typedef unsigned char   undefined;

typedef unsigned char    bool;
typedef unsigned char    byte;
typedef unsigned char    dwfenc;
typedef unsigned int    dword;
typedef long long    longlong;
typedef int    sdword;
typedef unsigned char    uchar;
typedef unsigned int    uint;
typedef unsigned long    ulong;
typedef unsigned long long    ulonglong;
typedef unsigned char    undefined1;
typedef unsigned short    undefined2;
typedef unsigned int    undefined3;
typedef unsigned int    undefined4;
typedef unsigned long long    undefined6;
typedef unsigned long long    undefined7;
typedef unsigned long long    undefined8;
typedef unsigned short    ushort;
typedef int    wchar_t;
typedef unsigned short    word;
typedef struct eh_frame_hdr eh_frame_hdr, *Peh_frame_hdr;

struct eh_frame_hdr {
    byte eh_frame_hdr_version; // Exception Handler Frame Header Version
    dwfenc eh_frame_pointer_encoding; // Exception Handler Frame Pointer Encoding
    dwfenc eh_frame_desc_entry_count_encoding; // Encoding of # of Exception Handler FDEs
    dwfenc eh_frame_table_encoding; // Exception Handler Table Encoding
};

typedef struct fde_table_entry fde_table_entry, *Pfde_table_entry;

struct fde_table_entry {
    dword initial_loc; // Initial Location
    dword data_loc; // Data location
};

typedef ushort sa_family_t;

typedef struct termios termios, *Ptermios;

typedef uint tcflag_t;

typedef uchar cc_t;

typedef uint speed_t;

struct termios {
    tcflag_t c_iflag;
    tcflag_t c_oflag;
    tcflag_t c_cflag;
    tcflag_t c_lflag;
    cc_t c_line;
    cc_t c_cc[32];
    speed_t c_ispeed;
    speed_t c_ospeed;
};

typedef void _IO_lock_t;

typedef struct _IO_marker _IO_marker, *P_IO_marker;

typedef struct _IO_FILE _IO_FILE, *P_IO_FILE;

typedef long __off_t;

typedef longlong __quad_t;

typedef __quad_t __off64_t;

typedef ulong size_t;

struct _IO_FILE {
    int _flags;
    char * _IO_read_ptr;
    char * _IO_read_end;
    char * _IO_read_base;
    char * _IO_write_base;
    char * _IO_write_ptr;
    char * _IO_write_end;
    char * _IO_buf_base;
    char * _IO_buf_end;
    char * _IO_save_base;
    char * _IO_backup_base;
    char * _IO_save_end;
    struct _IO_marker * _markers;
    struct _IO_FILE * _chain;
    int _fileno;
    int _flags2;
    __off_t _old_offset;
    ushort _cur_column;
    char _vtable_offset;
    char _shortbuf[1];
    _IO_lock_t * _lock;
    __off64_t _offset;
    void * __pad1;
    void * __pad2;
    void * __pad3;
    void * __pad4;
    size_t __pad5;
    int _mode;
    char _unused2[40];
};

struct _IO_marker {
    struct _IO_marker * _next;
    struct _IO_FILE * _sbuf;
    int _pos;
};

typedef struct stat64 stat64, *Pstat64;

typedef ulonglong __u_quad_t;

typedef __u_quad_t __dev_t;

typedef ulong __ino_t;

typedef uint __mode_t;

typedef uint __nlink_t;

typedef uint __uid_t;

typedef uint __gid_t;

typedef long __blksize_t;

typedef __quad_t __blkcnt64_t;

typedef struct timespec timespec, *Ptimespec;

typedef __u_quad_t __ino64_t;

typedef long __time_t;

struct timespec {
    __time_t tv_sec;
    long tv_nsec;
};

struct stat64 {
    __dev_t st_dev;
    uint __pad1;
    __ino_t __st_ino;
    __mode_t st_mode;
    __nlink_t st_nlink;
    __uid_t st_uid;
    __gid_t st_gid;
    __dev_t st_rdev;
    uint __pad2;
    __off64_t st_size;
    __blksize_t st_blksize;
    __blkcnt64_t st_blocks;
    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
    __ino64_t st_ino;
};

typedef struct addrinfo addrinfo, *Paddrinfo;

typedef uint __socklen_t;

typedef __socklen_t socklen_t;

typedef struct sockaddr sockaddr, *Psockaddr;

struct addrinfo {
    int ai_flags;
    int ai_family;
    int ai_socktype;
    int ai_protocol;
    socklen_t ai_addrlen;
    struct sockaddr * ai_addr;
    char * ai_canonname;
    struct addrinfo * ai_next;
};

struct sockaddr {
    sa_family_t sa_family;
    char sa_data[14];
};

typedef struct _IO_FILE FILE;

typedef int __ssize_t;

typedef __ssize_t ssize_t;

typedef int __pid_t;

typedef long __suseconds_t;

typedef long __clock_t;

typedef struct hostent hostent, *Phostent;

struct hostent {
    char * h_name;
    char * * h_aliases;
    int h_addrtype;
    int h_length;
    char * * h_addr_list;
};

typedef struct passwd passwd, *Ppasswd;

struct passwd {
    char * pw_name;
    char * pw_passwd;
    __uid_t pw_uid;
    __gid_t pw_gid;
    char * pw_gecos;
    char * pw_dir;
    char * pw_shell;
};

typedef struct evp_pkey_ctx_st evp_pkey_ctx_st, *Pevp_pkey_ctx_st;

struct evp_pkey_ctx_st {
};

typedef struct evp_pkey_ctx_st EVP_PKEY_CTX;

typedef int nl_item;

typedef struct dirent64 dirent64, *Pdirent64;

struct dirent64 {
    __ino64_t d_ino;
    __off64_t d_off;
    ushort d_reclen;
    uchar d_type;
    char d_name[256];
};

typedef struct __dirstream __dirstream, *P__dirstream;

struct __dirstream {
};

typedef struct __dirstream DIR;

typedef union _union_1031 _union_1031, *P_union_1031;

typedef struct _struct_1032 _struct_1032, *P_struct_1032;

typedef struct _struct_1033 _struct_1033, *P_struct_1033;

typedef struct _struct_1034 _struct_1034, *P_struct_1034;

typedef struct _struct_1035 _struct_1035, *P_struct_1035;

typedef struct _struct_1036 _struct_1036, *P_struct_1036;

typedef struct _struct_1037 _struct_1037, *P_struct_1037;

typedef union sigval sigval, *Psigval;

typedef union sigval sigval_t;

struct _struct_1032 {
    __pid_t si_pid;
    __uid_t si_uid;
};

union sigval {
    int sival_int;
    void * sival_ptr;
};

struct _struct_1033 {
    int si_tid;
    int si_overrun;
    sigval_t si_sigval;
};

struct _struct_1035 {
    __pid_t si_pid;
    __uid_t si_uid;
    int si_status;
    __clock_t si_utime;
    __clock_t si_stime;
};

struct _struct_1037 {
    long si_band;
    int si_fd;
};

struct _struct_1036 {
    void * si_addr;
};

struct _struct_1034 {
    __pid_t si_pid;
    __uid_t si_uid;
    sigval_t si_sigval;
};

union _union_1031 {
    int _pad[29];
    struct _struct_1032 _kill;
    struct _struct_1033 _timer;
    struct _struct_1034 _rt;
    struct _struct_1035 _sigchld;
    struct _struct_1036 _sigfault;
    struct _struct_1037 _sigpoll;
};

typedef struct siginfo siginfo, *Psiginfo;

struct siginfo {
    int si_signo;
    int si_errno;
    int si_code;
    union _union_1031 _sifields;
};

typedef struct siginfo siginfo_t;

typedef uint uLong;

typedef char BOOLEAN;


// WARNING! conflicting data type names: /DWARF/size_t - /stddef.h/size_t

typedef uint uInt;


// WARNING! conflicting data type names: /DWARF/__time_t - /types.h/__time_t

typedef uint mmask_t;


// WARNING! conflicting data type names: /DWARF/__off_t - /types.h/__off_t

typedef sdword int32_t;

typedef uchar LYEditCode;


// WARNING! conflicting data type names: /DWARF/__suseconds_t - /types.h/__suseconds_t

typedef int __fd_mask;


// WARNING! conflicting data type names: /DWARF/__clock_t - /types.h/__clock_t

typedef word uint16_t;

typedef bool _Bool;

typedef int HTCoord;

typedef uchar Byte;

typedef ushort PortNumber;


// WARNING! conflicting data type names: /DWARF/__blksize_t - /types.h/__blksize_t

typedef uint chtype;

typedef int TagFlags;

typedef int UCode_t;

typedef ushort LYKeymap_t;

typedef int HTColor;

typedef int TagClass;

typedef int HTFont;

typedef dword uint32_t;


// WARNING! conflicting data type names: /DWARF/__ino_t - /types.h/__ino_t

typedef struct bstring bstring, *Pbstring;

struct bstring {
    char * str;
    int len;
};

typedef struct bstring.conflict bstring.conflict, *Pbstring.conflict;

struct bstring.conflict {
    char * str;
    wchar_t len;
};

typedef struct _HTChunk.conflict _HTChunk.conflict, *P_HTChunk.conflict;

typedef struct _HTChunk.conflict HTChunk.conflict;

struct _HTChunk.conflict {
    wchar_t size;
    wchar_t growby;
    wchar_t allocated;
    char * data;
    wchar_t failok;
    HTChunk.conflict * next;
};

typedef struct _HTChunk _HTChunk, *P_HTChunk;

typedef struct _HTChunk HTChunk;

struct _HTChunk {
    int size;
    int growby;
    int allocated;
    char * data;
    int failok;
    HTChunk * next;
};

typedef struct _CSOfield_info _CSOfield_info, *P_CSOfield_info;

typedef struct _CSOfield_info CSOfield_info;

struct _CSOfield_info {
    struct _CSOfield_info * next;
    char * name;
    char * attributes;
    char * description;
    int id;
    int lookup;
    int indexed;
    int url;
    int max_size;
    int defreturn;
    int explicit_return;
    int reserved;
    int gpublic;
    char name_buf[16];
    char desc_buf[32];
    char attr_buf[80];
};

typedef struct _CSOformgen_context _CSOformgen_context, *P_CSOformgen_context;

struct _CSOformgen_context {
    char * host;
    char * seek;
    CSOfield_info * fld;
    int port;
    int cur_line;
    int cur_off;
    int rep_line;
    int rep_off;
    int public_override;
    int field_select;
};

typedef struct _CSOformgen_context CSOformgen_context;

typedef struct Kcmd Kcmd, *PKcmd;

typedef enum LYKeymapCode {
    LYK_UNKNOWN=0,
    LYK_COMMAND=1,
    LYK_1=2,
    LYK_2=3,
    LYK_3=4,
    LYK_4=5,
    LYK_5=6,
    LYK_6=7,
    LYK_7=8,
    LYK_8=9,
    LYK_9=10,
    LYK_SOURCE=11,
    LYK_RELOAD=12,
    LYK_QUIT=13,
    LYK_ABORT=14,
    LYK_NEXT_PAGE=15,
    LYK_PREV_PAGE=16,
    LYK_UP_TWO=17,
    LYK_DOWN_TWO=18,
    LYK_UP_HALF=19,
    LYK_DOWN_HALF=20,
    LYK_REFRESH=21,
    LYK_HOME=22,
    LYK_END=23,
    LYK_FIRST_LINK=24,
    LYK_LAST_LINK=25,
    LYK_PREV_LINK=26,
    LYK_NEXT_LINK=27,
    LYK_LPOS_PREV_LINK=28,
    LYK_LPOS_NEXT_LINK=29,
    LYK_FASTBACKW_LINK=30,
    LYK_FASTFORW_LINK=31,
    LYK_UP_LINK=32,
    LYK_DOWN_LINK=33,
    LYK_RIGHT_LINK=34,
    LYK_LEFT_LINK=35,
    LYK_HISTORY=36,
    LYK_PREV_DOC=37,
    LYK_NEXT_DOC=38,
    LYK_ACTIVATE=39,
    LYK_SUBMIT=40,
    LYK_GOTO=41,
    LYK_ECGOTO=42,
    LYK_HELP=43,
    LYK_DWIMHELP=44,
    LYK_INDEX=45,
    LYK_NOCACHE=46,
    LYK_INTERRUPT=47,
    LYK_MAIN_MENU=48,
    LYK_OPTIONS=49,
    LYK_INDEX_SEARCH=50,
    LYK_WHEREIS=51,
    LYK_PREV=52,
    LYK_NEXT=53,
    LYK_COMMENT=54,
    LYK_EDIT=55,
    LYK_INFO=56,
    LYK_PRINT=57,
    LYK_ADD_BOOKMARK=58,
    LYK_DEL_BOOKMARK=59,
    LYK_VIEW_BOOKMARK=60,
    LYK_VLINKS=61,
    LYK_SHELL=62,
    LYK_DOWNLOAD=63,
    LYK_TRACE_TOGGLE=64,
    LYK_TRACE_LOG=65,
    LYK_IMAGE_TOGGLE=66,
    LYK_INLINE_TOGGLE=67,
    LYK_HEAD=68,
    LYK_DO_NOTHING=69,
    LYK_TOGGLE_HELP=70,
    LYK_JUMP=71,
    LYK_KEYMAP=72,
    LYK_LIST=73,
    LYK_TOOLBAR=74,
    LYK_HISTORICAL=75,
    LYK_MINIMAL=76,
    LYK_SOFT_DQUOTES=77,
    LYK_RAW_TOGGLE=78,
    LYK_COOKIE_JAR=79,
    LYK_F_LINK_NUM=80,
    LYK_CLEAR_AUTH=81,
    LYK_SWITCH_DTD=82,
    LYK_ELGOTO=83,
    LYK_CHANGE_LINK=84,
    LYK_DWIMEDIT=85,
    LYK_EDIT_TEXTAREA=86,
    LYK_GROW_TEXTAREA=87,
    LYK_INSERT_FILE=88,
    LYK_EXTERN_LINK=89,
    LYK_EXTERN_PAGE=90,
    LYK_DIRED_MENU=91,
    LYK_CREATE=92,
    LYK_REMOVE=93,
    LYK_MODIFY=94,
    LYK_TAG_LINK=95,
    LYK_UPLOAD=96,
    LYK_INSTALL=97,
    LYK_CHG_CENTER=98,
    LYK_CHDIR=99,
    LYK_SHIFT_LEFT=100,
    LYK_SHIFT_RIGHT=101,
    LYK_LINEWRAP_TOGGLE=102,
    LYK_PASTE_URL=103,
    LYK_TO_CLIPBOARD=104,
    LYK_NESTED_TABLES=105
} LYKeymapCode;

struct Kcmd {
    enum LYKeymapCode code;
    char * name;
    char * doc;
};

typedef struct _HTStream _HTStream, *P_HTStream;

typedef struct _HTStream HTStream;

typedef struct _HTStreamClass _HTStreamClass, *P_HTStreamClass;

typedef void * HTError;

typedef struct _HTStreamClass HTStreamClass;

struct _HTStreamClass {
    char * name;
    void (* _free)(HTStream *);
    void (* _abort)(HTStream *, HTError);
    void (* put_character)(HTStream *, char);
    void (* put_string)(HTStream *, char *);
    void (* put_block)(HTStream *, char *, wchar_t);
};

struct _HTStream {
    HTStreamClass * isa;
};

typedef struct _HTStream.conflict _HTStream.conflict, *P_HTStream.conflict;

typedef struct _HTStream.conflict HTStream.conflict;

typedef struct _HTStreamClass.conflict _HTStreamClass.conflict, *P_HTStreamClass.conflict;

typedef struct _HTStreamClass.conflict HTStreamClass.conflict;

typedef struct _HTParentAnchor _HTParentAnchor, *P_HTParentAnchor;

typedef struct _HTParentAnchor HTParentAnchor;


// WARNING! conflicting data type names: /DWARF/stdio.h/FILE - /stdio.h/FILE

typedef struct _HTParentAnchor0 _HTParentAnchor0, *P_HTParentAnchor0;

typedef struct _HTParentAnchor0 HTParentAnchor0;

typedef struct _HTList _HTList, *P_HTList;

typedef struct _HTList HTList;

typedef struct _HyperDoc _HyperDoc, *P_HyperDoc;

typedef struct _HyperDoc HyperDoc;

typedef struct _HTAtom _HTAtom, *P_HTAtom;

typedef struct _HTAtom HTAtom;

typedef HTAtom * HTFormat;

typedef struct _UCAnchorInfo _UCAnchorInfo, *P_UCAnchorInfo;

typedef struct _UCAnchorInfo UCAnchorInfo;

typedef struct _HTBTree_top _HTBTree_top, *P_HTBTree_top;

typedef struct _HTBTree_top HTBTree;

typedef struct _UCStageInfo _UCStageInfo, *P_UCStageInfo;

typedef int (* HTComparer)(void *, void *);

typedef struct _HTBTree_element _HTBTree_element, *P_HTBTree_element;

typedef struct _LYUCcharset _LYUCcharset, *P_LYUCcharset;

typedef struct _LYUCcharset LYUCcharset;

struct _HTStreamClass.conflict {
    char * name;
    void (* _free)(HTStream.conflict *);
    void (* _abort)(HTStream.conflict *, HTError);
    void (* put_character)(HTStream.conflict *, char);
    void (* put_string)(HTStream.conflict *, char *);
    void (* put_block)(HTStream.conflict *, char *, int);
};

struct _HTBTree_top {
    HTComparer compare;
    struct _HTBTree_element * top;
};

struct _LYUCcharset {
    int UChndl;
    char * MIMEname;
    int enc;
    int codepage;
    int repertoire;
    int codepoints;
    int cpranges;
    int like8859;
};

struct _UCStageInfo {
    int lock;
    int LYhndl;
    LYUCcharset C;
};

struct _HTBTree_element {
    void * object;
    struct _HTBTree_element * up;
    struct _HTBTree_element * left;
    int left_depth;
    struct _HTBTree_element * right;
    int right_depth;
};

struct _UCAnchorInfo {
    struct _UCStageInfo s[4];
};

struct _HyperDoc {
};

struct _HTAtom {
    HTAtom * next;
    char * name;
};

struct _HTList {
    void * object;
    HTList * next;
};

struct _HTParentAnchor0 {
    HTParentAnchor0 * parent;
    char * address;
    HTParentAnchor * info;
    HTBTree * children;
    HTList sources;
    HTList _add_adult;
    short adult_hash;
    BOOLEAN underway;
};

struct _HTStream.conflict {
    HTStreamClass.conflict * isa;
    HTParentAnchor * anchor;
    FILE * fp;
    char * filename;
    HTChunk * chunk;
    HTChunk * last_chunk;
    HTStreamClass.conflict * actions;
    HTStream.conflict * target;
    int status;
};

struct _HTParentAnchor {
    HTParentAnchor0 * parent;
    HTList children_notag;
    HyperDoc * document;
    char * address;
    struct bstring * post_data;
    char * post_content_type;
    char * bookmark;
    HTFormat format;
    char * charset;
    BOOLEAN isIndex;
    char * isIndexAction;
    char * isIndexPrompt;
    char * title;
    char * owner;
    char * RevTitle;
    char * citehost;
    char * style;
    HTList * methods;
    void * protocol;
    char * physical;
    BOOLEAN isISMAPScript;
    BOOLEAN isHEAD;
    BOOLEAN safe;
    char * source_cache_file;
    HTChunk * source_cache_chunk;
    char * FileCache;
    char * SugFname;
    char * cache_control;
    BOOLEAN no_cache;
    BOOLEAN inBASE;
    char * content_type_params;
    char * content_type;
    char * content_language;
    char * content_encoding;
    char * content_base;
    char * content_disposition;
    char * content_location;
    char * content_md5;
    char * message_id;
    char * subject;
    int content_length;
    char * date;
    char * expires;
    char * last_modified;
    char * ETag;
    char * server;
    UCAnchorInfo * UCStages;
    HTList * imaps;
};

typedef struct _HTStream.conflict2 _HTStream.conflict2, *P_HTStream.conflict2;

typedef struct _HTStreamClass.conflict2 _HTStreamClass.conflict2, *P_HTStreamClass.conflict2;

typedef struct _HTStream.conflict2 HTStream.conflict2;

typedef struct _HTStreamClass.conflict2 HTStreamClass.conflict2;

typedef struct SGML_dtd SGML_dtd, *PSGML_dtd;

typedef struct _HTStructuredClass _HTStructuredClass, *P_HTStructuredClass;

typedef struct _HTStructured _HTStructured, *P_HTStructured;

typedef struct _HTStructured HTStructured;

typedef struct _HTStructuredClass HTStructuredClass;

typedef struct _tag _tag, *P_tag;

typedef struct _tag HTTag;

typedef struct _HTElement _HTElement, *P_HTElement;

typedef struct _HTElement HTElement;

typedef enum sgml_state {
    S_text=0,
    S_attr=1,
    S_attr_gap=2,
    S_comment=3,
    S_cro=4,
    S_doctype=5,
    S_dollar=6,
    S_dollar_dq=7,
    S_dollar_paren=8,
    S_dollar_paren_dq=9,
    S_dollar_paren_sq=10,
    S_dollar_sq=11,
    S_dquoted=12,
    S_end=13,
    S_entity=14,
    S_equals=15,
    S_ero=16,
    S_esc=17,
    S_esc_dq=18,
    S_esc_sq=19,
    S_exclamation=20,
    S_in_kanji=21,
    S_incro=22,
    S_junk_tag=23,
    S_litteral=24,
    S_marked=25,
    S_nonascii_text=26,
    S_nonascii_text_dq=27,
    S_nonascii_text_sq=28,
    S_paren=29,
    S_paren_dq=30,
    S_paren_sq=31,
    S_pcdata=32,
    S_pi=33,
    S_script=34,
    S_sgmlatt=35,
    S_sgmlele=36,
    S_sgmlent=37,
    S_squoted=38,
    S_tag=39,
    S_tag_gap=40,
    S_tagname_slash=41,
    S_value=42
} sgml_state;

typedef struct _UCTransParams _UCTransParams, *P_UCTransParams;

typedef struct _UCTransParams UCTransParams;

typedef struct _HText _HText, *P_HText;

typedef struct _HText HText;

typedef struct _HTStreamClass.conflict1 _HTStreamClass.conflict1, *P_HTStreamClass.conflict1;

typedef struct _HTStreamClass.conflict1 HTStreamClass.conflict1;

typedef struct HTChildAnchor HTChildAnchor, *PHTChildAnchor;

typedef struct _HTStyle _HTStyle, *P_HTStyle;

typedef struct _HTStyle HTStyle;

typedef struct _stack_element _stack_element, *P_stack_element;

typedef struct _stack_element stack_element;

typedef struct attr attr, *Pattr;

typedef struct attr * AttrList;

typedef struct AttrType AttrType, *PAttrType;

typedef enum SGMLContent {
    SGML_EMPTY=0,
    SGML_LITTERAL=1,
    SGML_CDATA=2,
    SGML_SCRIPT=3,
    SGML_RCDATA=4,
    SGML_MIXED=5,
    SGML_ELEMENT=6,
    SGML_PCDATA=7
} SGMLContent;

typedef struct _line _line, *P_line;

typedef struct _line HTLine;

typedef struct HTLineTemp HTLineTemp, *PHTLineTemp;

typedef struct _TextAnchor _TextAnchor, *P_TextAnchor;

typedef struct _TextAnchor TextAnchor;

typedef struct _STable_info _STable_info, *P_STable_info;

typedef struct _STable_info STable_info;

typedef enum HTkcode {
    NOKANJI=0,
    EUC=1,
    SJIS=2,
    JIS=3
} HTkcode;

typedef enum eDetectedKCode {
    DET_SJIS=0,
    DET_EUC=1,
    DET_NOTYET=2,
    DET_MIXED=3
} eDetectedKCode;

typedef enum eSJIS_status {
    SJIS_state_neutral=0,
    SJIS_state_in_kanji=1,
    SJIS_state_has_bad_code=2
} eSJIS_status;

typedef enum eEUC_status {
    EUC_state_neutral=0,
    EUC_state_in_kanji=1,
    EUC_state_in_kana=2,
    EUC_state_has_bad_code=3
} eEUC_status;

typedef enum eGridState {
    S_text=0,
    S_esc=1,
    S_dollar=2,
    S_paren=3,
    S_nonascii_text=4,
    S_dollar_paren=5,
    S_jisx0201_text=6
} eGridState;

typedef struct _LYUCcharset.conflict _LYUCcharset.conflict, *P_LYUCcharset.conflict;

typedef struct _LYUCcharset.conflict LYUCcharset.conflict;

typedef struct _HTPool _HTPool, *P_HTPool;

typedef struct _HTPool HTPool;

typedef struct _HTAnchor _HTAnchor, *P_HTAnchor;

typedef struct _HTAnchor HTAnchor;

typedef HTAtom HTLinkType;

typedef struct HTTabStop HTTabStop, *PHTTabStop;

typedef struct HTStyleChange HTStyleChange, *PHTStyleChange;

typedef struct _FormInfo.conflict _FormInfo.conflict, *P_FormInfo.conflict;

typedef struct _FormInfo.conflict FormInfo;

typedef struct HiliteList HiliteList, *PHiliteList;

typedef struct _STable_cellinfo _STable_cellinfo, *P_STable_cellinfo;

typedef struct _STable_cellinfo STable_cellinfo;

typedef struct _STable_rowinfo _STable_rowinfo, *P_STable_rowinfo;

typedef struct _STable_rowinfo STable_rowinfo;

typedef struct _STable_states _STable_states, *P_STable_states;

typedef struct _STable_states STable_states;

typedef struct HTStyleChange pool_data;

typedef struct _OptionType.conflict _OptionType.conflict, *P_OptionType.conflict;

typedef struct _OptionType.conflict OptionType.conflict;

typedef struct HiliteInfo HiliteInfo, *PHiliteInfo;

typedef enum ended_state {
    ROW_not_ended=0,
    ROW_ended_by_endtr=1,
    ROW_ended_by_splitline=2
} ended_state;

typedef enum cellstate_t {
    CS_invalid=-1,
    CS__new=0,
    CS__0new=1,
    CS__0eb=2,
    CS__eb=3,
    CS__0cb=4,
    CS__cb=5,
    CS__0ef=6,
    CS__ef=7,
    CS__0cf=8,
    CS__cf=9,
    CS__ebc=10,
    CS__cbc=11
} cellstate_t;

struct _STable_states {
    enum cellstate_t prev_state;
    enum cellstate_t state;
    int lineno;
    int icell_core;
    int x_td;
    int pending_len;
};

struct _STable_rowinfo {
    int Line;
    int ncells;
    BOOLEAN fixed_line;
    enum ended_state ended;
    int content;
    int offset;
    int allocated;
    STable_cellinfo * cells;
    int alignment;
};

struct _STable_info {
    struct _STable_info * enclosing;
    struct _TextAnchor * enclosing_last_anchor_before_stbl;
    int startline;
    int nrows;
    int ncols;
    int maxlen;
    int maxpos;
    int allocated_rows;
    int allocated_sumcols;
    int ncolinfo;
    STable_cellinfo * sumcols;
    STable_rowinfo * rows;
    STable_rowinfo rowspans2eog;
    short alignment;
    short rowgroup_align;
    short pending_colgroup_align;
    int pending_colgroup_next;
    STable_states s;
};

struct HiliteInfo {
    char * hl_text;
    short hl_x;
};

struct HiliteList {
    struct HiliteInfo * hl_info;
    struct HiliteInfo hl_base;
    short hl_len;
};

struct _stack_element {
    HTStyle * style;
    int tag_number;
};

struct _LYUCcharset.conflict {
    wchar_t UChndl;
    char * MIMEname;
    wchar_t enc;
    wchar_t codepage;
    wchar_t repertoire;
    wchar_t codepoints;
    wchar_t cpranges;
    wchar_t like8859;
};

struct _HTStreamClass.conflict1 {
    char * name;
    void (* _free)(HTStream *);
    void (* _abort)(HTStream *, HTError);
    void (* put_character)(HTStream *, char);
    void (* put_string)(HTStream *, char *);
    void (* put_block)(HTStream *, char *, int);
};

struct _HTStreamClass.conflict2 {
    char * name;
    void (* _free)(HTStream.conflict2 *);
    void (* _abort)(HTStream.conflict2 *, HTError);
    void (* put_character)(HTStream.conflict2 *, char);
    void (* put_string)(HTStream.conflict2 *, char *);
    void (* put_block)(HTStream.conflict2 *, char *, int);
};

struct SGML_dtd {
    HTTag * tags;
    int number_of_tags;
    char * * entity_names;
    size_t number_of_entities;
};

struct _FormInfo.conflict {
    char * name;
    wchar_t number;
    wchar_t type;
    char * value;
    char * orig_value;
    wchar_t size;
    uint maxlength;
    wchar_t group;
    wchar_t num_value;
    wchar_t hrange;
    wchar_t lrange;
    OptionType.conflict * select_list;
    char * submit_action;
    wchar_t submit_method;
    char * submit_enctype;
    char * submit_title;
    BOOLEAN no_cache;
    char * cp_submit_value;
    char * orig_submit_value;
    wchar_t size_l;
    wchar_t disabled;
    wchar_t name_cs;
    wchar_t value_cs;
    char * accept_cs;
};

struct _UCTransParams {
    BOOLEAN transp;
    BOOLEAN do_cjk;
    BOOLEAN decode_utf8;
    BOOLEAN output_utf8;
    BOOLEAN use_raw_char_in;
    BOOLEAN strip_raw_char_in;
    BOOLEAN pass_160_173_raw;
    BOOLEAN do_8bitraw;
    BOOLEAN trans_to_uni;
    BOOLEAN trans_C0_to_uni;
    BOOLEAN repl_translated_C0;
    BOOLEAN trans_from_uni;
};

struct _OptionType.conflict {
    char * name;
    char * cp_submit_value;
    wchar_t value_cs;
    struct _OptionType.conflict * next;
};

struct _line {
    struct _line * next;
    struct _line * prev;
    ushort offset;
    ushort size;
    struct HTStyleChange * styles;
    ushort numstyles;
    char data[1];
};

struct HTLineTemp {
    HTLine base;
    char data[1026];
};

struct attr {
    char * name;
    char type;
};

struct _HTStructured {
    HTStructuredClass * isa;
    HTParentAnchor * node_anchor;
    HText * text;
    HTStream * target;
    HTStreamClass.conflict1 targetClass;
    struct HTChildAnchor * CurrentA;
    int CurrentANum;
    char * base_href;
    char * map_address;
    HTChunk title;
    HTChunk object;
    BOOLEAN object_started;
    BOOLEAN object_declare;
    BOOLEAN object_shapes;
    BOOLEAN object_ismap;
    char * object_usemap;
    char * object_id;
    char * object_title;
    char * object_data;
    char * object_type;
    char * object_classid;
    char * object_codebase;
    char * object_codetype;
    char * object_name;
    int objects_mixed_open;
    int objects_figged_open;
    HTChunk option;
    BOOLEAN first_option;
    char * LastOptionValue;
    BOOLEAN LastOptionChecked;
    BOOLEAN select_disabled;
    HTChunk textarea;
    char * textarea_name;
    int textarea_name_cs;
    char * textarea_accept_cs;
    int textarea_cols;
    int textarea_rows;
    int textarea_disabled;
    char * textarea_id;
    HTChunk math;
    HTChunk style_block;
    HTChunk script;
    int List_Nesting_Level;
    int OL_Counter[12];
    char OL_Type[12];
    int Last_OL_Count;
    char Last_OL_Type;
    int Division_Level;
    short DivisionAlignments[800];
    int Underline_Level;
    int Quote_Level;
    BOOLEAN UsePlainSpace;
    BOOLEAN HiddenValue;
    int lastraw;
    char * comment_start;
    char * comment_end;
    HTTag * current_tag;
    BOOLEAN style_change;
    HTStyle * new_style;
    HTStyle * old_style;
    int current_default_alignment;
    BOOLEAN in_word;
    stack_element stack[800];
    stack_element * sp;
    BOOLEAN stack_overrun;
    int skip_stack;
    BOOLEAN inA;
    BOOLEAN inAPPLET;
    BOOLEAN inAPPLETwithP;
    BOOLEAN inBadBASE;
    BOOLEAN inBadHREF;
    BOOLEAN inBadHTML;
    BOOLEAN inBASE;
    BOOLEAN inBoldA;
    BOOLEAN inBoldH;
    BOOLEAN inCAPTION;
    BOOLEAN inCREDIT;
    BOOLEAN inFIG;
    BOOLEAN inFIGwithP;
    BOOLEAN inFONT;
    BOOLEAN inFORM;
    BOOLEAN inLABEL;
    BOOLEAN inP;
    BOOLEAN inPRE;
    BOOLEAN inSELECT;
    BOOLEAN inTABLE;
    BOOLEAN inTEXTAREA;
    BOOLEAN inUnderline;
    BOOLEAN needBoldH;
    char * xinclude;
    LYUCcharset * UCI;
    int UCLYhndl;
    LYUCcharset * inUCI;
    int inUCLYhndl;
    LYUCcharset * outUCI;
    int outUCLYhndl;
    UCTransParams T;
    int tag_charset;
};

struct _HTStructuredClass {
    char * name;
    void (* _free)(HTStructured *);
    void (* _abort)(HTStructured *, HTError);
    void (* put_character)(HTStructured *, char);
    void (* put_string)(HTStructured *, char *);
    void (* put_block)(HTStructured *, char *, int);
    int (* start_element)(HTStructured *, int, BOOLEAN *, char * *, int, char * *);
    int (* end_element)(HTStructured *, int, char * *);
    int (* put_entity)(HTStructured *, int);
};

struct _HTStyle {
    struct _HTStyle * next;
    char * name;
    int id;
    char * SGMLTag;
    HTFont font;
    HTCoord fontSize;
    HTColor color;
    int superscript;
    HTAnchor * anchor;
    HTCoord indent1st;
    HTCoord leftIndent;
    HTCoord rightIndent;
    short alignment;
    HTCoord lineHt;
    HTCoord descentLine;
    struct HTTabStop * tabs;
    BOOLEAN wordWrap;
    BOOLEAN freeFormat;
    HTCoord spaceBefore;
    HTCoord spaceAfter;
    int paraFlags;
};

struct _HText {
    HTParentAnchor * node_anchor;
    HTLine * last_line;
    struct HTLineTemp temp_line[2];
    wchar_t Lines;
    TextAnchor * first_anchor;
    TextAnchor * last_anchor;
    TextAnchor * last_anchor_before_stbl;
    TextAnchor * last_anchor_before_split;
    HTList * forms;
    wchar_t last_anchor_number;
    BOOLEAN source;
    BOOLEAN toolbar;
    HTList * tabs;
    HTList * hidden_links;
    wchar_t hiddenlinkflag;
    BOOLEAN no_cache;
    char LastChar;
    BOOLEAN IgnoreExcess;
    HTStyle * style;
    wchar_t display_on_the_fly;
    wchar_t top_of_screen;
    HTLine * top_of_screen_line;
    HTLine * next_line;
    uint permissible_split;
    BOOLEAN in_line_1;
    BOOLEAN stale;
    BOOLEAN page_has_target;
    BOOLEAN has_utf8;
    BOOLEAN had_utf8;
    wchar_t first_lineno_last_disp_partial;
    wchar_t last_lineno_last_disp_partial;
    STable_info * stbl;
    HTList * enclosed_stbl;
    enum HTkcode kcode;
    enum HTkcode specified_kcode;
    enum eDetectedKCode detected_kcode;
    enum eSJIS_status SJIS_status;
    enum eEUC_status EUC_status;
    enum eGridState state;
    wchar_t kanji_buf;
    wchar_t in_sjis;
    wchar_t halted;
    BOOLEAN have_8bit_chars;
    LYUCcharset.conflict * UCI;
    wchar_t UCLYhndl;
    UCTransParams T;
    HTStream * target;
    HTStreamClass targetClass;
    HTPool * pool;
    BOOLEAN clickable_images;
    BOOLEAN pseudo_inline_alts;
    BOOLEAN verbose_img;
    BOOLEAN raw_mode;
    BOOLEAN historical_comments;
    BOOLEAN minimal_comments;
    BOOLEAN soft_dquotes;
    short old_dtd;
    short keypad_mode;
    short disp_lines;
    short disp_cols;
};

struct _HTAnchor {
    HTParentAnchor0 * parent;
};

struct _HTElement {
    HTElement * next;
    HTTag * tag;
};

struct HTStyleChange {
    uint direction:2;
    uint horizpos:14;
    uint style:16;
};

struct _STable_cellinfo {
    int cLine;
    int pos;
    int len;
    int colspan;
    int alignment;
};

struct AttrType {
    char * name;
    AttrList list;
};

struct HTTabStop {
    short kind;
    HTCoord position;
};

struct _HTPool {
    pool_data data[2042];
    struct _HTPool * prev;
    wchar_t used;
};

struct _tag {
    char * name;
    int name_len;
    BOOLEAN can_justify;
    AttrList attributes;
    int number_of_attributes;
    struct AttrType * attr_types;
    enum SGMLContent contents;
    TagClass tagclass;
    TagClass contains;
    TagClass icontains;
    TagClass contained;
    TagClass icontained;
    TagClass canclose;
    TagFlags flags;
};

struct _HTStream.conflict2 {
    HTStreamClass.conflict2 * isa;
    struct SGML_dtd * dtd;
    HTStructuredClass * actions;
    HTStructured * target;
    HTTag * current_tag;
    HTTag * slashedtag;
    HTTag * unknown_tag;
    BOOLEAN extended_html;
    BOOLEAN strict_xml;
    BOOLEAN inSELECT;
    BOOLEAN no_lynx_specialcodes;
    int current_attribute_number;
    HTChunk * string;
    int leading_spaces;
    int trailing_spaces;
    HTElement * element_stack;
    enum sgml_state state;
    uchar kanji_buf;
    BOOLEAN present[36];
    char * value[36];
    BOOLEAN lead_exclamation;
    BOOLEAN first_dash;
    BOOLEAN end_comment;
    BOOLEAN doctype_bracket;
    BOOLEAN first_bracket;
    BOOLEAN second_bracket;
    BOOLEAN isHex;
    HTParentAnchor * node_anchor;
    LYUCcharset * inUCI;
    int inUCLYhndl;
    LYUCcharset * outUCI;
    int outUCLYhndl;
    char utf_count;
    UCode_t utf_char;
    char utf_buf[8];
    char * utf_buf_p;
    UCTransParams T;
    int current_tag_charset;
    char * recover;
    int recover_index;
    char * include;
    char * active_include;
    int include_index;
    char * url;
    char * csi;
    int csi_index;
    BOOLEAN cur_attr_is_href;
    BOOLEAN cur_attr_is_name;
};

struct HTChildAnchor {
    HTParentAnchor0 * parent;
    char * tag;
    HTAnchor * dest;
    HTLinkType * type;
    HTList _add_children_notag;
    HTList _add_sources;
};

struct _TextAnchor {
    struct _TextAnchor * next;
    struct _TextAnchor * prev;
    wchar_t sgml_offset;
    wchar_t number;
    wchar_t line_num;
    short line_pos;
    short extent;
    BOOLEAN show_anchor;
    BOOLEAN inUnderline;
    BOOLEAN expansion_anch;
    char link_type;
    FormInfo * input_field;
    struct HiliteList lites;
    struct HTChildAnchor * anchor;
};

typedef struct _HTStream.conflict1 _HTStream.conflict1, *P_HTStream.conflict1;

typedef struct _HTStream.conflict1 HTStream.conflict1;

struct _HTStream.conflict1 {
    HTStreamClass.conflict * isa;
    FILE * fp;
    char * end_command;
    char * remove_command;
    char * viewer_command;
    HTFormat input_format;
    HTFormat output_format;
    HTParentAnchor * anchor;
    HTStream.conflict1 * sink;
};

typedef struct _HTStream.conflict6 _HTStream.conflict6, *P_HTStream.conflict6;

typedef struct _HTStream.conflict6 HTStream.conflict6;

typedef struct _HTStreamClass.conflict5 _HTStreamClass.conflict5, *P_HTStreamClass.conflict5;

typedef struct _HTStreamClass.conflict5 HTStreamClass.conflict5;

typedef enum MIME_state {
    MIME_TRANSPARENT=0,
    MIME_CHUNKED=1,
    mcCHUNKED_COUNT_DIGIT=2,
    mcCHUNKED_COUNT_CR=3,
    mcCHUNKED_COUNT_LF=4,
    mcCHUNKED_EXTENSION=5,
    mcCHUNKED_DATA=6,
    mcCHUNKED_DATA_CR=7,
    mcCHUNKED_DATA_LF=8,
    miBEGINNING_OF_LINE=9,
    miA=10,
    miACCEPT_RANGES=11,
    miAGE=12,
    miAL=13,
    miALLOW=14,
    miALTERNATES=15,
    miC=16,
    miCACHE_CONTROL=17,
    miCO=18,
    miCOOKIE=19,
    miCON=20,
    miCONNECTION=21,
    miCONTENT_=22,
    miCONTENT_BASE=23,
    miCONTENT_DISPOSITION=24,
    miCONTENT_ENCODING=25,
    miCONTENT_FEATURES=26,
    miCONTENT_L=27,
    miCONTENT_LANGUAGE=28,
    miCONTENT_LENGTH=29,
    miCONTENT_LOCATION=30,
    miCONTENT_MD5=31,
    miCONTENT_RANGE=32,
    miCONTENT_T=33,
    miCONTENT_TRANSFER_ENCODING=34,
    miCONTENT_TYPE=35,
    miDATE=36,
    miE=37,
    miETAG=38,
    miEXPIRES=39,
    miKEEP_ALIVE=40,
    miL=41,
    miLAST_MODIFIED=42,
    miLINK=43,
    miLOCATION=44,
    miP=45,
    miPR=46,
    miPRAGMA=47,
    miPROXY_AUTHENTICATE=48,
    miPUBLIC=49,
    miR=50,
    miRE=51,
    miREFRESH=52,
    miRETRY_AFTER=53,
    miS=54,
    miSAFE=55,
    miSE=56,
    miSERVER=57,
    miSET_COOKIE=58,
    miSET_COOKIE1=59,
    miSET_COOKIE2=60,
    miT=61,
    miTITLE=62,
    miTRANSFER_ENCODING=63,
    miU=64,
    miUPGRADE=65,
    miURI=66,
    miV=67,
    miVARY=68,
    miVIA=69,
    miW=70,
    miWARNING=71,
    miWWW_AUTHENTICATE=72,
    miSKIP_GET_VALUE=73,
    miGET_VALUE=74,
    miJUNK_LINE=75,
    miNEWLINE=76,
    miCHECK=77,
    MIME_NET_ASCII=78,
    MIME_IGNORE=79
} MIME_state;

struct _HTStreamClass.conflict5 {
    char * name;
    void (* _free)(HTStream.conflict6 *);
    void (* _abort)(HTStream.conflict6 *, HTError);
    void (* put_character)(HTStream.conflict6 *, char);
    void (* put_string)(HTStream.conflict6 *, char *);
    void (* put_block)(HTStream.conflict6 *, char *, int);
};

struct _HTStream.conflict6 {
    HTStreamClass.conflict5 * isa;
    BOOLEAN net_ascii;
    enum MIME_state state;
    enum MIME_state if_ok;
    enum MIME_state field;
    enum MIME_state fold_state;
    BOOLEAN head_only;
    BOOLEAN pickup_redirection;
    BOOLEAN no_streamstack;
    char * check_pointer;
    char * value_pointer;
    char value[5120];
    HTParentAnchor * anchor;
    HTStream.conflict6 * sink;
    char * boundary;
    char * set_cookie;
    char * set_cookie2;
    char * location;
    char * refresh_url;
    HTFormat c_t_encoding;
    char * compression_encoding;
    BOOLEAN chunked_encoding;
    long chunked_size;
    HTFormat format;
    HTStream.conflict6 * target;
    HTStreamClass.conflict5 targetClass;
    HTAtom * targetRep;
};

typedef struct _HTStreamClass.conflict4 _HTStreamClass.conflict4, *P_HTStreamClass.conflict4;

typedef struct _HTStream.conflict4 _HTStream.conflict4, *P_HTStream.conflict4;

typedef struct _HTStream.conflict4 HTStream.conflict4;

typedef struct _HTStreamClass.conflict4 HTStreamClass.conflict4;

struct _HTStreamClass.conflict4 {
    char * name;
    void (* _free)(HTStream.conflict4 *);
    void (* _abort)(HTStream.conflict4 *, HTError);
    void (* put_character)(HTStream.conflict4 *, char);
    void (* put_string)(HTStream.conflict4 *, char *);
    void (* put_block)(HTStream.conflict4 *, char *, int);
};

struct _HTStream.conflict4 {
    HTStreamClass.conflict4 * isa;
    HTStream.conflict4 * target;
    HTStreamClass.conflict4 targetClass;
};

typedef struct _HTStream.conflict3 _HTStream.conflict3, *P_HTStream.conflict3;

typedef struct _HTStreamClass.conflict3 _HTStreamClass.conflict3, *P_HTStreamClass.conflict3;

typedef struct _HTStream.conflict3 HTStream.conflict3;

typedef struct _HTStreamClass.conflict3 HTStreamClass.conflict3;

struct _HTStreamClass.conflict3 {
    char * name;
    void (* _free)(HTStream.conflict3 *);
    void (* _abort)(HTStream.conflict3 *, HTError);
    void (* put_character)(HTStream.conflict3 *, char);
    void (* put_string)(HTStream.conflict3 *, char *);
    void (* put_block)(HTStream.conflict3 *, char *, int);
};

struct _HTStream.conflict3 {
    HTStreamClass.conflict3 * isa;
    HText * text;
    LYUCcharset * inUCI;
    int inUCLYhndl;
    LYUCcharset * outUCI;
    int outUCLYhndl;
    char utf_count;
    UCode_t utf_char;
    char utf_buf[8];
    char * utf_buf_p;
    UCTransParams T;
};

typedef struct _HTStreamClass.conflict6 _HTStreamClass.conflict6, *P_HTStreamClass.conflict6;

typedef struct _HTStream.conflict7 _HTStream.conflict7, *P_HTStream.conflict7;

typedef struct _HTStream.conflict7 HTStream.conflict7;

typedef struct _HTStreamClass.conflict6 HTStreamClass.conflict6;

typedef struct _HTStructured.conflict _HTStructured.conflict, *P_HTStructured.conflict;

typedef struct _HTStructured.conflict HTStructured.conflict;

typedef enum tokenstate {
    beginning=0,
    before_tag=1,
    colon=2,
    before_value=3,
    value=4,
    bracketed_value=5,
    quoted_value=6,
    escape_in_quoted=7,
    done=8
} tokenstate;

typedef struct _HTStructuredClass.conflict _HTStructuredClass.conflict, *P_HTStructuredClass.conflict;

typedef struct _HTStructuredClass.conflict HTStructuredClass.conflict;

struct _HTStructured.conflict {
    HTStructuredClass.conflict * isa;
};

struct _HTStream.conflict7 {
    HTStreamClass.conflict6 * isa;
    HTStructured.conflict * target;
    char * par_value[23];
    enum tokenstate state;
    char param[10001];
    int param_number;
    int param_count;
};

struct _HTStreamClass.conflict6 {
    char * name;
    void (* _free)(HTStream.conflict7 *);
    void (* _abort)(HTStream.conflict7 *, HTError);
    void (* put_character)(HTStream.conflict7 *, char);
    void (* put_string)(HTStream.conflict7 *, char *);
    void (* put_block)(HTStream.conflict7 *, char *, int);
};

struct _HTStructuredClass.conflict {
    char * name;
    void (* _free)(HTStructured.conflict *);
    void (* _abort)(HTStructured.conflict *, HTError);
    void (* put_character)(HTStructured.conflict *, char);
    void (* put_string)(HTStructured.conflict *, char *);
    void (* put_block)(HTStructured.conflict *, char *, int);
    int (* start_element)(HTStructured.conflict *, int, BOOLEAN *, char * *, int, char * *);
    int (* end_element)(HTStructured.conflict *, int, char * *);
    int (* put_entity)(HTStructured.conflict *, int);
};

typedef struct _HTStream.conflict5 _HTStream.conflict5, *P_HTStream.conflict5;

typedef struct _HTStream.conflict5 HTStream.conflict5;

struct _HTStream.conflict5 {
    HTStreamClass.conflict4 * isa;
    BOOLEAN had_cr;
    HTStream.conflict5 * sink;
};

typedef __ino64_t ino_t;

typedef __uid_t uid_t;

typedef __off64_t off_t;

typedef __gid_t gid_t;

typedef __mode_t mode_t;

typedef __dev_t dev_t;

typedef __pid_t pid_t;

typedef struct anon_struct_8_2_e0c85072 anon_struct_8_2_e0c85072, *Panon_struct_8_2_e0c85072;

struct anon_struct_8_2_e0c85072 {
    int color;
    char * type;
};

typedef struct anon_struct_12_3_4c767f75 anon_struct_12_3_4c767f75, *Panon_struct_12_3_4c767f75;

struct anon_struct_12_3_4c767f75 {
    char * name;
    int style;
    int * set_hash;
};


// WARNING! conflicting data type names: /DWARF/dirent.h/DIR - /dirent.h/DIR

typedef struct dirent dirent, *Pdirent;

struct dirent {
    __ino64_t d_ino;
    __off64_t d_off;
    ushort d_reclen;
    uchar d_type;
    char d_name[256];
};

typedef enum _login_protocol {
    telnet=0,
    rlogin=1,
    tn3270=2
} _login_protocol;


// WARNING! conflicting data type names: /DWARF/siginfo.h/sigval_t - /siginfo.h/sigval_t


// WARNING! conflicting data type names: /DWARF/siginfo.h/siginfo - /siginfo.h/siginfo


// WARNING! conflicting data type names: /DWARF/siginfo.h/siginfo_t - /siginfo.h/siginfo_t


// WARNING! conflicting data type names: /DWARF/siginfo.h/sigval - /siginfo.h/sigval

typedef union anon_union_116_7_b489c2e4_for__sifields anon_union_116_7_b489c2e4_for__sifields, *Panon_union_116_7_b489c2e4_for__sifields;

typedef struct anon_struct_8_2_0a3d7222_for__kill anon_struct_8_2_0a3d7222_for__kill, *Panon_struct_8_2_0a3d7222_for__kill;

typedef struct anon_struct_12_3_5124685d_for__timer anon_struct_12_3_5124685d_for__timer, *Panon_struct_12_3_5124685d_for__timer;

typedef struct anon_struct_12_3_9bedbd60_for__rt anon_struct_12_3_9bedbd60_for__rt, *Panon_struct_12_3_9bedbd60_for__rt;

typedef struct anon_struct_20_5_7a025f54_for__sigchld anon_struct_20_5_7a025f54_for__sigchld, *Panon_struct_20_5_7a025f54_for__sigchld;

typedef struct anon_struct_4_1_ff5bff1a_for__sigfault anon_struct_4_1_ff5bff1a_for__sigfault, *Panon_struct_4_1_ff5bff1a_for__sigfault;

typedef struct anon_struct_8_2_686959ae_for__sigpoll anon_struct_8_2_686959ae_for__sigpoll, *Panon_struct_8_2_686959ae_for__sigpoll;

struct anon_struct_4_1_ff5bff1a_for__sigfault {
    void * si_addr;
};

struct anon_struct_12_3_5124685d_for__timer {
    wchar_t si_tid;
    wchar_t si_overrun;
    sigval_t si_sigval;
};

struct anon_struct_8_2_0a3d7222_for__kill {
    __pid_t si_pid;
    __uid_t si_uid;
};

struct anon_struct_20_5_7a025f54_for__sigchld {
    __pid_t si_pid;
    __uid_t si_uid;
    wchar_t si_status;
    __clock_t si_utime;
    __clock_t si_stime;
};

struct anon_struct_12_3_9bedbd60_for__rt {
    __pid_t si_pid;
    __uid_t si_uid;
    sigval_t si_sigval;
};

struct anon_struct_8_2_686959ae_for__sigpoll {
    long si_band;
    wchar_t si_fd;
};

union anon_union_116_7_b489c2e4_for__sifields {
    wchar_t _pad[29];
    struct anon_struct_8_2_0a3d7222_for__kill _kill;
    struct anon_struct_12_3_5124685d_for__timer _timer;
    struct anon_struct_12_3_9bedbd60_for__rt _rt;
    struct anon_struct_20_5_7a025f54_for__sigchld _sigchld;
    struct anon_struct_4_1_ff5bff1a_for__sigfault _sigfault;
    struct anon_struct_8_2_686959ae_for__sigpoll _sigpoll;
};

typedef struct _HTBTree_top.conflict _HTBTree_top.conflict, *P_HTBTree_top.conflict;

typedef wchar_t (* HTComparer.conflict)(void *, void *);

struct _HTBTree_top.conflict {
    HTComparer.conflict compare;
    struct _HTBTree_element * top;
};

typedef struct _HTBTree_top.conflict HTBTree.conflict;

typedef struct _HTBTree_element HTBTElement;

typedef char * __gnuc_va_list;

typedef struct _rule _rule, *P_rule;

typedef struct _rule rule;

typedef enum HTRuleOp {
    HT_Invalid=0,
    HT_Map=1,
    HT_Pass=2,
    HT_Fail=3,
    HT_DefProt=4,
    HT_Protect=5,
    HT_Progress=6,
    HT_InfoMsg=7,
    HT_UserMsg=8,
    HT_Alert=9,
    HT_AlwaysAlert=10,
    HT_Redirect=11,
    HT_RedirectPerm=12,
    HT_PermitRedir=13,
    HT_UseProxy=14
} HTRuleOp;

struct _rule {
    struct _rule * next;
    enum HTRuleOp op;
    char * pattern;
    char * equiv;
    char * condition_op;
    char * condition;
};

typedef struct struct_parts struct_parts, *Pstruct_parts;

struct struct_parts {
    char * access;
    char * host;
    char * absolute;
    char * relative;
    char * search;
    char * anchor;
};

typedef struct _HTStyleSheet _HTStyleSheet, *P_HTStyleSheet;

typedef struct _HTStyleSheet HTStyleSheet;

struct _HTStyleSheet {
    char * name;
    HTStyle * styles;
};

typedef enum HTStyle_Enum {
    ST_Normal=0,
    ST_DivCenter=1,
    ST_DivLeft=2,
    ST_DivRight=3,
    ST_Banner=4,
    ST_Blockquote=5,
    ST_Bq=6,
    ST_Footnote=7,
    ST_List=8,
    ST_List1=9,
    ST_List2=10,
    ST_List3=11,
    ST_List4=12,
    ST_List5=13,
    ST_List6=14,
    ST_Menu=15,
    ST_Menu1=16,
    ST_Menu2=17,
    ST_Menu3=18,
    ST_Menu4=19,
    ST_Menu5=20,
    ST_Menu6=21,
    ST_Glossary=22,
    ST_Glossary1=23,
    ST_Glossary2=24,
    ST_Glossary3=25,
    ST_Glossary4=26,
    ST_Glossary5=27,
    ST_Glossary6=28,
    ST_GlossaryCompact=29,
    ST_GlossaryCompact1=30,
    ST_GlossaryCompact2=31,
    ST_GlossaryCompact3=32,
    ST_GlossaryCompact4=33,
    ST_GlossaryCompact5=34,
    ST_GlossaryCompact6=35,
    ST_Example=36,
    ST_Preformatted=37,
    ST_Listing=38,
    ST_Address=39,
    ST_Note=40,
    ST_Heading1=41,
    ST_Heading2=42,
    ST_Heading3=43,
    ST_Heading4=44,
    ST_Heading5=45,
    ST_Heading6=46,
    ST_HeadingCenter=47,
    ST_HeadingLeft=48,
    ST_HeadingRight=49
} HTStyle_Enum;

typedef struct sigaction sigaction, *Psigaction;

typedef union anon_union_4_2_5ad2d23e_for___sigaction_handler anon_union_4_2_5ad2d23e_for___sigaction_handler, *Panon_union_4_2_5ad2d23e_for___sigaction_handler;

typedef struct __sigset_t __sigset_t, *P__sigset_t;

typedef void (* __sighandler_t)(wchar_t);

struct __sigset_t {
    ulong __val[32];
};

union anon_union_4_2_5ad2d23e_for___sigaction_handler {
    __sighandler_t sa_handler;
    void (* sa_sigaction)(wchar_t, siginfo_t *, void *);
};

struct sigaction {
    union anon_union_4_2_5ad2d23e_for___sigaction_handler __sigaction_handler;
    struct __sigset_t sa_mask;
    wchar_t sa_flags;
    void (* sa_restorer)(void);
};

typedef struct _connection _connection, *P_connection;

typedef struct _connection connection;

struct _connection {
    struct _connection * next;
    ulong addr;
    int socket;
    BOOLEAN binary;
};

typedef enum eServerType {
    GENERIC_SERVER=0,
    MACHTEN_SERVER=1,
    UNIX_SERVER=2,
    VMS_SERVER=3,
    CMS_SERVER=4,
    DCTS_SERVER=5,
    TCPC_SERVER=6,
    PETER_LEWIS_SERVER=7,
    NCSA_SERVER=8,
    WINDOWS_NT_SERVER=9,
    WINDOWS_2K_SERVER=10,
    MS_WINDOWS_SERVER=11,
    MSDOS_SERVER=12,
    APPLESHARE_SERVER=13,
    NETPRESENZ_SERVER=14,
    DLS_SERVER=15
} eServerType;

typedef struct _EntryInfo _EntryInfo, *P_EntryInfo;

typedef struct _EntryInfo EntryInfo;

struct _EntryInfo {
    char * filename;
    char * linkname;
    char * type;
    char * date;
    uint size;
    BOOLEAN display;
};

typedef struct _hashbucket _hashbucket, *P_hashbucket;

typedef struct _hashbucket bucket;

struct _hashbucket {
    char * name;
    wchar_t code;
    wchar_t color;
    wchar_t mono;
    wchar_t cattr;
    struct _hashbucket * next;
};

typedef struct _hashbucket.conflict _hashbucket.conflict, *P_hashbucket.conflict;

typedef struct _hashbucket.conflict bucket.conflict;

struct _hashbucket.conflict {
    char * name;
    int code;
    int color;
    int mono;
    int cattr;
    struct _hashbucket.conflict * next;
};

typedef union anon_union_4_2_13109f1b anon_union_4_2_13109f1b, *Panon_union_4_2_13109f1b;

union anon_union_4_2_13109f1b {
    int __in;
    int __i;
};

typedef struct AlignedHOSTENT AlignedHOSTENT, *PAlignedHOSTENT;

struct AlignedHOSTENT {
    struct hostent h;
    char rest[128];
};

typedef struct _statuses _statuses, *P_statuses;

struct _statuses {
    size_t rehostentlen;
    int h_length;
    int child_errno;
    int child_h_errno;
    BOOLEAN h_errno_valid;
};


// WARNING! conflicting data type names: /DWARF/libio.h/_IO_marker - /libio.h/_IO_marker

typedef struct _OptionType _OptionType, *P_OptionType;

struct _OptionType {
    char * name;
    char * cp_submit_value;
    int value_cs;
    struct _OptionType * next;
};

typedef struct _OptionType OptionType;

typedef struct _PerFormInfo _PerFormInfo, *P_PerFormInfo;

typedef struct _PerFormInfo PerFormInfo;

struct _PerFormInfo {
    wchar_t number;
    wchar_t disabled;
    struct _PerFormInfo * next;
    wchar_t nfields;
    FormInfo * first_field;
    FormInfo * last_field;
    char * accept_cs;
    char * thisacceptcs;
};

typedef struct _InputFieldData.conflict _InputFieldData.conflict, *P_InputFieldData.conflict;

struct _InputFieldData.conflict {
    char * accept;
    char * align;
    int checked;
    char * iclass;
    int disabled;
    char * error;
    char * height;
    char * id;
    char * lang;
    char * max;
    char * maxlength;
    char * md;
    char * min;
    char * name;
    int size;
    char * src;
    char * type;
    char * value;
    char * width;
    int name_cs;
    int value_cs;
    char * accept_cs;
};

typedef struct _InputFieldData _InputFieldData, *P_InputFieldData;

struct _InputFieldData {
    char * accept;
    char * align;
    wchar_t checked;
    char * iclass;
    wchar_t disabled;
    char * error;
    char * height;
    char * id;
    char * lang;
    char * max;
    char * maxlength;
    char * md;
    char * min;
    char * name;
    wchar_t size;
    char * src;
    char * type;
    char * value;
    char * width;
    wchar_t name_cs;
    wchar_t value_cs;
    char * accept_cs;
};

typedef struct _InputFieldData.conflict InputFieldData.conflict;

typedef struct _InputFieldData InputFieldData;

typedef enum html_src_check_state {
    HTSRC_CK_normal=0,
    HTSRC_CK_seen_excl=1,
    HTSRC_CK_after_tagname=2,
    HTSRC_CK_seen_dot=3
} html_src_check_state;

typedef struct _HT_tagspec _HT_tagspec, *P_HT_tagspec;

typedef struct _HT_tagspec HT_tagspec;

typedef enum HTMLElement {
    HTML_A=0,
    HTML_ABBR=1,
    HTML_ACRONYM=2,
    HTML_ADDRESS=3,
    HTML_APPLET=4,
    HTML_AREA=5,
    HTML_AU=6,
    HTML_AUTHOR=7,
    HTML_B=8,
    HTML_BANNER=9,
    HTML_BASE=10,
    HTML_BASEFONT=11,
    HTML_BDO=12,
    HTML_BGSOUND=13,
    HTML_BIG=14,
    HTML_BLINK=15,
    HTML_BLOCKQUOTE=16,
    HTML_BODY=17,
    HTML_BODYTEXT=18,
    HTML_BQ=19,
    HTML_BR=20,
    HTML_BUTTON=21,
    HTML_CAPTION=22,
    HTML_CENTER=23,
    HTML_CITE=24,
    HTML_CODE=25,
    HTML_COL=26,
    HTML_COLGROUP=27,
    HTML_COMMENT=28,
    HTML_CREDIT=29,
    HTML_DD=30,
    HTML_DEL=31,
    HTML_DFN=32,
    HTML_DIR=33,
    HTML_DIV=34,
    HTML_DL=35,
    HTML_DLC=36,
    HTML_DT=37,
    HTML_EM=38,
    HTML_EMBED=39,
    HTML_FIELDSET=40,
    HTML_FIG=41,
    HTML_FN=42,
    HTML_FONT=43,
    HTML_FORM=44,
    HTML_FRAME=45,
    HTML_FRAMESET=46,
    HTML_H1=47,
    HTML_H2=48,
    HTML_H3=49,
    HTML_H4=50,
    HTML_H5=51,
    HTML_H6=52,
    HTML_HEAD=53,
    HTML_HR=54,
    HTML_HTML=55,
    HTML_HY=56,
    HTML_I=57,
    HTML_IFRAME=58,
    HTML_IMG=59,
    HTML_INPUT=60,
    HTML_INS=61,
    HTML_ISINDEX=62,
    HTML_KBD=63,
    HTML_KEYGEN=64,
    HTML_LABEL=65,
    HTML_LEGEND=66,
    HTML_LH=67,
    HTML_LI=68,
    HTML_LINK=69,
    HTML_LISTING=70,
    HTML_MAP=71,
    HTML_MARQUEE=72,
    HTML_MATH=73,
    HTML_MENU=74,
    HTML_META=75,
    HTML_NEXTID=76,
    HTML_NOFRAMES=77,
    HTML_NOTE=78,
    HTML_OBJECT=79,
    HTML_OL=80,
    HTML_OPTION=81,
    HTML_OVERLAY=82,
    HTML_P=83,
    HTML_PARAM=84,
    HTML_PLAINTEXT=85,
    HTML_PRE=86,
    HTML_Q=87,
    HTML_S=88,
    HTML_SAMP=89,
    HTML_SCRIPT=90,
    HTML_SELECT=91,
    HTML_SHY=92,
    HTML_SMALL=93,
    HTML_SPAN=94,
    HTML_SPOT=95,
    HTML_STRIKE=96,
    HTML_STRONG=97,
    HTML_STYLE=98,
    HTML_SUB=99,
    HTML_SUP=100,
    HTML_TAB=101,
    HTML_TABLE=102,
    HTML_TBODY=103,
    HTML_TD=104,
    HTML_TEXTAREA=105,
    HTML_TEXTFLOW=106,
    HTML_TFOOT=107,
    HTML_TH=108,
    HTML_THEAD=109,
    HTML_TITLE=110,
    HTML_TR=111,
    HTML_TT=112,
    HTML_U=113,
    HTML_UL=114,
    HTML_VAR=115,
    HTML_WBR=116,
    HTML_XMP=117,
    HTML_ALT_OBJECT=118
} HTMLElement;

struct _HT_tagspec {
    struct _HT_tagspec * next;
    int style;
    char * class_name;
    enum HTMLElement element;
    BOOLEAN * present;
    char * * value;
    BOOLEAN start;
};

typedef enum HTlexeme {
    HTL_comm=0,
    HTL_tag=1,
    HTL_attrib=2,
    HTL_attrval=3,
    HTL_abracket=4,
    HTL_entity=5,
    HTL_href=6,
    HTL_entire=7,
    HTL_badseq=8,
    HTL_badtag=9,
    HTL_badattr=10,
    HTL_sgmlspecial=11,
    HTL_num_lexemes=12
} HTlexeme;

typedef struct anon_struct_8_2_f9ee80c1 anon_struct_8_2_f9ee80c1, *Panon_struct_8_2_f9ee80c1;

struct anon_struct_8_2_f9ee80c1 {
    wchar_t fg;
    wchar_t bg;
};

typedef struct anon_struct_8_2_38b386df anon_struct_8_2_38b386df, *Panon_struct_8_2_38b386df;

struct anon_struct_8_2_38b386df {
    char * name;
    wchar_t code;
};

typedef struct anon_struct_16_4_921a010c anon_struct_16_4_921a010c, *Panon_struct_16_4_921a010c;

struct anon_struct_16_4_921a010c {
    wchar_t fg;
    wchar_t dft_fg;
    wchar_t bg;
    wchar_t dft_bg;
};

typedef struct unipair_str unipair_str, *Punipair_str;

struct unipair_str {
    ushort unicode;
    char * replace_str;
};

typedef struct unimapdesc_str unimapdesc_str, *Punimapdesc_str;

struct unimapdesc_str {
    ushort entry_ct;
    struct unipair_str * entries;
    int isdefault;
    int trydefault;
};

typedef struct HTAAProt HTAAProt, *PHTAAProt;

typedef struct GroupDef GroupDef, *PGroupDef;

typedef HTList HTAssocList;

typedef HTList ItemList;

struct GroupDef {
    char * group_name;
    ItemList * item_list;
};

struct HTAAProt {
    char * ctemplate;
    char * filename;
    char * uid_name;
    char * gid_name;
    struct GroupDef * mask_group;
    HTList * valid_schemes;
    HTAssocList * values;
};

typedef __gnuc_va_list va_list;


// WARNING! conflicting data type names: /DWARF/stdio.h/_IO_FILE - /stdio.h/_IO_FILE

typedef struct sockaddr_storage sockaddr_storage, *Psockaddr_storage;

struct sockaddr_storage {
    sa_family_t ss_family;
    ulong __ss_align;
    char __ss_padding[120];
};

typedef struct sockaddr_in sockaddr_in, *Psockaddr_in;

typedef uint16_t in_port_t;

typedef struct in_addr in_addr, *Pin_addr;

typedef uint32_t in_addr_t;

struct in_addr {
    in_addr_t s_addr;
};

struct sockaddr_in {
    sa_family_t sin_family;
    in_port_t sin_port;
    struct in_addr sin_addr;
    uchar sin_zero[8];
};

typedef enum __socket_type {
    SOCK_STREAM=1,
    SOCK_DGRAM=2,
    SOCK_RAW=3,
    SOCK_RDM=4,
    SOCK_SEQPACKET=5,
    SOCK_DCCP=6,
    SOCK_PACKET=10,
    SOCK_NONBLOCK=2048,
    SOCK_CLOEXEC=524288
} __socket_type;

typedef struct HTAAProtCache HTAAProtCache, *PHTAAProtCache;

struct HTAAProtCache {
    char * prot_filename;
    struct HTAAProt * prot;
};

typedef struct USER_DATA USER_DATA, *PUSER_DATA;

struct USER_DATA {
    char * name;
    int user;
};

typedef void * voidpf;

typedef voidpf (* alloc_func)(voidpf, uInt, uInt);

typedef struct z_stream_s z_stream_s, *Pz_stream_s;

typedef struct z_stream_s z_stream;

typedef Byte Bytef;

typedef struct internal_state internal_state, *Pinternal_state;

typedef void (* free_func)(voidpf, voidpf);

struct internal_state {
    int dummy;
};

struct z_stream_s {
    Bytef * next_in;
    uInt avail_in;
    uLong total_in;
    Bytef * next_out;
    uInt avail_out;
    uLong total_out;
    char * msg;
    struct internal_state * state;
    alloc_func zalloc;
    free_func zfree;
    voidpf opaque;
    int data_type;
    uLong adler;
    uLong reserved;
};

typedef void * voidp;

typedef voidp gzFile;

typedef struct _TABLE _TABLE, *P_TABLE;

typedef struct _TABLE TABLE;

typedef __time_t time_t;

struct _TABLE {
    char * name;
    int type;
    time_t value;
};

typedef enum _DSTMODE {
    DSTon=0,
    DSToff=1,
    DSTmaybe=2
} _DSTMODE;

typedef enum _DSTMODE DSTMODE;

typedef union YYSTYPE YYSTYPE, *PYYSTYPE;

typedef enum _MERIDIAN {
    MERam=0,
    MERpm=1,
    MER24=2
} _MERIDIAN;

union YYSTYPE {
    time_t Number;
    enum _MERIDIAN Meridian;
};

typedef enum _MERIDIAN MERIDIAN;

typedef struct _JumpDatum _JumpDatum, *P_JumpDatum;

typedef struct _JumpDatum JumpDatum;

struct _JumpDatum {
    char * key;
    char * url;
};

typedef struct JumpTable.conflict JumpTable.conflict, *PJumpTable.conflict;

struct JumpTable.conflict {
    int key;
    int nel;
    char * msg;
    char * file;
    char * shortcut;
    HTList * history;
    JumpDatum * table;
    struct JumpTable.conflict * next;
    char * mp;
};

typedef struct JumpTable JumpTable, *PJumpTable;

struct JumpTable {
    wchar_t key;
    wchar_t nel;
    char * msg;
    char * file;
    char * shortcut;
    HTList * history;
    JumpDatum * table;
    struct JumpTable * next;
    char * mp;
};

typedef enum AcceptMedia {
    mediaINT=1,
    mediaOpt1=1,
    mediaEXT=2,
    mediaCFG=4,
    mediaOpt2=5,
    mediaUSR=8,
    mediaOpt3=13,
    mediaSYS=16,
    mediaOpt4=29,
    mediaALL=31
} AcceptMedia;

typedef struct _HTPresentation _HTPresentation, *P_HTPresentation;

typedef struct _HTPresentation HTPresentation;

struct _HTPresentation {
    HTAtom * rep;
    HTAtom * rep_out;
    HTStream.conflict * (* converter)(HTPresentation *, HTParentAnchor *, HTStream.conflict *);
    char * command;
    char * testcommand;
    float quality;
    float secs;
    float secs_per_byte;
    off_t maxbytes;
    BOOLEAN get_accept;
    int accept_opt;
};

typedef struct _HTPresentation.conflict2 _HTPresentation.conflict2, *P_HTPresentation.conflict2;

typedef struct _HTPresentation.conflict2 HTPresentation.conflict2;

struct _HTPresentation.conflict2 {
    HTAtom * rep;
    HTAtom * rep_out;
    HTStream.conflict4 * (* converter)(HTPresentation.conflict2 *, HTParentAnchor *, HTStream.conflict4 *);
    char * command;
    char * testcommand;
    float quality;
    float secs;
    float secs_per_byte;
    off_t maxbytes;
    BOOLEAN get_accept;
    int accept_opt;
};

typedef struct _HTPresentation.conflict3 _HTPresentation.conflict3, *P_HTPresentation.conflict3;

typedef struct _HTPresentation.conflict3 HTPresentation.conflict3;

struct _HTPresentation.conflict3 {
    HTAtom * rep;
    HTAtom * rep_out;
    HTStream.conflict6 * (* converter)(HTPresentation.conflict3 *, HTParentAnchor *, HTStream.conflict6 *);
    char * command;
    char * testcommand;
    float quality;
    float secs;
    float secs_per_byte;
    off_t maxbytes;
    BOOLEAN get_accept;
    int accept_opt;
};

typedef struct _HTPresentation.conflict4 _HTPresentation.conflict4, *P_HTPresentation.conflict4;

typedef struct _HTPresentation.conflict4 HTPresentation.conflict4;

struct _HTPresentation.conflict4 {
    HTAtom * rep;
    HTAtom * rep_out;
    HTStream.conflict7 * (* converter)(HTPresentation.conflict4 *, HTParentAnchor *, HTStream.conflict7 *);
    char * command;
    char * testcommand;
    float quality;
    float secs;
    float secs_per_byte;
    off_t maxbytes;
    BOOLEAN get_accept;
    int accept_opt;
};

typedef struct _HTPresentation.conflict1 _HTPresentation.conflict1, *P_HTPresentation.conflict1;

typedef struct _HTPresentation.conflict1 HTPresentation.conflict1;

struct _HTPresentation.conflict1 {
    HTAtom * rep;
    HTAtom * rep_out;
    HTStream.conflict3 * (* converter)(HTPresentation.conflict1 *, HTParentAnchor *, HTStream.conflict3 *);
    char * command;
    char * testcommand;
    float quality;
    float secs;
    float secs_per_byte;
    off_t maxbytes;
    BOOLEAN get_accept;
    int accept_opt;
};

typedef struct _HTPresentation.conflict _HTPresentation.conflict, *P_HTPresentation.conflict;

typedef struct _HTPresentation.conflict HTPresentation.conflict;

struct _HTPresentation.conflict {
    HTAtom * rep;
    HTAtom * rep_out;
    HTStream * (* converter)(HTPresentation.conflict *, HTParentAnchor *, HTStream *);
    char * command;
    char * testcommand;
    float quality;
    float secs;
    float secs_per_byte;
    off_t maxbytes;
    BOOLEAN get_accept;
    int accept_opt;
};

typedef struct _LYMapElement _LYMapElement, *P_LYMapElement;

typedef struct _LYMapElement LYMapElement;

struct _LYMapElement {
    char * address;
    char * title;
};

typedef struct _LYImageMap _LYImageMap, *P_LYImageMap;

typedef struct _LYImageMap LYImageMap;

struct _LYImageMap {
    char * address;
    char * title;
    HTList * elements;
};

typedef struct _TIMEINFO _TIMEINFO, *P_TIMEINFO;

struct _TIMEINFO {
    time_t time;
    long usec;
    long tzone;
};

typedef struct _TIMEINFO TIMEINFO;


// WARNING! conflicting data type names: /DWARF/time.h/timespec - /time.h/timespec

typedef struct timeval timeval, *Ptimeval;

struct timeval {
    __time_t tv_sec;
    __suseconds_t tv_usec;
};

typedef struct tm tm, *Ptm;

struct tm {
    int tm_sec;
    int tm_min;
    int tm_hour;
    int tm_mday;
    int tm_mon;
    int tm_year;
    int tm_wday;
    int tm_yday;
    int tm_isdst;
    long tm_gmtoff;
    char * tm_zone;
};

typedef struct timezone timezone, *Ptimezone;

struct timezone {
    wchar_t tz_minuteswest;
    wchar_t tz_dsttime;
};

typedef struct timezone.conflict timezone.conflict, *Ptimezone.conflict;

struct timezone.conflict {
    int tz_minuteswest;
    int tz_dsttime;
};

typedef struct HTCharStyle.conflict HTCharStyle.conflict, *PHTCharStyle.conflict;

struct HTCharStyle.conflict {
    int color;
    int mono;
    int cattr;
};

typedef struct HTCharStyle HTCharStyle, *PHTCharStyle;

struct HTCharStyle {
    wchar_t color;
    wchar_t mono;
    wchar_t cattr;
};

typedef struct UC_charset UC_charset, *PUC_charset;

struct UC_charset {
    char * MIMEname;
    char * LYNXname;
    uchar * unicount;
    ushort * unitable;
    int num_uni;
    struct unimapdesc_str replacedesc;
    int uc_status;
    int LYhndl;
    int GN;
    int lowest_eight;
    int enc;
    int codepage;
};

typedef struct _UCStageInfo.conflict _UCStageInfo.conflict, *P_UCStageInfo.conflict;

struct _UCStageInfo.conflict {
    wchar_t lock;
    wchar_t LYhndl;
    LYUCcharset.conflict C;
};

typedef struct _EditFieldData _EditFieldData, *P_EditFieldData;

struct _EditFieldData {
    wchar_t sx;
    wchar_t sy;
    wchar_t dspwdth;
    wchar_t strlen;
    wchar_t maxlen;
    char pad;
    BOOLEAN hidden;
    BOOLEAN dirty;
    BOOLEAN panon;
    wchar_t xpan;
    wchar_t pos;
    wchar_t margin;
    wchar_t current_modifiers;
    wchar_t mark;
    char buffer[1024];
    wchar_t offset2col[2048];
    wchar_t col2offset[2048];
};

typedef struct _EditFieldData EditFieldData;

typedef enum RecallType {
    NORECALL=0,
    RECALL_URL=1,
    RECALL_CMD=2,
    RECALL_MAIL=3
} RecallType;

typedef void * iconv_t;

typedef struct Keysym_String_List Keysym_String_List, *PKeysym_String_List;

struct Keysym_String_List {
    char * string;
    wchar_t value;
};

typedef struct anon_struct_8_2_38b4fbb6 anon_struct_8_2_38b4fbb6, *Panon_struct_8_2_38b4fbb6;

struct anon_struct_8_2_38b4fbb6 {
    char * name;
    wchar_t (* func)(char *);
};

typedef struct anon_struct_12_3_cf13f262 anon_struct_12_3_cf13f262, *Panon_struct_12_3_cf13f262;

struct anon_struct_12_3_cf13f262 {
    char * txt;
    wchar_t action;
    uint flag;
};

typedef struct HTAssoc HTAssoc, *PHTAssoc;

struct HTAssoc {
    char * name;
    char * value;
};

typedef struct group group, *Pgroup;

struct group {
    char * gr_name;
    char * gr_passwd;
    __gid_t gr_gid;
    char * * gr_mem;
};

typedef struct MailcapEntry MailcapEntry, *PMailcapEntry;

struct MailcapEntry {
    char * contenttype;
    char * command;
    char * testcommand;
    int needsterminal;
    int copiousoutput;
    int needtofree;
    char * label;
    char * printcommand;
    char * nametemplate;
    float quality;
    long maxbytes;
};

typedef struct cmdlist_s cmdlist_s, *Pcmdlist_s;

struct cmdlist_s {
    char * cmd;
    int result;
    struct cmdlist_s * next;
};

typedef struct _win_st _win_st, *P_win_st;

typedef struct _win_st WINDOW;

typedef chtype attr_t;

typedef struct ldat ldat, *Pldat;

typedef struct pdat pdat, *Ppdat;

typedef struct cchar_t cchar_t, *Pcchar_t;

struct cchar_t {
    attr_t attr;
    wchar_t chars[5];
};

struct pdat {
    short _pad_y;
    short _pad_x;
    short _pad_top;
    short _pad_left;
    short _pad_bottom;
    short _pad_right;
};

struct ldat {
};

struct _win_st {
    short _cury;
    short _curx;
    short _maxy;
    short _maxx;
    short _begy;
    short _begx;
    short _flags;
    attr_t _attrs;
    chtype _bkgd;
    _Bool _notimeout;
    _Bool _clear;
    _Bool _leaveok;
    _Bool _scroll;
    _Bool _idlok;
    _Bool _idcok;
    _Bool _immed;
    _Bool _sync;
    _Bool _use_keypad;
    wchar_t _delay;
    struct ldat * _line;
    short _regtop;
    short _regbottom;
    wchar_t _parx;
    wchar_t _pary;
    WINDOW * _parent;
    struct pdat _pad;
    short _yoffset;
    struct cchar_t _bkgrnd;
};

typedef struct MEVENT MEVENT, *PMEVENT;

struct MEVENT {
    short id;
    wchar_t x;
    wchar_t y;
    wchar_t z;
    mmask_t bstate;
};

typedef struct _HTStructuredClass.conflict1 _HTStructuredClass.conflict1, *P_HTStructuredClass.conflict1;

typedef struct _HTStructured.conflict1 _HTStructured.conflict1, *P_HTStructured.conflict1;

typedef struct _HTStructured.conflict1 HTStructured.conflict1;

typedef struct _HTStructuredClass.conflict1 HTStructuredClass.conflict1;

struct _HTStructuredClass.conflict1 {
    char * name;
    void (* _free)(HTStructured.conflict1 *);
    void (* _abort)(HTStructured.conflict1 *, HTError);
    void (* put_character)(HTStructured.conflict1 *, char);
    void (* put_string)(HTStructured.conflict1 *, char *);
    void (* put_block)(HTStructured.conflict1 *, char *, int);
    int (* start_element)(HTStructured.conflict1 *, int, BOOLEAN *, char * *, int, char * *);
    int (* end_element)(HTStructured.conflict1 *, int, char * *);
    int (* put_entity)(HTStructured.conflict1 *, int);
};

struct _HTStructured.conflict1 {
    HTStructuredClass.conflict1 * isa;
    HTStream.conflict4 * target;
    HTStreamClass.conflict4 targetClass;
    char buffer[201];
    int buffer_maxchars;
    char * write_pointer;
    char * line_break[21];
    int cleanness;
    BOOLEAN overflowed;
    BOOLEAN delete_line_break_char[21];
    BOOLEAN preformatted;
    BOOLEAN escape_specials;
    BOOLEAN in_attrval;
    HText * text;
};

typedef struct stat stat, *Pstat;

struct stat {
    __dev_t st_dev;
    ushort __pad1;
    __ino_t __st_ino;
    __mode_t st_mode;
    __nlink_t st_nlink;
    __uid_t st_uid;
    __gid_t st_gid;
    __dev_t st_rdev;
    ushort __pad2;
    __off64_t st_size;
    __blksize_t st_blksize;
    __blkcnt64_t st_blocks;
    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
    __ino64_t st_ino;
};

typedef enum CharUtil_st {
    st_HTML=0,
    st_URL=1,
    st_other=2
} CharUtil_st;

typedef enum canclose_t {
    close_NO=0,
    close_error=1,
    close_valid=2
} canclose_t;

typedef struct _DocAddress _DocAddress, *P_DocAddress;

struct _DocAddress {
    char * address;
    struct bstring * post_data;
    char * post_content_type;
    char * bookmark;
    BOOLEAN isHEAD;
    BOOLEAN safe;
};

typedef struct _DocAddress DocAddress;

typedef struct anon_struct_32_6_e3a42e01 anon_struct_32_6_e3a42e01, *Panon_struct_32_6_e3a42e01;

struct anon_struct_32_6_e3a42e01 {
    HTParentAnchor0 * parent;
    char * tag;
    HTAnchor * dest;
    HTLinkType * type;
    HTList _add_children_notag;
    HTList _add_sources;
};

typedef enum _state {
    S_text=0,
    S_esc=1,
    S_dollar=2,
    S_paren=3,
    S_nonascii_text=4,
    S_dollar_paren=5
} _state;


// WARNING! conflicting data type names: /DWARF/LYCharUtils.c/LYUCFullyTranslateString/_state - /DWARF/LYCharUtils.c/LYEntify/_state

typedef enum _parsing_what {
    P_text=0,
    P_utf8=1,
    P_hex=2,
    P_decimal=3,
    P_named=4
} _parsing_what;

typedef enum comment_state {
    start1=0,
    start2=1,
    end1=2,
    end2=3
} comment_state;

typedef struct parse_args_type parse_args_type, *Pparse_args_type;

typedef struct parse_args_type Config_Type;

struct parse_args_type {
    char * name;
    int type;
    long value;
    char * help_string;
};

typedef struct anon_struct_8_2_38b5a833 anon_struct_8_2_38b5a833, *Panon_struct_8_2_38b5a833;

struct anon_struct_8_2_38b5a833 {
    char * name;
    char * help;
};

typedef struct winsize winsize, *Pwinsize;

struct winsize {
    ushort ws_row;
    ushort ws_col;
    ushort ws_xpixel;
    ushort ws_ypixel;
};

typedef struct _HTProtocol.conflict1 _HTProtocol.conflict1, *P_HTProtocol.conflict1;

typedef struct _HTProtocol.conflict1 HTProtocol.conflict1;

struct _HTProtocol.conflict1 {
    char * name;
    int (* load)(char *, HTParentAnchor *, HTFormat, HTStream.conflict *);
    HTStream.conflict * (* saveStream)(HTParentAnchor *);
};

typedef struct _HTProtocol.conflict _HTProtocol.conflict, *P_HTProtocol.conflict;

typedef struct _HTProtocol.conflict HTProtocol.conflict;

struct _HTProtocol.conflict {
    char * name;
    int (* load)(char *, HTParentAnchor *, HTFormat, HTStream *);
    HTStream * (* saveStream)(HTParentAnchor *);
};

typedef struct _HTProtocol _HTProtocol, *P_HTProtocol;

typedef struct _HTProtocol HTProtocol;

struct _HTProtocol {
    char * name;
    wchar_t (* load)(char *, HTParentAnchor *, HTFormat, HTStream *);
    HTStream * (* saveStream)(HTParentAnchor *);
};

typedef struct anon_struct_8_2_38b4d85e anon_struct_8_2_38b4d85e, *Panon_struct_8_2_38b4d85e;

struct anon_struct_8_2_38b4d85e {
    char * name;
    BOOLEAN * flag;
};

typedef enum HTAAMethod {
    METHOD_UNKNOWN=0,
    METHOD_GET=1,
    METHOD_PUT=2
} HTAAMethod;

typedef enum HTAAScheme {
    HTAA_UNKNOWN=0,
    HTAA_NONE=1,
    HTAA_BASIC=2,
    HTAA_PUBKEY=3,
    HTAA_KERBEROS_V4=4,
    HTAA_KERBEROS_V5=5,
    HTAA_MAX_SCHEMES=6
} HTAAScheme;


// WARNING! conflicting data type names: /DWARF/_UNCATEGORIZED_/__dirstream - /dirent.h/__dirstream

typedef struct HTAAServer HTAAServer, *PHTAAServer;

struct HTAAServer {
    char * hostname;
    int portnumber;
    BOOLEAN IsProxy;
    HTList * setups;
    HTList * realms;
};

typedef struct HTAASetup HTAASetup, *PHTAASetup;

struct HTAASetup {
    struct HTAAServer * server;
    char * ctemplate;
    HTList * valid_schemes;
    HTAssocList * * scheme_specifics;
    BOOLEAN retry;
};

typedef struct HTAARealm HTAARealm, *PHTAARealm;

struct HTAARealm {
    char * realmname;
    char * username;
    char * password;
};

typedef struct trust trust, *Ptrust;

struct trust {
    char * src;
    char * path;
    int type;
    struct trust * next;
};

typedef struct ht_run_info ht_run_info, *Pht_run_info;

struct ht_run_info {
    wchar_t byte_len;
    wchar_t cell_len;
};

typedef struct PostData PostData, *PPostData;

typedef enum QuoteData {
    NO_QUOTE=0,
    QUOTE_MULTI=1,
    QUOTE_BASE64=2,
    QUOTE_SPECIAL=3
} QuoteData;

struct PostData {
    wchar_t type;
    BOOLEAN first;
    char * name;
    char * value;
    struct bstring.conflict * data;
    enum QuoteData quote;
};

typedef struct HTTabID HTTabID, *PHTTabID;

struct HTTabID {
    char * name;
    wchar_t column;
};

typedef struct agroup agroup, *Pagroup;

struct agroup {
    TextAnchor * anc;
    wchar_t prev_anchor_line;
    wchar_t anchors_this_line;
    wchar_t anchors_this_group;
};

typedef struct unipair_case unipair_case, *Punipair_case;

struct unipair_case {
    ushort upper;
    ushort lower;
};

typedef struct dired_menu dired_menu, *Pdired_menu;

struct dired_menu {
    wchar_t cond;
    char * sfx;
    char * link;
    char * rest;
    char * href;
    struct dired_menu * next;
};


// WARNING! conflicting data type names: /DWARF/LYLocal.c/LYExecv/lexical_block_2/anon_union_4_2_13109f1b - /DWARF/LYEdit.c/edit_temporary_file/lexical_block_0/lexical_block_0_3/lexical_block_0_3_0/anon_union_4_2_13109f1b


// WARNING! conflicting data type names: /DWARF/LYLocal.c/LYExecv/lexical_block_1/anon_union_4_2_13109f1b - /DWARF/LYEdit.c/edit_temporary_file/lexical_block_0/lexical_block_0_3/lexical_block_0_3_0/anon_union_4_2_13109f1b


// WARNING! conflicting data type names: /DWARF/LYLocal.c/LYExecv/lexical_block_3/anon_union_4_2_13109f1b - /DWARF/LYEdit.c/edit_temporary_file/lexical_block_0/lexical_block_0_3/lexical_block_0_3_0/anon_union_4_2_13109f1b


// WARNING! conflicting data type names: /DWARF/LYLocal.c/LYExecv/lexical_block_0/anon_union_4_2_13109f1b - /DWARF/LYEdit.c/edit_temporary_file/lexical_block_0/lexical_block_0_3/lexical_block_0_3_0/anon_union_4_2_13109f1b

typedef struct Config_Type.conflict Config_Type.conflict, *PConfig_Type.conflict;

typedef enum Conf_Types {
    CONF_NIL=0,
    CONF_BOOL=1,
    CONF_FUN=2,
    CONF_TIME=3,
    CONF_ENUM=4,
    CONF_INT=5,
    CONF_STR=6,
    CONF_PRG=7,
    CONF_ENV=8,
    CONF_ENV2=9,
    CONF_INCLUDE=10,
    CONF_ADD_ITEM=11,
    CONF_ADD_STRING=12,
    CONF_ADD_TRUSTED=13
} Conf_Types;

typedef struct Config_Enum Config_Enum, *PConfig_Enum;

struct Config_Enum {
    char * name;
    int value;
};

struct Config_Type.conflict {
    char * name;
    enum Conf_Types type;
    long value;
    struct Config_Enum * table;
};

typedef BOOLEAN optidx_set_t[207];

typedef struct UC_entity_info UC_entity_info, *PUC_entity_info;

struct UC_entity_info {
    char * name;
    ushort code;
};

typedef struct utmp utmp, *Putmp;

typedef struct exit_status exit_status, *Pexit_status;

struct exit_status {
    short e_termination;
    short e_exit;
};

struct utmp {
    short ut_type;
    pid_t ut_pid;
    char ut_line[32];
    char ut_id[4];
    char ut_user[32];
    char ut_host[256];
    struct exit_status ut_exit;
    long ut_session;
    struct timeval ut_tv;
    int32_t ut_addr_v6[4];
    char __unused[20];
};

typedef struct addrinfo.conflict addrinfo.conflict, *Paddrinfo.conflict;

struct addrinfo.conflict {
    int ai_flags;
    int ai_family;
    int ai_socktype;
    int ai_protocol;
    socklen_t ai_addrlen;
    struct sockaddr * ai_addr;
    char * ai_canonname;
    struct addrinfo.conflict * ai_next;
};


// WARNING! conflicting data type names: /DWARF/netdb.h/addrinfo - /netdb.h/addrinfo

typedef struct DIRED DIRED, *PDIRED;

struct DIRED {
    struct stat file_info;
    char sort_tags;
    char file_name[1];
};

typedef struct _HTSuffix _HTSuffix, *P_HTSuffix;

struct _HTSuffix {
    char * suffix;
    HTAtom * rep;
    HTAtom * encoding;
    char * desc;
    float quality;
};

typedef struct _HTSuffix HTSuffix;

typedef struct term term, *Pterm;

typedef struct term TERMINAL;

typedef struct termtype termtype, *Ptermtype;

typedef struct termtype TERMTYPE;

struct termtype {
    char * term_names;
    char * str_table;
    char * Booleans;
    short * Numbers;
    char * * Strings;
    char * ext_str_table;
    char * * ext_Names;
    ushort num_Booleans;
    ushort num_Numbers;
    ushort num_Strings;
    ushort ext_Booleans;
    ushort ext_Numbers;
    ushort ext_Strings;
};

struct term {
    TERMTYPE type;
    short Filedes;
    struct termios Ottyb;
    struct termios Nttyb;
    wchar_t _baudrate;
    char * _termname;
};

typedef enum invcheck_behaviour_t {
    INVCHECK_QUERY=0,
    INVCHECK_STRICT=1,
    INVCHECK_LOOSE=2
} invcheck_behaviour_t;

typedef struct _domain_entry _domain_entry, *P_domain_entry;

typedef struct _domain_entry domain_entry;

typedef enum behaviour_t {
    ACCEPT_ALWAYS=0,
    REJECT_ALWAYS=1,
    QUERY_USER=2
} behaviour_t;

struct _domain_entry {
    char * domain;
    enum behaviour_t bv;
    enum invcheck_behaviour_t invcheck_bv;
    HTList * cookie_list;
};

typedef struct anon_struct_8_2_24b5370d anon_struct_8_2_24b5370d, *Panon_struct_8_2_24b5370d;

struct anon_struct_8_2_24b5370d {
    char * name;
    char * value;
};

typedef struct LinkInfo.conflict LinkInfo.conflict, *PLinkInfo.conflict;

struct LinkInfo.conflict {
    char * lname;
    char * target;
    char * l_hightext;
    char * l_hightext2;
    wchar_t l_hightext2_offset;
    BOOLEAN inUnderline;
    wchar_t lx;
    wchar_t ly;
    wchar_t type;
    wchar_t sgml_offset;
    wchar_t anchor_number;
    wchar_t anchor_line_num;
    struct HiliteList list;
    struct _FormInfo.conflict * l_form;
};

typedef struct DocInfo DocInfo, *PDocInfo;

struct DocInfo {
    char * title;
    char * address;
    struct bstring.conflict * post_data;
    char * post_content_type;
    char * bookmark;
    BOOLEAN isHEAD;
    BOOLEAN safe;
    wchar_t link;
    wchar_t line;
    BOOLEAN internal_link;
    char * style;
};

typedef struct _lynx_list_item_type _lynx_list_item_type, *P_lynx_list_item_type;

struct _lynx_list_item_type {
    struct _lynx_list_item_type * next;
    char * name;
    char * command;
    wchar_t always_enabled;
    BOOLEAN override_primary_action;
    wchar_t pagelen;
};

typedef union ParseUnion ParseUnion, *PParseUnion;

typedef struct _lynx_list_item_type lynx_list_item_type;

typedef int (* ParseFunc)(char *);

union ParseUnion {
    lynx_list_item_type * * add_value;
    BOOLEAN * set_value;
    int * int_value;
    char * * str_value;
    ParseFunc fun_value;
    long def_value;
    HTList * * lst_value;
};

typedef struct HistInfo.conflict HistInfo.conflict, *PHistInfo.conflict;

struct HistInfo.conflict {
    struct DocInfo hdoc;
    wchar_t intern_seq_start;
};

typedef struct _VisitedLink _VisitedLink, *P_VisitedLink;

struct _VisitedLink {
    char * title;
    char * address;
    int level;
    struct _VisitedLink * next_tree;
    struct _VisitedLink * prev_latest;
    struct _VisitedLink * next_latest;
    struct _VisitedLink * prev_first;
};

typedef struct HistInfo HistInfo, *PHistInfo;

struct HistInfo {
    struct DocInfo hdoc;
    int intern_seq_start;
};

typedef struct LinkInfo.conflict1 LinkInfo.conflict1, *PLinkInfo.conflict1;

typedef struct _FormInfo _FormInfo, *P_FormInfo;

struct LinkInfo.conflict1 {
    char * lname;
    char * target;
    char * l_hightext;
    char * l_hightext2;
    wchar_t l_hightext2_offset;
    BOOLEAN inUnderline;
    wchar_t lx;
    wchar_t ly;
    wchar_t type;
    wchar_t sgml_offset;
    wchar_t anchor_number;
    wchar_t anchor_line_num;
    struct HiliteList list;
    struct _FormInfo * l_form;
};

struct _FormInfo {
    char * name;
    int number;
    int type;
    char * value;
    char * orig_value;
    int size;
    uint maxlength;
    int group;
    int num_value;
    int hrange;
    int lrange;
    OptionType * select_list;
    char * submit_action;
    int submit_method;
    char * submit_enctype;
    char * submit_title;
    BOOLEAN no_cache;
    char * cp_submit_value;
    char * orig_submit_value;
    int size_l;
    int disabled;
    int name_cs;
    int value_cs;
    char * accept_cs;
};

typedef struct LinkInfo LinkInfo, *PLinkInfo;

struct LinkInfo {
    char * lname;
    char * target;
    char * l_hightext;
    char * l_hightext2;
    int l_hightext2_offset;
    BOOLEAN inUnderline;
    int lx;
    int ly;
    int type;
    int sgml_offset;
    int anchor_number;
    int anchor_line_num;
    struct HiliteList list;
    struct _FormInfo * l_form;
};

typedef struct _VisitedLink VisitedLink;

typedef struct OptValues OptValues, *POptValues;

struct OptValues {
    wchar_t value;
    char * LongName;
    char * HtmlName;
};

typedef struct PostPair PostPair, *PPostPair;

struct PostPair {
    char * tag;
    char * value;
};

typedef enum HTCJKlang {
    NOCJK=0,
    JAPANESE=1,
    CHINESE=2,
    KOREAN=3,
    TAIPEI=4
} HTCJKlang;

typedef struct config_type config_type, *Pconfig_type;

typedef enum Conf_Types.conflict {
    CONF_NIL=0,
    CONF_ARRAY=1,
    CONF_BOOL=2,
    CONF_FUN=3,
    CONF_INT=4,
    CONF_ENUM=5,
    CONF_LIS=6,
    CONF_MBM=7,
    CONF_STR=8
} Conf_Types.conflict;

struct config_type {
    char * name;
    int enabled;
    enum Conf_Types.conflict type;
    long value;
    char * * strings;
    struct Config_Enum * table;
    void (* write_it)(FILE *, struct config_type *);
    char * note;
};

typedef struct config_type Config_Type.conflict1;

typedef enum LexItem {
    LEX_NONE=0,
    LEX_EOF=1,
    LEX_REC_SEP=2,
    LEX_FIELD_SEP=3,
    LEX_ITEM_SEP=4,
    LEX_OPEN_PAREN=5,
    LEX_CLOSE_PAREN=6,
    LEX_AT_SIGN=7,
    LEX_ALPH_STR=8,
    LEX_TMPL_STR=9
} LexItem;

typedef struct sockaddr_storage SockA;

typedef HTList AddressDefList;

typedef HTList UserDefList;

typedef struct Ref Ref, *PRef;

struct Ref {
    char * name;
    struct GroupDef * translation;
};

typedef struct Item Item, *PItem;

struct Item {
    UserDefList * user_def_list;
    AddressDefList * address_def_list;
};

typedef struct _cookie _cookie, *P_cookie;

typedef struct _cookie cookie;

struct _cookie {
    char * lynxID;
    char * name;
    char * value;
    int version;
    char * comment;
    char * commentURL;
    char * domain;
    int port;
    char * PortList;
    char * path;
    int pathlen;
    int flags;
    time_t expires;
    BOOLEAN quoted;
};

typedef struct anon_struct_12_3_3df7a7f3 anon_struct_12_3_3df7a7f3, *Panon_struct_12_3_3df7a7f3;

struct anon_struct_12_3_3df7a7f3 {
    char * * domain;
    int flag;
    int once;
};

typedef struct anon_struct_8_2_94731140 anon_struct_8_2_94731140, *Panon_struct_8_2_94731140;

struct anon_struct_8_2_94731140 {
    char * s;
    size_t n;
};

typedef enum anon_enum_32 {
    SHOW_COLOR_UNKNOWN=-1,
    UIP_UNKNOWN=-1,
    ABS_OFF=0,
    DIRS_FIRST=0,
    FLAG_ACCEPT_ALWAYS=0,
    FORCE_PROMPT_DFT=0,
    F_UNKNOWN=0,
    HTML_A=0,
    IPPROTO_HOPOPTS=0,
    IPPROTO_IP=0,
    LYE_NOP=0,
    LYK_UNKNOWN=0,
    MBM_OFF=0,
    NORECALL=0,
    NOT_A_URL_TYPE=0,
    ORDER_BY_NAME=0,
    SHOW_COLOR_NEVER=0,
    STACK_OFF=0,
    UIP_HISTORY=0,
    _NL_CTYPE_CLASS=0,
    __LC_CTYPE=0,
    cftNone=0,
    encodingNONE=0,
    ppUnknown=0,
    rateOFF=0,
    st_HTML=0,
    FILES_FIRST=1,
    FLAG_REJECT_ALWAYS=1,
    FORCE_PROMPT_YES=1,
    F_TEXT_TYPE=1,
    HTML_ABBR=1,
    IPPROTO_ICMP=1,
    LYE_CHAR=1,
    LYK_COMMAND=1,
    MBM_STANDARD=1,
    ORDER_BY_SIZE=1,
    RECALL_URL=1,
    SHOW_COLOR_OFF=1,
    STACK_ON=1,
    UIP_DOWNLOAD_OPTIONS=1,
    UNKNOWN_URL_TYPE=1,
    _ISblank=1,
    _NL_CTYPE_TOUPPER=1,
    __LC_NUMERIC=1,
    cftCompress=1,
    encodingGZIP=1,
    mediaINT=1,
    mediaOpt1=1,
    ppBZIP2=1,
    rateBYTES=1,
    st_URL=1,
    ABS_ON=2,
    FLAG_QUERY_USER=2,
    FORCE_PROMPT_NO=2,
    F_PASSWORD_TYPE=2,
    HTML_ACRONYM=2,
    HTTP_URL_TYPE=2,
    IPPROTO_IGMP=2,
    LYE_ENTER=2,
    LYK_1=2,
    MBM_ADVANCED=2,
    MIXED_STYLE=2,
    ORDER_BY_DATE=2,
    RECALL_CMD=2,
    SHOW_COLOR_ON=2,
    UIP_PRINT_OPTIONS=2,
    _IScntrl=2,
    _NL_CTYPE_GAP1=2,
    __LC_TIME=2,
    cftGzip=2,
    encodingDEFLATE=2,
    mediaEXT=2,
    ppCHMOD=2,
    rateKB=2,
    st_other=2,
    FILE_URL_TYPE=3,
    FLAG_FROM_FILE=3,
    F_CHECKBOX_TYPE=3,
    HTML_ADDRESS=3,
    LYE_TAB=3,
    LYK_2=3,
    ORDER_BY_MODE=3,
    RECALL_MAIL=3,
    SHOW_COLOR_ALWAYS=3,
    UIP_SHOWINFO=3,
    _NL_CTYPE_TOLOWER=3,
    __LC_COLLATE=3,
    cftBzip2=3,
    ppCOMPRESS=3,
    rateEtaBYTES=3,
    FLAG_INVCHECK_QUERY=4,
    FTP_URL_TYPE=4,
    F_RADIO_TYPE=4,
    HTML_APPLET=4,
    IPPROTO_IPIP=4,
    LYE_STOP=4,
    LYK_3=4,
    ORDER_BY_TYPE=4,
    UIP_LIST_PAGE=4,
    _ISpunct=4,
    _NL_CTYPE_GAP2=4,
    __LC_MONETARY=4,
    cftDeflate=4,
    encodingCOMPRESS=4,
    mediaCFG=4,
    ppCOPY=4,
    rateEtaKB=4,
    FLAG_INVCHECK_STRICT=5,
    F_SUBMIT_TYPE=5,
    HTML_AREA=5,
    LYE_ABORT=5,
    LYK_4=5,
    NCFTP_URL_TYPE=5,
    ORDER_BY_USER=5,
    UIP_VLINKS=5,
    _NL_CTYPE_CLASS32=5,
    __LC_MESSAGES=5,
    mediaOpt2=5,
    ppCSWING=5,
    FLAG_INVCHECK_LOOSE=6,
    F_RESET_TYPE=6,
    HTML_AU=6,
    IPPROTO_TCP=6,
    LYE_FORM_PASS=6,
    LYK_5=6,
    ORDER_BY_GROUP=6,
    UIP_LYNXCFG=6,
    WAIS_URL_TYPE=6,
    _NL_CTYPE_GAP3=6,
    __LC_ALL=6,
    ppGZIP=6,
    F_OPTION_LIST_TYPE=7,
    HTML_AUTHOR=7,
    LYE_DELN=7,
    LYK_6=7,
    NEWS_URL_TYPE=7,
    UIP_OPTIONS_MENU=7,
    _NL_CTYPE_GAP4=7,
    __LC_PAPER=7,
    ppINFLATE=7,
    DSTYLE_LINK=8,
    F_HIDDEN_TYPE=8,
    HTML_B=8,
    IPPROTO_EGP=8,
    LYE_DELC=8,
    LYK_7=8,
    NNTP_URL_TYPE=8,
    UIP_DIRED_MENU=8,
    _ISalnum=8,
    _NL_CTYPE_GAP5=8,
    __LC_NAME=8,
    encodingBZIP2=8,
    mediaUSR=8,
    ppINSTALL=8,
    F_TEXTAREA_TYPE=9,
    HTML_BANNER=9,
    LYE_DELP=9,
    LYK_8=9,
    TELNET_URL_TYPE=9,
    UIP_PERMIT_OPTIONS=9,
    _NL_CTYPE_GAP6=9,
    __LC_ADDRESS=9,
    ppMKDIR=9,
    F_RANGE_TYPE=10,
    HTML_BASE=10,
    LYE_DELNW=10,
    LYK_9=10,
    TN3270_URL_TYPE=10,
    UIP_UPLOAD_OPTIONS=10,
    _NL_CTYPE_CLASS_NAMES=10,
    __LC_TELEPHONE=10,
    ppMV=10,
    F_FILE_TYPE=11,
    HTML_BASEFONT=11,
    LYE_DELPW=11,
    LYK_SOURCE=11,
    RLOGIN_URL_TYPE=11,
    UIP_ADDRLIST_PAGE=11,
    _NL_CTYPE_MAP_NAMES=11,
    __LC_MEASUREMENT=11,
    ppRLOGIN=11,
    F_TEXT_SUBMIT_TYPE=12,
    GOPHER_URL_TYPE=12,
    HTML_BDO=12,
    IPPROTO_PUP=12,
    LYE_ERASE=12,
    LYK_RELOAD=12,
    UIP_CONFIG_DEF=12,
    _NL_CTYPE_WIDTH=12,
    __LC_IDENTIFICATION=12,
    ppRM=12,
    F_IMAGE_SUBMIT_TYPE=13,
    HTML_BGSOUND=13,
    HTML_GOPHER_URL_TYPE=13,
    LYE_BOL=13,
    LYK_QUIT=13,
    UIP_TRACELOG=13,
    _NL_CTYPE_MB_CUR_MAX=13,
    mediaOpt3=13,
    ppRMDIR=13,
    CODESET=14,
    F_KEYGEN_TYPE=14,
    HTML_BIG=14,
    LYE_EOL=14,
    LYK_ABORT=14,
    TELNET_GOPHER_URL_TYPE=14,
    UIP_INSTALL=14,
    _NL_CTYPE_CODESET_NAME=14,
    ppSETFONT=14,
    HTML_BLINK=15,
    INDEX_GOPHER_URL_TYPE=15,
    LYE_FORW=15,
    LYK_NEXT_PAGE=15,
    _NL_CTYPE_TOUPPER32=15,
    encodingALL=15,
    ppTAR=15,
    HTML_BLOCKQUOTE=16,
    LYE_FORW_RL=16,
    LYK_PREV_PAGE=16,
    MAILTO_URL_TYPE=16,
    _NL_CTYPE_TOLOWER32=16,
    mediaSYS=16,
    ppTELNET=16,
    BIBP_URL_TYPE=17,
    HTML_BODY=17,
    IPPROTO_UDP=17,
    LYE_BACK=17,
    LYK_UP_TWO=17,
    _NL_CTYPE_CLASS_OFFSET=17,
    ppTN3270=17,
    FINGER_URL_TYPE=18,
    HTML_BODYTEXT=18,
    LYE_BACK_LL=18,
    LYK_DOWN_TWO=18,
    _NL_CTYPE_MAP_OFFSET=18,
    ppTOUCH=18,
    CSO_URL_TYPE=19,
    HTML_BQ=19,
    LYE_FORWW=19,
    LYK_UP_HALF=19,
    _NL_CTYPE_INDIGITS_MB_LEN=19,
    ppUNCOMPRESS=19,
    HTML_BR=20,
    HTTPS_URL_TYPE=20,
    LYE_BACKW=20,
    LYK_DOWN_HALF=20,
    _NL_CTYPE_INDIGITS0_MB=20,
    ppUNZIP=20,
    HTML_BUTTON=21,
    LYE_LOWER=21,
    LYK_REFRESH=21,
    SNEWS_URL_TYPE=21,
    _NL_CTYPE_INDIGITS1_MB=21,
    ppUUDECODE=21,
    HTML_CAPTION=22,
    IPPROTO_IDP=22,
    LYE_UPPER=22,
    LYK_HOME=22,
    PROSPERO_URL_TYPE=22,
    _NL_CTYPE_INDIGITS2_MB=22,
    ppZCAT=22,
    AFS_URL_TYPE=23,
    HTML_CENTER=23,
    LYE_LKCMD=23,
    LYK_END=23,
    _NL_CTYPE_INDIGITS3_MB=23,
    ppZIP=23,
    DATA_URL_TYPE=24,
    HTML_CITE=24,
    LYE_AIX=24,
    LYK_FIRST_LINK=24,
    _NL_CTYPE_INDIGITS4_MB=24,
    pp_Last=24,
    HTML_CODE=25,
    LYE_DELBL=25,
    LYK_LAST_LINK=25,
    LYNXCGI_URL_TYPE=25,
    _NL_CTYPE_INDIGITS5_MB=25,
    HTML_COL=26,
    LYE_DELEL=26,
    LYK_PREV_LINK=26,
    LYNXEXEC_URL_TYPE=26,
    _NL_CTYPE_INDIGITS6_MB=26,
    HTML_COLGROUP=27,
    LYE_SWMAP=27,
    LYK_NEXT_LINK=27,
    LYNXPROG_URL_TYPE=27,
    _NL_CTYPE_INDIGITS7_MB=27,
    HTML_COMMENT=28,
    LYE_TPOS=28,
    LYK_LPOS_PREV_LINK=28,
    NEWSPOST_URL_TYPE=28,
    _NL_CTYPE_INDIGITS8_MB=28,
    HTML_CREDIT=29,
    IPPROTO_TP=29,
    LYE_SETM1=29,
    LYK_LPOS_NEXT_LINK=29,
    NEWSREPLY_URL_TYPE=29,
    _NL_CTYPE_INDIGITS9_MB=29,
    mediaOpt4=29,
    HTML_DD=30,
    LYE_SETM2=30,
    LYK_FASTBACKW_LINK=30,
    SNEWSPOST_URL_TYPE=30,
    _NL_CTYPE_INDIGITS_WC_LEN=30,
    HTML_DEL=31,
    LYE_UNMOD=31,
    LYK_FASTFORW_LINK=31,
    SNEWSREPLY_URL_TYPE=31,
    _NL_CTYPE_INDIGITS0_WC=31,
    mediaALL=31,
    HTML_DFN=32,
    LYE_C1CHAR=32,
    LYK_UP_LINK=32,
    LYNXCACHE_URL_TYPE=32,
    _NL_CTYPE_INDIGITS1_WC=32,
    HTML_DIR=33,
    IPPROTO_DCCP=33,
    LYE_SETMARK=33,
    LYK_DOWN_LINK=33,
    LYNXCFG_URL_TYPE=33,
    _NL_CTYPE_INDIGITS2_WC=33,
    HTML_DIV=34,
    LYE_XPMARK=34,
    LYK_RIGHT_LINK=34,
    LYNXCOMPILE_OPTS_URL_TYPE=34,
    _NL_CTYPE_INDIGITS3_WC=34,
    HTML_DL=35,
    LYE_KILLREG=35,
    LYK_LEFT_LINK=35,
    LYNXCOOKIE_URL_TYPE=35,
    _NL_CTYPE_INDIGITS4_WC=35,
    HTML_DLC=36,
    LYE_YANK=36,
    LYK_HISTORY=36,
    LYNXDIRED_URL_TYPE=36,
    _NL_CTYPE_INDIGITS5_WC=36,
    HTML_DT=37,
    LYE_PASTE=37,
    LYK_PREV_DOC=37,
    LYNXDOWNLOAD_URL_TYPE=37,
    _NL_CTYPE_INDIGITS6_WC=37,
    HTML_EM=38,
    LYK_NEXT_DOC=38,
    LYNXHIST_URL_TYPE=38,
    _NL_CTYPE_INDIGITS7_WC=38,
    HTML_EMBED=39,
    LYK_ACTIVATE=39,
    LYNXIMGMAP_URL_TYPE=39,
    _NL_CTYPE_INDIGITS8_WC=39,
    HTML_FIELDSET=40,
    LYK_SUBMIT=40,
    LYNXKEYMAP_URL_TYPE=40,
    _NL_CTYPE_INDIGITS9_WC=40,
    HTML_FIG=41,
    IPPROTO_IPV6=41,
    LYK_GOTO=41,
    LYNXMESSAGES_URL_TYPE=41,
    _NL_CTYPE_OUTDIGIT0_MB=41,
    HTML_FN=42,
    LYK_ECGOTO=42,
    LYNXOPTIONS_URL_TYPE=42,
    _NL_CTYPE_OUTDIGIT1_MB=42,
    HTML_FONT=43,
    IPPROTO_ROUTING=43,
    LYK_HELP=43,
    LYNXPRINT_URL_TYPE=43,
    _NL_CTYPE_OUTDIGIT2_MB=43,
    HTML_FORM=44,
    IPPROTO_FRAGMENT=44,
    LYK_DWIMHELP=44,
    PROXY_URL_TYPE=44,
    _NL_CTYPE_OUTDIGIT3_MB=44,
    HTML_FRAME=45,
    LYK_INDEX=45,
    _NL_CTYPE_OUTDIGIT4_MB=45,
    HTML_FRAMESET=46,
    IPPROTO_RSVP=46,
    LYK_NOCACHE=46,
    _NL_CTYPE_OUTDIGIT5_MB=46,
    HTML_H1=47,
    IPPROTO_GRE=47,
    LYK_INTERRUPT=47,
    _NL_CTYPE_OUTDIGIT6_MB=47,
    HTML_H2=48,
    LYK_MAIN_MENU=48,
    _NL_CTYPE_OUTDIGIT7_MB=48,
    HTML_H3=49,
    LYK_OPTIONS=49,
    _NL_CTYPE_OUTDIGIT8_MB=49,
    HTML_H4=50,
    IPPROTO_ESP=50,
    LYK_INDEX_SEARCH=50,
    _NL_CTYPE_OUTDIGIT9_MB=50,
    HTML_H5=51,
    IPPROTO_AH=51,
    LYK_WHEREIS=51,
    _NL_CTYPE_OUTDIGIT0_WC=51,
    HTML_H6=52,
    LYK_PREV=52,
    _NL_CTYPE_OUTDIGIT1_WC=52,
    HTML_HEAD=53,
    LYK_NEXT=53,
    _NL_CTYPE_OUTDIGIT2_WC=53,
    HTML_HR=54,
    LYK_COMMENT=54,
    _NL_CTYPE_OUTDIGIT3_WC=54,
    HTML_HTML=55,
    LYK_EDIT=55,
    _NL_CTYPE_OUTDIGIT4_WC=55,
    HTML_HY=56,
    LYK_INFO=56,
    _NL_CTYPE_OUTDIGIT5_WC=56,
    HTML_I=57,
    LYK_PRINT=57,
    _NL_CTYPE_OUTDIGIT6_WC=57,
    HTML_IFRAME=58,
    IPPROTO_ICMPV6=58,
    LYK_ADD_BOOKMARK=58,
    _NL_CTYPE_OUTDIGIT7_WC=58,
    HTML_IMG=59,
    IPPROTO_NONE=59,
    LYK_DEL_BOOKMARK=59,
    _NL_CTYPE_OUTDIGIT8_WC=59,
    HTML_INPUT=60,
    IPPROTO_DSTOPTS=60,
    LYK_VIEW_BOOKMARK=60,
    _NL_CTYPE_OUTDIGIT9_WC=60,
    HTML_INS=61,
    LYK_VLINKS=61,
    _NL_CTYPE_TRANSLIT_TAB_SIZE=61,
    HTML_ISINDEX=62,
    LYK_SHELL=62,
    _NL_CTYPE_TRANSLIT_FROM_IDX=62,
    HTML_KBD=63,
    LYK_DOWNLOAD=63,
    _NL_CTYPE_TRANSLIT_FROM_TBL=63,
    HTML_KEYGEN=64,
    LYK_TRACE_TOGGLE=64,
    _NL_CTYPE_TRANSLIT_TO_IDX=64,
    HTML_LABEL=65,
    LYK_TRACE_LOG=65,
    _NL_CTYPE_TRANSLIT_TO_TBL=65,
    HTML_LEGEND=66,
    LYK_IMAGE_TOGGLE=66,
    _NL_CTYPE_TRANSLIT_DEFAULT_MISSING_LEN=66,
    HTML_LH=67,
    LYK_INLINE_TOGGLE=67,
    _NL_CTYPE_TRANSLIT_DEFAULT_MISSING=67,
    HTML_LI=68,
    LYK_HEAD=68,
    _NL_CTYPE_TRANSLIT_IGNORE_LEN=68,
    HTML_LINK=69,
    LYK_DO_NOTHING=69,
    _NL_CTYPE_TRANSLIT_IGNORE=69,
    HTML_LISTING=70,
    LYK_TOGGLE_HELP=70,
    _NL_CTYPE_MAP_TO_NONASCII=70,
    HTML_MAP=71,
    LYK_JUMP=71,
    _NL_CTYPE_EXTRA_MAP_1=71,
    HTML_MARQUEE=72,
    LYK_KEYMAP=72,
    _NL_CTYPE_EXTRA_MAP_2=72,
    HTML_MATH=73,
    LYK_LIST=73,
    _NL_CTYPE_EXTRA_MAP_3=73,
    HTML_MENU=74,
    LYK_TOOLBAR=74,
    _NL_CTYPE_EXTRA_MAP_4=74,
    HTML_META=75,
    LYK_HISTORICAL=75,
    _NL_CTYPE_EXTRA_MAP_5=75,
    HTML_NEXTID=76,
    LYK_MINIMAL=76,
    _NL_CTYPE_EXTRA_MAP_6=76,
    HTML_NOFRAMES=77,
    LYK_SOFT_DQUOTES=77,
    _NL_CTYPE_EXTRA_MAP_7=77,
    HTML_NOTE=78,
    LYK_RAW_TOGGLE=78,
    _NL_CTYPE_EXTRA_MAP_8=78,
    HTML_OBJECT=79,
    LYK_COOKIE_JAR=79,
    _NL_CTYPE_EXTRA_MAP_9=79,
    HTML_OL=80,
    LYK_F_LINK_NUM=80,
    _NL_CTYPE_EXTRA_MAP_10=80,
    HTML_OPTION=81,
    LYK_CLEAR_AUTH=81,
    _NL_CTYPE_EXTRA_MAP_11=81,
    HTML_OVERLAY=82,
    LYK_SWITCH_DTD=82,
    _NL_CTYPE_EXTRA_MAP_12=82,
    HTML_P=83,
    LYK_ELGOTO=83,
    _NL_CTYPE_EXTRA_MAP_13=83,
    HTML_PARAM=84,
    LYK_CHANGE_LINK=84,
    _NL_CTYPE_EXTRA_MAP_14=84,
    HTML_PLAINTEXT=85,
    LYK_DWIMEDIT=85,
    _NL_NUM_LC_CTYPE=85,
    HTML_PRE=86,
    LYK_EDIT_TEXTAREA=86,
    HTML_Q=87,
    LYK_GROW_TEXTAREA=87,
    HTML_S=88,
    LYK_INSERT_FILE=88,
    HTML_SAMP=89,
    LYK_EXTERN_LINK=89,
    HTML_SCRIPT=90,
    LYK_EXTERN_PAGE=90,
    HTML_SELECT=91,
    LYK_DIRED_MENU=91,
    HTML_SHY=92,
    IPPROTO_MTP=92,
    LYK_CREATE=92,
    HTML_SMALL=93,
    LYK_REMOVE=93,
    HTML_SPAN=94,
    LYK_MODIFY=94,
    HTML_SPOT=95,
    LYK_TAG_LINK=95,
    HTML_STRIKE=96,
    LYK_UPLOAD=96,
    HTML_STRONG=97,
    LYK_INSTALL=97,
    HTML_STYLE=98,
    IPPROTO_ENCAP=98,
    LYK_CHG_CENTER=98,
    HTML_SUB=99,
    LYK_CHDIR=99,
    HTML_SUP=100,
    LYK_SHIFT_LEFT=100,
    HTML_TAB=101,
    LYK_SHIFT_RIGHT=101,
    HTML_TABLE=102,
    LYK_LINEWRAP_TOGGLE=102,
    HTML_TBODY=103,
    IPPROTO_PIM=103,
    LYK_PASTE_URL=103,
    HTML_TD=104,
    LYK_TO_CLIPBOARD=104,
    HTML_TEXTAREA=105,
    LYK_NESTED_TABLES=105,
    HTML_TEXTFLOW=106,
    HTML_TFOOT=107,
    HTML_TH=108,
    IPPROTO_COMP=108,
    HTML_THEAD=109,
    HTML_TITLE=110,
    HTML_TR=111,
    HTML_TT=112,
    HTML_U=113,
    HTML_UL=114,
    HTML_VAR=115,
    HTML_WBR=116,
    HTML_XMP=117,
    HTML_ALT_OBJECT=118,
    DSTYLE_STATUS=126,
    DSTYLE_ALINK=127,
    DSTYLE_NORMAL=128,
    DSTYLE_OPTION=129,
    DSTYLE_VALUE=130,
    DSTYLE_CANDY=131,
    DSTYLE_WHEREIS=132,
    IPPROTO_SCTP=132,
    DSTYLE_ELEMENTS=133,
    IPPROTO_UDPLITE=136,
    IPPROTO_RAW=255,
    IPPROTO_MAX=256,
    _ISupper=256,
    _ISlower=512,
    _ISalpha=1024,
    POOL_SIZE=2042,
    _ISdigit=2048,
    _ISxdigit=4096,
    _ISspace=8192,
    _ISprint=16384,
    _ISgraph=32768,
    RADIXCHAR=65536,
    __DECIMAL_POINT=65536,
    THOUSEP=65537,
    __THOUSANDS_SEP=65537,
    __GROUPING=65538,
    _NL_NUMERIC_DECIMAL_POINT_WC=65539,
    _NL_NUMERIC_THOUSANDS_SEP_WC=65540,
    _NL_NUMERIC_CODESET=65541,
    _NL_NUM_LC_NUMERIC=65542,
    ABDAY_1=131072,
    ABDAY_2=131073,
    ABDAY_3=131074,
    ABDAY_4=131075,
    ABDAY_5=131076,
    ABDAY_6=131077,
    ABDAY_7=131078,
    DAY_1=131079,
    DAY_2=131080,
    DAY_3=131081,
    DAY_4=131082,
    DAY_5=131083,
    DAY_6=131084,
    DAY_7=131085,
    ABMON_1=131086,
    ABMON_2=131087,
    ABMON_3=131088,
    ABMON_4=131089,
    ABMON_5=131090,
    ABMON_6=131091,
    ABMON_7=131092,
    ABMON_8=131093,
    ABMON_9=131094,
    ABMON_10=131095,
    ABMON_11=131096,
    ABMON_12=131097,
    MON_1=131098,
    MON_2=131099,
    MON_3=131100,
    MON_4=131101,
    MON_5=131102,
    MON_6=131103,
    MON_7=131104,
    MON_8=131105,
    MON_9=131106,
    MON_10=131107,
    MON_11=131108,
    MON_12=131109,
    AM_STR=131110,
    PM_STR=131111,
    D_T_FMT=131112,
    D_FMT=131113,
    T_FMT=131114,
    T_FMT_AMPM=131115,
    ERA=131116,
    __ERA_YEAR=131117,
    ERA_D_FMT=131118,
    ALT_DIGITS=131119,
    ERA_D_T_FMT=131120,
    ERA_T_FMT=131121,
    _NL_TIME_ERA_NUM_ENTRIES=131122,
    _NL_TIME_ERA_ENTRIES=131123,
    _NL_WABDAY_1=131124,
    _NL_WABDAY_2=131125,
    _NL_WABDAY_3=131126,
    _NL_WABDAY_4=131127,
    _NL_WABDAY_5=131128,
    _NL_WABDAY_6=131129,
    _NL_WABDAY_7=131130,
    _NL_WDAY_1=131131,
    _NL_WDAY_2=131132,
    _NL_WDAY_3=131133,
    _NL_WDAY_4=131134,
    _NL_WDAY_5=131135,
    _NL_WDAY_6=131136,
    _NL_WDAY_7=131137,
    _NL_WABMON_1=131138,
    _NL_WABMON_2=131139,
    _NL_WABMON_3=131140,
    _NL_WABMON_4=131141,
    _NL_WABMON_5=131142,
    _NL_WABMON_6=131143,
    _NL_WABMON_7=131144,
    _NL_WABMON_8=131145,
    _NL_WABMON_9=131146,
    _NL_WABMON_10=131147,
    _NL_WABMON_11=131148,
    _NL_WABMON_12=131149,
    _NL_WMON_1=131150,
    _NL_WMON_2=131151,
    _NL_WMON_3=131152,
    _NL_WMON_4=131153,
    _NL_WMON_5=131154,
    _NL_WMON_6=131155,
    _NL_WMON_7=131156,
    _NL_WMON_8=131157,
    _NL_WMON_9=131158,
    _NL_WMON_10=131159,
    _NL_WMON_11=131160,
    _NL_WMON_12=131161,
    _NL_WAM_STR=131162,
    _NL_WPM_STR=131163,
    _NL_WD_T_FMT=131164,
    _NL_WD_FMT=131165,
    _NL_WT_FMT=131166,
    _NL_WT_FMT_AMPM=131167,
    _NL_WERA_YEAR=131168,
    _NL_WERA_D_FMT=131169,
    _NL_WALT_DIGITS=131170,
    _NL_WERA_D_T_FMT=131171,
    _NL_WERA_T_FMT=131172,
    _NL_TIME_WEEK_NDAYS=131173,
    _NL_TIME_WEEK_1STDAY=131174,
    _NL_TIME_WEEK_1STWEEK=131175,
    _NL_TIME_FIRST_WEEKDAY=131176,
    _NL_TIME_FIRST_WORKDAY=131177,
    _NL_TIME_CAL_DIRECTION=131178,
    _NL_TIME_TIMEZONE=131179,
    _DATE_FMT=131180,
    _NL_W_DATE_FMT=131181,
    _NL_TIME_CODESET=131182,
    _NL_NUM_LC_TIME=131183,
    _NL_COLLATE_NRULES=196608,
    _NL_COLLATE_RULESETS=196609,
    _NL_COLLATE_TABLEMB=196610,
    _NL_COLLATE_WEIGHTMB=196611,
    _NL_COLLATE_EXTRAMB=196612,
    _NL_COLLATE_INDIRECTMB=196613,
    _NL_COLLATE_GAP1=196614,
    _NL_COLLATE_GAP2=196615,
    _NL_COLLATE_GAP3=196616,
    _NL_COLLATE_TABLEWC=196617,
    _NL_COLLATE_WEIGHTWC=196618,
    _NL_COLLATE_EXTRAWC=196619,
    _NL_COLLATE_INDIRECTWC=196620,
    _NL_COLLATE_SYMB_HASH_SIZEMB=196621,
    _NL_COLLATE_SYMB_TABLEMB=196622,
    _NL_COLLATE_SYMB_EXTRAMB=196623,
    _NL_COLLATE_COLLSEQMB=196624,
    _NL_COLLATE_COLLSEQWC=196625,
    _NL_COLLATE_CODESET=196626,
    _NL_NUM_LC_COLLATE=196627,
    __INT_CURR_SYMBOL=262144,
    __CURRENCY_SYMBOL=262145,
    __MON_DECIMAL_POINT=262146,
    __MON_THOUSANDS_SEP=262147,
    __MON_GROUPING=262148,
    __POSITIVE_SIGN=262149,
    __NEGATIVE_SIGN=262150,
    __INT_FRAC_DIGITS=262151,
    __FRAC_DIGITS=262152,
    __P_CS_PRECEDES=262153,
    __P_SEP_BY_SPACE=262154,
    __N_CS_PRECEDES=262155,
    __N_SEP_BY_SPACE=262156,
    __P_SIGN_POSN=262157,
    __N_SIGN_POSN=262158,
    _NL_MONETARY_CRNCYSTR=262159,
    __INT_P_CS_PRECEDES=262160,
    __INT_P_SEP_BY_SPACE=262161,
    __INT_N_CS_PRECEDES=262162,
    __INT_N_SEP_BY_SPACE=262163,
    __INT_P_SIGN_POSN=262164,
    __INT_N_SIGN_POSN=262165,
    _NL_MONETARY_DUO_INT_CURR_SYMBOL=262166,
    _NL_MONETARY_DUO_CURRENCY_SYMBOL=262167,
    _NL_MONETARY_DUO_INT_FRAC_DIGITS=262168,
    _NL_MONETARY_DUO_FRAC_DIGITS=262169,
    _NL_MONETARY_DUO_P_CS_PRECEDES=262170,
    _NL_MONETARY_DUO_P_SEP_BY_SPACE=262171,
    _NL_MONETARY_DUO_N_CS_PRECEDES=262172,
    _NL_MONETARY_DUO_N_SEP_BY_SPACE=262173,
    _NL_MONETARY_DUO_INT_P_CS_PRECEDES=262174,
    _NL_MONETARY_DUO_INT_P_SEP_BY_SPACE=262175,
    _NL_MONETARY_DUO_INT_N_CS_PRECEDES=262176,
    _NL_MONETARY_DUO_INT_N_SEP_BY_SPACE=262177,
    _NL_MONETARY_DUO_P_SIGN_POSN=262178,
    _NL_MONETARY_DUO_N_SIGN_POSN=262179,
    _NL_MONETARY_DUO_INT_P_SIGN_POSN=262180,
    _NL_MONETARY_DUO_INT_N_SIGN_POSN=262181,
    _NL_MONETARY_UNO_VALID_FROM=262182,
    _NL_MONETARY_UNO_VALID_TO=262183,
    _NL_MONETARY_DUO_VALID_FROM=262184,
    _NL_MONETARY_DUO_VALID_TO=262185,
    _NL_MONETARY_CONVERSION_RATE=262186,
    _NL_MONETARY_DECIMAL_POINT_WC=262187,
    _NL_MONETARY_THOUSANDS_SEP_WC=262188,
    _NL_MONETARY_CODESET=262189,
    _NL_NUM_LC_MONETARY=262190,
    __YESEXPR=327680,
    __NOEXPR=327681,
    __YESSTR=327682,
    __NOSTR=327683,
    _NL_MESSAGES_CODESET=327684,
    _NL_NUM_LC_MESSAGES=327685,
    _NL_PAPER_HEIGHT=458752,
    _NL_PAPER_WIDTH=458753,
    _NL_PAPER_CODESET=458754,
    _NL_NUM_LC_PAPER=458755,
    _NL_NAME_NAME_FMT=524288,
    _NL_NAME_NAME_GEN=524289,
    _NL_NAME_NAME_MR=524290,
    _NL_NAME_NAME_MRS=524291,
    _NL_NAME_NAME_MISS=524292,
    _NL_NAME_NAME_MS=524293,
    _NL_NAME_CODESET=524294,
    _NL_NUM_LC_NAME=524295,
    _NL_ADDRESS_POSTAL_FMT=589824,
    _NL_ADDRESS_COUNTRY_NAME=589825,
    _NL_ADDRESS_COUNTRY_POST=589826,
    _NL_ADDRESS_COUNTRY_AB2=589827,
    _NL_ADDRESS_COUNTRY_AB3=589828,
    _NL_ADDRESS_COUNTRY_CAR=589829,
    _NL_ADDRESS_COUNTRY_NUM=589830,
    _NL_ADDRESS_COUNTRY_ISBN=589831,
    _NL_ADDRESS_LANG_NAME=589832,
    _NL_ADDRESS_LANG_AB=589833,
    _NL_ADDRESS_LANG_TERM=589834,
    _NL_ADDRESS_LANG_LIB=589835,
    _NL_ADDRESS_CODESET=589836,
    _NL_NUM_LC_ADDRESS=589837,
    _NL_TELEPHONE_TEL_INT_FMT=655360,
    _NL_TELEPHONE_TEL_DOM_FMT=655361,
    _NL_TELEPHONE_INT_SELECT=655362,
    _NL_TELEPHONE_INT_PREFIX=655363,
    _NL_TELEPHONE_CODESET=655364,
    _NL_NUM_LC_TELEPHONE=655365,
    _NL_MEASUREMENT_MEASUREMENT=720896,
    _NL_MEASUREMENT_CODESET=720897,
    _NL_NUM_LC_MEASUREMENT=720898,
    _NL_IDENTIFICATION_TITLE=786432,
    _NL_IDENTIFICATION_SOURCE=786433,
    _NL_IDENTIFICATION_ADDRESS=786434,
    _NL_IDENTIFICATION_CONTACT=786435,
    _NL_IDENTIFICATION_EMAIL=786436,
    _NL_IDENTIFICATION_TEL=786437,
    _NL_IDENTIFICATION_FAX=786438,
    _NL_IDENTIFICATION_LANGUAGE=786439,
    _NL_IDENTIFICATION_TERRITORY=786440,
    _NL_IDENTIFICATION_AUDIENCE=786441,
    _NL_IDENTIFICATION_APPLICATION=786442,
    _NL_IDENTIFICATION_ABBREVIATION=786443,
    _NL_IDENTIFICATION_REVISION=786444,
    _NL_IDENTIFICATION_DATE=786445,
    _NL_IDENTIFICATION_CATEGORY=786446,
    _NL_IDENTIFICATION_CODESET=786447,
    _NL_NUM_LC_IDENTIFICATION=786448,
    _NL_NUM=786449
} anon_enum_32;

typedef enum UIP_t {
    UIP_UNKNOWN=-1,
    UIP_HISTORY=0,
    UIP_DOWNLOAD_OPTIONS=1,
    UIP_PRINT_OPTIONS=2,
    UIP_SHOWINFO=3,
    UIP_LIST_PAGE=4,
    UIP_VLINKS=5,
    UIP_LYNXCFG=6,
    UIP_OPTIONS_MENU=7,
    UIP_DIRED_MENU=8,
    UIP_PERMIT_OPTIONS=9,
    UIP_UPLOAD_OPTIONS=10,
    UIP_ADDRLIST_PAGE=11,
    UIP_CONFIG_DEF=12,
    UIP_TRACELOG=13,
    UIP_INSTALL=14
} UIP_t;

typedef enum UrlTypes {
    NOT_A_URL_TYPE=0,
    UNKNOWN_URL_TYPE=1,
    HTTP_URL_TYPE=2,
    FILE_URL_TYPE=3,
    FTP_URL_TYPE=4,
    NCFTP_URL_TYPE=5,
    WAIS_URL_TYPE=6,
    NEWS_URL_TYPE=7,
    NNTP_URL_TYPE=8,
    TELNET_URL_TYPE=9,
    TN3270_URL_TYPE=10,
    RLOGIN_URL_TYPE=11,
    GOPHER_URL_TYPE=12,
    HTML_GOPHER_URL_TYPE=13,
    TELNET_GOPHER_URL_TYPE=14,
    INDEX_GOPHER_URL_TYPE=15,
    MAILTO_URL_TYPE=16,
    BIBP_URL_TYPE=17,
    FINGER_URL_TYPE=18,
    CSO_URL_TYPE=19,
    HTTPS_URL_TYPE=20,
    SNEWS_URL_TYPE=21,
    PROSPERO_URL_TYPE=22,
    AFS_URL_TYPE=23,
    DATA_URL_TYPE=24,
    LYNXCGI_URL_TYPE=25,
    LYNXEXEC_URL_TYPE=26,
    LYNXPROG_URL_TYPE=27,
    NEWSPOST_URL_TYPE=28,
    NEWSREPLY_URL_TYPE=29,
    SNEWSPOST_URL_TYPE=30,
    SNEWSREPLY_URL_TYPE=31,
    LYNXCACHE_URL_TYPE=32,
    LYNXCFG_URL_TYPE=33,
    LYNXCOMPILE_OPTS_URL_TYPE=34,
    LYNXCOOKIE_URL_TYPE=35,
    LYNXDIRED_URL_TYPE=36,
    LYNXDOWNLOAD_URL_TYPE=37,
    LYNXHIST_URL_TYPE=38,
    LYNXIMGMAP_URL_TYPE=39,
    LYNXKEYMAP_URL_TYPE=40,
    LYNXMESSAGES_URL_TYPE=41,
    LYNXOPTIONS_URL_TYPE=42,
    LYNXPRINT_URL_TYPE=43,
    PROXY_URL_TYPE=44
} UrlTypes;

typedef struct _names_pairs _names_pairs, *P_names_pairs;

typedef struct _names_pairs names_pairs;

struct _names_pairs {
    char * fullname;
    char * MIMEname;
};

typedef struct uipage_entry uipage_entry, *Puipage_entry;

struct uipage_entry {
    enum UIP_t type;
    uint flags;
    char * url;
    HTList * alturls;
    char * file;
};

typedef struct _LYTemp _LYTemp, *P_LYTemp;

struct _LYTemp {
    struct _LYTemp * next;
    char * name;
    BOOLEAN outs;
    FILE * file;
};

typedef struct anon_struct_12_3_98742a7b anon_struct_12_3_98742a7b, *Panon_struct_12_3_98742a7b;

struct anon_struct_12_3_98742a7b {
    char * name;
    BOOLEAN * flag;
    BOOLEAN can;
};

typedef struct _LYTemp LY_TEMP;

typedef struct uipage_entry uip_entry;

typedef enum ProgramPaths {
    ppUnknown=0,
    ppBZIP2=1,
    ppCHMOD=2,
    ppCOMPRESS=3,
    ppCOPY=4,
    ppCSWING=5,
    ppGZIP=6,
    ppINFLATE=7,
    ppINSTALL=8,
    ppMKDIR=9,
    ppMV=10,
    ppRLOGIN=11,
    ppRM=12,
    ppRMDIR=13,
    ppSETFONT=14,
    ppTAR=15,
    ppTELNET=16,
    ppTN3270=17,
    ppTOUCH=18,
    ppUNCOMPRESS=19,
    ppUNZIP=20,
    ppUUDECODE=21,
    ppZCAT=22,
    ppZIP=23,
    pp_Last=24
} ProgramPaths;

typedef enum CompressFileType {
    cftNone=0,
    cftCompress=1,
    cftGzip=2,
    cftBzip2=3,
    cftDeflate=4
} CompressFileType;

typedef struct ANY_KEYS ANY_KEYS, *PANY_KEYS;

struct ANY_KEYS {
    int code;
    LYKeymap_t map;
    LYKeymap_t save;
};

typedef struct emap emap, *Pemap;

struct emap {
    char * name;
    int code;
    char * descr;
};

typedef struct anon_struct_8_2_19f06807 anon_struct_8_2_19f06807, *Panon_struct_8_2_19f06807;

struct anon_struct_8_2_19f06807 {
    int key;
    char * name;
};

typedef struct anon_struct_8_2_38238c5b anon_struct_8_2_38238c5b, *Panon_struct_8_2_38238c5b;

struct anon_struct_8_2_38238c5b {
    int code;
    char * name;
};

typedef struct __sigset_t sigset_t;

typedef struct fd_set fd_set, *Pfd_set;

struct fd_set {
    __fd_mask fds_bits[32];
};

typedef struct _NNTPAuth _NNTPAuth, *P_NNTPAuth;

typedef struct _NNTPAuth NNTPAuth;

struct _NNTPAuth {
    char * host;
    char * user;
    char * pass;
};

typedef enum NNTPAuthResult {
    NNTPAUTH_ERROR=0,
    NNTPAUTH_OK=281,
    NNTPAUTH_CLOSE=502
} NNTPAuthResult;


// WARNING! conflicting data type names: /stdarg.h/__gnuc_va_list - /DWARF/stdarg.h/__gnuc_va_list


// WARNING! conflicting data type names: /time.h/timeval - /DWARF/time.h/timeval


// WARNING! conflicting data type names: /time.h/timezone - /DWARF/time.h/timezone

typedef struct timezone * __timezone_ptr_t;


// WARNING! conflicting data type names: /time.h/time_t - /DWARF/time.h/time_t


// WARNING! conflicting data type names: /sigaction.h/sigaction - /DWARF/sigaction.h/sigaction

typedef union _union_1051 _union_1051, *P_union_1051;


// WARNING! conflicting data type names: /signal.h/__sighandler_t - /DWARF/signal.h/__sighandler_t

union _union_1051 {
    __sighandler_t sa_handler;
    void (* sa_sigaction)(int, siginfo_t *, void *);
};


// WARNING! conflicting data type names: /select.h/__fd_mask - /DWARF/__fd_mask


// WARNING! conflicting data type names: /select.h/fd_set - /DWARF/select.h/fd_set

typedef int (* __compar_fn_t)(void *, void *);

typedef struct Elf32_Shdr Elf32_Shdr, *PElf32_Shdr;

typedef enum Elf_SectionHeaderType_x86 {
    SHT_NULL=0,
    SHT_PROGBITS=1,
    SHT_SYMTAB=2,
    SHT_STRTAB=3,
    SHT_RELA=4,
    SHT_HASH=5,
    SHT_DYNAMIC=6,
    SHT_NOTE=7,
    SHT_NOBITS=8,
    SHT_REL=9,
    SHT_SHLIB=10,
    SHT_DYNSYM=11,
    SHT_INIT_ARRAY=14,
    SHT_FINI_ARRAY=15,
    SHT_PREINIT_ARRAY=16,
    SHT_GROUP=17,
    SHT_SYMTAB_SHNDX=18,
    SHT_ANDROID_REL=1610612737,
    SHT_ANDROID_RELA=1610612738,
    SHT_GNU_ATTRIBUTES=1879048181,
    SHT_GNU_HASH=1879048182,
    SHT_GNU_LIBLIST=1879048183,
    SHT_CHECKSUM=1879048184,
    SHT_SUNW_move=1879048186,
    SHT_SUNW_COMDAT=1879048187,
    SHT_SUNW_syminfo=1879048188,
    SHT_GNU_verdef=1879048189,
    SHT_GNU_verneed=1879048190,
    SHT_GNU_versym=1879048191
} Elf_SectionHeaderType_x86;

struct Elf32_Shdr {
    dword sh_name;
    enum Elf_SectionHeaderType_x86 sh_type;
    dword sh_flags;
    dword sh_addr;
    dword sh_offset;
    dword sh_size;
    dword sh_link;
    dword sh_info;
    dword sh_addralign;
    dword sh_entsize;
};

typedef struct Elf32_Dyn_x86 Elf32_Dyn_x86, *PElf32_Dyn_x86;

typedef enum Elf32_DynTag_x86 {
    DT_NULL=0,
    DT_NEEDED=1,
    DT_PLTRELSZ=2,
    DT_PLTGOT=3,
    DT_HASH=4,
    DT_STRTAB=5,
    DT_SYMTAB=6,
    DT_RELA=7,
    DT_RELASZ=8,
    DT_RELAENT=9,
    DT_STRSZ=10,
    DT_SYMENT=11,
    DT_INIT=12,
    DT_FINI=13,
    DT_SONAME=14,
    DT_RPATH=15,
    DT_SYMBOLIC=16,
    DT_REL=17,
    DT_RELSZ=18,
    DT_RELENT=19,
    DT_PLTREL=20,
    DT_DEBUG=21,
    DT_TEXTREL=22,
    DT_JMPREL=23,
    DT_BIND_NOW=24,
    DT_INIT_ARRAY=25,
    DT_FINI_ARRAY=26,
    DT_INIT_ARRAYSZ=27,
    DT_FINI_ARRAYSZ=28,
    DT_RUNPATH=29,
    DT_FLAGS=30,
    DT_PREINIT_ARRAY=32,
    DT_PREINIT_ARRAYSZ=33,
    DT_RELRSZ=35,
    DT_RELR=36,
    DT_RELRENT=37,
    DT_ANDROID_REL=1610612751,
    DT_ANDROID_RELSZ=1610612752,
    DT_ANDROID_RELA=1610612753,
    DT_ANDROID_RELASZ=1610612754,
    DT_ANDROID_RELR=1879040000,
    DT_ANDROID_RELRSZ=1879040001,
    DT_ANDROID_RELRENT=1879040003,
    DT_GNU_PRELINKED=1879047669,
    DT_GNU_CONFLICTSZ=1879047670,
    DT_GNU_LIBLISTSZ=1879047671,
    DT_CHECKSUM=1879047672,
    DT_PLTPADSZ=1879047673,
    DT_MOVEENT=1879047674,
    DT_MOVESZ=1879047675,
    DT_FEATURE_1=1879047676,
    DT_POSFLAG_1=1879047677,
    DT_SYMINSZ=1879047678,
    DT_SYMINENT=1879047679,
    DT_GNU_XHASH=1879047924,
    DT_GNU_HASH=1879047925,
    DT_TLSDESC_PLT=1879047926,
    DT_TLSDESC_GOT=1879047927,
    DT_GNU_CONFLICT=1879047928,
    DT_GNU_LIBLIST=1879047929,
    DT_CONFIG=1879047930,
    DT_DEPAUDIT=1879047931,
    DT_AUDIT=1879047932,
    DT_PLTPAD=1879047933,
    DT_MOVETAB=1879047934,
    DT_SYMINFO=1879047935,
    DT_VERSYM=1879048176,
    DT_RELACOUNT=1879048185,
    DT_RELCOUNT=1879048186,
    DT_FLAGS_1=1879048187,
    DT_VERDEF=1879048188,
    DT_VERDEFNUM=1879048189,
    DT_VERNEED=1879048190,
    DT_VERNEEDNUM=1879048191,
    DT_AUXILIARY=2147483645,
    DT_FILTER=2147483647
} Elf32_DynTag_x86;

struct Elf32_Dyn_x86 {
    enum Elf32_DynTag_x86 d_tag;
    dword d_val;
};

typedef struct Elf32_Sym Elf32_Sym, *PElf32_Sym;

struct Elf32_Sym {
    dword st_name;
    dword st_value;
    dword st_size;
    byte st_info;
    byte st_other;
    word st_shndx;
};

typedef struct Elf32_Phdr Elf32_Phdr, *PElf32_Phdr;

typedef enum Elf_ProgramHeaderType_x86 {
    PT_NULL=0,
    PT_LOAD=1,
    PT_DYNAMIC=2,
    PT_INTERP=3,
    PT_NOTE=4,
    PT_SHLIB=5,
    PT_PHDR=6,
    PT_TLS=7,
    PT_GNU_EH_FRAME=1685382480,
    PT_GNU_STACK=1685382481,
    PT_GNU_RELRO=1685382482
} Elf_ProgramHeaderType_x86;

struct Elf32_Phdr {
    enum Elf_ProgramHeaderType_x86 p_type;
    dword p_offset;
    dword p_vaddr;
    dword p_paddr;
    dword p_filesz;
    dword p_memsz;
    dword p_flags;
    dword p_align;
};

typedef struct NoteAbiTag NoteAbiTag, *PNoteAbiTag;

struct NoteAbiTag {
    dword namesz; // Length of name field
    dword descsz; // Length of description field
    dword type; // Vendor specific type
    char name[4]; // Vendor name
    dword abiType; // 0 == Linux
    dword requiredKernelVersion[3]; // Major.minor.patch
};

typedef struct Elf32_Rel Elf32_Rel, *PElf32_Rel;

struct Elf32_Rel {
    dword r_offset; // location to apply the relocation action
    dword r_info; // the symbol table index and the type of relocation
};

typedef struct Elf32_Ehdr Elf32_Ehdr, *PElf32_Ehdr;

struct Elf32_Ehdr {
    byte e_ident_magic_num;
    char e_ident_magic_str[3];
    byte e_ident_class;
    byte e_ident_data;
    byte e_ident_version;
    byte e_ident_osabi;
    byte e_ident_abiversion;
    byte e_ident_pad[7];
    word e_type;
    word e_machine;
    dword e_version;
    dword e_entry;
    dword e_phoff;
    dword e_shoff;
    dword e_flags;
    word e_ehsize;
    word e_phentsize;
    word e_phnum;
    word e_shentsize;
    word e_shnum;
    word e_shstrndx;
};


// WARNING! conflicting data type names: /stdint.h/uint16_t - /DWARF/uint16_t




int _init(EVP_PKEY_CTX *ctx)

{
  int iStack_c;
  
  __gmon_start__();
  frame_dummy();
  __do_global_ctors_aux();
  return iStack_c;
}



void FUN_0804a764(void)

{
                    // WARNING: Treating indirect jump as call
  (*(code *)(undefined *)0x0)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int fileno(FILE *__stream)

{
  int iVar1;
  
  iVar1 = fileno(__stream);
  return iVar1;
}



void scrollok(void)

{
  scrollok();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int fputs(char *__s,FILE *__stream)

{
  int iVar1;
  
  iVar1 = fputs(__s,__stream);
  return iVar1;
}



void ungetmouse(void)

{
  ungetmouse();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void abort(void)

{
                    // WARNING: Subroutine does not return
  abort();
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int * __errno_location(void)

{
  int *piVar1;
  
  piVar1 = __errno_location();
  return piVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int sigemptyset(sigset_t *__set)

{
  int iVar1;
  
  iVar1 = sigemptyset(__set);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int sprintf(char *__s,char *__format,...)

{
  int iVar1;
  
  iVar1 = sprintf(__s,__format);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

FILE * popen(char *__command,char *__modes)

{
  FILE *pFVar1;
  
  pFVar1 = popen(__command,__modes);
  return pFVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int connect(int __fd,sockaddr *__addr,socklen_t __len)

{
  int iVar1;
  
  iVar1 = connect(__fd,__addr,__len);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

__pid_t getpid(void)

{
  __pid_t _Var1;
  
  _Var1 = getpid();
  return _Var1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int mkdir(char *__path,__mode_t __mode)

{
  int iVar1;
  
  iVar1 = mkdir(__path,__mode);
  return iVar1;
}



void inflateReset(void)

{
  inflateReset();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strerror(int __errnum)

{
  char *pcVar1;
  
  pcVar1 = strerror(__errnum);
  return pcVar1;
}



void mouseinterval(void)

{
  mouseinterval();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int getsockname(int __fd,sockaddr *__addr,socklen_t *__len)

{
  int iVar1;
  
  iVar1 = getsockname(__fd,__addr,__len);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int memcmp(void *__s1,void *__s2,size_t __n)

{
  int iVar1;
  
  iVar1 = memcmp(__s1,__s2,__n);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void qsort(void *__base,size_t __nmemb,size_t __size,__compar_fn_t __compar)

{
  qsort(__base,__nmemb,__size,__compar);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void freeaddrinfo(addrinfo *__ai)

{
  freeaddrinfo(__ai);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void syslog(int __pri,char *__fmt,...)

{
  syslog(__pri,__fmt);
  return;
}



void newwin(void)

{
  newwin();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * bsearch(void *__key,void *__base,size_t __nmemb,size_t __size,__compar_fn_t __compar)

{
  void *pvVar1;
  
  pvVar1 = bsearch(__key,__base,__nmemb,__size,__compar);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

long random(void)

{
  long lVar1;
  
  lVar1 = random();
  return lVar1;
}



void inflateEnd(void)

{
  inflateEnd();
  return;
}



void waddch(void)

{
  waddch();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int open64(char *__file,int __oflag,...)

{
  int iVar1;
  
  iVar1 = open64(__file,__oflag);
  return iVar1;
}



void wmove(void)

{
  wmove();
  return;
}



void gzopen64(void)

{
  gzopen64();
  return;
}



void keypad(void)

{
  keypad();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

__sighandler_t signal(int __sig,__sighandler_t __handler)

{
  __sighandler_t p_Var1;
  
  p_Var1 = signal(__sig,__handler);
  return p_Var1;
}



void __gmon_start__(void)

{
  __gmon_start__();
  return;
}



void echo(void)

{
  echo();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * realloc(void *__ptr,size_t __size)

{
  void *pvVar1;
  
  pvVar1 = realloc(__ptr,__size);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

iconv_t iconv_open(char *__tocode,char *__fromcode)

{
  iconv_t pvVar1;
  
  pvVar1 = iconv_open(__tocode,__fromcode);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int unsetenv(char *__name)

{
  int iVar1;
  
  iVar1 = unsetenv(__name);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int __xstat64(int __ver,char *__filename,stat64 *__stat_buf)

{
  int iVar1;
  
  iVar1 = __xstat64(__ver,__filename,__stat_buf);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

tm * localtime(time_t *__timer)

{
  tm *ptVar1;
  
  ptVar1 = localtime(__timer);
  return ptVar1;
}



void endwin(void)

{
  endwin();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

group * getgrnam(char *__name)

{
  group *pgVar1;
  
  pgVar1 = getgrnam(__name);
  return pgVar1;
}



void gzclose(void)

{
  gzclose();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

double strtod(char *__nptr,char **__endptr)

{
  longdouble extraout_ST0;
  
  strtod(__nptr,__endptr);
  return (double)extraout_ST0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strchr(char *__s,int __c)

{
  char *pcVar1;
  
  pcVar1 = strchr(__s,__c);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * getenv(char *__name)

{
  char *pcVar1;
  
  pcVar1 = getenv(__name);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * calloc(size_t __nmemb,size_t __size)

{
  void *pvVar1;
  
  pvVar1 = calloc(__nmemb,__size);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int system(char *__command)

{
  int iVar1;
  
  iVar1 = system(__command);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strncpy(char *__dest,char *__src,size_t __n)

{
  char *pcVar1;
  
  pcVar1 = strncpy(__dest,__src,__n);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int putchar(int __c)

{
  int iVar1;
  
  iVar1 = putchar(__c);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * ttyname(int __fd)

{
  char *pcVar1;
  
  pcVar1 = ttyname(__fd);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

ssize_t write(int __fd,void *__buf,size_t __n)

{
  ssize_t sVar1;
  
  sVar1 = write(__fd,__buf,__n);
  return sVar1;
}



void doupdate(void)

{
  doupdate();
  return;
}



void resizeterm(void)

{
  resizeterm();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int listen(int __fd,int __n)

{
  int iVar1;
  
  iVar1 = listen(__fd,__n);
  return iVar1;
}



void derwin(void)

{
  derwin();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int toupper(int __c)

{
  int iVar1;
  
  iVar1 = toupper(__c);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * fgets(char *__s,int __n,FILE *__stream)

{
  char *pcVar1;
  
  pcVar1 = fgets(__s,__n,__stream);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int rename(char *__old,char *__new)

{
  int iVar1;
  
  iVar1 = rename(__old,__new);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * memset(void *__s,int __c,size_t __n)

{
  void *pvVar1;
  
  pvVar1 = memset(__s,__c,__n);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

FILE * fopen64(char *__filename,char *__modes)

{
  FILE *pFVar1;
  
  pFVar1 = fopen64(__filename,__modes);
  return pFVar1;
}



void __libc_start_main(void)

{
  __libc_start_main();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _IO_getc(_IO_FILE *__fp)

{
  int iVar1;
  
  iVar1 = _IO_getc(__fp);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _exit(int __status)

{
                    // WARNING: Subroutine does not return
  _exit(__status);
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strrchr(char *__s,int __c)

{
  char *pcVar1;
  
  pcVar1 = strrchr(__s,__c);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * ctermid(char *__s)

{
  char *pcVar1;
  
  pcVar1 = ctermid(__s);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int chmod(char *__file,__mode_t __mode)

{
  int iVar1;
  
  iVar1 = chmod(__file,__mode);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void __assert_fail(char *__assertion,char *__file,uint __line,char *__function)

{
                    // WARNING: Subroutine does not return
  __assert_fail(__assertion,__file,__line,__function);
}



void delwin(void)

{
  delwin();
  return;
}



void werase(void)

{
  werase();
  return;
}



void bindtextdomain(void)

{
  bindtextdomain();
  return;
}



void initscr(void)

{
  initscr();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

ssize_t read(int __fd,void *__buf,size_t __nbytes)

{
  ssize_t sVar1;
  
  sVar1 = read(__fd,__buf,__nbytes);
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void perror(char *__s)

{
  perror(__s);
  return;
}



void gettext(void)

{
  gettext();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int ungetc(int __c,FILE *__stream)

{
  int iVar1;
  
  iVar1 = ungetc(__c,__stream);
  return iVar1;
}



void pnoutrefresh(void)

{
  pnoutrefresh();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int gettimeofday(timeval *__tv,__timezone_ptr_t __tz)

{
  int iVar1;
  
  iVar1 = gettimeofday(__tv,__tz);
  return iVar1;
}



void wclrtoeol(void)

{
  wclrtoeol();
  return;
}



void inflate(void)

{
  inflate();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

long strtol(char *__nptr,char **__endptr,int __base)

{
  long lVar1;
  
  lVar1 = strtol(__nptr,__endptr,__base);
  return lVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

FILE * fdopen(int __fd,char *__modes)

{
  FILE *pFVar1;
  
  pFVar1 = fdopen(__fd,__modes);
  return pFVar1;
}



void clearok(void)

{
  clearok();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void free(void *__ptr)

{
  free(__ptr);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int __lxstat64(int __ver,char *__filename,stat64 *__stat_buf)

{
  int iVar1;
  
  iVar1 = __lxstat64(__ver,__filename,__stat_buf);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void openlog(char *__ident,int __option,int __facility)

{
  openlog(__ident,__option,__facility);
  return;
}



void pair_content(void)

{
  pair_content();
  return;
}



void getmouse(void)

{
  getmouse();
  return;
}



void mousemask(void)

{
  mousemask();
  return;
}



void curses_version(void)

{
  curses_version();
  return;
}



void nonl(void)

{
  nonl();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int truncate64(char *__file,__off64_t __length)

{
  int iVar1;
  
  iVar1 = truncate64(__file,__length);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int sigaction(int __sig,sigaction *__act,sigaction *__oact)

{
  int iVar1;
  
  iVar1 = sigaction(__sig,__act,__oact);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int fflush(FILE *__stream)

{
  int iVar1;
  
  iVar1 = fflush(__stream);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

DIR * opendir(char *__name)

{
  DIR *pDVar1;
  
  pDVar1 = opendir(__name);
  return pDVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int accept(int __fd,sockaddr *__addr,socklen_t *__addr_len)

{
  int iVar1;
  
  iVar1 = accept(__fd,__addr,__addr_len);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int ioctl(int __fd,ulong __request,...)

{
  int iVar1;
  
  iVar1 = ioctl(__fd,__request);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int socket(int __domain,int __type,int __protocol)

{
  int iVar1;
  
  iVar1 = socket(__domain,__type,__protocol);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int dup2(int __fd,int __fd2)

{
  int iVar1;
  
  iVar1 = dup2(__fd,__fd2);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

ushort ** __ctype_b_loc(void)

{
  ushort **ppuVar1;
  
  ppuVar1 = __ctype_b_loc();
  return ppuVar1;
}



void wtouchln(void)

{
  wtouchln();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int isatty(int __fd)

{
  int iVar1;
  
  iVar1 = isatty(__fd);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int getaddrinfo(char *__name,char *__service,addrinfo *__req,addrinfo **__pai)

{
  int iVar1;
  
  iVar1 = getaddrinfo(__name,__service,__req,__pai);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

__mode_t umask(__mode_t __mask)

{
  __mode_t _Var1;
  
  _Var1 = umask(__mask);
  return _Var1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int fclose(FILE *__stream)

{
  int iVar1;
  
  iVar1 = fclose(__stream);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

time_t mktime(tm *__tp)

{
  time_t tVar1;
  
  tVar1 = mktime(__tp);
  return tVar1;
}



void wrefresh(void)

{
  wrefresh();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

uint16_t ntohs(uint16_t __netshort)

{
  uint16_t uVar1;
  
  uVar1 = ntohs(__netshort);
  return uVar1;
}



void init_pair(void)

{
  init_pair();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

dirent64 * readdir64(DIR *__dirp)

{
  dirent64 *pdVar1;
  
  pdVar1 = readdir64(__dirp);
  return pdVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * memcpy(void *__dest,void *__src,size_t __n)

{
  void *pvVar1;
  
  pvVar1 = memcpy(__dest,__src,__n);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int execv(char *__path,char **__argv)

{
  int iVar1;
  
  iVar1 = execv(__path,__argv);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t strlen(char *__s)

{
  size_t sVar1;
  
  sVar1 = strlen(__s);
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * mkdtemp(char *__template)

{
  char *pcVar1;
  
  pcVar1 = mkdtemp(__template);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int unlink(char *__name)

{
  int iVar1;
  
  iVar1 = unlink(__name);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t iconv(iconv_t __cd,char **__inbuf,size_t *__inbytesleft,char **__outbuf,
            size_t *__outbytesleft)

{
  size_t sVar1;
  
  sVar1 = iconv(__cd,__inbuf,__inbytesleft,__outbuf,__outbytesleft);
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

passwd * getpwuid(__uid_t __uid)

{
  passwd *ppVar1;
  
  ppVar1 = getpwuid(__uid);
  return ppVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * gai_strerror(int __ecode)

{
  char *pcVar1;
  
  pcVar1 = gai_strerror(__ecode);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * setlocale(int __category,char *__locale)

{
  char *pcVar1;
  
  pcVar1 = setlocale(__category,__locale);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

__pid_t waitpid(__pid_t __pid,int *__stat_loc,int __options)

{
  __pid_t _Var1;
  
  _Var1 = waitpid(__pid,__stat_loc,__options);
  return _Var1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void clearerr(FILE *__stream)

{
  clearerr(__stream);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int fgetc(FILE *__stream)

{
  int iVar1;
  
  iVar1 = fgetc(__stream);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int feof(FILE *__stream)

{
  int iVar1;
  
  iVar1 = feof(__stream);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strcpy(char *__dest,char *__src)

{
  char *pcVar1;
  
  pcVar1 = strcpy(__dest,__src);
  return pcVar1;
}



void cbreak(void)

{
  cbreak();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int printf(char *__format,...)

{
  int iVar1;
  
  iVar1 = printf(__format);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int chdir(char *__path)

{
  int iVar1;
  
  iVar1 = chdir(__path);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * ctime(time_t *__timer)

{
  char *pcVar1;
  
  pcVar1 = ctime(__timer);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int bind(int __fd,sockaddr *__addr,socklen_t __len)

{
  int iVar1;
  
  iVar1 = bind(__fd,__addr,__len);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

__uid_t getuid(void)

{
  __uid_t _Var1;
  
  _Var1 = getuid();
  return _Var1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

long atol(char *__nptr)

{
  long lVar1;
  
  lVar1 = atol(__nptr);
  return lVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int atoi(char *__nptr)

{
  int iVar1;
  
  iVar1 = atoi(__nptr);
  return iVar1;
}



void start_color(void)

{
  start_color();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int putenv(char *__string)

{
  int iVar1;
  
  iVar1 = putenv(__string);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

double atof(char *__nptr)

{
  longdouble extraout_ST0;
  
  atof(__nptr);
  return (double)extraout_ST0;
}



void wresize(void)

{
  wresize();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int select(int __nfds,fd_set *__readfds,fd_set *__writefds,fd_set *__exceptfds,timeval *__timeout)

{
  int iVar1;
  
  iVar1 = select(__nfds,__readfds,__writefds,__exceptfds,__timeout);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void srandom(uint __seed)

{
  srandom(__seed);
  return;
}



void gzerror(void)

{
  gzerror();
  return;
}



void wgetch(void)

{
  wgetch();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int closedir(DIR *__dirp)

{
  int iVar1;
  
  iVar1 = closedir(__dirp);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int close(int __fd)

{
  int iVar1;
  
  iVar1 = close(__fd);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t fwrite(void *__ptr,size_t __size,size_t __n,FILE *__s)

{
  size_t sVar1;
  
  sVar1 = fwrite(__ptr,__size,__n,__s);
  return sVar1;
}



void wbkgd(void)

{
  wbkgd();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int fprintf(FILE *__stream,char *__format,...)

{
  int iVar1;
  
  iVar1 = fprintf(__stream,__format);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strstr(char *__haystack,char *__needle)

{
  char *pcVar1;
  
  pcVar1 = strstr(__haystack,__needle);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

time_t time(time_t *__timer)

{
  time_t tVar1;
  
  tVar1 = time(__timer);
  return tVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strncat(char *__dest,char *__src,size_t __n)

{
  char *pcVar1;
  
  pcVar1 = strncat(__dest,__src,__n);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int remove(char *__filename)

{
  int iVar1;
  
  iVar1 = remove(__filename);
  return iVar1;
}



void newpad(void)

{
  newpad();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int execve(char *__path,char **__argv,char **__envp)

{
  int iVar1;
  
  iVar1 = execve(__path,__argv,__envp);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * nl_langinfo(nl_item __item)

{
  char *pcVar1;
  
  pcVar1 = nl_langinfo(__item);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * malloc(size_t __size)

{
  void *pvVar1;
  
  pvVar1 = malloc(__size);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int sigprocmask(int __how,sigset_t *__set,sigset_t *__oset)

{
  int iVar1;
  
  iVar1 = sigprocmask(__how,__set,__oset);
  return iVar1;
}



void has_colors(void)

{
  has_colors();
  return;
}



void __stack_chk_fail(void)

{
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int iconv_close(iconv_t __cd)

{
  int iVar1;
  
  iVar1 = iconv_close(__cd);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int gethostname(char *__name,size_t __len)

{
  int iVar1;
  
  iVar1 = gethostname(__name,__len);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int fputc(int __c,FILE *__stream)

{
  int iVar1;
  
  iVar1 = fputc(__c,__stream);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int rmdir(char *__path)

{
  int iVar1;
  
  iVar1 = rmdir(__path);
  return iVar1;
}



void waddnstr(void)

{
  waddnstr();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strtok(char *__s,char *__delim)

{
  char *pcVar1;
  
  pcVar1 = strtok(__s,__delim);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

group * getgrgid(__gid_t __gid)

{
  group *pgVar1;
  
  pgVar1 = getgrgid(__gid);
  return pgVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

uint sleep(uint __seconds)

{
  uint uVar1;
  
  uVar1 = sleep(__seconds);
  return uVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int sigaddset(sigset_t *__set,int __signo)

{
  int iVar1;
  
  iVar1 = sigaddset(__set,__signo);
  return iVar1;
}



void wborder(void)

{
  wborder();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

ssize_t readlink(char *__path,char *__buf,size_t __len)

{
  ssize_t sVar1;
  
  sVar1 = readlink(__path,__buf,__len);
  return sVar1;
}



void inflateInit_(void)

{
  inflateInit_();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int getnameinfo(sockaddr *__sa,socklen_t __salen,char *__host,socklen_t __hostlen,char *__serv,
               socklen_t __servlen,uint __flags)

{
  int iVar1;
  
  iVar1 = getnameinfo(__sa,__salen,__host,__hostlen,__serv,__servlen,__flags);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strcat(char *__dest,char *__src)

{
  char *pcVar1;
  
  pcVar1 = strcat(__dest,__src);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * getcwd(char *__buf,size_t __size)

{
  char *pcVar1;
  
  pcVar1 = getcwd(__buf,__size);
  return pcVar1;
}



void define_key(void)

{
  define_key();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int vasprintf(char **__ptr,char *__f,__gnuc_va_list __arg)

{
  int iVar1;
  
  iVar1 = vasprintf(__ptr,__f,__arg);
  return iVar1;
}



void assume_default_colors(void)

{
  assume_default_colors();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int puts(char *__s)

{
  int iVar1;
  
  iVar1 = puts(__s);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

__pid_t fork(void)

{
  __pid_t _Var1;
  
  _Var1 = fork();
  return _Var1;
}



void textdomain(void)

{
  textdomain();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int tcsetattr(int __fd,int __optional_actions,termios *__termios_p)

{
  int iVar1;
  
  iVar1 = tcsetattr(__fd,__optional_actions,__termios_p);
  return iVar1;
}



void wattr_off(void)

{
  wattr_off();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int sscanf(char *__s,char *__format,...)

{
  int iVar1;
  
  iVar1 = sscanf(__s,__format);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int getgroups(int __size,__gid_t *__list)

{
  int iVar1;
  
  iVar1 = getgroups(__size,__list);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int strncmp(char *__s1,char *__s2,size_t __n)

{
  int iVar1;
  
  iVar1 = strncmp(__s1,__s2,__n);
  return iVar1;
}



void wnoutrefresh(void)

{
  wnoutrefresh();
  return;
}



void gzread(void)

{
  gzread();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _IO_putc(int __c,_IO_FILE *__fp)

{
  int iVar1;
  
  iVar1 = _IO_putc(__c,__fp);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strpbrk(char *__s,char *__accept)

{
  char *pcVar1;
  
  pcVar1 = strpbrk(__s,__accept);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int pipe(int *__pipedes)

{
  int iVar1;
  
  iVar1 = pipe(__pipedes);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t fread(void *__ptr,size_t __size,size_t __n,FILE *__stream)

{
  size_t sVar1;
  
  sVar1 = fread(__ptr,__size,__n,__stream);
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void closelog(void)

{
  closelog();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int kill(__pid_t __pid,int __sig)

{
  int iVar1;
  
  iVar1 = kill(__pid,__sig);
  return iVar1;
}



void wclear(void)

{
  wclear();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int getpeername(int __fd,sockaddr *__addr,socklen_t *__len)

{
  int iVar1;
  
  iVar1 = getpeername(__fd,__addr,__len);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

hostent * gethostbyname(char *__name)

{
  hostent *phVar1;
  
  phVar1 = gethostbyname(__name);
  return phVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int ferror(FILE *__stream)

{
  int iVar1;
  
  iVar1 = ferror(__stream);
  return iVar1;
}



void nl(void)

{
  nl();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

passwd * getpwnam(char *__name)

{
  passwd *ppVar1;
  
  ppVar1 = getpwnam(__name);
  return ppVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int tolower(int __c)

{
  int iVar1;
  
  iVar1 = tolower(__c);
  return iVar1;
}



void noecho(void)

{
  noecho();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int strcmp(char *__s1,char *__s2)

{
  int iVar1;
  
  iVar1 = strcmp(__s1,__s2);
  return iVar1;
}



void wbkgdset(void)

{
  wbkgdset();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void exit(int __status)

{
                    // WARNING: Subroutine does not return
  exit(__status);
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int pclose(FILE *__stream)

{
  int iVar1;
  
  iVar1 = pclose(__stream);
  return iVar1;
}



void napms(void)

{
  napms();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

FILE * freopen64(char *__filename,char *__modes,FILE *__stream)

{
  FILE *pFVar1;
  
  pFVar1 = freopen64(__filename,__modes,__stream);
  return pFVar1;
}



void wattr_on(void)

{
  wattr_on();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

__uid_t geteuid(void)

{
  __uid_t _Var1;
  
  _Var1 = geteuid();
  return _Var1;
}



void processEntry _start(undefined4 param_1,undefined4 param_2)

{
  undefined auStack_4 [4];
  
  __libc_start_main(main,param_2,&stack0x00000004,__libc_csu_init,__libc_csu_fini,param_1,auStack_4)
  ;
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



// WARNING: Removing unreachable block (ram,0x0804b48a)
// WARNING: Removing unreachable block (ram,0x0804b490)

void __do_global_dtors_aux(void)

{
  if (completed_6635 == '\0') {
    completed_6635 = '\x01';
  }
  return;
}



// WARNING: Removing unreachable block (ram,0x0804b4cf)
// WARNING: Removing unreachable block (ram,0x0804b4d8)

void frame_dummy(void)

{
  return;
}



// WARNING: Unknown calling convention

void cleanup_sig(int sig)

{
  undefined4 uVar1;
  EVP_PKEY_CTX *ctx;
  
  signal(1,(__sighandler_t)0x1);
  signal(2,(__sighandler_t)0x1);
  ctx = (EVP_PKEY_CTX *)0xf;
  signal(0xf,(__sighandler_t)0x1);
  if (traversal != '\0') {
    dump_traversal_history();
  }
  if (sig == 1) {
    cleanup_files();
  }
  else {
    if (dump_output_immediately == '\0') {
      cleanup(ctx);
    }
    if (sig != 0) {
      uVar1 = gettext("Exiting via interrupt:");
      printf("\n\n%s %d\n\n",uVar1,sig);
      fflush(stdout);
    }
  }
  if (sig == 0) {
    reset_signals();
  }
  else {
    exit_immediately(0);
  }
  return;
}



// WARNING: Unknown calling convention

void cleanup_files(void)

{
  LYCleanupTemp();
  if (lynx_temp_space != (char *)0x0) {
    free(lynx_temp_space);
    lynx_temp_space = (char *)0x0;
  }
  return;
}



void cleanup(EVP_PKEY_CTX *ctx)

{
  signal(1,(__sighandler_t)0x1);
  signal(0xf,(__sighandler_t)0x1);
  signal(2,(__sighandler_t)0x1);
  if (LYCursesON != '\0') {
    LYmove(LYlines + L'\xffffffff',L'\0');
    LYclrtoeol();
    lynx_stop_all_colors();
    LYrefresh();
    stop_curses();
  }
  if (persistent_cookies != '\0') {
    LYStoreCookies(LYCookieSaveFile);
  }
  cleanup_files();
  LYCloseTracelog();
  return;
}



// WARNING: Unknown calling convention

BOOLEAN LYVersionIsRelease(void)

{
  return '\0';
}



// WARNING: Unknown calling convention

char * LYVersionStatus(void)

{
  BOOLEAN BVar1;
  char *local_8;
  
  BVar1 = LYVersionIsRelease();
  if (BVar1 == '\0') {
    local_8 = (char *)gettext("development version");
  }
  else {
    local_8 = (char *)gettext("latest release");
  }
  return local_8;
}



// WARNING: Unknown calling convention

char * LYVersionDate(void)

{
  LYstrncpy(LYVersionDate::temp,"14 Dec 2008 16:24:56 -0800",L'\v');
  return LYVersionDate::temp;
}



// WARNING: Unknown calling convention

void dt_String(FILE *fp,char *label,char *value)

{
  bool bVar1;
  char *the_value;
  char *the_label;
  int need;
  int have;
  
  the_label = (char *)0x0;
  the_value = (char *)0x0;
  HTSACopy(&the_label,label);
  HTSACopy(&the_value,value);
  have = strlen(the_label);
  need = LYstrExtent(the_label,have,label_columns);
  LYEntify(&the_label,'\x01');
  LYEntify(&the_value,'\x01');
  fwrite(&DAT_081498b0,1,4,(FILE *)fp);
  while (bVar1 = need < label_columns, need = need + 1, bVar1) {
    fwrite("&nbsp;",1,6,(FILE *)fp);
  }
  fprintf((FILE *)fp,"<em>%s</em> %s\n",the_label,the_value);
  if (the_label != (char *)0x0) {
    free(the_label);
    the_label = (char *)0x0;
  }
  if (the_value != (char *)0x0) {
    free(the_value);
  }
  return;
}



// WARNING: Unknown calling convention

void dt_Number(FILE *fp0,char *label,long number,char *units)

{
  char *value;
  
  value = (char *)0x0;
  HTSprintf(&value,"%ld %s",number,units);
  dt_String(fp0,label,value);
  if (value != (char *)0x0) {
    free(value);
  }
  return;
}



int LYShowInfo(DocInfo *doc,DocInfo *newdoc,char *owner_address)

{
  long number;
  BOOLEAN BVar1;
  char *pcVar2;
  size_t sVar3;
  char *pcVar4;
  undefined4 uVar5;
  int iVar6;
  int *piVar7;
  FILE *pFVar8;
  ssize_t sVar9;
  wchar_t wVar10;
  int in_GS_OFFSET;
  size_t sVar11;
  int local_53c;
  char *local_534;
  char *local_530;
  char *local_52c;
  wchar_t local_528;
  char *local_524;
  char *local_520;
  char *local_51c;
  char *local_518;
  char *local_514;
  char *local_510;
  char *local_50c;
  char *owner_address_local;
  DocInfo *newdoc_local;
  DocInfo *doc_local;
  stat dir_info;
  char *enctype;
  int method;
  LYUCcharset *p_in;
  int buf_size;
  int next_to_last;
  char *last_slash;
  char *name;
  char *temp;
  char *cp;
  char *Title;
  FILE *fp0;
  int url_type;
  BOOLEAN LYInfoAdvanced;
  char buf [1024];
  char modes [80];
  int local_10;
  
  local_10 = *(int *)(in_GS_OFFSET + 0x14);
  Title = (char *)0x0;
  temp = (char *)0x0;
  LYInfoAdvanced = user_mode == 2;
  if (LYReuseTempfiles == '\0') {
    LYRemoveTemp(LYShowInfo::tempfile);
    fp0 = LYOpenTemp(LYShowInfo::tempfile,".html","w");
  }
  else {
    fp0 = LYOpenTempRewrite(LYShowInfo::tempfile,".html","w");
  }
  if (fp0 == (FILE *)0x0) {
    pcVar2 = (char *)gettext("Can\'t open temporary file!");
    HTAlert(pcVar2);
    local_53c = -1;
  }
  else {
    LYLocalFileToURL(&newdoc->address,LYShowInfo::tempfile);
    if ((((0 < nlinks) && (links[doc->link].lname != (char *)0x0)) &&
        (url_type = is_url(links[doc->link].lname), url_type != NOT_A_URL_TYPE)) &&
       ((url_type == LYNXEXEC_URL_TYPE || (url_type == LYNXPROG_URL_TYPE)))) {
      pcVar2 = strrchr(links[doc->link].lname,0x2f);
      sVar3 = strlen(links[doc->link].lname);
      if ((int)pcVar2 - (int)links[doc->link].lname == sVar3 - 1) {
        links[doc->link].lname[sVar3 - 1] = '\0';
      }
    }
    label_columns = 9;
    pcVar2 = (char *)gettext("Information about the current document");
    WriteInternalTitle(fp0,pcVar2);
    pcVar2 = LYVersionStatus();
    BVar1 = LYVersionIsRelease();
    if (BVar1 == '\0') {
      local_534 = "http://lynx.isc.org/current/";
    }
    else {
      local_534 = "http://lynx.isc.org/";
    }
    pcVar4 = LYVersionDate();
    fprintf((FILE *)fp0,"<h1>%s %s (%s) (<a href=\"%s\">%s</a>)",&DAT_0814995d,"2.8.7dev.11",pcVar4,
            local_534,pcVar2);
    pFVar8 = fp0;
    fwrite("</h1>\n",1,6,(FILE *)fp0);
    if ((lynx_edit_mode == '\0') || (nlinks < 1)) {
      uVar5 = gettext("File that you are currently viewing");
      fprintf((FILE *)fp0,"<h2>%s</h2>\n<dl compact>",uVar5,pFVar8,pcVar4,local_534,pcVar2);
      LYformTitle(&Title,doc->title);
      if ((doc->isHEAD == '\0') ||
         ((pcVar2 = strstr(Title," (HEAD)"), pcVar2 != (char *)0x0 ||
          (pcVar2 = strstr(Title," - HEAD"), pcVar2 != (char *)0x0)))) {
        local_530 = "";
      }
      else {
        local_530 = " (HEAD)";
      }
      HTSprintf(&temp,"%s%s",Title,local_530);
      pcVar2 = temp;
      pcVar4 = (char *)gettext("Linkname:");
      dt_String(fp0,pcVar4,pcVar2);
      if (temp != (char *)0x0) {
        free(temp);
        temp = (char *)0x0;
      }
      dt_String(fp0,"URL:",doc->address);
      pcVar2 = HTLoadedDocumentCharset();
      if (pcVar2 == (char *)0x0) {
        p_in = HTAnchor_getUCInfoStage(HTMainAnchor,1);
        if ((((p_in == (LYUCcharset *)0x0) || (p_in->MIMEname == (char *)0x0)) ||
            (*p_in->MIMEname == '\0')) || (iVar6 = HTAnchor_getUCLYhndl(HTMainAnchor,1), iVar6 < 0))
        {
          p_in = HTAnchor_getUCInfoStage(HTMainAnchor,0);
        }
        if (((p_in != (LYUCcharset *)0x0) && (p_in->MIMEname != (char *)0x0)) &&
           ((*p_in->MIMEname != '\0' && (iVar6 = HTAnchor_getUCLYhndl(HTMainAnchor,0), -1 < iVar6)))
           ) {
          uVar5 = gettext("(assumed)");
          HTSprintf(&temp,"%s %s",p_in->MIMEname,uVar5);
          pcVar2 = p_in->MIMEname;
          pcVar4 = (char *)gettext("Charset:");
          dt_String(fp0,pcVar4,pcVar2);
          if (temp != (char *)0x0) {
            free(temp);
            temp = (char *)0x0;
          }
        }
      }
      else {
        pcVar2 = HTLoadedDocumentCharset();
        pcVar4 = (char *)gettext("Charset:");
        dt_String(fp0,pcVar4,pcVar2);
      }
      cp = HText_getServer();
      if ((cp != (char *)0x0) && (*cp != '\0')) {
        pcVar2 = (char *)gettext("Server:");
        dt_String(fp0,pcVar2,cp);
      }
      cp = HText_getDate();
      if ((cp != (char *)0x0) && (*cp != '\0')) {
        pcVar2 = (char *)gettext("Date:");
        dt_String(fp0,pcVar2,cp);
      }
      cp = HText_getLastModified();
      if ((cp != (char *)0x0) && (*cp != '\0')) {
        pcVar2 = (char *)gettext("Last Mod:");
        dt_String(fp0,pcVar2,cp);
      }
      if (LYInfoAdvanced != '\0') {
        if ((HTMainAnchor != (HTParentAnchor *)0x0) && (HTMainAnchor->expires != (char *)0x0)) {
          pcVar2 = HTMainAnchor->expires;
          pcVar4 = (char *)gettext("Expires:");
          dt_String(fp0,pcVar4,pcVar2);
        }
        if ((HTMainAnchor != (HTParentAnchor *)0x0) && (HTMainAnchor->cache_control != (char *)0x0))
        {
          pcVar2 = HTMainAnchor->cache_control;
          pcVar4 = (char *)gettext("Cache-Control:");
          dt_String(fp0,pcVar4,pcVar2);
        }
        if ((HTMainAnchor == (HTParentAnchor *)0x0) || (HTMainAnchor->content_length < 1)) {
          pcVar2 = (char *)gettext("bytes");
          wVar10 = HText_getNumOfBytes();
          pcVar4 = (char *)gettext("Length:");
          dt_Number(fp0,pcVar4,wVar10,pcVar2);
        }
        else {
          pcVar2 = (char *)gettext("bytes");
          number = HTMainAnchor->content_length;
          pcVar4 = (char *)gettext("Content-Length:");
          dt_Number(fp0,pcVar4,number,pcVar2);
        }
        if ((HTMainAnchor != (HTParentAnchor *)0x0) &&
           (HTMainAnchor->content_language != (char *)0x0)) {
          pcVar2 = HTMainAnchor->content_language;
          pcVar4 = (char *)gettext("Language:");
          dt_String(fp0,pcVar4,pcVar2);
        }
      }
      if (doc->post_data != (bstring_conflict *)0x0) {
        if (doc->post_data == (bstring_conflict *)0x0) {
          local_52c = (char *)0x0;
        }
        else {
          local_52c = doc->post_data->str;
        }
        if (doc->post_data == (bstring_conflict *)0x0) {
          local_528 = L'\0';
        }
        else {
          local_528 = doc->post_data->len;
        }
        uVar5 = gettext("Post Data:");
        fprintf((FILE *)fp0,"<dt><em>%s</em> <xmp>%.*s</xmp>\n",uVar5,local_528,local_52c);
        pcVar2 = doc->post_content_type;
        pcVar4 = (char *)gettext("Post Content Type:");
        dt_String(fp0,pcVar4,pcVar2);
      }
      if (owner_address == (char *)0x0) {
        local_524 = (char *)gettext(&DAT_08149cc4);
      }
      else {
        local_524 = owner_address;
      }
      pcVar2 = (char *)gettext("Owner(s):");
      dt_String(fp0,pcVar2,local_524);
      pcVar2 = (char *)gettext("lines");
      wVar10 = HText_getNumOfLines();
      pcVar4 = (char *)gettext("size:");
      dt_Number(fp0,pcVar4,wVar10,pcVar2);
      if (lynx_mode == '\x02') {
        local_520 = (char *)gettext("forms mode");
      }
      else {
        wVar10 = HTisDocumentSource();
        if (wVar10 == L'\0') {
          local_51c = (char *)gettext("normal");
        }
        else {
          local_51c = (char *)gettext("source");
        }
        local_520 = local_51c;
      }
      HTSACopy(&temp,local_520);
      if (doc->safe != '\0') {
        pcVar2 = (char *)gettext(", safe");
        HTSACat(&temp,pcVar2);
      }
      if (doc->internal_link != '\0') {
        pcVar2 = (char *)gettext(", via internal link");
        HTSACat(&temp,pcVar2);
      }
      if (LYInfoAdvanced != '\0') {
        BVar1 = HText_hasNoCacheSet(HTMainText);
        if (BVar1 != '\0') {
          pcVar2 = (char *)gettext(", no-cache");
          HTSACat(&temp,pcVar2);
        }
        BVar1 = HTAnchor_isISMAPScript((HTAnchor *)HTMainAnchor);
        if (BVar1 != '\0') {
          pcVar2 = (char *)gettext(", ISMAP script");
          HTSACat(&temp,pcVar2);
        }
        if (doc->bookmark != (char *)0x0) {
          pcVar2 = (char *)gettext(", bookmark file");
          HTSACat(&temp,pcVar2);
        }
      }
      pcVar2 = temp;
      pcVar4 = (char *)gettext("mode:");
      dt_String(fp0,pcVar4,pcVar2);
      if (temp != (char *)0x0) {
        free(temp);
        temp = (char *)0x0;
      }
      fwrite("\n</dl>\n",1,7,(FILE *)fp0);
      if (nlinks < 1) {
        uVar5 = gettext("No Links on the current page");
        fprintf((FILE *)fp0,"<h2>%s</h2>",uVar5);
      }
      else {
        uVar5 = gettext("Link that you currently have selected");
        fprintf((FILE *)fp0,"<h2>%s</h2>\n<dl compact>",uVar5);
        pcVar2 = LYGetHiliteStr(doc->link,L'\0');
        pcVar4 = (char *)gettext("Linkname:");
        dt_String(fp0,pcVar4,pcVar2);
        if ((lynx_mode == '\x02') && (links[doc->link].type == 1)) {
          if ((links[doc->link].l_form)->submit_method != 0) {
            iVar6 = (links[doc->link].l_form)->submit_method;
            local_510 = (links[doc->link].l_form)->submit_enctype;
            if (iVar6 == 2) {
              local_518 = "POST";
            }
            else {
              if (iVar6 == 3) {
                local_514 = "(email)";
              }
              else {
                local_514 = "GET";
              }
              local_518 = local_514;
            }
            pcVar2 = (char *)gettext("Method:");
            dt_String(fp0,pcVar2,local_518);
            if ((local_510 == (char *)0x0) || (*local_510 == '\0')) {
              local_510 = "application/x-www-form-urlencoded";
            }
            pcVar2 = (char *)gettext("Enctype:");
            dt_String(fp0,pcVar2,local_510);
          }
          if ((links[doc->link].l_form)->submit_action != (char *)0x0) {
            pcVar2 = (links[doc->link].l_form)->submit_action;
            pcVar4 = (char *)gettext("Action:");
            dt_String(fp0,pcVar4,pcVar2);
          }
          if (((links[doc->link].l_form)->submit_method == 0) ||
             ((links[doc->link].l_form)->submit_action == (char *)0x0)) {
            uVar5 = gettext("(Form field)");
            fprintf((FILE *)fp0,"<dt>&nbsp;%s\n",uVar5);
          }
        }
        else {
          if (links[doc->link].lname == (char *)0x0) {
            local_50c = "";
          }
          else {
            local_50c = links[doc->link].lname;
          }
          dt_String(fp0,"URL:",local_50c);
        }
        fwrite("\n</dl>\n",1,7,(FILE *)fp0);
      }
    }
    else {
      uVar5 = gettext("Directory that you are currently viewing");
      fprintf((FILE *)fp0,"<h2>%s</h2>\n<dl compact>",uVar5,pFVar8,pcVar4,local_534,pcVar2);
      pcVar2 = HTnameOfFile_WWW(doc->address,'\0','\x01');
      temp = pcVar2;
      pcVar4 = (char *)gettext("Name:");
      dt_String(fp0,pcVar4,pcVar2);
      if (temp != (char *)0x0) {
        free(temp);
        temp = (char *)0x0;
      }
      pcVar2 = doc->address;
      pcVar4 = (char *)gettext(&DAT_081499d8);
      dt_String(fp0,pcVar4,pcVar2);
      fwrite("\n</dl>\n",1,7,(FILE *)fp0);
      temp = HTnameOfFile_WWW(links[doc->link].lname,'\0','\x01');
      iVar6 = lstat64(temp,(stat64 *)&dir_info);
      if (iVar6 == -1) {
        if (WWW_TraceFlag != '\0') {
          piVar7 = __errno_location();
          pcVar2 = temp;
          iVar6 = *piVar7;
          pFVar8 = TraceFP();
          fprintf((FILE *)pFVar8,"lstat(%s) failed, errno=%d\n",pcVar2,iVar6);
        }
        pcVar2 = (char *)gettext("Failed to obtain status of current link!");
        HTAlert(pcVar2);
      }
      else {
        label_columns = 0x10;
        if ((dir_info.st_mode & 0xf000) == 0x4000) {
          uVar5 = gettext("Directory that you have currently selected");
          fprintf((FILE *)fp0,"<h2>%s</h2>\n<dl compact>",uVar5);
        }
        else if ((dir_info.st_mode & 0xf000) == 0x8000) {
          uVar5 = gettext("File that you have currently selected");
          fprintf((FILE *)fp0,"<h2>%s</h2>\n<dl compact>",uVar5);
        }
        else if ((dir_info.st_mode & 0xf000) == 0xa000) {
          uVar5 = gettext("Symbolic link that you have currently selected");
          fprintf((FILE *)fp0,"<h2>%s</h2>\n<dl compact>",uVar5);
        }
        else {
          uVar5 = gettext("Item that you have currently selected");
          fprintf((FILE *)fp0,"<h2>%s</h2>\n<dl compact>",uVar5);
        }
        pcVar2 = temp;
        pcVar4 = (char *)gettext("Full name:");
        dt_String(fp0,pcVar4,pcVar2);
        if ((dir_info.st_mode & 0xf000) == 0xa000) {
          sVar9 = readlink(temp,buf,0x3ff);
          if (sVar9 == -1) {
            uVar5 = gettext("Unable to follow link");
            sprintf(buf,"%.*s",0x3ff,uVar5);
          }
          else {
            buf[sVar9] = '\0';
          }
          pcVar2 = (char *)gettext("Points to file:");
          dt_String(fp0,pcVar2,buf);
        }
        pcVar2 = HTAA_UidToName(dir_info.st_uid);
        if (*pcVar2 != '\0') {
          pcVar4 = (char *)gettext("Name of owner:");
          dt_String(fp0,pcVar4,pcVar2);
        }
        pcVar2 = HTAA_GidToName(dir_info.st_gid);
        if (*pcVar2 != '\0') {
          pcVar4 = (char *)gettext("Group name:");
          dt_String(fp0,pcVar4,pcVar2);
        }
        if ((dir_info.st_mode & 0xf000) == 0x8000) {
          pcVar2 = (char *)gettext("(bytes)");
          pcVar4 = (char *)gettext("File size:");
          dt_Number(fp0,pcVar4,(long)dir_info.st_size,pcVar2);
        }
        pcVar2 = ctime(&dir_info.st_ctim.tv_sec);
        pcVar4 = (char *)gettext("Creation date:");
        dt_String(fp0,pcVar4,pcVar2);
        pcVar2 = ctime(&dir_info.st_mtim.tv_sec);
        pcVar4 = (char *)gettext("Last modified:");
        dt_String(fp0,pcVar4,pcVar2);
        pcVar2 = ctime(&dir_info.st_atim.tv_sec);
        pcVar4 = (char *)gettext("Last accessed:");
        dt_String(fp0,pcVar4,pcVar2);
        fwrite("\n</dl>\n",1,7,(FILE *)fp0);
        label_columns = 9;
        uVar5 = gettext("Access Permissions");
        fprintf((FILE *)fp0,"<h2>%s</h2>\n<dl compact>",uVar5);
        modes[0] = '\0';
        modes[1] = '\0';
        modes[2] = '\0';
        if ((dir_info.st_mode & 0x100) != 0) {
          sVar11 = 7;
          pcVar2 = ", read";
          sVar3 = strlen(modes);
          memcpy(modes + sVar3,pcVar2,sVar11);
        }
        if ((dir_info.st_mode & 0x80) != 0) {
          sVar11 = 8;
          pcVar2 = ", write";
          sVar3 = strlen(modes);
          memcpy(modes + sVar3,pcVar2,sVar11);
        }
        if ((dir_info.st_mode & 0x40) != 0) {
          if ((dir_info.st_mode & 0xf000) == 0x4000) {
            sVar11 = 9;
            pcVar2 = ", search";
            sVar3 = strlen(modes);
            memcpy(modes + sVar3,pcVar2,sVar11);
          }
          else {
            sVar11 = 10;
            pcVar2 = ", execute";
            sVar3 = strlen(modes);
            memcpy(modes + sVar3,pcVar2,sVar11);
            if ((dir_info.st_mode & 0x800) != 0) {
              sVar11 = 9;
              pcVar2 = ", setuid";
              sVar3 = strlen(modes);
              memcpy(modes + sVar3,pcVar2,sVar11);
            }
          }
        }
        pcVar2 = (char *)gettext("Owner:");
        dt_String(fp0,pcVar2,modes + 2);
        modes[0] = '\0';
        modes[1] = '\0';
        modes[2] = '\0';
        if ((dir_info.st_mode & 0x20) != 0) {
          sVar11 = 7;
          pcVar2 = ", read";
          sVar3 = strlen(modes);
          memcpy(modes + sVar3,pcVar2,sVar11);
        }
        if ((dir_info.st_mode & 0x10) != 0) {
          sVar11 = 8;
          pcVar2 = ", write";
          sVar3 = strlen(modes);
          memcpy(modes + sVar3,pcVar2,sVar11);
        }
        if ((dir_info.st_mode & 8) != 0) {
          if ((dir_info.st_mode & 0xf000) == 0x4000) {
            sVar11 = 9;
            pcVar2 = ", search";
            sVar3 = strlen(modes);
            memcpy(modes + sVar3,pcVar2,sVar11);
          }
          else {
            sVar11 = 10;
            pcVar2 = ", execute";
            sVar3 = strlen(modes);
            memcpy(modes + sVar3,pcVar2,sVar11);
            if ((dir_info.st_mode & 0x400) != 0) {
              sVar11 = 9;
              pcVar2 = ", setgid";
              sVar3 = strlen(modes);
              memcpy(modes + sVar3,pcVar2,sVar11);
            }
          }
        }
        pcVar2 = (char *)gettext("Group:");
        dt_String(fp0,pcVar2,modes + 2);
        modes[0] = '\0';
        modes[1] = '\0';
        modes[2] = '\0';
        if ((dir_info.st_mode & 4) != 0) {
          sVar11 = 7;
          pcVar2 = ", read";
          sVar3 = strlen(modes);
          memcpy(modes + sVar3,pcVar2,sVar11);
        }
        if ((dir_info.st_mode & 2) != 0) {
          sVar11 = 8;
          pcVar2 = ", write";
          sVar3 = strlen(modes);
          memcpy(modes + sVar3,pcVar2,sVar11);
        }
        if ((dir_info.st_mode & 1) != 0) {
          if ((dir_info.st_mode & 0xf000) == 0x4000) {
            sVar11 = 9;
            pcVar2 = ", search";
            sVar3 = strlen(modes);
            memcpy(modes + sVar3,pcVar2,sVar11);
          }
          else {
            sVar11 = 10;
            pcVar2 = ", execute";
            sVar3 = strlen(modes);
            memcpy(modes + sVar3,pcVar2,sVar11);
            if ((dir_info.st_mode & 0x200) != 0) {
              sVar11 = 9;
              pcVar2 = ", sticky";
              sVar3 = strlen(modes);
              memcpy(modes + sVar3,pcVar2,sVar11);
            }
          }
        }
        pcVar2 = (char *)gettext("World:");
        dt_String(fp0,pcVar2,modes + 2);
        fwrite("\n</dl>\n",1,7,(FILE *)fp0);
      }
      if (temp != (char *)0x0) {
        free(temp);
        temp = (char *)0x0;
      }
    }
    EndInternalPage(fp0);
    LYrefresh();
    LYCloseTemp(LYShowInfo::tempfile);
    if (Title != (char *)0x0) {
      free(Title);
      Title = (char *)0x0;
    }
    local_53c = 0;
  }
  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {
    return local_53c;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

BOOLEAN editor_can_position(void)

{
  char *pcVar1;
  int iVar2;
  BOOLEAN local_19;
  char *local_18;
  uint n;
  HTList *p;
  char *value;
  
  p = positionable_editor;
  for (n = 0; n < 0xb; n = n + 1) {
    pcVar1 = strstr(editor,editor_can_position::table[n]);
    if (pcVar1 != (char *)0x0) {
      return '\x01';
    }
  }
  if (positionable_editor == (HTList *)0x0) {
LAB_0804d133:
    local_19 = '\0';
  }
  else {
    do {
      if ((p == (HTList *)0x0) || (p = p->next, p == (HTList *)0x0)) {
        local_18 = (char *)0x0;
      }
      else {
        local_18 = (char *)p->object;
      }
      if (local_18 == (char *)0x0) goto LAB_0804d133;
      iVar2 = strcmp(editor,local_18);
    } while (iVar2 != 0);
    local_19 = '\x01';
  }
  return local_19;
}



int edit_current_file(char *newfile,int cur,int lineno)

{
  int iVar1;
  BOOLEAN BVar2;
  FILE *pFVar3;
  char *pcVar4;
  int iVar5;
  char *Msg;
  int in_GS_OFFSET;
  int local_80;
  int local_7c;
  char *newfile_local;
  char *number_sign;
  char *colon;
  char *filename;
  int result;
  char position [80];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  result = 0;
  filename = (char *)0x0;
  if (WWW_TraceFlag != '\0') {
    pFVar3 = TraceFP();
    fprintf((FILE *)pFVar3,"edit_current_file(newfile=%s, cur=%d, lineno=%d)\n",newfile,cur,lineno);
  }
  BVar2 = LYisLocalFile(newfile);
  if (BVar2 == '\0') {
    pcVar4 = (char *)gettext("Lynx cannot currently (e)dit remote WWW files.");
    HTUserMsg(pcVar4);
    local_80 = 0;
    goto LAB_0804d388;
  }
  pcVar4 = trimPoundSelector(newfile);
  iVar5 = strncmp(newfile,"file://localhost/",0x10);
  if (iVar5 == 0) {
    colon = newfile + 0x10;
  }
  else {
    colon = strchr(newfile,0x3a);
  }
  HTSACopy(&filename,colon + 1);
  HTUnEscape(filename);
  BVar2 = LYCanReadFile(filename);
  if (BVar2 == '\0') {
    if (filename != (char *)0x0) {
      free(filename);
      filename = (char *)0x0;
    }
    filename = HTParse(newfile,"",5);
    HTUnEscape(filename);
    BVar2 = LYCanReadFile(filename);
    if (BVar2 != '\0') goto LAB_0804d2b4;
    Msg = (char *)gettext("Could not access file.");
    HTAlert(Msg);
  }
  else {
LAB_0804d2b4:
    if (cur < 0) {
      cur = 0;
    }
    position[0] = '\0';
    if (nlinks == 0) {
      local_7c = 0;
    }
    else {
      local_7c = links[cur].ly;
    }
    if (0 < lineno + local_7c) {
      sprintf(position,"%d",lineno + local_7c);
    }
    edit_temporary_file(filename,position,(char *)0x0);
    result = 1;
  }
  if (pcVar4 != (char *)0x0) {
    *pcVar4 = '#';
  }
  if (filename != (char *)0x0) {
    free(filename);
    filename = (char *)0x0;
  }
  if (WWW_TraceFlag != '\0') {
    pFVar3 = TraceFP();
    fprintf((FILE *)pFVar3,"edit_current_file returns %d\n",result);
  }
  local_80 = result;
LAB_0804d388:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return local_80;
}



void edit_temporary_file(char *filename,char *position,char *message)

{
  int iVar1;
  BOOLEAN BVar2;
  char *pcVar3;
  FILE *pFVar4;
  int *piVar5;
  wchar_t wVar6;
  char *Msg2;
  int iVar7;
  int in_GS_OFFSET;
  char *local_f8;
  char *message_local;
  char *position_local;
  char *filename_local;
  stat stat_info;
  anon_union_4_2_13109f1b __u_3;
  anon_union_4_2_13109f1b __u_2;
  anon_union_4_2_13109f1b __u_1;
  anon_union_4_2_13109f1b __u;
  int save_err;
  int rv;
  int params;
  char *editor_arg;
  char *command;
  char *format;
  char exitcode [80];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  format = "%s %s";
  command = (char *)0x0;
  editor_arg = "";
  pcVar3 = strstr(editor,"pico");
  if (pcVar3 != (char *)0x0) {
    editor_arg = " -t";
  }
  BVar2 = editor_can_position();
  if ((BVar2 == '\0') || (*position == '\0')) {
    HTAddXpand(&command,format,1,editor);
    HTAddParam(&command,format,2,filename);
    HTEndParam(&command,format,3);
  }
  else {
    format = "%s +%s%s %s";
    HTAddXpand(&command,"%s +%s%s %s",1,editor);
    HTAddParam(&command,format,2,position);
    HTAddParam(&command,format,3,editor_arg);
    HTAddParam(&command,format,4,filename);
    HTEndParam(&command,format,5);
  }
  if (message != (char *)0x0) {
    mustshow = '\x01';
    statusline(message);
  }
  pcVar3 = command;
  if (WWW_TraceFlag != '\0') {
    pFVar4 = TraceFP();
    fprintf((FILE *)pFVar4,"LYEdit: %s\n",pcVar3);
  }
  if ((WWW_TraceFlag != '\0') && (LYTraceLogFP == (FILE *)0x0)) {
    sleep(MessageSecs);
  }
  stop_curses();
  piVar5 = __errno_location();
  *piVar5 = 0;
  wVar6 = LYSystem(command);
  if (wVar6 == L'\0') {
    start_curses();
  }
  else {
    start_curses();
    piVar5 = __errno_location();
    iVar7 = *piVar5;
    if (WWW_TraceFlag != '\0') {
      if (iVar7 == 0) {
        local_f8 = "reason unknown";
      }
      else {
        local_f8 = strerror(iVar7);
      }
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"ExtEditForm: system() returned %d (0x%x), %s\n",wVar6,wVar6,local_f8);
    }
    LYFixCursesOn("show error warning:");
    if (wVar6 == L'\xffffffff') {
      pcVar3 = strerror(iVar7);
      Msg2 = (char *)gettext("Error starting editor, %s");
      HTUserMsg2(Msg2,pcVar3);
    }
    else if ((char)(((byte)wVar6 & 0x7f) + 1) >> 1 < '\x01') {
      if (((wVar6 & 0x7fU) == 0) && ((wVar6 & 0xff00U) >> 8 != 0x7f)) {
        sprintf(exitcode,"%d",(wVar6 & 0xff00U) >> 8);
        pcVar3 = (char *)gettext("Editor returned with error status %s");
        HTUserMsg2(pcVar3,exitcode);
      }
      else {
        pcVar3 = (char *)gettext(
                                "Error spawning editor, check your editor definition in the options menu"
                                );
        HTAlwaysAlert((char *)0x0,pcVar3);
      }
    }
    else {
      pcVar3 = (char *)gettext("Editor killed by signal");
      HTAlwaysAlert((char *)0x0,pcVar3);
    }
  }
  HTSprintf0(&command,"%s~",filename);
  iVar7 = stat64(command,(stat64 *)&stat_info);
  if (iVar7 == 0) {
    remove(command);
  }
  if (command != (char *)0x0) {
    free(command);
    command = (char *)0x0;
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



// WARNING: Unknown calling convention

wchar_t peek_mouse_levent(void)

{
  bool bVar1;
  wchar_t local_8;
  
  bVar1 = L'\0' < have_levent;
  if (bVar1) {
    ungetmouse(&levent);
    have_levent = have_levent + L'\xffffffff';
  }
  local_8 = (wchar_t)bVar1;
  return local_8;
}



// WARNING: Unknown calling convention

wchar_t get_mouse_link(void)

{
  wchar_t wVar1;
  wchar_t t;
  
  wVar1 = mouse_link;
  t = mouse_link;
  mouse_link = L'\xffffffff';
  if (wVar1 < L'\0') {
    t = L'\xffffffff';
  }
  return t;
}



// WARNING: Unknown calling convention

wchar_t peek_mouse_link(void)

{
  return mouse_link;
}



// WARNING: Unknown calling convention

wchar_t fancy_mouse(WINDOW *win,wchar_t row,wchar_t *position)

{
  int iVar1;
  int local_60;
  wchar_t local_58;
  int local_50;
  int local_4c;
  int local_40;
  int local_3c;
  wchar_t local_34;
  int local_2c;
  int local_28;
  MEVENT event;
  wchar_t delta;
  wchar_t mypos;
  wchar_t cmd;
  
  getmouse(&event);
  if ((event.bstate & 0x1c) == 0) {
    if ((event.bstate & 0x1c000) == 0) {
      return L'E';
    }
    return L'\r';
  }
  if (win == (WINDOW *)0x0) {
    local_60 = -1;
  }
  else {
    local_60 = (int)win->_begy;
  }
  local_60 = event.y - local_60;
  iVar1 = local_60 - row;
  if (win == (WINDOW *)0x0) {
    local_58 = L'\xffffffff';
  }
  else {
    local_58 = (wchar_t)win->_begx;
  }
  if (local_58 <= event.x) {
    if (win == (WINDOW *)0x0) {
      local_50 = -1;
      local_4c = -1;
    }
    else {
      local_50 = (int)win->_begx;
      local_4c = win->_maxx + 1;
    }
    if (event.x < local_50 + local_4c) goto LAB_0804d90f;
  }
  if ((event.bstate & 0x7000000) == 0) {
    return L'\r';
  }
LAB_0804d90f:
  if (win == (WINDOW *)0x0) {
    local_40 = -1;
  }
  else {
    local_40 = win->_maxy + 1;
  }
  if (local_60 + 1 == local_40) {
    if ((event.bstate & 0x10) == 0) {
      if ((event.bstate & 8) == 0) {
        cmd = L'\x1b';
      }
      else {
        cmd = L'\x0f';
      }
    }
    else {
      cmd = L'\x17';
    }
  }
  else {
    if (win == (WINDOW *)0x0) {
      local_3c = -1;
    }
    else {
      local_3c = win->_maxy + 1;
    }
    if (local_60 < local_3c) {
      if (local_60 == 0) {
        if ((event.bstate & 0x10) == 0) {
          if ((event.bstate & 8) == 0) {
            cmd = L'\x1a';
          }
          else {
            cmd = L'\x10';
          }
        }
        else {
          cmd = L'\x16';
        }
      }
      else if (local_60 < 0) {
        if ((event.bstate & 0x18) == 0) {
          cmd = L'\x10';
        }
        else {
          cmd = L'\x16';
        }
      }
      else {
        if (win == (WINDOW *)0x0) {
          local_34 = L'\0';
        }
        else {
          local_34 = win->_begx + L'\x01';
        }
        if (local_34 < event.x) {
          if (win == (WINDOW *)0x0) {
            local_2c = -1;
            local_28 = -1;
          }
          else {
            local_2c = (int)win->_begx;
            local_28 = win->_maxx + 1;
          }
          if (event.x < local_2c + local_28 + L'\xfffffffe') {
            if ((event.bstate & 0x7000000) != 0) {
              *position = *position + iVar1;
              return L'\xffffffff';
            }
            *position = *position + iVar1;
            return L'\'';
          }
        }
        *position = *position + iVar1;
        cmd = L'\xffffffff';
      }
    }
    else if ((event.bstate & 0x18) == 0) {
      cmd = L'\x0f';
    }
    else {
      cmd = L'\x17';
    }
  }
  return cmd;
}



// WARNING: Unknown calling convention

HTList * whichRecall(RecallType recall)

{
  HTList *pHVar1;
  HTList *local_18;
  HTList **list;
  
  if (recall == RECALL_CMD) {
    local_18 = LYcommandList();
  }
  else {
    if (recall == RECALL_MAIL) {
      list = &MAIL_edit_history;
    }
    else {
      list = &URL_edit_history;
    }
    if (*list == (HTList *)0x0) {
      pHVar1 = HTList_new();
      *list = pHVar1;
    }
    local_18 = *list;
  }
  return local_18;
}



// WARNING: Unknown calling convention

void LYRemoveFromCloset(HTList *list)

{
  void *__ptr;
  void *data;
  
  __ptr = HTList_removeFirstObject(list);
  if ((__ptr != (void *)0x0) && (__ptr != (void *)0x0)) {
    free(__ptr);
  }
  return;
}



// WARNING: Unknown calling convention

void LYCloseCloset(RecallType recall)

{
  HTList *list_00;
  HTList *list;
  
  list_00 = whichRecall(recall);
  while ((list_00 != (HTList *)0x0 && (list_00->next != (HTList *)0x0))) {
    LYRemoveFromCloset(list_00);
  }
  HTList_delete(list_00);
  return;
}



// WARNING: Unknown calling convention

char * LYFindInCloset(RecallType recall,char *base)

{
  size_t __n;
  int iVar1;
  char *local_1c;
  uint len;
  char *data;
  HTList *list;
  
  list = whichRecall(recall);
  __n = strlen(base);
  do {
    if ((list == (HTList *)0x0) || (list->next == (HTList *)0x0)) {
      return (char *)0x0;
    }
    if ((list == (HTList *)0x0) || (list = list->next, list == (HTList *)0x0)) {
      local_1c = (char *)0x0;
    }
    else {
      local_1c = (char *)list->object;
    }
    iVar1 = strncmp(base,local_1c,__n);
  } while (iVar1 != 0);
  return local_1c;
}



// WARNING: Unknown calling convention

void LYAddToCloset(RecallType recall,char *str)

{
  int iVar1;
  char *data;
  HTList *list;
  
  list = whichRecall(recall);
  data = (char *)0x0;
  HTSACopy(&data,str);
  HTList_addObject(list,data);
  while( true ) {
    iVar1 = HTList_count(list);
    if (iVar1 < 0x65) break;
    LYRemoveFromCloset(list);
  }
  return;
}



// WARNING: Unknown calling convention

wchar_t XYdist(wchar_t x1,wchar_t y1,wchar_t x2,wchar_t y2,wchar_t dx2)

{
  wchar_t local_1c;
  wchar_t local_18;
  wchar_t yerr;
  wchar_t xerr;
  
  xerr = (x2 - x1) * 3;
  yerr = (y2 - y1) * 9;
  if (xerr < L'\0') {
    xerr = ((x1 - x2) - dx2) * 3 + L'\x01';
  }
  if (xerr < L'\0') {
    xerr = L'\0';
  }
  if (yerr < L'\0') {
    yerr = (y2 - y1) * -9;
  }
  if (yerr == L'\0') {
    if (xerr < L'\x01') {
      local_18 = L'\0';
    }
    else {
      local_18 = xerr * 2 + L'\xffffffff';
    }
    local_1c = local_18;
  }
  else {
    if ((xerr < L'\t') && (yerr != L'\0')) {
      yerr = yerr + (9 - xerr);
    }
    local_1c = yerr + xerr * 2;
  }
  return local_1c;
}



// WARNING: Unknown calling convention

wchar_t set_clicked_link(wchar_t x,wchar_t y,wchar_t code,wchar_t clicks)

{
  int iVar1;
  int iVar2;
  bool bVar3;
  BOOLEAN BVar4;
  wchar_t wVar5;
  wchar_t wVar6;
  char *pcVar7;
  wchar_t wVar8;
  wchar_t local_98;
  int local_94;
  wchar_t local_90;
  wchar_t local_8c;
  wchar_t local_88;
  wchar_t local_84;
  wchar_t local_80;
  int local_78;
  int local_74;
  wchar_t local_6c;
  int local_68;
  double frac;
  wchar_t curx;
  wchar_t cury;
  wchar_t cur_err_2;
  char *text;
  wchar_t count;
  wchar_t is_text;
  wchar_t lx;
  wchar_t len;
  wchar_t cur_err;
  wchar_t mouse_err;
  wchar_t l;
  wchar_t h;
  wchar_t toolbar;
  wchar_t c;
  wchar_t i;
  wchar_t right;
  wchar_t left;
  
  wVar5 = (LYcols - (uint)(LYShowScrollbar != '\0')) + L'\xfffffffb';
  c = L'\xffffffff';
  if ((LYlines + L'\xffffffff' == y) || (y == L'\0')) {
    if ((y == L'\0') && (BVar4 = HText_hasToolbar(HTMainText), BVar4 != '\0')) {
      local_94 = 1;
    }
    else {
      local_94 = 0;
    }
    mouse_link = L'\xfffffffe';
    if ((x == L'\0') && (local_94 != 0)) {
      c = L'';
    }
    else if ((y == L'\0') &&
            ((LYcols - (uint)(LYShowScrollbar != '\0') == x && (s_hot_paste != -1)))) {
      c = L'';
    }
    else if (clicks < L'\x02') {
      if (x < local_94 + L'\x06') {
        if ((code == L'\x03') && (y != L'\0')) {
          local_88 = L'';
        }
        else {
          if ((s_forw_backw == -1) || (x - local_94 < 3)) {
            local_84 = L'';
          }
          else {
            local_84 = L'';
          }
          local_88 = local_84;
        }
        c = local_88;
      }
      else if (wVar5 < x) {
        if ((code == L'\x03') && (y != L'\0')) {
          local_80 = L'';
        }
        else {
          local_80 = L'';
        }
        c = local_80;
      }
      else if (y == L'\0') {
        c = L'';
      }
      else {
        c = L'';
      }
    }
    else if (x < local_94 + L'\x06') {
      if ((code == L'\x03') && (y != L'\0')) {
        local_90 = L'';
      }
      else {
        local_90 = L'';
      }
      c = local_90;
    }
    else if (wVar5 < x) {
      if ((code == L'\x03') && (y != L'\0')) {
        local_8c = L'';
      }
      else {
        local_8c = L'';
      }
      c = local_8c;
    }
    else if (y == L'\0') {
      c = L'';
    }
    else {
      c = L'';
    }
  }
  else if (((LYcols + L'\xffffffff' == x) && (LYShowScrollbar != '\0')) &&
          (L'\xffffffff' < LYsb_begin)) {
    if (LYsb_arrow == '\0') {
      local_78 = 0;
    }
    else {
      local_78 = 2;
    }
    wVar5 = display_lines - local_78;
    mouse_link = L'\xfffffffe';
    if (LYsb_arrow == '\0') {
      local_74 = 1;
    }
    else {
      local_74 = 2;
    }
    wVar8 = y - local_74;
    if (wVar8 < L'\0') {
      mouse_link = L'\xfffffffe';
      return L'';
    }
    if (wVar5 <= wVar8) {
      mouse_link = L'\xfffffffe';
      return L'';
    }
    if (L'\x01' < clicks) {
      wVar6 = HText_getNumOfLines();
      iVar1 = (wVar6 + L'\x01') - display_lines;
      if (0 < iVar1) {
        LYSetNewline((int)ROUND((double)iVar1 * ((double)wVar8 / (double)(wVar5 + L'\xffffffff')) +
                                1.0 + 0.5));
      }
      wVar5 = LYReverseKeymap(0x45);
      return wVar5;
    }
    if (wVar8 < LYsb_begin) {
      mouse_link = L'\xfffffffe';
      return L'';
    }
    if (LYsb_end <= wVar8) {
      mouse_link = L'\xfffffffe';
      return L'';
    }
    mouse_link = L'\xffffffff';
  }
  else {
    mouse_err = L'\x1d';
    for (i = L'\0'; i < nlinks; i = i + L'\x01') {
      iVar1 = links[i].lx;
      bVar3 = false;
      count = L'\0';
      pcVar7 = LYGetHiliteStr(i,L'\0');
      if ((links[i].type == 1) &&
         ((((links[i].l_form)->type == 1 || ((links[i].l_form)->type == 0xc)) ||
          (((links[i].l_form)->type == 2 ||
           (((links[i].l_form)->type == 0xb || ((links[i].l_form)->type == 9)))))))) {
        bVar3 = true;
      }
      if (pcVar7 != (char *)0x0) {
        if (bVar3) {
          len = (links[i].l_form)->size;
        }
        else {
          len = strlen(pcVar7);
        }
        cur_err = XYdist(x,y,links[i].lx,links[i].ly,len);
        while (L'\0' < cur_err) {
          count = count + L'\x01';
          pcVar7 = LYGetHiliteStr(i,count);
          if (pcVar7 == (char *)0x0) break;
          wVar5 = strlen(pcVar7);
          iVar2 = links[i].ly;
          wVar8 = LYGetHilitePos(i,count);
          wVar5 = XYdist(x,y,wVar8,iVar2 + count,wVar5);
          local_98 = cur_err;
          if (wVar5 < cur_err) {
            local_98 = wVar5;
          }
          cur_err = local_98;
        }
        if ((L'\0' < cur_err) && (bVar3)) {
          cur_err = cur_err + L'\xffffffff';
        }
        if (cur_err == L'\0') {
          if (LYwin == (WINDOW *)0x0) {
            local_6c = L'\xffffffff';
            local_68 = -1;
          }
          else {
            local_6c = (wchar_t)LYwin->_cury;
            local_68 = (int)LYwin->_curx;
          }
          if (((clicks < L'\x02') || (!bVar3)) || ((links[i].l_form)->type != 0xc)) {
            if (((code == L'\x02') && (local_6c == y)) &&
               ((iVar1 <= local_68 && (local_68 - iVar1 <= len)))) {
              mouse_link = L'\xffffffff';
            }
            else {
              if (bVar3) {
                have_levent = L'\x01';
              }
              mouse_link = i;
            }
            mouse_err = L'\0';
          }
          else {
            if (((code == L'\x02') && (local_6c == y)) &&
               ((iVar1 <= local_68 && (local_68 - iVar1 <= len)))) {
              mouse_link = L'\xffffffff';
            }
            else {
              mouse_link = i;
            }
            c = L'';
            mouse_err = L'\0';
          }
          break;
        }
        if (cur_err < mouse_err) {
          mouse_err = cur_err;
          mouse_link = i;
        }
      }
    }
    if (mouse_link < L'\0') {
      if (LYlines < y * 2) {
        if (y * 4 < LYlines * 3) {
          c = L'';
        }
        else {
          c = L'';
        }
      }
      else if (y * 4 < LYlines) {
        c = L'';
      }
      else {
        c = L'';
      }
    }
    else if (mouse_err == L'\0') {
      if (c == L'\xffffffff') {
        c = L'';
      }
    }
    else if (L'\xffffffff' < mouse_err) {
      c = L'';
    }
  }
  return c;
}



// WARNING: Unknown calling convention

char * LYstrncpy(char *dst,char *src,wchar_t n)

{
  wchar_t wVar1;
  char *pcVar2;
  wchar_t len;
  char *val;
  
  if (src == (char *)0x0) {
    src = "";
  }
  wVar1 = strlen(src);
  if (n < L'\0') {
    n = L'\0';
  }
  pcVar2 = strncpy(dst,src,n);
  if (wVar1 < n) {
    dst[wVar1] = '\0';
  }
  else {
    dst[n] = '\0';
  }
  return pcVar2;
}



char * LYmbcsstrncpy(char *dst,char *src,wchar_t n_bytes,wchar_t n_glyphs,BOOLEAN utf_flag)

{
  bool bVar1;
  char *pcVar2;
  BOOLEAN utf_flag_local;
  wchar_t i_glyphs;
  wchar_t i_bytes;
  char *val;
  
  pcVar2 = dst;
  i_bytes = L'\0';
  i_glyphs = L'\0';
  if (n_bytes < L'\0') {
    n_bytes = L'\0';
  }
  if (n_glyphs < L'\0') {
    n_glyphs = L'\0';
  }
  while( true ) {
    if ((*src == '\0') || (n_bytes <= i_bytes)) {
      *dst = '\0';
      return pcVar2;
    }
    if (((utf_flag != '\0') && ((*src & 0xc0U) != 0x80)) &&
       (bVar1 = n_glyphs <= i_glyphs, i_glyphs = i_glyphs + L'\x01', bVar1)) break;
    *dst = *src;
    dst = dst + 1;
    src = src + 1;
    i_bytes = i_bytes + L'\x01';
  }
  *dst = '\0';
  return pcVar2;
}



char * LYmbcs_skip_glyphs(char *data,wchar_t n_glyphs,BOOLEAN utf_flag)

{
  bool bVar1;
  BOOLEAN utf_flag_local;
  wchar_t i_glyphs;
  
  i_glyphs = L'\0';
  if (n_glyphs < L'\0') {
    n_glyphs = L'\0';
  }
  if ((data != (char *)0x0) && (*data != '\0')) {
    if (utf_flag == '\0') {
      do {
        bVar1 = n_glyphs < L'\x01';
        n_glyphs = n_glyphs + L'\xffffffff';
        if (bVar1) {
          return data;
        }
        data = data + 1;
      } while (*data != '\0');
    }
    else {
      while ((*data != '\0' &&
             (((utf_flag == '\0' || ((*data & 0xc0U) == 0x80)) ||
              (bVar1 = i_glyphs < n_glyphs, i_glyphs = i_glyphs + L'\x01', bVar1))))) {
        data = data + 1;
      }
    }
  }
  return data;
}



char * LYmbcs_skip_cells(char *data,wchar_t n_cells,BOOLEAN utf_flag)

{
  char *pcVar1;
  wchar_t wVar2;
  BOOLEAN utf_flag_local;
  wchar_t target;
  wchar_t actual;
  char *result;
  
  target = n_cells;
  do {
    pcVar1 = LYmbcs_skip_glyphs(data,target,utf_flag);
    wVar2 = LYstrExtent2(data,(int)pcVar1 - (int)data);
    if (wVar2 < L'\x01') {
      return pcVar1;
    }
    target = target + L'\xffffffff';
  } while (n_cells < wVar2);
  return pcVar1;
}



wchar_t LYmbcsstrlen(char *str,BOOLEAN utf_flag,BOOLEAN count_gcells)

{
  BOOLEAN count_gcells_local;
  BOOLEAN utf_flag_local;
  wchar_t len;
  wchar_t j;
  wchar_t i;
  
  len = L'\0';
  if ((str != (char *)0x0) && (*str != '\0')) {
    if (count_gcells == '\0') {
      for (i = L'\0'; str[i] != '\0'; i = i + L'\x01') {
        if ((str[i] < '\x03') || ('\b' < str[i])) {
          len = len + L'\x01';
          if ((utf_flag == '\0') || ((str[i] & 0xc0U) == 0x80)) {
            if (((((utf_flag == '\0') && (HTCJK != NOCJK)) && (str[i] < '\0')) &&
                (str[i + L'\x01'] != '\0')) &&
               ((str[i + L'\x01'] < '\x03' || ('\b' < str[i + L'\x01'])))) {
              i = i + L'\x01';
            }
          }
          else {
            j = L'\0';
            while (((str[i + L'\x01'] != '\0' &&
                    ((str[i + L'\x01'] < '\x03' || ('\b' < str[i + L'\x01'])))) &&
                   ((j < L'\x05' && ((utf_flag != '\0' && ((str[i + L'\x01'] & 0xc0U) == 0x80)))))))
            {
              i = i + L'\x01';
              j = j + L'\x01';
            }
          }
        }
      }
    }
    else {
      len = LYstrCells(str);
    }
  }
  return len;
}



void ena_csi(BOOLEAN flag)

{
  BOOLEAN flag_local;
  
  csi_is_csi = flag;
  return;
}



// WARNING: Unknown calling convention

wchar_t lookup_tiname(char *name,char **names)

{
  int iVar1;
  wchar_t code;
  
  code = L'\0';
  while( true ) {
    if (names[code] == (char *)0x0) {
      return L'\xffffffff';
    }
    iVar1 = strcmp(names[code],name);
    if (iVar1 == 0) break;
    code = code + L'\x01';
  }
  return code;
}



char * expand_tiname(char *first,size_t len,char **result,char *final)

{
  int iVar1;
  char *pcVar2;
  size_t sVar3;
  int in_GS_OFFSET;
  char *final_local;
  char **result_local;
  char *first_local;
  wchar_t code;
  char name [8192];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  strncpy(name,first,len);
  name[len] = '\0';
  code = lookup_tiname(name,(char **)strnames);
  if (code < L'\0') {
    code = lookup_tiname(name,(char **)strfnames);
    if (code < L'\0') goto LAB_0804ea55;
  }
  if (*(int *)(*(int *)(cur_term + 0x10) + code * 4) != 0) {
    LYstrncpy(*result,*(char **)(*(int *)(cur_term + 0x10) + code * 4),(int)final - (int)*result);
    pcVar2 = *result;
    sVar3 = strlen(*result);
    *result = pcVar2 + sVar3;
  }
LAB_0804ea55:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return first + len;
}



char * expand_tichar(char *first,char **result,char *final)

{
  int iVar1;
  ushort **ppuVar2;
  size_t len;
  int in_GS_OFFSET;
  char *final_local;
  char **result_local;
  char *first_local;
  char *last;
  char *name;
  wchar_t value;
  wchar_t radix;
  wchar_t limit;
  wchar_t ch;
  char tmp [80];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  limit = L'\0';
  radix = L'\0';
  value = L'\0';
  name = (char *)0x0;
  ch = (wchar_t)*first;
  first_local = first + 1;
  switch(ch) {
  case L'E':
  case L'e':
    value = L'\x1b';
    break;
  default:
    ppuVar2 = __ctype_b_loc();
    if (((*ppuVar2)[ch] & 0x800) == 0) {
      value = (wchar_t)*first_local;
    }
    else {
      radix = L'\b';
      limit = L'\x03';
      first_local = first;
    }
    break;
  case L'a':
    name = "bel";
    break;
  case L'b':
    value = L'\b';
    break;
  case L'd':
    radix = L'\n';
    limit = L'\x03';
    break;
  case L'f':
    value = L'\f';
    break;
  case L'n':
    value = L'\n';
    break;
  case L'r':
    value = L'\r';
    break;
  case L't':
    value = L'\t';
    break;
  case L'v':
    value = L'\v';
    break;
  case L'x':
    radix = L'\x10';
    limit = L'\x02';
  }
  if (radix != L'\0') {
    last = (char *)0x0;
    LYstrncpy(tmp,first_local,limit);
    value = strtol(tmp,&last,radix);
    if ((last != (char *)0x0) && (last != tmp)) {
      first_local = first_local + ((int)last - (int)tmp);
    }
  }
  if (name == (char *)0x0) {
    **result = (char)value;
    *result = *result + 1;
  }
  else {
    len = strlen(name);
    expand_tiname(name,len,result,final);
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return first_local;
}



// WARNING: Unknown calling convention

wchar_t expand_substring(char *dst,char *first,char *last,char *final)

{
  byte *first_00;
  char *pcVar1;
  byte bVar2;
  size_t sVar3;
  char *was;
  char *s;
  wchar_t ch;
  
  while( true ) {
    while( true ) {
      while( true ) {
        while( true ) {
          if (last <= first) {
            *dst = '\0';
            return L'\x01';
          }
          ch._0_1_ = *first;
          first_00 = (byte *)(first + 1);
          if ((char)ch != '\\') break;
          first = (char *)first_00;
          first = expand_tichar((char *)first_00,&dst,final);
        }
        if ((char)ch == '^') break;
        if ((char)ch == '\0') {
          ch._0_1_ = -0x80;
        }
        *dst = (char)ch;
        dst = dst + 1;
        first = (char *)first_00;
      }
      bVar2 = *first_00;
      pcVar1 = first + 2;
      if (bVar2 == 0x28) break;
      if (bVar2 == 0x3f) {
        *dst = '\x7f';
        dst = dst + 1;
        first = pcVar1;
      }
      else if ((bVar2 & 0x3f) < 0x20) {
        *dst = bVar2 & 0x1f;
        dst = dst + 1;
        first = pcVar1;
      }
      else {
        *dst = '^';
        dst = dst + 1;
        first = first + 1;
      }
    }
    first = pcVar1;
    s = strchr(pcVar1,0x29);
    pcVar1 = dst;
    if (s == (char *)0x0) {
      sVar3 = strlen(first);
      s = first + sVar3;
    }
    first = expand_tiname(first,(int)s - (int)first,&dst,final);
    if (dst == pcVar1) break;
    if (*first != '\0') {
      first = first + 1;
    }
  }
  return L'\0';
}



void unescaped_char(char *parse,wchar_t *keysym)

{
  int iVar1;
  size_t sVar2;
  int in_GS_OFFSET;
  wchar_t *keysym_local;
  char *parse_local;
  size_t len;
  char buf [8192];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  sVar2 = strlen(parse);
  if (2 < sVar2) {
    expand_substring(buf,parse + 1,parse + (sVar2 - 1),buf + 0x1fff);
    sVar2 = strlen(buf);
    if (sVar2 == 1) {
      *keysym = (int)buf[0];
    }
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



// WARNING: Unknown calling convention

BOOLEAN unescape_string(char *src,char *dst,char *final)

{
  size_t sVar1;
  wchar_t wVar2;
  wchar_t keysym;
  BOOLEAN ok;
  
  ok = '\0';
  if (*src == '\'') {
    keysym = L'\xffffffff';
    unescaped_char(src,&keysym);
    if (L'\xffffffff' < keysym) {
      *dst = (char)keysym;
      dst[1] = '\0';
      ok = '\x01';
    }
  }
  else if (*src == '\"') {
    sVar1 = strlen(src);
    wVar2 = expand_substring(dst,src + 1,src + (sVar1 - 1),final);
    ok = (BOOLEAN)wVar2;
  }
  return ok;
}



wchar_t map_string_to_keysym(char *str,wchar_t *keysym)

{
  int iVar1;
  int iVar2;
  wchar_t wVar3;
  ushort **ppuVar4;
  size_t sVar5;
  int in_GS_OFFSET;
  wchar_t local_2034;
  size_t local_2030;
  wchar_t *keysym_local;
  char *str_local;
  Keysym_String_List *k;
  long value;
  char *tmp;
  size_t len;
  wchar_t othersym;
  char *other;
  wchar_t modifier;
  char buf [8192];
  
  str_local = str;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  modifier = L'\0';
  *keysym = L'\xffffffff';
  iVar2 = strncasecomp(str,"LAC:",4);
  if (iVar2 == 0) {
    other = strchr(str + 4,0x3a);
    if (other != (char *)0x0) {
      othersym = lecname_to_lec(other + 1);
      if ((L'\xffffffff' < othersym) && ((int)(other + (-4 - (int)str)) < 0x2000)) {
        strncpy(buf,str + 4,(size_t)(other + (-4 - (int)str)));
        other[(int)(buf + (-4 - (int)str))] = '\0';
        wVar3 = lacname_to_lac(buf);
        *keysym = wVar3;
        if (L'\xffffffff' < *keysym) {
          *keysym = othersym << 8 | *keysym | 0x8000;
          local_2034 = *keysym;
          goto LAB_0804f472;
        }
      }
    }
    wVar3 = lacname_to_lac(str + 4);
    *keysym = wVar3;
    if (L'\xffffffff' < *keysym) {
      *keysym = *keysym | 0x800;
      local_2034 = *keysym;
      goto LAB_0804f472;
    }
  }
  iVar2 = strncasecomp(str,"Meta-",5);
  if (iVar2 == 0) {
    str_local = str + 5;
    modifier = L'\x2000';
    if (*str_local != 0) {
      len = strlen(str_local);
      if (len == 1) {
        *keysym = (uint)(byte)*str_local | modifier;
        local_2034 = *keysym;
        goto LAB_0804f472;
      }
      if ((len == 2) && (*str_local == 0x5e)) {
        ppuVar4 = __ctype_b_loc();
        if ((((*ppuVar4)[(byte)str[6]] & 0x400) != 0) || (('?' < str[6] && (str[6] < '`')))) {
          *keysym = (byte)str[6] & 0x1f | modifier;
          local_2034 = *keysym;
          goto LAB_0804f472;
        }
      }
      if ((len == 2) && ((*str_local == 0x5e && (str[6] == '?')))) {
        *keysym = modifier | 0x7f;
        local_2034 = *keysym;
        goto LAB_0804f472;
      }
      if ((*str_local == 0x5e) || (*str_local == 0x5c)) {
        local_2030 = len;
        if (0x1c < len) {
          local_2030 = 0x1c;
        }
        expand_substring(buf,str_local,(char *)((byte *)str_local + local_2030),buf + 0x1fff);
        sVar5 = strlen(buf);
        if (sVar5 < 2) {
          *keysym = (uint)(byte)buf[0] | modifier;
          local_2034 = *keysym;
          goto LAB_0804f472;
        }
      }
    }
  }
  if (*str_local == '\'') {
    unescaped_char(str_local,keysym);
  }
  else {
    ppuVar4 = __ctype_b_loc();
    if (((*ppuVar4)[(byte)*str_local] & 0x800) == 0) {
      for (k = Keysym_Strings; k->string != (char *)0x0; k = k + 1) {
        iVar2 = strcmp(k->string,str_local);
        if (iVar2 == 0) {
          *keysym = k->value;
          break;
        }
      }
    }
    else {
      wVar3 = strtol(str_local,&tmp,0);
      ppuVar4 = __ctype_b_loc();
      if ((((*ppuVar4)[(byte)*tmp] & 8) == 0) && (*keysym = wVar3, L'' < *keysym)) {
        *keysym = *keysym | 0x400;
      }
    }
  }
  if (L'\xffffffff' < *keysym) {
    *keysym = *keysym | modifier;
  }
  local_2034 = *keysym;
LAB_0804f472:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return local_2034;
}



// WARNING: Unknown calling convention

char * skip_keysym(char *parse)

{
  bool bVar1;
  ushort **ppuVar2;
  char *local_18;
  wchar_t escaped;
  wchar_t quoted;
  
  quoted = L'\0';
  bVar1 = false;
  for (; *parse != '\0'; parse = parse + 1) {
    if (bVar1) {
      bVar1 = false;
    }
    else if (quoted == L'\0') {
      if (*parse == '\\') {
        bVar1 = true;
      }
      else if ((*parse == '\"') || (*parse == '\'')) {
        quoted = (wchar_t)*parse;
      }
      else {
        ppuVar2 = __ctype_b_loc();
        if (((*ppuVar2)[(byte)*parse] & 0x2000) != 0) break;
      }
    }
    else if (*parse == '\\') {
      bVar1 = true;
    }
    else if (*parse == quoted) {
      quoted = L'\0';
    }
  }
  if ((quoted != L'\0') || (bVar1)) {
    local_18 = (char *)0x0;
  }
  else {
    local_18 = parse;
  }
  return local_18;
}



wchar_t setkey_cmd(char *parse)

{
  int iVar1;
  BOOLEAN BVar2;
  FILE *pFVar3;
  ushort **ppuVar4;
  wchar_t wVar5;
  int in_GS_OFFSET;
  wchar_t local_2020;
  char *parse_local;
  wchar_t keysym;
  char *t;
  char *s;
  char buf [8192];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
    pFVar3 = TraceFP();
    fprintf((FILE *)pFVar3,"KEYMAP(PA): in=%s",parse);
  }
  s = skip_keysym(parse);
  if (s == (char *)0x0) {
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
      pFVar3 = TraceFP();
      fprintf((FILE *)pFVar3,"KEYMAP(SKIP) no key description\n");
    }
  }
  else {
    ppuVar4 = __ctype_b_loc();
    if (((*ppuVar4)[(byte)*s] & 0x2000) == 0) {
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
        pFVar3 = TraceFP();
        fprintf((FILE *)pFVar3,"KEYMAP(SKIP) junk after key description: \'%s\'\n",s);
      }
    }
    else {
      *s = '\0';
      s = s + 1;
      s = LYSkipBlanks(s);
      t = skip_keysym(s);
      if (t == (char *)0x0) {
        if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
          pFVar3 = TraceFP();
          fprintf((FILE *)pFVar3,"KEYMAP(SKIP) no key expansion found\n");
        }
        local_2020 = L'\xffffffff';
        goto LAB_0804f886;
      }
      if (t != s) {
        *t = '\0';
      }
      wVar5 = map_string_to_keysym(s,&keysym);
      if (L'\xffffffff' < wVar5) {
        BVar2 = unescape_string(parse,buf,buf + 0x1fff);
        wVar5 = keysym;
        if (BVar2 == '\0') {
          if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
            pFVar3 = TraceFP();
            fprintf((FILE *)pFVar3,"KEYMAP(SKIP) could unescape key\n");
          }
          local_2020 = L'\0';
        }
        else {
          if (LYTraceLogFP == (FILE *)0x0) {
            if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
              pFVar3 = TraceFP();
              fprintf((FILE *)pFVar3,"KEYMAP(DEF) keysym=%#x\n",wVar5);
            }
          }
          else if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
            pFVar3 = TraceFP();
            fprintf((FILE *)pFVar3,"KEYMAP(DEF) keysym=%#x, seq=\'%s\'\n",wVar5,buf);
          }
          local_2020 = define_key(buf,keysym);
        }
        goto LAB_0804f886;
      }
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
        pFVar3 = TraceFP();
        fprintf((FILE *)pFVar3,"KEYMAP(SKIP) could not map to keysym\n");
      }
    }
  }
  local_2020 = L'\xffffffff';
LAB_0804f886:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return local_2020;
}



// WARNING: Unknown calling convention

wchar_t unsetkey_cmd(char *parse)

{
  wchar_t wVar1;
  wchar_t keysym;
  char *s;
  
  s = skip_keysym(parse);
  if (s != parse) {
    *s = '\0';
    wVar1 = map_string_to_keysym(parse,&keysym);
    if (L'\xffffffff' < wVar1) {
      define_key(0,keysym);
    }
  }
  return L'\0';
}



// WARNING: Unknown calling convention

wchar_t read_keymap_file(void)

{
  int iVar1;
  _func_wchar_t_char_ptr *p_Var2;
  FILE *fp_00;
  size_t __n;
  size_t sVar3;
  int iVar4;
  char *pcVar5;
  wchar_t wVar6;
  char *pcVar7;
  int in_GS_OFFSET;
  size_t len;
  char *s;
  size_t n;
  wchar_t linenum;
  FILE *fp;
  char *line;
  char file [256];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  line = (char *)0x0;
  LYAddPathToHome(file,0x100,".lynx-keymaps");
  fp_00 = fopen64(file,"r");
  if (fp_00 != (FILE *)0x0) {
    linenum = L'\0';
    while (pcVar7 = LYSafeGets(&line,(FILE *)fp_00), pcVar7 != (char *)0x0) {
      pcVar7 = LYSkipBlanks(line);
      linenum = linenum + L'\x01';
      if ((*pcVar7 != '\0') && (*pcVar7 != '#')) {
        for (n = 0; n < 2; n = n + 1) {
          __n = strlen(read_keymap_file::table[n].name);
          sVar3 = strlen(pcVar7);
          if ((__n < sVar3) &&
             (iVar4 = strncmp(pcVar7,read_keymap_file::table[n].name,__n), iVar4 == 0)) {
            p_Var2 = read_keymap_file::table[n].func;
            pcVar5 = LYSkipBlanks(pcVar7 + __n);
            wVar6 = (*p_Var2)(pcVar5);
            if (wVar6 < L'\0') {
              pcVar5 = (char *)gettext("Error processing line %d of %s\n");
              fprintf(stderr,pcVar5,linenum,file);
            }
          }
        }
      }
    }
    if (line != (char *)0x0) {
      free(line);
      line = (char *)0x0;
    }
    LYCloseInput((FILE *)fp_00);
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return L'\0';
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void setup_vtXXX_keymap(void)

{
  size_t n;
  
  for (n = 0; n < 0x15; n = n + 1) {
    define_key(setup_vtXXX_keymap::table[n].string,setup_vtXXX_keymap::table[n].value);
  }
  return;
}



// WARNING: Unknown calling convention

wchar_t lynx_initialize_keymaps(void)

{
  wchar_t wVar1;
  
  setup_vtXXX_keymap();
  wVar1 = read_keymap_file();
  return wVar1;
}



// WARNING: Unknown calling convention

wchar_t LYmouse_menu(wchar_t x,wchar_t y,wchar_t atlink,wchar_t code)

{
  wchar_t wVar1;
  wchar_t local_100;
  wchar_t local_fc;
  wchar_t local_f8;
  char *choices [27];
  wchar_t actions [26];
  wchar_t filter_out;
  wchar_t retlac;
  wchar_t c1;
  wchar_t c;
  
  if (atlink == L'\0') {
    local_100 = L'\x02';
  }
  else {
    local_100 = L'\x01';
  }
  filter_out = local_100;
  c1 = L'\0';
  for (c = L'\0'; c < L'\x1a'; c = c + L'\x01') {
    if ((filter_out & LYmouse_menu::possible_entries[c].flag) == 0) {
      choices[c1] = LYmouse_menu::possible_entries[c].txt;
      actions[c1] = LYmouse_menu::possible_entries[c].action;
      c1 = c1 + L'\x01';
    }
  }
  choices[c1] = (char *)0x0;
  if (x < L'\x06') {
    local_fc = L'\x01';
  }
  else {
    local_fc = x + L'\xfffffffb';
  }
  if (atlink == L'\0') {
    local_f8 = L'\t';
  }
  else {
    local_f8 = L'\x01';
  }
  wVar1 = popup_choice(local_f8,y,local_fc,choices,c1,L'\0','\x01');
  if (term_options == '\0') {
    retlac = actions[wVar1];
  }
  else {
    retlac = L'E';
    term_options = '\0';
  }
  if ((code == L'\x02') && (mouse_link == L'\xffffffff')) {
    switch(retlac) {
    case L'\x0e':
      retlac = L'\r';
    case L'\f':
    case L'\x0f':
    case L'\x10':
    case L'\x11':
    case L'\x12':
    case L'\x13':
    case L'\x14':
    case L'\x16':
    case L'\x17':
    case L'$':
    case L'%':
    case L'*':
    case L'+':
    case L'0':
    case L'1':
    case L'2':
    case L'3':
    case L'8':
    case L'9':
    case L'<':
    case L'O':
      mouse_link = L'\xfffffffd';
    }
  }
  if ((retlac == L'E') || (retlac == L'\x15')) {
    mouse_link = L'\xffffffff';
  }
  if ((code == L'\x02') && (retlac == L'E')) {
    repaint_main_statusline(L'\x02');
  }
  return retlac;
}



// WARNING: Unknown calling convention

wchar_t LYgetch_for(wchar_t code)

{
  undefined4 uVar1;
  int *piVar2;
  WINDOW *pWVar3;
  FILE *pFVar4;
  wchar_t wVar5;
  ushort **ppuVar6;
  char *Msg;
  int iVar7;
  FILE *ctx;
  wchar_t local_54;
  wchar_t local_50;
  wchar_t local_4c;
  MEVENT event;
  wchar_t atlink;
  wchar_t lac;
  wchar_t err;
  wchar_t current_modifier;
  wchar_t d;
  wchar_t c;
  wchar_t b;
  wchar_t a;
  BOOLEAN done_esc;
  
  d = L'\xffffffff';
  current_modifier = L'\0';
  done_esc = false;
  have_levent = L'\0';
  uVar1 = levent._0_4_;
  do {
    levent._0_4_ = uVar1;
    piVar2 = __errno_location();
    if (*piVar2 == 4) {
      piVar2 = __errno_location();
      *piVar2 = 0;
    }
    clearerr(stdin);
    pWVar3 = LYtopwindow();
    c = wgetch(pWVar3);
    lynx_nl2crlf(L'\0');
    if (WWW_TraceFlag != '\0') {
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"GETCH: Got %#x.\n",c);
    }
    if ((c == L'\xffffffff') && (piVar2 = __errno_location(), *piVar2 == 4)) {
      if (WWW_TraceFlag != '\0') {
        iVar7 = (int)recent_sizechange;
        pFVar4 = TraceFP();
        fprintf((FILE *)pFVar4,"Got EOF with EINTR, recent_sizechange so far is %d\n",iVar7);
      }
      if ((recent_sizechange == '\0') && (size_change(L'\0'), WWW_TraceFlag != '\0')) {
        iVar7 = (int)recent_sizechange;
        pFVar4 = TraceFP();
        fprintf((FILE *)pFVar4,"Now recent_sizechange is %d\n",iVar7);
      }
      piVar2 = __errno_location();
      *piVar2 = 0;
      return L'';
    }
    ctx = stdin;
    iVar7 = feof(stdin);
    if (((iVar7 != 0) || (ctx = stdin, iVar7 = ferror(stdin), iVar7 != 0)) || (c == L'\xffffffff'))
    {
      if (recent_sizechange != '\0') {
        return L'\a';
      }
      cleanup((EVP_PKEY_CTX *)ctx);
      exit_immediately(0);
    }
    if ((escape_bound == 0) && ((c == L'\x1b' || ((csi_is_csi != '\0' && (c == L'\x9b')))))) {
      done_esc = '\x01';
      pWVar3 = LYtopwindow();
      wVar5 = wgetch(pWVar3);
      if ((wVar5 == L'[') || (a = wVar5, wVar5 == L'O')) {
        pWVar3 = LYtopwindow();
        a = wgetch(pWVar3);
      }
      switch(a) {
      case L'1':
        if ((wVar5 == L'[') || (c == L'\x9b')) {
          pWVar3 = LYtopwindow();
          d = wgetch(pWVar3);
          if (d == L'~') {
            c = L'';
            break;
          }
        }
        done_esc = '\0';
        break;
      case L'2':
        if ((wVar5 == L'[') || (c == L'\x9b')) {
          pWVar3 = LYtopwindow();
          d = wgetch(pWVar3);
          if (d == L'~') {
            c = L'';
          }
          else if ((d == L'8') || (d == L'9')) {
            pWVar3 = LYtopwindow();
            iVar7 = wgetch(pWVar3);
            if (iVar7 == 0x7e) {
              if (d == L'8') {
                c = L'';
              }
              else if (d == L'9') {
                c = L'';
              }
              d = L'\xffffffff';
            }
          }
        }
        else {
          done_esc = '\0';
        }
        break;
      case L'3':
        if ((wVar5 == L'[') || (c == L'\x9b')) {
          pWVar3 = LYtopwindow();
          d = wgetch(pWVar3);
          if (d == L'~') {
            c = L'';
            break;
          }
        }
        done_esc = '\0';
        break;
      case L'4':
        if ((wVar5 == L'[') || (c == L'\x9b')) {
          pWVar3 = LYtopwindow();
          d = wgetch(pWVar3);
          if (d == L'~') {
            c = L'';
            break;
          }
        }
        done_esc = '\0';
        break;
      case L'5':
        if ((wVar5 == L'[') || (c == L'\x9b')) {
          pWVar3 = LYtopwindow();
          d = wgetch(pWVar3);
          if (d == L'~') {
            c = L'';
            break;
          }
        }
        done_esc = '\0';
        break;
      case L'6':
        if ((wVar5 == L'[') || (c == L'\x9b')) {
          pWVar3 = LYtopwindow();
          d = wgetch(pWVar3);
          if (d == L'~') {
            c = L'';
            break;
          }
        }
        done_esc = '\0';
        break;
      default:
switchD_0804ff2c_caseD_37:
        if (((c == L'\x1b') && (a == wVar5)) && (wVar5 != L'[')) {
          current_modifier = L'\x2000';
          c = a;
          done_esc = (uint)a >> 8 == 0;
        }
        else {
          if (WWW_TraceFlag != '\0') {
            pFVar4 = TraceFP();
            fprintf((FILE *)pFVar4,"Unknown key sequence: %d:%d:%d\n",c,wVar5,a);
          }
          if ((WWW_TraceFlag != '\0') && (LYTraceLogFP == (FILE *)0x0)) {
            sleep(MessageSecs);
          }
        }
        break;
      case L'A':
        c = L'';
        break;
      case L'B':
        c = L'';
        break;
      case L'C':
        c = L'';
        break;
      case L'D':
        c = L'';
        break;
      case L'M':
        c = L'\n';
        break;
      case L'P':
        c = L'';
        break;
      case L'[':
        if ((wVar5 != L'[') && (c != L'\x9b')) goto switchD_0804ff2c_caseD_37;
        pWVar3 = LYtopwindow();
        d = wgetch(pWVar3);
        if (d == L'A') {
          c = L'';
        }
        break;
      case L'k':
        if (wVar5 == L'O') {
          c = L'+';
        }
        else {
          done_esc = '\0';
        }
        break;
      case L'l':
        c = L'+';
        break;
      case L'm':
        c = L'-';
        break;
      case L'p':
        c = L'0';
        break;
      case L'q':
        c = L'';
        break;
      case L'r':
        c = L'';
        break;
      case L's':
        c = L'';
        break;
      case L't':
        c = L'';
        break;
      case L'u':
        c = L'';
        break;
      case L'v':
        c = L'';
        break;
      case L'w':
        c = L'';
        break;
      case L'x':
        c = L'';
        break;
      case L'y':
        c = L'';
      }
      ppuVar6 = __ctype_b_loc();
      if ((((*ppuVar6)[a] & 0x800) != 0) &&
         ((((wVar5 == L'[' || (c == L'\x9b')) && (d != L'\xffffffff')) && (d != L'~')))) {
        pWVar3 = LYtopwindow();
        d = wgetch(pWVar3);
      }
      if ((!(bool)done_esc) && ((uint)a >> 8 == 0)) {
        if (((a == wVar5) && ((wVar5 != L'[' && (c != L'\x9b')))) && (c == L'\x1b')) {
          current_modifier = L'\x2000';
          c = a;
          done_esc = true;
        }
        else {
          done_esc = true;
        }
      }
    }
    if ((c < L'\0') || ((c & 0x8000U) == 0)) {
      if ((L'\xffffffff' < c) && ((c & 0x400U) != 0)) {
        c = c & 0xfffffbff;
        done_esc = true;
      }
    }
    else if ((code != L'\x02') && (code != L'\x03')) {
      if ((c == L'\xffffffff') || ((c & 0x8000U) == 0)) {
        local_54 = c;
      }
      else {
        local_54 = (wchar_t)CONCAT11(8,(char)c);
      }
      c = local_54;
    }
    if ((((L'\xffffffff' < c) && (L'\xffffffff' < c)) && ((c & 0x8000U) == 0)) &&
       ((c & 0x2000U) != 0)) {
      current_modifier = L'\x2000';
      c = c & 0x7ff;
    }
    if ((L'\xffffffff' < c) && ((c & 0x8800U) != 0)) {
      done_esc = true;
    }
    if ((bool)done_esc) goto switchD_08050400_caseD_108;
    switch(c) {
    case L'':
      c = L'';
      goto switchD_08050400_caseD_108;
    case L'':
      c = L'';
      goto switchD_08050400_caseD_108;
    case L'':
      c = L'';
      goto switchD_08050400_caseD_108;
    case L'':
      c = L'';
      goto switchD_08050400_caseD_108;
    case L'':
      c = L'';
      goto switchD_08050400_caseD_108;
    case L'':
      c = L'\x7f';
    default:
      goto switchD_08050400_caseD_108;
    case L'':
      c = L'';
      goto switchD_08050400_caseD_108;
    case L'':
      c = L'';
      goto switchD_08050400_caseD_108;
    case L'':
      c = L'';
      goto switchD_08050400_caseD_108;
    case L'':
      c = L'';
      goto switchD_08050400_caseD_108;
    case L'':
      c = L'\x12';
      goto switchD_08050400_caseD_108;
    case L'':
      c = L'';
      goto switchD_08050400_caseD_108;
    case L'':
      c = L'';
      goto switchD_08050400_caseD_108;
    case L'':
      c = L'\n';
      goto switchD_08050400_caseD_108;
    case L'':
      c = L'';
      goto switchD_08050400_caseD_108;
    case L'':
      c = L'';
      goto switchD_08050400_caseD_108;
    case L'':
      c = L'';
      goto switchD_08050400_caseD_108;
    case L'':
      c = L'';
      goto switchD_08050400_caseD_108;
    case L'':
      c = L'';
      goto switchD_08050400_caseD_108;
    case L'':
      c = L'';
      goto switchD_08050400_caseD_108;
    case L'':
      c = L'';
      goto switchD_08050400_caseD_108;
    case L'':
      c = L'';
      goto switchD_08050400_caseD_108;
    case L'':
      c = L'';
      goto switchD_08050400_caseD_108;
    case L'':
      c = L'';
      goto switchD_08050400_caseD_108;
    case L'':
      c = L'';
      goto switchD_08050400_caseD_108;
    case L'':
      c = L'';
      goto switchD_08050400_caseD_108;
    case L'':
      if (WWW_TraceFlag != '\0') {
        pFVar4 = TraceFP();
        fprintf((FILE *)pFVar4,"KEY_MOUSE\n");
      }
      if (code == L'\x01') {
        c = L'';
        goto switchD_08050400_caseD_108;
      }
      if (code == L'\x04') {
        getmouse(&event);
        c = L'';
        goto switchD_08050400_caseD_108;
      }
      lac = L'\0';
      c = L'\xffffffff';
      mouse_link = L'\xffffffff';
      iVar7 = getmouse(&event);
      if (iVar7 != 0) {
        if (WWW_TraceFlag != '\0') {
          pFVar4 = TraceFP();
          fprintf((FILE *)pFVar4,"Mouse error: no event available!\n");
        }
        if (code == L'\0') {
          local_50 = L'\0';
        }
        else {
          local_50 = L'';
        }
        return local_50;
      }
      uVar1._0_2_ = event.id;
      uVar1._2_2_ = event._2_2_;
      levent.id = event.id;
      levent._2_2_ = event._2_2_;
      levent.x = event.x;
      levent.y = event.y;
      levent.z = event.z;
      levent.bstate = event.bstate;
      if ((event.bstate & 4) != 0) {
        c = set_clicked_link(event.x,event.y,code,L'\x01');
        goto LAB_0805092b;
      }
      if ((event.bstate & 8) != 0) {
        c = set_clicked_link(event.x,event.y,code,L'\x02');
        if ((c == L'') && (code == L'\x02')) {
          lac = L'(';
        }
        goto LAB_0805092b;
      }
      if ((event.bstate & 0x4000) != 0) {
        c = L'';
        goto LAB_0805092b;
      }
      if ((code != L'\x03') && (uVar1 = levent._0_4_, (event.bstate & 0x30c3) == 0)) {
        if ((event.bstate & 0x100) != 0) {
          wVar5 = set_clicked_link(event.x,event.y,code,L'\x01');
          if ((uint)(wVar5 == L'') == L'\0') {
            mouse_link = L'\xffffffff';
          }
          lac = LYmouse_menu(event.x,event.y,(uint)(wVar5 == L''),code);
          if (lac == L'(') {
            if (mouse_link == L'\xffffffff') {
              lac = L'\'';
            }
            else if ((((L'\xffffffff' < mouse_link) && (textfields_need_activation != '\0')) &&
                     (links[mouse_link].type == 1)) &&
                    ((((links[mouse_link].l_form)->type == 1 ||
                      ((links[mouse_link].l_form)->type == 0xc)) ||
                     (((links[mouse_link].l_form)->type == 2 ||
                      (((links[mouse_link].l_form)->type == 0xb ||
                       ((links[mouse_link].l_form)->type == 9)))))))) {
              lac = L'\'';
            }
          }
          if ((lac == L'\'') && (mouse_link == L'\xffffffff')) {
            Msg = (char *)gettext("No link chosen");
            HTAlert(Msg);
            lac = L'\x15';
          }
          iVar7 = LYReverseKeymap(lac);
          if (iVar7 < 0) {
            local_4c = lac | 0x800;
          }
          else {
            local_4c = LYReverseKeymap(lac);
          }
          c = local_4c;
        }
LAB_0805092b:
        if ((((code == L'\x02') && (mouse_link == L'\xffffffff')) && (lac != L'\x15')) &&
           (lac != L'(')) {
          ungetmouse(&event);
          wgetch(LYwin);
          c = L'';
        }
        if ((0x294 < c + L'\x01') && ((c & 0x800U) != 0)) {
          return c;
        }
switchD_08050400_caseD_108:
        if ((c & 0x8800U) != 0) {
          return c;
        }
        if (0x294 < c + L'\x01') {
          return L'\0';
        }
        return c | current_modifier;
      }
      break;
    case L'':
      if (WWW_TraceFlag != '\0') {
        iVar7 = (int)recent_sizechange;
        pFVar4 = TraceFP();
        fprintf((FILE *)pFVar4,"Got KEY_RESIZE, recent_sizechange so far is %d\n",iVar7);
      }
      size_change(L'\0');
      if (WWW_TraceFlag != '\0') {
        iVar7 = (int)recent_sizechange;
        pFVar4 = TraceFP();
        fprintf((FILE *)pFVar4,"Now recent_sizechange is %d\n",iVar7);
      }
      if (recent_sizechange != '\0') {
        c = L'';
        goto switchD_08050400_caseD_108;
      }
      recent_sizechange = '\x01';
      uVar1 = levent._0_4_;
    }
  } while( true );
}



// WARNING: Unknown calling convention

wchar_t LYgetch(void)

{
  wchar_t wVar1;
  
  wVar1 = LYReadCmdKey(L'\0');
  return wVar1;
}



// WARNING: Unknown calling convention

wchar_t LYgetch_choice(void)

{
  wchar_t ch;
  
  ch = LYReadCmdKey(L'\x01');
  if (ch == L'\x03') {
    ch = L'\a';
  }
  return ch;
}



// WARNING: Unknown calling convention

wchar_t LYgetch_input(void)

{
  wchar_t ch;
  
  ch = LYReadCmdKey(L'\x02');
  if (ch == L'\x03') {
    ch = L'\a';
  }
  return ch;
}



// WARNING: Unknown calling convention

wchar_t LYgetch_single(void)

{
  ushort **ppuVar1;
  wchar_t local_18;
  wchar_t ch;
  
  ch = LYReadCmdKey(L'\x04');
  if (ch == L'\x03') {
    ch = L'\a';
  }
  else if ((L'\0' < ch) && (ch < L'')) {
    ppuVar1 = __ctype_b_loc();
    if (((*ppuVar1)[ch & 0xff] & 0x200) == 0) {
      local_18 = ch & 0xff;
    }
    else {
      local_18 = toupper(ch & 0xff);
    }
    ch = local_18;
  }
  return ch;
}



// WARNING: Unknown calling convention

void LYLowerCase(char *arg_buffer)

{
  ushort **ppuVar1;
  int iVar2;
  char local_19;
  size_t i;
  
  for (i = 0; arg_buffer[i] != '\0'; i = i + 1) {
    if ((arg_buffer[i] < '\0') && (arg_buffer[i + 1] != '\0')) {
      if (((kanji_code != SJIS) || ((byte)arg_buffer[i] < 0xa1)) || (0xdf < (byte)arg_buffer[i])) {
        i = i + 1;
      }
    }
    else {
      ppuVar1 = __ctype_b_loc();
      if (((*ppuVar1)[(byte)arg_buffer[i]] & 0x100) == 0) {
        local_19 = arg_buffer[i];
      }
      else {
        iVar2 = tolower((uint)(byte)arg_buffer[i]);
        local_19 = (char)iVar2;
      }
      arg_buffer[i] = local_19;
    }
  }
  return;
}



// WARNING: Unknown calling convention

void LYUpperCase(char *arg_buffer)

{
  ushort **ppuVar1;
  int iVar2;
  char local_19;
  size_t i;
  
  for (i = 0; arg_buffer[i] != '\0'; i = i + 1) {
    if ((arg_buffer[i] < '\0') && (arg_buffer[i + 1] != '\0')) {
      if (((kanji_code != SJIS) || ((byte)arg_buffer[i] < 0xa1)) || (0xdf < (byte)arg_buffer[i])) {
        i = i + 1;
      }
    }
    else {
      ppuVar1 = __ctype_b_loc();
      if (((*ppuVar1)[(byte)arg_buffer[i]] & 0x200) == 0) {
        local_19 = arg_buffer[i];
      }
      else {
        iVar2 = toupper((uint)(byte)arg_buffer[i]);
        local_19 = (char)iVar2;
      }
      arg_buffer[i] = local_19;
    }
  }
  return;
}



// WARNING: Unknown calling convention

BOOLEAN LYRemoveNewlines(char *buffer)

{
  char *local_18;
  char *old;
  
  if (buffer != (char *)0x0) {
    for (local_18 = buffer; ((*local_18 != '\0' && (*local_18 != '\n')) && (*local_18 != '\r'));
        local_18 = local_18 + 1) {
    }
    if (*local_18 != '\0') {
      for (old = local_18; *old != '\0'; old = old + 1) {
        if ((*old != '\n') && (*old != '\r')) {
          *local_18 = *old;
          local_18 = local_18 + 1;
        }
      }
      *local_18 = '\0';
      return '\x01';
    }
  }
  return '\0';
}



// WARNING: Unknown calling convention

char * LYReduceBlanks(char *buffer)

{
  if ((buffer != (char *)0x0) && (*buffer != '\0')) {
    LYTrimLeading(buffer);
    LYTrimTrailing(buffer);
    convert_to_spaces(buffer,'\x01');
  }
  return buffer;
}



// WARNING: Unknown calling convention

char * LYRemoveBlanks(char *buffer)

{
  ushort **ppuVar1;
  byte *local_1c;
  byte *local_18;
  char *old;
  
  if (buffer == (char *)0x0) {
    local_1c = (byte *)0x0;
  }
  else {
    for (local_18 = (byte *)buffer; *local_18 != 0; local_18 = local_18 + 1) {
      ppuVar1 = __ctype_b_loc();
      if (((*ppuVar1)[*local_18] & 0x2000) != 0) break;
    }
    if (*local_18 != 0) {
      for (old = (char *)local_18; *old != '\0'; old = old + 1) {
        ppuVar1 = __ctype_b_loc();
        if (((*ppuVar1)[(byte)*old] & 0x2000) == 0) {
          *local_18 = *old;
          local_18 = local_18 + 1;
        }
      }
      *local_18 = 0;
    }
    local_1c = local_18;
  }
  return (char *)local_1c;
}



// WARNING: Unknown calling convention

char * LYSkipBlanks(char *buffer)

{
  ushort **ppuVar1;
  
  while( true ) {
    ppuVar1 = __ctype_b_loc();
    if (((*ppuVar1)[(byte)*buffer] & 0x2000) == 0) break;
    buffer = buffer + 1;
  }
  return buffer;
}



// WARNING: Unknown calling convention

char * LYSkipNonBlanks(char *buffer)

{
  ushort **ppuVar1;
  
  while( true ) {
    if (*buffer == '\0') {
      return buffer;
    }
    ppuVar1 = __ctype_b_loc();
    if (((*ppuVar1)[(byte)*buffer] & 0x2000) != 0) break;
    buffer = buffer + 1;
  }
  return buffer;
}



// WARNING: Unknown calling convention

char * LYSkipCBlanks(char *buffer)

{
  ushort **ppuVar1;
  
  while( true ) {
    ppuVar1 = __ctype_b_loc();
    if (((*ppuVar1)[(byte)*buffer] & 0x2000) == 0) break;
    buffer = buffer + 1;
  }
  return buffer;
}



// WARNING: Unknown calling convention

char * LYSkipCNonBlanks(char *buffer)

{
  ushort **ppuVar1;
  
  while( true ) {
    if (*buffer == '\0') {
      return buffer;
    }
    ppuVar1 = __ctype_b_loc();
    if (((*ppuVar1)[(byte)*buffer] & 0x2000) != 0) break;
    buffer = buffer + 1;
  }
  return buffer;
}



// WARNING: Unknown calling convention

void LYTrimLeading(char *buffer)

{
  char cVar1;
  char *skipped;
  
  skipped = LYSkipBlanks(buffer);
  do {
    *buffer = *skipped;
    cVar1 = *buffer;
    buffer = buffer + 1;
    skipped = skipped + 1;
  } while (cVar1 != '\0');
  return;
}



// WARNING: Unknown calling convention

char * LYTrimNewline(char *buffer)

{
  size_t i;
  
  i = strlen(buffer);
  while ((i != 0 && ((buffer[i - 1] == '\n' || (buffer[i - 1] == '\r'))))) {
    i = i - 1;
    buffer[i] = '\0';
  }
  return buffer;
}



// WARNING: Unknown calling convention

void LYTrimTrailing(char *buffer)

{
  ushort **ppuVar1;
  size_t i;
  
  i = strlen(buffer);
  while( true ) {
    if (i == 0) {
      return;
    }
    ppuVar1 = __ctype_b_loc();
    if (((*ppuVar1)[(byte)buffer[i - 1]] & 0x2000) == 0) break;
    i = i - 1;
    buffer[i] = '\0';
  }
  return;
}



char * LYElideString(char *str,wchar_t cut_pos)

{
  char cVar1;
  size_t sVar2;
  int in_GS_OFFSET;
  char *str_local;
  wchar_t len;
  char *d;
  char *s;
  char buff [1024];
  int local_c;
  
  local_c = *(int *)(in_GS_OFFSET + 0x14);
  LYstrncpy(buff,str,L'');
  sVar2 = strlen(buff);
  if ((int)((LYcols - (uint)(LYShowScrollbar != '\0')) + -9) < (int)sVar2) {
    buff[cut_pos] = '.';
    buff[cut_pos + L'\x01'] = '.';
    s = buff + sVar2 + ((uint)(LYShowScrollbar != '\0') - LYcols) + cut_pos + 10;
    d = buff + cut_pos + L'\x02';
    do {
      if (((s < buff) || (d < buff)) || (buff + LYcols <= d)) break;
      *d = *s;
      cVar1 = *d;
      d = d + 1;
      s = s + 1;
    } while (cVar1 != '\0');
    buff[LYcols] = '\0';
  }
  strcpy(LYElideString::s_str,buff);
  if (local_c != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return LYElideString::s_str;
}



// WARNING: Unknown calling convention

BOOLEAN LYTrimStartfile(char *buffer)

{
  int iVar1;
  BOOLEAN local_5;
  
  LYTrimHead(buffer);
  if ((*buffer == 'l') || (*buffer == 'L')) {
    iVar1 = strncasecomp(buffer,"lynxexec:",9);
    if (iVar1 != 0) goto LAB_0805116c;
LAB_0805119f:
    HTUnEscapeSome(buffer," \r\n\t");
    convert_to_spaces(buffer,'\x01');
    local_5 = '\x01';
  }
  else {
LAB_0805116c:
    if ((*buffer == 'l') || (*buffer == 'L')) {
      iVar1 = strncasecomp(buffer,"lynxprog:",9);
      if (iVar1 == 0) goto LAB_0805119f;
    }
    local_5 = '\0';
  }
  return local_5;
}



// WARNING: Unknown calling convention

void LYEscapeStartfile(char **buffer)

{
  BOOLEAN BVar1;
  char *src;
  char *escaped;
  
  BVar1 = LYTrimStartfile(*buffer);
  if (BVar1 == '\0') {
    src = HTEscapeUnsafe(*buffer);
    HTSACopy(buffer,src);
    if (src != (char *)0x0) {
      free(src);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void LYTrimAllStartfile(char *buffer)

{
  BOOLEAN BVar1;
  
  BVar1 = LYTrimStartfile(buffer);
  if (BVar1 == '\0') {
    LYRemoveBlanks(buffer);
  }
  return;
}



// WARNING: Unknown calling convention

void LYSetupEdit(EditFieldData *edit,char *old,wchar_t maxstr,wchar_t maxdsp)

{
  wchar_t wVar1;
  wchar_t local_c;
  wchar_t local_8;
  
  if (LYwin == (WINDOW *)0x0) {
    local_c = L'\xffffffff';
  }
  else {
    local_c = (wchar_t)LYwin->_cury;
  }
  edit->sy = local_c;
  if (LYwin == (WINDOW *)0x0) {
    local_8 = L'\xffffffff';
  }
  else {
    local_8 = (wchar_t)LYwin->_curx;
  }
  edit->sx = local_8;
  edit->pad = ' ';
  edit->dirty = '\x01';
  edit->panon = '\0';
  edit->current_modifiers = L'\0';
  edit->maxlen = maxstr;
  edit->dspwdth = maxdsp;
  edit->margin = L'\0';
  wVar1 = strlen(old);
  edit->pos = wVar1;
  edit->mark = L'\xffffffff';
  edit->xpan = L'\0';
  if (maxdsp < maxstr) {
    if (L'\x04' < edit->dspwdth) {
      edit->panon = '\x01';
    }
    edit->margin = ((uint)(edit->dspwdth >> 0x1f) >> 0x1e) + edit->dspwdth >> 2;
    if (L'\n' < edit->margin) {
      edit->margin = L'\n';
    }
  }
  LYstrncpy(edit->buffer,old,maxstr);
  wVar1 = strlen(edit->buffer);
  edit->strlen = wVar1;
  return;
}



// WARNING: Unknown calling convention

wchar_t mbcs_glyphs(char *s,wchar_t len)

{
  wchar_t i;
  wchar_t glyphs;
  
  glyphs = L'\0';
  if (LYCharSet_UC[current_char_set].enc == 7) {
    for (i = L'\0'; (s[i] != '\0' && (i < len)); i = i + L'\x01') {
      if ((s[i] & 0xc0U) != 0x80) {
        glyphs = glyphs + L'\x01';
      }
    }
  }
  else if (HTCJK == NOCJK) {
    glyphs = len;
  }
  else {
    for (i = L'\0'; (s[i] != '\0' && (i < len)); i = i + L'\x01') {
      if (s[i] < '\0') {
        i = i + L'\x01';
      }
      glyphs = glyphs + L'\x01';
    }
  }
  return glyphs;
}



// WARNING: Unknown calling convention

wchar_t mbcs_skip(char *s,wchar_t pos)

{
  wchar_t i;
  wchar_t p;
  
  if (LYCharSet_UC[current_char_set].enc == 7) {
    p = L'\0';
    for (i = L'\0'; s[i] != '\0'; i = i + L'\x01') {
      if ((s[i] & 0xc0U) != 0x80) {
        p = p + L'\x01';
      }
      if (pos < p) {
        return i;
      }
    }
  }
  else if (HTCJK == NOCJK) {
    i = pos;
  }
  else {
    i = L'\0';
    for (p = L'\0'; (s[i] != '\0' && (p < pos)); p = p + L'\x01') {
      if (s[i] < '\0') {
        i = i + L'\x01';
      }
      i = i + L'\x01';
    }
  }
  return i;
}



// WARNING: Unknown calling convention

wchar_t cell2char(char *s,wchar_t cells)

{
  wchar_t wVar1;
  wchar_t wVar2;
  wchar_t have;
  wchar_t pos;
  wchar_t len;
  wchar_t result;
  
  wVar1 = strlen(s);
  for (pos = L'\0'; pos <= wVar1; pos = pos + L'\x01') {
    wVar2 = LYstrExtent2(s,pos);
    if (cells <= wVar2) break;
  }
  if (wVar1 < pos) {
    pos = wVar1;
  }
  wVar1 = mbcs_glyphs(s,pos);
  return wVar1;
}



wchar_t LYEditInsert(EditFieldData *edit,uchar *s,wchar_t len,wchar_t map,BOOLEAN maxMessage)

{
  bool bVar1;
  char *text;
  BOOLEAN maxMessage_local;
  wchar_t overflow;
  wchar_t edited;
  wchar_t remains;
  wchar_t length;
  
  length = strlen(edit->buffer);
  edited = L'\0';
  bVar1 = false;
  if (edit->maxlen - (length + len) < 0) {
    bVar1 = true;
    len = L'\0';
    if (edit->maxlen <= length) goto finish;
    len = edit->maxlen - length;
  }
  edit->buffer[length + len] = '\0';
  for (; edit->pos <= length; length = length + L'\xffffffff') {
    edit->buffer[length + len] = edit->buffer[length];
  }
  strncpy(edit->buffer + edit->pos,(char *)s,len);
  edited = L'\x01';
finish:
  edit->pos = edit->pos + len;
  edit->strlen = edit->strlen + len;
  if (edited != L'\0') {
    edit->dirty = '\x01';
  }
  if ((bVar1) && (maxMessage != '\0')) {
    mustshow = '\x01';
    text = (char *)gettext("Maximum length reached!  Delete text or move off field.");
    statusline(text);
  }
  if (edit->pos < edit->mark) {
    edit->mark = edit->mark + len;
  }
  else if (edit->mark < ~edit->pos) {
    edit->mark = edit->mark - len;
  }
  if (L'\xffffffff' < edit->mark) {
    edit->mark = ~edit->mark;
  }
  return edited;
}



wchar_t LYEdit1(EditFieldData *edit,wchar_t ch,wchar_t action,BOOLEAN maxMessage)

{
  char cVar1;
  wchar_t wVar2;
  ushort **ppuVar3;
  wchar_t wVar4;
  wchar_t wVar5;
  char *pcVar6;
  int iVar7;
  wchar_t local_30;
  BOOLEAN maxMessage_local;
  wchar_t yanklen;
  wchar_t reglen;
  wchar_t offset;
  wchar_t length;
  wchar_t i;
  uchar uch;
  
  if (edit->maxlen < L'\x01') {
    return L'\0';
  }
  wVar2 = strlen(edit->buffer);
  edit->strlen = wVar2;
  i = wVar2;
  switch(action) {
  default:
    return ch;
  case L'\x01':
    uch = (uchar)ch;
    LYEditInsert(edit,&uch,L'\x01',L'\0',maxMessage);
    return L'\0';
  case L'\a':
    if (wVar2 <= edit->pos) break;
    wVar5 = edit->pos;
    wVar4 = mbcs_skip(edit->buffer + edit->pos,L'\x01');
    edit->pos = wVar5 + wVar4;
  case L'\t':
    if ((wVar2 != L'\0') && (edit->pos != L'\0')) {
      wVar5 = edit->pos;
      wVar4 = mbcs_glyphs(edit->buffer,edit->pos);
      wVar4 = mbcs_skip(edit->buffer,wVar4 + L'\xffffffff');
      iVar7 = wVar5 - wVar4;
      edit->pos = edit->pos - iVar7;
      for (i = edit->pos; i < (wVar2 - iVar7) + L'\x01'; i = i + L'\x01') {
        edit->buffer[i] = *(char *)((int)edit + i + iVar7 + 0x2c);
      }
      if (L'\xffffffff' < edit->mark) {
        edit->mark = ~edit->mark;
      }
      if (edit->mark <= ~edit->pos) {
        edit->mark = edit->mark + iVar7;
      }
    }
    break;
  case L'\n':
    wVar5 = edit->pos;
    LYEdit1(edit,L'\0',L'\x13','\0');
    offset = edit->pos - wVar5;
    edit->pos = edit->pos - offset;
    goto shrink;
  case L'\v':
    wVar5 = edit->pos;
    LYEdit1(edit,L'\0',L'\x14','\0');
    offset = wVar5 - edit->pos;
shrink:
    for (i = edit->pos; i < (wVar2 - offset) + L'\x01'; i = i + L'\x01') {
      edit->buffer[i] = edit->buffer[i + offset];
    }
    if (L'\xffffffff' < edit->mark) {
      edit->mark = ~edit->mark;
    }
    if (edit->mark <= ~edit->pos - offset) {
      edit->mark = edit->mark + offset;
    }
    if ((~edit->pos - offset < edit->mark) && (edit->mark < ~edit->pos)) {
      edit->mark = ~edit->pos;
    }
    break;
  case L'\f':
    edit->buffer[0] = '\0';
    edit->mark = L'\xffffffff';
  case L'\r':
    edit->pos = L'\0';
    break;
  case L'\x0e':
    edit->pos = wVar2;
    break;
  case L'\x0f':
  case L'\x10':
    if (edit->pos < wVar2) {
      wVar2 = edit->pos;
      wVar5 = mbcs_skip(edit->buffer + edit->pos,L'\x01');
      edit->pos = wVar2 + wVar5;
    }
    else if (action == L'\x10') {
      return -ch;
    }
    break;
  case L'\x11':
  case L'\x12':
    if (edit->pos < L'\x01') {
      if (action == L'\x12') {
        return -ch;
      }
    }
    else {
      wVar2 = mbcs_glyphs(edit->buffer,edit->pos);
      wVar2 = mbcs_skip(edit->buffer,wVar2 + L'\xffffffff');
      edit->pos = wVar2;
    }
    break;
  case L'\x13':
    while ((ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[(byte)edit->buffer[edit->pos]] & 8) != 0 ||
           (edit->buffer[edit->pos] < '\0'))) {
      edit->pos = edit->pos + L'\x01';
    }
    while (((ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[(byte)edit->buffer[edit->pos]] & 8) == 0 &&
            (-1 < edit->buffer[edit->pos])) && (edit->buffer[edit->pos] != '\0'))) {
      edit->pos = edit->pos + L'\x01';
    }
    break;
  case L'\x14':
    while (((edit->pos != L'\0' &&
            (ppuVar3 = __ctype_b_loc(),
            ((*ppuVar3)[(byte)edit->buffer[edit->pos + L'\xffffffff']] & 8) == 0)) &&
           (-1 < edit->buffer[edit->pos + L'\xffffffff']))) {
      edit->pos = edit->pos + L'\xffffffff';
    }
    while ((edit->pos != L'\0' &&
           ((ppuVar3 = __ctype_b_loc(),
            ((*ppuVar3)[(byte)edit->buffer[edit->pos + L'\xffffffff']] & 8) != 0 ||
            (edit->buffer[edit->pos + L'\xffffffff'] < '\0'))))) {
      edit->pos = edit->pos + L'\xffffffff';
    }
    break;
  case L'\x15':
    LYLowerCase(edit->buffer);
    break;
  case L'\x16':
    LYUpperCase(edit->buffer);
    break;
  case L'\x19':
    for (i = edit->pos; i < wVar2 + L'\x01'; i = i + L'\x01') {
      *(char *)((int)edit + (i - edit->pos) + 0x2c) = edit->buffer[i];
    }
    if (L'\xffffffff' < edit->mark) {
      edit->mark = ~edit->mark;
    }
    if (~edit->pos < edit->mark) {
      edit->mark = L'\xffffffff';
    }
    else {
      edit->mark = edit->mark + edit->pos;
    }
    edit->pos = L'\0';
    break;
  case L'\x1a':
    edit->buffer[edit->pos] = '\0';
    if (L'\xffffffff' < edit->mark) {
      edit->mark = ~edit->mark;
    }
    if (edit->mark <= ~edit->pos) {
      edit->mark = L'\xffffffff';
    }
    break;
  case L'\x1c':
    if ((LYCharSet_UC[current_char_set].enc != 7) && (HTCJK == NOCJK)) {
      if ((wVar2 < L'\x02') || (edit->pos == L'\0')) {
        return ch;
      }
      if (edit->pos == wVar2) {
        edit->pos = edit->pos + L'\xffffffff';
      }
      if (edit->mark < L'\0') {
        edit->mark = ~edit->mark;
      }
      if ((edit->mark == edit->pos) || (edit->mark == edit->pos + L'\x01')) {
        edit->mark = edit->pos + L'\xffffffff';
      }
      if (L'\xffffffff' < edit->mark) {
        edit->mark = ~edit->mark;
      }
      if (edit->buffer[edit->pos + L'\xffffffff'] == edit->buffer[edit->pos]) {
        edit->pos = edit->pos + L'\x01';
      }
      else {
        cVar1 = edit->buffer[edit->pos + L'\xffffffff'];
        edit->buffer[edit->pos + L'\xffffffff'] = edit->buffer[edit->pos];
        wVar2 = edit->pos;
        edit->buffer[wVar2] = cVar1;
        edit->pos = wVar2 + L'\x01';
      }
    }
    break;
  case L' ':
    ch = ch & 0xff;
    if (LYlowest_eightbit[current_char_set] <= ch + L'@') {
      ch = ch + L'@';
    }
    if ((edit->maxlen < edit->pos) || (edit->maxlen <= edit->strlen)) {
      if (maxMessage != '\0') {
        mustshow = '\x01';
        pcVar6 = (char *)gettext("Maximum length reached!  Delete text or move off field.");
        statusline(pcVar6);
      }
      return ch;
    }
    if (edit->pos < edit->mark) {
      edit->mark = edit->mark + L'\x01';
    }
    else if (edit->mark < ~edit->pos) {
      edit->mark = edit->mark + L'\xffffffff';
    }
    if (L'\xffffffff' < edit->mark) {
      edit->mark = ~edit->mark;
    }
    for (; edit->pos <= i; i = i + L'\xffffffff') {
      edit->buffer[i + L'\x01'] = edit->buffer[i];
    }
    edit->buffer[wVar2 + L'\x01'] = '\0';
    edit->buffer[edit->pos] = (char)ch;
    edit->pos = edit->pos + L'\x01';
    break;
  case L'!':
    edit->mark = edit->pos;
    return L'\0';
  case L'\"':
    if (edit->mark < L'\0') {
      edit->mark = ~edit->mark;
    }
    if (edit->mark == edit->pos) {
      return L'\0';
    }
    wVar2 = edit->pos;
    edit->pos = edit->mark;
    edit->mark = wVar2;
    break;
  case L'#':
    if (edit->mark < L'\0') {
      edit->mark = ~edit->mark;
    }
    if (edit->mark == edit->pos) {
      killbuffer[0] = '\0';
      return L'\0';
    }
    if (edit->pos < edit->mark) {
      LYEdit1(edit,L'\0',L'\"','\0');
    }
    wVar2 = edit->pos - edit->mark;
    local_30 = wVar2;
    if (L'' < wVar2) {
      local_30 = L'';
    }
    LYstrncpy(killbuffer,edit->buffer + edit->mark,local_30);
    i = edit->mark;
    while (*(char *)((int)edit + i + wVar2 + 0x2c) != '\0') {
      edit->buffer[i] = *(char *)((int)edit + i + wVar2 + 0x2c);
      i = i + L'\x01';
    }
    edit->buffer[i] = *(char *)((int)edit + i + wVar2 + 0x2c);
    edit->pos = edit->mark;
    if (L'\xffffffff' < edit->mark) {
      edit->mark = ~edit->mark;
    }
    break;
  case L'$':
    if (killbuffer[0] == '\0') {
      edit->mark = ~edit->pos;
      return L'\0';
    }
    wVar2 = strlen(killbuffer);
    if ((edit->maxlen < edit->pos + wVar2) || (edit->maxlen < edit->strlen + wVar2)) {
      if (maxMessage != '\0') {
        mustshow = '\x01';
        pcVar6 = (char *)gettext("Maximum length reached!  Delete text or move off field.");
        statusline(pcVar6);
      }
    }
    else {
      edit->mark = ~edit->pos;
      for (; edit->pos <= i; i = i + L'\xffffffff') {
        edit->buffer[i + wVar2] = edit->buffer[i];
      }
      for (i = L'\0'; i < wVar2; i = i + L'\x01') {
        wVar5 = edit->pos;
        edit->buffer[wVar5] = killbuffer[i];
        edit->pos = wVar5 + L'\x01';
      }
    }
  }
  edit->dirty = '\x01';
  wVar2 = strlen(edit->buffer);
  edit->strlen = wVar2;
  return L'\0';
}



wchar_t get_popup_number(char *msg,wchar_t *c,wchar_t *rel)

{
  int iVar1;
  char cVar2;
  wchar_t wVar3;
  char *Msg;
  ushort **ppuVar4;
  int in_GS_OFFSET;
  wchar_t local_a8;
  wchar_t *rel_local;
  wchar_t *c_local;
  char *msg_local;
  wchar_t num;
  char *p;
  char temp [120];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  p = temp;
  temp[0] = (char)*c;
  temp[1] = '\0';
  mustshow = '\x01';
  statusline(msg);
  wVar3 = LYgetstr(temp,L'\0',0x78,NORECALL);
  if ((wVar3 < L'\0') || (temp[0] == '\0')) {
    Msg = (char *)gettext("Cancelled!!!");
    HTInfoMsg(Msg);
    *c = L'\0';
    *rel = L'\0';
    local_a8 = L'\0';
  }
  else {
    *rel = L'\0';
    local_a8 = atoi(p);
    while (ppuVar4 = __ctype_b_loc(), ((*ppuVar4)[(byte)*p] & 0x800) != 0) {
      p = p + 1;
    }
    cVar2 = *p;
    if ((cVar2 == '+') || (cVar2 == '-')) {
      *rel = (int)*p;
      p = p + 1;
      *c = (int)*p;
    }
    else if (cVar2 != '\0') {
      *c = (int)*p;
      p = p + 1;
      *rel = (int)*p;
    }
    if ((*p == 'g') || (*p == 'G')) {
      *c = L'g';
    }
    else if ((*p == 'p') || (*p == 'P')) {
      *c = L'p';
    }
    else {
      *c = L'\0';
    }
    if ((*rel != L'+') && (*rel != L'-')) {
      *rel = L'\0';
    }
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return local_a8;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void remember_column(EditFieldData *edit,wchar_t offset)

{
  wchar_t local_18;
  wchar_t x0;
  wchar_t y0;
  
  if (LYwin == (WINDOW *)0x0) {
    local_18 = L'\xffffffff';
  }
  else {
    local_18 = (wchar_t)LYwin->_curx;
  }
  edit->offset2col[offset] = local_18;
  return;
}



// WARNING: Unknown calling convention

void fill_edited_line(wchar_t prompting,wchar_t length,wchar_t ch)

{
  wchar_t local_1c;
  wchar_t local_18;
  wchar_t i;
  
  if (prompting == L'\0') {
    local_1c = s_aedit_pad;
  }
  else {
    local_1c = s_prompt_edit_pad;
  }
  curses_style(local_1c,L'\x01');
  for (i = L'\0'; i < length; i = i + L'\x01') {
    waddch(LYwin,ch & 0xff);
  }
  if (prompting == L'\0') {
    local_18 = s_aedit_pad;
  }
  else {
    local_18 = s_prompt_edit_pad;
  }
  curses_style(local_18,L'\0');
  return;
}



// WARNING: Removing unreachable block (ram,0x080527bc)
// WARNING: Removing unreachable block (ram,0x0805281f)
// WARNING: Unknown calling convention

void LYRefreshEdit(EditFieldData *edit)

{
  char *s;
  int iVar1;
  bool bVar2;
  wchar_t wVar3;
  wchar_t wVar4;
  wchar_t wVar5;
  FILE *pFVar6;
  char *data;
  char *pcVar7;
  char *local_94;
  wchar_t local_90;
  wchar_t local_8c;
  wchar_t local_88;
  wchar_t local_84;
  wchar_t local_80;
  wchar_t local_7c;
  wchar_t col;
  wchar_t j;
  char *next;
  char *last;
  wchar_t cell;
  wchar_t old_cells;
  wchar_t prompting;
  wchar_t estyle;
  wchar_t rgt_shift;
  wchar_t lft_shift;
  char *str;
  wchar_t padsize;
  wchar_t i;
  wchar_t pos_chars;
  wchar_t lft_chars;
  wchar_t dpy_chars;
  wchar_t all_chars;
  wchar_t pos_cells;
  wchar_t lft_cells;
  wchar_t dpy_cells;
  wchar_t all_cells;
  wchar_t lft_bytes;
  wchar_t dpy_bytes;
  wchar_t pos_bytes;
  wchar_t all_bytes;
  BOOLEAN utf_flag;
  
  lft_shift = L'\0';
  bVar2 = false;
  if ((edit->dirty != '\0') && (edit->dspwdth != L'\0')) {
    edit->dirty = '\0';
    wVar3 = strlen(edit->buffer);
    edit->strlen = wVar3;
    wVar4 = LYstrCells(edit->buffer);
    wVar5 = LYstrExtent2(edit->buffer,edit->pos);
    mbcs_glyphs(edit->buffer,edit->xpan);
    mbcs_glyphs(edit->buffer,edit->pos);
    mbcs_glyphs(edit->buffer,wVar3);
    lft_bytes = edit->xpan;
    lft_cells = LYstrExtent2(edit->buffer,edit->xpan);
    if ((edit->dspwdth + lft_cells <= wVar4) &&
       ((edit->dspwdth + lft_cells) - edit->margin <= wVar5)) {
      lft_cells = (wVar5 - edit->dspwdth) + edit->margin;
      wVar3 = cell2char(edit->buffer,lft_cells);
      lft_bytes = mbcs_skip(edit->buffer,wVar3);
    }
    if (wVar5 < edit->margin + lft_cells) {
      lft_cells = wVar5 - edit->margin;
      if (lft_cells < L'\0') {
        lft_cells = L'\0';
      }
      wVar3 = cell2char(edit->buffer,lft_cells);
      lft_bytes = mbcs_skip(edit->buffer,wVar3);
    }
    LYmove(edit->sy,edit->sx);
    if ((edit->panon != '\0') && (lft_cells != L'\0')) {
      curses_style(s_aedit_arr,L'\x01');
      LYmove(edit->sy,edit->sx);
      waddch(LYwin,acs_map._176_4_);
      curses_style(s_aedit_arr,L'\0');
      lft_shift = L'\x01';
    }
    s = edit->buffer + lft_bytes;
    edit->xpan = lft_bytes;
    dpy_cells = wVar4 - lft_cells;
    if (edit->dspwdth - lft_shift < dpy_cells) {
      bVar2 = true;
      dpy_cells = (edit->dspwdth - lft_shift) + L'\xffffffff';
    }
    do {
      wVar3 = dpy_cells;
      wVar4 = cell2char(s,dpy_cells);
      wVar4 = mbcs_skip(s,wVar4);
      if (!bVar2) break;
      wVar5 = LYstrExtent2(s,wVar4);
      if (dpy_cells < wVar5) {
        wVar5 = dpy_cells + L'\xffffffff';
      }
      dpy_cells = wVar5;
    } while (dpy_cells < wVar3);
    prompting = (wchar_t)(edit->sy == LYlines + L'\xffffffff');
    if (prompting == L'\0') {
      estyle = s_aedit;
    }
    else {
      estyle = s_prompt_edit;
    }
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
      if (prompting == L'\0') {
        local_94 = "active";
      }
      else {
        local_94 = "prompt";
      }
      pFVar6 = TraceFP();
      fprintf((FILE *)pFVar6,"STYLE.getstr: switching to <edit.%s>.\n",local_94);
    }
    if (estyle == L'\xffffffff') {
      LYwin->_attrs = 0;
    }
    else {
      curses_style(estyle,L'\x01');
    }
    if (edit->hidden == '\0') {
      if ((L'\xffffffff' < edit->mark) && (edit->mark < edit->xpan)) {
        if (prompting == L'\0') {
          local_90 = s_aedit_sel;
        }
        else {
          local_90 = s_prompt_sel;
        }
        curses_style(local_90,L'\x01');
      }
      remember_column(edit,L'\0');
      for (i = L'\0'; i < wVar4; i = i + L'\x01') {
        if ((L'\xffffffff' < edit->mark) &&
           (((edit->xpan + i == edit->mark && (edit->mark < edit->pos)) ||
            ((edit->xpan + i == edit->pos && (edit->pos < edit->mark)))))) {
          if (prompting == L'\0') {
            local_8c = s_aedit_sel;
          }
          else {
            local_8c = s_prompt_sel;
          }
          curses_style(local_8c,L'\x01');
        }
        if ((L'\xffffffff' < edit->mark) &&
           (((edit->xpan + i == edit->mark && (edit->pos < edit->mark)) ||
            ((edit->xpan + i == edit->pos && (edit->mark < edit->pos)))))) {
          if (prompting == L'\0') {
            local_88 = s_aedit_sel;
          }
          else {
            local_88 = s_prompt_sel;
          }
          curses_style(local_88,L'\0');
        }
        if (((s[i] == '\x01') || (s[i] == '\x02')) ||
           (((s[i] == -0x60 && ((HTPassHighCtrlRaw == '\0' && (HTCJK == NOCJK)))) &&
            ((LYCharSet_UC[current_char_set].enc == 2 ||
             ((LYCharSet_UC[current_char_set].like8859 & 0x80U) != 0)))))) {
          waddch(LYwin,0x20);
        }
        else if (s[i] == '\t') {
          col = edit->offset2col[i] - edit->sx;
          while (col = col + L'\x01', (col & 7U) != 0) {
            waddch(LYwin,0x20);
          }
          waddch(LYwin,0x20);
        }
        else {
          waddch(LYwin,s[i]);
        }
        remember_column(edit,i + L'\x01');
      }
      if ((L'\xffffffff' < edit->mark) &&
         (((edit->xpan + wVar4 <= edit->mark && (edit->pos < edit->xpan + wVar4)) ||
          ((edit->mark < edit->xpan + wVar4 && (edit->xpan + wVar4 <= edit->pos)))))) {
        if (prompting == L'\0') {
          local_84 = s_aedit_sel;
        }
        else {
          local_84 = s_prompt_sel;
        }
        curses_style(local_84,L'\0');
      }
    }
    else {
      iVar1 = LYCharSet_UC[current_char_set].enc;
      cell = L'\0';
      fill_edited_line(L'\0',dpy_cells,L'*');
      i = L'\0';
      do {
        data = s + i;
        pcVar7 = LYmbcs_skip_glyphs(data,L'\x01',iVar1 == 7);
        for (; i < (int)pcVar7 - (int)s; i = i + L'\x01') {
          edit->offset2col[i] = edit->sx + cell;
        }
        wVar3 = LYstrExtent2(data,(int)pcVar7 - (int)data);
        cell = cell + wVar3;
      } while (i < wVar4);
      edit->offset2col[i] = edit->sx + cell;
    }
    fill_edited_line(prompting,edit->dspwdth + (edit->sx - edit->offset2col[wVar4]),(int)edit->pad);
    if (((edit->panon != '\0') && (wVar4 != L'\0')) && (bVar2)) {
      if (WWW_TraceFlag != '\0') {
        pFVar6 = TraceFP();
        fprintf((FILE *)pFVar6,"Draw right-scroller offset (%d + %d)\n",dpy_cells,lft_shift);
      }
      if (prompting == L'\0') {
        local_80 = s_aedit_arr;
      }
      else {
        local_80 = s_prompt_edit_arr;
      }
      curses_style(local_80,L'\x01');
      LYmove(edit->sy,edit->sx + dpy_cells + lft_shift);
      waddch(LYwin,acs_map._172_4_);
      if (prompting == L'\0') {
        local_7c = s_aedit_arr;
      }
      else {
        local_7c = s_prompt_edit_arr;
      }
      curses_style(local_7c,L'\0');
    }
    LYmove(edit->sy,*(wchar_t *)((int)edit + ((edit->pos - edit->xpan) + 0x108) * 4 + 0xc));
    if (estyle != L'\xffffffff') {
      curses_style(estyle,L'\0');
    }
    LYrefresh();
  }
  return;
}



// WARNING: Unknown calling convention

void reinsertEdit(EditFieldData *edit,char *result)

{
  uint uVar1;
  
  if (result != (char *)0x0) {
    LYEdit1(edit,L'\0',L'\f','\0');
    for (; *result != '\0'; result = result + 1) {
      uVar1 = EditBinding((int)*result);
      LYEdit1(edit,(int)*result,uVar1 & 0xffffff7f,'\0');
    }
  }
  return;
}



// WARNING: Unknown calling convention

wchar_t caselessCmpList(void *a,void *b)

{
  wchar_t wVar1;
  
                    // WARNING: Load size is inaccurate
                    // WARNING: Load size is inaccurate
  wVar1 = strcasecomp(*a,*b);
  return wVar1;
}



// WARNING: Unknown calling convention

wchar_t normalCmpList(void *a,void *b)

{
  wchar_t wVar1;
  
                    // WARNING: Load size is inaccurate
                    // WARNING: Load size is inaccurate
  wVar1 = strcmp(*a,*b);
  return wVar1;
}



char ** sortedList(HTList *list,BOOLEAN ignorecase)

{
  uint __nmemb;
  char **__base;
  int iVar1;
  char *local_30;
  code *local_2c;
  BOOLEAN ignorecase_local;
  char **result;
  uint jk;
  uint k;
  uint j;
  uint count;
  
  __nmemb = HTList_count(list);
  j = 0;
  __base = (char **)calloc(__nmemb + 1,4);
  if (__base == (char **)0x0) {
    outofmem("./LYStrings.c","sortedList");
  }
  while ((list != (HTList *)0x0 && (list->next != (HTList *)0x0))) {
    if ((list == (HTList *)0x0) || (list = list->next, list == (HTList *)0x0)) {
      local_30 = (char *)0x0;
    }
    else {
      local_30 = (char *)list->object;
    }
    __base[j] = local_30;
    j = j + 1;
  }
  if (1 < __nmemb) {
    if (ignorecase == '\0') {
      local_2c = normalCmpList;
    }
    else {
      local_2c = caselessCmpList;
    }
    qsort(__base,__nmemb,4,local_2c);
    for (j = 0; __base[j] != (char *)0x0; j = j + 1) {
      for (k = j; __base[k] != (char *)0x0; k = k + 1) {
        iVar1 = strcmp(__base[j],__base[k]);
        if (iVar1 != 0) break;
      }
      if (j != k - 1) {
        for (jk = j; __base[jk] = __base[(jk + (k - 1)) - j], __base[jk] != (char *)0x0; jk = jk + 1
            ) {
        }
      }
    }
  }
  return __base;
}



// WARNING: Unknown calling convention

wchar_t LYarrayLength(char **list)

{
  char *pcVar1;
  wchar_t result;
  
  result = L'\0';
  while (pcVar1 = *list, list = list + 1, pcVar1 != (char *)0x0) {
    result = result + L'\x01';
  }
  return result;
}



// WARNING: Unknown calling convention

wchar_t LYarrayWidth(char **list)

{
  char *__s;
  wchar_t wVar1;
  wchar_t check;
  wchar_t result;
  
  result = L'\0';
  while (*list != (char *)0x0) {
    __s = *list;
    list = list + 1;
    wVar1 = strlen(__s);
    if (result < wVar1) {
      result = wVar1;
    }
  }
  return result;
}



// WARNING: Unknown calling convention

void FormatChoiceNum(char *dst,wchar_t num_choices,wchar_t choice,char *value)

{
  int local_18;
  wchar_t digits;
  
  if (num_choices < L'\0') {
    LYstrncpy(dst,value,L'');
  }
  else {
    if (num_choices < L'\n') {
      local_18 = 1;
    }
    else {
      local_18 = 2;
    }
    sprintf(dst,"%*d: %.*s",local_18,choice + L'\x01',0x3f7 - local_18,value);
  }
  return;
}



// WARNING: Unknown calling convention

uint options_width(char **list)

{
  size_t sVar1;
  wchar_t count;
  uint width;
  
  width = 0;
  for (count = L'\0'; list[count] != (char *)0x0; count = count + L'\x01') {
    sVar1 = strlen(list[count]);
    if (width < sVar1) {
      width = strlen(list[count]);
    }
  }
  return width;
}



void draw_option(WINDOW *win,wchar_t entry,wchar_t width,BOOLEAN reversed,wchar_t num_choices,
                wchar_t number,char *value)

{
  int iVar1;
  int in_GS_OFFSET;
  wchar_t local_428;
  wchar_t local_424;
  char *value_local;
  BOOLEAN reversed_local;
  WINDOW *win_local;
  char Cnum [1024];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  FormatChoiceNum(Cnum,num_choices,number,"");
  wmove(win,entry,1);
  curses_w_style(win,s_menu_entry,L'\x01');
  waddch(win,0x20);
  curses_w_style(win,s_menu_entry,L'\0');
  curses_w_style(win,s_menu_number,L'\x01');
  waddnstr(win,Cnum,0xffffffff);
  curses_w_style(win,s_menu_number,L'\0');
  if (reversed == '\0') {
    local_428 = s_menu_entry;
  }
  else {
    local_428 = s_menu_active;
  }
  curses_w_style(win,local_428,L'\x01');
  LYpaddstr(win,width,value);
  if (reversed == '\0') {
    local_424 = s_menu_entry;
  }
  else {
    local_424 = s_menu_active;
  }
  curses_w_style(win,local_424,L'\0');
  curses_w_style(win,s_menu_entry,L'\x01');
  waddch(win,0x20);
  curses_w_style(win,s_menu_entry,L'\0');
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



wchar_t LYhandlePopupList(wchar_t cur_choice,wchar_t ly,wchar_t lx,char **choices,wchar_t width,
                         wchar_t i_length,wchar_t disabled,BOOLEAN for_mouse)

{
  int iVar1;
  char **list;
  BOOLEAN BVar2;
  wchar_t wVar3;
  wchar_t wVar4;
  char *pcVar5;
  FILE *pFVar6;
  int iVar7;
  int in_GS_OFFSET;
  undefined3 in_stack_00000021;
  wchar_t wVar8;
  wchar_t wVar9;
  wchar_t wVar10;
  wchar_t local_50c;
  wchar_t local_508;
  wchar_t local_504;
  uint local_500;
  wchar_t local_4fc;
  wchar_t local_4f8;
  wchar_t local_4f4;
  wchar_t local_4f0;
  wchar_t local_4ec;
  BOOLEAN for_mouse_local;
  char **choices_local;
  char *msg;
  wchar_t curpage;
  wchar_t row;
  wchar_t limit;
  wchar_t check;
  wchar_t can_scroll_was;
  wchar_t can_scroll;
  char **Cptr;
  char *popup_status_msg;
  wchar_t number;
  wchar_t QueryNum;
  wchar_t QueryTotal;
  RecallType recall;
  wchar_t ch;
  char *cp;
  wchar_t npages;
  wchar_t Lnum;
  wchar_t lines_to_show;
  wchar_t window_offset;
  wchar_t length;
  wchar_t bottom;
  wchar_t top;
  wchar_t max_choices;
  wchar_t num_choices;
  WINDOW *form_window;
  wchar_t orig_choice;
  wchar_t rel;
  wchar_t j;
  wchar_t i;
  wchar_t cmd;
  wchar_t c;
  BOOLEAN ReDraw;
  BOOLEAN FirstRecall;
  BOOLEAN numbered;
  char buffer [1024];
  char Cnum [64];
  
  BVar2 = for_mouse;
  list = choices;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  numbered = keypad_mode != 0;
  c = L'\0';
  cmd = L'\0';
  i = L'\0';
  j = L'\0';
  rel = L'\0';
  num_choices = L'\0';
  max_choices = L'\0';
  length = L'\xffffffff';
  window_offset = L'\0';
  ch = L'\0';
  FirstRecall = '\x01';
  ReDraw = '\0';
  popup_status_msg = (char *)0x0;
  Cptr = (char **)0x0;
  can_scroll = L'\0';
  can_scroll_was = L'\0';
  orig_choice = cur_choice;
  if (cur_choice < L'\0') {
    cur_choice = L'\0';
  }
  if (LYhandlePopupList::first != '\0') {
    LYhandlePopupList::prev_target_buffer[0] = '\0';
    LYhandlePopupList::first = '\0';
  }
  LYhandlePopupList::prev_target[0] = '\0';
  if (search_queries == (HTList *)0x0) {
    local_50c = L'\0';
  }
  else {
    local_50c = HTList_count(search_queries);
  }
  QueryTotal = local_50c;
  recall = (RecallType)(L'\0' < local_50c);
  QueryNum = local_50c;
  wVar4 = LYarrayLength(list);
  num_choices = wVar4 + L'\xffffffff';
  if (width < L'\x01') {
    width = options_width(list);
  }
  if (numbered == '\0') {
    Lnum = L'\0';
    max_choices = L'\xffffffff';
  }
  else {
    sprintf(Cnum,"%d: ",num_choices);
    Lnum = strlen(Cnum);
    max_choices = num_choices;
  }
  top = ~cur_choice + ly;
  if (top < L'\0') {
    top = L'\0';
  }
  if (i_length < L'\x01') {
    i_length = num_choices;
  }
  else {
    i_length = i_length + L'\xffffffff';
  }
  bottom = top + i_length + L'\x03';
  if (user_mode == 0) {
    lines_to_show = LYlines + L'\xfffffffc';
  }
  else {
    lines_to_show = LYlines + L'\xfffffffe';
  }
  if (((BVar2 != '\0') && (user_mode == 0)) && (L'\x02' < lines_to_show)) {
    lines_to_show = lines_to_show + L'\xffffffff';
  }
  if (lines_to_show < bottom) {
    if (lines_to_show < i_length + L'\x03') {
      top = L'\0';
      bottom = i_length + L'\x03';
      if (lines_to_show < bottom) {
        bottom = lines_to_show + L'\x01';
      }
    }
    else {
      top = lines_to_show + (-2 - i_length);
      bottom = lines_to_show + L'\x01';
    }
  }
  length = (bottom - top) + L'\xfffffffe';
  if (length <= num_choices) {
    can_scroll = L'\x04';
  }
  if (bottom < ly + L'\x02') {
    bottom = ly + L'\x02';
    if (lines_to_show + L'\x01' < bottom) {
      bottom = lines_to_show + L'\x01';
    }
    top = (bottom - length) + L'\xfffffffe';
  }
  if (BVar2 != '\0') {
    check = width + Lnum + L'\x04';
    limit = LYcols;
    if (check < LYcols) {
      if (LYcols < lx + L'\xffffffff' + check) {
        lx = (LYcols + 1) - check;
      }
      else if (lx < L'\x01') {
        lx = L'\x01';
      }
    }
  }
  width = width + Lnum;
  bottom = bottom - top;
  if (((num_choices < L'\x01') || (num_choices < cur_choice)) ||
     (form_window = LYstartPopup(&top,&lx,&bottom,&width), form_window == (WINDOW *)0x0)) {
    local_508 = orig_choice;
LAB_08055183:
    if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
      __stack_chk_fail();
    }
    return local_508;
  }
  width = width - Lnum;
  bottom = bottom + top;
  if (disabled == L'\0') {
    if (BVar2 == '\0') {
      popup_status_msg =
           (char *)gettext(
                          "(Choice list) Hit return and use arrow keys and return to select option."
                          );
    }
    else {
      popup_status_msg =
           (char *)gettext("Left mouse button or return to select, arrow keys to scroll.");
    }
  }
  else {
    popup_status_msg =
         (char *)gettext("UNMODIFIABLE choice list.  Use return or arrow keys to review or leave.");
  }
  mustshow = '\x01';
  statusline(popup_status_msg);
  if (length <= cur_choice) {
    window_offset = (cur_choice - length) + L'\x01';
  }
  if (length < num_choices + L'\x01') {
    local_504 = (num_choices + length) / length;
  }
  else {
    local_504 = L'\x01';
  }
  npages = local_504;
redraw:
  for (i = L'\0'; i <= num_choices; i = i + L'\x01') {
    if ((window_offset <= i) && (i - window_offset < length)) {
      draw_option(form_window,(i + L'\x01') - window_offset,width,'\0',max_choices,i,list[i]);
    }
  }
  LYbox(form_window,numbered == '\0');
  Cptr = (char **)0x0;
switchD_08053f70_caseD_0:
  do {
    if (cmd == L'\'') {
LAB_0805514e:
      LYsubwindow((WINDOW *)0x0);
      if (disabled == L'\0') {
        local_4ec = cur_choice;
      }
      else {
        local_4ec = orig_choice;
      }
      local_508 = local_4ec;
      goto LAB_08055183;
    }
    row = (i + L'\x01') - window_offset;
    if (can_scroll != L'\0') {
      if (window_offset == L'\0') {
        local_500 = 0;
      }
      else {
        local_500 = 2;
      }
      can_scroll = length <= num_choices - window_offset | local_500;
      if ((~can_scroll & can_scroll_was) != 0) {
        LYbox(form_window,numbered == '\0');
        can_scroll_was = L'\0';
      }
      if ((~can_scroll_was & can_scroll & 2U) != 0) {
        wmove(form_window,1,width + Lnum + 3);
        curses_w_style(form_window,s_menu_sb,L'\x01');
        waddch(form_window,acs_map._180_4_);
        curses_w_style(form_window,s_menu_sb,L'\0');
      }
      if ((~(byte)can_scroll_was & (byte)can_scroll & 1) != 0) {
        wmove(form_window,length,width + Lnum + 3);
        curses_w_style(form_window,s_menu_sb,L'\x01');
        waddch(form_window,acs_map._184_4_);
        curses_w_style(form_window,s_menu_sb,L'\0');
      }
    }
    if (Cptr != (char **)0x0) {
      draw_option(form_window,row,width,'\0',max_choices,i,Cptr[i]);
    }
    Cptr = list;
    i = cur_choice;
    row = (cur_choice + L'\x01') - window_offset;
    wVar4 = L'\x01';
    wVar9 = max_choices;
    draw_option(form_window,row,width,'\x01',max_choices,cur_choice,list[cur_choice]);
    LYstowCursor(form_window,row,L'\x01');
    c = LYgetch_choice();
    if (((term_options == '\0') && (c != L'\x03')) && (c != L'\a')) {
      if (c == L'\xffffffff') {
        if (keymap[0] != 0x2f) goto LAB_08053e90;
        goto LAB_08053e81;
      }
      if ((c & 0x8800U) == 0) {
        if (keymap[(c & 0x7ffU) + 1] == 0x2f) goto LAB_08053e81;
      }
      else if ((c & 0xffU) == 0x2f) goto LAB_08053e81;
LAB_08053e90:
      if (c == L'') {
        cmd = fancy_mouse(form_window,row,&cur_choice);
        if (cmd < L'\0') goto redraw;
        if (cmd == L'\'') goto LAB_0805514e;
      }
      else {
        if (c == L'\xffffffff') {
          local_4fc = (wchar_t)keymap[0];
        }
        else {
          if ((c & 0x8800U) == 0) {
            local_4f8 = (wchar_t)keymap[(c & 0x7ffU) + 1];
          }
          else {
            local_4f8 = c & 0xff;
          }
          local_4fc = local_4f8;
        }
        cmd = local_4fc;
      }
    }
    else {
LAB_08053e81:
      cmd = L'\r';
    }
    switch(cmd) {
    case L'\r':
    case L'\x0e':
    case L'%':
    case L'/':
      cur_choice = orig_choice;
      cmd = L'\'';
      break;
    case L'\x0f':
      if ((num_choices - length) + L'\x01' != window_offset) {
        iVar7 = cur_choice - window_offset;
        window_offset = window_offset + length;
        if (num_choices - length < window_offset) {
          window_offset = (num_choices - length) + L'\x01';
        }
        cur_choice = iVar7 + window_offset;
        goto redraw;
      }
      if (cur_choice < num_choices) {
        cur_choice = num_choices;
      }
      break;
    case L'\x10':
      if (window_offset != L'\0') {
        iVar7 = cur_choice - window_offset;
        window_offset = window_offset - length;
        if (window_offset < L'\0') {
          window_offset = L'\0';
        }
        cur_choice = iVar7 + window_offset;
        goto redraw;
      }
      if (L'\0' < cur_choice) {
        cur_choice = L'\0';
      }
      break;
    case L'\x11':
      cur_choice = cur_choice + L'\xfffffffe';
      if (cur_choice < L'\0') {
        cur_choice = L'\0';
      }
      if (cur_choice - window_offset < 0) {
        window_offset = window_offset + L'\xfffffffe';
        if (window_offset < L'\0') {
          window_offset = L'\0';
        }
        goto redraw;
      }
      break;
    case L'\x12':
      cur_choice = cur_choice + L'\x02';
      if (num_choices < cur_choice) {
        cur_choice = num_choices;
      }
      if (length <= cur_choice - window_offset) {
        window_offset = window_offset + L'\x02';
        if ((num_choices - length) + L'\x01' < window_offset) {
          window_offset = (num_choices - length) + L'\x01';
        }
        goto redraw;
      }
      break;
    case L'\x13':
      cur_choice = cur_choice - length / 2;
      if (cur_choice < L'\0') {
        cur_choice = L'\0';
      }
      if (cur_choice - window_offset < 0) {
        window_offset = window_offset - length / 2;
        if (window_offset < L'\0') {
          window_offset = L'\0';
        }
        goto redraw;
      }
      break;
    case L'\x14':
      cur_choice = length / 2 + cur_choice;
      if (num_choices < cur_choice) {
        cur_choice = num_choices;
      }
      if (length <= cur_choice - window_offset) {
        window_offset = window_offset + length / 2;
        if ((num_choices - length) + L'\x01' < window_offset) {
          window_offset = (num_choices - length) + L'\x01';
        }
        goto redraw;
      }
      break;
    case L'\x15':
      lynx_force_repaint();
      LYrefresh();
      break;
    case L'\x16':
      cur_choice = L'\0';
      if (L'\0' < window_offset) {
        window_offset = L'\0';
        goto redraw;
      }
      break;
    case L'\x17':
      cur_choice = num_choices;
      if ((num_choices - length) + L'\x01' != window_offset) {
        window_offset = (num_choices - length) + L'\x01';
        goto redraw;
      }
      break;
    case L'\x1a':
    case L'\x1c':
    case L'\x1e':
    case L' ':
      if (L'\0' < cur_choice) {
        cur_choice = cur_choice + L'\xffffffff';
      }
      if (cur_choice - window_offset < 0) {
        window_offset = window_offset + L'\xffffffff';
        goto redraw;
      }
      break;
    case L'\x1b':
    case L'\x1d':
    case L'\x1f':
    case L'!':
      if (cur_choice < num_choices) {
        cur_choice = cur_choice + L'\x01';
      }
      if (length <= cur_choice - window_offset) {
        window_offset = window_offset + L'\x01';
        goto redraw;
      }
      break;
    case L'3':
      goto switchD_08053f70_caseD_33;
    case L'5':
      if (((recall != NORECALL) && (LYhandlePopupList::prev_target_buffer[0] == '\0')) &&
         (cp = (char *)HTList_objectAt(search_queries,0), cp != (char *)0x0)) {
        LYstrncpy(LYhandlePopupList::prev_target_buffer,cp,L'');
        QueryNum = L'\0';
        FirstRecall = '\0';
      }
      strcpy(LYhandlePopupList::prev_target,LYhandlePopupList::prev_target_buffer);
switchD_08053f70_caseD_33:
      if (LYhandlePopupList::prev_target[0] == '\0') {
        mustshow = '\x01';
        pcVar5 = (char *)gettext("Enter a whereis query: ");
        statusline(pcVar5);
        ch = LYgetstr(LYhandlePopupList::prev_target,L'\0',0x400,recall);
        if (L'\xffffffff' < ch) goto check_recall;
        pcVar5 = (char *)gettext("Cancelled!!!");
        HTInfoMsg(pcVar5);
      }
      else {
check_recall:
        do {
          while( true ) {
            if ((LYhandlePopupList::prev_target[0] == '\0') &&
               ((recall == NORECALL || ((ch != L'' && (ch != L'')))))) {
              pcVar5 = (char *)gettext("Cancelled!!!");
              HTInfoMsg(pcVar5);
              goto restore_popup_statusline;
            }
            if ((recall == NORECALL) || (ch != L'')) break;
            if (FirstRecall == '\0') {
              QueryNum = QueryNum + L'\x01';
            }
            else {
              FirstRecall = '\0';
              QueryNum = QueryTotal;
              if (LYhandlePopupList::prev_target_buffer[0] == '\0') {
                QueryNum = L'\0';
              }
              else {
                do {
                  QueryNum = QueryNum + L'\xffffffff';
                  if (QueryNum < L'\x01') break;
                  cp = (char *)HTList_objectAt(search_queries,QueryNum);
                } while ((cp == (char *)0x0) ||
                        (iVar7 = strcmp(LYhandlePopupList::prev_target_buffer,cp), iVar7 != 0));
              }
            }
            if (QueryTotal <= QueryNum) {
              QueryNum = L'\0';
            }
            cp = (char *)HTList_objectAt(search_queries,QueryNum);
            if (cp == (char *)0x0) {
LAB_08054e06:
              strcpy(LYhandlePopupList::prev_target_buffer,LYhandlePopupList::prev_target);
              HTAddSearchQuery(LYhandlePopupList::prev_target_buffer);
              j = L'\x01';
              goto LAB_08054ec4;
            }
            LYstrncpy(LYhandlePopupList::prev_target,cp,L'');
            if ((LYhandlePopupList::prev_target_buffer[0] == '\0') ||
               (iVar7 = strcmp(LYhandlePopupList::prev_target_buffer,LYhandlePopupList::prev_target)
               , iVar7 != 0)) {
              if (((LYhandlePopupList::prev_target_buffer[0] == '\0') || (QueryTotal != L'\x02')) &&
                 ((LYhandlePopupList::prev_target_buffer[0] != '\0' || (QueryTotal != L'\x01')))) {
                mustshow = '\x01';
                pcVar5 = (char *)gettext("Edit a previous query: ");
                statusline(pcVar5);
              }
              else {
                mustshow = '\x01';
                pcVar5 = (char *)gettext("Edit the previous query: ");
                statusline(pcVar5);
              }
            }
            else {
              mustshow = '\x01';
              pcVar5 = (char *)gettext("Edit the current query: ");
              statusline(pcVar5);
            }
            ch = LYgetstr(LYhandlePopupList::prev_target,L'\0',0x400,recall);
            if (ch < L'\0') {
              pcVar5 = (char *)gettext("Cancelled!!!");
              HTInfoMsg(pcVar5);
              goto restore_popup_statusline;
            }
          }
          if ((recall == NORECALL) || (ch != L'')) goto LAB_08054e06;
          if (FirstRecall == '\0') {
            QueryNum = QueryNum + L'\xffffffff';
          }
          else {
            FirstRecall = '\0';
            if (LYhandlePopupList::prev_target_buffer[0] == '\0') {
              QueryNum = QueryTotal + L'\xffffffff';
            }
            else {
              QueryNum = L'\0';
              while ((QueryNum < QueryTotal + L'\xffffffff' &&
                     ((cp = (char *)HTList_objectAt(search_queries,QueryNum), cp == (char *)0x0 ||
                      (iVar7 = strcmp(LYhandlePopupList::prev_target_buffer,cp), iVar7 != 0))))) {
                QueryNum = QueryNum + L'\x01';
              }
            }
          }
          if (QueryNum < L'\0') {
            QueryNum = QueryTotal + L'\xffffffff';
          }
          cp = (char *)HTList_objectAt(search_queries,QueryNum);
          if (cp == (char *)0x0) goto LAB_08054e06;
          LYstrncpy(LYhandlePopupList::prev_target,cp,L'');
          if ((LYhandlePopupList::prev_target_buffer[0] == '\0') ||
             (iVar7 = strcmp(LYhandlePopupList::prev_target_buffer,LYhandlePopupList::prev_target),
             iVar7 != 0)) {
            if (((LYhandlePopupList::prev_target_buffer[0] == '\0') || (QueryTotal != L'\x02')) &&
               ((LYhandlePopupList::prev_target_buffer[0] != '\0' || (QueryTotal != L'\x01')))) {
              mustshow = '\x01';
              pcVar5 = (char *)gettext("Edit a previous query: ");
              statusline(pcVar5);
            }
            else {
              mustshow = '\x01';
              pcVar5 = (char *)gettext("Edit the previous query: ");
              statusline(pcVar5);
            }
          }
          else {
            mustshow = '\x01';
            pcVar5 = (char *)gettext("Edit the current query: ");
            statusline(pcVar5);
          }
          ch = LYgetstr(LYhandlePopupList::prev_target,L'\0',0x400,recall);
        } while (L'\xffffffff' < ch);
        pcVar5 = (char *)gettext("Cancelled!!!");
        HTInfoMsg(pcVar5);
      }
      goto restore_popup_statusline;
    case L'P':
      c = L'\0';
    case L'\x02':
    case L'\x03':
    case L'\x04':
    case L'\x05':
    case L'\x06':
    case L'\a':
    case L'\b':
    case L'\t':
    case L'\n':
      pcVar5 = (char *)gettext("Select option (or page) number: ");
      number = get_popup_number(pcVar5,&c,&rel);
      if (WWW_TraceFlag != '\0') {
        pFVar6 = TraceFP();
        fprintf((FILE *)pFVar6,"got popup option number %d, ",number);
      }
      wVar8 = c;
      wVar3 = rel;
      wVar10 = cur_choice;
      if (WWW_TraceFlag != '\0') {
        pFVar6 = TraceFP();
        fprintf((FILE *)pFVar6,"rel=\'%c\', c=\'%c\', cur_choice=%d\n",wVar3,wVar8,wVar10);
        wVar4 = wVar8;
        wVar9 = wVar10;
      }
      if (c == L'p') {
        if (length < cur_choice + L'\x01') {
          local_4f4 = (cur_choice + length) / length;
        }
        else {
          local_4f4 = L'\x01';
        }
        curpage = local_4f4;
        if (WWW_TraceFlag != '\0') {
          pFVar6 = TraceFP();
          fprintf((FILE *)pFVar6,"  curpage=%d\n",curpage,wVar4,wVar9);
        }
        if (rel == L'+') {
          number = number + curpage;
        }
        else if (rel == L'-') {
          number = curpage - number;
        }
      }
      else if (rel == L'+') {
        number = cur_choice + number + L'\x01';
      }
      else if (rel == L'-') {
        number = (cur_choice - number) + L'\x01';
      }
      if ((rel != L'\0') && (WWW_TraceFlag != '\0')) {
        pFVar6 = TraceFP();
        fprintf((FILE *)pFVar6,"new number=%d\n",number,wVar4,wVar9);
      }
      wVar4 = number;
      if (c == L'p') {
        if (number < L'\x02') {
          if (window_offset != L'\0') {
            window_offset = L'\0';
            cur_choice = L'\0';
            mustshow = '\x01';
            statusline(popup_status_msg);
            goto redraw;
          }
          pcVar5 = (char *)gettext("You are already at the beginning of this option list.");
          HTUserMsg(pcVar5);
          mustshow = '\x01';
          statusline(popup_status_msg);
        }
        else if (number < npages) {
          if ((number + L'\xffffffff') * length - window_offset != 0) {
            cur_choice = (number + L'\xffffffff') * length;
            mustshow = '\x01';
            window_offset = cur_choice;
            statusline(popup_status_msg);
            goto redraw;
          }
          msg = (char *)0x0;
          pcVar5 = (char *)gettext("You are already at page %d of this option list.");
          HTSprintf0(&msg,pcVar5,number);
          HTUserMsg(msg);
          if (msg != (char *)0x0) {
            free(msg);
            msg = (char *)0x0;
          }
          mustshow = '\x01';
          statusline(popup_status_msg);
        }
        else {
          if (window_offset < (num_choices - length) + L'\x01') {
            window_offset = (npages + L'\xffffffff') * length;
            if (num_choices - length < window_offset) {
              window_offset = (num_choices - length) + L'\x01';
            }
            if (cur_choice < window_offset) {
              cur_choice = window_offset;
            }
            mustshow = '\x01';
            statusline(popup_status_msg);
            goto redraw;
          }
          pcVar5 = (char *)gettext("You are already at the end of this option list.");
          HTUserMsg(pcVar5);
          mustshow = '\x01';
          statusline(popup_status_msg);
        }
        break;
      }
      if (L'\0' < number) {
        number = number + L'\xffffffff';
        if ((number <= num_choices) && (c == L'\0')) {
          cmd = L'\'';
          cur_choice = number;
          break;
        }
        if (c == L'g') {
          if (cur_choice == number) {
            msg = (char *)0x0;
            pcVar5 = (char *)gettext("Option number %d already is current.");
            HTSprintf0(&msg,pcVar5,wVar4);
            HTUserMsg(msg);
            if (msg != (char *)0x0) {
              free(msg);
              msg = (char *)0x0;
            }
            mustshow = '\x01';
            statusline(popup_status_msg);
            break;
          }
          if (number <= num_choices) {
            j = number - cur_choice;
            if ((j < L'\x01') || (number - window_offset < length)) {
              if ((number - window_offset < 0) &&
                 (window_offset = window_offset - ((j >> 0x1f ^ j) - (j >> 0x1f)),
                 window_offset < L'\0')) {
                window_offset = L'\0';
              }
            }
            else {
              window_offset = window_offset + j;
              if ((num_choices - length) + L'\x01' < window_offset) {
                window_offset = (num_choices - length) + L'\x01';
              }
            }
            mustshow = '\x01';
            cur_choice = number;
            statusline(popup_status_msg);
            goto redraw;
          }
          pcVar5 = (char *)gettext("You have entered an invalid option number.");
          HTUserMsg(pcVar5);
        }
      }
      mustshow = '\x01';
      statusline(popup_status_msg);
      break;
    }
  } while( true );
LAB_08054ec4:
  if (Cptr[i + j] == (char *)0x0) goto LAB_08054ee5;
  FormatChoiceNum(buffer,max_choices,i + j,Cptr[i + j]);
  if (case_sensitive == '\0') {
    pcVar5 = LYstrstr(buffer,LYhandlePopupList::prev_target_buffer);
  }
  else {
    pcVar5 = strstr(buffer,LYhandlePopupList::prev_target_buffer);
  }
  if (pcVar5 != (char *)0x0) goto LAB_08054ee5;
  j = j + L'\x01';
  goto LAB_08054ec4;
LAB_08054ee5:
  if (Cptr[i + j] == (char *)0x0) {
    if (cur_choice == L'\0') {
      pcVar5 = (char *)gettext("\'%s\' not found!");
      HTUserMsg2(pcVar5,LYhandlePopupList::prev_target_buffer);
    }
    else {
      for (j = L'\0'; j < cur_choice; j = j + L'\x01') {
        FormatChoiceNum(buffer,max_choices,j + L'\x01',Cptr[j]);
        if (case_sensitive == '\0') {
          pcVar5 = LYstrstr(buffer,LYhandlePopupList::prev_target_buffer);
        }
        else {
          pcVar5 = strstr(buffer,LYhandlePopupList::prev_target_buffer);
        }
        if (pcVar5 != (char *)0x0) break;
      }
      if (j < cur_choice) {
        j = cur_choice - j;
        cur_choice = cur_choice - j;
        if (cur_choice - window_offset < 0) {
          window_offset = window_offset - j;
          if (window_offset < L'\0') {
            window_offset = L'\0';
          }
          ReDraw = '\x01';
        }
      }
      else {
        pcVar5 = (char *)gettext("\'%s\' not found!");
        HTUserMsg2(pcVar5,LYhandlePopupList::prev_target_buffer);
      }
    }
  }
  else {
    cur_choice = cur_choice + j;
    if (length <= cur_choice - window_offset) {
      window_offset = window_offset + j;
      if ((num_choices - length) + L'\x01' < window_offset) {
        window_offset = (num_choices - length) + L'\x01';
      }
      ReDraw = '\x01';
    }
  }
restore_popup_statusline:
  mustshow = '\x01';
  statusline(popup_status_msg);
  LYhandlePopupList::prev_target[0] = '\0';
  if (search_queries == (HTList *)0x0) {
    local_4f0 = L'\0';
  }
  else {
    local_4f0 = HTList_count(search_queries);
  }
  QueryTotal = local_4f0;
  recall = (RecallType)(L'\0' < local_4f0);
  QueryNum = local_4f0;
  if (ReDraw == '\x01') goto code_r0x08055122;
  goto switchD_08053f70_caseD_0;
code_r0x08055122:
  ReDraw = '\0';
  goto redraw;
}



wchar_t LYgetstr(char *inputline,wchar_t hidden,size_t bufsize,RecallType recall)

{
  int iVar1;
  bool bVar2;
  FILE *pFVar3;
  int iVar4;
  HTList *list_00;
  char **list_01;
  char *result;
  size_t sVar5;
  uchar *puVar6;
  uint uVar7;
  wchar_t wVar8;
  int in_GS_OFFSET;
  bool bVar9;
  int local_44a0;
  wchar_t local_449c;
  wchar_t local_4498;
  wchar_t local_4490;
  wchar_t local_448c;
  char *inputline_local;
  uchar *e1;
  wchar_t len;
  uchar *e;
  uchar *s;
  wchar_t num_options;
  wchar_t cur_choice;
  wchar_t old_x;
  wchar_t old_y;
  char **data;
  HTList *list;
  wchar_t last_xlkc;
  wchar_t last_xlec;
  wchar_t xlec;
  wchar_t ch;
  wchar_t MaxStringSize;
  wchar_t y;
  wchar_t x;
  BOOLEAN refresh_mb;
  EditFieldData MyEdit;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  xlec = L'\xfffffffe';
  last_xlkc = L'\xffffffff';
  bVar2 = true;
  if (LYwin == (WINDOW *)0x0) {
    local_44a0 = -1;
  }
  else {
    local_44a0 = (int)LYwin->_curx;
  }
  if (bufsize < 0x400) {
    local_449c = bufsize + L'\xffffffff';
  }
  else {
    local_449c = L'';
  }
  LYSetupEdit(&MyEdit,inputline,local_449c,(LYcols - (uint)(LYShowScrollbar != '\0')) - local_44a0);
  MyEdit.hidden = (BOOLEAN)hidden;
  if (WWW_TraceFlag != '\0') {
    pFVar3 = TraceFP();
    fprintf((FILE *)pFVar3,"called LYgetstr\n");
  }
  do {
    do {
      wVar8 = xlec;
      if (bVar2) {
        LYRefreshEdit(&MyEdit);
      }
      ch = LYReadCmdKey(L'\x03');
    } while ((!bVar2) && (iVar4 = EditBinding(ch), iVar4 != 1));
    if ((term_letter != '\0') || ((term_options != '\0' || (term_message != '\0')))) {
      ch = L'\a';
    }
    if ((recall != NORECALL) && ((ch == L'' || (ch == L'')))) {
      LYstrncpy(inputline,MyEdit.buffer,bufsize);
      LYAddToCloset(recall,MyEdit.buffer);
      if (WWW_TraceFlag != '\0') {
        pFVar3 = TraceFP();
        fprintf((FILE *)pFVar3,"LYgetstr(%s) recall\n",inputline);
      }
      local_4498 = ch;
      goto LAB_08055ac1;
    }
    ch = ch | MyEdit.current_modifiers;
    MyEdit.current_modifiers = L'\0';
    if (last_xlkc != L'\xffffffff') {
      if (ch == last_xlkc) {
        ch = ch | 0x1000;
      }
      last_xlkc = L'\xffffffff';
    }
    if (ch == L'\xffffffff') {
      bVar9 = keymap[0] == 0x15;
    }
    else if ((ch & 0x8800U) == 0) {
      bVar9 = keymap[(ch & 0x7ffU) + 1] == 0x15;
    }
    else {
      bVar9 = (ch & 0xffU) == 0x15;
    }
    if (!bVar9) {
      xlec = EditBinding(ch);
      if (((xlec & 0x80U) == 0) || ((xlec & 0x1000U) != 0)) {
        last_xlkc = L'\xffffffff';
      }
      else {
        last_xlkc = ch;
        xlec = xlec & 0xffffff7f;
      }
      switch(xlec) {
      default:
        if ((xlec & 0x1000U) == 0) {
          uVar7 = EditBinding(ch);
          wVar8 = LYEdit1(&MyEdit,ch,uVar7 & 0xffffff7f,'\0');
          if (wVar8 == L'\0') {
            if ((((bVar2) && (HTCJK != NOCJK)) && (L'\x80' < ch)) && (ch < L'')) {
              bVar2 = false;
            }
            else {
              bVar2 = true;
            }
          }
          else if (!bVar2) {
            LYEdit1(&MyEdit,L'\0',L'\t','\0');
          }
        }
        break;
      case L'\x02':
        LYstrncpy(inputline,MyEdit.buffer,bufsize);
        if (hidden == L'\0') {
          LYAddToCloset(recall,MyEdit.buffer);
        }
        if (WWW_TraceFlag != '\0') {
          pFVar3 = TraceFP();
          fprintf((FILE *)pFVar3,"LYgetstr(%s) LYE_ENTER\n",inputline);
        }
        local_4498 = ch;
LAB_08055ac1:
        if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
          __stack_chk_fail();
        }
        return local_4498;
      case L'\x03':
        if ((xlec == wVar8) && (recall != NORECALL)) {
          list_00 = whichRecall(recall);
          if ((list_00 != (HTList *)0x0) && (list_00->next != (HTList *)0x0)) {
            list_01 = sortedList(list_00,recall == RECALL_CMD);
            cur_choice = L'\0';
            wVar8 = LYarrayLength(list_01);
            while ((cur_choice < wVar8 &&
                   (iVar4 = strcasecomp(list_01[cur_choice],MyEdit.buffer), iVar4 < 0))) {
              cur_choice = cur_choice + L'\x01';
            }
            if (LYwin == (WINDOW *)0x0) {
              local_4490 = L'\xffffffff';
              local_448c = L'\xffffffff';
            }
            else {
              local_4490 = (wchar_t)LYwin->_cury;
              local_448c = (wchar_t)LYwin->_curx;
            }
            wVar8 = LYhandlePopupList(cur_choice,L'\0',local_448c,list_01,L'\xffffffff',
                                      L'\xffffffff',L'\0','\0');
            if (L'\xffffffff' < wVar8) {
              if (recall == RECALL_CMD) {
                mustshow = '\x01';
                statusline(": ");
              }
              reinsertEdit(&MyEdit,list_01[wVar8]);
            }
            LYmove(local_4490,local_448c);
            if (list_01 != (char **)0x0) {
              free(list_01);
            }
          }
        }
        else {
          result = LYFindInCloset(recall,MyEdit.buffer);
          reinsertEdit(&MyEdit,result);
        }
        break;
      case L'\x04':
        if (WWW_TraceFlag != '\0') {
          pFVar3 = TraceFP();
          fprintf((FILE *)pFVar3,"LYgetstr LYE_STOP\n");
        }
        textfields_need_activation = '\x01';
        local_4498 = L'\xffffffff';
        goto LAB_08055ac1;
      case L'\x05':
        *inputline = '\0';
        if (WWW_TraceFlag != '\0') {
          pFVar3 = TraceFP();
          fprintf((FILE *)pFVar3,"LYgetstr LYE_ABORT\n");
        }
        local_4498 = L'\xffffffff';
        goto LAB_08055ac1;
      case L'\x06':
      case L'\x17':
        break;
      case L'\x1d':
        MyEdit.current_modifiers = MyEdit.current_modifiers | 0x4000;
        break;
      case L'\x1e':
        MyEdit.current_modifiers = MyEdit.current_modifiers | 0x2000;
        break;
      case L'%':
        e1 = (uchar *)get_clip_grab();
        if (e1 != (uchar *)0x0) {
          sVar5 = strlen((char *)e1);
          puVar6 = e1 + sVar5;
          s = e1;
          if (0 < (int)sVar5) {
            while (e1 < puVar6) {
              if (*e1 < 0x20) {
                if (s < e1) {
                  LYEditInsert(&MyEdit,s,(int)e1 - (int)s,L'\0','\x01');
                }
                s = e1;
                if (*e1 != '\t') break;
                LYEditInsert(&MyEdit," ",L'\x01',L'\0','\x01');
                e1 = e1 + 1;
                s = e1;
              }
              else {
                e1 = e1 + 1;
              }
            }
            if (s < e1) {
              LYEditInsert(&MyEdit,s,(int)e1 - (int)s,L'\0','\x01');
            }
          }
          get_clip_release();
        }
      }
    }
  } while( true );
}



// WARNING: Unknown calling convention

char * LYLineeditHelpURL(void)

{
  char *pcVar1;
  size_t sVar2;
  char *local_c;
  
  if (LYLineeditHelpURL::lasthelp_lineedit == current_lineedit) {
    local_c = LYLineeditHelpURL::helpbuf;
  }
  else {
    if (LYLineeditHelpURL::lasthelp_lineedit == L'\xffffffff') {
      LYstrncpy(LYLineeditHelpURL::helpbuf,helpfilepath,L'');
      pcVar1 = LYLineeditHelpURL::phelp;
      sVar2 = strlen(LYLineeditHelpURL::helpbuf);
      LYLineeditHelpURL::phelp = pcVar1 + sVar2;
    }
    if (((LYLineeditHelpURLs[current_lineedit] != (char *)0x0) &&
        (*LYLineeditHelpURLs[current_lineedit] != '\0')) &&
       (sVar2 = strlen(LYLineeditHelpURLs[current_lineedit]),
       sVar2 <= (uint)((int)&LYLineeditHelpURL::lasthelp_lineedit - (int)LYLineeditHelpURL::phelp)))
    {
      LYstrncpy(LYLineeditHelpURL::phelp,LYLineeditHelpURLs[current_lineedit],
                (wchar_t)(LYLineeditHelpURL::helpbuf + (0xff - (int)LYLineeditHelpURL::phelp)));
      LYLineeditHelpURL::lasthelp_lineedit = current_lineedit;
      return LYLineeditHelpURL::helpbuf;
    }
    local_c = (char *)0x0;
  }
  return local_c;
}



// WARNING: Unknown calling convention

char * LYstrsep(char **stringp,char *delim)

{
  char *pcVar1;
  char *local_18;
  char *out;
  char *tmp;
  
  if ((stringp == (char **)0x0) || (*stringp == (char *)0x0)) {
    local_18 = (char *)0x0;
  }
  else {
    local_18 = *stringp;
    pcVar1 = strpbrk(*stringp,delim);
    if (pcVar1 == (char *)0x0) {
      *stringp = (char *)0x0;
    }
    else {
      *pcVar1 = '\0';
      *stringp = pcVar1 + 1;
    }
  }
  return local_18;
}



// WARNING: Unknown calling convention

char * LYstrstr(char *chptr,char *tarptr)

{
  size_t sVar1;
  wchar_t wVar2;
  int iVar3;
  wchar_t len;
  
  sVar1 = strlen(tarptr);
  while( true ) {
    if (*chptr == '\0') {
      return (char *)0x0;
    }
    wVar2 = UPPER8((int)*chptr,(int)*tarptr);
    if ((wVar2 == L'\0') && (iVar3 = strncasecomp8(chptr + 1,tarptr + 1,sVar1 - 1), iVar3 == 0))
    break;
    chptr = chptr + 1;
  }
  return chptr;
}



// WARNING: Unknown calling convention

char * LYno_attr_char_case_strstr(char *chptr,char *tarptr)

{
  wchar_t wVar1;
  char *local_c;
  char *local_8;
  
  if (chptr != (char *)0x0) {
    for (; (('\x02' < *chptr && (*chptr < '\t')) && (*chptr != '\0')); chptr = chptr + 1) {
    }
    for (; *chptr != '\0'; chptr = chptr + 1) {
      wVar1 = UPPER8((int)*chptr,(int)*tarptr);
      if (wVar1 == L'\0') {
        local_c = chptr + 1;
        local_8 = tarptr + 1;
        if (*local_8 == '\0') {
          return chptr;
        }
        do {
          if ((*local_c < '\x03') || ('\b' < *local_c)) {
            wVar1 = UPPER8((int)*local_c,(int)*local_8);
            if (wVar1 != L'\0') break;
            local_8 = local_8 + 1;
          }
          local_c = local_c + 1;
          if (*local_8 == '\0') {
            return chptr;
          }
        } while (*local_c != '\0');
      }
    }
  }
  return (char *)0x0;
}



// WARNING: Unknown calling convention

char * LYno_attr_char_strstr(char *chptr,char *tarptr)

{
  char *local_c;
  char *local_8;
  
  if (chptr != (char *)0x0) {
    for (; (('\x02' < *chptr && (*chptr < '\t')) && (*chptr != '\0')); chptr = chptr + 1) {
    }
    for (; *chptr != '\0'; chptr = chptr + 1) {
      if (*chptr == *tarptr) {
        local_c = chptr + 1;
        local_8 = tarptr + 1;
        if (*local_8 == '\0') {
          return chptr;
        }
        do {
          if ((*local_c < '\x03') || ('\b' < *local_c)) {
            if (*local_c != *local_8) break;
            local_8 = local_8 + 1;
          }
          local_c = local_c + 1;
          if (*local_8 == '\0') {
            return chptr;
          }
        } while (*local_c != '\0');
      }
    }
  }
  return (char *)0x0;
}



char * LYno_attr_mbcs_case_strstr
                 (char *chptr,char *tarptr,BOOLEAN utf_flag,BOOLEAN count_gcells,wchar_t *nstartp,
                 wchar_t *nendp)

{
  wchar_t wVar1;
  wchar_t wVar2;
  BOOLEAN count_gcells_local;
  BOOLEAN utf_flag_local;
  wchar_t tarlen;
  wchar_t offset;
  wchar_t len;
  char *tmptarptr;
  char *tmpchptr;
  
  len = L'\0';
  if ((chptr != (char *)0x0) && (tarptr != (char *)0x0)) {
    for (; ('\x02' < *chptr && ((*chptr < '\t' && (*chptr != '\0')))); chptr = chptr + 1) {
    }
    for (; *chptr != '\0'; chptr = chptr + 1) {
      if (((((utf_flag == '\0') && (HTCJK != NOCJK)) && (*chptr < '\0')) &&
          (((*chptr == *tarptr && (chptr[1] != '\0')) && ((chptr[1] < '\x03' || ('\b' < chptr[1]))))
          )) || (wVar1 = UPPER8((int)*chptr,(int)*tarptr), wVar1 == L'\0')) {
        tarlen = L'\0';
        wVar1 = len + L'\x01';
        tmpchptr = chptr + 1;
        tmptarptr = tarptr + 1;
        if (*tmptarptr == '\0') {
          if (nstartp != (wchar_t *)0x0) {
            *nstartp = len;
          }
          if (nendp != (wchar_t *)0x0) {
            *nendp = wVar1;
          }
          return chptr;
        }
        if ((((utf_flag == '\0') && (HTCJK != NOCJK)) &&
            ((*chptr < '\0' && ((*chptr == *tarptr && (*tmpchptr != '\0')))))) &&
           ((*tmpchptr < '\x03' || ('\b' < *tmpchptr)))) {
          if (*tmpchptr != *tmptarptr) {
            chptr = chptr + 1;
            if (count_gcells != '\0') {
              wVar1 = len + L'\x02';
            }
            goto LAB_08056270;
          }
          tmpchptr = chptr + 2;
          tmptarptr = tarptr + 2;
          tarlen = (wchar_t)(count_gcells != '\0');
          if (*tmptarptr == '\0') {
            if (nstartp != (wchar_t *)0x0) {
              *nstartp = len;
            }
            if (nendp != (wchar_t *)0x0) {
              *nendp = wVar1 + tarlen;
            }
            return chptr;
          }
        }
        do {
          if ((*tmpchptr < '\x03') || ('\b' < *tmpchptr)) {
            if ((utf_flag == '\0') && ((HTCJK != NOCJK && (*tmpchptr < '\0')))) {
              if (((*tmpchptr != *tmptarptr) || (tmpchptr[1] != tmptarptr[1])) ||
                 (('\x02' < tmpchptr[1] && (tmpchptr[1] < '\t')))) break;
              tmpchptr = tmpchptr + 1;
              tmptarptr = tmptarptr + 1;
              if (count_gcells != '\0') {
                tarlen = tarlen + L'\x01';
              }
            }
            else {
              wVar2 = UPPER8((int)*tmpchptr,(int)*tmptarptr);
              if (wVar2 != L'\0') break;
            }
            if ((utf_flag == '\0') || ((*tmptarptr & 0xc0U) != 0x80)) {
              tarlen = tarlen + L'\x01';
            }
            tmptarptr = tmptarptr + 1;
          }
          tmpchptr = tmpchptr + 1;
          if (*tmptarptr == '\0') {
            if (nstartp != (wchar_t *)0x0) {
              *nstartp = len;
            }
            if (nendp != (wchar_t *)0x0) {
              *nendp = wVar1 + tarlen;
            }
            return chptr;
          }
        } while (*tmpchptr != '\0');
      }
      else {
        wVar1 = len;
        if (((utf_flag == '\0') || ((*chptr & 0xc0U) != 0x80)) &&
           ((*chptr < '\x03' || ('\b' < *chptr)))) {
          if (((((utf_flag == '\0') && (HTCJK != NOCJK)) && (*chptr < '\0')) && (chptr[1] != '\0'))
             && (((chptr[1] < '\x03' || ('\b' < chptr[1])) &&
                 (chptr = chptr + 1, count_gcells != '\0')))) {
            len = len + L'\x01';
          }
          wVar1 = len + L'\x01';
        }
      }
LAB_08056270:
      len = wVar1;
    }
  }
  return (char *)0x0;
}



char * LYno_attr_mbcs_strstr
                 (char *chptr,char *tarptr,BOOLEAN utf_flag,BOOLEAN count_gcells,wchar_t *nstartp,
                 wchar_t *nendp)

{
  wchar_t wVar1;
  BOOLEAN count_gcells_local;
  BOOLEAN utf_flag_local;
  wchar_t tarlen;
  wchar_t offset;
  wchar_t len;
  char *tmptarptr;
  char *tmpchptr;
  
  len = L'\0';
  if ((chptr != (char *)0x0) && (tarptr != (char *)0x0)) {
    for (; ('\x02' < *chptr && ((*chptr < '\t' && (*chptr != '\0')))); chptr = chptr + 1) {
    }
    for (; *chptr != '\0'; chptr = chptr + 1) {
      if (*chptr == *tarptr) {
        tarlen = L'\0';
        wVar1 = len + L'\x01';
        tmpchptr = chptr + 1;
        tmptarptr = tarptr + 1;
        if (*tmptarptr == '\0') {
          if (nstartp != (wchar_t *)0x0) {
            *nstartp = len;
          }
          if (nendp != (wchar_t *)0x0) {
            *nendp = wVar1;
          }
          return chptr;
        }
        if ((((utf_flag == '\0') && (HTCJK != NOCJK)) && ((*chptr < '\0' && (*tmpchptr != '\0'))))
           && ((*tmpchptr < '\x03' || ('\b' < *tmpchptr)))) {
          if (*tmpchptr != *tmptarptr) {
            chptr = chptr + 1;
            if (count_gcells != '\0') {
              wVar1 = len + L'\x02';
            }
            goto LAB_080565aa;
          }
          tmpchptr = chptr + 2;
          tmptarptr = tarptr + 2;
          tarlen = (wchar_t)(count_gcells != '\0');
          if (*tmptarptr == '\0') {
            if (nstartp != (wchar_t *)0x0) {
              *nstartp = len;
            }
            if (nendp != (wchar_t *)0x0) {
              *nendp = wVar1 + tarlen;
            }
            return chptr;
          }
        }
        do {
          if ((*tmpchptr < '\x03') || ('\b' < *tmpchptr)) {
            if ((utf_flag == '\0') && ((HTCJK != NOCJK && (*tmpchptr < '\0')))) {
              if (((*tmpchptr != *tmptarptr) || (tmpchptr[1] != tmptarptr[1])) ||
                 (('\x02' < tmpchptr[1] && (tmpchptr[1] < '\t')))) break;
              tmpchptr = tmpchptr + 1;
              tmptarptr = tmptarptr + 1;
              if (count_gcells != '\0') {
                tarlen = tarlen + L'\x01';
              }
            }
            else if (*tmpchptr != *tmptarptr) break;
            if ((utf_flag == '\0') || ((*tmptarptr & 0xc0U) != 0x80)) {
              tarlen = tarlen + L'\x01';
            }
            tmptarptr = tmptarptr + 1;
          }
          tmpchptr = tmpchptr + 1;
          if (*tmptarptr == '\0') {
            if (nstartp != (wchar_t *)0x0) {
              *nstartp = len;
            }
            if (nendp != (wchar_t *)0x0) {
              *nendp = wVar1 + tarlen;
            }
            return chptr;
          }
        } while (*tmpchptr != '\0');
      }
      else {
        wVar1 = len;
        if (((utf_flag == '\0') || ((*chptr & 0xc0U) != 0x80)) &&
           ((*chptr < '\x03' || ('\b' < *chptr)))) {
          if ((((((utf_flag == '\0') && (HTCJK != NOCJK)) && (*chptr < '\0')) && (chptr[1] != '\0'))
              && ((chptr[1] < '\x03' || ('\b' < chptr[1])))) &&
             (chptr = chptr + 1, count_gcells != '\0')) {
            len = len + L'\x01';
          }
          wVar1 = len + L'\x01';
        }
      }
LAB_080565aa:
      len = wVar1;
    }
  }
  return (char *)0x0;
}



// WARNING: Unknown calling convention

char * SNACopy(char **dest,char *src,wchar_t n)

{
  char *pcVar1;
  FILE *__stream;
  
  if (*dest != (char *)0x0) {
    free(*dest);
    *dest = (char *)0x0;
  }
  if (src != (char *)0x0) {
    pcVar1 = (char *)malloc(n + L'\x01');
    *dest = pcVar1;
    if (*dest == (char *)0x0) {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"Tried to malloc %d bytes\n",n);
      }
      outofmem("./LYStrings.c","SNACopy");
    }
    strncpy(*dest,src,n);
    (*dest)[n] = '\0';
  }
  return *dest;
}



// WARNING: Unknown calling convention

char * SNACat(char **dest,char *src,wchar_t n)

{
  size_t sVar1;
  char *pcVar2;
  wchar_t length;
  
  if ((src != (char *)0x0) && (*src != '\0')) {
    if (*dest == (char *)0x0) {
      pcVar2 = (char *)malloc(n + L'\x01');
      *dest = pcVar2;
      if (*dest == (char *)0x0) {
        outofmem("./LYStrings.c","SNACat");
      }
      memcpy(*dest,src,n);
      (*dest)[n] = '\0';
    }
    else {
      sVar1 = strlen(*dest);
      pcVar2 = (char *)realloc(*dest,sVar1 + n + 1);
      *dest = pcVar2;
      if (*dest == (char *)0x0) {
        outofmem("./LYStrings.c","SNACat");
      }
      strncpy(*dest + sVar1,src,n);
      (*dest)[sVar1 + n] = '\0';
    }
  }
  return *dest;
}



// WARNING: Unknown calling convention

long UniToLowerCase(long upper)

{
  size_t sVar1;
  int iVar2;
  uint local_18;
  long diff;
  size_t low;
  size_t high;
  size_t i;
  
  if (upper < 1) {
    local_18 = upper;
  }
  else {
    low = 0;
    high = 0x2c1;
    do {
      if (high <= low) {
        return upper;
      }
      sVar1 = (high - low >> 1) + low;
      iVar2 = (uint)unicode_to_lower_case[sVar1].upper - upper;
      if (iVar2 < 0) {
        low = sVar1 + 1;
      }
      if (0 < iVar2) {
        high = sVar1;
      }
    } while ((uint)unicode_to_lower_case[sVar1].upper != upper);
    local_18 = (uint)unicode_to_lower_case[sVar1].lower;
  }
  return local_18;
}



// WARNING: Unknown calling convention

wchar_t UPPER8(wchar_t ch1,wchar_t ch2)

{
  char ch_in;
  char ch_in_00;
  ushort **ppuVar1;
  UCode_t upper;
  UCode_t upper_00;
  long lVar2;
  long lVar3;
  wchar_t local_2c;
  uint local_28;
  uint local_24;
  uint local_20;
  uint local_1c;
  long uni_ch1;
  long uni_ch2;
  
  if (ch1 == ch2) {
    local_2c = L'\0';
  }
  else if (ch2 == L'\0') {
    local_2c = ch1 & 0xff;
  }
  else if (ch1 == L'\0') {
    local_2c = -(ch2 & 0xffU);
  }
  else {
    ch_in = (char)ch1;
    ch_in_00 = (char)ch2;
    if ((ch_in < '\0') || (ch_in_00 < '\0')) {
      if ((ch_in < '\0') && (ch_in_00 < '\0')) {
        if (DisplayCharsetMatchLocale == '\0') {
          upper = UCTransToUni(ch_in_00,current_char_set);
          if (upper < 0) {
            local_2c = ch1 & 0xff;
          }
          else {
            upper_00 = UCTransToUni(ch_in,current_char_set);
            lVar2 = UniToLowerCase(upper_00);
            lVar3 = UniToLowerCase(upper);
            local_2c = lVar2 - lVar3;
          }
        }
        else {
          ppuVar1 = __ctype_b_loc();
          if (((*ppuVar1)[ch1 & 0xff] & 0x200) == 0) {
            local_20 = ch1 & 0xff;
          }
          else {
            local_20 = toupper(ch1 & 0xff);
          }
          ppuVar1 = __ctype_b_loc();
          if (((*ppuVar1)[ch2 & 0xff] & 0x200) == 0) {
            local_1c = ch2 & 0xff;
          }
          else {
            local_1c = toupper(ch2 & 0xff);
          }
          local_2c = local_20 - local_1c;
        }
      }
      else {
        local_2c = L'\xfffffff6';
      }
    }
    else {
      ppuVar1 = __ctype_b_loc();
      if (((*ppuVar1)[ch1 & 0xff] & 0x200) == 0) {
        local_28 = ch1 & 0xff;
      }
      else {
        local_28 = toupper(ch1 & 0xff);
      }
      ppuVar1 = __ctype_b_loc();
      if (((*ppuVar1)[ch2 & 0xff] & 0x200) == 0) {
        local_24 = ch2 & 0xff;
      }
      else {
        local_24 = toupper(ch2 & 0xff);
      }
      local_2c = local_28 - local_24;
    }
  }
  return local_2c;
}



char * LYSafeGets(char **src,FILE *fp)

{
  int iVar1;
  char *pcVar2;
  int iVar3;
  int in_GS_OFFSET;
  FILE *fp_local;
  char **src_local;
  char *result;
  char buffer [8192];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  result = (char *)0x0;
  if (src != (char **)0x0) {
    result = *src;
  }
  if (result != (char *)0x0) {
    *result = '\0';
  }
  do {
    pcVar2 = fgets(buffer,0x2000,(FILE *)fp);
    if (pcVar2 == (char *)0x0) break;
    if (buffer[0] != '\0') {
      result = HTSACat(&result,buffer);
    }
    pcVar2 = strchr(buffer,10);
  } while (pcVar2 == (char *)0x0);
  iVar3 = ferror((FILE *)fp);
  if (iVar3 == 0) {
    iVar3 = feof((FILE *)fp);
    if ((((iVar3 != 0) && (result != (char *)0x0)) && (*result == '\0')) && (result != (char *)0x0))
    {
      free(result);
      result = (char *)0x0;
    }
  }
  else if (result != (char *)0x0) {
    free(result);
    result = (char *)0x0;
  }
  if (src != (char **)0x0) {
    *src = result;
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return result;
}



// WARNING: Unknown calling convention

void LYOpenCmdLogfile(wchar_t argc,char **argv)

{
  char *pcVar1;
  wchar_t n;
  
  if (lynx_cmd_logfile != (char *)0x0) {
    cmd_logfile = LYNewTxtFile(lynx_cmd_logfile);
    if (cmd_logfile != (FILE *)0x0) {
      pcVar1 = LYVersionDate();
      fprintf((FILE *)cmd_logfile,"# Command logfile created by %s %s (%s)\n",&DAT_0814bcf0,
              "2.8.7dev.11",pcVar1);
      for (n = L'\0'; n < argc; n = n + L'\x01') {
        fprintf((FILE *)cmd_logfile,"# Arg%d = %s\n",n,argv[n],pcVar1);
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

BOOLEAN LYHaveCmdScript(void)

{
  return cmd_script != (FILE *)0x0;
}



// WARNING: Unknown calling convention

void LYOpenCmdScript(void)

{
  char *pcVar1;
  FILE *__stream;
  char *local_c;
  
  if (lynx_cmd_script != (char *)0x0) {
    cmd_script = (FILE *)fopen64(lynx_cmd_script,"r");
    pcVar1 = lynx_cmd_script;
    if (WWW_TraceFlag != '\0') {
      if (cmd_script == (FILE *)0x0) {
        local_c = "FAIL";
      }
      else {
        local_c = "SUCCESS";
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"LYOpenCmdScript(%s) %s\n",pcVar1,local_c);
    }
  }
  return;
}



// WARNING: Unknown calling convention

wchar_t LYReadCmdKey(wchar_t mode)

{
  char *buffer_00;
  ushort **ppuVar1;
  char *pcVar2;
  int iVar3;
  FILE *pFVar4;
  uint len;
  char *tmp;
  char *src;
  char *buffer;
  wchar_t ch;
  
  ch = L'\xffffffff';
  if (cmd_script == (FILE *)0x0) {
    ch = LYgetch_for(mode);
  }
  else {
    buffer = (char *)0x0;
    while (ch < L'\0') {
      pcVar2 = LYSafeGets(&buffer,cmd_script);
      if (pcVar2 == (char *)0x0) break;
      LYTrimTrailing(buffer);
      pcVar2 = LYSkipBlanks(buffer);
      buffer_00 = LYSkipNonBlanks(pcVar2);
      if ((int)buffer_00 - (int)pcVar2 == 3) {
        iVar3 = strncasecomp(pcVar2,"key",3);
        if (iVar3 == 0) {
          pcVar2 = LYSkipBlanks(buffer_00);
          ch = LYStringToKeycode(pcVar2);
        }
        else {
          iVar3 = strncasecomp(pcVar2,"set",3);
          if (iVar3 == 0) {
            pcVar2 = LYSkipBlanks(buffer_00);
            for (tmp = pcVar2; *tmp != '\0'; tmp = tmp + 1) {
              ppuVar1 = __ctype_b_loc();
              if ((((*ppuVar1)[(byte)*tmp] & 0x2000) != 0) || (*tmp == '=')) break;
            }
            if (*tmp != '\0') {
              *tmp = '\0';
              tmp = LYSkipBlanks(tmp + 1);
            }
            if (WWW_TraceFlag != '\0') {
              pFVar4 = TraceFP();
              fprintf((FILE *)pFVar4,"LYSetConfigValue(%s, %s)\n",pcVar2,tmp);
            }
            LYSetConfigValue(pcVar2,tmp);
          }
        }
      }
      else if ((int)buffer_00 - (int)pcVar2 == 4) {
        iVar3 = strncasecomp(pcVar2,"exit",4);
        if (iVar3 == 0) {
          exit_immediately(0);
        }
      }
    }
    iVar3 = feof((FILE *)cmd_script);
    if (iVar3 != 0) {
      fclose((FILE *)cmd_script);
      cmd_script = (FILE *)0x0;
    }
    if (L'\xffffffff' < ch) {
      LYSleepReplay();
      LYrefresh();
    }
    if (buffer != (char *)0x0) {
      free(buffer);
      buffer = (char *)0x0;
    }
  }
  if (WWW_TraceFlag != '\0') {
    pcVar2 = LYKeycodeToString(ch,'\x01');
    pFVar4 = TraceFP();
    fprintf((FILE *)pFVar4,"LYReadCmdKey(%d) ->%s (%#x)\n",mode,pcVar2,ch);
  }
  LYWriteCmdKey(ch);
  return ch;
}



// WARNING: Unknown calling convention

void LYWriteCmdKey(wchar_t ch)

{
  char *pcVar1;
  
  if (cmd_logfile != (FILE *)0x0) {
    pcVar1 = LYKeycodeToString(ch,'\0');
    fprintf((FILE *)cmd_logfile,"key %s\n",pcVar1);
  }
  return;
}



// WARNING: Unknown calling convention

void LYCloseCmdLogfile(void)

{
  if (cmd_logfile != (FILE *)0x0) {
    LYCloseOutput(cmd_logfile);
    cmd_logfile = (FILE *)0x0;
  }
  if (cmd_script != (FILE *)0x0) {
    LYCloseInput(cmd_script);
    cmd_script = (FILE *)0x0;
  }
  if (lynx_cmd_logfile != (char *)0x0) {
    free(lynx_cmd_logfile);
    lynx_cmd_logfile = (char *)0x0;
  }
  if (lynx_cmd_script != (char *)0x0) {
    free(lynx_cmd_script);
    lynx_cmd_script = (char *)0x0;
  }
  return;
}



// WARNING: Unknown calling convention

void terminate_letter(wchar_t sig)

{
  term_letter = '\x01';
  signal(2,terminate_letter);
  return;
}



// WARNING: Unknown calling convention

void SafeHTUnEscape(char *string)

{
  bool bVar1;
  ushort **ppuVar2;
  char *Msg;
  wchar_t flg;
  wchar_t i;
  
  bVar1 = false;
  HTUnEscape(string);
  i = L'\0';
  do {
    if (string[i] == '\0') {
      if (bVar1) {
        Msg = (char *)gettext("Warning!  Control codes in mail address replaced by ?");
        HTAlert(Msg);
      }
      return;
    }
    if (string[i] < '\0') {
LAB_080570b0:
      string[i] = '?';
      bVar1 = true;
    }
    else {
      ppuVar2 = __ctype_b_loc();
      if (((*ppuVar2)[(byte)string[i]] & 0x4000) == 0) goto LAB_080570b0;
    }
    i = i + L'\x01';
  } while( true );
}



// WARNING: Unknown calling convention

void remove_tildes(char *string)

{
  if (*string == '~') {
    *string = ' ';
  }
  return;
}



// WARNING: Unknown calling convention

void comma_append(char **dst,char *src)

{
  ushort **ppuVar1;
  
  if (*src != '\0') {
    while ((*src == ',' || (ppuVar1 = __ctype_b_loc(), ((*ppuVar1)[(byte)*src] & 0x2000) != 0))) {
      src = src + 1;
    }
    if (*src != '\0') {
      if ((*dst == (char *)0x0) || (**dst == '\0')) {
        HTSACopy(dst,src);
      }
      else {
        HTSACat(dst,",");
        HTSACat(dst,src);
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

void extract_field(char **dst,char *src,char *keyword)

{
  char *__s;
  size_t n;
  int iVar1;
  FILE *__stream;
  char *local_18;
  char *cp1;
  char *cp;
  wchar_t len;
  
  n = strlen(keyword);
  for (cp = src + 1; *cp != '\0'; cp = cp + 1) {
    if ((cp[-1] == '?') || (cp[-1] == '&')) {
      iVar1 = strncasecomp(cp,keyword,n);
      if (iVar1 == 0) {
        __s = cp + n;
        cp = strchr(__s,0x26);
        if (cp != (char *)0x0) {
          *cp = '\0';
        }
        comma_append(dst,__s);
        if (cp == (char *)0x0) break;
        *cp = '&';
      }
    }
  }
  if (WWW_TraceFlag != '\0') {
    if (*dst == (char *)0x0) {
      local_18 = "(null)";
    }
    else {
      local_18 = *dst;
    }
    __stream = TraceFP();
    fprintf((FILE *)__stream,"extract_field(%s) = \'%s\'\n",keyword,local_18);
  }
  return;
}



// WARNING: Unknown calling convention

void extract_subject(char *dst,char *src)

{
  char *__s;
  size_t n;
  int iVar1;
  char *pcVar2;
  FILE *__stream;
  char *local_18;
  char *cp1;
  char *cp;
  wchar_t len;
  char *keyword;
  
  n = strlen("subject=");
  for (cp = src + 1; *cp != '\0'; cp = cp + 1) {
    if ((cp[-1] == '?') || (cp[-1] == '&')) {
      iVar1 = strncasecomp(cp,"subject=",n);
      if (iVar1 == 0) break;
    }
  }
  if (*cp != '\0') {
    __s = cp + n;
    pcVar2 = strchr(__s,0x26);
    if (pcVar2 != (char *)0x0) {
      *pcVar2 = '\0';
    }
    if (*__s != '\0') {
      strncpy(dst,__s,0x46);
      dst[0x46] = '\0';
      SafeHTUnEscape(dst);
    }
    if (pcVar2 != (char *)0x0) {
      *pcVar2 = '&';
    }
  }
  if (WWW_TraceFlag != '\0') {
    if (dst == (char *)0x0) {
      local_18 = "(null)";
    }
    else {
      local_18 = dst;
    }
    __stream = TraceFP();
    fprintf((FILE *)__stream,"extract_subject(%s) = \'%s\'\n","subject=",local_18);
  }
  return;
}



// WARNING: Unknown calling convention

void extract_body(char **dst,char *src)

{
  int iVar1;
  FILE *__stream;
  char *local_28;
  char *temp;
  char *cp1;
  char *cp0;
  char *cp;
  wchar_t i;
  wchar_t len;
  char *keyword;
  
  keyword = "body=";
  len = strlen("body=");
  temp = (char *)0x0;
  for (cp = src + 1; *cp != '\0'; cp = cp + 1) {
    if ((cp[-1] == '?') || (cp[-1] == '&')) {
      iVar1 = strncasecomp(cp,keyword,len);
      if (iVar1 == 0) {
        cp = cp + len;
        cp1 = strchr(cp,0x26);
        if (cp1 != (char *)0x0) {
          *cp1 = '\0';
        }
        if (*cp != '\0') {
          HTSACopy(&temp,cp);
          HTUnEscape(temp);
          cp0 = temp;
          while( true ) {
            cp = strchr(cp0,10);
            if (cp == (char *)0x0) break;
            *cp = '\0';
            if ((cp0 < cp) && (cp[-1] == '\r')) {
              cp[-1] = '\0';
            }
            i = L'\0';
            len = strlen(cp0);
            while (L'N' < len) {
              HTSprintf(dst,"%.78s\n",cp0 + i);
              i = i + L'N';
              len = strlen(cp0 + i);
            }
            HTSprintf(dst,"%s\n",cp0 + i);
            cp0 = cp + 1;
          }
          i = L'\0';
          len = strlen(cp0);
          while (L'N' < len) {
            HTSprintf(dst,"%.78s\n",cp0 + i);
            i = i + L'N';
            len = strlen(cp0 + i);
          }
          if (len != L'\0') {
            HTSprintf(dst,"%s\n",cp0 + i);
          }
          if (temp != (char *)0x0) {
            free(temp);
            temp = (char *)0x0;
          }
        }
        if (cp1 == (char *)0x0) break;
        *cp1 = '&';
        cp = cp1;
        cp1 = (char *)0x0;
      }
    }
  }
  if (WWW_TraceFlag != '\0') {
    if (*dst == (char *)0x0) {
      local_28 = "(null)";
    }
    else {
      local_28 = *dst;
    }
    __stream = TraceFP();
    fprintf((FILE *)__stream,"extract_body(%s) = \'%s\'\n",keyword,local_28);
  }
  return;
}



// WARNING: Unknown calling convention

BOOLEAN trim_comma(char *address)

{
  size_t sVar1;
  
  sVar1 = strlen(address);
  if (address[sVar1 - 1] == ',') {
    sVar1 = strlen(address);
    address[sVar1 - 1] = '\0';
  }
  return *address == '\0';
}



// WARNING: Unknown calling convention

BOOLEAN convert_explorer(char *address)

{
  BOOLEAN BVar1;
  char *pcVar2;
  char *cp1;
  char *cp0;
  char *cp;
  
  cp = address;
  while( true ) {
    pcVar2 = strchr(cp,0x40);
    if (pcVar2 == (char *)0x0) break;
    cp1 = pcVar2 + 1;
    pcVar2 = strchr(cp1,0x3b);
    if (pcVar2 != (char *)0x0) {
      *pcVar2 = ',';
      cp1 = pcVar2 + 1;
    }
    cp = cp1;
  }
  BVar1 = trim_comma(address);
  return BVar1;
}



wchar_t header_prompt(char *label,char **result,uint limit)

{
  int iVar1;
  char *pcVar2;
  size_t sVar3;
  wchar_t wVar4;
  int in_GS_OFFSET;
  wchar_t local_424;
  char **result_local;
  char *label_local;
  wchar_t ok;
  char buffer [1024];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if (*result == (char *)0x0) {
    buffer[0] = '\0';
  }
  else {
    pcVar2 = (char *)gettext(" Use Control-U to erase the default.\n");
    sVar3 = strlen(pcVar2);
    pcVar2 = (char *)gettext(" Use Control-U to erase the default.\n");
    LYwaddnstr(LYwin,pcVar2,sVar3);
    LYstrncpy(buffer,*result,L'');
  }
  if (0x400 < limit) {
    limit = 0x400;
  }
  pcVar2 = (char *)gettext(label);
  sVar3 = strlen(pcVar2);
  pcVar2 = (char *)gettext(label);
  LYwaddnstr(LYwin,pcVar2,sVar3);
  LYwaddnstr(LYwin,": ",2);
  wVar4 = LYgetstr(buffer,L'\0',limit,NORECALL);
  if ((wVar4 < L'\0') || (term_letter != '\0')) {
    local_424 = L'\0';
  }
  else {
    local_424 = L'\x01';
  }
  LYwaddnstr(LYwin,"\n",1);
  if (local_424 != L'\0') {
    remove_tildes(buffer);
    HTSACopy(result,buffer);
  }
  term_letter = '\0';
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return local_424;
}



// WARNING: Unknown calling convention

void show_addresses(char *addresses)

{
  char *pcVar1;
  size_t sVar2;
  char *cp1;
  char *cp;
  
  cp = addresses;
  while( true ) {
    pcVar1 = strchr(cp,0x2c);
    if (pcVar1 == (char *)0x0) break;
    *pcVar1 = '\0';
    for (; *cp == ' '; cp = cp + 1) {
    }
    if (*cp != '\0') {
      sVar2 = strlen(cp);
      LYwaddnstr(LYwin,cp,sVar2);
      LYwaddnstr(LYwin,",\n  ",4);
    }
    *pcVar1 = ',';
    cp = pcVar1 + 1;
  }
  if (*cp != '\0') {
    sVar2 = strlen(cp);
    LYwaddnstr(LYwin,cp,sVar2);
  }
  return;
}



// WARNING: Unknown calling convention

FILE * LYPipeToMailer(void)

{
  char *pcVar1;
  BOOLEAN BVar2;
  FILE *__stream;
  undefined *local_1c;
  FILE *fp;
  char *buffer;
  
  buffer = (char *)0x0;
  fp = (FILE *)0x0;
  BVar2 = LYSystemMail();
  if (BVar2 != '\0') {
    HTSprintf0(&buffer,"%s %s",system_mail,system_mail_flags);
    fp = (FILE *)popen(buffer,"w");
    pcVar1 = buffer;
    if (WWW_TraceFlag != '\0') {
      if (fp == (FILE *)0x0) {
        local_1c = &DAT_0814be8b;
      }
      else {
        local_1c = &DAT_0814be88;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"popen(%s) %s\n",pcVar1,local_1c);
    }
    if (buffer != (char *)0x0) {
      free(buffer);
    }
  }
  return fp;
}



void mailform(char *mailto_address,char *mailto_subject,char *mailto_content,char *mailto_type)

{
  int iVar1;
  BOOLEAN BVar2;
  FILE *pFVar3;
  char *pcVar4;
  wchar_t wVar5;
  int in_GS_OFFSET;
  char *local_2f8;
  char *local_2f4;
  char *local_2f0;
  char *local_2ec;
  char *local_2e8;
  char *mailto_type_local;
  char *mailto_content_local;
  char *mailto_subject_local;
  char *mailto_address_local;
  wchar_t i;
  wchar_t len;
  wchar_t ch;
  char *searchpart;
  char *cp;
  char *keywords;
  char *ccaddr;
  char *address;
  FILE *fd;
  char buf [512];
  char subject [80];
  char self [80];
  
  mailto_content_local = mailto_content;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  address = (char *)0x0;
  ccaddr = (char *)0x0;
  keywords = (char *)0x0;
  cp = (char *)0x0;
  searchpart = (char *)0x0;
  if (WWW_TraceFlag != '\0') {
    if (mailto_address == (char *)0x0) {
      local_2f8 = "(null)";
    }
    else {
      local_2f8 = mailto_address;
    }
    pFVar3 = TraceFP();
    fprintf((FILE *)pFVar3,"mailto_address: \"%s\"\n",local_2f8);
  }
  if (WWW_TraceFlag != '\0') {
    if (mailto_subject == (char *)0x0) {
      local_2f4 = "(null)";
    }
    else {
      local_2f4 = mailto_subject;
    }
    pFVar3 = TraceFP();
    fprintf((FILE *)pFVar3,"mailto_subject: \"%s\"\n",local_2f4);
  }
  if (WWW_TraceFlag != '\0') {
    if (mailto_content == (char *)0x0) {
      local_2f0 = "(null)";
    }
    else {
      local_2f0 = mailto_content;
    }
    pFVar3 = TraceFP();
    fprintf((FILE *)pFVar3,"mailto_content: \"%s\"\n",local_2f0);
  }
  if (WWW_TraceFlag != '\0') {
    if (mailto_type == (char *)0x0) {
      local_2ec = "(null)";
    }
    else {
      local_2ec = mailto_type;
    }
    pFVar3 = TraceFP();
    fprintf((FILE *)pFVar3,"mailto_type:    \"%s\"\n",local_2ec);
  }
  BVar2 = LYSystemMail();
  if (BVar2 == '\0') goto LAB_0805841a;
  if ((mailto_address == (char *)0x0) || (mailto_content == (char *)0x0)) {
    pcVar4 = (char *)gettext("Malformed mailto form submission!  Cancelled!");
    HTAlert(pcVar4);
    goto LAB_0805841a;
  }
  subject[0] = '\0';
  self[0] = '\0';
  cp = strchr(mailto_address,10);
  if (cp != (char *)0x0) {
    *cp = '\0';
  }
  HTSACopy(&address,mailto_address);
  cp = strchr(address,0x3f);
  if (cp != (char *)0x0) {
    HTSACopy(&searchpart,cp);
    *cp = '\0';
    cp = searchpart + 1;
    if (*cp != '\0') {
      extract_subject(subject,searchpart);
      extract_field(&address,searchpart,"to=");
      extract_field(&ccaddr,searchpart,"cc=");
      extract_field(&keywords,searchpart,"keywords=");
      if (keywords != (char *)0x0) {
        if (*keywords == '\0') {
          if (keywords != (char *)0x0) {
            free(keywords);
            keywords = (char *)0x0;
          }
        }
        else {
          SafeHTUnEscape(keywords);
        }
      }
      if (searchpart != (char *)0x0) {
        free(searchpart);
        searchpart = (char *)0x0;
      }
    }
  }
  BVar2 = convert_explorer(address);
  if (BVar2 == '\0') {
    if (ccaddr != (char *)0x0) {
      BVar2 = convert_explorer(ccaddr);
      if ((BVar2 != '\0') && (ccaddr != (char *)0x0)) {
        free(ccaddr);
        ccaddr = (char *)0x0;
      }
    }
    SafeHTUnEscape(address);
    if (ccaddr != (char *)0x0) {
      SafeHTUnEscape(ccaddr);
    }
    if (subject[0] == '\0') {
      if ((mailto_subject == (char *)0x0) || (*mailto_subject == '\0')) {
        sprintf(subject,"mailto:%.63s",address);
      }
      else {
        LYstrncpy(subject,mailto_subject,L'F');
      }
    }
    mustshow = '\x01';
    pcVar4 = (char *)gettext("Subject: ");
    statusline(pcVar4);
    wVar5 = LYgetstr(subject,L'\0',0x46,NORECALL);
    if (wVar5 < L'\0') {
      pcVar4 = (char *)gettext("Mailto form submission Cancelled!!!");
      HTInfoMsg(pcVar4);
    }
    else {
      if (LYNoCc == '\0') {
        if ((personal_mail_address == (char *)0x0) || (*personal_mail_address == '\0')) {
          local_2e8 = "";
        }
        else {
          local_2e8 = personal_mail_address;
        }
        sprintf(self,"%.*s",0x46,local_2e8);
        mustshow = '\x01';
        statusline("Cc: ");
        wVar5 = LYgetstr(self,L'\0',0x46,NORECALL);
        if (wVar5 < L'\0') {
          pcVar4 = (char *)gettext("Mailto form submission Cancelled!!!");
          HTInfoMsg(pcVar4);
          goto cleanup;
        }
        remove_tildes(self);
        if (ccaddr == (char *)0x0) {
          HTSACopy(&ccaddr,self);
        }
        else {
          HTSACat(&ccaddr,",");
          HTSACat(&ccaddr,self);
        }
      }
      fd = LYPipeToMailer();
      if (fd == (FILE *)0x0) {
        pcVar4 = (char *)gettext("Mailto form submission failed!");
        HTAlert(pcVar4);
      }
      else {
        if ((mailto_type != (char *)0x0) && (*mailto_type != '\0')) {
          fwrite("Mime-Version: 1.0\n",1,0x12,(FILE *)fd);
          fprintf((FILE *)fd,"Content-Type: %s\n",mailto_type);
        }
        fprintf((FILE *)fd,"To: %s\n",address);
        if ((personal_mail_address != (char *)0x0) && (*personal_mail_address != '\0')) {
          fprintf((FILE *)fd,"From: %s\n",personal_mail_address);
        }
        if ((ccaddr != (char *)0x0) && (*ccaddr != '\0')) {
          fprintf((FILE *)fd,"Cc: %s\n",ccaddr);
        }
        fprintf((FILE *)fd,"Subject: %s\n\n",subject);
        if ((keywords != (char *)0x0) && (*keywords != '\0')) {
          fprintf((FILE *)fd,"Keywords: %s\n",keywords);
        }
        mustshow = '\x01';
        pcVar4 = (char *)gettext("Sending form content...");
        statusline(pcVar4);
        while( true ) {
          cp = strchr(mailto_content_local,10);
          if (cp == (char *)0x0) break;
          *cp = '\0';
          i = L'\0';
          len = strlen(mailto_content_local);
          while (L'N' < len) {
            strncpy(buf,mailto_content_local + i,0x4e);
            buf[78] = '\0';
            fprintf((FILE *)fd,"%s\n",buf);
            i = i + L'N';
            len = strlen(mailto_content_local + i);
          }
          fprintf((FILE *)fd,"%s\n",mailto_content_local + i);
          mailto_content_local = cp + 1;
        }
        i = L'\0';
        len = strlen(mailto_content_local);
        while (L'N' < len) {
          strncpy(buf,mailto_content_local + i,0x4e);
          buf[78] = '\0';
          fprintf((FILE *)fd,"%s\n",buf);
          i = i + L'N';
          len = strlen(mailto_content_local + i);
        }
        if (len != L'\0') {
          fprintf((FILE *)fd,"%s\n",mailto_content_local + i);
        }
        pclose((FILE *)fd);
        LYSleepMsg();
      }
    }
  }
  else {
    pcVar4 = (char *)gettext("Malformed mailto form submission!  Cancelled!");
    HTAlert(pcVar4);
  }
cleanup:
  if (address != (char *)0x0) {
    free(address);
    address = (char *)0x0;
  }
  if (ccaddr != (char *)0x0) {
    free(ccaddr);
    ccaddr = (char *)0x0;
  }
  if (keywords != (char *)0x0) {
    free(keywords);
    keywords = (char *)0x0;
  }
LAB_0805841a:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



// WARNING: Unknown calling convention

void mailmsg(wchar_t cur,char *owner_address,char *filename,char *linkname)

{
  BOOLEAN BVar1;
  char *pcVar2;
  int iVar3;
  FILE *pFVar4;
  char *__format;
  char *pcVar5;
  undefined4 uVar6;
  FILE *ofp;
  char *cp;
  char *cmd;
  char *searchpart;
  char *address;
  FILE *fp;
  FILE *fd;
  
  address = (char *)0x0;
  searchpart = (char *)0x0;
  cmd = (char *)0x0;
  BVar1 = LYSystemMail();
  if (((BVar1 != '\0') && (owner_address != (char *)0x0)) && (*owner_address != '\0')) {
    pcVar2 = strchr(owner_address,10);
    if (pcVar2 != (char *)0x0) {
      *pcVar2 = '\0';
    }
    iVar3 = strncasecomp(owner_address,"lynx-dev@",9);
    if (iVar3 != 0) {
      HTSACopy(&address,owner_address);
      pcVar2 = strchr(address,0x3f);
      if (pcVar2 != (char *)0x0) {
        HTSACopy(&searchpart,pcVar2);
        *pcVar2 = '\0';
        if (searchpart[1] != '\0') {
          extract_field(&address,searchpart,"to=");
        }
      }
      convert_explorer(address);
      SafeHTUnEscape(address);
      BVar1 = trim_comma(address);
      if (BVar1 == '\0') {
        fd = LYPipeToMailer();
        if (fd == (FILE *)0x0) {
          if (address != (char *)0x0) {
            free(address);
            address = (char *)0x0;
          }
          pcVar2 = cmd;
          if (WWW_TraceFlag != '\0') {
            pFVar4 = TraceFP();
            fprintf((FILE *)pFVar4,"mailmsg: \'%s\' failed.\n",pcVar2);
          }
        }
        else {
          fprintf((FILE *)fd,"To: %s\n",address);
          fprintf((FILE *)fd,"Subject: Lynx Error in %s\n",filename);
          if ((personal_mail_address != (char *)0x0) && (*personal_mail_address != '\0')) {
            fprintf((FILE *)fd,"Cc: %s\n",personal_mail_address);
          }
          fprintf((FILE *)fd,"X-URL: %s\n",filename);
          fprintf((FILE *)fd,"X-Mailer: %s, Version %s\n\n",&DAT_0814c083,"2.8.7dev.11");
          pcVar2 = links[cur].target;
          pcVar5 = links[cur].lname;
          __format = (char *)gettext("The link   %s :?: %s \n");
          fprintf((FILE *)fd,__format,pcVar5,pcVar2);
          pcVar2 = LYGetHiliteStr(cur,L'\0');
          pcVar5 = (char *)gettext("called \"%s\"\n");
          fprintf((FILE *)fd,pcVar5,pcVar2);
          pcVar2 = (char *)gettext("in the file \"%s\" called \"%s\"\n");
          fprintf((FILE *)fd,pcVar2,filename,linkname);
          uVar6 = gettext("was requested but was not available.");
          fprintf((FILE *)fd,"%s\n\n",uVar6);
          uVar6 = gettext("Thought you might want to know.");
          fprintf((FILE *)fd,"%s\n\n",uVar6);
          uVar6 = gettext("This message was automatically generated by");
          fprintf((FILE *)fd,"%s\n",uVar6);
          fprintf((FILE *)fd,"%s %s",&DAT_0814c083,"2.8.7dev.11");
          if (LynxSigFile != (char *)0x0) {
            fp = (FILE *)fopen64(LynxSigFile,"r");
            if (fp != (FILE *)0x0) {
              fwrite(&DAT_0814c162,1,4,(FILE *)fd);
              while( true ) {
                pcVar2 = LYSafeGets(&cmd,fp);
                if (pcVar2 == (char *)0x0) break;
                fputs(cmd,(FILE *)fd);
              }
              LYCloseInput(fp);
            }
          }
          pclose((FILE *)fd);
          if (traversal != '\0') {
            ofp = LYAppendToTxtFile("traverse.errors");
            if (ofp == (FILE *)0x0) {
              ofp = LYNewTxtFile("traverse.errors");
              if (ofp == (FILE *)0x0) {
                pcVar2 = (char *)gettext("Unable to open traversal errors output file");
                perror(pcVar2);
                exit_immediately(1);
              }
            }
            fprintf((FILE *)ofp,"%s\t%s \tin %s\n",links[cur].lname,links[cur].target,filename);
            LYCloseOutput(ofp);
          }
          if (address != (char *)0x0) {
            free(address);
          }
        }
      }
      else {
        if (address != (char *)0x0) {
          free(address);
          address = (char *)0x0;
        }
        if (WWW_TraceFlag != '\0') {
          pFVar4 = TraceFP();
          fprintf((FILE *)pFVar4,"mailmsg: No address in \'%s\'.\n",owner_address);
        }
      }
    }
  }
  return;
}



void reply_by_mail(char *mail_address,char *filename,char *title,char *refid)

{
  int iVar1;
  LYKeymap_t LVar2;
  BOOLEAN BVar3;
  FILE *pFVar4;
  char *pcVar5;
  int iVar6;
  size_t sVar7;
  wchar_t wVar8;
  char *pcVar9;
  int in_GS_OFFSET;
  char *local_15d4;
  char *local_15d0;
  char *local_15cc;
  char *local_15c8;
  char local_15c4;
  char *local_15c0;
  char *local_15bc;
  char *refid_local;
  char *title_local;
  char *filename_local;
  char *mail_address_local;
  char *msg;
  wchar_t n;
  char *header;
  wchar_t c;
  wchar_t i;
  char *cp1;
  char *cp;
  char *body;
  char *searchpart;
  char *keywords;
  char *ccaddr;
  char *the_subject;
  char *to_address;
  char *cc_address;
  char *from_address;
  char *label;
  FILE *fp;
  FILE *fd;
  BOOLEAN is_preparsed;
  char buf [4096];
  char user_input [1024];
  char my_tmpfile [256];
  char default_subject [80];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  label = (char *)0x0;
  from_address = (char *)0x0;
  cc_address = (char *)0x0;
  to_address = (char *)0x0;
  the_subject = (char *)0x0;
  ccaddr = (char *)0x0;
  keywords = (char *)0x0;
  searchpart = (char *)0x0;
  body = (char *)0x0;
  cp = (char *)0x0;
  cp1 = (char *)0x0;
  c = L'\0';
  header = (char *)0x0;
  if (WWW_TraceFlag != '\0') {
    if (refid == (char *)0x0) {
      local_15d4 = "(null)";
    }
    else {
      local_15d4 = refid;
    }
    if (title == (char *)0x0) {
      local_15d0 = "(null)";
    }
    else {
      local_15d0 = title;
    }
    if (filename == (char *)0x0) {
      local_15cc = "(null)";
    }
    else {
      local_15cc = filename;
    }
    if (mail_address == (char *)0x0) {
      local_15c8 = "(null)";
    }
    else {
      local_15c8 = mail_address;
    }
    pFVar4 = TraceFP();
    fprintf((FILE *)pFVar4,"reply_by_mail(\"%s\", \"%s\", \"%s\", \"%s\")\n",local_15c8,local_15cc,
            local_15d0,local_15d4);
  }
  term_letter = '\0';
  BVar3 = LYSystemMail();
  if (BVar3 == '\0') goto LAB_0805a0df;
  if ((mail_address == (char *)0x0) || (*mail_address == '\0')) {
    pcVar5 = (char *)gettext("No email address is present in mailto URL!");
    HTAlert(pcVar5);
    goto LAB_0805a0df;
  }
  HTSACopy(&to_address,mail_address);
  fd = LYOpenTemp(my_tmpfile,".txt","w");
  if (fd == (FILE *)0x0) {
    pcVar5 = (char *)gettext("Unable to open temporary file for mailto URL!");
    HTAlert(pcVar5);
    goto LAB_0805a0df;
  }
  default_subject[0] = '\0';
  cp = strchr(to_address,0x3f);
  if (cp != (char *)0x0) {
    HTSACopy(&searchpart,cp);
    *cp = '\0';
    cp = searchpart + 1;
    if (*cp != '\0') {
      extract_subject(default_subject,searchpart);
      extract_field(&to_address,searchpart,"to=");
      extract_field(&ccaddr,searchpart,"cc=");
      extract_field(&keywords,searchpart,"keywords=");
      if (keywords != (char *)0x0) {
        if (*keywords == '\0') {
          if (keywords != (char *)0x0) {
            free(keywords);
            keywords = (char *)0x0;
          }
        }
        else {
          SafeHTUnEscape(keywords);
        }
      }
      extract_body(&body,searchpart);
      if (searchpart != (char *)0x0) {
        free(searchpart);
        searchpart = (char *)0x0;
      }
    }
  }
  BVar3 = convert_explorer(to_address);
  if (BVar3 == '\0') {
    if (((ccaddr != (char *)0x0) && (BVar3 = convert_explorer(ccaddr), BVar3 != '\0')) &&
       (ccaddr != (char *)0x0)) {
      free(ccaddr);
      ccaddr = (char *)0x0;
    }
    SafeHTUnEscape(to_address);
    if (ccaddr != (char *)0x0) {
      SafeHTUnEscape(ccaddr);
    }
    if (((default_subject[0] == '\0') && (title != (char *)0x0)) && (*title != '\0')) {
      strncpy(default_subject,title,0x46);
      default_subject[70] = '\0';
    }
    signal(2,terminate_letter);
    HTSprintf(&header,"To: %s\n",to_address);
    iVar6 = strncasecomp(LYCharSet_UC[current_char_set].MIMEname,"us-ascii",8);
    if (iVar6 != 0) {
      HTSACat(&header,"Mime-Version: 1.0\n");
      if ((LYHaveCJKCharacterSet == '\0') &&
         (iVar6 = strncasecomp(LYCharSet_UC[current_char_set].MIMEname,"x-",2), iVar6 != 0)) {
        HTSprintf(&header,"Content-Type: text/plain; charset=%s\n",
                  LYCharSet_UC[current_char_set].MIMEname);
      }
      HTSACat(&header,"Content-Transfer-Encoding: 8bit\n");
    }
    if ((filename == (char *)0x0) || (*filename == '\0')) {
      HTSprintf(&header,"X-URL: mailto:%s\n",to_address);
    }
    else {
      HTSprintf(&header,"X-URL: %s\n",filename);
    }
    pcVar5 = "2.8.7dev.11";
    HTSprintf(&header,"X-Mailer: %s, Version %s\n",&DAT_0814c083,"2.8.7dev.11");
    if ((refid != (char *)0x0) && (*refid != '\0')) {
      HTSprintf(&header,"In-Reply-To: <%s>\n",refid,pcVar5);
    }
    LYclear();
    LYmove(L'\x02',L'\0');
    scrollok(LYwin,1);
    if (body == (char *)0x0) {
      pcVar5 = (char *)gettext("You are sending a comment to:\n  ");
      sVar7 = strlen(pcVar5);
      pcVar5 = (char *)gettext("You are sending a comment to:\n  ");
      LYwaddnstr(LYwin,pcVar5,sVar7);
    }
    else {
      pcVar5 = (char *)gettext("You are sending a message with body to:\n  ");
      sVar7 = strlen(pcVar5);
      pcVar5 = (char *)gettext("You are sending a message with body to:\n  ");
      LYwaddnstr(LYwin,pcVar5,sVar7);
    }
    show_addresses(to_address);
    cp = ccaddr;
    if (ccaddr != (char *)0x0) {
      pcVar5 = strchr(ccaddr,0x2c);
      if (pcVar5 == (char *)0x0) {
        pcVar5 = (char *)gettext("\n With copy to:\n  ");
        sVar7 = strlen(pcVar5);
        pcVar5 = (char *)gettext("\n With copy to:\n  ");
        LYwaddnstr(LYwin,pcVar5,sVar7);
      }
      else {
        pcVar5 = (char *)gettext("\n With copies to:\n  ");
        sVar7 = strlen(pcVar5);
        pcVar5 = (char *)gettext("\n With copies to:\n  ");
        LYwaddnstr(LYwin,pcVar5,sVar7);
      }
      show_addresses(ccaddr);
    }
    pcVar5 = (char *)gettext("\n\nUse Ctrl-G to cancel if you do not want to send a message\n");
    sVar7 = strlen(pcVar5);
    pcVar5 = (char *)gettext("\n\nUse Ctrl-G to cancel if you do not want to send a message\n");
    LYwaddnstr(LYwin,pcVar5,sVar7);
    pcVar5 = (char *)gettext("\n Please enter your name, or leave it blank to remain anonymous\n");
    sVar7 = strlen(pcVar5);
    pcVar5 = (char *)gettext("\n Please enter your name, or leave it blank to remain anonymous\n");
    LYwaddnstr(LYwin,pcVar5,sVar7);
    label = "X-Personal_Name: ";
    wVar8 = header_prompt("X-Personal_Name: ",&reply_by_mail::personal_name,0x400);
    if (wVar8 == L'\0') goto cancelled;
    if (*reply_by_mail::personal_name != '\0') {
      HTSprintf(&header,"%s: %s\n",label,reply_by_mail::personal_name);
    }
    pcVar5 = (char *)gettext("\n Please enter a mail address or some other\n");
    sVar7 = strlen(pcVar5);
    pcVar5 = (char *)gettext("\n Please enter a mail address or some other\n");
    LYwaddnstr(LYwin,pcVar5,sVar7);
    pcVar5 = (char *)gettext(" means to contact you, if you desire a response.\n");
    sVar7 = strlen(pcVar5);
    pcVar5 = (char *)gettext(" means to contact you, if you desire a response.\n");
    LYwaddnstr(LYwin,pcVar5,sVar7);
    label = "From";
    if (personal_mail_address != (char *)0x0) {
      HTSACopy(&from_address,personal_mail_address);
    }
    wVar8 = header_prompt(label,&from_address,0x400);
    if (wVar8 == L'\0') goto cancelled;
    HTSprintf(&header,"%s: %s\n",label,from_address);
    pcVar5 = (char *)gettext("\n Please enter a subject line.\n");
    sVar7 = strlen(pcVar5);
    pcVar5 = (char *)gettext("\n Please enter a subject line.\n");
    LYwaddnstr(LYwin,pcVar5,sVar7);
    label = "Subject";
    if (default_subject[0] == '\0') {
      if ((filename == (char *)0x0) || (*filename == '\0')) {
        HTSprintf(&the_subject,"mailto:%s",to_address);
      }
      else {
        HTSprintf(&the_subject,"%s",filename);
      }
    }
    else {
      HTSACopy(&the_subject,default_subject);
    }
    wVar8 = header_prompt(label,&the_subject,0x46);
    if (wVar8 == L'\0') goto cancelled;
    if (LYNoCc == '\0') {
      pcVar5 = (char *)gettext("\n Enter a mail address for a CC of your message.\n");
      sVar7 = strlen(pcVar5);
      pcVar5 = (char *)gettext("\n Enter a mail address for a CC of your message.\n");
      LYwaddnstr(LYwin,pcVar5,sVar7);
      pcVar5 = (char *)gettext(" (Leave blank if you don\'t want a copy.)\n");
      sVar7 = strlen(pcVar5);
      pcVar5 = (char *)gettext(" (Leave blank if you don\'t want a copy.)\n");
      LYwaddnstr(LYwin,pcVar5,sVar7);
      if (personal_mail_address != (char *)0x0) {
        HTSACopy(&cc_address,personal_mail_address);
      }
      wVar8 = header_prompt("Cc",&cc_address,0x400);
      if (wVar8 == L'\0') goto cancelled;
      comma_append(&ccaddr,cc_address);
    }
    pcVar5 = the_subject;
    HTSprintf(&header,"%s: %s\n",label,the_subject);
    if ((ccaddr != (char *)0x0) && (*ccaddr != '\0')) {
      HTSprintf(&header,"Cc: %s\n",ccaddr,pcVar5);
    }
    if ((keywords != (char *)0x0) && (*keywords != '\0')) {
      HTSprintf(&header,"Keywords: %s\n",keywords,pcVar5);
    }
    HTSACat(&header,"\n");
    pcVar5 = header;
    if (WWW_TraceFlag != '\0') {
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"**header==\n%s",pcVar5);
    }
    if (((no_editor == '\0') && (editor != (char *)0x0)) && (*editor != '\0')) {
      if (body == (char *)0x0) {
        pcVar5 = HTLoadedDocumentURL();
        if (*pcVar5 != '\0') {
          if ((LYPreparsedSource == '\0') || (wVar8 = HTisDocumentSource(), wVar8 == L'\0')) {
            local_15c4 = '\0';
          }
          else {
            local_15c4 = '\x01';
          }
          is_preparsed = local_15c4;
          if (local_15c4 == '\0') {
            local_15c0 = (char *)gettext("Do you wish to include the original message?");
          }
          else {
            local_15c0 = (char *)gettext("Do you wish to include the preparsed source?");
          }
          BVar3 = HTConfirm(local_15c0);
          if (BVar3 == '\x01') {
            print_wwwfile_to_fd(fd,'\x01',is_preparsed == '\0');
          }
        }
      }
      else {
        cp1 = body;
        while (pcVar5 = strchr(cp1,10), pcVar5 != (char *)0x0) {
          *pcVar5 = '\0';
          cp = pcVar5 + 1;
          fprintf((FILE *)fd,"%s\n",cp1);
          cp1 = cp;
        }
        cp = (char *)0x0;
      }
      LYCloseTempFP(fd);
      scrollok(LYwin,0);
      if (((term_letter == '\0') && (c != L'\x03')) && (c != L'\a')) {
        LVar2 = keymap[0];
        if (c == L'\xffffffff') {
joined_r0x080596e1:
          if (LVar2 == 0x2f) goto cleanup;
        }
        else {
          if ((c & 0x8800U) == 0) {
            LVar2 = keymap[(c & 0x7ffU) + 1];
            goto joined_r0x080596e1;
          }
          if ((c & 0xffU) == 0x2f) goto cleanup;
        }
        pcVar5 = (char *)gettext("Spawning your selected editor to edit mail message");
        edit_temporary_file(my_tmpfile,"",pcVar5);
        goto LAB_08059bc1;
      }
    }
    else {
      if (body == (char *)0x0) {
        pcVar5 = (char *)gettext("\n Please enter your message below.");
        sVar7 = strlen(pcVar5);
        pcVar5 = (char *)gettext("\n Please enter your message below.");
        LYwaddnstr(LYwin,pcVar5,sVar7);
        pcVar5 = (char *)gettext("\n When you are done, press enter and put a single period (.)");
        sVar7 = strlen(pcVar5);
        pcVar5 = (char *)gettext("\n When you are done, press enter and put a single period (.)");
        LYwaddnstr(LYwin,pcVar5,sVar7);
        pcVar5 = (char *)gettext("\n on a line and press enter again.");
        sVar7 = strlen(pcVar5);
        pcVar5 = (char *)gettext("\n on a line and press enter again.");
        LYwaddnstr(LYwin,pcVar5,sVar7);
        LYwaddnstr(LYwin,"\n\n",2);
        LYrefresh();
        user_input[0] = '\0';
        wVar8 = LYgetstr(user_input,L'\0',0x400,NORECALL);
        if (((L'\xffffffff' < wVar8) && (term_letter == '\0')) &&
           (iVar6 = strcmp(user_input,"."), iVar6 != 0)) {
          do {
            iVar6 = strcmp(user_input,".");
            if ((iVar6 == 0) || (term_letter != '\0')) {
              fputc(10,(FILE *)fd);
              LYCloseTempFP(fd);
              scrollok(LYwin,0);
              goto LAB_08059bc1;
            }
            LYwaddnstr(LYwin,"\n",1);
            remove_tildes(user_input);
            fprintf((FILE *)fd,"%s\n",user_input);
            user_input[0] = '\0';
            wVar8 = LYgetstr(user_input,L'\0',0x400,NORECALL);
          } while (L'\xffffffff' < wVar8);
        }
        goto cancelled;
      }
      LYclear();
      LYmove(L'\0',L'\0');
      pcVar5 = (char *)gettext("\n Please review the message body:\n\n");
      sVar7 = strlen(pcVar5);
      pcVar5 = (char *)gettext("\n Please review the message body:\n\n");
      LYwaddnstr(LYwin,pcVar5,sVar7);
      LYrefresh();
      cp1 = body;
      i = LYlines + L'\xfffffffb';
      while (cp = strchr(cp1,10), cp != (char *)0x0) {
        if (i < L'\x01') {
          pcVar5 = (char *)gettext("\nPress RETURN to continue: ");
          sVar7 = strlen(pcVar5);
          pcVar5 = (char *)gettext("\nPress RETURN to continue: ");
          LYwaddnstr(LYwin,pcVar5,sVar7);
          LYrefresh();
          c = LYgetch();
          LYwaddnstr(LYwin,"\n",1);
          if (((term_letter != '\0') || (c == L'\x03')) || (c == L'\a')) goto cancelled;
          LVar2 = keymap[0];
          if (c == L'\xffffffff') {
joined_r0x0805988b:
            if (LVar2 == 0x2f) goto cancelled;
          }
          else {
            if ((c & 0x8800U) == 0) {
              LVar2 = keymap[(c & 0x7ffU) + 1];
              goto joined_r0x0805988b;
            }
            if ((c & 0xffU) == 0x2f) goto cancelled;
          }
          i = LYlines + L'\xfffffffe';
        }
        *cp = '\0';
        cp = cp + 1;
        fprintf((FILE *)fd,"%s\n",cp1);
        sVar7 = strlen(cp1);
        LYwaddnstr(LYwin,cp1,sVar7);
        LYwaddnstr(LYwin,"\n",1);
        cp1 = cp;
        i = i + L'\xffffffff';
      }
      for (; L'\xffffffff' < i; i = i + L'\xffffffff') {
        LYwaddnstr(LYwin,"\n",1);
      }
      LYrefresh();
      LYCloseTempFP(fd);
      scrollok(LYwin,0);
LAB_08059bc1:
      signal(2,(__sighandler_t)0x1);
      LYStatusLine = LYlines + -1;
      if (body == (char *)0x0) {
        local_15bc = (char *)gettext("Send this comment?");
      }
      else {
        local_15bc = (char *)gettext("Send this message?");
      }
      BVar3 = HTConfirm(local_15bc);
      c = (wchar_t)BVar3;
      LYStatusLine = -1;
      if (c == L'\x01') {
        if (((body == (char *)0x0) && (LynxSigFile != (char *)0x0)) &&
           (fp = (FILE *)fopen64(LynxSigFile,"r"), pcVar5 = LynxSigFile, fp != (FILE *)0x0)) {
          LYStatusLine = LYlines + -1;
          if (term_letter == '\0') {
            msg = (char *)0x0;
            pcVar9 = (char *)gettext("Append \'%s\'?");
            HTSprintf0(&msg,pcVar9,pcVar5);
            BVar3 = HTConfirm(msg);
            c = (wchar_t)BVar3;
            if (msg != (char *)0x0) {
              free(msg);
              msg = (char *)0x0;
            }
          }
          else {
            mustshow = '\x01';
            pcVar9 = (char *)gettext("Append \'%s\'?");
            user_message(pcVar9,pcVar5);
            c = L'\0';
          }
          LYStatusLine = -1;
          if ((c == L'\x01') && (fd = (FILE *)fopen64(my_tmpfile,"a+"), fd != (FILE *)0x0)) {
            msg = (char *)0x0;
            fwrite(&DAT_0814c162,1,4,(FILE *)fd);
            while (pcVar5 = LYSafeGets(&msg,fp), pcVar5 != (char *)0x0) {
              fputs(msg,(FILE *)fd);
            }
            LYCloseOutput(fd);
            if (msg != (char *)0x0) {
              free(msg);
              msg = (char *)0x0;
            }
          }
          LYCloseInput(fp);
        }
        LYclear();
        mustshow = '\x01';
        pcVar5 = (char *)gettext("Sending your message...");
        statusline(pcVar5);
        signal(2,(__sighandler_t)0x1);
        fp = LYPipeToMailer();
        if (fp == (FILE *)0x0) {
          pcVar5 = (char *)gettext("Cancelled!!!");
          HTInfoMsg(pcVar5);
        }
        if (fp != (FILE *)0x0) {
          fd = (FILE *)fopen64(my_tmpfile,"r");
          if (fd == (FILE *)0x0) {
            pcVar5 = (char *)gettext("Cancelled!!!");
            HTInfoMsg(pcVar5);
            pclose((FILE *)fp);
          }
          else {
            fputs(header,(FILE *)fp);
            while (n = fread(buf,1,0x1000,(FILE *)fd), n != L'\0') {
              fwrite(buf,1,n,(FILE *)fp);
            }
            pclose((FILE *)fp);
            LYCloseInput(fd);
          }
        }
      }
      else {
        LYclear();
      }
    }
  }
  else {
    pcVar5 = (char *)gettext("No email address is present in mailto URL!");
    HTAlert(pcVar5);
cancelled:
    pcVar5 = (char *)gettext("Cancelled!!!");
    HTInfoMsg(pcVar5);
    LYCloseTempFP(fd);
    scrollok(LYwin,0);
  }
cleanup:
  signal(2,cleanup_sig);
  term_letter = '\0';
  if (header != (char *)0x0) {
    free(header);
    header = (char *)0x0;
  }
  LYRemoveTemp(my_tmpfile);
  if (from_address != (char *)0x0) {
    free(from_address);
    from_address = (char *)0x0;
  }
  if (the_subject != (char *)0x0) {
    free(the_subject);
    the_subject = (char *)0x0;
  }
  if (cc_address != (char *)0x0) {
    free(cc_address);
    cc_address = (char *)0x0;
  }
  if (to_address != (char *)0x0) {
    free(to_address);
    to_address = (char *)0x0;
  }
  if (ccaddr != (char *)0x0) {
    free(ccaddr);
    ccaddr = (char *)0x0;
  }
  if (keywords != (char *)0x0) {
    free(keywords);
    keywords = (char *)0x0;
  }
  if (body != (char *)0x0) {
    free(body);
    body = (char *)0x0;
  }
LAB_0805a0df:
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

BOOLEAN LYSystemMail(void)

{
  int iVar1;
  char *Msg;
  
  if ((system_mail != (char *)0x0) && (iVar1 = strcmp(system_mail,"unknown"), iVar1 != 0)) {
    return '\x01';
  }
  Msg = (char *)gettext("No system mailer configured");
  HTAlert(Msg);
  return '\0';
}



// WARNING: Unknown calling convention

void HTAlert(char *Msg)

{
  FILE *pFVar1;
  char *pcVar2;
  
  if (WWW_TraceFlag != '\0') {
    pFVar1 = TraceFP();
    fprintf((FILE *)pFVar1,"\nAlert!: %s\n\n",Msg);
  }
  if (WWW_TraceFlag != '\0') {
    pFVar1 = TraceFP();
    fflush((FILE *)pFVar1);
  }
  mustshow = '\x01';
  pcVar2 = (char *)gettext("Alert!: %s");
  user_message(pcVar2,Msg);
  pcVar2 = (char *)gettext("Alert!: %s");
  LYstore_message2(pcVar2,Msg);
  if ((dump_output_immediately != '\0') && (dump_to_stderr != '\0')) {
    fflush(stdout);
    pcVar2 = (char *)gettext("Alert!: %s");
    fprintf(stderr,pcVar2,Msg);
    fputc(10,stderr);
    fflush(stderr);
  }
  LYSleepAlert();
  return;
}



// WARNING: Unknown calling convention

void HTAlwaysAlert(char *extra_prefix,char *Msg)

{
  char *pcVar1;
  FILE *pFVar2;
  FILE *local_18;
  char *local_14;
  FILE *local_c;
  FILE *local_8;
  
  if ((dump_output_immediately == '\0') && (LYCursesON != '\0')) {
    HTAlert(Msg);
  }
  else {
    if (extra_prefix == (char *)0x0) {
      if (Msg == (char *)0x0) {
        local_14 = "";
      }
      else {
        local_14 = Msg;
      }
      pcVar1 = (char *)gettext("Alert!: %s");
      if (WWW_TraceFlag == '\0') {
        local_c = stderr;
      }
      else {
        local_c = stdout;
      }
      fprintf(local_c,pcVar1,local_14);
      fflush(stdout);
      pcVar1 = (char *)gettext("Alert!: %s");
      LYstore_message2(pcVar1,Msg);
      LYSleepAlert();
      if (WWW_TraceFlag == '\0') {
        local_8 = stderr;
      }
      else {
        local_8 = stdout;
      }
      fputc(10,local_8);
    }
    else {
      if (WWW_TraceFlag == '\0') {
        local_18 = stderr;
      }
      else {
        local_18 = stdout;
      }
      fprintf(local_18,"%s %s!\n",extra_prefix,Msg);
      fflush(stdout);
      pcVar1 = (char *)gettext("Alert!: %s");
      LYstore_message2(pcVar1,Msg);
      LYSleepAlert();
    }
    if (WWW_TraceFlag != '\0') {
      pFVar2 = TraceFP();
      fprintf((FILE *)pFVar2,"\nAlert!: %s\n\n",Msg);
    }
    if (WWW_TraceFlag != '\0') {
      pFVar2 = TraceFP();
      fflush((FILE *)pFVar2);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void HTInfoMsg(char *Msg)

{
  FILE *__stream;
  
  mustshow = '\x01';
  statusline(Msg);
  if ((Msg != (char *)0x0) && (*Msg != '\0')) {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"Info message: %s\n",Msg);
    }
    LYstore_message(Msg);
    LYSleepInfo();
  }
  return;
}



// WARNING: Unknown calling convention

void HTInfoMsg2(char *Msg2,char *Arg)

{
  FILE *pFVar1;
  
  mustshow = '\x01';
  user_message(Msg2,Arg);
  if ((Msg2 != (char *)0x0) && (*Msg2 != '\0')) {
    if (WWW_TraceFlag != '\0') {
      pFVar1 = TraceFP();
      fprintf((FILE *)pFVar1,"Info message: ");
    }
    if (WWW_TraceFlag != '\0') {
      pFVar1 = TraceFP();
      fprintf((FILE *)pFVar1,Msg2,Arg);
    }
    if (WWW_TraceFlag != '\0') {
      pFVar1 = TraceFP();
      fprintf((FILE *)pFVar1,"\n");
    }
    LYstore_message2(Msg2,Arg);
    LYSleepInfo();
  }
  return;
}



// WARNING: Unknown calling convention

void HTUserMsg(char *Msg)

{
  FILE *__stream;
  
  mustshow = '\x01';
  statusline(Msg);
  if ((Msg != (char *)0x0) && (*Msg != '\0')) {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"User message: %s\n",Msg);
    }
    LYstore_message(Msg);
    LYSleepMsg();
  }
  return;
}



// WARNING: Unknown calling convention

void HTUserMsg2(char *Msg2,char *Arg)

{
  FILE *pFVar1;
  
  mustshow = '\x01';
  user_message(Msg2,Arg);
  if ((Msg2 != (char *)0x0) && (*Msg2 != '\0')) {
    if (WWW_TraceFlag != '\0') {
      pFVar1 = TraceFP();
      fprintf((FILE *)pFVar1,"User message: ");
    }
    if (WWW_TraceFlag != '\0') {
      pFVar1 = TraceFP();
      fprintf((FILE *)pFVar1,Msg2,Arg);
    }
    if (WWW_TraceFlag != '\0') {
      pFVar1 = TraceFP();
      fprintf((FILE *)pFVar1,"\n");
    }
    LYstore_message2(Msg2,Arg);
    LYSleepMsg();
  }
  return;
}



// WARNING: Unknown calling convention

void HTProgress(char *Msg)

{
  FILE *__stream;
  
  statusline(Msg);
  LYstore_message(Msg);
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"%s\n",Msg);
  }
  LYSleepDebug();
  return;
}



// WARNING: Unknown calling convention

char * HTProgressUnits(wchar_t rate)

{
  char *local_8;
  
  if (HTProgressUnits::bunits == (char *)0x0) {
    HTProgressUnits::bunits = (char *)gettext("bytes");
    HTProgressUnits::kbunits = (char *)gettext(LYTransferName);
  }
  if ((rate == L'\x02') || (rate == L'\x04')) {
    local_8 = HTProgressUnits::kbunits;
  }
  else {
    local_8 = HTProgressUnits::bunits;
  }
  return local_8;
}



// WARNING: Removing unreachable block (ram,0x0805a744)
// WARNING: Removing unreachable block (ram,0x0805a79d)

char * sprint_bytes(char *s,off_t n,char *was_units)

{
  size_t sVar1;
  undefined8 uVar2;
  undefined4 local_2c;
  int local_28;
  off_t n_local;
  char *u;
  
  u = HTProgressUnits(LYTransferRate);
  if ((LYTransferRate == 2) || (LYTransferRate == 4)) {
    local_28 = (int)((ulonglong)(uint)sprint_bytes::kb_units * 10 >> 0x20);
    local_2c = (undefined4)((ulonglong)(uint)sprint_bytes::kb_units * 10);
    if (n < CONCAT44(sprint_bytes::kb_units._4_4_ * 10 + local_28,local_2c)) {
      if (n < 1000) {
        sprintf(s,"%lld",(int)n,n._4_4_);
        u = HTProgressUnits(L'\x01');
      }
      else {
        sprintf(s,"%.2g",(double)n /
                         (double)CONCAT44(sprint_bytes::kb_units._4_4_,(uint)sprint_bytes::kb_units)
               );
      }
    }
    else {
      uVar2 = __divdi3(n,(uint)sprint_bytes::kb_units,sprint_bytes::kb_units._4_4_);
      sprintf(s,"%lld",(int)uVar2,(int)((ulonglong)uVar2 >> 0x20));
    }
  }
  else {
    sprintf(s,"%lld",(int)n,n._4_4_);
  }
  if ((was_units == (char *)0x0) || (was_units != u)) {
    sVar1 = strlen(s);
    sprintf(s + sVar1," %s",u);
  }
  return u;
}



// WARNING: Unknown calling convention

char * sprint_tbuf(char *s,long t)

{
  if (t < 0xe11) {
    if (t < 0x3d) {
      sprintf(s,"%ld sec",t);
    }
    else {
      sprintf(s,"%ldm%lds",t / 0x3c,t % 0x3c);
    }
  }
  else {
    sprintf(s,"%ldh%ldm%lds",t / 0xe10,(t / 0x3c) % 0x3c,t % 0x3c);
  }
  return s;
}



// WARNING: Removing unreachable block (ram,0x0805ae0e)
// WARNING: Removing unreachable block (ram,0x0805acfb)
// WARNING: Removing unreachable block (ram,0x0805ab3a)
// WARNING: Removing unreachable block (ram,0x0805ad7b)
// WARNING: Removing unreachable block (ram,0x0805af20)

void HTReadProgress(off_t bytes,off_t total)

{
  int iVar1;
  double dVar2;
  longlong lVar3;
  longlong lVar4;
  ulonglong uVar5;
  double dVar6;
  double dVar7;
  double dVar8;
  char *pcVar9;
  char *pcVar10;
  long t;
  FILE *__stream;
  int in_GS_OFFSET;
  off_t total_local;
  off_t bytes_local;
  double now;
  timeval tv;
  char *was_units;
  wchar_t renew;
  char transferp [80];
  char totalp [80];
  char bytesp [80];
  char tbuf [16];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  gettimeofday((timeval *)&tv,(__timezone_ptr_t)0x0);
  lVar3 = CONCAT44(HTReadProgress::transfer_rate._4_4_,(int)HTReadProgress::transfer_rate);
  dVar2 = (double)tv.tv_usec / 1000000.0 + (double)tv.tv_sec;
  if (LYShowTransferRate == '\0') {
    LYTransferRate = 0;
  }
  dVar6 = dVar2;
  dVar7 = dVar2;
  dVar8 = dVar2;
  lVar4 = bytes;
  if ((bytes != 0) &&
     (dVar6 = HTReadProgress::last_active, dVar7 = HTReadProgress::last,
     dVar8 = HTReadProgress::first,
     lVar4 = CONCAT44(HTReadProgress::bytes_last._4_4_,(undefined4)HTReadProgress::bytes_last),
     bytes < 0)) {
    bytes = CONCAT44(HTReadProgress::bytes_last._4_4_,(undefined4)HTReadProgress::bytes_last);
    total = CONCAT44(HTReadProgress::total_last._4_4_,(undefined4)HTReadProgress::total_last);
    lVar4 = CONCAT44(HTReadProgress::bytes_last._4_4_,(undefined4)HTReadProgress::bytes_last);
  }
  HTReadProgress::first = dVar8;
  HTReadProgress::last = dVar7;
  HTReadProgress::last_active = dVar6;
  total_local._0_4_ = (int)total;
  uVar5 = CONCAT44(HTReadProgress::total_last._4_4_,(undefined4)HTReadProgress::total_last);
  if ((0 < bytes) &&
     (uVar5 = CONCAT44(HTReadProgress::total_last._4_4_,(undefined4)HTReadProgress::total_last),
     HTReadProgress::first < dVar2)) {
    HTReadProgress::transfer_rate =
         CONCAT44(HTReadProgress::transfer_rate._4_4_,(int)HTReadProgress::transfer_rate);
    if ((HTReadProgress::transfer_rate._4_4_ < 1) &&
       ((HTReadProgress::transfer_rate._4_4_ < 0 ||
        (HTReadProgress::transfer_rate = lVar3, (int)HTReadProgress::transfer_rate == 0)))) {
      HTReadProgress::transfer_rate = (off_t)ROUND((double)bytes / (dVar2 - HTReadProgress::first));
    }
    lVar3 = HTReadProgress::transfer_rate;
    uVar5 = total;
    if (HTReadProgress::last + 0.2 <= dVar2) {
      HTReadProgress::bytes_last = lVar4;
      if (HTReadProgress::last < dVar2) {
        if (bytes != lVar4) {
          HTReadProgress::last_active = dVar2;
        }
        HTReadProgress::transfer_rate =
             (off_t)ROUND((double)bytes / (dVar2 - HTReadProgress::first));
        HTReadProgress::last = dVar2;
        HTReadProgress::bytes_last = bytes;
      }
      HTReadProgress::total_last = total;
      if (total < 1) {
        was_units = (char *)0x0;
      }
      else {
        was_units = sprint_bytes(totalp,total,(char *)0x0);
      }
      sprint_bytes(bytesp,bytes,was_units);
      if (total < 1) {
        pcVar9 = (char *)gettext("Read %s of data");
        HTSprintf0(&HTReadProgress::line,pcVar9,bytesp);
      }
      else {
        pcVar9 = (char *)gettext("Read %s of %s of data");
        HTSprintf0(&HTReadProgress::line,pcVar9,bytesp,totalp);
      }
      if ((LYTransferRate != 0) && (0 < HTReadProgress::transfer_rate)) {
        sprint_bytes(transferp,HTReadProgress::transfer_rate,(char *)0x0);
        pcVar9 = (char *)gettext(", %s/sec");
        HTSprintf(&HTReadProgress::line,pcVar9,transferp);
      }
      if ((LYTransferRate == 3) || (LYTransferRate == 4)) {
        if (5.0 <= dVar2 - HTReadProgress::last_active) {
          pcVar9 = sprint_tbuf(tbuf,(int)ROUND(dVar2 - HTReadProgress::last_active));
          pcVar10 = (char *)gettext(" (stalled for %s)");
          HTSprintf(&HTReadProgress::line,pcVar10,pcVar9);
        }
        if ((0 < total) && (HTReadProgress::transfer_rate != 0)) {
          t = __divdi3(total - bytes,HTReadProgress::transfer_rate);
          pcVar9 = sprint_tbuf(tbuf,t);
          pcVar10 = (char *)gettext(", ETA %s");
          HTSprintf(&HTReadProgress::line,pcVar10,pcVar9);
        }
      }
      HTSACat(&HTReadProgress::line,".");
      if ((0x7fffffffffffffff < (ulonglong)total) &&
         ((total < -0x100000000 || ((int)total_local != -1)))) {
        pcVar9 = (char *)gettext(" (Press \'z\' to abort)");
        HTSACat(&HTReadProgress::line,pcVar9);
      }
      statusline(HTReadProgress::line);
      pcVar9 = HTReadProgress::line;
      lVar3 = HTReadProgress::transfer_rate;
      lVar4 = HTReadProgress::bytes_last;
      uVar5 = HTReadProgress::total_last;
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"%s\n",pcVar9);
        lVar3 = HTReadProgress::transfer_rate;
        lVar4 = HTReadProgress::bytes_last;
        uVar5 = HTReadProgress::total_last;
      }
    }
  }
  HTReadProgress::total_last._4_4_ = (undefined4)(uVar5 >> 0x20);
  HTReadProgress::total_last._0_4_ = (undefined4)uVar5;
  HTReadProgress::bytes_last._4_4_ = (undefined4)((ulonglong)lVar4 >> 0x20);
  HTReadProgress::bytes_last._0_4_ = (undefined4)lVar4;
  HTReadProgress::transfer_rate._4_4_ = (int)((ulonglong)lVar3 >> 0x20);
  HTReadProgress::transfer_rate._0_4_ = (int)lVar3;
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
    HTReadProgress::transfer_rate = lVar3;
    HTReadProgress::bytes_last = lVar4;
    HTReadProgress::total_last = uVar5;
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



// WARNING: Unknown calling convention

BOOLEAN HTLastConfirmCancelled(void)

{
  bool bVar1;
  
  bVar1 = conf_cancelled != '\0';
  if (bVar1) {
    conf_cancelled = '\0';
  }
  return bVar1;
}



// WARNING: Unknown calling convention

wchar_t HTForcedPrompt(wchar_t option,char *msg,wchar_t dft)

{
  wchar_t wVar1;
  char *msg2;
  char *show;
  wchar_t result;
  
  result = L'\0';
  show = (char *)0x0;
  msg2 = (char *)0x0;
  if (option == L'\0') {
    result = HTConfirmDefault(msg,dft);
  }
  else {
    if (option == L'\x01') {
      show = (char *)gettext(&DAT_0814c7d6);
      result = L'\x01';
    }
    else {
      if (option != L'\x02') {
        wVar1 = HTConfirmDefault(msg,dft);
        return wVar1;
      }
      show = (char *)gettext(&DAT_0814c7da);
      result = L'\0';
    }
    HTSprintf(&msg2,"%s %s",msg,show);
    HTUserMsg(msg2);
    free(msg2);
  }
  return result;
}



// WARNING: Unknown calling convention

wchar_t HTConfirmDefault(char *Msg,wchar_t Dft)

{
  char cVar1;
  char cVar2;
  LYKeymap_t LVar3;
  char *pcVar4;
  ushort **ppuVar5;
  FILE *pFVar6;
  wchar_t wVar7;
  uint local_4c;
  uint local_48;
  int local_44;
  int local_40;
  wchar_t local_3c;
  wchar_t local_38;
  char *local_34;
  undefined *local_30;
  wchar_t c;
  char *msg;
  wchar_t result;
  char *msg_no;
  char *msg_yes;
  char fallback_n;
  char fallback_y;
  
  msg_yes = (char *)gettext(&DAT_0814c7d6);
  msg_no = (char *)gettext(&DAT_0814c7da);
  result = L'\xffffffff';
  ppuVar5 = __ctype_b_loc();
  if (((*ppuVar5)[(byte)*msg_yes] & 0x200) == 0) {
    local_4c = (uint)(byte)*msg_yes;
  }
  else {
    local_4c = toupper((uint)(byte)*msg_yes);
  }
  ppuVar5 = __ctype_b_loc();
  if (((*ppuVar5)[(byte)*msg_no] & 0x200) == 0) {
    local_48 = (uint)(byte)*msg_no;
  }
  else {
    local_48 = toupper((uint)(byte)*msg_no);
  }
  if (local_4c == local_48) {
    msg_yes = "yes";
    msg_no = "no";
  }
  conf_cancelled = '\0';
  if (dump_output_immediately == '\0') {
    msg = (char *)0x0;
    fallback_y = 'y';
    fallback_n = 'n';
    if ((*msg_yes == 'y') || (*msg_no == 'y')) {
      fallback_y = '\0';
    }
    if ((*msg_yes == 'n') || (*msg_no == 'n')) {
      fallback_n = '\0';
    }
    if (Dft == L'\xfffffffe') {
      HTSprintf0(&msg,"%s (%c/%c) ",Msg,(int)*msg_yes,(int)*msg_no);
    }
    else {
      if (Dft == L'\x01') {
        cVar1 = *msg_yes;
      }
      else {
        cVar1 = *msg_no;
      }
      local_40 = (int)cVar1;
      HTSprintf0(&msg,"%s (%c) ",Msg,local_40);
    }
    pcVar4 = msg;
    if ((LYTraceLogFP != (FILE *)0x0) && (WWW_TraceFlag != '\0')) {
      pFVar6 = TraceFP();
      fprintf((FILE *)pFVar6,"Confirm: %s",pcVar4);
    }
    mustshow = '\x01';
    statusline(msg);
    if (msg != (char *)0x0) {
      free(msg);
      msg = (char *)0x0;
    }
    do {
      while( true ) {
        while( true ) {
          while( true ) {
            while( true ) {
              while( true ) {
                if (L'\xffffffff' < result) goto LAB_0805b590;
                wVar7 = LYgetch_single();
                ppuVar5 = __ctype_b_loc();
                if (((*ppuVar5)[(byte)*msg_yes] & 0x200) == 0) {
                  local_3c = (wchar_t)(byte)*msg_yes;
                }
                else {
                  local_3c = toupper((uint)(byte)*msg_yes);
                }
                if (local_3c != wVar7) break;
                result = L'\x01';
              }
              ppuVar5 = __ctype_b_loc();
              if (((*ppuVar5)[(byte)*msg_no] & 0x200) == 0) {
                local_38 = (wchar_t)(byte)*msg_no;
              }
              else {
                local_38 = toupper((uint)(byte)*msg_no);
              }
              if (local_38 != wVar7) break;
              result = L'\0';
            }
            if ((fallback_y == '\0') || (fallback_y != wVar7)) break;
            result = L'\x01';
          }
          if ((fallback_n == '\0') || (fallback_n != wVar7)) break;
          result = L'\0';
        }
        if ((wVar7 != L'\x03') && (wVar7 != L'\a')) break;
LAB_0805b568:
        conf_cancelled = '\x01';
        result = L'\0';
      }
      LVar3 = keymap[0];
      if (wVar7 == L'\xffffffff') {
joined_r0x0805b530:
        if (LVar3 == 0x2f) goto LAB_0805b568;
      }
      else {
        if ((wVar7 & 0x8800U) == 0) {
          LVar3 = keymap[(wVar7 & 0x7ffU) + 1];
          goto joined_r0x0805b530;
        }
        if ((wVar7 & 0xffU) == 0x2f) goto LAB_0805b568;
      }
    } while (Dft == L'\xfffffffe');
    result = Dft;
LAB_0805b590:
    if (WWW_TraceFlag != '\0') {
      if (conf_cancelled == '\0') {
        local_34 = "";
      }
      else {
        local_34 = ", cancelled";
      }
      if (result == L'\0') {
        local_30 = &DAT_0814c853;
      }
      else {
        local_30 = &DAT_0814c84f;
      }
      pFVar6 = TraceFP();
      fprintf((FILE *)pFVar6,"- %s%s.\n",local_30,local_34);
    }
  }
  else {
    if (Dft == L'\xfffffffe') {
      if (WWW_TraceFlag != '\0') {
        cVar1 = *msg_no;
        cVar2 = *msg_yes;
        pFVar6 = TraceFP();
        fprintf((FILE *)pFVar6,"Confirm: %s (%c/%c) ",Msg,(int)cVar2,(int)cVar1);
      }
    }
    else if (WWW_TraceFlag != '\0') {
      if (Dft == L'\x01') {
        cVar1 = *msg_yes;
      }
      else {
        cVar1 = *msg_no;
      }
      local_44 = (int)cVar1;
      pFVar6 = TraceFP();
      fprintf((FILE *)pFVar6,"Confirm: %s (%c) ",Msg,local_44);
    }
    if (WWW_TraceFlag != '\0') {
      pFVar6 = TraceFP();
      fprintf((FILE *)pFVar6,"- NO, not interactive.\n");
    }
    result = L'\0';
  }
  return result;
}



// WARNING: Unknown calling convention

BOOLEAN HTConfirm(char *Msg)

{
  wchar_t wVar1;
  
  wVar1 = HTConfirmDefault(Msg,L'\xfffffffe');
  return (BOOLEAN)wVar1;
}



BOOLEAN confirm_post_resub(char *address,char *title,wchar_t if_imgmap,wchar_t if_file)

{
  int iVar1;
  int iVar2;
  size_t sVar3;
  size_t sVar4;
  char *pcVar5;
  int in_GS_OFFSET;
  BOOLEAN local_11d;
  char *title_local;
  char *address_local;
  size_t maxlen;
  char *temp;
  char *msg;
  size_t len1;
  BOOLEAN res;
  char buf [240];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  msg = (char *)gettext("Resubmit POST content to %s ?");
  maxlen = (LYcols - (uint)(LYShowScrollbar != '\0')) - 5;
  if (address == (char *)0x0) {
    local_11d = '\0';
    goto LAB_0805baed;
  }
  iVar2 = strncasecomp(address,"LYNXIMGMAP:",0xb);
  if (iVar2 == 0) {
    if (if_imgmap < L'\x01') {
      local_11d = '\0';
      goto LAB_0805baed;
    }
    if (if_imgmap == L'\x01') {
      local_11d = '\x01';
      goto LAB_0805baed;
    }
    msg = (char *)gettext("List from document with POST data.  Reload %s ?");
  }
  else if (((*address == 'f') || (*address == 'F')) &&
          (iVar2 = strncasecomp(address,"file:",5), iVar2 == 0)) {
    if (if_file < L'\x01') {
      local_11d = '\0';
      goto LAB_0805baed;
    }
    if (if_file == L'\x01') {
      local_11d = '\x01';
      goto LAB_0805baed;
    }
    msg = (char *)gettext("List from document with POST data.  Reload %s ?");
  }
  else if (dump_output_immediately != '\0') {
    local_11d = '\0';
    goto LAB_0805baed;
  }
  if (0xef < maxlen) {
    maxlen = 0xef;
  }
  sVar3 = strlen(msg);
  sVar4 = strlen(address);
  if (maxlen < sVar4 + sVar3) {
    pcVar5 = HTParse(address,"",0x1d);
    sVar4 = strlen(pcVar5);
    if (maxlen < sVar4 + sVar3) {
      if (pcVar5 != (char *)0x0) {
        free(pcVar5);
      }
      if ((title == (char *)0x0) || (sVar4 = strlen(title), maxlen < sVar4 + sVar3)) {
        pcVar5 = HTParse(address,"",0x19);
        sVar4 = strlen(pcVar5);
        if (maxlen < sVar4 + sVar3) {
          if (pcVar5 != (char *)0x0) {
            free(pcVar5);
          }
          pcVar5 = HTParse(address,"",8);
          if (((pcVar5 == (char *)0x0) || (*pcVar5 == '\0')) ||
             (sVar4 = strlen(pcVar5), maxlen < sVar4 + sVar3)) {
            if (pcVar5 != (char *)0x0) {
              free(pcVar5);
            }
            pcVar5 = (char *)gettext("Document from Form with POST content.  Resubmit?");
            local_11d = HTConfirm(pcVar5);
          }
          else {
            sprintf(buf,msg,pcVar5);
            local_11d = HTConfirm(buf);
            if (pcVar5 != (char *)0x0) {
              free(pcVar5);
            }
          }
        }
        else {
          sprintf(buf,msg,pcVar5);
          local_11d = HTConfirm(buf);
          if (pcVar5 != (char *)0x0) {
            free(pcVar5);
          }
        }
      }
      else {
        sprintf(buf,msg,title);
        local_11d = HTConfirm(buf);
      }
    }
    else {
      sprintf(buf,msg,pcVar5);
      local_11d = HTConfirm(buf);
      if (pcVar5 != (char *)0x0) {
        free(pcVar5);
      }
    }
  }
  else {
    sprintf(buf,msg,address);
    local_11d = HTConfirm(buf);
  }
LAB_0805baed:
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return local_11d;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



char * HTPrompt(char *Msg,char *deflt)

{
  int iVar1;
  int in_GS_OFFSET;
  char *deflt_local;
  char *Msg_local;
  char *rep;
  char Tmp [200];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  rep = (char *)0x0;
  Tmp[0] = '\0';
  Tmp[199] = '\0';
  mustshow = '\x01';
  statusline(Msg);
  if (deflt != (char *)0x0) {
    strncpy(Tmp,deflt,199);
  }
  if (dump_output_immediately == '\0') {
    LYgetstr(Tmp,L'\0',200,NORECALL);
  }
  HTSACopy(&rep,Tmp);
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return rep;
}



char * HTPromptPassword(char *Msg)

{
  int iVar1;
  undefined4 uVar2;
  int in_GS_OFFSET;
  char *local_8c;
  char *Msg_local;
  char *result;
  char pw [120];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  result = (char *)0x0;
  pw[0] = '\0';
  if (dump_output_immediately == '\0') {
    mustshow = '\x01';
    if (Msg == (char *)0x0) {
      local_8c = (char *)gettext("Password: ");
    }
    else {
      local_8c = Msg;
    }
    statusline(local_8c);
    LYgetstr(pw,L'\x01',0x78,NORECALL);
    HTSACopy(&result,pw);
  }
  else {
    uVar2 = gettext("lynx: Password required!!!");
    printf("\n%s\n",uVar2);
    HTSACopy(&result,"");
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return result;
}



void HTPromptUsernameAndPassword(char *Msg,char **username,char **password,BOOLEAN IsProxy)

{
  undefined4 uVar1;
  char *pcVar2;
  char *Msg_00;
  char *local_24;
  char *local_20;
  char *local_1c;
  char *local_18;
  char *local_14;
  char *local_10;
  BOOLEAN IsProxy_local;
  
  if ((((IsProxy == '\0') && (authentication_info[0] != (char *)0x0)) &&
      (authentication_info[1] != (char *)0x0)) ||
     (((IsProxy == '\x01' && (proxyauth_info[0] != (char *)0x0)) &&
      (proxyauth_info[1] != (char *)0x0)))) {
    if (IsProxy == '\0') {
      local_24 = authentication_info[0];
    }
    else {
      local_24 = proxyauth_info[0];
    }
    HTSACopy(username,local_24);
    if (IsProxy == '\0') {
      if (authentication_info[0] != (char *)0x0) {
        free(authentication_info[0]);
        authentication_info[0] = (char *)0x0;
      }
    }
    else if (proxyauth_info[0] != (char *)0x0) {
      free(proxyauth_info[0]);
      proxyauth_info[0] = (char *)0x0;
    }
    if (IsProxy == '\0') {
      local_20 = authentication_info[1];
    }
    else {
      local_20 = proxyauth_info[1];
    }
    HTSACopy(password,local_20);
    if (IsProxy == '\0') {
      if (authentication_info[1] != (char *)0x0) {
        free(authentication_info[1]);
        authentication_info[1] = (char *)0x0;
      }
    }
    else if (proxyauth_info[1] != (char *)0x0) {
      free(proxyauth_info[1]);
      proxyauth_info[1] = (char *)0x0;
    }
  }
  else if (dump_output_immediately == '\0') {
    if (((IsProxy == '\0') && (authentication_info[0] != (char *)0x0)) ||
       ((IsProxy == '\x01' && (proxyauth_info[0] != (char *)0x0)))) {
      if (IsProxy == '\0') {
        local_14 = authentication_info[0];
      }
      else {
        local_14 = proxyauth_info[0];
      }
      HTSACopy(username,local_14);
      if (IsProxy == '\0') {
        if (authentication_info[0] != (char *)0x0) {
          free(authentication_info[0]);
          authentication_info[0] = (char *)0x0;
        }
      }
      else if (proxyauth_info[0] != (char *)0x0) {
        free(proxyauth_info[0]);
        proxyauth_info[0] = (char *)0x0;
      }
    }
    if (Msg == (char *)0x0) {
      pcVar2 = *username;
      Msg_00 = (char *)gettext("Username: ");
      pcVar2 = HTPrompt(Msg_00,pcVar2);
      *username = pcVar2;
    }
    else {
      pcVar2 = HTPrompt(Msg,*username);
      *username = pcVar2;
    }
    if (((IsProxy == '\0') && (authentication_info[1] != (char *)0x0)) ||
       ((IsProxy == '\x01' && (proxyauth_info[1] != (char *)0x0)))) {
      if (IsProxy == '\0') {
        local_10 = authentication_info[1];
      }
      else {
        local_10 = proxyauth_info[1];
      }
      HTSACopy(password,local_10);
      if (IsProxy == '\0') {
        if (authentication_info[1] != (char *)0x0) {
          free(authentication_info[1]);
          authentication_info[1] = (char *)0x0;
        }
      }
      else if (proxyauth_info[1] != (char *)0x0) {
        free(proxyauth_info[1]);
        proxyauth_info[1] = (char *)0x0;
      }
    }
    else if ((*username == (char *)0x0) || (**username == '\0')) {
      HTSACopy(password,"");
    }
    else {
      pcVar2 = (char *)gettext("Password: ");
      pcVar2 = HTPromptPassword(pcVar2);
      *password = pcVar2;
    }
  }
  else {
    if (((IsProxy == '\0') && (authentication_info[0] != (char *)0x0)) ||
       ((IsProxy == '\x01' && (proxyauth_info[0] != (char *)0x0)))) {
      if (IsProxy == '\0') {
        local_1c = authentication_info[0];
      }
      else {
        local_1c = proxyauth_info[0];
      }
      HTSACopy(username,local_1c);
      if (IsProxy == '\0') {
        if (authentication_info[0] != (char *)0x0) {
          free(authentication_info[0]);
          authentication_info[0] = (char *)0x0;
        }
      }
      else if (proxyauth_info[0] != (char *)0x0) {
        free(proxyauth_info[0]);
        proxyauth_info[0] = (char *)0x0;
      }
    }
    else {
      HTSACopy(username,"WWWuser");
    }
    if (((IsProxy == '\0') && (authentication_info[1] != (char *)0x0)) ||
       ((IsProxy == '\x01' && (proxyauth_info[1] != (char *)0x0)))) {
      if (IsProxy == '\0') {
        local_18 = authentication_info[1];
      }
      else {
        local_18 = proxyauth_info[1];
      }
      HTSACopy(password,local_18);
      if (IsProxy == '\0') {
        if (authentication_info[1] != (char *)0x0) {
          free(authentication_info[1]);
          authentication_info[1] = (char *)0x0;
        }
      }
      else if (proxyauth_info[1] != (char *)0x0) {
        free(proxyauth_info[1]);
        proxyauth_info[1] = (char *)0x0;
      }
    }
    else {
      HTSACopy(password,"");
    }
    uVar1 = gettext("lynx: Username and Password required!!!");
    printf("\n%s\n",uVar1);
  }
  return;
}



// WARNING: Unknown calling convention

BOOLEAN HTConfirmCookie(domain_entry *de,char *server,char *name,char *value)

{
  char cVar1;
  char cVar2;
  wchar_t wVar3;
  size_t sVar4;
  ushort **ppuVar5;
  FILE *pFVar6;
  char *pcVar7;
  char *pcVar8;
  int iVar9;
  BOOLEAN local_45;
  uint local_40;
  char *s;
  char *p;
  char *message;
  wchar_t percentage;
  wchar_t space_free;
  wchar_t valuelen;
  wchar_t namelen;
  char *prompt;
  wchar_t ch;
  
  prompt = (char *)gettext("%s cookie: %.*s=%.*s  Allow? (Y/N/Always/neVer)");
  if (de == (domain_entry *)0x0) {
    local_45 = '\0';
  }
  else if (de->bv == ACCEPT_ALWAYS) {
    local_45 = '\x01';
  }
  else if (de->bv == REJECT_ALWAYS) {
    local_45 = '\0';
  }
  else if (dump_output_immediately == '\0') {
    if (LYAcceptAllCookies == '\0') {
      message = (char *)0x0;
      iVar9 = LYcols - (uint)(LYShowScrollbar != '\0');
      wVar3 = LYstrCells(prompt);
      sVar4 = strlen(server);
      space_free = (iVar9 + (10 - wVar3)) - sVar4;
      if (space_free < L'\0') {
        space_free = L'\0';
      }
      namelen = strlen(name);
      valuelen = strlen(value);
      if (space_free < namelen + valuelen) {
        percentage = (space_free * 100) / (namelen + valuelen);
        namelen = (percentage * namelen) / 100;
        valuelen = (percentage * valuelen) / 100;
      }
      HTSprintf(&message,prompt,server,namelen,name,valuelen,value);
      mustshow = '\x01';
      statusline(message);
      if (message != (char *)0x0) {
        free(message);
        message = (char *)0x0;
      }
    }
LAB_0805c303:
    do {
      if (LYAcceptAllCookies == '\0') {
        ch = LYgetch_single();
        gettext("Y/N/A/V");
        s = "YNAV\a\x03";
        pcVar8 = strchr("YNAV\a\x03",ch);
        if (((pcVar8 == (char *)0x0) && (ppuVar5 = __ctype_b_loc(), ((*ppuVar5)[ch] & 0x400) != 0))
           && (p = strrchr(prompt,0x28), p != (char *)0x0)) {
          if (WWW_TraceFlag != '\0') {
            pFVar6 = TraceFP();
            fprintf((FILE *)pFVar6,"Looking for %c in %s\n",ch,p);
          }
          do {
            if (((*p == ')') || (*p == '\0')) ||
               (ppuVar5 = __ctype_b_loc(), ((*ppuVar5)[(byte)*s] & 0x400) == 0)) break;
            ppuVar5 = __ctype_b_loc();
            if (((*ppuVar5)[(byte)*p] & 0x400) != 0) {
              cVar1 = *p;
              ppuVar5 = __ctype_b_loc();
              if (((*ppuVar5)[(byte)*p] & 0x200) == 0) {
                local_40 = (uint)(byte)*p;
              }
              else {
                local_40 = toupper((uint)(byte)*p);
              }
              if ((int)cVar1 == local_40) {
                if (WWW_TraceFlag != '\0') {
                  cVar1 = *s;
                  cVar2 = *p;
                  pFVar6 = TraceFP();
                  fprintf((FILE *)pFVar6,"...testing %c/%c\n",(int)cVar2,(int)cVar1);
                }
                if (*p == ch) {
                  ch = (wchar_t)*s;
                  break;
                }
                s = s + 1;
              }
            }
            p = p + 1;
          } while( true );
        }
      }
      else {
        ch = L'A';
      }
      if (ch == L'N') break;
      if (ch < L'O') {
        if (ch == L'A') {
          de->bv = ACCEPT_ALWAYS;
          pcVar8 = de->domain;
          pcVar7 = (char *)gettext("\'A\'lways allowing from domain \'%s\'.");
          HTUserMsg2(pcVar7,pcVar8);
          return '\x01';
        }
      }
      else {
        if (ch == L'V') {
          de->bv = REJECT_ALWAYS;
          pcVar8 = de->domain;
          pcVar7 = (char *)gettext("ne\'V\'er allowing from domain \'%s\'.");
          HTUserMsg2(pcVar7,pcVar8);
          return '\0';
        }
        if (ch == L'Y') {
          pcVar8 = (char *)gettext("Allowing this cookie.");
          HTInfoMsg(pcVar8);
          return '\x01';
        }
      }
      if ((ch == L'\x03') || (ch == L'\a')) break;
      if (ch != L'\xffffffff') {
        if ((ch & 0x8800U) == 0) {
          if (keymap[(ch & 0x7ffU) + 1] == 0x2f) break;
        }
        else if ((ch & 0xffU) == 0x2f) break;
        goto LAB_0805c303;
      }
    } while (keymap[0] != 0x2f);
    pcVar8 = (char *)gettext("Rejecting this cookie.");
    HTUserMsg(pcVar8);
    local_45 = '\0';
  }
  else {
    local_45 = LYSetCookies;
  }
  return local_45;
}



// WARNING: Unknown calling convention

wchar_t HTConfirmPostRedirect(char *Redirecting_url,wchar_t server_status)

{
  char *pcVar1;
  size_t sVar2;
  wchar_t wVar3;
  wchar_t local_30;
  int local_2c;
  undefined4 local_28;
  wchar_t c;
  wchar_t on_screen;
  char *url;
  char *StatusInfo;
  char *show_POST_url;
  wchar_t result;
  
  result = L'\xffffffff';
  show_POST_url = (char *)0x0;
  StatusInfo = (char *)0x0;
  url = (char *)0x0;
  on_screen = L'\0';
  if ((server_status == L'') || (server_status == L'')) {
    local_30 = L'';
  }
  else if (dump_output_immediately == '\0') {
    if (user_mode == 0) {
      on_screen = L'\x02';
      LYmove(LYlines + L'\xfffffffe',L'\0');
      pcVar1 = (char *)gettext("Server asked for %d redirection of POST content to");
      HTSprintf0(&StatusInfo,pcVar1,server_status);
      sVar2 = strlen(StatusInfo);
      LYwaddnstr(LYwin,StatusInfo,sVar2);
      LYclrtoeol();
      LYmove(LYlines + L'\xffffffff',L'\0');
      if (LYcols < 0xfa) {
        local_2c = (LYcols - (uint)(LYShowScrollbar != '\0')) + -5;
      }
      else {
        local_2c = 0xfa;
      }
      HTSprintf0(&url,"URL: %.*s",local_2c,Redirecting_url);
      sVar2 = strlen(url);
      LYwaddnstr(LYwin,url,sVar2);
      LYclrtoeol();
      if (server_status == L'') {
        mustshow = '\x01';
        pcVar1 = (char *)gettext("P)roceed, use G)ET or C)ancel ");
        statusline(pcVar1);
      }
      else {
        mustshow = '\x01';
        pcVar1 = (char *)gettext("P)roceed, or C)ancel ");
        statusline(pcVar1);
      }
    }
    else {
      if (server_status == L'') {
        local_28 = gettext("Redirection of POST content.  P)roceed, see U)RL, use G)ET or C)ancel");
      }
      else {
        local_28 = gettext("Redirection of POST content.  P)roceed, see U)RL, or C)ancel");
      }
      HTSprintf0(&StatusInfo,"%d %.*s",server_status,0xfb,local_28);
      pcVar1 = (char *)gettext("Location: ");
      HTSACopy(&show_POST_url,pcVar1);
      HTSACat(&show_POST_url,Redirecting_url);
    }
    while (result < L'\0') {
      if (on_screen == L'\0') {
        mustshow = '\x01';
        statusline(StatusInfo);
      }
      else if (on_screen == L'\x01') {
        mustshow = '\x01';
        statusline(show_POST_url);
      }
      wVar3 = LYgetch_single();
      if (wVar3 == L'G') {
        if (server_status == L'') {
          if (show_POST_url != (char *)0x0) {
            free(show_POST_url);
            show_POST_url = (char *)0x0;
          }
          result = L'';
        }
        else {
LAB_0805c98b:
          if (on_screen == L'\x01') {
            on_screen = L'\0';
          }
          else {
            on_screen = L'\x02';
          }
        }
      }
      else if (wVar3 < L'H') {
        if ((wVar3 != L'\a') && (wVar3 != L'C')) goto LAB_0805c98b;
        if (show_POST_url != (char *)0x0) {
          free(show_POST_url);
          show_POST_url = (char *)0x0;
        }
        result = L'\0';
      }
      else if (wVar3 == L'P') {
        if (show_POST_url != (char *)0x0) {
          free(show_POST_url);
          show_POST_url = (char *)0x0;
        }
        result = L'\x01';
      }
      else {
        if (wVar3 != L'U') goto LAB_0805c98b;
        if (user_mode != 0) {
          if (on_screen == L'\x01') {
            on_screen = L'\0';
          }
          else {
            on_screen = L'\x01';
          }
        }
      }
    }
    if (StatusInfo != (char *)0x0) {
      free(StatusInfo);
      StatusInfo = (char *)0x0;
    }
    if (url != (char *)0x0) {
      free(url);
    }
    local_30 = result;
  }
  else if (server_status == L'') {
    local_30 = L'';
  }
  else {
    local_30 = L'\0';
  }
  return local_30;
}



// WARNING: Unknown calling convention

void LYSleepAlert(void)

{
  if (((crawl == '\0') && (traversal == '\0')) && (LYCursesON != '\0')) {
    napms(AlertSecs);
  }
  return;
}



// WARNING: Unknown calling convention

void LYSleepDebug(void)

{
  if (((crawl == '\0') && (traversal == '\0')) && (LYCursesON != '\0')) {
    napms(DebugSecs);
  }
  return;
}



// WARNING: Unknown calling convention

void LYSleepInfo(void)

{
  if (((crawl == '\0') && (traversal == '\0')) && (LYCursesON != '\0')) {
    napms(InfoSecs);
  }
  return;
}



// WARNING: Unknown calling convention

void LYSleepMsg(void)

{
  if (((crawl == '\0') && (traversal == '\0')) && (LYCursesON != '\0')) {
    napms(MessageSecs);
  }
  return;
}



// WARNING: Unknown calling convention

void LYSleepReplay(void)

{
  if (((crawl == '\0') && (traversal == '\0')) && (LYCursesON != '\0')) {
    napms(ReplaySecs);
  }
  return;
}



// WARNING: Unknown calling convention

pool_data * ALLOC_IN_POOL(HTPool **ppoolptr,uint request)

{
  HTPool *pHVar1;
  wchar_t wVar2;
  HTPool *newpool;
  uint j;
  uint n;
  pool_data *ptr;
  HTPool *pool;
  
  pHVar1 = *ppoolptr;
  if (pHVar1 == (HTPool *)0x0) {
    ptr = (pool_data *)0x0;
  }
  else {
    n = request;
    if (request == 0) {
      n = 1;
    }
    if ((n & 7) != 0) {
      n = (n - (n & 7)) + 8;
    }
    wVar2 = n >> 2;
    if ((uint)(pHVar1->used + wVar2) < 0x7fb) {
      ptr = pHVar1->data + pHVar1->used;
      pHVar1->used = pHVar1->used + wVar2;
    }
    else {
      ptr = (pool_data *)LY_check_calloc(1,0x1ff0);
      if ((HTPool *)ptr == (HTPool *)0x0) {
        ptr = (pool_data *)0x0;
      }
      else {
        *(HTPool **)((int)ptr + 0x1fe8) = pHVar1;
        *(wchar_t *)((int)ptr + 0x1fec) = wVar2;
        *ppoolptr = (HTPool *)ptr;
      }
    }
  }
  return ptr;
}



// WARNING: Unknown calling convention

HTPool * POOL_NEW(void)

{
  HTPool *pHVar1;
  HTPool *poolptr;
  
  pHVar1 = (HTPool *)LY_check_calloc(1,0x1ff0);
  if (pHVar1 != (HTPool *)0x0) {
    pHVar1->prev = (_HTPool *)0x0;
    pHVar1->used = L'\0';
  }
  return pHVar1;
}



// WARNING: Unknown calling convention

void POOL_FREE(HTPool *poolptr)

{
  _HTPool *p_Var1;
  HTPool *prev;
  HTPool *cur;
  
  cur = poolptr;
  while (cur != (HTPool *)0x0) {
    p_Var1 = cur->prev;
    free(cur);
    cur = p_Var1;
  }
  return;
}



// WARNING: Unknown calling convention

void * HText_pool_calloc(HText *text,uint size)

{
  pool_data *ppVar1;
  
  ppVar1 = ALLOC_IN_POOL(&text->pool,size);
  return ppVar1;
}



// WARNING: Unknown calling convention

void ht_justify_cleanup(void)

{
  wchar_t local_8;
  
  if ((ok_justify == '\0') || (psrc_view != '\0')) {
    local_8 = L'';
  }
  else {
    local_8 = L'\xffffffff';
  }
  wait_for_this_stacked_elt = local_8;
  can_justify_here = '\x01';
  can_justify_this_line = '\x01';
  form_in_htext = '\0';
  last_anchor_of_previous_line = (TextAnchor *)0x0;
  this_line_was_split = '\0';
  in_DT = '\0';
  have_raw_nbsps = '\0';
  return;
}



// WARNING: Unknown calling convention

void mark_justify_start_position(void *text)

{
  if ((text != (void *)0x0) && (*(int *)((int)text + 4) != 0)) {
    justify_start_position = (wchar_t)*(ushort *)(*(int *)((int)text + 4) + 10);
  }
  return;
}



// WARNING: Unknown calling convention

void HText_halt(void)

{
  if (L'\0' < HTFormNumber) {
    HText_DisableCurrentForm();
  }
  if ((HTMainText != (HText *)0x0) && (HTMainText->halted < L'\x02')) {
    HTMainText->halted = L'\x02';
  }
  return;
}



// WARNING: Unknown calling convention

BOOLEAN mem_is_avail(size_t factor,size_t bytes)

{
  void *__ptr;
  BOOLEAN local_15;
  void *p;
  
  if ((bytes < 5000) && (factor != 0)) {
    bytes = 5000;
  }
  if (factor == 0) {
    factor = 1;
  }
  __ptr = malloc(factor * bytes);
  if (__ptr == (void *)0x0) {
    local_15 = '\0';
  }
  else {
    if (__ptr != (void *)0x0) {
      free(__ptr);
    }
    local_15 = '\x01';
  }
  return local_15;
}



// WARNING: Unknown calling convention

void * LY_check_calloc(size_t nmemb,size_t size)

{
  wchar_t wVar1;
  BOOLEAN BVar2;
  wchar_t wVar3;
  HText *self;
  FILE *__stream;
  char *pcVar4;
  void *pvVar5;
  void *local_24;
  char *local_20;
  char *local_1c;
  HText *t;
  wchar_t n;
  wchar_t i;
  
  BVar2 = mem_is_avail(4,nmemb * size);
  if (BVar2 == '\0') {
    wVar3 = HTList_count(loaded_texts);
    wVar1 = wVar3;
    do {
      i = wVar1 + L'\xffffffff';
      if (i < L'\x01') {
        LYFakeZap('\x01');
        if ((HTMainText == (HText *)0x0) || (HTMainText->halted < L'\x02')) {
          BVar2 = mem_is_avail(2,nmemb * size);
          if (BVar2 == '\0') {
            HText_halt();
            BVar2 = mem_is_avail(0,700);
            if (BVar2 != '\0') {
              pcVar4 = (char *)gettext("Memory exhausted, display interrupted!");
              HTAlert(pcVar4);
            }
          }
          else if (((HTMainText == (HText *)0x0) || (HTMainText->halted == L'\0')) &&
                  (BVar2 = mem_is_avail(0,700), BVar2 != '\0')) {
            pcVar4 = (char *)gettext("Memory exhausted, will interrupt transfer!");
            HTAlert(pcVar4);
            if (HTMainText != (HText *)0x0) {
              HTMainText->halted = L'\x01';
            }
          }
        }
        pvVar5 = calloc(nmemb,size);
        return pvVar5;
      }
      self = (HText *)HTList_objectAt(loaded_texts,i);
      if (WWW_TraceFlag != '\0') {
        if (((self == (HText *)0x0) || (self->node_anchor == (HTParentAnchor *)0x0)) ||
           (self->node_anchor->post_data == (bstring *)0x0)) {
          local_20 = "";
        }
        else {
          local_20 = " with POST data";
        }
        if (((self == (HText *)0x0) || (self->node_anchor == (HTParentAnchor *)0x0)) ||
           (self->node_anchor->address == (char *)0x0)) {
          local_1c = "unknown anchor";
        }
        else {
          local_1c = self->node_anchor->address;
        }
        __stream = TraceFP();
        fprintf((FILE *)__stream,"\nBUG *** Emergency freeing document %d/%d for \'%s\'%s!\n",wVar1,
                wVar3,local_1c,local_20);
      }
      HTList_removeObjectAt(loaded_texts,i);
      HText_free(self);
      BVar2 = mem_is_avail(4,nmemb * size);
      wVar1 = i;
    } while (BVar2 == '\0');
    local_24 = calloc(nmemb,size);
  }
  else {
    local_24 = calloc(nmemb,size);
  }
  return local_24;
}



// WARNING: Unknown calling convention

wchar_t StyleToCols(HText *text,HTLine *line,wchar_t nstyle)

{
  char *pcVar1;
  size_t sVar2;
  wchar_t wVar3;
  wchar_t utf_extra;
  char *last;
  char *data;
  wchar_t nchars;
  wchar_t result;
  
  result = (wchar_t)line->offset;
  nchars = (wchar_t)(*(ushort *)(line->styles + nstyle) >> 2);
  data = line->data;
  pcVar1 = data + line->size;
  while ((L'\0' < nchars && (data < pcVar1))) {
    if ((*data < '\x03') || (('\b' < *data || (*data == '\b')))) {
      sVar2 = utf8_length((text->T).output_utf8,data);
      if (sVar2 == 0) {
        if ((HTCJK == NOCJK) || (-1 < *data)) {
          data = data + 1;
          result = result + L'\x01';
        }
        else {
          data = data + 2;
          result = result + L'\x02';
        }
      }
      else {
        wVar3 = LYstrExtent(data,sVar2 + L'\x01',L'\x02');
        result = result + wVar3;
        data = data + sVar2 + L'\x01';
      }
      nchars = nchars + L'\xffffffff';
    }
    else {
      data = data + 1;
    }
  }
  return result;
}



// WARNING: Unknown calling convention

void LYClearHiText(TextAnchor *a)

{
  if ((a->lites).hl_info != (HiliteInfo *)0x0) {
    free((a->lites).hl_info);
    (a->lites).hl_info = (HiliteInfo *)0x0;
  }
  (a->lites).hl_base.hl_text = (char *)0x0;
  (a->lites).hl_len = 0;
  return;
}



// WARNING: Unknown calling convention

void LYSetHiText(TextAnchor *a,char *text,wchar_t len)

{
  pool_data *ppVar1;
  
  if (text != (char *)0x0) {
    ppVar1 = ALLOC_IN_POOL(&HTMainText->pool,len + L'\x02');
    (a->lites).hl_base.hl_text = (char *)ppVar1;
    memcpy((a->lites).hl_base.hl_text,text,len);
    (a->lites).hl_base.hl_text[len] = '\0';
    (a->lites).hl_len = 1;
  }
  return;
}



// WARNING: Unknown calling convention

void LYAddHiText(TextAnchor *a,char *text,wchar_t x)

{
  HiliteInfo *__ptr;
  int iVar1;
  size_t sVar2;
  pool_data *ppVar3;
  uint want;
  uint need;
  HiliteInfo *have;
  
  __ptr = (a->lites).hl_info;
  iVar1 = (a->lites).hl_len + -1;
  (a->lites).hl_len = (a->lites).hl_len + 1;
  sVar2 = (int)(a->lites).hl_len << 3;
  if (__ptr == (HiliteInfo *)0x0) {
    have = (HiliteInfo *)malloc(sVar2);
  }
  else {
    have = (HiliteInfo *)realloc(__ptr,sVar2);
  }
  (a->lites).hl_info = have;
  sVar2 = strlen(text);
  ppVar3 = ALLOC_IN_POOL(&HTMainText->pool,sVar2 + 2);
  have[iVar1].hl_text = (char *)ppVar3;
  strcpy(have[iVar1].hl_text,text);
  have[iVar1].hl_x = (short)x;
  return;
}



// WARNING: Unknown calling convention

wchar_t LYAdjHiTextPos(TextAnchor *a,wchar_t count)

{
  char *pcVar1;
  wchar_t local_18;
  char *result;
  
  if (count < (a->lites).hl_len) {
    if (count < L'\x01') {
      result = (a->lites).hl_base.hl_text;
    }
    else {
      result = (a->lites).hl_info[-(1 - count)].hl_text;
    }
  }
  else {
    result = (char *)0x0;
  }
  if (result == (char *)0x0) {
    local_18 = L'\0';
  }
  else {
    pcVar1 = LYSkipBlanks(result);
    local_18 = (int)pcVar1 - (int)result;
  }
  return local_18;
}



// WARNING: Unknown calling convention

char * LYGetHiTextStr(TextAnchor *a,wchar_t count)

{
  wchar_t wVar1;
  char *result;
  
  if (count < (a->lites).hl_len) {
    if (count < L'\x01') {
      result = (a->lites).hl_base.hl_text;
    }
    else {
      result = (a->lites).hl_info[-(1 - count)].hl_text;
    }
  }
  else {
    result = (char *)0x0;
  }
  wVar1 = LYAdjHiTextPos(a,count);
  return result + wVar1;
}



// WARNING: Unknown calling convention

wchar_t LYGetHiTextPos(TextAnchor *a,wchar_t count)

{
  wchar_t wVar1;
  wchar_t result;
  
  if (count < (a->lites).hl_len) {
    if (count < L'\x01') {
      result = (wchar_t)a->line_pos;
    }
    else {
      result = (wchar_t)(a->lites).hl_info[-(1 - count)].hl_x;
    }
  }
  else {
    result = L'\xffffffff';
  }
  wVar1 = LYAdjHiTextPos(a,count);
  return result + wVar1;
}



// WARNING: Unknown calling convention

void LYCopyHiText(TextAnchor *a,TextAnchor *b)

{
  char *text;
  wchar_t wVar1;
  char *s;
  wchar_t count;
  
  LYClearHiText(a);
  count = L'\0';
  while( true ) {
    text = LYGetHiTextStr(b,count);
    if (text == (char *)0x0) break;
    if (count == L'\0') {
      wVar1 = strlen(text);
      LYSetHiText(a,text,wVar1);
    }
    else {
      wVar1 = LYGetHiTextPos(b,count);
      LYAddHiText(a,text,wVar1);
    }
    count = count + L'\x01';
  }
  return;
}



// WARNING: Unknown calling convention

void HText_getChartransInfo(HText *me)

{
  wchar_t wVar1;
  LYUCcharset_conflict *pLVar2;
  wchar_t chndl;
  
  wVar1 = HTAnchor_getUCLYhndl(me->node_anchor,3);
  me->UCLYhndl = wVar1;
  if (me->UCLYhndl < L'\0') {
    HTAnchor_setUCInfoStage(me->node_anchor,current_char_set,3,3);
    wVar1 = HTAnchor_getUCLYhndl(me->node_anchor,3);
    me->UCLYhndl = wVar1;
  }
  pLVar2 = (LYUCcharset_conflict *)HTAnchor_getUCInfoStage(me->node_anchor,3);
  me->UCI = pLVar2;
  return;
}



// WARNING: Unknown calling convention

void PerFormInfo_free(PerFormInfo *form)

{
  if (form != (PerFormInfo *)0x0) {
    if (form->accept_cs != (char *)0x0) {
      free(form->accept_cs);
      form->accept_cs = (char *)0x0;
    }
    if (form->thisacceptcs != (char *)0x0) {
      free(form->thisacceptcs);
      form->thisacceptcs = (char *)0x0;
    }
    if (form != (PerFormInfo *)0x0) {
      free(form);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void free_form_fields(FormInfo *input_field)

{
  _OptionType_conflict *p_Var1;
  OptionType_conflict *tmp;
  OptionType_conflict *optptr;
  
  if ((input_field->type == L'\a') && (input_field->select_list != (OptionType_conflict *)0x0)) {
    p_Var1 = input_field->select_list;
    while (optptr = p_Var1, optptr != (OptionType_conflict *)0x0) {
      p_Var1 = optptr->next;
      if (optptr->name != (char *)0x0) {
        free(optptr->name);
        optptr->name = (char *)0x0;
      }
      if (optptr->cp_submit_value != (char *)0x0) {
        free(optptr->cp_submit_value);
        optptr->cp_submit_value = (char *)0x0;
      }
      if (optptr != (OptionType_conflict *)0x0) {
        free(optptr);
      }
    }
    input_field->select_list = (OptionType_conflict *)0x0;
    input_field->value = (char *)0x0;
    input_field->orig_value = (char *)0x0;
    input_field->cp_submit_value = (char *)0x0;
    input_field->orig_submit_value = (char *)0x0;
  }
  else {
    if (input_field->value != (char *)0x0) {
      free(input_field->value);
      input_field->value = (char *)0x0;
    }
    if (input_field->orig_value != (char *)0x0) {
      free(input_field->orig_value);
      input_field->orig_value = (char *)0x0;
    }
    if (input_field->cp_submit_value != (char *)0x0) {
      free(input_field->cp_submit_value);
      input_field->cp_submit_value = (char *)0x0;
    }
    if (input_field->orig_submit_value != (char *)0x0) {
      free(input_field->orig_submit_value);
      input_field->orig_submit_value = (char *)0x0;
    }
  }
  if (input_field->name != (char *)0x0) {
    free(input_field->name);
    input_field->name = (char *)0x0;
  }
  if (input_field->submit_action != (char *)0x0) {
    free(input_field->submit_action);
    input_field->submit_action = (char *)0x0;
  }
  if (input_field->submit_enctype != (char *)0x0) {
    free(input_field->submit_enctype);
    input_field->submit_enctype = (char *)0x0;
  }
  if (input_field->submit_title != (char *)0x0) {
    free(input_field->submit_title);
    input_field->submit_title = (char *)0x0;
  }
  if (input_field->accept_cs != (char *)0x0) {
    free(input_field->accept_cs);
    input_field->accept_cs = (char *)0x0;
  }
  return;
}



// WARNING: Unknown calling convention

void FormList_delete(HTList *forms)

{
  PerFormInfo *local_18;
  PerFormInfo *form;
  HTList *cur;
  
  cur = forms;
  while( true ) {
    if ((cur == (HTList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
      local_18 = (PerFormInfo *)0x0;
    }
    else {
      local_18 = (PerFormInfo *)cur->object;
    }
    if (local_18 == (PerFormInfo *)0x0) break;
    PerFormInfo_free(local_18);
  }
  HTList_delete(forms);
  return;
}



// WARNING: Unknown calling convention

void ResetPartialLinenos(HText *text)

{
  if (text != (HText *)0x0) {
    text->first_lineno_last_disp_partial = L'\xffffffff';
    text->last_lineno_last_disp_partial = L'\xffffffff';
  }
  return;
}



// WARNING: Unknown calling convention

HText * HText_new(HTParentAnchor *anchor)

{
  HTLine *pHVar1;
  BOOLEAN BVar2;
  HText *me;
  FILE *pFVar3;
  int iVar4;
  HText *self_00;
  HTPool *pHVar5;
  LYUCcharset_conflict *p_in;
  short local_2a;
  BOOLEAN local_28;
  bool local_21;
  bool local_20;
  HText *self;
  HTLine *line;
  
  me = (HText *)calloc(1,0x904);
  if (me != (HText *)0x0) {
    if (WWW_TraceFlag != '\0') {
      pFVar3 = TraceFP();
      fprintf((FILE *)pFVar3,"GridText: start HText_new\n");
    }
    if (HTMainText != (HText *)0x0) {
      BVar2 = HText_hasUTF8OutputSet(HTMainText);
      if (((BVar2 == '\0') || (BVar2 = HTLoadedDocumentEightbit(), BVar2 == '\0')) ||
         (LYCharSet_UC[current_char_set].enc != 7)) {
        me->had_utf8 = HTMainText->has_utf8;
      }
      else {
        me->had_utf8 = HTMainText->has_utf8;
      }
      HTMainText->has_utf8 = '\0';
    }
    if (loaded_texts == (HTList *)0x0) {
      loaded_texts = HTList_new();
    }
    if (anchor->document != (HyperDoc *)0x0) {
      HTList_removeObject(loaded_texts,anchor->document);
      if (WWW_TraceFlag != '\0') {
        pFVar3 = TraceFP();
        fprintf((FILE *)pFVar3,"GridText: Auto-uncaching\n");
      }
      HTAnchor_delete_links(anchor);
      *(undefined4 *)anchor->document = 0;
      HText_free((HText *)anchor->document);
      anchor->document = (HyperDoc *)0x0;
    }
    HTList_addObject(loaded_texts,me);
    iVar4 = HTList_count(loaded_texts);
    if (HTCacheSize < iVar4) {
      if (WWW_TraceFlag != '\0') {
        pFVar3 = TraceFP();
        fprintf((FILE *)pFVar3,"GridText: Freeing off cached doc.\n");
      }
      self_00 = (HText *)HTList_removeFirstObject(loaded_texts);
      HText_free(self_00);
    }
    pHVar5 = POOL_NEW();
    me->pool = pHVar5;
    if (me->pool == (HTPool *)0x0) {
      outofmem("./GridText.c","HText_New");
    }
    me->last_line = &me->temp_line[0].base;
    pHVar1 = me->last_line;
    pHVar1->prev = pHVar1;
    pHVar1->next = pHVar1->prev;
    pHVar1->size = 0;
    pHVar1->offset = pHVar1->size;
    pHVar1->data[pHVar1->size] = '\0';
    pHVar1->numstyles = 0;
    pHVar1->styles = (HTStyleChange *)stylechanges_buffers;
    me->Lines = L'\0';
    me->last_anchor = (TextAnchor *)0x0;
    me->first_anchor = me->last_anchor;
    me->last_anchor_before_split = (TextAnchor *)0x0;
    me->style = &default_style;
    me->top_of_screen = L'\0';
    me->node_anchor = anchor;
    me->last_anchor_number = L'\0';
    me->stale = '\x01';
    me->toolbar = '\0';
    me->tabs = (HTList *)0x0;
    me->clickable_images = clickable_images;
    me->pseudo_inline_alts = pseudo_inline_alts;
    me->verbose_img = verbose_img;
    me->raw_mode = LYUseDefaultRawMode;
    me->historical_comments = historical_comments;
    me->minimal_comments = minimal_comments;
    me->soft_dquotes = soft_dquotes;
    me->old_dtd = (short)Old_DTD;
    me->keypad_mode = (short)keypad_mode;
    me->disp_lines = (short)LYlines;
    if (LYwideLines == L'\0') {
      local_2a = (short)LYcols;
    }
    else {
      local_2a = 0x3f6;
    }
    me->disp_cols = local_2a;
    if (((anchor->bookmark == (char *)0x0) &&
        (BVar2 = LYIsUIPage3(anchor->address,UIP_LIST_PAGE,L'\0'), BVar2 == '\0')) &&
       (BVar2 = LYIsUIPage3(anchor->address,UIP_ADDRLIST_PAGE,L'\0'), BVar2 == '\0')) {
      me->hiddenlinkflag = LYHiddenLinks;
    }
    else {
      me->hiddenlinkflag = L'\0';
    }
    me->hidden_links = (HTList *)0x0;
    if ((anchor->no_cache == '\0') && (anchor->post_data == (bstring *)0x0)) {
      local_28 = '\0';
    }
    else {
      local_28 = '\x01';
    }
    me->no_cache = local_28;
    me->LastChar = '\0';
    me->IgnoreExcess = '\0';
    if (LYpsrc == '\0') {
      local_21 = HTOutputFormat == WWW_SOURCE;
    }
    else {
      if ((mark_htext_as_source == '\0') && (psrc_view == '\0')) {
        local_20 = false;
      }
      else {
        local_20 = true;
      }
      local_21 = local_20;
    }
    me->source = local_21;
    mark_htext_as_source = '\0';
    HTAnchor_setDocument(anchor,(HyperDoc *)me);
    HTFormNumber = L'\0';
    HTMainAnchor = anchor;
    HTMainText = me;
    me->display_on_the_fly = L'\0';
    me->kcode = NOKANJI;
    me->specified_kcode = NOKANJI;
    me->detected_kcode = DET_NOTYET;
    me->SJIS_status = SJIS_state_neutral;
    me->EUC_status = EUC_state_neutral;
    me->state = S_text;
    me->kanji_buf = L'\0';
    me->in_sjis = L'\0';
    me->have_8bit_chars = '\0';
    HText_getChartransInfo(me);
    UCSetTransParams(&me->T,me->UCLYhndl,(LYUCcharset *)me->UCI,current_char_set,
                     LYCharSet_UC + current_char_set);
    p_in = (LYUCcharset_conflict *)HTAnchor_getUCInfoStage(anchor,3);
    HText_setKcode(me,anchor->charset,p_in);
    if (underscore_string[0] != '.') {
      memset(underscore_string,0x2e,0x3ff);
      underscore_string[1023] = '\0';
      underscore_string[1024] = '\0';
      memset(star_string,0x5f,0x3ff);
      star_string[1023] = '\0';
      star_string[1024] = '\0';
    }
    underline_on = '\0';
    bold_on = '\0';
    if (display_partial_flag != '\0') {
      display_partial = '\x01';
      NumOfLines_partial = L'\0';
    }
    ResetPartialLinenos(me);
    ht_justify_cleanup();
  }
  return me;
}



// WARNING: Unknown calling convention

HText * HText_new2(HTParentAnchor *anchor,HTStream *stream)

{
  HTStreamClass *pHVar1;
  HText *pHVar2;
  HText *result;
  
  pHVar2 = HText_new(anchor);
  if (stream != (HTStream *)0x0) {
    pHVar2->target = stream;
    pHVar1 = stream->isa;
    (pHVar2->targetClass).name = pHVar1->name;
    (pHVar2->targetClass)._free = pHVar1->_free;
    (pHVar2->targetClass)._abort = pHVar1->_abort;
    (pHVar2->targetClass).put_character = pHVar1->put_character;
    (pHVar2->targetClass).put_string = pHVar1->put_string;
    (pHVar2->targetClass).put_block = pHVar1->put_block;
  }
  return pHVar2;
}



// WARNING: Unknown calling convention

void HText_free(HText *self)

{
  TextAnchor *pTVar1;
  BOOLEAN BVar2;
  void **local_18;
  HTList *cur;
  HTTabID *Tab;
  TextAnchor *l;
  
  if (self != (HText *)0x0) {
    while (self->first_anchor != (TextAnchor *)0x0) {
      pTVar1 = self->first_anchor;
      self->first_anchor = pTVar1->next;
      if ((pTVar1->link_type == '\x02') && (pTVar1->input_field != (FormInfo *)0x0)) {
        free_form_fields(pTVar1->input_field);
      }
      if ((pTVar1->lites).hl_info != (HiliteInfo *)0x0) {
        free((pTVar1->lites).hl_info);
        (pTVar1->lites).hl_info = (HiliteInfo *)0x0;
      }
    }
    FormList_delete(self->forms);
    if (self->tabs != (HTList *)0x0) {
      cur = self->tabs;
      while( true ) {
        if ((cur == (HTList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
          local_18 = (void **)0x0;
        }
        else {
          local_18 = (void **)cur->object;
        }
        if (local_18 == (void **)0x0) break;
        if (*local_18 != (void *)0x0) {
          free(*local_18);
          *local_18 = (void *)0x0;
        }
        if (local_18 != (void **)0x0) {
          free(local_18);
        }
      }
      HTList_delete(self->tabs);
      self->tabs = (HTList *)0x0;
    }
    if (self->hidden_links != (HTList *)0x0) {
      LYFreeStringList(self->hidden_links);
      self->hidden_links = (HTList *)0x0;
    }
    if (self->node_anchor != (HTParentAnchor *)0x0) {
      HTAnchor_resetUCInfoStage(self->node_anchor,-1,2,0);
      HTAnchor_resetUCInfoStage(self->node_anchor,-1,3,0);
      HTAnchor_clearSourceCache(self->node_anchor);
      HTAnchor_delete_links(self->node_anchor);
      HTAnchor_setDocument(self->node_anchor,(HyperDoc *)0x0);
      BVar2 = HTAnchor_delete(self->node_anchor->parent);
      if (BVar2 != '\0') {
        HTMainAnchor = (HTParentAnchor *)0x0;
      }
    }
    POOL_FREE(self->pool);
    if (self != (HText *)0x0) {
      free(self);
    }
  }
  return;
}



// WARNING: Unknown calling convention

wchar_t display_line(HTLine *line,HText *text,wchar_t scrline,char *target)

{
  char *__src;
  ushort **ppuVar1;
  size_t sVar2;
  int local_4c;
  uint local_48;
  int local_40;
  int local_38;
  int local_34;
  int local_30;
  uint local_2c;
  uint local_28;
  char buffer [7];
  wchar_t x;
  wchar_t y;
  wchar_t current_style;
  size_t utf_extra;
  char *data;
  char LastDisplayChar;
  
  utf_extra = 0;
  LastDisplayChar = ' ';
  current_style = L'\0';
  LYmove(scrline,L'\0');
  buffer[2] = '\0';
  buffer[1] = '\0';
  buffer[0] = '\0';
  LYclrtoeol();
  local_28 = (uint)line->offset;
  if (LYwideLines == L'\0') {
    local_4c = LYcols;
  }
  else {
    local_4c = 0x3f6;
  }
  if (local_4c <= (int)local_28) {
    if (LYwideLines == L'\0') {
      local_48 = LYcols - 1;
    }
    else {
      local_48 = 0x3f5;
    }
    local_28 = local_48;
  }
  if (line->size == 0) {
    local_2c = local_28;
  }
  else {
    for (local_2c = 0; (int)local_2c < (int)local_28; local_2c = local_2c + 1) {
      waddch(LYwin,0x20);
    }
  }
  local_2c = local_2c + 1;
  __src = line->data;
LAB_0805e4d5:
  while( true ) {
    data = __src;
    if (LYwideLines == L'\0') {
      local_30 = LYcols;
    }
    else {
      local_30 = 0x3f6;
    }
    if ((local_30 < (int)local_2c) || (buffer[0] = *data, buffer[0] == '\0')) {
      waddch(LYwin,10);
      for (; current_style < (int)(uint)line->numstyles; current_style = current_style + L'\x01') {
        curses_style((uint)*(ushort *)&line->styles[current_style].field_0x2,
                     (uint)(*(byte *)(line->styles + current_style) & 3));
      }
      return L'\0';
    }
    __src = data + 1;
    while ((current_style < (int)(uint)line->numstyles &&
           ((int)((uint)(*(ushort *)(line->styles + current_style) >> 2) + (uint)line->offset + 1)
            <= (int)local_2c))) {
      curses_style((uint)*(ushort *)&line->styles[current_style].field_0x2,
                   (uint)(*(byte *)(line->styles + current_style) & 3));
      current_style = current_style + L'\x01';
    }
    if (buffer[0] == '\a') goto LAB_0805e2c4;
    if (buffer[0] != '\b') break;
    if (dump_output_immediately == '\0') {
      waddch(LYwin,0x2b);
      local_2c = local_2c + 1;
    }
  }
  goto LAB_0805e306;
LAB_0805e2c4:
  if (((*__src == '\0') &&
      (ppuVar1 = __ctype_b_loc(), ((*ppuVar1)[(byte)LastDisplayChar] & 0x2000) == 0)) &&
     (LastDisplayChar != '-')) {
    buffer[0] = '-';
LAB_0805e306:
    if (((text->T).output_utf8 != '\0') && (buffer[0] < '\0')) {
      text->has_utf8 = '\x01';
      utf_extra = utf8_length((text->T).output_utf8,data);
      LastDisplayChar = 'M';
    }
    if (utf_extra == 0) {
      if ((HTCJK == NOCJK) || (-1 < buffer[0])) {
        sVar2 = strlen(buffer);
        LYwaddnstr(LYwin,buffer,sVar2);
        LastDisplayChar = buffer[0];
      }
      else {
        if (LYwideLines == L'\0') {
          local_40 = LYcols;
        }
        else {
          local_40 = 0x3f6;
        }
        if ((int)local_2c <= local_40) {
          buffer[1] = *__src;
          buffer[2] = '\0';
          __src = data + 2;
          local_2c = local_2c + 1;
          sVar2 = strlen(buffer);
          LYwaddnstr(LYwin,buffer,sVar2);
          buffer[1] = '\0';
          LastDisplayChar = 'M';
          if (LYwin == (WINDOW *)0x0) {
            local_38 = -1;
          }
          else {
            local_38 = (int)LYwin->_curx;
          }
          if (LYwideLines == L'\0') {
            local_34 = LYcols;
          }
          else {
            local_34 = 0x3f6;
          }
          if ((local_34 <= local_38) || (local_38 == 0)) goto LAB_0805e4d5;
        }
      }
    }
    else {
      strncpy(buffer + 1,__src,utf_extra);
      buffer[utf_extra + 1] = '\0';
      sVar2 = strlen(buffer);
      LYwaddnstr(LYwin,buffer,sVar2);
      buffer[1] = '\0';
      __src = __src + utf_extra;
      utf_extra = 0;
    }
    data = __src;
    local_2c = local_2c + 1;
    __src = data;
  }
  goto LAB_0805e4d5;
}



void display_title(HText *text)

{
  int iVar1;
  BOOLEAN BVar2;
  char *pcVar3;
  wchar_t wVar4;
  int iVar5;
  size_t sVar6;
  uchar *sjis;
  wchar_t wVar7;
  int in_GS_OFFSET;
  bool bVar8;
  char *local_5c;
  wchar_t local_58;
  int local_54;
  undefined4 local_50;
  HText *text_local;
  wchar_t c;
  wchar_t start_of_last_page;
  wchar_t total_pages;
  wchar_t limit;
  wchar_t toolbar;
  wchar_t j;
  wchar_t i;
  uchar *tmp;
  char *title;
  char percent [20];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  title = (char *)0x0;
  if (text != (HText *)0x0) {
    lynx_start_title_color();
    if (last_colorattr_ptr < 1) {
      curses_style(s_title,L'\x02');
    }
    else {
      curses_style(s_title,L'\x01');
    }
    pcVar3 = HTAnchor_title(text->node_anchor);
    if (pcVar3 == (char *)0x0) {
      local_5c = " ";
    }
    else {
      local_5c = HTAnchor_title(text->node_anchor);
    }
    HTSACopy(&title,local_5c);
    LYReduceBlanks(title);
    wVar4 = LYscreenWidth();
    if (wVar4 < L'\n') {
      percent[0] = '\0';
    }
    else if ((((display_lines < 1) && (0 < LYlines)) && (text->top_of_screen < L'')) &&
            (text->Lines < L'\x000f4240')) {
      sprintf(percent," (l%d of %d)",text->top_of_screen,text->Lines);
    }
    else if ((text->Lines < display_lines) || (display_lines < 1)) {
      percent[0] = '\0';
    }
    else {
      iVar5 = (text->Lines + display_lines) / display_lines;
      if (display_lines < text->Lines) {
        local_58 = text->Lines - display_lines;
      }
      else {
        local_58 = L'\0';
      }
      local_54 = iVar5;
      if (text->top_of_screen <= local_58) {
        local_54 = (text->top_of_screen + display_lines) / display_lines;
      }
      sprintf(percent," (p%d of %d)",local_54,iVar5);
    }
    if ((HTCJK != NOCJK) && (*title != '\0')) {
      sVar6 = strlen(title);
      sjis = (uchar *)calloc((sVar6 + 0x80) * 2,1);
      if (sjis != (uchar *)0x0) {
        if (kanji_code == EUC) {
          TO_EUC((uchar *)title,sjis);
        }
        else if (kanji_code == SJIS) {
          TO_SJIS((uchar *)title,sjis);
        }
        else {
          j = L'\0';
          for (i = L'\0'; title[i] != '\0'; i = i + L'\x01') {
            if (title[i] != '\x1b') {
              sjis[j] = title[i];
              j = j + L'\x01';
            }
          }
          sjis[j] = '\0';
        }
        HTSACopy(&title,(char *)sjis);
        if (sjis != (uchar *)0x0) {
          free(sjis);
        }
      }
    }
    LYmove(L'\0',L'\0');
    LYclrtoeol();
    BVar2 = HText_hasToolbar(text);
    if (BVar2 != '\0') {
      waddch(LYwin,0x23);
    }
    toolbar = (wchar_t)(BVar2 != '\0');
    if ((s_forw_backw != -1) && ((nhist != 0 || (1 < nhist_extra)))) {
      if (nhist == 0) {
        local_50 = 0x20;
      }
      else {
        local_50 = acs_map._176_4_;
      }
      curses_style(s_forw_backw,L'\x01');
      if (nhist == 0) {
        LYmove(L'\0',toolbar + L'\x03');
      }
      else {
        waddch(LYwin,local_50);
        waddch(LYwin,local_50);
        waddch(LYwin,local_50);
      }
      if (1 < nhist_extra) {
        waddch(LYwin,acs_map._172_4_);
        waddch(LYwin,acs_map._172_4_);
        waddch(LYwin,acs_map._172_4_);
      }
      curses_style(s_forw_backw,L'\0');
    }
    bVar8 = LYShowScrollbar != '\0';
    sVar6 = strlen(percent);
    wVar7 = LYstrCells(title);
    i = ((wVar4 - (uint)bVar8) - sVar6) - wVar7;
    if (i < L'\x01') {
      bVar8 = LYShowScrollbar != '\0';
      sVar6 = strlen(percent);
      pcVar3 = title;
      wVar4 = ((wVar4 - (uint)bVar8) - sVar6) + L'\xfffffffd';
      if (wVar4 < L'\x01') {
        *title = '\0';
      }
      else {
        wVar4 = LYstrExtent2(title,wVar4);
        memcpy(pcVar3 + wVar4,&DAT_0814cce2,4);
      }
      i = L'\0';
    }
    LYmove(L'\0',i);
    sVar6 = strlen(title);
    LYwaddnstr(LYwin,title,sVar6);
    if (percent[0] != '\0') {
      sVar6 = strlen(percent);
      LYwaddnstr(LYwin,percent,sVar6);
    }
    waddch(LYwin,10);
    if (title != (char *)0x0) {
      free(title);
      title = (char *)0x0;
    }
    if (s_hot_paste != -1) {
      LYmove(L'\0',LYcols - (uint)(LYShowScrollbar != '\0'));
      curses_style(s_hot_paste,L'\x01');
      waddch(LYwin,acs_map._172_4_);
      curses_style(s_hot_paste,L'\0');
      LYmove(L'\x01',L'\0');
    }
    curses_style(s_title,L'\0');
    lynx_stop_title_color();
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void display_scrollbar(HText *text)

{
  wchar_t wVar1;
  int iVar2;
  bool bVar3;
  int local_48;
  wchar_t local_44;
  wchar_t local_40;
  wchar_t s_1;
  wchar_t s;
  wchar_t shown;
  wchar_t sh;
  wchar_t bot_skip;
  wchar_t top_skip;
  wchar_t off;
  wchar_t h;
  wchar_t i;
  
  if (LYsb_arrow == '\0') {
    local_48 = 0;
  }
  else {
    local_48 = 2;
  }
  wVar1 = display_lines - local_48;
  bVar3 = LYsb_arrow != '\0';
  LYsb_end = L'\xffffffff';
  LYsb_begin = L'\xffffffff';
  if ((((LYShowScrollbar != '\0') && (text != (HText *)0x0)) && (L'\x02' < wVar1)) &&
     (display_lines < text->Lines)) {
    if (text->top_of_screen < text->Lines - display_lines) {
      shown = display_lines;
    }
    else {
      shown = text->Lines - text->top_of_screen;
      if (shown < L'\x01') {
        shown = L'\x01';
      }
    }
    sh = (shown * wVar1 + text->Lines / 2) / text->Lines;
    if (sh < L'\x01') {
      sh = L'\x01';
    }
    if (wVar1 + L'\xffffffff' <= sh) {
      sh = wVar1 + L'\xfffffffe';
    }
    if (text->top_of_screen == L'\0') {
      top_skip = L'\0';
    }
    else if (text->Lines + (1 - (text->top_of_screen + display_lines)) < 1) {
      top_skip = wVar1 - sh;
    }
    else {
      top_skip = (wchar_t)ROUND((longdouble)1 +
                                ((longdouble)text->top_of_screen * (longdouble)((wVar1 - sh) + -1))
                                / (longdouble)((text->Lines - display_lines) + 1));
    }
    iVar2 = (wVar1 - sh) - top_skip;
    LYsb_begin = top_skip;
    LYsb_end = wVar1 - iVar2;
    if (LYsb_arrow != '\0') {
      if (top_skip == L'\0') {
        local_44 = s_sb_naa;
      }
      else {
        local_44 = s_sb_aa;
      }
      if (last_colorattr_ptr < 1) {
        curses_style(local_44,L'\x02');
      }
      else {
        curses_style(local_44,L'\x01');
      }
      LYmove(L'\x01',(LYcols - (uint)(LYShowScrollbar != '\0')) + LYshiftWin);
      waddch(LYwin,acs_map._180_4_);
      curses_style(local_44,L'\0');
    }
    if (last_colorattr_ptr < 1) {
      curses_style(s_sb_bg,L'\x02');
    }
    else {
      curses_style(s_sb_bg,L'\x01');
    }
    for (i = L'\x01'; i <= wVar1; i = i + L'\x01') {
      if ((i + L'\xffffffff' <= top_skip) && (top_skip < i)) {
        curses_style(s_sb_bar,L'\x01');
      }
      if ((i + L'\xffffffff' <= wVar1 - iVar2) && (wVar1 - iVar2 < i)) {
        curses_style(s_sb_bar,L'\0');
      }
      LYmove(i + (uint)bVar3,(LYcols - (uint)(LYShowScrollbar != '\0')) + LYshiftWin);
      if ((top_skip < i) && (i <= wVar1 - iVar2)) {
        waddch(LYwin,acs_map._192_4_);
      }
      else {
        waddch(LYwin,acs_map._388_4_);
      }
    }
    curses_style(s_sb_bg,L'\0');
    if (LYsb_arrow != '\0') {
      if (iVar2 == 0) {
        local_40 = s_sb_naa;
      }
      else {
        local_40 = s_sb_aa;
      }
      if (last_colorattr_ptr < 1) {
        curses_style(local_40,L'\x02');
      }
      else {
        curses_style(local_40,L'\x01');
      }
      LYmove(wVar1 + L'\x02',(LYcols - (uint)(LYShowScrollbar != '\0')) + LYshiftWin);
      waddch(LYwin,acs_map._184_4_);
      curses_style(local_40,L'\0');
    }
  }
  return;
}



// WARNING: Unknown calling convention

void display_page(HText *text,wchar_t line_number,char *target)

{
  int cur;
  size_t __n;
  size_t sVar1;
  char *pcVar2;
  wchar_t wVar3;
  FILE *pFVar4;
  wchar_t local_90;
  char *local_8c;
  int local_84;
  char *local_80;
  char *local_7c;
  char *local_78;
  char tmp [7];
  char *cp_AnchorAddress;
  char *s;
  wchar_t count;
  char *hi_string;
  wchar_t y;
  size_t utf_extra;
  wchar_t len;
  wchar_t x_pos;
  wchar_t written;
  wchar_t itmp;
  wchar_t LenNeeded;
  wchar_t offset;
  char *data;
  wchar_t last_disp_partial;
  HTAnchor *link_dest_intl;
  HTAnchor *link_dest;
  FormInfo *FormInfo_ptr;
  wchar_t stop_before_for_anchors;
  TextAnchor *Anchor_ptr;
  char *cp;
  wchar_t title_lines;
  wchar_t i;
  HTLine *line;
  BOOLEAN display_flag;
  
  line = (HTLine *)0x0;
  title_lines = L'\x01';
  Anchor_ptr = (TextAnchor *)0x0;
  display_flag = '\0';
  link_dest_intl = (HTAnchor *)0x0;
  last_disp_partial = L'\xffffffff';
  lynx_mode = '\x01';
  if (text == (HText *)0x0) {
    if (enable_scrollback != '\0') {
      waddch(LYwin,0x2a);
      LYrefresh();
      LYclear();
    }
    LYwaddnstr(LYwin,"\n\nError accessing document!\nNo data available!\n",0x2f);
    LYrefresh();
    nlinks = 0;
    return;
  }
  if (((display_partial != '\0') || (recent_sizechange != '\0')) || (text->stale != '\0')) {
    ResetPartialLinenos(text);
  }
  tmp[2] = '\0';
  tmp[1] = '\0';
  tmp[0] = '\0';
  if ((target != (char *)0x0) && (*target == '\0')) {
    target = (char *)0x0;
  }
  text->page_has_target = '\0';
  if (display_lines < 1) {
    return;
  }
  line = text->last_line->prev;
  line_number = HText_getPreferredTopLine(text,line_number);
  i = L'\0';
  for (line = text->last_line->next; (i < line_number && (text->last_line != line));
      line = line->next) {
    if (LYNoCore == '\0') {
      if (line->next == (_line *)0x0) {
                    // WARNING: Subroutine does not return
        __assert_fail("line->next != ((void *)0)","./GridText.c",0x7e0,"display_page");
      }
    }
    else if (line->next == (_line *)0x0) {
      if (enable_scrollback != '\0') {
        waddch(LYwin,0x2a);
        LYrefresh();
        LYclear();
      }
      LYwaddnstr(LYwin,"\n\nError drawing page!\nBad HText structure!\n",0x2b);
      LYrefresh();
      nlinks = 0;
      return;
    }
    i = i + L'\x01';
  }
  if (((LYlowest_eightbit[current_char_set] < 0x100) &&
      (current_char_set != display_page::charset_last_displayed)) && (LYCursesON != '\0')) {
    display_page::charset_last_displayed = current_char_set;
  }
  if (enable_scrollback != '\0') {
    waddch(LYwin,0x2a);
    LYrefresh();
    LYclear();
  }
  if ((text->stale != '\0') || (text->top_of_screen + display_lines != line_number)) {
    last_colorattr_ptr = 0;
  }
  text->top_of_screen = line_number;
  text->top_of_screen_line = line;
  if (no_title == '\0') {
    display_title(text);
  }
  else {
    LYmove(L'\0',L'\0');
    title_lines = L'\0';
  }
  display_flag = '\x01';
  if (((display_partial != '\0') || (text->first_lineno_last_disp_partial != line_number)) ||
     (text->last_lineno_last_disp_partial < line_number)) {
    ResetCachedStyles();
  }
  if ((display_partial == '\0') || (text->stbl == (STable_info *)0x0)) {
    stop_before_for_anchors = display_lines + line_number;
  }
  else {
    stop_before_for_anchors = Stbl_getStartLineDeep(text->stbl);
    if (display_lines + line_number < stop_before_for_anchors) {
      stop_before_for_anchors = display_lines + line_number;
    }
  }
  if (line != (HTLine *)0x0) {
    if ((display_partial != '\0') || (text->first_lineno_last_disp_partial != line_number)) {
      text->has_utf8 = '\0';
    }
    for (i = L'\0'; i < display_lines; i = i + L'\x01') {
      if (LYNoCore == '\0') {
        if (line == (HTLine *)0x0) {
                    // WARNING: Subroutine does not return
          __assert_fail("line != ((void *)0)","./GridText.c",0x848,"display_page");
        }
      }
      else if (line == (HTLine *)0x0) {
        if (enable_scrollback != '\0') {
          waddch(LYwin,0x2a);
          LYrefresh();
          LYclear();
        }
        LYwaddnstr(LYwin,"\n\nError drawing page!\nBad HText structure!\n",0x2b);
        LYrefresh();
        nlinks = 0;
        return;
      }
      if (((display_partial == '\0') && (text->first_lineno_last_disp_partial == line_number)) &&
         (i + line_number <= text->last_lineno_last_disp_partial)) {
        LYmove(i + title_lines + L'\x01',L'\0');
      }
      else {
        display_line(line,text,i + L'\x01',target);
      }
      data = line->data;
      offset = (wchar_t)line->offset;
      while ((target != (char *)0x0 && (*target != '\0'))) {
        if (case_sensitive == '\0') {
          local_8c = LYno_attr_mbcs_case_strstr
                               (data,target,(text->T).output_utf8,'\x01',(wchar_t *)0x0,&LenNeeded);
        }
        else {
          local_8c = LYno_attr_mbcs_strstr
                               (data,target,(text->T).output_utf8,'\x01',(wchar_t *)0x0,&LenNeeded);
        }
        cp = local_8c;
        if (local_8c == (char *)0x0) break;
        if (LYwideLines == L'\0') {
          local_84 = LYcols;
        }
        else {
          local_84 = 0x3f6;
        }
        if (local_84 < (uint)line->offset + LenNeeded) break;
        itmp = L'\0';
        written = L'\0';
        x_pos = (wchar_t)(local_8c + (offset - (int)data));
        wVar3 = strlen(target);
        text->page_has_target = '\x01';
        LYstartTargetEmphasis();
        for (; (written < wVar3 && (tmp[0] = data[itmp], tmp[0] != '\0')); itmp = itmp + L'\x01') {
          if ((tmp[0] < '\x03') || (('\b' < tmp[0] || (tmp[0] == '\b')))) {
            if (cp <= data + itmp) {
              if (data + itmp == cp) {
                LYmove(i + title_lines,x_pos);
              }
              __n = utf8_length((text->T).output_utf8,data + itmp);
              if (__n == 0) {
                if ((HTCJK == NOCJK) || (-1 < tmp[0])) {
                  sVar1 = strlen(tmp);
                  LYwaddnstr(LYwin,tmp,sVar1);
                  written = written + L'\x01';
                }
                else {
                  itmp = itmp + L'\x01';
                  tmp[1] = data[itmp];
                  sVar1 = strlen(tmp);
                  LYwaddnstr(LYwin,tmp,sVar1);
                  tmp[1] = '\0';
                  written = written + L'\x02';
                }
              }
              else {
                strncpy(tmp + 1,line->data + itmp + L'\x01',__n);
                tmp[__n + 1] = '\0';
                itmp = itmp + __n;
                sVar1 = strlen(tmp);
                LYwaddnstr(LYwin,tmp,sVar1);
                tmp[1] = '\0';
                written = written + __n + L'\x01';
              }
            }
          }
          else {
            x_pos = x_pos + L'\xffffffff';
          }
        }
        LYstopTargetEmphasis();
        if (LYwin == (WINDOW *)0x0) {
          local_90 = L'\xffffffff';
        }
        else {
          local_90 = (wchar_t)LYwin->_curx;
        }
        offset = local_90;
        data = data + itmp;
        LYmove(i + title_lines + L'\x01',L'\0');
      }
      if (text->last_line == line) goto LAB_0805f90b;
      if (display_partial != '\0') {
        last_disp_partial = i + line_number;
      }
      display_flag = '\x01';
      line = line->next;
    }
  }
LAB_0805f94c:
  text->next_line = line;
  text->stale = '\0';
  nlinks = 0;
  Anchor_ptr = text->first_anchor;
  while( true ) {
    if ((Anchor_ptr == (TextAnchor *)0x0) || (stop_before_for_anchors < Anchor_ptr->line_num))
    goto LAB_0805ffa7;
    if ((line_number <= Anchor_ptr->line_num) && (Anchor_ptr->line_num < stop_before_for_anchors)) {
      pcVar2 = LYGetHiTextStr(Anchor_ptr,L'\0');
      if ((((Anchor_ptr->show_anchor == '\0') || (pcVar2 == (char *)0x0)) || (*pcVar2 == '\0')) ||
         ((Anchor_ptr->link_type & 1U) != 1)) {
        if ((Anchor_ptr->link_type == '\x02') && (Anchor_ptr->input_field->type != L'\b')) {
          lynx_mode = '\x02';
          FormInfo_ptr = Anchor_ptr->input_field;
          links[nlinks].sgml_offset = Anchor_ptr->sgml_offset;
          links[nlinks].anchor_number = Anchor_ptr->number;
          links[nlinks].anchor_line_num = Anchor_ptr->line_num;
          links[nlinks].l_form = (_FormInfo *)FormInfo_ptr;
          links[nlinks].lx = (int)Anchor_ptr->line_pos;
          links[nlinks].ly = (Anchor_ptr->line_num + L'\x01') - line_number;
          links[nlinks].type = 1;
          links[nlinks].inUnderline = Anchor_ptr->inUnderline;
          links[nlinks].target = empty_string;
          HTSACopy(&links[nlinks].lname,empty_string);
          if (FormInfo_ptr->type == L'\x04') {
            if (FormInfo_ptr->num_value == L'\0') {
              local_80 = unchecked_radio;
            }
            else {
              local_80 = checked_radio;
            }
            LYSetHilite(nlinks,local_80);
          }
          else if (FormInfo_ptr->type == L'\x03') {
            if (FormInfo_ptr->num_value == L'\0') {
              local_7c = unchecked_box;
            }
            else {
              local_7c = checked_box;
            }
            LYSetHilite(nlinks,local_7c);
          }
          else if (FormInfo_ptr->type == L'\x02') {
            wVar3 = LYstrCells(FormInfo_ptr->value);
            if (wVar3 < L'') {
              wVar3 = LYstrCells(FormInfo_ptr->value);
              local_78 = star_string + (0x3ff - wVar3);
            }
            else {
              local_78 = star_string;
            }
            LYSetHilite(nlinks,local_78);
          }
          else {
            LYSetHilite(nlinks,FormInfo_ptr->value);
          }
          cur = nlinks;
          nlinks = nlinks + 1;
          LYhighlight(L'\0',cur,target);
          display_flag = '\x01';
        }
        else if ((pcVar2 != (char *)0x0) && ((*pcVar2 != '\0' && (WWW_TraceFlag != '\0')))) {
          pFVar4 = TraceFP();
          fprintf((FILE *)pFVar4,"\nGridText: Not showing link, hightext=%s\n",pcVar2);
        }
      }
      else {
        count = L'\0';
        while( true ) {
          pcVar2 = LYGetHiTextStr(Anchor_ptr,count);
          if (count == L'\0') {
            LYSetHilite(nlinks,pcVar2);
          }
          if (pcVar2 == (char *)0x0) break;
          if (count != L'\0') {
            wVar3 = LYGetHiTextPos(Anchor_ptr,count);
            LYAddHilite(nlinks,pcVar2,wVar3);
          }
          count = count + L'\x01';
        }
        links[nlinks].inUnderline = Anchor_ptr->inUnderline;
        links[nlinks].sgml_offset = Anchor_ptr->sgml_offset;
        links[nlinks].anchor_number = Anchor_ptr->number;
        links[nlinks].anchor_line_num = Anchor_ptr->line_num;
        link_dest = HTAnchor_followLink(Anchor_ptr->anchor);
        if (traversal == '\0') {
          cp_AnchorAddress = HTAnchor_address(link_dest);
        }
        else {
          cp_AnchorAddress = stub_HTAnchor_address(link_dest);
        }
        if (links[nlinks].lname != (char *)0x0) {
          free(links[nlinks].lname);
          links[nlinks].lname = (char *)0x0;
        }
        if (cp_AnchorAddress == (char *)0x0) {
          HTSACopy(&links[nlinks].lname,empty_string);
        }
        else {
          links[nlinks].lname = cp_AnchorAddress;
        }
        links[nlinks].lx = (int)Anchor_ptr->line_pos;
        links[nlinks].ly = (Anchor_ptr->line_num + L'\x01') - line_number;
        if (link_dest_intl == (HTAnchor *)0x0) {
          links[nlinks].type = 2;
        }
        else {
          links[nlinks].type = 6;
        }
        links[nlinks].target = empty_string;
        links[nlinks].l_form = (_FormInfo *)0x0;
        nlinks = nlinks + 1;
        display_flag = '\x01';
      }
    }
    if (nlinks == 0x400) break;
    Anchor_ptr = Anchor_ptr->next;
  }
  if (LYCursesON != '\0') {
    pcVar2 = (char *)gettext(
                            "Maximum links per page exceeded!  Use half-page or two-line scrolling."
                            );
    HTAlert(pcVar2);
  }
  if (WWW_TraceFlag != '\0') {
    pFVar4 = TraceFP();
    fprintf((FILE *)pFVar4,"\ndisplay_page: MAXLINKS reached.\n");
  }
LAB_0805ffa7:
  LYFreeHilites(nlinks,display_page::last_nlinks);
  display_page::last_nlinks = nlinks;
  more_links = '\0';
  if (((traversal != '\0') && (Anchor_ptr != (TextAnchor *)0x0)) &&
     (Anchor_ptr->next != (_TextAnchor *)0x0)) {
    more_links = '\x01';
  }
  if (display_flag == '\0') {
    LYwaddnstr(LYwin,"\n     Document is empty",0x17);
  }
  display_scrollbar(text);
  if (((display_partial == '\0') || (display_flag == '\0')) ||
     ((last_disp_partial < text->top_of_screen ||
      ((enable_scrollback != '\0' || (recent_sizechange != '\0')))))) {
    ResetPartialLinenos(text);
  }
  else {
    text->first_lineno_last_disp_partial = text->top_of_screen;
    text->last_lineno_last_disp_partial = last_disp_partial;
  }
  LYrefresh();
  return;
LAB_0805f90b:
  while (i = i + L'\x01', i < display_lines) {
    LYmove(i + title_lines,L'\0');
    LYclrtoeol();
  }
  goto LAB_0805f94c;
}



// WARNING: Unknown calling convention

void HText_beginAppend(HText *text)

{
  text->permissible_split = 0;
  text->in_line_1 = '\x01';
  return;
}



wchar_t set_style_by_embedded_chars(char *s,char *e,uchar start_c,uchar end_c)

{
  uchar end_c_local;
  uchar start_c_local;
  wchar_t ret;
  
  while( true ) {
    e = e + -1;
    if (e < s) {
      return L'\0';
    }
    if ((int)*e == (uint)end_c) break;
    if ((int)*e == (uint)start_c) {
      return L'\x01';
    }
  }
  return L'\0';
}



// WARNING: Unknown calling convention

void move_anchors_in_region
               (HTLine *line,wchar_t line_number,TextAnchor **prev_anchor,
               wchar_t *prev_head_processed,wchar_t sbyte,wchar_t ebyte,wchar_t shift)

{
  short sVar1;
  int local_18;
  wchar_t last;
  wchar_t head_processed;
  TextAnchor *a;
  
  head_processed = *prev_head_processed;
  a = *prev_anchor;
  do {
    if ((a == (TextAnchor *)0x0) || (line_number < a->line_num)) goto LAB_0806024b;
    if (a->extent == 0) {
      local_18 = 0;
    }
    else {
      local_18 = a->extent + -1;
    }
    last = a->line_pos + local_18;
    if (line_number + L'\xffffffff' <= a->line_num) {
      if (a->line_num == line_number + L'\xffffffff') {
        last = last + ~(uint)line->prev->size;
      }
      if (sbyte <= last) {
        if (((head_processed == L'\0') && (a->line_num == line_number)) && (ebyte <= a->line_pos)) {
LAB_0806024b:
          *prev_anchor = a;
          *prev_head_processed = head_processed;
          return;
        }
        sVar1 = (short)shift;
        if (((head_processed == L'\0') && (a->line_num == line_number)) && (sbyte <= a->line_pos)) {
          a->line_pos = a->line_pos + sVar1;
          a->extent = a->extent - sVar1;
          head_processed = L'\x01';
        }
        if (ebyte <= last) goto LAB_0806024b;
        a->extent = a->extent + sVar1;
      }
    }
    a = a->next;
    head_processed = L'\0';
  } while( true );
}



// WARNING: Unknown calling convention

HTLine * insert_blanks_in_line
                   (HTLine *line,wchar_t line_number,HText *text,TextAnchor **prev_anchor,
                   wchar_t ninserts,wchar_t *oldpos,wchar_t *newpos)

{
  wchar_t wVar1;
  char *pcVar2;
  bool bVar3;
  HTLine *local_54;
  wchar_t local_50;
  wchar_t local_4c;
  wchar_t local_48;
  wchar_t delta;
  wchar_t curlim;
  char *t;
  char *copied;
  char *pre;
  char *s;
  char *newdata;
  HTLine *mod_line;
  wchar_t head_processed;
  wchar_t shift;
  wchar_t added_chars;
  wchar_t istyle;
  wchar_t ip;
  wchar_t ioldc;
  
  ioldc = L'\0';
  istyle = L'\0';
  added_chars = L'\0';
  shift = L'\0';
  pre = line->data;
  copied = line->data;
  if (((line == (HTLine *)0x0) || (line->size == 0)) || (ninserts == L'\0')) {
    local_54 = (HTLine *)0x0;
  }
  else {
    for (ip = L'\0'; ip < ninserts; ip = ip + L'\x01') {
      if ((oldpos[ip] < newpos[ip]) && (added_chars < newpos[ip] - oldpos[ip])) {
        added_chars = newpos[ip] - oldpos[ip];
      }
    }
    if ((uint)line->size + added_chars < 0x3ff) {
      if (text->last_line == line) {
        if (text->temp_line == (HTLineTemp *)line) {
          mod_line = (HTLine *)(text->temp_line + 1);
        }
        else {
          mod_line = (HTLine *)text->temp_line;
        }
      }
      else {
        mod_line = (HTLine *)ALLOC_IN_POOL(&HTMainText->pool,(uint)line->size + added_chars + 0x14);
      }
      if (mod_line == (HTLine *)0x0) {
        local_54 = (HTLine *)0x0;
      }
      else {
        if (*prev_anchor == (TextAnchor *)0x0) {
          *prev_anchor = text->first_anchor;
        }
        if ((*prev_anchor == (TextAnchor *)0x0) || (line_number <= (*prev_anchor)->line_num)) {
          local_50 = L'\0';
        }
        else {
          local_50 = L'\x01';
        }
        head_processed = local_50;
        memcpy(mod_line,line,0x14);
        pcVar2 = mod_line->data;
        t = pcVar2;
        s = pre;
        for (ip = L'\0'; ip <= ninserts; ip = ip + L'\x01') {
          if (ip < ninserts) {
            local_4c = oldpos[ip];
          }
          else {
            if (line->size < 0x401) {
              local_48 = L'';
            }
            else {
              local_48 = (uint)line->size + L'\x01';
            }
            local_4c = local_48;
          }
          pre = s;
          for (; *s != '\0'; s = s + 1) {
            if ((((text == (HText *)0x0) || ((text->T).output_utf8 == '\0')) || (-1 < *s)) ||
               (0xbf < (byte)*s)) {
              if ((*s < '\x03') || ('\b' < *s)) {
                if (local_4c <= ioldc) break;
                ioldc = ioldc + L'\x01';
                pre = s + 1;
              }
            }
            else {
              pre = s + 1;
            }
          }
          if (ip != L'\0') {
            move_anchors_in_region
                      (line,line_number,prev_anchor,&head_processed,(int)copied - (int)line->data,
                       (int)pre - (int)line->data,shift);
          }
          while ((istyle < (int)(uint)line->numstyles &&
                 ((int)(uint)(*(ushort *)(mod_line->styles + istyle) >> 2) < local_4c))) {
            *(ushort *)(mod_line->styles + istyle) =
                 *(ushort *)(mod_line->styles + istyle) & 3 |
                 ((*(ushort *)(mod_line->styles + istyle) >> 2) + (short)shift) * 4;
            istyle = istyle + L'\x01';
          }
          for (; copied < pre; copied = copied + 1) {
            *t = *copied;
            t = t + 1;
          }
          if (ip < ninserts) {
            delta = (newpos[ip] - oldpos[ip]) - shift;
            if (delta < L'\0') {
              for (; ((wVar1 = delta + L'\x01', bVar3 = delta < L'\0', delta = wVar1, bVar3 &&
                      (pcVar2 < t)) && (t[-1] == ' ')); t = t + -1) {
                shift = shift + L'\xffffffff';
              }
            }
            else {
              shift = newpos[ip] - oldpos[ip];
            }
            while (L'\0' < delta) {
              *t = ' ';
              t = t + 1;
              delta = delta + L'\xffffffff';
            }
          }
        }
        for (; pre < s; pre = pre + 1) {
          *t = *pre;
          t = t + 1;
        }
        if (((head_processed != L'\0') && (*prev_anchor != (TextAnchor *)0x0)) &&
           ((*prev_anchor)->line_num == line_number)) {
          (*prev_anchor)->extent = (*prev_anchor)->extent + (short)shift;
        }
        *t = '\0';
        mod_line->size = (short)t - (short)pcVar2;
        local_54 = mod_line;
      }
    }
    else {
      local_54 = (HTLine *)0x0;
    }
  }
  return local_54;
}



// WARNING: Unknown calling convention

HTStyleChange *
skip_matched_and_correct_offsets(HTStyleChange *end,HTStyleChange *start,uint split_pos)

{
  HTStyleChange *tmp;
  wchar_t level;
  
  level = L'\0';
  tmp = end;
  do {
    if (tmp < start) {
      return (HTStyleChange *)0x0;
    }
    if (*(short *)&tmp->field_0x2 == *(short *)&end->field_0x2) {
      if ((*(byte *)tmp & 3) == 0) {
        level = level + L'\xffffffff';
      }
      else {
        if ((*(byte *)tmp & 3) != 1) {
          return (HTStyleChange *)0x0;
        }
        level = level + L'\x01';
        if (level == L'\0') {
          return tmp;
        }
      }
    }
    if (split_pos < *(ushort *)tmp >> 2) {
      *(ushort *)tmp = *(ushort *)tmp & 3 | (short)split_pos * 4;
    }
    tmp = tmp + -1;
  } while( true );
}



// WARNING: Restarted to delay deadcode elimination for space: ram
// WARNING: Unknown calling convention

void split_line(HText *text,uint split)

{
  HTStyleChange *pHVar1;
  char cVar2;
  ushort uVar3;
  short sVar4;
  short sVar5;
  short sVar6;
  HTStyle *pHVar7;
  wchar_t line_number;
  HTLine *__src;
  bool bVar8;
  short sVar9;
  short sVar10;
  FILE *pFVar11;
  char *pcVar12;
  wchar_t wVar13;
  wchar_t wVar14;
  HTLine *line_00;
  pool_data *ppVar15;
  wchar_t wVar16;
  uint uVar17;
  wchar_t wVar18;
  size_t sVar19;
  size_t __size;
  wchar_t *oldpos_00;
  wchar_t *newpos_00;
  int iVar20;
  int iVar21;
  wchar_t wVar22;
  HTCoord local_110;
  short local_106;
  int local_104;
  int local_100;
  int local_fc;
  int local_f0;
  int local_ec;
  int local_e8;
  char local_e1;
  uint i_2;
  char *p2_1;
  char *p2;
  wchar_t delta;
  wchar_t i_1;
  wchar_t *newpos;
  wchar_t *oldpos;
  wchar_t utf_extra;
  HTLine *jline;
  wchar_t r_;
  wchar_t d_;
  wchar_t total_cell_len;
  wchar_t total_byte_len;
  ht_run_info *r;
  char *jp;
  wchar_t end;
  wchar_t start;
  wchar_t n_1;
  wchar_t len;
  wchar_t moved;
  HTLine *temp;
  wchar_t n;
  HTStyleChange *at_end;
  HTStyleChange *scan;
  HTStyleChange *to;
  HTStyleChange *from;
  wchar_t i;
  uint plen;
  char *linedata;
  char *prevdata;
  HTLine *line;
  HTLine *previous;
  wchar_t ctrl_chars_on_previous_line;
  char *cp;
  char *p;
  wchar_t t_bold;
  wchar_t t_underline;
  wchar_t s_pre;
  wchar_t s_post;
  wchar_t s;
  wchar_t TailTrim;
  wchar_t SpecialAttrChars;
  wchar_t HeadTrim;
  wchar_t CurLine;
  TextAnchor *a;
  wchar_t new_offset;
  wchar_t indent;
  wchar_t spare;
  HTStyle *style;
  short alignment;
  char c;
  
  pHVar7 = text->style;
  if (text->in_line_1 == '\0') {
    local_110 = text->style->leftIndent;
  }
  else {
    local_110 = text->style->indent1st;
  }
  line_number = text->Lines;
  HeadTrim = L'\0';
  SpecialAttrChars = L'\0';
  t_underline = (wchar_t)underline_on;
  t_bold = (wchar_t)bold_on;
  ctrl_chars_on_previous_line = L'\0';
  __src = text->last_line;
  if (text->temp_line == (HTLineTemp *)__src) {
    line = (HTLine *)(text->temp_line + 1);
  }
  else {
    line = (HTLine *)text->temp_line;
  }
  if (line == (HTLine *)0x0) {
    return;
  }
  wVar22 = L'\x14';
  memset(line,0,0x14);
  ctrl_chars_on_this_line = L'\0';
  utfxtra_on_this_line = L'\0';
  text->LastChar = ' ';
  pcVar12 = __src->data;
  if ((*pcVar12 != '\x05') && (*pcVar12 != '\x03')) goto LAB_0806093a;
  cVar2 = __src->field_0x13;
  if (cVar2 != '\x05') {
    if (cVar2 == '\b') {
      __src->field_0x13 = *pcVar12;
      *pcVar12 = '\b';
      goto LAB_0806093a;
    }
    if (cVar2 != '\x03') goto LAB_0806093a;
  }
  if (*(char *)&__src[1].next == '\b') {
    *(undefined *)&__src[1].next = __src->field_0x13;
    __src->field_0x13 = *pcVar12;
    *pcVar12 = '\b';
  }
LAB_0806093a:
  if (__src->size < split) {
    if (WWW_TraceFlag != '\0') {
      uVar3 = __src->size;
      pFVar11 = TraceFP();
      wVar22 = split;
      fprintf((FILE *)pFVar11,"*** split_line: split==%u greater than last_line->size==%d !\n",split
              ,(uint)uVar3);
    }
    if (0x400 < split) {
      split = (uint)__src->size;
      pcVar12 = strrchr(__src->data,0x20);
      if ((pcVar12 != (char *)0x0) && (1 < (int)pcVar12 - (int)__src->data)) {
        split = (int)pcVar12 - (int)__src->data;
      }
      if (WWW_TraceFlag != '\0') {
        pFVar11 = TraceFP();
        wVar22 = split;
        fprintf((FILE *)pFVar11,"                split adjusted to %u.\n",split);
      }
    }
  }
  text->Lines = text->Lines + L'\x01';
  __src->next->prev = line;
  line->prev = __src;
  line->next = __src->next;
  __src->next = line;
  text->last_line = line;
  line->size = 0;
  line->offset = 0;
  text->permissible_split = 0;
  line->data[0] = '\0';
  sVar4 = pHVar7->alignment;
  if (split != 0) {
    if ((dump_output_immediately == '\0') || (use_underscore == '\0')) {
      t_underline = set_style_by_embedded_chars(__src->data,__src->data + split,'\x03','\x04');
    }
    wVar22 = L'\x05';
    t_bold = set_style_by_embedded_chars(__src->data,__src->data + split,'\x05','\x06');
  }
  if (((dump_output_immediately == '\0') || (use_underscore == '\0')) && (t_underline != L'\0')) {
    uVar3 = line->size;
    line->data[uVar3] = '\x03';
    line->size = uVar3 + 1;
    line->data[line->size] = '\0';
    ctrl_chars_on_this_line = ctrl_chars_on_this_line + L'\x01';
    SpecialAttrChars = L'\x01';
  }
  if (t_bold != L'\0') {
    uVar3 = line->size;
    line->data[uVar3] = '\x05';
    line->size = uVar3 + 1;
    line->data[line->size] = '\0';
    ctrl_chars_on_this_line = ctrl_chars_on_this_line + L'\x01';
    SpecialAttrChars = SpecialAttrChars + L'\x01';
  }
  if (split != 0) {
    __src->data[__src->size] = '\0';
    __src->size = (ushort)split;
    for (p = __src->data + split;
        (((*p == ' ' || (*p == '\x01')) &&
         ((((HeadTrim != L'\0' ||
            ((text->first_anchor != (TextAnchor *)0x0 || (underline_on != '\0')))) ||
           (bold_on != '\0')) ||
          ((((sVar4 != 1 || (pHVar7->wordWrap != '\0')) || (pHVar7->freeFormat != '\0')) ||
           ((pHVar7->spaceBefore != 0 || (pHVar7->spaceAfter != 0)))))))) || (*p == '\a'));
        p = p + 1) {
      HeadTrim = HeadTrim + L'\x01';
    }
    wVar13 = strlen(p);
    i = wVar13;
    if (wVar13 != L'\0') {
      while (wVar14 = i, i = wVar14 + L'\xffffffff', L'\xffffffff' < i) {
        if (((p[i] == '\x03') || (p[i] == '\x04')) ||
           ((p[i] == '\x05' || ((p[i] == '\x06' || (p[i] == '\a')))))) {
          ctrl_chars_on_this_line = ctrl_chars_on_this_line + L'\x01';
        }
        else if (((text->T).output_utf8 != '\0') && ((p[i] & 0xc0U) == 0x80)) {
          utfxtra_on_this_line = utfxtra_on_this_line + L'\x01';
        }
        if ((p[i] == '\a') && ((int)text->permissible_split < i)) {
          text->permissible_split = wVar14;
        }
      }
      ctrl_chars_on_this_line = ctrl_chars_on_this_line + utfxtra_on_this_line;
      strcat(line->data,p);
      line->size = line->size + (short)wVar13;
    }
  }
  p = __src->data + (__src->size - 1);
  while (((__src->data <= p && (((*p == ' ' || (*p == '\x01')) && (psrc_view == '\0')))) &&
         (((((ctrl_chars_on_this_line != L'\0' || (HeadTrim != L'\0')) ||
            (text->first_anchor != (TextAnchor *)0x0)) ||
           ((underline_on != '\0' || (bold_on != '\0')))) ||
          (((sVar4 != 1 ||
            (((pHVar7->wordWrap != '\0' || (pHVar7->freeFormat != '\0')) ||
             (pHVar7->spaceBefore != 0)))) || (pHVar7->spaceAfter != 0))))))) {
    p = p + -1;
  }
  iVar21 = (int)__src + ((__src->size + 0x11) - (int)p);
  __src->size = __src->size - (short)iVar21;
  p[1] = '\0';
  if (split == 0) {
    s = (uint)__src->size + iVar21;
  }
  else {
    s = split;
  }
  wVar13 = s + HeadTrim;
  wVar14 = s - iVar21;
  if (WWW_TraceFlag != '\0') {
    pFVar11 = TraceFP();
    fprintf((FILE *)pFVar11,"GridText: split_line(%u [now:%d]) called\n",split,s);
    wVar22 = split;
  }
  if ((HTStyleChange (*) [64])__src->styles == stylechanges_buffers) {
    line->styles = (HTStyleChange *)stylechanges_buffers[1];
  }
  else {
    line->styles = (HTStyleChange *)stylechanges_buffers;
  }
  line->numstyles = 0;
  from = __src->styles + -(1 - (uint)__src->numstyles);
  to = line->styles + 0x3f;
  do {
    local_106 = (short)SpecialAttrChars;
    sVar9 = (short)wVar13;
    if ((from < __src->styles) || (to < line->styles)) break;
    *to = *from;
    if (wVar13 < (int)(uint)(*(ushort *)to >> 2)) {
      *(ushort *)to = *(ushort *)to & 3 | ((*(ushort *)to >> 2) + (local_106 - sVar9)) * 4;
    }
    else {
      if (((int)(uint)(*(ushort *)to >> 2) <= wVar14) ||
         (((*(byte *)to & 3) != 1 && ((*(byte *)to & 3) != 2)))) break;
      if ((int)(uint)(*(ushort *)to >> 2) < s) {
        local_106 = 0;
      }
      *(ushort *)to = *(ushort *)to & 3 | local_106 << 2;
    }
    to = to + -1;
    from = from + -1;
  } while( true );
  scan = from;
  at_end = from;
LAB_0806123f:
  sVar10 = (short)wVar14;
  if ((scan < __src->styles) || (at_end < __src->styles)) goto LAB_08061259;
  if ((*(byte *)scan & 3) == 0) {
    wVar22 = wVar14;
    scan = skip_matched_and_correct_offsets(scan,__src->styles,wVar14);
    if (scan == (HTStyleChange *)0x0) {
      if (WWW_TraceFlag != '\0') {
        pFVar11 = TraceFP();
        fprintf((FILE *)pFVar11,"BUG: styles improperly nested.\n");
      }
      goto LAB_08061259;
    }
  }
  else if ((*(byte *)scan & 3) == 1) {
    if ((((*(byte *)at_end & 3) == 1) &&
        (*(short *)&at_end->field_0x2 == *(short *)&scan->field_0x2)) &&
       (wVar14 <= (int)(uint)(*(ushort *)at_end >> 2))) {
      at_end = at_end + -1;
    }
    else {
      if (__src->styles + 0x3f <= at_end) {
        if (WWW_TraceFlag != '\0') {
          pFVar11 = TraceFP();
          fprintf((FILE *)pFVar11,"BUG: style overflow before split_line.\n",wVar22);
        }
LAB_08061259:
        line->numstyles = (ushort)((int)line->styles + (0xfc - (int)to) >> 2);
        if ((line->numstyles == 0) || (0x3f < line->numstyles)) {
          if (line->numstyles == 0) {
            *(ushort *)line->styles = *(ushort *)line->styles | 0xfffc;
          }
        }
        else {
          for (n = L'\0'; n < (int)(uint)line->numstyles; n = n + L'\x01') {
            line->styles[n] = to[n + L'\x01'];
          }
        }
        __src->numstyles = (short)((int)at_end - (int)__src->styles >> 2) + 1;
        if (__src->numstyles == 0) {
          *(ushort *)__src->styles = *(ushort *)__src->styles | 0xfffc;
        }
        line_00 = (HTLine *)ALLOC_IN_POOL(&HTMainText->pool,__src->size + 0x14);
        if (line_00 == (HTLine *)0x0) {
          outofmem("./GridText.c","split_line_2");
        }
        memcpy(line_00,__src,__src->size + 0x14);
        ppVar15 = ALLOC_IN_POOL(&HTMainText->pool,(uint)__src->numstyles * 4);
        line_00->styles = ppVar15;
        if (line_00->styles == (HTStyleChange *)0x0) {
          outofmem("./GridText.c","split_line_2");
        }
        wVar22 = (uint)__src->numstyles * 4;
        memcpy(line_00->styles,__src->styles,wVar22);
        line_00->prev->next = line_00;
        line_00->next->prev = line_00;
        line_00->data[line_00->size] = '\0';
        spare = L'\0';
        if ((((this_line_was_split != '\0') || (sVar4 == 3)) || (sVar4 == 2)) ||
           (text->stbl != (STable_info *)0x0)) {
          for (cp = line_00->data; *cp != '\0'; cp = cp + 1) {
            if (((*cp == '\x03') || (*cp == '\x04')) ||
               ((*cp == '\x05' || ((*cp == '\x06' || (*cp == '\a')))))) {
              ctrl_chars_on_previous_line = ctrl_chars_on_previous_line + L'\x01';
            }
          }
          if ((line_00->size != 0) && (line_00->data[line_00->size - 1] == '\a')) {
            ctrl_chars_on_previous_line = ctrl_chars_on_previous_line + L'\xffffffff';
          }
          if (text->stbl == (STable_info *)0x0) {
            local_104 = LYcols - (uint)(LYShowScrollbar != '\0');
          }
          else {
            if (LYtableCols < L'\x01') {
              if (LYwideLines == L'\0') {
                local_fc = LYcols;
              }
              else {
                local_fc = 0x3f6;
              }
              local_100 = local_fc;
            }
            else {
              local_100 = (LYtableCols * LYcols) / 0xc;
            }
            local_104 = local_100 - (uint)(LYShowScrollbar != '\0');
          }
          iVar20 = pHVar7->rightIndent;
          wVar16 = LYstrExtent2(line_00->data,(uint)line_00->size);
          spare = ((local_104 - iVar20) - local_110) - wVar16;
          if ((spare < L'\0') && (LYwideLines != L'\0')) {
            spare = L'\0';
          }
        }
        uVar17 = (uint)line_00->offset;
        if (pHVar7->alignment == 2) {
          new_offset = uVar17 + local_110 + spare;
        }
        else if (pHVar7->alignment == 3) {
          new_offset = uVar17 + spare / 2 + local_110;
        }
        else {
          new_offset = uVar17 + local_110;
        }
        line_00->offset = ~(ushort)(new_offset >> 0x1f) & (ushort)new_offset;
        if (text->stbl != (STable_info *)0x0) {
          wVar22 = text->Lines + L'\xffffffff';
          Stbl_finishCellInTable
                    (text->stbl,0,wVar22,(uint)line_00->offset,
                     (uint)line_00->size - ctrl_chars_on_previous_line);
        }
        text->in_line_1 = '\0';
        if (L'\0' < s) {
          bVar8 = false;
          a = text->last_anchor_before_split;
          if (a == (TextAnchor *)0x0) {
            a = text->first_anchor;
          }
          for (; a != (TextAnchor *)0x0; a = a->next) {
            if (a->line_num == line_number) {
              len._0_2_ = a->extent;
              wVar16 = a->number;
              sVar4 = a->line_pos;
              start = (wchar_t)sVar4;
              wVar18 = start + (short)len;
              text->last_anchor_before_split = a;
              if (start < wVar14) {
                if (wVar14 < wVar18) {
                  if (WWW_TraceFlag != '\0') {
                    pFVar11 = TraceFP();
                    fprintf((FILE *)pFVar11,"anchor %d: no relocation",wVar16);
                    wVar22 = wVar16;
                  }
                  if (wVar13 < wVar18) {
                    if (WWW_TraceFlag != '\0') {
                      pFVar11 = TraceFP();
                      fprintf((FILE *)pFVar11," of the start.\n",wVar22);
                    }
                    a->extent = a->extent + (local_106 - ((short)iVar21 + (short)HeadTrim));
                  }
                  else {
                    if (WWW_TraceFlag != '\0') {
                      pFVar11 = TraceFP();
                      fprintf((FILE *)pFVar11,", cut the end.\n",wVar22);
                    }
                    a->extent = sVar10 - sVar4;
                  }
                }
              }
              else if (((s <= start) || ((short)len != 0)) ||
                      ((wVar16 != L'\0' && ((a->show_anchor == '\0' || (bVar8)))))) {
                bVar8 = true;
                a->line_num = a->line_num + L'\x01';
                if (WWW_TraceFlag != '\0') {
                  sVar5 = a->extent;
                  sVar6 = a->line_pos;
                  wVar22 = a->line_num;
                  pFVar11 = TraceFP();
                  fprintf((FILE *)pFVar11,
                          "anchor %d: (T,H,S)=(%d,%d,%d); (line,pos,ext):(%d,%d,%d), ",wVar16,iVar21
                          ,HeadTrim,SpecialAttrChars,wVar22,(int)sVar6,(int)sVar5);
                  wVar22 = wVar16;
                }
                if (wVar18 < wVar13) {
                  if (WWW_TraceFlag != '\0') {
                    wVar22 = wVar13 - wVar18;
                    pFVar11 = TraceFP();
                    fprintf((FILE *)pFVar11,"Move end +%d, ",wVar22);
                  }
                  len._0_2_ = (short)len + (sVar9 - (short)wVar18);
                }
                if (start < wVar13) {
                  if (WWW_TraceFlag != '\0') {
                    wVar22 = wVar13 - start;
                    pFVar11 = TraceFP();
                    fprintf((FILE *)pFVar11,"Move start +%d, ",wVar22);
                  }
                  len._0_2_ = (short)len + (sVar4 - sVar9);
                  start = wVar13;
                }
                a->line_pos = ((short)start - sVar9) + local_106;
                a->extent = (short)len;
                if (WWW_TraceFlag != '\0') {
                  sVar4 = a->extent;
                  sVar5 = a->line_pos;
                  wVar22 = a->line_num;
                  pFVar11 = TraceFP();
                  fprintf((FILE *)pFVar11,"->(%d,%d,%d)\n",wVar22,(int)sVar5,(int)sVar4);
                }
              }
              else {
                if (WWW_TraceFlag != '\0') {
                  pFVar11 = TraceFP();
                  fprintf((FILE *)pFVar11,"anchor %d: no relocation, empty-finished",wVar16);
                  wVar22 = wVar16;
                }
                a->line_pos = sVar10;
              }
            }
            else if (line_number < a->line_num) break;
          }
        }
        if ((((this_line_was_split != '\0') && (L'\0' < spare)) &&
            (text->stbl == (STable_info *)0x0)) &&
           ((0 < justify_max_void_percent && (justify_max_void_percent < 0x65)))) {
          if (text->stbl == (STable_info *)0x0) {
            local_f0 = LYcols - (uint)(LYShowScrollbar != '\0');
          }
          else {
            if (LYtableCols < L'\x01') {
              if (LYwideLines == L'\0') {
                local_e8 = LYcols;
              }
              else {
                local_e8 = 0x3f6;
              }
              local_ec = local_e8;
            }
            else {
              local_ec = (LYtableCols * LYcols) / 0xc;
            }
            local_f0 = local_ec - (uint)(LYShowScrollbar != '\0');
          }
          if ((spare * 100) /
              (((local_f0 - pHVar7->rightIndent) - local_110) + ctrl_chars_on_previous_line) <=
              justify_max_void_percent) {
            r = ht_runs;
            ht_num_runs = L'\0';
            ht_runs[0].cell_len = L'\0';
            ht_runs[0].byte_len = L'\0';
            for (jp = line_00->data + justify_start_position; cVar2 = *jp, cVar2 != '\0';
                jp = jp + 1) {
              if (cVar2 == ' ') {
                ht_num_runs = ht_num_runs + L'\x01';
                r[1].cell_len = L'\0';
                r[1].byte_len = r[1].cell_len;
                r = r + 1;
              }
              else {
                r->byte_len = r->byte_len + L'\x01';
                if ((cVar2 < '\x03') || ('\b' < cVar2)) {
                  r->cell_len = r->cell_len + L'\x01';
                  if (cVar2 == '\x01') {
                    *jp = ' ';
                  }
                  else if (((text->T).output_utf8 != '\0') && (cVar2 < '\0')) {
                    sVar19 = utf8_length((text->T).output_utf8,jp);
                    r->byte_len = r->byte_len + sVar19;
                    jp = jp + sVar19;
                  }
                }
              }
            }
            wVar22 = ht_num_runs + L'\x01';
            previous = line_00;
            if (wVar22 != L'\x01') {
              __size = ht_num_runs * 8;
              ht_num_runs = wVar22;
              oldpos_00 = (wchar_t *)malloc(__size);
              newpos_00 = oldpos_00 + -(1 - ht_num_runs);
              i_1 = L'\x01';
              if (oldpos_00 == (wchar_t *)0x0) {
                outofmem("./GridText.c","split_line_3");
              }
              iVar21 = spare / (ht_num_runs + L'\xffffffff');
              r_ = spare % (ht_num_runs + L'\xffffffff');
              *oldpos_00 = ht_runs[0].cell_len + justify_start_position + L'\x01';
              *newpos_00 = *oldpos_00 + (uint)(L'\0' < r_) + iVar21;
              for (; r_ = r_ + L'\xffffffff', i_1 < ht_num_runs + L'\xffffffff'; i_1 = i_1 + L'\x01'
                  ) {
                iVar20 = ht_runs[i_1].cell_len + L'\x01';
                oldpos_00[i_1] = oldpos_00[-(1 - i_1)] + iVar20;
                newpos_00[i_1] = newpos_00[-(1 - i_1)] + iVar20 + (uint)(L'\0' < r_) + iVar21;
              }
              previous = insert_blanks_in_line
                                   (line_00,line_number,text,&last_anchor_of_previous_line,
                                    ht_num_runs + L'\xffffffff',oldpos_00,newpos_00);
              free(oldpos_00);
              if (previous == (HTLine *)0x0) {
                outofmem("./GridText.c","split_line_4");
              }
              line_00->next->prev = previous;
              line_00->prev->next = previous;
              wVar22 = ht_num_runs;
            }
            ht_num_runs = wVar22;
            if (justify_start_position == L'\0') {
              have_raw_nbsps = '\0';
              justify_start_position = L'\0';
              this_line_was_split = '\0';
              can_justify_this_line = '\x01';
              return;
            }
            for (p2 = previous->data; p2 < previous->data + justify_start_position; p2 = p2 + 1) {
              if (*p2 == '\x01') {
                local_e1 = ' ';
              }
              else {
                local_e1 = *p2;
              }
              *p2 = local_e1;
            }
            have_raw_nbsps = '\0';
            justify_start_position = L'\0';
            this_line_was_split = '\0';
            can_justify_this_line = '\x01';
            return;
          }
        }
        if ((((wait_for_this_stacked_elt < L'\0') &&
             (((text->style->alignment == 1 || (text->style->alignment == 0)) && (HTCJK == NOCJK))))
            && (((in_DT == '\0' && (can_justify_here != '\0')) && (can_justify_this_line != '\0'))))
           && (form_in_htext == '\0')) {
          if (((line->size != 0) && (text->stbl == (STable_info *)0x0)) && (WWW_TraceFlag != '\0'))
          {
            uVar3 = line->size;
            pFVar11 = TraceFP();
            fprintf((FILE *)pFVar11,
                    "BUG: justification: shouldn\'t happen - new line is not empty!\n\t\'%.*s\'\n",
                    (uint)uVar3,line->data);
          }
          for (p2_1 = line_00->data; *p2_1 != '\0'; p2_1 = p2_1 + 1) {
            if (*p2_1 == '\x01') {
              *p2_1 = ' ';
            }
          }
        }
        else if (have_raw_nbsps != '\0') {
          for (i_2 = 0; i_2 < line_00->size; i_2 = i_2 + 1) {
            if (line_00->data[i_2] == '\x01') {
              line_00->data[i_2] = ' ';
            }
          }
          for (i_2 = 0; i_2 < line->size; i_2 = i_2 + 1) {
            if (line->data[i_2] == '\x01') {
              line->data[i_2] = ' ';
            }
          }
        }
        can_justify_this_line = '\x01';
        this_line_was_split = '\0';
        justify_start_position = L'\0';
        have_raw_nbsps = '\0';
        return;
      }
      pHVar1 = at_end + 1;
      *(byte *)pHVar1 = *(byte *)pHVar1 & 0xfc;
      *(undefined2 *)&at_end[1].field_0x2 = *(undefined2 *)&scan->field_0x2;
      *(ushort *)pHVar1 = *(ushort *)pHVar1 & 3 | sVar10 * 4;
      at_end = pHVar1;
    }
    if (((to < line->styles + 0x3f) && ((*(byte *)(to + 1) & 3) == 0)) &&
       (((uint)(*(ushort *)(to + 1) >> 2) <= (uint)SpecialAttrChars &&
        (*(short *)&to[1].field_0x2 == *(short *)&scan->field_0x2)))) {
      to = to + 1;
    }
    else {
      if (to < line->styles) {
        if (WWW_TraceFlag != '\0') {
          pFVar11 = TraceFP();
          fprintf((FILE *)pFVar11,"BUG: style overflow after split_line.\n",wVar22);
        }
        goto LAB_08061259;
      }
      *to = *scan;
      *(ushort *)to = *(ushort *)to & 3 | local_106 * 4;
      to = to + -1;
    }
  }
  if (wVar14 < (int)(uint)(*(ushort *)scan >> 2)) {
    *(ushort *)scan = *(ushort *)scan & 3 | sVar10 * 4;
  }
  scan = scan + -1;
  goto LAB_0806123f;
}



// WARNING: Unknown calling convention

void blank_lines(HText *text,wchar_t newlines)

{
  BOOLEAN BVar1;
  bool bVar2;
  HTLine *line;
  BOOLEAN first;
  
  BVar1 = HText_LastLineEmpty(text,'\0');
  if (BVar1 == '\0') {
    newlines = newlines + L'\x01';
  }
  else {
    line = text->last_line->prev;
    bVar2 = text->last_line == line;
    if ((no_title != '\0') && (bVar2)) {
      return;
    }
    if ((bVar2) && (newlines == L'\x01')) {
      return;
    }
    for (; (((line != (HTLine *)0x0 && (text->last_line != line)) &&
            (BVar1 = HText_TrueEmptyLine(line,text,'\0'), BVar1 != '\0')) && (newlines != L'\0'));
        newlines = newlines + L'\xffffffff') {
      line = line->prev;
    }
  }
  for (; newlines != L'\0'; newlines = newlines + L'\xffffffff') {
    split_line(text,0);
  }
  text->in_line_1 = '\x01';
  return;
}



// WARNING: Unknown calling convention

void HText_appendParagraph(HText *text)

{
  wchar_t wVar1;
  wchar_t local_18;
  wchar_t before;
  wchar_t after;
  
  wVar1 = text->style->spaceAfter;
  local_18 = text->style->spaceBefore;
  if (local_18 < wVar1) {
    local_18 = wVar1;
  }
  blank_lines(text,local_18);
  return;
}



// WARNING: Unknown calling convention

void HText_setStyle(HText *text,HTStyle *style)

{
  wchar_t wVar1;
  char *pcVar2;
  FILE *__stream;
  wchar_t local_1c;
  wchar_t before;
  wchar_t after;
  
  if (style != (HTStyle *)0x0) {
    wVar1 = text->style->spaceAfter;
    local_1c = style->spaceBefore;
    if (WWW_TraceFlag != '\0') {
      pcVar2 = style->name;
      __stream = TraceFP();
      fprintf((FILE *)__stream,"GridText: Change to style %s\n",pcVar2);
    }
    if (local_1c < wVar1) {
      local_1c = wVar1;
    }
    blank_lines(text,local_1c);
    text->style = style;
  }
  return;
}



// WARNING: Unknown calling convention

void HText_appendCharacter(HText *text,wchar_t ch)

{
  ushort uVar1;
  eDetectedKCode eVar2;
  eEUC_status eVar3;
  HTStyle *pHVar4;
  wchar_t wVar5;
  eGridState eVar6;
  uint uVar7;
  HTLine *pHVar8;
  byte bVar9;
  char *str;
  FILE *pFVar10;
  ushort **ppuVar11;
  int iVar12;
  uchar *unaff_EBX;
  uchar *unaff_ESI;
  HTCoord local_180;
  int local_174;
  int local_16c;
  int local_168;
  int local_164;
  int local_160;
  int local_15c;
  int local_158;
  wchar_t local_154;
  int local_150;
  int local_14c;
  wchar_t local_148;
  int local_144;
  int local_140;
  int local_13c;
  int local_138;
  int local_134;
  int local_12c;
  int local_128;
  int local_124;
  int local_120;
  int local_11c;
  int local_118;
  int local_114;
  int local_10c;
  int local_108;
  int local_104;
  wchar_t local_100;
  int local_fc;
  int local_f8;
  int local_f4;
  int local_f0;
  int local_ec;
  int local_e8;
  int local_e4;
  int local_e0;
  int local_dc;
  int local_d8;
  int local_d0;
  int local_c8;
  int local_c0;
  int local_bc;
  int local_b8;
  int local_b0;
  int local_ac;
  int local_a8;
  int local_a4;
  int local_a0;
  int local_9c;
  int local_94;
  int local_90;
  int local_8c;
  byte local_79;
  byte local_78;
  byte local_77;
  byte local_6e;
  byte local_6d;
  HTFont font;
  wchar_t number;
  wchar_t nominal;
  eGridState saved_state;
  wchar_t saved_kanji_buf;
  wchar_t target_cu_1;
  wchar_t target_1;
  wchar_t here_cu;
  wchar_t here;
  wchar_t target_cu;
  wchar_t target;
  HTTabStop *Tab;
  wchar_t i;
  eDetectedKCode save_d_kcode;
  wchar_t actual;
  wchar_t limit;
  wchar_t indent;
  HTStyle *style;
  HTLine *line;
  uchar tmp [2];
  uchar c_1;
  uchar kb;
  uchar c;
  
  if (text == (HText *)0x0) {
    return;
  }
  if (L'\x01' < text->halted) {
    if (text->halted == L'\x02') {
      text->halted = L'\0';
      text->kanji_buf = L'\0';
      str = (char *)gettext(" *** MEMORY EXHAUSTED ***");
      HText_appendText(text,str);
    }
    text->halted = L'\x03';
    return;
  }
  bVar9 = (byte)ch;
  if ((((HTCJK == JAPANESE) && (text->detected_kcode != DET_MIXED)) &&
      (text->specified_kcode != SJIS)) && (text->specified_kcode != EUC)) {
    eVar2 = text->detected_kcode;
    if (text->SJIS_status == SJIS_state_in_kanji) {
      if (((bVar9 < 0x40) || (bVar9 == 0x7f)) || (0xfc < bVar9)) {
        text->SJIS_status = SJIS_state_has_bad_code;
        if (text->EUC_status == EUC_state_has_bad_code) {
          text->detected_kcode = DET_MIXED;
        }
        else {
          text->detected_kcode = DET_EUC;
        }
      }
      else {
        text->SJIS_status = SJIS_state_neutral;
      }
    }
    else if (text->SJIS_status == SJIS_state_neutral) {
      if (((bVar9 < 0x81) || (0x9f < bVar9)) && ((bVar9 < 0xe0 || (0xef < bVar9)))) {
        if (((char)bVar9 < '\0') && ((bVar9 < 0xa1 || (0xdf < bVar9)))) {
          text->SJIS_status = SJIS_state_has_bad_code;
          if (text->EUC_status == EUC_state_has_bad_code) {
            text->detected_kcode = DET_MIXED;
          }
          else {
            text->detected_kcode = DET_EUC;
          }
        }
      }
      else {
        text->SJIS_status = SJIS_state_in_kanji;
      }
    }
    eVar3 = text->EUC_status;
    if (eVar3 == EUC_state_in_kanji) {
      if ((bVar9 < 0xa1) || (bVar9 == 0xff)) {
        text->EUC_status = EUC_state_has_bad_code;
        if (text->SJIS_status == SJIS_state_has_bad_code) {
          text->detected_kcode = DET_MIXED;
        }
        else {
          text->detected_kcode = DET_SJIS;
        }
      }
      else {
        text->EUC_status = EUC_state_neutral;
      }
    }
    else if (eVar3 == EUC_state_neutral) {
      if ((bVar9 < 0xa1) || (bVar9 == 0xff)) {
        if (bVar9 == 0x8e) {
          text->EUC_status = EUC_state_in_kana;
        }
        else if ((char)bVar9 < '\0') {
          text->EUC_status = EUC_state_has_bad_code;
          if (text->SJIS_status == SJIS_state_has_bad_code) {
            text->detected_kcode = DET_MIXED;
          }
          else {
            text->detected_kcode = DET_SJIS;
          }
        }
      }
      else {
        text->EUC_status = EUC_state_in_kanji;
      }
    }
    else if (eVar3 == EUC_state_in_kana) {
      if ((bVar9 < 0xa1) || (0xdf < bVar9)) {
        text->EUC_status = EUC_state_has_bad_code;
        if (text->SJIS_status == SJIS_state_has_bad_code) {
          text->detected_kcode = DET_MIXED;
        }
        else {
          text->detected_kcode = DET_SJIS;
        }
      }
      else {
        text->EUC_status = EUC_state_neutral;
      }
    }
    c = bVar9;
    if (text->detected_kcode != eVar2) {
      eVar2 = text->detected_kcode;
      if (eVar2 == DET_EUC) {
        if (WWW_TraceFlag != '\0') {
          pFVar10 = TraceFP();
          fprintf((FILE *)pFVar10,"TH_JP_AUTO_DETECT: This document\'s kcode seems EUC.\n");
        }
      }
      else if (eVar2 == DET_SJIS) {
        if (WWW_TraceFlag != '\0') {
          pFVar10 = TraceFP();
          fprintf((FILE *)pFVar10,"TH_JP_AUTO_DETECT: This document\'s kcode seems SJIS.\n");
        }
      }
      else if (eVar2 == DET_MIXED) {
        if (WWW_TraceFlag != '\0') {
          pFVar10 = TraceFP();
          fprintf((FILE *)pFVar10,"TH_JP_AUTO_DETECT: This document\'s kcode seems mixed!\n");
        }
      }
      else if (WWW_TraceFlag != '\0') {
        pFVar10 = TraceFP();
        fprintf((FILE *)pFVar10,"TH_JP_AUTO_DETECT: This document\'s kcode is unexpected!\n");
      }
    }
  }
  if ((ch == L'\x1b') && (HTCJK == NOCJK)) {
    return;
  }
  if (((((char)bVar9 < '\0') && (HTCJK == NOCJK)) && ((text->T).transp == '\0')) &&
     (((text->T).output_utf8 == '\0' && ((ch & 0xffU) < LYlowest_eightbit[current_char_set])))) {
    return;
  }
  if (((bVar9 == 0x9b) && (HTCJK == NOCJK)) &&
     ((HTPassHighCtrlRaw == '\0' &&
      ((((text->T).transp == '\0' && ((text->T).output_utf8 == '\0')) &&
       (0x9b < LYlowest_eightbit[current_char_set])))))) {
    return;
  }
  line = text->last_line;
  pHVar4 = text->style;
  if (text->in_line_1 == '\0') {
    local_180 = pHVar4->leftIndent;
  }
  else {
    local_180 = pHVar4->indent1st;
  }
  if (HTCJK == NOCJK) {
    if (ch == L'\x1b') {
      return;
    }
LAB_08062c21:
    if ((HTCJK != NOCJK) &&
       (((ch == L'\x05' || (ch == L'\x06')) &&
        (text->permissible_split = (uint)line->size, HTCJK == JAPANESE)))) {
      text->kcode = NOKANJI;
    }
    if (((ch < L'\x03') || (L'\b' < ch)) || (ch == L'\b')) {
      if (ch == L'\b') {
        uVar1 = line->size;
        line->data[uVar1] = '\b';
        line->size = uVar1 + 1;
        line->data[line->size] = '\0';
        return;
      }
    }
    else {
      if (0x3fe < line->size) {
        return;
      }
      if (with_backspaces == '\0') {
        return;
      }
      if (HTCJK != NOCJK) {
        return;
      }
      if ((text->T).output_utf8 != '\0') {
        return;
      }
      if (ch == L'\x03') {
        uVar1 = line->size;
        line->data[uVar1] = '\x03';
        line->size = uVar1 + 1;
        line->data[line->size] = '\0';
        if ((dump_output_immediately != '\0') && (use_underscore != '\0')) {
          underline_on = '\x01';
          return;
        }
        underline_on = '\x01';
        ctrl_chars_on_this_line = ctrl_chars_on_this_line + L'\x01';
        return;
      }
      if (ch == L'\x04') {
        uVar1 = line->size;
        line->data[uVar1] = '\x04';
        line->size = uVar1 + 1;
        line->data[line->size] = '\0';
        if ((dump_output_immediately != '\0') && (use_underscore != '\0')) {
          underline_on = '\0';
          return;
        }
        underline_on = '\0';
        ctrl_chars_on_this_line = ctrl_chars_on_this_line + L'\x01';
        return;
      }
      if (ch == L'\x05') {
        uVar1 = line->size;
        line->data[uVar1] = '\x05';
        line->size = uVar1 + 1;
        line->data[line->size] = '\0';
        bold_on = '\x01';
        ctrl_chars_on_this_line = ctrl_chars_on_this_line + L'\x01';
        return;
      }
      if (ch == L'\x06') {
        uVar1 = line->size;
        line->data[uVar1] = '\x06';
        line->size = uVar1 + 1;
        line->data[line->size] = '\0';
        bold_on = '\0';
        ctrl_chars_on_this_line = ctrl_chars_on_this_line + L'\x01';
        return;
      }
      if (ch == L'\a') {
        if (line->size == 0) {
          return;
        }
        if ((uint)line->size <= text->permissible_split) {
          return;
        }
        i = text->permissible_split;
        do {
          wVar5 = i;
          i = wVar5 + L'\x01';
          if (line->data[wVar5 + L'\x01'] == '\0') break;
        } while (((((2 < (byte)line->data[wVar5 + L'\x01']) &&
                   ((byte)line->data[wVar5 + L'\x01'] < 9)) ||
                  (ppuVar11 = __ctype_b_loc(),
                  ((*ppuVar11)[(byte)line->data[wVar5 + L'\x01']] & 0x2000) != 0)) ||
                 ((line->data[wVar5 + L'\x01'] == '-' || (line->data[wVar5 + L'\x01'] == '\x01'))))
                || (line->data[wVar5 + L'\x01'] == '\x02'));
        if (line->data[wVar5 + L'\x01'] == '\0') {
          return;
        }
      }
    }
    if ((text->T).output_utf8 != '\0') {
      if (((text->T).output_utf8 != '\0') && ((ch & 0xc0U) == 0x80)) {
        if (line->size < 0x400) {
          if ((line->size == 0) || (line->data[line->size - 1] != '\a')) {
            local_174 = 0;
          }
          else {
            local_174 = 1;
          }
          if (text->stbl == (STable_info *)0x0) {
            local_16c = LYcols - (uint)(LYShowScrollbar != '\0');
          }
          else {
            if (LYtableCols < L'\x01') {
              if (LYwideLines == L'\0') {
                local_164 = LYcols;
              }
              else {
                local_164 = 0x3f6;
              }
              local_168 = local_164;
            }
            else {
              local_168 = (LYtableCols * LYcols) / 0xc;
            }
            local_16c = local_168 - (uint)(LYShowScrollbar != '\0');
          }
          if ((((uint)line->offset + (uint)line->size + local_180) - ctrl_chars_on_this_line) +
              local_174 < local_16c) goto LAB_0806320c;
        }
        if ((text->permissible_split == 0) || (text->source != '\0')) {
          text->permissible_split = (uint)line->size;
          while (((text->permissible_split != 0 && ((text->T).output_utf8 != '\0')) &&
                 ((line->data[text->permissible_split - 1] & 0xc0U) == 0x80))) {
            text->permissible_split = text->permissible_split - 1;
          }
          if ((text->permissible_split != 0) && (line->data[text->permissible_split - 1] < '\0')) {
            text->permissible_split = text->permissible_split - 1;
          }
          if (text->permissible_split == (uint)line->size) {
            text->permissible_split = 0;
          }
        }
        split_line(text,text->permissible_split);
        line = text->last_line;
        if ((text->source != '\0') && ((uint)line->size == ctrl_chars_on_this_line)) {
          HText_appendCharacter(text,L'\b');
        }
LAB_0806320c:
        uVar1 = line->size;
        line->data[uVar1] = (char)ch;
        line->size = uVar1 + 1;
        line->data[line->size] = '\0';
        ctrl_chars_on_this_line = ctrl_chars_on_this_line + L'\x01';
        utfxtra_on_this_line = utfxtra_on_this_line + L'\x01';
        return;
      }
      if (((ch & 0x80U) != 0) && (0x3f9 < line->size)) {
        if (((text->permissible_split == 0) || (text->source != '\0')) &&
           (text->permissible_split = (uint)line->size, text->permissible_split == (uint)line->size)
           ) {
          text->permissible_split = 0;
        }
        split_line(text,text->permissible_split);
        line = text->last_line;
        if ((text->source != '\0') && ((uint)line->size == ctrl_chars_on_this_line)) {
          HText_appendCharacter(text,L'\b');
        }
      }
    }
    if (ch == L'\n') {
      split_line(text,0);
      text->in_line_1 = '\x01';
      if (HTCJK != JAPANESE) {
        return;
      }
      text->kcode = NOKANJI;
      return;
    }
    if (ch == L'\x02') {
      ch = L' ';
    }
    if (ch == L'\r') {
      split_line(text,0);
      text->in_line_1 = '\0';
      if (HTCJK != JAPANESE) {
        return;
      }
      text->kcode = NOKANJI;
      return;
    }
    if (ch == L'\t') {
      if ((line->size != 0) && (line->data[line->size - 1] == '\a')) {
        line->size = line->size - 1;
        line->data[line->size] = '\0';
        ctrl_chars_on_this_line = ctrl_chars_on_this_line + L'\xffffffff';
      }
      here = ((uint)line->size + (uint)line->offset + local_180) - ctrl_chars_on_this_line;
      if (pHVar4->tabs == (HTTabStop *)0x0) {
        if (text->in_line_1 == '\0') {
          split_line(text,0);
          return;
        }
        if (pHVar4->leftIndent <= here) {
          split_line(text,0);
          return;
        }
        target = pHVar4->leftIndent;
      }
      else {
        for (Tab = pHVar4->tabs; Tab->position <= here; Tab = Tab + 1) {
          if (Tab->position == 0) {
            split_line(text,0);
            return;
          }
        }
        target = Tab->position;
      }
      if (text->stbl == (STable_info *)0x0) {
        local_160 = LYcols - (uint)(LYShowScrollbar != '\0');
      }
      else {
        if (LYtableCols < L'\x01') {
          if (LYwideLines == L'\0') {
            local_158 = LYcols;
          }
          else {
            local_158 = 0x3f6;
          }
          local_15c = local_158;
        }
        else {
          local_15c = (LYtableCols * LYcols) / 0xc;
        }
        local_160 = local_15c - (uint)(LYShowScrollbar != '\0');
      }
      if ((local_160 - pHVar4->rightIndent < target) && (HTOutputFormat != WWW_SOURCE)) {
        split_line(text,0);
        return;
      }
      text->permissible_split = (uint)line->size;
      if (text->stbl == (STable_info *)0x0) {
        local_154 = LYcols - (uint)(LYShowScrollbar != '\0');
      }
      else {
        if (LYtableCols < L'\x01') {
          if (LYwideLines == L'\0') {
            local_14c = LYcols;
          }
          else {
            local_14c = 0x3f6;
          }
          local_150 = local_14c;
        }
        else {
          local_150 = (LYtableCols * LYcols) / 0xc;
        }
        local_154 = local_150 - (uint)(LYShowScrollbar != '\0');
      }
      if (local_154 < target) {
        if (text->stbl == (STable_info *)0x0) {
          local_148 = LYcols - (uint)(LYShowScrollbar != '\0');
        }
        else {
          if (LYtableCols < L'\x01') {
            if (LYwideLines == L'\0') {
              local_140 = LYcols;
            }
            else {
              local_140 = 0x3f6;
            }
            local_144 = local_140;
          }
          else {
            local_144 = (LYtableCols * LYcols) / 0xc;
          }
          local_148 = local_144 - (uint)(LYShowScrollbar != '\0');
        }
        target = local_148;
      }
      if (line->size == 0) {
        line->offset = line->offset + ((short)target - (short)here);
        return;
      }
      for (; here < target; here = here + L'\x01') {
        uVar1 = line->size;
        line->data[uVar1] = ' ';
        line->size = uVar1 + 1;
        line->data[line->size] = '\0';
      }
      return;
    }
  }
  else {
    switch(text->state) {
    case S_text:
      if (ch == L'\x1b') {
        text->state = S_esc;
        text->kanji_buf = L'\0';
        return;
      }
      break;
    case S_esc:
      if (ch == L'$') {
        text->state = S_dollar;
        return;
      }
      if (ch == L'(') {
        text->state = S_paren;
        return;
      }
      text->state = S_text;
    case S_dollar:
      if (((ch == L'@') || (ch == L'B')) || (ch == L'A')) {
        text->state = S_nonascii_text;
        if ((ch != L'@') && (ch != L'B')) {
          return;
        }
        text->kcode = JIS;
        return;
      }
      if (ch == L'(') {
        text->state = S_dollar_paren;
        return;
      }
      text->state = S_text;
      break;
    case S_paren:
      if (((ch == L'B') || (ch == L'J')) || (ch == L'T')) {
        text->permissible_split = (uint)text->last_line->size;
        text->state = S_text;
        return;
      }
      if (ch == L'I') {
        text->state = S_jisx0201_text;
        text->permissible_split = (uint)text->last_line->size;
        text->kcode = JIS;
        return;
      }
      text->state = S_text;
      break;
    case S_nonascii_text:
      if (ch == L'\x1b') {
        text->state = S_esc;
        text->kanji_buf = L'\0';
        if (HTCJK != JAPANESE) {
          return;
        }
        text->kcode = NOKANJI;
        return;
      }
      if (bVar9 < 0x20) {
        text->state = S_text;
        text->kanji_buf = L'\0';
        if (HTCJK == JAPANESE) {
          text->kcode = NOKANJI;
        }
      }
      else {
        ch = ch | 0x80;
      }
      break;
    case S_dollar_paren:
      if (ch == L'C') {
        text->state = S_nonascii_text;
        return;
      }
      text->state = S_text;
      break;
    case S_jisx0201_text:
      if (ch == L'\x1b') {
        text->state = S_esc;
        text->kanji_buf = L'\0';
        text->kcode = NOKANJI;
        return;
      }
      text->kanji_buf = L'\xffffff8e';
      ch = ch | 0x80;
    }
    if (text->kanji_buf == L'\0') {
      if ((ch & 0x80U) != 0) {
        if ((text->kcode == JIS) ||
           ((((text->kcode != SJIS &&
              ((text->detected_kcode != DET_SJIS || (text->specified_kcode != NOKANJI)))) &&
             ((text->kcode != NOKANJI || (text->specified_kcode != SJIS)))) ||
            ((c_1 = (uchar)ch, c_1 < 0xa1 || (0xdf < c_1)))))) {
          text->kanji_buf = ch;
          text->permissible_split = (uint)text->last_line->size;
          return;
        }
        kb = (uchar)text->kanji_buf;
        JISx0201TO0208_SJIS((uchar)&kb,unaff_EBX,unaff_ESI);
        ch = (wchar_t)(char)c_1;
        text->kanji_buf = (uint)kb;
        text->permissible_split = (uint)text->last_line->size;
      }
      goto LAB_08062c21;
    }
  }
  bVar9 = (byte)ch;
  if (((text->source != '\0') || (dont_wrap_pre != '\0')) && (text == HTMainText)) {
    iVar12 = ((uint)line->offset + (uint)line->size) - ctrl_chars_on_this_line;
    if (text->stbl == (STable_info *)0x0) {
      local_13c = LYcols - (uint)(LYShowScrollbar != '\0');
    }
    else {
      if (LYtableCols < L'\x01') {
        if (LYwideLines == L'\0') {
          local_134 = LYcols;
        }
        else {
          local_134 = 0x3f6;
        }
        local_138 = local_134;
      }
      else {
        local_138 = (LYtableCols * LYcols) / 0xc;
      }
      local_13c = local_138 - (uint)(LYShowScrollbar != '\0');
    }
    if ((HTCJK == NOCJK) || (text->kanji_buf == L'\0')) {
      local_12c = 0;
    }
    else {
      local_12c = 1;
    }
    if (iVar12 < (local_13c - pHVar4->rightIndent) - local_12c) {
      if ((text->T).output_utf8 != '\0') {
        if (((int)(char)~bVar9 & 0xc0U) == 0) {
          if ((~bVar9 & 0x20) == 0) {
            if ((~bVar9 & 0x10) == 0) {
              if ((~bVar9 & 8) == 0) {
                if ((~bVar9 & 4) == 0) {
                  if ((~bVar9 & 2) == 0) {
                    local_114 = 0;
                  }
                  else {
                    local_114 = 5;
                  }
                  local_118 = local_114;
                }
                else {
                  local_118 = 4;
                }
                local_11c = local_118;
              }
              else {
                local_11c = 3;
              }
              local_120 = local_11c;
            }
            else {
              local_120 = 2;
            }
            local_124 = local_120;
          }
          else {
            local_124 = 1;
          }
          local_128 = local_124;
        }
        else {
          local_128 = 0;
        }
        if (text->stbl == (STable_info *)0x0) {
          local_10c = LYcols - (uint)(LYShowScrollbar != '\0');
        }
        else {
          if (LYtableCols < L'\x01') {
            if (LYwideLines == L'\0') {
              local_104 = LYcols;
            }
            else {
              local_104 = 0x3f6;
            }
            local_108 = local_104;
          }
          else {
            local_108 = (LYtableCols * LYcols) / 0xc;
          }
          local_10c = local_108 - (uint)(LYShowScrollbar != '\0');
        }
        if (local_10c <= local_128 + iVar12) goto LAB_08063b53;
      }
    }
    else {
LAB_08063b53:
      split_line(text,0);
      line = text->last_line;
      wVar5 = text->kanji_buf;
      eVar6 = text->state;
      text->kanji_buf = L'\0';
      text->state = S_text;
      HText_appendCharacter(text,L'\b');
      text->kanji_buf = wVar5;
      text->state = eVar6;
    }
  }
  if ((ch == L' ') && (text->permissible_split = (uint)text->last_line->size, HTCJK == JAPANESE)) {
    text->kcode = NOKANJI;
  }
  if (text->IgnoreExcess != '\0') {
    iVar12 = ((uint)line->offset + (uint)line->size + local_180) - ctrl_chars_on_this_line;
    if (text->stbl == (STable_info *)0x0) {
      local_100 = LYcols - (uint)(LYShowScrollbar != '\0');
    }
    else {
      if (LYtableCols < L'\x01') {
        if (LYwideLines == L'\0') {
          local_f8 = LYcols;
        }
        else {
          local_f8 = 0x3f6;
        }
        local_fc = local_f8;
      }
      else {
        local_fc = (LYtableCols * LYcols) / 0xc;
      }
      local_100 = local_fc - (uint)(LYShowScrollbar != '\0');
    }
    limit = local_100;
    if ((((keypad_mode == 3) || (keypad_mode == 2)) && (number_fields_on_left == '\0')) &&
       ((text->last_anchor != (TextAnchor *)0x0 &&
        (wVar5 = text->last_anchor->number, L'\0' < wVar5)))) {
      if (wVar5 < L'') {
        if (wVar5 < L'') {
          if (wVar5 < L'') {
            if (wVar5 < L'd') {
              if (wVar5 < L'\n') {
                local_e4 = 3;
              }
              else {
                local_e4 = 4;
              }
              local_e8 = local_e4;
            }
            else {
              local_e8 = 5;
            }
            local_ec = local_e8;
          }
          else {
            local_ec = 6;
          }
          local_f0 = local_ec;
        }
        else {
          local_f0 = 7;
        }
        local_f4 = local_f0;
      }
      else {
        local_f4 = 8;
      }
      limit = local_100 - local_f4;
    }
    if (limit <= pHVar4->rightIndent + iVar12) {
      return;
    }
    if (text->stbl == (STable_info *)0x0) {
      local_e0 = LYcols - (uint)(LYShowScrollbar != '\0');
    }
    else {
      if (LYtableCols < L'\x01') {
        if (LYwideLines == L'\0') {
          local_d8 = LYcols;
        }
        else {
          local_d8 = 0x3f6;
        }
        local_dc = local_d8;
      }
      else {
        local_dc = (LYtableCols * LYcols) / 0xc;
      }
      local_e0 = local_dc - (uint)(LYShowScrollbar != '\0');
    }
    if (local_e0 <= iVar12) {
      return;
    }
  }
  if ((line->size == 0) || (line->data[line->size - 1] != '\a')) {
    local_d0 = 0;
  }
  else {
    local_d0 = 1;
  }
  local_d0 = (uint)line->offset + local_180 + (uint)line->size + local_d0;
  if ((HTCJK == NOCJK) || (text->kanji_buf == L'\0')) {
    local_c8 = 0;
  }
  else {
    local_c8 = 1;
  }
  if (text->stbl == (STable_info *)0x0) {
    local_c0 = LYcols - (uint)(LYShowScrollbar != '\0');
  }
  else {
    if (LYtableCols < L'\x01') {
      if (LYwideLines == L'\0') {
        local_b8 = LYcols;
      }
      else {
        local_b8 = 0x3f6;
      }
      local_bc = local_b8;
    }
    else {
      local_bc = (LYtableCols * LYcols) / 0xc;
    }
    local_c0 = local_bc - (uint)(LYShowScrollbar != '\0');
  }
  if (((pHVar4->rightIndent + local_d0) - ctrl_chars_on_this_line) + local_c8 < local_c0) {
    if ((text->T).output_utf8 != '\0') {
      if (((int)(char)~bVar9 & 0xc0U) == 0) {
        if ((~bVar9 & 0x20) == 0) {
          if ((~bVar9 & 0x10) == 0) {
            if ((~bVar9 & 8) == 0) {
              if ((~bVar9 & 4) == 0) {
                if ((~bVar9 & 2) == 0) {
                  local_9c = 0;
                }
                else {
                  local_9c = 5;
                }
                local_a0 = local_9c;
              }
              else {
                local_a0 = 4;
              }
              local_a4 = local_a0;
            }
            else {
              local_a4 = 3;
            }
            local_a8 = local_a4;
          }
          else {
            local_a8 = 2;
          }
          local_ac = local_a8;
        }
        else {
          local_ac = 1;
        }
        local_b0 = local_ac;
      }
      else {
        local_b0 = 0;
      }
      if (text->stbl == (STable_info *)0x0) {
        local_90 = LYcols - (uint)(LYShowScrollbar != '\0');
      }
      else {
        if (LYtableCols < L'\x01') {
          if (LYwideLines == L'\0') {
            local_8c = LYcols;
          }
          else {
            local_8c = 0x3f6;
          }
          local_90 = local_8c;
        }
        else {
          local_90 = (LYtableCols * LYcols) / 0xc;
        }
        local_90 = local_90 - (uint)(LYShowScrollbar != '\0');
      }
      local_94 = local_90 + -1;
      if (local_94 <= (local_d0 - ctrl_chars_on_this_line) + local_b0) goto LAB_08064265;
    }
    if (0x3fe < line->size) {
      split_line(text,0);
    }
  }
  else {
LAB_08064265:
    if ((pHVar4->wordWrap == '\0') || (HTOutputFormat == WWW_SOURCE)) {
      if (HTOutputFormat == WWW_SOURCE) {
        if (0x3fe < line->size) {
          split_line(text,0);
        }
      }
      else if (((dump_output_immediately == '\0') && ((crawl == '\0' || (traversal == '\0')))) ||
              (dont_wrap_pre == '\0')) {
        split_line(text,0);
      }
      else if (0x3fe < line->size) {
        split_line(text,0);
      }
    }
    else {
      if (((wait_for_this_stacked_elt < L'\0') &&
          (((text->style->alignment == 1 || (text->style->alignment == 0)) && (HTCJK == NOCJK)))) &&
         ((((in_DT == '\0' && (can_justify_here != '\0')) && (can_justify_this_line != '\0')) &&
          (form_in_htext == '\0')))) {
        this_line_was_split = '\x01';
      }
      split_line(text,text->permissible_split);
      if (ch == L' ') {
        return;
      }
    }
  }
  if ((ch == L'\x01') &&
     ((((L'\xffffffff' < wait_for_this_stacked_elt ||
        ((text->style->alignment != 1 && (text->style->alignment != 0)))) || (HTCJK != NOCJK)) ||
      ((((in_DT != '\0' || (can_justify_here == '\0')) || (can_justify_this_line == '\0')) ||
       (form_in_htext != '\0')))))) {
    ch = L' ';
  }
  else {
    have_raw_nbsps = '\x01';
  }
  if ((ch & 0x80U) != 0) {
    text->have_8bit_chars = '\x01';
  }
  uVar7 = pHVar4->font;
  pHVar8 = text->last_line;
  local_79 = (byte)ch;
  if ((HTCJK == NOCJK) || (text->kanji_buf == L'\0')) {
    if (HTCJK == NOCJK) {
      uVar1 = pHVar8->size;
      local_6e = local_79;
      if ((uVar7 & 1) != 0) {
        ppuVar11 = __ctype_b_loc();
        local_6d = local_79;
        if (((*ppuVar11)[ch & 0xff] & 0x200) != 0) {
          iVar12 = toupper(ch & 0xff);
          local_6d = (byte)iVar12;
        }
        local_6e = local_6d;
      }
      pHVar8->data[uVar1] = local_6e;
      pHVar8->size = uVar1 + 1;
    }
    else {
      uVar1 = pHVar8->size;
      if (kanji_code == NOKANJI) {
        local_78 = local_79;
        if ((uVar7 & 1) != 0) {
          ppuVar11 = __ctype_b_loc();
          local_77 = local_79;
          if (((*ppuVar11)[ch & 0xff] & 0x200) != 0) {
            iVar12 = toupper(ch & 0xff);
            local_77 = (byte)iVar12;
          }
          local_78 = local_77;
        }
        local_79 = local_78;
      }
      pHVar8->data[uVar1] = local_79;
      pHVar8->size = uVar1 + 1;
    }
  }
  else {
    wVar5 = text->kanji_buf;
    kb = (uchar)wVar5;
    c_1 = local_79;
    if (HTCJK == JAPANESE) {
      if (text->kcode != JIS) {
        if (((local_79 < 0x40) || (local_79 == 0x7f)) ||
           ((0xfc < local_79 || (((kb < 0x81 || (0x9f < kb)) && ((kb < 0xe0 || (0xef < kb)))))))) {
          if (((((kb < 0xa1) || (kb == 0xff)) || (local_79 < 0xa1)) || (local_79 == 0xff)) &&
             (((kb != 0x8e || (local_79 < 0xa1)) || (0xdf < local_79)))) {
            text->kcode = NOKANJI;
          }
          else {
            text->kcode = EUC;
          }
        }
        else if ((((kb < 0xa1) || (kb == 0xff)) || ((local_79 < 0xa1 || (local_79 == 0xff)))) &&
                (((kb != 0x8e || (local_79 < 0xa1)) || (0xdf < local_79)))) {
          text->kcode = SJIS;
        }
        else if (text->specified_kcode == NOKANJI) {
          if (text->detected_kcode == DET_EUC) {
            text->kcode = EUC;
          }
          else if (text->detected_kcode == DET_SJIS) {
            text->kcode = SJIS;
          }
          else if (((kb == 0x8e) && (0xa0 < local_79)) &&
                  ((local_79 < 0xe0 && (text->kcode != EUC)))) {
            text->kcode = SJIS;
          }
        }
        else {
          text->kcode = text->specified_kcode;
        }
      }
      if (kanji_code == EUC) {
        if (text->kcode == SJIS) {
          SJIS_TO_EUC1(kb,local_79,tmp);
          uVar1 = pHVar8->size;
          pHVar8->data[uVar1] = tmp[0];
          pHVar8->size = uVar1 + 1;
          uVar1 = pHVar8->size;
          pHVar8->data[uVar1] = tmp[1];
          pHVar8->size = uVar1 + 1;
        }
        else if ((((kb < 0xa1) || (kb == 0xff)) || ((local_79 < 0xa1 || (local_79 == 0xff)))) &&
                (((kb != 0x8e || (local_79 < 0xa1)) || (0xdf < local_79)))) {
          if (WWW_TraceFlag != '\0') {
            pFVar10 = TraceFP();
            fprintf((FILE *)pFVar10,"This character (%X:%X) doesn\'t seem Japanese\n",wVar5 & 0xff,
                    ch & 0xff);
          }
          uVar1 = pHVar8->size;
          pHVar8->data[uVar1] = '=';
          pHVar8->size = uVar1 + 1;
          uVar1 = pHVar8->size;
          pHVar8->data[uVar1] = '=';
          pHVar8->size = uVar1 + 1;
        }
        else {
          JISx0201TO0208_EUC(kb,local_79,&kb,&c_1);
          uVar1 = pHVar8->size;
          pHVar8->data[uVar1] = kb;
          pHVar8->size = uVar1 + 1;
          uVar1 = pHVar8->size;
          pHVar8->data[uVar1] = c_1;
          pHVar8->size = uVar1 + 1;
        }
      }
      else if (kanji_code == SJIS) {
        if ((text->kcode == EUC) || (text->kcode == JIS)) {
          EUC_TO_SJIS1(kb,local_79,tmp);
          uVar1 = pHVar8->size;
          pHVar8->data[uVar1] = tmp[0];
          pHVar8->size = uVar1 + 1;
          uVar1 = pHVar8->size;
          pHVar8->data[uVar1] = tmp[1];
          pHVar8->size = uVar1 + 1;
        }
        else if ((((local_79 < 0x40) || (local_79 == 0x7f)) || (0xfc < local_79)) ||
                (((kb < 0x81 || (0x9f < kb)) && ((kb < 0xe0 || (0xef < kb)))))) {
          uVar1 = pHVar8->size;
          pHVar8->data[uVar1] = '=';
          pHVar8->size = uVar1 + 1;
          uVar1 = pHVar8->size;
          pHVar8->data[uVar1] = '=';
          pHVar8->size = uVar1 + 1;
          if (WWW_TraceFlag != '\0') {
            pFVar10 = TraceFP();
            fprintf((FILE *)pFVar10,"This character (%X:%X) doesn\'t seem Japanese\n",wVar5 & 0xff,
                    ch & 0xff);
          }
        }
        else {
          uVar1 = pHVar8->size;
          pHVar8->data[uVar1] = kb;
          pHVar8->size = uVar1 + 1;
          uVar1 = pHVar8->size;
          pHVar8->data[uVar1] = local_79;
          pHVar8->size = uVar1 + 1;
        }
      }
    }
    else {
      uVar1 = pHVar8->size;
      pHVar8->data[uVar1] = kb;
      pHVar8->size = uVar1 + 1;
      uVar1 = pHVar8->size;
      pHVar8->data[uVar1] = local_79;
      pHVar8->size = uVar1 + 1;
    }
    text->kanji_buf = L'\0';
  }
  pHVar8->data[pHVar8->size] = '\0';
  if ((uVar7 & 0x10) != 0) {
    HText_appendCharacter(text,L'\x01');
  }
  if (ch == L'\a') {
    ctrl_chars_on_this_line = ctrl_chars_on_this_line + L'\x01';
    text->permissible_split = (uint)text->last_line->size;
  }
  if (ch == L'\b') {
    ctrl_chars_on_this_line = ctrl_chars_on_this_line + L'\x01';
  }
  return;
}



// WARNING: Unknown calling convention

void _internal_HTC(HText *text,wchar_t style,wchar_t dir)

{
  HTLine *pHVar1;
  HTLine *line;
  
  if (text != (HText *)0x0) {
    pHVar1 = text->last_line;
    if ((((pHVar1->numstyles == 0) || (dir != L'\0')) ||
        ((*(byte *)(pHVar1->styles + -(1 - (uint)pHVar1->numstyles)) & 3) == 0)) ||
       (((uint)*(ushort *)&pHVar1->styles[-(1 - (uint)pHVar1->numstyles)].field_0x2 != style ||
        ((uint)(*(ushort *)(pHVar1->styles + -(1 - (uint)pHVar1->numstyles)) >> 2) !=
         (uint)pHVar1->size - ctrl_chars_on_this_line)))) {
      if (pHVar1->numstyles < 0x40) {
        *(ushort *)(pHVar1->styles + pHVar1->numstyles) =
             *(ushort *)(pHVar1->styles + pHVar1->numstyles) & 3 | pHVar1->size * 4;
        if (ctrl_chars_on_this_line <=
            (int)(uint)(*(ushort *)(pHVar1->styles + pHVar1->numstyles) >> 2)) {
          *(ushort *)(pHVar1->styles + pHVar1->numstyles) =
               *(ushort *)(pHVar1->styles + pHVar1->numstyles) & 3 |
               ((*(ushort *)(pHVar1->styles + pHVar1->numstyles) >> 2) -
               (short)ctrl_chars_on_this_line) * 4;
        }
        *(short *)&pHVar1->styles[pHVar1->numstyles].field_0x2 = (short)style;
        *(byte *)(pHVar1->styles + pHVar1->numstyles) =
             *(byte *)(pHVar1->styles + pHVar1->numstyles) & 0xfc | (byte)dir & 3;
        pHVar1->numstyles = pHVar1->numstyles + 1;
      }
    }
    else {
      pHVar1->numstyles = pHVar1->numstyles - 1;
    }
  }
  return;
}



void HText_setLastChar(HText *text,char ch)

{
  char ch_local;
  
  if (text != (HText *)0x0) {
    text->LastChar = ch;
  }
  return;
}



// WARNING: Unknown calling convention

char HText_getLastChar(HText *text)

{
  char local_5;
  
  if (text == (HText *)0x0) {
    local_5 = '\0';
  }
  else {
    local_5 = text->LastChar;
  }
  return local_5;
}



void HText_setIgnoreExcess(HText *text,BOOLEAN ignore)

{
  BOOLEAN ignore_local;
  
  if (text != (HText *)0x0) {
    text->IgnoreExcess = ignore;
  }
  return;
}



// WARNING: Unknown calling convention

wchar_t HText_insertBlanksInStblLines(HText *me,wchar_t ncols)

{
  ushort uVar1;
  wchar_t wVar2;
  HTStyle *pHVar3;
  BOOLEAN BVar4;
  wchar_t *oldpos_00;
  wchar_t *newpos_00;
  wchar_t wVar5;
  HTLine *pHVar6;
  TextAnchor **ppTVar7;
  FILE *pFVar8;
  int iVar9;
  wchar_t *pwVar10;
  wchar_t wVar11;
  TextAnchor **prev_anchor;
  wchar_t wVar12;
  wchar_t local_7c;
  int local_78;
  int local_74;
  int local_70;
  wchar_t ip_1;
  wchar_t width_1;
  wchar_t width;
  wchar_t ip;
  wchar_t i;
  HTStyle *style;
  wchar_t table_offset;
  wchar_t spare;
  wchar_t indent;
  wchar_t max_width;
  wchar_t lines_changed;
  wchar_t added_chars_before;
  wchar_t last_nonempty;
  wchar_t first_lineno_pass2;
  wchar_t last_lineno;
  wchar_t first_lineno;
  wchar_t lineno;
  wchar_t ninserts;
  wchar_t *newpos;
  wchar_t *oldpos;
  HTLine *first_line;
  HTLine *mod_line;
  HTLine *line;
  short alignment;
  
  first_line = (HTLine *)0x0;
  last_nonempty = L'\xffffffff';
  lines_changed = L'\0';
  max_width = L'\0';
  i = L'\0';
  lineno = Stbl_getStartLine(me->stbl);
  if ((lineno < L'\0') || (me->Lines < lineno)) {
    local_7c = L'\xffffffff';
  }
  else {
    oldpos_00 = (wchar_t *)calloc(ncols * 2,4);
    if (oldpos_00 == (wchar_t *)0x0) {
      local_7c = L'\xffffffff';
    }
    else {
      newpos_00 = oldpos_00 + ncols;
      line = me->last_line->next;
      for (; i < lineno; i = i + L'\x01') {
        if (line == (HTLine *)0x0) {
          free(oldpos_00);
          return L'\xffffffff';
        }
        line = line->next;
      }
      wVar2 = me->Lines;
      first_lineno_pass2 = wVar2;
      for (; (line != (HTLine *)0x0 && (lineno <= wVar2)); lineno = lineno + L'\x01') {
        pwVar10 = oldpos_00;
        wVar5 = Stbl_getFixupPositions(me->stbl,lineno,oldpos_00,newpos_00);
        if (L'\xffffffff' < wVar5) {
          if (first_line == (HTLine *)0x0) {
            first_line = line;
            first_lineno_pass2 = lineno;
            if (WWW_TraceFlag != '\0') {
              if (WWW_TraceFlag != '\0') {
                pFVar8 = TraceFP();
                pwVar10 = (wchar_t *)lineno;
                fprintf((FILE *)pFVar8,"line %d first to adjust  --  newpos:",lineno);
              }
              for (ip = L'\0'; ip < ncols; ip = ip + L'\x01') {
                if (WWW_TraceFlag != '\0') {
                  pwVar10 = (wchar_t *)newpos_00[ip];
                  pFVar8 = TraceFP();
                  fprintf((FILE *)pFVar8," %d",pwVar10);
                }
              }
              if (WWW_TraceFlag != '\0') {
                pFVar8 = TraceFP();
                fprintf((FILE *)pFVar8,"\n",pwVar10);
              }
            }
          }
          if (me->last_line == line) {
            if ((line->size == 0) || (BVar4 = HText_TrueEmptyLine(line,me,'\0'), BVar4 != '\0'))
            goto LAB_080652c3;
            if (first_line == line) {
              first_line = (HTLine *)0x0;
            }
            split_line(me,0);
            line = me->last_line->prev;
            if (first_line == (HTLine *)0x0) {
              first_line = line;
            }
          }
          if (wVar5 == L'\0') {
            wVar5 = HText_TrueLineSize(line,me,'\0');
            if (max_width < wVar5) {
              max_width = wVar5;
            }
            if (((nested_tables != '\0') && (wVar5 != L'\0')) && (last_nonempty < lineno)) {
              last_nonempty = lineno;
            }
            if (WWW_TraceFlag != '\0') {
              pFVar8 = TraceFP();
              fprintf((FILE *)pFVar8,"line %d true/max width:%d/%d oldpos: NONE\n",lineno,wVar5,
                      max_width);
            }
          }
          else {
            prev_anchor = &me->last_anchor_before_stbl;
            wVar12 = wVar5;
            pHVar6 = insert_blanks_in_line(line,lineno,me,prev_anchor,wVar5,oldpos_00,newpos_00);
            if (pHVar6 != (HTLine *)0x0) {
              if (me->last_line == line) {
                me->last_line = pHVar6;
              }
              line->prev->next = pHVar6;
              line->next->prev = pHVar6;
              lines_changed = lines_changed + L'\x01';
              if (line == first_line) {
                first_line = pHVar6;
              }
              line = pHVar6;
              if (L'\xffffffff' < me->first_lineno_last_disp_partial) {
                if (me->first_lineno_last_disp_partial < lineno) {
                  if (lineno <= me->last_lineno_last_disp_partial) {
                    me->last_lineno_last_disp_partial = lineno + L'\xffffffff';
                  }
                }
                else {
                  ResetPartialLinenos(me);
                }
              }
            }
            wVar11 = L'\0';
            ppTVar7 = (TextAnchor **)HText_TrueLineSize(line,me,'\0');
            if (max_width < (int)ppTVar7) {
              max_width = (wchar_t)ppTVar7;
            }
            if (((nested_tables != '\0') && (ppTVar7 != (TextAnchor **)0x0)) &&
               (last_nonempty < lineno)) {
              last_nonempty = lineno;
            }
            if (WWW_TraceFlag != '\0') {
              if (WWW_TraceFlag != '\0') {
                pFVar8 = TraceFP();
                wVar11 = lineno;
                wVar12 = max_width;
                fprintf((FILE *)pFVar8,"line %d true/max width:%d/%d oldpos:",lineno,ppTVar7,
                        max_width);
                prev_anchor = ppTVar7;
              }
              for (ip_1 = L'\0'; ip_1 < wVar5; ip_1 = ip_1 + L'\x01') {
                if (WWW_TraceFlag != '\0') {
                  wVar11 = oldpos_00[ip_1];
                  pFVar8 = TraceFP();
                  fprintf((FILE *)pFVar8," %d",wVar11,prev_anchor,wVar12);
                }
              }
              if (WWW_TraceFlag != '\0') {
                pFVar8 = TraceFP();
                fprintf((FILE *)pFVar8,"\n",wVar11,prev_anchor,wVar12);
              }
            }
          }
        }
LAB_080652c3:
        line = line->next;
      }
      pHVar3 = me->style;
      alignment = Stbl_getAlignment(me->stbl);
      if (alignment == -1) {
        alignment = pHVar3->alignment;
      }
      indent = pHVar3->leftIndent;
      if (me->stbl == (STable_info *)0x0) {
        local_78 = LYcols - (uint)(LYShowScrollbar != '\0');
      }
      else {
        if (LYtableCols < L'\x01') {
          if (LYwideLines == L'\0') {
            local_70 = LYcols;
          }
          else {
            local_70 = 0x3f6;
          }
          local_74 = local_70;
        }
        else {
          local_74 = (LYtableCols * LYcols) / 0xc;
        }
        local_78 = local_74 - (uint)(LYShowScrollbar != '\0');
      }
      spare = ((local_78 - pHVar3->rightIndent) - indent) - max_width;
      if ((spare < L'\0') && (-1 < pHVar3->rightIndent + spare)) {
        spare = L'\0';
      }
      else if (spare < L'\0') {
        spare = spare + pHVar3->rightIndent;
      }
      if ((spare < L'\0') && (-1 < indent + spare)) {
        indent = indent + spare;
        spare = L'\0';
      }
      else if (spare < L'\0') {
        if (WWW_TraceFlag != '\0') {
          pFVar8 = TraceFP();
          fprintf((FILE *)pFVar8,"BUG: insertBlanks: resulting table too wide by %d positions!\n",
                  -spare);
        }
        spare = L'\0';
        indent = L'\0';
      }
      if (alignment == 2) {
        table_offset = indent + spare;
      }
      else if (alignment == 3) {
        table_offset = spare / 2 + indent;
      }
      else {
        table_offset = indent;
      }
      if (WWW_TraceFlag != '\0') {
        pFVar8 = TraceFP();
        fprintf((FILE *)pFVar8,"changing offsets");
      }
      lineno = first_lineno_pass2;
      for (line = first_line;
          ((line != (HTLine *)0x0 && (lineno <= wVar2)) && (me->last_line != line));
          line = line->next) {
        iVar9 = Stbl_getFixupPositions(me->stbl,lineno,oldpos_00,newpos_00);
        if ((-1 < iVar9) && ((uint)line->offset != table_offset)) {
          if (L'\xffffffff' < me->first_lineno_last_disp_partial) {
            if (me->first_lineno_last_disp_partial < lineno) {
              if (lineno <= me->last_lineno_last_disp_partial) {
                me->last_lineno_last_disp_partial = lineno + L'\xffffffff';
              }
            }
            else {
              ResetPartialLinenos(me);
            }
          }
          if (WWW_TraceFlag != '\0') {
            uVar1 = line->offset;
            pFVar8 = TraceFP();
            fprintf((FILE *)pFVar8," %d:%d",lineno,table_offset - (uint)uVar1);
          }
          line->offset = ~(ushort)(table_offset >> 0x1f) & (ushort)table_offset;
        }
        lineno = lineno + L'\x01';
      }
      if ((nested_tables != '\0') && (max_width != L'\0')) {
        Stbl_update_enclosing(me->stbl,max_width,last_nonempty);
      }
      if (WWW_TraceFlag != '\0') {
        pFVar8 = TraceFP();
        fprintf((FILE *)pFVar8," %d:done\n",lineno);
      }
      free(oldpos_00);
      local_7c = lines_changed;
    }
  }
  return local_7c;
}



// WARNING: Unknown calling convention

void HText_cancelStbl(HText *me)

{
  FILE *pFVar1;
  STable_info *pSVar2;
  STable_info *enclosing;
  STable_info *stbl;
  
  if ((me == (HText *)0x0) || (me->stbl == (STable_info *)0x0)) {
    if (WWW_TraceFlag != '\0') {
      pFVar1 = TraceFP();
      fprintf((FILE *)pFVar1,"cancelStbl: ignored.\n");
    }
  }
  else {
    if (WWW_TraceFlag != '\0') {
      pFVar1 = TraceFP();
      fprintf((FILE *)pFVar1,"cancelStbl: ok, will do.\n");
    }
    if (nested_tables == '\0') {
      Stbl_free(me->stbl);
    }
    else {
      stbl = me->stbl;
      while (stbl != (STable_info *)0x0) {
        pSVar2 = Stbl_get_enclosing(stbl);
        Stbl_free(stbl);
        stbl = pSVar2;
      }
    }
    me->stbl = (STable_info *)0x0;
  }
  return;
}



void HText_startStblTABLE(HText *me,short alignment)

{
  STable_info *enclosing;
  STable_info *pSVar1;
  FILE *pFVar2;
  short alignment_local;
  STable_info *current;
  
  enclosing = me->stbl;
  if (me != (HText *)0x0) {
    if (nested_tables == '\0') {
      if (me->stbl != (STable_info *)0x0) {
        HText_cancelStbl(me);
      }
    }
    else if (enclosing != (STable_info *)0x0) {
      split_line(me,0);
    }
    pSVar1 = Stbl_startTABLE(alignment);
    me->stbl = pSVar1;
    if (me->stbl == (STable_info *)0x0) {
      if (WWW_TraceFlag != '\0') {
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2,"startStblTABLE: failed.\n");
      }
    }
    else {
      if (WWW_TraceFlag != '\0') {
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2,"startStblTABLE: started.\n");
      }
      if (nested_tables != '\0') {
        Stbl_set_enclosing(me->stbl,enclosing,me->last_anchor_before_stbl);
      }
      me->last_anchor_before_stbl = me->last_anchor;
    }
  }
  return;
}



// WARNING: Unknown calling convention

void free_enclosed_stbl(HText *me)

{
  STable_info *pSVar1;
  FILE *__stream;
  STable_info *local_1c;
  STable_info *stbl;
  HTList *list;
  
  if (me->enclosed_stbl != (HTList *)0x0) {
    list = me->enclosed_stbl;
    while( true ) {
      if ((list == (HTList *)0x0) || (list = list->next, list == (HTList *)0x0)) {
        local_1c = (STable_info *)0x0;
      }
      else {
        local_1c = (STable_info *)list->object;
      }
      if (local_1c == (STable_info *)0x0) break;
      if (WWW_TraceFlag != '\0') {
        pSVar1 = me->stbl;
        __stream = TraceFP();
        fprintf((FILE *)__stream,"endStblTABLE: finally free %p\n",pSVar1);
      }
      Stbl_free(local_1c);
    }
    HTList_delete(me->enclosed_stbl);
    me->enclosed_stbl = (HTList *)0x0;
  }
  return;
}



// WARNING: Unknown calling convention

wchar_t HText_endStblTABLE(HText *me)

{
  STable_info *pSVar1;
  FILE *pFVar2;
  wchar_t wVar3;
  _TextAnchor *p_Var4;
  HTList *pHVar5;
  wchar_t local_20;
  undefined *local_1c;
  STable_info *enclosing;
  wchar_t lines_changed;
  wchar_t ncols;
  
  enclosing = (STable_info *)0x0;
  if ((me == (HText *)0x0) || (me->stbl == (STable_info *)0x0)) {
    if (WWW_TraceFlag != '\0') {
      pFVar2 = TraceFP();
      fprintf((FILE *)pFVar2,"endStblTABLE: ignored.\n");
    }
    free_enclosed_stbl(me);
    local_20 = L'\0';
  }
  else {
    if (WWW_TraceFlag != '\0') {
      pFVar2 = TraceFP();
      fprintf((FILE *)pFVar2,"endStblTABLE: ok, will try.\n");
    }
    wVar3 = Stbl_finishTABLE(me->stbl);
    if (WWW_TraceFlag != '\0') {
      pFVar2 = TraceFP();
      fprintf((FILE *)pFVar2,"endStblTABLE: ncols = %d.\n",wVar3);
    }
    if (L'\0' < wVar3) {
      wVar3 = HText_insertBlanksInStblLines(me,wVar3);
      if (WWW_TraceFlag != '\0') {
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2,"endStblTABLE: changed %d lines, done.\n",wVar3);
      }
      NumOfLines_partial = NumOfLines_partial - wVar3;
    }
    if (nested_tables == '\0') {
      Stbl_free(me->stbl);
      me->stbl = (STable_info *)0x0;
    }
    else {
      enclosing = Stbl_get_enclosing(me->stbl);
      p_Var4 = Stbl_get_last_anchor_before(me->stbl);
      me->last_anchor_before_stbl = p_Var4;
      if (enclosing == (STable_info *)0x0) {
        Stbl_free(me->stbl);
        free_enclosed_stbl(me);
      }
      else {
        if (me->enclosed_stbl == (HTList *)0x0) {
          pHVar5 = HTList_new();
          me->enclosed_stbl = pHVar5;
        }
        HTList_addObject(me->enclosed_stbl,me->stbl);
        if (WWW_TraceFlag != '\0') {
          pSVar1 = me->stbl;
          pFVar2 = TraceFP();
          fprintf((FILE *)pFVar2,"endStblTABLE: postpone free %p\n",pSVar1);
        }
      }
      me->stbl = enclosing;
    }
    if (WWW_TraceFlag != '\0') {
      if (enclosing == (STable_info *)0x0) {
        local_1c = &DAT_0814d3d8;
      }
      else {
        local_1c = &DAT_0814cbac;
      }
      pFVar2 = TraceFP();
      fprintf((FILE *)pFVar2,"endStblTABLE: have%s enclosing table (%p)\n",local_1c,enclosing);
    }
    local_20 = (wchar_t)(enclosing != (STable_info *)0x0);
  }
  return local_20;
}



void HText_startStblTR(HText *me,short alignment)

{
  int iVar1;
  short alignment_local;
  
  if ((me != (HText *)0x0) && (me->stbl != (STable_info *)0x0)) {
    iVar1 = Stbl_addRowToTable(me->stbl,(int)alignment,me->Lines);
    if (iVar1 < 0) {
      HText_cancelStbl(me);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void HText_endStblTR(HText *me)

{
  return;
}



void HText_startStblTD(HText *me,wchar_t colspan,wchar_t rowspan,short alignment,BOOLEAN isheader)

{
  FILE *pFVar1;
  wchar_t pos;
  wchar_t offset_not_used_yet;
  int iVar2;
  BOOLEAN isheader_local;
  short alignment_local;
  
  if ((me != (HText *)0x0) && (me->stbl != (STable_info *)0x0)) {
    if (colspan < L'\0') {
      colspan = L'\x01';
    }
    if (L'' < colspan) {
      if (WWW_TraceFlag != '\0') {
        pFVar1 = TraceFP();
        fprintf((FILE *)pFVar1,"*** COLSPAN=%d is too large, ignored!\n",colspan);
      }
      colspan = L'\x01';
    }
    if (L'' < rowspan) {
      if (WWW_TraceFlag != '\0') {
        pFVar1 = TraceFP();
        fprintf((FILE *)pFVar1,"*** ROWSPAN=%d is too large, ignored!\n",rowspan);
      }
      rowspan = L'\x01';
    }
    pos = HText_LastLineSize(me,'\0');
    offset_not_used_yet = HText_LastLineOffset(me);
    iVar2 = Stbl_addCellToTable(me->stbl,colspan,rowspan,(int)alignment,(int)isheader,me->Lines,
                                offset_not_used_yet,pos);
    if (iVar2 < 0) {
      HText_cancelStbl(me);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void HText_endStblTD(HText *me)

{
  wchar_t pos;
  wchar_t offset;
  int iVar1;
  
  if ((me != (HText *)0x0) && (me->stbl != (STable_info *)0x0)) {
    pos = HText_LastLineSize(me,'\0');
    offset = HText_LastLineOffset(me);
    iVar1 = Stbl_finishCellInTable(me->stbl,1,me->Lines,offset,pos);
    if (iVar1 < 0) {
      HText_cancelStbl(me);
    }
  }
  return;
}



void HText_startStblCOL(HText *me,wchar_t span,short alignment,BOOLEAN isgroup)

{
  FILE *__stream;
  int iVar1;
  BOOLEAN isgroup_local;
  short alignment_local;
  
  if ((me != (HText *)0x0) && (me->stbl != (STable_info *)0x0)) {
    if (span < L'\x01') {
      span = L'\x01';
    }
    if (L'' < span) {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"*** SPAN=%d is too large, ignored!\n",span);
      }
      span = L'\x01';
    }
    iVar1 = Stbl_addColInfo(me->stbl,span,alignment,isgroup);
    if (iVar1 < 0) {
      HText_cancelStbl(me);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void HText_endStblCOLGROUP(HText *me)

{
  int iVar1;
  
  if ((me != (HText *)0x0) && (me->stbl != (STable_info *)0x0)) {
    iVar1 = Stbl_finishColGroup(me->stbl);
    if (iVar1 < 0) {
      HText_cancelStbl(me);
    }
  }
  return;
}



void HText_startStblRowGroup(HText *me,short alignment)

{
  int iVar1;
  short alignment_local;
  
  if ((me != (HText *)0x0) && (me->stbl != (STable_info *)0x0)) {
    iVar1 = Stbl_addRowGroup(me->stbl,alignment);
    if (iVar1 < 0) {
      HText_cancelStbl(me);
    }
  }
  return;
}



void add_link_number(HText *text,TextAnchor *a,BOOLEAN save_position)

{
  int iVar1;
  char cVar2;
  wchar_t wVar3;
  int in_GS_OFFSET;
  BOOLEAN save_position_local;
  TextAnchor *a_local;
  HText *text_local;
  wchar_t saved_linenum;
  char saved_lastchar;
  char marker [32];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if (((L'\0' < a->number) && ((text->source == '\0' || (psrcview_no_anchor_numbering == '\0')))) &&
     ((keypad_mode == 1 || (keypad_mode == 2)))) {
    cVar2 = text->LastChar;
    wVar3 = text->Lines;
    sprintf(marker,"[%d]",a->number);
    HText_appendText(text,marker);
    if (((wVar3 != L'\0') && (text->Lines != L'\0')) && (cVar2 != ' ')) {
      text->LastChar = ']';
    }
    if (save_position != '\0') {
      a->line_num = text->Lines;
      a->line_pos = text->last_line->size;
    }
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



wchar_t HText_beginAnchor(HText *text,BOOLEAN underline,HTChildAnchor *anc)

{
  TextAnchor *a_00;
  wchar_t wVar1;
  HTAnchor *pHVar2;
  BOOLEAN underline_local;
  TextAnchor *a;
  
  a_00 = (TextAnchor *)ALLOC_IN_POOL(&HTMainText->pool,0x34);
  if (a_00 == (TextAnchor *)0x0) {
    outofmem("./GridText.c","HText_beginAnchor");
  }
  a_00->inUnderline = underline;
  wVar1 = SGML_offset();
  a_00->sgml_offset = wVar1;
  a_00->line_num = text->Lines;
  a_00->line_pos = text->last_line->size;
  if (text->last_anchor == (TextAnchor *)0x0) {
    text->first_anchor = a_00;
  }
  else {
    text->last_anchor->next = a_00;
  }
  a_00->next = (_TextAnchor *)0x0;
  a_00->anchor = anc;
  a_00->extent = 0;
  a_00->link_type = '\x01';
  text->last_anchor = a_00;
  pHVar2 = HTAnchor_followLink(anc);
  if (pHVar2 == (HTAnchor *)0x0) {
    a_00->number = L'\0';
  }
  else {
    text->last_anchor_number = text->last_anchor_number + L'\x01';
    a_00->number = text->last_anchor_number;
  }
  if (number_links_on_left != '\0') {
    add_link_number(text,a_00,'\x01');
  }
  return a_00->number;
}



// WARNING: Unknown calling convention

BOOLEAN HText_endAnchor0(HText *text,wchar_t number,wchar_t really)

{
  char cVar1;
  short sVar2;
  HTLine *pHVar3;
  wchar_t wVar4;
  short sVar5;
  bool bVar6;
  BOOLEAN BVar7;
  FILE *pFVar8;
  HTAnchor *me;
  ushort **ppuVar9;
  wchar_t wVar10;
  int iVar11;
  short local_56;
  TextAnchor *anc;
  wchar_t NumSize;
  wchar_t extent_adjust;
  wchar_t BlankExtent;
  wchar_t CurBlankExtent;
  HTLine *start;
  HTLine *prev;
  HTLine *last;
  wchar_t l;
  wchar_t k;
  wchar_t j;
  wchar_t i;
  TextAnchor *a;
  BOOLEAN remove_numbers_on_empty;
  
  if ((number < L'\x01') || (text->last_anchor->number == number)) {
    a = text->last_anchor;
  }
  else {
    for (a = text->first_anchor; (a != (TextAnchor *)0x0 && (a->number != number)); a = a->next) {
    }
    if (a == (TextAnchor *)0x0) {
      a = text->last_anchor;
    }
  }
  if (WWW_TraceFlag != '\0') {
    cVar1 = a->link_type;
    wVar10 = a->number;
    pFVar8 = TraceFP();
    fprintf((FILE *)pFVar8,"GridText:HText_endAnchor0: number:%d link_type:%d\n",wVar10,(int)cVar1);
  }
  if (a->link_type == '\x02') {
    if (WWW_TraceFlag != '\0') {
      pFVar8 = TraceFP();
      fprintf((FILE *)pFVar8,"BUG: HText_endAnchor0: internal error: last anchor was input field!\n"
             );
    }
    return '\0';
  }
  if (a->number == L'\0') {
    if (really != L'\0') {
      a->show_anchor = '\0';
      a->extent = 0;
      return '\0';
    }
    return '\0';
  }
  if ((keypad_mode == 1) || (keypad_mode == 2)) {
    if (text->hiddenlinkflag != L'\0') {
LAB_0806620f:
      bVar6 = true;
      goto LAB_0806621f;
    }
    if ((LYNoISMAPifUSEMAP != '\0') &&
       ((text->node_anchor == (HTParentAnchor *)0x0 || (text->node_anchor->bookmark == (char *)0x0))
       )) {
      me = HTAnchor_followLink(a->anchor);
      BVar7 = HTAnchor_isISMAPScript(me);
      if (BVar7 != '\0') goto LAB_0806620f;
    }
  }
  bVar6 = false;
LAB_0806621f:
  pHVar3 = text->last_line;
  prev = text->last_line->prev;
  CurBlankExtent = L'\0';
  BlankExtent = L'\0';
  extent_adjust = L'\0';
  l = text->Lines;
  start = pHVar3;
  if (a->line_num < l) {
    i = (wchar_t)pHVar3->size;
    while ((L'\0' < i &&
           (ppuVar9 = __ctype_b_loc(),
           ((*ppuVar9)[(byte)pHVar3->data[i + L'\xffffffff']] & 0x2000) != 0))) {
      extent_adjust = extent_adjust + L'\xffffffff';
      i = i + L'\xffffffff';
    }
  }
  for (; a->line_num < l; l = l + L'\xffffffff') {
    extent_adjust = extent_adjust + (uint)start->size;
    start = start->prev;
  }
  sVar5 = (short)extent_adjust + (start->size - a->line_pos);
  a->extent = a->extent + sVar5;
  if ((int)(uint)pHVar3->size < (int)a->extent) {
    i = (wchar_t)pHVar3->size;
  }
  else {
    i = (wchar_t)a->extent;
  }
  k = (uint)pHVar3->size - i;
  for (j = k; (j < (int)(uint)pHVar3->size &&
              (((('\x02' < pHVar3->data[j] && (pHVar3->data[j] < '\t')) ||
                (ppuVar9 = __ctype_b_loc(), ((*ppuVar9)[(byte)pHVar3->data[j]] & 0x2000) != 0)) ||
               ((pHVar3->data[j] == '\x01' || (pHVar3->data[j] == '\x02')))))); j = j + L'\x01') {
    i = i + L'\xffffffff';
  }
  start = pHVar3;
  if (i == L'\0') {
    if ((int)(uint)pHVar3->size < (int)a->extent) {
      BlankExtent = (wchar_t)pHVar3->size;
      CurBlankExtent = BlankExtent;
    }
    else {
      BlankExtent = (wchar_t)a->extent;
      CurBlankExtent = BlankExtent;
    }
  }
  while( true ) {
    do {
      if ((i != L'\0') ||
         ((a->extent <= CurBlankExtent &&
          (((a->extent != CurBlankExtent || (k != L'\0')) ||
           ((text->last_line == prev || ((prev->size != 0 && (prev->data[prev->size - 1] != ']')))))
           ))))) goto LAB_0806660f;
      start = prev;
      k = ((uint)prev->size - (int)a->extent) + CurBlankExtent;
      if (k < L'\0') {
        j = L'\0';
        i = (wchar_t)prev->size;
      }
      else {
        i = a->extent - CurBlankExtent;
        j = k;
      }
      for (; (j < (int)(uint)prev->size &&
             (((('\x02' < prev->data[j] && (prev->data[j] < '\t')) ||
               (ppuVar9 = __ctype_b_loc(), ((*ppuVar9)[(byte)prev->data[j]] & 0x2000) != 0)) ||
              ((prev->data[j] == '\x01' || (prev->data[j] == '\x02')))))); j = j + L'\x01') {
        i = i + L'\xffffffff';
      }
    } while (i != L'\0');
    if (((int)a->extent <= (uint)prev->size + CurBlankExtent) &&
       ((((int)a->extent != (uint)prev->size + CurBlankExtent || (k != L'\0')) ||
        ((prev->prev == text->last_line ||
         ((prev->prev->size != 0 && (prev->prev->data[prev->prev->size - 1] != ']')))))))) break;
    BlankExtent = CurBlankExtent + (uint)prev->size;
    prev = prev->prev;
    CurBlankExtent = BlankExtent;
  }
  BlankExtent = (wchar_t)a->extent;
LAB_0806660f:
  if (really == L'\0') {
    a->extent = a->extent - sVar5;
    return i == L'\0';
  }
  if (i == L'\0') {
    a->show_anchor = '\0';
    if (WWW_TraceFlag != '\0') {
      sVar5 = a->extent;
      sVar2 = a->line_pos;
      wVar10 = a->line_num;
      pFVar8 = TraceFP();
      fprintf((FILE *)pFVar8,"HText_endAnchor0: hidden (line,pos,ext,BlankExtent):(%d,%d,%d,%d)",
              wVar10,(int)sVar2,(int)sVar5,BlankExtent);
    }
    if (bVar6) {
      if (start == pHVar3) {
        iVar11 = (uint)pHVar3->size - (int)a->extent;
      }
      else {
        prev = start->prev;
        iVar11 = ((uint)start->size - (int)a->extent) + CurBlankExtent;
      }
      j = iVar11 + L'\xffffffff';
      if (j < L'\0') {
        j = L'\0';
      }
      wVar10 = j;
      if (start->data[j] == ']') {
        NumSize = L'\x01';
        wVar4 = j;
        while ((j = wVar4 + L'\xffffffff', L'\xffffffff' < j &&
               (ppuVar9 = __ctype_b_loc(),
               ((*ppuVar9)[(byte)start->data[wVar4 + L'\xffffffff']] & 0x800) != 0))) {
          NumSize = NumSize + L'\x01';
          wVar4 = j;
        }
        for (; j < L'\0'; j = j + L'\x01') {
          NumSize = NumSize + L'\xffffffff';
        }
        if (start->data[j] == '[') {
          iVar11 = NumSize + L'\x01';
          if ((start == pHVar3) && (j < (int)text->permissible_split)) {
            if ((int)(text->permissible_split - iVar11) < j) {
              text->permissible_split = j;
            }
            else {
              text->permissible_split = text->permissible_split - iVar11;
            }
          }
          for (k = j + iVar11; k < (int)(uint)start->size; k = k + L'\x01') {
            start->data[j] = start->data[k];
            j = j + L'\x01';
          }
          for (anc = a; anc != (TextAnchor *)0x0; anc = anc->next) {
            if ((anc->line_num == a->line_num) && (iVar11 <= anc->line_pos)) {
              anc->line_pos = anc->line_pos - (short)iVar11;
            }
          }
          start->size = (ushort)j;
          start->data[j] = '\0';
          wVar10 = j;
          while (j = wVar10 + L'\x01', j < k) {
            start->data[wVar10 + L'\x01'] = '\0';
            wVar10 = j;
          }
        }
        else if ((prev == (HTLine *)0x0) || (prev->size < 2)) {
          a->show_anchor = '\x01';
        }
        else {
          wVar10 = wVar10 + L'\x01';
          wVar4 = (uint)prev->size;
          do {
            i = wVar4;
            j = i + L'\xffffffff';
            if ((j < L'\0') || (prev->data[i + L'\xffffffff'] < '\x03')) break;
            wVar4 = j;
          } while (prev->data[i + L'\xffffffff'] < '\t');
          while ((L'\xffffffff' < j &&
                 (ppuVar9 = __ctype_b_loc(), ((*ppuVar9)[(byte)prev->data[j]] & 0x800) != 0))) {
            j = j + L'\xffffffff';
          }
          for (; j < L'\0'; j = j + L'\x01') {
          }
          if (prev->data[j] == '[') {
            for (; i < (int)(uint)prev->size; i = i + L'\x01') {
              prev->data[j] = prev->data[i];
              j = j + L'\x01';
            }
            prev->size = (ushort)j;
            prev->data[j] = '\0';
            for (; j < i; j = j + L'\x01') {
              prev->data[j] = '\0';
            }
            if ((start == pHVar3) && (text->permissible_split != 0)) {
              if ((int)text->permissible_split < wVar10) {
                text->permissible_split = 0;
              }
              else {
                text->permissible_split = text->permissible_split - wVar10;
              }
            }
            j = L'\0';
            for (k = wVar10; k < (int)(uint)start->size; k = k + L'\x01') {
              start->data[j] = start->data[k];
              j = j + L'\x01';
            }
            for (anc = a; anc != (TextAnchor *)0x0; anc = anc->next) {
              if ((anc->line_num == a->line_num) && (wVar10 <= anc->line_pos)) {
                anc->line_pos = anc->line_pos - (short)wVar10;
              }
            }
            start->size = (ushort)j;
            start->data[j] = '\0';
            wVar10 = j;
            while (j = wVar10 + L'\x01', j < k) {
              start->data[wVar10 + L'\x01'] = '\0';
              wVar10 = j;
            }
          }
          else {
            a->show_anchor = '\x01';
          }
        }
      }
      else if ((prev == (HTLine *)0x0) || (prev->size < 3)) {
        a->show_anchor = '\x01';
      }
      else {
        wVar10 = (uint)prev->size;
        do {
          j = wVar10 + L'\xffffffff';
          if ((j < L'\0') || (prev->data[wVar10 + L'\xffffffff'] < '\x03')) break;
          iVar11 = wVar10 + L'\xffffffff';
          wVar10 = j;
        } while (prev->data[iVar11] < '\t');
        if (j < L'\0') {
          j = L'\0';
        }
        if (((j < L'\x02') || (prev->data[j] != ']')) ||
           (ppuVar9 = __ctype_b_loc(),
           ((*ppuVar9)[(byte)prev->data[j + L'\xffffffff']] & 0x800) == 0)) {
          a->show_anchor = '\x01';
        }
        else {
          NumSize = L'\x01';
          wVar10 = j;
          while ((j = wVar10 + L'\xffffffff', L'\xffffffff' < j &&
                 (ppuVar9 = __ctype_b_loc(),
                 ((*ppuVar9)[(byte)prev->data[wVar10 + L'\xffffffff']] & 0x800) != 0))) {
            NumSize = NumSize + L'\x01';
            wVar10 = j;
          }
          for (; j < L'\0'; j = j + L'\x01') {
            NumSize = NumSize + L'\xffffffff';
          }
          if (prev->data[j] == '[') {
            for (k = j + NumSize + L'\x01'; k < (int)(uint)prev->size; k = k + L'\x01') {
              prev->data[j] = prev->data[k];
              j = j + L'\x01';
            }
            prev->size = (ushort)j;
            prev->data[j] = '\0';
            wVar10 = j;
            while (j = wVar10 + L'\x01', j < k) {
              prev->data[wVar10 + L'\x01'] = '\0';
              wVar10 = j;
            }
          }
          else {
            a->show_anchor = '\x01';
          }
        }
      }
    }
  }
  else {
    if (number_links_on_left == '\0') {
      add_link_number(text,a,'\0');
    }
    a->show_anchor = '\x01';
    if ((BlankExtent != L'\0') && (WWW_TraceFlag != '\0')) {
      sVar5 = a->extent;
      sVar2 = a->line_pos;
      wVar10 = a->line_num;
      pFVar8 = TraceFP();
      fprintf((FILE *)pFVar8,"HText_endAnchor0: blanks (line,pos,ext,BlankExtent):(%d,%d,%d,%d)",
              wVar10,(int)sVar2,(int)sVar5,BlankExtent);
    }
  }
  if (a->show_anchor == '\0') {
    a->extent = 0;
    if (text->hiddenlinkflag != L'\0') {
      a->number = L'\0';
      text->last_anchor_number = text->last_anchor_number + L'\xffffffff';
      HText_AddHiddenLink(text,a);
    }
  }
  else {
    if (BlankExtent < a->extent) {
      local_56 = (short)BlankExtent;
    }
    else {
      local_56 = 0;
    }
    a->extent = a->extent - local_56;
  }
  if ((((BlankExtent != L'\0') || (a->extent < 1)) || (a->number < L'\x01')) &&
     (WWW_TraceFlag != '\0')) {
    sVar5 = a->extent;
    sVar2 = a->line_pos;
    wVar10 = a->line_num;
    wVar4 = a->number;
    pFVar8 = TraceFP();
    fprintf((FILE *)pFVar8,"->[%d](%d,%d,%d,%d)\n",wVar4,wVar10,(int)sVar2,(int)sVar5,BlankExtent);
  }
  return '\0';
}



// WARNING: Unknown calling convention

void HText_endAnchor(HText *text,wchar_t number)

{
  HText_endAnchor0(text,number,L'\x01');
  return;
}



// WARNING: Unknown calling convention

BOOLEAN HText_isAnchorBlank(HText *text,wchar_t number)

{
  BOOLEAN BVar1;
  
  BVar1 = HText_endAnchor0(text,number,L'\0');
  return BVar1;
}



// WARNING: Unknown calling convention

void HText_appendText(HText *text,char *str)

{
  char *p;
  
  if ((str != (char *)0x0) && (text->halted != L'\x03')) {
    for (p = str; *p != '\0'; p = p + 1) {
      HText_appendCharacter(text,(int)*p);
    }
  }
  return;
}



// WARNING: Unknown calling convention

wchar_t remove_special_attr_chars(char *buf)

{
  char *local_c;
  wchar_t local_8;
  
  local_8 = L'\0';
  for (local_c = buf; *local_c != '\0'; local_c = local_c + 1) {
    local_8 = local_8 + (uint)(*local_c == '\b');
    if ((*local_c < '\x03') || ('\b' < *local_c)) {
      *buf = *local_c;
      buf = buf + 1;
    }
  }
  *buf = '\0';
  return local_8;
}



// WARNING: Unknown calling convention

void HText_endAppend(HText *text)

{
  _line *p_Var1;
  _line *p_Var2;
  HTLine *pHVar3;
  FILE *pFVar4;
  HTLine *next_to_the_last_line;
  HTLine *line_ptr;
  
  if (text != (HText *)0x0) {
    if (WWW_TraceFlag != '\0') {
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"GridText: Entering HText_endAppend\n");
    }
    split_line(text,0);
    if (text->halted == L'\0') {
      if (text->stbl != (STable_info *)0x0) {
        HText_endStblTABLE(text);
      }
    }
    else {
      if (text->stbl != (STable_info *)0x0) {
        HText_cancelStbl(text);
      }
      LYFakeZap('\0');
      text->halted = L'\0';
    }
    p_Var1 = text->last_line->next;
    while ((text->last_line->data[0] == '\0' && (L'\x02' < text->Lines))) {
      p_Var2 = text->last_line->prev;
      if (WWW_TraceFlag != '\0') {
        pHVar3 = text->last_line;
        pFVar4 = TraceFP();
        fprintf((FILE *)pFVar4,"GridText: Removing bottom blank line: `%s\'\n",pHVar3->data);
      }
      p_Var2->next = p_Var1;
      p_Var1->prev = p_Var2;
      text->last_line = p_Var2;
      text->Lines = text->Lines + L'\xffffffff';
      if (WWW_TraceFlag != '\0') {
        pHVar3 = text->last_line;
        pFVar4 = TraceFP();
        fprintf((FILE *)pFVar4,"GridText: New bottom line: `%s\'\n",pHVar3->data);
      }
    }
    HText_trimHightext(text,'\x01',L'\xffffffff');
  }
  return;
}



void HText_trimHightext(HText *text,BOOLEAN final,wchar_t stop_before)

{
  short sVar1;
  short sVar2;
  ushort uVar3;
  wchar_t wVar4;
  HTLine *pHVar5;
  FILE *pFVar6;
  char *pcVar7;
  ushort **ppuVar8;
  size_t sVar9;
  wchar_t wVar10;
  bool bVar11;
  BOOLEAN final_local;
  wchar_t hi_offset;
  char *hi_string;
  HTLine *old_line_ptr2;
  wchar_t size;
  wchar_t anchor_col;
  wchar_t count_line;
  wchar_t actual_len;
  wchar_t hilite_len;
  char *hilite_str;
  HTLine *line_ptr2;
  HTLine *line_ptr;
  TextAnchor *prev_a;
  TextAnchor *anchor_ptr;
  wchar_t cur_shift;
  wchar_t cur_line;
  uchar ch;
  
  prev_a = (TextAnchor *)0x0;
  if (text != (HText *)0x0) {
    if (final == '\0') {
      if ((stop_before < L'\0') || (text->Lines < stop_before)) {
        stop_before = text->Lines;
      }
      if (WWW_TraceFlag != '\0') {
        wVar10 = text->Lines;
        pFVar6 = TraceFP();
        fprintf((FILE *)pFVar6,"GridText: Entering HText_trimHightext (partial: 0..%d/%d)\n",
                stop_before,wVar10);
      }
    }
    else if (WWW_TraceFlag != '\0') {
      pFVar6 = TraceFP();
      fprintf((FILE *)pFVar6,"GridText: Entering HText_trimHightext (final)\n");
    }
    line_ptr = text->last_line->next;
    cur_line = L'\0';
    for (anchor_ptr = text->first_anchor; anchor_ptr != (TextAnchor *)0x0;
        anchor_ptr = anchor_ptr->next) {
      while( true ) {
        for (; cur_line < anchor_ptr->line_num; cur_line = cur_line + L'\x01') {
          line_ptr = line_ptr->next;
        }
        if (final == '\0') {
          if (stop_before <= cur_line) {
            return;
          }
          if ((text->Lines + L'\xffffffff' <= anchor_ptr->line_num) &&
             ((int)(uint)text->last_line->prev->size <= (int)anchor_ptr->line_pos)) {
            return;
          }
          if ((((anchor_ptr->extent == 0) && (anchor_ptr->number != L'\0')) &&
              ((anchor_ptr->link_type & 1U) != 0)) &&
             ((anchor_ptr->show_anchor == '\0' && (anchor_ptr->number == text->last_anchor_number)))
             ) goto LAB_080677e5;
        }
        pcVar7 = LYGetHiTextStr(anchor_ptr,L'\0');
        if (pcVar7 != (char *)0x0) goto LAB_080677e5;
        if ((int)(uint)line_ptr->size < (int)anchor_ptr->line_pos) {
          anchor_ptr->line_pos = line_ptr->size;
        }
        if (anchor_ptr->line_pos < 0) {
          anchor_ptr->line_pos = 0;
          anchor_ptr->line_num = cur_line;
        }
        if (WWW_TraceFlag != '\0') {
          sVar1 = anchor_ptr->extent;
          wVar10 = anchor_ptr->number;
          wVar4 = anchor_ptr->sgml_offset;
          sVar2 = anchor_ptr->line_pos;
          pFVar6 = TraceFP();
          fprintf((FILE *)pFVar6,"GridText: Anchor found on line:%d col:%d [%05d:%d] ext:%d\n",
                  cur_line,(int)sVar2,wVar4,wVar10,(int)sVar1);
        }
        cur_shift = L'\0';
        if ((anchor_ptr->link_type & 1U) != 0) {
          ch = line_ptr->data[anchor_ptr->line_pos];
          while ((ppuVar8 = __ctype_b_loc(), ((*ppuVar8)[ch] & 0x2000) != 0 ||
                 ((2 < ch && (ch < 9))))) {
            anchor_ptr->line_pos = anchor_ptr->line_pos + 1;
            anchor_ptr->extent = anchor_ptr->extent + -1;
            cur_shift = cur_shift + L'\x01';
            ch = line_ptr->data[anchor_ptr->line_pos];
          }
        }
        if (anchor_ptr->extent < 0) {
          anchor_ptr->extent = 0;
        }
        if (WWW_TraceFlag != '\0') {
          pcVar7 = line_ptr->data;
          pFVar6 = TraceFP();
          fprintf((FILE *)pFVar6,"anchor text: \'%s\'\n",pcVar7);
        }
        sVar1 = anchor_ptr->line_pos;
        sVar9 = strlen(line_ptr->data);
        if ((uint)(int)sVar1 < sVar9) goto LAB_080674b9;
        if ((text->Lines <= cur_line) ||
           (((anchor_ptr->extent == 0 && ((int)anchor_ptr->line_pos == (uint)line_ptr->size)) &&
            ((prev_a == (TextAnchor *)0x0 || (prev_a->line_num <= anchor_ptr->line_num)))))) break;
        anchor_ptr->line_num = anchor_ptr->line_num + L'\x01';
        anchor_ptr->line_pos = 0;
        if (WWW_TraceFlag != '\0') {
          pFVar6 = TraceFP();
          fprintf((FILE *)pFVar6,"found anchor at end of line\n");
        }
      }
      if (WWW_TraceFlag != '\0') {
        pFVar6 = TraceFP();
        fprintf((FILE *)pFVar6,"found anchor at end of line, leaving it there\n");
      }
LAB_080674b9:
      if ((anchor_ptr->extent < 1) || (anchor_ptr->line_pos < 0)) {
        LYClearHiText(anchor_ptr);
        LYSetHiText(anchor_ptr,"",L'\0');
      }
      else {
        size = (uint)line_ptr->size - (int)anchor_ptr->line_pos;
        if (anchor_ptr->extent < size) {
          size = (wchar_t)anchor_ptr->extent;
        }
        LYClearHiText(anchor_ptr);
        LYSetHiText(anchor_ptr,line_ptr->data + anchor_ptr->line_pos,size);
      }
      hilite_str = LYGetHiTextStr(anchor_ptr,L'\0');
      hilite_len = strlen(hilite_str);
      actual_len = (wchar_t)anchor_ptr->extent;
      line_ptr2 = line_ptr;
      count_line = cur_line;
      while (hilite_len < actual_len) {
        old_line_ptr2 = line_ptr2;
        count_line = count_line + L'\x01';
        pHVar5 = line_ptr2->next;
        if ((final == '\0') && (stop_before <= count_line)) {
          line_ptr2 = pHVar5;
          LYClearHiText(anchor_ptr);
          break;
        }
        bVar11 = text->last_line == line_ptr2;
        line_ptr2 = pHVar5;
        if (bVar11) break;
        if (pHVar5 != (HTLine *)0x0) {
          hi_string = (char *)0x0;
          uVar3 = pHVar5->offset;
          SNACopy(&hi_string,pHVar5->data,actual_len - hilite_len);
          wVar10 = actual_len;
          sVar9 = strlen(hi_string);
          actual_len = wVar10 - sVar9;
          wVar10 = remove_special_attr_chars(hi_string);
          wVar10 = (uint)uVar3 + wVar10;
          if ((anchor_ptr->link_type & 1U) != 0) {
            LYTrimTrailing(hi_string);
          }
          if ((hi_string == (char *)0x0) || (*hi_string == '\0')) {
            if (hilite_len < actual_len) {
              LYAddHiText(anchor_ptr,"",wVar10);
            }
          }
          else {
            LYAddHiText(anchor_ptr,hi_string,wVar10);
          }
          if (hi_string != (char *)0x0) {
            free(hi_string);
            hi_string = (char *)0x0;
          }
        }
      }
      if ((final == '\0') && (stop_before <= count_line)) {
        return;
      }
      hilite_str = LYGetHiTextStr(anchor_ptr,L'\0');
      remove_special_attr_chars(hilite_str);
      if ((anchor_ptr->link_type & 1U) != 0) {
        LYTrimTrailing(hilite_str);
      }
      anchor_col = (wchar_t)anchor_ptr->line_pos;
      if (0 < anchor_ptr->line_pos) {
        wVar10 = LYstrExtent2(line_ptr->data,anchor_col);
        anchor_ptr->line_pos = (short)wVar10;
        if (line_ptr->data[0] == '\b') {
          anchor_ptr->line_pos = anchor_ptr->line_pos + 1;
        }
      }
      anchor_ptr->line_pos = anchor_ptr->line_pos + line_ptr->offset;
      anchor_ptr->line_num = cur_line;
      if (WWW_TraceFlag != '\0') {
        wVar10 = anchor_ptr->number;
        sVar1 = anchor_ptr->line_pos;
        pFVar6 = TraceFP();
        fprintf((FILE *)pFVar6,"GridText:     add link on line %d col %d [%d] %s\n",cur_line,
                (int)sVar1,wVar10,"in HText_trimHightext");
      }
LAB_080677e5:
      prev_a = anchor_ptr;
    }
  }
  return;
}



// WARNING: Unknown calling convention

HTParentAnchor * HText_nodeAnchor(HText *text)

{
  return text->node_anchor;
}



// WARNING: Unknown calling convention

HTChildAnchor * HText_childNextNumber(wchar_t number,void **prev)

{
  HTChildAnchor *local_18;
  TextAnchor *a;
  
  a = (TextAnchor *)*prev;
  if ((HTMainText == (HText *)0x0) || (number < L'\x01')) {
    local_18 = (HTChildAnchor *)0x0;
  }
  else {
    if ((number == L'\x01') || (a == (TextAnchor *)0x0)) {
      a = HTMainText->first_anchor;
    }
    for (; (a != (TextAnchor *)0x0 && (a->number != number)); a = a->next) {
    }
    if (a == (TextAnchor *)0x0) {
      local_18 = (HTChildAnchor *)0x0;
    }
    else {
      *prev = a;
      local_18 = a->anchor;
    }
  }
  return local_18;
}



// WARNING: Unknown calling convention

void HText_FormDescNumber(wchar_t number,char **desc)

{
  char *pcVar1;
  TextAnchor *a;
  
  if (desc != (char **)0x0) {
    if (((HTMainText == (HText *)0x0) || (HTMainText->first_anchor == (TextAnchor *)0x0)) ||
       (number < L'\x01')) {
      pcVar1 = (char *)gettext("unknown field or link");
      *desc = pcVar1;
    }
    else {
      for (a = HTMainText->first_anchor; a != (TextAnchor *)0x0; a = a->next) {
        if (a->number == number) {
          if ((a->input_field == (FormInfo *)0x0) || (a->input_field->type == L'\0')) {
            pcVar1 = (char *)gettext("unknown field or link");
            *desc = pcVar1;
            return;
          }
          break;
        }
      }
      switch(a->input_field->type) {
      default:
        pcVar1 = (char *)gettext("unknown form field");
        *desc = pcVar1;
        break;
      case L'\x01':
        pcVar1 = (char *)gettext("text entry field");
        *desc = pcVar1;
        break;
      case L'\x02':
        pcVar1 = (char *)gettext("password entry field");
        *desc = pcVar1;
        break;
      case L'\x03':
        pcVar1 = (char *)gettext("checkbox");
        *desc = pcVar1;
        break;
      case L'\x04':
        pcVar1 = (char *)gettext("radio button");
        *desc = pcVar1;
        break;
      case L'\x05':
        pcVar1 = (char *)gettext("submit button");
        *desc = pcVar1;
        break;
      case L'\x06':
        pcVar1 = (char *)gettext("reset button");
        *desc = pcVar1;
        break;
      case L'\a':
        pcVar1 = (char *)gettext("popup menu");
        *desc = pcVar1;
        break;
      case L'\b':
        pcVar1 = (char *)gettext("hidden form field");
        *desc = pcVar1;
        break;
      case L'\t':
        pcVar1 = (char *)gettext("text entry area");
        *desc = pcVar1;
        break;
      case L'\n':
        pcVar1 = (char *)gettext("range entry field");
        *desc = pcVar1;
        break;
      case L'\v':
        pcVar1 = (char *)gettext("file entry field");
        *desc = pcVar1;
        break;
      case L'\f':
        pcVar1 = (char *)gettext("text-submit field");
        *desc = pcVar1;
        break;
      case L'\r':
        pcVar1 = (char *)gettext("image-submit button");
        *desc = pcVar1;
        break;
      case L'\x0e':
        pcVar1 = (char *)gettext("keygen field");
        *desc = pcVar1;
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

wchar_t HTGetRelLinkNum(wchar_t num,wchar_t rel,wchar_t cur)

{
  wchar_t wVar1;
  int iVar2;
  wchar_t wVar3;
  wchar_t wVar4;
  bool bVar5;
  HText *pHVar6;
  int iVar7;
  wchar_t wVar8;
  FILE *pFVar9;
  char *local_38;
  wchar_t local_34;
  wchar_t local_30;
  wchar_t curanchor;
  wchar_t on_screen;
  wchar_t curpos;
  wchar_t curline;
  wchar_t scrtop;
  TextAnchor *l;
  TextAnchor *a;
  
  l = (TextAnchor *)0x0;
  wVar8 = HText_getTopOfScreen();
  pHVar6 = HTMainText;
  wVar1 = links[cur].anchor_line_num;
  iVar2 = links[cur].lx;
  if ((wVar1 < wVar8) || (display_lines + wVar8 <= wVar1)) {
    bVar5 = false;
  }
  else {
    bVar5 = true;
  }
  curanchor = links[cur].anchor_number;
  if (WWW_TraceFlag != '\0') {
    pFVar9 = TraceFP();
    fprintf((FILE *)pFVar9,"HTGetRelLinkNum(%d,%d,%d) -- HTMainText=%p\n",num,rel,cur,pHVar6);
  }
  iVar7 = display_lines;
  if (WWW_TraceFlag != '\0') {
    if (bVar5) {
      local_38 = "on_screen";
    }
    else {
      local_38 = "0";
    }
    pFVar9 = TraceFP();
    fprintf((FILE *)pFVar9,"  scrtop=%d, curline=%d, curanchor=%d, display_lines=%d, %s\n",wVar8,
            wVar1,curanchor,iVar7,local_38);
  }
  if (HTMainText == (HText *)0x0) {
    local_34 = L'\0';
  }
  else if (rel == L'\0') {
    local_34 = num;
  }
  else if ((bVar5) && (curanchor != L'\0')) {
    if (WWW_TraceFlag != '\0') {
      pFVar9 = TraceFP();
      fprintf((FILE *)pFVar9,"curanchor=%d at line %d on screen\n",curanchor,wVar1);
    }
    if (rel == L'+') {
      local_34 = curanchor + num;
    }
    else if (rel == L'-') {
      local_34 = curanchor - num;
    }
    else {
      local_34 = num;
    }
  }
  else {
    for (a = HTMainText->first_anchor; a != (TextAnchor *)0x0; a = a->next) {
      if (WWW_TraceFlag != '\0') {
        wVar3 = a->number;
        wVar4 = a->line_num;
        pFVar9 = TraceFP();
        fprintf((FILE *)pFVar9,"  a->line_num=%d, a->number=%d\n",wVar4,wVar3);
      }
      if (wVar8 <= a->line_num) break;
      if (a->number != L'\0') {
        l = a;
        curanchor = a->number;
      }
    }
    if (WWW_TraceFlag != '\0') {
      pFVar9 = TraceFP();
      fprintf((FILE *)pFVar9,"  a=%p, l=%p, curanchor=%d\n",a,l,curanchor);
    }
    if (bVar5) {
      for (; a != (TextAnchor *)0x0; a = a->next) {
        if (a->number != L'\0') {
          l = a;
          curanchor = a->number;
        }
        if ((a->line_num == wVar1) && (a->line_pos == iVar2)) break;
      }
    }
    if (rel == L'+') {
      local_34 = curanchor + num;
    }
    else if (rel == L'-') {
      if (l == (TextAnchor *)0x0) {
        for (; (a != (TextAnchor *)0x0 && (a->number == L'\0')); a = a->next) {
        }
        if (a == (TextAnchor *)0x0) {
          local_30 = L'\0';
        }
        else {
          local_30 = a->number - num;
        }
        local_34 = local_30;
      }
      else {
        local_34 = (curanchor + L'\x01') - num;
      }
    }
    else {
      local_34 = num;
    }
  }
  return local_34;
}



// WARNING: Removing unreachable block (ram,0x08067f39)
// WARNING: Unknown calling convention

wchar_t HTGetLinkInfo(wchar_t number,wchar_t want_go,wchar_t *go_line,wchar_t *linknum,
                     char **hightext,char **lname)

{
  char *pcVar1;
  HTAnchor *me;
  char *cp_freeme;
  wchar_t max_offset;
  wchar_t prev_prev_anchor_line;
  wchar_t prev_anchor_line;
  wchar_t anchors_this_screen;
  wchar_t anchors_this_line;
  HTAnchor *link_dest;
  TextAnchor *a;
  
  anchors_this_line = L'\0';
  anchors_this_screen = L'\0';
  prev_anchor_line = L'\xffffffff';
  prev_prev_anchor_line = L'\xffffffff';
  if (HTMainText != (HText *)0x0) {
    for (a = HTMainText->first_anchor; a != (TextAnchor *)0x0; a = a->next) {
      if ((a->show_anchor != '\0') && ((a->link_type != '\x02' || (a->input_field->type != L'\b'))))
      {
        if (a->line_num == prev_anchor_line) {
          anchors_this_line = anchors_this_line + L'\x01';
        }
        else {
          anchors_this_line = L'\x01';
          prev_prev_anchor_line = prev_anchor_line;
          prev_anchor_line = a->line_num;
        }
        if (HTMainText->top_of_screen <= a->line_num) {
          anchors_this_screen = anchors_this_screen + L'\x01';
        }
      }
      if (a->number == number) {
        if ((want_go == L'\0') && (a->link_type != '\x02')) {
          pcVar1 = LYGetHiTextStr(a,L'\0');
          *hightext = pcVar1;
          me = HTAnchor_followLink(a->anchor);
          if (traversal == '\0') {
            cp_freeme = HTAnchor_address(me);
          }
          else {
            cp_freeme = stub_HTAnchor_address(me);
          }
          HTSACopy(lname,cp_freeme);
          if (cp_freeme != (char *)0x0) {
            free(cp_freeme);
          }
          return L'\x02';
        }
        if (a->show_anchor != '\0') {
          if ((((anchors_this_screen < L'\x01') || (nlinks < anchors_this_screen)) ||
              (a->line_num < HTMainText->top_of_screen)) ||
             (HTMainText->top_of_screen + display_lines <= a->line_num)) {
            max_offset = L'\x03';
            if (display_lines < 4) {
              max_offset = display_lines + L'\xffffffff';
            }
            *go_line = prev_anchor_line - max_offset;
            if (*go_line <= prev_prev_anchor_line) {
              *go_line = prev_prev_anchor_line + L'\x01';
            }
            if (*go_line < L'\0') {
              *go_line = L'\0';
            }
            if (linknum != (wchar_t *)0x0) {
              *linknum = anchors_this_line + L'\xffffffff';
            }
          }
          else {
            *go_line = HTMainText->top_of_screen;
            if (linknum != (wchar_t *)0x0) {
              *linknum = anchors_this_screen + L'\xffffffff';
            }
          }
          return L'\b';
        }
        return L'\0';
      }
    }
  }
  return L'\0';
}



BOOLEAN same_anchor_or_field
                  (wchar_t numberA,FormInfo *formA,wchar_t numberB,FormInfo *formB,BOOLEAN ta_same)

{
  int iVar1;
  bool local_9;
  BOOLEAN ta_same_local;
  
  if ((L'\0' < numberA) || (L'\0' < numberB)) {
    if (numberA == numberB) {
      return '\x01';
    }
    if (ta_same == '\0') {
      return '\0';
    }
  }
  if ((formA == (FormInfo *)0x0) && (formB == (FormInfo *)0x0)) {
    local_9 = false;
  }
  else if (formA == formB) {
    local_9 = true;
  }
  else if (ta_same == '\0') {
    local_9 = false;
  }
  else if ((formA == (FormInfo *)0x0) || (formB == (FormInfo *)0x0)) {
    local_9 = false;
  }
  else if (((formA->type == formB->type) && (formA->type == L'\t')) && (formB->type == L'\t')) {
    if (formA->number == formB->number) {
      if ((formA->name == (char *)0x0) || (formB->name == (char *)0x0)) {
        local_9 = true;
      }
      else {
        iVar1 = strcmp(formA->name,formB->name);
        local_9 = iVar1 == 0;
      }
    }
    else {
      local_9 = false;
    }
  }
  else {
    local_9 = false;
  }
  return local_9;
}



// WARNING: Unknown calling convention

BOOLEAN HText_TAHasMoreLines(wchar_t curlink,wchar_t direction)

{
  BOOLEAN BVar1;
  FormInfo *local_30;
  FormInfo *local_28;
  FormInfo *local_20;
  FormInfo *local_18;
  TextAnchor *prev_a;
  TextAnchor *a;
  
  prev_a = (TextAnchor *)0x0;
  if (HTMainText != (HText *)0x0) {
    if (direction < L'\0') {
      for (a = HTMainText->first_anchor; a != (TextAnchor *)0x0; a = a->next) {
        if ((a->link_type == '\x02') && ((FormInfo *)links[curlink].l_form == a->input_field)) {
          if ((a != (TextAnchor *)0x0) && (prev_a != (TextAnchor *)0x0)) {
            if (prev_a->link_type == '\x02') {
              local_30 = prev_a->input_field;
            }
            else {
              local_30 = (FormInfo *)0x0;
            }
            if (a->link_type == '\x02') {
              local_28 = a->input_field;
            }
            else {
              local_28 = (FormInfo *)0x0;
            }
            BVar1 = same_anchor_or_field(a->number,local_28,prev_a->number,local_30,'\x01');
            if (BVar1 != '\0') {
              return '\x01';
            }
          }
          return '\0';
        }
        if ((links[curlink].anchor_number != 0) && (links[curlink].anchor_number <= a->number)) {
          return '\0';
        }
        prev_a = a;
      }
    }
    else {
      for (a = HTMainText->first_anchor; a != (TextAnchor *)0x0; a = a->next) {
        if ((a->link_type == '\x02') && ((FormInfo *)links[curlink].l_form == a->input_field)) {
          if ((a != (TextAnchor *)0x0) && (a->next != (_TextAnchor *)0x0)) {
            if (a->next->link_type == '\x02') {
              local_20 = a->next->input_field;
            }
            else {
              local_20 = (FormInfo *)0x0;
            }
            if (a->link_type == '\x02') {
              local_18 = a->input_field;
            }
            else {
              local_18 = (FormInfo *)0x0;
            }
            BVar1 = same_anchor_or_field(a->number,local_18,a->next->number,local_20,'\x01');
            if (BVar1 != '\0') {
              return '\x01';
            }
          }
          return '\0';
        }
        if ((links[curlink].anchor_number != 0) && (links[curlink].anchor_number <= a->number)) {
          return '\0';
        }
      }
    }
  }
  return '\0';
}



wchar_t HTGetLinkOrFieldStart
                  (wchar_t curlink,wchar_t *go_line,wchar_t *linknum,wchar_t direction,
                  BOOLEAN ta_skip)

{
  TextAnchor *pTVar1;
  BOOLEAN BVar2;
  wchar_t local_80;
  FormInfo *local_78;
  FormInfo *local_70;
  FormInfo *local_68;
  FormInfo *local_60;
  FormInfo *local_58;
  FormInfo *local_50;
  BOOLEAN ta_skip_local;
  agroup current;
  agroup previous;
  wchar_t screensahead;
  wchar_t screensback;
  wchar_t max_offset;
  agroup *group_to_go;
  wchar_t prev_prev_anchor_line;
  wchar_t prev_anchor_line;
  wchar_t anchors_this_line;
  TextAnchor *a;
  
  anchors_this_line = L'\0';
  prev_anchor_line = L'\xffffffff';
  prev_prev_anchor_line = L'\xffffffff';
  group_to_go = (agroup *)0x0;
  if (HTMainText == (HText *)0x0) {
    local_80 = L'\0';
  }
  else {
    current.anc = (TextAnchor *)0x0;
    previous.anc = (TextAnchor *)0x0;
    current.prev_anchor_line = L'\xffffffff';
    previous.prev_anchor_line = L'\xffffffff';
    current.anchors_this_line = L'\0';
    previous.anchors_this_line = L'\0';
    current.anchors_this_group = L'\0';
    previous.anchors_this_group = L'\0';
    for (a = HTMainText->first_anchor; a != (TextAnchor *)0x0; a = a->next) {
      if ((a->show_anchor != '\0') && ((a->link_type != '\x02' || (a->input_field->type != L'\b'))))
      {
        if (a->line_num == prev_anchor_line) {
          anchors_this_line = anchors_this_line + L'\x01';
        }
        else {
          anchors_this_line = L'\x01';
          prev_prev_anchor_line = prev_anchor_line;
          prev_anchor_line = a->line_num;
        }
        if ((current.anc == (TextAnchor *)0x0) || (a == (TextAnchor *)0x0)) {
LAB_0806854c:
          previous.anc = current.anc;
          previous.prev_anchor_line = current.prev_anchor_line;
          previous.anchors_this_line = current.anchors_this_line;
          previous.anchors_this_group = current.anchors_this_group;
          current.anc = a;
          current.prev_anchor_line = prev_prev_anchor_line;
          current.anchors_this_line = anchors_this_line;
          current.anchors_this_group = L'\x01';
        }
        else {
          if (a->link_type == '\x02') {
            local_78 = a->input_field;
          }
          else {
            local_78 = (FormInfo *)0x0;
          }
          if ((current.anc)->link_type == '\x02') {
            local_70 = (current.anc)->input_field;
          }
          else {
            local_70 = (FormInfo *)0x0;
          }
          BVar2 = same_anchor_or_field((current.anc)->number,local_70,a->number,local_78,ta_skip);
          if (BVar2 == '\0') goto LAB_0806854c;
          current.anchors_this_group = current.anchors_this_group + L'\x01';
        }
        if (curlink < L'\0') {
          if (HTMainText->top_of_screen <= a->line_num) {
            if (direction < L'\0') {
              group_to_go = &previous;
            }
            else if (direction == L'\0') {
              if (previous.anc == (TextAnchor *)0x0) {
                group_to_go = &current;
              }
              else {
                group_to_go = &previous;
              }
            }
            else {
              group_to_go = &current;
            }
            break;
          }
        }
        else {
          if ((L'\xffffffff' < curlink) && (a != (TextAnchor *)0x0)) {
            if (a->link_type == '\x02') {
              local_68 = a->input_field;
            }
            else {
              local_68 = (FormInfo *)0x0;
            }
            if (links[curlink].type == 1) {
              local_60 = (FormInfo *)links[curlink].l_form;
            }
            else {
              local_60 = (FormInfo *)0x0;
            }
            BVar2 = same_anchor_or_field
                              (links[curlink].anchor_number,local_60,a->number,local_68,ta_skip);
            if (BVar2 != '\0') {
              if (direction == L'\xffffffff') {
                group_to_go = &previous;
              }
              else {
                if (direction != L'\0') goto LAB_08068779;
                group_to_go = &current;
              }
              break;
            }
          }
          if (((L'\0' < direction) && (L'\xffffffff' < curlink)) &&
             (previous.anc != (TextAnchor *)0x0)) {
            if ((previous.anc)->link_type == '\x02') {
              local_58 = (previous.anc)->input_field;
            }
            else {
              local_58 = (FormInfo *)0x0;
            }
            if (links[curlink].type == 1) {
              local_50 = (FormInfo *)links[curlink].l_form;
            }
            else {
              local_50 = (FormInfo *)0x0;
            }
            BVar2 = same_anchor_or_field
                              (links[curlink].anchor_number,local_50,(previous.anc)->number,local_58
                               ,ta_skip);
            if (BVar2 != '\0') {
              group_to_go = &current;
              break;
            }
          }
        }
      }
LAB_08068779:
    }
    if (((group_to_go == (agroup *)0x0) && (curlink < L'\0')) && (direction < L'\x01')) {
      group_to_go = &current;
    }
    if ((group_to_go == (agroup *)0x0) || (pTVar1 = group_to_go->anc, pTVar1 == (TextAnchor *)0x0))
    {
      local_80 = L'\0';
    }
    else if (((pTVar1->line_num < HTMainText->top_of_screen) &&
             (HTMainText->top_of_screen - display_lines <= pTVar1->line_num)) &&
            ((((curlink < L'\0' && (group_to_go->anchors_this_group == L'\x01')) ||
              ((((direction < L'\0' && (group_to_go != &current)) &&
                (current.anc != (TextAnchor *)0x0)) &&
               ((HTMainText->top_of_screen <= (current.anc)->line_num &&
                (group_to_go->anchors_this_group == L'\x01')))))) ||
             ((pTVar1->next != (_TextAnchor *)0x0 &&
              (HTMainText->top_of_screen <= pTVar1->next->line_num)))))) {
      local_80 = L'\x10';
    }
    else {
      if (display_lines < pTVar1->line_num) {
        if (pTVar1->line_num < HTMainText->top_of_screen) {
          max_offset = pTVar1->line_num +
                       (display_lines *
                        (((HTMainText->top_of_screen - pTVar1->line_num) + display_lines + -1) /
                        display_lines) - HTMainText->top_of_screen);
        }
        else if (display_lines < HTMainText->Lines - pTVar1->line_num) {
          if (pTVar1->line_num < HTMainText->top_of_screen + display_lines) {
            max_offset = L'\x03';
          }
          else {
            max_offset = (pTVar1->line_num - HTMainText->top_of_screen) -
                         display_lines *
                         ((pTVar1->line_num - HTMainText->top_of_screen) / display_lines);
          }
        }
        else {
          max_offset = pTVar1->line_num + ~HTMainText->Lines + display_lines;
        }
      }
      else {
        max_offset = L'\0';
      }
      if (max_offset < L'\0') {
        max_offset = L'\0';
      }
      else if (display_lines <= max_offset) {
        max_offset = display_lines + L'\xffffffff';
      }
      *go_line = pTVar1->line_num - max_offset;
      if (*go_line <= group_to_go->prev_anchor_line) {
        *go_line = group_to_go->prev_anchor_line + L'\x01';
      }
      if (*go_line < L'\0') {
        *go_line = L'\0';
      }
      if (linknum != (wchar_t *)0x0) {
        *linknum = group_to_go->anchors_this_line + L'\xffffffff';
      }
      local_80 = L'\b';
    }
  }
  return local_80;
}



BOOLEAN HText_getFirstTargetInLine
                  (HText *text,wchar_t line_num,BOOLEAN utf_flag,wchar_t *offset,wchar_t *tLen,
                  char **data,char *target)

{
  char *local_34;
  int local_2c;
  BOOLEAN utf_flag_local;
  char *cp;
  wchar_t i;
  wchar_t LenNeeded;
  wchar_t HitOffset;
  wchar_t LineOffset;
  char *LineData;
  HTLine *line;
  
  if ((((text != (HText *)0x0) && (L'\xffffffff' < line_num)) && (line_num <= text->Lines)) &&
     ((target != (char *)0x0 && (*target != '\0')))) {
    i = L'\0';
    for (line = text->last_line->next; (i < line_num && (text->last_line != line));
        line = line->next) {
      if (line->next == (_line *)0x0) {
        return '\0';
      }
      i = i + L'\x01';
    }
    if ((line != (HTLine *)0x0) || (cRam00000012 == '\0')) {
      LineData = line->data;
      LineOffset = (wchar_t)line->offset;
      if (case_sensitive == '\0') {
        local_34 = LYno_attr_mbcs_case_strstr(LineData,target,utf_flag,'\x01',&HitOffset,&LenNeeded)
        ;
      }
      else {
        local_34 = LYno_attr_mbcs_strstr(LineData,target,utf_flag,'\x01',&HitOffset,&LenNeeded);
      }
      if (local_34 != (char *)0x0) {
        if (LYwideLines == L'\0') {
          local_2c = LYcols;
        }
        else {
          local_2c = 0x3f6;
        }
        if (LineOffset + LenNeeded <= local_2c) {
          *offset = HitOffset + LineOffset;
          *tLen = LenNeeded - HitOffset;
          HTSACopy(data,local_34);
          remove_special_attr_chars(*data);
          return '\x01';
        }
      }
    }
  }
  return '\0';
}



// WARNING: Unknown calling convention

wchar_t HText_getNumOfLines(void)

{
  wchar_t local_8;
  
  if (HTMainText == (HText *)0x0) {
    local_8 = L'\0';
  }
  else {
    local_8 = HTMainText->Lines;
  }
  return local_8;
}



// WARNING: Unknown calling convention

wchar_t HText_getNumOfBytes(void)

{
  size_t sVar1;
  HTLine *line;
  wchar_t result;
  
  result = L'\xffffffff';
  if (HTMainText != (HText *)0x0) {
    for (line = HTMainText->last_line->next; HTMainText->last_line != line; line = line->next) {
      sVar1 = strlen(line->data);
      result = sVar1 + result + L'\x01';
    }
  }
  return result;
}



// WARNING: Unknown calling convention

char * HText_getTitle(void)

{
  char *local_8;
  
  if (HTMainText == (HText *)0x0) {
    local_8 = (char *)0x0;
  }
  else {
    local_8 = HTAnchor_title(HTMainText->node_anchor);
  }
  return local_8;
}



// WARNING: Unknown calling convention

char * HText_getStyle(void)

{
  char *local_8;
  
  if (HTMainText == (HText *)0x0) {
    local_8 = (char *)0x0;
  }
  else {
    local_8 = HTAnchor_style(HTMainText->node_anchor);
  }
  return local_8;
}



// WARNING: Unknown calling convention

char * HText_getSugFname(void)

{
  char *local_8;
  
  if (HTMainText == (HText *)0x0) {
    local_8 = (char *)0x0;
  }
  else {
    local_8 = HTAnchor_SugFname(HTMainText->node_anchor);
  }
  return local_8;
}



void HTCheckFnameForCompression(char **fname,HTParentAnchor *anchor,BOOLEAN strip_ok)

{
  int iVar1;
  CompressFileType CVar2;
  BOOLEAN strip_ok_local;
  wchar_t rootlen;
  CompressFileType second;
  CompressFileType method;
  char *suffix;
  char *cp;
  char *dot;
  char *fn;
  
  fn = *fname;
  dot = (char *)0x0;
  cp = (char *)0x0;
  suffix = "";
  if ((((fn != (char *)0x0) && (anchor != (HTParentAnchor *)0x0)) &&
      (fn = LYPathLeaf(fn), *fn != '\0')) &&
     ((method = HTContentToCompressType(anchor), method != cftNone || (strip_ok != '\0')))) {
    dot = strrchr(fn,0x2e);
    if ((dot != (char *)0x0) && (iVar1 = strcasecomp(dot,".tgz"), iVar1 == 0)) {
      if (method != cftNone) {
        return;
      }
      memcpy(dot,&DAT_0814d991,5);
      return;
    }
    dot = strrchr(fn,0x2e);
    if (dot != (char *)0x0) {
      rootlen = L'\0';
      CVar2 = HTCompressFileType(fn,".",&rootlen);
      if (CVar2 != cftNone) {
        if (method != cftNone) {
          return;
        }
        *dot = '\0';
        return;
      }
      second = HTCompressFileType(fn,"-_",&rootlen);
      if (second != cftNone) {
        cp = fn + rootlen;
        if (method == cftNone) {
          if (dot + 1 == cp) {
            cp = cp + -1;
          }
          *cp = '\0';
          return;
        }
        *cp = '.';
        if (second == cftCompress) {
          LYUpperCase(cp);
          return;
        }
        LYLowerCase(cp);
        return;
      }
    }
    suffix = HTCompressTypeToSuffix(method);
    if (*suffix != '\0') {
      if (dot == (char *)0x0) {
        HTSACat(fname,suffix);
      }
      else {
        dot = dot + 1;
        if (*dot == '\0') {
          HTSACat(fname,suffix + 1);
        }
        else {
          HTSACat(fname,suffix);
        }
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

char * HText_getLastModified(void)

{
  char *local_8;
  
  if (HTMainText == (HText *)0x0) {
    local_8 = (char *)0x0;
  }
  else {
    local_8 = HTAnchor_last_modified(HTMainText->node_anchor);
  }
  return local_8;
}



// WARNING: Unknown calling convention

char * HText_getDate(void)

{
  char *local_8;
  
  if (HTMainText == (HText *)0x0) {
    local_8 = (char *)0x0;
  }
  else {
    local_8 = HTAnchor_date(HTMainText->node_anchor);
  }
  return local_8;
}



// WARNING: Unknown calling convention

char * HText_getServer(void)

{
  char *local_8;
  
  if (HTMainText == (HText *)0x0) {
    local_8 = (char *)0x0;
  }
  else {
    local_8 = HTAnchor_server(HTMainText->node_anchor);
  }
  return local_8;
}



// WARNING: Unknown calling convention

void HText_pageDisplay(wchar_t line_num,char *target)

{
  FILE *pFVar1;
  wchar_t stop_before;
  
  if (((debug_display_partial != '\0') || (LYTraceLogFP != (FILE *)0x0)) && (WWW_TraceFlag != '\0'))
  {
    pFVar1 = TraceFP();
    fprintf((FILE *)pFVar1,"GridText: HText_pageDisplay at line %d started\n",line_num);
  }
  if (display_partial != '\0') {
    stop_before = L'\xffffffff';
    if ((HTMainText != (HText *)0x0) && (HTMainText->stbl != (STable_info *)0x0)) {
      stop_before = Stbl_getStartLineDeep(HTMainText->stbl);
    }
    HText_trimHightext(HTMainText,'\0',stop_before);
  }
  display_page(HTMainText,line_num + L'\xffffffff',target);
  if ((display_partial != '\0') && (debug_display_partial != '\0')) {
    LYSleepMsg();
  }
  is_www_index = HTAnchor_isIndex(HTMainAnchor);
  if (((debug_display_partial != '\0') || (LYTraceLogFP != (FILE *)0x0)) && (WWW_TraceFlag != '\0'))
  {
    pFVar1 = TraceFP();
    fprintf((FILE *)pFVar1,"GridText: HText_pageDisplay finished\n");
  }
  return;
}



// WARNING: Unknown calling convention

BOOLEAN HText_pageHasPrevTarget(void)

{
  BOOLEAN local_5;
  
  if (HTMainText == (HText *)0x0) {
    local_5 = '\0';
  }
  else {
    local_5 = HTMainText->page_has_target;
  }
  return local_5;
}



// WARNING: Unknown calling convention

wchar_t HText_closestAnchor(HText *text,wchar_t offset)

{
  wchar_t wVar1;
  uint uVar2;
  uint uVar3;
  TextAnchor *closest;
  TextAnchor *Anchor_ptr;
  wchar_t newdiff;
  wchar_t absdiff;
  wchar_t result;
  
  result = L'\xffffffff';
  absdiff = L'\0';
  closest = (TextAnchor *)0x0;
  Anchor_ptr = text->first_anchor;
  do {
    if (Anchor_ptr == (TextAnchor *)0x0) {
LAB_08069180:
      if ((result < L'\0') && (closest != (TextAnchor *)0x0)) {
        result = closest->number;
      }
      return result;
    }
    if (Anchor_ptr->sgml_offset == offset) {
      result = Anchor_ptr->number;
      goto LAB_08069180;
    }
    uVar2 = Anchor_ptr->sgml_offset - offset;
    uVar3 = (int)uVar2 >> 0x1f;
    wVar1 = (uVar2 ^ uVar3) - uVar3;
    if ((absdiff == L'\0') || (wVar1 < absdiff)) {
      closest = Anchor_ptr;
      absdiff = wVar1;
    }
    Anchor_ptr = Anchor_ptr->next;
  } while( true );
}



// WARNING: Unknown calling convention

wchar_t HText_locateAnchor(HText *text,wchar_t anchor_number)

{
  TextAnchor *Anchor_ptr;
  wchar_t result;
  
  Anchor_ptr = text->first_anchor;
  while( true ) {
    if (Anchor_ptr == (TextAnchor *)0x0) {
      return L'\xffffffff';
    }
    if (Anchor_ptr->number == anchor_number) break;
    Anchor_ptr = Anchor_ptr->next;
  }
  return Anchor_ptr->sgml_offset;
}



// WARNING: Unknown calling convention

BOOLEAN anchor_is_numbered(TextAnchor *Anchor_ptr)

{
  BOOLEAN result;
  
  result = '\0';
  if ((Anchor_ptr->show_anchor == '\0') || ((Anchor_ptr->link_type & 1U) != 1)) {
    if ((Anchor_ptr->link_type == '\x02') && (Anchor_ptr->input_field->type != L'\b')) {
      result = '\x01';
    }
  }
  else {
    result = '\x01';
  }
  return result;
}



// WARNING: Unknown calling convention

wchar_t HText_getAbsLineNumber(HText *text,wchar_t anchor_number)

{
  BOOLEAN BVar1;
  TextAnchor *Anchor_ptr;
  wchar_t result;
  
  if ((L'\xffffffff' < anchor_number) && (text != (HText *)0x0)) {
    for (Anchor_ptr = text->first_anchor; Anchor_ptr != (TextAnchor *)0x0;
        Anchor_ptr = Anchor_ptr->next) {
      BVar1 = anchor_is_numbered(Anchor_ptr);
      if ((BVar1 != '\0') && (Anchor_ptr->number == anchor_number)) {
        return Anchor_ptr->line_num;
      }
    }
  }
  return L'\xffffffff';
}



// WARNING: Unknown calling convention

wchar_t HText_anchorRelativeTo(HText *text,wchar_t top_lineno,wchar_t anchor_number)

{
  BOOLEAN BVar1;
  TextAnchor *Anchor_ptr;
  wchar_t from_top;
  wchar_t result;
  
  from_top = L'\0';
  Anchor_ptr = text->first_anchor;
  while( true ) {
    if (Anchor_ptr == (TextAnchor *)0x0) {
      return L'\0';
    }
    if (Anchor_ptr->number == anchor_number) break;
    BVar1 = anchor_is_numbered(Anchor_ptr);
    if ((BVar1 != '\0') && (top_lineno <= Anchor_ptr->line_num)) {
      from_top = from_top + L'\x01';
    }
    Anchor_ptr = Anchor_ptr->next;
  }
  return from_top;
}



// WARNING: Unknown calling convention

wchar_t HText_LinksInLines(HText *text,wchar_t line_num,wchar_t Lines)

{
  wchar_t wVar1;
  wchar_t local_18;
  TextAnchor *Anchor_ptr;
  wchar_t end;
  wchar_t start;
  wchar_t total;
  
  total = L'\0';
  wVar1 = line_num + L'\xffffffff' + Lines;
  if (text == (HText *)0x0) {
    local_18 = L'\0';
  }
  else {
    for (Anchor_ptr = text->first_anchor;
        (Anchor_ptr != (TextAnchor *)0x0 && (Anchor_ptr->line_num <= wVar1));
        Anchor_ptr = Anchor_ptr->next) {
      if (((line_num + L'\xffffffff' <= Anchor_ptr->line_num) &&
          ((Anchor_ptr->line_num < wVar1 && (Anchor_ptr->show_anchor != '\0')))) &&
         ((Anchor_ptr->link_type != '\x02' || (Anchor_ptr->input_field->type != L'\b')))) {
        total = total + L'\x01';
      }
    }
    local_18 = total;
  }
  return local_18;
}



// WARNING: Unknown calling convention

void HText_setStale(HText *text)

{
  text->stale = '\x01';
  return;
}



// WARNING: Unknown calling convention

void HText_refresh(HText *text)

{
  if (text->stale != '\0') {
    display_page(text,text->top_of_screen,"");
  }
  return;
}



// WARNING: Unknown calling convention

wchar_t HText_sourceAnchors(HText *text)

{
  wchar_t local_8;
  
  if (text == (HText *)0x0) {
    local_8 = L'\xffffffff';
  }
  else {
    local_8 = text->last_anchor_number;
  }
  return local_8;
}



// WARNING: Unknown calling convention

BOOLEAN HText_canScrollUp(HText *text)

{
  return text->top_of_screen != L'\0';
}



// WARNING: Unknown calling convention

BOOLEAN HText_canScrollDown(void)

{
  BOOLEAN local_18;
  HText *text;
  
  if ((HTMainText == (HText *)0x0) ||
     (HTMainText->Lines < HTMainText->top_of_screen + display_lines)) {
    local_18 = '\0';
  }
  else {
    local_18 = '\x01';
  }
  return local_18;
}



// WARNING: Unknown calling convention

void HText_scrollTop(HText *text)

{
  display_page(text,L'\0',"");
  return;
}



// WARNING: Unknown calling convention

void HText_scrollDown(HText *text)

{
  display_page(text,text->top_of_screen + display_lines,"");
  return;
}



// WARNING: Unknown calling convention

void HText_scrollUp(HText *text)

{
  display_page(text,text->top_of_screen - display_lines,"");
  return;
}



// WARNING: Unknown calling convention

void HText_scrollBottom(HText *text)

{
  display_page(text,text->Lines - display_lines,"");
  return;
}



// WARNING: Unknown calling convention

BOOLEAN HText_select(HText *text)

{
  BOOLEAN BVar1;
  
  if (text != HTMainText) {
    if (text != (HText *)0x0) {
      text->page_has_target = '\0';
    }
    ResetPartialLinenos(text);
    ResetPartialLinenos(HTMainText);
    if (HTMainText != (HText *)0x0) {
      BVar1 = HText_hasUTF8OutputSet(HTMainText);
      if (((BVar1 == '\0') || (BVar1 = HTLoadedDocumentEightbit(), BVar1 == '\0')) ||
         (LYCharSet_UC[current_char_set].enc != 7)) {
        text->had_utf8 = '\0';
      }
      else {
        text->had_utf8 = HTMainText->has_utf8;
      }
      HTMainText->has_utf8 = '\0';
      text->has_utf8 = '\0';
    }
    HTMainText = text;
    HTMainAnchor = text->node_anchor;
    if ((loaded_texts != (HTList *)0x0) &&
       (BVar1 = HTList_removeObject(loaded_texts,text), BVar1 != '\0')) {
      HTList_addObject(loaded_texts,text);
    }
    return '\x01';
  }
  return '\x01';
}



// WARNING: Unknown calling convention

BOOLEAN HText_POSTReplyLoaded(DocInfo *doc)

{
  char cVar1;
  bstring_conflict *a;
  char *__s1;
  BOOLEAN BVar2;
  int iVar3;
  BOOLEAN local_29;
  int *local_28;
  char *address;
  bstring_conflict *post_data;
  HTList *cur;
  HText *text;
  BOOLEAN is_head;
  
  cur = loaded_texts;
  if ((loaded_texts == (HTList *)0x0) || (doc == (DocInfo *)0x0)) {
    local_29 = '\0';
  }
  else {
    a = doc->post_data;
    if ((a == (bstring_conflict *)0x0) || (__s1 = doc->address, __s1 == (char *)0x0)) {
      local_29 = '\0';
    }
    else {
      cVar1 = doc->isHEAD;
      do {
        if ((cur == (HTList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
          local_28 = (int *)0x0;
        }
        else {
          local_28 = (int *)cur->object;
        }
        if (local_28 == (int *)0x0) {
          return '\0';
        }
      } while ((((*local_28 == 0) || (*(int *)(*local_28 + 0x14) == 0)) ||
               (BVar2 = HTSABEql((bstring *)a,*(bstring **)(*local_28 + 0x14)), BVar2 == '\0')) ||
              (((*(int *)(*local_28 + 0x10) == 0 ||
                (iVar3 = strcmp(__s1,*(char **)(*local_28 + 0x10)), iVar3 != 0)) ||
               (*(char *)(*local_28 + 0x55) != cVar1))));
      local_29 = '\x01';
    }
  }
  return local_29;
}



// WARNING: Unknown calling convention

BOOLEAN HTFindPoundSelector(char *selector)

{
  wchar_t wVar1;
  FILE *pFVar2;
  int iVar3;
  TextAnchor *a;
  
  if (WWW_TraceFlag != '\0') {
    pFVar2 = TraceFP();
    fprintf((FILE *)pFVar2,"FindPound: searching for \"%s\"\n",selector);
  }
  a = HTMainText->first_anchor;
  while( true ) {
    if (a == (TextAnchor *)0x0) {
      return '\0';
    }
    if (((a->anchor != (HTChildAnchor *)0x0) && (a->anchor->tag != (char *)0x0)) &&
       (iVar3 = strcmp(a->anchor->tag,selector), iVar3 == 0)) break;
    a = a->next;
  }
  iVar3 = a->line_num + L'\x01';
  www_search_result = iVar3;
  if (WWW_TraceFlag != '\0') {
    wVar1 = a->number;
    pFVar2 = TraceFP();
    fprintf((FILE *)pFVar2,"FindPound: Selecting anchor [%d] at line %d\n",wVar1,iVar3);
  }
  iVar3 = strcmp(selector,LYToolbarName);
  if (iVar3 == 0) {
    www_search_result = www_search_result + -1;
  }
  return '\x01';
}



// WARNING: Unknown calling convention

BOOLEAN HText_selectAnchor(HText *text,HTChildAnchor *anchor)

{
  wchar_t wVar1;
  wchar_t wVar2;
  FILE *pFVar3;
  BOOLEAN local_19;
  wchar_t l;
  TextAnchor *a;
  
  for (a = text->first_anchor; (a != (TextAnchor *)0x0 && (a->anchor != anchor)); a = a->next) {
  }
  if (a == (TextAnchor *)0x0) {
    if (WWW_TraceFlag != '\0') {
      pFVar3 = TraceFP();
      fprintf((FILE *)pFVar3,"HText: No such anchor in this text!\n");
    }
    local_19 = '\0';
  }
  else {
    if (text != HTMainText) {
      HTMainText = text;
      HTMainAnchor = text->node_anchor;
    }
    wVar1 = a->line_num;
    if (WWW_TraceFlag != '\0') {
      wVar2 = a->number;
      pFVar3 = TraceFP();
      fprintf((FILE *)pFVar3,"HText: Selecting anchor [%d] at line %d\n",wVar2,wVar1);
    }
    if (((text->stale == '\0') && (text->top_of_screen <= wVar1)) &&
       (wVar1 < text->top_of_screen + display_lines + L'\x01')) {
      local_19 = '\x01';
    }
    else {
      www_search_result = wVar1 - display_lines / 3;
      local_19 = '\x01';
    }
  }
  return local_19;
}



// WARNING: Unknown calling convention

void HText_applyStyle(HText *me,HTStyle *style)

{
  return;
}



// WARNING: Unknown calling convention

void HText_updateStyle(HText *me,HTStyle *style)

{
  return;
}



// WARNING: Unknown calling convention

HTStyle * HText_selectionStyle(HText *me,HTStyleSheet *sheet)

{
  return (HTStyle *)0x0;
}



// WARNING: Unknown calling convention

void HText_replaceSel(HText *me,char *aString,HTStyle *aStyle)

{
  return;
}



// WARNING: Unknown calling convention

void HTextApplyToSimilar(HText *me,HTStyle *style)

{
  return;
}



// WARNING: Unknown calling convention

void HTextSelectUnstyled(HText *me,HTStyleSheet *sheet)

{
  return;
}



// WARNING: Unknown calling convention

void HText_unlinkSelection(HText *me)

{
  return;
}



// WARNING: Unknown calling convention

HTAnchor * HText_referenceSelected(HText *me)

{
  return (HTAnchor *)0x0;
}



// WARNING: Unknown calling convention

wchar_t HText_getTopOfScreen(void)

{
  wchar_t local_18;
  HText *text;
  
  if (HTMainText == (HText *)0x0) {
    local_18 = L'\0';
  }
  else {
    local_18 = HTMainText->top_of_screen;
  }
  return local_18;
}



// WARNING: Unknown calling convention

wchar_t HText_getLines(HText *text)

{
  return text->Lines;
}



// WARNING: Unknown calling convention

wchar_t HText_getPreferredTopLine(HText *text,wchar_t line_number)

{
  wchar_t wVar1;
  wchar_t last_screen;
  
  if (text->Lines < display_lines) {
    line_number = L'\0';
    wVar1 = line_number;
  }
  else {
    wVar1 = text->Lines + (2 - display_lines);
    if ((line_number <= text->Lines) && (wVar1 = line_number, line_number < L'\0')) {
      line_number = L'\0';
      wVar1 = line_number;
    }
  }
  line_number = wVar1;
  return line_number;
}



// WARNING: Unknown calling convention

HTAnchor * HText_linkSelTo(HText *me,HTAnchor *anchor)

{
  return (HTAnchor *)0x0;
}



// WARNING: Unknown calling convention

void HTSearchQueries_free(void)

{
  LYFreeStringList(search_queries);
  search_queries = (HTList *)0x0;
  return;
}



// WARNING: Unknown calling convention

void HTAddSearchQuery(char *query)

{
  int iVar1;
  char *local_18;
  HTList *cur;
  char *old;
  char *new_query;
  
  new_query = (char *)0x0;
  if ((query != (char *)0x0) && (*query != '\0')) {
    HTSACopy(&new_query,query);
    if (search_queries == (HTList *)0x0) {
      search_queries = HTList_new();
      HTList_addObject(search_queries,new_query);
    }
    else {
      cur = search_queries;
      do {
        if ((cur == (HTList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
          local_18 = (char *)0x0;
        }
        else {
          local_18 = (char *)cur->object;
        }
        if (local_18 == (char *)0x0) goto LAB_08069b4b;
        iVar1 = strcmp(local_18,new_query);
      } while (iVar1 != 0);
      HTList_removeObject(search_queries,local_18);
      if (local_18 != (char *)0x0) {
        free(local_18);
      }
LAB_08069b4b:
      HTList_addObject(search_queries,new_query);
    }
  }
  return;
}



wchar_t do_www_search(DocInfo *doc)

{
  BOOLEAN BVar1;
  char *pcVar2;
  wchar_t wVar3;
  int iVar4;
  char *message;
  FILE *__stream;
  int in_GS_OFFSET;
  wchar_t local_248;
  RecallType local_244;
  wchar_t local_240;
  DocInfo *doc_local;
  char *cp_freeme;
  wchar_t QueryNum;
  wchar_t QueryTotal;
  RecallType recall;
  wchar_t ch;
  char *tmpaddress;
  char *cp;
  BOOLEAN PreviousSearch;
  char temp [256];
  char searchstring [256];
  int local_c;
  
  local_c = *(int *)(in_GS_OFFSET + 0x14);
  tmpaddress = (char *)0x0;
  PreviousSearch = '\0';
  pcVar2 = strchr(doc->address,0x3f);
  if (pcVar2 == (char *)0x0) {
    searchstring[0] = '\0';
    temp[0] = '\0';
    cp = (char *)0x0;
  }
  else {
    PreviousSearch = '\x01';
    cp = pcVar2 + 1;
    LYstrncpy(searchstring,cp,L'');
    for (cp = searchstring; *cp != '\0'; cp = cp + 1) {
      if (*cp == '+') {
        *cp = ' ';
      }
    }
    HTUnEscape(searchstring);
    strcpy(temp,searchstring);
    HTAddSearchQuery(searchstring);
  }
  if (searchstring[0] == '\0') {
    if (HTMainAnchor->isIndexPrompt == (char *)0x0) {
      mustshow = '\x01';
      pcVar2 = (char *)gettext("Enter a database query: ");
      statusline(pcVar2);
    }
    else {
      mustshow = '\x01';
      statusline(HTMainAnchor->isIndexPrompt);
    }
  }
  else {
    mustshow = '\x01';
    pcVar2 = (char *)gettext("Edit the current query: ");
    statusline(pcVar2);
  }
  if (search_queries == (HTList *)0x0) {
    local_248 = L'\0';
  }
  else {
    local_248 = HTList_count(search_queries);
  }
  if (((PreviousSearch == '\0') || (local_248 < L'\x02')) &&
     ((PreviousSearch != '\0' || (local_248 < L'\x01')))) {
    local_244 = NORECALL;
  }
  else {
    local_244 = RECALL_URL;
  }
  QueryNum = local_248;
  while( true ) {
    while( true ) {
      wVar3 = LYgetstr(searchstring,L'\0',0x100,local_244);
      if ((((L'\xffffffff' < wVar3) && (searchstring[0] != '\0')) && (wVar3 != L'')) &&
         (wVar3 != L'')) {
        LYTrimLeading(searchstring);
        if (searchstring[0] == '\0') {
          pcVar2 = (char *)gettext("Cancelled!!!");
          HTInfoMsg(pcVar2);
          local_240 = L'\x03';
        }
        else {
          LYTrimTrailing(searchstring);
          if ((LYforce_no_cache == '\0') && (iVar4 = strcmp(temp,searchstring), iVar4 == 0)) {
            pcVar2 = (char *)gettext("Use Control-R to resubmit the current query.");
            HTUserMsg(pcVar2);
            local_240 = L'\x03';
          }
          else {
            HTAddSearchQuery(searchstring);
            cp = strchr(doc->address,0x3f);
            if (cp != (char *)0x0) {
              *cp = '\0';
            }
            HTSACopy(&tmpaddress,doc->address);
            HTSACat(&tmpaddress,"?");
            HTSACat(&tmpaddress,searchstring);
            pcVar2 = tmpaddress;
            message = (char *)gettext("Getting %s");
            user_message(message,pcVar2);
            LYSyslog(tmpaddress);
            if (tmpaddress != (char *)0x0) {
              free(tmpaddress);
              tmpaddress = (char *)0x0;
            }
            if (cp != (char *)0x0) {
              *cp = '?';
            }
            BVar1 = HTSearch(searchstring,HTMainAnchor);
            if (BVar1 == '\0') {
              local_240 = L'\0';
            }
            else {
              if (traversal == '\0') {
                cp_freeme = HTAnchor_address((HTAnchor *)HTMainAnchor);
              }
              else {
                cp_freeme = stub_HTAnchor_address((HTAnchor *)HTMainAnchor);
              }
              HTSACopy(&doc->address,cp_freeme);
              if (cp_freeme != (char *)0x0) {
                free(cp_freeme);
              }
              if (WWW_TraceFlag != '\0') {
                pcVar2 = doc->address;
                __stream = TraceFP();
                fprintf((FILE *)__stream,"\ndo_www_search: newfile: %s\n",pcVar2);
              }
              local_240 = L'\x01';
            }
          }
        }
        goto LAB_0806a2d6;
      }
      if ((local_244 == NORECALL) || (wVar3 != L'')) break;
      if (PreviousSearch == '\0') {
        QueryNum = QueryNum + L'\x01';
      }
      else {
        QueryNum = L'\x01';
        PreviousSearch = '\0';
      }
      if (local_248 <= QueryNum) {
        QueryNum = L'\0';
      }
      cp = (char *)HTList_objectAt(search_queries,QueryNum);
      if (cp == (char *)0x0) goto LAB_0806a05a;
      LYstrncpy(searchstring,cp,L'');
      if ((temp[0] == '\0') || (iVar4 = strcmp(temp,searchstring), iVar4 != 0)) {
        if (((temp[0] == '\0') || (local_248 != L'\x02')) &&
           ((temp[0] != '\0' || (local_248 != L'\x01')))) {
          mustshow = '\x01';
          pcVar2 = (char *)gettext("Edit a previous query: ");
          statusline(pcVar2);
        }
        else {
          mustshow = '\x01';
          pcVar2 = (char *)gettext("Edit the previous query: ");
          statusline(pcVar2);
        }
      }
      else {
        mustshow = '\x01';
        pcVar2 = (char *)gettext("Edit the current query: ");
        statusline(pcVar2);
      }
    }
    if ((local_244 == NORECALL) || (wVar3 != L'')) break;
    if (PreviousSearch != '\0') {
      PreviousSearch = '\0';
      QueryNum = local_248;
    }
    QueryNum = QueryNum + L'\xffffffff';
    if (QueryNum < L'\0') {
      QueryNum = local_248 + L'\xffffffff';
    }
    cp = (char *)HTList_objectAt(search_queries,QueryNum);
    if (cp == (char *)0x0) break;
    LYstrncpy(searchstring,cp,L'');
    if ((temp[0] == '\0') || (iVar4 = strcmp(temp,searchstring), iVar4 != 0)) {
      if (((temp[0] == '\0') || (local_248 != L'\x02')) &&
         ((temp[0] != '\0' || (local_248 != L'\x01')))) {
        mustshow = '\x01';
        pcVar2 = (char *)gettext("Edit a previous query: ");
        statusline(pcVar2);
      }
      else {
        mustshow = '\x01';
        pcVar2 = (char *)gettext("Edit the previous query: ");
        statusline(pcVar2);
      }
    }
    else {
      mustshow = '\x01';
      pcVar2 = (char *)gettext("Edit the current query: ");
      statusline(pcVar2);
    }
  }
LAB_0806a05a:
  pcVar2 = (char *)gettext("Cancelled!!!");
  HTInfoMsg(pcVar2);
  local_240 = L'\x03';
LAB_0806a2d6:
  if (local_c == *(int *)(in_GS_OFFSET + 0x14)) {
    return local_240;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void write_offset(FILE *fp,HTLine *line)

{
  wchar_t i;
  
  if (line->data[0] != '\0') {
    for (i = L'\0'; i < (int)(uint)line->offset; i = i + L'\x01') {
      fputc(0x20,(FILE *)fp);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void write_hyphen(FILE *fp)

{
  bool bVar1;
  
  if (((dump_output_immediately != '\0') && (LYRawMode != '\0')) &&
     (LYlowest_eightbit[current_char_set] < 0xae)) {
    if ((LYCharSet_UC[current_char_set].enc == 2) ||
       ((LYCharSet_UC[current_char_set].like8859 & 0x80U) != 0)) {
      bVar1 = true;
    }
    else {
      bVar1 = false;
    }
    if (bVar1) {
      fputc(0xad,(FILE *)fp);
      return;
    }
  }
  fputc(0x2d,(FILE *)fp);
  return;
}



// WARNING: Unknown calling convention

wchar_t TrimmedLength(char *string)

{
  char cVar1;
  wchar_t wVar2;
  uint uVar3;
  ushort **ppuVar4;
  char *pcVar5;
  char *src;
  char *dst;
  uint ch;
  wchar_t adjust;
  wchar_t result;
  
  result = strlen(string);
  wVar2 = HTisDocumentSource();
  adjust = result;
  if (wVar2 == L'\0') {
    for (; L'\0' < adjust; adjust = adjust + L'\xffffffff') {
      uVar3 = (uint)(byte)string[adjust + L'\xffffffff'];
      ppuVar4 = __ctype_b_loc();
      if ((((*ppuVar4)[uVar3] & 0x2000) == 0) && ((uVar3 < 3 || (8 < uVar3)))) break;
    }
    if (result != adjust) {
      src = string + adjust;
      dst = src;
      do {
        pcVar5 = LYSkipBlanks(src);
        *dst = *pcVar5;
        cVar1 = *dst;
        dst = dst + 1;
        src = pcVar5 + 1;
      } while (cVar1 != '\0');
      result = (wchar_t)(dst + (-1 - (int)string));
    }
  }
  return result;
}



void print_wwwfile_to_fd(FILE *fp,BOOLEAN is_email,BOOLEAN is_reply)

{
  bool bVar1;
  bool bVar2;
  bool bVar3;
  bool bVar4;
  int iVar5;
  wchar_t wVar6;
  uint __c;
  wchar_t local_30;
  BOOLEAN is_reply_local;
  BOOLEAN is_email_local;
  wchar_t ch;
  HText *text;
  HTLine *line;
  wchar_t limit;
  wchar_t first;
  BOOLEAN bs;
  BOOLEAN in_u;
  BOOLEAN in_b;
  
  bVar2 = true;
  bVar3 = false;
  bVar4 = false;
  if (((((is_email == '\0') && (is_reply == '\0')) && (HTMainText != (HText *)0x0)) &&
      ((with_backspaces != '\0' && (HTCJK == NOCJK)))) && ((HTMainText->T).output_utf8 == '\0')) {
    bVar1 = true;
  }
  else {
    bVar1 = false;
  }
  if (HTMainText != (HText *)0x0) {
    line = HTMainText->last_line->next;
    while( true ) {
      if (bVar2) {
        bVar2 = false;
        if (is_reply == '\0') {
          if ((is_email != '\0') && (iVar5 = strncmp(line->data,"From ",5), iVar5 == 0)) {
            fputc(0x3e,(FILE *)fp);
          }
        }
        else {
          fputc(0x3e,(FILE *)fp);
        }
      }
      else if (line->data[0] != '\b') {
        fputc(10,(FILE *)fp);
        if (is_reply == '\0') {
          if ((is_email != '\0') && (iVar5 = strncmp(line->data,"From ",5), iVar5 == 0)) {
            fputc(0x3e,(FILE *)fp);
          }
        }
        else {
          fputc(0x3e,(FILE *)fp);
        }
      }
      write_offset(fp,line);
      wVar6 = TrimmedLength(line->data);
      for (local_30 = L'\0'; local_30 < wVar6; local_30 = local_30 + L'\x01') {
        __c = (uint)(byte)line->data[local_30];
        if ((__c < 3) || (8 < __c)) {
          if (bVar3) {
            fputc(__c,(FILE *)fp);
            fputc(8,(FILE *)fp);
            fputc(__c,(FILE *)fp);
          }
          else if (bVar4) {
            fputc(0x5f,(FILE *)fp);
            fputc(8,(FILE *)fp);
            fputc(__c,(FILE *)fp);
          }
          else {
            fputc(__c,(FILE *)fp);
          }
        }
        else if ((__c == 7) && (wVar6 <= local_30 + L'\x01')) {
          write_hyphen(fp);
        }
        else if ((dump_output_immediately == '\0') || (use_underscore == '\0')) {
          if (bVar1) {
            if (__c == 4) {
              bVar4 = false;
            }
            else if (__c < 5) {
              if ((__c == 3) && (!bVar3)) {
                bVar4 = true;
              }
            }
            else if (__c == 5) {
              if (bVar4) {
                bVar4 = false;
              }
              bVar3 = true;
            }
            else if (__c == 6) {
              bVar3 = false;
            }
          }
        }
        else if (__c - 3 < 2) {
          fputc(0x5f,(FILE *)fp);
        }
      }
      if (HTMainText->last_line == line) break;
      line = line->next;
    }
    fputc(10,(FILE *)fp);
  }
  return;
}



// WARNING: Unknown calling convention

void print_crawl_to_fd(FILE *fp,char *thelink,char *thetitle)

{
  bool bVar1;
  wchar_t wVar2;
  uint __c;
  wchar_t local_18;
  wchar_t ch;
  HTLine *line;
  wchar_t limit;
  wchar_t first;
  
  bVar1 = true;
  if (HTMainText != (HText *)0x0) {
    line = HTMainText->last_line->next;
    fprintf((FILE *)fp,"THE_URL:%s\n",thelink);
    if (thetitle != (char *)0x0) {
      fprintf((FILE *)fp,"THE_TITLE:%s\n",thetitle);
    }
    while( true ) {
      if ((!bVar1) && (line->data[0] != '\b')) {
        fputc(10,(FILE *)fp);
      }
      bVar1 = false;
      write_offset(fp,line);
      wVar2 = TrimmedLength(line->data);
      for (local_18 = L'\0'; local_18 < wVar2; local_18 = local_18 + L'\x01') {
        __c = (uint)(byte)line->data[local_18];
        if ((__c < 3) || (8 < __c)) {
          fputc(__c,(FILE *)fp);
        }
        else if ((__c == 7) && (wVar2 <= local_18 + L'\x01')) {
          write_hyphen(fp);
        }
      }
      if (HTMainText->last_line == line) break;
      line = line->next;
    }
    fputc(10,(FILE *)fp);
    if ((no_list == '\0') && ((keypad_mode == 1 || (keypad_mode == 2)))) {
      printlist(fp,'\0');
    }
  }
  return;
}



// WARNING: Removing unreachable block (ram,0x0806a9c7)
// WARNING: Unknown calling convention

void adjust_search_result(DocInfo *doc,wchar_t tentative_result,wchar_t start_line)

{
  bool bVar1;
  int iVar2;
  wchar_t i;
  wchar_t max_offset;
  wchar_t goal;
  wchar_t nl_closest;
  TextAnchor *a;
  wchar_t anch_line;
  BOOLEAN on_screen;
  
  if (L'\0' < tentative_result) {
    anch_line = L'\xffffffff';
    nl_closest = L'\xffffffff';
    goal = L'\x04';
    if ((HTMainText->top_of_screen < tentative_result) &&
       (tentative_result <= HTMainText->top_of_screen + display_lines)) {
      bVar1 = true;
    }
    else {
      bVar1 = false;
    }
    if (display_lines < 4) {
      goal = display_lines;
    }
    iVar2 = goal + L'\xffffffff';
    if ((bVar1) && (0 < nlinks)) {
      for (i = L'\0'; i < nlinks; i = i + L'\x01') {
        if (doc->line + links[i].ly + L'\xffffffff' <= tentative_result) {
          nl_closest = i;
        }
        if (tentative_result <= doc->line + links[i].ly + L'\xffffffff') break;
      }
      if ((L'\xffffffff' < nl_closest) &&
         (doc->line + links[nl_closest].ly + L'\xffffffff' == tentative_result)) {
        www_search_result = doc->line;
        doc->link = nl_closest;
        return;
      }
    }
    for (a = HTMainText->first_anchor;
        (a != (TextAnchor *)0x0 && (a->line_num <= tentative_result + L'\xffffffff')); a = a->next)
    {
      anch_line = a->line_num + L'\x01';
    }
    if (((anch_line < L'\0') || (anch_line < tentative_result - iVar2)) ||
       ((anch_line <= start_line && (HTMainText->top_of_screen < tentative_result)))) {
      if ((tentative_result == start_line || tentative_result - start_line < 0) ||
         (iVar2 < ~start_line + tentative_result)) {
        if ((HTMainText->top_of_screen < tentative_result) &&
           ((tentative_result <= start_line &&
            (tentative_result <= HTMainText->top_of_screen + goal)))) {
          www_search_result = HTMainText->top_of_screen + L'\x01';
        }
        else if (goal < tentative_result) {
          www_search_result = tentative_result - iVar2;
        }
        else {
          www_search_result = 1;
        }
      }
      else {
        www_search_result = start_line + L'\x01';
      }
    }
    else {
      www_search_result = anch_line;
    }
    if ((doc->line == www_search_result) && (L'\xffffffff' < nl_closest)) {
      doc->link = nl_closest;
    }
  }
  return;
}



// WARNING: Unknown calling convention

BOOLEAN anchor_has_target(TextAnchor *a,char *target)

{
  char *pcVar1;
  wchar_t count;
  char *cp;
  char *sp;
  char *stars;
  OptionType_conflict *option;
  
  stars = (char *)0x0;
  count = L'\0';
  while (pcVar1 = LYGetHiTextStr(a,count), pcVar1 != (char *)0x0) {
    if (case_sensitive == '\0') {
      pcVar1 = LYno_attr_char_case_strstr(pcVar1,target);
    }
    else {
      pcVar1 = LYno_attr_char_strstr(pcVar1,target);
    }
    if (pcVar1 != (char *)0x0) {
      return '\x01';
    }
    count = count + L'\x01';
  }
  if (((a->input_field != (FormInfo *)0x0) && (a->input_field->value != (char *)0x0)) &&
     (a->input_field->type != L'\b')) {
    if (a->input_field->type == L'\x02') {
      if (case_sensitive == '\0') {
        pcVar1 = LYno_attr_char_case_strstr(a->input_field->value,target);
      }
      else {
        pcVar1 = LYno_attr_char_strstr(a->input_field->value,target);
      }
      if (pcVar1 != (char *)0x0) {
        return '\x01';
      }
      HTSACopy(&stars,a->input_field->value);
      for (sp = stars; *sp != '\0'; sp = sp + 1) {
        *sp = '*';
      }
      if (case_sensitive == '\0') {
        pcVar1 = LYno_attr_char_case_strstr(stars,target);
      }
      else {
        pcVar1 = LYno_attr_char_strstr(stars,target);
      }
      if (pcVar1 != (char *)0x0) {
        if (stars != (char *)0x0) {
          free(stars);
        }
        return '\x01';
      }
      if (stars != (char *)0x0) {
        free(stars);
      }
    }
    else if (a->input_field->type == L'\a') {
      for (option = a->input_field->select_list; option != (OptionType_conflict *)0x0;
          option = option->next) {
        if (case_sensitive == '\0') {
          pcVar1 = LYno_attr_char_case_strstr(option->name,target);
        }
        else {
          pcVar1 = LYno_attr_char_strstr(option->name,target);
        }
        if (pcVar1 != (char *)0x0) {
          return '\x01';
        }
      }
    }
    else if (a->input_field->type == L'\x04') {
      if (a->input_field->num_value == L'\0') {
        cp = unchecked_radio;
      }
      else {
        cp = checked_radio;
      }
      if (case_sensitive == '\0') {
        pcVar1 = LYno_attr_char_case_strstr(cp,target);
      }
      else {
        pcVar1 = LYno_attr_char_strstr(cp,target);
      }
      if (pcVar1 != (char *)0x0) {
        return '\x01';
      }
    }
    else if (a->input_field->type == L'\x03') {
      if (a->input_field->num_value == L'\0') {
        cp = unchecked_box;
      }
      else {
        cp = checked_box;
      }
      if (case_sensitive == '\0') {
        pcVar1 = LYno_attr_char_case_strstr(cp,target);
      }
      else {
        pcVar1 = LYno_attr_char_strstr(cp,target);
      }
      if (pcVar1 != (char *)0x0) {
        return '\x01';
      }
    }
    else {
      if (case_sensitive == '\0') {
        pcVar1 = LYno_attr_char_case_strstr(a->input_field->value,target);
      }
      else {
        pcVar1 = LYno_attr_char_strstr(a->input_field->value,target);
      }
      if (pcVar1 != (char *)0x0) {
        return '\x01';
      }
    }
  }
  return '\0';
}



// WARNING: Unknown calling convention

TextAnchor * line_num_to_anchor(wchar_t line_num)

{
  TextAnchor *a;
  
  if (HTMainText == (HText *)0x0) {
    a = (TextAnchor *)0x0;
  }
  else {
    for (a = HTMainText->first_anchor; (a != (TextAnchor *)0x0 && (a->line_num < line_num));
        a = a->next) {
    }
  }
  return a;
}



// WARNING: Unknown calling convention

wchar_t line_num_in_text(HText *text,HTLine *line)

{
  HTLine *temp;
  wchar_t result;
  
  result = L'\x01';
  for (temp = text->last_line->next; temp != line; temp = temp->next) {
    result = result + L'\x01';
  }
  return result;
}



// WARNING: Unknown calling convention

TextAnchor * get_prev_anchor(TextAnchor *a)

{
  _TextAnchor *p_Var1;
  TextAnchor *q;
  TextAnchor *p;
  
  if ((a->prev == (_TextAnchor *)0x0) && (p = HTMainText->first_anchor, p != (TextAnchor *)0x0)) {
    while (p_Var1 = p->next, p_Var1 != (_TextAnchor *)0x0) {
      p_Var1->prev = p;
      p = p_Var1;
    }
  }
  return a->prev;
}



// WARNING: Unknown calling convention

wchar_t www_search_forward(wchar_t start_line,DocInfo *doc,char *target,HTLine *line,wchar_t count)

{
  BOOLEAN BVar1;
  char *pcVar2;
  bool local_15;
  wchar_t tentative_result;
  TextAnchor *a;
  wchar_t wrapped;
  
  wrapped = L'\0';
  a = line_num_to_anchor(count + L'\xffffffff');
  while( true ) {
    for (; (a != (TextAnchor *)0x0 && (a->line_num == count + L'\xffffffff')); a = a->next) {
      if ((a->show_anchor != '\0') &&
         (((a->link_type != '\x02' || (a->input_field->type != L'\b')) &&
          (BVar1 = anchor_has_target(a,target), BVar1 != '\0')))) {
        adjust_search_result(doc,count,start_line);
        return L'\x01';
      }
    }
    if (case_sensitive == '\0') {
      pcVar2 = LYno_attr_char_case_strstr(line->data,target);
    }
    else {
      pcVar2 = LYno_attr_char_strstr(line->data,target);
    }
    local_15 = pcVar2 != (char *)0x0;
    if (local_15) break;
    if (((count == start_line) && (wrapped != L'\0')) || (L'\x01' < wrapped)) {
      pcVar2 = (char *)gettext("\'%s\' not found!");
      HTUserMsg2(pcVar2,target);
      return L'\xffffffff';
    }
    if (HTMainText->last_line == line) {
      count = L'\0';
      wrapped = wrapped + L'\x01';
    }
    line = line->next;
    count = count + L'\x01';
  }
  if (L'\0' < count) {
    adjust_search_result(doc,count,start_line);
  }
  return L'\0';
}



// WARNING: Unknown calling convention

wchar_t www_search_backward(wchar_t start_line,DocInfo *doc,char *target,HTLine *line,wchar_t count)

{
  BOOLEAN BVar1;
  char *pcVar2;
  wchar_t wVar3;
  bool local_15;
  wchar_t tentative_result;
  TextAnchor *a;
  wchar_t wrapped;
  
  wrapped = L'\0';
  a = line_num_to_anchor(count + L'\xffffffff');
  while( true ) {
    for (; (a != (TextAnchor *)0x0 && (a->line_num == count + L'\xffffffff'));
        a = get_prev_anchor(a)) {
      if ((a->show_anchor != '\0') &&
         (((a->link_type != '\x02' || (a->input_field->type != L'\b')) &&
          (BVar1 = anchor_has_target(a,target), BVar1 != '\0')))) {
        adjust_search_result(doc,count,start_line);
        return L'\x01';
      }
    }
    if (case_sensitive == '\0') {
      pcVar2 = LYno_attr_char_case_strstr(line->data,target);
    }
    else {
      pcVar2 = LYno_attr_char_strstr(line->data,target);
    }
    local_15 = pcVar2 != (char *)0x0;
    if (local_15) break;
    if (((count == start_line) && (wrapped != L'\0')) || (L'\x01' < wrapped)) {
      pcVar2 = (char *)gettext("\'%s\' not found!");
      HTUserMsg2(pcVar2,target);
      return L'\xffffffff';
    }
    if (HTMainText->last_line->next == line) {
      wVar3 = line_num_in_text(HTMainText,HTMainText->last_line);
      count = wVar3 + L'\x01';
      wrapped = wrapped + L'\x01';
    }
    line = line->prev;
    count = count + L'\xffffffff';
  }
  if (L'\0' < count) {
    adjust_search_result(doc,count,start_line);
  }
  return L'\0';
}



// WARNING: Unknown calling convention

void www_user_search(wchar_t start_line,DocInfo *doc,char *target,wchar_t direction)

{
  wchar_t count;
  HTLine *line;
  
  if (HTMainText != (HText *)0x0) {
    line = HTMainText->last_line->next;
    if (start_line + direction < 1) {
      line = HTMainText->last_line;
      count = line_num_in_text(HTMainText,line);
    }
    else {
      for (count = L'\x01'; count < start_line + direction; count = count + L'\x01') {
        if (HTMainText->last_line == line) {
          line = HTMainText->last_line->next;
          count = L'\x01';
          break;
        }
        line = line->next;
      }
    }
    if (direction < L'\0') {
      www_search_backward(start_line,doc,target,line,count);
    }
    else {
      www_search_forward(start_line,doc,target,line,count);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void user_message(char *message,char *argument)

{
  char *local_18;
  char *temp;
  
  if (message == (char *)0x0) {
    mustshow = '\0';
  }
  else {
    temp = (char *)0x0;
    if (argument == (char *)0x0) {
      local_18 = "";
    }
    else {
      local_18 = argument;
    }
    HTSprintf0(&temp,message,local_18);
    statusline(temp);
    if (temp != (char *)0x0) {
      free(temp);
    }
  }
  return;
}



// WARNING: Unknown calling convention

char * HText_getOwner(void)

{
  char *local_8;
  
  if (HTMainText == (HText *)0x0) {
    local_8 = (char *)0x0;
  }
  else {
    local_8 = HTAnchor_owner(HTMainText->node_anchor);
  }
  return local_8;
}



// WARNING: Unknown calling convention

void HText_setMainTextOwner(char *owner)

{
  if (HTMainText != (HText *)0x0) {
    HTAnchor_setOwner(HTMainText->node_anchor,owner);
  }
  return;
}



// WARNING: Unknown calling convention

char * HText_getRevTitle(void)

{
  char *local_8;
  
  if (HTMainText == (HText *)0x0) {
    local_8 = (char *)0x0;
  }
  else {
    local_8 = HTAnchor_RevTitle(HTMainText->node_anchor);
  }
  return local_8;
}



// WARNING: Unknown calling convention

char * HText_getContentBase(void)

{
  char *local_8;
  
  if (HTMainText == (HText *)0x0) {
    local_8 = (char *)0x0;
  }
  else {
    local_8 = HTAnchor_content_base(HTMainText->node_anchor);
  }
  return local_8;
}



// WARNING: Unknown calling convention

char * HText_getContentLocation(void)

{
  char *local_8;
  
  if (HTMainText == (HText *)0x0) {
    local_8 = (char *)0x0;
  }
  else {
    local_8 = HTAnchor_content_location(HTMainText->node_anchor);
  }
  return local_8;
}



// WARNING: Unknown calling convention

char * HText_getMessageID(void)

{
  char *local_8;
  
  if (HTMainText == (HText *)0x0) {
    local_8 = (char *)0x0;
  }
  else {
    local_8 = HTAnchor_messageID(HTMainText->node_anchor);
  }
  return local_8;
}



// WARNING: Unknown calling convention

void HTuncache_current_document(void)

{
  HTParentAnchor *pHVar1;
  FILE *pFVar2;
  char *local_1c;
  char *local_18;
  HTParentAnchor *htmain_anchor;
  
  if (HTMainText == (HText *)0x0) {
    if (WWW_TraceFlag != '\0') {
      pFVar2 = TraceFP();
      fprintf((FILE *)pFVar2,"HTuncache.. HTMainText already is NULL!\n");
    }
  }
  else {
    pHVar1 = HTMainText->node_anchor;
    if ((pHVar1 != (HTParentAnchor *)0x0) &&
       (((HTOutputFormat == (HTFormat)0x0 || (HTOutputFormat != WWW_SOURCE)) &&
        (pHVar1->UCStages != (UCAnchorInfo *)0x0)))) {
      free(pHVar1->UCStages);
      pHVar1->UCStages = (UCAnchorInfo *)0x0;
    }
    if (WWW_TraceFlag != '\0') {
      if ((pHVar1 == (HTParentAnchor *)0x0) || (pHVar1->post_data == (bstring *)0x0)) {
        local_1c = "";
      }
      else {
        local_1c = " with POST data";
      }
      if ((pHVar1 == (HTParentAnchor *)0x0) || (pHVar1->address == (char *)0x0)) {
        local_18 = "unknown anchor";
      }
      else {
        local_18 = pHVar1->address;
      }
      pFVar2 = TraceFP();
      fprintf((FILE *)pFVar2,"\nHTuncache.. freeing document for \'%s\'%s\n",local_18,local_1c);
    }
    HTList_removeObject(loaded_texts,HTMainText);
    HText_free(HTMainText);
    HTMainText = (HText *)0x0;
  }
  return;
}



// WARNING: Unknown calling convention

BOOLEAN useSourceCache(void)

{
  FILE *__stream;
  undefined *local_18;
  BOOLEAN result;
  
  result = '\0';
  if ((LYCacheSource == L'\x01') &&
     (result = HTMainAnchor->source_cache_file != (char *)0x0, WWW_TraceFlag != '\0')) {
    if ((bool)result) {
      local_18 = &DAT_0814cbac;
    }
    else {
      local_18 = &DAT_0814dbf6;
    }
    __stream = TraceFP();
    fprintf((FILE *)__stream,"SourceCache: file-cache%s found\n",local_18);
  }
  return result;
}



// WARNING: Unknown calling convention

BOOLEAN useMemoryCache(void)

{
  FILE *__stream;
  undefined *local_18;
  BOOLEAN result;
  
  result = '\0';
  if ((LYCacheSource == L'\x02') &&
     (result = HTMainAnchor->source_cache_chunk != (HTChunk *)0x0, WWW_TraceFlag != '\0')) {
    if ((bool)result) {
      local_18 = &DAT_0814cbac;
    }
    else {
      local_18 = &DAT_0814dbf6;
    }
    __stream = TraceFP();
    fprintf((FILE *)__stream,"SourceCache: memory-cache%s found\n",local_18);
  }
  return result;
}



// WARNING: Unknown calling convention

BOOLEAN HTreparse_document(void)

{
  HTChunk *pHVar1;
  BOOLEAN BVar2;
  FILE *pFVar3;
  HTFormat format_00;
  FILE *fp_00;
  char *pcVar4;
  int iVar5;
  HTAtom *format_01;
  BOOLEAN local_35;
  char local_34;
  char *local_30;
  char *local_2c;
  wchar_t ret_1;
  HTFormat format_1;
  wchar_t ret;
  HTFormat format;
  FILE *fp;
  BOOLEAN ok;
  
  ok = '\0';
  if ((HTMainAnchor == (HTParentAnchor *)0x0) || (LYCacheSource == L'\0')) {
    if (WWW_TraceFlag != '\0') {
      pFVar3 = TraceFP();
      fprintf((FILE *)pFVar3,"HTreparse_document returns FALSE\n");
    }
    local_35 = '\0';
  }
  else {
    BVar2 = useSourceCache();
    if (BVar2 == '\0') {
      BVar2 = useMemoryCache();
      if (BVar2 != '\0') {
        format_01 = HTAtom_for("text/html");
        if (WWW_TraceFlag != '\0') {
          pHVar1 = HTMainAnchor->source_cache_chunk;
          pFVar3 = TraceFP();
          fprintf((FILE *)pFVar3,"SourceCache: Reparsing from memory chunk %p\n",pHVar1);
        }
        if (((HTOutputFormat == (HTFormat)0x0) || (HTOutputFormat != WWW_SOURCE)) &&
           (HTMainAnchor->UCStages != (UCAnchorInfo *)0x0)) {
          free(HTMainAnchor->UCStages);
          HTMainAnchor->UCStages = (UCAnchorInfo *)0x0;
        }
        if (HTMainAnchor->content_type == (char *)0x0) {
          format_1 = HTCharsetFormat(format_01,HTMainAnchor,UCLYhndl_for_unspec);
        }
        else {
          format_1 = HTAtom_for(HTMainAnchor->content_type);
        }
        BVar2 = HText_HaveUserChangedForms(HTMainText);
        if (BVar2 != '\0') {
          pcVar4 = (char *)gettext("Reloading document.  Any form entries will be lost!");
          HTAlert(pcVar4);
        }
        HTAnchor_setProtocol(HTMainAnchor,&scm);
        iVar5 = HTParseMem(format_1,HTOutputFormat,HTMainAnchor,HTMainAnchor->source_cache_chunk,
                           (HTStream_conflict4 *)0x0);
        ok = iVar5 == 200;
        if (WWW_TraceFlag != '\0') {
          if ((bool)ok) {
            local_2c = "succeeded";
          }
          else {
            local_2c = "failed";
          }
          pFVar3 = TraceFP();
          fprintf((FILE *)pFVar3,"Reparse memory %s\n",local_2c);
        }
      }
    }
    else {
      if (WWW_TraceFlag != '\0') {
        pcVar4 = HTMainAnchor->source_cache_file;
        pFVar3 = TraceFP();
        fprintf((FILE *)pFVar3,"SourceCache: Reparsing file %s\n",pcVar4);
      }
      if (((HTOutputFormat == (HTFormat)0x0) || (HTOutputFormat != WWW_SOURCE)) &&
         (HTMainAnchor->UCStages != (UCAnchorInfo *)0x0)) {
        free(HTMainAnchor->UCStages);
        HTMainAnchor->UCStages = (UCAnchorInfo *)0x0;
      }
      if (HTMainAnchor->content_type == (char *)0x0) {
        format_00 = HTFileFormat(HTMainAnchor->source_cache_file,(HTAtom **)0x0,(char **)0x0);
        format = HTCharsetFormat(format_00,HTMainAnchor,UCLYhndl_for_unspec);
      }
      else {
        format = HTAtom_for(HTMainAnchor->content_type);
      }
      if (WWW_TraceFlag != '\0') {
        pcVar4 = format->name;
        pFVar3 = TraceFP();
        fprintf((FILE *)pFVar3,"  Content type is \"%s\"\n",pcVar4);
      }
      fp_00 = fopen64(HTMainAnchor->source_cache_file,"r");
      if (fp_00 == (FILE *)0x0) {
        if (WWW_TraceFlag != '\0') {
          pcVar4 = HTMainAnchor->source_cache_file;
          pFVar3 = TraceFP();
          fprintf((FILE *)pFVar3,"  Cannot read file %s\n",pcVar4);
        }
        LYRemoveTemp(HTMainAnchor->source_cache_file);
        if (HTMainAnchor->source_cache_file != (char *)0x0) {
          free(HTMainAnchor->source_cache_file);
          HTMainAnchor->source_cache_file = (char *)0x0;
        }
        return '\0';
      }
      BVar2 = HText_HaveUserChangedForms(HTMainText);
      if (BVar2 != '\0') {
        pcVar4 = (char *)gettext("Reloading document.  Any form entries will be lost!");
        HTAlert(pcVar4);
      }
      HTAnchor_setProtocol(HTMainAnchor,&HTFile);
      iVar5 = HTParseFile(format,HTOutputFormat,HTMainAnchor,(FILE *)fp_00,(HTStream_conflict4 *)0x0
                         );
      LYCloseInput((FILE *)fp_00);
      if (iVar5 == 0xce) {
        pcVar4 = (char *)gettext("Loading incomplete.");
        HTInfoMsg(pcVar4);
        if (WWW_TraceFlag != '\0') {
          pcVar4 = HTLoadedDocumentURL();
          pFVar3 = TraceFP();
          fprintf((FILE *)pFVar3,"SourceCache: `%s\' has been accessed, partial content.\n",pcVar4);
        }
      }
      if ((iVar5 == 200) || (iVar5 == 0xce)) {
        local_34 = '\x01';
      }
      else {
        local_34 = '\0';
      }
      ok = local_34;
      if (WWW_TraceFlag != '\0') {
        if (local_34 == '\0') {
          local_30 = "failed";
        }
        else {
          local_30 = "succeeded";
        }
        pFVar3 = TraceFP();
        fprintf((FILE *)pFVar3,"Reparse file %s\n",local_30);
      }
    }
    local_35 = ok;
  }
  return local_35;
}



// WARNING: Unknown calling convention

BOOLEAN HTcan_reparse_document(void)

{
  BOOLEAN BVar1;
  FILE *__stream;
  BOOLEAN result;
  
  result = '\0';
  if ((HTMainAnchor == (HTParentAnchor *)0x0) || (LYCacheSource == L'\0')) {
    result = '\0';
  }
  else {
    BVar1 = useSourceCache();
    if (BVar1 == '\0') {
      BVar1 = useMemoryCache();
      if (BVar1 != '\0') {
        result = '\x01';
      }
    }
    else {
      result = LYCanReadFile(HTMainAnchor->source_cache_file);
    }
  }
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"HTcan_reparse_document -> %d\n",(int)result);
  }
  return result;
}



// WARNING: Unknown calling convention

void trace_setting_change(char *name,wchar_t prev_setting,wchar_t new_setting)

{
  FILE *__stream;
  
  if ((prev_setting != new_setting) && (WWW_TraceFlag != '\0')) {
    __stream = TraceFP();
    fprintf((FILE *)__stream,
            "HTdocument_settings_changed: %s setting has changed (was %d, now %d)\n",name,
            prev_setting,new_setting);
  }
  return;
}



// WARNING: Unknown calling convention

BOOLEAN HTdocument_settings_changed(void)

{
  short sVar1;
  short sVar2;
  int iVar3;
  BOOLEAN BVar4;
  FILE *__stream;
  int local_24;
  int local_1c;
  int local_10;
  
  if ((HTMainText == (HText *)0x0) || (BVar4 = HTcan_reparse_document(), BVar4 == '\0')) {
    return '\0';
  }
  if (WWW_TraceFlag != '\0') {
    trace_setting_change("CLICKABLE_IMAGES",(int)HTMainText->clickable_images,(int)clickable_images)
    ;
    trace_setting_change
              ("PSEUDO_INLINE_ALTS",(int)HTMainText->pseudo_inline_alts,(int)pseudo_inline_alts);
    trace_setting_change("VERBOSE_IMG",(int)HTMainText->verbose_img,(int)verbose_img);
    trace_setting_change("RAW_MODE",(int)HTMainText->raw_mode,(int)LYUseDefaultRawMode);
    trace_setting_change
              ("HISTORICAL_COMMENTS",(int)HTMainText->historical_comments,(int)historical_comments);
    trace_setting_change("MINIMAL_COMMENTS",(int)HTMainText->minimal_comments,(int)minimal_comments)
    ;
    trace_setting_change("SOFT_DQUOTES",(int)HTMainText->soft_dquotes,(int)soft_dquotes);
    trace_setting_change("OLD_DTD",(int)HTMainText->old_dtd,Old_DTD);
    trace_setting_change("KEYPAD_MODE",(int)HTMainText->keypad_mode,keypad_mode);
    iVar3 = LYlines;
    if (HTMainText->disp_lines == LYlines) {
      if (LYwideLines == L'\0') {
        local_24 = LYcols;
      }
      else {
        local_24 = 0x3f6;
      }
      if (HTMainText->disp_cols == local_24) goto LAB_0806bfe7;
    }
    if (WWW_TraceFlag != '\0') {
      if (LYwideLines == L'\0') {
        local_1c = LYcols;
      }
      else {
        local_1c = 0x3f6;
      }
      sVar1 = HTMainText->disp_lines;
      sVar2 = HTMainText->disp_cols;
      __stream = TraceFP();
      fprintf((FILE *)__stream,
              "HTdocument_settings_changed: Screen size has changed (was %dx%d, now %dx%d)\n",
              (int)sVar2,(int)sVar1,local_1c,iVar3);
    }
  }
LAB_0806bfe7:
  if ((((((HTMainText->clickable_images == clickable_images) &&
         (HTMainText->pseudo_inline_alts == pseudo_inline_alts)) &&
        (HTMainText->verbose_img == verbose_img)) &&
       ((HTMainText->raw_mode == LYUseDefaultRawMode &&
        (HTMainText->historical_comments == historical_comments)))) &&
      ((HTMainText->minimal_comments == minimal_comments || (historical_comments != '\0')))) &&
     (((HTMainText->soft_dquotes == soft_dquotes && (HTMainText->old_dtd == Old_DTD)) &&
      (HTMainText->keypad_mode == keypad_mode)))) {
    if (LYwideLines == L'\0') {
      local_10 = LYcols;
    }
    else {
      local_10 = 0x3f6;
    }
    if (HTMainText->disp_cols == local_10) {
      return '\0';
    }
  }
  return '\x01';
}



// WARNING: Unknown calling convention

wchar_t HTisDocumentSource(void)

{
  wchar_t local_8;
  
  if (HTMainText == (HText *)0x0) {
    local_8 = L'\0';
  }
  else {
    local_8 = (wchar_t)HTMainText->source;
  }
  return local_8;
}



// WARNING: Unknown calling convention

char * HTLoadedDocumentURL(void)

{
  char *local_8;
  
  if (HTMainText == (HText *)0x0) {
    local_8 = "";
  }
  else if ((HTMainText->node_anchor == (HTParentAnchor *)0x0) ||
          (HTMainText->node_anchor->address == (char *)0x0)) {
    local_8 = "";
  }
  else {
    local_8 = HTMainText->node_anchor->address;
  }
  return local_8;
}



// WARNING: Unknown calling convention

bstring_conflict * HTLoadedDocumentPost_data(void)

{
  bstring_conflict *local_8;
  
  if (((HTMainText == (HText *)0x0) || (HTMainText->node_anchor == (HTParentAnchor *)0x0)) ||
     (HTMainText->node_anchor->post_data == (bstring *)0x0)) {
    local_8 = (bstring_conflict *)0x0;
  }
  else {
    local_8 = (bstring_conflict *)HTMainText->node_anchor->post_data;
  }
  return local_8;
}



// WARNING: Unknown calling convention

char * HTLoadedDocumentTitle(void)

{
  char *local_8;
  
  if (HTMainText == (HText *)0x0) {
    local_8 = "";
  }
  else if ((HTMainText->node_anchor == (HTParentAnchor *)0x0) ||
          (HTMainText->node_anchor->title == (char *)0x0)) {
    local_8 = "";
  }
  else {
    local_8 = HTMainText->node_anchor->title;
  }
  return local_8;
}



// WARNING: Unknown calling convention

BOOLEAN HTLoadedDocumentIsHEAD(void)

{
  BOOLEAN local_5;
  
  if (HTMainText == (HText *)0x0) {
    local_5 = '\0';
  }
  else if ((HTMainText->node_anchor == (HTParentAnchor *)0x0) ||
          (HTMainText->node_anchor->isHEAD == '\0')) {
    local_5 = '\0';
  }
  else {
    local_5 = HTMainText->node_anchor->isHEAD;
  }
  return local_5;
}



// WARNING: Unknown calling convention

BOOLEAN HTLoadedDocumentIsSafe(void)

{
  BOOLEAN local_5;
  
  if (HTMainText == (HText *)0x0) {
    local_5 = '\0';
  }
  else if ((HTMainText->node_anchor == (HTParentAnchor *)0x0) ||
          (HTMainText->node_anchor->safe == '\0')) {
    local_5 = '\0';
  }
  else {
    local_5 = HTMainText->node_anchor->safe;
  }
  return local_5;
}



// WARNING: Unknown calling convention

char * HTLoadedDocumentCharset(void)

{
  char *local_8;
  
  if (HTMainText == (HText *)0x0) {
    local_8 = (char *)0x0;
  }
  else if ((HTMainText->node_anchor == (HTParentAnchor *)0x0) ||
          (HTMainText->node_anchor->charset == (char *)0x0)) {
    local_8 = (char *)0x0;
  }
  else {
    local_8 = HTMainText->node_anchor->charset;
  }
  return local_8;
}



// WARNING: Unknown calling convention

BOOLEAN HTLoadedDocumentEightbit(void)

{
  BOOLEAN local_5;
  
  if (HTMainText == (HText *)0x0) {
    local_5 = '\0';
  }
  else {
    local_5 = HTMainText->have_8bit_chars;
  }
  return local_5;
}



// WARNING: Unknown calling convention

void HText_setNodeAnchorBookmark(char *bookmark)

{
  if ((HTMainText != (HText *)0x0) && (HTMainText->node_anchor != (HTParentAnchor *)0x0)) {
    HTAnchor_setBookmark(HTMainText->node_anchor,bookmark);
  }
  return;
}



// WARNING: Unknown calling convention

char * HTLoadedDocumentBookmark(void)

{
  char *local_8;
  
  if (HTMainText == (HText *)0x0) {
    local_8 = (char *)0x0;
  }
  else if ((HTMainText->node_anchor == (HTParentAnchor *)0x0) ||
          (HTMainText->node_anchor->bookmark == (char *)0x0)) {
    local_8 = (char *)0x0;
  }
  else {
    local_8 = HTMainText->node_anchor->bookmark;
  }
  return local_8;
}



wchar_t HText_LastLineSize(HText *text,BOOLEAN IgnoreSpaces)

{
  wchar_t local_c;
  BOOLEAN IgnoreSpaces_local;
  
  if (((text == (HText *)0x0) || (text->last_line == (HTLine *)0x0)) || (text->last_line->size == 0)
     ) {
    local_c = L'\0';
  }
  else {
    local_c = HText_TrueLineSize(text->last_line,text,IgnoreSpaces);
  }
  return local_c;
}



BOOLEAN HText_LastLineEmpty(HText *text,BOOLEAN IgnoreSpaces)

{
  BOOLEAN local_9;
  BOOLEAN IgnoreSpaces_local;
  
  if (((text == (HText *)0x0) || (text->last_line == (HTLine *)0x0)) || (text->last_line->size == 0)
     ) {
    local_9 = '\x01';
  }
  else {
    local_9 = HText_TrueEmptyLine(text->last_line,text,IgnoreSpaces);
  }
  return local_9;
}



// WARNING: Unknown calling convention

wchar_t HText_LastLineOffset(HText *text)

{
  wchar_t local_8;
  
  if ((text == (HText *)0x0) || (text->last_line == (HTLine *)0x0)) {
    local_8 = L'\0';
  }
  else {
    local_8 = (wchar_t)text->last_line->offset;
  }
  return local_8;
}



wchar_t HText_PreviousLineSize(HText *text,BOOLEAN IgnoreSpaces)

{
  HTLine *line_00;
  wchar_t local_1c;
  BOOLEAN IgnoreSpaces_local;
  HTLine *line;
  
  if ((text == (HText *)0x0) || (text->last_line == (HTLine *)0x0)) {
    local_1c = L'\0';
  }
  else {
    line_00 = text->last_line->prev;
    if (line_00 == (HTLine *)0x0) {
      local_1c = L'\0';
    }
    else {
      local_1c = HText_TrueLineSize(line_00,text,IgnoreSpaces);
    }
  }
  return local_1c;
}



BOOLEAN HText_PreviousLineEmpty(HText *text,BOOLEAN IgnoreSpaces)

{
  HTLine *line_00;
  BOOLEAN local_19;
  BOOLEAN IgnoreSpaces_local;
  HTLine *line;
  
  if ((text == (HText *)0x0) || (text->last_line == (HTLine *)0x0)) {
    local_19 = '\x01';
  }
  else {
    line_00 = text->last_line->prev;
    if (line_00 == (HTLine *)0x0) {
      local_19 = '\x01';
    }
    else {
      local_19 = HText_TrueEmptyLine(line_00,text,IgnoreSpaces);
    }
  }
  return local_19;
}



wchar_t HText_TrueLineSize(HTLine *line,HText *text,BOOLEAN IgnoreSpaces)

{
  ushort **ppuVar1;
  wchar_t local_1c;
  BOOLEAN IgnoreSpaces_local;
  wchar_t true_size;
  size_t i;
  
  true_size = L'\0';
  if ((line == (HTLine *)0x0) || (line->size == 0)) {
    local_1c = L'\0';
  }
  else {
    if (IgnoreSpaces == '\0') {
      for (i = 0; i < line->size; i = i + 1) {
        if (((line->data[i] < '\x03') || ('\b' < line->data[i])) &&
           ((text == (HText *)0x0 ||
            ((((text->T).output_utf8 == '\0' || (-1 < line->data[i])) ||
             ((line->data[i] & 0xc0U) == 0xc0)))))) {
          true_size = true_size + L'\x01';
        }
      }
    }
    else {
      for (i = 0; i < line->size; i = i + 1) {
        if (((((byte)line->data[i] < 3) || (8 < (byte)line->data[i])) &&
            (((text == (HText *)0x0 || (((text->T).output_utf8 == '\0' || (-1 < line->data[i])))) ||
             ((line->data[i] & 0xc0U) == 0xc0)))) &&
           (((ppuVar1 = __ctype_b_loc(), ((*ppuVar1)[(byte)line->data[i]] & 0x2000) == 0 &&
             (line->data[i] != '\x01')) && (line->data[i] != '\x02')))) {
          true_size = true_size + L'\x01';
        }
      }
    }
    local_1c = true_size;
  }
  return local_1c;
}



BOOLEAN HText_TrueEmptyLine(HTLine *line,HText *text,BOOLEAN IgnoreSpaces)

{
  ushort **ppuVar1;
  BOOLEAN IgnoreSpaces_local;
  size_t i;
  
  if ((line != (HTLine *)0x0) && (line->size != 0)) {
    if (IgnoreSpaces == '\0') {
      for (i = 0; i < line->size; i = i + 1) {
        if (((line->data[i] < '\x03') || ('\b' < line->data[i])) &&
           ((text == (HText *)0x0 ||
            ((((text->T).output_utf8 == '\0' || (-1 < line->data[i])) ||
             ((line->data[i] & 0xc0U) == 0xc0)))))) {
          return '\0';
        }
      }
    }
    else {
      for (i = 0; i < line->size; i = i + 1) {
        if (((((byte)line->data[i] < 3) || (8 < (byte)line->data[i])) &&
            (((text == (HText *)0x0 || (((text->T).output_utf8 == '\0' || (-1 < line->data[i])))) ||
             ((line->data[i] & 0xc0U) == 0xc0)))) &&
           (((ppuVar1 = __ctype_b_loc(), ((*ppuVar1)[(byte)line->data[i]] & 0x2000) == 0 &&
             (line->data[i] != '\x01')) && (line->data[i] != '\x02')))) {
          return '\0';
        }
      }
    }
  }
  return '\x01';
}



// WARNING: Unknown calling convention

void HText_NegateLineOne(HText *text)

{
  if (text != (HText *)0x0) {
    text->in_line_1 = '\0';
  }
  return;
}



// WARNING: Unknown calling convention

BOOLEAN HText_inLineOne(HText *text)

{
  BOOLEAN local_5;
  
  if (text == (HText *)0x0) {
    local_5 = '\x01';
  }
  else {
    local_5 = text->in_line_1;
  }
  return local_5;
}



// WARNING: Unknown calling convention

void HText_RemovePreviousLine(HText *text)

{
  _line *p_Var1;
  HTLine *previous;
  HTLine *line;
  
  if ((text != (HText *)0x0) && (L'\x01' < text->Lines)) {
    p_Var1 = text->last_line->prev->prev;
    p_Var1->next = text->last_line;
    text->last_line->prev = p_Var1;
    text->Lines = text->Lines + L'\xffffffff';
  }
  return;
}



// WARNING: Unknown calling convention

wchar_t HText_getCurrentColumn(HText *text)

{
  wchar_t wVar1;
  HTCoord local_18;
  wchar_t column;
  BOOLEAN IgnoreSpaces;
  
  column = L'\0';
  if (text != (HText *)0x0) {
    if (text->in_line_1 == '\0') {
      local_18 = text->style->leftIndent;
    }
    else {
      local_18 = text->style->indent1st;
    }
    wVar1 = HText_LastLineSize(text,'\0');
    column = local_18 + wVar1 + (uint)text->last_line->offset;
  }
  return column;
}



// WARNING: Unknown calling convention

wchar_t HText_getMaximumColumn(HText *text)

{
  wchar_t local_18;
  wchar_t column;
  
  if (LYwideLines == L'\0') {
    local_18 = LYcols;
  }
  else {
    local_18 = L'';
  }
  column = local_18;
  if (text != (HText *)0x0) {
    column = local_18 - text->style->rightIndent;
  }
  return column;
}



// WARNING: Unknown calling convention

void HText_setTabID(HText *text,char *name)

{
  HTList *pHVar1;
  int iVar2;
  wchar_t wVar3;
  HTTabID *local_18;
  HTList *last;
  HTList *cur;
  HTTabID *Tab;
  
  Tab = (HTTabID *)0x0;
  cur = text->tabs;
  last = (HTList *)0x0;
  if (((text != (HText *)0x0) && (name != (char *)0x0)) && (*name != '\0')) {
    if (cur == (HTList *)0x0) {
      pHVar1 = HTList_new();
      text->tabs = pHVar1;
      cur = text->tabs;
    }
    else {
      while( true ) {
        if ((cur == (HTList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
          local_18 = (HTTabID *)0x0;
        }
        else {
          local_18 = (HTTabID *)cur->object;
        }
        Tab = local_18;
        if (local_18 == (HTTabID *)0x0) break;
        if ((local_18->name != (char *)0x0) && (iVar2 = strcmp(local_18->name,name), iVar2 == 0)) {
          return;
        }
        last = cur;
      }
      if (last != (HTList *)0x0) {
        cur = last;
      }
    }
    if (Tab == (HTTabID *)0x0) {
      Tab = (HTTabID *)calloc(1,8);
      if (Tab == (HTTabID *)0x0) {
        outofmem("./GridText.c","HText_setTabID");
      }
      HTList_addObject(cur,Tab);
      HTSACopy((char **)Tab,name);
    }
    wVar3 = HText_getCurrentColumn(text);
    Tab->column = wVar3;
  }
  return;
}



// WARNING: Unknown calling convention

wchar_t HText_getTabIDColumn(HText *text,char *name)

{
  int iVar1;
  char **local_18;
  HTList *cur;
  HTTabID *Tab;
  wchar_t column;
  
  column = L'\0';
  cur = text->tabs;
  if ((((text != (HText *)0x0) && (name != (char *)0x0)) && (*name != '\0')) &&
     (cur != (HTList *)0x0)) {
    do {
      if ((cur == (HTList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
        local_18 = (char **)0x0;
      }
      else {
        local_18 = (char **)cur->object;
      }
    } while ((local_18 != (char **)0x0) &&
            ((*local_18 == (char *)0x0 || (iVar1 = strcmp(*local_18,name), iVar1 != 0))));
    if (local_18 != (char **)0x0) {
      column = (wchar_t)local_18[1];
    }
  }
  return column;
}



// WARNING: Unknown calling convention

void HText_AddHiddenLink(HText *text,TextAnchor *textanchor)

{
  HTList *pHVar1;
  HTAnchor *me;
  char *newObject;
  HTAnchor *dest;
  
  if (((text != (HText *)0x0) && (textanchor != (TextAnchor *)0x0)) &&
     (textanchor->anchor != (HTChildAnchor *)0x0)) {
    if (text->hidden_links == (HTList *)0x0) {
      pHVar1 = HTList_new();
      text->hidden_links = pHVar1;
    }
    me = HTAnchor_followLink(textanchor->anchor);
    if ((me != (HTAnchor *)0x0) &&
       (((text->hiddenlinkflag != L'\x02' || (text->hidden_links == (HTList *)0x0)) ||
        (text->hidden_links->next == (HTList *)0x0)))) {
      newObject = HTAnchor_address(me);
      HTList_appendObject(text->hidden_links,newObject);
    }
  }
  return;
}



// WARNING: Unknown calling convention

wchar_t HText_HiddenLinkCount(HText *text)

{
  wchar_t count;
  
  count = L'\0';
  if ((text != (HText *)0x0) && (text->hidden_links != (HTList *)0x0)) {
    count = HTList_count(text->hidden_links);
  }
  return count;
}



// WARNING: Unknown calling convention

char * HText_HiddenLinkAt(HText *text,wchar_t number)

{
  char *href;
  
  href = (char *)0x0;
  if (((text != (HText *)0x0) && (text->hidden_links != (HTList *)0x0)) && (L'\xffffffff' < number))
  {
    href = (char *)HTList_objectAt(text->hidden_links,number);
  }
  return href;
}



// WARNING: Unknown calling convention

void HText_beginForm(char *action,char *method,char *enctype,char *title,char *accept_cs)

{
  wchar_t wVar1;
  int iVar2;
  char *pcVar3;
  PerFormInfo *pPVar4;
  FILE *__stream;
  char *local_34;
  char *local_30;
  char *local_2c;
  char *local_28;
  char *local_24;
  char *local_20;
  PerFormInfo *newform;
  
  HTFormMethod = L'\x01';
  HTFormNumber = HTFormNumber + L'\x01';
  HTFormFields = L'\0';
  HTFormDisabled = '\0';
  if (action == (char *)0x0) {
    pcVar3 = HTLoadedDocumentURL();
    HTSACopy(&HTFormAction,pcVar3);
  }
  else {
    iVar2 = strncasecomp(action,"mailto:",7);
    if (iVar2 == 0) {
      HTFormMethod = L'\x03';
    }
    HTSACopy(&HTFormAction,action);
  }
  if (((method != (char *)0x0) && (HTFormMethod != L'\x03')) &&
     ((iVar2 = strcasecomp(method,"post"), iVar2 == 0 ||
      (iVar2 = strcasecomp(method,"pget"), iVar2 == 0)))) {
    HTFormMethod = L'\x02';
  }
  if ((enctype == (char *)0x0) || (*enctype == '\0')) {
    if (HTFormEnctype != (char *)0x0) {
      free(HTFormEnctype);
      HTFormEnctype = (char *)0x0;
    }
  }
  else {
    HTSACopy(&HTFormEnctype,enctype);
    if ((HTFormMethod != L'\x03') &&
       (iVar2 = strncasecomp(enctype,"multipart/form-data",0x13), iVar2 == 0)) {
      HTFormMethod = L'\x02';
    }
  }
  if ((title == (char *)0x0) || (*title == '\0')) {
    if (HTFormTitle != (char *)0x0) {
      free(HTFormTitle);
      HTFormTitle = (char *)0x0;
    }
  }
  else {
    HTSACopy(&HTFormTitle,title);
  }
  if (accept_cs != (char *)0x0) {
    HTSACopy(&HTFormAcceptCharset,accept_cs);
    LYRemoveBlanks(HTFormAcceptCharset);
    LYLowerCase(HTFormAcceptCharset);
  }
  pPVar4 = (PerFormInfo *)calloc(1,0x20);
  if (pPVar4 == (PerFormInfo *)0x0) {
    outofmem("./GridText.c","HText_beginForm");
  }
  pPVar4->number = HTFormNumber;
  PerFormInfo_free(HTCurrentForm);
  wVar1 = HTFormMethod;
  pcVar3 = HTFormAction;
  HTCurrentForm = pPVar4;
  if (WWW_TraceFlag != '\0') {
    if (HTFormAcceptCharset == (char *)0x0) {
      local_34 = "";
      local_30 = "";
    }
    else {
      local_30 = " Accept-charset:";
      local_34 = HTFormAcceptCharset;
    }
    if (HTFormEnctype == (char *)0x0) {
      local_2c = "";
      local_28 = "";
    }
    else {
      local_28 = " Enctype:";
      local_2c = HTFormEnctype;
    }
    if (HTFormTitle == (char *)0x0) {
      local_24 = "";
      local_20 = "";
    }
    else {
      local_20 = " Title:";
      local_24 = HTFormTitle;
    }
    __stream = TraceFP();
    fprintf((FILE *)__stream,"BeginForm: action:%s Method:%d%s%s%s%s%s%s\n",pcVar3,wVar1,local_20,
            local_24,local_28,local_2c,local_30,local_34);
  }
  return;
}



// WARNING: Unknown calling convention

void HText_endForm(HText *text)

{
  HTList *pHVar1;
  FILE *__stream;
  TextAnchor *a;
  
  if (((HTFormFields == L'\x01') && (text != (HText *)0x0)) &&
     (text->first_anchor != (TextAnchor *)0x0)) {
    for (a = text->first_anchor; a != (TextAnchor *)0x0; a = a->next) {
      if (((a->link_type == '\x02') && (a->input_field->number == HTFormNumber)) &&
         (a->input_field->type == L'\x01')) {
        a->input_field->submit_action = (char *)0x0;
        HTSACopy(&a->input_field->submit_action,HTFormAction);
        if (HTFormEnctype != (char *)0x0) {
          HTSACopy(&a->input_field->submit_enctype,HTFormEnctype);
        }
        if (HTFormTitle != (char *)0x0) {
          HTSACopy(&a->input_field->submit_title,HTFormTitle);
        }
        a->input_field->submit_method = HTFormMethod;
        a->input_field->type = L'\f';
        if (HTFormDisabled != '\0') {
          a->input_field->disabled = L'\x01';
        }
        break;
      }
    }
  }
  if (HTCurrentForm == (PerFormInfo *)0x0) {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"endForm:    HTCurrentForm is missing!\n");
    }
  }
  else {
    if (HTFormDisabled != '\0') {
      HTCurrentForm->disabled = L'\x01';
    }
    HTCurrentForm->accept_cs = HTFormAcceptCharset;
    HTFormAcceptCharset = (char *)0x0;
    if (text->forms == (HTList *)0x0) {
      pHVar1 = HTList_new();
      text->forms = pHVar1;
    }
    HTList_appendObject(text->forms,HTCurrentForm);
    HTCurrentForm = (PerFormInfo *)0x0;
  }
  if (HTCurSelectGroup != (char *)0x0) {
    free(HTCurSelectGroup);
    HTCurSelectGroup = (char *)0x0;
  }
  if (HTCurSelectGroupSize != (char *)0x0) {
    free(HTCurSelectGroupSize);
    HTCurSelectGroupSize = (char *)0x0;
  }
  if (HTCurSelectedOptionValue != (char *)0x0) {
    free(HTCurSelectedOptionValue);
    HTCurSelectedOptionValue = (char *)0x0;
  }
  if (HTFormAction != (char *)0x0) {
    free(HTFormAction);
    HTFormAction = (char *)0x0;
  }
  if (HTFormEnctype != (char *)0x0) {
    free(HTFormEnctype);
    HTFormEnctype = (char *)0x0;
  }
  if (HTFormTitle != (char *)0x0) {
    free(HTFormTitle);
    HTFormTitle = (char *)0x0;
  }
  if (HTFormAcceptCharset != (char *)0x0) {
    free(HTFormAcceptCharset);
    HTFormAcceptCharset = (char *)0x0;
  }
  HTFormFields = L'\0';
  HTFormDisabled = '\0';
  return;
}



void HText_beginSelect(char *name,wchar_t name_cs,BOOLEAN multiple,char *size)

{
  wchar_t wVar1;
  FILE *pFVar2;
  char *local_1c;
  char *local_14;
  char *local_10;
  BOOLEAN multiple_local;
  
  HTSACopy(&HTCurSelectGroup,name);
  HTCurSelectGroupCharset = name_cs;
  if (multiple == '\0') {
    HTCurSelectGroupType = L'\x04';
  }
  else {
    HTCurSelectGroupType = L'\x03';
  }
  HTSACopy(&HTCurSelectGroupSize,size);
  wVar1 = HTCurSelectGroupType;
  if (WWW_TraceFlag != '\0') {
    if (HTCurSelectGroupSize == (char *)0x0) {
      local_1c = "<NULL>";
    }
    else {
      local_1c = HTCurSelectGroupSize;
    }
    if (HTCurSelectGroup == (char *)0x0) {
      local_14 = "<NULL>";
    }
    else {
      local_14 = HTCurSelectGroup;
    }
    pFVar2 = TraceFP();
    fprintf((FILE *)pFVar2,"HText_beginSelect: name=%s type=%d size=%s\n",local_14,wVar1,local_1c);
  }
  wVar1 = HTCurSelectGroupCharset;
  if (WWW_TraceFlag != '\0') {
    if (HTCurSelectGroupCharset < L'\0') {
      local_10 = "<UNKNOWN>";
    }
    else {
      local_10 = LYCharSet_UC[HTCurSelectGroupCharset].MIMEname;
    }
    pFVar2 = TraceFP();
    fprintf((FILE *)pFVar2,"HText_beginSelect: name_cs=%d \"%s\"\n",wVar1,local_10);
  }
  return;
}



// WARNING: Unknown calling convention

wchar_t HText_getOptionNum(HText *text)

{
  TextAnchor *pTVar1;
  FILE *__stream;
  wchar_t local_18;
  wchar_t n;
  OptionType_conflict *op;
  TextAnchor *a;
  
  n = L'\x01';
  if ((text == (HText *)0x0) || (text->last_anchor == (TextAnchor *)0x0)) {
    local_18 = L'\0';
  }
  else {
    pTVar1 = text->last_anchor;
    if ((pTVar1->link_type == '\x02') &&
       ((pTVar1->input_field != (FormInfo *)0x0 && (pTVar1->input_field->type == L'\a')))) {
      for (op = pTVar1->input_field->select_list; op != (OptionType_conflict *)0x0; op = op->next) {
        n = n + L'\x01';
      }
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HText_getOptionNum: Got number \'%d\'.\n",n);
      }
      local_18 = n;
    }
    else {
      local_18 = L'\0';
    }
  }
  return local_18;
}



// WARNING: Unknown calling convention

char * HText_skipOptionNumPrefix(char *opname)

{
  char cVar1;
  ushort **ppuVar2;
  wchar_t i;
  char *cp;
  
  if ((keypad_mode != 3) && (keypad_mode != 2)) {
    return opname;
  }
  if ((((opname != (char *)0x0) && (*opname != '\0')) && (*opname == '(')) && (opname[1] != 0)) {
    ppuVar2 = __ctype_b_loc();
    cp = opname + 2;
    if (((*ppuVar2)[(byte)opname[1]] & 0x800) != 0) {
      while ((*cp != '\0' && (ppuVar2 = __ctype_b_loc(), ((*ppuVar2)[(byte)*cp] & 0x800) != 0))) {
        cp = cp + 1;
      }
      if ((*cp == '\0') || (cVar1 = *cp, cp = cp + 1, cVar1 != ')')) {
        return opname;
      }
      i = (int)cp - (int)opname;
      for (; (i < L'\x05' && (*cp == '_')); cp = cp + 1) {
        i = i + L'\x01';
      }
      if (L'\x04' < i) {
        return cp;
      }
      return opname;
    }
  }
  return opname;
}



char * HText_setLastOptionValue
                 (HText *text,char *value,char *submit_value,wchar_t order,BOOLEAN checked,
                 wchar_t val_cs,wchar_t submit_val_cs)

{
  FormInfo *pFVar1;
  bool bVar2;
  FILE *pFVar3;
  size_t sVar4;
  ushort **ppuVar5;
  char *pcVar6;
  OptionType_conflict *pOVar7;
  uchar *sjis;
  wchar_t wVar8;
  char *local_8c;
  char *local_88;
  undefined *local_84;
  char *local_80;
  wchar_t local_78;
  char *local_74;
  wchar_t local_70;
  size_t local_6c;
  char *local_68;
  size_t local_64;
  char *local_60;
  char *local_5c;
  char *local_58;
  char *local_54;
  char *local_50;
  BOOLEAN checked_local;
  FormInfo *last_input_1;
  wchar_t newlen_1;
  wchar_t curlen_1;
  wchar_t curlen;
  wchar_t newlen;
  FormInfo *last_input;
  OptionType_conflict *new_ptr;
  OptionType_conflict *op_ptr;
  wchar_t j;
  wchar_t i;
  wchar_t number;
  uchar *tmp;
  char *ret_Value;
  char *cp1;
  char *cp;
  BOOLEAN first_option;
  
  ret_Value = (char *)0x0;
  number = L'\0';
  if ((((value == (char *)0x0) || (text == (HText *)0x0)) ||
      (text->last_anchor == (TextAnchor *)0x0)) ||
     ((text->last_anchor->input_field == (FormInfo *)0x0 || (text->last_anchor->link_type != '\x02')
      ))) {
    if (WWW_TraceFlag != '\0') {
      if (value == (char *)0x0) {
        local_8c = "<NULL>";
      }
      else {
        local_8c = value;
      }
      pFVar3 = TraceFP();
      fprintf((FILE *)pFVar3,"HText_setLastOptionValue: invalid call!  value:%s!\n",local_8c);
    }
    local_88 = (char *)0x0;
  }
  else {
    if (WWW_TraceFlag != '\0') {
      if (checked == '\0') {
        local_84 = &DAT_0814e05f;
      }
      else {
        local_84 = &DAT_0814e05c;
      }
      pFVar3 = TraceFP();
      fprintf((FILE *)pFVar3,"Entering HText_setLastOptionValue: value:\"%s\", checked:%s\n",value,
              local_84);
    }
    if (*value != '\0') {
      sVar4 = strlen(value);
      for (cp = value + (sVar4 - 1);
          (value <= cp &&
          ((ppuVar5 = __ctype_b_loc(), ((*ppuVar5)[(byte)*cp] & 0x2000) != 0 ||
           ((2 < (byte)*cp && ((byte)*cp < 9)))))); cp = cp + -1) {
      }
      cp[1] = '\0';
    }
    for (cp = value;
        (ppuVar5 = __ctype_b_loc(), ((*ppuVar5)[(byte)*cp] & 0x2000) != 0 ||
        ((2 < (byte)*cp && ((byte)*cp < 9)))); cp = cp + 1) {
    }
    if ((((HTCurSelectGroupType == L'\x04') && (LYSelectPopups != '\0')) &&
        ((keypad_mode == 3 || (keypad_mode == 2)))) &&
       (pcVar6 = HText_skipOptionNumPrefix(cp), cp < pcVar6)) {
      j = (int)pcVar6 - (int)cp;
      for (i = L'\0';
          (ppuVar5 = __ctype_b_loc(), ((*ppuVar5)[(byte)pcVar6[i]] & 0x2000) != 0 ||
          ((2 < (byte)pcVar6[i] && ((byte)pcVar6[i] < 9)))); i = i + L'\x01') {
      }
      if (L'\0' < i) {
        for (; pcVar6[i] != '\0'; i = i + L'\x01') {
          cp[j] = pcVar6[i];
          j = j + L'\x01';
        }
        cp[j] = '\0';
      }
    }
    if (HTCurSelectGroupType == L'\x03') {
      HTSACopy(&text->last_anchor->input_field->value,cp);
      text->last_anchor->input_field->value_cs = val_cs;
      HText_appendText(text,cp);
    }
    else if (LYSelectPopups == '\0') {
      if (submit_value == (char *)0x0) {
        local_80 = cp;
      }
      else {
        local_80 = submit_value;
      }
      HTSACopy(&text->last_anchor->input_field->value,local_80);
      if (submit_value == (char *)0x0) {
        local_78 = val_cs;
      }
      else {
        local_78 = submit_val_cs;
      }
      text->last_anchor->input_field->value_cs = local_78;
      HText_appendText(text,cp);
    }
    else {
      op_ptr = text->last_anchor->input_field->select_list;
      bVar2 = false;
      LYReduceBlanks(value);
      if (op_ptr == (OptionType_conflict *)0x0) {
        if (text->last_anchor->input_field->type != L'\a') {
          if (WWW_TraceFlag != '\0') {
            pFVar3 = TraceFP();
            fprintf((FILE *)pFVar3,
                    "HText_setLastOptionValue: last input_field not F_OPTION_LIST_TYPE (%d)\n",7);
          }
          if (WWW_TraceFlag != '\0') {
            wVar8 = text->last_anchor->input_field->type;
            pFVar3 = TraceFP();
            fprintf((FILE *)pFVar3,"                          but %d, ignoring!\n",wVar8);
          }
          return (char *)0x0;
        }
        pFVar1 = text->last_anchor->input_field;
        pOVar7 = (OptionType_conflict *)calloc(1,0x10);
        pFVar1->select_list = pOVar7;
        new_ptr = pFVar1->select_list;
        if (new_ptr == (OptionType_conflict *)0x0) {
          outofmem("./GridText.c","HText_setLastOptionValue");
        }
        bVar2 = true;
      }
      else {
        for (; op_ptr->next != (_OptionType_conflict *)0x0; op_ptr = op_ptr->next) {
          number = number + L'\x01';
        }
        number = number + L'\x01';
        new_ptr = (OptionType_conflict *)calloc(1,0x10);
        op_ptr->next = new_ptr;
        if (new_ptr == (OptionType_conflict *)0x0) {
          outofmem("./GridText.c","HText_setLastOptionValue");
        }
      }
      new_ptr->name = (char *)0x0;
      new_ptr->cp_submit_value = (char *)0x0;
      new_ptr->next = (_OptionType_conflict *)0x0;
      for (cp = value;
          (ppuVar5 = __ctype_b_loc(), ((*ppuVar5)[(byte)*cp] & 0x2000) != 0 ||
          ((2 < (byte)*cp && ((byte)*cp < 9)))); cp = cp + 1) {
      }
      j = L'\0';
      for (i = L'\0'; cp[i] != '\0'; i = i + L'\x01') {
        if ((cp[i] == '\x01') || (cp[i] == '\x02')) {
          cp[j] = ' ';
          j = j + L'\x01';
        }
        else if ((cp[i] != '\a') && (((byte)cp[i] < 3 || (8 < (byte)cp[i])))) {
          cp[j] = cp[i];
          j = j + L'\x01';
        }
      }
      cp[j] = '\0';
      if (HTCJK == NOCJK) {
        HTSACopy(&new_ptr->name,cp);
      }
      else if (cp != (char *)0x0) {
        sVar4 = strlen(cp);
        sjis = (uchar *)calloc(sVar4 * 2 + 1,1);
        if (sjis != (uchar *)0x0) {
          if (sjis == (uchar *)0x0) {
            outofmem("./GridText.c","HText_setLastOptionValue");
          }
          if (kanji_code == EUC) {
            TO_EUC((uchar *)cp,sjis);
            val_cs = current_char_set;
          }
          else if (kanji_code == SJIS) {
            TO_SJIS((uchar *)cp,sjis);
            val_cs = current_char_set;
          }
          else {
            j = L'\0';
            for (i = L'\0'; cp[i] != '\0'; i = i + L'\x01') {
              if (cp[i] != '\x1b') {
                sjis[j] = cp[i];
                j = j + L'\x01';
              }
            }
          }
          HTSACopy(&new_ptr->name,(char *)sjis);
          if (sjis != (uchar *)0x0) {
            free(sjis);
          }
        }
      }
      if (submit_value == (char *)0x0) {
        local_74 = HText_skipOptionNumPrefix(new_ptr->name);
      }
      else {
        local_74 = submit_value;
      }
      HTSACopy(&new_ptr->cp_submit_value,local_74);
      if (submit_value == (char *)0x0) {
        local_70 = val_cs;
      }
      else {
        local_70 = submit_val_cs;
      }
      new_ptr->value_cs = local_70;
      if (bVar2) {
        pFVar1 = text->last_anchor->input_field;
        HTSACopy(&HTCurSelectedOptionValue,new_ptr->name);
        pFVar1->num_value = L'\0';
        if (pFVar1->value != (char *)0x0) {
          free(pFVar1->value);
          pFVar1->value = (char *)0x0;
        }
        if (pFVar1->cp_submit_value != (char *)0x0) {
          free(pFVar1->cp_submit_value);
          pFVar1->cp_submit_value = (char *)0x0;
        }
        pFVar1->value = pFVar1->select_list->name;
        pFVar1->orig_value = pFVar1->select_list->name;
        pFVar1->cp_submit_value = pFVar1->select_list->cp_submit_value;
        pFVar1->orig_submit_value = pFVar1->select_list->cp_submit_value;
        pFVar1->value_cs = new_ptr->value_cs;
      }
      else {
        sVar4 = strlen(new_ptr->name);
        if (HTCurSelectedOptionValue == (char *)0x0) {
          local_6c = 0;
        }
        else {
          local_6c = strlen(HTCurSelectedOptionValue);
        }
        if ((int)local_6c < (int)sVar4) {
          if ((int)(sVar4 - local_6c) < 0x400) {
            local_68 = underscore_string + (local_6c - sVar4) + 0x3ff;
          }
          else {
            local_68 = underscore_string;
          }
          HTSACat(&HTCurSelectedOptionValue,local_68);
        }
      }
      if (checked != '\0') {
        sVar4 = strlen(new_ptr->name);
        if (HTCurSelectedOptionValue == (char *)0x0) {
          local_64 = 0;
        }
        else {
          local_64 = strlen(HTCurSelectedOptionValue);
        }
        pFVar1 = text->last_anchor->input_field;
        pFVar1->num_value = number;
        pFVar1->value = new_ptr->name;
        pFVar1->orig_value = new_ptr->name;
        pFVar1->cp_submit_value = new_ptr->cp_submit_value;
        pFVar1->orig_submit_value = new_ptr->cp_submit_value;
        pFVar1->value_cs = new_ptr->value_cs;
        HTSACopy(&HTCurSelectedOptionValue,new_ptr->name);
        if ((int)sVar4 < (int)local_64) {
          if ((int)(local_64 - sVar4) < 0x400) {
            local_60 = underscore_string + (sVar4 - local_64) + 0x3ff;
          }
          else {
            local_60 = underscore_string;
          }
          HTSACat(&HTCurSelectedOptionValue,local_60);
        }
      }
      if (order == L'\x03') {
        if (HTCurSelectedOptionValue == (char *)0x0) {
          HTSACopy(&HTCurSelectedOptionValue,"");
        }
        pFVar1 = text->last_anchor->input_field;
        wVar8 = strlen(HTCurSelectedOptionValue);
        pFVar1->size = wVar8;
        ret_Value = HTCurSelectedOptionValue;
      }
    }
    if (WWW_TraceFlag != '\0') {
      if (WWW_TraceFlag != '\0') {
        if (order == L'\x03') {
          local_5c = " LAST_ORDER";
        }
        else {
          local_5c = "";
        }
        pFVar3 = TraceFP();
        fprintf((FILE *)pFVar3,"HText_setLastOptionValue:%s value=\"%s\"\n",local_5c,value);
      }
      if (WWW_TraceFlag != '\0') {
        if (val_cs < L'\0') {
          local_58 = "<UNKNOWN>";
        }
        else {
          local_58 = LYCharSet_UC[val_cs].MIMEname;
        }
        pFVar3 = TraceFP();
        fprintf((FILE *)pFVar3,"            val_cs=%d \"%s\"",val_cs,local_58);
      }
      if (submit_value == (char *)0x0) {
        if (WWW_TraceFlag != '\0') {
          pFVar3 = TraceFP();
          fprintf((FILE *)pFVar3,"\n");
        }
      }
      else if (WWW_TraceFlag != '\0') {
        if (HTCurSelectGroupType == L'\x03') {
          local_54 = "(ignored)";
        }
        else {
          local_54 = "";
        }
        if (submit_val_cs < L'\0') {
          local_50 = "<UNKNOWN>";
        }
        else {
          local_50 = LYCharSet_UC[submit_val_cs].MIMEname;
        }
        pFVar3 = TraceFP();
        fprintf((FILE *)pFVar3," (submit_val_cs %d \"%s\") submit_value%s=\"%s\"\n",submit_val_cs,
                local_50,local_54,submit_value);
      }
    }
    local_88 = ret_Value;
  }
  return local_88;
}



wchar_t HText_beginInput(HText *text,BOOLEAN underline,InputFieldData *I)

{
  int iVar1;
  char *pcVar2;
  wchar_t wVar3;
  FILE *pFVar4;
  wchar_t wVar5;
  int iVar6;
  size_t sVar7;
  uchar *sjis;
  uint uVar8;
  HTList *pHVar9;
  int in_GS_OFFSET;
  char *local_ac;
  wchar_t local_a8;
  wchar_t local_a4;
  char *local_a0;
  byte local_9c;
  char *local_98;
  int local_94;
  int local_90;
  int local_8c;
  byte local_88;
  char *local_80;
  char *local_7c;
  char *local_74;
  char *local_70;
  char *local_68;
  InputFieldData *I_local;
  BOOLEAN underline_local;
  HText *text_local;
  wchar_t i2;
  TextAnchor *b;
  wchar_t MaximumSize;
  wchar_t adjust_marker;
  wchar_t j;
  wchar_t i;
  uchar *tmp;
  char *IValue;
  char *cp_option;
  FormInfo *f;
  TextAnchor *a;
  BOOLEAN had_bracket;
  char marker [16];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  cp_option = (char *)0x0;
  IValue = (char *)0x0;
  adjust_marker = L'\0';
  if (WWW_TraceFlag != '\0') {
    if (I->type == (char *)0x0) {
      local_ac = "";
    }
    else {
      local_ac = I->type;
    }
    pFVar4 = TraceFP();
    fprintf((FILE *)pFVar4,"GridText: Entering HText_beginInput type=%s\n",local_ac);
  }
  a = (TextAnchor *)ALLOC_IN_POOL(&HTMainText->pool,0x34);
  f = (FormInfo *)ALLOC_IN_POOL(&HTMainText->pool,0x60);
  if ((a == (TextAnchor *)0x0) || (f == (FormInfo *)0x0)) {
    outofmem("./GridText.c","HText_beginInput");
  }
  wVar5 = SGML_offset();
  a->sgml_offset = wVar5;
  a->inUnderline = underline;
  a->line_num = text->Lines;
  a->line_pos = text->last_line->size;
  if (I->type != (char *)0x0) {
    iVar6 = strcmp(I->type,"OPTION");
    if (((iVar6 == 0) && (HTCurSelectGroupType == L'\x04')) && (LYSelectPopups == '\0')) {
      I->type = "RADIO";
      I->name = HTCurSelectGroup;
      I->name_cs = HTCurSelectGroupCharset;
    }
  }
  if ((I->name != (char *)0x0) && (I->type != (char *)0x0)) {
    iVar6 = strcasecomp(I->type,"radio");
    if (iVar6 == 0) {
      if (text->last_anchor == (TextAnchor *)0x0) {
        I->checked = L'\x01';
      }
      else {
        i2 = L'\0';
        for (b = text->first_anchor; b != (TextAnchor *)0x0; b = b->next) {
          if (((b->link_type == '\x02') && (b->input_field->type == L'\x04')) &&
             (b->input_field->number == HTFormNumber)) {
            iVar6 = strcmp(b->input_field->name,I->name);
            if (iVar6 == 0) {
              if ((I->checked != L'\0') && (b->input_field->num_value != L'\0')) {
                b->input_field->num_value = L'\0';
                HTSACopy(&b->input_field->orig_value,"0");
                break;
              }
              i2 = i2 + L'\x01';
            }
          }
        }
        if (i2 == L'\0') {
          I->checked = L'\x01';
        }
      }
    }
  }
  a->next = (_TextAnchor *)0x0;
  a->anchor = (HTChildAnchor *)0x0;
  a->link_type = '\x02';
  a->show_anchor = '\x01';
  LYClearHiText(a);
  a->extent = 2;
  a->input_field = f;
  f->select_list = (OptionType_conflict *)0x0;
  f->number = HTFormNumber;
  if ((HTFormDisabled == '\0') && (I->disabled == L'\0')) {
    local_a8 = L'\0';
  }
  else {
    local_a8 = L'\x01';
  }
  f->disabled = local_a8;
  f->no_cache = '\0';
  HTFormFields = HTFormFields + L'\x01';
  if (HTFormMethod == L'\x02') {
    f->no_cache = '\x01';
  }
  if (I->value != (char *)0x0) {
    HTSACopy(&IValue,I->value);
  }
  if ((IValue != (char *)0x0) && (HTCJK != NOCJK)) {
    if (I->type != (char *)0x0) {
      iVar6 = strcasecomp(I->type,"hidden");
      if (iVar6 == 0) goto LAB_0806e574;
    }
    sVar7 = strlen(IValue);
    sjis = (uchar *)calloc(sVar7 * 2 + 1,1);
    if (sjis != (uchar *)0x0) {
      if (kanji_code == EUC) {
        TO_EUC((uchar *)IValue,sjis);
        I->value_cs = current_char_set;
      }
      else if (kanji_code == SJIS) {
        TO_SJIS((uchar *)IValue,sjis);
        I->value_cs = current_char_set;
      }
      else {
        j = L'\0';
        for (i = L'\0'; IValue[i] != '\0'; i = i + L'\x01') {
          if (IValue[i] != '\x1b') {
            sjis[j] = IValue[i];
            j = j + L'\x01';
          }
        }
      }
      HTSACopy(&IValue,(char *)sjis);
      if (sjis != (uchar *)0x0) {
        free(sjis);
      }
    }
  }
LAB_0806e574:
  if (I->type != (char *)0x0) {
    iVar6 = strcmp(I->type,"OPTION");
    if (iVar6 == 0) {
      cp_option = I->type;
      if (HTCurSelectGroupType == L'\x04') {
        I->type = "OPTION_LIST";
      }
      else {
        I->type = "CHECKBOX";
      }
      I->name = HTCurSelectGroup;
      I->name_cs = HTCurSelectGroupCharset;
      if (HTCurSelectGroupSize != (char *)0x0) {
        wVar5 = atoi(HTCurSelectGroupSize);
        f->size_l = wVar5;
        if (HTCurSelectGroupSize != (char *)0x0) {
          free(HTCurSelectGroupSize);
          HTCurSelectGroupSize = (char *)0x0;
        }
      }
    }
  }
  if (I->size == L'\0') {
    f->size = L'\x14';
  }
  else {
    f->size = I->size;
    if ((f->size == L'\0') && (cp_option == (char *)0x0)) {
      f->size = L'\x14';
    }
  }
  if (I->maxlength == (char *)0x0) {
    f->maxlength = 0;
  }
  else {
    uVar8 = atoi(I->maxlength);
    f->maxlength = uVar8;
  }
  if (I->checked == L'\x01') {
    f->num_value = L'\x01';
  }
  else {
    f->num_value = L'\0';
  }
  if (I->type == (char *)0x0) {
    f->type = L'\x01';
  }
  else {
    iVar6 = strcasecomp(I->type,"password");
    if (iVar6 == 0) {
      f->type = L'\x02';
    }
    else {
      iVar6 = strcasecomp(I->type,"checkbox");
      if (iVar6 == 0) {
        f->type = L'\x03';
      }
      else {
        iVar6 = strcasecomp(I->type,"radio");
        if (iVar6 == 0) {
          f->type = L'\x04';
        }
        else {
          iVar6 = strcasecomp(I->type,"submit");
          if (iVar6 == 0) {
            f->type = L'\x05';
          }
          else {
            iVar6 = strcasecomp(I->type,"image");
            if (iVar6 == 0) {
              f->type = L'\r';
            }
            else {
              iVar6 = strcasecomp(I->type,"reset");
              if (iVar6 == 0) {
                f->type = L'\x06';
              }
              else {
                iVar6 = strcasecomp(I->type,"OPTION_LIST");
                if (iVar6 == 0) {
                  f->type = L'\a';
                }
                else {
                  iVar6 = strcasecomp(I->type,"hidden");
                  if (iVar6 == 0) {
                    f->type = L'\b';
                    HTFormFields = HTFormFields + L'\xffffffff';
                    f->size = L'\0';
                  }
                  else {
                    iVar6 = strcasecomp(I->type,"textarea");
                    if (iVar6 == 0) {
                      f->type = L'\t';
                    }
                    else {
                      iVar6 = strcasecomp(I->type,"range");
                      if (iVar6 == 0) {
                        f->type = L'\n';
                      }
                      else {
                        iVar6 = strcasecomp(I->type,"file");
                        if (iVar6 == 0) {
                          f->type = L'\v';
                          if (WWW_TraceFlag != '\0') {
                            pFVar4 = TraceFP();
                            fprintf((FILE *)pFVar4,"ok, got a file uploader\n");
                          }
                        }
                        else {
                          iVar6 = strcasecomp(I->type,"keygen");
                          if (iVar6 == 0) {
                            f->type = L'\x0e';
                          }
                          else {
                            f->type = L'\x01';
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (I->name == (char *)0x0) {
    if (((f->type != L'\x06') && (f->type != L'\x05')) && (f->type != L'\r')) {
      if (WWW_TraceFlag != '\0') {
        pFVar4 = TraceFP();
        fprintf((FILE *)pFVar4,"GridText: No name present in input field; not displaying\n");
      }
      if (IValue != (char *)0x0) {
        free(IValue);
        IValue = (char *)0x0;
      }
      local_a4 = L'\0';
      goto LAB_0806f27d;
    }
    HTSACopy(&f->name,"");
  }
  else {
    HTSACopy(&f->name,I->name);
    f->name_cs = I->name_cs;
  }
  if (text->last_anchor == (TextAnchor *)0x0) {
    text->first_anchor = a;
  }
  else {
    text->last_anchor->next = a;
  }
  if (IValue == (char *)0x0) {
    if (f->type != L'\a') {
      HTSACopy(&f->value,"");
      f->value_cs = current_char_set;
    }
  }
  else {
    if ((f->type == L'\a') || (f->type == L'\x03')) {
      HTSACopy(&f->value,IValue);
      HTSACopy(&f->cp_submit_value,IValue);
    }
    else {
      HTSACopy(&f->value,IValue);
    }
    f->value_cs = I->value_cs;
  }
  if (f->type == L'\x06') {
    if ((f->value == (char *)0x0) || (*f->value == '\0')) {
      HTSACopy(&f->value,"Reset");
      f->size = L'\x05';
    }
    else {
      wVar5 = strlen(f->value);
      f->size = wVar5;
    }
  }
  else if ((f->type == L'\r') || (f->type == L'\x05')) {
    if ((f->value == (char *)0x0) || (*f->value == '\0')) {
      if (f->type == L'\r') {
        HTSACopy(&f->value,"[IMAGE]-Submit");
        f->size = L'\x0e';
      }
      else {
        HTSACopy(&f->value,"Submit");
        f->size = L'\x06';
      }
    }
    else {
      wVar5 = strlen(f->value);
      f->size = wVar5;
    }
    f->submit_action = (char *)0x0;
    HTSACopy(&f->submit_action,HTFormAction);
    if (HTFormEnctype != (char *)0x0) {
      HTSACopy(&f->submit_enctype,HTFormEnctype);
    }
    if (HTFormTitle != (char *)0x0) {
      HTSACopy(&f->submit_title,HTFormTitle);
    }
    f->submit_method = HTFormMethod;
  }
  else if (((f->type == L'\x04') || (f->type == L'\x03')) &&
          (f->size = L'\x03', IValue == (char *)0x0)) {
    if (f->type == L'\x03') {
      local_a0 = "on";
    }
    else {
      local_a0 = "";
    }
    HTSACopy(&f->value,local_a0);
  }
  if (IValue != (char *)0x0) {
    free(IValue);
    IValue = (char *)0x0;
  }
  if ((f->type == L'\x04') || (f->type == L'\x03')) {
    if (f->num_value == L'\0') {
      HTSACopy(&f->orig_value,"0");
    }
    else {
      HTSACopy(&f->orig_value,"1");
    }
  }
  else if (f->type == L'\a') {
    f->orig_value = (char *)0x0;
  }
  else {
    HTSACopy(&f->orig_value,f->value);
  }
  if (I->accept_cs != (char *)0x0) {
    HTSACopy(&f->accept_cs,I->accept_cs);
    LYRemoveBlanks(f->accept_cs);
    LYLowerCase(f->accept_cs);
  }
  if (((uint)f->type < 0xf) && (local_9c = (byte)f->type, (1 << (local_9c & 0x1f) & 0x4500U) != 0))
  {
    a->number = L'\0';
  }
  else if ((keypad_mode == 3) || (keypad_mode == 2)) {
    text->last_anchor_number = text->last_anchor_number + L'\x01';
    a->number = text->last_anchor_number;
  }
  else {
    a->number = L'\0';
  }
  if (((keypad_mode == 3) || (keypad_mode == 2)) && (L'\0' < a->number)) {
    sprintf(marker,"[%d]",a->number);
    adjust_marker = strlen(marker);
    if (number_fields_on_left != '\0') {
      had_bracket = f->type == L'\a';
      if ((bool)had_bracket) {
        local_98 = marker + 1;
      }
      else {
        local_98 = marker;
      }
      HText_appendText(text,local_98);
      if (had_bracket != '\0') {
        HText_appendCharacter(text,L'[');
      }
    }
    a->line_num = text->Lines;
    a->line_pos = text->last_line->size;
  }
  else {
    marker[0] = '\0';
  }
  if (text->stbl == (STable_info *)0x0) {
    local_90 = LYcols - (uint)(LYShowScrollbar != '\0');
  }
  else {
    if (LYtableCols < L'\x01') {
      if (LYwideLines == L'\0') {
        local_8c = LYcols;
      }
      else {
        local_8c = 0x3f6;
      }
      local_90 = local_8c;
    }
    else {
      local_90 = (LYtableCols * LYcols) / 0xc;
    }
    local_90 = local_90 - (uint)(LYShowScrollbar != '\0');
  }
  local_94 = local_90 + 1;
  if (((uint)f->type < 0xe) && (local_88 = (byte)f->type, (1 << (local_88 & 0x1f) & 0x2262U) != 0))
  {
    MaximumSize = (local_94 - adjust_marker) + (~text->style->leftIndent - text->style->rightIndent)
    ;
    if ((keypad_mode == 3) || (keypad_mode == 2)) {
      if ((number_fields_on_left == '\0') &&
         ((f->type == L'\x01' && (a->line_pos + L'\n' < MaximumSize)))) {
        MaximumSize = MaximumSize - a->line_pos;
      }
      else {
        sVar7 = strlen(marker);
        MaximumSize = MaximumSize - sVar7;
      }
    }
    I->value = f->value;
  }
  else {
    MaximumSize = (local_94 - adjust_marker) + L'\xfffffff6';
  }
  if (MaximumSize < L'\x01') {
    MaximumSize = L'\x01';
  }
  if (MaximumSize < f->size) {
    f->size = MaximumSize;
  }
  text->last_anchor = a;
  if (HTCurrentForm == (PerFormInfo *)0x0) {
    if (WWW_TraceFlag != '\0') {
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"beginInput: HTCurrentForm is missing!\n");
    }
  }
  else {
    if (HTCurrentForm->first_field == (FormInfo *)0x0) {
      HTCurrentForm->first_field = f;
    }
    HTCurrentForm->last_field = f;
    HTCurrentForm->nfields = HTCurrentForm->nfields + L'\x01';
    if ((f->accept_cs != (char *)0x0) && (HTFormAcceptCharset == (char *)0x0)) {
      HTSACopy(&HTFormAcceptCharset,f->accept_cs);
    }
    if (text->forms == (HTList *)0x0) {
      pHVar9 = HTList_new();
      text->forms = pHVar9;
    }
  }
  if (WWW_TraceFlag != '\0') {
    wVar5 = f->size;
    if (f->value == (char *)0x0) {
      local_80 = "";
    }
    else {
      local_80 = f->value;
    }
    pcVar2 = f->name;
    pFVar4 = TraceFP();
    fprintf((FILE *)pFVar4,"Input link: name=%s\nvalue=%s\nsize=%d\n",pcVar2,local_80,wVar5);
  }
  if (WWW_TraceFlag != '\0') {
    if (I->name_cs < L'\0') {
      local_7c = "<UNKNOWN>";
    }
    else {
      local_7c = LYCharSet_UC[I->name_cs].MIMEname;
    }
    wVar5 = I->name_cs;
    if (f->name_cs < L'\0') {
      local_74 = "<UNKNOWN>";
    }
    else {
      local_74 = LYCharSet_UC[f->name_cs].MIMEname;
    }
    wVar3 = f->name_cs;
    pFVar4 = TraceFP();
    fprintf((FILE *)pFVar4,"Input link: name_cs=%d \"%s\" (from %d \"%s\")\n",wVar3,local_74,wVar5,
            local_7c);
  }
  if (WWW_TraceFlag != '\0') {
    if (I->value_cs < L'\0') {
      local_70 = "<UNKNOWN>";
    }
    else {
      local_70 = LYCharSet_UC[I->value_cs].MIMEname;
    }
    wVar5 = I->value_cs;
    if (f->value_cs < L'\0') {
      local_68 = "<UNKNOWN>";
    }
    else {
      local_68 = LYCharSet_UC[f->value_cs].MIMEname;
    }
    wVar3 = f->value_cs;
    pFVar4 = TraceFP();
    fprintf((FILE *)pFVar4,"            value_cs=%d \"%s\" (from %d \"%s\")\n",wVar3,local_68,wVar5,
            local_70);
  }
  if ((I->size != L'\0') && (adjust_marker < f->size)) {
    f->size = f->size - adjust_marker;
  }
  local_a4 = f->size;
LAB_0806f27d:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return local_a4;
}



void HText_endInput(HText *text)

{
  int iVar1;
  int in_GS_OFFSET;
  HText *text_local;
  char marker [20];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if ((((keypad_mode == 3) || (keypad_mode == 2)) && (number_fields_on_left == '\0')) &&
     (((text != (HText *)0x0 && (text->last_anchor != (TextAnchor *)0x0)) &&
      (L'\0' < text->last_anchor->number)))) {
    HText_setIgnoreExcess(text,'\0');
    sprintf(marker,"[%d]",text->last_anchor->number);
    HText_appendText(text,marker);
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



// WARNING: Unknown calling convention

double get_trans_q(wchar_t cs_from,char *givenmime)

{
  int iVar1;
  char *a;
  char *__nptr;
  double local_2c;
  double df;
  char *ptok;
  char *pval;
  char *field;
  char *pair;
  char *p;
  BOOLEAN tq;
  
  df = 1.0;
  if ((givenmime == (char *)0x0) || (*givenmime == '\0')) {
    local_2c = 0.0;
  }
  else {
    p = strchr(givenmime,0x3b);
    if (p != (char *)0x0) {
      *p = '\0';
      p = p + 1;
    }
    iVar1 = strcmp(givenmime,"*");
    if (iVar1 == 0) {
      iVar1 = UCGetLYhndl_byMIME("utf-8");
      tq = UCCanTranslateFromTo(cs_from,iVar1);
    }
    else {
      iVar1 = UCGetLYhndl_byMIME(givenmime);
      tq = UCCanTranslateFromTo(cs_from,iVar1);
    }
    if (tq == '\0') {
      local_2c = 0.0;
    }
    else if ((p == (char *)0x0) || (*p == '\0')) {
      local_2c = (double)(short)tq;
    }
    else {
      field = p;
      do {
        do {
          do {
            pair = HTNextTok(&field,";","\"",(char *)0x0);
            if (pair == (char *)0x0) goto LAB_0806f4c0;
            a = HTNextTok(&pair,"= ",(char *)0x0,(char *)0x0);
          } while (a == (char *)0x0);
          __nptr = HTNextField(&pair);
        } while (__nptr == (char *)0x0);
        iVar1 = strcasecomp(a,"q");
      } while (iVar1 != 0);
      df = strtod(__nptr,(char **)0x0);
LAB_0806f4c0:
      local_2c = (double)(short)tq * df;
    }
  }
  return local_2c;
}



// WARNING: Unknown calling convention

wchar_t find_best_target_cs(char **best_csname,wchar_t cs_from,char *acceptstring)

{
  int iVar1;
  double dVar2;
  wchar_t local_28;
  double q;
  double bestq;
  char *nextfield;
  char *field;
  char *bestmime;
  char *paccept;
  
  paccept = (char *)0x0;
  bestq = -1.0;
  bestmime = (char *)0x0;
  HTSACopy(&paccept,acceptstring);
  nextfield = paccept;
  while( true ) {
    field = HTNextTok(&nextfield,",","\"",(char *)0x0);
    if (field == (char *)0x0) break;
    if (*field != '\0') {
      dVar2 = get_trans_q(cs_from,field);
      if (bestq < dVar2) {
        bestmime = field;
        bestq = dVar2;
      }
    }
  }
  if (bestmime == (char *)0x0) {
    if (paccept != (char *)0x0) {
      free(paccept);
    }
    local_28 = L'\xffffffff';
  }
  else {
    iVar1 = strcmp(bestmime,"*");
    if (iVar1 == 0) {
      HTSACopy(best_csname,"utf-8");
    }
    else {
      HTSACopy(best_csname,bestmime);
    }
    if (paccept != (char *)0x0) {
      free(paccept);
      paccept = (char *)0x0;
    }
    if (bestq <= 0.0) {
      local_28 = L'\xffffffff';
    }
    else {
      local_28 = UCGetLYhndl_byMIME(*best_csname);
    }
  }
  return local_28;
}



void load_a_file(char *val_used,bstring_conflict **result)

{
  int iVar1;
  FILE *__stream;
  FILE *__stream_00;
  char *Msg;
  size_t len;
  int in_GS_OFFSET;
  bstring_conflict **result_local;
  char *val_used_local;
  size_t bytes;
  FILE *fd;
  char buffer [257];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"Ok, about to convert %s to mime/thingy\n",val_used);
  }
  if (*val_used != '\0') {
    __stream_00 = fopen64(val_used,"rb");
    if (__stream_00 == (FILE *)0x0) {
      Msg = (char *)gettext("Can\'t open file for uploading");
      HTAlert(Msg);
    }
    else {
      while( true ) {
        len = fread(buffer,1,0x100,__stream_00);
        if (len == 0) break;
        HTSABCat((bstring **)result,buffer,len);
      }
      LYCloseInput((FILE *)__stream_00);
    }
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



// WARNING: Unknown calling convention

char * guess_content_type(char *filename)

{
  HTFormat pHVar1;
  char *local_18;
  HTFormat format;
  char *desc;
  HTAtom *encoding;
  
  pHVar1 = HTFileFormat(filename,&encoding,&desc);
  if (((pHVar1 == (HTFormat)0x0) || (pHVar1->name == (char *)0x0)) || (*pHVar1->name == '\0')) {
    local_18 = "text/plain";
  }
  else {
    local_18 = pHVar1->name;
  }
  return local_18;
}



// WARNING: Unknown calling convention

void cannot_transcode(BOOLEAN *had_warning,char *target_csname)

{
  char *message;
  char *local_8;
  
  if (*had_warning == '\0') {
    *had_warning = '\x01';
    mustshow = '\x01';
    if (target_csname == (char *)0x0) {
      local_8 = "UNKNOWN";
    }
    else {
      local_8 = target_csname;
    }
    message = (char *)gettext("Warning: Cannot transcode form data to charset %s!");
    user_message(message,local_8);
    LYSleepAlert();
  }
  return;
}



// WARNING: Unknown calling convention

uint check_form_specialchars(char *value)

{
  char *p;
  uint result;
  
  result = 0;
  p = value;
  while (((p != (char *)0x0 && (*p != '\0')) && (result != 3))) {
    if (((*p == '\x01') || (*p == '\x02')) || (*p == '\a')) {
      result = result | 2;
    }
    else if (*p < '\0') {
      result = result | 1;
    }
    p = p + 1;
  }
  return result;
}



// WARNING: Unknown calling convention

void UpdateBoundary(char **Boundary,bstring_conflict *data)

{
  int iVar1;
  ushort **ppuVar2;
  wchar_t local_30;
  char *local_2c;
  char local_25;
  char *want;
  char *text;
  wchar_t last;
  wchar_t have;
  wchar_t j;
  char temp [2];
  
  have = strlen(*Boundary);
  if (data == (bstring_conflict *)0x0) {
    local_30 = L'\0';
  }
  else {
    local_30 = data->len;
  }
  last = local_30;
  if (data == (bstring_conflict *)0x0) {
    local_2c = (char *)0x0;
  }
  else {
    local_2c = data->str;
  }
  text = local_2c;
  want = *Boundary;
  for (j = L'\0'; j <= last - have; j = j + L'\x01') {
    if (*want == text[j]) {
      iVar1 = memcmp(want,text + j,have);
      if (iVar1 == 0) {
        ppuVar2 = __ctype_b_loc();
        if (((*ppuVar2)[(byte)text[have + j]] & 0x800) == 0) {
          local_25 = '0';
        }
        else {
          local_25 = 'a';
        }
        temp[0] = local_25;
        temp[1] = '\0';
        HTSACat(&want,temp);
        have = have + L'\x01';
      }
    }
  }
  *Boundary = want;
  return;
}



// WARNING: Unknown calling convention

char * convert_to_base64(char *src,wchar_t len)

{
  byte *pbVar1;
  char *pcVar2;
  byte bVar3;
  byte bVar4;
  char *pcVar5;
  char *e_1;
  char *c_1;
  char *e;
  char *c;
  wchar_t chunk;
  wchar_t eollen;
  char *str;
  char *r;
  char *eol;
  wchar_t rlen;
  char *dest;
  uchar c3;
  uchar c2;
  uchar c1;
  
  str = src;
  rlen = ((len + L'\x02') / 3) * 4;
  if (rlen != L'\0') {
    rlen = rlen + (rlen + L'\xffffffff') / 0x4c + 1;
  }
  pcVar5 = (char *)malloc(rlen + L'\x01');
  if (pcVar5 == (char *)0x0) {
    outofmem("./GridText.c","convert_to_base64");
  }
  chunk = L'\0';
  r = pcVar5;
  for (; L'\0' < len; len = len + L'\xfffffffd') {
    if (chunk == L'\x13') {
      for (c = "\n"; c < ""; c = c + 1) {
        *r = *c;
        r = r + 1;
      }
      chunk = L'\0';
    }
    bVar3 = *str;
    bVar4 = str[1];
    pbVar1 = (byte *)(str + 2);
    *r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[bVar3 >> 2];
    r[1] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
           [(uint)(bVar4 >> 4) | (bVar3 & 3) << 4];
    pcVar2 = r + 2;
    if (len < L'\x03') {
      str = (char *)pbVar1;
      if (len == L'\x02') {
        *pcVar2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
                  [(bVar4 & 0xf) * 4];
        r[3] = '=';
      }
      else {
        *pcVar2 = '=';
        r[3] = '=';
      }
    }
    else {
      bVar3 = *pbVar1;
      *pcVar2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
                [(uint)(bVar3 >> 6) | (bVar4 & 0xf) * 4];
      r[3] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[bVar3 & 0x3f];
      str = str + 3;
    }
    r = r + 4;
    chunk = chunk + L'\x01';
  }
  if (rlen != L'\0') {
    for (c_1 = "\n"; c_1 < ""; c_1 = c_1 + 1) {
      *r = *c_1;
      r = r + 1;
    }
  }
  *r = '\0';
  return pcVar5;
}



// WARNING: Unknown calling convention

char * escape_or_quote_name(char *name,QuoteData quoting,char *MultipartContentType)

{
  char *escaped1;
  
  escaped1 = (char *)0x0;
  if (quoting < QUOTE_SPECIAL) {
    if (quoting == NO_QUOTE) {
      HTSACopy(&escaped1,name);
    }
    else {
      HTSACopy(&escaped1,"Content-Disposition: form-data");
      HTSprintf(&escaped1,"; name=\"%s\"",name);
      if (MultipartContentType != (char *)0x0) {
        HTSprintf(&escaped1,MultipartContentType,"text/plain");
      }
      if (quoting == QUOTE_BASE64) {
        HTSACat(&escaped1,"\r\nContent-Transfer-Encoding: base64");
      }
      HTSACat(&escaped1,"\r\n\r\n");
    }
  }
  else if (quoting == QUOTE_SPECIAL) {
    escaped1 = HTEscapeSP(name,'\x01');
  }
  return escaped1;
}



// WARNING: Unknown calling convention

char * escape_or_quote_value(char *value,QuoteData quoting)

{
  wchar_t len;
  char *local_18;
  char *escaped2;
  
  escaped2 = (char *)0x0;
  if (quoting == QUOTE_BASE64) {
    len = strlen(value);
    escaped2 = convert_to_base64(value,len);
  }
  else if (quoting < QUOTE_BASE64) {
    if (value == (char *)0x0) {
      local_18 = "";
    }
    else {
      local_18 = value;
    }
    HTSACopy(&escaped2,local_18);
  }
  else if (quoting == QUOTE_SPECIAL) {
    escaped2 = HTEscapeSP(value,'\x01');
  }
  return escaped2;
}



// WARNING: Unknown calling convention

wchar_t check_if_base64_needed(wchar_t submit_method,bstring_conflict *data)

{
  bool bVar1;
  uint uVar2;
  FILE *__stream;
  char *local_30;
  wchar_t local_2c;
  wchar_t local_28;
  wchar_t ch;
  wchar_t length;
  wchar_t n;
  wchar_t col;
  char *text;
  wchar_t width;
  BOOLEAN printable;
  
  width = L'\0';
  bVar1 = true;
  if (data == (bstring_conflict *)0x0) {
    local_30 = (char *)0x0;
  }
  else {
    local_30 = data->str;
  }
  if (local_30 != (char *)0x0) {
    col = L'\0';
    if (data == (bstring_conflict *)0x0) {
      local_2c = L'\0';
    }
    else {
      local_2c = data->len;
    }
    for (n = L'\0'; n < local_2c; n = n + L'\x01') {
      uVar2 = (uint)(byte)local_30[n];
      if ((local_30[n] < '\0') || ((uVar2 < 0x20 && (uVar2 != 10)))) {
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"nonprintable %d:%#x\n",n,uVar2);
        }
        bVar1 = false;
      }
      if ((uVar2 == 10) || (uVar2 == 0xd)) {
        if (width < col) {
          width = col;
        }
        col = L'\0';
      }
      else {
        col = col + L'\x01';
      }
    }
    if (width < col) {
      width = col;
    }
  }
  if (((bVar1) || (submit_method != L'\x03')) || (width < L'I')) {
    local_28 = L'\0';
  }
  else {
    local_28 = L'\x01';
  }
  return local_28;
}



// WARNING: Unknown calling convention

wchar_t HText_SubmitForm(FormInfo *submit_item,DocInfo *doc,char *link_name,char *link_value)

{
  char cVar1;
  bstring_conflict *pbVar2;
  BOOLEAN BVar3;
  FILE *pFVar4;
  int iVar5;
  char *pcVar6;
  uint uVar7;
  wchar_t wVar8;
  char *pcVar9;
  wchar_t local_194;
  char *local_190;
  QuoteData local_18c;
  QuoteData local_188;
  char *local_184;
  char *local_17c;
  char *local_178;
  char *local_174;
  char *local_170;
  char *local_16c;
  char *local_168;
  char *local_164;
  char *local_160;
  char *local_15c;
  char *local_154;
  char *local_150;
  char *local_14c;
  char *local_148;
  char *local_144;
  char *local_140;
  char *local_138;
  char *local_134;
  char *local_130;
  wchar_t local_128;
  char *local_124;
  char *local_11c;
  char *local_114;
  undefined *local_10c;
  undefined *local_108;
  undefined *local_104;
  undefined *local_100;
  undefined *local_fc;
  undefined *local_f8;
  undefined *local_f4;
  undefined1 *local_ec;
  undefined1 *local_e8;
  undefined *local_e4;
  undefined *local_e0;
  undefined *local_dc;
  undefined *local_d8;
  undefined *local_d4;
  undefined *local_d0;
  char *local_cc;
  char *local_c8;
  undefined *local_c4;
  undefined *local_c0;
  int local_bc;
  char *local_b8;
  wchar_t local_b4;
  char *local_ac;
  char *local_a8;
  char *local_a4;
  char *local_a0;
  char *temp;
  char *t;
  char *marker;
  QuoteData quoting;
  wchar_t out_cs;
  FormInfo *form_ptr_1;
  uint name_is_special;
  uint field_is_special;
  char *val;
  FormInfo *form_ptr;
  uint form_is_special;
  wchar_t textarea_lineno;
  wchar_t target_cs;
  wchar_t result;
  wchar_t form_number;
  wchar_t anchor_limit;
  wchar_t anchor_count;
  char *val_used;
  char *previous_blanks;
  char *name_used;
  char *last_textarea_name;
  char *escaped2;
  char *escaped1;
  char *copied_val_used;
  char *copied_name_used;
  char *content_type_out;
  char *MultipartContentType;
  char *Boundary;
  bstring_conflict *my_query;
  TextAnchor *anchor_ptr;
  PostData *my_data;
  PerFormInfo *thisform;
  char *target_csname;
  char *out_csname;
  BOOLEAN first_one;
  BOOLEAN skip_field;
  BOOLEAN SemiColon;
  BOOLEAN PlainText;
  BOOLEAN success;
  BOOLEAN have_accept_cs;
  BOOLEAN had_chartrans_warning;
  
  had_chartrans_warning = '\0';
  have_accept_cs = '\0';
  PlainText = '\0';
  SemiColon = '\0';
  skip_field = '\0';
  target_csname = (char *)0x0;
  my_data = (PostData *)0x0;
  my_query = (bstring_conflict *)0x0;
  Boundary = (char *)0x0;
  MultipartContentType = (char *)0x0;
  content_type_out = (char *)0x0;
  copied_name_used = (char *)0x0;
  copied_val_used = (char *)0x0;
  escaped1 = (char *)0x0;
  escaped2 = (char *)0x0;
  last_textarea_name = (char *)0x0;
  name_used = "";
  previous_blanks = (char *)0x0;
  val_used = "";
  anchor_count = L'\0';
  anchor_limit = L'\0';
  form_number = submit_item->number;
  result = L'\0';
  target_cs = L'\xffffffff';
  textarea_lineno = L'\0';
  form_is_special = 0;
  if (WWW_TraceFlag != '\0') {
    pFVar4 = TraceFP();
    fprintf((FILE *)pFVar4,"SubmitForm\n  link_name=%s\n  link_value=%s\n",link_name,link_value);
  }
  if (HTMainText == (HText *)0x0) {
    local_194 = L'\0';
  }
  else {
    thisform = (PerFormInfo *)HTList_objectAt(HTMainText->forms,form_number + L'\xffffffff');
    if (thisform == (PerFormInfo *)0x0) {
      if (WWW_TraceFlag != '\0') {
        pFVar4 = TraceFP();
        fprintf((FILE *)pFVar4,"SubmitForm: form %d not in HTMainText\'s list!\n",form_number);
      }
    }
    else if (thisform->number != form_number) {
      if (WWW_TraceFlag != '\0') {
        wVar8 = thisform->number;
        pFVar4 = TraceFP();
        fprintf((FILE *)pFVar4,"SubmitForm: failed sanity check, %d!=%d !\n",wVar8,form_number);
      }
      thisform = (PerFormInfo *)0x0;
    }
    if ((submit_item->submit_action == (char *)0x0) || (*submit_item->submit_action == '\0')) {
      if (WWW_TraceFlag != '\0') {
        pFVar4 = TraceFP();
        fprintf((FILE *)pFVar4,"SubmitForm: no action given\n");
      }
      local_194 = L'\0';
    }
    else if ((submit_item->submit_method == L'\x03') &&
            (iVar5 = strncasecomp(submit_item->submit_action,"mailto:",7), iVar5 != 0)) {
      pcVar6 = (char *)gettext("Malformed mailto form submission!  Cancelled!");
      HTAlert(pcVar6);
      local_194 = L'\0';
    }
    else {
      if ((submit_item->submit_enctype == (char *)0x0) ||
         (iVar5 = strncasecomp(submit_item->submit_enctype,"text/plain",10), iVar5 != 0)) {
        if ((submit_item->submit_enctype == (char *)0x0) ||
           (iVar5 = strncasecomp(submit_item->submit_enctype,"application/sgml-form-urlencoded",0x20
                                ), iVar5 != 0)) {
          if ((submit_item->submit_enctype != (char *)0x0) &&
             (iVar5 = strncasecomp(submit_item->submit_enctype,"multipart/form-data",0x13),
             iVar5 == 0)) {
            Boundary = "xnyLAaB03X";
          }
        }
        else {
          SemiColon = '\x01';
        }
      }
      else {
        PlainText = '\x01';
      }
      if (((thisform != (PerFormInfo *)0x0) && (submit_item->accept_cs != (char *)0x0)) &&
         (iVar5 = strcasecomp(submit_item->accept_cs,"UNKNOWN"), iVar5 != 0)) {
        have_accept_cs = '\x01';
        target_cs = find_best_target_cs(&thisform->thisacceptcs,current_char_set,
                                        submit_item->accept_cs);
      }
      if (((thisform != (PerFormInfo *)0x0) && (have_accept_cs == '\0')) &&
         ((thisform->accept_cs != (char *)0x0 &&
          (iVar5 = strcasecomp(thisform->accept_cs,"UNKNOWN"), iVar5 != 0)))) {
        have_accept_cs = '\x01';
        target_cs = find_best_target_cs(&thisform->thisacceptcs,current_char_set,thisform->accept_cs
                                       );
      }
      if (((have_accept_cs != '\0') && (L'\xffffffff' < target_cs)) &&
         (thisform->thisacceptcs != (char *)0x0)) {
        target_csname = thisform->thisacceptcs;
      }
      if (((target_cs < L'\0') && (HTMainText->node_anchor->charset != (char *)0x0)) &&
         (*HTMainText->node_anchor->charset != '\0')) {
        target_cs = UCGetLYhndl_byMIME(HTMainText->node_anchor->charset);
        if (target_cs < L'\0') {
          target_cs = UCLYhndl_for_unspec;
          target_csname = LYCharSet_UC[UCLYhndl_for_unspec].MIMEname;
        }
        else {
          target_csname = HTMainText->node_anchor->charset;
        }
      }
      if (target_cs < L'\0') {
        target_cs = UCLYhndl_for_unspec;
      }
      for (anchor_ptr = HTMainText->first_anchor; anchor_ptr != (TextAnchor *)0x0;
          anchor_ptr = anchor_ptr->next) {
        if (anchor_ptr->link_type == '\x02') {
          if ((anchor_ptr->input_field->number == form_number) &&
             (anchor_ptr->input_field->disabled == L'\0')) {
            form_ptr = anchor_ptr->input_field;
            if (form_ptr->cp_submit_value == (char *)0x0) {
              local_190 = form_ptr->value;
            }
            else {
              local_190 = form_ptr->cp_submit_value;
            }
            val = local_190;
            field_is_special = check_form_specialchars(local_190);
            name_is_special = check_form_specialchars(form_ptr->name);
            form_is_special = field_is_special | name_is_special;
            if (((((field_is_special != 0) && (L'\xffffffff' < target_cs)) &&
                 (((field_is_special & 1) != 0 ||
                  ((LYCharSet_UC[target_cs].enc != 2 &&
                   ((LYCharSet_UC[target_cs].like8859 & 0x80U) == 0)))))) &&
                (BVar3 = UCNeedNotTranslate(form_ptr->value_cs,target_cs), BVar3 == '\0')) &&
               (BVar3 = UCCanTranslateFromTo(form_ptr->value_cs,target_cs), BVar3 == '\0')) {
              BVar3 = UCCanTranslateFromTo(target_cs,form_ptr->value_cs);
              if (BVar3 == '\0') {
                target_cs = L'\xffffffff';
              }
              else {
                target_cs = form_ptr->value_cs;
                target_csname = (char *)0x0;
              }
            }
            if (((name_is_special != 0) && (L'\xffffffff' < target_cs)) &&
               (((((name_is_special & 1) != 0 ||
                  ((LYCharSet_UC[target_cs].enc != 2 &&
                   ((LYCharSet_UC[target_cs].like8859 & 0x80U) == 0)))) &&
                 (BVar3 = UCNeedNotTranslate(form_ptr->name_cs,target_cs), BVar3 == '\0')) &&
                (BVar3 = UCCanTranslateFromTo(form_ptr->name_cs,target_cs), BVar3 == '\0')))) {
              BVar3 = UCCanTranslateFromTo(target_cs,form_ptr->name_cs);
              if (BVar3 == '\0') {
                target_cs = L'\xffffffff';
              }
              else {
                target_cs = form_ptr->value_cs;
                target_csname = (char *)0x0;
              }
            }
            anchor_limit = anchor_limit + L'\x01';
          }
          else if (form_number < anchor_ptr->input_field->number) break;
        }
      }
      if ((anchor_limit != L'\0') &&
         (my_data = (PostData *)calloc(anchor_limit,0x18), my_data == (PostData *)0x0)) {
        outofmem("./GridText.c","HText_SubmitForm");
      }
      if ((target_csname == (char *)0x0) && (L'\xffffffff' < target_cs)) {
        if ((form_is_special & 1) == 0) {
          if ((form_is_special & 2) == 0) {
            target_csname = "us-ascii";
          }
          else {
            target_csname = LYCharSet_UC[target_cs].MIMEname;
          }
        }
        else {
          target_csname = LYCharSet_UC[target_cs].MIMEname;
        }
      }
      if ((submit_item->submit_method == L'\x01') && (Boundary == (char *)0x0)) {
        temp = (char *)0x0;
        HTSACopy(&temp,submit_item->submit_action);
        strtok(temp,"#");
        strtok(temp,"?");
        HTSACat(&temp,"?");
        HTSABCat0((bstring **)&my_query,temp);
      }
      else {
        if (SemiColon == '\x01') {
          HTSACopy(&content_type_out,"application/sgml-form-urlencoded");
        }
        else if (PlainText == '\x01') {
          HTSACopy(&content_type_out,"text/plain");
        }
        else if (Boundary == (char *)0x0) {
          HTSACopy(&content_type_out,"application/x-www-form-urlencoded");
        }
        else {
          HTSACopy(&content_type_out,"multipart/form-data");
        }
        if (((have_accept_cs != '\0') || ((form_is_special & 1) != 0)) ||
           ((form_is_special & 2) != 0)) {
          if ((target_cs < L'\0') || (target_csname == (char *)0x0)) {
            cannot_transcode(&had_chartrans_warning,target_csname);
          }
          else if ((Boundary == (char *)0x0) &&
                  (((HTMainText->node_anchor->charset != (char *)0x0 &&
                    ((iVar5 = strcmp(HTMainText->node_anchor->charset,"iso-8859-1"), iVar5 != 0 ||
                     (iVar5 = strcmp(target_csname,"iso-8859-1"), iVar5 != 0)))) ||
                   ((HTMainText->node_anchor->charset == (char *)0x0 &&
                    (target_cs != UCLYhndl_for_unspec)))))) {
            HTSprintf(&content_type_out,"; charset=%s",target_csname);
          }
        }
      }
      out_csname = target_csname;
      for (anchor_ptr = HTMainText->first_anchor; anchor_ptr != (TextAnchor *)0x0;
          anchor_ptr = anchor_ptr->next) {
        if (anchor_ptr->link_type == '\x02') {
          if ((anchor_ptr->input_field->number == form_number) &&
             (anchor_ptr->input_field->disabled == L'\0')) {
            form_ptr_1 = anchor_ptr->input_field;
            if (PlainText == '\0') {
              if (Boundary == (char *)0x0) {
                local_188 = QUOTE_SPECIAL;
              }
              else {
                local_188 = QUOTE_MULTI;
              }
              local_18c = local_188;
            }
            else {
              local_18c = NO_QUOTE;
            }
            quoting = local_18c;
            if (form_ptr_1->type != L'\t') {
              textarea_lineno = L'\0';
            }
            if (WWW_TraceFlag != '\0') {
              iVar5 = anchor_count + L'\x01';
              pFVar4 = TraceFP();
              fprintf((FILE *)pFVar4,"SubmitForm[%d/%d]: ",iVar5,anchor_limit);
            }
            if (form_ptr_1->name == (char *)0x0) {
              local_184 = "";
            }
            else {
              local_184 = form_ptr_1->name;
            }
            name_used = local_184;
            switch(form_ptr_1->type) {
            default:
              if (WWW_TraceFlag != '\0') {
                wVar8 = form_ptr_1->type;
                pFVar4 = TraceFP();
                fprintf((FILE *)pFVar4,"What type is %d?\n",wVar8);
              }
              break;
            case L'\x01':
            case L'\x02':
            case L'\x03':
            case L'\x04':
            case L'\a':
            case L'\b':
            case L'\t':
switchD_080707d1_caseD_1:
              if (form_ptr_1->cp_submit_value == (char *)0x0) {
                val_used = form_ptr_1->value;
              }
              else {
                val_used = form_ptr_1->cp_submit_value;
              }
              uVar7 = check_form_specialchars(val_used);
              if (uVar7 == 0) {
                if (WWW_TraceFlag != '\0') {
                  if (target_csname == (char *)0x0) {
                    local_150 = "???";
                  }
                  else {
                    local_150 = target_csname;
                  }
                  if (form_ptr_1->name == (char *)0x0) {
                    local_14c = "";
                  }
                  else {
                    local_14c = form_ptr_1->name;
                  }
                  pFVar4 = TraceFP();
                  fprintf((FILE *)pFVar4,"field \"%s\" %d %s OK\n",local_14c,target_cs,local_150);
                }
                success = '\x01';
              }
              else {
                HTSACopy(&copied_val_used,val_used);
                success = LYUCTranslateBackFormData
                                    (&copied_val_used,form_ptr_1->value_cs,target_cs,PlainText);
                if (WWW_TraceFlag != '\0') {
                  if (success == '\0') {
                    local_164 = "FAILED";
                  }
                  else {
                    local_164 = "OK";
                  }
                  if (target_csname == (char *)0x0) {
                    local_160 = "???";
                  }
                  else {
                    local_160 = target_csname;
                  }
                  if (form_ptr_1->value_cs < L'\0') {
                    local_15c = "???";
                  }
                  else {
                    local_15c = LYCharSet_UC[form_ptr_1->value_cs].MIMEname;
                  }
                  wVar8 = form_ptr_1->value_cs;
                  if (form_ptr_1->name == (char *)0x0) {
                    local_154 = "";
                  }
                  else {
                    local_154 = form_ptr_1->name;
                  }
                  pFVar4 = TraceFP();
                  fprintf((FILE *)pFVar4,"field \"%s\" %d %s -> %d %s %s\n",local_154,wVar8,
                          local_15c,target_cs,local_160,local_164);
                }
                if (success != '\0') {
                  val_used = copied_val_used;
                }
              }
              if (success == '\0') {
                cannot_transcode(&had_chartrans_warning,target_csname);
                out_cs = form_ptr_1->value_cs;
              }
              else {
                out_cs = target_cs;
              }
              if (L'\xffffffff' < out_cs) {
                out_csname = LYCharSet_UC[out_cs].MIMEname;
              }
              if (Boundary != (char *)0x0) {
                HTSACopy(&MultipartContentType,"\r\nContent-Type: %s");
                if ((success == '\0') && (form_ptr_1->value_cs < L'\0')) {
                  out_csname = "UNKNOWN-8BIT";
                }
                else if (success == '\0') {
                  target_csname = (char *)0x0;
                }
                else if (target_csname == (char *)0x0) {
                  target_csname = LYCharSet_UC[target_cs].MIMEname;
                }
                iVar5 = strcmp(out_csname,"iso-8859-1");
                if (iVar5 != 0) {
                  HTSprintf(&MultipartContentType,"; charset=%s",out_csname);
                }
              }
              if ((((form_ptr_1->type != L'\t') ||
                   (textarea_lineno = textarea_lineno + L'\x01', textarea_lineno < L'\x02')) ||
                  (last_textarea_name == (char *)0x0)) ||
                 ((form_ptr_1->name == (char *)0x0 ||
                  (iVar5 = strcmp(last_textarea_name,form_ptr_1->name), iVar5 != 0)))) {
                uVar7 = check_form_specialchars(name_used);
                if (uVar7 == 0) {
                  if (WWW_TraceFlag != '\0') {
                    if (target_csname == (char *)0x0) {
                      local_134 = "???";
                    }
                    else {
                      local_134 = target_csname;
                    }
                    if (form_ptr_1->name == (char *)0x0) {
                      local_130 = "";
                    }
                    else {
                      local_130 = form_ptr_1->name;
                    }
                    pFVar4 = TraceFP();
                    fprintf((FILE *)pFVar4,"name \"%s\" %d %s OK\n",local_130,target_cs,local_134);
                  }
                  success = '\x01';
                  if (Boundary != (char *)0x0) {
                    HTSACopy(&copied_name_used,name_used);
                  }
                }
                else {
                  HTSACopy(&copied_name_used,name_used);
                  success = LYUCTranslateBackFormData
                                      (&copied_name_used,form_ptr_1->name_cs,target_cs,PlainText);
                  if (WWW_TraceFlag != '\0') {
                    if (success == '\0') {
                      local_148 = "FAILED";
                    }
                    else {
                      local_148 = "OK";
                    }
                    if (target_csname == (char *)0x0) {
                      local_144 = "???";
                    }
                    else {
                      local_144 = target_csname;
                    }
                    if (form_ptr_1->name_cs < L'\0') {
                      local_140 = "???";
                    }
                    else {
                      local_140 = LYCharSet_UC[form_ptr_1->name_cs].MIMEname;
                    }
                    wVar8 = form_ptr_1->name_cs;
                    if (form_ptr_1->name == (char *)0x0) {
                      local_138 = "";
                    }
                    else {
                      local_138 = form_ptr_1->name;
                    }
                    pFVar4 = TraceFP();
                    fprintf((FILE *)pFVar4,"name \"%s\" %d %s -> %d %s %s\n",local_138,wVar8,
                            local_140,target_cs,local_144,local_148);
                  }
                  if (success != '\0') {
                    name_used = copied_name_used;
                  }
                  if (Boundary != (char *)0x0) {
                    if (success == '\0') {
                      HTSACopy(&MultipartContentType,"");
                      target_csname = (char *)0x0;
                    }
                    else if (target_csname == (char *)0x0) {
                      target_csname = LYCharSet_UC[target_cs].MIMEname;
                    }
                  }
                }
                if (success == '\0') {
                  cannot_transcode(&had_chartrans_warning,target_csname);
                }
                if (Boundary != (char *)0x0) {
                  HTMake822Word(&copied_name_used,0);
                  name_used = copied_name_used;
                }
              }
              break;
            case L'\x05':
            case L'\f':
            case L'\r':
              if (((form_ptr_1->name == (char *)0x0) || (*form_ptr_1->name == '\0')) ||
                 (iVar5 = strcmp(form_ptr_1->name,link_name), iVar5 != 0)) {
                if (WWW_TraceFlag != '\0') {
                  pFVar4 = TraceFP();
                  fprintf((FILE *)pFVar4,"skipping submit field with ");
                }
                if (WWW_TraceFlag != '\0') {
                  if ((form_ptr_1->name == (char *)0x0) || (*form_ptr_1->name == '\0')) {
                    local_178 = "no field name";
                  }
                  else {
                    local_178 = "not current link";
                  }
                  if (link_name == (char *)0x0) {
                    local_174 = "???";
                  }
                  else {
                    local_174 = link_name;
                  }
                  if (form_ptr_1->name == (char *)0x0) {
                    local_170 = "???";
                  }
                  else {
                    local_170 = form_ptr_1->name;
                  }
                  pFVar4 = TraceFP();
                  fprintf((FILE *)pFVar4,"name \"%s\" for link_name \"%s\", %s.\n",local_170,
                          local_174,local_178);
                }
              }
              else {
                if ((form_ptr_1->type == L'\f') ||
                   (((form_ptr_1->value != (char *)0x0 && (*form_ptr_1->value != '\0')) &&
                    (iVar5 = strcmp(form_ptr_1->value,link_value), iVar5 == 0))))
                goto switchD_080707d1_caseD_1;
                if (WWW_TraceFlag != '\0') {
                  pFVar4 = TraceFP();
                  fprintf((FILE *)pFVar4,"skipping submit field with ");
                }
                if (WWW_TraceFlag != '\0') {
                  if (link_name == (char *)0x0) {
                    local_16c = "???";
                  }
                  else {
                    local_16c = link_name;
                  }
                  if (form_ptr_1->name == (char *)0x0) {
                    local_168 = "???";
                  }
                  else {
                    local_168 = form_ptr_1->name;
                  }
                  pFVar4 = TraceFP();
                  fprintf((FILE *)pFVar4,"name \"%s\" for link_name \"%s\", %s!\n",local_168,
                          local_16c,"values are different");
                }
              }
              break;
            case L'\x06':
              if (WWW_TraceFlag != '\0') {
                pFVar4 = TraceFP();
                fprintf((FILE *)pFVar4,"reset\n");
              }
              break;
            case L'\v':
              if (form_ptr_1->value == (char *)0x0) {
                local_17c = "";
              }
              else {
                local_17c = form_ptr_1->value;
              }
              val_used = local_17c;
              if (WWW_TraceFlag != '\0') {
                pFVar4 = TraceFP();
                fprintf((FILE *)pFVar4,"I will submit %s (from %s)\n",val_used,name_used);
              }
            }
            skip_field = '\0';
            my_data[anchor_count].first = '\x01';
            my_data[anchor_count].type = form_ptr_1->type;
            switch(form_ptr_1->type) {
            default:
              skip_field = '\x01';
              break;
            case L'\x01':
            case L'\x02':
            case L'\a':
            case L'\b':
              break;
            case L'\x03':
            case L'\x04':
              if (form_ptr_1->num_value == L'\0') {
                skip_field = '\x01';
              }
              break;
            case L'\x05':
            case L'\f':
            case L'\r':
              if ((((form_ptr_1->name == (char *)0x0) || (*form_ptr_1->name == '\0')) ||
                  (iVar5 = strcmp(form_ptr_1->name,link_name), iVar5 != 0)) ||
                 ((form_ptr_1->type != L'\f' &&
                  (((form_ptr_1->value == (char *)0x0 || (*form_ptr_1->value == '\0')) ||
                   (iVar5 = strcmp(form_ptr_1->value,link_value), iVar5 != 0)))))) {
                skip_field = '\x01';
              }
              break;
            case L'\t':
              if ((last_textarea_name == (char *)0x0) ||
                 (iVar5 = strcmp(last_textarea_name,form_ptr_1->name), iVar5 != 0)) {
                textarea_lineno = L'\x01';
                last_textarea_name = form_ptr_1->name;
              }
              else {
                my_data[anchor_count].first = '\0';
              }
              break;
            case L'\v':
              load_a_file(val_used,&my_data[anchor_count].data);
            }
            if (skip_field == '\0') {
              HTSACopy(&my_data[anchor_count].name,name_used);
              HTSACopy(&my_data[anchor_count].value,val_used);
              if (my_data[anchor_count].data == (bstring_conflict *)0x0) {
                HTSABCat0((bstring **)&my_data[anchor_count].data,val_used);
              }
              my_data[anchor_count].quote = quoting;
              if ((quoting == QUOTE_MULTI) &&
                 (wVar8 = check_if_base64_needed
                                    (submit_item->submit_method,my_data[anchor_count].data),
                 wVar8 != L'\0')) {
                if (WWW_TraceFlag != '\0') {
                  pFVar4 = TraceFP();
                  fprintf((FILE *)pFVar4,"will encode as base64\n");
                }
                my_data[anchor_count].quote = QUOTE_BASE64;
                if (my_data[anchor_count].data == (bstring_conflict *)0x0) {
                  local_128 = L'\0';
                }
                else {
                  local_128 = (my_data[anchor_count].data)->len;
                }
                if (my_data[anchor_count].data == (bstring_conflict *)0x0) {
                  local_124 = (char *)0x0;
                }
                else {
                  local_124 = (my_data[anchor_count].data)->str;
                }
                escaped2 = convert_to_base64(local_124,local_128);
                HTSABCopy0((bstring **)&my_data[anchor_count].data,escaped2);
                if (escaped2 != (char *)0x0) {
                  free(escaped2);
                  escaped2 = (char *)0x0;
                }
              }
            }
            anchor_count = anchor_count + L'\x01';
            if (copied_name_used != (char *)0x0) {
              free(copied_name_used);
              copied_name_used = (char *)0x0;
            }
            if (copied_val_used != (char *)0x0) {
              free(copied_val_used);
              copied_val_used = (char *)0x0;
            }
          }
          else if (form_number < anchor_ptr->input_field->number) break;
        }
      }
      if (copied_name_used != (char *)0x0) {
        free(copied_name_used);
        copied_name_used = (char *)0x0;
      }
      if (my_data != (PostData *)0x0) {
        first_one = '\x01';
        if ((content_type_out != (char *)0x0) && (Boundary != (char *)0x0)) {
          Boundary = (char *)0x0;
          HTSACopy(&Boundary,"LYNX");
          for (anchor_count = L'\0'; anchor_count < anchor_limit;
              anchor_count = anchor_count + L'\x01') {
            if (my_data[anchor_count].data != (bstring_conflict *)0x0) {
              UpdateBoundary(&Boundary,my_data[anchor_count].data);
            }
          }
          HTSprintf(&content_type_out,"; boundary=%s",Boundary);
        }
        for (anchor_count = L'\0'; anchor_count < anchor_limit;
            anchor_count = anchor_count + L'\x01') {
          if ((my_data[anchor_count].name != (char *)0x0) &&
             (my_data[anchor_count].value != (char *)0x0)) {
            if (WWW_TraceFlag != '\0') {
              pbVar2 = my_data[anchor_count].data;
              if (my_data[anchor_count].value == (char *)0x0) {
                local_11c = "";
              }
              else {
                local_11c = my_data[anchor_count].value;
              }
              cVar1 = my_data[anchor_count].first;
              if (my_data[anchor_count].name == (char *)0x0) {
                local_114 = "";
              }
              else {
                local_114 = my_data[anchor_count].name;
              }
              iVar5 = anchor_count + L'\x01';
              pFVar4 = TraceFP();
              fprintf((FILE *)pFVar4,"processing [%d:%d] name=%s(first:%d, value=%s, data=%p)\n",
                      iVar5,anchor_limit,local_114,(int)cVar1,local_11c,pbVar2);
            }
            if (my_data[anchor_count].first != '\0') {
              if (first_one == '\0') {
                if (PlainText == '\0') {
                  if (SemiColon == '\0') {
                    if (Boundary == (char *)0x0) {
                      HTSABCat0((bstring **)&my_query,"&");
                    }
                    else {
                      HTBprintf((bstring **)&my_query,"\r\n--%s\r\n",Boundary);
                    }
                  }
                  else {
                    HTSABCat0((bstring **)&my_query,";");
                  }
                }
                else {
                  HTSABCat0((bstring **)&my_query,"\n");
                }
              }
              else {
                if (Boundary != (char *)0x0) {
                  HTBprintf((bstring **)&my_query,"--%s\r\n",Boundary);
                }
                first_one = '\0';
              }
            }
            HTSABCat((bstring **)&my_data[anchor_count].data,"",1);
            name_used = my_data[anchor_count].name;
            val_used = my_data[anchor_count].value;
            switch(my_data[anchor_count].type) {
            case L'\x01':
            case L'\x02':
            case L'\a':
            case L'\b':
              escaped1 = escape_or_quote_name
                                   (my_data[anchor_count].name,my_data[anchor_count].quote,
                                    MultipartContentType);
              escaped2 = escape_or_quote_value(val_used,my_data[anchor_count].quote);
              if ((PlainText == '\0') || (*escaped2 == '\0')) {
                local_10c = &DAT_0814cbac;
              }
              else {
                local_10c = &DAT_0814d205;
              }
              if (PlainText == '\0') {
                local_108 = &DAT_0814cbac;
              }
              else {
                local_108 = &DAT_0814d205;
              }
              if (Boundary == (char *)0x0) {
                local_104 = &DAT_0814e81f;
              }
              else {
                local_104 = &DAT_0814cbac;
              }
              HTBprintf((bstring **)&my_query,"%s%s%s%s%s",escaped1,local_104,local_108,escaped2,
                        local_10c);
              break;
            case L'\x03':
            case L'\x04':
              escaped1 = escape_or_quote_name
                                   (my_data[anchor_count].name,my_data[anchor_count].quote,
                                    MultipartContentType);
              escaped2 = escape_or_quote_value(val_used,my_data[anchor_count].quote);
              if ((PlainText == '\0') || (*escaped2 == '\0')) {
                local_100 = &DAT_0814cbac;
              }
              else {
                local_100 = &DAT_0814d205;
              }
              if (PlainText == '\0') {
                local_fc = &DAT_0814cbac;
              }
              else {
                local_fc = &DAT_0814d205;
              }
              if (Boundary == (char *)0x0) {
                local_f8 = &DAT_0814e81f;
              }
              else {
                local_f8 = &DAT_0814cbac;
              }
              HTBprintf((bstring **)&my_query,"%s%s%s%s%s",escaped1,local_f8,local_fc,escaped2,
                        local_100);
              break;
            case L'\x05':
            case L'\f':
            case L'\r':
              escaped1 = escape_or_quote_name
                                   (my_data[anchor_count].name,my_data[anchor_count].quote,
                                    MultipartContentType);
              escaped2 = escape_or_quote_value(val_used,my_data[anchor_count].quote);
              if (my_data[anchor_count].type == L'\r') {
                if (Boundary == (char *)0x0) {
                  if ((PlainText == '\0') || (*escaped1 == '\0')) {
                    local_f4 = &DAT_0814cbac;
                  }
                  else {
                    local_f4 = &DAT_0814d205;
                  }
                  if (PlainText == '\0') {
                    if (SemiColon == '\0') {
                      local_e8 = &DAT_0814e81d;
                    }
                    else {
                      local_e8 = &DAT_0814e38c;
                    }
                    local_ec = local_e8;
                  }
                  else {
                    local_ec = &DAT_0814d205;
                  }
                  HTBprintf((bstring **)&my_query,"%s.x=0%s%s.y=0%s",escaped1,local_ec,escaped1,
                            local_f4);
                }
                else {
                  pcVar6 = strchr(escaped1,0x3d);
                  pcVar6[1] = '\0';
                  HTBprintf((bstring **)&my_query,
                            "%s\"%s.x\"\r\n\r\n0\r\n--%s\r\n%s\"%s.y\"\r\n\r\n0",escaped1,
                            my_data[anchor_count].name,Boundary,escaped1,my_data[anchor_count].name)
                  ;
                }
              }
              else {
                if ((PlainText == '\0') || (*escaped2 == '\0')) {
                  local_e4 = &DAT_0814cbac;
                }
                else {
                  local_e4 = &DAT_0814d205;
                }
                if (PlainText == '\0') {
                  local_e0 = &DAT_0814cbac;
                }
                else {
                  local_e0 = &DAT_0814d205;
                }
                if (Boundary == (char *)0x0) {
                  local_dc = &DAT_0814e81f;
                }
                else {
                  local_dc = &DAT_0814cbac;
                }
                HTBprintf((bstring **)&my_query,"%s%s%s%s%s",escaped1,local_dc,local_e0,escaped2,
                          local_e4);
              }
              break;
            case L'\t':
              escaped2 = escape_or_quote_value(val_used,my_data[anchor_count].quote);
              if (my_data[anchor_count].first == '\0') {
                if (PlainText == '\0') {
                  if (Boundary == (char *)0x0) {
                    local_c8 = "%0d%0a";
                  }
                  else {
                    local_c8 = "\r\n";
                  }
                  local_cc = local_c8;
                }
                else {
                  local_cc = "\n";
                }
                marker = local_cc;
                if (*escaped2 == '\0') {
                  HTSACat(&previous_blanks,local_cc);
                }
                else {
                  if ((previous_blanks != (char *)0x0) &&
                     (HTSABCat0((bstring **)&my_query,previous_blanks),
                     previous_blanks != (char *)0x0)) {
                    free(previous_blanks);
                    previous_blanks = (char *)0x0;
                  }
                  HTSABCat0((bstring **)&my_query,escaped2);
                  if ((PlainText == '\0') && (Boundary == (char *)0x0)) {
                    HTSACopy(&previous_blanks,marker);
                  }
                  else {
                    HTSABCat0((bstring **)&my_query,marker);
                  }
                }
              }
              else {
                textarea_lineno = L'\x01';
                if (PlainText == '\0') {
                  if (Boundary == (char *)0x0) {
                    HTSACopy(&previous_blanks,"%0d%0a");
                  }
                  else {
                    HTSACopy(&previous_blanks,"\r\n");
                  }
                }
                else if (previous_blanks != (char *)0x0) {
                  free(previous_blanks);
                  previous_blanks = (char *)0x0;
                }
                escaped1 = escape_or_quote_name
                                     (name_used,my_data[anchor_count].quote,MultipartContentType);
                if ((PlainText == '\0') || (*escaped2 == '\0')) {
                  local_d8 = &DAT_0814cbac;
                }
                else {
                  local_d8 = &DAT_0814d205;
                }
                if (PlainText == '\0') {
                  local_d4 = &DAT_0814cbac;
                }
                else {
                  local_d4 = &DAT_0814d205;
                }
                if (Boundary == (char *)0x0) {
                  local_d0 = &DAT_0814e81f;
                }
                else {
                  local_d0 = &DAT_0814cbac;
                }
                HTBprintf((bstring **)&my_query,"%s%s%s%s%s",escaped1,local_d0,local_d4,escaped2,
                          local_d8);
              }
              break;
            case L'\v':
              if (PlainText == '\0') {
                if (Boundary == (char *)0x0) {
                  escaped1 = HTEscapeSP(my_data[anchor_count].name,'\x01');
                }
                else {
                  t = guess_content_type(val_used);
                  temp = (char *)0x0;
                  HTSACopy(&escaped1,"Content-Disposition: form-data");
                  HTSprintf(&escaped1,"; name=\"%s\"",my_data[anchor_count].name);
                  HTSACopy(&temp,val_used);
                  HTMake822Word(&temp,0);
                  HTSprintf(&escaped1,"; filename=\"%s\"",temp);
                  if (temp != (char *)0x0) {
                    free(temp);
                    temp = (char *)0x0;
                  }
                  HTSprintf(&escaped1,"\r\nContent-Type: %s",t);
                  if (my_data[anchor_count].quote == QUOTE_BASE64) {
                    HTSACat(&escaped1,"\r\nContent-Transfer-Encoding: base64");
                  }
                  HTSACat(&escaped1,"\r\n\r\n");
                }
              }
              else {
                HTSACopy(&escaped1,my_data[anchor_count].name);
              }
              if (PlainText == '\0') {
                local_c4 = &DAT_0814cbac;
              }
              else {
                local_c4 = &DAT_0814d205;
              }
              if (Boundary == (char *)0x0) {
                local_c0 = &DAT_0814e81f;
              }
              else {
                local_c0 = &DAT_0814cbac;
              }
              HTBprintf((bstring **)&my_query,"%s%s%s",escaped1,local_c0,local_c4);
              if ((my_data[anchor_count].data != (bstring_conflict *)0x0) &&
                 (L'\x01' < (my_data[anchor_count].data)->len)) {
                if (my_data[anchor_count].data == (bstring_conflict *)0x0) {
                  local_bc = -1;
                }
                else {
                  local_bc = (my_data[anchor_count].data)->len + L'\xffffffff';
                }
                if (my_data[anchor_count].data == (bstring_conflict *)0x0) {
                  local_b8 = (char *)0x0;
                }
                else {
                  local_b8 = (my_data[anchor_count].data)->str;
                }
                HTSABCat((bstring **)&my_query,local_b8,local_bc);
                if (PlainText != '\0') {
                  HTBprintf((bstring **)&my_query,"\n",local_bc,local_c0,local_c4);
                }
              }
            }
            if (escaped1 != (char *)0x0) {
              free(escaped1);
              escaped1 = (char *)0x0;
            }
            if (escaped2 != (char *)0x0) {
              free(escaped2);
              escaped2 = (char *)0x0;
            }
          }
        }
        if (Boundary != (char *)0x0) {
          HTBprintf((bstring **)&my_query,"\r\n--%s--\r\n",Boundary);
        }
        if (WWW_TraceFlag != '\0') {
          if (WWW_TraceFlag != '\0') {
            if (my_query == (bstring_conflict *)0x0) {
              local_b4 = L'\0';
            }
            else {
              local_b4 = my_query->len;
            }
            pFVar4 = TraceFP();
            fprintf((FILE *)pFVar4,"Query %d{",local_b4);
          }
          trace_bstring((bstring *)my_query);
          if (WWW_TraceFlag != '\0') {
            pFVar4 = TraceFP();
            fprintf((FILE *)pFVar4,"}\n");
          }
        }
      }
      if (submit_item->submit_method == L'\x03') {
        pcVar6 = submit_item->submit_action;
        pcVar9 = (char *)gettext("Submitting %s");
        HTUserMsg2(pcVar9,pcVar6);
        HTSABCat((bstring **)&my_query,"",1);
        pcVar6 = content_type_out;
        if (my_query == (bstring_conflict *)0x0) {
          local_ac = (char *)0x0;
        }
        else {
          local_ac = my_query->str;
        }
        if ((submit_item->submit_title == (char *)0x0) || (*submit_item->submit_title == '\0')) {
          pcVar9 = HText_getTitle();
          if (pcVar9 == (char *)0x0) {
            local_a4 = "";
          }
          else {
            local_a4 = HText_getTitle();
          }
          local_a8 = local_a4;
        }
        else {
          local_a8 = submit_item->submit_title;
        }
        mailform(submit_item->submit_action + 7,local_a8,local_ac,pcVar6);
        result = L'\0';
        HTSABFree((bstring **)&my_query);
        if (content_type_out != (char *)0x0) {
          free(content_type_out);
          content_type_out = (char *)0x0;
        }
      }
      else {
        mustshow = '\x01';
        pcVar6 = (char *)gettext("Submitting form...");
        statusline(pcVar6);
        if ((submit_item->submit_method == L'\x02') || (Boundary != (char *)0x0)) {
          LYFreePostData(doc);
          pcVar6 = content_type_out;
          doc->post_data = my_query;
          doc->post_content_type = content_type_out;
          if (WWW_TraceFlag != '\0') {
            pFVar4 = TraceFP();
            fprintf((FILE *)pFVar4,"GridText - post_data set:\n%s\n",pcVar6);
          }
          HTSACopy(&doc->address,submit_item->submit_action);
        }
        else {
          HTSABCat((bstring **)&my_query,"",1);
          if (my_query == (bstring_conflict *)0x0) {
            local_a0 = (char *)0x0;
          }
          else {
            local_a0 = my_query->str;
          }
          HTSACopy(&doc->address,local_a0);
          LYFreePostData(doc);
          if (content_type_out != (char *)0x0) {
            free(content_type_out);
            content_type_out = (char *)0x0;
          }
        }
        result = L'\x01';
      }
      if (MultipartContentType != (char *)0x0) {
        free(MultipartContentType);
        MultipartContentType = (char *)0x0;
      }
      if (previous_blanks != (char *)0x0) {
        free(previous_blanks);
        previous_blanks = (char *)0x0;
      }
      if (Boundary != (char *)0x0) {
        free(Boundary);
        Boundary = (char *)0x0;
      }
      if (my_data != (PostData *)0x0) {
        for (anchor_count = L'\0'; anchor_count < anchor_limit;
            anchor_count = anchor_count + L'\x01') {
          if (my_data[anchor_count].name != (char *)0x0) {
            free(my_data[anchor_count].name);
            my_data[anchor_count].name = (char *)0x0;
          }
          if (my_data[anchor_count].value != (char *)0x0) {
            free(my_data[anchor_count].value);
            my_data[anchor_count].value = (char *)0x0;
          }
          HTSABFree((bstring **)&my_data[anchor_count].data);
        }
        if (my_data != (PostData *)0x0) {
          free(my_data);
        }
      }
      local_194 = result;
    }
  }
  return local_194;
}



// WARNING: Unknown calling convention

void HText_DisableCurrentForm(void)

{
  TextAnchor *anchor_ptr;
  
  HTFormDisabled = '\x01';
  if (HTMainText != (HText *)0x0) {
    for (anchor_ptr = HTMainText->first_anchor; anchor_ptr != (TextAnchor *)0x0;
        anchor_ptr = anchor_ptr->next) {
      if ((anchor_ptr->link_type == '\x02') && (anchor_ptr->input_field->number == HTFormNumber)) {
        anchor_ptr->input_field->disabled = L'\x01';
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

void HText_ResetForm(FormInfo *form)

{
  char *text;
  TextAnchor *anchor_ptr;
  
  mustshow = '\x01';
  text = (char *)gettext("Resetting form...");
  statusline(text);
  if (HTMainText != (HText *)0x0) {
    for (anchor_ptr = HTMainText->first_anchor; anchor_ptr != (TextAnchor *)0x0;
        anchor_ptr = anchor_ptr->next) {
      if (anchor_ptr->link_type == '\x02') {
        if (anchor_ptr->input_field->number == form->number) {
          if ((anchor_ptr->input_field->type == L'\x04') ||
             (anchor_ptr->input_field->type == L'\x03')) {
            if (*anchor_ptr->input_field->orig_value == '0') {
              anchor_ptr->input_field->num_value = L'\0';
            }
            else {
              anchor_ptr->input_field->num_value = L'\x01';
            }
          }
          else if (anchor_ptr->input_field->type == L'\a') {
            anchor_ptr->input_field->value = anchor_ptr->input_field->orig_value;
            anchor_ptr->input_field->cp_submit_value = anchor_ptr->input_field->orig_submit_value;
          }
          else {
            HTSACopy(&anchor_ptr->input_field->value,anchor_ptr->input_field->orig_value);
          }
        }
        else if (form->number < anchor_ptr->input_field->number) {
          return;
        }
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

BOOLEAN HText_HaveUserChangedForms(HText *text)

{
  int iVar1;
  TextAnchor *anchor_ptr;
  
  if (text != (HText *)0x0) {
    for (anchor_ptr = text->first_anchor; anchor_ptr != (TextAnchor *)0x0;
        anchor_ptr = anchor_ptr->next) {
      if (anchor_ptr->link_type == '\x02') {
        if ((anchor_ptr->input_field->type == L'\x04') || (anchor_ptr->input_field->type == L'\x03')
           ) {
          if (((*anchor_ptr->input_field->orig_value == '0') &&
              (anchor_ptr->input_field->num_value == L'\x01')) ||
             ((*anchor_ptr->input_field->orig_value != '0' &&
              (anchor_ptr->input_field->num_value == L'\0')))) {
            return '\x01';
          }
        }
        else if (anchor_ptr->input_field->type == L'\a') {
          iVar1 = strcmp(anchor_ptr->input_field->value,anchor_ptr->input_field->orig_value);
          if (iVar1 != 0) {
            return '\x01';
          }
          iVar1 = strcmp(anchor_ptr->input_field->cp_submit_value,
                         anchor_ptr->input_field->orig_submit_value);
          if (iVar1 != 0) {
            return '\x01';
          }
        }
        else {
          iVar1 = strcmp(anchor_ptr->input_field->value,anchor_ptr->input_field->orig_value);
          if (iVar1 != 0) {
            return '\x01';
          }
        }
      }
    }
  }
  return '\0';
}



// WARNING: Unknown calling convention

void HText_activateRadioButton(FormInfo *form)

{
  wchar_t wVar1;
  int iVar2;
  wchar_t form_number;
  TextAnchor *anchor_ptr;
  
  wVar1 = form->number;
  if (HTMainText != (HText *)0x0) {
    for (anchor_ptr = HTMainText->first_anchor; anchor_ptr != (TextAnchor *)0x0;
        anchor_ptr = anchor_ptr->next) {
      if ((anchor_ptr->link_type == '\x02') && (anchor_ptr->input_field->type == L'\x04')) {
        if (anchor_ptr->input_field->number == wVar1) {
          iVar2 = strcmp(anchor_ptr->input_field->name,form->name);
          if ((iVar2 == 0) && (anchor_ptr->input_field->num_value != L'\0')) {
            anchor_ptr->input_field->num_value = L'\0';
            break;
          }
        }
        else if (wVar1 < anchor_ptr->input_field->number) break;
      }
    }
    form->num_value = L'\x01';
  }
  return;
}



// WARNING: Unknown calling convention

char * stub_HTAnchor_address(HTAnchor *me)

{
  char *addr;
  
  addr = (char *)0x0;
  if (me != (HTAnchor *)0x0) {
    HTSACopy(&addr,me->parent->address);
  }
  return addr;
}



// WARNING: Unknown calling convention

void HText_setToolbar(HText *text)

{
  if (text != (HText *)0x0) {
    text->toolbar = '\x01';
  }
  return;
}



// WARNING: Unknown calling convention

BOOLEAN HText_hasToolbar(HText *text)

{
  BOOLEAN local_8;
  
  if ((text == (HText *)0x0) || (text->toolbar == '\0')) {
    local_8 = '\0';
  }
  else {
    local_8 = '\x01';
  }
  return local_8;
}



// WARNING: Unknown calling convention

void HText_setNoCache(HText *text)

{
  if (text != (HText *)0x0) {
    text->no_cache = '\x01';
  }
  return;
}



// WARNING: Unknown calling convention

BOOLEAN HText_hasNoCacheSet(HText *text)

{
  BOOLEAN local_8;
  
  if ((text == (HText *)0x0) || (text->no_cache == '\0')) {
    local_8 = '\0';
  }
  else {
    local_8 = '\x01';
  }
  return local_8;
}



// WARNING: Unknown calling convention

BOOLEAN HText_hasUTF8OutputSet(HText *text)

{
  BOOLEAN local_8;
  
  if ((text == (HText *)0x0) || ((text->T).output_utf8 == '\0')) {
    local_8 = '\0';
  }
  else {
    local_8 = '\x01';
  }
  return local_8;
}



// WARNING: Unknown calling convention

void HText_setKcode(HText *text,char *charset,LYUCcharset_conflict *p_in)

{
  int iVar1;
  bool bVar2;
  BOOLEAN charset_explicit;
  
  if (text == (HText *)0x0) {
    return;
  }
  if ((charset == (char *)0x0) && (p_in == (LYUCcharset_conflict *)0x0)) {
    return;
  }
  bVar2 = charset != (char *)0x0;
  if ((charset == (char *)0x0) || (*charset == '\0')) {
    charset = p_in->MIMEname;
  }
  if (charset == (char *)0x0) {
    return;
  }
  if (*charset == '\0') {
    return;
  }
  if ((bVar2) &&
     (((iVar1 = strcmp(charset,"shift_jis"), iVar1 == 0 ||
       (iVar1 = strcmp(charset,"x-sjis"), iVar1 == 0)) ||
      (iVar1 = strcmp(charset,"x-shift-jis"), iVar1 == 0)))) {
    text->kcode = SJIS;
  }
  else if (((bVar2) && (iVar1 = strcmp(charset,"utf-8"), iVar1 != 0)) &&
          (((p_in != (LYUCcharset_conflict *)0x0 && (p_in->enc == L'\x05')) ||
           (((((iVar1 = strcmp(charset,"x-euc"), iVar1 == 0 ||
               (iVar1 = strcmp(charset,"euc-jp"), iVar1 == 0)) ||
              ((iVar1 = strncmp(charset,"x-euc-",6), iVar1 == 0 ||
               ((((iVar1 = strcmp(charset,"euc-kr"), iVar1 == 0 ||
                  (iVar1 = strcmp(charset,"iso-2022-kr"), iVar1 == 0)) ||
                 (iVar1 = strcmp(charset,"big5"), iVar1 == 0)) ||
                ((iVar1 = strcmp(charset,"cn-big5"), iVar1 == 0 ||
                 (iVar1 = strcmp(charset,"euc-cn"), iVar1 == 0)))))))) ||
             (iVar1 = strcmp(charset,"gb2312"), iVar1 == 0)) ||
            ((iVar1 = strncmp(charset,"cn-gb",5), iVar1 == 0 ||
             (iVar1 = strcmp(charset,"iso-2022-cn"), iVar1 == 0)))))))) {
    text->kcode = EUC;
  }
  else {
    text->kcode = NOKANJI;
    if ((HTCJK != NOCJK) &&
       ((p_in == (LYUCcharset_conflict *)0x0 || ((p_in->enc != L'\x05' && (p_in->enc != L'\a'))))))
    {
      HTCJK = NOCJK;
    }
  }
  if ((bVar2) && (iVar1 = strcmp(charset,"utf-8"), iVar1 != 0)) {
    text->specified_kcode = text->kcode;
    return;
  }
  if (UCAssume_MIMEcharset != (char *)0x0) {
    iVar1 = strcmp(UCAssume_MIMEcharset,"euc-jp");
    if (iVar1 == 0) {
      text->specified_kcode = EUC;
      text->kcode = text->specified_kcode;
    }
    else {
      iVar1 = strcmp(UCAssume_MIMEcharset,"shift_jis");
      if (iVar1 == 0) {
        text->specified_kcode = SJIS;
        text->kcode = text->specified_kcode;
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

void HText_setBreakPoint(HText *text)

{
  if (text != (HText *)0x0) {
    text->permissible_split = (uint)text->last_line->size;
  }
  return;
}



// WARNING: Unknown calling convention

BOOLEAN HText_AreDifferent(HTParentAnchor *anchor,char *full_address)

{
  HTParentAnchor *pHVar1;
  BOOLEAN BVar2;
  char *pcVar3;
  int iVar4;
  BOOLEAN local_19;
  char *local_18;
  char *MTpound;
  char *MTaddress;
  HTParentAnchor *MTanc;
  
  if (((HTMainText == (HText *)0x0) || (anchor == (HTParentAnchor *)0x0)) ||
     (full_address == (char *)0x0)) {
    local_19 = '\x01';
  }
  else {
    pHVar1 = HTMainText->node_anchor;
    if ((pHVar1->address == (char *)0x0) || (anchor->address == (char *)0x0)) {
      local_19 = '\x01';
    }
    else {
      pcVar3 = strchr(full_address,0x23);
      if (pcVar3 == (char *)0x0) {
        local_19 = '\x01';
      }
      else {
        iVar4 = strncasecomp(anchor->address,"LYNXIMGMAP:",0xb);
        if (iVar4 == 0) {
          local_19 = '\x01';
        }
        else if (pHVar1->isHEAD == anchor->isHEAD) {
          iVar4 = strncasecomp(pHVar1->address,"LYNXIMGMAP:",0xb);
          if (iVar4 == 0) {
            local_18 = pHVar1->address + 0xb;
          }
          else {
            local_18 = pHVar1->address;
          }
          pcVar3 = trimPoundSelector(local_18);
          iVar4 = strcmp(local_18,anchor->address);
          if (iVar4 == 0) {
            if (pcVar3 != (char *)0x0) {
              *pcVar3 = '#';
            }
            if (pHVar1->address == local_18) {
              if (pHVar1->post_data == (bstring *)0x0) {
                if (anchor->post_data != (bstring *)0x0) {
                  return '\x01';
                }
              }
              else {
                if (anchor->post_data == (bstring *)0x0) {
                  return '\x01';
                }
                BVar2 = HTSABEql(pHVar1->post_data,anchor->post_data);
                if (BVar2 == '\0') {
                  return '\x01';
                }
              }
            }
            local_19 = '\0';
          }
          else {
            if (pcVar3 != (char *)0x0) {
              *pcVar3 = '#';
            }
            local_19 = '\x01';
          }
        }
        else {
          local_19 = '\x01';
        }
      }
    }
  }
  return local_19;
}



wchar_t increment_tagged_htline
                  (HTLine *ht,TextAnchor *a,wchar_t *lx_val,wchar_t *old_val,wchar_t incr,
                  wchar_t mode)

{
  byte bVar1;
  bool bVar2;
  bool bVar3;
  wchar_t wVar4;
  ushort **ppuVar5;
  char *pcVar6;
  size_t sVar7;
  pool_data *ppVar8;
  size_t sVar9;
  int in_GS_OFFSET;
  wchar_t *old_val_local;
  wchar_t *lx_val_local;
  TextAnchor *a_local;
  HTLine *ht_local;
  HTLine *temp;
  wchar_t fixup;
  wchar_t post_n;
  wchar_t pre_n;
  wchar_t new_n;
  wchar_t n;
  wchar_t val;
  char *t;
  char *lx;
  char *s;
  char *p;
  TextAnchor *nxt_anchor;
  TextAnchor *st_anchor;
  BOOLEAN valid;
  BOOLEAN plx;
  char lxbuf [2048];
  char buf [1024];
  int local_8;
  
  ht_local = ht;
  local_8 = *(int *)(in_GS_OFFSET + 0x14);
  st_anchor = a;
  p = ht->data;
  s = buf;
  bVar3 = false;
  fixup = L'\0';
  if (*lx_val != L'\0') {
    for (nxt_anchor = a; (nxt_anchor != (TextAnchor *)0x0 && (nxt_anchor->line_num == a->line_num));
        nxt_anchor = nxt_anchor->next) {
      nxt_anchor->line_pos = nxt_anchor->line_pos + (short)*lx_val;
    }
    fixup = *lx_val;
    *lx_val = L'\0';
    if (a != (TextAnchor *)0x0) {
      st_anchor = a->next;
    }
  }
  do {
    while( true ) {
      if (*p == '\0') goto LAB_080733d8;
      if (*p == '[') break;
      *s = *p;
      s = s + 1;
      p = p + 1;
    }
    *s = *p;
    s = s + 1;
    p = p + 1;
    n = L'\0';
    bVar2 = true;
    t = p;
    while (*t != ']') {
      if (*t == '\0') {
        bVar2 = false;
        bVar3 = true;
        break;
      }
      ppuVar5 = __ctype_b_loc();
      bVar1 = *t;
      t = t + 1;
      if (((*ppuVar5)[bVar1] & 0x800) == 0) {
        bVar2 = false;
        break;
      }
      n = n + L'\x01';
    }
    if ((bVar2) && (L'\0' < n)) {
      wVar4 = atoi(p);
      if ((*old_val == wVar4) || (*old_val == L'\0')) {
        if (*old_val != L'\0') {
          *old_val = *old_val + L'\x01';
        }
        sprintf(s,"%d",wVar4 + incr);
        sVar7 = strlen(s);
        s = s + sVar7;
        p = p + n;
        if (sVar7 - n != 0) {
          for (nxt_anchor = st_anchor;
              (nxt_anchor != (TextAnchor *)0x0 && (nxt_anchor->line_num == a->line_num));
              nxt_anchor = nxt_anchor->next) {
            nxt_anchor->line_pos = nxt_anchor->line_pos + (short)(sVar7 - n);
          }
          if (st_anchor != (TextAnchor *)0x0) {
            st_anchor = st_anchor->next;
          }
        }
      }
    }
    sVar7 = strlen(p);
    sVar9 = strlen(ht->next->data);
  } while ((!bVar3) || (0x7ff < (int)(sVar7 + sVar9 + 2)));
  strcpy(lxbuf,p);
  strcat(lxbuf,ht->next->data);
  n = L'\0';
  bVar3 = true;
  t = lxbuf;
  do {
    if (*t == ']') {
LAB_0807325c:
      if (((bVar3) && (L'\0' < n)) && (n + sVar9 + 2 < 0x400)) {
        wVar4 = atoi(lxbuf);
        if ((*old_val == wVar4) || (*old_val == L'\0')) {
          if (*old_val != L'\0') {
            *old_val = *old_val + L'\x01';
          }
          sprintf(lxbuf,"%d",wVar4 + incr);
          sVar9 = strlen(lxbuf);
          pcVar6 = strchr(ht->next->data,0x5d);
          strcat(lxbuf,pcVar6);
          pcVar6 = strncpy(s,lxbuf,sVar7);
          s = pcVar6 + sVar7;
          strcpy(ht->next->data,lxbuf + sVar7);
          *lx_val = sVar9 - n;
        }
      }
LAB_080733d8:
      *s = '\0';
      sVar7 = strlen(ht->data);
      if (mode == L'\x01') {
        buf[sVar7] = '\0';
      }
      else {
        sVar9 = strlen(buf);
        if (ht->size < sVar9) {
          sVar9 = strlen(buf);
          ht_local = (HTLine *)ALLOC_IN_POOL(&HTMainText->pool,sVar9 + 0x14);
          if (ht_local == (HTLine *)0x0) {
            outofmem("./GridText.c","increment_tagged_htline");
          }
          memcpy(ht_local,ht,0x14);
          ppVar8 = ALLOC_IN_POOL(&HTMainText->pool,(uint)ht->numstyles * 4);
          ht_local->styles = ppVar8;
          if (ht_local->styles == (HTStyleChange *)0x0) {
            outofmem("./GridText.c","increment_tagged_htline");
          }
          memcpy(ht_local->styles,ht->styles,(uint)ht->numstyles * 4);
          ht_local->prev->next = ht_local;
          ht_local->next->prev = ht_local;
        }
      }
      strcpy(ht_local->data,buf);
      sVar9 = strlen(buf);
      if (local_8 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
        __stack_chk_fail();
      }
      return (sVar9 - sVar7) + fixup;
    }
    ppuVar5 = __ctype_b_loc();
    bVar1 = *t;
    t = t + 1;
    if (((*ppuVar5)[bVar1] & 0x800) == 0) {
      bVar3 = false;
      goto LAB_0807325c;
    }
    n = n + L'\x01';
  } while( true );
}



// WARNING: Unknown calling convention

void insert_new_textarea_anchor(TextAnchor **curr_anchor,HTLine **exit_htline)

{
  wchar_t wVar1;
  wchar_t i;
  wchar_t lx;
  wchar_t curr_tag;
  HTLine *l;
  FormInfo *f;
  TextAnchor *a;
  HTLine *htline;
  TextAnchor *anchor;
  
  anchor = *curr_anchor;
  a = (TextAnchor *)0x0;
  f = (FormInfo *)0x0;
  l = (HTLine *)0x0;
  curr_tag = L'\0';
  lx = L'\0';
  htline = HTMainText->last_line->next;
  i = L'\0';
  while ((anchor->line_num != i && (htline = htline->next, HTMainText->last_line != htline))) {
    i = i + L'\x01';
  }
  l = (HTLine *)ALLOC_IN_POOL(&HTMainText->pool,0x414);
  a = (TextAnchor *)ALLOC_IN_POOL(&HTMainText->pool,0x34);
  f = (FormInfo *)ALLOC_IN_POOL(&HTMainText->pool,0x60);
  if (((a == (TextAnchor *)0x0) || (l == (HTLine *)0x0)) || (f == (FormInfo *)0x0)) {
    outofmem("./GridText.c","insert_new_textarea_anchor");
  }
  a->next = anchor->next;
  a->number = anchor->number;
  a->line_pos = anchor->line_pos;
  a->extent = anchor->extent;
  wVar1 = SGML_offset();
  a->sgml_offset = wVar1;
  a->line_num = anchor->line_num + L'\x01';
  LYCopyHiText(a,anchor);
  a->link_type = anchor->link_type;
  a->input_field = f;
  a->show_anchor = anchor->show_anchor;
  a->inUnderline = anchor->inUnderline;
  a->expansion_anch = '\x01';
  a->anchor = (HTChildAnchor *)0x0;
  HTSACopy(&f->name,anchor->input_field->name);
  f->number = anchor->input_field->number;
  f->type = anchor->input_field->type;
  HTSACopy(&f->orig_value,"");
  f->size = anchor->input_field->size;
  f->maxlength = anchor->input_field->maxlength;
  f->no_cache = anchor->input_field->no_cache;
  f->disabled = anchor->input_field->disabled;
  f->value_cs = current_char_set;
  l->next = htline->next;
  l->prev = htline;
  l->offset = htline->offset;
  l->size = htline->size;
  l->numstyles = htline->numstyles;
  l->styles = htline->styles;
  strcpy(l->data,htline->data);
  htline->next->prev = l;
  htline->next = l;
  if ((keypad_mode == 3) || (keypad_mode == 2)) {
    a->number = a->number + L'\x01';
    increment_tagged_htline(l,a,&lx,&curr_tag,L'\x01',L'\x01');
  }
  if (HTMainText->last_anchor == anchor) {
    HTMainText->last_anchor = a;
  }
  if (HTMainText->last_line == htline) {
    HTMainText->last_line = l;
  }
  anchor->next = a;
  *curr_anchor = a;
  *exit_htline = l->next;
  return;
}



// WARNING: Unknown calling convention

void update_subsequent_anchors
               (wchar_t newlines,TextAnchor *start_anchor,HTLine *start_htline,wchar_t start_tag)

{
  FILE *pFVar1;
  char *Msg;
  wchar_t hang_detect;
  wchar_t hang;
  wchar_t lx;
  wchar_t tag_adj;
  wchar_t line_adj;
  HTLine *htline;
  TextAnchor *anchor;
  
  htline = start_htline;
  line_adj = L'\0';
  tag_adj = L'\0';
  lx = L'\0';
  hang = L'\0';
  if (WWW_TraceFlag != '\0') {
    pFVar1 = TraceFP();
    fprintf((FILE *)pFVar1,"GridText: adjusting struct\'s to add %d new line(s)\n",newlines);
  }
  for (anchor = start_anchor->next; anchor != (TextAnchor *)0x0; anchor = anchor->next) {
    if (((keypad_mode == 3) || (keypad_mode == 2)) && (anchor->number != L'\0')) {
      anchor->number = anchor->number + newlines;
    }
    anchor->line_num = anchor->line_num + newlines;
  }
  if ((keypad_mode == 3) || (keypad_mode == 2)) {
    anchor = start_anchor->next;
    for (; HTMainText->last_line->next != htline; htline = htline->next) {
      for (; (anchor != (TextAnchor *)0x0 && (anchor->number - newlines != start_tag));
          anchor = anchor->next) {
        hang = hang + L'\x01';
        if ((anchor->next == anchor) || (L'' < hang)) {
          Msg = (char *)gettext("Hang Detect: TextAnchor struct corrupted - suggest aborting!");
          HTAlert(Msg);
          goto finish;
        }
      }
      if (anchor == (TextAnchor *)0x0) break;
      line_adj = increment_tagged_htline(htline,anchor,&lx,&start_tag,newlines,L'\0');
      htline->size = htline->size + (short)line_adj;
      tag_adj = tag_adj + line_adj;
    }
  }
finish:
  nlinks = nlinks + newlines;
  HTMainText->Lines = HTMainText->Lines + newlines;
  HTMainText->last_anchor_number = HTMainText->last_anchor_number + newlines;
  more_text = HText_canScrollDown();
  if (WWW_TraceFlag != '\0') {
    pFVar1 = TraceFP();
    fprintf((FILE *)pFVar1,"GridText: TextAnchor and HTLine struct\'s adjusted\n");
  }
  return;
}



// WARNING: Unknown calling convention

BOOLEAN IsFormsTextarea(FormInfo *form,TextAnchor *anchor_ptr)

{
  int iVar1;
  
  if ((((anchor_ptr->link_type == '\x02') && (anchor_ptr->input_field->type == L'\t')) &&
      (anchor_ptr->input_field->number == form->number)) &&
     (iVar1 = strcmp(anchor_ptr->input_field->name,form->name), iVar1 == 0)) {
    return '\x01';
  }
  return '\0';
}



// WARNING: Unknown calling convention

wchar_t finish_ExtEditForm(LinkInfo_conflict *form_link,TextAnchor *start_anchor,char *ed_temp,
                          wchar_t orig_cnt)

{
  bool bVar1;
  FILE *pFVar2;
  int iVar3;
  ushort **ppuVar4;
  char *pcVar5;
  char *pcVar6;
  wchar_t wVar7;
  stat stat_info;
  wchar_t i;
  wchar_t skip_num;
  char *skip_at;
  wchar_t wanted_fieldlen_wrap;
  wchar_t len_in;
  wchar_t len0;
  wchar_t len;
  wchar_t newlines;
  wchar_t match_tag;
  char *cp;
  char *lp;
  char *line;
  char *ebuf;
  HTLine *htline;
  wchar_t line_cnt;
  wchar_t exit_line;
  wchar_t entry_line;
  TextAnchor *end_anchor;
  TextAnchor *anchor_ptr;
  FILE *fp;
  size_t size;
  BOOLEAN wrapalert;
  
  end_anchor = (TextAnchor *)0x0;
  wrapalert = '\0';
  entry_line = form_link->anchor_line_num;
  exit_line = L'\0';
  line_cnt = L'\x01';
  htline = (HTLine *)0x0;
  match_tag = L'\0';
  newlines = L'\0';
  wanted_fieldlen_wrap = L'\xffffffff';
  skip_at = (char *)0x0;
  skip_num = L'\0';
  if (WWW_TraceFlag != '\0') {
    pFVar2 = TraceFP();
    fprintf((FILE *)pFVar2,"GridText: entered HText_ExtEditForm()\n");
  }
  iVar3 = stat64(ed_temp,(stat64 *)&stat_info);
  if (((iVar3 < 0) || ((stat_info.st_mode & 0xf000) != 0x8000)) ||
     (size = (size_t)stat_info.st_size, (size_t)stat_info.st_size == 0)) {
    size = 0;
    ebuf = (char *)calloc(1,1);
    if (ebuf == (char *)0x0) {
      outofmem("./GridText.c","HText_ExtEditForm");
    }
  }
  else {
    ebuf = (char *)calloc((size_t)stat_info.st_size + 1,1);
    if (ebuf == (char *)0x0) {
      pcVar5 = (char *)gettext("Not enough memory for file!");
      HTAlwaysAlert((char *)0x0,pcVar5);
      return L'\0';
    }
    fp = (FILE *)fopen64(ed_temp,"r");
    size = fread(ebuf,1,size,(FILE *)fp);
    LYCloseInput(fp);
    ebuf[size] = '\0';
  }
  while (size != 0) {
    if (LYtrimInputFields == '\0') {
      if ((ebuf[size - 1] == '\r') || (ebuf[size - 1] == '\n')) {
        bVar1 = true;
      }
      else {
        bVar1 = false;
      }
      if (!bVar1) goto LAB_08073d78;
    }
    else {
      ppuVar4 = __ctype_b_loc();
      if (((*ppuVar4)[(byte)ebuf[size - 1]] & 0x2000) == 0) {
LAB_08073d78:
        if (ebuf[size - 1] != '\0') break;
      }
    }
    size = size - 1;
    ebuf[size] = '\0';
  }
  pcVar5 = (char *)malloc(0x400);
  if (pcVar5 == (char *)0x0) {
    outofmem("./GridText.c","HText_ExtEditForm");
  }
  anchor_ptr = start_anchor;
  if ((start_anchor->input_field->size < L'\x05') || (L'' < start_anchor->input_field->size)) {
    wanted_fieldlen_wrap = L'\0';
  }
  len = L'\0';
  lp = ebuf;
  do {
    if (((orig_cnt < line_cnt) && (*lp == '\0')) && ((len == L'\0' || (*lp != '\0')))) {
      if (WWW_TraceFlag != '\0') {
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2,"GridText: edited text inserted into lynx struct\'s\n");
      }
      if (L'\0' < newlines) {
        update_subsequent_anchors(newlines,end_anchor,htline,match_tag);
      }
      if (pcVar5 != (char *)0x0) {
        free(pcVar5);
      }
      if (ebuf != (char *)0x0) {
        free(ebuf);
      }
      return exit_line - entry_line;
    }
    if (skip_at == (char *)0x0) {
      len0 = L'\0';
    }
    else {
      len0 = (int)skip_at - (int)lp;
      strncpy(pcVar5,lp,len0);
      pcVar5[len0] = '\0';
      lp = skip_at + skip_num;
      skip_at = (char *)0x0;
      skip_num = L'\0';
    }
    pcVar5[len0] = '\0';
    pcVar6 = strchr(lp,10);
    if (pcVar6 == (char *)0x0) {
      len = strlen(lp);
    }
    else {
      len = (int)pcVar6 - (int)lp;
    }
    if ((((wanted_fieldlen_wrap < L'\0') && (wrapalert == '\0')) &&
        (start_anchor->input_field->size <= len0 + len)) &&
       ((pcVar6 = strchr(lp,0x20), pcVar6 != (char *)0x0 &&
        ((int)pcVar6 - (int)lp < start_anchor->input_field->size + L'\xffffffff')))) {
      LYFixCursesOn("ask for confirmation:");
      LYerase();
      pcVar6 = (char *)gettext("Wrap lines to fit displayed area?");
      wVar7 = HTConfirmDefault(pcVar6,L'\0');
      if (wVar7 == L'\0') {
        wanted_fieldlen_wrap = L'\0';
      }
      else {
        wanted_fieldlen_wrap = start_anchor->input_field->size + L'\xffffffff';
      }
    }
    if ((L'\0' < wanted_fieldlen_wrap) && (wanted_fieldlen_wrap < len0 + len)) {
      for (i = wanted_fieldlen_wrap - len0;
          ((uint)(wanted_fieldlen_wrap >> 0x1f) >> 0x1e) + wanted_fieldlen_wrap >> 2 <= i + len0;
          i = i + L'\xffffffff') {
        ppuVar4 = __ctype_b_loc();
        if (((*ppuVar4)[(byte)lp[i]] & 0x2000) != 0) {
          len = i + L'\x01';
          cp = lp + i;
          if (((cp[1] != '\n') &&
              (ppuVar4 = __ctype_b_loc(), ((*ppuVar4)[(byte)cp[1]] & 0x2000) != 0)) &&
             (ppuVar4 = __ctype_b_loc(), ((*ppuVar4)[(byte)cp[2]] & 0x2000) == 0)) {
            len = i + L'\x02';
            cp = cp + 1;
          }
          ppuVar4 = __ctype_b_loc();
          if (((*ppuVar4)[(byte)cp[1]] & 0x2000) == 0) {
            for (; ((*cp != '\0' && (*cp != '\r')) &&
                   ((*cp != '\n' &&
                    ((int)cp - (int)lp <=
                     (((uint)(wanted_fieldlen_wrap * 3 >> 0x1f) >> 0x1e) + wanted_fieldlen_wrap * 3
                     >> 2) + len)))); cp = cp + 1) {
            }
            if ((*cp == '\r') && (cp[1] == '\n')) {
              cp = cp + 1;
            }
            if ((*cp == '\n') &&
               (((cp[1] == '\r' || (cp[1] == '\n')) ||
                (ppuVar4 = __ctype_b_loc(), ((*ppuVar4)[(byte)cp[1]] & 0x2000) == 0)))) {
              *cp = ' ';
              while (ppuVar4 = __ctype_b_loc(), ((*ppuVar4)[(byte)cp[-1]] & 0x2000) != 0) {
                skip_num = skip_num + L'\x01';
                cp = cp + -1;
              }
              skip_at = cp;
            }
          }
          break;
        }
      }
    }
    if ((L'\0' < wanted_fieldlen_wrap) && (i = len, wanted_fieldlen_wrap < len0 + len)) {
      do {
        i = i + L'\xffffffff';
        if (len0 + i + L'\x01' <= wanted_fieldlen_wrap) break;
        ppuVar4 = __ctype_b_loc();
      } while (((*ppuVar4)[(byte)lp[i]] & 0x2000) != 0);
      if (wanted_fieldlen_wrap < len0 + i + L'\x01') {
        len = wanted_fieldlen_wrap - len0;
      }
    }
    if (0x3ff < len0 + len) {
      if (wrapalert == '\0') {
        LYFixCursesOn("show alert:");
        pcVar6 = (char *)gettext("Very long lines have been wrapped!");
        HTAlert(pcVar6);
        wrapalert = '\x01';
      }
      for (i = L'' - len0; L'\0' < i; i = i + L'\xffffffff') {
        ppuVar4 = __ctype_b_loc();
        if (((*ppuVar4)[(byte)lp[i]] & 0x2000) != 0) {
          len = i;
          break;
        }
      }
      if (0x3ff < len0 + len) {
        len = L'' - len0;
      }
    }
    strncat(pcVar5,lp,len);
    pcVar5[len0 + len] = '\0';
    if (orig_cnt < line_cnt) {
      insert_new_textarea_anchor(&end_anchor,&htline);
      anchor_ptr = end_anchor;
      newlines = newlines + L'\x01';
    }
    HTSACopy(&anchor_ptr->input_field->value,pcVar5);
    if (len0 + len < 1) {
      if (exit_line == L'\0') {
        exit_line = anchor_ptr->line_num;
      }
    }
    else {
      exit_line = L'\0';
    }
    lp = lp + len;
    if ((*lp != 0) && (ppuVar4 = __ctype_b_loc(), ((*ppuVar4)[(byte)*lp] & 0x2000) != 0)) {
      lp = (char *)((byte *)lp + 1);
    }
    end_anchor = anchor_ptr;
    anchor_ptr = anchor_ptr->next;
    if (anchor_ptr != (_TextAnchor *)0x0) {
      match_tag = anchor_ptr->number;
    }
    line_cnt = line_cnt + L'\x01';
  } while( true );
}



wchar_t HText_ExtEditForm(LinkInfo_conflict *form_link)

{
  int iVar1;
  wchar_t wVar2;
  FormInfo *form_00;
  char *pcVar3;
  bool bVar4;
  BOOLEAN BVar5;
  FILE *pFVar6;
  char *result;
  int in_GS_OFFSET;
  wchar_t local_50;
  LinkInfo_conflict *form_link_local;
  FormInfo *form;
  wchar_t offset;
  wchar_t orig_cnt;
  wchar_t entry_line;
  wchar_t start_line;
  TextAnchor *start_anchor;
  TextAnchor *anchor_ptr;
  FILE *fp;
  char *ed_temp;
  BOOLEAN firstanchor;
  char ed_offset [10];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  start_anchor = (TextAnchor *)0x0;
  bVar4 = true;
  start_line = L'\0';
  wVar2 = form_link->anchor_line_num;
  orig_cnt = L'\0';
  form_00 = form_link->l_form;
  if (WWW_TraceFlag != '\0') {
    pFVar6 = TraceFP();
    fprintf((FILE *)pFVar6,"GridText: entered HText_ExtEditForm()\n");
  }
  result = (char *)malloc(0x100);
  pFVar6 = LYOpenTemp(result,"","w");
  if (pFVar6 == (FILE *)0x0) {
    if (result != (char *)0x0) {
      free(result);
    }
    local_50 = L'\0';
  }
  else {
    for (anchor_ptr = HTMainText->first_anchor; anchor_ptr != (TextAnchor *)0x0;
        anchor_ptr = anchor_ptr->next) {
      BVar5 = IsFormsTextarea(form_00,anchor_ptr);
      if (BVar5 == '\0') {
        if (!bVar4) break;
      }
      else {
        if (bVar4) {
          bVar4 = false;
          start_anchor = anchor_ptr;
          start_line = anchor_ptr->line_num;
        }
        orig_cnt = orig_cnt + L'\x01';
        fputs(anchor_ptr->input_field->value,(FILE *)pFVar6);
        fputc(10,(FILE *)pFVar6);
      }
    }
    LYCloseTempFP(pFVar6);
    if (WWW_TraceFlag != '\0') {
      pcVar3 = form_00->name;
      pFVar6 = TraceFP();
      fprintf((FILE *)pFVar6,"GridText: TEXTAREA name=|%s| dumped to tempfile\n",pcVar3);
    }
    pcVar3 = editor;
    if (WWW_TraceFlag != '\0') {
      pFVar6 = TraceFP();
      fprintf((FILE *)pFVar6,"GridText: invoking editor (%s) on tempfile\n",pcVar3);
    }
    ed_offset[0] = '\0';
    if (wVar2 != start_line && -1 < wVar2 - start_line) {
      BVar5 = editor_can_position();
      if (BVar5 != '\0') {
        sprintf(ed_offset,"%d",(wVar2 - start_line) + 1);
      }
    }
    edit_temporary_file(result,ed_offset,(char *)0x0);
    pcVar3 = editor;
    if (WWW_TraceFlag != '\0') {
      pFVar6 = TraceFP();
      fprintf((FILE *)pFVar6,"GridText: returned from editor (%s)\n",pcVar3);
    }
    if (form_00->disabled == L'\0') {
      offset = finish_ExtEditForm(form_link,start_anchor,result,orig_cnt);
    }
    else {
      offset = L'\0';
    }
    LYRemoveTemp(result);
    if (result != (char *)0x0) {
      free(result);
    }
    if (WWW_TraceFlag != '\0') {
      pFVar6 = TraceFP();
      fprintf((FILE *)pFVar6,"GridText: exiting HText_ExtEditForm()\n");
    }
    local_50 = offset;
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return local_50;
}



// WARNING: Unknown calling convention

void HText_ExpandTextarea(LinkInfo_conflict *form_link,wchar_t newlines)

{
  char *pcVar1;
  BOOLEAN BVar2;
  FILE *pFVar3;
  wchar_t i;
  wchar_t match_tag;
  HTLine *htline;
  FormInfo *form;
  TextAnchor *end_anchor;
  TextAnchor *anchor_ptr;
  BOOLEAN firstanchor;
  
  end_anchor = (TextAnchor *)0x0;
  firstanchor = '\x01';
  form = form_link->l_form;
  htline = (HTLine *)0x0;
  match_tag = L'\0';
  if (WWW_TraceFlag != '\0') {
    pFVar3 = TraceFP();
    fprintf((FILE *)pFVar3,"GridText: entered HText_ExpandTextarea()\n");
  }
  if (L'\0' < newlines) {
    for (anchor_ptr = HTMainText->first_anchor; anchor_ptr != (TextAnchor *)0x0;
        anchor_ptr = anchor_ptr->next) {
      BVar2 = IsFormsTextarea(form,anchor_ptr);
      if (BVar2 == '\0') {
        if (firstanchor == '\0') break;
      }
      else {
        if (firstanchor != '\0') {
          firstanchor = '\0';
        }
        end_anchor = anchor_ptr;
      }
    }
    for (i = L'\x01'; i <= newlines; i = i + L'\x01') {
      insert_new_textarea_anchor(&end_anchor,&htline);
      HTSACopy(&end_anchor->input_field->value,"");
      if (end_anchor->next != (_TextAnchor *)0x0) {
        match_tag = end_anchor->next->number;
      }
    }
    if (WWW_TraceFlag != '\0') {
      pcVar1 = form->name;
      pFVar3 = TraceFP();
      fprintf((FILE *)pFVar3,"GridText: %d blank line(s) added to TEXTAREA name=|%s|\n",newlines,
              pcVar1);
    }
    update_subsequent_anchors(newlines,end_anchor,htline,match_tag);
    if (WWW_TraceFlag != '\0') {
      pFVar3 = TraceFP();
      fprintf((FILE *)pFVar3,"GridText: exiting HText_ExpandTextarea()\n");
    }
  }
  return;
}



// WARNING: Unknown calling convention

wchar_t HText_InsertFile(LinkInfo_conflict *form_link)

{
  _line *p_Var1;
  BOOLEAN BVar2;
  FILE *pFVar3;
  char *pcVar4;
  int iVar5;
  wchar_t wVar6;
  wchar_t local_cc;
  wchar_t local_c8;
  stat stat_info;
  wchar_t i;
  wchar_t len;
  wchar_t newlines;
  wchar_t match_tag;
  wchar_t file_cs;
  wchar_t entry_line;
  char *cp;
  char *lp;
  char *line;
  char *fbuf;
  HTLine *l;
  FormInfo *f;
  TextAnchor *a;
  HTLine *htline;
  FormInfo *form;
  TextAnchor *end_anchor;
  TextAnchor *prev_anchor;
  TextAnchor *anchor_ptr;
  char *fn;
  FILE *fp;
  size_t size;
  BOOLEAN truncalert;
  BOOLEAN firstanchor;
  
  prev_anchor = (TextAnchor *)0x0;
  end_anchor = (TextAnchor *)0x0;
  firstanchor = '\x01';
  truncalert = '\0';
  form = form_link->l_form;
  htline = (HTLine *)0x0;
  a = (TextAnchor *)0x0;
  f = (FormInfo *)0x0;
  l = (HTLine *)0x0;
  entry_line = form_link->anchor_line_num;
  if (WWW_TraceFlag != '\0') {
    pFVar3 = TraceFP();
    fprintf((FILE *)pFVar3,"GridText: entered HText_InsertFile()\n");
  }
  fn = GetFileName();
  if (fn == (char *)0x0) {
    pcVar4 = (char *)gettext("File insert cancelled!!!");
    HTInfoMsg(pcVar4);
    if (WWW_TraceFlag != '\0') {
      pFVar3 = TraceFP();
      fprintf((FILE *)pFVar3,"GridText: file insert cancelled - no filename provided\n");
    }
    local_cc = L'\0';
  }
  else {
    if (((no_dotfiles != '\0') || (show_dotfiles == '\0')) &&
       (pcVar4 = LYPathLeaf(fn), *pcVar4 == '.')) {
      pcVar4 = (char *)gettext("File name may not begin with a dot.");
      HTUserMsg(pcVar4);
      return L'\0';
    }
    iVar5 = stat64(fn,(stat64 *)&stat_info);
    if ((iVar5 < 0) || (size = (size_t)stat_info.st_size, (size_t)stat_info.st_size == 0)) {
      pcVar4 = (char *)gettext("Nothing to insert - file is 0-length.");
      HTInfoMsg(pcVar4);
      if (WWW_TraceFlag != '\0') {
        pFVar3 = TraceFP();
        fprintf((FILE *)pFVar3,"GridText: file insert aborted - file=|%s|- was 0-length\n",fn);
      }
      if (fn != (char *)0x0) {
        free(fn);
      }
      local_cc = L'\0';
    }
    else {
      fbuf = (char *)calloc((size_t)stat_info.st_size + 1,1);
      if (fbuf == (char *)0x0) {
        free(fn);
        pcVar4 = (char *)gettext("Not enough memory for file!");
        HTAlert(pcVar4);
        local_cc = L'\0';
      }
      else {
        LYGetFileInfo(fn,(HTParentAnchor **)0x0,(HTFormat *)0x0,(HTAtom **)0x0,(char **)0x0,
                      (char **)0x0,&file_cs);
        fp = (FILE *)fopen64(fn,"r");
        if (fp == (FILE *)0x0) {
          free(fbuf);
          free(fn);
          pcVar4 = (char *)gettext("Can\'t open file for reading.");
          HTAlert(pcVar4);
          local_cc = L'\0';
        }
        else {
          size = fread(fbuf,1,size,(FILE *)fp);
          LYCloseInput(fp);
          if (fn != (char *)0x0) {
            free(fn);
            fn = (char *)0x0;
          }
          fbuf[size] = '\0';
          anchor_ptr = HTMainText->first_anchor;
          while ((anchor_ptr != (TextAnchor *)0x0 &&
                 ((BVar2 = IsFormsTextarea(form,anchor_ptr), BVar2 == '\0' ||
                  (anchor_ptr->line_num != entry_line))))) {
            prev_anchor = anchor_ptr;
            anchor_ptr = anchor_ptr->next;
          }
          htline = HTMainText->last_line->next;
          i = L'\0';
          while ((anchor_ptr->line_num != i &&
                 (htline = htline->next, HTMainText->last_line != htline))) {
            i = i + L'\x01';
          }
          l = (HTLine *)ALLOC_IN_POOL(&HTMainText->pool,0x414);
          a = (TextAnchor *)ALLOC_IN_POOL(&HTMainText->pool,0x34);
          f = (FormInfo *)ALLOC_IN_POOL(&HTMainText->pool,0x60);
          if (((a == (TextAnchor *)0x0) || (l == (HTLine *)0x0)) || (f == (FormInfo *)0x0)) {
            outofmem("./GridText.c","HText_InsertFile");
          }
          a->next = anchor_ptr;
          a->number = anchor_ptr->number;
          a->line_pos = anchor_ptr->line_pos;
          a->extent = anchor_ptr->extent;
          wVar6 = SGML_offset();
          a->sgml_offset = wVar6;
          a->line_num = anchor_ptr->line_num;
          LYCopyHiText(a,anchor_ptr);
          a->link_type = anchor_ptr->link_type;
          a->input_field = f;
          a->show_anchor = anchor_ptr->show_anchor;
          a->inUnderline = anchor_ptr->inUnderline;
          a->expansion_anch = '\x01';
          a->anchor = (HTChildAnchor *)0x0;
          HTSACopy(&f->name,anchor_ptr->input_field->name);
          f->number = anchor_ptr->input_field->number;
          f->type = anchor_ptr->input_field->type;
          HTSACopy(&f->orig_value,"");
          f->size = anchor_ptr->input_field->size;
          f->maxlength = anchor_ptr->input_field->maxlength;
          f->no_cache = anchor_ptr->input_field->no_cache;
          f->disabled = anchor_ptr->input_field->disabled;
          if (file_cs < L'\0') {
            local_c8 = current_char_set;
          }
          else {
            local_c8 = file_cs;
          }
          f->value_cs = local_c8;
          l->offset = htline->offset;
          l->size = htline->size;
          l->numstyles = htline->numstyles;
          l->styles = htline->styles;
          strcpy(l->data,htline->data);
          if (HTMainText->first_anchor == anchor_ptr) {
            HTMainText->first_anchor = a;
          }
          if (prev_anchor != (TextAnchor *)0x0) {
            prev_anchor->next = a;
          }
          p_Var1 = htline->prev;
          l->next = p_Var1->next;
          l->prev = p_Var1;
          p_Var1->next->prev = l;
          p_Var1->next = l;
          htline = p_Var1->next->next;
          anchor_ptr = a;
          newlines = L'\x01';
          line = (char *)malloc(0x400);
          if (line == (char *)0x0) {
            outofmem("./GridText.c","HText_InsertFile");
          }
          wVar6 = anchor_ptr->number;
          lp = fbuf;
          while (*lp != '\0') {
            cp = strchr(lp,10);
            if (cp == (char *)0x0) {
              len = strlen(lp);
            }
            else {
              len = (int)cp - (int)lp;
            }
            if (L'' < len) {
              if (truncalert == '\0') {
                pcVar4 = (char *)gettext("Very long lines have been truncated!");
                HTAlert(pcVar4);
                truncalert = '\x01';
              }
              len = L'';
              if (lp[0x3ff] != '\0') {
                lp[0x400] = '\0';
              }
            }
            strncpy(line,lp,len);
            line[len] = '\0';
            if (firstanchor == '\0') {
              insert_new_textarea_anchor(&end_anchor,&htline);
              anchor_ptr = end_anchor;
              newlines = newlines + L'\x01';
            }
            HTSACopy(&anchor_ptr->input_field->value,line);
            if (L'\xffffffff' < file_cs) {
              anchor_ptr->input_field->value_cs = file_cs;
            }
            lp = lp + len;
            if (*lp != '\0') {
              lp = lp + 1;
            }
            firstanchor = '\0';
            end_anchor = anchor_ptr;
            anchor_ptr = anchor_ptr->next;
          }
          if (WWW_TraceFlag != '\0') {
            pFVar3 = TraceFP();
            fprintf((FILE *)pFVar3,"GridText: file inserted into lynx struct\'s\n");
          }
          update_subsequent_anchors(newlines,end_anchor,htline,wVar6);
          if (line != (char *)0x0) {
            free(line);
            line = (char *)0x0;
          }
          if (fbuf != (char *)0x0) {
            free(fbuf);
            fbuf = (char *)0x0;
          }
          if (WWW_TraceFlag != '\0') {
            pFVar3 = TraceFP();
            fprintf((FILE *)pFVar3,"GridText: exiting HText_InsertFile()\n");
          }
          local_cc = newlines;
        }
      }
    }
  }
  return local_cc;
}



// WARNING: Unknown calling convention

wchar_t GetColumn(void)

{
  wchar_t local_18;
  wchar_t x;
  wchar_t y;
  wchar_t result;
  
  if (LYwin == (WINDOW *)0x0) {
    local_18 = L'\xffffffff';
  }
  else {
    local_18 = (wchar_t)LYwin->_curx;
  }
  return local_18;
}



// WARNING: Unknown calling convention

BOOLEAN DidWrap(wchar_t y0,wchar_t x0)

{
  wchar_t local_20;
  int local_1c;
  int local_18;
  wchar_t x;
  wchar_t y;
  BOOLEAN result;
  
  result = '\0';
  if (LYwin == (WINDOW *)0x0) {
    local_20 = L'\xffffffff';
    local_1c = -1;
  }
  else {
    local_20 = (wchar_t)LYwin->_cury;
    local_1c = (int)LYwin->_curx;
  }
  if (LYwideLines == L'\0') {
    local_18 = LYcols;
  }
  else {
    local_18 = 0x3f6;
  }
  if ((local_18 <= local_1c) || ((local_1c == 0 && (local_20 != y0)))) {
    result = '\x01';
  }
  return result;
}



// WARNING: Unknown calling convention

void redraw_part_of_line(HTLine *line,char *str,wchar_t len,HText *text)

{
  char *__src;
  BOOLEAN BVar1;
  wchar_t wVar2;
  ushort **ppuVar3;
  size_t sVar4;
  wchar_t local_48;
  wchar_t local_44;
  int local_3c;
  int local_38;
  char buffer [7];
  wchar_t XP;
  wchar_t YP;
  wchar_t scols;
  wchar_t tcols;
  wchar_t current_style;
  size_t utf_extra;
  char *end_of_data;
  char *data;
  char LastDisplayChar;
  
  utf_extra = 0;
  current_style = L'\0';
  LastDisplayChar = ' ';
  if (LYwin == (WINDOW *)0x0) {
    local_48 = L'\xffffffff';
    local_44 = L'\xffffffff';
  }
  else {
    local_48 = (wchar_t)LYwin->_cury;
    local_44 = (wchar_t)LYwin->_curx;
  }
  buffer[2] = '\0';
  buffer[1] = '\0';
  buffer[0] = '\0';
  data = str;
  local_38 = local_44 + L'\x01';
  __src = data;
LAB_08075439:
  while( true ) {
    data = __src;
    if (str + len <= data) {
      for (; current_style < (int)(uint)line->numstyles; current_style = current_style + L'\x01') {
        curses_style((uint)*(ushort *)&line->styles[current_style].field_0x2,
                     (uint)(*(byte *)(line->styles + current_style) & 3));
      }
      return;
    }
    buffer[0] = *data;
    __src = data + 1;
    wVar2 = GetColumn();
    scols = StyleToCols(text,line,current_style);
    while ((current_style < (int)(uint)line->numstyles && (scols <= wVar2))) {
      curses_style((uint)*(ushort *)&line->styles[current_style].field_0x2,
                   (uint)(*(byte *)(line->styles + current_style) & 3));
      current_style = current_style + L'\x01';
      scols = StyleToCols(text,line,current_style);
    }
    if (buffer[0] == '\a') goto LAB_08075299;
    if (buffer[0] != '\b') break;
    if (dump_output_immediately == '\0') {
      waddch(LYwin,0x2b);
      local_38 = local_38 + 1;
    }
  }
  goto LAB_080752db;
LAB_08075299:
  if (((*__src == '\0') &&
      (ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[(byte)LastDisplayChar] & 0x2000) == 0)) &&
     (LastDisplayChar != '-')) {
    buffer[0] = '-';
LAB_080752db:
    if (((text->T).output_utf8 != '\0') && (buffer[0] < '\0')) {
      utf_extra = utf8_length((text->T).output_utf8,data);
      LastDisplayChar = 'M';
    }
    if (utf_extra == 0) {
      if ((HTCJK == NOCJK) || (-1 < buffer[0])) {
        sVar4 = strlen(buffer);
        LYwaddnstr(LYwin,buffer,sVar4);
        LastDisplayChar = buffer[0];
      }
      else {
        if (LYwideLines == L'\0') {
          local_3c = LYcols;
        }
        else {
          local_3c = 0x3f6;
        }
        if (local_38 <= local_3c) {
          buffer[1] = *__src;
          buffer[2] = '\0';
          local_38 = local_38 + 1;
          sVar4 = strlen(buffer);
          LYwaddnstr(LYwin,buffer,sVar4);
          buffer[1] = '\0';
          LastDisplayChar = 'M';
          __src = data + 2;
        }
      }
    }
    else {
      strncpy(buffer + 1,__src,utf_extra);
      buffer[utf_extra + 1] = '\0';
      sVar4 = strlen(buffer);
      LYwaddnstr(LYwin,buffer,sVar4);
      buffer[1] = '\0';
      __src = __src + utf_extra;
      utf_extra = 0;
    }
    data = __src;
    BVar1 = DidWrap(local_48,local_44);
    __src = data;
    if (BVar1 == '\0') {
      local_38 = local_38 + 1;
    }
  }
  goto LAB_08075439;
}



// WARNING: Unknown calling convention

void redraw_lines_of_link(wchar_t cur)

{
  bool bVar1;
  HText *text_00;
  wchar_t wVar2;
  char *__s;
  char *text;
  wchar_t count;
  wchar_t col;
  wchar_t row;
  wchar_t lines_back;
  HTLine *todr1;
  
  if (HTMainText->next_line == HTMainText->last_line) {
    lines_back = HTMainText->Lines + ((1 - links[cur].ly) - HTMainText->top_of_screen);
  }
  else {
    lines_back = (1 - links[cur].ly) + display_lines;
  }
  todr1 = HTMainText->next_line;
  while (bVar1 = L'\0' < lines_back, lines_back = lines_back + L'\xffffffff', bVar1) {
    todr1 = todr1->prev;
  }
  row = links[cur].ly;
  if (no_title != '\0') {
    row = row + L'\xffffffff';
  }
  count = L'\0';
  while( true ) {
    if (display_lines < row) {
      return;
    }
    __s = LYGetHiliteStr(cur,count);
    if (__s == (char *)0x0) break;
    wVar2 = LYGetHilitePos(cur,count);
    LYmove(row,wVar2);
    text_00 = HTMainText;
    wVar2 = strlen(__s);
    redraw_part_of_line(todr1,__s,wVar2,text_00);
    todr1 = todr1->next;
    count = count + L'\x01';
    row = row + L'\x01';
  }
  return;
}



// WARNING: Unknown calling convention

void HTMark_asSource(void)

{
  if (HTMainText != (HText *)0x0) {
    HTMainText->source = '\x01';
  }
  return;
}



// WARNING: Unknown calling convention

HTkcode HText_getKcode(HText *text)

{
  return text->kcode;
}



// WARNING: Unknown calling convention

void HText_updateKcode(HText *text,HTkcode kcode)

{
  text->kcode = kcode;
  return;
}



// WARNING: Unknown calling convention

HTkcode HText_getSpecifiedKcode(HText *text)

{
  return text->specified_kcode;
}



// WARNING: Unknown calling convention

void HText_updateSpecifiedKcode(HText *text,HTkcode kcode)

{
  text->specified_kcode = kcode;
  return;
}



// WARNING: Unknown calling convention

wchar_t HTMainText_Get_UCLYhndl(void)

{
  wchar_t local_8;
  
  if (HTMainText == (HText *)0x0) {
    local_8 = L'\xffffffff';
  }
  else {
    local_8 = HTAnchor_getUCLYhndl(HTMainText->node_anchor,0);
  }
  return local_8;
}



// WARNING: Unknown calling convention

int getfile(DocInfo *doc,int *target)

{
  char cVar1;
  BOOLEAN BVar2;
  FILE *pFVar3;
  size_t sVar4;
  char *pcVar5;
  int iVar6;
  ushort **ppuVar7;
  wchar_t wVar8;
  char *pcVar9;
  undefined4 uVar10;
  UrlTypes UVar11;
  bstring_conflict *b;
  int local_6c;
  char *local_68;
  char *local_64;
  char *local_60;
  char *local_5c;
  DocAddress WWWDoc;
  char *msg;
  HTParentAnchor *tmpanchor_1;
  int status;
  char *proxy_1;
  char *proxy;
  char *title;
  HTParentAnchor *tmpanchor;
  char *last_slash;
  char *ref_url;
  long value;
  char *cp1;
  char *temp;
  char *cp;
  char *pound;
  UrlTypes url_type;
  
  url_type = NOT_A_URL_TYPE;
  cp = (char *)0x0;
  temp = (char *)0x0;
  if (LYCancelDownload != '\0') {
    if (WWW_TraceFlag != '\0') {
      pFVar3 = TraceFP();
      fprintf((FILE *)pFVar3,"getfile:    resetting LYCancelDownload to FALSE\n");
    }
    LYCancelDownload = '\0';
  }
  LYFakeZap('\0');
  redirection_attempts = 0;
Try_Redirected_URL:
  do {
    WWWDoc.address = doc->address;
    WWWDoc.post_data = (bstring *)doc->post_data;
    WWWDoc.post_content_type = doc->post_content_type;
    WWWDoc.bookmark = doc->bookmark;
    WWWDoc.isHEAD = doc->isHEAD;
    WWWDoc.safe = doc->safe;
    HTPermitRedir = '\0';
    if (WWW_Download_File != (char *)0x0) {
      free(WWW_Download_File);
      WWW_Download_File = (char *)0x0;
    }
    redirect_post_content = '\0';
    HTNoDataOK = 0;
    if (WWW_TraceFlag != '\0') {
      pcVar5 = doc->address;
      pFVar3 = TraceFP();
      fprintf((FILE *)pFVar3,"getfile: getting %s\n\n",pcVar5);
    }
    temp = HTParse(doc->address,"",8);
    if ((temp != (char *)0x0) && (sVar4 = strlen(temp), 3 < sVar4)) {
      cp1 = strchr(temp,0x40);
      if (cp1 == (char *)0x0) {
        cp1 = temp;
      }
      pcVar5 = strrchr(cp1,0x3a);
      if (pcVar5 != (char *)0x0) {
        cp = pcVar5 + 1;
        iVar6 = sscanf(cp,"%ld",&value);
        if (iVar6 == 1) {
          if ((value == 0x13) || (value == 0x10013)) {
            pcVar5 = (char *)gettext("Port 19 not permitted in URLs.");
            HTAlert(pcVar5);
            if (temp != (char *)0x0) {
              free(temp);
            }
            return 3;
          }
          if ((value == 0x19) || (value == 0x10019)) {
            pcVar5 = (char *)gettext("Port 25 not permitted in URLs.");
            HTAlert(pcVar5);
            if (temp != (char *)0x0) {
              free(temp);
            }
            return 3;
          }
          if ((0xffff < value) || (value < 0)) {
            msg = (char *)0x0;
            pcVar5 = (char *)gettext("Port %lu not permitted in URLs.");
            HTSprintf0(&msg,pcVar5,value);
            HTAlert(msg);
            if (msg != (char *)0x0) {
              free(msg);
              msg = (char *)0x0;
            }
            if (temp != (char *)0x0) {
              free(temp);
            }
            return 3;
          }
        }
        else {
          ppuVar7 = __ctype_b_loc();
          if (((*ppuVar7)[(byte)*cp] & 0x800) != 0) {
            pcVar5 = (char *)gettext("URL has a bad port field.");
            HTAlert(pcVar5);
            if (temp != (char *)0x0) {
              free(temp);
            }
            return 3;
          }
        }
      }
    }
    cp = (char *)0x0;
    if (temp != (char *)0x0) {
      free(temp);
      temp = (char *)0x0;
    }
    url_type = is_url(doc->address);
    if (url_type == NOT_A_URL_TYPE) {
      if ((WWW_TraceFlag != '\0') && (LYTraceLogFP == (FILE *)0x0)) {
        sleep(MessageSecs);
      }
      pcVar5 = doc->address;
      pcVar9 = (char *)gettext("Badly formed address %s");
      HTUserMsg2(pcVar9,pcVar5);
      if (WWW_TraceFlag != '\0') {
        pFVar3 = TraceFP();
        fprintf((FILE *)pFVar3,"\n");
      }
      return 3;
    }
    if ((((((LYValidate != '\0') && (LYPermitURL == '\0')) && (url_type != HTTP_URL_TYPE)) &&
         ((url_type != HTTPS_URL_TYPE && (url_type != LYNXHIST_URL_TYPE)))) &&
        ((url_type != LYNXKEYMAP_URL_TYPE &&
         ((url_type != LYNXIMGMAP_URL_TYPE && (url_type != LYNXCOOKIE_URL_TYPE)))))) &&
       ((url_type != LYNXMESSAGES_URL_TYPE &&
        ((url_type != LYNXOPTIONS_URL_TYPE || (WWWDoc.post_data == (bstring *)0x0)))))) {
      sVar4 = strlen(helpfilepath);
      iVar6 = strncmp(WWWDoc.address,helpfilepath,sVar4);
      if (iVar6 != 0) {
        if (lynxlistfile != (char *)0x0) {
          sVar4 = strlen(lynxlistfile);
          iVar6 = strncmp(WWWDoc.address,lynxlistfile,sVar4);
          if (iVar6 == 0) goto LAB_08075b5a;
        }
        if (lynxlinksfile != (char *)0x0) {
          sVar4 = strlen(lynxlinksfile);
          iVar6 = strncmp(WWWDoc.address,lynxlinksfile,sVar4);
          if (iVar6 == 0) goto LAB_08075b5a;
        }
        if (lynxjumpfile == (char *)0x0) {
LAB_08075b3a:
          pcVar5 = (char *)gettext("Not an http URL or form ACTION!");
          HTUserMsg(pcVar5);
          return 3;
        }
        sVar4 = strlen(lynxjumpfile);
        iVar6 = strncmp(WWWDoc.address,lynxjumpfile,sVar4);
        if (iVar6 != 0) goto LAB_08075b3a;
      }
    }
LAB_08075b5a:
    if (traversal == '\0') {
      if (((check_realm != '\0') && (LYPermitURL == '\0')) && (LYJumpFileURL == '\0')) {
        sVar4 = strlen(startrealm);
        iVar6 = strncmp(startrealm,WWWDoc.address,sVar4);
        if (((((((iVar6 != 0) && (url_type != LYNXHIST_URL_TYPE)) &&
               ((url_type != LYNXKEYMAP_URL_TYPE &&
                ((url_type != LYNXIMGMAP_URL_TYPE && (url_type != LYNXCOOKIE_URL_TYPE)))))) &&
              (url_type != LYNXPRINT_URL_TYPE)) &&
             ((((url_type != LYNXOPTIONS_URL_TYPE && (url_type != LYNXCFG_URL_TYPE)) &&
               (url_type != LYNXCOMPILE_OPTS_URL_TYPE)) &&
              ((url_type != LYNXMESSAGES_URL_TYPE && (url_type != LYNXDOWNLOAD_URL_TYPE)))))) &&
            (((url_type != MAILTO_URL_TYPE &&
              ((url_type != NEWSPOST_URL_TYPE && (url_type != NEWSREPLY_URL_TYPE)))) &&
             ((url_type != SNEWSPOST_URL_TYPE && (url_type != SNEWSREPLY_URL_TYPE)))))) &&
           (((LYUserSpecifiedURL != '\0' ||
             (((url_type != LYNXEXEC_URL_TYPE && (url_type != LYNXPROG_URL_TYPE)) &&
              (url_type != LYNXCGI_URL_TYPE)))) &&
            ((WWWDoc.bookmark == (char *)0x0 || (*WWWDoc.bookmark == '\0')))))) {
          sVar4 = strlen(helpfilepath);
          iVar6 = strncmp(WWWDoc.address,helpfilepath,sVar4);
          if (iVar6 != 0) {
            if (lynxlistfile != (char *)0x0) {
              sVar4 = strlen(lynxlistfile);
              iVar6 = strncmp(WWWDoc.address,lynxlistfile,sVar4);
              if (iVar6 == 0) goto LAB_08075d68;
            }
            if (lynxjumpfile == (char *)0x0) {
LAB_08075d48:
              pcVar5 = (char *)gettext("URL is not in starting realm!");
              HTUserMsg(pcVar5);
              return 3;
            }
            sVar4 = strlen(lynxjumpfile);
            iVar6 = strncmp(WWWDoc.address,lynxjumpfile,sVar4);
            if (iVar6 != 0) goto LAB_08075d48;
          }
        }
      }
    }
    else if ((url_type != HTTP_URL_TYPE) && (url_type != LYNXIMGMAP_URL_TYPE)) {
      return 3;
    }
LAB_08075d68:
    if ((((((((WWWDoc.post_data != (bstring *)0x0) && (url_type != HTTP_URL_TYPE)) &&
            (url_type != HTTPS_URL_TYPE)) &&
           ((url_type != LYNXCGI_URL_TYPE && (url_type != LYNXIMGMAP_URL_TYPE)))) &&
          (url_type != GOPHER_URL_TYPE)) &&
         ((url_type != CSO_URL_TYPE && (url_type != PROXY_URL_TYPE)))) &&
        (url_type != LYNXOPTIONS_URL_TYPE)) &&
       ((url_type != FILE_URL_TYPE ||
        ((BVar2 = LYIsUIPage3(WWWDoc.address,UIP_LIST_PAGE,L'\x01'), BVar2 == '\0' &&
         (BVar2 = LYIsUIPage3(WWWDoc.address,UIP_ADDRLIST_PAGE,L'\x01'), BVar2 == '\0')))))) {
      if (WWW_TraceFlag != '\0') {
        pFVar3 = TraceFP();
        fprintf((FILE *)pFVar3,"getfile: dropping post_data!\n");
      }
      pcVar5 = (char *)gettext("POST not supported for this URL - ignoring POST data!");
      HTAlert(pcVar5);
      LYFreePostData(doc);
      WWWDoc.post_data = (bstring *)0x0;
      WWWDoc.post_content_type = (char *)0x0;
    }
    LYSyslog(doc->address);
    if (((url_type == UNKNOWN_URL_TYPE) || (url_type == AFS_URL_TYPE)) ||
       (url_type == PROSPERO_URL_TYPE)) {
      pcVar5 = (char *)gettext("Unsupported URL scheme!");
      HTAlert(pcVar5);
      return 3;
    }
    if (url_type == DATA_URL_TYPE) {
      pcVar5 = (char *)gettext("Unsupported data: URL!  Use SHOWINFO, for now.");
      HTAlert(pcVar5);
      return 3;
    }
    if (url_type == LYNXPRINT_URL_TYPE) {
      wVar8 = printfile(doc);
      return wVar8;
    }
    if (url_type == LYNXOPTIONS_URL_TYPE) {
      wVar8 = postoptions(doc);
      return wVar8;
    }
    if ((url_type == LYNXCFG_URL_TYPE) && (no_lynxcfg_info == '\0')) {
      iVar6 = lynx_cfg_infopage(doc);
      return iVar6;
    }
    if ((url_type == LYNXCOMPILE_OPTS_URL_TYPE) && (no_compileopts_info == '\0')) {
      iVar6 = lynx_compile_opts(doc);
      return iVar6;
    }
    if ((((url_type == NEWSPOST_URL_TYPE) || (url_type == NEWSREPLY_URL_TYPE)) ||
        (url_type == SNEWSPOST_URL_TYPE)) || (url_type == SNEWSREPLY_URL_TYPE)) {
      if (no_newspost != '\0') {
        pcVar5 = (char *)gettext("News posting is disabled!");
        HTUserMsg(pcVar5);
        return 3;
      }
      if ((news_ok == '\0') && ((url_type == NEWSPOST_URL_TYPE || (url_type == NEWSREPLY_URL_TYPE)))
         ) {
        pcVar5 = (char *)gettext("USENET news access is disabled!");
        HTUserMsg(pcVar5);
        return 3;
      }
      HTLoadAbsolute(&WWWDoc);
      return 3;
    }
    if (url_type == LYNXDOWNLOAD_URL_TYPE) {
      LYDownload(doc->address);
      return 1;
    }
    if (url_type == LYNXDIRED_URL_TYPE) {
      if (no_dired_support != '\0') {
        pcVar5 = (char *)gettext("File management support is disabled!");
        HTUserMsg(pcVar5);
        return 3;
      }
      local_dired(doc);
      WWWDoc.address = doc->address;
      WWWDoc.post_data = (bstring *)doc->post_data;
      WWWDoc.post_content_type = doc->post_content_type;
      WWWDoc.bookmark = doc->bookmark;
      WWWDoc.isHEAD = doc->isHEAD;
      WWWDoc.safe = doc->safe;
      BVar2 = HTLoadAbsolute(&WWWDoc);
      if (BVar2 != '\0') {
        return 1;
      }
      return 0;
    }
    if ((LYNoRefererHeader == '\0') && (LYNoRefererForThis == '\0')) {
      ref_url = HTLoadedDocumentURL();
      iVar6 = strncasecomp(ref_url,"LYNXIMGMAP:",0xb);
      if (iVar6 == 0) {
        ref_url = ref_url + 0xb;
      }
      if ((no_filereferer == '\x01') &&
         (((*ref_url == 'f' || (*ref_url == 'F')) &&
          (iVar6 = strncasecomp(ref_url,"file:",5), iVar6 == 0)))) {
        LYNoRefererForThis = '\x01';
      }
      if (((LYNoRefererForThis == '\0') && (cp = strchr(ref_url,0x3f), cp != (char *)0x0)) &&
         (pcVar5 = strchr(cp,0x3d), pcVar5 != (char *)0x0)) {
        if (LYRefererWithQuery == 'S') {
          HTSACopy(&LYRequestReferer,ref_url);
        }
        else if (LYRefererWithQuery == 'P') {
          if (LYRequestReferer != (char *)0x0) {
            free(LYRequestReferer);
            LYRequestReferer = (char *)0x0;
          }
          LYRequestReferer = HTParse(ref_url,"",0x39);
        }
        else {
          LYNoRefererForThis = '\x01';
        }
        cp = (char *)0x0;
      }
      else if (LYNoRefererForThis == '\0') {
        HTSACopy(&LYRequestReferer,ref_url);
      }
    }
    else {
      pcVar5 = HTLoadedDocumentURL();
      HTSACopy(&LYRequestReferer,pcVar5);
    }
    if (url_type == LYNXHIST_URL_TYPE) {
      BVar2 = historytarget(doc);
      if (((BVar2 != '\0') && (doc != (DocInfo *)0x0)) && (doc->address != (char *)0x0)) {
        WWWDoc.address = doc->address;
        WWWDoc.post_data = (bstring *)doc->post_data;
        WWWDoc.post_content_type = doc->post_content_type;
        WWWDoc.bookmark = doc->bookmark;
        WWWDoc.isHEAD = doc->isHEAD;
        WWWDoc.safe = doc->safe;
        lynx_edit_mode = '\0';
        BVar2 = HTLoadAbsolute(&WWWDoc);
        if (BVar2 != '\0') {
          return 1;
        }
        return 0;
      }
      return 0;
    }
    if ((url_type == LYNXEXEC_URL_TYPE) || (url_type == LYNXPROG_URL_TYPE)) {
      if (no_exec != '\0') {
        pcVar5 = doc->address;
        pcVar9 = HTLoadedDocumentURL();
        BVar2 = exec_ok(pcVar9,pcVar5 + 9,1);
        if (BVar2 == '\0') {
          pcVar5 = (char *)gettext("Execution is disabled.");
          HTUserMsg(pcVar5);
          return 3;
        }
      }
      if ((no_bookmark_exec != '\0') && (pcVar5 = HTLoadedDocumentBookmark(), pcVar5 != (char *)0x0)
         ) {
        pcVar5 = (char *)gettext("Execution via bookmarks is disabled.");
        HTUserMsg(pcVar5);
        return 3;
      }
      if (local_exec == '\0') {
        if (local_exec_on_local_files != '\0') {
          pcVar5 = doc->address;
          pcVar9 = HTLoadedDocumentURL();
          BVar2 = exec_ok(pcVar9,pcVar5 + 9,0);
          if (BVar2 != '\0') goto LAB_08076372;
        }
        msg = (char *)0x0;
        pcVar5 = key_for_func(0x31);
        pcVar9 = (char *)gettext(
                                "Execution is not enabled for this file.  See the Options menu (use %s)."
                                );
        HTSprintf0(&msg,pcVar9,pcVar5);
        HTAlert(msg);
        if (msg != (char *)0x0) {
          free(msg);
        }
      }
      else {
LAB_08076372:
        msg = (char *)0x0;
        last_slash = strrchr(doc->address,0x2f);
        iVar6 = (int)last_slash - (int)doc->address;
        sVar4 = strlen(doc->address);
        if (iVar6 == sVar4 - 1) {
          pcVar5 = doc->address;
          sVar4 = strlen(doc->address);
          pcVar5[sVar4 - 1] = '\0';
        }
        HTSACopy(&msg,doc->address);
        LYTildeExpand(&msg,'\x01');
        HTInfoMsg(doc->address);
        stop_curses();
        pcVar5 = strstr(msg,"//");
        if (pcVar5 == msg + 9) {
          LYSystem(msg + 0xb);
        }
        else {
          LYSystem(msg + 9);
        }
        if (msg != (char *)0x0) {
          free(msg);
          msg = (char *)0x0;
        }
        if (url_type != LYNXPROG_URL_TYPE) {
          signal(2,(__sighandler_t)0x1);
          uVar10 = gettext("Press <return> to return to Lynx.");
          printf("\n%s",uVar10);
          fflush(stdout);
          LYgetch();
        }
        if (dump_output_immediately == '\0') {
          start_curses();
          LYAddVisitedLink(doc);
        }
      }
      return 3;
    }
    if (url_type == MAILTO_URL_TYPE) {
      if (no_mail == '\0') {
        tmpanchor = HTAnchor_findAddress(&WWWDoc);
        msg = (char *)0x0;
        title = "";
        pcVar5 = HTAnchor_title(tmpanchor);
        if (pcVar5 == (char *)0x0) {
          if ((HTMainAnchor != (HTParentAnchor *)0x0) && (LYUserSpecifiedURL == '\0')) {
            title = HTAnchor_subject(HTMainAnchor);
            if ((title == (char *)0x0) || (*title == '\0')) {
              title = "";
            }
            else {
              iVar6 = strncasecomp(title,"Re:",3);
              if (iVar6 != 0) {
                HTSACopy(&msg,"Re: ");
                HTSACat(&msg,title);
                title = msg;
              }
            }
          }
        }
        else {
          title = HTAnchor_title(tmpanchor);
        }
        pcVar5 = strchr(doc->address,0x3a);
        cp = pcVar5 + 1;
        if ((HTMainAnchor == (HTParentAnchor *)0x0) || (LYUserSpecifiedURL != '\0')) {
          local_68 = (char *)0x0;
        }
        else {
          local_68 = HTMainAnchor->message_id;
        }
        if ((HTMainAnchor == (HTParentAnchor *)0x0) || (LYUserSpecifiedURL != '\0')) {
          local_64 = doc->address;
        }
        else {
          local_64 = HTMainAnchor->address;
        }
        reply_by_mail(cp,local_64,title,local_68);
        if (msg != (char *)0x0) {
          free(msg);
        }
      }
      else {
        pcVar5 = (char *)gettext("Mail access is disabled!");
        HTUserMsg(pcVar5);
      }
      return 3;
    }
    if (((((((local_host_only != '\0') && (url_type != LYNXKEYMAP_URL_TYPE)) &&
           (url_type != LYNXIMGMAP_URL_TYPE)) &&
          ((url_type != LYNXCOOKIE_URL_TYPE && (url_type != LYNXMESSAGES_URL_TYPE)))) &&
         ((url_type != LYNXCGI_URL_TYPE &&
          ((url_type != NEWS_URL_TYPE || (iVar6 = strncmp(doc->address,"news://",7), iVar6 == 0)))))
         ) && (BVar2 = LYisLocalHost(doc->address), BVar2 == '\0')) &&
       (BVar2 = LYisLocalAlias(doc->address), BVar2 == '\0')) {
      pcVar5 = (char *)gettext("Only files and servers on the local host can be accessed.");
      HTUserMsg(pcVar5);
      return 3;
    }
    if (((url_type == TELNET_URL_TYPE) || (url_type == TN3270_URL_TYPE)) ||
       (url_type == TELNET_GOPHER_URL_TYPE)) {
      if (telnet_ok == '\0') {
        pcVar5 = (char *)gettext("Telnet access is disabled!");
        HTUserMsg(pcVar5);
        return 3;
      }
      if ((no_telnet_port != '\0') &&
         (pcVar5 = strchr(doc->address + 7,0x3a), pcVar5 != (char *)0x0)) {
        pcVar5 = (char *)gettext("Telnet port specifications are disabled.");
        HTUserMsg(pcVar5);
        return 3;
      }
      if (url_type == TN3270_URL_TYPE) {
        local_60 = "tn3270_proxy";
      }
      else {
        if (url_type == TELNET_GOPHER_URL_TYPE) {
          local_5c = "gopher_proxy";
        }
        else {
          local_5c = "telnet_proxy";
        }
        local_60 = local_5c;
      }
      proxy = LYGetEnv(local_60);
      if (((proxy == (char *)0x0) || (BVar2 = override_proxy(doc->address), BVar2 != '\0')) ||
         ((iVar6 = strncasecomp(proxy,"telnet:",7), iVar6 == 0 ||
          ((iVar6 = strncasecomp(proxy,"tn3270:",7), iVar6 == 0 ||
           (iVar6 = strncasecomp(proxy,"rlogin:",7), iVar6 == 0)))))) {
        stop_curses();
        HTLoadAbsolute(&WWWDoc);
        if (dump_output_immediately == '\0') {
          start_curses();
          fflush(stdout);
          LYAddVisitedLink(doc);
        }
        return 3;
      }
LAB_08076bd0:
      if ((ftp_ok == '\0') && ((url_type == FTP_URL_TYPE || (url_type == NCFTP_URL_TYPE)))) {
        pcVar5 = (char *)gettext("Ftp access is disabled!");
        HTUserMsg(pcVar5);
        return 3;
      }
      if (url_type == HTML_GOPHER_URL_TYPE) {
        msg = (char *)0x0;
        cp = strchr(doc->address + 9,0x2f);
        if (cp != (char *)0x0) {
          cp = cp + 1;
          iVar6 = strncmp(cp,"hGET%20/",8);
          if (iVar6 == 0) {
            HTSACopy(&msg,"http://");
            if (WWW_TraceFlag != '\0') {
              pcVar5 = doc->address;
              pFVar3 = TraceFP();
              fprintf((FILE *)pFVar3,"getfile: URL \'%s\'\n",pcVar5);
            }
            *cp = '\0';
            HTSACat(&msg,doc->address + 9);
            pcVar5 = strchr(msg + 6,0x3a);
            if (pcVar5 == (char *)0x0) {
              HTSACat(&msg,"70/");
              pcVar5 = msg;
              sVar4 = strlen(msg);
              pcVar5[sVar4 - 4] = ':';
            }
            sVar4 = strlen(cp + 7);
            if (1 < sVar4) {
              HTSACat(&msg,cp + 8);
            }
            HTSACopy(&doc->address,msg);
            if (WWW_TraceFlag != '\0') {
              pcVar5 = doc->address;
              pFVar3 = TraceFP();
              fprintf((FILE *)pFVar3,"  changed to \'%s\'\n",pcVar5);
            }
            if (msg != (char *)0x0) {
              free(msg);
              msg = (char *)0x0;
            }
            url_type = HTTP_URL_TYPE;
          }
        }
      }
      if ((((url_type == HTTP_URL_TYPE) || (url_type == HTTPS_URL_TYPE)) ||
          (url_type == FTP_URL_TYPE)) ||
         ((url_type == NCFTP_URL_TYPE || (url_type == CSO_URL_TYPE)))) {
        fix_httplike_urls(doc,url_type);
      }
      WWWDoc.address = doc->address;
      lynx_edit_mode = '\0';
      if (url_type == BIBP_URL_TYPE) {
        msg = (char *)0x0;
        if (BibP_bibhost_checked == '\0') {
          LYCheckBibHost();
        }
        if (BibP_bibhost_available == '\0') {
          if ((HTMainAnchor == (HTParentAnchor *)0x0) ||
             (pcVar5 = HTAnchor_citehost(HTMainAnchor), pcVar5 == (char *)0x0)) {
            HTSACopy(&msg,BibP_globalserver);
          }
          else {
            pcVar5 = HTAnchor_citehost(HTMainAnchor);
            HTSACopy(&msg,pcVar5);
          }
        }
        else {
          HTSACopy(&msg,BibP_bibhost);
        }
        if ((HTMainAnchor == (HTParentAnchor *)0x0) ||
           (pcVar5 = HTAnchor_citehost(HTMainAnchor), pcVar5 == (char *)0x0)) {
          HTSACat(&msg,"bibp1.0/resolve?usin=");
        }
        else {
          HTSACat(&msg,"bibp1.0/resolve?citehost=");
          pcVar5 = HTAnchor_citehost(HTMainAnchor);
          HTSACat(&msg,pcVar5);
          HTSACat(&msg,"&usin=");
        }
        HTSACat(&msg,doc->address + 5);
        HTSACopy(&doc->address,msg);
        WWWDoc.address = doc->address;
        if (msg != (char *)0x0) {
          free(msg);
          msg = (char *)0x0;
        }
      }
      if (url_type == FILE_URL_TYPE) {
        LYTildeExpand(&doc->address,'\x01');
        WWWDoc.address = doc->address;
      }
      if ((WWW_TraceFlag != '\0') && (LYTraceLogFP == (FILE *)0x0)) {
        sleep(MessageSecs);
      }
      pcVar5 = doc->address;
      pcVar9 = (char *)gettext("Getting %s");
      user_message(pcVar9,pcVar5);
      if ((WWW_TraceFlag != '\0') && (WWW_TraceFlag != '\0')) {
        pFVar3 = TraceFP();
        fprintf((FILE *)pFVar3,"\n");
      }
      BVar2 = HTLoadAbsolute(&WWWDoc);
      if (BVar2 != '\0') {
        lynx_mode = '\x01';
        pound = strchr(doc->address,0x23);
        if (WWW_Download_File != (char *)0x0) {
          tmpanchor_1 = HTAnchor_findAddress(&WWWDoc);
          msg = (char *)0x0;
          pcVar5 = HTAnchor_SugFname(tmpanchor_1);
          if (pcVar5 == (char *)0x0) {
            HTSACopy(&msg,doc->address);
          }
          else {
            pcVar5 = HTAnchor_SugFname(tmpanchor_1);
            HTSACopy(&msg,pcVar5);
          }
          HTCheckFnameForCompression(&msg,tmpanchor_1,'\0');
          iVar6 = LYdownload_options(&msg,WWW_Download_File);
          if (iVar6 < 0) {
            if (msg != (char *)0x0) {
              free(msg);
            }
            return 0;
          }
          LYAddVisitedLink(doc);
          HTSACopy(&doc->address,msg);
          if (msg != (char *)0x0) {
            free(msg);
            msg = (char *)0x0;
          }
          doc->internal_link = '\0';
          WWWDoc.address = doc->address;
          LYFreePostData(doc);
          WWWDoc.post_data = (bstring *)0x0;
          WWWDoc.post_content_type = (char *)0x0;
          doc->bookmark = (char *)0x0;
          WWWDoc.bookmark = doc->bookmark;
          doc->isHEAD = '\0';
          WWWDoc.isHEAD = doc->isHEAD;
          doc->safe = '\0';
          WWWDoc.safe = doc->safe;
          HTOutputFormat = HTAtom_for("www/present");
          BVar2 = HTLoadAbsolute(&WWWDoc);
          if (BVar2 != '\0') {
            return 1;
          }
          return 0;
        }
        if (pound == (char *)0x0) {
          pcVar5 = HTLoadedDocumentURL();
          iVar6 = strcmp(doc->address,pcVar5);
          if (iVar6 == 0) {
            b = HTLoadedDocumentPost_data();
            BVar2 = HTSABEql((bstring *)doc->post_data,(bstring *)b);
            if ((BVar2 != '\0') &&
               (cVar1 = doc->isHEAD, BVar2 = HTLoadedDocumentIsHEAD(), cVar1 == BVar2))
            goto LAB_08077653;
          }
          LYAddVisitedLink(doc);
          return 3;
        }
LAB_08077653:
        if (pound != (char *)0x0) {
          if (HTMainText == (HText *)0x0) {
            return 3;
          }
          BVar2 = HTFindPoundSelector(pound + 1);
          if (BVar2 != '\0') {
            *target = www_search_result;
            doc->link = L'\xffffffff';
          }
        }
        return 1;
      }
      if (use_this_url_instead == (char *)0x0) {
        if (HTNoDataOK == 0) {
          return 0;
        }
        return 3;
      }
      UVar11 = is_url(use_this_url_instead);
      if (UVar11 == NOT_A_URL_TYPE) {
        pcVar5 = (char *)gettext("Location URL is not absolute.");
        HTUserMsg(pcVar5);
        temp = HTParse(use_this_url_instead,WWWDoc.address,0x1f);
        if ((temp != (char *)0x0) && (*temp != '\0')) {
          HTSACopy(&use_this_url_instead,temp);
        }
        if (temp != (char *)0x0) {
          free(temp);
          temp = (char *)0x0;
        }
      }
      url_type = is_url(use_this_url_instead);
      if ((HTPermitRedir == '\0') &&
         ((((((((url_type == LYNXDOWNLOAD_URL_TYPE || (url_type == LYNXEXEC_URL_TYPE)) ||
               (url_type == LYNXPROG_URL_TYPE)) ||
              ((((url_type == LYNXDIRED_URL_TYPE || (url_type == LYNXPRINT_URL_TYPE)) ||
                ((url_type == LYNXOPTIONS_URL_TYPE ||
                 ((url_type == LYNXCFG_URL_TYPE || (url_type == LYNXCOMPILE_OPTS_URL_TYPE)))))) ||
               (url_type == LYNXHIST_URL_TYPE)))) ||
             (((((url_type == LYNXCOOKIE_URL_TYPE || (url_type == LYNXMESSAGES_URL_TYPE)) ||
                ((LYValidate != '\0' &&
                 ((url_type != HTTP_URL_TYPE && (url_type != HTTPS_URL_TYPE)))))) ||
               (((no_file_url != '\0' || (no_goto_file != '\0')) && (url_type == FILE_URL_TYPE))))
              || (((((no_goto_lynxcgi != '\0' && (url_type == LYNXCGI_URL_TYPE)) ||
                    ((no_goto_bibp != '\0' && (url_type == BIBP_URL_TYPE)))) ||
                   ((no_goto_cso != '\0' && (url_type == CSO_URL_TYPE)))) ||
                  (((no_goto_finger != '\0' && (url_type == FINGER_URL_TYPE)) ||
                   (((no_goto_ftp != '\0' &&
                     ((url_type == FTP_URL_TYPE || (url_type == NCFTP_URL_TYPE)))) ||
                    ((no_goto_gopher != '\0' && (url_type == GOPHER_URL_TYPE)))))))))))) ||
            ((((no_goto_http != '\0' && (url_type == HTTP_URL_TYPE)) ||
              ((no_goto_https != '\0' && (url_type == HTTPS_URL_TYPE)))) ||
             (((no_goto_mailto != '\0' && (url_type == MAILTO_URL_TYPE)) ||
              ((no_goto_news != '\0' && (url_type == NEWS_URL_TYPE)))))))) ||
           (((((no_goto_nntp != '\0' && (url_type == NNTP_URL_TYPE)) ||
              ((no_goto_rlogin != '\0' && (url_type == RLOGIN_URL_TYPE)))) ||
             ((no_goto_snews != '\0' && (url_type == SNEWS_URL_TYPE)))) ||
            ((no_goto_telnet != '\0' && (url_type == TELNET_URL_TYPE)))))) ||
          (((no_goto_tn3270 != '\0' && (url_type == TN3270_URL_TYPE)) ||
           ((no_goto_wais != '\0' && (url_type == WAIS_URL_TYPE)))))))) {
        pcVar5 = (char *)gettext("Illegal redirection URL received from server!");
        HTAlert(pcVar5);
        pcVar5 = use_this_url_instead;
        if (LYCursesON == '\0') {
          pcVar9 = (char *)gettext("Illegal URL: %s");
          fprintf(stderr,pcVar9,pcVar5);
        }
        else {
          pcVar9 = (char *)gettext("Illegal URL: %s");
          HTUserMsg2(pcVar9,pcVar5);
        }
        if (use_this_url_instead != (char *)0x0) {
          free(use_this_url_instead);
          use_this_url_instead = (char *)0x0;
        }
        return 3;
      }
      pound = strchr(doc->address,0x23);
      if ((pound != (char *)0x0) &&
         (pcVar5 = strchr(use_this_url_instead,0x23), pcVar5 == (char *)0x0)) {
        if (WWW_TraceFlag != '\0') {
          pFVar3 = TraceFP();
          fprintf((FILE *)pFVar3,"getfile: Adding fragment \'%s\' to redirection URL.\n",pound);
        }
        HTSACat(&use_this_url_instead,pound);
        doc->link = L'\xffffffff';
      }
      if ((WWW_TraceFlag != '\0') && (LYTraceLogFP == (FILE *)0x0)) {
        sleep(MessageSecs);
      }
      pcVar5 = use_this_url_instead;
      pcVar9 = (char *)gettext("Using %s");
      HTUserMsg2(pcVar9,pcVar5);
      if (WWW_TraceFlag != '\0') {
        pFVar3 = TraceFP();
        fprintf((FILE *)pFVar3,"\n");
      }
      HTSACopy(&doc->address,use_this_url_instead);
      if (use_this_url_instead != (char *)0x0) {
        free(use_this_url_instead);
        use_this_url_instead = (char *)0x0;
      }
      if (redirect_post_content == '\0') {
        LYFreePostData(doc);
      }
      goto Try_Redirected_URL;
    }
    if ((news_ok == '\0') && ((url_type == NEWS_URL_TYPE || (url_type == NNTP_URL_TYPE)))) {
      pcVar5 = (char *)gettext("USENET news access is disabled!");
      HTUserMsg(pcVar5);
      return 3;
    }
    if (url_type == RLOGIN_URL_TYPE) {
      if (rlogin_ok == '\0') {
        pcVar5 = (char *)gettext("Rlogin access is disabled!");
        HTUserMsg(pcVar5);
        return 3;
      }
      proxy_1 = LYGetEnv("rlogin_proxy");
      if ((((proxy_1 == (char *)0x0) || (BVar2 = override_proxy(doc->address), BVar2 != '\0')) ||
          (iVar6 = strncasecomp(proxy_1,"telnet:",7), iVar6 == 0)) ||
         ((iVar6 = strncasecomp(proxy_1,"tn3270:",7), iVar6 == 0 ||
          (iVar6 = strncasecomp(proxy_1,"rlogin:",7), iVar6 == 0)))) {
        stop_curses();
        HTLoadAbsolute(&WWWDoc);
        fflush(stdout);
        if (dump_output_immediately == '\0') {
          start_curses();
          LYAddVisitedLink(doc);
        }
        return 3;
      }
      goto LAB_08076bd0;
    }
    if ((url_type != INDEX_GOPHER_URL_TYPE) ||
       (pcVar5 = strchr(doc->address,0x3f), pcVar5 != (char *)0x0)) goto LAB_08076bd0;
    cp = strstr(doc->address,"%09");
    if (cp == (char *)0x0) {
      BVar2 = HTLoadAbsolute(&WWWDoc);
      if (BVar2 == '\0') {
        local_6c = 0;
      }
      else {
        status = do_www_search(doc);
        if (status == L'\x03') {
          LYpop(doc);
          WWWDoc.address = doc->address;
          WWWDoc.post_data = (bstring *)doc->post_data;
          WWWDoc.post_content_type = doc->post_content_type;
          WWWDoc.bookmark = doc->bookmark;
          WWWDoc.isHEAD = doc->isHEAD;
          WWWDoc.safe = doc->safe;
          BVar2 = HTLoadAbsolute(&WWWDoc);
          status = (int)BVar2;
        }
        else {
          lynx_edit_mode = '\0';
        }
        local_6c = status;
      }
      return local_6c;
    }
    *cp = '\0';
    HTSACopy(&temp,doc->address);
    cp = cp + 3;
    if ((*cp != '\0') && (iVar6 = strncmp(cp,"%09",3), iVar6 != 0)) {
      HTSACat(&temp,"?");
      HTSACat(&temp,cp);
      cp = strstr(temp,"%09");
      if (cp != (char *)0x0) {
        *cp = '\0';
      }
    }
    HTSACopy(&doc->address,temp);
    if (temp != (char *)0x0) {
      free(temp);
      temp = (char *)0x0;
    }
  } while( true );
}



// WARNING: Unknown calling convention

void srcmode_for_next_retrieval(int mode)

{
  if (mode < 0) {
    HTOutputFormat = HTAtom_for("www/present");
    psrc_view = '\0';
  }
  else if (mode == 0) {
    if (HTOutputFormat == WWW_SOURCE) {
      HTOutputFormat = HTAtom_for("www/present");
    }
    else if (LYpsrc != '\0') {
      psrc_view = '\0';
    }
  }
  else if (LYpsrc == '\0') {
    HTOutputFormat = WWW_SOURCE;
  }
  else {
    psrc_view = '\x01';
  }
  return;
}



int follow_link_number(int c,int cur,DocInfo *doc,int *num)

{
  int iVar1;
  FILE *pFVar2;
  char *pcVar3;
  wchar_t wVar4;
  int iVar5;
  ushort **ppuVar6;
  int in_GS_OFFSET;
  int local_d8;
  int local_d4;
  int local_d0;
  wchar_t local_cc;
  wchar_t local_c8;
  BOOLEAN local_c4;
  int *num_local;
  DocInfo *doc_local;
  char *text;
  int info;
  int curpage;
  int npages;
  int nlines;
  int curline;
  int new_link;
  int new_top;
  int rel;
  char *p;
  BOOLEAN want_go;
  char temp [120];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  p = temp;
  rel = 0;
  curline = *num;
  if (WWW_TraceFlag != '\0') {
    pFVar2 = TraceFP();
    fprintf((FILE *)pFVar2,"follow_link_number(%d,%d,...)\n",c,cur);
  }
  temp[0] = (char)c;
  temp[1] = '\0';
  *num = -1;
  mustshow = '\x01';
  pcVar3 = (char *)gettext("Follow link (or goto link or page) number: ");
  statusline(pcVar3);
  wVar4 = LYgetstr(temp,L'\0',0x78,NORECALL);
  if ((wVar4 < L'\0') || (temp[0] == '\0')) {
    pcVar3 = (char *)gettext("Cancelled!!!");
    HTInfoMsg(pcVar3);
    local_d8 = 0x10e;
  }
  else {
    iVar5 = atoi(p);
    *num = iVar5;
    while (ppuVar6 = __ctype_b_loc(), ((*ppuVar6)[(byte)*p] & 0x800) != 0) {
      p = p + 1;
    }
    iVar5 = (int)*p;
    if ((iVar5 == 0x2b) || (iVar5 == 0x2d)) {
      p = p + 1;
      c = (int)*p;
      rel = iVar5;
    }
    else {
      c = iVar5;
      if (iVar5 != 0) {
        p = p + 1;
        rel = (int)*p;
      }
    }
    if (WWW_TraceFlag != '\0') {
      iVar5 = *num;
      pFVar2 = TraceFP();
      fprintf((FILE *)pFVar2,"  temp=%s, *num=%d, rel=\'%c\'\n",temp,iVar5,rel);
    }
    iVar5 = LYlines;
    if (((c == 0x70) || (c == 0x50)) && (display_lines == 0)) {
      if (WWW_TraceFlag != '\0') {
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2," curline=%d, LYlines=%d, display too small!\n",curline,iVar5);
      }
      local_d8 = 5;
    }
    else if ((c == 0x70) || (c == 0x50)) {
      nlines = HText_getNumOfLines();
      if (display_lines < nlines + L'\x01') {
        local_d4 = (nlines + display_lines) / display_lines;
      }
      else {
        local_d4 = 1;
      }
      npages = local_d4;
      if (display_lines < curline + 1) {
        local_d0 = (curline + display_lines) / display_lines;
      }
      else {
        local_d0 = 1;
      }
      curpage = local_d0;
      if (WWW_TraceFlag != '\0') {
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2," nlines=%d, npages=%d, curline=%d, curpage=%d\n",nlines,npages,
                curline,curpage);
      }
      if (*num < 1) {
        *num = (uint)(rel == 0);
      }
      if (rel == 0x2b) {
        *num = *num + curpage;
      }
      else if (rel == 0x2d) {
        *num = curpage - *num;
      }
      if (npages < 2) {
        local_cc = L'\x01';
      }
      else {
        iVar5 = npages;
        if (*num <= npages) {
          iVar5 = *num;
        }
        local_c8 = display_lines * (iVar5 + -1) + L'\x01';
        local_cc = local_c8;
      }
      doc->line = local_cc;
      local_d8 = 3;
    }
    else {
      if ((c == 0x67) || (c == 0x47)) {
        local_c4 = '\x01';
      }
      else {
        local_c4 = '\0';
      }
      want_go = local_c4;
      if (rel != 0) {
        wVar4 = HTGetRelLinkNum(*num,rel,cur);
        *num = wVar4;
      }
      if (*num < 1) {
        local_d8 = 5;
      }
      else {
        text = (char *)0x0;
        info = HTGetLinkInfo(*num,(int)want_go,&new_top,&new_link,&text,&links[cur].lname);
        if (text != (char *)0x0) {
          LYSetHilite(cur,text);
        }
        if (info == 6) {
          links[cur].type = 6;
          local_d8 = 1;
        }
        else if (info == 8) {
          doc->line = new_top + L'\x01';
          doc->link = new_link;
          local_d8 = 2;
        }
        else if (info == 0) {
          local_d8 = 5;
        }
        else {
          links[cur].type = 2;
          local_d8 = 1;
        }
      }
    }
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return local_d8;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void add_trusted(char *str,int type)

{
  char *pcVar1;
  trust *dest;
  int Type;
  char *src;
  char *path;
  trust *tp;
  
  if (str != (char *)0x0) {
    if (add_trusted::first != '\0') {
      add_trusted::first = '\0';
    }
    pcVar1 = strchr(str,9);
    if (pcVar1 == (char *)0x0) {
      path = "";
    }
    else {
      *pcVar1 = '\0';
      path = pcVar1 + 1;
    }
    dest = (trust *)malloc(0x10);
    if (dest == (trust *)0x0) {
      outofmem("./LYGetFile.c","add_trusted");
    }
    dest->src = (char *)0x0;
    dest->path = (char *)0x0;
    dest->type = type;
    HTSACopy((char **)dest,str);
    HTSACopy(&dest->path,path);
    if (type == 0) {
      if (trusted_exec == &trusted_exec_default) {
        dest->next = (trust *)0x0;
        trusted_exec = dest;
      }
      else {
        dest->next = trusted_exec;
        trusted_exec = dest;
      }
    }
    else if (type == 1) {
      if (always_trusted_exec == &always_trusted_exec_default) {
        dest->next = (trust *)0x0;
        always_trusted_exec = dest;
      }
      else {
        dest->next = always_trusted_exec;
        always_trusted_exec = dest;
      }
    }
    else if (type == 2) {
      if (trusted_cgi == &trusted_cgi_default) {
        dest->next = (trust *)0x0;
        trusted_cgi = dest;
      }
      else {
        dest->next = trusted_cgi;
        trusted_cgi = dest;
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

BOOLEAN exec_ok(char *source,char *linktext,int type)

{
  char cVar1;
  char *pcVar2;
  ushort **ppuVar3;
  FILE *pFVar4;
  size_t sVar5;
  int iVar6;
  BOOLEAN local_29;
  char *command;
  char *buf;
  int Type;
  char *allowed_extra_chars;
  char *cp;
  trust *tp;
  
  Type = type;
  if (LYJumpFileURL == '\0') {
    if (type == 0) {
      tp = trusted_exec;
    }
    else if (type == 1) {
      tp = always_trusted_exec;
    }
    else {
      if (type != 2) {
        pcVar2 = (char *)gettext("Executable link rejected due to malformed request.");
        HTAlert(pcVar2);
        return '\0';
      }
      tp = trusted_cgi;
    }
    pcVar2 = strstr(linktext,"../");
    if (pcVar2 == (char *)0x0) {
      if (Type == 2) {
        allowed_extra_chars = " _-:./@~$&+=\t";
      }
      else {
        allowed_extra_chars = " _-:./@~$+=\t";
      }
      for (cp = linktext; *cp != '\0'; cp = cp + 1) {
        ppuVar3 = __ctype_b_loc();
        if ((((*ppuVar3)[(byte)*cp] & 8) == 0) &&
           (pcVar2 = strchr(allowed_extra_chars,(int)*cp), pcVar2 == (char *)0x0)) {
          buf = (char *)0x0;
          cVar1 = *cp;
          pcVar2 = (char *)gettext("Executable link rejected due to `%c\' character.");
          HTSprintf0(&buf,pcVar2,(int)cVar1);
          HTAlert(buf);
          if (buf != (char *)0x0) {
            free(buf);
          }
          return '\0';
        }
      }
      while( true ) {
        for (; tp != (trust *)0x0; tp = tp->next) {
          if (tp->type == Type) {
            command = linktext;
            pcVar2 = strstr(linktext,"//");
            if (pcVar2 == linktext) {
              command = linktext + 2;
            }
            if (WWW_TraceFlag != '\0') {
              pcVar2 = tp->src;
              pFVar4 = TraceFP();
              fprintf((FILE *)pFVar4,"comparing source\n\t\'%s\'\n\t\'%s\'\n",source,pcVar2);
            }
            if (WWW_TraceFlag != '\0') {
              pcVar2 = tp->path;
              pFVar4 = TraceFP();
              fprintf((FILE *)pFVar4,"comparing command\n\t\'%s\'\n\t\'%s\'\n",command,pcVar2);
            }
            sVar5 = strlen(tp->src);
            iVar6 = strncmp(source,tp->src,sVar5);
            if (iVar6 == 0) {
              sVar5 = strlen(tp->path);
              iVar6 = strncmp(command,tp->path,sVar5);
              if (iVar6 == 0) {
                return '\x01';
              }
            }
          }
        }
        if ((Type != 0) || (always_trusted_exec == &always_trusted_exec_default)) break;
        Type = 1;
        tp = always_trusted_exec;
      }
      if ((no_exec == '\0') || (type != 1)) {
        pcVar2 = (char *)gettext("Executable link rejected due to location or path.");
        HTAlert(pcVar2);
      }
      local_29 = '\0';
    }
    else {
      pcVar2 = (char *)gettext("Executable link rejected due to relative path string (\'../\').");
      HTAlert(pcVar2);
      local_29 = '\0';
    }
  }
  else {
    local_29 = '\x01';
  }
  return local_29;
}



// WARNING: Unknown calling convention

int fix_httplike_urls(DocInfo *doc,UrlTypes type)

{
  char *pcVar1;
  BOOLEAN BVar2;
  char *pcVar3;
  size_t sVar4;
  FILE *pFVar5;
  char *pcVar6;
  char *second;
  char *first;
  char *path_1;
  char *path;
  char *proxy;
  char *slash;
  
  pcVar3 = strchr(doc->address,0x23);
  if (pcVar3 != (char *)0x0) {
    return 0;
  }
  if ((type == FTP_URL_TYPE) &&
     (pcVar3 = doc->address, sVar4 = strlen(doc->address), pcVar3[sVar4 - 1] == '/')) {
    path = HTParse(doc->address,"",5);
    if (path != (char *)0x0) {
      if ((*path == '/') && (path[1] == '\0')) {
        if (path != (char *)0x0) {
          free(path);
        }
        return 0;
      }
      if (path != (char *)0x0) {
        free(path);
        path = (char *)0x0;
      }
    }
    proxy = LYGetEnv("ftp_proxy");
    if ((proxy != (char *)0x0) && (BVar2 = override_proxy(doc->address), BVar2 == '\0')) {
      return 0;
    }
    if (WWW_TraceFlag != '\0') {
      pcVar3 = doc->address;
      pFVar5 = TraceFP();
      fprintf((FILE *)pFVar5,"fix_httplike_urls: URL \'%s\'\n",pcVar3);
    }
    LYTrimHtmlSep(doc->address);
    if (WWW_TraceFlag != '\0') {
      pcVar3 = doc->address;
      pFVar5 = TraceFP();
      fprintf((FILE *)pFVar5,"            changed to \'%s\'\n",pcVar3);
    }
    if ((WWW_TraceFlag != '\0') && (LYTraceLogFP == (FILE *)0x0)) {
      sleep(MessageSecs);
    }
  }
  else if (type == NCFTP_URL_TYPE) {
    path_1 = (char *)0x0;
    pcVar3 = doc->address;
    pcVar6 = strchr(pcVar3,0x3a);
    if (WWW_TraceFlag != '\0') {
      pcVar1 = doc->address;
      pFVar5 = TraceFP();
      fprintf((FILE *)pFVar5,"fix_httplike_urls: URL \'%s\'\n",pcVar1);
    }
    *pcVar6 = '\0';
    HTSprintf0(&path_1,"%s//%s%s",&DAT_0814f68a,pcVar3,pcVar6 + 1);
    if (doc->address != (char *)0x0) {
      free(doc->address);
      doc->address = (char *)0x0;
    }
    doc->address = path_1;
    if (WWW_TraceFlag != '\0') {
      pcVar3 = doc->address;
      pFVar5 = TraceFP();
      fprintf((FILE *)pFVar5,"            changed to \'%s\'\n",pcVar3);
    }
    if ((WWW_TraceFlag != '\0') && (LYTraceLogFP == (FILE *)0x0)) {
      sleep(MessageSecs);
    }
  }
  slash = strrchr(doc->address,0x2f);
  if (slash != (char *)0x0) {
    if ((slash[-1] != '/') || (slash[-2] != ':')) {
      return 0;
    }
    if ((type == HTTP_URL_TYPE) || (type == HTTPS_URL_TYPE)) {
      pcVar3 = slash + -2;
      pcVar6 = strchr(doc->address,0x3a);
      if (pcVar3 != pcVar6) {
        return 0;
      }
      pcVar3 = strchr(doc->address,0x3f);
      if (pcVar3 != (char *)0x0) {
        return 0;
      }
    }
  }
  if (WWW_TraceFlag != '\0') {
    pcVar3 = doc->address;
    pFVar5 = TraceFP();
    fprintf((FILE *)pFVar5,"fix_httplike_urls: URL \'%s\'\n",pcVar3);
  }
  LYAddHtmlSep(&doc->address);
  if (WWW_TraceFlag != '\0') {
    pcVar3 = doc->address;
    pFVar5 = TraceFP();
    fprintf((FILE *)pFVar5,"            changed to \'%s\'\n",pcVar3);
  }
  if ((WWW_TraceFlag != '\0') && (LYTraceLogFP == (FILE *)0x0)) {
    sleep(MessageSecs);
  }
  return 1;
}



// WARNING: Unknown calling convention

void LYStdinArgs_free(void)

{
  LYFreeStringList(LYStdinArgs);
  LYStdinArgs = (HTList *)0x0;
  return;
}



// WARNING: Unknown calling convention

void reset_signals(void)

{
  signal(1,(__sighandler_t)0x0);
  signal(0xf,(__sighandler_t)0x0);
  signal(2,(__sighandler_t)0x0);
  if (no_suspend != '\0') {
    signal(0x14,(__sighandler_t)0x0);
  }
  return;
}



// WARNING: Unknown calling convention

void exit_immediately(int code)

{
  reset_signals();
  LYexit(code);
  return;
}



BOOLEAN GetStdin(char **buf,BOOLEAN marker)

{
  char *pcVar1;
  int iVar2;
  FILE *pFVar3;
  BOOLEAN local_11;
  char *local_10;
  BOOLEAN marker_local;
  
  pcVar1 = LYSafeGets(buf,stdin);
  if (pcVar1 == (char *)0x0) {
LAB_080786e8:
    if (WWW_TraceFlag != '\0') {
      if (*buf == (char *)0x0) {
        local_10 = "";
      }
      else {
        local_10 = *buf;
      }
      pFVar3 = TraceFP();
      fprintf((FILE *)pFVar3,"...mark: %s\n",local_10);
    }
    local_11 = '\0';
  }
  else {
    if (marker != '\0') {
      iVar2 = strncmp(*buf,"---",3);
      if (iVar2 == 0) goto LAB_080786e8;
    }
    LYTrimTrailing(*buf);
    if (WWW_TraceFlag != '\0') {
      pcVar1 = *buf;
      pFVar3 = TraceFP();
      fprintf((FILE *)pFVar3,"...data: %s\n",pcVar1);
    }
    local_11 = '\x01';
  }
  return local_11;
}



// WARNING: Unknown calling convention

void SetLocale(void)

{
  char *cp;
  
  setlocale(6,"");
  cp = LYGetEnv("LYNX_LOCALEDIR");
  if (cp == (char *)0x0) {
    cp = "/usr/share/locale";
  }
  bindtextdomain(&DAT_0814f6e0,cp);
  textdomain(&DAT_0814f6e0);
  return;
}



// WARNING: Restarted to delay deadcode elimination for space: stack

int main(int argc,char **argv)

{
  int iVar1;
  BOOLEAN BVar2;
  char *pcVar3;
  int iVar4;
  undefined4 uVar5;
  FILE *pFVar6;
  char *pcVar7;
  HTAtom *pHVar8;
  __sighandler_t p_Var9;
  int iVar10;
  int in_GS_OFFSET;
  EVP_PKEY_CTX *ctx;
  HTList *countp;
  HTList *pHVar11;
  HTList *local_2e4;
  int local_2e0;
  BOOLEAN local_2dc;
  BOOLEAN local_2d8;
  BOOLEAN local_2d4;
  BOOLEAN local_2d0;
  BOOLEAN local_2cc;
  BOOLEAN local_2c8;
  BOOLEAN local_2c4;
  BOOLEAN local_2c0;
  char **argv_local;
  undefined local_2b4 [4];
  stat dir_info;
  char *noargv [2];
  char *argument;
  int ch;
  int ignored;
  HTList *cur;
  char *buf;
  char *cp1;
  FILE *fp;
  char *cp;
  char *temp;
  int status;
  int i;
  char local_21c [3];
  BOOLEAN LYGetStdinArgs;
  char result [256];
  char filename [256];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  temp = (char *)0x0;
  cp = (char *)0x0;
  i._3_1_ = '\0';
  ftp_lasthost = (char *)calloc(1,1);
  LYShowColor = 2;
  pgm = *argv;
  fp = (FILE *)0x0;
  fp = (FILE *)LYLastPathSep(pgm);
  if (fp != (FILE *)0x0) {
    pgm = (char *)((int)&fp->_flags + 1);
  }
  pcVar3 = LYGetEnv("LYNX_TRACE");
  if (pcVar3 != (char *)0x0) {
    WWW_TraceFlag = '\x01';
  }
  fp = (FILE *)LYGetEnv("LYNX_TRACE_FILE");
  if (fp == (FILE *)0x0) {
    fp = (FILE *)s_Lynx_trace_0814f700;
  }
  LYTraceLogPath = (char *)malloc(0x100);
  LYAddPathToHome(LYTraceLogPath,0x100,(char *)fp);
  for (status = 1; status < argc; status = status + 1) {
    parse_arg(argv + status,1,&status);
  }
  LYOpenTraceLog();
  SetLocale();
  memset(links,0,0x11000);
  LYAllocHistory(8);
  memset(MBM_A_subbookmark,0,0x1a);
  countp = (HTList *)0x1a;
  memset(MBM_A_subdescript,0,0x1a);
  HTSACopy(&list_format,"    %p %4l %-8.8o %-8.8g %7s %-12.12d %a");
  AlertSecs = 3000;
  DebugSecs = 0;
  InfoSecs = 1000;
  MessageSecs = 2000;
  ReplaySecs = 0;
  HTSACopy(&LYTransferName,"KiB");
  HTSACopy(&helpfile,"http://lynx.isc.org/release/lynx2-8-6/lynx_help/lynx_help_main.html");
  HTSACopy(&startfile,"http://lynx.isc.org/");
  LYEscapeStartfile(&startfile);
  HTSACopy(&indexfile,"http://www.ncsa.uiuc.edu/SDG/Software/Mosaic/MetaIndex.html");
  HTSACopy(&global_type_map,"/etc/mailcap");
  HTSACopy(&personal_type_map,"~/.mailcap");
  HTSACopy(&global_extension_map,"/etc/mime.types");
  HTSACopy(&personal_extension_map,"~/.mime.types");
  HTSACopy(&language,"en");
  HTSACopy(&pref_charset,"");
  HTSACopy(&system_mail,"/usr/sbin/sendmail");
  HTSACopy(&system_mail_flags,"-t -oi");
  HTSACopy(&LYUserAgent,"Lynx");
  HTSACat(&LYUserAgent,"/");
  HTSACat(&LYUserAgent,"2.8.7dev.11");
  if (HTLibraryVersion != (char *)0x0) {
    HTSACat(&LYUserAgent," libwww-FM/");
    HTSACat(&LYUserAgent,HTLibraryVersion);
  }
  HTSACopy(&LYUserAgentDefault,LYUserAgent);
  HTSACopy(&lynx_version_putenv_command,"LYNX_VERSION=");
  HTSACat(&lynx_version_putenv_command,"2.8.7dev.11");
  putenv(lynx_version_putenv_command);
  fp = (FILE *)LYGetEnv("LYNX_TEMP_SPACE");
  if (fp == (FILE *)0x0) {
    fp = (FILE *)LYGetEnv("TMPDIR");
    if (fp == (FILE *)0x0) {
      HTSACopy(&lynx_temp_space,"/tmp/");
    }
    else {
      HTSACopy(&lynx_temp_space,(char *)fp);
    }
  }
  else {
    HTSACopy(&lynx_temp_space,(char *)fp);
  }
  LYTildeExpand(&lynx_temp_space,'\x01');
  fp = (FILE *)strstr(lynx_temp_space,"$USER");
  if ((fp != (FILE *)0x0) && (buf = LYGetEnv("USER"), buf != (char *)0x0)) {
    *(undefined *)&fp->_flags = 0;
    HTSACopy(&cp,lynx_temp_space);
    *(undefined *)&fp->_flags = 0x24;
    HTSACat(&cp,buf);
    fp = (FILE *)((int)&fp->_IO_read_ptr + 1);
    HTSACat(&cp,(char *)fp);
    HTSACopy(&lynx_temp_space,cp);
    if (cp != (char *)0x0) {
      free(cp);
      cp = (char *)0x0;
    }
  }
  LYAddPathSep(&lynx_temp_space);
  HTSACopy(&lynx_temp_space,lynx_temp_space);
  iVar4 = HTStat(lynx_temp_space,(stat *)local_2b4);
  if (((iVar4 < 0) && (iVar4 = mkdir(lynx_temp_space,0x1c0), iVar4 < 0)) ||
     ((dir_info.__st_ino & 0xf000) != 0x4000)) {
    uVar5 = gettext("No such directory");
    countp = (HTList *)lynx_temp_space;
    fprintf(stderr,"%s: %s\n",lynx_temp_space,uVar5);
    exit_immediately(1);
  }
  pcVar3 = HTHostName();
  HTSACopy(&LYHostName,pcVar3);
  HTSACopy(&LYLocalDomain,"ukans.edu");
  HTSACopy(&URLDomainPrefixes,"www.");
  HTSACopy(&URLDomainSuffixes,".com,.edu,.net,.org");
  HTSACopy(&XLoadImageCommand,"xli %s &");
  HTSACopy(&SSL_cert_file,(char *)0x0);
  HTSACopy(&BibP_globalserver,"http://usin.org/");
  HTSACopy(&BibP_bibhost,"http://bibhost/");
  no_newspost = LYNewsPosting == '\0';
  for (status = 1; status < argc; status = status + 1) {
    countp = (HTList *)&status;
    parse_arg(argv + status,2,(int *)countp);
  }
  for (status = 1; status < argc; status = status + 1) {
    iVar4 = strcmp(argv[status],"-");
    if (iVar4 == 0) {
      i._3_1_ = '\x01';
      break;
    }
  }
  if (i._3_1_ == '\x01') {
    cur = (HTList *)0x0;
    if (WWW_TraceFlag != '\0') {
      pFVar6 = TraceFP();
      fprintf((FILE *)pFVar6,"processing stdin arguments\n");
    }
    while (BVar2 = GetStdin((char **)&cur,'\x01'), BVar2 != '\0') {
      dir_info.st_ino._4_4_ = cur;
      noargv[0] = (char *)0x0;
      LYTrimTrailing((char *)cur);
      countp = (HTList *)0x0;
      BVar2 = parse_arg((char **)((int)&dir_info.st_ino + 4),2,(int *)0x0);
      pHVar11 = cur;
      if ((BVar2 == '\0') && (*(char *)&cur->object != '\0')) {
        noargv[1] = (char *)0x0;
        if (LYStdinArgs == (HTList *)0x0) {
          LYStdinArgs = HTList_new();
        }
        HTSACopy(noargv + 1,(char *)cur);
        HTList_appendObject(LYStdinArgs,noargv[1]);
        pHVar11 = (HTList *)noargv[1];
        if (WWW_TraceFlag != '\0') {
          pFVar6 = TraceFP();
          fprintf((FILE *)pFVar6,"...StdinArg:%s\n",pHVar11);
          countp = pHVar11;
        }
      }
      else if (WWW_TraceFlag != '\0') {
        pFVar6 = TraceFP();
        fprintf((FILE *)pFVar6,"...complete:%s\n",pHVar11);
        countp = pHVar11;
      }
    }
    if (WWW_TraceFlag != '\0') {
      pFVar6 = TraceFP();
      fprintf((FILE *)pFVar6,"...done with stdin arguments\n",countp);
    }
    if (cur != (HTList *)0x0) {
      free(cur);
      cur = (HTList *)0x0;
    }
  }
  if (LYValidate == '\x01') {
    parse_restrictions("all");
    LYUseTraceLog = '\0';
  }
  if (lynx_cmd_script != (char *)0x0) {
    LYTildeExpand(&lynx_cmd_script,'\x01');
    LYOpenCmdScript();
  }
  if (lynx_cmd_logfile != (char *)0x0) {
    LYTildeExpand(&lynx_cmd_logfile,'\x01');
    LYOpenCmdLogfile(argc,argv);
  }
  pcVar3 = (char *)gettext("Jump to (use \'?\' for list): ");
  HTSACopy(&jumpprompt,pcVar3);
  if ((lynx_cfg_file == (char *)0x0) &&
     ((fp = (FILE *)LYGetEnv("LYNX_CFG"), fp != (FILE *)0x0 ||
      (fp = (FILE *)LYGetEnv("lynx_cfg"), fp != (FILE *)0x0)))) {
    HTSACopy(&lynx_cfg_file,(char *)fp);
  }
  if (lynx_cfg_file == (char *)0x0) {
    HTSACopy(&lynx_cfg_file,"/etc/lynx-cur/lynx.cfg");
  }
  LYTildeExpand(&lynx_cfg_file,'\0');
  BVar2 = LYCanReadFile(lynx_cfg_file);
  pcVar3 = lynx_cfg_file;
  if (BVar2 == '\0') {
    pcVar7 = (char *)gettext("\nConfiguration file \"%s\" is not available.\n\n");
    fprintf(stderr,pcVar7,pcVar3);
    exit_immediately(1);
  }
  iVar4 = LYCharSetsDeclared();
  if (iVar4 == 0) {
    pcVar3 = (char *)gettext("\nLynx character sets not declared.\n\n");
    fprintf(stderr,pcVar3);
    exit_immediately(1);
  }
  current_char_set = safeUCGetLYhndl_byMIME("iso-8859-1");
  UCLYhndl_for_unspec = LATIN1;
  HTSACopy(&UCAssume_MIMEcharset,LYCharSet_UC[LATIN1].MIMEname);
  iVar4 = LYEditmapDeclared();
  if (iVar4 == 0) {
    pcVar3 = (char *)gettext("\nLynx edit map not declared.\n\n");
    fprintf(stderr,pcVar3);
    exit_immediately(1);
  }
  lynx_setup_colors();
  pcVar3 = Current_Dir(result + 0xfc);
  iVar4 = strcmp(pcVar3,".");
  if (iVar4 == 0) {
    fp = (FILE *)LYGetEnv("PWD");
    if (fp != (FILE *)0x0) {
      HTSACopy(&original_dir,(char *)fp);
    }
  }
  else {
    HTSACopy(&original_dir,result + 0xfc);
  }
  LYstrncpy(result + 0xfc,".lynxsig",L'');
  BVar2 = LYPathOffHomeOK(result + 0xfc,0x100);
  if (BVar2 == '\0') {
    if (WWW_TraceFlag != '\0') {
      pFVar6 = TraceFP();
      fprintf((FILE *)pFVar6,"LYNX_SIG_FILE \'%s\' is bad. Ignoring.\n",".lynxsig");
    }
  }
  else {
    HTSACopy(&LynxSigFile,result + 0xfc);
    LYAddPathToHome(result + 0xfc,0x100,LynxSigFile);
    HTSACopy(&LynxSigFile,result + 0xfc);
    pcVar3 = LynxSigFile;
    if (WWW_TraceFlag != '\0') {
      pFVar6 = TraceFP();
      fprintf((FILE *)pFVar6,"LYNX_SIG_FILE set to \'%s\'\n",pcVar3);
    }
  }
  HTSwitchDTD(1);
  read_cfg(lynx_cfg_file,"main program",1,(FILE *)0x0);
  if (lynx_lss_file2 != (char *)0x0) {
    if (lynx_lss_file != (char *)0x0) {
      free(lynx_lss_file);
    }
    lynx_lss_file = lynx_lss_file2;
    lynx_lss_file2 = (char *)0x0;
  }
  if ((lynx_lss_file == (char *)0x0) &&
     ((fp = (FILE *)LYGetEnv("LYNX_LSS"), fp != (FILE *)0x0 ||
      (fp = (FILE *)LYGetEnv("lynx_lss"), fp != (FILE *)0x0)))) {
    HTSACopy(&lynx_lss_file,(char *)fp);
  }
  if (lynx_lss_file == (char *)0x0) {
    HTSACopy(&lynx_lss_file,"/etc/lynx-cur/lynx.lss");
  }
  LYTildeExpand(&lynx_lss_file,'\x01');
  if (((lynx_lss_file == (char *)0x0) || (*lynx_lss_file == '\0')) ||
     (BVar2 = LYCanReadFile(lynx_lss_file), pcVar3 = lynx_lss_file, BVar2 != '\0')) {
    style_readFromFile(lynx_lss_file);
  }
  else {
    pcVar7 = (char *)gettext("\nLynx file \"%s\" is not available.\n\n");
    fprintf(stderr,pcVar7,pcVar3);
    exit_immediately(1);
  }
  read_rc((FILE *)0x0);
  LYFindLocaleCharset();
  fp = (FILE *)LYGetEnv("WWW_HOME");
  if (fp != (FILE *)0x0) {
    HTSACopy(&startfile,(char *)fp);
    LYEscapeStartfile(&startfile);
  }
  HTSACopy(&LynxHome,startfile);
  LYEnsureAbsoluteURL(&LynxHome,"LynxHome",L'\0');
  for (status = 1; status < argc; status = status + 1) {
    parse_arg(argv + status,4,&status);
  }
  if (LYStdinArgs != (HTList *)0x0) {
    ignored = (int)LYStdinArgs;
    noargv[0] = (char *)0x0;
    while( true ) {
      if ((ignored == 0) || (ignored = *(int *)(ignored + 4), (HTList **)ignored == (HTList **)0x0))
      {
        local_2e4 = (HTList *)0x0;
      }
      else {
        local_2e4 = *(HTList **)ignored;
      }
      dir_info.st_ino._4_4_ = local_2e4;
      if (local_2e4 == (HTList *)0x0) break;
      parse_arg((char **)((int)&dir_info.st_ino + 4),4,(int *)0x0);
    }
    LYStdinArgs_free();
  }
  if ((i._3_1_ != '\0') || (startfile_stdin != '\0')) goto LAB_080797a2;
  iVar4 = fileno(stdin);
  iVar4 = isatty(iVar4);
  if (iVar4 != 0) goto LAB_080797a2;
  iVar4 = fileno(stdout);
  if (iVar4 == 0) {
    iVar4 = fileno(stderr);
    iVar4 = isatty(iVar4);
    if (iVar4 != 0) goto LAB_080796f6;
    local_2e0 = 0;
  }
  else {
LAB_080796f6:
    local_2e0 = 1;
  }
  iVar4 = isatty(local_2e0);
  if (iVar4 != 0) {
    ch = 0;
    while (iVar4 = fgetc(stdin), iVar4 != -1) {
      ch = ch + 1;
    }
    if (ch != 0) {
      pcVar3 = (char *)gettext("Ignored %d characters from standard input.\n");
      fprintf(stderr,pcVar3,ch);
      pcVar3 = (char *)gettext("Use \"-stdin\" or \"-\" to tell how to handle piped input.\n");
      fprintf(stderr,pcVar3);
    }
  }
LAB_080797a2:
  if (startfile_stdin != '\0') {
    noargv[1] = (char *)0x0;
    if (WWW_TraceFlag != '\0') {
      pFVar6 = TraceFP();
      fprintf((FILE *)pFVar6,"processing stdin startfile\n");
    }
    cp1 = (char *)LYOpenTemp(local_21c,".html","w");
    if ((FILE *)cp1 != (FILE *)0x0) {
      HTSACopy(&startfile,local_21c);
      while (BVar2 = GetStdin(noargv + 1,'\0'), BVar2 != '\0') {
        fputs(noargv[1],(FILE *)cp1);
        fputc(10,(FILE *)cp1);
      }
      if (noargv[1] != (char *)0x0) {
        free(noargv[1]);
        noargv[1] = (char *)0x0;
      }
      LYCloseTempFP((FILE *)cp1);
    }
    if (WWW_TraceFlag != '\0') {
      pFVar6 = TraceFP();
      fprintf((FILE *)pFVar6,"...done stdin startfile\n");
    }
  }
  if (Old_DTD != 0) {
    HTSwitchDTD((uint)(Old_DTD == 0));
  }
  HTMLUseCharacterSet(current_char_set);
  if (persistent_cookies != '\0') {
    if (LYCookieFile == (char *)0x0) {
      LYCookieFile = (char *)malloc(0x100);
      LYAddPathToHome(LYCookieFile,0x100,".lynx_cookies");
    }
    else {
      LYTildeExpand(&LYCookieFile,'\0');
    }
    LYLoadCookies(LYCookieFile);
  }
  if (LYCookieSaveFile != (char *)0x0) {
    LYTildeExpand(&LYCookieSaveFile,'\0');
  }
  if (LYCookieSaveFile == (char *)0x0) {
    if (dump_output_immediately == '\0') {
      HTSACopy(&LYCookieSaveFile,LYCookieFile);
    }
    else {
      HTSACopy(&LYCookieSaveFile,"/dev/null");
    }
  }
  fp = (FILE *)LYGetEnv("LYNX_HELPFILE");
  if (fp != (FILE *)0x0) {
    HTSACopy(&helpfile,(char *)fp);
  }
  HTSACopy(&helpfilepath,helpfile);
  fp = (FILE *)LYPathLeaf(helpfilepath);
  if (fp != (FILE *)helpfilepath) {
    *(char *)&fp->_flags = '\0';
  }
  LYAddHtmlSep(&helpfilepath);
  fp = (FILE *)LYGetEnv("LYNX_SAVE_SPACE");
  if (fp != (FILE *)0x0) {
    HTSACopy(&lynx_save_space,(char *)fp);
  }
  if (((lynx_save_space != (char *)0x0) && (*lynx_save_space == '\0')) &&
     (lynx_save_space != (char *)0x0)) {
    free(lynx_save_space);
    lynx_save_space = (char *)0x0;
  }
  if (lynx_save_space != (char *)0x0) {
    LYTildeExpand(&lynx_save_space,'\x01');
    LYAddPathSep(&lynx_save_space);
  }
  HTFormatInit();
  if (FileInitAlreadyDone == '\0') {
    HTFileInit();
  }
  BVar2 = LYCheckUserAgent();
  if (BVar2 == '\0') {
    pcVar3 = (char *)gettext("User-Agent string does not contain \"Lynx\" or \"L_y_n_x\"");
    pcVar7 = (char *)gettext("Warning:");
    HTAlwaysAlert(pcVar7,pcVar3);
  }
  if (LYPreparsedSource != '\0') {
    HTPreparsedFormatInit();
  }
  if (emacs_keys != '\0') {
    set_emacs_keys();
  }
  if (vi_keys != '\0') {
    set_vi_keys();
  }
  if (no_numbers != '\0') {
    number_links = '\0';
    number_fields = '\0';
    keypad_mode = 0;
    set_numbers_as_arrows();
  }
  if ((crawl != '\0') && (number_links == '\0')) {
    keypad_mode = 0;
  }
  if ((keypad_mode != 1) && (keypad_mode != 2)) {
    if (number_fields != '\0') {
      keypad_mode = 2;
    }
    if (number_links != '\0') {
      keypad_mode = 1;
    }
    set_numbers_as_arrows();
  }
  if (LYUseDefSelPop == '\0') {
    LYSelectPopups = LYSelectPopups == '\0';
  }
  if (LYUseDefShoCur == '\0') {
    LYShowCursor = LYShowCursor == '\0';
  }
  if ((LYPrependBase != '\0') && (pHVar8 = HTAtom_for("www/download"), pHVar8 == HTOutputFormat)) {
    LYPrependBaseToSource = '\x01';
  }
  if (no_multibook != '\0') {
    LYMBMBlocked = '\x01';
  }
  if (((dump_output_immediately != '\0') || (LYMBMBlocked != '\0')) || (no_multibook != '\0')) {
    LYMultiBookmarks = 0;
    LYMBMBlocked = '\x01';
    no_multibook = '\x01';
  }
  if (dump_output_immediately == '\0') {
    signal(1,cleanup_sig);
  }
  else {
    LYCacheSource = L'\0';
    display_partial_flag = '\0';
  }
  signal(0xf,cleanup_sig);
  LYExtSignal(L'\x1c',size_change);
  if (((WWW_TraceFlag == '\0') && (dump_output_immediately == '\0')) && (stack_dump == '\0')) {
    signal(2,cleanup_sig);
    signal(0xb,FatalProblem);
    signal(4,FatalProblem);
    p_Var9 = signal(0xd,(__sighandler_t)0x1);
    if (p_Var9 != (__sighandler_t)0x1) {
      restore_sigpipe_for_children = '\x01';
    }
  }
  if (no_suspend != '\0') {
    signal(0x14,(__sighandler_t)0x1);
  }
  if ((HEAD_request != '\0') && (BVar2 = LYCanDoHEAD(startfile), BVar2 != '\x01')) {
    fprintf(stderr,
            "The \'-head\' switch is for http HEAD requests and cannot be used for\n\'%s\'.\n",
            startfile);
    exit_immediately(1);
  }
  if ((keep_mime_headers != '\0') && (BVar2 = LYCanDoHEAD(startfile), BVar2 != '\x01')) {
    fprintf(stderr,"The \'-mime_header\' switch is for http URLs and cannot be used for\n\'%s\'.\n",
            startfile);
    exit_immediately(1);
  }
  if ((traversal != '\0') && (iVar4 = strncmp(startfile,"http",4), iVar4 != 0)) {
    fprintf(stderr,"The \'-traversal\' switch is for http URLs and cannot be used for\n\'%s\'.\n",
            startfile);
    exit_immediately(1);
  }
  if (dump_output_immediately == '\0') {
    HTMLSRC_init_caches('\0');
  }
  if (dump_output_immediately == '\0') {
    setup(terminal);
  }
  LYEnsureAbsoluteURL(&startfile,"STARTFILE",L'\0');
  if (homepage != (char *)0x0) {
    LYEnsureAbsoluteURL(&homepage,"HOMEPAGE",L'\0');
  }
  if ((homepage == (char *)0x0) || (*homepage == '\0')) {
    HTSACopy(&homepage,startfile);
  }
  else {
    HTSACopy(&LynxHome,homepage);
  }
  BVar2 = inlocaldomain();
  if (BVar2 == '\0') {
    if (WWW_TraceFlag != '\0') {
      pFVar6 = TraceFP();
      fprintf((FILE *)pFVar6,"LYMain: User in REMOTE domain\n");
    }
    if ((no_outside_telnet == '\0') && (telnet_ok != '\0')) {
      local_2cc = '\x01';
    }
    else {
      local_2cc = '\0';
    }
    telnet_ok = local_2cc;
    if ((no_outside_news == '\0') && (news_ok != '\0')) {
      local_2c8 = '\x01';
    }
    else {
      local_2c8 = '\0';
    }
    news_ok = local_2c8;
    if ((no_outside_ftp == '\0') && (ftp_ok != '\0')) {
      local_2c4 = '\x01';
    }
    else {
      local_2c4 = '\0';
    }
    ftp_ok = local_2c4;
    if ((no_outside_rlogin == '\0') && (rlogin_ok != '\0')) {
      local_2c0 = '\x01';
    }
    else {
      local_2c0 = '\0';
    }
    rlogin_ok = local_2c0;
  }
  else {
    if (WWW_TraceFlag != '\0') {
      pFVar6 = TraceFP();
      fprintf((FILE *)pFVar6,"LYMain: User in Local domain\n");
    }
    if ((no_inside_telnet == '\0') && (telnet_ok != '\0')) {
      local_2dc = '\x01';
    }
    else {
      local_2dc = '\0';
    }
    telnet_ok = local_2dc;
    if ((no_inside_news == '\0') && (news_ok != '\0')) {
      local_2d8 = '\x01';
    }
    else {
      local_2d8 = '\0';
    }
    news_ok = local_2d8;
    if ((no_inside_ftp == '\0') && (ftp_ok != '\0')) {
      local_2d4 = '\x01';
    }
    else {
      local_2d4 = '\0';
    }
    ftp_ok = local_2d4;
    if ((no_inside_rlogin == '\0') && (rlogin_ok != '\0')) {
      local_2d0 = '\x01';
    }
    else {
      local_2d0 = '\0';
    }
    rlogin_ok = local_2d0;
  }
  LYSetConfigValue("broken_ftp_retr","ProFTPD 1.2.5");
  LYSetConfigValue("broken_ftp_retr","spftp/");
  LYSetConfigValue("broken_ftp_epsv","(Version wu-2.6.2-12)");
  if ((bookmark_page == (char *)0x0) || (*bookmark_page == '\0')) {
    cp = (char *)0x0;
    HTSprintf0(&cp,"lynx_bookmarks%s",".html");
    set_default_bookmark_page(cp);
    if (cp != (char *)0x0) {
      free(cp);
      cp = (char *)0x0;
    }
  }
  if ((BookmarkPage == (char *)0x0) || (*BookmarkPage == '\0')) {
    set_default_bookmark_page(bookmark_page);
  }
  LYOpenlog(syslog_txt);
  if ((x_display != (char *)0x0) && (*x_display != '\0')) {
    LYisConfiguredForX = '\x01';
  }
  if (dump_output_immediately == '\0') {
    cache_tag_styles();
    if (with_backspaces != '\0') {
      with_backspaces = '\0';
    }
    ena_csi(0x9b < LYlowest_eightbit[current_char_set]);
    temp = (char *)mainloop();
    LYCloseCloset(RECALL_URL);
    ctx = (EVP_PKEY_CTX *)0x3;
    LYCloseCloset(RECALL_MAIL);
    cleanup(ctx);
    exit_immediately((int)temp);
  }
  else {
    if (((crawl == '\0') || (number_links != '\0')) || (number_fields != '\0')) {
      if (no_numbers == '\0') {
        if (((no_list == '\0') && (keypad_mode != 1)) && (keypad_mode != 2)) {
          if (number_fields == '\0') {
            keypad_mode = 1;
          }
          else {
            keypad_mode = 2;
          }
        }
      }
      else {
        keypad_mode = 0;
      }
    }
    else {
      keypad_mode = 0;
    }
    if (0 < dump_output_width) {
      LYcols = dump_output_width;
    }
    HTAddGotoURL(startfile);
    status = HTList_count(Goto_URLs);
    while (status = status + -1, -1 < status) {
      pcVar3 = (char *)HTList_objectAt(Goto_URLs,status);
      HTSACopy(&startfile,pcVar3);
      pcVar3 = startfile;
      if (WWW_TraceFlag != '\0') {
        iVar10 = HTList_count(Goto_URLs);
        iVar4 = status + 1;
        pFVar6 = TraceFP();
        fprintf((FILE *)pFVar6,"dumping %d:%d %s\n",iVar4,iVar10,pcVar3);
      }
      temp = (char *)mainloop();
      if ((no_list == '\0') && (crawl == '\0')) {
        printlist((FILE *)stdout,'\0');
      }
      if (status != 0) {
        putchar(10);
      }
    }
    if (persistent_cookies != '\0') {
      LYStoreCookies(LYCookieSaveFile);
    }
    exit_immediately((int)temp);
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return (int)temp;
}



// WARNING: Unknown calling convention

void LYRegisterLynxProtocols(void)

{
  HTRegisterProtocol(&LYLynxKeymap);
  HTRegisterProtocol(&LYLynxCGI);
  HTRegisterProtocol(&LYLynxIMGmap);
  HTRegisterProtocol(&LYLynxCookies);
  HTRegisterProtocol(&LYLynxStatusMessages);
  return;
}



// WARNING: Unknown calling convention

void reload_read_cfg(void)

{
  char *pcVar1;
  int iVar2;
  FILE *pFVar3;
  char *LYCookieSaveFile_flag;
  char *LYCookieFile_flag;
  FILE *rcfp;
  char *tempfile;
  BOOLEAN persistent_cookies_flag;
  
  if (no_option_save == '\0') {
    tempfile = (char *)calloc(0x100,1);
    if (tempfile == (char *)0x0) {
      pcVar1 = (char *)gettext("Not enough memory!");
      HTAlwaysAlert((char *)0x0,pcVar1);
    }
    else {
      rcfp = LYOpenTemp(tempfile,".rc","w");
      if (rcfp == (FILE *)0x0) {
        if (tempfile != (char *)0x0) {
          free(tempfile);
          tempfile = (char *)0x0;
        }
        pcVar1 = (char *)gettext("Can\'t open temporary file!");
        HTAlwaysAlert((char *)0x0,pcVar1);
      }
      else {
        iVar2 = save_rc(rcfp);
        if (iVar2 == 0) {
          pcVar1 = (char *)gettext("Unable to save Options!");
          HTAlwaysAlert((char *)0x0,pcVar1);
          LYRemoveTemp(tempfile);
          if (tempfile != (char *)0x0) {
            free(tempfile);
          }
        }
        else {
          persistent_cookies_flag = persistent_cookies;
          LYCookieFile_flag = (char *)0x0;
          LYCookieSaveFile_flag = (char *)0x0;
          if (persistent_cookies != '\0') {
            HTSACopy(&LYCookieFile_flag,LYCookieFile);
            HTSACopy(&LYCookieSaveFile_flag,LYCookieSaveFile);
          }
          html_src_on_lynxcfg_reload();
          free_lynx_cfg();
          source_cache_file_error = '\0';
          read_cfg(lynx_cfg_file,"main program",1,(FILE *)0x0);
          rcfp = (FILE *)fopen64(tempfile,"r");
          read_rc(rcfp);
          LYRemoveTemp(tempfile);
          if (tempfile != (char *)0x0) {
            free(tempfile);
            tempfile = (char *)0x0;
          }
          LYSetDisplayLines();
          if (persistent_cookies != persistent_cookies_flag) {
            persistent_cookies = persistent_cookies_flag;
            pcVar1 = (char *)gettext(
                                    "persistent cookies state will be changed in next session only."
                                    );
            HTAlert(pcVar1);
          }
          if (persistent_cookies != '\0') {
            iVar2 = strcmp(LYCookieFile,LYCookieFile_flag);
            if (iVar2 != 0) {
              HTSACopy(&LYCookieFile,LYCookieFile_flag);
              if (WWW_TraceFlag != '\0') {
                pFVar3 = TraceFP();
                fprintf((FILE *)pFVar3,
                        "cookie file can be changed in next session only, restored.\n");
              }
            }
            iVar2 = strcmp(LYCookieSaveFile,LYCookieSaveFile_flag);
            if (iVar2 != 0) {
              HTSACopy(&LYCookieSaveFile,LYCookieSaveFile_flag);
              if (WWW_TraceFlag != '\0') {
                pFVar3 = TraceFP();
                fprintf((FILE *)pFVar3,
                        "cookie save file can be changed in next session only, restored.\n");
              }
            }
            if (LYCookieFile_flag != (char *)0x0) {
              free(LYCookieFile_flag);
              LYCookieFile_flag = (char *)0x0;
            }
            if (LYCookieSaveFile_flag != (char *)0x0) {
              free(LYCookieSaveFile_flag);
            }
          }
        }
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

void disable_pausing(void)

{
  AlertSecs = 0;
  DebugSecs = 0;
  InfoSecs = 0;
  MessageSecs = 0;
  ReplaySecs = 0;
  return;
}



// WARNING: Unknown calling convention

void force_dump_mode(void)

{
  dump_output_immediately = '\x01';
  disable_pausing();
  LYcols = 0x50;
  return;
}



// WARNING: Unknown calling convention

int parse_authentication(char *next_arg,char **result)

{
  size_t __n;
  char *pcVar1;
  char *cp;
  char *auth_info;
  
  auth_info = (char *)0x0;
  if (next_arg != (char *)0x0) {
    HTSACopy(&auth_info,next_arg);
    __n = strlen(next_arg);
    memset(next_arg,0x20,__n);
  }
  if (auth_info != (char *)0x0) {
    pcVar1 = strchr(auth_info,0x3a);
    if (pcVar1 != (char *)0x0) {
      *pcVar1 = '\0';
      HTUnEscape(pcVar1 + 1);
      HTSACopy(result + 1,pcVar1 + 1);
    }
    if (*auth_info != '\0') {
      HTUnEscape(auth_info);
      HTSACopy(result,auth_info);
    }
    if (auth_info != (char *)0x0) {
      free(auth_info);
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

int anonymous_fun(char *next_arg)

{
  if ((LYValidate == '\0') && (LYRestricted == '\0')) {
    parse_restrictions("default");
  }
  LYRestricted = '\x01';
  return 0;
}



// WARNING: Unknown calling convention

int assume_charset_fun(char *next_arg)

{
  UCLYhndl_for_unspec = safeUCGetLYhndl_byMIME(next_arg);
  HTSACopy(&UCAssume_MIMEcharset,LYCharSet_UC[UCLYhndl_for_unspec].MIMEname);
  return 0;
}



// WARNING: Unknown calling convention

int assume_local_charset_fun(char *next_arg)

{
  UCLYhndl_HTFile_for_unspec = safeUCGetLYhndl_byMIME(next_arg);
  return 0;
}



// WARNING: Unknown calling convention

int assume_unrec_charset_fun(char *next_arg)

{
  UCLYhndl_for_unrec = safeUCGetLYhndl_byMIME(next_arg);
  return 0;
}



// WARNING: Unknown calling convention

int auth_fun(char *next_arg)

{
  parse_authentication(next_arg,authentication_info);
  return 0;
}



// WARNING: Unknown calling convention

int base_fun(char *next_arg)

{
  HTAtom *pHVar1;
  
  LYPrependBase = '\x01';
  pHVar1 = HTAtom_for("www/dump");
  if (pHVar1 == HTOutputFormat) {
    HTOutputFormat = HTAtom_for("www/download");
  }
  return 0;
}



// WARNING: Unknown calling convention

int cache_fun(char *next_arg)

{
  if (next_arg != (char *)0x0) {
    HTCacheSize = atoi(next_arg);
  }
  if (HTCacheSize < 2) {
    HTCacheSize = 2;
  }
  return 0;
}



// WARNING: Unknown calling convention

int child_fun(char *next_arg)

{
  child_lynx = '\x01';
  no_disk_save = '\x01';
  no_mail = '\x01';
  return 0;
}



// WARNING: Unknown calling convention

int child_relaxed_fun(char *next_arg)

{
  child_lynx = '\x01';
  return 0;
}



// WARNING: Unknown calling convention

int crawl_fun(char *next_arg)

{
  crawl = '\x01';
  LYcols = 0x50;
  return 0;
}



// WARNING: Unknown calling convention

int display_fun(char *next_arg)

{
  if (next_arg != (char *)0x0) {
    LYsetXDisplay(next_arg);
  }
  return 0;
}



// WARNING: Unknown calling convention

int display_charset_fun(char *next_arg)

{
  int iVar1;
  char *__format;
  int i;
  
  iVar1 = UCGetLYhndl_byMIME(next_arg);
  if (iVar1 < 0) {
    __format = (char *)gettext("Lynx: ignoring unrecognized charset=%s\n");
    fprintf(stderr,__format,next_arg);
    iVar1 = current_char_set;
  }
  current_char_set = iVar1;
  return 0;
}



// WARNING: Unknown calling convention

int dump_output_fun(char *next_arg)

{
  force_dump_mode();
  return 0;
}



// WARNING: Unknown calling convention

int editor_fun(char *next_arg)

{
  if (next_arg != (char *)0x0) {
    HTSACopy(&editor,next_arg);
  }
  system_editor = '\x01';
  return 0;
}



// WARNING: Unknown calling convention

int error_file_fun(char *next_arg)

{
  if (next_arg != (char *)0x0) {
    http_error_file = next_arg;
  }
  return 0;
}



// WARNING: Unknown calling convention

int exec_fun(char *next_arg)

{
  local_exec = '\x01';
  return 0;
}



// WARNING: Unknown calling convention

int get_data_fun(char *next_arg)

{
  char *pcVar1;
  BOOLEAN BVar2;
  FILE *pFVar3;
  char *buf;
  char **get_data;
  
  buf = (char *)0x0;
  force_dump_mode();
  HTSACopy(&form_get_data,"?");
  get_data = &form_get_data;
  while( true ) {
    BVar2 = GetStdin(&buf,'\x01');
    if (BVar2 == '\0') break;
    HTSACat(get_data,buf);
  }
  if (WWW_TraceFlag != '\0') {
    pcVar1 = *get_data;
    pFVar3 = TraceFP();
    fprintf((FILE *)pFVar3,"get_data:%s\n",pcVar1);
  }
  pcVar1 = form_get_data;
  if (WWW_TraceFlag != '\0') {
    pFVar3 = TraceFP();
    fprintf((FILE *)pFVar3,"get_data:%s\n",pcVar1);
  }
  return 0;
}



// WARNING: Unknown calling convention

int help_fun(char *next_arg)

{
  print_help_and_exit(0);
  return 0;
}



// WARNING: Unknown calling convention

int hiddenlinks_fun(char *next_arg)

{
  BOOLEAN BVar1;
  
  if (next_arg == (char *)0x0) {
    LYHiddenLinks = 0;
  }
  else {
    BVar1 = LYgetEnum(hiddenlinks_fun::table,next_arg,&LYHiddenLinks);
    if (BVar1 == '\0') {
      print_help_and_exit(-1);
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

int homepage_fun(char *next_arg)

{
  if (next_arg != (char *)0x0) {
    HTSACopy(&homepage,next_arg);
    LYEscapeStartfile(&homepage);
  }
  return 0;
}



// WARNING: Unknown calling convention

int mime_header_fun(char *next_arg)

{
  HTAtom *local_8;
  
  keep_mime_headers = '\x01';
  force_dump_mode();
  if (LYPrependBase == '\0') {
    local_8 = HTAtom_for("www/dump");
  }
  else {
    local_8 = HTAtom_for("www/download");
  }
  HTOutputFormat = local_8;
  LYcols = 0x3f6;
  return 0;
}



// WARNING: Unknown calling convention

int newschunksize_fun(char *next_arg)

{
  if (next_arg != (char *)0x0) {
    HTNewsChunkSize = atoi(next_arg);
    if (HTNewsMaxChunk < HTNewsChunkSize) {
      HTNewsMaxChunk = HTNewsChunkSize;
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

int newsmaxchunk_fun(char *next_arg)

{
  if (next_arg != (char *)0x0) {
    HTNewsMaxChunk = atoi(next_arg);
    if (HTNewsMaxChunk < HTNewsChunkSize) {
      HTNewsChunkSize = HTNewsMaxChunk;
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

int nobold_fun(char *next_arg)

{
  LYnoVideo(L'\x01');
  return 0;
}



// WARNING: Unknown calling convention

int nobrowse_fun(char *next_arg)

{
  HTDirAccess = 0;
  return 0;
}



// WARNING: Unknown calling convention

int nocolor_fun(char *next_arg)

{
  LYShowColor = 0;
  return 0;
}



// WARNING: Unknown calling convention

int nopause_fun(char *next_arg)

{
  disable_pausing();
  return 0;
}



// WARNING: Unknown calling convention

int nomore_fun(char *next_arg)

{
  nomore = '\x01';
  return 0;
}



// WARNING: Unknown calling convention

int noreverse_fun(char *next_arg)

{
  LYnoVideo(L'\x02');
  return 0;
}



// WARNING: Unknown calling convention

int nounderline_fun(char *next_arg)

{
  LYnoVideo(L'\x04');
  return 0;
}



// WARNING: Unknown calling convention

int pauth_fun(char *next_arg)

{
  parse_authentication(next_arg,proxyauth_info);
  return 0;
}



// WARNING: Unknown calling convention

int post_data_fun(char *next_arg)

{
  BOOLEAN BVar1;
  char *buf;
  char **post_data;
  
  buf = (char *)0x0;
  force_dump_mode();
  post_data = &form_post_data;
  while( true ) {
    BVar1 = GetStdin(&buf,'\x01');
    if (BVar1 == '\0') break;
    HTSACat(post_data,buf);
  }
  return 0;
}



// WARNING: Unknown calling convention

char * show_restriction(char *name)

{
  wchar_t wVar1;
  char *value;
  
  wVar1 = find_restriction(name,L'\xffffffff');
  if (wVar1 == L'\0') {
    value = "off";
  }
  else if (wVar1 == L'\x01') {
    value = "on";
  }
  else {
    value = "?";
  }
  return value;
}



// WARNING: Unknown calling convention

int restrictions_fun(char *next_arg)

{
  bool bVar1;
  bool bVar2;
  char *__s1;
  int iVar3;
  char *__s;
  size_t sVar4;
  size_t sVar5;
  undefined *local_2c;
  char *value;
  char *name;
  uint column;
  uint k;
  uint j;
  BOOLEAN first;
  BOOLEAN found;
  
  column = 0;
  if ((next_arg == (char *)0x0) || (*next_arg == '\0')) {
    for (j = 0; j < 4; j = j + 1) {
      puts(restrictions_fun::Usage[j]);
    }
    for (j = 0; j < 0x26; j = j + 1) {
      iVar3 = strcmp(restrictions_fun::table[j].name,"all");
      if (iVar3 == 0) {
LAB_0807af12:
        value = (char *)0x0;
      }
      else {
        iVar3 = strcmp(restrictions_fun::table[j].name,"default");
        if (iVar3 == 0) goto LAB_0807af12;
        value = show_restriction(restrictions_fun::table[j].name);
      }
      print_help_strings(restrictions_fun::table[j].name,restrictions_fun::table[j].help,value,'\0')
      ;
    }
    bVar2 = true;
    j = 0;
    while( true ) {
      bVar1 = false;
      __s1 = index_to_restriction(j);
      if (__s1 == (char *)0x0) break;
      for (k = 0; k < 0x26; k = k + 1) {
        iVar3 = strcmp(__s1,restrictions_fun::table[k].name);
        if (iVar3 == 0) {
          bVar1 = true;
        }
      }
      if (!bVar1) {
        if (bVar2) {
          puts("Other restrictions (see the user\'s guide):");
        }
        __s = show_restriction(restrictions_fun::table[j].name);
        if (column == 0) {
          local_2c = &DAT_08150b5e;
        }
        else {
          local_2c = &DAT_08150b5b;
        }
        printf("%s%s (%s)",local_2c,__s1,__s);
        sVar4 = strlen(__s1);
        sVar5 = strlen(__s);
        column = sVar4 + sVar5 + column + 5;
        if (0x32 < column) {
          column = 0;
          putchar(10);
        }
        bVar2 = false;
      }
      j = j + 1;
    }
    if (column != 0) {
      putchar(10);
    }
    exit_immediately(0);
  }
  else if (*next_arg == '?') {
    print_restrictions_to_fd(stdout);
    exit_immediately(0);
  }
  else {
    parse_restrictions(next_arg);
  }
  return 0;
}



// WARNING: Unknown calling convention

int selective_fun(char *next_arg)

{
  HTDirAccess = 1;
  return 0;
}



// WARNING: Unknown calling convention

int source_fun(char *next_arg)

{
  HTAtom *local_8;
  
  force_dump_mode();
  if (LYPrependBase == '\0') {
    local_8 = HTAtom_for("www/dump");
  }
  else {
    local_8 = HTAtom_for("www/download");
  }
  HTOutputFormat = local_8;
  LYcols = 0x3f6;
  return 0;
}



// WARNING: Unknown calling convention

int traversal_fun(char *next_arg)

{
  traversal = '\x01';
  LYcols = 0x3f6;
  return 0;
}



// WARNING: Unknown calling convention

int version_fun(char *next_arg)

{
  char *pcVar1;
  char *fmt;
  undefined4 uVar2;
  char *result;
  
  result = (char *)0x0;
  SetLocale();
  pcVar1 = LYVersionDate();
  fmt = (char *)gettext("%s Version %s (%s)");
  HTSprintf0(&result,fmt,&DAT_0814f827,"2.8.7dev.11",pcVar1);
  HTSACat(&result,"\n");
  HTSprintf(&result,"libwww-FM %s",HTLibraryVersion);
  uVar2 = curses_version();
  HTSprintf(&result,", %s",uVar2);
  HTSprintf(&result,"(wide)");
  puts(result);
  free(result);
  pcVar1 = (char *)gettext("Built on %s %s %s\n");
  printf(pcVar1,"linux-gnu","May 21 2010","12:03:35");
  puts("");
  pcVar1 = (char *)gettext("Copyrights held by the Lynx Developers Group,");
  puts(pcVar1);
  pcVar1 = (char *)gettext("the University of Kansas, CERN, and other contributors.");
  puts(pcVar1);
  pcVar1 = (char *)gettext("Distributed under the GNU General Public License (Version 2).");
  puts(pcVar1);
  pcVar1 = (char *)gettext("See http://lynx.isc.org/ and the online help for more information.");
  puts(pcVar1);
  puts("");
  exit_immediately(0);
  return 0;
}



// WARNING: Unknown calling convention

int width_fun(char *next_arg)

{
  int local_18;
  int w;
  
  if (next_arg != (char *)0x0) {
    local_18 = atoi(next_arg);
    if (0 < local_18) {
      if (0x3f6 < local_18) {
        local_18 = 0x3f6;
      }
      dump_output_width = local_18;
    }
  }
  return 0;
}



void print_help_strings(char *name,char *help,char *value,BOOLEAN option)

{
  size_t sVar1;
  char *pcVar2;
  int __c;
  bool bVar3;
  undefined *local_20;
  BOOLEAN option_local;
  int field_width;
  int first;
  int c;
  int pad;
  
  sVar1 = strlen(name);
  first = (-sVar1 - (int)option) + 0x12;
  if (option == '\0') {
    local_20 = &DAT_0814f6b1;
  }
  else {
    local_20 = &DAT_0814f8e3;
  }
  fprintf(stdout,"  %s%s",local_20,name);
  if (*help != '=') {
    for (pad = (-sVar1 - (int)option) + 0x11; 0 < pad; pad = pad + -1) {
      fputc(0x20,stdout);
    }
    fputc(0x20,stdout);
    first = 0;
  }
  pcVar2 = strchr(help,10);
  if (pcVar2 == (char *)0x0) {
    fputs(help,stdout);
  }
  else {
    for (; __c = (int)*help, __c != 0; help = help + 1) {
      if (__c == 10) {
        first = first + -1;
        if (first < 0) {
          pad = 0x14;
          c = 10;
        }
        else {
          c = 0x20;
          pad = first;
        }
        fputc(c,stdout);
        while (bVar3 = pad != 0, pad = pad + -1, bVar3) {
          fputc(0x20,stdout);
        }
      }
      else {
        fputc(__c,stdout);
      }
      first = first + -1;
    }
  }
  if (value != (char *)0x0) {
    printf(" (%s)",value);
  }
  fputc(10,stdout);
  return;
}



// WARNING: Unknown calling convention

void print_help_and_exit(int exit_status)

{
  int iVar1;
  char *__format;
  char *pcVar2;
  long *plVar3;
  uint uVar4;
  int in_GS_OFFSET;
  char *local_420;
  char *local_41c;
  ParseUnion *q;
  char *value;
  Config_Type *p;
  char temp [1024];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if (pgm == (char *)0x0) {
    pgm = "lynx";
  }
  pcVar2 = pgm;
  __format = (char *)gettext("USAGE: %s [options] [file]\n");
  fprintf(stdout,__format,pcVar2);
  pcVar2 = (char *)gettext("Options are:\n");
  fprintf(stdout,pcVar2);
  print_help_strings("","receive options and arguments from stdin",(char *)0x0,'\x01');
  p = Arg_Table;
  do {
    if (p->name == (char *)0x0) {
      exit_immediately(exit_status);
      if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
        return;
      }
                    // WARNING: Subroutine does not return
      __stack_chk_fail();
    }
    value = temp;
    plVar3 = &p->value;
    uVar4 = p->type & 0xff0;
    if (uVar4 == 0x30) {
      if (*(char *)*plVar3 == '\0') {
        local_41c = "on";
      }
      else {
        local_41c = "off";
      }
      strcpy(temp,local_41c);
    }
    else if (uVar4 < 0x31) {
      if ((uVar4 == 0x10) || (uVar4 == 0x20)) {
        if (*(char *)*plVar3 == '\0') {
          local_420 = "off";
        }
        else {
          local_420 = "on";
        }
        strcpy(temp,local_420);
      }
      else {
LAB_0807b701:
        value = (char *)0x0;
      }
    }
    else if (uVar4 == 0x70) {
      value = *(char **)*plVar3;
      if ((value != (char *)0x0) && (*value == '\0')) {
        value = (char *)0x0;
      }
    }
    else if (uVar4 == 0x80) {
      sprintf(temp,"%.3f",(double)*(int *)*plVar3 / 1000.0);
    }
    else {
      if (uVar4 != 0x60) goto LAB_0807b701;
      sprintf(temp,"%d",*(undefined4 *)*plVar3);
    }
    print_help_strings(p->name,p->help_string,value,'\x01');
    p = p + 1;
  } while( true );
}



// WARNING: Unknown calling convention

int arg_eqs_parse(char *a,char *b,char **c)

{
  char *pcVar1;
  ushort **ppuVar2;
  int result;
  
  result = -1;
  *c = (char *)0x0;
  do {
    if (-1 < result) {
      return result;
    }
    if (((*a != *b) || (*a == '\0')) || (*b == '\0')) {
      if (*a == '\0') {
        switch(*b) {
        case '\0':
          result = 1;
          break;
        default:
          result = 0;
          break;
        case '\t':
        case ' ':
          pcVar1 = LYSkipBlanks(b);
          *c = pcVar1;
          result = 1;
          break;
        case '+':
switchD_0807b7e7_caseD_2b:
          *c = b;
          result = 1;
          break;
        case '-':
          ppuVar2 = __ctype_b_loc();
          if (((*ppuVar2)[(byte)b[1]] & 0x400) == 0) goto switchD_0807b7e7_caseD_2b;
          result = 0;
          break;
        case ':':
        case '=':
          *c = b + 1;
          result = 1;
        }
      }
      else if ((*a != '_') || (*b != '-')) {
        result = 0;
      }
    }
    a = a + 1;
    b = b + 1;
  } while( true );
}



// WARNING: Unknown calling convention

BOOLEAN parse_arg(char **argv,uint mask,int *countp)

{
  char *pcVar1;
  long *plVar2;
  char *pcVar3;
  FILE *pFVar4;
  int iVar5;
  long lVar6;
  char *__format;
  uint uVar7;
  int local_48;
  bool local_41;
  char *local_40;
  float ival;
  char *temp_ptr;
  char *next_arg;
  ParseFunc fun;
  ParseUnion *q;
  char *arg_name;
  Config_Type *p;
  
  arg_name = *argv;
  if (WWW_TraceFlag != '\0') {
    if (countp == (int *)0x0) {
      local_48 = -1;
    }
    else {
      local_48 = *countp;
    }
    pFVar4 = TraceFP();
    fprintf((FILE *)pFVar4,"parse_arg(arg_name=%s, mask=%u, count=%d)\n",arg_name,mask,local_48);
  }
  if ((((countp == (int *)0x0) == mask) &&
      (parse_arg::no_options_further = '\0', nonoption != (char *)0x0)) &&
     (nonoption != (char *)0x0)) {
    free(nonoption);
    nonoption = (char *)0x0;
  }
  if ((*arg_name == '-') && (parse_arg::no_options_further != '\x01')) {
    iVar5 = strcmp(arg_name,"--");
    if (iVar5 == 0) {
      parse_arg::no_options_further = '\x01';
      local_41 = true;
    }
    else {
      pcVar1 = arg_name + 1;
      if (*pcVar1 == '\0') {
        local_41 = true;
      }
      else {
        if (*pcVar1 == '-') {
          pcVar1 = arg_name + 2;
        }
        arg_name = pcVar1;
        if (WWW_TraceFlag != '\0') {
          pFVar4 = TraceFP();
          fprintf((FILE *)pFVar4,"parse_arg lookup(%s)\n",arg_name);
        }
        for (p = Arg_Table; p->name != (char *)0x0; p = p + 1) {
          q = (ParseUnion *)&p->value;
          next_arg = (char *)0x0;
          temp_ptr = (char *)0x0;
          if ((*p->name == *arg_name) &&
             (iVar5 = arg_eqs_parse(p->name,arg_name,&next_arg), iVar5 != 0)) {
            if ((p->type & 0x1000U) != 0) {
              if (((next_arg == (char *)0x0) && (next_arg = argv[1], countp != (int *)0x0)) &&
                 (next_arg != (char *)0x0)) {
                *countp = *countp + 1;
              }
              if (WWW_TraceFlag != '\0') {
                if (next_arg == (char *)0x0) {
                  local_40 = "(null)";
                }
                else {
                  local_40 = next_arg;
                }
                pFVar4 = TraceFP();
                fprintf((FILE *)pFVar4,"...arg:%s\n",local_40);
              }
            }
            if ((p->type & mask) == 0) {
              if (WWW_TraceFlag != '\0') {
                uVar7 = p->type;
                pFVar4 = TraceFP();
                fprintf((FILE *)pFVar4,"...skip (mask %u/%d)\n",mask,uVar7 & 7);
              }
              return '\0';
            }
            uVar7 = p->type & 0xff0;
            if (uVar7 == 0x40) {
              fun = q->fun_value;
              if (fun != (ParseFunc)0x0) {
                (*fun)(next_arg);
              }
            }
            else if (uVar7 < 0x41) {
              if ((((uVar7 == 0x20) || (uVar7 == 0x30)) || (uVar7 == 0x10)) &&
                 (q->add_value != (lynx_list_item_type **)0x0)) {
                if (next_arg == (char *)0x0) {
                  uVar7 = p->type & 0xff0;
                  if (uVar7 == 0x20) {
                    *q->set_value = '\x01';
                  }
                  else if (uVar7 == 0x30) {
                    *q->set_value = '\0';
                  }
                  else if (uVar7 == 0x10) {
                    *q->set_value = *q->set_value == '\0';
                  }
                }
                else if ((((*next_arg == '1') || (*next_arg == '+')) ||
                         (iVar5 = strcasecomp(next_arg,"on"), iVar5 == 0)) ||
                        (iVar5 = strcasecomp(next_arg,"true"), iVar5 == 0)) {
                  *q->set_value = '\x01';
                }
                else if (((*next_arg == '0') || (*next_arg == '-')) ||
                        ((iVar5 = strcasecomp(next_arg,"off"), iVar5 == 0 ||
                         (iVar5 = strcasecomp(next_arg,"false"), iVar5 == 0)))) {
                  *q->set_value = '\0';
                }
              }
            }
            else if (uVar7 == 0x60) {
              if ((q->add_value != (lynx_list_item_type **)0x0) && (next_arg != (char *)0x0)) {
                plVar2 = q->int_value;
                lVar6 = strtol(next_arg,&temp_ptr,0);
                *plVar2 = lVar6;
              }
            }
            else if (uVar7 < 0x61) {
              if (((uVar7 == 0x50) && (q->add_value != (lynx_list_item_type **)0x0)) &&
                 (next_arg != (char *)0x0)) {
                HTSACopy(q->str_value,next_arg);
              }
            }
            else if (uVar7 == 0x70) {
              if ((q->add_value != (lynx_list_item_type **)0x0) && (next_arg != (char *)0x0)) {
                *q->str_value = next_arg;
              }
            }
            else if ((((uVar7 == 0x80) && (q->add_value != (lynx_list_item_type **)0x0)) &&
                     (next_arg != (char *)0x0)) && (iVar5 = sscanf(next_arg,"%f",&ival), iVar5 == 1)
                    ) {
              *q->int_value = (int)ROUND(ival * 1000.0);
            }
            Old_DTD = (int)DTD_recovery;
            return '\x01';
          }
        }
        if (pgm == (char *)0x0) {
          pgm = "LYNX";
        }
        pcVar3 = pgm;
        pcVar1 = *argv;
        __format = (char *)gettext("%s: Invalid Option: %s\n");
        fprintf(stderr,__format,pcVar3,pcVar1);
        print_help_and_exit(-1);
        local_41 = false;
      }
    }
  }
  else {
    if (mask == 4) {
      if (nonoption != (char *)0x0) {
        LYEnsureAbsoluteURL(&nonoption,"NONOPTION",L'\0');
        HTAddGotoURL(nonoption);
        if (nonoption != (char *)0x0) {
          free(nonoption);
          nonoption = (char *)0x0;
        }
      }
      HTSACopy(&nonoption,arg_name);
    }
    HTSACopy(&startfile,arg_name);
    LYEscapeStartfile(&startfile);
    pcVar1 = startfile;
    if (WWW_TraceFlag != '\0') {
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"parse_arg startfile:%s\n",pcVar1);
    }
    local_41 = countp != (int *)0x0;
  }
  return local_41;
}



// WARNING: Unknown calling convention

void FatalProblem(int sig)

{
  undefined4 uVar1;
  
  signal(1,(__sighandler_t)0x1);
  signal(0xf,(__sighandler_t)0x1);
  signal(2,(__sighandler_t)0x1);
  signal(0xb,(__sighandler_t)0x1);
  signal(4,(__sighandler_t)0x1);
  fflush(stderr);
  fflush(stdout);
  if ((LYOutOfMemory != '\0') && (LYCursesON != '\0')) {
    LYSleepAlert();
  }
  cleanup_sig(0);
  signal(0xb,(__sighandler_t)0x0);
  signal(4,(__sighandler_t)0x0);
  if (LYOutOfMemory == '\0') {
    fprintf(stderr,"\r\nA Fatal error has occurred in %s Ver. %s\r\n",&DAT_0814f827,"2.8.7dev.11");
    fwrite("\r\nPlease notify your system administrator to confirm a bug, and\r\nif confirmed, to notify the lynx-dev list.  Bug reports should\r\nhave concise descriptions of the command and/or URL which causes\r\nthe problem, the operating system name with version number, the\r\nTCPIP implementation, and any other relevant information.\r\n"
           ,1,0x13f,stderr);
    if ((sig != 0) || (LYNoCore == '\0')) {
      fwrite("\r\nDo NOT mail the core file if one was generated.\r\n",1,0x33,stderr);
    }
    if (sig != 0) {
      fprintf(stderr,"\r\nLynx now exiting with signal:  %d\r\n\r\n",sig);
    }
    if (LYNoCore != '\0') {
      exit_immediately(1);
    }
                    // WARNING: Subroutine does not return
    abort();
  }
  LYOutOfMemory = '\0';
  uVar1 = gettext("Memory exhausted!  Program aborted!");
  printf("\r\n%s\r\n\r\n",uVar1);
  fflush(stdout);
  exit_immediately(1);
  return;
}



// WARNING: Unknown calling convention

wchar_t sametext(char *een,char *twee)

{
  int iVar1;
  wchar_t local_8;
  
  if ((een == (char *)0x0) || (twee == (char *)0x0)) {
    local_8 = L'\x01';
  }
  else {
    iVar1 = strcmp(een,twee);
    local_8 = (wchar_t)(iVar1 == 0);
  }
  return local_8;
}



// WARNING: Unknown calling convention

void TracelogOpenFailed(void)

{
  char *Msg;
  undefined4 uVar1;
  
  WWW_TraceFlag = '\0';
  if (LYCursesON == '\0') {
    uVar1 = gettext("Trace Log open failed.  Trace off!");
    fprintf(stderr,"%s\n",uVar1);
    exit_immediately(1);
  }
  else {
    Msg = (char *)gettext("Trace Log open failed.  Trace off!");
    HTUserMsg(Msg);
  }
  return;
}



// WARNING: Unknown calling convention

BOOLEAN LYReopenTracelog(BOOLEAN *trace_flag_ptr)

{
  FILE *__stream;
  BOOLEAN local_5;
  
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"\nTurning off TRACE for fetch of log.\n");
  }
  LYCloseTracelog();
  LYTraceLogFP = LYAppendToTxtFile(LYTraceLogPath);
  if (LYTraceLogFP == (FILE *)0x0) {
    TracelogOpenFailed();
    local_5 = '\0';
  }
  else {
    if (WWW_TraceFlag != '\0') {
      WWW_TraceFlag = '\0';
      *trace_flag_ptr = '\x01';
    }
    local_5 = '\x01';
  }
  return local_5;
}



// WARNING: Unknown calling convention

void turn_trace_back_on(BOOLEAN *trace_flag_ptr)

{
  FILE *__s;
  
  if (*trace_flag_ptr == '\x01') {
    WWW_TraceFlag = '\x01';
    *trace_flag_ptr = '\0';
    __s = TraceFP();
    fwrite("Turning TRACE back on.\n\n",1,0x18,(FILE *)__s);
  }
  return;
}



// WARNING: Unknown calling convention

FILE * TraceFP(void)

{
  FILE *local_8;
  
  if (LYTraceLogFP == (FILE *)0x0) {
    local_8 = stderr;
  }
  else {
    local_8 = LYTraceLogFP;
  }
  return local_8;
}



// WARNING: Unknown calling convention

BOOLEAN LYOpenTraceLog(void)

{
  undefined4 uVar1;
  FILE *pFVar2;
  char *pcVar3;
  
  if (((WWW_TraceFlag != '\0') && (LYUseTraceLog != '\0')) && (LYTraceLogFP == (FILE *)0x0)) {
    LYTraceLogFP = LYNewTxtFile(LYTraceLogPath);
    if (LYTraceLogFP == (FILE *)0x0) {
      TracelogOpenFailed();
      return '\0';
    }
    fflush(stdout);
    fflush(stderr);
    uVar1 = gettext("Lynx Trace Log");
    pFVar2 = TraceFP();
    pcVar3 = "2.8.7dev.11";
    fprintf((FILE *)pFVar2,"\t\t%s (%s)\n\n",uVar1,"2.8.7dev.11");
    if (LYValidate == '\0') {
      if (LYRestricted == '\0') {
        if ((had_restrictions_all == '\0') || (had_restrictions_default == '\0')) {
          if (had_restrictions_default == '\0') {
            if ((had_restrictions_all != '\0') && (WWW_TraceFlag != '\0')) {
              pFVar2 = TraceFP();
              fprintf((FILE *)pFVar2,"\"all\" restrictions are set.\n",uVar1,pcVar3);
            }
          }
          else if (WWW_TraceFlag != '\0') {
            pFVar2 = TraceFP();
            fprintf((FILE *)pFVar2,"Restriction \"default\" was given.\n",uVar1,pcVar3);
          }
        }
        else if (WWW_TraceFlag != '\0') {
          pFVar2 = TraceFP();
          fprintf((FILE *)pFVar2,"Restrictions \"all\" and \"default\" were given.\n",uVar1,pcVar3);
        }
      }
      else if (had_restrictions_all == '\0') {
        if (WWW_TraceFlag != '\0') {
          pFVar2 = TraceFP();
          fprintf((FILE *)pFVar2,"Anonymous restrictions are set.\n",uVar1,pcVar3);
        }
      }
      else if (WWW_TraceFlag != '\0') {
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2,"Anonymous restrictions set, restriction \"all\" was given.\n",uVar1,
                pcVar3);
      }
    }
    else if ((LYRestricted == '\0') || (had_restrictions_default == '\0')) {
      if (had_restrictions_default == '\0') {
        if (LYRestricted == '\0') {
          if (WWW_TraceFlag != '\0') {
            pFVar2 = TraceFP();
            fprintf((FILE *)pFVar2,"Validate restrictions are set.\n",uVar1,pcVar3);
          }
        }
        else if (WWW_TraceFlag != '\0') {
          pFVar2 = TraceFP();
          fprintf((FILE *)pFVar2,
                  "Validate restrictions set, additional anonymous restrictions ignored.\n",uVar1,
                  pcVar3);
        }
      }
      else if (WWW_TraceFlag != '\0') {
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2,"Validate restrictions set, restriction \"default\" was given.\n",
                uVar1,pcVar3);
      }
    }
    else if (WWW_TraceFlag != '\0') {
      pFVar2 = TraceFP();
      fprintf((FILE *)pFVar2,"Validate and some anonymous restrictions are set.\n",uVar1,pcVar3);
    }
  }
  return '\x01';
}



// WARNING: Unknown calling convention

void LYCloseTracelog(void)

{
  if (LYTraceLogFP != (FILE *)0x0) {
    fflush(stdout);
    fflush(stderr);
    fclose((FILE *)LYTraceLogFP);
    LYTraceLogFP = (FILE *)0x0;
  }
  return;
}



// WARNING: Unknown calling convention

void handle_LYK_TRACE_TOGGLE(void)

{
  BOOLEAN BVar1;
  char *local_8;
  
  WWW_TraceFlag = WWW_TraceFlag == '\0';
  BVar1 = LYOpenTraceLog();
  if (BVar1 != '\0') {
    if (WWW_TraceFlag == '\0') {
      local_8 = (char *)gettext("Trace OFF!");
    }
    else {
      local_8 = (char *)gettext("Trace ON!");
    }
    HTUserMsg(local_8);
  }
  return;
}



// WARNING: Unknown calling convention

void LYSetNewline(wchar_t value)

{
  Newline = value;
  return;
}



// WARNING: Unknown calling convention

wchar_t LYGetNewline(void)

{
  return Newline;
}



// WARNING: Unknown calling convention

void LYChgNewline(wchar_t adjust)

{
  Newline = Newline + adjust;
  return;
}



// WARNING: Unknown calling convention

BOOLEAN reparse_document(void)

{
  BOOLEAN BVar1;
  BOOLEAN result;
  
  from_source_cache = '\x01';
  BVar1 = HTreparse_document();
  from_source_cache = BVar1 != '\0';
  return BVar1;
}



// WARNING: Unknown calling convention

BOOLEAN reparse_or_reload(wchar_t *cmd)

{
  BOOLEAN BVar1;
  
  BVar1 = reparse_document();
  if (BVar1 == '\0') {
    *cmd = L'\f';
  }
  return BVar1 == '\0';
}



// WARNING: Unknown calling convention

void set_address(DocInfo *doc,char *address)

{
  HTSACopy(&doc->address,address);
  return;
}



// WARNING: Unknown calling convention

void copy_address(DocInfo *dst,DocInfo *src)

{
  HTSACopy(&dst->address,src->address);
  return;
}



// WARNING: Unknown calling convention

void free_address(DocInfo *doc)

{
  if (doc->address != (char *)0x0) {
    free(doc->address);
    doc->address = (char *)0x0;
  }
  return;
}



// WARNING: Unknown calling convention

void move_address(DocInfo *dst,DocInfo *src)

{
  copy_address(dst,src);
  free_address(src);
  return;
}



// WARNING: Unknown calling convention

BOOLEAN LYMainLoop_pageDisplay(wchar_t line_num)

{
  wchar_t wVar1;
  BOOLEAN BVar2;
  char *pcVar3;
  wchar_t prev_newline;
  char *pound;
  
  wVar1 = Newline;
  Newline = line_num;
  if (((((from_source_cache == '\0') && (display_partial != '\0')) && (newdoc.line == L'\x01')) &&
      ((line_num == L'\x01' && (wVar1 == L'\x01')))) &&
     ((pcVar3 = strchr(newdoc.address,0x23), pcVar3 != (char *)0x0 &&
      ((*pcVar3 != '\0' && (pcVar3[1] != '\0')))))) {
    BVar2 = HTFindPoundSelector(pcVar3 + 1);
    if (BVar2 == '\0') {
      Newline = wVar1;
      return '\0';
    }
    Newline = www_search_result;
  }
  HText_pageDisplay(Newline,prev_target);
  return '\x01';
}



// WARNING: Unknown calling convention

BOOLEAN set_curdoc_link(wchar_t nextlink)

{
  BOOLEAN result;
  
  result = '\0';
  if (((curdoc.link != nextlink) && (L'\xffffffff' < nextlink)) && (nextlink < nlinks)) {
    if ((L'\xffffffff' < curdoc.link) && (curdoc.link < nlinks)) {
      LYhighlight(L'\0',curdoc.link,prev_target);
      result = '\x01';
    }
    curdoc.link = nextlink;
  }
  return result;
}



// WARNING: Unknown calling convention

void goto_line(wchar_t nextline)

{
  wchar_t wVar1;
  wchar_t wVar2;
  FILE *pFVar3;
  wchar_t old_link;
  wchar_t n;
  
  wVar1 = newdoc.link;
  newdoc.link = L'\0';
  n = L'\0';
  while( true ) {
    if (nlinks <= n) {
      newdoc.link = L'\0';
      return;
    }
    if (links[n].anchor_line_num + L'\x01' == nextline) break;
    n = n + L'\x01';
  }
  if (WWW_TraceFlag != '\0') {
    wVar2 = HText_getTopOfScreen();
    pFVar3 = TraceFP();
    fprintf((FILE *)pFVar3,"top_of_screen %d\n",wVar2 + L'\x01');
  }
  if (WWW_TraceFlag != '\0') {
    pFVar3 = TraceFP();
    fprintf((FILE *)pFVar3,"goto_line(%d) -> link %d -> %d\n",nextline,wVar1,n);
  }
  newdoc.link = n;
  return;
}



// WARNING: Unknown calling convention

void set_curdoc_link_by_mouse(wchar_t nextlink)

{
  BOOLEAN BVar1;
  
  BVar1 = set_curdoc_link(nextlink);
  if (BVar1 != '\0') {
    LYhighlight(L'\x01',nextlink,prev_target);
    LYmsec_delay(0x14);
  }
  return;
}



// WARNING: Unknown calling convention

wchar_t do_change_link(void)

{
  char *fmt;
  char *msgtmp;
  wchar_t mouse_tmp;
  
  mouse_tmp = get_mouse_link();
  if (mouse_tmp != L'\xffffffff') {
    if ((mouse_tmp < L'\0') || (nlinks <= mouse_tmp)) {
      msgtmp = (char *)0x0;
      fmt = (char *)gettext("Internal error: Invalid mouse link %d!");
      HTSprintf0(&msgtmp,fmt,mouse_tmp);
      HTAlert(msgtmp);
      if (msgtmp != (char *)0x0) {
        free(msgtmp);
      }
      return L'\xffffffff';
    }
    set_curdoc_link_by_mouse(mouse_tmp);
  }
  return L'\0';
}



// WARNING: Unknown calling convention

void do_check_goto_URL(char *user_input_buffer,char **old_user_input,BOOLEAN *force_load)

{
  bool bVar1;
  BOOLEAN BVar2;
  size_t __n;
  char *Msg2;
  int iVar3;
  char *pcVar4;
  wchar_t wVar5;
  uint n;
  BOOLEAN found;
  
  bVar1 = false;
  if (*user_input_buffer == '#') {
    if ((user_input_buffer[1] != '\0') &&
       (BVar2 = HTFindPoundSelector(user_input_buffer + 1), BVar2 != '\0')) {
      HTAddGotoURL(user_input_buffer);
      trimPoundSelector(curdoc.address);
      HTSACat(&curdoc.address,user_input_buffer);
    }
  }
  else {
    HTSACopy(old_user_input,user_input_buffer);
    LYEnsureAbsoluteURL(old_user_input,"",L'\x01');
    sprintf(user_input_buffer,"%.*s",0x3ff,*old_user_input);
    if (*old_user_input != (char *)0x0) {
      free(*old_user_input);
      *old_user_input = (char *)0x0;
    }
    for (n = 0; n < 0x1d; n = n + 1) {
      if (*do_check_goto_URL::table[n].flag != '\0') {
        __n = strlen(do_check_goto_URL::table[n].name);
        iVar3 = strncmp(user_input_buffer,do_check_goto_URL::table[n].name,__n);
        if (iVar3 == 0) {
          bVar1 = true;
          pcVar4 = do_check_goto_URL::table[n].name;
          Msg2 = (char *)gettext("You are not allowed to goto \"%s\" URLs");
          HTUserMsg2(Msg2,pcVar4);
          break;
        }
      }
    }
    if (!bVar1) {
      if (((LYValidate != '\0') && (iVar3 = strncasecomp(user_input_buffer,"http:",5), iVar3 != 0))
         && (iVar3 = strncasecomp(user_input_buffer,"https:",6), iVar3 != 0)) {
        pcVar4 = (char *)gettext("Goto a non-http URL is disallowed!");
        HTUserMsg(pcVar4);
        return;
      }
      set_address(&newdoc,user_input_buffer);
      newdoc.isHEAD = '\0';
      wVar5 = are_different(&curdoc,&newdoc);
      if (wVar5 != L'\0') {
        pcVar4 = (char *)gettext("A URL specified by the user");
        HTSACopy(&newdoc.title,pcVar4);
        LYFreePostData(&newdoc);
        if (newdoc.bookmark != (char *)0x0) {
          free(newdoc.bookmark);
          newdoc.bookmark = (char *)0x0;
        }
        newdoc.safe = '\0';
        newdoc.internal_link = '\0';
        *force_load = '\x01';
        if ((lynx_edit_mode != '\0') && (1 < LYAutoUncacheDirLists)) {
          HTuncache_current_document();
        }
      }
      LYUserSpecifiedURL = '\x01';
      HTAddGotoURL(newdoc.address);
    }
  }
  return;
}



// WARNING: Unknown calling convention

BOOLEAN do_check_recall(wchar_t ch,char *user_input_buffer,char **old_user_input,wchar_t URLTotal,
                       wchar_t *URLNum,RecallType recall,BOOLEAN *FirstURLRecall)

{
  char *pcVar1;
  int iVar2;
  char *cp;
  BOOLEAN ret;
  
  if (*old_user_input == (char *)0x0) {
    HTSACopy(old_user_input,"");
  }
  do {
    do {
      while( true ) {
        LYTrimAllStartfile(user_input_buffer);
        if ((*user_input_buffer == '\0') &&
           ((recall == NORECALL || ((ch != L'' && (ch != L'')))))) {
          LYstrncpy(user_input_buffer,*old_user_input,L'');
          if (*old_user_input != (char *)0x0) {
            free(*old_user_input);
            *old_user_input = (char *)0x0;
          }
          pcVar1 = (char *)gettext("Cancelled!!!");
          HTInfoMsg(pcVar1);
          return '\0';
        }
        if ((recall != NORECALL) && (ch == L'')) break;
        if ((recall == NORECALL) || (ch != L'')) {
          return '\x01';
        }
        if (*FirstURLRecall == '\0') {
          *URLNum = *URLNum + L'\xffffffff';
        }
        else {
          *FirstURLRecall = '\0';
          *URLNum = URLTotal + L'\xffffffff';
        }
        if (*URLNum < L'\0') {
          *URLNum = URLTotal + L'\xffffffff';
        }
        pcVar1 = (char *)HTList_objectAt(Goto_URLs,*URLNum);
        if (pcVar1 != (char *)0x0) {
          LYstrncpy(user_input_buffer,pcVar1,L'');
          if (((goto_buffer == '\0') || (**old_user_input == '\0')) ||
             (iVar2 = strcmp(*old_user_input,user_input_buffer), iVar2 != 0)) {
            if (((goto_buffer == '\0') || (URLTotal != L'\x02')) &&
               ((goto_buffer != '\0' || (URLTotal != L'\x01')))) {
              mustshow = '\x01';
              pcVar1 = (char *)gettext("Edit a previous Goto URL: ");
              statusline(pcVar1);
            }
            else {
              mustshow = '\x01';
              pcVar1 = (char *)gettext("Edit the previous Goto URL: ");
              statusline(pcVar1);
            }
          }
          else {
            mustshow = '\x01';
            pcVar1 = (char *)gettext("Edit the current Goto URL: ");
            statusline(pcVar1);
          }
          ch = LYgetstr(user_input_buffer,L'\0',0x400,recall);
          if (ch < L'\0') {
            LYstrncpy(user_input_buffer,*old_user_input,L'');
            if (*old_user_input != (char *)0x0) {
              free(*old_user_input);
              *old_user_input = (char *)0x0;
            }
            pcVar1 = (char *)gettext("Cancelled!!!");
            HTInfoMsg(pcVar1);
            return '\0';
          }
        }
      }
      if (*FirstURLRecall == '\0') {
        *URLNum = *URLNum + L'\x01';
      }
      else {
        *FirstURLRecall = '\0';
        *URLNum = L'\0';
      }
      if (URLTotal <= *URLNum) {
        *URLNum = L'\0';
      }
      pcVar1 = (char *)HTList_objectAt(Goto_URLs,*URLNum);
    } while (pcVar1 == (char *)0x0);
    LYstrncpy(user_input_buffer,pcVar1,L'');
    if (((goto_buffer == '\0') || (**old_user_input == '\0')) ||
       (iVar2 = strcmp(*old_user_input,user_input_buffer), iVar2 != 0)) {
      if (((goto_buffer == '\0') || (URLTotal != L'\x02')) &&
         ((goto_buffer != '\0' || (URLTotal != L'\x01')))) {
        mustshow = '\x01';
        pcVar1 = (char *)gettext("Edit a previous Goto URL: ");
        statusline(pcVar1);
      }
      else {
        mustshow = '\x01';
        pcVar1 = (char *)gettext("Edit the previous Goto URL: ");
        statusline(pcVar1);
      }
    }
    else {
      mustshow = '\x01';
      pcVar1 = (char *)gettext("Edit the current Goto URL: ");
      statusline(pcVar1);
    }
    ch = LYgetstr(user_input_buffer,L'\0',0x400,recall);
  } while (L'\xffffffff' < ch);
  LYstrncpy(user_input_buffer,*old_user_input,L'');
  if (*old_user_input != (char *)0x0) {
    free(*old_user_input);
    *old_user_input = (char *)0x0;
  }
  pcVar1 = (char *)gettext("Cancelled!!!");
  HTInfoMsg(pcVar1);
  return '\0';
}



// WARNING: Unknown calling convention

void do_cleanup_after_delete(void)

{
  HTuncache_current_document();
  move_address(&newdoc,&curdoc);
  newdoc.line = curdoc.line;
  if (curdoc.link == nlinks + L'\xffffffff') {
    newdoc.link = curdoc.link + L'\xffffffff';
  }
  else {
    newdoc.link = curdoc.link;
  }
  return;
}



// WARNING: Unknown calling convention

wchar_t find_link_near_col(wchar_t col,wchar_t delta)

{
  int iVar1;
  char *__s;
  size_t sVar2;
  bool local_25;
  char *text;
  wchar_t cx;
  wchar_t dist;
  wchar_t best;
  wchar_t cy;
  wchar_t i;
  
  i = curdoc.link;
  while( true ) {
    if (delta < L'\x01') {
      local_25 = (bool)((byte)~(byte)((uint)i >> 0x18) >> 7);
    }
    else {
      local_25 = i < nlinks;
    }
    if (local_25 == false) break;
    if (0 < (links[i].ly - links[curdoc.link].ly) * delta) {
      iVar1 = links[i].ly;
      best = L'\xffffffff';
      dist = L'\x000f4240';
      while( true ) {
        if (delta < L'\x01') {
          if (i < L'\0') {
            return best;
          }
        }
        else if (nlinks <= i) {
          return best;
        }
        if (links[i].ly != iVar1) break;
        cx = links[i].lx;
        __s = LYGetHiliteStr(i,L'\0');
        if (__s != (char *)0x0) {
          sVar2 = strlen(__s);
          cx = (sVar2 >> 1) + cx;
        }
        cx = cx - col;
        if (cx < L'\0') {
          cx = -cx;
        }
        if (cx < dist) {
          dist = cx;
          best = i;
        }
        i = i + delta;
      }
      return best;
    }
    i = i + delta;
  }
  return L'\xffffffff';
}



// WARNING: Unknown calling convention

wchar_t DoTraversal(wchar_t c,BOOLEAN *crawl_ok)

{
  bool bVar1;
  BOOLEAN BVar2;
  int iVar3;
  size_t sVar4;
  char *pcVar5;
  FILE *__stream;
  bool bVar6;
  EVP_PKEY_CTX *pEVar7;
  wchar_t local_18;
  BOOLEAN rlink_allowed;
  BOOLEAN rlink_exists;
  BOOLEAN rlink_rejected;
  
  if (((nlinks < 1) || (links[curdoc.link].type == 1)) || (links[curdoc.link].lname == (char *)0x0))
  {
    bVar1 = false;
  }
  else {
    bVar1 = true;
  }
  if (bVar1) {
    BVar2 = lookup_reject(links[curdoc.link].lname);
    if (((BVar2 == '\0') && (traversal_host != (char *)0x0)) &&
       (links[curdoc.link].lname != (char *)0x0)) {
      iVar3 = strncasecomp(links[curdoc.link].lname,"LYNXIMGMAP:",0xb);
      if (iVar3 == 0) {
        sVar4 = strlen(traversal_host);
        iVar3 = strncmp(traversal_host,links[curdoc.link].lname + 0xb,sVar4);
        bVar6 = iVar3 == 0;
      }
      else {
        sVar4 = strlen(traversal_host);
        iVar3 = strncmp(traversal_host,links[curdoc.link].lname,sVar4);
        bVar6 = iVar3 == 0;
      }
    }
    else {
      bVar6 = false;
    }
  }
  else {
    bVar6 = false;
  }
  if ((bVar1) && (bVar6)) {
    BVar2 = lookup_link(links[curdoc.link].lname);
    if (BVar2 == '\0') {
      HTSACopy(&traversal_link_to_add,links[curdoc.link].lname);
      iVar3 = strncasecomp(traversal_link_to_add,"LYNXIMGMAP:",0xb);
      if (iVar3 != 0) {
        *crawl_ok = '\x01';
      }
      c = L'';
    }
    else if ((more_links == '\0') &&
            ((curdoc.link < L'\0' || (nlinks + L'\xffffffff' <= curdoc.link)))) {
      pEVar7 = (EVP_PKEY_CTX *)curdoc.title;
      iVar3 = strcmp(curdoc.title,"Entry into main screen");
      if ((iVar3 == 0) || (nhist < 1)) {
        if (dump_output_immediately == '\0') {
          cleanup(pEVar7);
          exit_immediately(1);
        }
        c = L'\xffffffff';
      }
      else {
        c = L'';
      }
    }
    else {
      c = L'';
    }
  }
  else {
    if (bVar1) {
      add_to_reject_list(links[curdoc.link].lname);
    }
    if ((more_links == '\0') && ((curdoc.link < L'\0' || (nlinks + L'\xffffffff' <= curdoc.link))))
    {
      pEVar7 = (EVP_PKEY_CTX *)curdoc.title;
      iVar3 = strcmp(curdoc.title,"Entry into main screen");
      if ((iVar3 == 0) || (nhist < 1)) {
        if (dump_output_immediately == '\0') {
          cleanup(pEVar7);
          exit_immediately(1);
        }
        c = L'\xffffffff';
      }
      else {
        c = L'';
      }
    }
    else {
      c = L'';
    }
  }
  if (WWW_TraceFlag != '\0') {
    pcVar5 = LYKeycodeToString(c,'\0');
    iVar3 = nlinks;
    if (nlinks < 1) {
      local_18 = L'\0';
    }
    else {
      local_18 = curdoc.link;
    }
    __stream = TraceFP();
    fprintf((FILE *)__stream,"DoTraversal(%d:%d) -> %s\n",local_18,iVar3,pcVar5);
  }
  return c;
}



// WARNING: Unknown calling convention

wchar_t handle_LYK_ACTIVATE(wchar_t *c,wchar_t cmd,BOOLEAN *try_internal,BOOLEAN *refresh_screen,
                           BOOLEAN *force_load,wchar_t real_cmd)

{
  LinkInfo_conflict curlink;
  BOOLEAN BVar1;
  wchar_t wVar2;
  char *pcVar3;
  FILE *__stream;
  HTAtom *pHVar4;
  size_t __n;
  int iVar5;
  LinkInfo *pLVar6;
  char **ppcVar7;
  byte bVar8;
  char *in_stack_ffffff74;
  undefined4 in_stack_ffffff78;
  undefined4 in_stack_ffffff7c;
  undefined4 in_stack_ffffff80;
  undefined4 in_stack_ffffff84;
  undefined auVar9 [16];
  undefined in_stack_ffffff88 [48];
  wchar_t local_28;
  BOOLEAN local_24;
  wchar_t local_20;
  char *local_1c;
  char *local_14;
  undefined8 uVar10;
  
  bVar8 = 0;
  wVar2 = do_change_link();
  if (wVar2 == L'\xffffffff') {
    LYforce_no_cache = '\0';
    reloading = '\0';
    return L'\x01';
  }
  if (nlinks < 1) {
    return L'\0';
  }
  if (links[curdoc.link].type == 1) {
    if (((real_cmd == L'\'') && (textfields_need_activation != '\0')) &&
       (((links[curdoc.link].l_form)->type == 1 ||
        (((((links[curdoc.link].l_form)->type == 0xc || ((links[curdoc.link].l_form)->type == 2)) ||
          ((links[curdoc.link].l_form)->type == 0xb)) || ((links[curdoc.link].l_form)->type == 9))))
       )) {
      textinput_activated = '\x01';
      pLVar6 = links + curdoc.link;
      ppcVar7 = (char **)&stack0xffffff74;
      for (iVar5 = 0x11; iVar5 != 0; iVar5 = iVar5 + -1) {
        *ppcVar7 = pLVar6->lname;
        pLVar6 = (LinkInfo *)((int)pLVar6 + ((uint)bVar8 * -2 + 1) * 4);
        ppcVar7 = ppcVar7 + (uint)bVar8 * -2 + 1;
      }
      curlink.target = (char *)in_stack_ffffff78;
      curlink.lname = in_stack_ffffff74;
      curlink.l_hightext = (char *)in_stack_ffffff7c;
      curlink.l_hightext2 = (char *)in_stack_ffffff80;
      curlink.l_hightext2_offset = in_stack_ffffff84;
      auVar9 = in_stack_ffffff88._28_16_;
      curlink.inUnderline = in_stack_ffffff88[0];
      curlink._21_3_ = in_stack_ffffff88._1_3_;
      curlink.lx = in_stack_ffffff88._4_4_;
      curlink.ly = in_stack_ffffff88._8_4_;
      curlink.type = in_stack_ffffff88._12_4_;
      curlink.sgml_offset = in_stack_ffffff88._16_4_;
      curlink.anchor_number = in_stack_ffffff88._20_4_;
      curlink.anchor_line_num = in_stack_ffffff88._24_4_;
      uVar10 = auVar9._4_8_;
      curlink.list.hl_info = (HiliteInfo *)auVar9._0_4_;
      curlink.list.hl_base.hl_text = (char *)(int)uVar10;
      curlink.list.hl_base.hl_x = (short)((ulonglong)uVar10 >> 0x20);
      curlink.list.hl_base._6_2_ = (short)((ulonglong)uVar10 >> 0x30);
      curlink.list.hl_len = auVar9._12_2_;
      curlink.list._14_2_ = auVar9._14_2_;
      curlink.l_form = (_FormInfo_conflict *)in_stack_ffffff88._44_4_;
      show_main_statusline(curlink,L'\x02');
      textfields_need_activation = textfields_activation_option;
      return L'\0';
    }
    if ((((links[curdoc.link].l_form)->type == 5) || ((links[curdoc.link].l_form)->type == 0xd)) ||
       ((links[curdoc.link].l_form)->type == 0xc)) {
      if ((links[curdoc.link].l_form)->disabled == 1) {
        HTOutputFormat = HTAtom_for("www/present");
        LYforce_no_cache = '\0';
        reloading = '\0';
        return L'\0';
      }
      if (((links[curdoc.link].l_form)->submit_action == (char *)0x0) ||
         (*(links[curdoc.link].l_form)->submit_action == '\0')) {
        pcVar3 = (char *)gettext();
        HTUserMsg(pcVar3);
        HTOutputFormat = HTAtom_for("www/present");
        LYforce_no_cache = '\0';
        reloading = '\0';
        return L'\0';
      }
      if (((links[curdoc.link].l_form)->submit_method == 3) && (no_mail != '\0')) {
        pcVar3 = (char *)gettext();
        HTAlert(pcVar3);
        HTOutputFormat = HTAtom_for("www/present");
        LYforce_no_cache = '\0';
        reloading = '\0';
        return L'\0';
      }
      if ((no_file_url != '\0') &&
         (((*(links[curdoc.link].l_form)->submit_action == 'f' ||
           (*(links[curdoc.link].l_form)->submit_action == 'F')) &&
          (iVar5 = strncasecomp((links[curdoc.link].l_form)->submit_action,"file:",5), iVar5 == 0)))
         ) {
        pcVar3 = (char *)gettext();
        HTAlert(pcVar3);
        HTOutputFormat = HTAtom_for("www/present");
        LYforce_no_cache = '\0';
        reloading = '\0';
        return L'\0';
      }
      iVar5 = strncasecomp((links[curdoc.link].l_form)->submit_action,"LYNXCOOKIE:",0xb);
      if (((((iVar5 == 0) ||
            ((iVar5 = strncasecomp((links[curdoc.link].l_form)->submit_action,"LYNXDIRED:",10),
             iVar5 == 0 &&
             (((no_dired_support != '\0' ||
               (iVar5 = strncasecomp((links[curdoc.link].l_form)->submit_action + 10,
                                     "//PERMIT_LOCATION",0x11), iVar5 != 0)) ||
              (BVar1 = LYIsUIPage3(curdoc.address,UIP_PERMIT_OPTIONS,L'\x01'), BVar1 == '\0'))))))
           || (((iVar5 = strncasecomp((links[curdoc.link].l_form)->submit_action,"LYNXDOWNLOAD:",0xd
                                     ), iVar5 == 0 ||
                (iVar5 = strncasecomp((links[curdoc.link].l_form)->submit_action,"LYNXHIST:",9),
                iVar5 == 0)) ||
               ((iVar5 = strncasecomp((links[curdoc.link].l_form)->submit_action,"LYNXKEYMAP:",0xb),
                iVar5 == 0 ||
                ((iVar5 = strncasecomp((links[curdoc.link].l_form)->submit_action,"LYNXIMGMAP:",0xb)
                 , iVar5 == 0 ||
                 (iVar5 = strncasecomp((links[curdoc.link].l_form)->submit_action,"LYNXPRINT:",10),
                 iVar5 == 0)))))))) ||
          (((*(links[curdoc.link].l_form)->submit_action == 'l' ||
            (*(links[curdoc.link].l_form)->submit_action == 'L')) &&
           (iVar5 = strncasecomp((links[curdoc.link].l_form)->submit_action,"lynxexec:",9),
           iVar5 == 0)))) ||
         (((*(links[curdoc.link].l_form)->submit_action == 'l' ||
           (*(links[curdoc.link].l_form)->submit_action == 'L')) &&
          (iVar5 = strncasecomp((links[curdoc.link].l_form)->submit_action,"lynxprog:",9),
          iVar5 == 0)))) {
        pcVar3 = (char *)gettext();
        HTAlert(pcVar3);
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"LYMainLoop: Rejected \'%s\'\n");
        }
        HTOutputFormat = HTAtom_for("www/present");
        LYforce_no_cache = '\0';
        reloading = '\0';
        return L'\0';
      }
      if (check_realm != '\0') {
        LYPermitURL = '\x01';
      }
      if (((no_filereferer == '\x01') && ((*curdoc.address == 'f' || (*curdoc.address == 'F')))) &&
         (iVar5 = strncasecomp(curdoc.address,"file:",5), iVar5 == 0)) {
        LYNoRefererForThis = '\x01';
      }
      if ((links[curdoc.link].l_form)->submit_method != 3) {
        pcVar3 = LYGetHiliteStr(curdoc.link,L'\0');
        HTSACopy(&newdoc.title,pcVar3);
      }
    }
    if ((((links[curdoc.link].l_form)->type == 1) || ((links[curdoc.link].l_form)->type == 0xc)) ||
       (((links[curdoc.link].l_form)->type == 2 ||
        (((links[curdoc.link].l_form)->type == 0xb || ((links[curdoc.link].l_form)->type == 9))))))
    {
      if ((real_cmd == L'.') ||
         (((real_cmd == L'?' || (real_cmd == L'D')) ||
          ((real_cmd == L'(' && (textinput_activated == '\0')))))) {
        local_28 = L'\0';
      }
      else {
        local_28 = L'\x02';
      }
      show_formlink_statusline((FormInfo *)links[curdoc.link].l_form,local_28);
      if (((user_mode == 0) && (textinput_activated != '\0')) &&
         ((real_cmd == L'\'' || (real_cmd == L'(')))) {
        form_noviceline((links[curdoc.link].l_form)->disabled);
      }
    }
    if ((((real_cmd == L'(') || (real_cmd == L'.')) || (real_cmd == L'?')) || (real_cmd == L'D')) {
      local_24 = '\x01';
    }
    else {
      local_24 = '\0';
    }
    wVar2 = change_form_link(curdoc.link,&newdoc,refresh_screen,'\0',local_24);
    *c = wVar2;
    if ((*c == L'') && (*refresh_screen == '\0')) {
      pHVar4 = HTAtom_for("www/download");
      if ((((pHVar4 == HTOutputFormat) && (newdoc.post_data != (bstring_conflict *)0x0)) &&
          (newdoc.safe == '\0')) && (BVar1 = HText_POSTReplyLoaded(&newdoc), BVar1 == '\x01')) {
        pcVar3 = (char *)gettext();
        BVar1 = HTConfirm(pcVar3);
        if (BVar1 == '\0') {
          pcVar3 = (char *)gettext();
          HTInfoMsg(pcVar3);
          HTOutputFormat = HTAtom_for("www/present");
          LYforce_no_cache = '\0';
          copy_address(&newdoc,&curdoc);
          HTSACopy(&newdoc.title,curdoc.title);
          if (curdoc.post_data == (bstring_conflict *)0x0) {
            local_20 = L'\0';
            local_1c = (char *)0x0;
          }
          else {
            local_20 = (curdoc.post_data)->len;
            local_1c = (curdoc.post_data)->str;
          }
          HTSABCopy((bstring **)&newdoc.post_data,local_1c,local_20);
          HTSACopy(&newdoc.post_content_type,curdoc.post_content_type);
          HTSACopy(&newdoc.bookmark,curdoc.bookmark);
          newdoc.isHEAD = curdoc.isHEAD;
          newdoc.safe = curdoc.safe;
          newdoc.internal_link = curdoc.internal_link;
          return L'\0';
        }
      }
      if ((check_realm != '\0') && (LYValidate == '\0')) {
        LYPermitURL = '\x01';
      }
    }
    else if ((((links[curdoc.link].l_form)->type == 5) ||
             (((links[curdoc.link].l_form)->type == 0xd ||
              ((links[curdoc.link].l_form)->type == 0xc)))) &&
            ((links[curdoc.link].l_form)->submit_method != 3)) {
      pcVar3 = HText_getTitle();
      if (pcVar3 == (char *)0x0) {
        if (curdoc.title != (char *)0x0) {
          HTSACopy(&newdoc.title,curdoc.title);
        }
      }
      else {
        pcVar3 = HText_getTitle();
        HTSACopy(&newdoc.title,pcVar3);
      }
    }
    if (*c == L'') {
      *c = L'';
    }
    else if (*c == L'\x17') {
      *c = L'';
      *refresh_screen = '\x01';
    }
    else {
      if ((((*c & 0x8000U) == 0) && ((*c & 0x800U) != 0)) &&
         (iVar5 = LYReverseKeymap(*c & 0xff), -1 < iVar5)) {
        LYReverseKeymap(*c & 0xff);
      }
      if (((real_cmd == L'\'') || (real_cmd == L'(')) &&
         (((((links[curdoc.link].l_form)->type == 1 ||
            ((((links[curdoc.link].l_form)->type == 0xc || ((links[curdoc.link].l_form)->type == 2))
             || ((links[curdoc.link].l_form)->type == 0xb)))) ||
           ((links[curdoc.link].l_form)->type == 9)) && (textinput_activated != '\0')))) {
        return L'\x03';
      }
    }
    return L'\x02';
  }
  if (((no_file_url != '\0') &&
      ((*links[curdoc.link].lname == 'f' || (*links[curdoc.link].lname == 'F')))) &&
     (iVar5 = strncasecomp(links[curdoc.link].lname,"file:",5), iVar5 == 0)) {
    if (((*curdoc.address != 'f') && (*curdoc.address != 'F')) ||
       (iVar5 = strncasecomp(curdoc.address,"file:",5), iVar5 != 0)) {
      iVar5 = strncasecomp(curdoc.address,"LYNXKEYMAP:",0xb);
      if ((iVar5 != 0) && (iVar5 = strncasecomp(curdoc.address,"LYNXCOOKIE:",0xb), iVar5 != 0)) {
LAB_0807e34b:
        pcVar3 = (char *)gettext();
        HTAlert(pcVar3);
        reloading = '\0';
        return L'\0';
      }
      __n = strlen(helpfilepath);
      iVar5 = strncmp(links[curdoc.link].lname,helpfilepath,__n);
      if (iVar5 != 0) goto LAB_0807e34b;
    }
    if (curdoc.bookmark != (char *)0x0) {
      pcVar3 = (char *)gettext();
      HTAlert(pcVar3);
      reloading = '\0';
      return L'\0';
    }
  }
  iVar5 = strncasecomp(links[curdoc.link].lname,"LYNXCOOKIE:",0xb);
  if (iVar5 == 0) {
    pcVar3 = (char *)gettext();
    if (curdoc.title == (char *)0x0) {
      local_14 = "";
    }
    else {
      local_14 = curdoc.title;
    }
    iVar5 = strcmp(local_14,pcVar3);
    if ((iVar5 != 0) || (iVar5 = strncasecomp(curdoc.address,"LYNXCOOKIE:",0xb), iVar5 != 0))
    goto LAB_0807e610;
  }
  iVar5 = strncasecomp(links[curdoc.link].lname,"LYNXDIRED:",10);
  if (((((iVar5 == 0) &&
        (((BVar1 = LYIsUIPage3(curdoc.address,UIP_DIRED_MENU,L'\x01'), BVar1 == '\0' &&
          (BVar1 = LYIsUIPage3(curdoc.address,UIP_PERMIT_OPTIONS,L'\x01'), BVar1 == '\0')) &&
         (BVar1 = LYIsUIPage3(curdoc.address,UIP_UPLOAD_OPTIONS,L'\x01'), BVar1 == '\0')))) ||
       ((iVar5 = strncasecomp(links[curdoc.link].lname,"LYNXDOWNLOAD:",0xd), iVar5 == 0 &&
        (BVar1 = LYIsUIPage3(curdoc.address,UIP_DOWNLOAD_OPTIONS,L'\x01'), BVar1 == '\0')))) ||
      ((iVar5 = strncasecomp(links[curdoc.link].lname,"LYNXHIST:",9), iVar5 == 0 &&
       (((BVar1 = LYIsUIPage3(curdoc.address,UIP_HISTORY,L'\x01'), BVar1 == '\0' &&
         (BVar1 = LYIsUIPage3(curdoc.address,UIP_LIST_PAGE,L'\x01'), BVar1 == '\0')) &&
        (BVar1 = LYIsUIPage3(curdoc.address,UIP_ADDRLIST_PAGE,L'\x01'), BVar1 == '\0')))))) ||
     ((iVar5 = strncasecomp(links[curdoc.link].lname,"LYNXPRINT:",10), iVar5 == 0 &&
      (BVar1 = LYIsUIPage3(curdoc.address,UIP_PRINT_OPTIONS,L'\x01'), BVar1 == '\0')))) {
LAB_0807e610:
    pcVar3 = (char *)gettext();
    HTAlert(pcVar3);
    HTOutputFormat = HTAtom_for("www/present");
    reloading = '\0';
    LYforce_no_cache = '\0';
    return L'\0';
  }
  BVar1 = run_external(links[curdoc.link].lname,'\x01');
  if (BVar1 != '\0') {
    *refresh_screen = '\x01';
    return L'\0';
  }
  set_address(&newdoc,links[curdoc.link].lname);
  pcVar3 = LYGetHiliteStr(curdoc.link,L'\0');
  HTSACopy(&newdoc.title,pcVar3);
  wVar2 = are_different(&curdoc,&newdoc);
  if (wVar2 != L'\0') {
    LYFreePostData(&newdoc);
    if (newdoc.bookmark != (char *)0x0) {
      free(newdoc.bookmark);
      newdoc.bookmark = (char *)0x0;
    }
    iVar5 = strncasecomp(newdoc.address,"LYNXMESSAGES:",0xd);
    if (iVar5 == 0) {
      LYforce_no_cache = '\x01';
    }
  }
  if ((((no_jump == '\0') && (lynxjumpfile != (char *)0x0)) && (curdoc.address != (char *)0x0)) &&
     (iVar5 = strcmp(lynxjumpfile,curdoc.address), iVar5 == 0)) {
    LYJumpFileURL = '\x01';
    LYUserSpecifiedURL = '\x01';
    goto LAB_0807e858;
  }
  if (curdoc.title == (char *)0x0) {
LAB_0807e7d7:
    if ((curdoc.bookmark == (char *)0x0) &&
       ((lynxjumpfile == (char *)0x0 || (iVar5 = strcmp(lynxjumpfile,curdoc.address), iVar5 != 0))))
    {
      if (((no_filereferer == '\x01') && ((*curdoc.address == 'f' || (*curdoc.address == 'F')))) &&
         (iVar5 = strncasecomp(curdoc.address,"file:",5), iVar5 == 0)) {
        LYNoRefererForThis = '\x01';
      }
      goto LAB_0807e858;
    }
  }
  else {
    BVar1 = LYIsUIPage3(curdoc.address,UIP_HISTORY,L'\x01');
    if (BVar1 == '\0') {
      pcVar3 = (char *)gettext();
      iVar5 = strcmp(curdoc.title,pcVar3);
      if (iVar5 != 0) goto LAB_0807e7d7;
    }
  }
  LYUserSpecifiedURL = '\x01';
LAB_0807e858:
  newdoc.link = L'\0';
  *force_load = '\x01';
  psrc_view = '\0';
  if (lynx_edit_mode != '\0') {
    if (1 < LYAutoUncacheDirLists) {
      HTuncache_current_document();
    }
    HTUnEscapeSome(newdoc.address,"/");
    iVar5 = strcasecomp(newdoc.address,"file://localhost/");
    if (iVar5 != 0) {
      strip_trailing_slash(newdoc.address);
    }
  }
  iVar5 = strncasecomp(curdoc.address,"LYNXCOOKIE:",0xb);
  if (iVar5 != 0) {
    return L'\0';
  }
  HTuncache_current_document();
  return L'\0';
}



// WARNING: Unknown calling convention

void handle_LYK_ADD_BOOKMARK(BOOLEAN *refresh_screen,wchar_t *old_c,wchar_t real_c)

{
  BOOLEAN BVar1;
  char *pcVar2;
  int iVar3;
  wchar_t wVar4;
  char *local_18;
  wchar_t c;
  
  if (LYValidate != '\0') {
    if (*old_c == real_c) {
      return;
    }
    *old_c = real_c;
    pcVar2 = (char *)gettext("Bookmark features are currently disabled.");
    HTUserMsg(pcVar2);
    return;
  }
  BVar1 = LYIsUIPage3(curdoc.address,UIP_HISTORY,L'\x01');
  if ((((((BVar1 != '\0') ||
         (BVar1 = LYIsUIPage3(curdoc.address,UIP_SHOWINFO,L'\x01'), BVar1 != '\0')) ||
        (BVar1 = LYIsUIPage3(curdoc.address,UIP_PRINT_OPTIONS,L'\x01'), BVar1 != '\0')) ||
       ((BVar1 = LYIsUIPage3(curdoc.address,UIP_DIRED_MENU,L'\x01'), BVar1 != '\0' ||
        (BVar1 = LYIsUIPage3(curdoc.address,UIP_PERMIT_OPTIONS,L'\x01'), BVar1 != '\0')))) ||
      (((BVar1 = LYIsUIPage3(curdoc.address,UIP_UPLOAD_OPTIONS,L'\x01'), BVar1 != '\0' ||
        ((BVar1 = LYIsUIPage3(curdoc.address,UIP_DOWNLOAD_OPTIONS,L'\x01'), BVar1 != '\0' ||
         (iVar3 = strncasecomp(curdoc.address,"LYNXCOOKIE:",0xb), iVar3 == 0)))) ||
       (BVar1 = LYIsUIPage3(curdoc.address,UIP_OPTIONS_MENU,L'\x01'), BVar1 != '\0')))) ||
     ((0 < nlinks &&
      ((((links[curdoc.link].lname == (char *)0x0 ||
         (iVar3 = strncasecomp(links[curdoc.link].lname,"LYNXHIST:",9), iVar3 == 0)) ||
        (iVar3 = strncasecomp(links[curdoc.link].lname,"LYNXPRINT:",10), iVar3 == 0)) ||
       (((iVar3 = strncasecomp(links[curdoc.link].lname,"LYNXDIRED:",10), iVar3 == 0 ||
         (iVar3 = strncasecomp(links[curdoc.link].lname,"LYNXDOWNLOAD:",0xd), iVar3 == 0)) ||
        ((iVar3 = strncasecomp(links[curdoc.link].lname,"LYNXCOOKIE:",0xb), iVar3 == 0 ||
         (iVar3 = strncasecomp(links[curdoc.link].lname,"LYNXPRINT:",10), iVar3 == 0)))))))))) {
    if (*old_c != real_c) {
      *old_c = real_c;
      pcVar2 = (char *)gettext(
                              "History, showinfo, menu and list files cannot be saved as bookmarks."
                              );
      HTUserMsg(pcVar2);
    }
    return;
  }
  if (nlinks < 1) {
    if (curdoc.post_data != (bstring_conflict *)0x0) {
      pcVar2 = (char *)gettext(
                              "Documents from forms with POST content cannot be saved as bookmarks."
                              );
      HTUserMsg(pcVar2);
      return;
    }
    if (curdoc.bookmark != (char *)0x0) {
      pcVar2 = (char *)gettext("There are no links in this bookmark file!");
      HTUserMsg(pcVar2);
      return;
    }
    mustshow = '\x01';
    pcVar2 = (char *)gettext("Save D)ocument to bookmark file or C)ancel? (d,c): ");
    statusline(pcVar2);
    wVar4 = LYgetch_single();
    if (wVar4 != L'D') {
      return;
    }
    save_bookmark_link(curdoc.address,curdoc.title);
    *refresh_screen = '\x01';
    goto check_add_bookmark_to_self;
  }
  if (((curdoc.post_data == (bstring_conflict *)0x0) && (curdoc.bookmark == (char *)0x0)) &&
     ((BVar1 = LYIsUIPage3(curdoc.address,UIP_LIST_PAGE,L'\x01'), BVar1 == '\0' &&
      ((BVar1 = LYIsUIPage3(curdoc.address,UIP_ADDRLIST_PAGE,L'\x01'), BVar1 == '\0' &&
       (BVar1 = LYIsUIPage3(curdoc.address,UIP_VLINKS,L'\x01'), BVar1 == '\0')))))) {
    mustshow = '\x01';
    pcVar2 = (char *)gettext("Save D)ocument or L)ink to bookmark file or C)ancel? (d,l,c): ");
    statusline(pcVar2);
    c = LYgetch_single();
    if (c == L'D') {
      save_bookmark_link(curdoc.address,curdoc.title);
      *refresh_screen = '\x01';
      goto check_add_bookmark_to_self;
    }
  }
  else {
    if ((LYMultiBookmarks == 0) && (curdoc.bookmark != (char *)0x0)) {
      if (*bookmark_page == '.') {
        local_18 = bookmark_page + 1;
      }
      else {
        local_18 = bookmark_page;
      }
      pcVar2 = strstr(curdoc.address,local_18);
      if (pcVar2 == (char *)0x0) goto LAB_0807ed36;
      mustshow = '\x01';
      pcVar2 = (char *)gettext("Reproduce L)ink in this bookmark file or C)ancel? (l,c): ");
      statusline(pcVar2);
    }
    else {
LAB_0807ed36:
      if ((curdoc.post_data != (bstring_conflict *)0x0) && (links[curdoc.link].type == 6)) {
        pcVar2 = (char *)gettext(
                                "Documents from forms with POST content cannot be saved as bookmarks."
                                );
        HTUserMsg(pcVar2);
        return;
      }
      mustshow = '\x01';
      pcVar2 = (char *)gettext("Save L)ink to bookmark file or C)ancel? (l,c): ");
      statusline(pcVar2);
    }
    c = LYgetch_single();
  }
  if (c != L'L') {
    return;
  }
  if ((curdoc.post_data != (bstring_conflict *)0x0) && (links[curdoc.link].type == 6)) {
    pcVar2 = (char *)gettext("Documents from forms with POST content cannot be saved as bookmarks.")
    ;
    HTUserMsg(pcVar2);
    return;
  }
  if (links[curdoc.link].type == 1) {
    pcVar2 = (char *)gettext("Cannot save form fields/links");
    HTUserMsg(pcVar2);
    return;
  }
  pcVar2 = LYGetHiliteStr(curdoc.link,L'\0');
  save_bookmark_link(links[curdoc.link].lname,pcVar2);
  *refresh_screen = '\x01';
check_add_bookmark_to_self:
  if (curdoc.bookmark == (char *)0x0) {
    return;
  }
  if (BookmarkPage == (char *)0x0) {
    return;
  }
  iVar3 = strcmp(curdoc.bookmark,BookmarkPage);
  if (iVar3 != 0) {
    return;
  }
  HTuncache_current_document();
  move_address(&newdoc,&curdoc);
  HTSACopy(&newdoc.bookmark,curdoc.bookmark);
  newdoc.link = curdoc.link;
  newdoc.line = curdoc.line;
  newdoc.internal_link = '\0';
  return;
}



// WARNING: Unknown calling convention

void handle_LYK_CLEAR_AUTH(wchar_t *old_c,wchar_t real_c)

{
  BOOLEAN BVar1;
  char *pcVar2;
  
  if (*old_c != real_c) {
    *old_c = real_c;
    pcVar2 = (char *)gettext("Clear all authorization info for this session?");
    BVar1 = HTConfirm(pcVar2);
    if (BVar1 == '\0') {
      pcVar2 = (char *)gettext("Cancelled!!!");
      HTUserMsg(pcVar2);
    }
    else {
      if (authentication_info[0] != (char *)0x0) {
        free(authentication_info[0]);
        authentication_info[0] = (char *)0x0;
      }
      if (authentication_info[1] != (char *)0x0) {
        free(authentication_info[1]);
        authentication_info[1] = (char *)0x0;
      }
      if (proxyauth_info[0] != (char *)0x0) {
        free(proxyauth_info[0]);
        proxyauth_info[0] = (char *)0x0;
      }
      if (proxyauth_info[1] != (char *)0x0) {
        free(proxyauth_info[1]);
        proxyauth_info[1] = (char *)0x0;
      }
      HTClearHTTPAuthInfo();
      HTClearNNTPAuthInfo();
      HTClearFTPPassword();
      pcVar2 = (char *)gettext("Authorization info cleared.");
      HTUserMsg(pcVar2);
    }
  }
  return;
}



// WARNING: Unknown calling convention

wchar_t handle_LYK_COMMAND(char *user_input_buffer)

{
  wchar_t wVar1;
  char *buffer;
  char *pcVar2;
  Kcmd *pKVar3;
  FILE *__stream;
  wchar_t local_20;
  wchar_t local_1c;
  wchar_t local_18;
  char *tmp;
  char *src;
  Kcmd *mp;
  wchar_t ch;
  
  *user_input_buffer = '\0';
  mustshow = '\x01';
  statusline(": ");
  wVar1 = LYgetstr(user_input_buffer,L'\0',0x400,RECALL_CMD);
  if (wVar1 < L'\0') {
    local_1c = L'\0';
  }
  else {
    buffer = LYSkipBlanks(user_input_buffer);
    pcVar2 = LYSkipNonBlanks(buffer);
    *pcVar2 = '\0';
    pKVar3 = LYStringToKcmd(buffer);
    if (pKVar3 == (Kcmd *)0x0) {
      local_20 = L'\0';
    }
    else {
      local_20 = pKVar3->code;
    }
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"LYK_COMMAND(%s.%s) = %d\n",buffer,pcVar2,local_20);
    }
    if (local_20 == L'\0') {
      if (*buffer == '\0') {
        local_18 = L'\0';
      }
      else {
        local_18 = L'\xffffffff';
      }
      local_1c = local_18;
    }
    else {
      local_1c = local_20;
    }
  }
  return local_1c;
}



// WARNING: Unknown calling convention

void handle_LYK_COMMENT(BOOLEAN *refresh_screen,char **owner_address_p,wchar_t *old_c,wchar_t real_c
                       )

{
  int iVar1;
  char *pcVar2;
  wchar_t wVar3;
  size_t sVar4;
  char *pcVar5;
  UrlTypes UVar6;
  char *local_30;
  char *local_2c;
  char *temp;
  char *id;
  char *kp;
  char *cp;
  char *address;
  wchar_t c;
  
  if ((*owner_address_p == (char *)0x0) &&
     (iVar1 = strncasecomp(curdoc.address,"http",4), iVar1 != 0)) {
    if (*old_c == real_c) {
      return;
    }
    *old_c = real_c;
    pcVar2 = (char *)gettext("No owner is defined for this file so you cannot send a comment");
    HTUserMsg(pcVar2);
    return;
  }
  if (no_mail == '\0') {
    pcVar2 = (char *)gettext("Do you wish to send a comment?");
    wVar3 = HTConfirmDefault(pcVar2,L'\0');
    if (wVar3 != L'\0') {
      if (*owner_address_p == (char *)0x0) {
        address = (char *)0x0;
        temp = HTParse(curdoc.address,"",4);
        if (temp != (char *)0x0) {
          HTUnEscape(temp);
          if ((*temp == '~') && (sVar4 = strlen(temp), 1 < sVar4)) {
            cp = strchr(temp + 1,0x2f);
            if (cp != (char *)0x0) {
              *cp = '\0';
            }
            HTSACopy(&address,"mailto:");
            HTSACat(&address,temp + 1);
            HTSACat(&address,"@");
          }
          if (temp != (char *)0x0) {
            free(temp);
            temp = (char *)0x0;
          }
        }
        if (address == (char *)0x0) {
          HTSACopy(&address,"mailto:WebMaster@");
        }
        temp = HTParse(curdoc.address,"",8);
        HTSACat(&address,temp);
        pcVar2 = address;
        pcVar5 = (char *)gettext("No owner is defined. Use %s?");
        HTSprintf0(&temp,pcVar5,pcVar2);
        c = HTConfirmDefault(temp,L'\0');
        if (temp != (char *)0x0) {
          free(temp);
          temp = (char *)0x0;
        }
        if (c != L'\x01') {
          if (address == (char *)0x0) {
            return;
          }
          free(address);
          return;
        }
        HTSACopy(owner_address_p,address);
        if (address != (char *)0x0) {
          free(address);
          address = (char *)0x0;
        }
      }
      UVar6 = is_url(*owner_address_p);
      if (UVar6 == MAILTO_URL_TYPE) {
        kp = HText_getRevTitle();
        id = HText_getMessageID();
        temp = (char *)0x0;
        if ((((kp == (char *)0x0) && (HTMainAnchor != (HTParentAnchor *)0x0)) &&
            (kp = HTAnchor_subject(HTMainAnchor), kp != (char *)0x0)) &&
           ((*kp != '\0' && (iVar1 = strncasecomp(kp,"Re: ",4), iVar1 != 0)))) {
          HTSACopy(&temp,"Re: ");
          HTSACat(&temp,kp);
          kp = temp;
        }
        pcVar5 = strchr(*owner_address_p,0x3a);
        pcVar2 = curdoc.address;
        if (pcVar5 == (char *)0x0) {
          if (kp == (char *)0x0) {
            local_2c = "";
          }
          else {
            local_2c = kp;
          }
          reply_by_mail(*owner_address_p,curdoc.address,local_2c,id);
        }
        else {
          if (kp == (char *)0x0) {
            local_30 = "";
          }
          else {
            local_30 = kp;
          }
          pcVar5 = strchr(*owner_address_p,0x3a);
          reply_by_mail(pcVar5 + 1,pcVar2,local_30,id);
        }
        if (temp != (char *)0x0) {
          free(temp);
        }
        *refresh_screen = '\x01';
      }
      else {
        set_address(&newdoc,*owner_address_p);
        newdoc.internal_link = '\0';
      }
    }
  }
  else if (*old_c != real_c) {
    *old_c = real_c;
    pcVar2 = (char *)gettext("Mail is disallowed so you cannot send a comment");
    HTUserMsg(pcVar2);
  }
  return;
}



// WARNING: Unknown calling convention

BOOLEAN handle_LYK_COOKIE_JAR(wchar_t *cmd)

{
  int iVar1;
  BOOLEAN local_5;
  
  iVar1 = strncasecomp(curdoc.address,"LYNXCOOKIE:",0xb);
  if (iVar1 == 0) {
    *cmd = L'%';
    local_5 = '\x01';
  }
  else {
    set_address(&newdoc,"LYNXCOOKIE:/");
    LYFreePostData(&newdoc);
    if (newdoc.bookmark != (char *)0x0) {
      free(newdoc.bookmark);
      newdoc.bookmark = (char *)0x0;
    }
    newdoc.isHEAD = '\0';
    newdoc.safe = '\0';
    newdoc.internal_link = '\0';
    LYforce_no_cache = '\x01';
    if ((LYValidate != '\0') || (check_realm != '\0')) {
      LYPermitURL = '\x01';
    }
    local_5 = '\0';
  }
  return local_5;
}



// WARNING: Unknown calling convention

void handle_LYK_CREATE(void)

{
  wchar_t wVar1;
  
  if ((lynx_edit_mode != '\0') && (no_dired_support == '\0')) {
    wVar1 = local_create(&curdoc);
    if (L'\0' < wVar1) {
      if (0 < LYAutoUncacheDirLists) {
        HTuncache_current_document();
      }
      move_address(&newdoc,&curdoc);
      LYFreePostData(&newdoc);
      if (newdoc.bookmark != (char *)0x0) {
        free(newdoc.bookmark);
        newdoc.bookmark = (char *)0x0;
      }
      newdoc.isHEAD = '\0';
      newdoc.safe = '\0';
      newdoc.line = curdoc.line;
      newdoc.link = ~(curdoc.link >> 0x1f) & curdoc.link;
      LYclear();
    }
  }
  return;
}



// WARNING: Unknown calling convention

void handle_LYK_DEL_BOOKMARK(BOOLEAN *refresh_screen,wchar_t *old_c,wchar_t real_c)

{
  char *Msg;
  wchar_t wVar1;
  
  if (curdoc.bookmark == (char *)0x0) {
    *refresh_screen = '\x01';
    if (*old_c != real_c) {
      *old_c = real_c;
      lynx_force_repaint();
    }
  }
  else {
    Msg = (char *)gettext("Do you really want to delete this link from your bookmark file?");
    wVar1 = HTConfirmDefault(Msg,L'\0');
    if (wVar1 == L'\x01') {
      remove_bookmark_link(links[curdoc.link].anchor_number + L'\xffffffff',curdoc.bookmark);
      do_cleanup_after_delete();
    }
  }
  return;
}



// WARNING: Unknown calling convention

void handle_LYK_DIRED_MENU(BOOLEAN *refresh_screen,wchar_t *old_c,wchar_t real_c)

{
  BOOLEAN BVar1;
  char *__s2;
  int iVar2;
  char *local_8;
  
  if ((lynx_edit_mode != '\0') && (no_dired_support == '\0')) {
    BVar1 = LYIsUIPage3(curdoc.address,UIP_DIRED_MENU,L'\x01');
    if (BVar1 == '\0') {
      __s2 = (char *)gettext("File Management Options");
      if (curdoc.title == (char *)0x0) {
        local_8 = "";
      }
      else {
        local_8 = curdoc.title;
      }
      iVar2 = strcmp(local_8,__s2);
      if (iVar2 != 0) {
        dired_options(&curdoc,&newdoc.address);
        *refresh_screen = '\x01';
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

wchar_t handle_LYK_DOWNLOAD(wchar_t *cmd,wchar_t *old_c,wchar_t real_c)

{
  BOOLEAN BVar1;
  char *pcVar2;
  wchar_t wVar3;
  int iVar4;
  wchar_t local_1c;
  char *local_18;
  wchar_t number;
  
  if ((LYValidate != '\0') ||
     (((no_download != '\0' && (override_no_download == '\0')) && (no_disk_save != '\0')))) {
    if (*old_c != real_c) {
      *old_c = real_c;
      pcVar2 = (char *)gettext("The \'d\'ownload command is currently disabled.");
      HTUserMsg(pcVar2);
    }
    return L'\0';
  }
  BVar1 = LYIsUIPage3(curdoc.address,UIP_DOWNLOAD_OPTIONS,L'\x01');
  if (BVar1 != '\0') {
    return L'\0';
  }
  wVar3 = do_change_link();
  if (wVar3 != L'\xffffffff') {
    if (nlinks < 1) {
      if (*old_c != real_c) {
        *old_c = real_c;
        pcVar2 = (char *)gettext("Nothing to download.");
        HTUserMsg(pcVar2);
      }
    }
    else if (links[curdoc.link].type == 1) {
      if ((((links[curdoc.link].l_form)->type == 5) || ((links[curdoc.link].l_form)->type == 0xd))
         || ((links[curdoc.link].l_form)->type == 0xc)) {
        if ((links[curdoc.link].l_form)->submit_method == 3) {
          if (*old_c != real_c) {
            *old_c = real_c;
            pcVar2 = (char *)gettext("Form has a mailto action!  Cannot download.");
            HTUserMsg(pcVar2);
          }
          return L'\0';
        }
        iVar4 = strncasecomp((links[curdoc.link].l_form)->submit_action,"LYNXOPTIONS:",0xc);
        if (iVar4 == 0) {
          if (*old_c != real_c) {
            *old_c = real_c;
            pcVar2 = (char *)gettext("This special URL cannot be downloaded!");
            HTUserMsg(pcVar2);
          }
          return L'\0';
        }
        HTOutputFormat = HTAtom_for("www/download");
        LYforce_no_cache = '\x01';
        *cmd = L'\'';
        return L'\x02';
      }
      if (*old_c != real_c) {
        *old_c = real_c;
        pcVar2 = (char *)gettext("You cannot download an input field.");
        HTUserMsg(pcVar2);
      }
    }
    else {
      iVar4 = strncasecomp(curdoc.address,"LYNXCOOKIE:",0xb);
      if (iVar4 == 0) {
        if (*old_c != real_c) {
          *old_c = real_c;
          pcVar2 = (char *)gettext("You cannot download cookies.");
          HTUserMsg(pcVar2);
        }
      }
      else {
        BVar1 = LYIsUIPage3(curdoc.address,UIP_PRINT_OPTIONS,L'\x01');
        if (BVar1 == '\0') {
          BVar1 = LYIsUIPage3(curdoc.address,UIP_UPLOAD_OPTIONS,L'\x01');
          if (BVar1 == '\0') {
            BVar1 = LYIsUIPage3(curdoc.address,UIP_PERMIT_OPTIONS,L'\x01');
            if (BVar1 == '\0') {
              if (((lynx_edit_mode == '\0') || (no_dired_support != '\0')) ||
                 (pcVar2 = strstr(links[curdoc.link].lname,"/SugFile="), pcVar2 != (char *)0x0)) {
                BVar1 = LYIsUIPage3(curdoc.address,UIP_HISTORY,L'\x01');
                if ((BVar1 == '\0') ||
                   (iVar4 = strncasecomp(links[curdoc.link].lname,"LYNXHIST:",9), iVar4 != 0)) {
                  iVar4 = strncmp(links[curdoc.link].lname,"data:",5);
                  if (iVar4 == 0) {
                    if (*old_c != real_c) {
                      *old_c = real_c;
                      pcVar2 = (char *)gettext("Unsupported data: URL!  Use SHOWINFO, for now.");
                      HTAlert(pcVar2);
                    }
                  }
                  else {
                    iVar4 = strncasecomp(links[curdoc.link].lname,"LYNXCOOKIE:",0xb);
                    if (((((((iVar4 == 0) ||
                            (iVar4 = strncasecomp(links[curdoc.link].lname,"LYNXDIRED:",10),
                            iVar4 == 0)) ||
                           (iVar4 = strncasecomp(links[curdoc.link].lname,"LYNXDOWNLOAD:",0xd),
                           iVar4 == 0)) ||
                          ((iVar4 = strncasecomp(links[curdoc.link].lname,"LYNXPRINT:",10),
                           iVar4 == 0 ||
                           (iVar4 = strncasecomp(links[curdoc.link].lname,"LYNXOPTIONS:",0xc),
                           iVar4 == 0)))) ||
                         ((iVar4 = strncasecomp(links[curdoc.link].lname,"LYNXHIST:",9), iVar4 == 0
                          || ((iVar4 = strncasecomp(links[curdoc.link].lname,"LYNXHIST:",9),
                              iVar4 == 0 ||
                              (iVar4 = strncasecomp(links[curdoc.link].lname,"LYNXCOMPILEOPTS:",0x10
                                                   ), iVar4 == 0)))))) ||
                        (((*links[curdoc.link].lname == 'l' || (*links[curdoc.link].lname == 'L'))
                         && (iVar4 = strncasecomp(links[curdoc.link].lname,"lynxexec:",9),
                            iVar4 == 0)))) ||
                       (((*links[curdoc.link].lname == 'l' || (*links[curdoc.link].lname == 'L')) &&
                        (iVar4 = strncasecomp(links[curdoc.link].lname,"lynxprog:",9), iVar4 == 0)))
                       ) {
                      pcVar2 = (char *)gettext("This special URL cannot be downloaded!");
                      HTUserMsg(pcVar2);
                    }
                    else {
                      iVar4 = strncasecomp(links[curdoc.link].lname,"mailto:",7);
                      if (iVar4 == 0) {
                        pcVar2 = (char *)gettext("You cannot download a mailto: link.");
                        HTUserMsg(pcVar2);
                      }
                      else if (((local_host_only == '\0') ||
                               (BVar1 = LYisLocalHost(links[curdoc.link].lname), BVar1 != '\0')) ||
                              (BVar1 = LYisLocalAlias(links[curdoc.link].lname), BVar1 != '\0')) {
                        set_address(&newdoc,links[curdoc.link].lname);
                        pcVar2 = LYGetHiliteStr(curdoc.link,L'\0');
                        HTSACopy(&newdoc.title,pcVar2);
                        wVar3 = are_different(&curdoc,&newdoc);
                        if (wVar3 != L'\0') {
                          LYFreePostData(&newdoc);
                          if (newdoc.bookmark != (char *)0x0) {
                            free(newdoc.bookmark);
                            newdoc.bookmark = (char *)0x0;
                          }
                          newdoc.isHEAD = '\0';
                          newdoc.safe = '\0';
                        }
                        newdoc.internal_link = '\0';
                        newdoc.link = (wchar_t)(user_mode == 0);
                        HTOutputFormat = HTAtom_for("www/download");
                        LYforce_no_cache = '\x01';
                      }
                      else {
                        pcVar2 = (char *)gettext(
                                                "Only files and servers on the local host can be accessed."
                                                );
                        HTUserMsg(pcVar2);
                      }
                    }
                  }
                }
                else {
                  iVar4 = atoi(links[curdoc.link].lname + 9);
                  if ((nhist <= iVar4) || (iVar4 < 0)) {
                    pcVar2 = (char *)gettext("This special URL cannot be downloaded!");
                    HTUserMsg(pcVar2);
                    return L'\0';
                  }
                  if ((history[iVar4].hdoc.post_data != (bstring_conflict *)0x0) &&
                     (history[iVar4].hdoc.safe != '\x01')) {
                    pcVar2 = (char *)gettext("Document from Form with POST content.  Resubmit?");
                    BVar1 = HTConfirm(pcVar2);
                    if (BVar1 == '\0') {
                      pcVar2 = (char *)gettext("Cancelled!!!");
                      HTInfoMsg(pcVar2);
                      return L'\0';
                    }
                  }
                  copy_address(&newdoc,&history[iVar4].hdoc);
                  pcVar2 = LYGetHiliteStr(curdoc.link,L'\0');
                  HTSACopy(&newdoc.title,pcVar2);
                  HTSACopy(&newdoc.bookmark,history[iVar4].hdoc.bookmark);
                  LYFreePostData(&newdoc);
                  if (history[iVar4].hdoc.post_data != (bstring_conflict *)0x0) {
                    if (history[iVar4].hdoc.post_data == (bstring_conflict *)0x0) {
                      local_1c = L'\0';
                    }
                    else {
                      local_1c = (history[iVar4].hdoc.post_data)->len;
                    }
                    if (history[iVar4].hdoc.post_data == (bstring_conflict *)0x0) {
                      local_18 = (char *)0x0;
                    }
                    else {
                      local_18 = (history[iVar4].hdoc.post_data)->str;
                    }
                    HTSABCopy((bstring **)&newdoc.post_data,local_18,local_1c);
                  }
                  if (history[iVar4].hdoc.post_content_type != (char *)0x0) {
                    HTSACopy(&newdoc.post_content_type,history[iVar4].hdoc.post_content_type);
                  }
                  newdoc.isHEAD = history[iVar4].hdoc.isHEAD;
                  newdoc.safe = history[iVar4].hdoc.safe;
                  newdoc.internal_link = '\0';
                  newdoc.link = (wchar_t)(user_mode == 0);
                  HTOutputFormat = HTAtom_for("www/download");
                  LYUserSpecifiedURL = '\x01';
                  LYforce_no_cache = '\x01';
                }
              }
              else {
                copy_address(&handle_LYK_DOWNLOAD::temp,&newdoc);
                set_address(&newdoc,links[curdoc.link].lname);
                iVar4 = LYdownload_options(&newdoc.address,links[curdoc.link].lname);
                if (iVar4 < 0) {
                  copy_address(&newdoc,&handle_LYK_DOWNLOAD::temp);
                }
                else {
                  newdoc.internal_link = '\0';
                }
                LYFreeDocInfo(&handle_LYK_DOWNLOAD::temp);
              }
            }
            else if (*old_c != real_c) {
              *old_c = real_c;
              pcVar2 = (char *)gettext("You cannot download an permit option.");
              HTUserMsg(pcVar2);
            }
          }
          else if (*old_c != real_c) {
            *old_c = real_c;
            pcVar2 = (char *)gettext("You cannot download an upload option.");
            HTUserMsg(pcVar2);
          }
        }
        else if (*old_c != real_c) {
          *old_c = real_c;
          pcVar2 = (char *)gettext("You cannot download a printing option.");
          HTUserMsg(pcVar2);
        }
      }
    }
    return L'\0';
  }
  return L'\x01';
}



// WARNING: Unknown calling convention

void handle_LYK_DOWN_xxx(wchar_t *old_c,wchar_t real_c,wchar_t scroll_by)

{
  char *Msg;
  wchar_t i;
  
  if (more_text == '\0') {
    if (*old_c != real_c) {
      *old_c = real_c;
      Msg = (char *)gettext("You are already at the end of this document.");
      HTInfoMsg(Msg);
    }
  }
  else {
    Newline = Newline + scroll_by;
    if (((0 < nlinks) && (L'\xffffffff' < curdoc.link)) && (scroll_by < links[curdoc.link].ly)) {
      newdoc.link = curdoc.link;
      for (i = L'\0'; links[i].ly <= scroll_by; i = i + L'\x01') {
        newdoc.link = newdoc.link + L'\xffffffff';
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

void handle_LYK_DOWN_HALF(wchar_t *old_c,wchar_t real_c)

{
  handle_LYK_DOWN_xxx(old_c,real_c,display_lines / 2);
  return;
}



// WARNING: Unknown calling convention

void handle_LYK_DOWN_LINK(wchar_t *follow_col,wchar_t *old_c,wchar_t real_c)

{
  char *pcVar1;
  size_t sVar2;
  wchar_t wVar3;
  char *text;
  wchar_t newlink;
  
  if (curdoc.link < nlinks + L'\xffffffff') {
    if (*follow_col == L'\xffffffff') {
      pcVar1 = LYGetHiliteStr(curdoc.link,L'\0');
      *follow_col = links[curdoc.link].lx;
      if (pcVar1 != (char *)0x0) {
        wVar3 = *follow_col;
        sVar2 = strlen(pcVar1);
        *follow_col = wVar3 + (sVar2 >> 1);
      }
    }
    wVar3 = find_link_near_col(*follow_col,L'\x01');
    if (wVar3 < L'\0') {
      if (more_text == '\0') {
        if (*old_c != real_c) {
          *old_c = real_c;
          pcVar1 = (char *)gettext("There are no links below this line of the document.");
          HTUserMsg(pcVar1);
        }
      }
      else {
        Newline = Newline + display_lines;
      }
    }
    else {
      set_curdoc_link(wVar3);
    }
  }
  else if (more_text == '\0') {
    if (*old_c != real_c) {
      *old_c = real_c;
      pcVar1 = (char *)gettext("You are already at the end of this document.");
      HTInfoMsg(pcVar1);
    }
  }
  else {
    Newline = Newline + display_lines;
  }
  return;
}



// WARNING: Unknown calling convention

void handle_LYK_DOWN_TWO(wchar_t *old_c,wchar_t real_c)

{
  handle_LYK_DOWN_xxx(old_c,real_c,L'\x02');
  return;
}



// WARNING: Unknown calling convention

wchar_t handle_LYK_DWIMEDIT(wchar_t *cmd,wchar_t *old_c,wchar_t real_c)

{
  char *pcVar1;
  wchar_t local_8;
  
  if (((nlinks < 1) || (links[curdoc.link].type != 1)) || ((links[curdoc.link].l_form)->type != 9))
  {
    if (((nlinks < 1) || (links[curdoc.link].type != 1)) || ((links[curdoc.link].l_form)->type != 1)
       ) {
      if (no_editor == '\0') {
        local_8 = L'\0';
      }
      else {
        if (*old_c != real_c) {
          *old_c = real_c;
          pcVar1 = (char *)gettext("External editing is currently disabled.");
          HTUserMsg(pcVar1);
        }
        local_8 = L'\x01';
      }
    }
    else {
      pcVar1 = (char *)gettext("This field cannot be (e)dited with an external editor.");
      HTUserMsg(pcVar1);
      local_8 = L'\x01';
    }
  }
  else {
    *cmd = L'V';
    local_8 = L'\x02';
  }
  return local_8;
}



// WARNING: Unknown calling convention

wchar_t handle_LYK_ECGOTO(wchar_t *ch,char *user_input_buffer,char **old_user_input,wchar_t *old_c,
                         wchar_t real_c)

{
  BOOLEAN BVar1;
  char *pcVar2;
  wchar_t wVar3;
  int iVar4;
  
  if ((no_goto == '\0') || (LYValidate != '\0')) {
    BVar1 = LYIsUIPage3(curdoc.address,UIP_DIRED_MENU,L'\x01');
    if ((BVar1 == '\0') &&
       ((BVar1 = LYIsUIPage3(curdoc.address,UIP_PERMIT_OPTIONS,L'\x01'), BVar1 == '\0' &&
        (BVar1 = LYIsUIPage3(curdoc.address,UIP_UPLOAD_OPTIONS,L'\x01'), BVar1 == '\0')))) {
      HTSACopy(old_user_input,user_input_buffer);
      LYstrncpy(user_input_buffer,curdoc.address,L'');
      if (curdoc.post_data != (bstring_conflict *)0x0) {
        pcVar2 = (char *)gettext("Current document has POST data.");
        HTAlert(pcVar2);
      }
      mustshow = '\x01';
      pcVar2 = (char *)gettext("Edit this document\'s URL: ");
      statusline(pcVar2);
      wVar3 = LYgetstr(user_input_buffer,L'\0',0x400,RECALL_URL);
      *ch = wVar3;
      if ((((L'\xffffffff' < *ch) && (*user_input_buffer != '\0')) &&
          (iVar4 = strcmp(user_input_buffer,curdoc.address), iVar4 != 0)) &&
         (LYTrimAllStartfile(user_input_buffer), *user_input_buffer != '\0')) {
        return L'\x02';
      }
      pcVar2 = (char *)gettext("Cancelled!!!");
      HTInfoMsg(pcVar2);
      LYstrncpy(user_input_buffer,*old_user_input,L'');
      if (*old_user_input != (char *)0x0) {
        free(*old_user_input);
        *old_user_input = (char *)0x0;
      }
      return L'\0';
    }
    if (*old_c != real_c) {
      *old_c = real_c;
      pcVar2 = (char *)gettext("You cannot edit File Management URLs");
      HTUserMsg(pcVar2);
    }
  }
  else if (*old_c != real_c) {
    *old_c = real_c;
    pcVar2 = (char *)gettext("Goto a random URL is disallowed!");
    HTUserMsg(pcVar2);
  }
  return L'\0';
}



// WARNING: Unknown calling convention

void handle_LYK_EDIT(wchar_t *old_c,wchar_t real_c)

{
  char *pcVar1;
  UrlTypes UVar2;
  int iVar3;
  stat dir_info;
  char *tp;
  char *cp;
  
  tp = (char *)0x0;
  if (no_editor == '\0') {
    if ((((lynx_edit_mode == '\0') || (editor == (char *)0x0)) || (*editor == '\0')) ||
       (no_dired_support != '\0')) {
      if ((editor == (char *)0x0) || (*editor == '\0')) {
        if (*old_c != real_c) {
          *old_c = real_c;
          pcVar1 = (char *)gettext("No editor is defined!");
          HTUserMsg(pcVar1);
        }
      }
      else {
        iVar3 = edit_current_file(newdoc.address,curdoc.link,Newline);
        if (iVar3 != 0) {
          HTuncache_current_document();
          LYforce_no_cache = '\x01';
          free_address(&curdoc);
          newdoc.line = curdoc.line;
          newdoc.link = curdoc.link;
          LYclear();
        }
      }
    }
    else if (0 < nlinks) {
      cp = links[curdoc.link].lname;
      UVar2 = is_url(cp);
      if (UVar2 == FILE_URL_TYPE) {
        cp = HTnameOfFile_WWW(cp,'\0','\x01');
        HTSACopy(&tp,cp);
        if (cp != (char *)0x0) {
          free(cp);
          cp = (char *)0x0;
        }
        iVar3 = stat64(tp,(stat64 *)&dir_info);
        if (iVar3 == -1) {
          pcVar1 = (char *)gettext("System error - failure to get status.");
          HTAlert(pcVar1);
        }
        else if ((dir_info.st_mode & 0xf000) == 0x8000) {
          HTSACopy(&tp,links[curdoc.link].lname);
          HTUnEscapeSome(tp,"/");
          iVar3 = edit_current_file(tp,curdoc.link,Newline);
          if (iVar3 != 0) {
            if (0 < LYAutoUncacheDirLists) {
              HTuncache_current_document();
            }
            move_address(&newdoc,&curdoc);
            newdoc.line = curdoc.line;
            newdoc.link = curdoc.link;
            LYclear();
          }
        }
        if (tp != (char *)0x0) {
          free(tp);
        }
      }
    }
  }
  else if (*old_c != real_c) {
    *old_c = real_c;
    pcVar1 = (char *)gettext("The \'e\'dit command is currently disabled.");
    HTUserMsg(pcVar1);
  }
  return;
}



// WARNING: Unknown calling convention

void handle_LYK_DWIMHELP(char **cshelpfile)

{
  char *pcVar1;
  
  if (((((L'\xffffffff' < curdoc.link) && (curdoc.link < nlinks)) && (links[curdoc.link].type == 1))
      && ((links[curdoc.link].l_form)->disabled == 0)) &&
     ((((links[curdoc.link].l_form)->type == 1 || ((links[curdoc.link].l_form)->type == 0xc)) ||
      (((links[curdoc.link].l_form)->type == 2 ||
       (((links[curdoc.link].l_form)->type == 0xb || ((links[curdoc.link].l_form)->type == 9))))))))
  {
    pcVar1 = LYLineeditHelpURL();
    *cshelpfile = pcVar1;
  }
  return;
}



// WARNING: Unknown calling convention

void handle_LYK_EDIT_TEXTAREA(BOOLEAN *refresh_screen,wchar_t *old_c,wchar_t real_c)

{
  char *pcVar1;
  wchar_t n;
  
  if (no_editor == '\0') {
    if ((editor == (char *)0x0) || (*editor == '\0')) {
      if (*old_c != real_c) {
        *old_c = real_c;
        pcVar1 = (char *)gettext("No editor is defined!");
        HTUserMsg(pcVar1);
      }
    }
    else if ((links[curdoc.link].type == 1) && ((links[curdoc.link].l_form)->type == 9)) {
      stop_curses();
      HText_ExtEditForm((LinkInfo_conflict *)(links + curdoc.link));
      start_curses();
      *refresh_screen = '\x01';
    }
    else {
      pcVar1 = (char *)gettext("Not in a TEXTAREA; cannot use external editor.");
      HTInfoMsg(pcVar1);
    }
  }
  else if (*old_c != real_c) {
    *old_c = real_c;
    pcVar1 = (char *)gettext("External editing is currently disabled.");
    HTUserMsg(pcVar1);
  }
  return;
}



// WARNING: Unknown calling convention

wchar_t handle_LYK_ELGOTO(wchar_t *ch,char *user_input_buffer,char **old_user_input,wchar_t *old_c,
                         wchar_t real_c)

{
  BOOLEAN BVar1;
  char *pcVar2;
  int iVar3;
  wchar_t wVar4;
  char *local_c;
  char *local_8;
  
  if ((no_goto == '\0') || (LYValidate != '\0')) {
    if (((nlinks < 1) || (curdoc.link < L'\0')) ||
       ((((links[curdoc.link].type == 1 && ((links[curdoc.link].l_form)->type != 5)) &&
         ((links[curdoc.link].l_form)->type != 0xd)) && ((links[curdoc.link].l_form)->type != 0xc)))
       ) {
      if (*old_c != real_c) {
        *old_c = real_c;
        pcVar2 = (char *)gettext("You are not on a form submission button or normal link.");
        HTUserMsg(pcVar2);
      }
    }
    else if ((links[curdoc.link].type == 1) &&
            (((links[curdoc.link].l_form)->submit_action == (char *)0x0 ||
             (*(links[curdoc.link].l_form)->submit_action == '\0')))) {
      if (*old_c != real_c) {
        *old_c = real_c;
        pcVar2 = (char *)gettext("** Bad HTML!!  No form action defined. **");
        HTUserMsg(pcVar2);
      }
    }
    else {
      iVar3 = strncasecomp(links[curdoc.link].lname,"LYNXDIRED:",10);
      if ((iVar3 != 0) &&
         (((BVar1 = LYIsUIPage3(curdoc.address,UIP_DIRED_MENU,L'\x01'), BVar1 == '\0' &&
           (BVar1 = LYIsUIPage3(curdoc.address,UIP_PERMIT_OPTIONS,L'\x01'), BVar1 == '\0')) &&
          (BVar1 = LYIsUIPage3(curdoc.address,UIP_UPLOAD_OPTIONS,L'\x01'), BVar1 == '\0')))) {
        HTSACopy(old_user_input,user_input_buffer);
        if (links[curdoc.link].type == 1) {
          local_c = (links[curdoc.link].l_form)->submit_action;
        }
        else {
          local_c = links[curdoc.link].lname;
        }
        LYstrncpy(user_input_buffer,local_c,L'');
        mustshow = '\x01';
        pcVar2 = (char *)gettext("Edit the current link\'s URL: ");
        statusline(pcVar2);
        wVar4 = LYgetstr(user_input_buffer,L'\0',0x400,RECALL_URL);
        *ch = wVar4;
        if ((L'\xffffffff' < *ch) && (*user_input_buffer != '\0')) {
          if (links[curdoc.link].type == 1) {
            local_8 = (links[curdoc.link].l_form)->submit_action;
          }
          else {
            local_8 = links[curdoc.link].lname;
          }
          iVar3 = strcmp(user_input_buffer,local_8);
          if ((iVar3 != 0) && (LYTrimAllStartfile(user_input_buffer), *user_input_buffer != '\0')) {
            return L'\x02';
          }
        }
        pcVar2 = (char *)gettext("Cancelled!!!");
        HTInfoMsg(pcVar2);
        LYstrncpy(user_input_buffer,*old_user_input,L'');
        if (*old_user_input != (char *)0x0) {
          free(*old_user_input);
          *old_user_input = (char *)0x0;
        }
        return L'\0';
      }
      if (*old_c != real_c) {
        *old_c = real_c;
        pcVar2 = (char *)gettext("You cannot edit File Management URLs");
        HTUserMsg(pcVar2);
      }
    }
  }
  else if (*old_c != real_c) {
    *old_c = real_c;
    pcVar2 = (char *)gettext("Goto a random URL is disallowed!");
    HTUserMsg(pcVar2);
  }
  return L'\0';
}



// WARNING: Unknown calling convention

void handle_LYK_EXTERN_LINK(BOOLEAN *refresh_screen)

{
  if ((0 < nlinks) && (links[curdoc.link].lname != (char *)0x0)) {
    run_external(links[curdoc.link].lname,'\0');
    *refresh_screen = '\x01';
  }
  return;
}



// WARNING: Unknown calling convention

void handle_LYK_EXTERN_PAGE(BOOLEAN *refresh_screen)

{
  if (curdoc.address != (char *)0x0) {
    run_external(curdoc.address,'\0');
    *refresh_screen = '\x01';
  }
  return;
}



// WARNING: Unknown calling convention

BOOLEAN handle_LYK_FASTBACKW_LINK(wchar_t *cmd,wchar_t *old_c,wchar_t real_c)

{
  int iVar1;
  bool bVar2;
  wchar_t wVar3;
  char *pcVar4;
  char *thisname_1;
  wchar_t thisgroup_1;
  char *thisname;
  wchar_t thisgroup;
  wchar_t code;
  wchar_t res;
  wchar_t nextlink;
  wchar_t samepage;
  
  bVar2 = false;
  nextlink = curdoc.link;
  if (1 < nlinks) {
    if ((links[curdoc.link].type == 1) && ((links[curdoc.link].l_form)->type == 9)) {
      iVar1 = (links[curdoc.link].l_form)->number;
      pcVar4 = (links[curdoc.link].l_form)->name;
      if ((curdoc.link < L'\x01') ||
         ((((links[0].type == 1 && ((links[0].l_form)->type == 9)) &&
           ((links[0].l_form)->number == iVar1)) &&
          (wVar3 = sametext((links[0].l_form)->name,pcVar4), wVar3 != L'\0')))) {
        if ((((((more_text == '\0') && (Newline == L'\x01')) && (links[0].type == 1)) &&
             (((links[0].l_form)->type == 9 && ((links[0].l_form)->number == iVar1)))) &&
            (wVar3 = sametext((links[0].l_form)->name,pcVar4), wVar3 != L'\0')) &&
           ((((links[nlinks + -1].type != 1 || ((links[nlinks + -1].l_form)->type != 9)) ||
             ((links[nlinks + -1].l_form)->number != iVar1)) ||
            (wVar3 = sametext((links[nlinks + -1].l_form)->name,pcVar4), wVar3 == L'\0')))) {
          nextlink = nlinks + L'\xffffffff';
          bVar2 = true;
        }
        else if (((more_text == '\0') && (Newline == L'\x01')) && (L'\0' < curdoc.link)) {
          nextlink = L'\0';
          bVar2 = true;
        }
      }
      else {
        while ((nextlink = nextlink + L'\xffffffff', links[nextlink].type == 1 &&
               ((links[nextlink].l_form)->type == 9))) {
          if (((links[nextlink].l_form)->number != iVar1) ||
             (wVar3 = sametext((links[nextlink].l_form)->name,pcVar4), wVar3 == L'\0')) break;
        }
        bVar2 = true;
      }
    }
    else if (curdoc.link < L'\x01') {
      if ((more_text == '\0') && (Newline == L'\x01')) {
        nextlink = nlinks + L'\xffffffff';
        bVar2 = true;
      }
    }
    else {
      nextlink = curdoc.link + L'\xffffffff';
      bVar2 = true;
    }
  }
  if (bVar2) {
    if (((L'\0' < nextlink) && (links[nextlink].type == 1)) && ((links[nextlink].l_form)->type == 9)
       ) {
      iVar1 = (links[nextlink].l_form)->number;
      pcVar4 = (links[nextlink].l_form)->name;
      if (((links[0].type == 1) && ((links[0].l_form)->type == 9)) &&
         (((links[0].l_form)->number == iVar1 &&
          (wVar3 = sametext((links[0].l_form)->name,pcVar4), wVar3 != L'\0')))) {
        nextlink = L'\0';
      }
      else {
        while (((L'\x01' < nextlink && (links[nextlink + L'\xffffffff'].type == 1)) &&
               (((links[nextlink + L'\xffffffff'].l_form)->type == 9 &&
                (((links[nextlink + L'\xffffffff'].l_form)->number == iVar1 &&
                 (wVar3 = sametext((links[nextlink + L'\xffffffff'].l_form)->name,pcVar4),
                 wVar3 != L'\0'))))))) {
          nextlink = nextlink + L'\xffffffff';
        }
      }
    }
    set_curdoc_link(nextlink);
    return '\0';
  }
  if ((L'\x01' < Newline) &&
     (wVar3 = HTGetLinkOrFieldStart(curdoc.link,&Newline,&newdoc.link,L'\xffffffff','\x01'),
     wVar3 != L'\0')) {
    if (wVar3 == L'\x10') {
      if (0 < nlinks) {
        curdoc.link = L'\0';
      }
      *cmd = L'\x1a';
      return '\x01';
    }
    Newline = Newline + L'\x01';
    return '\0';
  }
  if (*old_c == real_c) {
    return '\0';
  }
  *old_c = real_c;
  pcVar4 = (char *)gettext("There are no links above this line of the document.");
  HTInfoMsg(pcVar4);
  return '\0';
}



// WARNING: Unknown calling convention

void handle_LYK_FASTFORW_LINK(wchar_t *old_c,wchar_t real_c)

{
  int iVar1;
  bool bVar2;
  wchar_t wVar3;
  char *pcVar4;
  char *thisname;
  wchar_t thisgroup;
  wchar_t nextlink;
  wchar_t samepage;
  
  bVar2 = false;
  nextlink = curdoc.link;
  if (1 < nlinks) {
    if ((links[curdoc.link].type == 1) && ((links[curdoc.link].l_form)->type == 9)) {
      iVar1 = (links[curdoc.link].l_form)->number;
      pcVar4 = (links[curdoc.link].l_form)->name;
      if ((curdoc.link < nlinks + L'\xffffffff') &&
         (((links[nlinks + -1].type != 1 || ((links[nlinks + -1].l_form)->type != 9)) ||
          (((links[nlinks + -1].l_form)->number != iVar1 ||
           (wVar3 = sametext((links[nlinks + -1].l_form)->name,pcVar4), wVar3 == L'\0')))))) {
        do {
          nextlink = nextlink + L'\x01';
          if (((links[nextlink].type != 1) || ((links[nextlink].l_form)->type != 9)) ||
             ((links[nextlink].l_form)->number != iVar1)) break;
          wVar3 = sametext((links[nextlink].l_form)->name,pcVar4);
        } while (wVar3 != L'\0');
        bVar2 = true;
      }
      else if (((more_text == '\0') && (Newline == L'\x01')) && (L'\0' < curdoc.link)) {
        nextlink = L'\0';
        bVar2 = true;
      }
    }
    else if (curdoc.link < nlinks + L'\xffffffff') {
      nextlink = curdoc.link + L'\x01';
      bVar2 = true;
    }
    else if (((more_text == '\0') && (Newline == L'\x01')) && (L'\0' < curdoc.link)) {
      nextlink = L'\0';
      bVar2 = true;
    }
  }
  if (bVar2) {
    set_curdoc_link(nextlink);
  }
  else if (((more_text == '\0') && (Newline == L'\x01')) && (curdoc.link == nlinks + L'\xffffffff'))
  {
    set_curdoc_link(L'\0');
  }
  else {
    if ((more_text != '\0') &&
       (wVar3 = HTGetLinkOrFieldStart(curdoc.link,&Newline,&newdoc.link,L'\x01','\x01'),
       wVar3 != L'\0')) {
      Newline = Newline + L'\x01';
      return;
    }
    if (*old_c != real_c) {
      *old_c = real_c;
      pcVar4 = (char *)gettext("There are no links below this line of the document.");
      HTInfoMsg(pcVar4);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void handle_LYK_FIRST_LINK(void)

{
  wchar_t wVar1;
  wchar_t i;
  
  i = curdoc.link;
  wVar1 = i;
  do {
    i = wVar1;
    wVar1 = i + L'\xffffffff';
    if (wVar1 < L'\0') break;
  } while (links[wVar1].ly == links[curdoc.link].ly);
  set_curdoc_link(i);
  return;
}



// WARNING: Unknown calling convention

BOOLEAN handle_LYK_GOTO(wchar_t *ch,char *user_input_buffer,char **old_user_input,RecallType *recall
                       ,wchar_t *URLTotal,wchar_t *URLNum,BOOLEAN *FirstURLRecall,wchar_t *old_c,
                       wchar_t real_c)

{
  char *pcVar1;
  wchar_t wVar2;
  BOOLEAN local_9;
  wchar_t local_8;
  
  if ((no_goto == '\0') || (LYValidate != '\0')) {
    HTSACopy(old_user_input,user_input_buffer);
    if (goto_buffer == '\0') {
      *user_input_buffer = '\0';
    }
    if (Goto_URLs == (HTList *)0x0) {
      local_8 = L'\0';
    }
    else {
      local_8 = HTList_count(Goto_URLs);
    }
    *URLTotal = local_8;
    if ((goto_buffer == '\0') || (*user_input_buffer == '\0')) {
      *recall = (uint)(L'\0' < *URLTotal);
      *URLNum = *URLTotal;
      *FirstURLRecall = '\x01';
    }
    else {
      *recall = (uint)(L'\x01' < *URLTotal);
      *URLNum = L'\0';
      *FirstURLRecall = '\0';
    }
    mustshow = '\x01';
    pcVar1 = (char *)gettext("URL to open: ");
    statusline(pcVar1);
    wVar2 = LYgetstr(user_input_buffer,L'\0',0x400,*recall);
    *ch = wVar2;
    if (*ch < L'\0') {
      LYstrncpy(user_input_buffer,*old_user_input,L'');
      if (*old_user_input != (char *)0x0) {
        free(*old_user_input);
        *old_user_input = (char *)0x0;
      }
      pcVar1 = (char *)gettext("Cancelled!!!");
      HTInfoMsg(pcVar1);
      local_9 = '\0';
    }
    else {
      local_9 = '\x01';
    }
  }
  else {
    if (*old_c != real_c) {
      *old_c = real_c;
      pcVar1 = (char *)gettext("Goto a random URL is disallowed!");
      HTUserMsg(pcVar1);
    }
    local_9 = '\0';
  }
  return local_9;
}



// WARNING: Unknown calling convention

void handle_LYK_GROW_TEXTAREA(BOOLEAN *refresh_screen)

{
  char *Msg;
  
  if ((links[curdoc.link].type == 1) && ((links[curdoc.link].l_form)->type == 9)) {
    HText_ExpandTextarea((LinkInfo_conflict *)(links + curdoc.link),L'\x05');
    *refresh_screen = '\x01';
  }
  else {
    Msg = (char *)gettext("Not in a TEXTAREA; cannot use command.");
    HTInfoMsg(Msg);
  }
  return;
}



// WARNING: Unknown calling convention

BOOLEAN handle_LYK_HEAD(wchar_t *cmd)

{
  BOOLEAN BVar1;
  char *pcVar2;
  wchar_t wVar3;
  int iVar4;
  char *local_20;
  char *local_18;
  char *scheme_1;
  char *scheme;
  wchar_t c;
  
  if ((nlinks < 1) ||
     ((((links[curdoc.link].type == 1 && ((links[curdoc.link].l_form)->type != 5)) &&
       ((links[curdoc.link].l_form)->type != 0xd)) && ((links[curdoc.link].l_form)->type != 0xc))))
  {
    if ((curdoc.post_data != (bstring_conflict *)0x0) && (curdoc.safe != '\x01')) {
      pcVar2 = (char *)gettext("Document from POST action, HEAD may not be understood.  Proceed?");
      BVar1 = HTConfirm(pcVar2);
      if (BVar1 == '\0') {
        pcVar2 = (char *)gettext("Cancelled!!!");
        HTInfoMsg(pcVar2);
        return '\0';
      }
    }
    if (nlinks < 1) {
      c = L'D';
    }
    else {
      mustshow = '\x01';
      pcVar2 = (char *)gettext("Send HEAD request for D)ocument, or C)ancel? (d,c): ");
      statusline(pcVar2);
      c = LYgetch_single();
    }
    if (c == L'D') {
      iVar4 = strncasecomp(curdoc.address,"LYNXIMGMAP:",0xb);
      if (iVar4 == 0) {
        local_18 = curdoc.address + 0xb;
      }
      else {
        local_18 = curdoc.address;
      }
      BVar1 = LYCanDoHEAD(local_18);
      if (BVar1 == '\x01') {
        HEAD_request = '\x01';
        LYforce_no_cache = '\x01';
        HTSACopy(&newdoc.title,curdoc.title);
        BVar1 = HTLoadedDocumentIsHEAD();
        if (BVar1 == '\0') {
          HTSACat(&newdoc.title," - HEAD");
        }
        else {
          HText_setNoCache(HTMainText);
          free_address(&curdoc);
        }
      }
      else {
        pcVar2 = (char *)gettext("Sorry, the document is not an http URL.");
        HTUserMsg(pcVar2);
      }
    }
  }
  else {
    mustshow = '\x01';
    pcVar2 = (char *)gettext("Send HEAD request for D)ocument or L)ink, or C)ancel? (d,l,c): ");
    statusline(pcVar2);
    wVar3 = LYgetch_single();
    if (wVar3 == L'D') {
      iVar4 = strncasecomp(curdoc.address,"LYNXIMGMAP:",0xb);
      if (iVar4 == 0) {
        local_20 = curdoc.address + 0xb;
      }
      else {
        local_20 = curdoc.address;
      }
      BVar1 = LYCanDoHEAD(local_20);
      if (BVar1 == '\x01') {
        if ((curdoc.post_data != (bstring_conflict *)0x0) && (curdoc.safe != '\x01')) {
          pcVar2 = (char *)gettext(
                                  "Document from POST action, HEAD may not be understood.  Proceed?"
                                  );
          BVar1 = HTConfirm(pcVar2);
          if (BVar1 == '\0') {
            pcVar2 = (char *)gettext("Cancelled!!!");
            HTInfoMsg(pcVar2);
            return '\0';
          }
        }
        HEAD_request = '\x01';
        LYforce_no_cache = '\x01';
        HTSACopy(&newdoc.title,curdoc.title);
        BVar1 = HTLoadedDocumentIsHEAD();
        if (BVar1 == '\0') {
          HTSACat(&newdoc.title," - HEAD");
        }
        else {
          HText_setNoCache(HTMainText);
          free_address(&curdoc);
        }
      }
      else {
        pcVar2 = (char *)gettext("Sorry, the document is not an http URL.");
        HTUserMsg(pcVar2);
      }
    }
    else if (wVar3 == L'L') {
      if ((((links[curdoc.link].type == 1) ||
           (iVar4 = strncmp(links[curdoc.link].lname,"http",4), iVar4 == 0)) ||
          ((iVar4 = strncmp(links[curdoc.link].lname,"LYNXIMGMAP:http",0xf), iVar4 == 0 ||
           (BVar1 = LYCanDoHEAD(links[curdoc.link].lname), BVar1 == '\x01')))) ||
         (((links[curdoc.link].type == 6 && (curdoc.address != (char *)0x0)) &&
          (iVar4 = strncmp(curdoc.address,"http",4), iVar4 == 0)))) {
        if ((links[curdoc.link].type == 1) && ((links[curdoc.link].l_form)->disabled != 0)) {
          pcVar2 = (char *)gettext("Sorry, the ACTION for this form is disabled.");
          HTUserMsg(pcVar2);
        }
        else {
          if (((links[curdoc.link].type != 1) ||
              ((links[curdoc.link].l_form)->submit_action == (char *)0x0)) ||
             ((((*(links[curdoc.link].l_form)->submit_action == 'l' ||
                (*(links[curdoc.link].l_form)->submit_action == 'L')) &&
               (iVar4 = strncasecomp((links[curdoc.link].l_form)->submit_action,"lynxcgi:",8),
               iVar4 == 0)) ||
              (iVar4 = strncmp((links[curdoc.link].l_form)->submit_action,"http",4), iVar4 == 0))))
          {
            if ((links[curdoc.link].type == 1) && ((links[curdoc.link].l_form)->submit_method == 2))
            {
              pcVar2 = (char *)gettext(
                                      "Form submit action is POST, HEAD may not be understood.  Proceed?"
                                      );
              BVar1 = HTConfirm(pcVar2);
              if (BVar1 == '\0') {
                pcVar2 = (char *)gettext("Cancelled!!!");
                HTInfoMsg(pcVar2);
                return '\0';
              }
            }
            HEAD_request = '\x01';
            LYforce_no_cache = '\x01';
            *cmd = L'\'';
            return '\x01';
          }
          pcVar2 = (char *)gettext("Sorry, the ACTION for this form is not an http URL.");
          HTUserMsg(pcVar2);
        }
      }
      else {
        pcVar2 = (char *)gettext("Sorry, the link is not an http URL.");
        HTUserMsg(pcVar2);
      }
    }
  }
  return '\0';
}



// WARNING: Unknown calling convention

void handle_LYK_HELP(char **cshelpfile)

{
  int iVar1;
  char *src;
  char *my_value;
  
  my_value = (char *)0x0;
  if (*cshelpfile == (char *)0x0) {
    *cshelpfile = helpfile;
  }
  HTSACopy(&my_value,*cshelpfile);
  LYEnsureAbsoluteURL(&my_value,*cshelpfile,L'\0');
  iVar1 = strcmp(curdoc.address,my_value);
  if (iVar1 != 0) {
    set_address(&newdoc,my_value);
    src = (char *)gettext("Help Screen");
    HTSACopy(&newdoc.title,src);
    LYFreePostData(&newdoc);
    if (newdoc.bookmark != (char *)0x0) {
      free(newdoc.bookmark);
      newdoc.bookmark = (char *)0x0;
    }
    newdoc.isHEAD = '\0';
    newdoc.safe = '\0';
    newdoc.internal_link = '\0';
  }
  if (my_value != (char *)0x0) {
    free(my_value);
  }
  *cshelpfile = (char *)0x0;
  return;
}



// WARNING: Unknown calling convention

void handle_LYK_HISTORICAL(void)

{
  BOOLEAN BVar1;
  char *Msg;
  char *local_c;
  char *local_8;
  
  BVar1 = HTcan_reparse_document();
  if (BVar1 == '\0') {
    if ((curdoc.post_data != (bstring_conflict *)0x0) && (curdoc.safe != '\x01')) {
      BVar1 = confirm_post_resub(curdoc.address,(char *)0x0,L'\0',L'\0');
      if (BVar1 == '\0') {
        Msg = (char *)gettext("Document will not be reloaded!");
        HTInfoMsg(Msg);
        goto LAB_08082457;
      }
    }
    HText_setNoCache(HTMainText);
    move_address(&newdoc,&curdoc);
    newdoc.line = curdoc.line;
    newdoc.link = curdoc.link;
  }
LAB_08082457:
  historical_comments = historical_comments == '\0';
  if (minimal_comments == '\0') {
    if ((bool)historical_comments) {
      local_8 = (char *)gettext("Historical comment parsing ON (Valid is overridden)!");
    }
    else {
      local_8 = (char *)gettext("Historical comment parsing OFF (Valid is in effect)!");
    }
    HTAlert(local_8);
  }
  else {
    if ((bool)historical_comments) {
      local_c = (char *)gettext("Historical comment parsing ON (Minimal is overridden)!");
    }
    else {
      local_c = (char *)gettext("Historical comment parsing OFF (Minimal is in effect)!");
    }
    HTAlert(local_c);
  }
  reparse_document();
  return;
}



BOOLEAN handle_LYK_HISTORY(BOOLEAN ForcePush)

{
  BOOLEAN BVar1;
  int iVar2;
  char *src;
  BOOLEAN ForcePush_local;
  
  if ((curdoc.title == (char *)0x0) ||
     (BVar1 = LYIsUIPage3(curdoc.address,UIP_HISTORY,L'\x01'), BVar1 != '\0')) {
    return '\0';
  }
  if ((WWW_TraceFlag != '\0') && ((LYUseTraceLog == '\0' && (LYCursesON != '\0')))) {
    LYmove(LYlines + L'\xffffffff',(LYcols - (uint)(LYShowScrollbar != '\0')) + L'\xffffffff');
    LYrefresh();
  }
  LYpush(&curdoc,ForcePush);
  iVar2 = showhistory(&newdoc.address);
  if (iVar2 < 0) {
    LYpop(&curdoc);
    return '\x01';
  }
  LYRegisterUIPage(newdoc.address,UIP_HISTORY);
  src = (char *)gettext("History Page");
  HTSACopy(&newdoc.title,src);
  LYFreePostData(&newdoc);
  if (newdoc.bookmark != (char *)0x0) {
    free(newdoc.bookmark);
    newdoc.bookmark = (char *)0x0;
  }
  newdoc.isHEAD = '\0';
  newdoc.safe = '\0';
  newdoc.internal_link = '\0';
  newdoc.link = L'\x01';
  free_address(&curdoc);
  if ((LYValidate != '\0') || (check_realm != '\0')) {
    LYPermitURL = '\x01';
  }
  return '\x01';
}



// WARNING: Unknown calling convention

BOOLEAN handle_LYK_IMAGE_TOGGLE(wchar_t *cmd)

{
  BOOLEAN BVar1;
  char *local_8;
  
  clickable_images = clickable_images == '\0';
  if ((bool)clickable_images) {
    local_8 = (char *)gettext("Links will be included for all images!  Reloading...");
  }
  else {
    local_8 = (char *)gettext("Standard image handling restored!  Reloading...");
  }
  HTUserMsg(local_8);
  BVar1 = reparse_or_reload(cmd);
  return BVar1;
}



// WARNING: Unknown calling convention

void handle_LYK_INDEX(wchar_t *old_c,wchar_t real_c)

{
  int iVar1;
  char *pcVar2;
  
  iVar1 = strcmp(curdoc.address,indexfile);
  if (iVar1 != 0) {
    if (*indexfile == '\0') {
      if (*old_c != real_c) {
        *old_c = real_c;
        pcVar2 = (char *)gettext("No index is currently available.");
        HTUserMsg(pcVar2);
      }
    }
    else {
      set_address(&newdoc,indexfile);
      pcVar2 = (char *)gettext("System Index");
      HTSACopy(&newdoc.title,pcVar2);
      LYFreePostData(&newdoc);
      if (newdoc.bookmark != (char *)0x0) {
        free(newdoc.bookmark);
        newdoc.bookmark = (char *)0x0;
      }
      newdoc.isHEAD = '\0';
      newdoc.safe = '\0';
      newdoc.internal_link = '\0';
    }
  }
  return;
}



void handle_LYK_INDEX_SEARCH(BOOLEAN *force_load,BOOLEAN ForcePush,wchar_t *old_c,wchar_t real_c)

{
  wchar_t wVar1;
  char *Msg2;
  char *pcVar2;
  wchar_t local_1c;
  char *local_18;
  wchar_t local_14;
  char *local_10;
  BOOLEAN ForcePush_local;
  
  if (is_www_index == '\0') {
    if (*old_c != real_c) {
      *old_c = real_c;
      pcVar2 = (char *)gettext(
                              "Not a searchable indexed document -- press \'/\' to search for a text string"
                              );
      HTUserMsg(pcVar2);
    }
  }
  else {
    newdoc.isHEAD = '\0';
    newdoc.safe = '\0';
    wVar1 = do_www_search(&newdoc);
    pcVar2 = use_this_url_instead;
    if (wVar1 == L'\x01') {
      if (((WWW_TraceFlag != '\0') && (LYUseTraceLog == '\0')) && (LYCursesON != '\0')) {
        LYmove(LYlines + L'\xffffffff',(LYcols - (uint)(LYShowScrollbar != '\0')) + L'\xffffffff');
        LYrefresh();
      }
      LYpush(&curdoc,ForcePush);
      copy_address(&curdoc,&newdoc);
      if (curdoc.post_data == (bstring_conflict *)0x0) {
        local_1c = L'\0';
        local_18 = (char *)0x0;
      }
      else {
        local_1c = (curdoc.post_data)->len;
        local_18 = (curdoc.post_data)->str;
      }
      HTSABCopy((bstring **)&newdoc.post_data,local_18,local_1c);
      HTSACopy(&newdoc.post_content_type,curdoc.post_content_type);
      newdoc.internal_link = '\0';
      curdoc.line = L'\xffffffff';
      Newline = L'\0';
    }
    else if (use_this_url_instead == (char *)0x0) {
      copy_address(&newdoc,&curdoc);
      if (curdoc.post_data == (bstring_conflict *)0x0) {
        local_14 = L'\0';
        local_10 = (char *)0x0;
      }
      else {
        local_14 = (curdoc.post_data)->len;
        local_10 = (curdoc.post_data)->str;
      }
      HTSABCopy((bstring **)&newdoc.post_data,local_10,local_14);
      HTSACopy(&newdoc.post_content_type,curdoc.post_content_type);
      HTSACopy(&newdoc.bookmark,curdoc.bookmark);
      newdoc.isHEAD = curdoc.isHEAD;
      newdoc.safe = curdoc.safe;
      newdoc.internal_link = curdoc.internal_link;
    }
    else {
      Msg2 = (char *)gettext("Using %s");
      HTUserMsg2(Msg2,pcVar2);
      HTSACopy(&newdoc.title,"A URL specified by redirection");
      set_address(&newdoc,use_this_url_instead);
      LYFreePostData(&newdoc);
      if (newdoc.bookmark != (char *)0x0) {
        free(newdoc.bookmark);
        newdoc.bookmark = (char *)0x0;
      }
      newdoc.isHEAD = '\0';
      newdoc.safe = '\0';
      newdoc.internal_link = '\0';
      if (use_this_url_instead != (char *)0x0) {
        free(use_this_url_instead);
        use_this_url_instead = (char *)0x0;
      }
      *force_load = '\x01';
    }
  }
  return;
}



// WARNING: Unknown calling convention

BOOLEAN handle_LYK_INFO(wchar_t *cmd)

{
  BOOLEAN BVar1;
  wchar_t wVar2;
  int iVar3;
  char *src;
  BOOLEAN local_5;
  
  BVar1 = LYIsUIPage3(curdoc.address,UIP_SHOWINFO,L'\x01');
  if (BVar1 == '\0') {
    wVar2 = do_change_link();
    if (wVar2 != L'\xffffffff') {
      iVar3 = LYShowInfo(&curdoc,&newdoc,owner_address);
      if (-1 < iVar3) {
        LYRegisterUIPage(newdoc.address,UIP_SHOWINFO);
        src = (char *)gettext("Information about the current document");
        HTSACopy(&newdoc.title,src);
        LYFreePostData(&newdoc);
        if (newdoc.bookmark != (char *)0x0) {
          free(newdoc.bookmark);
          newdoc.bookmark = (char *)0x0;
        }
        newdoc.isHEAD = '\0';
        newdoc.safe = '\0';
        newdoc.internal_link = '\0';
        LYforce_no_cache = '\x01';
        if ((LYValidate != '\0') || (check_realm != '\0')) {
          LYPermitURL = '\x01';
        }
      }
    }
    local_5 = '\0';
  }
  else {
    *cmd = L'%';
    local_5 = '\x01';
  }
  return local_5;
}



// WARNING: Unknown calling convention

BOOLEAN handle_LYK_INLINE_TOGGLE(wchar_t *cmd)

{
  BOOLEAN BVar1;
  char *local_8;
  
  pseudo_inline_alts = pseudo_inline_alts == '\0';
  if ((bool)pseudo_inline_alts) {
    local_8 = (char *)gettext(
                             "Pseudo_ALTs will be inserted for inlines without ALT strings!  Reloading..."
                             );
  }
  else {
    local_8 = (char *)gettext(
                             "Inlines without an ALT string specified will be ignored!  Reloading..."
                             );
  }
  HTUserMsg(local_8);
  BVar1 = reparse_or_reload(cmd);
  return BVar1;
}



// WARNING: Unknown calling convention

void handle_LYK_INSERT_FILE(BOOLEAN *refresh_screen,wchar_t *old_c,wchar_t real_c)

{
  char *pcVar1;
  wchar_t n;
  
  if ((links[curdoc.link].type == 1) && ((links[curdoc.link].l_form)->type == 9)) {
    if ((((no_file_url == '\0') && (no_goto_file == '\0')) && (HTDirAccess != 0)) &&
       (HTDirAccess != 1)) {
      HText_InsertFile((LinkInfo_conflict *)(links + curdoc.link));
      *refresh_screen = '\x01';
    }
    else if (*old_c != real_c) {
      *old_c = real_c;
      if (no_goto_file == '\0') {
        pcVar1 = (char *)gettext("Access to local files denied.");
        HTUserMsg(pcVar1);
      }
      else {
        pcVar1 = (char *)gettext("You are not allowed to goto \"%s\" URLs");
        HTUserMsg2(pcVar1,"file:");
      }
      pcVar1 = (char *)gettext("File insert cancelled!!!");
      HTInfoMsg(pcVar1);
    }
  }
  else {
    pcVar1 = (char *)gettext("Not in a TEXTAREA; cannot use command.");
    HTInfoMsg(pcVar1);
  }
  return;
}



// WARNING: Unknown calling convention

BOOLEAN handle_LYK_JUMP(wchar_t c,char *user_input_buffer,char **old_user_input,RecallType *recall,
                       BOOLEAN *FirstURLRecall,wchar_t *URLNum,wchar_t *URLTotal,wchar_t *ch,
                       wchar_t *old_c,wchar_t real_c)

{
  BOOLEAN BVar1;
  char *pcVar2;
  char *ret;
  
  if ((no_jump == '\0') && (JThead != (JumpTable_conflict *)0x0)) {
    LYJumpFileURL = '\x01';
    pcVar2 = LYJump(c);
    if (pcVar2 == (char *)0x0) {
      LYJumpFileURL = '\0';
    }
    else {
      pcVar2 = HTParse(pcVar2,startfile,0x1f);
      BVar1 = LYTrimStartfile(pcVar2);
      if (BVar1 == '\0') {
        LYRemoveBlanks(user_input_buffer);
      }
      set_address(&newdoc,pcVar2);
      HTSACopy(&lynxjumpfile,pcVar2);
      LYFreePostData(&newdoc);
      if (newdoc.bookmark != (char *)0x0) {
        free(newdoc.bookmark);
        newdoc.bookmark = (char *)0x0;
      }
      newdoc.isHEAD = '\0';
      newdoc.safe = '\0';
      newdoc.internal_link = '\0';
      if (pcVar2 != (char *)0x0) {
        free(pcVar2);
      }
      LYUserSpecifiedURL = '\x01';
    }
  }
  else if (*old_c != real_c) {
    *old_c = real_c;
    if (no_jump == '\0') {
      pcVar2 = (char *)gettext("No jump file is currently available.");
      HTUserMsg(pcVar2);
    }
    else {
      pcVar2 = (char *)gettext("Jumping to a shortcut URL is disallowed!");
      HTUserMsg(pcVar2);
    }
  }
  return '\0';
}



// WARNING: Unknown calling convention

void handle_LYK_KEYMAP(BOOLEAN *vi_keys_flag,BOOLEAN *emacs_keys_flag,wchar_t *old_c,wchar_t real_c)

{
  char *src;
  
  if (*old_c != real_c) {
    *old_c = real_c;
    set_address(&newdoc,"LYNXKEYMAP:");
    src = (char *)gettext("Current Key Map");
    HTSACopy(&newdoc.title,src);
    LYFreePostData(&newdoc);
    if (newdoc.bookmark != (char *)0x0) {
      free(newdoc.bookmark);
      newdoc.bookmark = (char *)0x0;
    }
    newdoc.isHEAD = '\0';
    newdoc.safe = '\0';
    newdoc.internal_link = '\0';
    if ((*vi_keys_flag != vi_keys) || (*emacs_keys_flag != emacs_keys)) {
      *vi_keys_flag = vi_keys;
      *emacs_keys_flag = emacs_keys;
    }
    if (no_dired_support == '\0') {
      prev_lynx_edit_mode = lynx_edit_mode;
    }
    LYforce_no_cache = '\x01';
  }
  return;
}



// WARNING: Unknown calling convention

void handle_LYK_LAST_LINK(void)

{
  wchar_t wVar1;
  wchar_t i;
  
  i = curdoc.link;
  wVar1 = i;
  do {
    i = wVar1;
    wVar1 = i + L'\x01';
    if (nlinks <= wVar1) break;
  } while (links[wVar1].ly == links[curdoc.link].ly);
  set_curdoc_link(i);
  return;
}



// WARNING: Unknown calling convention

void handle_LYK_LEFT_LINK(void)

{
  if ((L'\0' < curdoc.link) && (links[curdoc.link].ly == links[curdoc.link + L'\xffffffff'].ly)) {
    set_curdoc_link(curdoc.link + L'\xffffffff');
  }
  return;
}



// WARNING: Unknown calling convention

BOOLEAN handle_LYK_LIST(wchar_t *cmd)

{
  BOOLEAN BVar1;
  char *pcVar2;
  int iVar3;
  char *local_c;
  
  pcVar2 = (char *)gettext("List Page");
  if (curdoc.title == (char *)0x0) {
    local_c = "";
  }
  else {
    local_c = curdoc.title;
  }
  iVar3 = strcmp(local_c,pcVar2);
  if ((iVar3 == 0) && (BVar1 = LYIsUIPage3(curdoc.address,UIP_LIST_PAGE,L'\x01'), BVar1 != '\0')) {
    *cmd = L'%';
    return '\x01';
  }
  iVar3 = showlist(&newdoc,'\x01');
  if (-1 < iVar3) {
    pcVar2 = (char *)gettext("List Page");
    HTSACopy(&newdoc.title,pcVar2);
    if ((LYValidate != '\0') || (check_realm != '\0')) {
      LYPermitURL = '\x01';
      HTSACopy(&lynxlistfile,newdoc.address);
    }
  }
  return '\0';
}



// WARNING: Unknown calling convention

void handle_LYK_MAIN_MENU(wchar_t *old_c,wchar_t real_c)

{
  int iVar1;
  char *pcVar2;
  wchar_t wVar3;
  
  iVar1 = strcmp(curdoc.address,homepage);
  if (iVar1 == 0) {
    if (*old_c != real_c) {
      *old_c = real_c;
      pcVar2 = (char *)gettext("You are already at main screen!");
      HTUserMsg(pcVar2);
    }
  }
  else {
    pcVar2 = (char *)gettext("Do you really want to go to the Main screen?");
    wVar3 = HTConfirmDefault(pcVar2,L'\0');
    if (wVar3 == L'\x01') {
      set_address(&newdoc,homepage);
      pcVar2 = (char *)gettext("Entry into main screen");
      HTSACopy(&newdoc.title,pcVar2);
      LYFreePostData(&newdoc);
      if (newdoc.bookmark != (char *)0x0) {
        free(newdoc.bookmark);
        newdoc.bookmark = (char *)0x0;
      }
      newdoc.isHEAD = '\0';
      newdoc.safe = '\0';
      newdoc.internal_link = '\0';
      LYhighlight(L'\0',curdoc.link,prev_target);
      if ((lynx_edit_mode != '\0') && (1 < LYAutoUncacheDirLists)) {
        HTuncache_current_document();
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

void handle_LYK_MINIMAL(void)

{
  BOOLEAN BVar1;
  char *Msg;
  char *local_c;
  char *local_8;
  
  if (historical_comments == '\0') {
    BVar1 = HTcan_reparse_document();
    if (BVar1 == '\0') {
      if ((curdoc.post_data != (bstring_conflict *)0x0) && (curdoc.safe != '\x01')) {
        BVar1 = confirm_post_resub(curdoc.address,(char *)0x0,L'\0',L'\0');
        if (BVar1 == '\0') {
          Msg = (char *)gettext("Document will not be reloaded!");
          HTInfoMsg(Msg);
          goto LAB_080832a6;
        }
      }
      HText_setNoCache(HTMainText);
      move_address(&newdoc,&curdoc);
      newdoc.line = curdoc.line;
      newdoc.link = curdoc.link;
    }
  }
LAB_080832a6:
  minimal_comments = minimal_comments == '\0';
  if (historical_comments == '\0') {
    if ((bool)minimal_comments) {
      local_c = (char *)gettext("Minimal comment parsing ON (and in effect)!");
    }
    else {
      local_c = (char *)gettext("Minimal comment parsing OFF (Valid is in effect)!");
    }
    HTAlert(local_c);
  }
  else {
    if ((bool)minimal_comments) {
      local_8 = (char *)gettext("Minimal comment parsing ON (but Historical is in effect)!");
    }
    else {
      local_8 = (char *)gettext("Minimal comment parsing OFF (Historical is in effect)!");
    }
    HTAlert(local_8);
  }
  reparse_document();
  return;
}



// WARNING: Unknown calling convention

void handle_LYK_MODIFY(BOOLEAN *refresh_screen)

{
  wchar_t wVar1;
  wchar_t ret;
  
  if (((lynx_edit_mode != '\0') && (0 < nlinks)) && (no_dired_support == '\0')) {
    wVar1 = local_modify(&curdoc,&newdoc.address);
    if (wVar1 == L'\xffffff9d') {
      *refresh_screen = '\x01';
    }
    else if (wVar1 != L'\0') {
      if (0 < LYAutoUncacheDirLists) {
        HTuncache_current_document();
      }
      move_address(&newdoc,&curdoc);
      LYFreePostData(&newdoc);
      if (newdoc.bookmark != (char *)0x0) {
        free(newdoc.bookmark);
        newdoc.bookmark = (char *)0x0;
      }
      newdoc.isHEAD = '\0';
      newdoc.safe = '\0';
      newdoc.internal_link = '\0';
      newdoc.line = curdoc.line;
      newdoc.link = curdoc.link;
      LYclear();
    }
  }
  return;
}



// WARNING: Unknown calling convention

BOOLEAN handle_LYK_NESTED_TABLES(wchar_t *cmd)

{
  BOOLEAN BVar1;
  char *local_8;
  
  nested_tables = nested_tables == '\0';
  if ((bool)nested_tables) {
    local_8 = (char *)gettext("Parsing nested-tables toggled ON!  Reloading...");
  }
  else {
    local_8 = (char *)gettext("Parsing nested-tables toggled OFF!  Reloading...");
  }
  HTUserMsg(local_8);
  BVar1 = reparse_or_reload(cmd);
  return BVar1;
}



// WARNING: Unknown calling convention

BOOLEAN handle_LYK_OPTIONS(wchar_t *cmd,BOOLEAN *refresh_screen)

{
  bool bVar1;
  BOOLEAN BVar2;
  int iVar3;
  char *Msg;
  wchar_t wVar4;
  char *local_50;
  char *local_4c;
  char *local_48;
  char *local_44;
  char *local_40;
  char *local_3c;
  char *local_38;
  char *local_34;
  char *local_30;
  char *CurrentNegoCharset;
  char *CurrentNegoLanguage;
  char *CurrentUserAgent;
  wchar_t HTfileSortMethod_flag;
  wchar_t CurrentCharSet_flag;
  wchar_t CurrentAssumeCharSet_flag;
  BOOLEAN canreparse_post;
  BOOLEAN user_mode_flag;
  BOOLEAN show_dotfiles_flag;
  BOOLEAN keypad_mode_flag;
  BOOLEAN verbose_img_flag;
  BOOLEAN LYSelectPopups_flag;
  BOOLEAN LYUseDefaultRawMode_flag;
  
  if (LYUseFormsOptions != '\0') {
    BVar2 = LYIsUIPage3(curdoc.address,UIP_OPTIONS_MENU,L'\x01');
    if (BVar2 == '\0') {
      set_address(&newdoc,"LYNXOPTIONS:/");
      LYFreePostData(&newdoc);
      if (newdoc.bookmark != (char *)0x0) {
        free(newdoc.bookmark);
        newdoc.bookmark = (char *)0x0;
      }
      if ((LYValidate != '\0') || (check_realm != '\0')) {
        LYPermitURL = '\x01';
      }
      LYforce_no_cache = '\x01';
      newdoc.isHEAD = '\0';
      newdoc.safe = '\0';
      newdoc.internal_link = '\0';
      return '\0';
    }
    *cmd = L'%';
    return '\x01';
  }
  LYUseDefaultRawMode_flag = LYUseDefaultRawMode;
  LYSelectPopups_flag = LYSelectPopups;
  verbose_img_flag = verbose_img;
  keypad_mode_flag = (BOOLEAN)keypad_mode;
  show_dotfiles_flag = show_dotfiles;
  user_mode_flag = (BOOLEAN)user_mode;
  CurrentAssumeCharSet_flag = UCLYhndl_for_unspec;
  CurrentCharSet_flag = current_char_set;
  HTfileSortMethod_flag = HTfileSortMethod;
  CurrentUserAgent = (char *)0x0;
  CurrentNegoLanguage = (char *)0x0;
  CurrentNegoCharset = (char *)0x0;
  if (LYUserAgent == (char *)0x0) {
    local_50 = "";
  }
  else {
    local_50 = LYUserAgent;
  }
  HTSACopy(&CurrentUserAgent,local_50);
  if (language == (char *)0x0) {
    local_4c = "";
  }
  else {
    local_4c = language;
  }
  HTSACopy(&CurrentNegoLanguage,local_4c);
  if (pref_charset == (char *)0x0) {
    local_48 = "";
  }
  else {
    local_48 = pref_charset;
  }
  HTSACopy(&CurrentNegoCharset,local_48);
  LYoptions();
  if ((((keypad_mode_flag == keypad_mode) &&
       ((user_mode_flag == user_mode || ((user_mode_flag != '\0' && (user_mode != 0)))))) &&
      (((HTfileSortMethod_flag == HTfileSortMethod && (show_dotfiles_flag == show_dotfiles)) ||
       ((((*curdoc.address != 'f' && (*curdoc.address != 'F')) ||
         (iVar3 = strncasecomp(curdoc.address,"file:",5), iVar3 != 0)) &&
        (iVar3 = strncasecomp(curdoc.address,"ftp:",4), iVar3 != 0)))))) &&
     (((CurrentCharSet_flag == current_char_set &&
       (CurrentAssumeCharSet_flag == UCLYhndl_for_unspec)) &&
      ((verbose_img_flag == verbose_img &&
       ((LYUseDefaultRawMode_flag == LYUseDefaultRawMode && (LYSelectPopups_flag == LYSelectPopups))
       )))))) {
    if (LYUserAgent == (char *)0x0) {
      local_44 = "";
    }
    else {
      local_44 = LYUserAgent;
    }
    iVar3 = strcmp(CurrentUserAgent,local_44);
    if (iVar3 == 0) {
      if (language == (char *)0x0) {
        local_40 = "";
      }
      else {
        local_40 = language;
      }
      iVar3 = strcmp(CurrentNegoLanguage,local_40);
      if (iVar3 == 0) {
        if (pref_charset == (char *)0x0) {
          local_3c = "";
        }
        else {
          local_3c = pref_charset;
        }
        iVar3 = strcmp(CurrentNegoCharset,local_3c);
        if (iVar3 == 0) goto LAB_08083a3e;
      }
    }
    iVar3 = strncmp(curdoc.address,"http",4);
    if ((iVar3 != 0) &&
       (((*curdoc.address != 'l' && (*curdoc.address != 'L')) ||
        (iVar3 = strncasecomp(curdoc.address,"lynxcgi:",8), iVar3 != 0)))) goto LAB_08083a3e;
  }
  canreparse_post = '\0';
  if (((curdoc.post_data != (bstring_conflict *)0x0) && (curdoc.safe != '\x01')) &&
     ((canreparse_post = HTcan_reparse_document(), canreparse_post == '\0' &&
      (BVar2 = confirm_post_resub(curdoc.address,curdoc.title,L'\x02',L'\x01'), BVar2 == '\0')))) {
    Msg = (char *)gettext("Document will not be reloaded!");
    HTInfoMsg(Msg);
    goto LAB_08083a3e;
  }
  copy_address(&newdoc,&curdoc);
  if (LYUserAgent == (char *)0x0) {
    local_38 = "";
  }
  else {
    local_38 = LYUserAgent;
  }
  iVar3 = strcmp(CurrentUserAgent,local_38);
  if (iVar3 == 0) {
    if (language == (char *)0x0) {
      local_34 = "";
    }
    else {
      local_34 = language;
    }
    iVar3 = strcmp(CurrentNegoLanguage,local_34);
    if (iVar3 != 0) goto LAB_0808386e;
    if (pref_charset == (char *)0x0) {
      local_30 = "";
    }
    else {
      local_30 = pref_charset;
    }
    iVar3 = strcmp(CurrentNegoCharset,local_30);
    if (iVar3 != 0) goto LAB_0808386e;
  }
  else {
LAB_0808386e:
    iVar3 = strncmp(curdoc.address,"http",4);
    if (iVar3 != 0) {
      if (((*curdoc.address == 'l') || (*curdoc.address == 'L')) &&
         (iVar3 = strncasecomp(curdoc.address,"lynxcgi:",8), iVar3 == 0)) {
        bVar1 = false;
      }
      else {
        bVar1 = true;
      }
      if (bVar1) goto LAB_080838e5;
    }
    reloading = '\x01';
  }
LAB_080838e5:
  wVar4 = HTisDocumentSource();
  if (wVar4 != L'\0') {
    srcmode_for_next_retrieval(1);
  }
  if ((reloading == '\0') && (BVar2 = reparse_document(), BVar2 != '\0')) {
    if (CurrentUserAgent != (char *)0x0) {
      free(CurrentUserAgent);
      CurrentUserAgent = (char *)0x0;
    }
    if (CurrentNegoLanguage != (char *)0x0) {
      free(CurrentNegoLanguage);
      CurrentNegoLanguage = (char *)0x0;
    }
    if (CurrentNegoCharset != (char *)0x0) {
      free(CurrentNegoCharset);
    }
    return '\0';
  }
  if ((canreparse_post != '\0') &&
     (BVar2 = confirm_post_resub(curdoc.address,curdoc.title,L'\x02',L'\x01'), BVar2 == '\0')) {
    wVar4 = HTisDocumentSource();
    if (wVar4 != L'\0') {
      srcmode_for_next_retrieval(0);
    }
    if (CurrentUserAgent != (char *)0x0) {
      free(CurrentUserAgent);
      CurrentUserAgent = (char *)0x0;
    }
    if (CurrentNegoLanguage != (char *)0x0) {
      free(CurrentNegoLanguage);
      CurrentNegoLanguage = (char *)0x0;
    }
    if (CurrentNegoCharset != (char *)0x0) {
      free(CurrentNegoCharset);
    }
    return '\0';
  }
  HEAD_request = HTLoadedDocumentIsHEAD();
  HText_setNoCache(HTMainText);
  newdoc.line = curdoc.line;
  newdoc.link = curdoc.link;
  LYforce_no_cache = '\x01';
  free_address(&curdoc);
LAB_08083a3e:
  if (CurrentUserAgent != (char *)0x0) {
    free(CurrentUserAgent);
    CurrentUserAgent = (char *)0x0;
  }
  if (CurrentNegoLanguage != (char *)0x0) {
    free(CurrentNegoLanguage);
    CurrentNegoLanguage = (char *)0x0;
  }
  if (CurrentNegoCharset != (char *)0x0) {
    free(CurrentNegoCharset);
  }
  *refresh_screen = '\x01';
  return '\0';
}



// WARNING: Unknown calling convention

void handle_NEXT_DOC(void)

{
  int iVar1;
  char *Msg;
  
  iVar1 = LYhist_next(&curdoc,&newdoc);
  if (iVar1 == 0) {
    Msg = (char *)gettext("No next document present");
    HTUserMsg(Msg);
  }
  else {
    free_address(&curdoc);
  }
  return;
}



// WARNING: Unknown calling convention

void handle_LYK_NEXT_LINK(wchar_t c,wchar_t *old_c,wchar_t real_c)

{
  int iVar1;
  wchar_t wVar2;
  char *pcVar3;
  char *thisname;
  wchar_t thisgroup;
  
  if (curdoc.link < nlinks + L'\xffffffff') {
    LYhighlight(L'\0',curdoc.link,prev_target);
    if (((links[curdoc.link].type == 1) && ((links[curdoc.link].l_form)->type == 9)) && (c == L'\t')
       ) {
      iVar1 = (links[curdoc.link].l_form)->number;
      pcVar3 = (links[curdoc.link].l_form)->name;
      while ((curdoc.link = curdoc.link + L'\x01', curdoc.link < nlinks + L'\xffffffff' &&
             (links[curdoc.link].type == 1))) {
        if ((links[curdoc.link].l_form)->type != 9) {
          return;
        }
        if ((links[curdoc.link].l_form)->number != iVar1) {
          return;
        }
        wVar2 = sametext((links[curdoc.link].l_form)->name,pcVar3);
        if (wVar2 == L'\0') {
          return;
        }
      }
    }
    else {
      curdoc.link = curdoc.link + L'\x01';
    }
  }
  else if (((more_text == '\0') && (Newline == L'\x01')) && (curdoc.link == nlinks + L'\xffffffff'))
  {
    set_curdoc_link(L'\0');
  }
  else if (more_text == '\0') {
    if (*old_c != real_c) {
      *old_c = real_c;
      pcVar3 = (char *)gettext("You are already at the end of this document.");
      HTInfoMsg(pcVar3);
    }
  }
  else {
    Newline = Newline + display_lines;
  }
  return;
}



// WARNING: Unknown calling convention

void handle_LYK_NEXT_PAGE(wchar_t *old_c,wchar_t real_c)

{
  char *Msg;
  
  if (more_text == '\0') {
    if (curdoc.link < nlinks + L'\xffffffff') {
      set_curdoc_link(nlinks + L'\xffffffff');
    }
    else if (*old_c != real_c) {
      *old_c = real_c;
      Msg = (char *)gettext("You are already at the end of this document.");
      HTInfoMsg(Msg);
    }
  }
  else {
    Newline = Newline + display_lines;
  }
  return;
}



// WARNING: Unknown calling convention

BOOLEAN handle_LYK_NOCACHE(wchar_t *old_c,wchar_t real_c)

{
  char *Msg;
  
  if (0 < nlinks) {
    if ((((links[curdoc.link].type == 1) && ((links[curdoc.link].l_form)->type != 5)) &&
        ((links[curdoc.link].l_form)->type != 0xd)) && ((links[curdoc.link].l_form)->type != 0xc)) {
      if (*old_c != real_c) {
        *old_c = real_c;
        Msg = (char *)gettext("You are not on a form submission button or normal link.");
        HTUserMsg(Msg);
      }
      return '\0';
    }
    LYforce_no_cache = '\x01';
    reloading = '\x01';
  }
  return '\x01';
}



// WARNING: Unknown calling convention

void handle_LYK_PREV_LINK(wchar_t *arrowup,wchar_t *old_c,wchar_t real_c)

{
  wchar_t wVar1;
  char *Msg;
  wchar_t local_18;
  wchar_t scrollamount;
  
  if (curdoc.link < L'\x01') {
    if (((more_text == '\0') && (curdoc.link == L'\0')) && (Newline == L'\x01')) {
      set_curdoc_link(nlinks + L'\xffffffff');
    }
    else if (curdoc.line < L'\x02') {
      if (*old_c != real_c) {
        *old_c = real_c;
        Msg = (char *)gettext("You are already at the beginning of this document.");
        HTInfoMsg(Msg);
      }
    }
    else {
      if (display_lines < Newline) {
        local_18 = display_lines;
      }
      else {
        local_18 = Newline + L'\xffffffff';
      }
      Newline = Newline - local_18;
      if (((local_18 < display_lines) && (0 < nlinks)) &&
         ((curdoc.link == L'\0' && (links[0].ly + -1 + local_18 <= display_lines)))) {
        wVar1 = HText_LinksInLines(HTMainText,L'\x01',local_18);
        newdoc.link = wVar1 + L'\xffffffff';
      }
      else {
        *arrowup = L'\x01';
      }
    }
  }
  else {
    set_curdoc_link(curdoc.link + L'\xffffffff');
  }
  return;
}



// WARNING: Unknown calling convention

wchar_t handle_PREV_DOC(wchar_t *cmd,wchar_t *old_c,wchar_t real_c)

{
  bool bVar1;
  BOOLEAN BVar2;
  HTParentAnchor *me;
  HyperDoc *pHVar3;
  int iVar4;
  wchar_t wVar5;
  char *pcVar6;
  char *Msg2;
  DocAddress WWWDoc;
  HText *text;
  HTParentAnchor *tmpanchor;
  BOOLEAN first;
  BOOLEAN conf;
  
  if (nhist < 1) {
    if (child_lynx == '\x01') {
      return L'\x01';
    }
    if (*old_c != real_c) {
      *old_c = real_c;
      pcVar6 = (char *)gettext("You are already at the first document");
      HTUserMsg(pcVar6);
    }
  }
  else {
    bVar1 = true;
    HTLastConfirmCancelled();
    while( true ) {
      if ((nhist < 1) ||
         (conf = '\0', history[nhist + -1].hdoc.post_data == (bstring_conflict *)0x0))
      goto LAB_08084307;
      WWWDoc.address = history[nhist + -1].hdoc.address;
      WWWDoc.post_data = (bstring *)history[nhist + -1].hdoc.post_data;
      WWWDoc.post_content_type = history[nhist + -1].hdoc.post_content_type;
      WWWDoc.bookmark = history[nhist + -1].hdoc.bookmark;
      WWWDoc.isHEAD = history[nhist + -1].hdoc.isHEAD;
      WWWDoc.safe = history[nhist + -1].hdoc.safe;
      me = HTAnchor_findAddress(&WWWDoc);
      BVar2 = HTAnchor_safe(me);
      if (BVar2 != '\0') goto LAB_08084307;
      pHVar3 = HTAnchor_document(me);
      if (((pHVar3 != (HyperDoc *)0x0) ||
          ((iVar4 = strncasecomp(WWWDoc.address,"LYNXIMGMAP:",0xb), iVar4 != 0 &&
           (conf = confirm_post_resub(WWWDoc.address,history[nhist + -1].hdoc.title,L'\0',L'\0'),
           conf != '\0')))) &&
         ((LYresubmit_posts == '\0' ||
          ((conf != '\0' ||
           (((wVar5 = are_different(&history[nhist + -1].hdoc,&curdoc), wVar5 == L'\0' &&
             (wVar5 = are_different(&history[nhist + -1].hdoc,&newdoc), wVar5 == L'\0')) ||
            (BVar2 = confirm_post_resub(WWWDoc.address,history[nhist + -1].hdoc.title,L'\x02',
                                        L'\x02'), BVar2 != '\0')))))))) break;
      BVar2 = HTLastConfirmCancelled();
      pcVar6 = WWWDoc.address;
      if (BVar2 != '\0') {
        if ((!bVar1) && (curdoc.internal_link != '\0')) {
          free_address(&curdoc);
        }
        *cmd = L'E';
        return L'\x02';
      }
      if (nhist == 1) {
        pcVar6 = (char *)gettext("Cancelled!!!");
        HTInfoMsg(pcVar6);
        *old_c = L'\0';
        *cmd = L'E';
        return L'\x02';
      }
      Msg2 = (char *)gettext("Skipping %s");
      HTUserMsg2(Msg2,pcVar6);
      do {
        LYpop(&curdoc);
        if (nhist < 2) break;
        wVar5 = are_different(&history[nhist + -1].hdoc,&curdoc);
      } while (wVar5 == L'\0');
      bVar1 = false;
    }
    if (conf != '\0') {
      LYforce_no_cache = '\x01';
    }
LAB_08084307:
    if (!bVar1) {
      curdoc.internal_link = '\0';
    }
    LYhist_prev_register(&curdoc);
    free_address(&newdoc);
    if ((lynx_edit_mode != '\0') && (1 < LYAutoUncacheDirLists)) {
      HTuncache_current_document();
    }
  }
  return L'\0';
}



// WARNING: Unknown calling convention

void handle_LYK_PREV_PAGE(wchar_t *old_c,wchar_t real_c)

{
  char *Msg;
  
  if (Newline < L'\x02') {
    if (curdoc.link < L'\x01') {
      if (*old_c != real_c) {
        *old_c = real_c;
        Msg = (char *)gettext("You are already at the beginning of this document.");
        HTInfoMsg(Msg);
      }
    }
    else {
      set_curdoc_link(L'\0');
    }
  }
  else {
    Newline = Newline - display_lines;
  }
  return;
}



// WARNING: Unknown calling convention

void handle_LYK_PRINT(BOOLEAN *ForcePush,wchar_t *old_c,wchar_t real_c)

{
  BOOLEAN BVar1;
  char *pcVar2;
  wchar_t wVar3;
  
  if (LYValidate == '\0') {
    BVar1 = LYIsUIPage3(curdoc.address,UIP_PRINT_OPTIONS,L'\x01');
    if (BVar1 == '\0') {
      wVar3 = HText_getNumOfLines();
      wVar3 = print_options(&newdoc.address,curdoc.address,wVar3);
      if (L'\xffffffff' < wVar3) {
        LYRegisterUIPage(newdoc.address,UIP_PRINT_OPTIONS);
        pcVar2 = (char *)gettext("Printing Options");
        HTSACopy(&newdoc.title,pcVar2);
        LYFreePostData(&newdoc);
        if (newdoc.bookmark != (char *)0x0) {
          free(newdoc.bookmark);
          newdoc.bookmark = (char *)0x0;
        }
        newdoc.isHEAD = '\0';
        newdoc.safe = '\0';
        *ForcePush = '\x01';
        if (check_realm != '\0') {
          LYPermitURL = '\x01';
        }
      }
    }
  }
  else if (*old_c != real_c) {
    *old_c = real_c;
    pcVar2 = (char *)gettext("The \'p\'rint command is currently disabled.");
    HTUserMsg(pcVar2);
  }
  return;
}



// WARNING: Unknown calling convention

BOOLEAN handle_LYK_QUIT(void)

{
  char *pcVar1;
  wchar_t c;
  
  if (LYQuitDefaultYes == '\x01') {
    pcVar1 = (char *)gettext("Are you sure you want to quit?");
    c = HTConfirmDefault(pcVar1,L'\x01');
  }
  else {
    pcVar1 = (char *)gettext("Are you sure you want to quit?");
    c = HTConfirmDefault(pcVar1,L'\0');
  }
  if (LYQuitDefaultYes == '\x01') {
    if (c != L'\0') {
      return '\x01';
    }
    pcVar1 = (char *)gettext("Excellent!!!");
    HTInfoMsg(pcVar1);
  }
  else {
    if (c == L'\x01') {
      return '\x01';
    }
    pcVar1 = (char *)gettext("Excellent!!!");
    HTInfoMsg(pcVar1);
  }
  return '\0';
}



// WARNING: Unknown calling convention

BOOLEAN handle_LYK_RAW_TOGGLE(wchar_t *cmd)

{
  char *pcVar1;
  BOOLEAN local_9;
  char *local_8;
  
  pcVar1 = HTLoadedDocumentCharset();
  if (pcVar1 == (char *)0x0) {
    LYUseDefaultRawMode = LYUseDefaultRawMode == '\0';
    if (LYRawMode == '\0') {
      local_8 = (char *)gettext("Raw 8-bit or CJK mode toggled ON!  Reloading...");
    }
    else {
      local_8 = (char *)gettext("Raw 8-bit or CJK mode toggled OFF!  Reloading...");
    }
    HTUserMsg(local_8);
    HTMLSetCharacterHandling(current_char_set);
    local_9 = reparse_or_reload(cmd);
  }
  else {
    pcVar1 = (char *)gettext("charset for this document specified explicitly, sorry...");
    HTUserMsg(pcVar1);
    local_9 = '\0';
  }
  return local_9;
}



// WARNING: Unknown calling convention

void handle_LYK_RELOAD(wchar_t real_cmd)

{
  BOOLEAN BVar1;
  char *pcVar2;
  wchar_t wVar3;
  
  if ((curdoc.post_data != (bstring_conflict *)0x0) && (curdoc.safe != '\x01')) {
    pcVar2 = (char *)gettext("Document from Form with POST content.  Resubmit?");
    BVar1 = HTConfirm(pcVar2);
    if (BVar1 == '\0') {
      pcVar2 = (char *)gettext("Cancelled!!!");
      HTInfoMsg(pcVar2);
      return;
    }
  }
  wVar3 = HTisDocumentSource();
  if (wVar3 != L'\0') {
    forced_UCLYhdnl = HTMainText_Get_UCLYhndl();
    if (L'\xffffffff' < forced_UCLYhdnl) {
      force_old_UCLYhndl_on_reload = '\x01';
    }
    srcmode_for_next_retrieval(1);
  }
  HEAD_request = HTLoadedDocumentIsHEAD();
  HText_setNoCache(HTMainText);
  newdoc.line = curdoc.line;
  newdoc.link = curdoc.link;
  free_address(&curdoc);
  if (real_cmd == L'\f') {
    reloading = '\x01';
  }
  return;
}



// WARNING: Unknown calling convention

void handle_LYK_REMOVE(BOOLEAN *refresh_screen)

{
  wchar_t wVar1;
  wchar_t linkno;
  
  wVar1 = curdoc.link;
  if (((lynx_edit_mode != '\0') && (0 < nlinks)) && (no_dired_support == '\0')) {
    local_remove(&curdoc);
    if (LYAutoUncacheDirLists < 1) {
      if (curdoc.link != wVar1) {
        *refresh_screen = '\x01';
      }
    }
    else {
      do_cleanup_after_delete();
    }
  }
  return;
}



// WARNING: Unknown calling convention

void handle_LYK_RIGHT_LINK(void)

{
  if ((curdoc.link < nlinks + L'\xffffffff') &&
     (links[curdoc.link].ly == links[curdoc.link + L'\x01'].ly)) {
    set_curdoc_link(curdoc.link + L'\x01');
  }
  return;
}



// WARNING: Unknown calling convention

void handle_LYK_SHELL(BOOLEAN *refresh_screen,wchar_t *old_c,wchar_t real_c)

{
  undefined4 uVar1;
  char *pcVar2;
  
  if (no_shell == '\0') {
    stop_curses();
    uVar1 = gettext("Spawning your default shell.  Use \'exit\' to return to Lynx.\n");
    printf("%s\r\n",uVar1);
    if (handle_LYK_SHELL::shell == (char *)0x0) {
      pcVar2 = LYSysShell();
      HTSACopy(&handle_LYK_SHELL::shell,pcVar2);
    }
    LYSystem(handle_LYK_SHELL::shell);
    start_curses();
    *refresh_screen = '\x01';
  }
  else if (*old_c != real_c) {
    *old_c = real_c;
    pcVar2 = (char *)gettext("Spawning is currently disabled.");
    HTUserMsg(pcVar2);
  }
  return;
}



// WARNING: Unknown calling convention

void handle_LYK_SOFT_DQUOTES(void)

{
  BOOLEAN BVar1;
  char *Msg;
  char *local_8;
  
  BVar1 = HTcan_reparse_document();
  if (BVar1 == '\0') {
    if ((curdoc.post_data != (bstring_conflict *)0x0) && (curdoc.safe != '\x01')) {
      BVar1 = confirm_post_resub(curdoc.address,(char *)0x0,L'\x01',L'\x01');
      if (BVar1 == '\0') {
        Msg = (char *)gettext("Document will not be reloaded!");
        HTInfoMsg(Msg);
        goto LAB_080848df;
      }
    }
    HText_setNoCache(HTMainText);
    move_address(&newdoc,&curdoc);
    newdoc.line = curdoc.line;
    newdoc.link = curdoc.link;
  }
LAB_080848df:
  soft_dquotes = soft_dquotes == '\0';
  if ((bool)soft_dquotes) {
    local_8 = (char *)gettext("Soft double-quote parsing ON!");
  }
  else {
    local_8 = (char *)gettext("Soft double-quote parsing OFF!");
  }
  HTUserMsg(local_8);
  reparse_document();
  return;
}



// WARNING: Unknown calling convention

wchar_t wrap_reparse_document(void)

{
  BOOLEAN BVar1;
  wchar_t wVar2;
  FILE *pFVar3;
  wchar_t wVar4;
  wchar_t wVar5;
  wchar_t wVar6;
  wchar_t local_34;
  wchar_t local_30;
  wchar_t top_lineno;
  wchar_t new_lineno;
  wchar_t new_anchor;
  wchar_t old_offset;
  wchar_t old_from_top;
  wchar_t old_line_num;
  wchar_t anchor_number;
  wchar_t result;
  
  if ((nlinks < 1) || (curdoc.link < L'\0')) {
    local_34 = L'\xffffffff';
  }
  else {
    local_34 = links[curdoc.link].anchor_number;
  }
  wVar2 = HText_getAbsLineNumber(HTMainText,local_34);
  wVar4 = curdoc.link;
  old_from_top = (wVar2 - Newline) + L'\x01';
  if ((nlinks < 1) || (curdoc.link < L'\0')) {
    local_30 = L'\xffffffff';
  }
  else {
    local_30 = links[curdoc.link].sgml_offset;
  }
  if (WWW_TraceFlag != '\0') {
    pFVar3 = TraceFP();
    fprintf((FILE *)pFVar3,"original anchor %d, topline %d, link %d, offset %d\n",local_34,wVar2,
            wVar4,local_30);
  }
  BVar1 = reparse_document();
  if ((BVar1 != L'\0') && (L'\xffffffff' < local_30)) {
    wVar4 = HText_closestAnchor(HTMainText,local_30);
    wVar2 = HText_getAbsLineNumber(HTMainText,wVar4);
    if (WWW_TraceFlag != '\0') {
      pFVar3 = TraceFP();
      fprintf((FILE *)pFVar3,"old anchor %d -> new anchor %d\n",local_34,wVar4);
    }
    if (wVar2 - old_from_top < 0) {
      old_from_top = wVar2;
    }
    wVar2 = HText_getPreferredTopLine(HTMainText,wVar2 - old_from_top);
    wVar5 = wVar2 + L'\x01';
    if (WWW_TraceFlag != '\0') {
      pFVar3 = TraceFP();
      fprintf((FILE *)pFVar3,"preferred top %d\n",wVar5);
    }
    if (wVar5 == Newline) {
      newdoc.link = curdoc.link;
    }
    else {
      Newline = wVar5;
      newdoc.link = HText_anchorRelativeTo(HTMainText,wVar2,wVar4);
      curdoc.link = newdoc.link;
      if (WWW_TraceFlag != '\0') {
        wVar6 = HText_locateAnchor(HTMainText,wVar4);
        wVar2 = curdoc.link;
        pFVar3 = TraceFP();
        fprintf((FILE *)pFVar3,"adjusted anchor %d, topline %d, link %d, offset %d\n",wVar4,wVar5,
                wVar2,wVar6);
      }
    }
  }
  return (int)BVar1;
}



// WARNING: Unknown calling convention

void handle_LYK_SOURCE(char **ownerS_address_p)

{
  char cVar1;
  char *pcVar2;
  wchar_t wVar3;
  BOOLEAN canreparse_post;
  
  canreparse_post = '\0';
  if (((curdoc.post_data != (bstring_conflict *)0x0) && (curdoc.safe != '\x01')) &&
     (canreparse_post = HTcan_reparse_document(), canreparse_post == '\0')) {
    if (curdoc.isHEAD == '\0') {
      cVar1 = confirm_post_resub(curdoc.address,curdoc.title,L'\x01',L'\x01');
    }
    else {
      pcVar2 = (char *)gettext("Document from Form with POST content.  Resubmit?");
      cVar1 = HTConfirm(pcVar2);
    }
    if (cVar1 == '\0') {
      pcVar2 = (char *)gettext("Cancelled!!!");
      HTInfoMsg(pcVar2);
      return;
    }
  }
  wVar3 = HTisDocumentSource();
  if (wVar3 == L'\0') {
    pcVar2 = HText_getOwner();
    if (pcVar2 != (char *)0x0) {
      pcVar2 = HText_getOwner();
      HTSACopy(ownerS_address_p,pcVar2);
    }
    LYUCPushAssumed(HTMainAnchor);
    srcmode_for_next_retrieval(1);
  }
  else {
    srcmode_for_next_retrieval(-1);
  }
  wVar3 = wrap_reparse_document();
  if (wVar3 == L'\0') {
    if (canreparse_post == '\0') {
      if (curdoc.title != (char *)0x0) {
        HTSACopy(&newdoc.title,curdoc.title);
      }
      free_address(&curdoc);
      LYforce_no_cache = '\x01';
    }
    else {
      srcmode_for_next_retrieval(0);
      LYUCPopAssumed();
    }
  }
  else {
    HTOutputFormat = HTAtom_for("www/present");
    if (psrc_view != '\0') {
      HTMark_asSource();
    }
    psrc_view = '\0';
    if (*ownerS_address_p != (char *)0x0) {
      free(*ownerS_address_p);
      *ownerS_address_p = (char *)0x0;
    }
    LYUCPopAssumed();
    HTMLSetCharacterHandling(current_char_set);
  }
  return;
}



// WARNING: Unknown calling convention

void handle_LYK_SWITCH_DTD(void)

{
  BOOLEAN BVar1;
  BOOLEAN BVar2;
  char *Msg;
  wchar_t wVar3;
  char *local_18;
  BOOLEAN canreparse;
  
  BVar1 = HTcan_reparse_document();
  if (BVar1 == '\0') {
    if ((curdoc.post_data != (bstring_conflict *)0x0) && (curdoc.safe != '\x01')) {
      BVar2 = confirm_post_resub(curdoc.address,(char *)0x0,L'\x01',L'\x01');
      if (BVar2 == '\0') {
        Msg = (char *)gettext("Document will not be reloaded!");
        HTInfoMsg(Msg);
        goto LAB_08084e0c;
      }
    }
    wVar3 = HTisDocumentSource();
    if ((wVar3 != L'\0') && (LYPreparsedSource != '\0')) {
      srcmode_for_next_retrieval(1);
    }
    HText_setNoCache(HTMainText);
    move_address(&newdoc,&curdoc);
    newdoc.line = curdoc.line;
    newdoc.link = curdoc.link;
  }
LAB_08084e0c:
  Old_DTD = (int)(Old_DTD == 0);
  HTSwitchDTD((uint)(Old_DTD == 0));
  if (Old_DTD == 0) {
    local_18 = (char *)gettext("Now using SortaSGML parsing of HTML!");
  }
  else {
    local_18 = (char *)gettext("Now using TagSoup parsing of HTML.");
  }
  HTUserMsg(local_18);
  if (BVar1 != '\0') {
    wVar3 = HTisDocumentSource();
    if ((wVar3 != L'\0') && (LYPreparsedSource != '\0')) {
      srcmode_for_next_retrieval(1);
    }
    BVar1 = reparse_document();
    if (BVar1 == '\0') {
      srcmode_for_next_retrieval(0);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void handle_LYK_TAG_LINK(void)

{
  char *pcVar1;
  int iVar2;
  char *local_18;
  char *tagname;
  HTList *t1;
  BOOLEAN found;
  
  if (((lynx_edit_mode != '\0') && (0 < nlinks)) && (no_dired_support == '\0')) {
    pcVar1 = LYGetHiliteStr(curdoc.link,L'\0');
    iVar2 = strcmp(pcVar1,"..");
    if (iVar2 != 0) {
      if (dir_list_style == 2) {
        pcVar1 = LYGetHiliteStr(curdoc.link,L'\0');
        iVar2 = strcmp(pcVar1,"../");
      }
      else {
        pcVar1 = LYGetHiliteStr(curdoc.link,L'\0');
        iVar2 = strncmp(pcVar1,"Up to ",6);
      }
      if (iVar2 != 0) {
        found = '\0';
        t1 = tagged;
        do {
          if ((t1 == (HTList *)0x0) || (t1 = t1->next, t1 == (HTList *)0x0)) {
            local_18 = (char *)0x0;
          }
          else {
            local_18 = (char *)t1->object;
          }
          tagname = local_18;
          if (local_18 == (char *)0x0) goto LAB_0808502d;
          iVar2 = strcmp(links[curdoc.link].lname,local_18);
        } while (iVar2 != 0);
        found = '\x01';
        HTList_removeObject(tagged,tagname);
        if (tagname != (char *)0x0) {
          free(tagname);
          tagname = (char *)0x0;
        }
        tagflag(L'\0',curdoc.link);
LAB_0808502d:
        if (found == '\0') {
          if (tagged == (HTList *)0x0) {
            tagged = HTList_new();
          }
          tagname = (char *)0x0;
          HTSACopy(&tagname,links[curdoc.link].lname);
          HTList_addObject(tagged,tagname);
          tagflag(L'\x01',curdoc.link);
        }
        if (curdoc.link < nlinks + L'\xffffffff') {
          set_curdoc_link(curdoc.link + L'\x01');
        }
        else if (((more_text == '\0') && (Newline == L'\x01')) &&
                (curdoc.link == nlinks + L'\xffffffff')) {
          set_curdoc_link(L'\0');
        }
        else if (more_text != '\0') {
          Newline = Newline + display_lines;
        }
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

void handle_LYK_TOGGLE_HELP(void)

{
  if (user_mode == 0) {
    toggle_novice_line();
    noviceline((int)more_text);
  }
  return;
}



// WARNING: Unknown calling convention

void handle_LYK_TOOLBAR(BOOLEAN *try_internal,BOOLEAN *force_load,wchar_t *old_c,wchar_t real_c)

{
  BOOLEAN BVar1;
  char *Msg;
  char *toolbar;
  char *cp;
  
  toolbar = (char *)0x0;
  BVar1 = HText_hasToolbar(HTMainText);
  if (BVar1 == '\0') {
    if (*old_c != real_c) {
      *old_c = real_c;
      Msg = (char *)gettext("Document has no Toolbar links or Banner.");
      HTUserMsg(Msg);
    }
  }
  else if (*old_c != real_c) {
    *old_c = real_c;
    cp = trimPoundSelector(curdoc.address);
    HTSprintf0(&toolbar,"%s#%s",curdoc.address,LYToolbarName);
    if (cp != (char *)0x0) {
      *cp = '#';
    }
    set_address(&newdoc,toolbar);
    if (toolbar != (char *)0x0) {
      free(toolbar);
    }
    *try_internal = '\x01';
    *force_load = '\x01';
  }
  return;
}



// WARNING: Unknown calling convention

void handle_LYK_TRACE_LOG(BOOLEAN *trace_flag_ptr)

{
  BOOLEAN BVar1;
  char *pcVar2;
  
  if (LYTraceLogFP == (FILE *)0x0) {
    pcVar2 = (char *)gettext("No trace log has been started for this session.");
    HTUserMsg(pcVar2);
  }
  else {
    BVar1 = LYIsUIPage3(curdoc.address,UIP_TRACELOG,L'\x01');
    if (BVar1 == '\0') {
      BVar1 = LYReopenTracelog(trace_flag_ptr);
      if (BVar1 != '\0') {
        LYLocalFileToURL(&newdoc.address,LYTraceLogPath);
        LYRegisterUIPage(newdoc.address,UIP_TRACELOG);
        pcVar2 = (char *)gettext("Lynx Trace Log");
        HTSACopy(&newdoc.title,pcVar2);
        LYFreePostData(&newdoc);
        if (newdoc.bookmark != (char *)0x0) {
          free(newdoc.bookmark);
          newdoc.bookmark = (char *)0x0;
        }
        newdoc.isHEAD = '\0';
        newdoc.safe = '\0';
        newdoc.internal_link = '\0';
        if ((LYValidate != '\0') || (check_realm != '\0')) {
          LYPermitURL = '\x01';
        }
        LYforce_no_cache = '\x01';
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

void handle_LYK_UPLOAD(void)

{
  BOOLEAN BVar1;
  char *src;
  
  BVar1 = LYIsUIPage3(curdoc.address,UIP_UPLOAD_OPTIONS,L'\x01');
  if (((BVar1 == '\0') && (lynx_edit_mode != '\0')) && (no_dired_support == '\0')) {
    LYUpload_options(&newdoc.address,curdoc.address);
    src = (char *)gettext("Upload Options");
    HTSACopy(&newdoc.title,src);
    LYFreePostData(&newdoc);
    if (newdoc.bookmark != (char *)0x0) {
      free(newdoc.bookmark);
      newdoc.bookmark = (char *)0x0;
    }
    newdoc.isHEAD = '\0';
    newdoc.safe = '\0';
    newdoc.internal_link = '\0';
    if (0 < LYAutoUncacheDirLists) {
      HTuncache_current_document();
    }
  }
  return;
}



// WARNING: Unknown calling convention

void handle_LYK_UP_xxx(wchar_t *arrowup,wchar_t *old_c,wchar_t real_c,wchar_t scroll_by)

{
  wchar_t wVar1;
  wchar_t wVar2;
  char *Msg;
  
  wVar1 = curdoc.link;
  if (Newline < L'\x02') {
    if (*old_c != real_c) {
      *old_c = real_c;
      Msg = (char *)gettext("You are already at the beginning of this document.");
      HTInfoMsg(Msg);
    }
  }
  else {
    if (Newline == scroll_by || Newline - scroll_by < 0) {
      scroll_by = Newline + L'\xffffffff';
    }
    Newline = Newline - scroll_by;
    if ((0 < nlinks) && (L'\xffffffff' < curdoc.link)) {
      if (display_lines < links[curdoc.link].ly + scroll_by) {
        *arrowup = L'\x01';
      }
      else {
        wVar2 = HText_LinksInLines(HTMainText,Newline,scroll_by);
        newdoc.link = wVar1 + wVar2;
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

void handle_LYK_UP_HALF(wchar_t *arrowup,wchar_t *old_c,wchar_t real_c)

{
  handle_LYK_UP_xxx(arrowup,old_c,real_c,display_lines / 2);
  return;
}



// WARNING: Unknown calling convention

void handle_LYK_UP_LINK(wchar_t *follow_col,wchar_t *arrowup,wchar_t *old_c,wchar_t real_c)

{
  wchar_t wVar1;
  char *pcVar2;
  size_t sVar3;
  wchar_t local_1c;
  wchar_t scrollamount;
  char *text;
  wchar_t newlink;
  
  if (curdoc.link < L'\x01') {
LAB_0808561c:
    if ((curdoc.line < L'\x02') || (Newline < L'\x02')) {
      if (*old_c != real_c) {
        *old_c = real_c;
        pcVar2 = (char *)gettext("You are already at the beginning of this document.");
        HTInfoMsg(pcVar2);
      }
    }
    else {
      if (display_lines < Newline) {
        local_1c = display_lines;
      }
      else {
        local_1c = Newline + L'\xffffffff';
      }
      Newline = Newline - local_1c;
      if ((((local_1c < display_lines) && (0 < nlinks)) && (L'\xffffffff' < curdoc.link)) &&
         (links[0].ly + -1 + local_1c <= display_lines)) {
        wVar1 = HText_LinksInLines(HTMainText,L'\x01',local_1c);
        newdoc.link = wVar1 + L'\xffffffff';
      }
      else {
        *arrowup = L'\x01';
      }
    }
  }
  else {
    if (links[0].ly == links[curdoc.link].ly) {
      wVar1 = HText_LinksInLines(HTMainText,L'\x01',Newline + L'\xffffffff');
      if (wVar1 != L'\0') goto LAB_0808561c;
    }
    if (*follow_col == L'\xffffffff') {
      pcVar2 = LYGetHiliteStr(curdoc.link,L'\0');
      *follow_col = links[curdoc.link].lx;
      if (pcVar2 != (char *)0x0) {
        wVar1 = *follow_col;
        sVar3 = strlen(pcVar2);
        *follow_col = wVar1 + (sVar3 >> 1);
      }
    }
    wVar1 = find_link_near_col(*follow_col,L'\xffffffff');
    if (wVar1 < L'\0') {
      if (*old_c != real_c) {
        *old_c = real_c;
        pcVar2 = (char *)gettext("There are no links above this line of the document.");
        HTUserMsg(pcVar2);
      }
    }
    else {
      set_curdoc_link(wVar1);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void handle_LYK_UP_TWO(wchar_t *arrowup,wchar_t *old_c,wchar_t real_c)

{
  handle_LYK_UP_xxx(arrowup,old_c,real_c,L'\x02');
  return;
}



// WARNING: Unknown calling convention

void handle_LYK_VIEW_BOOKMARK(BOOLEAN *refresh_screen,wchar_t *old_c,wchar_t real_c)

{
  char *pcVar1;
  int iVar2;
  char *cp;
  
  if (LYValidate == '\0') {
    pcVar1 = get_bookmark_filename(&newdoc.address);
    if (pcVar1 == (char *)0x0) {
      if (*old_c != real_c) {
        *old_c = real_c;
        pcVar1 = (char *)gettext("Unable to open bookmark file, use \'a\' to save a link first");
        LYMBM_statusline(pcVar1);
        LYSleepAlert();
        if (LYMultiBookmarks != 0) {
          *refresh_screen = '\x01';
        }
      }
    }
    else {
      if (((*pcVar1 != '\0') && (iVar2 = strcmp(pcVar1," "), iVar2 != 0)) &&
         (iVar2 = strcmp(curdoc.address,newdoc.address), iVar2 != 0)) {
        LYforce_no_cache = '\x01';
        pcVar1 = (char *)gettext("Bookmark file");
        HTSACopy(&newdoc.title,pcVar1);
        HTSACopy(&newdoc.bookmark,BookmarkPage);
        LYFreePostData(&newdoc);
        newdoc.isHEAD = '\0';
        newdoc.safe = '\0';
        newdoc.internal_link = '\0';
        return;
      }
      if (LYMultiBookmarks != 0) {
        *refresh_screen = '\x01';
      }
    }
  }
  else if (*old_c != real_c) {
    *old_c = real_c;
    pcVar1 = (char *)gettext("Bookmark features are currently disabled.");
    HTUserMsg(pcVar1);
  }
  return;
}



// WARNING: Unknown calling convention

BOOLEAN handle_LYK_VLINKS(wchar_t *cmd,BOOLEAN *newdoc_link_is_absolute)

{
  BOOLEAN BVar1;
  int iVar2;
  char *pcVar3;
  BOOLEAN local_15;
  wchar_t c;
  
  BVar1 = LYIsUIPage3(curdoc.address,UIP_VLINKS,L'\x01');
  if (BVar1 == '\0') {
    iVar2 = LYShowVisitedLinks(&newdoc.address);
    if (iVar2 < 0) {
      pcVar3 = (char *)gettext("No previously visited links available!");
      HTUserMsg(pcVar3);
      local_15 = '\0';
    }
    else {
      pcVar3 = (char *)gettext("Visited Links Page");
      HTSACopy(&newdoc.title,pcVar3);
      LYFreePostData(&newdoc);
      if (newdoc.bookmark != (char *)0x0) {
        free(newdoc.bookmark);
        newdoc.bookmark = (char *)0x0;
      }
      newdoc.isHEAD = '\0';
      newdoc.safe = '\0';
      newdoc.internal_link = '\0';
      if (0 < iVar2) {
        *newdoc_link_is_absolute = '\x01';
        newdoc.link = iVar2 + L'\xffffffff';
      }
      if ((LYValidate != '\0') || (check_realm != '\0')) {
        LYPermitURL = '\x01';
        HTSACopy(&lynxlinksfile,newdoc.address);
      }
      local_15 = '\0';
    }
  }
  else {
    *cmd = L'%';
    local_15 = '\x01';
  }
  return local_15;
}



// WARNING: Unknown calling convention

void handle_LYK_WHEREIS(wchar_t cmd,BOOLEAN *refresh_screen)

{
  BOOLEAN BVar1;
  int iVar2;
  char local_24;
  int local_20;
  int local_1c;
  char *remember_old_target;
  wchar_t oldcur;
  BOOLEAN found;
  BOOLEAN have_target_onscreen;
  
  if ((prev_target[0] == '\0') || (BVar1 = HText_pageHasPrevTarget(), BVar1 == '\0')) {
    local_24 = '\0';
  }
  else {
    local_24 = '\x01';
  }
  have_target_onscreen = local_24;
  oldcur = curdoc.link;
  remember_old_target = (char *)0x0;
  if (local_24 == '\0') {
    HTSACopy(&remember_old_target,"");
  }
  else {
    HTSACopy(&remember_old_target,prev_target);
  }
  if (cmd == L'3') {
    prev_target[0] = '\0';
    local_20 = 0;
  }
  else {
    if (cmd == L'5') {
      local_1c = 1;
    }
    else {
      local_1c = -1;
    }
    local_20 = local_1c;
  }
  found = textsearch(&curdoc,prev_target,0x3ff,local_20);
  if ((www_search_result < 0) || (curdoc.line == www_search_result)) {
    if (found == '\0') {
      *refresh_screen = have_target_onscreen;
    }
    else if ((have_target_onscreen == '\0') && (found != '\0')) {
      *refresh_screen = '\x01';
    }
    else if ((((curdoc.line == www_search_result) && (curdoc.link == oldcur)) &&
             (L'\xffffffff' < curdoc.link)) &&
            ((0 < nlinks && (display_lines / 3 <= links[curdoc.link].ly)))) {
      *refresh_screen = '\x01';
    }
    else if (((case_sensitive != '\0') &&
             (iVar2 = strcmp(prev_target,remember_old_target), iVar2 != 0)) ||
            ((case_sensitive == '\0' &&
             (iVar2 = strcasecomp8(prev_target,remember_old_target), iVar2 != 0)))) {
      *refresh_screen = '\x01';
    }
  }
  else {
    *refresh_screen = '\x01';
  }
  if (remember_old_target != (char *)0x0) {
    free(remember_old_target);
  }
  return;
}



// WARNING: Unknown calling convention

void handle_LYK_digit(wchar_t c,BOOLEAN *force_load,char *user_input_buffer,wchar_t *old_c,
                     wchar_t real_c,BOOLEAN *try_internal)

{
  int iVar1;
  char *pcVar2;
  wchar_t wVar3;
  wchar_t local_20;
  char *temp;
  wchar_t number;
  wchar_t lindx;
  
  if (nlinks < 1) {
    local_20 = L'\0';
  }
  else {
    local_20 = curdoc.link;
  }
  lindx = local_20;
  temp = (char *)0x0;
  number = curdoc.line;
  iVar1 = follow_link_number(c,local_20,&newdoc,&number);
  wVar3 = newdoc.line;
  if (iVar1 == 2) {
    Newline = newdoc.line;
    newdoc.line = L'\x01';
    if (((curdoc.line == wVar3) && (0 < nlinks)) && (L'\xffffffff' < curdoc.link)) {
      if (curdoc.link == newdoc.link) {
        HTSACopy(&temp,user_input_buffer);
        wVar3 = number;
        pcVar2 = (char *)gettext("Link number %d already is current.");
        sprintf(user_input_buffer,pcVar2,wVar3);
        HTUserMsg(user_input_buffer);
        LYstrncpy(user_input_buffer,temp,L'');
        if (temp != (char *)0x0) {
          free(temp);
        }
      }
      else {
        set_curdoc_link(newdoc.link);
        newdoc.link = L'\0';
      }
    }
  }
  else if (iVar1 < 3) {
    if (iVar1 == 1) {
      set_address(&newdoc,links[lindx].lname);
      pcVar2 = LYGetHiliteStr(lindx,L'\0');
      HTSACopy(&newdoc.title,pcVar2);
      wVar3 = are_different(&curdoc,&newdoc);
      if (wVar3 != L'\0') {
        LYFreePostData(&newdoc);
        if (newdoc.bookmark != (char *)0x0) {
          free(newdoc.bookmark);
          newdoc.bookmark = (char *)0x0;
        }
        newdoc.isHEAD = '\0';
        newdoc.safe = '\0';
        iVar1 = strncasecomp(newdoc.address,"LYNXMESSAGES:",0xd);
        if (iVar1 == 0) {
          LYforce_no_cache = '\x01';
        }
      }
      newdoc.internal_link = '\0';
      *force_load = '\x01';
    }
  }
  else if (iVar1 == 3) {
    Newline = newdoc.line;
    newdoc.line = L'\x01';
    if (curdoc.line == wVar3) {
      if (wVar3 < L'\x02') {
        pcVar2 = (char *)gettext("You are already at the beginning of this document.");
        HTInfoMsg(pcVar2);
      }
      else if (more_text == '\0') {
        pcVar2 = (char *)gettext("You are already at the end of this document.");
        HTInfoMsg(pcVar2);
      }
      else {
        HTSACopy(&temp,user_input_buffer);
        wVar3 = number;
        pcVar2 = (char *)gettext("You are already at page %d of this document.");
        sprintf(user_input_buffer,pcVar2,wVar3);
        HTUserMsg(user_input_buffer);
        LYstrncpy(user_input_buffer,temp,L'');
        if (temp != (char *)0x0) {
          free(temp);
        }
      }
    }
  }
  else if (iVar1 == 5) {
    *old_c = real_c;
    pcVar2 = (char *)gettext("You have entered an invalid link number.");
    HTUserMsg(pcVar2);
  }
  return;
}



// WARNING: Unknown calling convention

void handle_LYK_CHDIR(void)

{
  int iVar1;
  BOOLEAN BVar2;
  char *pcVar3;
  wchar_t wVar4;
  FILE *__stream;
  int iVar5;
  int *piVar6;
  int in_GS_OFFSET;
  char *addr;
  char *p;
  char buf2 [256];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  p = (char *)0x0;
  if (no_chdir != '\0') {
    pcVar3 = (char *)gettext("Changing working-directory is currently disabled.");
    HTUserMsg(pcVar3);
    goto LAB_080861c9;
  }
  mustshow = '\x01';
  pcVar3 = (char *)gettext("cd to:");
  statusline(pcVar3);
  wVar4 = LYgetstr(handle_LYK_CHDIR::buf,L'\0',0xff,NORECALL);
  if ((wVar4 < L'\0') || (handle_LYK_CHDIR::buf[0] == '\0')) {
    pcVar3 = (char *)gettext("Cancelled!!!");
    HTInfoMsg(pcVar3);
    goto LAB_080861c9;
  }
  if ((handle_LYK_CHDIR::buf[0] == '~') &&
     ((handle_LYK_CHDIR::buf[1] == '/' || (handle_LYK_CHDIR::buf[1] == '\0')))) {
    pcVar3 = Home_Dir();
    HTSprintf0(&p,"%s%s",pcVar3,handle_LYK_CHDIR::buf + 1);
  }
  else {
    HTSACopy(&p,handle_LYK_CHDIR::buf);
  }
  pcVar3 = p;
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"changing directory to \'%s\'\n",pcVar3);
  }
  iVar5 = chdir(p);
  if (iVar5 == 0) {
    if (no_dired_support == '\0') {
      if (lynx_edit_mode == '\0') {
        BVar2 = LYIsUIPage3(curdoc.address,UIP_DIRED_MENU,L'\x01');
        if (BVar2 == '\0') goto LAB_08086193;
      }
      addr = (char *)0x0;
      Current_Dir(buf2);
      LYLocalFileToURL(&addr,buf2);
      newdoc.address = addr;
      newdoc.isHEAD = '\0';
      pcVar3 = (char *)gettext("A URL specified by the user");
      HTSACopy(&newdoc.title,pcVar3);
      LYFreePostData(&newdoc);
      if (newdoc.bookmark != (char *)0x0) {
        free(newdoc.bookmark);
        newdoc.bookmark = (char *)0x0;
      }
      newdoc.safe = '\0';
      newdoc.internal_link = '\0';
      if ((lynx_edit_mode != '\0') && (1 < LYAutoUncacheDirLists)) {
        HTuncache_current_document();
      }
    }
    else {
LAB_08086193:
      pcVar3 = (char *)gettext("Done!");
      HTInfoMsg(pcVar3);
    }
  }
  else {
    piVar6 = __errno_location();
    iVar5 = *piVar6;
    if (iVar5 == 0xd) {
      pcVar3 = (char *)gettext("Could not access directory.");
      HTInfoMsg(pcVar3);
    }
    else if (iVar5 == 0x14) {
      pcVar3 = (char *)gettext("A component of path is not a directory");
      HTInfoMsg(pcVar3);
    }
    else if (iVar5 == 2) {
      pcVar3 = (char *)gettext("No such directory");
      HTInfoMsg(pcVar3);
    }
    else {
      pcVar3 = (char *)gettext("failed to change directory");
      HTInfoMsg(pcVar3);
    }
  }
  if (p != (char *)0x0) {
    free(p);
    p = (char *)0x0;
  }
LAB_080861c9:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



// WARNING: Unknown calling convention

wchar_t repeat_to_delta(wchar_t n)

{
  wchar_t threshold;
  
  threshold = LYcols / 3;
  while( true ) {
    if (threshold < L'\x01') {
      return n;
    }
    if (threshold <= n) break;
    threshold = (threshold * 2) / 3;
  }
  return threshold;
}



// WARNING: Unknown calling convention

void handle_LYK_SHIFT_LEFT(BOOLEAN *flag,wchar_t count)

{
  wchar_t wVar1;
  char *Msg;
  wchar_t wVar2;
  
  wVar1 = LYshiftWin;
  if (LYwideLines == L'\0') {
    Msg = (char *)gettext("Shifting is disabled while line-wrap is in effect");
    HTAlert(Msg);
  }
  else {
    if (L'\0' < LYshiftWin) {
      wVar2 = repeat_to_delta(count);
      LYshiftWin = wVar1 - wVar2;
      *flag = '\x01';
    }
    if (LYshiftWin < L'\0') {
      LYshiftWin = L'\0';
    }
  }
  return;
}



// WARNING: Unknown calling convention

void handle_LYK_SHIFT_RIGHT(BOOLEAN *flag,wchar_t count)

{
  char *Msg;
  wchar_t wVar1;
  
  if (LYwideLines == L'\0') {
    Msg = (char *)gettext("Shifting is disabled while line-wrap is in effect");
    HTAlert(Msg);
  }
  else {
    wVar1 = repeat_to_delta(count);
    LYshiftWin = wVar1 + LYshiftWin;
    *flag = '\x01';
  }
  return;
}



// WARNING: Unknown calling convention

BOOLEAN handle_LYK_LINEWRAP_TOGGLE(wchar_t *cmd,BOOLEAN *flag)

{
  wchar_t wVar1;
  BOOLEAN local_19;
  char *local_18;
  wchar_t c;
  
  if (LYwin == stdscr) {
    local_19 = '\0';
  }
  else {
    wVar1 = popup_choice((uint)(LYwideLines == L'\0'),LYlines / 2 + L'\xfffffffe',
                         (int)(LYcols - (uint)(LYShowScrollbar != '\0')) / 2 + L'\xfffffffa',
                         handle_LYK_LINEWRAP_TOGGLE::choices,L'\b',L'\0','\x01');
    if (term_options == '\0') {
      LYtableCols = handle_LYK_LINEWRAP_TOGGLE::wrap[wVar1];
      if (wVar1 == L'\0') {
        LYshiftWin = L'\0';
      }
      LYwideLines = wVar1;
      *flag = '\x01';
      if (LYwideLines == L'\0') {
        local_18 = (char *)gettext("Linewrap ON!");
      }
      else {
        local_18 = (char *)gettext("Linewrap OFF!");
      }
      HTUserMsg(local_18);
      local_19 = reparse_or_reload(cmd);
    }
    else {
      local_19 = '\0';
    }
  }
  return local_19;
}


/*
Unable to decompile 'mainloop'
Cause: Exception while decompiling 0808641f: process: timeout

*/


// WARNING: Unknown calling convention

wchar_t are_different(DocInfo *doc1,DocInfo *doc2)

{
  BOOLEAN BVar1;
  char *pcVar2;
  char *pcVar3;
  int iVar4;
  wchar_t local_18;
  char *cp2;
  char *cp1;
  
  if ((doc1->address == (char *)0x0) || (doc2->address == (char *)0x0)) {
    local_18 = L'\x01';
  }
  else if (doc1->isHEAD == doc2->isHEAD) {
    pcVar2 = trimPoundSelector(doc1->address);
    pcVar3 = trimPoundSelector(doc2->address);
    iVar4 = strcmp(doc1->address,doc2->address);
    if (iVar4 == 0) {
      if (pcVar2 != (char *)0x0) {
        *pcVar2 = '#';
      }
      if (pcVar3 != (char *)0x0) {
        *pcVar3 = '#';
      }
      if (doc1->post_data == (bstring_conflict *)0x0) {
        if (doc2->post_data != (bstring_conflict *)0x0) {
          return L'\x01';
        }
      }
      else {
        if (doc2->post_data == (bstring_conflict *)0x0) {
          return L'\x01';
        }
        BVar1 = HTSABEql((bstring *)doc1->post_data,(bstring *)doc2->post_data);
        if (BVar1 == '\0') {
          return L'\x01';
        }
      }
      local_18 = L'\0';
    }
    else {
      if (pcVar2 != (char *)0x0) {
        *pcVar2 = '#';
      }
      if (pcVar3 != (char *)0x0) {
        *pcVar3 = '#';
      }
      local_18 = L'\x01';
    }
  }
  else {
    local_18 = L'\x01';
  }
  return local_18;
}



// WARNING: Unknown calling convention

void HTAddGotoURL(char *url)

{
  FILE *__stream;
  int iVar1;
  char *local_18;
  HTList *cur;
  char *old;
  char *copy;
  
  copy = (char *)0x0;
  if ((url != (char *)0x0) && (*url != '\0')) {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTAddGotoURL %s\n",url);
    }
    HTSACopy(&copy,url);
    if (Goto_URLs == (HTList *)0x0) {
      Goto_URLs = HTList_new();
      HTList_addObject(Goto_URLs,copy);
    }
    else {
      cur = Goto_URLs;
      do {
        if ((cur == (HTList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
          local_18 = (char *)0x0;
        }
        else {
          local_18 = (char *)cur->object;
        }
        if (local_18 == (char *)0x0) goto LAB_0808afa1;
        iVar1 = strcmp(local_18,copy);
      } while (iVar1 != 0);
      HTList_removeObject(Goto_URLs,local_18);
      if (local_18 != (char *)0x0) {
        free(local_18);
      }
LAB_0808afa1:
      HTList_addObject(Goto_URLs,copy);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void show_main_statusline(LinkInfo_conflict curlink,wchar_t for_what)

{
  int iVar1;
  wchar_t wVar2;
  char *pcVar3;
  size_t sVar4;
  char *pcVar5;
  int iVar6;
  int in_GS_OFFSET;
  char *cp;
  char *indx;
  char buf [128];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if ((user_mode == 0) && (for_what != L'\x02')) {
    noviceline((int)more_text);
  }
  wVar2 = HTisDocumentSource();
  if (wVar2 == L'\0') {
    if (((lynx_mode == '\x02') && (0 < nlinks)) &&
       ((user_mode != 2 ||
        (((undefined  [68])curlink & (undefined  [68])0x2) == (undefined  [68])0x0)))) {
      if (curlink.type == L'\x01') {
        show_formlink_statusline(curlink.l_form,for_what);
      }
      else {
        pcVar3 = (char *)gettext("(NORMAL LINK)   Use right-arrow or <return> to activate.");
        statusline(pcVar3);
      }
      if (is_www_index != '\0') {
        pcVar3 = (char *)gettext("-index-");
        iVar6 = LYcols - (uint)(LYShowScrollbar != '\0');
        sVar4 = strlen(pcVar3);
        LYmove(LYlines + L'\xffffffff',iVar6 - sVar4);
        lynx_start_reverse();
        sVar4 = strlen(pcVar3);
        LYwaddnstr(LYwin,pcVar3,sVar4);
        lynx_stop_reverse();
      }
    }
    else if ((user_mode == 2) && (0 < nlinks)) {
      cp = (char *)0x0;
      if (curlink.type == L'\x06') {
        iVar6 = strncasecomp(curlink.lname,"LYNXIMGMAP:",0xb);
        if (iVar6 != 0) {
          cp = strchr(curlink.lname,0x23);
        }
      }
      if (cp == (char *)0x0) {
        cp = curlink.lname;
      }
      status_link(cp,more_text,is_www_index);
    }
    else if ((is_www_index == '\0') || (more_text == '\0')) {
      if (is_www_index == '\0') {
        if (more_text == '\0') {
          mustshow = '\x01';
          pcVar3 = (char *)gettext(
                                  "Commands: Use arrow keys to move, \'?\' for help, \'q\' to quit, \'<-\' to go back."
                                  );
          statusline(pcVar3);
        }
        else if (user_mode == 0) {
          mustshow = '\x01';
          pcVar3 = (char *)gettext("-- press space for next page --");
          statusline(pcVar3);
        }
        else {
          mustshow = '\x01';
          pcVar3 = (char *)gettext(
                                  "-- press space for more, use arrow keys to move, \'?\' for help, \'q\' to quit."
                                  );
          statusline(pcVar3);
        }
      }
      else {
        pcVar3 = key_for_func(0x32);
        pcVar5 = (char *)gettext("This is a searchable index.  Use %s to search.");
        sprintf(buf,pcVar5,pcVar3);
        mustshow = '\x01';
        statusline(buf);
      }
    }
    else {
      pcVar3 = key_for_func(0x32);
      pcVar5 = (char *)gettext("--More--  This is a searchable index.  Use %s to search.");
      sprintf(buf,pcVar5,pcVar3);
      mustshow = '\x01';
      statusline(buf);
    }
  }
  else {
    mustshow = '\x01';
    pcVar3 = (char *)gettext(
                            "Currently viewing document source.  Press \'\\\' to return to rendered version."
                            );
    statusline(pcVar3);
  }
  if (LYShowCursor == '\0') {
    LYmove(LYlines + L'\xffffffff',(LYcols - (uint)(LYShowScrollbar != '\0')) + L'\xffffffff');
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



// WARNING: Unknown calling convention

void repaint_main_statusline(wchar_t for_what)

{
  int iVar1;
  LinkInfo *pLVar2;
  char **ppcVar3;
  LinkInfo_conflict in_stack_ffffff94;
  
  if ((L'\xffffffff' < curdoc.link) && (curdoc.link < nlinks)) {
    pLVar2 = links + curdoc.link;
    ppcVar3 = (char **)&stack0xffffff94;
    for (iVar1 = 0x11; iVar1 != 0; iVar1 = iVar1 + -1) {
      *ppcVar3 = pLVar2->lname;
      pLVar2 = (LinkInfo *)&pLVar2->target;
      ppcVar3 = ppcVar3 + 1;
    }
    show_main_statusline(in_stack_ffffff94,for_what);
  }
  return;
}



// WARNING: Unknown calling convention

void form_noviceline(wchar_t disabled)

{
  char *pcVar1;
  size_t sVar2;
  int iVar3;
  char *erasekey;
  char *temp;
  
  LYmove(LYlines + L'\xfffffffe',L'\0');
  LYclrtoeol();
  if (disabled == L'\0') {
    pcVar1 = (char *)gettext(
                            "            Enter text into the field by typing on the keyboard              "
                            );
    sVar2 = strlen(pcVar1);
    pcVar1 = (char *)gettext(
                            "            Enter text into the field by typing on the keyboard              "
                            );
    LYwaddnstr(LYwin,pcVar1,sVar2);
  }
  LYmove(LYlines + L'\xffffffff',L'\0');
  LYclrtoeol();
  if (disabled == L'\0') {
    iVar3 = EditBinding(0x15);
    if (iVar3 == 0xc) {
      pcVar1 = (char *)gettext(
                              "    Ctrl-U to delete all text in field, [Backspace] to delete a character    "
                              );
      sVar2 = strlen(pcVar1);
      pcVar1 = (char *)gettext(
                              "    Ctrl-U to delete all text in field, [Backspace] to delete a character    "
                              );
      LYwaddnstr(LYwin,pcVar1,sVar2);
    }
    else {
      iVar3 = EditBinding(0x15);
      if (iVar3 == 0x19) {
        pcVar1 = (char *)gettext(
                                "      Ctrl-U to delete text in field, [Backspace] to delete a character    "
                                );
        sVar2 = strlen(pcVar1);
        pcVar1 = (char *)gettext(
                                "      Ctrl-U to delete text in field, [Backspace] to delete a character    "
                                );
        LYwaddnstr(LYwin,pcVar1,sVar2);
      }
      else {
        temp = (char *)0x0;
        iVar3 = LYKeyForEditAction(0xc);
        erasekey = fmt_keys(iVar3,-1);
        if (erasekey == (char *)0x0) {
          iVar3 = LYKeyForEditAction(0x19);
          erasekey = fmt_keys(iVar3,-1);
          if (erasekey != (char *)0x0) {
            pcVar1 = (char *)gettext(
                                    "      %s to delete text in field, [Backspace] to delete a character    "
                                    );
            HTSprintf0(&temp,pcVar1,erasekey);
          }
        }
        else {
          pcVar1 = (char *)gettext(
                                  "    %s to delete all text in field, [Backspace] to delete a character    "
                                  );
          HTSprintf0(&temp,pcVar1,erasekey);
        }
        if (temp != (char *)0x0) {
          sVar2 = strlen(temp);
          LYwaddnstr(LYwin,temp,sVar2);
          if (temp != (char *)0x0) {
            free(temp);
            temp = (char *)0x0;
          }
        }
        if (erasekey != (char *)0x0) {
          free(erasekey);
        }
      }
    }
  }
  return;
}



void exit_immediately_with_error_message(wchar_t state,BOOLEAN first_file)

{
  char *pcVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  char **in_stack_ffffffb4;
  char *local_30;
  char *local_28;
  char *local_1c;
  BOOLEAN first_file_local;
  char *buf2;
  char *buf;
  
  buf = (char *)0x0;
  buf2 = (char *)0x0;
  if (first_file != '\0') {
    in_stack_ffffffb4 = &buf2;
    LYstatusline_messages_on_exit(in_stack_ffffffb4);
  }
  if (state != L'\0') goto LAB_0808b66d;
  if (buf2 == (char *)0x0) {
LAB_0808b60f:
    local_30 = startfile;
  }
  else {
    pcVar1 = (char *)gettext("Can\'t Access");
    pcVar1 = strstr(buf2,pcVar1);
    if (pcVar1 == (char *)0x0) goto LAB_0808b60f;
    local_30 = "";
  }
  uVar2 = gettext("lynx: Can\'t access startfile");
  if (buf2 == (char *)0x0) {
    local_28 = "";
  }
  else {
    local_28 = buf2;
  }
  in_stack_ffffffb4 = &buf;
  HTSprintf0(in_stack_ffffffb4,"%s\n%s %s\n",local_28,uVar2,local_30);
LAB_0808b66d:
  if (state == L'\x03') {
    uVar2 = gettext("      Exiting...");
    uVar3 = gettext("lynx: Start file could not be found or is not text/html or text/plain");
    if (buf2 == (char *)0x0) {
      local_1c = "";
    }
    else {
      local_1c = buf2;
    }
    in_stack_ffffffb4 = &buf;
    HTSprintf0(in_stack_ffffffb4,"%s\n%s\n%s\n",local_1c,uVar3,uVar2);
  }
  if (buf2 != (char *)0x0) {
    in_stack_ffffffb4 = (char **)buf2;
    free(buf2);
    buf2 = (char *)0x0;
  }
  if (dump_output_immediately == '\0') {
    cleanup((EVP_PKEY_CTX *)in_stack_ffffffb4);
  }
  if (dump_output_immediately == '\0') {
    fputs(buf,stdout);
  }
  else {
    fputs(buf,stderr);
  }
  if (buf != (char *)0x0) {
    free(buf);
    buf = (char *)0x0;
  }
  if (dump_output_immediately == '\0') {
    exit_immediately(1);
  }
  return;
}



void status_link(char *curlink_name,BOOLEAN show_more,BOOLEAN show_indx)

{
  int iVar1;
  char *pcVar2;
  undefined4 uVar3;
  FILE *__stream;
  int in_GS_OFFSET;
  BOOLEAN show_indx_local;
  BOOLEAN show_more_local;
  char *curlink_name_local;
  wchar_t n;
  wchar_t cut_to_pos;
  wchar_t cut_from_pos;
  char *buf;
  wchar_t length;
  wchar_t prefix;
  char format [1024];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  prefix = L'\0';
  format[0] = '\0';
  if ((show_more != '\0') && (nomore == '\0')) {
    uVar3 = gettext("-more-");
    sprintf(format,"%.*s ",0x3fe,uVar3);
    prefix = strlen(format);
  }
  if (show_indx != '\0') {
    uVar3 = gettext("-index-");
    sprintf(format + prefix,"%.*s ",0x3fe - prefix,uVar3);
  }
  prefix = strlen(format);
  length = strlen(curlink_name);
  if (((LYcols - (uint)(LYShowScrollbar != '\0')) + L'\xffffffff' < prefix) || (L'' < prefix)) {
    mustshow = '\x01';
    user_message("%s",format);
  }
  else {
    sprintf(format + prefix,"%%.%ds",((LYcols - (uint)(LYShowScrollbar != '\0')) + -1) - prefix);
    if (((int)((LYcols - (uint)(LYShowScrollbar != '\0')) + -1) < length + prefix) &&
       (long_url_ok != '\0')) {
      buf = (char *)0x0;
      HTSACopy(&buf,curlink_name);
      for (cut_to_pos = length + L'\xfffffffe'; (L'\0' < cut_to_pos && (buf[cut_to_pos] != '/'));
          cut_to_pos = cut_to_pos + L'\xffffffff') {
      }
      for (cut_from_pos = cut_to_pos + L'\xfffffffc';
          (L'\0' < cut_from_pos &&
          ((buf[cut_from_pos] != '/' ||
           ((int)((LYcols - (uint)(LYShowScrollbar != '\0')) + -1) <=
            prefix + cut_from_pos + 4 + (length - cut_to_pos)))));
          cut_from_pos = cut_from_pos + L'\xffffffff') {
      }
      if (L'\0' < cut_from_pos) {
        for (n = L'\x01'; n < L'\x04'; n = n + L'\x01') {
          buf[cut_from_pos + n] = '.';
        }
        for (n = L'\0'; cut_to_pos + n <= length; n = n + L'\x01') {
          buf[cut_from_pos + L'\x04' + n] = buf[cut_to_pos + n];
        }
      }
      mustshow = '\x01';
      user_message(format,buf);
      pcVar2 = buf;
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"lastline = %s\n",pcVar2);
      }
      if (buf != (char *)0x0) {
        free(buf);
        buf = (char *)0x0;
      }
    }
    else {
      mustshow = '\x01';
      user_message(format,curlink_name);
    }
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



// WARNING: Unknown calling convention

char * LYDownLoadAddress(void)

{
  char *local_8;
  
  if (newdoc.address == (char *)0x0) {
    local_8 = "";
  }
  else {
    local_8 = newdoc.address;
  }
  return local_8;
}



// WARNING: Unknown calling convention

wchar_t string_to_attr(char *name)

{
  int iVar1;
  uint i;
  
  i = 0;
  while( true ) {
    if (6 < i) {
      return L'\0';
    }
    iVar1 = strcasecomp(Mono_Attrs[i].name,name);
    if (iVar1 == 0) break;
    i = i + 1;
  }
  return Mono_Attrs[i].code;
}



// WARNING: Unknown calling convention

char * attr_to_string(wchar_t code)

{
  bool bVar1;
  uint uVar2;
  uint uVar3;
  int iVar4;
  char *pcVar5;
  char *pcVar6;
  size_t sVar7;
  undefined *__src;
  size_t __n;
  int local_28;
  char *bg;
  char *fg;
  wchar_t bold;
  wchar_t pair;
  uint i;
  short b;
  short f;
  
  uVar2 = code & 0xff00;
  uVar3 = uVar2 >> 8;
  if ((uVar3 == 0) || ((code & 0x200000U) == 0)) {
    bVar1 = false;
  }
  else {
    bVar1 = true;
  }
  if (bVar1) {
    code = code & 0xffdfffff;
  }
  attr_to_string::result[0] = '\0';
  for (i = 0; i < 7; i = i + 1) {
    if ((Mono_Attrs[i].code & code) != 0) {
      if (attr_to_string::result[0] != '\0') {
        __n = 2;
        __src = &DAT_08155669;
        sVar7 = strlen(attr_to_string::result);
        memcpy(attr_to_string::result + sVar7,__src,__n);
      }
      strcat(attr_to_string::result,Mono_Attrs[i].name);
    }
  }
  if (uVar3 != 0) {
    iVar4 = pair_content((short)(uVar2 >> 8),&f,&b);
    if (iVar4 != -1) {
      if (bVar1) {
        local_28 = f + COLORS;
      }
      else {
        local_28 = (int)f;
      }
      pcVar5 = lookup_color(local_28);
      pcVar6 = lookup_color((int)b);
      if (attr_to_string::result[0] != '\0') {
        strcat(attr_to_string::result,"+");
      }
      sVar7 = strlen(attr_to_string::result);
      sprintf(attr_to_string::result + sVar7,"%s/%s",pcVar5,pcVar6);
    }
  }
  return attr_to_string::result;
}



void LYbox(WINDOW *win,BOOLEAN formfield)

{
  BOOLEAN formfield_local;
  wchar_t boxhori;
  wchar_t boxvert;
  
  UCSetBoxChars(current_char_set,&boxvert,&boxhori,0,0);
  curses_w_style(win,s_menu_frame,L'\x01');
  if ((boxvert == L'\0') || (boxhori == L'\0')) {
    wborder(win,boxvert,boxvert,boxhori,boxhori,0,0,0,0);
  }
  else if ((boxvert == L'*') || (boxhori == L'*')) {
    wborder(win,boxvert,boxvert,boxhori,boxhori,0x2a,0x2a,0x2a,0x2a);
  }
  else {
    wborder(win,boxvert,boxvert,boxhori,boxhori,0x2f,0x5c,0x5c,0x2f);
  }
  curses_w_style(win,s_menu_frame,L'\0');
  wrefresh(win);
  return;
}



// WARNING: Unknown calling convention

void setStyle(wchar_t style,wchar_t color,wchar_t cattr,wchar_t mono)

{
  displayStyles[style].color = color;
  displayStyles[style].cattr = cattr;
  displayStyles[style].mono = mono;
  return;
}



// WARNING: Unknown calling convention

void setHashStyle(wchar_t style,wchar_t color,wchar_t cattr,wchar_t mono,char *element)

{
  bucket_conflict *dest;
  FILE *__stream;
  bucket *ds;
  
  dest = hashStyles + style;
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"CSS(SET): <%s> hash=%d, ca=%#x, ma=%#x\n",element,style,color,mono);
  }
  hashStyles[style].color = color;
  hashStyles[style].cattr = cattr;
  hashStyles[style].mono = mono;
  hashStyles[style].code = style;
  if (dest->name != (char *)0x0) {
    free(dest->name);
    dest->name = (char *)0x0;
  }
  HTSACopy(&dest->name,element);
  return;
}



// WARNING: Unknown calling convention

void LYAttrset(WINDOW *win,wchar_t color,wchar_t mono)

{
  char *pcVar1;
  FILE *pFVar2;
  
  if (((lynx_has_color == L'\0') || (LYShowColor < 2)) || (color < L'\0')) {
    if (mono < L'\0') {
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2,"CSS:LYAttrset (A_NORMAL)\n");
      }
      win->_attrs = 0;
    }
    else {
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
        pcVar1 = attr_to_string(mono);
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2,"CSS:LYAttrset mono %#x -> (%s)\n",mono,pcVar1);
      }
      win->_attrs = mono;
    }
  }
  else {
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
      pcVar1 = attr_to_string(color);
      pFVar2 = TraceFP();
      fprintf((FILE *)pFVar2,"CSS:LYAttrset color %#x -> (%s)\n",color,pcVar1);
    }
    win->_attrs = color;
  }
  return;
}



// WARNING: Unknown calling convention

void curses_w_style(WINDOW *win,wchar_t style,wchar_t dir)

{
  int iVar1;
  int iVar2;
  char *pcVar3;
  FILE *pFVar4;
  long lVar5;
  bucket_conflict *local_34;
  undefined *local_24;
  int local_20;
  int local_1c;
  wchar_t last_attr;
  bucket *ds;
  wchar_t XP;
  wchar_t YP;
  
  if (style == L'\xffffffff') {
    local_34 = &nostyle_bucket;
  }
  else {
    local_34 = hashStyles + style;
  }
  if (local_34->name == (char *)0x0) {
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"CSS.CS:Style %d not configured\n",style);
    }
  }
  else {
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
      iVar1 = local_34->color;
      iVar2 = local_34->code;
      pcVar3 = local_34->name;
      if (dir == L'\0') {
        local_24 = &DAT_0815571d;
      }
      else {
        local_24 = &DAT_0815571c;
      }
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"CSS.CS:<%s%s> style %d code %#x, color %#x\n",local_24,pcVar3,style,
              iVar2,iVar1);
    }
    if (win == (WINDOW *)0x0) {
      local_20 = -1;
      local_1c = -1;
    }
    else {
      local_20 = (int)win->_cury;
      local_1c = (int)win->_curx;
    }
    if ((style == s_normal) && (dir != L'\0')) {
      LYAttrset(win,local_34->color,local_34->mono);
      if (win == LYwin) {
        SetCachedStyle(local_20,local_1c,s_normal);
      }
    }
    else {
      if (dir == L'\x01') {
        if (0x7f < last_colorattr_ptr) {
          if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
            iVar1 = last_styles[last_colorattr_ptr];
            pFVar4 = TraceFP();
            fprintf((FILE *)pFVar4,"........... %s (0x%x) %s\r\n",
                    "attribute cache FULL, dropping last",iVar1,"in LynxChangeStyle(curses_w_style)"
                   );
          }
          last_colorattr_ptr = 0x7f;
        }
        iVar1 = last_colorattr_ptr;
        lVar5 = LYgetattrs(win);
        last_styles[iVar1] = lVar5;
        last_colorattr_ptr = iVar1 + 1;
      }
      else if (dir != L'\x02') {
        if (dir != L'\0') {
          return;
        }
        if (last_colorattr_ptr != 0) {
          last_colorattr_ptr = last_colorattr_ptr + -1;
          LYAttrset(win,last_styles[last_colorattr_ptr],last_styles[last_colorattr_ptr]);
          return;
        }
        LYAttrset(win,L'\0',L'\xffffffff');
        return;
      }
      if (((((style != s_alink) && (style != s_curedit)) && (style != s_aedit)) &&
          ((style != s_aedit_sel && (style != s_aedit_pad)))) && (style != s_aedit_arr)) {
        if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
          pcVar3 = local_34->name;
          pFVar4 = TraceFP();
          fprintf((FILE *)pFVar4,"CACHED: <%s> @(%d,%d)\n",pcVar3,local_20,local_1c);
        }
        if (win == LYwin) {
          SetCachedStyle(local_20,local_1c,style);
        }
      }
      LYAttrset(win,local_34->color,local_34->mono);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void wcurses_css(WINDOW *win,char *name,wchar_t dir)

{
  bool bVar1;
  int iVar2;
  FILE *pFVar3;
  char *pcVar4;
  wchar_t style;
  char *pclass;
  wchar_t tmpHash;
  wchar_t try_again;
  
  bVar1 = true;
  while (bVar1) {
    iVar2 = hash_code(name);
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
      pFVar3 = TraceFP();
      fprintf((FILE *)pFVar3,"CSSTRIM:trying to set [%s] style - ",name);
    }
    if (iVar2 == -1) {
      pcVar4 = strrchr(name,0x2e);
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
        pFVar3 = TraceFP();
        fprintf((FILE *)pFVar3,"undefined, trimming at %p\n",pcVar4);
      }
      if (pcVar4 == (char *)0x0) {
        bVar1 = false;
      }
      else {
        *pcVar4 = '\0';
      }
    }
    else {
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
        iVar2 = hash_code(name);
        pFVar3 = TraceFP();
        fprintf((FILE *)pFVar3,"ok (%d)\n",iVar2);
      }
      style = hash_code(name);
      curses_w_style(win,style,dir);
      bVar1 = false;
    }
  }
  return;
}



// WARNING: Unknown calling convention

void curses_css(char *name,wchar_t dir)

{
  wcurses_css(LYwin,name,dir);
  return;
}



// WARNING: Unknown calling convention

void curses_style(wchar_t style,wchar_t dir)

{
  curses_w_style(LYwin,style,dir);
  return;
}



// WARNING: Unknown calling convention

wchar_t get_color_pair(wchar_t n)

{
  wchar_t local_8;
  
  if (((n < L'\x19') && (lynx_color_pairs[n].fg == default_fg)) &&
     (lynx_color_pairs[n].bg == default_bg)) {
    local_8 = L'\0';
  }
  else {
    local_8 = n << 8;
  }
  return local_8;
}



// WARNING: Unknown calling convention

wchar_t lynx_color_cfg_attr(wchar_t code)

{
  wchar_t fg;
  wchar_t result;
  
  result = L'\0';
  if ((((L'\xffffffff' < code) && (code < L'\b')) &&
      (COLORS + L'\xffffffff' < lynx_color_cfg[code].fg)) &&
     ((COLORS & lynx_color_cfg[code].fg) != 0)) {
    result = L'\x00200000';
  }
  return result;
}



// WARNING: Unknown calling convention

wchar_t encode_color_attr(wchar_t color_attr)

{
  wchar_t wVar1;
  wchar_t offs;
  wchar_t code;
  wchar_t result;
  
  code = (wchar_t)((color_attr & 0x200000U) != 0);
  if ((color_attr & 0x140000U) != 0) {
    code = code | 2;
  }
  if ((color_attr & 0x20000U) != 0) {
    code = code | 4;
  }
  result = lynx_color_cfg_attr(code);
  if (code + L'\x01' < COLOR_PAIRS) {
    wVar1 = get_color_pair(code + L'\x01');
    result = result | wVar1;
  }
  return result;
}



// WARNING: Unknown calling convention

wchar_t decode_mono_code(wchar_t mono_code)

{
  wchar_t result;
  
  result = L'\0';
  if ((mono_code & 1U) != 0) {
    result = L'\x00200000';
  }
  if ((mono_code & 2U) != 0) {
    result = result | 0x40000;
  }
  if ((mono_code & 4U) != 0) {
    result = result | 0x20000;
  }
  return result;
}



// WARNING: Unknown calling convention

wchar_t LYgetTableAttr(void)

{
  wchar_t result;
  
  if ((lynx_has_color == L'\0') || (LYShowColor < 2)) {
    result = Current_Attr;
  }
  else {
    result = encode_color_attr(Current_Attr);
  }
  return ~Masked_Attr & result;
}



// WARNING: Unknown calling convention

char * LYgetTableString(wchar_t code)

{
  FILE *pFVar1;
  char *pcVar2;
  char *result;
  uint n;
  wchar_t bg;
  wchar_t fg;
  wchar_t mono;
  wchar_t pair;
  wchar_t second;
  wchar_t mask;
  
  mask = decode_mono_code(code);
  second = encode_color_attr(mask);
  pair = (uint)(second & 0xff00U) >> 8;
  mono = mask & 0xffffff00;
  fg = lynx_color_pairs[pair].fg;
  bg = lynx_color_pairs[pair].bg;
  result = (char *)0x0;
  if (WWW_TraceFlag != '\0') {
    pFVar1 = TraceFP();
    fprintf((FILE *)pFVar1,"LYgetTableString(%d)\n",code);
  }
  if ((fg == L'\0') && (bg == L'\0')) {
    fg = L'\a';
  }
  if (WWW_TraceFlag != '\0') {
    pFVar1 = TraceFP();
    fprintf((FILE *)pFVar1,"%#x -> %#x (mono %#x pair %d) fg=%d, bg=%d\n",mask,second,mono,pair,fg,
            bg);
  }
  for (n = 0; n < 7; n = n + 1) {
    if ((Mono_Attrs[n].code & mono) != 0) {
      if (result != (char *)0x0) {
        HTSACat(&result,"+");
      }
      HTSACat(&result,Mono_Attrs[n].name);
    }
  }
  if (result == (char *)0x0) {
    HTSACopy(&result,"normal");
  }
  HTSACat(&result,":");
  pcVar2 = lookup_color(fg);
  HTSACat(&result,pcVar2);
  if (L'\xffffffff' < bg) {
    HTSACat(&result,":");
    pcVar2 = lookup_color(bg);
    HTSACat(&result,pcVar2);
  }
  pcVar2 = result;
  if (WWW_TraceFlag != '\0') {
    pFVar1 = TraceFP();
    fprintf((FILE *)pFVar1,"->%s\n",pcVar2);
  }
  return result;
}



// WARNING: Unknown calling convention

void lynx_init_color_pair(wchar_t n)

{
  return;
}



// WARNING: Unknown calling convention

void lynx_map_color(wchar_t n)

{
  FILE *__stream;
  wchar_t j;
  
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"lynx_map_color(%d)\n",n);
  }
  if (n + L'\x01' < 0x19) {
    for (j = n + L'\x01'; j < L'\x19'; j = j + L'\b') {
      lynx_color_pairs[j].fg = lynx_color_cfg[n].fg;
      lynx_color_pairs[j].bg = lynx_color_cfg[n].bg;
    }
    lynx_color_pairs[n + L'\t'].bg = lynx_color_cfg[0].bg;
  }
  lynx_init_color_pair(n);
  return;
}



// WARNING: Unknown calling convention

wchar_t lynx_chg_color(wchar_t color,wchar_t fg,wchar_t bg)

{
  FILE *__stream;
  wchar_t local_8;
  
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"lynx_chg_color(color=%d, fg=%d, bg=%d)\n",color,fg,bg);
  }
  if ((fg == L'\xfffffffd') || (bg == L'\xfffffffd')) {
    local_8 = L'\xffffffff';
  }
  else if ((color < L'\0') || (L'\a' < color)) {
    local_8 = L'\xffffffff';
  }
  else {
    lynx_color_cfg[color].fg = fg;
    lynx_color_cfg[color].bg = bg;
    lynx_map_color(color);
    local_8 = L'\0';
  }
  return local_8;
}



// WARNING: Unknown calling convention

void lynx_set_color(wchar_t a)

{
  WINDOW *pWVar1;
  wchar_t wVar2;
  wchar_t local_8;
  
  pWVar1 = LYwin;
  if ((lynx_has_color != L'\0') && (1 < LYShowColor)) {
    wVar2 = lynx_color_cfg_attr(a);
    if (a + L'\x01' < COLOR_PAIRS) {
      local_8 = get_color_pair(a + L'\x01');
    }
    else {
      local_8 = L'\0';
    }
    pWVar1->_attrs = wVar2 | local_8;
  }
  return;
}



// WARNING: Unknown calling convention

void lynx_standout(wchar_t flag)

{
  if (flag == L'\0') {
    wattr_off(LYwin,0x40000,0);
  }
  else {
    wattr_on(LYwin,0x40000,0);
  }
  return;
}



// WARNING: Unknown calling convention

void lynx_init_colors(void)

{
  int iVar1;
  int iVar2;
  FILE *__stream;
  size_t n;
  
  iVar2 = default_bg;
  iVar1 = default_fg;
  if (lynx_has_color == L'\0') {
    if (LYShowColor != 0) {
      LYShowColor = 1;
    }
  }
  else {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"lynx_init_colors (default %d/%d)\n",iVar1,iVar2);
    }
    lynx_color_cfg[0].fg = default_fg;
    lynx_color_cfg[0].bg = default_bg;
    for (n = 0; n < 8; n = n + 1) {
      lynx_init_color_pair(n);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void lynx_setup_colors(void)

{
  FILE *__stream;
  wchar_t n;
  
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"lynx_setup_colors\n");
  }
  if (LYuse_default_colors == '\0') {
    for (n = L'\0'; n < L'\b'; n = n + L'\x01') {
      if (lynx_color_cfg[n].dft_fg != L'\0') {
        lynx_color_cfg[n].fg = L'\0';
      }
      if (lynx_color_cfg[n].dft_bg != L'\0') {
        lynx_color_cfg[n].bg = L'\a';
      }
    }
  }
  for (n = L'\0'; n < L'\b'; n = n + L'\x01') {
    lynx_map_color(n);
  }
  return;
}



// WARNING: Unknown calling convention

void LYnoVideo(wchar_t a)

{
  FILE *__stream;
  
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"LYnoVideo(%d)\n",a);
  }
  Masked_Attr = decode_mono_code(a);
  return;
}



// WARNING: Unknown calling convention

void start_curses(void)

{
  wchar_t wVar1;
  bool bVar2;
  int iVar3;
  char cVar4;
  BOOLEAN BVar5;
  int iVar6;
  wchar_t wVar7;
  FILE *pFVar8;
  undefined4 uVar9;
  uint n;
  wchar_t keypad_on;
  BOOLEAN savesize;
  
  bVar2 = false;
  iVar6 = fileno(stdout);
  iVar6 = isatty(iVar6);
  if (iVar6 != 0) {
    wVar7 = LYReopenInput();
    if (wVar7 < L'\0') {
      fwrite("Cannot open tty input\n",1,0x16,stderr);
      exit_immediately(1);
    }
  }
  BVar5 = recent_sizechange;
  if (LYscreen == (WINDOW *)0x0) {
    size_change(L'\0');
    recent_sizechange = BVar5;
    if (WWW_TraceFlag != '\0') {
      pFVar8 = TraceFP();
      fprintf((FILE *)pFVar8,"Screen size: %s()\n","initscr");
    }
    LYscreen = (WINDOW *)initscr();
    if (LYscreen == (WINDOW *)0x0) {
      uVar9 = gettext("Terminal initialisation failed - unknown terminal type?");
      pFVar8 = TraceFP();
      fprintf((FILE *)pFVar8,"%s\n",uVar9);
      exit_immediately(1);
    }
    lynx_called_initscr = '\x01';
    LYlines = LYscreenHeight();
    LYcols = LYscreenWidth();
    size_change(L'\0');
    iVar3 = LYlines;
    iVar6 = LYcols;
    recent_sizechange = '\0';
    if (WWW_TraceFlag != '\0') {
      pFVar8 = TraceFP();
      fprintf((FILE *)pFVar8,"Screen size is now %d x %d\n",iVar3,iVar6);
    }
    if (LYuseCursesPads == '\0') {
      LYwin = stdscr;
    }
    else {
      LYwin = (WINDOW *)newpad(LYlines,0x3f6);
      LYshiftWin = L'\0';
      LYwideLines = L'\0';
    }
    keypad(LYwin,1);
    bVar2 = true;
    wVar7 = lynx_initialize_keymaps();
    if (wVar7 == L'\xffffffff') {
      endwin();
      exit_immediately(1);
    }
    cVar4 = has_colors();
    if (cVar4 != '\0') {
      lynx_has_color = L'\x01';
      start_color();
      if (0x10 < COLORS) {
        COLORS = 0x10;
      }
      if (COLORS < 8) {
        COLORS = 2;
      }
      if ((8 < COLORS) && (COLORS != 0x10)) {
        COLORS = 8;
      }
      if (LYuse_default_colors != '\0') {
        iVar6 = assume_default_colors(default_fg,default_bg);
        if (iVar6 != 0) {
          default_fg = 7;
          default_bg = 0;
        }
        iVar3 = default_bg;
        iVar6 = default_fg;
        if (WWW_TraceFlag != '\0') {
          pFVar8 = TraceFP();
          fprintf((FILE *)pFVar8,"initializing default colors %d/%d\n",iVar6,iVar3);
        }
        if ((-1 < default_fg) || (-1 < default_bg)) {
          for (n = 0; n < 8; n = n + 1) {
            if ((-1 < default_fg) && (lynx_color_cfg[n].fg < L'\0')) {
              lynx_color_cfg[n].fg = default_fg;
            }
            if ((-1 < default_bg) && (lynx_color_cfg[n].bg < L'\0')) {
              lynx_color_cfg[n].bg = default_bg;
            }
            if (WWW_TraceFlag != '\0') {
              wVar7 = lynx_color_cfg[n].bg;
              wVar1 = lynx_color_cfg[n].fg;
              pFVar8 = TraceFP();
              fprintf((FILE *)pFVar8,"color_cfg[%u] = %d/%d\n",n,wVar1,wVar7);
            }
          }
          lynx_setup_colors();
        }
      }
    }
    if ((lynx_lss_file != (char *)0x0) && (*lynx_lss_file != '\0')) {
      BVar5 = LYCanReadFile(lynx_lss_file);
      if (BVar5 != '\0') {
        style_readFromFile(lynx_lss_file);
      }
    }
    parse_userstyles();
    lynx_init_colors();
  }
  cbreak();
  signal(2,cleanup_sig);
  noecho();
  if (!bVar2) {
    keypad(LYwin,1);
  }
  lynx_enable_mouse(L'\x01');
  fflush(stdin);
  fflush(stdout);
  fflush(stderr);
  LYCursesON = '\x01';
  if (WWW_TraceFlag != '\0') {
    pFVar8 = TraceFP();
    fprintf((FILE *)pFVar8,"start_curses: done.\n");
  }
  return;
}



// WARNING: Unknown calling convention

void lynx_enable_mouse(wchar_t state)

{
  int iVar1;
  wchar_t old;
  
  if (LYUseMouse != '\0') {
    if (state == L'\0') {
      mousemask(0,0);
    }
    else {
      if (lynx_enable_mouse::was == L'\0') {
        iVar1 = mouseinterval(0xffffffff);
        lynx_enable_mouse::was = lynx_enable_mouse::was + L'\x01';
        if (iVar1 < 200) {
          mouseinterval(300);
        }
      }
      mousemask(0x501f1df,0);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void lynx_nl2crlf(wchar_t normal)

{
  int iVar1;
  
  iVar1 = cur_term;
  if (lynx_nl2crlf::did_save == L'\0') {
    if (cur_term == 0) {
      lynx_nl2crlf::can_fix = L'\0';
    }
    else {
      lynx_nl2crlf::saved_tty.c_iflag = *(tcflag_t *)(cur_term + 0x68);
      lynx_nl2crlf::saved_tty.c_oflag = *(tcflag_t *)(cur_term + 0x6c);
      lynx_nl2crlf::saved_tty.c_cflag = *(tcflag_t *)(cur_term + 0x70);
      lynx_nl2crlf::saved_tty.c_lflag = *(tcflag_t *)(cur_term + 0x74);
      lynx_nl2crlf::saved_tty._16_4_ = *(undefined4 *)(cur_term + 0x78);
      lynx_nl2crlf::saved_tty.c_cc._3_4_ = *(undefined4 *)(cur_term + 0x7c);
      lynx_nl2crlf::saved_tty.c_cc._7_4_ = *(undefined4 *)(cur_term + 0x80);
      lynx_nl2crlf::saved_tty.c_cc._11_4_ = *(undefined4 *)(cur_term + 0x84);
      lynx_nl2crlf::saved_tty.c_cc._15_4_ = *(undefined4 *)(cur_term + 0x88);
      lynx_nl2crlf::saved_tty.c_cc._19_4_ = *(undefined4 *)(cur_term + 0x8c);
      lynx_nl2crlf::saved_tty.c_cc._23_4_ = *(undefined4 *)(cur_term + 0x90);
      lynx_nl2crlf::saved_tty.c_cc._27_4_ = *(undefined4 *)(cur_term + 0x94);
      lynx_nl2crlf::saved_tty._48_4_ = *(undefined4 *)(cur_term + 0x98);
      lynx_nl2crlf::saved_tty.c_ispeed = *(speed_t *)(cur_term + 0x9c);
      lynx_nl2crlf::saved_tty.c_ospeed = *(speed_t *)(cur_term + 0xa0);
      lynx_nl2crlf::did_save = L'\x01';
    }
  }
  if (lynx_nl2crlf::can_fix != L'\0') {
    if (normal == L'\0') {
      if (lynx_nl2crlf::waiting != L'\0') {
        *(tcflag_t *)(cur_term + 0x68) = lynx_nl2crlf::saved_tty.c_iflag;
        *(tcflag_t *)(iVar1 + 0x6c) = lynx_nl2crlf::saved_tty.c_oflag;
        *(tcflag_t *)(iVar1 + 0x70) = lynx_nl2crlf::saved_tty.c_cflag;
        *(tcflag_t *)(iVar1 + 0x74) = lynx_nl2crlf::saved_tty.c_lflag;
        *(undefined4 *)(iVar1 + 0x78) = lynx_nl2crlf::saved_tty._16_4_;
        *(undefined4 *)(iVar1 + 0x7c) = lynx_nl2crlf::saved_tty.c_cc._3_4_;
        *(undefined4 *)(iVar1 + 0x80) = lynx_nl2crlf::saved_tty.c_cc._7_4_;
        *(undefined4 *)(iVar1 + 0x84) = lynx_nl2crlf::saved_tty.c_cc._11_4_;
        *(undefined4 *)(iVar1 + 0x88) = lynx_nl2crlf::saved_tty.c_cc._15_4_;
        *(undefined4 *)(iVar1 + 0x8c) = lynx_nl2crlf::saved_tty.c_cc._19_4_;
        *(undefined4 *)(iVar1 + 0x90) = lynx_nl2crlf::saved_tty.c_cc._23_4_;
        *(undefined4 *)(iVar1 + 0x94) = lynx_nl2crlf::saved_tty.c_cc._27_4_;
        *(undefined4 *)(iVar1 + 0x98) = lynx_nl2crlf::saved_tty._48_4_;
        *(speed_t *)(iVar1 + 0x9c) = lynx_nl2crlf::saved_tty.c_ispeed;
        *(speed_t *)(iVar1 + 0xa0) = lynx_nl2crlf::saved_tty.c_ospeed;
        iVar1 = fileno(stdout);
        tcsetattr(iVar1,1,(termios *)&lynx_nl2crlf::saved_tty);
        lynx_nl2crlf::waiting = L'\0';
        nl();
        LYrefresh();
      }
    }
    else if (lynx_nl2crlf::waiting == L'\0') {
      *(uint *)(cur_term + 0x6c) = *(uint *)(cur_term + 0x6c) | 4;
      lynx_nl2crlf::waiting = L'\x01';
      nonl();
    }
  }
  return;
}



// WARNING: Unknown calling convention

void stop_curses(void)

{
  FILE *__stream;
  
  if (LYCursesON != '\0') {
    FreeCachedStyles();
    echo();
  }
  if (LYCursesON == '\x01') {
    lynx_nl2crlf(L'\x01');
    lynx_enable_mouse(L'\0');
    if ((LYscreen != (WINDOW *)0x0) || (lynx_called_initscr != '\0')) {
      endwin();
    }
  }
  fflush(stdout);
  fflush(stderr);
  LYCursesON = '\0';
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"stop_curses: done.\n");
  }
  signal(2,(__sighandler_t)0x0);
  return;
}



// WARNING: Unknown calling convention

BOOLEAN setup(char *terminal)

{
  char *pcVar1;
  wchar_t wVar2;
  undefined4 uVar3;
  int iVar4;
  char *cp;
  char *buffer;
  char *term_putenv;
  
  term_putenv = (char *)0x0;
  buffer = (char *)0x0;
  pcVar1 = LYgetXDisplay();
  if (pcVar1 == (char *)0x0) {
    if (x_display != (char *)0x0) {
      free(x_display);
      x_display = (char *)0x0;
    }
  }
  else {
    HTSACopy(&x_display,pcVar1);
  }
  if (terminal != (char *)0x0) {
    HTSprintf0(&term_putenv,"TERM=%.106s",terminal);
    putenv(term_putenv);
  }
  pcVar1 = LYGetEnv("TERM");
  wVar2 = dumbterm(pcVar1);
  if (wVar2 != L'\0') {
    uVar3 = gettext("Your Terminal type is unknown!");
    printf("\n\n  %s\n\n",uVar3);
    uVar3 = gettext("Enter a terminal type:");
    printf("  %s [vt100] ",uVar3);
    pcVar1 = LYSafeGets(&buffer,stdin);
    if (pcVar1 != (char *)0x0) {
      LYTrimLeading(buffer);
      LYTrimTrailing(buffer);
    }
    if ((buffer == (char *)0x0) || (*buffer == '\0')) {
      HTSACopy(&buffer,"vt100");
    }
    HTSprintf0(&term_putenv,"TERM=%.106s",buffer);
    if (buffer != (char *)0x0) {
      free(buffer);
      buffer = (char *)0x0;
    }
    putenv(term_putenv);
    pcVar1 = LYGetEnv("TERM");
    uVar3 = gettext("TERMINAL TYPE IS SET TO");
    printf("\n%s %s\n",uVar3,pcVar1);
    LYSleepMsg();
  }
  start_curses();
  iVar4 = strncmp(ttytype,"sun",3);
  if (iVar4 == 0) {
    LYnoVideo(L'\x02');
  }
  LYlines = LYscreenHeight();
  LYcols = LYscreenWidth();
  return '\x01';
}



// WARNING: Unknown calling convention

wchar_t dumbterm(char *terminal)

{
  int iVar1;
  wchar_t dumb;
  
  if ((((terminal != (char *)0x0) && (iVar1 = strcasecomp(terminal,"network"), iVar1 != 0)) &&
      (iVar1 = strcasecomp(terminal,"unknown"), iVar1 != 0)) &&
     (((iVar1 = strcasecomp(terminal,"dialup"), iVar1 != 0 &&
       (iVar1 = strcasecomp(terminal,"dumb"), iVar1 != 0)) &&
      ((iVar1 = strcasecomp(terminal,"switch"), iVar1 != 0 &&
       (iVar1 = strcasecomp(terminal,"ethernet"), iVar1 != 0)))))) {
    return L'\0';
  }
  return L'\x01';
}



// WARNING: Unknown calling convention

void LYpaddstr(WINDOW *the_window,wchar_t width,char *the_string)

{
  bool bVar1;
  int local_1c;
  wchar_t actual;
  wchar_t x;
  wchar_t y;
  
  actual = strlen(the_string);
  if (the_window == (WINDOW *)0x0) {
    local_1c = -1;
  }
  else {
    local_1c = (int)the_window->_curx;
  }
  if ((int)(LYcols - (uint)(LYShowScrollbar != '\0')) < width + local_1c) {
    width = (LYcols - (uint)(LYShowScrollbar != '\0')) - local_1c;
  }
  if (width < actual) {
    actual = width;
  }
  LYwaddnstr(the_window,the_string,actual);
  width = width - actual;
  while (bVar1 = L'\0' < width, width = width + L'\xffffffff', bVar1) {
    waddnstr(the_window,&DAT_08155a7f,0xffffffff);
  }
  return;
}



// WARNING: Unknown calling convention

void LYsubwindow(WINDOW *param)

{
  uint uVar1;
  int local_18;
  long b;
  
  if (param == (WINDOW *)0x0) {
    if (LYwin == (WINDOW *)0x0) {
      local_18 = -1;
    }
    else {
      local_18 = LYwin->_maxy + 1;
    }
    wtouchln(LYwin,0,local_18,1);
    delwin(my_subwindow);
    my_subwindow = (WINDOW *)0x0;
  }
  else {
    my_subwindow = param;
    keypad(param,1);
    curses_w_style(my_subwindow,s_menu_bg,L'\x01');
    uVar1 = LYgetattrs(my_subwindow);
    wbkgd(my_subwindow,uVar1 | 0x20);
    curses_w_style(my_subwindow,s_menu_bg,L'\0');
    scrollok(my_subwindow,1);
  }
  return;
}



// WARNING: Unknown calling convention

WINDOW * LYtopwindow(void)

{
  WINDOW *local_8;
  
  if (my_subwindow == (WINDOW *)0x0) {
    local_8 = LYwin;
  }
  else {
    local_8 = my_subwindow;
  }
  return local_8;
}



// WARNING: Unknown calling convention

WINDOW * LYstartPopup(wchar_t *top_y,wchar_t *left_x,wchar_t *height,wchar_t *width)

{
  char *Msg;
  WINDOW *form_window;
  
  form_window = (WINDOW *)0x0;
  if ((L'\0' < *left_x) && (*left_x + *width + 4 < (int)(LYcols - (uint)(LYShowScrollbar != '\0'))))
  {
    form_window = (WINDOW *)newwin(*height,*width + L'\x04',*top_y,*left_x + L'\xffffffff');
  }
  if (form_window == (WINDOW *)0x0) {
    if ((LYcols - (uint)(LYShowScrollbar != '\0')) + L'\xfffffffc' < *width) {
      *width = (LYcols - (uint)(LYShowScrollbar != '\0')) + L'\xfffffffc';
      *left_x = L'\x01';
    }
    else {
      *left_x = ((LYcols - (uint)(LYShowScrollbar != '\0')) + -4) - *width;
      if (*left_x < L'\x01') {
        *left_x = L'\x01';
      }
    }
    form_window = (WINDOW *)newwin(*height,*width + L'\x04',*top_y,*left_x + L'\xffffffff');
  }
  if (form_window == (WINDOW *)0x0) {
    Msg = (char *)gettext("Unable to create popup window!");
    HTAlert(Msg);
  }
  else {
    LYsubwindow(form_window);
  }
  return form_window;
}



// WARNING: Unknown calling convention

void LYstartTargetEmphasis(void)

{
  if (s_whereis == -1) {
    lynx_start_bold();
    lynx_start_reverse();
    lynx_start_underline();
  }
  else {
    curses_style(s_whereis,L'\x01');
  }
  return;
}



// WARNING: Unknown calling convention

void LYstopTargetEmphasis(void)

{
  if (s_whereis == -1) {
    lynx_stop_underline();
    lynx_stop_reverse();
    lynx_stop_bold();
  }
  else {
    curses_style(s_whereis,L'\0');
  }
  return;
}



// WARNING: Unknown calling convention

void LYtouchline(wchar_t row)

{
  wtouchln(LYwin,row,1,1);
  return;
}



// WARNING: Unknown calling convention

void LYwaddnstr(WINDOW *w,char *src,size_t len)

{
  WINDOW *w_00;
  FILE *__stream;
  int local_50;
  int local_4c;
  int local_48;
  int local_44;
  int local_40;
  int local_3c;
  int local_34;
  wchar_t local_2c;
  WINDOW *sub;
  size_t inx;
  wchar_t x;
  wchar_t y;
  wchar_t x0;
  wchar_t y0;
  
  if (LYwin == (WINDOW *)0x0) {
    local_50 = -1;
    local_4c = -1;
  }
  else {
    local_50 = (int)LYwin->_cury;
    local_4c = (int)LYwin->_curx;
  }
  if (((((LYuseCursesPads == '\0') || (LYwin != w)) || (LYshiftWin != L'\0')) ||
      ((LYwideLines != L'\0' ||
       ((int)len <= (int)((LYcols - (uint)(LYShowScrollbar != '\0')) - local_4c))))) ||
     ((int)(LYcols - (uint)(LYShowScrollbar != '\0')) <= local_4c)) {
    if (WWW_TraceFlag != '\0') {
      if (LYwin == (WINDOW *)0x0) {
        local_40 = -1;
        local_3c = -1;
      }
      else {
        local_40 = (int)LYwin->_cury;
        local_3c = (int)LYwin->_curx;
      }
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"[%2d,%2d] LYwaddnstr(%.*s, %u)\n",local_40,local_3c,len,src,len);
      }
    }
    if (LYwin == (WINDOW *)0x0) {
      local_34 = -1;
    }
    else {
      local_34 = (int)LYwin->_curx;
    }
    for (inx = 0; inx < len; inx = inx + 1) {
      if (src[inx] == '\t') {
        if (LYwin == (WINDOW *)0x0) {
          local_2c = L'\xffffffff';
        }
        else {
          local_2c = (wchar_t)LYwin->_curx;
        }
        x = local_2c;
        while (x = x + L'\x01', (x - local_34 & 7U) != 0) {
          waddch(w,0x20);
        }
        waddch(w,0x20);
      }
      else {
        waddch(w,src[inx]);
      }
    }
  }
  else {
    w_00 = (WINDOW *)derwin(LYwin,LYlines,LYcols - (uint)(LYShowScrollbar != '\0'),0,0);
    if (w_00 != (WINDOW *)0x0) {
      wmove(w_00,local_50,local_4c);
      LYwideLines = L'\x01';
      LYwaddnstr(w_00,src,len);
      if (w_00 == (WINDOW *)0x0) {
        local_48 = -1;
        local_44 = -1;
      }
      else {
        local_48 = (int)w_00->_cury;
        local_44 = (int)w_00->_curx;
      }
      delwin(w_00);
      wmove(LYwin,local_48,local_44);
    }
    LYwideLines = L'\0';
  }
  return;
}



// WARNING: Unknown calling convention

wchar_t LYstrExtent(char *string,wchar_t len,wchar_t maxCells)

{
  short sVar1;
  wchar_t local_28;
  wchar_t new_y;
  wchar_t new_x;
  wchar_t n;
  wchar_t used;
  wchar_t result;
  
  if (len < L'\0') {
    used = strlen(string);
  }
  else {
    used = len;
  }
  result = used;
  if ((L'\0' < used) && (lynx_called_initscr != '\0')) {
    if ((LYstrExtent::fake_max < maxCells) &&
       (LYstrExtent::fake_max = (maxCells + L'\x01') * 2, LYstrExtent::fake_win != (WINDOW *)0x0)) {
      delwin(LYstrExtent::fake_win);
      LYstrExtent::fake_win = (WINDOW *)0x0;
    }
    if (LYstrExtent::fake_win == (WINDOW *)0x0) {
      LYstrExtent::fake_win = (WINDOW *)newwin(2,LYstrExtent::fake_max,0,0);
    }
    if (LYstrExtent::fake_win != (WINDOW *)0x0) {
      result = L'\0';
      wmove(LYstrExtent::fake_win,0,0);
      for (n = L'\0'; n < used; n = n + L'\x01') {
        if ((string[n] != '\0') && ((string[n] < '\x03' || ('\b' < string[n])))) {
          waddch(LYstrExtent::fake_win,string[n]);
          if (LYstrExtent::fake_win == (WINDOW *)0x0) {
            sVar1 = -1;
            local_28 = L'\xffffffff';
          }
          else {
            sVar1 = LYstrExtent::fake_win->_cury;
            local_28 = (wchar_t)LYstrExtent::fake_win->_curx;
          }
          if ((0 < sVar1) || (maxCells < local_28)) break;
          result = local_28;
        }
      }
    }
  }
  if (maxCells < result) {
    result = maxCells;
  }
  return result;
}



// WARNING: Unknown calling convention

wchar_t LYstrExtent2(char *string,wchar_t len)

{
  wchar_t wVar1;
  
  wVar1 = LYstrExtent(string,len,len << 3);
  return wVar1;
}



// WARNING: Unknown calling convention

wchar_t LYstrCells(char *string)

{
  wchar_t wVar1;
  
  wVar1 = strlen(string);
  wVar1 = LYstrExtent2(string,wVar1);
  return wVar1;
}



// WARNING: Unknown calling convention

wchar_t LYscreenHeight(void)

{
  wchar_t result;
  
  result = LINES;
  if (LINES < L'\x01') {
    result = L'\x18';
  }
  return result;
}



// WARNING: Unknown calling convention

wchar_t LYscreenWidth(void)

{
  wchar_t result;
  
  result = COLS;
  if (COLS < L'\x01') {
    result = L'P';
  }
  return result;
}



// WARNING: Unknown calling convention

void LYnormalColor(void)

{
  wchar_t color;
  
  if ((LYwin != stdscr) && (L'\xffffffff' < displayStyles[128].color)) {
    wbkgd(LYwin,displayStyles[128].color | 0x20);
    LYrefresh();
  }
  return;
}



// WARNING: Unknown calling convention

void LYclear(void)

{
  wclear(LYwin);
  LYnormalColor();
  return;
}



// WARNING: Unknown calling convention

void LYclrtoeol(void)

{
  wclrtoeol(LYwin);
  return;
}



// WARNING: Unknown calling convention

void LYerase(void)

{
  werase(LYwin);
  LYnormalColor();
  return;
}



// WARNING: Unknown calling convention

void LYmove(wchar_t y,wchar_t x)

{
  wmove(LYwin,y,x);
  return;
}



// WARNING: Unknown calling convention

void LYrefresh(void)

{
  wchar_t wVar1;
  int local_24;
  wchar_t local_20;
  int local_1c;
  wchar_t x;
  wchar_t y;
  
  if (LYwin == stdscr) {
    wrefresh(stdscr);
  }
  else {
    if (LYwin == (WINDOW *)0x0) {
      local_24 = -1;
      local_20 = L'\xffffffff';
    }
    else {
      local_24 = (int)LYwin->_cury;
      local_20 = (wchar_t)LYwin->_curx;
    }
    x = local_20;
    if ((int)(LYcols - (uint)(LYShowScrollbar != '\0')) < local_20) {
      x = LYcols - (uint)(LYShowScrollbar != '\0');
    }
    wmove(stdscr,local_24,x);
    wnoutrefresh(stdscr);
    wVar1 = LYscreenWidth();
    pnoutrefresh(LYwin,0,LYshiftWin,0,0,LYlines,wVar1 + L'\xffffffff');
    if (my_subwindow != (WINDOW *)0x0) {
      if (my_subwindow == (WINDOW *)0x0) {
        local_1c = -1;
      }
      else {
        local_1c = my_subwindow->_maxy + 1;
      }
      wtouchln(my_subwindow,0,local_1c,1);
      wnoutrefresh(my_subwindow);
    }
    doupdate();
  }
  return;
}



// WARNING: Unknown calling convention

void lynx_force_repaint(void)

{
  clearok(curscr,1);
  return;
}



// WARNING: Unknown calling convention

void lynx_start_title_color(void)

{
  return;
}



// WARNING: Unknown calling convention

void lynx_stop_title_color(void)

{
  return;
}



// WARNING: Unknown calling convention

void lynx_start_link_color(wchar_t flag,wchar_t pending)

{
  if (flag == L'\0') {
    lynx_start_bold();
    if (pending != L'\0') {
      lynx_start_underline();
    }
  }
  else {
    lynx_start_reverse();
    if ((lynx_has_color != L'\0') && (1 < LYShowColor)) {
      lynx_start_underline();
    }
  }
  return;
}



// WARNING: Unknown calling convention

void lynx_stop_link_color(wchar_t flag,wchar_t pending)

{
  wchar_t local_8;
  
  if (flag == L'\x01') {
    local_8 = s_alink;
  }
  else {
    local_8 = s_a;
  }
  curses_style(local_8,L'\0');
  return;
}



// WARNING: Unknown calling convention

void lynx_stop_target_color(void)

{
  lynx_stop_underline();
  lynx_stop_reverse();
  lynx_stop_bold();
  return;
}



// WARNING: Unknown calling convention

void lynx_start_target_color(void)

{
  lynx_start_bold();
  lynx_start_reverse();
  lynx_start_underline();
  return;
}



// WARNING: Unknown calling convention

void lynx_start_status_color(void)

{
  if ((lynx_has_color == L'\0') || (LYShowColor < 2)) {
    lynx_start_reverse();
  }
  else {
    lynx_set_color(L'\x02');
  }
  return;
}



// WARNING: Unknown calling convention

void lynx_stop_status_color(void)

{
  if ((lynx_has_color == L'\0') || (LYShowColor < 2)) {
    lynx_stop_reverse();
  }
  else {
    lynx_set_color(L'\0');
  }
  return;
}



// WARNING: Unknown calling convention

void lynx_start_h1_color(void)

{
  if ((bold_H1 != '\0') || (bold_headers != '\0')) {
    lynx_start_bold();
  }
  return;
}



// WARNING: Unknown calling convention

void lynx_stop_h1_color(void)

{
  if ((bold_H1 != '\0') || (bold_headers != '\0')) {
    lynx_stop_bold();
  }
  return;
}



// WARNING: Unknown calling convention

void lynx_start_prompt_color(void)

{
  lynx_start_reverse();
  return;
}



// WARNING: Unknown calling convention

void lynx_stop_prompt_color(void)

{
  lynx_stop_reverse();
  return;
}



// WARNING: Unknown calling convention

void lynx_start_radio_color(void)

{
  lynx_start_bold();
  return;
}



// WARNING: Unknown calling convention

void lynx_stop_radio_color(void)

{
  lynx_stop_bold();
  return;
}



// WARNING: Unknown calling convention

void lynx_stop_all_colors(void)

{
  lynx_stop_underline();
  lynx_stop_reverse();
  lynx_stop_bold();
  return;
}



// WARNING: Unknown calling convention

void lynx_start_bold(void)

{
  undefined4 local_8;
  
  if (LYUnderlineLinks == '\0') {
    local_8 = 0x200000;
  }
  else {
    local_8 = 0x20000;
  }
  wattr_on(LYwin,local_8,0);
  return;
}



// WARNING: Unknown calling convention

void lynx_start_reverse(void)

{
  wattr_on(LYwin,0x40000,0);
  return;
}



// WARNING: Unknown calling convention

void lynx_start_underline(void)

{
  undefined4 local_8;
  
  if (LYUnderlineLinks == '\0') {
    local_8 = 0x20000;
  }
  else {
    local_8 = 0x200000;
  }
  wattr_on(LYwin,local_8,0);
  return;
}



// WARNING: Unknown calling convention

void lynx_stop_bold(void)

{
  undefined4 local_8;
  
  if (LYUnderlineLinks == '\0') {
    local_8 = 0x200000;
  }
  else {
    local_8 = 0x20000;
  }
  wattr_off(LYwin,local_8,0);
  return;
}



// WARNING: Unknown calling convention

void lynx_stop_reverse(void)

{
  wattr_off(LYwin,0x40000,0);
  return;
}



// WARNING: Unknown calling convention

void lynx_stop_underline(void)

{
  undefined4 local_8;
  
  if (LYUnderlineLinks == '\0') {
    local_8 = 0x20000;
  }
  else {
    local_8 = 0x200000;
  }
  wattr_off(LYwin,local_8,0);
  return;
}



// WARNING: Unknown calling convention

void LYSetDisplayLines(void)

{
  if (no_title == '\0') {
    if (user_mode == 0) {
      display_lines = LYlines + -4;
    }
    else {
      display_lines = LYlines + -2;
    }
  }
  else if (user_mode == 0) {
    display_lines = LYlines + -3;
  }
  else {
    display_lines = LYlines + -1;
  }
  return;
}



// WARNING: Unknown calling convention

void LYstowCursor(WINDOW *win,wchar_t row,wchar_t col)

{
  if (LYShowCursor == '\0') {
    LYmove(LYlines + L'\xffffffff',(LYcols - (uint)(LYShowScrollbar != '\0')) + L'\xffffffff');
  }
  else {
    wmove(win,row,col);
  }
  wrefresh(win);
  return;
}



// WARNING: Unknown calling convention

long LYgetattrs(WINDOW *win)

{
  attr_t result;
  short pair;
  
  return win->_attrs;
}



// WARNING: Unknown calling convention

wchar_t LYindex2MBM(wchar_t n)

{
  wchar_t local_8;
  
  if ((n < L'\0') || (L'\x19' < n)) {
    local_8 = L'?';
  }
  else {
    local_8 = (wchar_t)LYindex2MBM::MBMcodes[n];
  }
  return local_8;
}



// WARNING: Unknown calling convention

wchar_t LYMBM2index(wchar_t ch)

{
  ushort **ppuVar1;
  char *pcVar2;
  uint local_1c;
  char *result;
  char *letters;
  
  ppuVar1 = __ctype_b_loc();
  if (((*ppuVar1)[ch & 0xff] & 0x200) == 0) {
    local_1c = ch & 0xff;
  }
  else {
    local_1c = toupper(ch & 0xff);
  }
  if (((0 < (int)local_1c) &&
      (pcVar2 = strchr("ABCDEFGHIJKLMNOPQRSTUVWXYZ",local_1c), pcVar2 != (char *)0x0)) &&
     ((int)(pcVar2 + -0x8155ac4) < 0x1a)) {
    return (wchar_t)(pcVar2 + -0x8155ac4);
  }
  return L'\xffffffff';
}



// WARNING: Unknown calling convention

void show_bookmark_not_defined(void)

{
  char *pcVar1;
  char *fmt;
  char *string_buffer;
  
  string_buffer = (char *)0x0;
  pcVar1 = key_for_func(0x31);
  fmt = (char *)gettext("Bookmark file is not defined. Use %s to see options.");
  HTSprintf0(&string_buffer,fmt,pcVar1);
  LYMBM_statusline(string_buffer);
  if (string_buffer != (char *)0x0) {
    free(string_buffer);
  }
  return;
}



// WARNING: Unknown calling convention

char * get_bookmark_filename(char **URL)

{
  wchar_t wVar1;
  FILE *__stream;
  FILE *fp_00;
  char *pcVar2;
  int iVar3;
  char *newname;
  wchar_t MBM_tmp;
  FILE *fp;
  char *string_buffer;
  
  string_buffer = (char *)0x0;
  wVar1 = select_multi_bookmarks();
  if (wVar1 == L'\xfffffffe') {
    return "";
  }
  if (wVar1 != L'\xffffffff') {
    HTSACopy(&BookmarkPage,MBM_A_subbookmark[wVar1]);
    LYAddPathToHome(get_bookmark_filename::filename_buffer,0x100,BookmarkPage);
    pcVar2 = BookmarkPage;
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"\nget_bookmark_filename: SEEKING %s\n   AS %s\n\n",pcVar2,
              get_bookmark_filename::filename_buffer);
    }
    fp_00 = fopen64(get_bookmark_filename::filename_buffer,"r");
    if (fp_00 != (FILE *)0x0) {
      pcVar2 = LYSafeGets(&string_buffer,(FILE *)fp_00);
      if (((pcVar2 == (char *)0x0) || (pcVar2 = LYTrimNewline(string_buffer), *pcVar2 == '\0')) ||
         (iVar3 = strncmp(string_buffer,"ncsa-xmosaic-hotlist-format-1",0x1d), iVar3 != 0)) {
        is_mosaic_hotlist = '\0';
        LYLocalFileToURL(URL,get_bookmark_filename::filename_buffer);
      }
      else {
        is_mosaic_hotlist = '\x01';
        pcVar2 = convert_mosaic_bookmark_file(get_bookmark_filename::filename_buffer);
        LYLocalFileToURL(URL,pcVar2);
      }
      if (string_buffer != (char *)0x0) {
        free(string_buffer);
        string_buffer = (char *)0x0;
      }
      LYCloseInput((FILE *)fp_00);
      return get_bookmark_filename::filename_buffer;
    }
    return (char *)0x0;
  }
  show_bookmark_not_defined();
  return " ";
}



// WARNING: Unknown calling convention

char * convert_mosaic_bookmark_file(char *filename_buffer)

{
  char *pcVar1;
  undefined4 uVar2;
  char *local_18;
  wchar_t line;
  char *buf;
  FILE *nfp;
  FILE *fp;
  
  buf = (char *)0x0;
  line = L'\xfffffffe';
  LYRemoveTemp(convert_mosaic_bookmark_file::newfile);
  nfp = LYOpenTemp(convert_mosaic_bookmark_file::newfile,".html","w");
  if (nfp == (FILE *)0x0) {
    pcVar1 = (char *)gettext("Unable to open tempfile for X Mosaic hotlist conversion.");
    LYMBM_statusline(pcVar1);
    LYSleepAlert();
    local_18 = "";
  }
  else {
    fp = (FILE *)fopen64(filename_buffer,"r");
    if (fp == (FILE *)0x0) {
      local_18 = "";
    }
    else {
      uVar2 = gettext("Converted Mosaic Hotlist");
      fprintf((FILE *)nfp,"<head>\n<title>%s</title>\n</head>\n",uVar2);
      uVar2 = gettext(
                     "     This file is an HTML representation of the X Mosaic hotlist file.\n     Outdated or invalid links may be removed by using the\n     remove bookmark command, it is usually the \'R\' key but may have\n     been remapped by you or your system administrator."
                     );
      fprintf((FILE *)nfp,"%s\n\n<p>\n<ol>\n",uVar2);
      while( true ) {
        pcVar1 = LYSafeGets(&buf,fp);
        if (pcVar1 == (char *)0x0) break;
        if (L'\xffffffff' < line) {
          LYTrimNewline(buf);
          if ((line & 1U) == 0) {
            if (*buf != '\0') {
              strtok(buf," ");
              fprintf((FILE *)nfp,"<LI><a href=\"%s\">",buf);
            }
          }
          else {
            fprintf((FILE *)nfp,"%s</a>\n",buf);
          }
        }
        line = line + L'\x01';
      }
      LYCloseTempFP(nfp);
      LYCloseInput(fp);
      local_18 = convert_mosaic_bookmark_file::newfile;
    }
  }
  return local_18;
}



void save_bookmark_link(char *address,char *title)

{
  int iVar1;
  BOOLEAN BVar2;
  char *pcVar3;
  FILE *__stream;
  undefined4 uVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  int iVar7;
  int in_GS_OFFSET;
  char *local_4180;
  char *local_4178;
  char *title_local;
  char *address_local;
  DocAddress WWWDoc;
  char *TimeString;
  time_t NowTime;
  char *p;
  char *page;
  char *url;
  HText *text;
  HTParentAnchor *tmpanchor;
  wchar_t c;
  wchar_t i;
  char *Title;
  char *Address;
  char *bookmark_URL;
  char *filename;
  FILE *fp;
  BOOLEAN first_time;
  char tmp_buffer [8192];
  char string_buffer [8192];
  char filename_buffer [256];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  first_time = '\0';
  bookmark_URL = (char *)0x0;
  Address = (char *)0x0;
  Title = (char *)0x0;
  if ((address == (char *)0x0) || (*address == '\0')) {
    pcVar3 = (char *)gettext("Malformed address.");
    HTAlert(pcVar3);
  }
  else {
    filename = get_bookmark_filename(&bookmark_URL);
    if (filename == (char *)0x0) {
      first_time = '\x01';
      filename_buffer[0] = '\0';
    }
    else {
      if ((*filename == '\0') || (iVar7 = strcmp(filename," "), iVar7 == 0)) {
        if (bookmark_URL != (char *)0x0) {
          free(bookmark_URL);
          bookmark_URL = (char *)0x0;
        }
        goto LAB_0808f3f9;
      }
      LYstrncpy(filename_buffer,filename,L'');
    }
    if (BookmarkPage == (char *)0x0) {
      if (bookmark_URL != (char *)0x0) {
        free(bookmark_URL);
        bookmark_URL = (char *)0x0;
      }
    }
    else {
      if (LYMultiBookmarks != 0) {
        url = HTLoadedDocumentURL();
        if (*BookmarkPage == '.') {
          local_4180 = BookmarkPage + 1;
        }
        else {
          local_4180 = BookmarkPage;
        }
        page = local_4180;
        pcVar3 = strstr(url,local_4180);
        if (pcVar3 != (char *)0x0) {
          pcVar3 = (char *)gettext("Reproduce L)ink in this bookmark file or C)ancel? (l,c): ");
          LYMBM_statusline(pcVar3);
          c = LYgetch_single();
          if (c != L'L') {
            if (bookmark_URL != (char *)0x0) {
              free(bookmark_URL);
              bookmark_URL = (char *)0x0;
            }
            goto LAB_0808f3f9;
          }
        }
      }
      do {
        if (HTCJK == JAPANESE) {
          if (kanji_code == EUC) {
            TO_EUC((uchar *)title,(uchar *)tmp_buffer);
          }
          else if (kanji_code == SJIS) {
            TO_SJIS((uchar *)title,(uchar *)tmp_buffer);
          }
          LYstrncpy(string_buffer,tmp_buffer,L'');
        }
        else {
          LYstrncpy(string_buffer,title,L'');
        }
        LYReduceBlanks(string_buffer);
        pcVar3 = (char *)gettext("Title: ");
        LYMBM_statusline(pcVar3);
        LYgetstr(string_buffer,L'\0',0x2000,NORECALL);
        if (string_buffer[0] == '\0') {
          pcVar3 = (char *)gettext("Cancelled!!!");
          LYMBM_statusline(pcVar3);
          LYSleepMsg();
          if (bookmark_URL != (char *)0x0) {
            free(bookmark_URL);
            bookmark_URL = (char *)0x0;
          }
          goto LAB_0808f3f9;
        }
        BVar2 = havevisible(string_buffer);
      } while (BVar2 == '\0');
      LYformTitle(&Title,string_buffer);
      LYEntify(&Title,'\x01');
      if (((UCSaveBookmarksInUnicode != '\0') && (BVar2 = have8bit(Title), BVar2 != '\0')) &&
         (LYHaveCJKCharacterSet == '\0')) {
        p = title_convert8bit(Title);
        if (Title != (char *)0x0) {
          free(Title);
        }
        Title = p;
      }
      if (first_time != '\0') {
        LYAddPathToHome(filename_buffer,0x100,BookmarkPage);
      }
      pcVar3 = BookmarkPage;
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"\nsave_bookmark_link: SEEKING %s\n   AS %s\n\n",pcVar3,
                filename_buffer);
      }
      if (first_time == '\0') {
        local_4178 = "a+";
      }
      else {
        local_4178 = "w";
      }
      fp = (FILE *)fopen64(filename_buffer,local_4178);
      if (fp == (FILE *)0x0) {
        pcVar3 = (char *)gettext("ERROR - unable to open bookmark file.");
        LYMBM_statusline(pcVar3);
        LYSleepAlert();
        if (Title != (char *)0x0) {
          free(Title);
          Title = (char *)0x0;
        }
        if (bookmark_URL != (char *)0x0) {
          free(bookmark_URL);
          bookmark_URL = (char *)0x0;
        }
      }
      else {
        HTSACopy(&Address,address);
        LYEntify(&Address,'\0');
        if (first_time != '\0') {
          fwrite("<head>\n",1,7,(FILE *)fp);
          LYAddMETAcharsetToFD(fp,-1);
          uVar4 = gettext("Bookmark file");
          fprintf((FILE *)fp,"<title>%s</title>\n</head>\n",uVar4);
          uVar4 = gettext(
                         "Note: if you edit this file manually\n      you should not change the format within the lines\n      or add other HTML markup.\n      Make sure any bookmark link is saved as a single line."
                         );
          uVar5 = gettext(
                         "     This file also may be edited with a standard text editor to delete\n     outdated or invalid links, or to change their order."
                         );
          uVar6 = gettext(
                         "     You can delete links using the remove bookmark command.  It is usually\n     the \'R\' key but may have been remapped by you or your system\n     administrator."
                         );
          fprintf((FILE *)fp,"%s<br>\n%s\n\n<!--\n%s\n-->\n\n<p>\n<ol>\n",uVar6,uVar5,uVar4);
        }
        if (is_mosaic_hotlist == '\0') {
          fprintf((FILE *)fp,"<LI><a href=\"%s\">%s</a>\n",Address,Title);
        }
        else {
          NowTime = time((time_t *)0x0);
          pcVar3 = ctime(&NowTime);
          fprintf((FILE *)fp,"%s %s%s\n",Address,pcVar3,Title);
        }
        LYCloseOutput(fp);
        if (((first_time == '\0') && (0 < nhist)) && (bookmark_URL != (char *)0x0)) {
          for (i = L'\0'; i < nhist; i = i + L'\x01') {
            if ((history[i].hdoc.bookmark != (char *)0x0) &&
               (iVar7 = strcmp(history[i].hdoc.address,bookmark_URL), iVar7 == 0)) {
              WWWDoc.address = history[i].hdoc.address;
              WWWDoc.post_data = (bstring *)0x0;
              WWWDoc.post_content_type = (char *)0x0;
              WWWDoc.bookmark = history[i].hdoc.bookmark;
              WWWDoc.isHEAD = '\0';
              WWWDoc.safe = '\0';
              tmpanchor = HTAnchor_findAddress(&WWWDoc);
              text = (HText *)HTAnchor_document(tmpanchor);
              if (text != (HText *)0x0) {
                HText_setNoCache(text);
              }
              break;
            }
          }
        }
        if (Title != (char *)0x0) {
          free(Title);
          Title = (char *)0x0;
        }
        if (Address != (char *)0x0) {
          free(Address);
          Address = (char *)0x0;
        }
        if (bookmark_URL != (char *)0x0) {
          free(bookmark_URL);
          bookmark_URL = (char *)0x0;
        }
        pcVar3 = (char *)gettext("Done!");
        LYMBM_statusline(pcVar3);
        LYSleepMsg();
      }
    }
  }
LAB_0808f3f9:
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void remove_bookmark_link(wchar_t cur,char *cur_bookmark_page)

{
  int iVar1;
  FILE *pFVar2;
  char *pcVar3;
  int iVar4;
  int *piVar5;
  wchar_t wVar6;
  int in_GS_OFFSET;
  BOOLEAN local_3b0;
  char *cur_bookmark_page_local;
  stat stat_buf;
  char *program;
  char *buffer;
  wchar_t keep_ol;
  wchar_t seen;
  char *cp2;
  char *cp;
  wchar_t del_line;
  mode_t mode;
  wchar_t n;
  char *buf;
  FILE *nfp;
  FILE *fp;
  BOOLEAN retain;
  BOOLEAN regular;
  BOOLEAN keep_tempfile;
  char homepath [256];
  char newfile [256];
  char filename_buffer [256];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  buf = (char *)0x0;
  keep_tempfile = '\0';
  regular = '\0';
  if (WWW_TraceFlag != '\0') {
    pFVar2 = TraceFP();
    fprintf((FILE *)pFVar2,"remove_bookmark_link: deleting link number: %d\n",cur);
  }
  if (cur_bookmark_page == (char *)0x0) goto LAB_0808fc90;
  LYAddPathToHome(filename_buffer,0x100,cur_bookmark_page);
  if (WWW_TraceFlag != '\0') {
    pFVar2 = TraceFP();
    fprintf((FILE *)pFVar2,"\nremove_bookmark_link: SEEKING %s\n   AS %s\n\n",cur_bookmark_page,
            filename_buffer);
  }
  fp = (FILE *)fopen64(filename_buffer,"r");
  if (fp == (FILE *)0x0) {
    pcVar3 = (char *)gettext("Unable to open bookmark file for deletion of link.");
    HTAlert(pcVar3);
    goto LAB_0808fc90;
  }
  LYAddPathToHome(homepath,0x100,"");
  nfp = LYOpenScratch(newfile,homepath);
  if (nfp == (FILE *)0x0) {
    LYCloseInput(fp);
    pcVar3 = (char *)gettext("Unable to open scratch file for deletion of link.");
    HTAlert(pcVar3);
    goto LAB_0808fc90;
  }
  iVar4 = stat64(filename_buffer,(stat64 *)&stat_buf);
  if (iVar4 == 0) {
    if (((stat_buf.st_mode & 0xf000) == 0x8000) && (stat_buf.st_nlink == 1)) {
      local_3b0 = '\x01';
    }
    else {
      local_3b0 = '\0';
    }
    regular = local_3b0;
    mode = stat_buf.st_mode & 0xff | 0x180;
    chmod(newfile,mode);
    nfp = LYReopenTemp(newfile);
    if (nfp == (FILE *)0x0) {
      LYCloseInput(fp);
      pcVar3 = (char *)gettext("Unable to reopen temporary file for deletion of link.");
      HTAlert(pcVar3);
      goto LAB_0808fc90;
    }
  }
  if (is_mosaic_hotlist == '\0') {
    n = L'\xffffffff';
    do {
      pcVar3 = LYSafeGets(&buf,fp);
      if (pcVar3 == (char *)0x0) goto LAB_0808f8b3;
      keep_ol = L'\0';
      retain = '\x01';
      seen = L'\0';
      cp = buf;
      if ((cur == L'\0') && (cp2 = LYstrstr(buf,"<ol><LI>"), cp2 != (char *)0x0)) {
        keep_ol = L'\x01';
      }
      while ((n < cur && (cp = LYstrstr(cp,"<a href="), cp != (char *)0x0))) {
        seen = seen + L'\x01';
        n = n + L'\x01';
        if (n == cur) {
          if (((seen != L'\x01') || (pcVar3 = LYstrstr(buf,"</a>"), pcVar3 == (char *)0x0)) ||
             (pcVar3 = LYstrstr(cp + 1,"<a href="), pcVar3 != (char *)0x0)) {
            pcVar3 = (char *)gettext("Link is not by itself all on one line in bookmark file.");
            HTAlert(pcVar3);
            goto failure;
          }
          if (WWW_TraceFlag != '\0') {
            pFVar2 = TraceFP();
            fprintf((FILE *)pFVar2,"remove_bookmark_link: skipping link %d\n",n);
          }
          if (keep_ol != L'\0') {
            fwrite("<ol>\n",1,5,(FILE *)nfp);
          }
          retain = '\0';
        }
        cp = cp + 8;
      }
    } while ((retain == '\0') || (iVar4 = fputs(buf,(FILE *)nfp), iVar4 != -1));
  }
  else {
    del_line = cur * 2;
    n = L'\xfffffffd';
    do {
      pcVar3 = LYSafeGets(&buf,fp);
      if (pcVar3 == (char *)0x0) goto LAB_0808f8b3;
      n = n + L'\x01';
    } while (((n == del_line) || (del_line + L'\x01' == n)) ||
            (iVar4 = fputs(buf,(FILE *)nfp), iVar4 != -1));
  }
  goto failure;
LAB_0808f8b3:
  if (buf != (char *)0x0) {
    free(buf);
    buf = (char *)0x0;
  }
  if (WWW_TraceFlag != '\0') {
    pFVar2 = TraceFP();
    fprintf((FILE *)pFVar2,"remove_bookmark_link: files: %s %s\n",newfile,filename_buffer);
  }
  LYCloseInput(fp);
  fp = (FILE *)0x0;
  iVar4 = fflush((FILE *)nfp);
  if (iVar4 == -1) {
    if (WWW_TraceFlag != '\0') {
      piVar5 = __errno_location();
      pcVar3 = strerror(*piVar5);
      pFVar2 = TraceFP();
      fprintf((FILE *)pFVar2,"fflush(nfp): %s",pcVar3);
    }
  }
  else {
    LYCloseTempFP(nfp);
    nfp = (FILE *)0x0;
    if (regular == '\0') {
      wVar6 = LYCopyFile(newfile,filename_buffer);
      if (wVar6 == L'\0') {
        LYRemoveTemp(newfile);
        goto LAB_0808fc90;
      }
      LYSleepAlert();
      pcVar3 = (char *)gettext("Unable to copy temporary file for deletion of link.");
      HTUserMsg(pcVar3);
      keep_tempfile = '\x01';
    }
    iVar4 = rename(newfile,filename_buffer);
    if (iVar4 != -1) {
      if (regular != '\0') {
        chmod(filename_buffer,stat_buf.st_mode & 0xfff);
      }
      goto LAB_0808fc90;
    }
    piVar5 = __errno_location();
    if (*piVar5 == 0x12) {
      buffer = (char *)0x0;
      pcVar3 = HTGetProgramPath(ppMV);
      if (pcVar3 != (char *)0x0) {
        HTAddParam(&buffer,"%s %s %s",1,pcVar3);
        HTAddParam(&buffer,"%s %s %s",2,newfile);
        HTAddParam(&buffer,"%s %s %s",3,filename_buffer);
        HTEndParam(&buffer,"%s %s %s",3);
        wVar6 = LYSystem(buffer);
        if (wVar6 == L'\0') {
          if (regular != '\0') {
            chmod(filename_buffer,stat_buf.st_mode & 0xfff);
          }
          if (buffer != (char *)0x0) {
            free(buffer);
            buffer = (char *)0x0;
          }
          goto LAB_0808fc90;
        }
      }
      if (buffer != (char *)0x0) {
        free(buffer);
        buffer = (char *)0x0;
      }
      keep_tempfile = '\x01';
    }
    else {
      if (WWW_TraceFlag != '\0') {
        piVar5 = __errno_location();
        pcVar3 = strerror(*piVar5);
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2,"rename(): %s",pcVar3);
      }
      pcVar3 = (char *)gettext("Error renaming temporary file.");
      HTAlert(pcVar3);
      if (WWW_TraceFlag != '\0') {
        perror("renaming the file");
      }
    }
  }
failure:
  if (buf != (char *)0x0) {
    free(buf);
    buf = (char *)0x0;
  }
  pcVar3 = (char *)gettext("Bookmark deletion failed.");
  HTAlert(pcVar3);
  if (nfp != (FILE *)0x0) {
    LYCloseTempFP(nfp);
  }
  if (fp != (FILE *)0x0) {
    LYCloseInput(fp);
  }
  if (keep_tempfile == '\0') {
    LYRemoveTemp(newfile);
  }
  else {
    pcVar3 = (char *)gettext("File may be recoverable from %s during this session");
    HTUserMsg2(pcVar3,newfile);
  }
LAB_0808fc90:
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

wchar_t select_multi_bookmarks(void)

{
  BOOLEAN BVar1;
  char *text;
  wchar_t wVar2;
  wchar_t local_20;
  wchar_t local_1c;
  wchar_t local_18;
  wchar_t c;
  
  if ((LYMultiBookmarks == 0) || (BVar1 = LYHaveSubBookmarks(), BVar1 == '\0')) {
    if (MBM_A_subbookmark[0] == (char *)0x0) {
      local_20 = L'\xffffffff';
    }
    else {
      local_20 = L'\0';
    }
  }
  else if ((LYMultiBookmarks == 2) && (user_mode == 2)) {
    text = (char *)gettext("Select subbookmark, \'=\' for menu, or ^G to cancel: ");
    LYMBM_statusline(text);
    do {
      while( true ) {
        wVar2 = LYgetch();
        BVar1 = LYisNonAlnumKeyname(wVar2,0x25);
        if (((BVar1 != '\0') || (wVar2 == L'\x03')) || (wVar2 == L'\a')) {
          return L'\xfffffffe';
        }
        BVar1 = LYisNonAlnumKeyname(wVar2,0x15);
        if (BVar1 == '\0') break;
        lynx_force_repaint();
        LYrefresh();
      }
      BVar1 = LYisNonAlnumKeyname(wVar2,0x27);
      if (BVar1 != '\0') {
        if (MBM_A_subbookmark[0] == (char *)0x0) {
          local_1c = L'\xffffffff';
        }
        else {
          local_1c = L'\0';
        }
        return local_1c;
      }
      if (wVar2 == L'=') {
        wVar2 = select_menu_multi_bookmarks();
        return wVar2;
      }
      local_18 = LYMBM2index(wVar2);
    } while (local_18 < L'\0');
    if (MBM_A_subbookmark[local_18] == (char *)0x0) {
      local_18 = L'\xffffffff';
    }
    local_20 = local_18;
  }
  else {
    local_20 = select_menu_multi_bookmarks();
  }
  return local_20;
}



// WARNING: Unknown calling convention

wchar_t select_menu_multi_bookmarks(void)

{
  BOOLEAN BVar1;
  char *pcVar2;
  size_t sVar3;
  wchar_t wVar4;
  wchar_t local_40;
  wchar_t local_3c;
  char *shead_buffer;
  wchar_t MBM_current;
  wchar_t MBM_to;
  wchar_t MBM_from;
  wchar_t MBM_screens;
  wchar_t MBM_allow;
  wchar_t MBM_tmp_count;
  wchar_t d;
  wchar_t c;
  
  if (LYMultiBookmarks == 0) {
    local_40 = L'\0';
  }
  else {
    MBM_allow = LYlines + L'\xfffffff9';
    if (L'\0' < MBM_allow) {
      MBM_screens = 0x19 / MBM_allow + L'\x01';
      MBM_current = L'\x01';
LAB_0808fe6d:
      do {
        MBM_from = (MBM_current + L'\xffffffff') * MBM_allow;
        if (MBM_from < L'\0') {
          MBM_from = L'\0';
        }
        if (MBM_current != L'\x01') {
          MBM_from = MBM_from + L'\x01';
        }
        MBM_to = MBM_allow * MBM_current;
        if (L'\x19' < MBM_to) {
          MBM_to = L'\x19';
        }
        LYclear();
        LYmove(L'\x01',L'\x05');
        lynx_start_h1_color();
        if (MBM_screens < L'\x02') {
          pcVar2 = (char *)gettext("       Select Bookmark");
          sVar3 = strlen(pcVar2);
          pcVar2 = (char *)gettext("       Select Bookmark");
          LYwaddnstr(LYwin,pcVar2,sVar3);
        }
        else {
          shead_buffer = (char *)0x0;
          pcVar2 = (char *)gettext(" Select Bookmark (screen %d of %d)");
          HTSprintf0(&shead_buffer,pcVar2,MBM_current,MBM_screens);
          sVar3 = strlen(shead_buffer);
          LYwaddnstr(LYwin,shead_buffer,sVar3);
          if (shead_buffer != (char *)0x0) {
            free(shead_buffer);
            shead_buffer = (char *)0x0;
          }
        }
        lynx_stop_h1_color();
        MBM_tmp_count = L'\0';
        for (c = MBM_from; c <= MBM_to; c = c + L'\x01') {
          LYmove(MBM_tmp_count + L'\x03',L'\x05');
          wVar4 = LYindex2MBM(c);
          waddch(LYwin,wVar4);
          LYwaddnstr(LYwin," : ",3);
          if (MBM_A_subdescript[c] != (char *)0x0) {
            sVar3 = strlen(MBM_A_subdescript[c]);
            LYwaddnstr(LYwin,MBM_A_subdescript[c],sVar3);
          }
          LYmove(MBM_tmp_count + L'\x03',L'$');
          waddch(LYwin,0x28);
          if (MBM_A_subbookmark[c] != (char *)0x0) {
            sVar3 = strlen(MBM_A_subbookmark[c]);
            LYwaddnstr(LYwin,MBM_A_subbookmark[c],sVar3);
          }
          waddch(LYwin,0x29);
          MBM_tmp_count = MBM_tmp_count + L'\x01';
        }
        if (L'\x01' < MBM_screens) {
          LYmove(LYlines + L'\xfffffffe',L'\0');
          LYwaddnstr(LYwin,"\'",1);
          lynx_start_bold();
          LYwaddnstr(LYwin,"[",1);
          lynx_stop_bold();
          LYwaddnstr(LYwin,"\' ",2);
          pcVar2 = (char *)gettext("previous");
          sVar3 = strlen(pcVar2);
          pcVar2 = (char *)gettext("previous");
          LYwaddnstr(LYwin,pcVar2,sVar3);
          LYwaddnstr(LYwin,", \'",3);
          lynx_start_bold();
          LYwaddnstr(LYwin,"]",1);
          lynx_stop_bold();
          LYwaddnstr(LYwin,"\' ",2);
          pcVar2 = (char *)gettext("next screen");
          sVar3 = strlen(pcVar2);
          pcVar2 = (char *)gettext("next screen");
          LYwaddnstr(LYwin,pcVar2,sVar3);
        }
        pcVar2 = (char *)gettext("Select destination or ^G to Cancel: ");
        LYMBM_statusline(pcVar2);
        do {
          while( true ) {
            while( true ) {
              c = LYgetch();
              d = LYMBM2index(c);
              if (d < L'\0') break;
              if (MBM_A_subbookmark[d] != (char *)0x0) {
                return d;
              }
              show_bookmark_not_defined();
              pcVar2 = (char *)gettext("Select destination or ^G to Cancel: ");
              LYMBM_statusline(pcVar2);
            }
            BVar1 = LYisNonAlnumKeyname(c,0x25);
            if (((BVar1 != '\0') || (c == L'\a')) || (c == L'\x03')) {
              return L'\xfffffffe';
            }
            BVar1 = LYisNonAlnumKeyname(c,0x15);
            if (BVar1 == '\0') break;
            lynx_force_repaint();
            LYrefresh();
          }
          BVar1 = LYisNonAlnumKeyname(c,0x27);
          if (BVar1 != '\0') {
            if (MBM_A_subbookmark[0] == (char *)0x0) {
              local_3c = L'\xffffffff';
            }
            else {
              local_3c = L'\0';
            }
            return local_3c;
          }
          if (((c == L']') || (BVar1 = LYisNonAlnumKeyname(c,0xf), BVar1 != '\0')) &&
             (L'\x01' < MBM_screens)) {
            MBM_current = MBM_current + L'\x01';
            if (MBM_screens < MBM_current) {
              MBM_current = L'\x01';
            }
            goto LAB_0808fe6d;
          }
        } while (((c != L'[') && (BVar1 = LYisNonAlnumKeyname(c,0x10), BVar1 == '\0')) ||
                (MBM_screens < L'\x02'));
        MBM_current = MBM_current + L'\xffffffff';
        if (MBM_current < L'\x01') {
          MBM_current = MBM_screens;
        }
      } while( true );
    }
    pcVar2 = (char *)gettext("Screen too small! (8x35 min)");
    HTAlert(pcVar2);
    local_40 = L'\xfffffffe';
  }
  return local_40;
}



// WARNING: Unknown calling convention

BOOLEAN LYHaveSubBookmarks(void)

{
  wchar_t i;
  
  i = L'\x01';
  while( true ) {
    if (L'\x18' < i) {
      return '\0';
    }
    if ((MBM_A_subbookmark[i] != (char *)0x0) && (*MBM_A_subbookmark[i] != '\0')) break;
    i = i + L'\x01';
  }
  return '\x01';
}



// WARNING: Unknown calling convention

void LYMBM_statusline(char *text)

{
  if ((LYMultiBookmarks == 0) || (user_mode != 0)) {
    mustshow = '\x01';
    statusline(text);
  }
  else {
    LYStatusLine = LYlines + -1;
    mustshow = '\x01';
    statusline(text);
    LYStatusLine = -1;
  }
  return;
}



// WARNING: Unknown calling convention

BOOLEAN havevisible(char *Title)

{
  byte bVar1;
  BOOLEAN BVar2;
  UCode_t UVar3;
  long unicode;
  char *p;
  uchar c;
  
  p = Title;
  do {
    if (*p == '\0') {
      return '\0';
    }
    bVar1 = *p;
    if ((0x20 < bVar1) && (bVar1 < 0x7f)) {
      return '\x01';
    }
    if ((0x20 < bVar1) && (bVar1 != 0x7f)) {
      if ((LYHaveCJKCharacterSet != '\0') ||
         (BVar2 = UCCanUniTranslateFrom(current_char_set), BVar2 == '\0')) {
        return '\x01';
      }
      UVar3 = UCTransToUni(*p,current_char_set);
      if ((0x20 < UVar3) && (UVar3 < 0x7f)) {
        return '\x01';
      }
      if ((0x20 < UVar3) &&
         (((UVar3 != 0xa0 && (UVar3 != 0xad)) && ((UVar3 < 0x2000 || (0x200e < UVar3)))))) {
        return '\x01';
      }
    }
    p = p + 1;
  } while( true );
}



// WARNING: Unknown calling convention

BOOLEAN have8bit(char *Title)

{
  char *p;
  
  p = Title;
  while( true ) {
    if (*p == '\0') {
      return '\0';
    }
    if (*p < '\0') break;
    p = p + 1;
  }
  return '\x01';
}



char * title_convert8bit(char *Title)

{
  int iVar1;
  int charset_in_00;
  int charset_out_00;
  int iVar2;
  UCode_t UVar3;
  int in_GS_OFFSET;
  char *Title_local;
  long unicode;
  wchar_t charset_out;
  wchar_t charset_in;
  char *buf;
  char *ncr;
  char *comment;
  char *q;
  char *p0;
  char *p;
  char temp [2];
  char replace_buf [32];
  
  charset_in_00 = current_char_set;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  p = Title;
  comment = (char *)0x0;
  ncr = (char *)0x0;
  buf = (char *)0x0;
  charset_out_00 = UCGetLYhndl_byMIME("us-ascii");
  for (; *p != '\0'; p = p + 1) {
    LYstrncpy(temp,p,L'\x01');
    if (temp[0] < '\0') {
      iVar2 = UCTransCharStr(replace_buf,0x20,temp[0],charset_in_00,charset_out_00,1);
      if (0 < iVar2) {
        HTSACat(&comment,replace_buf);
      }
      UVar3 = UCTransToUni(temp[0],charset_in_00);
      HTSACat(&ncr,"&#");
      sprintf(replace_buf,"%ld",UVar3);
      HTSACat(&ncr,replace_buf);
      HTSACat(&ncr,";");
    }
    else {
      HTSACat(&comment,temp);
      HTSACat(&ncr,temp);
    }
  }
  q = comment;
  for (p0 = comment; *p0 != '\0'; p0 = p0 + 1) {
    if (((0x1f < (byte)*p0) && (*p0 != '>')) && ((q == comment || ((*p0 != '-' || (q[-1] != '-')))))
       ) {
      *q = *p0;
      q = q + 1;
    }
  }
  *q = '\0';
  HTSACat(&buf,"<!-- ");
  HTSACat(&buf,comment);
  HTSACat(&buf," -->");
  HTSACat(&buf,ncr);
  if (comment != (char *)0x0) {
    free(comment);
    comment = (char *)0x0;
  }
  if (ncr != (char *)0x0) {
    free(ncr);
    ncr = (char *)0x0;
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return buf;
}



// WARNING: Unknown calling convention

void set_default_bookmark_page(char *value)

{
  int iVar1;
  char *src;
  
  if (value != (char *)0x0) {
    if ((bookmark_page == (char *)0x0) || (iVar1 = strcmp(bookmark_page,value), iVar1 != 0)) {
      HTSACopy(&bookmark_page,value);
    }
    HTSACopy(&BookmarkPage,bookmark_page);
    HTSACopy(MBM_A_subbookmark,bookmark_page);
    src = (char *)gettext("Default Bookmark File");
    HTSACopy(MBM_A_subdescript,src);
    return;
  }
  return;
}



time_t LYmktime(char *string,BOOLEAN absolute)

{
  time_t tVar1;
  FILE *pFVar2;
  time_t tVar3;
  char *pcVar4;
  BOOLEAN absolute_local;
  time_t result;
  
  if ((string != (char *)0x0) && (*string != '\0')) {
    if (WWW_TraceFlag != '\0') {
      pFVar2 = TraceFP();
      fprintf((FILE *)pFVar2,"LYmktime: Parsing \'%s\'\n",string);
    }
    result = parsedate(string,(TIMEINFO *)0x0);
    if (absolute == '\0') {
      tVar3 = time((time_t *)0x0);
      if (-1 < tVar3 - result) {
        result = 0;
      }
    }
    if ((result != 0) && (WWW_TraceFlag != '\0')) {
      pcVar4 = ctime(&result);
      tVar1 = result;
      pFVar2 = TraceFP();
      fprintf((FILE *)pFVar2,"LYmktime: clock=%d, ctime=%s",tVar1,pcVar4);
    }
  }
  return result;
}



// WARNING: Unknown calling convention

LY_TEMP * FindTempfileByName(char *name)

{
  int iVar1;
  LY_TEMP *p;
  
  p = ly_temp;
  while( true ) {
    if (p == (LY_TEMP *)0x0) {
      return (LY_TEMP *)0x0;
    }
    iVar1 = strcmp(p->name,name);
    if (iVar1 == 0) break;
    p = p->next;
  }
  return p;
}



// WARNING: Unknown calling convention

LY_TEMP * FindTempfileByFP(FILE *fp)

{
  LY_TEMP *p;
  
  for (p = ly_temp; (p != (LY_TEMP *)0x0 && (p->file != fp)); p = p->next) {
  }
  return p;
}



// WARNING: Unknown calling convention

char * LYGetEnv(char *name)

{
  char *local_18;
  char *result;
  
  local_18 = getenv(name);
  if ((local_18 == (char *)0x0) || (*local_18 == '\0')) {
    local_18 = (char *)0x0;
  }
  return local_18;
}



size_t utf8_length(BOOLEAN utf_flag,char *data)

{
  size_t sVar1;
  BOOLEAN utf_flag_local;
  size_t utf_extra;
  
  utf_extra = 0;
  if ((utf_flag != '\0') && (*data < '\0')) {
    if (((int)*data & 0xe0U) == 0xc0) {
      utf_extra = 1;
    }
    else if (((int)*data & 0xf0U) == 0xe0) {
      utf_extra = 2;
    }
    else if (((int)*data & 0xf8U) == 0xf0) {
      utf_extra = 3;
    }
    else if (((int)*data & 0xfcU) == 0xf8) {
      utf_extra = 4;
    }
    else if (((int)*data & 0xfeU) == 0xfc) {
      utf_extra = 5;
    }
    else {
      utf_extra = 0;
    }
    sVar1 = strlen(data + 1);
    if (sVar1 < utf_extra) {
      utf_extra = 0;
    }
  }
  return utf_extra;
}



// WARNING: Unknown calling convention

void LYFreeHilites(wchar_t first,wchar_t last)

{
  wchar_t i;
  
  for (i = first; i < last; i = i + L'\x01') {
    LYSetHilite(i,(char *)0x0);
    if (links[i].lname != (char *)0x0) {
      free(links[i].lname);
      links[i].lname = (char *)0x0;
    }
  }
  return;
}



// WARNING: Unknown calling convention

void LYSetHilite(wchar_t cur,char *text)

{
  links[cur].list.hl_base.hl_text = text;
  links[cur].list.hl_len = (ushort)(text != (char *)0x0);
  if (links[cur].list.hl_info != (HiliteInfo *)0x0) {
    free(links[cur].list.hl_info);
    links[cur].list.hl_info = (HiliteInfo *)0x0;
  }
  return;
}



// WARNING: Unknown calling convention

void LYAddHilite(wchar_t cur,char *text,wchar_t x)

{
  HiliteInfo *__ptr;
  int iVar1;
  int iVar2;
  uint want;
  uint need;
  HiliteInfo *have;
  HiliteList *list;
  
  __ptr = links[cur].list.hl_info;
  iVar1 = links[cur].list.hl_len + -1;
  links[cur].list.hl_len = links[cur].list.hl_len + 1;
  iVar2 = (int)links[cur].list.hl_len;
  if (__ptr == (HiliteInfo *)0x0) {
    have = (HiliteInfo *)malloc(iVar2 << 3);
  }
  else {
    have = (HiliteInfo *)realloc(__ptr,iVar2 << 3);
  }
  links[cur].list.hl_info = have;
  have[iVar1].hl_text = text;
  have[iVar1].hl_x = (short)x;
  return;
}



// WARNING: Unknown calling convention

char * LYGetHiliteStr(wchar_t cur,wchar_t count)

{
  char *result;
  
  if (count < links[cur].list.hl_len) {
    if (count < L'\x01') {
      result = links[cur].list.hl_base.hl_text;
    }
    else {
      result = links[cur].list.hl_info[-(1 - count)].hl_text;
    }
  }
  else {
    result = (char *)0x0;
  }
  return result;
}



// WARNING: Unknown calling convention

wchar_t LYGetHilitePos(wchar_t cur,wchar_t count)

{
  wchar_t result;
  
  if (count < links[cur].list.hl_len) {
    if (count < L'\x01') {
      result = links[cur].lx;
    }
    else {
      result = (wchar_t)links[cur].list.hl_info[-(1 - count)].hl_x;
    }
  }
  else {
    result = L'\xffffffff';
  }
  return result;
}



BOOLEAN show_whereis_targets
                  (wchar_t flag,wchar_t cur,wchar_t count,char *target,BOOLEAN TargetEmphasisON,
                  BOOLEAN utf_flag)

{
  int iVar1;
  BOOLEAN BVar2;
  char *pcVar3;
  wchar_t wVar4;
  wchar_t y_00;
  wchar_t wVar5;
  wchar_t wVar6;
  size_t sVar7;
  wchar_t n;
  int iVar8;
  int in_GS_OFFSET;
  char *local_518;
  wchar_t local_514;
  char *local_510;
  int local_508;
  int local_500;
  int local_4f8;
  int local_4f0;
  wchar_t local_4ec;
  char *local_4e8;
  char *local_4e0;
  char *local_4d8;
  wchar_t local_4d0;
  wchar_t local_4c8;
  int local_4bc;
  int local_4b4;
  int local_4ac;
  int local_4a4;
  wchar_t local_4a0;
  char *local_49c;
  char *local_494;
  char *local_48c;
  wchar_t local_484;
  int local_478;
  BOOLEAN utf_flag_local;
  BOOLEAN TargetEmphasisON_local;
  char *target_local;
  char tmp [7];
  size_t utf_extra;
  wchar_t hoffset;
  wchar_t hLine;
  wchar_t hLen;
  wchar_t hlen;
  wchar_t tlen;
  char *data;
  wchar_t offset;
  wchar_t y;
  wchar_t len;
  wchar_t written;
  wchar_t itmp;
  wchar_t tLen;
  wchar_t Offset;
  wchar_t LenNeeded;
  wchar_t HitOffset;
  char *theData;
  char *cp;
  char *Data;
  char buffer [1024];
  
  TargetEmphasisON_local = TargetEmphasisON;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  Data = (char *)0x0;
  theData = (char *)0x0;
  tmp[2] = '\0';
  tmp[1] = '\0';
  tmp[0] = '\0';
  if (((((target != (char *)0x0) && (*target != '\0')) && ((links[cur].type & 2U) != 0)) &&
      ((pcVar3 = LYGetHiliteStr(cur,count), pcVar3 != (char *)0x0 &&
       (pcVar3 = LYGetHiliteStr(cur,count), *pcVar3 != '\0')))) &&
     ((links[cur].ly + count < display_lines &&
      (BVar2 = HText_getFirstTargetInLine
                         (HTMainText,links[cur].anchor_line_num + count,utf_flag,&Offset,&tLen,
                          &theData,target), BVar2 != '\0')))) {
    wVar4 = strlen(target);
    y_00 = links[cur].ly + count;
    wVar5 = LYGetHilitePos(cur,count);
    iVar8 = LYcols - (uint)(LYShowScrollbar != '\0');
    wVar6 = LYGetHilitePos(cur,count);
    pcVar3 = LYGetHiliteStr(cur,count);
    if (pcVar3 == (char *)0x0) {
      local_518 = "";
    }
    else {
      local_518 = LYGetHiliteStr(cur,count);
    }
    LYmbcsstrncpy(buffer,local_518,L'',iVar8 - wVar6,utf_flag);
    local_514 = strlen(buffer);
    if ((HTCJK != NOCJK) || (utf_flag != '\0')) {
      local_514 = LYmbcsstrlen(buffer,utf_flag,'\x01');
    }
    if (Offset < wVar5 + local_514) {
      Data = theData;
      while ((Offset < wVar5 && (Offset + tLen <= wVar5))) {
        iVar8 = Offset + tLen;
        if (case_sensitive == '\0') {
          local_510 = LYno_attr_mbcs_case_strstr
                                (Data + wVar4,target,utf_flag,'\x01',&HitOffset,&LenNeeded);
        }
        else {
          local_510 = LYno_attr_mbcs_strstr
                                (Data + wVar4,target,utf_flag,'\x01',&HitOffset,&LenNeeded);
        }
        cp = local_510;
        if ((local_510 == (char *)0x0) || (LYcols <= LenNeeded + iVar8)) goto highlight_search_done;
        Data = local_510;
        Offset = HitOffset + iVar8;
      }
      if ((Offset < wVar5) && (wVar5 < Offset + tLen)) {
        itmp = L'\0';
        iVar8 = Offset - wVar5;
        LYmove(y_00,wVar5);
        tmp[0] = buffer[0];
        wVar6 = utf8_length(utf_flag,buffer);
        if (wVar6 == L'\0') {
          if ((HTCJK == NOCJK) || (-1 < tmp[0])) {
            if (flag == L'\x01') {
              LYmove(y_00,wVar5 + L'\x01');
            }
            else {
              LYstartTargetEmphasis();
              TargetEmphasisON_local = '\x01';
              sVar7 = strlen(tmp);
              LYwaddnstr(LYwin,tmp,sVar7);
            }
            written = L'\x01';
          }
          else {
            itmp = L'\x01';
            if (flag == L'\x01') {
              LYmove(y_00,wVar5 + L'\x01');
            }
            else {
              LYstartTargetEmphasis();
              TargetEmphasisON_local = '\x01';
              sVar7 = strlen(tmp);
              LYwaddnstr(LYwin,tmp,sVar7);
            }
            tmp[1] = '\0';
            written = L'\x02';
          }
        }
        else {
          LYstrncpy(tmp + 1,buffer + 1,wVar6);
          if (flag == L'\x01') {
            LYmove(y_00,wVar5 + L'\x01');
          }
          else {
            LYstartTargetEmphasis();
            TargetEmphasisON_local = '\x01';
            sVar7 = strlen(tmp);
            LYwaddnstr(LYwin,tmp,sVar7);
          }
          tmp[1] = '\0';
          written = wVar6 + L'\x01';
          itmp = wVar6;
        }
        itmp = itmp + L'\x01';
        if ((TargetEmphasisON_local == '\0') && (buffer[itmp] != '\0')) {
          LYstartTargetEmphasis();
          TargetEmphasisON_local = '\x01';
        }
        for (; (written < iVar8 + wVar4 && (tmp[0] = buffer[itmp], tmp[0] != '\0'));
            itmp = itmp + L'\x01') {
          wVar6 = utf8_length(utf_flag,buffer + itmp);
          if (wVar6 == L'\0') {
            if ((HTCJK == NOCJK) || (-1 < tmp[0])) {
              if ((flag == L'\x01') && (buffer[itmp + L'\x01'] == '\0')) {
                LYstopTargetEmphasis();
                TargetEmphasisON_local = '\0';
                if (LYwin == (WINDOW *)0x0) {
                  local_4f8 = -1;
                }
                else {
                  local_4f8 = (int)LYwin->_curx;
                }
                LYmove(y_00,local_4f8 + L'\x01');
              }
              else {
                sVar7 = strlen(tmp);
                LYwaddnstr(LYwin,tmp,sVar7);
              }
              written = written + L'\x01';
            }
            else {
              tmp[1] = buffer[itmp + L'\x01'];
              if ((flag == L'\x01') && (buffer[itmp + L'\x02'] == '\0')) {
                LYstopTargetEmphasis();
                TargetEmphasisON_local = '\0';
                if (LYwin == (WINDOW *)0x0) {
                  local_500 = -1;
                }
                else {
                  local_500 = (int)LYwin->_curx;
                }
                LYmove(y_00,local_500 + L'\x01');
              }
              else {
                sVar7 = strlen(tmp);
                LYwaddnstr(LYwin,tmp,sVar7);
              }
              tmp[1] = '\0';
              written = written + L'\x02';
              itmp = itmp + L'\x01';
            }
          }
          else {
            LYstrncpy(tmp + 1,buffer + itmp + L'\x01',wVar6);
            if ((flag == L'\x01') && (buffer[itmp + wVar6 + L'\x01'] == '\0')) {
              LYstopTargetEmphasis();
              TargetEmphasisON_local = '\0';
              if (LYwin == (WINDOW *)0x0) {
                local_508 = -1;
              }
              else {
                local_508 = (int)LYwin->_curx;
              }
              LYmove(y_00,local_508 + L'\x01');
            }
            else {
              sVar7 = strlen(tmp);
              LYwaddnstr(LYwin,tmp,sVar7);
            }
            tmp[1] = '\0';
            written = written + wVar6 + L'\x01';
            itmp = itmp + wVar6;
          }
        }
        if (TargetEmphasisON_local != '\0') {
          LYstopTargetEmphasis();
          TargetEmphasisON_local = '\0';
        }
        if (LYwin == (WINDOW *)0x0) {
          local_4f0 = -1;
        }
        else {
          local_4f0 = (int)LYwin->_curx;
        }
        if (flag == L'\x01') {
          local_4ec = local_514 + L'\xffffffff';
        }
        else {
          local_4ec = local_514;
        }
        if (local_4ec + wVar5 <= local_4f0) goto highlight_search_done;
        if (case_sensitive == '\0') {
          if (utf_flag == '\0') {
            local_4d8 = Data + (local_4f0 - Offset);
          }
          else {
            local_4d8 = LYmbcs_skip_glyphs(Data,local_4f0 - Offset,utf_flag);
          }
          local_4e8 = LYno_attr_mbcs_case_strstr
                                (local_4d8,target,utf_flag,'\x01',&HitOffset,&LenNeeded);
        }
        else {
          if (utf_flag == '\0') {
            local_4e0 = Data + (local_4f0 - Offset);
          }
          else {
            local_4e0 = LYmbcs_skip_glyphs(Data,local_4f0 - Offset,utf_flag);
          }
          local_4e8 = LYno_attr_mbcs_strstr(local_4e0,target,utf_flag,'\x01',&HitOffset,&LenNeeded);
        }
        cp = local_4e8;
        if ((local_4e8 == (char *)0x0) || (LYcols <= LenNeeded + local_4f0))
        goto highlight_search_done;
        if (flag == L'\x01') {
          local_4d0 = local_514 + L'\xffffffff';
        }
        else {
          local_4d0 = local_514;
        }
        if (local_4d0 + wVar5 <= local_4f0 + HitOffset) goto highlight_search_done;
        Data = local_4e8;
        Offset = HitOffset + local_4f0;
      }
      while( true ) {
        data = buffer;
        if (flag == L'\x01') {
          local_4c8 = local_514 + L'\xffffffff';
        }
        else {
          local_4c8 = local_514;
        }
        if (local_4c8 < Offset - wVar5) goto highlight_search_done;
        if (utf_flag == '\0') {
          pcVar3 = data + (Offset - wVar5);
        }
        else {
          pcVar3 = LYmbcs_skip_glyphs(data,Offset - wVar5,utf_flag);
          LYrefresh();
        }
        wVar6 = Offset;
        itmp = L'\0';
        LYmove(y_00,Offset);
        tmp[0] = *pcVar3;
        n = utf8_length(utf_flag,pcVar3);
        if (n == L'\0') {
          if ((HTCJK == NOCJK) || (-1 < tmp[0])) {
            if ((flag == L'\x01') && ((wVar6 <= wVar5 || (pcVar3[1] == '\0')))) {
              LYmove(y_00,wVar6 + L'\x01');
            }
            else {
              LYstartTargetEmphasis();
              TargetEmphasisON_local = '\x01';
              sVar7 = strlen(tmp);
              LYwaddnstr(LYwin,tmp,sVar7);
            }
            written = L'\x01';
          }
          else {
            itmp = L'\x01';
            tmp[1] = pcVar3[1];
            if ((flag == L'\x01') && ((wVar6 <= wVar5 || (pcVar3[2] == '\0')))) {
              LYmove(y_00,wVar6 + L'\x02');
            }
            else {
              LYstartTargetEmphasis();
              TargetEmphasisON_local = '\x01';
              sVar7 = strlen(tmp);
              LYwaddnstr(LYwin,tmp,sVar7);
            }
            tmp[1] = '\0';
            written = L'\x02';
          }
        }
        else {
          LYstrncpy(tmp + 1,pcVar3 + 1,n);
          if ((flag == L'\x01') && ((wVar6 <= wVar5 || (pcVar3[n + L'\x01'] == '\0')))) {
            LYmove(y_00,wVar6 + L'\x01');
          }
          else {
            LYstartTargetEmphasis();
            TargetEmphasisON_local = '\x01';
            sVar7 = strlen(tmp);
            LYwaddnstr(LYwin,tmp,sVar7);
          }
          tmp[1] = '\0';
          written = n + L'\x01';
          itmp = n;
        }
        itmp = itmp + L'\x01';
        if ((TargetEmphasisON_local == '\0') && (pcVar3[itmp] != '\0')) {
          LYstartTargetEmphasis();
          TargetEmphasisON_local = '\x01';
        }
        for (; (written < wVar4 && (tmp[0] = pcVar3[itmp], tmp[0] != '\0')); itmp = itmp + L'\x01')
        {
          wVar6 = utf8_length(utf_flag,pcVar3 + itmp);
          if (wVar6 == L'\0') {
            if ((HTCJK == NOCJK) || (-1 < tmp[0])) {
              if ((flag == L'\x01') && (pcVar3[itmp + L'\x01'] == '\0')) {
                LYstopTargetEmphasis();
                TargetEmphasisON_local = '\0';
                if (LYwin == (WINDOW *)0x0) {
                  local_4ac = -1;
                }
                else {
                  local_4ac = (int)LYwin->_curx;
                }
                LYmove(y_00,local_4ac + L'\x01');
              }
              else {
                sVar7 = strlen(tmp);
                LYwaddnstr(LYwin,tmp,sVar7);
              }
              written = written + L'\x01';
            }
            else {
              tmp[1] = pcVar3[itmp + L'\x01'];
              if ((flag == L'\x01') && (pcVar3[itmp + L'\x02'] == '\0')) {
                LYstopTargetEmphasis();
                TargetEmphasisON_local = '\0';
                if (LYwin == (WINDOW *)0x0) {
                  local_4b4 = -1;
                }
                else {
                  local_4b4 = (int)LYwin->_curx;
                }
                LYmove(y_00,local_4b4 + L'\x01');
              }
              else {
                sVar7 = strlen(tmp);
                LYwaddnstr(LYwin,tmp,sVar7);
              }
              tmp[1] = '\0';
              written = written + L'\x02';
              itmp = itmp + L'\x01';
            }
          }
          else {
            LYstrncpy(tmp + 1,pcVar3 + itmp + L'\x01',wVar6);
            if ((flag == L'\x01') && (pcVar3[itmp + wVar6 + L'\x01'] == '\0')) {
              LYstopTargetEmphasis();
              TargetEmphasisON_local = '\0';
              if (LYwin == (WINDOW *)0x0) {
                local_4bc = -1;
              }
              else {
                local_4bc = (int)LYwin->_curx;
              }
              LYmove(y_00,local_4bc + L'\x01');
            }
            else {
              sVar7 = strlen(tmp);
              LYwaddnstr(LYwin,tmp,sVar7);
            }
            tmp[1] = '\0';
            written = written + wVar6 + L'\x01';
            itmp = itmp + wVar6;
          }
        }
        if (TargetEmphasisON_local != '\0') {
          LYstopTargetEmphasis();
          TargetEmphasisON_local = '\0';
        }
        if (LYwin == (WINDOW *)0x0) {
          local_4a4 = -1;
        }
        else {
          local_4a4 = (int)LYwin->_curx;
        }
        if (flag == L'\x01') {
          local_4a0 = local_514 + L'\xffffffff';
        }
        else {
          local_4a0 = local_514;
        }
        if (local_4a0 + wVar5 <= local_4a4) goto highlight_search_done;
        if (case_sensitive == '\0') {
          if (utf_flag == '\0') {
            local_48c = Data + (local_4a4 - Offset);
          }
          else {
            local_48c = LYmbcs_skip_glyphs(Data,local_4a4 - Offset,utf_flag);
          }
          local_49c = LYno_attr_mbcs_case_strstr
                                (local_48c,target,utf_flag,'\x01',&HitOffset,&LenNeeded);
        }
        else {
          if (utf_flag == '\0') {
            local_494 = Data + (local_4a4 - Offset);
          }
          else {
            local_494 = LYmbcs_skip_glyphs(Data,local_4a4 - Offset,utf_flag);
          }
          local_49c = LYno_attr_mbcs_strstr(local_494,target,utf_flag,'\x01',&HitOffset,&LenNeeded);
        }
        cp = local_49c;
        if ((local_49c == (char *)0x0) || (LYcols <= LenNeeded + local_4a4))
        goto highlight_search_done;
        if (flag == L'\x01') {
          local_484 = local_514 + L'\xffffffff';
        }
        else {
          local_484 = local_514;
        }
        if (local_484 + wVar5 <= local_4a4 + HitOffset) goto highlight_search_done;
        if (wVar5 + local_514 <= tLen + local_4a4 + HitOffset) break;
        Data = local_49c;
        Offset = HitOffset + local_4a4;
      }
      wVar4 = local_4a4 + HitOffset;
      if (utf_flag == '\0') {
        pcVar3 = Data + (wVar4 - wVar5);
      }
      else {
        pcVar3 = LYmbcs_skip_glyphs(Data,wVar4 - wVar5,utf_flag);
        LYrefresh();
      }
      LYmove(y_00,wVar4);
      itmp = L'\0';
      written = L'\0';
      wVar4 = strlen(pcVar3);
      LYstartTargetEmphasis();
      TargetEmphasisON_local = '\x01';
      for (; (written < wVar4 && (tmp[0] = pcVar3[itmp], tmp[0] != '\0')); itmp = itmp + L'\x01') {
        wVar5 = utf8_length(utf_flag,pcVar3 + itmp);
        if (wVar5 == L'\0') {
          if ((HTCJK == NOCJK) || (-1 < tmp[0])) {
            if ((flag == L'\x01') && (pcVar3[itmp + L'\x01'] == '\0')) {
              LYstopTargetEmphasis();
              TargetEmphasisON_local = '\0';
            }
            else {
              sVar7 = strlen(tmp);
              LYwaddnstr(LYwin,tmp,sVar7);
            }
            written = written + L'\x01';
          }
          else {
            tmp[1] = pcVar3[itmp + L'\x01'];
            if ((flag == L'\x01') && (pcVar3[itmp + L'\x02'] == '\0')) {
              LYstopTargetEmphasis();
              TargetEmphasisON_local = '\0';
            }
            else {
              sVar7 = strlen(tmp);
              LYwaddnstr(LYwin,tmp,sVar7);
            }
            tmp[1] = '\0';
            written = written + L'\x02';
            itmp = itmp + L'\x01';
          }
        }
        else {
          LYstrncpy(tmp + 1,pcVar3 + itmp + L'\x01',wVar5);
          if ((flag == L'\x01') && (pcVar3[itmp + wVar5 + L'\x01'] == '\0')) {
            LYstopTargetEmphasis();
            TargetEmphasisON_local = '\0';
            if (LYwin == (WINDOW *)0x0) {
              local_478 = -1;
            }
            else {
              local_478 = (int)LYwin->_curx;
            }
            LYmove(y_00,local_478 + L'\x01');
          }
          else {
            sVar7 = strlen(tmp);
            LYwaddnstr(LYwin,tmp,sVar7);
          }
          tmp[1] = '\0';
          written = written + wVar5 + L'\x01';
          itmp = itmp + wVar5;
        }
      }
      if (TargetEmphasisON_local != '\0') {
        LYstopTargetEmphasis();
      }
    }
  }
highlight_search_done:
  if (theData != (char *)0x0) {
    free(theData);
    theData = (char *)0x0;
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return TargetEmphasisON_local;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

wchar_t find_cached_style(wchar_t cur,wchar_t flag)

{
  int iVar1;
  int iVar2;
  BOOLEAN BVar3;
  FILE *pFVar4;
  wchar_t x;
  wchar_t s;
  
  s = s_alink;
  if (((textfields_need_activation != '\0') && (links[cur].type == 1)) &&
     (((links[cur].l_form)->type == 1 ||
      (((((links[cur].l_form)->type == 0xc || ((links[cur].l_form)->type == 2)) ||
        ((links[cur].l_form)->type == 0xb)) || ((links[cur].l_form)->type == 9)))))) {
    s = s_curedit;
  }
  if (flag == L'\x01') {
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
      iVar1 = links[cur].lx;
      iVar2 = links[cur].ly;
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"STYLE.highlight.on: @(%d,%d).\n",iVar2,iVar1);
    }
  }
  else {
    BVar3 = ValidCachedStyle(links[cur].ly,links[cur].lx);
    if (BVar3 == '\0') {
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
        pFVar4 = TraceFP();
        fprintf((FILE *)pFVar4,"STYLE.highlight.off: can\'t use cache.\n");
      }
      s = s_a;
    }
    else {
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
        iVar1 = links[cur].lx;
        iVar2 = links[cur].ly;
        pFVar4 = TraceFP();
        fprintf((FILE *)pFVar4,"STYLE.highlight.off: cached style @(%d,%d): ",iVar2,iVar1);
      }
      s = GetCachedStyle(links[cur].ly,links[cur].lx);
      if (s == L'\0') {
        x = links[cur].lx;
        do {
          x = x + L'\xffffffff';
          if (x < L'\0') goto LAB_08092b86;
          s = GetCachedStyle(links[cur].ly,x);
        } while (s == L'\0');
        SetCachedStyle(links[cur].ly,links[cur].lx,s);
        if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
          iVar1 = links[cur].lx;
          pFVar4 = TraceFP();
          fprintf((FILE *)pFVar4,"found %d, x_offset=%d.\n",s,x - iVar1);
        }
LAB_08092b86:
        if (s == L'\0') {
          if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
            pFVar4 = TraceFP();
            fprintf((FILE *)pFVar4,"not found, assume <a>.\n");
          }
          s = s_a;
        }
      }
      else if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
        pFVar4 = TraceFP();
        fprintf((FILE *)pFVar4,"found %d.\n",s);
      }
    }
  }
  return s;
}



void LYhighlight(wchar_t flag,wchar_t cur,char *target)

{
  int iVar1;
  int iVar2;
  int iVar3;
  bool bVar4;
  bool bVar5;
  FILE *pFVar6;
  wchar_t wVar7;
  char *pcVar8;
  wchar_t x;
  size_t sVar9;
  int iVar10;
  int in_GS_OFFSET;
  bool utf_flag_00;
  int local_478;
  char *local_474;
  undefined *local_46c;
  char *local_460;
  int local_45c;
  wchar_t local_458;
  wchar_t local_454;
  char *target_local;
  char tmp [7];
  wchar_t row;
  char *text;
  wchar_t avail_space;
  wchar_t gllen;
  wchar_t len;
  char *hi_string;
  wchar_t title_adjust;
  wchar_t hi_offset;
  wchar_t hi_count;
  wchar_t i;
  BOOLEAN hl2_drawn;
  BOOLEAN hl1_drawn;
  BOOLEAN utf_flag;
  BOOLEAN target1_drawn;
  BOOLEAN TargetEmphasisON;
  char buffer [1024];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if (no_title == '\0') {
    local_478 = 0;
  }
  else {
    local_478 = -1;
  }
  TargetEmphasisON = '\0';
  utf_flag_00 = LYCharSet_UC[current_char_set].enc == 7;
  bVar5 = false;
  tmp[2] = '\0';
  tmp[1] = '\0';
  tmp[0] = '\0';
  if (cur < L'\0') {
    if (WWW_TraceFlag != '\0') {
      pFVar6 = TraceFP();
      fprintf((FILE *)pFVar6,"LYhighlight cur %d (bug workaround)\n",cur);
    }
    cur = L'\0';
  }
  if (WWW_TraceFlag != '\0') {
    if (target == (char *)0x0) {
      local_474 = "(null)";
    }
    else {
      local_474 = target;
    }
    iVar2 = links[cur].anchor_number;
    if (flag == L'\0') {
      local_46c = &DAT_081564e3;
    }
    else {
      local_46c = &DAT_081564e0;
    }
    iVar10 = links[cur].lx;
    iVar3 = links[cur].ly;
    pFVar6 = TraceFP();
    fprintf((FILE *)pFVar6,"LYhighlight at(%2d,%2d) %s %d [%d]:%s\n",iVar3,iVar10,local_46c,cur,
            iVar2,local_474);
  }
  if (0 < nlinks) {
    if ((flag == L'\x01') || (links[cur].type == 1)) {
      LYmove(links[cur].ly + local_478,links[cur].lx);
      wVar7 = find_cached_style(cur,flag);
      curses_style(wVar7,L'\x01');
    }
    if (links[cur].type == 1) {
      avail_space = ((LYcols - (uint)(LYShowScrollbar != '\0')) - links[cur].lx) +
                    (LYlines - links[cur].ly) * (LYcols - (uint)(LYShowScrollbar != '\0'));
      text = LYGetHiliteStr(cur,L'\0');
      if (text == (char *)0x0) {
        text = "";
      }
      if ((links[cur].l_form)->size < avail_space) {
        avail_space = (links[cur].l_form)->size;
      }
      gllen = LYmbcsstrlen(text,utf_flag_00,'\x01');
      pcVar8 = LYmbcs_skip_cells(text,avail_space,utf_flag_00);
      LYwaddnstr(LYwin,text,(int)pcVar8 - (int)text);
      while (bVar4 = gllen < avail_space, gllen = gllen + L'\x01', bVar4) {
        waddch(LYwin,0x5f);
      }
    }
    else if (flag == L'\0') {
      bVar5 = true;
      redraw_lines_of_link(cur);
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
        iVar2 = links[cur].lx;
        iVar10 = links[cur].ly;
        pFVar6 = TraceFP();
        fprintf((FILE *)pFVar6,"STYLE.highlight.off: NOFIX branch @(%d,%d).\n",iVar10,iVar2);
      }
    }
    else {
      iVar10 = LYcols - (uint)(LYShowScrollbar != '\0');
      iVar2 = links[cur].lx;
      pcVar8 = LYGetHiliteStr(cur,L'\0');
      if (pcVar8 == (char *)0x0) {
        local_460 = "";
      }
      else {
        local_460 = LYGetHiliteStr(cur,L'\0');
      }
      LYmbcsstrncpy(buffer,local_460,L'',iVar10 - iVar2,utf_flag_00);
      sVar9 = strlen(buffer);
      LYwaddnstr(LYwin,buffer,sVar9);
    }
    if (!bVar5) {
      for (hi_count = L'\x01';
          (pcVar8 = LYGetHiliteStr(cur,hi_count), pcVar8 != (char *)0x0 &&
          (links[cur].ly + hi_count <= display_lines)); hi_count = hi_count + L'\x01') {
        wVar7 = links[cur].ly + hi_count + local_478;
        x = LYGetHilitePos(cur,hi_count);
        lynx_stop_link_color((uint)(flag == L'\x01'),(int)links[cur].inUnderline);
        LYmove(wVar7,x);
        if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
          if (flag == L'\x01') {
            local_45c = s_alink;
          }
          else {
            local_45c = s_a;
          }
          pFVar6 = TraceFP();
          fprintf((FILE *)pFVar6,"STYLE.highlight.line2: @(%d,%d), style=%d.\n",wVar7,x,local_45c);
        }
        if (flag == L'\x01') {
          local_458 = s_alink;
        }
        else {
          local_458 = s_a;
        }
        curses_style(local_458,L'\x02');
        for (i = L'\0'; (tmp[0] = pcVar8[i], tmp[0] != '\0' && (i + x < LYcols)); i = i + L'\x01') {
          if ((pcVar8[i] < '\x03') || ('\b' < pcVar8[i])) {
            if ((HTCJK == NOCJK) || (-1 < tmp[0])) {
              sVar9 = strlen(tmp);
              LYwaddnstr(LYwin,tmp,sVar9);
            }
            else {
              i = i + L'\x01';
              tmp[1] = pcVar8[i];
              sVar9 = strlen(tmp);
              LYwaddnstr(LYwin,tmp,sVar9);
              tmp[1] = '\0';
            }
          }
        }
      }
      lynx_stop_link_color((uint)(flag == L'\x01'),(int)links[cur].inUnderline);
    }
    hi_count = L'\0';
    while (pcVar8 = LYGetHiliteStr(cur,hi_count), pcVar8 != (char *)0x0) {
      TargetEmphasisON = show_whereis_targets(flag,cur,hi_count,target,TargetEmphasisON,utf_flag_00)
      ;
      hi_count = hi_count + L'\x01';
    }
    if (LYShowCursor == '\0') {
      LYmove(LYlines + L'\xffffffff',(LYcols - (uint)(LYShowScrollbar != '\0')) + L'\xffffffff');
    }
    else {
      if (links[cur].lx < 1) {
        local_454 = L'\0';
      }
      else {
        local_454 = links[cur].lx + L'\xffffffff';
      }
      LYmove(links[cur].ly + local_478,local_454);
    }
    if (flag != L'\0') {
      LYrefresh();
    }
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



// WARNING: Unknown calling convention

void free_and_clear(char **pointer)

{
  if (*pointer != (char *)0x0) {
    if (*pointer != (char *)0x0) {
      free(*pointer);
      *pointer = (char *)0x0;
    }
    *pointer = (char *)0x0;
  }
  return;
}



void convert_to_spaces(char *string,BOOLEAN condense)

{
  char cVar1;
  bool bVar2;
  BOOLEAN condense_local;
  char *ns;
  char *s;
  BOOLEAN last_is_space;
  
  bVar2 = false;
  if (string != (char *)0x0) {
    ns = LYSkipNonBlanks(string);
    for (s = ns; *s != '\0'; s = s + 1) {
      cVar1 = *s;
      if (cVar1 == '\n') {
LAB_080936ba:
        if (!bVar2) {
          *ns = ' ';
          ns = ns + 1;
          bVar2 = true;
        }
      }
      else {
        if (cVar1 < '\v') {
          if (cVar1 == '\t') {
LAB_0809369e:
            if ((condense == '\0') || (!bVar2)) {
              *ns = ' ';
              ns = ns + 1;
            }
            bVar2 = true;
            goto LAB_080936e3;
          }
        }
        else {
          if (cVar1 == '\r') goto LAB_080936ba;
          if (cVar1 == ' ') goto LAB_0809369e;
        }
        *ns = *s;
        ns = ns + 1;
        bVar2 = false;
      }
LAB_080936e3:
    }
    *ns = '\0';
  }
  return;
}



// WARNING: Unknown calling convention

char * strip_trailing_slash(char *dirname)

{
  wchar_t i;
  
  i = strlen(dirname);
  while ((i = i + L'\xffffffff', L'\xffffffff' < i && (dirname[i] == '/'))) {
    dirname[i] = '\0';
  }
  return dirname;
}



// WARNING: Unknown calling convention

void remove_most_blanks(char *buffer)

{
  bool bVar1;
  size_t sVar2;
  undefined *__src;
  size_t __n;
  wchar_t length;
  BOOLEAN trailing;
  
  sVar2 = strlen(buffer);
  if ((sVar2 == 0) || (buffer[sVar2 - 1] != ' ')) {
    bVar1 = false;
  }
  else {
    bVar1 = true;
  }
  LYReduceBlanks(buffer);
  if (bVar1) {
    __n = 2;
    __src = &DAT_0815656c;
    sVar2 = strlen(buffer);
    memcpy(buffer + sVar2,__src,__n);
  }
  return;
}



void statusline(char *text)

{
  bool bVar1;
  size_t sVar2;
  uchar *euc;
  wchar_t wVar3;
  char *pcVar4;
  int iVar5;
  int in_GS_OFFSET;
  wchar_t local_84c;
  wchar_t local_848;
  uint local_844;
  wchar_t local_840;
  char *text_local;
  wchar_t a;
  wchar_t x;
  wchar_t y;
  char *p;
  wchar_t at_lineno;
  wchar_t j;
  wchar_t i;
  wchar_t len;
  wchar_t max_length;
  uchar *temp;
  BOOLEAN has_CJK;
  uchar k;
  char text_buff [1024];
  char buffer [1024];
  int local_8;
  
  local_8 = *(int *)(in_GS_OFFSET + 0x14);
  if (((text != (char *)0x0) && (dump_output_immediately == '\0')) &&
     ((mustshow == '\x01' || (no_statusline != '\x01')))) {
    mustshow = '\0';
    LYstrncpy(text_buff,text,L'');
    strchr(text_buff,10);
    local_84c = (LYcols - (uint)(LYShowScrollbar != '\0')) + L'\xffffffff';
    if (L'' < local_84c) {
      local_84c = L'';
    }
    if ((text_buff[0] == '\0') || (LYHaveCJKCharacterSet == '\0')) {
      remove_most_blanks(text_buff);
      len = strlen(text_buff);
      if (L'' < len) {
        len = L'';
      }
      pcVar4 = strncpy(buffer,text_buff,len);
      pcVar4[len] = '\0';
      while ((L'\0' < len && (wVar3 = LYstrExtent(buffer,len,len), local_84c < wVar3))) {
        text_buff[len + L''] = '\0';
        len = len + L'\xffffffff';
      }
    }
    else {
      sVar2 = strlen(text_buff);
      euc = (uchar *)calloc(sVar2 + 1,1);
      if (euc == (uchar *)0x0) {
        outofmem("./LYUtils.c","statusline");
      }
      if (kanji_code == EUC) {
        TO_EUC((uchar *)text_buff,euc);
      }
      else if (kanji_code == SJIS) {
        strcpy((char *)euc,text_buff);
      }
      else {
        j = L'\0';
        for (i = L'\0'; text_buff[i] != '\0'; i = i + L'\x01') {
          if (text_buff[i] != '\x1b') {
            euc[j] = text_buff[i];
            j = j + L'\x01';
          }
        }
        euc[j] = '\0';
      }
      remove_most_blanks((char *)euc);
      i = L'\0';
      j = L'\0';
      len = L'\0';
      k = '\0';
      while ((euc[i] != '\0' && (len < local_84c))) {
        if (k == '\0') {
          if ((char)euc[i] < '\0') {
            k = euc[i];
          }
          else {
            buffer[j] = euc[i];
            j = j + L'\x01';
            len = len + L'\x01';
          }
        }
        else {
          buffer[j] = k;
          buffer[j + L'\x01'] = euc[i];
          j = j + L'\x02';
          k = '\0';
          len = len + L'\x02';
        }
        i = i + L'\x01';
      }
      buffer[j] = '\0';
      if (euc != (uchar *)0x0) {
        free(euc);
      }
    }
    if (LYStatusLine < 0) {
      if (user_mode == 0) {
        at_lineno = LYlines + L'\xfffffffd';
      }
      else {
        at_lineno = LYlines + L'\xffffffff';
      }
    }
    else if (LYStatusLine < LYlines + -1) {
      at_lineno = LYStatusLine;
    }
    else {
      at_lineno = LYlines + L'\xffffffff';
    }
    LYmove(at_lineno,L'\0');
    LYclrtoeol();
    if (buffer[0] != '\0') {
      bVar1 = false;
      if (HTCJK != NOCJK) {
        for (i = L'\0'; buffer[i] != '\0'; i = i + L'\x01') {
          if (buffer[i] < '\0') {
            bVar1 = true;
            break;
          }
        }
      }
      if (bVar1) {
        LYrefresh();
      }
      pcVar4 = (char *)gettext("Alert!: %s");
      iVar5 = strncmp(buffer,pcVar4,5);
      if ((iVar5 == 0) && (hashStyles[s_alert].name != (char *)0x0)) {
        local_848 = s_alert;
      }
      else {
        local_848 = s_status;
      }
      curses_style(local_848,L'\x01');
      sVar2 = strlen(buffer);
      LYwaddnstr(LYwin,buffer,sVar2);
      if ((lynx_has_color == L'\0') || (LYShowColor < 2)) {
        local_844 = 0x20;
      }
      else {
        local_844 = hashStyles[local_848].color | 0x20;
      }
      wbkgdset(LYwin,local_844);
      if (LYwin == (WINDOW *)0x0) {
        local_840 = L'\xffffffff';
      }
      else {
        local_840 = (wchar_t)LYwin->_cury;
      }
      if (local_840 == at_lineno) {
        LYclrtoeol();
      }
      if ((lynx_has_color == L'\0') || (LYShowColor < 2)) {
        wbkgdset(LYwin,0x20);
      }
      else if (s_normal == -1) {
        wbkgdset(LYwin,displayStyles[128].color | 0x20);
      }
      else {
        wbkgdset(LYwin,hashStyles[s_normal].color | 0x20);
      }
      curses_style(local_848,L'\0');
    }
    LYrefresh();
  }
  if (local_8 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

char * novice_lines(wchar_t lineno)

{
  char *local_8;
  
  if (lineno == L'\x01') {
    local_8 = (char *)gettext(
                             "  O)ther cmds  B)ack  E)dit  D)ownload ^R)eload ^W)ipe screen  search doc: / \n"
                             );
  }
  else if (lineno == L'\x02') {
    local_8 = (char *)gettext(
                             "O)ther cmds  C)omment  History: <backspace>  Bookmarks: V)iew, A)dd, R)emove \n"
                             );
  }
  else if (lineno == L'\0') {
    local_8 = (char *)gettext(
                             "  O)ther cmds  H)elp  K)eymap  G)oto  P)rint  M)ain screen  o)ptions  Q)uit  \n"
                             );
  }
  else {
    local_8 = "";
  }
  return local_8;
}



// WARNING: Unknown calling convention

void toggle_novice_line(void)

{
  char *pcVar1;
  
  lineno = lineno + L'\x01';
  pcVar1 = novice_lines(lineno);
  if (*pcVar1 == '\0') {
    lineno = L'\0';
  }
  return;
}



// WARNING: Unknown calling convention

void noviceline(wchar_t more_flag)

{
  char *pcVar1;
  size_t sVar2;
  
  if (dump_output_immediately == '\0') {
    LYmove(LYlines + L'\xfffffffe',L'\0');
    LYclrtoeol();
    pcVar1 = (char *)gettext(
                            "  Arrow keys: Up and Down to move.  Right to follow a link; Left to go back.  \n"
                            );
    sVar2 = strlen(pcVar1);
    pcVar1 = (char *)gettext(
                            "  Arrow keys: Up and Down to move.  Right to follow a link; Left to go back.  \n"
                            );
    LYwaddnstr(LYwin,pcVar1,sVar2);
    LYmove(LYlines + L'\xffffffff',L'\0');
    LYclrtoeol();
    if ((lynx_edit_mode == '\0') || (no_dired_support != '\0')) {
      if (LYUseNoviceLineTwo == '\0') {
        pcVar1 = novice_lines(lineno);
        sVar2 = strlen(pcVar1);
        pcVar1 = novice_lines(lineno);
        LYwaddnstr(LYwin,pcVar1,sVar2);
      }
      else {
        pcVar1 = (char *)gettext(
                                " H)elp O)ptions P)rint G)o M)ain screen Q)uit /=search [delete]=history list \n"
                                );
        sVar2 = strlen(pcVar1);
        pcVar1 = (char *)gettext(
                                " H)elp O)ptions P)rint G)o M)ain screen Q)uit /=search [delete]=history list \n"
                                );
        LYwaddnstr(LYwin,pcVar1,sVar2);
      }
    }
    else {
      pcVar1 = (char *)gettext(
                              "  C)reate  D)ownload  E)dit  F)ull menu  M)odify  R)emove  T)ag  U)pload     \n"
                              );
      sVar2 = strlen(pcVar1);
      pcVar1 = (char *)gettext(
                              "  C)reate  D)ownload  E)dit  F)ull menu  M)odify  R)emove  T)ag  U)pload     \n"
                              );
      LYwaddnstr(LYwin,pcVar1,sVar2);
    }
    LYrefresh();
  }
  return;
}



// WARNING: Unknown calling convention

wchar_t LYReopenInput(void)

{
  FILE *pFVar1;
  int iVar2;
  wchar_t wVar3;
  FILE *pFVar4;
  FILE *pFVar5;
  FILE *frp;
  wchar_t new_fd;
  char *term_name;
  wchar_t fd;
  wchar_t result;
  
  result = L'\0';
  iVar2 = fileno(stdin);
  if (iVar2 == 0) {
    iVar2 = isatty(0);
    if (iVar2 == 0) {
      wVar3 = LYConsoleInputFD('\0');
      if (wVar3 == L'\0') {
        term_name = (char *)0x0;
        new_fd = L'\xffffffff';
        iVar2 = fileno(stdout);
        iVar2 = isatty(iVar2);
        if (iVar2 != 0) {
          iVar2 = fileno(stdout);
          term_name = ttyname(iVar2);
          if (term_name != (char *)0x0) {
            new_fd = open64(term_name,0);
          }
        }
        if (new_fd == L'\xffffffff') {
          iVar2 = fileno(stderr);
          iVar2 = isatty(iVar2);
          if (iVar2 != 0) {
            iVar2 = fileno(stderr);
            term_name = ttyname(iVar2);
            if (term_name != (char *)0x0) {
              new_fd = open64(term_name,0);
            }
          }
        }
        if (new_fd == L'\xffffffff') {
          term_name = ctermid((char *)0x0);
          if (term_name != (char *)0x0) {
            new_fd = open64(term_name,0);
          }
        }
        if (new_fd == L'\xffffffff') {
          term_name = "/dev/tty";
          new_fd = open64("/dev/tty",0);
        }
        if (WWW_TraceFlag != '\0') {
          pFVar4 = TraceFP();
          fprintf((FILE *)pFVar4,"LYReopenInput open(%s) returned %d.\n",term_name,new_fd);
        }
        if (new_fd < L'\0') {
          result = L'\xffffffff';
        }
        else {
          close(new_fd);
          pFVar5 = freopen64(term_name,"r",stdin);
          if (WWW_TraceFlag != '\0') {
            iVar2 = fileno(stdin);
            pFVar1 = stdin;
            pFVar4 = TraceFP();
            fprintf((FILE *)pFVar4,
                    "LYReopenInput freopen(%s,\"r\",stdin) returned %p, stdin is now %p with fd %d.\n"
                    ,term_name,pFVar5,pFVar1,iVar2);
          }
          result = L'\x01';
        }
      }
    }
  }
  return result;
}



wchar_t LYConsoleInputFD(BOOLEAN need_selectable)

{
  int iVar1;
  wchar_t local_1c;
  BOOLEAN need_selectable_local;
  wchar_t fd;
  
  local_1c = fileno(stdin);
  if (((need_selectable != '\0') && (local_1c != L'\xffffffff')) &&
     (iVar1 = isatty(local_1c), iVar1 == 0)) {
    local_1c = L'\xffffffff';
  }
  return local_1c;
}



void LYFakeZap(BOOLEAN set)

{
  wchar_t wVar1;
  FILE *pFVar2;
  BOOLEAN set_local;
  
  if ((set == '\0') || (L'\0' < fake_zap)) {
    if ((set == '\0') && (fake_zap != L'\0')) {
      if (WWW_TraceFlag != '\0') {
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2,"\r *** Unset simulated \'Z\'");
      }
      wVar1 = fake_zap;
      if (WWW_TraceFlag != '\0') {
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2,", %d pending",wVar1);
      }
      if (WWW_TraceFlag != '\0') {
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2," ***\n");
      }
      fake_zap = L'\0';
    }
  }
  else {
    if (WWW_TraceFlag != '\0') {
      pFVar2 = TraceFP();
      fprintf((FILE *)pFVar2,"\r *** Set simulated \'Z\'");
    }
    wVar1 = fake_zap;
    if ((fake_zap != L'\0') && (WWW_TraceFlag != '\0')) {
      pFVar2 = TraceFP();
      fprintf((FILE *)pFVar2,", %d pending",wVar1);
    }
    if (WWW_TraceFlag != '\0') {
      pFVar2 = TraceFP();
      fprintf((FILE *)pFVar2," ***\n");
    }
    fake_zap = fake_zap + L'\x01';
  }
  return;
}



// WARNING: Unknown calling convention

wchar_t DontCheck(void)

{
  BOOLEAN BVar1;
  wchar_t local_18;
  timeval tv;
  long next;
  
  if (dump_output_immediately == '\0') {
    BVar1 = LYHaveCmdScript();
    if (BVar1 == '\0') {
      gettimeofday((timeval *)&tv,(__timezone_ptr_t)0x0);
      if (tv.tv_usec / 100000 == DontCheck::last) {
        local_18 = L'\x01';
      }
      else {
        local_18 = L'\0';
        DontCheck::last = tv.tv_usec / 100000;
      }
    }
    else {
      local_18 = L'\x01';
    }
  }
  else {
    local_18 = L'\x01';
  }
  return local_18;
}



// WARNING: Unknown calling convention

wchar_t HTCheckForInterrupt(void)

{
  LYKeymap_t LVar1;
  BOOLEAN BVar2;
  FILE *pFVar3;
  wchar_t wVar4;
  int *piVar5;
  char *pcVar6;
  wchar_t local_c0;
  wchar_t local_bc;
  wchar_t local_b8;
  fd_set readfds;
  timeval socket_timeout;
  wchar_t Newline_partial;
  wchar_t res;
  char *s;
  fd_set *__arr;
  uint __i;
  wchar_t ret;
  wchar_t cmd;
  wchar_t c;
  BOOLEAN do_refresh;
  
  if (L'\0' < fake_zap) {
    fake_zap = fake_zap + L'\xffffffff';
    if (WWW_TraceFlag != '\0') {
      pFVar3 = TraceFP();
      fprintf((FILE *)pFVar3,"\r *** Got simulated \'Z\' ***\n");
    }
    if (WWW_TraceFlag != '\0') {
      pFVar3 = TraceFP();
      fflush((FILE *)pFVar3);
    }
    if ((WWW_TraceFlag != '\0') && (LYTraceLogFP == (FILE *)0x0)) {
      sleep(AlertSecs);
    }
    return L'\x01';
  }
  wVar4 = DontCheck();
  if (wVar4 != L'\0') {
    return L'\0';
  }
  ret = L'\0';
  socket_timeout.tv_sec = 0;
  socket_timeout.tv_usec = 0;
  __arr = &readfds;
  for (__i = 0; __i < 0x20; __i = __i + 1) {
    __arr->fds_bits[__i] = 0;
  }
  readfds.fds_bits[0] = readfds.fds_bits[0] | 1;
  ret = select(1,(fd_set *)&readfds,(fd_set *)0x0,(fd_set *)0x0,(timeval *)&socket_timeout);
  if ((ret == L'\xffffffff') && (piVar5 = __errno_location(), *piVar5 == 4)) {
    return L'\0';
  }
  if ((readfds.fds_bits[0] & 1U) == 0) {
    return L'\0';
  }
  c = LYgetch();
  if ((c == L'\x03') || (c == L'\a')) {
LAB_080946b5:
    local_c0 = L'\x01';
  }
  else {
    LVar1 = keymap[0];
    if (c == L'\xffffffff') {
joined_r0x080946b3:
      if (LVar1 == 0x2f) goto LAB_080946b5;
    }
    else {
      if ((c & 0x8800U) == 0) {
        LVar1 = keymap[(c & 0x7ffU) + 1];
        goto joined_r0x080946b3;
      }
      if ((c & 0xffU) == 0x2f) goto LAB_080946b5;
    }
    if (c == L'\xffffffff') {
      local_bc = (wchar_t)keymap[0];
    }
    else {
      if ((c & 0x8800U) == 0) {
        local_b8 = (wchar_t)keymap[(c & 0x7ffU) + 1];
      }
      else {
        local_b8 = c & 0xff;
      }
      local_bc = local_b8;
    }
    cmd = local_bc;
    if (local_bc == L'@') {
      handle_LYK_TRACE_TOGGLE();
    }
    else if (local_bc == L'h') {
      s = LYDownLoadAddress();
      if (((s == (char *)0x0) || (*s == '\0')) || (wVar4 = put_clip(s), wVar4 != L'\0')) {
        pcVar6 = (char *)gettext("Copy to clipboard failed.");
        HTInfoMsg(pcVar6);
      }
      else {
        pcVar6 = (char *)gettext("Download document URL put to clipboard.");
        HTInfoMsg(pcVar6);
      }
    }
    else if ((display_partial != '\0') && (L'\x02' < NumOfLines_partial)) {
      Newline_partial = LYGetNewline();
      switch(cmd) {
      case L'\x0f':
        BVar2 = HText_canScrollDown();
        if (BVar2 != '\0') {
          Newline_partial = Newline_partial + display_lines;
        }
        break;
      case L'\x10':
        if (L'\x01' < Newline_partial) {
          Newline_partial = Newline_partial - display_lines;
        }
        break;
      case L'\x11':
        if (L'\x01' < Newline_partial) {
          Newline_partial = Newline_partial + L'\xfffffffe';
        }
        break;
      case L'\x12':
        BVar2 = HText_canScrollDown();
        if (BVar2 != '\0') {
          Newline_partial = Newline_partial + L'\x02';
        }
        break;
      case L'\x13':
        if (L'\x01' < Newline_partial) {
          Newline_partial = Newline_partial - display_lines / 2;
        }
        break;
      case L'\x14':
        BVar2 = HText_canScrollDown();
        if (BVar2 != '\0') {
          Newline_partial = display_lines / 2 + Newline_partial;
        }
        break;
      case L'\x15':
        break;
      case L'\x16':
        if (L'\x01' < Newline_partial) {
          Newline_partial = L'\x01';
        }
        break;
      case L'\x17':
        BVar2 = HText_canScrollDown();
        if (BVar2 != '\0') {
          wVar4 = HText_getNumOfLines();
          Newline_partial = (wVar4 - display_lines) + L'\x01';
        }
        break;
      default:
        return L'\0';
      case L'\x1e':
        if (display_lines + L'\x01' < Newline_partial) {
          res = HTGetLinkOrFieldStart
                          (L'\xffffffff',&Newline_partial,(wchar_t *)0x0,L'\xffffffff','\x01');
          if (res == L'\b') {
            Newline_partial = Newline_partial + L'\x01';
          }
          else if (res == L'\x10') {
            Newline_partial = Newline_partial - display_lines;
          }
        }
        else {
          Newline_partial = Newline_partial - display_lines;
        }
        break;
      case L'\x1f':
        BVar2 = HText_canScrollDown();
        if (BVar2 != '\0') {
          wVar4 = HText_LinksInLines(HTMainText,Newline_partial,display_lines);
          res = HTGetLinkOrFieldStart
                          (wVar4 + L'\xffffffff',&Newline_partial,(wchar_t *)0x0,L'\x01','\x01');
          if (res == L'\b') {
            Newline_partial = Newline_partial + L'\x01';
          }
        }
        break;
      case L'3':
      case L'4':
      case L'5':
        handle_LYK_WHEREIS(cmd,&do_refresh);
        if (www_search_result != -1) {
          Newline_partial = www_search_result;
          www_search_result = -1;
        }
      }
      if (Newline_partial < L'\x01') {
        Newline_partial = L'\x01';
      }
      BVar2 = LYMainLoop_pageDisplay(Newline_partial);
      if (BVar2 != '\0') {
        NumOfLines_partial = HText_getNumOfLines();
      }
    }
    local_c0 = L'\0';
  }
  return local_c0;
}



// WARNING: Unknown calling convention

BOOLEAN LYisAbsPath(char *path)

{
  BOOLEAN result;
  
  result = '\0';
  if ((path != (char *)0x0) && (*path != '\0')) {
    result = *path == '/';
  }
  return result;
}



// WARNING: Unknown calling convention

BOOLEAN LYisRootPath(char *path)

{
  size_t sVar1;
  BOOLEAN local_8;
  
  sVar1 = strlen(path);
  if ((sVar1 == 1) && (*path == '/')) {
    local_8 = '\x01';
  }
  else {
    local_8 = '\0';
  }
  return local_8;
}



// WARNING: Unknown calling convention

BOOLEAN LYisLocalFile(char *filename)

{
  char *__s;
  char *pcVar1;
  int iVar2;
  char *__s2;
  char *cp;
  char *acc_method;
  char *host;
  
  if (filename == (char *)0x0) {
    return '\0';
  }
  __s = HTParse(filename,"",8);
  if (__s == (char *)0x0) {
    return '\0';
  }
  if (*__s == '\0') {
    if (__s != (char *)0x0) {
      free(__s);
    }
    return '\0';
  }
  pcVar1 = strchr(__s,0x3a);
  if (pcVar1 != (char *)0x0) {
    *pcVar1 = '\0';
  }
  pcVar1 = HTParse(filename,"",0x10);
  if ((pcVar1 != (char *)0x0) && (iVar2 = strcmp("file",pcVar1), iVar2 == 0)) {
    iVar2 = strcmp(__s,"localhost");
    if (iVar2 != 0) {
      __s2 = HTHostName();
      iVar2 = strcmp(__s,__s2);
      if (iVar2 != 0) goto LAB_08094bf3;
    }
    if (__s != (char *)0x0) {
      free(__s);
    }
    if (pcVar1 != (char *)0x0) {
      free(pcVar1);
    }
    return '\x01';
  }
LAB_08094bf3:
  if (__s != (char *)0x0) {
    free(__s);
  }
  if (pcVar1 != (char *)0x0) {
    free(pcVar1);
  }
  return '\0';
}



// WARNING: Unknown calling convention

BOOLEAN LYisLocalHost(char *filename)

{
  char *__s;
  char *pcVar1;
  int iVar2;
  BOOLEAN local_15;
  char *cp;
  char *host;
  
  if (filename == (char *)0x0) {
    local_15 = '\0';
  }
  else {
    __s = HTParse(filename,"",8);
    if (__s == (char *)0x0) {
      local_15 = '\0';
    }
    else if (*__s == '\0') {
      if (__s != (char *)0x0) {
        free(__s);
      }
      local_15 = '\0';
    }
    else {
      pcVar1 = strchr(__s,0x3a);
      if (pcVar1 != (char *)0x0) {
        *pcVar1 = '\0';
      }
      iVar2 = strcmp(__s,"localhost");
      if ((iVar2 != 0) && (iVar2 = strcmp(__s,LYHostName), iVar2 != 0)) {
        pcVar1 = HTHostName();
        iVar2 = strcmp(__s,pcVar1);
        if (iVar2 != 0) {
          if (__s != (char *)0x0) {
            free(__s);
          }
          return '\0';
        }
      }
      if (__s != (char *)0x0) {
        free(__s);
      }
      local_15 = '\x01';
    }
  }
  return local_15;
}



// WARNING: Unknown calling convention

void LYFreeStringList(HTList *list)

{
  void *local_18;
  HTList *cur;
  char *argument;
  
  if (list != (HTList *)0x0) {
    cur = list;
    while( true ) {
      if ((cur == (HTList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
        local_18 = (void *)0x0;
      }
      else {
        local_18 = cur->object;
      }
      if (local_18 == (void *)0x0) break;
      if (local_18 != (void *)0x0) {
        free(local_18);
      }
    }
    HTList_delete(list);
  }
  return;
}



// WARNING: Unknown calling convention

void LYLocalhostAliases_free(void)

{
  LYFreeStringList(localhost_aliases);
  localhost_aliases = (HTList *)0x0;
  return;
}



// WARNING: Unknown calling convention

void LYAddLocalhostAlias(char *alias)

{
  char *LocalAlias;
  
  LocalAlias = (char *)0x0;
  if ((alias != (char *)0x0) && (*alias != '\0')) {
    if (localhost_aliases == (HTList *)0x0) {
      localhost_aliases = HTList_new();
    }
    HTSACopy(&LocalAlias,alias);
    HTList_addObject(localhost_aliases,LocalAlias);
  }
  return;
}



// WARNING: Unknown calling convention

BOOLEAN LYisLocalAlias(char *filename)

{
  char *__s;
  char *pcVar1;
  int iVar2;
  BOOLEAN local_19;
  char *local_18;
  HTList *cur;
  char *cp;
  char *alias;
  char *host;
  
  cur = localhost_aliases;
  if ((localhost_aliases == (HTList *)0x0) || (filename == (char *)0x0)) {
    local_19 = '\0';
  }
  else {
    __s = HTParse(filename,"",8);
    if (__s == (char *)0x0) {
      local_19 = '\0';
    }
    else if (*__s == '\0') {
      if (__s != (char *)0x0) {
        free(__s);
      }
      local_19 = '\0';
    }
    else {
      pcVar1 = strchr(__s,0x3a);
      if (pcVar1 != (char *)0x0) {
        *pcVar1 = '\0';
      }
      do {
        if ((cur == (HTList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
          local_18 = (char *)0x0;
        }
        else {
          local_18 = (char *)cur->object;
        }
        if (local_18 == (char *)0x0) {
          if (__s != (char *)0x0) {
            free(__s);
          }
          return '\0';
        }
        iVar2 = strcmp(__s,local_18);
      } while (iVar2 != 0);
      if (__s != (char *)0x0) {
        free(__s);
      }
      local_19 = '\x01';
    }
  }
  return local_19;
}



// WARNING: Unknown calling convention

UrlTypes LYCheckForProxyURL(char *filename)

{
  char *pcVar1;
  ushort **ppuVar2;
  char *cp2;
  char *cp1;
  char *cp;
  
  cp = filename;
  cp2 = (char *)0x0;
  if ((filename == (char *)0x0) || (*filename == '\0')) {
    return NOT_A_URL_TYPE;
  }
  cp = LYSkipBlanks(filename);
  cp1 = strchr(cp + 1,0x3a);
  if (cp1 != (char *)0x0) {
    pcVar1 = strchr(cp + 1,0x2f);
    if ((pcVar1 != (char *)0x0) && (pcVar1 < cp1)) {
      return NOT_A_URL_TYPE;
    }
    *cp1 = '\0';
    cp2 = (char *)0x0;
    HTSACopy(&cp2,cp);
    *cp1 = ':';
    HTSACat(&cp2,"_proxy");
    pcVar1 = LYGetEnv(cp2);
    if (pcVar1 != (char *)0x0) {
      if (cp2 != (char *)0x0) {
        free(cp2);
      }
      return PROXY_URL_TYPE;
    }
    if (cp2 != (char *)0x0) {
      free(cp2);
      cp2 = (char *)0x0;
    }
    cp1 = cp1 + 1;
    if (*cp == '\0') {
      return NOT_A_URL_TYPE;
    }
    ppuVar2 = __ctype_b_loc();
    if (((*ppuVar2)[(byte)*cp1] & 0x800) == 0) {
      return UNKNOWN_URL_TYPE;
    }
    while ((*cp1 != '\0' && (ppuVar2 = __ctype_b_loc(), ((*ppuVar2)[(byte)*cp1] & 0x800) != 0))) {
      cp1 = cp1 + 1;
    }
    if ((*cp1 != '\0') && (*cp1 != '/')) {
      return UNKNOWN_URL_TYPE;
    }
  }
  return NOT_A_URL_TYPE;
}



// WARNING: Unknown calling convention

BOOLEAN compare_type(char *tst,char *cmp,size_t len)

{
  int iVar1;
  BOOLEAN local_15;
  size_t i;
  
  iVar1 = strncasecomp(tst,cmp,len);
  if (iVar1 == 0) {
    iVar1 = strncmp(tst,cmp,len);
    if (iVar1 != 0) {
      for (i = 0; i < len; i = i + 1) {
        tst[i] = cmp[i];
      }
    }
    local_15 = '\x01';
  }
  else {
    local_15 = '\0';
  }
  return local_15;
}



// WARNING: Unknown calling convention

UrlTypes is_url(char *filename)

{
  BOOLEAN BVar1;
  char *pcVar2;
  size_t sVar3;
  char *pcVar4;
  ushort **ppuVar5;
  int iVar6;
  wchar_t limit;
  wchar_t len;
  UrlTypes result;
  char *cp1;
  char *cp;
  
  result = NOT_A_URL_TYPE;
  if ((filename == (char *)0x0) || (*filename == '\0')) {
    return NOT_A_URL_TYPE;
  }
  pcVar2 = strchr(filename,0x3a);
  if (pcVar2 == (char *)0x0) {
    return NOT_A_URL_TYPE;
  }
  pcVar2 = LYSkipBlanks(filename);
  if ((*pcVar2 == ':') || (*pcVar2 == '/')) {
    return NOT_A_URL_TYPE;
  }
  sVar3 = strlen(pcVar2);
  switch(*pcVar2) {
  case 'B':
  case 'b':
    BVar1 = compare_type(pcVar2,"bibp:",5);
    if (BVar1 != '\0') {
      result = BIBP_URL_TYPE;
    }
    break;
  default:
    if ((2 < (int)sVar3) &&
       (((pcVar4 = strchr(pcVar2 + 3,0x3a), pcVar4 == (char *)0x0 || (pcVar4[1] != '/')) ||
        (pcVar4[2] != '/')))) {
      if (((pcVar4 != (char *)0x0) && (1 < (int)pcVar4 - (int)pcVar2)) &&
         (BVar1 = LYisAbsPath(pcVar4 + 1), BVar1 != '\0')) {
        result = NCFTP_URL_TYPE;
      }
      break;
    }
    switch(*pcVar2) {
    case 'A':
    case 'a':
      BVar1 = compare_type(pcVar2,"afs:",4);
      if (BVar1 != '\0') {
        result = AFS_URL_TYPE;
      }
      break;
    case 'C':
    case 'c':
      BVar1 = compare_type(pcVar2,"cso:",4);
      if (BVar1 != '\0') {
        result = CSO_URL_TYPE;
      }
      break;
    case 'G':
    case 'g':
      BVar1 = compare_type(pcVar2,"gopher:",7);
      if (BVar1 == '\0') break;
      sVar3 = strlen(pcVar2);
      if ((sVar3 < 0xb) || (pcVar2 = strchr(pcVar2 + 0xb,0x2f), pcVar2 == (char *)0x0)) {
        result = GOPHER_URL_TYPE;
        break;
      }
      ppuVar5 = __ctype_b_loc();
      if (((*ppuVar5)[(byte)pcVar2[1]] & 0x200) == 0) {
        if (pcVar2[1] != 'H') goto LAB_0809592e;
      }
      else {
        iVar6 = toupper((uint)(byte)pcVar2[1]);
        if (iVar6 != 0x48) {
LAB_0809592e:
          if (pcVar2[1] != 'w') {
            if ((pcVar2[1] == 'T') || (pcVar2[1] == '8')) {
              result = TELNET_GOPHER_URL_TYPE;
            }
            else if (pcVar2[1] == '7') {
              result = INDEX_GOPHER_URL_TYPE;
            }
            else {
              result = GOPHER_URL_TYPE;
            }
            break;
          }
        }
      }
      result = HTML_GOPHER_URL_TYPE;
      break;
    case 'H':
    case 'h':
      BVar1 = compare_type(pcVar2,"http:",5);
      if (BVar1 == '\0') {
        BVar1 = compare_type(pcVar2,"https:",6);
        if (BVar1 != '\0') {
          result = HTTPS_URL_TYPE;
        }
      }
      else {
        result = HTTP_URL_TYPE;
      }
      break;
    case 'P':
    case 'p':
      BVar1 = compare_type(pcVar2,"prospero:",9);
      if (BVar1 != '\0') {
        result = PROSPERO_URL_TYPE;
      }
      break;
    case 'R':
    case 'r':
      BVar1 = compare_type(pcVar2,"rlogin:",7);
      if (BVar1 != '\0') {
        result = RLOGIN_URL_TYPE;
      }
      break;
    case 'T':
    case 't':
      BVar1 = compare_type(pcVar2,"telnet:",7);
      if (BVar1 == '\0') {
        BVar1 = compare_type(pcVar2,"tn3270:",7);
        if (BVar1 != '\0') {
          result = TN3270_URL_TYPE;
        }
      }
      else {
        result = TELNET_URL_TYPE;
      }
      break;
    case 'W':
    case 'w':
      BVar1 = compare_type(pcVar2,"wais:",5);
      if (BVar1 != '\0') {
        result = WAIS_URL_TYPE;
      }
    }
    break;
  case 'D':
  case 'd':
    BVar1 = compare_type(pcVar2,"data:",5);
    if (BVar1 != '\0') {
      result = DATA_URL_TYPE;
    }
    break;
  case 'F':
  case 'f':
    BVar1 = compare_type(pcVar2,"file:",5);
    if (BVar1 == '\0') {
      if (((((int)sVar3 < 6) || (pcVar2[4] != '/')) || (pcVar2[5] != '/')) ||
         (BVar1 = compare_type(pcVar2,"ftp:",4), BVar1 == '\0')) {
        if (((8 < (int)sVar3) && (pcVar2[7] == '/')) &&
           ((pcVar2[8] == '/' && (BVar1 = compare_type(pcVar2,"finger:",7), BVar1 != '\0')))) {
          result = FINGER_URL_TYPE;
        }
      }
      else {
        result = FTP_URL_TYPE;
      }
    }
    else {
      BVar1 = LYisLocalFile(pcVar2);
      if (BVar1 == '\0') {
        if ((pcVar2[5] == '/') && (pcVar2[6] == '/')) {
          result = FTP_URL_TYPE;
        }
      }
      else {
        result = FILE_URL_TYPE;
      }
    }
    break;
  case 'L':
  case 'l':
    BVar1 = compare_type(pcVar2,"lynxexec:",9);
    if (BVar1 == '\0') {
      BVar1 = compare_type(pcVar2,"lynxprog:",9);
      if (BVar1 == '\0') {
        BVar1 = compare_type(pcVar2,"lynxcgi:",8);
        if (BVar1 == '\0') {
          BVar1 = compare_type(pcVar2,"LYNXPRINT:",10);
          if (BVar1 == '\0') {
            BVar1 = compare_type(pcVar2,"LYNXOPTIONS:",0xc);
            if (BVar1 == '\0') {
              BVar1 = compare_type(pcVar2,"LYNXCFG:",8);
              if (BVar1 == '\0') {
                BVar1 = compare_type(pcVar2,"LYNXMESSAGES:",0xd);
                if (BVar1 == '\0') {
                  BVar1 = compare_type(pcVar2,"LYNXCOMPILEOPTS:",0x10);
                  if (BVar1 == '\0') {
                    BVar1 = compare_type(pcVar2,"LYNXDOWNLOAD:",0xd);
                    if (BVar1 == '\0') {
                      BVar1 = compare_type(pcVar2,"LYNXDIRED:",10);
                      if (BVar1 == '\0') {
                        BVar1 = compare_type(pcVar2,"LYNXHIST:",9);
                        if (BVar1 == '\0') {
                          BVar1 = compare_type(pcVar2,"LYNXKEYMAP:",0xb);
                          if (BVar1 == '\0') {
                            BVar1 = compare_type(pcVar2,"LYNXIMGMAP:",0xb);
                            if (BVar1 == '\0') {
                              BVar1 = compare_type(pcVar2,"LYNXCOOKIE:",0xb);
                              if (BVar1 != '\0') {
                                result = LYNXCOOKIE_URL_TYPE;
                              }
                            }
                            else {
                              is_url(pcVar2 + 0xb);
                              result = LYNXIMGMAP_URL_TYPE;
                            }
                          }
                          else {
                            result = LYNXKEYMAP_URL_TYPE;
                          }
                        }
                        else {
                          result = LYNXHIST_URL_TYPE;
                        }
                      }
                      else {
                        result = LYNXDIRED_URL_TYPE;
                      }
                    }
                    else {
                      result = LYNXDOWNLOAD_URL_TYPE;
                    }
                  }
                  else {
                    result = LYNXCOMPILE_OPTS_URL_TYPE;
                  }
                }
                else {
                  result = LYNXMESSAGES_URL_TYPE;
                }
              }
              else {
                result = LYNXCFG_URL_TYPE;
              }
            }
            else {
              result = LYNXOPTIONS_URL_TYPE;
            }
          }
          else {
            result = LYNXPRINT_URL_TYPE;
          }
        }
        else {
          result = LYNXCGI_URL_TYPE;
        }
      }
      else {
        result = LYNXPROG_URL_TYPE;
      }
    }
    else {
      result = LYNXEXEC_URL_TYPE;
    }
    break;
  case 'M':
  case 'm':
    BVar1 = compare_type(pcVar2,"mailto:",7);
    if (BVar1 != '\0') {
      result = MAILTO_URL_TYPE;
    }
    break;
  case 'N':
  case 'n':
    BVar1 = compare_type(pcVar2,"news:",5);
    if (BVar1 == '\0') {
      BVar1 = compare_type(pcVar2,"nntp:",5);
      if (BVar1 == '\0') {
        BVar1 = compare_type(pcVar2,"newspost:",9);
        if (BVar1 == '\0') {
          BVar1 = compare_type(pcVar2,"newsreply:",10);
          if (BVar1 != '\0') {
            result = NEWSREPLY_URL_TYPE;
          }
        }
        else {
          result = NEWSPOST_URL_TYPE;
        }
      }
      else {
        result = NNTP_URL_TYPE;
      }
    }
    else {
      result = NEWS_URL_TYPE;
    }
    break;
  case 'S':
  case 's':
    BVar1 = compare_type(pcVar2,"snews:",6);
    if (BVar1 == '\0') {
      BVar1 = compare_type(pcVar2,"snewspost:",10);
      if (BVar1 == '\0') {
        BVar1 = compare_type(pcVar2,"snewsreply:",0xb);
        if (BVar1 != '\0') {
          result = NEWSREPLY_URL_TYPE;
        }
      }
      else {
        result = NEWSPOST_URL_TYPE;
      }
    }
    else {
      result = SNEWS_URL_TYPE;
    }
  }
  if (result == NOT_A_URL_TYPE) {
    result = LYCheckForProxyURL(filename);
  }
  return result;
}



// WARNING: Unknown calling convention

void LYFixCursesOn(char *reason)

{
  FILE *__stream;
  
  if ((dump_output_immediately == '\0') && (LYCursesON == '\0')) {
    if ((reason != (char *)0x0) && (WWW_TraceFlag != '\0')) {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"Forcing curses on to %s\n",reason);
    }
    start_curses();
  }
  return;
}



// WARNING: Unknown calling convention

BOOLEAN LYFixCursesOnForAccess(char *addr,char *physical)

{
  char *pcVar1;
  int iVar2;
  char *cp1;
  
  if (((((dump_output_immediately == '\0') && (LYCursesON == '\0')) && (physical != (char *)0x0)) &&
      ((pcVar1 = strstr(addr,"://"), pcVar1 != (char *)0x0 &&
       ((((iVar2 = strncasecomp(addr,"telnet:",7), iVar2 == 0 ||
          (iVar2 = strncasecomp(addr,"rlogin:",7), iVar2 == 0)) ||
         (iVar2 = strncasecomp(addr,"tn3270:",7), iVar2 == 0)) ||
        (((iVar2 = strncasecomp(addr,"gopher:",7), iVar2 != 0 &&
          (pcVar1 = strchr(addr + 0xb,0x2f), pcVar1 != (char *)0x0)) &&
         ((pcVar1[1] == 'T' || (pcVar1[1] == '8')))))))))) &&
     (((iVar2 = strncasecomp(physical,"telnet:",7), iVar2 != 0 &&
       (iVar2 = strncasecomp(physical,"rlogin:",7), iVar2 != 0)) &&
      (iVar2 = strncasecomp(physical,"tn3270:",7), iVar2 != 0)))) {
    start_curses();
    pcVar1 = (char *)gettext("Unexpected access protocol for this URL scheme.");
    HTAlert(pcVar1);
    return '\x01';
  }
  return '\0';
}



// WARNING: Unknown calling convention

BOOLEAN LYCanDoHEAD(char *address)

{
  BOOLEAN BVar1;
  int iVar2;
  char *pcVar3;
  ushort **ppuVar4;
  BOOLEAN local_29;
  char *local_28;
  char *proxy;
  char *acc_method;
  char *cp;
  char *temp;
  wchar_t isurl;
  char *temp0;
  
  temp0 = (char *)0x0;
  if ((address == (char *)0x0) || (*address == '\0')) {
    local_29 = '\0';
  }
  else {
    iVar2 = strncmp(address,"http",4);
    if (iVar2 == 0) {
      local_29 = '\x01';
    }
    else {
      HTSACopy(&temp0,address);
      isurl = is_url(temp0);
      if (isurl == L'\0') {
        if (temp0 != (char *)0x0) {
          free(temp0);
        }
        local_29 = '\0';
      }
      else if (isurl == L'\x19') {
        if (temp0 != (char *)0x0) {
          free(temp0);
        }
        local_29 = '\x01';
      }
      else {
        if ((isurl == L'\a') || (isurl == L'\b')) {
          temp = HTParse(address,"",4);
          cp = strrchr(temp,0x2f);
          local_28 = cp;
          if (cp == (char *)0x0) {
            local_28 = temp;
          }
          pcVar3 = strchr(local_28,0x40);
          if (pcVar3 != (char *)0x0) {
            if (temp0 != (char *)0x0) {
              free(temp0);
              temp0 = (char *)0x0;
            }
            if (temp != (char *)0x0) {
              free(temp);
            }
            return '\x01';
          }
          if (((cp != (char *)0x0) &&
              (ppuVar4 = __ctype_b_loc(), ((*ppuVar4)[(byte)cp[1]] & 0x800) != 0)) &&
             (pcVar3 = strchr(cp,0x2d), pcVar3 == (char *)0x0)) {
            if (temp0 != (char *)0x0) {
              free(temp0);
              temp0 = (char *)0x0;
            }
            if (temp != (char *)0x0) {
              free(temp);
            }
            return '\x01';
          }
          if (temp != (char *)0x0) {
            free(temp);
            temp = (char *)0x0;
          }
        }
        if (isurl != L'\x03') {
          acc_method = HTParse(temp0,"",0x10);
          if ((acc_method != (char *)0x0) && (*acc_method != '\0')) {
            HTSACat(&acc_method,"_proxy");
            pcVar3 = LYGetEnv(acc_method);
            if ((pcVar3 != (char *)0x0) &&
               (((iVar2 = strncasecomp(pcVar3,"http:",5), iVar2 == 0 ||
                 (((*pcVar3 == 'l' || (*pcVar3 == 'L')) &&
                  (iVar2 = strncasecomp(pcVar3,"lynxcgi:",8), iVar2 == 0)))) &&
                (BVar1 = override_proxy(temp0), BVar1 == '\0')))) {
              if (temp0 != (char *)0x0) {
                free(temp0);
                temp0 = (char *)0x0;
              }
              if (acc_method != (char *)0x0) {
                free(acc_method);
              }
              return '\x01';
            }
          }
          if (acc_method != (char *)0x0) {
            free(acc_method);
            acc_method = (char *)0x0;
          }
        }
        if (temp0 != (char *)0x0) {
          free(temp0);
        }
        local_29 = '\0';
      }
    }
  }
  return local_29;
}



// WARNING: Unknown calling convention

BOOLEAN LYCloseInput(FILE *fp)

{
  int iVar1;
  wchar_t err;
  
  if (fp != (FILE *)0x0) {
    iVar1 = ferror((FILE *)fp);
    fclose((FILE *)fp);
    if (iVar1 == 0) {
      return '\x01';
    }
  }
  return '\0';
}



// WARNING: Unknown calling convention

BOOLEAN LYCloseOutput(FILE *fp)

{
  int iVar1;
  char *Msg;
  wchar_t err;
  
  if (fp != (FILE *)0x0) {
    iVar1 = ferror((FILE *)fp);
    fclose((FILE *)fp);
    if (iVar1 == 0) {
      return '\x01';
    }
  }
  Msg = (char *)gettext("Cannot write to file.");
  HTAlert(Msg);
  return '\0';
}



// WARNING: Unknown calling convention

BOOLEAN LYCanWriteFile(char *filename)

{
  BOOLEAN BVar1;
  FILE *fp;
  char *text;
  bool local_5;
  
  fp = fopen64(filename,"w");
  BVar1 = LYCloseOutput((FILE *)fp);
  if (BVar1 == '\0') {
    mustshow = '\x01';
    text = (char *)gettext("Enter a new filename: ");
    statusline(text);
  }
  else {
    remove(filename);
  }
  local_5 = BVar1 != '\0';
  return local_5;
}



// WARNING: Unknown calling convention

BOOLEAN LYCanReadFile(char *filename)

{
  BOOLEAN BVar1;
  FILE *fp_00;
  FILE *fp;
  
  if (((filename != (char *)0x0) && (*filename != '\0')) &&
     (fp_00 = fopen64(filename,"r"), fp_00 != (FILE *)0x0)) {
    BVar1 = LYCloseInput((FILE *)fp_00);
    return BVar1;
  }
  return '\0';
}



// WARNING: Unknown calling convention

void remove_backslashes(char *buf)

{
  char *cp;
  
  for (cp = buf; *cp != '\0'; cp = cp + 1) {
    if (*cp == '\\') {
      if ((*cp == '\\') && (cp[1] == '\\')) {
        *buf = *cp;
        buf = buf + 1;
      }
    }
    else {
      *buf = *cp;
      buf = buf + 1;
    }
  }
  *buf = '\0';
  return;
}



// WARNING: Unknown calling convention

BOOLEAN inlocaldomain(void)

{
  int iVar1;
  FILE *__stream;
  size_t sVar2;
  int iVar3;
  size_t sVar4;
  FILE *__stream_00;
  int in_GS_OFFSET;
  char *local_1ac;
  char *mytty;
  char *cp;
  FILE *fp;
  wchar_t n;
  wchar_t result;
  utmp me;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  mytty = (char *)0x0;
  local_1ac = ttyname(0);
  if (local_1ac != (char *)0x0) {
    mytty = LYLastPathSep(local_1ac);
  }
  result._0_1_ = '\0';
  if ((mytty == (char *)0x0) || (__stream = fopen64("/var/run/utmp","r"), __stream == (FILE *)0x0))
  {
    if (WWW_TraceFlag != '\0') {
      if (local_1ac == (char *)0x0) {
        local_1ac = "(null)";
      }
      __stream_00 = TraceFP();
      fprintf((FILE *)__stream_00,"Could not get ttyname (returned %s) or open UTMP file %s\n",
              local_1ac,"/var/run/utmp");
    }
  }
  else {
    do {
      sVar2 = fread(&me,0x180,1,__stream);
      if ((int)sVar2 < 1) break;
      iVar3 = strcmp(me.ut_line,mytty + 1);
    } while (iVar3 != 0);
    LYCloseInput((FILE *)__stream);
    if (0 < (int)sVar2) {
      sVar2 = strlen(me.ut_host);
      sVar4 = strlen(LYLocalDomain);
      if (sVar4 < sVar2) {
        sVar2 = strlen(me.ut_host);
        sVar4 = strlen(LYLocalDomain);
        iVar3 = strcmp(LYLocalDomain,(char *)((int)&me + (sVar2 - sVar4) + 0x4c));
        if (iVar3 == 0) {
          result._0_1_ = '\x01';
          goto LAB_0809638e;
        }
      }
      if (me.ut_host[0] == '\0') {
        result._0_1_ = '\x01';
      }
    }
  }
LAB_0809638e:
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return (BOOLEAN)result;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Removing unreachable block (ram,0x080963ef)
// WARNING: Unknown calling convention

void LYExtSignal(wchar_t sig,LYSigHandlerFunc_t *handler)

{
  sigaction act;
  
  if ((sig == L'\x1c') && (LYNonRestartingSIGWINCH != '\0')) {
    act.__sigaction_handler.sa_handler = handler;
    sigemptyset((sigset_t *)&act.sa_mask);
    act.sa_flags = L'\0';
    sigaction(0x1c,(sigaction *)&act,(sigaction *)0x0);
  }
  else {
    signal(sig,(__sighandler_t)handler);
  }
  return;
}



// WARNING: Unknown calling convention

BOOLEAN LYToggleSigDfl(wchar_t sig,sigaction *where,wchar_t to_dfl)

{
  int *piVar1;
  char *pcVar2;
  FILE *__stream;
  BOOLEAN local_99;
  sigaction oact;
  wchar_t rv;
  
  if (to_dfl == L'\x01') {
    rv = sigaction(sig,(sigaction *)0x0,(sigaction *)&oact);
    if (rv == L'\0') {
      if (oact.__sigaction_handler.sa_handler == (__sighandler_t)0x0) {
        if (where != (sigaction *)0x0) {
          memcpy(where,&oact,0x8c);
          rv = L'\0';
        }
      }
      else {
        oact.__sigaction_handler.sa_handler = (__sighandler_t)0x0;
        rv = sigaction(sig,(sigaction *)&oact,(sigaction *)where);
      }
    }
  }
  else {
    rv = sigaction(sig,(sigaction *)where,(sigaction *)0x0);
  }
  if (rv == L'\0') {
    local_99 = '\x01';
  }
  else {
    if (WWW_TraceFlag != '\0') {
      piVar1 = __errno_location();
      pcVar2 = strerror(*piVar1);
      __stream = TraceFP();
      fprintf((FILE *)__stream,"Error in LYToggleSigDfl: %s\n",pcVar2);
    }
    local_99 = '\0';
  }
  return local_99;
}



// WARNING: Unknown calling convention

void size_change(wchar_t sig)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  FILE *__stream;
  winsize win;
  wchar_t old_cols;
  wchar_t old_lines;
  
  iVar3 = LYlines;
  iVar1 = LYcols;
  iVar4 = ioctl(0,0x5413,&win);
  if (iVar4 == 0) {
    if (win.ws_row != 0) {
      LYlines = (int)win.ws_row;
    }
    if (win.ws_col != 0) {
      LYcols = (int)win.ws_col;
    }
  }
  if (LYlines < 1) {
    LYlines = 0x18;
  }
  iVar4 = LYlines;
  if (LYcols < 1) {
    LYcols = 0x50;
  }
  iVar2 = LYcols;
  if (((LYlines != iVar3) || (LYcols != iVar1)) &&
     (recent_sizechange = '\x01', WWW_TraceFlag != '\0')) {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"Window size changed from (%d,%d) to (%d,%d)\n",iVar3,iVar1,iVar4,iVar2
           );
  }
  LYExtSignal(L'\x1c',size_change);
  return;
}



// WARNING: Unknown calling convention

void HTSugFilenames_free(void)

{
  LYFreeStringList(sug_filenames);
  sug_filenames = (HTList *)0x0;
  return;
}



// WARNING: Unknown calling convention

void HTAddSugFilename(char *fname)

{
  int iVar1;
  char *local_18;
  HTList *cur;
  char *old;
  char *tmp;
  
  tmp = (char *)0x0;
  if ((fname != (char *)0x0) && (*fname != '\0')) {
    HTSACopy(&tmp,fname);
    if (sug_filenames == (HTList *)0x0) {
      sug_filenames = HTList_new();
      HTList_addObject(sug_filenames,tmp);
    }
    else {
      cur = sug_filenames;
      do {
        if ((cur == (HTList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
          local_18 = (char *)0x0;
        }
        else {
          local_18 = (char *)cur->object;
        }
        if (local_18 == (char *)0x0) goto LAB_08096750;
        iVar1 = strcmp(local_18,tmp);
      } while (iVar1 != 0);
      HTList_removeObject(sug_filenames,local_18);
      if (local_18 != (char *)0x0) {
        free(local_18);
      }
LAB_08096750:
      HTList_addObject(sug_filenames,tmp);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void change_sug_filename(char *fname)

{
  size_t sVar1;
  __pid_t _Var2;
  size_t sVar3;
  int iVar4;
  size_t sVar5;
  char *pcVar6;
  byte local_30;
  char *local_2c;
  char *end;
  char *cp1;
  char *cp;
  char *temp;
  char *cp2;
  
  temp = (char *)0x0;
  sVar1 = strlen(fname);
  HTUnEscape(fname);
  cp2 = wwwName(lynx_temp_space);
  if (*cp2 == '/') {
    _Var2 = getpid();
    HTSprintf0(&temp,"file://localhost%s%u",cp2,_Var2);
  }
  else {
    _Var2 = getpid();
    HTSprintf0(&temp,"file://localhost/%s%u",cp2,_Var2);
  }
  sVar3 = strlen(temp);
  iVar4 = strncmp(fname,temp,sVar3);
  if (iVar4 == 0) {
    cp = strrchr(fname,0x2e);
    sVar3 = strlen(cp);
    sVar5 = strlen(temp);
    if (sVar5 - 4 < sVar3) {
      cp = (char *)0x0;
    }
    if (cp == (char *)0x0) {
      local_2c = "";
    }
    else {
      local_2c = cp;
    }
    HTSACopy(&temp,local_2c);
    sprintf(fname,"temp%.*s",0xf6,temp);
  }
  if (temp != (char *)0x0) {
    free(temp);
    temp = (char *)0x0;
  }
  sVar3 = strlen(fname);
  if (fname[sVar3 - 1] == '/') {
    sVar3 = strlen(fname);
    fname[sVar3 - 1] = '\0';
  }
  cp = strrchr(fname,0x2f);
  if ((cp != (char *)0x0) && (sVar3 = strlen(cp), 1 < sVar3)) {
    cp1 = fname;
    while (cp = cp + 1, *cp != '\0') {
      *cp1 = *cp;
      cp1 = cp1 + 1;
    }
    *cp1 = '\0';
  }
  if (((((fname + sVar1)[-1] == ']') && (pcVar6 = strrchr(fname,0x5b), pcVar6 != (char *)0x0)) &&
      (fname < pcVar6)) && (cp = pcVar6 + -1, *cp == ' ')) {
    for (; *cp == ' '; cp = cp + -1) {
      *cp = '\0';
    }
  }
  pcVar6 = strchr(fname,0x5b);
  if (((pcVar6 != (char *)0x0) && (cp1 = strrchr(pcVar6,0x5d), cp1 != (char *)0x0)) &&
     (sVar3 = strlen(cp1), 1 < sVar3)) {
    cp = fname;
    while (cp1 = cp1 + 1, *cp1 != '\0') {
      *cp = *cp1;
      cp = cp + 1;
    }
    *cp = '\0';
  }
  for (cp = fname; *cp != '\0'; cp = cp + 1) {
    if (((int)*cp - 0x20U < 0x10) &&
       (local_30 = (byte)((int)*cp - 0x20U), (1 << (local_30 & 0x1f) & 0x8085U) != 0)) {
      *cp = '-';
    }
  }
  sVar3 = strlen(fname);
  for (cp = fname + sVar3; cp < fname + sVar1; cp = cp + 1) {
    *cp = '\0';
  }
  return;
}



wchar_t fmt_tempname(char *result,char *prefix,char *suffix)

{
  int iVar1;
  bool bVar2;
  time_t tVar3;
  long lVar4;
  uint uVar5;
  uint uVar6;
  char *Msg;
  __pid_t _Var7;
  size_t sVar8;
  size_t sVar9;
  FILE *__stream;
  int in_GS_OFFSET;
  uint local_134;
  char *suffix_local;
  char *prefix_local;
  char *result_local;
  uint mask;
  uint offset;
  wchar_t code;
  char leaf [256];
  
  prefix_local = prefix;
  suffix_local = suffix;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if (prefix == (char *)0x0) {
    prefix_local = "";
  }
  if (suffix == (char *)0x0) {
    suffix_local = "";
  }
  if (fmt_tempname::first != '\0') {
    tVar3 = time((time_t *)0x0);
    srandom((uint)(result + tVar3));
    fmt_tempname::first = '\0';
  }
  fmt_tempname::counter = 10000;
  if (fmt_tempname::names_used < L'') {
    lVar4 = random();
    local_134 = (uint)(longlong)ROUND(((float)lVar4 * 10000.0) / 2.147484e+09 + 1.0);
    fmt_tempname::counter = local_134;
    do {
      fmt_tempname::counter = fmt_tempname::counter % 10000;
      uVar5 = fmt_tempname::counter >> 3;
      uVar6 = 1 << ((byte)fmt_tempname::counter & 7);
      if ((fmt_tempname::used_tempname[uVar5] & uVar6) == 0) {
        fmt_tempname::names_used = fmt_tempname::names_used + L'\x01';
        fmt_tempname::used_tempname[uVar5] = (byte)uVar6 | fmt_tempname::used_tempname[uVar5];
        break;
      }
    } while ((fmt_tempname::used_tempname[uVar5] & uVar6) == 0);
  }
  if (L'' < fmt_tempname::names_used) {
    Msg = (char *)gettext("Too many tempfiles");
    HTAlert(Msg);
  }
  uVar5 = fmt_tempname::counter;
  _Var7 = getpid();
  sprintf(leaf,"L%u-%uTMP%s",_Var7,uVar5,suffix_local);
  sVar8 = strlen(prefix_local);
  sVar9 = strlen(leaf);
  bVar2 = 0xff < sVar8 + sVar9;
  if (bVar2) {
    sprintf(result,"%.*s",0xff,leaf,suffix_local);
  }
  else {
    sprintf(result,"%s%s",prefix_local,leaf,suffix_local);
  }
  code = (wchar_t)!bVar2;
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"-> \'%s\'\n",result);
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return code;
}



// WARNING: Unknown calling convention

wchar_t number2arrows(wchar_t number)

{
  switch(number) {
  case L'1':
    number = L'';
    break;
  case L'2':
    number = L'';
    break;
  case L'3':
    number = L'';
    break;
  case L'4':
    number = L'';
    break;
  case L'5':
    number = L'';
    break;
  case L'6':
    number = L'';
    break;
  case L'7':
    number = L'';
    break;
  case L'8':
    number = L'';
    break;
  case L'9':
    number = L'';
  }
  return number;
}



// WARNING: Unknown calling convention

BOOLEAN strn_dash_equ(char *p1,char *p2,wchar_t len)

{
  char cVar1;
  bool bVar2;
  
  do {
    bVar2 = len == L'\0';
    len = len + L'\xffffffff';
    if (bVar2) {
      return '\x01';
    }
    if (*p2 == '\0') {
      return '\0';
    }
    cVar1 = *p1;
    if ((cVar1 == '-') || (cVar1 == '_')) {
      if (*p2 != '_') {
        return '\0';
      }
    }
    else {
      if (cVar1 == '\0') {
        return '\0';
      }
      if (*p1 != *p2) {
        return '\0';
      }
    }
    p1 = p1 + 1;
    p2 = p2 + 1;
  } while( true );
}



// WARNING: Unknown calling convention

char * index_to_restriction(wchar_t inx)

{
  char *local_8;
  
  if ((inx < L'\0') || (L'9' < inx)) {
    local_8 = (char *)0x0;
  }
  else {
    local_8 = restrictions[inx].name;
  }
  return local_8;
}



// WARNING: Unknown calling convention

wchar_t find_restriction(char *name,wchar_t len)

{
  BOOLEAN BVar1;
  uint i;
  
  if (len < L'\0') {
    len = strlen(name);
  }
  i = 0;
  while( true ) {
    if (0x39 < i) {
      return L'\xffffffff';
    }
    BVar1 = strn_dash_equ(name,restrictions[i].name,len);
    if (BVar1 != '\0') break;
    i = i + 1;
  }
  return (int)*restrictions[i].flag;
}



// WARNING: Unknown calling convention

void parse_restrictions(char *s)

{
  bool bVar1;
  BOOLEAN BVar2;
  char *p1;
  undefined4 uVar3;
  uint i;
  char *word;
  char *p;
  BOOLEAN found;
  
  p = s;
  do {
    if ((*p == '\0') || (p1 = LYSkipCBlanks(p), p = p1, *p1 == '\0')) {
      if (no_shell != '\0') {
        no_goto_lynxexec = '\x01';
        no_goto_lynxprog = '\x01';
        no_goto_lynxcgi = '\x01';
        local_exec_on_local_files = '\x01';
      }
      return;
    }
    for (; (*p != ',' && (*p != '\0')); p = p + 1) {
    }
    bVar1 = false;
    BVar2 = strn_dash_equ(p1,"all",(int)p - (int)p1);
    if (BVar2 == '\0') {
      BVar2 = strn_dash_equ(p1,"default",(int)p - (int)p1);
      if (BVar2 == '\0') {
        for (i = 0; i < 0x3a; i = i + 1) {
          BVar2 = strn_dash_equ(p1,restrictions[i].name,(int)p - (int)p1);
          if (BVar2 != '\0') {
            *restrictions[i].flag = '\x01';
            bVar1 = true;
            break;
          }
        }
      }
      else {
        bVar1 = true;
        for (i = 2; i < 0x3a; i = i + 1) {
          *restrictions[i].flag = restrictions[i].can == '\0';
        }
      }
    }
    else {
      bVar1 = true;
      for (i = 2; i < 0x3a; i = i + 1) {
        *restrictions[i].flag = '\x01';
      }
    }
    if (!bVar1) {
      uVar3 = gettext("unknown restriction");
      printf("%s: %.*s\n",uVar3,(int)p - (int)p1,p1);
      exit_immediately(1);
    }
    if (*p != '\0') {
      p = p + 1;
    }
  } while( true );
}



// WARNING: Unknown calling convention

void print_restrictions_to_fd(FILE *fp)

{
  char *pcVar1;
  int iVar2;
  uint count;
  uint i;
  
  count = 0;
  for (i = 0; i < 0x3a; i = i + 1) {
    if (*restrictions[i].flag == '\x01') {
      count = count + 1;
    }
  }
  if (count == 0) {
    pcVar1 = (char *)gettext("No restrictions set.\n");
    fprintf((FILE *)fp,pcVar1);
  }
  else {
    pcVar1 = (char *)gettext("Restrictions set:\n");
    fprintf((FILE *)fp,pcVar1);
    for (i = 0; i < 0x3a; i = i + 1) {
      if (*restrictions[i].flag == '\x01') {
        iVar2 = strncmp(restrictions[i].name,"goto_",5);
        if ((iVar2 != 0) || (no_goto == '\0')) {
          fprintf((FILE *)fp,"   %s\n",restrictions[i].name);
        }
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

void LYCheckMail(void)

{
  int iVar1;
  char *pcVar2;
  stat st;
  time_t now;
  
  if (LYCheckMail::firsttime != '\0') {
    LYCheckMail::mf = LYGetEnv("MAIL");
    LYCheckMail::firsttime = '\0';
    time(&LYCheckMail::lasttime);
  }
  if (LYCheckMail::mf == (char *)0x0) {
    return;
  }
  time(&now);
  if (now - LYCheckMail::lastcheck < 0x3c) {
    return;
  }
  LYCheckMail::lastcheck = now;
  iVar1 = stat64(LYCheckMail::mf,(stat64 *)&st);
  if ((-1 < iVar1) && ((st.st_mode & 0xf000) == 0x8000)) {
    if ((-1 < st.st_size._4_4_) && ((0 < st.st_size._4_4_ || ((uint)st.st_size != 0)))) {
      if (((st.st_mtim.tv_sec == LYCheckMail::lasttime) || (st.st_mtim.tv_sec <= st.st_atim.tv_sec))
         && (((LYCheckMail::lastsize == 0 || (st.st_size._4_4_ < LYCheckMail::lastsize >> 0x1f)) ||
             ((st.st_size._4_4_ <= LYCheckMail::lastsize >> 0x1f &&
              ((uint)st.st_size <= (uint)LYCheckMail::lastsize)))))) {
        if (LYCheckMail::lastsize == 0) {
          pcVar2 = (char *)gettext("*** You have mail. ***");
          HTUserMsg(pcVar2);
        }
      }
      else {
        pcVar2 = (char *)gettext("*** You have new mail. ***");
        HTUserMsg(pcVar2);
      }
    }
    LYCheckMail::lasttime = st.st_mtim.tv_sec;
    LYCheckMail::lastsize = (uint)st.st_size;
    return;
  }
  LYCheckMail::mf = (char *)0x0;
  return;
}



// WARNING: Unknown calling convention

void LYEnsureAbsoluteURL(char **href,char *name,wchar_t fixit)

{
  int iVar1;
  UrlTypes UVar2;
  FILE *__stream;
  char *pcVar3;
  undefined1 *local_1c;
  char *local_18;
  char *temp;
  
  if ((*href != (char *)0x0) && (**href != '\0')) {
    LYFillLocalFileURL(href,"file://localhost");
    iVar1 = strcasecomp(*href,"news:");
    if (iVar1 == 0) {
      HTSACat(href,"*");
    }
    else {
      iVar1 = strcasecomp(*href,"snews:");
      if (iVar1 == 0) {
        HTSACat(href,"/*");
      }
    }
    UVar2 = is_url(*href);
    if (UVar2 == NOT_A_URL_TYPE) {
      if (WWW_TraceFlag != '\0') {
        pcVar3 = *href;
        if (name == (char *)0x0) {
          local_1c = &DAT_08156400;
          local_18 = "";
        }
        else {
          local_1c = &DAT_0815656c;
          local_18 = name;
        }
        __stream = TraceFP();
        fprintf((FILE *)__stream,"%s%s\'%s\' is not a URL\n",local_18,local_1c,pcVar3);
      }
      LYConvertToURL(href,fixit);
    }
    pcVar3 = HTParse(*href,"",0x1f);
    if ((pcVar3 != (char *)0x0) && (*pcVar3 != '\0')) {
      HTSACopy(href,pcVar3);
    }
    if (pcVar3 != (char *)0x0) {
      free(pcVar3);
    }
  }
  return;
}



void LYConvertToURL(char **AllocatedString,wchar_t fixit)

{
  int iVar1;
  char *pcVar2;
  BOOLEAN BVar3;
  char *pcVar4;
  FILE *pFVar5;
  int iVar6;
  int in_GS_OFFSET;
  char *local_194;
  char **AllocatedString_local;
  stat st;
  char *cp2;
  char *temp2;
  char *fragment;
  char *cp;
  char *temp;
  char *old_string;
  BOOLEAN is_local;
  char curdir [256];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  old_string = *AllocatedString;
  temp = (char *)0x0;
  cp = (char *)0x0;
  if ((old_string == (char *)0x0) || (*old_string == '\0')) goto LAB_08098058;
  *AllocatedString = (char *)0x0;
  HTSACopy(AllocatedString,"file://localhost");
  if (*old_string == '/') {
    if (old_string[1] == '\0') {
      HTSACat(AllocatedString,"/");
    }
    else {
      iVar6 = stat64(old_string,(stat64 *)&st);
      if (iVar6 < 0) {
        BVar3 = LYCanReadFile(old_string);
        if (BVar3 == '\0') {
          if (old_string[1] == '~') {
            pcVar4 = Home_Dir();
            pcVar4 = wwwName(pcVar4);
            HTSACat(AllocatedString,pcVar4);
            cp = strchr(old_string + 1,0x2f);
            if (cp != (char *)0x0) {
              HTSACopy(&temp,cp);
              LYTrimRelFromAbsPath(temp);
              HTSACat(AllocatedString,temp);
              if (temp != (char *)0x0) {
                free(temp);
                temp = (char *)0x0;
              }
            }
          }
          else {
            HTSACopy(&temp,old_string);
            LYTrimRelFromAbsPath(temp);
            HTSACat(AllocatedString,temp);
            if (temp != (char *)0x0) {
              free(temp);
              temp = (char *)0x0;
            }
          }
          goto LAB_08097fdd;
        }
      }
      HTSACopy(&temp,old_string);
      LYTrimRelFromAbsPath(temp);
      pcVar2 = old_string;
      pcVar4 = temp;
      if (WWW_TraceFlag != '\0') {
        pFVar5 = TraceFP();
        fprintf((FILE *)pFVar5,"Converted \'%s\' to \'%s\'\n",pcVar2,pcVar4);
      }
      cp = HTEscape(temp,'\x04');
      HTSACat(AllocatedString,cp);
      if (cp != (char *)0x0) {
        free(cp);
        cp = (char *)0x0;
      }
      if (temp != (char *)0x0) {
        free(temp);
        temp = (char *)0x0;
      }
      pcVar4 = old_string;
      if (WWW_TraceFlag != '\0') {
        pcVar2 = *AllocatedString;
        pFVar5 = TraceFP();
        fprintf((FILE *)pFVar5,"Converted \'%s\' to \'%s\'\n",pcVar4,pcVar2);
      }
    }
LAB_08097fdd:
    pcVar4 = old_string;
    if (WWW_TraceFlag != '\0') {
      pcVar2 = *AllocatedString;
      pFVar5 = TraceFP();
      fprintf((FILE *)pFVar5,"Converted \'%s\' to \'%s\'\n",pcVar4,pcVar2);
    }
  }
  else {
    fragment = (char *)0x0;
    if (*old_string == '~') {
      pcVar4 = Home_Dir();
      pcVar4 = wwwName(pcVar4);
      HTSACat(AllocatedString,pcVar4);
      cp = strchr(old_string,0x2f);
      if (cp != (char *)0x0) {
        HTSACopy(&temp,cp);
        LYTrimRelFromAbsPath(temp);
        HTSACat(AllocatedString,temp);
        if (temp != (char *)0x0) {
          free(temp);
          temp = (char *)0x0;
        }
      }
      pcVar4 = old_string;
      if (WWW_TraceFlag != '\0') {
        pcVar2 = *AllocatedString;
        pFVar5 = TraceFP();
        fprintf((FILE *)pFVar5,"Converted \'%s\' to \'%s\'\n",pcVar4,pcVar2);
      }
    }
    else {
      temp2 = (char *)0x0;
      is_local = '\0';
      Current_Dir(curdir);
      HTSACopy(&temp,curdir);
      HTSACat(&temp,"/");
      HTSACat(&temp,old_string);
      LYTrimRelFromAbsPath(temp);
      pcVar2 = old_string;
      pcVar4 = temp;
      if (WWW_TraceFlag != '\0') {
        pFVar5 = TraceFP();
        fprintf((FILE *)pFVar5,"Converted \'%s\' to \'%s\'\n",pcVar2,pcVar4);
      }
      iVar6 = stat64(temp,(stat64 *)&st);
      if (iVar6 < 0) {
        BVar3 = LYCanReadFile(temp);
        if (BVar3 != '\0') goto LAB_080977a2;
        cp2 = (char *)0x0;
        HTSACopy(&temp2,curdir);
        LYAddPathSep(&temp2);
        HTSACopy(&cp,old_string);
        fragment = trimPoundSelector(cp);
        HTUnEscape(cp);
        HTSACat(&temp2,cp);
        HTSACopy(&cp2,temp2);
        LYTrimRelFromAbsPath(temp2);
        iVar6 = strcmp(temp2,temp);
        if (iVar6 == 0) {
LAB_08097a63:
          pcVar4 = strchr(curdir,0x23);
          if (pcVar4 == (char *)0x0) {
            pcVar4 = strchr(curdir,0x25);
            if (pcVar4 == (char *)0x0) goto LAB_08097b6c;
          }
          if (temp != (char *)0x0) {
            free(temp);
            temp = (char *)0x0;
          }
          iVar6 = strcmp(cp2,temp2);
          if (iVar6 == 0) {
            temp = HTEscape(curdir,'\x04');
            LYAddHtmlSep(&temp);
            HTSACat(&temp,old_string);
          }
          else {
            temp = HTEscape(temp2,'\x04');
            if (fragment != (char *)0x0) {
              if (fragment != (char *)0x0) {
                *fragment = '#';
              }
              HTSACat(&temp,fragment);
            }
          }
        }
        else {
          iVar6 = stat64(temp2,(stat64 *)&st);
          if (iVar6 < 0) {
            BVar3 = LYCanReadFile(temp2);
            if (BVar3 == '\0') goto LAB_08097a63;
          }
          if (temp != (char *)0x0) {
            free(temp);
            temp = (char *)0x0;
          }
          iVar6 = strcmp(cp2,temp2);
          if (iVar6 == 0) {
            temp = HTEscape(curdir,'\x04');
            LYAddHtmlSep(&temp);
            HTSACat(&temp,old_string);
          }
          else {
            temp = HTEscape(temp2,'\x04');
            if (fragment != (char *)0x0) {
              if (fragment != (char *)0x0) {
                *fragment = '#';
              }
              HTSACat(&temp,fragment);
            }
          }
          HTSACat(AllocatedString,temp);
          pcVar4 = old_string;
          if (WWW_TraceFlag != '\0') {
            pcVar2 = *AllocatedString;
            pFVar5 = TraceFP();
            fprintf((FILE *)pFVar5,"Converted \'%s\' to \'%s\'\n",pcVar4,pcVar2);
          }
          is_local = '\x01';
        }
LAB_08097b6c:
        if (cp != (char *)0x0) {
          free(cp);
          cp = (char *)0x0;
        }
        if (cp2 != (char *)0x0) {
          free(cp2);
          cp2 = (char *)0x0;
        }
      }
      else {
LAB_080977a2:
        cp = HTEscape(temp,'\x04');
        HTSACat(AllocatedString,cp);
        if (cp != (char *)0x0) {
          free(cp);
          cp = (char *)0x0;
        }
        pcVar4 = old_string;
        if (WWW_TraceFlag != '\0') {
          pcVar2 = *AllocatedString;
          pFVar5 = TraceFP();
          fprintf((FILE *)pFVar5,"Converted \'%s\' to \'%s\'\n",pcVar4,pcVar2);
        }
        is_local = '\x01';
      }
      if (is_local == '\0') {
        if (WWW_TraceFlag != '\0') {
          if (temp2 == (char *)0x0) {
            local_194 = temp;
          }
          else {
            local_194 = temp2;
          }
          pFVar5 = TraceFP();
          fprintf((FILE *)pFVar5,"Can\'t stat() or fopen() \'%s\'\n",local_194);
        }
        BVar3 = LYExpandHostForURL(&old_string,URLDomainPrefixes,URLDomainSuffixes);
        if (BVar3 == '\0') {
          if (fixit == L'\0') {
            HTSACat(AllocatedString,temp);
          }
          else {
            HTSACopy(AllocatedString,old_string);
          }
        }
        else {
          BVar3 = LYAddSchemeForURL(&old_string,"http://");
          if (BVar3 == '\0') {
            HTSACopy(AllocatedString,"http://");
            HTSACat(AllocatedString,old_string);
          }
          else {
            HTSACopy(AllocatedString,old_string);
          }
        }
        if (WWW_TraceFlag != '\0') {
          pcVar4 = *AllocatedString;
          pFVar5 = TraceFP();
          fprintf((FILE *)pFVar5,"Trying: \'%s\'\n",pcVar4);
        }
      }
      if (temp != (char *)0x0) {
        free(temp);
        temp = (char *)0x0;
      }
      if (temp2 != (char *)0x0) {
        free(temp2);
        temp2 = (char *)0x0;
      }
    }
  }
  if (old_string != (char *)0x0) {
    free(old_string);
    old_string = (char *)0x0;
  }
  if ((WWW_TraceFlag != '\0') && (LYTraceLogFP == (FILE *)0x0)) {
    sleep(AlertSecs);
  }
LAB_08098058:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



// WARNING: Unknown calling convention

BOOLEAN LYExpandHostForURL(char **AllocatedString,char *prefix_list,char *suffix_list)

{
  char *pcVar1;
  int iVar2;
  ushort **ppuVar3;
  char *pcVar4;
  wchar_t wVar5;
  FILE *pFVar6;
  size_t sVar7;
  undefined4 uVar8;
  undefined4 uVar9;
  hostent *phVar10;
  char *local_94;
  char *local_90;
  char *local_8c;
  char *local_88;
  char *local_84;
  char *local_80;
  addrinfo hints;
  wchar_t error;
  addrinfo *res;
  char *Fragment;
  char *Path;
  char *host;
  char *HostColon;
  char *Host;
  char *MsgStr;
  char *StrColon;
  char *Str;
  char *EndS;
  char *StartS;
  char *DomainSuffix;
  char *EndP;
  char *StartP;
  char *DomainPrefix;
  BOOLEAN Startup;
  BOOLEAN GotHost;
  
  DomainPrefix = (char *)0x0;
  DomainSuffix = (char *)0x0;
  Str = (char *)0x0;
  StrColon = (char *)0x0;
  MsgStr = (char *)0x0;
  Host = (char *)0x0;
  HostColon = (char *)0x0;
  host = (char *)0x0;
  Path = (char *)0x0;
  Fragment = (char *)0x0;
  GotHost = '\0';
  Startup = helpfilepath == (char *)0x0;
  if ((((*AllocatedString == (char *)0x0) || (**AllocatedString == '\0')) ||
      (**AllocatedString == '/')) || (**AllocatedString == '#')) {
    return '\0';
  }
  iVar2 = strncmp(*AllocatedString,"..",2);
  if ((iVar2 == 0) || (iVar2 = strncmp(*AllocatedString,"./",2), iVar2 == 0)) {
    return GotHost;
  }
  HTSACopy(&Str,*AllocatedString);
  Path = strchr(Str,0x2f);
  if (Path == (char *)0x0) {
    Fragment = trimPoundSelector(Str);
  }
  else {
    *Path = '\0';
  }
  StrColon = strrchr(Str,0x3a);
  if ((StrColon != (char *)0x0) &&
     (ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[(byte)StrColon[1]] & 0x800) != 0)) {
    if (StrColon == Str) goto cleanup;
    *StrColon = '\0';
  }
  HTSACopy(&host,Str);
  HTUnEscape(host);
  if (LYCursesON == '\0') {
    if ((Startup != '\0') && (dump_output_immediately == '\0')) {
      uVar8 = gettext(" first");
      pcVar4 = host;
      uVar9 = gettext("Looking up ");
      fprintf(stdout,"%s \'%s\'%s\r\n",uVar9,pcVar4,uVar8);
    }
  }
  else {
    pcVar4 = (char *)gettext("Looking up ");
    HTSACopy(&MsgStr,pcVar4);
    HTSACat(&MsgStr,host);
    pcVar4 = (char *)gettext(" first");
    HTSACat(&MsgStr,pcVar4);
    HTProgress(MsgStr);
  }
  memset(&hints,0,0x20);
  hints.ai_family = L'\0';
  hints.ai_socktype = L'\x01';
  iVar2 = getaddrinfo(host,"80",(addrinfo *)&hints,(addrinfo **)&res);
  pcVar1 = Str;
  pcVar4 = host;
  if ((iVar2 == 0) && (res != (addrinfo *)0x0)) {
    if (((LYCursesON != '\0') && (wVar5 = HTCheckForInterrupt(), pcVar4 = host, wVar5 != L'\0')) &&
       (WWW_TraceFlag != '\0')) {
      pFVar6 = TraceFP();
      fprintf((FILE *)pFVar6,"LYExpandHostForURL: Ignoring interrupt because \'%s\' resolved.\n",
              pcVar4);
    }
    GotHost = '\x01';
  }
  else if ((LYCursesON == '\0') || (lynx_nsl_status != -0x752e)) {
    if ((prefix_list == (char *)0x0) || (sVar7 = strlen(Str), pcVar1[sVar7 - 1] == '.')) {
      local_94 = "";
    }
    else {
      local_94 = prefix_list;
    }
    StartP = local_94;
    if (((*local_94 != '\0') && (*local_94 != '.')) &&
       (((iVar2 = strncasecomp(*AllocatedString,"www.",4), iVar2 == 0 ||
         (((((iVar2 = strncasecomp(*AllocatedString,"ftp.",4), iVar2 == 0 ||
             (iVar2 = strncasecomp(*AllocatedString,"gopher.",7), iVar2 == 0)) ||
            (iVar2 = strncasecomp(*AllocatedString,"wais.",5), iVar2 == 0)) ||
           ((iVar2 = strncasecomp(*AllocatedString,"cso.",4), iVar2 == 0 ||
            (iVar2 = strncasecomp(*AllocatedString,"ns.",3), iVar2 == 0)))) ||
          (iVar2 = strncasecomp(*AllocatedString,"ph.",3), iVar2 == 0)))) ||
        (((iVar2 = strncasecomp(*AllocatedString,"finger.",7), iVar2 == 0 ||
          (iVar2 = strncasecomp(*AllocatedString,"news.",5), iVar2 == 0)) ||
         (iVar2 = strncasecomp(*AllocatedString,"nntp.",5), iVar2 == 0)))))) {
      StartP = "";
    }
    for (; (*StartP != '\0' && (((byte)*StartP < 0x21 || (*StartP == ',')))); StartP = StartP + 1) {
    }
    for (EndP = StartP; ((*EndP != '\0' && (0x20 < (byte)*EndP)) && (*EndP != ',')); EndP = EndP + 1
        ) {
    }
    HTSACopy(&DomainPrefix,StartP);
    DomainPrefix[(int)EndP - (int)StartP] = '\0';
    do {
      if ((suffix_list == (char *)0x0) || (*Str == '.')) {
        local_90 = "";
      }
      else {
        local_90 = suffix_list;
      }
      for (StartS = local_90; (*StartS != '\0' && (((byte)*StartS < 0x21 || (*StartS == ','))));
          StartS = StartS + 1) {
      }
      for (EndS = StartS; ((*EndS != '\0' && (0x20 < (byte)*EndS)) && (*EndS != ','));
          EndS = EndS + 1) {
      }
      HTSACopy(&DomainSuffix,StartS);
      DomainSuffix[(int)EndS - (int)StartS] = '\0';
      do {
        HTSACopy(&Host,DomainPrefix);
        if (*Str == '.') {
          local_8c = Str + 1;
        }
        else {
          local_8c = Str;
        }
        HTSACat(&Host,local_8c);
        pcVar4 = Host;
        sVar7 = strlen(Host);
        pcVar1 = Host;
        if (pcVar4[sVar7 - 1] == '.') {
          sVar7 = strlen(Host);
          pcVar1[sVar7 - 1] = '\0';
        }
        HTSACat(&Host,DomainSuffix);
        HostColon = strrchr(Host,0x3a);
        if ((HostColon != (char *)0x0) &&
           (ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[(byte)HostColon[1]] & 0x800) != 0)) {
          *HostColon = '\0';
        }
        HTSACopy(&host,Host);
        HTUnEscape(host);
        if (LYCursesON == '\0') {
          if ((Startup != '\0') && (dump_output_immediately == '\0')) {
            uVar8 = gettext(", guessing...");
            pcVar4 = host;
            uVar9 = gettext("Looking up ");
            fprintf(stdout,"%s \'%s\'%s\n",uVar9,pcVar4,uVar8);
          }
        }
        else {
          pcVar4 = (char *)gettext("Looking up ");
          HTSACopy(&MsgStr,pcVar4);
          HTSACat(&MsgStr,host);
          pcVar4 = (char *)gettext(", guessing...");
          HTSACat(&MsgStr,pcVar4);
          HTProgress(MsgStr);
        }
        phVar10 = LYGetHostByName(host);
        pcVar4 = host;
        GotHost = phVar10 != (hostent *)0x0;
        if (HostColon != (char *)0x0) {
          *HostColon = ':';
        }
        if (!(bool)GotHost) {
          if ((LYCursesON != '\0') && (lynx_nsl_status == -0x752e)) {
            if (WWW_TraceFlag != '\0') {
              pFVar6 = TraceFP();
              fprintf((FILE *)pFVar6,
                      "LYExpandHostForURL: Interrupted while \'%s\' failed to resolve.\n",pcVar4);
            }
            goto cleanup;
          }
          if (*EndS == '\0') {
            local_88 = EndS;
          }
          else {
            local_88 = EndS + 1;
          }
          for (StartS = local_88; (*StartS != '\0' && (((byte)*StartS < 0x21 || (*StartS == ','))));
              StartS = StartS + 1) {
          }
          for (EndS = StartS; ((*EndS != '\0' && (0x20 < (byte)*EndS)) && (*EndS != ','));
              EndS = EndS + 1) {
          }
          LYstrncpy(DomainSuffix,StartS,(int)EndS - (int)StartS);
        }
      } while ((GotHost == '\0') && (*DomainSuffix != '\0'));
      if (GotHost == '\0') {
        if (*EndP == '\0') {
          local_84 = EndP;
        }
        else {
          local_84 = EndP + 1;
        }
        for (StartP = local_84; (*StartP != '\0' && (((byte)*StartP < 0x21 || (*StartP == ','))));
            StartP = StartP + 1) {
        }
        for (EndP = StartP; ((*EndP != '\0' && (0x20 < (byte)*EndP)) && (*EndP != ','));
            EndP = EndP + 1) {
        }
        LYstrncpy(DomainPrefix,StartP,(int)EndP - (int)StartP);
      }
    } while ((GotHost == '\0') && (*DomainPrefix != '\0'));
    if (GotHost != '\0') {
      if ((StrColon != (char *)0x0) && (pcVar4 = strchr(Host,0x3a), pcVar4 == (char *)0x0)) {
        *StrColon = ':';
        HTSACat(&Host,StrColon);
      }
      if (Path == (char *)0x0) {
        if (Fragment != (char *)0x0) {
          HTSACat(&Host,"/");
          if (Fragment != (char *)0x0) {
            *Fragment = '#';
          }
          HTSACat(&Host,Fragment);
        }
      }
      else {
        *Path = '/';
        HTSACat(&Host,Path);
      }
      HTSACopy(AllocatedString,Host);
    }
    if (((LYCursesON != '\0') && (wVar5 = HTCheckForInterrupt(), pcVar4 = host, wVar5 != L'\0')) &&
       (WWW_TraceFlag != '\0')) {
      if (GotHost == '\0') {
        local_80 = "timed out";
      }
      else {
        local_80 = "resolved";
      }
      pFVar6 = TraceFP();
      fprintf((FILE *)pFVar6,"LYExpandHostForURL: Ignoring interrupt because \'%s\' %s.\n",pcVar4,
              local_80);
    }
  }
  else if (WWW_TraceFlag != '\0') {
    pFVar6 = TraceFP();
    fprintf((FILE *)pFVar6,"LYExpandHostForURL: Interrupted while \'%s\' failed to resolve.\n",
            pcVar4);
  }
cleanup:
  if (DomainPrefix != (char *)0x0) {
    free(DomainPrefix);
    DomainPrefix = (char *)0x0;
  }
  if (DomainSuffix != (char *)0x0) {
    free(DomainSuffix);
    DomainSuffix = (char *)0x0;
  }
  if (Str != (char *)0x0) {
    free(Str);
    Str = (char *)0x0;
  }
  if (MsgStr != (char *)0x0) {
    free(MsgStr);
    MsgStr = (char *)0x0;
  }
  if (Host != (char *)0x0) {
    free(Host);
    Host = (char *)0x0;
  }
  if (host != (char *)0x0) {
    free(host);
  }
  return GotHost;
}



// WARNING: Unknown calling convention

BOOLEAN LYAddSchemeForURL(char **AllocatedString,char *default_scheme)

{
  int iVar1;
  char *pcVar2;
  BOOLEAN local_15;
  char *Str;
  BOOLEAN GotScheme;
  
  Str = (char *)0x0;
  GotScheme = '\0';
  if ((*AllocatedString != (char *)0x0) && (**AllocatedString != '\0')) {
    iVar1 = strncasecomp(*AllocatedString,"www",3);
    if (iVar1 == 0) {
      if ((default_scheme == (char *)0x0) ||
         (pcVar2 = strstr(default_scheme,"http"), pcVar2 == (char *)0x0)) {
        HTSACopy(&Str,"http://");
      }
      else {
        HTSACopy(&Str,default_scheme);
      }
      GotScheme = '\x01';
    }
    else {
      iVar1 = strncasecomp(*AllocatedString,"ftp",3);
      if (iVar1 == 0) {
        HTSACopy(&Str,"ftp://");
        GotScheme = '\x01';
      }
      else {
        iVar1 = strncasecomp(*AllocatedString,"gopher",6);
        if (iVar1 == 0) {
          HTSACopy(&Str,"gopher://");
          GotScheme = '\x01';
        }
        else {
          iVar1 = strncasecomp(*AllocatedString,"wais",4);
          if (iVar1 == 0) {
            HTSACopy(&Str,"wais://");
            GotScheme = '\x01';
          }
          else {
            iVar1 = strncasecomp(*AllocatedString,"cso",3);
            if (((iVar1 == 0) || (iVar1 = strncasecomp(*AllocatedString,"ns.",3), iVar1 == 0)) ||
               (iVar1 = strncasecomp(*AllocatedString,"ph.",3), iVar1 == 0)) {
              HTSACopy(&Str,"cso://");
              GotScheme = '\x01';
            }
            else {
              iVar1 = strncasecomp(*AllocatedString,"finger",6);
              if (iVar1 == 0) {
                HTSACopy(&Str,"finger://");
                GotScheme = '\x01';
              }
              else {
                iVar1 = strncasecomp(*AllocatedString,"news",4);
                if (iVar1 == 0) {
                  if ((default_scheme == (char *)0x0) ||
                     ((pcVar2 = strstr(default_scheme,"news"), pcVar2 == (char *)0x0 &&
                      (pcVar2 = strstr(default_scheme,"nntp"), pcVar2 == (char *)0x0)))) {
                    HTSACopy(&Str,"news://");
                  }
                  else {
                    HTSACopy(&Str,default_scheme);
                  }
                  GotScheme = '\x01';
                }
                else {
                  iVar1 = strncasecomp(*AllocatedString,"nntp",4);
                  if (iVar1 == 0) {
                    HTSACopy(&Str,"nntp://");
                    GotScheme = '\x01';
                  }
                }
              }
            }
          }
        }
      }
    }
    if (GotScheme == '\x01') {
      HTSACat(&Str,*AllocatedString);
      HTSACopy(AllocatedString,Str);
      if (Str != (char *)0x0) {
        free(Str);
      }
      local_15 = GotScheme;
    }
    else if ((default_scheme == (char *)0x0) || (*default_scheme == '\0')) {
      local_15 = GotScheme;
    }
    else {
      HTSACopy(&Str,default_scheme);
      GotScheme = '\x01';
      HTSACat(&Str,*AllocatedString);
      HTSACopy(AllocatedString,Str);
      if (Str != (char *)0x0) {
        free(Str);
      }
      local_15 = GotScheme;
    }
    return local_15;
  }
  return '\0';
}



// WARNING: Unknown calling convention

void LYTrimRelFromAbsPath(char *path)

{
  char cVar1;
  size_t sVar2;
  wchar_t i;
  char *cp;
  BOOLEAN TerminalSlash;
  
  if ((path != (char *)0x0) && (*path == '/')) {
    sVar2 = strlen(path);
    cVar1 = path[sVar2 - 1];
    HTSimplify(path);
    cp = path;
    while (cp[1] == '.') {
      if (cp[2] == '\0') {
        cp[1] = '\0';
      }
      else if (cp[2] == '/') {
        cp = cp + 2;
      }
      else if ((cp[2] == '.') && (cp[3] == '\0')) {
        cp[1] = '\0';
      }
      else {
        if ((cp[2] != '.') || (cp[3] != '/')) break;
        cp = cp + 3;
      }
    }
    if (path < cp) {
      for (i = L'\0'; cp[i] != '\0'; i = i + L'\x01') {
        path[i] = cp[i];
      }
      path[i] = '\0';
    }
    if (cVar1 != '/') {
      LYTrimPathSep(path);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void LYDoCSI(char *url,char *comment,char **csi)

{
  int iVar1;
  char *cp;
  
  if (comment != (char *)0x0) {
    iVar1 = strncmp(comment,"!--#",4);
    if (iVar1 == 0) {
      iVar1 = strncasecomp(comment + 4,"lynxCSI",7);
      if (iVar1 == 0) {
        HTSACat(csi,"\n<p align=\"center\">URL: ");
        HTSACat(csi,url);
        HTSACat(csi,"</p>\n\n");
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

char * Current_Dir(char *pathname)

{
  char *pcVar1;
  char *result;
  
  pcVar1 = getcwd(pathname,0x100);
  if (pcVar1 == (char *)0x0) {
    memcpy(pathname,&DAT_081575f5,2);
  }
  return pathname;
}



// WARNING: Unknown calling convention

char * CheckDir(char *path)

{
  BOOLEAN BVar1;
  int iVar2;
  stat stat_info;
  
  BVar1 = LYisAbsPath(path);
  if (((BVar1 != '\0') && (iVar2 = HTStat(path,&stat_info), -1 < iVar2)) &&
     ((stat_info.st_mode & 0xf000) == 0x4000)) {
    return path;
  }
  return (char *)0x0;
}



// WARNING: Unknown calling convention

char * HomeEnv(void)

{
  char *pcVar1;
  char *result;
  
  pcVar1 = LYGetEnv("HOME");
  pcVar1 = CheckDir(pcVar1);
  return pcVar1;
}



// WARNING: Unknown calling convention

char * Home_Dir(void)

{
  char *pcVar1;
  __uid_t __uid;
  passwd *ppVar2;
  passwd *pw;
  char *cp;
  
  if (Home_Dir::homedir == (char *)0x0) {
    pcVar1 = HomeEnv();
    if (pcVar1 == (char *)0x0) {
      __uid = geteuid();
      ppVar2 = getpwuid(__uid);
      if ((ppVar2 == (passwd *)0x0) || (ppVar2->pw_dir == (char *)0x0)) {
        HTSACopy(&HomeDir,"/tmp");
      }
      else {
        HTSACopy(&HomeDir,ppVar2->pw_dir);
      }
    }
    else {
      HTSACopy(&HomeDir,pcVar1);
    }
    Home_Dir::homedir = HomeDir;
  }
  if (Home_Dir::homedir == (char *)0x0) {
    pcVar1 = (char *)gettext("Cannot find HOME directory");
    puts(pcVar1);
    exit_immediately(1);
  }
  return Home_Dir::homedir;
}



// WARNING: Unknown calling convention

char * LYPathLeaf(char *pathname)

{
  char *local_18;
  char *leaf;
  
  leaf = strrchr(pathname,0x2f);
  if (leaf != (char *)0x0) {
    leaf = leaf + 1;
  }
  if (leaf == (char *)0x0) {
    local_18 = pathname;
  }
  else {
    local_18 = leaf;
  }
  return local_18;
}



// WARNING: Unknown calling convention

BOOLEAN LYPathOffHomeOK(char *fbuffer,size_t fbuffer_size)

{
  char *pcVar1;
  UrlTypes UVar2;
  int iVar3;
  char *pcVar4;
  size_t sVar5;
  char *cp1;
  char *cp;
  char *file;
  
  file = (char *)0x0;
  if (((fbuffer == (char *)0x0) || (fbuffer_size < 2)) || (*fbuffer == '\0')) {
    return '\0';
  }
  HTSACopy(&file,fbuffer);
  pcVar4 = file;
  cp = file;
  if (*file == '~') {
    if (file[1] == '/') {
      if (file[2] == '\0') {
        if (file != (char *)0x0) {
          free(file);
        }
        return '\0';
      }
      pcVar1 = strchr(file + 2,0x2f);
      if (pcVar1 == (char *)0x0) {
        cp = pcVar4 + 2;
      }
      else {
        *pcVar4 = '.';
      }
    }
    else {
      if ((file[1] == '\0') || (pcVar4 = strchr(file + 1,0x2f), pcVar4 == (char *)0x0)) {
        if (file != (char *)0x0) {
          free(file);
        }
        return '\0';
      }
      cp = pcVar4 + -1;
      if (pcVar4[1] == '\0') {
        if (file != (char *)0x0) {
          free(file);
        }
        return '\0';
      }
      pcVar1 = strchr(pcVar4 + 1,0x2f);
      if (pcVar1 == (char *)0x0) {
        cp = pcVar4 + 1;
      }
      else {
        *cp = '.';
      }
    }
  }
  UVar2 = is_url(cp);
  if ((UVar2 == NOT_A_URL_TYPE) && (*cp != '/')) {
    HTSimplify(cp);
    iVar3 = strncmp(cp,"./",2);
    if ((iVar3 == 0) && (pcVar4 = strchr(cp + 2,0x2f), pcVar4 == (char *)0x0)) {
      cp = cp + 2;
    }
    if ((((*cp != '\0') && (*cp != '/')) && (sVar5 = strlen(cp), cp[sVar5 - 1] != '/')) &&
       ((pcVar4 = strstr(cp,".."), pcVar4 == (char *)0x0 && (iVar3 = strcmp(cp,"."), iVar3 != 0))))
    {
      if ((fbuffer_size < 4) ||
         ((iVar3 = strncmp(cp,"./",2), iVar3 == 0 ||
          (pcVar4 = strchr(cp,0x2f), pcVar4 == (char *)0x0)))) {
        sVar5 = strlen(cp);
        if (fbuffer_size - 1 < sVar5) {
          cp[fbuffer_size - 1] = '\0';
        }
        strcpy(fbuffer,cp);
      }
      else {
        memcpy(fbuffer,&DAT_08157421,3);
        sVar5 = strlen(cp);
        if (fbuffer_size - 3 < sVar5) {
          cp[fbuffer_size - 3] = '\0';
        }
        strcat(fbuffer,cp);
      }
      if (file != (char *)0x0) {
        free(file);
      }
      return '\x01';
    }
    if (file != (char *)0x0) {
      free(file);
    }
    return '\0';
  }
  if (file != (char *)0x0) {
    free(file);
  }
  return '\0';
}



char * FindLeadingTilde(char *pathname,BOOLEAN embedded)

{
  BOOLEAN embedded_local;
  char *result;
  
  result = pathname;
  if (pathname != (char *)0x0) {
    if (embedded != '\0') {
      for (; *pathname != '\0'; pathname = pathname + 1) {
        if ((*pathname == '/') && (pathname[1] == '~')) {
          pathname = pathname + 1;
          break;
        }
      }
    }
    if (*pathname == '~') {
      result = pathname;
    }
  }
  return result;
}



char * LYAbsOrHomePath(char **fname)

{
  int iVar1;
  BOOLEAN BVar2;
  int in_GS_OFFSET;
  char **fname_local;
  char temp [256];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  BVar2 = LYisAbsPath(*fname);
  if (BVar2 == '\0') {
    if (**fname == '~') {
      LYTildeExpand(fname,'\0');
    }
    else {
      LYAddPathToHome(temp,0x100,*fname);
      HTSACopy(fname,temp);
    }
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return *fname;
}



char * LYTildeExpand(char **pathname,BOOLEAN embedded)

{
  FILE *pFVar1;
  char *pcVar2;
  BOOLEAN embedded_local;
  char *second;
  char *first;
  char *temp;
  
  temp = FindLeadingTilde(*pathname,embedded);
  if (*temp == '~') {
    if (WWW_TraceFlag != '\0') {
      pcVar2 = *pathname;
      pFVar1 = TraceFP();
      fprintf((FILE *)pFVar1,"LYTildeExpand %s\n",pcVar2);
    }
    if (temp[1] == '/') {
      first = (char *)0x0;
      second = (char *)0x0;
      HTSACopy(&first,*pathname);
      first[(int)temp - (int)*pathname] = '\0';
      HTSACopy(&second,temp + 2);
      HTSACopy(pathname,first);
      pcVar2 = Home_Dir();
      pcVar2 = wwwName(pcVar2);
      HTSACat(pathname,pcVar2);
      LYAddPathSep(pathname);
      HTSACat(pathname,second);
      if (first != (char *)0x0) {
        free(first);
        first = (char *)0x0;
      }
      if (second != (char *)0x0) {
        free(second);
        second = (char *)0x0;
      }
    }
    else if (temp[1] == '\0') {
      pcVar2 = Home_Dir();
      pcVar2 = wwwName(pcVar2);
      HTSACopy(pathname,pcVar2);
    }
    if (WWW_TraceFlag != '\0') {
      pcVar2 = *pathname;
      pFVar1 = TraceFP();
      fprintf((FILE *)pFVar1,"expanded path %s\n",pcVar2);
    }
  }
  return *pathname;
}



// WARNING: Unknown calling convention

void LYAddPathToHome(char *fbuffer,size_t fbuffer_size,char *fname)

{
  char *src;
  size_t sVar1;
  int iVar2;
  char *local_18;
  wchar_t len;
  char *file;
  char *home;
  
  home = (char *)0x0;
  file = fname;
  if (fbuffer != (char *)0x0) {
    if (fbuffer_size < 2) {
      *fbuffer = '\0';
    }
    else {
      fbuffer[fbuffer_size - 1] = '\0';
      if (fname == (char *)0x0) {
        file = "";
      }
      src = Home_Dir();
      HTSACopy(&home,src);
      if ((home == (char *)0x0) || (*home == '\0')) {
        HTSACopy(&home,"/error");
      }
      sVar1 = strlen(home);
      if ((int)(~sVar1 + fbuffer_size) < 1) {
        LYstrncpy(fbuffer,home,fbuffer_size + L'\xffffffff');
        if (home != (char *)0x0) {
          free(home);
        }
      }
      else {
        iVar2 = strncmp(file,"./",2);
        if (iVar2 == 0) {
          local_18 = file + 2;
        }
        else {
          local_18 = file;
        }
        sprintf(fbuffer,"%s/%.*s",home,~sVar1 + fbuffer_size,local_18);
        if (home != (char *)0x0) {
          free(home);
        }
      }
    }
  }
  return;
}



char * LYAddPathToSave(char *fname)

{
  int iVar1;
  BOOLEAN BVar2;
  int in_GS_OFFSET;
  char *fname_local;
  char *result;
  char temp [256];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  result = (char *)0x0;
  BVar2 = LYisAbsPath(fname);
  if (BVar2 == '\0') {
    if (lynx_save_space == (char *)0x0) {
      LYAddPathToHome(temp,0x100,fname);
      HTSACopy(&result,temp);
    }
    else {
      HTSACopy(&result,lynx_save_space);
    }
  }
  else {
    HTSACopy(&result,fname);
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return result;
}



// WARNING: Unknown calling convention

BOOLEAN IsOurSymlink(char *name)

{
  BOOLEAN BVar1;
  FILE *__stream;
  char *clone;
  char *cutoff;
  char *buffer;
  wchar_t used;
  wchar_t size;
  BOOLEAN result;
  
  result = '\0';
  size = L'';
  buffer = (char *)malloc(0x100);
  if (buffer != (char *)0x0) {
    do {
      used = readlink(name,buffer,size + L'\xffffffff');
      if (used != size + L'\xffffffff') break;
      size = size << 1;
      buffer = (char *)realloc(buffer,size);
    } while (buffer != (char *)0x0);
    if (used < L'\x01') {
      if (buffer != (char *)0x0) {
        free(buffer);
        buffer = (char *)0x0;
      }
    }
    else {
      buffer[used] = '\0';
    }
  }
  if (buffer != (char *)0x0) {
    BVar1 = LYisAbsPath(buffer);
    if (BVar1 == '\0') {
      cutoff = LYLastPathSep(name);
      clone = (char *)0x0;
      if (cutoff != (char *)0x0) {
        HTSprintf0(&clone,"%.*s%s%s",(int)cutoff - (int)name,name,&DAT_081573e8,buffer);
        if (buffer != (char *)0x0) {
          free(buffer);
        }
        buffer = clone;
      }
    }
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"IsOurSymlink(%s -> %s)\n",name,buffer);
    }
    result = IsOurFile(buffer);
    if (buffer != (char *)0x0) {
      free(buffer);
    }
  }
  return result;
}



// WARNING: Unknown calling convention

BOOLEAN IsOurFile(char *name)

{
  __uid_t _Var1;
  BOOLEAN BVar2;
  int iVar3;
  __uid_t _Var4;
  FILE *__stream;
  char *local_7c;
  stat data;
  char *leaf;
  char *path;
  wchar_t linked;
  BOOLEAN result;
  
  result = '\0';
  if (*name == '~') goto LAB_08099db6;
  iVar3 = lstat64(name,(stat64 *)&data);
  _Var1 = data.st_uid;
  if (iVar3 != 0) goto LAB_08099db6;
  if ((((data.st_mode & 0xf000) == 0x8000) && ((data.st_mode & 0x12) == 0)) && (data.st_nlink == 1))
  {
    _Var4 = getuid();
    if (_Var1 != _Var4) goto LAB_08099c9e;
  }
  else {
LAB_08099c9e:
    if ((data.st_mode & 0xf000) != 0xa000) goto LAB_08099db6;
    BVar2 = IsOurSymlink(name);
    if (BVar2 == '\0') goto LAB_08099db6;
  }
  linked = L'\0';
  path = (char *)0x0;
  HTSACopy(&path,name);
  do {
    leaf = LYPathLeaf(path);
    if (leaf != path) {
      leaf = leaf + -1;
      *leaf = '\0';
    }
    if (*path == '\0') {
      local_7c = "/";
    }
    else {
      local_7c = path;
    }
    iVar3 = lstat64(local_7c,(stat64 *)&data);
    if (iVar3 != 0) break;
    if ((data.st_mode & 0xf000) == 0xa000) {
      linked = L'\x01';
    }
    else if ((data.st_mode & 0xf000) == 0x4000) {
      if ((linked != L'\0') && ((linked = L'\0', data.st_uid != 0 || ((data.st_mode & 2) != 0)))) {
        linked = L'\x01';
        break;
      }
    }
    else if (linked != L'\0') break;
  } while (leaf != path);
  if (path != (char *)0x0) {
    free(path);
    path = (char *)0x0;
  }
  result = linked == L'\0';
LAB_08099db6:
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
    iVar3 = (int)result;
    __stream = TraceFP();
    fprintf((FILE *)__stream,"IsOurFile(%s) %d\n",name,iVar3);
  }
  return result;
}



// WARNING: Unknown calling convention

FILE * OpenHiddenFile(char *name,char *mode)

{
  BOOLEAN BVar1;
  char *pcVar2;
  int *piVar3;
  FILE *pFVar4;
  int iVar5;
  FILE *pFVar6;
  __mode_t __mask;
  char *local_78;
  stat data;
  mode_t save;
  wchar_t fd;
  FILE *fp;
  BOOLEAN binary;
  
  fp = (FILE *)0x0;
  pcVar2 = strchr(mode,0x62);
  if (*mode == 'w') {
    fd = open64(name,0xc1,0x180);
    if (((fd < L'\0') && (piVar3 = __errno_location(), *piVar3 == 0x11)) &&
       (BVar1 = IsOurFile(name), BVar1 != '\0')) {
      remove(name);
      fd = open64(name,0xc1,0x180);
    }
    if (fd < L'\0') {
      return (FILE *)0x0;
    }
    pFVar4 = fdopen(fd,mode);
    return (FILE *)pFVar4;
  }
  if (*mode != 'a') {
    if (*mode != 'a') {
      __mask = umask(0x3f);
      iVar5 = chmod(name,0x180);
      if ((iVar5 == 0) || (piVar3 = __errno_location(), *piVar3 == 2)) {
        fp = (FILE *)fopen64(name,mode);
      }
      umask(__mask);
      return fp;
    }
    return (FILE *)0x0;
  }
  BVar1 = IsOurFile(name);
  if ((BVar1 != '\0') && (iVar5 = chmod(name,0x180), iVar5 == 0)) {
    pFVar4 = fopen64(name,mode);
    return (FILE *)pFVar4;
  }
  iVar5 = lstat64(name,(stat64 *)&data);
  if (iVar5 == 0) {
    return (FILE *)0x0;
  }
  if (pcVar2 == (char *)0x0) {
    local_78 = "w";
  }
  else {
    local_78 = "wb";
  }
  pFVar6 = OpenHiddenFile(name,local_78);
  return pFVar6;
}



// WARNING: Unknown calling convention

FILE * LYNewBinFile(char *name)

{
  FILE *pFVar1;
  FILE *fp;
  
  pFVar1 = OpenHiddenFile(name,"wb");
  return pFVar1;
}



// WARNING: Unknown calling convention

FILE * LYNewTxtFile(char *name)

{
  FILE *pFVar1;
  FILE *fp;
  
  pFVar1 = OpenHiddenFile(name,"w");
  return pFVar1;
}



// WARNING: Unknown calling convention

FILE * LYAppendToTxtFile(char *name)

{
  FILE *pFVar1;
  FILE *fp;
  
  pFVar1 = OpenHiddenFile(name,"a+");
  return pFVar1;
}



// WARNING: Unknown calling convention

void LYRelaxFilePermissions(char *name)

{
  int iVar1;
  __mode_t __mask;
  stat stat_buf;
  mode_t save;
  mode_t mode;
  
  iVar1 = stat64(name,(stat64 *)&stat_buf);
  if (((iVar1 == 0) && ((stat_buf.st_mode & 0xf000) == 0x8000)) &&
     ((stat_buf.st_mode & 0x1ff) == 0x180)) {
    __mask = umask(0x3f);
    umask(__mask);
    chmod(name,~__mask & (stat_buf.st_mode & 0x1c0 | 0x36));
  }
  return;
}



// WARNING: Unknown calling convention

BOOLEAN LYCachedTemp(char *result,char **cached)

{
  BOOLEAN BVar1;
  BOOLEAN local_5;
  
  if (*cached == (char *)0x0) {
    local_5 = '\0';
  }
  else {
    LYstrncpy(result,*cached,L'');
    if (*cached != (char *)0x0) {
      free(*cached);
      *cached = (char *)0x0;
    }
    BVar1 = LYCanReadFile(result);
    if (BVar1 != '\0') {
      remove(result);
    }
    local_5 = '\x01';
  }
  return local_5;
}



// WARNING: Unknown calling convention

FILE * LYOpenTemp(char *result,char *suffix,char *mode)

{
  char cVar1;
  bool bVar2;
  bool bVar3;
  __uid_t _Var4;
  FILE *pFVar5;
  int iVar6;
  __uid_t _Var7;
  __mode_t __mask;
  char *pcVar8;
  int *piVar9;
  wchar_t wVar10;
  LY_TEMP *pLVar11;
  FILE *local_8c;
  stat sb;
  wchar_t old_mask;
  LY_TEMP *p;
  FILE *fp;
  BOOLEAN make_it;
  char wrt;
  BOOLEAN txt;
  
  fp = (FILE *)0x0;
  bVar3 = true;
  wrt = 'r';
  if (WWW_TraceFlag != '\0') {
    pFVar5 = TraceFP();
    fprintf((FILE *)pFVar5,"LYOpenTemp(,%s,%s)\n",suffix,mode);
  }
  if (result == (char *)0x0) {
    local_8c = (FILE *)0x0;
  }
  else {
    while (*mode != '\0') {
      cVar1 = *mode;
      mode = mode + 1;
      if (cVar1 == 'b') {
        bVar3 = false;
      }
      else if (cVar1 == 'w') {
        wrt = 'w';
      }
      else {
        if (cVar1 != 'a') {
          if (WWW_TraceFlag != '\0') {
            pFVar5 = TraceFP();
            fprintf((FILE *)pFVar5,"%s @%d: BUG\n","./LYUtils.c",0x1742);
          }
          return (FILE *)0x0;
        }
        wrt = 'a';
      }
    }
    if (lynx_temp_subspace == 0) {
      bVar2 = false;
      iVar6 = lstat64(lynx_temp_space,(stat64 *)&sb);
      _Var4 = sb.st_uid;
      pcVar8 = lynx_temp_space;
      if ((iVar6 == 0) && ((sb.st_mode & 0xf000) == 0x4000)) {
        _Var7 = getuid();
        pcVar8 = lynx_temp_space;
        if (((_Var4 != _Var7) || ((sb.st_mode & 0x12) != 0)) &&
           (bVar2 = true, WWW_TraceFlag != '\0')) {
          pFVar5 = TraceFP();
          fprintf((FILE *)pFVar5,"lynx_temp_space is not our directory %s owner %d mode %03o\n",
                  pcVar8,sb.st_uid,sb.st_mode & 0x1ff);
        }
      }
      else {
        bVar2 = true;
        if (WWW_TraceFlag != '\0') {
          pFVar5 = TraceFP();
          fprintf((FILE *)pFVar5,"lynx_temp_space is not a directory %s\n",pcVar8);
        }
      }
      if (bVar2) {
        __mask = umask(0x3f);
        HTSACat(&lynx_temp_space,"lynxXXXXXXXXXX");
        pcVar8 = mkdtemp(lynx_temp_space);
        if (pcVar8 == (char *)0x0) {
          piVar9 = __errno_location();
          pcVar8 = strerror(*piVar9);
          printf("%s: %s\n",lynx_temp_space,pcVar8);
          exit_immediately(1);
        }
        umask(__mask);
        lynx_temp_subspace = 1;
        HTSACat(&lynx_temp_space,"/");
        pcVar8 = lynx_temp_space;
        if (WWW_TraceFlag != '\0') {
          pFVar5 = TraceFP();
          fprintf((FILE *)pFVar5,"made subdirectory %s\n",pcVar8);
        }
      }
      else {
        lynx_temp_subspace = -1;
      }
    }
    do {
      wVar10 = fmt_tempname(result,lynx_temp_space,suffix);
      if (wVar10 == L'\0') {
        return (FILE *)0x0;
      }
      if (bVar3) {
        if (wrt == 'a') {
          fp = LYAppendToTxtFile(result);
        }
        else if (wrt == 'w') {
          fp = LYNewTxtFile(result);
        }
      }
      else {
        fp = LYNewBinFile(result);
      }
      if ((fp == (FILE *)0x0) && (piVar9 = __errno_location(), *piVar9 != 0x11)) {
        if (WWW_TraceFlag != '\0') {
          piVar9 = __errno_location();
          pcVar8 = strerror(*piVar9);
          pFVar5 = TraceFP();
          fprintf((FILE *)pFVar5,"... LYOpenTemp(%s) failed: %s\n",result,pcVar8);
        }
        return (FILE *)0x0;
      }
    } while (fp == (FILE *)0x0);
    pLVar11 = (LY_TEMP *)calloc(1,0x10);
    if (pLVar11 == (LY_TEMP *)0x0) {
      outofmem("./LYUtils.c","LYOpenTemp");
    }
    else {
      pLVar11->next = ly_temp;
      HTSACopy(&pLVar11->name,result);
      pLVar11->file = fp;
      pLVar11->outs = wrt != 'r';
      ly_temp = pLVar11;
    }
    if (WWW_TraceFlag != '\0') {
      pFVar5 = TraceFP();
      fprintf((FILE *)pFVar5,"... LYOpenTemp(%s)\n",result);
    }
    local_8c = fp;
  }
  return local_8c;
}



// WARNING: Unknown calling convention

FILE * LYReopenTemp(char *name)

{
  LY_TEMP *pLVar1;
  FILE *pFVar2;
  FILE *fp;
  LY_TEMP *p;
  
  fp = (FILE *)0x0;
  LYCloseTemp(name);
  pLVar1 = FindTempfileByName(name);
  if (pLVar1 != (LY_TEMP *)0x0) {
    pFVar2 = LYAppendToTxtFile(name);
    pLVar1->file = pFVar2;
    fp = pLVar1->file;
  }
  return fp;
}



// WARNING: Unknown calling convention

FILE * LYOpenTempRewrite(char *fname,char *suffix,char *mode)

{
  char cVar1;
  bool bVar2;
  bool bVar3;
  FILE *pFVar4;
  LY_TEMP *pLVar5;
  int iVar6;
  int *piVar7;
  char *pcVar8;
  bool bVar9;
  FILE *local_94;
  char *local_90;
  char *local_8c;
  char *local_88;
  char *local_7c;
  stat stat_buf;
  LY_TEMP *p;
  FILE *fp;
  BOOLEAN still_open;
  BOOLEAN is_ours;
  BOOLEAN writable_exists;
  BOOLEAN registered;
  char wrt;
  BOOLEAN txt;
  
  fp = (FILE *)0x0;
  bVar3 = true;
  wrt = 'r';
  bVar2 = false;
  writable_exists = '\0';
  is_ours = '\0';
  bVar9 = false;
  if (WWW_TraceFlag != '\0') {
    pFVar4 = TraceFP();
    fprintf((FILE *)pFVar4,"LYOpenTempRewrite(%s,%s,%s)\n",fname,suffix,mode);
  }
  if (*fname == '\0') {
    local_94 = LYOpenTemp(fname,suffix,mode);
  }
  else {
    pLVar5 = FindTempfileByName(fname);
    if (pLVar5 != (LY_TEMP *)0x0) {
      bVar2 = true;
      bVar9 = pLVar5->file != (FILE *)0x0;
      if (WWW_TraceFlag != '\0') {
        if (bVar9) {
          local_90 = ", still open!";
        }
        else {
          local_90 = ".";
        }
        pFVar4 = TraceFP();
        fprintf((FILE *)pFVar4,"...used before%s\n",local_90);
      }
    }
    if (bVar2) {
      writable_exists = HTEditable(fname);
      if (writable_exists != '\0') {
        is_ours = IsOurFile(fname);
      }
      if (WWW_TraceFlag != '\0') {
        if (is_ours == '\0') {
          local_8c = "is NOT our file.";
        }
        else {
          local_8c = "is our file.";
        }
        if (writable_exists == '\0') {
          local_88 = "";
        }
        else {
          local_88 = "exists and is writable, ";
        }
        pFVar4 = TraceFP();
        fprintf((FILE *)pFVar4,"...%s%s\n",local_88,local_8c);
      }
    }
    if (bVar9) {
      local_94 = LYOpenTemp(fname,suffix,mode);
    }
    else if (bVar2) {
      if ((writable_exists == '\0') || (is_ours != '\0')) {
        if ((is_ours == '\0') && (iVar6 = lstat64(fname,(stat64 *)&stat_buf), iVar6 == 0)) {
          local_94 = LYOpenTemp(fname,suffix,mode);
        }
        else {
          while (*mode != '\0') {
            cVar1 = *mode;
            mode = mode + 1;
            if (cVar1 == 'b') {
              bVar3 = false;
            }
            else if (cVar1 == 'w') {
              wrt = 'w';
            }
            else {
              if (cVar1 != 'a') {
                if (WWW_TraceFlag != '\0') {
                  pFVar4 = TraceFP();
                  fprintf((FILE *)pFVar4,"%s @%d: BUG\n","./LYUtils.c",0x180d);
                }
                return (FILE *)0x0;
              }
              wrt = 'a';
            }
          }
          if (is_ours != '\0') {
            if (bVar3) {
              iVar6 = truncate64(fname,0);
              if (iVar6 != 0) {
                if (WWW_TraceFlag != '\0') {
                  piVar7 = __errno_location();
                  pcVar8 = strerror(*piVar7);
                  pFVar4 = TraceFP();
                  fprintf((FILE *)pFVar4,"... truncate(%s,0) failed: %s\n",fname,pcVar8);
                }
                pFVar4 = LYOpenTemp(fname,suffix,mode);
                return pFVar4;
              }
              pFVar4 = LYReopenTemp(fname);
              return pFVar4;
            }
            remove(fname);
          }
          if (bVar3) {
            if (wrt == 'a') {
              fp = LYAppendToTxtFile(fname);
            }
            else if (wrt == 'w') {
              fp = LYNewTxtFile(fname);
            }
          }
          else {
            fp = LYNewBinFile(fname);
          }
          pLVar5->file = fp;
          if (WWW_TraceFlag != '\0') {
            if (fp == (FILE *)0x0) {
              local_7c = "failed";
            }
            else {
              local_7c = "ok";
            }
            pFVar4 = TraceFP();
            fprintf((FILE *)pFVar4,"... LYOpenTempRewrite(%s), %s\n",fname,local_7c);
          }
          local_94 = fp;
        }
      }
      else {
        local_94 = LYOpenTemp(fname,suffix,mode);
      }
    }
    else {
      local_94 = LYOpenTemp(fname,suffix,mode);
    }
  }
  return local_94;
}



// WARNING: Unknown calling convention

FILE * LYOpenScratch(char *result,char *prefix)

{
  wchar_t wVar1;
  LY_TEMP *pLVar2;
  FILE *__stream;
  FILE *local_18;
  LY_TEMP *p;
  FILE *fp;
  
  wVar1 = fmt_tempname(result,prefix,".html");
  if (wVar1 == L'\0') {
    local_18 = (FILE *)0x0;
  }
  else {
    local_18 = LYNewTxtFile(result);
    if (local_18 != (FILE *)0x0) {
      pLVar2 = (LY_TEMP *)calloc(1,0x10);
      if (pLVar2 == (LY_TEMP *)0x0) {
        outofmem("./LYUtils.c","LYOpenScratch");
      }
      else {
        pLVar2->next = ly_temp;
        HTSACopy(&pLVar2->name,result);
        pLVar2->file = local_18;
        ly_temp = pLVar2;
      }
    }
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"LYOpenScratch(%s)\n",result);
    }
  }
  return local_18;
}



// WARNING: Unknown calling convention

void LY_close_temp(LY_TEMP *p)

{
  if (p->file != (FILE *)0x0) {
    if (p->outs == '\0') {
      LYCloseInput(p->file);
    }
    else {
      LYCloseOutput(p->file);
    }
    p->file = (FILE *)0x0;
  }
  return;
}



// WARNING: Unknown calling convention

void LYCloseTemp(char *name)

{
  FILE *pFVar1;
  LY_TEMP *p_00;
  char *local_18;
  LY_TEMP *p;
  
  if (WWW_TraceFlag != '\0') {
    pFVar1 = TraceFP();
    fprintf((FILE *)pFVar1,"LYCloseTemp(%s)\n",name);
  }
  p_00 = FindTempfileByName(name);
  if (p_00 != (LY_TEMP *)0x0) {
    if (WWW_TraceFlag != '\0') {
      if (p_00->file == (FILE *)0x0) {
        local_18 = "";
      }
      else {
        local_18 = ", closed";
      }
      pFVar1 = TraceFP();
      fprintf((FILE *)pFVar1,"...LYCloseTemp(%s)%s\n",name,local_18);
    }
    LY_close_temp(p_00);
  }
  return;
}



// WARNING: Unknown calling convention

void LYCloseTempFP(FILE *fp)

{
  char *pcVar1;
  FILE *pFVar2;
  LY_TEMP *p_00;
  LY_TEMP *p;
  
  if (WWW_TraceFlag != '\0') {
    pFVar2 = TraceFP();
    fprintf((FILE *)pFVar2,"LYCloseTempFP\n");
  }
  p_00 = FindTempfileByFP(fp);
  if (p_00 != (LY_TEMP *)0x0) {
    LY_close_temp(p_00);
    if (WWW_TraceFlag != '\0') {
      pcVar1 = p_00->name;
      pFVar2 = TraceFP();
      fprintf((FILE *)pFVar2,"...LYCloseTempFP(%s)\n",pcVar1);
    }
  }
  return;
}



// WARNING: Unknown calling convention

wchar_t LYRemoveTemp(char *name)

{
  FILE *pFVar1;
  int iVar2;
  wchar_t wVar3;
  char *local_18;
  wchar_t code;
  LY_TEMP *q;
  LY_TEMP *p;
  
  if ((name != (char *)0x0) && (*name != '\0')) {
    if (WWW_TraceFlag != '\0') {
      pFVar1 = TraceFP();
      fprintf((FILE *)pFVar1,"LYRemoveTemp(%s)\n",name);
    }
    q = (LY_TEMP *)0x0;
    for (p = ly_temp; p != (LY_TEMP *)0x0; p = p->next) {
      iVar2 = strcmp(name,p->name);
      if (iVar2 == 0) {
        if (q == (LY_TEMP *)0x0) {
          ly_temp = p->next;
        }
        else {
          q->next = p->next;
        }
        LY_close_temp(p);
        wVar3 = remove(name);
        if (WWW_TraceFlag != '\0') {
          if (p->file == (FILE *)0x0) {
            local_18 = "";
          }
          else {
            local_18 = ", closed";
          }
          pFVar1 = TraceFP();
          fprintf((FILE *)pFVar1,"...LYRemoveTemp done(%d)%s\n",wVar3,local_18);
        }
        if (WWW_TraceFlag != '\0') {
          pFVar1 = TraceFP();
          fflush((FILE *)pFVar1);
        }
        if (p->name != (char *)0x0) {
          free(p->name);
          p->name = (char *)0x0;
        }
        if (p == (LY_TEMP *)0x0) {
          return wVar3;
        }
        free(p);
        return wVar3;
      }
      q = p;
    }
  }
  return L'\xffffffff';
}



// WARNING: Unknown calling convention

void LYCleanupTemp(void)

{
  int iVar1;
  FILE *__stream;
  int in_GS_OFFSET;
  char result [256];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  while (ly_temp != (LY_TEMP *)0x0) {
    LYRemoveTemp(ly_temp->name);
  }
  if (0 < lynx_temp_subspace) {
    LYstrncpy(result,lynx_temp_space,L'');
    LYTrimPathSep(result);
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"LYCleanupTemp removing %s\n",result);
    }
    rmdir(result);
    lynx_temp_subspace = -1;
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



// WARNING: Unknown calling convention

void LYRenamedTemp(char *oldname,char *newname)

{
  FILE *__stream;
  LY_TEMP *pLVar1;
  LY_TEMP *p;
  
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"LYRenamedTemp(old=%s, new=%s)\n",oldname,newname);
  }
  pLVar1 = FindTempfileByName(oldname);
  if (pLVar1 != (LY_TEMP *)0x0) {
    HTSACopy(&pLVar1->name,newname);
  }
  return;
}



// WARNING: Unknown calling convention

void LYCheckBibHost(void)

{
  BOOLEAN BVar1;
  BOOLEAN BVar2;
  DocAddress bibhostIcon;
  BOOLEAN saveFlag;
  
  bibhostIcon.address = (char *)0x0;
  HTSACopy(&bibhostIcon.address,BibP_bibhost);
  HTSACat(&bibhostIcon.address,"bibp1.0/bibpicon.jpg");
  BVar1 = traversal;
  bibhostIcon.post_data = (bstring *)0x0;
  bibhostIcon.post_content_type = (char *)0x0;
  bibhostIcon.bookmark = (char *)0x0;
  bibhostIcon.isHEAD = '\0';
  bibhostIcon.safe = '\0';
  traversal = '\x01';
  BVar2 = HTLoadAbsolute(&bibhostIcon);
  BibP_bibhost_available = BVar2 == '\x01';
  traversal = BVar1;
  BibP_bibhost_checked = '\x01';
  return;
}



// WARNING: Unknown calling convention

BOOLEAN LYIsUIPage3(char *url,UIP_t type,wchar_t flagparam)

{
  size_t sVar1;
  int iVar2;
  bool bVar3;
  char *local_18;
  HTList *l0;
  char *p;
  size_t l;
  uint i;
  
  if (url == (char *)0x0) {
    return '\0';
  }
  i = 0;
  while( true ) {
    if (0xc < i) {
      return '\0';
    }
    if (ly_uip[i].type == type) break;
    i = i + 1;
  }
  if (ly_uip[i].url != (char *)0x0) {
    if ((flagparam & 1U) == 0) {
      iVar2 = strcmp(ly_uip[i].url,url);
      bVar3 = iVar2 == 0;
    }
    else {
      sVar1 = strlen(ly_uip[i].url);
      iVar2 = strncmp(ly_uip[i].url,url,sVar1);
      if ((iVar2 == 0) && ((url[sVar1] == '\0' || (url[sVar1] == '#')))) {
        bVar3 = true;
      }
      else {
        bVar3 = false;
      }
    }
    if (bVar3) {
      return '\x01';
    }
    if ((ly_uip[i].flags & 1) != 0) {
      l0 = ly_uip[i].alturls;
      while( true ) {
        if ((l0 == (HTList *)0x0) || (l0 = l0->next, l0 == (HTList *)0x0)) {
          local_18 = (char *)0x0;
        }
        else {
          local_18 = (char *)l0->object;
        }
        if (local_18 == (char *)0x0) break;
        if ((flagparam & 1U) == 0) {
          iVar2 = strcmp(local_18,url);
          bVar3 = iVar2 == 0;
        }
        else {
          sVar1 = strlen(local_18);
          iVar2 = strncmp(local_18,url,sVar1);
          if ((iVar2 == 0) && ((url[sVar1] == '\0' || (url[sVar1] == '#')))) {
            bVar3 = true;
          }
          else {
            bVar3 = false;
          }
        }
        if (bVar3) {
          return '\x01';
        }
      }
    }
    return '\0';
  }
  return '\0';
}



// WARNING: Unknown calling convention

void LYRegisterUIPage(char *url,UIP_t type)

{
  int iVar1;
  HTList *pHVar2;
  char *local_1c;
  HTList *l0;
  wchar_t n;
  char *p;
  uint i;
  
  i = 0;
  while( true ) {
    if (0xc < i) {
      return;
    }
    if (ly_uip[i].type == type) break;
    i = i + 1;
  }
  if (((ly_uip[i].url != (char *)0x0) && (url != (char *)0x0)) &&
     (iVar1 = strcmp(ly_uip[i].url,url), iVar1 == 0)) {
    return;
  }
  if (((ly_uip[i].url == (char *)0x0) || (url == (char *)0x0)) || ((ly_uip[i].flags & 1) == 0)) {
    HTSACopy(&ly_uip[i].url,url);
    return;
  }
  n = L'\0';
  l0 = ly_uip[i].alturls;
  while( true ) {
    if ((l0 == (HTList *)0x0) || (l0 = l0->next, l0 == (HTList *)0x0)) {
      local_1c = (char *)0x0;
    }
    else {
      local_1c = (char *)l0->object;
    }
    if (local_1c == (char *)0x0) {
      if (ly_uip[i].alturls == (HTList *)0x0) {
        pHVar2 = HTList_new();
        ly_uip[i].alturls = pHVar2;
      }
      if ((HTCacheSize <= n) && ((ly_uip[i].flags & 2) != 0)) {
        HTList_removeFirstObject(ly_uip[i].alturls);
      }
      HTList_addObject(ly_uip[i].alturls,ly_uip[i].url);
      ly_uip[i].url = (char *)0x0;
      HTSACopy(&ly_uip[i].url,url);
      return;
    }
    iVar1 = strcmp(local_1c,url);
    if (iVar1 == 0) {
      return;
    }
    iVar1 = strcmp(local_1c,ly_uip[i].url);
    if (iVar1 == 0) break;
    n = n + L'\x01';
  }
  HTSACopy(&ly_uip[i].url,url);
  return;
}



// WARNING: Unknown calling convention

void LYUIPages_free(void)

{
  uint i;
  
  for (i = 0; i < 0xd; i = i + 1) {
    if (ly_uip[i].url != (char *)0x0) {
      free(ly_uip[i].url);
      ly_uip[i].url = (char *)0x0;
    }
    if (ly_uip[i].file != (char *)0x0) {
      free(ly_uip[i].file);
      ly_uip[i].file = (char *)0x0;
    }
    LYFreeStringList(ly_uip[i].alturls);
    ly_uip[i].alturls = (HTList *)0x0;
  }
  return;
}



// WARNING: Unknown calling convention

char * wwwName(char *pathname)

{
  char *cp;
  
  return pathname;
}



// WARNING: Unknown calling convention

BOOLEAN LYValidateFilename(char *result,char *given)

{
  BOOLEAN BVar1;
  int iVar2;
  char *pcVar3;
  char *pcVar4;
  size_t sVar5;
  size_t sVar6;
  BOOLEAN local_19;
  char *cp2;
  char *cp;
  
  iVar2 = strcmp(given,"/dev/null");
  if (iVar2 == 0) {
    local_19 = '\0';
  }
  else if (*given == '|') {
    if (no_shell == '\0') {
      LYstrncpy(result,given,L'');
      local_19 = '\x01';
    }
    else {
      pcVar3 = (char *)gettext("Spawning is currently disabled.");
      HTUserMsg(pcVar3);
      local_19 = '\0';
    }
  }
  else {
    pcVar3 = FindLeadingTilde(given,'\x01');
    if (pcVar3 != given) {
      pcVar4 = Home_Dir();
      pcVar4 = wwwName(pcVar4);
      if (pcVar4 != (char *)0x0) {
        sVar5 = strlen(pcVar4);
        sVar6 = strlen(given);
        if (sVar5 + sVar6 < 0x100) {
          *pcVar3 = '\0';
          strcpy(result,given);
          LYTrimPathSep(result);
          strcat(result,pcVar4);
          strcat(result,pcVar3 + 1);
          strcpy(given,result);
        }
      }
    }
    BVar1 = LYisAbsPath(given);
    if (BVar1 == '\0') {
      cp = Current_Dir(LYValidateFilename::buf);
    }
    else {
      cp = (char *)0x0;
    }
    *result = '\0';
    if (cp != (char *)0x0) {
      LYTrimPathSep(cp);
      sVar5 = strlen(cp);
      if (0xfd < sVar5) {
        return '\0';
      }
      sprintf(result,"%s/",cp);
    }
    sVar5 = strlen(result);
    sVar6 = strlen(given);
    if (sVar5 + sVar6 < 0xff) {
      strcat(result,given);
      local_19 = '\x01';
    }
    else {
      local_19 = '\0';
    }
  }
  return local_19;
}



// WARNING: Unknown calling convention

wchar_t LYValidateOutput(char *filename)

{
  BOOLEAN BVar1;
  BOOLEAN BVar2;
  char *pcVar3;
  wchar_t c;
  
  if (*filename == '|') {
    return L'Y';
  }
  if (((no_dotfiles != '\0') || (show_dotfiles == '\0')) &&
     (pcVar3 = LYPathLeaf(filename), *pcVar3 == '.')) {
    pcVar3 = (char *)gettext("File name may not begin with a dot.");
    HTAlert(pcVar3);
    return L'N';
  }
  BVar1 = LYCanReadFile(filename);
  if (BVar1 != '\0') {
    pcVar3 = (char *)gettext("File exists.  Overwrite?");
    BVar1 = HTConfirm(pcVar3);
    BVar2 = HTLastConfirmCancelled();
    if (BVar2 != '\0') {
      pcVar3 = (char *)gettext("Save request cancelled!!!");
      HTInfoMsg(pcVar3);
      return L'\x03';
    }
    if (BVar1 == '\0') {
      return L'N';
    }
  }
  return L'Y';
}



void LYLocalFileToURL(char **target,char *source)

{
  int iVar1;
  BOOLEAN BVar2;
  char *src;
  int in_GS_OFFSET;
  char *source_local;
  char **target_local;
  char *leaf;
  char temp [256];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  HTSACopy(target,"file://localhost");
  src = wwwName(source);
  BVar2 = LYisAbsPath(source);
  if (BVar2 == '\0') {
    Current_Dir(temp);
    if (temp[0] != '/') {
      LYAddHtmlSep(target);
    }
    HTSACat(target,temp);
  }
  if (*src != '/') {
    LYAddHtmlSep(target);
  }
  HTSACat(target,src);
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



// WARNING: Unknown calling convention

FILE * InternalPageFP(char *filename,wchar_t reuse_flag)

{
  char *Msg;
  FILE *fp;
  
  if ((LYReuseTempfiles == '\0') || (reuse_flag == L'\0')) {
    LYRemoveTemp(filename);
    fp = LYOpenTemp(filename,".html","wb");
  }
  else {
    fp = LYOpenTempRewrite(filename,".html","wb");
  }
  if (fp == (FILE *)0x0) {
    Msg = (char *)gettext("Can\'t open temporary file!");
    HTAlert(Msg);
  }
  return fp;
}



// WARNING: Unknown calling convention

void WriteInternalTitle(FILE *fp0,char *Title)

{
  char *pcVar1;
  int iVar2;
  char *Address;
  
  fwrite("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">\n",1,0x40,(FILE *)fp0);
  fwrite("<html>\n<head>\n",1,0xe,(FILE *)fp0);
  LYAddMETAcharsetToFD(fp0,-1);
  pcVar1 = (char *)gettext("List Page");
  iVar2 = strcmp(Title,pcVar1);
  if (iVar2 == 0) {
    pcVar1 = HTLoadedDocumentURL();
    pcVar1 = strchr(pcVar1,0x22);
    if (pcVar1 == (char *)0x0) {
      Address = (char *)0x0;
      pcVar1 = HTLoadedDocumentURL();
      HTSACopy(&Address,pcVar1);
      LYEntify(&Address,'\0');
      fprintf((FILE *)fp0,"<base href=\"%s\">\n",Address);
      if (Address != (char *)0x0) {
        free(Address);
        Address = (char *)0x0;
      }
    }
  }
  fprintf((FILE *)fp0,"<title>%s</title>\n</head>\n<body>\n",Title);
  return;
}



// WARNING: Unknown calling convention

void BeginInternalPage(FILE *fp0,char *Title,char *HelpURL)

{
  char *pcVar1;
  BOOLEAN BVar2;
  undefined4 uVar3;
  
  WriteInternalTitle(fp0,Title);
  if (((user_mode == 0) &&
      (BVar2 = LYwouldPush(Title,(char *)0x0), pcVar1 = helpfilepath, BVar2 != '\0')) &&
     (HelpURL != (char *)0x0)) {
    uVar3 = gettext(" Version ");
    fprintf((FILE *)fp0,"<h1>%s (%s%s%s), <a href=\"%s%s\">help</a></h1>\n",Title,&DAT_08157a84,
            uVar3,"2.8.7dev.11",pcVar1,HelpURL);
    return;
  }
  uVar3 = gettext(" Version ");
  fprintf((FILE *)fp0,"<h1>%s (%s%s%s)</h1>\n",Title,&DAT_08157a84,uVar3,"2.8.7dev.11");
  return;
}



// WARNING: Unknown calling convention

void EndInternalPage(FILE *fp0)

{
  fwrite("</body>\n</html>",1,0xf,(FILE *)fp0);
  return;
}



// WARNING: Unknown calling convention

char * trimPoundSelector(char *address)

{
  char *pcVar1;
  char *pound;
  
  pcVar1 = strchr(address,0x23);
  if (pcVar1 != (char *)0x0) {
    *pcVar1 = '\0';
  }
  return pcVar1;
}



// WARNING: Unknown calling convention

void LYTrimPathSep(char *path)

{
  size_t sVar1;
  size_t len;
  
  if (path != (char *)0x0) {
    sVar1 = strlen(path);
    if ((sVar1 != 0) && (path[sVar1 - 1] == '/')) {
      path[sVar1 - 1] = '\0';
    }
  }
  return;
}



// WARNING: Unknown calling convention

void LYAddPathSep(char **path)

{
  char *__s;
  size_t sVar1;
  char *temp;
  size_t len;
  
  if ((path != (char **)0x0) && (__s = *path, __s != (char *)0x0)) {
    sVar1 = strlen(__s);
    if ((sVar1 != 0) && (__s[sVar1 - 1] != '/')) {
      HTSACat(path,"/");
    }
  }
  return;
}



// WARNING: Unknown calling convention

void LYAddPathSep0(char *path)

{
  size_t sVar1;
  size_t len;
  
  if (path != (char *)0x0) {
    sVar1 = strlen(path);
    if (((sVar1 != 0) && (sVar1 < 0xfe)) && (path[sVar1 - 1] != '/')) {
      strcat(path,"/");
    }
  }
  return;
}



// WARNING: Unknown calling convention

char * LYLastPathSep(char *path)

{
  char *pcVar1;
  char *result;
  
  pcVar1 = strrchr(path,0x2f);
  return pcVar1;
}



// WARNING: Unknown calling convention

void LYTrimHtmlSep(char *path)

{
  size_t sVar1;
  size_t len;
  
  if (path != (char *)0x0) {
    sVar1 = strlen(path);
    if ((sVar1 != 0) && (path[sVar1 - 1] == '/')) {
      path[sVar1 - 1] = '\0';
    }
  }
  return;
}



// WARNING: Unknown calling convention

void LYAddHtmlSep(char **path)

{
  char *__s;
  size_t sVar1;
  char *temp;
  size_t len;
  
  if ((path != (char **)0x0) && (__s = *path, __s != (char *)0x0)) {
    sVar1 = strlen(__s);
    if ((sVar1 != 0) && (__s[sVar1 - 1] != '/')) {
      HTSACat(path,"/");
    }
  }
  return;
}



// WARNING: Unknown calling convention

void LYAddHtmlSep0(char *path)

{
  size_t sVar1;
  size_t len;
  
  if (path != (char *)0x0) {
    sVar1 = strlen(path);
    if (((sVar1 != 0) && (sVar1 < 0xfe)) && (path[sVar1 - 1] != '/')) {
      strcat(path,"/");
    }
  }
  return;
}



wchar_t LYCopyFile(char *src,char *dst)

{
  int iVar1;
  FILE *__stream;
  FILE *__stream_00;
  FILE *__s;
  int iVar2;
  size_t __n;
  char *pcVar3;
  int in_GS_OFFSET;
  char *dst_local;
  char *src_local;
  wchar_t len;
  FILE *fout;
  FILE *fin;
  char *the_command;
  char *program;
  wchar_t code;
  uchar buff [8192];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  program = HTGetProgramPath(ppCOPY);
  if (program == (char *)0x0) {
    code = L'\xffffffff';
    __stream_00 = fopen64(src,"rb");
    if (__stream_00 != (FILE *)0x0) {
      __s = fopen64(dst,"wb");
      if (__s != (FILE *)0x0) {
        code = L'\0';
        do {
          __n = fread(buff,1,0x2000,__stream_00);
          if ((int)__n < 1) goto LAB_0809bf6a;
          fwrite(buff,1,__n,__s);
          iVar2 = ferror(__s);
        } while (iVar2 == 0);
        code = L'\xffffffff';
LAB_0809bf6a:
        LYCloseOutput((FILE *)__s);
      }
      LYCloseInput((FILE *)__stream_00);
    }
  }
  else {
    the_command = (char *)0x0;
    HTAddParam(&the_command,"%s %s %s",1,program);
    HTAddParam(&the_command,"%s %s %s",2,src);
    HTAddParam(&the_command,"%s %s %s",3,dst);
    HTEndParam(&the_command,"%s %s %s",3);
    pcVar3 = the_command;
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"command: %s\n",pcVar3);
    }
    stop_curses();
    code = LYSystem(the_command);
    start_curses();
    if (the_command != (char *)0x0) {
      free(the_command);
      the_command = (char *)0x0;
    }
  }
  if (code != L'\0') {
    pcVar3 = (char *)gettext("Cannot write to file.");
    HTAlert(pcVar3);
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return code;
}



// WARNING: Removing unreachable block (ram,0x0809c115)
// WARNING: Removing unreachable block (ram,0x0809c11b)
// WARNING: Unknown calling convention

wchar_t LYSystem(char *command)

{
  int iVar1;
  FILE *pFVar2;
  wchar_t wVar3;
  int *piVar4;
  sigaction saved_sigtstp_act;
  wchar_t saved_errno;
  wchar_t do_free;
  wchar_t code;
  BOOLEAN sigtstp_saved;
  
  sigtstp_saved = '\0';
  fflush(stdout);
  fflush(stderr);
  if (WWW_TraceFlag != '\0') {
    pFVar2 = TraceFP();
    fprintf((FILE *)pFVar2,"LYSystem(%s)\n",command);
  }
  if (WWW_TraceFlag != '\0') {
    pFVar2 = TraceFP();
    fflush((FILE *)pFVar2);
  }
  if (restore_sigpipe_for_children != '\0') {
    signal(0xd,(__sighandler_t)0x0);
  }
  if (((dump_output_immediately == '\0') && (LYCursesON == '\0')) && (no_suspend == '\0')) {
    sigtstp_saved = LYToggleSigDfl(L'\x14',&saved_sigtstp_act,L'\x01');
  }
  wVar3 = system(command);
  piVar4 = __errno_location();
  iVar1 = *piVar4;
  if (sigtstp_saved != '\0') {
    LYToggleSigDfl(L'\x14',&saved_sigtstp_act,L'\0');
  }
  if (restore_sigpipe_for_children != '\0') {
    signal(0xd,(__sighandler_t)0x1);
  }
  fflush(stdout);
  fflush(stderr);
  piVar4 = __errno_location();
  *piVar4 = iVar1;
  return wVar3;
}



// WARNING: Unknown calling convention

char * LYSysShell(void)

{
  char *shell;
  
  return "exec $SHELL";
}



// WARNING: Unknown calling convention

char * LYgetXDisplay(void)

{
  char *pcVar1;
  
  pcVar1 = LYGetEnv("DISPLAY");
  return pcVar1;
}



// WARNING: Unknown calling convention

void LYsetXDisplay(char *new_display)

{
  char *src;
  
  if (new_display != (char *)0x0) {
    HTSprintf0(&LYsetXDisplay::display_putenv_command,"DISPLAY=%s",new_display);
    putenv(LYsetXDisplay::display_putenv_command);
    src = LYgetXDisplay();
    if (src != (char *)0x0) {
      HTSACopy(&x_display,src);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void get_clip_release(void)

{
  if (paste_handle != (FILE *)0x0) {
    pclose((FILE *)paste_handle);
  }
  if ((paste_buf != (char *)0x0) && (paste_buf != (char *)0x0)) {
    free(paste_buf);
    paste_buf = (char *)0x0;
  }
  return;
}



// WARNING: Unknown calling convention

wchar_t clip_grab(void)

{
  char *__command;
  wchar_t local_18;
  char *cmd;
  
  __command = LYGetEnv("RL_PASTE_CMD");
  if (paste_handle != (FILE *)0x0) {
    pclose((FILE *)paste_handle);
  }
  if (__command == (char *)0x0) {
    local_18 = L'\0';
  }
  else {
    paste_handle = (FILE *)popen(__command,"r");
    if (paste_handle == (FILE *)0x0) {
      local_18 = L'\0';
    }
    else {
      local_18 = L'\x01';
    }
  }
  return local_18;
}



// WARNING: Unknown calling convention

char * get_clip_grab(void)

{
  wchar_t wVar1;
  size_t sVar2;
  char *pcVar3;
  char *local_18;
  wchar_t off;
  wchar_t size;
  wchar_t len;
  
  size = L'';
  off = L'\0';
  wVar1 = clip_grab();
  if (wVar1 == L'\0') {
    local_18 = (char *)0x0;
  }
  else if (paste_handle == (FILE *)0x0) {
    local_18 = (char *)0x0;
  }
  else {
    if ((paste_buf != (char *)0x0) && (paste_buf != (char *)0x0)) {
      free(paste_buf);
      paste_buf = (char *)0x0;
    }
    paste_buf = (char *)malloc(0x3f0);
    while( true ) {
      sVar2 = fread(paste_buf + off,1,0x3ef,(FILE *)paste_handle);
      paste_buf[off + sVar2] = '\0';
      if ((int)sVar2 < 0x3ef) break;
      pcVar3 = strchr(paste_buf + off,0xd);
      if (pcVar3 != (char *)0x0) break;
      pcVar3 = strchr(paste_buf + off,10);
      if (pcVar3 != (char *)0x0) break;
      size = size + L'';
      paste_buf = (char *)realloc(paste_buf,size);
      off = off + sVar2;
    }
    local_18 = paste_buf;
  }
  return local_18;
}



// WARNING: Unknown calling convention

wchar_t put_clip(char *s)

{
  char *__command;
  size_t __n;
  FILE *__s;
  size_t sVar1;
  int iVar2;
  wchar_t local_18;
  wchar_t res;
  wchar_t l;
  FILE *fh;
  char *cmd;
  
  __command = LYGetEnv("RL_CLCOPY_CMD");
  __n = strlen(s);
  if (__command == (char *)0x0) {
    local_18 = L'\xffffffff';
  }
  else {
    __s = popen(__command,"w");
    if (__s == (FILE *)0x0) {
      local_18 = L'\xffffffff';
    }
    else {
      sVar1 = fwrite(s,1,__n,__s);
      iVar2 = pclose(__s);
      if ((iVar2 == 0) && (sVar1 == __n)) {
        local_18 = L'\0';
      }
      else {
        local_18 = L'\xffffffff';
      }
    }
  }
  return local_18;
}



// WARNING: Unknown calling convention

void LYmsec_delay(uint msec)

{
  napms(msec);
  return;
}



// WARNING: Unknown calling convention

void LYOpenlog(char *banner)

{
  FILE *__stream;
  char *local_8;
  
  if (syslog_requested_urls != '\0') {
    if (WWW_TraceFlag != '\0') {
      if (banner == (char *)0x0) {
        local_8 = "(null)";
      }
      else {
        local_8 = banner;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"LYOpenlog(%s)\n",local_8);
    }
    openlog("lynx",1,0xa8);
    if (banner == (char *)0x0) {
      syslog(6,"Session start");
    }
    else {
      syslog(6,"Session start:%s",banner);
    }
  }
  return;
}



// WARNING: Unknown calling convention

BOOLEAN looks_like_password(char *first,char *last)

{
  BOOLEAN result;
  
  result = '\0';
  while( true ) {
    if (last < first) {
      return result;
    }
    if ((*first == '/') || (*first == ':')) break;
    result = '\x01';
    first = first + 1;
  }
  return '\0';
}



// WARNING: Unknown calling convention

void LYSyslog(char *arg)

{
  char *pcVar1;
  BOOLEAN BVar2;
  FILE *pFVar3;
  UrlTypes UVar4;
  int iVar5;
  char *local_1c;
  char *buf;
  char *atsign;
  char *colon2;
  char *colon1;
  
  if (syslog_requested_urls != '\0') {
    if (WWW_TraceFlag != '\0') {
      pFVar3 = TraceFP();
      fprintf((FILE *)pFVar3,"LYSyslog %s\n",arg);
    }
    UVar4 = is_url(arg);
    if ((((UVar4 != NOT_A_URL_TYPE) && (colon1 = strchr(arg,0x3a), colon1 != (char *)0x0)) &&
        (iVar5 = strncmp(colon1,"://",3), iVar5 == 0)) &&
       (((colon2 = strchr(colon1 + 3,0x3a), colon2 != (char *)0x0 &&
         (atsign = strchr(colon1,0x40), atsign != (char *)0x0)) &&
        ((colon2 < atsign && (BVar2 = looks_like_password(colon2 + 1,atsign + -1), BVar2 != '\0'))))
       )) {
      buf = (char *)0x0;
      HTSACopy(&buf,arg);
      buf[(int)(colon2 + (1 - (int)arg))] = '\0';
      HTSACat(&buf,"******");
      HTSACat(&buf,atsign);
      syslog(0xae,"%s",buf);
      pcVar1 = buf;
      if (WWW_TraceFlag != '\0') {
        pFVar3 = TraceFP();
        fprintf((FILE *)pFVar3,"...alter %s\n",pcVar1);
      }
      if (buf == (char *)0x0) {
        return;
      }
      free(buf);
      return;
    }
    if (arg == (char *)0x0) {
      local_1c = "(null)";
    }
    else {
      local_1c = arg;
    }
    syslog(0xae,"%s",local_1c);
  }
  return;
}



// WARNING: Unknown calling convention

void LYCloselog(void)

{
  if (syslog_requested_urls != '\0') {
    syslog(6,"Session over");
    closelog();
  }
  return;
}



// WARNING: Unknown calling convention

BOOLEAN LYCheckUserAgent(void)

{
  char *pcVar1;
  
  if ((((LYUserAgent != (char *)0x0) && (*LYUserAgent != '\0')) &&
      (pcVar1 = strstr(LYUserAgent,"Lynx"), pcVar1 == (char *)0x0)) &&
     (((pcVar1 = strstr(LYUserAgent,"lynx"), pcVar1 == (char *)0x0 &&
       (pcVar1 = strstr(LYUserAgent,"L_y_n_x"), pcVar1 == (char *)0x0)) &&
      (pcVar1 = strstr(LYUserAgent,"l_y_n_x"), pcVar1 == (char *)0x0)))) {
    return '\0';
  }
  return '\x01';
}



// WARNING: Unknown calling convention

void validate_x_display(void)

{
  char *src;
  char *cp;
  
  src = LYgetXDisplay();
  if (src == (char *)0x0) {
    if (x_display != (char *)0x0) {
      free(x_display);
      x_display = (char *)0x0;
    }
  }
  else {
    HTSACopy(&x_display,src);
  }
  return;
}



// WARNING: Unknown calling convention

void summarize_x_display(char *display_option)

{
  int iVar1;
  char *pcVar2;
  
  if ((x_display == (char *)0x0) && (*display_option == '\0')) {
LAB_0809c891:
    if ((x_display == (char *)0x0) && (LYisConfiguredForX == '\x01')) {
      mustshow = '\x01';
      pcVar2 = (char *)gettext("Value accepted! -- WARNING: Lynx is configured for XWINDOWS!");
      statusline(pcVar2);
    }
    else if ((x_display == (char *)0x0) || (LYisConfiguredForX != '\0')) {
      mustshow = '\x01';
      pcVar2 = (char *)gettext("Value accepted!");
      statusline(pcVar2);
    }
    else {
      mustshow = '\x01';
      pcVar2 = (char *)gettext("Value accepted! -- WARNING: Lynx is NOT configured for XWINDOWS!");
      statusline(pcVar2);
    }
  }
  else {
    if (x_display != (char *)0x0) {
      iVar1 = strcmp(x_display,display_option);
      if (iVar1 == 0) goto LAB_0809c891;
    }
    if (*display_option == '\0') {
      mustshow = '\x01';
      pcVar2 = (char *)gettext("Failed to clear DISPLAY variable!");
      statusline(pcVar2);
    }
    else {
      mustshow = '\x01';
      pcVar2 = (char *)gettext("Failed to set DISPLAY variable!");
      statusline(pcVar2);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void SetupChosenShowColor(void)

{
  wchar_t local_10;
  wchar_t local_c;
  wchar_t local_8;
  
  can_do_colors = '\x01';
  if (LYCursesON != '\0') {
    can_do_colors = has_colors();
  }
  if ((no_option_save == '\0') && (LYChosenShowColor == L'\xffffffff')) {
    if (LYrcShowColor == 0) {
      if (LYShowColor < 2) {
        local_10 = L'\0';
      }
      else {
        local_10 = L'\x02';
      }
      LYChosenShowColor = local_10;
    }
    else if (LYrcShowColor == 3) {
      if (can_do_colors == '\0') {
        LYChosenShowColor = L'\x03';
      }
      else {
        if (LYShowColor < 2) {
          local_c = L'\x01';
        }
        else {
          local_c = L'\x03';
        }
        LYChosenShowColor = local_c;
      }
    }
    else {
      if (LYShowColor < 2) {
        local_8 = L'\x01';
      }
      else {
        local_8 = L'\x02';
      }
      LYChosenShowColor = local_8;
    }
  }
  return;
}



// WARNING: Unknown calling convention

wchar_t add_it(char *text,wchar_t len)

{
  size_t len_00;
  
  if (len != L'\0') {
    text[len] = '\0';
    len_00 = strlen(text);
    LYwaddnstr(LYwin,text,len_00);
  }
  return L'\0';
}



void addlbl(char *text)

{
  bool bVar1;
  wchar_t wVar2;
  int in_GS_OFFSET;
  char *text_local;
  wchar_t d;
  wchar_t s;
  BOOLEAN b;
  char actual [80];
  int local_8;
  
  local_8 = *(int *)(in_GS_OFFSET + 0x14);
  bVar1 = false;
  d = L'\0';
  for (s = L'\0'; text[s] != '\0'; s = s + L'\x01') {
    actual[d] = text[s];
    wVar2 = d + L'\x01';
    if (text[s] == '(') {
      wVar2 = add_it(actual,d);
      lynx_start_bold();
      bVar1 = true;
      actual[wVar2] = text[s];
      d = wVar2 + L'\x01';
    }
    else {
      d = wVar2;
      if (text[s] == ')') {
        d = add_it(actual,wVar2);
        lynx_stop_bold();
        bVar1 = false;
      }
    }
  }
  add_it(actual,d);
  if (bVar1) {
    lynx_stop_bold();
  }
  if (local_8 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



// WARNING: Unknown calling convention

void LYoptions(void)

{
  int iVar1;
  bool bVar2;
  bool bVar3;
  char cVar4;
  BOOLEAN BVar5;
  char *pcVar6;
  size_t sVar7;
  int iVar8;
  char **choices_00;
  wchar_t wVar9;
  char *pcVar10;
  ushort **ppuVar11;
  int in_GS_OFFSET;
  char *local_64c;
  char *local_644;
  char *local_640;
  char *local_638;
  char *local_634;
  char *local_62c;
  char *local_628;
  char *local_624;
  char *local_620;
  char *local_61c;
  char *local_614;
  char *local_610;
  wchar_t local_60c;
  char *local_608;
  char *local_600;
  char *local_5fc;
  char *local_5f4;
  char *local_5f0;
  char *local_5e8;
  wchar_t local_5e4;
  char *local_5e0;
  wchar_t local_5dc;
  char *local_5d8;
  wchar_t local_5d0;
  char *local_5cc;
  wchar_t local_5c8;
  char *local_5c4;
  wchar_t local_5c0;
  char *local_5bc;
  wchar_t local_5b8;
  char *local_5b4;
  wchar_t local_5b0;
  char *local_5ac;
  wchar_t local_5a8;
  char *local_5a4;
  char *local_5a0;
  char *local_59c;
  wchar_t local_598;
  wchar_t local_594;
  char *local_590;
  char *local_58c;
  wchar_t local_588;
  char *local_584;
  char *local_580;
  char *local_57c;
  wchar_t local_578;
  char *local_574;
  char *local_56c;
  char *local_568;
  char *local_560;
  char *local_55c;
  char *local_554;
  char *local_550;
  char *local_548;
  char *local_544;
  char *local_53c;
  char *local_538;
  char *local_530;
  char *local_52c;
  char *local_524;
  char *local_520;
  char *local_518;
  wchar_t local_514;
  wchar_t local_510;
  char *local_50c;
  wchar_t local_508;
  wchar_t local_504;
  wchar_t local_500;
  char *local_4fc;
  wchar_t local_4f8;
  char *local_4f4;
  char *local_4ec;
  char *local_4e8;
  char *local_4e0;
  wchar_t local_4dc;
  wchar_t local_4d8;
  wchar_t local_4d4;
  wchar_t local_4d0;
  wchar_t local_4cc;
  wchar_t local_4c8;
  wchar_t local_4c4;
  wchar_t local_4bc;
  wchar_t local_4b8;
  wchar_t local_4b4;
  wchar_t local_4b0;
  wchar_t local_4ac;
  wchar_t local_4a8;
  wchar_t local_4a4;
  wchar_t local_4a0;
  wchar_t local_49c;
  wchar_t local_498;
  wchar_t local_494;
  char *local_490;
  char *local_488;
  char *local_484;
  char *local_47c;
  char *choices [10];
  char *terminal_1;
  wchar_t chosen;
  char *terminal;
  char **assume_list;
  wchar_t curval;
  wchar_t i;
  char *cp;
  wchar_t CurrentShowColor;
  wchar_t CurrentAssumeCharSet;
  wchar_t CurrentCharSet;
  wchar_t ch;
  wchar_t response;
  BOOLEAN again;
  BOOLEAN old_use_assume_charset;
  BOOLEAN use_assume_charset;
  BOOLEAN AddValueAccepted;
  BOOLEAN CurrentRawMode;
  char display_option [1024];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  CurrentCharSet = current_char_set;
  CurrentAssumeCharSet = UCLYhndl_for_unspec;
  CurrentShowColor = LYShowColor;
  CurrentRawMode = LYRawMode;
  bVar2 = false;
  if (LYlines < 0x17) {
    pcVar6 = (char *)gettext("Screen height must be at least 23 lines for the Options menu!");
    HTAlert(pcVar6);
LAB_080a09db:
    if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
      __stack_chk_fail();
    }
    return;
  }
  term_options = '\0';
  LYStatusLine = LYlines + -1;
  signal(2,terminate_options);
  if (no_option_save == '\0') {
    SetupChosenShowColor();
  }
  else if (LYShowColor == 0) {
    LYShowColor = 1;
  }
  else if (LYShowColor == 3) {
    LYShowColor = 2;
  }
  use_assume_charset = user_mode == 2;
draw_options:
  if (enable_scrollback == '\0') {
    LYerase();
  }
  else {
    LYclear();
  }
  LYmove(L'\0',L'\x05');
  lynx_start_h1_color();
  LYwaddnstr(LYwin,"         Options Menu (",0x17);
  LYwaddnstr(LYwin,"Lynx",4);
  LYwaddnstr(LYwin," Version ",9);
  LYwaddnstr(LYwin,"2.8.7dev.11",0xb);
  waddch(LYwin,0x29);
  lynx_stop_h1_color();
  LYmove(L'\x02',L'\x05');
  addlbl("(E)ditor                     : ");
  if ((editor == (char *)0x0) || (*editor == '\0')) {
    local_64c = "NONE";
  }
  else {
    local_64c = editor;
  }
  sVar7 = strlen(local_64c);
  if ((editor == (char *)0x0) || (*editor == '\0')) {
    local_644 = "NONE";
  }
  else {
    local_644 = editor;
  }
  LYwaddnstr(LYwin,local_644,sVar7);
  LYmove(L'\x03',L'\x05');
  addlbl("(D)ISPLAY variable           : ");
  if ((x_display == (char *)0x0) || (*x_display == '\0')) {
    local_640 = "NONE";
  }
  else {
    local_640 = x_display;
  }
  sVar7 = strlen(local_640);
  if ((x_display == (char *)0x0) || (*x_display == '\0')) {
    local_638 = "NONE";
  }
  else {
    local_638 = x_display;
  }
  LYwaddnstr(LYwin,local_638,sVar7);
  LYmove(L'\x04',L'\x05');
  addlbl("mu(L)ti-bookmarks: ");
  sVar7 = strlen(LYoptions::mbm_choices[LYMultiBookmarks]);
  LYwaddnstr(LYwin,LYoptions::mbm_choices[LYMultiBookmarks],sVar7);
  LYmove(L'\x04',L'\"');
  if (LYMultiBookmarks == 0) {
    addlbl("(B)ookmark file: ");
    if ((bookmark_page == (char *)0x0) || (*bookmark_page == '\0')) {
      local_634 = "NONE";
    }
    else {
      local_634 = bookmark_page;
    }
    sVar7 = strlen(local_634);
    if ((bookmark_page == (char *)0x0) || (*bookmark_page == '\0')) {
      local_62c = "NONE";
    }
    else {
      local_62c = bookmark_page;
    }
    LYwaddnstr(LYwin,local_62c,sVar7);
  }
  else {
    addlbl("review/edit (B)ookmarks files");
  }
  LYmove(L'\x05',L'\x05');
  addlbl("(F)TP sort criteria          : ");
  if (HTfileSortMethod == 0) {
    local_628 = "By Filename";
  }
  else {
    if (HTfileSortMethod == 2) {
      local_624 = "By Size    ";
    }
    else {
      if (HTfileSortMethod == 1) {
        local_620 = "By Type    ";
      }
      else {
        local_620 = "By Date    ";
      }
      local_624 = local_620;
    }
    local_628 = local_624;
  }
  LYwaddnstr(LYwin,local_628,0xb);
  LYmove(L'\x06',L'\x05');
  addlbl("(P)ersonal mail address      : ");
  if ((personal_mail_address == (char *)0x0) || (*personal_mail_address == '\0')) {
    local_61c = "NONE";
  }
  else {
    local_61c = personal_mail_address;
  }
  sVar7 = strlen(local_61c);
  if ((personal_mail_address == (char *)0x0) || (*personal_mail_address == '\0')) {
    local_614 = "NONE";
  }
  else {
    local_614 = personal_mail_address;
  }
  LYwaddnstr(LYwin,local_614,sVar7);
  LYmove(L'\a',L'\x05');
  addlbl("(S)earching type             : ");
  if (case_sensitive == '\0') {
    local_610 = "CASE INSENSITIVE";
  }
  else {
    local_610 = "CASE SENSITIVE  ";
  }
  LYwaddnstr(LYwin,local_610,0x10);
  if ((bool)use_assume_charset) {
    local_60c = L'\v';
  }
  else {
    local_60c = L'\n';
  }
  LYmove(local_60c,L'\x05');
  addlbl("display (C)haracter set      : ");
  sVar7 = strlen(LYchar_set_names[current_char_set]);
  LYwaddnstr(LYwin,LYchar_set_names[current_char_set],sVar7);
  LYmove(L'\b',L'\x05');
  addlbl("preferred document lan(G)uage: ");
  if ((language == (char *)0x0) || (*language == '\0')) {
    local_608 = "NONE";
  }
  else {
    local_608 = language;
  }
  sVar7 = strlen(local_608);
  if ((language == (char *)0x0) || (*language == '\0')) {
    local_600 = "NONE";
  }
  else {
    local_600 = language;
  }
  LYwaddnstr(LYwin,local_600,sVar7);
  LYmove(L'\t',L'\x05');
  addlbl("preferred document c(H)arset : ");
  if ((pref_charset == (char *)0x0) || (*pref_charset == '\0')) {
    local_5fc = "NONE";
  }
  else {
    local_5fc = pref_charset;
  }
  sVar7 = strlen(local_5fc);
  if ((pref_charset == (char *)0x0) || (*pref_charset == '\0')) {
    local_5f4 = "NONE";
  }
  else {
    local_5f4 = pref_charset;
  }
  LYwaddnstr(LYwin,local_5f4,sVar7);
  if ((bool)use_assume_charset) {
    LYmove(L'\n',L'\x05');
    addlbl("(^A)ssume charset if unknown : ");
    if (UCAssume_MIMEcharset == (char *)0x0) {
      if (UCLYhndl_for_unspec < 0) {
        local_5f0 = "NONE";
      }
      else {
        local_5f0 = LYCharSet_UC[UCLYhndl_for_unspec].MIMEname;
      }
      sVar7 = strlen(local_5f0);
      if (UCLYhndl_for_unspec < 0) {
        local_5e8 = "NONE";
      }
      else {
        local_5e8 = LYCharSet_UC[UCLYhndl_for_unspec].MIMEname;
      }
      LYwaddnstr(LYwin,local_5e8,sVar7);
    }
    else {
      sVar7 = strlen(UCAssume_MIMEcharset);
      LYwaddnstr(LYwin,UCAssume_MIMEcharset,sVar7);
    }
  }
  if ((bool)use_assume_charset) {
    local_5e4 = L'\f';
  }
  else {
    local_5e4 = L'\v';
  }
  LYmove(local_5e4,L'\x05');
  addlbl("Raw 8-bit or CJK m(O)de      : ");
  if (LYRawMode == '\0') {
    local_5e0 = "OFF";
  }
  else {
    local_5e0 = "ON ";
  }
  LYwaddnstr(LYwin,local_5e0,3);
  if ((bool)use_assume_charset) {
    local_5dc = L'\f';
  }
  else {
    local_5dc = L'\v';
  }
  LYmove(local_5dc,L',');
  addlbl("show color (&)  : ");
  if (no_option_save == '\0') {
    if (LYChosenShowColor == L'\x01') {
      LYwaddnstr(LYwin,"OFF",3);
    }
    else if (LYChosenShowColor < L'\x02') {
      if (LYChosenShowColor == L'\0') {
        LYwaddnstr(LYwin,"NEVER     ",10);
      }
    }
    else if (LYChosenShowColor == L'\x02') {
      LYwaddnstr(LYwin,"ON ",3);
    }
    else if (LYChosenShowColor == L'\x03') {
      cVar4 = has_colors();
      if (cVar4 == '\x01') {
        LYwaddnstr(LYwin,"ALWAYS    ",10);
      }
      else {
        LYwaddnstr(LYwin,"Always try",10);
      }
    }
  }
  else {
    if (LYShowColor == 1) {
      local_5d8 = "ON ";
    }
    else {
      local_5d8 = "OFF";
    }
    LYwaddnstr(LYwin,local_5d8,3);
  }
  if ((bool)use_assume_charset) {
    local_5d0 = L'\r';
  }
  else {
    local_5d0 = L'\f';
  }
  LYmove(local_5d0,L'\x05');
  addlbl("(V)I keys: ");
  if (vi_keys == '\0') {
    local_5cc = "OFF";
  }
  else {
    local_5cc = "ON ";
  }
  LYwaddnstr(LYwin,local_5cc,3);
  if ((bool)use_assume_charset) {
    local_5c8 = L'\r';
  }
  else {
    local_5c8 = L'\f';
  }
  LYmove(local_5c8,L'\x16');
  addlbl("e(M)acs keys: ");
  if (emacs_keys == '\0') {
    local_5c4 = "OFF";
  }
  else {
    local_5c4 = "ON ";
  }
  LYwaddnstr(LYwin,local_5c4,3);
  if ((bool)use_assume_charset) {
    local_5c0 = L'\r';
  }
  else {
    local_5c0 = L'\f';
  }
  LYmove(local_5c0,L',');
  addlbl("sho(W) dot files: ");
  if ((no_dotfiles == '\0') && (show_dotfiles != '\0')) {
    local_5bc = "ON ";
  }
  else {
    local_5bc = "OFF";
  }
  LYwaddnstr(LYwin,local_5bc,3);
  if ((bool)use_assume_charset) {
    local_5b8 = L'\x0e';
  }
  else {
    local_5b8 = L'\r';
  }
  LYmove(local_5b8,L'\x05');
  addlbl("popups for selec(T) fields   : ");
  if (LYSelectPopups == '\0') {
    local_5b4 = "OFF";
  }
  else {
    local_5b4 = "ON ";
  }
  LYwaddnstr(LYwin,local_5b4,3);
  if ((bool)use_assume_charset) {
    local_5b0 = L'\x0e';
  }
  else {
    local_5b0 = L'\r';
  }
  LYmove(local_5b0,L',');
  addlbl("show cursor (@) : ");
  if (LYShowCursor == '\0') {
    local_5ac = "OFF";
  }
  else {
    local_5ac = "ON ";
  }
  LYwaddnstr(LYwin,local_5ac,3);
  if ((bool)use_assume_charset) {
    local_5a8 = L'\x0f';
  }
  else {
    local_5a8 = L'\x0e';
  }
  LYmove(local_5a8,L'\x05');
  addlbl("(K)eypad mode                : ");
  if (((keypad_mode == 3) || (keypad_mode == 2)) && ((keypad_mode == 1 || (keypad_mode == 2)))) {
    local_5a4 = "Links and form fields are numbered";
  }
  else {
    if ((keypad_mode == 1) || (keypad_mode == 2)) {
      local_5a0 = "Links are numbered                ";
    }
    else {
      if ((keypad_mode == 3) || (keypad_mode == 2)) {
        local_59c = "Form fields are numbered          ";
      }
      else {
        local_59c = "Numbers act as arrows             ";
      }
      local_5a0 = local_59c;
    }
    local_5a4 = local_5a0;
  }
  LYwaddnstr(LYwin,local_5a4,0x22);
  if ((bool)use_assume_charset) {
    local_598 = L'\x10';
  }
  else {
    local_598 = L'\x0f';
  }
  LYmove(local_598,L'\x05');
  addlbl("li(N)e edit style            : ");
  sVar7 = strlen(LYLineeditNames[current_lineedit]);
  LYwaddnstr(LYwin,LYLineeditNames[current_lineedit],sVar7);
  if ((bool)use_assume_charset) {
    local_594 = L'\x12';
  }
  else {
    local_594 = L'\x11';
  }
  LYmove(local_594,L'\x05');
  addlbl("l(I)st directory style       : ");
  if (dir_list_style == 1) {
    local_590 = "Files first      ";
  }
  else {
    if (dir_list_style == 2) {
      local_58c = "Mixed style      ";
    }
    else {
      local_58c = "Directories first";
    }
    local_590 = local_58c;
  }
  LYwaddnstr(LYwin,local_590,0x11);
  if ((bool)use_assume_charset) {
    local_588 = L'\x13';
  }
  else {
    local_588 = L'\x12';
  }
  LYmove(local_588,L'\x05');
  addlbl("(U)ser mode                  : ");
  if (user_mode == 0) {
    local_584 = "Novice      ";
  }
  else {
    if (user_mode == 1) {
      local_580 = "Intermediate";
    }
    else {
      local_580 = "Advanced    ";
    }
    local_584 = local_580;
  }
  LYwaddnstr(LYwin,local_584,0xc);
  addlbl("  verbose images (!) : ");
  if (verbose_img == '\0') {
    local_57c = "OFF";
  }
  else {
    local_57c = "ON ";
  }
  LYwaddnstr(LYwin,local_57c,3);
  if ((bool)use_assume_charset) {
    local_578 = L'\x14';
  }
  else {
    local_578 = L'\x13';
  }
  LYmove(local_578,L'\x05');
  addlbl("user (A)gent                 : ");
  if ((LYUserAgent == (char *)0x0) || (*LYUserAgent == '\0')) {
    local_574 = "NONE";
  }
  else {
    local_574 = LYUserAgent;
  }
  sVar7 = strlen(local_574);
  if ((LYUserAgent == (char *)0x0) || (*LYUserAgent == '\0')) {
    local_56c = "NONE";
  }
  else {
    local_56c = LYUserAgent;
  }
  LYwaddnstr(LYwin,local_56c,sVar7);
  LYmove(LYlines + L'\xfffffffd',L'\x02');
  pcVar6 = (char *)gettext("Select ");
  sVar7 = strlen(pcVar6);
  pcVar6 = (char *)gettext("Select ");
  LYwaddnstr(LYwin,pcVar6,sVar7);
  lynx_start_bold();
  pcVar6 = (char *)gettext("capital letter");
  sVar7 = strlen(pcVar6);
  pcVar6 = (char *)gettext("capital letter");
  LYwaddnstr(LYwin,pcVar6,sVar7);
  lynx_stop_bold();
  pcVar6 = (char *)gettext(" of option line,");
  sVar7 = strlen(pcVar6);
  pcVar6 = (char *)gettext(" of option line,");
  LYwaddnstr(LYwin,pcVar6,sVar7);
  if (no_option_save == '\0') {
    LYwaddnstr(LYwin," \'",2);
    lynx_start_bold();
    LYwaddnstr(LYwin,">",1);
    lynx_stop_bold();
    LYwaddnstr(LYwin,"\'",1);
    pcVar6 = (char *)gettext(" to save,");
    sVar7 = strlen(pcVar6);
    pcVar6 = (char *)gettext(" to save,");
    LYwaddnstr(LYwin,pcVar6,sVar7);
  }
  pcVar6 = (char *)gettext(&DAT_08158205);
  sVar7 = strlen(pcVar6);
  pcVar6 = (char *)gettext(&DAT_08158205);
  LYwaddnstr(LYwin,pcVar6,sVar7);
  LYwaddnstr(LYwin,"\'",1);
  lynx_start_bold();
  LYwaddnstr(LYwin,"r",1);
  lynx_stop_bold();
  LYwaddnstr(LYwin,"\'",1);
  pcVar6 = (char *)gettext(" to return to Lynx.");
  sVar7 = strlen(pcVar6);
  pcVar6 = (char *)gettext(" to return to Lynx.");
  LYwaddnstr(LYwin,pcVar6,sVar7);
  response = L'\0';
switchD_0809e032_caseD_52:
  if ((((response == L'R') || (BVar5 = LYisNonAlnumKeyname(response,0x25), BVar5 != '\0')) ||
      (response == L'>')) || (term_options != '\0')) {
LAB_080a09b6:
    term_options = '\0';
    LYStatusLine = -1;
    signal(2,cleanup_sig);
    goto LAB_080a09db;
  }
  if ((response == L'\x03') || (response == L'\a')) {
LAB_080a0991:
    ppuVar11 = __ctype_b_loc();
    if (((*ppuVar11)[response] & 0x4000) == 0) goto LAB_080a09b6;
  }
  else {
    if (response == L'\xffffffff') {
      if (keymap[0] != 0x2f) goto LAB_0809debc;
      goto LAB_080a0991;
    }
    if ((response & 0x8800U) == 0) {
      if (keymap[(response & 0x7ffU) + 1] == 0x2f) goto LAB_080a0991;
    }
    else if ((response & 0xffU) == 0x2f) goto LAB_080a0991;
  }
LAB_0809debc:
  if (bVar2) {
    mustshow = '\x01';
    pcVar6 = (char *)gettext("Value accepted!");
    statusline(pcVar6);
    bVar2 = false;
  }
  LYmove(LYlines + L'\xfffffffe',L'\0');
  lynx_start_prompt_color();
  pcVar6 = (char *)gettext("Command: ");
  sVar7 = strlen(pcVar6);
  pcVar6 = (char *)gettext("Command: ");
  LYwaddnstr(LYwin,pcVar6,sVar7);
  lynx_stop_prompt_color();
  LYrefresh();
  response = LYgetch_single();
  if (term_options == '\0') {
    if ((response == L'\x03') || (response == L'\a')) {
LAB_0809dfc7:
      ppuVar11 = __ctype_b_loc();
      if (((*ppuVar11)[response] & 0x4000) == 0) goto LAB_0809dfe8;
    }
    else {
      if (response == L'\xffffffff') {
        if (keymap[0] != 0x2f) goto LAB_0809dff2;
        goto LAB_0809dfc7;
      }
      if ((response & 0x8800U) == 0) {
        if (keymap[(response & 0x7ffU) + 1] == 0x2f) goto LAB_0809dfc7;
      }
      else if ((response & 0xffU) == 0x2f) goto LAB_0809dfc7;
    }
  }
  else {
LAB_0809dfe8:
    response = L'R';
  }
LAB_0809dff2:
  BVar5 = LYisNonAlnumKeyname(response,0x15);
  if (BVar5 != '\0') {
    lynx_force_repaint();
    goto draw_options;
  }
  switch(response) {
  default:
    if (no_option_save == '\0') {
      pcVar6 = (char *)gettext(" \'>\' to save, or \'r\' to return to Lynx ");
      HTInfoMsg(pcVar6);
    }
    else {
      pcVar6 = (char *)gettext(" \'r\' to return to Lynx ");
      HTInfoMsg(pcVar6);
    }
    goto switchD_0809e032_caseD_52;
  case L'\x01':
    if ((bool)use_assume_charset) {
      choices_00 = (char **)calloc(LYNumCharsets + 1,4);
      if (choices_00 == (char **)0x0) {
        outofmem("./LYOptions.c","options");
      }
      for (i = L'\0'; i < LYNumCharsets; i = i + L'\x01') {
        choices_00[i] = LYCharSet_UC[i].MIMEname;
      }
      curval = UCLYhndl_for_unspec;
      if ((UCLYhndl_for_unspec == current_char_set) && (UCAssume_MIMEcharset != (char *)0x0)) {
        curval = UCGetLYhndl_byMIME(UCAssume_MIMEcharset);
      }
      if (curval < L'\0') {
        if (LYRawMode == '\0') {
          local_514 = L'\0';
        }
        else {
          local_514 = current_char_set;
        }
        curval = local_514;
      }
      if (LYSelectPopups == '\0') {
        UCLYhndl_for_unspec = boolean_choice(curval,L'\n',L'\xffffffff',choices_00);
      }
      else {
        UCLYhndl_for_unspec = popup_choice(curval,L'\n',L'\xffffffff',choices_00,L'\0',L'\0','\0');
      }
      if ((CurrentAssumeCharSet != UCLYhndl_for_unspec) || (UCLYhndl_for_unspec != curval)) {
        if (UCLYhndl_for_unspec != CurrentAssumeCharSet) {
          HTSACopy(&UCAssume_MIMEcharset,LYCharSet_UC[UCLYhndl_for_unspec].MIMEname);
        }
        if (HTCJK != JAPANESE) {
          LYRawMode = UCLYhndl_for_unspec == current_char_set;
        }
        HTMLSetUseDefaultRawMode(current_char_set,LYRawMode);
        HTMLSetCharacterHandling(current_char_set);
        CurrentAssumeCharSet = UCLYhndl_for_unspec;
        CurrentRawMode = LYRawMode;
        if (LYSelectPopups == '\0') {
          if ((bool)use_assume_charset) {
            local_510 = L'\f';
          }
          else {
            local_510 = L'\v';
          }
          LYmove(local_510,L'$');
          LYclrtoeol();
          if (LYRawMode == '\0') {
            local_50c = "OFF";
          }
          else {
            local_50c = "ON ";
          }
          LYwaddnstr(LYwin,local_50c,3);
        }
      }
      if (choices_00 != (char **)0x0) {
        free(choices_00);
      }
      response = L' ';
      if (LYSelectPopups != '\0') {
        if (term_options == '\0') {
          bVar2 = true;
        }
        else {
          term_options = '\0';
        }
        goto draw_options;
      }
    }
    else {
      mustshow = '\x01';
      pcVar6 = (char *)gettext("That key requires Advanced User mode.");
      statusline(pcVar6);
      bVar2 = false;
    }
    goto switchD_0809e032_caseD_52;
  case L'!':
    if (LYSelectPopups == '\0') {
      wVar9 = boolean_choice((int)verbose_img,L'\x12',L'G',LYoptions::bool_choices);
      verbose_img = (BOOLEAN)wVar9;
    }
    else {
      wVar9 = popup_choice((int)verbose_img,L'\x12',L'G',LYoptions::bool_choices,L'\x02',L'\0','\0')
      ;
      verbose_img = (BOOLEAN)wVar9;
    }
    response = L' ';
    if (LYSelectPopups != '\0') {
      if (term_options == '\0') {
        bVar2 = true;
      }
      else {
        term_options = '\0';
      }
      goto draw_options;
    }
    goto switchD_0809e032_caseD_52;
  case L'&':
    if (no_option_save == '\0') {
      choices[0] = (char *)0x0;
      HTSACopy(choices,"NEVER     ");
      choices[1] = (char *)0x0;
      HTSACopy(choices + 1,"OFF       ");
      choices[2] = (char *)0x0;
      HTSACopy(choices + 2,"ON        ");
      choices[3] = (char *)0x0;
      cVar4 = has_colors();
      if (cVar4 == '\x01') {
        HTSACopy(choices + 3,"ALWAYS    ");
      }
      else {
        HTSACopy(choices + 3,"Always try");
      }
      choices[4] = (char *)0x0;
      do {
        if (LYSelectPopups == '\0') {
          if ((bool)use_assume_charset) {
            local_4c8 = L'\f';
          }
          else {
            local_4c8 = L'\v';
          }
          chosen = boolean_choice(LYChosenShowColor,local_4c8,L'>',choices);
        }
        else {
          if ((bool)use_assume_charset) {
            local_4c4 = L'\f';
          }
          else {
            local_4c4 = L'\v';
          }
          chosen = popup_choice(LYChosenShowColor,local_4c4,L'>',choices,L'\x04',L'\0','\0');
        }
        if ((chosen == L'\x02') && (cVar4 = has_colors(), cVar4 == '\0')) {
          bVar3 = true;
        }
        else {
          bVar3 = false;
        }
        if (bVar3) {
          pcVar6 = LYGetEnv("TERM");
          if (pcVar6 == (char *)0x0) {
            pcVar6 = (char *)gettext("Terminal does not support color");
            HTUserMsg(pcVar6);
          }
          else {
            pcVar10 = (char *)gettext("Your \'%s\' terminal does not support color.");
            HTUserMsg2(pcVar10,pcVar6);
          }
        }
      } while (bVar3);
      LYChosenShowColor = chosen;
      cVar4 = has_colors();
      if (cVar4 != '\0') {
        LYShowColor = chosen;
      }
      if (choices[0] != (char *)0x0) {
        free(choices[0]);
        choices[0] = (char *)0x0;
      }
      if (choices[1] != (char *)0x0) {
        free(choices[1]);
        choices[1] = (char *)0x0;
      }
      if (choices[2] != (char *)0x0) {
        free(choices[2]);
        choices[2] = (char *)0x0;
      }
      if (choices[3] != (char *)0x0) {
        free(choices[3]);
        choices[3] = (char *)0x0;
      }
    }
    else {
      cVar4 = has_colors();
      if (cVar4 != '\x01') {
        pcVar6 = LYGetEnv("TERM");
        if (pcVar6 == (char *)0x0) {
          pcVar6 = (char *)gettext("Terminal does not support color");
          HTUserMsg(pcVar6);
        }
        else {
          pcVar10 = (char *)gettext("Your \'%s\' terminal does not support color.");
          HTUserMsg2(pcVar10,pcVar6);
        }
        goto switchD_0809e032_caseD_52;
      }
      if ((bool)use_assume_charset) {
        local_4cc = L'\f';
      }
      else {
        local_4cc = L'\v';
      }
      wVar9 = boolean_choice(LYShowColor + L'\xffffffff',local_4cc,L'>',LYoptions::bool_choices);
      if (wVar9 == L'\0') {
        LYShowColor = 1;
      }
      else {
        LYShowColor = 2;
      }
    }
    if (CurrentShowColor != LYShowColor) {
      lynx_force_repaint();
    }
    CurrentShowColor = LYShowColor;
    response = L' ';
    if ((LYSelectPopups != '\0') && (no_option_save == '\0')) {
      if (term_options == '\0') {
        bVar2 = true;
      }
      else {
        term_options = '\0';
      }
      goto draw_options;
    }
    goto switchD_0809e032_caseD_52;
  case L'>':
    if (no_option_save == '\0') {
      pcVar6 = (char *)gettext("Saving Options...");
      HTInfoMsg(pcVar6);
      LYrcShowColor = LYChosenShowColor;
      iVar8 = save_rc((FILE *)0x0);
      if (iVar8 == 0) {
        pcVar6 = (char *)gettext("Unable to save Options!");
        HTAlert(pcVar6);
      }
      else {
        pcVar6 = (char *)gettext("Options saved!");
        HTInfoMsg(pcVar6);
      }
    }
    else {
      pcVar6 = (char *)gettext(" \'r\' to return to Lynx ");
      HTInfoMsg(pcVar6);
      response = L' ';
    }
    goto switchD_0809e032_caseD_52;
  case L'@':
    if ((bool)use_assume_charset) {
      local_4bc = L'\x0e';
    }
    else {
      local_4bc = L'\r';
    }
    wVar9 = boolean_choice((int)LYShowCursor,local_4bc,L'>',LYoptions::bool_choices);
    LYShowCursor = (BOOLEAN)wVar9;
    response = L' ';
    goto switchD_0809e032_caseD_52;
  case L'A':
    if (no_useragent == '\0') {
      if ((LYUserAgent == (char *)0x0) || (*LYUserAgent == '\0')) {
        LYmove(L'\x04',L'$');
        LYwaddnstr(LYwin,"    ",4);
        display_option[0] = '\0';
      }
      else {
        LYstrncpy(display_option,LYUserAgent,L'');
      }
      mustshow = '\x01';
      pcVar6 = (char *)gettext(
                              "Hit RETURN to accept entered data.  Delete data to invoke the default."
                              );
      statusline(pcVar6);
      if ((bool)use_assume_charset) {
        local_498 = L'\x14';
      }
      else {
        local_498 = L'\x13';
      }
      LYmove(local_498,L'$');
      lynx_start_bold();
      wVar9 = LYgetstr(display_option,L'\0',0x400,NORECALL);
      lynx_stop_bold();
      if ((bool)use_assume_charset) {
        local_494 = L'\x14';
      }
      else {
        local_494 = L'\x13';
      }
      LYmove(local_494,L'$');
      if ((term_options == '\0') && (wVar9 != L'\xffffffff')) {
        if (display_option[0] == '\0') {
          HTSACopy(&LYUserAgent,LYUserAgentDefault);
          if ((LYUserAgent == (char *)0x0) || (*LYUserAgent == '\0')) {
            local_484 = "NONE";
          }
          else {
            local_484 = LYUserAgent;
          }
          sVar7 = strlen(local_484);
          if ((LYUserAgent == (char *)0x0) || (*LYUserAgent == '\0')) {
            local_47c = "NONE";
          }
          else {
            local_47c = LYUserAgent;
          }
          LYwaddnstr(LYwin,local_47c,sVar7);
        }
        else {
          HTSACopy(&LYUserAgent,display_option);
          sVar7 = strlen(display_option);
          LYwaddnstr(LYwin,display_option,sVar7);
        }
      }
      else {
        if ((LYUserAgent == (char *)0x0) || (*LYUserAgent == '\0')) {
          local_490 = "NONE";
        }
        else {
          local_490 = LYUserAgent;
        }
        sVar7 = strlen(local_490);
        if ((LYUserAgent == (char *)0x0) || (*LYUserAgent == '\0')) {
          local_488 = "NONE";
        }
        else {
          local_488 = LYUserAgent;
        }
        LYwaddnstr(LYwin,local_488,sVar7);
      }
      LYclrtoeol();
      if (wVar9 == L'\xffffffff') {
        pcVar6 = (char *)gettext("Cancelled!!!");
        HTInfoMsg(pcVar6);
        HTInfoMsg("");
      }
      else {
        BVar5 = LYCheckUserAgent();
        if (BVar5 == '\0') {
          mustshow = '\x01';
          pcVar6 = (char *)gettext(
                                  "Use \"L_y_n_x\" or \"Lynx\" in User-Agent, or it looks like intentional deception!"
                                  );
          statusline(pcVar6);
        }
        else {
          mustshow = '\x01';
          pcVar6 = (char *)gettext("Value accepted!");
          statusline(pcVar6);
        }
      }
    }
    else {
      mustshow = '\x01';
      pcVar6 = (char *)gettext("Changing of the User-Agent string is disabled!");
      statusline(pcVar6);
    }
    response = L' ';
    goto switchD_0809e032_caseD_52;
  case L'B':
    if (no_bookmark == '\0') {
      if (LYMultiBookmarks != 0) {
        edit_bookmarks();
        signal(2,terminate_options);
        goto draw_options;
      }
      if ((bookmark_page == (char *)0x0) || (*bookmark_page == '\0')) {
        LYmove(L'\x04',L'2');
        LYclrtoeol();
        display_option[0] = '\0';
      }
      else {
        LYstrncpy(display_option,bookmark_page,L'');
      }
      mustshow = '\x01';
      pcVar6 = (char *)gettext("Hit RETURN to accept entered data.");
      statusline(pcVar6);
      LYmove(L'\x04',L'2');
      lynx_start_bold();
      wVar9 = LYgetstr(display_option,L'\0',0x400,NORECALL);
      lynx_stop_bold();
      LYmove(L'\x04',L'2');
      if (((term_options == '\0') && (wVar9 != L'\xffffffff')) && (display_option[0] != '\0')) {
        BVar5 = LYPathOffHomeOK(display_option,0x400);
        if (BVar5 == '\0') {
          if ((bookmark_page == (char *)0x0) || (*bookmark_page == '\0')) {
            local_52c = "NONE";
          }
          else {
            local_52c = bookmark_page;
          }
          sVar7 = strlen(local_52c);
          if ((bookmark_page == (char *)0x0) || (*bookmark_page == '\0')) {
            local_524 = "NONE";
          }
          else {
            local_524 = bookmark_page;
          }
          LYwaddnstr(LYwin,local_524,sVar7);
          LYclrtoeol();
          mustshow = '\x01';
          pcVar6 = (char *)gettext("Use a filepath off your home directory!");
          statusline(pcVar6);
          response = L' ';
          goto switchD_0809e032_caseD_52;
        }
        HTSACopy(&bookmark_page,display_option);
        HTSACopy(MBM_A_subbookmark,bookmark_page);
        sVar7 = strlen(bookmark_page);
        LYwaddnstr(LYwin,bookmark_page,sVar7);
      }
      else {
        if ((bookmark_page == (char *)0x0) || (*bookmark_page == '\0')) {
          local_538 = "NONE";
        }
        else {
          local_538 = bookmark_page;
        }
        sVar7 = strlen(local_538);
        if ((bookmark_page == (char *)0x0) || (*bookmark_page == '\0')) {
          local_530 = "NONE";
        }
        else {
          local_530 = bookmark_page;
        }
        LYwaddnstr(LYwin,local_530,sVar7);
      }
      LYclrtoeol();
      if (wVar9 == L'\xffffffff') {
        pcVar6 = (char *)gettext("Cancelled!!!");
        HTInfoMsg(pcVar6);
        HTInfoMsg("");
      }
      else {
        mustshow = '\x01';
        pcVar6 = (char *)gettext("Value accepted!");
        statusline(pcVar6);
      }
    }
    else {
      mustshow = '\x01';
      pcVar6 = (char *)gettext("You are not allowed to change the bookmark file!");
      statusline(pcVar6);
    }
    response = L' ';
    goto switchD_0809e032_caseD_52;
  case L'C':
    if (LYSelectPopups == '\0') {
      if ((bool)use_assume_charset) {
        local_508 = L'\v';
      }
      else {
        local_508 = L'\n';
      }
      current_char_set = boolean_choice(current_char_set,local_508,L'\xffffffff',LYchar_set_names);
    }
    else {
      if ((bool)use_assume_charset) {
        local_504 = L'\v';
      }
      else {
        local_504 = L'\n';
      }
      current_char_set =
           popup_choice(current_char_set,local_504,L'\xffffffff',LYchar_set_names,L'\0',L'\0','\0');
    }
    if (CurrentCharSet != current_char_set) {
      LYUseDefaultRawMode = '\x01';
      HTMLUseCharacterSet(current_char_set);
      CurrentCharSet = current_char_set;
      CurrentRawMode = LYRawMode;
      if (LYSelectPopups == '\0') {
        if ((bool)use_assume_charset) {
          local_500 = L'\f';
        }
        else {
          local_500 = L'\v';
        }
        LYmove(local_500,L'$');
        LYclrtoeol();
        if (LYRawMode == '\0') {
          local_4fc = "OFF";
        }
        else {
          local_4fc = "ON ";
        }
        LYwaddnstr(LYwin,local_4fc,3);
      }
    }
    response = L' ';
    if (LYSelectPopups != '\0') {
      if (term_options == '\0') {
        bVar2 = true;
      }
      else {
        term_options = '\0';
      }
      goto draw_options;
    }
    goto switchD_0809e032_caseD_52;
  case L'D':
    if ((x_display == (char *)0x0) || (*x_display == '\0')) {
      LYmove(L'\x03',L'$');
      LYwaddnstr(LYwin,"    ",4);
      display_option[0] = '\0';
    }
    else {
      LYstrncpy(display_option,x_display,L'');
    }
    mustshow = '\x01';
    pcVar6 = (char *)gettext("Hit RETURN to accept entered data.");
    statusline(pcVar6);
    LYmove(L'\x03',L'$');
    lynx_start_bold();
    wVar9 = LYgetstr(display_option,L'\0',0x400,NORECALL);
    lynx_stop_bold();
    LYmove(L'\x03',L'$');
    if (((term_options == '\0') && (wVar9 != L'\xffffffff')) &&
       ((x_display == (char *)0x0 || (iVar8 = strcmp(x_display,display_option), iVar8 != 0)))) {
      if ((display_option[0] == '\0') &&
         ((x_display == (char *)0x0 || ((x_display != (char *)0x0 && (*x_display == '\0')))))) {
        LYwaddnstr(LYwin,"NONE",4);
        LYclrtoeol();
        mustshow = '\x01';
        pcVar6 = (char *)gettext("Value accepted!");
        statusline(pcVar6);
        response = L' ';
      }
      else {
        LYsetXDisplay(display_option);
        validate_x_display();
        if (x_display == (char *)0x0) {
          local_550 = "NONE";
        }
        else {
          local_550 = x_display;
        }
        sVar7 = strlen(local_550);
        if (x_display == (char *)0x0) {
          local_548 = "NONE";
        }
        else {
          local_548 = x_display;
        }
        LYwaddnstr(LYwin,local_548,sVar7);
        LYclrtoeol();
        summarize_x_display(display_option);
        response = L' ';
      }
    }
    else {
      if ((x_display == (char *)0x0) || (*x_display == '\0')) {
        local_55c = "NONE";
      }
      else {
        local_55c = x_display;
      }
      sVar7 = strlen(local_55c);
      if ((x_display == (char *)0x0) || (*x_display == '\0')) {
        local_554 = "NONE";
      }
      else {
        local_554 = x_display;
      }
      LYwaddnstr(LYwin,local_554,sVar7);
      LYclrtoeol();
      if (wVar9 == L'\xffffffff') {
        pcVar6 = (char *)gettext("Cancelled!!!");
        HTInfoMsg(pcVar6);
        HTInfoMsg("");
      }
      else {
        mustshow = '\x01';
        pcVar6 = (char *)gettext("Value accepted!");
        statusline(pcVar6);
      }
      response = L' ';
    }
    goto switchD_0809e032_caseD_52;
  case L'E':
    if (no_editor == '\0') {
      if (system_editor == '\0') {
        if ((editor == (char *)0x0) || (*editor == '\0')) {
          LYmove(L'\x02',L'$');
          LYwaddnstr(LYwin,"    ",4);
          display_option[0] = '\0';
        }
        else {
          LYstrncpy(display_option,editor,L'');
        }
        mustshow = '\x01';
        pcVar6 = (char *)gettext("Hit RETURN to accept entered data.");
        statusline(pcVar6);
        LYmove(L'\x02',L'$');
        lynx_start_bold();
        wVar9 = LYgetstr(display_option,L'\0',0x400,NORECALL);
        lynx_stop_bold();
        LYmove(L'\x02',L'$');
        if ((term_options == '\0') && (wVar9 != L'\xffffffff')) {
          if (display_option[0] == '\0') {
            if (editor != (char *)0x0) {
              free(editor);
              editor = (char *)0x0;
            }
            LYwaddnstr(LYwin,"NONE",4);
          }
          else {
            HTSACopy(&editor,display_option);
            sVar7 = strlen(display_option);
            LYwaddnstr(LYwin,display_option,sVar7);
          }
        }
        else {
          if ((editor == (char *)0x0) || (*editor == '\0')) {
            local_568 = "NONE";
          }
          else {
            local_568 = editor;
          }
          sVar7 = strlen(local_568);
          if ((editor == (char *)0x0) || (*editor == '\0')) {
            local_560 = "NONE";
          }
          else {
            local_560 = editor;
          }
          LYwaddnstr(LYwin,local_560,sVar7);
        }
        LYclrtoeol();
        if (wVar9 == L'\xffffffff') {
          pcVar6 = (char *)gettext("Cancelled!!!");
          HTInfoMsg(pcVar6);
          HTInfoMsg("");
        }
        else {
          mustshow = '\x01';
          pcVar6 = (char *)gettext("Value accepted!");
          statusline(pcVar6);
        }
      }
      else {
        mustshow = '\x01';
        pcVar6 = (char *)gettext("You are not allowed to change which editor to use!");
        statusline(pcVar6);
      }
    }
    else {
      mustshow = '\x01';
      pcVar6 = (char *)gettext("The \'e\'dit command is currently disabled.");
      statusline(pcVar6);
    }
    response = L' ';
    goto switchD_0809e032_caseD_52;
  case L'F':
    if (LYSelectPopups == '\0') {
      HTfileSortMethod =
           boolean_choice(HTfileSortMethod,L'\x05',L'\xffffffff',LYoptions::fileSort_choices);
    }
    else {
      HTfileSortMethod =
           popup_choice(HTfileSortMethod,L'\x05',L'\xffffffff',LYoptions::fileSort_choices,L'\x04',
                        L'\0','\0');
    }
    response = L' ';
    if (LYSelectPopups != '\0') {
      if (term_options == '\0') {
        bVar2 = true;
      }
      else {
        term_options = '\0';
      }
      goto draw_options;
    }
    goto switchD_0809e032_caseD_52;
  case L'G':
    if ((language == (char *)0x0) || (*language == '\0')) {
      LYmove(L'\b',L'$');
      LYwaddnstr(LYwin,"    ",4);
      display_option[0] = '\0';
    }
    else {
      LYstrncpy(display_option,language,L'');
    }
    mustshow = '\x01';
    pcVar6 = (char *)gettext("Hit RETURN to accept entered data.");
    statusline(pcVar6);
    LYmove(L'\b',L'$');
    lynx_start_bold();
    wVar9 = LYgetstr(display_option,L'\0',0x400,NORECALL);
    lynx_stop_bold();
    LYmove(L'\b',L'$');
    if ((term_options == '\0') && (wVar9 != L'\xffffffff')) {
      if (display_option[0] == '\0') {
        if (language != (char *)0x0) {
          free(language);
          language = (char *)0x0;
        }
        LYwaddnstr(LYwin,"NONE",4);
      }
      else {
        HTSACopy(&language,display_option);
        sVar7 = strlen(display_option);
        LYwaddnstr(LYwin,display_option,sVar7);
      }
    }
    else {
      if ((language == (char *)0x0) || (*language == '\0')) {
        local_4f4 = "NONE";
      }
      else {
        local_4f4 = language;
      }
      sVar7 = strlen(local_4f4);
      if ((language == (char *)0x0) || (*language == '\0')) {
        local_4ec = "NONE";
      }
      else {
        local_4ec = language;
      }
      LYwaddnstr(LYwin,local_4ec,sVar7);
    }
    LYclrtoeol();
    if (wVar9 == L'\xffffffff') {
      pcVar6 = (char *)gettext("Cancelled!!!");
      HTInfoMsg(pcVar6);
      HTInfoMsg("");
    }
    else {
      mustshow = '\x01';
      pcVar6 = (char *)gettext("Value accepted!");
      statusline(pcVar6);
    }
    response = L' ';
    goto switchD_0809e032_caseD_52;
  case L'H':
    if ((pref_charset == (char *)0x0) || (*pref_charset == '\0')) {
      LYmove(L'\t',L'$');
      LYwaddnstr(LYwin,"    ",4);
      display_option[0] = '\0';
    }
    else {
      LYstrncpy(display_option,pref_charset,L'');
    }
    mustshow = '\x01';
    pcVar6 = (char *)gettext("Hit RETURN to accept entered data.");
    statusline(pcVar6);
    LYmove(L'\t',L'$');
    lynx_start_bold();
    wVar9 = LYgetstr(display_option,L'\0',0x400,NORECALL);
    lynx_stop_bold();
    LYmove(L'\t',L'$');
    if ((term_options == '\0') && (wVar9 != L'\xffffffff')) {
      if (display_option[0] == '\0') {
        if (pref_charset != (char *)0x0) {
          free(pref_charset);
          pref_charset = (char *)0x0;
        }
        LYwaddnstr(LYwin,"NONE",4);
      }
      else {
        HTSACopy(&pref_charset,display_option);
        sVar7 = strlen(display_option);
        LYwaddnstr(LYwin,display_option,sVar7);
      }
    }
    else {
      if ((pref_charset == (char *)0x0) || (*pref_charset == '\0')) {
        local_4e8 = "NONE";
      }
      else {
        local_4e8 = pref_charset;
      }
      sVar7 = strlen(local_4e8);
      if ((pref_charset == (char *)0x0) || (*pref_charset == '\0')) {
        local_4e0 = "NONE";
      }
      else {
        local_4e0 = pref_charset;
      }
      LYwaddnstr(LYwin,local_4e0,sVar7);
    }
    LYclrtoeol();
    if (wVar9 == L'\xffffffff') {
      pcVar6 = (char *)gettext("Cancelled!!!");
      HTInfoMsg(pcVar6);
      HTInfoMsg("");
    }
    else {
      mustshow = '\x01';
      pcVar6 = (char *)gettext("Value accepted!");
      statusline(pcVar6);
    }
    response = L' ';
    goto switchD_0809e032_caseD_52;
  case L'I':
    if (LYSelectPopups == '\0') {
      if ((bool)use_assume_charset) {
        local_4a8 = L'\x12';
      }
      else {
        local_4a8 = L'\x11';
      }
      dir_list_style =
           boolean_choice(dir_list_style,local_4a8,L'\xffffffff',LYoptions::dirList_choices);
    }
    else {
      if ((bool)use_assume_charset) {
        local_4a4 = L'\x12';
      }
      else {
        local_4a4 = L'\x11';
      }
      dir_list_style =
           popup_choice(dir_list_style,local_4a4,L'\xffffffff',LYoptions::dirList_choices,L'\x03',
                        L'\0','\0');
    }
    response = L' ';
    if (LYSelectPopups != '\0') {
      if (term_options == '\0') {
        bVar2 = true;
      }
      else {
        term_options = '\0';
      }
      goto draw_options;
    }
    goto switchD_0809e032_caseD_52;
  case L'K':
    if (LYSelectPopups == '\0') {
      if ((bool)use_assume_charset) {
        local_4b8 = L'\x0f';
      }
      else {
        local_4b8 = L'\x0e';
      }
      keypad_mode = boolean_choice(keypad_mode,local_4b8,L'\xffffffff',LYoptions::keypad_choices);
    }
    else {
      if ((bool)use_assume_charset) {
        local_4b4 = L'\x0f';
      }
      else {
        local_4b4 = L'\x0e';
      }
      keypad_mode = popup_choice(keypad_mode,local_4b4,L'\xffffffff',LYoptions::keypad_choices,
                                 L'\x03',L'\0','\0');
    }
    if (keypad_mode == 0) {
      set_numbers_as_arrows();
    }
    else {
      reset_numbers_as_arrows();
    }
    response = L' ';
    if (LYSelectPopups != '\0') {
      if (term_options == '\0') {
        bVar2 = true;
      }
      else {
        term_options = '\0';
      }
      goto draw_options;
    }
    goto switchD_0809e032_caseD_52;
  case L'L':
    if (LYMBMBlocked == '\0') {
      if (LYSelectPopups == '\0') {
        LYMultiBookmarks = boolean_choice(LYMultiBookmarks,L'\x04',L'\x18',LYoptions::mbm_choices);
      }
      else {
        LYMultiBookmarks =
             popup_choice(LYMultiBookmarks,L'\x04',L'\x17',LYoptions::mbm_choices,L'\x03',L'\0','\0'
                         );
      }
      if (LYSelectPopups == '\0') {
        LYmove(L'\x04',L'\"');
        LYclrtoeol();
        if (LYMultiBookmarks == 0) {
          pcVar6 = (char *)gettext("B)ookmark file: ");
          sVar7 = strlen(pcVar6);
          pcVar6 = (char *)gettext("B)ookmark file: ");
          LYwaddnstr(LYwin,pcVar6,sVar7);
          if ((bookmark_page == (char *)0x0) || (*bookmark_page == '\0')) {
            local_544 = "NONE";
          }
          else {
            local_544 = bookmark_page;
          }
          sVar7 = strlen(local_544);
          if ((bookmark_page == (char *)0x0) || (*bookmark_page == '\0')) {
            local_53c = "NONE";
          }
          else {
            local_53c = bookmark_page;
          }
          LYwaddnstr(LYwin,local_53c,sVar7);
        }
        else {
          pcVar6 = (char *)gettext("review/edit B)ookmarks files");
          sVar7 = strlen(pcVar6);
          pcVar6 = (char *)gettext("review/edit B)ookmarks files");
          LYwaddnstr(LYwin,pcVar6,sVar7);
        }
      }
      response = L' ';
      if (LYSelectPopups != '\0') {
        if (term_options == '\0') {
          bVar2 = true;
        }
        else {
          term_options = '\0';
        }
        goto draw_options;
      }
    }
    else {
      mustshow = '\x01';
      pcVar6 = (char *)gettext("Multiple bookmark support is not available.");
      statusline(pcVar6);
      response = L' ';
    }
    goto switchD_0809e032_caseD_52;
  case L'M':
    if ((bool)use_assume_charset) {
      local_4d8 = L'\r';
    }
    else {
      local_4d8 = L'\f';
    }
    wVar9 = boolean_choice((int)emacs_keys,local_4d8,L'$',LYoptions::bool_choices);
    emacs_keys = (BOOLEAN)wVar9;
    if (emacs_keys == '\0') {
      reset_emacs_keys();
    }
    else {
      set_emacs_keys();
    }
    response = L' ';
    goto switchD_0809e032_caseD_52;
  case L'N':
    if (LYSelectPopups == '\0') {
      if ((bool)use_assume_charset) {
        local_4b0 = L'\x10';
      }
      else {
        local_4b0 = L'\x0f';
      }
      current_lineedit = boolean_choice(current_lineedit,local_4b0,L'\xffffffff',LYLineeditNames);
    }
    else {
      if ((bool)use_assume_charset) {
        local_4ac = L'\x10';
      }
      else {
        local_4ac = L'\x0f';
      }
      current_lineedit =
           popup_choice(current_lineedit,local_4ac,L'\xffffffff',LYLineeditNames,L'\0',L'\0','\0');
    }
    response = L' ';
    if (LYSelectPopups != '\0') {
      if (term_options == '\0') {
        bVar2 = true;
      }
      else {
        term_options = '\0';
      }
      goto draw_options;
    }
    goto switchD_0809e032_caseD_52;
  case L'O':
    if ((bool)use_assume_charset) {
      local_4f8 = L'\f';
    }
    else {
      local_4f8 = L'\v';
    }
    wVar9 = boolean_choice((int)LYRawMode,local_4f8,L'\xffffffff',LYoptions::bool_choices);
    LYRawMode = (BOOLEAN)wVar9;
    if (CurrentRawMode != LYRawMode) {
      HTMLSetUseDefaultRawMode(current_char_set,LYRawMode);
      HTMLSetCharacterHandling(current_char_set);
      CurrentRawMode = LYRawMode;
    }
    response = L' ';
    goto switchD_0809e032_caseD_52;
  case L'P':
    if ((personal_mail_address == (char *)0x0) || (*personal_mail_address == '\0')) {
      LYmove(L'\x06',L'$');
      LYwaddnstr(LYwin,"    ",4);
      display_option[0] = '\0';
    }
    else {
      LYstrncpy(display_option,personal_mail_address,L'');
    }
    mustshow = '\x01';
    pcVar6 = (char *)gettext("Hit RETURN to accept entered data.");
    statusline(pcVar6);
    LYmove(L'\x06',L'$');
    lynx_start_bold();
    wVar9 = LYgetstr(display_option,L'\0',0x400,NORECALL);
    lynx_stop_bold();
    LYmove(L'\x06',L'$');
    if ((term_options == '\0') && (wVar9 != L'\xffffffff')) {
      if (display_option[0] == '\0') {
        if (personal_mail_address != (char *)0x0) {
          free(personal_mail_address);
          personal_mail_address = (char *)0x0;
        }
        LYwaddnstr(LYwin,"NONE",4);
      }
      else {
        HTSACopy(&personal_mail_address,display_option);
        sVar7 = strlen(display_option);
        LYwaddnstr(LYwin,display_option,sVar7);
      }
    }
    else {
      if ((personal_mail_address == (char *)0x0) || (*personal_mail_address == '\0')) {
        local_520 = "NONE";
      }
      else {
        local_520 = personal_mail_address;
      }
      sVar7 = strlen(local_520);
      if ((personal_mail_address == (char *)0x0) || (*personal_mail_address == '\0')) {
        local_518 = "NONE";
      }
      else {
        local_518 = personal_mail_address;
      }
      LYwaddnstr(LYwin,local_518,sVar7);
    }
    LYclrtoeol();
    if (wVar9 == L'\xffffffff') {
      pcVar6 = (char *)gettext("Cancelled!!!");
      HTInfoMsg(pcVar6);
      HTInfoMsg("");
    }
    else {
      mustshow = '\x01';
      pcVar6 = (char *)gettext("Value accepted!");
      statusline(pcVar6);
    }
    response = L' ';
  case L'R':
    goto switchD_0809e032_caseD_52;
  case L'S':
    wVar9 = boolean_choice((int)case_sensitive,L'\a',L'\xffffffff',LYoptions::caseless_choices);
    case_sensitive = (BOOLEAN)wVar9;
    response = L' ';
    goto switchD_0809e032_caseD_52;
  case L'T':
    if ((bool)use_assume_charset) {
      local_4d0 = L'\x0e';
    }
    else {
      local_4d0 = L'\r';
    }
    wVar9 = boolean_choice((int)LYSelectPopups,local_4d0,L'$',LYoptions::bool_choices);
    LYSelectPopups = (BOOLEAN)wVar9;
    response = L' ';
    goto switchD_0809e032_caseD_52;
  case L'U':
    break;
  case L'V':
    if ((bool)use_assume_charset) {
      local_4dc = L'\r';
    }
    else {
      local_4dc = L'\f';
    }
    wVar9 = boolean_choice((int)vi_keys,local_4dc,L'\x0f',LYoptions::bool_choices);
    vi_keys = (BOOLEAN)wVar9;
    if (vi_keys == '\0') {
      reset_vi_keys();
    }
    else {
      set_vi_keys();
    }
    response = L' ';
    goto switchD_0809e032_caseD_52;
  case L'W':
    if (no_dotfiles == '\0') {
      if ((bool)use_assume_charset) {
        local_4d4 = L'\r';
      }
      else {
        local_4d4 = L'\f';
      }
      wVar9 = boolean_choice((int)show_dotfiles,local_4d4,L'>',LYoptions::bool_choices);
      show_dotfiles = (BOOLEAN)wVar9;
    }
    else {
      mustshow = '\x01';
      pcVar6 = (char *)gettext("Access to dot files is disabled!");
      statusline(pcVar6);
    }
    response = L' ';
    goto switchD_0809e032_caseD_52;
  }
  if (LYSelectPopups == '\0') {
    if ((bool)use_assume_charset) {
      local_4a0 = L'\x13';
    }
    else {
      local_4a0 = L'\x12';
    }
    user_mode = boolean_choice(user_mode,local_4a0,L'\xffffffff',LYoptions::userMode_choices);
  }
  else {
    if ((bool)use_assume_charset) {
      local_49c = L'\x13';
    }
    else {
      local_49c = L'\x12';
    }
    user_mode = popup_choice(user_mode,local_49c,L'\xffffffff',LYoptions::userMode_choices,L'\x03',
                             L'\0','\0');
  }
  use_assume_charset = 1 < user_mode;
  LYSetDisplayLines();
  response = L' ';
  if (LYSelectPopups != '\0') goto code_r0x080a03c9;
  goto switchD_0809e032_caseD_52;
code_r0x080a03c9:
  if (term_options == '\0') {
    bVar2 = true;
  }
  else {
    term_options = '\0';
  }
  goto draw_options;
}



// WARNING: Unknown calling convention

wchar_t widest_choice(char **choices)

{
  wchar_t wVar1;
  wchar_t len;
  wchar_t width;
  wchar_t n;
  
  width = L'\0';
  for (n = L'\0'; choices[n] != (char *)0x0; n = n + L'\x01') {
    wVar1 = strlen(choices[n]);
    if (width < wVar1) {
      width = wVar1;
    }
  }
  return width;
}



// WARNING: Unknown calling convention

void show_choice(char *choice,wchar_t width)

{
  bool bVar1;
  size_t len_00;
  wchar_t len;
  
  len = strlen(choice);
  len_00 = strlen(choice);
  LYwaddnstr(LYwin,choice,len_00);
  while (bVar1 = len < width, len = len + L'\x01', bVar1) {
    waddch(LYwin,0x20);
  }
  return;
}



// WARNING: Unknown calling convention

wchar_t boolean_choice(wchar_t cur_choice,wchar_t line,wchar_t column,char **choices)

{
  wchar_t wVar1;
  wchar_t wVar2;
  wchar_t wVar3;
  wchar_t width_00;
  char *pcVar4;
  ushort **ppuVar5;
  wchar_t local_30;
  uint local_2c;
  uint local_28;
  wchar_t width;
  wchar_t orig_choice;
  wchar_t col;
  wchar_t number;
  wchar_t cmd;
  wchar_t response;
  
  wVar2 = cur_choice;
  response = L'\0';
  if (column < L'\0') {
    local_30 = L'$';
  }
  else {
    local_30 = column;
  }
  width_00 = widest_choice(choices);
  for (number = L'\0'; choices[number] != (char *)0x0; number = number + L'\x01') {
  }
  wVar1 = number + L'\xffffffff';
  mustshow = '\x01';
  pcVar4 = (char *)gettext("Hit any key to change value; RETURN to accept.");
  statusline(pcVar4);
  LYmove(line,local_30);
  lynx_start_reverse();
  show_choice(choices[cur_choice],width_00);
  if (LYShowCursor != '\0') {
    LYmove(line,local_30 + L'\xffffffff');
  }
  LYrefresh();
  term_options = '\0';
  do {
    LYmove(line,local_30);
    if (term_options == '\0') {
      response = LYgetch_single();
    }
    if (term_options == '\0') {
      if ((response == L'\x03') || (response == L'\a')) {
LAB_080a0c10:
        ppuVar5 = __ctype_b_loc();
        if (((*ppuVar5)[response] & 0x4000) == 0) goto LAB_080a0c2e;
      }
      else {
        if (response == L'\xffffffff') {
          if (keymap[0] != 0x2f) goto LAB_080a0c42;
          goto LAB_080a0c10;
        }
        if ((response & 0x8800U) == 0) {
          if (keymap[(response & 0x7ffU) + 1] == 0x2f) goto LAB_080a0c10;
        }
        else if ((response & 0xffU) == 0x2f) goto LAB_080a0c10;
      }
    }
    else {
LAB_080a0c2e:
      response = L'\n';
      term_options = '\x01';
      cur_choice = wVar2;
    }
LAB_080a0c42:
    if ((response == L'\n') || (response == L'\r')) {
LAB_080a0d76:
      LYmove(line,local_30);
      lynx_stop_reverse();
      show_choice(choices[cur_choice],width_00);
      if (term_options == '\0') {
        mustshow = '\x01';
        pcVar4 = (char *)gettext("Value accepted!");
        statusline(pcVar4);
      }
      else {
        term_options = '\0';
        pcVar4 = (char *)gettext("Cancelled!!!");
        HTInfoMsg(pcVar4);
        HTInfoMsg("");
      }
      return cur_choice;
    }
    if (response == L'\xffffffff') {
      local_2c = (uint)keymap[0];
    }
    else {
      if ((response & 0x8800U) == 0) {
        local_28 = (uint)keymap[(response & 0x7ffU) + 1];
      }
      else {
        local_28 = response & 0xff;
      }
      local_2c = local_28;
    }
    wVar3 = wVar1;
    switch(local_2c) {
    case 0:
    case 1:
    case 0xb:
    case 0xc:
    case 0xf:
    case 0x12:
    case 0x14:
    case 0x18:
    case 0x19:
    case 0x1b:
    case 0x1d:
    case 0x1f:
    case 0x21:
    case 0x22:
    case 0x24:
switchD_080a0cc5_caseD_0:
      if (cur_choice == wVar1) {
        cur_choice = L'\0';
        wVar3 = cur_choice;
      }
      else {
        wVar3 = cur_choice + L'\x01';
      }
      break;
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
      if (wVar1 < local_2c + L'\xffffffff') goto switchD_080a0cc5_caseD_0;
      wVar3 = local_2c + L'\xffffffff';
      break;
    case 0xd:
    case 0xe:
    case 0x25:
      term_options = '\x01';
      wVar3 = wVar2;
      break;
    case 0x10:
    case 0x11:
    case 0x13:
    case 0x1a:
    case 0x1c:
    case 0x1e:
    case 0x20:
    case 0x23:
      if (cur_choice != L'\0') {
        wVar3 = cur_choice + L'\xffffffff';
      }
      break;
    case 0x15:
      lynx_force_repaint();
      LYrefresh();
      wVar3 = cur_choice;
      break;
    case 0x16:
      cur_choice = L'\0';
      wVar3 = cur_choice;
      break;
    case 0x17:
      break;
    default:
      goto LAB_080a0d76;
    }
    cur_choice = wVar3;
    show_choice(choices[cur_choice],width_00);
    if (LYShowCursor != '\0') {
      LYmove(line,local_30 + L'\xffffffff');
    }
    LYrefresh();
  } while( true );
}



// WARNING: Unknown calling convention

void terminate_options(wchar_t sig)

{
  term_options = '\x01';
  signal(2,terminate_options);
  return;
}



// WARNING: Unknown calling convention

void edit_bookmarks(void)

{
  int iVar1;
  BOOLEAN BVar2;
  char *pcVar3;
  size_t sVar4;
  int iVar5;
  wchar_t wVar6;
  ushort **ppuVar7;
  int in_GS_OFFSET;
  wchar_t local_134;
  char *local_130;
  char *local_12c;
  char *ehead_buffer;
  wchar_t a;
  wchar_t MBM_current;
  wchar_t ch;
  wchar_t def_response;
  wchar_t response;
  char MBM_tmp_line [256];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  response = L'\0';
  def_response = L'\0';
  MBM_current = L'\x01';
  term_options = '\0';
  signal(2,terminate_options);
draw_bookmark_list:
  do {
    if (enable_scrollback == '\0') {
      LYerase();
    }
    else {
      LYclear();
    }
    LYmove(L'\0',L'\x05');
    lynx_start_h1_color();
    if (LYlines < 0x21) {
      ehead_buffer = (char *)0x0;
      pcVar3 = (char *)gettext("Editing Bookmark DESCRIPTION and FILEPATH (%d of 2)");
      HTSprintf0(&ehead_buffer,pcVar3,MBM_current);
      sVar4 = strlen(ehead_buffer);
      LYwaddnstr(LYwin,ehead_buffer,sVar4);
      if (ehead_buffer != (char *)0x0) {
        free(ehead_buffer);
        ehead_buffer = (char *)0x0;
      }
    }
    else {
      pcVar3 = (char *)gettext("         Editing Bookmark DESCRIPTION and FILEPATH");
      sVar4 = strlen(pcVar3);
      pcVar3 = (char *)gettext("         Editing Bookmark DESCRIPTION and FILEPATH");
      LYwaddnstr(LYwin,pcVar3,sVar4);
    }
    lynx_stop_h1_color();
    if (LYlines < 0x21) {
      for (a = MBM_current * 0xd + L'\xfffffff3'; a <= (MBM_current * 0x19) / 2; a = a + L'\x01') {
        LYmove(a + MBM_current * -0xd + 0x10,L'\x05');
        wVar6 = LYindex2MBM(a);
        waddch(LYwin,wVar6 & 0xff);
        LYwaddnstr(LYwin," : ",3);
        if (MBM_A_subdescript[a] != (char *)0x0) {
          sVar4 = strlen(MBM_A_subdescript[a]);
          LYwaddnstr(LYwin,MBM_A_subdescript[a],sVar4);
        }
        LYmove(a + MBM_current * -0xd + 0x10,L'#');
        LYwaddnstr(LYwin,"| ",2);
        if (MBM_A_subbookmark[a] != (char *)0x0) {
          sVar4 = strlen(MBM_A_subbookmark[a]);
          LYwaddnstr(LYwin,MBM_A_subbookmark[a],sVar4);
        }
      }
    }
    else {
      for (a = L'\0'; a < L'\x1a'; a = a + L'\x01') {
        LYmove(a + L'\x03',L'\x05');
        wVar6 = LYindex2MBM(a);
        waddch(LYwin,wVar6 & 0xff);
        LYwaddnstr(LYwin," : ",3);
        if (MBM_A_subdescript[a] != (char *)0x0) {
          sVar4 = strlen(MBM_A_subdescript[a]);
          LYwaddnstr(LYwin,MBM_A_subdescript[a],sVar4);
        }
        LYmove(a + L'\x03',L'#');
        LYwaddnstr(LYwin,"| ",2);
        if (MBM_A_subbookmark[a] != (char *)0x0) {
          sVar4 = strlen(MBM_A_subbookmark[a]);
          LYwaddnstr(LYwin,MBM_A_subbookmark[a],sVar4);
        }
      }
    }
    if (LYlines < 0x21) {
      LYmove(LYlines + L'\xfffffffc',L'\0');
      LYwaddnstr(LYwin,"\'",1);
      lynx_start_bold();
      LYwaddnstr(LYwin,"[",1);
      lynx_stop_bold();
      LYwaddnstr(LYwin,"\' ",2);
      pcVar3 = (char *)gettext("previous");
      sVar4 = strlen(pcVar3);
      pcVar3 = (char *)gettext("previous");
      LYwaddnstr(LYwin,pcVar3,sVar4);
      LYwaddnstr(LYwin,", \'",3);
      lynx_start_bold();
      LYwaddnstr(LYwin,"]",1);
      lynx_stop_bold();
      LYwaddnstr(LYwin,"\' ",2);
      pcVar3 = (char *)gettext("next screen");
      sVar4 = strlen(pcVar3);
      pcVar3 = (char *)gettext("next screen");
      LYwaddnstr(LYwin,pcVar3,sVar4);
    }
    LYmove(LYlines + L'\xfffffffd',L'\0');
    if (no_option_save == '\0') {
      LYwaddnstr(LYwin,"\'",1);
      lynx_start_bold();
      LYwaddnstr(LYwin,">",1);
      lynx_stop_bold();
      LYwaddnstr(LYwin,"\'",1);
      pcVar3 = (char *)gettext(" to save,");
      sVar4 = strlen(pcVar3);
      pcVar3 = (char *)gettext(" to save,");
      LYwaddnstr(LYwin,pcVar3,sVar4);
    }
    pcVar3 = (char *)gettext(&DAT_08158205);
    sVar4 = strlen(pcVar3);
    pcVar3 = (char *)gettext(&DAT_08158205);
    LYwaddnstr(LYwin,pcVar3,sVar4);
    LYwaddnstr(LYwin,"\'",1);
    lynx_start_bold();
    LYwaddnstr(LYwin,"^G",2);
    lynx_stop_bold();
    LYwaddnstr(LYwin,"\'",1);
    pcVar3 = (char *)gettext(" to return to Lynx.");
    sVar4 = strlen(pcVar3);
    pcVar3 = (char *)gettext(" to return to Lynx.");
    LYwaddnstr(LYwin,pcVar3,sVar4);
LAB_080a1d8c:
    do {
      if ((term_options != '\0') || (BVar2 = LYisNonAlnumKeyname(response,0x25), BVar2 != '\0'))
      goto LAB_080a1e4e;
      if ((response == L'\x03') || (response == L'\a')) {
LAB_080a1e20:
        ppuVar7 = __ctype_b_loc();
        if (((*ppuVar7)[response] & 0x4000) == 0) goto LAB_080a1e4e;
      }
      else {
        if (response == L'\xffffffff') {
          if (keymap[0] != 0x2f) goto LAB_080a1e41;
          goto LAB_080a1e20;
        }
        if ((response & 0x8800U) == 0) {
          if (keymap[(response & 0x7ffU) + 1] == 0x2f) goto LAB_080a1e20;
        }
        else if ((response & 0xffU) == 0x2f) goto LAB_080a1e20;
      }
LAB_080a1e41:
      if (response == L'>') {
LAB_080a1e4e:
        term_options = '\0';
        signal(2,cleanup_sig);
        if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
          return;
        }
                    // WARNING: Subroutine does not return
        __stack_chk_fail();
      }
      LYmove(LYlines + L'\xfffffffe',L'\0');
      lynx_start_prompt_color();
      pcVar3 = (char *)gettext("Letter: ");
      sVar4 = strlen(pcVar3);
      pcVar3 = (char *)gettext("Letter: ");
      LYwaddnstr(LYwin,pcVar3,sVar4);
      lynx_stop_prompt_color();
      LYrefresh();
      if (def_response == L'\0') {
        local_134 = LYgetch_single();
      }
      else {
        local_134 = def_response;
      }
      response = local_134;
      def_response = L'\0';
    } while (term_options != '\0');
    if ((local_134 == L'\x03') || (local_134 == L'\a')) {
LAB_080a1654:
      ppuVar7 = __ctype_b_loc();
      if (((*ppuVar7)[response] & 0x4000) == 0) goto LAB_080a1d8c;
    }
    else {
      if (local_134 == L'\xffffffff') {
        if (keymap[0] != 0x2f) goto LAB_080a1679;
        goto LAB_080a1654;
      }
      if ((local_134 & 0x8800U) == 0) {
        if (keymap[(local_134 & 0x7ffU) + 1] == 0x2f) goto LAB_080a1654;
      }
      else if ((local_134 & 0xffU) == 0x2f) goto LAB_080a1654;
    }
LAB_080a1679:
    BVar2 = LYisNonAlnumKeyname(response,0x25);
    if (BVar2 != '\0') goto LAB_080a1d8c;
    if (response == L'>') {
      if (no_option_save == '\0') {
        pcVar3 = (char *)gettext("Saving Options...");
        HTInfoMsg(pcVar3);
        iVar5 = save_rc((FILE *)0x0);
        if (iVar5 == 0) {
          pcVar3 = (char *)gettext("Unable to save Options!");
          HTAlert(pcVar3);
        }
        else {
          pcVar3 = (char *)gettext("Options saved!");
          HTInfoMsg(pcVar3);
        }
      }
      else {
        pcVar3 = (char *)gettext(" \'r\' to return to Lynx ");
        HTInfoMsg(pcVar3);
        response = L' ';
      }
      goto LAB_080a1d8c;
    }
    BVar2 = LYisNonAlnumKeyname(response,0x15);
    if (BVar2 != '\0') {
      lynx_force_repaint();
      goto LAB_080a1d8c;
    }
    if (((response == L']') || (BVar2 = LYisNonAlnumKeyname(response,0xf), BVar2 != '\0')) &&
       (LYlines < 0x21)) {
      MBM_current = MBM_current + L'\x01';
      if (L'\x02' < MBM_current) {
        MBM_current = L'\x01';
      }
      goto draw_bookmark_list;
    }
    if (((response != L'[') && (BVar2 = LYisNonAlnumKeyname(response,0x10), BVar2 == '\0')) ||
       (0x20 < LYlines)) {
      for (a = L'\0'; a < L'\x1a'; a = a + L'\x01') {
        wVar6 = LYMBM2index(response);
        if (wVar6 == a) {
          if (LYlines < 0x21) {
            if ((MBM_current == L'\x01') && (L'\f' < a)) {
              MBM_current = L'\x02';
              def_response = response;
              goto draw_bookmark_list;
            }
            if ((MBM_current == L'\x02') && (a < L'\f')) {
              MBM_current = L'\x01';
              def_response = response;
              goto draw_bookmark_list;
            }
          }
          mustshow = '\x01';
          pcVar3 = (char *)gettext("Hit RETURN to accept entered data.");
          statusline(pcVar3);
          if (L'\0' < a) {
            lynx_start_bold();
            if (LYlines < 0x21) {
              LYmove(a + MBM_current * -0xd + 0x10,L'\t');
            }
            else {
              LYmove(a + L'\x03',L'\t');
            }
            if (MBM_A_subdescript[a] == (char *)0x0) {
              local_130 = "";
            }
            else {
              local_130 = MBM_A_subdescript[a];
            }
            LYstrncpy(MBM_tmp_line,local_130,L'');
            ch = LYgetstr(MBM_tmp_line,L'\0',0x100,NORECALL);
            lynx_stop_bold();
            if (MBM_tmp_line[0] == '\0') {
              if (MBM_A_subdescript[a] != (char *)0x0) {
                free(MBM_A_subdescript[a]);
                MBM_A_subdescript[a] = (char *)0x0;
              }
            }
            else {
              HTSACopy(MBM_A_subdescript + a,MBM_tmp_line);
            }
            if (LYlines < 0x21) {
              LYmove(a + MBM_current * -0xd + 0x10,L'\x05');
            }
            else {
              LYmove(a + L'\x03',L'\x05');
            }
            wVar6 = LYindex2MBM(a);
            waddch(LYwin,wVar6 & 0xff);
            LYwaddnstr(LYwin," : ",3);
            if (MBM_A_subdescript[a] != (char *)0x0) {
              sVar4 = strlen(MBM_A_subdescript[a]);
              LYwaddnstr(LYwin,MBM_A_subdescript[a],sVar4);
            }
            LYclrtoeol();
            LYrefresh();
          }
          if (LYlines < 0x21) {
            LYmove(a + MBM_current * -0xd + 0x10,L'#');
          }
          else {
            LYmove(a + L'\x03',L'#');
          }
          LYwaddnstr(LYwin,"| ",2);
          lynx_start_bold();
          if (MBM_A_subbookmark[a] == (char *)0x0) {
            local_12c = "";
          }
          else {
            local_12c = MBM_A_subbookmark[a];
          }
          LYstrncpy(MBM_tmp_line,local_12c,L'');
          ch = LYgetstr(MBM_tmp_line,L'\0',0x100,NORECALL);
          lynx_stop_bold();
          if (MBM_tmp_line[0] == '\0') {
            if (a == L'\0') {
              HTSACopy(MBM_A_subbookmark,bookmark_page);
            }
            else if (MBM_A_subbookmark[a] != (char *)0x0) {
              free(MBM_A_subbookmark[a]);
              MBM_A_subbookmark[a] = (char *)0x0;
            }
          }
          else {
            BVar2 = LYPathOffHomeOK(MBM_tmp_line,0x100);
            if (BVar2 == '\0') {
              pcVar3 = (char *)gettext("Use a filepath off your home directory!");
              LYMBM_statusline(pcVar3);
              LYSleepAlert();
            }
            else {
              HTSACopy(MBM_A_subbookmark + a,MBM_tmp_line);
              if (a == L'\0') {
                HTSACopy(&bookmark_page,MBM_A_subbookmark[0]);
              }
            }
          }
          if (LYlines < 0x21) {
            LYmove(a + MBM_current * -0xd + 0x10,L'#');
          }
          else {
            LYmove(a + L'\x03',L'#');
          }
          LYwaddnstr(LYwin,"| ",2);
          if (MBM_A_subbookmark[a] != (char *)0x0) {
            sVar4 = strlen(MBM_A_subbookmark[a]);
            LYwaddnstr(LYwin,MBM_A_subbookmark[a],sVar4);
          }
          LYclrtoeol();
          LYmove(LYlines + L'\xffffffff',L'\0');
          LYclrtoeol();
          break;
        }
      }
      goto LAB_080a1d8c;
    }
    MBM_current = MBM_current + L'\xffffffff';
    if (MBM_current < L'\x01') {
      MBM_current = L'\x02';
    }
  } while( true );
}



wchar_t popup_choice(wchar_t cur_choice,wchar_t line,wchar_t column,char **choices,wchar_t i_length,
                    wchar_t disabled,BOOLEAN for_mouse)

{
  wchar_t wVar1;
  char *pcVar2;
  byte local_c;
  BOOLEAN for_mouse_local;
  
  if (column < L'\0') {
    column = L'#';
  }
  term_options = '\0';
  wVar1 = LYhandlePopupList(cur_choice,line,column,choices,L'\xffffffff',i_length,disabled,for_mouse
                           );
  if ((((uint)(wVar1 + L'\xfffffff3') < 0x19) &&
      (local_c = (byte)(wVar1 + L'\xfffffff3'), (1 << (local_c & 0x1f) & 0x1000003U) != 0)) &&
     (term_options = '\x01', for_mouse == '\0')) {
    pcVar2 = (char *)gettext("Cancelled!!!");
    HTUserMsg(pcVar2);
  }
  if ((disabled == L'\0') && (term_options == '\0')) {
    if (for_mouse == '\0') {
      mustshow = '\x01';
      pcVar2 = (char *)gettext("Value accepted!");
      statusline(pcVar2);
    }
  }
  else {
    mustshow = '\x01';
    statusline("");
  }
  return wVar1;
}



// WARNING: Unknown calling convention

void PutOptValues(FILE *fp,wchar_t value,OptValues *table)

{
  undefined4 uVar1;
  char *local_8;
  
  for (; table->LongName != (char *)0x0; table = table + 1) {
    if (table->HtmlName != (char *)0x0) {
      uVar1 = gettext(table->LongName);
      if (table->value == value) {
        local_8 = "selected";
      }
      else {
        local_8 = "";
      }
      fprintf((FILE *)fp,"<option value=\"%s\" %s>%s\n",table->HtmlName,local_8,uVar1);
    }
  }
  return;
}



// WARNING: Unknown calling convention

BOOLEAN GetOptValues(OptValues *table,char *value,wchar_t *result)

{
  int iVar1;
  
  while( true ) {
    if (table->LongName == (char *)0x0) {
      return '\0';
    }
    if ((table->HtmlName != (char *)0x0) && (iVar1 = strcmp(value,table->HtmlName), iVar1 == 0))
    break;
    table = table + 1;
  }
  *result = table->value;
  return '\x01';
}



// WARNING: Unknown calling convention

PostPair * break_data(bstring_conflict *data)

{
  char *pcVar1;
  FILE *pFVar2;
  char *pcVar3;
  size_t sVar4;
  ushort **ppuVar5;
  PostPair *local_34;
  char *local_30;
  size_t len;
  size_t i;
  wchar_t count;
  PostPair *q;
  char *p;
  
  count = L'\0';
  if (((data == (bstring_conflict *)0x0) || (data == (bstring_conflict *)0x0)) ||
     (data->len == L'\0')) {
    local_34 = (PostPair *)0x0;
  }
  else {
    if (data == (bstring_conflict *)0x0) {
      local_30 = (char *)0x0;
    }
    else {
      local_30 = data->str;
    }
    p = local_30;
    if (WWW_TraceFlag != '\0') {
      pFVar2 = TraceFP();
      fprintf((FILE *)pFVar2,"break_data %s\n",local_30);
    }
    q = (PostPair *)calloc(1,8);
    if (q == (PostPair *)0x0) {
      outofmem("./LYOptions.c","break_data(calloc)");
    }
    do {
      pcVar3 = LYstrsep(&p,"&");
      q[count].value = pcVar3;
      pcVar3 = LYstrsep(&q[count].value,"=");
      q[count].tag = pcVar3;
      HTUnEscape(q[count].tag);
      sVar4 = strlen(q[count].value);
      for (i = 0; i < sVar4; i = i + 1) {
        if (q[count].value[i] == '+') {
          if (((i == 0) || (q[count].value[i + 1] != '+')) ||
             (ppuVar5 = __ctype_b_loc(), ((*ppuVar5)[(byte)q[count].value[i + 2]] & 8) == 0)) {
            q[count].value[i] = ' ';
          }
          else {
            q[count].value[i] = ' ';
            i = i + 2;
          }
        }
      }
      HTUnEscape(q[count].value);
      if (WWW_TraceFlag != '\0') {
        pcVar3 = q[count].value;
        pcVar1 = q[count].tag;
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2,"...item[%d] tag=%s, value=%s\n",count,pcVar1,pcVar3);
      }
      local_34 = (PostPair *)realloc(q,(count + L'\x02') * 8);
      if (local_34 == (PostPair *)0x0) {
        outofmem("./LYOptions.c","break_data(realloc)");
      }
      local_34[count + L'\x01'].tag = (char *)0x0;
    } while ((p != (char *)0x0) && (count = count + L'\x01', q = local_34, *p != '\0'));
  }
  return local_34;
}



// WARNING: Unknown calling convention

BOOLEAN isLynxOptionsPage(char *address,char *portion)

{
  char *a;
  int iVar1;
  size_t n;
  uint len;
  BOOLEAN result;
  
  result = '\0';
  iVar1 = strncasecomp(address,"LYNXOPTIONS:",0xc);
  if (iVar1 == 0) {
    n = strlen(portion);
    a = address + 0xc;
    iVar1 = strncasecomp(a,portion,n);
    if ((iVar1 == 0) && ((a[n] == '\0' || (a[n] == '/')))) {
      result = '\x01';
    }
  }
  return result;
}



// WARNING: Unknown calling convention

wchar_t postoptions(DocInfo *newdoc)

{
  bool bVar1;
  BOOLEAN BVar2;
  char *pcVar3;
  char *pcVar4;
  int iVar5;
  int iVar6;
  FILE *pFVar7;
  wchar_t wVar8;
  wchar_t local_6c;
  char *local_68;
  char *local_64;
  char *local_60;
  DocAddress WWWDoc;
  wchar_t j_1;
  wchar_t newval_3;
  wchar_t newval_2;
  wchar_t j;
  wchar_t newval_1;
  char *buf;
  wchar_t status;
  wchar_t CurrentShowColor;
  wchar_t old_media_value;
  wchar_t display_char_set_old;
  wchar_t code;
  wchar_t i;
  PostPair *data;
  BOOLEAN need_end_reload;
  BOOLEAN need_reload;
  BOOLEAN assume_char_set_changed;
  BOOLEAN raw_mode_old;
  BOOLEAN save_all;
  
  data = (PostPair *)0x0;
  code = L'\0';
  save_all = '\0';
  display_char_set_old = current_char_set;
  old_media_value = LYAcceptMedia;
  raw_mode_old = LYRawMode;
  assume_char_set_changed = '\0';
  need_reload = '\0';
  need_end_reload = '\0';
  CurrentShowColor = LYShowColor;
  BVar2 = isLynxOptionsPage(newdoc->address,"//MBM_MENU");
  if (BVar2 != '\0') {
    if (newdoc->post_data != (bstring_conflict *)0x0) {
      free(newdoc->post_data);
      newdoc->post_data = (bstring_conflict *)0x0;
    }
    if (no_bookmark != '\0') {
      pcVar3 = (char *)gettext("You are not allowed to change the bookmark file!");
      HTAlert(pcVar3);
      return L'\x03';
    }
    if (dump_output_immediately != '\0') {
      return L'\0';
    }
    edit_bookmarks();
    return L'\x03';
  }
  BVar2 = isLynxOptionsPage(newdoc->address,"/");
  if (BVar2 == '\0') {
    pcVar3 = (char *)gettext("Random URL is disallowed!  Use a shortcut.");
    HTAlert(pcVar3);
    return L'\x03';
  }
  data = break_data(newdoc->post_data);
  if (data == (PostPair *)0x0) {
    status = gen_options(&newdoc->address);
    if (status != L'\x01') {
      HTAlwaysAlert("Unexpected way of accessing",newdoc->address);
      if (newdoc->address != (char *)0x0) {
        free(newdoc->address);
        newdoc->address = (char *)0x0;
      }
      return status;
    }
    WWWDoc.address = newdoc->address;
    WWWDoc.post_data = (bstring *)newdoc->post_data;
    WWWDoc.post_content_type = newdoc->post_content_type;
    WWWDoc.bookmark = newdoc->bookmark;
    WWWDoc.isHEAD = newdoc->isHEAD;
    WWWDoc.safe = newdoc->safe;
    BVar2 = HTLoadAbsolute(&WWWDoc);
    if (BVar2 == '\0') {
      return L'\0';
    }
    LYRegisterUIPage(newdoc->address,UIP_OPTIONS_MENU);
    lynx_edit_mode = '\0';
    return L'\x01';
  }
  pcVar3 = HTLoadedDocumentURL();
  BVar2 = LYIsUIPage3(pcVar3,UIP_OPTIONS_MENU,L'\0');
  if (BVar2 == '\0') {
    pcVar3 = HTLoadedDocumentURL();
    BVar2 = LYIsUIPage3(pcVar3,UIP_VLINKS,L'\0');
    if (BVar2 == '\0') {
      buf = (char *)0x0;
      pcVar3 = key_for_func_ext(0x31,0);
      pcVar4 = (char *)gettext("Use %s to invoke the Options menu!");
      HTSprintf0(&buf,pcVar4,pcVar3);
      HTAlert(buf);
      if (buf != (char *)0x0) {
        free(buf);
        buf = (char *)0x0;
      }
      if (data != (PostPair *)0x0) {
        free(data);
      }
      return L'\0';
    }
  }
  for (i = L'\0'; data[i].tag != (char *)0x0; i = i + L'\x01') {
    iVar6 = strcmp(data[i].tag,secure_string);
    if (iVar6 == 0) {
      if ((secure_value == (char *)0x0) || (iVar6 = strcmp(data[i].value,secure_value), iVar6 != 0))
      {
        buf = (char *)0x0;
        pcVar3 = key_for_func_ext(0x31,0);
        pcVar4 = (char *)gettext("Use %s to invoke the Options menu!");
        HTSprintf0(&buf,pcVar4,pcVar3);
        HTAlert(buf);
        if (data != (PostPair *)0x0) {
          free(data);
        }
        return L'\x03';
      }
      if (secure_value != (char *)0x0) {
        free(secure_value);
        secure_value = (char *)0x0;
      }
    }
    iVar6 = strcmp(data[i].tag,save_options_string);
    if ((iVar6 == 0) && (no_option_save == '\0')) {
      save_all = '\x01';
    }
    iVar6 = strcmp(data[i].tag,cookies_string);
    if (iVar6 == 0) {
      iVar6 = strcmp(data[i].value,cookies_ignore_all_string);
      if (iVar6 == 0) {
        LYSetCookies = '\0';
      }
      else {
        iVar6 = strcmp(data[i].value,cookies_up_to_user_string);
        if (iVar6 == 0) {
          LYSetCookies = '\x01';
          LYAcceptAllCookies = '\0';
        }
        else {
          iVar6 = strcmp(data[i].value,cookies_accept_all_string);
          if (iVar6 == 0) {
            LYSetCookies = '\x01';
            LYAcceptAllCookies = '\x01';
          }
        }
      }
    }
    iVar6 = strcmp(data[i].tag,x_display_string);
    if (iVar6 == 0) {
      LYsetXDisplay(data[i].value);
      validate_x_display();
      summarize_x_display(data[i].value);
    }
    iVar6 = strcmp(data[i].tag,editor_string);
    if (iVar6 == 0) {
      if (editor != (char *)0x0) {
        free(editor);
        editor = (char *)0x0;
      }
      HTSACopy(&editor,data[i].value);
    }
    iVar6 = strcmp(data[i].tag,emacs_keys_string);
    if ((iVar6 == 0) && (BVar2 = GetOptValues(bool_values,data[i].value,&code), BVar2 != '\0')) {
      emacs_keys = (BOOLEAN)code;
      if (emacs_keys == '\0') {
        reset_emacs_keys();
      }
      else {
        set_emacs_keys();
      }
    }
    iVar6 = strcmp(data[i].tag,keypad_mode_string);
    if (iVar6 == 0) {
      buf = (char *)0x0;
      BVar2 = GetOptValues(keypad_mode_values,data[i].value,(wchar_t *)&buf);
      if ((BVar2 != '\0') && ((char *)keypad_mode != buf)) {
        keypad_mode = (int)buf;
        need_reload = '\x01';
        if (buf == (char *)0x0) {
          set_numbers_as_arrows();
        }
        else {
          reset_numbers_as_arrows();
        }
      }
    }
    iVar6 = strcmp(data[i].tag,lineedit_mode_string);
    if (iVar6 == 0) {
      wVar8 = atoi(data[i].value);
      for (j = L'\0'; LYLineeditNames[j] != (char *)0x0; j = j + L'\x01') {
        if (j == wVar8) {
          current_lineedit = wVar8;
        }
      }
    }
    iVar6 = strcmp(data[i].tag,mail_address_string);
    if (iVar6 == 0) {
      if (personal_mail_address != (char *)0x0) {
        free(personal_mail_address);
        personal_mail_address = (char *)0x0;
      }
      HTSACopy(&personal_mail_address,data[i].value);
    }
    iVar6 = strcmp(data[i].tag,anonftp_password_string);
    if (iVar6 == 0) {
      if (anonftp_password != (char *)0x0) {
        free(anonftp_password);
        anonftp_password = (char *)0x0;
      }
      HTSACopy(&anonftp_password,data[i].value);
    }
    iVar6 = strcmp(data[i].tag,search_type_string);
    if ((iVar6 == 0) &&
       (BVar2 = GetOptValues(search_type_values,data[i].value,&code), BVar2 != '\0')) {
      case_sensitive = (BOOLEAN)code;
    }
    iVar6 = strcmp(data[i].tag,DTD_recovery_string);
    if (((iVar6 == 0) && (BVar2 = GetOptValues(DTD_type_values,data[i].value,&code), BVar2 != '\0'))
       && (Old_DTD != code)) {
      Old_DTD = code;
      HTSwitchDTD((uint)(code == L'\0'));
      need_reload = '\x01';
    }
    iVar6 = strcmp(data[i].tag,select_popups_string);
    if ((iVar6 == 0) && (BVar2 = GetOptValues(bool_values,data[i].value,&code), BVar2 != '\0')) {
      LYSelectPopups = (BOOLEAN)code;
    }
    iVar6 = strcmp(data[i].tag,show_color_string);
    if ((iVar6 == 0) &&
       (BVar2 = GetOptValues(show_color_values,data[i].value,&LYChosenShowColor), BVar2 != '\0')) {
      if (can_do_colors != '\0') {
        LYShowColor = LYChosenShowColor;
      }
      if (CurrentShowColor != LYShowColor) {
        lynx_force_repaint();
      }
      CurrentShowColor = LYShowColor;
    }
    iVar6 = strcmp(data[i].tag,show_cursor_string);
    if ((iVar6 == 0) && (BVar2 = GetOptValues(bool_values,data[i].value,&code), BVar2 != '\0')) {
      LYShowCursor = (BOOLEAN)code;
    }
    iVar6 = strcmp(data[i].tag,underline_links_string);
    if ((iVar6 == 0) && (BVar2 = GetOptValues(bool_values,data[i].value,&code), BVar2 != '\0')) {
      LYUnderlineLinks = (BOOLEAN)code;
    }
    iVar6 = strcmp(data[i].tag,show_scrollbar_string);
    if ((iVar6 == 0) && (BVar2 = GetOptValues(bool_values,data[i].value,&code), BVar2 != '\0')) {
      LYShowScrollbar = (BOOLEAN)code;
      need_reload = '\x01';
    }
    iVar6 = strcmp(data[i].tag,cookie_prompt_string);
    if (iVar6 == 0) {
      GetOptValues(prompt_values,data[i].value,&cookie_noprompt);
    }
    iVar6 = strcmp(data[i].tag,user_mode_string);
    if ((iVar6 == 0) &&
       (BVar2 = GetOptValues(user_mode_values,data[i].value,&user_mode), BVar2 != '\0')) {
      LYSetDisplayLines();
    }
    iVar6 = strcmp(data[i].tag,visited_links_string);
    if (iVar6 == 0) {
      GetOptValues(visited_links_values,data[i].value,&Visited_Links_As);
    }
    iVar6 = strcmp(data[i].tag,images_string);
    if (iVar6 == 0) {
      iVar6 = strcmp(data[i].value,images_ignore_all_string);
      if ((iVar6 == 0) && ((pseudo_inline_alts != '\0' || (clickable_images != '\0')))) {
        pseudo_inline_alts = '\0';
        clickable_images = '\0';
        need_reload = '\x01';
      }
      else {
        iVar6 = strcmp(data[i].value,images_use_label_string);
        if ((iVar6 == 0) && ((pseudo_inline_alts != '\x01' || (clickable_images != '\0')))) {
          pseudo_inline_alts = '\x01';
          clickable_images = '\0';
          need_reload = '\x01';
        }
        else {
          iVar6 = strcmp(data[i].value,images_use_links_string);
          if ((iVar6 == 0) && (clickable_images != '\x01')) {
            clickable_images = '\x01';
            need_reload = '\x01';
          }
        }
      }
    }
    iVar6 = strcmp(data[i].tag,verbose_images_string);
    if (((iVar6 == 0) &&
        (BVar2 = GetOptValues(verbose_images_type_values,data[i].value,&code), BVar2 != '\0')) &&
       (verbose_img != code)) {
      verbose_img = (BOOLEAN)code;
      need_reload = '\x01';
    }
    iVar6 = strcmp(data[i].tag,vi_keys_string);
    if ((iVar6 == 0) && (BVar2 = GetOptValues(bool_values,data[i].value,&code), BVar2 != '\0')) {
      vi_keys = (BOOLEAN)code;
      if (vi_keys == '\0') {
        reset_vi_keys();
      }
      else {
        set_vi_keys();
      }
    }
    iVar6 = strcmp(data[i].tag,mbm_string);
    if ((iVar6 == 0) && (LYMBMBlocked == '\0')) {
      GetOptValues(mbm_values,data[i].value,&LYMultiBookmarks);
    }
    iVar6 = strcmp(data[i].tag,single_bookmark_string);
    if (((iVar6 == 0) && (no_bookmark == '\0')) && (*data[i].value != '\0')) {
      if (bookmark_page != (char *)0x0) {
        free(bookmark_page);
        bookmark_page = (char *)0x0;
      }
      HTSACopy(&bookmark_page,data[i].value);
    }
    iVar6 = strcmp(data[i].tag,assume_char_set_string);
    if (((iVar6 == 0) && (iVar6 = UCGetLYhndl_byMIME(data[i].value), -1 < iVar6)) &&
       (((raw_mode_old != '\0' &&
         (iVar5 = safeUCGetLYhndl_byMIME(UCAssume_MIMEcharset), iVar5 != iVar6)) ||
        ((raw_mode_old == '\0' && (iVar6 != UCLYhndl_for_unspec)))))) {
      UCLYhndl_for_unspec = iVar6;
      HTSACopy(&UCAssume_MIMEcharset,data[i].value);
      assume_char_set_changed = '\x01';
    }
    iVar6 = strcmp(data[i].tag,locale_charset_string);
    if ((iVar6 == 0) && (BVar2 = GetOptValues(bool_values,data[i].value,&code), BVar2 != '\0')) {
      LYLocaleCharset = (BOOLEAN)code;
    }
    iVar6 = strcmp(data[i].tag,display_char_set_string);
    if (iVar6 == 0) {
      wVar8 = atoi(data[i].value);
      for (j_1 = L'\0'; LYchar_set_names[j_1] != (char *)0x0; j_1 = j_1 + L'\x01') {
        if (j_1 == wVar8) {
          current_char_set = wVar8;
        }
      }
    }
    iVar6 = strcmp(data[i].tag,raw_mode_string);
    if ((iVar6 == 0) && (BVar2 = GetOptValues(bool_values,data[i].value,&code), BVar2 != '\0')) {
      LYRawMode = (BOOLEAN)code;
    }
    iVar6 = strcmp(data[i].tag,passive_ftp_string);
    if (iVar6 == 0) {
      ftp_passive = (BOOLEAN)code;
    }
    iVar6 = strcmp(data[i].tag,ftp_sort_string);
    if (iVar6 == 0) {
      GetOptValues(ftp_sort_values,data[i].value,&HTfileSortMethod);
    }
    iVar6 = strcmp(data[i].tag,dired_list_string);
    if (iVar6 == 0) {
      GetOptValues(dired_list_values,data[i].value,&dir_list_style);
    }
    iVar6 = strcmp(data[i].tag,dired_sort_string);
    if (iVar6 == 0) {
      GetOptValues(dired_sort_values,data[i].value,&dir_list_order);
    }
    iVar6 = strcmp(data[i].tag,show_dotfiles_string);
    if (((iVar6 == 0) && (no_dotfiles == '\0')) &&
       (BVar2 = GetOptValues(bool_values,data[i].value,&code), BVar2 != '\0')) {
      show_dotfiles = (BOOLEAN)code;
    }
    iVar6 = strcmp(data[i].tag,show_rate_string);
    if ((iVar6 == 0) && (BVar2 = GetOptValues(rate_values,data[i].value,&code), BVar2 != '\0')) {
      LYTransferRate = code;
    }
    iVar6 = strcmp(data[i].tag,preferred_media_string);
    if (iVar6 == 0) {
      GetOptValues(media_values,data[i].value,&LYAcceptMedia);
    }
    iVar6 = strcmp(data[i].tag,preferred_encoding_string);
    if (iVar6 == 0) {
      GetOptValues(encoding_values,data[i].value,&LYAcceptEncoding);
    }
    iVar6 = strcmp(data[i].tag,preferred_doc_char_string);
    if ((iVar6 == 0) && (iVar6 = strcmp(pref_charset,data[i].value), iVar6 != 0)) {
      if (pref_charset != (char *)0x0) {
        free(pref_charset);
        pref_charset = (char *)0x0;
      }
      HTSACopy(&pref_charset,data[i].value);
      need_end_reload = '\x01';
    }
    iVar6 = strcmp(data[i].tag,preferred_doc_lang_string);
    if ((iVar6 == 0) && (iVar6 = strcmp(language,data[i].value), iVar6 != 0)) {
      if (language != (char *)0x0) {
        free(language);
        language = (char *)0x0;
      }
      HTSACopy(&language,data[i].value);
      need_end_reload = '\x01';
    }
    iVar6 = strcmp(data[i].tag,user_agent_string);
    if (((iVar6 == 0) && (no_useragent == '\0')) &&
       (iVar6 = strcmp(LYUserAgent,data[i].value), iVar6 != 0)) {
      need_end_reload = '\x01';
      if (LYUserAgent != (char *)0x0) {
        free(LYUserAgent);
        LYUserAgent = (char *)0x0;
      }
      if (*data[i].value == '\0') {
        local_68 = LYUserAgentDefault;
      }
      else {
        local_68 = data[i].value;
      }
      HTSACopy(&LYUserAgent,local_68);
      BVar2 = LYCheckUserAgent();
      if (BVar2 == '\0') {
        pcVar3 = (char *)gettext(
                                "Use \"L_y_n_x\" or \"Lynx\" in User-Agent, or it looks like intentional deception!"
                                );
        HTAlert(pcVar3);
      }
    }
  }
  LYFindLocaleCharset();
  if (old_media_value != LYAcceptMedia) {
    HTFilterPresentations();
  }
  if (((display_char_set_old != current_char_set) || (raw_mode_old != LYRawMode)) ||
     (assume_char_set_changed != '\0')) {
    if (display_char_set_old != current_char_set) {
      LYUseDefaultRawMode = '\x01';
      HTMLUseCharacterSet(current_char_set);
    }
    if ((assume_char_set_changed != '\0') && (HTCJK != JAPANESE)) {
      LYRawMode = UCLYhndl_for_unspec == current_char_set;
    }
    if ((raw_mode_old != LYRawMode) || (assume_char_set_changed != '\0')) {
      HTMLSetUseDefaultRawMode(current_char_set,LYRawMode);
      HTMLSetCharacterHandling(current_char_set);
    }
    need_reload = '\x01';
  }
  HTSABFree((bstring **)&newdoc->post_data);
  if (data != (PostPair *)0x0) {
    free(data);
    data = (PostPair *)0x0;
  }
  if (save_all != '\0') {
    pcVar3 = (char *)gettext("Saving Options...");
    HTInfoMsg(pcVar3);
    LYrcShowColor = LYChosenShowColor;
    iVar6 = save_rc((FILE *)0x0);
    if (iVar6 == 0) {
      pcVar3 = (char *)gettext("Unable to save Options!");
      HTAlert(pcVar3);
    }
    else {
      pcVar3 = (char *)gettext("Options saved!");
      HTInfoMsg(pcVar3);
    }
  }
  if (WWW_TraceFlag != '\0') {
    pFVar7 = TraceFP();
    fprintf((FILE *)pFVar7,"\nLYOptions.c/postoptions(): exiting...\n");
  }
  if (WWW_TraceFlag != '\0') {
    if (need_reload == '\0') {
      local_64 = "FALSE";
    }
    else {
      local_64 = "TRUE";
    }
    pFVar7 = TraceFP();
    fprintf((FILE *)pFVar7,"                            need_reload = %s\n",local_64);
  }
  if (WWW_TraceFlag != '\0') {
    if (need_end_reload == '\0') {
      local_60 = "FALSE";
    }
    else {
      local_60 = "TRUE";
    }
    pFVar7 = TraceFP();
    fprintf((FILE *)pFVar7,"                            need_end_reload = %s\n",local_60);
  }
  LYpop(newdoc);
  WWWDoc.address = newdoc->address;
  WWWDoc.post_data = (bstring *)newdoc->post_data;
  WWWDoc.post_content_type = newdoc->post_content_type;
  WWWDoc.bookmark = newdoc->bookmark;
  WWWDoc.isHEAD = newdoc->isHEAD;
  WWWDoc.safe = newdoc->safe;
  LYforce_no_cache = '\0';
  LYoverride_no_cache = '\x01';
  BVar2 = HTLoadAbsolute(&WWWDoc);
  if (BVar2 == '\0') {
    return L'\0';
  }
  HTuncache_current_document();
  LYpop(newdoc);
  WWWDoc.address = newdoc->address;
  WWWDoc.post_data = (bstring *)newdoc->post_data;
  WWWDoc.post_content_type = newdoc->post_content_type;
  WWWDoc.bookmark = newdoc->bookmark;
  WWWDoc.isHEAD = newdoc->isHEAD;
  WWWDoc.safe = newdoc->safe;
  LYforce_no_cache = '\0';
  LYoverride_no_cache = '\x01';
  BVar2 = HTLoadAbsolute(&WWWDoc);
  if (BVar2 == '\0') {
    return L'\0';
  }
  reloading = '\0';
  if (need_end_reload == '\x01') {
    iVar6 = strncmp(newdoc->address,"http",4);
    if (iVar6 != 0) {
      if (((*newdoc->address == 'l') || (*newdoc->address == 'L')) &&
         (iVar6 = strncasecomp(newdoc->address,"lynxcgi:",8), iVar6 == 0)) {
        bVar1 = true;
      }
      else {
        bVar1 = false;
      }
      if (bVar1) goto LAB_080a398a;
    }
    reloading = '\x01';
    need_reload = '\x01';
  }
LAB_080a398a:
  if (need_reload == '\0') {
    if (WWW_TraceFlag != '\0') {
      pFVar7 = TraceFP();
      fprintf((FILE *)pFVar7,"LYOptions.c/postoptions(): now really exit.\n\n");
    }
    local_6c = L'\x01';
  }
  else {
    wVar8 = HTisDocumentSource();
    if (wVar8 != L'\0') {
      srcmode_for_next_retrieval(1);
    }
    if ((reloading == '\0') && (BVar2 = HTcan_reparse_document(), BVar2 != '\0')) {
      BVar2 = HTreparse_document();
      if (BVar2 == '\0') {
        srcmode_for_next_retrieval(0);
      }
      if (WWW_TraceFlag != '\0') {
        pFVar7 = TraceFP();
        fprintf((FILE *)pFVar7,"LYOptions.c/postoptions(): now really exit.\n\n");
      }
      return L'\x01';
    }
    if (((newdoc->post_data != (bstring_conflict *)0x0) && (newdoc->safe == '\0')) &&
       (BVar2 = confirm_post_resub(newdoc->address,newdoc->title,L'\x02',L'\x01'), BVar2 == '\0')) {
      pcVar3 = (char *)gettext("Document will not be reloaded!");
      HTInfoMsg(pcVar3);
      wVar8 = HTisDocumentSource();
      if (wVar8 != L'\0') {
        srcmode_for_next_retrieval(0);
      }
      return L'\x01';
    }
    HEAD_request = HTLoadedDocumentIsHEAD();
    HTuncache_current_document();
    LYpush(newdoc,'\0');
    if (WWW_TraceFlag != '\0') {
      pFVar7 = TraceFP();
      fprintf((FILE *)pFVar7,"LYOptions.c/postoptions(): now really exit.\n\n");
    }
    local_6c = L'\x03';
  }
  return local_6c;
}



// WARNING: Unknown calling convention

char * NewSecureValue(void)

{
  long lVar1;
  char *local_18;
  long key;
  
  if (secure_value != (char *)0x0) {
    free(secure_value);
    secure_value = (char *)0x0;
  }
  secure_value = (char *)malloc(0x50);
  if (secure_value == (char *)0x0) {
    local_18 = NewSecureValue::oops;
  }
  else {
    lVar1 = random();
    sprintf(secure_value,"%ld",lVar1);
    local_18 = secure_value;
  }
  return local_18;
}



// WARNING: Unknown calling convention

void PutLabel(FILE *fp,char *name,char *value)

{
  bool bVar1;
  BOOLEAN BVar2;
  wchar_t len;
  char *local_18;
  wchar_t need;
  wchar_t want;
  wchar_t have;
  
  len = strlen(name);
  need = LYstrExtent(name,len,L'!');
  if (no_margins == '\0') {
    local_18 = "&nbsp;&nbsp;";
  }
  else {
    local_18 = "";
  }
  fprintf((FILE *)fp,"%s%s",local_18,name);
  BVar2 = will_save_rc(value);
  if ((BVar2 == '\0') || (no_option_save != '\0')) {
    if (need < L'\x1e') {
      fwrite("&nbsp;",1,6,(FILE *)fp);
      need = need + L'\x01';
    }
    fwrite(&DAT_08159104,1,3,(FILE *)fp);
    while (bVar1 = need < L'\x1e', need = need + L'\x01', bVar1) {
      fwrite("&nbsp;",1,6,(FILE *)fp);
    }
  }
  else {
    while (bVar1 = need < L'!', need = need + L'\x01', bVar1) {
      fwrite("&nbsp;",1,6,(FILE *)fp);
    }
  }
  fwrite(&DAT_08159108,1,2,(FILE *)fp);
  return;
}



// WARNING: Unknown calling convention

char * check_if_write_lynxrc(char **table)

{
  BOOLEAN BVar1;
  char *result;
  wchar_t n;
  
  result = (char *)0x0;
  n = L'\0';
  while( true ) {
    if (table[n] == (char *)0x0) {
      return result;
    }
    result = table[n];
    BVar1 = will_save_rc(result);
    if (BVar1 == '\0') break;
    n = n + L'\x01';
  }
  return result;
}



// WARNING: Unknown calling convention

char * will_save_cookies(void)

{
  char *pcVar1;
  
  pcVar1 = check_if_write_lynxrc(will_save_cookies::table);
  return pcVar1;
}



// WARNING: Unknown calling convention

char * will_save_images(void)

{
  char *pcVar1;
  
  pcVar1 = check_if_write_lynxrc(will_save_images::table);
  return pcVar1;
}



// WARNING: Unknown calling convention

void LYMenuVisitedLinks(FILE *fp0,wchar_t disable_all)

{
  char *local_8;
  
  if (disable_all == L'\0') {
    local_8 = "";
  }
  else {
    local_8 = "disabled";
  }
  fprintf((FILE *)fp0,"<select name=\"%s\" %s>\n",visited_links_string,local_8);
  PutOptValues(fp0,Visited_Links_As,visited_links_values);
  fwrite("</select>\n",1,10,(FILE *)fp0);
  return;
}



wchar_t gen_options(char **newfile)

{
  int iVar1;
  char *pcVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  char *pcVar5;
  int in_GS_OFFSET;
  size_t local_1b0;
  int local_1a8;
  wchar_t local_1a4;
  char *local_19c;
  char *local_198;
  char *local_194;
  char *local_190;
  char *local_18c;
  char *local_188;
  char *local_180;
  char *local_17c;
  char *local_174;
  char *local_16c;
  char *local_164;
  char *local_160;
  char *local_158;
  char *local_154;
  char *local_150;
  char *local_14c;
  char *local_148;
  char *local_140;
  char *local_138;
  char *local_134;
  char *local_130;
  char *local_12c;
  char *local_124;
  char *local_120;
  char *local_118;
  char *local_114;
  char *local_110;
  char *local_10c;
  char *local_104;
  char *local_100;
  char *local_fc;
  char *local_f8;
  char *local_f4;
  char *local_f0;
  char *local_ec;
  char *local_e8;
  char *local_e4;
  char *local_e0;
  char *local_d8;
  char *local_d0;
  char *local_c8;
  char *local_c4;
  char *local_bc;
  char *local_b8;
  char *local_b4;
  char *local_b0;
  char *local_ac;
  char *local_a8;
  char *local_a4;
  char *local_a0;
  char *local_9c;
  char *local_98;
  char *local_94;
  char *local_90;
  char *local_8c;
  char *local_84;
  char *local_80;
  char *local_7c;
  char *local_78;
  char *local_74;
  char *local_70;
  char *local_6c;
  char *local_64;
  char *local_5c;
  char *local_58;
  char *local_54;
  char *local_50;
  char **newfile_local;
  char *message;
  wchar_t curval;
  size_t len;
  size_t text_len;
  size_t cset_len;
  FILE *fp0;
  wchar_t i;
  BOOLEAN disable_all;
  char temp [16];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  disable_all = '\0';
  cset_len = 0;
  if ((int)(LYcols - (uint)(LYShowScrollbar != '\0')) < 0x2e) {
    local_1b0 = 7;
  }
  else {
    if (no_margins == '\0') {
      local_1a8 = 0x25;
    }
    else {
      local_1a8 = 0x23;
    }
    local_1b0 = (LYcols - (uint)(LYShowScrollbar != '\0')) - local_1a8;
  }
  text_len = local_1b0;
  fp0 = InternalPageFP(gen_options::tempfile,L'\x01');
  if (fp0 == (FILE *)0x0) {
    local_1a4 = L'\0';
  }
  else {
    LYLocalFileToURL(newfile,gen_options::tempfile);
    LYforce_no_cache = '\x01';
    if (LYUseFormsOptions == '\0') {
      disable_all = '\x01';
    }
    pcVar2 = (char *)gettext("Options Menu");
    BeginInternalPage(fp0,pcVar2,(char *)0x0);
    fprintf((FILE *)fp0,"<form action=\"%s\" method=\"post\">\n","LYNXOPTIONS:");
    pcVar2 = NewSecureValue();
    fprintf((FILE *)fp0,"<input name=\"%s\" type=\"hidden\" value=\"%s\">\n",secure_string,pcVar2);
    fwrite("<p align=center>\n",1,0x11,(FILE *)fp0);
    if (disable_all == '\0') {
      uVar3 = gettext("Accept Changes");
      fprintf((FILE *)fp0,"<input type=\"submit\" value=\"%s\"> - \n",uVar3);
      uVar3 = gettext("Reset Changes");
      fprintf((FILE *)fp0,"<input type=\"reset\" value=\"%s\"> - \n",uVar3);
      uVar3 = gettext("Left Arrow cancels changes");
      fprintf((FILE *)fp0,"%s - \n",uVar3);
    }
    uVar3 = gettext("HELP!");
    pcVar2 = "keystrokes/option_help.html.gz";
    fprintf((FILE *)fp0,"<a href=\"%s%s\">%s</a>\n",helpfilepath,"keystrokes/option_help.html.gz",
            uVar3);
    if (no_option_save == '\0') {
      if (disable_all == '\0') {
        uVar4 = gettext("Save options to disk");
        fprintf((FILE *)fp0,"<p align=center>%s: ",uVar4,pcVar2,uVar3);
        fprintf((FILE *)fp0,"<input type=\"checkbox\" name=\"%s\">\n",save_options_string);
      }
      uVar4 = gettext("(options marked with (!) will not be saved)");
      fprintf((FILE *)fp0,"<br>%s\n",uVar4,pcVar2,uVar3);
    }
    fwrite("<pre>\n",1,6,(FILE *)fp0);
    uVar4 = gettext("General Preferences");
    if (no_margins == '\0') {
      local_19c = "&nbsp;&nbsp;";
    }
    else {
      local_19c = "";
    }
    fprintf((FILE *)fp0,"\n%s<em>%s</em>\n",local_19c,uVar4,uVar3);
    pcVar2 = user_mode_string;
    pcVar5 = (char *)gettext("User mode");
    PutLabel(fp0,pcVar5,pcVar2);
    if (disable_all == '\0') {
      local_198 = "";
    }
    else {
      local_198 = "disabled";
    }
    fprintf((FILE *)fp0,"<select name=\"%s\" %s>\n",user_mode_string,local_198);
    PutOptValues(fp0,user_mode,user_mode_values);
    fwrite("</select>\n",1,10,(FILE *)fp0);
    pcVar2 = editor_string;
    pcVar5 = (char *)gettext("Editor");
    PutLabel(fp0,pcVar5,pcVar2);
    if (disable_all == '\0') {
      if ((no_editor == '\0') && (system_editor == '\0')) {
        local_190 = "";
      }
      else {
        local_190 = "disabled";
      }
      local_194 = local_190;
    }
    else {
      local_194 = "disabled";
    }
    if (editor == (char *)0x0) {
      local_18c = "";
    }
    else {
      local_18c = editor;
    }
    fprintf((FILE *)fp0,"<input size=%d type=\"text\" name=\"%s\" value=\"%s\" %s>\n",text_len,
            editor_string,local_18c,local_194);
    pcVar2 = search_type_string;
    pcVar5 = (char *)gettext("Type of Search");
    PutLabel(fp0,pcVar5,pcVar2);
    if (disable_all == '\0') {
      local_188 = "";
    }
    else {
      local_188 = "disabled";
    }
    fprintf((FILE *)fp0,"<select name=\"%s\" %s>\n",search_type_string,local_188,local_18c,local_194
           );
    PutOptValues(fp0,(int)case_sensitive,search_type_values);
    fwrite("</select>\n",1,10,(FILE *)fp0);
    uVar3 = gettext("Security and Privacy");
    if (no_margins == '\0') {
      local_180 = "&nbsp;&nbsp;";
    }
    else {
      local_180 = "";
    }
    fprintf((FILE *)fp0,"\n%s<em>%s</em>\n",local_180,uVar3);
    pcVar2 = will_save_cookies();
    pcVar5 = (char *)gettext("Cookies");
    PutLabel(fp0,pcVar5,pcVar2);
    if (disable_all == '\0') {
      local_17c = "";
    }
    else {
      local_17c = "disabled";
    }
    fprintf((FILE *)fp0,"<select name=\"%s\" %s>\n",cookies_string,local_17c);
    uVar3 = gettext(cookies_ignore_all_string);
    if (LYSetCookies == '\0') {
      local_174 = "selected";
    }
    else {
      local_174 = "";
    }
    fprintf((FILE *)fp0,"<option value=\"%s\" %s>%s\n",cookies_ignore_all_string,local_174,uVar3);
    uVar3 = gettext(cookies_up_to_user_string);
    if ((LYSetCookies == '\0') || (LYAcceptAllCookies != '\0')) {
      local_16c = "";
    }
    else {
      local_16c = "selected";
    }
    fprintf((FILE *)fp0,"<option value=\"%s\" %s>%s\n",cookies_up_to_user_string,local_16c,uVar3);
    uVar3 = gettext(cookies_accept_all_string);
    if ((LYSetCookies == '\0') || (LYAcceptAllCookies == '\0')) {
      local_164 = "";
    }
    else {
      local_164 = "selected";
    }
    fprintf((FILE *)fp0,"<option value=\"%s\" %s>%s\n",cookies_accept_all_string,local_164,uVar3);
    fwrite("</select>\n",1,10,(FILE *)fp0);
    pcVar2 = cookie_prompt_string;
    pcVar5 = (char *)gettext("Invalid-Cookie Prompting");
    PutLabel(fp0,pcVar5,pcVar2);
    if (disable_all == '\0') {
      local_160 = "";
    }
    else {
      local_160 = "disabled";
    }
    fprintf((FILE *)fp0,"<select name=\"%s\" %s>\n",cookie_prompt_string,local_160,uVar3);
    PutOptValues(fp0,cookie_noprompt,prompt_values);
    fwrite("</select>\n",1,10,(FILE *)fp0);
    uVar3 = gettext("Keyboard Input");
    if (no_margins == '\0') {
      local_158 = "&nbsp;&nbsp;";
    }
    else {
      local_158 = "";
    }
    fprintf((FILE *)fp0,"\n%s<em>%s</em>\n",local_158,uVar3);
    pcVar2 = keypad_mode_string;
    pcVar5 = (char *)gettext("Keypad mode");
    PutLabel(fp0,pcVar5,pcVar2);
    if (disable_all == '\0') {
      local_154 = "";
    }
    else {
      local_154 = "disabled";
    }
    fprintf((FILE *)fp0,"<select name=\"%s\" %s>\n",keypad_mode_string,local_154);
    PutOptValues(fp0,keypad_mode,keypad_mode_values);
    fwrite("</select>\n",1,10,(FILE *)fp0);
    pcVar2 = emacs_keys_string;
    pcVar5 = (char *)gettext("Emacs keys");
    PutLabel(fp0,pcVar5,pcVar2);
    if (disable_all == '\0') {
      local_150 = "";
    }
    else {
      local_150 = "disabled";
    }
    fprintf((FILE *)fp0,"<select name=\"%s\" %s>\n",emacs_keys_string,local_150);
    PutOptValues(fp0,(int)emacs_keys,bool_values);
    fwrite("</select>\n",1,10,(FILE *)fp0);
    pcVar2 = vi_keys_string;
    pcVar5 = (char *)gettext("VI keys");
    PutLabel(fp0,pcVar5,pcVar2);
    if (disable_all == '\0') {
      local_14c = "";
    }
    else {
      local_14c = "disabled";
    }
    fprintf((FILE *)fp0,"<select name=\"%s\" %s>\n",vi_keys_string,local_14c);
    PutOptValues(fp0,(int)vi_keys,bool_values);
    fwrite("</select>\n",1,10,(FILE *)fp0);
    pcVar2 = lineedit_mode_string;
    if (LYLineeditNames[1] != (char *)0x0) {
      pcVar5 = (char *)gettext("Line edit style");
      PutLabel(fp0,pcVar5,pcVar2);
      if (disable_all == '\0') {
        local_148 = "";
      }
      else {
        local_148 = "disabled";
      }
      fprintf((FILE *)fp0,"<select name=\"%s\" %s>\n",lineedit_mode_string,local_148);
      for (i = L'\0'; LYLineeditNames[i] != (char *)0x0; i = i + L'\x01') {
        sprintf(temp,"%d",i);
        uVar3 = gettext(LYLineeditNames[i]);
        if (i == current_lineedit) {
          local_140 = "selected";
        }
        else {
          local_140 = "";
        }
        fprintf((FILE *)fp0,"<option value=\"%s\" %s>%s\n",temp,local_140,uVar3);
      }
      fwrite("</select>\n",1,10,(FILE *)fp0);
    }
    uVar3 = gettext("Display and Character Set");
    if (no_margins == '\0') {
      local_138 = "&nbsp;&nbsp;";
    }
    else {
      local_138 = "";
    }
    fprintf((FILE *)fp0,"\n%s<em>%s</em>\n",local_138,uVar3);
    pcVar2 = locale_charset_string;
    pcVar5 = (char *)gettext("Use locale-based character set");
    PutLabel(fp0,pcVar5,pcVar2);
    if (disable_all == '\0') {
      local_134 = "";
    }
    else {
      local_134 = "disabled";
    }
    fprintf((FILE *)fp0,"<select name=\"%s\" %s>\n",locale_charset_string,local_134);
    PutOptValues(fp0,(int)LYLocaleCharset,bool_values);
    fwrite("</select>\n",1,10,(FILE *)fp0);
    pcVar2 = display_char_set_string;
    pcVar5 = (char *)gettext("Display character set");
    PutLabel(fp0,pcVar5,pcVar2);
    if (disable_all == '\0') {
      if (LYLocaleCharset == '\0') {
        local_12c = "";
      }
      else {
        local_12c = "disabled";
      }
      local_130 = local_12c;
    }
    else {
      local_130 = "disabled";
    }
    fprintf((FILE *)fp0,"<select name=\"%s\" %s>\n",display_char_set_string,local_130);
    for (i = L'\0'; LYchar_set_names[i] != (char *)0x0; i = i + L'\x01') {
      len = strlen(LYchar_set_names[i]);
      if (cset_len < len) {
        cset_len = len;
      }
      sprintf(temp,"%d",i);
      uVar3 = gettext(LYchar_set_names[i]);
      if (i == current_char_set) {
        local_124 = "selected";
      }
      else {
        local_124 = "";
      }
      fprintf((FILE *)fp0,"<option value=\"%s\" %s>%s\n",temp,local_124,uVar3);
    }
    fwrite("</select>\n",1,10,(FILE *)fp0);
    curval = UCLYhndl_for_unspec;
    if (UCLYhndl_for_unspec == current_char_set) {
      curval = safeUCGetLYhndl_byMIME(UCAssume_MIMEcharset);
    }
    pcVar2 = assume_char_set_string;
    pcVar5 = (char *)gettext("Assumed document character set");
    PutLabel(fp0,pcVar5,pcVar2);
    if (disable_all == '\0') {
      local_120 = "";
    }
    else {
      local_120 = "disabled";
    }
    fprintf((FILE *)fp0,"<select name=\"%s\" %s>\n",assume_char_set_string,local_120);
    for (i = L'\0'; i < LYNumCharsets; i = i + L'\x01') {
      uVar3 = gettext(LYCharSet_UC[i].MIMEname);
      if (i == curval) {
        local_118 = "selected";
      }
      else {
        local_118 = "";
      }
      fprintf((FILE *)fp0,"<option value=\"%s\" %s>%s\n",LYCharSet_UC[i].MIMEname,local_118,uVar3);
    }
    fwrite("</select>\n",1,10,(FILE *)fp0);
    pcVar2 = raw_mode_string;
    if (LYHaveCJKCharacterSet == '\0') {
      pcVar5 = (char *)gettext("Raw 8-bit");
      PutLabel(fp0,pcVar5,pcVar2);
    }
    else {
      pcVar5 = (char *)gettext("CJK mode");
      PutLabel(fp0,pcVar5,pcVar2);
    }
    if (disable_all == '\0') {
      local_114 = "";
    }
    else {
      local_114 = "disabled";
    }
    fprintf((FILE *)fp0,"<select name=\"%s\" %s>\n",raw_mode_string,local_114);
    PutOptValues(fp0,(int)LYRawMode,bool_values);
    fwrite("</select>\n",1,10,(FILE *)fp0);
    pcVar2 = x_display_string;
    pcVar5 = (char *)gettext("X Display");
    PutLabel(fp0,pcVar5,pcVar2);
    if (disable_all == '\0') {
      local_110 = "";
    }
    else {
      local_110 = "disabled";
    }
    if (x_display == (char *)0x0) {
      local_10c = "";
    }
    else {
      local_10c = x_display;
    }
    fprintf((FILE *)fp0,"<input size=%d type=\"text\" name=\"%s\" value=\"%s\" %s>\n",text_len,
            x_display_string,local_10c,local_110);
    uVar3 = gettext("Document Appearance");
    if (no_margins == '\0') {
      local_104 = "&nbsp;&nbsp;";
    }
    else {
      local_104 = "";
    }
    fprintf((FILE *)fp0,"\n%s<em>%s</em>\n",local_104,uVar3,local_10c,local_110);
    SetupChosenShowColor();
    pcVar2 = show_color_string;
    pcVar5 = (char *)gettext("Show color");
    PutLabel(fp0,pcVar5,pcVar2);
    if (no_option_save == '\0') {
      if (disable_all == '\0') {
        local_f8 = "";
      }
      else {
        local_f8 = "disabled";
      }
      fprintf((FILE *)fp0,"<select name=\"%s\" %s>\n",show_color_string,local_f8);
      if (can_do_colors == '\0') {
        show_color_values[2].HtmlName = (char *)0x0;
        show_color_values[3].LongName = "Always try";
      }
      else {
        show_color_values[2].HtmlName = "ON";
        show_color_values[3].LongName = "ALWAYS";
      }
      PutOptValues(fp0,LYChosenShowColor,show_color_values);
    }
    else {
      if (disable_all == '\0') {
        if (can_do_colors == '\0') {
          local_fc = "disabled";
        }
        else {
          local_fc = "";
        }
        local_100 = local_fc;
      }
      else {
        local_100 = "disabled";
      }
      fprintf((FILE *)fp0,"<select name=\"%s\" %s>\n",show_color_string,local_100);
      if (LYShowColor == 0) {
        LYShowColor = 1;
      }
      else if (LYShowColor == 3) {
        LYShowColor = 2;
      }
      PutOptValues(fp0,LYShowColor + L'\xffffffff',bool_values);
    }
    fwrite("</select>\n",1,10,(FILE *)fp0);
    pcVar2 = show_cursor_string;
    pcVar5 = (char *)gettext("Show cursor");
    PutLabel(fp0,pcVar5,pcVar2);
    if (disable_all == '\0') {
      local_f4 = "";
    }
    else {
      local_f4 = "disabled";
    }
    fprintf((FILE *)fp0,"<select name=\"%s\" %s>\n",show_cursor_string,local_f4);
    PutOptValues(fp0,(int)LYShowCursor,bool_values);
    fwrite("</select>\n",1,10,(FILE *)fp0);
    pcVar2 = underline_links_string;
    pcVar5 = (char *)gettext("Underline links");
    PutLabel(fp0,pcVar5,pcVar2);
    if (disable_all == '\0') {
      local_f0 = "";
    }
    else {
      local_f0 = "disabled";
    }
    fprintf((FILE *)fp0,"<select name=\"%s\" %s>\n",underline_links_string,local_f0);
    PutOptValues(fp0,(int)LYUnderlineLinks,bool_values);
    fwrite("</select>\n",1,10,(FILE *)fp0);
    pcVar2 = show_scrollbar_string;
    pcVar5 = (char *)gettext("Show scrollbar");
    PutLabel(fp0,pcVar5,pcVar2);
    if (disable_all == '\0') {
      local_ec = "";
    }
    else {
      local_ec = "disabled";
    }
    fprintf((FILE *)fp0,"<select name=\"%s\" %s>\n",show_scrollbar_string,local_ec);
    PutOptValues(fp0,(int)LYShowScrollbar,bool_values);
    fwrite("</select>\n",1,10,(FILE *)fp0);
    pcVar2 = select_popups_string;
    pcVar5 = (char *)gettext("Popups for select fields");
    PutLabel(fp0,pcVar5,pcVar2);
    if (disable_all == '\0') {
      local_e8 = "";
    }
    else {
      local_e8 = "disabled";
    }
    fprintf((FILE *)fp0,"<select name=\"%s\" %s>\n",select_popups_string,local_e8);
    PutOptValues(fp0,(int)LYSelectPopups,bool_values);
    fwrite("</select>\n",1,10,(FILE *)fp0);
    pcVar2 = DTD_recovery_string;
    pcVar5 = (char *)gettext("HTML error recovery");
    PutLabel(fp0,pcVar5,pcVar2);
    if (disable_all == '\0') {
      local_e4 = "";
    }
    else {
      local_e4 = "disabled";
    }
    fprintf((FILE *)fp0,"<select name=\"%s\" %s>\n",DTD_recovery_string,local_e4);
    PutOptValues(fp0,Old_DTD,DTD_type_values);
    fwrite("</select>\n",1,10,(FILE *)fp0);
    pcVar2 = will_save_images();
    pcVar5 = (char *)gettext("Show images");
    PutLabel(fp0,pcVar5,pcVar2);
    if (disable_all == '\0') {
      local_e0 = "";
    }
    else {
      local_e0 = "disabled";
    }
    fprintf((FILE *)fp0,"<select name=\"%s\" %s>\n",images_string,local_e0);
    uVar3 = gettext(images_ignore_all_string);
    if ((pseudo_inline_alts == '\0') && (clickable_images == '\0')) {
      local_d8 = "selected";
    }
    else {
      local_d8 = "";
    }
    fprintf((FILE *)fp0,"<option value=\"%s\" %s>%s\n",images_ignore_all_string,local_d8,uVar3);
    uVar3 = gettext(images_use_label_string);
    if ((pseudo_inline_alts == '\0') || (clickable_images != '\0')) {
      local_d0 = "";
    }
    else {
      local_d0 = "selected";
    }
    fprintf((FILE *)fp0,"<option value=\"%s\" %s>%s\n",images_use_label_string,local_d0,uVar3);
    uVar3 = gettext(images_use_links_string);
    if (clickable_images == '\0') {
      local_c8 = "";
    }
    else {
      local_c8 = "selected";
    }
    fprintf((FILE *)fp0,"<option value=\"%s\" %s>%s\n",images_use_links_string,local_c8,uVar3);
    fwrite("</select>\n",1,10,(FILE *)fp0);
    pcVar2 = verbose_images_string;
    pcVar5 = (char *)gettext("Verbose images");
    PutLabel(fp0,pcVar5,pcVar2);
    if (disable_all == '\0') {
      local_c4 = "";
    }
    else {
      local_c4 = "disabled";
    }
    fprintf((FILE *)fp0,"<select name=\"%s\" %s>\n",verbose_images_string,local_c4,uVar3);
    PutOptValues(fp0,(int)verbose_img,verbose_images_type_values);
    fwrite("</select>\n",1,10,(FILE *)fp0);
    uVar3 = gettext("Headers Transferred to Remote Servers");
    if (no_margins == '\0') {
      local_bc = "&nbsp;&nbsp;";
    }
    else {
      local_bc = "";
    }
    fprintf((FILE *)fp0,"\n%s<em>%s</em>\n",local_bc,uVar3);
    pcVar2 = mail_address_string;
    pcVar5 = (char *)gettext("Personal mail address");
    PutLabel(fp0,pcVar5,pcVar2);
    if (disable_all == '\0') {
      local_b8 = "";
    }
    else {
      local_b8 = "disabled";
    }
    if (personal_mail_address == (char *)0x0) {
      local_b4 = "";
    }
    else {
      local_b4 = personal_mail_address;
    }
    fprintf((FILE *)fp0,"<input size=%d type=\"text\" name=\"%s\" value=\"%s\" %s>\n",text_len,
            mail_address_string,local_b4,local_b8);
    pcVar2 = mail_address_string;
    pcVar5 = (char *)gettext("Password for anonymous ftp");
    PutLabel(fp0,pcVar5,pcVar2);
    if (disable_all == '\0') {
      local_b0 = "";
    }
    else {
      local_b0 = "disabled";
    }
    if (anonftp_password == (char *)0x0) {
      local_ac = "";
    }
    else {
      local_ac = anonftp_password;
    }
    fprintf((FILE *)fp0,"<input size=%d type=\"text\" name=\"%s\" value=\"%s\" %s>\n",text_len,
            anonftp_password_string,local_ac,local_b0);
    pcVar2 = preferred_media_string;
    pcVar5 = (char *)gettext("Preferred media type");
    PutLabel(fp0,pcVar5,pcVar2);
    if (disable_all == '\0') {
      local_a8 = "";
    }
    else {
      local_a8 = "disabled";
    }
    fprintf((FILE *)fp0,"<select name=\"%s\" %s>\n",preferred_media_string,local_a8,local_ac,
            local_b0);
    PutOptValues(fp0,LYAcceptMedia,media_values);
    fwrite("</select>\n",1,10,(FILE *)fp0);
    pcVar2 = preferred_encoding_string;
    pcVar5 = (char *)gettext("Preferred encoding");
    PutLabel(fp0,pcVar5,pcVar2);
    if (disable_all == '\0') {
      local_a4 = "";
    }
    else {
      local_a4 = "disabled";
    }
    fprintf((FILE *)fp0,"<select name=\"%s\" %s>\n",preferred_encoding_string,local_a4);
    PutOptValues(fp0,LYAcceptEncoding,encoding_values);
    fwrite("</select>\n",1,10,(FILE *)fp0);
    pcVar2 = preferred_doc_char_string;
    pcVar5 = (char *)gettext("Preferred document character set");
    PutLabel(fp0,pcVar5,pcVar2);
    if (disable_all == '\0') {
      local_a0 = "";
    }
    else {
      local_a0 = "disabled";
    }
    if (pref_charset == (char *)0x0) {
      local_9c = "";
    }
    else {
      local_9c = pref_charset;
    }
    fprintf((FILE *)fp0,"<input size=%d type=\"text\" name=\"%s\" value=\"%s\" %s>\n",cset_len + 2,
            preferred_doc_char_string,local_9c,local_a0);
    pcVar2 = preferred_doc_lang_string;
    pcVar5 = (char *)gettext("Preferred document language");
    PutLabel(fp0,pcVar5,pcVar2);
    if (disable_all == '\0') {
      local_98 = "";
    }
    else {
      local_98 = "disabled";
    }
    if (language == (char *)0x0) {
      local_94 = "";
    }
    else {
      local_94 = language;
    }
    fprintf((FILE *)fp0,"<input size=%d type=\"text\" name=\"%s\" value=\"%s\" %s>\n",cset_len + 2,
            preferred_doc_lang_string,local_94,local_98);
    pcVar2 = user_agent_string;
    if (no_useragent == '\0') {
      pcVar5 = (char *)gettext("User-Agent header");
      PutLabel(fp0,pcVar5,pcVar2);
      if (disable_all == '\0') {
        local_90 = "";
      }
      else {
        local_90 = "disabled";
      }
      if (LYUserAgent == (char *)0x0) {
        local_8c = "";
      }
      else {
        local_8c = LYUserAgent;
      }
      fprintf((FILE *)fp0,"<input size=%d type=\"text\" name=\"%s\" value=\"%s\" %s>\n",text_len,
              user_agent_string,local_8c,local_90);
      local_94 = local_8c;
      local_98 = local_90;
    }
    uVar3 = gettext("Listing and Accessing Files");
    if (no_margins == '\0') {
      local_84 = "&nbsp;&nbsp;";
    }
    else {
      local_84 = "";
    }
    fprintf((FILE *)fp0,"\n%s<em>%s</em>\n",local_84,uVar3,local_94,local_98);
    pcVar2 = passive_ftp_string;
    pcVar5 = (char *)gettext("Use Passive FTP");
    PutLabel(fp0,pcVar5,pcVar2);
    if (disable_all == '\0') {
      local_80 = "";
    }
    else {
      local_80 = "disabled";
    }
    fprintf((FILE *)fp0,"<select name=\"%s\" %s>\n",passive_ftp_string,local_80);
    PutOptValues(fp0,(int)ftp_passive,bool_values);
    fwrite("</select>\n",1,10,(FILE *)fp0);
    pcVar2 = ftp_sort_string;
    pcVar5 = (char *)gettext("FTP sort criteria");
    PutLabel(fp0,pcVar5,pcVar2);
    if (disable_all == '\0') {
      local_7c = "";
    }
    else {
      local_7c = "disabled";
    }
    fprintf((FILE *)fp0,"<select name=\"%s\" %s>\n",ftp_sort_string,local_7c);
    PutOptValues(fp0,HTfileSortMethod,ftp_sort_values);
    fwrite("</select>\n",1,10,(FILE *)fp0);
    pcVar2 = dired_list_string;
    pcVar5 = (char *)gettext("Local directory sort criteria");
    PutLabel(fp0,pcVar5,pcVar2);
    if (disable_all == '\0') {
      local_78 = "";
    }
    else {
      local_78 = "disabled";
    }
    fprintf((FILE *)fp0,"<select name=\"%s\" %s>\n",dired_list_string,local_78);
    PutOptValues(fp0,dir_list_style,dired_list_values);
    fwrite("</select>\n",1,10,(FILE *)fp0);
    pcVar2 = dired_sort_string;
    pcVar5 = (char *)gettext("Local directory sort order");
    PutLabel(fp0,pcVar5,pcVar2);
    if (disable_all == '\0') {
      local_74 = "";
    }
    else {
      local_74 = "disabled";
    }
    fprintf((FILE *)fp0,"<select name=\"%s\" %s>\n",dired_sort_string,local_74);
    PutOptValues(fp0,dir_list_order,dired_sort_values);
    fwrite("</select>\n",1,10,(FILE *)fp0);
    pcVar2 = show_dotfiles_string;
    if (no_dotfiles == '\0') {
      pcVar5 = (char *)gettext("Show dot files");
      PutLabel(fp0,pcVar5,pcVar2);
      if (disable_all == '\0') {
        local_70 = "";
      }
      else {
        local_70 = "disabled";
      }
      fprintf((FILE *)fp0,"<select name=\"%s\" %s>\n",show_dotfiles_string,local_70);
      PutOptValues(fp0,(int)show_dotfiles,bool_values);
      fwrite("</select>\n",1,10,(FILE *)fp0);
    }
    pcVar2 = show_rate_string;
    pcVar5 = (char *)gettext("Show transfer rate");
    PutLabel(fp0,pcVar5,pcVar2);
    if (disable_all == '\0') {
      local_6c = "";
    }
    else {
      local_6c = "disabled";
    }
    fprintf((FILE *)fp0,"<select name=\"%s\" %s>\n",show_rate_string,local_6c);
    for (i = L'\0'; rate_values[i].LongName != (char *)0x0; i = i + L'\x01') {
      message = (char *)0x0;
      pcVar2 = HTProgressUnits(rate_values[i].value);
      HTSprintf0(&message,rate_values[i].LongName,pcVar2);
      uVar3 = gettext(message);
      if (rate_values[i].value == LYTransferRate) {
        local_64 = "selected";
      }
      else {
        local_64 = "";
      }
      fprintf((FILE *)fp0,"<option value=\"%s\" %s>%s\n",rate_values[i].HtmlName,local_64,uVar3);
      if (message != (char *)0x0) {
        free(message);
        message = (char *)0x0;
      }
    }
    fwrite("</select>\n",1,10,(FILE *)fp0);
    uVar3 = gettext("Special Files and Screens");
    if (no_margins == '\0') {
      local_5c = "&nbsp;&nbsp;";
    }
    else {
      local_5c = "";
    }
    fprintf((FILE *)fp0,"\n%s<em>%s</em>\n",local_5c,uVar3);
    pcVar2 = mbm_string;
    if (LYMBMBlocked == '\0') {
      pcVar5 = (char *)gettext("Multi-bookmarks");
      PutLabel(fp0,pcVar5,pcVar2);
      if (disable_all == '\0') {
        local_58 = "";
      }
      else {
        local_58 = "disabled";
      }
      fprintf((FILE *)fp0,"<select name=\"%s\" %s>\n",mbm_string,local_58);
      PutOptValues(fp0,LYMultiBookmarks,mbm_values);
      fwrite("</select>\n",1,10,(FILE *)fp0);
    }
    pcVar5 = single_bookmark_string;
    pcVar2 = mbm_string;
    if (LYMultiBookmarks == 0) {
      pcVar2 = (char *)gettext("Bookmarks file");
      PutLabel(fp0,pcVar2,pcVar5);
      if (disable_all == '\0') {
        local_54 = "";
      }
      else {
        local_54 = "disabled";
      }
      if (bookmark_page == (char *)0x0) {
        local_50 = "";
      }
      else {
        local_50 = bookmark_page;
      }
      fprintf((FILE *)fp0,"<input size=%d type=\"text\" name=\"%s\" value=\"%s\" %s>\n",text_len,
              single_bookmark_string,local_50,local_54);
    }
    else {
      pcVar5 = (char *)gettext("Review/edit Bookmarks files");
      PutLabel(fp0,pcVar5,pcVar2);
      uVar3 = gettext("Goto multi-bookmark menu");
      fprintf((FILE *)fp0,"<a href=\"%s\">%s</a>\n","LYNXOPTIONS://MBM_MENU",uVar3);
    }
    pcVar2 = visited_links_string;
    pcVar5 = (char *)gettext("Visited Pages");
    PutLabel(fp0,pcVar5,pcVar2);
    LYMenuVisitedLinks(fp0,(int)disable_all);
    if (no_lynxcfg_info == '\0') {
      uVar3 = gettext("View the file ");
      fprintf((FILE *)fp0,"\n  %s<a href=\"%s\">lynx.cfg</a>.\n",uVar3,"LYNXCFG:");
    }
    fwrite("\n</pre>\n",1,8,(FILE *)fp0);
    if (disable_all == '\0') {
      fwrite("<p align=center>\n",1,0x11,(FILE *)fp0);
      uVar3 = gettext("Accept Changes");
      fprintf((FILE *)fp0,"<input type=\"submit\" value=\"%s\"> - \n",uVar3);
      uVar3 = gettext("Reset Changes");
      fprintf((FILE *)fp0,"<input type=\"reset\" value=\"%s\"> - \n",uVar3);
      uVar3 = gettext("Left Arrow cancels changes");
      fprintf((FILE *)fp0,"%s\n",uVar3);
    }
    fwrite("</form>\n",1,8,(FILE *)fp0);
    EndInternalPage(fp0);
    LYCloseTempFP(fp0);
    local_1a4 = L'\x01';
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return local_1a4;
}



// WARNING: Unknown calling convention

BOOLEAN is_true(char *string)

{
  int iVar1;
  
  iVar1 = strcasecomp(string,"TRUE");
  if ((iVar1 != 0) && (iVar1 = strcasecomp(string,"ON"), iVar1 != 0)) {
    return '\0';
  }
  return '\x01';
}



// WARNING: Unknown calling convention

char * find_colon(char *buffer)

{
  char cVar1;
  char *buf;
  char ch;
  
  buf = buffer;
  if (buffer != (char *)0x0) {
    for (; cVar1 = *buf, cVar1 != '\0'; buf = buf + 1) {
      if (cVar1 == ':') {
        return buf;
      }
      if ((cVar1 == '\\') && (buf = buf + 1, *buf == '\0')) {
        return (char *)0x0;
      }
    }
  }
  return (char *)0x0;
}



// WARNING: Unknown calling convention

void free_item_list(lynx_list_item_type **ptr)

{
  _lynx_list_item_type *p_Var1;
  lynx_list_item_type *next;
  lynx_list_item_type *cur;
  
  p_Var1 = *ptr;
  while (cur = p_Var1, cur != (lynx_list_item_type *)0x0) {
    p_Var1 = cur->next;
    if (cur->name != (char *)0x0) {
      free(cur->name);
      cur->name = (char *)0x0;
    }
    if (cur->command != (char *)0x0) {
      free(cur->command);
      cur->command = (char *)0x0;
    }
    if (cur != (lynx_list_item_type *)0x0) {
      free(cur);
    }
  }
  *ptr = (lynx_list_item_type *)0x0;
  return;
}



// WARNING: Unknown calling convention

void free_all_item_lists(void)

{
  free_item_list(&printers);
  free_item_list(&downloaders);
  free_item_list(&uploaders);
  free_item_list(&externals);
  return;
}



// WARNING: Unknown calling convention

void add_item_to_list(char *buffer,lynx_list_item_type **list_ptr,int special)

{
  BOOLEAN BVar1;
  char *pcVar2;
  int iVar3;
  char *pcVar4;
  size_t sVar5;
  wchar_t wVar6;
  lynx_list_item_type *prev_item;
  lynx_list_item_type *cur_item;
  char *last_colon;
  char *next_colon;
  char *colon;
  
  pcVar2 = strrchr(buffer,0x3a);
  if ((pcVar2 != (char *)0x0) && (pcVar2[-1] != '\\')) {
    *pcVar2 = '\0';
    iVar3 = strcasecomp(pcVar2 + 1,"XWINDOWS");
    if (iVar3 == 0) {
      pcVar2 = LYgetXDisplay();
      if (pcVar2 == (char *)0x0) {
        return;
      }
    }
    else {
      iVar3 = strcasecomp(pcVar2 + 1,"NON_XWINDOWS");
      if ((iVar3 == 0) && (pcVar2 = LYgetXDisplay(), pcVar2 != (char *)0x0)) {
        return;
      }
    }
  }
  if (*list_ptr == (lynx_list_item_type *)0x0) {
    cur_item = (lynx_list_item_type *)calloc(1,0x18);
    if (cur_item == (lynx_list_item_type *)0x0) {
      outofmem("./LYReadCFG.c","read_cfg");
    }
    *list_ptr = cur_item;
  }
  else {
    for (prev_item = *list_ptr; prev_item->next != (_lynx_list_item_type *)0x0;
        prev_item = prev_item->next) {
    }
    cur_item = (lynx_list_item_type *)calloc(1,0x18);
    if (cur_item == (_lynx_list_item_type *)0x0) {
      outofmem("./LYReadCFG.c","read_cfg");
    }
    else {
      prev_item->next = cur_item;
    }
  }
  cur_item->next = (_lynx_list_item_type *)0x0;
  cur_item->name = (char *)0x0;
  cur_item->command = (char *)0x0;
  cur_item->always_enabled = L'\0';
  cur_item->override_primary_action = '\0';
  cur_item->pagelen = L'B';
  pcVar2 = find_colon(buffer);
  if (pcVar2 != (char *)0x0) {
    pcVar4 = (char *)calloc((size_t)(pcVar2 + (1 - (int)buffer)),1);
    cur_item->name = pcVar4;
    if (cur_item->name == (char *)0x0) {
      outofmem("./LYReadCFG.c","read_cfg");
    }
    LYstrncpy(cur_item->name,buffer,(int)pcVar2 - (int)buffer);
    remove_backslashes(cur_item->name);
    next_colon = find_colon(pcVar2 + 1);
    if (next_colon == (char *)0x0) {
      sVar5 = strlen(pcVar2);
      next_colon = pcVar2 + sVar5;
    }
    if (next_colon != pcVar2 + 1 && -1 < (int)next_colon - (int)(pcVar2 + 1)) {
      pcVar4 = (char *)calloc((int)next_colon - (int)pcVar2,1);
      cur_item->command = pcVar4;
      if (cur_item->command == (char *)0x0) {
        outofmem("./LYReadCFG.c","read_cfg");
      }
      LYstrncpy(cur_item->command,pcVar2 + 1,(int)next_colon - (int)(pcVar2 + 1));
      remove_backslashes(cur_item->command);
    }
    pcVar2 = next_colon + 1;
    if (*next_colon != '\0') {
      next_colon = strchr(pcVar2,0x3a);
      if (next_colon != (char *)0x0) {
        *next_colon = '\0';
        next_colon = next_colon + 1;
      }
      BVar1 = is_true(pcVar2);
      cur_item->always_enabled = (int)BVar1;
      if (next_colon != (char *)0x0) {
        if (special == 0) {
          BVar1 = is_true(next_colon);
          cur_item->override_primary_action = BVar1;
        }
        else {
          wVar6 = atoi(next_colon);
          cur_item->pagelen = wVar6;
        }
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

lynx_list_item_type * find_item_by_number(lynx_list_item_type *list_ptr,char *number)

{
  int value;
  
  value = atoi(number);
  for (; (-1 < value && (list_ptr != (lynx_list_item_type *)0x0)); list_ptr = list_ptr->next) {
    value = value + -1;
  }
  return list_ptr;
}



int match_item_by_name(lynx_list_item_type *ptr,char *name,BOOLEAN only_overriders)

{
  size_t n;
  int iVar1;
  BOOLEAN only_overriders_local;
  
  if (ptr->command != (char *)0x0) {
    n = strlen(ptr->name);
    iVar1 = strncasecomp(ptr->name,name,n);
    if ((iVar1 == 0) && ((only_overriders == '\0' || (ptr->override_primary_action != '\0')))) {
      return 1;
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

int check_color(char *color,int the_default)

{
  FILE *pFVar1;
  int iVar2;
  int local_18;
  int c;
  int i;
  
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
    pFVar1 = TraceFP();
    fprintf((FILE *)pFVar1,"check_color(%s,%d)\n",color,the_default);
  }
  iVar2 = strcasecomp(color,"default");
  if (iVar2 == 0) {
    if ((LYuse_default_colors != '\0') && (default_color_reset == '\0')) {
      the_default = -1;
    }
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
      pFVar1 = TraceFP();
      fprintf((FILE *)pFVar1,"=> default %d\n",the_default);
    }
    local_18 = the_default;
  }
  else {
    iVar2 = strcasecomp(color,"nocolor");
    if (iVar2 == 0) {
      local_18 = -2;
    }
    else {
      for (i = 0; i < 0x10; i = i + 1) {
        iVar2 = strcasecomp(color,Color_Strings[i]);
        if (iVar2 == 0) {
          if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
            pFVar1 = TraceFP();
            fprintf((FILE *)pFVar1,"=> %d\n",i);
          }
          return i;
        }
      }
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
        pFVar1 = TraceFP();
        fprintf((FILE *)pFVar1,"=> ERR_COLOR\n");
      }
      local_18 = -3;
    }
  }
  return local_18;
}



// WARNING: Unknown calling convention

char * lookup_color(int code)

{
  uint n;
  
  n = 0;
  while( true ) {
    if (0xf < n) {
      return "default";
    }
    if (n == code) break;
    n = n + 1;
  }
  return Color_Strings[n];
}



// WARNING: Unknown calling convention

void exit_with_color_syntax(char *error_line)

{
  char *__format;
  undefined4 uVar1;
  uint i;
  
  __format = (char *)gettext(
                            "Syntax Error parsing COLOR in configuration file:\nThe line must be of the form:\nCOLOR:INTEGER:FOREGROUND:BACKGROUND\n\nHere FOREGROUND and BACKGROUND must be one of:\nThe special strings \'nocolor\' or \'default\', or\n"
                            );
  fprintf(stderr,__format);
  for (i = 0; i < 0x10; i = i + 4) {
    fprintf(stderr,"%16s %16s %16s %16s\n",Color_Strings[i],Color_Strings[i + 1],
            Color_Strings[i + 2],Color_Strings[i + 3]);
  }
  uVar1 = gettext("Offending line:");
  fprintf(stderr,"%s\nCOLOR:%s\n",uVar1,error_line);
  exit_immediately(1);
  return;
}



// WARNING: Unknown calling convention

void parse_color(char *buffer)

{
  wchar_t wVar1;
  wchar_t fg_00;
  char *temp;
  char *bg;
  char *fg;
  int color;
  
  temp = (char *)0x0;
  HTSACopy(&temp,buffer);
  color = atoi(buffer);
  fg = find_colon(buffer);
  if (fg == (char *)0x0) {
    exit_with_color_syntax(temp);
  }
  *fg = '\0';
  fg = fg + 1;
  bg = find_colon(fg);
  if (bg == (char *)0x0) {
    exit_with_color_syntax(temp);
  }
  *bg = '\0';
  bg = bg + 1;
  wVar1 = check_color(bg,default_bg);
  fg_00 = check_color(fg,default_fg);
  wVar1 = lynx_chg_color(color,fg_00,wVar1);
  if (wVar1 < L'\0') {
    exit_with_color_syntax(temp);
  }
  if (temp != (char *)0x0) {
    free(temp);
  }
  return;
}



// WARNING: Unknown calling convention

int assume_charset_fun(char *value)

{
  UCLYhndl_for_unspec = safeUCGetLYhndl_byMIME(value);
  HTSACopy(&UCAssume_MIMEcharset,LYCharSet_UC[UCLYhndl_for_unspec].MIMEname);
  return 0;
}



// WARNING: Unknown calling convention

int assume_local_charset_fun(char *value)

{
  UCLYhndl_HTFile_for_unspec = safeUCGetLYhndl_byMIME(value);
  return 0;
}



// WARNING: Unknown calling convention

int assume_unrec_charset_fun(char *value)

{
  UCLYhndl_for_unrec = safeUCGetLYhndl_byMIME(value);
  return 0;
}



// WARNING: Unknown calling convention

int character_set_fun(char *value)

{
  int iVar1;
  int i;
  
  iVar1 = UCGetLYhndl_byAnyName(value);
  if (-1 < iVar1) {
    current_char_set = iVar1;
  }
  return 0;
}



// WARNING: Unknown calling convention

int outgoing_mail_charset_fun(char *value)

{
  outgoing_mail_charset = UCGetLYhndl_byMIME(value);
  return 0;
}



// WARNING: Unknown calling convention

int assumed_color_fun(char *buffer)

{
  FILE *__stream;
  char *temp;
  char *bg;
  char *fg;
  
  fg = buffer;
  temp = (char *)0x0;
  if (LYuse_default_colors == '\0') {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"...ignored since DEFAULT_COLORS:off\n");
    }
  }
  else {
    HTSACopy(&temp,buffer);
    bg = find_colon(fg);
    if (bg == (char *)0x0) {
      exit_with_color_syntax(temp);
    }
    *bg = '\0';
    bg = bg + 1;
    default_fg = check_color(fg,default_fg);
    default_bg = check_color(bg,default_bg);
    if ((default_fg == -3) || (default_bg == -3)) {
      exit_with_color_syntax(temp);
    }
    if (temp != (char *)0x0) {
      free(temp);
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

int color_fun(char *value)

{
  parse_color(value);
  return 0;
}



// WARNING: Unknown calling convention

int default_colors_fun(char *value)

{
  LYuse_default_colors = is_true(value);
  if (LYuse_default_colors == '\0') {
    default_color_reset = '\x01';
    if ((default_fg == -1) || (default_bg == -1)) {
      default_fg = 7;
      default_bg = 0;
      lynx_setup_colors();
    }
  }
  else {
    default_fg = -1;
    default_bg = -1;
  }
  return 0;
}



// WARNING: Unknown calling convention

int default_bookmark_file_fun(char *value)

{
  set_default_bookmark_page(value);
  return 0;
}



// WARNING: Unknown calling convention

int default_cache_size_fun(char *value)

{
  HTCacheSize = atoi(value);
  if (HTCacheSize < 2) {
    HTCacheSize = 2;
  }
  return 0;
}



// WARNING: Unknown calling convention

int default_editor_fun(char *value)

{
  if (system_editor == '\0') {
    HTSACopy(&editor,value);
  }
  return 0;
}



// WARNING: Unknown calling convention

int numbers_as_arrows_fun(char *value)

{
  BOOLEAN BVar1;
  
  BVar1 = is_true(value);
  keypad_mode = (int)(BVar1 == '\0');
  return 0;
}



// WARNING: Unknown calling convention

int dired_menu_fun(char *value)

{
  add_menu_item(value);
  return 0;
}



// WARNING: Unknown calling convention

int jumpfile_fun(char *value)

{
  char *pcVar1;
  BOOLEAN BVar2;
  FILE *__stream;
  char *buffer;
  
  buffer = (char *)0x0;
  HTSprintf0(&buffer,"JUMPFILE:%s",value);
  BVar2 = LYJumpInit(buffer);
  pcVar1 = buffer;
  if ((BVar2 == '\0') && (WWW_TraceFlag != '\0')) {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"Failed to register %s\n",pcVar1);
  }
  if (buffer != (char *)0x0) {
    free(buffer);
  }
  return 0;
}



// WARNING: Restarted to delay deadcode elimination for space: stack
// WARNING: Unknown calling convention

int keymap_fun(char *key)

{
  char *pcVar1;
  char *pcVar2;
  int iVar3;
  uint uVar4;
  char *local_2c;
  char **endp;
  char *sselect_edi;
  int select_edi;
  int lec;
  int lkc;
  char *efunc;
  char *func;
  BOOLEAN success;
  
  pcVar1 = strchr(key,0x3a);
  if (pcVar1 != (char *)0x0) {
    *pcVar1 = '\0';
    func = pcVar1 + 1;
    efunc = strchr(func,0x3a);
    if (efunc == func) {
      func = (char *)0x0;
    }
    else {
      if ((efunc != (char *)0x0) && (iVar3 = strncasecomp(efunc + 1,"DIRED",5), iVar3 == 0)) {
        pcVar1 = strtok(func," \t\n:#");
        iVar3 = remap(key,pcVar1,'\x01');
        if (iVar3 == 0) {
          pcVar1 = efunc + 1;
          pcVar2 = (char *)gettext("key remapping of %s to %s for %s failed\n");
          fprintf(stderr,pcVar2,key,func,pcVar1);
          return 0;
        }
        if (func == (char *)0x0) {
          return 0;
        }
        iVar3 = strcmp("TOGGLE_HELP",func);
        if (iVar3 != 0) {
          return 0;
        }
        LYUseNoviceLineTwo = '\0';
        return 0;
      }
      pcVar1 = strtok(func," \t\n:#");
      iVar3 = remap(key,pcVar1,'\0');
      if (iVar3 == 0) {
        pcVar1 = (char *)gettext("key remapping of %s to %s failed\n");
        fprintf(stderr,pcVar1,key,func);
      }
      else if ((func != (char *)0x0) && (iVar3 = strcmp("TOGGLE_HELP",func), iVar3 == 0)) {
        LYUseNoviceLineTwo = '\0';
      }
    }
    if (efunc != (char *)0x0) {
      efunc = efunc + 1;
      local_2c = efunc;
      if (func != (char *)0x0) {
        local_2c = (char *)0x0;
      }
      pcVar1 = strtok(local_2c," \t\n:#");
      if ((pcVar1 == efunc) && (*efunc != '\0')) {
        success = '\0';
        lkc = lkcstring_to_lkc(key);
        lec = -1;
        select_edi = 0;
        sselect_edi = strtok((char *)0x0," \t\n:#");
        if (sselect_edi != (char *)0x0) {
          if (*sselect_edi != '\0') {
            select_edi = strtol(sselect_edi,&sselect_edi,10);
          }
          pcVar1 = sselect_edi;
          if (*sselect_edi != '\0') {
            pcVar2 = (char *)gettext("invalid line-editor selection %s for key %s, selecting all\n")
            ;
            fprintf(stderr,pcVar2,pcVar1,key);
            select_edi = 0;
          }
        }
        if ((success == '\0') && (iVar3 = strcasecomp(efunc,"PASS!"), iVar3 == 0)) {
          if (func != (char *)0x0) {
            uVar4 = lacname_to_lac(func);
            lec = uVar4 | 0x1000;
            success = LYRemapEditBinding(lkc,lec,select_edi);
          }
          if (success != '\0') {
            return 0;
          }
          pcVar1 = (char *)gettext(
                                  "setting of line-editor binding for key %s (0x%x) to 0x%x for %s failed\n"
                                  );
          fprintf(stderr,pcVar1,key,lkc,lec,efunc);
        }
        if (success == '\0') {
          lec = lecname_to_lec(efunc);
          success = LYRemapEditBinding(lkc,lec,select_edi);
        }
        if (success == '\0') {
          if (lec == -1) {
            pcVar1 = (char *)gettext(
                                    "setting of line-editor binding for key %s (0x%x) for %s failed\n"
                                    );
            fprintf(stderr,pcVar1,key,lkc,efunc);
          }
          else {
            pcVar1 = (char *)gettext(
                                    "setting of line-editor binding for key %s (0x%x) to 0x%x for %s failed\n"
                                    );
            fprintf(stderr,pcVar1,key,lkc,lec,efunc);
          }
        }
      }
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

int localhost_alias_fun(char *value)

{
  LYAddLocalhostAlias(value);
  return 0;
}



// WARNING: Unknown calling convention

int lynxcgi_environment_fun(char *value)

{
  add_lynxcgi_environment(value);
  return 0;
}



int lynx_sig_file_fun(char *value)

{
  int iVar1;
  char *pcVar2;
  BOOLEAN BVar3;
  FILE *pFVar4;
  int in_GS_OFFSET;
  char *value_local;
  char temp [256];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  LYstrncpy(temp,value,L'');
  BVar3 = LYPathOffHomeOK(temp,0x100);
  if (BVar3 == '\0') {
    if (WWW_TraceFlag != '\0') {
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"LYNX_SIG_FILE \'%s\' is bad. Ignoring.\n",".lynxsig");
    }
  }
  else {
    HTSACopy(&LynxSigFile,temp);
    LYAddPathToHome(temp,0x100,LynxSigFile);
    HTSACopy(&LynxSigFile,temp);
    pcVar2 = LynxSigFile;
    if (WWW_TraceFlag != '\0') {
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"LYNX_SIG_FILE set to \'%s\'\n",pcVar2);
    }
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return 0;
}



// WARNING: Unknown calling convention

int news_chunk_size_fun(char *value)

{
  HTNewsChunkSize = atoi(value);
  if (HTNewsMaxChunk < HTNewsChunkSize) {
    HTNewsMaxChunk = HTNewsChunkSize;
  }
  return 0;
}



// WARNING: Unknown calling convention

int news_max_chunk_fun(char *value)

{
  HTNewsMaxChunk = atoi(value);
  if (HTNewsMaxChunk < HTNewsChunkSize) {
    HTNewsChunkSize = HTNewsMaxChunk;
  }
  return 0;
}



// WARNING: Unknown calling convention

int news_posting_fun(char *value)

{
  LYNewsPosting = is_true(value);
  no_newspost = LYNewsPosting == '\0';
  return 0;
}



// WARNING: Unknown calling convention

int cern_rulesfile_fun(char *value)

{
  int iVar1;
  char *__format;
  char *local_18;
  char *rulesfile2;
  char *rulesfile1;
  
  rulesfile1 = (char *)0x0;
  rulesfile2 = (char *)0x0;
  iVar1 = HTLoadRules(value);
  if (iVar1 < 0) {
    HTSACopy(&rulesfile1,value);
    LYTrimLeading(value);
    LYTrimTrailing(value);
    HTSACopy(&rulesfile2,value);
    LYTildeExpand(&rulesfile2,'\0');
    iVar1 = strcmp(rulesfile1,rulesfile2);
    if ((iVar1 == 0) || (iVar1 = HTLoadRules(rulesfile2), iVar1 < 0)) {
      if ((rulesfile2 == (char *)0x0) || (*rulesfile2 == '\0')) {
        local_18 = (char *)gettext("(no name)");
      }
      else {
        local_18 = rulesfile2;
      }
      __format = (char *)gettext("Lynx: cannot start, CERN rules file %s is not available\n");
      fprintf(stderr,__format,local_18);
      exit_immediately(1);
    }
    else {
      if (rulesfile1 != (char *)0x0) {
        free(rulesfile1);
        rulesfile1 = (char *)0x0;
      }
      if (rulesfile2 != (char *)0x0) {
        free(rulesfile2);
      }
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

int referer_with_query_fun(char *value)

{
  int iVar1;
  
  iVar1 = strncasecomp(value,"SEND",4);
  if (iVar1 == 0) {
    LYRefererWithQuery = 'S';
  }
  else {
    iVar1 = strncasecomp(value,"PARTIAL",7);
    if (iVar1 == 0) {
      LYRefererWithQuery = 'P';
    }
    else {
      LYRefererWithQuery = 'D';
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

int suffix_fun(char *value)

{
  size_t sVar1;
  FILE *pFVar2;
  char *pcVar3;
  char *local_38;
  double df;
  double q;
  char *description;
  char *sq;
  char *encoding;
  char *p;
  char *mime_type;
  
  encoding = (char *)0x0;
  sq = (char *)0x0;
  description = (char *)0x0;
  sVar1 = strlen(value);
  if ((sVar1 < 3) || (mime_type = strchr(value,0x3a), mime_type == (char *)0x0)) {
    if (WWW_TraceFlag != '\0') {
      pFVar2 = TraceFP();
      fprintf((FILE *)pFVar2,"Invalid SUFFIX:%s ignored.\n",value);
    }
  }
  else {
    *mime_type = '\0';
    mime_type = mime_type + 1;
    if ((*mime_type != '\0') && (encoding = strchr(mime_type,0x3a), encoding != (char *)0x0)) {
      *encoding = '\0';
      encoding = encoding + 1;
      sq = strchr(encoding,0x3a);
      if (sq != (char *)0x0) {
        *sq = '\0';
        sq = sq + 1;
        description = strchr(sq,0x3a);
        if (description != (char *)0x0) {
          *description = '\0';
          description = description + 1;
          p = strchr(sq,0x3a);
          if (p != (char *)0x0) {
            *p = '\0';
          }
          LYTrimTail(description);
        }
        LYRemoveBlanks(sq);
        if (*sq == '\0') {
          sq = (char *)0x0;
        }
      }
      LYRemoveBlanks(encoding);
      LYLowerCase(encoding);
      if (*encoding == '\0') {
        encoding = (char *)0x0;
      }
    }
    LYRemoveBlanks(mime_type);
    if (*mime_type == '\0') {
      if (WWW_TraceFlag != '\0') {
        if (encoding == (char *)0x0) {
          local_38 = "what?";
        }
        else {
          local_38 = encoding;
        }
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2,"SUFFIX:%s without MIME type for %s\n",value,local_38);
      }
      mime_type = (char *)0x0;
      if (encoding == (char *)0x0) {
        return 0;
      }
    }
    if (encoding == (char *)0x0) {
      pcVar3 = strstr(mime_type,"tex");
      if ((((pcVar3 == (char *)0x0) &&
           (pcVar3 = strstr(mime_type,"postscript"), pcVar3 == (char *)0x0)) &&
          (pcVar3 = strstr(mime_type,"sh"), pcVar3 == (char *)0x0)) &&
         ((pcVar3 = strstr(mime_type,"troff"), pcVar3 == (char *)0x0 &&
          (pcVar3 = strstr(mime_type,"rtf"), pcVar3 == (char *)0x0)))) {
        encoding = "binary";
      }
      else {
        encoding = "8bit";
      }
    }
    if (sq == (char *)0x0) {
      q = 1.0;
    }
    else {
      q = strtod(sq,&p);
      if ((p == sq) && (q <= 0.0)) {
        if (WWW_TraceFlag != '\0') {
          pFVar2 = TraceFP();
          fprintf((FILE *)pFVar2,"Invalid q=%s for SUFFIX:%s, using -1.0\n",sq,value);
        }
        q = -1.0;
      }
    }
    HTSetSuffix5(value,mime_type,encoding,description,q);
  }
  return 0;
}



// WARNING: Unknown calling convention

int suffix_order_fun(char *value)

{
  int iVar1;
  FILE *__stream;
  char *a;
  char *optn;
  char *p;
  BOOLEAN want_file_init_now;
  
  p = value;
  want_file_init_now = '\0';
  LYUseBuiltinSuffixes = '\x01';
LAB_080a7adf:
  do {
    a = HTNextTok(&p,", ","",(char *)0x0);
    if (a == (char *)0x0) {
LAB_080a7b0f:
      if ((want_file_init_now != '\0') && (FileInitAlreadyDone == '\0')) {
        HTFileInit();
        FileInitAlreadyDone = '\x01';
      }
      return 0;
    }
    iVar1 = strcasecomp(a,"NO_BUILTIN");
    if (iVar1 != 0) {
      iVar1 = strcasecomp(a,"PRECEDENCE_HERE");
      if (iVar1 == 0) {
        want_file_init_now = '\x01';
      }
      else {
        iVar1 = strcasecomp(a,"PRECEDENCE_OTHER");
        if (iVar1 != 0) {
          if (WWW_TraceFlag != '\0') {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"Invalid SUFFIX_ORDER:%s\n",a);
          }
          goto LAB_080a7b0f;
        }
        want_file_init_now = '\0';
      }
      goto LAB_080a7adf;
    }
    LYUseBuiltinSuffixes = '\0';
  } while( true );
}



// WARNING: Unknown calling convention

int system_editor_fun(char *value)

{
  HTSACopy(&editor,value);
  system_editor = '\x01';
  return 0;
}



// WARNING: Unknown calling convention

int viewer_fun(char *value)

{
  size_t sVar1;
  char *pcVar2;
  char *pcVar3;
  int iVar4;
  char *environment;
  char *viewer;
  char *mime_type;
  
  sVar1 = strlen(value);
  if ((2 < sVar1) && (pcVar2 = strchr(value,0x3a), pcVar2 != (char *)0x0)) {
    *pcVar2 = '\0';
    pcVar2 = pcVar2 + 1;
    LYRemoveBlanks(value);
    LYLowerCase(value);
    pcVar3 = strrchr(pcVar2,0x3a);
    if ((pcVar3 == (char *)0x0) || ((sVar1 = strlen(pcVar2), sVar1 < 2 || (pcVar3[-1] == '\\')))) {
      remove_backslashes(pcVar2);
      HTSetPresentation(value,pcVar2,(char *)0x0,1.0,3.0,0.0,0,mediaCFG);
    }
    else {
      *pcVar3 = '\0';
      remove_backslashes(pcVar2);
      iVar4 = strcasecomp(pcVar3 + 1,"XWINDOWS");
      if (iVar4 == 0) {
        pcVar3 = LYgetXDisplay();
        if (pcVar3 != (char *)0x0) {
          HTSetPresentation(value,pcVar2,(char *)0x0,1.0,3.0,0.0,0,mediaCFG);
        }
      }
      else {
        iVar4 = strcasecomp(pcVar3 + 1,"NON_XWINDOWS");
        if (iVar4 == 0) {
          pcVar3 = LYgetXDisplay();
          if (pcVar3 == (char *)0x0) {
            HTSetPresentation(value,pcVar2,(char *)0x0,1.0,3.0,0.0,0,mediaCFG);
          }
        }
        else {
          HTSetPresentation(value,pcVar2,(char *)0x0,1.0,3.0,0.0,0,mediaCFG);
        }
      }
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

int nonrest_sigwinch_fun(char *value)

{
  int iVar1;
  char *pcVar2;
  
  iVar1 = strncasecomp(value,"XWINDOWS",8);
  if (iVar1 == 0) {
    pcVar2 = LYgetXDisplay();
    LYNonRestartingSIGWINCH = pcVar2 != (char *)0x0;
  }
  else {
    LYNonRestartingSIGWINCH = is_true(value);
  }
  return 0;
}



// WARNING: Unknown calling convention

void html_src_bad_syntax(char *value,char *option_name)

{
  char *buf;
  
  buf = (char *)0x0;
  HTSprintf0(&buf,"HTMLSRC_%s",option_name);
  LYUpperCase(buf);
  fprintf(stderr,"Bad syntax in TAGSPEC %s:%s\n",buf,value);
  exit_immediately(1);
  return;
}



// WARNING: Unknown calling convention

int parse_html_src_spec(HTlexeme lexeme_code,char *value,char *option_name)

{
  char *ts;
  FILE *__stream;
  int iVar1;
  char *ts2;
  
  if ((value != (char *)0x0) && (*value != '\0')) {
    ts = strchr(value,0x3a);
    if (ts == (char *)0x0) {
      html_src_bad_syntax(value,option_name);
    }
    *ts = '\0';
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"LYReadCFG - parsing tagspec \'%s:%s\' for option \'%s\'\n",value,ts,
              option_name);
    }
    html_src_clean_item(lexeme_code);
    iVar1 = html_src_parse_tagspec(value,lexeme_code,'\x01','\x01');
    if ((iVar1 == 0) || (iVar1 = html_src_parse_tagspec(ts,lexeme_code,'\x01','\x01'), iVar1 == 0))
    {
      *ts = ':';
      html_src_bad_syntax(value,option_name);
    }
    *ts = ':';
    HTSACopy(HTL_tagspecs + lexeme_code,value);
  }
  return 0;
}



// WARNING: Unknown calling convention

int psrcspec_fun(char *s)

{
  char *pcVar1;
  BOOLEAN BVar2;
  FILE *pFVar3;
  int found;
  char *e;
  
  e = strchr(s,0x3a);
  if (e == (char *)0x0) {
    if (WWW_TraceFlag != '\0') {
      pFVar3 = TraceFP();
      fprintf((FILE *)pFVar3,"bad format of PRETTYSRC_SPEC setting value, ignored %s\n",s);
    }
  }
  else {
    *e = '\0';
    BVar2 = LYgetEnum(psrcspec_fun::lexemnames,s,&found);
    if (BVar2 == '\0') {
      if (WWW_TraceFlag != '\0') {
        pcVar1 = e + 1;
        pFVar3 = TraceFP();
        fprintf((FILE *)pFVar3,"bad format of PRETTYSRC_SPEC setting value, ignored %s:%s\n",s,
                pcVar1);
      }
    }
    else {
      parse_html_src_spec(found,e + 1,s);
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

int read_htmlsrc_attrname_xform(char *str)

{
  int iVar1;
  FILE *pFVar2;
  int val;
  
  iVar1 = sscanf(str,"%d",&val);
  if (iVar1 == 1) {
    if ((val < 0) || (2 < val)) {
      if (WWW_TraceFlag != '\0') {
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2,
                "bad value for htmlsrc_attrname_xform (ignored - must be one of 0,1,2): %d\n",val);
      }
    }
    else {
      attrname_transform = val;
    }
  }
  else if (WWW_TraceFlag != '\0') {
    pFVar2 = TraceFP();
    fprintf((FILE *)pFVar2,"bad value for htmlsrc_attrname_xform (ignored): %s\n",str);
  }
  return 0;
}



// WARNING: Unknown calling convention

int read_htmlsrc_tagname_xform(char *str)

{
  int iVar1;
  FILE *pFVar2;
  int val;
  
  iVar1 = sscanf(str,"%d",&val);
  if (iVar1 == 1) {
    if ((val < 0) || (2 < val)) {
      if (WWW_TraceFlag != '\0') {
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2,
                "bad value for htmlsrc_tagname_xform (ignored - must be one of 0,1,2): %d\n",val);
      }
    }
    else {
      tagname_transform = val;
    }
  }
  else if (WWW_TraceFlag != '\0') {
    pFVar2 = TraceFP();
    fprintf((FILE *)pFVar2,"bad value for htmlsrc_tagname_xform (ignored): %s\n",str);
  }
  return 0;
}



// WARNING: Unknown calling convention

void free_lynx_cfg(void)

{
  char *__s;
  long *plVar1;
  char *pcVar2;
  char *eqls;
  char *name;
  ParseUnion *q;
  Config_Type_conflict *tbl;
  
  for (tbl = Config_Table; tbl->name != (char *)0x0; tbl = tbl + 1) {
    plVar1 = &tbl->value;
    if ((tbl->type == CONF_ENV) && (*plVar1 != 0)) {
      __s = *(char **)*plVar1;
      pcVar2 = strchr(__s,0x3d);
      if (pcVar2 != (char *)0x0) {
        *pcVar2 = '\0';
        unsetenv(__s);
      }
      if (*(int *)*plVar1 != 0) {
        free(*(void **)*plVar1);
        *(undefined4 *)*plVar1 = 0;
      }
      if (*plVar1 != 0) {
        free((void *)*plVar1);
        *plVar1 = 0;
      }
    }
  }
  free_all_item_lists();
  reset_dired_menu();
  if (lynxcfginfo_url != (char *)0x0) {
    free(lynxcfginfo_url);
    lynxcfginfo_url = (char *)0x0;
  }
  if (configinfo_url != (char *)0x0) {
    free(configinfo_url);
    configinfo_url = (char *)0x0;
  }
  return;
}



// WARNING: Unknown calling convention

Config_Type_conflict * lookup_config(char *name)

{
  byte bVar1;
  ushort **ppuVar2;
  int iVar3;
  char local_1d;
  uint local_18;
  Config_Type_conflict *tbl;
  char ch1;
  char ch;
  
  tbl = Config_Table;
  ppuVar2 = __ctype_b_loc();
  if (((*ppuVar2)[(byte)*name] & 0x200) == 0) {
    local_1d = *name;
  }
  else {
    iVar3 = toupper((uint)(byte)*name);
    local_1d = (char)iVar3;
  }
  while( true ) {
    if (tbl->name == (char *)0x0) {
      return tbl;
    }
    bVar1 = *tbl->name;
    ppuVar2 = __ctype_b_loc();
    if (((*ppuVar2)[bVar1] & 0x200) == 0) {
      local_18 = (uint)bVar1;
    }
    else {
      local_18 = toupper((uint)bVar1);
    }
    if (((int)local_1d == local_18) && (iVar3 = strcasecomp(name,tbl->name), iVar3 == 0)) break;
    tbl = tbl + 1;
  }
  return tbl;
}



// WARNING: Unknown calling convention

char * actual_filename(char *cfg_filename,char *parent_filename,char *dft_filename)

{
  BOOLEAN BVar1;
  char *pcVar2;
  char *my_filename;
  
  my_filename = (char *)0x0;
  BVar1 = LYisAbsPath(cfg_filename);
  if ((BVar1 == '\0') &&
     ((parent_filename != (char *)0x0 || (BVar1 = LYCanReadFile(cfg_filename), BVar1 == '\0')))) {
    if ((*cfg_filename == '~') && (cfg_filename[1] == '/')) {
      pcVar2 = Home_Dir();
      HTSprintf0(&my_filename,"%s%s",pcVar2,cfg_filename + 1);
    }
    else {
      if (parent_filename != (char *)0x0) {
        HTSACopy(&my_filename,parent_filename);
        pcVar2 = LYPathLeaf(my_filename);
        *pcVar2 = '\0';
        HTSACat(&my_filename,cfg_filename);
      }
      if ((my_filename != (char *)0x0) && (BVar1 = LYCanReadFile(my_filename), BVar1 != '\0')) {
        return my_filename;
      }
      HTSACopy(&my_filename,dft_filename);
      pcVar2 = LYPathLeaf(my_filename);
      *pcVar2 = '\0';
      HTSACat(&my_filename,cfg_filename);
      BVar1 = LYCanReadFile(my_filename);
      if (BVar1 == '\0') {
        HTSACopy(&my_filename,cfg_filename);
      }
    }
  }
  else {
    HTSACopy(&my_filename,cfg_filename);
  }
  return my_filename;
}



// WARNING: Unknown calling convention

FILE * LYOpenCFG(char *cfg_filename,char *parent_filename,char *dft_filename)

{
  char *__filename;
  FILE *__stream;
  FILE *pFVar1;
  FILE *result;
  char *my_file;
  
  __filename = actual_filename(cfg_filename,parent_filename,dft_filename);
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"opening config file %s\n",__filename);
  }
  pFVar1 = fopen64(__filename,"r");
  if (__filename != (char *)0x0) {
    free(__filename);
  }
  return (FILE *)pFVar1;
}



// WARNING: Unknown calling convention

void LYSetConfigValue(char *name,char *value)

{
  BOOLEAN *pBVar1;
  HTList **ppHVar2;
  BOOLEAN BVar3;
  int iVar4;
  char *pcVar5;
  lynx_list_item_type **pplVar6;
  HTList *pHVar7;
  float ival;
  char *temp;
  ParseUnion *q;
  Config_Type_conflict *tbl;
  
  tbl = lookup_config(name);
  q = (ParseUnion *)&tbl->value;
  temp = (char *)0x0;
  switch(tbl->type) {
  case CONF_BOOL:
    if (q->add_value != (lynx_list_item_type **)0x0) {
      pBVar1 = q->set_value;
      BVar3 = is_true(value);
      *pBVar1 = BVar3;
    }
    break;
  case CONF_FUN:
    if (q->add_value != (lynx_list_item_type **)0x0) {
      (*q->fun_value)(value);
    }
    break;
  case CONF_TIME:
    if ((q->add_value != (lynx_list_item_type **)0x0) &&
       (iVar4 = sscanf(value,"%f",&ival), iVar4 == 1)) {
      *q->int_value = (int)ROUND(ival * 1000.0);
    }
    break;
  case CONF_ENUM:
    if (tbl->table != (Config_Enum *)0x0) {
      LYgetEnum(tbl->table,value,q->int_value);
    }
    break;
  case CONF_INT:
    if ((q->add_value != (lynx_list_item_type **)0x0) &&
       (iVar4 = sscanf(value,"%d",&ival), iVar4 == 1)) {
      *q->add_value = (lynx_list_item_type *)ival;
    }
    break;
  case CONF_STR:
    if (q->add_value != (lynx_list_item_type **)0x0) {
      HTSACopy(q->str_value,value);
    }
    break;
  case CONF_PRG:
    pcVar5 = HTSACopy(&temp,value);
    if (pcVar5 != (char *)0x0) {
      HTSetProgramPath(q->def_value,temp);
    }
    break;
  case CONF_ENV:
  case CONF_ENV2:
    if (tbl->type == CONF_ENV) {
      LYLowerCase(name);
    }
    else {
      LYUpperCase(name);
    }
    pcVar5 = LYGetEnv(name);
    if (pcVar5 == (char *)0x0) {
      if (q->add_value == (lynx_list_item_type **)0x0) {
        pplVar6 = (lynx_list_item_type **)calloc(1,4);
        q->add_value = pplVar6;
      }
      HTSprintf0(q->str_value,"%s=%s",name,value);
      putenv(*q->str_value);
    }
    break;
  case CONF_ADD_ITEM:
    if (q->add_value != (lynx_list_item_type **)0x0) {
      add_item_to_list(value,q->add_value,(uint)(q->add_value == &printers));
    }
    break;
  case CONF_ADD_STRING:
    if (*q->add_value == (lynx_list_item_type *)0x0) {
      ppHVar2 = q->lst_value;
      pHVar7 = HTList_new();
      *ppHVar2 = pHVar7;
    }
    if (q->add_value != (lynx_list_item_type **)0x0) {
      ival = 0.0;
      HTSACopy((char **)&ival,value);
      HTList_appendObject(*q->lst_value,(void *)ival);
    }
    break;
  case CONF_ADD_TRUSTED:
    add_trusted(value,q->def_value);
  }
  return;
}



void do_read_cfg(char *cfg_filename,char *parent_filename,int nesting_level,FILE *fp0,
                optidx_set_t *allowed)

{
  FILE *pFVar1;
  char *pcVar2;
  ushort **ppuVar3;
  size_t sVar4;
  uint uVar5;
  int in_GS_OFFSET;
  Conf_Types local_224;
  BOOLEAN local_21c;
  optidx_set_t *allowed_local;
  FILE *fp0_local;
  char *parent_filename_local;
  char *cfg_filename_local;
  lynx_list_item_type *cur_download;
  char *buf;
  uint i_1;
  uint i1;
  uint i;
  Config_Type_conflict *tbl2;
  char *my_file;
  char *sep;
  char *cp1;
  char *url;
  char *p2;
  char *p1;
  optidx_set_t *resultant_set;
  ParseUnion *q;
  Config_Type_conflict *tbl;
  char *cp;
  char *value;
  char *name;
  char *buffer;
  FILE *fp;
  BOOLEAN any_optname_found;
  char savechar;
  optidx_set_t anded_set;
  optidx_set_t cur_set;
  int local_c;
  
  local_c = *(int *)(in_GS_OFFSET + 0x14);
  buffer = (char *)0x0;
  if (WWW_TraceFlag != '\0') {
    pFVar1 = TraceFP();
    fprintf((FILE *)pFVar1,"Loading cfg file \'%s\'.\n",cfg_filename);
  }
  if (10 < nesting_level) {
    pcVar2 = (char *)gettext("More than %d nested lynx.cfg includes -- perhaps there is a loop?!?\n"
                            );
    fprintf(stderr,pcVar2,nesting_level + -1);
    pcVar2 = (char *)gettext("Last attempted include was \'%s\',\n");
    fprintf(stderr,pcVar2,cfg_filename);
    pcVar2 = (char *)gettext("included from \'%s\'.\n");
    fprintf(stderr,pcVar2,parent_filename);
    exit_immediately(1);
  }
  if ((cfg_filename == (char *)0x0) || (*cfg_filename == '\0')) {
    if (WWW_TraceFlag != '\0') {
      pFVar1 = TraceFP();
      fprintf((FILE *)pFVar1,"No filename following -cfg switch!\n");
    }
  }
  else {
    fp = LYOpenCFG(cfg_filename,parent_filename,"/etc/lynx-cur/lynx.cfg");
    if (fp == (FILE *)0x0) {
      if (WWW_TraceFlag != '\0') {
        pFVar1 = TraceFP();
        fprintf((FILE *)pFVar1,"lynx.cfg file not found as \'%s\'\n",cfg_filename);
      }
    }
    else {
      have_read_cfg = '\x01';
      while (pcVar2 = LYSafeGets(&buffer,fp), pcVar2 != (char *)0x0) {
        name = LYSkipBlanks(buffer);
        ppuVar3 = __ctype_b_loc();
        if ((((*ppuVar3)[(byte)*name] & 4) == 0) && (LYTrimTrailing(name), *name != '\0')) {
          value = strchr(name,0x3a);
          if (value == (char *)0x0) {
            if (WWW_TraceFlag != '\0') {
              pFVar1 = TraceFP();
              fprintf((FILE *)pFVar1,"LYReadCFG: missing \':\' %s\n",name);
            }
          }
          else {
            *value = '\0';
            value = value + 1;
            cp = strrchr(value,0x3a);
            if (cp == (char *)0x0) {
              cp = value;
            }
            cp = strchr(cp,0x23);
            if (cp != (char *)0x0) {
              cp = cp + -1;
              ppuVar3 = __ctype_b_loc();
              if (((*ppuVar3)[(byte)*cp] & 0x2000) != 0) {
                *cp = '\0';
              }
            }
            if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
              pFVar1 = TraceFP();
              fprintf((FILE *)pFVar1,"LYReadCFG %s:%s\n",name,value);
            }
            tbl = lookup_config(name);
            if (tbl->name == (char *)0x0) {
              if (WWW_TraceFlag != '\0') {
                pFVar1 = TraceFP();
                fprintf((FILE *)pFVar1,"LYReadCFG: ignored %s:%s\n",name,value);
              }
            }
            else if ((allowed == (optidx_set_t *)0x0) ||
                    ((*allowed)[(int)(tbl + -0x819614) >> 4] == '\0')) {
              q = (ParseUnion *)&tbl->value;
              if ((fp0 == (FILE *)0x0) || (tbl->type == CONF_INCLUDE)) {
                local_224 = tbl->type;
              }
              else {
                local_224 = CONF_NIL;
              }
              if (local_224 < 0xe) {
                uVar5 = 1 << ((byte)local_224 & 0x1f);
                if ((uVar5 & 0x3bfe) == 0) {
                  if ((uVar5 & 0x400) == 0) goto LAB_080a926e;
                  resultant_set = (optidx_set_t *)0x0;
                  any_optname_found = '\0';
                  url = (char *)0x0;
                  cp1 = (char *)0x0;
                  sep = " for ";
                  p1 = strstr(value," for ");
                  if (p1 == (char *)0x0) {
                    sep = ":";
                    p1 = strstr(value,":");
                    if (p1 != (char *)0x0) goto LAB_080a8d55;
                  }
                  else {
LAB_080a8d55:
                    *p1 = '\0';
                    sVar4 = strlen(sep);
                    p1 = p1 + sVar4;
                  }
                  if ((fp0 != (FILE *)0x0) && (no_lynxcfg_xinfo == '\0')) {
                    my_file = actual_filename(value,cfg_filename,"/etc/lynx-cur/lynx.cfg");
                    LYLocalFileToURL(&url,my_file);
                    if (my_file != (char *)0x0) {
                      free(my_file);
                      my_file = (char *)0x0;
                    }
                    HTSACopy(&cp1,value);
                    pcVar2 = strchr(value,0x26);
                    if ((pcVar2 != (char *)0x0) ||
                       (pcVar2 = strchr(value,0x3c), pcVar2 != (char *)0x0)) {
                      LYEntify(&cp1,'\x01');
                    }
                    fprintf((FILE *)fp0,"%s:<a href=\"%s\">%s</a>\n\n",name,url,cp1);
                    fprintf((FILE *)fp0,"    #&lt;begin  %s&gt;\n",cp1);
                  }
                  if (p1 != (char *)0x0) {
                    while (p1 = LYSkipBlanks(p1), *p1 != '\0') {
                      p2 = LYSkipNonBlanks(p1);
                      savechar = *p2;
                      *p2 = '\0';
                      tbl2 = lookup_config(p1);
                      if (tbl2->name == (char *)0x0) {
                        if (fp0 == (FILE *)0x0) {
                          fprintf(stderr,"unknown option name %s in %s\n",p1,cfg_filename);
                        }
                      }
                      else {
                        if (any_optname_found == '\0') {
                          any_optname_found = '\x01';
                          for (i = 0; i < 0xcf; i = i + 1) {
                            cur_set[i] = '\x01';
                          }
                        }
                        cur_set[(int)(tbl2 + -0x819614) >> 4] = '\0';
                      }
                      if ((savechar == '\0') || (p2[1] == '\0')) break;
                      p1 = p2 + 1;
                    }
                  }
                  if (allowed == (optidx_set_t *)0x0) {
                    if (any_optname_found == '\0') {
                      resultant_set = (optidx_set_t *)0x0;
                    }
                    else {
                      resultant_set = (optidx_set_t *)cur_set;
                    }
                  }
                  else if (any_optname_found == '\0') {
                    resultant_set = allowed;
                  }
                  else {
                    for (i1 = 0; i1 < 0xcf; i1 = i1 + 1) {
                      if (((*allowed)[i1] == '\0') && (cur_set[i1] == '\0')) {
                        local_21c = '\0';
                      }
                      else {
                        local_21c = '\x01';
                      }
                      anded_set[i1] = local_21c;
                    }
                    resultant_set = (optidx_set_t *)anded_set;
                  }
                  if (((fp0 != (FILE *)0x0) && (no_lynxcfg_xinfo == '\0')) &&
                     (resultant_set != (optidx_set_t *)0x0)) {
                    buf = (char *)0x0;
                    fwrite("     Options allowed in this file:\n",1,0x23,(FILE *)fp0);
                    for (i_1 = 0; i_1 < 0xcf; i_1 = i_1 + 1) {
                      if ((*resultant_set)[i_1] == '\0') {
                        HTSACopy(&buf,Config_Table[i_1].name);
                        LYUpperCase(buf);
                        fprintf((FILE *)fp0,"         * %s\n",buf);
                      }
                    }
                    if (buf != (char *)0x0) {
                      free(buf);
                      buf = (char *)0x0;
                    }
                  }
                  do_read_cfg(value,cfg_filename,nesting_level + 1,fp0,resultant_set);
                  if ((fp0 != (FILE *)0x0) && (no_lynxcfg_xinfo == '\0')) {
                    fprintf((FILE *)fp0,"    #&lt;end of %s&gt;\n\n",cp1);
                    if (url != (char *)0x0) {
                      free(url);
                      url = (char *)0x0;
                    }
                    if (cp1 != (char *)0x0) {
                      free(cp1);
                      cp1 = (char *)0x0;
                    }
                  }
                }
                else {
                  LYSetConfigValue(name,value);
                }
              }
              else {
LAB_080a926e:
                if (fp0 != (FILE *)0x0) {
                  pcVar2 = strchr(value,0x26);
                  if ((pcVar2 == (char *)0x0) &&
                     (pcVar2 = strchr(value,0x3c), pcVar2 == (char *)0x0)) {
                    fprintf((FILE *)fp0,"%s:%s\n",name,value);
                  }
                  else {
                    buf = (char *)0x0;
                    HTSACopy(&buf,value);
                    LYEntify(&buf,'\x01');
                    fprintf((FILE *)fp0,"%s:%s\n",name,buf);
                    if (buf != (char *)0x0) {
                      free(buf);
                      buf = (char *)0x0;
                    }
                  }
                }
              }
            }
            else if (fp0 == (FILE *)0x0) {
              fprintf(stderr,"%s is not allowed in the %s\n",name,cfg_filename);
            }
          }
        }
      }
      LYCloseInput(fp);
      if (downloaders != (lynx_list_item_type *)0x0) {
        for (cur_download = downloaders; cur_download != (lynx_list_item_type *)0x0;
            cur_download = cur_download->next) {
          if (cur_download->always_enabled != L'\0') {
            override_no_download = '\x01';
            break;
          }
        }
      }
      LYConfigCookies();
    }
  }
  if (local_c == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void read_cfg(char *cfg_filename,char *parent_filename,int nesting_level,FILE *fp0)

{
  HTInitProgramPaths();
  do_read_cfg(cfg_filename,parent_filename,nesting_level,fp0,(optidx_set_t *)0x0);
  return;
}



// WARNING: Unknown calling convention

void extra_cfg_link(FILE *fp,char *href,char *name)

{
  fprintf((FILE *)fp,"<a href=\"%s\">%s</a>",href,name);
  return;
}



// WARNING: Unknown calling convention

int lynx_cfg_infopage(DocInfo *newdoc)

{
  BOOLEAN BVar1;
  char *pcVar2;
  char *pcVar3;
  int iVar4;
  FILE *fp0_00;
  undefined4 uVar5;
  undefined4 uVar6;
  uint local_30;
  DocAddress WWWDoc;
  FILE *fp0;
  char *cp1;
  char *temp;
  
  temp = (char *)0x0;
  cp1 = (char *)0x0;
  if ((no_lynxcfg_xinfo != '\0') ||
     (pcVar2 = strstr(newdoc->address,"LYNXCFG://reload"), pcVar2 == (char *)0x0))
  goto LAB_080a960e;
  reload_read_cfg();
  if ((HTMainText != (HText *)0x0) && (0 < nhist)) {
    pcVar2 = (char *)gettext("Lynx.cfg Information");
    pcVar3 = HTLoadedDocumentTitle();
    iVar4 = strcmp(pcVar3,pcVar2);
    if (iVar4 == 0) {
      pcVar2 = history[nhist + -1].hdoc.address;
      pcVar3 = HTLoadedDocumentURL();
      iVar4 = strcmp(pcVar3,pcVar2);
      if ((iVar4 == 0) &&
         (BVar1 = LYIsUIPage3(history[nhist + -1].hdoc.address,UIP_LYNXCFG,L'\x01'),
         pcVar2 = lynxcfginfo_url, BVar1 != '\0')) {
        if (lynxcfginfo_url != (char *)0x0) {
          pcVar3 = HTLoadedDocumentURL();
          iVar4 = strcmp(pcVar3,pcVar2);
          if (iVar4 == 0) goto LAB_080a95ee;
        }
        LYpop(newdoc);
        WWWDoc.address = newdoc->address;
        WWWDoc.post_data = (bstring *)newdoc->post_data;
        WWWDoc.post_content_type = newdoc->post_content_type;
        WWWDoc.bookmark = newdoc->bookmark;
        WWWDoc.isHEAD = newdoc->isHEAD;
        WWWDoc.safe = newdoc->safe;
        LYforce_no_cache = '\0';
        LYoverride_no_cache = '\x01';
        BVar1 = HTLoadAbsolute(&WWWDoc);
        if (BVar1 == '\0') {
          return 0;
        }
        HTuncache_current_document();
        LYRegisterUIPage((char *)0x0,UIP_LYNXCFG);
      }
    }
  }
LAB_080a95ee:
  if (lynxcfginfo_url != (char *)0x0) {
    free(lynxcfginfo_url);
    lynxcfginfo_url = (char *)0x0;
  }
LAB_080a960e:
  if ((LYforce_no_cache == '\0') || (reloading == '\0')) {
    if ((lynxcfginfo_url != (char *)0x0) &&
       ((BVar1 = LYCanReadFile(lynx_cfg_infopage::tempfile), BVar1 == '\0' &&
        (lynxcfginfo_url != (char *)0x0)))) {
      free(lynxcfginfo_url);
      lynxcfginfo_url = (char *)0x0;
    }
  }
  else if (lynxcfginfo_url != (char *)0x0) {
    free(lynxcfginfo_url);
    lynxcfginfo_url = (char *)0x0;
  }
  if (lynxcfginfo_url == (char *)0x0) {
    fp0_00 = InternalPageFP(lynx_cfg_infopage::tempfile,L'\x01');
    if (fp0_00 == (FILE *)0x0) {
      return 0;
    }
    LYLocalFileToURL(&lynxcfginfo_url,lynx_cfg_infopage::tempfile);
    LYforce_no_cache = '\x01';
    pcVar2 = (char *)gettext("Lynx.cfg Information");
    BeginInternalPage(fp0_00,pcVar2,(char *)0x0);
    fwrite("<pre>\n",1,6,(FILE *)fp0_00);
    if (no_lynxcfg_xinfo == '\0') {
      iVar4 = strcmp(lynx_cfg_file,"/etc/lynx-cur/lynx.cfg");
      if (iVar4 == 0) {
        uVar5 = gettext("Please read the distribution");
        uVar6 = gettext("The following is read from your lynx.cfg file.");
        fprintf((FILE *)fp0_00,"<em>%s\n%s",uVar6,uVar5);
        fwrite(" </em>lynx.cfg<em> ",1,0x13,(FILE *)fp0_00);
        uVar5 = gettext("for more comments.");
        fprintf((FILE *)fp0_00,"%s</em>\n",uVar5);
      }
      else {
        uVar5 = gettext("Please read the distribution");
        uVar6 = gettext("The following is read from your lynx.cfg file.");
        fprintf((FILE *)fp0_00,"<em>%s\n%s",uVar6,uVar5);
        LYLocalFileToURL(&temp,"/etc/lynx-cur/lynx.cfg");
        fprintf((FILE *)fp0_00," <a href=\"%s\">lynx.cfg</a> ",temp);
        if (temp != (char *)0x0) {
          free(temp);
          temp = (char *)0x0;
        }
        uVar5 = gettext("for more comments.");
        fprintf((FILE *)fp0_00,"%s</em>\n\n",uVar5);
      }
      if ((no_compileopts_info == '\0') && (no_lynxcfg_xinfo == '\0')) {
        uVar5 = gettext("See also");
        fprintf((FILE *)fp0_00,"%s</pre><ul><li>",uVar5);
        pcVar2 = (char *)gettext("compile time options");
        extra_cfg_link(fp0_00,"LYNXCOMPILEOPTS:",pcVar2);
        fwrite(&DAT_0815af9f,1,4,(FILE *)fp0_00);
        LYLocalFileToURL(&temp,lynx_lss_file);
        pcVar2 = (char *)gettext("color-style configuration");
        extra_cfg_link(fp0_00,temp,pcVar2);
        fwrite("</ul><pre>\n",1,0xb,(FILE *)fp0_00);
      }
      else {
        uVar5 = gettext("See also");
        fprintf((FILE *)fp0_00,"%s ",uVar5);
        if (no_compileopts_info == '\0') {
          pcVar2 = (char *)gettext("compile time options");
          extra_cfg_link(fp0_00,"LYNXCOMPILEOPTS:",pcVar2);
        }
        if (no_lynxcfg_xinfo == '\0') {
          LYLocalFileToURL(&temp,lynx_lss_file);
          pcVar2 = (char *)gettext("color-style configuration");
          extra_cfg_link(fp0_00,temp,pcVar2);
        }
        fwrite(&DAT_0815afce,1,2,(FILE *)fp0_00);
      }
      if (user_mode == 2) {
        uVar5 = gettext("RELOAD THE CHANGES");
        fprintf((FILE *)fp0_00,"  <a href=\"%s//reload\">%s</a>\n","LYNXCFG:",uVar5);
      }
      LYLocalFileToURL(&temp,lynx_cfg_file);
      HTSACopy(&cp1,lynx_cfg_file);
      pcVar2 = strchr(lynx_cfg_file,0x26);
      if ((pcVar2 != (char *)0x0) || (pcVar2 = strchr(lynx_cfg_file,0x3c), pcVar2 != (char *)0x0)) {
        LYEntify(&cp1,'\x01');
      }
      pcVar3 = temp;
      pcVar2 = cp1;
      uVar5 = gettext("Your primary configuration");
      fprintf((FILE *)fp0_00,"\n    #<em>%s <a href=\"%s\">%s</a></em>\n",uVar5,pcVar3,pcVar2);
      if (temp != (char *)0x0) {
        free(temp);
        temp = (char *)0x0;
      }
      if (cp1 != (char *)0x0) {
        free(cp1);
        cp1 = (char *)0x0;
      }
    }
    else {
      uVar5 = gettext("The following is read from your lynx.cfg file.");
      fprintf((FILE *)fp0_00,"<em>%s</em>\n\n",uVar5);
    }
    read_cfg(lynx_cfg_file,"main program",1,fp0_00);
    fwrite("</pre>\n",1,7,(FILE *)fp0_00);
    EndInternalPage(fp0_00);
    LYCloseTempFP(fp0_00);
    LYRegisterUIPage(lynxcfginfo_url,UIP_LYNXCFG);
  }
  HTSACopy(&newdoc->address,lynxcfginfo_url);
  WWWDoc.address = newdoc->address;
  WWWDoc.post_data = (bstring *)newdoc->post_data;
  WWWDoc.post_content_type = newdoc->post_content_type;
  WWWDoc.bookmark = newdoc->bookmark;
  WWWDoc.isHEAD = newdoc->isHEAD;
  WWWDoc.safe = newdoc->safe;
  BVar1 = HTLoadAbsolute(&WWWDoc);
  if (BVar1 != '\0') {
    lynx_edit_mode = '\0';
  }
  local_30 = (uint)(BVar1 != '\0');
  return local_30;
}



// WARNING: Unknown calling convention

int lynx_compile_opts(DocInfo *newdoc)

{
  BOOLEAN BVar1;
  FILE *fp0_00;
  char *Title;
  undefined4 uVar2;
  FILE *pFVar3;
  uint local_28;
  DocAddress WWWDoc;
  FILE *fp0;
  uint n;
  
  if ((LYforce_no_cache == '\0') || (reloading == '\0')) {
    if ((configinfo_url != (char *)0x0) &&
       ((BVar1 = LYCanReadFile(lynx_compile_opts::tempfile), BVar1 == '\0' &&
        (configinfo_url != (char *)0x0)))) {
      free(configinfo_url);
      configinfo_url = (char *)0x0;
    }
  }
  else if (configinfo_url != (char *)0x0) {
    free(configinfo_url);
    configinfo_url = (char *)0x0;
  }
  if (configinfo_url == (char *)0x0) {
    fp0_00 = InternalPageFP(lynx_compile_opts::tempfile,L'\x01');
    if (fp0_00 == (FILE *)0x0) {
      return 0;
    }
    LYLocalFileToURL(&configinfo_url,lynx_compile_opts::tempfile);
    Title = (char *)gettext("Configuration Definitions");
    BeginInternalPage(fp0_00,Title,(char *)0x0);
    pFVar3 = fp0_00;
    fwrite("<pre>\n",1,6,(FILE *)fp0_00);
    uVar2 = gettext(
                   "The following data were derived during the automatic configuration/build\nprocess of this copy of Lynx.  When reporting a bug, please include a copy\nof this page."
                   );
    fprintf((FILE *)fp0_00,"\n%s<br>\n<em>config.cache</em>\n",uVar2);
    for (n = 0; n < 0x11a; n = n + 1) {
      pFVar3 = (FILE *)lynx_compile_opts::config_cache[n].value;
      fprintf((FILE *)fp0_00,"%-35s %s\n",lynx_compile_opts::config_cache[n].name,pFVar3);
    }
    uVar2 = gettext(
                   "The following data were used as automatically-configured compile-time\ndefinitions when this copy of Lynx was built."
                   );
    fprintf((FILE *)fp0_00,"\n%s<br>\n<em>lynx_cfg.h</em>\n",uVar2,pFVar3);
    for (n = 0; n < 0xb8; n = n + 1) {
      fprintf((FILE *)fp0_00,"%-35s %s\n",lynx_compile_opts::config_defines[n].name,
              lynx_compile_opts::config_defines[n].value);
    }
    fwrite("</pre>\n",1,7,(FILE *)fp0_00);
    EndInternalPage(fp0_00);
    LYCloseTempFP(fp0_00);
    LYRegisterUIPage(configinfo_url,UIP_CONFIG_DEF);
  }
  HTSACopy(&newdoc->address,configinfo_url);
  WWWDoc.address = newdoc->address;
  WWWDoc.post_data = (bstring *)newdoc->post_data;
  WWWDoc.post_content_type = newdoc->post_content_type;
  WWWDoc.bookmark = newdoc->bookmark;
  WWWDoc.isHEAD = newdoc->isHEAD;
  WWWDoc.safe = newdoc->safe;
  BVar1 = HTLoadAbsolute(&WWWDoc);
  if (BVar1 != '\0') {
    lynx_edit_mode = '\0';
  }
  local_28 = (uint)(BVar1 != '\0');
  return local_28;
}



// WARNING: Unknown calling convention

BOOLEAN link_has_target(int cur,char *target)

{
  char *pcVar1;
  size_t __n;
  char *text;
  int count;
  char *cp;
  char *stars;
  OptionType *option;
  LinkInfo *a;
  
  a = links + cur;
  stars = (char *)0x0;
  count = 0;
  while (pcVar1 = LYGetHiliteStr(cur,count), pcVar1 != (char *)0x0) {
    if (case_sensitive == '\0') {
      pcVar1 = LYno_attr_char_case_strstr(pcVar1,target);
    }
    else {
      pcVar1 = LYno_attr_char_strstr(pcVar1,target);
    }
    if (pcVar1 != (char *)0x0) {
      return '\x01';
    }
    count = count + 1;
  }
  if (((a->l_form != (_FormInfo *)0x0) && (a->l_form->value != (char *)0x0)) &&
     (a->l_form->type != 8)) {
    if (a->l_form->type == 2) {
      if (case_sensitive == '\0') {
        pcVar1 = LYno_attr_char_case_strstr(a->l_form->value,target);
      }
      else {
        pcVar1 = LYno_attr_char_strstr(a->l_form->value,target);
      }
      if (pcVar1 != (char *)0x0) {
        return '\x01';
      }
      HTSACopy(&stars,a->l_form->value);
      __n = strlen(stars);
      memset(stars,0x2a,__n);
      if (case_sensitive == '\0') {
        pcVar1 = LYno_attr_char_case_strstr(stars,target);
      }
      else {
        pcVar1 = LYno_attr_char_strstr(stars,target);
      }
      if (pcVar1 != (char *)0x0) {
        if (stars != (char *)0x0) {
          free(stars);
        }
        return '\x01';
      }
      if (stars != (char *)0x0) {
        free(stars);
      }
    }
    else if (a->l_form->type == 7) {
      for (option = a->l_form->select_list; option != (OptionType *)0x0; option = option->next) {
        if (case_sensitive == '\0') {
          pcVar1 = LYno_attr_char_case_strstr(option->name,target);
        }
        else {
          pcVar1 = LYno_attr_char_strstr(option->name,target);
        }
        if (pcVar1 != (char *)0x0) {
          return '\x01';
        }
      }
    }
    else if (a->l_form->type == 4) {
      if (a->l_form->num_value == 0) {
        cp = unchecked_radio;
      }
      else {
        cp = checked_radio;
      }
      if (case_sensitive == '\0') {
        pcVar1 = LYno_attr_char_case_strstr(cp,target);
      }
      else {
        pcVar1 = LYno_attr_char_strstr(cp,target);
      }
      if (pcVar1 != (char *)0x0) {
        return '\x01';
      }
    }
    else if (a->l_form->type == 3) {
      if (a->l_form->num_value == 0) {
        cp = unchecked_box;
      }
      else {
        cp = checked_box;
      }
      if (case_sensitive == '\0') {
        pcVar1 = LYno_attr_char_case_strstr(cp,target);
      }
      else {
        pcVar1 = LYno_attr_char_strstr(cp,target);
      }
      if (pcVar1 != (char *)0x0) {
        return '\x01';
      }
    }
    else {
      if (case_sensitive == '\0') {
        pcVar1 = LYno_attr_char_case_strstr(a->l_form->value,target);
      }
      else {
        pcVar1 = LYno_attr_char_strstr(a->l_form->value,target);
      }
      if (pcVar1 != (char *)0x0) {
        return '\x01';
      }
    }
  }
  return '\0';
}



// WARNING: Unknown calling convention

int check_next_target_in_links(int *cur,char *target)

{
  BOOLEAN BVar1;
  int local_18;
  int i;
  
  if (nlinks == 0) {
LAB_080aa2ce:
    local_18 = 0;
  }
  else {
    i = *cur;
    do {
      i = i + 1;
      if (nlinks <= i) goto LAB_080aa2ce;
      BVar1 = link_has_target(i,target);
    } while (BVar1 == '\0');
    *cur = i;
    local_18 = 1;
  }
  return local_18;
}



// WARNING: Unknown calling convention

int check_prev_target_in_links(int *cur,char *target)

{
  BOOLEAN BVar1;
  int local_18;
  int i;
  
  if (nlinks == 0) {
LAB_080aa327:
    local_18 = 0;
  }
  else {
    i = *cur;
    do {
      i = i + -1;
      if (i < 0) goto LAB_080aa327;
      BVar1 = link_has_target(i,target);
    } while (BVar1 == '\0');
    *cur = i;
    local_18 = 1;
  }
  return local_18;
}



// WARNING: Unknown calling convention

BOOLEAN textsearch(DocInfo *cur_doc,char *prev_target,int target_size,int direction)

{
  wchar_t cur;
  bool bVar1;
  RecallType recall_00;
  char *pcVar2;
  int iVar3;
  int local_2c;
  int QueryNum;
  int QueryTotal;
  RecallType recall;
  int ch;
  char *cp;
  int oldcur;
  int offset;
  BOOLEAN FirstRecall;
  
  cur = cur_doc->link;
  ch = 0;
  bVar1 = true;
  if (textsearch::first != '\0') {
    textsearch::prev_target_buffer[0] = '\0';
    textsearch::first = '\0';
  }
  if (search_queries == (HTList *)0x0) {
    local_2c = 0;
  }
  else {
    local_2c = HTList_count(search_queries);
  }
  recall_00 = (RecallType)(0 < local_2c);
  QueryNum = local_2c;
  if (direction != 0) {
    LYstrncpy(prev_target,textsearch::prev_target_buffer,target_size);
  }
  if (*prev_target == '\0') {
    mustshow = '\x01';
    pcVar2 = (char *)gettext("Enter a whereis query: ");
    statusline(pcVar2);
    ch = LYgetstr(prev_target,L'\0',target_size,recall_00);
    if (ch < L'\0') {
      LYstrncpy(prev_target,textsearch::prev_target_buffer,target_size);
      pcVar2 = (char *)gettext("Cancelled!!!");
      HTInfoMsg(pcVar2);
      return '\0';
    }
  }
  do {
    while( true ) {
      if ((*prev_target == '\0') && ((recall_00 == NORECALL || ((ch != 0x100 && (ch != 0x101)))))) {
        pcVar2 = (char *)gettext("Cancelled!!!");
        HTInfoMsg(pcVar2);
        return '\0';
      }
      if ((recall_00 != NORECALL) && (ch == 0x100)) break;
      if ((recall_00 == NORECALL) || (ch != 0x101)) goto LAB_080aa821;
      if (bVar1) {
        bVar1 = false;
        if (textsearch::prev_target_buffer[0] == '\0') {
          QueryNum = local_2c + -1;
        }
        else {
          QueryNum = 0;
          while ((QueryNum < local_2c + -1 &&
                 ((pcVar2 = (char *)HTList_objectAt(search_queries,QueryNum), pcVar2 == (char *)0x0
                  || (iVar3 = strcmp(textsearch::prev_target_buffer,pcVar2), iVar3 != 0))))) {
            QueryNum = QueryNum + 1;
          }
        }
      }
      else {
        QueryNum = QueryNum + -1;
      }
      if (QueryNum < 0) {
        QueryNum = local_2c + -1;
      }
      pcVar2 = (char *)HTList_objectAt(search_queries,QueryNum);
      if (pcVar2 == (char *)0x0) goto LAB_080aa821;
      LYstrncpy(prev_target,pcVar2,target_size);
      if ((textsearch::prev_target_buffer[0] == '\0') ||
         (iVar3 = strcmp(textsearch::prev_target_buffer,prev_target), iVar3 != 0)) {
        if (((textsearch::prev_target_buffer[0] == '\0') || (local_2c != 2)) &&
           ((textsearch::prev_target_buffer[0] != '\0' || (local_2c != 1)))) {
          mustshow = '\x01';
          pcVar2 = (char *)gettext("Edit a previous query: ");
          statusline(pcVar2);
        }
        else {
          mustshow = '\x01';
          pcVar2 = (char *)gettext("Edit the previous query: ");
          statusline(pcVar2);
        }
      }
      else {
        mustshow = '\x01';
        pcVar2 = (char *)gettext("Edit the current query: ");
        statusline(pcVar2);
      }
      ch = LYgetstr(prev_target,L'\0',target_size,recall_00);
      if (ch < L'\0') {
        LYstrncpy(prev_target,textsearch::prev_target_buffer,target_size);
        pcVar2 = (char *)gettext("Cancelled!!!");
        HTInfoMsg(pcVar2);
        return '\0';
      }
    }
    if (bVar1) {
      bVar1 = false;
      QueryNum = local_2c;
      if (textsearch::prev_target_buffer[0] == '\0') {
        QueryNum = 0;
      }
      else {
        do {
          QueryNum = QueryNum + -1;
          if (QueryNum < 1) break;
          pcVar2 = (char *)HTList_objectAt(search_queries,QueryNum);
        } while ((pcVar2 == (char *)0x0) ||
                (iVar3 = strcmp(textsearch::prev_target_buffer,pcVar2), iVar3 != 0));
      }
    }
    else {
      QueryNum = QueryNum + 1;
    }
    if (local_2c <= QueryNum) {
      QueryNum = 0;
    }
    pcVar2 = (char *)HTList_objectAt(search_queries,QueryNum);
    if (pcVar2 == (char *)0x0) {
LAB_080aa821:
      LYstrncpy(textsearch::prev_target_buffer,prev_target,L'');
      HTAddSearchQuery(textsearch::prev_target_buffer);
      if (direction < 0) {
        offset = 0;
        iVar3 = check_prev_target_in_links(&cur_doc->link,prev_target);
        if (iVar3 != 0) {
          LYhighlight(L'\0',cur,prev_target);
          return '\x01';
        }
      }
      else {
        iVar3 = check_next_target_in_links(&cur_doc->link,prev_target);
        if (iVar3 != 0) {
          LYhighlight(L'\0',cur,prev_target);
          return '\x01';
        }
        if (nlinks == 0) {
          offset = display_lines + -1;
        }
        else {
          offset = links[cur_doc->link].ly + -1;
        }
      }
      www_user_search(cur_doc->line + offset,cur_doc,prev_target,direction);
      if (cur_doc->link != cur) {
        LYhighlight(L'\0',cur,prev_target);
        return '\x01';
      }
      return 0 < www_search_result;
    }
    LYstrncpy(prev_target,pcVar2,target_size);
    if ((textsearch::prev_target_buffer[0] == '\0') ||
       (iVar3 = strcmp(textsearch::prev_target_buffer,prev_target), iVar3 != 0)) {
      if (((textsearch::prev_target_buffer[0] == '\0') || (local_2c != 2)) &&
         ((textsearch::prev_target_buffer[0] != '\0' || (local_2c != 1)))) {
        mustshow = '\x01';
        pcVar2 = (char *)gettext("Edit a previous query: ");
        statusline(pcVar2);
      }
      else {
        mustshow = '\x01';
        pcVar2 = (char *)gettext("Edit the previous query: ");
        statusline(pcVar2);
      }
    }
    else {
      mustshow = '\x01';
      pcVar2 = (char *)gettext("Edit the current query: ");
      statusline(pcVar2);
    }
    ch = LYgetstr(prev_target,L'\0',target_size,recall_00);
    if (ch < L'\0') {
      LYstrncpy(prev_target,textsearch::prev_target_buffer,target_size);
      pcVar2 = (char *)gettext("Cancelled!!!");
      HTInfoMsg(pcVar2);
      return '\0';
    }
  } while( true );
}



// WARNING: Unknown calling convention

void trace_history(char *tag)

{
  int iVar1;
  int iVar2;
  int iVar3;
  FILE *pFVar4;
  
  iVar3 = nhist_extra;
  iVar2 = size_history;
  iVar1 = nhist;
  if (WWW_TraceFlag != '\0') {
    if (WWW_TraceFlag != '\0') {
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HISTORY %s %d/%d (%d extra)\n",tag,iVar1,iVar2,iVar3);
    }
    if (WWW_TraceFlag != '\0') {
      pFVar4 = TraceFP();
      fflush((FILE *)pFVar4);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void LYAddVisitedLink(DocInfo *doc)

{
  bool bVar1;
  BOOLEAN BVar2;
  int iVar3;
  VisitedLink *dst;
  char *local_34;
  char *local_30;
  char *local_2c;
  VisitedLink *local_28;
  int l;
  VisitedLink *b;
  VisitedLink *a;
  int related;
  char *title;
  HTList *cur;
  VisitedLink *tmp;
  
  if (doc->title == (char *)0x0) {
    local_34 = (char *)gettext("(No title.)");
  }
  else {
    local_34 = doc->title;
  }
  if ((doc->address == (char *)0x0) || (*doc->address == '\0')) {
    PrevVisitedLink = (VisitedLink *)0x0;
    return;
  }
  if ((((doc->post_data == (bstring_conflict *)0x0) && (doc->isHEAD == '\0')) &&
      (doc->bookmark == (char *)0x0)) &&
     ((iVar3 = strncmp(doc->address,"LYNX",4), iVar3 != 0 &&
      (iVar3 = strncmp(doc->address,"file://localhost/",0x11), iVar3 != 0)))) {
LAB_080aad21:
    if (Visited_Links == (HTList *)0x0) {
      Visited_Links = HTList_new();
      Latest_last.prev_latest = &Latest_first;
      Latest_first.next_latest = &Latest_last;
      Latest_last.next_latest = (_VisitedLink *)0x0;
      Latest_first.prev_latest = (_VisitedLink *)0x0;
      First_tree = (VisitedLink *)0x0;
      Latest_tree = (VisitedLink *)0x0;
      Last_by_first = (VisitedLink *)0x0;
    }
    cur = Visited_Links;
    do {
      if ((cur == (HTList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
        local_28 = (VisitedLink *)0x0;
      }
      else {
        local_28 = (VisitedLink *)cur->object;
      }
      if (local_28 == (VisitedLink *)0x0) {
        dst = (VisitedLink *)calloc(1,0x1c);
        if (dst == (VisitedLink *)0x0) {
          outofmem("./LYHistory.c","LYAddVisitedLink");
        }
        HTSACopy(&dst->address,doc->address);
        LYformTitle((char **)dst,local_34);
        HTList_appendObject(Visited_Links,dst);
        dst->prev_first = Last_by_first;
        Last_by_first = dst;
        if (PrevVisitedLink == (VisitedLink *)0x0) {
          if (Latest_tree != (VisitedLink *)0x0) {
            Latest_tree->next_tree = dst;
          }
          dst->level = 0;
          dst->next_tree = (_VisitedLink *)0x0;
          Latest_tree = dst;
        }
        else {
          a = PrevVisitedLink;
          for (b = PrevVisitedLink->next_tree;
              (b != (VisitedLink *)0x0 && (PrevVisitedLink->level < b->level)); b = b->next_tree) {
            a = b;
          }
          if (b == (VisitedLink *)0x0) {
            Latest_tree = dst;
          }
          dst->next_tree = a->next_tree;
          a->next_tree = dst;
          dst->level = PrevVisitedLink->level + 1;
        }
        if (First_tree == (VisitedLink *)0x0) {
          First_tree = dst;
        }
        PrevVisitedLink = dst;
        PrevActiveVisitedLink = dst;
        (Latest_last.prev_latest)->next_latest = dst;
        dst->prev_latest = Latest_last.prev_latest;
        dst->next_latest = &Latest_last;
        Latest_last.prev_latest = dst;
        return;
      }
      if (doc->address == (char *)0x0) {
        local_30 = "";
      }
      else {
        local_30 = doc->address;
      }
      if (local_28->address == (char *)0x0) {
        local_2c = "";
      }
      else {
        local_2c = local_28->address;
      }
      iVar3 = strcmp(local_2c,local_30);
    } while (iVar3 != 0);
    PrevVisitedLink = local_28;
    PrevActiveVisitedLink = local_28;
    if (local_28->next_latest != &Latest_last) {
      local_28->prev_latest->next_latest = local_28->next_latest;
      local_28->next_latest->prev_latest = local_28->prev_latest;
      (Latest_last.prev_latest)->next_latest = local_28;
      local_28->prev_latest = Latest_last.prev_latest;
      local_28->next_latest = &Latest_last;
      Latest_last.prev_latest = local_28;
    }
  }
  else {
    bVar1 = true;
    BVar2 = LYIsUIPage3(doc->address,UIP_HISTORY,L'\x01');
    if (((BVar2 == '\0') &&
        ((BVar2 = LYIsUIPage3(doc->address,UIP_VLINKS,L'\x01'), BVar2 == '\0' &&
         (BVar2 = LYIsUIPage3(doc->address,UIP_SHOWINFO,L'\x01'), BVar2 == '\0')))) &&
       (iVar3 = strncasecomp(doc->address,"LYNXMESSAGES:",0xd), iVar3 != 0)) {
      bVar1 = false;
      BVar2 = LYIsUIPage3(doc->address,UIP_DIRED_MENU,L'\x01');
      if (((((BVar2 == '\0') &&
            (BVar2 = LYIsUIPage3(doc->address,UIP_UPLOAD_OPTIONS,L'\x01'), BVar2 == '\0')) &&
           (BVar2 = LYIsUIPage3(doc->address,UIP_PERMIT_OPTIONS,L'\x01'), BVar2 == '\0')) &&
          (((BVar2 = LYIsUIPage3(doc->address,UIP_PRINT_OPTIONS,L'\x01'), BVar2 == '\0' &&
            (BVar2 = LYIsUIPage3(doc->address,UIP_DOWNLOAD_OPTIONS,L'\x01'), BVar2 == '\0')) &&
           ((BVar2 = LYIsUIPage3(doc->address,UIP_OPTIONS_MENU,L'\x01'), BVar2 == '\0' &&
            ((iVar3 = strncasecomp(doc->address,"LYNXKEYMAP:",0xb), iVar3 != 0 &&
             (BVar2 = LYIsUIPage3(doc->address,UIP_LIST_PAGE,L'\x01'), BVar2 == '\0')))))))) &&
         ((BVar2 = LYIsUIPage3(doc->address,UIP_CONFIG_DEF,L'\x01'), BVar2 == '\0' &&
          (((BVar2 = LYIsUIPage3(doc->address,UIP_LYNXCFG,L'\x01'), BVar2 == '\0' &&
            (iVar3 = strncasecomp(doc->address,"LYNXCOOKIE:",0xb), iVar3 != 0)) &&
           (BVar2 = LYIsUIPage3(doc->address,UIP_TRACELOG,L'\x01'), BVar2 == '\0'))))))
      goto LAB_080aad21;
    }
    if (!bVar1) {
      PrevVisitedLink = (VisitedLink *)0x0;
    }
  }
  return;
}



// WARNING: Unknown calling convention

BOOLEAN LYwouldPush(char *title,char *docurl)

{
  BOOLEAN BVar1;
  int iVar2;
  size_t sVar3;
  char *pcVar4;
  BOOLEAN local_1c;
  size_t ulen;
  BOOLEAN rc;
  
  if ((docurl != (char *)0x0) &&
     (((iVar2 = strncmp(docurl,"file://localhost/",0x11), iVar2 != 0 ||
       (sVar3 = strlen(docurl), sVar3 < 6)) ||
      (iVar2 = strcmp(docurl + (sVar3 - 5),".html"), iVar2 != 0)))) {
    return '\x01';
  }
  if (docurl != (char *)0x0) {
    BVar1 = LYIsUIPage3(docurl,UIP_HISTORY,L'\x01');
    if (((BVar1 == '\0') && (BVar1 = LYIsUIPage3(docurl,UIP_PRINT_OPTIONS,L'\x01'), BVar1 == '\0'))
       && ((BVar1 = LYIsUIPage3(docurl,UIP_DIRED_MENU,L'\x01'), BVar1 == '\0' &&
           ((BVar1 = LYIsUIPage3(docurl,UIP_UPLOAD_OPTIONS,L'\x01'), BVar1 == '\0' &&
            (BVar1 = LYIsUIPage3(docurl,UIP_PERMIT_OPTIONS,L'\x01'), BVar1 == '\0')))))) {
      local_1c = '\x01';
    }
    else {
      local_1c = '\0';
    }
    return local_1c;
  }
  pcVar4 = (char *)gettext("History Page");
  iVar2 = strcmp(title,pcVar4);
  if (iVar2 != 0) {
    pcVar4 = (char *)gettext("Printing Options");
    iVar2 = strcmp(title,pcVar4);
    if (iVar2 != 0) {
      pcVar4 = (char *)gettext("File Management Options");
      iVar2 = strcmp(title,pcVar4);
      if (iVar2 != 0) {
        pcVar4 = (char *)gettext("Upload Options");
        iVar2 = strcmp(title,pcVar4);
        if (iVar2 != 0) {
          pcVar4 = (char *)gettext("File Permission Options");
          iVar2 = strcmp(title,pcVar4);
          if (iVar2 != 0) {
            return '\x01';
          }
        }
      }
    }
  }
  return '\0';
}



// WARNING: Unknown calling convention

void LYFreePostData(DocInfo *doc)

{
  HTSABFree((bstring **)&doc->post_data);
  if (doc->post_content_type != (char *)0x0) {
    free(doc->post_content_type);
    doc->post_content_type = (char *)0x0;
  }
  return;
}



// WARNING: Unknown calling convention

void LYFreeDocInfo(DocInfo *doc)

{
  if (doc->title != (char *)0x0) {
    free(doc->title);
    doc->title = (char *)0x0;
  }
  if (doc->address != (char *)0x0) {
    free(doc->address);
    doc->address = (char *)0x0;
  }
  if (doc->bookmark != (char *)0x0) {
    free(doc->bookmark);
    doc->bookmark = (char *)0x0;
  }
  LYFreePostData(doc);
  return;
}



// WARNING: Unknown calling convention

void clean_extra_history(void)

{
  trace_history("clean_extra_history");
  nhist = nhist + nhist_extra;
  for (; 0 < nhist_extra; nhist_extra = nhist_extra + -1) {
    nhist = nhist + -1;
    LYFreeDocInfo(&history[nhist].hdoc);
  }
  trace_history("...clean_extra_history");
  return;
}



// WARNING: Unknown calling convention

int are_identical(HistInfo *doc,DocInfo *doc1)

{
  BOOLEAN BVar1;
  int iVar2;
  char *local_c;
  char *local_8;
  
  iVar2 = strcmp(doc1->address,(doc->hdoc).address);
  if ((iVar2 == 0) &&
     (BVar1 = HTSABEql((bstring *)doc1->post_data,(bstring *)(doc->hdoc).post_data), BVar1 != '\0'))
  {
    if ((doc->hdoc).bookmark == (char *)0x0) {
      local_c = "";
    }
    else {
      local_c = (doc->hdoc).bookmark;
    }
    if (doc1->bookmark == (char *)0x0) {
      local_8 = "";
    }
    else {
      local_8 = doc1->bookmark;
    }
    iVar2 = strcmp(local_8,local_c);
    if ((iVar2 == 0) && (doc1->isHEAD == (doc->hdoc).isHEAD)) {
      return 1;
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

void LYAllocHistory(int entries)

{
  HistInfo *__s;
  int iVar1;
  FILE *pFVar2;
  size_t __size;
  int save;
  uint want;
  
  iVar1 = size_history;
  if (WWW_TraceFlag != '\0') {
    pFVar2 = TraceFP();
    fprintf((FILE *)pFVar2,"LYAllocHistory %d vs %d\n",entries,iVar1);
  }
  if (size_history <= entries + 1) {
    save = size_history;
    size_history = (entries + 2) * 2;
    __size = (entries + 2) * 0x58;
    if (history == (HistInfo *)0x0) {
      history = (HistInfo *)malloc(__size);
    }
    else {
      history = (HistInfo *)realloc(history,__size);
    }
    if (history == (HistInfo *)0x0) {
      outofmem("./LYHistory.c","LYAllocHistory");
    }
    while (save < size_history) {
      __s = history + save;
      save = save + 1;
      memset(__s,0,0x2c);
    }
  }
  iVar1 = size_history;
  if (WWW_TraceFlag != '\0') {
    pFVar2 = TraceFP();
    fprintf((FILE *)pFVar2,"...LYAllocHistory %d vs %d\n",entries,iVar1);
  }
  return;
}



int LYpush(DocInfo *doc,BOOLEAN force_push)

{
  char *pcVar1;
  char *pcVar2;
  BOOLEAN BVar3;
  int iVar4;
  FILE *pFVar5;
  wchar_t local_44;
  char *local_40;
  int local_38;
  BOOLEAN force_push_local;
  DocAddress WWWDoc;
  char *temp;
  HTParentAnchor *thatparent;
  HTParentAnchor *thisparent;
  
  if (*doc->address == '\0') {
    return 0;
  }
  if ((force_push == '\0') && (BVar3 = LYwouldPush(doc->title,doc->address), BVar3 == '\0')) {
    if (LYforce_no_cache == '\0') {
      LYoverride_no_cache = '\x01';
    }
    return 0;
  }
  if (((0 < nhist) && (iVar4 = are_identical(history + nhist + -1,doc), iVar4 != 0)) &&
     (history[nhist + -1].hdoc.internal_link == doc->internal_link)) {
    history[nhist + -1].hdoc.link = doc->link;
    history[nhist + -1].hdoc.line = doc->line;
    return 0;
  }
  if ((0 < nhist_extra) && (iVar4 = are_identical(history + nhist,doc), iVar4 != 0)) {
    history[nhist].hdoc.link = doc->link;
    history[nhist].hdoc.line = doc->line;
    nhist_extra = nhist_extra + -1;
    LYAllocHistory(nhist);
    nhist = nhist + 1;
    trace_history("LYpush: just move the cursor");
    return 1;
  }
  clean_extra_history();
  LYAllocHistory(nhist);
  history[nhist].hdoc.link = doc->link;
  history[nhist].hdoc.line = doc->line;
  history[nhist].hdoc.title = (char *)0x0;
  LYformTitle((char **)(history + nhist),doc->title);
  history[nhist].hdoc.address = (char *)0x0;
  HTSACopy(&history[nhist].hdoc.address,doc->address);
  history[nhist].hdoc.post_data = (bstring_conflict *)0x0;
  if (doc->post_data == (bstring_conflict *)0x0) {
    local_44 = L'\0';
  }
  else {
    local_44 = doc->post_data->len;
  }
  if (doc->post_data == (bstring_conflict *)0x0) {
    local_40 = (char *)0x0;
  }
  else {
    local_40 = doc->post_data->str;
  }
  HTSABCopy((bstring **)&history[nhist].hdoc.post_data,local_40,local_44);
  history[nhist].hdoc.post_content_type = (char *)0x0;
  HTSACopy(&history[nhist].hdoc.post_content_type,doc->post_content_type);
  history[nhist].hdoc.bookmark = (char *)0x0;
  HTSACopy(&history[nhist].hdoc.bookmark,doc->bookmark);
  history[nhist].hdoc.isHEAD = doc->isHEAD;
  history[nhist].hdoc.safe = doc->safe;
  history[nhist].hdoc.internal_link = '\0';
  history[nhist].intern_seq_start = -1;
  if (doc->internal_link != '\0') {
    if (0 < nhist) {
      thatparent = (HTParentAnchor *)0x0;
      WWWDoc.address = doc->address;
      WWWDoc.post_data = (bstring *)doc->post_data;
      WWWDoc.post_content_type = doc->post_content_type;
      WWWDoc.bookmark = doc->bookmark;
      WWWDoc.isHEAD = doc->isHEAD;
      WWWDoc.safe = doc->safe;
      thisparent = HTAnchor_findAddress(&WWWDoc);
      if (thisparent != (HTParentAnchor *)0x0) {
        iVar4 = strncasecomp(history[nhist + -1].hdoc.address,"LYNXIMGMAP:",0xb);
        if ((iVar4 == 0) && (iVar4 = strncasecomp(doc->address,"LYNXIMGMAP:",0xb), iVar4 != 0)) {
          WWWDoc.address = history[nhist + -1].hdoc.address + 0xb;
        }
        else {
          iVar4 = strncasecomp(doc->address,"LYNXIMGMAP:",0xb);
          if ((iVar4 == 0) &&
             (iVar4 = strncasecomp(history[nhist + -1].hdoc.address,"LYNXIMGMAP:",0xb), iVar4 != 0))
          {
            temp = (char *)0x0;
            HTSACopy(&temp,"LYNXIMGMAP:");
            HTSACat(&temp,doc->address + 0xb);
            WWWDoc.address = temp;
            WWWDoc.post_content_type = history[nhist + -1].hdoc.post_content_type;
            WWWDoc.bookmark = history[nhist + -1].hdoc.bookmark;
            WWWDoc.isHEAD = history[nhist + -1].hdoc.isHEAD;
            WWWDoc.safe = history[nhist + -1].hdoc.safe;
            thatparent = HTAnchor_findAddress(&WWWDoc);
            if (temp != (char *)0x0) {
              free(temp);
              temp = (char *)0x0;
            }
          }
          else {
            WWWDoc.address = history[nhist + -1].hdoc.address;
          }
        }
        if (thatparent == (HTParentAnchor *)0x0) {
          WWWDoc.post_data = (bstring *)history[nhist + -1].hdoc.post_data;
          WWWDoc.post_content_type = history[nhist + -1].hdoc.post_content_type;
          WWWDoc.bookmark = history[nhist + -1].hdoc.bookmark;
          WWWDoc.isHEAD = history[nhist + -1].hdoc.isHEAD;
          WWWDoc.safe = history[nhist + -1].hdoc.safe;
          thatparent = HTAnchor_findAddress(&WWWDoc);
        }
        if ((thatparent == thisparent) &&
           ((HTMainText == (HText *)0x0 || (HTMainAnchor == thisparent)))) {
          history[nhist].hdoc.internal_link = '\x01';
          if (history[nhist + -1].intern_seq_start < 0) {
            local_38 = nhist + -1;
          }
          else {
            local_38 = history[nhist + -1].intern_seq_start;
          }
          history[nhist].intern_seq_start = local_38;
          if (WWW_TraceFlag != '\0') {
            pFVar5 = TraceFP();
            fprintf((FILE *)pFVar5,"\nLYpush: pushed as internal link, OK\n");
          }
        }
      }
    }
    if ((history[nhist].hdoc.internal_link == '\0') && (WWW_TraceFlag != '\0')) {
      pFVar5 = TraceFP();
      fprintf((FILE *)pFVar5,"\nLYpush: push as internal link requested, %s\n",
              "but didn\'t check out!");
    }
  }
  iVar4 = nhist;
  if (WWW_TraceFlag != '\0') {
    pcVar1 = doc->title;
    pcVar2 = doc->address;
    pFVar5 = TraceFP();
    fprintf((FILE *)pFVar5,"\nLYpush[%d]: address:%s\n        title:%s\n",iVar4,pcVar2,pcVar1);
  }
  nhist = nhist + 1;
  return 1;
}



// WARNING: Unknown calling convention

void LYpop(DocInfo *doc)

{
  char *pcVar1;
  char *pcVar2;
  BOOLEAN BVar3;
  undefined2 uVar4;
  undefined3 uVar5;
  int iVar6;
  FILE *__stream;
  HistInfo *pHVar7;
  
  if (0 < nhist) {
    clean_extra_history();
    nhist = nhist + -1;
    LYFreeDocInfo(doc);
    pHVar7 = history + nhist;
    doc->title = (pHVar7->hdoc).title;
    doc->address = (pHVar7->hdoc).address;
    doc->post_data = (pHVar7->hdoc).post_data;
    doc->post_content_type = (pHVar7->hdoc).post_content_type;
    doc->bookmark = (pHVar7->hdoc).bookmark;
    BVar3 = (pHVar7->hdoc).safe;
    uVar4 = *(undefined2 *)&(pHVar7->hdoc).field_0x16;
    doc->isHEAD = (pHVar7->hdoc).isHEAD;
    doc->safe = BVar3;
    *(undefined2 *)&doc->field_0x16 = uVar4;
    doc->link = (pHVar7->hdoc).link;
    doc->line = (pHVar7->hdoc).line;
    uVar5 = *(undefined3 *)&(pHVar7->hdoc).field_0x21;
    doc->internal_link = (pHVar7->hdoc).internal_link;
    *(undefined3 *)&doc->field_0x21 = uVar5;
    doc->style = (pHVar7->hdoc).style;
    LYSetNewline(doc->line);
    iVar6 = nhist;
    if (WWW_TraceFlag != '\0') {
      pcVar1 = doc->title;
      pcVar2 = doc->address;
      __stream = TraceFP();
      fprintf((FILE *)__stream,"LYpop[%d]: address:%s\n     title:%s\n",iVar6,pcVar2,pcVar1);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void LYhist_prev(DocInfo *doc)

{
  trace_history("LYhist_prev");
  if ((0 < nhist) && ((nhist_extra != 0 || (nhist < size_history)))) {
    nhist = nhist + -1;
    nhist_extra = nhist_extra + 1;
    LYpop_num(nhist,doc);
    trace_history("...LYhist_prev");
  }
  return;
}



// WARNING: Unknown calling convention

void LYhist_prev_register(DocInfo *doc)

{
  int iVar1;
  
  trace_history("LYhist_prev_register");
  if (1 < nhist) {
    if (nhist_extra == 0) {
      iVar1 = LYpush(doc,'\0');
      if (iVar1 != 0) {
        nhist = nhist + -1;
        nhist_extra = nhist_extra + 1;
      }
    }
    else {
      history[nhist].hdoc.link = doc->link;
      history[nhist].hdoc.line = doc->line;
    }
    trace_history("...LYhist_prev_register");
  }
  return;
}



// WARNING: Unknown calling convention

int LYhist_next(DocInfo *doc,DocInfo *newdoc)

{
  bool bVar1;
  uint local_8;
  
  bVar1 = 1 < nhist_extra;
  if (bVar1) {
    history[nhist].hdoc.link = doc->link;
    history[nhist].hdoc.line = doc->line;
    LYAllocHistory(nhist);
    nhist = nhist + 1;
    nhist_extra = nhist_extra + -1;
    LYpop_num(nhist,newdoc);
  }
  local_8 = (uint)bVar1;
  return local_8;
}



// WARNING: Unknown calling convention

void LYpop_num(int number,DocInfo *doc)

{
  wchar_t wVar1;
  FILE *pFVar2;
  wchar_t local_18;
  char *local_14;
  char *local_10;
  char *local_c;
  
  if ((-1 < number) && (number < nhist + nhist_extra)) {
    doc->link = history[number].hdoc.link;
    doc->line = history[number].hdoc.line;
    HTSACopy(&doc->title,history[number].hdoc.title);
    HTSACopy(&doc->address,history[number].hdoc.address);
    if (history[number].hdoc.post_data == (bstring_conflict *)0x0) {
      local_18 = L'\0';
    }
    else {
      local_18 = (history[number].hdoc.post_data)->len;
    }
    if (history[number].hdoc.post_data == (bstring_conflict *)0x0) {
      local_14 = (char *)0x0;
    }
    else {
      local_14 = (history[number].hdoc.post_data)->str;
    }
    HTSABCopy((bstring **)&doc->post_data,local_14,local_18);
    HTSACopy(&doc->post_content_type,history[number].hdoc.post_content_type);
    HTSACopy(&doc->bookmark,history[number].hdoc.bookmark);
    doc->isHEAD = history[number].hdoc.isHEAD;
    doc->safe = history[number].hdoc.safe;
    doc->internal_link = history[number].hdoc.internal_link;
    LYSetNewline(doc->line);
    if (WWW_TraceFlag != '\0') {
      if (WWW_TraceFlag != '\0') {
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2,"LYpop_num(%d)\n",number);
      }
      if (WWW_TraceFlag != '\0') {
        wVar1 = doc->link;
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2,"  link    %d\n",wVar1);
      }
      if (WWW_TraceFlag != '\0') {
        wVar1 = doc->line;
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2,"  line    %d\n",wVar1);
      }
      if (WWW_TraceFlag != '\0') {
        if (doc->title == (char *)0x0) {
          local_10 = "";
        }
        else {
          local_10 = doc->title;
        }
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2,"  title   %s\n",local_10);
      }
      if (WWW_TraceFlag != '\0') {
        if (doc->address == (char *)0x0) {
          local_c = "";
        }
        else {
          local_c = doc->address;
        }
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2,"  address %s\n",local_c);
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

int showhistory(char **newfile)

{
  FILE *fp0_00;
  char *pcVar1;
  undefined4 uVar2;
  int local_24;
  undefined *local_1c;
  undefined *local_18;
  FILE *fp0;
  int x;
  char *Title;
  
  Title = (char *)0x0;
  fp0_00 = InternalPageFP(showhistory::tempfile,L'\x01');
  if (fp0_00 == (FILE *)0x0) {
    local_24 = -1;
  }
  else {
    LYLocalFileToURL(newfile,showhistory::tempfile);
    LYforce_HTML_mode = '\x01';
    LYforce_no_cache = '\x01';
    pcVar1 = (char *)gettext("History Page");
    BeginInternalPage(fp0_00,pcVar1,"keystrokes/history_help.html.gz");
    uVar2 = gettext("Your recent statusline messages");
    fprintf((FILE *)fp0_00,"<p align=right> <a href=\"%s\">[%s]</a>\n","LYNXMESSAGES:",uVar2);
    fwrite("<pre>\n",1,6,(FILE *)fp0_00);
    uVar2 = gettext("You selected:");
    fprintf((FILE *)fp0_00,"<em>%s</em>\n",uVar2);
    x = nhist + nhist_extra;
    while (x = x + -1, -1 < x) {
      if (history[x].hdoc.title == (char *)0x0) {
        pcVar1 = (char *)gettext("(No title.)");
        HTSACopy(&Title,pcVar1);
      }
      else {
        HTSACopy(&Title,history[x].hdoc.title);
        LYEntify(&Title,'\x01');
        LYTrimLeading(Title);
        LYTrimTrailing(Title);
        if (*Title == '\0') {
          pcVar1 = (char *)gettext("(No title.)");
          HTSACopy(&Title,pcVar1);
        }
      }
      if (x < 100) {
        if (x < 10) {
          local_18 = &DAT_0815e2c5;
        }
        else {
          local_18 = &DAT_0815e2c8;
        }
        local_1c = local_18;
      }
      else {
        local_1c = &DAT_0815dfd2;
      }
      fprintf((FILE *)fp0_00,"%s<em>%d</em>. <tab id=t%d><a href=\"%s%d\">%s</a>\n",local_1c,x,x,
              "LYNXHIST:",x,Title);
      if (history[x].hdoc.address == (char *)0x0) {
        pcVar1 = (char *)gettext("(no address)");
        HTSACopy(&Title,pcVar1);
      }
      else {
        HTSACopy(&Title,history[x].hdoc.address);
        LYEntify(&Title,'\x01');
      }
      if (history[x].hdoc.internal_link != '\0') {
        if (history[x].intern_seq_start == history[nhist + -1].intern_seq_start) {
          pcVar1 = (char *)gettext(" (internal)");
          HTSACat(&Title,pcVar1);
        }
        else {
          pcVar1 = (char *)gettext(" (was internal)");
          HTSACat(&Title,pcVar1);
        }
      }
      fprintf((FILE *)fp0_00,"<tab to=t%d>%s\n",x,Title);
    }
    fwrite("</pre>\n",1,7,(FILE *)fp0_00);
    EndInternalPage(fp0_00);
    LYCloseTempFP(fp0_00);
    if (Title != (char *)0x0) {
      free(Title);
    }
    local_24 = 0;
  }
  return local_24;
}



// WARNING: Removing unreachable block (ram,0x080ac7ff)
// WARNING: Unknown calling convention

BOOLEAN historytarget(DocInfo *newdoc)

{
  BOOLEAN BVar1;
  size_t sVar2;
  ushort **ppuVar3;
  int number_00;
  char *pcVar4;
  char *pcVar5;
  int iVar6;
  HTParentAnchor *me;
  HyperDoc *pHVar7;
  DocAddress WWWDoc;
  HText *text;
  HTParentAnchor *tmpanchor;
  int number;
  BOOLEAN treat_as_intern;
  
  if ((((newdoc == (DocInfo *)0x0) || (newdoc->address == (char *)0x0)) ||
      (sVar2 = strlen(newdoc->address), sVar2 < 10)) ||
     (ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[(byte)newdoc->address[9]] & 0x800) == 0)) {
    return '\0';
  }
  number_00 = atoi(newdoc->address + 9);
  if ((nhist + nhist_extra < number_00) || (number_00 < 0)) {
    return '\0';
  }
  if ((HTMainText != (HText *)0x0) && (0 < nhist)) {
    pcVar4 = (char *)gettext("History Page");
    pcVar5 = HTLoadedDocumentTitle();
    iVar6 = strcmp(pcVar5,pcVar4);
    if (iVar6 == 0) {
      pcVar4 = HTLoadedDocumentURL();
      BVar1 = LYIsUIPage3(pcVar4,UIP_HISTORY,L'\0');
      if (BVar1 != '\0') {
        pcVar4 = history[nhist + -1].hdoc.address;
        pcVar5 = HTLoadedDocumentURL();
        iVar6 = strcmp(pcVar5,pcVar4);
        if (iVar6 != 0) {
          HTuncache_current_document();
        }
      }
    }
  }
  LYpop_num(number_00,newdoc);
  if ((((newdoc->internal_link == '\0') ||
       (history[number_00].intern_seq_start != history[nhist + -1].intern_seq_start)) &&
      ((nhist + -1 <= number_00 ||
       ((history[nhist + -1].hdoc.internal_link == '\0' ||
        (history[nhist + -1].intern_seq_start != number_00)))))) ||
     ((LYforce_no_cache == '\x01' && (LYoverride_no_cache == '\0')))) {
    newdoc->internal_link = '\0';
  }
  if (newdoc->post_data == (bstring_conflict *)0x0) goto LAB_080ac88a;
  WWWDoc.address = newdoc->address;
  WWWDoc.post_data = (bstring *)newdoc->post_data;
  WWWDoc.post_content_type = newdoc->post_content_type;
  WWWDoc.bookmark = newdoc->bookmark;
  WWWDoc.isHEAD = newdoc->isHEAD;
  WWWDoc.safe = newdoc->safe;
  me = HTAnchor_findAddress(&WWWDoc);
  pHVar7 = HTAnchor_document(me);
  if ((LYresubmit_posts == '\x01') ||
     (((LYforce_no_cache == '\x01' && (LYoverride_no_cache == '\0')) || (pHVar7 == (HyperDoc *)0x0))
     )) {
    iVar6 = strncasecomp(newdoc->address,"LYNXIMGMAP:",0xb);
    if (iVar6 != 0) {
      pcVar4 = (char *)gettext("Document from Form with POST content.  Resubmit?");
      BVar1 = HTConfirm(pcVar4);
      if (BVar1 != '\x01') goto LAB_080ac85a;
    }
    LYforce_no_cache = '\x01';
    LYoverride_no_cache = '\0';
  }
  else {
LAB_080ac85a:
    if (pHVar7 == (HyperDoc *)0x0) {
      pcVar4 = (char *)gettext("Cancelled!!!");
      HTInfoMsg(pcVar4);
      return '\0';
    }
    LYforce_no_cache = '\0';
    LYoverride_no_cache = '\x01';
  }
LAB_080ac88a:
  if (number_00 != 0) {
    pcVar4 = (char *)gettext(" (From History)");
    HTSACat(&newdoc->title,pcVar4);
  }
  return '\x01';
}



// WARNING: Unknown calling convention

int LYShowVisitedLinks(char **newfile)

{
  HTList *pHVar1;
  int iVar2;
  FILE *fp0_00;
  char *pcVar3;
  undefined4 uVar4;
  int iVar5;
  int iVar6;
  int local_50;
  VisitedLink *local_4c;
  char *local_48;
  int local_44;
  int local_40;
  char *local_3c;
  VisitedLink *local_38;
  char *post_arrow;
  char *arrow;
  int ret;
  int offset;
  HTList *cur;
  VisitedLink *vl;
  FILE *fp0;
  int tot;
  int x;
  char *Address;
  char *Title;
  
  pHVar1 = Visited_Links;
  Title = (char *)0x0;
  Address = (char *)0x0;
  cur = Visited_Links;
  ret = 0;
  if (Visited_Links == (HTList *)0x0) {
    local_50 = -1;
  }
  else {
    fp0_00 = InternalPageFP(LYShowVisitedLinks::tempfile,L'\x01');
    if (fp0_00 == (FILE *)0x0) {
      local_50 = -1;
    }
    else {
      LYLocalFileToURL(newfile,LYShowVisitedLinks::tempfile);
      LYRegisterUIPage(*newfile,UIP_VLINKS);
      LYforce_HTML_mode = '\x01';
      LYforce_no_cache = '\x01';
      pcVar3 = (char *)gettext("Visited Links Page");
      BeginInternalPage(fp0_00,pcVar3,"keystrokes/visited_help.html.gz");
      fprintf((FILE *)fp0_00,"<form action=\"%s\" method=\"post\">\n","LYNXOPTIONS:");
      LYMenuVisitedLinks(fp0_00,L'\0');
      fwrite("<input type=\"submit\" value=\"Accept Changes\">\n",1,0x2d,(FILE *)fp0_00);
      fwrite("</form>\n",1,8,(FILE *)fp0_00);
      fwrite(&DAT_0815e437,1,4,(FILE *)fp0_00);
      fwrite("<pre>\n",1,6,(FILE *)fp0_00);
      uVar4 = gettext("You visited (POSTs, bookmark, menu and list files excluded):");
      fprintf((FILE *)fp0_00,"<em>%s</em>\n",uVar4);
      if ((Visited_Links_As & 4U) == 0) {
        x = -1;
      }
      else {
        x = HTList_count(Visited_Links);
      }
      iVar2 = x;
      if ((Visited_Links_As & 1U) == 0) {
        if ((Visited_Links_As & 2U) == 0) {
          if ((Visited_Links_As & 4U) == 0) {
            if ((pHVar1 == (HTList *)0x0) || (cur = pHVar1->next, cur == (HTList *)0x0)) {
              local_4c = (VisitedLink *)0x0;
            }
            else {
              local_4c = (VisitedLink *)cur->object;
            }
            vl = local_4c;
          }
          else {
            vl = Last_by_first;
          }
        }
        else {
          if ((Visited_Links_As & 4U) == 0) {
            vl = Latest_first.next_latest;
          }
          else {
            vl = Latest_last.prev_latest;
          }
          if ((vl == &Latest_last) || (vl == &Latest_first)) {
            vl = (VisitedLink *)0x0;
          }
        }
      }
      else {
        vl = First_tree;
      }
      while (vl != (VisitedLink *)0x0) {
        arrow = "";
        post_arrow = "";
        if ((Visited_Links_As & 4U) == 0) {
          x = x + 1;
        }
        else {
          x = x + -1;
        }
        if (vl == PrevActiveVisitedLink) {
          if ((Visited_Links_As & 4U) == 0) {
            ret = x + 3;
          }
          else {
            ret = (iVar2 - x) + 2;
          }
        }
        if (vl == PrevActiveVisitedLink) {
          post_arrow = "<A NAME=current></A>";
          if ((vl->level == 0) || (((byte)Visited_Links_As & 1) != 1)) {
            local_48 = "=>";
          }
          else {
            local_48 = "==>";
          }
          arrow = local_48;
          HTSACat(newfile,"#current");
        }
        if ((Visited_Links_As & 1U) == 0) {
          if (x < 100) {
            if (x < 10) {
              local_40 = 2;
            }
            else {
              local_40 = 1;
            }
            local_44 = local_40;
          }
          else {
            local_44 = 0;
          }
          offset = local_44;
        }
        else {
          offset = vl->level * 2;
          if (0x18 < offset) {
            offset = (offset + 0x18) / 2;
          }
          if ((int)(((uint)(LYcols * 3 >> 0x1f) >> 0x1e) + LYcols * 3) >> 2 < offset) {
            offset = (int)(((uint)(LYcols * 3 >> 0x1f) >> 0x1e) + LYcols * 3) >> 2;
          }
        }
        if ((vl->title == (char *)0x0) || (*vl->title == '\0')) {
          pcVar3 = (char *)gettext("(No title.)");
          HTSACopy(&Title,pcVar3);
        }
        else {
          HTSACopy(&Title,vl->title);
          LYEntify(&Title,'\x01');
          LYTrimLeading(Title);
          LYTrimTrailing(Title);
          if (*Title == '\0') {
            pcVar3 = (char *)gettext("(No title.)");
            HTSACopy(&Title,pcVar3);
          }
        }
        iVar5 = x;
        iVar6 = x;
        if ((vl->address == (char *)0x0) || (*vl->address == '\0')) {
          pcVar3 = Title;
          fprintf((FILE *)fp0_00,"%-*s%s<em>%d</em>. <tab id=t%d><em>%s</em>\n",offset,arrow,
                  post_arrow,x,x,Title);
        }
        else {
          HTSACopy(&Address,vl->address);
          LYEntify(&Address,'\0');
          pcVar3 = Address;
          fprintf((FILE *)fp0_00,"%-*s%s<em>%d</em>. <tab id=t%d><a href=\"%s\">%s</a>\n",offset,
                  arrow,post_arrow,x,x,Address,Title);
        }
        if (Address != (char *)0x0) {
          HTSACopy(&Address,vl->address);
          LYEntify(&Address,'\x01');
        }
        if (Address == (char *)0x0) {
          local_3c = (char *)gettext("(no address)");
        }
        else {
          local_3c = Address;
        }
        fprintf((FILE *)fp0_00,"<tab to=t%d>%s\n",x,local_3c,post_arrow,iVar5,iVar6,pcVar3);
        if ((Visited_Links_As & 1U) == 0) {
          if ((Visited_Links_As & 2U) == 0) {
            if ((Visited_Links_As & 4U) == 0) {
              if ((cur == (HTList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
                local_38 = (VisitedLink *)0x0;
              }
              else {
                local_38 = (VisitedLink *)cur->object;
              }
              vl = local_38;
            }
            else {
              vl = vl->prev_first;
            }
          }
          else {
            if ((Visited_Links_As & 4U) == 0) {
              vl = vl->next_latest;
            }
            else {
              vl = vl->prev_latest;
            }
            if ((vl == &Latest_last) || (vl == &Latest_first)) {
              vl = (VisitedLink *)0x0;
            }
          }
        }
        else {
          vl = vl->next_tree;
        }
      }
      fwrite("</pre>\n",1,7,(FILE *)fp0_00);
      EndInternalPage(fp0_00);
      LYCloseTempFP(fp0_00);
      if (Title != (char *)0x0) {
        free(Title);
        Title = (char *)0x0;
      }
      if (Address != (char *)0x0) {
        free(Address);
      }
      local_50 = ret;
    }
  }
  return local_50;
}



// WARNING: Unknown calling convention

void to_stack(char *str)

{
  if (0x27 < topOfStack) {
    topOfStack = 0;
  }
  if (buffstack[topOfStack] != (char *)0x0) {
    free(buffstack[topOfStack]);
    buffstack[topOfStack] = (char *)0x0;
  }
  buffstack[topOfStack] = str;
  topOfStack = topOfStack + 1;
  if (0x27 < topOfStack) {
    topOfStack = 0;
  }
  return;
}



// WARNING: Unknown calling convention

void LYstatusline_messages_on_exit(char **buf)

{
  int i;
  
  HTSACat(buf,"\n");
  i = topOfStack + -1;
  while (i = i + 1, i < 0x28) {
    if (buffstack[i] != (char *)0x0) {
      HTSACat(buf,buffstack[i]);
      HTSACat(buf,"\n");
    }
  }
  i = -1;
  while (i = i + 1, i < topOfStack) {
    if (buffstack[i] != (char *)0x0) {
      HTSACat(buf,buffstack[i]);
      HTSACat(buf,"\n");
    }
  }
  return;
}



// WARNING: Unknown calling convention

void LYstore_message2(char *message,char *argument)

{
  char *local_18;
  char *temp;
  
  if (message != (char *)0x0) {
    temp = (char *)0x0;
    if (argument == (char *)0x0) {
      local_18 = "";
    }
    else {
      local_18 = argument;
    }
    HTSprintf0(&temp,message,local_18);
    to_stack(temp);
  }
  return;
}



// WARNING: Unknown calling convention

void LYstore_message(char *message)

{
  char *temp;
  
  if (message != (char *)0x0) {
    temp = (char *)0x0;
    HTSACopy(&temp,message);
    to_stack(temp);
  }
  return;
}



// WARNING: Unknown calling convention

int LYLoadMESSAGES(char *arg,HTParentAnchor *anAnchor,HTFormat format_out,HTStream *sink)

{
  char *pcVar1;
  char *pcVar2;
  _func_void_HTStream_ptr_char_ptr_wchar_t *p_Var3;
  char *fmt;
  wchar_t wVar4;
  undefined4 uVar5;
  int local_30;
  char *temp;
  int i;
  int nummsg;
  char *buf;
  HTStream *target;
  HTFormat format_in;
  
  format_in = HTAtom_for("text/html");
  target = (HTStream *)0x0;
  buf = (char *)0x0;
  nummsg = 0;
  temp = (char *)0x0;
  i = 0x28;
  while (i = i + -1, -1 < i) {
    if (buffstack[i] != (char *)0x0) {
      nummsg = nummsg + 1;
    }
  }
  target = (HTStream *)HTStreamStack(format_in,format_out,(HTStream_conflict4 *)sink,anAnchor);
  if (((HTStream_conflict4 *)target == (HTStream_conflict4 *)0x0) ||
     ((HTStream_conflict4 *)target == (HTStream_conflict4 *)0x0)) {
    pcVar1 = format_out->name;
    pcVar2 = format_in->name;
    fmt = (char *)gettext("Sorry, no known way of converting %s to %s.");
    HTSprintf0(&buf,fmt,pcVar2,pcVar1);
    HTAlert(buf);
    if (buf != (char *)0x0) {
      free(buf);
    }
    local_30 = -29999;
  }
  else {
    anAnchor->no_cache = '\x01';
    HTSprintf0(&buf,"<html>\n<head>\n");
    p_Var3 = target->isa->put_block;
    wVar4 = strlen(buf);
    (*p_Var3)(target,buf,wVar4);
    HTSprintf0(&buf,"<META %s content=\"text/html;charset=%s\">\n","http-equiv=\"content-type\"",
               LYCharSet_UC[current_char_set].MIMEname);
    p_Var3 = target->isa->put_block;
    wVar4 = strlen(buf);
    (*p_Var3)(target,buf,wVar4);
    uVar5 = gettext("Your recent statusline messages");
    HTSprintf0(&buf,"<title>%s</title>\n</head>\n<body>\n",uVar5);
    p_Var3 = target->isa->put_block;
    wVar4 = strlen(buf);
    (*p_Var3)(target,buf,wVar4);
    if (nummsg == 0) {
      uVar5 = gettext("(No messages yet)");
      HTSprintf0(&buf,"<p>%s\n</body>\n</html>\n",uVar5);
    }
    else {
      HTSprintf0(&buf,"<ol>\n");
      p_Var3 = target->isa->put_block;
      wVar4 = strlen(buf);
      (*p_Var3)(target,buf,wVar4);
      i = topOfStack;
      while (i = i + -1, -1 < i) {
        if (buffstack[i] != (char *)0x0) {
          HTSACopy(&temp,buffstack[i]);
          LYEntify(&temp,'\x01');
          HTSprintf0(&buf,"<li value=%d> <em>%s</em>\n",nummsg,temp);
          nummsg = nummsg + -1;
          p_Var3 = target->isa->put_block;
          wVar4 = strlen(buf);
          (*p_Var3)(target,buf,wVar4);
        }
      }
      i = 0x28;
      while (i = i + -1, topOfStack <= i) {
        if (buffstack[i] != (char *)0x0) {
          HTSACopy(&temp,buffstack[i]);
          LYEntify(&temp,'\x01');
          HTSprintf0(&buf,"<li value=%d> <em>%s</em>\n",nummsg,temp);
          nummsg = nummsg + -1;
          p_Var3 = target->isa->put_block;
          wVar4 = strlen(buf);
          (*p_Var3)(target,buf,wVar4);
        }
      }
      if (temp != (char *)0x0) {
        free(temp);
        temp = (char *)0x0;
      }
      HTSprintf0(&buf,"</ol>\n</body>\n</html>\n");
    }
    p_Var3 = target->isa->put_block;
    wVar4 = strlen(buf);
    (*p_Var3)(target,buf,wVar4);
    (*target->isa->_free)(target);
    if (buf != (char *)0x0) {
      free(buf);
    }
    local_30 = 200;
  }
  return local_30;
}



// WARNING: Unknown calling convention

char ** options_list(OptionType_conflict *opt_ptr)

{
  OptionType_conflict *tmp_ptr;
  wchar_t pass;
  size_t len;
  char **result;
  
  result = (char **)0x0;
  for (pass = L'\0'; pass < L'\x02'; pass = pass + L'\x01') {
    len = 0;
    for (tmp_ptr = opt_ptr; tmp_ptr != (OptionType_conflict *)0x0; tmp_ptr = tmp_ptr->next) {
      if (pass != L'\0') {
        result[len] = tmp_ptr->name;
      }
      len = len + 1;
    }
    if (pass == L'\0') {
      result = (char **)calloc(len + 1,4);
    }
    else {
      result[len] = (char *)0x0;
    }
  }
  return result;
}



wchar_t change_form_link_ex(wchar_t cur,DocInfo *newdoc,BOOLEAN *refresh_screen,
                           BOOLEAN use_last_tfpos,BOOLEAN immediate_submit,BOOLEAN redraw_only)

{
  FormInfo *submit_item;
  char *link_value_00;
  char **choices;
  size_t len;
  wchar_t wVar1;
  char *pcVar2;
  int iVar3;
  int local_6c;
  wchar_t local_68;
  char *local_60;
  char *local_54;
  char *local_50;
  BOOLEAN redraw_only_local;
  BOOLEAN immediate_submit_local;
  BOOLEAN use_last_tfpos_local;
  wchar_t i_1;
  wchar_t i;
  OptionType_conflict *opt_ptr;
  wchar_t dummy;
  char **my_data;
  wchar_t title_adjust;
  wchar_t OrigNumValue;
  wchar_t c;
  wchar_t newdoc_changed;
  char *link_value;
  char *link_name;
  FormInfo *form;
  
  submit_item = (FormInfo *)links[cur].l_form;
  pcVar2 = submit_item->name;
  link_value_00 = submit_item->value;
  newdoc_changed = L'\0';
  c = L'';
  if (no_title == '\0') {
    local_6c = 0;
  }
  else {
    local_6c = -1;
  }
  if (submit_item == (FormInfo *)0x0) {
    local_68 = L'';
  }
  else {
    choices = options_list(submit_item->select_list);
    LYmove(links[cur].ly + local_6c,links[cur].lx);
    switch(submit_item->type) {
    case L'\x01':
    case L'\x02':
    case L'\t':
    case L'\v':
      c = form_getstr(cur,use_last_tfpos,redraw_only);
      if (submit_item->type == L'\x02') {
        wVar1 = LYstrCells(submit_item->value);
        if (wVar1 < L'') {
          wVar1 = LYstrCells(submit_item->value);
          local_50 = star_string + (0x3ff - wVar1);
        }
        else {
          local_50 = star_string;
        }
        local_54 = local_50;
      }
      else {
        local_54 = submit_item->value;
      }
      LYSetHilite(cur,local_54);
      break;
    case L'\x03':
      if (submit_item->disabled != L'\x01') {
        if (submit_item->num_value == L'\0') {
          local_60 = checked_box;
        }
        else {
          local_60 = unchecked_box;
        }
        LYSetHilite(cur,local_60);
        submit_item->num_value = (uint)(submit_item->num_value == L'\0');
      }
      break;
    case L'\x04':
      if (submit_item->disabled != L'\x01') {
        if (submit_item->num_value == L'\0') {
          lynx_start_radio_color();
          for (i_1 = L'\0'; i_1 < nlinks; i_1 = i_1 + L'\x01') {
            if ((((links[i_1].type == 1) && ((links[i_1].l_form)->type == 4)) &&
                ((links[i_1].l_form)->number == submit_item->number)) &&
               ((iVar3 = strcmp((links[i_1].l_form)->name,submit_item->name), iVar3 == 0 &&
                ((links[i_1].l_form)->num_value != 0)))) {
              LYmove(links[i_1].ly,links[i_1].lx);
              len = strlen(unchecked_radio);
              LYwaddnstr(LYwin,unchecked_radio,len);
              LYSetHilite(i_1,unchecked_radio);
            }
          }
          lynx_stop_radio_color();
          HText_activateRadioButton(submit_item);
          LYSetHilite(cur,checked_radio);
        }
        else if (user_mode == 0) {
          pcVar2 = (char *)gettext("One radio button must be checked at all times!");
          HTUserMsg(pcVar2);
        }
      }
      break;
    case L'\x05':
    case L'\r':
      if (submit_item->disabled != L'\x01') {
        if ((submit_item->no_cache != '\0') && (submit_item->submit_method != L'\x03')) {
          LYforce_no_cache = '\x01';
          reloading = '\x01';
        }
        newdoc_changed = HText_SubmitForm(submit_item,newdoc,pcVar2,link_value_00);
        if (submit_item->submit_method == L'\x03') {
          *refresh_screen = '\x01';
        }
        else {
          newdoc->link = L'\0';
          newdoc->internal_link = '\0';
        }
      }
      break;
    case L'\x06':
      if (submit_item->disabled != L'\x01') {
        HText_ResetForm(submit_item);
        *refresh_screen = '\x01';
      }
      break;
    case L'\a':
      if (submit_item->select_list == (OptionType_conflict *)0x0) {
        pcVar2 = (char *)gettext("Bad HTML!!  Unable to create popup window!");
        HTAlert(pcVar2);
        c = L'';
      }
      else if (submit_item->disabled == L'\x01') {
        LYhandlePopupList(submit_item->num_value,links[cur].ly,links[cur].lx,choices,
                          submit_item->size,submit_item->size_l,submit_item->disabled,'\0');
        if (enable_scrollback == '\0') {
          c = L'\x17';
        }
        else {
          c = L'\f';
        }
      }
      else {
        wVar1 = LYhandlePopupList(submit_item->num_value,links[cur].ly,links[cur].lx,choices,
                                  submit_item->size,submit_item->size_l,submit_item->disabled,'\0');
        submit_item->num_value = wVar1;
        opt_ptr = submit_item->select_list;
        for (i = L'\0'; i < submit_item->num_value; i = i + L'\x01') {
          opt_ptr = opt_ptr->next;
        }
        submit_item->value = opt_ptr->name;
        submit_item->cp_submit_value = opt_ptr->cp_submit_value;
        submit_item->value_cs = opt_ptr->value_cs;
        if (enable_scrollback == '\0') {
          c = L'\x17';
        }
        else {
          c = L'\f';
        }
      }
      break;
    case L'\f':
      if (redraw_only == '\0') {
        if (immediate_submit == '\0') {
          c = form_getstr(cur,use_last_tfpos,'\0');
        }
        if ((submit_item->disabled == L'\x01') &&
           (((c == L'\r' || (c == L'\n')) || (immediate_submit != '\0')))) {
          wVar1 = peek_mouse_link();
          if (wVar1 < L'\0') {
            c = L'\t';
          }
          else {
            c = L'';
          }
        }
        else if ((immediate_submit == '\0') &&
                ((((c != L'\r' && (c != L'\n')) && (c != L'')) ||
                 (wVar1 = peek_mouse_link(), wVar1 != L'\xffffffff')))) {
          LYSetHilite(cur,submit_item->value);
        }
        else {
          LYSetHilite(cur,submit_item->value);
          if ((submit_item->submit_action == (char *)0x0) || (*submit_item->submit_action == '\0'))
          {
            pcVar2 = (char *)gettext("** Bad HTML!!  No form action defined. **");
            HTUserMsg(pcVar2);
            c = L'';
          }
          else if ((submit_item->submit_method == L'\x03') && (no_mail != '\0')) {
            pcVar2 = (char *)gettext("Mail disallowed!  Cannot submit.");
            HTAlert(pcVar2);
            c = L'';
          }
          else if ((immediate_submit == '\0') &&
                  (((no_file_url != '\0' &&
                    (((*submit_item->submit_action == 'f' || (*submit_item->submit_action == 'F'))
                     && (iVar3 = strncasecomp(submit_item->submit_action,"file:",5), iVar3 == 0))))
                   || (iVar3 = strncasecomp(submit_item->submit_action,"lynx",4), iVar3 == 0)))) {
            c = L'';
          }
          else {
            if ((submit_item->no_cache != '\0') && (submit_item->submit_method != L'\x03')) {
              LYforce_no_cache = '\x01';
              reloading = '\x01';
            }
            newdoc_changed = HText_SubmitForm(submit_item,newdoc,pcVar2,submit_item->value);
            if (submit_item->submit_method == L'\x03') {
              *refresh_screen = '\x01';
            }
            else {
              newdoc->link = L'\0';
              newdoc->internal_link = '\0';
            }
            c = L'';
          }
        }
      }
      else {
        c = form_getstr(cur,use_last_tfpos,'\x01');
      }
    }
    if (newdoc_changed == L'\0') {
      LYforce_no_cache = '\0';
      reloading = '\0';
    }
    else {
      c = L'';
    }
    if (choices != (char **)0x0) {
      free(choices);
    }
    local_68 = c;
  }
  return local_68;
}



wchar_t change_form_link(wchar_t cur,DocInfo *newdoc,BOOLEAN *refresh_screen,BOOLEAN use_last_tfpos,
                        BOOLEAN immediate_submit)

{
  wchar_t wVar1;
  BOOLEAN immediate_submit_local;
  BOOLEAN use_last_tfpos_local;
  
  wVar1 = change_form_link_ex(cur,newdoc,refresh_screen,use_last_tfpos,immediate_submit,'\0');
  return wVar1;
}



// WARNING: Unknown calling convention

void LYSetLastTFPos(wchar_t pos)

{
  LastTFPos = pos;
  return;
}



wchar_t form_getstr(wchar_t cur,BOOLEAN use_last_tfpos,BOOLEAN redraw_only)

{
  int iVar1;
  wchar_t wVar2;
  size_t sVar3;
  char *pcVar4;
  int iVar5;
  size_t sVar6;
  int in_GS_OFFSET;
  bool bVar7;
  byte local_44e0;
  wchar_t local_44dc;
  wchar_t local_44d8;
  wchar_t local_44d4;
  wchar_t local_44d0;
  wchar_t local_44cc;
  wchar_t local_44c8;
  wchar_t local_44c4;
  int local_44bc;
  int local_44b4;
  BOOLEAN redraw_only_local;
  BOOLEAN use_last_tfpos_local;
  MEVENT event;
  wchar_t new_len;
  wchar_t old_len;
  wchar_t rc;
  wchar_t c;
  uchar *e1;
  wchar_t len;
  char *buf;
  uchar *e;
  uchar *s;
  wchar_t cury;
  wchar_t curx;
  wchar_t last_xlkc;
  wchar_t repeat;
  wchar_t action;
  wchar_t startline;
  wchar_t startcol;
  wchar_t max_length;
  wchar_t far_col;
  wchar_t ch;
  char *value;
  FormInfo *form;
  BOOLEAN Edited;
  BOOLEAN refresh_mb;
  BOOLEAN HaveMaxlength;
  EditFieldData MyEdit;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  form = (FormInfo *)links[cur].l_form;
  value = form->value;
  HaveMaxlength = '\0';
  last_xlkc = L'\xffffffff';
  refresh_mb = '\x01';
  Edited = '\0';
  if (LYwin == (WINDOW *)0x0) {
    local_44dc = L'\xffffffff';
  }
  else {
    local_44dc = (wchar_t)LYwin->_cury;
  }
  startline = local_44dc;
  if (LYwin == (WINDOW *)0x0) {
    local_44d8 = L'\xffffffff';
  }
  else {
    local_44d8 = (wchar_t)LYwin->_curx;
  }
  startcol = local_44d8;
  if ((int)(LYcols - (uint)(LYShowScrollbar != '\0')) < form->size + local_44d8) {
    far_col = LYcols - (uint)(LYShowScrollbar != '\0');
  }
  else {
    far_col = form->size + local_44d8;
  }
  if ((form->maxlength == 0) || (0x3ff < form->maxlength)) {
    local_44d4 = L'';
  }
  else {
    local_44d4 = form->maxlength;
  }
  max_length = local_44d4;
  wVar2 = strlen(form->value);
  if ((uint)max_length < (uint)wVar2) {
    sVar3 = strlen(form->value);
    value = value + (sVar3 - max_length);
    if ((form->disabled == L'\0') && ((form->submit_method != L'\x03' || (no_mail == '\0')))) {
      pcVar4 = (char *)gettext("Form field value exceeds buffer length!  Trim the tail.");
      HTUserMsg(pcVar4);
      if (redraw_only == '\0') {
        local_44d0 = L'\x02';
      }
      else {
        local_44d0 = L'\0';
      }
      show_formlink_statusline(form,local_44d0);
      LYmove(startline,startcol);
    }
  }
  LYSetupEdit(&MyEdit,value,max_length,far_col - startcol);
  MyEdit.pad = '_';
  MyEdit.hidden = form->type == L'\x02';
  if ((((use_last_tfpos != '\0') && (L'\xffffffff' < LastTFPos)) && (LastTFPos < MyEdit.strlen)) &&
     (MyEdit.pos = LastTFPos, LastTFPos == L'\0')) {
    MyEdit.mark = ~MyEdit.strlen;
  }
  wVar2 = peek_mouse_levent();
  if ((wVar2 != L'\0') && (use_last_tfpos == '\0')) {
    MyEdit.pos = L'\0';
  }
  LYRefreshEdit(&MyEdit);
  if (redraw_only == '\0') {
again:
    repeat = L'\xffffffff';
    get_mouse_link();
    ch = LYgetch_input();
    if ((refresh_mb == '\0') && (iVar5 = EditBinding(ch), iVar5 != 1)) goto code_r0x080ae1a1;
    goto LAB_080ae1b4;
  }
  local_44cc = L'\0';
LAB_080aecb1:
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return local_44cc;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
code_r0x080ae1a1:
  iVar5 = EditBinding(ch);
  if (iVar5 != 0x18) goto again;
LAB_080ae1b4:
  action = L'\0';
  if (((ch != L'\xffffffff') && ((ch & 0x800U) != 0)) && ((ch & 0x8000U) == 0)) goto breakfor;
  if (ch == L'') {
    getmouse(&event);
    if (LYwin == (WINDOW *)0x0) {
      local_44c8 = L'\xffffffff';
    }
    else {
      local_44c8 = (wchar_t)LYwin->_cury;
    }
    cury = local_44c8;
    if (LYwin == (WINDOW *)0x0) {
      local_44c4 = L'\xffffffff';
    }
    else {
      local_44c4 = (wchar_t)LYwin->_curx;
    }
    curx = local_44c4;
    if (event.y == local_44c8) {
      repeat = event.x - local_44c4;
      if (repeat < L'\0') {
        action = L'\x11';
        repeat = -repeat;
      }
      else {
        action = L'\x0f';
      }
    }
    else {
      MyEdit.dirty = '\x01';
    }
    last_xlkc = L'\xffffffff';
  }
  else {
    if ((ch & 0x8000U) == 0) {
      ch = ch | MyEdit.current_modifiers;
    }
    MyEdit.current_modifiers = L'\0';
    if (last_xlkc != L'\xffffffff') {
      if (ch == last_xlkc) {
        ch = ch | 0x1000;
      }
      last_xlkc = L'\xffffffff';
    }
  }
  wVar2 = peek_mouse_link();
  if (wVar2 != L'\xffffffff') goto breakfor;
  if (action == L'\0') {
    action = EditBinding(ch);
  }
  if (((action & 0x80U) == 0) || ((action & 0x1000U) != 0)) {
    last_xlkc = L'\xffffffff';
  }
  else {
    last_xlkc = ch;
    action = action & 0xffffff7f;
  }
  if (action == L'\x1d') {
    MyEdit.current_modifiers = MyEdit.current_modifiers | 0x4000;
    goto again;
  }
  if (action == L'\x1e') {
    MyEdit.current_modifiers = MyEdit.current_modifiers | 0x2000;
    goto again;
  }
  if ((action == L'\x02') || (action == L'\x06')) goto breakfor;
  if ((action & 0x1000U) != 0) {
    ch = (wchar_t)CONCAT11(8,(char)action);
    goto breakfor;
  }
  if (action == L'\x17') {
    mustshow = '\x01';
    pcVar4 = (char *)gettext("Enter Lynx keystroke command: ");
    statusline(pcVar4);
    ch = LYgetch();
    goto breakfor;
  }
  if (action == L'%') {
    s = (uchar *)get_clip_grab();
    buf = (char *)0x0;
    if (s == (uchar *)0x0) goto breakfor;
    sVar3 = strlen((char *)s);
    e = s + sVar3;
    if ((int)sVar3 < 1) {
      pcVar4 = (char *)gettext("Clipboard empty or Not text data.");
      HTInfoMsg(pcVar4);
      goto again;
    }
    e1 = s;
    while (e1 < e) {
      if (*e1 < 0x20) {
        if (s < e1) {
          LYEditInsert(&MyEdit,s,(int)e1 - (int)s,L'\xffffffff','\x01');
        }
        s = e1;
        if (*e1 != '\t') break;
        LYEditInsert(&MyEdit," ",L'\x01',L'\xffffffff','\x01');
        e1 = e1 + 1;
        s = e1;
      }
      else {
        e1 = e1 + 1;
      }
    }
    if (s < e1) {
      LYEditInsert(&MyEdit,s,(int)e1 - (int)s,L'\xffffffff','\x01');
    }
    for (; (e1 < e && (*e1 == '\r')); e1 = e1 + 1) {
    }
    if ((e1 + 1 < e) && (*e1 == '\n')) {
      HTSACopy(&buf,(char *)(e1 + 1));
    }
    get_clip_release();
    if (MyEdit.strlen < max_length) {
      if ((HaveMaxlength != '\0') && (MyEdit.strlen < max_length)) {
        HaveMaxlength = '\0';
        mustshow = '\x01';
        pcVar4 = (char *)gettext("Enter text.  Use arrows or tab to move off of field.");
        statusline(pcVar4);
      }
    }
    else {
      HaveMaxlength = '\x01';
    }
    iVar5 = strcmp(value,MyEdit.buffer);
    if (iVar5 != 0) {
      Edited = '\x01';
    }
    if (buf != (char *)0x0) {
      put_clip(buf);
      if (buf != (char *)0x0) {
        free(buf);
        buf = (char *)0x0;
      }
      ch = L'\n';
breakfor:
      if (Edited != '\0') {
        if (form->value == value) {
          HTSACopy(&form->value,MyEdit.buffer);
        }
        else {
          sVar3 = strlen(form->value);
          sVar6 = strlen(value);
          if ((int)sVar6 < (int)sVar3) {
            local_44b4 = sVar3 - sVar6;
          }
          else {
            local_44b4 = 0;
          }
          form->value[local_44b4] = '\0';
          HTSACat(&form->value,MyEdit.buffer);
          pcVar4 = (char *)gettext("Modified tail combined with head of form field value.");
          HTUserMsg(pcVar4);
        }
        if (LYtrimInputFields != '\0') {
          LYTrimTrailing(form->value);
        }
        if ((form->value != (char *)0x0) && (*form->value != '\0')) {
          form->value_cs = current_char_set;
        }
      }
      local_44cc = ch;
      goto LAB_080aecb1;
    }
    LYRefreshEdit(&MyEdit);
  }
  if (((action == L'\x18') && (HTCJK == NOCJK)) && (0x97 < LYlowest_eightbit[current_char_set]))
  goto breakfor;
  if (action == L'\x03') {
    ch = L'\t';
    goto breakfor;
  }
  if (action == L'\x05') {
    local_44cc = L'';
    goto LAB_080aecb1;
  }
  if (action == L'\x04') {
    textfields_need_activation = '\x01';
    goto breakfor;
  }
  if (action == L'\0') {
    if (ch == L'\xffffffff') {
      bVar7 = keymap[0] == 0x15;
    }
    else if ((ch & 0x8800U) == 0) {
      bVar7 = keymap[(ch & 0x7ffU) + 1] == 0x15;
    }
    else {
      bVar7 = (ch & 0xffU) == 0x15;
    }
    if (bVar7) goto breakfor;
  }
  if (((action == L'\x11') && (MyEdit.pos == L'\0')) && (repeat == L'\xffffffff')) {
    c = L'\x01';
    if (textfield_prompt_at_left_edge == '\0') {
      iVar5 = strcmp(MyEdit.buffer,value);
      if (iVar5 != 0) {
        pcVar4 = (char *)gettext("Do you want to go back to the previous document?");
        c = HTConfirmDefault(pcVar4,L'\0');
      }
    }
    else {
      pcVar4 = (char *)gettext("Do you want to go back to the previous document?");
      c = HTConfirmDefault(pcVar4,L'\0');
    }
    if (c == L'\x01') {
      local_44cc = ch;
      goto LAB_080aecb1;
    }
    if (form->disabled == L'\x01') {
      mustshow = '\x01';
      pcVar4 = (char *)gettext("Use arrows or tab to move off of field.");
      statusline(pcVar4);
    }
    else {
      mustshow = '\x01';
      pcVar4 = (char *)gettext("Enter text.  Use arrows or tab to move off of field.");
      statusline(pcVar4);
    }
  }
  if ((form->disabled != L'\x01') ||
     (((uint)(action + L'\xfffffff3') < 0x16 &&
      (local_44e0 = (byte)(action + L'\xfffffff3'), (1 << (local_44e0 & 0x1f) & 0x3000ffU) != 0))))
  {
    if (repeat < L'\0') {
      repeat = L'\x01';
    }
    while (bVar7 = repeat != L'\0', repeat = repeat + L'\xffffffff', bVar7) {
      wVar2 = LYEdit1(&MyEdit,ch,action & 0xffffff7f,'\x01');
      if (wVar2 < L'\0') {
        ch = -wVar2;
        if ((action != L'\x12') && (action != L'\x10')) goto breakfor;
        if ((L'\xffffffff' < cur) && (cur < nlinks)) {
          if (action == L'\x10') {
            if (cur < nlinks + L'\xffffffff') {
LAB_080ae9f2:
              if (action == L'\x10') {
                local_44bc = 1;
              }
              else {
                local_44bc = -1;
              }
              if (links[local_44bc + cur].ly == links[cur].ly) goto breakfor;
            }
          }
          else if (L'\0' < cur) goto LAB_080ae9f2;
        }
      }
      if (wVar2 == L'\0') {
        if ((((HTCJK == NOCJK) || (ch < L'\x80')) || (L'' < ch)) || (refresh_mb == '\0')) {
          refresh_mb = '\x01';
        }
        else {
          refresh_mb = '\0';
        }
      }
      else if (refresh_mb == '\0') {
        LYEdit1(&MyEdit,L'\0',L'\t','\x01');
      }
    }
    if (MyEdit.strlen < max_length) {
      if ((HaveMaxlength != '\0') && (MyEdit.strlen < max_length)) {
        HaveMaxlength = '\0';
        mustshow = '\x01';
        pcVar4 = (char *)gettext("Enter text.  Use arrows or tab to move off of field.");
        statusline(pcVar4);
      }
    }
    else {
      HaveMaxlength = '\x01';
    }
    iVar5 = strcmp(value,MyEdit.buffer);
    if (iVar5 != 0) {
      Edited = '\x01';
    }
    if (refresh_mb != '\0') {
      LYRefreshEdit(&MyEdit);
    }
    LYSetLastTFPos(MyEdit.pos);
  }
  goto again;
}



// WARNING: Unknown calling convention

void show_formlink_statusline(FormInfo *form,wchar_t for_what)

{
  char *pcVar1;
  char *xkey_info_1;
  char *submit_str;
  char *xkey_info;
  
  switch(form->type) {
  case L'\x01':
    if (form->disabled == L'\x01') {
      pcVar1 = (char *)gettext(
                              "UNMODIFIABLE form text field.  Use UP or DOWN arrows or tab to move off."
                              );
      statusline(pcVar1);
    }
    else if (for_what == L'\0') {
      pcVar1 = (char *)gettext("(Text entry field) Inactive.  Press <return> to activate.");
      statusline(pcVar1);
    }
    else {
      pcVar1 = (char *)gettext(
                              "(Text entry field) Enter text.  Use UP or DOWN arrows or tab to move off."
                              );
      statusline(pcVar1);
    }
    break;
  case L'\x02':
    if (form->disabled == L'\x01') {
      pcVar1 = (char *)gettext(
                              "UNMODIFIABLE form password.  Use UP or DOWN arrows or tab to move off."
                              );
      statusline(pcVar1);
    }
    else if (for_what == L'\0') {
      pcVar1 = (char *)gettext("(Password entry field) Inactive.  Press <return> to activate.");
      statusline(pcVar1);
    }
    else {
      pcVar1 = (char *)gettext(
                              "(Password entry field) Enter text.  Use UP or DOWN arrows or tab to move off."
                              );
      statusline(pcVar1);
    }
    break;
  case L'\x03':
    if (form->disabled == L'\x01') {
      pcVar1 = (char *)gettext(
                              "UNMODIFIABLE form checkbox.  Use UP or DOWN arrows or tab to move off."
                              );
      statusline(pcVar1);
    }
    else {
      pcVar1 = (char *)gettext("(Checkbox Field)   Use right-arrow or <return> to toggle.");
      statusline(pcVar1);
    }
    break;
  case L'\x04':
    if (form->disabled == L'\x01') {
      pcVar1 = (char *)gettext(
                              "UNMODIFIABLE form radio button.  Use UP or DOWN arrows or tab to move off."
                              );
      statusline(pcVar1);
    }
    else {
      pcVar1 = (char *)gettext("(Radio Button)   Use right-arrow or <return> to toggle.");
      statusline(pcVar1);
    }
    break;
  case L'\x05':
  case L'\r':
    if (form->disabled == L'\x01') {
      pcVar1 = (char *)gettext(
                              "DISABLED form submit button.  Use UP or DOWN arrows or tab to move off."
                              );
      statusline(pcVar1);
    }
    else if (form->submit_method == L'\x03') {
      if (no_mail == '\0') {
        if (user_mode == 2) {
          submit_str = (char *)0x0;
          pcVar1 = (char *)gettext("Submit mailto form to ");
          HTSACopy(&submit_str,pcVar1);
          HTSACat(&submit_str,form->submit_action);
          statusline(submit_str);
          if (submit_str != (char *)0x0) {
            free(submit_str);
          }
        }
        else {
          pcVar1 = (char *)gettext(
                                  "(mailto form submit button) Use right-arrow or <return> to submit."
                                  );
          statusline(pcVar1);
        }
      }
      else {
        pcVar1 = (char *)gettext(
                                "(mailto form submit button) Mail is disallowed so you cannot submit."
                                );
        statusline(pcVar1);
      }
    }
    else if (form->no_cache == '\0') {
      if (user_mode == 2) {
        submit_str = (char *)0x0;
        pcVar1 = (char *)gettext("Submit (\'x\' for no cache) to ");
        HTSACopy(&submit_str,pcVar1);
        HTSACat(&submit_str,form->submit_action);
        statusline(submit_str);
        if (submit_str != (char *)0x0) {
          free(submit_str);
        }
      }
      else {
        pcVar1 = (char *)gettext(
                                "(Form submit button) Use right-arrow or <return> to submit (\'x\' for no cache)."
                                );
        statusline(pcVar1);
      }
    }
    else if (user_mode == 2) {
      submit_str = (char *)0x0;
      pcVar1 = (char *)gettext("Submit to ");
      HTSACopy(&submit_str,pcVar1);
      HTSACat(&submit_str,form->submit_action);
      statusline(submit_str);
      if (submit_str != (char *)0x0) {
        free(submit_str);
      }
    }
    else {
      pcVar1 = (char *)gettext("(Form submit button) Use right-arrow or <return> to submit.");
      statusline(pcVar1);
    }
    break;
  case L'\x06':
    if (form->disabled == L'\x01') {
      pcVar1 = (char *)gettext(
                              "DISABLED form reset button.  Use UP or DOWN arrows or tab to move off."
                              );
      statusline(pcVar1);
    }
    else {
      pcVar1 = (char *)gettext(
                              "(Form reset button)   Use right-arrow or <return> to reset form to defaults."
                              );
      statusline(pcVar1);
    }
    break;
  case L'\a':
    if (form->disabled == L'\x01') {
      pcVar1 = (char *)gettext(
                              "UNMODIFIABLE option list.  Use return or arrow keys to review or leave."
                              );
      statusline(pcVar1);
    }
    else {
      pcVar1 = (char *)gettext(
                              "(Option list) Hit return and use arrow keys and return to select option."
                              );
      statusline(pcVar1);
    }
    break;
  case L'\t':
    if (form->disabled == L'\x01') {
      pcVar1 = (char *)gettext(
                              "UNMODIFIABLE form text field.  Use UP or DOWN arrows or tab to move off."
                              );
      statusline(pcVar1);
    }
    else {
      submit_str = (char *)0x0;
      xkey_info_1 = (char *)0x0;
      if ((((no_editor == '\0') && (editor != (char *)0x0)) && (editor != (char *)0x0)) &&
         (xkey_info_1 = key_for_func_ext(0x56,for_what), xkey_info_1 == (char *)0x0)) {
        xkey_info_1 = key_for_func_ext(0x55,for_what);
      }
      if ((xkey_info_1 == (char *)0x0) || (*xkey_info_1 == '\0')) {
        if (for_what == L'\0') {
          pcVar1 = (char *)gettext("(Textarea) Inactive.  Press <return> to activate.");
          statusline(pcVar1);
        }
        else {
          pcVar1 = (char *)gettext("(Textarea) Enter text. Use UP/DOWN arrows or TAB to move off.");
          statusline(pcVar1);
        }
      }
      else {
        if (for_what == L'\0') {
          pcVar1 = (char *)gettext(
                                  "(Textarea) Inactive.  Press <return> to activate (%s for editor)."
                                  );
          HTSprintf0(&submit_str,pcVar1,xkey_info_1);
        }
        else {
          pcVar1 = (char *)gettext(
                                  "(Textarea) Enter text. Use UP/DOWN arrows or TAB to move off (%s for editor)."
                                  );
          HTSprintf0(&submit_str,pcVar1,xkey_info_1);
        }
        statusline(submit_str);
        if (submit_str != (char *)0x0) {
          free(submit_str);
          submit_str = (char *)0x0;
        }
      }
      if (xkey_info_1 != (char *)0x0) {
        free(xkey_info_1);
      }
    }
    break;
  case L'\v':
    if (form->disabled == L'\x01') {
      pcVar1 = (char *)gettext(
                              "UNMODIFIABLE file entry field.  Use UP or DOWN arrows or tab to move off."
                              );
      statusline(pcVar1);
    }
    else {
      pcVar1 = (char *)gettext(
                              "(File entry field) Enter filename.  Use UP or DOWN arrows or tab to move off."
                              );
      statusline(pcVar1);
    }
    break;
  case L'\f':
    if (form->disabled == L'\x01') {
      pcVar1 = (char *)gettext("UNMODIFIABLE form field.  Use UP or DOWN arrows or tab to move off."
                              );
      statusline(pcVar1);
    }
    else if (form->submit_method == L'\x03') {
      if (no_mail == '\0') {
        if (for_what == L'\0') {
          pcVar1 = (char *)gettext("(mailto form field) Inactive.  Press <return> to change.");
          statusline(pcVar1);
        }
        else {
          pcVar1 = (char *)gettext(
                                  "(mailto form field) Enter text.  Use <return> to submit, arrows to move off."
                                  );
          statusline(pcVar1);
        }
      }
      else {
        pcVar1 = (char *)gettext("(mailto form field) Mail is disallowed so you cannot submit.");
        statusline(pcVar1);
      }
    }
    else if (form->no_cache == '\0') {
      submit_str = (char *)0x0;
      xkey_info = key_for_func_ext(0x2e,for_what);
      if ((xkey_info == (char *)0x0) || (*xkey_info == '\0')) {
        if (for_what == L'\0') {
          pcVar1 = (char *)gettext("(Form field) Inactive.  Use <return> to edit.");
          statusline(pcVar1);
        }
        else {
          pcVar1 = (char *)gettext("(Form field) Enter text.  Use <return> to submit.");
          statusline(pcVar1);
        }
      }
      else {
        if (for_what == L'\0') {
          pcVar1 = (char *)gettext(
                                  "(Form field) Inactive.  Use <return> to edit (%s to submit with no cache)."
                                  );
          HTSprintf0(&submit_str,pcVar1,xkey_info);
        }
        else {
          pcVar1 = (char *)gettext(
                                  "(Form field) Enter text.  Use <return> to submit (%s for no cache)."
                                  );
          HTSprintf0(&submit_str,pcVar1,xkey_info);
        }
        statusline(submit_str);
        if (submit_str != (char *)0x0) {
          free(submit_str);
          submit_str = (char *)0x0;
        }
      }
      if (xkey_info != (char *)0x0) {
        free(xkey_info);
      }
    }
    else if (for_what == L'\0') {
      pcVar1 = (char *)gettext(
                              "(Form field) Inactive. Press <return> to edit, press <return> twice to submit."
                              );
      statusline(pcVar1);
    }
    else {
      pcVar1 = (char *)gettext(
                              "(Form field) Enter text.  Use <return> to submit, arrows or tab to move off."
                              );
      statusline(pcVar1);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void set_environ(wchar_t name,char *value,char *no_value)

{
  char *local_18;
  char *envbuffer;
  
  envbuffer = (char *)0x0;
  HTSACopy(&envbuffer,set_environ::names[name]);
  HTSACat(&envbuffer,"=");
  if (value == (char *)0x0) {
    local_18 = no_value;
  }
  else {
    local_18 = value;
  }
  HTSACat(&envbuffer,local_18);
  putenv(envbuffer);
  if (set_environ::pointers[name] != (char *)0x0) {
    free(set_environ::pointers[name]);
    set_environ::pointers[name] = (char *)0x0;
  }
  set_environ::pointers[name] = envbuffer;
  return;
}



// WARNING: Unknown calling convention

char * suggested_filename(DocInfo *newdoc)

{
  char *pcVar1;
  CompressFileType CVar2;
  FILE *__stream;
  wchar_t rootlen;
  char *sug_filename;
  
  sug_filename = (char *)0x0;
  pcVar1 = HText_getSugFname();
  if (pcVar1 == (char *)0x0) {
    HTSACopy(&sug_filename,newdoc->address);
  }
  else {
    pcVar1 = HText_getSugFname();
    HTSACopy(&sug_filename,pcVar1);
  }
  CVar2 = HTCompressFileType(sug_filename,".",&rootlen);
  pcVar1 = sug_filename;
  if (CVar2 != cftNone) {
    sug_filename[rootlen] = '\0';
  }
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"suggest %s\n",pcVar1);
  }
  return sug_filename;
}



// WARNING: Unknown calling convention

void SetupFilename(char *filename,char *sug_filename)

{
  char *pcVar1;
  wchar_t wVar2;
  char *__dest;
  FILE *pFVar3;
  int iVar4;
  HTAtom *pHVar5;
  char *cp;
  HTAtom *encoding;
  HTFormat format;
  
  LYstrncpy(filename,sug_filename,L'');
  change_sug_filename(filename);
  wVar2 = HTisDocumentSource();
  if (wVar2 == L'\0') {
    __dest = strrchr(filename,0x2e);
    if ((__dest != (char *)0x0) && ((int)__dest - (int)filename < 0xfa)) {
      format = HTFileFormat(filename,&encoding,(char **)0x0);
      if (WWW_TraceFlag != '\0') {
        pcVar1 = format->name;
        pFVar3 = TraceFP();
        fprintf((FILE *)pFVar3,"... format %s\n",pcVar1);
      }
      iVar4 = strcasecomp(format->name,"text/html");
      if (iVar4 != 0) {
        if (encoding == (HTAtom *)0x0) goto LAB_080af672;
        pHVar5 = HTAtom_for("identity");
        if (pHVar5 == encoding) goto LAB_080af672;
        pHVar5 = HTAtom_for("8bit");
        if (pHVar5 == encoding) goto LAB_080af672;
        pHVar5 = HTAtom_for("binary");
        if (pHVar5 == encoding) goto LAB_080af672;
        pHVar5 = HTAtom_for("7bit");
        if (pHVar5 == encoding) goto LAB_080af672;
      }
      memcpy(__dest,&DAT_0815f2de,5);
    }
  }
LAB_080af672:
  if (WWW_TraceFlag != '\0') {
    pFVar3 = TraceFP();
    fprintf((FILE *)pFVar3,"... result %s\n",filename);
  }
  return;
}



// WARNING: Unknown calling convention

wchar_t RecallFilename(char *filename,BOOLEAN *first,wchar_t *now,wchar_t *total,wchar_t flag)

{
  RecallType recall_00;
  wchar_t wVar1;
  char *pcVar2;
  wchar_t local_1c;
  RecallType recall;
  char *cp;
  wchar_t ch;
  
  if (*now < L'\0') {
    if (sug_filenames == (HTList *)0x0) {
      local_1c = L'\0';
    }
    else {
      local_1c = HTList_count(sug_filenames);
    }
    *total = local_1c;
    *now = *total;
  }
  recall_00 = (RecallType)(L'\0' < *total);
  wVar1 = LYgetstr(filename,L'\0',0x100,recall_00);
  if ((((L'\xffffffff' < wVar1) && (*filename != '\0')) && (wVar1 != L'')) && (wVar1 != L'')) {
    return L'\x02';
  }
  if ((recall_00 == NORECALL) || (wVar1 != L'')) {
    if ((recall_00 != NORECALL) && (wVar1 == L'')) {
      if (*first == '\0') {
        *now = *now + L'\xffffffff';
      }
      else {
        *first = '\0';
        *now = *total + L'\xffffffff';
      }
      if (*now < L'\0') {
        *first = '\x01';
        *now = *total;
        mustshow = '\x01';
        pcVar2 = (char *)gettext("Enter a filename: ");
        statusline(pcVar2);
        return L'\0';
      }
      pcVar2 = (char *)HTList_objectAt(sug_filenames,*now);
      if (pcVar2 != (char *)0x0) {
        LYstrncpy(filename,pcVar2,L'');
        if (*total == L'\x01') {
          mustshow = '\x01';
          pcVar2 = (char *)gettext("Edit the previous filename: ");
          statusline(pcVar2);
        }
        else {
          mustshow = '\x01';
          pcVar2 = (char *)gettext("Edit a previous filename: ");
          statusline(pcVar2);
        }
        return L'\x01';
      }
    }
  }
  else {
    if (*first == '\0') {
      *now = *now + L'\x01';
    }
    else {
      *first = '\0';
      *now = L'\0';
    }
    if (*total <= *now) {
      *first = '\x01';
      *now = *total;
      mustshow = '\x01';
      pcVar2 = (char *)gettext("Enter a filename: ");
      statusline(pcVar2);
      return L'\0';
    }
    pcVar2 = (char *)HTList_objectAt(sug_filenames,*now);
    if (pcVar2 != (char *)0x0) {
      LYstrncpy(filename,pcVar2,L'');
      if (*total == L'\x01') {
        mustshow = '\x01';
        pcVar2 = (char *)gettext("Edit the previous filename: ");
        statusline(pcVar2);
      }
      else {
        mustshow = '\x01';
        pcVar2 = (char *)gettext("Edit a previous filename: ");
        statusline(pcVar2);
      }
      return L'\x01';
    }
  }
  if (flag == L'\0') {
    pcVar2 = (char *)gettext("Save request cancelled!!!");
    HTInfoMsg(pcVar2);
  }
  else if (flag == L'\x01') {
    return L'\x03';
  }
  return L'\x03';
}



// WARNING: Unknown calling convention

BOOLEAN confirm_by_pages(char *prompt,wchar_t lines_in_file,wchar_t lines_per_page)

{
  char *Msg;
  char *msg;
  wchar_t c;
  wchar_t pages;
  
  pages = lines_in_file / (lines_per_page + L'\x01');
  if (0 < lines_in_file % (LYlines + 1)) {
    pages = pages + L'\x01';
  }
  if (L'\x04' < pages) {
    msg = (char *)0x0;
    HTSprintf0(&msg,prompt,pages);
    c = HTConfirmDefault(msg,L'\x01');
    if (msg != (char *)0x0) {
      free(msg);
      msg = (char *)0x0;
    }
    if (c != L'\x01') {
      Msg = (char *)gettext("Print request cancelled!!!");
      HTInfoMsg(Msg);
      return '\0';
    }
    LYwaddnstr(LYwin,"   Ok...",8);
  }
  return '\x01';
}



void send_file_to_file(DocInfo *newdoc,char *content_base,char *sug_filename)

{
  int iVar1;
  BOOLEAN BVar2;
  char *pcVar3;
  size_t sVar4;
  size_t sVar5;
  wchar_t wVar6;
  FILE *pFVar7;
  int *piVar8;
  ushort **ppuVar9;
  char *__s1;
  int iVar10;
  int in_GS_OFFSET;
  bool bVar11;
  FILE *local_23c;
  char *sug_filename_local;
  char *content_base_local;
  DocInfo *newdoc_local;
  wchar_t c;
  wchar_t FnameTotal;
  wchar_t FnameNum;
  FILE *outfile_fp;
  char *disp_charset;
  BOOLEAN use_cte;
  BOOLEAN FirstRecall;
  char filename [256];
  char buffer [256];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  FirstRecall = '\x01';
  FnameNum = L'\xffffffff';
  mustshow = '\x01';
  pcVar3 = (char *)gettext("Enter a filename: ");
  statusline(pcVar3);
retry:
  while( true ) {
    do {
      SetupFilename(filename,sug_filename);
      if (lynx_save_space != (char *)0x0) {
        sVar4 = strlen(lynx_save_space);
        sVar5 = strlen(filename);
        if (sVar4 + sVar5 < 0x100) {
          strcpy(buffer,lynx_save_space);
          strcat(buffer,filename);
          strcpy(filename,buffer);
        }
      }
      do {
        wVar6 = RecallFilename(filename,&FirstRecall,&FnameNum,&FnameTotal,L'\0');
      } while (wVar6 == L'\x01');
      if (wVar6 == L'\x03') goto done;
    } while (wVar6 == L'\0');
    BVar2 = LYValidateFilename(buffer,filename);
    if (BVar2 == '\0') {
      pcVar3 = (char *)gettext("Save request cancelled!!!");
      HTInfoMsg(pcVar3);
      goto done;
    }
    wVar6 = LYValidateOutput(buffer);
    if (wVar6 != L'N') break;
    mustshow = '\x01';
    pcVar3 = (char *)gettext("Enter a new filename: ");
    statusline(pcVar3);
    FirstRecall = '\x01';
    FnameNum = FnameTotal;
  }
  if (wVar6 != L'Y') goto done;
  if (WWW_TraceFlag != '\0') {
    pFVar7 = TraceFP();
    fprintf((FILE *)pFVar7,"LYPrint: filename is %s, action is `%c\'\n",buffer,0);
  }
  if (buffer[0] == '|') {
    if (no_shell != '\0') {
      pcVar3 = (char *)gettext("Spawning is currently disabled.");
      HTUserMsg(pcVar3);
      FirstRecall = '\x01';
      FnameNum = FnameTotal;
      goto retry;
    }
    outfile_fp = (FILE *)popen(buffer + 1,"w");
    if (outfile_fp == (FILE *)0x0) {
      if (WWW_TraceFlag != '\0') {
        piVar8 = __errno_location();
        iVar10 = *piVar8;
        pFVar7 = TraceFP();
        fprintf((FILE *)pFVar7,"LYPrint: errno is %d\n",iVar10);
      }
      pcVar3 = (char *)gettext("Cannot write to file.");
      HTAlert(pcVar3);
      mustshow = '\x01';
      pcVar3 = (char *)gettext("Enter a new filename: ");
      statusline(pcVar3);
      FirstRecall = '\x01';
      FnameNum = FnameTotal;
      goto retry;
    }
  }
  else {
    ppuVar9 = __ctype_b_loc();
    if ((**ppuVar9 & 0x200) == 0) {
      bVar11 = false;
    }
    else {
      iVar10 = toupper(0);
      bVar11 = iVar10 == 0x41;
    }
    if (bVar11) {
      local_23c = LYAppendToTxtFile(buffer);
    }
    else {
      local_23c = LYNewTxtFile(buffer);
    }
    outfile_fp = local_23c;
    if (local_23c == (FILE *)0x0) {
      if (WWW_TraceFlag != '\0') {
        piVar8 = __errno_location();
        iVar10 = *piVar8;
        pFVar7 = TraceFP();
        fprintf((FILE *)pFVar7,"LYPrint: errno is %d\n",iVar10);
      }
      pcVar3 = (char *)gettext("Cannot write to file.");
      HTAlert(pcVar3);
      mustshow = '\x01';
      pcVar3 = (char *)gettext("Enter a new filename: ");
      statusline(pcVar3);
      FirstRecall = '\x01';
      FnameNum = FnameTotal;
      goto retry;
    }
  }
  if (LYPrependBaseToSource != '\0') {
    wVar6 = HTisDocumentSource();
    if (wVar6 != L'\0') {
      fprintf((FILE *)outfile_fp,"<!-- X-URL: %s -->\n",newdoc->address);
      pcVar3 = HText_getDate();
      if (pcVar3 != (char *)0x0) {
        pcVar3 = HText_getDate();
        fprintf((FILE *)outfile_fp,"<!-- Date: %s -->\n",pcVar3);
        pcVar3 = HText_getLastModified();
        if (pcVar3 != (char *)0x0) {
          pcVar3 = HText_getDate();
          __s1 = HText_getLastModified();
          iVar10 = strcmp(__s1,pcVar3);
          if (iVar10 != 0) {
            pcVar3 = HText_getLastModified();
            iVar10 = strcmp(pcVar3,"Thu, 01 Jan 1970 00:00:01 GMT");
            if (iVar10 != 0) {
              pcVar3 = HText_getLastModified();
              fprintf((FILE *)outfile_fp,"<!-- Last-Modified: %s -->\n",pcVar3);
            }
          }
        }
      }
      fprintf((FILE *)outfile_fp,"<BASE HREF=\"%s\">\n",content_base);
    }
  }
  if (LYPrependCharsetToSource != '\0') {
    wVar6 = HTisDocumentSource();
    if (wVar6 != L'\0') {
      use_cte = HTLoadedDocumentEightbit();
      disp_charset = LYCharSet_UC[current_char_set].MIMEname;
      if ((use_cte != '\0') && (LYHaveCJKCharacterSet == '\0')) {
        iVar10 = strncasecomp(disp_charset,"x-",2);
        if (iVar10 != 0) {
          fprintf((FILE *)outfile_fp,
                  "<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=%s\">\n\n",
                  disp_charset);
        }
      }
    }
  }
  print_wwwfile_to_fd(outfile_fp,'\0','\0');
  if (keypad_mode != 0) {
    printlist(outfile_fp,'\0');
  }
  if (buffer[0] == '|') {
    pclose((FILE *)outfile_fp);
  }
  else {
    LYCloseOutput(outfile_fp);
  }
  HTAddSugFilename(buffer);
done:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void send_file_to_mail(DocInfo *newdoc,char *content_base,char *content_location)

{
  int iVar1;
  BOOLEAN BVar2;
  wchar_t wVar3;
  char *pcVar4;
  int iVar5;
  int in_GS_OFFSET;
  BOOLEAN local_43c;
  char local_438;
  char local_434;
  char *content_location_local;
  char *content_base_local;
  DocInfo *newdoc_local;
  char *subject;
  char *buffer;
  FILE *outfile_fp;
  char *disp_charset;
  BOOLEAN use_type;
  BOOLEAN use_cte;
  BOOLEAN use_mime;
  char user_response [1024];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  buffer = (char *)0x0;
  subject = (char *)0x0;
  BVar2 = LYSystemMail();
  if (BVar2 == '\0') goto LAB_080b0649;
  if ((LYPreparsedSource == '\0') || (send_file_to_mail::first_mail_preparsed == '\0')) {
LAB_080b0154:
    mustshow = '\x01';
    pcVar4 = (char *)gettext("Please enter a valid internet mail address: ");
    statusline(pcVar4);
    LYstrncpy(user_response,personal_mail_address,L'');
    wVar3 = LYgetstr(user_response,L'\0',0x400,RECALL_MAIL);
    if ((wVar3 < L'\0') || (user_response[0] == '\0')) {
      pcVar4 = (char *)gettext("Mail request cancelled!!!");
      HTInfoMsg(pcVar4);
    }
    else {
      disp_charset = LYCharSet_UC[current_char_set].MIMEname;
      use_cte = HTLoadedDocumentEightbit();
      if (use_cte == '\0') {
LAB_080b0226:
        disp_charset = (char *)0x0;
        use_cte = '\0';
      }
      else {
        iVar5 = strncasecomp(disp_charset,"x-",2);
        if (iVar5 == 0) goto LAB_080b0226;
      }
      if (disp_charset == (char *)0x0) {
        wVar3 = HTisDocumentSource();
        if (wVar3 != L'\0') goto LAB_080b0249;
        local_43c = '\0';
      }
      else {
LAB_080b0249:
        local_43c = '\x01';
      }
      use_type = local_43c;
      subject = subject_translate8bit(newdoc->title);
      if (newdoc->isHEAD != '\0') {
        if (subject != (char *)0x0) {
          free(subject);
          subject = (char *)0x0;
        }
        HTSACopy(&subject,"HEAD  ");
        HTSACat(&subject,newdoc->address);
      }
      outfile_fp = LYPipeToMailer();
      if (outfile_fp == (FILE *)0x0) {
        pcVar4 = (char *)gettext("ERROR - Unable to mail file");
        HTAlert(pcVar4);
      }
      else {
        use_cte = HTLoadedDocumentEightbit();
        disp_charset = LYCharSet_UC[current_char_set].MIMEname;
        if ((use_cte == '\0') || (LYHaveCJKCharacterSet != '\0')) {
LAB_080b0365:
          disp_charset = (char *)0x0;
        }
        else {
          iVar5 = strncasecomp(disp_charset,"x-",2);
          if (iVar5 == 0) goto LAB_080b0365;
        }
        if (disp_charset == (char *)0x0) {
          wVar3 = HTisDocumentSource();
          if (wVar3 != L'\0') goto LAB_080b0381;
          local_438 = '\0';
        }
        else {
LAB_080b0381:
          local_438 = '\x01';
        }
        use_type = local_438;
        if ((use_cte == '\0') && (local_438 == '\0')) {
          local_434 = '\0';
        }
        else {
          local_434 = '\x01';
        }
        use_mime = local_434;
        if (local_434 != '\0') {
          fwrite("Mime-Version: 1.0\n",1,0x12,(FILE *)outfile_fp);
          if (use_cte != '\0') {
            fwrite("Content-Transfer-Encoding: 8bit\n",1,0x20,(FILE *)outfile_fp);
          }
        }
        wVar3 = HTisDocumentSource();
        if (wVar3 == L'\0') {
          if (disp_charset != (char *)0x0) {
            fprintf((FILE *)outfile_fp,"Content-Type: text/plain; charset=%s\n",disp_charset);
          }
        }
        else {
          fwrite("Content-Type: text/html",1,0x17,(FILE *)outfile_fp);
          if (disp_charset == (char *)0x0) {
            fputc(10,(FILE *)outfile_fp);
          }
          else {
            fprintf((FILE *)outfile_fp,"; charset=%s\n",disp_charset);
          }
        }
        if (use_mime != '\0') {
          if (content_base != (char *)0x0) {
            fprintf((FILE *)outfile_fp,"Content-Base: %s\n",content_base);
          }
          if (content_location != (char *)0x0) {
            fprintf((FILE *)outfile_fp,"Content-Location: %s\n",content_location);
          }
        }
        fprintf((FILE *)outfile_fp,"To: %s\nSubject: %s\n",user_response,subject);
        fprintf((FILE *)outfile_fp,"X-URL: %s\n\n",newdoc->address);
        if (LYPrependBaseToSource != '\0') {
          wVar3 = HTisDocumentSource();
          if (wVar3 != L'\0') {
            fprintf((FILE *)outfile_fp,"<!-- X-URL: %s -->\n<BASE HREF=\"%s\">\n\n",newdoc->address,
                    content_base);
          }
        }
        print_wwwfile_to_fd(outfile_fp,'\x01','\0');
        if (keypad_mode != 0) {
          printlist(outfile_fp,'\0');
        }
        pclose((FILE *)outfile_fp);
      }
    }
  }
  else {
    wVar3 = HTisDocumentSource();
    if (wVar3 == L'\0') goto LAB_080b0154;
    pcVar4 = (char *)gettext("Viewing preparsed source.  Are you sure you want to mail it?");
    wVar3 = HTConfirmDefault(pcVar4,L'\0');
    if (wVar3 == L'\x01') {
      LYwaddnstr(LYwin,"   Ok...",8);
      send_file_to_mail::first_mail_preparsed = '\0';
      goto LAB_080b0154;
    }
    pcVar4 = (char *)gettext("Mail request cancelled!!!");
    HTInfoMsg(pcVar4);
  }
  if (buffer != (char *)0x0) {
    free(buffer);
    buffer = (char *)0x0;
  }
  if (subject != (char *)0x0) {
    free(subject);
    subject = (char *)0x0;
  }
LAB_080b0649:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void send_file_to_printer
               (DocInfo *newdoc,char *content_base,char *sug_filename,wchar_t printer_number)

{
  int iVar1;
  wchar_t wVar2;
  char *pcVar3;
  int iVar4;
  FILE *__stream;
  int in_GS_OFFSET;
  char *local_23c;
  char *sug_filename_local;
  char *content_base_local;
  DocInfo *newdoc_local;
  wchar_t count;
  lynx_list_item_type *cur_printer;
  wchar_t FnameNum;
  wchar_t FnameTotal;
  char *the_command;
  FILE *outfile_fp;
  BOOLEAN FirstRecall;
  char my_temp [256];
  char my_file [256];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  FirstRecall = '\x01';
  the_command = (char *)0x0;
  FnameNum = L'\xffffffff';
  wVar2 = HTisDocumentSource();
  if (wVar2 == L'\0') {
    local_23c = ".txt";
  }
  else {
    local_23c = ".html";
  }
  outfile_fp = LYOpenTemp(my_temp,local_23c,"w");
  if (outfile_fp == (FILE *)0x0) {
    pcVar3 = (char *)gettext("ERROR - Unable to allocate file space!!!");
    HTAlert(pcVar3);
  }
  else {
    if (LYPrependBaseToSource != '\0') {
      wVar2 = HTisDocumentSource();
      if (wVar2 != L'\0') {
        fprintf((FILE *)outfile_fp,"<!-- X-URL: %s -->\n<BASE HREF=\"%s\">\n\n",newdoc->address,
                content_base);
      }
    }
    print_wwwfile_to_fd(outfile_fp,'\0','\0');
    if (keypad_mode != 0) {
      printlist(outfile_fp,'\0');
    }
    LYCloseTempFP(outfile_fp);
    cur_printer = printers;
    for (count = L'\0'; count < printer_number; count = count + L'\x01') {
      cur_printer = cur_printer->next;
    }
    if (cur_printer->command == (char *)0x0) {
      pcVar3 = (char *)gettext("ERROR! - printer is misconfigured!");
      HTAlert(pcVar3);
    }
    else {
      iVar4 = HTCountCommandArgs(cur_printer->command);
      if (iVar4 < 2) {
LAB_080b0950:
        HTAddParam(&the_command,cur_printer->command,1,my_temp);
        HTAddParam(&the_command,cur_printer->command,2,my_file);
        HTEndParam(&the_command,cur_printer->command,2);
        LYmove(L'\x01',L'\x01');
        stop_curses();
        pcVar3 = the_command;
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"command: %s\n",pcVar3);
        }
        pcVar3 = (char *)gettext("Printing file.  Please wait...");
        printf(pcVar3);
        pcVar3 = HText_getTitle();
        set_environ(L'\0',pcVar3,"");
        set_environ(L'\x01',newdoc->address,"");
        pcVar3 = HText_getDate();
        set_environ(L'\x02',pcVar3,"");
        pcVar3 = HText_getLastModified();
        set_environ(L'\x03',pcVar3,"");
        LYSystem(the_command);
        if (the_command != (char *)0x0) {
          free(the_command);
          the_command = (char *)0x0;
        }
        LYRemoveTemp(my_temp);
        set_environ(L'\0',"","");
        set_environ(L'\x01',"","");
        set_environ(L'\x02',"","");
        set_environ(L'\x03',"","");
        fflush(stdout);
        signal(2,cleanup_sig);
        LYSleepMsg();
        start_curses();
      }
      else {
        mustshow = '\x01';
        pcVar3 = (char *)gettext("Enter a filename: ");
        statusline(pcVar3);
again:
        do {
          SetupFilename(my_file,sug_filename);
          do {
            wVar2 = RecallFilename(my_file,&FirstRecall,&FnameNum,&FnameTotal,L'\0');
          } while (wVar2 == L'\x01');
          if (wVar2 == L'\x03') goto done;
        } while (wVar2 == L'\0');
        if ((no_dotfiles != '\0') || (show_dotfiles == '\0')) {
          pcVar3 = LYPathLeaf(my_file);
          if (*pcVar3 == '.') {
            pcVar3 = (char *)gettext("File name may not begin with a dot.");
            HTAlert(pcVar3);
            mustshow = '\x01';
            pcVar3 = (char *)gettext("Enter a new filename: ");
            statusline(pcVar3);
            FirstRecall = '\x01';
            FnameNum = FnameTotal;
            goto again;
          }
        }
        iVar4 = strcmp(my_file,"/dev/null");
        if (iVar4 != 0) {
          HTAddSugFilename(my_file);
          goto LAB_080b0950;
        }
        pcVar3 = (char *)gettext("Print request cancelled!!!");
        HTInfoMsg(pcVar3);
      }
    }
  }
done:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void send_file_to_screen(DocInfo *newdoc,char *content_base,BOOLEAN Lpansi)

{
  int iVar1;
  FILE *__stream;
  char *pcVar2;
  wchar_t wVar3;
  undefined4 uVar4;
  int in_GS_OFFSET;
  BOOLEAN Lpansi_local;
  char *content_base_local;
  DocInfo *newdoc_local;
  FILE *outfile_fp;
  char prompt [80];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if (Lpansi == '\0') {
    mustshow = '\x01';
    pcVar2 = (char *)gettext("Press <return> to begin: ");
    statusline(pcVar2);
  }
  else {
    mustshow = '\x01';
    pcVar2 = (char *)gettext("Be sure your printer is on-line.  Press <return> to start printing:");
    statusline(pcVar2);
  }
  prompt[0] = '\0';
  wVar3 = LYgetstr(prompt,L'\0',0x50,NORECALL);
  __stream = stdout;
  if (wVar3 < L'\0') {
    pcVar2 = (char *)gettext("Print request cancelled!!!");
    HTInfoMsg(pcVar2);
  }
  else {
    stop_curses();
    signal(2,(__sighandler_t)0x1);
    if (LYPrependBaseToSource != '\0') {
      wVar3 = HTisDocumentSource();
      if (wVar3 != L'\0') {
        fprintf(__stream,"<!-- X-URL: %s -->\n<BASE HREF=\"%s\">\n\n",newdoc->address,content_base);
      }
    }
    if (Lpansi != '\0') {
      printf("\x1b[5i");
    }
    print_wwwfile_to_fd((FILE *)__stream,'\0','\0');
    if (keypad_mode != 0) {
      printlist((FILE *)__stream,'\0');
    }
    if (Lpansi == '\0') {
      uVar4 = gettext("Press <return> to finish: ");
      fprintf(stdout,"\n\n%s",uVar4);
      fflush(stdout);
      LYgetch();
    }
    else {
      printf("\n\f");
      printf("\x1b[4i");
      fflush(stdout);
    }
    start_curses();
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



// WARNING: Unknown calling convention

wchar_t printfile(DocInfo *newdoc)

{
  int lines_per_page;
  BOOLEAN BVar1;
  char *pcVar2;
  wchar_t wVar3;
  UrlTypes UVar4;
  char *pcVar5;
  wchar_t local_4c;
  DocAddress WWWDoc;
  wchar_t type;
  wchar_t printer_number;
  wchar_t pagelen;
  wchar_t lines_in_file;
  char *sug_filename;
  char *link_info;
  char *cp;
  char *content_location;
  char *content_base;
  BOOLEAN Lpansi;
  
  Lpansi = '\0';
  content_base = (char *)0x0;
  content_location = (char *)0x0;
  cp = (char *)0x0;
  link_info = (char *)0x0;
  lines_in_file = L'\0';
  pagelen = L'\0';
  printer_number = L'\0';
  type = L'\0';
  HTSACopy(&link_info,newdoc->address + 0xc);
  LYpop(newdoc);
  WWWDoc.address = newdoc->address;
  WWWDoc.post_data = (bstring *)newdoc->post_data;
  WWWDoc.post_content_type = newdoc->post_content_type;
  WWWDoc.bookmark = newdoc->bookmark;
  WWWDoc.isHEAD = newdoc->isHEAD;
  WWWDoc.safe = newdoc->safe;
  BVar1 = HTLoadAbsolute(&WWWDoc);
  if (BVar1 == '\0') {
    local_4c = L'\0';
  }
  else {
    pcVar2 = HText_getContentBase();
    if (pcVar2 != (char *)0x0) {
      pcVar2 = HText_getContentBase();
      HTSACopy(&content_base,pcVar2);
      LYRemoveBlanks(content_base);
      if (((content_base == (char *)0x0) || (*content_base == '\0')) &&
         (content_base != (char *)0x0)) {
        free(content_base);
        content_base = (char *)0x0;
      }
    }
    wVar3 = HTisDocumentSource();
    if (wVar3 != L'\0') {
      pcVar2 = HText_getContentLocation();
      if (pcVar2 != (char *)0x0) {
        pcVar2 = HText_getContentLocation();
        HTSACopy(&content_location,pcVar2);
        LYRemoveBlanks(content_location);
        if (((content_location == (char *)0x0) || (*content_location == '\0')) &&
           (content_location != (char *)0x0)) {
          free(content_location);
          content_location = (char *)0x0;
        }
      }
      if (content_base == (char *)0x0) {
        if ((content_location == (char *)0x0) ||
           (UVar4 = is_url(content_location), UVar4 == NOT_A_URL_TYPE)) {
          HTSACopy(&content_base,newdoc->address);
        }
        else {
          HTSACopy(&content_base,content_location);
        }
      }
      if (content_location == (char *)0x0) {
        HTSACopy(&content_location,newdoc->address);
      }
    }
    pcVar2 = suggested_filename(newdoc);
    cp = strstr(link_info,"lines=");
    if (cp != (char *)0x0) {
      *cp = '\0';
      cp = cp + 6;
      lines_in_file = atoi(cp);
    }
    pcVar5 = strstr(link_info,"LOCAL_FILE");
    if (pcVar5 == (char *)0x0) {
      pcVar5 = strstr(link_info,"TO_SCREEN");
      if (pcVar5 == (char *)0x0) {
        pcVar5 = strstr(link_info,"LPANSI");
        if (pcVar5 == (char *)0x0) {
          pcVar5 = strstr(link_info,"MAIL_FILE");
          if (pcVar5 == (char *)0x0) {
            pcVar5 = strstr(link_info,"PRINTER");
            if (pcVar5 != (char *)0x0) {
              type = L'\x05';
              cp = strstr(link_info,"number=");
              if (cp != (char *)0x0) {
                cp = cp + 7;
                printer_number = atoi(cp);
              }
              pcVar5 = strstr(link_info,"pagelen=");
              if (pcVar5 == (char *)0x0) {
                pagelen = L'B';
                cp = (char *)0x0;
              }
              else {
                cp = pcVar5 + 8;
                pagelen = atoi(cp);
              }
            }
          }
          else {
            type = L'\x04';
          }
        }
        else {
          Lpansi = '\x01';
          type = L'\x02';
        }
      }
      else {
        type = L'\x02';
      }
    }
    else {
      type = L'\x01';
    }
    lines_per_page = LYlines;
    if (type == L'\x02') {
      pcVar5 = (char *)gettext("File is %d screens long.  Are you sure you want to print?");
      BVar1 = confirm_by_pages(pcVar5,lines_in_file,lines_per_page);
      if (BVar1 != '\0') {
        send_file_to_screen(newdoc,content_base,Lpansi);
      }
    }
    else if ((uint)type < 3) {
      if (type == L'\x01') {
        send_file_to_file(newdoc,content_base,pcVar2);
      }
    }
    else if (type == L'\x04') {
      send_file_to_mail(newdoc,content_base,content_location);
    }
    else if (type == L'\x05') {
      pcVar5 = (char *)gettext("File is %d pages long.  Are you sure you want to print?");
      BVar1 = confirm_by_pages(pcVar5,lines_in_file,pagelen);
      if (BVar1 != '\0') {
        send_file_to_printer(newdoc,content_base,pcVar2,printer_number);
      }
    }
    if (link_info != (char *)0x0) {
      free(link_info);
      link_info = (char *)0x0;
    }
    if (pcVar2 != (char *)0x0) {
      free(pcVar2);
    }
    if (content_base != (char *)0x0) {
      free(content_base);
      content_base = (char *)0x0;
    }
    if (content_location != (char *)0x0) {
      free(content_location);
    }
    local_4c = L'\x01';
  }
  return local_4c;
}



// WARNING: Unknown calling convention

char * subject_translate8bit(char *source)

{
  int cs_to;
  char *local_18;
  wchar_t i;
  wchar_t charset_out;
  wchar_t charset_in;
  char *target;
  
  cs_to = outgoing_mail_charset;
  target = (char *)0x0;
  HTSACopy(&target,source);
  if ((((cs_to < 0) || (cs_to == current_char_set)) || (LYCharSet_UC[current_char_set].enc == 5)) ||
     (LYCharSet_UC[cs_to].enc == 5)) {
    local_18 = target;
  }
  else {
    LYUCTranslateBackFormData(&target,current_char_set,cs_to,'\x01');
    local_18 = target;
  }
  return local_18;
}



// WARNING: Unknown calling convention

wchar_t print_options(char **newfile,char *printed_url,wchar_t lines_in_file)

{
  int iVar1;
  FILE *fp0_00;
  char *Title;
  undefined4 uVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  wchar_t wVar6;
  wchar_t local_40;
  undefined4 local_38;
  undefined4 local_34;
  char *local_30;
  lynx_list_item_type *cur_printer;
  FILE *fp0;
  wchar_t pages;
  wchar_t count;
  char *buffer;
  
  buffer = (char *)0x0;
  fp0_00 = InternalPageFP(print_options::my_temp,L'\x01');
  if (fp0_00 == (FILE *)0x0) {
    local_40 = L'\xffffffff';
  }
  else {
    LYLocalFileToURL(newfile,print_options::my_temp);
    Title = (char *)gettext("Printing Options");
    BeginInternalPage(fp0_00,Title,"keystrokes/print_help.html.gz");
    fwrite("<pre>\n",1,6,(FILE *)fp0_00);
    iVar1 = (lines_in_file + L'A') / 0x42;
    uVar2 = gettext("(approximately)");
    if (iVar1 < 2) {
      local_38 = gettext(&DAT_0815f8a8);
    }
    else {
      local_38 = gettext("pages");
    }
    uVar3 = gettext("Number of pages:");
    uVar4 = gettext("Number of lines:");
    uVar5 = gettext("Document:");
    HTSprintf0(&buffer,"   <em>%s</em> %s\n   <em>%s</em> %d\n   <em>%s</em> %d %s %s\n",uVar5,
               printed_url,uVar4,lines_in_file,uVar3,iVar1,local_38,uVar2);
    fputs(buffer,(FILE *)fp0_00);
    if (buffer != (char *)0x0) {
      free(buffer);
      buffer = (char *)0x0;
    }
    if (((no_print != '\0') || (no_disk_save != '\0')) || (no_mail != '\0')) {
      uVar2 = gettext("Some print functions have been disabled!");
      fprintf((FILE *)fp0_00,"   <em>%s</em>\n",uVar2);
    }
    if (user_mode == 0) {
      local_34 = gettext("Standard print options:");
    }
    else {
      local_34 = gettext("Print options:");
    }
    fprintf((FILE *)fp0_00,"\n%s\n",local_34);
    if ((no_disk_save == '\0') && (no_print == '\0')) {
      uVar2 = gettext("Save to a local file");
      fprintf((FILE *)fp0_00,"   <a href=\"%s//LOCAL_FILE/lines=%d\">%s</a>\n","LYNXPRINT:",
              lines_in_file,uVar2);
    }
    else {
      uVar2 = gettext("Save to disk disabled");
      fprintf((FILE *)fp0_00,"   <em>%s</em>\n",uVar2);
    }
    if ((no_mail == '\0') && (local_host_only == '\0')) {
      uVar2 = gettext("Mail the file");
      fprintf((FILE *)fp0_00,"   <a href=\"%s//MAIL_FILE/lines=%d\">%s</a>\n","LYNXPRINT:",
              lines_in_file,uVar2);
    }
    uVar2 = gettext("Print to the screen");
    fprintf((FILE *)fp0_00,"   <a href=\"%s//TO_SCREEN/lines=%d\">%s</a>\n","LYNXPRINT:",
            lines_in_file,uVar2);
    uVar2 = gettext("Print out on a printer attached to your vt100 terminal");
    wVar6 = lines_in_file;
    fprintf((FILE *)fp0_00,"   <a href=\"%s//LPANSI/lines=%d\">%s</a>\n","LYNXPRINT:",lines_in_file,
            uVar2);
    if (user_mode == 0) {
      uVar3 = gettext("Local additions:");
      fprintf((FILE *)fp0_00,"\n%s\n",uVar3,wVar6,uVar2);
    }
    count = L'\0';
    for (cur_printer = printers; cur_printer != (lynx_list_item_type *)0x0;
        cur_printer = cur_printer->next) {
      if ((no_print == '\0') || (cur_printer->always_enabled != L'\0')) {
        fprintf((FILE *)fp0_00,"   <a href=\"%s//PRINTER/number=%d/pagelen=%d/lines=%d\">",
                "LYNXPRINT:",count,cur_printer->pagelen,lines_in_file);
        if (cur_printer->name == (char *)0x0) {
          local_30 = "No Name Given";
        }
        else {
          local_30 = cur_printer->name;
        }
        fputs(local_30,(FILE *)fp0_00);
        fwrite("</a>\n",1,5,(FILE *)fp0_00);
      }
      count = count + L'\x01';
    }
    fwrite("</pre>\n",1,7,(FILE *)fp0_00);
    EndInternalPage(fp0_00);
    LYCloseTempFP(fp0_00);
    LYforce_no_cache = '\x01';
    local_40 = L'\0';
  }
  return local_40;
}



// WARNING: Unknown calling convention

char * GetFileName(void)

{
  int iVar1;
  BOOLEAN BVar2;
  char *pcVar3;
  wchar_t wVar4;
  int iVar5;
  size_t sVar6;
  int in_GS_OFFSET;
  char *local_288;
  stat stat_info;
  wchar_t FnameTotal;
  wchar_t FnameNum;
  char *fn;
  BOOLEAN FirstRecall;
  char tbuf [256];
  char fbuf [256];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  FirstRecall = '\x01';
  FnameNum = L'\xffffffff';
  mustshow = '\x01';
  pcVar3 = (char *)gettext("Enter a filename: ");
  statusline(pcVar3);
  while( true ) {
    do {
      SetupFilename(fbuf,"");
      do {
        wVar4 = RecallFilename(fbuf,&FirstRecall,&FnameNum,&FnameTotal,L'\x01');
      } while (wVar4 == L'\x01');
      if (wVar4 == L'\x03') goto quit;
    } while (wVar4 == L'\0');
    HTAddSugFilename(fbuf);
    BVar2 = LYValidateFilename(tbuf,fbuf);
    if (BVar2 == '\0') break;
    iVar5 = stat64(tbuf,(stat64 *)&stat_info);
    if ((iVar5 < 0) ||
       (((stat_info.st_mode & 0xf000) != 0x8000 && ((stat_info.st_mode & 0xf000) != 0xa000)))) {
      pcVar3 = (char *)gettext("File does not exist.");
      HTInfoMsg(pcVar3);
      mustshow = '\x01';
      pcVar3 = (char *)gettext("File does not exist - reenter or cancel:");
      statusline(pcVar3);
      FirstRecall = '\x01';
      FnameNum = FnameTotal;
    }
    else {
      BVar2 = LYCanReadFile(tbuf);
      if (BVar2 != '\0') {
        sVar6 = strlen(tbuf);
        fn = (char *)calloc(sVar6 + 1,1);
        if (fn == (char *)0x0) {
          outofmem("./LYPrint.c","GetFileName");
        }
        local_288 = strcpy(fn,tbuf);
        goto LAB_080b1920;
      }
      pcVar3 = (char *)gettext("File is not readable.");
      HTInfoMsg(pcVar3);
      mustshow = '\x01';
      pcVar3 = (char *)gettext("File is not readable - reenter or cancel:");
      statusline(pcVar3);
      FirstRecall = '\x01';
      FnameNum = FnameTotal;
    }
  }
quit:
  local_288 = (char *)0x0;
LAB_080b1920:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return local_288;
}



// WARNING: Unknown calling convention

BOOLEAN getBool(char *src)

{
  int iVar1;
  
  iVar1 = strncasecomp(src,"on",2);
  if ((iVar1 != 0) && (iVar1 = strncasecomp(src,"true",4), iVar1 != 0)) {
    return '\0';
  }
  return '\x01';
}



// WARNING: Unknown calling convention

char * LYputEnum(Config_Enum *table,int value)

{
  while( true ) {
    if (table->name == (char *)0x0) {
      return "?";
    }
    if (table->value == value) break;
    table = table + 1;
  }
  return table->name;
}



// WARNING: Unknown calling convention

BOOLEAN LYgetEnum(Config_Enum *table,char *name,int *result)

{
  size_t n;
  int iVar1;
  int match;
  uint len;
  Config_Enum *found;
  
  found = (Config_Enum *)0x0;
  n = strlen(name);
  match = 0;
  if (n != 0) {
    for (; table->name != (char *)0x0; table = table + 1) {
      iVar1 = strncasecomp(table->name,name,n);
      if (iVar1 == 0) {
        found = table;
        iVar1 = strcasecomp(table->name,name);
        if (iVar1 == 0) {
          match = 1;
          break;
        }
        match = match + 1;
      }
    }
    if (match == 1) {
      *result = found->value;
      return '\x01';
    }
  }
  return '\0';
}



// WARNING: Unknown calling convention

int get_assume_charset(char *value)

{
  int iVar1;
  int i;
  
  i = 0;
  while( true ) {
    if (LYNumCharsets <= i) {
      return 0;
    }
    iVar1 = strcasecomp(value,LYCharSet_UC[i].MIMEname);
    if (iVar1 == 0) break;
    i = i + 1;
  }
  UCLYhndl_for_unspec = i;
  return 0;
}



// WARNING: Unknown calling convention

void put_assume_charset(FILE *fp,config_type *tbl)

{
  int i;
  
  for (i = 0; i < LYNumCharsets; i = i + 1) {
    fprintf((FILE *)fp,"#    %s\n",LYCharSet_UC[i].MIMEname);
  }
  fprintf((FILE *)fp,"%s=%s\n\n",tbl->name,LYCharSet_UC[UCLYhndl_for_unspec].MIMEname);
  return;
}



// WARNING: Unknown calling convention

int get_display_charset(char *value)

{
  int iVar1;
  int i;
  
  iVar1 = UCGetLYhndl_byAnyName(value);
  if (-1 < iVar1) {
    current_char_set = iVar1;
  }
  return 0;
}



// WARNING: Unknown calling convention

void put_display_charset(FILE *fp,config_type *tbl)

{
  int i;
  
  for (i = 0; LYchar_set_names[i] != (char *)0x0; i = i + 1) {
    fprintf((FILE *)fp,"#    %s\n",LYchar_set_names[i]);
  }
  fprintf((FILE *)fp,"%s=%s\n\n",tbl->name,LYchar_set_names[current_char_set]);
  return;
}



// WARNING: Unknown calling convention

int get_editor(char *value)

{
  if (system_editor == '\0') {
    HTSACopy(&editor,value);
  }
  return 0;
}



// WARNING: Unknown calling convention

void put_editor(FILE *fp,config_type *tbl)

{
  char *local_8;
  
  if (editor == (char *)0x0) {
    local_8 = "";
  }
  else {
    local_8 = editor;
  }
  fprintf((FILE *)fp,"%s=%s\n\n",tbl->name,local_8);
  return;
}



// WARNING: Unknown calling convention

int get_tagsoup(char *value)

{
  BOOLEAN BVar1;
  int found;
  
  found = Old_DTD;
  BVar1 = LYgetEnum(tbl_DTD_recovery,value,&found);
  if ((BVar1 != '\0') && (Old_DTD != found)) {
    Old_DTD = found;
    HTSwitchDTD((uint)(found == 0));
  }
  return 0;
}



// WARNING: Unknown calling convention

void put_tagsoup(FILE *fp,config_type *tbl)

{
  char *pcVar1;
  
  pcVar1 = LYputEnum(tbl_DTD_recovery,Old_DTD);
  fprintf((FILE *)fp,"%s=%s\n\n",tbl->name,pcVar1);
  return;
}



// WARNING: Unknown calling convention

Config_Type_conflict1 * lookup_config(char *name)

{
  byte bVar1;
  ushort **ppuVar2;
  int iVar3;
  char local_1d;
  uint local_18;
  Config_Type_conflict1 *tbl;
  char ch1;
  char ch;
  
  tbl = Config_Table;
  ppuVar2 = __ctype_b_loc();
  if (((*ppuVar2)[(byte)*name] & 0x200) == 0) {
    local_1d = *name;
  }
  else {
    iVar3 = toupper((uint)(byte)*name);
    local_1d = (char)iVar3;
  }
  do {
    if (tbl->name == (char *)0x0) {
      return tbl;
    }
    if (tbl->enabled != 0) {
      bVar1 = *tbl->name;
      ppuVar2 = __ctype_b_loc();
      if (((*ppuVar2)[bVar1] & 0x200) == 0) {
        local_18 = (uint)bVar1;
      }
      else {
        local_18 = toupper((uint)bVar1);
      }
      if (((int)local_1d == local_18) && (iVar3 = strcasecomp(name,tbl->name), iVar3 == 0)) {
        return tbl;
      }
    }
    tbl = tbl + 1;
  } while( true );
}



// WARNING: Unknown calling convention

int _f(char *c)

{
  int in_EAX;
  
  return in_EAX;
}



// WARNING: Unknown calling convention

int _read_rc(int val)

{
  ParseUnion *q;
  ParseUnion _q;
  
  q->add_value = (lynx_list_item_type **)_f;
  if (val != 0) {
    _f((char *)0x0);
    (*q->fun_value)((char *)0x0);
  }
  return val;
}



void read_rc(FILE *fp)

{
  int iVar1;
  BOOLEAN *pBVar2;
  BOOLEAN BVar3;
  FILE *pFVar4;
  ushort **ppuVar5;
  size_t sVar6;
  int iVar7;
  wchar_t wVar8;
  char *pcVar9;
  int in_GS_OFFSET;
  FILE *fp_local;
  int ival;
  char *special;
  ParseUnion *q;
  Config_Type_conflict1 *tbl;
  char *notes;
  char *value;
  char *name;
  int n;
  char *buffer;
  char MBM_line [256];
  char rcfile [256];
  
  fp_local = fp;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  buffer = (char *)0x0;
  if (fp == (FILE *)0x0) {
    LYAddPathToHome(rcfile,0x100,".lynxrc");
    fp_local = (FILE *)fopen64(rcfile,"r");
    if (fp_local == (FILE *)0x0) goto LAB_080b2483;
    if (WWW_TraceFlag != '\0') {
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"read_rc opened %s\n",rcfile);
    }
  }
  else if (WWW_TraceFlag != '\0') {
    pFVar4 = TraceFP();
    fprintf((FILE *)pFVar4,"read_rc used passed-in stream\n");
  }
switchD_080b2107_caseD_0:
  pcVar9 = LYSafeGets(&buffer,fp_local);
  if (pcVar9 != (char *)0x0) {
    LYTrimTrailing(buffer);
    name = LYSkipBlanks(buffer);
    ppuVar5 = __ctype_b_loc();
    if ((((*ppuVar5)[(byte)*name] & 4) == 0) && (*name != '\0')) {
      value = strchr(name,0x3d);
      if (value == (char *)0x0) {
        if (WWW_TraceFlag != '\0') {
          pFVar4 = TraceFP();
          fprintf((FILE *)pFVar4,"LYrcFile: missing \'=\' %s\n",name);
        }
        goto switchD_080b2107_caseD_0;
      }
      *value = '\0';
      value = value + 1;
      LYTrimTrailing(name);
      value = LYSkipBlanks(value);
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
        pFVar4 = TraceFP();
        fprintf((FILE *)pFVar4,"LYrcFile %s:%s\n",name,value);
      }
      tbl = lookup_config(name);
      if (tbl->name == (char *)0x0) {
        special = "multi_bookmark";
        sVar6 = strlen("multi_bookmark");
        iVar7 = strncasecomp(name,special,sVar6);
        if (iVar7 == 0) {
          tbl = lookup_config(special);
        }
        if (tbl->name == (char *)0x0) {
          if (WWW_TraceFlag != '\0') {
            pFVar4 = TraceFP();
            fprintf((FILE *)pFVar4,"LYrcFile: ignored %s=%s\n",name,value);
          }
          goto switchD_080b2107_caseD_0;
        }
      }
      q = (ParseUnion *)&tbl->value;
      switch(tbl->type) {
      case CONF_ARRAY:
        for (n = 0; tbl->strings[n] != (char *)0x0; n = n + 1) {
          iVar7 = strcasecomp(value,tbl->strings[n]);
          if (iVar7 == 0) {
            *q->int_value = n;
            break;
          }
        }
        break;
      case CONF_BOOL:
        if (q->add_value != (lynx_list_item_type **)0x0) {
          pBVar2 = q->set_value;
          BVar3 = getBool(value);
          *pBVar2 = BVar3;
        }
        break;
      case CONF_FUN:
        if (q->add_value != (lynx_list_item_type **)0x0) {
          (*q->fun_value)(value);
        }
        break;
      case CONF_INT:
        if ((q->add_value != (lynx_list_item_type **)0x0) &&
           (iVar7 = sscanf(value,"%d",&ival), iVar7 == 1)) {
          *q->int_value = ival;
        }
        break;
      case CONF_ENUM:
        if (tbl->table != (Config_Enum *)0x0) {
          LYgetEnum(tbl->table,value,q->int_value);
        }
        break;
      case CONF_LIS:
        if (q->add_value != (lynx_list_item_type **)0x0) {
          if (*q->add_value != (lynx_list_item_type *)0x0) {
            HTSACat(q->str_value,",");
          }
          HTSACat(q->str_value,value);
        }
        break;
      case CONF_MBM:
        for (n = 1; n < 0x1a; n = n + 1) {
          wVar8 = LYindex2MBM(n);
          sprintf(MBM_line,"multi_bookmark%c",wVar8);
          iVar7 = strcasecomp(name,MBM_line);
          if (iVar7 == 0) {
            notes = strchr(value,0x2c);
            if (notes == (char *)0x0) {
              sVar6 = strlen(value);
              notes = value + sVar6;
            }
            else {
              *notes = '\0';
              notes = notes + 1;
              LYTrimTrailing(value);
              notes = LYSkipBlanks(notes);
            }
            HTSACopy(MBM_A_subbookmark + n,value);
            HTSACopy(MBM_A_subdescript + n,notes);
            break;
          }
        }
        break;
      case CONF_STR:
        if (q->add_value != (lynx_list_item_type **)0x0) {
          HTSACopy(q->str_value,value);
        }
      }
    }
    goto switchD_080b2107_caseD_0;
  }
  LYCloseInput(fp_local);
  LYConfigCookies();
  if (LYrcShowColor == 0) {
    if (LYShowColor == 2) {
      LYShowColor = 1;
    }
  }
  else if ((LYrcShowColor == 3) && (LYShowColor != 0)) {
    LYShowColor = 3;
  }
  set_default_bookmark_page(bookmark_page);
LAB_080b2483:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



// WARNING: Unknown calling convention

void write_list(FILE *fp,char *list)

{
  char cVar1;
  bool bVar2;
  int ch;
  int first;
  
  bVar2 = true;
  while (*list != '\0') {
    cVar1 = *list;
    list = list + 1;
    if (bVar2) {
      fwrite(&DAT_081625f4,1,2,(FILE *)fp);
      bVar2 = false;
    }
    if (cVar1 == 10) {
      bVar2 = true;
    }
    fputc((int)cVar1,(FILE *)fp);
  }
  return;
}



// WARNING: Unknown calling convention

void explain_keypad_mode(FILE *fp)

{
  char *pcVar1;
  
  pcVar1 = (char *)gettext(
                          "If keypad_mode is set to \"NUMBERS_AS_ARROWS\", then the numbers on\nyour keypad when the numlock is on will act as arrow keys:\n            8 = Up Arrow\n  4 = Left Arrow    6 = Right Arrow\n            2 = Down Arrow\nand the corresponding keyboard numbers will act as arrow keys,\nregardless of whether numlock is on.\n"
                          );
  write_list(fp,pcVar1);
  pcVar1 = (char *)gettext(
                          "If keypad_mode is set to \"LINKS_ARE_NUMBERED\", then numbers will\nappear next to each link and numbers are used to select links.\n"
                          );
  write_list(fp,pcVar1);
  pcVar1 = (char *)gettext(
                          "If keypad_mode is set to \"LINKS_AND_FORM_FIELDS_ARE_NUMBERED\", then\nnumbers will appear next to each link and visible form input field.\nNumbers are used to select links, or to move the \"current link\" to a\nform input field or button.  In addition, options in popup menus are\nindexed so that the user may type an option number to select an option in\na popup menu, even if the option isn\'t visible on the screen.  Reference\nlists and output from the list command also enumerate form inputs.\n"
                          );
  write_list(fp,pcVar1);
  pcVar1 = (char *)gettext(
                          "NOTE: Some fixed format documents may look disfigured when\n\"LINKS_ARE_NUMBERED\" or \"LINKS_AND_FORM_FIELDS_ARE_NUMBERED\" are\nenabled.\n"
                          );
  write_list(fp,pcVar1);
  return;
}



int save_rc(FILE *fp)

{
  int iVar1;
  char *pcVar2;
  undefined4 uVar3;
  long *plVar4;
  wchar_t wVar5;
  int in_GS_OFFSET;
  int local_13c;
  undefined *local_134;
  char *local_130;
  undefined *local_12c;
  FILE *fp_local;
  ParseUnion *q;
  int n;
  Config_Type_conflict1 *tbl;
  BOOLEAN is_tempfile;
  char rcfile [256];
  
  fp_local = fp;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  tbl = Config_Table;
  if (fp == (FILE *)0x0) {
    LYAddPathToHome(rcfile,0x100,".lynxrc");
    fp_local = LYNewTxtFile(rcfile);
    if (fp_local == (FILE *)0x0) {
      local_13c = 0;
      goto LAB_080b2b68;
    }
  }
  pcVar2 = (char *)gettext("Lynx User Defaults File\n\n");
  write_list(fp_local,pcVar2);
  pcVar2 = (char *)gettext(
                          "This file contains options saved from the Lynx Options Screen (normally\nwith the \'o\' key).  To save options with that screen, you must select the\ncheckbox:\n"
                          );
  write_list(fp_local,pcVar2);
  uVar3 = gettext("Save options to disk");
  fprintf((FILE *)fp_local,"#\t%s\n",uVar3);
  fwrite(&DAT_08162afc,1,2,(FILE *)fp_local);
  pcVar2 = (char *)gettext(
                          "You must then save the settings using the link on the line above the\ncheckbox:\n"
                          );
  write_list(fp_local,pcVar2);
  uVar3 = gettext("Accept Changes");
  fprintf((FILE *)fp_local,"#\t%s\n",uVar3);
  fwrite(&DAT_08162afc,1,2,(FILE *)fp_local);
  pcVar2 = (char *)gettext(
                          "You may also use the command-line option \"-forms_options\", which displays\nthe simpler Options Menu instead.  Save options with that using the \'>\' key.\n\n"
                          );
  write_list(fp_local,pcVar2);
  pcVar2 = (char *)gettext(
                          "There is normally no need to edit this file manually, since the defaults\nhere can be controlled from the Options Screen, and the next time options\nare saved from the Options Screen this file will be completely rewritten.\nYou have been warned...\n\nIf you are looking for the general configuration file - it is normally\ncalled \"lynx.cfg\".  It has different content and a different format.\nIt is not this file.\n"
                          );
  write_list(fp_local,pcVar2);
  fputc(10,(FILE *)fp_local);
  while (tbl->name != (char *)0x0) {
    plVar4 = &tbl->value;
    if (tbl->enabled == 0) {
      tbl = tbl + 1;
    }
    else {
      if (tbl->note == (char *)0x0) {
        if (tbl->table == tbl_keypad_mode) {
          explain_keypad_mode(fp_local);
        }
      }
      else {
        pcVar2 = (char *)gettext(tbl->note);
        write_list(fp_local,pcVar2);
      }
      switch(tbl->type) {
      case CONF_ARRAY:
        for (n = 0; tbl->strings[n] != (char *)0x0; n = n + 1) {
          fprintf((FILE *)fp_local,"#    %s\n",tbl->strings[n]);
        }
        fprintf((FILE *)fp_local,"%s=%s\n\n",tbl->name,tbl->strings[*(int *)*plVar4]);
        break;
      case CONF_BOOL:
        if (*(char *)*plVar4 == '\0') {
          local_134 = &DAT_0815fbd6;
        }
        else {
          local_134 = &DAT_0815fbd3;
        }
        fprintf((FILE *)fp_local,"%s=%s\n\n",tbl->name,local_134);
        break;
      case CONF_FUN:
        if (tbl->write_it != (_func_void_FILE_ptr_config_type_ptr *)0x0) {
          (*tbl->write_it)(fp_local,tbl);
        }
        break;
      case CONF_INT:
        fprintf((FILE *)fp_local,"%s=%d\n\n",tbl->name,*(undefined4 *)*plVar4);
        break;
      case CONF_ENUM:
        pcVar2 = LYputEnum(tbl->table,*(int *)*plVar4);
        fprintf((FILE *)fp_local,"%s=%s\n\n",tbl->name,pcVar2);
        break;
      case CONF_LIS:
      case CONF_STR:
        if ((*plVar4 == 0) || (*(int *)*plVar4 == 0)) {
          local_12c = &DAT_0815fe34;
        }
        else {
          local_12c = *(undefined **)*plVar4;
        }
        fprintf((FILE *)fp_local,"%s=%s\n\n",tbl->name,local_12c);
        break;
      case CONF_MBM:
        for (n = 1; n < 0x1a; n = n + 1) {
          wVar5 = LYindex2MBM(n);
          fprintf((FILE *)fp_local,"multi_bookmark%c=",wVar5);
          if (MBM_A_subbookmark[n] == (char *)0x0) {
            local_130 = "";
          }
          else {
            local_130 = MBM_A_subbookmark[n];
          }
          fputs(local_130,(FILE *)fp_local);
          if ((MBM_A_subdescript[n] != (char *)0x0) && (*MBM_A_subdescript[n] != '\0')) {
            fprintf((FILE *)fp_local,",%s",MBM_A_subdescript[n]);
          }
          fputc(10,(FILE *)fp_local);
        }
        fputc(10,(FILE *)fp_local);
      }
      tbl = tbl + 1;
    }
  }
  if (fp == (FILE *)0x0) {
    LYCloseOutput(fp_local);
  }
  else {
    LYCloseTempFP(fp_local);
  }
  local_13c = 1;
LAB_080b2b68:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return local_13c;
}



// WARNING: Unknown calling convention

BOOLEAN will_save_rc(char *name)

{
  Config_Type_conflict1 *pCVar1;
  Config_Type_conflict1 *tbl;
  
  pCVar1 = lookup_config(name);
  return pCVar1->name != (char *)0x0;
}



// WARNING: Unknown calling convention

int enable_lynxrc(char *value)

{
  BOOLEAN BVar1;
  char *pcVar2;
  int iVar3;
  char *colon;
  Config_Type_conflict1 *tbl;
  
  pcVar2 = strchr(value,0x3a);
  if (pcVar2 != (char *)0x0) {
    *pcVar2 = '\0';
    LYTrimLeading(value);
    LYTrimTrailing(value);
    for (tbl = Config_Table; tbl->name != (char *)0x0; tbl = tbl + 1) {
      iVar3 = strcasecomp(value,tbl->name);
      if (iVar3 == 0) {
        BVar1 = getBool(pcVar2 + 1);
        tbl->enabled = (int)BVar1;
        return 0;
      }
    }
  }
  return 0;
}



void LYDownload(char *line)

{
  int iVar1;
  BOOLEAN BVar2;
  char *pcVar3;
  int iVar4;
  RecallType recall_00;
  wchar_t wVar5;
  FILE *pFVar6;
  int in_GS_OFFSET;
  int local_254;
  char *line_local;
  int FnameNum;
  int FnameTotal;
  RecallType recall;
  int ch;
  lynx_list_item_type *download_command;
  char *cp;
  char *the_command;
  int count;
  int method_number;
  char *sug_file;
  char *file;
  char *method;
  char *Line;
  BOOLEAN SecondS;
  BOOLEAN FirstRecall;
  char command [256];
  char buffer [256];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  Line = (char *)0x0;
  sug_file = (char *)0x0;
  the_command = (char *)0x0;
  FirstRecall = '\x01';
  SecondS = '\0';
  if (LYValidDownloadFile[0] != '\0') {
    HTSACopy(&Line,line);
    pcVar3 = strstr(Line,"/File=");
    file = pcVar3;
    if (pcVar3 != (char *)0x0) {
      *pcVar3 = '\0';
      file = pcVar3 + 6;
      sug_file = strstr(pcVar3 + 7,"/SugFile=");
      if (sug_file != (char *)0x0) {
        *sug_file = '\0';
        sug_file = sug_file + 9;
        HTUnEscape(sug_file);
      }
      iVar4 = strcmp(file,LYValidDownloadFile);
      if (iVar4 == 0) {
        iVar4 = strncmp(file,"file://localhost",0x10);
        if (iVar4 == 0) {
          file = file + 0x10;
        }
        else if (((*file == 'f') || (*file == 'F')) &&
                (iVar4 = strncasecomp(file,"file:",5), iVar4 == 0)) {
          file = file + 5;
        }
        HTUnEscape(file);
        method = strstr(Line,"Method=");
        if (method != (char *)0x0) {
          method = method + 7;
          method_number = atoi(method);
          if (sug_filenames == (HTList *)0x0) {
            local_254 = 0;
          }
          else {
            local_254 = HTList_count(sug_filenames);
          }
          recall_00 = (RecallType)(0 < local_254);
          FnameNum = local_254;
          if (method_number < 0) {
            mustshow = '\x01';
            pcVar3 = (char *)gettext("Enter a filename: ");
            statusline(pcVar3);
retry:
            do {
              FnameNum = local_254;
              if (sug_file == (char *)0x0) {
                buffer[0] = '\0';
              }
              else {
                LYstrncpy(buffer,sug_file,L'\x7f');
              }
              while( true ) {
                while( true ) {
                  wVar5 = LYgetstr(buffer,L'\0',0x80,recall_00);
                  if (((L'\xffffffff' < wVar5) && (buffer[0] != '\0')) &&
                     ((wVar5 != L'' && (wVar5 != L'')))) {
                    strcpy(command,buffer);
                    BVar2 = LYValidateFilename(buffer,command);
                    if (BVar2 == '\0') goto cancelled;
                    if (buffer[0] == '|') {
                      pcVar3 = (char *)gettext("Cannot write to file.");
                      HTAlert(pcVar3);
                      mustshow = '\x01';
                      pcVar3 = (char *)gettext("Enter a new filename: ");
                      statusline(pcVar3);
                      FirstRecall = '\x01';
                      goto retry;
                    }
                    wVar5 = LYValidateOutput(buffer);
                    if (wVar5 == L'N') {
                      mustshow = '\x01';
                      pcVar3 = (char *)gettext("Enter a new filename: ");
                      statusline(pcVar3);
                      FirstRecall = '\x01';
                      goto retry;
                    }
                    if (wVar5 != L'Y') {
                      if (Line != (char *)0x0) {
                        free(Line);
                        Line = (char *)0x0;
                      }
                      goto LAB_080b3888;
                    }
                    if (WWW_TraceFlag != '\0') {
                      pFVar6 = TraceFP();
                      fprintf((FILE *)pFVar6,"LYDownload: filename is %s\n",buffer);
                    }
                    BVar2 = LYCanWriteFile(buffer);
                    if (BVar2 != '\0') {
                      SecondS = '\x01';
                      pcVar3 = (char *)gettext("Saving...");
                      HTInfoMsg(pcVar3);
                      LYCopyFile(file,buffer);
                      LYRelaxFilePermissions(buffer);
                      goto LAB_080b37db;
                    }
                    FirstRecall = '\x01';
                    goto retry;
                  }
                  if ((recall_00 == NORECALL) || (wVar5 != L'')) break;
                  if (FirstRecall == '\0') {
                    FnameNum = FnameNum + 1;
                  }
                  else {
                    FirstRecall = '\0';
                    FnameNum = 0;
                  }
                  if (local_254 <= FnameNum) {
                    FirstRecall = '\x01';
                    mustshow = '\x01';
                    pcVar3 = (char *)gettext("Enter a filename: ");
                    statusline(pcVar3);
                    goto retry;
                  }
                  pcVar3 = (char *)HTList_objectAt(sug_filenames,FnameNum);
                  if (pcVar3 == (char *)0x0) goto cancelled;
                  LYstrncpy(buffer,pcVar3,L'');
                  if (local_254 == 1) {
                    mustshow = '\x01';
                    pcVar3 = (char *)gettext("Edit the previous filename: ");
                    statusline(pcVar3);
                  }
                  else {
                    mustshow = '\x01';
                    pcVar3 = (char *)gettext("Edit a previous filename: ");
                    statusline(pcVar3);
                  }
                }
                if ((recall_00 == NORECALL) || (wVar5 != L'')) goto cancelled;
                if (FirstRecall != '\0') {
                  FirstRecall = '\0';
                  FnameNum = local_254;
                }
                FnameNum = FnameNum + -1;
                if (FnameNum < 0) break;
                pcVar3 = (char *)HTList_objectAt(sug_filenames,FnameNum);
                if (pcVar3 == (char *)0x0) goto cancelled;
                LYstrncpy(buffer,pcVar3,L'');
                if (local_254 == 1) {
                  mustshow = '\x01';
                  pcVar3 = (char *)gettext("Edit the previous filename: ");
                  statusline(pcVar3);
                }
                else {
                  mustshow = '\x01';
                  pcVar3 = (char *)gettext("Edit a previous filename: ");
                  statusline(pcVar3);
                }
              }
              FirstRecall = '\x01';
              mustshow = '\x01';
              pcVar3 = (char *)gettext("Enter a filename: ");
              statusline(pcVar3);
            } while( true );
          }
          buffer[0] = '\0';
          download_command = downloaders;
          for (count = 0; count < method_number; count = count + 1) {
            download_command = download_command->next;
          }
          if (download_command->command != (char *)0x0) {
            iVar4 = HTCountCommandArgs(download_command->command);
            if (1 < iVar4) {
              mustshow = '\x01';
              pcVar3 = (char *)gettext("Enter a filename: ");
              statusline(pcVar3);
again:
              do {
                if (sug_file == (char *)0x0) {
                  buffer[0] = '\0';
                }
                else {
                  strncpy(buffer,sug_file,0x7f);
                }
                while( true ) {
                  while( true ) {
                    wVar5 = LYgetstr(buffer,L'\0',0x100,recall_00);
                    if ((((L'\xffffffff' < wVar5) && (buffer[0] != '\0')) && (wVar5 != L'')) &&
                       (wVar5 != L'')) {
                      if (((no_dotfiles != '\0') || (show_dotfiles == '\0')) &&
                         (pcVar3 = LYPathLeaf(buffer), *pcVar3 == '.')) {
                        pcVar3 = (char *)gettext("File name may not begin with a dot.");
                        HTAlert(pcVar3);
                        mustshow = '\x01';
                        pcVar3 = (char *)gettext("Enter a new filename: ");
                        statusline(pcVar3);
                        goto again;
                      }
                      iVar4 = strcmp(buffer,"/dev/null");
                      if (iVar4 == 0) goto cancelled;
                      SecondS = '\x01';
                      goto LAB_080b36b0;
                    }
                    if ((recall_00 == NORECALL) || (wVar5 != L'')) break;
                    if (FirstRecall == '\0') {
                      FnameNum = FnameNum + 1;
                    }
                    else {
                      FirstRecall = '\0';
                      FnameNum = 0;
                    }
                    if (local_254 <= FnameNum) {
                      FirstRecall = '\x01';
                      FnameNum = local_254;
                      mustshow = '\x01';
                      pcVar3 = (char *)gettext("Enter a filename: ");
                      statusline(pcVar3);
                      goto again;
                    }
                    pcVar3 = (char *)HTList_objectAt(sug_filenames,FnameNum);
                    if (pcVar3 == (char *)0x0) goto cancelled;
                    LYstrncpy(buffer,pcVar3,L'');
                    if (local_254 == 1) {
                      mustshow = '\x01';
                      pcVar3 = (char *)gettext("Edit the previous filename: ");
                      statusline(pcVar3);
                    }
                    else {
                      mustshow = '\x01';
                      pcVar3 = (char *)gettext("Edit a previous filename: ");
                      statusline(pcVar3);
                    }
                  }
                  if ((recall_00 == NORECALL) || (wVar5 != L'')) goto cancelled;
                  if (FirstRecall != '\0') {
                    FirstRecall = '\0';
                    FnameNum = local_254;
                  }
                  FnameNum = FnameNum + -1;
                  if (FnameNum < 0) break;
                  pcVar3 = (char *)HTList_objectAt(sug_filenames,FnameNum);
                  if (pcVar3 == (char *)0x0) goto cancelled;
                  LYstrncpy(buffer,pcVar3,L'');
                  if (local_254 == 1) {
                    mustshow = '\x01';
                    pcVar3 = (char *)gettext("Edit the previous filename: ");
                    statusline(pcVar3);
                  }
                  else {
                    mustshow = '\x01';
                    pcVar3 = (char *)gettext("Edit a previous filename: ");
                    statusline(pcVar3);
                  }
                }
                FirstRecall = '\x01';
                FnameNum = local_254;
                mustshow = '\x01';
                pcVar3 = (char *)gettext("Enter a filename: ");
                statusline(pcVar3);
              } while( true );
            }
LAB_080b36b0:
            count = 1;
            HTAddParam(&the_command,download_command->command,1,file);
            iVar4 = HTCountCommandArgs(download_command->command);
            if (1 < iVar4) {
              count = count + 1;
              HTAddParam(&the_command,download_command->command,count,buffer);
            }
            HTEndParam(&the_command,download_command->command,count);
            pcVar3 = the_command;
            if (WWW_TraceFlag != '\0') {
              pFVar6 = TraceFP();
              fprintf((FILE *)pFVar6,"command: %s\n",pcVar3);
            }
            stop_curses();
            LYSystem(the_command);
            if (the_command != (char *)0x0) {
              free(the_command);
              the_command = (char *)0x0;
            }
            start_curses();
LAB_080b37db:
            if (SecondS == '\x01') {
              HTAddSugFilename(buffer);
            }
            if (Line != (char *)0x0) {
              free(Line);
              Line = (char *)0x0;
            }
            goto LAB_080b3888;
          }
          pcVar3 = (char *)gettext("ERROR! - download command is misconfigured.");
          HTAlert(pcVar3);
        }
      }
    }
  }
  pcVar3 = (char *)gettext("Unable to download file.");
  HTAlert(pcVar3);
  if (Line != (char *)0x0) {
    free(Line);
    Line = (char *)0x0;
  }
  goto LAB_080b3888;
cancelled:
  pcVar3 = (char *)gettext("Cancelling!");
  HTInfoMsg(pcVar3);
  if (Line != (char *)0x0) {
    free(Line);
    Line = (char *)0x0;
  }
LAB_080b3888:
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

int SuffixIs(char *filename,char *suffix)

{
  size_t sVar1;
  size_t sVar2;
  int iVar3;
  size_t need;
  size_t have;
  
  sVar1 = strlen(filename);
  sVar2 = strlen(suffix);
  if ((sVar2 < sVar1) && (iVar3 = strcmp(filename + (sVar1 - sVar2),suffix), iVar3 == 0)) {
    return 1;
  }
  return 0;
}



// WARNING: Unknown calling convention

int LYdownload_options(char **newfile,char *data_file)

{
  char *pcVar1;
  undefined4 uVar2;
  int iVar3;
  char *source_00;
  undefined4 local_3c;
  char *local_30;
  char *local_2c;
  char *source;
  char *target;
  int count;
  lynx_list_item_type *cur_download;
  FILE *fp0;
  char *sug_filename;
  char *downloaded_url;
  
  downloaded_url = (char *)0x0;
  sug_filename = (char *)0x0;
  HTSACopy(&sug_filename,*newfile);
  change_sug_filename(sug_filename);
  fp0 = InternalPageFP(LYdownload_options::tempfile,L'\x01');
  if (fp0 != (FILE *)0x0) {
    HTSACopy(&downloaded_url,*newfile);
    LYLocalFileToURL(newfile,LYdownload_options::tempfile);
    LYstrncpy(LYValidDownloadFile,data_file,L'');
    LYforce_no_cache = '\x01';
    pcVar1 = (char *)gettext("Download Options");
    BeginInternalPage(fp0,pcVar1,"Lynx_users_guide.html.gz#RemoteSource");
    fwrite("<pre>\n",1,6,(FILE *)fp0);
    pcVar1 = downloaded_url;
    uVar2 = gettext("Downloaded link:");
    fprintf((FILE *)fp0,"<em>%s</em> %s\n",uVar2,pcVar1);
    if (downloaded_url != (char *)0x0) {
      free(downloaded_url);
      downloaded_url = (char *)0x0;
    }
    pcVar1 = sug_filename;
    uVar2 = gettext("Suggested file name:");
    fprintf((FILE *)fp0,"<em>%s</em> %s\n",uVar2,pcVar1);
    if (user_mode == 0) {
      local_3c = gettext("Standard download options:");
    }
    else {
      local_3c = gettext("Download options:");
    }
    fprintf((FILE *)fp0,"\n%s\n",local_3c,pcVar1);
    if (no_disk_save == '\0') {
      if (lynx_edit_mode == '\0') {
        uVar2 = gettext("Save to disk");
        if (lynx_save_space == (char *)0x0) {
          local_30 = "";
        }
        else {
          local_30 = lynx_save_space;
        }
        pcVar1 = data_file;
        fprintf((FILE *)fp0,"   <a href=\"%s//Method=-1/File=%s/SugFile=%s%s\">%s</a>\n",
                "LYNXDOWNLOAD:",data_file,local_30,sug_filename,uVar2);
        iVar3 = SuffixIs(data_file,".html");
        if ((iVar3 != 0) || (iVar3 = SuffixIs(data_file,".txt"), iVar3 != 0)) {
          target = (char *)0x0;
          source_00 = LYAddPathToSave(data_file);
          LYLocalFileToURL(&target,source_00);
          pcVar1 = (char *)gettext("View temporary file");
          fprintf((FILE *)fp0,"   <a href=\"%s\">%s</a>\n",target,pcVar1);
          if (source_00 != (char *)0x0) {
            free(source_00);
          }
          if (target != (char *)0x0) {
            free(target);
            target = (char *)0x0;
          }
        }
      }
    }
    else {
      uVar2 = gettext("Save to disk disabled.");
      fprintf((FILE *)fp0,"   <em>%s</em>\n",uVar2);
    }
    if (user_mode == 0) {
      uVar2 = gettext("Local additions:");
      fprintf((FILE *)fp0,"\n%s\n",uVar2,pcVar1);
    }
    if (downloaders != (lynx_list_item_type *)0x0) {
      count = 0;
      for (cur_download = downloaders; cur_download != (lynx_list_item_type *)0x0;
          cur_download = cur_download->next) {
        if ((no_download == '\0') || (cur_download->always_enabled != L'\0')) {
          fprintf((FILE *)fp0,"   <a href=\"%s//Method=%d/File=%s/SugFile=%s\">","LYNXDOWNLOAD:",
                  count,data_file,sug_filename);
          if (cur_download->name == (char *)0x0) {
            local_2c = (char *)gettext("No Name Given");
          }
          else {
            local_2c = cur_download->name;
          }
          fputs(local_2c,(FILE *)fp0);
          fwrite("</a>\n",1,5,(FILE *)fp0);
        }
        count = count + 1;
      }
    }
    fwrite("</pre>\n",1,7,(FILE *)fp0);
    EndInternalPage(fp0);
    LYCloseTempFP(fp0);
    LYRegisterUIPage(*newfile,UIP_DOWNLOAD_OPTIONS);
    if (sug_filename != (char *)0x0) {
      free(sug_filename);
    }
    return 0;
  }
  return -1;
}



// WARNING: Unknown calling convention

BOOLEAN message_has_content(char *filename,BOOLEAN *nonspaces)

{
  FILE *__stream;
  ushort **ppuVar1;
  char *pcVar2;
  char *local_1c;
  char *cp;
  char *buffer;
  FILE *fp;
  char firstnonblank;
  BOOLEAN in_headers;
  
  buffer = (char *)0x0;
  in_headers = '\x01';
  *nonspaces = '\0';
  if ((filename != (char *)0x0) && (fp = (FILE *)fopen64(filename,"r"), fp != (FILE *)0x0)) {
    while( true ) {
      pcVar2 = LYSafeGets(&buffer,fp);
      if (pcVar2 == (char *)0x0) {
        if (buffer != (char *)0x0) {
          free(buffer);
          buffer = (char *)0x0;
        }
        LYCloseInput(fp);
        return '\0';
      }
      cp = buffer;
      firstnonblank = '\0';
      LYTrimNewline(buffer);
      for (; *cp != '\0'; cp = cp + 1) {
        if ((firstnonblank == '\0') && (ppuVar1 = __ctype_b_loc(), (short)(*ppuVar1)[(byte)*cp] < 0)
           ) {
          firstnonblank = *cp;
        }
        else {
          ppuVar1 = __ctype_b_loc();
          if (((*ppuVar1)[(byte)*cp] & 0x2000) == 0) {
            *nonspaces = '\x01';
          }
        }
      }
      if (((firstnonblank != '\0') && (firstnonblank != '>')) && (in_headers == '\0')) break;
      if (firstnonblank == '\0') {
        in_headers = '\0';
      }
    }
    LYCloseInput(fp);
    if (buffer != (char *)0x0) {
      free(buffer);
    }
    return '\x01';
  }
  if (WWW_TraceFlag != '\0') {
    if (filename == (char *)0x0) {
      local_1c = "(null)";
    }
    else {
      local_1c = filename;
    }
    __stream = TraceFP();
    fprintf((FILE *)__stream,"Failed to open file %s for reading!\n",local_1c);
  }
  return '\0';
}



char * LYNewsPost(char *newsgroups,BOOLEAN followup)

{
  int iVar1;
  LYKeymap_t LVar2;
  BOOLEAN BVar3;
  char *pcVar4;
  int iVar5;
  ushort **ppuVar6;
  size_t sVar7;
  wchar_t wVar8;
  char *pcVar9;
  int in_GS_OFFSET;
  undefined *__src;
  size_t __n;
  char *local_a58;
  BOOLEAN followup_local;
  char *newsgroups_local;
  char *buffer_1;
  char *buffer;
  FILE *fp;
  char *org;
  char *References;
  char *NewsGroups;
  char *postfile;
  FILE *fc;
  FILE *fd;
  wchar_t len;
  wchar_t c;
  char *kp;
  char *cp;
  BOOLEAN nonspaces;
  BOOLEAN nonempty;
  char CJKinput [1024];
  char user_input [1024];
  char CJKfile [256];
  char my_tempfile [256];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  cp = (char *)0x0;
  kp = (char *)0x0;
  c = L'\0';
  fd = (FILE *)0x0;
  fc = (FILE *)0x0;
  postfile = (char *)0x0;
  NewsGroups = (char *)0x0;
  References = (char *)0x0;
  org = (char *)0x0;
  fp = (FILE *)0x0;
  nonempty = '\0';
  nonspaces = '\0';
  if (((newsgroups == (char *)0x0) || (*newsgroups == '\0')) || (no_newspost != '\0'))
  goto LAB_080b5121;
  fd = LYOpenTemp(my_tempfile,".html","w");
  if (fd == (FILE *)0x0) {
    pcVar4 = (char *)gettext("Can\'t open temporary file!");
    HTAlert(pcVar4);
    goto LAB_080b5121;
  }
  CJKfile[0] = '\0';
  iVar5 = UCGetLYhndl_byMIME("euc-jp");
  if (((iVar5 == current_char_set) ||
      (iVar5 = UCGetLYhndl_byMIME("shift_jis"), iVar5 == current_char_set)) &&
     (fc = LYOpenTemp(CJKfile,".html","w"), fc == (FILE *)0x0)) {
    pcVar4 = (char *)gettext("Can\'t open temporary file!");
    HTAlert(pcVar4);
    LYRemoveTemp(my_tempfile);
    goto LAB_080b5121;
  }
  HTSACopy(&NewsGroups,newsgroups);
  cp = strstr(NewsGroups,";ref=");
  if (cp != (char *)0x0) {
    *cp = '\0';
    cp = cp + 5;
    if (*cp == '<') {
      HTSACopy(&References,cp);
    }
    else {
      HTSACopy(&References,"<");
      HTSACat(&References,cp);
      HTSACat(&References,">");
    }
    HTUnEscape(References);
    cp = strchr(References,0x40);
    if ((((cp == (char *)0x0) || (cp <= References + 1)) ||
        (ppuVar6 = __ctype_b_loc(), ((*ppuVar6)[(byte)cp[1]] & 8) == 0)) &&
       (References != (char *)0x0)) {
      free(References);
      References = (char *)0x0;
    }
  }
  HTUnEscape(NewsGroups);
  if (*NewsGroups == '\0') {
    LYCloseTempFP(fd);
  }
  else {
    signal(2,terminate_message);
    term_message = '\0';
    LYclear();
    LYmove(L'\x02',L'\0');
    scrollok(LYwin,1);
    pcVar4 = (char *)gettext("You will be posting to:");
    sVar7 = strlen(pcVar4);
    pcVar4 = (char *)gettext("You will be posting to:");
    LYwaddnstr(LYwin,pcVar4,sVar7);
    LYwaddnstr(LYwin,"\n\t",2);
    sVar7 = strlen(NewsGroups);
    LYwaddnstr(LYwin,NewsGroups,sVar7);
    waddch(LYwin,10);
    pcVar4 = (char *)gettext("\n\n Please provide your mail address for the From: header\n");
    sVar7 = strlen(pcVar4);
    pcVar4 = (char *)gettext("\n\n Please provide your mail address for the From: header\n");
    LYwaddnstr(LYwin,pcVar4,sVar7);
    if (personal_mail_address == (char *)0x0) {
      local_a58 = "";
    }
    else {
      local_a58 = personal_mail_address;
    }
    sprintf(user_input,"From: %.*s",0x3f8,local_a58);
    wVar8 = LYgetstr(user_input,L'\0',0x400,NORECALL);
    if ((wVar8 < L'\0') || (term_message != '\0')) {
      pcVar4 = (char *)gettext("News Post Cancelled!!!");
      HTInfoMsg(pcVar4);
      LYCloseTempFP(fd);
      scrollok(LYwin,0);
    }
    else {
      fprintf((FILE *)fd,"%s\n",user_input);
      pcVar4 = (char *)gettext("\n\n Please provide or edit the Subject: header\n");
      sVar7 = strlen(pcVar4);
      pcVar4 = (char *)gettext("\n\n Please provide or edit the Subject: header\n");
      LYwaddnstr(LYwin,pcVar4,sVar7);
      memcpy(user_input,"Subject: ",10);
      if (((followup == '\x01') && (0 < nhist)) && (kp = HText_getTitle(), kp != (char *)0x0)) {
        kp = LYSkipCBlanks(kp);
        if (HTCJK == JAPANESE) {
          CJKinput[0] = '\0';
          if (kanji_code == EUC) {
            TO_EUC((uchar *)kp,(uchar *)CJKinput);
            kp = CJKinput;
          }
          else if (kanji_code == SJIS) {
            TO_SJIS((uchar *)kp,(uchar *)CJKinput);
            kp = CJKinput;
          }
        }
        iVar5 = strncasecomp(kp,"Re:",3);
        if (iVar5 != 0) {
          __n = 5;
          __src = &DAT_0816321d;
          sVar7 = strlen(user_input);
          memcpy(user_input + sVar7,__src,__n);
        }
        len = strlen(user_input);
        LYstrncpy(user_input + len,kp,L'' - len);
      }
      cp = (char *)0x0;
      wVar8 = LYgetstr(user_input,L'\0',0x400,NORECALL);
      if ((wVar8 < L'\0') || (term_message != '\0')) {
        pcVar4 = (char *)gettext("News Post Cancelled!!!");
        HTInfoMsg(pcVar4);
        LYCloseTempFP(fd);
        scrollok(LYwin,0);
      }
      else {
        fprintf((FILE *)fd,"%s\n",user_input);
        HTSACopy(&cp,"Organization: ");
        org = LYGetEnv("ORGANIZATION");
        if (org == (char *)0x0) {
          org = LYGetEnv("NEWS_ORGANIZATION");
          if (org == (char *)0x0) {
            fp = (FILE *)fopen64("/etc/organization","r");
            if (fp != (FILE *)0x0) {
              buffer = (char *)0x0;
              pcVar4 = LYSafeGets(&buffer,fp);
              if ((pcVar4 != (char *)0x0) && (user_input[0] != '\0')) {
                LYTrimNewline(buffer);
                HTSACat(&cp,buffer);
              }
              if (buffer != (char *)0x0) {
                free(buffer);
                buffer = (char *)0x0;
              }
              LYCloseInput(fp);
            }
          }
          else {
            HTSACat(&cp,org);
          }
        }
        else {
          HTSACat(&cp,org);
        }
        LYstrncpy(user_input,cp,L'');
        if (cp != (char *)0x0) {
          free(cp);
          cp = (char *)0x0;
        }
        pcVar4 = (char *)gettext("\n\n Please provide or edit the Organization: header\n");
        sVar7 = strlen(pcVar4);
        pcVar4 = (char *)gettext("\n\n Please provide or edit the Organization: header\n");
        LYwaddnstr(LYwin,pcVar4,sVar7);
        wVar8 = LYgetstr(user_input,L'\0',0x400,NORECALL);
        if ((wVar8 < L'\0') || (term_message != '\0')) {
          pcVar4 = (char *)gettext("News Post Cancelled!!!");
          HTInfoMsg(pcVar4);
          LYCloseTempFP(fd);
          scrollok(LYwin,0);
        }
        else {
          fprintf((FILE *)fd,"%s\n",user_input);
          if (References != (char *)0x0) {
            fprintf((FILE *)fd,"References: %s\n",References);
          }
          fprintf((FILE *)fd,"Newsgroups: %s\nSummary: \nKeywords: \n\n",NewsGroups);
          if (((no_editor == '\0') && (editor != (char *)0x0)) && (*editor != '\0')) {
            if ((followup != '\0') && (0 < nhist)) {
              if (term_message == '\0') {
                pcVar4 = (char *)gettext("Do you wish to include the original message?");
                BVar3 = HTConfirm(pcVar4);
                if (BVar3 == '\x01') {
                  print_wwwfile_to_fd(fd,'\0','\x01');
                }
              }
              else {
                mustshow = '\x01';
                pcVar4 = (char *)gettext("Do you wish to include the original message?");
                statusline(pcVar4);
              }
            }
            LYCloseTempFP(fd);
            scrollok(LYwin,0);
            if (((term_message == '\0') && (c != L'\x03')) && (c != L'\a')) {
              LVar2 = keymap[0];
              if (c == L'\xffffffff') {
joined_r0x080b4a53:
                if (LVar2 == 0x2f) goto cleanup;
              }
              else {
                if ((c & 0x8800U) == 0) {
                  LVar2 = keymap[(c & 0x7ffU) + 1];
                  goto joined_r0x080b4a53;
                }
                if ((c & 0xffU) == 0x2f) goto cleanup;
              }
              pcVar4 = (char *)gettext("Spawning your selected editor to edit news message");
              edit_temporary_file(my_tempfile,"",pcVar4);
              nonempty = message_has_content(my_tempfile,&nonspaces);
LAB_080b4d09:
              if (nonempty == '\0') {
                pcVar4 = (char *)gettext("Message has no original text!");
                HTAlert(pcVar4);
                if (nonspaces != '\0') {
                  pcVar4 = (char *)gettext("Post this message?");
                  wVar8 = HTConfirmDefault(pcVar4,L'\0');
                  if (wVar8 == L'\x01') goto LAB_080b4da1;
                }
              }
              else {
                LYStatusLine = LYlines + -1;
                pcVar4 = (char *)gettext("Post this message?");
                BVar3 = HTConfirm(pcVar4);
                c = (wchar_t)BVar3;
                LYStatusLine = -1;
                if (c == L'\x01') {
LAB_080b4da1:
                  if ((LynxSigFile != (char *)0x0) &&
                     (fp = (FILE *)fopen64(LynxSigFile,"r"), pcVar4 = LynxSigFile, fp != (FILE *)0x0
                     )) {
                    buffer = (char *)0x0;
                    pcVar9 = (char *)gettext("Append \'%s\'?");
                    HTSprintf0(&buffer,pcVar9,pcVar4);
                    pcVar4 = LynxSigFile;
                    LYStatusLine = LYlines + -1;
                    if (term_message == '\0') {
                      BVar3 = HTConfirm(buffer);
                      if ((BVar3 == '\x01') &&
                         (fd = LYAppendToTxtFile(my_tempfile), fd != (FILE *)0x0)) {
                        buffer_1 = (char *)0x0;
                        fwrite(&DAT_081633fe,1,4,(FILE *)fd);
                        while (pcVar4 = LYSafeGets(&buffer_1,fp), pcVar4 != (char *)0x0) {
                          fputs(buffer_1,(FILE *)fd);
                        }
                        LYCloseOutput(fd);
                      }
                    }
                    else {
                      mustshow = '\x01';
                      pcVar9 = (char *)gettext("Append \'%s\'?");
                      user_message(pcVar9,pcVar4);
                    }
                    LYCloseInput(fp);
                    if (buffer != (char *)0x0) {
                      free(buffer);
                      buffer = (char *)0x0;
                    }
                    LYStatusLine = -1;
                  }
                  LYclear();
                  if (CJKfile[0] == '\0') {
                    HTSACopy(&postfile,my_tempfile);
                  }
                  else {
                    fd = (FILE *)fopen64(my_tempfile,"r");
                    if (fd == (FILE *)0x0) {
                      HTSACopy(&postfile,my_tempfile);
                    }
                    else {
                      buffer_1 = (char *)0x0;
                      while (pcVar4 = LYSafeGets(&buffer_1,fd), pcVar4 != (char *)0x0) {
                        TO_JIS((uchar *)buffer_1,(uchar *)CJKinput);
                        fputs(CJKinput,(FILE *)fc);
                      }
                      LYCloseTempFP(fc);
                      HTSACopy(&postfile,CJKfile);
                      LYCloseInput(fd);
                      LYRemoveTemp(my_tempfile);
                      strcpy(my_tempfile,CJKfile);
                      CJKfile[0] = '\0';
                    }
                  }
                  if (followup == '\0') {
                    LYforce_no_cache = '\x01';
                  }
                  LYStatusLine = LYlines + -1;
                  pcVar4 = (char *)gettext("Posting to newsgroup(s)...");
                  HTUserMsg(pcVar4);
                  LYStatusLine = -1;
                }
                else {
                  LYclear();
                }
              }
            }
          }
          else {
            pcVar4 = (char *)gettext("\n\n Please enter your message below.");
            sVar7 = strlen(pcVar4);
            pcVar4 = (char *)gettext("\n\n Please enter your message below.");
            LYwaddnstr(LYwin,pcVar4,sVar7);
            pcVar4 = (char *)gettext("\n When you are done, press enter and put a single period (.)"
                                    );
            sVar7 = strlen(pcVar4);
            pcVar4 = (char *)gettext("\n When you are done, press enter and put a single period (.)"
                                    );
            LYwaddnstr(LYwin,pcVar4,sVar7);
            pcVar4 = (char *)gettext("\n on a line and press enter again.");
            sVar7 = strlen(pcVar4);
            pcVar4 = (char *)gettext("\n on a line and press enter again.");
            LYwaddnstr(LYwin,pcVar4,sVar7);
            LYwaddnstr(LYwin,"\n\n",2);
            LYrefresh();
            user_input[0] = '\0';
            wVar8 = LYgetstr(user_input,L'\0',0x400,NORECALL);
            if ((wVar8 < L'\0') || (term_message != '\0')) {
              pcVar4 = (char *)gettext("News Post Cancelled!!!");
              HTInfoMsg(pcVar4);
              LYCloseTempFP(fd);
              scrollok(LYwin,0);
            }
            else {
              do {
                iVar5 = strcmp(user_input,".");
                if ((iVar5 == 0) || (term_message != '\0')) {
                  fputc(10,(FILE *)fd);
                  LYCloseTempFP(fd);
                  scrollok(LYwin,0);
                  goto LAB_080b4d09;
                }
                waddch(LYwin,10);
                fprintf((FILE *)fd,"%s\n",user_input);
                if ((nonempty == '\0') && (user_input[0] != '\0')) {
                  nonempty = '\x01';
                }
                user_input[0] = '\0';
                wVar8 = LYgetstr(user_input,L'\0',0x400,NORECALL);
              } while (L'\xffffffff' < wVar8);
              pcVar4 = (char *)gettext("News Post Cancelled!!!");
              HTInfoMsg(pcVar4);
              LYCloseTempFP(fd);
              scrollok(LYwin,0);
            }
          }
        }
      }
    }
  }
cleanup:
  signal(2,cleanup_sig);
  term_message = '\0';
  if (postfile == (char *)0x0) {
    LYRemoveTemp(my_tempfile);
  }
  LYRemoveTemp(CJKfile);
  if (NewsGroups != (char *)0x0) {
    free(NewsGroups);
    NewsGroups = (char *)0x0;
  }
  if (References != (char *)0x0) {
    free(References);
    References = (char *)0x0;
  }
LAB_080b5121:
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return postfile;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void terminate_message(wchar_t sig)

{
  term_message = '\x01';
  signal(2,terminate_message);
  return;
}



// WARNING: Unknown calling convention

HTList * LYcommandList(void)

{
  char *data;
  uint j;
  
  if (LYcommandList::myList == (HTList *)0x0) {
    LYcommandList::myList = HTList_new();
    for (j = 0; revmap[j].name != (char *)0x0; j = j + 1) {
      if (revmap[j].doc != (char *)0x0) {
        data = (char *)0x0;
        HTSACopy(&data,revmap[j].name);
        HTList_addObject(LYcommandList::myList,data);
      }
    }
  }
  return LYcommandList::myList;
}



// WARNING: Unknown calling convention

Kcmd * LYKeycodeToKcmd(LYKeymapCode code)

{
  Kcmd *result;
  uint j;
  
  if (code != LYK_UNKNOWN) {
    for (j = 0; revmap[j].name != (char *)0x0; j = j + 1) {
      if (revmap[j].code == code) {
        return revmap + j;
      }
    }
  }
  return (Kcmd *)0x0;
}



// WARNING: Unknown calling convention

Kcmd * LYStringToKcmd(char *name)

{
  bool bVar1;
  size_t n;
  int iVar2;
  Kcmd *local_28;
  Kcmd *maybe;
  Kcmd *result;
  uint j;
  uint need;
  BOOLEAN exact;
  
  n = strlen(name);
  bVar1 = false;
  result = (Kcmd *)0x0;
  maybe = (Kcmd *)0x0;
  if ((name != (char *)0x0) && (*name != '\0')) {
    for (j = 0; revmap[j].name != (char *)0x0; j = j + 1) {
      iVar2 = strcasecomp(revmap[j].name,name);
      if (iVar2 == 0) {
        result = revmap + j;
        break;
      }
      if (!bVar1) {
        iVar2 = strncasecomp(revmap[j].name,name,n);
        if (iVar2 == 0) {
          if (maybe == (Kcmd *)0x0) {
            maybe = revmap + j;
          }
          else if ((revmap[j].name[n] != '\0') && (maybe->name[n] != '\0')) {
            maybe = (Kcmd *)0x0;
            bVar1 = true;
          }
        }
      }
    }
  }
  if (result == (Kcmd *)0x0) {
    local_28 = maybe;
  }
  else {
    local_28 = result;
  }
  return local_28;
}



char * LYKeycodeToString(int c,BOOLEAN upper8)

{
  bool bVar1;
  BOOLEAN upper8_local;
  uint n;
  BOOLEAN named;
  
  bVar1 = false;
  n = 0;
  do {
    if (0x17 < n) {
LAB_080b53fc:
      if (!bVar1) {
        if ((c < 0x21) || (0x7e < c)) {
          if ((upper8 == '\0') ||
             (((c < 0x21 || (0xff < c)) || (LYlowest_eightbit[current_char_set] < c)))) {
            if (c < 0x20) {
              sprintf(LYKeycodeToString::buf,"^%c",c | 0x40);
            }
            else if (c < 0x100) {
              sprintf(LYKeycodeToString::buf,"0x%x",c);
            }
            else {
              sprintf(LYKeycodeToString::buf,"key-0x%x",c);
            }
          }
          else {
            sprintf(LYKeycodeToString::buf,"%c",c);
          }
        }
        else {
          sprintf(LYKeycodeToString::buf,"%c",c);
        }
      }
      return LYKeycodeToString::buf;
    }
    if (named_keys[n].key == c) {
      bVar1 = true;
      strcpy(LYKeycodeToString::buf,named_keys[n].name);
      goto LAB_080b53fc;
    }
    n = n + 1;
  } while( true );
}



// WARNING: Unknown calling convention

int LYStringToKeycode(char *src)

{
  int iVar1;
  char *dst;
  int len;
  int key;
  uint n;
  
  key = -1;
  len = strlen(src);
  if (len == 1) {
    key = (int)*src;
  }
  else if ((len == 2) && (*src == '^')) {
    key = (int)src[1] & 0x1f;
  }
  else if ((len < 3) || (iVar1 = strncasecomp(src,"0x",2), iVar1 != 0)) {
    if ((6 < len) && (iVar1 = strncasecomp(src,"key-",4), iVar1 == 0)) {
      dst = (char *)0x0;
      key = strtol(src + 4,&dst,0);
      if ((dst == (char *)0x0) || (*dst == '\0')) {
        key = -1;
      }
    }
  }
  else {
    dst = (char *)0x0;
    key = strtol(src,&dst,0);
    if ((dst != (char *)0x0) && (*dst != '\0')) {
      key = -1;
    }
  }
  if (key < 0) {
    for (n = 0; n < 0x18; n = n + 1) {
      iVar1 = strcasecomp(named_keys[n].name,src);
      if (iVar1 == 0) {
        return named_keys[n].key;
      }
    }
  }
  return key;
}



// WARNING: Unknown calling convention

char * pretty_html(int c)

{
  char cVar1;
  bool bVar2;
  size_t sVar3;
  char *local_28;
  uint n;
  int adj;
  char *dst;
  char *src;
  BOOLEAN found;
  
  src = LYKeycodeToString(c,'\x01');
  if (src == (char *)0x0) {
    local_28 = (char *)0x0;
  }
  else {
    dst = pretty_html::buf;
    adj = 0;
    while( true ) {
      cVar1 = *src;
      src = src + 1;
      if (cVar1 == 0) break;
      bVar2 = false;
      for (n = 0; n < 4; n = n + 1) {
        if (pretty_html::table[n].code == (int)cVar1) {
          bVar2 = true;
          strcpy(dst,pretty_html::table[n].name);
          sVar3 = strlen(dst);
          adj = sVar3 + adj + -1;
          sVar3 = strlen(dst);
          dst = dst + sVar3;
          break;
        }
      }
      if (!bVar2) {
        *dst = cVar1;
        dst = dst + 1;
      }
    }
    adj = (int)(pretty_html::buf + adj + (0xb - (int)dst));
    while (bVar2 = 0 < adj, adj = adj + -1, bVar2) {
      *dst = ' ';
      dst = dst + 1;
    }
    *dst = '\0';
    local_28 = pretty_html::buf;
  }
  return local_28;
}



// WARNING: Unknown calling convention

char * format_binding(LYKeymap_t *table,int i)

{
  Kcmd *pKVar1;
  char *pcVar2;
  Kcmd *rmap;
  char *formatted;
  char *buf;
  LYKeymapCode the_key;
  
  the_key = (LYKeymapCode)table[i];
  buf = (char *)0x0;
  pKVar1 = LYKeycodeToKcmd(the_key);
  if ((((pKVar1 != (Kcmd *)0x0) && (pKVar1->name != (char *)0x0)) && (pKVar1->doc != (char *)0x0))
     && (pcVar2 = pretty_html(i + -1), pcVar2 != (char *)0x0)) {
    HTSprintf0(&buf,"%-*s %-13s %s\n",0xb,pcVar2,pKVar1->name,pKVar1->doc);
    return buf;
  }
  return (char *)0x0;
}



void print_binding(HTStream *target,int i,BOOLEAN both)

{
  int i_00;
  _func_void_HTStream_ptr_char_ptr_wchar_t *p_Var1;
  char *pcVar2;
  wchar_t wVar3;
  BOOLEAN both_local;
  LYKeymapCode lac1;
  char *buf;
  
  lac1 = LYK_UNKNOWN;
  if (((prev_lynx_edit_mode == '\0') || (no_dired_support != '\0')) ||
     (lac1 = (LYKeymapCode)key_override[i], lac1 == LYK_UNKNOWN)) {
    pcVar2 = format_binding(keymap,i);
    if (pcVar2 != (char *)0x0) {
      lac1 = (LYKeymapCode)keymap[i];
      p_Var1 = target->isa->put_block;
      wVar3 = strlen(pcVar2);
      (*p_Var1)(target,pcVar2,wVar3);
      if (pcVar2 != (char *)0x0) {
        free(pcVar2);
      }
    }
  }
  else {
    pcVar2 = format_binding(key_override,i);
    if (pcVar2 != (char *)0x0) {
      p_Var1 = target->isa->put_block;
      wVar3 = strlen(pcVar2);
      (*p_Var1)(target,pcVar2,wVar3);
      if (pcVar2 != (char *)0x0) {
        free(pcVar2);
      }
    }
  }
  if (both != '\0') {
    i_00 = i + -0x20;
    if (((prev_lynx_edit_mode == '\0') || (no_dired_support != '\0')) || (key_override[i_00] == 0))
    {
      if (keymap[i_00] != lac1) {
        pcVar2 = format_binding(keymap,i_00);
        if (pcVar2 != (char *)0x0) {
          p_Var1 = target->isa->put_block;
          wVar3 = strlen(pcVar2);
          (*p_Var1)(target,pcVar2,wVar3);
          if (pcVar2 != (char *)0x0) {
            free(pcVar2);
          }
        }
      }
    }
    else if (key_override[i_00] != lac1) {
      pcVar2 = format_binding(key_override,i_00);
      if (pcVar2 != (char *)0x0) {
        p_Var1 = target->isa->put_block;
        wVar3 = strlen(pcVar2);
        (*p_Var1)(target,pcVar2,wVar3);
        if (pcVar2 != (char *)0x0) {
          free(pcVar2);
        }
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

int lacname_to_lac(char *func)

{
  Kcmd *pKVar1;
  LYKeymapCode local_18;
  Kcmd *mp;
  
  pKVar1 = LYStringToKcmd(func);
  if (pKVar1 == (Kcmd *)0x0) {
    local_18 = ~LYK_UNKNOWN;
  }
  else {
    local_18 = pKVar1->code;
  }
  return local_18;
}



// WARNING: Unknown calling convention

int lecname_to_lec(char *func)

{
  int iVar1;
  emap *mp;
  int i;
  
  if ((func != (char *)0x0) && (*func != '\0')) {
    for (mp = ekmap; mp->name != (char *)0x0; mp = mp + 1) {
      iVar1 = strcmp(mp->name,func);
      if (iVar1 == 0) {
        return mp->code;
      }
    }
  }
  return -1;
}



// WARNING: Unknown calling convention

int lkcstring_to_lkc(char *src)

{
  size_t sVar1;
  ushort **ppuVar2;
  int iVar3;
  int local_18;
  int c;
  
  c = -1;
  sVar1 = strlen(src);
  if (sVar1 == 1) {
    c = (int)*src;
  }
  else {
    sVar1 = strlen(src);
    if ((sVar1 == 2) && (*src == '^')) {
      c = (int)src[1] & 0x1f;
    }
    else {
      sVar1 = strlen(src);
      if ((sVar1 < 2) || (ppuVar2 = __ctype_b_loc(), ((*ppuVar2)[(byte)*src] & 0x800) == 0)) {
        map_string_to_keysym(src,&c);
        if (-1 < c) {
          if ((0xff < (c & 0x7ffU)) && ((c & 0x400U) == 0)) {
            return -1;
          }
          c = c & 0xfffffbff;
        }
      }
      else {
        iVar3 = sscanf(src,"%i",&c);
        if (iVar3 != 1) {
          return -1;
        }
      }
    }
  }
  if (c == 0x1b) {
    escape_bound = 1;
  }
  if (c < -1) {
    local_18 = -1;
  }
  else {
    local_18 = c;
  }
  return local_18;
}



// WARNING: Unknown calling convention

int LYLoadKeymap(char *arg,HTParentAnchor *anAnchor,HTFormat format_out,HTStream *sink)

{
  char *pcVar1;
  char *pcVar2;
  _func_void_HTStream_ptr_char_ptr_wchar_t *p_Var3;
  char *fmt;
  undefined4 uVar4;
  wchar_t wVar5;
  ushort **ppuVar6;
  int local_20;
  int i;
  char *buf;
  HTStream *target;
  HTFormat format_in;
  
  format_in = HTAtom_for("text/html");
  buf = (char *)0x0;
  target = (HTStream *)HTStreamStack(format_in,format_out,(HTStream_conflict4 *)sink,anAnchor);
  if (((HTStream_conflict4 *)target == (HTStream_conflict4 *)0x0) ||
     ((HTStream_conflict4 *)target == (HTStream_conflict4 *)0x0)) {
    pcVar1 = format_out->name;
    pcVar2 = format_in->name;
    fmt = (char *)gettext("Sorry, no known way of converting %s to %s.");
    HTSprintf0(&buf,fmt,pcVar2,pcVar1);
    HTAlert(buf);
    if (buf != (char *)0x0) {
      free(buf);
    }
    local_20 = -29999;
  }
  else {
    anAnchor->no_cache = '\x01';
    uVar4 = gettext("Current Key Map");
    HTSprintf0(&buf,"<html>\n<head>\n<title>%s</title>\n</head>\n<body>\n",uVar4);
    p_Var3 = target->isa->put_block;
    wVar5 = strlen(buf);
    (*p_Var3)(target,buf,wVar5);
    HTSprintf0(&buf,"<pre>\n");
    p_Var3 = target->isa->put_block;
    wVar5 = strlen(buf);
    (*p_Var3)(target,buf,wVar5);
    for (i = 0x62; i < 0x7c; i = i + 1) {
      print_binding(target,i,'\x01');
    }
    for (i = 1; i < 0x295; i = i + 1) {
      if ((i < 0x80) && (0x20 < i)) {
        ppuVar6 = __ctype_b_loc();
        if (((*ppuVar6)[-(1 - i)] & 0x400) == 0) goto LAB_080b5dac;
      }
      else {
LAB_080b5dac:
        if ((LYUseMouse != '\0') || (keymap[i] != 0x54)) {
          print_binding(target,i,'\0');
        }
      }
    }
    HTSprintf0(&buf,"</pre>\n</body>\n</html>\n");
    p_Var3 = target->isa->put_block;
    wVar5 = strlen(buf);
    (*p_Var3)(target,buf,wVar5);
    (*target->isa->_free)(target);
    if (buf != (char *)0x0) {
      free(buf);
    }
    local_20 = 200;
  }
  return local_20;
}



int remap(char *key,char *func,BOOLEAN for_dired)

{
  Kcmd *pKVar1;
  uint local_20;
  uint local_1c;
  BOOLEAN for_dired_local;
  int c;
  Kcmd *mp;
  
  if (func == (char *)0x0) {
    local_20 = 0;
  }
  else {
    c = lkcstring_to_lkc(key);
    if (c < 0) {
      local_20 = 0;
    }
    else {
      if (-1 < c) {
        if ((c & 0x8800U) != 0) {
          return 0;
        }
        if ((c & 0x7ffU) != c) {
          c = c & 0x7ff;
        }
      }
      if (c + 1 < 0x295) {
        pKVar1 = LYStringToKcmd(func);
        if (pKVar1 == (Kcmd *)0x0) {
          local_20 = 0;
        }
        else {
          if (for_dired == '\0') {
            keymap[c + 1] = (LYKeymap_t)pKVar1->code;
          }
          else {
            key_override[c + 1] = (LYKeymap_t)pKVar1->code;
          }
          if (c == 0) {
            local_1c = pKVar1->code | 0x800;
          }
          else {
            local_1c = c;
          }
          local_20 = local_1c;
        }
      }
      else {
        local_20 = 0;
      }
    }
  }
  return local_20;
}



// WARNING: Unknown calling convention

void set_any_keys(ANY_KEYS *table,int size)

{
  int iVar1;
  int k;
  int j;
  
  for (j = 0; j < size; j = j + 1) {
    iVar1 = table[j].code + 1;
    table[j].save = keymap[iVar1];
    keymap[iVar1] = table[j].map;
  }
  return;
}



// WARNING: Unknown calling convention

void reset_any_keys(ANY_KEYS *table,int size)

{
  int k;
  int j;
  
  for (j = 0; j < size; j = j + 1) {
    keymap[table[j].code + 1] = table[j].save;
  }
  return;
}



// WARNING: Unknown calling convention

void set_vms_keys(void)

{
  set_any_keys(vms_keys_table,2);
  return;
}



// WARNING: Unknown calling convention

void set_vi_keys(void)

{
  set_any_keys(vi_keys_table,4);
  did_vi_keys = '\x01';
  return;
}



// WARNING: Unknown calling convention

void reset_vi_keys(void)

{
  if (did_vi_keys != '\0') {
    reset_any_keys(vi_keys_table,4);
    did_vi_keys = '\0';
  }
  return;
}



// WARNING: Unknown calling convention

void set_emacs_keys(void)

{
  set_any_keys(emacs_keys_table,4);
  did_emacs_keys = '\x01';
  return;
}



// WARNING: Unknown calling convention

void reset_emacs_keys(void)

{
  if (did_emacs_keys != '\0') {
    reset_any_keys(emacs_keys_table,4);
    did_emacs_keys = '\0';
  }
  return;
}



// WARNING: Unknown calling convention

void set_numbers_as_arrows(void)

{
  set_any_keys(number_keys_table,9);
  did_number_keys = '\x01';
  return;
}



// WARNING: Unknown calling convention

void reset_numbers_as_arrows(void)

{
  if (did_number_keys != '\0') {
    reset_any_keys(number_keys_table,9);
    did_number_keys = '\0';
  }
  return;
}



// WARNING: Unknown calling convention

char * key_for_func(int func)

{
  int c;
  char *local_18;
  char *formatted;
  int i;
  
  c = LYReverseKeymap(func);
  if (c < 0) {
    if (key_for_func::buf == (char *)0x0) {
      HTSACopy(&key_for_func::buf,"");
    }
  }
  else {
    local_18 = LYKeycodeToString(c,'\x01');
    if (local_18 == (char *)0x0) {
      local_18 = "?";
    }
    HTSACopy(&key_for_func::buf,local_18);
  }
  return key_for_func::buf;
}



// WARNING: Unknown calling convention

char * fmt_keys(int lkc_first,int lkc_second)

{
  char *pcVar1;
  char *pcVar2;
  size_t sVar3;
  undefined *local_20;
  undefined *local_1c;
  char *fmt_second;
  char *fmt_first;
  char *buf;
  BOOLEAN quotes;
  
  buf = (char *)0x0;
  quotes = '\0';
  if (lkc_first < 0) {
    return (char *)0x0;
  }
  pcVar2 = LYKeycodeToString(lkc_first,'\x01');
  if (((pcVar2 != (char *)0x0) && (sVar3 = strlen(pcVar2), sVar3 == 1)) && (*pcVar2 != '\'')) {
    quotes = '\x01';
  }
  if (quotes == '\0') {
    HTSACopy(&buf,pcVar2);
  }
  else {
    if (lkc_second < 0) {
      HTSprintf0(&buf,"\'%s\'",pcVar2);
      return buf;
    }
    HTSprintf0(&buf,"\'%s",pcVar2);
  }
  if (-1 < lkc_second) {
    pcVar2 = LYKeycodeToString(lkc_second,'\x01');
    if (pcVar2 == (char *)0x0) {
      if (buf != (char *)0x0) {
        free(buf);
      }
      return (char *)0x0;
    }
    if (quotes == '\0') {
      local_20 = &DAT_081646f7;
    }
    else {
      local_20 = &DAT_08164d9d;
    }
    sVar3 = strlen(pcVar2);
    if (((sVar3 < 3) || (*pcVar2 == '<')) &&
       ((sVar3 = strlen(buf), pcVar1 = buf, sVar3 < 3 ||
        (sVar3 = strlen(buf), pcVar1[sVar3 - 1] == '>')))) {
      local_1c = &DAT_081646f7;
    }
    else {
      local_1c = &DAT_08164d9f;
    }
    HTSprintf(&buf,"%s%s%s",local_1c,pcVar2,local_20);
  }
  return buf;
}



// WARNING: Unknown calling convention

int best_reverse_keymap(int lac)

{
  uint local_40;
  uint local_3c;
  uint local_34;
  uint local_30;
  int local_2c;
  int local_28;
  int local_24;
  int local_20;
  int local_1c;
  int local_18;
  int c;
  int i;
  
  i = 0x61;
  while( true ) {
    if (i < 0) {
      return -1;
    }
    if (((lynx_edit_mode != '\0') && (no_dired_support == '\0')) && (lac != 0)) {
      if (i == -1) {
        local_40 = (uint)key_override[0];
      }
      else {
        if ((i & 0x8800U) == 0) {
          local_3c = (uint)key_override[(i & 0x7ffU) + 1];
        }
        else {
          local_3c = i & 0xff;
        }
        local_40 = local_3c;
      }
      if (local_40 == lac) {
        return i;
      }
    }
    if (i == -1) {
      local_34 = (uint)keymap[0];
    }
    else {
      if ((i & 0x8800U) == 0) {
        local_30 = (uint)keymap[(i & 0x7ffU) + 1];
      }
      else {
        local_30 = i & 0xff;
      }
      local_34 = local_30;
    }
    if (local_34 == lac) break;
    if (i == 0x7a) {
      local_2c = 0x20;
    }
    else {
      if (i == 0x60) {
        local_28 = 0x7b;
      }
      else {
        if (i == 0x7e) {
          local_24 = 0;
        }
        else {
          if (i == 0x1f) {
            local_20 = 0x100;
          }
          else {
            if (i == 0x293) {
              local_1c = 0x7f;
            }
            else {
              if (i == 0xff) {
                local_18 = -1;
              }
              else {
                local_18 = i + 1;
              }
              local_1c = local_18;
            }
            local_20 = local_1c;
          }
          local_24 = local_20;
        }
        local_28 = local_24;
      }
      local_2c = local_28;
    }
    i = local_2c;
  }
  return i;
}



// WARNING: Unknown calling convention

char * key_for_func_ext(int lac,int context_code)

{
  char *pcVar1;
  char *local_18;
  int modkey;
  int lkc;
  
  modkey = -1;
  if ((context_code == 2) && (lkc = LYEditKeyForAction(lac,&modkey), -1 < lkc)) {
    if ((lkc & 0x7000U) != 0) {
      pcVar1 = fmt_keys(modkey,lkc & 0xffff8fff);
      return pcVar1;
    }
    pcVar1 = fmt_keys(lkc,-1);
    return pcVar1;
  }
  lkc = best_reverse_keymap(lac);
  if (lkc < 0) {
    local_18 = (char *)0x0;
  }
  else if (context_code == 2) {
    modkey = LYKeyForEditAction(0x17);
    if (modkey < 0) {
      local_18 = (char *)0x0;
    }
    else {
      local_18 = fmt_keys(modkey,lkc);
    }
  }
  else {
    local_18 = fmt_keys(lkc,-1);
  }
  return local_18;
}



// WARNING: Unknown calling convention

BOOLEAN LYisNonAlnumKeyname(int ch,int KeyName)

{
  char *pcVar1;
  bool local_5;
  
  if ((ch < 0) || (0x294 < ch)) {
    local_5 = false;
  }
  else {
    if ((0 < ch) &&
       (pcVar1 = strchr("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",ch),
       pcVar1 != (char *)0x0)) {
      return '\0';
    }
    local_5 = (uint)keymap[ch + 1] == KeyName;
  }
  return local_5;
}



// WARNING: Unknown calling convention

int LYReverseKeymap(int KeyName)

{
  int i;
  
  i = 1;
  while( true ) {
    if (0x294 < i) {
      return -1;
    }
    if ((uint)keymap[i] == KeyName) break;
    i = i + 1;
  }
  return i + -1;
}



// WARNING: Unknown calling convention

void strtolower(char *i)

{
  ushort **ppuVar1;
  int iVar2;
  char local_5;
  
  if (i != (char *)0x0) {
    for (; *i != '\0'; i = i + 1) {
      ppuVar1 = __ctype_b_loc();
      if (((*ppuVar1)[(byte)*i] & 0x100) == 0) {
        local_5 = *i;
      }
      else {
        iVar2 = tolower((uint)(byte)*i);
        local_5 = (char)iVar2;
      }
      *i = local_5;
    }
  }
  return;
}



// WARNING: Unknown calling convention

void actually_set_style(HTStructured *me)

{
  LYUCcharset *p_out;
  int cs_out;
  HText *pHVar1;
  
  if (me->text == (HText *)0x0) {
    LYGetChartransInfo(me);
    p_out = HTAnchor_getUCInfoStage(me->node_anchor,3);
    cs_out = HTAnchor_getUCLYhndl(me->node_anchor,3);
    UCSetTransParams(&me->T,me->UCLYhndl,me->UCI,cs_out,p_out);
    pHVar1 = HText_new2(me->node_anchor,me->target);
    me->text = pHVar1;
    HText_beginAppend(me->text);
    HText_setStyle(me->text,me->new_style);
    me->in_word = '\0';
    LYCheckForContentBase(me);
  }
  else {
    HText_setStyle(me->text,me->new_style);
  }
  me->old_style = me->new_style;
  me->style_change = '\0';
  return;
}



// WARNING: Unknown calling convention

void change_paragraph_style(HTStructured *me,HTStyle *style)

{
  if (me->new_style != style) {
    me->style_change = '\x01';
    me->new_style = style;
  }
  me->in_word = '\0';
  return;
}



// WARNING: Unknown calling convention

BOOLEAN LYBadHTML(HTStructured *me)

{
  char *Msg;
  BOOLEAN local_5;
  
  if ((WWW_TraceFlag == '\0') && (me->inBadHTML == '\0')) {
    Msg = (char *)gettext("** Bad HTML!!  Use -trace to diagnose. **");
    HTUserMsg(Msg);
    me->inBadHTML = '\x01';
    local_5 = '\0';
  }
  else {
    local_5 = '\x01';
  }
  return local_5;
}



void HTML_put_character(HTStructured *me,char c)

{
  int iVar1;
  char cVar2;
  char c_local;
  
  c_local = c;
  if ((LYMapsOnly != '\0') && (me->sp->tag_number != 0x4f)) {
    return;
  }
  if ((me->lastraw == 0xd) && (c == '\n')) {
    me->lastraw = -1;
    return;
  }
  me->lastraw = (int)c;
  if (c == '\r') {
    c_local = '\n';
  }
  switch(me->sp->tag_number) {
  case 0x1c:
    break;
  default:
    if ((me->inSELECT != '\0') && (me->sp->tag_number != 0)) {
      HTChunkPutc(&me->option,c_local);
      return;
    }
    iVar1 = me->sp->tag_number;
    if (iVar1 == 0x55) {
LAB_080b6adf:
      if (c_local != '\r') {
        me->inP = '\x01';
        me->inLABEL = '\0';
        HText_appendCharacter(me->text,(int)c_local);
      }
    }
    else {
      if (iVar1 < 0x56) {
        if (iVar1 == 0x46) goto LAB_080b6adf;
      }
      else {
        if (iVar1 == 0x56) {
          if ((c_local != '\r') &&
             ((((c_local != '\n' || (me->inLABEL == '\0')) || (me->inP != '\0')) &&
              ((c_local != '\n' || (me->inPRE != '\0')))))) {
            me->inP = '\x01';
            me->inLABEL = '\0';
            HText_appendCharacter(me->text,(int)c_local);
          }
          me->inPRE = '\x01';
          goto LAB_080b6d21;
        }
        if (iVar1 == 0x75) goto LAB_080b6adf;
      }
      if (me->sp->style->id == 0x25) {
        if ((c_local != '\r') &&
           ((((c_local != '\n' || (me->inLABEL == '\0')) || (me->inP != '\0')) &&
            ((c_local != '\n' || (me->inPRE != '\0')))))) {
          me->inP = '\x01';
          me->inLABEL = '\0';
          HText_appendCharacter(me->text,(int)c_local);
        }
        me->inPRE = '\x01';
      }
      else if ((me->sp->style->id == 0x26) || (me->sp->style->id == 0x24)) {
        if (c_local != '\r') {
          me->inP = '\x01';
          me->inLABEL = '\0';
          HText_appendCharacter(me->text,(int)c_local);
        }
      }
      else {
        if (me->style_change != '\0') {
          if (c_local == '\n') {
            return;
          }
          if (c_local == ' ') {
            return;
          }
          if (me->style_change != '\0') {
            actually_set_style(me);
          }
        }
        if (c_local == '\n') {
          if (me->in_word != '\0') {
            cVar2 = HText_getLastChar(me->text);
            if (cVar2 != ' ') {
              me->inP = '\x01';
              me->inLABEL = '\0';
              HText_appendCharacter(me->text,L' ');
            }
            me->in_word = '\0';
          }
        }
        else if ((c_local == ' ') || (c_local == '\t')) {
          cVar2 = HText_getLastChar(me->text);
          if (cVar2 != ' ') {
            me->inP = '\x01';
            me->inLABEL = '\0';
            HText_appendCharacter(me->text,L' ');
          }
        }
        else if (c_local != '\r') {
          me->inP = '\x01';
          me->inLABEL = '\0';
          HText_appendCharacter(me->text,(int)c_local);
          me->in_word = '\x01';
        }
      }
    }
LAB_080b6d21:
    if ((c_local == '\n') || (c_local == '\t')) {
      HText_setLastChar(me->text,' ');
    }
    else if ((c_local == '\r') && (cVar2 = HText_getLastChar(me->text), cVar2 == ' ')) {
      HText_setLastChar(me->text,' ');
    }
    else {
      HText_setLastChar(me->text,c_local);
    }
    break;
  case 0x49:
    HTChunkPutc(&me->math,c_local);
    break;
  case 0x4f:
    HTChunkPutc(&me->object,c_local);
    break;
  case 0x51:
  case 0x5b:
    HTChunkPutc(&me->option,c_local);
    break;
  case 0x5a:
    HTChunkPutc(&me->script,c_local);
    break;
  case 0x62:
    HTChunkPutc(&me->style_block,c_local);
    break;
  case 0x69:
    HTChunkPutc(&me->textarea,c_local);
    break;
  case 0x6e:
    if (c_local != '\a') {
      if (((c_local == '\n') || (c_local == '\t')) || (c_local == '\r')) {
        HTChunkPutc(&me->title,' ');
      }
      else {
        HTChunkPutc(&me->title,c_local);
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

void HTML_put_string(HTStructured *me,char *s)

{
  char cVar1;
  char *p;
  char *translated_string;
  char c;
  
  translated_string = (char *)0x0;
  if (s == (char *)0x0) {
    return;
  }
  if ((LYMapsOnly != '\0') && (me->sp->tag_number != 0x4f)) {
    return;
  }
  if (psrc_convert_string != '\0') {
    HTSACopy(&translated_string,s);
    LYUCTranslateHTMLString
              (&translated_string,me->tag_charset,current_char_set,'\x01','\x01','\0',st_HTML);
    s = translated_string;
  }
  switch(me->sp->tag_number) {
  case 0x1c:
    break;
  default:
    if (me->sp->style->freeFormat == '\0') {
      if (psrc_view == '\0') {
        HText_appendText(me->text,s);
      }
      else {
        for (; *s != '\0'; s = s + 1) {
          HTML_put_character(me,*s);
        }
      }
    }
    else {
      p = s;
      if (me->style_change != '\0') {
        for (; (*p != '\0' && ((((*p == '\n' || (*p == '\r')) || (*p == ' ')) || (*p == '\t'))));
            p = p + 1) {
        }
        if (*p == '\0') break;
        if (me->style_change != '\0') {
          actually_set_style(me);
        }
      }
      for (; *p != '\0'; p = p + 1) {
        if ((*p == '\r') && (p[1] != '\n')) {
          c = '\n';
        }
        else {
          c = *p;
        }
        if (me->style_change == '\0') {
LAB_080b7080:
          if (c == '\n') {
            if (me->in_word != '\0') {
              cVar1 = HText_getLastChar(me->text);
              if (cVar1 != ' ') {
                HText_appendCharacter(me->text,L' ');
              }
              me->in_word = '\0';
            }
          }
          else if ((c == ' ') || (c == '\t')) {
            cVar1 = HText_getLastChar(me->text);
            if (cVar1 != ' ') {
              HText_appendCharacter(me->text,L' ');
            }
          }
          else if (c != '\r') {
            HText_appendCharacter(me->text,(int)c);
            me->in_word = '\x01';
          }
          if ((c == '\n') || (c == '\t')) {
            HText_setLastChar(me->text,' ');
          }
          else if ((c == '\r') && (cVar1 = HText_getLastChar(me->text), cVar1 == ' ')) {
            HText_setLastChar(me->text,' ');
          }
          else {
            HText_setLastChar(me->text,c);
          }
        }
        else if (((c != '\n') && (c != ' ')) && (c != '\t')) {
          if (me->style_change != '\0') {
            actually_set_style(me);
          }
          goto LAB_080b7080;
        }
      }
    }
    break;
  case 0x46:
  case 0x55:
  case 0x56:
  case 0x75:
    HText_appendText(me->text,s);
    break;
  case 0x49:
    HTChunkPuts(&me->math,s);
    break;
  case 0x4f:
    HTChunkPuts(&me->object,s);
    break;
  case 0x51:
  case 0x5b:
    HTChunkPuts(&me->option,s);
    break;
  case 0x5a:
    HTChunkPuts(&me->script,s);
    break;
  case 0x62:
    HTChunkPuts(&me->style_block,s);
    break;
  case 0x69:
    HTChunkPuts(&me->textarea,s);
    break;
  case 0x6e:
    HTChunkPuts(&me->title,s);
  }
  if ((psrc_convert_string != '\0') &&
     (psrc_convert_string = '\0', translated_string != (char *)0x0)) {
    free(translated_string);
  }
  return;
}



// WARNING: Unknown calling convention

void HTML_write(HTStructured *me,char *s,int l)

{
  char *e;
  char *p;
  
  if ((LYMapsOnly == '\0') || (me->sp->tag_number == 0x4f)) {
    for (p = s; p < s + l; p = p + 1) {
      HTML_put_character(me,*p);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void addClassName(char *prefix,char *actual,int length)

{
  size_t sVar1;
  int iVar2;
  int iVar3;
  uint need;
  uint have;
  int offset;
  
  sVar1 = strlen(prefix);
  iVar3 = (int)Style_className_end - (int)Style_className;
  iVar2 = sVar1 + length + 1;
  if (Style_className_len <= (uint)(iVar3 + iVar2)) {
    Style_className_len = (iVar3 + iVar2 + 0x200) * 2 + Style_className_len;
    if (Style_className == (char *)0x0) {
      Style_className = (char *)malloc(Style_className_len);
    }
    else {
      Style_className = (char *)realloc(Style_className,Style_className_len);
    }
    if (Style_className == (char *)0x0) {
      outofmem("./HTML.c","addClassName");
    }
    Style_className_end = Style_className + iVar3;
  }
  if (sVar1 != 0) {
    strcpy(Style_className_end,prefix);
  }
  if (length != 0) {
    memcpy(Style_className_end + sVar1,actual,length);
  }
  Style_className_end[sVar1 + length] = '\0';
  strtolower(Style_className_end);
  Style_className_end = Style_className_end + sVar1 + length;
  return;
}



void HTMLSRC_apply_markup(HTStructured *context,HTlexeme lexeme,BOOLEAN start,int tag_charset)

{
  FILE *__stream;
  HT_tagspec **local_28;
  char *local_20;
  BOOLEAN start_local;
  HT_tagspec *ts;
  
  if (start == '\0') {
    local_28 = lexeme_end;
  }
  else {
    local_28 = lexeme_start;
  }
  for (ts = local_28[lexeme]; ts != (HT_tagspec *)0x0; ts = ts->next) {
    if (ts->start != '\0') {
      current_tag_style = ts->style;
      force_current_tag_style = '\x01';
      forced_classname = ts->class_name;
      force_classname = '\x01';
    }
    if (WWW_TraceFlag != '\0') {
      if (ts->start == '\0') {
        local_20 = "SRCSTOP %d\n";
      }
      else {
        local_20 = "SRCSTART %d\n";
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,local_20,lexeme);
    }
    if (ts->start == '\0') {
      HTML_end_element(context,ts->element,(char **)0x0);
    }
    else {
      HTML_start_element(context,ts->element,ts->present,ts->value,tag_charset,(char **)0x0);
    }
  }
  return;
}



void LYStartArea(HTStructured *obj,char *href,char *alt,char *title,int tag_charset)

{
  int iVar1;
  int in_GS_OFFSET;
  char *title_local;
  char *alt_local;
  char *href_local;
  HTStructured *obj_local;
  char *new_value [18];
  int i;
  BOOLEAN new_present [18];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  for (i = 0; i < 0x12; i = i + 1) {
    new_present[i] = '\0';
  }
  if (alt != (char *)0x0) {
    new_present[1] = '\x01';
    new_value[1] = alt;
  }
  if ((title != (char *)0x0) && (*title != '\0')) {
    new_present[17] = '\x01';
    new_value[17] = title;
  }
  if (href != (char *)0x0) {
    new_present[6] = '\x01';
    new_value[6] = href;
  }
  (*obj->isa->start_element)(obj,5,new_present,new_value,tag_charset,(char **)0x0);
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void LYHandleFIG(HTStructured *me,BOOLEAN *present,char **value,BOOLEAN isobject,BOOLEAN imagemap,
                char *id,char *src,BOOLEAN convert,BOOLEAN start,BOOLEAN *intern_flag)

{
  HTChildAnchor *pHVar1;
  BOOLEAN local_38;
  HTLinkType *local_34;
  char *local_30;
  char *local_2c;
  BOOLEAN start_local;
  BOOLEAN convert_local;
  BOOLEAN imagemap_local;
  BOOLEAN isobject_local;
  char *href;
  
  if (start == '\x01') {
    me->inFIG = '\x01';
    if (me->inA != '\0') {
      if (tags[0].contents != SGML_EMPTY) {
        me->skip_stack = me->skip_stack + 1;
      }
      HTML_end_element(me,0,(char **)0x0);
    }
    if (isobject == '\0') {
      LYEnsureDoubleSpace(me);
      LYResetParagraphAlignment(me);
      me->inFIGwithP = '\x01';
    }
    else {
      me->inFIGwithP = '\0';
      HTML_put_character(me,' ');
    }
    if ((id != (char *)0x0) && (*id != '\0')) {
      if ((present == (BOOLEAN *)0x0) || (convert == '\0')) {
        LYHandleID(me,id);
      }
      else {
        LYCheckForID(me,present,value,6);
      }
    }
    me->in_word = '\0';
    me->inP = '\0';
    if (((clickable_images != '\0') && (src != (char *)0x0)) && (*src != '\0')) {
      href = (char *)0x0;
      HTSACopy(&href,src);
      if ((href == (char *)0x0) || ((*href != '#' && (*href != '\0')))) {
        local_38 = '\0';
      }
      else {
        local_38 = '\x01';
      }
      *intern_flag = local_38;
      LYLegitimizeHREF(me,&href,'\x01','\x01');
      if (*href != '\0') {
        if (intern_flag == (BOOLEAN *)0x0) {
          local_34 = (HTLinkType *)0x0;
        }
        else {
          local_34 = HTInternalLink;
        }
        pHVar1 = HTAnchor_findChildAndLink(me->node_anchor,(char *)0x0,href,local_34);
        me->CurrentA = pHVar1;
        HText_beginAnchor(me->text,me->inUnderline,me->CurrentA);
        if (me->inBoldH == '\0') {
          HText_appendCharacter(me->text,L'\x05');
        }
        if (isobject == '\0') {
          local_30 = "[FIGURE]";
        }
        else {
          if (imagemap == '\0') {
            local_2c = "(OBJECT)";
          }
          else {
            local_2c = "(IMAGE)";
          }
          local_30 = local_2c;
        }
        HTML_put_string(me,local_30);
        if (me->inBoldH == '\0') {
          HText_appendCharacter(me->text,L'\x06');
        }
        HText_endAnchor(me->text,L'\0');
        HTML_put_character(me,'-');
        HTML_put_character(me,' ');
        me->in_word = '\0';
      }
      if (href != (char *)0x0) {
        free(href);
      }
    }
  }
  else {
    if (me->inFIGwithP == '\0') {
      HTML_put_character(me,' ');
    }
    else {
      LYEnsureDoubleSpace(me);
    }
    LYResetParagraphAlignment(me);
    me->inFIGwithP = '\0';
    me->inFIG = '\0';
    change_paragraph_style(me,me->sp->style);
    if (-1 < me->List_Nesting_Level) {
      if (me->style_change != '\0') {
        actually_set_style(me);
      }
      HText_NegateLineOne(me->text);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void clear_objectdata(HTStructured *me)

{
  if (me != (HTStructured *)0x0) {
    HTChunkClear(&me->object);
    me->object_started = '\0';
    me->object_declare = '\0';
    me->object_shapes = '\0';
    me->object_ismap = '\0';
    if (me->object_usemap != (char *)0x0) {
      free(me->object_usemap);
      me->object_usemap = (char *)0x0;
    }
    if (me->object_id != (char *)0x0) {
      free(me->object_id);
      me->object_id = (char *)0x0;
    }
    if (me->object_title != (char *)0x0) {
      free(me->object_title);
      me->object_title = (char *)0x0;
    }
    if (me->object_data != (char *)0x0) {
      free(me->object_data);
      me->object_data = (char *)0x0;
    }
    if (me->object_type != (char *)0x0) {
      free(me->object_type);
      me->object_type = (char *)0x0;
    }
    if (me->object_classid != (char *)0x0) {
      free(me->object_classid);
      me->object_classid = (char *)0x0;
    }
    if (me->object_codebase != (char *)0x0) {
      free(me->object_codebase);
      me->object_codebase = (char *)0x0;
    }
    if (me->object_codetype != (char *)0x0) {
      free(me->object_codetype);
      me->object_codetype = (char *)0x0;
    }
    if (me->object_name != (char *)0x0) {
      free(me->object_name);
      me->object_name = (char *)0x0;
    }
  }
  return;
}


/*
Unable to decompile 'HTML_start_element'
Cause: Exception while decompiling 080b7abc: process: timeout

*/


// WARNING: Removing unreachable block (ram,0x080cccc9)

int HTML_end_element(HTStructured *me,int element_number,char **include)

{
  int iVar1;
  stack_element *psVar2;
  BOOLEAN BVar3;
  FILE *pFVar4;
  int iVar5;
  char *pcVar6;
  ushort **ppuVar7;
  size_t sVar8;
  wchar_t wVar9;
  int in_GS_OFFSET;
  int local_200;
  char *local_1fc;
  char *local_1f8;
  char *local_1f4;
  char *local_1f0;
  char *local_1ec;
  char *local_1e8;
  char *local_1e4;
  undefined1 *local_1e0;
  undefined1 *local_1dc;
  char *local_1d8;
  undefined1 *local_1d4;
  char *local_1d0;
  char *local_1cc;
  char *local_1c8;
  undefined1 *local_1c4;
  undefined1 *local_1c0;
  char *local_1bc;
  undefined1 *local_1b8;
  char *local_1b4;
  int local_1b0;
  undefined1 *local_1ac;
  char local_1a1;
  char local_199;
  char **include_local;
  HTStructured *me_local;
  InputFieldData_conflict I;
  HTkcode specified_kcode;
  HTkcode kcode;
  char *ptr;
  int j_1;
  int j;
  char *data_1;
  int chars;
  char *data;
  char *last_map;
  char *first_map;
  char *last_end;
  char *first_end;
  char *start;
  int e;
  int s;
  int tag_charset;
  HTTag *tag;
  char *cp;
  char *temp;
  int status;
  int i;
  BOOLEAN have_param;
  BOOLEAN reached_awaited_stacked_elt;
  BOOLEAN skip_stack_requested;
  BOOLEAN intern_flag;
  BOOLEAN BreakFlag;
  char buf [200];
  
  include_local = include;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  i = 0;
  status = 0;
  temp = (char *)0x0;
  cp = (char *)0x0;
  BreakFlag = '\0';
  intern_flag = '\0';
  skip_stack_requested = '\0';
  reached_awaited_stacked_elt = '\0';
  if (((psrc_view != '\0') && (sgml_in_psrc_was_initialized == '\0')) && (psrc_nested_call == '\0'))
  {
    tag = tags + element_number;
    tag_charset = 0;
    psrc_nested_call = '\x01';
    HTMLSRC_apply_markup(me,HTL_abracket,'\x01',0);
    HTML_put_string(me,"</");
    HTMLSRC_apply_markup(me,HTL_abracket,'\0',tag_charset);
    HTMLSRC_apply_markup(me,HTL_tag,'\x01',tag_charset);
    if (tagname_transform == 0) {
      LYstrncpy(buf,tag->name,L'');
      LYLowerCase(buf);
      HTML_put_string(me,buf);
    }
    else {
      HTML_put_string(me,tag->name);
    }
    HTMLSRC_apply_markup(me,HTL_tag,'\0',tag_charset);
    HTMLSRC_apply_markup(me,HTL_abracket,'\x01',tag_charset);
    HTML_put_character(me,'>');
    HTMLSRC_apply_markup(me,HTL_abracket,'\0',tag_charset);
    psrc_nested_call = '\0';
    local_200 = 0;
    goto LAB_080cd7d5;
  }
  if (((me->stack + 799 <= me->sp) || (me->sp->tag_number != element_number)) &&
     ((tags[element_number].contents != SGML_EMPTY && (WWW_TraceFlag != '\0')))) {
    if (me->sp == me->stack + 799) {
      local_1fc = "none";
    }
    else {
      if (me->sp->tag_number < 0) {
        local_1f8 = "*invalid tag*";
      }
      else {
        if (me->sp->tag_number < 0x76) {
          local_1f4 = tags[me->sp->tag_number].name;
        }
        else {
          local_1f4 = "special tag";
        }
        local_1f8 = local_1f4;
      }
      local_1fc = local_1f8;
    }
    pcVar6 = tags[element_number].name;
    pFVar4 = TraceFP();
    fprintf((FILE *)pFVar4,"HTML: end of element %s when expecting end of %s\n",pcVar6,local_1fc);
  }
  if (((LYMapsOnly != '\0') && (element_number != 0x47)) &&
     ((element_number != 5 && (element_number != 0x4f)))) {
    local_200 = 0;
    goto LAB_080cd7d5;
  }
  if (tags[element_number].contents != SGML_EMPTY) {
    skip_stack_requested = 0 < me->skip_stack;
    if (((((me->sp->tag_number != element_number) && (me->skip_stack < 1)) &&
         (tags[67].contents != SGML_EMPTY)) &&
        (((me->sp->tag_number == 0x72 || (me->sp->tag_number == 0x50)) ||
         ((me->sp->tag_number == 0x4a ||
          ((me->sp->tag_number == 0x21 || (me->sp->tag_number == 0x44)))))))) &&
       ((element_number == 0x2f ||
        ((((element_number == 0x30 || (element_number == 0x31)) || (element_number == 0x32)) ||
         ((element_number == 0x33 || (element_number == 0x34)))))))) {
      BreakFlag = '\x01';
    }
    if (((me->skip_stack == 0) && (element_number == 0x4f)) &&
       ((me->sp->tag_number == 0x95 && (me->sp < me->stack + 799)))) {
      me->sp->tag_number = 0x4f;
    }
    if (me->skip_stack < 1) {
      if ((((element_number == 0x4f) && (me->sp->tag_number != 0x4f)) &&
          (me->sp->tag_number != 0x95)) &&
         ((0 < me->objects_mixed_open &&
          ((me->objects_figged_open < 1 || (me->sp->tag_number != 0x29)))))) {
        if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
          if (me->sp->style->name == (char *)0x0) {
            local_1ec = "(null)";
          }
          else {
            local_1ec = me->sp->style->name;
          }
          iVar5 = me->objects_mixed_open;
          psVar2 = me->sp;
          pFVar4 = TraceFP();
          fprintf((FILE *)pFVar4,"HTML:end_element[%d]: %s (level %d), %s - %s\n",
                  (int)me + (0x20ec - (int)psVar2) >> 3,"Special OBJECT handling",iVar5,
                  "leaving on stack",local_1ec);
        }
        me->objects_mixed_open = me->objects_mixed_open + -1;
      }
      else {
        if ((me->stack_overrun == '\x01') && (me->sp->tag_number != element_number)) {
          local_200 = 0;
          goto LAB_080cd7d5;
        }
        if ((element_number == 0x5b) && (me->sp->tag_number != 0x5b)) {
          local_200 = 0;
          goto LAB_080cd7d5;
        }
        if ((((me->sp->tag_number != element_number) && (tags[67].contents == SGML_EMPTY)) &&
            (((me->sp->tag_number == 0x72 ||
              (((me->sp->tag_number == 0x50 || (me->sp->tag_number == 0x4a)) ||
               (me->sp->tag_number == 0x21)))) || (me->sp->tag_number == 0x44)))) &&
           ((((element_number == 0x2f || (element_number == 0x30)) ||
             ((element_number == 0x31 || ((element_number == 0x32 || (element_number == 0x33))))))
            || (element_number == 0x34)))) {
          local_200 = 0;
          goto LAB_080cd7d5;
        }
        if (me->sp < me->stack + 799) {
          if (((int)me + (0x7f4 - (int)me->sp) >> 3) + L'' == wait_for_this_stacked_elt) {
            reached_awaited_stacked_elt = '\x01';
          }
          if (((element_number == 0x4f) && (me->sp->tag_number == 0x29)) &&
             (0 < me->objects_figged_open)) {
            if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
              if (me->sp->style->name == (char *)0x0) {
                local_1e8 = "(null)";
              }
              else {
                local_1e8 = me->sp->style->name;
              }
              iVar5 = me->objects_figged_open;
              psVar2 = me->sp;
              pFVar4 = TraceFP();
              fprintf((FILE *)pFVar4,"HTML:end_element[%d]: %s (level %d), %s - %s\n",
                      (int)me + (0x20ec - (int)psVar2) >> 3,"Special OBJECT->FIG handling",iVar5,
                      "treating as end FIG",local_1e8);
            }
            me->objects_figged_open = me->objects_figged_open + -1;
            element_number = 0x29;
          }
          me->sp = me->sp + 1;
          if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
            if (me->sp->style->name == (char *)0x0) {
              local_1e4 = "(null)";
            }
            else {
              local_1e4 = me->sp->style->name;
            }
            psVar2 = me->sp;
            pFVar4 = TraceFP();
            fprintf((FILE *)pFVar4,"HTML:end_element[%d]: Popped style off stack - %s\n",
                    (int)me + (0x20ec - (int)psVar2) >> 3,local_1e4);
          }
        }
        else if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
          pFVar4 = TraceFP();
          fprintf((FILE *)pFVar4,
                  "Stack underflow error!  Tried to pop off more styles than exist in stack\n");
        }
      }
    }
    else {
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
        if (me->sp->style->name == (char *)0x0) {
          local_1f0 = "(null)";
        }
        else {
          local_1f0 = me->sp->style->name;
        }
        iVar5 = me->skip_stack;
        pFVar4 = TraceFP();
        fprintf((FILE *)pFVar4,"HTML:end_element: Internal call (level %d), leaving on stack - %s\n"
                ,iVar5,local_1f0);
      }
      me->skip_stack = me->skip_stack + -1;
    }
  }
  if (BreakFlag == '\x01') {
    if (reached_awaited_stacked_elt != '\0') {
      wait_for_this_stacked_elt = L'\xffffffff';
    }
    local_200 = 0;
    goto LAB_080cd7d5;
  }
  if ((((me->inTEXTAREA != '\0') && (element_number != 0x69)) &&
      (BVar3 = LYBadHTML(me), BVar3 != '\0')) && (WWW_TraceFlag != '\0')) {
    pFVar4 = TraceFP();
    fprintf((FILE *)pFVar4,"Bad HTML: Missing TEXTAREA end tag\n");
  }
  if (((me->text == (HText *)0x0) && (LYMapsOnly == '\0')) && (me->style_change != '\0')) {
    actually_set_style(me);
  }
  switch(element_number) {
  case 0:
    if (me->inA != '\0') {
      me->inA = '\0';
      if (((hidden_link_marker != (char *)0x0) && (*hidden_link_marker != '\0')) &&
         (BVar3 = HText_isAnchorBlank(me->text,me->CurrentANum), BVar3 != '\0')) {
        HText_appendText(me->text,hidden_link_marker);
      }
      if (me->style_change != '\0') {
        actually_set_style(me);
      }
      if ((me->inBoldA == '\x01') && (me->inBoldH == '\0')) {
        HText_appendCharacter(me->text,L'\x06');
      }
      HText_endAnchor(me->text,me->CurrentANum);
      me->CurrentANum = 0;
      me->inBoldA = '\0';
      if ((0 < me->Underline_Level) && (me->inUnderline == '\0')) {
        HText_appendCharacter(me->text,L'\x03');
        me->inUnderline = '\x01';
      }
    }
    break;
  case 1:
  case 2:
  case 6:
  case 7:
  case 0xc:
  case 0xe:
  case 0x15:
  case 0x19:
  case 0x1e:
  case 0x20:
  case 0x25:
  case 0x3f:
  case 0x41:
  case 0x43:
  case 0x44:
  case 0x52:
  case 0x59:
  case 0x5d:
  case 0x5e:
  case 100:
  case 0x67:
  case 0x6b:
  case 0x6d:
  case 0x70:
  case 0x73:
    break;
  case 3:
  case 9:
  case 0x10:
  case 0x13:
  case 0x48:
    change_paragraph_style(me,me->sp->style);
    if (me->style_change != '\0') {
      actually_set_style(me);
    }
    if (me->sp->tag_number == element_number) {
      LYEnsureDoubleSpace(me);
    }
    if (-1 < me->List_Nesting_Level) {
      HText_NegateLineOne(me->text);
    }
    break;
  case 4:
    if (me->inAPPLETwithP == '\0') {
      HTML_put_character(me,' ');
    }
    else {
      LYEnsureDoubleSpace(me);
    }
    LYResetParagraphAlignment(me);
    me->inAPPLETwithP = '\0';
    me->inAPPLET = '\0';
    change_paragraph_style(me,me->sp->style);
    break;
  default:
    change_paragraph_style(me,me->sp->style);
    break;
  case 8:
  case 0xf:
  case 0x18:
  case 0x26:
  case 0x39:
  case 0x61:
  case 0x71:
    if (0 < me->Underline_Level) {
      me->Underline_Level = me->Underline_Level + -1;
      if ((me->inUnderline == '\0') || (0 < me->Underline_Level)) {
        if (WWW_TraceFlag != '\0') {
          iVar5 = me->Underline_Level;
          pFVar4 = TraceFP();
          fprintf((FILE *)pFVar4,"Underline Level is %d\n",iVar5);
        }
      }
      else {
        HText_appendCharacter(me->text,L'\x04');
        me->inUnderline = '\0';
        if (WWW_TraceFlag != '\0') {
          pFVar4 = TraceFP();
          fprintf((FILE *)pFVar4,"Ending underline\n");
        }
      }
    }
    break;
  case 0x11:
    if ((((me->inA != '\0') || (me->inSELECT != '\0')) || (me->inTEXTAREA != '\0')) &&
       ((BVar3 = LYBadHTML(me), BVar3 != '\0' && (WWW_TraceFlag != '\0')))) {
      if (me->inA == '\0') {
        local_1c4 = &DAT_0816522e;
      }
      else {
        local_1c4 = &DAT_08166114;
      }
      if (((me->inSELECT == '\0') && (me->inTEXTAREA == '\0')) || (me->inA == '\0')) {
        local_1c0 = &DAT_0816522e;
      }
      else {
        local_1c0 = &DAT_08166116;
      }
      if (me->inTEXTAREA == '\0') {
        local_1bc = "";
      }
      else {
        local_1bc = "TEXTAREA";
      }
      if ((me->inSELECT == '\0') || (me->inTEXTAREA == '\0')) {
        local_1b8 = &DAT_0816522e;
      }
      else {
        local_1b8 = &DAT_08166116;
      }
      if (me->inSELECT == '\0') {
        local_1b4 = "";
      }
      else {
        local_1b4 = "SELECT";
      }
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"Bad HTML: %s%s%s%s%s not closed before BODY end tag *****\n",local_1b4
              ,local_1b8,local_1bc,local_1c0,local_1c4);
    }
    break;
  case 0x12:
    change_paragraph_style(me,me->sp->style);
    break;
  case 0x16:
    LYEnsureDoubleSpace(me);
    LYResetParagraphAlignment(me);
    me->inCAPTION = '\0';
    change_paragraph_style(me,me->sp->style);
    me->inLABEL = '\0';
    break;
  case 0x17:
  case 0x22:
    if (-1 < me->Division_Level) {
      me->Division_Level = me->Division_Level + -1;
    }
    if ((-1 < me->Division_Level) &&
       (me->sp->style->alignment != me->DivisionAlignments[me->Division_Level])) {
      if (me->inP != '\0') {
        LYEnsureSingleSpace(me);
      }
      me->sp->style->alignment = me->DivisionAlignments[me->Division_Level];
    }
    change_paragraph_style(me,me->sp->style);
    if (me->style_change == '\0') {
      if (me->inP != '\0') {
        LYEnsureSingleSpace(me);
      }
    }
    else {
      actually_set_style(me);
      if (-1 < me->List_Nesting_Level) {
        HText_NegateLineOne(me->text);
      }
    }
    me->current_default_alignment = (int)me->sp->style->alignment;
    break;
  case 0x1b:
    if (me->inTABLE != '\0') {
      HText_endStblCOLGROUP(me->text);
    }
    break;
  case 0x1d:
    LYEnsureDoubleSpace(me);
    LYResetParagraphAlignment(me);
    me->inCREDIT = '\0';
    change_paragraph_style(me,me->sp->style);
    me->inLABEL = '\0';
    break;
  case 0x1f:
  case 0x58:
  case 0x60:
    HTML_put_character(me,' ');
    if (me->inUnderline == '\0') {
      HText_appendCharacter(me->text,L'\x03');
    }
    HTML_put_string(me,":DEL]");
    if (me->inUnderline == '\0') {
      HText_appendCharacter(me->text,L'\x04');
    }
    HTML_put_character(me,' ');
    me->in_word = '\0';
    break;
  case 0x28:
    LYEnsureDoubleSpace(me);
    LYResetParagraphAlignment(me);
    change_paragraph_style(me,me->sp->style);
    break;
  case 0x29:
    LYHandleFIG(me,(BOOLEAN *)0x0,(char **)0x0,'\0','\0',(char *)0x0,(char *)0x0,'\0','\0',
                &intern_flag);
    break;
  case 0x2a:
  case 0x4e:
    change_paragraph_style(me,me->sp->style);
    if (me->style_change != '\0') {
      actually_set_style(me);
    }
    if (me->sp->tag_number == element_number) {
      LYEnsureDoubleSpace(me);
    }
    if (-1 < me->List_Nesting_Level) {
      HText_NegateLineOne(me->text);
    }
    me->inLABEL = '\0';
    break;
  case 0x2b:
    me->inFONT = '\0';
    break;
  case 0x2c:
    if (((me->inFORM == '\0') && (BVar3 = LYBadHTML(me), BVar3 != '\0')) && (WWW_TraceFlag != '\0'))
    {
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"Bad HTML: Unmatched FORM end tag\n");
    }
    form_in_htext = '\0';
    if (me->inSELECT != '\0') {
      BVar3 = LYBadHTML(me);
      if ((BVar3 != '\0') && (WWW_TraceFlag != '\0')) {
        pFVar4 = TraceFP();
        fprintf((FILE *)pFVar4,"Bad HTML: Open SELECT at FORM end. Faking SELECT end tag. *****\n");
      }
      if ((me->sp->tag_number != 0x5b) && (tags[91].contents != SGML_EMPTY)) {
        me->skip_stack = me->skip_stack + 1;
      }
      HTML_end_element(me,0x5b,include);
    }
    me->inFORM = '\0';
    HText_endForm(me->text);
    if ((me->List_Nesting_Level < 0) || (me->inP != '\0')) {
      LYEnsureSingleSpace(me);
    }
    break;
  case 0x2e:
    change_paragraph_style(me,me->sp->style);
    break;
  case 0x2f:
  case 0x30:
  case 0x31:
  case 0x32:
  case 0x33:
  case 0x34:
    if (me->Division_Level < 0) {
      if ((me->sp->style->id == 0x2f) || (me->sp->style->id == 0x29)) {
        me->sp->style->alignment = 3;
      }
      else if (me->sp->style->id == 0x31) {
        me->sp->style->alignment = 2;
      }
      else {
        me->sp->style->alignment = 1;
      }
    }
    else {
      me->sp->style->alignment = me->DivisionAlignments[me->Division_Level];
    }
    change_paragraph_style(me,me->sp->style);
    if (me->style_change != '\0') {
      actually_set_style(me);
    }
    if ((styles[element_number]->font & 2U) != 0) {
      if ((me->inBoldA == '\0') && (me->inBoldH == '\x01')) {
        HText_appendCharacter(me->text,L'\x06');
      }
      me->inBoldH = '\0';
    }
    if (-1 < me->List_Nesting_Level) {
      HText_NegateLineOne(me->text);
    }
    if ((0 < me->Underline_Level) && (me->inUnderline == '\0')) {
      HText_appendCharacter(me->text,L'\x03');
      me->inUnderline = '\x01';
    }
    break;
  case 0x35:
    if ((me->inBASE != '\0') &&
       ((BVar3 = LYIsUIPage3(me->node_anchor->address,UIP_LIST_PAGE,L'\0'), BVar3 != '\0' ||
        (BVar3 = LYIsUIPage3(me->node_anchor->address,UIP_ADDRLIST_PAGE,L'\0'), BVar3 != '\0')))) {
      HTSACopy(&me->node_anchor->content_base,me->base_href);
    }
    BVar3 = HText_hasToolbar(me->text);
    if (BVar3 != '\0') {
      HText_appendParagraph(me->text);
    }
    break;
  case 0x37:
    if ((((me->inA != '\0') || (me->inSELECT != '\0')) || (me->inTEXTAREA != '\0')) &&
       ((BVar3 = LYBadHTML(me), BVar3 != '\0' && (WWW_TraceFlag != '\0')))) {
      if (me->inA == '\0') {
        local_1e0 = &DAT_0816522e;
      }
      else {
        local_1e0 = &DAT_08166114;
      }
      if (((me->inSELECT == '\0') && (me->inTEXTAREA == '\0')) || (me->inA == '\0')) {
        local_1dc = &DAT_0816522e;
      }
      else {
        local_1dc = &DAT_08166116;
      }
      if (me->inTEXTAREA == '\0') {
        local_1d8 = "";
      }
      else {
        local_1d8 = "TEXTAREA";
      }
      if ((me->inSELECT == '\0') || (me->inTEXTAREA == '\0')) {
        local_1d4 = &DAT_0816522e;
      }
      else {
        local_1d4 = &DAT_08166116;
      }
      if (me->inSELECT == '\0') {
        local_1d0 = "";
      }
      else {
        local_1d0 = "SELECT";
      }
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"Bad HTML: %s%s%s%s%s not closed before HTML end tag *****\n",local_1d0
              ,local_1d4,local_1d8,local_1dc,local_1e0);
    }
    break;
  case 0x3a:
  case 0x4d:
    LYEnsureDoubleSpace(me);
    LYResetParagraphAlignment(me);
    change_paragraph_style(me,me->sp->style);
    break;
  case 0x3d:
    HTML_put_character(me,' ');
    if (me->inUnderline == '\0') {
      HText_appendCharacter(me->text,L'\x03');
    }
    HTML_put_string(me,":INS]");
    if (me->inUnderline == '\0') {
      HText_appendCharacter(me->text,L'\x04');
    }
    HTML_put_character(me,' ');
    me->in_word = '\0';
    break;
  case 0x42:
    LYEnsureDoubleSpace(me);
    LYResetParagraphAlignment(me);
    change_paragraph_style(me,me->sp->style);
    break;
  case 0x47:
    if (me->map_address != (char *)0x0) {
      free(me->map_address);
      me->map_address = (char *)0x0;
    }
    break;
  case 0x49:
    HTChunkPutc(&me->math,' ');
    HTChunkTerminate(&me->math);
    if (2 < (me->math).size) {
      LYEnsureSingleSpace(me);
      if (me->inUnderline == '\0') {
        HText_appendCharacter(me->text,L'\x03');
      }
      HTML_put_string(me,"[MATH:");
      HText_appendCharacter(me->text,L'\x04');
      HTML_put_character(me,' ');
      HTML_put_string(me,(me->math).data);
      HText_appendCharacter(me->text,L'\x03');
      HTML_put_string(me,":MATH]");
      if (me->inUnderline == '\0') {
        HText_appendCharacter(me->text,L'\x04');
      }
      LYEnsureSingleSpace(me);
    }
    HTChunkClear(&me->math);
    break;
  case 0x4f:
    s = 0;
    e = 0;
    start = (char *)0x0;
    first_end = (char *)0x0;
    last_end = (char *)0x0;
    first_map = (char *)0x0;
    last_map = (char *)0x0;
    have_param = '\0';
    data = (char *)0x0;
    HTChunkTerminate(&me->object);
    data = (me->object).data;
    while (cp = strchr(data,0x3c), cp != (char *)0x0) {
      iVar5 = strncmp(cp,"<!--",4);
      if (iVar5 == 0) {
        cp = LYFindEndOfComment(cp);
      }
      else if ((((((s == 0) && (iVar5 = strncasecomp(cp,"<PARAM",6), iVar5 == 0)) &&
                 (ppuVar7 = __ctype_b_loc(), ((*ppuVar7)[(byte)cp[6]] & 8) == 0)) &&
                ((cp[6] != '_' && (cp[6] != '-')))) && (cp[6] != '.')) && (cp[6] != ':')) {
        have_param = '\x01';
      }
      else {
        iVar5 = strncasecomp(cp,"<OBJECT",7);
        if (((iVar5 == 0) && (ppuVar7 = __ctype_b_loc(), ((*ppuVar7)[(byte)cp[7]] & 8) == 0)) &&
           ((cp[7] != '_' && (((cp[7] != '-' && (cp[7] != '.')) && (cp[7] != ':')))))) {
          if (s == 0) {
            start = cp;
          }
          s = s + 1;
        }
        else {
          iVar5 = strncasecomp(cp,"</OBJECT",8);
          if (((iVar5 == 0) && (ppuVar7 = __ctype_b_loc(), ((*ppuVar7)[(byte)cp[8]] & 8) == 0)) &&
             ((cp[8] != '_' && (((cp[8] != '-' && (cp[8] != '.')) && (cp[8] != ':')))))) {
            if (e == 0) {
              first_end = cp;
            }
            last_end = cp;
            e = e + 1;
          }
          else {
            iVar5 = strncasecomp(cp,"<MAP",4);
            if (((((iVar5 == 0) && (ppuVar7 = __ctype_b_loc(), ((*ppuVar7)[(byte)cp[4]] & 8) == 0))
                 && (cp[4] != '_')) && ((cp[4] != '-' && (cp[4] != '.')))) && (cp[4] != ':')) {
              if (first_map == (char *)0x0) {
                first_map = cp;
              }
              last_map = cp;
            }
            else {
              iVar5 = strncasecomp(cp,"</MAP",5);
              if (((iVar5 == 0) && (ppuVar7 = __ctype_b_loc(), ((*ppuVar7)[(byte)cp[5]] & 8) == 0))
                 && ((cp[5] != '_' && (((cp[5] != '-' && (cp[5] != '.')) && (cp[5] != ':')))))) {
                last_map = cp;
              }
            }
          }
        }
      }
      data = cp + 1;
      cp = data;
    }
    if (s < e) {
      BVar3 = LYBadHTML(me);
      if ((BVar3 != '\0') && (WWW_TraceFlag != '\0')) {
        pcVar6 = (me->object).data;
        pFVar4 = TraceFP();
        fprintf((FILE *)pFVar4,
                "Bad HTML: Unmatched OBJECT start and end tags.  Discarding content:\n%s\n",pcVar6);
      }
    }
    else {
      if (e < s) {
        if (((((me->object_declare == '\0') && (me->object_name == (char *)0x0)) &&
             ((me->object_shapes == '\0' || (LYMapsOnly != '\0')))) &&
            ((me->object_usemap == (char *)0x0 || (LYMapsOnly != '\0')))) &&
           ((clickable_images == '\0' ||
            (((((LYMapsOnly != '\0' || (me->object_data == (char *)0x0)) || (have_param != '\0')) ||
              ((me->object_classid != (char *)0x0 || (me->object_codebase != (char *)0x0)))) ||
             (me->object_codetype != (char *)0x0)))))) {
          if (WWW_TraceFlag != '\0') {
            pcVar6 = (me->object).data;
            pFVar4 = TraceFP();
            fprintf((FILE *)pFVar4,"%s:\n%s\n",
                    "HTML: Nested OBJECT tags.  Recycling incomplete contents",pcVar6);
          }
          status = 0x2bd;
          (me->object).size = (me->object).size + -1;
          HTChunkPuts(&me->object,"</OBJECT>");
          if (include == (char **)0x0) {
            include_local = &me->xinclude;
          }
          SNACat(include_local,(me->object).data,(me->object).size);
          clear_objectdata(me);
          HTML_start_element(me,0x4f,(BOOLEAN *)0x0,(char **)0x0,me->tag_charset,include_local);
        }
        else {
          if (WWW_TraceFlag != '\0') {
            pFVar4 = TraceFP();
            fprintf((FILE *)pFVar4,"HTML: Nested OBJECT tags.  Recycling.\n");
          }
          status = 700;
          (me->object).size = (me->object).size + -1;
          HTChunkPuts(&me->object,"</OBJECT>");
          if (LYMapsOnly == '\0') {
            change_paragraph_style(me,me->sp->style);
          }
        }
        break;
      }
      if (WWW_TraceFlag != '\0') {
        pcVar6 = (me->object).data;
        pFVar4 = TraceFP();
        fprintf((FILE *)pFVar4,"HTML:OBJECT content:\n%s\n",pcVar6);
      }
      if (me->object_declare == '\x01') {
        if (((me->object_id != (char *)0x0) && (*me->object_id != '\0')) && (LYMapsOnly == '\0')) {
          LYHandleID(me,me->object_id);
        }
        if (WWW_TraceFlag != '\0') {
          pFVar4 = TraceFP();
          fprintf((FILE *)pFVar4,"HTML: DECLAREd OBJECT.  Ignoring!\n");
        }
      }
      else if ((me->object_name == (char *)0x0) || (LYMapsOnly != '\0')) {
        if (s < 1) {
LAB_080cb916:
          if ((me->object_shapes == '\x01') && (LYMapsOnly == '\0')) {
            if (WWW_TraceFlag != '\0') {
              pFVar4 = TraceFP();
              fprintf((FILE *)pFVar4,"HTML: OBJECT has SHAPES.  Converting to FIG.\n");
            }
            if (include == (char **)0x0) {
              include_local = &me->xinclude;
            }
            HTSACat(include_local,"<FIG ISOBJECT IMAGEMAP");
            if (me->object_ismap == '\x01') {
              HTSACat(include_local," IMAGEMAP");
            }
            if (me->object_id != (char *)0x0) {
              HTSACat(include_local," ID=\"");
              HTSACat(include_local,me->object_id);
              HTSACat(include_local,"\"");
            }
            if ((me->object_data != (char *)0x0) && (me->object_classid == (char *)0x0)) {
              HTSACat(include_local," SRC=\"");
              HTSACat(include_local,me->object_data);
              HTSACat(include_local,"\"");
            }
            HTSACat(include_local,">");
            (me->object).size = (me->object).size + -1;
            HTChunkPuts(&me->object,"</FIG>");
            HTChunkTerminate(&me->object);
            HTSACat(include_local,(me->object).data);
          }
          else if ((me->object_usemap == (char *)0x0) || (LYMapsOnly != '\0')) {
            if (((me->object_id != (char *)0x0) && (*me->object_id != '\0')) && (LYMapsOnly == '\0')
               ) {
              LYHandleID(me,me->object_id);
            }
            if (1 < (me->object).size) {
              if (include == (char **)0x0) {
                include_local = &me->xinclude;
              }
              HTSACat(include_local,(me->object).data);
            }
            if ((((clickable_images != '\0') && (LYMapsOnly == '\0')) &&
                ((me->object_data != (char *)0x0 &&
                 ((have_param == '\0' && (me->object_classid == (char *)0x0)))))) &&
               ((me->object_codebase == (char *)0x0 && (me->object_codetype == (char *)0x0)))) {
              if (include_local == (char **)0x0) {
                include_local = &me->xinclude;
              }
              if (me->inA != '\0') {
                HTSACat(include_local,"</A>");
              }
              HTSACat(include_local," -<A HREF=\"");
              HTSACat(include_local,me->object_data);
              HTSACat(include_local,"\">");
              if ((me->object_type == (char *)0x0) ||
                 (iVar5 = strncasecomp(me->object_type,"image/",6), iVar5 != 0)) {
                HTSACat(include_local,"(OBJECT)");
              }
              else {
                HTSACat(include_local,"(IMAGE)");
              }
              HTSACat(include_local,"</A> ");
            }
          }
          else {
            if (WWW_TraceFlag != '\0') {
              pFVar4 = TraceFP();
              fprintf((FILE *)pFVar4,"HTML: OBJECT has USEMAP.  Converting to IMG.\n");
            }
            if (include == (char **)0x0) {
              include_local = &me->xinclude;
            }
            HTSACat(include_local,"<IMG ISOBJECT");
            if (me->object_id != (char *)0x0) {
              HTSACat(include_local," ID=\"");
              HTSACat(include_local,me->object_id);
              HTSACat(include_local,"\"");
            }
            if ((me->object_data != (char *)0x0) && (me->object_classid == (char *)0x0)) {
              HTSACat(include_local," SRC=\"");
              HTSACat(include_local,me->object_data);
              HTSACat(include_local,"\"");
            }
            if (me->object_title != (char *)0x0) {
              HTSACat(include_local," TITLE=\"");
              HTSACat(include_local,me->object_title);
              HTSACat(include_local,"\" ALT=\"");
              HTSACat(include_local,me->object_title);
              HTSACat(include_local,"\"");
            }
            if (me->object_usemap == (char *)0x0) {
              HTSACat(include_local,">");
            }
            else {
              HTSACat(include_local," USEMAP=\"");
              HTSACat(include_local,me->object_usemap);
              if (me->object_ismap == '\x01') {
                HTSACat(include_local,"\" ISMAP>");
              }
              else {
                HTSACat(include_local,"\">");
              }
            }
            if (first_map != (char *)0x0) {
              if (s == 0) {
                HTSACat(include_local,(me->object).data);
                if (WWW_TraceFlag != '\0') {
                  pFVar4 = TraceFP();
                  fprintf((FILE *)pFVar4,"HTML: MAP found, recycling object contents.\n");
                }
              }
              else {
                data = (char *)0x0;
                if (last_map < start) {
                  *start = '\0';
                  i = 0;
                }
                else if (last_map < first_end) {
                  *first_end = '\0';
                  i = e;
                }
                else if (last_map < last_end) {
                  *last_end = '\0';
                  i = 1;
                }
                else {
                  i = 0;
                }
                if (last_end < first_map) {
                  HTSACopy(&data,"<OBJECT><");
                  HTSACat(&data,last_end + 1);
                  i = 0;
                }
                else if (start < first_map) {
                  HTSACopy(&data,start);
                }
                else {
                  HTSACopy(&data,(me->object).data);
                }
                for (; pcVar6 = data, 0 < i; i = i + -1) {
                  HTSACat(&data,"</OBJECT>");
                }
                if (WWW_TraceFlag != '\0') {
                  pFVar4 = TraceFP();
                  fprintf((FILE *)pFVar4,"%s:\n%s\n",
                          "HTML: MAP and nested OBJECT tags.  Recycling parts",pcVar6);
                }
                HTSACat(include_local,data);
                if (data != (char *)0x0) {
                  free(data);
                  data = (char *)0x0;
                }
              }
            }
          }
        }
        else if (((start == (char *)0x0) || (first_end == (char *)0x0)) || (first_end <= start)) {
          BVar3 = LYBadHTML(me);
          if ((BVar3 != '\0') && (WWW_TraceFlag != '\0')) {
            pFVar4 = TraceFP();
            fprintf((FILE *)pFVar4,
                    "Bad HTML: Unmatched OBJECT start and end tags.  Discarding content.\n");
          }
        }
        else {
          if (LYMapsOnly == '\0') goto LAB_080cb916;
          if ((LYMapsOnly == '\0') || ((last_map != (char *)0x0 && (first_end <= last_map)))) {
            e = 0;
          }
          else {
            *first_end = '\0';
          }
          data = (char *)0x0;
          if ((LYMapsOnly == '\0') || ((first_map != (char *)0x0 && (first_map <= start)))) {
            HTSACopy(&data,(me->object).data);
          }
          else {
            HTSACopy(&data,start);
          }
          if (0 < e) {
            for (i = e; 0 < i; i = i + -1) {
              HTSACat(&data,"</OBJECT>");
            }
          }
          if (include == (char **)0x0) {
            include_local = &me->xinclude;
          }
          HTSACat(include_local,data);
          if (WWW_TraceFlag != '\0') {
            if (s < 2) {
              local_1ac = &DAT_0816522e;
            }
            else {
              local_1ac = &DAT_081663cc;
            }
            pFVar4 = TraceFP();
            fprintf((FILE *)pFVar4,"HTML: Recycling nested OBJECT%s.\n",local_1ac);
          }
          if (data != (char *)0x0) {
            free(data);
            data = (char *)0x0;
          }
        }
      }
      else {
        if ((me->object_id != (char *)0x0) && (*me->object_id != '\0')) {
          LYHandleID(me,me->object_id);
        }
        if (WWW_TraceFlag != '\0') {
          pFVar4 = TraceFP();
          fprintf((FILE *)pFVar4,"HTML: NAMEd OBJECT.  Ignoring!\n");
        }
      }
    }
    clear_objectdata(me);
    if (LYMapsOnly == '\0') {
      change_paragraph_style(me,me->sp->style);
    }
    break;
  case 0x50:
    local_1b0 = me->List_Nesting_Level;
    if (0xb < local_1b0) {
      local_1b0 = 0xb;
    }
    me->OL_Counter[local_1b0] = OL_VOID;
  case 0x21:
  case 0x23:
  case 0x4a:
  case 0x72:
    me->List_Nesting_Level = me->List_Nesting_Level + -1;
    if (WWW_TraceFlag != '\0') {
      iVar5 = me->List_Nesting_Level;
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTML_end_element: Reducing List Nesting Level to %d\n",iVar5);
    }
    if (element_number == 0x23) {
      in_DT = '\0';
    }
    change_paragraph_style(me,me->sp->style);
    if (me->style_change != '\0') {
      actually_set_style(me);
    }
    if (-1 < me->List_Nesting_Level) {
      LYEnsureSingleSpace(me);
    }
    break;
  case 0x53:
    LYHandlePlike(me,(BOOLEAN *)0x0,(char **)0x0,include,0,'\0');
    break;
  case 0x56:
    HText_appendCharacter(me->text,L'\n');
    me->inPRE = '\0';
  case 0x46:
  case 0x55:
  case 0x75:
    if (me->comment_start != (char *)0x0) {
      HText_appendText(me->text,me->comment_start);
    }
    change_paragraph_style(me,me->sp->style);
    if (-1 < me->List_Nesting_Level) {
      if (me->style_change != '\0') {
        actually_set_style(me);
      }
      HText_NegateLineOne(me->text);
    }
    break;
  case 0x57:
    if (0 < me->Quote_Level) {
      me->Quote_Level = me->Quote_Level + -1;
    }
    if ((me->Quote_Level & 1U) == 0) {
      HTML_put_character(me,'\"');
    }
    else {
      HTML_put_character(me,'\'');
    }
    break;
  case 0x5a:
    HTChunkTerminate(&me->script);
    if (WWW_TraceFlag != '\0') {
      pcVar6 = (me->script).data;
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTML: SCRIPT content =\n%s\n",pcVar6);
    }
    HTChunkClear(&me->script);
    break;
  case 0x5b:
    if (me->inSELECT == '\0') {
      BVar3 = LYBadHTML(me);
      if ((BVar3 != '\0') && (WWW_TraceFlag != '\0')) {
        pFVar4 = TraceFP();
        fprintf((FILE *)pFVar4,"Bad HTML: Unmatched SELECT end tag *****\n");
      }
    }
    else {
      me->inSELECT = '\0';
      me->select_disabled = '\0';
      if (((me->inFORM == '\0') && (BVar3 = LYBadHTML(me), BVar3 != '\0')) &&
         (WWW_TraceFlag != '\0')) {
        pFVar4 = TraceFP();
        fprintf((FILE *)pFVar4,"Bad HTML: SELECT end tag not within FORM element *****\n");
      }
      HTChunkTerminate(&me->option);
      ptr = HText_setLastOptionValue
                      (me->text,(me->option).data,me->LastOptionValue,L'\x03',me->LastOptionChecked,
                       me->UCLYhndl,me->tag_charset);
      if (me->LastOptionValue != (char *)0x0) {
        free(me->LastOptionValue);
        me->LastOptionValue = (char *)0x0;
      }
      me->LastOptionChecked = '\0';
      if ((HTCurSelectGroupType == L'\x03') || (LYSelectPopups == '\0')) {
        LYEnsureSingleSpace(me);
      }
      else {
        if (((ptr != (char *)0x0) &&
            (((me->sp->tag_number == 0x56 || (me->inPRE == '\x01')) ||
             (me->sp->style->freeFormat == '\0')))) && (sVar8 = strlen(ptr), 6 < sVar8)) {
          for (i = 0; i < 6; i = i + 1) {
            if (*ptr == ' ') {
              HText_appendCharacter(me->text,L'\x01');
            }
            else {
              HText_appendCharacter(me->text,(int)*ptr);
            }
            ptr = ptr + 1;
          }
          HText_setIgnoreExcess(me->text,'\x01');
        }
        for (; (ptr != (char *)0x0 && (*ptr != '\0')); ptr = ptr + 1) {
          if (*ptr == ' ') {
            HText_appendCharacter(me->text,L'\x01');
          }
          else {
            kcode = NOKANJI;
            specified_kcode = NOKANJI;
            if (HTCJK == JAPANESE) {
              kcode = HText_getKcode(me->text);
              HText_updateKcode(me->text,kanji_code);
              specified_kcode = HText_getSpecifiedKcode(me->text);
              HText_updateSpecifiedKcode(me->text,kanji_code);
            }
            HText_appendCharacter(me->text,(int)*ptr);
            if (HTCJK == JAPANESE) {
              HText_updateKcode(me->text,kcode);
              HText_updateSpecifiedKcode(me->text,specified_kcode);
            }
          }
        }
        if (me->first_option == '\0') {
          HText_appendCharacter(me->text,L']');
          HText_endInput(me->text);
          HText_setLastChar(me->text,']');
          me->in_word = '\x01';
        }
        HText_setIgnoreExcess(me->text,'\0');
      }
      HTChunkClear(&me->option);
      if ((0 < me->Underline_Level) && (me->inUnderline == '\0')) {
        HText_appendCharacter(me->text,L'\x03');
        me->inUnderline = '\x01';
      }
      if ((me->needBoldH == '\x01') && (me->inBoldH == '\0')) {
        HText_appendCharacter(me->text,L'\x05');
        me->inBoldH = '\x01';
        me->needBoldH = '\0';
      }
    }
    break;
  case 0x62:
    HTChunkTerminate(&me->style_block);
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
      pcVar6 = (me->style_block).data;
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTML: STYLE content =\n%s\n",pcVar6);
    }
    HTChunkClear(&me->style_block);
    break;
  case 99:
    HText_appendCharacter(me->text,L']');
    break;
  case 0x66:
    if (nested_tables == '\0') {
      me->inTABLE = '\0';
    }
    if (me->sp->style->id != 0x25) {
      if (-1 < me->Division_Level) {
        me->Division_Level = me->Division_Level + -1;
      }
      if (-1 < me->Division_Level) {
        me->sp->style->alignment = me->DivisionAlignments[me->Division_Level];
      }
      change_paragraph_style(me,me->sp->style);
      if (me->style_change != '\0') {
        actually_set_style(me);
      }
      if (nested_tables == '\0') {
        HText_endStblTABLE(me->text);
      }
      else {
        wVar9 = HText_endStblTABLE(me->text);
        me->inTABLE = (BOOLEAN)wVar9;
      }
      me->current_default_alignment = (int)me->sp->style->alignment;
      if (-1 < me->List_Nesting_Level) {
        HText_NegateLineOne(me->text);
      }
    }
    break;
  case 0x68:
  case 0x6c:
    HText_endStblTD(me->text);
    break;
  case 0x69:
    if (me->inTEXTAREA == '\0') {
      BVar3 = LYBadHTML(me);
      if ((BVar3 != '\0') && (WWW_TraceFlag != '\0')) {
        pFVar4 = TraceFP();
        fprintf((FILE *)pFVar4,"Bad HTML: Unmatched TEXTAREA end tag\n");
      }
    }
    else {
      me->inTEXTAREA = '\0';
      memset(&I,0,0x58);
      I.value_cs = current_char_set;
      if (me->style_change != '\0') {
        actually_set_style(me);
      }
      HTML_put_character(me,' ');
      me->in_word = '\0';
      HText_appendCharacter(me->text,L'\r');
      HTChunkTerminate(&me->textarea);
      if (temp != (char *)0x0) {
        free(temp);
        temp = (char *)0x0;
      }
      I.type = "textarea";
      I.size = me->textarea_cols;
      I.name = me->textarea_name;
      I.name_cs = me->textarea_name_cs;
      I.accept_cs = me->textarea_accept_cs;
      me->textarea_accept_cs = (char *)0x0;
      I.disabled = me->textarea_disabled;
      I.id = me->textarea_id;
      me->UsePlainSpace = '\x01';
      if (tags[element_number].contents == SGML_LITTERAL) {
        LYUCTranslateHTMLString
                  (&(me->textarea).data,me->UCLYhndl,current_char_set,'\0',me->UsePlainSpace,
                   me->HiddenValue,st_HTML);
      }
      else {
        LYUCFullyTranslateString
                  (&(me->textarea).data,me->UCLYhndl,current_char_set,'\0','\0',me->UsePlainSpace,
                   me->HiddenValue,'\0',st_HTML);
      }
      data_1 = (me->textarea).data;
      if (*data_1 != '\0') {
        sVar8 = strlen(data_1);
        for (cp = data_1 + (sVar8 - 1); (data_1 <= cp && (*cp == '\n')); cp = cp + -1) {
          *cp = '\0';
        }
        for (; *data_1 == '\n'; data_1 = data_1 + 1) {
        }
      }
      cp = strchr(data_1,10);
      if (cp == (char *)0x0) {
        if (*data_1 == '\0') {
          if (temp != (char *)0x0) {
            free(temp);
            temp = (char *)0x0;
          }
        }
        else {
          HTSACopy(&temp,data_1);
        }
        data_1 = "";
      }
      else {
        *cp = '\0';
        HTSACopy(&temp,data_1);
        *cp = '\n';
        data_1 = cp + 1;
      }
      for (i = 0; i < me->textarea_rows; i = i + 1) {
        for (j = 0; (temp != (char *)0x0 && (temp[j] != '\0')); j = j + 1) {
          if (temp[j] == '\r') {
            if (temp[j + 1] == '\0') {
              local_1a1 = '\0';
            }
            else {
              local_1a1 = ' ';
            }
            temp[j] = local_1a1;
          }
        }
        I.value = temp;
        for (chars = HText_beginInput(me->text,me->inUnderline,(InputFieldData *)&I); 0 < chars;
            chars = chars + -1) {
          HTML_put_character(me,'_');
        }
        HText_appendCharacter(me->text,L'\r');
        if (*data_1 == '\0') {
          if (temp != (char *)0x0) {
            free(temp);
            temp = (char *)0x0;
          }
        }
        else if (*data_1 == '\n') {
          if (temp != (char *)0x0) {
            free(temp);
            temp = (char *)0x0;
          }
          data_1 = data_1 + 1;
        }
        else {
          cp = strchr(data_1,10);
          if (cp == (char *)0x0) {
            HTSACopy(&temp,data_1);
            data_1 = "";
          }
          else {
            *cp = '\0';
            HTSACopy(&temp,data_1);
            *cp = '\n';
            data_1 = cp + 1;
          }
        }
      }
      while ((*data_1 != '\0' || (temp != (char *)0x0))) {
        for (j_1 = 0; (temp != (char *)0x0 && (temp[j_1] != '\0')); j_1 = j_1 + 1) {
          if (temp[j_1] == '\r') {
            if (temp[j_1 + 1] == '\0') {
              local_199 = '\0';
            }
            else {
              local_199 = ' ';
            }
            temp[j_1] = local_199;
          }
        }
        I.value = temp;
        HText_beginInput(me->text,me->inUnderline,(InputFieldData *)&I);
        for (chars = me->textarea_cols; 0 < chars; chars = chars + -1) {
          HTML_put_character(me,'_');
        }
        HText_appendCharacter(me->text,L'\r');
        if (*data_1 == '\n') {
          if (temp != (char *)0x0) {
            free(temp);
            temp = (char *)0x0;
          }
          data_1 = data_1 + 1;
        }
        else {
          cp = strchr(data_1,10);
          if (cp == (char *)0x0) {
            if (*data_1 == '\0') {
              if (temp != (char *)0x0) {
                free(temp);
                temp = (char *)0x0;
              }
            }
            else {
              HTSACopy(&temp,data_1);
              data_1 = "";
            }
          }
          else {
            *cp = '\0';
            HTSACopy(&temp,data_1);
            *cp = '\n';
            data_1 = cp + 1;
          }
        }
      }
      cp = (char *)0x0;
      me->UsePlainSpace = '\0';
      HTChunkClear(&me->textarea);
      if (me->textarea_name != (char *)0x0) {
        free(me->textarea_name);
        me->textarea_name = (char *)0x0;
      }
      me->textarea_name_cs = -1;
      if (me->textarea_id != (char *)0x0) {
        free(me->textarea_id);
        me->textarea_id = (char *)0x0;
      }
    }
    break;
  case 0x6a:
    change_paragraph_style(me,me->sp->style);
    break;
  case 0x6e:
    HTChunkTerminate(&me->title);
    HTAnchor_setTitle(me->node_anchor,(me->title).data);
    HTChunkClear(&me->title);
    if (((me->node_anchor->bookmark != (char *)0x0) && (*me->node_anchor->bookmark != '\0')) &&
       ((LYMultiBookmarks != 0 ||
        (((bookmark_page != (char *)0x0 && (*bookmark_page != '\0')) &&
         (iVar5 = strcmp(me->node_anchor->bookmark,bookmark_page), iVar5 != 0)))))) {
      if (include == (char **)0x0) {
        include_local = &me->xinclude;
      }
      for (i = 0; i < 0x1a; i = i + 1) {
        if ((MBM_A_subbookmark[i] != (char *)0x0) &&
           (iVar5 = strcmp(MBM_A_subbookmark[i],me->node_anchor->bookmark), iVar5 == 0)) {
          HTSACat(include_local,"<H2><EM>");
          pcVar6 = (char *)gettext("Description:");
          HTSACat(include_local,pcVar6);
          HTSACat(include_local,"</EM> ");
          if ((MBM_A_subdescript[i] == (char *)0x0) || (*MBM_A_subdescript[i] == '\0')) {
            local_1cc = (char *)gettext("(none)");
          }
          else {
            local_1cc = MBM_A_subdescript[i];
          }
          HTSACopy(&temp,local_1cc);
          LYEntify(&temp,'\x01');
          HTSACat(include_local,temp);
          HTSACat(include_local,"<BR><EM>&nbsp;&nbsp;&nbsp;");
          pcVar6 = (char *)gettext("Filepath:");
          HTSACat(include_local,pcVar6);
          HTSACat(include_local,"</EM> ");
          if ((MBM_A_subbookmark[i] == (char *)0x0) || (*MBM_A_subbookmark[i] == '\0')) {
            local_1c8 = (char *)gettext("(unknown)");
          }
          else {
            local_1c8 = MBM_A_subbookmark[i];
          }
          HTSACopy(&temp,local_1c8);
          LYEntify(&temp,'\x01');
          HTSACat(include_local,temp);
          if (temp != (char *)0x0) {
            free(temp);
            temp = (char *)0x0;
          }
          HTSACat(include_local,"</H2>");
          break;
        }
      }
    }
    break;
  case 0x6f:
    HText_endStblTR(me->text);
    BVar3 = HText_LastLineEmpty(me->text,'\0');
    if (BVar3 == '\0') {
      HText_setLastChar(me->text,' ');
      HText_appendCharacter(me->text,L'\r');
    }
    me->in_word = '\0';
  }
  if (reached_awaited_stacked_elt != '\0') {
    wait_for_this_stacked_elt = L'\xffffffff';
  }
  if (me->xinclude != (char *)0x0) {
    HText_appendText(me->text," *** LYNX ERROR ***\rUnparsed data:\r");
    HText_appendText(me->text,me->xinclude);
    if (me->xinclude != (char *)0x0) {
      free(me->xinclude);
      me->xinclude = (char *)0x0;
    }
  }
  if ((skip_stack_requested == '\0') &&
     ((FastTrimColorClass(tags[element_number].name,tags[element_number].name_len,Style_className,
                          &Style_className_end,&hcode), tags[element_number].contents != SGML_EMPTY
      || ((tags[element_number].flags & 0x10U) != 0)))) {
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
      pcVar6 = tags[element_number].name;
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"STYLE.end_element: ending non-\"EMPTY\" style <%s...>\n",pcVar6);
    }
    _internal_HTC(me->text,hcode,L'\0');
  }
  local_200 = status;
LAB_080cd7d5:
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return local_200;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

int HTML_put_entity(HTStructured *me,int entity_number)

{
  int local_18;
  int nent;
  
  if (entity_number < (int)0x70) {
    HTML_put_string(me,p_entity_values[entity_number]);
    local_18 = 0;
  }
  else {
    local_18 = -4;
  }
  return local_18;
}



// WARNING: Unknown calling convention

void HTML_free(HTStructured *me)

{
  BOOLEAN BVar1;
  FILE *pFVar2;
  wchar_t wVar3;
  char *pcVar4;
  char *include;
  
  include = (char *)0x0;
  if ((LYMapsOnly == '\0') || (me->text != (HText *)0x0)) {
    if (me->style_change != '\0') {
      actually_set_style(me);
    }
    if (me->comment_end != (char *)0x0) {
      HTML_put_string(me,me->comment_end);
    }
    if (me->text != (HText *)0x0) {
      if (me->inUnderline != '\0') {
        HText_appendCharacter(me->text,L'\x04');
        me->inUnderline = '\0';
        me->Underline_Level = 0;
        if (WWW_TraceFlag != '\0') {
          pFVar2 = TraceFP();
          fprintf((FILE *)pFVar2,"HTML_free: Ending underline\n");
        }
      }
      if (me->inA != '\0') {
        HTML_end_element(me,0,&include);
        me->inA = '\0';
        if (WWW_TraceFlag != '\0') {
          pFVar2 = TraceFP();
          fprintf((FILE *)pFVar2,"HTML_free: Ending HTML_A\n");
        }
      }
      if (me->inFONT != '\0') {
        HTML_end_element(me,0x2b,&include);
        me->inFONT = '\0';
      }
      if (me->inFORM != '\0') {
        HTML_end_element(me,0x2c,&include);
        me->inFORM = '\0';
      }
      if (0 < (me->option).size) {
        BVar1 = LYBadHTML(me);
        if ((BVar1 != '\0') && (WWW_TraceFlag != '\0')) {
          pFVar2 = TraceFP();
          fprintf((FILE *)pFVar2,"Bad HTML: SELECT or OPTION not ended properly *****\n");
        }
        HTChunkTerminate(&me->option);
        if (WWW_TraceFlag != '\0') {
          pcVar4 = (me->option).data;
          pFVar2 = TraceFP();
          fprintf((FILE *)pFVar2,"HTML_free: ***** leftover option data: %s\n",pcVar4);
        }
        HTML_put_string(me,(me->option).data);
        HTChunkClear(&me->option);
      }
      if (0 < (me->textarea).size) {
        BVar1 = LYBadHTML(me);
        if ((BVar1 != '\0') && (WWW_TraceFlag != '\0')) {
          pFVar2 = TraceFP();
          fprintf((FILE *)pFVar2,"Bad HTML: TEXTAREA not used properly *****\n");
        }
        HTChunkTerminate(&me->textarea);
        if (WWW_TraceFlag != '\0') {
          pcVar4 = (me->textarea).data;
          pFVar2 = TraceFP();
          fprintf((FILE *)pFVar2,"HTML_free: ***** leftover textarea data: %s\n",pcVar4);
        }
        HTML_put_string(me,(me->textarea).data);
        HTChunkClear(&me->textarea);
      }
      if (dump_output_immediately == '\0') {
        wVar3 = HText_sourceAnchors(me->text);
        if (wVar3 < L'\x01') {
          wVar3 = HText_HiddenLinkCount(me->text);
          if (L'\0' < wVar3) {
            HTML_start_element(me,0x53,(BOOLEAN *)0x0,(char **)0x0,-1,&include);
            HTML_put_character(me,'[');
            HTML_start_element(me,0x26,(BOOLEAN *)0x0,(char **)0x0,-1,&include);
            pcVar4 = (char *)gettext("Document has only hidden links.  Use the \'l\'ist command.");
            HTML_put_string(me,pcVar4);
            HTML_end_element(me,0x26,&include);
            HTML_put_character(me,']');
            HTML_end_element(me,0x53,&include);
          }
        }
      }
      if (me->xinclude != (char *)0x0) {
        HText_appendText(me->text," *** LYNX ERROR ***\rUnparsed data:\r");
        HText_appendText(me->text,me->xinclude);
        if (me->xinclude != (char *)0x0) {
          free(me->xinclude);
          me->xinclude = (char *)0x0;
        }
      }
      HText_endAppend(me->text);
    }
    if (0 < (me->option).size) {
      BVar1 = LYBadHTML(me);
      if ((BVar1 != '\0') && (WWW_TraceFlag != '\0')) {
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2,"Bad HTML: SELECT or OPTION not ended properly *****\n");
      }
      if (WWW_TraceFlag != '\0') {
        HTChunkTerminate(&me->option);
        if (WWW_TraceFlag != '\0') {
          pcVar4 = (me->option).data;
          pFVar2 = TraceFP();
          fprintf((FILE *)pFVar2,"HTML_free: ***** leftover option data: %s\n",pcVar4);
        }
      }
      HTChunkClear(&me->option);
    }
    if (0 < (me->textarea).size) {
      BVar1 = LYBadHTML(me);
      if ((BVar1 != '\0') && (WWW_TraceFlag != '\0')) {
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2,"Bad HTML: TEXTAREA not used properly *****\n");
      }
      if (WWW_TraceFlag != '\0') {
        HTChunkTerminate(&me->textarea);
        if (WWW_TraceFlag != '\0') {
          pcVar4 = (me->textarea).data;
          pFVar2 = TraceFP();
          fprintf((FILE *)pFVar2,"HTML_free: ***** leftover textarea data: %s\n",pcVar4);
        }
      }
      HTChunkClear(&me->textarea);
    }
    if (me->target != (HTStream *)0x0) {
      (*(me->targetClass)._free)(me->target);
    }
    if (((me->sp != (stack_element *)0x0) && (me->sp->style != (HTStyle *)0x0)) &&
       (me->sp->style->name != (char *)0x0)) {
      if (((me->sp->style->id == 1) || (me->sp->style->id == 0x2f)) || (me->sp->style->id == 0x29))
      {
        me->sp->style->alignment = 3;
      }
      else if ((me->sp->style->id == 3) || (me->sp->style->id == 0x31)) {
        me->sp->style->alignment = 2;
      }
      else {
        me->sp->style->alignment = 1;
      }
      styles[86]->alignment = 1;
    }
    if (me->base_href != (char *)0x0) {
      free(me->base_href);
      me->base_href = (char *)0x0;
    }
    if (me->map_address != (char *)0x0) {
      free(me->map_address);
      me->map_address = (char *)0x0;
    }
    if (me->LastOptionValue != (char *)0x0) {
      free(me->LastOptionValue);
      me->LastOptionValue = (char *)0x0;
    }
    clear_objectdata(me);
    if (me != (HTStructured *)0x0) {
      free(me);
    }
  }
  else {
    if (me->base_href != (char *)0x0) {
      free(me->base_href);
      me->base_href = (char *)0x0;
    }
    if (me->map_address != (char *)0x0) {
      free(me->map_address);
      me->map_address = (char *)0x0;
    }
    clear_objectdata(me);
    if (me->xinclude != (char *)0x0) {
      free(me->xinclude);
      me->xinclude = (char *)0x0;
    }
    if (me != (HTStructured *)0x0) {
      free(me);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void HTML_abort(HTStructured *me,HTError e)

{
  char *pcVar1;
  FILE *pFVar2;
  char *include;
  
  include = (char *)0x0;
  if (me->text != (HText *)0x0) {
    if (me->inUnderline != '\0') {
      HText_appendCharacter(me->text,L'\x04');
      me->inUnderline = '\0';
      me->Underline_Level = 0;
    }
    if (me->inA != '\0') {
      HTML_end_element(me,0,&include);
      me->inA = '\0';
    }
    if (me->inFONT != '\0') {
      HTML_end_element(me,0x2b,&include);
      me->inFONT = '\0';
    }
    if (me->inFORM != '\0') {
      HTML_end_element(me,0x2c,&include);
      me->inFORM = '\0';
    }
    HText_endAppend(me->text);
  }
  if (0 < (me->option).size) {
    if (WWW_TraceFlag != '\0') {
      if (WWW_TraceFlag != '\0') {
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2,"HTML_abort: SELECT or OPTION not ended properly *****\n");
      }
      HTChunkTerminate(&me->option);
      if (WWW_TraceFlag != '\0') {
        pcVar1 = (me->option).data;
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2,"HTML_abort: ***** leftover option data: %s\n",pcVar1);
      }
    }
    HTChunkClear(&me->option);
  }
  if (0 < (me->textarea).size) {
    if (WWW_TraceFlag != '\0') {
      if (WWW_TraceFlag != '\0') {
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2,"HTML_abort: TEXTAREA not used properly *****\n");
      }
      HTChunkTerminate(&me->textarea);
      if (WWW_TraceFlag != '\0') {
        pcVar1 = (me->textarea).data;
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2,"HTML_abort: ***** leftover textarea data: %s\n",pcVar1);
      }
    }
    HTChunkClear(&me->textarea);
  }
  if (me->target != (HTStream *)0x0) {
    (*(me->targetClass)._abort)(me->target,e);
  }
  if (((me->sp != (stack_element *)0x0) && (me->sp->style != (HTStyle *)0x0)) &&
     (me->sp->style->name != (char *)0x0)) {
    if (((me->sp->style->id == 1) || (me->sp->style->id == 0x2f)) || (me->sp->style->id == 0x29)) {
      me->sp->style->alignment = 3;
    }
    else if ((me->sp->style->id == 3) || (me->sp->style->id == 0x31)) {
      me->sp->style->alignment = 2;
    }
    else {
      me->sp->style->alignment = 1;
    }
    styles[86]->alignment = 1;
  }
  if (me->base_href != (char *)0x0) {
    free(me->base_href);
    me->base_href = (char *)0x0;
  }
  if (me->map_address != (char *)0x0) {
    free(me->map_address);
    me->map_address = (char *)0x0;
  }
  if (me->textarea_name != (char *)0x0) {
    free(me->textarea_name);
    me->textarea_name = (char *)0x0;
  }
  if (me->textarea_accept_cs != (char *)0x0) {
    free(me->textarea_accept_cs);
    me->textarea_accept_cs = (char *)0x0;
  }
  if (me->textarea_id != (char *)0x0) {
    free(me->textarea_id);
    me->textarea_id = (char *)0x0;
  }
  if (me->LastOptionValue != (char *)0x0) {
    free(me->LastOptionValue);
    me->LastOptionValue = (char *)0x0;
  }
  if (me->xinclude != (char *)0x0) {
    free(me->xinclude);
    me->xinclude = (char *)0x0;
  }
  clear_objectdata(me);
  if (me != (HTStructured *)0x0) {
    free(me);
  }
  return;
}



// WARNING: Unknown calling convention

void get_styles(void)

{
  HTStyle **st;
  
  st = (HTStyle **)0x0;
  styleSheet = DefaultStyle(&st);
  default_style = *st;
  styles[47] = st[0x29];
  styles[48] = st[0x2a];
  styles[49] = st[0x2b];
  styles[50] = st[0x2c];
  styles[51] = st[0x2d];
  styles[52] = st[0x2e];
  styles[143] = st[0x2f];
  styles[144] = st[0x30];
  styles[145] = st[0x31];
  styles[146] = st[1];
  styles[147] = st[2];
  styles[148] = st[3];
  styles[35] = st[0x16];
  styles[131] = st[0x17];
  styles[132] = st[0x18];
  styles[133] = st[0x19];
  styles[134] = st[0x1a];
  styles[135] = st[0x1b];
  styles[136] = st[0x1c];
  styles[80] = st[8];
  styles[114] = st[8];
  styles[119] = st[9];
  styles[120] = st[10];
  styles[121] = st[0xb];
  styles[122] = st[0xc];
  styles[123] = st[0xd];
  styles[124] = st[0xe];
  styles[33] = st[0xf];
  styles[74] = st[0xf];
  styles[125] = st[0x10];
  styles[126] = st[0x11];
  styles[127] = st[0x12];
  styles[128] = st[0x13];
  styles[129] = st[0x14];
  styles[130] = st[0x15];
  styles[36] = st[0x1d];
  styles[137] = st[0x1e];
  styles[138] = st[0x1f];
  styles[139] = st[0x20];
  styles[140] = st[0x21];
  styles[141] = st[0x22];
  styles[142] = st[0x23];
  styles[3] = st[0x27];
  styles[9] = st[4];
  styles[16] = st[5];
  styles[19] = st[6];
  styles[42] = st[7];
  styles[78] = st[0x28];
  styles[117] = st[0x24];
  styles[85] = st[0x24];
  styles[86] = st[0x25];
  styles[70] = st[0x26];
  return;
}



// WARNING: Unknown calling convention

HTStyle * LYstyles(int style_number)

{
  if (styles[style_number] == (HTStyle *)0x0) {
    get_styles();
  }
  return styles[style_number];
}



// WARNING: Unknown calling convention

HTStructured * HTML_new(HTParentAnchor *anchor,HTFormat format_out,HTStream_conflict *stream)

{
  HTStreamClass_conflict *pHVar1;
  FILE *__stream;
  HTAtom *pHVar2;
  HTStream_conflict4 *output;
  HTStructured *pHVar3;
  int iVar4;
  LYUCcharset *pLVar5;
  HTStream_conflict *intermediate;
  HTStructured *me;
  
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"start HTML_new\n");
  }
  pHVar2 = HTAtom_for("text/plain");
  if ((pHVar2 != format_out) && (pHVar2 = HTAtom_for("www/present"), pHVar2 != format_out)) {
    pHVar2 = HTAtom_for("text/html");
    output = HTStreamStack(pHVar2,format_out,(HTStream_conflict4 *)stream,anchor);
    if (output != (HTStream_conflict4 *)0x0) {
      pHVar3 = (HTStructured *)HTMLGenerator(output);
      return pHVar3;
    }
    fprintf(stderr,"\n** Internal error: can\'t parse HTML to %s\n",format_out->name);
    exit_immediately(1);
  }
  pHVar3 = (HTStructured *)calloc(1,0x2144);
  if (pHVar3 == (HTStructured *)0x0) {
    outofmem("./HTML.c","HTML_new");
  }
  get_styles();
  pHVar3->isa = &HTMLPresentation;
  pHVar3->node_anchor = anchor;
  pHVar3->CurrentA = (HTChildAnchor *)0x0;
  pHVar3->CurrentANum = 0;
  pHVar3->base_href = (char *)0x0;
  pHVar3->map_address = (char *)0x0;
  HTChunkInit(&pHVar3->title,0x80);
  HTChunkInit(&pHVar3->object,0x80);
  pHVar3->object_started = '\0';
  pHVar3->object_declare = '\0';
  pHVar3->object_shapes = '\0';
  pHVar3->object_ismap = '\0';
  pHVar3->object_id = (char *)0x0;
  pHVar3->object_title = (char *)0x0;
  pHVar3->object_data = (char *)0x0;
  pHVar3->object_type = (char *)0x0;
  pHVar3->object_classid = (char *)0x0;
  pHVar3->object_codebase = (char *)0x0;
  pHVar3->object_codetype = (char *)0x0;
  pHVar3->object_usemap = (char *)0x0;
  pHVar3->object_name = (char *)0x0;
  HTChunkInit(&pHVar3->option,0x80);
  pHVar3->first_option = '\x01';
  pHVar3->LastOptionValue = (char *)0x0;
  pHVar3->LastOptionChecked = '\0';
  pHVar3->select_disabled = '\0';
  HTChunkInit(&pHVar3->textarea,0x80);
  pHVar3->textarea_name = (char *)0x0;
  pHVar3->textarea_name_cs = -1;
  pHVar3->textarea_accept_cs = (char *)0x0;
  pHVar3->textarea_cols = 0;
  pHVar3->textarea_rows = 4;
  pHVar3->textarea_disabled = 0;
  pHVar3->textarea_id = (char *)0x0;
  HTChunkInit(&pHVar3->math,0x80);
  HTChunkInit(&pHVar3->style_block,0x80);
  HTChunkInit(&pHVar3->script,0x80);
  pHVar3->text = (HText *)0x0;
  pHVar3->style_change = '\x01';
  pHVar3->new_style = default_style;
  pHVar3->old_style = (HTStyle *)0x0;
  pHVar3->current_default_alignment = 1;
  pHVar3->sp = pHVar3->stack + 799;
  pHVar3->skip_stack = 0;
  pHVar3->sp->tag_number = -1;
  pHVar3->sp->style = default_style;
  pHVar3->sp->style->alignment = 1;
  pHVar3->stack_overrun = '\0';
  pHVar3->Division_Level = -1;
  pHVar3->Underline_Level = 0;
  pHVar3->Quote_Level = 0;
  pHVar3->UsePlainSpace = '\0';
  pHVar3->HiddenValue = '\0';
  pHVar3->lastraw = -1;
  pHVar3->List_Nesting_Level = -1;
  LYZero_OL_Counter(pHVar3);
  pHVar3->Last_OL_Count = 0;
  pHVar3->Last_OL_Type = '1';
  pHVar3->inA = '\0';
  pHVar3->inAPPLET = '\0';
  pHVar3->inAPPLETwithP = '\0';
  pHVar3->inBadBASE = '\0';
  pHVar3->inBadHREF = '\0';
  pHVar3->inBadHTML = '\0';
  pHVar3->inBASE = '\0';
  pHVar3->node_anchor->inBASE = '\0';
  pHVar3->inBoldA = '\0';
  pHVar3->inBoldH = '\0';
  pHVar3->inCAPTION = '\0';
  pHVar3->inCREDIT = '\0';
  pHVar3->inFIG = '\0';
  pHVar3->inFIGwithP = '\0';
  pHVar3->inFONT = '\0';
  pHVar3->inFORM = '\0';
  pHVar3->inLABEL = '\0';
  pHVar3->inP = '\0';
  pHVar3->inPRE = '\0';
  pHVar3->inSELECT = '\0';
  pHVar3->inTABLE = '\0';
  pHVar3->inUnderline = '\0';
  pHVar3->needBoldH = '\0';
  pHVar3->comment_start = (char *)0x0;
  pHVar3->comment_end = (char *)0x0;
  addClassName("","",0);
  class_string[0] = '\0';
  LYGetChartransInfo(pHVar3);
  UCTransParams_clear(&pHVar3->T);
  iVar4 = HTAnchor_getUCLYhndl(pHVar3->node_anchor,1);
  pHVar3->inUCLYhndl = iVar4;
  if (pHVar3->inUCLYhndl < 0) {
    iVar4 = HTAnchor_getUCLYhndl(pHVar3->node_anchor,0);
    pHVar3->inUCLYhndl = iVar4;
    pLVar5 = HTAnchor_getUCInfoStage(pHVar3->node_anchor,0);
    pHVar3->inUCI = pLVar5;
  }
  else {
    pLVar5 = HTAnchor_getUCInfoStage(pHVar3->node_anchor,1);
    pHVar3->inUCI = pLVar5;
  }
  pLVar5 = HTAnchor_getUCInfoStage(pHVar3->node_anchor,2);
  pHVar3->outUCI = pLVar5;
  iVar4 = HTAnchor_getUCLYhndl(pHVar3->node_anchor,2);
  pHVar3->outUCLYhndl = iVar4;
  pHVar3->target = (HTStream *)stream;
  if (stream != (HTStream_conflict *)0x0) {
    pHVar1 = stream->isa;
    (pHVar3->targetClass).name = pHVar1->name;
    (pHVar3->targetClass)._free = (_func_void_HTStream_ptr *)pHVar1->_free;
    (pHVar3->targetClass)._abort = (_func_void_HTStream_ptr_HTError *)pHVar1->_abort;
    (pHVar3->targetClass).put_character = (_func_void_HTStream_ptr_char *)pHVar1->put_character;
    (pHVar3->targetClass).put_string = (_func_void_HTStream_ptr_char_ptr *)pHVar1->put_string;
    (pHVar3->targetClass).put_block =
         (_func_void_HTStream_ptr_char_ptr_int_conflict *)pHVar1->put_block;
  }
  return pHVar3;
}



// WARNING: Unknown calling convention

void CacheThru_do_free(HTStream_conflict *me)

{
  HTChunk *pHVar1;
  FILE *pFVar2;
  int iVar3;
  char *pcVar4;
  char *cp_freeme_1;
  char *cp_freeme;
  
  if (me->anchor->source_cache_file != (char *)0x0) {
    if (WWW_TraceFlag != '\0') {
      pcVar4 = me->anchor->source_cache_file;
      pFVar2 = TraceFP();
      fprintf((FILE *)pFVar2,"SourceCacheWriter: Removing previous file %s\n",pcVar4);
    }
    LYRemoveTemp(me->anchor->source_cache_file);
    if (me->anchor->source_cache_file != (char *)0x0) {
      free(me->anchor->source_cache_file);
      me->anchor->source_cache_file = (char *)0x0;
    }
  }
  if (me->anchor->source_cache_chunk != (HTChunk *)0x0) {
    if (WWW_TraceFlag != '\0') {
      pHVar1 = me->anchor->source_cache_chunk;
      pFVar2 = TraceFP();
      fprintf((FILE *)pFVar2,"SourceCacheWriter: Removing previous memory chunk %p\n",pHVar1);
    }
    HTChunkFree(me->anchor->source_cache_chunk);
    me->anchor->source_cache_chunk = (HTChunk *)0x0;
  }
  if (me->fp == (FILE *)0x0) {
    if (me->status != 0) {
      if (me->chunk != (HTChunk *)0x0) {
        if (WWW_TraceFlag != '\0') {
          pHVar1 = me->chunk;
          pFVar2 = TraceFP();
          fprintf((FILE *)pFVar2,"SourceCacheWriter: memory chunk %p had errors.\n",pHVar1);
        }
        HTChunkFree(me->chunk);
        me->last_chunk = (HTChunk *)0x0;
        me->chunk = me->last_chunk;
      }
      pcVar4 = (char *)gettext("Source cache error - not enough memory!");
      HTAlert(pcVar4);
    }
  }
  else {
    fflush((FILE *)me->fp);
    iVar3 = ferror((FILE *)me->fp);
    if (iVar3 != 0) {
      me->status = -1;
    }
    LYCloseTempFP(me->fp);
    if (me->status == 0) {
      cp_freeme = (char *)0x0;
      me->anchor->source_cache_file = me->filename;
      if (WWW_TraceFlag != '\0') {
        cp_freeme = HTAnchor_address((HTAnchor *)me->anchor);
        pcVar4 = me->filename;
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2,"SourceCacheWriter: Committing file %s for URL %s to anchor\n",pcVar4
                ,cp_freeme);
      }
      if (cp_freeme != (char *)0x0) {
        free(cp_freeme);
      }
    }
    else {
      if (source_cache_file_error == '\0') {
        pcVar4 = (char *)gettext("Source cache error - disk full?");
        HTAlert(pcVar4);
        source_cache_file_error = '\x01';
      }
      LYRemoveTemp(me->filename);
      me->anchor->source_cache_file = (char *)0x0;
    }
  }
  if (me->chunk != (HTChunk *)0x0) {
    cp_freeme_1 = (char *)0x0;
    me->anchor->source_cache_chunk = me->chunk;
    if (WWW_TraceFlag != '\0') {
      cp_freeme_1 = HTAnchor_address((HTAnchor *)me->anchor);
      pHVar1 = me->chunk;
      pFVar2 = TraceFP();
      fprintf((FILE *)pFVar2,"SourceCacheWriter: Committing memory chunk %p for URL %s to anchor\n",
              pHVar1,cp_freeme_1);
    }
    if (cp_freeme_1 != (char *)0x0) {
      free(cp_freeme_1);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void CacheThru_free(HTStream_conflict *me)

{
  CacheThru_do_free(me);
  (*me->actions->_free)(me->target);
  if (me != (HTStream_conflict *)0x0) {
    free(me);
  }
  return;
}



// WARNING: Unknown calling convention

void CacheThru_abort(HTStream_conflict *me,HTError e)

{
  char *pcVar1;
  HTChunk *pHVar2;
  FILE *pFVar3;
  
  if (me->fp != (FILE *)0x0) {
    LYCloseTempFP(me->fp);
  }
  if (LYCacheSourceForAborted == L'\0') {
    if (me->filename != (char *)0x0) {
      if (WWW_TraceFlag != '\0') {
        pcVar1 = me->filename;
        pFVar3 = TraceFP();
        fprintf((FILE *)pFVar3,"SourceCacheWriter: Removing active file %s\n",pcVar1);
      }
      LYRemoveTemp(me->filename);
      if (me->filename != (char *)0x0) {
        free(me->filename);
        me->filename = (char *)0x0;
      }
    }
    if (me->chunk != (HTChunk *)0x0) {
      if (WWW_TraceFlag != '\0') {
        pHVar2 = me->chunk;
        pFVar3 = TraceFP();
        fprintf((FILE *)pFVar3,"SourceCacheWriter: Removing active memory chunk %p\n",pHVar2);
      }
      HTChunkFree(me->chunk);
    }
  }
  else {
    me->status = 0;
    CacheThru_do_free(me);
  }
  (*me->actions->_abort)(me->target,e);
  if (me != (HTStream_conflict *)0x0) {
    free(me);
  }
  return;
}



void CacheThru_put_character(HTStream_conflict *me,char c_in)

{
  HTChunk *pHVar1;
  char c_in_local;
  
  if (me->status == 0) {
    if (me->fp == (FILE *)0x0) {
      if (me->chunk != (HTChunk *)0x0) {
        pHVar1 = HTChunkPutc2(me->last_chunk,c_in);
        me->last_chunk = pHVar1;
        if ((me->last_chunk == (HTChunk *)0x0) || (me->last_chunk->allocated == 0)) {
          me->status = -1;
        }
      }
    }
    else {
      fputc((int)c_in,(FILE *)me->fp);
    }
  }
  (*me->actions->put_character)(me->target,c_in);
  return;
}



// WARNING: Unknown calling convention

void CacheThru_put_string(HTStream_conflict *me,char *str)

{
  HTChunk *pHVar1;
  
  if (me->status == 0) {
    if (me->fp == (FILE *)0x0) {
      if (me->chunk != (HTChunk *)0x0) {
        pHVar1 = HTChunkPuts2(me->last_chunk,str);
        me->last_chunk = pHVar1;
        if ((me->last_chunk == (HTChunk *)0x0) || (me->last_chunk->allocated == 0)) {
          me->status = -1;
        }
      }
    }
    else {
      fputs(str,(FILE *)me->fp);
    }
  }
  (*me->actions->put_string)(me->target,str);
  return;
}



// WARNING: Unknown calling convention

void CacheThru_write(HTStream_conflict *me,char *str,int l)

{
  int iVar1;
  HTChunk *pHVar2;
  
  if ((me->status == 0) && (l != 0)) {
    if (me->fp == (FILE *)0x0) {
      if (me->chunk != (HTChunk *)0x0) {
        pHVar2 = HTChunkPutb2(me->last_chunk,str,l);
        me->last_chunk = pHVar2;
        if ((me->last_chunk == (HTChunk *)0x0) || (me->last_chunk->allocated == 0)) {
          me->status = -1;
        }
      }
    }
    else {
      fwrite(str,1,l,(FILE *)me->fp);
      iVar1 = ferror((FILE *)me->fp);
      if (iVar1 != 0) {
        me->status = -1;
      }
    }
  }
  (*me->actions->put_block)(me->target,str,l);
  return;
}



HTStream_conflict * CacheThru_new(HTParentAnchor *anchor,HTStream_conflict *target)

{
  int iVar1;
  char **ppcVar2;
  char *pcVar3;
  int iVar4;
  FILE *pFVar5;
  HTChunk *pHVar6;
  int in_GS_OFFSET;
  HTStream_conflict *local_124;
  HTStream_conflict *target_local;
  HTParentAnchor *anchor_local;
  HTProtocol_conflict1 *p;
  HTStream_conflict *stream;
  char *cp_freeme;
  char filename [256];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  cp_freeme = (char *)0x0;
  ppcVar2 = (char **)anchor->protocol;
  if (LYCacheSource == L'\0') {
    local_124 = target;
  }
  else {
    iVar4 = strcmp(*ppcVar2,"http");
    if ((iVar4 == 0) || (iVar4 = strcmp(*ppcVar2,"https"), iVar4 == 0)) {
      if (WWW_TraceFlag != '\0') {
        pFVar5 = TraceFP();
        fprintf((FILE *)pFVar5,"start CacheThru_new\n");
      }
      local_124 = (HTStream_conflict *)malloc(0x24);
      if (local_124 == (HTStream_conflict *)0x0) {
        outofmem("./HTML.c","CacheThru_new");
      }
      local_124->isa = &PassThruCache;
      local_124->anchor = anchor;
      local_124->fp = (FILE *)0x0;
      local_124->filename = (char *)0x0;
      local_124->chunk = (HTChunk *)0x0;
      local_124->target = target;
      local_124->actions = target->isa;
      local_124->status = 0;
      if (LYCacheSource == L'\x01') {
        if ((anchor->source_cache_file != (char *)0x0) && (WWW_TraceFlag != '\0')) {
          pcVar3 = anchor->source_cache_file;
          pFVar5 = TraceFP();
          fprintf((FILE *)pFVar5,
                  "SourceCacheWriter: If successful, will replace source cache file %s\n",pcVar3);
        }
        pFVar5 = LYOpenTemp(filename,".html","wb");
        local_124->fp = pFVar5;
        if (local_124->fp == (FILE *)0x0) {
          if (WWW_TraceFlag != '\0') {
            cp_freeme = HTAnchor_address((HTAnchor *)anchor);
            pFVar5 = TraceFP();
            fprintf((FILE *)pFVar5,"SourceCacheWriter: Cannot open source cache file for URL %s\n",
                    cp_freeme);
          }
          if (local_124 != (HTStream_conflict *)0x0) {
            free(local_124);
          }
          if (cp_freeme != (char *)0x0) {
            free(cp_freeme);
          }
          local_124 = target;
          goto LAB_080cf851;
        }
        HTSACopy(&local_124->filename,filename);
        if (WWW_TraceFlag != '\0') {
          cp_freeme = HTAnchor_address((HTAnchor *)anchor);
          pFVar5 = TraceFP();
          fprintf((FILE *)pFVar5,"SourceCacheWriter: Caching source for URL %s in file %s\n",
                  cp_freeme,filename);
        }
        if (cp_freeme != (char *)0x0) {
          free(cp_freeme);
          cp_freeme = (char *)0x0;
        }
      }
      if (LYCacheSource == L'\x02') {
        if ((anchor->source_cache_chunk != (HTChunk *)0x0) && (WWW_TraceFlag != '\0')) {
          pHVar6 = anchor->source_cache_chunk;
          pFVar5 = TraceFP();
          fprintf((FILE *)pFVar5,"SourceCacheWriter: If successful, will replace memory chunk %p\n",
                  pHVar6);
        }
        pHVar6 = HTChunkCreateMayFail(0x1000,1);
        local_124->last_chunk = pHVar6;
        local_124->chunk = local_124->last_chunk;
        if (local_124->chunk == (HTChunk *)0x0) {
          local_124->status = -1;
        }
        if (WWW_TraceFlag != '\0') {
          pHVar6 = local_124->chunk;
          cp_freeme = HTAnchor_address((HTAnchor *)anchor);
          pFVar5 = TraceFP();
          fprintf((FILE *)pFVar5,"SourceCacheWriter: Caching source for URL %s in memory chunk %p\n"
                  ,cp_freeme,pHVar6);
        }
        if (cp_freeme != (char *)0x0) {
          free(cp_freeme);
        }
      }
    }
    else {
      if (WWW_TraceFlag != '\0') {
        pcVar3 = *ppcVar2;
        pFVar5 = TraceFP();
        fprintf((FILE *)pFVar5,"SourceCacheWriter: Protocol is \"%s\"; not cached\n",pcVar3);
      }
      local_124 = target;
    }
  }
LAB_080cf851:
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return local_124;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

HTStream_conflict * HTMLToPlain(HTPresentation *pres,HTParentAnchor *anchor,HTStream_conflict *sink)

{
  FILE *__stream;
  HTStructured *target;
  HTStream_conflict2 *target_00;
  HTStream_conflict *pHVar1;
  
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"HTMLToPlain calling CacheThru_new\n");
  }
  target = HTML_new(anchor,pres->rep_out,sink);
  target_00 = SGML_new(&HTML_dtd,anchor,target);
  pHVar1 = CacheThru_new(anchor,(HTStream_conflict *)target_00);
  return pHVar1;
}



// WARNING: Unknown calling convention

HTStream_conflict *
HTMLParsedPresent(HTPresentation *pres,HTParentAnchor *anchor,HTStream_conflict *sink)

{
  HTFormat rep_out;
  int LYhndl;
  HTAtom *pHVar1;
  HTAtom *rep_in;
  FILE *__stream;
  HTStructured *target;
  HTStream_conflict2 *target_00;
  HTStream_conflict *local_1c;
  int structured_cset;
  int old_parser_cset;
  HTStream_conflict *intermediate;
  
  intermediate = sink;
  if (sink == (HTStream_conflict *)0x0) {
    LYhndl = HTAnchor_getUCLYhndl(anchor,1);
    structured_cset = HTAnchor_getUCLYhndl(anchor,2);
    if (structured_cset < 0) {
      structured_cset = HTAnchor_getUCLYhndl(anchor,3);
    }
    if (structured_cset < 0) {
      structured_cset = current_char_set;
    }
    HTAnchor_setUCInfoStage(anchor,structured_cset,1,5);
    if (pres->rep_out == WWW_SOURCE) {
      pHVar1 = HTAtom_for("www/present");
      rep_in = HTAtom_for("text/plain");
      intermediate = (HTStream_conflict *)
                     HTStreamStack(rep_in,pHVar1,(HTStream_conflict4 *)0x0,anchor);
    }
    else {
      rep_out = pres->rep_out;
      pHVar1 = HTAtom_for("text/plain");
      intermediate = (HTStream_conflict *)
                     HTStreamStack(pHVar1,rep_out,(HTStream_conflict4 *)0x0,anchor);
    }
    if (LYhndl != structured_cset) {
      HTAnchor_resetUCInfoStage(anchor,LYhndl,1,0);
      if (-1 < LYhndl) {
        HTAnchor_setUCInfoStage(anchor,LYhndl,1,2);
      }
    }
  }
  if (intermediate == (HTStream_conflict *)0x0) {
    local_1c = (HTStream_conflict *)0x0;
  }
  else {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMLParsedPresent calling CacheThru_new\n");
    }
    target = (HTStructured *)HTMLGenerator((HTStream_conflict4 *)intermediate);
    target_00 = SGML_new(&HTML_dtd,anchor,target);
    local_1c = CacheThru_new(anchor,(HTStream_conflict *)target_00);
  }
  return local_1c;
}



// WARNING: Unknown calling convention

HTStream_conflict * HTMLToC(HTPresentation *pres,HTParentAnchor *anchor,HTStream_conflict *sink)

{
  HTAtom *format_out;
  HTStructured *me;
  FILE *__stream;
  HTStream_conflict2 *target;
  HTStream_conflict *pHVar1;
  HTStructured *html;
  
  if (sink != (HTStream_conflict *)0x0) {
    (*sink->isa->put_string)(sink,"/* ");
  }
  format_out = HTAtom_for("text/plain");
  me = HTML_new(anchor,format_out,sink);
  me->comment_start = "/* ";
  me->comment_end = " */\n";
  if (sink == (HTStream_conflict *)0x0) {
    HTML_put_string(me,me->comment_start);
  }
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"HTMLToC calling CacheThru_new\n");
  }
  target = SGML_new(&HTML_dtd,anchor,me);
  pHVar1 = CacheThru_new(anchor,(HTStream_conflict *)target);
  return pHVar1;
}



// WARNING: Unknown calling convention

HTStream_conflict * HTMLPresent(HTPresentation *pres,HTParentAnchor *anchor,HTStream_conflict *sink)

{
  FILE *__stream;
  HTAtom *format_out;
  HTStructured *target;
  HTStream_conflict2 *target_00;
  HTStream_conflict *pHVar1;
  
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"HTMLPresent calling CacheThru_new\n");
  }
  format_out = HTAtom_for("www/present");
  target = HTML_new(anchor,format_out,(HTStream_conflict *)0x0);
  target_00 = SGML_new(&HTML_dtd,anchor,target);
  pHVar1 = CacheThru_new(anchor,(HTStream_conflict *)target_00);
  return pHVar1;
}



// WARNING: Unknown calling convention

int HTLoadError(HTStream_conflict *sink,int number,char *message)

{
  HTAlert(message);
  return -number;
}



// WARNING: Unknown calling convention

char * MakeNewTitle(char **value,int src_type)

{
  char *newtitle;
  char *ptr;
  
  newtitle = (char *)0x0;
  HTSACopy(&newtitle,"[");
  if ((value == (char **)0x0) || (value[src_type] == (char *)0x0)) {
    ptr = (char *)0x0;
  }
  else {
    ptr = strrchr(value[src_type],0x2f);
  }
  if (ptr == (char *)0x0) {
    HTSACat(&newtitle,value[src_type]);
  }
  else {
    HTSACat(&newtitle,ptr + 1);
  }
  HTSACat(&newtitle,"]");
  return newtitle;
}



// WARNING: Unknown calling convention

char * MakeNewImageValue(char **value)

{
  char *local_18;
  char *newtitle;
  char *ptr;
  
  newtitle = (char *)0x0;
  HTSACopy(&newtitle,"[");
  if (value[0x1b] == (char *)0x0) {
    local_18 = (char *)0x0;
  }
  else {
    local_18 = strrchr(value[0x1b],0x2f);
  }
  ptr = local_18;
  if (local_18 == (char *)0x0) {
    HTSACat(&newtitle,value[0x1b]);
  }
  else {
    HTSACat(&newtitle,local_18 + 1);
  }
  HTSACat(&newtitle,"]-Submit");
  return newtitle;
}



// WARNING: Unknown calling convention

char * MakeNewMapValue(char **value,char *mapstr)

{
  char *newtitle;
  char *ptr;
  
  newtitle = (char *)0x0;
  HTSACopy(&newtitle,"[");
  HTSACat(&newtitle,mapstr);
  if (((verbose_img != '\0') && (value[0xf] != (char *)0x0)) && (*value[0xf] != '\0')) {
    HTSACat(&newtitle,":");
    ptr = strrchr(value[0xf],0x2f);
    if (ptr == (char *)0x0) {
      HTSACat(&newtitle,value[0xf]);
    }
    else {
      HTSACat(&newtitle,ptr + 1);
    }
  }
  HTSACat(&newtitle,"]");
  return newtitle;
}



void HTFWriter_error(HTStream_conflict *me,char *id)

{
  int iVar1;
  int *piVar2;
  char *pcVar3;
  int in_GS_OFFSET;
  char *id_local;
  HTStream_conflict *me_local;
  char buf [200];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  piVar2 = __errno_location();
  pcVar3 = strerror(*piVar2);
  sprintf(buf,"%.60s: %.60s: %.60s",id,me->isa->name,pcVar3);
  HTAlert(buf);
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void HTFWriter_put_character(HTStream_conflict *me,char c)

{
  char c_local;
  
  if (me->anchor != (HTParentAnchor *)0x0) {
    _IO_putc((int)c,(_IO_FILE *)me->anchor);
  }
  return;
}



// WARNING: Unknown calling convention

void HTFWriter_put_string(HTStream_conflict *me,char *s)

{
  if (me->anchor != (HTParentAnchor *)0x0) {
    fputs(s,(FILE *)me->anchor);
  }
  return;
}



// WARNING: Unknown calling convention

void HTFWriter_write(HTStream_conflict *me,char *s,int l)

{
  size_t sVar1;
  size_t result;
  
  if (me->anchor != (HTParentAnchor *)0x0) {
    sVar1 = fwrite(s,1,l,(FILE *)me->anchor);
    if (l != sVar1) {
      HTFWriter_error(me,"HTFWriter_write");
    }
  }
  return;
}



// WARNING: Unknown calling convention

void HTFWriter_free(HTStream_conflict *me)

{
  HTChunk *pHVar1;
  HTStreamClass_conflict *pHVar2;
  HTChunk *pHVar3;
  int iVar4;
  char *pcVar5;
  char *message;
  HTStreamClass_conflict *pHVar6;
  int status;
  char *addr;
  char *path;
  int len;
  BOOLEAN skip_loadfile;
  BOOLEAN found;
  BOOLEAN use_zread;
  
  path = (char *)0x0;
  addr = (char *)0x0;
  use_zread = '\0';
  found = '\0';
  if (me->anchor != (HTParentAnchor *)0x0) {
    fflush((FILE *)me->anchor);
  }
  if (me->fp != (FILE *)0x0) {
    LYCloseTempFP((FILE *)me->anchor);
    pHVar1 = me->last_chunk;
    pHVar3 = (HTChunk *)HTAtom_for("www/compressed");
    if (pHVar1 == pHVar3) {
      if (me->target[2].actions != (HTStreamClass_conflict *)0x0) {
        skip_loadfile = me->chunk != (HTChunk *)0x0;
        HTSACopy(&path,(char *)me->target[2].actions);
        len = strlen(path);
        if ((len < 4) ||
           ((iVar4 = strcasecomp(path + (len - 2),"gz"), iVar4 != 0 &&
            (iVar4 = strcasecomp(path + len + -2,"zz"), iVar4 != 0)))) {
          if ((len < 5) || (iVar4 = strcasecomp(path + len + -3,"bz2"), iVar4 != 0)) {
            if ((2 < len) && (iVar4 = strcasecomp(path + len + -1,"Z"), iVar4 == 0)) {
              path[len + -2] = '\0';
              remove(path);
            }
          }
          else {
            path[len + -4] = '\0';
            remove(path);
          }
        }
        else if (skip_loadfile == '\0') {
          use_zread = '\x01';
        }
        else {
          path[len + -3] = '\0';
          remove(path);
        }
        if (use_zread == '\0') {
          if (dump_output_immediately == '\0') {
            mustshow = '\x01';
            HTProgress((char *)me->fp);
          }
          if ((me->fp != (FILE *)0x0) && (*(char *)&me->fp->_flags != '\0')) {
            LYSystem((char *)me->fp);
          }
          found = LYCanReadFile((char *)me->target[2].actions);
        }
        if (found == '\0') {
          LYLocalFileToURL(&addr,path);
          if (use_zread == '\0') {
            LYRenamedTemp((char *)me->target[2].actions,path);
            HTSACopy((char **)&me->target[2].actions,path);
            HTSACopy((char **)&me->target[3].chunk,"binary");
          }
          if (path != (char *)0x0) {
            free(path);
            path = (char *)0x0;
          }
          if (skip_loadfile == '\0') {
            iVar4 = HTAnchor_getUCLYhndl((HTParentAnchor *)me->target,1);
            if (iVar4 < 0) {
              HTAnchor_copyUCInfoStage((HTParentAnchor *)me->target,1,0,2);
            }
            HTAnchor_copyUCInfoStage((HTParentAnchor *)me->target,1,0,-1);
          }
          pcVar5 = addr;
          if (dump_output_immediately == '\0') {
            message = (char *)gettext("Using %s");
            LYstore_message2(message,pcVar5);
          }
          if (skip_loadfile == '\0') {
            HTLoadFile(addr,(HTParentAnchor *)me->target,(HTFormat)me->actions,
                       (HTStream *)me->status);
          }
          else {
            if (me->fp != (FILE *)0x0) {
              free(me->fp);
              me->fp = (FILE *)0x0;
            }
            HTAddParam((char **)&me->fp,(char *)me->chunk,1,(char *)me->target[2].actions);
            HTEndParam((char **)&me->fp,(char *)me->chunk,1);
            if (dump_output_immediately == '\0') {
              HTProgress((char *)me->fp);
              stop_curses();
            }
            LYSystem((char *)me->fp);
            if ((me->filename != (char *)0x0) && (me->filename != (char *)0x0)) {
              free(me->filename);
              me->filename = (char *)0x0;
            }
            if (dump_output_immediately == '\0') {
              start_curses();
            }
          }
          if ((dump_output_immediately != '\0') &&
             (pHVar2 = me->actions, pHVar6 = (HTStreamClass_conflict *)HTAtom_for("www/present"),
             pHVar2 == pHVar6)) {
            if (addr != (char *)0x0) {
              free(addr);
              addr = (char *)0x0;
            }
            remove((char *)me->target[2].actions);
            if (me->target[2].actions != (HTStreamClass_conflict *)0x0) {
              free(me->target[2].actions);
              me->target[2].actions = (HTStreamClass_conflict *)0x0;
            }
            if (me->filename != (char *)0x0) {
              free(me->filename);
              me->filename = (char *)0x0;
            }
            if (me->fp != (FILE *)0x0) {
              free(me->fp);
              me->fp = (FILE *)0x0;
            }
            if (me->chunk != (HTChunk *)0x0) {
              free(me->chunk);
              me->chunk = (HTChunk *)0x0;
            }
            if (me == (HTStream_conflict *)0x0) {
              return;
            }
            free(me);
            return;
          }
        }
        else {
          if (dump_output_immediately == '\0') {
            lynx_force_repaint();
            LYrefresh();
          }
          pcVar5 = (char *)gettext("Error uncompressing temporary file!");
          HTAlert(pcVar5);
          LYRemoveTemp((char *)me->target[2].actions);
          if (me->target[2].actions != (HTStreamClass_conflict *)0x0) {
            free(me->target[2].actions);
            me->target[2].actions = (HTStreamClass_conflict *)0x0;
          }
        }
        if (addr != (char *)0x0) {
          free(addr);
          addr = (char *)0x0;
        }
      }
      if ((me->filename != (char *)0x0) && (me->filename != (char *)0x0)) {
        free(me->filename);
        me->filename = (char *)0x0;
      }
    }
    else {
      iVar4 = strcmp((char *)me->fp,"SaveToFile");
      if (iVar4 == 0) {
        if ((me->filename != (char *)0x0) && (me->filename != (char *)0x0)) {
          free(me->filename);
          me->filename = (char *)0x0;
        }
        if (dump_output_immediately == '\0') {
          start_curses();
        }
      }
      else {
        if (dump_output_immediately == '\0') {
          mustshow = '\x01';
          HTProgress((char *)me->fp);
          stop_curses();
        }
        LYSystem((char *)me->fp);
        if ((me->filename != (char *)0x0) && (me->filename != (char *)0x0)) {
          free(me->filename);
          me->filename = (char *)0x0;
        }
        if (dump_output_immediately == '\0') {
          start_curses();
        }
      }
    }
    if (me->fp != (FILE *)0x0) {
      free(me->fp);
      me->fp = (FILE *)0x0;
    }
  }
  if (me->chunk != (HTChunk *)0x0) {
    free(me->chunk);
    me->chunk = (HTChunk *)0x0;
  }
  if (dump_output_immediately != '\0') {
    if (me->target[2].actions != (HTStreamClass_conflict *)0x0) {
      remove((char *)me->target[2].actions);
    }
    if (me != (HTStream_conflict *)0x0) {
      free(me);
      me = (HTStream_conflict *)0x0;
    }
    if (persistent_cookies != '\0') {
      LYStoreCookies(LYCookieSaveFile);
    }
    exit_immediately(0);
  }
  if (me != (HTStream_conflict *)0x0) {
    free(me);
  }
  return;
}



void HTFWriter_abort(HTStream_conflict *me,HTError e)

{
  int iVar1;
  char *pcVar2;
  FILE *pFVar3;
  int iVar4;
  int *piVar5;
  char *pcVar6;
  undefined4 uVar7;
  int in_GS_OFFSET;
  HTError e_local;
  HTStream_conflict *me_local;
  char buf [560];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if (WWW_TraceFlag != '\0') {
    pFVar3 = TraceFP();
    fprintf((FILE *)pFVar3,"HTFWriter_abort called\n");
  }
  LYCloseTempFP((FILE *)me->anchor);
  if (me->chunk != (HTChunk *)0x0) {
    free(me->chunk);
    me->chunk = (HTChunk *)0x0;
  }
  if (me->fp != (FILE *)0x0) {
    if (WWW_TraceFlag != '\0') {
      pFVar3 = TraceFP();
      fprintf((FILE *)pFVar3,"HTFWriter: Aborting: file not executed or saved.\n");
    }
    if (me->fp != (FILE *)0x0) {
      free(me->fp);
      me->fp = (FILE *)0x0;
    }
    if (me->filename != (char *)0x0) {
      chmod(me->filename,0x180);
      iVar4 = unlink(me->filename);
      if (iVar4 != 0) {
        piVar5 = __errno_location();
        pcVar6 = strerror(*piVar5);
        pcVar2 = me->filename;
        uVar7 = gettext("Error deleting file");
        sprintf(buf,"%.60s \'%.400s\': %.60s",uVar7,pcVar2,pcVar6);
        HTAlert(buf);
      }
      if (me->filename != (char *)0x0) {
        free(me->filename);
        me->filename = (char *)0x0;
      }
    }
  }
  if (WWW_Download_File != (char *)0x0) {
    free(WWW_Download_File);
    WWW_Download_File = (char *)0x0;
  }
  if (me != (HTStream_conflict *)0x0) {
    free(me);
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



// WARNING: Unknown calling convention

HTStream_conflict * HTFWriter_new(FILE *fp)

{
  HTStream_conflict *local_18;
  HTStream_conflict *me;
  
  if (fp == (FILE *)0x0) {
    local_18 = (HTStream_conflict *)0x0;
  }
  else {
    local_18 = (HTStream_conflict *)calloc(1,0x24);
    if (local_18 == (HTStream_conflict *)0x0) {
      outofmem("./HTFWriter.c","HTFWriter_new");
    }
    local_18->isa = &HTFWriter;
    local_18->anchor = (HTParentAnchor *)fp;
    local_18->fp = (FILE *)0x0;
    local_18->filename = (char *)0x0;
    local_18->target = (HTStream_conflict *)0x0;
    local_18->status = 0;
  }
  return local_18;
}



// WARNING: Unknown calling convention

char * mailcap_substitute(HTParentAnchor *anchor,HTPresentation *pres,char *fnam)

{
  BOOLEAN BVar1;
  char *format;
  char *prepend;
  char *result;
  
  result = LYMakeMailcapCommand(pres->command,anchor->content_type_params,fnam);
  BVar1 = LYMailcapUsesPctS(pres->command);
  if (BVar1 == '\0') {
    prepend = (char *)0x0;
    HTSprintf(&prepend,"( %s",result);
    HTAddParam(&prepend,"( %s ) < %s",2,fnam);
    if (result != (char *)0x0) {
      free(result);
    }
    result = prepend;
  }
  return result;
}



HTStream_conflict *
HTSaveAndExecute(HTPresentation *pres,HTParentAnchor *anchor,HTStream_conflict *sink)

{
  int iVar1;
  BOOLEAN BVar2;
  char *pcVar3;
  int iVar4;
  char *fmt;
  HTParentAnchor *pHVar5;
  FILE *pFVar6;
  int in_GS_OFFSET;
  HTStream_conflict3 *local_128;
  HTStream_conflict *sink_local;
  HTParentAnchor *anchor_local;
  HTPresentation *pres_local;
  char *buf;
  HTStream_conflict *me;
  char *suffix;
  char fnam [256];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if (traversal != '\0') {
    LYCancelledFetch = '\x01';
    local_128 = (HTStream_conflict3 *)0x0;
    goto LAB_080d0eeb;
  }
  if (pres->quality < 999.0) goto LAB_080d0bc4;
  if (dump_output_immediately != '\0') {
    LYCancelledFetch = '\x01';
    local_128 = (HTStream_conflict3 *)0x0;
    goto LAB_080d0eeb;
  }
  if (no_exec != '\0') {
    pcVar3 = (char *)gettext("Execution is disabled.");
    HTAlert(pcVar3);
    local_128 = HTPlainPresent((HTPresentation_conflict1 *)pres,anchor,(HTStream_conflict3 *)sink);
    goto LAB_080d0eeb;
  }
  if (local_exec == '\0') {
    if (local_exec_on_local_files == '\0') {
LAB_080d0b2d:
      buf = (char *)0x0;
      pcVar3 = key_for_func(0x31);
      fmt = (char *)gettext(
                           "Execution is not enabled for this file.  See the Options menu (use %s)."
                           );
      HTSprintf0(&buf,fmt,pcVar3);
      HTAlert(buf);
      if (buf != (char *)0x0) {
        free(buf);
        buf = (char *)0x0;
      }
      local_128 = HTPlainPresent((HTPresentation_conflict1 *)pres,anchor,(HTStream_conflict3 *)sink)
      ;
      goto LAB_080d0eeb;
    }
    if (LYJumpFileURL == '\0') {
      iVar4 = strncmp(anchor->address,"file://localhost",0x10);
      if (iVar4 != 0) goto LAB_080d0b2d;
    }
  }
LAB_080d0bc4:
  if (dump_output_immediately == '\0') {
    me = (HTStream_conflict *)calloc(1,0x24);
    if (me == (HTStream_conflict *)0x0) {
      outofmem("./HTFWriter.c","HTSaveAndExecute");
    }
    me->isa = &HTFWriter;
    me->last_chunk = (HTChunk *)pres->rep;
    me->actions = (HTStreamClass_conflict *)pres->rep_out;
    me->target = (HTStream_conflict *)anchor;
    me->status = (int)sink;
    BVar2 = LYCachedTemp(fnam,&anchor->FileCache);
    if (BVar2 == '\0') {
      iVar4 = strcasecomp(pres->rep->name,"text/html");
      if (iVar4 == 0) {
        suffix = ".html";
      }
      else {
        iVar4 = strncasecomp(pres->rep->name,"text/",5);
        if (iVar4 == 0) {
          suffix = ".txt";
        }
        else {
          suffix = HTFileSuffix(pres->rep,anchor->content_encoding);
          if ((suffix == (char *)0x0) || (*suffix != '.')) {
            iVar4 = strncasecomp(pres->rep->name,"application/",0xc);
            if (iVar4 == 0) {
              suffix = ".bin";
            }
            else {
              suffix = ".html";
            }
          }
        }
      }
      pHVar5 = (HTParentAnchor *)LYOpenTemp(fnam,suffix,"wb");
      me->anchor = pHVar5;
    }
    else {
      pHVar5 = (HTParentAnchor *)LYOpenTempRewrite(fnam,".bin","wb");
      me->anchor = pHVar5;
    }
    if (me->anchor == (HTParentAnchor *)0x0) {
      pcVar3 = (char *)gettext("Can\'t open temporary file!");
      HTAlert(pcVar3);
      if (me != (HTStream_conflict *)0x0) {
        free(me);
        me = (HTStream_conflict *)0x0;
      }
      local_128 = (HTStream_conflict3 *)0x0;
    }
    else {
      HTSACopy((char **)&me->chunk,pres->command);
      pFVar6 = (FILE *)mailcap_substitute(anchor,pres,fnam);
      me->fp = pFVar6;
      me->filename = (char *)0x0;
      HTAddParam(&me->filename,"%s",1,fnam);
      HTEndParam(&me->filename,"%s",1);
      HTSACopy(&anchor->FileCache,fnam);
      local_128 = (HTStream_conflict3 *)me;
    }
  }
  else {
    local_128 = (HTStream_conflict3 *)HTSaveToFile(pres,anchor,sink);
  }
LAB_080d0eeb:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return (HTStream_conflict *)local_128;
}



HTStream_conflict *
HTSaveToFile(HTPresentation *pres,HTParentAnchor *anchor,HTStream_conflict *sink)

{
  int iVar1;
  LYKeymap_t LVar2;
  BOOLEAN BVar3;
  HTAtom *pHVar4;
  char *pcVar5;
  char *pcVar6;
  HTParentAnchor *pHVar7;
  int iVar8;
  UrlTypes UVar9;
  int in_GS_OFFSET;
  HTStream_conflict *local_13c;
  char *local_138;
  HTStream_conflict *sink_local;
  HTParentAnchor *anchor_local;
  HTPresentation *pres_local;
  char *temp;
  int c;
  char *cp;
  char *suffix;
  HTStream_conflict *ret_obj;
  BOOLEAN IsBinary;
  char fnam [256];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  c = 0;
  IsBinary = '\x01';
  ret_obj = (HTStream_conflict *)calloc(1,0x24);
  if (ret_obj == (HTStream_conflict *)0x0) {
    outofmem("./HTFWriter.c","HTSaveToFile");
  }
  ret_obj->isa = &HTFWriter;
  ret_obj->filename = (char *)0x0;
  ret_obj->fp = (FILE *)0x0;
  ret_obj->last_chunk = (HTChunk *)pres->rep;
  ret_obj->actions = (HTStreamClass_conflict *)pres->rep_out;
  ret_obj->target = (HTStream_conflict *)anchor;
  ret_obj->status = (int)sink;
  if (dump_output_immediately == '\0') {
    LYCancelDownload = '\0';
    pHVar4 = HTAtom_for("www/download");
    if (pHVar4 != HTOutputFormat) {
      if ((traversal != '\0') ||
         (((no_download != '\0' && (override_no_download == '\0')) && (no_disk_save != '\0')))) {
        if (traversal == '\0') {
          pcVar5 = (char *)gettext("This file cannot be displayed on this terminal.");
          HTAlert(pcVar5);
        }
        LYCancelDownload = '\x01';
        if (traversal != '\0') {
          LYCancelledFetch = '\x01';
        }
        if (ret_obj != (HTStream_conflict *)0x0) {
          free(ret_obj);
          ret_obj = (HTStream_conflict *)0x0;
        }
        local_13c = (HTStream_conflict *)0x0;
        goto LAB_080d197d;
      }
      cp = strchr(pres->rep->name,0x3b);
      if ((cp == (char *)0x0) || (pcVar5 = strstr(cp + 1,"charset"), pcVar5 == (char *)0x0)) {
        if (*pres->rep->name == '\0') {
          mustshow = '\x01';
          pcVar5 = (char *)gettext(
                                  "This file cannot be displayed on this terminal:  D)ownload, or C)ancel"
                                  );
          statusline(pcVar5);
        }
        else {
          mustshow = '\x01';
          pcVar5 = pres->rep->name;
          pcVar6 = (char *)gettext("%s  D)ownload, or C)ancel");
          user_message(pcVar6,pcVar5);
        }
      }
      else {
        mustshow = '\x01';
        pcVar5 = pres->rep->name;
        pcVar6 = (char *)gettext("%s  D)ownload, or C)ancel");
        user_message(pcVar6,pcVar5);
      }
      while (((c != 0x44 && (c != 0x43)) && ((c != 3 && (c != 7))))) {
        LVar2 = keymap[0];
        if (c == -1) {
joined_r0x080d11f7:
          if (LVar2 == 0x2f) break;
        }
        else {
          if ((c & 0x8800U) == 0) {
            LVar2 = keymap[(c & 0x7ffU) + 1];
            goto joined_r0x080d11f7;
          }
          if ((c & 0xffU) == 0x2f) break;
        }
        c = LYgetch_single();
      }
      if (((c != 0x43) && (c != 3)) && (c != 7)) {
        LVar2 = keymap[0];
        if (c != -1) {
          if ((c & 0x8800U) != 0) {
            if ((c & 0xffU) != 0x2f) goto LAB_080d1301;
            goto LAB_080d12af;
          }
          LVar2 = keymap[(c & 0x7ffU) + 1];
        }
        if (LVar2 != 0x2f) goto LAB_080d1301;
      }
LAB_080d12af:
      mustshow = '\x01';
      pcVar5 = (char *)gettext("Cancelling file.");
      statusline(pcVar5);
      LYCancelDownload = '\x01';
      if (ret_obj != (HTStream_conflict *)0x0) {
        free(ret_obj);
        ret_obj = (HTStream_conflict *)0x0;
      }
      local_13c = (HTStream_conflict *)0x0;
      goto LAB_080d197d;
    }
LAB_080d1301:
    BVar3 = LYCachedTemp(fnam,&anchor->FileCache);
    if (BVar3 == '\0') {
      iVar8 = strcasecomp(pres->rep->name,"text/html");
      if (iVar8 == 0) {
        suffix = ".html";
      }
      else {
        iVar8 = strncasecomp(pres->rep->name,"text/",5);
        if (iVar8 == 0) {
          suffix = ".txt";
        }
        else {
          iVar8 = strncasecomp(pres->rep->name,"application/",0xc);
          if (iVar8 == 0) {
            suffix = ".bin";
          }
          else {
            suffix = HTFileSuffix(pres->rep,anchor->content_encoding);
            if ((suffix == (char *)0x0) || (*suffix != '.')) {
              suffix = ".html";
            }
          }
        }
      }
      pHVar7 = (HTParentAnchor *)LYOpenTemp(fnam,suffix,"wb");
      ret_obj->anchor = pHVar7;
    }
    else {
      pHVar7 = (HTParentAnchor *)LYOpenTempRewrite(fnam,".bin","wb");
      ret_obj->anchor = pHVar7;
    }
    if (ret_obj->anchor == (HTParentAnchor *)0x0) {
      pcVar5 = (char *)gettext("Can\'t open output file!  Cancelling!");
      HTAlert(pcVar5);
      if (ret_obj != (HTStream_conflict *)0x0) {
        free(ret_obj);
        ret_obj = (HTStream_conflict *)0x0;
      }
      local_13c = (HTStream_conflict *)0x0;
      goto LAB_080d197d;
    }
    iVar8 = strncasecomp(pres->rep->name,"text/",5);
    if (((iVar8 == 0) || (iVar8 = strcasecomp(pres->rep->name,"application/postscript"), iVar8 == 0)
        ) || (iVar8 = strcasecomp(pres->rep->name,"application/x-RUNOFF-MANUAL"), iVar8 == 0)) {
      IsBinary = '\0';
    }
    pcVar5 = pres->rep->name;
    pcVar6 = (char *)gettext("Content-type: %s");
    HTInfoMsg2(pcVar6,pcVar5);
    HTSACopy(&WWW_Download_File,fnam);
    ret_obj->filename = (char *)0x0;
    HTAddParam(&ret_obj->filename,"%s",1,fnam);
    HTEndParam(&ret_obj->filename,"%s",1);
    HTSACopy((char **)&ret_obj->fp,"SaveToFile");
    mustshow = '\x01';
    pcVar5 = (char *)gettext("Retrieving file.  - PLEASE WAIT -");
    statusline(pcVar5);
    HTSACopy(&anchor->FileCache,fnam);
  }
  else {
    ret_obj->anchor = stdout;
    pHVar4 = HTAtom_for("www/download");
    if (pHVar4 != HTOutputFormat) {
      local_13c = ret_obj;
      goto LAB_080d197d;
    }
  }
  if (((LYPrependBaseToSource != '\0') &&
      (iVar8 = strncasecomp(pres->rep->name,"text/html",9), iVar8 == 0)) &&
     (anchor->content_encoding == (char *)0x0)) {
    temp = (char *)0x0;
    if ((anchor->content_base == (char *)0x0) || (*anchor->content_base == '\0')) {
      if ((anchor->content_location != (char *)0x0) && (*anchor->content_location != '\0')) {
        HTSACopy(&temp,anchor->content_location);
      }
    }
    else {
      HTSACopy(&temp,anchor->content_base);
    }
    if (temp != (char *)0x0) {
      LYRemoveBlanks(temp);
      UVar9 = is_url(temp);
      if ((UVar9 == NOT_A_URL_TYPE) && (temp != (char *)0x0)) {
        free(temp);
        temp = (char *)0x0;
      }
    }
    fprintf((FILE *)ret_obj->anchor,"<!-- X-URL: %s -->\n",anchor->address);
    if (((((anchor->date != (char *)0x0) && (*anchor->date != '\0')) &&
         (fprintf((FILE *)ret_obj->anchor,"<!-- Date: %s -->\n",anchor->date),
         anchor->last_modified != (char *)0x0)) &&
        ((*anchor->last_modified != '\0' &&
         (iVar8 = strcmp(anchor->last_modified,anchor->date), iVar8 != 0)))) &&
       (iVar8 = strcmp(anchor->last_modified,"Thu, 01 Jan 1970 00:00:01 GMT"), iVar8 != 0)) {
      fprintf((FILE *)ret_obj->anchor,"<!-- Last-Modified: %s -->\n",anchor->last_modified);
    }
    if (temp == (char *)0x0) {
      local_138 = anchor->address;
    }
    else {
      local_138 = temp;
    }
    fprintf((FILE *)ret_obj->anchor,"<BASE HREF=\"%s\">\n\n",local_138);
    if (temp != (char *)0x0) {
      free(temp);
      temp = (char *)0x0;
    }
  }
  if (((LYPrependCharsetToSource != '\0') &&
      (iVar8 = strncasecomp(pres->rep->name,"text/html",9), iVar8 == 0)) &&
     (anchor->content_encoding == (char *)0x0)) {
    temp = (char *)0x0;
    if ((anchor->charset != (char *)0x0) && (*anchor->charset != '\0')) {
      HTSACopy(&temp,anchor->charset);
      LYRemoveBlanks(temp);
      fprintf((FILE *)ret_obj->anchor,
              "<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=%s\">\n\n",temp);
    }
    if (temp != (char *)0x0) {
      free(temp);
      temp = (char *)0x0;
    }
  }
  local_13c = ret_obj;
LAB_080d197d:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return local_13c;
}



HTStream_conflict *
HTCompressed(HTPresentation *pres,HTParentAnchor *anchor,HTStream_conflict *sink)

{
  int iVar1;
  HTAtom *pHVar2;
  CompressFileType CVar3;
  char *pcVar4;
  HTAtom *pHVar5;
  int iVar6;
  size_t sVar7;
  HTParentAnchor *pHVar8;
  int in_GS_OFFSET;
  undefined *__src;
  size_t __n;
  HTStream_conflict *local_25c;
  HTStream_conflict *sink_local;
  HTParentAnchor *anchor_local;
  HTPresentation *pres_local;
  char *program;
  char *middle;
  char *compress_suffix;
  char *uncompress_mask;
  char *suffix;
  int i;
  int n;
  HTPresentation *Pnow;
  HTPresentation *Pres;
  char *type;
  HTFormat format;
  HTStream_conflict *me;
  BOOLEAN can_present;
  char temp [256];
  char fnam [256];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  type = (char *)0x0;
  Pres = (HTPresentation *)0x0;
  Pnow = (HTPresentation *)0x0;
  can_present = '\0';
  uncompress_mask = (char *)0x0;
  compress_suffix = "";
  if (((anchor == (HTParentAnchor *)0x0) || (anchor->content_encoding == (char *)0x0)) ||
     (anchor->content_type == (char *)0x0)) {
    format = HTAtom_for("application/octet-stream");
    local_25c = (HTStream_conflict *)
                HTStreamStack(format,pres->rep_out,(HTStream_conflict4 *)sink,anchor);
    me = local_25c;
  }
  else {
    n = HTList_count(HTPresentations);
    for (i = 0; i < n; i = i + 1) {
      Pnow = (HTPresentation *)HTList_objectAt(HTPresentations,i);
      iVar6 = strcasecomp(Pnow->rep->name,anchor->content_type);
      if (((iVar6 == 0) &&
          (pHVar5 = Pnow->rep_out, pHVar2 = HTAtom_for("www/present"), pHVar5 == pHVar2)) &&
         ((Pres == (HTPresentation *)0x0 || (Pres->quality <= Pnow->quality)))) {
        Pres = Pnow;
        can_present = '\x01';
        CVar3 = HTEncodingToCompressType(anchor->content_encoding);
        if (CVar3 == cftGzip) {
          pcVar4 = HTGetProgramPath(ppGZIP);
          if (pcVar4 != (char *)0x0) {
            HTSACopy(&uncompress_mask,pcVar4);
            HTSACat(&uncompress_mask," -d --no-name %s");
            compress_suffix = "gz";
          }
        }
        else if (CVar3 < cftBzip2) {
          if ((CVar3 == cftCompress) &&
             (pcVar4 = HTGetProgramPath(ppUNCOMPRESS), pcVar4 != (char *)0x0)) {
            HTSACopy(&uncompress_mask,pcVar4);
            HTSACat(&uncompress_mask," %s");
            compress_suffix = "Z";
          }
        }
        else if (CVar3 == cftBzip2) {
          pcVar4 = HTGetProgramPath(ppBZIP2);
          if (pcVar4 != (char *)0x0) {
            HTSACopy(&uncompress_mask,pcVar4);
            HTSACat(&uncompress_mask," -d %s");
            compress_suffix = "bz2";
          }
        }
        else if ((CVar3 == cftDeflate) &&
                (pcVar4 = HTGetProgramPath(ppINFLATE), pcVar4 != (char *)0x0)) {
          HTSACopy(&uncompress_mask,pcVar4);
          HTSACat(&uncompress_mask," %s");
          compress_suffix = "zz";
        }
      }
    }
    if (((((can_present == '\0') || (uncompress_mask == (char *)0x0)) ||
         (pcVar4 = strchr(anchor->content_type,0x3b), pcVar4 != (char *)0x0)) ||
        ((pHVar5 = HTAtom_for("www/download"), pHVar5 == HTOutputFormat ||
         (iVar6 = strcasecomp(pres->rep_out->name,"www/download"), iVar6 == 0)))) ||
       ((traversal != '\0' &&
        ((iVar6 = strcasecomp(anchor->content_type,"text/html"), iVar6 != 0 &&
         (iVar6 = strcasecomp(anchor->content_type,"text/plain"), iVar6 != 0)))))) {
      pcVar4 = strchr(anchor->content_encoding,0x2f);
      if (pcVar4 == (char *)0x0) {
        iVar6 = strncasecomp(anchor->content_encoding,"x-",2);
        if (iVar6 == 0) {
          HTSACopy(&type,"application/");
        }
        else {
          HTSACopy(&type,"application/x-");
        }
        HTSACat(&type,anchor->content_encoding);
      }
      else {
        HTSACopy(&type,anchor->content_encoding);
      }
      format = HTAtom_for(type);
      if (type != (char *)0x0) {
        free(type);
        type = (char *)0x0;
      }
      if (uncompress_mask != (char *)0x0) {
        free(uncompress_mask);
        uncompress_mask = (char *)0x0;
      }
      local_25c = (HTStream_conflict *)
                  HTStreamStack(format,pres->rep_out,(HTStream_conflict4 *)sink,anchor);
      me = local_25c;
    }
    else {
      me = (HTStream_conflict *)calloc(1,0x24);
      if (me == (HTStream_conflict *)0x0) {
        outofmem("./HTFWriter.c","HTCompressed");
      }
      me->isa = &HTFWriter;
      me->last_chunk = (HTChunk *)pres->rep;
      me->actions = (HTStreamClass_conflict *)pres->rep_out;
      me->target = (HTStream_conflict *)anchor;
      me->status = (int)sink;
      if ((anchor->FileCache != (char *)0x0) &&
         (LYRemoveTemp(anchor->FileCache), anchor->FileCache != (char *)0x0)) {
        free(anchor->FileCache);
        anchor->FileCache = (char *)0x0;
      }
      middle = (char *)0x0;
      iVar6 = strcasecomp(anchor->content_type,"text/html");
      if (iVar6 == 0) {
        middle = "html";
      }
      else {
        iVar6 = strncasecomp(anchor->content_type,"text/",5);
        if (iVar6 == 0) {
          middle = "txt";
        }
        else {
          iVar6 = strncasecomp(anchor->content_type,"application/",0xc);
          if (iVar6 == 0) {
            middle = "bin";
          }
          else {
            pHVar5 = HTAtom_for(anchor->content_type);
            suffix = HTFileSuffix(pHVar5,(char *)0x0);
            if ((suffix != (char *)0x0) && (*suffix == '.')) {
              middle = suffix + 1;
            }
          }
        }
      }
      temp[0] = '\0';
      if (middle != (char *)0x0) {
        __n = 2;
        __src = &DAT_0816744b;
        sVar7 = strlen(temp);
        memcpy(temp + sVar7,__src,__n);
        strcat(temp,middle);
        strcat(temp,".");
      }
      strcat(temp,compress_suffix);
      pHVar8 = (HTParentAnchor *)LYOpenTemp(fnam,temp,"wb");
      me->anchor = pHVar8;
      if (me->anchor == (HTParentAnchor *)0x0) {
        pcVar4 = (char *)gettext("Can\'t open temporary file!");
        HTAlert(pcVar4);
        if (uncompress_mask != (char *)0x0) {
          free(uncompress_mask);
          uncompress_mask = (char *)0x0;
        }
        if (me != (HTStream_conflict *)0x0) {
          free(me);
          me = (HTStream_conflict *)0x0;
        }
        local_25c = (HTStream_conflict *)0x0;
      }
      else {
        if (((dump_output_immediately == '\0') && (traversal == '\0')) &&
           ((Pres->quality < 999.0 ||
            ((no_exec == '\0' &&
             ((local_exec != '\0' ||
              ((local_exec_on_local_files != '\0' &&
               ((LYJumpFileURL != '\0' ||
                (iVar6 = strncmp(anchor->address,"file://localhost",0x10), iVar6 == 0)))))))))))) {
          HTSACopy((char **)&me->chunk,Pres->command);
        }
        if ((*compress_suffix == 'g') && (me->chunk == (HTChunk *)0x0)) {
          HTSACopy((char **)&me->fp,"");
        }
        else {
          me->fp = (FILE *)0x0;
          HTAddParam((char **)&me->fp,uncompress_mask,1,fnam);
          HTEndParam((char **)&me->fp,uncompress_mask,1);
        }
        if (uncompress_mask != (char *)0x0) {
          free(uncompress_mask);
          uncompress_mask = (char *)0x0;
        }
        me->filename = (char *)0x0;
        HTAddParam(&me->filename,"%s",1,fnam);
        HTEndParam(&me->filename,"%s",1);
        HTSACopy(&anchor->FileCache,fnam);
        local_25c = me;
      }
    }
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return local_25c;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

HTStream_conflict *
HTDumpToStdout(HTPresentation *pres,HTParentAnchor *anchor,HTStream_conflict *sink)

{
  HTStream_conflict *pHVar1;
  HTStream_conflict *ret_obj;
  
  pHVar1 = (HTStream_conflict *)calloc(1,0x24);
  if (pHVar1 == (HTStream_conflict *)0x0) {
    outofmem("./HTFWriter.c","HTDumpToStdout");
  }
  pHVar1->isa = &HTFWriter;
  pHVar1->filename = (char *)0x0;
  pHVar1->fp = (FILE *)0x0;
  pHVar1->target = (HTStream_conflict *)anchor;
  pHVar1->anchor = stdout;
  return pHVar1;
}



// WARNING: Unknown calling convention

void HTFormatInit(void)

{
  BOOLEAN BVar1;
  FILE *__stream;
  char *pcVar2;
  HTAtom *pHVar3;
  HTAtom *pHVar4;
  AcceptMedia media;
  
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"HTFormatInit\n");
  }
  pcVar2 = LYgetXDisplay();
  if (pcVar2 != (char *)0x0) {
    HTSetPresentation("application/postscript","ghostview %s&",(char *)0x0,1.0,3.0,0.0,0,mediaEXT);
    if ((XLoadImageCommand != (char *)0x0) && (*XLoadImageCommand != '\0')) {
      HTSetPresentation("image/gif",XLoadImageCommand,(char *)0x0,1.0,3.0,0.0,0,mediaEXT);
      HTSetPresentation("image/x-xbm",XLoadImageCommand,(char *)0x0,1.0,3.0,0.0,0,mediaEXT);
      HTSetPresentation("image/x-xbitmap",XLoadImageCommand,(char *)0x0,1.0,3.0,0.0,0,mediaEXT);
      HTSetPresentation("image/x-png",XLoadImageCommand,(char *)0x0,2.0,3.0,0.0,0,mediaEXT);
      HTSetPresentation("image/png",XLoadImageCommand,(char *)0x0,1.0,3.0,0.0,0,mediaEXT);
      HTSetPresentation("image/x-rgb",XLoadImageCommand,(char *)0x0,1.0,3.0,0.0,0,mediaEXT);
      HTSetPresentation("image/x-tiff",XLoadImageCommand,(char *)0x0,2.0,3.0,0.0,0,mediaEXT);
      HTSetPresentation("image/tiff",XLoadImageCommand,(char *)0x0,1.0,3.0,0.0,0,mediaEXT);
      HTSetPresentation("image/jpeg",XLoadImageCommand,(char *)0x0,1.0,3.0,0.0,0,mediaEXT);
    }
    HTSetPresentation("video/mpeg","mpeg_play %s &",(char *)0x0,1.0,3.0,0.0,0,mediaEXT);
  }
  HTSetPresentation("application/x-csh","csh %s",(char *)0x0,999.0,3.0,0.0,0,mediaEXT);
  HTSetPresentation("application/x-sh","sh %s",(char *)0x0,999.0,3.0,0.0,0,mediaEXT);
  HTSetPresentation("application/x-ksh","ksh %s",(char *)0x0,999.0,3.0,0.0,0,mediaEXT);
  HTSetConversion("message/x-http-redirection","*",HTMIMERedirect,2.0,0.0,0.0,0,mediaINT);
  HTSetConversion("message/x-http-redirection","www/present",HTMIMERedirect,2.0,0.0,0.0,0,mediaINT);
  HTSetConversion("message/x-http-redirection","www/debug",HTMIMERedirect,1.0,0.0,0.0,0,mediaINT);
  HTSetConversion("www/mime","www/present",HTMIMEConvert,1.0,0.0,0.0,0,mediaINT);
  HTSetConversion("www/mime","www/download",HTMIMEConvert,1.0,0.0,0.0,0,mediaINT);
  HTSetConversion("www/mime","www/source",HTMIMEConvert,1.0,0.0,0.0,0,mediaINT);
  HTSetConversion("www/mime","www/dump",HTMIMEConvert,1.0,0.0,0.0,0,mediaINT);
  HTSetConversion("www/compressed","www/download",HTCompressed,1.0,0.0,0.0,0,mediaINT);
  HTSetConversion("www/compressed","www/present",HTCompressed,1.0,0.0,0.0,0,mediaINT);
  HTSetConversion("www/compressed","www/source",HTCompressed,1.0,0.0,0.0,0,mediaINT);
  HTSetConversion("www/compressed","www/dump",HTCompressed,1.0,0.0,0.0,0,mediaINT);
  HTSetConversion("application/html","text/x-c",HTMLToC,0.5,0.0,0.0,0,mediaINT);
  HTSetConversion("application/html","text/plain",HTMLToPlain,0.5,0.0,0.0,0,mediaINT);
  HTSetConversion("text/css","text/plain",HTMLToPlain,0.5,0.0,0.0,0,mediaINT);
  HTSetConversion("application/html","www/present",HTMLPresent,2.0,0.0,0.0,0,mediaINT);
  HTSetConversion("application/xhtml+xml","www/present",HTMLPresent,2.0,0.0,0.0,0,mediaINT);
  HTSetConversion("application/xml","www/present",HTMLPresent,2.0,0.0,0.0,0,mediaINT);
  HTSetConversion("application/html","www/source",HTPlainPresent,1.0,0.0,0.0,0,mediaINT);
  HTSetConversion("application/x-wais-source","www/source",HTPlainPresent,1.0,0.0,0.0,0,mediaINT);
  HTSetConversion("application/x-wais-source","www/present",HTWSRCConvert,2.0,0.0,0.0,0,mediaINT);
  HTSetConversion("application/x-wais-source","www/download",HTWSRCConvert,1.0,0.0,0.0,0,mediaINT);
  HTSetConversion("application/x-wais-source","www/dump",HTWSRCConvert,1.0,0.0,0.0,0,mediaINT);
  HTSetConversion("www/source","www/present",HTSaveToFile,1.0,3.0,0.0,0,mediaEXT);
  HTSetConversion("www/source","www/source",HTSaveToFile,1.0,3.0,0.0,0,mediaEXT);
  HTSetConversion("www/source","www/download",HTSaveToFile,1.0,3.0,0.0,0,mediaEXT);
  HTSetConversion("www/source","*",HTSaveToFile,1.0,3.0,0.0,0,mediaEXT);
  HTSetConversion("www/source","www/dump",HTDumpToStdout,1.0,3.0,0.0,0,mediaEXT);
  HTSetConversion("text/x-sgml","www/source",HTPlainPresent,1.0,0.0,0.0,0,mediaINT);
  HTSetConversion("text/x-sgml","www/present",HTMLPresent,2.0,0.0,0.0,0,mediaINT);
  HTSetConversion("text/sgml","www/source",HTPlainPresent,1.0,0.0,0.0,0,mediaINT);
  HTSetConversion("text/sgml","www/present",HTMLPresent,1.0,0.0,0.0,0,mediaINT);
  HTSetConversion("text/css","www/present",HTPlainPresent,1.0,0.0,0.0,0,mediaINT);
  HTSetConversion("text/plain","www/present",HTPlainPresent,1.0,0.0,0.0,0,mediaINT);
  HTSetConversion("text/plain","www/source",HTPlainPresent,1.0,0.0,0.0,0,mediaINT);
  HTSetConversion("text/html","www/source",HTPlainPresent,1.0,0.0,0.0,0,mediaINT);
  HTSetConversion("text/html","text/x-c",HTMLToC,0.5,0.0,0.0,0,mediaINT);
  HTSetConversion("text/html","text/plain",HTMLToPlain,0.5,0.0,0.0,0,mediaINT);
  HTSetConversion("text/html","www/present",HTMLPresent,1.0,0.0,0.0,0,mediaINT);
  HTSetConversion("text/xml","www/present",HTMLPresent,2.0,0.0,0.0,0,mediaINT);
  BVar1 = LYisAbsPath(global_type_map);
  if (BVar1 != '\0') {
    HTLoadTypesConfigFile(global_type_map,mediaSYS);
  }
  pcVar2 = LYAbsOrHomePath(&personal_type_map);
  BVar1 = IsOurFile(pcVar2);
  if (BVar1 != '\0') {
    BVar1 = LYCanReadFile(personal_type_map);
    if (BVar1 != '\0') {
      HTLoadTypesConfigFile(personal_type_map,mediaUSR);
    }
  }
  pHVar3 = HTAtom_for("www/present");
  pHVar4 = HTAtom_for("text/plain");
  HTReorderPresentation(pHVar4,pHVar3);
  pHVar3 = HTAtom_for("www/present");
  pHVar4 = HTAtom_for("text/html");
  HTReorderPresentation(pHVar4,pHVar3);
  HTFilterPresentations();
  return;
}



// WARNING: Unknown calling convention

void HTPreparsedFormatInit(void)

{
  FILE *__stream;
  
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"HTPreparsedFormatInit\n");
  }
  if (LYPreparsedSource != '\0') {
    HTSetConversion("text/html","www/source",HTMLParsedPresent,1.0,0.0,0.0,0,mediaINT);
    HTSetConversion("text/html","www/dump",HTMLParsedPresent,1.0,0.0,0.0,0,mediaINT);
  }
  return;
}



// WARNING: Unknown calling convention

char * GetCommand(char *s,char **t)

{
  bool bVar1;
  size_t sVar2;
  char *txt;
  int quoted;
  char *s2;
  
  bVar1 = false;
  s = LYSkipBlanks(s);
  sVar2 = strlen(s);
  s2 = (char *)malloc(sVar2 * 2 + 1);
  if (s2 == (char *)0x0) {
    txt = (char *)gettext("Memory exhausted!  Program aborted!");
    ExitWithError(txt);
  }
  *t = s2;
  while ((s != (char *)0x0 && (*s != '\0'))) {
    if (bVar1) {
      if (*s == '%') {
        *s2 = '%';
        s2 = s2 + 1;
      }
      *s2 = *s;
      s2 = s2 + 1;
      s = s + 1;
      bVar1 = false;
    }
    else {
      if (*s == ';') {
        *s2 = '\0';
        return s + 1;
      }
      if (*s == '\\') {
        bVar1 = true;
        s = s + 1;
      }
      else {
        *s2 = *s;
        s2 = s2 + 1;
        s = s + 1;
      }
    }
  }
  *s2 = '\0';
  return (char *)0x0;
}



// WARNING: Unknown calling convention

char * Cleanse(char *s)

{
  LYTrimLeading(s);
  LYTrimTrailing(s);
  LYLowerCase(s);
  return s;
}



// WARNING: Unknown calling convention

void TrimCommand(char *command)

{
  bool bVar1;
  bool bVar2;
  bool bVar3;
  int c0;
  int ch;
  char *d;
  char *s;
  BOOLEAN squote;
  BOOLEAN dquote;
  BOOLEAN escape;
  
  LYTrimTrailing(command);
  s = command;
  d = command;
  c0 = 0x20;
  bVar1 = false;
  bVar3 = false;
  bVar2 = false;
LAB_080d36f2:
  ch = (int)*s;
  s = s + 1;
  if (ch == 0) {
    *d = '\0';
    return;
  }
  if (bVar1) {
    bVar1 = false;
  }
  else if (bVar2) {
    if (ch == 0x27) {
      bVar2 = false;
    }
  }
  else if (bVar3) {
    if (ch == 0x22) {
      bVar3 = false;
    }
  }
  else if (ch == 0x27) {
    bVar2 = true;
  }
  else if (ch == 0x5c) {
    if (bVar3) {
      bVar1 = true;
    }
  }
  else if (ch == 0x22) {
    bVar3 = true;
  }
  if (((!bVar1) && (!bVar3)) && (!bVar2)) goto code_r0x080d36c5;
  goto LAB_080d36de;
code_r0x080d36c5:
  if (ch == 9) {
    ch = 0x20;
  }
  if ((ch != 0x20) || (c0 != 0x20)) {
LAB_080d36de:
    *d = (char)ch;
    d = d + 1;
    c0 = ch;
  }
  goto LAB_080d36f2;
}



// WARNING: Unknown calling convention

int ProcessMailcapEntry(FILE *fp,MailcapEntry *mc,AcceptMedia media)

{
  char *pcVar1;
  char *pcVar2;
  size_t sVar3;
  FILE *pFVar4;
  int iVar5;
  long lVar6;
  double dVar7;
  char *mallocd_string;
  char *eq;
  char *arg;
  char *LineBuf;
  char *t;
  char *s;
  char *rawentry;
  size_t need;
  size_t len;
  size_t rawentryalloc;
  
  rawentryalloc = 2000;
  LineBuf = (char *)0x0;
  rawentry = (char *)malloc(2000);
  if (rawentry == (char *)0x0) {
    pcVar2 = (char *)gettext("Memory exhausted!  Program aborted!");
    ExitWithError(pcVar2);
  }
  *rawentry = '\0';
  do {
    do {
      pcVar2 = LYSafeGets(&LineBuf,fp);
      if (pcVar2 == (char *)0x0) {
LAB_080d385c:
        if (LineBuf != (char *)0x0) {
          free(LineBuf);
          LineBuf = (char *)0x0;
        }
        t = LYSkipBlanks(rawentry);
        s = t;
        if (*t == '\0') {
          if (rawentry != (char *)0x0) {
            free(rawentry);
          }
        }
        else {
          s = strchr(rawentry,0x3b);
          if (s == (char *)0x0) {
            if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
              pFVar4 = TraceFP();
              fprintf((FILE *)pFVar4,"ProcessMailcapEntry: Ignoring invalid mailcap entry: %s\n",
                      rawentry);
            }
            if (rawentry != (char *)0x0) {
              free(rawentry);
            }
          }
          else {
            *s = '\0';
            s = s + 1;
            iVar5 = strncasecomp(t,"text/html",9);
            if ((iVar5 != 0) && (iVar5 = strncasecomp(t,"text/plain",10), iVar5 != 0)) {
              LYRemoveBlanks(rawentry);
              LYLowerCase(rawentry);
              mc->needsterminal = 0;
              mc->copiousoutput = 0;
              mc->needtofree = 1;
              mc->testcommand = (char *)0x0;
              mc->label = (char *)0x0;
              mc->printcommand = (char *)0x0;
              mc->contenttype = (char *)0x0;
              HTSACopy(&mc->contenttype,rawentry);
              mc->quality = 1.0;
              mc->maxbytes = 0;
              t = GetCommand(s,&mc->command);
              if (t != (char *)0x0) {
                s = LYSkipBlanks(t);
                while (s != (char *)0x0) {
                  t = GetCommand(s,&mallocd_string);
                  arg = mallocd_string;
                  eq = strchr(mallocd_string,0x3d);
                  if (eq != (char *)0x0) {
                    *eq = '\0';
                    eq = eq + 1;
                    eq = LYSkipBlanks(eq);
                  }
                  if ((arg != (char *)0x0) && (*arg != '\0')) {
                    arg = Cleanse(arg);
                    iVar5 = strcmp(arg,"needsterminal");
                    if (iVar5 == 0) {
                      mc->needsterminal = 1;
                    }
                    else {
                      iVar5 = strcmp(arg,"copiousoutput");
                      if (iVar5 == 0) {
                        mc->copiousoutput = 1;
                      }
                      else if ((eq == (char *)0x0) || (iVar5 = strcmp(arg,"test"), iVar5 != 0)) {
                        if ((eq == (char *)0x0) || (iVar5 = strcmp(arg,"description"), iVar5 != 0))
                        {
                          if ((eq == (char *)0x0) || (iVar5 = strcmp(arg,"label"), iVar5 != 0)) {
                            if ((eq == (char *)0x0) || (iVar5 = strcmp(arg,"print"), iVar5 != 0)) {
                              if ((eq == (char *)0x0) ||
                                 (iVar5 = strcmp(arg,"textualnewlines"), iVar5 != 0)) {
                                if ((eq == (char *)0x0) || (iVar5 = strcmp(arg,"q"), iVar5 != 0)) {
                                  if ((eq == (char *)0x0) || (iVar5 = strcmp(arg,"mxb"), iVar5 != 0)
                                     ) {
                                    iVar5 = strcmp(arg,"notes");
                                    if ((iVar5 != 0) &&
                                       (((*arg != '\0' && (WWW_TraceFlag != '\0')) &&
                                        ((WWW_TraceMask & 8U) != 0)))) {
                                      pFVar4 = TraceFP();
                                      fprintf((FILE *)pFVar4,
                                              "ProcessMailcapEntry: Ignoring mailcap flag \'%s\'.\n"
                                              ,arg);
                                    }
                                  }
                                  else {
                                    lVar6 = atol(eq);
                                    mc->maxbytes = lVar6;
                                    if (mc->maxbytes < 0) {
                                      mc->maxbytes = 0;
                                    }
                                  }
                                }
                                else {
                                  dVar7 = atof(eq);
                                  mc->quality = (float)dVar7;
                                  if ((0.0 < mc->quality) && (mc->quality < 0.001)) {
                                    mc->quality = 0.001;
                                  }
                                }
                              }
                            }
                            else {
                              mc->printcommand = eq;
                            }
                          }
                          else {
                            mc->label = eq;
                          }
                        }
                        else {
                          mc->label = eq;
                        }
                      }
                      else {
                        mc->testcommand = (char *)0x0;
                        HTSACopy(&mc->testcommand,eq);
                        TrimCommand(mc->testcommand);
                        if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
                          pcVar2 = mc->testcommand;
                          pFVar4 = TraceFP();
                          fprintf((FILE *)pFVar4,"ProcessMailcapEntry: Found testcommand:%s\n",
                                  pcVar2);
                        }
                      }
                    }
                  }
                  if (mallocd_string != (char *)0x0) {
                    free(mallocd_string);
                    mallocd_string = (char *)0x0;
                  }
                  s = t;
                }
              }
              if (rawentry != (char *)0x0) {
                free(rawentry);
                rawentry = (char *)0x0;
              }
              iVar5 = PassesTest(mc);
              if (iVar5 != 0) {
                if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
                  pcVar2 = mc->command;
                  pcVar1 = mc->contenttype;
                  pFVar4 = TraceFP();
                  fprintf((FILE *)pFVar4,"ProcessMailcapEntry Setting up conversion %s : %s\n",
                          pcVar1,pcVar2);
                }
                HTSetPresentation(mc->contenttype,mc->command,mc->testcommand,(double)mc->quality,
                                  3.0,0.0,mc->maxbytes,media);
              }
              if (mc->command != (char *)0x0) {
                free(mc->command);
                mc->command = (char *)0x0;
              }
              if (mc->testcommand != (char *)0x0) {
                free(mc->testcommand);
                mc->testcommand = (char *)0x0;
              }
              if (mc->contenttype != (char *)0x0) {
                free(mc->contenttype);
                mc->contenttype = (char *)0x0;
              }
              return 1;
            }
            s = s + -1;
            *s = ';';
            if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
              pFVar4 = TraceFP();
              fprintf((FILE *)pFVar4,"ProcessMailcapEntry: Ignoring mailcap entry: %s\n",rawentry);
            }
            if (rawentry != (char *)0x0) {
              free(rawentry);
            }
          }
        }
        return 0;
      }
      LYTrimNewline(LineBuf);
    } while ((*LineBuf == '#') || (*LineBuf == '\0'));
    len = strlen(LineBuf);
    sVar3 = strlen(rawentry);
    need = sVar3 + len + 1;
    if (rawentryalloc < need) {
      rawentryalloc = need + rawentryalloc + 2000;
      rawentry = (char *)realloc(rawentry,rawentryalloc);
      if (rawentry == (char *)0x0) {
        pcVar2 = (char *)gettext("Memory exhausted!  Program aborted!");
        ExitWithError(pcVar2);
      }
    }
    if ((len == 0) || (LineBuf[len - 1] != '\\')) {
      strcat(rawentry,LineBuf);
      goto LAB_080d385c;
    }
    LineBuf[len - 1] = '\0';
    strcat(rawentry,LineBuf);
  } while( true );
}



// WARNING: Unknown calling convention

char * LYSkipQuoted(char *s)

{
  bool bVar1;
  int escaped;
  
  bVar1 = false;
  s = s + 1;
  do {
    if (*s == '\0') {
      return s;
    }
    if (bVar1) {
      bVar1 = false;
    }
    else if (*s == '\\') {
      bVar1 = true;
    }
    else if (*s == '\"') {
      return s + 1;
    }
    s = s + 1;
  } while( true );
}



// WARNING: Unknown calling convention

char * LYSkipToken(char *s)

{
  char *pcVar1;
  
  for (; (*s != '\0' && (0x20 < (byte)*s)); s = s + 1) {
    pcVar1 = strchr("\"()<>@,;:\\/[]?.=",(int)*s);
    if (pcVar1 != (char *)0x0) {
      return s;
    }
  }
  return s;
}



// WARNING: Unknown calling convention

char * LYSkipValue(char *s)

{
  if (*s == '\"') {
    s = LYSkipQuoted(s);
  }
  else {
    s = LYSkipToken(s);
  }
  return s;
}



// WARNING: Unknown calling convention

char * LYCopyValue(char *s)

{
  int k;
  int j;
  char *result;
  char *t;
  
  result = (char *)0x0;
  if (*s == '\"') {
    t = LYSkipQuoted(s);
    HTSACopy(&result,s + 1);
    result[(int)(t + (-2 - (int)s))] = '\0';
    k = 0;
    j = 0;
    while( true ) {
      if (result[j] == '\\') {
        j = j + 1;
      }
      result[k] = result[j];
      if (result[k] == '\0') break;
      j = j + 1;
      k = k + 1;
    }
  }
  else {
    t = LYSkipToken(s);
    HTSACopy(&result,s);
    result[(int)t - (int)s] = '\0';
  }
  return result;
}



// WARNING: Unknown calling convention

char * LYGetContentType(char *name,char *params)

{
  size_t __n;
  char *pcVar1;
  char *buffer;
  int iVar2;
  char *next;
  char *test;
  size_t length;
  char *result;
  BOOLEAN found;
  
  result = (char *)0x0;
  if (params != (char *)0x0) {
    if (name == (char *)0x0) {
      HTSACopy(&result,params);
      pcVar1 = LYSkipNonBlanks(result);
      *pcVar1 = '\0';
    }
    else {
      __n = strlen(name);
      test = strchr(params,0x3b);
      do {
        if (test == (char *)0x0) {
          return result;
        }
        found = '\0';
        pcVar1 = LYSkipCBlanks(test + 1);
        buffer = LYSkipToken(pcVar1);
        if (((int)buffer - (int)pcVar1 == __n) && (iVar2 = strncmp(pcVar1,name,__n), iVar2 == 0)) {
          found = '\x01';
        }
        test = LYSkipCBlanks(buffer);
        if (*test == '=') {
          pcVar1 = LYSkipCBlanks(test + 1);
          if (found != '\0') {
            pcVar1 = LYCopyValue(pcVar1);
            return pcVar1;
          }
          pcVar1 = LYSkipValue(pcVar1);
          test = LYSkipCBlanks(pcVar1);
        }
      } while (*test == ';');
    }
  }
  return result;
}



// WARNING: Unknown calling convention

BOOLEAN LYMailcapUsesPctS(char *controlstring)

{
  char cVar1;
  bool bVar2;
  bool bVar3;
  char *pcVar4;
  int escaped;
  int prefixed;
  char *next;
  char *from;
  int result;
  
  result = 0;
  bVar3 = false;
  bVar2 = false;
  for (from = controlstring; *from != '\0'; from = from + 1) {
    if (bVar2) {
      bVar2 = false;
    }
    else if (*from == '\\') {
      bVar2 = true;
    }
    else if (bVar3) {
      bVar3 = false;
      cVar1 = *from;
      if (((cVar1 != 'n') && ('n' < cVar1)) && (cVar1 != 't')) {
        if (cVar1 == '{') {
          pcVar4 = strchr(from,0x7d);
          if (pcVar4 != (char *)0x0) {
            from = pcVar4;
          }
        }
        else if (cVar1 == 's') {
          result = 1;
        }
      }
    }
    else if (*from == '%') {
      bVar3 = true;
    }
  }
  return (BOOLEAN)result;
}



// WARNING: Unknown calling convention

int BuildCommand(HTChunk *cmd,char *controlstring,char *TmpFileName,char *params)

{
  char cVar1;
  bool bVar2;
  bool bVar3;
  char *pcVar4;
  int iVar5;
  FILE *pFVar6;
  int escaped;
  int prefixed;
  char *value;
  char *name;
  char *next;
  char *from;
  size_t TmpFileLen;
  int result;
  
  result = 0;
  TmpFileLen = strlen(TmpFileName);
  bVar3 = false;
  bVar2 = false;
  from = controlstring;
  do {
    if (*from == '\0') {
      HTChunkTerminate(cmd);
      return result;
    }
    if (bVar2) {
      bVar2 = false;
      HTChunkPutc(cmd,*from);
    }
    else if (*from == '\\') {
      bVar2 = true;
    }
    else if (bVar3) {
      bVar3 = false;
      cVar1 = *from;
      if (cVar1 == 'n') {
LAB_080d4396:
        if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
          pFVar6 = TraceFP();
          fprintf((FILE *)pFVar6,"BuildCommand: Bad mailcap \"test\" clause: %s\n",controlstring);
        }
      }
      else if (cVar1 < 'o') {
        if (cVar1 != '%') {
          if (cVar1 != 'F') goto LAB_080d4583;
          goto LAB_080d4396;
        }
        HTChunkPutc(cmd,*from);
      }
      else if (cVar1 == 't') {
        pcVar4 = LYGetContentType((char *)0x0,params);
        if ((pcVar4 != (char *)0x0) && (HTChunkPuts(cmd,pcVar4), pcVar4 != (char *)0x0)) {
          free(pcVar4);
        }
      }
      else if (cVar1 == '{') {
        next = strchr(from,0x7d);
        if (next == (char *)0x0) goto LAB_080d4583;
        if (params == (char *)0x0) {
          result = -1;
        }
        else {
          from = from + 1;
          name = (char *)0x0;
          HTSprintf0(&name,"%.*s",(int)next - (int)from,from);
          pcVar4 = LYGetContentType(name,params);
          if (pcVar4 == (char *)0x0) {
            iVar5 = strcmp(name,"charset");
            pcVar4 = name;
            if (iVar5 == 0) {
              HTChunkPuts(cmd,"ISO-8859-1");
            }
            else if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
              pFVar6 = TraceFP();
              fprintf((FILE *)pFVar6,"BuildCommand no value for %s\n",pcVar4);
            }
          }
          else {
            HTChunkPuts(cmd,pcVar4);
            if (pcVar4 != (char *)0x0) {
              free(pcVar4);
            }
          }
          if (name != (char *)0x0) {
            free(name);
            name = (char *)0x0;
          }
        }
        from = next;
      }
      else if (cVar1 == 's') {
        if ((TmpFileLen != 0) && (TmpFileName != (char *)0x0)) {
          HTChunkPuts(cmd,TmpFileName);
        }
      }
      else {
LAB_080d4583:
        if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
          cVar1 = *from;
          pFVar6 = TraceFP();
          fprintf((FILE *)pFVar6,
                  "BuildCommand: Ignoring unrecognized format code in mailcap file \'%%%c\'.\n",
                  (int)cVar1);
        }
      }
    }
    else if (*from == '%') {
      bVar3 = true;
    }
    else {
      HTChunkPutc(cmd,*from);
    }
    from = from + 1;
  } while( true );
}



int LYTestMailcapCommand(char *testcommand,char *params)

{
  int iVar1;
  BOOLEAN BVar2;
  FILE *pFVar3;
  char *pcVar4;
  HTChunk *cmd;
  int iVar5;
  wchar_t wVar6;
  int in_GS_OFFSET;
  char *params_local;
  char *testcommand_local;
  HTChunk *expanded;
  int result;
  char TmpFileName [256];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  BVar2 = LYMailcapUsesPctS(testcommand);
  if (BVar2 == '\0') {
    TmpFileName[0] = '\0';
  }
  else {
    pFVar3 = LYOpenTemp(TmpFileName,".html","w");
    if (pFVar3 == (FILE *)0x0) {
      pcVar4 = (char *)gettext("Can\'t open temporary file!");
      ExitWithError(pcVar4);
    }
    LYCloseTemp(TmpFileName);
  }
  cmd = HTChunkCreate(0x400);
  pcVar4 = TmpFileName;
  iVar5 = BuildCommand(cmd,testcommand,pcVar4,params);
  if (iVar5 == 0) {
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
      pcVar4 = cmd->data;
      pFVar3 = TraceFP();
      fprintf((FILE *)pFVar3,"PassesTest: Executing test command: %s\n",pcVar4);
    }
    wVar6 = LYSystem(cmd->data);
    if (wVar6 == L'\0') {
      result = 0;
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
        pFVar3 = TraceFP();
        fprintf((FILE *)pFVar3,"PassesTest: Test passed!\n",pcVar4);
      }
    }
    else {
      result = -1;
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
        pFVar3 = TraceFP();
        fprintf((FILE *)pFVar3,"PassesTest: Test failed!\n",pcVar4);
      }
    }
  }
  else {
    result = 1;
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
      pcVar4 = cmd->data;
      pFVar3 = TraceFP();
      fprintf((FILE *)pFVar3,"PassesTest: Deferring test command: %s\n",pcVar4);
    }
  }
  HTChunkFree(cmd);
  LYRemoveTemp(TmpFileName);
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return result;
}



// WARNING: Unknown calling convention

char * LYMakeMailcapCommand(char *command,char *params,char *filename)

{
  char *result;
  HTChunk *expanded;
  
  expanded = (HTChunk *)0x0;
  result = (char *)0x0;
  expanded = HTChunkCreate(0x400);
  BuildCommand(expanded,command,filename,params);
  HTSACopy(&result,expanded->data);
  HTChunkFree(expanded);
  return result;
}



// WARNING: Unknown calling convention

int RememberTestResult(int mode,char *cmd,int result)

{
  int iVar1;
  cmdlist_s *pcVar2;
  int local_18;
  cmdlist_s *cur;
  
  if (mode == 1) {
    for (cur = RememberTestResult::cmdlist; cur != (cmdlist_s *)0x0; cur = cur->next) {
      iVar1 = strcmp(cmd,cur->cmd);
      if (iVar1 == 0) {
        return cur->result;
      }
    }
    local_18 = -1;
  }
  else {
    if (mode == 2) {
      pcVar2 = (cmdlist_s *)calloc(1,0xc);
      if (pcVar2 == (cmdlist_s *)0x0) {
        outofmem("./HTInit.c","RememberTestResult");
      }
      pcVar2->next = RememberTestResult::cmdlist;
      HTSACopy((char **)pcVar2,cmd);
      pcVar2->result = result;
      RememberTestResult::cmdlist = pcVar2;
    }
    else {
      pcVar2 = RememberTestResult::cmdlist;
      if (mode == 0) {
        while (RememberTestResult::cmdlist = pcVar2, RememberTestResult::cmdlist != (cmdlist_s *)0x0
              ) {
          pcVar2 = RememberTestResult::cmdlist->next;
          if (RememberTestResult::cmdlist->cmd != (char *)0x0) {
            free(RememberTestResult::cmdlist->cmd);
            RememberTestResult::cmdlist->cmd = (char *)0x0;
          }
          if (RememberTestResult::cmdlist != (cmdlist_s *)0x0) {
            free(RememberTestResult::cmdlist);
          }
        }
      }
    }
    local_18 = 0;
  }
  return local_18;
}



// WARNING: Unknown calling convention

int PassesTest(MailcapEntry *mc)

{
  int iVar1;
  FILE *pFVar2;
  char *pcVar3;
  int local_18;
  int result;
  
  if (mc->testcommand == (char *)0x0) {
    local_18 = 1;
  }
  else {
    iVar1 = strcmp(mc->testcommand,"test \"$DISPLAY\"");
    if (((iVar1 != 0) && (iVar1 = strcmp(mc->testcommand,"test \"$DISPLAY\" != \"\""), iVar1 != 0))
       && (iVar1 = strcmp(mc->testcommand,"test -n \"$DISPLAY\""), iVar1 != 0)) {
      iVar1 = strcmp(mc->testcommand,"test -z \"$DISPLAY\"");
      if (iVar1 == 0) {
        if (mc->testcommand != (char *)0x0) {
          free(mc->testcommand);
          mc->testcommand = (char *)0x0;
        }
        if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
          pFVar2 = TraceFP();
          fprintf((FILE *)pFVar2,"PassesTest: Testing for NON_XWINDOWS environment.\n");
        }
        pcVar3 = LYgetXDisplay();
        if (pcVar3 == (char *)0x0) {
          if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
            pFVar2 = TraceFP();
            fprintf((FILE *)pFVar2,"PassesTest: Test passed!\n");
          }
          return 1;
        }
        if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
          pFVar2 = TraceFP();
          fprintf((FILE *)pFVar2,"PassesTest: Test failed!\n");
        }
        return 0;
      }
      iVar1 = strcmp(mc->testcommand,"test -n \"$LYNX_VERSION\"");
      if (iVar1 == 0) {
        if (mc->testcommand != (char *)0x0) {
          free(mc->testcommand);
          mc->testcommand = (char *)0x0;
        }
        if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
          pFVar2 = TraceFP();
          fprintf((FILE *)pFVar2,"PassesTest: Testing for LYNX environment.\n");
        }
        if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
          pFVar2 = TraceFP();
          fprintf((FILE *)pFVar2,"PassesTest: Test passed!\n");
        }
        return 1;
      }
      iVar1 = strcmp(mc->testcommand,"test -z \"$LYNX_VERSION\"");
      if (iVar1 == 0) {
        if (mc->testcommand != (char *)0x0) {
          free(mc->testcommand);
          mc->testcommand = (char *)0x0;
        }
        if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
          pFVar2 = TraceFP();
          fprintf((FILE *)pFVar2,"PassesTest: Testing for non-LYNX environment.\n");
        }
        if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
          pFVar2 = TraceFP();
          fprintf((FILE *)pFVar2,"PassesTest: Test failed!\n");
        }
        return 0;
      }
      result = RememberTestResult(1,mc->testcommand,0);
      if (result == -1) {
        result = LYTestMailcapCommand(mc->testcommand,(char *)0x0);
        RememberTestResult(2,mc->testcommand,(uint)(result != 0));
      }
      if ((result != 1) && (mc->testcommand != (char *)0x0)) {
        free(mc->testcommand);
        mc->testcommand = (char *)0x0;
      }
      if (result < 0) {
        if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
          pFVar2 = TraceFP();
          fprintf((FILE *)pFVar2,"PassesTest: Test failed!\n");
        }
      }
      else if (((result == 0) && (WWW_TraceFlag != '\0')) && ((WWW_TraceMask & 8U) != 0)) {
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2,"PassesTest: Test passed!\n");
      }
      return (uint)~result >> 0x1f;
    }
    if (mc->testcommand != (char *)0x0) {
      free(mc->testcommand);
      mc->testcommand = (char *)0x0;
    }
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
      pFVar2 = TraceFP();
      fprintf((FILE *)pFVar2,"PassesTest: Testing for XWINDOWS environment.\n");
    }
    pcVar3 = LYgetXDisplay();
    if (pcVar3 == (char *)0x0) {
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2,"PassesTest: Test failed!\n");
      }
      local_18 = 0;
    }
    else {
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2,"PassesTest: Test passed!\n");
      }
      local_18 = 1;
    }
  }
  return local_18;
}



// WARNING: Unknown calling convention

int ProcessMailcapFile(char *file,AcceptMedia media)

{
  FILE *pFVar1;
  FILE *__stream;
  int iVar2;
  int local_38;
  MailcapEntry mc;
  FILE *fp;
  
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
    pFVar1 = TraceFP();
    fprintf((FILE *)pFVar1,"ProcessMailcapFile: Loading file \'%s\'.\n",file);
  }
  __stream = fopen64(file,"r");
  if (__stream == (FILE *)0x0) {
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
      pFVar1 = TraceFP();
      fprintf((FILE *)pFVar1,"ProcessMailcapFile: Could not open \'%s\'.\n",file);
    }
    local_38 = 0;
  }
  else {
    while (__stream != (FILE *)0x0) {
      iVar2 = feof(__stream);
      if (iVar2 != 0) break;
      ProcessMailcapEntry((FILE *)__stream,&mc,media);
    }
    LYCloseInput((FILE *)__stream);
    RememberTestResult(0,(char *)0x0,0);
    local_38 = 1;
  }
  return local_38;
}



// WARNING: Unknown calling convention

int ExitWithError(char *txt)

{
  FILE *__stream;
  
  if (txt != (char *)0x0) {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"Lynx: %s\n",txt);
  }
  exit_immediately(1);
  return -1;
}



// WARNING: Unknown calling convention

int HTLoadTypesConfigFile(char *fn,AcceptMedia media)

{
  HTList *tail;
  HTList *pHVar1;
  int iVar2;
  HTList *saved;
  int result;
  
  tail = HTPresentations;
  if (reverse_mailcap != 0) {
    HTPresentations = (HTList *)0x0;
  }
  iVar2 = ProcessMailcapFile(fn,media);
  pHVar1 = HTPresentations;
  if (((reverse_mailcap != 0) && (pHVar1 = tail, iVar2 != 0)) && (HTPresentations != (HTList *)0x0))
  {
    HTList_reverse(HTPresentations);
    HTList_appendList(HTPresentations,tail);
    pHVar1 = HTPresentations;
    if (tail != (HTList *)0x0) {
      free(tail);
      pHVar1 = HTPresentations;
    }
  }
  HTPresentations = pHVar1;
  return iVar2;
}



// WARNING: Unknown calling convention

void HTFileInit(void)

{
  BOOLEAN BVar1;
  FILE *pFVar2;
  char *name;
  
  if (LYUseBuiltinSuffixes == '\0') {
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
      pFVar2 = TraceFP();
      fprintf((FILE *)pFVar2,"HTFileInit: Skipping all default (HTInit) extension maps!\n");
    }
  }
  else {
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
      pFVar2 = TraceFP();
      fprintf((FILE *)pFVar2,"HTFileInit: Loading default (HTInit) extension maps.\n");
    }
    HTSetSuffix5("*","text/plain","8bit",(char *)0x0,1.0);
    HTSetSuffix5("*.*","text/plain","8bit",(char *)0x0,1.0);
    HTSetSuffix5(".csh","application/x-csh","8bit",(char *)0x0,0.8);
    HTSetSuffix5(".sh","application/x-sh","8bit",(char *)0x0,0.8);
    HTSetSuffix5(".ksh","application/x-ksh","8bit",(char *)0x0,0.8);
    HTSetSuffix5(".saveme","application/x-Binary","binary",(char *)0x0,1.0);
    HTSetSuffix5(".dump","application/x-Binary","binary",(char *)0x0,1.0);
    HTSetSuffix5(".bin","application/x-Binary","binary",(char *)0x0,1.0);
    HTSetSuffix5(".arc","application/x-Compressed","binary",(char *)0x0,1.0);
    HTSetSuffix5(".alpha-exe","application/x-Executable","binary",(char *)0x0,1.0);
    HTSetSuffix5(".alpha_exe","application/x-Executable","binary",(char *)0x0,1.0);
    HTSetSuffix5(".AXP-exe","application/x-Executable","binary",(char *)0x0,1.0);
    HTSetSuffix5(".AXP_exe","application/x-Executable","binary",(char *)0x0,1.0);
    HTSetSuffix5(".VAX-exe","application/x-Executable","binary",(char *)0x0,1.0);
    HTSetSuffix5(".VAX_exe","application/x-Executable","binary",(char *)0x0,1.0);
    HTSetSuffix5(".exe","application/octet-stream","binary","Executable",1.0);
    HTSetSuffix5(".Z","application/x-compress","binary","UNIX Compressed",1.0);
    HTSetSuffix5(".Z",(char *)0x0,"compress","UNIX Compressed",1.0);
    HTSetSuffix5(".exe.Z","application/octet-stream","compress","Executable",1.0);
    HTSetSuffix5(".tar_Z","application/x-tar","compress","UNIX Compr. Tar",1.0);
    HTSetSuffix5(".tar.Z","application/x-tar","compress","UNIX Compr. Tar",1.0);
    HTSetSuffix5("-gz","application/x-gzip","binary","GNU Compressed",1.0);
    HTSetSuffix5("_gz","application/x-gzip","binary","GNU Compressed",1.0);
    HTSetSuffix5(".gz","application/x-gzip","binary","GNU Compressed",1.0);
    HTSetSuffix5("-gz",(char *)0x0,"gzip","GNU Compressed",1.0);
    HTSetSuffix5("_gz",(char *)0x0,"gzip","GNU Compressed",1.0);
    HTSetSuffix5(".gz",(char *)0x0,"gzip","GNU Compressed",1.0);
    HTSetSuffix5(".tar.gz","application/x-tar","gzip","GNU Compr. Tar",1.0);
    HTSetSuffix5(".tgz","application/x-tar","gzip","GNU Compr. Tar",1.0);
    HTSetSuffix5(".wsrc","application/x-wais-source","8bit","WAIS-source",1.0);
    HTSetSuffix5(".zip","application/zip","binary","Zip File",1.0);
    HTSetSuffix5(".zz","application/x-deflate","binary",(char *)0x0,1.0);
    HTSetSuffix5(".zz","application/deflate","binary",(char *)0x0,1.0);
    HTSetSuffix5(".bz2","application/x-bzip2","binary",(char *)0x0,1.0);
    HTSetSuffix5(".bz2","application/bzip2","binary",(char *)0x0,1.0);
    HTSetSuffix5(".uu","application/x-uuencoded","7bit","UUencoded",1.0);
    HTSetSuffix5(".hqx","application/mac-binhex40","8bit","Mac BinHex",1.0);
    HTSetSuffix5(".o","application/octet-stream","binary","Prog. Object",0.5);
    HTSetSuffix5(".a","application/octet-stream","binary","Prog. Library",0.5);
    HTSetSuffix5(".so","application/octet-stream","binary","Shared Lib",0.5);
    HTSetSuffix5(".oda","application/oda","binary","ODA",1.0);
    HTSetSuffix5(".pdf","application/pdf","binary","PDF",1.0);
    HTSetSuffix5(".eps","application/postscript","8bit","Postscript",1.0);
    HTSetSuffix5(".ai","application/postscript","8bit","Postscript",1.0);
    HTSetSuffix5(".ps","application/postscript","8bit","Postscript",1.0);
    HTSetSuffix5(".rtf","application/rtf","8bit","RTF",1.0);
    HTSetSuffix5(".dvi","application/x-dvi","8bit","DVI",1.0);
    HTSetSuffix5(".hdf","application/x-hdf","8bit","HDF",1.0);
    HTSetSuffix5(".cdf","application/x-netcdf","8bit",(char *)0x0,1.0);
    HTSetSuffix5(".nc","application/x-netcdf","8bit",(char *)0x0,1.0);
    HTSetSuffix5(".latex","application/x-latex","8bit","LaTeX",1.0);
    HTSetSuffix5(".tex","text/x-tex","8bit","TeX",1.0);
    HTSetSuffix5(".texinfo","application/x-texinfo","8bit","Texinfo",1.0);
    HTSetSuffix5(".texi","application/x-texinfo","8bit","Texinfo",1.0);
    HTSetSuffix5(".t","application/x-troff","8bit","Troff",1.0);
    HTSetSuffix5(".tr","application/x-troff","8bit","Troff",1.0);
    HTSetSuffix5(".roff","application/x-troff","8bit","Troff",1.0);
    HTSetSuffix5(".man","application/x-troff-man","8bit","Man Page",1.0);
    HTSetSuffix5(".me","application/x-troff-me","8bit","Troff me",1.0);
    HTSetSuffix5(".ms","application/x-troff-ms","8bit","Troff ms",1.0);
    HTSetSuffix5(".zoo","application/x-Zoo File","binary",(char *)0x0,1.0);
    HTSetSuffix5(".bak",(char *)0x0,"binary","Backup",0.5);
    HTSetSuffix5(".bkp","application/octet-stream","binary","VMS BAK File",1.0);
    HTSetSuffix5(".bck","application/octet-stream","binary","VMS BAK File",1.0);
    HTSetSuffix5(".hlb","application/octet-stream","binary","VMS Help Libr.",1.0);
    HTSetSuffix5(".olb","application/octet-stream","binary","VMS Obj. Libr.",1.0);
    HTSetSuffix5(".tlb","application/octet-stream","binary","VMS Text Libr.",1.0);
    HTSetSuffix5(".obj","application/octet-stream","binary","Prog. Object",1.0);
    HTSetSuffix5(".decw$book","application/octet-stream","binary","DEC BookReader",1.0);
    HTSetSuffix5(".mem","text/x-runoff-manual","8bit","RUNOFF-MANUAL",1.0);
    HTSetSuffix5(".vsd","application/visio","binary",(char *)0x0,1.0);
    HTSetSuffix5(".lha","application/x-lha","binary","lha File",1.0);
    HTSetSuffix5(".lzh","application/x-lzh","binary","lzh File",1.0);
    HTSetSuffix5(".sea","application/x-sea","binary","sea File",1.0);
    HTSetSuffix5(".sit","application/x-stuffit","binary","StuffIt",1.0);
    HTSetSuffix5(".dms","application/x-dms","binary","dms File",1.0);
    HTSetSuffix5(".iff","application/x-iff","binary","iff File",1.0);
    HTSetSuffix5(".bcpio","application/x-bcpio","binary",(char *)0x0,1.0);
    HTSetSuffix5(".cpio","application/x-cpio","binary",(char *)0x0,1.0);
    HTSetSuffix5(".shar","application/x-shar","8bit",(char *)0x0,1.0);
    HTSetSuffix5(".share","application/x-share","8bit",(char *)0x0,1.0);
    HTSetSuffix5(".sv4cpio","application/x-sv4cpio","binary",(char *)0x0,1.0);
    HTSetSuffix5(".sv4crc","application/x-sv4crc","binary",(char *)0x0,1.0);
    HTSetSuffix5(".tar","application/x-tar","binary","Tar File",1.0);
    HTSetSuffix5(".ustar","application/x-ustar","binary",(char *)0x0,1.0);
    HTSetSuffix5(".snd","audio/basic","binary",(char *)0x0,1.0);
    HTSetSuffix5(".au","audio/basic","binary",(char *)0x0,1.0);
    HTSetSuffix5(".aifc","audio/x-aiff","binary",(char *)0x0,1.0);
    HTSetSuffix5(".aif","audio/x-aiff","binary",(char *)0x0,1.0);
    HTSetSuffix5(".aiff","audio/x-aiff","binary",(char *)0x0,1.0);
    HTSetSuffix5(".wav","audio/x-wav","binary",(char *)0x0,1.0);
    HTSetSuffix5(".midi","audio/midi","binary",(char *)0x0,1.0);
    HTSetSuffix5(".mod","audio/mod","binary",(char *)0x0,1.0);
    HTSetSuffix5(".gif","image/gif","binary",(char *)0x0,1.0);
    HTSetSuffix5(".ief","image/ief","binary",(char *)0x0,1.0);
    HTSetSuffix5(".jfif","image/jpeg","binary",(char *)0x0,1.0);
    HTSetSuffix5(".jfif-tbnl","image/jpeg","binary",(char *)0x0,1.0);
    HTSetSuffix5(".jpe","image/jpeg","binary",(char *)0x0,1.0);
    HTSetSuffix5(".jpg","image/jpeg","binary",(char *)0x0,1.0);
    HTSetSuffix5(".jpeg","image/jpeg","binary",(char *)0x0,1.0);
    HTSetSuffix5(".tif","image/tiff","binary",(char *)0x0,1.0);
    HTSetSuffix5(".tiff","image/tiff","binary",(char *)0x0,1.0);
    HTSetSuffix5(".ham","image/ham","binary",(char *)0x0,1.0);
    HTSetSuffix5(".ras","image/x-cmu-rast","binary",(char *)0x0,1.0);
    HTSetSuffix5(".pnm","image/x-portable-anymap","binary",(char *)0x0,1.0);
    HTSetSuffix5(".pbm","image/x-portable-bitmap","binary",(char *)0x0,1.0);
    HTSetSuffix5(".pgm","image/x-portable-graymap","binary",(char *)0x0,1.0);
    HTSetSuffix5(".ppm","image/x-portable-pixmap","binary",(char *)0x0,1.0);
    HTSetSuffix5(".png","image/png","binary",(char *)0x0,1.0);
    HTSetSuffix5(".rgb","image/x-rgb","binary",(char *)0x0,1.0);
    HTSetSuffix5(".xbm","image/x-xbitmap","binary",(char *)0x0,1.0);
    HTSetSuffix5(".xpm","image/x-xpixmap","binary",(char *)0x0,1.0);
    HTSetSuffix5(".xwd","image/x-xwindowdump","binary",(char *)0x0,1.0);
    HTSetSuffix5(".rtx","text/richtext","8bit",(char *)0x0,1.0);
    HTSetSuffix5(".tsv","text/tab-separated-values","8bit",(char *)0x0,1.0);
    HTSetSuffix5(".etx","text/x-setext","8bit",(char *)0x0,1.0);
    HTSetSuffix5(".mpg","video/mpeg","binary",(char *)0x0,1.0);
    HTSetSuffix5(".mpe","video/mpeg","binary",(char *)0x0,1.0);
    HTSetSuffix5(".mpeg","video/mpeg","binary",(char *)0x0,1.0);
    HTSetSuffix5(".mov","video/quicktime","binary",(char *)0x0,1.0);
    HTSetSuffix5(".qt","video/quicktime","binary",(char *)0x0,1.0);
    HTSetSuffix5(".avi","video/x-msvideo","binary",(char *)0x0,1.0);
    HTSetSuffix5(".movie","video/x-sgi-movie","binary",(char *)0x0,1.0);
    HTSetSuffix5(".mv","video/x-sgi-movie","binary",(char *)0x0,1.0);
    HTSetSuffix5(".mime","message/rfc822","8bit",(char *)0x0,1.0);
    HTSetSuffix5(".c","text/plain","8bit",(char *)0x0,1.0);
    HTSetSuffix5(".cc","text/plain","8bit",(char *)0x0,1.0);
    HTSetSuffix5(".c++","text/plain","8bit",(char *)0x0,1.0);
    HTSetSuffix5(".css","text/plain","8bit",(char *)0x0,1.0);
    HTSetSuffix5(".h","text/plain","8bit",(char *)0x0,1.0);
    HTSetSuffix5(".pl","text/plain","8bit",(char *)0x0,1.0);
    HTSetSuffix5(".text","text/plain","8bit",(char *)0x0,1.0);
    HTSetSuffix5(".txt","text/plain","8bit",(char *)0x0,1.0);
    HTSetSuffix5(".php","text/html","8bit",(char *)0x0,1.0);
    HTSetSuffix5(".php3","text/html","8bit",(char *)0x0,1.0);
    HTSetSuffix5(".html3","text/html","8bit",(char *)0x0,1.0);
    HTSetSuffix5(".ht3","text/html","8bit",(char *)0x0,1.0);
    HTSetSuffix5(".phtml","text/html","8bit",(char *)0x0,1.0);
    HTSetSuffix5(".shtml","text/html","8bit",(char *)0x0,1.0);
    HTSetSuffix5(".sht","text/html","8bit",(char *)0x0,1.0);
    HTSetSuffix5(".htmlx","text/html","8bit",(char *)0x0,1.0);
    HTSetSuffix5(".htm","text/html","8bit",(char *)0x0,1.0);
    HTSetSuffix5(".html","text/html","8bit",(char *)0x0,1.0);
  }
  BVar1 = LYisAbsPath(global_extension_map);
  if (BVar1 != '\0') {
    HTLoadExtensionsConfigFile(global_extension_map);
  }
  name = LYAbsOrHomePath(&personal_extension_map);
  BVar1 = IsOurFile(name);
  if (BVar1 != '\0') {
    BVar1 = LYCanReadFile(personal_extension_map);
    if (BVar1 != '\0') {
      HTLoadExtensionsConfigFile(personal_extension_map);
    }
  }
  return;
}



// WARNING: Unknown calling convention

int HTGetLine(char *s,int n,FILE *f)

{
  int iVar1;
  uint local_10;
  int local_c;
  int local_8;
  
  local_c = 0;
  if (f == (FILE *)0x0) {
    local_10 = 1;
  }
  else {
    while( true ) {
      local_8 = fgetc((FILE *)f);
      s[local_c] = (char)local_8;
      if (s[local_c] == '\r') {
        local_8 = fgetc((FILE *)f);
        if (local_8 == 10) {
          s[local_c] = '\n';
        }
        else if (local_8 != -1) {
          ungetc(local_8,(FILE *)f);
        }
      }
      if ((((local_8 == -1) || (s[local_c] == '\n')) || (s[local_c] == '\r')) || (n + -1 == local_c)
         ) break;
      local_c = local_c + 1;
    }
    s[local_c] = '\0';
    iVar1 = feof((FILE *)f);
    local_10 = (uint)(iVar1 != 0);
  }
  return local_10;
}



void HTGetWord(char *word,char *line,char stop,char stop2)

{
  char *pcVar1;
  char stop2_local;
  char stop_local;
  int y;
  int x;
  
  for (x = 0; ((line[x] != '\0' && (line[x] != stop)) && (line[x] != stop2)); x = x + 1) {
    word[x] = line[x];
  }
  word[x] = '\0';
  if (line[x] != '\0') {
    x = x + 1;
  }
  y = 0;
  do {
    pcVar1 = line + y;
    *pcVar1 = line[x];
    y = y + 1;
    x = x + 1;
  } while (*pcVar1 != '\0');
  return;
}



int HTLoadExtensionsConfigFile(char *fn)

{
  int iVar1;
  char *pcVar2;
  FILE *pFVar3;
  char *pcVar4;
  int iVar5;
  int in_GS_OFFSET;
  char *fn_local;
  char *ext;
  int count;
  FILE *f;
  char *ct;
  char word [256];
  char line [256];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  count = 0;
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
    pFVar3 = TraceFP();
    fprintf((FILE *)pFVar3,"HTLoadExtensionsConfigFile: Loading file \'%s\'.\n",fn);
  }
  f = (FILE *)fopen64(fn,"r");
  if (f == (FILE *)0x0) {
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
      pFVar3 = TraceFP();
      fprintf((FILE *)pFVar3,"HTLoadExtensionsConfigFile: Could not open \'%s\'.\n",fn);
    }
  }
  else {
    while (iVar5 = HTGetLine(line,0x100,f), iVar5 == 0) {
      HTGetWord(word,line,' ','\t');
      if ((line[0] != '\0') && (word[0] != '#')) {
        ct = (char *)0x0;
        HTSACopy(&ct,word);
        LYLowerCase(ct);
        while (line[0] != '\0') {
          HTGetWord(word,line,' ','\t');
          if ((word[0] != '\0') && (word[0] != ' ')) {
            ext = (char *)0x0;
            HTSprintf0(&ext,".%s",word);
            LYLowerCase(ext);
            pcVar2 = ct;
            pcVar4 = ext;
            if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
              pFVar3 = TraceFP();
              fprintf((FILE *)pFVar3,"setting suffix \'%s\' to \'%s\'.\n",pcVar4,pcVar2);
            }
            pcVar4 = strstr(ct,"tex");
            if ((((pcVar4 == (char *)0x0) &&
                 (pcVar4 = strstr(ct,"postscript"), pcVar4 == (char *)0x0)) &&
                (pcVar4 = strstr(ct,"sh"), pcVar4 == (char *)0x0)) &&
               ((pcVar4 = strstr(ct,"troff"), pcVar4 == (char *)0x0 &&
                (pcVar4 = strstr(ct,"rtf"), pcVar4 == (char *)0x0)))) {
              HTSetSuffix5(ext,ct,"binary",(char *)0x0,1.0);
            }
            else {
              HTSetSuffix5(ext,ct,"8bit",(char *)0x0,1.0);
            }
            count = count + 1;
            if (ext != (char *)0x0) {
              free(ext);
              ext = (char *)0x0;
            }
          }
        }
        if (ct != (char *)0x0) {
          free(ct);
          ct = (char *)0x0;
        }
      }
    }
    LYCloseInput(f);
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return count;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

HTStyleSheet * DefaultStyle(HTStyle ***result_array)

{
  _HTStyle *p_Var1;
  HTStyleSheet *pHVar2;
  HTStyle *pHVar3;
  int iVar4;
  HTStyle *pHVar5;
  HTStyle *pHVar6;
  byte bVar7;
  HTStyle *r;
  HTStyle *q;
  HTStyle *p;
  
  bVar7 = 0;
  if (result == (HTStyleSheet *)0x0) {
    pHVar2 = HTStyleSheetNew();
    pHVar5 = sheet.styles;
    result = pHVar2;
    pHVar2->name = sheet.name;
    pHVar2->styles = pHVar5;
    result->styles = (HTStyle *)0x0;
    for (p = sheet.styles; p != (HTStyle *)0x0; p = p->next) {
      pHVar3 = HTStyleNew();
      pHVar5 = p;
      pHVar6 = pHVar3;
      for (iVar4 = 0x14; iVar4 != 0; iVar4 = iVar4 + -1) {
        pHVar6->next = pHVar5->next;
        pHVar5 = (HTStyle *)((int)pHVar5 + (uint)bVar7 * -8 + 4);
        pHVar6 = (HTStyle *)((int)pHVar6 + (uint)bVar7 * -8 + 4);
      }
      if (no_margins != '\0') {
        pHVar3->indent1st = 0;
        pHVar3->leftIndent = 0;
        pHVar3->rightIndent = 0;
      }
      st_array[pHVar3->id] = pHVar3;
      pHVar3->next = result->styles;
      result->styles = pHVar3;
    }
  }
  else {
    q = result->styles;
    p = sheet.styles;
    for (; (p != (HTStyle *)0x0 && (q != (HTStyle *)0x0)); q = q->next) {
      p_Var1 = q->next;
      pHVar5 = p;
      pHVar6 = q;
      for (iVar4 = 0x14; iVar4 != 0; iVar4 = iVar4 + -1) {
        pHVar6->next = pHVar5->next;
        pHVar5 = (HTStyle *)&pHVar5->name;
        pHVar6 = (HTStyle *)&pHVar6->name;
      }
      if (no_margins != '\0') {
        q->indent1st = 0;
        q->leftIndent = 0;
        q->rightIndent = 0;
      }
      st_array[q->id] = q;
      q->next = p_Var1;
      p = p->next;
    }
  }
  *result_array = st_array;
  return result;
}



int LYUpload(char *line)

{
  int iVar1;
  BOOLEAN BVar2;
  char *pcVar3;
  int iVar4;
  wchar_t wVar5;
  FILE *pFVar6;
  int in_GS_OFFSET;
  int local_140;
  char *line_local;
  char *the_command;
  lynx_list_item_type *upload_command;
  char *filename;
  char *the_upload;
  int count;
  int method_number;
  char *directory;
  char *method;
  char tmpbuf [256];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  the_upload = (char *)0x0;
  filename = (char *)0x0;
  upload_command = (lynx_list_item_type *)0x0;
  the_command = (char *)0x0;
  directory = strstr(line,"TO=");
  if (directory != (char *)0x0) {
    directory[-1] = '\0';
    directory = directory + 3;
    method = strstr(line,"UPLOAD=");
    if (method != (char *)0x0) {
      method = method + 7;
      method_number = atoi(method);
      upload_command = uploaders;
      for (count = 0; count < method_number; count = count + 1) {
        upload_command = upload_command->next;
      }
      if (upload_command->command != (char *)0x0) {
        iVar4 = HTCountCommandArgs(upload_command->command);
        if (iVar4 == 0) {
          HTSACopy(&the_upload,upload_command->command);
        }
        else {
          mustshow = '\x01';
          pcVar3 = (char *)gettext("Enter a filename: ");
          statusline(pcVar3);
retry:
          do {
            do {
              tmpbuf[0] = '\0';
              wVar5 = LYgetstr(tmpbuf,L'\0',0x100,NORECALL);
              if ((wVar5 < L'\0') || (tmpbuf[0] == '\0')) {
cancelled:
                pcVar3 = (char *)gettext("Cancelling!");
                HTInfoMsg(pcVar3);
                local_140 = 0;
                goto LAB_080d7436;
              }
              pcVar3 = strstr(tmpbuf,"../");
              if (pcVar3 != (char *)0x0) {
                pcVar3 = (char *)gettext("Illegal redirection \"../\" found! Request ignored.");
                HTAlert(pcVar3);
                goto cancelled;
              }
              pcVar3 = strchr(tmpbuf,0x2f);
              if (pcVar3 != (char *)0x0) {
                pcVar3 = (char *)gettext("Illegal character \"/\" found! Request ignored.");
                HTAlert(pcVar3);
                goto cancelled;
              }
              if (tmpbuf[0] == '~') {
                pcVar3 = (char *)gettext("Illegal redirection using \"~\" found! Request ignored.");
                HTAlert(pcVar3);
                goto cancelled;
              }
              HTSprintf0(&filename,"%s/%s",directory,tmpbuf);
              if (*filename == '|') {
                pcVar3 = (char *)gettext("Cannot write to file.");
                HTAlert(pcVar3);
                mustshow = '\x01';
                pcVar3 = (char *)gettext("Enter a new filename: ");
                statusline(pcVar3);
                goto retry;
              }
              wVar5 = LYValidateOutput(filename);
              pcVar3 = filename;
            } while (wVar5 == L'N');
            if (wVar5 != L'Y') goto cancelled;
            if (WWW_TraceFlag != '\0') {
              pFVar6 = TraceFP();
              fprintf((FILE *)pFVar6,"LYUpload: filename is %s",pcVar3);
            }
            BVar2 = LYCanWriteFile(filename);
          } while (BVar2 == '\0');
          HTAddParam(&the_upload,upload_command->command,1,filename);
          HTEndParam(&the_upload,upload_command->command,1);
        }
        HTAddParam(&the_command,"cd %s ; ",1,directory);
        HTEndParam(&the_command,"cd %s ; ",1);
        HTSACat(&the_command,the_upload);
        pcVar3 = the_command;
        if (WWW_TraceFlag != '\0') {
          pFVar6 = TraceFP();
          fprintf((FILE *)pFVar6,"command: %s\n",pcVar3);
        }
        stop_curses();
        LYSystem(the_command);
        start_curses();
        if (the_command != (char *)0x0) {
          free(the_command);
          the_command = (char *)0x0;
        }
        if (the_upload != (char *)0x0) {
          free(the_upload);
          the_upload = (char *)0x0;
        }
        if (filename != (char *)0x0) {
          chmod(filename,0x180);
        }
        if (filename != (char *)0x0) {
          free(filename);
          filename = (char *)0x0;
        }
        local_140 = 1;
        goto LAB_080d7436;
      }
      pcVar3 = (char *)gettext("ERROR! - upload command is misconfigured");
      HTAlert(pcVar3);
    }
  }
  pcVar3 = (char *)gettext("Unable to upload file.");
  HTAlert(pcVar3);
  local_140 = 0;
LAB_080d7436:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return local_140;
}



// WARNING: Unknown calling convention

int LYUpload_options(char **newfile,char *directory)

{
  FILE *fp0_00;
  char *pcVar1;
  undefined4 uVar2;
  int local_1c;
  char *local_18;
  char *cp;
  int count;
  lynx_list_item_type *cur_upload;
  FILE *fp0;
  
  fp0_00 = InternalPageFP(LYUpload_options::tempfile,L'\x01');
  if (fp0_00 == (FILE *)0x0) {
    local_1c = -1;
  }
  else {
    pcVar1 = HTnameOfFile_WWW(directory,'\0','\x01');
    strcpy(LYUpload_options::curloc,pcVar1);
    LYTrimPathSep(LYUpload_options::curloc);
    if (pcVar1 != (char *)0x0) {
      free(pcVar1);
    }
    LYLocalFileToURL(newfile,LYUpload_options::tempfile);
    LYRegisterUIPage(*newfile,UIP_UPLOAD_OPTIONS);
    pcVar1 = (char *)gettext("Upload Options");
    BeginInternalPage(fp0_00,pcVar1,"Lynx_users_guide.html.gz#DirEd");
    fwrite("<pre>\n",1,6,(FILE *)fp0_00);
    uVar2 = gettext("Upload To:");
    fprintf((FILE *)fp0_00,"   <em>%s</em> %s\n",uVar2,LYUpload_options::curloc);
    uVar2 = gettext("Upload options:");
    fprintf((FILE *)fp0_00,"\n%s\n",uVar2);
    if (uploaders == (lynx_list_item_type *)0x0) {
      fwrite("   &lt;NONE&gt;\n",1,0x10,(FILE *)fp0_00);
    }
    else {
      count = 0;
      for (cur_upload = uploaders; cur_upload != (lynx_list_item_type *)0x0;
          cur_upload = cur_upload->next) {
        fprintf((FILE *)fp0_00,"   <a href=\"LYNXDIRED://UPLOAD=%d/TO=%s\">",count,
                LYUpload_options::curloc);
        if (cur_upload->name == (char *)0x0) {
          local_18 = (char *)gettext("No Name Given");
        }
        else {
          local_18 = cur_upload->name;
        }
        fputs(local_18,(FILE *)fp0_00);
        fwrite("</a>\n",1,5,(FILE *)fp0_00);
        count = count + 1;
      }
    }
    fwrite("</pre>\n",1,7,(FILE *)fp0_00);
    EndInternalPage(fp0_00);
    LYCloseTempFP(fp0_00);
    LYforce_no_cache = '\x01';
    local_1c = 0;
  }
  return local_1c;
}



// WARNING: Unknown calling convention

void no_leak_checking(void)

{
  return;
}



// WARNING: Unknown calling convention

int LYatexit(_func_void *function)

{
  FILE *__stream;
  int local_8;
  
  if (topOfStack == 0x32) {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"(LY)atexit: Too many functions, ignoring one!\n");
    }
    local_8 = -1;
  }
  else {
    callstack[topOfStack] = function;
    topOfStack = topOfStack + 1;
    local_8 = 0;
  }
  return local_8;
}



// WARNING: Unknown calling convention

void LYCompleteExit(void)

{
  while (topOfStack = topOfStack + -1, -1 < topOfStack) {
    (*callstack[topOfStack])();
  }
  return;
}



// WARNING: Unknown calling convention

void LYexit(int status)

{
  undefined4 uVar1;
  
  if (LYOutOfMemory == '\x01') {
    signal(1,(__sighandler_t)0x1);
    signal(0xf,(__sighandler_t)0x1);
    signal(2,(__sighandler_t)0x1);
    signal(0xb,(__sighandler_t)0x1);
    signal(4,(__sighandler_t)0x1);
    fflush(stderr);
    fflush(stdout);
    if (LYCursesON != '\0') {
      LYSleepAlert();
    }
    cleanup_sig(0);
    signal(0xb,(__sighandler_t)0x0);
    signal(4,(__sighandler_t)0x0);
  }
  LYCloselog();
  LYCompleteExit();
  LYCloseCmdLogfile();
  cleanup_files();
  fflush(stderr);
  if (LYOutOfMemory == '\x01') {
    LYOutOfMemory = '\0';
    uVar1 = gettext("Memory exhausted!  Program aborted!");
    printf("\r\n%s\r\n\r\n",uVar1);
    fflush(stdout);
  }
  LYCloseTracelog();
                    // WARNING: Subroutine does not return
  exit(status);
}



// WARNING: Unknown calling convention

void outofmem(char *fname,char *func)

{
  undefined4 uVar1;
  
  uVar1 = gettext("Memory exhausted!  Aborting...");
  fprintf(stderr,"\n\n\n%s %s: %s\n",fname,func,uVar1);
  LYOutOfMemory = '\x01';
  LYexit(-1);
  return;
}



// WARNING: Unknown calling convention

void LYJumpTable_free(void)

{
  JumpTable_conflict *pJVar1;
  JumpTable_conflict *next;
  JumpTable_conflict *cur;
  
  cur = JThead;
  pJVar1 = cur;
  while (cur = pJVar1, cur != (JumpTable_conflict *)0x0) {
    pJVar1 = cur->next;
    if (cur->msg != (char *)0x0) {
      free(cur->msg);
      cur->msg = (char *)0x0;
    }
    if (cur->file != (char *)0x0) {
      free(cur->file);
      cur->file = (char *)0x0;
    }
    if (cur->shortcut != (char *)0x0) {
      free(cur->shortcut);
      cur->shortcut = (char *)0x0;
    }
    if (cur->history != (HTList *)0x0) {
      LYFreeStringList(cur->history);
      cur->history = (HTList *)0x0;
    }
    if (cur->table != (JumpDatum *)0x0) {
      free(cur->table);
      cur->table = (JumpDatum *)0x0;
    }
    if (cur->mp != (char *)0x0) {
      free(cur->mp);
      cur->mp = (char *)0x0;
    }
    if (cur != (JumpTable_conflict *)0x0) {
      free(cur);
    }
  }
  JThead = (JumpTable_conflict *)0x0;
  return;
}



// WARNING: Unknown calling convention

void LYAddJumpShortcut(HTList *historyp,char *shortcut)

{
  int iVar1;
  char *local_18;
  HTList *cur;
  char *old;
  char *tmp;
  
  tmp = (char *)0x0;
  cur = historyp;
  if (((historyp != (HTList *)0x0) && (shortcut != (char *)0x0)) && (*shortcut != '\0')) {
    HTSACopy(&tmp,shortcut);
    do {
      if ((cur == (HTList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
        local_18 = (char *)0x0;
      }
      else {
        local_18 = (char *)cur->object;
      }
      if (local_18 == (char *)0x0) goto LAB_080d7ac1;
      iVar1 = strcmp(local_18,tmp);
    } while (iVar1 != 0);
    HTList_removeObject(historyp,local_18);
    if (local_18 != (char *)0x0) {
      free(local_18);
    }
LAB_080d7ac1:
    HTList_addObject(historyp,tmp);
  }
  return;
}



// WARNING: Unknown calling convention

BOOLEAN LYJumpInit(char *config)

{
  char *pcVar1;
  int iVar2;
  size_t sVar3;
  HTList *pHVar4;
  BOOLEAN local_19;
  JumpTable_conflict *jtptmp;
  char *cp;
  JumpTable_conflict *jtp;
  
  jtp = (JumpTable_conflict *)calloc(1,0x24);
  if (jtp == (JumpTable_conflict *)0x0) {
    outofmem("./LYJump.c","LYJumpInit");
  }
  pcVar1 = strtok(config,":\n");
  if (pcVar1 == (char *)0x0) {
    if (jtp != (JumpTable_conflict *)0x0) {
      free(jtp);
    }
    local_19 = '\0';
  }
  else {
    pcVar1 = strtok((char *)0x0,":\n");
    if (pcVar1 == (char *)0x0) {
      if (jtp != (JumpTable_conflict *)0x0) {
        free(jtp);
      }
      local_19 = '\0';
    }
    else {
      HTSACopy(&jtp->file,pcVar1);
      cp = strtok((char *)0x0,":\n");
      if ((cp == (char *)0x0) && (JThead != (JumpTable_conflict *)0x0)) {
        jtptmp = JThead;
        jumpfile = jtp->file;
        if (jtp != (JumpTable_conflict *)0x0) {
          free(jtp);
        }
        for (; (jtptmp != (JumpTable_conflict *)0x0 && (jtptmp->key != 0)); jtptmp = jtptmp->next) {
        }
        if (jtptmp == (JumpTable_conflict *)0x0) {
          local_19 = '\0';
        }
        else {
          HTSACopy(&jtptmp->file,jumpfile);
          HTSACopy(&jtptmp->msg,jumpprompt);
          local_19 = '\x01';
        }
      }
      else {
        if ((cp != (char *)0x0) && (JThead == (JumpTable_conflict *)0x0)) {
          JThead = jtp;
          HTSACopy(&jtp->msg,jumpprompt);
          if (jumpfile == (char *)0x0) {
            HTSACopy(&jumpfile,JThead->file);
          }
          jtp = (JumpTable_conflict *)calloc(1,0x24);
          if (jtp == (JumpTable_conflict *)0x0) {
            outofmem("./LYJump.c","LYJumpInit");
          }
          HTSACopy(&jtp->file,JThead->file);
        }
        if (cp != (char *)0x0) {
          iVar2 = remap(cp,"JUMP",'\0');
          jtp->key = iVar2;
          cp = strtok((char *)0x0,"\n");
          if ((cp == (char *)0x0) || (*cp == '\0')) {
            cp = (char *)0x0;
          }
          else {
            HTSACopy(&jtp->msg,cp);
          }
        }
        if (cp == (char *)0x0) {
          HTSACopy(&jtp->msg,jumpprompt);
        }
        pcVar1 = jtp->msg;
        sVar3 = strlen(jtp->msg);
        if (pcVar1[sVar3 - 1] != ' ') {
          HTSACat(&jtp->msg," ");
        }
        pHVar4 = HTList_new();
        jtp->history = pHVar4;
        jtp->next = JThead;
        JThead = jtp;
        local_19 = '\x01';
      }
    }
  }
  return local_19;
}



// WARNING: Unknown calling convention

char * LYJump(int key)

{
  char *pcVar1;
  uint uVar2;
  size_t sVar3;
  ushort **ppuVar4;
  int iVar5;
  bool bVar6;
  int local_40;
  char *local_38;
  JumpDatum seeking;
  char *msg;
  int ShortcutNum;
  int ShortcutTotal;
  RecallType recall;
  int ch;
  JumpTable_conflict *jtp;
  char *cp;
  char *bp;
  JumpDatum *found;
  BOOLEAN FirstShortcutRecall;
  
  FirstShortcutRecall = '\x01';
  if (JThead != (JumpTable_conflict *)0x0) {
    for (jtp = JThead; ((jtp != (JumpTable_conflict *)0x0 && (jtp->key != 0)) && (jtp->key != key));
        jtp = jtp->next) {
    }
    if (jtp == (JumpTable_conflict *)0x0) {
      msg = (char *)0x0;
      pcVar1 = (char *)gettext("Key \'%c\' is not mapped to a jump file!");
      HTSprintf0(&msg,pcVar1,key);
      HTAlert(msg);
      if (msg != (char *)0x0) {
        free(msg);
      }
    }
    else {
      if (jtp->table == (JumpDatum *)0x0) {
        uVar2 = LYRead_Jumpfile(jtp);
        jtp->nel = uVar2;
      }
      if (jtp->nel != 0) {
        if (((jump_buffer == '\0') || (jtp->shortcut == (char *)0x0)) || (*jtp->shortcut == '\0')) {
          LYJump::buf[0] = '\0';
        }
        else if ((jtp->shortcut != (char *)0x0) && (*jtp->shortcut != '\0')) {
          sVar3 = strlen(jtp->shortcut);
          if (0x77 < sVar3) {
            jtp->shortcut[0x77] = '\0';
          }
          strcpy(LYJump::buf,jtp->shortcut);
        }
        if (jtp->history == (HTList *)0x0) {
          local_40 = 0;
        }
        else {
          local_40 = HTList_count(jtp->history);
        }
        ShortcutTotal = local_40;
        if ((jump_buffer == '\0') || (LYJump::buf[0] == '\0')) {
          bVar6 = 0 < local_40;
          ShortcutNum = local_40;
          FirstShortcutRecall = '\x01';
        }
        else {
          bVar6 = 1 < local_40;
          ShortcutNum = 0;
          FirstShortcutRecall = '\0';
        }
        recall = (RecallType)bVar6;
        statusline(jtp->msg);
        ch = LYgetstr(LYJump::buf,L'\0',0x78,recall);
        if (ch < L'\0') {
          pcVar1 = (char *)gettext("Cancelled!!!");
          HTInfoMsg(pcVar1);
        }
        else {
          do {
            while( true ) {
              bp = LYJump::buf;
              ppuVar4 = __ctype_b_loc();
              if (((*ppuVar4)[key & 0xff] & 0x200) == 0) {
                bVar6 = (char)key == 'G';
              }
              else {
                iVar5 = toupper(key & 0xff);
                bVar6 = iVar5 == 0x47;
              }
              if ((bVar6) && (iVar5 = strncmp(LYJump::buf,"o ",2), iVar5 == 0)) {
                bp = bp + 1;
              }
              bp = LYSkipBlanks(bp);
              if ((*bp == '\0') && ((recall == NORECALL || ((ch != 0x100 && (ch != 0x101)))))) {
                LYJump::buf[0] = '\0';
                HTSACopy(&jtp->shortcut,LYJump::buf);
                pcVar1 = (char *)gettext("Cancelled!!!");
                HTInfoMsg(pcVar1);
                return (char *)0x0;
              }
              if ((recall == NORECALL) || (ch != 0x100)) break;
              if (FirstShortcutRecall == '\0') {
                ShortcutNum = ShortcutNum + 1;
              }
              else {
                FirstShortcutRecall = '\0';
                ShortcutNum = 0;
              }
              if (ShortcutTotal <= ShortcutNum) {
                ShortcutNum = 0;
              }
              cp = (char *)HTList_objectAt(jtp->history,ShortcutNum);
              if (cp == (char *)0x0) {
LAB_080d83cf:
                seeking.key = bp;
                found = (JumpDatum *)bsearch(&seeking,jtp->table,jtp->nel,8,LYCompare);
                if (found == (JumpDatum *)0x0) {
                  user_message("Unknown target \'%s\'",LYJump::buf);
                  LYSleepAlert();
                }
                HTSACopy(&jtp->shortcut,bp);
                LYAddJumpShortcut(jtp->history,jtp->shortcut);
                if (found == (JumpDatum *)0x0) {
                  local_38 = (char *)0x0;
                }
                else {
                  local_38 = found->url;
                }
                return local_38;
              }
              LYstrncpy(LYJump::buf,cp,L'{');
              if (((jump_buffer == '\0') || (jtp->shortcut == (char *)0x0)) ||
                 (iVar5 = strcmp(LYJump::buf,jtp->shortcut), iVar5 != 0)) {
                if (((jump_buffer == '\0') || (ShortcutTotal != 2)) &&
                   ((jump_buffer != '\0' || (ShortcutTotal != 1)))) {
                  mustshow = '\x01';
                  pcVar1 = (char *)gettext("Edit a previous shortcut: ");
                  statusline(pcVar1);
                }
                else {
                  mustshow = '\x01';
                  pcVar1 = (char *)gettext("Edit the previous shortcut: ");
                  statusline(pcVar1);
                }
              }
              else {
                mustshow = '\x01';
                pcVar1 = (char *)gettext("Edit the current shortcut: ");
                statusline(pcVar1);
              }
              ch = LYgetstr(LYJump::buf,L'\0',0x7c,recall);
              if (ch < L'\0') {
                pcVar1 = (char *)gettext("Cancelled!!!");
                HTInfoMsg(pcVar1);
                return (char *)0x0;
              }
            }
            if ((recall == NORECALL) || (ch != 0x101)) goto LAB_080d83cf;
            if (FirstShortcutRecall != '\0') {
              FirstShortcutRecall = '\0';
              ShortcutNum = ShortcutTotal;
            }
            ShortcutNum = ShortcutNum + -1;
            if (ShortcutNum < 0) {
              ShortcutNum = ShortcutTotal + -1;
            }
            cp = (char *)HTList_objectAt(jtp->history,ShortcutNum);
            if (cp == (char *)0x0) goto LAB_080d83cf;
            LYstrncpy(LYJump::buf,cp,L'{');
            if (((jump_buffer == '\0') || (jtp->shortcut == (char *)0x0)) ||
               (iVar5 = strcmp(LYJump::buf,jtp->shortcut), iVar5 != 0)) {
              if (((jump_buffer == '\0') || (ShortcutTotal != 2)) &&
                 ((jump_buffer != '\0' || (ShortcutTotal != 1)))) {
                mustshow = '\x01';
                pcVar1 = (char *)gettext("Edit a previous shortcut: ");
                statusline(pcVar1);
              }
              else {
                mustshow = '\x01';
                pcVar1 = (char *)gettext("Edit the previous shortcut: ");
                statusline(pcVar1);
              }
            }
            else {
              mustshow = '\x01';
              pcVar1 = (char *)gettext("Edit the current shortcut: ");
              statusline(pcVar1);
            }
            ch = LYgetstr(LYJump::buf,L'\0',0x7c,recall);
          } while (L'\xffffffff' < ch);
          pcVar1 = (char *)gettext("Cancelled!!!");
          HTInfoMsg(pcVar1);
        }
      }
    }
  }
  return (char *)0x0;
}



// WARNING: Unknown calling convention

uint LYRead_Jumpfile(JumpTable_conflict *jtp)

{
  FILE *pFVar1;
  int iVar2;
  char *pcVar3;
  char *pcVar4;
  uint uVar5;
  JumpDatum *pJVar6;
  uint local_a0;
  stat st;
  uint i;
  char *cp;
  int fd;
  char *mp;
  uint nel;
  
  if ((jtp->file == (char *)0x0) || (*jtp->file == '\0')) {
    local_a0 = 0;
  }
  else {
    if (WWW_TraceFlag != '\0') {
      pcVar3 = jtp->file;
      pFVar1 = TraceFP();
      fprintf((FILE *)pFVar1,"Read Jumpfile %s\n",pcVar3);
    }
    iVar2 = stat64(jtp->file,(stat64 *)&st);
    if (iVar2 < 0) {
      pcVar3 = (char *)gettext("Cannot locate jump file!");
      HTAlert(pcVar3);
      local_a0 = 0;
    }
    else {
      pcVar3 = (char *)calloc((size_t)st.st_size + 1,1);
      if (pcVar3 == (char *)0x0) {
        pcVar3 = (char *)gettext("Out of memory reading jump file!");
        HTAlert(pcVar3);
        local_a0 = 0;
      }
      else {
        iVar2 = open64(jtp->file,0);
        if (iVar2 < 0) {
          pcVar4 = (char *)gettext("Cannot open jump file!");
          HTAlert(pcVar4);
          if (pcVar3 != (char *)0x0) {
            free(pcVar3);
          }
          local_a0 = 0;
        }
        else {
          uVar5 = read(iVar2,pcVar3,(size_t)st.st_size);
          if ((st.st_size._4_4_ < (int)uVar5 >> 0x1f) ||
             ((st.st_size._4_4_ <= (int)uVar5 >> 0x1f && ((size_t)st.st_size <= uVar5)))) {
            pcVar3[(size_t)st.st_size] = '\0';
            close(iVar2);
            nel = 0;
            cp = pcVar3;
            while( true ) {
              pcVar4 = strchr(cp,10);
              if (pcVar4 == (char *)0x0) break;
              nel = nel + 1;
              cp = pcVar4 + 1;
            }
            pJVar6 = (JumpDatum *)malloc(nel << 3);
            jtp->table = pJVar6;
            if (jtp->table == (JumpDatum *)0x0) {
              pcVar4 = (char *)gettext("Out of memory reading jump table!");
              HTAlert(pcVar4);
              if (pcVar3 != (char *)0x0) {
                free(pcVar3);
              }
              local_a0 = 0;
            }
            else {
              jtp->mp = pcVar3;
              cp = jtp->mp;
              i = 0;
              do {
                while( true ) {
                  if (nel <= i) goto LAB_080d88cd;
                  iVar2 = strncmp(cp,"<!--",4);
                  if (iVar2 != 0) break;
LAB_080d8755:
                  pcVar3 = strchr(cp,10);
                  if (pcVar3 == (char *)0x0) goto LAB_080d88cd;
                  cp = pcVar3 + 1;
                }
                iVar2 = strncmp(cp,"<dl>",4);
                if (iVar2 == 0) goto LAB_080d8755;
                pcVar3 = LYstrstr(cp,"<dt>");
                if (pcVar3 == (char *)0x0) break;
                jtp->table[i].key = pcVar3 + 4;
                pcVar3 = LYstrstr(pcVar3 + 4,"<dd>");
                if (pcVar3 == (char *)0x0) break;
                *pcVar3 = '\0';
                pcVar3 = LYstrstr(pcVar3 + 4,"href=\"");
                if (pcVar3 == (char *)0x0) break;
                jtp->table[i].url = pcVar3 + 6;
                pcVar3 = strchr(pcVar3 + 6,0x22);
                if (pcVar3 == (char *)0x0) break;
                *pcVar3 = '\0';
                pcVar3 = strchr(pcVar3 + 1,10);
                if (pcVar3 == (char *)0x0) break;
                cp = pcVar3 + 1;
                if (WWW_TraceFlag != '\0') {
                  pcVar3 = jtp->table[i].url;
                  pcVar4 = jtp->table[i].key;
                  pFVar1 = TraceFP();
                  fprintf((FILE *)pFVar1,"Read jumpfile[%u] key=\'%s\', url=\'%s\'\n",i,pcVar4,
                          pcVar3);
                }
                i = i + 1;
              } while (cp != (char *)0x0);
LAB_080d88cd:
              local_a0 = i;
            }
          }
          else {
            pcVar4 = (char *)gettext("Error reading jump file!");
            HTAlert(pcVar4);
            if (pcVar3 != (char *)0x0) {
              free(pcVar3);
            }
            local_a0 = 0;
          }
        }
      }
    }
  }
  return local_a0;
}



// WARNING: Unknown calling convention

int LYCompare(void *e1,void *e2)

{
  int iVar1;
  
                    // WARNING: Load size is inaccurate
                    // WARNING: Load size is inaccurate
  iVar1 = strcasecomp(*e1,*e2);
  return iVar1;
}



// WARNING: Removing unreachable block (ram,0x080d8cdb)
// WARNING: Removing unreachable block (ram,0x080d8c3d)
// WARNING: Removing unreachable block (ram,0x080d8c63)
// WARNING: Removing unreachable block (ram,0x080d8c6c)
// WARNING: Removing unreachable block (ram,0x080d8c78)
// WARNING: Removing unreachable block (ram,0x080d8c82)
// WARNING: Removing unreachable block (ram,0x080d8ca0)
// WARNING: Removing unreachable block (ram,0x080d8ea7)

int showlist(DocInfo *newdoc,BOOLEAN titles)

{
  char *pcVar1;
  undefined4 uVar2;
  HTChildAnchor *me;
  HTParentAnchor *me_00;
  HTParentAnchor *me_01;
  int iVar3;
  int local_94;
  UIP_t local_90;
  char *local_8c;
  undefined *local_88;
  char *local_80;
  char *local_7c;
  undefined *local_78;
  char *local_74;
  undefined *local_70;
  char *local_6c;
  char *local_68;
  undefined *local_64;
  char *local_60;
  undefined *local_5c;
  BOOLEAN titles_local;
  char *title;
  char *address;
  HTParentAnchor *parent;
  HTAnchor *dest;
  HTAnchor *dest_intl;
  HTChildAnchor *child;
  void *helper;
  char *desc;
  char *LinkTitle;
  char *cp;
  char *Title;
  char *Address;
  FILE *fp0;
  int hidden_links;
  int refs;
  int cnt;
  BOOLEAN intern_w_post;
  
  Address = (char *)0x0;
  Title = (char *)0x0;
  cp = (char *)0x0;
  LinkTitle = (char *)0x0;
  intern_w_post = '\0';
  desc = "unknown field or link";
  refs = HText_sourceAnchors(HTMainText);
  hidden_links = HText_HiddenLinkCount(HTMainText);
  if (((refs < 1) && (L'\0' < hidden_links)) && (LYHiddenLinks != 1)) {
    pcVar1 = (char *)gettext("There are only hidden links from this document.");
    HTUserMsg(pcVar1);
    local_94 = -1;
  }
  else if ((refs < 1) && (hidden_links < L'\x01')) {
    pcVar1 = (char *)gettext("There are no references from this document.");
    HTUserMsg(pcVar1);
    local_94 = -1;
  }
  else {
    fp0 = InternalPageFP(showlist::tempfile,(uint)(titles == showlist::last_titles));
    if (fp0 == (FILE *)0x0) {
      local_94 = -1;
    }
    else {
      LYLocalFileToURL(&newdoc->address,showlist::tempfile);
      if (titles == '\0') {
        local_90 = UIP_ADDRLIST_PAGE;
      }
      else {
        local_90 = UIP_LIST_PAGE;
      }
      LYRegisterUIPage(newdoc->address,local_90);
      LYforce_HTML_mode = '\x01';
      LYforce_no_cache = '\x01';
      showlist::last_titles = titles;
      pcVar1 = (char *)gettext("List Page");
      BeginInternalPage(fp0,pcVar1,"keystrokes/follow_help.html.gz");
      pcVar1 = HTLoadedDocumentURL();
      HTSACopy(&Address,pcVar1);
      LYEntify(&Address,'\0');
      if ((Address == (char *)0x0) || (*Address == '\0')) {
        local_8c = (char *)gettext("this document:");
      }
      else {
        local_8c = Address;
      }
      uVar2 = gettext("References in ");
      fprintf((FILE *)fp0,"%s%s<p>\n",uVar2,local_8c);
      local_68 = local_8c;
      if (Address != (char *)0x0) {
        free(Address);
        Address = (char *)0x0;
        local_68 = local_8c;
      }
      if (0 < refs) {
        if (keypad_mode == 0) {
          local_88 = &DAT_08168dee;
        }
        else {
          local_88 = &DAT_08168df1;
        }
        fprintf((FILE *)fp0,"<%s compact>\n",local_88,local_68);
        if (0 < hidden_links) {
          uVar2 = gettext("Visible links:");
          fprintf((FILE *)fp0,"<lh><em>%s</em>\n",uVar2,local_68);
        }
      }
      if ((0 < hidden_links) && (LYHiddenLinks == 2)) {
        hidden_links = 0;
      }
      helper = (void *)0x0;
      for (cnt = 1; cnt <= refs; cnt = cnt + 1) {
        me = HText_childNextNumber(cnt,&helper);
        if (me == (HTChildAnchor *)0x0) {
          if ((keypad_mode == 3) || (keypad_mode == 2)) {
            HText_FormDescNumber(cnt,&desc);
            local_68 = (char *)cnt;
            fprintf((FILE *)fp0,"<li><a id=%d href=\"#%d\">form field</a> = <em>%s</em>\n",cnt,cnt,
                    desc);
          }
        }
        else {
          me_00 = (HTParentAnchor *)HTAnchor_followLink(me);
          me_01 = HTAnchor_parent((HTAnchor *)me_00);
          pcVar1 = HTAnchor_address((HTAnchor *)me_00);
          if (titles == '\0') {
            local_80 = (char *)0x0;
LAB_080d8d55:
            if (LinkTitle != (char *)0x0) {
              free(LinkTitle);
              LinkTitle = (char *)0x0;
            }
          }
          else {
            local_80 = HTAnchor_title(me_01);
            if (((me->type == (HTLinkType *)0x0) || ((HTParentAnchor *)me->dest != me_00)) ||
               (iVar3 = strncmp(me->type->name,"RelTitle: ",10), iVar3 != 0)) goto LAB_080d8d55;
            HTSprintf0(&LinkTitle,"(%s)",me->type->name + 10);
          }
          HTSACopy(&Address,pcVar1);
          if (pcVar1 != (char *)0x0) {
            free(pcVar1);
          }
          LYEntify(&Address,'\x01');
          if ((local_80 != (char *)0x0) && (*local_80 != '\0')) {
            LYformTitle(&Title,local_80);
            LYEntify(&Title,'\x01');
            if (*Title == '\0') {
              if (Title != (char *)0x0) {
                free(Title);
                Title = (char *)0x0;
              }
            }
            else {
              cp = strchr(Address,0x23);
            }
          }
          if ((Title == (char *)0x0) || (cp == (char *)0x0)) {
            local_7c = "";
          }
          else {
            local_7c = cp + 1;
          }
          if ((Title == (char *)0x0) || (cp == (char *)0x0)) {
            local_78 = &DAT_08168e75;
          }
          else {
            local_78 = &DAT_08168e76;
          }
          if (Title == (char *)0x0) {
            local_74 = Address;
          }
          else {
            local_74 = Title;
          }
          if ((me_01 == me_00) || (Title == (char *)0x0)) {
            local_70 = &DAT_08168e75;
          }
          else {
            local_70 = &DAT_08168e7a;
          }
          if (LinkTitle == (char *)0x0) {
            local_6c = "";
          }
          else {
            local_6c = LinkTitle;
          }
          local_68 = "";
          fprintf((FILE *)fp0,"<li><a href=\"%s\"%s>%s%s%s%s%s</a>\n",Address,&DAT_08168e75,local_6c
                  ,local_70,local_74,local_78,local_7c);
          if (Address != (char *)0x0) {
            free(Address);
            Address = (char *)0x0;
          }
          if (Title != (char *)0x0) {
            free(Title);
            Title = (char *)0x0;
          }
        }
      }
      if (LinkTitle != (char *)0x0) {
        free(LinkTitle);
        LinkTitle = (char *)0x0;
      }
      if (0 < hidden_links) {
        if (0 < refs) {
          if (keypad_mode == 0) {
            local_64 = &DAT_08168dee;
          }
          else {
            local_64 = &DAT_08168df1;
          }
          fprintf((FILE *)fp0,"\n</%s>\n\n<p>\n",local_64,local_68);
        }
        if (keypad_mode == 0) {
          local_60 = "ol continue";
        }
        else {
          local_60 = "ul";
        }
        fprintf((FILE *)fp0,"<%s compact>\n",local_60);
        uVar2 = gettext("Hidden links:");
        fprintf((FILE *)fp0,"<lh><em>%s</em>\n",uVar2);
      }
      for (cnt = 0; cnt < hidden_links; cnt = cnt + 1) {
        pcVar1 = HText_HiddenLinkAt(HTMainText,cnt);
        HTSACopy(&Address,pcVar1);
        LYEntify(&Address,'\0');
        if ((Address == (char *)0x0) || (*Address == '\0')) {
          if (Address != (char *)0x0) {
            free(Address);
            Address = (char *)0x0;
          }
        }
        else {
          local_68 = Address;
          fprintf((FILE *)fp0,"<li><a href=\"%s\">%s</a>\n",Address,Address);
          if (Address != (char *)0x0) {
            free(Address);
            Address = (char *)0x0;
          }
        }
      }
      if (keypad_mode == 0) {
        local_5c = &DAT_08168dee;
      }
      else {
        local_5c = &DAT_08168df1;
      }
      fprintf((FILE *)fp0,"\n</%s>\n",local_5c,local_68);
      EndInternalPage(fp0);
      LYCloseTempFP(fp0);
      if (intern_w_post == '\0') {
        LYFreePostData(newdoc);
        newdoc->internal_link = '\0';
      }
      else {
        newdoc->internal_link = '\x01';
      }
      newdoc->isHEAD = '\0';
      newdoc->safe = '\0';
      local_94 = 0;
    }
  }
  return local_94;
}



void print_refs(FILE *fp,BOOLEAN titles,int refs)

{
  HTParentAnchor *pHVar1;
  HTParentAnchor *me;
  char *local_34;
  char *local_30;
  undefined *local_2c;
  BOOLEAN titles_local;
  char *title;
  HTParentAnchor *parent;
  HTAnchor *dest;
  HTChildAnchor *child;
  void *helper;
  char *desc;
  char *address;
  int cnt;
  
  address = (char *)0x0;
  desc = (char *)gettext("unknown field or link");
  helper = (void *)0x0;
  for (cnt = 1; cnt <= refs; cnt = cnt + 1) {
    pHVar1 = (HTParentAnchor *)HText_childNextNumber(cnt,&helper);
    if (pHVar1 == (HTParentAnchor *)0x0) {
      if ((keypad_mode == 3) || (keypad_mode == 2)) {
        HText_FormDescNumber(cnt,&desc);
        fprintf((FILE *)fp,"%4d. form field = %s\n",cnt,desc);
      }
    }
    else {
      me = (HTParentAnchor *)HTAnchor_followLink((HTChildAnchor *)pHVar1);
      if (me != pHVar1) {
        pHVar1 = HTAnchor_parent((HTAnchor *)me);
        if (titles == '\0') {
          local_34 = (char *)0x0;
        }
        else {
          local_34 = HTAnchor_title(pHVar1);
        }
        address = HTAnchor_address((HTAnchor *)me);
        if ((keypad_mode == 1) || (keypad_mode == 2)) {
          fprintf((FILE *)fp,"%4d. ",cnt);
        }
        if (local_34 == (char *)0x0) {
          local_30 = address;
        }
        else {
          local_30 = local_34;
        }
        if ((pHVar1 == me) || (local_34 == (char *)0x0)) {
          local_2c = &DAT_08168e75;
        }
        else {
          local_2c = &DAT_08168e7a;
        }
        fprintf((FILE *)fp,"%s%s\n",local_2c,local_30);
        if (address != (char *)0x0) {
          free(address);
          address = (char *)0x0;
        }
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

void print_hidden_refs(FILE *fp,int refs,int hidden_links)

{
  undefined4 uVar1;
  char *src;
  undefined *local_18;
  char *address;
  int cnt;
  
  address = (char *)0x0;
  uVar1 = gettext("Hidden links:");
  if (refs < 1) {
    local_18 = &DAT_08168e75;
  }
  else {
    local_18 = &DAT_08168f21;
  }
  fprintf((FILE *)fp,"%s   %s\n",local_18,uVar1);
  for (cnt = 0; cnt < hidden_links; cnt = cnt + 1) {
    src = HText_HiddenLinkAt(HTMainText,cnt);
    HTSACopy(&address,src);
    if ((address == (char *)0x0) || (*address == '\0')) {
      if (address != (char *)0x0) {
        free(address);
        address = (char *)0x0;
      }
    }
    else {
      if ((keypad_mode == 1) || (keypad_mode == 2)) {
        fprintf((FILE *)fp,"%4d. ",cnt + 1 + refs,uVar1);
      }
      fprintf((FILE *)fp,"%s\n",address);
      if (address != (char *)0x0) {
        free(address);
        address = (char *)0x0;
      }
    }
  }
  return;
}



void printlist(FILE *fp,BOOLEAN titles)

{
  wchar_t refs_00;
  undefined4 uVar1;
  BOOLEAN titles_local;
  int hidden_links;
  int refs;
  
  refs_00 = HText_sourceAnchors(HTMainText);
  if ((L'\0' < refs_00) || (LYHiddenLinks == 1)) {
    hidden_links = HText_HiddenLinkCount(HTMainText);
    if ((L'\0' < refs_00) || (L'\0' < hidden_links)) {
      if ((((keypad_mode == 1) || (keypad_mode == 2)) || (keypad_mode == 3)) || (keypad_mode == 2))
      {
        uVar1 = gettext("References");
        fprintf((FILE *)fp,"\n%s\n\n",uVar1);
      }
      if (LYHiddenLinks == 2) {
        hidden_links = 0;
      }
      if (0 < hidden_links) {
        uVar1 = gettext("Visible links");
        fprintf((FILE *)fp,"   %s\n",uVar1);
      }
      print_refs(fp,titles,refs_00);
      if (0 < hidden_links) {
        print_hidden_refs(fp,refs_00,hidden_links);
      }
    }
  }
  LYPrintImgMaps(fp);
  return;
}



// WARNING: Unknown calling convention

void remember_alloced(void *ptr)

{
  if (alloced == (HTList *)0x0) {
    alloced = HTList_new();
  }
  HTList_addObject(alloced,ptr);
  return;
}



// WARNING: Unknown calling convention

void add_environment_value(char *env_value)

{
  int iVar1;
  
  if (envc == envc_size) {
    if (env == (char **)0x0) {
      iVar1 = envc_size + 0xc;
      envc_size = envc_size + 10;
      env = (char **)malloc(iVar1 * 4);
      remember_alloced(env);
    }
    else {
      iVar1 = envc_size + 0xc;
      envc_size = envc_size + 10;
      env = (char **)realloc(env,iVar1 * 4);
    }
    if (env == (char **)0x0) {
      outofmem("./LYCgi.c","LYCgi");
    }
  }
  env[envc] = env_value;
  envc = envc + 1;
  env[envc] = (char *)0x0;
  return;
}



// WARNING: Unknown calling convention

void add_lynxcgi_environment(char *variable_name)

{
  char *add_value;
  char *env_value;
  
  env_value = LYGetEnv(variable_name);
  if (env_value != (char *)0x0) {
    add_value = (char *)0x0;
    HTSprintf0(&add_value,"%s=%s",variable_name,env_value);
    add_environment_value(add_value);
    remember_alloced(add_value);
  }
  return;
}



// WARNING: Unknown calling convention

BOOLEAN can_exec_cgi(char *linktext,char *linkargs)

{
  BOOLEAN BVar1;
  char *source;
  char *p;
  char *command;
  char *message;
  char *format;
  BOOLEAN result;
  
  format = (char *)gettext("Do you want to execute \"%s\"?");
  message = (char *)0x0;
  command = (char *)0x0;
  result = '\x01';
  source = HTLoadedDocumentURL();
  BVar1 = exec_ok(source,linktext,2);
  if (BVar1 == '\0') {
    result = '\0';
  }
  else if (user_mode < 2) {
    HTSACopy(&command,linktext);
    if ((linkargs != (char *)0x0) && (*linkargs != '\0')) {
      HTSprintf(&command," %s",linkargs);
    }
    HTUnEscape(command);
    for (p = command; *p != '\0'; p = p + 1) {
      if (*p == '+') {
        *p = ' ';
      }
    }
    HTSprintf0(&message,format,command);
    result = HTConfirm(message);
    if (message != (char *)0x0) {
      free(message);
      message = (char *)0x0;
    }
    if (command != (char *)0x0) {
      free(command);
    }
  }
  return result;
}



int LYLoadCGI(char *arg,HTParentAnchor *anAnchor,HTFormat format_out,HTStream *sink)

{
  char *pcVar1;
  BOOLEAN BVar2;
  size_t sVar3;
  char *pcVar4;
  int iVar5;
  int *piVar6;
  FILE *pFVar7;
  char *fmt;
  ssize_t sVar8;
  wchar_t wVar9;
  __pid_t _Var10;
  int iVar11;
  char **__argv;
  int in_GS_OFFSET;
  int local_50c;
  char *local_504;
  int local_500;
  HTStream *sink_local;
  HTFormat format_out_local;
  HTParentAnchor *anAnchor_local;
  char *arg_local;
  stat stat_buf;
  int fd2 [2];
  int fd1 [2];
  char *cr;
  int exec_errno;
  char **cur_argv;
  int argv_cnt;
  char **argv;
  int total_written;
  int remaining;
  int written;
  int total_chars;
  int chars;
  char *tmp;
  char *new_arg;
  int pid;
  HTStream *target;
  HTFormat format_in;
  char *path_translated;
  char *pgm_buff;
  char *path_info;
  char *document_root;
  char *orig_pgm;
  int statrv;
  char *pgm_args;
  char *pgm;
  char *cp;
  int status;
  char buf [1024];
  
  iVar11 = *(int *)(in_GS_OFFSET + 0x14);
  status = 0;
  pgm = (char *)0x0;
  pgm_args = (char *)0x0;
  orig_pgm = (char *)0x0;
  document_root = (char *)0x0;
  path_info = (char *)0x0;
  pgm_buff = (char *)0x0;
  if (((arg == (char *)0x0) || (*arg == '\0')) || (sVar3 = strlen(arg), sVar3 < 9)) {
    pcVar4 = (char *)gettext("Bad request!");
    HTAlert(pcVar4);
    status = -2;
    goto LAB_080dae8b;
  }
  iVar5 = strncmp(arg,"lynxcgi://localhost",0x13);
  if (iVar5 == 0) {
    HTSACopy(&pgm,arg + 0x13);
  }
  else {
    HTSACopy(&pgm,arg + 8);
  }
  cp = strchr(pgm,0x3f);
  if (cp != (char *)0x0) {
    *cp = '\0';
    pgm_args = cp + 1;
    cp = pgm_args;
  }
  HTSACopy(&orig_pgm,pgm);
  cp = trimPoundSelector(pgm);
  if (cp != (char *)0x0) {
    pgm_args = (char *)0x0;
  }
  HTUnEscape(pgm);
  statrv = stat64(pgm,(stat64 *)&stat_buf);
  if (statrv < 0) {
    HTSACopy(&pgm_buff,pgm);
    while( true ) {
      if ((-1 < statrv) && (statrv = stat64(pgm_buff,(stat64 *)&stat_buf), -1 < statrv))
      goto LAB_080d9a59;
      cp = strrchr(pgm_buff,0x2f);
      if (cp == (char *)0x0) break;
      *cp = '\0';
      statrv = 1;
    }
    if (WWW_TraceFlag != '\0') {
      piVar6 = __errno_location();
      pcVar4 = strerror(*piVar6);
      pFVar7 = TraceFP();
      fprintf((FILE *)pFVar7,"LYNXCGI: %s: %s\n","strrchr(pgm_buff, \'/\') returned NULL",pcVar4);
    }
LAB_080d9a59:
    pcVar4 = pgm;
    if (statrv < 0) {
      if (WWW_TraceFlag != '\0') {
        piVar6 = __errno_location();
        pcVar4 = strerror(*piVar6);
        pFVar7 = TraceFP();
        fprintf((FILE *)pFVar7,"LYNXCGI: %s: %s\n","stat() of pgm_buff failed",pcVar4);
      }
    }
    else {
      sVar3 = strlen(pgm_buff);
      HTSACopy(&path_info,pcVar4 + sVar3);
      strcpy(pgm,pgm_buff);
      pcVar1 = path_info;
      pcVar4 = pgm_buff;
      if (WWW_TraceFlag != '\0') {
        pFVar7 = TraceFP();
        fprintf((FILE *)pFVar7,"LYNXCGI: stat() of %s succeeded, path_info=\"%s\".\n",pcVar4,pcVar1)
        ;
      }
    }
    if (pgm_buff != (char *)0x0) {
      free(pgm_buff);
      pgm_buff = (char *)0x0;
    }
  }
  pcVar1 = pgm;
  pcVar4 = orig_pgm;
  if (statrv == 0) {
    if (((stat_buf.st_mode & 0xf000) == 0x8000) && ((stat_buf.st_mode & 0x49) != 0)) {
      if (((path_info != (char *)0x0) && (anAnchor != HTMainAnchor)) &&
         ((reloading == '\0' || (anAnchor->document == (HyperDoc *)0x0)))) {
        pcVar4 = HTLoadedDocumentURL();
        iVar5 = strcmp(arg,pcVar4);
        if ((((iVar5 != 0) && (BVar2 = HText_AreDifferent(anAnchor,arg), BVar2 != '\0')) &&
            (pcVar4 = HTUnEscape(orig_pgm), pcVar4 != (char *)0x0)) &&
           (BVar2 = can_exec_cgi(orig_pgm,""), BVar2 == '\0')) {
          status = -29999;
          goto LAB_080dae19;
        }
      }
      if (no_lynxcgi == '\0') {
        if (((no_bookmark_exec != '\0') && (anAnchor != HTMainAnchor)) &&
           ((reloading == '\0' || (anAnchor->document == (HyperDoc *)0x0)))) {
          pcVar4 = HTLoadedDocumentURL();
          iVar5 = strcmp(arg,pcVar4);
          if (((iVar5 != 0) && (BVar2 = HText_AreDifferent(anAnchor,arg), BVar2 != '\0')) &&
             (pcVar4 = HTLoadedDocumentBookmark(), pcVar4 != (char *)0x0)) {
            pcVar4 = (char *)gettext("Execution via bookmarks is disabled.");
            HTUserMsg(pcVar4);
            status = -29999;
            goto LAB_080dae19;
          }
        }
        if ((anAnchor != HTMainAnchor) &&
           ((reloading == '\0' || (anAnchor->document == (HyperDoc *)0x0)))) {
          pcVar4 = HTLoadedDocumentURL();
          iVar5 = strcmp(arg,pcVar4);
          if ((iVar5 != 0) &&
             ((BVar2 = HText_AreDifferent(anAnchor,arg), BVar2 != '\0' &&
              (BVar2 = can_exec_cgi(pgm,pgm_args), BVar2 == '\0')))) {
            status = -29999;
            goto LAB_080dae19;
          }
        }
        target = (HTStream *)0x0;
        if ((anAnchor->isHEAD == '\0') && (keep_mime_headers == '\0')) {
          format_in = HTAtom_for("www/mime");
        }
        else {
          format_in = HTAtom_for("text/plain");
        }
        pcVar4 = (char *)anAnchor;
        target = (HTStream *)HTStreamStack(format_in,format_out,(HTStream_conflict4 *)sink,anAnchor)
        ;
        if (((HTStream_conflict4 *)target == (HTStream_conflict4 *)0x0) ||
           ((HTStream_conflict4 *)target == (HTStream_conflict4 *)0x0)) {
          tmp = (char *)0x0;
          pcVar4 = format_out->name;
          pcVar1 = format_in->name;
          fmt = (char *)gettext("Sorry, no known way of converting %s to %s.");
          HTSprintf0(&tmp,fmt,pcVar1,pcVar4);
          HTAlert(tmp);
          if (tmp != (char *)0x0) {
            free(tmp);
            tmp = (char *)0x0;
          }
          status = -29999;
        }
        else if ((anAnchor->post_data == (bstring *)0x0) || (iVar5 = pipe(fd1), -1 < iVar5)) {
          iVar5 = pipe(fd2);
          if (iVar5 < 0) {
            pcVar4 = (char *)gettext("Unable to set up connection.");
            HTAlert(pcVar4);
            if (WWW_TraceFlag != '\0') {
              piVar6 = __errno_location();
              pcVar4 = strerror(*piVar6);
              pFVar7 = TraceFP();
              fprintf((FILE *)pFVar7,"LYNXCGI: %s: %s\n","pipe() failed",pcVar4);
            }
            close(fd1[0]);
            close(fd1[1]);
            status = -3;
          }
          else {
            if (LYLoadCGI::first_time != '\0') {
              LYLoadCGI::first_time = '\0';
              add_environment_value("REMOTE_HOST=localhost");
              add_environment_value("REMOTE_ADDR=127.0.0.1");
              HTSprintf0(&user_agent,"HTTP_USER_AGENT=%s/%s libwww/%s",&DAT_081691b3,"2.8.7dev.11",
                         HTLibraryVersion);
              add_environment_value(user_agent);
              pcVar4 = "2.8.7dev.11";
              sink = (HTStream *)&DAT_081691b3;
              HTSprintf0(&server_software,"SERVER_SOFTWARE=%s/%s",&DAT_081691b3,"2.8.7dev.11");
              add_environment_value(server_software);
            }
            fflush(stdout);
            fflush(stderr);
            if (WWW_TraceFlag != '\0') {
              pFVar7 = TraceFP();
              fflush((FILE *)pFVar7);
            }
            pid = fork();
            if (pid < 1) {
              if (pid == 0) {
                argv_cnt = 3;
                close(fd2[0]);
                iVar11 = fileno(stdout);
                dup2(fd2[1],iVar11);
                iVar11 = fileno(stderr);
                dup2(fd2[1],iVar11);
                close(fd2[1]);
                if ((language != (char *)0x0) && (*language != '\0')) {
                  HTSprintf0(&accept_language,"HTTP_ACCEPT_LANGUAGE=%s",language);
                  add_environment_value(accept_language);
                }
                if ((pref_charset != (char *)0x0) && (*pref_charset != '\0')) {
                  cp = (char *)0x0;
                  HTSACopy(&cp,"HTTP_ACCEPT_CHARSET=");
                  HTSACat(&cp,pref_charset);
                  add_environment_value(cp);
                }
                if ((anAnchor->post_data != (bstring *)0x0) &&
                   (anAnchor->post_content_type != (char *)0x0)) {
                  cp = (char *)0x0;
                  HTSACopy(&cp,"CONTENT_TYPE=");
                  HTSACat(&cp,anAnchor->post_content_type);
                  add_environment_value(cp);
                }
                if (anAnchor->post_data == (bstring *)0x0) {
                  iVar11 = fileno(stdin);
                  close(iVar11);
                  if (anAnchor->isHEAD != '\0') {
                    add_environment_value("REQUEST_METHOD=HEAD");
                  }
                }
                else {
                  close(fd1[1]);
                  iVar11 = fileno(stdin);
                  dup2(fd1[0],iVar11);
                  close(fd1[0]);
                  add_environment_value("REQUEST_METHOD=POST");
                  if (anAnchor->post_data == (bstring *)0x0) {
                    local_500 = 0;
                  }
                  else {
                    local_500 = anAnchor->post_data->len;
                  }
                  HTSprintf0(&post_len,"CONTENT_LENGTH=%d",local_500);
                  add_environment_value(post_len);
                }
                if (pgm_args != (char *)0x0) {
                  for (cp = pgm_args; *cp != '\0'; cp = cp + 1) {
                    if (*cp == '+') {
                      argv_cnt = argv_cnt + 1;
                    }
                  }
                }
                __argv = (char **)malloc(argv_cnt << 2);
                if (__argv == (char **)0x0) {
                  outofmem("./LYCgi.c","LYCgi");
                }
                cur_argv = __argv + 1;
                if (pgm_args == (char *)0x0) {
                  if ((anAnchor->isHEAD == '\0') && (anAnchor->post_data == (bstring *)0x0)) {
                    add_environment_value("REQUEST_METHOD=GET");
                  }
                }
                else {
                  if (is_www_index == '\0') {
                    if ((anAnchor->isHEAD == '\0') && (anAnchor->post_data == (bstring *)0x0)) {
                      add_environment_value("REQUEST_METHOD=GET");
                    }
                  }
                  else {
                    add_environment_value("REQUEST_METHOD=SEARCH");
                  }
                  cp = (char *)0x0;
                  HTSACopy(&cp,"QUERY_STRING=");
                  HTSACat(&cp,pgm_args);
                  add_environment_value(cp);
                  cr = pgm_args;
                  for (cp = pgm_args; *cp != '\0'; cp = cp + 1) {
                    if (*cp == '+') {
                      *cp = '\0';
                      cp = cp + 1;
                      pcVar4 = HTUnEscape(cr);
                      *cur_argv = pcVar4;
                      cur_argv = cur_argv + 1;
                      cr = cp;
                    }
                  }
                  pcVar4 = HTUnEscape(cr);
                  *cur_argv = pcVar4;
                  cur_argv = cur_argv + 1;
                }
                *cur_argv = (char *)0x0;
                *__argv = pgm;
                if (LYCgiDocumentRoot != (char *)0x0) {
                  cp = (char *)0x0;
                  HTSACopy(&cp,"DOCUMENT_ROOT=");
                  HTSACat(&cp,LYCgiDocumentRoot);
                  add_environment_value(cp);
                }
                if (path_info != (char *)0x0) {
                  cp = (char *)0x0;
                  HTSACopy(&cp,"PATH_INFO=");
                  HTSACat(&cp,path_info);
                  add_environment_value(cp);
                }
                if ((LYCgiDocumentRoot != (char *)0x0) && (path_info != (char *)0x0)) {
                  HTSACopy(&document_root,LYCgiDocumentRoot);
                  LYTrimHtmlSep(document_root);
                  path_translated = document_root;
                  HTSACat(&path_translated,path_info);
                  cp = (char *)0x0;
                  HTSACopy(&cp,"PATH_TRANSLATED=");
                  HTSACat(&cp,path_translated);
                  add_environment_value(cp);
                  if (path_translated != (char *)0x0) {
                    free(path_translated);
                    path_translated = (char *)0x0;
                  }
                }
                execve(*__argv,__argv,env);
                piVar6 = __errno_location();
                iVar11 = *piVar6;
                if (WWW_TraceFlag != '\0') {
                  piVar6 = __errno_location();
                  pcVar4 = strerror(*piVar6);
                  pFVar7 = TraceFP();
                  fprintf((FILE *)pFVar7,"LYNXCGI: %s: %s\n","execve failed",pcVar4);
                }
                puts("Content-Type: text/plain\r\n\r");
                if (anAnchor->isHEAD == '\0') {
                  printf("exec of %s failed",pgm);
                  pcVar4 = strerror(iVar11);
                  printf(": %s.\r\n",pcVar4);
                }
                fflush(stdout);
                fflush(stderr);
                    // WARNING: Subroutine does not return
                _exit(1);
              }
              pcVar4 = (char *)gettext("Unable to make connection");
              HTAlert(pcVar4);
              if (WWW_TraceFlag != '\0') {
                piVar6 = __errno_location();
                pcVar4 = strerror(*piVar6);
                pFVar7 = TraceFP();
                fprintf((FILE *)pFVar7,"LYNXCGI: %s: %s\n","fork() failed",pcVar4);
              }
              status = -0xcc;
              close(fd1[0]);
              close(fd1[1]);
              close(fd2[0]);
              close(fd2[1]);
              status = -1;
            }
            else {
              close(fd2[1]);
              if (anAnchor->post_data != (bstring *)0x0) {
                total_written = 0;
                close(fd1[0]);
                if (WWW_TraceFlag != '\0') {
                  if (WWW_TraceFlag != '\0') {
                    sink = (HTStream *)anAnchor->post_content_type;
                    pFVar7 = TraceFP();
                    fprintf((FILE *)pFVar7,"LYNXCGI: Doing post, content-type \'%s\'\n",sink);
                  }
                  if (WWW_TraceFlag != '\0') {
                    pFVar7 = TraceFP();
                    fprintf((FILE *)pFVar7,"LYNXCGI: Writing:\n",sink);
                  }
                  trace_bstring(anAnchor->post_data);
                  if (WWW_TraceFlag != '\0') {
                    pFVar7 = TraceFP();
                    fprintf((FILE *)pFVar7,"----------------------------------\n");
                  }
                }
                if (anAnchor->post_data == (bstring *)0x0) {
                  local_50c = 0;
                }
                else {
                  local_50c = anAnchor->post_data->len;
                }
                remaining = local_50c;
                do {
                  while( true ) {
                    if (anAnchor->post_data == (bstring *)0x0) {
                      local_504 = (char *)0x0;
                    }
                    else {
                      local_504 = anAnchor->post_data->str;
                    }
                    sVar8 = write(fd1[1],local_504 + total_written,remaining);
                    if (sVar8 == 0) goto LAB_080da45e;
                    if (-1 < sVar8) break;
                    piVar6 = __errno_location();
                    if (*piVar6 != 4) {
                      if (WWW_TraceFlag != '\0') {
                        piVar6 = __errno_location();
                        pcVar4 = strerror(*piVar6);
                        pFVar7 = TraceFP();
                        fprintf((FILE *)pFVar7,"LYNXCGI: %s: %s\n","write() of POST data failed",
                                pcVar4);
                      }
                      goto LAB_080da45e;
                    }
                  }
                  if (WWW_TraceFlag != '\0') {
                    pFVar7 = TraceFP();
                    fprintf((FILE *)pFVar7,"LYNXCGI: Wrote %d bytes of POST data.\n",sVar8);
                  }
                  total_written = total_written + sVar8;
                  remaining = remaining - sVar8;
                } while (remaining != 0);
LAB_080da45e:
                if ((remaining != 0) && (WWW_TraceFlag != '\0')) {
                  pFVar7 = TraceFP();
                  fprintf((FILE *)pFVar7,"LYNXCGI: %d bytes remain unwritten!\n",remaining,pcVar4);
                }
                close(fd1[1]);
              }
              total_chars = 0;
              HTReadProgress(0,0);
              do {
                while( true ) {
                  wVar9 = read(fd2[0],buf,0x400);
                  if (wVar9 == L'\0') goto LAB_080da5fd;
                  if (wVar9 < L'\0') break;
                  total_chars = total_chars + wVar9;
                  HTReadProgress((longlong)total_chars,0);
                  if (WWW_TraceFlag != '\0') {
                    pFVar7 = TraceFP();
                    fprintf((FILE *)pFVar7,"LYNXCGI: Rx: %.*s\n",wVar9,buf);
                  }
                  (*target->isa->put_block)(target,buf,wVar9);
                }
                piVar6 = __errno_location();
              } while (*piVar6 == 4);
              if (WWW_TraceFlag != '\0') {
                piVar6 = __errno_location();
                pcVar4 = strerror(*piVar6);
                pFVar7 = TraceFP();
                fprintf((FILE *)pFVar7,"LYNXCGI: %s: %s\n","read() of CGI output failed",pcVar4);
              }
LAB_080da5fd:
              if ((wVar9 < L'\0') && (total_chars == 0)) {
                status = -29999;
                (*target->isa->_abort)(target,(HTError)0x0);
                target = (HTStream *)0x0;
              }
              else if (wVar9 == L'\0') {
                status = 200;
              }
              else {
                status = 0xce;
              }
              do {
                _Var10 = waitpid(pid,(int *)&new_arg,0);
                if (_Var10 != -1) break;
                piVar6 = __errno_location();
              } while (*piVar6 == 4);
              close(fd2[0]);
            }
          }
        }
        else {
          pcVar4 = (char *)gettext("Unable to set up connection.");
          HTAlert(pcVar4);
          if (WWW_TraceFlag != '\0') {
            piVar6 = __errno_location();
            pcVar4 = strerror(*piVar6);
            pFVar7 = TraceFP();
            fprintf((FILE *)pFVar7,"LYNXCGI: %s: %s\n","pipe() failed",pcVar4);
          }
          status = -3;
        }
        if (target != (HTStream *)0x0) {
          (*target->isa->_free)(target);
        }
      }
      else {
        pcVar4 = (char *)gettext("cgi support has been disabled.");
        HTUserMsg(pcVar4);
        status = -29999;
      }
    }
    else {
      new_arg = (char *)0x0;
      if (path_info != (char *)0x0) {
        if (WWW_TraceFlag != '\0') {
          pFVar7 = TraceFP();
          fprintf((FILE *)pFVar7,"%s is not a file and %s not an executable, giving up.\n",pcVar4,
                  pcVar1);
        }
        if (path_info != (char *)0x0) {
          free(path_info);
          path_info = (char *)0x0;
        }
        if (pgm != (char *)0x0) {
          free(pgm);
          pgm = (char *)0x0;
        }
        if (orig_pgm != (char *)0x0) {
          free(orig_pgm);
          orig_pgm = (char *)0x0;
        }
        status = -4;
        goto LAB_080dae8b;
      }
      LYLocalFileToURL(&new_arg,orig_pgm);
      if (WWW_TraceFlag != '\0') {
        pFVar7 = TraceFP();
        fprintf((FILE *)pFVar7,"%s is not an executable file, passing the buck.\n",arg);
      }
      status = HTLoadFile(new_arg,anAnchor,format_out,sink);
      if (new_arg != (char *)0x0) {
        free(new_arg);
        new_arg = (char *)0x0;
      }
    }
  }
  else {
    pcVar4 = (char *)gettext("Unable to access cgi script");
    HTAlert(pcVar4);
    if (WWW_TraceFlag != '\0') {
      piVar6 = __errno_location();
      pcVar4 = strerror(*piVar6);
      pFVar7 = TraceFP();
      fprintf((FILE *)pFVar7,"LYNXCGI: %s: %s\n","stat() failed",pcVar4);
    }
    status = -4;
  }
LAB_080dae19:
  if (path_info != (char *)0x0) {
    free(path_info);
    path_info = (char *)0x0;
  }
  if (pgm != (char *)0x0) {
    free(pgm);
    pgm = (char *)0x0;
  }
  if (orig_pgm != (char *)0x0) {
    free(orig_pgm);
    orig_pgm = (char *)0x0;
  }
LAB_080dae8b:
  if (iVar11 == *(int *)(in_GS_OFFSET + 0x14)) {
    return status;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void final_perror(char *msg,BOOLEAN clean_flag)

{
  int iVar1;
  int *piVar2;
  EVP_PKEY_CTX *in_stack_ffffffe4;
  BOOLEAN clean_flag_local;
  int saved_errno;
  
  piVar2 = __errno_location();
  iVar1 = *piVar2;
  if (LYCursesON != '\0') {
    if (clean_flag == '\0') {
      stop_curses();
    }
    else {
      cleanup(in_stack_ffffffe4);
    }
  }
  piVar2 = __errno_location();
  *piVar2 = iVar1;
  perror(msg);
  return;
}



// WARNING: Unknown calling convention

void exit_with_perror(char *msg)

{
  final_perror(msg,'\x01');
  exit_immediately(1);
  return;
}



// WARNING: Unknown calling convention

BOOLEAN lookup_link(char *target)

{
  char *pcVar1;
  int iVar2;
  int result;
  char *line;
  char *buffer;
  FILE *ifp;
  
  buffer = (char *)0x0;
  line = (char *)0x0;
  result._0_1_ = '\0';
  ifp = (FILE *)fopen64("traverse.dat","r");
  if (ifp == (FILE *)0x0) {
    ifp = LYNewTxtFile("traverse.dat");
    if (ifp != (FILE *)0x0) {
      LYCloseOutput(ifp);
      return '\0';
    }
    pcVar1 = (char *)gettext("Unable to open traversal file.");
    exit_with_perror(pcVar1);
  }
  HTSprintf0(&line,"%s\n",target);
  do {
    pcVar1 = LYSafeGets(&buffer,ifp);
    if (pcVar1 == (char *)0x0) goto LAB_080dafe5;
    iVar2 = strcmp(line,buffer);
  } while (iVar2 != 0);
  result._0_1_ = '\x01';
LAB_080dafe5:
  if (line != (char *)0x0) {
    free(line);
    line = (char *)0x0;
  }
  if (buffer != (char *)0x0) {
    free(buffer);
    buffer = (char *)0x0;
  }
  LYCloseInput(ifp);
  return (BOOLEAN)result;
}



// WARNING: Unknown calling convention

void add_to_table(char *target)

{
  FILE *__stream;
  char *msg;
  FILE *ifp;
  
  __stream = LYAppendToTxtFile("traverse.dat");
  if (__stream == (FILE *)0x0) {
    msg = (char *)gettext("Unable to open traversal file.");
    exit_with_perror(msg);
  }
  fprintf((FILE *)__stream,"%s\n",target);
  LYCloseOutput(__stream);
  return;
}



// WARNING: Unknown calling convention

void add_to_traverse_list(char *fname,char *prev_link_name)

{
  FILE *__stream;
  char *msg;
  FILE *ifp;
  
  __stream = LYAppendToTxtFile("traverse2.dat");
  if (__stream == (FILE *)0x0) {
    msg = (char *)gettext("Unable to open traversal found file.");
    exit_with_perror(msg);
  }
  fprintf((FILE *)__stream,"%s\t%s\n",fname,prev_link_name);
  LYCloseOutput(__stream);
  return;
}



// WARNING: Unknown calling convention

void dump_traversal_history(void)

{
  FILE *__stream;
  char *msg;
  undefined4 uVar1;
  undefined4 uVar2;
  FILE *ifp;
  int x;
  
  if (0 < nhist) {
    __stream = LYAppendToTxtFile("traverse.dat");
    if (__stream == (FILE *)0x0) {
      msg = (char *)gettext("Unable to open traversal file.");
      final_perror(msg,'\0');
    }
    else {
      uVar1 = gettext("here is a list of the history stack so that you may rebuild");
      uVar2 = gettext("TRAVERSAL WAS INTERRUPTED");
      fprintf((FILE *)__stream,"\n\n%s\n\n\t    %s\n\n",uVar2,uVar1);
      x = nhist;
      while (x = x + -1, -1 < x) {
        fprintf((FILE *)__stream,"%s\t%s\n",history[x].hdoc.title,history[x].hdoc.address);
      }
      LYCloseOutput(__stream);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void add_to_reject_list(char *target)

{
  FILE *pFVar1;
  char *msg;
  FILE *ifp;
  
  if (WWW_TraceFlag != '\0') {
    pFVar1 = TraceFP();
    fprintf((FILE *)pFVar1,"add_to_reject_list(%s)\n",target);
  }
  pFVar1 = LYAppendToTxtFile("reject.dat");
  if (pFVar1 == (FILE *)0x0) {
    msg = (char *)gettext("Unable to open reject file.");
    exit_with_perror(msg);
  }
  fprintf((FILE *)pFVar1,"%s\n",target);
  LYCloseOutput(pFVar1);
  return;
}



// WARNING: Unknown calling convention

BOOLEAN lookup_reject(char *target)

{
  size_t sVar1;
  int iVar2;
  char *pcVar3;
  FILE *__stream;
  int result;
  int len;
  char *line;
  char *buffer;
  FILE *ifp;
  
  buffer = (char *)0x0;
  line = (char *)0x0;
  result = 0;
  ifp = (FILE *)fopen64("reject.dat","r");
  if (ifp == (FILE *)0x0) {
    return '\0';
  }
  HTSprintf0(&line,"%s",target);
  while ((pcVar3 = LYSafeGets(&buffer,ifp), pcVar3 != (char *)0x0 && (result == 0))) {
    LYTrimTrailing(buffer);
    sVar1 = strlen(buffer);
    if (0 < (int)sVar1) {
      if (buffer[sVar1 - 1] == '*') {
        if ((sVar1 == 1) || (iVar2 = strncmp(line,buffer,sVar1 - 1), iVar2 == 0)) {
          result = 1;
        }
      }
      else {
        iVar2 = strcmp(line,buffer);
        if (iVar2 == 0) {
          result = 1;
        }
      }
    }
  }
  if (buffer != (char *)0x0) {
    free(buffer);
    buffer = (char *)0x0;
  }
  if (line != (char *)0x0) {
    free(line);
    line = (char *)0x0;
  }
  LYCloseInput(ifp);
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"lookup_reject(%s) -> %d\n",target,result);
  }
  return (BOOLEAN)result;
}



// WARNING: Unknown calling convention

int EditBinding(int xlkc)

{
  uint uVar1;
  uint local_28;
  uint local_24;
  int local_20;
  int local_1c;
  int local_18;
  int c;
  int xleac;
  int editaction;
  
  uVar1 = xlkc & 0x7ff;
  if (xlkc == -1) {
    local_28 = 0;
  }
  else if ((xlkc & 0x8000U) == 0) {
    if ((xlkc & 0x4000U) == 0) {
      if ((xlkc & 0x2000U) == 0) {
        if ((xlkc & 0x1000U) == 0) {
          xleac = (int)LYLineEditors[current_lineedit][uVar1];
        }
        else {
          if (uVar1 < 0x112) {
            local_18 = (int)Mod3Binding[uVar1];
          }
          else {
            local_18 = 0x1f;
          }
          xleac = local_18;
        }
      }
      else {
        if (uVar1 < 0x112) {
          local_1c = (int)Mod2Binding[uVar1];
        }
        else {
          local_1c = 0x1f;
        }
        xleac = local_1c;
      }
    }
    else {
      if (uVar1 < 0x112) {
        local_20 = (int)Mod1Binding[uVar1];
      }
      else {
        local_20 = 0x1f;
      }
      xleac = local_20;
    }
    if (xleac == 0x1f) {
      editaction = (int)LYLineEditors[current_lineedit][uVar1];
    }
    else {
      editaction = xleac;
    }
    local_28 = editaction;
  }
  else {
    if ((xlkc == -1) || ((xlkc & 0x8000U) == 0)) {
      local_24 = xlkc;
    }
    else {
      local_24 = (int)(xlkc & 0xffff7fffU) >> 8 & 0xff;
    }
    local_28 = local_24;
  }
  return local_28;
}



// WARNING: Unknown calling convention

BOOLEAN LYRemapEditBinding(int xlkc,int lec,int select_edi)

{
  uint uVar1;
  short sVar2;
  BOOLEAN local_15;
  int c;
  int j;
  BOOLEAN success;
  
  uVar1 = xlkc & 0x7ff;
  success = '\0';
  if (((xlkc < 0) || ((xlkc & 0x800U) != 0)) || (0x295 < uVar1)) {
    local_15 = '\0';
  }
  else {
    sVar2 = (short)lec;
    if ((xlkc & 0x4000U) == 0) {
      if ((xlkc & 0x2000U) == 0) {
        if ((xlkc & 0x1000U) == 0) {
          if ((uint)lec < 0x100) {
            if (select_edi < 1) {
              for (j = 0; LYLineeditNames[j] != (char *)0x0; j = j + 1) {
                success = '\x01';
                if ((-1 < select_edi) || (j + 1 + select_edi != 0)) {
                  LYLineEditors[j][uVar1] = (LYEditCode)lec;
                }
              }
            }
            else if ((uint)select_edi < 3) {
              LYLineEditors[select_edi + -1][uVar1] = (LYEditCode)lec;
              success = '\x01';
            }
            local_15 = success;
          }
          else {
            local_15 = '\0';
          }
        }
        else if (uVar1 < 0x112) {
          Mod3Binding[uVar1] = sVar2;
          local_15 = '\x01';
        }
        else {
          local_15 = '\0';
        }
      }
      else if (uVar1 < 0x112) {
        Mod2Binding[uVar1] = sVar2;
        local_15 = '\x01';
      }
      else {
        local_15 = '\0';
      }
    }
    else if (uVar1 < 0x112) {
      Mod1Binding[uVar1] = sVar2;
      local_15 = '\x01';
    }
    else {
      local_15 = '\0';
    }
  }
  return local_15;
}



// WARNING: Unknown calling convention

int LYKeyForEditAction(int lec)

{
  int local_2c;
  int local_28;
  int local_24;
  int local_20;
  int local_1c;
  int local_18;
  int i;
  int editaction;
  
  i = 0x61;
  while( true ) {
    if (i < 0) {
      return -1;
    }
    if ((uint)LYLineEditors[current_lineedit][i] == lec) break;
    if (i == 0x7a) {
      local_2c = 0x20;
    }
    else {
      if (i == 0x60) {
        local_28 = 0x7b;
      }
      else {
        if (i == 0x7e) {
          local_24 = 0;
        }
        else {
          if (i == 0x1f) {
            local_20 = 0x100;
          }
          else {
            if (i == 0x293) {
              local_1c = 0x7f;
            }
            else {
              if (i == 0xff) {
                local_18 = -1;
              }
              else {
                local_18 = i + 1;
              }
              local_1c = local_18;
            }
            local_20 = local_1c;
          }
          local_24 = local_20;
        }
        local_28 = local_24;
      }
      local_2c = local_28;
    }
    i = local_2c;
  }
  return i;
}



// WARNING: Unknown calling convention

int LYEditKeyForAction(int lac,int *pmodkey)

{
  uint uVar1;
  uint local_c4;
  uint local_c0;
  uint local_bc;
  uint local_b8;
  int local_b4;
  int local_b0;
  int local_ac;
  int local_a8;
  int local_a4;
  int local_a0;
  uint local_9c;
  uint local_98;
  uint local_94;
  uint local_90;
  int local_8c;
  int local_88;
  int local_84;
  int local_80;
  int local_7c;
  int local_78;
  uint local_74;
  uint local_70;
  uint local_6c;
  uint local_68;
  int local_64;
  int local_60;
  int local_5c;
  int local_58;
  int local_54;
  int local_50;
  uint local_4c;
  uint local_48;
  uint local_44;
  uint local_40;
  int local_3c;
  int local_38;
  int local_34;
  int local_30;
  int local_2c;
  int local_28;
  int mod3found;
  int mod2found;
  int mod1found;
  int c;
  int i;
  int editaction;
  
  mod1found = -1;
  mod2found = -1;
  mod3found = -1;
  if (pmodkey != (int *)0x0) {
    *pmodkey = -1;
  }
  i = 0x61;
  while (-1 < i) {
    uVar1 = (uint)LYLineEditors[current_lineedit][i];
    if ((lac | 0x1000U) == uVar1) {
      return i;
    }
    if (uVar1 == 6) {
      if (((lynx_edit_mode != '\0') && (no_dired_support == '\0')) && (lac != 0)) {
        if (i == -1) {
          local_c4 = (uint)key_override[0];
        }
        else {
          if ((i & 0x8800U) == 0) {
            local_c0 = (uint)key_override[(i & 0x7ffU) + 1];
          }
          else {
            local_c0 = i & 0xff;
          }
          local_c4 = local_c0;
        }
        if (local_c4 == lac) {
          return i;
        }
      }
      if (i == -1) {
        local_bc = (uint)keymap[0];
      }
      else {
        if ((i & 0x8800U) == 0) {
          local_b8 = (uint)keymap[(i & 0x7ffU) + 1];
        }
        else {
          local_b8 = i & 0xff;
        }
        local_bc = local_b8;
      }
      if (local_bc == lac) {
        return i;
      }
    }
    if (uVar1 == 3) {
      if (((lynx_edit_mode != '\0') && (no_dired_support == '\0')) &&
         ((lac != 0 && ((uint)key_override[10] == lac)))) {
        return i;
      }
      if ((uint)keymap[10] == lac) {
        return i;
      }
    }
    if ((uVar1 == 0x1d) && (mod1found < 0)) {
      mod1found = i;
    }
    if ((uVar1 == 0x1e) && (mod2found < 0)) {
      mod2found = i;
    }
    if (((LYLineEditors[current_lineedit][i] & 0x80) != 0) && (mod3found < 0)) {
      mod3found = i;
    }
    if (i == 0x7a) {
      local_b4 = 0x20;
    }
    else {
      if (i == 0x60) {
        local_b0 = 0x7b;
      }
      else {
        if (i == 0x7e) {
          local_ac = 0;
        }
        else {
          if (i == 0x1f) {
            local_a8 = 0x100;
          }
          else {
            if (i == 0x293) {
              local_a4 = 0x7f;
            }
            else {
              if (i == 0xff) {
                local_a0 = -1;
              }
              else {
                local_a0 = i + 1;
              }
              local_a4 = local_a0;
            }
            local_a8 = local_a4;
          }
          local_ac = local_a8;
        }
        local_b0 = local_ac;
      }
      local_b4 = local_b0;
    }
    i = local_b4;
  }
  if (-1 < mod3found) {
    i = mod3found;
    while (-1 < i) {
      if ((LYLineEditors[current_lineedit][i] & 0x80) != 0) {
        uVar1 = (uint)Mod3Binding[i];
        if (pmodkey != (int *)0x0) {
          *pmodkey = i;
        }
        if ((lac | 0x1000U) == uVar1) {
          return i | 0x1000;
        }
        if (uVar1 == 6) {
          if (((lynx_edit_mode != '\0') && (no_dired_support == '\0')) && (lac != 0)) {
            if (i == -1) {
              local_9c = (uint)key_override[0];
            }
            else {
              if ((i & 0x8800U) == 0) {
                local_98 = (uint)key_override[(i & 0x7ffU) + 1];
              }
              else {
                local_98 = i & 0xff;
              }
              local_9c = local_98;
            }
            if (local_9c == lac) {
              return i | 0x1000;
            }
          }
          if (i == -1) {
            local_94 = (uint)keymap[0];
          }
          else {
            if ((i & 0x8800U) == 0) {
              local_90 = (uint)keymap[(i & 0x7ffU) + 1];
            }
            else {
              local_90 = i & 0xff;
            }
            local_94 = local_90;
          }
          if (local_94 == lac) {
            return i | 0x1000;
          }
        }
        if (uVar1 == 3) {
          if (((lynx_edit_mode != '\0') && (no_dired_support == '\0')) &&
             ((lac != 0 && ((uint)key_override[10] == lac)))) {
            return i | 0x1000;
          }
          if ((uint)keymap[10] == lac) {
            return i | 0x1000;
          }
        }
      }
      if (i == 0x7a) {
        local_8c = 0x20;
      }
      else {
        if (i == 0x60) {
          local_88 = 0x7b;
        }
        else {
          if (i == 0x7e) {
            local_84 = 0;
          }
          else {
            if (i == 0x1f) {
              local_80 = 0x100;
            }
            else {
              if (i == 0x111) {
                local_7c = 0x7f;
              }
              else {
                if (i == 0xff) {
                  local_78 = -1;
                }
                else {
                  local_78 = i + 1;
                }
                local_7c = local_78;
              }
              local_80 = local_7c;
            }
            local_84 = local_80;
          }
          local_88 = local_84;
        }
        local_8c = local_88;
      }
      i = local_8c;
    }
  }
  if (-1 < mod1found) {
    if (pmodkey != (int *)0x0) {
      *pmodkey = mod1found;
    }
    i = 0x61;
    while (-1 < i) {
      uVar1 = (uint)Mod1Binding[i];
      if ((lac | 0x1000U) == uVar1) {
        return i | 0x4000;
      }
      if (uVar1 == 6) {
        if (((lynx_edit_mode != '\0') && (no_dired_support == '\0')) && (lac != 0)) {
          if (i == -1) {
            local_74 = (uint)key_override[0];
          }
          else {
            if ((i & 0x8800U) == 0) {
              local_70 = (uint)key_override[(i & 0x7ffU) + 1];
            }
            else {
              local_70 = i & 0xff;
            }
            local_74 = local_70;
          }
          if (local_74 == lac) {
            return i | 0x4000;
          }
        }
        if (i == -1) {
          local_6c = (uint)keymap[0];
        }
        else {
          if ((i & 0x8800U) == 0) {
            local_68 = (uint)keymap[(i & 0x7ffU) + 1];
          }
          else {
            local_68 = i & 0xff;
          }
          local_6c = local_68;
        }
        if (local_6c == lac) {
          return i | 0x4000;
        }
      }
      if (uVar1 == 3) {
        if ((((lynx_edit_mode != '\0') && (no_dired_support == '\0')) && (lac != 0)) &&
           ((uint)key_override[10] == lac)) {
          return i | 0x4000;
        }
        if ((uint)keymap[10] == lac) {
          return i | 0x4000;
        }
      }
      if (i == 0x7a) {
        local_64 = 0x20;
      }
      else {
        if (i == 0x60) {
          local_60 = 0x7b;
        }
        else {
          if (i == 0x7e) {
            local_5c = 0;
          }
          else {
            if (i == 0x1f) {
              local_58 = 0x100;
            }
            else {
              if (i == 0x111) {
                local_54 = 0x7f;
              }
              else {
                if (i == 0xff) {
                  local_50 = -1;
                }
                else {
                  local_50 = i + 1;
                }
                local_54 = local_50;
              }
              local_58 = local_54;
            }
            local_5c = local_58;
          }
          local_60 = local_5c;
        }
        local_64 = local_60;
      }
      i = local_64;
    }
  }
  if (-1 < mod2found) {
    if (pmodkey != (int *)0x0) {
      *pmodkey = mod1found;
    }
    i = 0x61;
    while (-1 < i) {
      uVar1 = (uint)Mod2Binding[i];
      if ((lac | 0x1000U) == uVar1) {
        return i | 0x2000;
      }
      if (uVar1 == 6) {
        if (((lynx_edit_mode != '\0') && (no_dired_support == '\0')) && (lac != 0)) {
          if (i == -1) {
            local_4c = (uint)key_override[0];
          }
          else {
            if ((i & 0x8800U) == 0) {
              local_48 = (uint)key_override[(i & 0x7ffU) + 1];
            }
            else {
              local_48 = i & 0xff;
            }
            local_4c = local_48;
          }
          if (local_4c == lac) {
            return i | 0x2000;
          }
        }
        if (i == -1) {
          local_44 = (uint)keymap[0];
        }
        else {
          if ((i & 0x8800U) == 0) {
            local_40 = (uint)keymap[(i & 0x7ffU) + 1];
          }
          else {
            local_40 = i & 0xff;
          }
          local_44 = local_40;
        }
        if (local_44 == lac) {
          return i | 0x2000;
        }
      }
      if (uVar1 == 3) {
        if (((lynx_edit_mode != '\0') && (no_dired_support == '\0')) &&
           ((lac != 0 && ((uint)key_override[10] == lac)))) {
          return i | 0x2000;
        }
        if ((uint)keymap[10] == lac) {
          return i | 0x2000;
        }
      }
      if (i == 0x7a) {
        local_3c = 0x20;
      }
      else {
        if (i == 0x60) {
          local_38 = 0x7b;
        }
        else {
          if (i == 0x7e) {
            local_34 = 0;
          }
          else {
            if (i == 0x1f) {
              local_30 = 0x100;
            }
            else {
              if (i == 0x111) {
                local_2c = 0x7f;
              }
              else {
                if (i == 0xff) {
                  local_28 = -1;
                }
                else {
                  local_28 = i + 1;
                }
                local_2c = local_28;
              }
              local_30 = local_2c;
            }
            local_34 = local_30;
          }
          local_38 = local_34;
        }
        local_3c = local_38;
      }
      i = local_3c;
    }
  }
  if (pmodkey != (int *)0x0) {
    *pmodkey = -1;
  }
  return -1;
}



// WARNING: Unknown calling convention

int LYEditmapDeclared(void)

{
  int status;
  
  return 1;
}



// WARNING: Unknown calling convention

void HTMLSetCharacterHandling(int i)

{
  char *__s1;
  int iVar1;
  BOOLEAN BVar2;
  int iVar3;
  int iVar4;
  FILE *pFVar5;
  BOOLEAN local_24;
  undefined *local_20;
  undefined *local_1c;
  char *mime;
  int UCLYhndl_for_unspec_flag;
  int chndl;
  BOOLEAN LYRawMode_flag;
  
  iVar3 = safeUCGetLYhndl_byMIME(UCAssume_MIMEcharset);
  BVar2 = LYRawMode;
  iVar1 = UCLYhndl_for_unspec;
  if (LYCharSet_UC[i].enc == 5) {
    __s1 = LYCharSet_UC[i].MIMEname;
    iVar4 = strcmp(__s1,"euc-cn");
    if (iVar4 == 0) {
      HTCJK = CHINESE;
      kanji_code = EUC;
    }
    else {
      iVar4 = strcmp(__s1,"euc-jp");
      if (iVar4 == 0) {
        HTCJK = JAPANESE;
        kanji_code = EUC;
      }
      else {
        iVar4 = strcmp(__s1,"shift_jis");
        if (iVar4 == 0) {
          HTCJK = JAPANESE;
          kanji_code = SJIS;
        }
        else {
          iVar4 = strcmp(__s1,"euc-kr");
          if (iVar4 == 0) {
            HTCJK = KOREAN;
            kanji_code = EUC;
          }
          else {
            iVar4 = strcmp(__s1,"big5");
            if (iVar4 == 0) {
              HTCJK = TAIPEI;
              kanji_code = EUC;
            }
          }
        }
      }
    }
    if (LYUseDefaultRawMode == '\0') {
      HTCJK = NOCJK;
    }
    LYRawMode = HTCJK != NOCJK;
    HTPassEightBitRaw = '\0';
    HTPassEightBitNum = '\0';
    HTPassHighCtrlRaw = HTCJK != NOCJK;
  }
  else {
    HTCJK = NOCJK;
    kanji_code = NOKANJI;
    if (i == iVar3) {
      LYRawMode = LYUseDefaultRawMode;
    }
    else {
      LYRawMode = LYUseDefaultRawMode == '\0';
    }
    if (((LYCharSet_UC[i].codepoints & 2U) == 0) && ((LYCharSet_UC[i].like8859 & 0x100U) == 0)) {
      local_24 = '\0';
    }
    else {
      local_24 = '\x01';
    }
    HTPassEightBitNum = local_24;
    if (LYRawMode == '\0') {
      HTPassEightBitRaw = '\0';
      if (i != iVar3) {
        HTPassHighCtrlRaw = '\0';
        goto LAB_080dc462;
      }
    }
    else {
      HTPassEightBitRaw = LYlowest_eightbit[i] < 0xa1;
    }
    HTPassHighCtrlRaw = LYlowest_eightbit[i] < 0x83;
  }
LAB_080dc462:
  HTPassHighCtrlNum = '\0';
  if (LYRawMode == '\0') {
    if ((iVar3 == i) ||
       ((UCLYhndl_for_unspec = iVar3, LYCharSet_UC[i].enc == 5 && (LYCharSet_UC[iVar3].enc == 5))))
    {
      UCLYhndl_for_unspec = LATIN1;
    }
  }
  else {
    UCLYhndl_for_unspec = i;
  }
  ena_csi(0x9b < LYlowest_eightbit[current_char_set]);
  if (WWW_TraceFlag != '\0') {
    if ((BVar2 != LYRawMode) && (WWW_TraceFlag != '\0')) {
      if (LYRawMode == '\0') {
        local_20 = &DAT_0816980b;
      }
      else {
        local_20 = &DAT_08169808;
      }
      if (BVar2 == '\0') {
        local_1c = &DAT_0816980b;
      }
      else {
        local_1c = &DAT_08169808;
      }
      pFVar5 = TraceFP();
      fprintf((FILE *)pFVar5,"HTMLSetCharacterHandling: LYRawMode changed %s -> %s\n",local_1c,
              local_20);
    }
    iVar3 = UCLYhndl_for_unspec;
    if ((iVar1 != UCLYhndl_for_unspec) && (WWW_TraceFlag != '\0')) {
      pFVar5 = TraceFP();
      fprintf((FILE *)pFVar5,"HTMLSetCharacterHandling: UCLYhndl_for_unspec changed %d -> %d\n",
              iVar1,iVar3);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void Set_HTCJK(char *inMIMEname,char *outMIMEname)

{
  int iVar1;
  
  if (LYRawMode == '\0') {
    HTCJK = NOCJK;
    return;
  }
  iVar1 = strcmp(inMIMEname,"euc-jp");
  if ((((iVar1 == 0) || (iVar1 = strcmp(inMIMEname,"utf-8"), iVar1 == 0)) ||
      (iVar1 = strcmp(inMIMEname,"shift_jis"), iVar1 == 0)) &&
     ((iVar1 = strcmp(outMIMEname,"euc-jp"), iVar1 == 0 ||
      (iVar1 = strcmp(outMIMEname,"shift_jis"), iVar1 == 0)))) {
    HTCJK = JAPANESE;
  }
  else {
    iVar1 = strcmp(inMIMEname,"euc-cn");
    if ((iVar1 == 0) && (iVar1 = strcmp(outMIMEname,"euc-cn"), iVar1 == 0)) {
      HTCJK = CHINESE;
      return;
    }
    iVar1 = strcmp(inMIMEname,"big5");
    if ((iVar1 == 0) && (iVar1 = strcmp(outMIMEname,"big5"), iVar1 == 0)) {
      HTCJK = TAIPEI;
      return;
    }
    iVar1 = strcmp(inMIMEname,"euc-kr");
    if ((iVar1 == 0) && (iVar1 = strcmp(outMIMEname,"euc-kr"), iVar1 == 0)) {
      HTCJK = KOREAN;
      return;
    }
    HTCJK = NOCJK;
  }
  return;
}



// WARNING: Unknown calling convention

void HTMLSetRawModeDefault(int i)

{
  LYDefaultRawMode = LYCharSet_UC[i].enc == 5;
  return;
}



void HTMLSetUseDefaultRawMode(int i,BOOLEAN modeflag)

{
  int iVar1;
  BOOLEAN modeflag_local;
  int chndl;
  
  if (LYCharSet_UC[i].enc == 5) {
    LYUseDefaultRawMode = modeflag;
  }
  else {
    iVar1 = safeUCGetLYhndl_byMIME(UCAssume_MIMEcharset);
    LYUseDefaultRawMode = modeflag;
    if (i != iVar1) {
      LYUseDefaultRawMode = modeflag == '\0';
    }
  }
  return;
}



// WARNING: Unknown calling convention

void HTMLSetHaveCJKCharacterSet(int i)

{
  LYHaveCJKCharacterSet = LYCharSet_UC[i].enc == 5;
  return;
}



// WARNING: Unknown calling convention

void HTMLSetDisplayCharsetMatchLocale(int i)

{
  int iVar1;
  BOOLEAN match;
  
  if (LYHaveCJKCharacterSet == '\0') {
    iVar1 = strncasecomp(LYCharSet_UC[i].MIMEname,"cp",2);
    if ((iVar1 == 0) && (iVar1 = strncasecomp(LYCharSet_UC[i].MIMEname,"windows",7), iVar1 == 0)) {
      match = '\x01';
      if (UCForce8bitTOUPPER != '\0') {
        match = '\0';
      }
    }
    else {
      match = '\0';
    }
    DisplayCharsetMatchLocale = match;
    return;
  }
  DisplayCharsetMatchLocale = '\x01';
  return;
}



// WARNING: Unknown calling convention

int UCGetLYhndl_byAnyName(char *value)

{
  FILE *__stream;
  int iVar1;
  int local_18;
  int i;
  
  LYTrimTrailing(value);
  if (value == (char *)0x0) {
    local_18 = -1;
  }
  else {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"UCGetLYhndl_byAnyName(%s)\n",value);
    }
    for (i = 0; (i < 0x3c && (LYchar_set_names[i] != (char *)0x0)); i = i + 1) {
      iVar1 = strcmp(value,LYchar_set_names[i]);
      if (iVar1 == 0) {
        return i;
      }
    }
    for (i = 0; OLD_charset_names[i].fullname != (char *)0x0; i = i + 1) {
      iVar1 = strcmp(value,OLD_charset_names[i].fullname);
      if (iVar1 == 0) {
        iVar1 = UCGetLYhndl_byMIME(OLD_charset_names[i].MIMEname);
        return iVar1;
      }
    }
    local_18 = UCGetLYhndl_byMIME(value);
  }
  return local_18;
}



// WARNING: Unknown calling convention

char * HTMLGetEntityName(UCode_t code)

{
  char *local_18;
  int MaxValue;
  
  if ((code < 0) || (0x5f < code)) {
    local_18 = "";
  }
  else {
    local_18 = LYEntityNames[code];
  }
  return local_18;
}



// WARNING: Unknown calling convention

UCode_t HTMLGetEntityUCValue(char *name)

{
  size_t sVar1;
  int iVar2;
  UCode_t local_28;
  size_t number_of_unicode_entities;
  int diff;
  size_t low;
  size_t high;
  size_t i;
  UCode_t value;
  
  value = 0;
  if ((name == (char *)0x0) || (*name == '\0')) {
    local_28 = 0;
  }
  else {
    low = 0;
    high = 0x3e4;
    sVar1 = high;
    while (high = sVar1, low < high) {
      sVar1 = (high - low >> 1) + low;
      iVar2 = strcmp(HTMLGetEntityUCValue::unicode_entities[sVar1].name,name);
      if (iVar2 == 0) {
        value = (UCode_t)HTMLGetEntityUCValue::unicode_entities[sVar1].code;
        break;
      }
      if (iVar2 < 0) {
        low = sVar1 + 1;
        sVar1 = high;
      }
    }
    local_28 = value;
  }
  return local_28;
}



// WARNING: Unknown calling convention

void HTMLUseCharacterSet(int i)

{
  HTMLSetRawModeDefault(i);
  p_entity_values = LYCharSets[i];
  HTMLSetCharacterHandling(i);
  HTMLSetHaveCJKCharacterSet(i);
  HTMLSetDisplayCharsetMatchLocale(i);
  return;
}



// WARNING: Unknown calling convention

int LYCharSetsDeclared(void)

{
  UCInit();
  return UCInitialized;
}



void LYEntify(char **str,BOOLEAN isTITLE)

{
  bool bVar1;
  bool bVar2;
  char *pcVar3;
  size_t sVar4;
  BOOLEAN isTITLE_local;
  int in_sjis;
  _state state;
  int gts;
  int lts;
  int amps;
  char *cp;
  char *q;
  char *p;
  
  p = *str;
  amps = 0;
  lts = 0;
  gts = 0;
  state = S_text;
  bVar1 = false;
  if ((p != (char *)0x0) && (*p != '\0')) {
    while ((*p != '\0' && (pcVar3 = strchr(p,0x26), pcVar3 != (char *)0x0))) {
      amps = amps + 1;
      p = pcVar3 + 1;
    }
    if (isTITLE == '\x01') {
      p = *str;
      while ((*p != '\0' && (pcVar3 = strchr(p,0x3c), pcVar3 != (char *)0x0))) {
        lts = lts + 1;
        p = pcVar3 + 1;
      }
    }
    if (isTITLE == '\x01') {
      p = *str;
      while ((*p != '\0' && (pcVar3 = strchr(p,0x3e), pcVar3 != (char *)0x0))) {
        gts = gts + 1;
        p = pcVar3 + 1;
      }
    }
    if (((amps != 0) || (lts != 0)) || (gts != 0)) {
      sVar4 = strlen(*str);
      pcVar3 = (char *)calloc(sVar4 + lts * 3 + amps * 4 + gts * 3 + 1,1);
      if (pcVar3 == (char *)0x0) {
        outofmem("./LYCharUtils.c","LYEntify");
      }
      q = pcVar3;
      for (p = *str; *p != '\0'; p = p + 1) {
        if (HTCJK == NOCJK) {
LAB_080dcf24:
          if (*p == '&') {
            *q = '&';
            q[1] = 'a';
            q[2] = 'm';
            q[3] = 'p';
            q[4] = ';';
            q = q + 5;
          }
          else if ((isTITLE == '\0') || (*p != '<')) {
            if ((isTITLE == '\0') || (*p != '>')) {
              *q = *p;
              q = q + 1;
            }
            else {
              *q = '&';
              q[1] = 'g';
              q[2] = 't';
              q[3] = ';';
              q = q + 4;
            }
          }
          else {
            *q = '&';
            q[1] = 'l';
            q[2] = 't';
            q[3] = ';';
            q = q + 4;
          }
        }
        else {
          switch(state) {
          case S_text:
            if (*p != '\x1b') goto switchD_080dcc08_caseD_6;
            state = S_esc;
            *q = *p;
            q = q + 1;
            break;
          case S_esc:
            if (*p == '$') {
              state = S_dollar;
              *q = *p;
              q = q + 1;
            }
            else if (*p == '(') {
              state = S_paren;
              *q = *p;
              q = q + 1;
            }
            else {
              state = S_text;
              *q = *p;
              q = q + 1;
            }
            break;
          case S_dollar:
            if (((*p == '@') || (*p == 'B')) || (*p == 'A')) {
              state = S_nonascii_text;
              *q = *p;
              q = q + 1;
            }
            else if (*p == '(') {
              state = S_dollar_paren;
              *q = *p;
              q = q + 1;
            }
            else {
              state = S_text;
              *q = *p;
              q = q + 1;
            }
            break;
          case S_paren:
            if (((*p == 'B') || (*p == 'J')) || (*p == 'T')) {
              state = S_text;
              *q = *p;
              q = q + 1;
            }
            else {
              if (*p != 'I') goto switchD_080dcc08_caseD_4;
              state = S_nonascii_text;
              *q = *p;
              q = q + 1;
            }
            break;
          case S_nonascii_text:
switchD_080dcc08_caseD_4:
            if (*p == '\x1b') {
              state = S_esc;
            }
            *q = *p;
            q = q + 1;
            break;
          case S_dollar_paren:
            if (*p == 'C') {
              state = S_nonascii_text;
              *q = *p;
              q = q + 1;
            }
            else {
              state = S_text;
              *q = *p;
              q = q + 1;
            }
            break;
          default:
switchD_080dcc08_caseD_6:
            if (p[1] == '\0') goto LAB_080dcf24;
            if ((((((byte)*p < 0xa1) || (*p == -1)) || ((byte)p[1] < 0xa1)) || (p[1] == -1)) &&
               (((*p != -0x72 || ((byte)p[1] < 0xa1)) || (0xdf < (byte)p[1])))) {
              if ((((byte)p[1] < 0x40) || (p[1] == '\x7f')) || (0xfc < (byte)p[1])) {
LAB_080dceb5:
                if ((((byte)*p < 0xa1) || (*p == -1)) ||
                   ((((byte)p[1] < 0x40 || (0x7e < (byte)p[1])) &&
                    (((byte)p[1] < 0xa1 || (p[1] == -1)))))) goto LAB_080dcf24;
              }
              else if (((byte)*p < 0x81) || (0x9f < (byte)*p)) {
                if ((bVar1) && ((0xdf < (byte)*p && ((byte)*p < 0xf0)))) {
                  bVar2 = true;
                }
                else {
                  bVar2 = false;
                }
                if (!bVar2) goto LAB_080dceb5;
              }
              else {
                bVar1 = true;
              }
            }
            *q = *p;
            p = p + 1;
            q[1] = *p;
            q = q + 2;
          }
        }
      }
      *q = '\0';
      if (*str != (char *)0x0) {
        free(*str);
        *str = (char *)0x0;
      }
      *str = pcVar3;
    }
  }
  return;
}



// WARNING: Unknown calling convention

void LYTrimHead(char *str)

{
  char *ns;
  char *s;
  
  s = str;
  if ((str != (char *)0x0) && (*str != '\0')) {
    for (; (*s != '\0' && (((byte)*s < 0x21 && (*s != '\x1b')))); s = s + 1) {
    }
    if (str < s) {
      ns = str;
      for (; *s != '\0'; s = s + 1) {
        *ns = *s;
        ns = ns + 1;
      }
      *ns = '\0';
    }
  }
  return;
}



// WARNING: Unknown calling convention

void LYTrimTail(char *str)

{
  int i;
  
  if ((str != (char *)0x0) && (*str != '\0')) {
    i = strlen(str);
    while ((i = i - 1, -1 < i && ((byte)str[i] < 0x21))) {
      str[i] = '\0';
    }
  }
  return;
}



// WARNING: Unknown calling convention

char * LYFindEndOfComment(char *str)

{
  int iVar1;
  char *local_18;
  comment_state state;
  char *cp1;
  char *cp;
  
  if (str == (char *)0x0) {
    local_18 = (char *)0x0;
  }
  else {
    iVar1 = strncmp(str,"<!--",4);
    if (iVar1 == 0) {
      cp = str + 4;
      local_18 = cp;
      if (*cp != '>') {
        local_18 = strchr(cp,0x3e);
        if (local_18 == (char *)0x0) {
          local_18 = str;
        }
        else if (*cp != '-') {
          state = start2;
          for (; *cp != '\0'; cp = cp + 1) {
            if (state == start2) {
              if (*cp == '-') {
                state = end1;
              }
            }
            else if (state == start1) {
              if (*cp != '-') {
                return local_18;
              }
              state = start2;
            }
            else if (state == end1) {
              if (*cp != '-') {
                return local_18;
              }
              state = end2;
            }
            else if (state == end2) {
              if (*cp == '>') {
                return cp;
              }
              if (*cp == '-') {
                state = start1;
              }
              else {
                if (0x20 < (byte)*cp) {
                  return local_18;
                }
                if (*cp == '\x1b') {
                  return local_18;
                }
              }
            }
          }
        }
      }
    }
    else {
      local_18 = str;
    }
  }
  return local_18;
}



void LYFillLocalFileURL(char **href,char *base)

{
  int iVar1;
  int iVar2;
  char *pcVar3;
  char *pcVar4;
  int in_GS_OFFSET;
  char *base_local;
  char **href_local;
  char *temp2;
  char *temp;
  char curdir [256];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  temp = (char *)0x0;
  if ((*href == (char *)0x0) || (**href == '\0')) goto LAB_080dd617;
  iVar2 = strcmp(*href,"//");
  if (iVar2 == 0) {
LAB_080dd2f5:
    if ((base != (char *)0x0) && ((*base == 'f' || (*base == 'F')))) {
      iVar2 = strncasecomp(base,"file:",5);
      if (iVar2 == 0) {
        HTSACopy(&temp,"file:");
        HTSACat(&temp,*href);
        HTSACopy(href,temp);
      }
    }
  }
  else {
    iVar2 = strncmp(*href,"///",3);
    if (iVar2 == 0) goto LAB_080dd2f5;
  }
  if ((**href == 'f') || (**href == 'F')) {
    iVar2 = strncasecomp(*href,"file:",5);
    if (iVar2 == 0) {
      if ((*href)[5] == '\0') {
        HTSACat(href,"//localhost");
      }
      else {
        iVar2 = strcmp(*href,"file://");
        if (iVar2 == 0) {
          HTSACat(href,"localhost");
        }
        else {
          iVar2 = strncmp(*href,"file:///",8);
          if (iVar2 == 0) {
            HTSACopy(&temp,*href + 7);
            LYLocalFileToURL(href,temp);
          }
          else {
            iVar2 = strncmp(*href,"file:/",6);
            if ((iVar2 == 0) && ((*href)[6] != '/')) {
              HTSACopy(&temp,*href + 5);
              LYLocalFileToURL(href,temp);
            }
          }
        }
      }
    }
  }
  iVar2 = strcmp(*href,"file://localhost");
  if (iVar2 == 0) {
    pcVar3 = Current_Dir(curdir);
    pcVar3 = wwwName(pcVar3);
    if (*pcVar3 != '/') {
      LYAddHtmlSep(href);
    }
    pcVar4 = strchr(pcVar3,0x25);
    if (pcVar4 == (char *)0x0) {
      pcVar4 = strchr(pcVar3,0x23);
      if (pcVar4 == (char *)0x0) {
        HTSACat(href,pcVar3);
        goto LAB_080dd5f5;
      }
    }
    if (temp != (char *)0x0) {
      free(temp);
      temp = (char *)0x0;
    }
    temp = HTEscape(pcVar3,'\x04');
    HTSACat(href,temp);
  }
LAB_080dd5f5:
  if (temp != (char *)0x0) {
    free(temp);
    temp = (char *)0x0;
  }
LAB_080dd617:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



// WARNING: Unknown calling convention

void LYAddMETAcharsetToFD(FILE *fd,int disp_chndl)

{
  if (disp_chndl == -1) {
    disp_chndl = current_char_set;
  }
  if ((((fd != (FILE *)0x0) && (-1 < disp_chndl)) && (UCLYhndl_HTFile_for_unspec != disp_chndl)) &&
     (LYCharSet_UC[disp_chndl].enc != 0)) {
    fprintf((FILE *)fd,"<META %s content=\"text/html;charset=%s\">\n","http-equiv=\"content-type\"",
            LYCharSet_UC[disp_chndl].MIMEname);
  }
  return;
}



// WARNING: Unknown calling convention

char * LYUppercaseA_OL_String(int seqnum)

{
  if (seqnum < 2) {
    memcpy(LYUppercaseA_OL_String::OLstring,&DAT_0816d4ca,4);
  }
  else if (seqnum < 0x1b) {
    sprintf(LYUppercaseA_OL_String::OLstring," %c.",seqnum + 0x40);
  }
  else if (seqnum < 0x2bf) {
    sprintf(LYUppercaseA_OL_String::OLstring,"%c%c.",(seqnum + -1) / 0x1a + 0x40,
            ((seqnum + -1) / 0x1a) * -0x1a + seqnum + 0x40);
  }
  else if (seqnum < 0x4767) {
    sprintf(LYUppercaseA_OL_String::OLstring,"%c%c%c.",(seqnum + -0x1b) / 0x2a4 + 0x40,
            (((seqnum + -0x1b) / 0x2a4) * -0x2a4 + seqnum + -1) / 0x1a + 0x40,
            ((seqnum + -1) / 0x1a) * -0x1a + seqnum + 0x40);
  }
  else {
    memcpy(LYUppercaseA_OL_String::OLstring,&DAT_0816d4e1,5);
  }
  return LYUppercaseA_OL_String::OLstring;
}



// WARNING: Unknown calling convention

char * LYLowercaseA_OL_String(int seqnum)

{
  if (seqnum < 2) {
    memcpy(LYLowercaseA_OL_String::OLstring,&DAT_0816d4e6,4);
  }
  else if (seqnum < 0x1b) {
    sprintf(LYLowercaseA_OL_String::OLstring," %c.",seqnum + 0x60);
  }
  else if (seqnum < 0x2bf) {
    sprintf(LYLowercaseA_OL_String::OLstring,"%c%c.",(seqnum + -1) / 0x1a + 0x60,
            ((seqnum + -1) / 0x1a) * -0x1a + seqnum + 0x60);
  }
  else if (seqnum < 0x4767) {
    sprintf(LYLowercaseA_OL_String::OLstring,"%c%c%c.",(seqnum + -0x1b) / 0x2a4 + 0x60,
            (((seqnum + -0x1b) / 0x2a4) * -0x2a4 + seqnum + -1) / 0x1a + 0x60,
            ((seqnum + -1) / 0x1a) * -0x1a + seqnum + 0x60);
  }
  else {
    memcpy(LYLowercaseA_OL_String::OLstring,&DAT_0816d4ea,5);
  }
  return LYLowercaseA_OL_String::OLstring;
}



// WARNING: Unknown calling convention

char * LYUppercaseI_OL_String(int seqnum)

{
  size_t sVar1;
  undefined *puVar2;
  char *__src;
  size_t sVar3;
  int Arabic;
  
  Arabic = seqnum;
  if (seqnum < 3000) {
    if (seqnum == 0x32) {
      memcpy(LYUppercaseI_OL_String::OLstring,&DAT_0816d500,4);
    }
    else if (seqnum < 0x33) {
      if (seqnum == 5) {
        memcpy(LYUppercaseI_OL_String::OLstring,&DAT_0816d4f8,4);
      }
      else if (seqnum == 10) {
        memcpy(LYUppercaseI_OL_String::OLstring,&DAT_0816d4fc,4);
      }
      else {
        if (seqnum != 1) {
LAB_080ddbf6:
          LYUppercaseI_OL_String::OLstring[0] = '\0';
          for (; 999 < Arabic; Arabic = Arabic + -1000) {
            sVar3 = 2;
            puVar2 = &DAT_0816d510;
            sVar1 = strlen(LYUppercaseI_OL_String::OLstring);
            memcpy(LYUppercaseI_OL_String::OLstring + sVar1,puVar2,sVar3);
          }
          if (899 < Arabic) {
            sVar3 = 3;
            puVar2 = &DAT_0816d512;
            sVar1 = strlen(LYUppercaseI_OL_String::OLstring);
            memcpy(LYUppercaseI_OL_String::OLstring + sVar1,puVar2,sVar3);
            Arabic = Arabic + -900;
          }
          if (499 < Arabic) {
            sVar3 = 2;
            puVar2 = &DAT_0816d515;
            sVar1 = strlen(LYUppercaseI_OL_String::OLstring);
            memcpy(LYUppercaseI_OL_String::OLstring + sVar1,puVar2,sVar3);
            for (Arabic = Arabic + -500; 499 < Arabic; Arabic = Arabic + -10) {
              sVar3 = 2;
              puVar2 = &DAT_0816d517;
              sVar1 = strlen(LYUppercaseI_OL_String::OLstring);
              memcpy(LYUppercaseI_OL_String::OLstring + sVar1,puVar2,sVar3);
            }
          }
          if (399 < Arabic) {
            sVar3 = 3;
            puVar2 = &DAT_0816d519;
            sVar1 = strlen(LYUppercaseI_OL_String::OLstring);
            memcpy(LYUppercaseI_OL_String::OLstring + sVar1,puVar2,sVar3);
            Arabic = Arabic + -400;
          }
          for (; 99 < Arabic; Arabic = Arabic + -100) {
            sVar3 = 2;
            puVar2 = &DAT_0816d517;
            sVar1 = strlen(LYUppercaseI_OL_String::OLstring);
            memcpy(LYUppercaseI_OL_String::OLstring + sVar1,puVar2,sVar3);
          }
          if (0x59 < Arabic) {
            sVar3 = 3;
            puVar2 = &DAT_0816d51c;
            sVar1 = strlen(LYUppercaseI_OL_String::OLstring);
            memcpy(LYUppercaseI_OL_String::OLstring + sVar1,puVar2,sVar3);
            Arabic = Arabic + -0x5a;
          }
          if (0x31 < Arabic) {
            sVar3 = 2;
            puVar2 = &DAT_0816d51f;
            sVar1 = strlen(LYUppercaseI_OL_String::OLstring);
            memcpy(LYUppercaseI_OL_String::OLstring + sVar1,puVar2,sVar3);
            for (Arabic = Arabic + -0x32; 0x31 < Arabic; Arabic = Arabic + -10) {
              sVar3 = 2;
              puVar2 = &DAT_0816d521;
              sVar1 = strlen(LYUppercaseI_OL_String::OLstring);
              memcpy(LYUppercaseI_OL_String::OLstring + sVar1,puVar2,sVar3);
            }
          }
          if (0x27 < Arabic) {
            sVar3 = 3;
            puVar2 = &DAT_0816d523;
            sVar1 = strlen(LYUppercaseI_OL_String::OLstring);
            memcpy(LYUppercaseI_OL_String::OLstring + sVar1,puVar2,sVar3);
            Arabic = Arabic + -0x28;
          }
          do {
            switch(Arabic) {
            case 0:
              goto switchD_080dde69_caseD_0;
            case 1:
              sVar3 = 3;
              puVar2 = &DAT_0816d526;
              sVar1 = strlen(LYUppercaseI_OL_String::OLstring);
              memcpy(LYUppercaseI_OL_String::OLstring + sVar1,puVar2,sVar3);
              goto LAB_080de05e;
            case 2:
              sVar3 = 4;
              puVar2 = &DAT_0816d529;
              sVar1 = strlen(LYUppercaseI_OL_String::OLstring);
              memcpy(LYUppercaseI_OL_String::OLstring + sVar1,puVar2,sVar3);
              goto LAB_080de05e;
            case 3:
              sVar3 = 5;
              puVar2 = &DAT_0816d52d;
              sVar1 = strlen(LYUppercaseI_OL_String::OLstring);
              memcpy(LYUppercaseI_OL_String::OLstring + sVar1,puVar2,sVar3);
              goto LAB_080de05e;
            case 4:
              sVar3 = 4;
              puVar2 = &DAT_0816d532;
              sVar1 = strlen(LYUppercaseI_OL_String::OLstring);
              memcpy(LYUppercaseI_OL_String::OLstring + sVar1,puVar2,sVar3);
              goto LAB_080de05e;
            case 5:
              sVar3 = 3;
              puVar2 = &DAT_0816d536;
              sVar1 = strlen(LYUppercaseI_OL_String::OLstring);
              memcpy(LYUppercaseI_OL_String::OLstring + sVar1,puVar2,sVar3);
              goto LAB_080de05e;
            case 6:
              sVar3 = 4;
              puVar2 = &DAT_0816d539;
              sVar1 = strlen(LYUppercaseI_OL_String::OLstring);
              memcpy(LYUppercaseI_OL_String::OLstring + sVar1,puVar2,sVar3);
              goto LAB_080de05e;
            case 7:
              sVar3 = 5;
              puVar2 = &DAT_0816d53d;
              sVar1 = strlen(LYUppercaseI_OL_String::OLstring);
              memcpy(LYUppercaseI_OL_String::OLstring + sVar1,puVar2,sVar3);
              goto LAB_080de05e;
            case 8:
              sVar3 = 6;
              __src = "VIII.";
              sVar1 = strlen(LYUppercaseI_OL_String::OLstring);
              memcpy(LYUppercaseI_OL_String::OLstring + sVar1,__src,sVar3);
              goto LAB_080de05e;
            case 9:
              sVar3 = 4;
              puVar2 = &DAT_0816d548;
              sVar1 = strlen(LYUppercaseI_OL_String::OLstring);
              memcpy(LYUppercaseI_OL_String::OLstring + sVar1,puVar2,sVar3);
              goto LAB_080de05e;
            case 10:
              sVar3 = 3;
              puVar2 = &DAT_0816d54c;
              sVar1 = strlen(LYUppercaseI_OL_String::OLstring);
              memcpy(LYUppercaseI_OL_String::OLstring + sVar1,puVar2,sVar3);
              goto LAB_080de05e;
            default:
              sVar3 = 2;
              puVar2 = &DAT_0816d521;
              sVar1 = strlen(LYUppercaseI_OL_String::OLstring);
              memcpy(LYUppercaseI_OL_String::OLstring + sVar1,puVar2,sVar3);
              Arabic = Arabic + -10;
            }
          } while( true );
        }
        memcpy(LYUppercaseI_OL_String::OLstring,&DAT_0816d4f4,4);
      }
    }
    else if (seqnum == 500) {
      memcpy(LYUppercaseI_OL_String::OLstring,&DAT_0816d508,4);
    }
    else if (seqnum == 1000) {
      memcpy(LYUppercaseI_OL_String::OLstring,&DAT_0816d50c,4);
    }
    else {
      if (seqnum != 100) goto LAB_080ddbf6;
      memcpy(LYUppercaseI_OL_String::OLstring,&DAT_0816d504,4);
    }
  }
  else {
    memcpy(LYUppercaseI_OL_String::OLstring,&DAT_0816d4ef,5);
  }
  goto LAB_080de05e;
switchD_080dde69_caseD_0:
  sVar3 = 2;
  puVar2 = &DAT_0816d54f;
  sVar1 = strlen(LYUppercaseI_OL_String::OLstring);
  memcpy(LYUppercaseI_OL_String::OLstring + sVar1,puVar2,sVar3);
LAB_080de05e:
  return LYUppercaseI_OL_String::OLstring;
}



// WARNING: Unknown calling convention

char * LYLowercaseI_OL_String(int seqnum)

{
  size_t sVar1;
  undefined *puVar2;
  char *__src;
  size_t sVar3;
  int Arabic;
  
  Arabic = seqnum;
  if (seqnum < 3000) {
    if (seqnum == 0x32) {
      memcpy(LYLowercaseI_OL_String::OLstring,&DAT_0816d591,4);
    }
    else if (seqnum < 0x33) {
      if (seqnum == 5) {
        memcpy(LYLowercaseI_OL_String::OLstring,&DAT_0816d589,4);
      }
      else if (seqnum == 10) {
        memcpy(LYLowercaseI_OL_String::OLstring,&DAT_0816d58d,4);
      }
      else {
        if (seqnum != 1) {
LAB_080de212:
          LYLowercaseI_OL_String::OLstring[0] = '\0';
          for (; 999 < Arabic; Arabic = Arabic + -1000) {
            sVar3 = 2;
            puVar2 = &DAT_0816d5a1;
            sVar1 = strlen(LYLowercaseI_OL_String::OLstring);
            memcpy(LYLowercaseI_OL_String::OLstring + sVar1,puVar2,sVar3);
          }
          if (899 < Arabic) {
            sVar3 = 3;
            puVar2 = &DAT_0816d5a3;
            sVar1 = strlen(LYLowercaseI_OL_String::OLstring);
            memcpy(LYLowercaseI_OL_String::OLstring + sVar1,puVar2,sVar3);
            Arabic = Arabic + -900;
          }
          if (499 < Arabic) {
            sVar3 = 2;
            puVar2 = &DAT_0816d5a6;
            sVar1 = strlen(LYLowercaseI_OL_String::OLstring);
            memcpy(LYLowercaseI_OL_String::OLstring + sVar1,puVar2,sVar3);
            for (Arabic = Arabic + -500; 499 < Arabic; Arabic = Arabic + -10) {
              sVar3 = 2;
              puVar2 = &DAT_0816d5a8;
              sVar1 = strlen(LYLowercaseI_OL_String::OLstring);
              memcpy(LYLowercaseI_OL_String::OLstring + sVar1,puVar2,sVar3);
            }
          }
          if (399 < Arabic) {
            sVar3 = 3;
            puVar2 = &DAT_0816d5aa;
            sVar1 = strlen(LYLowercaseI_OL_String::OLstring);
            memcpy(LYLowercaseI_OL_String::OLstring + sVar1,puVar2,sVar3);
            Arabic = Arabic + -400;
          }
          for (; 99 < Arabic; Arabic = Arabic + -100) {
            sVar3 = 2;
            puVar2 = &DAT_0816d5a8;
            sVar1 = strlen(LYLowercaseI_OL_String::OLstring);
            memcpy(LYLowercaseI_OL_String::OLstring + sVar1,puVar2,sVar3);
          }
          if (0x59 < Arabic) {
            sVar3 = 3;
            puVar2 = &DAT_0816d5ad;
            sVar1 = strlen(LYLowercaseI_OL_String::OLstring);
            memcpy(LYLowercaseI_OL_String::OLstring + sVar1,puVar2,sVar3);
            Arabic = Arabic + -0x5a;
          }
          if (0x31 < Arabic) {
            sVar3 = 2;
            puVar2 = &DAT_0816d5b0;
            sVar1 = strlen(LYLowercaseI_OL_String::OLstring);
            memcpy(LYLowercaseI_OL_String::OLstring + sVar1,puVar2,sVar3);
            for (Arabic = Arabic + -0x32; 0x31 < Arabic; Arabic = Arabic + -10) {
              sVar3 = 2;
              puVar2 = &DAT_0816d5b2;
              sVar1 = strlen(LYLowercaseI_OL_String::OLstring);
              memcpy(LYLowercaseI_OL_String::OLstring + sVar1,puVar2,sVar3);
            }
          }
          if (0x27 < Arabic) {
            sVar3 = 3;
            puVar2 = &DAT_0816d5b4;
            sVar1 = strlen(LYLowercaseI_OL_String::OLstring);
            memcpy(LYLowercaseI_OL_String::OLstring + sVar1,puVar2,sVar3);
            Arabic = Arabic + -0x28;
          }
          do {
            switch(Arabic) {
            case 0:
              goto switchD_080de485_caseD_0;
            case 1:
              sVar3 = 3;
              puVar2 = &DAT_0816d5b7;
              sVar1 = strlen(LYLowercaseI_OL_String::OLstring);
              memcpy(LYLowercaseI_OL_String::OLstring + sVar1,puVar2,sVar3);
              goto LAB_080de67a;
            case 2:
              sVar3 = 4;
              puVar2 = &DAT_0816d5ba;
              sVar1 = strlen(LYLowercaseI_OL_String::OLstring);
              memcpy(LYLowercaseI_OL_String::OLstring + sVar1,puVar2,sVar3);
              goto LAB_080de67a;
            case 3:
              sVar3 = 5;
              puVar2 = &DAT_0816d5be;
              sVar1 = strlen(LYLowercaseI_OL_String::OLstring);
              memcpy(LYLowercaseI_OL_String::OLstring + sVar1,puVar2,sVar3);
              goto LAB_080de67a;
            case 4:
              sVar3 = 4;
              puVar2 = &DAT_0816d5c3;
              sVar1 = strlen(LYLowercaseI_OL_String::OLstring);
              memcpy(LYLowercaseI_OL_String::OLstring + sVar1,puVar2,sVar3);
              goto LAB_080de67a;
            case 5:
              sVar3 = 3;
              puVar2 = &DAT_0816d5c7;
              sVar1 = strlen(LYLowercaseI_OL_String::OLstring);
              memcpy(LYLowercaseI_OL_String::OLstring + sVar1,puVar2,sVar3);
              goto LAB_080de67a;
            case 6:
              sVar3 = 4;
              puVar2 = &DAT_0816d5ca;
              sVar1 = strlen(LYLowercaseI_OL_String::OLstring);
              memcpy(LYLowercaseI_OL_String::OLstring + sVar1,puVar2,sVar3);
              goto LAB_080de67a;
            case 7:
              sVar3 = 5;
              puVar2 = &DAT_0816d5ce;
              sVar1 = strlen(LYLowercaseI_OL_String::OLstring);
              memcpy(LYLowercaseI_OL_String::OLstring + sVar1,puVar2,sVar3);
              goto LAB_080de67a;
            case 8:
              sVar3 = 6;
              __src = "viii.";
              sVar1 = strlen(LYLowercaseI_OL_String::OLstring);
              memcpy(LYLowercaseI_OL_String::OLstring + sVar1,__src,sVar3);
              goto LAB_080de67a;
            case 9:
              sVar3 = 4;
              puVar2 = &DAT_0816d5d9;
              sVar1 = strlen(LYLowercaseI_OL_String::OLstring);
              memcpy(LYLowercaseI_OL_String::OLstring + sVar1,puVar2,sVar3);
              goto LAB_080de67a;
            case 10:
              sVar3 = 3;
              puVar2 = &DAT_0816d5dd;
              sVar1 = strlen(LYLowercaseI_OL_String::OLstring);
              memcpy(LYLowercaseI_OL_String::OLstring + sVar1,puVar2,sVar3);
              goto LAB_080de67a;
            default:
              sVar3 = 2;
              puVar2 = &DAT_0816d5b2;
              sVar1 = strlen(LYLowercaseI_OL_String::OLstring);
              memcpy(LYLowercaseI_OL_String::OLstring + sVar1,puVar2,sVar3);
              Arabic = Arabic + -10;
            }
          } while( true );
        }
        memcpy(LYLowercaseI_OL_String::OLstring,&DAT_0816d585,4);
      }
    }
    else if (seqnum == 500) {
      memcpy(LYLowercaseI_OL_String::OLstring,&DAT_0816d599,4);
    }
    else if (seqnum == 1000) {
      memcpy(LYLowercaseI_OL_String::OLstring,&DAT_0816d59d,4);
    }
    else {
      if (seqnum != 100) goto LAB_080de212;
      memcpy(LYLowercaseI_OL_String::OLstring,&DAT_0816d595,4);
    }
  }
  else {
    memcpy(LYLowercaseI_OL_String::OLstring,&DAT_0816d580,5);
  }
  goto LAB_080de67a;
switchD_080de485_caseD_0:
  sVar3 = 2;
  puVar2 = &DAT_0816d54f;
  sVar1 = strlen(LYLowercaseI_OL_String::OLstring);
  memcpy(LYLowercaseI_OL_String::OLstring + sVar1,puVar2,sVar3);
LAB_080de67a:
  return LYLowercaseI_OL_String::OLstring;
}



// WARNING: Unknown calling convention

void LYZero_OL_Counter(HTStructured *me)

{
  int i;
  
  if (me != (HTStructured *)0x0) {
    for (i = 0; i < 0xc; i = i + 1) {
      me->OL_Counter[i] = OL_VOID;
      me->OL_Type[i] = '1';
    }
    me->Last_OL_Count = 0;
    me->Last_OL_Type = '1';
  }
  return;
}



// WARNING: Unknown calling convention

void LYGetChartransInfo(HTStructured *me)

{
  int iVar1;
  LYUCcharset *pLVar2;
  int chndl;
  
  iVar1 = HTAnchor_getUCLYhndl(me->node_anchor,2);
  me->UCLYhndl = iVar1;
  if (me->UCLYhndl < 0) {
    chndl = HTAnchor_getUCLYhndl(me->node_anchor,3);
    if (chndl < 0) {
      chndl = current_char_set;
      HTAnchor_setUCInfoStage(me->node_anchor,current_char_set,3,3);
    }
    HTAnchor_setUCInfoStage(me->node_anchor,chndl,2,3);
    iVar1 = HTAnchor_getUCLYhndl(me->node_anchor,2);
    me->UCLYhndl = iVar1;
  }
  pLVar2 = HTAnchor_getUCInfoStage(me->node_anchor,2);
  me->UCI = pLVar2;
  return;
}



char * UCPutUtf8ToBuffer(char *q,UCode_t code,BOOLEAN terminate)

{
  byte bVar1;
  byte bVar2;
  byte bVar3;
  byte bVar4;
  byte bVar5;
  char *local_1c;
  BOOLEAN terminate_local;
  char *q_in;
  
  local_1c = q;
  if (q == (char *)0x0) {
    local_1c = (char *)0x0;
  }
  else if ((code < 0x80) || (code == 0x7fffffff)) {
    local_1c = (char *)0x0;
  }
  else {
    bVar1 = (byte)(code >> 6);
    bVar5 = (byte)code;
    if (code < 0x800) {
      *q = bVar1 | 0xc0;
      q[1] = bVar5 & 0x3f | 0x80;
      q = q + 2;
    }
    else {
      bVar2 = (byte)(code >> 0xc);
      if (code < 0x10000) {
        *q = bVar2 | 0xe0;
        q[1] = bVar1 & 0x3f | 0x80;
        q[2] = bVar5 & 0x3f | 0x80;
        q = q + 3;
      }
      else {
        bVar3 = (byte)(code >> 0x12);
        if (code < 0x200000) {
          *q = bVar3 | 0xf0;
          q[1] = bVar2 & 0x3f | 0x80;
          q[2] = bVar1 & 0x3f | 0x80;
          q[3] = bVar5 & 0x3f | 0x80;
          q = q + 4;
        }
        else {
          bVar4 = (byte)((uint)code >> 0x18);
          if (code < 0x4000000) {
            *q = bVar4 | 0xf8;
            q[1] = bVar3 & 0x3f | 0x80;
            q[2] = bVar2 & 0x3f | 0x80;
            q[3] = bVar1 & 0x3f | 0x80;
            q[4] = bVar5 & 0x3f | 0x80;
            q = q + 5;
          }
          else {
            *q = (char)bVar4 >> 6 | 0xfc;
            q[1] = bVar4 & 0x3f | 0x80;
            q[2] = bVar3 & 0x3f | 0x80;
            q[3] = bVar2 & 0x3f | 0x80;
            q[4] = bVar1 & 0x3f | 0x80;
            q[5] = bVar5 & 0x3f | 0x80;
            q = q + 6;
          }
        }
      }
    }
    if (terminate == '\0') {
      local_1c = q;
    }
    else {
      *q = '\0';
    }
  }
  return local_1c;
}



char ** LYUCFullyTranslateString
                  (char **str,int cs_from,int cs_to,BOOLEAN do_ent,BOOLEAN use_lynx_specials,
                  BOOLEAN plain_space,BOOLEAN hidden,BOOLEAN Back,CharUtil_st stype)

{
  int iVar1;
  ushort uVar2;
  BOOLEAN BVar3;
  int iVar4;
  char *pcVar5;
  size_t sVar6;
  byte *__s;
  uint uVar7;
  FILE *__stream;
  ushort **ppuVar8;
  int in_GS_OFFSET;
  char **local_12c;
  BOOLEAN local_128;
  BOOLEAN local_124;
  _state local_114;
  UCode_t local_104;
  char *local_100;
  char *local_e4;
  BOOLEAN Back_local;
  BOOLEAN hidden_local;
  BOOLEAN plain_space_local;
  BOOLEAN use_lynx_specials_local;
  BOOLEAN do_ent_local;
  char **str_local;
  UCTransParams T;
  char *pp;
  int rev_c;
  _parsing_what what;
  _state state;
  char *puni;
  char *name;
  size_t len;
  ulong lcode;
  UCode_t code;
  int lowest_8;
  int uck;
  char *esc;
  char *cp;
  HTChunk *chunk;
  char *qs;
  char *q;
  char *p;
  BOOLEAN from_is_utf8;
  BOOLEAN no_bytetrans;
  BOOLEAN repl_translated_C0;
  BOOLEAN output_utf8;
  char cpe;
  char replace_buf [64];
  
  do_ent_local = do_ent;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  chunk = (HTChunk *)0x0;
  cp = (char *)0x0;
  cpe = '\0';
  esc = (char *)0x0;
  code = 0;
  output_utf8 = '\0';
  repl_translated_C0 = '\0';
  name = (char *)0x0;
  from_is_utf8 = '\0';
  state = S_text;
  what = P_text;
  if (((str == (char **)0x0) || (*str == (char *)0x0)) || (**str == '\0')) {
    local_12c = str;
  }
  else {
    memset(replace_buf,0,0x40);
    if (((HTCJK == NOCJK) || (iVar4 = strcmp(LYCharSet_UC[cs_from].MIMEname,"utf-8"), iVar4 == 0))
       || (iVar4 = strcmp(LYCharSet_UC[cs_to].MIMEname,"utf-8"), iVar4 == 0)) {
      if (((cs_to < 1) && (cs_from == cs_to)) && ((Back == '\0' || (cs_to < 0)))) {
        no_bytetrans = '\x01';
      }
      else {
        if (((use_lynx_specials == '\0') && (Back == '\0')) &&
           (BVar3 = UCNeedNotTranslate(cs_from,cs_to), BVar3 != '\0')) {
          local_128 = '\x01';
        }
        else {
          local_128 = '\0';
        }
        no_bytetrans = local_128;
      }
    }
    else {
      no_bytetrans = '\x01';
    }
    if (((do_ent != '\0') && (hidden != '\0')) &&
       ((stype != st_URL && (pcVar5 = strchr(*str,0x26), pcVar5 == (char *)0x0)))) {
      do_ent_local = '\0';
    }
    BVar3 = UCCanTranslateFromTo(cs_from,cs_to);
    if (BVar3 == '\0') {
      if (cs_to < 0) {
        local_12c = (char **)0x0;
        goto LAB_080e06f3;
      }
      if ((do_ent_local == '\0') && (no_bytetrans != '\0')) {
        local_12c = (char **)0x0;
        goto LAB_080e06f3;
      }
      no_bytetrans = '\x01';
    }
    else if (cs_to < 0) {
      do_ent_local = '\0';
    }
    if ((do_ent_local != '\0') || (no_bytetrans == '\0')) {
      p = *str;
      if (no_bytetrans == '\0') {
        UCTransParams_clear(&T);
        UCSetTransParams(&T,cs_from,LYCharSet_UC + cs_from,cs_to,LYCharSet_UC + cs_to);
        from_is_utf8 = LYCharSet_UC[cs_from].enc == 7;
        output_utf8 = T.output_utf8;
        repl_translated_C0 = T.repl_translated_C0;
        puni = p;
      }
      else if (do_ent_local != '\0') {
        if ((LYCharSet_UC[cs_to].enc == 7) ||
           (BVar3 = HText_hasUTF8OutputSet(HTMainText), BVar3 != '\0')) {
          local_124 = '\x01';
        }
        else {
          local_124 = '\0';
        }
        output_utf8 = local_124;
        repl_translated_C0 = LYCharSet_UC[cs_to].enc == 3;
      }
      lowest_8 = LYlowest_eightbit[cs_to];
      sVar6 = strlen(p);
      len = sVar6 + 0x10;
      q = p;
      qs = p;
      do {
        pcVar5 = p;
        if ((*p == '\0') && ((state == S_text || (state == S_nonascii_text)))) goto LAB_080e0602;
        switch(state) {
        case S_text:
          code = (UCode_t)(byte)*p;
          if (*p == '\x1b') {
            if (((HTCJK == NOCJK) || (hidden != '\0')) && (stype == st_HTML)) {
              if (hidden == '\0') {
                state = S_next_char;
              }
              else {
                state = S_trans_byte;
              }
            }
            else {
              state = S_esc;
              if (stype == st_URL) {
                if (q != qs) {
                  iVar4 = (int)q - (int)qs;
                  if (chunk == (HTChunk *)0x0) {
                    chunk = HTChunkCreate2(0x80,len + 1);
                  }
                  HTChunkPutb(chunk,qs,iVar4);
                }
                if (chunk == (HTChunk *)0x0) {
                  chunk = HTChunkCreate2(0x80,len + 1);
                }
                HTChunkPuts(chunk,"%1B");
                qs = *str;
                p = p + 1;
                q = qs;
              }
              else if (stype == st_HTML) {
                *q = *p;
                q = q + 1;
                p = p + 1;
              }
              else {
                p = p + 1;
              }
            }
          }
          else {
            if (do_ent_local == '\0') {
              local_114 = S_trans_byte;
            }
            else {
              local_114 = S_check_ent;
            }
            state = local_114;
          }
          break;
        case S_esc:
          if (*p == '$') {
            state = S_dollar;
            *q = *p;
            q = q + 1;
            p = p + 1;
          }
          else if (*p == '(') {
            state = S_paren;
            *q = *p;
            q = q + 1;
            p = p + 1;
          }
          else {
            state = S_text;
          }
          break;
        case S_dollar:
          if (((*p == '@') || (*p == 'B')) || (*p == 'A')) {
            state = S_nonascii_text;
            *q = *p;
            q = q + 1;
            p = p + 1;
          }
          else if (*p == '(') {
            state = S_dollar_paren;
            *q = *p;
            q = q + 1;
            p = p + 1;
          }
          else {
            state = S_text;
          }
          break;
        case S_paren:
          if (((*p == 'B') || (*p == 'J')) || (*p == 'T')) {
            state = S_text;
            *q = *p;
            q = q + 1;
            p = p + 1;
          }
          else if (*p == 'I') {
            state = S_nonascii_text;
            *q = *p;
            q = q + 1;
            p = p + 1;
          }
          else {
            state = S_text;
          }
          break;
        case S_nonascii_text:
          if ((*p == '\x1b') && (((HTCJK != NOCJK && (hidden == '\0')) || (stype != st_HTML)))) {
            state = S_esc;
            if (stype == st_URL) {
              if (q != qs) {
                iVar4 = (int)q - (int)qs;
                if (chunk == (HTChunk *)0x0) {
                  chunk = HTChunkCreate2(0x80,len + 1);
                }
                HTChunkPutb(chunk,qs,iVar4);
              }
              if (chunk == (HTChunk *)0x0) {
                chunk = HTChunkCreate2(0x80,len + 1);
              }
              HTChunkPuts(chunk,"%1B");
              qs = *str;
              p = p + 1;
              q = qs;
              break;
            }
            if (stype != st_HTML) {
              p = p + 1;
              break;
            }
          }
          *q = *p;
          q = q + 1;
          p = p + 1;
          break;
        case S_dollar_paren:
          if (*p == 'C') {
            state = S_nonascii_text;
            *q = *p;
            q = q + 1;
            p = p + 1;
          }
          else {
            state = S_text;
          }
          break;
        case S_trans_byte:
          if ((*p == '\0') || (no_bytetrans != '\0')) {
            state = S_got_outchar;
            break;
          }
          if (Back == '\0') {
            if (code < 0x7f) {
              state = S_got_outchar;
              break;
            }
          }
          else {
            if ((*p == '\x01') || (*p == '\x02')) {
              if (plain_space != '\0') {
                *p = ' ';
                code = 0x20;
                state = S_got_outchar;
                break;
              }
              code = 0xa0;
              if ((LYCharSet_UC[cs_to].enc == 2) || ((LYCharSet_UC[cs_to].like8859 & 0x80U) != 0)) {
                state = S_got_outchar;
                break;
              }
              if ((LYCharSet_UC[cs_from].enc != 2) &&
                 ((LYCharSet_UC[cs_from].like8859 & 0x80U) == 0)) {
                state = S_check_uni;
                break;
              }
              *p = -0x60;
            }
            else if (*p == '\a') {
              code = 0xad;
              if ((LYCharSet_UC[cs_to].enc == 2) || ((LYCharSet_UC[cs_to].like8859 & 0x80U) != 0)) {
                state = S_got_outchar;
                break;
              }
              if ((LYCharSet_UC[cs_from].enc != 2) &&
                 ((LYCharSet_UC[cs_from].like8859 & 0x80U) == 0)) {
                state = S_check_uni;
                break;
              }
              *p = -0x53;
            }
            else if (output_utf8 == '\0') {
              if ((code < 0x7f) || (T.transp != '\0')) {
                state = S_got_outchar;
                break;
              }
            }
            else {
              iVar4 = strcmp(LYCharSet_UC[cs_from].MIMEname,"euc-jp");
              if (((iVar4 == 0) &&
                  (((((0xa0 < (byte)*p && (*p != -1)) && (0xa0 < (byte)p[1])) && (p[1] != -1)) ||
                   (((*p == -0x72 && (0xa0 < (byte)p[1])) && ((byte)p[1] < 0xe0)))))) ||
                 ((((iVar4 = strcmp(LYCharSet_UC[cs_from].MIMEname,"shift_jis"), iVar4 == 0 &&
                    (0x3f < (byte)p[1])) && ((p[1] != '\x7f' && ((byte)p[1] < 0xfd)))) &&
                  (((0x80 < (byte)*p && ((byte)*p < 0xa0)) ||
                   ((0xdf < (byte)*p && ((byte)*p < 0xf0)))))))) {
                code = UCTransJPToUni(p,2,cs_from);
                p = p + 1;
                state = S_check_uni;
                break;
              }
            }
            iVar4 = UCReverseTransChar(*p,cs_to,cs_from);
            if (0x7f < iVar4) {
              *p = (char)iVar4;
              state = S_got_outchar;
              code = iVar4;
              break;
            }
          }
          if (from_is_utf8 == '\0') {
            if ((((use_lynx_specials != '\0') && (Back == '\0')) &&
                ((code == 0xa0 || (code == 0xad)))) &&
               ((LYCharSet_UC[cs_from].enc == 2 || ((LYCharSet_UC[cs_from].like8859 & 0x80U) != 0)))
               ) {
              if (code == 0xa0) {
                *p = '\x01';
                code = 1;
              }
              else if (code == 0xad) {
                *p = '\a';
                code = 7;
              }
              state = S_got_outchar;
              break;
            }
            if (T.trans_to_uni == '\0') {
              if (T.trans_from_uni == '\0') {
                state = S_got_outchar;
                break;
              }
            }
            else {
              code = UCTransToUni(*p,cs_from);
              if (code < 1) {
                code = (UCode_t)(byte)*p;
              }
            }
          }
          else if (((int)*p & 0xc0U) == 0xc0) {
            puni = p;
            code = UCGetUniFromUtf8String(&puni);
            if (code < 1) {
              code = (UCode_t)(byte)*p;
            }
            else {
              what = P_utf8;
            }
          }
          if (((use_lynx_specials == '\0') || (Back != '\0')) || ((code != 0xa0 && (code != 0xad))))
          {
            state = S_check_uni;
          }
          else {
            if (code == 0xa0) {
              local_104 = 1;
            }
            else {
              local_104 = 7;
            }
            code = local_104;
            state = S_got_outchar;
          }
          break;
        case S_check_ent:
          if (*p == '&') {
            __s = (byte *)(p + 1);
            len = strlen((char *)__s);
            if ((((*__s == 0x23) && (2 < len)) && ((pcVar5[2] == 'x' || (pcVar5[2] == 'X')))) &&
               (((byte)pcVar5[3] < 0x7f &&
                (ppuVar8 = __ctype_b_loc(), ((*ppuVar8)[(byte)pcVar5[3]] & 0x1000) != 0)))) {
              what = P_hex;
              state = S_ncr;
            }
            else if ((*__s == 0x23) &&
                    (((2 < len && ((byte)pcVar5[2] < 0x7f)) &&
                     (ppuVar8 = __ctype_b_loc(), ((*ppuVar8)[(byte)pcVar5[2]] & 0x800) != 0)))) {
              what = P_decimal;
              state = S_ncr;
            }
            else if ((*__s < 0x7f) && (ppuVar8 = __ctype_b_loc(), ((*ppuVar8)[*__s] & 0x400) != 0))
            {
              what = P_named;
              state = S_named;
            }
            else {
              state = S_trans_byte;
            }
          }
          else {
            state = S_trans_byte;
          }
          break;
        case S_ncr:
          if (what == P_hex) {
            p = p + 3;
          }
          else {
            p = p + 2;
          }
          cp = p;
          for (; (*p != '\0' && ((byte)*p < 0x7f)); p = p + 1) {
            if (what == P_hex) {
              ppuVar8 = __ctype_b_loc();
              uVar2 = (*ppuVar8)[(byte)*p] & 0x1000;
            }
            else {
              ppuVar8 = __ctype_b_loc();
              uVar2 = (*ppuVar8)[(byte)*p] & 0x800;
            }
            if (uVar2 == 0) break;
          }
          cpe = *p;
          if (*p != '\0') {
            *p = '\0';
            p = p + 1;
          }
          if (what == P_hex) {
            iVar4 = sscanf(cp,"%lx",&lcode);
          }
          else {
            iVar4 = sscanf(cp,"%lu",&lcode);
          }
          if ((iVar4 == 1) && (-1 < (int)lcode)) {
            code = lcode;
            if ((lcode == 1) || ((0x7f < (int)lcode && ((int)lcode < 0x9c)))) {
              switch(lcode) {
              case 1:
                code = 0x263a;
                break;
              case 0x80:
                code = 0x20ac;
                break;
              case 0x82:
                code = 0x201a;
                break;
              case 0x84:
                code = 0x201e;
                break;
              case 0x85:
                code = 0x2026;
                break;
              case 0x86:
                code = 0x2020;
                break;
              case 0x87:
                code = 0x2021;
                break;
              case 0x89:
                code = 0x2030;
                break;
              case 0x8b:
                code = 0x2039;
                break;
              case 0x91:
                code = 0x2018;
                break;
              case 0x92:
                code = 0x2019;
                break;
              case 0x93:
                code = 0x201c;
                break;
              case 0x94:
                code = 0x201d;
                break;
              case 0x95:
                code = 0x2022;
                break;
              case 0x96:
                code = 0x2013;
                break;
              case 0x97:
                code = 0x2014;
                break;
              case 0x98:
                code = 0x2dc;
                break;
              case 0x99:
                code = 0x2122;
                break;
              case 0x9b:
                code = 0x203a;
              }
            }
            state = S_check_uni;
          }
          else {
            state = S_recover;
          }
          break;
        case S_check_uni:
          if (((((code < 0x20) && (code != 9)) &&
               ((code != 10 && ((code != 0xd && (HTCJK == NOCJK)))))) ||
              ((code == 0x7f && ((HTPassHighCtrlRaw == '\0' && (HTCJK == NOCJK)))))) ||
             ((0x7f < code && ((code < 0xa0 && (HTPassHighCtrlNum == '\0')))))) {
            state = S_recover;
            break;
          }
          if ((0x9f < code) && (stype == st_URL)) {
            state = S_got_oututf8;
            break;
          }
          if (code == 0xa0) {
            if (plain_space != '\0') {
              code = 0x20;
              state = S_got_outchar;
              break;
            }
            if (use_lynx_specials != '\0') {
              code = 1;
              state = S_got_outchar;
              break;
            }
            if ((((hidden != '\0') && (Back == '\0')) ||
                ((LYCharSet_UC[cs_to].codepoints & 2U) != 0)) ||
               ((LYCharSet_UC[cs_to].enc == 2 || ((LYCharSet_UC[cs_to].like8859 & 0x80U) != 0)))) {
              state = S_got_outchar;
              break;
            }
            if ((LYCharSet_UC[cs_to].repertoire & 2U) == 0) {
              code = 0x20;
              state = S_got_outchar;
              break;
            }
          }
          if (code == 0xad) {
            if (plain_space != '\0') {
              replace_buf[0] = '\0';
              state = S_got_outstring;
              break;
            }
            if (((Back == '\0') || (LYCharSet_UC[cs_to].enc == 2)) ||
               ((LYCharSet_UC[cs_to].like8859 & 0x80U) != 0)) {
              if ((hidden != '\0') || (Back != '\0')) {
                state = S_got_outchar;
                break;
              }
              if (use_lynx_specials != '\0') {
                code = 7;
                state = S_got_outchar;
                break;
              }
            }
          }
          uck = UCTransUniChar(code,cs_to);
          if (((0x1f < uck) && (uck < 0x100)) && ((uck < 0x7f || (lowest_8 <= uck)))) {
            state = S_got_outchar;
            code = uck;
            break;
          }
          if ((uck == -4) || (((repl_translated_C0 != '\0' && (0 < uck)) && (uck < 0x20)))) {
            uVar7 = UCTransUniCharStr(replace_buf,0x3c,code,cs_to,0);
            uck = -((int)~uVar7 >> 0x1f);
            if (uck != 0) {
              state = S_got_outstring;
              break;
            }
          }
          if (((output_utf8 != '\0') && (0x7f < code)) && (code != 0x7fffffff)) {
            state = S_got_oututf8;
            break;
          }
          if (((code == 0x2002) || (code == 0x2003)) || (code == 0x2009)) {
            if (hidden == '\0') {
              if (plain_space == '\0') {
                code = 2;
                state = S_got_outchar;
              }
              else {
                code = 0x20;
                state = S_got_outchar;
              }
            }
            else {
              state = S_recover;
            }
            break;
          }
          if ((((code == 0x200c) || (code == 0x200d)) || (code == 0x200e)) || (code == 0x200f)) {
            if (WWW_TraceFlag != '\0') {
              __stream = TraceFP();
              fprintf((FILE *)__stream,"LYUCFullyTranslateString: Ignoring \'%ld\'.\n",code);
            }
            replace_buf[0] = '\0';
            state = S_got_outstring;
            break;
          }
          if (0xff < code) {
            state = S_recover;
            break;
          }
          if ((code < 0xa1) ||
             ((code < 0x100 && ((HTPassEightBitNum != '\0' || (cs_to == LATIN1)))))) {
            state = S_got_outchar;
            break;
          }
        case S_recover:
          if ((what == P_decimal) || (what == P_hex)) {
            *q = '&';
            q[1] = '#';
            pcVar5 = q + 2;
            if (what == P_hex) {
              q[2] = 'x';
              pcVar5 = q + 3;
            }
            q = pcVar5;
            if (cpe != '\0') {
              p[-1] = cpe;
            }
            p = cp;
            state = S_done;
          }
          else if (what == P_named) {
            *cp = cpe;
            *q = '&';
            q = q + 1;
            state = S_done;
          }
          else if ((((T.output_utf8 == '\0') && (stype == st_HTML)) && (hidden == '\0')) &&
                  ((HTPassEightBitRaw == '\0' || ((int)(uint)(byte)*p < lowest_8)))) {
            sprintf(replace_buf,"U%.2lX",code);
            state = S_got_outstring;
          }
          else {
            puni = p;
            state = S_got_outchar;
            code = (uint)(byte)*p;
          }
          break;
        case S_named:
          cp = p + 1;
          p = cp;
          while (((*cp != '\0' && ((byte)*cp < 0x7f)) &&
                 (ppuVar8 = __ctype_b_loc(), ((*ppuVar8)[(byte)*cp] & 8) != 0))) {
            cp = cp + 1;
          }
          cpe = *cp;
          *cp = '\0';
          name = p;
          state = S_check_name;
          break;
        case S_check_name:
          code = HTMLGetEntityUCValue(name);
          if ((code < 1) || ((cpe == '=' && (stype == st_URL)))) {
            state = S_recover;
          }
          else {
            state = S_check_uni;
          }
          break;
        case S_got_oututf8:
          if ((code < 0x100) && ((code < 0x80 || (LYCharSet_UC[cs_to].enc != 7)))) {
            state = S_got_outchar;
          }
          else {
            UCPutUtf8ToBuffer(replace_buf,code,'\x01');
            state = S_got_outstring;
          }
          break;
        case S_got_outstring:
          if ((what == P_decimal) || (what == P_hex)) {
            if ((cpe != ';') && (cpe != '\0')) {
              p = p + -1;
              *p = cpe;
            }
            p = p + -1;
          }
          else if (what == P_named) {
            *cp = cpe;
            if (*cp == ';') {
              local_100 = cp;
            }
            else {
              local_100 = cp + -1;
            }
            p = local_100;
          }
          else if (what == P_utf8) {
            p = puni;
          }
          if (replace_buf[0] == '\0') {
            state = S_next_char;
          }
          else if ((stype == st_URL) &&
                  ((code = (UCode_t)replace_buf[0], 0x7e < code ||
                   ((((code < 0x20 && (code != 9)) && (code != 10)) && (code != 0)))))) {
            state = S_put_urlstring;
          }
          else {
            if (q != qs) {
              iVar4 = (int)q - (int)qs;
              if (chunk == (HTChunk *)0x0) {
                chunk = HTChunkCreate2(0x80,len + 1);
              }
              HTChunkPutb(chunk,qs,iVar4);
            }
            if (chunk == (HTChunk *)0x0) {
              chunk = HTChunkCreate2(0x80,len + 1);
            }
            HTChunkPuts(chunk,replace_buf);
            qs = *str;
            state = S_next_char;
            q = qs;
          }
          break;
        case S_put_urlstring:
          esc = HTEscape(replace_buf,'\x01');
          if (q != qs) {
            iVar4 = (int)q - (int)qs;
            if (chunk == (HTChunk *)0x0) {
              chunk = HTChunkCreate2(0x80,len + 1);
            }
            HTChunkPutb(chunk,qs,iVar4);
          }
          if (chunk == (HTChunk *)0x0) {
            chunk = HTChunkCreate2(0x80,len + 1);
          }
          HTChunkPuts(chunk,esc);
          qs = *str;
          q = qs;
          if (esc != (char *)0x0) {
            free(esc);
            esc = (char *)0x0;
          }
          state = S_next_char;
          break;
        case S_got_outchar:
          if ((what == P_decimal) || (what == P_hex)) {
            if ((cpe != ';') && (cpe != '\0')) {
              p = p + -1;
              *p = cpe;
            }
            p = p + -1;
          }
          else if (what == P_named) {
            *cp = cpe;
            if (*cp == ';') {
              local_e4 = cp;
            }
            else {
              local_e4 = cp + -1;
            }
            p = local_e4;
          }
          else if (what == P_utf8) {
            p = puni;
          }
          if ((stype == st_URL) &&
             ((0x7e < code || (((code < 0x20 && (code != 9)) && (code != 10)))))) {
            state = S_put_urlchar;
          }
          else if ((((hidden == '\0') && (code == 10)) && (*p == '\n')) &&
                  ((q != qs && (q[-1] == '\r')))) {
            q[-1] = *p;
            p = p + 1;
            state = S_done;
          }
          else {
            *q = (char)code;
            q = q + 1;
            state = S_next_char;
          }
          break;
        case S_put_urlchar:
          *q = '%';
          pcVar5 = q + 1;
          if (p < pcVar5) {
            iVar4 = (int)pcVar5 - (int)qs;
            q = pcVar5;
            if (chunk == (HTChunk *)0x0) {
              chunk = HTChunkCreate2(0x80,len + 1);
            }
            HTChunkPutb(chunk,qs,iVar4);
            qs = *str;
            *qs = hex[code >> 4 & 0xf];
            q = qs + 1;
          }
          else {
            *pcVar5 = hex[code >> 4 & 0xf];
            q = q + 2;
          }
          if (p < q) {
            iVar4 = (int)q - (int)qs;
            if (chunk == (HTChunk *)0x0) {
              chunk = HTChunkCreate2(0x80,len + 1);
            }
            HTChunkPutb(chunk,qs,iVar4);
            qs = *str;
            *qs = hex[code & 0xf];
            q = qs + 1;
          }
          else {
            *q = hex[code & 0xf];
            q = q + 1;
          }
        case S_next_char:
          p = p + 1;
switchD_080dedaa_caseD_13:
          state = S_text;
          what = P_text;
          break;
        case S_done:
          goto switchD_080dedaa_caseD_13;
        }
      } while( true );
    }
    local_12c = str;
  }
  goto LAB_080e06f3;
LAB_080e0602:
  *q = '\0';
  if (chunk == (HTChunk *)0x0) {
    if ((stype == st_URL) || (stype == st_other)) {
      LYTrimHead(qs);
      LYTrimTail(qs);
    }
  }
  else {
    pcVar5 = q + (1 - (int)qs);
    if (chunk == (HTChunk *)0x0) {
      chunk = HTChunkCreate2(0x80,len + 1);
    }
    HTChunkPutb(chunk,qs,(int)pcVar5);
    if ((stype == st_URL) || (stype == st_other)) {
      LYTrimHead(chunk->data);
      LYTrimTail(chunk->data);
    }
    HTSACopy(str,chunk->data);
    HTChunkFree(chunk);
  }
  local_12c = str;
LAB_080e06f3:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return local_12c;
}



BOOLEAN LYUCTranslateHTMLString
                  (char **str,int cs_from,int cs_to,BOOLEAN use_lynx_specials,BOOLEAN plain_space,
                  BOOLEAN hidden,CharUtil_st stype)

{
  char **ppcVar1;
  BOOLEAN hidden_local;
  BOOLEAN plain_space_local;
  BOOLEAN use_lynx_specials_local;
  BOOLEAN ret;
  
  ppcVar1 = LYUCFullyTranslateString
                      (str,cs_from,cs_to,'\x01',use_lynx_specials,plain_space,hidden,'\0',stype);
  return ppcVar1 != (char **)0x0;
}



BOOLEAN LYUCTranslateBackFormData(char **str,int cs_from,int cs_to,BOOLEAN plain_space)

{
  char **ppcVar1;
  BOOLEAN plain_space_local;
  char **ret;
  
  ppcVar1 = LYUCFullyTranslateString(str,cs_from,cs_to,'\0','\0',plain_space,'\x01','\x01',st_HTML);
  return ppcVar1 != (char **)0x0;
}



// WARNING: Unknown calling convention

char * LYParseTagParam(char *from,char *name)

{
  ushort **ppuVar1;
  size_t sVar2;
  int iVar3;
  char *string;
  char *result;
  size_t len;
  
  len = strlen(name);
  result = (char *)0x0;
  string = from;
  while( true ) {
    string = strchr(string,0x3b);
    if (string == (char *)0x0) {
      return (char *)0x0;
    }
    while ((*string != '\0' &&
           ((*string == ';' ||
            (ppuVar1 = __ctype_b_loc(), ((*ppuVar1)[(byte)*string] & 0x2000) != 0))))) {
      string = string + 1;
    }
    sVar2 = strlen(string);
    if (sVar2 < len) break;
    iVar3 = strncasecomp(string,name,len);
    if (iVar3 == 0) {
      for (string = string + len;
          (*string != '\0' &&
          ((ppuVar1 = __ctype_b_loc(), ((*ppuVar1)[(byte)*string] & 0x2000) != 0 || (*string == '=')
           ))); string = string + 1) {
      }
      HTSACopy(&result,string);
      len = 0;
      while ((ppuVar1 = __ctype_b_loc(), ((*ppuVar1)[(byte)string[len]] & 0x4000) != 0 &&
             (ppuVar1 = __ctype_b_loc(), ((*ppuVar1)[(byte)string[len]] & 0x2000) == 0))) {
        len = len + 1;
      }
      result[len] = '\0';
      if ((2 < len) && ((*result == '\'' && (result[len - 1] == *result)))) {
        result[len - 1] = '\0';
        for (string = result; *string = string[1], *string != '\0'; string = string + 1) {
        }
      }
      return result;
    }
  }
  return (char *)0x0;
}



// WARNING: Unknown calling convention

void LYParseRefreshURL(char *content,char **p_seconds,char **p_address)

{
  ushort **ppuVar1;
  char *pcVar2;
  FILE *__stream;
  char *local_1c;
  char *local_18;
  char *Seconds;
  char *cp1;
  char *cp;
  
  cp1 = (char *)0x0;
  Seconds = (char *)0x0;
  cp = LYSkipBlanks(content);
  if (*cp != '\0') {
    ppuVar1 = __ctype_b_loc();
    if (((*ppuVar1)[(byte)*cp] & 0x800) != 0) {
      for (cp1 = cp; *cp1 != '\0'; cp1 = cp1 + 1) {
        ppuVar1 = __ctype_b_loc();
        if (((*ppuVar1)[(byte)*cp1] & 0x800) == 0) break;
      }
      SNACopy(&Seconds,cp,(int)cp1 - (int)cp);
    }
  }
  *p_seconds = Seconds;
  pcVar2 = LYParseTagParam(content,"URL");
  *p_address = pcVar2;
  if (WWW_TraceFlag != '\0') {
    if (*p_address == (char *)0x0) {
      local_1c = "";
    }
    else {
      local_1c = *p_address;
    }
    if (*p_seconds == (char *)0x0) {
      local_18 = "";
    }
    else {
      local_18 = *p_seconds;
    }
    __stream = TraceFP();
    fprintf((FILE *)__stream,"LYParseRefreshURL\n\tcontent: %s\n\tseconds: %s\n\taddress: %s\n",
            content,local_18,local_1c);
  }
  return;
}



// WARNING: Unknown calling convention

void LYHandleMETA(HTStructured *me,BOOLEAN *present,char **value,char **include)

{
  BOOLEAN BVar1;
  FILE *pFVar2;
  int iVar3;
  ushort **ppuVar4;
  char *pcVar5;
  time_t tVar6;
  time_t tVar7;
  LYUCcharset *pLVar8;
  HTChildAnchor *pHVar9;
  char *local_94;
  char *local_90;
  char *local_8c;
  char *local_88;
  char *local_84;
  char *local_80;
  char *local_7c;
  char *local_78;
  char local_74;
  char local_70;
  BOOLEAN local_6c;
  char *local_68;
  char *local_64;
  char *local_60;
  char *local_5c;
  char *local_58;
  char *local_54;
  char *local_50;
  char *cp3;
  int chndl;
  char *cp4;
  LYUCcharset *p_out;
  LYUCcharset *p_in;
  int url_type;
  char *cp1;
  char *cp0;
  char *cp;
  char *temp;
  char *id_string;
  char *href;
  char *content;
  char *name;
  char *http_equiv;
  BOOLEAN given_and_display_8859like;
  BOOLEAN given_is_8859like;
  BOOLEAN given_is_8859;
  BOOLEAN chartrans_ok;
  
  http_equiv = (char *)0x0;
  name = (char *)0x0;
  content = (char *)0x0;
  href = (char *)0x0;
  id_string = (char *)0x0;
  temp = (char *)0x0;
  cp1 = (char *)0x0;
  url_type = 0;
  if (me == (HTStructured *)0x0) {
    return;
  }
  if (present == (BOOLEAN *)0x0) {
    return;
  }
  if (((present[1] != '\0') && (value[1] != (char *)0x0)) && (*value[1] != '\0')) {
    HTSACopy(&http_equiv,value[1]);
    convert_to_spaces(http_equiv,'\x01');
    LYUCTranslateHTMLString(&http_equiv,me->tag_charset,me->tag_charset,'\0','\0','\x01',st_other);
    if ((*http_equiv == '\0') && (http_equiv != (char *)0x0)) {
      free(http_equiv);
      http_equiv = (char *)0x0;
    }
  }
  if (((present[2] != '\0') && (value[2] != (char *)0x0)) && (*value[2] != '\0')) {
    HTSACopy(&name,value[2]);
    convert_to_spaces(name,'\x01');
    LYUCTranslateHTMLString(&name,me->tag_charset,me->tag_charset,'\0','\0','\x01',st_other);
    if ((*name == '\0') && (name != (char *)0x0)) {
      free(name);
      name = (char *)0x0;
    }
  }
  if (((*present != '\0') && (*value != (char *)0x0)) && (**value != '\0')) {
    HTSACopy(&content,*value);
    convert_to_spaces(content,'\0');
    LYTrimHead(content);
    LYTrimTail(content);
    if ((*content == '\0') && (content != (char *)0x0)) {
      free(content);
      content = (char *)0x0;
    }
  }
  if (WWW_TraceFlag != '\0') {
    if (content == (char *)0x0) {
      local_94 = "NULL";
    }
    else {
      local_94 = content;
    }
    if (name == (char *)0x0) {
      local_90 = "NULL";
    }
    else {
      local_90 = name;
    }
    if (http_equiv == (char *)0x0) {
      local_8c = "NULL";
    }
    else {
      local_8c = http_equiv;
    }
    pFVar2 = TraceFP();
    fprintf((FILE *)pFVar2,"LYHandleMETA: HTTP-EQUIV=\"%s\" NAME=\"%s\" CONTENT=\"%s\"\n",local_8c,
            local_90,local_94);
  }
  if (((http_equiv == (char *)0x0) && (name == (char *)0x0)) || (content == (char *)0x0))
  goto free_META_copies;
  if (http_equiv == (char *)0x0) {
    local_88 = "";
  }
  else {
    local_88 = http_equiv;
  }
  iVar3 = strcasecomp(local_88,"Pragma");
  if (iVar3 != 0) {
    if (http_equiv == (char *)0x0) {
      local_84 = "";
    }
    else {
      local_84 = http_equiv;
    }
    iVar3 = strcasecomp(local_84,"Cache-Control");
    if (iVar3 != 0) {
      if (http_equiv == (char *)0x0) {
        local_7c = "";
      }
      else {
        local_7c = http_equiv;
      }
      iVar3 = strcasecomp(local_7c,"Expires");
      if (iVar3 == 0) {
        LYUCTranslateHTMLString(&content,me->tag_charset,me->tag_charset,'\0','\0','\x01',st_other);
        HTSACopy(&me->node_anchor->expires,content);
        if (me->node_anchor->no_cache == '\0') {
          iVar3 = strcmp(content,"0");
          if (iVar3 == 0) {
            me->node_anchor->no_cache = '\x01';
            HText_setNoCache(me->text);
          }
          else if (me->node_anchor->date == (char *)0x0) {
            tVar6 = LYmktime(content,'\0');
            if (tVar6 == 0) {
              me->node_anchor->no_cache = '\x01';
              HText_setNoCache(me->text);
            }
          }
          else {
            tVar6 = LYmktime(content,'\x01');
            tVar7 = LYmktime(me->node_anchor->date,'\x01');
            if (tVar6 <= tVar7) {
              me->node_anchor->no_cache = '\x01';
              HText_setNoCache(me->text);
            }
          }
        }
      }
      else {
        if ((me->node_anchor->charset == (char *)0x0) || (*me->node_anchor->charset == '\0')) {
          if (http_equiv == (char *)0x0) {
            local_78 = "";
          }
          else {
            local_78 = http_equiv;
          }
          iVar3 = strcasecomp(local_78,"Content-Type");
          if (iVar3 == 0) {
            p_in = (LYUCcharset *)0x0;
            p_out = (LYUCcharset *)0x0;
            LYUCTranslateHTMLString
                      (&content,me->tag_charset,me->tag_charset,'\0','\0','\x01',st_other);
            LYLowerCase(content);
            cp1 = strstr(content,"charset");
            if (cp1 != (char *)0x0) {
              chartrans_ok = '\0';
              cp3 = (char *)0x0;
              for (cp1 = cp1 + 7; ((*cp1 == ' ' || (*cp1 == '=')) || (*cp1 == '\"')); cp1 = cp1 + 1)
              {
              }
              HTSACopy(&cp3,cp1);
              for (cp4 = cp3;
                  ((*cp4 != '\0' && (*cp4 != '\"')) &&
                  ((*cp4 != ';' && ((*cp4 != ':' && (0x20 < (byte)*cp4)))))); cp4 = cp4 + 1) {
              }
              *cp4 = '\0';
              cp4 = cp3;
              chndl = UCGetLYhndl_byMIME(cp3);
              BVar1 = UCCanTranslateFromTo(chndl,current_char_set);
              if (BVar1 == '\0') {
                if (chndl < 0) {
                  chndl = UCLYhndl_for_unrec;
                  if (UCLYhndl_for_unrec < 0) {
                    chndl = UCLYhndl_for_unspec;
                  }
                  BVar1 = UCCanTranslateFromTo(chndl,current_char_set);
                  if (BVar1 != '\0') {
                    chartrans_ok = '\x01';
                    HTAnchor_setUCInfoStage(me->node_anchor,chndl,1,3);
                  }
                }
              }
              else {
                chartrans_ok = '\x01';
                HTSACopy(&me->node_anchor->charset,cp4);
                HTAnchor_setUCInfoStage(me->node_anchor,chndl,1,3);
              }
              if (chartrans_ok == '\0') {
                iVar3 = strncmp(cp4,"iso-8859-",9);
                if ((iVar3 == 0) &&
                   (ppuVar4 = __ctype_b_loc(), ((*ppuVar4)[(byte)cp4[9]] & 0x800) != 0)) {
                  local_74 = '\x01';
                }
                else {
                  local_74 = '\0';
                }
                given_is_8859 = local_74;
                if ((((local_74 == '\0') && (iVar3 = strncmp(cp4,"windows-",8), iVar3 != 0)) &&
                    (iVar3 = strncmp(cp4,"cp12",4), iVar3 != 0)) &&
                   (iVar3 = strncmp(cp4,"cp-12",5), iVar3 != 0)) {
                  local_70 = '\0';
                }
                else {
                  local_70 = '\x01';
                }
                given_is_8859like = local_70;
                if ((local_70 == '\0') ||
                   ((pcVar5 = strstr(LYchar_set_names[current_char_set],"ISO-8859"),
                    pcVar5 == (char *)0x0 &&
                    (pcVar5 = strstr(LYchar_set_names[current_char_set],"windows-"),
                    pcVar5 == (char *)0x0)))) {
                  local_6c = '\0';
                }
                else {
                  local_6c = '\x01';
                }
                given_and_display_8859like = local_6c;
                if (given_is_8859 != '\0') {
                  cp1 = cp4 + 10;
                  while ((*cp1 != '\0' &&
                         (ppuVar4 = __ctype_b_loc(), ((*ppuVar4)[(byte)*cp1] & 0x800) != 0))) {
                    cp1 = cp1 + 1;
                  }
                  *cp1 = '\0';
                }
                if (given_and_display_8859like != '\0') {
                  HTSACopy(&me->node_anchor->charset,cp4);
                  HTPassEightBitRaw = '\x01';
                }
                if (*cp4 == '\0') {
                  local_68 = me->node_anchor->charset;
                }
                else {
                  local_68 = cp4;
                }
                HTAlert(local_68);
              }
              else {
                p_in = HTAnchor_getUCInfoStage(me->node_anchor,1);
                p_out = HTAnchor_setUCInfoStage(me->node_anchor,current_char_set,3,1);
                if (p_out == (LYUCcharset *)0x0) {
                  p_out = HTAnchor_getUCInfoStage(me->node_anchor,3);
                }
                iVar3 = strcmp(p_in->MIMEname,"x-transparent");
                if (iVar3 == 0) {
                  HTPassEightBitRaw = '\x01';
                  iVar3 = HTAnchor_getUCLYhndl(me->node_anchor,3);
                  HTAnchor_setUCInfoStage(me->node_anchor,iVar3,1,1);
                }
                iVar3 = strcmp(p_out->MIMEname,"x-transparent");
                if (iVar3 == 0) {
                  HTPassEightBitRaw = '\x01';
                  iVar3 = HTAnchor_getUCLYhndl(me->node_anchor,1);
                  HTAnchor_setUCInfoStage(me->node_anchor,iVar3,3,1);
                }
                if ((p_in->enc == 5) || (p_in->enc == 7)) {
                  if (p_out->enc == 5) {
                    Set_HTCJK(p_in->MIMEname,p_out->MIMEname);
                  }
                }
                else {
                  HTCJK = NOCJK;
                  if (((p_in->codepoints & 1U) == 0) && (chndl == current_char_set)) {
                    HTPassEightBitRaw = '\x01';
                  }
                }
                LYGetChartransInfo(me);
                if (me->UCLYhndl != chndl) {
                  HTAnchor_setUCInfoStage(me->node_anchor,chndl,0,3);
                  HTAnchor_setUCInfoStage(me->node_anchor,chndl,1,3);
                  iVar3 = HTAnchor_getUCLYhndl(me->node_anchor,1);
                  me->inUCLYhndl = iVar3;
                  pLVar8 = HTAnchor_getUCInfoStage(me->node_anchor,1);
                  me->inUCI = pLVar8;
                }
                UCSetTransParams(&me->T,me->inUCLYhndl,me->inUCI,me->outUCLYhndl,me->outUCI);
              }
              if (cp3 != (char *)0x0) {
                free(cp3);
                cp3 = (char *)0x0;
              }
              if ((me->node_anchor->charset != (char *)0x0) && (WWW_TraceFlag != '\0')) {
                pcVar5 = me->node_anchor->charset;
                pFVar2 = TraceFP();
                fprintf((FILE *)pFVar2,"LYHandleMETA: New charset: %s\n",pcVar5);
              }
            }
            HText_setKcode(me->text,me->node_anchor->charset,(LYUCcharset_conflict *)p_in);
            goto free_META_copies;
          }
        }
        if (http_equiv == (char *)0x0) {
          local_64 = "";
        }
        else {
          local_64 = http_equiv;
        }
        iVar3 = strcasecomp(local_64,"Refresh");
        if (iVar3 == 0) {
          cp3 = (char *)0x0;
          LYUCTranslateHTMLString
                    (&content,me->tag_charset,me->tag_charset,'\0','\0','\x01',st_other);
          LYParseRefreshURL(content,&cp3,&href);
          if (cp3 != (char *)0x0) {
            if (href == (char *)0x0) {
              HTSACopy(&href,me->node_anchor->address);
              HText_setNoCache(me->text);
            }
            else {
              url_type = LYLegitimizeHREF(me,&href,'\x01','\0');
              if (url_type == 0) {
                pcVar5 = (char *)gettext("Refresh URL is not absolute.");
                HTUserMsg(pcVar5);
                if (*href == '\0') {
                  HTSACopy(&href,me->node_anchor->address);
                  HText_setNoCache(me->text);
                }
                else {
                  temp = HTParse(href,me->node_anchor->address,0x1f);
                  HTSACopy(&href,temp);
                  if (temp != (char *)0x0) {
                    free(temp);
                    temp = (char *)0x0;
                  }
                }
              }
              else {
                if (me->inBASE == '\0') {
                  local_60 = me->node_anchor->address;
                }
                else {
                  local_60 = me->base_href;
                }
                LYFillLocalFileURL(&href,local_60);
              }
              iVar3 = strcmp(href,me->node_anchor->address);
              if (iVar3 == 0) {
                HText_setNoCache(me->text);
              }
            }
            cp = (char *)0x0;
            if (me->inA != '\0') {
              if ((me->inBoldA == '\x01') && (me->inBoldH == '\0')) {
                HText_appendCharacter(me->text,L'\x06');
              }
              me->inBoldA = '\0';
              HText_endAnchor(me->text,me->CurrentANum);
              me->inA = '\0';
              me->CurrentANum = 0;
            }
            pHVar9 = HTAnchor_findChildAndLink(me->node_anchor,id_string,href,(HTLinkType *)0x0);
            me->CurrentA = pHVar9;
            if (id_string != (char *)0x0) {
              *cp = '#';
              free(id_string);
              id_string = (char *)0x0;
            }
            LYEnsureSingleSpace(me);
            if (me->inUnderline == '\0') {
              HText_appendCharacter(me->text,L'\x03');
            }
            HTML_put_string(me,"REFRESH(");
            HTML_put_string(me,cp3);
            HTML_put_string(me," sec):");
            if (cp3 != (char *)0x0) {
              free(cp3);
              cp3 = (char *)0x0;
            }
            if (me->inUnderline == '\0') {
              HText_appendCharacter(me->text,L'\x04');
            }
            HTML_put_character(me,' ');
            me->in_word = '\0';
            HText_beginAnchor(me->text,me->inUnderline,me->CurrentA);
            if (me->inBoldH == '\0') {
              HText_appendCharacter(me->text,L'\x05');
            }
            HTML_put_string(me,href);
            if (href != (char *)0x0) {
              free(href);
              href = (char *)0x0;
            }
            if (me->inBoldH == '\0') {
              HText_appendCharacter(me->text,L'\x06');
            }
            HText_endAnchor(me->text,L'\0');
            LYEnsureSingleSpace(me);
          }
        }
        else {
          if ((me->node_anchor->SugFname == (char *)0x0) || (*me->node_anchor->SugFname == '\0')) {
            if (http_equiv == (char *)0x0) {
              local_5c = "";
            }
            else {
              local_5c = http_equiv;
            }
            iVar3 = strcasecomp(local_5c,"Content-Disposition");
            if (iVar3 == 0) {
              cp = content;
              while ((*cp != '\0' && (iVar3 = strncasecomp(cp,"filename",8), iVar3 != 0))) {
                cp = cp + 1;
              }
              if (*cp != '\0') {
                cp = LYSkipBlanks(cp + 8);
                if (*cp == '=') {
                  cp = cp + 1;
                }
                cp = LYSkipBlanks(cp);
                if (*cp != '\0') {
                  HTSACopy(&me->node_anchor->SugFname,cp);
                  if (*me->node_anchor->SugFname == '\"') {
                    cp = strchr(me->node_anchor->SugFname + 1,0x22);
                    if (cp == (char *)0x0) {
                      if (me->node_anchor->SugFname != (char *)0x0) {
                        free(me->node_anchor->SugFname);
                        me->node_anchor->SugFname = (char *)0x0;
                      }
                    }
                    else {
                      cp[1] = '\0';
                      HTMIME_TrimDoubleQuotes(me->node_anchor->SugFname);
                      if (((me->node_anchor->SugFname == (char *)0x0) ||
                          (*me->node_anchor->SugFname == '\0')) &&
                         (me->node_anchor->SugFname != (char *)0x0)) {
                        free(me->node_anchor->SugFname);
                        me->node_anchor->SugFname = (char *)0x0;
                      }
                    }
                  }
                  cp = me->node_anchor->SugFname;
                  if (cp != (char *)0x0) {
                    for (; *cp != '\0'; cp = cp + 1) {
                      ppuVar4 = __ctype_b_loc();
                      if (((*ppuVar4)[(byte)*cp] & 0x2000) != 0) {
                        *cp = '_';
                      }
                    }
                  }
                }
              }
              goto free_META_copies;
            }
          }
          if (http_equiv == (char *)0x0) {
            local_58 = "";
          }
          else {
            local_58 = http_equiv;
          }
          iVar3 = strcasecomp(local_58,"Set-Cookie");
          if (iVar3 == 0) {
            if (me->inBASE == '\0') {
              local_54 = me->node_anchor->address;
            }
            else {
              local_54 = me->base_href;
            }
            url_type = is_url(local_54);
            if ((url_type == HTTP_URL_TYPE) || (url_type == HTTPS_URL_TYPE)) {
              if (me->inBASE == '\0') {
                local_50 = me->node_anchor->address;
              }
              else {
                local_50 = me->base_href;
              }
              LYSetCookie(content,(char *)0x0,local_50);
            }
          }
        }
      }
      goto free_META_copies;
    }
  }
  LYUCTranslateHTMLString(&content,me->tag_charset,me->tag_charset,'\0','\0','\x01',st_other);
  iVar3 = strcasecomp(content,"no-cache");
  if (iVar3 == 0) {
    me->node_anchor->no_cache = '\x01';
    HText_setNoCache(me->text);
  }
  if (me->node_anchor->cache_control == (char *)0x0) {
    if (http_equiv == (char *)0x0) {
      local_80 = "";
    }
    else {
      local_80 = http_equiv;
    }
    iVar3 = strcasecomp(local_80,"Cache-Control");
    if (iVar3 == 0) {
      LYLowerCase(content);
      HTSACopy(&me->node_anchor->cache_control,content);
      if (me->node_anchor->no_cache == '\0') {
        cp0 = content;
        while (cp = strstr(cp0,"no-cache"), cp != (char *)0x0) {
          for (cp = cp + 8; (*cp != '\0' && ((byte)*cp < 0x21)); cp = cp + 1) {
          }
          if ((*cp == '\0') || (*cp == ';')) {
            me->node_anchor->no_cache = '\x01';
            HText_setNoCache(me->text);
            break;
          }
          cp0 = cp;
        }
        if (me->node_anchor->no_cache != '\x01') {
          cp0 = content;
          while (pcVar5 = strstr(cp0,"max-age"), pcVar5 != (char *)0x0) {
            for (cp = pcVar5 + 7; (*cp != '\0' && ((byte)*cp < 0x21)); cp = cp + 1) {
            }
            if (*cp == '=') {
              do {
                cp = cp + 1;
                if (*cp == '\0') break;
              } while ((byte)*cp < 0x21);
              ppuVar4 = __ctype_b_loc();
              if (((*ppuVar4)[(byte)*cp] & 0x800) != 0) {
                cp0 = cp;
                while (ppuVar4 = __ctype_b_loc(), ((*ppuVar4)[(byte)*cp] & 0x800) != 0) {
                  cp = cp + 1;
                }
                if ((*cp0 == '0') && (cp0 + 1 == cp)) {
                  me->node_anchor->no_cache = '\x01';
                  HText_setNoCache(me->text);
                  goto free_META_copies;
                }
              }
            }
            cp0 = cp;
          }
          cp = (char *)0x0;
        }
      }
    }
  }
free_META_copies:
  if (http_equiv != (char *)0x0) {
    free(http_equiv);
    http_equiv = (char *)0x0;
  }
  if (name != (char *)0x0) {
    free(name);
    name = (char *)0x0;
  }
  if (content != (char *)0x0) {
    free(content);
  }
  return;
}



void LYHandlePlike(HTStructured *me,BOOLEAN *present,char **value,char **include,int align_idx,
                  BOOLEAN start)

{
  HTStyle *pHVar1;
  BOOLEAN BVar2;
  HTStyle *pHVar3;
  int iVar4;
  BOOLEAN start_local;
  
  if (start != '\0') {
    if (me->inFIG != '\0') {
      me->inFIGwithP = '\x01';
    }
    if (me->inAPPLET != '\0') {
      me->inAPPLETwithP = '\x01';
    }
  }
  if (me->style_change != '\0') {
    actually_set_style(me);
  }
  if (me->List_Nesting_Level < 0) {
    if (me->sp->tag_number == 3) {
      BVar2 = HText_LastLineEmpty(me->text,'\0');
      if (BVar2 == '\0') {
        HText_setLastChar(me->text,' ');
        HText_appendCharacter(me->text,L'\r');
      }
    }
    else {
      if (start == '\0') {
        if (me->sp->style->spaceAfter < 1) {
          LYEnsureSingleSpace(me);
        }
        else {
          LYEnsureDoubleSpace(me);
        }
      }
      else if ((me->inLABEL == '\0') || (me->inP != '\0')) {
        HText_appendParagraph(me->text);
      }
      me->inLABEL = '\0';
    }
  }
  else if (me->inP != '\0') {
    if (((((me->inFIG == '\0') && (me->inAPPLET == '\0')) && (me->inCAPTION == '\0')) &&
        ((me->inCREDIT == '\0' && (me->sp->style->spaceAfter < 1)))) &&
       ((start == '\0' || (me->sp->style->spaceBefore < 1)))) {
      LYEnsureSingleSpace(me);
    }
    else {
      LYEnsureDoubleSpace(me);
    }
  }
  me->in_word = '\0';
  BVar2 = LYoverride_default_alignment(me);
  if (BVar2 == '\0') {
    if (((me->List_Nesting_Level < 0) ||
        (((me->sp->style->id != 1 && (me->sp->style->id != 2)) && (me->sp->style->id != 3)))) &&
       ((-1 < me->Division_Level || ((me->sp->style->id != 0 && (me->sp->style->id != 0x25)))))) {
      me->sp->style->alignment = (short)me->current_default_alignment;
    }
    else {
      me->sp->style->alignment = 1;
    }
  }
  else {
    pHVar1 = me->sp->style;
    pHVar3 = LYstyles(me->sp->tag_number);
    pHVar1->alignment = pHVar3->alignment;
  }
  if ((((start != '\0') && (present != (BOOLEAN *)0x0)) && (present[align_idx] != '\0')) &&
     (value[align_idx] != (char *)0x0)) {
    iVar4 = strcasecomp(value[align_idx],"center");
    if ((iVar4 == 0) && ((me->List_Nesting_Level < 0 || (me->inP != '\0')))) {
      me->sp->style->alignment = 3;
    }
    else {
      iVar4 = strcasecomp(value[align_idx],"right");
      if ((iVar4 == 0) && ((me->List_Nesting_Level < 0 || (me->inP != '\0')))) {
        me->sp->style->alignment = 2;
      }
      else {
        iVar4 = strcasecomp(value[align_idx],"left");
        if (iVar4 != 0) {
          iVar4 = strcasecomp(value[align_idx],"justify");
          if (iVar4 != 0) goto LAB_080e2480;
        }
        me->sp->style->alignment = 1;
      }
    }
  }
LAB_080e2480:
  me->inP = '\0';
  return;
}



// WARNING: Removing unreachable block (ram,0x080e2845)

void LYHandleSELECT(HTStructured *me,BOOLEAN *present,char **value,char **include,BOOLEAN start)

{
  BOOLEAN BVar1;
  FILE *pFVar2;
  char *pcVar3;
  wchar_t wVar4;
  size_t sVar5;
  BOOLEAN start_local;
  char *ptr;
  char *size;
  char *name;
  int i;
  BOOLEAN multiple;
  
  if (start == '\x01') {
    name = (char *)0x0;
    multiple = '\0';
    me->select_disabled = '\0';
    if (((me->inFORM == '\0') && (BVar1 = LYBadHTML(me), BVar1 != '\0')) && (WWW_TraceFlag != '\0'))
    {
      pFVar2 = TraceFP();
      fprintf((FILE *)pFVar2,"Bad HTML: SELECT start tag not within FORM tag\n");
    }
    if (((me->inTEXTAREA != '\0') && (BVar1 = LYBadHTML(me), BVar1 != '\0')) &&
       (WWW_TraceFlag != '\0')) {
      pFVar2 = TraceFP();
      fprintf((FILE *)pFVar2,"Bad HTML: Missing TEXTAREA end tag\n");
    }
    me->inSELECT = '\x01';
    if (((present == (BOOLEAN *)0x0) || (present[0xb] == '\0')) ||
       ((value[0xb] == (char *)0x0 || (*value[0xb] == '\0')))) {
      HTSACopy(&name,"");
    }
    else {
      pcVar3 = strchr(value[0xb],0x26);
      if (pcVar3 == (char *)0x0) {
        HTSACopy(&name,value[0xb]);
      }
      else {
        HTSACopy(&name,value[0xb]);
        LYUCTranslateHTMLString(&name,me->tag_charset,me->tag_charset,'\0','\0','\x01',st_HTML);
      }
    }
    if ((present != (BOOLEAN *)0x0) && (present[10] != '\0')) {
      multiple = '\x01';
    }
    if ((present != (BOOLEAN *)0x0) && (present[4] != '\0')) {
      me->select_disabled = '\x01';
    }
    if ((((present != (BOOLEAN *)0x0) && (present[0x10] != '\0')) && (value[0x10] != (char *)0x0))
       && ((*value[0x10] != '\0' && (WWW_TraceFlag != '\0')))) {
      pcVar3 = value[0x10];
      pFVar2 = TraceFP();
      fprintf((FILE *)pFVar2,"LYHandleSELECT: Ignoring SIZE=\"%s\" for SELECT.\n",pcVar3);
    }
    if ((me->inBoldH == '\x01') && ((multiple == '\0' || (LYSelectPopups == '\0')))) {
      HText_appendCharacter(me->text,L'\x06');
      me->inBoldH = '\0';
      me->needBoldH = '\x01';
    }
    if ((me->inUnderline == '\x01') && ((multiple == '\0' || (LYSelectPopups == '\0')))) {
      HText_appendCharacter(me->text,L'\x04');
      me->inUnderline = '\0';
    }
    if ((((multiple == '\0') && (LYSelectPopups == '\x01')) &&
        ((me->sp->tag_number == 0x56 ||
         ((me->inPRE == '\x01' || (me->sp->style->freeFormat == '\0')))))) &&
       (wVar4 = HText_LastLineSize(me->text,'\0'),
       (LYcols - (uint)(LYShowScrollbar != '\0')) + L'\xfffffff9' < wVar4)) {
      HTML_put_character(me,'\n');
      me->in_word = '\0';
    }
    LYCheckForID(me,present,value,7);
    HText_beginSelect(name,me->tag_charset,multiple,(char *)0x0);
    if (name != (char *)0x0) {
      free(name);
    }
    me->first_option = '\x01';
  }
  else if (me->inSELECT == '\0') {
    BVar1 = LYBadHTML(me);
    if ((BVar1 != '\0') && (WWW_TraceFlag != '\0')) {
      pFVar2 = TraceFP();
      fprintf((FILE *)pFVar2,"Bad HTML: Unmatched SELECT end tag\n");
    }
  }
  else {
    me->inSELECT = '\0';
    me->select_disabled = '\0';
    HTChunkTerminate(&me->option);
    ptr = HText_setLastOptionValue
                    (me->text,(me->option).data,me->LastOptionValue,L'\x03',me->LastOptionChecked,
                     me->UCLYhndl,me->tag_charset);
    if (me->LastOptionValue != (char *)0x0) {
      free(me->LastOptionValue);
      me->LastOptionValue = (char *)0x0;
    }
    me->LastOptionChecked = '\0';
    if ((HTCurSelectGroupType == L'\x03') || (LYSelectPopups == '\0')) {
      LYEnsureSingleSpace(me);
    }
    else {
      if (((ptr != (char *)0x0) && (me->sp->tag_number == 0x56)) && (sVar5 = strlen(ptr), 6 < sVar5)
         ) {
        for (i = 0; i < 6; i = i + 1) {
          if (*ptr == ' ') {
            HText_appendCharacter(me->text,L'\x01');
          }
          else {
            HText_appendCharacter(me->text,(int)*ptr);
          }
          ptr = ptr + 1;
        }
        HText_setIgnoreExcess(me->text,'\x01');
      }
      for (; (ptr != (char *)0x0 && (*ptr != '\0')); ptr = ptr + 1) {
        if (*ptr == ' ') {
          HText_appendCharacter(me->text,L'\x01');
        }
        else {
          HText_appendCharacter(me->text,(int)*ptr);
        }
      }
      if (me->first_option == '\0') {
        HText_appendCharacter(me->text,L']');
        HText_setLastChar(me->text,']');
        me->in_word = '\x01';
      }
      HText_setIgnoreExcess(me->text,'\0');
    }
    HTChunkClear(&me->option);
    if ((0 < me->Underline_Level) && (me->inUnderline == '\0')) {
      HText_appendCharacter(me->text,L'\x03');
      me->inUnderline = '\x01';
    }
    if ((me->needBoldH == '\x01') && (me->inBoldH == '\0')) {
      HText_appendCharacter(me->text,L'\x05');
      me->inBoldH = '\x01';
      me->needBoldH = '\0';
    }
  }
  return;
}



int LYLegitimizeHREF(HTStructured *me,char **href,BOOLEAN force_slash,BOOLEAN strip_dots)

{
  BOOLEAN BVar1;
  char *pcVar2;
  char *pcVar3;
  int iVar4;
  char *pcVar5;
  char *__s1;
  FILE *pFVar6;
  UrlTypes local_38;
  char *local_34;
  BOOLEAN strip_dots_local;
  BOOLEAN force_slash_local;
  char *str;
  char *cp;
  char *path;
  char *temp;
  char *Base;
  char *pound;
  char *p;
  int url_type;
  
  if ((((me == (HTStructured *)0x0) || (href == (char **)0x0)) || (*href == (char *)0x0)) ||
     (**href == '\0')) {
    local_38 = NOT_A_URL_TYPE;
  }
  else {
    BVar1 = LYTrimStartfile(*href);
    if ((BVar1 == '\0') && (pcVar2 = LYSkipNonBlanks(*href), *pcVar2 != '\0')) {
      pcVar3 = strchr(*href,0x23);
      if ((pcVar3 == (char *)0x0) || (pcVar2 <= pcVar3)) {
        if (pcVar3 != (char *)0x0) {
          *pcVar3 = '\0';
        }
        BVar1 = LYRemoveNewlines(pcVar2);
        if ((BVar1 != '\0') || (pcVar5 = strchr(pcVar2,9), pcVar5 != (char *)0x0)) {
          LYRemoveBlanks(pcVar2);
        }
        if (pcVar3 != (char *)0x0) {
          pcVar2 = strchr(pcVar2,0);
          *pcVar3 = '#';
          convert_to_spaces(pcVar3,'\0');
          if (pcVar2 < pcVar3) {
            strcpy(pcVar2,pcVar3);
          }
        }
      }
      else {
        convert_to_spaces(pcVar2,'\0');
      }
    }
    if (**href == '\0') {
      local_38 = NOT_A_URL_TYPE;
    }
    else {
      pcVar2 = (char *)0x0;
      LYUCTranslateHTMLString(href,me->tag_charset,me->tag_charset,'\0','\0','\x01',st_URL);
      if (me->inBASE == '\0') {
        local_34 = me->node_anchor->address;
      }
      else {
        local_34 = me->base_href;
      }
      local_38 = is_url(*href);
      if (((((local_38 == NOT_A_URL_TYPE) && (force_slash != '\0')) && (**href == '.')) &&
          ((iVar4 = strcmp(*href,"."), iVar4 == 0 || (iVar4 = strcmp(*href,".."), iVar4 == 0)))) &&
         (((*local_34 != 'f' && (*local_34 != 'F')) ||
          (iVar4 = strncasecomp(local_34,"file:",5), iVar4 != 0)))) {
        HTSACat(href,"/");
      }
      if (((local_38 == NOT_A_URL_TYPE) && (LYStripDotDotURLs != '\0')) &&
         ((strip_dots != '\0' &&
          ((**href == '.' && (iVar4 = strncasecomp(local_34,"http",4), iVar4 == 0)))))) {
        str = "";
        pcVar5 = HTParse(*href,local_34,0x1f);
        __s1 = HTParse(pcVar5,"",5);
        pcVar3 = (char *)0x3;
        iVar4 = strncmp(__s1,"/..",3);
        if (iVar4 == 0) {
          cp = __s1 + 3;
          if ((*cp == '/') || (*cp == '\0')) {
            if (local_34[4] == 's') {
              str = "s";
            }
            if (WWW_TraceFlag != '\0') {
              pcVar3 = *href;
              pFVar6 = TraceFP();
              fprintf((FILE *)pFVar6,"LYLegitimizeHREF: Bad value \'%s\' for http%s URL.\n",pcVar3,
                      str);
              pcVar2 = str;
            }
            if (WWW_TraceFlag != '\0') {
              pFVar6 = TraceFP();
              fprintf((FILE *)pFVar6,"                  Stripping lead dots.\n",pcVar3,pcVar2);
            }
            if (me->inBadHREF == '\0') {
              pcVar2 = (char *)gettext("Bad partial reference!  Stripping lead dots.");
              HTUserMsg(pcVar2);
              me->inBadHREF = '\x01';
            }
          }
          if (*cp == '\0') {
            HTSACopy(href,"/");
          }
          else if (*cp == '/') {
            while (iVar4 = strncmp(cp,"/..",3), iVar4 == 0) {
              if (cp[3] != '/') {
                if (cp[3] == '\0') {
                  cp[1] = '\0';
                  cp[2] = '\0';
                }
                break;
              }
              cp = cp + 3;
            }
            HTSACopy(href,cp);
          }
        }
        if (pcVar5 != (char *)0x0) {
          free(pcVar5);
        }
        if (__s1 != (char *)0x0) {
          free(__s1);
        }
      }
    }
  }
  return local_38;
}



// WARNING: Unknown calling convention

void LYCheckForContentBase(HTStructured *me)

{
  UrlTypes UVar1;
  char *value [6];
  BOOLEAN present [6];
  int i;
  char *cp;
  
  cp = (char *)0x0;
  if (me == (HTStructured *)0x0) {
    return;
  }
  if (me->node_anchor == (HTParentAnchor *)0x0) {
    return;
  }
  if (me->node_anchor->content_base == (char *)0x0) {
    if (me->node_anchor->content_location == (char *)0x0) {
      return;
    }
    if (*me->node_anchor->content_location == '\0') {
      return;
    }
    HTSACopy(&cp,me->node_anchor->content_location);
    LYRemoveBlanks(cp);
    UVar1 = is_url(cp);
    if (UVar1 == NOT_A_URL_TYPE) {
      if (cp == (char *)0x0) {
        return;
      }
      free(cp);
      return;
    }
  }
  else {
    if (*me->node_anchor->content_base == '\0') {
      return;
    }
    HTSACopy(&cp,me->node_anchor->content_base);
    LYRemoveBlanks(cp);
  }
  if (*cp == '\0') {
    if (cp != (char *)0x0) {
      free(cp);
    }
  }
  else {
    for (i = 0; i < 6; i = i + 1) {
      present[i] = '\0';
    }
    present[1] = '\x01';
    value[1] = cp;
    (*me->isa->start_element)(me,10,present,value,0,(char **)0x0);
    if (cp != (char *)0x0) {
      free(cp);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void LYCheckForID(HTStructured *me,BOOLEAN *present,char **value,int attribute)

{
  char *temp;
  HTChildAnchor *ID_A;
  
  ID_A = (HTChildAnchor *)0x0;
  temp = (char *)0x0;
  if ((((me != (HTStructured *)0x0) && (me->text != (HText *)0x0)) && (present != (BOOLEAN *)0x0))
     && (((present[attribute] != '\0' && (value[attribute] != (char *)0x0)) &&
         (*value[attribute] != '\0')))) {
    HTSACopy(&temp,value[attribute]);
    LYUCTranslateHTMLString(&temp,me->tag_charset,me->tag_charset,'\0','\0','\x01',st_URL);
    if (*temp != '\0') {
      ID_A = HTAnchor_findChildAndLink(me->node_anchor,temp,(char *)0x0,(HTLinkType *)0x0);
      if (ID_A != (HTChildAnchor *)0x0) {
        HText_beginAnchor(me->text,me->inUnderline,ID_A);
        HText_endAnchor(me->text,L'\0');
      }
    }
    if (temp != (char *)0x0) {
      free(temp);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void LYHandleID(HTStructured *me,char *id)

{
  HTChildAnchor *anc;
  HTChildAnchor *ID_A;
  
  if ((((me != (HTStructured *)0x0) && (me->text != (HText *)0x0)) && (id != (char *)0x0)) &&
     (*id != '\0')) {
    anc = HTAnchor_findChildAndLink(me->node_anchor,id,(char *)0x0,(HTLinkType *)0x0);
    if (anc != (HTChildAnchor *)0x0) {
      HText_beginAnchor(me->text,me->inUnderline,anc);
      HText_endAnchor(me->text,L'\0');
    }
  }
  return;
}



// WARNING: Unknown calling convention

BOOLEAN LYoverride_default_alignment(HTStructured *me)

{
  int iVar1;
  BOOLEAN local_9;
  
  if (me == (HTStructured *)0x0) {
    return '\0';
  }
  iVar1 = me->sp->tag_number;
  if (iVar1 == 0x13) {
LAB_080e3423:
    me->sp->style->alignment = 1;
    local_9 = '\x01';
  }
  else {
    if (iVar1 < 0x14) {
      if ((iVar1 == 3) || (iVar1 == 0x10)) goto LAB_080e3423;
    }
    else if ((iVar1 == 0x2a) || (iVar1 == 0x4e)) goto LAB_080e3423;
    local_9 = '\0';
  }
  return local_9;
}



// WARNING: Unknown calling convention

void LYEnsureDoubleSpace(HTStructured *me)

{
  BOOLEAN BVar1;
  
  if ((me != (HTStructured *)0x0) && (me->text != (HText *)0x0)) {
    BVar1 = HText_LastLineEmpty(me->text,'\0');
    if (BVar1 == '\0') {
      HText_setLastChar(me->text,' ');
      HText_appendCharacter(me->text,L'\r');
      HText_appendCharacter(me->text,L'\r');
    }
    else {
      BVar1 = HText_PreviousLineEmpty(me->text,'\0');
      if (BVar1 == '\0') {
        HText_setLastChar(me->text,' ');
        HText_appendCharacter(me->text,L'\r');
      }
      else if (-1 < me->List_Nesting_Level) {
        HText_NegateLineOne(me->text);
      }
    }
    me->in_word = '\0';
  }
  return;
}



// WARNING: Unknown calling convention

void LYEnsureSingleSpace(HTStructured *me)

{
  BOOLEAN BVar1;
  
  if ((me != (HTStructured *)0x0) && (me->text != (HText *)0x0)) {
    BVar1 = HText_LastLineEmpty(me->text,'\0');
    if (BVar1 == '\0') {
      HText_setLastChar(me->text,' ');
      HText_appendCharacter(me->text,L'\r');
    }
    else if (-1 < me->List_Nesting_Level) {
      HText_NegateLineOne(me->text);
    }
    me->in_word = '\0';
  }
  return;
}



// WARNING: Unknown calling convention

void LYResetParagraphAlignment(HTStructured *me)

{
  if (me != (HTStructured *)0x0) {
    if ((me->List_Nesting_Level < 0) &&
       ((-1 < me->Division_Level || ((me->sp->style->id != 0 && (me->sp->style->id != 0x25)))))) {
      me->sp->style->alignment = (short)me->current_default_alignment;
    }
    else {
      me->sp->style->alignment = 1;
    }
  }
  return;
}



// WARNING: Unknown calling convention

BOOLEAN LYCheckForCSI(HTParentAnchor *anchor,char **url)

{
  BOOLEAN BVar1;
  int iVar2;
  
  if ((((anchor != (HTParentAnchor *)0x0) && (anchor->address != (char *)0x0)) &&
      ((*anchor->address == 'f' || (*anchor->address == 'F')))) &&
     (iVar2 = strncasecomp(anchor->address,"file:",5), iVar2 == 0)) {
    BVar1 = LYisLocalHost(anchor->address);
    if (BVar1 != '\0') {
      HTSACopy(url,anchor->address);
      return '\x01';
    }
    return '\0';
  }
  return '\0';
}



// WARNING: Unknown calling convention

BOOLEAN LYCommentHacks(HTParentAnchor *anchor,char *comment)

{
  char *pcVar1;
  BOOLEAN BVar2;
  int iVar3;
  ushort **ppuVar4;
  char *p_1;
  char *messageid;
  char *p;
  size_t len;
  char *cp;
  
  cp = comment;
  if (((comment != (char *)0x0) && (anchor != (HTParentAnchor *)0x0)) &&
     (anchor->address != (char *)0x0)) {
    iVar3 = strncmp(comment,"!--X-Message-Id: ",0x11);
    if (iVar3 == 0) {
      messageid = (char *)0x0;
      cp = comment + 0x11;
      while (((*cp != '\0' && ((byte)*cp < 0x7f)) &&
             (ppuVar4 = __ctype_b_loc(), (short)(*ppuVar4)[(byte)*cp] < 0))) {
        cp = cp + 1;
      }
      iVar3 = strcmp(cp," --");
      if (iVar3 == 0) {
        cp = comment + 0x11;
        HTSACopy(&messageid,cp);
        BVar2 = LYUCTranslateHTMLString(&messageid,0,0,'\0','\0','\x01',st_URL);
        if (BVar2 != '\0') {
          p = messageid;
          while (((*p != '\0' && ((byte)*p < 0x7f)) &&
                 (ppuVar4 = __ctype_b_loc(), (short)(*ppuVar4)[(byte)*p] < 0))) {
            p = p + 1;
          }
          iVar3 = strcmp(p," --");
          if (iVar3 == 0) {
            p = strchr(messageid,0x40);
            if ((p == (char *)0x0) || (p[1] == '\0')) {
              if (messageid != (char *)0x0) {
                free(messageid);
              }
            }
            else {
              p = messageid;
              len = strlen(messageid);
              if ((7 < len) && (iVar3 = strcmp(p + (len - 3)," --"), iVar3 == 0)) {
                p[len - 3] = '\0';
                BVar2 = HTAnchor_setMessageID(anchor,messageid);
                if (BVar2 != '\0') {
                  if (messageid != (char *)0x0) {
                    free(messageid);
                  }
                  return '\x01';
                }
                if (messageid != (char *)0x0) {
                  free(messageid);
                }
                return '\0';
              }
              if (messageid != (char *)0x0) {
                free(messageid);
              }
            }
          }
          else if (messageid != (char *)0x0) {
            free(messageid);
          }
        }
      }
    }
    else {
      iVar3 = strncmp(comment,"!--X-Subject: ",0xe);
      if (iVar3 == 0) {
        messageid = (char *)0x0;
        for (cp = comment + 0xe; *cp != '\0'; cp = cp + 1) {
          if ((0x7e < (byte)*cp) ||
             (ppuVar4 = __ctype_b_loc(), ((*ppuVar4)[(byte)*cp] & 0x4000) == 0)) {
            return '\0';
          }
        }
        cp = comment + 0xe;
        HTSACopy(&messageid,cp);
        BVar2 = LYUCTranslateHTMLString(&messageid,0,0,'\0','\x01','\0',st_HTML);
        if (BVar2 != '\0') {
          for (p_1 = messageid; pcVar1 = messageid, *p_1 != '\0'; p_1 = p_1 + 1) {
            if ((0x7e < (byte)*p_1) ||
               (ppuVar4 = __ctype_b_loc(), ((*ppuVar4)[(byte)*p_1] & 0x4000) == 0)) {
              if (messageid != (char *)0x0) {
                free(messageid);
              }
              return '\0';
            }
          }
          len = strlen(messageid);
          if ((3 < len) && (iVar3 = strcmp(pcVar1 + (len - 3)," --"), iVar3 == 0)) {
            pcVar1[len - 3] = '\0';
            BVar2 = HTAnchor_setSubject(anchor,messageid);
            if (BVar2 != '\0') {
              if (messageid != (char *)0x0) {
                free(messageid);
              }
              return '\x01';
            }
            if (messageid != (char *)0x0) {
              free(messageid);
            }
            return '\0';
          }
          if (messageid != (char *)0x0) {
            free(messageid);
          }
        }
      }
    }
  }
  return '\0';
}



// WARNING: Unknown calling convention

void LYformTitle(char **dst,char *src)

{
  size_t sVar1;
  uchar *euc;
  FILE *__stream;
  char *tmp_buffer;
  
  if (HTCJK == JAPANESE) {
    sVar1 = strlen(src);
    euc = (uchar *)malloc(sVar1 + 1);
    if (euc == (uchar *)0x0) {
      outofmem("./LYCharUtils.c","LYformTitle");
    }
    if (kanji_code == EUC) {
      TO_EUC((uchar *)src,euc);
    }
    else if (kanji_code == SJIS) {
      TO_SJIS((uchar *)src,euc);
    }
    else {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"\nLYformTitle: kanji_code is an unexpected value.");
      }
      strcpy((char *)euc,src);
    }
    HTSACopy(dst,(char *)euc);
    if (euc != (uchar *)0x0) {
      free(euc);
    }
  }
  else {
    HTSACopy(dst,src);
  }
  return;
}



// WARNING: Unknown calling convention

void ImageMapList_free(HTList *theList)

{
  void **local_1c;
  void **local_18;
  HTList *current;
  HTList *cur;
  LYMapElement *element;
  LYImageMap *map;
  
  cur = theList;
  if (theList != (HTList *)0x0) {
    while( true ) {
      if ((cur == (HTList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
        local_18 = (void **)0x0;
      }
      else {
        local_18 = (void **)cur->object;
      }
      if (local_18 == (void **)0x0) break;
      if (*local_18 != (void *)0x0) {
        free(*local_18);
        *local_18 = (void *)0x0;
      }
      if (local_18[1] != (void *)0x0) {
        free(local_18[1]);
        local_18[1] = (void *)0x0;
      }
      if (local_18[2] != (void *)0x0) {
        current = (HTList *)local_18[2];
        while( true ) {
          if ((current == (HTList *)0x0) || (current = current->next, current == (HTList *)0x0)) {
            local_1c = (void **)0x0;
          }
          else {
            local_1c = (void **)current->object;
          }
          if (local_1c == (void **)0x0) break;
          if (*local_1c != (void *)0x0) {
            free(*local_1c);
            *local_1c = (void *)0x0;
          }
          if (local_1c[1] != (void *)0x0) {
            free(local_1c[1]);
            local_1c[1] = (void *)0x0;
          }
          if (local_1c != (void **)0x0) {
            free(local_1c);
          }
        }
        HTList_delete((HTList *)local_18[2]);
        local_18[2] = (void *)0x0;
      }
      if (local_18 != (void **)0x0) {
        free(local_18);
      }
    }
    HTList_delete(theList);
  }
  return;
}



// WARNING: Unknown calling convention

BOOLEAN LYAddImageMap(char *address,char *title,HTParentAnchor *node_anchor)

{
  HTList *me;
  int iVar1;
  BOOLEAN local_31;
  void **local_30;
  LYImageMap *local_2c;
  LYImageMap *local_28;
  LYMapElement *ele;
  HTList *curele;
  HTList *theList;
  HTList *cur;
  LYImageMap *old;
  LYImageMap *tmp;
  
  old = (LYImageMap *)0x0;
  if ((address == (char *)0x0) || (*address == '\0')) {
    local_31 = '\0';
  }
  else if ((node_anchor == (HTParentAnchor *)0x0) || (node_anchor->address == (char *)0x0)) {
    local_31 = '\0';
  }
  else {
    if (LynxMaps == (HTList *)0x0) {
      LynxMaps = HTList_new();
    }
    me = LynxMaps;
    if (LynxMaps != (HTList *)0x0) {
      cur = LynxMaps;
      do {
        do {
          if ((cur == (HTList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
            local_2c = (LYImageMap *)0x0;
          }
          else {
            local_2c = (LYImageMap *)cur->object;
          }
          old = local_2c;
          if (local_2c == (LYImageMap *)0x0) goto LAB_080e3fd3;
        } while (local_2c->address == (char *)0x0);
        iVar1 = strcmp(local_2c->address,address);
      } while (iVar1 != 0);
      if (local_2c->address != (char *)0x0) {
        free(local_2c->address);
        local_2c->address = (char *)0x0;
      }
      if (local_2c->title != (char *)0x0) {
        free(local_2c->title);
        local_2c->title = (char *)0x0;
      }
      if (local_2c->elements != (HTList *)0x0) {
        curele = local_2c->elements;
        while( true ) {
          if ((curele == (HTList *)0x0) || (curele = curele->next, curele == (HTList *)0x0)) {
            local_30 = (void **)0x0;
          }
          else {
            local_30 = (void **)curele->object;
          }
          if (local_30 == (void **)0x0) break;
          if (*local_30 != (void *)0x0) {
            free(*local_30);
            *local_30 = (void *)0x0;
          }
          if (local_30[1] != (void *)0x0) {
            free(local_30[1]);
            local_30[1] = (void *)0x0;
          }
          if (local_30 != (void **)0x0) {
            free(local_30);
          }
        }
        HTList_delete(local_2c->elements);
        local_2c->elements = (HTList *)0x0;
      }
    }
LAB_080e3fd3:
    if (old == (LYImageMap *)0x0) {
      local_28 = (LYImageMap *)calloc(1,0xc);
    }
    else {
      local_28 = old;
    }
    if (local_28 == (LYImageMap *)0x0) {
      outofmem("./LYMap.c","LYAddImageMap");
      local_31 = '\0';
    }
    else {
      HTSACopy(&local_28->address,address);
      if ((title != (char *)0x0) && (*title != '\0')) {
        HTSACopy(&local_28->title,title);
      }
      if (local_28 != old) {
        HTList_addObject(me,local_28);
      }
      local_31 = '\x01';
    }
  }
  return local_31;
}



BOOLEAN LYAddMapElement(char *map,char *address,char *title,HTParentAnchor *node_anchor,
                       BOOLEAN intern_flag)

{
  HTList *pHVar1;
  int iVar2;
  char **dest;
  FILE *__stream;
  BOOLEAN local_2d;
  char **local_2c;
  char **local_28;
  char *local_24;
  char *local_20;
  char *local_1c;
  BOOLEAN intern_flag_local;
  HTList *cur;
  HTList *theList;
  LYImageMap *theMap;
  LYMapElement *tmp;
  
  if ((((map == (char *)0x0) || (*map == '\0')) || (address == (char *)0x0)) || (*address == '\0'))
  {
    local_2d = '\0';
  }
  else if ((node_anchor == (HTParentAnchor *)0x0) || (node_anchor->address == (char *)0x0)) {
    local_2d = '\0';
  }
  else {
    if (LynxMaps == (HTList *)0x0) {
      LYAddImageMap(map,(char *)0x0,node_anchor);
    }
    cur = LynxMaps;
    do {
      if ((cur == (HTList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
        local_2c = (char **)0x0;
      }
      else {
        local_2c = (char **)cur->object;
      }
      if (local_2c == (char **)0x0) break;
      iVar2 = strcmp(*local_2c,map);
    } while (iVar2 != 0);
    if (local_2c == (char **)0x0) {
      local_2d = '\0';
    }
    else {
      if (local_2c[2] == (char *)0x0) {
        pHVar1 = HTList_new();
        local_2c[2] = (char *)pHVar1;
      }
      cur = (HTList *)local_2c[2];
      do {
        if ((cur == (HTList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
          local_28 = (char **)0x0;
        }
        else {
          local_28 = (char **)cur->object;
        }
        if (local_28 == (char **)0x0) goto LAB_080e4252;
        iVar2 = strcmp(*local_28,address);
      } while (iVar2 != 0);
      if (*local_28 != (char *)0x0) {
        free(*local_28);
        *local_28 = (char *)0x0;
      }
      if (local_28[1] != (char *)0x0) {
        free(local_28[1]);
        local_28[1] = (char *)0x0;
      }
      HTList_removeObject((HTList *)local_2c[2],local_28);
      if (local_28 != (char **)0x0) {
        free(local_28);
      }
LAB_080e4252:
      dest = (char **)calloc(1,8);
      if (dest == (char **)0x0) {
        perror("Out of memory in LYAddMapElement");
        local_2d = '\0';
      }
      else {
        HTSACopy(dest,address);
        if ((title == (char *)0x0) || (*title == '\0')) {
          HTSACopy(dest + 1,address);
        }
        else {
          HTSACopy(dest + 1,title);
        }
        HTList_appendObject((HTList *)local_2c[2],dest);
        if (WWW_TraceFlag != '\0') {
          if (title == (char *)0x0) {
            local_24 = "";
          }
          else {
            local_24 = title;
          }
          if (address == (char *)0x0) {
            local_20 = "";
          }
          else {
            local_20 = address;
          }
          if (map == (char *)0x0) {
            local_1c = "";
          }
          else {
            local_1c = map;
          }
          __stream = TraceFP();
          fprintf((FILE *)__stream,"LYAddMapElement\n\tmap     %s\n\taddress %s\n\ttitle   %s)\n",
                  local_1c,local_20,local_24);
        }
        local_2d = '\x01';
      }
    }
  }
  return local_2d;
}



// WARNING: Unknown calling convention

BOOLEAN LYHaveImageMap(char *address)

{
  int iVar1;
  BOOLEAN local_19;
  char **local_18;
  HTList *cur;
  LYImageMap *Map;
  
  cur = LynxMaps;
  if (((LynxMaps == (HTList *)0x0) || (address == (char *)0x0)) || (*address == '\0')) {
    local_19 = '\0';
  }
  else {
    do {
      if ((cur == (HTList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
        local_18 = (char **)0x0;
      }
      else {
        local_18 = (char **)cur->object;
      }
      if (local_18 == (char **)0x0) {
        return '\0';
      }
      iVar1 = strcmp(*local_18,address);
    } while (iVar1 != 0);
    local_19 = '\x01';
  }
  return local_19;
}



// WARNING: Unknown calling convention

void fill_DocAddress(DocAddress *wwwdoc,char *address,HTParentAnchor *anAnchor,
                    HTParentAnchor **punderlying)

{
  HTParentAnchor *pHVar1;
  HTParentAnchor *underlying;
  
  if ((anAnchor == (HTParentAnchor *)0x0) || (anAnchor->post_data == (bstring *)0x0)) {
    wwwdoc->address = address;
    wwwdoc->post_data = (bstring *)0x0;
    wwwdoc->post_content_type = (char *)0x0;
    wwwdoc->bookmark = (char *)0x0;
    wwwdoc->isHEAD = '\0';
    wwwdoc->safe = '\0';
    if (punderlying != (HTParentAnchor **)0x0) {
      *punderlying = (HTParentAnchor *)0x0;
    }
  }
  else {
    wwwdoc->address = address;
    wwwdoc->post_data = anAnchor->post_data;
    wwwdoc->post_content_type = anAnchor->post_content_type;
    wwwdoc->bookmark = (char *)0x0;
    wwwdoc->isHEAD = '\0';
    wwwdoc->safe = '\0';
    pHVar1 = HTAnchor_findAddress(wwwdoc);
    if (pHVar1->safe != '\0') {
      wwwdoc->safe = '\x01';
    }
    if (punderlying != (HTParentAnchor **)0x0) {
      *punderlying = pHVar1;
    }
  }
  return;
}



// WARNING: Unknown calling convention

HTList * get_the_list(DocAddress *wwwdoc,char *address,HTParentAnchor *anchor,
                     HTParentAnchor **punderlying)

{
  HTList *local_8;
  
  if ((anchor == (HTParentAnchor *)0x0) || (anchor->post_data == (bstring *)0x0)) {
    fill_DocAddress(wwwdoc,address,(HTParentAnchor *)0x0,punderlying);
    local_8 = LynxMaps;
  }
  else {
    fill_DocAddress(wwwdoc,address,anchor,punderlying);
    if ((punderlying == (HTParentAnchor **)0x0) || (*punderlying == (HTParentAnchor *)0x0)) {
      local_8 = anchor->imaps;
    }
    else {
      local_8 = (*punderlying)->imaps;
    }
  }
  return local_8;
}



// WARNING: Unknown calling convention

int LYLoadIMGmap(char *arg,HTParentAnchor *anAnchor,HTFormat format_out,HTStream *sink)

{
  char *pcVar1;
  _func_void_HTStream_ptr_char_ptr_wchar_t *p_Var2;
  HTFormat pHVar3;
  BOOLEAN BVar4;
  int iVar5;
  char *pcVar6;
  char *fmt;
  wchar_t wVar7;
  LYImageMap *local_70;
  LYImageMap *local_6c;
  undefined *local_68;
  LYMapElement *local_64;
  undefined *local_60;
  DocAddress WWWDoc;
  HTFormat old_format_out;
  HTParentAnchor *underlying;
  char *cp;
  char *address;
  HTList *cur;
  HTList *theList;
  char *MapAddress;
  char *MapTitle;
  LYImageMap *theMap;
  LYMapElement *tmp;
  char *buf;
  HTStream *target;
  HTFormat format_in;
  BOOLEAN old_reloading;
  BOOLEAN old_cache_setting;
  
  format_in = HTAtom_for("text/html");
  pHVar3 = HTOutputFormat;
  target = (HTStream *)0x0;
  buf = (char *)0x0;
  tmp = (LYMapElement *)0x0;
  theMap = (LYImageMap *)0x0;
  MapTitle = (char *)0x0;
  MapAddress = (char *)0x0;
  cur = (HTList *)0x0;
  address = (char *)0x0;
  cp = (char *)0x0;
  old_cache_setting = LYforce_no_cache;
  old_reloading = reloading;
  iVar5 = strncasecomp(arg,"LYNXIMGMAP:",0xb);
  if (iVar5 == 0) {
    address = arg + 0xb;
  }
  if ((address == (char *)0x0) || (pcVar6 = strchr(address,0x3a), pcVar6 == (char *)0x0)) {
    pcVar6 = (char *)gettext("Misdirected client-side image MAP request!");
    HTAlert(pcVar6);
    return -29999;
  }
  theList = get_the_list(&WWWDoc,address,anAnchor,&underlying);
  if (WWWDoc.safe != '\0') {
    anAnchor->safe = '\x01';
  }
  if (theList == (HTList *)0x0) {
    if ((anAnchor->post_data != (bstring *)0x0) && (WWWDoc.safe == '\0')) {
      if ((underlying != (HTParentAnchor *)0x0) &&
         ((underlying->document != (HyperDoc *)0x0 && (LYforce_no_cache == '\0')))) {
LAB_080e4698:
        pcVar6 = (char *)gettext("Image map from POST response not available!");
        HTAlert(pcVar6);
        return -29999;
      }
      pcVar6 = (char *)gettext("Document from Form with POST content.  Resubmit?");
      BVar4 = HTConfirm(pcVar6);
      if (BVar4 != '\x01') goto LAB_080e4698;
    }
    LYforce_no_cache = '\x01';
    reloading = '\x01';
    HTOutputFormat = HTAtom_for("www/present");
    LYMapsOnly = '\x01';
    BVar4 = HTLoadAbsolute(&WWWDoc);
    if (BVar4 == '\0') {
      LYforce_no_cache = old_cache_setting;
      reloading = old_reloading;
      LYMapsOnly = '\0';
      HTOutputFormat = pHVar3;
      pcVar6 = (char *)gettext("Client-side image MAP is not accessible!");
      HTAlert(pcVar6);
      return -29999;
    }
    LYforce_no_cache = old_cache_setting;
    reloading = old_reloading;
    LYMapsOnly = '\0';
    HTOutputFormat = pHVar3;
    theList = get_the_list(&WWWDoc,address,anAnchor,&underlying);
  }
  if (theList == (HTList *)0x0) {
    pcVar6 = (char *)gettext("No client-side image MAPs are available!");
    HTAlert(pcVar6);
    return -29999;
  }
  cur = theList;
  do {
    if ((cur == (HTList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
      local_70 = (LYImageMap *)0x0;
    }
    else {
      local_70 = (LYImageMap *)cur->object;
    }
    theMap = local_70;
  } while ((local_70 != (LYImageMap *)0x0) &&
          (iVar5 = strcmp(local_70->address,address), iVar5 != 0));
  if ((theMap != (LYImageMap *)0x0) && (iVar5 = HTList_count(theMap->elements), iVar5 == 0)) {
    if (anAnchor->post_data == (bstring *)0x0) {
      HTSACopy(&redirecting_url,address);
      return 399;
    }
    if ((WWWDoc.safe != '\0') ||
       (((underlying->document != (HyperDoc *)0x0 && (anAnchor->document == (HyperDoc *)0x0)) &&
        ((LYinternal_flag != '\0' || (LYoverride_no_cache != '\0')))))) {
      HTSACopy(&redirecting_url,address);
      redirect_post_content = '\x01';
      return 399;
    }
  }
  if ((theMap == (LYImageMap *)0x0) || (theMap->elements == (HTList *)0x0)) {
    if ((anAnchor->post_data != (bstring *)0x0) && (WWWDoc.safe == '\0')) {
      if (((underlying != (HTParentAnchor *)0x0) && (underlying->document != (HyperDoc *)0x0)) &&
         (LYforce_no_cache == '\0')) {
LAB_080e48e5:
        pcVar6 = (char *)gettext("Image map from POST response not available!");
        HTAlert(pcVar6);
        return -29999;
      }
      pcVar6 = (char *)gettext("Document from Form with POST content.  Resubmit?");
      BVar4 = HTConfirm(pcVar6);
      if (BVar4 != '\x01') goto LAB_080e48e5;
    }
    LYforce_no_cache = '\x01';
    reloading = '\x01';
    HTOutputFormat = HTAtom_for("www/present");
    LYMapsOnly = '\x01';
    BVar4 = HTLoadAbsolute(&WWWDoc);
    if (BVar4 == '\0') {
      LYforce_no_cache = old_cache_setting;
      reloading = old_reloading;
      LYMapsOnly = '\0';
      HTOutputFormat = pHVar3;
      pcVar6 = (char *)gettext("Client-side image MAP is not accessible!");
      HTAlert(pcVar6);
      return -29999;
    }
    LYforce_no_cache = old_cache_setting;
    reloading = old_reloading;
    LYMapsOnly = '\0';
    HTOutputFormat = pHVar3;
    cur = get_the_list(&WWWDoc,address,anAnchor,&underlying);
    do {
      if ((cur == (HTList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
        local_6c = (LYImageMap *)0x0;
      }
      else {
        local_6c = (LYImageMap *)cur->object;
      }
      theMap = local_6c;
    } while ((local_6c != (LYImageMap *)0x0) &&
            (iVar5 = strcmp(local_6c->address,address), iVar5 != 0));
    if ((theMap == (LYImageMap *)0x0) || (theMap->elements == (HTList *)0x0)) {
      pcVar6 = (char *)gettext("Client-side image MAP is not available!");
      HTAlert(pcVar6);
      return -29999;
    }
  }
  anAnchor->no_cache = '\x01';
  target = (HTStream *)HTStreamStack(format_in,format_out,(HTStream_conflict4 *)sink,anAnchor);
  if (((HTStream_conflict4 *)target != (HTStream_conflict4 *)0x0) &&
     ((HTStream_conflict4 *)target != (HTStream_conflict4 *)0x0)) {
    if ((theMap->title == (char *)0x0) || (*theMap->title == '\0')) {
      if ((anAnchor->title == (char *)0x0) || (*anAnchor->title == '\0')) {
        if (((LYRequestTitle == (char *)0x0) || (*LYRequestTitle == '\0')) ||
           (iVar5 = strcasecomp(LYRequestTitle,"[USEMAP]"), iVar5 == 0)) {
          cp = strchr(address,0x23);
          if (cp != (char *)0x0) {
            HTSACopy(&MapTitle,cp + 1);
          }
        }
        else {
          HTSACopy(&MapTitle,LYRequestTitle);
        }
      }
      else {
        HTSACopy(&MapTitle,anAnchor->title);
      }
    }
    else {
      HTSACopy(&MapTitle,theMap->title);
    }
    if ((MapTitle == (char *)0x0) || (*MapTitle == '\0')) {
      HTSACopy(&MapTitle,"[USEMAP]");
    }
    else {
      LYEntify(&MapTitle,'\x01');
    }
    HTSprintf0(&buf,"<html>\n<head>\n");
    p_Var2 = target->isa->put_block;
    wVar7 = strlen(buf);
    (*p_Var2)(target,buf,wVar7);
    HTSprintf0(&buf,"<META %s content=\"text/html;charset=%s\">\n","http-equiv=\"content-type\"",
               LYCharSet_UC[current_char_set].MIMEname);
    p_Var2 = target->isa->put_block;
    wVar7 = strlen(buf);
    (*p_Var2)(target,buf,wVar7);
    HTSprintf0(&buf,"<title>%s</title>\n",MapTitle);
    p_Var2 = target->isa->put_block;
    wVar7 = strlen(buf);
    (*p_Var2)(target,buf,wVar7);
    HTSprintf0(&buf,"</head>\n<body>\n");
    p_Var2 = target->isa->put_block;
    wVar7 = strlen(buf);
    (*p_Var2)(target,buf,wVar7);
    HTSprintf0(&buf,"<h1><em>%s</em></h1>\n",MapTitle);
    p_Var2 = target->isa->put_block;
    wVar7 = strlen(buf);
    (*p_Var2)(target,buf,wVar7);
    HTSACopy(&MapAddress,address);
    LYEntify(&MapAddress,'\0');
    HTSprintf0(&buf,"<h2><em>MAP:</em>&nbsp;%s</h2>\n",MapAddress);
    p_Var2 = target->isa->put_block;
    wVar7 = strlen(buf);
    (*p_Var2)(target,buf,wVar7);
    if (keypad_mode == 0) {
      local_68 = &DAT_0816def0;
    }
    else {
      local_68 = &DAT_0816def3;
    }
    HTSprintf0(&buf,"<%s compact>\n",local_68);
    p_Var2 = target->isa->put_block;
    wVar7 = strlen(buf);
    (*p_Var2)(target,buf,wVar7);
    cur = theMap->elements;
    while( true ) {
      if ((cur == (HTList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
        local_64 = (LYMapElement *)0x0;
      }
      else {
        local_64 = (LYMapElement *)cur->object;
      }
      tmp = local_64;
      if (local_64 == (LYMapElement *)0x0) break;
      HTSACopy(&MapAddress,local_64->address);
      LYEntify(&MapAddress,'\0');
      (*target->isa->put_block)(target,"<li><a href=\"",L'\r');
      p_Var2 = target->isa->put_block;
      wVar7 = strlen(MapAddress);
      (*p_Var2)(target,MapAddress,wVar7);
      (*target->isa->put_block)(target,"\"",L'\x01');
      (*target->isa->put_block)(target,"\n>",L'\x02');
      LYformTitle(&MapTitle,tmp->title);
      LYEntify(&MapTitle,'\x01');
      p_Var2 = target->isa->put_block;
      wVar7 = strlen(MapTitle);
      (*p_Var2)(target,MapTitle,wVar7);
      (*target->isa->put_block)(target,"</a>\n",L'\x05');
    }
    if (keypad_mode == 0) {
      local_60 = &DAT_0816def0;
    }
    else {
      local_60 = &DAT_0816def3;
    }
    HTSprintf0(&buf,"</%s>\n</body>\n</html>\n",local_60);
    p_Var2 = target->isa->put_block;
    wVar7 = strlen(buf);
    (*p_Var2)(target,buf,wVar7);
    (*target->isa->_free)(target);
    if (MapAddress != (char *)0x0) {
      free(MapAddress);
      MapAddress = (char *)0x0;
    }
    if (MapTitle != (char *)0x0) {
      free(MapTitle);
      MapTitle = (char *)0x0;
    }
    if (buf != (char *)0x0) {
      free(buf);
    }
    return 200;
  }
  pcVar6 = format_out->name;
  pcVar1 = format_in->name;
  fmt = (char *)gettext("Sorry, no known way of converting %s to %s.");
  HTSprintf0(&buf,fmt,pcVar1,pcVar6);
  HTAlert(buf);
  if (buf != (char *)0x0) {
    free(buf);
  }
  return -29999;
}



// WARNING: Unknown calling convention

void LYPrintImgMaps(FILE *fp)

{
  char *__s;
  size_t __n;
  int iVar1;
  char *local_30;
  undefined4 *local_2c;
  char **local_28;
  int count;
  LYMapElement *elt;
  LYImageMap *map;
  HTList *inner;
  HTList *outer;
  int only_len;
  char *only;
  
  __s = HTLoadedDocumentURL();
  __n = strlen(__s);
  outer = LynxMaps;
  iVar1 = HTList_count(LynxMaps);
  if (0 < iVar1) {
    while( true ) {
      if ((outer == (HTList *)0x0) || (outer = outer->next, outer == (HTList *)0x0)) {
        local_28 = (char **)0x0;
      }
      else {
        local_28 = (char **)outer->object;
      }
      if (local_28 == (char **)0x0) break;
      if ((__n == 0) ||
         ((iVar1 = strncmp(__s,*local_28,__n), iVar1 == 0 &&
          (((*local_28)[__n] == '\0' || ((*local_28)[__n] == '#')))))) {
        if ((local_28[1] == (char *)0x0) || (*local_28[1] == '\0')) {
          local_30 = "[USEMAP]";
        }
        else {
          local_30 = local_28[1];
        }
        fprintf((FILE *)fp,"\n%s\n",local_30);
        fprintf((FILE *)fp,"%s\n",*local_28);
        inner = (HTList *)local_28[2];
        count = 0;
        while( true ) {
          if ((inner == (HTList *)0x0) || (inner = inner->next, inner == (HTList *)0x0)) {
            local_2c = (undefined4 *)0x0;
          }
          else {
            local_2c = (undefined4 *)inner->object;
          }
          if (local_2c == (undefined4 *)0x0) break;
          count = count + 1;
          fprintf((FILE *)fp,"%4d. %s",count,*local_2c);
          fputc(10,(FILE *)fp);
        }
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

void MemAllocCopy(char **dest,char *start,char *end)

{
  char *dst;
  char *temp;
  
  if (((start == (char *)0x0) || (end == (char *)0x0)) || (end <= start)) {
    HTSACopy(dest,"");
  }
  else {
    dst = (char *)calloc((size_t)(end + (1 - (int)start)),1);
    if (dst == (char *)0x0) {
      outofmem("./LYCookie.c","MemAllocCopy");
    }
    LYstrncpy(dst,start,(int)end - (int)start);
    HTSACopy(dest,dst);
    if (dst != (char *)0x0) {
      free(dst);
    }
  }
  return;
}



// WARNING: Unknown calling convention

cookie * newCookie(void)

{
  cookie *pstr;
  cookie *p;
  
  pstr = (cookie *)calloc(1,0x38);
  if (pstr == (cookie *)0x0) {
    outofmem("./LYCookie.c","newCookie");
  }
  HTSprintf0((char **)pstr,"%p",pstr);
  pstr->port = 0x50;
  return pstr;
}



// WARNING: Unknown calling convention

void freeCookie(cookie *co)

{
  if (co != (cookie *)0x0) {
    if (co->lynxID != (char *)0x0) {
      free(co->lynxID);
      co->lynxID = (char *)0x0;
    }
    if (co->name != (char *)0x0) {
      free(co->name);
      co->name = (char *)0x0;
    }
    if (co->value != (char *)0x0) {
      free(co->value);
      co->value = (char *)0x0;
    }
    if (co->comment != (char *)0x0) {
      free(co->comment);
      co->comment = (char *)0x0;
    }
    if (co->commentURL != (char *)0x0) {
      free(co->commentURL);
      co->commentURL = (char *)0x0;
    }
    if (co->domain != (char *)0x0) {
      free(co->domain);
      co->domain = (char *)0x0;
    }
    if (co->path != (char *)0x0) {
      free(co->path);
      co->path = (char *)0x0;
    }
    if (co->PortList != (char *)0x0) {
      free(co->PortList);
      co->PortList = (char *)0x0;
    }
    if (co != (cookie *)0x0) {
      free(co);
    }
  }
  return;
}



// WARNING: Unknown calling convention

BOOLEAN host_matches(char *A,char *B)

{
  int iVar1;
  size_t sVar2;
  size_t sVar3;
  int diff;
  
  if ((*B != '.') && (iVar1 = strcasecomp(A,B), iVar1 == 0)) {
    return '\x01';
  }
  if ((((*B == '.') && (B[1] != '\0')) && (B[1] != '.')) && (*A != '.')) {
    sVar2 = strlen(A);
    sVar3 = strlen(B);
    if ((0 < (int)(sVar2 - sVar3)) && (iVar1 = strcasecomp(A + (sVar2 - sVar3),B), iVar1 == 0)) {
      return '\x01';
    }
  }
  return '\0';
}



// WARNING: Unknown calling convention

BOOLEAN port_matches(int port,char *list)

{
  ushort **ppuVar1;
  int iVar2;
  char *number;
  
  number = list;
  if ((list != (char *)0x0) && (ppuVar1 = __ctype_b_loc(), ((*ppuVar1)[(byte)*list] & 0x800) != 0))
  {
    while (*number != '\0') {
      iVar2 = atoi(number);
      if (iVar2 == port) {
        return '\x01';
      }
      while (ppuVar1 = __ctype_b_loc(), ((*ppuVar1)[(byte)*number] & 0x800) != 0) {
        number = number + 1;
      }
      while ((*number != '\0' &&
             (ppuVar1 = __ctype_b_loc(), ((*ppuVar1)[(byte)*number] & 0x800) == 0))) {
        number = number + 1;
      }
    }
  }
  return '\0';
}



// WARNING: Unknown calling convention

int ignore_trailing_slash(char *a)

{
  int len;
  
  for (len = strlen(a); (1 < len && (a[len + -1] == '/')); len = len + -1) {
  }
  return len;
}



// WARNING: Unknown calling convention

BOOLEAN is_prefix(char *a,char *b)

{
  size_t __n;
  int iVar1;
  int iVar2;
  BOOLEAN local_15;
  int len_b;
  int len_a;
  
  __n = ignore_trailing_slash(a);
  iVar1 = ignore_trailing_slash(b);
  if (iVar1 < (int)__n) {
    local_15 = '\0';
  }
  else {
    iVar2 = strncmp(a,b,__n);
    if (iVar2 == 0) {
      if ((((int)__n < iVar1) && (((1 < (int)__n || (*a != '/')) && (b[__n] != '\0')))) &&
         (b[__n] != '/')) {
        local_15 = '\0';
      }
      else {
        local_15 = '\x01';
      }
    }
    else {
      local_15 = '\0';
    }
  }
  return local_15;
}



// WARNING: Unknown calling convention

domain_entry * find_domain_entry(char *name)

{
  invcheck_behaviour_t iVar1;
  behaviour_t bVar2;
  char *pcVar3;
  int iVar4;
  FILE *pFVar5;
  invcheck_behaviour_t local_28;
  behaviour_t local_24;
  domain_entry *de;
  HTList *hl;
  
  de = (domain_entry *)0x0;
  if ((name != (char *)0x0) && (*name != '\0')) {
    for (hl = domain_list; de = (domain_entry *)0x0, hl != (HTList *)0x0; hl = hl->next) {
      de = (domain_entry *)hl->object;
      if ((de != (domain_entry *)0x0) && (de->domain != (char *)0x0)) {
        if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
          iVar1 = de->invcheck_bv;
          bVar2 = de->bv;
          pcVar3 = de->domain;
          pFVar5 = TraceFP();
          fprintf((FILE *)pFVar5,"...test_domain_entry(%s) bv:%u, invcheck_bv:%u\n",pcVar3,bVar2,
                  iVar1);
        }
        iVar4 = strcasecomp(name,de->domain);
        if (iVar4 == 0) break;
      }
    }
  }
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
    if (de == (domain_entry *)0x0) {
      local_28 = ~INVCHECK_QUERY;
      local_24 = ~ACCEPT_ALWAYS;
    }
    else {
      local_28 = de->invcheck_bv;
      local_24 = de->bv;
    }
    pFVar5 = TraceFP();
    fprintf((FILE *)pFVar5,"find_domain_entry(%s) bv:%d, invcheck_bv:%d\n",name,local_24,local_28);
  }
  return de;
}



// WARNING: Unknown calling convention

void store_cookie(cookie *co,char *hostname,char *path)

{
  BOOLEAN BVar1;
  int iVar2;
  char *pcVar3;
  FILE *pFVar4;
  size_t sVar5;
  size_t sVar6;
  char *pcVar7;
  wchar_t wVar8;
  HTList *pHVar9;
  invcheck_behaviour_t local_40;
  invcheck_behaviour_t local_3c;
  char *msg;
  invcheck_behaviour_t invcheck_bv_1;
  invcheck_behaviour_t invcheck_bv;
  int invprompt_reasons;
  domain_entry *de;
  char *ptr;
  int pos;
  time_t now;
  cookie *c2;
  HTList *next;
  HTList *hl;
  BOOLEAN Replacement;
  
  now = time((time_t *)0x0);
  de = (domain_entry *)0x0;
  Replacement = '\0';
  invprompt_reasons = 0;
  if (co == (cookie *)0x0) {
    return;
  }
  if (domain_list == (HTList *)0x0) {
    domain_list = HTList_new();
    total_cookies = 0;
  }
  cookie_list = (HTList *)0x0;
  de = find_domain_entry(co->domain);
  if (de != (domain_entry *)0x0) {
    cookie_list = de->cookie_list;
  }
  BVar1 = is_prefix(co->path,path);
  if (BVar1 == '\0') {
    if (de == (domain_entry *)0x0) {
      local_40 = INVCHECK_QUERY;
    }
    else {
      local_40 = de->invcheck_bv;
    }
    invcheck_bv = local_40;
    if (local_40 == INVCHECK_STRICT) {
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
        pcVar3 = co->path;
        pFVar4 = TraceFP();
        fprintf((FILE *)pFVar4,"store_cookie: Rejecting because \'%s\' is not a prefix of \'%s\'.\n"
                ,pcVar3,path);
      }
      freeCookie(co);
      return;
    }
    if (local_40 == INVCHECK_QUERY) {
      invprompt_reasons = invprompt_reasons | 1;
    }
  }
  iVar2 = strcasecomp(co->domain,hostname);
  if (iVar2 != 0) {
    pcVar3 = strchr(hostname,0x2e);
    if (pcVar3 == (char *)0x0) {
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
        pFVar4 = TraceFP();
        fprintf((FILE *)pFVar4,"store_cookie: Rejecting because \'%s\' has no dot.\n",hostname);
      }
      freeCookie(co);
      return;
    }
    if ((*co->domain != '.') || (co->domain[1] == '\0')) {
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
        pcVar3 = co->domain;
        pFVar4 = TraceFP();
        fprintf((FILE *)pFVar4,"store_cookie: Rejecting domain \'%s\'.\n",pcVar3);
      }
      freeCookie(co);
      return;
    }
    ptr = strchr(co->domain + 1,0x2e);
    if ((ptr == (char *)0x0) || (ptr[1] == '\0')) {
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
        pcVar3 = co->domain;
        pFVar4 = TraceFP();
        fprintf((FILE *)pFVar4,"store_cookie: Rejecting domain \'%s\'.\n",pcVar3);
      }
      freeCookie(co);
      return;
    }
    BVar1 = host_matches(hostname,co->domain);
    if (BVar1 == '\0') {
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
        pcVar3 = co->domain;
        pFVar4 = TraceFP();
        fprintf((FILE *)pFVar4,"store_cookie: Rejecting domain \'%s\' for host \'%s\'.\n",pcVar3,
                hostname);
      }
      freeCookie(co);
      return;
    }
    sVar5 = strlen(hostname);
    sVar6 = strlen(co->domain);
    ptr = hostname + (sVar5 - sVar6);
    pcVar3 = strchr(hostname,0x2e);
    if (pcVar3 < ptr) {
      if (de == (domain_entry *)0x0) {
        local_3c = INVCHECK_QUERY;
      }
      else {
        local_3c = de->invcheck_bv;
      }
      invcheck_bv_1 = local_3c;
      if (local_3c == INVCHECK_STRICT) {
        if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
          pcVar3 = co->path;
          pFVar4 = TraceFP();
          fprintf((FILE *)pFVar4,
                  "store_cookie: Rejecting because \'%s\' is not a prefix of \'%s\'.\n",pcVar3,path)
          ;
        }
        freeCookie(co);
        return;
      }
      if (local_3c == INVCHECK_QUERY) {
        invprompt_reasons = invprompt_reasons | 2;
      }
    }
  }
  if (invprompt_reasons != 0) {
    msg = (char *)0x0;
    if ((invprompt_reasons & 2U) != 0) {
      pcVar3 = co->domain;
      pcVar7 = (char *)gettext("Accept invalid cookie domain=%s for \'%s\'?");
      HTSprintf0(&msg,pcVar7,pcVar3,hostname);
      wVar8 = HTForcedPrompt(cookie_noprompt,msg,L'\0');
      if (wVar8 == L'\0') {
        if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
          pcVar3 = co->domain;
          pFVar4 = TraceFP();
          fprintf((FILE *)pFVar4,"store_cookie: Rejecting domain \'%s\' for host \'%s\'.\n",pcVar3,
                  hostname);
        }
        freeCookie(co);
        if (msg == (char *)0x0) {
          return;
        }
        free(msg);
        return;
      }
    }
    if ((invprompt_reasons & 1U) != 0) {
      pcVar3 = co->path;
      pcVar7 = (char *)gettext("Accept invalid cookie path=%s as a prefix of \'%s\'?");
      HTSprintf0(&msg,pcVar7,pcVar3,path);
      wVar8 = HTForcedPrompt(cookie_noprompt,msg,L'\0');
      if (wVar8 == L'\0') {
        if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
          pcVar3 = co->path;
          pFVar4 = TraceFP();
          fprintf((FILE *)pFVar4,
                  "store_cookie: Rejecting because \'%s\' is not a prefix of \'%s\'.\n",pcVar3,path)
          ;
        }
        freeCookie(co);
        if (msg == (char *)0x0) {
          return;
        }
        free(msg);
        return;
      }
    }
    if (msg != (char *)0x0) {
      free(msg);
      msg = (char *)0x0;
    }
  }
  if (de == (domain_entry *)0x0) {
    de = (domain_entry *)calloc(1,0x10);
    if (de == (domain_entry *)0x0) {
      outofmem("./LYCookie.c","store_cookie");
    }
    de->bv = QUERY_USER;
    de->invcheck_bv = INVCHECK_QUERY;
    pHVar9 = HTList_new();
    de->cookie_list = pHVar9;
    cookie_list = de->cookie_list;
    HTSACopy(&de->domain,co->domain);
    HTList_appendObject(domain_list,de);
  }
  pos = 0;
  hl = cookie_list;
  while (hl != (HTList *)0x0) {
    c2 = (cookie *)hl->object;
    next = hl->next;
    if (((c2 == (cookie *)0x0) || ((c2->flags & 4U) == 0)) || (now < c2->expires)) {
      if (((c2 == (cookie *)0x0) || (iVar2 = strcasecomp(co->domain,c2->domain), iVar2 != 0)) ||
         ((iVar2 = strcmp(co->path,c2->path), iVar2 != 0 ||
          (iVar2 = strcmp(co->name,c2->name), iVar2 != 0)))) {
        if ((c2 != (cookie *)0x0) && (co->pathlen <= c2->pathlen)) {
          pos = pos + 1;
        }
      }
      else {
        HTList_removeObject(cookie_list,c2);
        freeCookie(c2);
        c2 = (cookie *)0x0;
        total_cookies = total_cookies + -1;
        Replacement = '\x01';
      }
    }
    else {
      HTList_removeObject(cookie_list,c2);
      freeCookie(c2);
      c2 = (cookie *)0x0;
      total_cookies = total_cookies + -1;
    }
    hl = next;
  }
  if (((co->flags & 4U) == 0) || (now < co->expires)) {
    iVar2 = HTList_count(cookie_list);
    if (max_cookies_domain < iVar2) {
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
        pFVar4 = TraceFP();
        fprintf((FILE *)pFVar4,"store_cookie: Domain\'s cookie limit exceeded!  Rejecting cookie.\n"
               );
      }
      freeCookie(co);
    }
    else if (max_cookies_global < total_cookies) {
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
        pFVar4 = TraceFP();
        fprintf((FILE *)pFVar4,"store_cookie: Total cookie limit exceeded!  Rejecting cookie.\n");
      }
      freeCookie(co);
    }
    else if (co->value == (char *)0x0) {
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
        pFVar4 = TraceFP();
        fprintf((FILE *)pFVar4,"store_cookie: Value is NULL! Not storing cookie.\n");
      }
      freeCookie(co);
    }
    else if (((Replacement == '\x01') && (de != (domain_entry *)0x0)) && (de->bv != REJECT_ALWAYS))
    {
      HTList_insertObjectAt(cookie_list,co,pos);
      total_cookies = total_cookies + 1;
    }
    else if (((co->flags & 0x20U) == 0) &&
            (BVar1 = HTConfirmCookie(de,hostname,co->name,co->value), BVar1 == '\0')) {
      freeCookie(co);
    }
    else {
      HTList_insertObjectAt(cookie_list,co,pos);
      total_cookies = total_cookies + 1;
    }
  }
  else {
    freeCookie(co);
  }
  return;
}



char * scan_cookie_sublist(char *hostname,char *path,int port,HTList *sublist,char *header,
                          BOOLEAN secure)

{
  int iVar1;
  BOOLEAN BVar2;
  char *pcVar3;
  FILE *pFVar4;
  size_t sVar5;
  size_t sVar6;
  ushort **ppuVar7;
  int in_GS_OFFSET;
  char *local_58;
  char *local_54;
  char *local_50;
  undefined4 local_4c;
  char *local_40;
  BOOLEAN secure_local;
  char *header_local;
  HTList *sublist_local;
  char *path_local;
  char *hostname_local;
  int len;
  time_t now;
  cookie *co;
  HTList *next;
  HTList *hl;
  char crlftab [8];
  
  hostname_local = hostname;
  path_local = path;
  sublist_local = sublist;
  header_local = header;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  hl = sublist;
  next = (HTList *)0x0;
  now = time((time_t *)0x0);
  len = 0;
  sprintf(crlftab,"%c%c%c",0xd,10,9);
LAB_080e6647:
  do {
    if (hl == (HTList *)0x0) {
      if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
        __stack_chk_fail();
      }
      return header_local;
    }
    co = (cookie *)hl->object;
    next = hl->next;
    if (co != (cookie *)0x0) {
      pcVar3 = LYstrstr(hostname_local,co->domain);
      if (pcVar3 != (char *)0x0) {
        if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
          if (co->value == (char *)0x0) {
            local_58 = "(no value)";
          }
          else {
            local_58 = co->value;
          }
          if (co->name == (char *)0x0) {
            local_54 = "(no name)";
          }
          else {
            local_54 = co->name;
          }
          pFVar4 = TraceFP();
          fprintf((FILE *)pFVar4,"Checking cookie %p %s=%s\n",hl,local_54,local_58);
        }
        if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
          if ((co->flags & 1U) == 0) {
            local_50 = "";
          }
          else {
            local_50 = " secure";
          }
          if (co->pathlen < 1) {
LAB_080e624e:
            local_4c = 0;
          }
          else {
            BVar2 = is_prefix(co->path,path_local);
            if (BVar2 != '\0') goto LAB_080e624e;
            local_4c = 1;
          }
          pcVar3 = co->path;
          BVar2 = host_matches(hostname_local,co->domain);
          if (co->domain == (char *)0x0) {
            local_40 = "(no domain)";
          }
          else {
            local_40 = co->domain;
          }
          pFVar4 = TraceFP();
          fprintf((FILE *)pFVar4,"\t%s %s %d %s %s %d%s\n",hostname_local,local_40,(int)BVar2,
                  path_local,pcVar3,local_4c,local_50);
        }
      }
    }
    if (((co != (cookie *)0x0) && ((co->flags & 4U) != 0)) && (co->expires <= now)) {
      HTList_removeObject(sublist_local,co);
      freeCookie(co);
      co = (cookie *)0x0;
      total_cookies = total_cookies + -1;
    }
    if (co != (cookie *)0x0) {
      BVar2 = host_matches(hostname_local,co->domain);
      if (BVar2 != '\0') {
        if (co->pathlen != 0) {
          BVar2 = is_prefix(co->path,path_local);
          if (BVar2 == '\0') goto LAB_080e6641;
        }
        if (((co->flags & 1U) != 0) && (secure == '\0')) {
          hl = next;
          goto LAB_080e6647;
        }
        if (co->PortList != (char *)0x0) {
          BVar2 = port_matches(port,co->PortList);
          if (BVar2 == '\0') {
            hl = next;
            goto LAB_080e6647;
          }
        }
        if (header_local == (char *)0x0) {
          if (0 < co->version) {
            HTSprintf0(&header_local,"$Version=\"%d\"; ",co->version);
            sVar5 = strlen(header_local);
            len = sVar5 + len;
          }
        }
        else {
          HTSACat(&header_local,"; ");
        }
        HTSACat(&header_local,co->name);
        HTSACat(&header_local,"=");
        if (co->quoted != '\0') {
          HTSACat(&header_local,"\"");
          len = len + 1;
        }
        HTSACat(&header_local,co->value);
        if (co->quoted != '\0') {
          HTSACat(&header_local,"\"");
          len = len + 1;
        }
        sVar5 = strlen(co->name);
        sVar6 = strlen(co->value);
        len = sVar5 + sVar6 + len + 1;
        if (0 < co->version) {
          if ((co->path != (char *)0x0) && ((co->flags & 0x10U) != 0)) {
            HTSACat(&header_local,"; $Path=\"");
            HTSACat(&header_local,co->path);
            HTSACat(&header_local,"\"");
            sVar5 = strlen(co->path);
            len = sVar5 + len + 10;
          }
          if (co->PortList != (char *)0x0) {
            ppuVar7 = __ctype_b_loc();
            if (((*ppuVar7)[(byte)*co->PortList] & 0x800) != 0) {
              HTSACat(&header_local,"; $Port=\"");
              HTSACat(&header_local,co->PortList);
              HTSACat(&header_local,"\"");
              sVar5 = strlen(co->PortList);
              len = sVar5 + len + 10;
            }
          }
          if ((co->domain != (char *)0x0) && ((co->flags & 8U) != 0)) {
            HTSACat(&header_local,"; $Domain=\"");
            HTSACat(&header_local,co->domain);
            HTSACat(&header_local,"\"");
            sVar5 = strlen(co->domain);
            len = sVar5 + len + 0xc;
          }
        }
      }
    }
LAB_080e6641:
    hl = next;
  } while( true );
}



// WARNING: Unknown calling convention

char * alloc_attr_value(char *value_start,char *value_end)

{
  int value_len;
  char *value;
  
  value = (char *)0x0;
  if ((value_start != (char *)0x0) && (value_start <= value_end)) {
    value_len = (int)value_end - (int)value_start;
    if (max_cookies_buffer < value_len) {
      value_len = max_cookies_buffer;
    }
    value = (char *)calloc(value_len + 1,1);
    if (value == (char *)0x0) {
      outofmem("./LYCookie.c","LYProcessSetCookies");
    }
    LYstrncpy(value,value_start,value_len);
  }
  return value;
}



// WARNING: Unknown calling convention

uint parse_attribute(uint flags,cookie *cur_cookie,int *cookie_len,char *attr_start,int attr_len,
                    char *value,char *address,char *hostname,int port)

{
  uint uVar1;
  bool bVar2;
  BOOLEAN BVar3;
  int iVar4;
  size_t sVar5;
  char *pcVar6;
  UrlTypes UVar7;
  FILE *pFVar8;
  ushort **ppuVar9;
  long lVar10;
  int *piVar11;
  time_t tVar12;
  time_t tVar13;
  int temp_1;
  int temp;
  char *cp;
  char *ptr;
  int url_type;
  BOOLEAN known_attr;
  
  bVar2 = false;
  uVar1 = flags & 0xfffffffd;
  if (attr_len == 6) {
    iVar4 = strncasecomp(attr_start,"secure",6);
    if (iVar4 == 0) {
      if (value == (char *)0x0) {
        bVar2 = true;
        if (cur_cookie != (cookie *)0x0) {
          cur_cookie->flags = cur_cookie->flags | 1;
        }
      }
      else {
        bVar2 = false;
      }
      goto LAB_080e700e;
    }
  }
  if (attr_len == 7) {
    iVar4 = strncasecomp(attr_start,"discard",7);
    if (iVar4 == 0) {
      if (value == (char *)0x0) {
        bVar2 = true;
        if (cur_cookie != (cookie *)0x0) {
          cur_cookie->flags = cur_cookie->flags | 2;
        }
      }
      else {
        bVar2 = false;
      }
      goto LAB_080e700e;
    }
  }
  if (attr_len == 7) {
    iVar4 = strncasecomp(attr_start,"comment",7);
    if (iVar4 == 0) {
      bVar2 = true;
      if (((cur_cookie != (cookie *)0x0) && (value != (char *)0x0)) &&
         (cur_cookie->comment == (char *)0x0)) {
        HTSACopy(&cur_cookie->comment,value);
        iVar4 = *cookie_len;
        sVar5 = strlen(cur_cookie->comment);
        *cookie_len = iVar4 + sVar5;
      }
      goto LAB_080e700e;
    }
  }
  if (attr_len == 10) {
    iVar4 = strncasecomp(attr_start,"commentURL",10);
    if (iVar4 == 0) {
      bVar2 = true;
      if (((cur_cookie != (cookie *)0x0) && (value != (char *)0x0)) &&
         (cur_cookie->commentURL == (char *)0x0)) {
        pcVar6 = HTParse(value,address,0x1f);
        cur_cookie->commentURL = pcVar6;
        UVar7 = is_url(cur_cookie->commentURL);
        if ((UVar7 == NOT_A_URL_TYPE) || ((UVar7 != HTTP_URL_TYPE && (UVar7 != HTTPS_URL_TYPE)))) {
          if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
            pcVar6 = cur_cookie->commentURL;
            pFVar8 = TraceFP();
            fprintf((FILE *)pFVar8,"LYProcessSetCookies: Rejecting commentURL value \'%s\'\n",pcVar6
                   );
          }
          if (cur_cookie->commentURL != (char *)0x0) {
            free(cur_cookie->commentURL);
            cur_cookie->commentURL = (char *)0x0;
          }
        }
        else {
          iVar4 = *cookie_len;
          sVar5 = strlen(cur_cookie->commentURL);
          *cookie_len = iVar4 + sVar5;
        }
      }
      goto LAB_080e700e;
    }
  }
  if (attr_len == 6) {
    iVar4 = strncasecomp(attr_start,"domain",6);
    if (iVar4 == 0) {
      bVar2 = true;
      if (((cur_cookie == (cookie *)0x0) || (value == (char *)0x0)) ||
         ((cur_cookie->flags & 8U) != 0)) goto LAB_080e700e;
      iVar4 = *cookie_len;
      sVar5 = strlen(cur_cookie->domain);
      *cookie_len = iVar4 - sVar5;
      if (((*value != '.') && (*value != '\0')) && (value[1] != '\0')) {
        iVar4 = strcasecomp(value,hostname);
        if (iVar4 != 0) {
          pcVar6 = strchr(value,0x2e);
          if ((pcVar6 != (char *)0x0) && (pcVar6[1] != '\0')) {
            ptr = value;
            do {
              if (*ptr != '.') {
                ppuVar9 = __ctype_b_loc();
                if (((*ppuVar9)[(byte)*ptr] & 0x800) == 0) goto code_r0x080e6a85;
              }
              ptr = ptr + 1;
            } while( true );
          }
          HTSACopy(&cur_cookie->domain,value);
          goto LAB_080e6b34;
        }
      }
      HTSACopy(&cur_cookie->domain,value);
      goto LAB_080e6b34;
    }
  }
  if (attr_len == 4) {
    iVar4 = strncasecomp(attr_start,"path",4);
    if (iVar4 == 0) {
      bVar2 = true;
      if (((cur_cookie != (cookie *)0x0) && (value != (char *)0x0)) &&
         ((cur_cookie->flags & 0x10U) == 0)) {
        iVar4 = *cookie_len;
        sVar5 = strlen(cur_cookie->path);
        *cookie_len = iVar4 - sVar5;
        HTSACopy(&cur_cookie->path,value);
        iVar4 = *cookie_len;
        sVar5 = strlen(cur_cookie->path);
        cur_cookie->pathlen = sVar5;
        *cookie_len = iVar4 + cur_cookie->pathlen;
        cur_cookie->flags = cur_cookie->flags | 0x10;
      }
      goto LAB_080e700e;
    }
  }
  if (attr_len == 4) {
    iVar4 = strncasecomp(attr_start,"port",4);
    if (iVar4 == 0) {
      if (((cur_cookie == (cookie *)0x0) || (value == (char *)0x0)) ||
         (cur_cookie->PortList != (char *)0x0)) {
        if (cur_cookie != (cookie *)0x0) {
          if (cur_cookie->PortList == (char *)0x0) {
            HTSprintf0(&cur_cookie->PortList,"%d",port);
            iVar4 = *cookie_len;
            sVar5 = strlen(cur_cookie->PortList);
            *cookie_len = iVar4 + sVar5;
          }
          bVar2 = true;
        }
      }
      else {
        for (cp = value; *cp != '\0'; cp = cp + 1) {
          ppuVar9 = __ctype_b_loc();
          if (((((*ppuVar9)[(byte)*cp] & 0x800) == 0) && (*cp != ',')) && (*cp != ' ')) break;
        }
        if (*cp == '\0') {
          BVar3 = port_matches(port,value);
          if (BVar3 == '\0') {
            flags = uVar1 | 1;
          }
          else {
            HTSACopy(&cur_cookie->PortList,value);
            iVar4 = *cookie_len;
            sVar5 = strlen(cur_cookie->PortList);
            *cookie_len = iVar4 + sVar5;
            flags = uVar1;
          }
          bVar2 = true;
          uVar1 = flags;
        }
        else {
          bVar2 = false;
        }
      }
      goto LAB_080e700e;
    }
  }
  if (attr_len == 7) {
    iVar4 = strncasecomp(attr_start,"version",7);
    if (iVar4 == 0) {
      bVar2 = true;
      if (((cur_cookie != (cookie *)0x0) && (value != (char *)0x0)) && (cur_cookie->version < 1)) {
        lVar10 = strtol(value,(char **)0x0,10);
        piVar11 = __errno_location();
        if (*piVar11 != -0x22) {
          cur_cookie->version = lVar10;
        }
      }
      goto LAB_080e700e;
    }
  }
  if (attr_len == 7) {
    iVar4 = strncasecomp(attr_start,"max-age",7);
    if (iVar4 == 0) {
      bVar2 = true;
      if (((cur_cookie != (cookie *)0x0) && (value != (char *)0x0)) && ((flags & 4) == 0)) {
        lVar10 = strtol(value,(char **)0x0,10);
        cur_cookie->flags = cur_cookie->flags | 4;
        piVar11 = __errno_location();
        if (*piVar11 == -0x22) {
          cur_cookie->expires = 0;
        }
        else {
          tVar12 = time((time_t *)0x0);
          cur_cookie->expires = tVar12 + lVar10;
          if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
            pcVar6 = ctime(&cur_cookie->expires);
            tVar13 = cur_cookie->expires;
            pFVar8 = TraceFP();
            fprintf((FILE *)pFVar8,"LYSetCookie: expires %d, %s",tVar13,pcVar6);
          }
        }
        uVar1 = uVar1 | 4;
      }
      goto LAB_080e700e;
    }
  }
  if (attr_len == 7) {
    iVar4 = strncasecomp(attr_start,"expires",7);
    if ((((iVar4 == 0) && (bVar2 = true, cur_cookie != (cookie *)0x0)) && ((flags & 4) == 0)) &&
       (((cur_cookie->flags & 4U) == 0 && (value != (char *)0x0)))) {
      cur_cookie->flags = cur_cookie->flags | 4;
      tVar13 = LYmktime(value,'\0');
      cur_cookie->expires = tVar13;
      if ((0 < cur_cookie->expires) && ((WWW_TraceFlag != '\0' && ((WWW_TraceMask & 0x20U) != 0))))
      {
        pcVar6 = ctime(&cur_cookie->expires);
        tVar13 = cur_cookie->expires;
        pFVar8 = TraceFP();
        fprintf((FILE *)pFVar8,"LYSetCookie: expires %d, %s",tVar13,pcVar6);
      }
    }
  }
  goto LAB_080e700e;
code_r0x080e6a85:
  if (*ptr == '\0') {
    HTSACopy(&cur_cookie->domain,value);
  }
  else {
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
      pFVar8 = TraceFP();
      fprintf((FILE *)pFVar8,"LYProcessSetCookies: Adding lead dot for domain value \'%s\'\n",value)
      ;
    }
    HTSACopy(&cur_cookie->domain,".");
    HTSACat(&cur_cookie->domain,value);
  }
LAB_080e6b34:
  iVar4 = *cookie_len;
  sVar5 = strlen(cur_cookie->domain);
  *cookie_len = iVar4 + sVar5;
  cur_cookie->flags = cur_cookie->flags | 8;
LAB_080e700e:
  flags = uVar1;
  if (bVar2) {
    flags = flags | 2;
  }
  return flags;
}



// WARNING: Unknown calling convention

void LYProcessSetCookies(char *SetCookie,char *SetCookie2,char *address,char *hostname,char *path,
                        int port)

{
  time_t tVar1;
  FILE *pFVar2;
  ushort **ppuVar3;
  byte *pbVar4;
  size_t sVar5;
  char *pcVar6;
  int iVar7;
  char *local_cc;
  BOOLEAN local_c8;
  char *local_c4;
  char *local_c0;
  char *local_bc;
  char *local_b8;
  char *local_b4;
  char *local_b0;
  char *local_ac;
  char *local_a8;
  char *local_a4;
  char *local_a0;
  char *local_9c;
  BOOLEAN local_98;
  char *local_94;
  char *local_90;
  char *local_8c;
  char *local_88;
  char *local_84;
  char *local_80;
  char *local_7c;
  char *local_78;
  char *local_74;
  cookie *local_70;
  char *value_1;
  char *cp1_1;
  char *cp_1;
  int spaces_1;
  char *value;
  char *cp1;
  char *cp;
  int spaces;
  uint parse_flags;
  int NumCookies;
  int cookie_len;
  cookie *co;
  cookie *cur_cookie;
  HTList *cl;
  HTList *CombinedCookies;
  char *value_end;
  char *value_start;
  char *attr_end;
  char *attr_start;
  char *p;
  BOOLEAN escaped_1;
  BOOLEAN escaped;
  BOOLEAN Quoted;
  
  CombinedCookies = (HTList *)0x0;
  cl = (HTList *)0x0;
  cur_cookie = (cookie *)0x0;
  co = (cookie *)0x0;
  cookie_len = 0;
  NumCookies = 0;
  Quoted = '\0';
  parse_flags = 0;
  if (((SetCookie != (char *)0x0) && (*SetCookie != '\0')) ||
     ((SetCookie2 != (char *)0x0 && (*SetCookie2 != '\0')))) {
    CombinedCookies = HTList_new();
    if (SetCookie2 == (char *)0x0) {
      local_cc = "";
    }
    else {
      local_cc = SetCookie2;
    }
    p = local_cc;
    if ((((SetCookie != (char *)0x0) && (*local_cc != '\0')) && (WWW_TraceFlag != '\0')) &&
       ((WWW_TraceMask & 0x20U) != 0)) {
      pFVar2 = TraceFP();
      fprintf((FILE *)pFVar2,"LYProcessSetCookies: Using Set-Cookie2 header.\n");
    }
    while ((NumCookies <= max_cookies_domain && (*p != '\0'))) {
      value_end = (char *)0x0;
      value_start = (char *)0x0;
      attr_end = (char *)0x0;
      attr_start = (char *)0x0;
      attr_start = LYSkipCBlanks(p);
      p = attr_start;
      while (((*p != '\0' && (ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[(byte)*p] & 0x2000) == 0)) &&
             ((*p != '=' && ((*p != ';' && (*p != ','))))))) {
        p = p + 1;
      }
      attr_end = p;
      p = LYSkipCBlanks(p);
      if ((*p == '=') || (iVar7 = strncasecomp(attr_start,"Expires",7), iVar7 == 0)) {
        if (*p == '=') {
          p = p + 1;
        }
        p = LYSkipCBlanks(p);
        if (((int)attr_end - (int)attr_start == 7) &&
           (iVar7 = strncasecomp(attr_start,"Expires",7), iVar7 == 0)) {
          value_start = p;
          ppuVar3 = __ctype_b_loc();
          if (((*ppuVar3)[(byte)*p] & 0x800) == 0) {
            while ((*p != '\0' && (ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[(byte)*p] & 0x400) != 0)))
            {
              p = p + 1;
            }
            while ((*p == ',' || (ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[(byte)*p] & 0x2000) != 0)))
            {
              p = p + 1;
            }
            spaces = 5;
          }
          else {
            spaces = 5;
          }
          while ((((*p != '\0' && (*p != ';')) && (*p != ',')) && (spaces != 0))) {
            p = p + 1;
            ppuVar3 = __ctype_b_loc();
            if (((*ppuVar3)[(byte)*p] & 0x2000) == 0) {
              if (*p == '-') {
                spaces = spaces + -1;
              }
            }
            else {
              while (ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[(byte)p[1]] & 0x2000) != 0) {
                p = p + 1;
              }
              spaces = spaces + -1;
            }
          }
          value_end = p;
        }
        else if (((int)attr_end - (int)attr_start == 4) &&
                ((iVar7 = strncasecomp(attr_start,"port",4), iVar7 == 0 &&
                 (ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[(byte)*p] & 0x800) != 0)))) {
          value_start = p;
          pbVar4 = (byte *)p;
          do {
            while (p = (char *)pbVar4, ppuVar3 = __ctype_b_loc(),
                  ((*ppuVar3)[(byte)*p] & 0x800) != 0) {
              pbVar4 = (byte *)(p + 1);
            }
            value_end = p;
            p = LYSkipCBlanks(p);
            if ((*p == '\0') || (*p == ';')) goto LAB_080e771a;
            if ((*p != ',') ||
               ((pbVar4 = (byte *)LYSkipCBlanks(p + 1), *pbVar4 == 0 ||
                (ppuVar3 = __ctype_b_loc(), cp1 = (char *)pbVar4, ((*ppuVar3)[*pbVar4] & 0x800) == 0
                )))) break;
            while (ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[(byte)*cp1] & 0x800) != 0) {
              cp1 = cp1 + 1;
            }
            pcVar6 = LYSkipCBlanks(cp1);
          } while (((*pcVar6 == '\0') || (*pcVar6 == ',')) || (*pcVar6 == ';'));
          for (; ((*p != '\0' && (*p != ';')) && (*p != ',')); p = p + 1) {
          }
          value_end = p;
          if ((value_start < p) &&
             (ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[(byte)value_end[-1]] & 0x2000) != 0)) {
            while (value_end = value_end + -1, value_start + 1 < value_end) {
              ppuVar3 = __ctype_b_loc();
              if ((((*ppuVar3)[(byte)*value_end] & 0x2000) == 0) ||
                 (ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[(byte)value_end[-1]] & 0x2000) == 0))
              break;
            }
          }
        }
        else {
          pcVar6 = p;
          if (*p == '\"') {
            value_start = p + 1;
            escaped = '\0';
            p = value_start;
            while ((*p != '\0' && ((*p != '\"' || (escaped != '\0'))))) {
              if ((escaped == '\0') && (*p == '\\')) {
                local_c8 = '\x01';
              }
              else {
                local_c8 = '\0';
              }
              p = p + 1;
              escaped = local_c8;
            }
            if (((p == value_start) || (*p != '\"')) || (escaped != '\0')) {
              value_start = pcVar6;
              value_end = p;
              if (*p != '\0') {
                p = p + 1;
              }
              Quoted = '\0';
            }
            else {
              value_end = p;
              p = p + 1;
              Quoted = '\x01';
            }
          }
          else {
            value_start = p;
            for (; ((*p != '\0' && (*p != ';')) && (*p != ',')); p = p + 1) {
            }
            value_end = p;
            if ((pcVar6 < p) &&
               (ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[(byte)value_end[-1]] & 0x2000) != 0)) {
              while (value_end = value_end + -1, value_start + 1 < value_end) {
                ppuVar3 = __ctype_b_loc();
                if ((((*ppuVar3)[(byte)*value_end] & 0x2000) == 0) ||
                   (ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[(byte)value_end[-1]] & 0x2000) == 0))
                break;
              }
            }
          }
        }
      }
LAB_080e771a:
      if ((*p == ';') || (*p == ',')) {
        p = p + 1;
      }
      if (attr_start < attr_end) {
        pcVar6 = alloc_attr_value(value_start,value_end);
        local_c0 = (char *)&cookie_len;
        local_c4 = attr_start;
        parse_flags = parse_attribute(parse_flags,cur_cookie,(int *)local_c0,attr_start,
                                      (int)attr_end - (int)attr_start,pcVar6,address,hostname,port);
        if ((((parse_flags & 2) == 0) && (pcVar6 != (char *)0x0)) && (value_start <= value_end)) {
          if (((max_cookies_buffer < cookie_len) || (cur_cookie == (cookie *)0x0)) ||
             ((parse_flags & 1) != 0)) {
            if (cur_cookie != (cookie *)0x0) {
              if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
                if (cur_cookie->value == (char *)0x0) {
                  local_c4 = "[no value]";
                }
                else {
                  local_c4 = cur_cookie->value;
                }
                if (cur_cookie->name == (char *)0x0) {
                  local_c0 = "[no name]";
                }
                else {
                  local_c0 = cur_cookie->name;
                }
                pFVar2 = TraceFP();
                fprintf((FILE *)pFVar2,"LYProcessSetCookies: Rejecting Set-Cookie2: %s=%s\n",
                        local_c0,local_c4);
              }
              if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
                if ((parse_flags & 1) == 0) {
                  local_bc = "                     due to invalid port!\n";
                }
                else {
                  local_bc = "                     due to excessive length!\n";
                }
                pFVar2 = TraceFP();
                fprintf((FILE *)pFVar2,local_bc,local_c0,local_c4);
              }
              if ((parse_flags & 1) != 0) {
                NumCookies = NumCookies + -1;
              }
              freeCookie(cur_cookie);
              cur_cookie = (cookie *)0x0;
            }
          }
          else {
            if (cur_cookie->version < 1) {
              cur_cookie->version = 1;
            }
            HTList_appendObject(CombinedCookies,cur_cookie);
          }
          cur_cookie = newCookie();
          cookie_len = 0;
          NumCookies = NumCookies + 1;
          MemAllocCopy(&cur_cookie->name,attr_start,attr_end);
          sVar5 = strlen(cur_cookie->name);
          cookie_len = sVar5 + cookie_len;
          MemAllocCopy(&cur_cookie->value,value_start,value_end);
          sVar5 = strlen(cur_cookie->value);
          cookie_len = sVar5 + cookie_len;
          HTSACopy(&cur_cookie->domain,hostname);
          sVar5 = strlen(cur_cookie->domain);
          cookie_len = sVar5 + cookie_len;
          HTSACopy(&cur_cookie->path,path);
          sVar5 = strlen(cur_cookie->path);
          cur_cookie->pathlen = sVar5;
          cookie_len = cur_cookie->pathlen + cookie_len;
          cur_cookie->port = port;
          parse_flags = 0;
          cur_cookie->quoted = '\x01';
        }
        if (pcVar6 != (char *)0x0) {
          free(pcVar6);
        }
      }
    }
    if ((((max_cookies_domain < NumCookies) || (max_cookies_buffer < cookie_len)) ||
        (cur_cookie == (cookie *)0x0)) || ((parse_flags & 1) != 0)) {
      if ((cur_cookie == (cookie *)0x0) || ((parse_flags & 1) != 0)) {
        if (cur_cookie != (cookie *)0x0) {
          if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
            if (cur_cookie->value == (char *)0x0) {
              local_a4 = "[no value]";
            }
            else {
              local_a4 = cur_cookie->value;
            }
            if (cur_cookie->name == (char *)0x0) {
              local_a0 = "[no name]";
            }
            else {
              local_a0 = cur_cookie->name;
            }
            pFVar2 = TraceFP();
            fprintf((FILE *)pFVar2,"LYProcessSetCookies: Rejecting Set-Cookie2: %s=%s\n",local_a0,
                    local_a4);
          }
          if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
            pFVar2 = TraceFP();
            fprintf((FILE *)pFVar2,"                     due to invalid port!\n");
          }
          freeCookie(cur_cookie);
        }
      }
      else {
        if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
          if (cur_cookie->value == (char *)0x0) {
            local_b8 = "[no value]";
          }
          else {
            local_b8 = cur_cookie->value;
          }
          if (cur_cookie->name == (char *)0x0) {
            local_b4 = "[no name]";
          }
          else {
            local_b4 = cur_cookie->name;
          }
          pFVar2 = TraceFP();
          fprintf((FILE *)pFVar2,"LYProcessSetCookies: Rejecting Set-Cookie2: %s=%s\n",local_b4,
                  local_b8);
        }
        if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
          if (max_cookies_domain < NumCookies) {
            local_b0 = "number!\n";
          }
          else {
            local_b0 = "!\n";
          }
          if ((max_cookies_buffer < cookie_len) && (max_cookies_domain < NumCookies)) {
            local_ac = " and ";
          }
          else {
            local_ac = "";
          }
          if (max_cookies_buffer < cookie_len) {
            local_a8 = "length";
          }
          else {
            local_a8 = "";
          }
          pFVar2 = TraceFP();
          fprintf((FILE *)pFVar2,"                     due to excessive %s%s%s\n",local_a8,local_ac,
                  local_b0);
        }
        freeCookie(cur_cookie);
      }
    }
    else {
      if (cur_cookie->version < 1) {
        cur_cookie->version = 1;
      }
      HTList_appendObject(CombinedCookies,cur_cookie);
    }
    cookie_len = 0;
    NumCookies = 0;
    cur_cookie = (cookie *)0x0;
    if ((SetCookie == (char *)0x0) || ((SetCookie2 != (char *)0x0 && (*SetCookie2 != '\0')))) {
      local_9c = "";
    }
    else {
      local_9c = SetCookie;
    }
    p = local_9c;
    if ((((SetCookie2 != (char *)0x0) && (*local_9c != '\0')) && (WWW_TraceFlag != '\0')) &&
       ((WWW_TraceMask & 0x20U) != 0)) {
      pFVar2 = TraceFP();
      fprintf((FILE *)pFVar2,"LYProcessSetCookies: Using Set-Cookie header.\n");
    }
    while ((NumCookies <= max_cookies_domain && (*p != '\0'))) {
      value_end = (char *)0x0;
      value_start = (char *)0x0;
      attr_end = (char *)0x0;
      attr_start = (char *)0x0;
      attr_start = LYSkipCBlanks(p);
      p = attr_start;
      while (((*p != '\0' && (ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[(byte)*p] & 0x2000) == 0)) &&
             ((*p != '=' && ((*p != ';' && (*p != ','))))))) {
        p = p + 1;
      }
      attr_end = p;
      p = LYSkipCBlanks(p);
      if ((*p == '=') || (iVar7 = strncasecomp(attr_start,"Expires",7), iVar7 == 0)) {
        if (*p == '=') {
          p = p + 1;
        }
        p = LYSkipCBlanks(p);
        if (((int)attr_end - (int)attr_start == 7) &&
           (iVar7 = strncasecomp(attr_start,"Expires",7), iVar7 == 0)) {
          value_start = p;
          ppuVar3 = __ctype_b_loc();
          if (((*ppuVar3)[(byte)*p] & 0x800) == 0) {
            while ((*p != '\0' && (ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[(byte)*p] & 0x400) != 0)))
            {
              p = p + 1;
            }
            while ((*p == ',' || (ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[(byte)*p] & 0x2000) != 0)))
            {
              p = p + 1;
            }
            spaces_1 = 5;
          }
          else {
            spaces_1 = 5;
          }
          while ((((*p != '\0' && (*p != ';')) && (*p != ',')) && (spaces_1 != 0))) {
            p = p + 1;
            ppuVar3 = __ctype_b_loc();
            if (((*ppuVar3)[(byte)*p] & 0x2000) == 0) {
              if (*p == '-') {
                spaces_1 = spaces_1 + -1;
              }
            }
            else {
              while (ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[(byte)p[1]] & 0x2000) != 0) {
                p = p + 1;
              }
              spaces_1 = spaces_1 + -1;
            }
          }
          value_end = p;
        }
        else if (((int)attr_end - (int)attr_start == 4) &&
                ((iVar7 = strncasecomp(attr_start,"port",4), iVar7 == 0 &&
                 (ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[(byte)*p] & 0x800) != 0)))) {
          value_start = p;
          pbVar4 = (byte *)p;
          do {
            while (p = (char *)pbVar4, ppuVar3 = __ctype_b_loc(),
                  ((*ppuVar3)[(byte)*p] & 0x800) != 0) {
              pbVar4 = (byte *)(p + 1);
            }
            value_end = p;
            p = LYSkipCBlanks(p);
            if ((*p == '\0') || (*p == ';')) goto LAB_080e837e;
            if ((*p != ',') ||
               ((pbVar4 = (byte *)LYSkipCBlanks(p + 1), *pbVar4 == 0 ||
                (ppuVar3 = __ctype_b_loc(), cp1_1 = (char *)pbVar4,
                ((*ppuVar3)[*pbVar4] & 0x800) == 0)))) break;
            while (ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[(byte)*cp1_1] & 0x800) != 0) {
              cp1_1 = cp1_1 + 1;
            }
            pcVar6 = LYSkipCBlanks(cp1_1);
          } while (((*pcVar6 == '\0') || (*pcVar6 == ',')) || (*pcVar6 == ';'));
          for (; ((*p != '\0' && (*p != ';')) && (*p != ',')); p = p + 1) {
          }
          value_end = p;
          if ((value_start < p) &&
             (ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[(byte)value_end[-1]] & 0x2000) != 0)) {
            while (value_end = value_end + -1, value_start + 1 < value_end) {
              ppuVar3 = __ctype_b_loc();
              if ((((*ppuVar3)[(byte)*value_end] & 0x2000) == 0) ||
                 (ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[(byte)value_end[-1]] & 0x2000) == 0))
              break;
            }
          }
        }
        else {
          pcVar6 = p;
          if (*p == '\"') {
            value_start = p + 1;
            escaped_1 = '\0';
            p = value_start;
            while ((*p != '\0' && ((*p != '\"' || (escaped_1 != '\0'))))) {
              if ((escaped_1 == '\0') && (*p == '\\')) {
                local_98 = '\x01';
              }
              else {
                local_98 = '\0';
              }
              p = p + 1;
              escaped_1 = local_98;
            }
            if (((p == value_start) || (*p != '\"')) || (escaped_1 != '\0')) {
              value_start = pcVar6;
              value_end = p;
              if (*p != '\0') {
                p = p + 1;
              }
              Quoted = '\0';
            }
            else {
              value_end = p;
              p = p + 1;
              Quoted = '\x01';
            }
          }
          else {
            value_start = p;
            for (; ((*p != '\0' && (*p != ';')) && (*p != ',')); p = p + 1) {
            }
            value_end = p;
            if ((pcVar6 < p) &&
               (ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[(byte)value_end[-1]] & 0x2000) != 0)) {
              while (value_end = value_end + -1, value_start + 1 < value_end) {
                ppuVar3 = __ctype_b_loc();
                if ((((*ppuVar3)[(byte)*value_end] & 0x2000) == 0) ||
                   (ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[(byte)value_end[-1]] & 0x2000) == 0))
                break;
              }
            }
          }
        }
      }
LAB_080e837e:
      if ((*p == ';') || (*p == ',')) {
        p = p + 1;
      }
      if (attr_start < attr_end) {
        pcVar6 = alloc_attr_value(value_start,value_end);
        local_90 = (char *)&cookie_len;
        local_94 = attr_start;
        parse_flags = parse_attribute(parse_flags,cur_cookie,(int *)local_90,attr_start,
                                      (int)attr_end - (int)attr_start,pcVar6,address,hostname,port);
        if ((((parse_flags & 2) == 0) && (pcVar6 != (char *)0x0)) && (value_start <= value_end)) {
          if ((max_cookies_buffer < cookie_len) || (cur_cookie == (cookie *)0x0)) {
            if (cur_cookie != (cookie *)0x0) {
              if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
                if (cur_cookie->value == (char *)0x0) {
                  local_94 = "[no value]";
                }
                else {
                  local_94 = cur_cookie->value;
                }
                if (cur_cookie->name == (char *)0x0) {
                  local_90 = "[no name]";
                }
                else {
                  local_90 = cur_cookie->name;
                }
                pFVar2 = TraceFP();
                fprintf((FILE *)pFVar2,"LYProcessSetCookies: Rejecting Set-Cookie: %s=%s\n",local_90
                        ,local_94);
              }
              if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
                pFVar2 = TraceFP();
                fprintf((FILE *)pFVar2,"                     due to excessive length!\n",local_90,
                        local_94);
              }
              freeCookie(cur_cookie);
              cur_cookie = (cookie *)0x0;
            }
          }
          else {
            if (SetCookie2 != (char *)0x0) {
              if (cur_cookie->version < 1) {
                cur_cookie->version = 1;
              }
              cur_cookie->quoted = '\x01';
            }
            HTList_appendObject(CombinedCookies,cur_cookie);
          }
          cur_cookie = newCookie();
          NumCookies = NumCookies + 1;
          cookie_len = 0;
          MemAllocCopy(&cur_cookie->name,attr_start,attr_end);
          sVar5 = strlen(cur_cookie->name);
          cookie_len = sVar5 + cookie_len;
          MemAllocCopy(&cur_cookie->value,value_start,value_end);
          sVar5 = strlen(cur_cookie->value);
          cookie_len = sVar5 + cookie_len;
          HTSACopy(&cur_cookie->domain,hostname);
          sVar5 = strlen(cur_cookie->domain);
          cookie_len = sVar5 + cookie_len;
          HTSACopy(&cur_cookie->path,path);
          sVar5 = strlen(cur_cookie->path);
          cur_cookie->pathlen = sVar5;
          cookie_len = cur_cookie->pathlen + cookie_len;
          cur_cookie->port = port;
          parse_flags = 0;
          cur_cookie->quoted = Quoted;
          Quoted = '\0';
        }
        if (pcVar6 != (char *)0x0) {
          free(pcVar6);
        }
      }
    }
    if (((max_cookies_domain < NumCookies) || (max_cookies_buffer < cookie_len)) ||
       (cur_cookie == (cookie *)0x0)) {
      if (cur_cookie != (cookie *)0x0) {
        if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
          if (cur_cookie->value == (char *)0x0) {
            local_8c = "[no value]";
          }
          else {
            local_8c = cur_cookie->value;
          }
          if (cur_cookie->name == (char *)0x0) {
            local_88 = "[no name]";
          }
          else {
            local_88 = cur_cookie->name;
          }
          pFVar2 = TraceFP();
          fprintf((FILE *)pFVar2,"LYProcessSetCookies: Rejecting Set-Cookie: %s=%s\n",local_88,
                  local_8c);
        }
        if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
          if (max_cookies_domain < NumCookies) {
            local_84 = "number!\n";
          }
          else {
            local_84 = "!\n";
          }
          if ((max_cookies_buffer < cookie_len) && (max_cookies_domain < NumCookies)) {
            local_80 = " and ";
          }
          else {
            local_80 = "";
          }
          if (max_cookies_buffer < cookie_len) {
            local_7c = "length";
          }
          else {
            local_7c = "";
          }
          pFVar2 = TraceFP();
          fprintf((FILE *)pFVar2,"                     due to excessive %s%s%s\n",local_7c,local_80,
                  local_84);
        }
        freeCookie(cur_cookie);
        cur_cookie = (cookie *)0x0;
      }
    }
    else {
      if (SetCookie2 != (char *)0x0) {
        if (cur_cookie->version < 1) {
          cur_cookie->version = 1;
        }
        cur_cookie->quoted = '\x01';
      }
      HTList_appendObject(CombinedCookies,cur_cookie);
    }
    cl = CombinedCookies;
    while( true ) {
      if ((cl == (HTList *)0x0) || (cl = cl->next, cl == (HTList *)0x0)) {
        local_70 = (cookie *)0x0;
      }
      else {
        local_70 = (cookie *)cl->object;
      }
      co = local_70;
      if (local_70 == (cookie *)0x0) break;
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
        if (local_70->value == (char *)0x0) {
          local_78 = "[no value]";
        }
        else {
          local_78 = local_70->value;
        }
        if (local_70->name == (char *)0x0) {
          local_74 = "[no name]";
        }
        else {
          local_74 = local_70->name;
        }
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2,"LYProcessSetCookie: attr=value pair: \'%s=%s\'\n",local_74,local_78)
        ;
      }
      if (((0 < co->expires) && (WWW_TraceFlag != '\0')) && ((WWW_TraceMask & 0x20U) != 0)) {
        pcVar6 = ctime(&co->expires);
        tVar1 = co->expires;
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2,"                    expires: %d, %s\n",tVar1,pcVar6);
      }
      iVar7 = strncasecomp(address,"https:",6);
      if (((iVar7 == 0) && (LYForceSSLCookiesSecure == '\x01')) &&
         (((co->flags & 1U) == 0 &&
          ((co->flags = co->flags | 1, WWW_TraceFlag != '\0' && ((WWW_TraceMask & 0x20U) != 0))))))
      {
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2,"                    Forced the \'secure\' flag on.\n");
      }
      store_cookie(co,hostname,path);
    }
    HTList_delete(CombinedCookies);
  }
  return;
}



// WARNING: Unknown calling convention

void LYSetCookie(char *SetCookie,char *SetCookie2,char *address)

{
  bool bVar1;
  char *__s;
  char *pcVar2;
  int iVar3;
  char *pcVar4;
  FILE *pFVar5;
  char *local_2c;
  char *local_28;
  int port;
  char *ptr;
  char *path;
  char *hostname;
  BOOLEAN BadHeaders;
  
  bVar1 = false;
  port = 0x50;
  __s = HTParse(address,"",8);
  if ((__s == (char *)0x0) || (pcVar2 = strchr(__s,0x3a), pcVar2 == (char *)0x0)) {
    iVar3 = strncasecomp(address,"https:",6);
    if (iVar3 == 0) {
      port = 0x1bb;
    }
  }
  else {
    *pcVar2 = '\0';
    port = atoi(pcVar2 + 1);
  }
  local_28 = (char *)0x5;
  pcVar2 = HTParse(address,"",5);
  if ((pcVar2 != (char *)0x0) && (pcVar4 = strrchr(pcVar2,0x2f), pcVar4 != (char *)0x0)) {
    if (pcVar4 == pcVar2) {
      pcVar4[1] = '\0';
    }
    else {
      *pcVar4 = '\0';
    }
  }
  if (((SetCookie == (char *)0x0) || (*SetCookie == '\0')) &&
     ((SetCookie2 == (char *)0x0 || (*SetCookie2 == '\0')))) {
    bVar1 = true;
  }
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
    local_2c = pcVar2;
    if (pcVar2 == (char *)0x0) {
      local_2c = "";
    }
    local_28 = __s;
    if (__s == (char *)0x0) {
      local_28 = "";
    }
    pFVar5 = TraceFP();
    fprintf((FILE *)pFVar5,"LYSetCookie called with host \'%s\', path \'%s\',\n",local_28,local_2c);
  }
  if (((SetCookie != (char *)0x0) && (WWW_TraceFlag != '\0')) && ((WWW_TraceMask & 0x20U) != 0)) {
    pFVar5 = TraceFP();
    local_28 = SetCookie;
    fprintf((FILE *)pFVar5,"    and Set-Cookie: \'%s\'\n",SetCookie);
  }
  if (((SetCookie2 != (char *)0x0) && (WWW_TraceFlag != '\0')) && ((WWW_TraceMask & 0x20U) != 0)) {
    pFVar5 = TraceFP();
    local_28 = SetCookie2;
    fprintf((FILE *)pFVar5,"    and Set-Cookie2: \'%s\'\n",SetCookie2);
  }
  if (((LYSetCookies == '\0') || (bVar1)) &&
     ((WWW_TraceFlag != '\0' && ((WWW_TraceMask & 0x20U) != 0)))) {
    pFVar5 = TraceFP();
    fprintf((FILE *)pFVar5,"    Ignoring this Set-Cookie/Set-Cookie2 request.\n",local_28);
  }
  if ((LYSetCookies == '\0') || (bVar1)) {
    if (__s != (char *)0x0) {
      free(__s);
    }
    if (pcVar2 != (char *)0x0) {
      free(pcVar2);
    }
  }
  else {
    LYProcessSetCookies(SetCookie,SetCookie2,address,__s,pcVar2,port);
    if (__s != (char *)0x0) {
      free(__s);
    }
    if (pcVar2 != (char *)0x0) {
      free(pcVar2);
    }
  }
  return;
}



char * LYAddCookieHeader(char *hostname,char *path,int port,BOOLEAN secure)

{
  void **oldObject;
  FILE *__stream;
  char *local_24;
  char *local_20;
  char *local_1c;
  BOOLEAN secure_local;
  domain_entry *de;
  HTList *next;
  HTList *hl;
  char *header;
  
  header = (char *)0x0;
  hl = domain_list;
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
    if (path == (char *)0x0) {
      local_24 = "(null)";
    }
    else {
      local_24 = path;
    }
    if (hostname == (char *)0x0) {
      local_20 = "(null)";
    }
    else {
      local_20 = hostname;
    }
    __stream = TraceFP();
    fprintf((FILE *)__stream,"LYCookie: Searching for \'%s:%d\', \'%s\'.\n",local_20,port,local_24);
  }
  while (hl != (HTList *)0x0) {
    oldObject = (void **)hl->object;
    hl = hl->next;
    if (oldObject != (void **)0x0) {
      if ((oldObject[3] == (void *)0x0) || (*(int *)((int)oldObject[3] + 4) == 0)) {
        if ((oldObject[1] == (void *)0x2) && (oldObject[2] == (void *)0x0)) {
          if (*oldObject != (void *)0x0) {
            free(*oldObject);
            *oldObject = (void *)0x0;
          }
          HTList_delete((HTList *)oldObject[3]);
          oldObject[3] = (void *)0x0;
          HTList_removeObject(domain_list,oldObject);
          if (oldObject != (void **)0x0) {
            free(oldObject);
          }
        }
      }
      else {
        header = scan_cookie_sublist(hostname,path,port,(HTList *)oldObject[3],header,secure);
      }
    }
  }
  if (header == (char *)0x0) {
    local_1c = (char *)0x0;
  }
  else {
    local_1c = header;
  }
  return local_1c;
}



// WARNING: Unknown calling convention

void LYLoadCookies(char *cookie_file)

{
  FILE *pFVar1;
  size_t sVar2;
  char *pcVar3;
  int iVar4;
  undefined *__src;
  size_t __n;
  char *tok_ptr;
  char *tok_out;
  int tok_loop;
  cookie *moo;
  time_t expires;
  char *buf;
  FILE *cookie_handle;
  
  buf = (char *)0x0;
  cookie_handle = (FILE *)fopen64(cookie_file,"r");
  if (cookie_handle != (FILE *)0x0) {
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
      pFVar1 = TraceFP();
      fprintf((FILE *)pFVar1,"LYLoadCookies: reading cookies from %s\n",cookie_file);
    }
    number_of_file_cookies = 0;
    while( true ) {
      pcVar3 = LYSafeGets(&buf,cookie_handle);
      if (pcVar3 == (char *)0x0) break;
      LYTrimNewline(buf);
      pcVar3 = buf;
      if ((*buf != '\0') && (*buf != '#')) {
        number_of_file_cookies = number_of_file_cookies + 1;
        __n = 2;
        __src = &DAT_0816e678;
        sVar2 = strlen(buf);
        memcpy(pcVar3 + sVar2,__src,__n);
        pcVar3 = buf;
        if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
          pFVar1 = TraceFP();
          fprintf((FILE *)pFVar1,"LYLoadCookies: tokenising %s\n",pcVar3);
        }
        tok_ptr = buf;
        tok_out = LYstrsep(&tok_ptr,"\t");
        for (tok_loop = 0;
            (tok_out != (char *)0x0 && (LYLoadCookies::tok_values[tok_loop].s != (char *)0x0));
            tok_loop = tok_loop + 1) {
          if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
            iVar4 = (int)tok_out - (int)buf;
            pFVar1 = TraceFP();
            fprintf((FILE *)pFVar1,"\t%d:[%03d]:[%s]\n",tok_loop,iVar4,tok_out);
          }
          LYstrncpy(LYLoadCookies::tok_values[tok_loop].s,tok_out,
                    LYLoadCookies::tok_values[tok_loop].n);
          tok_out = LYstrsep(&tok_ptr,"\t");
        }
        if (LYLoadCookies::tok_values[tok_loop].s == (char *)0x0) {
          expires = atol(LYLoadCookies::expires_a);
          if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
            pcVar3 = ctime(&expires);
            pFVar1 = TraceFP();
            fprintf((FILE *)pFVar1,"expires:\t%s\n",pcVar3);
          }
          moo = newCookie();
          HTSACopy(&moo->domain,LYLoadCookies::domain);
          HTSACopy(&moo->path,LYLoadCookies::path);
          HTSACopy(&moo->name,LYLoadCookies::name);
          if ((LYLoadCookies::value[0] == '\"') && (LYLoadCookies::value[1] != '\0')) {
            sVar2 = strlen(LYLoadCookies::value);
            if ((&DAT_081b06df)[sVar2] != '\"') goto LAB_080e9178;
            sVar2 = strlen(LYLoadCookies::value);
            if ((&DAT_081b06de)[sVar2] == '\\') goto LAB_080e9178;
            sVar2 = strlen(LYLoadCookies::value);
            (&DAT_081b06df)[sVar2] = 0;
            HTSACopy(&moo->value,LYLoadCookies::value + 1);
            moo->quoted = '\x01';
          }
          else {
LAB_080e9178:
            HTSACopy(&moo->value,LYLoadCookies::value);
          }
          sVar2 = strlen(moo->path);
          moo->pathlen = sVar2;
          moo->flags = moo->flags | 0x34;
          if (LYLoadCookies::domain[0] == '.') {
            moo->flags = moo->flags | 8;
          }
          if (LYLoadCookies::secure[0] != 'F') {
            moo->flags = moo->flags | 1;
          }
          moo->expires = expires;
          store_cookie(moo,LYLoadCookies::domain,LYLoadCookies::path);
        }
        else if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
          pFVar1 = TraceFP();
          fprintf((FILE *)pFVar1,"*** wrong format: not enough tokens, ignoring line!\n");
        }
      }
    }
    LYCloseInput(cookie_handle);
  }
  return;
}



// WARNING: Unknown calling convention

FILE * NewCookieFile(char *cookie_file)

{
  FILE *pFVar1;
  
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
    pFVar1 = TraceFP();
    fprintf((FILE *)pFVar1,"LYStoreCookies: save cookies to %s on exit\n",cookie_file);
  }
  pFVar1 = LYNewTxtFile(cookie_file);
  return pFVar1;
}



// WARNING: Unknown calling convention

void LYStoreCookies(char *cookie_file)

{
  char **ppcVar1;
  void *pvVar2;
  time_t tVar3;
  int iVar4;
  FILE *pFVar5;
  char *pcVar6;
  undefined4 uVar7;
  undefined4 uVar8;
  undefined4 uVar9;
  undefined *local_48;
  undefined *local_44;
  undefined *local_40;
  char *local_34;
  char *local_2c;
  time_t now;
  FILE *cookie_handle;
  cookie *co;
  domain_entry *de;
  HTList *cl;
  HTList *dl;
  
  cookie_handle = (FILE *)0x0;
  tVar3 = time((time_t *)0x0);
  if ((((cookie_file != (char *)0x0) && (*cookie_file != '\0')) &&
      (iVar4 = strcmp(cookie_file,"/dev/null"), iVar4 != 0)) &&
     (((domain_list != (HTList *)0x0 && (domain_list->next != (HTList *)0x0)) ||
      (number_of_file_cookies != 0)))) {
    if ((number_of_file_cookies != 0) &&
       (cookie_handle = NewCookieFile(cookie_file), cookie_handle == (FILE *)0x0)) {
      return;
    }
    for (dl = domain_list; dl != (HTList *)0x0; dl = dl->next) {
      ppcVar1 = (char **)dl->object;
      if (ppcVar1 != (char **)0x0) {
        for (cl = (HTList *)ppcVar1[3]; cl != (HTList *)0x0; cl = cl->next) {
          pvVar2 = cl->object;
          if (pvVar2 != (void *)0x0) {
            if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
              uVar9 = *(undefined4 *)((int)pvVar2 + 0x30);
              pFVar5 = TraceFP();
              fprintf((FILE *)pFVar5,"LYStoreCookies: %d cf %d ",tVar3,uVar9);
            }
            if ((*(uint *)((int)pvVar2 + 0x2c) & 2) == 0) {
              if ((*(uint *)((int)pvVar2 + 0x2c) & 4) == 0) {
                if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
                  pFVar5 = TraceFP();
                  fprintf((FILE *)pFVar5,"not stored - no expiration time\n");
                }
              }
              else if (tVar3 < *(int *)((int)pvVar2 + 0x30)) {
                if ((cookie_handle == (FILE *)0x0) &&
                   (cookie_handle = NewCookieFile(cookie_file), cookie_handle == (FILE *)0x0)) {
                  return;
                }
                if (*(char *)((int)pvVar2 + 0x34) == '\0') {
                  local_48 = &DAT_0816df60;
                }
                else {
                  local_48 = &DAT_0816e24f;
                }
                if (*(int *)((int)pvVar2 + 8) == 0) {
                  local_44 = &DAT_0816df60;
                }
                else {
                  local_44 = *(undefined **)((int)pvVar2 + 8);
                }
                if (*(char *)((int)pvVar2 + 0x34) == '\0') {
                  local_40 = &DAT_0816df60;
                }
                else {
                  local_40 = &DAT_0816e24f;
                }
                uVar9 = *(undefined4 *)((int)pvVar2 + 4);
                uVar8 = *(undefined4 *)((int)pvVar2 + 0x30);
                if ((*(uint *)((int)pvVar2 + 0x2c) & 1) == 0) {
                  local_34 = "FALSE";
                }
                else {
                  local_34 = "TRUE";
                }
                uVar7 = *(undefined4 *)((int)pvVar2 + 0x24);
                if (**ppcVar1 == '.') {
                  local_2c = "TRUE";
                }
                else {
                  local_2c = "FALSE";
                }
                pcVar6 = *ppcVar1;
                fprintf((FILE *)cookie_handle,"%s\t%s\t%s\t%s\t%d\t%s\t%s%s%s\n",pcVar6,local_2c,
                        uVar7,local_34,uVar8,uVar9,local_40,local_44,local_48);
                if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
                  pFVar5 = TraceFP();
                  fprintf((FILE *)pFVar5,"STORED\n",pcVar6,local_2c,uVar7,local_34,uVar8,uVar9,
                          local_40,local_44,local_48);
                }
              }
              else if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
                pFVar5 = TraceFP();
                fprintf((FILE *)pFVar5,"not stored - EXPIRED\n");
              }
            }
            else if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
              pFVar5 = TraceFP();
              fprintf((FILE *)pFVar5,"not stored - DISCARD\n");
            }
          }
        }
      }
    }
    if (cookie_handle != (FILE *)0x0) {
      LYCloseOutput(cookie_handle);
    }
  }
  return;
}



// WARNING: Unknown calling convention

int LYHandleCookies(char *arg,HTParentAnchor *anAnchor,HTFormat format_out,HTStream *sink)

{
  _func_void_HTStream_ptr_char_ptr_wchar_t *p_Var1;
  behaviour_t bVar2;
  LYKeymap_t LVar3;
  BOOLEAN BVar4;
  char *pcVar5;
  int iVar6;
  wchar_t wVar7;
  char *pcVar8;
  char *pcVar9;
  undefined4 uVar10;
  undefined4 uVar11;
  char *pcVar12;
  int local_74;
  undefined *local_6c;
  undefined *local_68;
  undefined *local_64;
  char *local_60;
  int ch;
  char *Title;
  char *Address;
  char *comment;
  char *path;
  char *value;
  char *name;
  cookie *co;
  domain_entry *de;
  HTList *next;
  HTList *cl;
  HTList *dl;
  char *lynxID;
  char *domain;
  char *buf;
  HTStream *target;
  HTFormat format_in;
  
  format_in = HTAtom_for("text/html");
  target = (HTStream *)0x0;
  buf = (char *)0x0;
  domain = (char *)0x0;
  lynxID = (char *)0x0;
  name = (char *)0x0;
  value = (char *)0x0;
  path = (char *)0x0;
  comment = (char *)0x0;
  Address = (char *)0x0;
  Title = (char *)0x0;
  if ((domain_list == (HTList *)0x0) || (domain_list->next == (HTList *)0x0)) {
    pcVar5 = (char *)gettext("The Cookie Jar is empty.");
    HTProgress(pcVar5);
    LYSleepMsg();
    HTNoDataOK = 1;
    local_74 = -0xcc;
  }
  else {
    domain = HTParse(arg,"",8);
    if (domain != (char *)0x0) {
      if (*domain == '\0') {
        if (domain != (char *)0x0) {
          free(domain);
          domain = (char *)0x0;
        }
      }
      else {
        lynxID = HTParse(arg,"",4);
        if (((lynxID != (char *)0x0) && (*lynxID == '\0')) && (lynxID != (char *)0x0)) {
          free(lynxID);
          lynxID = (char *)0x0;
        }
      }
    }
    if (domain == (char *)0x0) {
      target = (HTStream *)HTStreamStack(format_in,format_out,(HTStream_conflict4 *)sink,anAnchor);
      if (((HTStream_conflict4 *)target == (HTStream_conflict4 *)0x0) ||
         ((HTStream_conflict4 *)target == (HTStream_conflict4 *)0x0)) {
        pcVar5 = format_out->name;
        pcVar8 = format_in->name;
        pcVar9 = (char *)gettext("Sorry, no known way of converting %s to %s.");
        HTSprintf0(&buf,pcVar9,pcVar8,pcVar5);
        HTAlert(buf);
        if (buf != (char *)0x0) {
          free(buf);
        }
        local_74 = -29999;
      }
      else {
        uVar10 = gettext("Cookie Jar");
        HTSprintf0(&buf,"<html>\n<head>\n<title>%s</title>\n</head>\n<body>\n",uVar10);
        p_Var1 = target->isa->put_block;
        wVar7 = strlen(buf);
        (*p_Var1)(target,buf,wVar7);
        uVar10 = gettext("Cookie Jar");
        pcVar5 = helpfilepath;
        uVar11 = gettext(", help on ");
        HTSprintf0(&buf,"<h1>%s (%s)%s<a href=\"%s%s\">%s</a></h1>\n",&DAT_0816ea71,"2.8.7dev.11",
                   uVar11,pcVar5,"Lynx_users_guide.html.gz#Cookies",uVar10);
        p_Var1 = target->isa->put_block;
        wVar7 = strlen(buf);
        (*p_Var1)(target,buf,wVar7);
        uVar10 = gettext("Activate links to gobble up cookies or entire domains,");
        HTSprintf0(&buf,"<note>%s\n",uVar10);
        p_Var1 = target->isa->put_block;
        wVar7 = strlen(buf);
        (*p_Var1)(target,buf,wVar7);
        uVar10 = gettext("or to change a domain\'s \'allow\' setting.");
        HTSprintf0(&buf,"%s</note>\n",uVar10);
        p_Var1 = target->isa->put_block;
        wVar7 = strlen(buf);
        (*p_Var1)(target,buf,wVar7);
        HTSprintf0(&buf,"<dl compact>\n");
        p_Var1 = target->isa->put_block;
        wVar7 = strlen(buf);
        (*p_Var1)(target,buf,wVar7);
        for (dl = domain_list; dl != (HTList *)0x0; dl = dl->next) {
          de = (domain_entry *)dl->object;
          if (de != (domain_entry *)0x0) {
            pcVar5 = de->domain;
            pcVar8 = de->domain;
            pcVar9 = "LYNXCOOKIE:";
            HTSprintf0(&buf,"<dt>%s<dd><a href=\"%s//%s/\">Domain=%s</a>\n",de->domain,"LYNXCOOKIE:"
                       ,pcVar8,pcVar5);
            p_Var1 = target->isa->put_block;
            wVar7 = strlen(buf);
            (*p_Var1)(target,buf,wVar7);
            bVar2 = de->bv;
            if (bVar2 == REJECT_ALWAYS) {
              pcVar12 = (char *)gettext("(Cookies never allowed.)");
              HTSprintf0(&buf,pcVar12,wVar7,pcVar9,pcVar8,pcVar5);
            }
            else if (bVar2 == ACCEPT_ALWAYS) {
              pcVar12 = (char *)gettext("(Cookies always allowed.)");
              HTSprintf0(&buf,pcVar12,wVar7,pcVar9,pcVar8,pcVar5);
            }
            else if (bVar2 == QUERY_USER) {
              pcVar12 = (char *)gettext("(Cookies allowed via prompt.)");
              HTSprintf0(&buf,pcVar12,wVar7,pcVar9,pcVar8,pcVar5);
            }
            p_Var1 = target->isa->put_block;
            wVar7 = strlen(buf);
            (*p_Var1)(target,buf,wVar7);
            HTSprintf0(&buf,"\n");
            p_Var1 = target->isa->put_block;
            wVar7 = strlen(buf);
            (*p_Var1)(target,buf,wVar7);
            for (cl = de->cookie_list; cl != (HTList *)0x0; cl = cl->next) {
              co = (cookie *)cl->object;
              if (co != (cookie *)0x0) {
                if (co->name == (char *)0x0) {
                  pcVar5 = (char *)gettext("(No name.)");
                  HTSACopy(&name,pcVar5);
                }
                else {
                  HTSACopy(&name,co->name);
                  LYEntify(&name,'\x01');
                }
                if (co->value == (char *)0x0) {
                  pcVar5 = (char *)gettext("(No value.)");
                  HTSACopy(&value,pcVar5);
                }
                else {
                  HTSACopy(&value,co->value);
                  LYEntify(&value,'\x01');
                }
                HTSprintf0(&buf,"<dd><a href=\"%s//%s/%s\">%s=%s</a>\n","LYNXCOOKIE:",de->domain,
                           co->lynxID,name,value);
                if (name != (char *)0x0) {
                  free(name);
                  name = (char *)0x0;
                }
                if (value != (char *)0x0) {
                  free(value);
                  value = (char *)0x0;
                }
                p_Var1 = target->isa->put_block;
                wVar7 = strlen(buf);
                (*p_Var1)(target,buf,wVar7);
                if ((co->flags & 0x20U) != 0) {
                  uVar10 = gettext("(from a previous session)");
                  HTSprintf0(&buf,"%s\n",uVar10);
                  p_Var1 = target->isa->put_block;
                  wVar7 = strlen(buf);
                  (*p_Var1)(target,buf,wVar7);
                }
                if (co->path == (char *)0x0) {
                  HTSACopy(&path,"/");
                }
                else {
                  HTSACopy(&path,co->path);
                  LYEntify(&path,'\x01');
                }
                if ((co->flags & 2U) == 0) {
                  local_6c = &DAT_0816ec17;
                }
                else {
                  local_6c = &DAT_0816ec13;
                }
                if ((co->flags & 1U) == 0) {
                  local_68 = &DAT_0816ec17;
                }
                else {
                  local_68 = &DAT_0816ec13;
                }
                iVar6 = co->port;
                HTSprintf0(&buf,"<dd>Path=%s\n<dd>Port: %d Secure: %s Discard: %s\n",path,iVar6,
                           local_68,local_6c);
                if (path != (char *)0x0) {
                  free(path);
                  path = (char *)0x0;
                }
                p_Var1 = target->isa->put_block;
                wVar7 = strlen(buf);
                (*p_Var1)(target,buf,wVar7);
                if (co->PortList != (char *)0x0) {
                  HTSprintf0(&buf,"<dD>PortList=\"%s\"\n",co->PortList,iVar6,local_68,local_6c);
                  p_Var1 = target->isa->put_block;
                  wVar7 = strlen(buf);
                  (*p_Var1)(target,buf,wVar7);
                }
                if (co->commentURL != (char *)0x0) {
                  HTSACopy(&Address,co->commentURL);
                  LYEntify(&Address,'\0');
                  HTSACopy(&Title,co->commentURL);
                  LYEntify(&Title,'\x01');
                  HTSprintf0(&buf,"<dd>CommentURL: <a href=\"%s\">%s</a>\n",Address,Title);
                  if (Address != (char *)0x0) {
                    free(Address);
                    Address = (char *)0x0;
                  }
                  if (Title != (char *)0x0) {
                    free(Title);
                    Title = (char *)0x0;
                  }
                  p_Var1 = target->isa->put_block;
                  wVar7 = strlen(buf);
                  (*p_Var1)(target,buf,wVar7);
                }
                if (co->comment != (char *)0x0) {
                  HTSACopy(&comment,co->comment);
                  LYEntify(&comment,'\x01');
                  HTSprintf0(&buf,"<dd>Comment: %s\n",comment);
                  if (comment != (char *)0x0) {
                    free(comment);
                    comment = (char *)0x0;
                  }
                  p_Var1 = target->isa->put_block;
                  wVar7 = strlen(buf);
                  (*p_Var1)(target,buf,wVar7);
                }
                if ((co->flags & 4U) == 0) {
                  local_64 = &DAT_0816ebb4;
                }
                else {
                  local_64 = &DAT_0816df60;
                }
                if ((co->flags & 4U) == 0) {
                  local_60 = (char *)gettext("(End of session.)");
                }
                else {
                  local_60 = ctime(&co->expires);
                }
                uVar10 = gettext("Maximum Gobble Date:");
                HTSprintf0(&buf,"<dd><em>%s</em> %s%s",uVar10,local_60,local_64);
                p_Var1 = target->isa->put_block;
                wVar7 = strlen(buf);
                (*p_Var1)(target,buf,wVar7);
              }
            }
            HTSprintf0(&buf,"</dt>\n");
            p_Var1 = target->isa->put_block;
            wVar7 = strlen(buf);
            (*p_Var1)(target,buf,wVar7);
          }
        }
        HTSprintf0(&buf,"</dl>\n</body>\n</html>\n");
        p_Var1 = target->isa->put_block;
        wVar7 = strlen(buf);
        (*p_Var1)(target,buf,wVar7);
        (*target->isa->_free)(target);
        if (buf != (char *)0x0) {
          free(buf);
        }
        local_74 = 200;
      }
    }
    else {
      de = find_domain_entry(domain);
      if (de != (domain_entry *)0x0) {
        if (domain != (char *)0x0) {
          free(domain);
          domain = (char *)0x0;
        }
        if (lynxID == (char *)0x0) {
          if ((de->cookie_list == (HTList *)0x0) || (de->cookie_list->next == (HTList *)0x0)) {
            mustshow = '\x01';
            pcVar5 = (char *)gettext(
                                    "D)elete domain, set allow A)lways/P)rompt/neV)er, or C)ancel? "
                                    );
            statusline(pcVar5);
          }
          else {
            mustshow = '\x01';
            pcVar5 = (char *)gettext(
                                    "D)elete domain\'s cookies, set allow A)lways/P)rompt/neV)er, or C)ancel? "
                                    );
            statusline(pcVar5);
          }
          HTNoDataOK = 1;
LAB_080e9971:
          wVar7 = LYgetch_single();
          switch(wVar7) {
          case L'A':
            de->bv = ACCEPT_ALWAYS;
            pcVar5 = de->domain;
            pcVar8 = (char *)gettext("\'A\'lways allowing from domain \'%s\'.");
            HTUserMsg2(pcVar8,pcVar5);
            return -0xcc;
          default:
            if ((wVar7 == L'\x03') || (wVar7 == L'\a')) goto reject;
            LVar3 = keymap[0];
            if (wVar7 == L'\xffffffff') {
joined_r0x080e9c76:
              if (LVar3 == 0x2f) goto reject;
            }
            else {
              if ((wVar7 & 0x8800U) == 0) {
                LVar3 = keymap[(wVar7 & 0x7ffU) + 1];
                goto joined_r0x080e9c76;
              }
              if ((wVar7 & 0xffU) == 0x2f) {
reject:
                pcVar5 = (char *)gettext("Cancelled!!!");
                HTUserMsg(pcVar5);
                return -0xcc;
              }
            }
            goto LAB_080e9971;
          case L'C':
            goto reject;
          case L'D':
            if ((de->cookie_list == (HTList *)0x0) || (de->cookie_list->next == (HTList *)0x0)) {
              if (de->domain != (char *)0x0) {
                free(de->domain);
                de->domain = (char *)0x0;
              }
              HTList_delete(de->cookie_list);
              de->cookie_list = (HTList *)0x0;
              HTList_removeObject(domain_list,de);
              if (de != (domain_entry *)0x0) {
                free(de);
                de = (domain_entry *)0x0;
              }
              pcVar5 = (char *)gettext("The domain has been eaten!");
              HTProgress(pcVar5);
              LYSleepMsg();
              goto LAB_080e9cc5;
            }
            break;
          case L'P':
            de->bv = QUERY_USER;
            pcVar5 = de->domain;
            pcVar8 = (char *)gettext("\'P\'rompting to allow from domain \'%s\'.");
            HTUserMsg2(pcVar8,pcVar5);
            return -0xcc;
          case L'V':
            de->bv = REJECT_ALWAYS;
            pcVar5 = de->domain;
            pcVar8 = (char *)gettext("ne\'V\'er allowing from domain \'%s\'.");
            HTUserMsg2(pcVar8,pcVar5);
            if ((de->cookie_list == (HTList *)0x0) || (de->cookie_list->next == (HTList *)0x0)) {
              return -0xcc;
            }
            pcVar5 = (char *)gettext("Delete all cookies in this domain?");
            BVar4 = HTConfirm(pcVar5);
            if (BVar4 == '\0') {
              return -0xcc;
            }
          }
          cl = de->cookie_list;
          while (cl != (HTList *)0x0) {
            next = cl->next;
            co = (cookie *)cl->object;
            if (co != (cookie *)0x0) {
              HTList_removeObject(de->cookie_list,co);
              freeCookie(co);
              co = (cookie *)0x0;
              total_cookies = total_cookies + -1;
            }
            cl = next;
          }
          pcVar5 = (char *)gettext("All cookies in the domain have been eaten!");
          HTProgress(pcVar5);
          LYSleepMsg();
          if (de->bv != QUERY_USER) {
            return -0xcc;
          }
          pcVar5 = (char *)gettext("Delete this empty domain?");
          BVar4 = HTConfirm(pcVar5);
          if (BVar4 != '\0') {
            if (de->domain != (char *)0x0) {
              free(de->domain);
              de->domain = (char *)0x0;
            }
            HTList_delete(de->cookie_list);
            de->cookie_list = (HTList *)0x0;
            HTList_removeObject(domain_list,de);
            if (de != (domain_entry *)0x0) {
              free(de);
              de = (domain_entry *)0x0;
            }
            pcVar5 = (char *)gettext("The domain has been eaten!");
            HTProgress(pcVar5);
            LYSleepMsg();
          }
          goto LAB_080e9cc5;
        }
        for (cl = de->cookie_list; cl != (HTList *)0x0; cl = cl->next) {
          co = (cookie *)cl->object;
          if ((co != (cookie *)0x0) && (iVar6 = strcmp(lynxID,co->lynxID), iVar6 == 0)) {
            pcVar5 = (char *)gettext("Delete this cookie?");
            BVar4 = HTConfirm(pcVar5);
            if (BVar4 == '\0') {
              if (lynxID != (char *)0x0) {
                free(lynxID);
              }
              HTNoDataOK = 1;
              return -0xcc;
            }
            HTList_removeObject(de->cookie_list,co);
            freeCookie(co);
            co = (cookie *)0x0;
            total_cookies = total_cookies + -1;
            if ((de->bv == QUERY_USER) &&
               ((de->cookie_list == (HTList *)0x0 || (de->cookie_list->next == (HTList *)0x0)))) {
              pcVar5 = (char *)gettext("Delete this empty domain?");
              BVar4 = HTConfirm(pcVar5);
              if (BVar4 == '\0') goto LAB_080e98d8;
              if (de->domain != (char *)0x0) {
                free(de->domain);
                de->domain = (char *)0x0;
              }
              HTList_delete(de->cookie_list);
              de->cookie_list = (HTList *)0x0;
              HTList_removeObject(domain_list,de);
              if (de != (domain_entry *)0x0) {
                free(de);
                de = (domain_entry *)0x0;
              }
              pcVar5 = (char *)gettext("The domain has been eaten!");
              HTProgress(pcVar5);
            }
            else {
LAB_080e98d8:
              pcVar5 = (char *)gettext("The cookie has been eaten!");
              HTProgress(pcVar5);
            }
            LYSleepMsg();
            HTNoDataOK = 1;
            break;
          }
        }
      }
LAB_080e9cc5:
      if ((domain_list == (HTList *)0x0) || (domain_list->next == (HTList *)0x0)) {
        pcVar5 = (char *)gettext("All of the cookies in the jar have been eaten!");
        HTProgress(pcVar5);
        LYSleepMsg();
      }
      if (domain != (char *)0x0) {
        free(domain);
        domain = (char *)0x0;
      }
      if (lynxID != (char *)0x0) {
        free(lynxID);
      }
      local_74 = -0xcc;
    }
  }
  return local_74;
}



// WARNING: Removing unreachable block (ram,0x080ea8ca)
// WARNING: Unknown calling convention

void cookie_domain_flag_set(char *domainstr,int flag)

{
  invcheck_behaviour_t iVar1;
  behaviour_t bVar2;
  char *pcVar3;
  char *extra_prefix;
  HTList *pHVar4;
  FILE *__stream;
  char *strsmall;
  char *dstr;
  char **str;
  domain_entry *de;
  
  de = (domain_entry *)0x0;
  str = (char **)calloc(1,4);
  dstr = (char *)0x0;
  if (str == (char **)0x0) {
    pcVar3 = (char *)gettext("cookie_domain_flag_set error, aborting program");
    extra_prefix = (char *)gettext("Internal");
    HTAlwaysAlert(extra_prefix,pcVar3);
    exit_immediately(1);
  }
  if (domain_list == (HTList *)0x0) {
    domain_list = HTList_new();
    total_cookies = 0;
  }
  HTSACopy(&dstr,domainstr);
  *str = dstr;
  while (pcVar3 = LYstrsep(str,","), pcVar3 != (char *)0x0) {
    if (*pcVar3 != '\0') {
      de = find_domain_entry(pcVar3);
      if (de == (domain_entry *)0x0) {
        de = (domain_entry *)calloc(1,0x10);
        if (de == (domain_entry *)0x0) {
          outofmem("./LYCookie.c","cookie_domain_flag_set");
        }
        de->bv = ACCEPT_ALWAYS;
        de->invcheck_bv = INVCHECK_QUERY;
        switch(flag) {
        case 0:
          de->invcheck_bv = INVCHECK_QUERY;
          break;
        case 1:
          de->invcheck_bv = INVCHECK_QUERY;
          break;
        case 2:
          de->invcheck_bv = INVCHECK_QUERY;
          break;
        case 4:
          de->bv = QUERY_USER;
          break;
        case 5:
          de->bv = QUERY_USER;
          break;
        case 6:
          de->bv = QUERY_USER;
        }
        HTSACopy(&de->domain,pcVar3);
        pHVar4 = HTList_new();
        de->cookie_list = pHVar4;
        HTList_appendObject(domain_list,de);
      }
      switch(flag) {
      case 0:
        de->bv = ACCEPT_ALWAYS;
        break;
      case 1:
        de->bv = REJECT_ALWAYS;
        break;
      case 2:
        de->bv = QUERY_USER;
        break;
      case 4:
        de->invcheck_bv = INVCHECK_QUERY;
        break;
      case 5:
        de->invcheck_bv = INVCHECK_STRICT;
        break;
      case 6:
        de->invcheck_bv = INVCHECK_LOOSE;
      }
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x20U) != 0)) {
        iVar1 = de->invcheck_bv;
        bVar2 = de->bv;
        __stream = TraceFP();
        fprintf((FILE *)__stream,"cookie_domain_flag_set (%s, bv=%u, invcheck_bv=%u)\n",pcVar3,bVar2
                ,iVar1);
      }
    }
  }
  if (str != (char **)0x0) {
    free(str);
    str = (char **)0x0;
  }
  if (dstr != (char *)0x0) {
    free(dstr);
  }
  return;
}



// WARNING: Unknown calling convention

void LYConfigCookies(void)

{
  uint n;
  
  for (n = 0; n < 10; n = n + 1) {
    if (*LYConfigCookies::table[n].domain != (char *)0x0) {
      cookie_domain_flag_set(*LYConfigCookies::table[n].domain,LYConfigCookies::table[n].flag);
      if ((LYConfigCookies::table[n].once != 0) &&
         (*LYConfigCookies::table[n].domain != (char *)0x0)) {
        free(*LYConfigCookies::table[n].domain);
        *LYConfigCookies::table[n].domain = (char *)0x0;
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

char * TrimLowercase(char *buffer)

{
  LYRemoveBlanks(buffer);
  strtolower(buffer);
  return buffer;
}



// WARNING: Unknown calling convention

void parse_either(char *attrs,int dft_color,int *monop,int *colorp)

{
  size_t sVar1;
  wchar_t wVar2;
  int iVar3;
  char local_15;
  char *next;
  int value;
  char save;
  
  while (*attrs != '\0') {
    next = strchr(attrs,0x2b);
    if (next == (char *)0x0) {
      local_15 = '\0';
      sVar1 = strlen(attrs);
      next = attrs + sVar1;
    }
    else {
      local_15 = *next;
    }
    if (local_15 != '\0') {
      *next = '\0';
    }
    wVar2 = string_to_attr(attrs);
    if (wVar2 == L'\0') {
      if ((colorp != (int *)0x0) && (iVar3 = check_color(attrs,dft_color), iVar3 != -3)) {
        *colorp = iVar3;
      }
    }
    else {
      *monop = *monop | wVar2;
    }
    attrs = next;
    if (local_15 != '\0') {
      *next = local_15;
      attrs = next + 1;
    }
  }
  return;
}



// WARNING: Unknown calling convention

void parse_attributes(char *mono,char *fg,char *bg,int style,char *element)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  wchar_t style_00;
  FILE *pFVar5;
  uint uVar6;
  int iVar7;
  bool bVar8;
  int *colorp;
  int *piVar9;
  int iBlink;
  int iBold;
  int iBg;
  int iFg;
  int curPair;
  int newstyle;
  int cA;
  int bA;
  int fA;
  int mA;
  
  mA = 0;
  fA = default_fg;
  bA = default_bg;
  cA = 0;
  style_00 = hash_code(element);
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
    pFVar5 = TraceFP();
    fprintf((FILE *)pFVar5,"CSS(PA):style d=%d / h=%d, e=%s\n",style,style_00,element);
  }
  parse_either(mono,-3,&mA,(int *)0x0);
  parse_either(bg,default_bg,&cA,&bA);
  colorp = &fA;
  parse_either(fg,default_fg,&cA,colorp);
  iVar3 = fA;
  iVar2 = bA;
  iVar1 = default_bg;
  piVar9 = (int *)default_fg;
  if (style == -1) {
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
      pFVar5 = TraceFP();
      fprintf((FILE *)pFVar5,"CSS(DEF):default_fg=%d, default_bg=%d\n",iVar3,iVar2);
    }
    default_fg = fA;
    default_bg = bA;
    default_color_reset = '\x01';
  }
  else {
    if (fA == -2) {
      bA = -2;
    }
    else if (COLORS == 0) {
      cA = 0x200000;
      fA = -2;
      bA = -2;
    }
    else {
      if ((COLORS <= fA) || (COLORS <= bA)) {
        cA = 0x200000;
      }
      if (COLORS <= fA) {
        fA = fA % COLORS;
      }
      if (COLORS <= bA) {
        bA = bA % COLORS;
      }
    }
    iVar4 = fA;
    iVar3 = bA;
    iVar2 = cA;
    if (((lynx_has_color == L'\0') || (COLOR_PAIRS + -1 <= colorPairs)) || (fA == -2)) {
      if (((lynx_has_color != L'\0') && (fA != -2)) &&
         ((WWW_TraceFlag != '\0' && ((WWW_TraceMask & 2U) != 0)))) {
        iVar1 = COLOR_PAIRS + -1;
        pFVar5 = TraceFP();
        fprintf((FILE *)pFVar5,"CSS(NC): maximum of %d colorpairs exhausted\n",iVar1);
      }
      if (style < 0x85) {
        setStyle(style,L'\xffffffff',L'\xffffffff',mA);
      }
      setHashStyle(style_00,L'\xffffffff',L'\xffffffff',mA,element);
    }
    else {
      curPair = 0;
      uVar6 = ~(fA >> 0x1f) & fA;
      iVar7 = (~(bA >> 0x1f) & bA) + 1;
      bVar8 = (cA & 0x200000U) != 0;
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
        pFVar5 = TraceFP();
        fprintf((FILE *)pFVar5,"parse_attributes %d/%d %d/%d %#x\n",iVar4,piVar9,iVar3,iVar1,iVar2);
        colorp = piVar9;
      }
      if (((fA < 0x10) && (bA < 0x10)) && ((cA != 0 || ((fA != default_fg || (bA != default_bg))))))
      {
        if (our_pairs[bVar8][uVar6 + 1][iVar7] == '\0') {
          curPair = colorPairs + 1;
          colorPairs = curPair;
          init_pair((int)(short)curPair,(int)(short)fA,(int)(short)bA);
          our_pairs[bVar8][uVar6 + 1][iVar7] = (uchar)curPair;
        }
        else {
          curPair = (int)our_pairs[bVar8][uVar6 + 1][iVar7];
        }
      }
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
        pFVar5 = TraceFP();
        fprintf((FILE *)pFVar5,"CSS(CURPAIR):%d\n",curPair,colorp);
      }
      if (style < 0x85) {
        setStyle(style,cA | curPair << 8,cA,mA);
      }
      setHashStyle(style_00,curPair << 8 | cA,cA,mA,element);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void parse_style(char *param)

{
  int *piVar1;
  char *pcVar2;
  FILE *pFVar3;
  char *pcVar4;
  char *pcVar5;
  int iVar6;
  HTTag *pHVar7;
  undefined *local_3c;
  HTTag *t;
  int element_number;
  char *bg;
  char *fg;
  char *mono;
  char *element;
  char *tmp;
  char *buffer;
  uint n;
  BOOLEAN found;
  
  found = '\0';
  buffer = (char *)0x0;
  if (param != (char *)0x0) {
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
      pFVar3 = TraceFP();
      fprintf((FILE *)pFVar3,"parse_style(%s)\n",param);
    }
    HTSACopy(&buffer,param);
    if (buffer != (char *)0x0) {
      TrimLowercase(buffer);
      pcVar4 = strchr(buffer,0x3a);
      pcVar2 = buffer;
      if (pcVar4 == (char *)0x0) {
        pcVar5 = (char *)gettext(
                                "Syntax Error parsing style in lss file:\n[%s]\nThe line must be of the form:\nOBJECT:MONO:COLOR (ie em:bold:brightblue:white)\nwhere OBJECT is one of EM,STRONG,B,I,U,BLINK etc.\n\n"
                                );
        fprintf(stderr,pcVar5,pcVar2);
        exit_immediately(1);
      }
      pcVar2 = buffer;
      *pcVar4 = '\0';
      pcVar4 = pcVar4 + 1;
      pcVar5 = strchr(pcVar4,0x3a);
      if (pcVar5 == (char *)0x0) {
        fg = "nocolor";
        bg = "nocolor";
      }
      else {
        *pcVar5 = '\0';
        fg = pcVar5 + 1;
        pcVar5 = strchr(fg,0x3a);
        if (pcVar5 == (char *)0x0) {
          bg = "default";
        }
        else {
          *pcVar5 = '\0';
          bg = pcVar5 + 1;
        }
      }
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
        iVar6 = hash_code(pcVar2);
        if (hashStyles[iVar6].name == (char *)0x0) {
          local_3c = &DAT_0816f168;
        }
        else {
          local_3c = &DAT_0816f163;
        }
        iVar6 = hash_code(pcVar2);
        pFVar3 = TraceFP();
        fprintf((FILE *)pFVar3,"CSSPARSE:%s => %d %s\n",pcVar2,iVar6,local_3c);
      }
      for (n = 0; n < 0x1b; n = n + 1) {
        iVar6 = strcasecomp(pcVar2,parse_style::table[n].name);
        if (iVar6 == 0) {
          parse_attributes(pcVar4,fg,bg,parse_style::table[n].style,parse_style::table[n].name);
          if (parse_style::table[n].set_hash != (int *)0x0) {
            piVar1 = parse_style::table[n].set_hash;
            iVar6 = hash_code(parse_style::table[n].name);
            *piVar1 = iVar6;
          }
          found = '\x01';
          break;
        }
      }
      if (found == '\0') {
        element_number = -1;
        pHVar7 = SGMLFindTag(&HTML_dtd,pcVar2);
        if ((pHVar7 != (HTTag *)0x0) && (pHVar7->name != (char *)0x0)) {
          element_number = ((int)&pHVar7[-0x250ee9].contents >> 3) * -0x49249249;
        }
        if ((element_number < 0) || (0x75 < element_number)) {
          parse_attributes(pcVar4,fg,bg,0x85,pcVar2);
        }
        else {
          parse_attributes(pcVar4,fg,bg,element_number + 8,pcVar2);
        }
      }
      else {
        iVar6 = strcasecomp(pcVar2,"normal");
        if (iVar6 == 0) {
          parse_attributes(pcVar4,fg,bg,0x80,"html");
          s_normal = hash_code("html");
          LYnormalColor();
        }
      }
      if (buffer != (char *)0x0) {
        free(buffer);
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

void style_deleteStyleList(void)

{
  LYFreeStringList(lss_styles);
  lss_styles = (HTList *)0x0;
  return;
}



// WARNING: Unknown calling convention

void free_colorstylestuff(void)

{
  style_initialiseHashTable();
  style_deleteStyleList();
  memset(our_pairs,0,0x242);
  FreeCachedStyles();
  return;
}



// WARNING: Unknown calling convention

void initialise_default_stylesheet(void)

{
  FILE *__stream;
  char *value;
  char *name;
  int code;
  char *strong;
  char *normal;
  uint n;
  
  normal = LYgetTableString(L'\0');
  strong = LYgetTableString(L'\x04');
  if (((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) ||
     ((WWW_TraceFlag != '\0' && ((WWW_TraceMask & 2U) != 0)))) {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"initialise_default_stylesheet\n");
  }
  for (n = 0; n < 0x76; n = n + 1) {
    name = (char *)0x0;
    HTSprintf0(&name,"%s:%s",tags[n].name,normal);
    parse_style(name);
    if (name != (char *)0x0) {
      free(name);
      name = (char *)0x0;
    }
  }
  for (n = 0; n < 0x1b; n = n + 1) {
    code = initialise_default_stylesheet::table2[n].color;
    name = (char *)0x0;
    if (code == L'\0') {
      value = normal;
    }
    else if (code == L'\x04') {
      value = strong;
    }
    else {
      value = LYgetTableString(code);
    }
    HTSprintf0(&name,"%s:%s",initialise_default_stylesheet::table2[n].type,value);
    parse_style(name);
    if (name != (char *)0x0) {
      free(name);
      name = (char *)0x0;
    }
    if (((value != normal) && (value != strong)) && (value != (char *)0x0)) {
      free(value);
    }
  }
  if (normal != (char *)0x0) {
    free(normal);
    normal = (char *)0x0;
  }
  if (strong != (char *)0x0) {
    free(strong);
  }
  return;
}



// WARNING: Unknown calling convention

void style_initialiseHashTable(void)

{
  int i;
  
  for (i = 0; i < 0x2001; i = i + 1) {
    if (style_initialiseHashTable::firsttime == 0) {
      if (hashStyles[i].name != (char *)0x0) {
        free(hashStyles[i].name);
        hashStyles[i].name = (char *)0x0;
      }
    }
    else {
      hashStyles[i].name = (char *)0x0;
    }
    hashStyles[i].color = 0;
    hashStyles[i].cattr = 0;
    hashStyles[i].mono = 0;
  }
  if (style_initialiseHashTable::firsttime != 0) {
    style_initialiseHashTable::firsttime = 0;
  }
  s_alink = hash_code("alink");
  s_a = hash_code("a");
  s_status = hash_code("status");
  s_alert = hash_code("alert");
  s_title = hash_code("title");
  s_sb_bar = hash_code("scroll.bar");
  s_sb_bg = hash_code("scroll.back");
  s_sb_aa = hash_code("scroll.arrow");
  s_sb_naa = hash_code("scroll.noarrow");
  return;
}



// WARNING: Unknown calling convention

void parse_userstyles(void)

{
  HTList *pHVar1;
  FILE *__stream;
  char *local_1c;
  char *local_18;
  HTList *cur;
  char *name;
  
  pHVar1 = lss_styles;
  cur = lss_styles;
  colorPairs = 0;
  style_initialiseHashTable();
  if ((pHVar1 == (HTList *)0x0) || (pHVar1->next == (HTList *)0x0)) {
    initialise_default_stylesheet();
  }
  else {
    while( true ) {
      if ((cur == (HTList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
        local_18 = (char *)0x0;
      }
      else {
        local_18 = (char *)cur->object;
      }
      local_1c = local_18;
      if (local_18 == (char *)0x0) break;
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
        if (local_18 == (char *)0x0) {
          local_1c = "!?! empty !?!";
        }
        __stream = TraceFP();
        fprintf((FILE *)__stream,"LSS:%s\n",local_1c);
      }
      if (local_18 != (char *)0x0) {
        parse_style(local_18);
      }
    }
  }
  if (s_prompt_edit == -1) {
    s_prompt_edit = s_normal;
  }
  if (s_prompt_edit_arr == -1) {
    s_prompt_edit_arr = s_prompt_edit;
  }
  if (s_prompt_edit_pad == -1) {
    s_prompt_edit_pad = s_prompt_edit;
  }
  if (s_prompt_sel == -1) {
    s_prompt_sel = s_prompt_edit;
  }
  if (s_aedit == -1) {
    s_aedit = s_alink;
  }
  if (s_aedit_arr == -1) {
    s_aedit_arr = s_aedit;
  }
  if (s_aedit_pad == -1) {
    s_aedit_pad = s_aedit;
  }
  if (s_curedit == -1) {
    s_curedit = s_aedit;
  }
  if (s_aedit_sel == -1) {
    s_aedit_sel = s_aedit;
  }
  if (s_menu_bg == -1) {
    s_menu_bg = s_normal;
  }
  if (s_menu_entry == -1) {
    s_menu_entry = s_menu_bg;
  }
  if (s_menu_frame == -1) {
    s_menu_frame = s_menu_bg;
  }
  if (s_menu_number == -1) {
    s_menu_number = s_menu_bg;
  }
  if (s_menu_active == -1) {
    s_menu_active = s_alink;
  }
  return;
}



// WARNING: Unknown calling convention

void HStyle_addStyle(char *buffer)

{
  FILE *pFVar1;
  int iVar2;
  char *local_20;
  char *local_1c;
  char *local_18;
  char *name;
  
  name = (char *)0x0;
  if (((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) ||
     ((WWW_TraceFlag != '\0' && ((WWW_TraceMask & 2U) != 0)))) {
    pFVar1 = TraceFP();
    fprintf((FILE *)pFVar1,"HStyle_addStyle(%s)\n",buffer);
  }
  HTSACopy(&name,buffer);
  TrimLowercase(name);
  if (lss_styles == (HTList *)0x0) {
    lss_styles = HTList_new();
  }
  iVar2 = strncasecomp(name,"default:",8);
  if (iVar2 == 0) {
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
      if (name == (char *)0x0) {
        local_20 = "!?! empty !?!";
      }
      else {
        local_20 = name;
      }
      if (default_color_reset == '\0') {
        local_1c = "";
      }
      else {
        local_1c = ".ignore";
      }
      pFVar1 = TraceFP();
      fprintf((FILE *)pFVar1,"READCSS.default%s:%s\n",local_1c,local_20);
    }
    if (default_color_reset == '\0') {
      parse_style(name);
    }
  }
  else {
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
      if (name == (char *)0x0) {
        local_18 = "!?! empty !?!";
      }
      else {
        local_18 = name;
      }
      pFVar1 = TraceFP();
      fprintf((FILE *)pFVar1,"READCSS:%s\n",local_18);
    }
    HTList_addObject(lss_styles,name);
  }
  return;
}



// WARNING: Unknown calling convention

int style_readFromFileREC(char *lss_filename,char *parent_filename)

{
  FILE *pFVar1;
  int iVar2;
  size_t sVar3;
  char *pcVar4;
  char *local_1c;
  int local_18;
  int len;
  char *buffer;
  FILE *fh;
  
  buffer = (char *)0x0;
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
    if (lss_filename == (char *)0x0) {
      local_1c = "?!? empty ?!?";
    }
    else {
      local_1c = lss_filename;
    }
    pFVar1 = TraceFP();
    fprintf((FILE *)pFVar1,"CSS:Reading styles from file: %s\n",local_1c);
  }
  if ((lss_filename == (char *)0x0) || (*lss_filename == '\0')) {
    local_18 = -1;
  }
  else {
    fh = LYOpenCFG(lss_filename,parent_filename,"/etc/lynx-cur/lynx.lss");
    if (fh == (FILE *)0x0) {
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
        pFVar1 = TraceFP();
        fprintf((FILE *)pFVar1,"CSS:Can\'t open style file \'%s\', using defaults\n",lss_filename);
      }
      local_18 = -1;
    }
    else {
      if (parent_filename == (char *)0x0) {
        free_colorstylestuff();
      }
      while( true ) {
        pcVar4 = LYSafeGets(&buffer,fh);
        if (pcVar4 == (char *)0x0) break;
        LYTrimTrailing(buffer);
        LYTrimTail(buffer);
        LYTrimHead(buffer);
        iVar2 = strncasecomp(buffer,"include:",8);
        if (iVar2 == 0) {
          pcVar4 = LYSkipBlanks(buffer + 8);
          style_readFromFileREC(pcVar4,lss_filename);
        }
        else if (*buffer != '#') {
          sVar3 = strlen(buffer);
          if (0 < (int)sVar3) {
            HStyle_addStyle(buffer);
          }
        }
      }
      LYCloseInput(fh);
      if ((parent_filename == (char *)0x0) && (LYCursesON != '\0')) {
        parse_userstyles();
      }
      local_18 = 0;
    }
  }
  return local_18;
}



// WARNING: Unknown calling convention

int style_readFromFile(char *filename)

{
  int iVar1;
  
  iVar1 = style_readFromFileREC(filename,(char *)0x0);
  return iVar1;
}



void TrimColorClass(char *tagname,char *styleclassname,int *phcode)

{
  int iVar1;
  char *pcVar2;
  int iVar3;
  int in_GS_OFFSET;
  char *local_64;
  int *phcode_local;
  char *styleclassname_local;
  char *tagname_local;
  char *lookfrom;
  char *start;
  char *end;
  char tmp [64];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  start = (char *)0x0;
  sprintf(tmp,";%.*s",0x3d,tagname);
  TrimLowercase(tmp);
  lookfrom = styleclassname;
  if (styleclassname != (char *)0x0) {
    while (pcVar2 = strstr(lookfrom,tmp), pcVar2 != (char *)0x0) {
      lookfrom = pcVar2 + 1;
      start = pcVar2;
    }
    if (start != (char *)0x0) {
      *start = '\0';
    }
  }
  if ((lookfrom == (char *)0x0) || (*lookfrom == '\0')) {
    local_64 = tmp + 1;
  }
  else {
    local_64 = lookfrom;
  }
  iVar3 = hash_code(local_64);
  *phcode = iVar3;
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void FastTrimColorClass(char *tag_name,int name_len,char *stylename,char **pstylename_end,
                       int *phcode)

{
  bool bVar1;
  FILE *pFVar2;
  int iVar3;
  char *local_18;
  char *tag_start;
  BOOLEAN found;
  
  tag_start = *pstylename_end;
  bVar1 = false;
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
    pFVar2 = TraceFP();
    fprintf((FILE *)pFVar2,"STYLE.fast-trim: [%s] from [%s]: ",tag_name,stylename);
  }
  do {
    if (tag_start < stylename) {
LAB_080ebe46:
      if (bVar1) {
        *tag_start = '\0';
        *pstylename_end = tag_start;
      }
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
        if (bVar1) {
          local_18 = "success.\n";
        }
        else {
          local_18 = "failed.\n";
        }
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2,local_18);
      }
      iVar3 = hash_code(tag_start + 1);
      *phcode = iVar3;
      return;
    }
    for (; (stylename <= tag_start && (*tag_start != ';')); tag_start = tag_start + -1) {
    }
    iVar3 = strncasecomp(tag_start + 1,tag_name,name_len);
    if (iVar3 == 0) {
      bVar1 = true;
      goto LAB_080ebe46;
    }
    tag_start = tag_start + -1;
  } while( true );
}



// WARNING: Unknown calling convention

void cache_tag_styles(void)

{
  int iVar1;
  int iVar2;
  int in_GS_OFFSET;
  int i;
  char buf [200];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  for (i = 0; i < 0x76; i = i + 1) {
    LYstrncpy(buf,tags[i].name,L'');
    LYLowerCase(buf);
    iVar2 = hash_code(buf);
    cached_tag_styles[i] = iVar2;
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



// WARNING: Unknown calling convention

uint * RefCachedStyle(int y,int x)

{
  uint *result;
  
  result = (uint *)0x0;
  if (cached_styles_ptr == (uint *)0x0) {
    cached_styles_rows = display_lines;
    cached_styles_cols = LYcols;
    cached_styles_ptr = (uint *)calloc(LYcols * display_lines,4);
  }
  if ((((-1 < y) && (-1 < x)) && (y < cached_styles_rows)) && (x < cached_styles_cols)) {
    result = cached_styles_ptr + cached_styles_cols * y + x;
  }
  return result;
}



// WARNING: Unknown calling convention

BOOLEAN ValidCachedStyle(int y,int x)

{
  uint *puVar1;
  
  puVar1 = RefCachedStyle(y,x);
  return puVar1 != (uint *)0x0;
}



// WARNING: Unknown calling convention

uint GetCachedStyle(int y,int x)

{
  uint *puVar1;
  uint *cache;
  uint value;
  
  value = 0;
  puVar1 = RefCachedStyle(y,x);
  if (puVar1 != (uint *)0x0) {
    value = *puVar1;
  }
  return value;
}



// WARNING: Unknown calling convention

void SetCachedStyle(int y,int x,uint value)

{
  uint *puVar1;
  uint *cache;
  
  puVar1 = RefCachedStyle(y,x);
  if (puVar1 != (uint *)0x0) {
    *puVar1 = value;
  }
  return;
}



// WARNING: Unknown calling convention

void ResetCachedStyles(void)

{
  if (cached_styles_ptr != (uint *)0x0) {
    memset(cached_styles_ptr,0,cached_styles_cols * cached_styles_rows * 4);
  }
  return;
}



// WARNING: Unknown calling convention

void FreeCachedStyles(void)

{
  if (cached_styles_ptr != (uint *)0x0) {
    if (cached_styles_ptr != (uint *)0x0) {
      free(cached_styles_ptr);
      cached_styles_ptr = (uint *)0x0;
    }
    cached_styles_rows = 0;
    cached_styles_cols = 0;
  }
  return;
}



// WARNING: Unknown calling convention

int hash_code(char *string)

{
  char *p;
  int hash;
  
  hash = 0;
  for (p = string; *p != '\0'; p = p + 1) {
    hash = (int)(hash * 3 + (uint)(byte)*p) % 0x2001;
  }
  return hash;
}



// WARNING: Unknown calling convention

int hash_code_lowercase_on_fly(char *string)

{
  ushort **ppuVar1;
  uint local_1c;
  char *p;
  int hash;
  
  hash = 0;
  for (p = string; *p != '\0'; p = p + 1) {
    ppuVar1 = __ctype_b_loc();
    if (((*ppuVar1)[(byte)*p] & 0x100) == 0) {
      local_1c = (uint)(byte)*p;
    }
    else {
      local_1c = tolower((uint)(byte)*p);
      local_1c = local_1c & 0xff;
    }
    hash = (int)(hash * 3 + local_1c) % 0x2001;
  }
  return hash;
}



int hash_code_aggregate_char(char c,int hash)

{
  char c_local;
  
  return (int)(hash * 3 + (uint)(byte)c) % 0x2001;
}



// WARNING: Unknown calling convention

int hash_code_aggregate_lower_str(char *string,int hash_was)

{
  ushort **ppuVar1;
  uint local_1c;
  char *p;
  int hash;
  
  hash = hash_was;
  for (p = string; *p != '\0'; p = p + 1) {
    ppuVar1 = __ctype_b_loc();
    if (((*ppuVar1)[(byte)*p] & 0x100) == 0) {
      local_1c = (uint)(byte)*p;
    }
    else {
      local_1c = tolower((uint)(byte)*p);
      local_1c = local_1c & 0xff;
    }
    hash = (int)(hash * 3 + local_1c) % 0x2001;
  }
  return hash;
}



// WARNING: Unknown calling convention

int html_src_tag_index(char *tagname)

{
  HTTag *pHVar1;
  int local_18;
  HTTag *tag;
  
  pHVar1 = SGMLFindTag(&HTML_dtd,tagname);
  if ((pHVar1 == (HTTag *)0x0) || (pHVar1 == &HTTag_unrecognized)) {
    local_18 = -1;
  }
  else {
    local_18 = ((int)&pHVar1[-0x250ee9].contents >> 3) * -0x49249249;
  }
  return local_18;
}



// WARNING: Unknown calling convention

void append_close_tag(char *tagname,HT_tagspec **head,HT_tagspec **tail)

{
  size_t __nmemb;
  HTMLElement HVar1;
  HT_tagspec *pHVar2;
  BOOLEAN *pBVar3;
  char **ppcVar4;
  HT_tagspec *subj;
  HTTag *tag;
  int nattr;
  int idx;
  
  HVar1 = html_src_tag_index(tagname);
  __nmemb = tags[HVar1].number_of_attributes;
  if (HVar1 == ~HTML_A) {
    fprintf(stderr,"internal error: previous check didn\'t find bad HTML tag %s",tagname);
    exit_immediately(1);
  }
  pHVar2 = (HT_tagspec *)calloc(1,0x1c);
  pHVar2->element = HVar1;
  pBVar3 = (BOOLEAN *)calloc(__nmemb,1);
  pHVar2->present = pBVar3;
  ppcVar4 = (char **)calloc(__nmemb,4);
  pHVar2->value = ppcVar4;
  pHVar2->start = '\0';
  pHVar2->class_name = (char *)0x0;
  if (*head == (HT_tagspec *)0x0) {
    *head = pHVar2;
    *tail = pHVar2;
  }
  else {
    (*tail)->next = pHVar2;
    *tail = pHVar2;
  }
  return;
}



// WARNING: Unknown calling convention

void append_open_tag(char *tagname,char *classname,HT_tagspec **head,HT_tagspec **tail)

{
  HT_tagspec *pHVar1;
  int hash_was;
  int hcode;
  HTTag *tag;
  HT_tagspec *subj;
  
  append_close_tag(tagname,head,tail);
  pHVar1 = *tail;
  pHVar1->start = '\x01';
  hcode = hash_code_lowercase_on_fly(tagname);
  if ((classname == (char *)0x0) || (*classname == '\0')) {
    HTSACopy(&pHVar1->class_name,"");
  }
  else {
    hash_was = hash_code_aggregate_char('.',hcode);
    hcode = hash_code_aggregate_lower_str(classname,hash_was);
    HTSACopy(&pHVar1->class_name,classname);
  }
  pHVar1->style = hcode;
  return;
}



int html_src_parse_tagspec(char *ts,HTlexeme lexeme,BOOLEAN checkonly,BOOLEAN isstart)

{
  char cVar1;
  FILE *pFVar2;
  ushort **ppuVar3;
  int iVar4;
  char *pcVar5;
  HT_tagspec **local_68;
  BOOLEAN isstart_local;
  BOOLEAN checkonly_local;
  int idx_1;
  int idx;
  HT_tagspec **slot;
  HT_tagspec *tail;
  HT_tagspec *head;
  html_src_check_state state;
  char *classend;
  char *classstart;
  char *tagend;
  char *tagstart;
  char *p;
  char after_excl;
  char save1;
  char save;
  BOOLEAN code;
  BOOLEAN stop;
  
  stop = '\0';
  code = '\0';
  p = ts;
  tagstart = (char *)0x0;
  tagend = (char *)0x0;
  after_excl = '\0';
  state = HTSRC_CK_normal;
  head = (HT_tagspec *)0x0;
  tail = (HT_tagspec *)0x0;
  if (isstart == '\0') {
    local_68 = lexeme_end;
  }
  else {
    local_68 = lexeme_start;
  }
  do {
    if (stop != '\0') {
      if ((code != '\0') && (checkonly == '\0')) {
        local_68[lexeme] = head;
      }
      return (int)code;
    }
    if (state == HTSRC_CK_after_tagname) {
      cVar1 = *p;
      if (cVar1 != ' ') {
        if (' ' < cVar1) {
          if (cVar1 == '.') {
            if (after_excl == '\0') {
              state = HTSRC_CK_seen_dot;
            }
            else {
              if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
                pcVar5 = p + (1 - (int)ts);
                pFVar2 = TraceFP();
                fprintf((FILE *)pFVar2,"dot after \'!\' at column %d:\n\t%s\n",pcVar5,ts);
              }
              stop = '\x01';
            }
            goto LAB_080ecb1a;
          }
LAB_080ec8f6:
          if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
            pcVar5 = p + (1 - (int)ts);
            cVar1 = *p;
            pFVar2 = TraceFP();
            fprintf((FILE *)pFVar2,"unexpected char \'%c\' after tagname at column %d:\n\t%s\n",
                    (int)cVar1,pcVar5,ts);
          }
          stop = '\x01';
          goto LAB_080ecb1a;
        }
        if (cVar1 == '\0') {
          stop = '\x01';
          code = '\x01';
        }
        else if (cVar1 != '\t') goto LAB_080ec8f6;
      }
      save = *tagend;
      *tagend = '\0';
      classstart = (char *)0x0;
      if (checkonly == '\0') {
        if (after_excl == '\0') {
          append_open_tag(tagstart,(char *)0x0,&head,&tail);
        }
        else {
          append_close_tag(tagstart,&head,&tail);
        }
      }
      else {
        iVar4 = html_src_tag_index(tagstart);
        if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
          pFVar2 = TraceFP();
          fprintf((FILE *)pFVar2,"tag index(%s) = %d\n",tagstart,iVar4);
        }
        *tagend = save;
        if (iVar4 == -1) {
          stop = '\x01';
          goto LAB_080ecb1a;
        }
      }
      state = HTSRC_CK_normal;
      after_excl = '\0';
    }
    else if (state < HTSRC_CK_after_tagname) {
      cVar1 = *p;
      if (cVar1 != ' ') {
        if (cVar1 < '!') {
          if (cVar1 == '\0') {
            stop = '\x01';
            code = '\x01';
          }
          else if (cVar1 != '\t') goto LAB_080ec6a6;
        }
        else if (cVar1 == '!') {
          if (state == HTSRC_CK_seen_excl) {
            if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
              pcVar5 = p + (1 - (int)ts);
              pFVar2 = TraceFP();
              fprintf((FILE *)pFVar2,"second \'!\' at column %d:\n\t%s\n",pcVar5,ts);
            }
            stop = '\x01';
          }
          else {
            state = HTSRC_CK_seen_excl;
            after_excl = '\x01';
          }
        }
        else {
LAB_080ec6a6:
          ppuVar3 = __ctype_b_loc();
          if ((((*ppuVar3)[(byte)*p] & 0x400) == 0) && (*p != '_')) {
            if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
              pcVar5 = p + (1 - (int)ts);
              pFVar2 = TraceFP();
              fprintf((FILE *)pFVar2,"no name starting at column %d:\n\t%s\n",pcVar5,ts);
            }
            stop = '\x01';
          }
          else {
            tagstart = p;
            while ((*p != '\0' &&
                   ((ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[(byte)*p] & 8) != 0 || (*p == '_'))))) {
              p = p + 1;
            }
            tagend = p;
            p = p + -1;
            state = HTSRC_CK_after_tagname;
          }
        }
      }
    }
    else if (((state == HTSRC_CK_seen_dot) && (cVar1 = *p, cVar1 != '\t')) && (cVar1 != ' ')) {
      if (cVar1 == '\0') {
        if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
          pcVar5 = p + (1 - (int)ts);
          pFVar2 = TraceFP();
          fprintf((FILE *)pFVar2,"expected text after dot at column %d:\n\t%s\n",pcVar5,ts);
        }
        stop = '\x01';
      }
      else {
        ppuVar3 = __ctype_b_loc();
        if ((((*ppuVar3)[(byte)*p] & 0x400) == 0) && (*p != '_')) {
          if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
            pcVar5 = p + (1 - (int)ts);
            pFVar2 = TraceFP();
            fprintf((FILE *)pFVar2,"no name starting at column %d:\n\t%s\n",pcVar5,ts);
          }
          stop = '\x01';
        }
        else {
          classstart = p;
          while ((*p != '\0' &&
                 ((ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[(byte)*p] & 8) != 0 || (*p == '_'))))) {
            p = p + 1;
          }
          classend = p;
          save = *p;
          *p = '\0';
          save1 = *tagend;
          *tagend = '\0';
          if (checkonly == '\0') {
            p = p + -1;
            append_open_tag(tagstart,classstart,&head,&tail);
          }
          else {
            p = p + -1;
            iVar4 = html_src_tag_index(tagstart);
            *tagend = save1;
            *classend = save;
            if (iVar4 == -1) {
              return 0;
            }
          }
          state = HTSRC_CK_normal;
          after_excl = '\0';
        }
      }
    }
LAB_080ecb1a:
    p = p + 1;
  } while( true );
}



// WARNING: Unknown calling convention

void html_src_clean_item(HTlexeme l)

{
  HT_tagspec *pHVar1;
  HT_tagspec **local_18;
  HT_tagspec *ts;
  HT_tagspec **pts;
  HT_tagspec *cur;
  int i;
  
  if ((HTL_tagspecs[l] != (char *)0x0) && (HTL_tagspecs[l] != (char *)0x0)) {
    free(HTL_tagspecs[l]);
    HTL_tagspecs[l] = (char *)0x0;
  }
  for (i = 0; i < 2; i = i + 1) {
    if (i == 0) {
      local_18 = lexeme_end;
    }
    else {
      local_18 = lexeme_start;
    }
    pHVar1 = local_18[l];
    local_18[l] = (HT_tagspec *)0x0;
    while (ts = pHVar1, ts != (HT_tagspec *)0x0) {
      if (ts->present != (BOOLEAN *)0x0) {
        free(ts->present);
        ts->present = (BOOLEAN *)0x0;
      }
      if (ts->value != (char **)0x0) {
        free(ts->value);
        ts->value = (char **)0x0;
      }
      if ((ts->start != '\0') && (ts->class_name != (char *)0x0)) {
        free(ts->class_name);
        ts->class_name = (char *)0x0;
      }
      pHVar1 = ts->next;
      if (ts != (HT_tagspec *)0x0) {
        free(ts);
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

void html_src_clean_data(void)

{
  int i;
  
  for (i = 0; i < 0xc; i = i + 1) {
    html_src_clean_item(i);
  }
  return;
}



// WARNING: Unknown calling convention

void html_src_on_lynxcfg_reload(void)

{
  html_src_clean_data();
  HTMLSRC_init_caches('\x01');
  return;
}



// WARNING: Unknown calling convention

void failed_init(char *tag,int lexeme)

{
  char *pcVar1;
  
  pcVar1 = (char *)gettext("parse-error while caching %s tagspec of lexeme %d\n");
  fprintf(stderr,pcVar1,tag,lexeme);
  pcVar1 = (char *)gettext("Use -trace -trace-mask=8 to see details in log.\n");
  fprintf(stderr,pcVar1);
  exit_immediately(1);
  return;
}



void HTMLSRC_init_caches(BOOLEAN dont_exit)

{
  int iVar1;
  FILE *pFVar2;
  int iVar3;
  int in_GS_OFFSET;
  char *local_418;
  char *local_410;
  BOOLEAN dont_exit_local;
  char *p;
  int i;
  char buf [1000];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
    pFVar2 = TraceFP();
    fprintf((FILE *)pFVar2,"HTMLSRC_init_caches(%d tagspecs)\n",0xc);
  }
  for (i = 0; i < 0xc; i = i + 1) {
    if (HTL_tagspecs[i] == (char *)0x0) {
      local_418 = HTL_tagspecs_defaults[i];
    }
    else {
      local_418 = HTL_tagspecs[i];
    }
    LYstrncpy(buf,local_418,L'');
    HTSACopy(HTL_tagspecs + i,buf);
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
      pFVar2 = TraceFP();
      fprintf((FILE *)pFVar2,"parsing lexeme %d: %s\n",i + 1,buf);
    }
    local_410 = strchr(buf,0x3a);
    if (local_410 != (char *)0x0) {
      *local_410 = '\0';
    }
    iVar3 = html_src_parse_tagspec(buf,i,'\0','\x01');
    if ((iVar3 == 0) && (dont_exit == '\0')) {
      failed_init("1st",i);
    }
    if (local_410 == (char *)0x0) {
      local_410 = (char *)0x0;
    }
    else {
      local_410 = local_410 + 1;
    }
    iVar3 = html_src_parse_tagspec(local_410,i,'\0','\0');
    if ((iVar3 == 0) && (dont_exit == '\0')) {
      failed_init("2nd",i);
    }
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



// WARNING: Unknown calling convention

char * cellstate_s(cellstate_t state)

{
  char *result;
  
  result = "?";
  switch(state) {
  case CS__new:
    result = "CS__new";
    break;
  case CS__0new:
    result = "CS__0new";
    break;
  case CS__0eb:
    result = "CS__0eb";
    break;
  case CS__eb:
    result = "CS__eb";
    break;
  case CS__0cb:
    result = "CS__0cb";
    break;
  case CS__cb:
    result = "CS__cb";
    break;
  case CS__0ef:
    result = "CS__0ef";
    break;
  case CS__ef:
    result = "CS__ef";
    break;
  case CS__0cf:
    result = "CS__0cf";
    break;
  case CS__cf:
    result = "CS__cf";
    break;
  case CS__ebc:
    result = "CS__ebc";
    break;
  case CS__cbc:
    result = "CS__cbc";
    break;
  case CS_invalid:
    result = "CS_invalid";
  }
  return result;
}



STable_info * Stbl_startTABLE(short alignment)

{
  STable_info *pSVar1;
  FILE *__stream;
  short alignment_local;
  STable_info *me;
  
  pSVar1 = (STable_info *)calloc(1,0x78);
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 4U) != 0)) {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"TRST:Stbl_startTABLE(align=%d)\n",(int)alignment);
  }
  if (pSVar1 != (STable_info *)0x0) {
    pSVar1->alignment = alignment;
    pSVar1->rowgroup_align = -1;
    pSVar1->pending_colgroup_align = -1;
    (pSVar1->s).x_td = -1;
    (pSVar1->s).icell_core = -1;
    if (nested_tables != '\0') {
      pSVar1->enclosing = (_STable_info *)0x0;
    }
  }
  return pSVar1;
}



// WARNING: Unknown calling convention

void free_rowinfo(STable_rowinfo *me)

{
  if (((me != (STable_rowinfo *)0x0) && (me->allocated != 0)) &&
     (me->cells != (STable_cellinfo *)0x0)) {
    free(me->cells);
    me->cells = (STable_cellinfo *)0x0;
  }
  return;
}



// WARNING: Unknown calling convention

void Stbl_free(STable_info *me)

{
  FILE *__stream;
  int i;
  
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 4U) != 0)) {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"TRST:Stbl_free()\n");
  }
  if (((me != (STable_info *)0x0) && (me->allocated_rows != 0)) &&
     (me->rows != (STable_rowinfo *)0x0)) {
    for (i = 0; i < me->allocated_rows; i = i + 1) {
      free_rowinfo(me->rows + i);
    }
    if (me->rows != (STable_rowinfo *)0x0) {
      free(me->rows);
      me->rows = (STable_rowinfo *)0x0;
    }
  }
  free_rowinfo(&me->rowspans2eog);
  if ((me != (STable_info *)0x0) && (me->sumcols != (STable_cellinfo *)0x0)) {
    free(me->sumcols);
    me->sumcols = (STable_cellinfo *)0x0;
  }
  if (me != (STable_info *)0x0) {
    free(me);
  }
  return;
}



// WARNING: Unknown calling convention

int Stbl_addCellToRow(STable_rowinfo *me,STable_cellinfo *colinfo,int ncolinfo,STable_states *s,
                     int colspan,int alignment,int isheader,int lineno,int *ppos)

{
  int iVar1;
  int iVar2;
  int iVar3;
  FILE *pFVar4;
  char *pcVar5;
  char *pcVar6;
  uint uVar7;
  byte local_4c;
  int local_48;
  int local_34;
  int growby;
  int ret;
  cellstate_t newstate;
  int last_colspan;
  int i;
  STable_cellinfo *cells;
  
  if (me->ncells == 0) {
    local_48 = 1;
  }
  else {
    local_48 = me->cells[me->ncells + -1].colspan;
  }
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 4U) != 0)) {
    iVar1 = *ppos;
    pFVar4 = TraceFP();
    fprintf((FILE *)pFVar4,"TRST:Stbl_addCellToRow, line=%d, pos=%d, colspan=%d\n",lineno,iVar1,
            colspan);
  }
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 4U) != 0)) {
    pcVar5 = cellstate_s(s->state);
    pcVar6 = cellstate_s(s->prev_state);
    iVar1 = s->pending_len;
    iVar2 = s->lineno;
    iVar3 = me->ncells;
    pFVar4 = TraceFP();
    fprintf((FILE *)pFVar4," ncells=%d, stateLine=%d, pending_len=%d, pstate=%s, state=%s\n",iVar3,
            iVar2,iVar1,pcVar6,pcVar5);
  }
  if (me->ncells == 0) {
    s->prev_state = CS_invalid;
  }
  else if ((s->prev_state == CS_invalid) ||
          (((s->state != CS__0new && (s->state != CS__ef)) && (s->state != CS__0ef)))) {
    s->prev_state = s->state;
  }
  if ((me->ncells == 0) || (*ppos == 0)) {
    newstate = CS__0new;
  }
  else {
    newstate = CS__new;
  }
  if ((0 < me->ncells) && (0 < s->pending_len)) {
    if (s->prev_state != CS__cbc) {
      me->cells[me->ncells + -1].len = s->pending_len;
    }
    s->pending_len = 0;
  }
  s->x_td = *ppos;
  if (s->lineno == lineno) {
    switch(s->prev_state) {
    case CS__new:
    case CS__cf:
      if ((me->fixed_line == '\0') || (me->Line == lineno)) {
        me->fixed_line = '\x01';
        me->Line = lineno;
        goto switchD_080ed682_caseD_ffffffff;
      }
      break;
    default:
      goto switchD_080ed682_caseD_ffffffff;
    }
trace_and_fail:
    ret = -1;
  }
  else {
    if (me->fixed_line == '\0') {
      if ((me->ncells == 0) || (*ppos == 0)) {
        uVar7 = s->prev_state + CS__0new;
        if (uVar7 < 10) {
          local_4c = (byte)uVar7;
          uVar7 = 1 << (local_4c & 0x1f);
          if ((uVar7 & 0x2ad) == 0) {
            if ((uVar7 & 0x40) != 0) {
              *ppos = me->cells[me->ncells + -1].pos + me->cells[me->ncells + -1].len;
            }
          }
          else {
            if (0 < me->ncells) {
              for (i = me->ncells + local_48 + -2; me->ncells + -1 <= i; i = i + -1) {
                me->cells[i].pos = *ppos;
                me->cells[i].cLine = lineno;
              }
            }
            me->Line = lineno;
          }
        }
      }
      else {
        switch(s->prev_state) {
        default:
          me->fixed_line = '\x01';
          break;
        case CS__0new:
        case CS__0eb:
        case CS__0ef:
          break;
        case CS__0cb:
        case CS__0cf:
          if (me->cells->pos < *ppos) {
            me->Line = lineno;
          }
          me->fixed_line = '\x01';
          break;
        case CS__cb:
        case CS__cf:
        case CS__cbc:
          goto trace_and_fail;
        }
      }
    }
    if ((me->fixed_line != '\0') && (me->Line != lineno)) {
      switch(s->prev_state) {
      default:
        *ppos = me->cells[me->ncells + -1].pos;
        break;
      case CS__0cb:
      case CS__0cf:
        if ((*ppos == 0) || (*ppos <= me->cells->pos)) {
          *ppos = me->cells[me->ncells + -1].pos + me->cells[me->ncells + -1].len;
        }
        break;
      case CS__cb:
      case CS__cf:
        if (0 < *ppos) goto trace_and_fail;
        *ppos = me->cells[me->ncells + -1].pos + me->cells[me->ncells + -1].len;
        break;
      case CS_invalid:
      case CS__0new:
      case CS__0eb:
      case CS__0ef:
      case CS__cbc:
        break;
      }
    }
    s->lineno = lineno;
switchD_080ed682_caseD_ffffffff:
    s->state = newstate;
    if ((0 < me->ncells) && (1 < me->cells[me->ncells + -1].colspan)) {
      me->ncells = me->ncells + me->cells[me->ncells + -1].colspan + -1;
    }
    while ((me->ncells < me->allocated && (me->cells[me->ncells].alignment == -2))) {
      me->ncells = me->ncells + 1;
    }
    for (growby = 0; me->allocated + growby < me->ncells + colspan + 1; growby = growby + 0x10) {
    }
    if (growby != 0) {
      if ((me->allocated == 0) && (me->cells == (STable_cellinfo *)0x0)) {
        cells = (STable_cellinfo *)calloc(growby,0x14);
      }
      else {
        cells = (STable_cellinfo *)realloc(me->cells,(me->allocated + growby) * 0x14);
        for (i = 0; (cells != (STable_cellinfo *)0x0 && (i < growby)); i = i + 1) {
          cells[me->allocated + i].alignment = -1;
        }
      }
      if (cells == (STable_cellinfo *)0x0) goto trace_and_fail;
      me->allocated = me->allocated + growby;
      me->cells = cells;
    }
    me->cells[me->ncells].cLine = lineno;
    me->cells[me->ncells].pos = *ppos;
    me->cells[me->ncells].len = -1;
    me->cells[me->ncells].colspan = colspan;
    if (alignment == -1) {
      if (ncolinfo < me->ncells + 1) {
        me->cells[me->ncells].alignment = me->alignment;
      }
      else {
        me->cells[me->ncells].alignment = colinfo[me->ncells].alignment;
      }
      if (me->cells[me->ncells].alignment == -1) {
        me->cells[me->ncells].alignment = me->alignment;
      }
      if (me->cells[me->ncells].alignment == -1) {
        if (isheader == 0) {
          local_34 = 1;
        }
        else {
          local_34 = 3;
        }
        me->cells[me->ncells].alignment = local_34;
      }
    }
    else {
      me->cells[me->ncells].alignment = alignment;
    }
    i = me->ncells;
    while (i = i + 1, i < me->ncells + colspan) {
      me->cells[i].cLine = lineno;
      me->cells[i].pos = *ppos;
      me->cells[i].len = -1;
      me->cells[i].colspan = 0;
      me->cells[i].alignment = 1;
    }
    me->cells[me->ncells + colspan].pos = -1;
    me->ncells = me->ncells + 1;
    ret = me->ncells + -1;
  }
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 4U) != 0)) {
    pcVar5 = cellstate_s(s->state);
    pcVar6 = cellstate_s(s->prev_state);
    pFVar4 = TraceFP();
    fprintf((FILE *)pFVar4," => prev_state=%s, state=%s, ret=%d\n",pcVar6,pcVar5,ret);
  }
  return ret;
}



// WARNING: Unknown calling convention

int Stbl_reserveCellsInRow(STable_rowinfo *me,int icell,int colspan)

{
  FILE *__stream;
  STable_cellinfo *pSVar1;
  int iVar2;
  int growby;
  int i;
  STable_cellinfo *cells;
  
  iVar2 = (icell + 1 + colspan) - me->allocated;
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 4U) != 0)) {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"TRST:Stbl_reserveCellsInRow(icell=%d, colspan=%d\n",icell,colspan);
  }
  if (0 < iVar2) {
    pSVar1 = (STable_cellinfo *)realloc(me->cells,(me->allocated + iVar2) * 0x14);
    if (pSVar1 == (STable_cellinfo *)0x0) {
      return -1;
    }
    for (i = 0; i < iVar2; i = i + 1) {
      pSVar1[me->allocated + i].alignment = -1;
    }
    me->allocated = me->allocated + iVar2;
    me->cells = pSVar1;
  }
  for (i = icell; i < icell + colspan; i = i + 1) {
    me->cells[i].cLine = -1;
    me->cells[i].pos = -1;
    me->cells[i].len = -1;
    me->cells[i].colspan = 0;
    me->cells[i].alignment = -2;
  }
  me->cells[icell].colspan = colspan;
  return 0;
}



// WARNING: Unknown calling convention

int Stbl_finishCellInRow(STable_rowinfo *me,STable_states *s,int end_td,int lineno,int pos)

{
  STable_cellinfo *pSVar1;
  int iVar2;
  int iVar3;
  FILE *pFVar4;
  char *pcVar5;
  char *pcVar6;
  bool bVar7;
  int local_c8;
  uint local_c4;
  cellstate_t local_bc;
  cellstate_t local_b8;
  cellstate_t local_b4;
  int local_b0;
  cellstate_t local_ac;
  cellstate_t local_a8;
  cellstate_t local_a4;
  int local_a0;
  int local_9c;
  cellstate_t local_98;
  cellstate_t local_94;
  cellstate_t local_90;
  cellstate_t local_8c;
  cellstate_t local_88;
  int local_84;
  cellstate_t local_80;
  cellstate_t local_7c;
  int local_78;
  int local_74;
  cellstate_t local_70;
  cellstate_t local_6c;
  cellstate_t local_68;
  int local_64;
  cellstate_t local_60;
  cellstate_t local_5c;
  int local_58;
  int local_54;
  cellstate_t local_50;
  cellstate_t local_4c;
  cellstate_t local_48;
  cellstate_t local_44;
  int local_40;
  cellstate_t local_3c;
  int local_38;
  cellstate_t local_34;
  int ret;
  int empty;
  int multiline;
  cellstate_t newstate;
  STable_cellinfo *lastcell;
  
  newstate = CS_invalid;
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 4U) != 0)) {
    iVar2 = s->pending_len;
    iVar3 = me->ncells;
    pFVar4 = TraceFP();
    fprintf((FILE *)pFVar4,
            "TRST:Stbl_finishCellInRow line=%d pos=%d end_td=%d ncells=%d pnd_len=%d\n",lineno,pos,
            end_td,iVar3,iVar2);
  }
  if (me->ncells < 1) {
    return -1;
  }
  pSVar1 = me->cells + me->ncells + -1;
  if ((pSVar1->cLine == lineno) && (s->lineno == lineno)) {
    local_c8 = 0;
  }
  else {
    local_c8 = 1;
  }
  if (local_c8 == 0) {
    bVar7 = pos <= s->x_td;
  }
  else {
    bVar7 = pos == 0;
  }
  local_c4 = (uint)bVar7;
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 4U) != 0)) {
    pcVar5 = cellstate_s(s->state);
    pcVar6 = cellstate_s(s->prev_state);
    iVar2 = s->lineno;
    iVar3 = pSVar1->cLine;
    pFVar4 = TraceFP();
    fprintf((FILE *)pFVar4," [lines: lastCell=%d state=%d multi=%d] empty=%d (prev)state=(%s) %s\n",
            iVar3,iVar2,local_c8,local_c4,pcVar6,pcVar5);
  }
  if (local_c8 == 0) {
    if ((end_td & 1U) != 0) {
      s->x_td = -1;
      switch(s->state) {
      case CS__new:
        ret = -1;
        if ((local_c4 != 0) || (s->prev_state != CS__cbc)) {
          if (local_c4 == 0) {
            if (me->fixed_line == '\0') {
              me->fixed_line = '\x01';
              me->Line = lineno;
            }
            else if (me->Line != lineno) goto trace_and_return;
          }
          if (pSVar1->len < 0) {
            if (local_c4 == 0) {
              local_40 = pos - pSVar1->pos;
            }
            else {
              local_40 = 0;
            }
            pSVar1->len = local_40;
          }
          if (local_c4 == 0) {
            local_3c = CS__cf;
          }
          else {
            local_3c = CS__ef;
          }
          s->state = local_3c;
          if ((me->fixed_line == '\0') || (me->Line == lineno)) {
            local_38 = pSVar1->len;
          }
          else {
            local_38 = -1;
          }
          ret = local_38;
        }
        goto trace_and_return;
      case CS__0eb:
        newstate = CS__0ef;
        break;
      case CS__eb:
        if (local_c4 == 0) {
          local_34 = CS__cf;
        }
        else {
          local_34 = CS__ef;
        }
        newstate = local_34;
        break;
      case CS__0cb:
        if (local_c4 == 0) {
          local_44 = CS__cbc;
        }
        else {
          local_44 = CS__0cf;
        }
        newstate = local_44;
        break;
      case CS__cb:
        newstate = CS__cf;
        break;
      case CS__0ef:
        newstate = CS__0ef;
        break;
      case CS_invalid:
        if ((me->fixed_line == '\0') || (me->Line != pSVar1->cLine)) {
          pSVar1->len = 0;
        }
      case CS__0new:
        if (local_c4 == 0) {
          local_48 = CS__0cf;
        }
        else {
          local_48 = CS__0ef;
        }
        newstate = local_48;
      }
      pSVar1->len = pos - pSVar1->pos;
      goto switchD_080edf17_caseD_6;
    }
    switch(s->state) {
    case CS__new:
      ret = -1;
      if ((local_c4 != 0) || (s->prev_state != CS__cbc)) {
        if (local_c4 == 0) {
          if (me->fixed_line == '\0') {
            me->fixed_line = '\x01';
            me->Line = lineno;
          }
          else if (me->Line != lineno) goto trace_and_return;
        }
        if (local_c4 == 0) {
          local_5c = CS__cb;
        }
        else {
          local_5c = CS__eb;
        }
        s->state = local_5c;
        if (me->fixed_line == '\0') {
          if (local_c4 == 0) {
            local_58 = pos - pSVar1->pos;
          }
          else {
            local_58 = 0;
          }
          s->pending_len = local_58;
          ret = 0;
        }
        else {
          s->pending_len = 0;
          if (local_c4 == 0) {
            local_54 = pos - pSVar1->pos;
          }
          else {
            local_54 = 0;
          }
          pSVar1->len = local_54;
          ret = pSVar1->len;
        }
      }
      goto trace_and_return;
    case CS__0eb:
      newstate = CS__eb;
      break;
    case CS__eb:
      if (local_c4 == 0) {
        local_50 = CS__ebc;
      }
      else {
        local_50 = CS__eb;
      }
      newstate = local_50;
      break;
    case CS__0cb:
      newstate = CS__cb;
      break;
    case CS__cb:
      if (local_c4 == 0) {
        local_4c = CS__cbc;
      }
      else {
        local_4c = CS__cb;
      }
      newstate = local_4c;
      break;
    case CS__ef:
      ret = 0;
      goto trace_and_return;
    case CS__cf:
      ret = pSVar1->len;
      goto trace_and_return;
    case CS_invalid:
    case CS__0new:
      if (local_c4 == 0) {
        local_64 = pos - pSVar1->pos;
      }
      else {
        local_64 = 0;
      }
      s->pending_len = local_64;
      if (local_c4 == 0) {
        local_60 = CS__0cb;
      }
      else {
        local_60 = CS__0eb;
      }
      s->state = local_60;
      ret = 0;
      goto trace_and_return;
    }
    goto switchD_080edf17_caseD_6;
  }
  if ((end_td & 1U) != 0) {
    s->x_td = -1;
    switch(s->state) {
    case CS__new:
      if (local_c4 == 0) {
        local_7c = CS__cf;
      }
      else {
        local_7c = CS__ef;
      }
      newstate = local_7c;
      break;
    case CS__0new:
      if (local_c4 == 0) {
        local_8c = CS__0cf;
      }
      else {
        local_8c = CS__0ef;
      }
      newstate = local_8c;
      break;
    case CS__0eb:
      if (local_c4 == 0) {
        local_88 = CS__0cf;
      }
      else {
        local_88 = CS__0ef;
      }
      s->state = local_88;
      if (me->fixed_line == '\0') {
        if (local_c4 == 0) {
          ret = 0;
        }
        else {
          ret = ~(pSVar1->len >> 0x1f) & pSVar1->len;
        }
      }
      else if (local_c4 == 0) {
        if (pSVar1->len < 1) {
          local_84 = 0;
        }
        else {
          local_84 = -1;
        }
        ret = local_84;
      }
      else {
        ret = ~(pSVar1->len >> 0x1f) & pSVar1->len;
      }
      goto trace_and_return;
    case CS__eb:
      s->state = CS__ef;
      if (me->fixed_line == '\0') {
        if (local_c4 == 0) {
          if (pSVar1->len < 1) {
            local_74 = 0;
          }
          else {
            local_74 = -1;
          }
          ret = local_74;
        }
        else {
          ret = ~(pSVar1->len >> 0x1f) & pSVar1->len;
        }
      }
      else if (local_c4 == 0) {
        if (pSVar1->len < 1) {
          local_78 = 0;
        }
        else {
          local_78 = -1;
        }
        ret = local_78;
      }
      else {
        ret = ~(pSVar1->len >> 0x1f) & pSVar1->len;
      }
      goto trace_and_return;
    case CS__0cb:
      if (s->pending_len != 0) {
        if (local_c4 == 0) {
          pSVar1->len = 0;
        }
        else {
          pSVar1->len = s->pending_len;
        }
        s->pending_len = 0;
      }
      if (me->fixed_line == '\0') {
        if (local_c4 == 0) {
          if (s->icell_core == -1) {
            me->Line = -1;
          }
        }
        else if (s->icell_core == -1) {
          s->icell_core = me->ncells + -1;
        }
      }
      if ((s->pending_len != 0) && (local_c4 != 0)) {
        pSVar1->len = s->pending_len;
        s->pending_len = 0;
      }
      if (local_c4 == 0) {
        local_80 = CS__cbc;
      }
      else {
        local_80 = CS__0cf;
      }
      newstate = local_80;
      break;
    case CS__cb:
      if ((s->pending_len != 0) && (local_c4 != 0)) {
        pSVar1->len = s->pending_len;
        s->pending_len = 0;
      }
      ret = -1;
      if (local_c4 == 0) goto trace_and_return;
      if (me->fixed_line == '\0') {
        me->fixed_line = '\x01';
        me->Line = pSVar1->cLine;
      }
      else if (me->Line != pSVar1->cLine) goto trace_and_return;
      if (local_c4 == 0) {
        local_70 = CS__cbc;
      }
      else {
        local_70 = CS__cf;
      }
      newstate = local_70;
      break;
    case CS__0ef:
      newstate = CS__0ef;
      break;
    case CS__ebc:
      pSVar1->len = 0;
      if (((me->fixed_line == '\0') && (local_c4 == 0)) && (s->icell_core == -1)) {
        pSVar1->cLine = -1;
      }
      s->pending_len = 0;
      if (local_c4 == 0) {
        local_6c = CS__cbc;
      }
      else {
        local_6c = CS_invalid;
      }
      newstate = local_6c;
      break;
    case CS__cbc:
      pSVar1->len = 0;
      ret = -1;
      if ((me->fixed_line != '\0') && (me->Line == pSVar1->cLine)) goto trace_and_return;
      if ((me->fixed_line == '\0') && ((local_c4 != 0 && (s->icell_core == -1)))) {
        me->Line = lineno;
      }
      s->pending_len = 0;
      if (local_c4 == 0) {
        local_68 = CS__cbc;
      }
      else {
        local_68 = CS_invalid;
      }
      newstate = local_68;
      break;
    case CS_invalid:
      if ((local_c4 == 0) && (0 < pSVar1->len)) {
        s->state = CS__0cf;
        ret = -1;
        goto trace_and_return;
      }
      pSVar1->len = 0;
      pSVar1->cLine = -1;
      if (local_c4 == 0) {
        local_90 = CS__cbc;
      }
      else {
        local_90 = CS_invalid;
      }
      newstate = local_90;
    }
    goto switchD_080edf17_caseD_6;
  }
  switch(s->state) {
  case CS__new:
    if (local_c4 == 0) {
      local_a8 = CS__cb;
    }
    else {
      local_a8 = CS__eb;
    }
    newstate = local_a8;
    break;
  case CS__0new:
    if (local_c4 == 0) {
      local_b8 = CS__0cb;
    }
    else {
      local_b8 = CS__0eb;
    }
    newstate = local_b8;
    break;
  case CS__0eb:
    if (local_c4 == 0) {
      local_b4 = CS__ebc;
    }
    else {
      local_b4 = CS__0eb;
    }
    s->state = local_b4;
    if (me->fixed_line == '\0') {
      if (local_c4 == 0) {
        ret = 0;
      }
      else {
        ret = ~(pSVar1->len >> 0x1f) & pSVar1->len;
      }
    }
    else if (local_c4 == 0) {
      if (pSVar1->len < 1) {
        local_b0 = 0;
      }
      else {
        local_b0 = -1;
      }
      ret = local_b0;
    }
    else {
      ret = ~(pSVar1->len >> 0x1f) & pSVar1->len;
    }
    goto trace_and_return;
  case CS__eb:
    if (local_c4 == 0) {
      local_a4 = CS__ebc;
    }
    else {
      local_a4 = CS__eb;
    }
    s->state = local_a4;
    if (me->fixed_line == '\0') {
      if (local_c4 == 0) {
        if (pSVar1->len < 1) {
          local_9c = 0;
        }
        else {
          local_9c = -1;
        }
        ret = local_9c;
      }
      else {
        ret = ~(pSVar1->len >> 0x1f) & pSVar1->len;
      }
    }
    else if (local_c4 == 0) {
      if (pSVar1->len < 1) {
        local_a0 = 0;
      }
      else {
        local_a0 = -1;
      }
      ret = local_a0;
    }
    else {
      ret = ~(pSVar1->len >> 0x1f) & pSVar1->len;
    }
    goto trace_and_return;
  case CS__0cb:
    if (((me->fixed_line == '\0') && (local_c4 == 0)) && (s->icell_core == -1)) {
      me->Line = -1;
    }
    if ((s->pending_len != 0) && (local_c4 != 0)) {
      if (((me->fixed_line != '\0') && (me->Line == pSVar1->cLine)) ||
         (s->icell_core == me->ncells + -1)) {
        pSVar1->len = s->pending_len;
      }
      s->pending_len = 0;
    }
    if (local_c4 == 0) {
      local_ac = CS__cbc;
    }
    else {
      local_ac = CS__0cb;
    }
    newstate = local_ac;
    break;
  case CS__cb:
    if ((s->pending_len != 0) && (local_c4 != 0)) {
      pSVar1->len = s->pending_len;
      s->pending_len = 0;
    }
    ret = -1;
    if (local_c4 == 0) {
      if (me->fixed_line == '\0') {
        me->fixed_line = '\x01';
        me->Line = pSVar1->cLine;
      }
      s->state = CS__cbc;
      goto trace_and_return;
    }
    if (me->fixed_line == '\0') {
      me->fixed_line = '\x01';
      me->Line = pSVar1->cLine;
    }
    else if (me->Line != pSVar1->cLine) goto trace_and_return;
    if (local_c4 == 0) {
      local_98 = CS__cbc;
    }
    else {
      local_98 = CS__cb;
    }
    newstate = local_98;
    break;
  case CS__ef:
    ret = 0;
    goto trace_and_return;
  case CS__cf:
    ret = pSVar1->len;
    goto trace_and_return;
  case CS__cbc:
    if (me->fixed_line == '\0') {
      if (local_c4 == 0) {
        if (s->icell_core == -1) {
          me->Line = -1;
        }
      }
      else if (s->icell_core == -1) {
        me->Line = lineno;
      }
    }
    s->pending_len = 0;
    if (local_c4 == 0) {
      local_94 = CS__cbc;
    }
    else {
      local_94 = CS_invalid;
    }
    newstate = local_94;
    break;
  case CS_invalid:
    if (local_c4 == 0) {
      local_bc = CS__cbc;
    }
    else {
      local_bc = CS_invalid;
    }
    newstate = local_bc;
  }
switchD_080edf17_caseD_6:
  s->state = newstate;
  ret = pSVar1->len;
  if (((nested_tables != '\0') && (ret == -1)) && (pos == 0)) {
    ret = 0;
  }
trace_and_return:
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 4U) != 0)) {
    pcVar5 = cellstate_s(s->state);
    pcVar6 = cellstate_s(s->prev_state);
    pFVar4 = TraceFP();
    fprintf((FILE *)pFVar4," => prev_state=%s, state=%s, return=%d\n",pcVar6,pcVar5,ret);
  }
  return ret;
}



// WARNING: Unknown calling convention

int Stbl_reserveCellsInTable(STable_info *me,int icell,int colspan,int rowspan)

{
  FILE *pFVar1;
  STable_cellinfo *pSVar2;
  STable_rowinfo *pSVar3;
  int iVar4;
  int iVar5;
  int local_28;
  size_t local_24;
  size_t local_1c;
  int local_18;
  int i;
  int growby;
  STable_rowinfo *row;
  STable_rowinfo *rows;
  
  if (colspan < 0xc9) {
    if (rowspan < 0xc9) {
      if (me->nrows < 1) {
        local_28 = -1;
      }
      else {
        if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 4U) != 0)) {
          pFVar1 = TraceFP();
          fprintf((FILE *)pFVar1,"TRST:Stbl_reserveCellsInTable(icell=%d, colspan=%d, rowspan=%d)\n"
                  ,icell,colspan,rowspan);
        }
        if (rowspan == 0) {
          if ((me->rowspans2eog).cells == (STable_cellinfo *)0x0) {
            local_24 = icell + colspan;
            if ((int)local_24 < 1) {
              local_24 = 1;
            }
            pSVar2 = (STable_cellinfo *)calloc(local_24,0x14);
            (me->rowspans2eog).cells = pSVar2;
            if ((me->rowspans2eog).cells == (STable_cellinfo *)0x0) {
              return 0;
            }
            (me->rowspans2eog).allocated = icell + colspan;
          }
          Stbl_reserveCellsInRow(&me->rowspans2eog,icell,colspan);
        }
        iVar4 = (me->nrows + rowspan + -1) - me->allocated_rows;
        if (0 < iVar4) {
          pSVar3 = (STable_rowinfo *)realloc(me->rows,(me->allocated_rows + iVar4) * 0x24);
          if (pSVar3 == (STable_rowinfo *)0x0) {
            return 0;
          }
          for (i = 0; i < iVar4; i = i + 1) {
            iVar5 = me->allocated_rows + i;
            pSVar3[iVar5].allocated = 0;
            pSVar3[iVar5].offset = 0;
            pSVar3[iVar5].content = 0;
            if ((me->rowspans2eog).allocated == 0) {
              pSVar3[iVar5].cells = (STable_cellinfo *)0x0;
            }
            else {
              pSVar2 = (STable_cellinfo *)calloc((me->rowspans2eog).allocated,0x14);
              pSVar3[iVar5].cells = pSVar2;
              if (pSVar3[iVar5].cells != (STable_cellinfo *)0x0) {
                pSVar3[iVar5].allocated = (me->rowspans2eog).allocated;
                memcpy(pSVar3[iVar5].cells,(me->rowspans2eog).cells,pSVar3[iVar5].allocated * 0x14);
              }
            }
            pSVar3[iVar5].ncells = 0;
            pSVar3[iVar5].fixed_line = '\0';
            pSVar3[iVar5].alignment = -1;
          }
          me->allocated_rows = me->allocated_rows + iVar4;
          me->rows = pSVar3;
        }
        i = me->nrows;
        while( true ) {
          if (rowspan == 0) {
            local_18 = me->allocated_rows;
          }
          else {
            local_18 = me->nrows + rowspan + -1;
          }
          if (local_18 <= i) break;
          if (me->rows[i].allocated == 0) {
            pSVar3 = me->rows;
            local_1c = icell + colspan;
            if ((int)local_1c < 1) {
              local_1c = 1;
            }
            pSVar2 = (STable_cellinfo *)calloc(local_1c,0x14);
            pSVar3[i].cells = pSVar2;
            if (me->rows[i].cells == (STable_cellinfo *)0x0) {
              return 0;
            }
            me->rows[i].allocated = icell + colspan;
          }
          Stbl_reserveCellsInRow(me->rows + i,icell,colspan);
          i = i + 1;
        }
        local_28 = 0;
      }
    }
    else {
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 4U) != 0)) {
        pFVar1 = TraceFP();
        fprintf((FILE *)pFVar1,"TRST:*** ROWSPAN=%d is too large, ignored!\n",rowspan);
      }
      local_28 = -1;
    }
  }
  else {
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 4U) != 0)) {
      pFVar1 = TraceFP();
      fprintf((FILE *)pFVar1,"TRST:*** COLSPAN=%d is too large, ignored!\n",colspan);
    }
    local_28 = -1;
  }
  return local_28;
}



// WARNING: Unknown calling convention

void Stbl_cancelRowSpans(STable_info *me)

{
  FILE *__stream;
  int i;
  
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 4U) != 0)) {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"TRST:Stbl_cancelRowSpans()");
  }
  for (i = me->nrows; i < me->allocated_rows; i = i + 1) {
    if (me->rows[i].ncells == 0) {
      if (me->rows[i].cells != (STable_cellinfo *)0x0) {
        free(me->rows[i].cells);
        me->rows[i].cells = (STable_cellinfo *)0x0;
      }
      me->rows[i].allocated = 0;
    }
  }
  free_rowinfo(&me->rowspans2eog);
  (me->rowspans2eog).allocated = 0;
  return;
}



// WARNING: Unknown calling convention

int Stbl_addRowToTable(STable_info *me,int alignment,int lineno)

{
  short sVar1;
  FILE *__stream;
  STable_cellinfo *pSVar2;
  int iVar3;
  int local_2c;
  int growby;
  int i;
  STable_states *s;
  STable_rowinfo *row;
  STable_rowinfo *rows;
  
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 4U) != 0)) {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"TRST:Stbl_addRowToTable(alignment=%d, lineno=%d)\n",alignment,lineno);
  }
  if ((0 < me->nrows) && (0 < me->rows[me->nrows + -1].ncells)) {
    if (0 < (me->s).pending_len) {
      me->rows[me->nrows + -1].cells[me->rows[me->nrows + -1].ncells + -1].len = (me->s).pending_len
      ;
    }
    (me->s).pending_len = 0;
  }
  Stbl_finishRowInTable(me);
  if ((0 < me->nrows) && (me->rows[me->nrows + -1].Line == lineno)) {
    me->rows[me->nrows + -1].Line = -1;
  }
  (me->s).pending_len = 0;
  (me->s).x_td = -1;
  for (growby = 0; me->allocated_rows + growby < me->nrows + 2; growby = growby + 0x10) {
  }
  if (growby != 0) {
    if ((me->allocated_rows != 0) || (me->rows != (STable_rowinfo *)0x0)) {
      rows = (STable_rowinfo *)realloc(me->rows,(me->allocated_rows + growby) * 0x24);
      i = 0;
      do {
        if ((rows == (STable_rowinfo *)0x0) || (growby <= i)) goto LAB_080ef3ae;
        iVar3 = me->allocated_rows + i;
        if ((me->rowspans2eog).allocated == 0) {
          rows[iVar3].allocated = 0;
          rows[iVar3].cells = (STable_cellinfo *)0x0;
        }
        else {
          pSVar2 = (STable_cellinfo *)calloc((me->rowspans2eog).allocated,0x14);
          rows[iVar3].cells = pSVar2;
          if (rows[iVar3].cells == (STable_cellinfo *)0x0) {
            if (rows != (STable_rowinfo *)0x0) {
              free(rows);
              rows = (STable_rowinfo *)0x0;
            }
            goto LAB_080ef3ae;
          }
          rows[iVar3].allocated = (me->rowspans2eog).allocated;
          memcpy(rows[iVar3].cells,(me->rowspans2eog).cells,rows[iVar3].allocated * 0x14);
        }
        rows[iVar3].ncells = 0;
        rows[iVar3].fixed_line = '\0';
        rows[iVar3].alignment = -1;
        rows[iVar3].offset = 0;
        rows[iVar3].content = 0;
        i = i + 1;
      } while( true );
    }
    rows = (STable_rowinfo *)calloc(growby,0x24);
LAB_080ef3ae:
    if (rows == (STable_rowinfo *)0x0) {
      return -1;
    }
    me->allocated_rows = me->allocated_rows + growby;
    me->rows = rows;
  }
  me->rows[me->nrows].Line = lineno;
  if (me->nrows == 0) {
    me->startline = lineno;
  }
  if (alignment == -1) {
    if (me->rowgroup_align == -1) {
      sVar1 = me->alignment;
    }
    else {
      sVar1 = me->rowgroup_align;
    }
    local_2c = (int)sVar1;
    me->rows[me->nrows].alignment = local_2c;
  }
  else {
    me->rows[me->nrows].alignment = alignment;
  }
  me->nrows = me->nrows + 1;
  if (me->ncolinfo < me->pending_colgroup_next) {
    me->ncolinfo = me->pending_colgroup_next;
    me->pending_colgroup_next = 0;
  }
  me->rows[me->nrows].Line = -1;
  me->rows[me->nrows].ended = ROW_not_ended;
  return me->nrows + -1;
}



// WARNING: Unknown calling convention

int Stbl_finishRowInTable(STable_info *me)

{
  STable_rowinfo *pSVar1;
  FILE *__stream;
  int local_18;
  int ncells;
  STable_states *s;
  STable_rowinfo *lastrow;
  
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 4U) != 0)) {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"TRST:Stbl_finishRowInTable()\n");
  }
  if ((me->rows == (STable_rowinfo *)0x0) || (me->nrows == 0)) {
    local_18 = -1;
  }
  else {
    pSVar1 = me->rows + me->nrows + -1;
    pSVar1->ended = ROW_ended_by_endtr;
    if (0 < pSVar1->ncells) {
      if (0 < (me->s).pending_len) {
        pSVar1->cells[pSVar1->ncells + -1].len = (me->s).pending_len;
      }
      (me->s).pending_len = 0;
    }
    (me->s).state = CS_invalid;
    (me->s).prev_state = (me->s).state;
    (me->s).lineno = -1;
    if (((-1 < (me->s).icell_core) && (pSVar1->fixed_line == '\0')) &&
       (-1 < pSVar1->cells[(me->s).icell_core].cLine)) {
      pSVar1->Line = pSVar1->cells[(me->s).icell_core].cLine;
    }
    (me->s).icell_core = -1;
    local_18 = me->nrows;
  }
  return local_18;
}



// WARNING: Unknown calling convention

void update_sumcols0(STable_cellinfo *sumcols,STable_rowinfo *lastrow,int pos,int len,int icell,
                    int ispan,int allocated_sumcols)

{
  int local_18;
  int advance;
  int prevsumpos;
  int sumpos;
  int i;
  
  if (0 < len) {
    sumpos = pos;
    if (0 < ispan) {
      if (pos < lastrow->cells[icell].pos + len) {
        sumpos = lastrow->cells[icell].pos + len;
      }
      if (sumpos < sumcols[icell + ispan + -1].pos + sumcols[icell + ispan + -1].len) {
        sumpos = sumcols[icell + ispan + -1].pos + sumcols[icell + ispan + -1].len;
      }
    }
    advance = sumpos - sumcols[icell + ispan].pos;
    if (0 < advance) {
      for (i = icell + ispan; i < allocated_sumcols; i = i + 1) {
        if (((0 < ispan) && (sumcols[i].colspan < -1)) && (sumcols[i].colspan + i < icell + ispan))
        {
          advance = sumpos - sumcols[i].pos;
          if (0 < i) {
            local_18 = (sumcols[i + -1].pos + sumcols[i + -1].len) - sumcols[i].pos;
            if (local_18 < advance) {
              local_18 = advance;
            }
            advance = local_18;
          }
          if (advance < 1) {
            return;
          }
        }
        if (sumcols[i].pos < 0) {
          sumcols[i].pos = sumpos;
          return;
        }
        sumcols[i].pos = sumcols[i].pos + advance;
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

int get_remaining_colspan
              (STable_rowinfo *me,STable_cellinfo *colinfo,int ncolinfo,int colspan,int ncols_sofar)

{
  FILE *__stream;
  int local_1c;
  int local_18;
  int last_colspan;
  int i;
  
  if (me->ncells == 0) {
    local_18 = 1;
  }
  else {
    local_18 = me->cells[me->ncells + -1].colspan;
  }
  if ((ncolinfo == 0) || (ncolinfo < me->ncells + local_18)) {
    local_1c = (1 - (me->ncells + local_18)) + ncols_sofar;
    if (200 < local_1c) {
      local_1c = 200;
    }
    colspan = local_1c;
  }
  else {
    for (i = me->ncells + local_18 + -1; (i < ncolinfo + -1 && (colinfo[i].cLine != -2)); i = i + 1)
    {
    }
    colspan = (2 - (me->ncells + local_18)) + i;
  }
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 4U) != 0)) {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"TRST:get_remaining_colspan; colspan = %d\n",colspan);
  }
  return colspan;
}



// WARNING: Unknown calling convention

int Stbl_fakeFinishCellInTable(STable_info *me,STable_rowinfo *lastrow,int lineno,int finishing)

{
  int iVar1;
  int alignment;
  int iVar2;
  STable_rowinfo *pSVar3;
  STable_rowinfo *pSVar4;
  bool bVar5;
  undefined3 uVar6;
  int iVar7;
  FILE *pFVar8;
  int iVar9;
  STable_rowinfo *pSVar10;
  size_t __nmemb;
  STable_cellinfo *pSVar11;
  STable_rowinfo *pSVar12;
  STable_rowinfo *pSVar13;
  int local_60;
  char *local_5c;
  int local_58;
  int n;
  int need_cells;
  STable_rowinfo *rows;
  int prev_row_n;
  int prev_row_n2;
  STable_rowinfo *prev_row;
  int prev_reserved_last;
  int need_reserved;
  int end_td;
  int ih;
  int rs;
  int cs;
  int al;
  int i;
  int ncells;
  int fake;
  STable_states *s;
  
  bVar5 = false;
  if ((uint)((me->s).state + ~CS__0new) < 4) {
    bVar5 = true;
  }
  else if (finishing == 0) {
    bVar5 = true;
  }
  if (bVar5) {
    iVar1 = lastrow->ncells;
    alignment = lastrow->alignment;
    iVar2 = lastrow->cells[lastrow->ncells + -1].colspan;
    bVar5 = false;
    prev_reserved_last = -1;
    iVar7 = (int)lastrow - (int)me->rows >> 2;
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 4U) != 0)) {
      pFVar8 = TraceFP();
      fprintf((FILE *)pFVar8,
              "TRST:Stbl_fakeFinishCellInTable(lineno=%d, finishing=%d) START FAKING\n",lineno,
              finishing);
    }
    if ((finishing == 0) || (iVar9 = Stbl_finishCellInTable(me,3,lineno,0,0), -1 < iVar9)) {
      iVar9 = Stbl_addRowToTable(me,alignment,lineno);
      if (iVar9 < 0) {
        local_60 = -1;
      }
      else {
        lastrow = me->rows + me->nrows + -1;
        lastrow->content = 4;
        for (i = 0; i < lastrow->allocated; i = i + 1) {
          if (lastrow->cells[i].alignment == -2) {
            bVar5 = true;
            break;
          }
        }
        pSVar3 = me->rows;
        for (i = iVar1; i < (&pSVar3->allocated)[iVar7]; i = i + 1) {
          if ((&pSVar3->cells)[iVar7][i].alignment == -2) {
            prev_reserved_last = i;
          }
        }
        if ((bVar5) || (-1 < prev_reserved_last)) {
          pSVar4 = me->rows;
          pSVar10 = (STable_rowinfo *)realloc(me->rows,(me->allocated_rows + 1) * 0x24);
          __nmemb = prev_reserved_last + 1;
          if (pSVar10 == (STable_rowinfo *)0x0) {
            return -1;
          }
          if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 4U) != 0)) {
            pFVar8 = TraceFP();
            fprintf((FILE *)pFVar8,"TRST:Stbl_fakeFinishCellInTable REALLOC ROWSPAN\n");
          }
          me->rows = pSVar10;
          lastrow = me->rows + me->nrows + -1;
          pSVar10 = me->rows;
          me->allocated_rows = me->allocated_rows + 1;
          iVar9 = me->allocated_rows - me->nrows;
          while (n = iVar9 + -1, -1 < n) {
            pSVar12 = lastrow + iVar9;
            pSVar13 = lastrow + n;
            pSVar12->Line = pSVar13->Line;
            pSVar12->ncells = pSVar13->ncells;
            uVar6 = *(undefined3 *)&pSVar13->field_0x9;
            pSVar12->fixed_line = pSVar13->fixed_line;
            *(undefined3 *)&pSVar12->field_0x9 = uVar6;
            pSVar12->ended = pSVar13->ended;
            pSVar12->content = pSVar13->content;
            pSVar12->offset = pSVar13->offset;
            pSVar12->allocated = pSVar13->allocated;
            pSVar12->cells = pSVar13->cells;
            pSVar12->alignment = pSVar13->alignment;
            iVar9 = n;
          }
          lastrow->allocated = 0;
          lastrow->cells = (STable_cellinfo *)0x0;
          if (__nmemb != 0) {
            pSVar11 = (STable_cellinfo *)calloc(__nmemb,0x14);
            lastrow->cells = pSVar11;
            if (lastrow->cells == (STable_cellinfo *)0x0) {
              return -1;
            }
            lastrow->allocated = __nmemb;
            memcpy(lastrow->cells,(&pSVar10->cells)[(int)pSVar3 + (iVar7 * 4 - (int)pSVar4) >> 2],
                   lastrow->allocated * 0x14);
            i = -1;
            while (i = i + 1, i < iVar1) {
              if (lastrow->cells[i].alignment == -2) {
                lastrow->cells[i].alignment = 1;
              }
            }
          }
        }
        if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 4U) != 0)) {
          if (finishing == 0) {
            local_5c = "";
          }
          else {
            local_5c = ", last unfinished";
          }
          pFVar8 = TraceFP();
          fprintf((FILE *)pFVar8,"TRST:Stbl_fakeFinishCellInTable FAKE %d elts%s\n",iVar1,local_5c);
        }
        i = 0;
        do {
          i = i + 1;
          if (iVar1 < i) {
            if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 4U) != 0)) {
              pFVar8 = TraceFP();
              fprintf((FILE *)pFVar8,"TRST:Stbl_fakeFinishCellInTable(lineno=%d) FINISH FAKING\n",
                      lineno);
            }
            return 1;
          }
          local_58 = iVar2;
          if (i != iVar1) {
            local_58 = 1;
          }
          iVar7 = Stbl_addCellToTable(me,local_58,1,alignment,0,lineno,0,0);
          if (iVar7 < 0) {
            return -1;
          }
          lastrow->content = lastrow->content & 0xfffffffd;
        } while (((finishing != 0) && (i == iVar1)) ||
                (iVar7 = Stbl_finishCellInRow(lastrow,&me->s,3,lineno,0), -1 < iVar7));
        local_60 = -1;
      }
    }
    else {
      local_60 = -1;
    }
  }
  else {
    local_60 = 0;
  }
  return local_60;
}



// WARNING: Unknown calling convention

int Stbl_addCellToTable(STable_info *me,int colspan,int rowspan,int alignment,int isheader,
                       int lineno,int offset_not_used_yet,int pos)

{
  FILE *__stream;
  int iVar1;
  STable_cellinfo *pSVar2;
  int local_44;
  int local_3c;
  int growby;
  int rc;
  int sumpos;
  int ncells;
  int icell;
  int i;
  STable_cellinfo *sumcol;
  STable_cellinfo *sumcols;
  STable_rowinfo *lastrow;
  STable_states *s;
  
  iVar1 = pos;
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 4U) != 0)) {
    __stream = TraceFP();
    fprintf((FILE *)__stream,
            "TRST:Stbl_addCellToTable(lineno=%d, pos=%d, isheader=%d, cs=%d, rs=%d, al=%d)\n",lineno
            ,iVar1,isheader,colspan,rowspan,alignment);
  }
  if ((me->rows == (STable_rowinfo *)0x0) || (me->nrows == 0)) {
    local_44 = -1;
  }
  else {
    if (me->rows[me->nrows + -1].ended != ROW_not_ended) {
      Stbl_addRowToTable(me,alignment,lineno);
    }
    Stbl_finishCellInTable(me,1,lineno,0,pos);
    lastrow = me->rows + me->nrows + -1;
    if ((((nested_tables != '\0') && (pos == 0)) && (0 < lastrow->ncells)) &&
       (lastrow->cells[lastrow->ncells + -1].cLine != lineno)) {
      iVar1 = Stbl_fakeFinishCellInTable(me,lastrow,lineno,0);
      if (iVar1 < 0) {
        return -1;
      }
      if (iVar1 != 0) {
        lastrow = me->rows + me->nrows + -1;
      }
    }
    if (colspan == 0) {
      colspan = get_remaining_colspan(lastrow,me->sumcols,me->ncolinfo,0,me->ncols);
    }
    iVar1 = lastrow->ncells;
    local_44 = Stbl_addCellToRow(lastrow,me->sumcols,me->ncolinfo,&me->s,colspan,alignment,isheader,
                                 lineno,&pos);
    if (-1 < local_44) {
      if ((me->nrows == 1) && (me->startline < lastrow->Line)) {
        me->startline = lastrow->Line;
      }
      if (rowspan != 1) {
        Stbl_reserveCellsInTable(me,local_44,colspan,rowspan);
        lastrow = me->rows + me->nrows + -1;
      }
      lastrow->content = lastrow->content | 2;
      for (growby = 0; me->allocated_sumcols + growby < local_44 + colspan + 1;
          growby = growby + 0x10) {
      }
      if (growby != 0) {
        if ((me->allocated_sumcols == 0) && (me->sumcols == (STable_cellinfo *)0x0)) {
          sumcols = (STable_cellinfo *)calloc(growby,0x14);
        }
        else {
          sumcols = (STable_cellinfo *)realloc(me->sumcols,(me->allocated_sumcols + growby) * 0x14);
          for (i = 0; (sumcols != (STable_cellinfo *)0x0 && (i < growby)); i = i + 1) {
            pSVar2 = sumcols + me->allocated_sumcols + i;
            pSVar2->pos = sumcols[me->allocated_sumcols + -1].pos;
            pSVar2->len = 0;
            pSVar2->colspan = 0;
            pSVar2->cLine = 0;
            pSVar2->alignment = -1;
          }
        }
        if (sumcols == (STable_cellinfo *)0x0) {
          return -1;
        }
        me->allocated_sumcols = me->allocated_sumcols + growby;
        me->sumcols = sumcols;
      }
      if (me->ncols < local_44 + 1) {
        me->ncols = local_44 + 1;
      }
      if ((1 < colspan) && (0 < me->sumcols[local_44 + colspan].colspan + colspan)) {
        me->sumcols[local_44 + colspan].colspan = -colspan;
      }
      sumpos = pos;
      if (0 < iVar1) {
        sumpos = pos + (me->sumcols[iVar1 + -1].pos - lastrow->cells[iVar1 + -1].pos);
      }
      update_sumcols0(me->sumcols,lastrow,sumpos,sumpos - me->sumcols[local_44].pos,local_44,0,
                      me->allocated_sumcols);
      me->maxpos = me->sumcols[me->allocated_sumcols + -1].pos;
      if (LYwideLines == L'\0') {
        local_3c = LYcols - (uint)(LYShowScrollbar != '\0');
      }
      else {
        local_3c = 0x3f5;
      }
      if (local_3c < me->maxpos) {
        local_44 = -1;
      }
      else {
        local_44 = 0;
      }
    }
  }
  return local_44;
}



// WARNING: Unknown calling convention

int Stbl_finishCellInTable(STable_info *me,int end_td,int lineno,int offset,int pos)

{
  FILE *__stream;
  int iVar1;
  int local_5c;
  int local_58;
  int local_54;
  int local_4c;
  int local_44;
  int local_3c;
  int spanlend;
  int spanlen;
  int rc;
  int i;
  int icell;
  int xlen;
  int len;
  STable_rowinfo *lastrow;
  STable_states *s;
  
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 4U) != 0)) {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"TRST:Stbl_finishCellInTable(lineno=%d, pos=%d, off=%d, end_td=%d)\n",
            lineno,pos,offset,end_td);
  }
  if (me->nrows == 0) {
    local_58 = -1;
  }
  else {
    lastrow = me->rows + me->nrows + -1;
    local_58 = lastrow->ncells + -1;
    if (-1 < local_58) {
      if ((me->s).x_td == -1) {
        if ((end_td & 1U) == 0) {
          lastrow->ended = ROW_ended_by_splitline;
        }
        local_58 = 0;
      }
      else {
        icell = local_58;
        if (((nested_tables != '\0') && ((end_td & 2U) == 0)) &&
           (iVar1 = Stbl_fakeFinishCellInTable(me,lastrow,lineno,1), iVar1 != 0)) {
          if (iVar1 < 0) {
            return -1;
          }
          lastrow = me->rows + me->nrows + -1;
          icell = lastrow->ncells + -1;
        }
        len = Stbl_finishCellInRow(lastrow,&me->s,end_td,lineno,pos);
        if (len == -1) {
          local_58 = -1;
        }
        else {
          local_54 = len;
          if (len < 1) {
            local_54 = (me->s).pending_len;
          }
          if (lastrow->Line == lineno) {
            len = local_54;
          }
          if (lastrow->cells[icell].colspan < 2) {
            if (me->sumcols[icell].len < len) {
              if (-2 < me->sumcols[icell + 1].colspan) {
                me->maxlen = me->maxlen + (len - me->sumcols[icell].len);
              }
              me->sumcols[icell].len = len;
            }
          }
          else {
            spanlen = 0;
            spanlend = 0;
            for (i = icell; i < lastrow->cells[icell].colspan + icell; i = i + 1) {
              if ((0 < me->sumcols[i].len) && (spanlen = spanlen + me->sumcols[i].len, icell < i)) {
                spanlen = spanlen + 1;
              }
              local_5c = me->sumcols[i + 1].pos - me->sumcols[icell].pos;
              if (local_5c < spanlend) {
                local_5c = spanlend;
              }
              spanlend = local_5c;
            }
            if (spanlend != 0) {
              spanlend = spanlend + -1;
            }
            if (spanlen < spanlend) {
              spanlen = spanlend;
            }
            if (spanlen < len) {
              me->maxlen = me->maxlen + (len - spanlen);
            }
          }
          if (0 < len) {
            update_sumcols0(me->sumcols,lastrow,pos,len,icell,lastrow->cells[icell].colspan,
                            me->allocated_sumcols);
            me->maxpos = me->sumcols[me->allocated_sumcols + -1].pos;
          }
          if ((end_td & 1U) == 0) {
            lastrow->ended = ROW_ended_by_splitline;
            lastrow->content = lastrow->content | 0x20;
            lastrow->offset = offset;
          }
          if (nested_tables == '\0') {
            if (LYwideLines == L'\0') {
              local_44 = LYcols - (uint)(LYShowScrollbar != '\0');
            }
            else {
              local_44 = 0x3f5;
            }
            if (local_44 < me->maxlen + (local_54 - len)) {
              return -1;
            }
          }
          else {
            if (LYwideLines == L'\0') {
              local_4c = LYcols - (uint)(LYShowScrollbar != '\0');
            }
            else {
              local_4c = 0x3f5;
            }
            if (local_4c < me->maxlen) {
              return -1;
            }
          }
          if (LYwideLines == L'\0') {
            local_3c = LYcols - (uint)(LYShowScrollbar != '\0');
          }
          else {
            local_3c = 0x3f5;
          }
          if (local_3c < me->maxpos) {
            local_58 = -1;
          }
          else {
            local_58 = 0;
          }
        }
      }
    }
  }
  return local_58;
}



int Stbl_addColInfo(STable_info *me,int colspan,short alignment,BOOLEAN isgroup)

{
  int iVar1;
  FILE *__stream;
  STable_cellinfo *pSVar2;
  BOOLEAN isgroup_local;
  short alignment_local;
  int growby;
  int icolinfo;
  int i;
  STable_cellinfo *sumcol;
  STable_cellinfo *sumcols;
  
  alignment_local = alignment;
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 4U) != 0)) {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"TRST:Stbl_addColInfo(cs=%d, al=%d, isgroup=%d)\n",colspan,
            (int)alignment,(int)isgroup);
  }
  if (isgroup == '\0') {
    i = me->pending_colgroup_next;
    while (i = i + -1, me->ncolinfo + colspan <= i) {
      me->sumcols[i].alignment = -1;
    }
    me->pending_colgroup_next = me->ncolinfo + colspan;
  }
  else {
    if (me->ncolinfo < me->pending_colgroup_next) {
      me->ncolinfo = me->pending_colgroup_next;
    }
    me->pending_colgroup_next = me->ncolinfo + colspan;
    if (0 < me->ncolinfo) {
      me->sumcols[me->ncolinfo + -1].cLine = -2;
    }
    me->pending_colgroup_align = alignment;
  }
  iVar1 = me->ncolinfo;
  if (isgroup == '\0') {
    me->ncolinfo = me->ncolinfo + colspan;
  }
  for (growby = 0; me->allocated_sumcols + growby < iVar1 + colspan + 1; growby = growby + 0x10) {
  }
  if (growby != 0) {
    if (me->allocated_sumcols == 0) {
      sumcols = (STable_cellinfo *)calloc(growby,0x14);
    }
    else {
      sumcols = (STable_cellinfo *)realloc(me->sumcols,(me->allocated_sumcols + growby) * 0x14);
      for (i = 0; (sumcols != (STable_cellinfo *)0x0 && (i < growby)); i = i + 1) {
        pSVar2 = sumcols + me->allocated_sumcols + i;
        pSVar2->pos = sumcols[me->allocated_sumcols + -1].pos;
        pSVar2->len = 0;
        pSVar2->colspan = 0;
        pSVar2->cLine = 0;
      }
    }
    if (sumcols == (STable_cellinfo *)0x0) {
      return -1;
    }
    me->allocated_sumcols = me->allocated_sumcols + growby;
    me->sumcols = sumcols;
  }
  i = iVar1;
  if (alignment == -1) {
    alignment_local = me->pending_colgroup_align;
  }
  for (; i < iVar1 + colspan; i = i + 1) {
    me->sumcols[i].alignment = (int)alignment_local;
  }
  return 0;
}



// WARNING: Unknown calling convention

int Stbl_finishColGroup(STable_info *me)

{
  FILE *__stream;
  
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 4U) != 0)) {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"TRST:Stbl_finishColGroup()\n");
  }
  if ((me->ncolinfo <= me->pending_colgroup_next) &&
     (me->ncolinfo = me->pending_colgroup_next, 0 < me->ncolinfo)) {
    me->sumcols[me->ncolinfo + -1].cLine = -2;
  }
  me->pending_colgroup_next = 0;
  me->pending_colgroup_align = -1;
  return 0;
}



int Stbl_addRowGroup(STable_info *me,short alignment)

{
  FILE *__stream;
  short alignment_local;
  
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 4U) != 0)) {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"TRST:Stbl_addRowGroup()\n");
  }
  Stbl_cancelRowSpans(me);
  me->rowgroup_align = alignment;
  return 0;
}



// WARNING: Unknown calling convention

int Stbl_finishTABLE(STable_info *me)

{
  int iVar1;
  ended_state eVar2;
  bool bVar3;
  FILE *pFVar4;
  int iVar5;
  int local_58;
  int local_54;
  int local_50;
  int curwid;
  int curcell;
  int max_width;
  int foundcell;
  int have_offsets;
  int minoffset;
  STable_rowinfo *nextrow;
  int non_empty;
  int leading;
  int j;
  int curpos;
  int i;
  STable_states *s;
  
  curpos = 0;
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 4U) != 0)) {
    pFVar4 = TraceFP();
    fprintf((FILE *)pFVar4,"TRST:Stbl_finishTABLE()\n");
  }
  if (((me == (STable_info *)0x0) || (me->nrows < 1)) || (me->ncols < 1)) {
    local_58 = -1;
  }
  else {
    if ((0 < me->nrows) && (0 < me->rows[me->nrows + -1].ncells)) {
      if (0 < (me->s).pending_len) {
        me->rows[me->nrows + -1].cells[me->rows[me->nrows + -1].ncells + -1].len =
             (me->s).pending_len;
      }
      (me->s).pending_len = 0;
    }
    Stbl_finishRowInTable(me);
    for (i = 0; i < me->nrows + -1; i = i + 1) {
      j = i + 1;
      non_empty = 0;
      nextrow = me->rows + j;
      iVar5 = i;
      if ((nextrow->content & 0x26U) == 0x24) {
        minoffset = nextrow[-1].offset;
        if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 4U) != 0)) {
          eVar2 = nextrow[-1].ended;
          iVar5 = nextrow[-1].offset;
          pFVar4 = TraceFP();
          fprintf((FILE *)pFVar4,"TRST:Stbl_finishTABLE, l=%d, offset=%d, ended=%u.\n",i,iVar5,eVar2
                 );
        }
        for (; (j < me->nrows && ((nextrow->content & 0x26U) == 0x24)); nextrow = nextrow + 1) {
          if (nextrow->offset < minoffset) {
            minoffset = nextrow->offset;
          }
          if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 4U) != 0)) {
            eVar2 = nextrow[-1].ended;
            iVar5 = nextrow->offset;
            pFVar4 = TraceFP();
            fprintf((FILE *)pFVar4,"TRST:Stbl_finishTABLE, l=%d, offset=%d, ended=%u.\n",j,iVar5,
                    eVar2);
          }
          j = j + 1;
        }
        iVar5 = j + -1;
        j = i;
        nextrow = me->rows + i;
        bVar3 = false;
        nextrow->content = nextrow->content | 0x10;
        for (; j <= iVar5; j = j + 1) {
          nextrow->offset = nextrow->offset - minoffset;
          nextrow->content = nextrow->content | 8;
          if (nextrow->offset != 0) {
            bVar3 = true;
          }
          nextrow = nextrow + 1;
        }
        if (bVar3) {
          foundcell = -1;
          j = i + 1;
          nextrow = me->rows + j;
          for (; (foundcell == -1 && (j <= iVar5)); j = j + 1) {
            curcell = -1;
            while ((foundcell == -1 && (curcell = curcell + 1, curcell < nextrow->ncells))) {
              if (nextrow->cells[curcell].len != 0) {
                non_empty = j;
                foundcell = curcell;
              }
            }
            nextrow = nextrow + 1;
          }
          if (foundcell != -1) {
            max_width = 0;
            j = i;
            nextrow = me->rows + i;
            for (; j <= iVar5; j = j + 1) {
              if ((foundcell < nextrow->ncells) &&
                 (iVar1 = nextrow->cells[foundcell].len + nextrow->offset, max_width < iVar1)) {
                max_width = iVar1;
              }
              nextrow = nextrow + 1;
            }
            update_sumcols0(me->sumcols,me->rows + non_empty,0,max_width,foundcell,
                            me->rows[non_empty].cells[foundcell].colspan,me->allocated_sumcols);
            j = i;
            nextrow = me->rows + i;
            for (; j <= iVar5; j = j + 1) {
              if (foundcell < nextrow->ncells) {
                nextrow->cells[foundcell].len = max_width;
              }
              nextrow = nextrow + 1;
            }
          }
        }
      }
      i = iVar5;
    }
    for (i = 0; i < me->ncols; i = i + 1) {
      if (me->sumcols[i].pos < curpos) {
        me->sumcols[i].pos = curpos;
      }
      else {
        curpos = me->sumcols[i].pos;
      }
      if (0 < me->sumcols[i].len) {
        curpos = curpos + me->sumcols[i].len;
      }
    }
    if (LYwideLines == L'\0') {
      local_50 = LYcols - (uint)(LYShowScrollbar != '\0');
    }
    else {
      local_50 = 0x3f5;
    }
    if (local_50 < curpos) {
      local_54 = -1;
    }
    else {
      local_54 = me->ncols;
    }
    local_58 = local_54;
  }
  return local_58;
}



// WARNING: Unknown calling convention

short Stbl_getAlignment(STable_info *me)

{
  short local_6;
  
  if (me == (STable_info *)0x0) {
    local_6 = -1;
  }
  else {
    local_6 = me->alignment;
  }
  return local_6;
}



// WARNING: Unknown calling convention

int get_fixup_positions(STable_rowinfo *me,int *oldpos,int *newpos,STable_cellinfo *sumcols)

{
  STable_cellinfo *pSVar1;
  int iVar2;
  int local_38;
  int local_34;
  int local_30;
  int offset;
  int ninserts;
  int newlen;
  int next_i;
  int ip;
  int i;
  
  i = 0;
  ip = 0;
  if (me == (STable_rowinfo *)0x0) {
    local_34 = -1;
  }
  else {
    do {
      while( true ) {
        if (me->ncells <= i) goto LAB_080f1726;
        local_30 = me->cells[i].colspan;
        if (local_30 < 1) {
          local_30 = 1;
        }
        local_30 = local_30 + i;
        if (me->cells[i].cLine != me->Line) break;
        oldpos[ip] = me->cells[i].pos;
        if (((me->content & 8U) == 0) || ((me->ncells + -1 != i && ((me->content & 0x10U) != 0)))) {
          offset = 0;
        }
        else {
          offset = me->offset;
        }
        newpos[ip] = sumcols[i].pos + offset;
        if (((me->cells[i].alignment == 3) || (me->cells[i].alignment == 2)) &&
           (0 < me->cells[i].len)) {
          iVar2 = (sumcols[local_30].pos - newpos[ip]) + -1;
          local_38 = sumcols[i].len;
          if (sumcols[i].len < iVar2) {
            local_38 = iVar2;
          }
          if (me->cells[i].len < local_38) {
            if (me->cells[i].alignment == 2) {
              newpos[ip] = newpos[ip] + (local_38 - me->cells[i].len);
            }
            else {
              newpos[ip] = newpos[ip] + (local_38 - me->cells[i].len) / 2;
            }
          }
        }
        ip = ip + 1;
        i = local_30;
      }
      pSVar1 = me->cells + i;
      i = local_30;
    } while (pSVar1->cLine <= me->Line);
LAB_080f1726:
    local_34 = ip;
  }
  return local_34;
}



// WARNING: Unknown calling convention

int Stbl_getFixupPositions(STable_info *me,int lineno,int *oldpos,int *newpos)

{
  int local_18;
  int ninserts;
  int j;
  STable_rowinfo *row;
  
  ninserts = -1;
  if ((me == (STable_info *)0x0) || (me->nrows == 0)) {
    local_18 = -1;
  }
  else {
    for (j = 0; j < me->nrows; j = j + 1) {
      if (me->rows[j].Line == lineno) {
        ninserts = get_fixup_positions(me->rows + j,oldpos,newpos,me->sumcols);
        break;
      }
    }
    local_18 = ninserts;
  }
  return local_18;
}



// WARNING: Unknown calling convention

int Stbl_getStartLine(STable_info *me)

{
  int local_8;
  
  if (me == (STable_info *)0x0) {
    local_8 = -1;
  }
  else {
    local_8 = me->startline;
  }
  return local_8;
}



// WARNING: Unknown calling convention

int Stbl_getStartLineDeep(STable_info *me)

{
  int local_8;
  
  if (me == (STable_info *)0x0) {
    local_8 = -1;
  }
  else {
    for (; me->enclosing != (_STable_info *)0x0; me = me->enclosing) {
    }
    local_8 = me->startline;
  }
  return local_8;
}



// WARNING: Unknown calling convention

void Stbl_update_enclosing(STable_info *me,int max_width,int last_lineno)

{
  _STable_info *p_Var1;
  FILE *pFVar2;
  int iVar3;
  STable_info *enclosing;
  STable_info *stbl;
  int l;
  
  if (((me != (STable_info *)0x0) && (me->enclosing != (_STable_info *)0x0)) && (max_width != 0)) {
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 4U) != 0)) {
      iVar3 = me->startline;
      pFVar2 = TraceFP();
      fprintf((FILE *)pFVar2,"TRST:Stbl_update_enclosing, width=%d, lines=%d...%d.\n",max_width,
              iVar3,last_lineno);
    }
    for (l = me->startline; l <= last_lineno; l = l + 1) {
      iVar3 = Stbl_finishCellInTable(me->enclosing,0,l,0,max_width);
      if (iVar3 < 0) {
        stbl = me->enclosing;
        if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 4U) != 0)) {
          pFVar2 = TraceFP();
          fprintf((FILE *)pFVar2,"TRST:Stbl_update_enclosing: width too large, aborting enclosing\n"
                 );
        }
        me->enclosing = (_STable_info *)0x0;
        while (stbl != (STable_info *)0x0) {
          p_Var1 = stbl->enclosing;
          Stbl_free(stbl);
          stbl = p_Var1;
        }
        return;
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

void Stbl_set_enclosing(STable_info *me,STable_info *enclosing,
                       _TextAnchor *enclosing_last_anchor_before_stbl)

{
  if (me != (STable_info *)0x0) {
    me->enclosing = enclosing;
    me->enclosing_last_anchor_before_stbl = enclosing_last_anchor_before_stbl;
  }
  return;
}



// WARNING: Unknown calling convention

STable_info * Stbl_get_enclosing(STable_info *me)

{
  STable_info *local_8;
  
  if (me == (STable_info *)0x0) {
    local_8 = (STable_info *)0x0;
  }
  else {
    local_8 = me->enclosing;
  }
  return local_8;
}



// WARNING: Unknown calling convention

_TextAnchor * Stbl_get_last_anchor_before(STable_info *me)

{
  _TextAnchor *local_8;
  
  if (me == (STable_info *)0x0) {
    local_8 = (_TextAnchor *)0x0;
  }
  else {
    local_8 = me->enclosing_last_anchor_before_stbl;
  }
  return local_8;
}



// WARNING: Unknown calling convention

void date_error(char *s)

{
  return;
}



// WARNING: Unknown calling convention

time_t ToSeconds(time_t Hours,time_t Minutes,time_t Seconds,MERIDIAN Meridian)

{
  int local_8;
  
  if ((((Minutes < 0) || (0x3b < Minutes)) || (Seconds < 0)) || (0x3d < Seconds)) {
    local_8 = -1;
  }
  else {
    if (Meridian == MER24) {
      if ((Hours < 0) || (0x17 < Hours)) {
        return -1;
      }
    }
    else {
      if ((Hours < 1) || (0xc < Hours)) {
        return -1;
      }
      if (Hours == 0xc) {
        Hours = 0;
      }
      if (Meridian == MERpm) {
        Hours = Hours + 0xc;
      }
    }
    local_8 = Seconds + (Hours * 0x3c + Minutes) * 0x3c;
  }
  return local_8;
}



// WARNING: Unknown calling convention

time_t Convert(time_t Month,time_t Day,time_t Year,time_t Hours,time_t Minutes,time_t Seconds,
              MERIDIAN Meridian,DSTMODE dst)

{
  time_t tVar1;
  tm *ptVar2;
  time_t tod;
  time_t Julian;
  int i;
  int *mp;
  int *yp;
  
  if (Year < 0) {
    Year = -Year;
  }
  if (Year < 0x46) {
    Year = Year + 2000;
  }
  if (Year < 100) {
    Year = Year + 0x76c;
  }
  if (Year < 0x7b2) {
    Year = Year + 100;
  }
  mp = Convert::DaysNormal;
  yp = Convert::LeapYears;
  do {
    if (&DAT_08170d64 <= yp) {
LAB_080f1ab9:
      if (((((Year < 0x7b2) || (0x7f6 < Year)) || (Month < 1)) || ((0xc < Month || (Day < 1)))) ||
         (mp[Month] < Day)) {
        return -1;
      }
      Julian = Day + Year * 0x16d + -0xaf8cb;
      for (yp = Convert::LeapYears; (yp < &DAT_08170d64 && (*yp < Year)); yp = yp + 1) {
        Julian = Julian + 1;
      }
      for (i = 1; i < Month; i = i + 1) {
        mp = mp + 1;
        Julian = Julian + *mp;
      }
      Julian = Julian * 0x15180 + yyTimezone * 0x3c;
      tVar1 = ToSeconds(Hours,Minutes,Seconds,Meridian);
      if (-1 < tVar1) {
        tod = Julian + tVar1;
        Julian = tod;
        if ((dst == DSTon) ||
           ((dst == DSTmaybe && (ptVar2 = localtime(&tod), ptVar2->tm_isdst != 0)))) {
          Julian = Julian + -0xe10;
        }
        return Julian;
      }
      return -1;
    }
    if (*yp == Year) {
      mp = Convert::DaysLeap;
      goto LAB_080f1ab9;
    }
    yp = yp + 1;
  } while( true );
}



// WARNING: Unknown calling convention

time_t DSTcorrect(time_t Start,time_t Future)

{
  int iVar1;
  tm *ptVar2;
  time_t FutureDay;
  time_t StartDay;
  
  ptVar2 = localtime(&Start);
  iVar1 = ptVar2->tm_hour;
  ptVar2 = localtime(&Future);
  return (Future - Start) + ((iVar1 + 1) % 0x18 - (ptVar2->tm_hour + 1) % 0x18) * 0xe10;
}



// WARNING: Unknown calling convention

time_t RelativeMonth(time_t Start,time_t RelMonth)

{
  tm *ptVar1;
  int iVar2;
  time_t tVar3;
  time_t Year;
  time_t Month;
  tm *tm;
  
  ptVar1 = localtime(&Start);
  iVar2 = ptVar1->tm_year * 0xc + ptVar1->tm_mon + RelMonth;
  tVar3 = Convert(iVar2 % 0xc + 1,ptVar1->tm_mday,iVar2 / 0xc + 0x76c,ptVar1->tm_hour,ptVar1->tm_min
                  ,ptVar1->tm_sec,MER24,DSTmaybe);
  tVar3 = DSTcorrect(Start,tVar3);
  return tVar3;
}



// WARNING: Unknown calling convention

int LookupWord(char *buff,int length)

{
  char cVar1;
  char *pcVar2;
  int iVar3;
  int iVar4;
  int c;
  TABLE *tp;
  char *q;
  char *p;
  
  cVar1 = *buff;
  if ((length == 3) || ((length == 4 && (buff[3] == '.')))) {
    for (tp = MonthDayTable; tp < (TABLE *)&DAT_081708e4; tp = tp + 1) {
      pcVar2 = tp->name;
      if (((*pcVar2 == cVar1) && (buff[1] == pcVar2[1])) && (buff[2] == pcVar2[2])) {
        yylval.Number = tp->value;
        return tp->type;
      }
    }
  }
  else {
    for (tp = MonthDayTable; tp < (TABLE *)&DAT_081708e4; tp = tp + 1) {
      if ((*tp->name == cVar1) && (iVar3 = strcmp(buff,tp->name), iVar3 == 0)) {
        yylval.Number = tp->value;
        return tp->type;
      }
    }
  }
  for (tp = TimezoneTable; tp < (TABLE *)&DAT_08170d14; tp = tp + 1) {
    if (((*tp->name == cVar1) && (buff[1] == tp->name[1])) &&
       (iVar3 = strcmp(buff,tp->name), iVar3 == 0)) {
      yylval.Number = tp->value;
      return tp->type;
    }
  }
  iVar3 = strcmp(buff,"dst");
  if (iVar3 == 0) {
    return 0x10a;
  }
  for (tp = UnitsTable; tp < (TABLE *)&DAT_0817098c; tp = tp + 1) {
    if ((*tp->name == cVar1) && (iVar3 = strcmp(buff,tp->name), iVar3 == 0)) {
      yylval.Number = tp->value;
      return tp->type;
    }
  }
  iVar3 = length + -1;
  if ((0 < iVar3) && (buff[iVar3] == 's')) {
    buff[iVar3] = '\0';
    for (tp = UnitsTable; tp < (TABLE *)&DAT_0817098c; tp = tp + 1) {
      if ((*tp->name == cVar1) && (iVar4 = strcmp(buff,tp->name), iVar4 == 0)) {
        buff[iVar3] = 's';
        yylval.Number = tp->value;
        return tp->type;
      }
    }
    buff[iVar3] = 's';
  }
  p = buff;
  for (q = buff; *q != '\0'; q = q + 1) {
    if (*q != '.') {
      *p = *q;
      p = p + 1;
    }
  }
  *p = '\0';
  if ((buff[1] == 'm') && (buff[2] == '\0')) {
    if (*buff == 'a') {
      yylval = (YYSTYPE)0x0;
      return 0x103;
    }
    if (*buff == 'p') {
      yylval = (YYSTYPE)0x1;
      return 0x103;
    }
  }
  if ((int)p - (int)buff != length) {
    cVar1 = *buff;
    for (tp = TimezoneTable; tp < (TABLE *)&DAT_08170d14; tp = tp + 1) {
      if (((*tp->name == cVar1) && (buff[1] == tp->name[1])) &&
         (iVar3 = strcmp(buff,tp->name), iVar3 == 0)) {
        yylval.Number = tp->value;
        return tp->type;
      }
    }
  }
  yylval = (YYSTYPE)0x0;
  return 0x109;
}



// WARNING: Unknown calling convention

int date_lex(void)

{
  char cVar1;
  ushort **ppuVar2;
  int iVar3;
  byte *pbVar4;
  uint uVar5;
  int in_GS_OFFSET;
  int local_48;
  int local_44;
  int local_40;
  int local_3c;
  char local_35;
  int nesting;
  int i;
  int sign;
  char *p;
  int c;
  char buff [20];
  int local_8;
  
  local_8 = *(int *)(in_GS_OFFSET + 0x14);
  while( true ) {
    while ((-1 < *yyInput && (ppuVar2 = __ctype_b_loc(), ((*ppuVar2)[*yyInput] & 0x2000) != 0))) {
      yyInput = yyInput + 1;
    }
    cVar1 = *yyInput;
    iVar3 = (int)cVar1;
    if (iVar3 != 0x28) break;
    nesting = 1;
    pbVar4 = (byte *)yyInput;
LAB_080f220c:
    while( true ) {
      yyInput = (char *)pbVar4;
      pbVar4 = (byte *)(yyInput + 1);
      uVar5 = (uint)(char)*pbVar4;
      if ((uVar5 == 0x29) && (nesting = nesting + -1, nesting == 0)) break;
      if (uVar5 != 0x28) {
        if (((uVar5 < 0x80) && (uVar5 != 0)) && (uVar5 != 0xd)) goto code_r0x080f21d1;
        goto LAB_080f2200;
      }
      nesting = nesting + 1;
    }
    yyInput = yyInput + 2;
  }
  if ((((cVar1 < '\0') || (ppuVar2 = __ctype_b_loc(), ((*ppuVar2)[iVar3] & 0x800) == 0)) &&
      (iVar3 != 0x2d)) && (iVar3 != 0x2b)) {
    if ((cVar1 < '\0') || (ppuVar2 = __ctype_b_loc(), ((*ppuVar2)[iVar3] & 0x400) == 0)) {
      local_48 = (int)*yyInput;
      yyInput = yyInput + 1;
    }
    else {
      p = buff;
      while( true ) {
        local_35 = *yyInput;
        iVar3 = (int)local_35;
        yyInput = yyInput + 1;
        if ((iVar3 != 0x2e) &&
           ((local_35 < '\0' || (ppuVar2 = __ctype_b_loc(), ((*ppuVar2)[iVar3] & 0x400) == 0))))
        break;
        if (p < buff + 0x13) {
          if ((-1 < local_35) && (ppuVar2 = __ctype_b_loc(), ((*ppuVar2)[iVar3] & 0x100) != 0)) {
            iVar3 = tolower(iVar3);
            local_35 = (char)iVar3;
          }
          *p = local_35;
          p = p + 1;
        }
      }
      *p = '\0';
      yyInput = yyInput + -1;
      local_48 = LookupWord(buff,(int)p - (int)buff);
    }
  }
  else {
    if ((iVar3 == 0x2d) || (iVar3 == 0x2b)) {
      if (iVar3 == 0x2d) {
        local_44 = -1;
      }
      else {
        local_44 = 1;
      }
      sign = local_44;
      yyInput = yyInput + 1;
      if ((*yyInput < '\0') || (ppuVar2 = __ctype_b_loc(), ((*ppuVar2)[*yyInput] & 0x800) == 0)) {
        local_48 = (int)yyInput[-1];
        goto LAB_080f24f2;
      }
    }
    else {
      sign = 0;
    }
    i = 0;
    while( true ) {
      cVar1 = *yyInput;
      iVar3 = (int)cVar1;
      yyInput = yyInput + 1;
      if (((iVar3 == 0) || (cVar1 < '\0')) ||
         (ppuVar2 = __ctype_b_loc(), ((*ppuVar2)[iVar3] & 0x800) == 0)) break;
      i = i * 10 + iVar3 + -0x30;
    }
    yyInput = yyInput + -1;
    if (sign < 0) {
      local_40 = -i;
    }
    else {
      local_40 = i;
    }
    yylval.Number = local_40;
    if (sign == 0) {
      local_3c = 0x108;
    }
    else {
      local_3c = 0x107;
    }
    local_48 = local_3c;
  }
LAB_080f24f2:
  if (local_8 == *(int *)(in_GS_OFFSET + 0x14)) {
    return local_48;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
code_r0x080f21d1:
  if (uVar5 == 0x5c) {
    pbVar4 = (byte *)(yyInput + 2);
    if ((*pbVar4 == 0) || (0x7f < *pbVar4)) {
LAB_080f2200:
      yyInput = (char *)pbVar4;
      local_48 = 0x3f;
      goto LAB_080f24f2;
    }
  }
  goto LAB_080f220c;
}



// WARNING: Unknown calling convention

int GetTimeInfo(TIMEINFO *Now)

{
  int iVar1;
  tm *ptVar2;
  int local_18;
  timeval tv;
  tm *tm;
  
  iVar1 = gettimeofday((timeval *)&tv,(__timezone_ptr_t)0x0);
  if (iVar1 == -1) {
    local_18 = -1;
  }
  else {
    Now->time = tv.tv_sec;
    Now->usec = tv.tv_usec;
    if (0xe10 < Now->time - GetTimeInfo::LastTime) {
      GetTimeInfo::LastTime = Now->time;
      ptVar2 = localtime(&Now->time);
      if (ptVar2 == (tm *)0x0) {
        return -1;
      }
      GetTimeInfo::LastTzone = -ptVar2->tm_gmtoff / 0x3c;
    }
    Now->tzone = GetTimeInfo::LastTzone;
    local_18 = 0;
  }
  return local_18;
}



// WARNING: Unknown calling convention

time_t parsedate(char *p,TIMEINFO *now)

{
  tm *ptVar1;
  int iVar2;
  time_t tVar3;
  time_t local_40;
  time_t local_34;
  TIMEINFO ti;
  time_t Start;
  tm *tm;
  
  yyInput = p;
  if (now == (TIMEINFO *)0x0) {
    now = &ti;
    GetTimeInfo(&ti);
  }
  ptVar1 = localtime(&now->time);
  yyYear = ptVar1->tm_year + 0x76c;
  yyMonth = ptVar1->tm_mon + 1;
  yyDay = ptVar1->tm_mday;
  yyTimezone = now->tzone;
  if (ptVar1->tm_isdst != 0) {
    yyTimezone = yyTimezone + 0x3c;
  }
  yyDSTmode = DSTmaybe;
  yyHour = 0;
  yyMinutes = 0;
  yySeconds = 0;
  yyMeridian = MER24;
  yyRelSeconds = 0;
  yyRelMonth = 0;
  yyHaveDate = 0;
  yyHaveRel = 0;
  yyHaveTime = 0;
  iVar2 = date_parse();
  if (((iVar2 == 0) && (yyHaveTime < 2)) && (yyHaveDate < 2)) {
    if ((yyHaveDate == 0) && (yyHaveTime == 0)) {
      Start = now->time;
      if (yyHaveRel == 0) {
        Start = Start + ((ptVar1->tm_hour * -0x3c - ptVar1->tm_min) * 0x3c - ptVar1->tm_sec);
      }
    }
    else {
      Start = Convert(yyMonth,yyDay,yyYear,yyHour,yyMinutes,yySeconds,yyMeridian,yyDSTmode);
      if (Start < 0) {
        return -1;
      }
    }
    Start = Start + yyRelSeconds;
    if (yyRelMonth != 0) {
      tVar3 = RelativeMonth(Start,yyRelMonth);
      Start = Start + tVar3;
    }
    if (Start == -1) {
      local_34 = 0;
    }
    else {
      local_34 = Start;
    }
    local_40 = local_34;
  }
  else {
    local_40 = -1;
  }
  return local_40;
}



// WARNING: Unknown calling convention

int yygrowstack(void)

{
  int iVar1;
  int local_20;
  short *local_1c;
  YYSTYPE *local_18;
  YYSTYPE *newvs;
  short *newss;
  uint newsize;
  int i;
  
  if (yystacksize == 0) {
    newsize = 500;
  }
  else {
    if (499 < yystacksize) {
      return -1;
    }
    newsize = yystacksize << 1;
    if (500 < newsize) {
      newsize = 500;
    }
  }
  iVar1 = (int)yyssp - (int)yyss >> 1;
  if (yyss == (short *)0x0) {
    local_1c = (short *)malloc(newsize * 2);
  }
  else {
    local_1c = (short *)realloc(yyss,newsize * 2);
  }
  if (local_1c == (short *)0x0) {
    local_20 = -1;
  }
  else {
    yyss = local_1c;
    yyssp = local_1c + iVar1;
    if (yyvs == (YYSTYPE *)0x0) {
      local_18 = (YYSTYPE *)malloc(newsize << 2);
    }
    else {
      local_18 = (YYSTYPE *)realloc(yyvs,newsize << 2);
    }
    if (local_18 == (YYSTYPE *)0x0) {
      local_20 = -1;
    }
    else {
      yyvs = local_18;
      yyvsp = local_18 + iVar1;
      yystacksize = newsize;
      yysslim = yyss + -(1 - newsize);
      local_20 = 0;
    }
  }
  return local_20;
}



// WARNING: Unknown calling convention

int date_parse(void)

{
  int iVar1;
  short sVar2;
  int iVar3;
  int iVar4;
  int local_1c;
  int i;
  int yystate;
  int yyn;
  int yym;
  
  yynerrs = 0;
  yyerrflag = 0;
  yychar = -1;
  if ((yyss == (short *)0x0) && (iVar3 = yygrowstack(), iVar3 != 0)) {
yyoverflow:
    date_error("yacc stack overflow");
yyabort:
    local_1c = 1;
  }
  else {
    yyssp = yyss;
    yyvsp = yyvs;
    yystate = 0;
    *yyss = 0;
yyloop:
    do {
      yyn = (int)yydefred[yystate];
      if (yyn == 0) {
        if ((yychar < 0) && (yychar = date_lex(), yychar < 0)) {
          yychar = 0;
        }
        if ((((yysindex[yystate] != 0) && (iVar3 = yysindex[yystate] + yychar, -1 < iVar3)) &&
            (iVar3 < 0x12d)) && (yycheck[iVar3] == yychar)) {
          if ((yysslim <= yyssp) && (iVar4 = yygrowstack(), iVar4 != 0)) goto yyoverflow;
          yystate = (int)yytable[iVar3];
          yyssp = yyssp + 1;
          *yyssp = yytable[iVar3];
          yyvsp = yyvsp + 1;
          *yyvsp = yylval;
          yychar = -1;
          if (0 < yyerrflag) {
            yyerrflag = yyerrflag + -1;
          }
          goto yyloop;
        }
        if (((yyrindex[yystate] == 0) || (iVar3 = yyrindex[yystate] + yychar, iVar3 < 0)) ||
           ((300 < iVar3 || (yycheck[iVar3] != yychar)))) {
          if (yyerrflag == 0) {
            date_error("syntax error");
            yynerrs = yynerrs + 1;
          }
          if (yyerrflag < 3) {
            yyerrflag = 3;
            while ((((yysindex[*yyssp] == 0 || (iVar3 = yysindex[*yyssp] + 0x100, iVar3 < 0)) ||
                    (300 < iVar3)) || (yycheck[iVar3] != 0x100))) {
              if (yyssp <= yyss) goto yyabort;
              yyssp = yyssp + -1;
              yyvsp = yyvsp + -1;
            }
            if ((yysslim <= yyssp) && (iVar4 = yygrowstack(), iVar4 != 0)) goto yyoverflow;
            yystate = (int)yytable[iVar3];
            yyssp = yyssp + 1;
            *yyssp = yytable[iVar3];
            yyvsp = yyvsp + 1;
            *yyvsp = yylval;
          }
          else {
            if (yychar == 0) goto yyabort;
            yychar = -1;
          }
          goto yyloop;
        }
        yyn = (int)yytable[iVar3];
      }
      iVar3 = (int)yylen[yyn];
      if (iVar3 == 0) {
        memset(&yyval,0,4);
      }
      else {
        yyval = yyvsp[1 - iVar3];
      }
      switch(yyn) {
      case 3:
        yyHaveTime = yyHaveTime + 1;
        break;
      case 4:
        yyHaveTime = yyHaveTime + 1;
        yyTimezone = yyvsp->Number;
        break;
      case 5:
        yyHaveDate = yyHaveDate + 1;
        break;
      case 6:
        yyHaveDate = yyHaveDate + 1;
        yyHaveTime = yyHaveTime + 1;
        break;
      case 7:
        yyHaveDate = yyHaveDate + 1;
        yyHaveTime = yyHaveTime + 1;
        yyTimezone = yyvsp->Number;
        break;
      case 8:
        yyHaveRel = 1;
        break;
      case 9:
        if (yyvsp[-1].Number < 100) {
          yyHour = yyvsp[-1].Number;
          yyMinutes = 0;
        }
        else {
          yyHour = yyvsp[-1].Number / 100;
          yyMinutes = yyvsp[-1].Number % 100;
        }
        yySeconds = 0;
        yyMeridian = yyvsp->Meridian;
        break;
      case 10:
        yyHour = yyvsp[-3].Number;
        yyMinutes = yyvsp[-1].Number;
        yySeconds = 0;
        yyMeridian = yyvsp->Meridian;
        break;
      case 0xb:
        yyHour = yyvsp[-3].Number;
        yyMinutes = yyvsp[-1].Number;
        yyTimezone = yyvsp->Number;
        yyMeridian = MER24;
        yyDSTmode = DSToff;
        break;
      case 0xc:
        yyHour = yyvsp[-5].Number;
        yyMinutes = yyvsp[-3].Number;
        yySeconds = yyvsp[-1].Number;
        yyMeridian = yyvsp->Meridian;
        break;
      case 0xd:
        yyHour = yyvsp[-5].Number;
        yyMinutes = yyvsp[-3].Number;
        yySeconds = yyvsp[-1].Number;
        yyTimezone = yyvsp->Number;
        yyMeridian = MER24;
        yyDSTmode = DSToff;
        break;
      case 0xe:
        yyval = *yyvsp;
        yyDSTmode = DSToff;
        break;
      case 0xf:
        yyval = *yyvsp;
        yyDSTmode = DSTon;
        break;
      case 0x10:
        yyTimezone = yyvsp[-1].Number;
        yyDSTmode = DSTon;
        break;
      case 0x11:
        if (yyvsp[-1].Number != 0) goto yyabort;
        yyval = *yyvsp;
        yyDSTmode = DSToff;
        break;
      case 0x12:
        yyval = *yyvsp;
        yyDSTmode = DSToff;
        break;
      case 0x13:
        if (yyvsp->Number < 0) {
          yyvsp->Number = -yyvsp->Number;
          if ((9999 < yyvsp->Number) || (0x3b < yyvsp->Number % 100)) goto yyabort;
          yyval.Number = (yyvsp->Number / 100) * 0x3c + yyvsp->Number % 100;
        }
        else {
          if ((9999 < yyvsp->Number) || (0x3b < yyvsp->Number % 100)) goto yyabort;
          yyval.Number = (yyvsp->Number / 100) * -0x3c - yyvsp->Number % 100;
        }
        break;
      case 0x14:
        yyMonth = yyvsp[-2].Number;
        yyDay = yyvsp->Number;
        break;
      case 0x15:
        if (yyvsp[-4].Number < 0x65) {
          yyMonth = yyvsp[-4].Number;
          yyDay = yyvsp[-2].Number;
          yyYear = yyvsp->Number;
        }
        else {
          yyYear = yyvsp[-4].Number;
          yyMonth = yyvsp[-2].Number;
          yyDay = yyvsp->Number;
        }
        break;
      case 0x16:
        yyMonth = yyvsp[-1].Number;
        yyDay = yyvsp->Number;
        break;
      case 0x17:
        yyMonth = yyvsp[-3].Number;
        yyDay = yyvsp[-2].Number;
        yyYear = yyvsp->Number;
        break;
      case 0x18:
        yyDay = yyvsp[-1].Number;
        yyMonth = yyvsp->Number;
        break;
      case 0x19:
        yyDay = yyvsp[-2].Number;
        yyMonth = yyvsp[-1].Number;
        yyYear = yyvsp->Number;
        break;
      case 0x1a:
        yyDay = yyvsp[-2].Number;
        yyMonth = yyvsp[-1].Number;
        yyYear = yyvsp->Number;
        break;
      case 0x1b:
        yyDay = yyvsp[-3].Number;
        yyMonth = yyvsp[-1].Number;
        yyYear = -yyvsp->Number;
        break;
      case 0x1c:
        yyDay = yyvsp[-2].Number;
        yyMonth = -yyvsp[-1].Number;
        yyYear = -yyvsp->Number;
        yyDSTmode = DSToff;
        yyTimezone = 0;
        break;
      case 0x1d:
        yyMonth = yyvsp[-7].Number;
        yyDay = yyvsp[-6].Number;
        yyYear = yyvsp->Number;
        yyHour = yyvsp[-5].Number;
        yyMinutes = yyvsp[-3].Number;
        yySeconds = yyvsp[-1].Number;
        break;
      case 0x1e:
        yyRelSeconds = yyvsp[-1].Number * yyvsp->Number + yyRelSeconds;
        break;
      case 0x1f:
        yyRelSeconds = yyvsp[-1].Number * yyvsp->Number + yyRelSeconds;
        break;
      case 0x20:
        yyRelMonth = yyvsp[-1].Number * yyvsp->Number + yyRelMonth;
        break;
      case 0x21:
        yyRelMonth = yyvsp[-1].Number * yyvsp->Number + yyRelMonth;
        break;
      case 0x22:
        yyval.Number = 2;
        break;
      case 0x23:
        yyval = *yyvsp;
      }
      yyssp = yyssp + -iVar3;
      iVar4 = (int)*yyssp;
      yyvsp = yyvsp + -iVar3;
      iVar3 = (int)yylhs[yyn];
      if ((iVar4 != 0) || (iVar3 != 0)) {
        if ((yygindex[iVar3] == 0) ||
           (((iVar1 = yygindex[iVar3] + iVar4, iVar1 < 0 || (300 < iVar1)) ||
            (yycheck[iVar1] != iVar4)))) {
          sVar2 = yydgoto[iVar3];
        }
        else {
          sVar2 = yytable[iVar1];
        }
        yystate = (int)sVar2;
        if ((yysslim <= yyssp) && (iVar3 = yygrowstack(), iVar3 != 0)) goto yyoverflow;
        yyssp = yyssp + 1;
        *yyssp = sVar2;
        yyvsp = yyvsp + 1;
        *yyvsp = yyval;
        goto yyloop;
      }
      yystate = 1;
      yyssp = yyssp + 1;
      *yyssp = 1;
      yyvsp = yyvsp + 1;
      *yyvsp = yyval;
      if ((yychar < 0) && (yychar = date_lex(), yychar < 0)) {
        yychar = 0;
      }
    } while (yychar != 0);
    local_1c = 0;
  }
  return local_1c;
}



// WARNING: Unknown calling convention

void set_inverse_transl(int i)

{
  int iVar1;
  uchar *local_18;
  uchar *q;
  ushort *p;
  int glyph;
  int j;
  
  q = inverse_translations[i];
  if (q == (uchar *)0x0) {
    if (i == 0) {
      local_18 = inv_norm_transl;
    }
    else {
      local_18 = (uchar *)malloc(0x200);
    }
    inverse_translations[i] = local_18;
    q = inverse_translations[i];
    if (q == (uchar *)0x0) {
      return;
    }
  }
  for (j = 0; j < 0x200; j = j + 1) {
    q[j] = '\0';
  }
  for (j = 0; j < 0x100; j = j + 1) {
    iVar1 = conv_uni_to_pc((uint)translations[i][j],0);
    if (((-1 < iVar1) && (iVar1 < 0x200)) && (q[iVar1] < 0x20)) {
      q[iVar1] = (uchar)j;
    }
  }
  return;
}



// WARNING: Unknown calling convention

ushort * set_translate(int m)

{
  if (inverse_translations[m] == (uchar *)0x0) {
    set_inverse_transl(m);
  }
  inv_translate = inverse_translations[m];
  return (ushort *)translations[m];
}



// WARNING: Unknown calling convention

int UC_valid_UC_charset(int UC_charset_hndl)

{
  int local_8;
  
  if ((UC_charset_hndl < 0) || (UCNumCharsets <= UC_charset_hndl)) {
    local_8 = 0;
  }
  else {
    local_8 = 1;
  }
  return local_8;
}



// WARNING: Unknown calling convention

void UC_con_set_trans(int UC_charset_in_hndl,int Gn,int update_flag)

{
  int iVar1;
  FILE *__stream;
  ushort *ptrans;
  ushort *p;
  int j;
  int i;
  
  iVar1 = UC_valid_UC_charset(UC_charset_in_hndl);
  if (iVar1 == 0) {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"UC_con_set_trans: Invalid charset handle %d.\n",UC_charset_in_hndl);
    }
  }
  else {
    p = UCInfo[UC_charset_in_hndl].unitable;
    for (i = 0; i < 0x100; i = i + 1) {
      j = (int)UCInfo[UC_charset_in_hndl].unicount[i];
      if (j == 0) {
        translations[Gn][i] = 0xfffd;
      }
      else {
        translations[Gn][i] = *p;
        for (; j != 0; j = j + -1) {
          p = p + 1;
        }
      }
    }
    if (update_flag != 0) {
      set_inverse_transl(Gn);
    }
  }
  return;
}



int con_insert_unipair(ushort unicode,ushort fontpos,int fordefault)

{
  uint uVar1;
  ushort *puVar2;
  ushort fontpos_local;
  ushort unicode_local;
  ushort *p2;
  ushort **p1;
  int n;
  int i;
  
  if (fordefault == 0) {
    n = (int)(unicode >> 0xb);
    p1 = uni_pagedir[n];
  }
  else {
    n = (int)(unicode >> 0xb);
    p1 = unidefault_pagedir[n];
  }
  if (p1 == (ushort **)0x0) {
    p1 = (ushort **)malloc(0x80);
    if (fordefault == 0) {
      uni_pagedir[n] = p1;
    }
    else {
      unidefault_pagedir[n] = p1;
    }
    if (p1 == (ushort **)0x0) {
      return -1;
    }
    for (i = 0; i < 0x20; i = i + 1) {
      p1[i] = (ushort *)0x0;
    }
  }
  uVar1 = unicode >> 6 & 0x1f;
  p2 = p1[uVar1];
  if (p2 == (ushort *)0x0) {
    puVar2 = (ushort *)malloc(0x80);
    p1[uVar1] = puVar2;
    p2 = p1[uVar1];
    if (p2 == (ushort *)0x0) {
      return -1;
    }
    for (i = 0; i < 0x40; i = i + 1) {
      p2[i] = 0xffff;
    }
  }
  p2[unicode & 0x3f] = fontpos;
  return 0;
}



int con_insert_unipair_str(ushort unicode,char *replace_str,int fordefault)

{
  uint uVar1;
  char **ppcVar2;
  ushort unicode_local;
  char **p2;
  char ***p1;
  int n;
  int i;
  
  if (fordefault == 0) {
    n = (int)(unicode >> 0xb);
    p1 = uni_pagedir_str[n];
  }
  else {
    n = (int)(unicode >> 0xb);
    p1 = unidefault_pagedir_str[n];
  }
  if (p1 == (char ***)0x0) {
    p1 = (char ***)malloc(0x80);
    if (fordefault == 0) {
      uni_pagedir_str[n] = p1;
    }
    else {
      unidefault_pagedir_str[n] = p1;
    }
    if (p1 == (char ***)0x0) {
      return -1;
    }
    for (i = 0; i < 0x20; i = i + 1) {
      p1[i] = (char **)0x0;
    }
  }
  uVar1 = unicode >> 6 & 0x1f;
  if (p1[uVar1] == (char **)0x0) {
    ppcVar2 = (char **)malloc(0x100);
    p1[uVar1] = ppcVar2;
    if (p1[uVar1] == (char **)0x0) {
      return -1;
    }
    ppcVar2 = p1[uVar1];
    for (i = 0; i < 0x40; i = i + 1) {
      ppcVar2[i] = (char *)0x0;
    }
  }
  p1[uVar1][unicode & 0x3f] = replace_str;
  return 0;
}



// WARNING: Unknown calling convention

void con_clear_unimap(int fordefault)

{
  ushort **ppuVar1;
  ushort **p1;
  int j;
  int i;
  
  if (fordefault == 0) {
    for (i = 0; i < 0x20; i = i + 1) {
      ppuVar1 = uni_pagedir[i];
      if (ppuVar1 != (ushort **)0x0) {
        for (j = 0; j < 0x20; j = j + 1) {
          if (ppuVar1[j] != (ushort *)0x0) {
            free(ppuVar1[j]);
            ppuVar1[j] = (ushort *)0x0;
          }
        }
        if (ppuVar1 != (ushort **)0x0) {
          free(ppuVar1);
        }
      }
      uni_pagedir[i] = (ushort **)0x0;
    }
    hashtable_contents_valid = 1;
  }
  else {
    for (i = 0; i < 0x20; i = i + 1) {
      ppuVar1 = unidefault_pagedir[i];
      if (ppuVar1 != (ushort **)0x0) {
        for (j = 0; j < 0x20; j = j + 1) {
          if (ppuVar1[j] != (ushort *)0x0) {
            free(ppuVar1[j]);
            ppuVar1[j] = (ushort *)0x0;
          }
        }
        if (ppuVar1 != (ushort **)0x0) {
          free(ppuVar1);
        }
      }
      unidefault_pagedir[i] = (ushort **)0x0;
    }
    unidefault_contents_valid = 1;
  }
  return;
}



// WARNING: Unknown calling convention

void con_clear_unimap_str(int fordefault)

{
  char ***pppcVar1;
  char ***p1;
  int j;
  int i;
  
  if (fordefault == 0) {
    for (i = 0; i < 0x20; i = i + 1) {
      pppcVar1 = uni_pagedir_str[i];
      if (pppcVar1 != (char ***)0x0) {
        for (j = 0; j < 0x20; j = j + 1) {
          if (pppcVar1[j] != (char **)0x0) {
            free(pppcVar1[j]);
            pppcVar1[j] = (char **)0x0;
          }
        }
        if (pppcVar1 != (char ***)0x0) {
          free(pppcVar1);
        }
      }
      uni_pagedir_str[i] = (char ***)0x0;
    }
    hashtable_str_contents_valid = 1;
  }
  else {
    for (i = 0; i < 0x20; i = i + 1) {
      pppcVar1 = unidefault_pagedir_str[i];
      if (pppcVar1 != (char ***)0x0) {
        for (j = 0; j < 0x20; j = j + 1) {
          if (pppcVar1[j] != (char **)0x0) {
            free(pppcVar1[j]);
            pppcVar1[j] = (char **)0x0;
          }
        }
        if (pppcVar1 != (char ***)0x0) {
          free(pppcVar1);
        }
      }
      unidefault_pagedir_str[i] = (char ***)0x0;
    }
    unidefault_str_contents_valid = 1;
  }
  return;
}



// WARNING: Unknown calling convention

void con_set_default_unimap(void)

{
  ushort unicode;
  ushort *p;
  int j;
  int i;
  
  con_clear_unimap(1);
  p = dfont_unitable;
  for (i = 0; i < 0x100; i = i + 1) {
    for (j = (int)""[i]; j != 0; j = j + -1) {
      unicode = *p;
      p = p + 1;
      con_insert_unipair(unicode,(ushort)i,1);
    }
  }
  UC_default_unitable = dfont_unitable;
  con_clear_unimap_str(1);
  UC_con_set_unimap_str(0xa32,repl_map,1);
  UC_default_unitable_str = &dfont_replacedesc;
  return;
}



// WARNING: Unknown calling convention

int UC_con_set_unimap(int UC_charset_out_hndl,int update_flag)

{
  ushort unicode;
  int iVar1;
  FILE *__stream;
  int local_18;
  ushort *p;
  int j;
  int i;
  
  iVar1 = UC_valid_UC_charset(UC_charset_out_hndl);
  if (iVar1 == 0) {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"UC_con_set_unimap: Invalid charset handle %d.\n",UC_charset_out_hndl
             );
    }
    local_18 = -1;
  }
  else {
    p = UCInfo[UC_charset_out_hndl].unitable;
    if (p == UC_current_unitable) {
      local_18 = update_flag;
    }
    else {
      UC_current_unitable = p;
      con_clear_unimap(0);
      for (i = 0; i < 0x100; i = i + 1) {
        for (j = (int)UCInfo[UC_charset_out_hndl].unicount[i]; j != 0; j = j + -1) {
          unicode = *p;
          p = p + 1;
          con_insert_unipair(unicode,(ushort)i,0);
        }
      }
      if (update_flag != 0) {
        for (i = 0; i < 4; i = i + 1) {
          set_inverse_transl(i);
        }
      }
      local_18 = 0;
    }
  }
  return local_18;
}



int UC_con_set_unimap_str(ushort ct,unipair_str *list,int fordefault)

{
  int iVar1;
  bool bVar2;
  ushort ct_local;
  int err1;
  int err;
  
  ct_local = ct;
  err = 0;
  while (bVar2 = ct_local != 0, ct_local = ct_local - 1, bVar2) {
    iVar1 = con_insert_unipair_str(list->unicode,list->replace_str,fordefault);
    if (iVar1 != 0) {
      err = iVar1;
    }
    list = list + 1;
  }
  if (err == 0) {
    if (fordefault == 0) {
      hashtable_str_contents_valid = 1;
    }
    else {
      unidefault_str_contents_valid = 1;
    }
  }
  return err;
}



// WARNING: Unknown calling convention

int conv_uni_to_pc(long ucs,int usedefault)

{
  uint local_18;
  ushort *p2;
  ushort **p1;
  int h;
  
  if (ucs < 0x10000) {
    if ((ucs < 0x20) || (0xfffd < ucs)) {
      return -1;
    }
    if ((ucs == 0xfeff) || ((0x200a < ucs && (ucs < 0x2010)))) {
      return -2;
    }
    if ((ucs & 0xfffffe00U) == 0xf000) {
      return ucs & 0x1ff;
    }
  }
  else {
    ucs = 0xfffd;
  }
  if (usedefault == 0) {
    if (hashtable_contents_valid == 0) {
      return -3;
    }
    p1 = uni_pagedir[ucs >> 0xb];
  }
  else {
    if (unidefault_contents_valid == 0) {
      return -3;
    }
    p1 = unidefault_pagedir[ucs >> 0xb];
  }
  if (((p1 == (ushort **)0x0) || (p1[ucs >> 6 & 0x1f] == (ushort *)0x0)) ||
     (local_18 = (uint)p1[ucs >> 6 & 0x1f][ucs & 0x3f], 0x1ff < local_18)) {
    local_18 = 0xfffffffc;
  }
  return local_18;
}



// WARNING: Unknown calling convention

int conv_uni_to_str(char *outbuf,int buflen,long ucs,int usedefault)

{
  char *__src;
  int local_18;
  char **p2;
  char ***p1;
  char *h;
  
  if (ucs < 0x10000) {
    if ((ucs < 0x20) || (0xfffd < ucs)) {
      return -1;
    }
    if ((ucs == 0xfeff) || ((0x200a < ucs && (ucs < 0x2010)))) {
      return -2;
    }
  }
  else {
    ucs = 0xfffd;
  }
  if (usedefault == 0) {
    if (hashtable_str_contents_valid == 0) {
      return -3;
    }
    p1 = uni_pagedir_str[ucs >> 0xb];
  }
  else {
    if (unidefault_str_contents_valid == 0) {
      return -3;
    }
    p1 = unidefault_pagedir_str[ucs >> 0xb];
  }
  if (((p1 == (char ***)0x0) || (p1[ucs >> 6 & 0x1f] == (char **)0x0)) ||
     (__src = p1[ucs >> 6 & 0x1f][ucs & 0x3f], __src == (char *)0x0)) {
    local_18 = -4;
  }
  else {
    strncpy(outbuf,__src,buflen - 1);
    local_18 = 1;
  }
  return local_18;
}



// WARNING: Unknown calling convention

void UCconsole_map_init(void)

{
  con_set_default_unimap();
  UCInitialized = 1;
  return;
}



// WARNING: Unknown calling convention

int UCTransUniChar(long unicode,int charset_out)

{
  int local_2c;
  int local_28;
  ushort *ut;
  int trydefault;
  int isdefault;
  int UChndl_out;
  int rc;
  
  rc = 0;
  trydefault = 0;
  UChndl_out = LYCharSet_UC[charset_out].UChndl;
  if (UChndl_out < 0) {
    if (LYCharSet_UC[charset_out].codepage < 0) {
      if (unicode < 0x80) {
        local_28 = unicode;
      }
      else {
        local_28 = LYCharSet_UC[charset_out].codepage;
      }
      return local_28;
    }
    UChndl_out = default_UChndl;
    if (default_UChndl < 0) {
      return -0xc;
    }
    isdefault = 1;
  }
  else {
    isdefault = UCInfo[UChndl_out].replacedesc.isdefault;
    trydefault = UCInfo[UChndl_out].replacedesc.trydefault;
  }
  if (((isdefault != 0) ||
      (((UCInfo[UChndl_out].unitable == UC_current_unitable ||
        (local_2c = UC_con_set_unimap(UChndl_out,1), -1 < local_2c)) &&
       (local_2c = conv_uni_to_pc(unicode,0), rc = local_2c, local_2c < 0)))) &&
     (((isdefault == 0 && (trydefault == 0)) ||
      (local_2c = conv_uni_to_pc(unicode,1), rc = local_2c, local_2c < 0)))) {
    if ((isdefault == 0) && (rc == -4)) {
      rc = conv_uni_to_pc(0xfffd,0);
    }
    if (((isdefault != 0) || (trydefault != 0)) && (rc == -4)) {
      rc = conv_uni_to_pc(0xfffd,1);
    }
    local_2c = rc;
  }
  return local_2c;
}



// WARNING: Unknown calling convention

int UCTransUniCharStr(char *outbuf,int buflen,long unicode,int charset_out,int chk_single_flag)

{
  size_t sVar1;
  int iVar2;
  FILE *__stream;
  int local_48;
  char *tocode;
  size_t outleft;
  size_t inleft;
  char *pout;
  char *pin;
  iconv_t cd;
  ushort *ut;
  unimapdesc_str *repl;
  int trydefault;
  int isdefault;
  int UChndl_out;
  int ignore_err;
  int src;
  int rc;
  char str [3];
  
  rc = -0xe;
  src = 0;
  trydefault = 0;
  if (buflen < 2) {
    return -0xd;
  }
  UChndl_out = LYCharSet_UC[charset_out].UChndl;
  if (UChndl_out < 0) {
    if (LYCharSet_UC[charset_out].codepage < 0) {
      return LYCharSet_UC[charset_out].codepage;
    }
    UChndl_out = default_UChndl;
    if (default_UChndl < 0) {
      return -0xc;
    }
    isdefault = 1;
  }
  else {
    isdefault = UCInfo[UChndl_out].replacedesc.isdefault;
    trydefault = UCInfo[UChndl_out].replacedesc.trydefault;
  }
  if (chk_single_flag != 0) {
    if (((isdefault == 0) && (ut = UCInfo[UChndl_out].unitable, ut != UC_current_unitable)) &&
       (src = UC_con_set_unimap(UChndl_out,1), src < 0)) {
      return src;
    }
    src = conv_uni_to_pc(unicode,isdefault);
    if (0x1f < src) {
      *outbuf = (char)src;
      outbuf[1] = '\0';
      return 1;
    }
  }
  repl = &UCInfo[UChndl_out].replacedesc;
  if (isdefault == 0) {
    if (repl != UC_current_unitable_str) {
      con_clear_unimap_str(0);
      ignore_err = UC_con_set_unimap_str(repl->entry_ct,repl->entries,0);
      UC_current_unitable_str = repl;
    }
    rc = conv_uni_to_str(outbuf,buflen,unicode,0);
    if (-1 < rc) {
      sVar1 = strlen(outbuf);
      return sVar1;
    }
  }
  if (((trydefault == 0) || (chk_single_flag == 0)) || (src = conv_uni_to_pc(unicode,1), src < 0x20)
     ) {
    if ((isdefault != 0) || (trydefault != 0)) {
      iVar2 = strcmp(LYCharSet_UC[charset_out].MIMEname,"shift_jis");
      if ((iVar2 == 0) || (iVar2 = strcmp(LYCharSet_UC[charset_out].MIMEname,"euc-jp"), iVar2 == 0))
      {
        tocode = (char *)0x0;
        str[0] = (char)((uint)unicode >> 8);
        str[1] = (char)unicode;
        str[2] = '\0';
        pin = str;
        inleft = 2;
        pout = outbuf;
        outleft = buflen;
        HTSprintf0(&tocode,"%s//TRANSLIT",LYCharSet_UC[charset_out].MIMEname);
        cd = iconv_open(tocode,"UTF-16BE");
        if (tocode != (char *)0x0) {
          free(tocode);
          tocode = (char *)0x0;
        }
        if (cd == (iconv_t)0xffffffff) {
          cd = iconv_open(LYCharSet_UC[charset_out].MIMEname,"UTF-16BE");
        }
        rc = iconv(cd,&pin,&inleft,&pout,&outleft);
        iconv_close(cd);
        if ((int)pout - (int)outbuf == 3) {
          if (WWW_TraceFlag != '\0') {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"It seems to be a JIS X 0201 code(%ld). Not supported.\n",
                    unicode);
          }
          pin = str;
          inleft = 2;
          pout = outbuf;
          outleft = buflen;
        }
        else if (-1 < rc) {
          *pout = '\0';
          sVar1 = strlen(outbuf);
          return sVar1;
        }
      }
      rc = conv_uni_to_str(outbuf,buflen,unicode,1);
      if (-1 < rc) {
        sVar1 = strlen(outbuf);
        return sVar1;
      }
    }
    if (rc == -4) {
      if (isdefault == 0) {
        rc = conv_uni_to_str(outbuf,buflen,0xfffd,0);
      }
      if ((rc == -4) && ((isdefault != 0 || (trydefault != 0)))) {
        rc = conv_uni_to_str(outbuf,buflen,0xfffd,1);
      }
      if (-1 < rc) {
        sVar1 = strlen(outbuf);
        return sVar1;
      }
    }
    if ((chk_single_flag == 0) || (src != -4)) {
      local_48 = -4;
    }
    else {
      if (isdefault == 0) {
        rc = conv_uni_to_pc(0xfffd,0);
      }
      if ((rc == -4) && ((isdefault != 0 || (trydefault != 0)))) {
        rc = conv_uni_to_pc(0xfffd,1);
      }
      if (rc < 0x20) {
        local_48 = rc;
      }
      else {
        *outbuf = (char)rc;
        outbuf[1] = '\0';
        local_48 = 1;
      }
    }
  }
  else {
    *outbuf = (char)src;
    outbuf[1] = '\0';
    local_48 = 1;
  }
  return local_48;
}



// WARNING: Unknown calling convention

int UC_MapGN(int UChndl,int update_flag)

{
  char *pcVar1;
  bool bVar2;
  FILE *__stream;
  int local_1c;
  int lasthndl;
  int found;
  int Gn;
  int i;
  
  bVar2 = false;
  Gn = -1;
  i = 0;
  while ((i < 4 && (Gn < 0))) {
    if (UC_GNhandles[i] < 0) {
      Gn = i;
    }
    else if (UC_GNhandles[i] == UChndl) {
      Gn = i;
      bVar2 = true;
    }
    i = i + 1;
  }
  if (bVar2) {
    local_1c = Gn;
  }
  else {
    if (Gn < 0) {
      if (UC_lastautoGN == 1) {
        Gn = 2;
      }
      else {
        Gn = 1;
      }
      UC_lastautoGN = Gn;
      UCInfo[UC_GNhandles[Gn]].GN = -1;
      UCInfo[UChndl].GN = Gn;
      UC_GNhandles[Gn] = UChndl;
    }
    else {
      UCInfo[UChndl].GN = Gn;
      UC_GNhandles[Gn] = UChndl;
    }
    if (WWW_TraceFlag != '\0') {
      pcVar1 = UCInfo[UChndl].MIMEname;
      __stream = TraceFP();
      fprintf((FILE *)__stream,"UC_MapGN: Using %d <- %d (%s)\n",Gn,UChndl,pcVar1);
    }
    UC_con_set_trans(UChndl,Gn,update_flag);
    local_1c = Gn;
  }
  return local_1c;
}



int UCTransChar(char ch_in,int charset_in,int charset_out)

{
  ushort uVar1;
  int UChndl;
  bool bVar2;
  uint local_3c;
  char ch_in_local;
  int upd;
  ushort *ut;
  int trydefault;
  int isdefault;
  int UChndl_out;
  int UChndl_in;
  int rc;
  int Gn;
  int unicode;
  
  rc = -4;
  trydefault = 0;
  if (charset_in == charset_out) {
    local_3c = (uint)(byte)ch_in;
  }
  else if (charset_in < 0) {
    local_3c = 0xfffffff5;
  }
  else {
    UChndl = LYCharSet_UC[charset_in].UChndl;
    if (UChndl < 0) {
      local_3c = 0xfffffff5;
    }
    else {
      UChndl_out = LYCharSet_UC[charset_out].UChndl;
      if (UChndl_out < 0) {
        if (LYCharSet_UC[charset_out].codepage < 0) {
          return LYCharSet_UC[charset_out].codepage;
        }
        UChndl_out = default_UChndl;
        if (default_UChndl < 0) {
          return -0xc;
        }
        isdefault = 1;
      }
      else {
        isdefault = UCInfo[UChndl_out].replacedesc.isdefault;
        trydefault = UCInfo[UChndl_out].replacedesc.trydefault;
      }
      if (UCInfo[UChndl].num_uni == 0) {
        local_3c = 0xfffffff5;
      }
      else {
        Gn = UCInfo[UChndl].GN;
        bVar2 = Gn < 0;
        if (bVar2) {
          Gn = UC_MapGN(UChndl,0);
        }
        if (isdefault == 0) {
          if (UCInfo[UChndl_out].unitable == UC_current_unitable) {
            if (bVar2) {
              set_inverse_transl(Gn);
            }
          }
          else {
            rc = UC_con_set_unimap(UChndl_out,1);
            if (rc < 1) {
              if (rc < 0) {
                return rc;
              }
            }
            else {
              set_inverse_transl(Gn);
            }
          }
        }
        UC_translate = set_translate(Gn);
        uVar1 = UC_translate[(byte)ch_in];
        if ((isdefault != 0) ||
           (local_3c = conv_uni_to_pc((uint)uVar1,0), rc = local_3c, (int)local_3c < 0)) {
          if ((rc == -4) && ((isdefault != 0 || (trydefault != 0)))) {
            rc = conv_uni_to_pc((uint)uVar1,1);
          }
          if ((rc == -4) && (isdefault == 0)) {
            rc = conv_uni_to_pc(0xfffd,0);
          }
          if ((rc == -4) && ((isdefault != 0 || (trydefault != 0)))) {
            rc = conv_uni_to_pc(0xfffd,1);
          }
          local_3c = rc;
        }
      }
    }
  }
  return local_3c;
}



// WARNING: Unknown calling convention

UCode_t UCTransJPToUni(char *inbuf,int buflen,int charset_in)

{
  iconv_t __cd;
  uint local_28;
  iconv_t cd;
  size_t olen;
  size_t ilen;
  size_t rc;
  char *pout;
  char *pin;
  char outbuf [3];
  
  pin = inbuf;
  pout = outbuf;
  ilen = 2;
  olen = buflen;
  __cd = iconv_open("UTF-16BE",LYCharSet_UC[charset_in].MIMEname);
  rc = iconv(__cd,&pin,&ilen,&pout,&olen);
  iconv_close(__cd);
  if ((ilen == 0) && (olen == 0)) {
    local_28 = (uint)CONCAT11(outbuf[0],outbuf[1]);
  }
  else {
    local_28 = 0xfffffff5;
  }
  return local_28;
}



UCode_t UCTransToUni(char ch_in,int charset_in)

{
  int iVar1;
  iconv_t pvVar2;
  uint local_3c;
  char ch_in_local;
  iconv_t cd;
  size_t olen;
  size_t ilen;
  size_t rc;
  char *pout;
  char *pin;
  int UChndl_in;
  int Gn;
  int unicode;
  char obuffer [3];
  uchar ch_iu;
  
  if (charset_in == LATIN1) {
    return (uint)(byte)ch_in;
  }
  iVar1 = strcmp(LYCharSet_UC[charset_in].MIMEname,"shift_jis");
  if ((iVar1 == 0) || (iVar1 = strcmp(LYCharSet_UC[charset_in].MIMEname,"euc-jp"), iVar1 == 0)) {
    pin = UCTransToUni::buffer;
    pout = obuffer;
    olen = 2;
    ilen = 2;
    iVar1 = strcmp(LYCharSet_UC[charset_in].MIMEname,"shift_jis");
    if (iVar1 == 0) {
      if (UCTransToUni::inx == 0) {
        if (((0x80 < (byte)ch_in) && ((byte)ch_in < 0xa0)) ||
           ((0xdf < (byte)ch_in && ((byte)ch_in < 0xf0)))) {
          UCTransToUni::inx = 1;
          UCTransToUni::buffer[0] = ch_in;
          return -0xb;
        }
      }
      else if (((0x3f < (byte)ch_in) && (ch_in != '\x7f')) && ((byte)ch_in < 0xfd)) {
        UCTransToUni::buffer[2] = '\0';
        UCTransToUni::buffer[1] = ch_in;
        pvVar2 = iconv_open("UTF-16BE","Shift_JIS");
        rc = iconv(pvVar2,&pin,&ilen,&pout,&olen);
        iconv_close(pvVar2);
        UCTransToUni::inx = 0;
        if ((ilen == 0) && (olen == 0)) {
          UCTransToUni::inx = 0;
          return (uint)CONCAT11(obuffer[0],obuffer[1]);
        }
      }
    }
    iVar1 = strcmp(LYCharSet_UC[charset_in].MIMEname,"euc-jp");
    if (iVar1 == 0) {
      if (UCTransToUni::inx == 0) {
        if ((0xa0 < (byte)ch_in) && (ch_in != -1)) {
          UCTransToUni::inx = 1;
          UCTransToUni::buffer[0] = ch_in;
          return -0xb;
        }
      }
      else if ((0xa0 < (byte)ch_in) && (ch_in != -1)) {
        UCTransToUni::buffer[2] = '\0';
        UCTransToUni::buffer[1] = ch_in;
        pvVar2 = iconv_open("UTF-16BE","EUC-JP");
        rc = iconv(pvVar2,&pin,&ilen,&pout,&olen);
        iconv_close(pvVar2);
        if ((ilen == 0) && (olen == 0)) {
          UCTransToUni::inx = 0;
          return (uint)CONCAT11(obuffer[0],obuffer[1]);
        }
      }
    }
    UCTransToUni::inx = 0;
  }
  if ((ch_in < '\0') || ((byte)ch_in < 0x20)) {
    if (charset_in < 0) {
      local_3c = 0xfffffff5;
    }
    else if (((byte)ch_in < 0x20) && (LYCharSet_UC[charset_in].enc != 3)) {
      local_3c = (uint)(byte)ch_in;
    }
    else {
      UChndl_in = LYCharSet_UC[charset_in].UChndl;
      if (UChndl_in < 0) {
        local_3c = 0xfffffff5;
      }
      else if (UCInfo[UChndl_in].num_uni == 0) {
        local_3c = 0xfffffff5;
      }
      else {
        Gn = UCInfo[UChndl_in].GN;
        if (Gn < 0) {
          Gn = UC_MapGN(UChndl_in,1);
        }
        UC_translate = set_translate(Gn);
        local_3c = (uint)UC_translate[(byte)ch_in];
      }
    }
  }
  else {
    local_3c = (uint)(byte)ch_in;
  }
  return local_3c;
}



int UCReverseTransChar(char ch_out,int charset_in,int charset_out)

{
  int UChndl;
  uint local_2c;
  char ch_out_local;
  ushort *ut;
  int i_ch;
  int isdefault;
  int UChndl_out;
  int UChndl_in;
  int rc;
  int Gn;
  
  rc = -1;
  if (charset_in == charset_out) {
    local_2c = (uint)(byte)ch_out;
  }
  else if (charset_in < 0) {
    local_2c = 0xfffffff5;
  }
  else {
    UChndl = LYCharSet_UC[charset_in].UChndl;
    if (UChndl < 0) {
      local_2c = 0xfffffff5;
    }
    else if (UCInfo[UChndl].num_uni == 0) {
      local_2c = 0xfffffff5;
    }
    else if (charset_out < 0) {
      local_2c = 0xfffffff4;
    }
    else {
      UChndl_out = LYCharSet_UC[charset_out].UChndl;
      if (UChndl_out < 0) {
        if (LYCharSet_UC[charset_out].codepage < 0) {
          return LYCharSet_UC[charset_out].codepage;
        }
        UChndl_out = default_UChndl;
        if (default_UChndl < 0) {
          return -0xc;
        }
        isdefault = 1;
      }
      else {
        isdefault = UCInfo[UChndl_out].replacedesc.isdefault;
      }
      if ((isdefault == 0) && (UCInfo[UChndl_out].unitable == UC_current_unitable)) {
        Gn = UCInfo[UChndl].GN;
        if (Gn < 0) {
          Gn = UC_MapGN(UChndl,1);
        }
        UC_translate = set_translate(Gn);
        if (inv_translate != (uchar *)0x0) {
          rc = (int)inv_translate[(byte)ch_out];
        }
        if (0x1f < rc) {
          return rc;
        }
      }
      local_2c = UCTransChar(ch_out,charset_out,charset_in);
    }
  }
  return local_2c;
}



int UCTransCharStr(char *outbuf,int buflen,char ch_in,int charset_in,int charset_out,
                  int chk_single_flag)

{
  uint ucs;
  int iVar1;
  unimapdesc_str *puVar2;
  size_t sVar3;
  size_t local_3c;
  char ch_in_local;
  int upd;
  ushort *ut;
  unimapdesc_str *repl;
  int trydefault;
  int isdefault;
  int UChndl_out;
  int UChndl_in;
  int ignore_err;
  int src;
  int rc;
  int Gn;
  int unicode;
  
  rc = -0xe;
  src = 0;
  trydefault = 0;
  upd = 0;
  if (buflen < 2) {
    local_3c = 0xfffffff3;
  }
  else if ((chk_single_flag == 0) || (charset_in != charset_out)) {
    if (charset_in < 0) {
      local_3c = 0xfffffff5;
    }
    else {
      iVar1 = LYCharSet_UC[charset_in].UChndl;
      if (iVar1 < 0) {
        local_3c = 0xfffffff5;
      }
      else if (UCInfo[iVar1].num_uni == 0) {
        local_3c = 0xfffffff5;
      }
      else {
        UChndl_out = LYCharSet_UC[charset_out].UChndl;
        if (UChndl_out < 0) {
          if (LYCharSet_UC[charset_out].codepage < 0) {
            return LYCharSet_UC[charset_out].codepage;
          }
          UChndl_out = default_UChndl;
          if (default_UChndl < 0) {
            return -0xc;
          }
          isdefault = 1;
        }
        else {
          isdefault = UCInfo[UChndl_out].replacedesc.isdefault;
          trydefault = UCInfo[UChndl_out].replacedesc.trydefault;
        }
        Gn = UCInfo[iVar1].GN;
        if (Gn < 0) {
          Gn = UC_MapGN(iVar1,(uint)(chk_single_flag == 0));
          upd = chk_single_flag;
        }
        UC_translate = set_translate(Gn);
        ucs = (uint)UC_translate[(byte)ch_in];
        if (chk_single_flag != 0) {
          if (isdefault == 0) {
            if (UCInfo[UChndl_out].unitable == UC_current_unitable) {
              if (upd != 0) {
                set_inverse_transl(Gn);
              }
            }
            else {
              iVar1 = UC_con_set_unimap(UChndl_out,1);
              if (iVar1 < 1) {
                if (iVar1 < 0) {
                  return iVar1;
                }
              }
              else {
                set_inverse_transl(Gn);
              }
            }
          }
          src = conv_uni_to_pc(ucs,isdefault);
          if (0x1f < src) {
            *outbuf = (char)src;
            outbuf[1] = '\0';
            return 1;
          }
        }
        puVar2 = &UCInfo[UChndl_out].replacedesc;
        if (isdefault == 0) {
          if (puVar2 != UC_current_unitable_str) {
            con_clear_unimap_str(0);
            UC_con_set_unimap_str(puVar2->entry_ct,UCInfo[UChndl_out].replacedesc.entries,0);
            UC_current_unitable_str = puVar2;
          }
          rc = conv_uni_to_str(outbuf,buflen,ucs,0);
          if (-1 < rc) {
            sVar3 = strlen(outbuf);
            return sVar3;
          }
        }
        if (((trydefault == 0) || (chk_single_flag == 0)) ||
           (src = conv_uni_to_pc(ucs,1), src < 0x20)) {
          if (((isdefault == 0) && (trydefault == 0)) ||
             (rc = conv_uni_to_str(outbuf,buflen,ucs,1), rc < 0)) {
            if (rc == -4) {
              if (isdefault == 0) {
                rc = conv_uni_to_str(outbuf,buflen,0xfffd,0);
              }
              if ((rc == -4) && ((isdefault != 0 || (trydefault != 0)))) {
                rc = conv_uni_to_str(outbuf,buflen,0xfffd,1);
              }
              if (-1 < rc) {
                sVar3 = strlen(outbuf);
                return sVar3;
              }
            }
            if ((chk_single_flag == 0) || (src != -4)) {
              local_3c = 0xfffffffc;
            }
            else {
              if (isdefault == 0) {
                rc = conv_uni_to_pc(0xfffd,0);
              }
              if ((rc == -4) && ((isdefault != 0 || (trydefault != 0)))) {
                rc = conv_uni_to_pc(0xfffd,1);
              }
              if (rc < 0x20) {
                if (rc < 1) {
                  *outbuf = '\0';
                  local_3c = rc;
                }
                else {
                  local_3c = rc;
                }
              }
              else {
                *outbuf = (char)rc;
                outbuf[1] = '\0';
                local_3c = 1;
              }
            }
          }
          else {
            local_3c = strlen(outbuf);
          }
        }
        else {
          *outbuf = (char)src;
          outbuf[1] = '\0';
          local_3c = 1;
        }
      }
    }
  }
  else {
    *outbuf = ch_in;
    outbuf[1] = '\0';
    local_3c = 1;
  }
  return local_3c;
}



// WARNING: Unknown calling convention

int UC_FindGN_byMIME(char *UC_MIMEcharset)

{
  int iVar1;
  int i;
  
  i = 0;
  while( true ) {
    if (3 < i) {
      return -1;
    }
    iVar1 = strcmp(UC_MIMEcharset,UC_GNsetMIMEnames[i]);
    if (iVar1 == 0) break;
    i = i + 1;
  }
  return i;
}



// WARNING: Unknown calling convention

int UCGetRawUniMode_byLYhndl(int i)

{
  int local_8;
  
  if (i < 0) {
    local_8 = 0;
  }
  else {
    local_8 = LYCharSet_UC[i].enc;
  }
  return local_8;
}



// WARNING: Unknown calling convention

int getLYhndl_byCP(char *prefix,char *codepage)

{
  bool bVar1;
  char *cptmp;
  int result;
  
  result = -1;
  bVar1 = getLYhndl_byCP::nested == 0;
  getLYhndl_byCP::nested = getLYhndl_byCP::nested + 1;
  if (bVar1) {
    cptmp = (char *)0x0;
    HTSACopy(&cptmp,prefix);
    HTSACat(&cptmp,codepage);
    result = UCGetLYhndl_byMIME(cptmp);
    if (cptmp != (char *)0x0) {
      free(cptmp);
    }
  }
  getLYhndl_byCP::nested = getLYhndl_byCP::nested + -1;
  return result;
}



// WARNING: Unknown calling convention

int UCGetLYhndl_byMIME(char *value)

{
  FILE *pFVar1;
  int iVar2;
  ushort **ppuVar3;
  int local_18;
  int LYhndl;
  int i;
  
  if ((value == (char *)0x0) || (*value == '\0')) {
    if (WWW_TraceFlag != '\0') {
      pFVar1 = TraceFP();
      fprintf((FILE *)pFVar1,"UCGetLYhndl_byMIME: NULL argument instead of MIME name.\n");
    }
    local_18 = -1;
  }
  else {
    for (i = 0; ((i < 0x3c && (i < LYNumCharsets)) && (LYchar_set_names[i] != (char *)0x0));
        i = i + 1) {
      if ((LYCharSet_UC[i].MIMEname != (char *)0x0) &&
         (iVar2 = strcasecomp(value,LYCharSet_UC[i].MIMEname), iVar2 == 0)) {
        return i;
      }
    }
    iVar2 = strcasecomp(value,"unicode-1-1-utf-8");
    if ((iVar2 == 0) || (iVar2 = strcasecomp(value,"utf8"), iVar2 == 0)) {
      local_18 = UCGetLYhndl_byMIME("utf-8");
    }
    else {
      iVar2 = strcasecomp(value,"x-euc-jp");
      if (iVar2 == 0) {
        local_18 = UCGetLYhndl_byMIME("euc-jp");
      }
      else {
        iVar2 = strcasecomp(value,"x-shift-jis");
        if ((iVar2 == 0) || (iVar2 = strcasecomp(value,"x-sjis"), iVar2 == 0)) {
          local_18 = UCGetLYhndl_byMIME("shift_jis");
        }
        else {
          iVar2 = strcasecomp(value,"iso-2022-kr");
          if (iVar2 == 0) {
            local_18 = UCGetLYhndl_byMIME("euc-kr");
          }
          else {
            iVar2 = strcasecomp(value,"gb2312");
            if (((iVar2 == 0) || (iVar2 = strncasecomp(value,"cn-gb",5), iVar2 == 0)) ||
               (iVar2 = strcasecomp(value,"iso-2022-cn"), iVar2 == 0)) {
              local_18 = UCGetLYhndl_byMIME("euc-cn");
            }
            else {
              iVar2 = strcasecomp(value,"cn-big5");
              if (iVar2 == 0) {
                local_18 = UCGetLYhndl_byMIME("big5");
              }
              else {
                iVar2 = strcasecomp(value,"x-mac-roman");
                if ((iVar2 == 0) || (iVar2 = strcasecomp(value,"mac-roman"), iVar2 == 0)) {
                  local_18 = UCGetLYhndl_byMIME("macintosh");
                }
                else {
                  iVar2 = strcasecomp(value,"x-next");
                  if (((iVar2 == 0) || (iVar2 = strcasecomp(value,"nextstep"), iVar2 == 0)) ||
                     (iVar2 = strcasecomp(value,"x-nextstep"), iVar2 == 0)) {
                    local_18 = UCGetLYhndl_byMIME("next");
                  }
                  else {
                    iVar2 = strcasecomp(value,"iso-8859-1-windows-3.1-latin-1");
                    if ((((iVar2 == 0) || (iVar2 = strcasecomp(value,"cp1252"), iVar2 == 0)) ||
                        (iVar2 = strcasecomp(value,"cp-1252"), iVar2 == 0)) ||
                       ((iVar2 = strcasecomp(value,"ibm1252"), iVar2 == 0 ||
                        (iVar2 = strcasecomp(value,"iso-8859-1-windows-3.0-latin-1"), iVar2 == 0))))
                    {
                      local_18 = UCGetLYhndl_byMIME("windows-1252");
                    }
                    else {
                      iVar2 = strcasecomp(value,"iso-8859-2-windows-latin-2");
                      if (((iVar2 == 0) || (iVar2 = strcasecomp(value,"cp1250"), iVar2 == 0)) ||
                         ((iVar2 = strcasecomp(value,"cp-1250"), iVar2 == 0 ||
                          (iVar2 = strcasecomp(value,"ibm1250"), iVar2 == 0)))) {
                        local_18 = UCGetLYhndl_byMIME("windows-1250");
                      }
                      else {
                        iVar2 = strncasecomp(value,"ibm",3);
                        if ((((iVar2 == 0) || (iVar2 = strncasecomp(value,"cp-",3), iVar2 == 0)) &&
                            (ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[(byte)value[3]] & 0x800) != 0))
                           && ((ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[(byte)value[4]] & 0x800) != 0
                               && (ppuVar3 = __ctype_b_loc(),
                                  ((*ppuVar3)[(byte)value[5]] & 0x800) != 0)))) {
                          local_18 = getLYhndl_byCP("cp",value + 3);
                          if (local_18 < 0) {
                            local_18 = getLYhndl_byCP("windows-",value + 3);
                          }
                        }
                        else {
                          iVar2 = strncasecomp(value,"windows-",8);
                          if (((iVar2 == 0) &&
                              ((ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[(byte)value[8]] & 0x800) != 0
                               && (ppuVar3 = __ctype_b_loc(),
                                  ((*ppuVar3)[(byte)value[9]] & 0x800) != 0)))) &&
                             (ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[(byte)value[10]] & 0x800) != 0)
                             ) {
                            local_18 = getLYhndl_byCP("cp",value + 8);
                          }
                          else {
                            iVar2 = strcasecomp(value,"koi-8");
                            if (iVar2 == 0) {
                              local_18 = UCGetLYhndl_byMIME("koi8-r");
                            }
                            else {
                              iVar2 = strcasecomp(value,"ANSI_X3.4-1968");
                              if (iVar2 == 0) {
                                local_18 = US_ASCII;
                              }
                              else {
                                if (WWW_TraceFlag != '\0') {
                                  pFVar1 = TraceFP();
                                  fprintf((FILE *)pFVar1,
                                          "UCGetLYhndl_byMIME: unrecognized MIME name \"%s\"\n",
                                          value);
                                }
                                local_18 = -1;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return local_18;
}



// WARNING: Unknown calling convention

void UCreset_allocated_LYCharSets(void)

{
  int i;
  
  for (i = 0; i < 0x3c; i = i + 1) {
    remember_allocated_LYCharSets[i] = (char **)0x0;
  }
  return;
}



// WARNING: Unknown calling convention

char ** UC_setup_LYCharSets_repl(int UC_charset_in_hndl,uint lowest8)

{
  ushort uVar1;
  char *__s1;
  byte *pbVar2;
  char **ppcVar3;
  void *__ptr;
  void *__ptr_00;
  HTAtom *pHVar4;
  int iVar5;
  bool bVar6;
  char **local_48;
  unipair_str *list;
  uchar *ti;
  int changed;
  int j;
  size_t i;
  char *s8;
  char *s7;
  char **tp;
  ushort *pp;
  char **prepl;
  char **p;
  char **ISO_Latin1;
  ushort ct;
  ushort k;
  
  ppcVar3 = LYCharSets[0];
  __ptr = malloc(0x180);
  if (__ptr == (void *)0x0) {
    local_48 = (char **)0x0;
  }
  else {
    for (i = 0; i < 0x60; i = i + 1) {
      *(undefined4 *)(i * 4 + (int)__ptr) = 0;
    }
    __ptr_00 = malloc(0x60);
    if (__ptr_00 == (void *)0x0) {
      if (__ptr != (void *)0x0) {
        free(__ptr);
      }
      local_48 = (char **)0x0;
    }
    else {
      for (i = 0; i < 0x60; i = i + 1) {
        *(undefined *)((int)__ptr_00 + i) = 0;
      }
      pp = UCInfo[UC_charset_in_hndl].unitable;
      if (0 < UCInfo[UC_charset_in_hndl].num_uni) {
        for (i = 0; i < 0x100; i = i + 1) {
          j = (int)UCInfo[UC_charset_in_hndl].unicount[i];
          if (j != 0) {
            uVar1 = *pp;
            if (((0x9f < uVar1) && (uVar1 < 0x100)) && (lowest8 <= i)) {
              *(char *)((uVar1 - 0xa0) + (int)__ptr_00) = (char)i;
            }
            for (; j != 0; j = j + -1) {
              pp = pp + 1;
            }
          }
        }
      }
      ct = UCInfo[UC_charset_in_hndl].replacedesc.entry_ct;
      list = UCInfo[UC_charset_in_hndl].replacedesc.entries;
      while (bVar6 = ct != 0, ct = ct - 1, bVar6) {
        uVar1 = list->unicode;
        if ((0x9f < uVar1) && (uVar1 < 0x100)) {
          *(char **)((uVar1 - 0xa0) * 4 + (int)__ptr) = list->replace_str;
        }
        list = list + 1;
      }
      local_48 = (char **)malloc(0x1c0);
      if (local_48 == (char **)0x0) {
        if (__ptr != (void *)0x0) {
          free(__ptr);
        }
        if (__ptr_00 != (void *)0x0) {
          free(__ptr_00);
        }
        local_48 = (char **)0x0;
      }
      else {
        bVar6 = false;
        p = local_48;
        for (i = 0; i < 0x70; i = i + 1) {
          __s1 = SevenBitApproximations[i];
          pbVar2 = (byte *)ppcVar3[i];
          *p = __s1;
          if (((pbVar2 != (byte *)0x0) && (0x9f < *pbVar2)) && (pbVar2[1] == 0)) {
            if ((*(byte *)((*pbVar2 - 0xa0) + (int)__ptr_00) < (byte)lowest8) ||
               (((int)*__s1 == (uint)*(byte *)((*pbVar2 - 0xa0) + (int)__ptr_00) &&
                (__s1[1] == '\0')))) {
              if ((*(int *)((*pbVar2 - 0xa0) * 4 + (int)__ptr) != 0) &&
                 (iVar5 = strcmp(__s1,*(char **)((*pbVar2 - 0xa0) * 4 + (int)__ptr)), iVar5 != 0)) {
                *p = *(char **)((*pbVar2 - 0xa0) * 4 + (int)__ptr);
                bVar6 = true;
              }
            }
            else {
              if (*(byte *)((*pbVar2 - 0xa0) + (int)__ptr_00) == *pbVar2) {
                *p = (char *)pbVar2;
              }
              else {
                UC_setup_LYCharSets_repl::dummy[0] = *(char *)((*pbVar2 - 0xa0) + (int)__ptr_00);
                pHVar4 = HTAtom_for(UC_setup_LYCharSets_repl::dummy);
                *p = pHVar4->name;
              }
              bVar6 = true;
            }
          }
          p = p + 1;
        }
        if (__ptr != (void *)0x0) {
          free(__ptr);
        }
        if (__ptr_00 != (void *)0x0) {
          free(__ptr_00);
        }
        if (!bVar6) {
          if (local_48 != (char **)0x0) {
            free(local_48);
          }
          local_48 = (char **)0x0;
        }
      }
    }
  }
  return local_48;
}



// WARNING: Unknown calling convention

int UC_Register_with_LYCharSets(int s,char *UC_MIMEcharset,char *UC_LYNXcharset,int lowest_eightbit)

{
  int *piVar1;
  bool bVar2;
  int iVar3;
  FILE *__stream;
  char **ppcVar4;
  char **repl;
  int found;
  int LYhndl;
  int i;
  
  LYhndl = -1;
  if (LYNumCharsets == 0) {
    for (i = 0; (i < 0x3c && (LYchar_set_names[i] != (char *)0x0)); i = i + 1) {
      LYNumCharsets = i + 1;
    }
  }
  i = 0;
  while (((iVar3 = LYNumCharsets, i < 0x3c && (LYchar_set_names[i] != (char *)0x0)) && (LYhndl < 0))
        ) {
    if ((LYCharSet_UC[i].MIMEname != (char *)0x0) &&
       (iVar3 = strcmp(UC_MIMEcharset,LYCharSet_UC[i].MIMEname), iVar3 == 0)) {
      LYhndl = i;
    }
    i = i + 1;
  }
  if (LYhndl < 0) {
    bVar2 = false;
    if (0x3b < LYNumCharsets) {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"UC_Register_with_LYCharSets: Too many.  Ignoring %s/%s.",
                UC_MIMEcharset,UC_LYNXcharset);
      }
      return -1;
    }
    LYhndl = LYNumCharsets;
    piVar1 = LYlowest_eightbit + LYNumCharsets;
    LYNumCharsets = LYNumCharsets + 1;
    *piVar1 = 999;
    LYCharSets[iVar3] = SevenBitApproximations;
    LYchar_set_names[iVar3] = UC_LYNXcharset;
    LYchar_set_names[iVar3 + 1] = (char *)0x0;
  }
  else {
    bVar2 = true;
  }
  LYCharSet_UC[LYhndl].UChndl = s;
  LYCharSet_UC[LYhndl].MIMEname = UC_MIMEcharset;
  LYCharSet_UC[LYhndl].enc = UCInfo[s].enc;
  LYCharSet_UC[LYhndl].codepage = UCInfo[s].codepage;
  if (lowest_eightbit < LYlowest_eightbit[LYhndl]) {
    LYlowest_eightbit[LYhndl] = lowest_eightbit;
  }
  else if (LYlowest_eightbit[LYhndl] < lowest_eightbit) {
    UCInfo[s].lowest_eight = LYlowest_eightbit[LYhndl];
  }
  if (((!bVar2) && (0 < LYhndl)) &&
     (ppcVar4 = UC_setup_LYCharSets_repl(s,UCInfo[s].lowest_eight), ppcVar4 != (char **)0x0)) {
    LYCharSets[LYhndl] = ppcVar4;
    remember_allocated_LYCharSets[LYhndl] = ppcVar4;
  }
  return LYhndl;
}



// WARNING: Unknown calling convention

void UC_Charset_Setup(char *UC_MIMEcharset,char *UC_LYNXcharset,uchar *unicount,ushort *unitable,
                     int nnuni,unimapdesc_str replacedesc,int lowest_eight,int UC_rawuni,
                     int codepage)

{
  FILE *__stream;
  int iVar1;
  int found;
  int status;
  int i;
  int Gn;
  int s;
  
  found = -1;
  i = 0;
  while ((i < UCNumCharsets && (found < 0))) {
    iVar1 = strcmp(UCInfo[i].MIMEname,UC_MIMEcharset);
    if (iVar1 == 0) {
      found = i;
    }
    i = i + 1;
  }
  if (found < 0) {
    if (0x3b < UCNumCharsets) {
      if (WWW_TraceFlag == '\0') {
        return;
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,"UC_Charset_Setup: Too many.  Ignoring %s/%s.",UC_MIMEcharset,
              UC_LYNXcharset);
      return;
    }
    s = UCNumCharsets;
    UCInfo[UCNumCharsets].MIMEname = UC_MIMEcharset;
  }
  else {
    s = found;
  }
  UCInfo[s].LYNXname = UC_LYNXcharset;
  UCInfo[s].unicount = unicount;
  UCInfo[s].unitable = unitable;
  UCInfo[s].num_uni = nnuni;
  UCInfo[s].replacedesc.entry_ct = replacedesc.entry_ct;
  *(undefined2 *)&UCInfo[s].replacedesc.field_0x2 = replacedesc._2_2_;
  UCInfo[s].replacedesc.entries = replacedesc.entries;
  UCInfo[s].replacedesc.isdefault = replacedesc.isdefault;
  UCInfo[s].replacedesc.trydefault = replacedesc.trydefault;
  if (replacedesc.isdefault != 0) {
    default_UChndl = s;
  }
  iVar1 = UC_FindGN_byMIME(UC_MIMEcharset);
  if (-1 < iVar1) {
    UC_GNhandles[iVar1] = s;
  }
  UCInfo[s].GN = iVar1;
  if (UC_rawuni == 7) {
    lowest_eight = 0x80;
  }
  UCInfo[s].lowest_eight = lowest_eight;
  UCInfo[s].enc = UC_rawuni;
  UCInfo[s].codepage = codepage;
  iVar1 = UC_Register_with_LYCharSets(s,UC_MIMEcharset,UC_LYNXcharset,lowest_eight);
  UCInfo[s].LYhndl = iVar1;
  UCInfo[s].uc_status = 0;
  if (found < 0) {
    UCNumCharsets = UCNumCharsets + 1;
  }
  return;
}



// WARNING: Unknown calling convention

int UC_NoUctb_Register_with_LYCharSets
              (char *UC_MIMEcharset,char *UC_LYNXcharset,int lowest_eightbit,int UC_rawuni,
              int codepage)

{
  int *piVar1;
  int iVar2;
  FILE *__stream;
  int local_18;
  int LYhndl;
  int i;
  
  if (LYNumCharsets == 0) {
    for (i = 0; (i < 0x3c && (LYchar_set_names[i] != (char *)0x0)); i = i + 1) {
      LYNumCharsets = i + 1;
    }
  }
  i = 0;
  while( true ) {
    local_18 = LYNumCharsets;
    if ((0x3b < i) || (LYchar_set_names[i] == (char *)0x0)) {
      if (LYNumCharsets < 0x3c) {
        piVar1 = LYlowest_eightbit + LYNumCharsets;
        LYNumCharsets = LYNumCharsets + 1;
        *piVar1 = lowest_eightbit;
        LYCharSets[local_18] = SevenBitApproximations;
        LYchar_set_names[local_18] = UC_LYNXcharset;
        LYchar_set_names[local_18 + 1] = (char *)0x0;
        LYCharSet_UC[local_18].UChndl = -1;
        LYCharSet_UC[local_18].MIMEname = UC_MIMEcharset;
        LYCharSet_UC[local_18].enc = UC_rawuni;
        LYCharSet_UC[local_18].codepage = codepage;
      }
      else {
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"UC_NoUctb_Register_with_LYCharSets: Too many.  Ignoring %s/%s.",
                  UC_MIMEcharset,UC_LYNXcharset);
        }
        local_18 = -1;
      }
      return local_18;
    }
    if ((LYCharSet_UC[i].MIMEname != (char *)0x0) &&
       (iVar2 = strcmp(UC_MIMEcharset,LYCharSet_UC[i].MIMEname), iVar2 == 0)) break;
    i = i + 1;
  }
  return -1;
}



// WARNING: Unknown calling convention

void UC_Charset_NoUctb_Setup
               (char *UC_MIMEcharset,char *UC_LYNXcharset,int trydefault,int lowest_eight,
               int UC_rawuni,int codepage)

{
  int iVar1;
  int i;
  
  i = 0;
  while( true ) {
    if (UCNumCharsets <= i) {
      if (UC_rawuni == 7) {
        lowest_eight = 0x80;
      }
      if ((trydefault == 0) && (codepage == 0)) {
        codepage = -0xc;
      }
      UC_NoUctb_Register_with_LYCharSets
                (UC_MIMEcharset,UC_LYNXcharset,lowest_eight,UC_rawuni,codepage);
      return;
    }
    iVar1 = strcmp(UCInfo[i].MIMEname,UC_MIMEcharset);
    if (iVar1 == 0) break;
    i = i + 1;
  }
  return;
}



// WARNING: Unknown calling convention

void UCInit(void)

{
  unimapdesc_str replacedesc;
  unimapdesc_str replacedesc_00;
  unimapdesc_str replacedesc_01;
  unimapdesc_str replacedesc_02;
  unimapdesc_str replacedesc_03;
  unimapdesc_str replacedesc_04;
  unimapdesc_str replacedesc_05;
  unimapdesc_str replacedesc_06;
  unimapdesc_str replacedesc_07;
  unimapdesc_str replacedesc_08;
  unimapdesc_str replacedesc_09;
  unimapdesc_str replacedesc_10;
  unimapdesc_str replacedesc_11;
  unimapdesc_str replacedesc_12;
  unimapdesc_str replacedesc_13;
  unimapdesc_str replacedesc_14;
  unimapdesc_str replacedesc_15;
  unimapdesc_str replacedesc_16;
  unimapdesc_str replacedesc_17;
  unimapdesc_str replacedesc_18;
  unimapdesc_str replacedesc_19;
  unimapdesc_str replacedesc_20;
  unimapdesc_str replacedesc_21;
  unimapdesc_str replacedesc_22;
  unimapdesc_str replacedesc_23;
  unimapdesc_str replacedesc_24;
  unimapdesc_str replacedesc_25;
  unimapdesc_str replacedesc_26;
  unimapdesc_str replacedesc_27;
  unimapdesc_str replacedesc_28;
  unimapdesc_str replacedesc_29;
  unimapdesc_str replacedesc_30;
  unimapdesc_str replacedesc_31;
  unimapdesc_str replacedesc_32;
  unimapdesc_str replacedesc_33;
  unimapdesc_str replacedesc_34;
  unimapdesc_str replacedesc_35;
  unimapdesc_str replacedesc_36;
  unimapdesc_str replacedesc_37;
  unimapdesc_str replacedesc_38;
  
  UCreset_allocated_LYCharSets();
  UCconsole_map_init();
  replacedesc.trydefault = 1;
  replacedesc.entry_ct = 0x43;
  replacedesc._2_2_ = 0;
  replacedesc.entries = (unipair_str *)0x81a1460;
  replacedesc.isdefault = 0;
  UC_Charset_Setup("iso-8859-1","Western (ISO-8859-1)","",dfont_unitable_iso_8859_1,0xc9,replacedesc
                   ,0xa0,2,0x333);
  replacedesc_00.trydefault = 1;
  replacedesc_00.entry_ct = 0;
  replacedesc_00._2_2_ = 0;
  replacedesc_00.entries = (unipair_str *)0x0;
  replacedesc_00.isdefault = 0;
  UC_Charset_Setup("iso-8859-15","Western (ISO-8859-15)","",dfont_unitable_iso_8859_15,0xbf,
                   replacedesc_00,0xa0,2,0);
  replacedesc_01.trydefault = 1;
  replacedesc_01.entry_ct = 8;
  replacedesc_01._2_2_ = 0;
  replacedesc_01.entries = (unipair_str *)0x819c1a0;
  replacedesc_01.isdefault = 0;
  UC_Charset_Setup("cp850","Western (cp850)","",dfont_unitable_cp850,0xf7,replacedesc_01,0x80,1,
                   0x352);
  replacedesc_02.trydefault = 1;
  replacedesc_02.entry_ct = 9;
  replacedesc_02._2_2_ = 0;
  replacedesc_02.entries = (unipair_str *)0x819c080;
  replacedesc_02.isdefault = 0;
  UC_Charset_Setup("windows-1252","Western (windows-1252)","",dfont_unitable_windows_1252,0xe5,
                   replacedesc_02,0x80,1,0x4e4);
  replacedesc_03.trydefault = 1;
  replacedesc_03.entry_ct = 0xc;
  replacedesc_03._2_2_ = 0;
  replacedesc_03.entries = (unipair_str *)0x819c0e0;
  replacedesc_03.isdefault = 0;
  UC_Charset_Setup("cp437","IBM PC US codepage (cp437)","",dfont_unitable_cp437,0xf7,replacedesc_03,
                   0x80,1,0x1b5);
  replacedesc_04.trydefault = 1;
  replacedesc_04.entry_ct = 0x11;
  replacedesc_04._2_2_ = 0;
  replacedesc_04.entries = (unipair_str *)0x81a13c0;
  replacedesc_04.isdefault = 0;
  UC_Charset_Setup("dec-mcs","DEC Multinational","",dfont_unitable_dec_mcs,0xb0,replacedesc_04,0xa1,
                   2,0);
  replacedesc_05.trydefault = 1;
  replacedesc_05.entry_ct = 0xe;
  replacedesc_05._2_2_ = 0;
  replacedesc_05.entries = (unipair_str *)0x81a1840;
  replacedesc_05.isdefault = 0;
  UC_Charset_Setup("macintosh","Macintosh (8 bit)","",dfont_unitable_macintosh,0xe2,replacedesc_05,
                   0x80,1,0);
  replacedesc_06.trydefault = 1;
  replacedesc_06.entry_ct = 0;
  replacedesc_06._2_2_ = 0;
  replacedesc_06.entries = (unipair_str *)0x0;
  replacedesc_06.isdefault = 0;
  UC_Charset_Setup("next","NeXT character set","",dfont_unitable_next,0xde,replacedesc_06,0x80,1,0);
  replacedesc_07.trydefault = 1;
  replacedesc_07.entry_ct = 0;
  replacedesc_07._2_2_ = 0;
  replacedesc_07.entries = (unipair_str *)0x0;
  replacedesc_07.isdefault = 0;
  UC_Charset_Setup("hp-roman8","HP Roman8","",dfont_unitable_hp_roman8,0xbe,replacedesc_07,0xa0,1,0)
  ;
  UC_Charset_NoUctb_Setup("euc-cn","Chinese",1,0x80,5,0);
  UC_Charset_NoUctb_Setup("euc-jp","Japanese (EUC-JP)",1,0x80,5,0);
  UC_Charset_NoUctb_Setup("shift_jis","Japanese (Shift_JIS)",1,0x80,5,0);
  UC_Charset_NoUctb_Setup("euc-kr","Korean",1,0x80,5,0);
  UC_Charset_NoUctb_Setup("big5","Taipei (Big5)",1,0x80,5,0);
  replacedesc_08.trydefault = 1;
  replacedesc_08.entry_ct = 8;
  replacedesc_08._2_2_ = 0;
  replacedesc_08.entries = (unipair_str *)0x81a8f60;
  replacedesc_08.isdefault = 0;
  UC_Charset_Setup("viscii","Vietnamese (VISCII)","",dfont_unitable_viscii,0x8e,replacedesc_08,0x80,
                   3,0);
  replacedesc_09.isdefault = 1;
  replacedesc_09.entry_ct = 0xa32;
  replacedesc_09._2_2_ = 0;
  replacedesc_09.entries = (unipair_str *)0x819c220;
  replacedesc_09.trydefault = 0;
  UC_Charset_Setup("us-ascii","7 bit approximations (US-ASCII)","",dfont_unitable,0x268,
                   replacedesc_09,999,0,0);
  UC_Charset_NoUctb_Setup("x-transparent","Transparent",0,0x80,1,0);
  replacedesc_10.trydefault = 1;
  replacedesc_10.entry_ct = 7;
  replacedesc_10._2_2_ = 0;
  replacedesc_10.entries = (unipair_str *)0x81a1680;
  replacedesc_10.isdefault = 0;
  UC_Charset_Setup("iso-8859-2","Eastern European (ISO-8859-2)","",dfont_unitable_iso_8859_2,0xd1,
                   replacedesc_10,0xa0,2,0x390);
  replacedesc_11.trydefault = 1;
  replacedesc_11.entry_ct = 7;
  replacedesc_11._2_2_ = 0;
  replacedesc_11.entries = (unipair_str *)0x819c1e0;
  replacedesc_11.isdefault = 0;
  UC_Charset_Setup("cp852","Eastern European (cp852)","",dfont_unitable_cp852,0xfb,replacedesc_11,
                   0x80,1,0x354);
  replacedesc_12.trydefault = 1;
  replacedesc_12.entry_ct = 8;
  replacedesc_12._2_2_ = 0;
  replacedesc_12.entries = (unipair_str *)0x819c040;
  replacedesc_12.isdefault = 0;
  UC_Charset_Setup("windows-1250","Eastern European (windows-1250)","",dfont_unitable_windows_1250,
                   0xeb,replacedesc_12,0x80,1,0x4e2);
  replacedesc_13.trydefault = 1;
  replacedesc_13.entry_ct = 0;
  replacedesc_13._2_2_ = 0;
  replacedesc_13.entries = (unipair_str *)0x0;
  replacedesc_13.isdefault = 0;
  UC_Charset_Setup("iso-8859-3","Latin 3 (ISO-8859-3)","",dfont_unitable_iso_8859_3,0xb8,
                   replacedesc_13,0xa0,2,0x391);
  replacedesc_14.trydefault = 1;
  replacedesc_14.entry_ct = 0;
  replacedesc_14._2_2_ = 0;
  replacedesc_14.entries = (unipair_str *)0x0;
  replacedesc_14.isdefault = 0;
  UC_Charset_Setup("iso-8859-4","Latin 4 (ISO-8859-4)","",dfont_unitable_iso_8859_4,0x61,
                   replacedesc_14,0xa0,2,0x392);
  replacedesc_15.trydefault = 1;
  replacedesc_15.entry_ct = 0;
  replacedesc_15._2_2_ = 0;
  replacedesc_15.entries = (unipair_str *)0x0;
  replacedesc_15.isdefault = 0;
  UC_Charset_Setup("iso-8859-13","Baltic Rim (ISO-8859-13)","",dfont_unitable_iso_8859_13,0xbf,
                   replacedesc_15,0xa0,2,0);
  replacedesc_16.trydefault = 1;
  replacedesc_16.entry_ct = 0;
  replacedesc_16._2_2_ = 0;
  replacedesc_16.entries = (unipair_str *)0x0;
  replacedesc_16.isdefault = 0;
  UC_Charset_Setup("cp775","Baltic Rim (cp775)","",dfont_unitable_cp775,0xdf,replacedesc_16,0x80,1,
                   0x307);
  replacedesc_17.trydefault = 1;
  replacedesc_17.entry_ct = 0;
  replacedesc_17._2_2_ = 0;
  replacedesc_17.entries = (unipair_str *)0x0;
  replacedesc_17.isdefault = 0;
  UC_Charset_Setup("windows-1257","Baltic Rim (windows-1257)","",dfont_unitable_windows_1257,0xd3,
                   replacedesc_17,0x80,1,0x4e9);
  replacedesc_18.trydefault = 1;
  replacedesc_18.entry_ct = 4;
  replacedesc_18._2_2_ = 0;
  replacedesc_18.entries = (unipair_str *)0x81a16c0;
  replacedesc_18.isdefault = 0;
  UC_Charset_Setup("iso-8859-5","Cyrillic (ISO-8859-5)","",dfont_unitable_iso_8859_5,0xd0,
                   replacedesc_18,0xa0,2,0x393);
  replacedesc_19.trydefault = 1;
  replacedesc_19.entry_ct = 0;
  replacedesc_19._2_2_ = 0;
  replacedesc_19.entries = (unipair_str *)0x0;
  replacedesc_19.isdefault = 0;
  UC_Charset_Setup("cp866","Cyrillic (cp866)","",dfont_unitable_cp866,0xe0,replacedesc_19,0x80,1,
                   0x362);
  replacedesc_20.trydefault = 1;
  replacedesc_20.entry_ct = 0;
  replacedesc_20._2_2_ = 0;
  replacedesc_20.entries = (unipair_str *)0x0;
  replacedesc_20.isdefault = 0;
  UC_Charset_Setup("windows-1251","Cyrillic (windows-1251)","",dfont_unitable_windows_1251,0xde,
                   replacedesc_20,0x80,1,0x4e3);
  replacedesc_21.trydefault = 1;
  replacedesc_21.entry_ct = 0;
  replacedesc_21._2_2_ = 0;
  replacedesc_21.entries = (unipair_str *)0x0;
  replacedesc_21.isdefault = 0;
  UC_Charset_Setup("koi8-r","Cyrillic (KOI8-R)","",dfont_unitable_koi8_r,0xef,replacedesc_21,0x80,1,
                   0x36e);
  replacedesc_22.trydefault = 1;
  replacedesc_22.entry_ct = 0;
  replacedesc_22._2_2_ = 0;
  replacedesc_22.entries = (unipair_str *)0x0;
  replacedesc_22.isdefault = 0;
  UC_Charset_Setup("iso-8859-6","Arabic (ISO-8859-6)","",dfont_unitable_iso_8859_6,0x92,
                   replacedesc_22,0xa0,2,0x441);
  replacedesc_23.trydefault = 1;
  replacedesc_23.entry_ct = 0;
  replacedesc_23._2_2_ = 0;
  replacedesc_23.entries = (unipair_str *)0x0;
  replacedesc_23.isdefault = 0;
  UC_Charset_Setup("cp864","Arabic (cp864)","",dfont_unitable_cp864,0xda,replacedesc_23,0x80,1,0x360
                  );
  replacedesc_24.trydefault = 1;
  replacedesc_24.entry_ct = 0;
  replacedesc_24._2_2_ = 0;
  replacedesc_24.entries = (unipair_str *)0x0;
  replacedesc_24.isdefault = 0;
  UC_Charset_Setup("windows-1256","Arabic (windows-1256)","",dfont_unitable_windows_1256,0xdf,
                   replacedesc_24,0x80,1,0x4e8);
  replacedesc_25.trydefault = 1;
  replacedesc_25.entry_ct = 0;
  replacedesc_25._2_2_ = 0;
  replacedesc_25.entries = (unipair_str *)0x0;
  replacedesc_25.isdefault = 0;
  UC_Charset_Setup("iso-8859-14","Celtic (ISO-8859-14)","",dfont_unitable_iso_8859_14,0xbf,
                   replacedesc_25,0xa0,2,0);
  replacedesc_26.trydefault = 1;
  replacedesc_26.entry_ct = 6;
  replacedesc_26._2_2_ = 0;
  replacedesc_26.entries = (unipair_str *)0x81a16e0;
  replacedesc_26.isdefault = 0;
  UC_Charset_Setup("iso-8859-7","Greek (ISO-8859-7)","",dfont_unitable_iso_8859_7,0xdc,
                   replacedesc_26,0xa0,2,0x32d);
  replacedesc_27.trydefault = 1;
  replacedesc_27.entry_ct = 9;
  replacedesc_27._2_2_ = 0;
  replacedesc_27.entries = (unipair_str *)0x819c140;
  replacedesc_27.isdefault = 0;
  UC_Charset_Setup("cp737","Greek (cp737)","",dfont_unitable_cp737,0xe7,replacedesc_27,0x80,1,0x2e1)
  ;
  replacedesc_28.trydefault = 1;
  replacedesc_28.entry_ct = 0;
  replacedesc_28._2_2_ = 0;
  replacedesc_28.entries = (unipair_str *)0x0;
  replacedesc_28.isdefault = 0;
  UC_Charset_Setup("cp869","Greek2 (cp869)","",dfont_unitable_cp869,0xd9,replacedesc_28,0x86,1,0x365
                  );
  replacedesc_29.trydefault = 1;
  replacedesc_29.entry_ct = 0;
  replacedesc_29._2_2_ = 0;
  replacedesc_29.entries = (unipair_str *)0x0;
  replacedesc_29.isdefault = 0;
  UC_Charset_Setup("windows-1253","Greek (windows-1253)","",dfont_unitable_windows_1253,0xd0,
                   replacedesc_29,0x80,1,0x4e5);
  replacedesc_30.trydefault = 1;
  replacedesc_30.entry_ct = 0x16;
  replacedesc_30._2_2_ = 0;
  replacedesc_30.entries = (unipair_str *)0x81a1720;
  replacedesc_30.isdefault = 0;
  UC_Charset_Setup("iso-8859-8","Hebrew (ISO-8859-8)","",dfont_unitable_iso_8859_8,0x9b,
                   replacedesc_30,0xa0,2,0x394);
  replacedesc_31.trydefault = 1;
  replacedesc_31.entry_ct = 0;
  replacedesc_31._2_2_ = 0;
  replacedesc_31.entries = (unipair_str *)0x0;
  replacedesc_31.isdefault = 0;
  UC_Charset_Setup("cp862","Hebrew (cp862)","",dfont_unitable_cp862,0xe0,replacedesc_31,0x80,1,0x35e
                  );
  replacedesc_32.trydefault = 1;
  replacedesc_32.entry_ct = 0;
  replacedesc_32._2_2_ = 0;
  replacedesc_32.entries = (unipair_str *)0x0;
  replacedesc_32.isdefault = 0;
  UC_Charset_Setup("windows-1255","Hebrew (windows-1255)","",dfont_unitable_windows_1255,200,
                   replacedesc_32,0x80,1,0x4e7);
  replacedesc_33.trydefault = 1;
  replacedesc_33.entry_ct = 8;
  replacedesc_33._2_2_ = 0;
  replacedesc_33.entries = (unipair_str *)0x81a17e0;
  replacedesc_33.isdefault = 0;
  UC_Charset_Setup("iso-8859-9","Turkish (ISO-8859-9)","",dfont_unitable_iso_8859_9,0xcd,
                   replacedesc_33,0xa0,2,0x398);
  replacedesc_34.trydefault = 1;
  replacedesc_34.entry_ct = 0;
  replacedesc_34._2_2_ = 0;
  replacedesc_34.entries = (unipair_str *)0x0;
  replacedesc_34.isdefault = 0;
  UC_Charset_Setup("cp857","Turkish (cp857)","",dfont_unitable_cp857,0xdd,replacedesc_34,0x80,1,
                   0x359);
  replacedesc_35.trydefault = 1;
  replacedesc_35.entry_ct = 1;
  replacedesc_35._2_2_ = 0;
  replacedesc_35.entries = (unipair_str *)0x81a1820;
  replacedesc_35.isdefault = 0;
  UC_Charset_Setup("iso-8859-10","North European (ISO-8859-10)","",dfont_unitable_iso_8859_10,0xbf,
                   replacedesc_35,0xa0,2,0);
  UC_Charset_NoUctb_Setup("utf-8","UNICODE (UTF-8)",0,0x80,7,-4);
  UC_Charset_Setup("mnemonic+ascii+0","RFC 1345 w/o Intro","",dfont_unitable_mnemonic_ascii_0,0,
                   (unimapdesc_str)ZEXT816(0x81a52a000000795),999,0,0);
  UC_Charset_Setup("mnemonic","RFC 1345 Mnemonic","",dfont_unitable_mnemonic,0,
                   (unimapdesc_str)ZEXT816(0x81a18c00000073b),999,0,0);
  replacedesc_36.trydefault = 1;
  replacedesc_36.entry_ct = 0;
  replacedesc_36._2_2_ = 0;
  replacedesc_36.entries = (unipair_str *)0x0;
  replacedesc_36.isdefault = 0;
  UC_Charset_Setup("cp866u","Ukrainian Cyrillic (cp866u)","",dfont_unitable_cp866u,0xe0,
                   replacedesc_36,0x80,1,0);
  replacedesc_37.trydefault = 1;
  replacedesc_37.entry_ct = 0;
  replacedesc_37._2_2_ = 0;
  replacedesc_37.entries = (unipair_str *)0x0;
  replacedesc_37.isdefault = 0;
  UC_Charset_Setup("koi8-u","Ukrainian Cyrillic (KOI8-U)","",dfont_unitable_koi8_u,0xe0,
                   replacedesc_37,0x80,1,0);
  replacedesc_38.trydefault = 1;
  replacedesc_38.entry_ct = 0;
  replacedesc_38._2_2_ = 0;
  replacedesc_38.entries = (unipair_str *)0x0;
  replacedesc_38.isdefault = 0;
  UC_Charset_Setup("ptcp154","Cyrillic-Asian (PT154)","",dfont_unitable_ptcp154,0xdf,replacedesc_38,
                   0x80,1,0x604);
  LATIN1 = UCGetLYhndl_byMIME("iso-8859-1");
  US_ASCII = UCGetLYhndl_byMIME("us-ascii");
  UTF8_handle = UCGetLYhndl_byMIME("utf-8");
  TRANSPARENT = UCGetLYhndl_byMIME("x-transparent");
  return;
}



// WARNING: Unknown calling convention

int safeUCGetLYhndl_byMIME(char *value)

{
  FILE *__stream;
  int i;
  
  i = UCGetLYhndl_byMIME(value);
  if ((i == -1) && (i = LATIN1, WWW_TraceFlag != '\0')) {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"safeUCGetLYhndl_byMIME: ISO-8859-1 assumed.\n");
  }
  return i;
}



// WARNING: Unknown calling convention

void LYFindLocaleCharset(void)

{
  bool bVar1;
  FILE *pFVar2;
  char *value_00;
  int iVar3;
  int value;
  char *name;
  BOOLEAN found;
  
  bVar1 = false;
  if (WWW_TraceFlag != '\0') {
    iVar3 = (int)LYLocaleCharset;
    pFVar2 = TraceFP();
    fprintf((FILE *)pFVar2,"LYFindLocaleCharset(%d)\n",iVar3);
  }
  value_00 = nl_langinfo(0xe);
  if (value_00 == (char *)0x0) {
    if (WWW_TraceFlag != '\0') {
      pFVar2 = TraceFP();
      fprintf((FILE *)pFVar2,"Cannot find a MIME name for locale\n");
    }
  }
  else {
    iVar3 = UCGetLYhndl_byMIME(value_00);
    if (iVar3 < 0) {
      if (WWW_TraceFlag != '\0') {
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2,"Cannot find a handle for MIME name \"%s\"\n",value_00);
      }
    }
    else {
      bVar1 = true;
      linedrawing_char_set = iVar3;
      if (WWW_TraceFlag != '\0') {
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2,"Found name \"%s\" -> %d\n",value_00,iVar3);
      }
    }
  }
  if ((bVar1) && (LYLocaleCharset != '\0')) {
    current_char_set = linedrawing_char_set;
  }
  return;
}



// WARNING: Unknown calling convention

BOOLEAN UCCanUniTranslateFrom(int from)

{
  int iVar1;
  BOOLEAN local_5;
  
  if (from < 0) {
    local_5 = '\0';
  }
  else {
    iVar1 = strcmp(LYCharSet_UC[from].MIMEname,"x-transparent");
    if (iVar1 == 0) {
      local_5 = '\0';
    }
    else {
      local_5 = '\x01';
    }
  }
  return local_5;
}



// WARNING: Unknown calling convention

BOOLEAN UCCanTranslateUniTo(int to)

{
  return -1 < to;
}



// WARNING: Unknown calling convention

BOOLEAN UCCanTranslateFromTo(int from,int to)

{
  char *__s1;
  char *__s1_00;
  BOOLEAN BVar1;
  int iVar2;
  char *toname;
  char *fromname;
  
  if (from == to) {
    return '\x01';
  }
  if ((from < 0) || (to < 0)) {
    return '\0';
  }
  if (from == LATIN1) {
    BVar1 = UCCanTranslateUniTo(to);
    return BVar1;
  }
  if ((to != LATIN1) && (LYCharSet_UC[to].enc != 7)) {
    __s1 = LYCharSet_UC[from].MIMEname;
    __s1_00 = LYCharSet_UC[to].MIMEname;
    iVar2 = strcmp(__s1,"x-transparent");
    if ((iVar2 == 0) || (iVar2 = strcmp(__s1_00,"x-transparent"), iVar2 == 0)) {
      return '\x01';
    }
    iVar2 = strcmp(__s1,"us-ascii");
    if (iVar2 == 0) {
      return '\x01';
    }
    if (LYCharSet_UC[from].enc == 5) {
      if (LYCharSet_UC[to].enc != 5) {
        return '\0';
      }
      iVar2 = strcmp(__s1_00,"euc-jp");
      if (((iVar2 == 0) || (iVar2 = strcmp(__s1_00,"shift_jis"), iVar2 == 0)) &&
         ((iVar2 = strcmp(__s1,"euc-jp"), iVar2 == 0 ||
          (iVar2 = strcmp(__s1,"shift_jis"), iVar2 == 0)))) {
        return '\x01';
      }
      return '\0';
    }
    return '\x01';
  }
  BVar1 = UCCanUniTranslateFrom(from);
  return BVar1;
}



// WARNING: Unknown calling convention

BOOLEAN UCNeedNotTranslate(int from,int to)

{
  char *__s1;
  int iVar1;
  char *toname;
  char *fromname;
  
  if (from == to) {
    return '\x01';
  }
  if (from < 0) {
    return '\0';
  }
  if (LYCharSet_UC[from].enc == 0) {
    return '\x01';
  }
  __s1 = LYCharSet_UC[from].MIMEname;
  iVar1 = strcmp(__s1,"x-transparent");
  if ((iVar1 == 0) || (iVar1 = strcmp(__s1,"us-ascii"), iVar1 == 0)) {
    return '\x01';
  }
  if (to < 0) {
    return '\0';
  }
  if ((to == LATIN1) && ((LYCharSet_UC[from].codepoints & 1U) != 0)) {
    return '\x01';
  }
  iVar1 = strcmp(LYCharSet_UC[to].MIMEname,"x-transparent");
  if (iVar1 == 0) {
    return '\x01';
  }
  if (LYCharSet_UC[to].enc != 7) {
    if ((from == LATIN1) && ((LYCharSet_UC[from].codepoints & 2U) != 0)) {
      return '\x01';
    }
    if (LYCharSet_UC[from].enc != 5) {
      return '\0';
    }
    if (HTCJK != NOCJK) {
      if ((HTCJK == JAPANESE) &&
         ((iVar1 = strcmp(__s1,"euc-jp"), iVar1 == 0 ||
          (iVar1 = strcmp(__s1,"shift_jis"), iVar1 == 0)))) {
        return '\x01';
      }
      return '\0';
    }
    return '\0';
  }
  return '\0';
}



// WARNING: Unknown calling convention

void UCSetTransParams(UCTransParams *pT,int cs_in,LYUCcharset *p_in,int cs_out,LYUCcharset *p_out)

{
  char *pcVar1;
  char *pcVar2;
  bool bVar3;
  BOOLEAN BVar4;
  int iVar5;
  int iVar6;
  FILE *__stream;
  BOOLEAN local_48;
  BOOLEAN local_44;
  BOOLEAN local_40;
  BOOLEAN local_38;
  BOOLEAN local_34;
  BOOLEAN local_2c;
  BOOLEAN local_28;
  BOOLEAN local_24;
  BOOLEAN use_ucs;
  BOOLEAN intm_ucs;
  
  if (WWW_TraceFlag != '\0') {
    iVar5 = UCGetLYhndl_byMIME(p_out->MIMEname);
    pcVar1 = p_out->MIMEname;
    iVar6 = UCGetLYhndl_byMIME(p_in->MIMEname);
    pcVar2 = p_in->MIMEname;
    __stream = TraceFP();
    fprintf((FILE *)__stream,"UCSetTransParams: from %s(%d) to %s(%d)\n",pcVar2,iVar6,pcVar1,iVar5);
  }
  pT->trans_C0_to_uni = '\0';
  iVar5 = strcmp(p_in->MIMEname,"x-transparent");
  if ((iVar5 == 0) || (iVar5 = strcmp(p_out->MIMEname,"x-transparent"), iVar5 == 0)) {
    local_48 = '\x01';
  }
  else {
    local_48 = '\0';
  }
  pT->transp = local_48;
  if (pT->transp == '\0') {
    if ((p_in->enc == 5) && (HTCJK != NOCJK)) {
      local_40 = '\x01';
    }
    else {
      local_40 = '\0';
    }
    pT->do_cjk = local_40;
    pT->decode_utf8 = p_in->enc == 7;
    pT->output_utf8 = p_out->enc == 7;
    if (pT->do_cjk == '\0') {
      if (((cs_in == LATIN1) || (pT->decode_utf8 != '\0')) || ((p_in->codepoints & 5U) != 0)) {
        bVar3 = true;
      }
      else {
        bVar3 = false;
      }
      if ((bVar3) || (BVar4 = UCCanUniTranslateFrom(cs_in), BVar4 == '\0')) {
        local_38 = '\0';
      }
      else {
        local_38 = '\x01';
      }
      pT->trans_to_uni = local_38;
      if ((pT->trans_to_uni == '\0') || (p_in->enc != 3)) {
        local_34 = '\0';
      }
      else {
        local_34 = '\x01';
      }
      pT->trans_C0_to_uni = local_34;
      pT->repl_translated_C0 = p_out->enc == 3;
      pT->strip_raw_char_in = '\0';
      if ((bVar3) || (pT->trans_to_uni != '\0')) {
        bVar3 = true;
      }
      else {
        bVar3 = false;
      }
      pT->do_8bitraw = !bVar3;
      if ((bVar3) || ((p_in->like8859 & 0x80U) != 0)) {
        local_2c = '\0';
      }
      else {
        local_2c = '\x01';
      }
      pT->pass_160_173_raw = local_2c;
      if (((pT->output_utf8 == '\0') && (cs_in == cs_out)) && (pT->trans_C0_to_uni == '\0')) {
        local_28 = '\x01';
      }
      else {
        local_28 = '\0';
      }
      pT->use_raw_char_in = local_28;
      if (((bVar3) && (pT->do_8bitraw == '\0')) &&
         ((pT->use_raw_char_in == '\0' && (BVar4 = UCCanTranslateUniTo(cs_out), BVar4 != '\0')))) {
        local_24 = '\x01';
      }
      else {
        local_24 = '\0';
      }
      pT->trans_from_uni = local_24;
      return;
    }
    pT->trans_to_uni = '\0';
    pT->do_8bitraw = '\0';
    pT->pass_160_173_raw = '\x01';
    pT->use_raw_char_in = '\0';
    pT->repl_translated_C0 = '\0';
    pT->trans_from_uni = '\0';
    return;
  }
  pT->do_cjk = '\0';
  pT->decode_utf8 = '\0';
  pT->output_utf8 = '\0';
  pT->do_8bitraw = '\x01';
  pT->use_raw_char_in = '\x01';
  pT->strip_raw_char_in = '\0';
  pT->pass_160_173_raw = '\x01';
  pT->repl_translated_C0 = p_out->enc == 3;
  if ((p_in->enc == 3) || (p_out->enc == 3)) {
    local_44 = '\x01';
  }
  else {
    local_44 = '\0';
  }
  pT->trans_C0_to_uni = local_44;
  return;
}



// WARNING: Unknown calling convention

void UCTransParams_clear(UCTransParams *pT)

{
  pT->transp = '\0';
  pT->do_cjk = '\0';
  pT->decode_utf8 = '\0';
  pT->output_utf8 = '\0';
  pT->do_8bitraw = '\0';
  pT->use_raw_char_in = '\0';
  pT->strip_raw_char_in = '\0';
  pT->pass_160_173_raw = '\0';
  pT->trans_to_uni = '\0';
  pT->trans_C0_to_uni = '\0';
  pT->repl_translated_C0 = '\0';
  pT->trans_from_uni = '\0';
  return;
}



// WARNING: Removing unreachable block (ram,0x080f85a7)
// WARNING: Removing unreachable block (ram,0x080f85ad)
// WARNING: Removing unreachable block (ram,0x080f85b4)
// WARNING: Removing unreachable block (ram,0x080f85ba)
// WARNING: Unknown calling convention

void UCSetBoxChars(int cset,int *pvert_out,int *phori_out,int vert_in,int hori_in)

{
  BOOLEAN fix_lines;
  
  *pvert_out = vert_in;
  *phori_out = hori_in;
  return;
}



// WARNING: Unknown calling convention

BOOLEAN UCPutUtf8_charstring(HTStream *target,putc_func_t *myPutc,long code)

{
  byte bVar1;
  byte bVar2;
  byte bVar3;
  byte bVar4;
  byte bVar5;
  BOOLEAN local_5;
  
  if (code < 0x80) {
    local_5 = '\0';
  }
  else {
    bVar1 = (byte)(code >> 6);
    bVar2 = (byte)code;
    if (code < 0x800) {
      (*myPutc)(target,bVar1 | 0xc0);
      (*myPutc)(target,bVar2 & 0x3f | 0x80);
    }
    else {
      bVar3 = (byte)(code >> 0xc);
      if (code < 0x10000) {
        (*myPutc)(target,bVar3 | 0xe0);
        (*myPutc)(target,bVar1 & 0x3f | 0x80);
        (*myPutc)(target,bVar2 & 0x3f | 0x80);
      }
      else {
        bVar4 = (byte)(code >> 0x12);
        if (code < 0x200000) {
          (*myPutc)(target,bVar4 | 0xf0);
          (*myPutc)(target,bVar3 & 0x3f | 0x80);
          (*myPutc)(target,bVar1 & 0x3f | 0x80);
          (*myPutc)(target,bVar2 & 0x3f | 0x80);
        }
        else {
          bVar5 = (byte)((uint)code >> 0x18);
          if (code < 0x4000000) {
            (*myPutc)(target,bVar5 | 0xf8);
            (*myPutc)(target,bVar4 & 0x3f | 0x80);
            (*myPutc)(target,bVar3 & 0x3f | 0x80);
            (*myPutc)(target,bVar1 & 0x3f | 0x80);
            (*myPutc)(target,bVar2 & 0x3f | 0x80);
          }
          else {
            (*myPutc)(target,(char)bVar5 >> 6 | 0xfc);
            (*myPutc)(target,bVar5 & 0x3f | 0x80);
            (*myPutc)(target,bVar4 & 0x3f | 0x80);
            (*myPutc)(target,bVar3 & 0x3f | 0x80);
            (*myPutc)(target,bVar1 & 0x3f | 0x80);
            (*myPutc)(target,bVar2 & 0x3f | 0x80);
          }
        }
      }
    }
    local_5 = '\x01';
  }
  return local_5;
}



// WARNING: Unknown calling convention

BOOLEAN UCConvertUniToUtf8(UCode_t code,char *buffer)

{
  byte bVar1;
  byte bVar2;
  byte bVar3;
  byte bVar4;
  byte bVar5;
  BOOLEAN local_15;
  char *ch;
  
  if (buffer == (char *)0x0) {
    local_15 = '\0';
  }
  else if (code < 1) {
    *buffer = '\0';
    local_15 = '\0';
  }
  else {
    bVar1 = (byte)(code >> 6);
    bVar5 = (byte)code;
    if (code < 0x800) {
      *buffer = bVar1 | 0xc0;
      buffer[1] = bVar5 & 0x3f | 0x80;
      buffer[2] = '\0';
    }
    else {
      bVar2 = (byte)(code >> 0xc);
      if (code < 0x10000) {
        *buffer = bVar2 | 0xe0;
        buffer[1] = bVar1 & 0x3f | 0x80;
        buffer[2] = bVar5 & 0x3f | 0x80;
        buffer[3] = '\0';
      }
      else {
        bVar3 = (byte)(code >> 0x12);
        if (code < 0x200000) {
          *buffer = bVar3 | 0xf0;
          buffer[1] = bVar2 & 0x3f | 0x80;
          buffer[2] = bVar1 & 0x3f | 0x80;
          buffer[3] = bVar5 & 0x3f | 0x80;
          buffer[4] = '\0';
        }
        else {
          bVar4 = (byte)((uint)code >> 0x18);
          if (code < 0x4000000) {
            *buffer = bVar4 | 0xf8;
            buffer[1] = bVar3 & 0x3f | 0x80;
            buffer[2] = bVar2 & 0x3f | 0x80;
            buffer[3] = bVar1 & 0x3f | 0x80;
            buffer[4] = bVar5 & 0x3f | 0x80;
            buffer[5] = '\0';
          }
          else {
            *buffer = (char)bVar4 >> 6 | 0xfc;
            buffer[1] = bVar4 & 0x3f | 0x80;
            buffer[2] = bVar3 & 0x3f | 0x80;
            buffer[3] = bVar2 & 0x3f | 0x80;
            buffer[4] = bVar1 & 0x3f | 0x80;
            buffer[5] = bVar5 & 0x3f | 0x80;
            buffer[6] = '\0';
          }
        }
      }
    }
    local_15 = '\x01';
  }
  return local_15;
}



// WARNING: Unknown calling convention

UCode_t UCGetUniFromUtf8String(char **ppuni)

{
  char *pcVar1;
  int local_18;
  int i;
  int utf_count;
  char *p;
  UCode_t uc_out;
  
  uc_out = 0;
  pcVar1 = *ppuni;
  if (**ppuni < '\0') {
    if ((**ppuni & 0x40U) == 0) {
      local_18 = -1;
    }
    else {
      if (((int)*pcVar1 & 0xe0U) == 0xc0) {
        utf_count = 1;
      }
      else if (((int)*pcVar1 & 0xf0U) == 0xe0) {
        utf_count = 2;
      }
      else if (((int)*pcVar1 & 0xf8U) == 0xf0) {
        utf_count = 3;
      }
      else if (((int)*pcVar1 & 0xfcU) == 0xf8) {
        utf_count = 4;
      }
      else {
        if (((int)*pcVar1 & 0xfeU) != 0xfc) {
          return -1;
        }
        utf_count = 5;
      }
      p = *ppuni;
      for (i = 0; i < utf_count; i = i + 1) {
        p = p + 1;
        if (((int)*p & 0xc0U) != 0x80) {
          return -1;
        }
      }
      pcVar1 = *ppuni;
      switch(utf_count) {
      case 1:
        uc_out = (int)pcVar1[1] & 0x3fU | ((int)*pcVar1 & 0x1fU) << 6;
        break;
      case 2:
        uc_out = (int)pcVar1[2] & 0x3fU | ((int)pcVar1[1] & 0x3fU | ((int)*pcVar1 & 0xfU) << 6) << 6
        ;
        break;
      case 3:
        uc_out = (int)pcVar1[3] & 0x3fU |
                 ((int)pcVar1[2] & 0x3fU | ((int)pcVar1[1] & 0x3fU | ((int)*pcVar1 & 7U) << 6) << 6)
                 << 6;
        break;
      case 4:
        uc_out = (int)pcVar1[4] & 0x3fU |
                 ((int)pcVar1[3] & 0x3fU |
                 ((int)pcVar1[2] & 0x3fU | ((int)pcVar1[1] & 0x3fU | ((int)*pcVar1 & 3U) << 6) << 6)
                 << 6) << 6;
        break;
      case 5:
        uc_out = (int)pcVar1[5] & 0x3fU |
                 ((int)pcVar1[4] & 0x3fU |
                 ((int)pcVar1[3] & 0x3fU |
                 ((int)pcVar1[2] & 0x3fU | ((int)pcVar1[1] & 0x3fU | ((int)*pcVar1 & 1U) << 6) << 6)
                 << 6) << 6) << 6;
      }
      *ppuni = pcVar1 + utf_count;
      local_18 = uc_out;
    }
  }
  else {
    local_18 = (int)**ppuni;
  }
  return local_18;
}



// WARNING: Unknown calling convention

void UCChangeTerminalCodepage(int newcs,LYUCcharset *p)

{
  FILE *__stream;
  
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"UCChangeTerminalCodepage: Called, but not implemented!");
  }
  return;
}



// WARNING: Unknown calling convention

void format(char **result,char *fmt,char *parm)

{
  *result = (char *)0x0;
  HTAddParam(result,fmt,1,parm);
  HTEndParam(result,fmt,1);
  return;
}



// WARNING: Unknown calling convention

char * format_command(char *command,char *param)

{
  char *cmdbuf;
  
  cmdbuf = (char *)0x0;
  format(&cmdbuf,command,param);
  return cmdbuf;
}



char * lookup_external(char *param,BOOLEAN only_overriders)

{
  int iVar1;
  char *pcVar2;
  wchar_t wVar3;
  FILE *pFVar4;
  int local_44;
  wchar_t local_40;
  BOOLEAN only_overriders_local;
  wchar_t old_x;
  wchar_t old_y;
  lynx_list_item_type *ptr;
  char **choices;
  char *cmdbuf;
  wchar_t length;
  wchar_t cur_choice;
  wchar_t num_choices;
  wchar_t num_matched;
  wchar_t num_disabled;
  wchar_t pass;
  
  length = L'\0';
  cmdbuf = (char *)0x0;
  choices = (char **)0x0;
  for (pass = L'\0'; pass < L'\x02'; pass = pass + L'\x01') {
    num_disabled = L'\0';
    num_matched = L'\0';
    num_choices = L'\0';
    for (ptr = externals; ptr != (lynx_list_item_type *)0x0; ptr = ptr->next) {
      iVar1 = match_item_by_name(ptr,param,only_overriders);
      if (iVar1 != 0) {
        num_matched = num_matched + L'\x01';
        if (WWW_TraceFlag != '\0') {
          pcVar2 = ptr->name;
          pFVar4 = TraceFP();
          fprintf((FILE *)pFVar4,"EXTERNAL: \'%s\' <==> \'%s\'\n",pcVar2,param);
        }
        if (((no_externals == '\0') || (ptr->always_enabled != L'\0')) || (only_overriders != '\0'))
        {
          if (pass == L'\0') {
            length = length + L'\x01';
          }
          else if ((pass != L'\0') &&
                  (cmdbuf = format_command(ptr->command,param), L'\x01' < length)) {
            choices[num_choices] = cmdbuf;
          }
          num_choices = num_choices + L'\x01';
        }
        else {
          num_disabled = num_disabled + L'\x01';
        }
      }
    }
    if (L'\x01' < length) {
      if (pass == L'\0') {
        choices = (char **)calloc(length + L'\x01',4);
      }
      else {
        choices[num_choices] = (char *)0x0;
      }
    }
  }
  if ((num_disabled == L'\0') || (num_disabled != num_matched)) {
    if (L'\x01' < num_choices) {
      if (LYwin == (WINDOW *)0x0) {
        local_44 = -1;
        local_40 = L'\xffffffff';
      }
      else {
        local_44 = (int)LYwin->_cury;
        local_40 = (wchar_t)LYwin->_curx;
      }
      wVar3 = LYhandlePopupList(L'\xffffffff',L'\0',local_40,choices,L'\xffffffff',L'\xffffffff',
                                L'\0','\x01');
      wmove(LYwin,local_44,local_40);
      if (WWW_TraceFlag != '\0') {
        pFVar4 = TraceFP();
        fprintf((FILE *)pFVar4,"selected choice %d of %d\n",wVar3,num_choices);
      }
      if (wVar3 < L'\0') {
        pcVar2 = (char *)gettext("Cancelled!!!");
        HTInfoMsg(pcVar2);
        cmdbuf = (char *)0x0;
      }
      for (pass = L'\0'; choices[pass] != (char *)0x0; pass = pass + L'\x01') {
        if (pass == wVar3) {
          cmdbuf = choices[pass];
        }
        else if (choices[pass] != (char *)0x0) {
          free(choices[pass]);
          choices[pass] = (char *)0x0;
        }
      }
      if (choices != (char **)0x0) {
        free(choices);
      }
    }
  }
  else {
    pcVar2 = (char *)gettext("External support is currently disabled.");
    HTUserMsg(pcVar2);
  }
  return cmdbuf;
}



BOOLEAN run_external(char *param,BOOLEAN only_overriders)

{
  char *Msg;
  BOOLEAN local_19;
  BOOLEAN only_overriders_local;
  wchar_t confirmed;
  char *cmdbuf;
  wchar_t redraw_flag;
  BOOLEAN found;
  
  found = '\0';
  if (externals == (lynx_list_item_type *)0x0) {
    local_19 = '\0';
  }
  else {
    Msg = lookup_external(param,only_overriders);
    if ((Msg != (char *)0x0) && (*Msg != '\0')) {
      HTUserMsg(Msg);
      found = '\x01';
      stop_curses();
      fflush(stdout);
      LYSystem(Msg);
      fflush(stdout);
      start_curses();
    }
    if (Msg != (char *)0x0) {
      free(Msg);
    }
    local_19 = found;
  }
  return local_19;
}



// WARNING: Unknown calling convention

BOOLEAN cannot_stat(char *name)

{
  char *fmt;
  char *tmpbuf;
  
  tmpbuf = (char *)0x0;
  fmt = (char *)gettext("Unable to get status of \'%s\'.");
  HTSprintf0(&tmpbuf,fmt,name);
  HTAlert(tmpbuf);
  if (tmpbuf != (char *)0x0) {
    free(tmpbuf);
  }
  return '\0';
}



// WARNING: Unknown calling convention

BOOLEAN ok_stat(char *name,stat *sb)

{
  FILE *__stream;
  int iVar1;
  BOOLEAN local_5;
  
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"testing ok_stat(%s)\n",name);
  }
  iVar1 = stat64(name,(stat64 *)sb);
  if (iVar1 == 0) {
    local_5 = '\x01';
  }
  else {
    local_5 = cannot_stat(name);
  }
  return local_5;
}



// WARNING: Unknown calling convention

BOOLEAN ok_lstat(char *name,stat *sb)

{
  FILE *__stream;
  int iVar1;
  BOOLEAN local_5;
  
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"testing ok_lstat(%s)\n",name);
  }
  iVar1 = lstat64(name,(stat64 *)sb);
  if (iVar1 < 0) {
    local_5 = cannot_stat(name);
  }
  else {
    local_5 = '\x01';
  }
  return local_5;
}



// WARNING: Unknown calling convention

BOOLEAN ok_file_or_dir(stat *sb)

{
  char *Msg;
  BOOLEAN local_5;
  
  if (((sb->st_mode & 0xf000) == 0x4000) || ((sb->st_mode & 0xf000) == 0x8000)) {
    local_5 = '\x01';
  }
  else {
    Msg = (char *)gettext("The selected item is not a file or a directory!  Request ignored.");
    HTAlert(Msg);
    local_5 = '\0';
  }
  return local_5;
}



// WARNING: Unknown calling convention

wchar_t LYExecv(char *path,char **argv,char *msg)

{
  FILE *pFVar1;
  int *piVar2;
  __pid_t _Var3;
  char *pcVar4;
  anon_union_4_2_13109f1b __u_3;
  anon_union_4_2_13109f1b __u_2;
  anon_union_4_2_13109f1b __u_1;
  anon_union_4_2_13109f1b __u;
  wchar_t wstatus;
  wchar_t pid;
  char *tmpbuf;
  wchar_t n;
  wchar_t rc;
  
  rc = L'\0';
  tmpbuf = (char *)0x0;
  if (WWW_TraceFlag != '\0') {
    if (WWW_TraceFlag != '\0') {
      pFVar1 = TraceFP();
      fprintf((FILE *)pFVar1,"LYExecv path=\'%s\'\n",path);
    }
    for (n = L'\0'; argv[n] != (char *)0x0; n = n + L'\x01') {
      if (WWW_TraceFlag != '\0') {
        pcVar4 = argv[n];
        pFVar1 = TraceFP();
        fprintf((FILE *)pFVar1,"argv[%d] = \'%s\'\n",n,pcVar4);
      }
    }
  }
  rc = L'\x01';
  stop_curses();
  pid = fork();
  if (pid == L'\xffffffff') {
    pcVar4 = (char *)gettext("Unable to %s due to system error!");
    HTSprintf0(&tmpbuf,pcVar4,msg);
    rc = L'\0';
  }
  else {
    if (pid == L'\0') {
      execv(path,argv);
      LYexit(1);
    }
    do {
      _Var3 = waitpid(pid,&wstatus,0);
      if (_Var3 != -1) break;
      piVar2 = __errno_location();
    } while (*piVar2 == 4);
    if ((((wstatus & 0x7fU) == 0) && ((wstatus & 0xff00U) >> 8 != 0)) ||
       (('\0' < (char)(((byte)wstatus & 0x7f) + 1) >> 1 && ((wstatus & 0x7fU) != 0)))) {
      pcVar4 = (char *)gettext("Probable failure to %s due to system error!");
      HTSprintf0(&tmpbuf,pcVar4,msg);
      rc = L'\0';
    }
  }
  if (rc == L'\0') {
    LYSleepAlert();
  }
  start_curses();
  if (tmpbuf != (char *)0x0) {
    if (rc == L'\0') {
      HTAlert(tmpbuf);
    }
    if (tmpbuf != (char *)0x0) {
      free(tmpbuf);
    }
  }
  return rc;
}



// WARNING: Unknown calling convention

wchar_t make_directory(char *path)

{
  wchar_t wVar1;
  int iVar2;
  wchar_t local_2c;
  wchar_t local_28;
  char *args [5];
  char *msg;
  char *program;
  wchar_t code;
  
  program = HTGetProgramPath(ppMKDIR);
  if (program == (char *)0x0) {
    iVar2 = mkdir(path,0x1ff);
    if (iVar2 == 0) {
      local_28 = L'\x01';
    }
    else {
      local_28 = L'\xffffffff';
    }
    code = local_28;
  }
  else {
    msg = (char *)0x0;
    HTSprintf0(&msg,"make directory %s",path);
    args[0] = "mkdir";
    args[1] = path;
    args[2] = (char *)0x0;
    wVar1 = LYExecv(program,args,msg);
    if (wVar1 < L'\x01') {
      local_2c = L'\xffffffff';
    }
    else {
      local_2c = L'\x01';
    }
    code = local_2c;
    if (msg != (char *)0x0) {
      free(msg);
    }
  }
  return code;
}



// WARNING: Unknown calling convention

wchar_t remove_file(char *path)

{
  char *fmt;
  int iVar1;
  wchar_t local_28;
  char *args [5];
  char *tmpbuf;
  char *program;
  wchar_t code;
  
  program = HTGetProgramPath(ppRM);
  if (program == (char *)0x0) {
    iVar1 = remove(path);
    if (iVar1 == 0) {
      local_28 = L'\x01';
    }
    else {
      local_28 = L'\xffffffff';
    }
    code = local_28;
  }
  else {
    tmpbuf = (char *)0x0;
    args[0] = "rm";
    args[1] = "-f";
    args[2] = path;
    args[3] = (char *)0x0;
    fmt = (char *)gettext("remove %s");
    HTSprintf0(&tmpbuf,fmt,path);
    code = LYExecv(program,args,tmpbuf);
    if (tmpbuf != (char *)0x0) {
      free(tmpbuf);
    }
  }
  return code;
}



// WARNING: Unknown calling convention

wchar_t remove_directory(char *path)

{
  char *fmt;
  int iVar1;
  wchar_t local_28;
  char *args [5];
  char *tmpbuf;
  char *program;
  wchar_t code;
  
  program = HTGetProgramPath(ppRMDIR);
  if (program == (char *)0x0) {
    iVar1 = rmdir(path);
    if (iVar1 == 0) {
      local_28 = L'\x01';
    }
    else {
      local_28 = L'\xffffffff';
    }
    code = local_28;
  }
  else {
    tmpbuf = (char *)0x0;
    args[0] = "rmdir";
    args[1] = path;
    args[2] = (char *)0x0;
    fmt = (char *)gettext("remove %s");
    HTSprintf0(&tmpbuf,fmt,path);
    code = LYExecv(program,args,tmpbuf);
    if (tmpbuf != (char *)0x0) {
      free(tmpbuf);
    }
  }
  return code;
}



// WARNING: Unknown calling convention

wchar_t touch_file(char *path)

{
  char *fmt;
  wchar_t wVar1;
  FILE *__stream;
  wchar_t local_38;
  char *args [5];
  FILE *fp;
  char *msg;
  char *program;
  wchar_t code;
  
  program = HTGetProgramPath(ppTOUCH);
  if (program == (char *)0x0) {
    __stream = fopen64(path,"w");
    if (__stream == (FILE *)0x0) {
      code = L'\xffffffff';
    }
    else {
      fclose(__stream);
      code = L'\x01';
    }
  }
  else {
    msg = (char *)0x0;
    fmt = (char *)gettext("touch %s");
    HTSprintf0(&msg,fmt,path);
    args[0] = "touch";
    args[1] = path;
    args[2] = (char *)0x0;
    wVar1 = LYExecv(program,args,msg);
    if (wVar1 < L'\x01') {
      local_38 = L'\xffffffff';
    }
    else {
      local_38 = L'\x01';
    }
    code = local_38;
    if (msg != (char *)0x0) {
      free(msg);
    }
  }
  return code;
}



// WARNING: Unknown calling convention

wchar_t move_file(char *source,char *target)

{
  char *pcVar1;
  wchar_t wVar2;
  int iVar3;
  FILE *__stream;
  wchar_t local_78;
  char *args [5];
  char *msg;
  char *program;
  wchar_t code;
  
  program = HTGetProgramPath(ppMV);
  if (program == (char *)0x0) {
    msg = (char *)0x0;
    iVar3 = stat64(target,(stat64 *)args);
    if ((iVar3 == 0) && (((uint)args[4] & 0xf000) == 0x4000)) {
      pcVar1 = LYPathLeaf(source);
      HTSprintf0(&msg,"%s/%s",target,pcVar1);
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"move_file source=%s, target=%s\n",source,target);
      }
      target = msg;
    }
    code = rename(source,target);
    if (code != L'\0') {
      code = LYCopyFile(source,target);
      if (L'\xffffffff' < code) {
        code = remove(source);
      }
    }
    if (code == L'\0') {
      code = L'\x01';
    }
    if ((msg != target) && (msg != (char *)0x0)) {
      free(msg);
    }
  }
  else {
    msg = (char *)0x0;
    pcVar1 = (char *)gettext("move %s to %s");
    HTSprintf0(&msg,pcVar1,source,target);
    args[0] = "mv";
    args[1] = source;
    args[2] = target;
    args[3] = (char *)0x0;
    wVar2 = LYExecv(program,args,msg);
    if (wVar2 < L'\x01') {
      local_78 = L'\xffffffff';
    }
    else {
      local_78 = L'\x01';
    }
    code = local_78;
    if (msg != (char *)0x0) {
      free(msg);
    }
  }
  return code;
}



// WARNING: Unknown calling convention

BOOLEAN not_already_exists(char *name)

{
  int iVar1;
  int *piVar2;
  char *pcVar3;
  stat dir_info;
  
  iVar1 = stat64(name,(stat64 *)&dir_info);
  if (iVar1 == 0) {
    if ((dir_info.st_mode & 0xf000) == 0x4000) {
      pcVar3 = (char *)gettext("There is already a directory with that name!  Request ignored.");
      HTAlert(pcVar3);
    }
    else if ((dir_info.st_mode & 0xf000) == 0x8000) {
      pcVar3 = (char *)gettext("There is already a file with that name!  Request ignored.");
      HTAlert(pcVar3);
    }
    else {
      pcVar3 = (char *)gettext("The specified name is already in use!  Request ignored.");
      HTAlert(pcVar3);
    }
  }
  else {
    piVar2 = __errno_location();
    if (*piVar2 == 2) {
      return '\x01';
    }
    cannot_stat(name);
  }
  return '\0';
}



// WARNING: Unknown calling convention

BOOLEAN dir_has_same_owner(stat *info,wchar_t owner)

{
  char *pcVar1;
  
  if ((info->st_mode & 0xf000) == 0x4000) {
    if (info->st_uid == owner) {
      return '\x01';
    }
    pcVar1 = (char *)gettext("Destination has different owner!  Request denied.");
    HTAlert(pcVar1);
  }
  else {
    pcVar1 = (char *)gettext("Destination is not a valid directory!  Request denied.");
    HTAlert(pcVar1);
  }
  return '\0';
}



// WARNING: Removing unreachable block (ram,0x080f9d29)
// WARNING: Unknown calling convention

wchar_t remove_tagged(void)

{
  bool bVar1;
  BOOLEAN BVar2;
  BOOLEAN BVar3;
  char *Msg;
  UrlTypes UVar4;
  wchar_t wVar5;
  wchar_t local_8c;
  char *local_88;
  stat dir_info;
  HTList *tag;
  wchar_t count;
  char *testpath;
  char *tmpbuf;
  char *cp;
  wchar_t ans;
  BOOLEAN will_clear;
  
  testpath = (char *)0x0;
  if ((tagged == (HTList *)0x0) || (tagged->next == (HTList *)0x0)) {
    local_8c = L'\0';
  }
  else {
    Msg = (char *)gettext("Remove all tagged files and directories?");
    BVar2 = HTConfirm(Msg);
    count = L'\0';
    tag = tagged;
    while (bVar1 = true, BVar2 == '\x01') {
      if ((tag == (HTList *)0x0) || (tag = tag->next, tag == (HTList *)0x0)) {
        local_88 = (char *)0x0;
      }
      else {
        local_88 = (char *)tag->object;
      }
      if (local_88 == (char *)0x0) break;
      UVar4 = is_url(local_88);
      if (UVar4 == FILE_URL_TYPE) {
        testpath = HTnameOfFile_WWW(local_88,'\0','\x01');
        LYTrimPathSep(testpath);
        BVar3 = ok_stat(testpath,&dir_info);
        if (BVar3 == '\0') {
          bVar1 = false;
          break;
        }
        wVar5 = remove_file(testpath);
        if (wVar5 < L'\x01') {
          if (count == L'\0') {
            count = L'\xffffffff';
          }
          bVar1 = false;
          break;
        }
        count = count + L'\x01';
        if (testpath != (char *)0x0) {
          free(testpath);
          testpath = (char *)0x0;
        }
      }
    }
    if (testpath != (char *)0x0) {
      free(testpath);
    }
    if (bVar1) {
      clear_tags();
    }
    local_8c = count;
  }
  return local_8c;
}



wchar_t modify_tagged(char *testpath)

{
  int iVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  BOOLEAN BVar6;
  char *pcVar7;
  int iVar8;
  size_t sVar9;
  wchar_t wVar10;
  int in_GS_OFFSET;
  wchar_t local_4a4;
  char *local_4a0;
  char *local_49c;
  char *testpath_local;
  stat dir_info;
  ino_t inode;
  dev_t dev;
  char *cp1;
  HTList *tag;
  wchar_t count;
  char *srcpath;
  char *savepath;
  wchar_t owner;
  char *cp;
  char tmpbuf [1024];
  
  testpath_local = testpath;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  srcpath = (char *)0x0;
  count = L'\0';
  if ((tagged == (HTList *)0x0) || (tagged->next == (HTList *)0x0)) {
    local_4a4 = L'\0';
    goto LAB_080fa410;
  }
  mustshow = '\x01';
  pcVar7 = (char *)gettext("Enter new location for tagged items: ");
  statusline(pcVar7);
  tmpbuf[0] = '\0';
  LYgetstr(tmpbuf,L'\0',0x400,NORECALL);
  if (tmpbuf[0] == '\0') {
    local_4a4 = L'\0';
    goto LAB_080fa410;
  }
  if ((testpath == (char *)0x0) || (*testpath == '\0')) {
LAB_080f9e43:
    if ((tagged == (HTList *)0x0) || (tagged->next == (HTList *)0x0)) {
      local_4a0 = (char *)0x0;
    }
    else {
      local_4a0 = (char *)tagged->next->object;
    }
    cp = local_4a0;
    testpath_local = (char *)0x0;
  }
  else {
    iVar8 = strcmp(testpath,"/");
    if (iVar8 == 0) goto LAB_080f9e43;
    cp = testpath;
  }
  if (testpath_local == (char *)0x0) {
    if (cp == (char *)0x0) {
      savepath = HTURLPath_toFile(".",'\x01','\0');
    }
    else {
      cp = strip_trailing_slash(cp);
      cp = HTParse(".",cp,5);
      savepath = HTURLPath_toFile(cp,'\x01','\0');
      if (cp != (char *)0x0) {
        free(cp);
        cp = (char *)0x0;
      }
    }
  }
  else {
    iVar8 = strncmp(cp,"file://localhost",0x10);
    if (iVar8 == 0) {
      cp = cp + 0x10;
    }
    else if ((*cp == 'f') || (*cp == 'F')) {
      iVar8 = strncasecomp(cp,"file:",5);
      if (iVar8 == 0) {
        cp = cp + 5;
      }
    }
    savepath = HTURLPath_toFile(cp,'\x01','\0');
  }
  BVar6 = ok_stat(savepath,&dir_info);
  uVar5 = dir_info.st_ino._4_4_;
  uVar4 = (uint)dir_info.st_ino;
  uVar3 = dir_info.st_dev._4_4_;
  uVar2 = (uint)dir_info.st_dev;
  if (BVar6 == '\0') {
    if (savepath != (char *)0x0) {
      free(savepath);
      savepath = (char *)0x0;
    }
    local_4a4 = L'\0';
  }
  else {
    owner = dir_info.st_uid;
    if ((tmpbuf[0] == '~') && (tmpbuf[1] == '/')) {
      cp1 = (char *)0x0;
      pcVar7 = Home_Dir();
      HTSACopy(&cp1,pcVar7);
      HTSACat(&cp1,tmpbuf + 1);
      sVar9 = strlen(cp1);
      if (0x3ff < sVar9) {
        pcVar7 = (char *)gettext("Path too long");
        HTAlert(pcVar7);
        if (savepath != (char *)0x0) {
          free(savepath);
          savepath = (char *)0x0;
        }
        if (cp1 != (char *)0x0) {
          free(cp1);
          cp1 = (char *)0x0;
        }
        local_4a4 = L'\0';
        goto LAB_080fa410;
      }
      LYstrncpy(tmpbuf,cp1,L'');
      if (cp1 != (char *)0x0) {
        free(cp1);
        cp1 = (char *)0x0;
      }
    }
    if (tmpbuf[0] == '/') {
      HTSACopy(&savepath,tmpbuf);
    }
    else {
      LYAddPathSep(&savepath);
      HTSACat(&savepath,tmpbuf);
    }
    BVar6 = ok_stat(savepath,&dir_info);
    if (BVar6 == '\0') {
      if (savepath != (char *)0x0) {
        free(savepath);
        savepath = (char *)0x0;
      }
      local_4a4 = L'\0';
    }
    else if ((((uint)dir_info.st_dev ^ uVar2 | dir_info.st_dev._4_4_ ^ uVar3) == 0) &&
            (((uint)dir_info.st_ino ^ uVar4 | dir_info.st_ino._4_4_ ^ uVar5) == 0)) {
      pcVar7 = (char *)gettext("Source and destination are the same location - request ignored!");
      HTAlert(pcVar7);
      if (savepath != (char *)0x0) {
        free(savepath);
        savepath = (char *)0x0;
      }
      local_4a4 = L'\0';
    }
    else {
      BVar6 = dir_has_same_owner(&dir_info,owner);
      if (BVar6 != '\0') {
        count = L'\0';
        tag = tagged;
        while( true ) {
          if ((tag == (HTList *)0x0) || (tag = tag->next, tag == (HTList *)0x0)) {
            local_49c = (char *)0x0;
          }
          else {
            local_49c = (char *)tag->object;
          }
          cp = local_49c;
          if (local_49c == (char *)0x0) goto LAB_080fa3b0;
          srcpath = HTnameOfFile_WWW(local_49c,'\0','\x01');
          wVar10 = move_file(srcpath,savepath);
          if (wVar10 < L'\0') break;
          if (srcpath != (char *)0x0) {
            free(srcpath);
            srcpath = (char *)0x0;
          }
          count = count + L'\x01';
        }
        if (count == L'\0') {
          count = L'\xffffffff';
        }
LAB_080fa3b0:
        clear_tags();
        if (srcpath != (char *)0x0) {
          free(srcpath);
          srcpath = (char *)0x0;
        }
      }
      if (savepath != (char *)0x0) {
        free(savepath);
        savepath = (char *)0x0;
      }
      local_4a4 = count;
    }
  }
LAB_080fa410:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return local_4a4;
}



wchar_t modify_name(char *testpath)

{
  int iVar1;
  BOOLEAN BVar2;
  char *pcVar3;
  char *pcVar4;
  int in_GS_OFFSET;
  wchar_t local_27c;
  char *testpath_local;
  stat dir_info;
  wchar_t code;
  char *newpath;
  char *cp;
  char tmpbuf [512];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  newpath = (char *)0x0;
  code = L'\0';
  pcVar3 = strip_trailing_slash(testpath);
  BVar2 = ok_stat(pcVar3,&dir_info);
  if (BVar2 != '\0') {
    if ((dir_info.st_mode & 0xf000) == 0x4000) {
      cp = (char *)gettext("Enter new name for directory: ");
    }
    else {
      if ((dir_info.st_mode & 0xf000) != 0x8000) {
        BVar2 = ok_file_or_dir(&dir_info);
        local_27c = (wchar_t)BVar2;
        goto LAB_080fa665;
      }
      cp = (char *)gettext("Enter new name for file: ");
    }
    pcVar4 = LYPathLeaf(pcVar3);
    LYstrncpy(tmpbuf,pcVar4,L'');
    pcVar4 = get_filename(cp,tmpbuf,0x200);
    if (pcVar4 == (char *)0x0) {
      local_27c = L'\0';
      goto LAB_080fa665;
    }
    pcVar4 = LYLastPathSep(tmpbuf);
    if (pcVar4 == (char *)0x0) {
      if (tmpbuf[0] != '\0') {
        cp = LYLastPathSep(pcVar3);
        if (cp == (char *)0x0) {
          HTSACopy(&newpath,tmpbuf);
        }
        else {
          HTSprintf0(&newpath,"%.*s%s",cp + (1 - (int)pcVar3),pcVar3,tmpbuf);
        }
        BVar2 = not_already_exists(newpath);
        if (BVar2 != '\0') {
          code = move_file(pcVar3,newpath);
        }
        if (newpath != (char *)0x0) {
          free(newpath);
          newpath = (char *)0x0;
        }
      }
    }
    else {
      pcVar3 = (char *)gettext("Illegal character (path-separator) found! Request ignored.");
      HTAlert(pcVar3);
    }
  }
  local_27c = code;
LAB_080fa665:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return local_27c;
}



wchar_t modify_location(char *testpath)

{
  int iVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  BOOLEAN BVar6;
  char *pcVar7;
  char *pcVar8;
  int in_GS_OFFSET;
  wchar_t local_49c;
  char *testpath_local;
  stat dir_info;
  ino_t inode;
  dev_t dev;
  wchar_t code;
  char *savepath;
  char *newpath;
  wchar_t owner;
  char *sp;
  char *cp;
  char tmpbuf [1024];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  newpath = (char *)0x0;
  savepath = (char *)0x0;
  code = L'\0';
  pcVar7 = strip_trailing_slash(testpath);
  BVar6 = ok_stat(pcVar7,&dir_info);
  if (BVar6 == '\0') {
    local_49c = L'\0';
  }
  else {
    if ((dir_info.st_mode & 0xf000) == 0x4000) {
      pcVar8 = HTGetProgramPath(ppMV);
      if (pcVar8 == (char *)0x0) {
        pcVar7 = (char *)gettext("Could not access directory.");
        HTAlert(pcVar7);
        local_49c = L'\0';
        goto LAB_080faad9;
      }
      cp = (char *)gettext("Enter new location for directory: ");
    }
    else {
      if ((dir_info.st_mode & 0xf000) != 0x8000) {
        BVar6 = ok_file_or_dir(&dir_info);
        local_49c = (wchar_t)BVar6;
        goto LAB_080faad9;
      }
      cp = (char *)gettext("Enter new location for file: ");
    }
    LYstrncpy(tmpbuf,pcVar7,L'');
    pcVar8 = LYPathLeaf(tmpbuf);
    *pcVar8 = '\0';
    pcVar8 = get_filename(cp,tmpbuf,0x400);
    if (pcVar8 == (char *)0x0) {
      local_49c = L'\0';
    }
    else {
      if (tmpbuf[0] != '\0') {
        HTSACopy(&savepath,pcVar7);
        HTSACopy(&newpath,pcVar7);
        if ((tmpbuf[0] == '~') && ((tmpbuf[1] == '\0' || (tmpbuf[1] == '/')))) {
          pcVar7 = Home_Dir();
          HTSACopy(&newpath,pcVar7);
          HTSACat(&newpath,tmpbuf + 1);
          LYstrncpy(tmpbuf,newpath,L'');
        }
        BVar6 = LYisAbsPath(tmpbuf);
        if (BVar6 == '\0') {
          sp = LYLastPathSep(newpath);
          if (sp == (char *)0x0) {
            pcVar7 = (char *)gettext("Unexpected failure - unable to find trailing path separator");
            HTAlert(pcVar7);
            if (newpath != (char *)0x0) {
              free(newpath);
              newpath = (char *)0x0;
            }
            if (savepath != (char *)0x0) {
              free(savepath);
              savepath = (char *)0x0;
            }
            local_49c = L'\0';
            goto LAB_080faad9;
          }
          sp = sp + 1;
          *sp = '\0';
          HTSACat(&newpath,tmpbuf);
        }
        else {
          HTSACopy(&newpath,tmpbuf);
        }
        uVar5 = dir_info.st_ino._4_4_;
        uVar4 = (uint)dir_info.st_ino;
        uVar3 = dir_info.st_dev._4_4_;
        uVar2 = (uint)dir_info.st_dev;
        owner = dir_info.st_uid;
        BVar6 = ok_stat(newpath,&dir_info);
        if (BVar6 == '\0') {
          code = L'\0';
        }
        else if ((((uint)dir_info.st_dev ^ uVar2 | dir_info.st_dev._4_4_ ^ uVar3) == 0) &&
                (((uint)dir_info.st_ino ^ uVar4 | dir_info.st_ino._4_4_ ^ uVar5) == 0)) {
          pcVar7 = (char *)gettext("Source and destination are the same location!  Request ignored!"
                                  );
          HTAlert(pcVar7);
          code = L'\0';
        }
        else {
          BVar6 = dir_has_same_owner(&dir_info,owner);
          if (BVar6 != '\0') {
            code = move_file(savepath,newpath);
          }
        }
        if (newpath != (char *)0x0) {
          free(newpath);
          newpath = (char *)0x0;
        }
        if (savepath != (char *)0x0) {
          free(savepath);
          savepath = (char *)0x0;
        }
      }
      local_49c = code;
    }
  }
LAB_080faad9:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return local_49c;
}



wchar_t local_modify(DocInfo *doc,char **newpath)

{
  int iVar1;
  char *pcVar2;
  wchar_t wVar3;
  size_t sVar4;
  int in_GS_OFFSET;
  wchar_t local_220;
  char **newpath_local;
  DocInfo *doc_local;
  wchar_t count;
  char *cp;
  wchar_t ans;
  char testpath [512];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if ((tagged == (HTList *)0x0) || (tagged->next == (HTList *)0x0)) {
    if ((doc->link < L'\0') || (nlinks < doc->link)) {
      local_220 = L'\0';
    }
    else {
      mustshow = '\x01';
      pcVar2 = (char *)gettext("Modify name, location, or permission (n, l, or p): ");
      statusline(pcVar2);
      wVar3 = LYgetch_single();
      pcVar2 = strchr("NLP",wVar3);
      if (pcVar2 != (char *)0x0) {
        pcVar2 = HTnameOfFile_WWW(links[doc->link].lname,'\0','\x01');
        sVar4 = strlen(pcVar2);
        if (0x1ff < sVar4) {
          if (pcVar2 != (char *)0x0) {
            free(pcVar2);
          }
          local_220 = L'\0';
          goto LAB_080fade0;
        }
        LYstrncpy(testpath,pcVar2,L'');
        if (pcVar2 != (char *)0x0) {
          free(pcVar2);
        }
        if (wVar3 == L'N') {
          local_220 = modify_name(testpath);
          goto LAB_080fade0;
        }
        if (wVar3 == L'L') {
          wVar3 = modify_location(testpath);
          if (wVar3 != L'\0') {
            if (doc->link == nlinks + L'\xffffffff') {
              doc->link = doc->link + L'\xffffffff';
            }
            local_220 = L'\x01';
            goto LAB_080fade0;
          }
        }
        else {
          if (wVar3 == L'P') {
            local_220 = permit_location((char *)0x0,testpath,newpath);
            goto LAB_080fade0;
          }
          pcVar2 = (char *)gettext("This feature not yet implemented!");
          HTAlert(pcVar2);
        }
      }
      local_220 = L'\0';
    }
  }
  else {
    pcVar2 = HTnameOfFile_WWW(doc->address,'\0','\0');
    local_220 = modify_tagged(pcVar2);
    if (pcVar2 != (char *)0x0) {
      free(pcVar2);
    }
    if ((nlinks - local_220) + L'\xffffffff' < doc->link) {
      doc->link = (nlinks - local_220) + L'\xffffffff';
    }
    doc->link = doc->link & ~(doc->link >> 0x1f);
  }
LAB_080fade0:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return local_220;
}



wchar_t create_file(char *current_location)

{
  int iVar1;
  BOOLEAN BVar2;
  char *pcVar3;
  int in_GS_OFFSET;
  char *local_21c;
  char *current_location_local;
  char *testpath;
  wchar_t code;
  char tmpbuf [512];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  code = L'\0';
  testpath = (char *)0x0;
  tmpbuf[0] = '\0';
  pcVar3 = (char *)gettext("Enter name of file to create: ");
  pcVar3 = get_filename(pcVar3,tmpbuf,0x200);
  if (pcVar3 != (char *)0x0) {
    pcVar3 = strstr(tmpbuf,"//");
    if (pcVar3 == (char *)0x0) {
      if (tmpbuf[0] != '\0') {
        if ((no_dotfiles == '\0') && (show_dotfiles != '\0')) {
          local_21c = "~/";
        }
        else {
          local_21c = ".~/";
        }
        pcVar3 = strchr(local_21c,(int)tmpbuf[0]);
        if (pcVar3 == (char *)0x0) {
          HTSACopy(&testpath,current_location);
          LYAddPathSep(&testpath);
          HTSACat(&testpath,tmpbuf);
          BVar2 = not_already_exists(testpath);
          if (BVar2 != '\0') {
            code = touch_file(testpath);
          }
          if (testpath != (char *)0x0) {
            free(testpath);
            testpath = (char *)0x0;
          }
        }
      }
    }
    else {
      pcVar3 = (char *)gettext("Illegal redirection \"//\" found! Request ignored.");
      HTAlert(pcVar3);
    }
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return code;
}



wchar_t create_directory(char *current_location)

{
  int iVar1;
  BOOLEAN BVar2;
  char *pcVar3;
  int in_GS_OFFSET;
  char *local_21c;
  char *current_location_local;
  char *testpath;
  wchar_t code;
  char tmpbuf [512];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  code = L'\0';
  testpath = (char *)0x0;
  tmpbuf[0] = '\0';
  pcVar3 = (char *)gettext("Enter name for new directory: ");
  pcVar3 = get_filename(pcVar3,tmpbuf,0x200);
  if (pcVar3 != (char *)0x0) {
    pcVar3 = strstr(tmpbuf,"//");
    if (pcVar3 == (char *)0x0) {
      if (tmpbuf[0] != '\0') {
        if ((no_dotfiles == '\0') && (show_dotfiles != '\0')) {
          local_21c = "~/";
        }
        else {
          local_21c = ".~/";
        }
        pcVar3 = strchr(local_21c,(int)tmpbuf[0]);
        if (pcVar3 == (char *)0x0) {
          HTSACopy(&testpath,current_location);
          LYAddPathSep(&testpath);
          HTSACat(&testpath,tmpbuf);
          BVar2 = not_already_exists(testpath);
          if (BVar2 != '\0') {
            code = make_directory(testpath);
          }
          if (testpath != (char *)0x0) {
            free(testpath);
            testpath = (char *)0x0;
          }
        }
      }
    }
    else {
      pcVar3 = (char *)gettext("Illegal redirection \"//\" found! Request ignored.");
      HTAlert(pcVar3);
    }
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return code;
}



wchar_t local_create(DocInfo *doc)

{
  int iVar1;
  char *pcVar2;
  size_t sVar3;
  wchar_t wVar4;
  int in_GS_OFFSET;
  wchar_t local_21c;
  DocInfo *doc_local;
  char *cp;
  wchar_t ans;
  char testpath [512];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  pcVar2 = HTnameOfFile_WWW(doc->address,'\0','\x01');
  sVar3 = strlen(pcVar2);
  if (sVar3 < 0x200) {
    strcpy(testpath,pcVar2);
    if (pcVar2 != (char *)0x0) {
      free(pcVar2);
    }
    mustshow = '\x01';
    pcVar2 = (char *)gettext("Create file or directory (f or d): ");
    statusline(pcVar2);
    wVar4 = LYgetch_single();
    if (wVar4 == L'F') {
      local_21c = create_file(testpath);
    }
    else if (wVar4 == L'D') {
      local_21c = create_directory(testpath);
    }
    else {
      local_21c = L'\0';
    }
  }
  else {
    if (pcVar2 != (char *)0x0) {
      free(pcVar2);
    }
    local_21c = L'\0';
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return local_21c;
}



// WARNING: Unknown calling convention

wchar_t remove_single(char *testpath)

{
  BOOLEAN BVar1;
  char *pcVar2;
  size_t sVar3;
  wchar_t local_7c;
  wchar_t local_78;
  stat dir_info;
  char *tmpbuf;
  char *cp;
  wchar_t code;
  BOOLEAN is_directory;
  
  code = L'\0';
  tmpbuf = (char *)0x0;
  is_directory = '\0';
  BVar1 = ok_lstat(testpath,&dir_info);
  if (BVar1 == '\0') {
    local_7c = L'\0';
  }
  else {
    pcVar2 = LYLastPathSep(testpath);
    if (pcVar2 == (char *)0x0) {
      cp = testpath;
    }
    else {
      cp = pcVar2 + 1;
    }
    if ((dir_info.st_mode & 0xf000) == 0x4000) {
      sVar3 = strlen(cp);
      if (sVar3 < 0x25) {
        pcVar2 = (char *)gettext("Remove directory \'%s\'?");
        HTSprintf0(&tmpbuf,pcVar2,cp);
      }
      else {
        pcVar2 = (char *)gettext("Remove directory?");
        HTSprintf0(&tmpbuf,pcVar2);
      }
      is_directory = '\x01';
    }
    else if ((dir_info.st_mode & 0xf000) == 0x8000) {
      sVar3 = strlen(cp);
      if (sVar3 < 0x3c) {
        pcVar2 = (char *)gettext("Remove file \'%s\'?");
        HTSprintf0(&tmpbuf,pcVar2,cp);
      }
      else {
        pcVar2 = (char *)gettext("Remove file?");
        HTSprintf0(&tmpbuf,pcVar2);
      }
    }
    else {
      if ((dir_info.st_mode & 0xf000) != 0xa000) {
        cannot_stat(testpath);
        if (tmpbuf != (char *)0x0) {
          free(tmpbuf);
        }
        return L'\0';
      }
      sVar3 = strlen(cp);
      if (sVar3 < 0x32) {
        pcVar2 = (char *)gettext("Remove symbolic link \'%s\'?");
        HTSprintf0(&tmpbuf,pcVar2,cp);
      }
      else {
        pcVar2 = (char *)gettext("Remove symbolic link?");
        HTSprintf0(&tmpbuf,pcVar2);
      }
    }
    BVar1 = HTConfirm(tmpbuf);
    if (BVar1 == '\x01') {
      if (is_directory == '\0') {
        local_78 = remove_file(testpath);
      }
      else {
        local_78 = remove_directory(testpath);
      }
      code = local_78;
    }
    if (tmpbuf != (char *)0x0) {
      free(tmpbuf);
    }
    local_7c = code;
  }
  return local_7c;
}



wchar_t local_remove(DocInfo *doc)

{
  int iVar1;
  UrlTypes UVar2;
  char *__s;
  size_t sVar3;
  wchar_t wVar4;
  int in_GS_OFFSET;
  wchar_t local_22c;
  DocInfo *doc_local;
  wchar_t i;
  wchar_t count;
  char *tp;
  char *cp;
  char testpath [512];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if ((tagged == (HTList *)0x0) || (tagged->next == (HTList *)0x0)) {
    if ((doc->link < L'\0') || (nlinks < doc->link)) {
      local_22c = L'\0';
    }
    else {
      cp = links[doc->link].lname;
      UVar2 = is_url(cp);
      if (UVar2 == FILE_URL_TYPE) {
        __s = HTnameOfFile_WWW(cp,'\0','\x01');
        sVar3 = strlen(__s);
        if (0x1ff < sVar3) {
          if (__s != (char *)0x0) {
            free(__s);
          }
          local_22c = L'\0';
          goto LAB_080fb6da;
        }
        strcpy(testpath,__s);
        if (__s != (char *)0x0) {
          free(__s);
        }
        sVar3 = strlen(testpath);
        if ((sVar3 != 0) && (testpath[sVar3 - 1] == '/')) {
          testpath[sVar3 - 1] = '\0';
        }
        wVar4 = remove_single(testpath);
        if (wVar4 != L'\0') {
          if (doc->link == nlinks + L'\xffffffff') {
            doc->link = doc->link + L'\xffffffff';
          }
          local_22c = L'\x01';
          goto LAB_080fb6da;
        }
      }
      local_22c = L'\0';
    }
  }
  else {
    local_22c = remove_tagged();
    if ((nlinks - local_22c) + L'\xffffffff' < doc->link) {
      doc->link = (nlinks - local_22c) + L'\xffffffff';
    }
    doc->link = doc->link & ~(doc->link >> 0x1f);
  }
LAB_080fb6da:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return local_22c;
}



// WARNING: Unknown calling convention

long permit_bits(char *string_mode)

{
  int iVar1;
  long local_8;
  
  iVar1 = strcmp(string_mode,"IRUSR");
  if (iVar1 == 0) {
    local_8 = 0x100;
  }
  else {
    iVar1 = strcmp(string_mode,"IWUSR");
    if (iVar1 == 0) {
      local_8 = 0x80;
    }
    else {
      iVar1 = strcmp(string_mode,"IXUSR");
      if (iVar1 == 0) {
        local_8 = 0x40;
      }
      else {
        iVar1 = strcmp(string_mode,"IRGRP");
        if (iVar1 == 0) {
          local_8 = 0x20;
        }
        else {
          iVar1 = strcmp(string_mode,"IWGRP");
          if (iVar1 == 0) {
            local_8 = 0x10;
          }
          else {
            iVar1 = strcmp(string_mode,"IXGRP");
            if (iVar1 == 0) {
              local_8 = 8;
            }
            else {
              iVar1 = strcmp(string_mode,"IROTH");
              if (iVar1 == 0) {
                local_8 = 4;
              }
              else {
                iVar1 = strcmp(string_mode,"IWOTH");
                if (iVar1 == 0) {
                  local_8 = 2;
                }
                else {
                  iVar1 = strcmp(string_mode,"IXOTH");
                  if (iVar1 == 0) {
                    local_8 = 1;
                  }
                  else {
                    local_8 = 0;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return local_8;
}



wchar_t permit_location(char *destpath,char *srcpath,char **newpath)

{
  int iVar1;
  BOOLEAN BVar2;
  char *pcVar3;
  undefined4 uVar4;
  FILE *pFVar5;
  size_t sVar6;
  int iVar7;
  char *pcVar8;
  wchar_t wVar9;
  int in_GS_OFFSET;
  wchar_t local_1fc;
  char *local_1f8;
  char *local_1f4;
  char *local_1f0;
  char *local_1ec;
  char *local_1e8;
  char *local_1e4;
  char *local_1e0;
  char *local_1dc;
  char *local_1d8;
  char *local_1d4;
  char *local_1d0;
  char *local_1cc;
  char *local_1c8;
  char *local_1c4;
  char **newpath_local;
  char *srcpath_local;
  char *destpath_local;
  stat dir_info;
  char *args [5];
  char *tmpbuf;
  long mask;
  char *cr;
  mode_t new_mode;
  char *srcpath_url;
  char *group_name;
  char *user_filename;
  FILE *fp0;
  char *program;
  char *cp;
  char tmpdst [256];
  char amode [10];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if (srcpath == (char *)0x0) {
    new_mode = 0;
    if (LYValidPermitFile[0] == '\0') {
      if (LYCursesON == '\0') {
        uVar4 = gettext("Special URL only valid from current File Permission menu!");
        fprintf(stderr,"%s\n",uVar4);
      }
      else {
        pcVar3 = (char *)gettext("Special URL only valid from current File Permission menu!");
        HTAlert(pcVar3);
      }
      if (WWW_TraceFlag != '\0') {
        if (destpath == (char *)0x0) {
          local_1c4 = "NULL URL pointer";
        }
        else {
          local_1c4 = destpath;
        }
        pFVar5 = TraceFP();
        fprintf((FILE *)pFVar5,"permit_location: called for <%s>.\n",local_1c4);
      }
      local_1fc = L'\0';
    }
    else {
      for (cp = destpath; (*cp != '\0' && (*cp != '?')); cp = cp + 1) {
      }
      if (*cp == '\0') {
        local_1fc = L'\0';
      }
      else {
        *cp = '\0';
        cp = cp + 1;
        pcVar3 = HTURLPath_toFile(destpath,'\x01','\0');
        if (pcVar3 == (char *)0x0) {
          local_1fc = L'\0';
        }
        else {
          sVar6 = strlen(pcVar3);
          if (sVar6 < 0x100) {
            strcpy(tmpdst,pcVar3);
            if (pcVar3 != (char *)0x0) {
              free(pcVar3);
            }
            iVar7 = strcmp(tmpdst,LYValidPermitFile);
            if (iVar7 == 0) {
              pcVar3 = strip_trailing_slash(tmpdst);
              BVar2 = ok_stat(pcVar3,&dir_info);
              if (BVar2 != '\0') {
                BVar2 = ok_file_or_dir(&dir_info);
                if (BVar2 != '\0') {
                  while (*cp != '\0') {
                    for (cr = cp; (*cr != '\0' && (*cr != '&')); cr = cr + 1) {
                    }
                    if (*cr != '\0') {
                      *cr = '\0';
                      cr = cr + 1;
                    }
                    iVar7 = strncmp(cp,"mode=",5);
                    if (iVar7 != 0) {
                      pcVar3 = (char *)gettext("Invalid syntax format.");
                      HTAlert(pcVar3);
                      local_1fc = L'\0';
                      goto LAB_080fc443;
                    }
                    mask = permit_bits(cp + 5);
                    if (mask == 0) {
                      pcVar3 = (char *)gettext("Invalid mode format.");
                      HTAlert(pcVar3);
                      local_1fc = L'\0';
                      goto LAB_080fc443;
                    }
                    if (no_change_exec_perms == '\0') {
LAB_080fc288:
                      new_mode = new_mode | mask;
                    }
                    else {
                      pcVar8 = strchr(cp + 5,0x58);
                      if ((pcVar8 == (char *)0x0) || ((dir_info.st_mode & 0xf000) == 0x4000))
                      goto LAB_080fc288;
                    }
                    cp = cr;
                  }
                  program = HTGetProgramPath(ppCHMOD);
                  if (program == (char *)0x0) {
                    iVar7 = chmod(pcVar3,new_mode);
                    if (iVar7 < 0) {
                      local_1fc = L'\xffffffff';
                      goto LAB_080fc443;
                    }
                  }
                  else {
                    tmpbuf = (char *)0x0;
                    HTSprintf0(&tmpbuf,"chmod %.4o %s",new_mode,pcVar3);
                    sprintf(amode,"%.4o",new_mode);
                    args[0] = "chmod";
                    args[1] = amode;
                    args[3] = (char *)0x0;
                    args[2] = pcVar3;
                    wVar9 = LYExecv(program,args,tmpbuf);
                    if (wVar9 < L'\x01') {
                      if (tmpbuf != (char *)0x0) {
                        free(tmpbuf);
                        tmpbuf = (char *)0x0;
                      }
                      local_1fc = L'\xffffffff';
                      goto LAB_080fc443;
                    }
                    if (tmpbuf != (char *)0x0) {
                      free(tmpbuf);
                      tmpbuf = (char *)0x0;
                    }
                  }
                  LYforce_no_cache = '\x01';
                  local_1fc = L'\x01';
                  goto LAB_080fc443;
                }
              }
              local_1fc = L'\0';
            }
            else {
              if (LYCursesON == '\0') {
                uVar4 = gettext("Special URL only valid from current File Permission menu!");
                fprintf(stderr,"%s\n",uVar4);
              }
              else {
                pcVar3 = (char *)gettext("Special URL only valid from current File Permission menu!"
                                        );
                HTAlert(pcVar3);
              }
              if (WWW_TraceFlag != '\0') {
                pFVar5 = TraceFP();
                fprintf((FILE *)pFVar5,"permit_location: called for file \'%s\'.\n",tmpdst);
              }
              local_1fc = L'\0';
            }
          }
          else {
            if (pcVar3 != (char *)0x0) {
              free(pcVar3);
            }
            local_1fc = L'\0';
          }
        }
      }
    }
  }
  else {
    pcVar3 = strip_trailing_slash(srcpath);
    BVar2 = ok_lstat(pcVar3,&dir_info);
    if (BVar2 != '\0') {
      BVar2 = ok_file_or_dir(&dir_info);
      if (BVar2 != '\0') {
        user_filename = LYPathLeaf(pcVar3);
        LYRemoveTemp(permit_location::tempfile);
        fp0 = LYOpenTemp(permit_location::tempfile,".html","w");
        if (fp0 == (FILE *)0x0) {
          pcVar3 = (char *)gettext("Unable to open permit options file");
          HTAlert(pcVar3);
          local_1fc = L'\0';
        }
        else {
          LYLocalFileToURL(newpath,permit_location::tempfile);
          LYRegisterUIPage(*newpath,UIP_PERMIT_OPTIONS);
          group_name = HTAA_GidToName(dir_info.st_gid);
          LYstrncpy(LYValidPermitFile,pcVar3,L'');
          uVar4 = gettext("File Permission Options");
          fprintf((FILE *)fp0,"<Html><Head>\n<Title>%s</Title>\n</Head>\n<Body>\n",uVar4);
          uVar4 = gettext("Permissions for ");
          fprintf((FILE *)fp0,"<H1>%s%s</H1>\n",uVar4,user_filename);
          pcVar3 = HTEscape(pcVar3,'\x04');
          srcpath_url = pcVar3;
          fprintf((FILE *)fp0,"<Form Action=\"%s//PERMIT_LOCATION%s\">\n","LYNXDIRED:",pcVar3);
          if (srcpath_url != (char *)0x0) {
            free(srcpath_url);
            srcpath_url = (char *)0x0;
          }
          uVar4 = gettext("Specify permissions below:");
          fprintf((FILE *)fp0,"<Ol><Li>%s<Br><Br>\n",uVar4,pcVar3);
          uVar4 = gettext("Owner:");
          fprintf((FILE *)fp0,"%s:<Br>\n",uVar4);
          if ((dir_info.st_mode & 0x100) == 0) {
            local_1f8 = "";
          }
          else {
            local_1f8 = "checked";
          }
          fprintf((FILE *)fp0,
                  "<Input Type=\"checkbox\" Name=\"mode\" Value=\"IRUSR\" %s> Read<Br>\n",local_1f8)
          ;
          if ((dir_info.st_mode & 0x80) == 0) {
            local_1f4 = "";
          }
          else {
            local_1f4 = "checked";
          }
          fprintf((FILE *)fp0,
                  "<Input Type=\"checkbox\" Name=\"mode\" Value=\"IWUSR\" %s> Write<Br>\n",local_1f4
                 );
          if ((no_change_exec_perms == '\0') || ((dir_info.st_mode & 0xf000) == 0x4000)) {
            if ((dir_info.st_mode & 0xf000) == 0x4000) {
              local_1f0 = "Search";
            }
            else {
              local_1f0 = "Execute";
            }
            if ((dir_info.st_mode & 0x40) == 0) {
              local_1ec = "";
            }
            else {
              local_1ec = "checked";
            }
            fprintf((FILE *)fp0,
                    "<Input Type=\"checkbox\" Name=\"mode\" Value=\"IXUSR\" %s> %s<Br>\n",local_1ec,
                    local_1f0);
          }
          uVar4 = gettext("Group");
          local_1e0 = group_name;
          fprintf((FILE *)fp0,"%s %s:<Br>\n",uVar4,group_name);
          if ((dir_info.st_mode & 0x20) == 0) {
            local_1e8 = "";
          }
          else {
            local_1e8 = "checked";
          }
          fprintf((FILE *)fp0,
                  "<Input Type=\"checkbox\" Name=\"mode\" Value=\"IRGRP\" %s> Read<Br>\n",local_1e8,
                  local_1e0);
          if ((dir_info.st_mode & 0x10) == 0) {
            local_1e4 = "";
          }
          else {
            local_1e4 = "checked";
          }
          fprintf((FILE *)fp0,
                  "<Input Type=\"checkbox\" Name=\"mode\" Value=\"IWGRP\" %s> Write<Br>\n",local_1e4
                  ,local_1e0);
          if ((no_change_exec_perms == '\0') || ((dir_info.st_mode & 0xf000) == 0x4000)) {
            if ((dir_info.st_mode & 0xf000) == 0x4000) {
              local_1e0 = "Search";
            }
            else {
              local_1e0 = "Execute";
            }
            if ((dir_info.st_mode & 8) == 0) {
              local_1dc = "";
            }
            else {
              local_1dc = "checked";
            }
            fprintf((FILE *)fp0,
                    "<Input Type=\"checkbox\" Name=\"mode\" Value=\"IXGRP\" %s> %s<Br>\n",local_1dc,
                    local_1e0);
          }
          uVar4 = gettext("Others:");
          fprintf((FILE *)fp0,"%s<Br>\n",uVar4,local_1e0);
          if ((dir_info.st_mode & 4) == 0) {
            local_1d8 = "";
          }
          else {
            local_1d8 = "checked";
          }
          fprintf((FILE *)fp0,
                  "<Input Type=\"checkbox\" Name=\"mode\" Value=\"IROTH\" %s> Read<Br>\n",local_1d8,
                  local_1e0);
          if ((dir_info.st_mode & 2) == 0) {
            local_1d4 = "";
          }
          else {
            local_1d4 = "checked";
          }
          fprintf((FILE *)fp0,
                  "<Input Type=\"checkbox\" Name=\"mode\" Value=\"IWOTH\" %s> Write<Br>\n",local_1d4
                 );
          if ((no_change_exec_perms == '\0') || ((dir_info.st_mode & 0xf000) == 0x4000)) {
            if ((dir_info.st_mode & 0xf000) == 0x4000) {
              local_1d0 = "Search";
            }
            else {
              local_1d0 = "Execute";
            }
            if ((dir_info.st_mode & 1) == 0) {
              local_1cc = "";
            }
            else {
              local_1cc = "checked";
            }
            fprintf((FILE *)fp0,
                    "<Input Type=\"checkbox\" Name=\"mode\" Value=\"IXOTH\" %s> %s<Br>\n",local_1cc,
                    local_1d0);
          }
          if ((dir_info.st_mode & 0xf000) == 0x4000) {
            local_1c8 = "directory";
          }
          else {
            local_1c8 = "file";
          }
          uVar4 = gettext("form to permit");
          fprintf((FILE *)fp0,
                  "<Br>\n<Li><Input Type=\"submit\" Value=\"Submit\">  %s %s %s.\n</Ol>\n</Form>\n",
                  uVar4,local_1c8,user_filename);
          fwrite("</Body></Html>",1,0xe,(FILE *)fp0);
          LYCloseTempFP(fp0);
          LYforce_no_cache = '\x01';
          local_1fc = L'\xffffff9d';
        }
        goto LAB_080fc443;
      }
    }
    local_1fc = L'\0';
  }
LAB_080fc443:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return local_1fc;
}



// WARNING: Unknown calling convention

void tagflag(wchar_t flag,wchar_t cur)

{
  if (0 < nlinks) {
    LYmove(links[cur].ly,L'\x02');
    lynx_stop_reverse();
    if (flag == L'\x01') {
      waddch(LYwin,0x2b);
    }
    else {
      waddch(LYwin,0x20);
    }
    if (LYShowCursor == '\0') {
      LYmove(LYlines + L'\xffffffff',(LYcols - (uint)(LYShowScrollbar != '\0')) + L'\xffffffff');
    }
    else {
      LYmove(links[cur].ly,links[cur].lx);
    }
    LYrefresh();
  }
  return;
}



// WARNING: Unknown calling convention

void showtags(HTList *t)

{
  int iVar1;
  char *local_18;
  char *name;
  HTList *s;
  wchar_t i;
  
  i = L'\0';
  do {
    if (nlinks <= i) {
      return;
    }
    s = t;
    do {
      if ((s == (HTList *)0x0) || (s = s->next, s == (HTList *)0x0)) {
        local_18 = (char *)0x0;
      }
      else {
        local_18 = (char *)s->object;
      }
      if (local_18 == (char *)0x0) goto LAB_080fc5c5;
      iVar1 = strcmp(links[i].lname,local_18);
    } while (iVar1 != 0);
    tagflag(L'\x01',i);
LAB_080fc5c5:
    i = i + L'\x01';
  } while( true );
}



// WARNING: Unknown calling convention

char * DirectoryOf(char *pathname)

{
  BOOLEAN BVar1;
  char *pcVar2;
  char *result1;
  char *leaf;
  char *result;
  
  result = (char *)0x0;
  HTSACopy(&result,pathname);
  pcVar2 = LYPathLeaf(result);
  if (pcVar2 != result) {
    *pcVar2 = '\0';
    BVar1 = LYisRootPath(result);
    if (BVar1 == '\0') {
      LYTrimPathSep(result);
    }
    pcVar2 = wwwName(result);
    HTSACopy(&result,pcVar2);
  }
  return result;
}



// WARNING: Unknown calling convention

char * match_op(char *prefix,char *data)

{
  size_t __n;
  int iVar1;
  wchar_t len;
  
  __n = strlen(prefix);
  iVar1 = strncmp("LYNXDIRED://",data,0xc);
  if ((iVar1 == 0) && (iVar1 = strncmp(prefix,data + 0xc,__n), iVar1 == 0)) {
    return data + __n + 0xc;
  }
  return (char *)0x0;
}



// WARNING: Unknown calling convention

char * build_command(char *line,char *dirname,char *arg)

{
  char *pcVar1;
  char *pcVar2;
  char *pcVar3;
  char *pcVar4;
  char *local_18;
  char *tar_path;
  char *program;
  char *buffer;
  
  buffer = (char *)0x0;
  pcVar1 = HTGetProgramPath(ppTAR);
  pcVar2 = match_op("DECOMPRESS",line);
  if (pcVar2 == (char *)0x0) {
    pcVar2 = match_op("UUDECODE",line);
    if (pcVar2 == (char *)0x0) {
      if (pcVar1 != (char *)0x0) {
        pcVar2 = match_op("UNTAR_GZ",line);
        if (pcVar2 != (char *)0x0) {
          pcVar3 = HTGetProgramPath(ppGZIP);
          if (pcVar3 != (char *)0x0) {
            pcVar4 = DirectoryOf(pcVar2);
            HTAddParam(&buffer,"cd %s; %s -qdc %s |  %s %s %s",1,pcVar4);
            HTAddParam(&buffer,"cd %s; %s -qdc %s |  %s %s %s",2,pcVar3);
            HTAddParam(&buffer,"cd %s; %s -qdc %s |  %s %s %s",3,pcVar2);
            HTAddParam(&buffer,"cd %s; %s -qdc %s |  %s %s %s",4,pcVar1);
            HTAddToCmd(&buffer,"cd %s; %s -qdc %s |  %s %s %s",5,"-xf");
            HTAddToCmd(&buffer,"cd %s; %s -qdc %s |  %s %s %s",6,"-");
            HTEndParam(&buffer,"cd %s; %s -qdc %s |  %s %s %s",6);
          }
          return buffer;
        }
        pcVar2 = match_op("UNTAR_Z",line);
        if (pcVar2 != (char *)0x0) {
          pcVar3 = HTGetProgramPath(ppZCAT);
          if (pcVar3 != (char *)0x0) {
            pcVar4 = DirectoryOf(pcVar2);
            HTAddParam(&buffer,"cd %s; %s %s |  %s %s %s",1,pcVar4);
            HTAddParam(&buffer,"cd %s; %s %s |  %s %s %s",2,pcVar3);
            HTAddParam(&buffer,"cd %s; %s %s |  %s %s %s",3,pcVar2);
            HTAddParam(&buffer,"cd %s; %s %s |  %s %s %s",4,pcVar1);
            HTAddToCmd(&buffer,"cd %s; %s %s |  %s %s %s",5,"-xf");
            HTAddToCmd(&buffer,"cd %s; %s %s |  %s %s %s",6,"-");
            HTEndParam(&buffer,"cd %s; %s %s |  %s %s %s",6);
          }
          return buffer;
        }
        pcVar2 = match_op("UNTAR",line);
        if (pcVar2 != (char *)0x0) {
          pcVar3 = DirectoryOf(pcVar2);
          HTAddParam(&buffer,"cd %s; %s %s %s",1,pcVar3);
          HTAddParam(&buffer,"cd %s; %s %s %s",2,pcVar1);
          HTAddToCmd(&buffer,"cd %s; %s %s %s",3,"-xf");
          HTAddParam(&buffer,"cd %s; %s %s %s",4,pcVar2);
          HTEndParam(&buffer,"cd %s; %s %s %s",4);
          return buffer;
        }
        pcVar2 = match_op("TAR_GZ",line);
        if (pcVar2 != (char *)0x0) {
          pcVar3 = HTGetProgramPath(ppGZIP);
          if (pcVar3 != (char *)0x0) {
            pcVar4 = DirectoryOf(pcVar2);
            HTAddParam(&buffer,"cd %s; %s %s %s %s | %s -qc >%s%s",1,pcVar4);
            HTAddParam(&buffer,"cd %s; %s %s %s %s | %s -qc >%s%s",2,pcVar1);
            HTAddToCmd(&buffer,"cd %s; %s %s %s %s | %s -qc >%s%s",3,"-cf");
            HTAddToCmd(&buffer,"cd %s; %s %s %s %s | %s -qc >%s%s",4,"-");
            pcVar1 = LYPathLeaf(pcVar2);
            HTAddParam(&buffer,"cd %s; %s %s %s %s | %s -qc >%s%s",5,pcVar1);
            HTAddParam(&buffer,"cd %s; %s %s %s %s | %s -qc >%s%s",6,pcVar3);
            pcVar1 = LYPathLeaf(pcVar2);
            HTAddParam(&buffer,"cd %s; %s %s %s %s | %s -qc >%s%s",7,pcVar1);
            HTAddParam(&buffer,"cd %s; %s %s %s %s | %s -qc >%s%s",8,".tar.gz");
            HTEndParam(&buffer,"cd %s; %s %s %s %s | %s -qc >%s%s",8);
          }
          return buffer;
        }
        pcVar2 = match_op("TAR_Z",line);
        if (pcVar2 != (char *)0x0) {
          pcVar3 = HTGetProgramPath(ppCOMPRESS);
          if (pcVar3 != (char *)0x0) {
            pcVar4 = DirectoryOf(pcVar2);
            HTAddParam(&buffer,"cd %s; %s %s %s %s | %s >%s%s",1,pcVar4);
            HTAddParam(&buffer,"cd %s; %s %s %s %s | %s >%s%s",2,pcVar1);
            HTAddToCmd(&buffer,"cd %s; %s %s %s %s | %s >%s%s",3,"-cf");
            HTAddToCmd(&buffer,"cd %s; %s %s %s %s | %s >%s%s",4,"-");
            pcVar1 = LYPathLeaf(pcVar2);
            HTAddParam(&buffer,"cd %s; %s %s %s %s | %s >%s%s",5,pcVar1);
            HTAddParam(&buffer,"cd %s; %s %s %s %s | %s >%s%s",6,pcVar3);
            pcVar1 = LYPathLeaf(pcVar2);
            HTAddParam(&buffer,"cd %s; %s %s %s %s | %s >%s%s",7,pcVar1);
            HTAddParam(&buffer,"cd %s; %s %s %s %s | %s >%s%s",8,".tar.Z");
            HTEndParam(&buffer,"cd %s; %s %s %s %s | %s >%s%s",8);
          }
          return buffer;
        }
        pcVar2 = match_op("TAR",line);
        if (pcVar2 != (char *)0x0) {
          pcVar3 = DirectoryOf(pcVar2);
          HTAddParam(&buffer,"cd %s; %s %s %s %s.tar %s",1,pcVar3);
          HTAddParam(&buffer,"cd %s; %s %s %s %s.tar %s",2,pcVar1);
          HTAddToCmd(&buffer,"cd %s; %s %s %s %s.tar %s",3,"-cf");
          HTAddToCmd(&buffer,"cd %s; %s %s %s %s.tar %s",4,"");
          pcVar1 = LYPathLeaf(pcVar2);
          HTAddParam(&buffer,"cd %s; %s %s %s %s.tar %s",5,pcVar1);
          pcVar1 = LYPathLeaf(pcVar2);
          HTAddParam(&buffer,"cd %s; %s %s %s %s.tar %s",6,pcVar1);
          HTEndParam(&buffer,"cd %s; %s %s %s %s.tar %s",6);
          return buffer;
        }
      }
      pcVar1 = match_op("GZIP",line);
      if (pcVar1 == (char *)0x0) {
        pcVar1 = match_op("UNGZIP",line);
        if (pcVar1 == (char *)0x0) {
          pcVar1 = match_op("ZIP",line);
          if (pcVar1 == (char *)0x0) {
            pcVar1 = match_op("UNZIP",line);
            if (pcVar1 == (char *)0x0) {
              pcVar1 = match_op("COMPRESS",line);
              if (pcVar1 == (char *)0x0) {
                local_18 = (char *)0x0;
              }
              else {
                pcVar2 = HTGetProgramPath(ppCOMPRESS);
                if (pcVar2 != (char *)0x0) {
                  HTAddParam(&buffer,"%s %s",1,pcVar2);
                  HTAddParam(&buffer,"%s %s",2,pcVar1);
                  HTEndParam(&buffer,"%s %s",2);
                }
                local_18 = buffer;
              }
            }
            else {
              pcVar2 = HTGetProgramPath(ppUNZIP);
              if (pcVar2 != (char *)0x0) {
                pcVar3 = DirectoryOf(pcVar1);
                HTAddParam(&buffer,"cd %s; %s -q %s",1,pcVar3);
                HTAddParam(&buffer,"cd %s; %s -q %s",2,pcVar2);
                HTAddParam(&buffer,"cd %s; %s -q %s",3,pcVar1);
                HTEndParam(&buffer,"cd %s; %s -q %s",3);
              }
              local_18 = buffer;
            }
          }
          else {
            pcVar2 = HTGetProgramPath(ppZIP);
            if (pcVar2 != (char *)0x0) {
              pcVar3 = DirectoryOf(pcVar1);
              HTAddParam(&buffer,"cd %s; %s -rq %s.zip %s",1,pcVar3);
              HTAddParam(&buffer,"cd %s; %s -rq %s.zip %s",2,pcVar2);
              pcVar2 = LYPathLeaf(pcVar1);
              HTAddParam(&buffer,"cd %s; %s -rq %s.zip %s",3,pcVar2);
              pcVar1 = LYPathLeaf(pcVar1);
              HTAddParam(&buffer,"cd %s; %s -rq %s.zip %s",4,pcVar1);
              HTEndParam(&buffer,"cd %s; %s -rq %s.zip %s",4);
            }
            local_18 = buffer;
          }
        }
        else {
          pcVar2 = HTGetProgramPath(ppGZIP);
          if (pcVar2 != (char *)0x0) {
            HTAddParam(&buffer,"%s -d %s",1,pcVar2);
            HTAddParam(&buffer,"%s -d %s",2,pcVar1);
            HTEndParam(&buffer,"%s -d %s",2);
          }
          local_18 = buffer;
        }
      }
      else {
        pcVar2 = HTGetProgramPath(ppGZIP);
        if (pcVar2 != (char *)0x0) {
          HTAddParam(&buffer,"%s -q %s",1,pcVar2);
          HTAddParam(&buffer,"%s -q %s",2,pcVar1);
          HTEndParam(&buffer,"%s -q %s",2);
        }
        local_18 = buffer;
      }
    }
    else {
      pcVar1 = HTGetProgramPath(ppUUDECODE);
      if (pcVar1 != (char *)0x0) {
        HTAddParam(&buffer,"%s %s",1,pcVar1);
        HTAddParam(&buffer,"%s %s",2,pcVar2);
        HTEndParam(&buffer,"%s %s",2);
        pcVar1 = (char *)gettext(
                                "Warning!  UUDecoded file will exist in the directory you started Lynx."
                                );
        HTAlert(pcVar1);
      }
      local_18 = buffer;
    }
  }
  else {
    pcVar1 = HTGetProgramPath(ppUNCOMPRESS);
    if (pcVar1 != (char *)0x0) {
      HTAddParam(&buffer,"%s %s",1,pcVar1);
      HTAddParam(&buffer,"%s %s",2,pcVar2);
      HTEndParam(&buffer,"%s %s",2);
    }
    local_18 = buffer;
  }
  return local_18;
}



// WARNING: Removing unreachable block (ram,0x080fd854)
// WARNING: Unknown calling convention

wchar_t local_dired(DocInfo *doc)

{
  FILE *__stream;
  wchar_t wVar1;
  int iVar2;
  char *pcVar3;
  size_t sVar4;
  char *local_30;
  char *dirname;
  char *buffer;
  char *tmpbuf;
  char *tp;
  char *arg;
  char *line;
  char *line_url;
  BOOLEAN do_pop_doc;
  
  line = (char *)0x0;
  arg = (char *)0x0;
  tp = (char *)0x0;
  tmpbuf = (char *)0x0;
  buffer = (char *)0x0;
  do_pop_doc = '\x01';
  local_30 = doc->address;
  line_url = local_30;
  if (WWW_TraceFlag != '\0') {
    if (local_30 == (char *)0x0) {
      local_30 = (char *)gettext("NULL URL pointer");
    }
    __stream = TraceFP();
    fprintf((FILE *)__stream,"local_dired: called for <%s>.\n",local_30);
  }
  HTUnEscapeSome(line_url,"/");
  HTSACopy(&line,line_url);
  HTUnEscape(line);
  arg = match_op("CHDIR",line);
  if (arg == (char *)0x0) {
    arg = match_op("NEW_FILE",line);
    if (arg == (char *)0x0) {
      arg = match_op("NEW_FOLDER",line);
      if (arg == (char *)0x0) {
        arg = match_op("MODIFY_NAME",line);
        if (arg == (char *)0x0) {
          arg = match_op("MODIFY_LOCATION",line);
          if (arg == (char *)0x0) {
            arg = match_op("MOVE_TAGGED",line_url);
            if (arg == (char *)0x0) {
              arg = match_op("PERMIT_SRC",line);
              if (arg != (char *)0x0) {
                permit_location((char *)0x0,arg,&tp);
                if (tp != (char *)0x0) {
                  if (doc->address != (char *)0x0) {
                    free(doc->address);
                    doc->address = (char *)0x0;
                  }
                  doc->address = tp;
                }
                if (line == (char *)0x0) {
                  return L'\0';
                }
                free(line);
                return L'\0';
              }
              arg = match_op("PERMIT_LOCATION",line_url);
              if (arg == (char *)0x0) {
                arg = match_op("REMOVE_SINGLE",line);
                if (arg == (char *)0x0) {
                  arg = match_op("REMOVE_TAGGED",line);
                  if (arg == (char *)0x0) {
                    arg = match_op("CLEAR_TAGGED",line);
                    if (arg == (char *)0x0) {
                      arg = match_op("UPLOAD",line);
                      if (arg == (char *)0x0) {
                        LYTrimPathSep(line);
                        pcVar3 = LYLastPathSep(line);
                        if (pcVar3 == (char *)0x0) {
                          if (line == (char *)0x0) {
                            return L'\0';
                          }
                          free(line);
                          return L'\0';
                        }
                        buffer = build_command(line,(char *)0x0,arg);
                        if (buffer != (char *)0x0) {
                          sVar4 = strlen(buffer);
                          if ((int)sVar4 < (int)((LYcols - (uint)(LYShowScrollbar != '\0')) + -0xe))
                          {
                            pcVar3 = (char *)gettext("Executing %s ");
                            HTSprintf0(&tmpbuf,pcVar3,buffer);
                          }
                          else {
                            pcVar3 = (char *)gettext(
                                                  "Executing system command. This might take a while."
                                                  );
                            HTSprintf0(&tmpbuf,pcVar3);
                          }
                          mustshow = '\x01';
                          statusline(tmpbuf);
                          stop_curses();
                          printf("%s\r\n",tmpbuf);
                          LYSystem(buffer);
                          start_curses();
                          LYforce_no_cache = '\x01';
                        }
                      }
                      else {
                        iVar2 = LYUpload(line_url);
                        if (iVar2 != 0) {
                          LYforce_no_cache = '\x01';
                        }
                      }
                    }
                    else {
                      clear_tags();
                    }
                  }
                  else {
                    wVar1 = remove_tagged();
                    if (wVar1 != L'\0') {
                      LYforce_no_cache = '\x01';
                    }
                  }
                }
                else {
                  wVar1 = remove_single(arg);
                  if (L'\0' < wVar1) {
                    LYforce_no_cache = '\x01';
                  }
                }
              }
              else {
                permit_location(arg,(char *)0x0,&tp);
              }
            }
            else {
              wVar1 = modify_tagged(arg);
              if (L'\0' < wVar1) {
                LYforce_no_cache = '\x01';
              }
            }
          }
          else {
            wVar1 = modify_location(arg);
            if (L'\0' < wVar1) {
              LYforce_no_cache = '\x01';
            }
          }
        }
        else {
          wVar1 = modify_name(arg);
          if (L'\0' < wVar1) {
            LYforce_no_cache = '\x01';
          }
        }
      }
      else {
        wVar1 = create_directory(arg);
        if (L'\0' < wVar1) {
          LYforce_no_cache = '\x01';
        }
      }
    }
    else {
      wVar1 = create_file(arg);
      if (L'\0' < wVar1) {
        LYforce_no_cache = '\x01';
      }
    }
  }
  else {
    handle_LYK_CHDIR();
    do_pop_doc = '\0';
    arg = "blah";
  }
  if (tmpbuf != (char *)0x0) {
    free(tmpbuf);
    tmpbuf = (char *)0x0;
  }
  if (buffer != (char *)0x0) {
    free(buffer);
  }
  if (line != (char *)0x0) {
    free(line);
    line = (char *)0x0;
  }
  if (tp != (char *)0x0) {
    free(tp);
    tp = (char *)0x0;
  }
  if (do_pop_doc != '\0') {
    LYpop(doc);
  }
  return L'\0';
}



wchar_t dired_options(DocInfo *doc,char **newfile)

{
  int iVar1;
  BOOLEAN BVar2;
  char *pcVar3;
  undefined4 uVar4;
  size_t sVar5;
  size_t sVar6;
  int iVar7;
  int in_GS_OFFSET;
  wchar_t local_8d0;
  BOOLEAN local_8c8;
  undefined4 local_8c4;
  char *local_8c0;
  undefined1 *local_8b8;
  char **newfile_local;
  DocInfo *doc_local;
  stat dir_info;
  wchar_t m;
  wchar_t i;
  char *cd;
  char *cp1;
  wchar_t n;
  dired_menu *mp;
  wchar_t count;
  char *path_url;
  char *dir_url;
  FILE *fp0;
  lynx_list_item_type *nxt;
  char *dir;
  char *path;
  BOOLEAN nothing_tagged;
  char buf [2048];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  fp0 = InternalPageFP(dired_options::tempfile,L'\0');
  if (fp0 != (FILE *)0x0) {
    LYLocalFileToURL(newfile,dired_options::tempfile);
    LYRegisterUIPage(*newfile,UIP_DIRED_MENU);
    if ((doc->link < L'\0') || (nlinks + L'\x01' <= doc->link)) {
      HTSACopy(&path,"");
    }
    else {
      path = HTnameOfFile_WWW(links[doc->link].lname,'\0','\x01');
      LYTrimPathSep(path);
      BVar2 = ok_lstat(path,&dir_info);
      if (BVar2 == '\0') {
        LYCloseTempFP(fp0);
        if (path != (char *)0x0) {
          free(path);
          path = (char *)0x0;
        }
        goto LAB_080fe2a9;
      }
    }
    dir = HTnameOfFile_WWW(doc->address,'\0','\x01');
    LYTrimPathSep(dir);
    if ((tagged == (HTList *)0x0) || (tagged->next == (HTList *)0x0)) {
      local_8c8 = '\x01';
    }
    else {
      local_8c8 = '\0';
    }
    nothing_tagged = local_8c8;
    pcVar3 = (char *)gettext("File Management Options");
    BeginInternalPage(fp0,pcVar3,"keystrokes/dired_help.html.gz");
    uVar4 = gettext("Current directory:");
    pcVar3 = dir;
    fprintf((FILE *)fp0,"<em>%s</em> %s<br>\n",uVar4,dir);
    if (nothing_tagged == '\0') {
      n = HTList_count(tagged);
      cp1 = (char *)0x0;
      cd = (char *)0x0;
      if (n == L'\x01') {
        local_8c4 = gettext("tagged item:");
      }
      else {
        local_8c4 = gettext("tagged items:");
      }
      uVar4 = gettext("Current selection:");
      fprintf((FILE *)fp0,"<em>%s</em> %d %s",uVar4,n,local_8c4);
      HTSACopy(&cd,doc->address);
      HTUnEscapeSome(cd,"/");
      LYAddHtmlSep(&cd);
      local_8d0 = n;
      if (L'\n' < n) {
        local_8d0 = L'\n';
      }
      for (i = L'\x01'; i <= local_8d0; i = i + L'\x01') {
        if (*cd == '\0') {
          local_8c0 = "file://localhost";
        }
        else {
          local_8c0 = cd;
        }
        pcVar3 = (char *)HTList_objectAt(tagged,i + L'\xffffffff');
        cp1 = HTRelative(pcVar3,local_8c0);
        HTUnEscape(cp1);
        LYEntify(&cp1,'\x01');
        if (i == L'\x01') {
          local_8b8 = &DAT_0817d5c4;
        }
        else {
          local_8b8 = &DAT_0817e8fd;
        }
        fprintf((FILE *)fp0,"%s<br>\n&nbsp;&nbsp;&nbsp;%s",local_8b8,cp1);
        if (cp1 != (char *)0x0) {
          free(cp1);
          cp1 = (char *)0x0;
        }
      }
      if (local_8d0 < n) {
        fwrite(" , ...",1,6,(FILE *)fp0);
      }
      fwrite(&DAT_0817e923,1,4,(FILE *)fp0);
      if (cd != (char *)0x0) {
        free(cd);
        cd = (char *)0x0;
      }
    }
    else {
      uVar4 = gettext("Current selection:");
      fprintf((FILE *)fp0,"<em>%s</em> ",uVar4,pcVar3);
      if (*path == '\0') {
        uVar4 = gettext("Nothing currently selected.");
        fprintf((FILE *)fp0,"%s.<p>\n",uVar4,pcVar3);
      }
      else {
        fprintf((FILE *)fp0,"%s<p>\n",path,pcVar3);
      }
    }
    if (menu_head == (dired_menu *)0x0) {
      for (mp = defmenu; mp->href != (char *)0x0; mp = mp + 1) {
        mp->next = mp + 1;
      }
      mp[-1].next = (dired_menu *)0x0;
      menu_head = defmenu;
    }
    for (mp = menu_head; mp != (dired_menu *)0x0; mp = mp->next) {
      if (((((mp->cond == L'\x01') || (nothing_tagged != '\0')) &&
           ((mp->cond != L'\x01' || (nothing_tagged == '\0')))) &&
          ((mp->cond != L'\x02' || ((*path != '\0' && ((dir_info.st_mode & 0xf000) == 0x4000))))))
         && (((mp->cond != L'\x03' || ((*path != '\0' && ((dir_info.st_mode & 0xf000) == 0x8000))))
             && ((mp->cond != L'\x04' ||
                 ((*path != '\0' && ((dir_info.st_mode & 0xf000) == 0xa000)))))))) {
        if (*mp->sfx == '\0') {
LAB_080fdff9:
          dir_url = HTEscape(dir,'\x04');
          path_url = HTEscape(path,'\x04');
          pcVar3 = render_item(mp->href,path_url,dir_url,buf,L'','\x01');
          fprintf((FILE *)fp0,"<a href=\"%s",pcVar3);
          pcVar3 = render_item(mp->link,path,dir,buf,L'','\0');
          fprintf((FILE *)fp0,"\">%s</a> ",pcVar3);
          pcVar3 = render_item(mp->rest,path,dir,buf,L'','\0');
          fprintf((FILE *)fp0,"%s<br>\n",pcVar3);
          if (dir_url != (char *)0x0) {
            free(dir_url);
            dir_url = (char *)0x0;
          }
          if (path_url != (char *)0x0) {
            free(path_url);
            path_url = (char *)0x0;
          }
        }
        else {
          sVar5 = strlen(path);
          sVar6 = strlen(mp->sfx);
          pcVar3 = path;
          if (sVar6 <= sVar5) {
            sVar5 = strlen(path);
            sVar6 = strlen(mp->sfx);
            iVar7 = strcmp(mp->sfx,pcVar3 + (sVar5 - sVar6));
            if (iVar7 == 0) goto LAB_080fdff9;
          }
        }
      }
    }
    if (path != (char *)0x0) {
      free(path);
      path = (char *)0x0;
    }
    if (uploaders != (lynx_list_item_type *)0x0) {
      fwrite("<p>Upload to current directory:<p>\n",1,0x23,(FILE *)fp0);
      count = L'\0';
      for (nxt = uploaders; nxt != (lynx_list_item_type *)0x0; nxt = nxt->next) {
        fprintf((FILE *)fp0,"<a href=\"LYNXDIRED://UPLOAD=%d/TO=%s\"> %s </a><br>\n",count,dir,
                nxt->name);
        count = count + L'\x01';
      }
    }
    if (dir != (char *)0x0) {
      free(dir);
      dir = (char *)0x0;
    }
    EndInternalPage(fp0);
    LYCloseTempFP(fp0);
    LYforce_no_cache = '\x01';
  }
LAB_080fe2a9:
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return L'\0';
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

char * get_filename(char *prompt,char *buf,size_t bufsize)

{
  char *pcVar1;
  char *local_18;
  char *cp;
  
  mustshow = '\x01';
  statusline(prompt);
  LYgetstr(buf,L'\0',bufsize,NORECALL);
  pcVar1 = strstr(buf,"../");
  if (pcVar1 == (char *)0x0) {
    if ((no_dotfiles != '\0') || (show_dotfiles == '\0')) {
      pcVar1 = LYLastPathSep(buf);
      if (pcVar1 == (char *)0x0) {
        cp = buf;
      }
      else {
        cp = pcVar1 + 1;
      }
      if (*cp == '.') {
        pcVar1 = (char *)gettext("Illegal filename; request ignored.");
        HTAlert(pcVar1);
        return (char *)0x0;
      }
    }
    local_18 = buf;
  }
  else {
    pcVar1 = (char *)gettext("Illegal filename; request ignored.");
    HTAlert(pcVar1);
    local_18 = (char *)0x0;
  }
  return local_18;
}



// WARNING: Unknown calling convention

void clear_tags(void)

{
  void *__ptr;
  char *cp;
  
  while( true ) {
    __ptr = HTList_removeLastObject(tagged);
    if (__ptr == (void *)0x0) break;
    if (__ptr != (void *)0x0) {
      free(__ptr);
    }
  }
  if (((tagged == (HTList *)0x0) || (tagged->next == (HTList *)0x0)) && (tagged != (HTList *)0x0)) {
    free(tagged);
    tagged = (HTList *)0x0;
  }
  return;
}



// WARNING: Unknown calling convention

void add_menu_item(char *str)

{
  dired_menu *pdVar1;
  char *pcVar2;
  int iVar3;
  char *pcVar4;
  char *cp;
  dired_menu *mp;
  dired_menu *tmp;
  
  if (menu_head == defmenu) {
    menu_head = (dired_menu *)0x0;
  }
  pdVar1 = (dired_menu *)calloc(1,0x18);
  if (pdVar1 == (dired_menu *)0x0) {
    outofmem("./LYLocal.c","add_menu_item");
  }
  pcVar2 = strchr(str,0x3a);
  *pcVar2 = '\0';
  iVar3 = strcasecomp(str,"tag");
  if (iVar3 == 0) {
    pdVar1->cond = L'\x01';
  }
  else {
    iVar3 = strcasecomp(str,"dir");
    if (iVar3 == 0) {
      pdVar1->cond = L'\x02';
    }
    else {
      iVar3 = strcasecomp(str,"file");
      if (iVar3 == 0) {
        pdVar1->cond = L'\x03';
      }
      else {
        iVar3 = strcasecomp(str,"link");
        if (iVar3 == 0) {
          pdVar1->cond = L'\x04';
        }
      }
    }
  }
  pcVar4 = strchr(pcVar2 + 1,0x3a);
  *pcVar4 = '\0';
  HTSACopy(&pdVar1->sfx,pcVar2 + 1);
  pcVar2 = strchr(pcVar4 + 1,0x3a);
  *pcVar2 = '\0';
  HTSACopy(&pdVar1->link,pcVar4 + 1);
  pcVar4 = strchr(pcVar2 + 1,0x3a);
  *pcVar4 = '\0';
  HTSACopy(&pdVar1->rest,pcVar2 + 1);
  HTSACopy(&pdVar1->href,pcVar4 + 1);
  if (menu_head != (dired_menu *)0x0) {
    for (mp = menu_head; (mp != (dired_menu *)0x0 && (mp->next != (dired_menu *)0x0)); mp = mp->next
        ) {
    }
    mp->next = pdVar1;
    pdVar1 = menu_head;
  }
  menu_head = pdVar1;
  return;
}



// WARNING: Unknown calling convention

void reset_dired_menu(void)

{
  dired_menu *mp_next;
  dired_menu *mp;
  
  if (menu_head != defmenu) {
    mp = menu_head;
    while (mp != (dired_menu *)0x0) {
      if (mp->sfx != (char *)0x0) {
        free(mp->sfx);
        mp->sfx = (char *)0x0;
      }
      if (mp->link != (char *)0x0) {
        free(mp->link);
        mp->link = (char *)0x0;
      }
      if (mp->rest != (char *)0x0) {
        free(mp->rest);
        mp->rest = (char *)0x0;
      }
      if (mp->href != (char *)0x0) {
        free(mp->href);
        mp->href = (char *)0x0;
      }
      if (mp != (dired_menu *)0x0) {
        free(mp);
      }
      mp = (dired_menu *)0x0;
    }
    menu_head = (dired_menu *)0x0;
  }
  return;
}



char * render_item(char *s,char *path,char *dir,char *buf,wchar_t bufsize,BOOLEAN url_syntax)

{
  char cVar1;
  char *pcVar2;
  char *local_54;
  char *local_50;
  char *local_4c;
  char *local_48;
  char *local_44;
  char *local_40;
  char *local_3c;
  char *local_38;
  char *local_34;
  char *local_30;
  char *local_2c;
  BOOLEAN url_syntax_local;
  char *name;
  HTList *cur;
  char *taglist;
  char *bp;
  char *cp;
  char overrun;
  
  overrun = '\0';
  taglist = (char *)0x0;
  bp = buf;
  do {
    if ((*s == '\0') || (overrun != '\0')) {
      if ((byte)(overrun & url_syntax) != 0) {
        pcVar2 = (char *)gettext("Temporary URL or list would be too long.");
        HTAlert(pcVar2);
        bp = buf;
      }
      *bp = '\0';
      return buf;
    }
    if (*s == '%') {
      s = s + 1;
      cVar1 = *s;
      if (cVar1 == 'l') {
LAB_080fe8ef:
        if ((tagged != (HTList *)0x0) && (tagged->next != (HTList *)0x0)) {
          cur = tagged;
          while (overrun == '\0') {
            if ((cur == (HTList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
              local_3c = (char *)0x0;
            }
            else {
              local_3c = (char *)cur->object;
            }
            if (local_3c == (char *)0x0) break;
            if ((*s == 'l') && (pcVar2 = strrchr(local_3c,0x2f), pcVar2 != (char *)0x0)) {
              cp = pcVar2 + 1;
            }
            else {
              cp = local_3c;
            }
            HTSACat(&taglist,cp);
            HTSACat(&taglist," ");
          }
        }
        if (taglist != (char *)0x0) {
          for (cp = taglist; *cp != '\0'; cp = cp + 1) {
            if (buf + bufsize + L'\xfffffffe' < bp) {
              local_38 = &overrun;
            }
            else {
              local_38 = bp;
              bp = bp + 1;
            }
            *local_38 = *cp;
          }
          if (taglist != (char *)0x0) {
            free(taglist);
            taglist = (char *)0x0;
          }
        }
      }
      else if (cVar1 < 'm') {
        if (cVar1 == 'd') {
          cp = dir;
          if (*dir != '/') {
            if (buf + bufsize + L'\xfffffffe' < bp) {
              local_48 = &overrun;
            }
            else {
              local_48 = bp;
              bp = bp + 1;
            }
            *local_48 = '/';
          }
          for (; *cp != '\0'; cp = cp + 1) {
            if (buf + bufsize + L'\xfffffffe' < bp) {
              local_44 = &overrun;
            }
            else {
              local_44 = bp;
              bp = bp + 1;
            }
            *local_44 = *cp;
          }
        }
        else if (cVar1 == 'f') {
          pcVar2 = LYLastPathSep(path);
          if (pcVar2 == (char *)0x0) {
            cp = path;
          }
          else {
            cp = pcVar2 + 1;
          }
          for (; *cp != '\0'; cp = cp + 1) {
            if (buf + bufsize + L'\xfffffffe' < bp) {
              local_40 = &overrun;
            }
            else {
              local_40 = bp;
              bp = bp + 1;
            }
            *local_40 = *cp;
          }
        }
        else {
          if (cVar1 != '%') goto LAB_080fea16;
          if (buf + bufsize + L'\xfffffffe' < bp) {
            local_54 = &overrun;
          }
          else {
            local_54 = bp;
            bp = bp + 1;
          }
          *local_54 = '%';
        }
      }
      else if (cVar1 == 'p') {
        cp = path;
        if (*path != '/') {
          if (buf + bufsize + L'\xfffffffe' < bp) {
            local_50 = &overrun;
          }
          else {
            local_50 = bp;
            bp = bp + 1;
          }
          *local_50 = '/';
        }
        for (; *cp != '\0'; cp = cp + 1) {
          if (buf + bufsize + L'\xfffffffe' < bp) {
            local_4c = &overrun;
          }
          else {
            local_4c = bp;
            bp = bp + 1;
          }
          *local_4c = *cp;
        }
      }
      else {
        if (cVar1 == 't') goto LAB_080fe8ef;
LAB_080fea16:
        if (buf + bufsize + L'\xfffffffe' < bp) {
          local_34 = &overrun;
        }
        else {
          local_34 = bp;
          bp = bp + 1;
        }
        *local_34 = '%';
        if (buf + bufsize + L'\xfffffffe' < bp) {
          local_30 = &overrun;
        }
        else {
          local_30 = bp;
          bp = bp + 1;
        }
        *local_30 = *s;
      }
    }
    else {
      if (buf + bufsize + L'\xfffffffe' < bp) {
        local_2c = &overrun;
      }
      else {
        local_2c = bp;
        bp = bp + 1;
      }
      *local_2c = *s;
    }
    s = s + 1;
  } while( true );
}



// WARNING: Unknown calling convention

char * HTStrip(char *s)

{
  char *p;
  
  for (p = s; *p != '\0'; p = p + 1) {
  }
  while ((p = p + -1, s <= p && (((*p == ' ' || (*p == '\t')) || (*p == '\n'))))) {
    *p = '\0';
  }
  for (; ((*s == ' ' || (*s == '\t')) || (*s == '\n')); s = s + 1) {
  }
  return s;
}



// WARNING: Unknown calling convention

void scan(char *name,struct_parts *parts)

{
  char *pcVar1;
  int iVar2;
  char *local_18;
  char *p;
  char *after_access;
  
  parts->access = (char *)0x0;
  parts->host = (char *)0x0;
  parts->absolute = (char *)0x0;
  parts->relative = (char *)0x0;
  parts->search = (char *)0x0;
  parts->anchor = (char *)0x0;
  after_access = name;
  for (p = name; *p != '\0'; p = p + 1) {
    if (*p == ':') {
      *p = '\0';
      parts->access = name;
      after_access = p + 1;
      break;
    }
    if ((((*p == '/') || (*p == '#')) || (*p == ';')) || (*p == '?')) break;
  }
  p = after_access;
  do {
    if (*p == '\0') {
LAB_080fec3d:
      if (*after_access == '/') {
        if (after_access[1] == '/') {
          parts->host = after_access + 2;
          *after_access = '\0';
          pcVar1 = strchr(parts->host,0x2f);
          if (pcVar1 == (char *)0x0) {
            pcVar1 = strchr(parts->host,0x3f);
            if (pcVar1 != (char *)0x0) {
              *pcVar1 = '\0';
              parts->search = pcVar1 + 1;
            }
          }
          else {
            *pcVar1 = '\0';
            parts->absolute = pcVar1 + 1;
          }
        }
        else {
          parts->absolute = after_access + 1;
        }
      }
      else {
        if (*after_access == '\0') {
          local_18 = (char *)0x0;
        }
        else {
          local_18 = after_access;
        }
        parts->relative = local_18;
      }
      if (parts->access == (char *)0x0) {
        return;
      }
      if (parts->anchor == (char *)0x0) {
        return;
      }
      pcVar1 = strchr("lnsdLNSD",(int)*parts->access);
      if (pcVar1 != (char *)0x0) {
        if ((((parts->host != (char *)0x0) ||
             (iVar2 = strcasecomp(parts->access,"lynxcgi"), iVar2 == 0)) &&
            ((iVar2 = strcasecomp(parts->access,"nntp"), iVar2 != 0 &&
             ((iVar2 = strcasecomp(parts->access,"snews"), iVar2 != 0 &&
              (iVar2 = strcasecomp(parts->access,"news"), iVar2 != 0)))))) &&
           (iVar2 = strcasecomp(parts->access,"data"), iVar2 != 0)) {
          return;
        }
        if ((parts->relative != (char *)0x0) || (parts->absolute != (char *)0x0)) {
          parts->anchor[-1] = '#';
          parts->anchor = (char *)0x0;
        }
        return;
      }
      return;
    }
    if (*p == '#') {
      parts->anchor = p + 1;
      *p = '\0';
      goto LAB_080fec3d;
    }
    p = p + 1;
  } while( true );
}



// WARNING: Unknown calling convention

char * strchr_or_end(char *string,int ch)

{
  size_t sVar1;
  char *result;
  
  result = strchr(string,ch);
  if (result == (char *)0x0) {
    sVar1 = strlen(string);
    result = string + sVar1;
  }
  return result;
}



// WARNING: Unknown calling convention

char * HTParsePort(char *host,int *portp)

{
  byte *__nptr;
  char cVar1;
  int iVar2;
  ushort **ppuVar3;
  long lVar4;
  FILE *__stream;
  char *next;
  char *result;
  int brackets;
  
  brackets = 0;
  result = (char *)0x0;
  *portp = 0;
  __nptr = (byte *)host;
  if (host != (char *)0x0) {
    while ((host = (char *)__nptr, *host != '\0' && (result == (char *)0x0))) {
      cVar1 = *host;
      __nptr = (byte *)(host + 1);
      if (cVar1 == '[') {
        brackets = brackets + 1;
      }
      else if (cVar1 == ']') {
        brackets = brackets + -1;
      }
      else if (((cVar1 == ':') && (brackets == 0)) &&
              (ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[*__nptr] & 0x800) != 0)) {
        next = (char *)0x0;
        lVar4 = strtol((char *)__nptr,&next,10);
        *portp = lVar4;
        if (((next != (char *)0x0) && ((byte *)next != __nptr)) &&
           ((*next == '\0' && (result = host, WWW_TraceFlag != '\0')))) {
          iVar2 = *portp;
          __stream = TraceFP();
          fprintf((FILE *)__stream,"HTParsePort %d\n",iVar2);
        }
      }
    }
  }
  return result;
}



char * HTParse(char *aName,char *relatedName,int wanted)

{
  char *pcVar1;
  int iVar2;
  FILE *pFVar3;
  size_t sVar4;
  int iVar5;
  char *pcVar6;
  int in_GS_OFFSET;
  char *pcStack_f0;
  char *local_e4;
  char *local_e0;
  char *local_dc;
  char *local_d8;
  char *local_d4;
  char *local_d0;
  char *local_cc;
  char *local_c0;
  char *local_bc;
  char *local_b8;
  char *local_b4;
  char *local_b0;
  char *local_ac;
  char *local_a8;
  char *local_a4;
  char *local_a0;
  char *local_9c;
  int local_98;
  UrlTypes local_94;
  char *relatedName_local;
  char *aName_local;
  struct_parts related;
  struct_parts given;
  char *base;
  int want_detail;
  int len3;
  int portnumber;
  char *h;
  char *p2;
  char *acc_method;
  char *q;
  char *p;
  char *rel;
  char *name;
  uint len2;
  uint len1;
  uint len;
  char *return_value;
  char *tail;
  char *result;
  int local_c;
  
  aName_local = aName;
  relatedName_local = relatedName;
  local_c = *(int *)(in_GS_OFFSET + 0x14);
  result = (char *)0x0;
  tail = (char *)0x0;
  return_value = (char *)0x0;
  name = (char *)0x0;
  rel = (char *)0x0;
  if (WWW_TraceFlag != '\0') {
    pcStack_f0 = (char *)0x80fefb3;
    pFVar3 = TraceFP();
    local_e4 = aName_local;
    pcStack_f0 = (char *)0x80fefcd;
    fprintf((FILE *)pFVar3,"HTParse: aName:`%s\'\n");
  }
  if (WWW_TraceFlag != '\0') {
    pcStack_f0 = (char *)0x80fefdf;
    pFVar3 = TraceFP();
    local_e4 = relatedName_local;
    pcStack_f0 = (char *)0x80feff9;
    fprintf((FILE *)pFVar3,"   relatedName:`%s\'\n");
  }
  if ((wanted & 0x60U) != 0) {
    if ((wanted & 0x60U) == 0x60) {
      wanted = wanted | 4;
    }
    if ((wanted & 4U) != 0) {
      wanted = wanted & 0xffffff9f;
    }
  }
  if (WWW_TraceFlag != '\0') {
    if ((wanted & 0x40U) == 0) {
      local_c0 = "";
    }
    else {
      local_c0 = " QUERY";
    }
    if ((wanted & 0x20U) == 0) {
      local_bc = "";
    }
    else {
      local_bc = " PATH";
    }
    if ((wanted & 0x10U) == 0) {
      local_b8 = "";
    }
    else {
      local_b8 = " access";
    }
    if ((wanted & 8U) == 0) {
      local_b4 = "";
    }
    else {
      local_b4 = " host";
    }
    if ((wanted & 4U) == 0) {
      local_b0 = "";
    }
    else {
      local_b0 = " path";
    }
    if ((wanted & 2U) == 0) {
      local_ac = "";
    }
    else {
      local_ac = " anchor";
    }
    if ((wanted & 1U) == 0) {
      local_a8 = "";
    }
    else {
      local_a8 = " punc";
    }
    pcStack_f0 = (char *)0x80ff116;
    pFVar3 = TraceFP();
    local_cc = local_c0;
    local_d0 = local_bc;
    local_d4 = local_b8;
    local_d8 = local_b4;
    local_dc = local_b0;
    local_e0 = local_ac;
    local_e4 = local_a8;
    pcStack_f0 = (char *)0x80ff16c;
    fprintf((FILE *)pFVar3,"   want:%s%s%s%s%s%s%s\n");
  }
  pcStack_f0 = (char *)0x80ff17c;
  sVar4 = strlen(aName_local);
  len1 = sVar4 + 1;
  pcStack_f0 = (char *)0x80ff190;
  sVar4 = strlen(relatedName_local);
  len2 = sVar4 + 1;
  len = len1 + len2 + 8;
  iVar2 = -(len * 2 + len1 + len2 + 0x1e & 0xfffffff0);
  local_a4 = (char *)((int)&local_c0 + iVar2);
  tail = local_a4;
  result = local_a4;
  if (local_a4 == (char *)0x0) {
    *(char **)(&stack0xffffff18 + iVar2) = "HTParse";
    *(char **)(&stack0xffffff14 + iVar2) = "../../../WWW/Library/Implementation/HTParse.c";
    *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ff205;
    outofmem(*(char **)(&stack0xffffff14 + iVar2),*(char **)(&stack0xffffff18 + iVar2));
  }
  *result = '\0';
  name = result + len;
  rel = result + len + len1;
  *(uint *)((int)&stack0xffffff1c + iVar2) = len1;
  *(char **)(&stack0xffffff18 + iVar2) = aName_local;
  *(char **)(&stack0xffffff14 + iVar2) = name;
  *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ff23d;
  memcpy(*(void **)(&stack0xffffff14 + iVar2),*(void **)(&stack0xffffff18 + iVar2),
         *(size_t *)((int)&stack0xffffff1c + iVar2));
  *(struct_parts **)(&stack0xffffff18 + iVar2) = &given;
  *(char **)(&stack0xffffff14 + iVar2) = name;
  *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ff24f;
  scan(*(char **)(&stack0xffffff14 + iVar2),*(struct_parts **)(&stack0xffffff18 + iVar2));
  if ((((given.access == (char *)0x0) || (given.host == (char *)0x0)) ||
      (given.absolute == (char *)0x0)) && (*relatedName_local != '\0')) {
    *(uint *)((int)&stack0xffffff1c + iVar2) = len2;
    *(char **)(&stack0xffffff18 + iVar2) = relatedName_local;
    *(char **)(&stack0xffffff14 + iVar2) = rel;
    *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ff2b9;
    memcpy(*(void **)(&stack0xffffff14 + iVar2),*(void **)(&stack0xffffff18 + iVar2),
           *(size_t *)((int)&stack0xffffff1c + iVar2));
    *(struct_parts **)(&stack0xffffff18 + iVar2) = &related;
    *(char **)(&stack0xffffff14 + iVar2) = rel;
    *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ff2cb;
    scan(*(char **)(&stack0xffffff14 + iVar2),*(struct_parts **)(&stack0xffffff18 + iVar2));
  }
  else {
    related.access = (char *)0x0;
    related.host = (char *)0x0;
    related.absolute = (char *)0x0;
    related.relative = (char *)0x0;
    related.search = (char *)0x0;
    related.anchor = (char *)0x0;
  }
  pcVar1 = given.access;
  if (((given.access != (char *)0x0) && (given.host != (char *)0x0)) &&
     ((given.relative == (char *)0x0 && (given.absolute == (char *)0x0)))) {
    *(undefined **)(&stack0xffffff18 + iVar2) = &DAT_0817eafe;
    *(char **)(&stack0xffffff14 + iVar2) = pcVar1;
    *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ff2fa;
    iVar5 = strcmp(*(char **)(&stack0xffffff14 + iVar2),*(char **)(&stack0xffffff18 + iVar2));
    pcVar1 = given.access;
    if (iVar5 != 0) {
      *(char **)(&stack0xffffff18 + iVar2) = "https";
      *(char **)(&stack0xffffff14 + iVar2) = pcVar1;
      *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ff311;
      iVar5 = strcmp(*(char **)(&stack0xffffff14 + iVar2),*(char **)(&stack0xffffff18 + iVar2));
      pcVar1 = given.access;
      if (iVar5 != 0) {
        *(undefined **)(&stack0xffffff18 + iVar2) = &DAT_0817eb09;
        *(char **)(&stack0xffffff14 + iVar2) = pcVar1;
        *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ff328;
        iVar5 = strcmp(*(char **)(&stack0xffffff14 + iVar2),*(char **)(&stack0xffffff18 + iVar2));
        if (iVar5 != 0) goto LAB_080ff333;
      }
    }
    given.absolute = HTParse::empty_string;
  }
LAB_080ff333:
  if (given.access == (char *)0x0) {
    local_a0 = related.access;
  }
  else {
    local_a0 = given.access;
  }
  acc_method = local_a0;
  if (((wanted & 0x10U) != 0) && (local_a0 != (char *)0x0)) {
    *(char **)(&stack0xffffff18 + iVar2) = local_a0;
    *(char **)(&stack0xffffff14 + iVar2) = tail;
    *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ff379;
    strcpy(*(char **)(&stack0xffffff14 + iVar2),*(char **)(&stack0xffffff18 + iVar2));
    *(char **)(&stack0xffffff14 + iVar2) = tail;
    *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ff384;
    sVar4 = strlen(*(char **)(&stack0xffffff14 + iVar2));
    pcVar1 = tail + sVar4;
    tail = pcVar1;
    if ((wanted & 1U) != 0) {
      *pcVar1 = ':';
      tail = pcVar1 + 1;
      pcVar1[1] = '\0';
    }
  }
  if ((given.access != (char *)0x0) && (related.access != (char *)0x0)) {
    *(char **)(&stack0xffffff18 + iVar2) = related.access;
    *(char **)(&stack0xffffff14 + iVar2) = given.access;
    *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ff3c1;
    iVar5 = strcmp(*(char **)(&stack0xffffff14 + iVar2),*(char **)(&stack0xffffff18 + iVar2));
    if (iVar5 != 0) {
      related.host = (char *)0x0;
      related.absolute = (char *)0x0;
      related.relative = (char *)0x0;
      related.search = (char *)0x0;
      related.anchor = (char *)0x0;
    }
  }
  if (((wanted & 8U) != 0) && ((given.host != (char *)0x0 || (related.host != (char *)0x0)))) {
    if ((wanted & 1U) != 0) {
      *tail = '/';
      tail[1] = '/';
      tail = tail + 2;
    }
    if (given.host == (char *)0x0) {
      local_9c = related.host;
    }
    else {
      local_9c = given.host;
    }
    *(char **)(&stack0xffffff18 + iVar2) = local_9c;
    *(char **)(&stack0xffffff14 + iVar2) = tail;
    *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ff456;
    strcpy(*(char **)(&stack0xffffff14 + iVar2),*(char **)(&stack0xffffff18 + iVar2));
    *(undefined4 *)(&stack0xffffff18 + iVar2) = 0x40;
    *(char **)(&stack0xffffff14 + iVar2) = result;
    *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ff469;
    p2 = strchr(*(char **)(&stack0xffffff14 + iVar2),*(int *)(&stack0xffffff18 + iVar2));
    if (p2 != (char *)0x0) {
      tail = p2 + 1;
    }
    *(int **)(&stack0xffffff18 + iVar2) = &portnumber;
    *(char **)(&stack0xffffff14 + iVar2) = result;
    *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ff48d;
    p2 = HTParsePort(*(char **)(&stack0xffffff14 + iVar2),*(int **)(&stack0xffffff18 + iVar2));
    if ((p2 != (char *)0x0) && (acc_method != (char *)0x0)) {
      *(undefined **)(&stack0xffffff18 + iVar2) = &DAT_0817eafe;
      *(char **)(&stack0xffffff14 + iVar2) = acc_method;
      *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ff4b7;
      iVar5 = strcmp(*(char **)(&stack0xffffff14 + iVar2),*(char **)(&stack0xffffff18 + iVar2));
      if ((iVar5 != 0) || (portnumber != 0x50)) {
        *(char **)(&stack0xffffff18 + iVar2) = "https";
        *(char **)(&stack0xffffff14 + iVar2) = acc_method;
        *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ff4da;
        iVar5 = strcmp(*(char **)(&stack0xffffff14 + iVar2),*(char **)(&stack0xffffff18 + iVar2));
        if ((iVar5 != 0) || (portnumber != 0x1bb)) {
          *(char **)(&stack0xffffff18 + iVar2) = "gopher";
          *(char **)(&stack0xffffff14 + iVar2) = acc_method;
          *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ff4ff;
          iVar5 = strcmp(*(char **)(&stack0xffffff14 + iVar2),*(char **)(&stack0xffffff18 + iVar2));
          if ((iVar5 != 0) || (portnumber != 0x46)) {
            *(undefined **)(&stack0xffffff18 + iVar2) = &DAT_0817eb09;
            *(char **)(&stack0xffffff14 + iVar2) = acc_method;
            *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ff522;
            iVar5 = strcmp(*(char **)(&stack0xffffff14 + iVar2),*(char **)(&stack0xffffff18 + iVar2)
                          );
            if ((iVar5 != 0) || (portnumber != 0x15)) {
              *(undefined **)(&stack0xffffff18 + iVar2) = &DAT_0817eb14;
              *(char **)(&stack0xffffff14 + iVar2) = acc_method;
              *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ff545;
              iVar5 = strcmp(*(char **)(&stack0xffffff14 + iVar2),
                             *(char **)(&stack0xffffff18 + iVar2));
              if ((iVar5 != 0) || (portnumber != 0xd2)) {
                *(undefined **)(&stack0xffffff18 + iVar2) = &DAT_0817ea31;
                *(char **)(&stack0xffffff14 + iVar2) = acc_method;
                *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ff56a;
                iVar5 = strcmp(*(char **)(&stack0xffffff14 + iVar2),
                               *(char **)(&stack0xffffff18 + iVar2));
                if ((iVar5 != 0) || (portnumber != 0x77)) {
                  *(undefined **)(&stack0xffffff18 + iVar2) = &DAT_0817ea3c;
                  *(char **)(&stack0xffffff14 + iVar2) = acc_method;
                  *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ff58d;
                  iVar5 = strcmp(*(char **)(&stack0xffffff14 + iVar2),
                                 *(char **)(&stack0xffffff18 + iVar2));
                  if ((iVar5 != 0) || (portnumber != 0x77)) {
                    *(char **)(&stack0xffffff18 + iVar2) = "newspost";
                    *(char **)(&stack0xffffff14 + iVar2) = acc_method;
                    *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ff5b0;
                    iVar5 = strcmp(*(char **)(&stack0xffffff14 + iVar2),
                                   *(char **)(&stack0xffffff18 + iVar2));
                    if ((iVar5 != 0) || (portnumber != 0x77)) {
                      *(char **)(&stack0xffffff18 + iVar2) = "newsreply";
                      *(char **)(&stack0xffffff14 + iVar2) = acc_method;
                      *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ff5d3;
                      iVar5 = strcmp(*(char **)(&stack0xffffff14 + iVar2),
                                     *(char **)(&stack0xffffff18 + iVar2));
                      if ((iVar5 != 0) || (portnumber != 0x77)) {
                        *(char **)(&stack0xffffff18 + iVar2) = "snews";
                        *(char **)(&stack0xffffff14 + iVar2) = acc_method;
                        *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ff5f6;
                        iVar5 = strcmp(*(char **)(&stack0xffffff14 + iVar2),
                                       *(char **)(&stack0xffffff18 + iVar2));
                        if ((iVar5 != 0) || (portnumber != 0x233)) {
                          *(char **)(&stack0xffffff18 + iVar2) = "snewspost";
                          *(char **)(&stack0xffffff14 + iVar2) = acc_method;
                          *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ff61b;
                          iVar5 = strcmp(*(char **)(&stack0xffffff14 + iVar2),
                                         *(char **)(&stack0xffffff18 + iVar2));
                          if ((iVar5 != 0) || (portnumber != 0x233)) {
                            *(char **)(&stack0xffffff18 + iVar2) = "snewsreply";
                            *(char **)(&stack0xffffff14 + iVar2) = acc_method;
                            *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ff640;
                            iVar5 = strcmp(*(char **)(&stack0xffffff14 + iVar2),
                                           *(char **)(&stack0xffffff18 + iVar2));
                            if ((iVar5 != 0) || (portnumber != 0x233)) {
                              *(char **)(&stack0xffffff18 + iVar2) = "finger";
                              *(char **)(&stack0xffffff14 + iVar2) = acc_method;
                              *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ff665;
                              iVar5 = strcmp(*(char **)(&stack0xffffff14 + iVar2),
                                             *(char **)(&stack0xffffff18 + iVar2));
                              if ((iVar5 != 0) || (portnumber != 0x4f)) {
                                *(char **)(&stack0xffffff18 + iVar2) = "telnet";
                                *(char **)(&stack0xffffff14 + iVar2) = acc_method;
                                *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ff684;
                                iVar5 = strcmp(*(char **)(&stack0xffffff14 + iVar2),
                                               *(char **)(&stack0xffffff18 + iVar2));
                                if ((iVar5 != 0) || (portnumber != 0x17)) {
                                  *(char **)(&stack0xffffff18 + iVar2) = "tn3270";
                                  *(char **)(&stack0xffffff14 + iVar2) = acc_method;
                                  *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ff6a3;
                                  iVar5 = strcmp(*(char **)(&stack0xffffff14 + iVar2),
                                                 *(char **)(&stack0xffffff18 + iVar2));
                                  if ((iVar5 != 0) || (portnumber != 0x17)) {
                                    *(char **)(&stack0xffffff18 + iVar2) = "rlogin";
                                    *(char **)(&stack0xffffff14 + iVar2) = acc_method;
                                    *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ff6c2;
                                    iVar5 = strcmp(*(char **)(&stack0xffffff14 + iVar2),
                                                   *(char **)(&stack0xffffff18 + iVar2));
                                    if ((iVar5 != 0) || (portnumber != 0x201)) {
                                      *(undefined **)(&stack0xffffff18 + iVar2) = &DAT_0817eb5d;
                                      *(char **)(&stack0xffffff14 + iVar2) = acc_method;
                                      *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ff6e3;
                                      iVar5 = strcmp(*(char **)(&stack0xffffff14 + iVar2),
                                                     *(char **)(&stack0xffffff18 + iVar2));
                                      if ((iVar5 != 0) || (portnumber != 0x69)) goto LAB_080ff6f5;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      *p2 = '\0';
    }
LAB_080ff6f5:
    if (p2 == (char *)0x0) {
      *(char **)(&stack0xffffff14 + iVar2) = tail;
      *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ff706;
      sVar4 = strlen(*(char **)(&stack0xffffff14 + iVar2));
      if (0 < (int)sVar4) {
        h = tail + (sVar4 - 1);
        if (*h == '.') {
          *h = '\0';
        }
      }
    }
    else if ((p2 != result) && (h = p2 + -1, p2[-1] == '.')) {
      for (; *p2 != '\0'; p2 = p2 + 1) {
        *h = *p2;
        h = h + 1;
      }
      *h = '\0';
    }
  }
  *(char **)(&stack0xffffff14 + iVar2) = result;
  *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ff779;
  tail = LYRemoveBlanks(*(char **)(&stack0xffffff14 + iVar2));
  if ((given.search == (char *)0x0) || (given.search[-1] != '\0')) {
    if ((related.search != (char *)0x0) &&
       ((related.absolute == (char *)0x0 && (related.search[-1] == '\0')))) {
      related.absolute = related.search + -1;
      related.search[-1] = '?';
    }
  }
  else {
    given.absolute = given.search + -1;
    given.search[-1] = '?';
  }
  if ((given.host != (char *)0x0) && (related.host != (char *)0x0)) {
    *(char **)(&stack0xffffff18 + iVar2) = related.host;
    *(char **)(&stack0xffffff14 + iVar2) = given.host;
    *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ff7eb;
    iVar5 = strcmp(*(char **)(&stack0xffffff14 + iVar2),*(char **)(&stack0xffffff18 + iVar2));
    if (iVar5 != 0) {
      related.absolute = (char *)0x0;
      related.relative = (char *)0x0;
      related.anchor = (char *)0x0;
    }
  }
  if ((wanted & 100U) == 0) goto LAB_080ffc76;
  want_detail = wanted & 0x60;
  if (((acc_method != (char *)0x0) && (given.absolute == (char *)0x0)) &&
     (given.relative != (char *)0x0)) {
    local_98 = (int)*acc_method;
    if (local_98 == 0x53) {
LAB_080ff8e1:
      *(char **)(&stack0xffffff18 + iVar2) = "snews";
      *(char **)(&stack0xffffff14 + iVar2) = acc_method;
      *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ff8f4;
      iVar5 = strcasecomp(*(char **)(&stack0xffffff14 + iVar2),*(char **)(&stack0xffffff18 + iVar2))
      ;
      if (iVar5 == 0) {
        given.absolute = given.relative;
        given.relative = (char *)0x0;
      }
    }
    else if (local_98 < 0x54) {
      if (local_98 == 0x4e) {
LAB_080ff885:
        *(undefined **)(&stack0xffffff18 + iVar2) = &DAT_0817ea31;
        *(char **)(&stack0xffffff14 + iVar2) = acc_method;
        *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ff898;
        iVar5 = strcasecomp(*(char **)(&stack0xffffff14 + iVar2),
                            *(char **)(&stack0xffffff18 + iVar2));
        if (iVar5 == 0) {
LAB_080ff8d2:
          given.absolute = given.relative;
          given.relative = (char *)0x0;
        }
        else {
          *(undefined **)(&stack0xffffff18 + iVar2) = &DAT_0817ea3c;
          *(char **)(&stack0xffffff14 + iVar2) = acc_method;
          *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ff8af;
          iVar5 = strcasecomp(*(char **)(&stack0xffffff14 + iVar2),
                              *(char **)(&stack0xffffff18 + iVar2));
          if (iVar5 == 0) {
            *(undefined4 *)((int)&stack0xffffff1c + iVar2) = 7;
            *(char **)(&stack0xffffff18 + iVar2) = "news://";
            *(char **)(&stack0xffffff14 + iVar2) = result;
            *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ff8ce;
            iVar5 = strncasecomp(*(char **)(&stack0xffffff14 + iVar2),
                                 *(char **)(&stack0xffffff18 + iVar2),
                                 *(int *)((int)&stack0xffffff1c + iVar2));
            if (iVar5 == 0) goto LAB_080ff8d2;
          }
        }
      }
    }
    else {
      if (local_98 == 0x6e) goto LAB_080ff885;
      if (local_98 == 0x73) goto LAB_080ff8e1;
    }
  }
  if (given.absolute == (char *)0x0) {
    if (related.absolute == (char *)0x0) {
      if (given.relative == (char *)0x0) {
        if (related.relative == (char *)0x0) {
          if ((*aName_local == 'l') || (*aName_local == 'L')) {
            *(undefined4 *)((int)&stack0xffffff1c + iVar2) = 8;
            *(char **)(&stack0xffffff18 + iVar2) = "lynxcgi:";
            *(char **)(&stack0xffffff14 + iVar2) = aName_local;
            *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ffb6a;
            iVar5 = strncasecomp(*(char **)(&stack0xffffff14 + iVar2),
                                 *(char **)(&stack0xffffff18 + iVar2),
                                 *(int *)((int)&stack0xffffff1c + iVar2));
            if (iVar5 != 0) goto LAB_080ffb72;
          }
          else {
LAB_080ffb72:
            if ((*aName_local == 'l') || (*aName_local == 'L')) {
              *(undefined4 *)((int)&stack0xffffff1c + iVar2) = 9;
              *(char **)(&stack0xffffff18 + iVar2) = "lynxexec:";
              *(char **)(&stack0xffffff14 + iVar2) = aName_local;
              *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ffbaa;
              iVar5 = strncasecomp(*(char **)(&stack0xffffff14 + iVar2),
                                   *(char **)(&stack0xffffff18 + iVar2),
                                   *(int *)((int)&stack0xffffff1c + iVar2));
              if (iVar5 == 0) goto LAB_080ffbfa;
            }
            if ((*aName_local == 'l') || (*aName_local == 'L')) {
              *(undefined4 *)((int)&stack0xffffff1c + iVar2) = 9;
              *(char **)(&stack0xffffff18 + iVar2) = "lynxprog:";
              *(char **)(&stack0xffffff14 + iVar2) = aName_local;
              *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ffbe6;
              iVar5 = strncasecomp(*(char **)(&stack0xffffff14 + iVar2),
                                   *(char **)(&stack0xffffff18 + iVar2),
                                   *(int *)((int)&stack0xffffff1c + iVar2));
              if (iVar5 == 0) goto LAB_080ffbfa;
            }
            *tail = '/';
            tail = tail + 1;
            *tail = '\0';
          }
LAB_080ffbfa:
          *(char **)(&stack0xffffff18 + iVar2) = "news:/";
          *(char **)(&stack0xffffff14 + iVar2) = result;
          *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ffc0d;
          iVar5 = strcmp(*(char **)(&stack0xffffff14 + iVar2),*(char **)(&stack0xffffff18 + iVar2));
          if (iVar5 == 0) {
            result[5] = '*';
          }
          if (WWW_TraceFlag != '\0') {
            *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ffc2a;
            pFVar3 = TraceFP();
            *(char **)(&stack0xffffff18 + iVar2) = "HTParse: (No inheritance)\n";
            *(FILE **)(&stack0xffffff14 + iVar2) = pFVar3;
            *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ffc3a;
            fprintf(*(FILE **)(&stack0xffffff14 + iVar2),*(char **)(&stack0xffffff18 + iVar2));
          }
        }
        else {
          *(char **)(&stack0xffffff18 + iVar2) = related.relative;
          *(char **)(&stack0xffffff14 + iVar2) = tail;
          *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ffb07;
          strcpy(*(char **)(&stack0xffffff14 + iVar2),*(char **)(&stack0xffffff18 + iVar2));
          if (WWW_TraceFlag != '\0') {
            *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ffb1b;
            pFVar3 = TraceFP();
            *(char **)(&stack0xffffff18 + iVar2) = "HTParse: (Related-REL)\n";
            *(FILE **)(&stack0xffffff14 + iVar2) = pFVar3;
            *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ffb2b;
            fprintf(*(FILE **)(&stack0xffffff14 + iVar2),*(char **)(&stack0xffffff18 + iVar2));
          }
        }
      }
      else {
        *(char **)(&stack0xffffff18 + iVar2) = given.relative;
        *(char **)(&stack0xffffff14 + iVar2) = tail;
        *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ffac3;
        strcpy(*(char **)(&stack0xffffff14 + iVar2),*(char **)(&stack0xffffff18 + iVar2));
        if (WWW_TraceFlag != '\0') {
          *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ffad7;
          pFVar3 = TraceFP();
          *(char **)(&stack0xffffff18 + iVar2) = "HTParse: (REL)\n";
          *(FILE **)(&stack0xffffff14 + iVar2) = pFVar3;
          *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ffae7;
          fprintf(*(FILE **)(&stack0xffffff14 + iVar2),*(char **)(&stack0xffffff18 + iVar2));
        }
      }
    }
    else {
      base = tail;
      *tail = '/';
      tail = tail + 1;
      *(char **)(&stack0xffffff18 + iVar2) = related.absolute;
      *(char **)(&stack0xffffff14 + iVar2) = tail;
      *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ff98a;
      strcpy(*(char **)(&stack0xffffff14 + iVar2),*(char **)(&stack0xffffff18 + iVar2));
      pcVar1 = given.relative;
      if (given.relative != (char *)0x0) {
        if (*given.relative == ';') {
          *(undefined4 *)(&stack0xffffff18 + iVar2) = 0x3b;
          *(char **)(&stack0xffffff14 + iVar2) = tail;
          *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ff9b5;
          pcVar6 = strchr_or_end(*(char **)(&stack0xffffff14 + iVar2),
                                 *(int *)(&stack0xffffff18 + iVar2));
          *(char **)(&stack0xffffff18 + iVar2) = pcVar1;
          *(char **)(&stack0xffffff14 + iVar2) = pcVar6;
          *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ff9c1;
          strcpy(*(char **)(&stack0xffffff14 + iVar2),*(char **)(&stack0xffffff18 + iVar2));
        }
        else if (*given.relative == '?') {
          *(undefined4 *)(&stack0xffffff18 + iVar2) = 0x3f;
          *(char **)(&stack0xffffff14 + iVar2) = tail;
          *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ff9e6;
          pcVar6 = strchr_or_end(*(char **)(&stack0xffffff14 + iVar2),
                                 *(int *)(&stack0xffffff18 + iVar2));
          *(char **)(&stack0xffffff18 + iVar2) = pcVar1;
          *(char **)(&stack0xffffff14 + iVar2) = pcVar6;
          *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ff9f2;
          strcpy(*(char **)(&stack0xffffff14 + iVar2),*(char **)(&stack0xffffff18 + iVar2));
        }
        else {
          *(undefined4 *)(&stack0xffffff18 + iVar2) = 0x3f;
          *(char **)(&stack0xffffff14 + iVar2) = tail;
          *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ffa07;
          p = strchr(*(char **)(&stack0xffffff14 + iVar2),*(int *)(&stack0xffffff18 + iVar2));
          if (p == (char *)0x0) {
            *(char **)(&stack0xffffff14 + iVar2) = tail;
            *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ffa1b;
            sVar4 = strlen(*(char **)(&stack0xffffff14 + iVar2));
            p = tail + (sVar4 - 1);
          }
          for (; *p != '/'; p = p + -1) {
          }
          p[1] = '\0';
          *(char **)(&stack0xffffff18 + iVar2) = given.relative;
          *(char **)(&stack0xffffff14 + iVar2) = p;
          *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ffa4f;
          strcat(*(char **)(&stack0xffffff14 + iVar2),*(char **)(&stack0xffffff18 + iVar2));
        }
        *(char **)(&stack0xffffff14 + iVar2) = base;
        *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ffa5a;
        HTSimplify(*(char **)(&stack0xffffff14 + iVar2));
        if (*base == '\0') {
          *(undefined4 *)((int)&stack0xffffff1c + iVar2) = 2;
          *(undefined **)(&stack0xffffff18 + iVar2) = &DAT_0817eb79;
          *(char **)(&stack0xffffff14 + iVar2) = base;
          *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ffa7f;
          memcpy(*(void **)(&stack0xffffff14 + iVar2),*(void **)(&stack0xffffff18 + iVar2),
                 *(size_t *)((int)&stack0xffffff1c + iVar2));
        }
      }
      if (WWW_TraceFlag != '\0') {
        *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ffa93;
        pFVar3 = TraceFP();
        *(char **)(&stack0xffffff18 + iVar2) = "HTParse: (Related-ABS)\n";
        *(FILE **)(&stack0xffffff14 + iVar2) = pFVar3;
        *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ffaa3;
        fprintf(*(FILE **)(&stack0xffffff14 + iVar2),*(char **)(&stack0xffffff18 + iVar2));
      }
    }
  }
  else {
    if ((wanted & 1U) != 0) {
      *tail = '/';
      tail = tail + 1;
    }
    *(char **)(&stack0xffffff18 + iVar2) = given.absolute;
    *(char **)(&stack0xffffff14 + iVar2) = tail;
    *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ff932;
    strcpy(*(char **)(&stack0xffffff14 + iVar2),*(char **)(&stack0xffffff18 + iVar2));
    if (WWW_TraceFlag != '\0') {
      *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ff946;
      pFVar3 = TraceFP();
      *(char **)(&stack0xffffff18 + iVar2) = "HTParse: (ABS)\n";
      *(FILE **)(&stack0xffffff14 + iVar2) = pFVar3;
      *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ff956;
      fprintf(*(FILE **)(&stack0xffffff14 + iVar2),*(char **)(&stack0xffffff18 + iVar2));
    }
  }
  if (want_detail != 0) {
    *(undefined4 *)(&stack0xffffff18 + iVar2) = 0x3f;
    *(char **)(&stack0xffffff14 + iVar2) = tail;
    *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ffc55;
    p = strchr(*(char **)(&stack0xffffff14 + iVar2),*(int *)(&stack0xffffff18 + iVar2));
    if (p == (char *)0x0) {
      if ((wanted & 0x40U) != 0) {
        *tail = '\0';
      }
    }
    else {
      *p = '\0';
    }
  }
LAB_080ffc76:
  if ((((wanted & 2U) != 0) && (given.anchor != (char *)0x0)) && (*given.anchor != '\0')) {
    *(char **)(&stack0xffffff14 + iVar2) = tail;
    *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ffc9c;
    sVar4 = strlen(*(char **)(&stack0xffffff14 + iVar2));
    tail = tail + sVar4;
    if ((wanted & 1U) != 0) {
      *tail = '#';
      tail = tail + 1;
    }
    *(char **)(&stack0xffffff18 + iVar2) = given.anchor;
    *(char **)(&stack0xffffff14 + iVar2) = tail;
    *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ffcc5;
    strcpy(*(char **)(&stack0xffffff14 + iVar2),*(char **)(&stack0xffffff18 + iVar2));
  }
  *(undefined4 *)(&stack0xffffff18 + iVar2) = 0x20;
  *(char **)(&stack0xffffff14 + iVar2) = result;
  *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ffcd8;
  p = strchr(*(char **)(&stack0xffffff14 + iVar2),*(int *)(&stack0xffffff18 + iVar2));
  if (p != (char *)0x0) {
    *(char **)(&stack0xffffff14 + iVar2) = result;
    *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ffcf0;
    local_94 = is_url(*(char **)(&stack0xffffff14 + iVar2));
    switch(local_94) {
    default:
      if (WWW_TraceFlag != '\0') {
        *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ffd82;
        pFVar3 = TraceFP();
        *(char **)((int)&stack0xffffff1c + iVar2) = result;
        *(char **)(&stack0xffffff18 + iVar2) = "HTParse:      encode:`%s\'\n";
        *(FILE **)(&stack0xffffff14 + iVar2) = pFVar3;
        *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ffd99;
        fprintf(*(FILE **)(&stack0xffffff14 + iVar2),*(char **)(&stack0xffffff18 + iVar2));
      }
      do {
        *(char **)(&stack0xffffff14 + iVar2) = p;
        *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ffda6;
        sVar4 = strlen(*(char **)(&stack0xffffff14 + iVar2));
        for (q = p + sVar4 + 2; p + 1 != q; q = q + -1) {
          *q = q[-2];
        }
        *p = '%';
        p[1] = '2';
        p[2] = '0';
        *(undefined4 *)(&stack0xffffff18 + iVar2) = 0x20;
        *(char **)(&stack0xffffff14 + iVar2) = result;
        *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ffdf9;
        p = strchr(*(char **)(&stack0xffffff14 + iVar2),*(int *)(&stack0xffffff18 + iVar2));
      } while (p != (char *)0x0);
      break;
    case UNKNOWN_URL_TYPE:
      if (WWW_TraceFlag != '\0') {
        *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ffd22;
        pFVar3 = TraceFP();
        *(char **)((int)&stack0xffffff1c + iVar2) = result;
        *(char **)(&stack0xffffff18 + iVar2) = "HTParse:      ignore:`%s\'\n";
        *(FILE **)(&stack0xffffff14 + iVar2) = pFVar3;
        *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ffd39;
        fprintf(*(FILE **)(&stack0xffffff14 + iVar2),*(char **)(&stack0xffffff18 + iVar2));
      }
      break;
    case LYNXCGI_URL_TYPE:
    case LYNXEXEC_URL_TYPE:
    case LYNXPROG_URL_TYPE:
    case LYNXCACHE_URL_TYPE:
    case LYNXCFG_URL_TYPE:
    case LYNXCOMPILE_OPTS_URL_TYPE:
    case LYNXCOOKIE_URL_TYPE:
    case LYNXDIRED_URL_TYPE:
    case LYNXDOWNLOAD_URL_TYPE:
    case LYNXHIST_URL_TYPE:
    case LYNXIMGMAP_URL_TYPE:
    case LYNXKEYMAP_URL_TYPE:
    case LYNXMESSAGES_URL_TYPE:
    case LYNXOPTIONS_URL_TYPE:
    case LYNXPRINT_URL_TYPE:
      if (WWW_TraceFlag != '\0') {
        *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ffd54;
        pFVar3 = TraceFP();
        *(char **)((int)&stack0xffffff1c + iVar2) = result;
        *(char **)(&stack0xffffff18 + iVar2) = "HTParse:      spaces:`%s\'\n";
        *(FILE **)(&stack0xffffff14 + iVar2) = pFVar3;
        *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ffd6b;
        fprintf(*(FILE **)(&stack0xffffff14 + iVar2),*(char **)(&stack0xffffff18 + iVar2));
      }
    }
  }
  if (WWW_TraceFlag != '\0') {
    *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ffe12;
    pFVar3 = TraceFP();
    *(char **)((int)&stack0xffffff1c + iVar2) = result;
    *(char **)(&stack0xffffff18 + iVar2) = "HTParse:      result:`%s\'\n";
    *(FILE **)(&stack0xffffff14 + iVar2) = pFVar3;
    *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ffe29;
    fprintf(*(FILE **)(&stack0xffffff14 + iVar2),*(char **)(&stack0xffffff18 + iVar2));
  }
  *(char **)(&stack0xffffff18 + iVar2) = result;
  *(char ***)(&stack0xffffff14 + iVar2) = &return_value;
  *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ffe3d;
  HTSACopy(*(char ***)(&stack0xffffff14 + iVar2),*(char **)(&stack0xffffff18 + iVar2));
  if ((*relatedName_local != '\0') && ((wanted & 0x1dU) == 0x1d)) {
    *(char **)(&stack0xffffff18 + iVar2) = relatedName_local;
    *(char ***)(&stack0xffffff14 + iVar2) = &return_value;
    *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ffe6a;
    LYFillLocalFileURL(*(char ***)(&stack0xffffff14 + iVar2),*(char **)(&stack0xffffff18 + iVar2));
    pcVar1 = return_value;
    if (WWW_TraceFlag != '\0') {
      *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ffe7d;
      pFVar3 = TraceFP();
      *(char **)((int)&stack0xffffff1c + iVar2) = pcVar1;
      *(char **)(&stack0xffffff18 + iVar2) = "pass LYFillLocalFile:`%s\'\n";
      *(FILE **)(&stack0xffffff14 + iVar2) = pFVar3;
      *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ffe91;
      fprintf(*(FILE **)(&stack0xffffff14 + iVar2),*(char **)(&stack0xffffff18 + iVar2));
    }
  }
  if (local_c != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    *(undefined4 *)((int)&pcStack_f0 + iVar2) = 0x80ffea7;
    __stack_chk_fail();
  }
  return return_value;
}



char * HTParseAnchor(char *aName)

{
  int iVar1;
  size_t sVar2;
  undefined *puVar3;
  int in_GS_OFFSET;
  struct_parts *psStackY_50;
  char *local_40;
  char *aName_local;
  struct_parts given;
  char *name;
  char *p;
  int local_c;
  
  aName_local = aName;
  local_c = *(int *)(in_GS_OFFSET + 0x14);
  for (p = aName; (*p != '\0' && (*p != '#')); p = p + 1) {
  }
  puVar3 = &stack0xffffffb4;
  if (*p == '#') {
    psStackY_50 = (struct_parts *)0x80fff0b;
    sVar2 = strlen(p);
    iVar1 = -((uint)(p + (sVar2 - (int)aName) + 0x1f) & 0xfffffff0);
    name = (char *)((int)&local_40 + iVar1);
    local_40 = name;
    if (name == (char *)0x0) {
      *(char **)(&stack0xffffffb8 + iVar1) = "HTParseAnchor";
      *(char **)(&stack0xffffffb4 + iVar1) = "../../../WWW/Library/Implementation/HTParse.c";
      *(undefined4 *)((int)&psStackY_50 + iVar1) = 0x80fff55;
      outofmem(*(char **)(&stack0xffffffb4 + iVar1),*(char **)(&stack0xffffffb8 + iVar1));
    }
    *(char **)(&stack0xffffffb8 + iVar1) = aName_local;
    *(char **)(&stack0xffffffb4 + iVar1) = name;
    *(undefined4 *)((int)&psStackY_50 + iVar1) = 0x80fff67;
    strcpy(*(char **)(&stack0xffffffb4 + iVar1),*(char **)(&stack0xffffffb8 + iVar1));
    *(struct_parts **)(&stack0xffffffb8 + iVar1) = &given;
    *(char **)(&stack0xffffffb4 + iVar1) = name;
    *(undefined4 *)((int)&psStackY_50 + iVar1) = 0x80fff79;
    scan(*(char **)(&stack0xffffffb4 + iVar1),*(struct_parts **)(&stack0xffffffb8 + iVar1));
    p = p + 1;
    puVar3 = &stack0xffffffb4 + iVar1;
    if (given.anchor == (char *)0x0) {
      for (; puVar3 = &stack0xffffffb4 + iVar1, *p != '\0'; p = p + 1) {
      }
    }
  }
  if (local_c == *(int *)(in_GS_OFFSET + 0x14)) {
    return p;
  }
                    // WARNING: Subroutine does not return
  *(undefined4 *)(puVar3 + -4) = 0x80fffa8;
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void HTSimplify(char *filename)

{
  char *pcVar1;
  char *pcVar2;
  int iVar3;
  char *q1;
  char *q;
  char *p;
  
  if ((((((filename != (char *)0x0) && (*filename != '\0')) && (filename[1] != '\0')) &&
       ((*filename != '?' && (filename[1] != '?')))) && (filename[2] != '?')) &&
     (pcVar2 = strchr(filename,0x2f), pcVar2 != (char *)0x0)) {
    for (p = filename + 2; (*p != '\0' && (*p != '?')); p = p + 1) {
      if (*p == '/') {
        if (((p[1] == '.') && (p[2] == '.')) &&
           ((pcVar2 = p, p[3] == '/' || ((p[3] == '?' || (p[3] == '\0')))))) {
          do {
            pcVar1 = pcVar2;
            q = pcVar1 + -1;
            if (q < filename) break;
            pcVar2 = q;
          } while (*q != '/');
          if ((((*q == '/') && (iVar3 = strncmp(q,"/../",4), iVar3 != 0)) &&
              (iVar3 = strncmp(q,"/..?",4), iVar3 != 0)) &&
             ((pcVar1 + -2 <= filename || (pcVar1[-2] != '/')))) {
            q1 = p + 3;
            p = q;
            for (; *q1 != '\0'; q1 = q1 + 1) {
              *p = *q1;
              p = p + 1;
            }
            *p = '\0';
            p = pcVar1 + -2;
          }
        }
        else if ((p[1] == '.') && (p[2] == '/')) {
          q = p;
          for (q1 = p + 2; *q1 != '\0'; q1 = q1 + 1) {
            *q = *q1;
            q = q + 1;
          }
          *q = '\0';
          p = p + -1;
        }
        else if ((p[1] == '.') && (p[2] == '?')) {
          q = p;
          for (q1 = p + 2; q = q + 1, *q1 != '\0'; q1 = q1 + 1) {
            *q = *q1;
          }
          *q = '\0';
          p = p + -1;
        }
        else if ((p[1] == '.') && (p[2] == '\0')) {
          p[1] = '\0';
        }
      }
    }
    if (((filename + 2 <= p) && (*p == '?')) && (p[-1] == '.')) {
      if (p[-2] == '/') {
        q = p + -1;
        for (q1 = p; *q1 != '\0'; q1 = q1 + 1) {
          *q = *q1;
          q = q + 1;
        }
        *q = '\0';
      }
      else if ((((p[-2] == '.') && (filename + 4 <= p)) && (p[-3] == '/')) &&
              ((p[-4] != '/' || ((filename + 4 < p && (p[-5] != ':')))))) {
        for (q = p + -4; (filename < q && (*q != '/')); q = q + -1) {
        }
        if (*q == '/') {
          if ((filename < q) && (q[-1] == '/')) {
            if (q <= filename + 1) {
              return;
            }
            if (q[-1] == ':') {
              return;
            }
          }
          q = q + 1;
        }
        iVar3 = strncmp(q,"../",3);
        if ((iVar3 != 0) && (iVar3 = strncmp(q,"./",2), iVar3 != 0)) {
          q1 = p;
          p = q;
          for (; *q1 != '\0'; q1 = q1 + 1) {
            *p = *q1;
            p = p + 1;
          }
          *p = '\0';
        }
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

char * HTRelative(char *aName,char *relatedName)

{
  char *pcVar1;
  size_t sVar2;
  FILE *__stream;
  int levels;
  int slashes;
  char *last_slash;
  char *path;
  char *after_access;
  char *q;
  char *p;
  char *result;
  
  result = (char *)0x0;
  q = relatedName;
  after_access = (char *)0x0;
  path = (char *)0x0;
  last_slash = (char *)0x0;
  slashes = 0;
  for (p = aName; (*p != '\0' && (*p == *q)); p = p + 1) {
    if (*p == ':') {
      after_access = p + 1;
    }
    if (*p == '/') {
      last_slash = p;
      slashes = slashes + 1;
      if (slashes == 3) {
        path = p;
      }
    }
    q = q + 1;
  }
  if (after_access == (char *)0x0) {
    HTSACopy(&result,aName);
  }
  else if (slashes < 3) {
    HTSACopy(&result,after_access);
  }
  else if (slashes == 3) {
    HTSACopy(&result,path);
  }
  else {
    levels = 0;
    for (; (*q != '\0' && (*q != '#')); q = q + 1) {
      if (*q == '/') {
        levels = levels + 1;
      }
    }
    sVar2 = strlen(last_slash);
    result = (char *)calloc(levels * 3 + sVar2 + 1,1);
    if (result == (char *)0x0) {
      outofmem("../../../WWW/Library/Implementation/HTParse.c","HTRelative");
    }
    *result = '\0';
    for (; levels != 0; levels = levels + -1) {
      strcat(result,"../");
    }
    strcat(result,last_slash + 1);
  }
  pcVar1 = result;
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"HTparse: `%s\' expressed relative to\n   `%s\' is\n   `%s\'.\n",aName,
            relatedName,pcVar1);
  }
  return result;
}



char * HTEscape(char *str,uchar mask)

{
  byte bVar1;
  char *pcVar2;
  uchar mask_local;
  uint unacceptable;
  char *result;
  char *q;
  char *p;
  uchar a;
  
  unacceptable = 0;
  for (p = str; *p != '\0'; p = p + 1) {
    if ((((byte)*p < 0x20) || (*p < '\0')) ||
       (("HTparse: `%s\' expressed relative to\n   `%s\' is\n   `%s\'.\n"[(byte)*p + 0x20] & mask)
        == 0)) {
      unacceptable = unacceptable + 1;
    }
  }
  pcVar2 = (char *)calloc((size_t)(p + (unacceptable * 2 - (int)str) + 1),1);
  if (pcVar2 == (char *)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTParse.c","HTEscape");
  }
  q = pcVar2;
  for (p = str; *p != '\0'; p = p + 1) {
    bVar1 = *p;
    if (((bVar1 < 0x20) || ((char)bVar1 < '\0')) ||
       (("HTparse: `%s\' expressed relative to\n   `%s\' is\n   `%s\'.\n"[bVar1 + 0x20] & mask) == 0
       )) {
      *q = '%';
      q[1] = hex[bVar1 >> 4];
      q[2] = hex[bVar1 & 0xf];
      q = q + 3;
    }
    else {
      *q = *p;
      q = q + 1;
    }
  }
  *q = '\0';
  return pcVar2;
}



// WARNING: Unknown calling convention

char * HTEscapeUnsafe(char *str)

{
  byte bVar1;
  char *pcVar2;
  uint unacceptable;
  char *result;
  char *q;
  char *p;
  uchar a;
  
  unacceptable = 0;
  for (p = str; *p != '\0'; p = p + 1) {
    if (((byte)*p < 0x21) || (0x7e < (byte)*p)) {
      unacceptable = unacceptable + 1;
    }
  }
  pcVar2 = (char *)calloc((size_t)(p + (unacceptable * 2 - (int)str) + 1),1);
  if (pcVar2 == (char *)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTParse.c","HTEscapeUnsafe");
  }
  q = pcVar2;
  for (p = str; *p != '\0'; p = p + 1) {
    bVar1 = *p;
    if ((bVar1 < 0x21) || (0x7e < bVar1)) {
      *q = '%';
      q[1] = hex[bVar1 >> 4];
      q[2] = hex[bVar1 & 0xf];
      q = q + 3;
    }
    else {
      *q = *p;
      q = q + 1;
    }
  }
  *q = '\0';
  return pcVar2;
}



char * HTEscapeSP(char *str,uchar mask)

{
  byte bVar1;
  char *pcVar2;
  uchar mask_local;
  uint unacceptable;
  char *result;
  char *q;
  char *p;
  uchar a;
  
  unacceptable = 0;
  for (p = str; *p != '\0'; p = p + 1) {
    if ((*p != ' ') &&
       ((((byte)*p < 0x20 || (*p < '\0')) ||
        (("HTparse: `%s\' expressed relative to\n   `%s\' is\n   `%s\'.\n"[(byte)*p + 0x20] & mask)
         == 0)))) {
      unacceptable = unacceptable + 1;
    }
  }
  pcVar2 = (char *)calloc((size_t)(p + (unacceptable * 2 - (int)str) + 1),1);
  if (pcVar2 == (char *)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTParse.c","HTEscape");
  }
  q = pcVar2;
  for (p = str; *p != '\0'; p = p + 1) {
    bVar1 = *p;
    if (bVar1 == 0x20) {
      *q = '+';
      q = q + 1;
    }
    else if (((bVar1 < 0x20) || ((char)bVar1 < '\0')) ||
            (("HTparse: `%s\' expressed relative to\n   `%s\' is\n   `%s\'.\n"[bVar1 + 0x20] & mask)
             == 0)) {
      *q = '%';
      q[1] = hex[bVar1 >> 4];
      q[2] = hex[bVar1 & 0xf];
      q = q + 3;
    }
    else {
      *q = *p;
      q = q + 1;
    }
  }
  *q = '\0';
  return pcVar2;
}



char from_hex(char c)

{
  char local_a;
  char local_9;
  char c_local;
  
  if ((c < '0') || ('9' < c)) {
    if ((c < 'A') || ('F' < c)) {
      local_9 = c + -0x57;
    }
    else {
      local_9 = c + -0x37;
    }
    local_a = local_9;
  }
  else {
    local_a = c + -0x30;
  }
  return local_a;
}



// WARNING: Unknown calling convention

char * HTUnEscape(char *str)

{
  char *pcVar1;
  char cVar2;
  char cVar3;
  ushort **ppuVar4;
  char *q;
  char *p;
  
  p = str;
  q = str;
  if ((str != (char *)0x0) && (*str != '\0')) {
    while (*p != '\0') {
      if ((((*p == '%') && (p[1] != '\0')) && (p[2] != '\0')) &&
         ((ppuVar4 = __ctype_b_loc(), ((*ppuVar4)[(byte)p[1]] & 0x1000) != 0 &&
          (ppuVar4 = __ctype_b_loc(), ((*ppuVar4)[(byte)p[2]] & 0x1000) != 0)))) {
        pcVar1 = p + 1;
        if (*pcVar1 != '\0') {
          cVar2 = from_hex(*pcVar1);
          *q = (char)((int)cVar2 << 4);
          pcVar1 = p + 2;
        }
        p = pcVar1;
        if (*p != '\0') {
          cVar2 = *q;
          cVar3 = *p;
          p = p + 1;
          cVar3 = from_hex(cVar3);
          *q = cVar2 + cVar3;
        }
        *q = *q;
        q = q + 1;
      }
      else {
        *q = *p;
        q = q + 1;
        p = p + 1;
      }
    }
    *q = '\0';
  }
  return str;
}



// WARNING: Unknown calling convention

char * HTUnEscapeSome(char *str,char *do_trans)

{
  char cVar1;
  char cVar2;
  ushort **ppuVar3;
  char *pcVar4;
  char *q;
  char *p;
  char testcode;
  
  p = str;
  q = str;
  if ((((str != (char *)0x0) && (*str != '\0')) && (do_trans != (char *)0x0)) && (*do_trans != '\0')
     ) {
    while (*p != '\0') {
      if (((*p == '%') && (p[1] != '\0')) &&
         ((p[2] != '\0' &&
          ((ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[(byte)p[1]] & 0x1000) != 0 &&
           (ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[(byte)p[2]] & 0x1000) != 0)))))) {
        cVar1 = from_hex(p[1]);
        cVar2 = from_hex(p[2]);
        cVar2 = cVar1 * '\x10' + cVar2;
        if ((cVar2 == '\0') || (pcVar4 = strchr(do_trans,(int)cVar2), pcVar4 == (char *)0x0))
        goto LAB_08100c87;
        *q = cVar2;
        q = q + 1;
        p = p + 3;
      }
      else {
LAB_08100c87:
        *q = *p;
        q = q + 1;
        p = p + 1;
      }
    }
    *q = '\0';
  }
  return str;
}



// WARNING: Unknown calling convention

void HTMake822Word(char **str,int quoted)

{
  char *pcVar1;
  byte bVar2;
  char *pcVar3;
  char *local_28;
  uint added;
  char *result;
  char *q;
  char *p;
  uchar a;
  
  added = 0;
  if ((*str == (char *)0x0) || (**str == '\0')) {
    if (quoted == 0) {
      local_28 = "";
    }
    else {
      local_28 = "\"\"";
    }
    HTSACopy(str,local_28);
  }
  else {
    for (p = *str; *p != '\0'; p = p + 1) {
      bVar2 = *p;
      if (((bVar2 < 0x20) || ((char)bVar2 < '\0')) || (("HTEscapeUnsafe"[bVar2 + 6] & 1U) != 0)) {
        if (added == 0) {
          added = 2;
        }
        if ((bVar2 < 0xa0) && (bVar2 != 9)) {
          if ((bVar2 == 0xd) || (bVar2 == 10)) {
            added = added + 2;
          }
          else if (((bVar2 & 0x7f) < 0x20) || (("HTEscapeUnsafe"[bVar2 + 6] & 2U) != 0)) {
            added = added + 1;
          }
        }
      }
    }
    if (added != 0) {
      pcVar3 = (char *)calloc((size_t)(p + (added - (int)*str) + 1),1);
      if (pcVar3 == (char *)0x0) {
        outofmem("../../../WWW/Library/Implementation/HTParse.c","HTMake822Word");
      }
      q = pcVar3;
      if (quoted != 0) {
        *pcVar3 = '\"';
        q = pcVar3 + 1;
      }
      for (p = *str; *p != '\0'; p = p + 1) {
        bVar2 = *p;
        if ((bVar2 != 9) &&
           (((bVar2 & 0x7f) < 0x20 ||
            ((-1 < (char)bVar2 && (("HTEscapeUnsafe"[bVar2 + 6] & 2U) != 0)))))) {
          *q = '\\';
          q = q + 1;
        }
        *q = *p;
        pcVar1 = q + 1;
        if ((bVar2 == 10) || ((bVar2 == 0xd && (p[1] != '\n')))) {
          *pcVar1 = ' ';
          pcVar1 = q + 2;
        }
        q = pcVar1;
      }
      if (quoted != 0) {
        *q = '\"';
        q = q + 1;
      }
      *q = '\0';
      if (*str != (char *)0x0) {
        free(*str);
        *str = (char *)0x0;
      }
      *str = pcVar3;
    }
  }
  return;
}



// WARNING: Unknown calling convention

BOOLEAN HTRegisterProtocol(HTProtocol_conflict *protocol)

{
  if (protocols == (HTList *)0x0) {
    protocols = HTList_new();
  }
  HTList_addObject(protocols,protocol);
  return '\x01';
}



// WARNING: Unknown calling convention

void HTAccessInit(void)

{
  HTRegisterProtocol(&HTTP);
  HTRegisterProtocol(&HTTPS);
  HTRegisterProtocol(&HTFile);
  HTRegisterProtocol(&HTTelnet);
  HTRegisterProtocol(&HTTn3270);
  HTRegisterProtocol(&HTRlogin);
  HTRegisterProtocol(&HTFTP);
  HTRegisterProtocol(&HTNews);
  HTRegisterProtocol(&HTNNTP);
  HTRegisterProtocol(&HTNewsPost);
  HTRegisterProtocol(&HTNewsReply);
  HTRegisterProtocol(&HTSNews);
  HTRegisterProtocol(&HTSNewsPost);
  HTRegisterProtocol(&HTSNewsReply);
  HTRegisterProtocol(&HTGopher);
  HTRegisterProtocol(&HTCSO);
  HTRegisterProtocol(&HTFinger);
  LYRegisterLynxProtocols();
  return;
}



// WARNING: Unknown calling convention

BOOLEAN override_proxy(char *addr)

{
  int iVar1;
  char *__s;
  char *pcVar2;
  char *__s2;
  size_t sVar3;
  ushort **ppuVar4;
  char *local_38;
  int t_len;
  int templ_port;
  char *colon;
  char *end;
  int h_len;
  int port;
  char *acc_method;
  char *Host;
  char *host;
  char *at;
  char *p;
  char *no_proxy;
  
  no_proxy = getenv("no_proxy");
  port = 0;
  if ((no_proxy != (char *)0x0) && (iVar1 = strcmp(no_proxy,"*"), iVar1 == 0)) {
    return '\x01';
  }
  if (addr == (char *)0x0) {
    return '\0';
  }
  __s = HTParse(addr,"",8);
  if (__s == (char *)0x0) {
    return '\0';
  }
  if (*__s == '\0') {
    if (__s != (char *)0x0) {
      free(__s);
    }
    return '\0';
  }
  pcVar2 = strchr(__s,0x40);
  local_38 = __s;
  if (pcVar2 != (char *)0x0) {
    local_38 = pcVar2 + 1;
  }
  pcVar2 = HTParse(addr,"",0x10);
  if (pcVar2 != (char *)0x0) {
    iVar1 = strcmp("file",pcVar2);
    if (iVar1 == 0) {
      iVar1 = strcmp(local_38,"localhost");
      if (iVar1 == 0) {
LAB_0810116a:
        if (__s != (char *)0x0) {
          free(__s);
        }
        if (pcVar2 != (char *)0x0) {
          free(pcVar2);
        }
        return '\x01';
      }
      __s2 = HTHostName();
      iVar1 = strcmp(local_38,__s2);
      if (iVar1 == 0) goto LAB_0810116a;
    }
    if (pcVar2 != (char *)0x0) {
      free(pcVar2);
    }
  }
  if (no_proxy == (char *)0x0) {
    if (__s != (char *)0x0) {
      free(__s);
    }
  }
  else {
    pcVar2 = strrchr(local_38,0x3a);
    if (pcVar2 == (char *)0x0) {
      pcVar2 = HTParse(addr,"",0x10);
      if (pcVar2 != (char *)0x0) {
        iVar1 = strcmp(pcVar2,"http");
        if (iVar1 == 0) {
          port = 0x50;
        }
        else {
          iVar1 = strcmp(pcVar2,"https");
          if (iVar1 == 0) {
            port = 0x1bb;
          }
          else {
            iVar1 = strcmp(pcVar2,"ftp");
            if (iVar1 == 0) {
              port = 0x15;
            }
            else {
              iVar1 = strcmp(pcVar2,"gopher");
              if (iVar1 == 0) {
                port = 0x46;
              }
              else {
                iVar1 = strcmp(pcVar2,"cso");
                if (iVar1 == 0) {
                  port = 0x69;
                }
                else {
                  iVar1 = strcmp(pcVar2,"news");
                  if (iVar1 == 0) {
                    port = 0x77;
                  }
                  else {
                    iVar1 = strcmp(pcVar2,"nntp");
                    if (iVar1 == 0) {
                      port = 0x77;
                    }
                    else {
                      iVar1 = strcmp(pcVar2,"newspost");
                      if (iVar1 == 0) {
                        port = 0x77;
                      }
                      else {
                        iVar1 = strcmp(pcVar2,"newsreply");
                        if (iVar1 == 0) {
                          port = 0x77;
                        }
                        else {
                          iVar1 = strcmp(pcVar2,"snews");
                          if (iVar1 == 0) {
                            port = 0x233;
                          }
                          else {
                            iVar1 = strcmp(pcVar2,"snewspost");
                            if (iVar1 == 0) {
                              port = 0x233;
                            }
                            else {
                              iVar1 = strcmp(pcVar2,"snewsreply");
                              if (iVar1 == 0) {
                                port = 0x233;
                              }
                              else {
                                iVar1 = strcmp(pcVar2,"wais");
                                if (iVar1 == 0) {
                                  port = 0xd2;
                                }
                                else {
                                  iVar1 = strcmp(pcVar2,"finger");
                                  if (iVar1 == 0) {
                                    port = 0x4f;
                                  }
                                  else {
                                    iVar1 = strcmp(pcVar2,"telnet");
                                    if (iVar1 == 0) {
                                      port = 0x17;
                                    }
                                    else {
                                      iVar1 = strcmp(pcVar2,"tn3270");
                                      if (iVar1 == 0) {
                                        port = 0x17;
                                      }
                                      else {
                                        iVar1 = strcmp(pcVar2,"rlogin");
                                        if (iVar1 == 0) {
                                          port = 0x201;
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (pcVar2 != (char *)0x0) {
          free(pcVar2);
        }
      }
    }
    else {
      *pcVar2 = '\0';
      port = atoi(pcVar2 + 1);
    }
    if (port == 0) {
      port = 0x50;
    }
    sVar3 = strlen(local_38);
    while (*no_proxy != '\0') {
      colon = (char *)0x0;
      templ_port = 0;
      for (; (*no_proxy != '\0' && (((byte)*no_proxy < 0x21 || (*no_proxy == ','))));
          no_proxy = no_proxy + 1) {
      }
      for (end = no_proxy; ((*end != '\0' && (0x20 < (byte)*end)) && (*end != ',')); end = end + 1)
      {
        if (*end == ':') {
          colon = end;
        }
      }
      if (colon == (char *)0x0) {
        t_len = (int)end - (int)no_proxy;
      }
      else {
        templ_port = atoi(colon + 1);
        t_len = (int)colon - (int)no_proxy;
      }
      if (((templ_port == 0) || (templ_port == port)) &&
         ((0 < t_len &&
          ((t_len <= (int)sVar3 &&
           (iVar1 = strncasecomp(local_38 + (sVar3 - t_len),no_proxy,t_len), iVar1 == 0)))))) {
        if (__s != (char *)0x0) {
          free(__s);
        }
        return '\x01';
      }
      if (((((templ_port == 0) || (templ_port == port)) && (0 < t_len)) &&
          ((t_len <= (int)sVar3 &&
           (ppuVar4 = __ctype_b_loc(), ((*ppuVar4)[(byte)*no_proxy] & 0x800) != 0)))) &&
         (iVar1 = strncmp(__s,no_proxy,t_len), iVar1 == 0)) {
        if (__s != (char *)0x0) {
          free(__s);
        }
        return '\x01';
      }
      if (*end == '\0') break;
      no_proxy = end + 1;
    }
    if (__s != (char *)0x0) {
      free(__s);
    }
  }
  return '\0';
}



// WARNING: Unknown calling convention

int get_physical(char *addr,HTParentAnchor *anchor)

{
  FILE *pFVar1;
  int iVar2;
  char *pcVar3;
  char *physical_00;
  char **protocol;
  int iVar4;
  int local_58;
  HTProtocol_conflict *p;
  int n;
  int i;
  char *gatewayed_1;
  char *path;
  char *cp;
  char *gatewayed;
  char *proxy;
  char *gateway;
  char *gateway_parameter;
  char *host_1;
  char *host;
  char *Server_addr;
  char *physical;
  char *acc_method;
  int result;
  BOOLEAN override_flag;
  
  acc_method = (char *)0x0;
  physical = (char *)0x0;
  Server_addr = (char *)0x0;
  override_flag = '\0';
  if (WWW_TraceFlag != '\0') {
    pFVar1 = TraceFP();
    fprintf((FILE *)pFVar1,"get_physical %s\n",addr);
  }
  using_proxy = '\0';
  physical = HTTranslate(addr);
  if (physical == (char *)0x0) {
    if (redirecting_url == (char *)0x0) {
      local_58 = -0x193;
    }
    else {
      local_58 = 399;
    }
  }
  else {
    if (anchor->isISMAPScript == '\x01') {
      HTSACat(&physical,"?0,0");
      if (WWW_TraceFlag != '\0') {
        pFVar1 = TraceFP();
        fprintf((FILE *)pFVar1,"HTAccess: Appending \'?0,0\' coordinate pair.\n");
      }
    }
    iVar2 = strncmp(physical,"Proxied=",8);
    if (iVar2 == 0) {
      HTAnchor_setPhysical(anchor,physical + 8);
      using_proxy = '\x01';
    }
    else {
      iVar2 = strncmp(physical,"NoProxy=",8);
      if (iVar2 == 0) {
        HTAnchor_setPhysical(anchor,physical + 8);
        override_flag = '\x01';
      }
      else {
        HTAnchor_setPhysical(anchor,physical);
      }
    }
    if (physical != (char *)0x0) {
      free(physical);
      physical = (char *)0x0;
    }
    pcVar3 = HTAnchor_physical(anchor);
    acc_method = HTParse(pcVar3,"file:",0x10);
    if ((override_flag == '\0') && (using_proxy == '\0')) {
      iVar2 = strcasecomp(acc_method,"news");
      if (iVar2 == 0) {
        host = (char *)0x0;
        host = HTParse(addr,"",8);
        if (host == (char *)0x0) {
          pcVar3 = LYGetEnv("NNTPSERVER");
          if (pcVar3 != (char *)0x0) {
            HTSACopy(&Server_addr,"news://");
            pcVar3 = LYGetEnv("NNTPSERVER");
            HTSACat(&Server_addr,pcVar3);
            HTSACat(&Server_addr,":119/");
          }
        }
        else {
          pcVar3 = strchr(host,0x3a);
          if (pcVar3 == (char *)0x0) {
            HTSACopy(&Server_addr,"news://");
            HTSACat(&Server_addr,host);
            HTSACat(&Server_addr,":119/");
          }
          if (host != (char *)0x0) {
            free(host);
            host = (char *)0x0;
          }
        }
      }
      else {
        iVar2 = strcasecomp(acc_method,"wais");
        if (iVar2 == 0) {
          host_1 = (char *)0x0;
          host_1 = HTParse(addr,"",8);
          if (host_1 == (char *)0x0) {
            HTSACopy(&Server_addr,addr);
          }
          else {
            pcVar3 = strchr(host_1,0x3a);
            if (pcVar3 == (char *)0x0) {
              HTSACopy(&Server_addr,"wais://");
              HTSACat(&Server_addr,host_1);
              HTSACat(&Server_addr,":210/");
            }
            if (host_1 != (char *)0x0) {
              free(host_1);
              host_1 = (char *)0x0;
            }
          }
        }
        else {
          HTSACopy(&Server_addr,addr);
        }
      }
      override_flag = override_proxy(Server_addr);
    }
    if ((override_flag == '\0') && (using_proxy == '\0')) {
      gateway_parameter = (char *)0x0;
      HTSprintf0(&gateway_parameter,"WWW_%s_GATEWAY",acc_method);
      gateway = LYGetEnv(gateway_parameter);
      iVar2 = strcmp(acc_method,"file");
      if (iVar2 == 0) {
        memcpy(gateway_parameter,"ftp_proxy",10);
      }
      else {
        sprintf(gateway_parameter,"%s_proxy",acc_method);
      }
      proxy = LYGetEnv(gateway_parameter);
      if (gateway_parameter != (char *)0x0) {
        free(gateway_parameter);
        gateway_parameter = (char *)0x0;
      }
      if ((gateway != (char *)0x0) && (WWW_TraceFlag != '\0')) {
        pFVar1 = TraceFP();
        fprintf((FILE *)pFVar1,"Gateway found: %s\n",gateway);
      }
      if ((proxy != (char *)0x0) && (WWW_TraceFlag != '\0')) {
        pFVar1 = TraceFP();
        fprintf((FILE *)pFVar1,"proxy server found: %s\n",proxy);
      }
      if (proxy == (char *)0x0) {
        if (gateway != (char *)0x0) {
          pcVar3 = HTParse(addr,"",0xd);
          physical_00 = HTParse(pcVar3 + 1,gateway,0x1f);
          if (pcVar3 != (char *)0x0) {
            free(pcVar3);
          }
          HTAnchor_setPhysical(anchor,physical_00);
          if (physical_00 != (char *)0x0) {
            free(physical_00);
          }
          if (acc_method != (char *)0x0) {
            free(acc_method);
            acc_method = (char *)0x0;
          }
          pcVar3 = HTAnchor_physical(anchor);
          acc_method = HTParse(pcVar3,"http:",0x10);
        }
      }
      else {
        gatewayed = (char *)0x0;
        HTSACopy(&gatewayed,proxy);
        iVar2 = strncmp(gatewayed,"http",4);
        if (iVar2 == 0) {
          pcVar3 = strrchr(gatewayed,0x2f);
          if ((pcVar3 != (char *)0x0) && ((int)pcVar3 - (int)gatewayed < 8)) {
            LYAddHtmlSep(&gatewayed);
          }
        }
        iVar2 = strncmp(addr,"file",4);
        if (iVar2 == 0) {
          HTSACat(&gatewayed,"ftp");
          HTSACat(&gatewayed,addr + 4);
        }
        else {
          HTSACat(&gatewayed,addr);
        }
        using_proxy = '\x01';
        if (anchor->isISMAPScript == '\x01') {
          HTSACat(&gatewayed,"?0,0");
        }
        HTAnchor_setPhysical(anchor,gatewayed);
        if (gatewayed != (char *)0x0) {
          free(gatewayed);
          gatewayed = (char *)0x0;
        }
        if (acc_method != (char *)0x0) {
          free(acc_method);
          acc_method = (char *)0x0;
        }
        pcVar3 = HTAnchor_physical(anchor);
        acc_method = HTParse(pcVar3,"http:",0x10);
      }
    }
    if (Server_addr != (char *)0x0) {
      free(Server_addr);
      Server_addr = (char *)0x0;
    }
    result = -0x191;
    if (protocols == (HTList *)0x0) {
      HTAccessInit();
    }
    iVar2 = HTList_count(protocols);
    for (i = 0; i < iVar2; i = i + 1) {
      protocol = (char **)HTList_objectAt(protocols,i);
      iVar4 = strcmp(*protocol,acc_method);
      if (iVar4 == 0) {
        HTAnchor_setProtocol(anchor,protocol);
        if (acc_method != (char *)0x0) {
          free(acc_method);
          acc_method = (char *)0x0;
        }
        result = 0;
        break;
      }
    }
    if (acc_method != (char *)0x0) {
      free(acc_method);
    }
    local_58 = result;
  }
  return local_58;
}



// WARNING: Unknown calling convention

void LYUCPushAssumed(HTParentAnchor *anchor)

{
  int iVar1;
  char *src;
  int iVar2;
  FILE *__stream;
  LYUCcharset *anchor_UCI;
  int anchor_LYhndl;
  
  anchor_UCI = (LYUCcharset *)0x0;
  if (anchor != (HTParentAnchor *)0x0) {
    iVar2 = HTAnchor_getUCLYhndl(anchor,1);
    if (-1 < iVar2) {
      anchor_UCI = HTAnchor_getUCInfoStage(anchor,1);
    }
    src = UCAssume_MIMEcharset;
    if ((anchor_UCI != (LYUCcharset *)0x0) && (anchor_UCI->MIMEname != (char *)0x0)) {
      pushed_assume_MIMEname = UCAssume_MIMEcharset;
      UCAssume_MIMEcharset = (char *)0x0;
      if (HTCJK == JAPANESE) {
        HTSACopy(&UCAssume_MIMEcharset,src);
      }
      else {
        HTSACopy(&UCAssume_MIMEcharset,anchor_UCI->MIMEname);
      }
      iVar1 = UCLYhndl_for_unspec;
      if (UCLYhndl_for_unspec == iVar2) {
        UCLYhndl_for_unspec = iVar2;
        pushed_assume_LYhndl = iVar2;
        return;
      }
      if (WWW_TraceFlag == '\0') {
        UCLYhndl_for_unspec = iVar2;
        pushed_assume_LYhndl = iVar2;
        return;
      }
      pushed_assume_LYhndl = iVar2;
      __stream = TraceFP();
      fprintf((FILE *)__stream,"LYUCPushAssumed: UCLYhndl_for_unspec changed %d -> %d\n",iVar1,iVar2
             );
      UCLYhndl_for_unspec = iVar2;
      return;
    }
  }
  pushed_assume_LYhndl = -1;
  if (pushed_assume_MIMEname != (char *)0x0) {
    free(pushed_assume_MIMEname);
    pushed_assume_MIMEname = (char *)0x0;
  }
  return;
}



// WARNING: Unknown calling convention

int LYUCPopAssumed(void)

{
  int iVar1;
  int iVar2;
  FILE *__stream;
  int local_10;
  
  iVar2 = pushed_assume_LYhndl;
  iVar1 = UCLYhndl_for_unspec;
  if (pushed_assume_LYhndl < 0) {
    local_10 = -1;
  }
  else {
    if ((UCLYhndl_for_unspec != pushed_assume_LYhndl) && (WWW_TraceFlag != '\0')) {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"LYUCPopAssumed: UCLYhndl_for_unspec changed %d -> %d\n",iVar1,iVar2)
      ;
    }
    UCLYhndl_for_unspec = pushed_assume_LYhndl;
    pushed_assume_LYhndl = -1;
    if (UCAssume_MIMEcharset != (char *)0x0) {
      free(UCAssume_MIMEcharset);
    }
    UCAssume_MIMEcharset = pushed_assume_MIMEname;
    pushed_assume_MIMEname = (char *)0x0;
    local_10 = UCLYhndl_for_unspec;
  }
  return local_10;
}



// WARNING: Unknown calling convention

int HTLoad(char *addr,HTParentAnchor *anchor,HTFormat format_out,HTStream *sink)

{
  code *pcVar1;
  char *pcVar2;
  void *pvVar3;
  int status;
  HTProtocol_conflict *p;
  
  status = get_physical(addr,anchor);
  if (status == -0x193) {
    LYFixCursesOn("show alert:");
    pcVar2 = (char *)gettext("Access forbidden by rule");
    status = HTLoadError((HTStream_conflict *)sink,500,pcVar2);
  }
  else if ((status != 399) && (-1 < status)) {
    pcVar2 = HTAnchor_physical(anchor);
    LYFixCursesOnForAccess(addr,pcVar2);
    pvVar3 = HTAnchor_protocol(anchor);
    anchor->parent->underway = '\x01';
    pcVar1 = *(code **)((int)pvVar3 + 4);
    pcVar2 = HTAnchor_physical(anchor);
    status = (*pcVar1)(pcVar2,anchor,format_out,sink);
    anchor->parent->underway = '\0';
    LYUCPopAssumed();
  }
  return status;
}



// WARNING: Unknown calling convention

HTStream * HTSaveStream(HTParentAnchor *anchor)

{
  void *pvVar1;
  HTStream *local_18;
  HTProtocol_conflict *p;
  
  pvVar1 = HTAnchor_protocol(anchor);
  if (pvVar1 == (void *)0x0) {
    local_18 = (HTStream *)0x0;
  }
  else {
    local_18 = (HTStream *)(**(code **)((int)pvVar1 + 8))(anchor);
  }
  return local_18;
}



// WARNING: Unknown calling convention

BOOLEAN HTLoadDocument(char *full_address,HTParentAnchor *anchor,HTFormat format_out,HTStream *sink)

{
  BOOLEAN BVar1;
  FILE *pFVar2;
  char *pcVar3;
  int iVar4;
  HTFormat pHVar5;
  HTAtom *pHVar6;
  HText *pHVar7;
  BOOLEAN local_49;
  undefined *local_48;
  char *local_44;
  undefined *local_40;
  char *local_3c;
  DocAddress NewDoc;
  time_t theTime;
  char *cp;
  char *address_to_load;
  HText *text;
  int status;
  BOOLEAN ForcingNoCache;
  
  address_to_load = full_address;
  ForcingNoCache = LYforce_no_cache;
  if (WWW_TraceFlag != '\0') {
    pFVar2 = TraceFP();
    fprintf((FILE *)pFVar2,"HTAccess: loading document %s\n",address_to_load);
  }
  if (use_this_url_instead != (char *)0x0) {
    free(use_this_url_instead);
    use_this_url_instead = (char *)0x0;
  }
  permanent_redirection = '\0';
  if (redirection_attempts < 0xb) {
    text = (HText *)HTAnchor_document(anchor);
    if ((((LYinternal_flag != '\0') && (text == (HText *)0x0)) && (LYforce_no_cache == '\0')) &&
       (((anchor->post_data != (bstring *)0x0 && (anchor->safe == '\0')) &&
        (iVar4 = strncasecomp(full_address,"LYNXIMGMAP:",0xb), iVar4 != 0)))) {
      pcVar3 = (char *)gettext("Document with POST content not found in cache.  Resubmit?");
      BVar1 = HTConfirm(pcVar3);
      if (BVar1 != '\x01') {
        return '\0';
      }
    }
    if (anchor->post_data == (bstring *)0x0) {
      while ((cp = HTAnchor_physical(anchor), cp != (char *)0x0 &&
             (iVar4 = strncmp(cp,"Location=",9), iVar4 == 0))) {
        if (WWW_TraceFlag != '\0') {
          pcVar3 = anchor->address;
          pFVar2 = TraceFP();
          fprintf((FILE *)pFVar2,"HTAccess: \'%s\' is a redirection URL.\n",pcVar3);
        }
        if (WWW_TraceFlag != '\0') {
          pcVar3 = cp + 9;
          pFVar2 = TraceFP();
          fprintf((FILE *)pFVar2,"HTAccess: Redirecting to \'%s\'\n",pcVar3);
        }
        redirection_attempts = redirection_attempts + 1;
        if (10 < redirection_attempts) {
          pcVar3 = (char *)gettext("Redirection limit of 10 URL\'s reached.");
          HTAlert(pcVar3);
          redirection_attempts = 0;
          if (use_this_url_instead != (char *)0x0) {
            free(use_this_url_instead);
            use_this_url_instead = (char *)0x0;
          }
          return '\0';
        }
        HTSACopy(&use_this_url_instead,cp + 9);
        NewDoc.address = use_this_url_instead;
        NewDoc.post_data = (bstring *)0x0;
        NewDoc.post_content_type = (char *)0x0;
        NewDoc.bookmark = anchor->bookmark;
        NewDoc.isHEAD = anchor->isHEAD;
        NewDoc.safe = anchor->safe;
        anchor = HTAnchor_findAddress(&NewDoc);
      }
    }
    if (use_this_url_instead == (char *)0x0) {
      text = (HText *)HTAnchor_document(anchor);
      if ((text != (HText *)0x0) && (LYforce_no_cache == '\0')) {
        if ((LYoverride_no_cache != '\0') ||
           ((BVar1 = HText_hasNoCacheSet(text), BVar1 == '\0' ||
            (BVar1 = HText_AreDifferent(anchor,full_address), BVar1 == '\0')))) {
          if (WWW_TraceFlag != '\0') {
            pFVar2 = TraceFP();
            fprintf((FILE *)pFVar2,"HTAccess: Document already in memory.\n");
          }
          HText_select(text);
          pHVar5 = HTAnchor_format(anchor);
          pHVar6 = HTAtom_for("www/dired");
          if (pHVar5 == pHVar6) {
            lynx_edit_mode = '\x01';
          }
          redirection_attempts = 0;
          return '\x01';
        }
        ForcingNoCache = '\x01';
        HTSABFree(&anchor->post_data);
        if (WWW_TraceFlag != '\0') {
          pFVar2 = TraceFP();
          fprintf((FILE *)pFVar2,"HTAccess: Auto-reloading document.\n");
        }
      }
      BVar1 = HText_HaveUserChangedForms(text);
      if (BVar1 != '\0') {
        pcVar3 = (char *)gettext("Reloading document.  Any form entries will be lost!");
        HTAlert(pcVar3);
      }
      LYforce_no_cache = '\0';
      if ((ForcingNoCache != '\0') && (anchor->title != (char *)0x0)) {
        free(anchor->title);
        anchor->title = (char *)0x0;
      }
      local_44 = (char *)sink;
      status = HTLoad(address_to_load,anchor,format_out,sink);
      if (WWW_TraceFlag != '\0') {
        pFVar2 = TraceFP();
        format_out = (HTFormat)status;
        fprintf((FILE *)pFVar2,"HTAccess:  status=%d\n",status);
      }
      if (((text == (HText *)0x0) || (-1 < status)) ||
         (pHVar7 = (HText *)HTAnchor_document(anchor), pHVar7 != text)) {
        if (HTlogfile != (FILE *)0x0) {
          time(&theTime);
          if (status < 0) {
            local_48 = &DAT_0817f298;
          }
          else {
            local_48 = &DAT_0817f29d;
          }
          if (HTClientHost == (char *)0x0) {
            local_44 = "local";
          }
          else {
            local_44 = HTClientHost;
          }
          format_out = (HTFormat)ctime(&theTime);
          fprintf((FILE *)HTlogfile,"%24.24s %s %s %s\n",format_out,local_44,local_48,full_address);
          fflush((FILE *)HTlogfile);
          if (WWW_TraceFlag != '\0') {
            if (status < 0) {
              local_40 = &DAT_0817f298;
            }
            else {
              local_40 = &DAT_0817f29d;
            }
            if (HTClientHost == (char *)0x0) {
              local_3c = "local";
            }
            else {
              local_3c = HTClientHost;
            }
            format_out = (HTFormat)ctime(&theTime);
            pFVar2 = TraceFP();
            fprintf((FILE *)pFVar2,"Log: %24.24s %s %s %s\n",format_out,local_3c,local_40,
                    full_address);
            local_44 = local_3c;
          }
        }
        if (status == 399) {
          if (WWW_TraceFlag != '\0') {
            pFVar2 = TraceFP();
            fprintf((FILE *)pFVar2,"HTAccess: \'%s\' is a redirection URL.\n",address_to_load,
                    local_44);
          }
          pcVar3 = redirecting_url;
          if (WWW_TraceFlag != '\0') {
            pFVar2 = TraceFP();
            fprintf((FILE *)pFVar2,"HTAccess: Redirecting to \'%s\'\n",pcVar3,local_44);
          }
          iVar4 = strcmp(address_to_load,redirecting_url);
          if (iVar4 == 0) {
            redirection_attempts = redirection_attempts + 1;
            if (redirecting_url != (char *)0x0) {
              free(redirecting_url);
              redirecting_url = (char *)0x0;
            }
            permanent_redirection = '\0';
            local_49 = '\x01';
          }
          else {
            if (permanent_redirection != '\0') {
              HTSACopy(&anchor->physical,"Location=");
              HTSACat(&anchor->physical,redirecting_url);
            }
            HTSACopy(&use_this_url_instead,redirecting_url);
            if (ForcingNoCache != '\0') {
              LYforce_no_cache = '\x01';
            }
            redirection_attempts = redirection_attempts + 1;
            if (redirecting_url != (char *)0x0) {
              free(redirecting_url);
              redirecting_url = (char *)0x0;
            }
            permanent_redirection = '\0';
            local_49 = '\0';
          }
        }
        else {
          redirection_attempts = 0;
          if (redirecting_url != (char *)0x0) {
            free(redirecting_url);
            redirecting_url = (char *)0x0;
          }
          permanent_redirection = '\0';
          if (status == 200) {
            if (WWW_TraceFlag != '\0') {
              pFVar2 = TraceFP();
              fprintf((FILE *)pFVar2,"HTAccess: `%s\' has been accessed.\n",full_address,local_44);
            }
            local_49 = '\x01';
          }
          else if (status == 0xce) {
            pcVar3 = (char *)gettext("Loading incomplete.");
            HTAlert(pcVar3);
            if (WWW_TraceFlag != '\0') {
              pFVar2 = TraceFP();
              fprintf((FILE *)pFVar2,"HTAccess: `%s\' has been accessed, partial content.\n",
                      full_address);
            }
            local_49 = '\x01';
          }
          else if (status == -0xcc) {
            if (WWW_TraceFlag != '\0') {
              pFVar2 = TraceFP();
              fprintf((FILE *)pFVar2,"HTAccess: `%s\' has been accessed, No data left.\n",
                      full_address,local_44);
            }
            local_49 = '\0';
          }
          else if (status == -29999) {
            if (WWW_TraceFlag != '\0') {
              pFVar2 = TraceFP();
              fprintf((FILE *)pFVar2,"HTAccess: `%s\' has been accessed, No data loaded.\n",
                      full_address,local_44);
            }
            local_49 = '\0';
          }
          else if (status == -0x752e) {
            if (WWW_TraceFlag != '\0') {
              pFVar2 = TraceFP();
              fprintf((FILE *)pFVar2,"HTAccess: `%s\' has been accessed, transfer interrupted.\n",
                      full_address,local_44);
            }
            local_49 = '\0';
          }
          else {
            if (0 < status) {
              pcVar3 = (char *)gettext(
                                      "**** HTAccess: socket or file number returned by obsolete load routine!\n"
                                      );
              fprintf(stderr,pcVar3,format_out,local_44);
              pcVar3 = (char *)gettext(
                                      "**** HTAccess: Internal software error.  Please mail lynx-dev@nongnu.org!\n"
                                      );
              fprintf(stderr,pcVar3);
              pcVar3 = (char *)gettext("**** HTAccess: Status returned was: %d\n");
              fprintf(stderr,pcVar3,status);
              exit_immediately(1);
            }
            cp = (char *)0x0;
            pcVar3 = (char *)gettext("Can\'t Access");
            HTSACopy(&cp,pcVar3);
            HTSACat(&cp," `");
            HTSACat(&cp,full_address);
            HTSACat(&cp,"\'");
            mustshow = '\x01';
            HTProgress(cp);
            if (cp != (char *)0x0) {
              free(cp);
              cp = (char *)0x0;
            }
            if (WWW_TraceFlag != '\0') {
              pFVar2 = TraceFP();
              fprintf((FILE *)pFVar2,"HTAccess: Can\'t access `%s\'\n",full_address);
            }
            pcVar3 = (char *)gettext("Unable to access document.");
            HTLoadError((HTStream_conflict *)sink,500,pcVar3);
            local_49 = '\0';
          }
        }
      }
      else {
        pcVar3 = (char *)gettext("Loading failed, use a previous copy.");
        HTAlert(pcVar3);
        if (WWW_TraceFlag != '\0') {
          pFVar2 = TraceFP();
          fprintf((FILE *)pFVar2,"HTAccess: Loading failed, use a previous copy.\n");
        }
        HText_select(text);
        pHVar5 = HTAnchor_format(anchor);
        pHVar6 = HTAtom_for("www/dired");
        if (pHVar5 == pHVar6) {
          lynx_edit_mode = '\x01';
        }
        redirection_attempts = 0;
        local_49 = '\x01';
      }
    }
    else {
      if (redirecting_url != (char *)0x0) {
        free(redirecting_url);
        redirecting_url = (char *)0x0;
      }
      local_49 = '\0';
    }
  }
  else {
    redirection_attempts = 0;
    pcVar3 = (char *)gettext("Redirection limit of 10 URL\'s reached.");
    HTAlert(pcVar3);
    local_49 = '\0';
  }
  return local_49;
}



// WARNING: Unknown calling convention

BOOLEAN HTLoadAbsolute(DocAddress *docaddr)

{
  HTStream *sink;
  BOOLEAN BVar1;
  HTParentAnchor *anchor;
  HTAtom *local_8;
  
  sink = HTOutputStream;
  if (HTOutputFormat == (HTFormat)0x0) {
    local_8 = HTAtom_for("www/present");
  }
  else {
    local_8 = HTOutputFormat;
  }
  anchor = HTAnchor_findAddress(docaddr);
  BVar1 = HTLoadDocument(docaddr->address,anchor,local_8,sink);
  return BVar1;
}



// WARNING: Unknown calling convention

BOOLEAN HTLoadRelative(char *relative_name,HTParentAnchor *here)

{
  char *aName;
  DocAddress full_address;
  char *stripped;
  char *mycopy;
  BOOLEAN result;
  
  mycopy = (char *)0x0;
  full_address.address = (char *)0x0;
  full_address.post_data = (bstring *)0x0;
  full_address.post_content_type = (char *)0x0;
  full_address.bookmark = (char *)0x0;
  full_address.isHEAD = '\0';
  full_address.safe = '\0';
  HTSACopy(&mycopy,relative_name);
  aName = HTStrip(mycopy);
  full_address.address = HTParse(aName,here->address,0x1d);
  result = HTLoadAbsolute(&full_address);
  if (full_address.address != (char *)0x0) {
    free(full_address.address);
    full_address.address = (char *)0x0;
  }
  if (mycopy != (char *)0x0) {
    free(mycopy);
  }
  return result;
}



// WARNING: Unknown calling convention

BOOLEAN HTLoadAnchor(HTAnchor *destination)

{
  bool bVar1;
  HTStream *sink;
  BOOLEAN BVar2;
  HTParentAnchor *me;
  HyperDoc *pHVar3;
  HText *text_00;
  BOOLEAN local_1d;
  HTAtom *local_18;
  HText *text;
  HTParentAnchor *parent;
  BOOLEAN result;
  BOOLEAN loaded;
  
  bVar1 = false;
  if (destination == (HTAnchor *)0x0) {
    local_1d = '\0';
  }
  else {
    me = HTAnchor_parent(destination);
    pHVar3 = HTAnchor_document(me);
    sink = HTOutputStream;
    if (pHVar3 == (HyperDoc *)0x0) {
      if (HTOutputFormat == (HTFormat)0x0) {
        local_18 = HTAtom_for("www/present");
      }
      else {
        local_18 = HTOutputFormat;
      }
      BVar2 = HTLoadDocument(me->address,me,local_18,sink);
      if (BVar2 == '\0') {
        return '\0';
      }
      bVar1 = true;
    }
    text_00 = (HText *)HTAnchor_document(me);
    if (((HTParentAnchor *)destination == me) || (me->parent == (HTParentAnchor0 *)destination)) {
      if (!bVar1) {
        HText_select(text_00);
      }
    }
    else {
      HText_selectAnchor(text_00,(HTChildAnchor *)destination);
    }
    local_1d = '\x01';
  }
  return local_1d;
}



// WARNING: Unknown calling convention

char hex(int i)

{
  char *hexchars;
  
  return "0123456789ABCDEF"[i];
}



// WARNING: Unknown calling convention

BOOLEAN HTSearch(char *keywords,HTParentAnchor *here)

{
  char cVar1;
  size_t sVar2;
  char *src;
  char *escaped;
  char *address;
  char *e;
  char *s;
  char *p;
  char *u;
  char *q;
  uchar c;
  BOOLEAN result;
  
  address = (char *)0x0;
  sVar2 = strlen(keywords);
  src = (char *)calloc(sVar2 * 3 + 1,1);
  if (src == (char *)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTAccess.c","HTSearch");
  }
  HTSACopy(&address,here->isIndexAction);
  for (s = keywords; (*s != '\0' && ((byte)*s < 0x21)); s = s + 1) {
  }
  sVar2 = strlen(s);
  for (e = s + sVar2; (s < e && ((byte)e[-1] < 0x21)); e = e + -1) {
  }
  q = src;
  for (p = s; p < e; p = p + 1) {
    c = *p;
    if ((byte)*p < 0x21) {
      *q = '+';
      q = q + 1;
    }
    else if (HTCJK == NOCJK) {
      if (((c < 0x20) || ((char)c < '\0')) || ("0123456789ABCDEF"[c + 10] == '\0')) {
        *q = '%';
        q = q + 1;
        cVar1 = hex((uint)(c >> 4));
        *q = cVar1;
        q = q + 1;
        cVar1 = hex(c & 0xf);
        *q = cVar1;
        q = q + 1;
      }
      else {
        *q = *p;
        q = q + 1;
      }
    }
    else {
      *q = *p;
      q = q + 1;
    }
  }
  *q = '\0';
  u = strchr(address,0x3f);
  if (u != (char *)0x0) {
    *u = '\0';
  }
  HTSACat(&address,"?");
  HTSACat(&address,src);
  if (src != (char *)0x0) {
    free(src);
  }
  result = HTLoadRelative(address,here);
  if (address != (char *)0x0) {
    free(address);
  }
  return result;
}



// WARNING: Unknown calling convention

BOOLEAN HTSearchAbsolute(char *keywords,char *indexname)

{
  BOOLEAN BVar1;
  HTParentAnchor *here;
  DocAddress abs_doc;
  HTParentAnchor *anchor;
  
  abs_doc.address = indexname;
  abs_doc.post_data = (bstring *)0x0;
  abs_doc.post_content_type = (char *)0x0;
  abs_doc.bookmark = (char *)0x0;
  abs_doc.isHEAD = '\0';
  abs_doc.safe = '\0';
  here = HTAnchor_findAddress(&abs_doc);
  BVar1 = HTSearch(keywords,here);
  return BVar1;
}



// WARNING: Unknown calling convention

void strip_userid(char *host)

{
  char cVar1;
  char *pcVar2;
  FILE *__stream;
  char *msg;
  char *fake;
  char *p2;
  char *p1;
  
  p1 = host;
  pcVar2 = strchr(host,0x40);
  if (pcVar2 != (char *)0x0) {
    *pcVar2 = '\0';
    p2 = pcVar2 + 1;
    fake = HTParse(host,"",8);
    if (fake != (char *)0x0) {
      msg = (char *)0x0;
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"parsed:%s\n",fake);
      }
      pcVar2 = (char *)gettext("Address contains a username: %s");
      HTSprintf0(&msg,pcVar2,host);
      HTAlert(msg);
      if (msg != (char *)0x0) {
        free(msg);
      }
    }
    do {
      *p1 = *p2;
      cVar1 = *p1;
      p1 = p1 + 1;
      p2 = p2 + 1;
    } while (cVar1 != '\0');
  }
  return;
}



// WARNING: Unknown calling convention

BOOLEAN acceptEncoding(int code)

{
  char *program;
  BOOLEAN result;
  
  result = '\0';
  if ((LYAcceptEncoding & code) != 0) {
    program = (char *)0x0;
    if (code == 2) {
      program = HTGetProgramPath(ppINFLATE);
    }
    else if (code < 3) {
      if (code == 1) {
        program = HTGetProgramPath(ppGZIP);
      }
    }
    else if (code == 4) {
      program = HTGetProgramPath(ppCOMPRESS);
    }
    else if (code == 8) {
      program = HTGetProgramPath(ppBZIP2);
    }
    result = program != (char *)0x0;
  }
  return result;
}



int HTLoadHTTP(char *arg,HTParentAnchor *anAnchor,HTFormat format_out,HTStream *sink)

{
  int iVar1;
  char *pcVar2;
  bool bVar3;
  bool bVar4;
  bool bVar5;
  bool bVar6;
  bool bVar7;
  bool bVar8;
  bool bVar9;
  bool bVar10;
  BOOLEAN BVar11;
  char *pcVar12;
  int iVar13;
  FILE *pFVar14;
  int *piVar15;
  size_t sVar16;
  int iVar17;
  uint nbyte;
  HTAtom *pHVar18;
  wchar_t wVar19;
  char *fmt;
  int in_GS_OFFSET;
  undefined8 uVar20;
  undefined4 uVar21;
  char *local_1b0;
  char *local_1ac;
  char *local_1a4;
  char *local_1a0;
  size_t local_19c;
  int local_198;
  char *local_194;
  char *local_190;
  char *local_18c;
  char *local_188;
  int local_184;
  int local_180;
  int local_17c;
  char *local_178;
  char *local_174;
  size_t local_170;
  char *local_16c;
  char *local_168;
  char *local_164;
  int local_150;
  HTStream *sink_local;
  HTFormat format_out_local;
  HTParentAnchor *anAnchor_local;
  char *arg_local;
  int port2;
  FILE *error_file;
  int fields;
  int buffer_length;
  char *path2;
  char *host2;
  char *cookie;
  char *auth;
  char *list;
  char *colon;
  char *hostname;
  char *docname;
  char *abspath;
  int nn;
  char *pound;
  char *cp_1;
  char *cp;
  int k;
  int j;
  HTPresentation_conflict *pres;
  char *host;
  int i;
  int n;
  char *p1;
  void *handle;
  int len;
  int server_status;
  int rv;
  int rawlength;
  int length;
  char *linebuf;
  int real_length_of_line;
  char *line_kept_clean;
  char *line_buffer;
  char *METHOD;
  HTFormat format_in;
  HTStream *target;
  int bytes_already_read;
  int status;
  char *start_of_data;
  char *eol;
  bstring *command;
  char *url;
  int s;
  char crlf [3];
  BOOLEAN end_of_file;
  BOOLEAN secure;
  BOOLEAN already_retrying;
  BOOLEAN doing_redirect;
  BOOLEAN auth_proxy;
  BOOLEAN show_407;
  BOOLEAN show_401;
  BOOLEAN first_Accept;
  BOOLEAN extensions;
  BOOLEAN had_header;
  BOOLEAN do_post;
  BOOLEAN do_head;
  char temp [80];
  char server_version [21];
  
  format_out_local = format_out;
  sink_local = sink;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  url = arg;
  command = (bstring *)0x0;
  bVar4 = false;
  bVar3 = false;
  real_length_of_line = 0;
  linebuf = (char *)0x0;
  bVar8 = false;
  bVar9 = false;
  bVar7 = false;
  len = 0;
  handle = (void *)0x0;
  if (anAnchor->isHEAD == '\0') {
    if (anAnchor->post_data != (bstring *)0x0) {
      bVar3 = true;
    }
  }
  else {
    bVar4 = true;
  }
  if (arg == (char *)0x0) {
    status = -3;
    mustshow = '\x01';
    pcVar12 = (char *)gettext("Bad request!");
    HTProgress(pcVar12);
    goto done;
  }
  if (*arg == '\0') {
    status = -2;
    mustshow = '\x01';
    pcVar12 = (char *)gettext("Bad request!");
    HTProgress(pcVar12);
    goto done;
  }
  sprintf(crlf,"%c%c",0xd);
  bVar5 = true;
try_again:
  eol = (char *)0x0;
  length = 0;
  bVar10 = false;
  permanent_redirection = '\0';
  redirect_post_content = '\0';
  target = (HTStream *)0x0;
  line_buffer = (char *)0x0;
  line_kept_clean = (char *)0x0;
  iVar13 = strncmp(url,"https",5);
  if (iVar13 == 0) goto code_r0x081032f7;
  piVar15 = &s;
  status = HTDoConnect(arg,"HTTP",0x50,piVar15);
  if (status == -0x752e) {
    if (WWW_TraceFlag != '\0') {
      pFVar14 = TraceFP();
      fprintf((FILE *)pFVar14,"HTTP: Interrupted on connect; recovering cleanly.\n");
    }
    mustshow = '\x01';
    pcVar12 = (char *)gettext("Connection interrupted.");
    HTProgress(pcVar12);
    status = -29999;
    goto done;
  }
  if (status < 0) {
    if (WWW_TraceFlag != '\0') {
      piVar15 = __errno_location();
      iVar13 = *piVar15;
      pFVar14 = TraceFP();
      fprintf((FILE *)pFVar14,"HTTP: Unable to connect to remote host for `%s\' (errno = %d).\n",url
              ,iVar13);
    }
    pcVar12 = (char *)gettext("Unable to connect to remote host.");
    HTAlert(pcVar12);
    status = -29999;
    goto done;
  }
  uVar20 = CONCAT44(piVar15,5);
  p1 = HTParse(url,"",5);
  if (bVar3) {
    METHOD = "POST";
    HTSABCopy0(&command,"POST ");
  }
  else if (bVar4) {
    METHOD = "HEAD";
    HTSABCopy0(&command,"HEAD ");
  }
  else {
    METHOD = "GET";
    HTSABCopy0(&command,"GET ");
  }
  if (using_proxy == '\0') {
    HTSABCat0(&command,p1);
  }
  else {
    HTSABCat0(&command,p1 + 1);
  }
  if (p1 != (char *)0x0) {
    free(p1);
    p1 = (char *)0x0;
  }
  if (bVar5) {
    HTSABCat0(&command," ");
    HTSABCat0(&command,"HTTP/1.0");
  }
  HTSABCat0(&command,crlf);
  if (bVar5) {
    host = (char *)0x0;
    host = HTParse(anAnchor->address,"",8);
    if (host != (char *)0x0) {
      strip_userid(host);
      HTBprintf(&command,"Host: %s%c%c",host,0xd,10);
      if (host != (char *)0x0) {
        free(host);
        host = (char *)0x0;
      }
    }
    if (HTPresentations == (HTList *)0x0) {
      HTFormatInit();
    }
    n = HTList_count(HTPresentations);
    bVar6 = true;
    len = 0;
    for (i = 0; i < n; i = i + 1) {
      pres = (HTPresentation_conflict *)HTList_objectAt(HTPresentations,i);
      if (pres->get_accept != '\0') {
        if (1.0 <= pres->quality) {
          iVar13 = *(int *)((int)&pres->maxbytes + 4);
          if ((iVar13 < 0) || ((iVar13 < 1 && (*(int *)&pres->maxbytes == 0)))) {
            temp[0] = '\0';
          }
          else {
            sprintf(temp,";mxb=%lld",*(undefined4 *)&pres->maxbytes);
          }
        }
        else {
          iVar13 = *(int *)((int)&pres->maxbytes + 4);
          if ((iVar13 < 0) || ((iVar13 < 1 && (*(int *)&pres->maxbytes == 0)))) {
            sprintf(temp,";q=%4.3f",(double)pres->quality);
          }
          else {
            sprintf(temp,";q=%4.3f;mxb=%lld",(double)pres->quality,*(undefined4 *)&pres->maxbytes,
                    *(undefined4 *)((int)&pres->maxbytes + 4));
          }
        }
        if (bVar6) {
          local_1b0 = "Accept: ";
        }
        else {
          local_1b0 = ", ";
        }
        pcVar12 = temp;
        HTSprintf0(&linebuf,"%s%s%s",local_1b0,pres->rep->name,pcVar12);
        sVar16 = strlen(linebuf);
        len = sVar16 + len;
        if ((0xfc < len) && (!bVar6)) {
          HTSABCat0(&command,crlf);
          HTSprintf0(&linebuf,"Accept: %s%s",pres->rep->name,temp,pcVar12);
          len = strlen(linebuf);
        }
        HTSABCat0(&command,linebuf);
        bVar6 = false;
      }
    }
    if (bVar6) {
      local_1ac = "Accept: ";
    }
    else {
      local_1ac = ", ";
    }
    uVar21 = 10;
    HTBprintf(&command,"%s*/*;q=0.01%c%c",local_1ac,0xd,10);
    len = 0;
    if ((LYPrependBaseToSource == '\0') || (dump_output_immediately == '\0')) {
      list = (char *)0x0;
      for (j = 1; j < 0xf; j = j << 1) {
        BVar11 = acceptEncoding(j);
        if (BVar11 != '\0') {
          for (k = 0; tbl_preferred_encoding[k].name != (char *)0x0; k = k + 1) {
            if (tbl_preferred_encoding[k].value == j) {
              if (list != (char *)0x0) {
                HTSACat(&list,", ");
              }
              HTSACat(&list,tbl_preferred_encoding[k].name);
              break;
            }
          }
        }
      }
      if (list != (char *)0x0) {
        uVar21 = 10;
        HTBprintf(&command,"Accept-Encoding: %s%c%c",list,0xd,10);
        free(list);
      }
    }
    else if (WWW_TraceFlag != '\0') {
      pFVar14 = TraceFP();
      fprintf((FILE *)pFVar14,"omit Accept-Encoding to work-around interaction with -source\n");
    }
    if ((language != (char *)0x0) && (*language != '\0')) {
      uVar21 = 10;
      HTBprintf(&command,"Accept-Language: %s%c%c",language,0xd,10);
    }
    if ((pref_charset != (char *)0x0) && (*pref_charset != '\0')) {
      HTSABCat0(&command,"Accept-Charset: ");
      HTSACopy(&linebuf,pref_charset);
      pcVar12 = linebuf;
      sVar16 = strlen(linebuf);
      pcVar2 = linebuf;
      if (pcVar12[sVar16 - 1] == ',') {
        sVar16 = strlen(linebuf);
        pcVar2[sVar16 - 1] = '\0';
      }
      LYLowerCase(linebuf);
      pcVar12 = strstr(linebuf,"iso-8859-1");
      if (pcVar12 == (char *)0x0) {
        HTSACat(&linebuf,", iso-8859-1;q=0.01");
      }
      pcVar12 = strstr(linebuf,"us-ascii");
      if (pcVar12 == (char *)0x0) {
        HTSACat(&linebuf,", us-ascii;q=0.01");
      }
      HTSABCat0(&command,linebuf);
      HTBprintf(&command,"%c%c",0xd);
    }
    if (reloading != '\0') {
      HTBprintf(&command,"Pragma: no-cache%c%c",0xd,10,uVar21);
      HTBprintf(&command,"Cache-Control: no-cache%c%c",0xd);
    }
    if ((LYUserAgent == (char *)0x0) || (*LYUserAgent == '\0')) {
      if (HTAppVersion == (char *)0x0) {
        local_1a4 = "0.0";
      }
      else {
        local_1a4 = HTAppVersion;
      }
      if (HTAppName == (char *)0x0) {
        local_1a0 = "unknown";
      }
      else {
        local_1a0 = HTAppName;
      }
      HTBprintf(&command,"User-Agent: %s/%s  libwww-FM/%s%c%c",local_1a0,local_1a4,HTLibraryVersion,
                0xd,10);
    }
    else {
      cp = LYSkipBlanks(LYUserAgent);
      if (*cp != '\0') {
        HTBprintf(&command,"User-Agent: %.*s%c%c",0x5f1,LYUserAgent,0xd,10);
      }
    }
    if ((personal_mail_address != (char *)0x0) && (LYNoFromHeader == '\0')) {
      HTBprintf(&command,"From: %s%c%c",personal_mail_address,0xd,10);
    }
    if ((((LYUserSpecifiedURL == '\0') && (LYNoRefererHeader == '\0')) &&
        (LYNoRefererForThis == '\0')) && (pcVar12 = HTLoadedDocumentURL(), *pcVar12 != '\0')) {
      cp_1 = LYRequestReferer;
      if (LYRequestReferer == (char *)0x0) {
        cp_1 = HTLoadedDocumentURL();
      }
      HTSABCat0(&command,"Referer: ");
      iVar13 = strncasecomp(cp_1,"LYNXIMGMAP:",0xb);
      if (iVar13 == 0) {
        pound = strchr(cp_1,0x23);
        if (pound == (char *)0x0) {
          local_19c = strlen(cp_1);
        }
        else {
          local_19c = (int)pound - (int)cp_1;
        }
        nn = local_19c;
        HTSABCat(&command,cp_1 + 0xb,local_19c);
      }
      else {
        HTSABCat0(&command,cp_1);
      }
      HTBprintf(&command,"%c%c",0xd);
    }
    cookie = (char *)0x0;
    iVar13 = strncmp(anAnchor->address,"https",5);
    abspath = HTParse(arg,"",5);
    docname = HTParse(arg,"",4);
    hostname = HTParse(arg,"",8);
    if ((hostname == (char *)0x0) ||
       (colon = HTParsePort(hostname,(int *)&list), colon == (char *)0x0)) {
      iVar17 = strncmp(arg,"https",5);
      if (iVar17 == 0) {
        list = (char *)0x1bb;
      }
      else {
        list = (char *)0x50;
      }
    }
    else {
      *colon = '\0';
    }
    if (using_proxy == '\0') {
      cookie = LYAddCookieHeader(hostname,abspath,(int)list,iVar13 == 0);
      auth_proxy = '\0';
    }
    else {
      host2 = (char *)0x0;
      path2 = (char *)0x0;
      iVar17 = strncmp(docname,"https",5);
      if (iVar17 == 0) {
        local_198 = 0x1bb;
      }
      else {
        local_198 = 0x50;
      }
      port2 = local_198;
      host2 = HTParse(docname,"",8);
      path2 = HTParse(docname,"",5);
      if ((host2 != (char *)0x0) && (colon = HTParsePort(host2,&port2), colon != (char *)0x0)) {
        *colon = '\0';
      }
      auth = HTAA_composeAuth(host2,port2,path2,'\0');
      if ((auth == (char *)0x0) || (*auth == '\0')) {
        if ((auth != (char *)0x0) && (*auth == '\0')) {
          if ((traversal == '\0') && (dump_output_immediately == '\0')) {
            pcVar12 = (char *)gettext("Proceed without a username and password?");
            BVar11 = HTConfirm(pcVar12);
            if (BVar11 != '\0') {
              bVar8 = true;
              goto LAB_08104288;
            }
          }
          if ((traversal != '\0') || (dump_output_immediately != '\0')) {
            pcVar12 = (char *)gettext("Can\'t proceed without a username and password.");
            HTAlert(pcVar12);
          }
          HTSABFree(&command);
          if (hostname != (char *)0x0) {
            free(hostname);
            hostname = (char *)0x0;
          }
          if (docname != (char *)0x0) {
            free(docname);
            docname = (char *)0x0;
          }
          if (abspath != (char *)0x0) {
            free(abspath);
            abspath = (char *)0x0;
          }
          if (host2 != (char *)0x0) {
            free(host2);
            host2 = (char *)0x0;
          }
          if (path2 != (char *)0x0) {
            free(path2);
            path2 = (char *)0x0;
          }
          status = -29999;
          goto done;
        }
        if (WWW_TraceFlag != '\0') {
          pFVar14 = TraceFP();
          fprintf((FILE *)pFVar14,"HTTP: Not sending authorization (yet).\n");
        }
      }
      else {
        HTBprintf(&command,"%s%c%c",auth,0xd,10);
        if (WWW_TraceFlag != '\0') {
          pFVar14 = TraceFP();
          fprintf((FILE *)pFVar14,"HTTP: Sending authorization: %s\n",auth);
        }
      }
LAB_08104288:
      iVar17 = strncmp(docname,"http",4);
      if (iVar17 == 0) {
        cookie = LYAddCookieHeader(host2,path2,port2,iVar13 == 0);
      }
      if (host2 != (char *)0x0) {
        free(host2);
        host2 = (char *)0x0;
      }
      if (path2 != (char *)0x0) {
        free(path2);
        path2 = (char *)0x0;
      }
      auth_proxy = '\x01';
    }
    if (cookie != (char *)0x0) {
      if (*cookie != '$') {
        HTSABCat0(&command,"Cookie2: $Version=\"1\"");
        HTSABCat0(&command,crlf);
        if (WWW_TraceFlag != '\0') {
          pFVar14 = TraceFP();
          fprintf((FILE *)pFVar14,"HTTP: Sending Cookie2: $Version =\"1\"\n");
        }
      }
      if (*cookie != '\0') {
        HTSABCat0(&command,"Cookie: ");
        HTSABCat0(&command,cookie);
        HTSABCat0(&command,crlf);
        if (WWW_TraceFlag != '\0') {
          pFVar14 = TraceFP();
          fprintf((FILE *)pFVar14,"HTTP: Sending Cookie: %s\n",cookie);
        }
      }
      if (cookie != (char *)0x0) {
        free(cookie);
        cookie = (char *)0x0;
      }
    }
    if (abspath != (char *)0x0) {
      free(abspath);
      abspath = (char *)0x0;
    }
    uVar20 = CONCAT44((int)auth_proxy,docname);
    auth = HTAA_composeAuth(hostname,(int)list,docname,auth_proxy);
    if ((auth == (char *)0x0) || (*auth == '\0')) {
      if ((auth != (char *)0x0) && (*auth == '\0')) {
        if ((traversal == '\0') && (dump_output_immediately == '\0')) {
          pcVar12 = (char *)gettext("Proceed without a username and password?");
          BVar11 = HTConfirm(pcVar12);
          if (BVar11 != '\0') {
            if (auth_proxy == '\x01') {
              bVar9 = true;
            }
            else {
              bVar8 = true;
            }
            goto LAB_08104679;
          }
        }
        if ((traversal != '\0') || (dump_output_immediately != '\0')) {
          pcVar12 = (char *)gettext("Can\'t proceed without a username and password.");
          HTAlert(pcVar12);
        }
        HTSABFree(&command);
        if (hostname != (char *)0x0) {
          free(hostname);
          hostname = (char *)0x0;
        }
        if (docname != (char *)0x0) {
          free(docname);
          docname = (char *)0x0;
        }
        status = -29999;
        goto done;
      }
      if (WWW_TraceFlag != '\0') {
        if (auth_proxy == '\0') {
          local_190 = "HTTP: Not sending authorization (yet).\n";
        }
        else {
          local_190 = "HTTP: Not sending proxy authorization (yet).\n";
        }
        pFVar14 = TraceFP();
        fprintf((FILE *)pFVar14,local_190);
      }
    }
    else {
      uVar20 = CONCAT44(0xd,auth);
      HTBprintf(&command,"%s%c%c",auth,0xd,10);
      if (WWW_TraceFlag != '\0') {
        if (auth_proxy == '\0') {
          local_194 = "HTTP: Sending authorization: %s\n";
        }
        else {
          local_194 = "HTTP: Sending proxy authorization: %s\n";
        }
        pFVar14 = TraceFP();
        uVar20 = CONCAT44((int)((ulonglong)uVar20 >> 0x20),auth);
        fprintf((FILE *)pFVar14,local_194,auth);
      }
    }
LAB_08104679:
    if (hostname != (char *)0x0) {
      free(hostname);
      hostname = (char *)0x0;
    }
    if (docname != (char *)0x0) {
      free(docname);
      docname = (char *)0x0;
    }
  }
  if (bVar3) {
    if (WWW_TraceFlag != '\0') {
      if (anAnchor->post_content_type == (char *)0x0) {
        local_18c = "lose";
      }
      else {
        local_18c = anAnchor->post_content_type;
      }
      pFVar14 = TraceFP();
      fprintf((FILE *)pFVar14,"HTTP: Doing post, content-type \'%s\'\n",local_18c);
    }
    if (anAnchor->post_content_type == (char *)0x0) {
      local_188 = "lose";
    }
    else {
      local_188 = anAnchor->post_content_type;
    }
    HTBprintf(&command,"Content-type: %s%c%c",local_188,0xd,10);
    if (((anAnchor->post_data == (bstring *)0x0) || (anAnchor->post_data == (bstring *)0x0)) ||
       (anAnchor->post_data->len == 0)) {
      local_184 = 0;
    }
    else {
      if (anAnchor->post_data == (bstring *)0x0) {
        local_180 = 0;
      }
      else {
        local_180 = anAnchor->post_data->len;
      }
      local_184 = local_180;
    }
    uVar21 = 0xd;
    HTBprintf(&command,"Content-length: %d%c%c",local_184,0xd,10);
    HTSABCat0(&command,crlf);
    if (anAnchor->post_data == (bstring *)0x0) {
      local_17c = 0;
    }
    else {
      local_17c = anAnchor->post_data->len;
    }
    if (anAnchor->post_data == (bstring *)0x0) {
      local_178 = (char *)0x0;
    }
    else {
      local_178 = anAnchor->post_data->str;
    }
    uVar20 = CONCAT44(uVar21,local_17c);
    HTSABCat(&command,local_178,local_17c);
  }
  else {
    HTSABCat0(&command,crlf);
  }
  if (WWW_TraceFlag != '\0') {
    if (WWW_TraceFlag != '\0') {
      pFVar14 = TraceFP();
      fprintf((FILE *)pFVar14,"Writing:\n");
    }
    trace_bstring(command);
    if (WWW_TraceFlag != '\0') {
      if (anAnchor->post_data == (bstring *)0x0) {
        local_174 = "";
      }
      else {
        local_174 = crlf;
      }
      pFVar14 = TraceFP();
      uVar20 = CONCAT44((int)((ulonglong)uVar20 >> 0x20),local_174);
      fprintf((FILE *)pFVar14,"%s",local_174);
    }
    if (WWW_TraceFlag != '\0') {
      pFVar14 = TraceFP();
      fprintf((FILE *)pFVar14,"----------------------------------\n",uVar20);
    }
  }
  mustshow = '\x01';
  pcVar12 = (char *)gettext("Sending HTTP request.");
  HTProgress(pcVar12);
  if (command == (bstring *)0x0) {
    local_170 = 0;
    local_16c = (char *)0x0;
  }
  else {
    local_170 = command->len;
    local_16c = command->str;
  }
  status = write(s,local_16c,local_170);
  HTSABFree(&command);
  if (linebuf != (char *)0x0) {
    free(linebuf);
    linebuf = (char *)0x0;
  }
  if (status < 1) {
    if (status == 0) {
      if (WWW_TraceFlag != '\0') {
        pFVar14 = TraceFP();
        fprintf((FILE *)pFVar14,"HTTP: Got status 0 in initial write\n");
      }
      goto LAB_08104b3c;
    }
    piVar15 = __errno_location();
    if ((((*piVar15 != 0x6b) && (piVar15 = __errno_location(), *piVar15 != 0x68)) &&
        (piVar15 = __errno_location(), *piVar15 != 0x20)) || ((bVar7 || (bVar3)))) {
      if (WWW_TraceFlag != '\0') {
        pFVar14 = TraceFP();
        fprintf((FILE *)pFVar14,"HTTP: Hit unexpected network WRITE error; aborting connection.\n");
      }
      close(s);
      status = -1;
      pcVar12 = (char *)gettext("Unexpected network write error; connection aborted.");
      HTAlert(pcVar12);
      goto done;
    }
    if (WWW_TraceFlag != '\0') {
      pFVar14 = TraceFP();
      fprintf((FILE *)pFVar14,"HTTP: BONZO ON WRITE Trying again with HTTP0 request.\n");
    }
    mustshow = '\x01';
    pcVar12 = (char *)gettext("Retrying as HTTP0 request.");
    HTProgress(pcVar12);
    close(s);
    bVar5 = false;
    bVar7 = true;
    goto try_again;
  }
LAB_08104b3c:
  if (WWW_TraceFlag != '\0') {
    pFVar14 = TraceFP();
    fprintf((FILE *)pFVar14,"HTTP: WRITE delivered OK\n");
  }
  mustshow = '\x01';
  pcVar12 = (char *)gettext("HTTP request sent; waiting for response.");
  HTProgress(pcVar12);
  buffer_length = 0x600;
  line_buffer = (char *)calloc(0x600,1);
  if (line_buffer == (char *)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTTP.c","HTLoadHTTP");
  }
  bytes_already_read = 0;
  uVar21 = 0;
  HTReadProgress(0,0);
  do {
    if (buffer_length - length < 0x100) {
      buffer_length = buffer_length * 2;
      line_buffer = (char *)realloc(line_buffer,buffer_length);
      if (line_buffer == (char *)0x0) {
        outofmem("../../../WWW/Library/Implementation/HTTP.c","HTLoadHTTP");
      }
    }
    if (WWW_TraceFlag != '\0') {
      iVar13 = buffer_length - length;
      pFVar14 = TraceFP();
      fprintf((FILE *)pFVar14,"HTTP: Trying to read %d\n",iVar13 + -1);
    }
    nbyte = (buffer_length - length) - 1;
    uVar20 = CONCAT44(uVar21,nbyte);
    status = HTDoRead(s,line_buffer + length,nbyte);
    if (WWW_TraceFlag != '\0') {
      pFVar14 = TraceFP();
      uVar20 = CONCAT44((int)((ulonglong)uVar20 >> 0x20),status);
      fprintf((FILE *)pFVar14,"HTTP: Read %d\n",status);
    }
    if (status < 1) {
      if (status == -0x752e) {
        if (WWW_TraceFlag != '\0') {
          pFVar14 = TraceFP();
          fprintf((FILE *)pFVar14,"HTTP: Interrupted initial read.\n",uVar20);
        }
        mustshow = '\x01';
        pcVar12 = (char *)gettext("Connection interrupted.");
        HTProgress(pcVar12);
        close(s);
        status = -0xcc;
        goto clean_up;
      }
      if (((-1 < status) ||
          (((piVar15 = __errno_location(), *piVar15 != 0x6b &&
            (piVar15 = __errno_location(), *piVar15 != 0x68)) &&
           (piVar15 = __errno_location(), *piVar15 != 0x20)))) || ((bVar7 || (bVar3)))) {
        if (WWW_TraceFlag != '\0') {
          pFVar14 = TraceFP();
          fprintf((FILE *)pFVar14,
                  "HTTP: Hit unexpected network read error; aborting connection; status %d.\n",
                  status);
        }
        pcVar12 = (char *)gettext("Unexpected network read error; connection aborted.");
        HTAlert(pcVar12);
        close(s);
        status = -1;
        goto clean_up;
      }
      if (WWW_TraceFlag != '\0') {
        pFVar14 = TraceFP();
        fprintf((FILE *)pFVar14,"HTTP: BONZO Trying again with HTTP0 request.\n");
      }
      close(s);
      if (line_buffer != (char *)0x0) {
        free(line_buffer);
        line_buffer = (char *)0x0;
      }
      if (line_kept_clean != (char *)0x0) {
        free(line_kept_clean);
        line_kept_clean = (char *)0x0;
      }
      bVar5 = false;
      bVar7 = true;
      mustshow = '\x01';
      pcVar12 = (char *)gettext("Retrying as HTTP0 request.");
      HTProgress(pcVar12);
      goto try_again;
    }
    bytes_already_read = bytes_already_read + status;
    uVar21 = 0;
    HTReadProgress((longlong)bytes_already_read,0);
    if (status == 0) break;
    line_buffer[length + status] = '\0';
    if (line_buffer != (char *)0x0) {
      if (line_kept_clean != (char *)0x0) {
        free(line_kept_clean);
        line_kept_clean = (char *)0x0;
      }
      line_kept_clean = (char *)malloc(buffer_length);
      if (line_kept_clean == (char *)0x0) {
        outofmem("../../../WWW/Library/Implementation/HTTP.c","HTLoadHTTP");
      }
      memcpy(line_kept_clean,line_buffer,buffer_length);
      real_length_of_line = length + status;
    }
    eol = strchr(line_buffer + length,10);
    if (((eol != (char *)0x0) && (eol != line_buffer)) && (eol[-1] == '\r')) {
      eol[-1] = ' ';
    }
    length = length + status;
    if (eol != (char *)0x0) {
      *eol = '\0';
      break;
    }
  } while (bytes_already_read < 100);
  rawlength = length;
  if (WWW_TraceFlag != '\0') {
    pFVar14 = TraceFP();
    fprintf((FILE *)pFVar14,"HTTP: Rx: %s\n",line_buffer);
  }
  if ((bVar5) &&
     ((((iVar13 = strncmp(line_buffer,"<TITLE>Bad File Request</TITLE>",0x1f), iVar13 == 0 ||
        (iVar13 = strncmp(line_buffer,"Address should begin with",0x19), iVar13 == 0)) ||
       (iVar13 = strncmp(line_buffer,"<TITLE>Help ",0xc), iVar13 == 0)) ||
      (iVar13 = strcmp(line_buffer,"Document address invalid or access not authorised"), iVar13 == 0
      )))) {
    if (line_buffer != (char *)0x0) {
      free(line_buffer);
      line_buffer = (char *)0x0;
    }
    if (line_kept_clean != (char *)0x0) {
      free(line_kept_clean);
      line_kept_clean = (char *)0x0;
    }
    iVar13 = s;
    bVar5 = false;
    bVar7 = true;
    if (WWW_TraceFlag != '\0') {
      pFVar14 = TraceFP();
      fprintf((FILE *)pFVar14,"HTTP: close socket %d to retry with HTTP0\n",iVar13);
    }
    close(s);
    mustshow = '\x01';
    pcVar12 = (char *)gettext("Retrying as HTTP0 request.");
    HTProgress(pcVar12);
    goto try_again;
  }
  server_version[0] = '\0';
  fields = sscanf(line_buffer,"%20s %d",server_version);
  if (WWW_TraceFlag != '\0') {
    pFVar14 = TraceFP();
    fprintf((FILE *)pFVar14,"HTTP: Scanned %d fields from line_buffer\n",fields);
  }
  if ((http_error_file != (char *)0x0) &&
     (error_file = (FILE *)fopen64(http_error_file,"a+"), error_file != (FILE *)0x0)) {
    fprintf((FILE *)error_file,"   URL=%s (%s)\n",url);
    fprintf((FILE *)error_file,"STATUS=%s\n",line_buffer);
    fclose((FILE *)error_file);
  }
  if ((((fields < 2) || (server_version[0] == '\0')) ||
      ((server_version[0] != 'H' ||
       (((server_version[1] != 'T' || (server_version[2] != 'T')) || (server_version[3] != 'P'))))))
     || ((server_version[4] != '/' || (server_version[6] != '.')))) {
    if (WWW_TraceFlag != '\0') {
      pFVar14 = TraceFP();
      fprintf((FILE *)pFVar14,"--- Talking HTTP0.\n");
    }
    format_in = HTFileFormat(url,(HTAtom **)&port2,(char **)0x0);
    iVar13 = strncmp(format_in->name,"text/plain",10);
    if (iVar13 == 0) {
      if (WWW_TraceFlag != '\0') {
        pFVar14 = TraceFP();
        fprintf((FILE *)pFVar14,"HTTP: format_in being changed to text/HTML\n");
      }
      format_in = HTAtom_for("text/html");
    }
    if (((port2 != 0) && (pHVar18 = HTAtom_for("identity"), pHVar18 != (HTAtom *)port2)) &&
       ((pHVar18 = HTAtom_for("8bit"), pHVar18 != (HTAtom *)port2 &&
        ((pHVar18 = HTAtom_for("binary"), pHVar18 != (HTAtom *)port2 &&
         (pHVar18 = HTAtom_for("7bit"), pHVar18 != (HTAtom *)port2)))))) {
      if (WWW_TraceFlag != '\0') {
        pcVar12 = format_in->name;
        pFVar14 = TraceFP();
        fprintf((FILE *)pFVar14,"HTTP: format_in is \'%s\',\n",pcVar12);
      }
      HTSACopy(&anAnchor->content_type,format_in->name);
      HTSACopy(&anAnchor->content_encoding,*(char **)(port2 + 4));
      format_in = HTAtom_for("www/compressed");
      if (WWW_TraceFlag != '\0') {
        pFVar14 = TraceFP();
        fprintf((FILE *)pFVar14,"        Treating as \'%s\' with encoding \'%s\'\n","www/compressed"
               );
      }
    }
    start_of_data = line_kept_clean;
    goto LAB_08105ee9;
  }
  format_in = HTAtom_for("www/mime");
  if (WWW_TraceFlag != '\0') {
    pFVar14 = TraceFP();
    fprintf((FILE *)pFVar14,"--- Talking HTTP1.\n");
  }
  if (eol == (char *)0x0) {
    local_168 = HTLoadHTTP::empty;
  }
  else {
    local_168 = eol + 1;
  }
  start_of_data = local_168;
  if (eol == (char *)0x0) {
    local_164 = (char *)0x0;
  }
  else {
    local_164 = line_buffer + (length - (int)local_168);
  }
  length = (int)local_164;
  while (sVar16 = strlen(line_buffer), line_buffer[sVar16 - 1] == ' ') {
    sVar16 = strlen(line_buffer);
    line_buffer[sVar16 - 1] = '\0';
  }
  switch(server_status / 100) {
  default:
    pcVar12 = (char *)gettext("Unknown status reply from server!");
    HTAlert(pcVar12);
    HTAlert(line_buffer);
    if (traversal == '\0') {
      if ((dump_output_immediately == '\0') &&
         (pHVar18 = HTAtom_for("www/download"), pHVar18 == format_out_local)) {
        format_out_local = HTAtom_for("www/present");
      }
      break;
    }
    close(s);
    status = -1;
    goto clean_up;
  case 1:
    pcVar12 = (char *)gettext("Got unexpected Informational Status.");
    HTAlert(pcVar12);
    bVar4 = true;
    break;
  case 2:
    if (!bVar4) {
      if (server_status == 0xcd) {
        pcVar12 = (char *)gettext("Request fulfilled.  Reset Content.");
        HTAlert(pcVar12);
        close(s);
        status = -0xcc;
      }
      else if (server_status == 0xce) {
        HTAlert(line_buffer);
        close(s);
        status = -0xcc;
      }
      else {
        if (server_status != 0xcc) {
          HTProgress(line_buffer);
          break;
        }
        HTAlert(line_buffer);
        close(s);
        HTNoDataOK = 1;
        status = -0xcc;
      }
      goto clean_up;
    }
    HTProgress(line_buffer);
    break;
  case 3:
    if (((no_url_redirection != '\0') || (bVar4)) || (keep_mime_headers != '\0')) {
      HTProgress(line_buffer);
    }
    else if (server_status == 300) {
      HTAlert(line_buffer);
      if (traversal != '\0') {
        close(s);
        status = -1;
        goto clean_up;
      }
      if ((dump_output_immediately == '\0') &&
         (pHVar18 = HTAtom_for("www/download"), pHVar18 == format_out_local)) {
        format_out_local = HTAtom_for("www/present");
      }
    }
    else {
      if (server_status != 0x130) {
        if (((server_status == 0x131) || (server_status == 0x132)) || (0x133 < server_status)) {
          HTAlert(line_buffer);
          if (traversal == '\0') {
            if ((dump_output_immediately == '\0') &&
               (pHVar18 = HTAtom_for("www/download"), pHVar18 == format_out_local)) {
              format_out_local = HTAtom_for("www/present");
            }
            break;
          }
          close(s);
          status = -1;
        }
        else {
          if (((((dump_output_immediately == '\0') && (traversal == '\0')) || (!bVar3)) ||
              ((server_status == 0x12f || (server_status == 0x12e)))) || (server_status == 0x12d)) {
            HTProgress(line_buffer);
            if (server_status == 0x12d) {
              if (bVar3) {
                if (WWW_TraceFlag != '\0') {
                  pFVar14 = TraceFP();
                  fprintf((FILE *)pFVar14,
                          "HTTP: Have POST content.  Treating 301 (Permanent) as Temporary.\n");
                }
                pcVar12 = (char *)gettext(
                                         "Have POST content.  Treating Permanent Redirection as Temporary.\n"
                                         );
                HTAlert(pcVar12);
              }
              else {
                permanent_redirection = '\x01';
              }
            }
            bVar10 = true;
            break;
          }
          close(s);
          status = -1;
          pcVar12 = (char *)gettext("Redirection of POST content requires user approval.");
          HTAlert(pcVar12);
          if (traversal != '\0') {
            HTProgress(line_buffer);
          }
        }
        goto clean_up;
      }
      pcVar12 = (char *)gettext("Got unexpected 304 Not Modified status.");
      HTAlert(pcVar12);
      bVar4 = true;
    }
    break;
  case 4:
    if (server_status != 0x197) {
      if (server_status == 0x198) {
        HTAlert(line_buffer);
        close(s);
        status = -0xcc;
        goto done;
      }
      if (server_status == 0x191) {
        if (bVar8) break;
        BVar11 = HTAA_shouldRetryWithAuth(start_of_data,length,s,'\0');
        if (BVar11 == '\0') {
          if ((traversal == '\0') && (dump_output_immediately == '\0')) {
            pcVar12 = (char *)gettext("Show the 401 message body?");
            BVar11 = HTConfirm(pcVar12);
            if (BVar11 != '\0') break;
          }
          if ((traversal != '\0') || (dump_output_immediately != '\0')) {
            pcVar12 = (char *)gettext(
                                     "Can\'t retry with authorization!  Contact the server\'s WebMaster."
                                     );
            HTAlert(pcVar12);
          }
          close(s);
          status = -1;
          goto clean_up;
        }
        close(s);
        iVar13 = s;
        if ((dump_output_immediately == '\0') || (authentication_info[0] != (char *)0x0)) {
          if (WWW_TraceFlag != '\0') {
            pFVar14 = TraceFP();
            fprintf((FILE *)pFVar14,"%s %d %s\n","HTTP: close socket",iVar13,
                    "to retry with Access Authorization");
          }
          mustshow = '\x01';
          pcVar12 = (char *)gettext("Retrying with access authorization information.");
          HTProgress(pcVar12);
          if (line_buffer != (char *)0x0) {
            free(line_buffer);
            line_buffer = (char *)0x0;
          }
          if (line_kept_clean != (char *)0x0) {
            free(line_kept_clean);
          }
          goto try_again;
        }
        fwrite("HTTP: Access authorization required.\n",1,0x25,stderr);
        fwrite("       Use the -auth=id:pw parameter.\n",1,0x26,stderr);
        status = -0xcc;
      }
      else {
        HTAlert(line_buffer);
        if (traversal == '\0') {
          if ((dump_output_immediately == '\0') &&
             (pHVar18 = HTAtom_for("www/download"), pHVar18 == format_out_local)) {
            format_out_local = HTAtom_for("www/present");
          }
          break;
        }
        close(s);
        status = -1;
      }
      goto clean_up;
    }
    if ((using_proxy != '\0') && (!bVar9)) {
      BVar11 = HTAA_shouldRetryWithAuth(start_of_data,length,s,'\x01');
      if (BVar11 == '\0') {
        if ((traversal == '\0') && (dump_output_immediately == '\0')) {
          pcVar12 = (char *)gettext("Show the 407 message body?");
          BVar11 = HTConfirm(pcVar12);
          if (BVar11 != '\0') {
            if ((dump_output_immediately == '\0') &&
               (pHVar18 = HTAtom_for("www/download"), pHVar18 == format_out_local)) {
              format_out_local = HTAtom_for("www/present");
            }
            break;
          }
        }
        if ((traversal != '\0') || (dump_output_immediately != '\0')) {
          pcVar12 = (char *)gettext(
                                   "Can\'t retry with proxy authorization!  Contact the server\'s WebMaster."
                                   );
          HTAlert(pcVar12);
        }
        close(s);
        status = -1;
        goto clean_up;
      }
      close(s);
      iVar13 = s;
      if ((dump_output_immediately != '\0') && (proxyauth_info[0] == (char *)0x0)) {
        fwrite("HTTP: Proxy authorization required.\n",1,0x24,stderr);
        fwrite("       Use the -pauth=id:pw parameter.\n",1,0x27,stderr);
        status = -0xcc;
        goto clean_up;
      }
      if (WWW_TraceFlag != '\0') {
        pFVar14 = TraceFP();
        fprintf((FILE *)pFVar14,"%s %d %s\n","HTTP: close socket",iVar13,
                "to retry with Proxy Authorization");
      }
      mustshow = '\x01';
      pcVar12 = (char *)gettext("Retrying with proxy authorization information.");
      HTProgress(pcVar12);
      if (line_buffer != (char *)0x0) {
        free(line_buffer);
        line_buffer = (char *)0x0;
      }
      if (line_kept_clean != (char *)0x0) {
        free(line_kept_clean);
      }
      goto try_again;
    }
    break;
  case 5:
    HTAlert(line_buffer);
    if (traversal != '\0') {
      close(s);
      status = -1;
      goto clean_up;
    }
    if ((dump_output_immediately == '\0') &&
       (pHVar18 = HTAtom_for("www/download"), pHVar18 == format_out_local)) {
      format_out_local = HTAtom_for("www/present");
    }
  }
LAB_08105ee9:
  wVar19 = HTCheckForInterrupt();
  if (wVar19 == L'\0') {
    if ((bVar4) || (keep_mime_headers != '\0')) {
      start_of_data = line_kept_clean;
      length = rawlength;
      format_in = HTAtom_for("text/plain");
    }
    else if (bVar10) {
      format_in = HTAtom_for("message/x-http-redirection");
      HTSACopy(&anAnchor->content_type,format_in->name);
      if (traversal == '\0') {
        if ((dump_output_immediately == '\0') &&
           (pHVar18 = HTAtom_for("www/download"), pHVar18 == format_out_local)) {
          format_out_local = HTAtom_for("www/present");
        }
      }
      else {
        format_out_local = HTAtom_for("www/debug");
        if (sink_local == (HTStream *)0x0) {
          sink_local = (HTStream *)HTErrorStream();
        }
      }
    }
    target = (HTStream *)
             HTStreamStack(format_in,format_out_local,(HTStream_conflict4 *)sink_local,anAnchor);
    if ((HTStream_conflict4 *)target == (HTStream_conflict4 *)0x0) {
      port2 = 0;
      close(s);
      pcVar12 = format_out_local->name;
      pcVar2 = format_in->name;
      fmt = (char *)gettext("Sorry, no known way of converting %s to %s.");
      HTSprintf0((char **)&port2,fmt,pcVar2,pcVar12);
      mustshow = '\x01';
      HTProgress((char *)port2);
      if (port2 != 0) {
        free((void *)port2);
        port2 = 0;
      }
      status = -1;
    }
    else {
      (*((HTStream_conflict4 *)target)->isa->put_block)
                ((HTStream_conflict4 *)target,start_of_data,length);
      rv = HTCopy(anAnchor,s,handle,(HTStream_conflict4 *)target);
      if (rv == -1) {
        if ((bVar10) && (traversal != '\0')) {
          status = -1;
        }
        else {
          status = -0x752e;
        }
        close(s);
      }
      else if ((rv != -2) ||
              (((*target->isa->_abort)(target,(HTError)0x0), bVar10 &&
               (redirecting_url != (char *)0x0)))) {
        if ((rv == -0x752e) || (rv == -2)) {
          close(s);
        }
        else {
          (*target->isa->_free)(target);
        }
        pcVar12 = redirecting_url;
        if (bVar10) {
          if (redirecting_url == (char *)0x0) {
            if (traversal == '\0') {
              local_150 = 200;
            }
            else {
              local_150 = -1;
            }
            status = local_150;
          }
          else {
            if (WWW_TraceFlag != '\0') {
              pFVar14 = TraceFP();
              fprintf((FILE *)pFVar14,"HTTP: Picked up location \'%s\'\n",pcVar12);
            }
            if (rv == -0x752e) {
              if (redirecting_url != (char *)0x0) {
                free(redirecting_url);
                redirecting_url = (char *)0x0;
              }
              if (WWW_TraceFlag != '\0') {
                pFVar14 = TraceFP();
                fprintf((FILE *)pFVar14,"HTTP: Interrupted followup read.\n");
              }
              status = -0x752e;
            }
            else {
              HTProgress(line_buffer);
              pcVar12 = redirecting_url;
              if (server_status == 0x131) {
                sVar16 = strlen(redirecting_url);
                if (pcVar12[sVar16 - 1] != '/') {
                  HTSACat(&redirecting_url,"/");
                }
                HTSACat(&redirecting_url,anAnchor->address);
                pcVar12 = redirecting_url;
                if (WWW_TraceFlag != '\0') {
                  pFVar14 = TraceFP();
                  fprintf((FILE *)pFVar14,"HTTP: Proxy URL is \'%s\'\n",pcVar12);
                }
              }
              if (((bVar3) && (server_status != 0x12f)) && (server_status != 0x12e)) {
                wVar19 = HTConfirmPostRedirect(redirecting_url,server_status);
                if (wVar19 == L'\0') {
                  if (redirecting_url != (char *)0x0) {
                    free(redirecting_url);
                    redirecting_url = (char *)0x0;
                  }
                  status = -0xcc;
                }
                else {
                  if (wVar19 != L'') {
                    redirect_post_content = '\x01';
                  }
                  status = 399;
                }
              }
              else {
                status = 399;
              }
            }
          }
        }
        else {
          status = 200;
        }
      }
      else {
        close(s);
        if (((!bVar10) && (!bVar7)) && (!bVar3)) {
          if (WWW_TraceFlag != '\0') {
            pFVar14 = TraceFP();
            fprintf((FILE *)pFVar14,"HTTP: Trying again with HTTP0 request.\n");
          }
          if (line_buffer != (char *)0x0) {
            free(line_buffer);
            line_buffer = (char *)0x0;
          }
          if (line_kept_clean != (char *)0x0) {
            free(line_kept_clean);
            line_kept_clean = (char *)0x0;
          }
          bVar5 = false;
          bVar7 = true;
          mustshow = '\x01';
          pcVar12 = (char *)gettext("Retrying as HTTP0 request.");
          HTProgress(pcVar12);
          goto try_again;
        }
        status = -29999;
      }
    }
  }
  else {
    close(s);
    if (bVar10) {
      if (WWW_TraceFlag != '\0') {
        pFVar14 = TraceFP();
        fprintf((FILE *)pFVar14,"HTTP: Interrupted followup read.\n");
      }
      mustshow = '\x01';
      pcVar12 = (char *)gettext("Connection interrupted.");
      HTProgress(pcVar12);
    }
    status = -0x752e;
  }
clean_up:
  if (line_buffer != (char *)0x0) {
    free(line_buffer);
    line_buffer = (char *)0x0;
  }
  if (line_kept_clean != (char *)0x0) {
    free(line_kept_clean);
    line_kept_clean = (char *)0x0;
  }
  goto done;
code_r0x081032f7:
  pcVar12 = (char *)gettext("This client does not contain support for HTTPS URLs.");
  HTAlert(pcVar12);
  status = -29999;
done:
  reloading = '\0';
  dump_server_status = server_status;
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return status;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



char * FormatStr(char **bufp,char *start,char *entry)

{
  int iVar1;
  int in_GS_OFFSET;
  char *entry_local;
  char *start_local;
  char **bufp_local;
  char fmt [512];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if (*start == '\0') {
    if ((*bufp == (char *)0x0) || ((entry != (char *)0x0 && (*entry != '\0')))) {
      if (entry != (char *)0x0) {
        HTSACopy(bufp,entry);
      }
    }
    else {
      **bufp = '\0';
    }
  }
  else {
    sprintf(fmt,"%%%.*ss",0x1fd,start);
    HTSprintf0(bufp,fmt,entry);
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return *bufp;
}



char * FormatNum(char **bufp,char *start,int entry)

{
  int iVar1;
  int in_GS_OFFSET;
  char *start_local;
  char **bufp_local;
  char fmt [512];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if (*start == '\0') {
    sprintf(fmt,"%d",entry);
    HTSACopy(bufp,fmt);
  }
  else {
    sprintf(fmt,"%%%.*sd",0x1fd,start);
    HTSprintf0(bufp,fmt,entry);
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return *bufp;
}



void LYListFmtParse(char *fmtstr,DIRED *data,char *file,HTStructured_conflict *target,char *tail)

{
  size_t sVar1;
  ushort **ppuVar2;
  char *pcVar3;
  HTFormat pHVar4;
  int iVar5;
  uint uVar6;
  uint uVar7;
  int in_GS_OFFSET;
  char *local_170;
  char *local_16c;
  char *local_168;
  char *tail_local;
  HTStructured_conflict *target_local;
  char *file_local;
  DIRED *data_local;
  char *fmtstr_local;
  HTFormat format;
  char *cp2;
  int len;
  char *datestr;
  time_t now;
  char *name;
  char *buf;
  char *str;
  char *start;
  char *end;
  char *s;
  char type;
  char c;
  char tmp [256];
  int local_14;
  
  fmtstr_local = fmtstr;
  local_14 = *(int *)(in_GS_OFFSET + 0x14);
  str = (char *)0x0;
  buf = (char *)0x0;
  if ((data->file_info).st_mode == 0) {
    fmtstr_local = "    %a";
  }
  HTSACopy(&str,fmtstr_local);
  pcVar3 = str;
  s = str;
  sVar1 = strlen(str);
  end = pcVar3 + sVar1;
LAB_08107166:
  do {
    pcVar3 = s;
    if (*s == '\0') {
LAB_08107177:
      if (buf != (char *)0x0) {
        free(buf);
        buf = (char *)0x0;
      }
      (*target->isa->put_character)(target,'\n');
      if (str != (char *)0x0) {
        free(str);
        str = (char *)0x0;
      }
      if (local_14 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
        __stack_chk_fail();
      }
      return;
    }
    start = s;
    for (; *s != '\0'; s = s + 1) {
      if (*s == '%') {
        if (s[1] != '%') break;
        s = s + 1;
      }
    }
    *s = '\0';
    if (pcVar3 < s) {
      (*target->isa->put_string)(target,pcVar3);
    }
    if (s == end) goto LAB_08107177;
    start = s + 1;
    s = start;
    while (((((ppuVar2 = __ctype_b_loc(), ((*ppuVar2)[(byte)*s] & 0x800) != 0 || (*s == '.')) ||
             (*s == '-')) || ((*s == ' ' || (*s == '#')))) || ((*s == '+' || (*s == '\''))))) {
      s = s + 1;
    }
    c = *s;
    *s = '\0';
    switch(c) {
    case '\0':
      (*target->isa->put_string)(target,start);
      goto LAB_08107166;
    default:
      fprintf(stderr,"Unknown format character `%c\' in list format\n",(int)c);
      break;
    case '%':
      FormatStr(&buf,start,"%");
      break;
    case 'A':
    case 'a':
      HTDirEntry(target,tail,data->file_name);
      FormatStr(&buf,start,data->file_name);
      (*target->isa->put_string)(target,buf);
      (*target->isa->end_element)(target,0,(char **)0x0);
      *buf = '\0';
      if (((c != 'A') && (((data->file_info).st_mode & 0xf000) == 0xa000)) &&
         (len = readlink(file,tmp,0xff), -1 < len)) {
        (*target->isa->put_string)(target," -> ");
        tmp[len] = '\0';
        (*target->isa->put_string)(target,tmp);
      }
      break;
    case 'K':
      if (((data->file_info).st_mode & 0xf000) != 0x4000) goto switchD_0810694b_caseD_6b;
      FormatStr(&buf,start,"");
      HTSACat(&buf," ");
      break;
    case 'T':
    case 't':
      if (((data->file_info).st_mode & 0xf000) == 0x4000) {
        if (c == 'T') {
          FormatStr(&buf,start,"");
        }
        else {
          pcVar3 = (char *)gettext("Directory");
          FormatStr(&buf,start,pcVar3);
        }
      }
      else {
        pHVar4 = HTFileFormat(file,(HTAtom **)0x0,&cp2);
        if (c == 'T') {
          FormatStr(&buf,start,pHVar4->name);
        }
        else {
          if (cp2 == (char *)0x0) {
            iVar5 = strncmp(pHVar4->name,"application",0xb);
            if (iVar5 == 0) {
              cp2 = pHVar4->name + 0xc;
              iVar5 = strncmp(cp2,"x-",2);
              if (iVar5 == 0) {
                cp2 = cp2 + 2;
              }
            }
            else {
              cp2 = pHVar4->name;
            }
          }
          FormatStr(&buf,start,cp2);
        }
      }
      break;
    case 'd':
      now = time((time_t *)0x0);
      datestr = ctime(&(data->file_info).st_mtim.tv_sec);
      if (now - (data->file_info).st_mtim.tv_sec < 0xf099c0) {
        sprintf(tmp,"%.12s",datestr + 4);
      }
      else {
        sprintf(tmp,"%.7s %.4s ",datestr + 4,datestr + 0x14);
      }
      FormatStr(&buf,start,tmp);
      break;
    case 'g':
      name = HTAA_GidToName((data->file_info).st_gid);
      if (*name == '\0') {
        FormatNum(&buf,start,(data->file_info).st_gid);
      }
      else {
        FormatStr(&buf,start,name);
      }
      break;
    case 'k':
switchD_0810694b_caseD_6b:
      uVar6 = *(uint *)&(data->file_info).st_size;
      uVar7 = uVar6 + 0x3ff;
      iVar5 = *(int *)((int)&(data->file_info).st_size + 4) + (uint)(0xfffffc00 < uVar6);
      uVar6 = iVar5 >> 0x1f & 0x3ff;
      FormatNum(&buf,start,uVar6 + uVar7 >> 10 | (iVar5 + (uint)CARRY4(uVar6,uVar7)) * 0x400000);
      HTSACat(&buf,"K");
      break;
    case 'l':
      FormatNum(&buf,start,(data->file_info).st_nlink);
      break;
    case 'o':
      name = HTAA_UidToName((data->file_info).st_uid);
      if (*name == '\0') {
        FormatNum(&buf,start,(data->file_info).st_uid);
      }
      else {
        FormatStr(&buf,start,name);
      }
      break;
    case 'p':
      uVar6 = (data->file_info).st_mode & 0xf000;
      if (uVar6 == 0x6000) {
        type = 'b';
      }
      else if (uVar6 < 0x6001) {
        if (uVar6 == 0x2000) {
          type = 'c';
        }
        else if (uVar6 == 0x4000) {
          type = 'd';
        }
        else if (uVar6 == 0x1000) {
          type = 'p';
        }
        else {
LAB_08106e99:
          type = '?';
        }
      }
      else if (uVar6 == 0xa000) {
        type = 'l';
      }
      else if (uVar6 == 0xc000) {
        type = 's';
      }
      else {
        if (uVar6 != 0x8000) goto LAB_08106e99;
        type = '-';
      }
      if (((data->file_info).st_mode & 0x200) == 0) {
        local_170 = LYListFmtParse::pbits[(data->file_info).st_mode & 7];
      }
      else {
        local_170 = LYListFmtParse::ptbits[(data->file_info).st_mode & 7];
      }
      if (((data->file_info).st_mode & 0x400) == 0) {
        local_16c = LYListFmtParse::pbits[(data->file_info).st_mode >> 3 & 7];
      }
      else {
        local_16c = LYListFmtParse::psbits[(data->file_info).st_mode >> 3 & 7];
      }
      if (((data->file_info).st_mode & 0x800) == 0) {
        local_168 = LYListFmtParse::pbits[(data->file_info).st_mode >> 6 & 7];
      }
      else {
        local_168 = LYListFmtParse::psbits[(data->file_info).st_mode >> 6 & 7];
      }
      sprintf(tmp,"%c%s%s%s",(int)type,local_168,local_16c,local_170);
      FormatStr(&buf,start,tmp);
      break;
    case 's':
      FormatNum(&buf,start,*(int *)&(data->file_info).st_size);
    }
    if (buf != (char *)0x0) {
      (*target->isa->put_string)(target,buf);
    }
    s = s + 1;
  } while( true );
}



void HTSetSuffix5(char *suffix,char *representation,char *encoding,char *desc,double value)

{
  bool bVar1;
  int iVar2;
  HTAtom *pHVar3;
  HTAtom *pHVar4;
  HTSuffix *local_2c;
  double value_local;
  HTList *cur;
  HTSuffix *suff;
  BOOLEAN trivial_enc;
  
  if ((encoding != (char *)0x0) && (*encoding != '\0')) {
    iVar2 = strcmp(encoding,"identity");
    if (iVar2 != 0) {
      iVar2 = strcmp(encoding,"8bit");
      if (iVar2 != 0) {
        iVar2 = strcmp(encoding,"binary");
        if (iVar2 != 0) {
          iVar2 = strcmp(encoding,"7bit");
          if (iVar2 != 0) {
            bVar1 = false;
            goto LAB_08107284;
          }
        }
      }
    }
  }
  bVar1 = true;
LAB_08107284:
  iVar2 = strcmp(suffix,"*");
  if (iVar2 == 0) {
    suff = &no_suffix;
  }
  else {
    iVar2 = strcmp(suffix,"*.*");
    if (iVar2 == 0) {
      suff = &unknown_suffix;
    }
    else {
      cur = HTSuffixes;
      do {
        do {
          do {
            do {
              do {
                do {
                  do {
                    do {
                      if ((cur == (HTList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
                        local_2c = (HTSuffix *)0x0;
                      }
                      else {
                        local_2c = (HTSuffix *)cur->object;
                      }
                      suff = local_2c;
                      if (local_2c == (HTSuffix *)0x0) goto LAB_0810743d;
                    } while (local_2c->suffix == (char *)0x0);
                    iVar2 = strcmp(local_2c->suffix,suffix);
                  } while (iVar2 != 0);
                  if (bVar1) {
                    if (local_2c->encoding == (HTAtom *)0x0) goto LAB_0810743d;
                    pHVar4 = local_2c->encoding;
                    pHVar3 = HTAtom_for("identity");
                    if (pHVar4 == pHVar3) goto LAB_0810743d;
                    pHVar4 = local_2c->encoding;
                    pHVar3 = HTAtom_for("8bit");
                    if (pHVar4 == pHVar3) goto LAB_0810743d;
                    pHVar4 = local_2c->encoding;
                    pHVar3 = HTAtom_for("binary");
                    if (pHVar4 == pHVar3) goto LAB_0810743d;
                    pHVar4 = local_2c->encoding;
                    pHVar3 = HTAtom_for("7bit");
                    if (pHVar4 == pHVar3) goto LAB_0810743d;
                  }
                } while ((bVar1) || (local_2c->encoding == (HTAtom *)0x0));
                pHVar4 = local_2c->encoding;
                pHVar3 = HTAtom_for("identity");
              } while (pHVar4 == pHVar3);
              pHVar4 = local_2c->encoding;
              pHVar3 = HTAtom_for("8bit");
            } while (pHVar4 == pHVar3);
            pHVar4 = local_2c->encoding;
            pHVar3 = HTAtom_for("binary");
          } while (pHVar4 == pHVar3);
          pHVar4 = local_2c->encoding;
          pHVar3 = HTAtom_for("7bit");
        } while (pHVar4 == pHVar3);
        iVar2 = strcmp(encoding,local_2c->encoding->name);
      } while (iVar2 != 0);
LAB_0810743d:
      if (local_2c == (HTSuffix *)0x0) {
        suff = (HTSuffix *)calloc(1,0x14);
        if (suff == (HTSuffix *)0x0) {
          outofmem("../../../WWW/Library/Implementation/HTFile.c","HTSetSuffix");
        }
        if (HTSuffixes == (HTList *)0x0) {
          HTSuffixes = HTList_new();
        }
        HTList_addObject(HTSuffixes,suff);
        HTSACopy((char **)suff,suffix);
      }
    }
  }
  if (representation != (char *)0x0) {
    pHVar4 = HTAtom_for(representation);
    suff->rep = pHVar4;
  }
  pHVar4 = HTAtom_for(encoding);
  suff->encoding = pHVar4;
  HTSACopy(&suff->desc,desc);
  suff->quality = (float)value;
  return;
}



// WARNING: Unknown calling convention

char * HTCacheFileName(char *name)

{
  char *result;
  char *path;
  char *host;
  char *acc_method;
  
  acc_method = HTParse(name,"",0x10);
  host = HTParse(name,"",8);
  path = HTParse(name,"",5);
  result = (char *)0x0;
  HTSprintf0(&result,"%s/WWW/%s/%s%s",HTCacheRoot,acc_method,host,path);
  if (path != (char *)0x0) {
    free(path);
    path = (char *)0x0;
  }
  if (acc_method != (char *)0x0) {
    free(acc_method);
    acc_method = (char *)0x0;
  }
  if (host != (char *)0x0) {
    free(host);
  }
  return result;
}



char * HTURLPath_toFile(char *name,BOOLEAN expand_all,BOOLEAN is_remote)

{
  char *pcVar1;
  FILE *__stream;
  BOOLEAN is_remote_local;
  BOOLEAN expand_all_local;
  char *result;
  char *path;
  
  path = (char *)0x0;
  result = (char *)0x0;
  HTSACopy(&path,name);
  if (expand_all == '\0') {
    HTUnEscapeSome(path,"/");
  }
  else {
    HTUnEscape(path);
  }
  pcVar1 = path;
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"URLPath `%s\' means path `%s\'\n",name,pcVar1);
  }
  HTSACopy(&result,path);
  if (path != (char *)0x0) {
    free(path);
  }
  return result;
}



char * HTnameOfFile_WWW(char *name,BOOLEAN WWW_prefix,BOOLEAN expand_all)

{
  int iVar1;
  char *pcVar2;
  FILE *pFVar3;
  BOOLEAN expand_all_local;
  BOOLEAN WWW_prefix_local;
  char *result;
  char *home;
  char *path;
  char *host;
  char *acc_method;
  
  acc_method = HTParse(name,"",0x10);
  host = HTParse(name,"",8);
  path = HTParse(name,"",5);
  result = (char *)0x0;
  if (expand_all == '\0') {
    HTUnEscapeSome(path,"/");
  }
  else {
    HTUnEscape(path);
  }
  iVar1 = strcmp(acc_method,"file");
  if ((iVar1 == 0) || (*acc_method == '\0')) {
    pcVar2 = HTHostName();
    iVar1 = strcasecomp(host,pcVar2);
    if (iVar1 != 0) {
      iVar1 = strcasecomp(host,"localhost");
      if ((iVar1 != 0) && (*host != '\0')) {
        if (WWW_prefix == '\0') {
          HTSACopy(&result,path);
        }
        else {
          HTSprintf0(&result,"%s%s%s","/Net/",host,path);
          pcVar2 = result;
          if (WWW_TraceFlag != '\0') {
            pFVar3 = TraceFP();
            fprintf((FILE *)pFVar3,"Node `%s\' means file `%s\'\n",name,pcVar2);
          }
        }
        goto LAB_081078cc;
      }
    }
    if (WWW_TraceFlag != '\0') {
      pFVar3 = TraceFP();
      fprintf((FILE *)pFVar3,"Node `%s\' means path `%s\'\n",name,path);
    }
    HTSACopy(&result,path);
  }
  else if (WWW_prefix == '\0') {
    HTSACopy(&result,path);
  }
  else {
    home = LYGetEnv("HOME");
    if (home == (char *)0x0) {
      home = "/tmp";
    }
    HTSprintf0(&result,"%s/WWW/%s/%s%s",home,acc_method,host,path);
  }
LAB_081078cc:
  if (host != (char *)0x0) {
    free(host);
    host = (char *)0x0;
  }
  if (path != (char *)0x0) {
    free(path);
    path = (char *)0x0;
  }
  if (acc_method != (char *)0x0) {
    free(acc_method);
    acc_method = (char *)0x0;
  }
  pcVar2 = result;
  if (WWW_TraceFlag != '\0') {
    pFVar3 = TraceFP();
    fprintf((FILE *)pFVar3,"HTnameOfFile_WWW(%s,%d,%d) = %s\n",name,(int)WWW_prefix,(int)expand_all,
            pcVar2);
  }
  return result;
}



// WARNING: Unknown calling convention

char * WWW_nameOfFile(char *name)

{
  int iVar1;
  char *pcVar2;
  FILE *__stream;
  char *result;
  
  result = (char *)0x0;
  iVar1 = strncmp(HTMountRoot,name,5);
  if (iVar1 == 0) {
    HTSprintf0(&result,"%s//%s","file:",name + 5);
  }
  else {
    pcVar2 = HTHostName();
    HTSprintf0(&result,"%s//%s%s","file:",pcVar2,name);
  }
  pcVar2 = result;
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"File `%s\'\n\tmeans node `%s\'\n",name,pcVar2);
  }
  return result;
}



// WARNING: Unknown calling convention

char * HTFileSuffix(HTAtom *rep,char *enc)

{
  HTAtom *pHVar1;
  bool bVar2;
  int iVar3;
  char **ppcVar4;
  HTAtom *pHVar5;
  int iVar6;
  int i;
  int n;
  HTSuffix *suff;
  BOOLEAN trivial_enc;
  
  if ((((enc == (char *)0x0) || (*enc == '\0')) || (iVar3 = strcmp(enc,"identity"), iVar3 == 0)) ||
     (((iVar3 = strcmp(enc,"8bit"), iVar3 == 0 || (iVar3 = strcmp(enc,"binary"), iVar3 == 0)) ||
      (iVar3 = strcmp(enc,"7bit"), iVar3 == 0)))) {
    bVar2 = true;
  }
  else {
    bVar2 = false;
  }
  iVar3 = HTList_count(HTSuffixes);
  i = 0;
  while( true ) {
    if (iVar3 <= i) {
      return "";
    }
    ppcVar4 = (char **)HTList_objectAt(HTSuffixes,i);
    if (((HTAtom *)ppcVar4[1] == rep) &&
       (((bVar2 && (((ppcVar4[2] == (char *)0x0 ||
                     (pHVar1 = (HTAtom *)ppcVar4[2], pHVar5 = HTAtom_for("identity"),
                     pHVar1 == pHVar5)) ||
                    ((pHVar1 = (HTAtom *)ppcVar4[2], pHVar5 = HTAtom_for("8bit"), pHVar1 == pHVar5
                     || ((pHVar1 = (HTAtom *)ppcVar4[2], pHVar5 = HTAtom_for("binary"),
                         pHVar1 == pHVar5 ||
                         (pHVar1 = (HTAtom *)ppcVar4[2], pHVar5 = HTAtom_for("7bit"),
                         pHVar1 == pHVar5)))))))) ||
        ((!bVar2 &&
         (((((ppcVar4[2] != (char *)0x0 &&
             (pHVar1 = (HTAtom *)ppcVar4[2], pHVar5 = HTAtom_for("identity"), pHVar1 != pHVar5)) &&
            (pHVar1 = (HTAtom *)ppcVar4[2], pHVar5 = HTAtom_for("8bit"), pHVar1 != pHVar5)) &&
           ((pHVar1 = (HTAtom *)ppcVar4[2], pHVar5 = HTAtom_for("binary"), pHVar1 != pHVar5 &&
            (pHVar1 = (HTAtom *)ppcVar4[2], pHVar5 = HTAtom_for("7bit"), pHVar1 != pHVar5)))) &&
          (iVar6 = strcmp(enc,*(char **)(ppcVar4[2] + 4)), iVar6 == 0)))))))) break;
    i = i + 1;
  }
  return *ppcVar4;
}



// WARNING: Unknown calling convention

HTFormat HTFileFormat(char *filename,HTAtom **pencoding,char **pdesc)

{
  HTAtom *pHVar1;
  size_t sVar2;
  int iVar3;
  char **ppcVar4;
  size_t sVar5;
  int iVar6;
  size_t n_00;
  HTAtom *pHVar7;
  char *pcVar8;
  HTAtom *local_3c;
  HTSuffix *local_38;
  HTSuffix *local_34;
  HTAtom *local_30;
  HTAtom *local_2c;
  int ls2;
  int j;
  int ls;
  int lf;
  int i;
  int n;
  HTSuffix *suff;
  
  if (pencoding != (HTAtom **)0x0) {
    *pencoding = (HTAtom *)0x0;
  }
  if (pdesc != (char **)0x0) {
    *pdesc = (char *)0x0;
  }
  if (LYforce_HTML_mode == '\0') {
    sVar2 = strlen(filename);
    iVar3 = HTList_count(HTSuffixes);
    for (i = 0; i < iVar3; i = i + 1) {
      ppcVar4 = (char **)HTList_objectAt(HTSuffixes,i);
      sVar5 = strlen(*ppcVar4);
      if (((int)sVar5 <= (int)sVar2) &&
         (iVar6 = strcasecomp(*ppcVar4,filename + (sVar2 - sVar5)), iVar6 == 0)) {
        if (pencoding != (HTAtom **)0x0) {
          *pencoding = (HTAtom *)ppcVar4[2];
        }
        if (pdesc != (char **)0x0) {
          *pdesc = ppcVar4[3];
        }
        if (ppcVar4[1] != (char *)0x0) {
          return (HTFormat)ppcVar4[1];
        }
        for (j = 0; j < iVar3; j = j + 1) {
          ppcVar4 = (char **)HTList_objectAt(HTSuffixes,j);
          n_00 = strlen(*ppcVar4);
          if ((((int)(sVar5 + n_00) <= (int)sVar2) &&
              (iVar6 = strncasecomp(*ppcVar4,filename + ((sVar2 - sVar5) - n_00),n_00), iVar6 == 0))
             && (ppcVar4[1] != (char *)0x0)) {
            if ((pdesc != (char **)0x0) && (*pdesc == (char *)0x0)) {
              *pdesc = ppcVar4[3];
            }
            if (((pencoding != (HTAtom **)0x0) &&
                ((((*pencoding == (HTAtom *)0x0 ||
                   (pHVar1 = *pencoding, pHVar7 = HTAtom_for("identity"), pHVar1 == pHVar7)) ||
                  ((pHVar1 = *pencoding, pHVar7 = HTAtom_for("8bit"), pHVar1 == pHVar7 ||
                   ((pHVar1 = *pencoding, pHVar7 = HTAtom_for("binary"), pHVar1 == pHVar7 ||
                    (pHVar1 = *pencoding, pHVar7 = HTAtom_for("7bit"), pHVar1 == pHVar7)))))) &&
                 (pHVar1 = *pencoding, pHVar7 = HTAtom_for("7bit"), pHVar1 != pHVar7)))) &&
               ((((ppcVar4[2] != (char *)0x0 &&
                  (pHVar1 = (HTAtom *)ppcVar4[2], pHVar7 = HTAtom_for("identity"), pHVar1 != pHVar7)
                  ) && (pHVar1 = (HTAtom *)ppcVar4[2], pHVar7 = HTAtom_for("8bit"), pHVar1 != pHVar7
                       )) &&
                ((pHVar1 = (HTAtom *)ppcVar4[2], pHVar7 = HTAtom_for("binary"), pHVar1 != pHVar7 &&
                 (pHVar1 = (HTAtom *)ppcVar4[2], pHVar7 = HTAtom_for("7bit"), pHVar1 != pHVar7))))))
            {
              *pencoding = (HTAtom *)ppcVar4[2];
            }
            return (HTFormat)ppcVar4[1];
          }
        }
      }
    }
    pcVar8 = strchr(filename,0x2e);
    if (pcVar8 == (char *)0x0) {
      local_38 = &no_suffix;
    }
    else {
      if (unknown_suffix.rep == (HTAtom *)0x0) {
        local_34 = &no_suffix;
      }
      else {
        local_34 = &unknown_suffix;
      }
      local_38 = local_34;
    }
    if ((pencoding != (HTAtom **)0x0) && (*pencoding == (HTAtom *)0x0)) {
      if (local_38->encoding == (HTAtom *)0x0) {
        local_30 = HTAtom_for("binary");
      }
      else {
        local_30 = local_38->encoding;
      }
      *pencoding = local_30;
    }
    if (local_38->rep == (HTAtom *)0x0) {
      local_2c = HTAtom_for("application/octet-stream");
    }
    else {
      local_2c = local_38->rep;
    }
    local_3c = local_2c;
  }
  else {
    if (pencoding != (HTAtom **)0x0) {
      pHVar1 = HTAtom_for("8bit");
      *pencoding = pHVar1;
    }
    local_3c = HTAtom_for("text/html");
  }
  return local_3c;
}



// WARNING: Unknown calling convention

HTFormat HTCharsetFormat(HTFormat format,HTParentAnchor *anchor,int default_LYhndl)

{
  BOOLEAN BVar1;
  FILE *__stream;
  LYUCcharset *pLVar2;
  int iVar3;
  ushort **ppuVar4;
  char *pcVar5;
  char local_48;
  char local_44;
  char local_40;
  char *local_3c;
  LYUCcharset *p_out;
  LYUCcharset *p_in;
  int chndl;
  char *cp4;
  char *cp3;
  char *cp2;
  char *cp1;
  char *cp;
  BOOLEAN given_and_display_8859like;
  BOOLEAN given_is_8859like;
  BOOLEAN given_is_8859;
  BOOLEAN chartrans_ok;
  
  cp = (char *)0x0;
  cp3 = (char *)0x0;
  chartrans_ok = '\0';
  if (anchor->charset != (char *)0x0) {
    free(anchor->charset);
    anchor->charset = (char *)0x0;
  }
  HTSACopy(&cp,format->name);
  LYLowerCase(cp);
  cp1 = strchr(cp,0x3b);
  if (cp1 != (char *)0x0) {
    cp2 = strstr(cp1,"charset");
    if (cp2 != (char *)0x0) {
      if (WWW_TraceFlag != '\0') {
        pcVar5 = format->name;
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HTCharsetFormat: Extended MIME Content-Type is %s\n",pcVar5);
      }
      for (cp2 = cp2 + 7; (*cp2 == ' ' || (*cp2 == '=')); cp2 = cp2 + 1) {
      }
      HTSACopy(&cp3,cp2);
      local_3c = cp3;
      for (cp4 = cp3;
          (((*cp4 != '\0' && (*cp4 != '\"')) && (*cp4 != ';')) &&
          ((*cp4 != ':' && (0x20 < (byte)*cp4)))); cp4 = cp4 + 1) {
      }
      *cp4 = '\0';
      chndl = UCGetLYhndl_byMIME(cp3);
      BVar1 = UCCanTranslateFromTo(chndl,current_char_set);
      if (BVar1 == '\0') {
        if (chndl < 0) {
          chndl = UCLYhndl_for_unrec;
          if (UCLYhndl_for_unrec < 0) {
            chndl = UCLYhndl_for_unspec;
          }
          BVar1 = UCCanTranslateFromTo(chndl,current_char_set);
          if (BVar1 != '\0') {
            chartrans_ok = '\x01';
            HTAnchor_setUCInfoStage(anchor,chndl,0,1);
          }
        }
      }
      else {
        chartrans_ok = '\x01';
        *cp1 = '\0';
        format = HTAtom_for(cp);
        HTSACopy(&anchor->charset,local_3c);
        HTAnchor_setUCInfoStage(anchor,chndl,0,5);
      }
      if (chartrans_ok == '\0') {
        iVar3 = strncmp(local_3c,"iso-8859-",9);
        if (iVar3 == 0) {
          ppuVar4 = __ctype_b_loc();
          if (((*ppuVar4)[(byte)local_3c[9]] & 0x800) == 0) goto LAB_08108384;
          local_48 = '\x01';
        }
        else {
LAB_08108384:
          local_48 = '\0';
        }
        given_is_8859 = local_48;
        if (local_48 == '\0') {
          iVar3 = strncmp(local_3c,"windows-",8);
          if (iVar3 == 0) goto LAB_081083f5;
          iVar3 = strncmp(local_3c,"cp12",4);
          if (iVar3 == 0) goto LAB_081083f5;
          iVar3 = strncmp(local_3c,"cp-12",5);
          if (iVar3 == 0) goto LAB_081083f5;
          local_44 = '\0';
        }
        else {
LAB_081083f5:
          local_44 = '\x01';
        }
        given_is_8859like = local_44;
        if (local_44 == '\0') {
LAB_0810845b:
          local_40 = '\0';
        }
        else {
          pcVar5 = strstr(LYchar_set_names[current_char_set],"ISO-8859");
          if (pcVar5 == (char *)0x0) {
            pcVar5 = strstr(LYchar_set_names[current_char_set],"windows-");
            if (pcVar5 == (char *)0x0) goto LAB_0810845b;
          }
          local_40 = '\x01';
        }
        given_and_display_8859like = local_40;
        if (local_40 != '\0') {
          *cp1 = '\0';
          format = HTAtom_for(cp);
        }
        if (given_is_8859 != '\0') {
          for (cp1 = local_3c + 10; *cp1 != '\0'; cp1 = cp1 + 1) {
            ppuVar4 = __ctype_b_loc();
            if (((*ppuVar4)[(byte)*cp1] & 0x800) == 0) break;
          }
          *cp1 = '\0';
        }
        if (given_and_display_8859like != '\0') {
          HTSACopy(&anchor->charset,local_3c);
          HTPassEightBitRaw = '\x01';
        }
        if (*local_3c == '\0') {
          local_3c = anchor->charset;
        }
        else {
        }
        HTAlert(local_3c);
      }
      else {
        pLVar2 = HTAnchor_getUCInfoStage(anchor,0);
        p_out = HTAnchor_setUCInfoStage(anchor,current_char_set,3,1);
        if (p_out == (LYUCcharset *)0x0) {
          p_out = HTAnchor_getUCInfoStage(anchor,3);
        }
        iVar3 = strcmp(pLVar2->MIMEname,"x-transparent");
        if (iVar3 == 0) {
          HTPassEightBitRaw = '\x01';
          iVar3 = HTAnchor_getUCLYhndl(anchor,3);
          HTAnchor_setUCInfoStage(anchor,iVar3,0,1);
        }
        iVar3 = strcmp(p_out->MIMEname,"x-transparent");
        if (iVar3 == 0) {
          HTPassEightBitRaw = '\x01';
          iVar3 = HTAnchor_getUCLYhndl(anchor,0);
          HTAnchor_setUCInfoStage(anchor,iVar3,3,1);
        }
        if (pLVar2->enc == 5) {
          if (p_out->enc == 5) {
            Set_HTCJK(pLVar2->MIMEname,p_out->MIMEname);
          }
        }
        else {
          HTCJK = NOCJK;
          if (((pLVar2->codepoints & 1U) == 0) && (chndl == current_char_set)) {
            HTPassEightBitRaw = '\x01';
          }
        }
      }
      if (cp3 != (char *)0x0) {
        free(cp3);
        cp3 = (char *)0x0;
      }
      goto LAB_08108549;
    }
  }
  if (cp1 != (char *)0x0) {
    *cp1 = '\0';
    format = HTAtom_for(cp);
  }
LAB_08108549:
  if (cp != (char *)0x0) {
    free(cp);
    cp = (char *)0x0;
  }
  if (((chartrans_ok == '\0') && (anchor->charset == (char *)0x0)) && (-1 < default_LYhndl)) {
    HTAnchor_setUCInfoStage(anchor,default_LYhndl,0,1);
  }
  HTAnchor_copyUCInfoStage(anchor,1,0,-1);
  return format;
}



// WARNING: Unknown calling convention

void LYGetFileInfo(char *filename,HTParentAnchor **pfile_anchor,HTFormat *pformat,HTAtom **pencoding
                  ,char **pdesc,char **pcharset,int *pfile_cs)

{
  char *pcVar1;
  HTParentAnchor *anchor;
  int iVar2;
  FILE *__stream;
  char *local_34;
  undefined *local_30;
  undefined *local_2c;
  undefined *local_28;
  int file_cs;
  char *file_csname;
  HTParentAnchor *file_anchor;
  HTAtom *myEnc;
  HTFormat format;
  char *Aname;
  char *Afn;
  
  Aname = (char *)0x0;
  myEnc = (HTAtom *)0x0;
  Afn = HTEscape(filename,'\x04');
  LYLocalFileToURL(&Aname,Afn);
  anchor = HTAnchor_findSimpleAddress(Aname);
  file_csname = anchor->charset;
  format = HTFileFormat(filename,&myEnc,pdesc);
  format = HTCharsetFormat(format,anchor,UCLYhndl_HTFile_for_unspec);
  iVar2 = HTAnchor_getUCLYhndl(anchor,0);
  if (file_csname == (char *)0x0) {
    if (iVar2 < 0) {
      file_csname = "display character set";
    }
    else {
      file_csname = LYCharSet_UC[iVar2].MIMEname;
    }
  }
  if (WWW_TraceFlag == '\0') goto LAB_08108757;
  pcVar1 = format->name;
  if (myEnc == (HTAtom *)0x0) {
    local_34 = "";
LAB_081086d2:
    if (myEnc == (HTAtom *)0x0) {
      if (*format->name == 'a') {
        local_28 = &DAT_08180872;
      }
      else {
        local_28 = &DAT_08180464;
      }
      local_2c = local_28;
    }
    else {
      local_2c = &DAT_08180464;
    }
    local_30 = local_2c;
  }
  else {
    local_34 = myEnc->name;
    if (*myEnc->name != '8') goto LAB_081086d2;
    local_30 = &DAT_08180872;
  }
  __stream = TraceFP();
  fprintf((FILE *)__stream,"GetFileInfo: \'%s\' is a%s %s %s file, charset=%s (%d).\n",filename,
          local_30,local_34,pcVar1,file_csname,iVar2);
LAB_08108757:
  if (Afn != (char *)0x0) {
    free(Afn);
    Afn = (char *)0x0;
  }
  if (Aname != (char *)0x0) {
    free(Aname);
  }
  if (pfile_anchor != (HTParentAnchor **)0x0) {
    *pfile_anchor = anchor;
  }
  if (pformat != (HTFormat *)0x0) {
    *pformat = format;
  }
  if (pencoding != (HTAtom **)0x0) {
    *pencoding = myEnc;
  }
  if (pcharset != (char **)0x0) {
    *pcharset = file_csname;
  }
  if (pfile_cs != (int *)0x0) {
    *pfile_cs = iVar2;
  }
  return;
}



// WARNING: Unknown calling convention

float HTFileValue(char *filename)

{
  char *pcVar1;
  size_t sVar2;
  int iVar3;
  char **ppcVar4;
  size_t sVar5;
  int iVar6;
  FILE *__stream;
  int ls;
  int lf;
  int i;
  int n;
  HTSuffix *suff;
  
  sVar2 = strlen(filename);
  iVar3 = HTList_count(HTSuffixes);
  i = 0;
  while( true ) {
    if (iVar3 <= i) {
      return 0.3;
    }
    ppcVar4 = (char **)HTList_objectAt(HTSuffixes,i);
    sVar5 = strlen(*ppcVar4);
    if (((int)sVar5 <= (int)sVar2) &&
       (iVar6 = strcmp(*ppcVar4,filename + (sVar2 - sVar5)), iVar6 == 0)) break;
    i = i + 1;
  }
  if (WWW_TraceFlag != '\0') {
    pcVar1 = ppcVar4[4];
    __stream = TraceFP();
    fprintf((FILE *)__stream,"File: Value of %s is %.3f\n",filename,(double)(float)pcVar1);
  }
  return (float)ppcVar4[4];
}



// WARNING: Unknown calling convention

CompressFileType HTCompressFileType(char *filename,char *dots,int *rootlen)

{
  size_t sVar1;
  int iVar2;
  char *pcVar3;
  FILE *__stream;
  char *ftype;
  size_t len;
  CompressFileType result;
  
  result = cftNone;
  sVar1 = strlen(filename);
  ftype = filename + sVar1;
  if (4 < sVar1) {
    iVar2 = strcasecomp(ftype + -3,"bz2");
    if (iVar2 == 0) {
      pcVar3 = strchr(dots,(int)ftype[-4]);
      if (pcVar3 != (char *)0x0) {
        result = cftBzip2;
        ftype = ftype + -4;
        goto LAB_08108a16;
      }
    }
  }
  if (3 < sVar1) {
    iVar2 = strcasecomp(ftype + -2,"gz");
    if (iVar2 == 0) {
      pcVar3 = strchr(dots,(int)ftype[-3]);
      if (pcVar3 != (char *)0x0) {
        result = cftGzip;
        ftype = ftype + -3;
        goto LAB_08108a16;
      }
    }
  }
  if (3 < sVar1) {
    iVar2 = strcasecomp(ftype + -2,"zz");
    if (iVar2 == 0) {
      pcVar3 = strchr(dots,(int)ftype[-3]);
      if (pcVar3 != (char *)0x0) {
        result = cftDeflate;
        ftype = ftype + -3;
        goto LAB_08108a16;
      }
    }
  }
  if (2 < sVar1) {
    iVar2 = strcmp(ftype + -1,"Z");
    if (iVar2 == 0) {
      pcVar3 = strchr(dots,(int)ftype[-2]);
      if (pcVar3 != (char *)0x0) {
        result = cftCompress;
        ftype = ftype + -2;
      }
    }
  }
LAB_08108a16:
  *rootlen = (int)ftype - (int)filename;
  if (WWW_TraceFlag != '\0') {
    iVar2 = *rootlen;
    __stream = TraceFP();
    fprintf((FILE *)__stream,"HTCompressFileType(%s) returns %d:%s\n",filename,result,
            filename + iVar2);
  }
  return result;
}



// WARNING: Unknown calling convention

char * HTCompressTypeToSuffix(CompressFileType method)

{
  char *result;
  
  if (method == cftGzip) {
    result = ".gz";
    return result;
  }
  if (method < cftBzip2) {
    if (method == cftCompress) {
      result = ".Z";
      return result;
    }
  }
  else {
    if (method == cftBzip2) {
      result = ".bz2";
      return result;
    }
    if (method == cftDeflate) {
      result = ".zz";
      return result;
    }
  }
  result = "";
  return result;
}



// WARNING: Unknown calling convention

char * HTCompressTypeToEncoding(CompressFileType method)

{
  char *result;
  
  if (method == cftGzip) {
    result = "gzip";
    return result;
  }
  if (method < cftBzip2) {
    if (method == cftCompress) {
      result = "compress";
      return result;
    }
  }
  else {
    if (method == cftBzip2) {
      result = "bzip2";
      return result;
    }
    if (method == cftDeflate) {
      result = "deflate";
      return result;
    }
  }
  return (char *)0x0;
}



// WARNING: Unknown calling convention

CompressFileType HTEncodingToCompressType(char *coding)

{
  int iVar1;
  CompressFileType result;
  
  if (coding == (char *)0x0) {
    result = cftNone;
  }
  else {
    iVar1 = strcasecomp(coding,"gzip");
    if ((iVar1 != 0) && (iVar1 = strcasecomp(coding,"x-gzip"), iVar1 != 0)) {
      iVar1 = strcasecomp(coding,"compress");
      if ((iVar1 == 0) || (iVar1 = strcasecomp(coding,"x-compress"), iVar1 == 0)) {
        return cftCompress;
      }
      iVar1 = strcasecomp(coding,"bzip2");
      if ((iVar1 == 0) || (iVar1 = strcasecomp(coding,"x-bzip2"), iVar1 == 0)) {
        return cftBzip2;
      }
      iVar1 = strcasecomp(coding,"deflate");
      if ((iVar1 != 0) && (iVar1 = strcasecomp(coding,"x-deflate"), iVar1 != 0)) {
        return cftNone;
      }
      return cftDeflate;
    }
    result = cftGzip;
  }
  return result;
}



// WARNING: Unknown calling convention

CompressFileType HTContentTypeToCompressType(char *ct)

{
  int iVar1;
  CompressFileType method;
  
  if (ct == (char *)0x0) {
    method = cftNone;
  }
  else {
    iVar1 = strncasecomp(ct,"application/gzip",0x10);
    if ((iVar1 != 0) && (iVar1 = strncasecomp(ct,"application/x-gzip",0x12), iVar1 != 0)) {
      iVar1 = strncasecomp(ct,"application/compress",0x14);
      if ((iVar1 != 0) && (iVar1 = strncasecomp(ct,"application/x-compress",0x16), iVar1 != 0)) {
        iVar1 = strncasecomp(ct,"application/bzip2",0x11);
        if ((iVar1 != 0) && (iVar1 = strncasecomp(ct,"application/x-bzip2",0x13), iVar1 != 0)) {
          return cftNone;
        }
        return cftBzip2;
      }
      return cftCompress;
    }
    method = cftGzip;
  }
  return method;
}



// WARNING: Unknown calling convention

CompressFileType HTContentToCompressType(HTParentAnchor *anchor)

{
  char *ct_00;
  char *coding;
  char *ce;
  char *ct;
  CompressFileType method;
  
  method = cftNone;
  ct_00 = HTAnchor_content_type(anchor);
  coding = HTAnchor_content_encoding(anchor);
  if ((coding == (char *)0x0) && (ct_00 != (char *)0x0)) {
    method = HTContentTypeToCompressType(ct_00);
  }
  else if (coding != (char *)0x0) {
    method = HTEncodingToCompressType(coding);
  }
  return method;
}



// WARNING: Unknown calling convention

BOOLEAN HTEditable(char *filename)

{
  gid_t gVar1;
  __mode_t _Var2;
  int iVar3;
  __uid_t _Var4;
  FILE *pFVar5;
  __uid_t _Var6;
  __gid_t _Var7;
  __uid_t _Var8;
  int iVar9;
  BOOLEAN BStack_40085;
  gid_t groups [65536];
  stat fileStatus;
  int i2;
  int i;
  int ngroups;
  uid_t myUid;
  
  iVar3 = stat64(filename,(stat64 *)&fileStatus);
  if (iVar3 == 0) {
    iVar3 = getgroups(0x10000,groups);
    _Var4 = geteuid();
    _Var7 = fileStatus.st_gid;
    _Var6 = fileStatus.st_uid;
    _Var2 = fileStatus.st_mode;
    if (WWW_TraceFlag != '\0') {
      pFVar5 = TraceFP();
      _Var8 = _Var4;
      iVar9 = iVar3;
      fprintf((FILE *)pFVar5,"File mode is 0%o, uid=%d, gid=%d. My uid=%d, %d groups (",_Var2,_Var6,
              _Var7,_Var4,iVar3);
      for (i2 = 0; i2 < iVar3; i2 = i2 + 1) {
        gVar1 = groups[i2];
        pFVar5 = TraceFP();
        fprintf((FILE *)pFVar5," %d",gVar1,_Var6,_Var7,_Var8,iVar9);
      }
      pFVar5 = TraceFP();
      fwrite(&DAT_081809fd,1,2,(FILE *)pFVar5);
    }
    if ((fileStatus.st_mode & 2) == 0) {
      if (((fileStatus.st_mode & 0x80) == 0) || (fileStatus.st_uid != _Var4)) {
        if ((fileStatus.st_mode & 0x10) != 0) {
          for (i = 0; i < iVar3; i = i + 1) {
            if (groups[i] == fileStatus.st_gid) {
              return '\x01';
            }
          }
        }
        if (WWW_TraceFlag != '\0') {
          pFVar5 = TraceFP();
          fprintf((FILE *)pFVar5,"\tFile is not editable.\n");
        }
        BStack_40085 = '\0';
      }
      else {
        BStack_40085 = '\x01';
      }
    }
    else {
      BStack_40085 = '\x01';
    }
  }
  else {
    BStack_40085 = '\0';
  }
  return BStack_40085;
}



// WARNING: Unknown calling convention

HTStream * HTFileSaveStream(HTParentAnchor *anchor)

{
  char *__filename;
  FILE *fp_00;
  HTStream_conflict *local_18;
  FILE *fp;
  char *localname;
  char *addr;
  
  __filename = HTnameOfFile_WWW(anchor->address,'\x01','\x01');
  fp_00 = fopen64(__filename,"wb");
  if (__filename != (char *)0x0) {
    free(__filename);
  }
  if (fp_00 == (FILE *)0x0) {
    local_18 = (HTStream_conflict *)0x0;
  }
  else {
    local_18 = HTFWriter_new((FILE *)fp_00);
  }
  return (HTStream *)local_18;
}



// WARNING: Unknown calling convention

void HTDirEntry(HTStructured_conflict *target,char *tail,char *entry)

{
  int iVar1;
  size_t sVar2;
  ushort **ppuVar3;
  bool bVar4;
  char *local_20;
  undefined *local_18;
  int len;
  char *escaped;
  char *stripped;
  char *relative;
  
  relative = (char *)0x0;
  stripped = (char *)0x0;
  escaped = (char *)0x0;
  HTSACopy(&escaped,entry);
  LYTrimPathSep(escaped);
  iVar1 = strcmp(escaped,"..");
  if (iVar1 != 0) {
    stripped = escaped;
    escaped = HTEscape(escaped,'\x02');
    sVar2 = strlen(escaped);
    if (((2 < (int)sVar2) && (escaped[sVar2 - 3] == '%')) && (escaped[sVar2 - 2] == '2')) {
      ppuVar3 = __ctype_b_loc();
      if (((*ppuVar3)[(byte)escaped[sVar2 - 1]] & 0x200) == 0) {
        bVar4 = escaped[sVar2 - 1] == 'F';
      }
      else {
        iVar1 = toupper((uint)(byte)escaped[sVar2 - 1]);
        bVar4 = iVar1 == 0x46;
      }
      if (bVar4) {
        escaped[sVar2 - 3] = '\0';
      }
    }
  }
  if ((tail == (char *)0x0) || (*tail == '\0')) {
    if (*escaped == '\0') {
      local_20 = "/";
    }
    else {
      local_20 = escaped;
    }
    HTStartAnchor(target,(char *)0x0,local_20);
  }
  else {
    relative = (char *)0x0;
    if (*escaped == '\0') {
      local_18 = &DAT_08180464;
    }
    else {
      local_18 = &DAT_081806fc;
    }
    HTSprintf0(&relative,"%s%s%s",tail,local_18,escaped);
    HTStartAnchor(target,(char *)0x0,relative);
    if (relative != (char *)0x0) {
      free(relative);
      relative = (char *)0x0;
    }
  }
  if (stripped != (char *)0x0) {
    free(stripped);
    stripped = (char *)0x0;
  }
  if (escaped != (char *)0x0) {
    free(escaped);
  }
  return;
}



// WARNING: Unknown calling convention

BOOLEAN view_structured(HTFormat format_out)

{
  HTAtom *pHVar1;
  BOOLEAN result;
  
  if ((psrc_view == '\0') && (pHVar1 = HTAtom_for("www/dump"), pHVar1 != format_out)) {
    return '\0';
  }
  return '\x01';
}



// WARNING: Unknown calling convention

void HTStructured_doctype(HTStructured_conflict *target,HTFormat format_out)

{
  BOOLEAN BVar1;
  
  BVar1 = view_structured(format_out);
  if (BVar1 != '\0') {
    (*target->isa->put_string)
              (target,"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">\n");
  }
  return;
}



// WARNING: Unknown calling convention

void HTStructured_meta(HTStructured_conflict *target,HTFormat format_out)

{
  BOOLEAN BVar1;
  
  BVar1 = view_structured(format_out);
  if (BVar1 != '\0') {
    (*target->isa->put_string)
              (target,
               "<meta http-equiv=\"Content-Type\" content=\"text/html; charset=iso-8859-1\">\n");
  }
  return;
}



BOOLEAN HTDirTitles(HTStructured_conflict *target,HTParentAnchor *anchor,HTFormat format_out,
                   BOOLEAN tildeIsTop)

{
  _func_void_HTStructured_ptr_char_ptr_conflict *p_Var1;
  BOOLEAN BVar2;
  int iVar3;
  ushort **ppuVar4;
  char *pcVar5;
  char *local_60;
  char *local_58;
  char *local_50;
  char *local_48;
  char *local_40;
  BOOLEAN tildeIsTop_local;
  char *fullparentpath;
  DIR *dp;
  char *printable;
  char *parent;
  int i;
  char *cp;
  char *current;
  char *path;
  char *logical;
  BOOLEAN need_parent_link;
  
  logical = anchor->address;
  path = HTParse(logical,"",5);
  cp = (char *)0x0;
  need_parent_link = '\0';
  if ((tildeIsTop != '\0') && (iVar3 = strncmp(path,"/~",2), iVar3 == 0)) {
    if (path[2] == '\0') {
      path[1] = '\0';
    }
    else {
      for (i = 0; path[i + 2] != '\0'; i = i + 1) {
        path[i] = path[i + 2];
      }
      path[i] = '\0';
    }
  }
  cp = strrchr(path,0x3b);
  if (cp == (char *)0x0) goto LAB_0810946b;
  iVar3 = strncasecomp(cp + 1,"type=",5);
  if (iVar3 != 0) goto LAB_08109464;
  ppuVar4 = __ctype_b_loc();
  if (((*ppuVar4)[(byte)cp[6]] & 0x200) == 0) {
    if (cp[6] != 'D') goto LAB_081093c0;
LAB_0810945e:
    *cp = '\0';
  }
  else {
    iVar3 = toupper((uint)(byte)cp[6]);
    if (iVar3 == 0x44) goto LAB_0810945e;
LAB_081093c0:
    ppuVar4 = __ctype_b_loc();
    if (((*ppuVar4)[(byte)cp[6]] & 0x200) == 0) {
      if (cp[6] != 'A') goto LAB_0810940f;
      goto LAB_0810945e;
    }
    iVar3 = toupper((uint)(byte)cp[6]);
    if (iVar3 == 0x41) goto LAB_0810945e;
LAB_0810940f:
    ppuVar4 = __ctype_b_loc();
    if (((*ppuVar4)[(byte)cp[6]] & 0x200) == 0) {
      if (cp[6] == 'I') goto LAB_0810945e;
    }
    else {
      iVar3 = toupper((uint)(byte)cp[6]);
      if (iVar3 == 0x49) goto LAB_0810945e;
    }
  }
LAB_08109464:
  cp = (char *)0x0;
LAB_0810946b:
  current = LYPathLeaf(path);
  printable = (char *)0x0;
  iVar3 = strncasecomp(path,"/%2F",4);
  if (iVar3 == 0) {
    local_60 = path + 1;
  }
  else {
    local_60 = path;
  }
  printable = HTURLPath_toFile(local_60,'\x01','\x01');
  iVar3 = strncasecomp(printable,"/vmsysu:",8);
  if ((iVar3 == 0) || (iVar3 = strncasecomp(printable,"/anonymou.",10), iVar3 == 0)) {
    HTSACopy(&cp,printable + 1);
    HTSACopy(&printable,cp);
    if (cp != (char *)0x0) {
      free(cp);
      cp = (char *)0x0;
    }
  }
  HTStructured_doctype(target,format_out);
  (*target->isa->start_element)(target,0x35,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
  (*target->isa->put_character)(target,'\n');
  (*target->isa->start_element)(target,0x6e,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
  p_Var1 = target->isa->put_string;
  if (*printable == '\0') {
    local_58 = (char *)gettext("Welcome");
  }
  else {
    local_58 = printable;
  }
  (*p_Var1)(target,local_58);
  p_Var1 = target->isa->put_string;
  pcVar5 = (char *)gettext(" directory");
  (*p_Var1)(target,pcVar5);
  (*target->isa->end_element)(target,0x6e,(char **)0x0);
  (*target->isa->put_character)(target,'\n');
  HTStructured_meta(target,format_out);
  (*target->isa->end_element)(target,0x35,(char **)0x0);
  (*target->isa->put_character)(target,'\n');
  (*target->isa->start_element)(target,0x11,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
  (*target->isa->put_character)(target,'\n');
  (*target->isa->start_element)(target,0x30,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
  p_Var1 = target->isa->put_string;
  if (*printable == '\0') {
    local_50 = "";
  }
  else {
    local_50 = (char *)gettext("Current directory is ");
  }
  (*p_Var1)(target,local_50);
  p_Var1 = target->isa->put_string;
  if (*printable == '\0') {
    local_48 = (char *)gettext("Welcome");
  }
  else {
    local_48 = printable;
  }
  (*p_Var1)(target,local_48);
  (*target->isa->end_element)(target,0x30,(char **)0x0);
  (*target->isa->put_character)(target,'\n');
  iVar3 = strncasecomp(printable,"vmsysu:",7);
  if ((((iVar3 == 0) && (cp = strchr(printable,0x2e), cp != (char *)0x0)) &&
      (pcVar5 = strchr(cp,0x2f), pcVar5 == (char *)0x0)) ||
     ((iVar3 = strncasecomp(printable,"anonymou.",9), iVar3 == 0 &&
      (pcVar5 = strchr(printable,0x2f), pcVar5 == (char *)0x0)))) {
    if (printable != (char *)0x0) {
      free(printable);
      printable = (char *)0x0;
    }
    if (path != (char *)0x0) {
      free(path);
    }
    return need_parent_link;
  }
  if (printable != (char *)0x0) {
    free(printable);
    printable = (char *)0x0;
  }
  if (((current != path && -1 < (int)current - (int)path) && (current[-1] == '/')) &&
     (*current != '\0')) {
    parent = (char *)0x0;
    printable = (char *)0x0;
    current[-1] = '\0';
    parent = strrchr(path,0x2f);
    if (((parent != (char *)0x0) &&
        ((iVar3 = strcmp(parent,"/.."), iVar3 == 0 ||
         (iVar3 = strncasecomp(parent,"/%2F",4), iVar3 == 0)))) ||
       (iVar3 = strncasecomp(current,"%2F",3), iVar3 == 0)) {
      if (path != (char *)0x0) {
        free(path);
      }
      return need_parent_link;
    }
    printable = (char *)0x0;
    HTSprintf0(&printable,"%s/..",current);
    dp = (DIR *)0x0;
    BVar2 = LYisLocalFile(logical);
    if (BVar2 != '\0') {
      fullparentpath = (char *)0x0;
      if (*path == '\0') {
        local_40 = "/";
      }
      else {
        local_40 = path;
      }
      HTSACopy(&fullparentpath,local_40);
      iVar3 = strcmp(current,"..");
      if (iVar3 == 0) {
        HTSACat(&fullparentpath,"/../..");
      }
      else {
        iVar3 = strcmp(current,".");
        if (iVar3 == 0) {
          HTSACat(&fullparentpath,"/..");
        }
      }
      HTUnEscape(fullparentpath);
      dp = (DIR *)opendir(fullparentpath);
      if (dp == (DIR *)0x0) {
        if (fullparentpath != (char *)0x0) {
          free(fullparentpath);
          fullparentpath = (char *)0x0;
        }
        if (printable != (char *)0x0) {
          free(printable);
          printable = (char *)0x0;
        }
        if (path != (char *)0x0) {
          free(path);
        }
        return need_parent_link;
      }
      closedir((DIR *)dp);
      if (fullparentpath != (char *)0x0) {
        free(fullparentpath);
        fullparentpath = (char *)0x0;
      }
      need_parent_link = '\x01';
      if (path != (char *)0x0) {
        free(path);
        path = (char *)0x0;
      }
      if (printable != (char *)0x0) {
        free(printable);
      }
      return need_parent_link;
    }
    HTStartAnchor(target,"",printable);
    if (printable != (char *)0x0) {
      free(printable);
      printable = (char *)0x0;
    }
    p_Var1 = target->isa->put_string;
    pcVar5 = (char *)gettext("Up to ");
    (*p_Var1)(target,pcVar5);
    if (parent == (char *)0x0) {
      (*target->isa->put_character)(target,'/');
    }
    else {
      iVar3 = strcmp(current,".");
      if ((iVar3 == 0) || (iVar3 = strcmp(current,".."), iVar3 == 0)) {
        (*target->isa->put_string)(target,"..");
      }
      else {
        fullparentpath = (char *)0x0;
        HTSACopy(&fullparentpath,parent + 1);
        HTUnEscape(fullparentpath);
        (*target->isa->put_string)(target,fullparentpath);
        if (fullparentpath != (char *)0x0) {
          free(fullparentpath);
          fullparentpath = (char *)0x0;
        }
      }
    }
    (*target->isa->end_element)(target,0,(char **)0x0);
    (*target->isa->put_character)(target,'\n');
  }
  if (path != (char *)0x0) {
    free(path);
  }
  return need_parent_link;
}



// WARNING: Variable defined which should be unmapped: targetClass
// WARNING: Unknown calling convention

void do_readme(HTStructured_conflict *target,char *localname)

{
  int iVar1;
  HTStructuredClass_conflict targetClass;
  int ch;
  char *readme_file_name;
  FILE *fp;
  
  readme_file_name = (char *)0x0;
  HTSprintf0(&readme_file_name,"%s/%s",localname,"README");
  fp = (FILE *)fopen64(readme_file_name,"r");
  if (fp != (FILE *)0x0) {
    (*target->isa->start_element)(target,0x56,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
    while( true ) {
      iVar1 = fgetc((FILE *)fp);
      if (iVar1 == -1) break;
      (*target->isa->put_character)(target,(char)iVar1);
    }
    (*target->isa->end_element)(target,0x56,(char **)0x0);
    HTDisplayPartial();
    fclose((FILE *)fp);
  }
  if (readme_file_name != (char *)0x0) {
    free(readme_file_name);
  }
  return;
}



// WARNING: Unknown calling convention

char * file_type(char *path)

{
  char *type;
  
  for (; *path == '.'; path = path + 1) {
  }
  type = strchr(path,0x2e);
  if (type == (char *)0x0) {
    type = "";
  }
  return type;
}



// WARNING: Unknown calling convention

int dired_cmp(void *a,void *b)

{
  char *__s2;
  char *__s1;
  int local_58;
  int local_30;
  int local_2c;
  uint local_28;
  uint local_24;
  uint local_20;
  int code;
  DIRED *q;
  DIRED *p;
  
  code = (int)*(char *)((int)a + 0x60) - (int)*(char *)((int)b + 0x60);
  if (code == 0) {
    switch(dir_list_order) {
    default:
      code = 0;
      break;
    case 1:
      if ((*(int *)((int)a + 0x30) < *(int *)((int)b + 0x30)) ||
         ((*(int *)((int)a + 0x30) <= *(int *)((int)b + 0x30) &&
          (*(uint *)((int)a + 0x2c) < *(uint *)((int)b + 0x2c))))) {
        local_58 = 1;
      }
      else {
        local_30 = 1;
        if ((*(int *)((int)a + 0x30) <= *(int *)((int)b + 0x30)) &&
           ((*(int *)((int)a + 0x30) < *(int *)((int)b + 0x30) ||
            (*(uint *)((int)a + 0x2c) <= *(uint *)((int)b + 0x2c))))) {
          local_30 = 0;
        }
        local_58 = -local_30;
      }
      code = local_58;
      break;
    case 2:
      if (*(int *)((int)a + 0x48) < *(int *)((int)b + 0x48)) {
        local_2c = 1;
      }
      else {
        local_2c = -(uint)(*(int *)((int)b + 0x48) < *(int *)((int)a + 0x48));
      }
      code = local_2c;
      break;
    case 3:
      if (*(uint *)((int)a + 0x10) < *(uint *)((int)b + 0x10)) {
        local_28 = 0xffffffff;
      }
      else {
        local_28 = (uint)(*(uint *)((int)b + 0x10) < *(uint *)((int)a + 0x10));
      }
      code = local_28;
      break;
    case 4:
      __s2 = file_type((char *)((int)b + 0x61));
      __s1 = file_type((char *)((int)a + 0x61));
      code = strcmp(__s1,__s2);
      break;
    case 5:
      if (*(uint *)((int)a + 0x18) < *(uint *)((int)b + 0x18)) {
        local_24 = 0xffffffff;
      }
      else {
        local_24 = (uint)(*(uint *)((int)b + 0x18) < *(uint *)((int)a + 0x18));
      }
      code = local_24;
      break;
    case 6:
      if (*(uint *)((int)a + 0x1c) < *(uint *)((int)b + 0x1c)) {
        local_20 = 0xffffffff;
      }
      else {
        local_20 = (uint)(*(uint *)((int)b + 0x1c) < *(uint *)((int)a + 0x1c));
      }
      code = local_20;
    }
  }
  if (code == 0) {
    code = strcmp((char *)((int)a + 0x61),(char *)((int)b + 0x61));
  }
  return code;
}



int print_local_dir(DIR *dp,char *localname,HTParentAnchor *anchor,HTFormat format_out,
                   HTStream *sink)

{
  int iVar1;
  _func_void_HTStructured_ptr_HTError *p_Var2;
  DIRED *data_00;
  _func_void_HTStructured_ptr_char_ptr_conflict *p_Var3;
  FILE *pFVar4;
  int iVar5;
  HTAtom *form;
  char *pcVar6;
  size_t sVar7;
  stat64 *__buf;
  wchar_t wVar8;
  int in_GS_OFFSET;
  int local_11c;
  char local_116;
  char local_115;
  char *local_110;
  int local_10c;
  HTStream *sink_local;
  HTFormat format_out_local;
  HTParentAnchor *anchor_local;
  char *localname_local;
  DIR *dp_local;
  stat link_info;
  HTStructuredClass_conflict targetClass;
  DIRED *entry;
  int num_of_entries_output;
  HTBTElement *next_element;
  DIRED *data;
  int num_of_entries;
  stat *actual_info;
  int i;
  int status;
  char *tmpfilename;
  char *p;
  char *tail;
  char *pathname;
  dirent *dirbuf;
  HTBTree *bt;
  HTStructured_conflict *target;
  char test;
  char state;
  BOOLEAN preformatted;
  BOOLEAN need_parent_link;
  BOOLEAN present [25];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  pathname = (char *)0x0;
  tail = (char *)0x0;
  tmpfilename = (char *)0x0;
  need_parent_link = '\0';
  preformatted = '\0';
  num_of_entries = 0;
  if (WWW_TraceFlag != '\0') {
    pFVar4 = TraceFP();
    fprintf((FILE *)pFVar4,"print_local_dir() started\n");
  }
  pathname = HTParse(anchor->address,"",5);
  p = strrchr(pathname,0x2f);
  if (p == (char *)0x0) {
    p = "/";
  }
  HTSACopy(&tail,p + 1);
  if (pathname != (char *)0x0) {
    free(pathname);
    pathname = (char *)0x0;
  }
  if (-1 < UCLYhndl_HTFile_for_unspec) {
    HTAnchor_setUCInfoStage(anchor,UCLYhndl_HTFile_for_unspec,1,1);
  }
  target = (HTStructured_conflict *)HTML_new(anchor,format_out,(HTStream_conflict *)sink);
  p_Var2 = ((HTStructured *)target)->isa->_abort;
  for (i = 0; i < 0x19; i = i + 1) {
    present[i] = i == 6;
  }
  need_parent_link = HTDirTitles(target,anchor,format_out,'\0');
  if ((*anchor->address == 'l') || (*anchor->address == 'L')) {
    iVar5 = strncasecomp(anchor->address,"lynxcgi:",8);
    if (iVar5 == 0) goto LAB_0810a2bf;
  }
  form = HTAtom_for("www/dired");
  HTAnchor_setFormat(anchor,form);
  lynx_edit_mode = '\x01';
LAB_0810a2bf:
  if (HTDirReadme == 1) {
    do_readme(target,localname);
  }
  bt = HTBTree_new(dired_cmp);
  mustshow = '\x01';
  pcVar6 = (char *)gettext("Reading directory...");
  HTProgress(pcVar6);
  status = 200;
  while( true ) {
    dirbuf = (dirent *)readdir64((DIR *)dp);
    if (dirbuf == (dirent *)0x0) break;
    if ((*(uint *)&((dirent64 *)dirbuf)->d_ino | *(uint *)((int)&((dirent64 *)dirbuf)->d_ino + 4))
        != 0) {
      iVar5 = strcmp(((dirent64 *)dirbuf)->d_name,".");
      if (iVar5 != 0) {
        iVar5 = strcmp(dirbuf->d_name,"..");
        if ((iVar5 != 0) || (need_parent_link != '\0')) {
          iVar5 = strcmp(dirbuf->d_name,"..");
          if (((iVar5 == 0) || (dirbuf->d_name[0] != '.')) ||
             ((no_dotfiles == '\0' && (show_dotfiles != '\0')))) {
            HTSACopy(&tmpfilename,localname);
            LYAddPathSep(&tmpfilename);
            HTSACat(&tmpfilename,dirbuf->d_name);
            sVar7 = strlen(dirbuf->d_name);
            __buf = (stat64 *)malloc(sVar7 + 0x68);
            if (__buf == (stat64 *)0x0) {
              status = 0xce;
              break;
            }
            LYTrimPathSep(tmpfilename);
            iVar5 = lstat64(tmpfilename,__buf);
            actual_info = (stat *)__buf;
            if (iVar5 < 0) {
              __buf->st_mode = 0;
            }
            else if ((__buf->st_mode & 0xf000) == 0xa000) {
              actual_info = &link_info;
              iVar5 = stat64(tmpfilename,(stat64 *)actual_info);
              if (iVar5 < 0) {
                link_info.st_mode = 0;
              }
            }
            strcpy((char *)((int)&__buf[1].st_dev + 1),dirbuf->d_name);
            if ((actual_info->st_mode & 0xf000) == 0x4000) {
              if (dir_list_style == 2) {
                *(undefined *)&__buf[1].st_dev = 0x20;
                LYAddPathSep0((char *)((int)&__buf[1].st_dev + 1));
              }
              else {
                iVar5 = strcmp(dirbuf->d_name,"..");
                if (iVar5 == 0) {
                  *(undefined *)&__buf[1].st_dev = 0x41;
                }
                else {
                  *(undefined *)&__buf[1].st_dev = 0x44;
                }
              }
            }
            else if (dir_list_style == 2) {
              *(undefined *)&__buf[1].st_dev = 0x20;
            }
            else if (dir_list_style == 1) {
              *(undefined *)&__buf[1].st_dev = 0x43;
            }
            else {
              *(undefined *)&__buf[1].st_dev = 0x46;
            }
            HTBTree_add(bt,__buf);
            if (partial_threshold < 1) {
              local_11c = display_lines;
            }
            else {
              local_11c = partial_threshold;
            }
            if (num_of_entries % local_11c == 0) {
              wVar8 = HTCheckForInterrupt();
              if (wVar8 != L'\0') {
                status = 0xce;
                break;
              }
            }
            num_of_entries = num_of_entries + 1;
          }
        }
      }
    }
  }
  if (status == 0xce) {
    if (WWW_TraceFlag != '\0') {
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"Reading the directory interrupted by user\n");
    }
  }
  else {
    mustshow = '\x01';
    pcVar6 = (char *)gettext(&DAT_08180b9f);
    HTProgress(pcVar6);
  }
  next_element = HTBTree_next(bt,(HTBTElement *)0x0);
  num_of_entries_output = 0;
  state = 'I';
  do {
    if (next_element == (HTBTElement *)0x0) {
LAB_0810a948:
      if ((status == 200) && (state == 'I')) {
        (*target->isa->start_element)(target,0x53,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
        (*target->isa->put_string)(target,"Empty Directory");
      }
      if (preformatted != '\0') {
        (*target->isa->end_element)(target,0x56,(char **)0x0);
        (*target->isa->put_character)(target,'\n');
      }
      (*target->isa->end_element)(target,0x11,(char **)0x0);
      (*target->isa->put_character)(target,'\n');
      if (tmpfilename != (char *)0x0) {
        free(tmpfilename);
        tmpfilename = (char *)0x0;
      }
      if (tail != (char *)0x0) {
        free(tail);
        tail = (char *)0x0;
      }
      HTBTreeAndObject_free(bt);
      if (status == 200) {
        if (HTDirReadme == 2) {
          do_readme(target,localname);
        }
        (*target->isa->_free)(target);
      }
      else {
        (*p_Var2)((HTStructured *)target,(HTError)0x0);
      }
      HTFinishDisplayPartial();
      if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
        __stack_chk_fail();
      }
      return status;
    }
    HTSACopy(&tmpfilename,localname);
    LYAddPathSep(&tmpfilename);
    data_00 = (DIRED *)next_element->object;
    HTSACat(&tmpfilename,data_00->file_name);
    HTSimplify(tmpfilename);
    iVar5 = strcmp((char *)((int)next_element->object + 0x61),"..");
    if (iVar5 != 0) {
      if (*(char *)((int)next_element->object + 0x60) == 'D') {
        local_116 = 'D';
      }
      else {
        local_116 = 'F';
      }
      test = local_116;
      if (state != local_116) {
        if (*(char *)((int)next_element->object + 0x60) == 'D') {
          local_115 = 'D';
        }
        else {
          local_115 = 'F';
        }
        state = local_115;
        if (preformatted != '\0') {
          (*target->isa->end_element)(target,0x56,(char **)0x0);
          (*target->isa->put_character)(target,'\n');
          preformatted = '\0';
        }
        (*target->isa->start_element)(target,0x30,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
        if (dir_list_style != 2) {
          (*target->isa->start_element)(target,0x26,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
          p_Var3 = target->isa->put_string;
          if (state == 'D') {
            local_110 = (char *)gettext("Subdirectories:");
          }
          else {
            local_110 = (char *)gettext("Files:");
          }
          (*p_Var3)(target,local_110);
          (*target->isa->end_element)(target,0x26,(char **)0x0);
        }
        (*target->isa->end_element)(target,0x30,(char **)0x0);
        (*target->isa->put_character)(target,'\n');
      }
    }
    if (preformatted == '\0') {
      (*target->isa->start_element)(target,0x56,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
      (*target->isa->put_character)(target,'\n');
      preformatted = '\x01';
    }
    LYListFmtParse(list_format,data_00,tmpfilename,target,tail);
    next_element = HTBTree_next(bt,next_element);
    if (partial_threshold < 1) {
      local_10c = display_lines;
    }
    else {
      local_10c = partial_threshold;
    }
    if (num_of_entries_output % local_10c == 0) {
      HTDisplayPartial();
      wVar8 = HTCheckForInterrupt();
      if (wVar8 != L'\0') {
        mustshow = '\x01';
        pcVar6 = (char *)gettext("Data transfer interrupted.");
        HTProgress(pcVar6);
        status = 0xce;
        goto LAB_0810a948;
      }
    }
    num_of_entries_output = num_of_entries_output + 1;
  } while( true );
}



// WARNING: Unknown calling convention

int HTStat(char *filename,stat *data)

{
  char *temp_name;
  size_t len;
  int result;
  
  result = -1;
  len = strlen(filename);
  if ((len == 0) || (filename[len - 1] != '/')) {
    result = stat64(filename,(stat64 *)data);
  }
  else {
    temp_name = (char *)0x0;
    HTSprintf0(&temp_name,"%s.",filename);
    result = HTStat(temp_name,data);
    if (temp_name != (char *)0x0) {
      free(temp_name);
    }
  }
  return result;
}



// WARNING: Unknown calling convention

int decompressAndParse(HTParentAnchor *anchor,HTFormat format_out,HTStream *sink,char *nodename,
                      char *filename,HTAtom *myEncoding,HTFormat format,int *statusp)

{
  BOOLEAN BVar1;
  CompressFileType CVar2;
  FILE *pFVar3;
  int iVar4;
  HTAtom *pHVar5;
  HTFormat format_00;
  char *pcVar6;
  char *pcVar7;
  char *local_4c;
  char *lastslash;
  char *anchor_path;
  char *cp;
  CompressFileType cft;
  CompressFileType method;
  HTList *methods;
  HTAtom *put;
  FILE *fp;
  int bin;
  char *localname;
  int rootlen;
  CompressFileType internal_decompress;
  gzFile gzfp;
  FILE *zzfp;
  HTAtom *encoding;
  BOOLEAN failed_decompress;
  
  encoding = (HTAtom *)0x0;
  zzfp = (FILE *)0x0;
  gzfp = (gzFile)0x0;
  internal_decompress = cftNone;
  failed_decompress = '\0';
  rootlen = 0;
  localname = filename;
  CVar2 = HTCompressFileType(filename,".",&rootlen);
  bin = (int)(CVar2 != cftNone);
  if (bin == 0) {
    local_4c = "r";
  }
  else {
    local_4c = "rb";
  }
  fp = (FILE *)fopen64(localname,local_4c);
  if (WWW_TraceFlag != '\0') {
    pFVar3 = TraceFP();
    fprintf((FILE *)pFVar3,"HTLoadFile: Opening `%s\' gives %p\n",localname,fp);
  }
  if (fp == (FILE *)0x0) {
    return 0;
  }
  BVar1 = HTEditable(localname);
  if (BVar1 != '\0') {
    put = HTAtom_for("PUT");
    methods = HTAnchor_methods(anchor);
    iVar4 = HTList_indexOf(methods,put);
    if (iVar4 == -1) {
      HTList_addObject(methods,put);
    }
  }
  if ((((myEncoding == (HTAtom *)0x0) || (pHVar5 = HTAtom_for("identity"), pHVar5 == myEncoding)) ||
      (pHVar5 = HTAtom_for("8bit"), pHVar5 == myEncoding)) ||
     ((pHVar5 = HTAtom_for("binary"), pHVar5 == myEncoding ||
      (pHVar5 = HTAtom_for("7bit"), pHVar5 == myEncoding)))) {
    cft = HTCompressFileType(localname,".",&rootlen);
    if (cft != cftNone) {
      cp = (char *)0x0;
      HTSACopy(&cp,localname);
      cp[rootlen] = '\0';
      format_00 = HTFileFormat(cp,&encoding,(char **)0x0);
      if (cp != (char *)0x0) {
        free(cp);
        cp = (char *)0x0;
      }
      format = HTCharsetFormat(format_00,anchor,UCLYhndl_HTFile_for_unspec);
      HTSACopy(&anchor->content_type,format->name);
    }
    if (cft == cftGzip) {
      HTSACopy(&anchor->content_encoding,"x-gzip");
      iVar4 = strcmp(format_out->name,"www/download");
      if (iVar4 != 0) {
        fclose((FILE *)fp);
        gzfp = (gzFile)gzopen64(localname,&DAT_08180c15);
        if (WWW_TraceFlag != '\0') {
          pFVar3 = TraceFP();
          fprintf((FILE *)pFVar3,"HTLoadFile: gzopen of `%s\' gives %p\n",localname,gzfp);
        }
        internal_decompress = cftGzip;
      }
    }
    else if (cft < cftBzip2) {
      if (cft == cftCompress) {
        HTSACopy(&anchor->content_encoding,"x-compress");
        format = HTAtom_for("www/compressed");
      }
    }
    else if (cft == cftBzip2) {
      HTSACopy(&anchor->content_encoding,"x-bzip2");
      format = HTAtom_for("www/compressed");
    }
    else if (cft == cftDeflate) {
      HTSACopy(&anchor->content_encoding,"x-deflate");
      iVar4 = strcmp(format_out->name,"www/download");
      if (iVar4 != 0) {
        zzfp = fp;
        fp = (FILE *)0x0;
        if (WWW_TraceFlag != '\0') {
          pFVar3 = TraceFP();
          fprintf((FILE *)pFVar3,"HTLoadFile: zzopen of `%s\' gives %p\n",localname,zzfp);
        }
        internal_decompress = cftDeflate;
      }
    }
  }
  else {
    method = HTEncodingToCompressType(myEncoding->name);
    iVar4 = strcmp(format_out->name,"www/download");
    if ((iVar4 == 0) || (method != cftGzip)) {
      iVar4 = strcmp(format_out->name,"www/download");
      if ((iVar4 == 0) || (method != cftDeflate)) {
        HTSACopy(&anchor->content_type,format->name);
        HTSACopy(&anchor->content_encoding,myEncoding->name);
        format = HTAtom_for("www/compressed");
      }
      else {
        zzfp = fp;
        fp = (FILE *)0x0;
        if (WWW_TraceFlag != '\0') {
          pFVar3 = TraceFP();
          fprintf((FILE *)pFVar3,"HTLoadFile: zzopen of `%s\' gives %p\n",localname,zzfp);
        }
        internal_decompress = cftDeflate;
      }
    }
    else {
      fclose((FILE *)fp);
      gzfp = (gzFile)gzopen64(localname,&DAT_08180c15);
      if (WWW_TraceFlag != '\0') {
        pFVar3 = TraceFP();
        fprintf((FILE *)pFVar3,"HTLoadFile: gzopen of `%s\' gives %p\n",localname,gzfp);
      }
      internal_decompress = cftGzip;
    }
  }
  if (internal_decompress == cftNone) {
    iVar4 = HTParseFile(format,format_out,anchor,fp,(HTStream_conflict4 *)sink);
    *statusp = iVar4;
    fclose((FILE *)fp);
    return 1;
  }
  if (internal_decompress != cftNone) {
    if (internal_decompress < cftBzip2) {
      failed_decompress = gzfp == (gzFile)0x0;
      goto LAB_0810b099;
    }
    if (internal_decompress == cftDeflate) {
      failed_decompress = zzfp == (FILE *)0x0;
      goto LAB_0810b099;
    }
  }
  failed_decompress = '\x01';
LAB_0810b099:
  if (failed_decompress == '\0') {
    cp = (char *)0x0;
    if (anchor->SugFname == (char *)0x0) {
      pcVar6 = HTParse(anchor->address,"",5);
      HTUnEscape(pcVar6);
      pcVar7 = strrchr(pcVar6,0x2f);
      if (pcVar7 != (char *)0x0) {
        HTSACopy(&cp,pcVar7 + 1);
      }
      if (pcVar6 != (char *)0x0) {
        free(pcVar6);
      }
    }
    else {
      HTSACopy(&cp,anchor->SugFname);
    }
    if (anchor->content_encoding != (char *)0x0) {
      free(anchor->content_encoding);
      anchor->content_encoding = (char *)0x0;
    }
    if ((cp != (char *)0x0) && (*cp != '\0')) {
      HTCheckFnameForCompression(&cp,anchor,'\x01');
    }
    if ((cp != (char *)0x0) && (*cp != '\0')) {
      HTSACopy(&anchor->SugFname,cp);
    }
    if (cp != (char *)0x0) {
      free(cp);
      cp = (char *)0x0;
    }
    if (gzfp == (gzFile)0x0) {
      if (zzfp != (FILE *)0x0) {
        iVar4 = HTParseZzFile(format,format_out,anchor,zzfp,(HTStream_conflict4 *)sink);
        *statusp = iVar4;
      }
    }
    else {
      iVar4 = HTParseGzFile(format,format_out,anchor,gzfp,(HTStream_conflict4 *)sink);
      *statusp = iVar4;
    }
  }
  else {
    pcVar6 = (char *)gettext("Could not open file for decompression!");
    iVar4 = HTLoadError((HTStream_conflict *)0x0,1,pcVar6);
    *statusp = iVar4;
  }
  return 1;
}



// WARNING: Unknown calling convention

int HTLoadFile(char *addr,HTParentAnchor *anchor,HTFormat format_out,HTStream *sink)

{
  double dVar1;
  int iVar2;
  char *pcVar3;
  size_t sVar4;
  FILE *pFVar5;
  int *piVar6;
  int local_150;
  stat file_info;
  stat dir_info;
  char *cp;
  DIR *dp_1;
  CompressFileType cft;
  char *atomname;
  int rootlen;
  float value;
  float filevalue;
  HTFormat rep;
  HTAtom *enc;
  uint baselen;
  char *base;
  char *best_name;
  HTAtom *best_enc;
  HTFormat best_rep;
  float best;
  dirent *dirbuf;
  DIR *dp;
  char *localname;
  int default_UCLYhndl;
  char *ftp_newhost;
  int status;
  HTAtom *myEncoding;
  char *newname;
  char *nodename;
  HTFormat format;
  char *acc_method;
  char *filename;
  BOOLEAN forget_multi;
  
  filename = (char *)0x0;
  acc_method = (char *)0x0;
  nodename = (char *)0x0;
  newname = (char *)0x0;
  myEncoding = (HTAtom *)0x0;
  status = -1;
  HTSACopy(&newname,addr);
  filename = HTParse(newname,"",5);
  nodename = HTParse(newname,"",8);
  acc_method = HTParse(newname,"",0x10);
  iVar2 = strcmp("ftp",acc_method);
  if (iVar2 != 0) {
    iVar2 = strcmp("localhost",nodename);
    if (iVar2 != 0) {
      pcVar3 = HTHostName();
      iVar2 = strcmp(nodename,pcVar3);
      if (iVar2 != 0) goto LAB_0810b3a0;
    }
    if (newname != (char *)0x0) {
      free(newname);
      newname = (char *)0x0;
    }
    if (acc_method != (char *)0x0) {
      free(acc_method);
      acc_method = (char *)0x0;
    }
    if ((anchor->content_type == (char *)0x0) || (anchor->content_encoding == (char *)0x0)) {
      default_UCLYhndl = UCLYhndl_HTFile_for_unspec;
      if (force_old_UCLYhndl_on_reload != '\0') {
        force_old_UCLYhndl_on_reload = '\0';
        default_UCLYhndl = forced_UCLYhdnl;
      }
      format = HTFileFormat(filename,&myEncoding,(char **)0x0);
      format = HTCharsetFormat(format,anchor,default_UCLYhndl);
    }
    else {
      format = HTAtom_for(anchor->content_type);
      myEncoding = HTAtom_for(anchor->content_encoding);
    }
    if (filename != (char *)0x0) {
      free(filename);
      filename = (char *)0x0;
    }
    if (HTSecure == '\0') {
      localname = HTnameOfFile_WWW(addr,'\x01','\x01');
      sVar4 = strlen(localname);
      pcVar3 = localname;
      if (6 < sVar4) {
        sVar4 = strlen(localname);
        iVar2 = strcmp(pcVar3 + (sVar4 - 6),".multi");
        if (iVar2 == 0) {
          dp = (DIR *)0x0;
          forget_multi = '\0';
          best = -1e+20;
          best_rep = (HTFormat)0x0;
          best_enc = (HTAtom *)0x0;
          best_name = (char *)0x0;
          base = strrchr(localname,0x2f);
          baselen = 0;
          if ((base == (char *)0x0) || (base == localname)) {
            forget_multi = '\x01';
          }
          else {
            *base = '\0';
            base = base + 1;
            sVar4 = strlen(base);
            baselen = sVar4 - 6;
            base[baselen] = '\0';
            dp = (DIR *)opendir(localname);
          }
          if ((forget_multi != '\0') || (dp == (DIR *)0x0)) {
            if (localname != (char *)0x0) {
              free(localname);
              localname = (char *)0x0;
            }
            if (nodename != (char *)0x0) {
              free(nodename);
              nodename = (char *)0x0;
            }
            pcVar3 = (char *)gettext("Multiformat: directory scan failed.");
            iVar2 = HTLoadError((HTStream_conflict *)sink,500,pcVar3);
            return iVar2;
          }
          while (dirbuf = (dirent *)readdir64((DIR *)dp), dirbuf != (dirent *)0x0) {
            if ((((*(uint *)&((dirent64 *)dirbuf)->d_ino |
                  *(uint *)((int)&((dirent64 *)dirbuf)->d_ino + 4)) != 0) &&
                (sVar4 = strlen(((dirent64 *)dirbuf)->d_name), baselen < sVar4)) &&
               (iVar2 = strncmp(dirbuf->d_name,base,baselen), iVar2 == 0)) {
              rep = HTFileFormat(dirbuf->d_name,&enc,(char **)0x0);
              filevalue = HTFileValue(dirbuf->d_name);
              value = HTStackValue(rep,format_out,filevalue,0);
              if (value <= 0.0) {
                rootlen = 0;
                atomname = (char *)0x0;
                cft = HTCompressFileType(dirbuf->d_name,".",&rootlen);
                cp = (char *)0x0;
                enc = (HTAtom *)0x0;
                if (cft != cftNone) {
                  HTSACopy(&cp,dirbuf->d_name);
                  cp[rootlen] = '\0';
                  format = HTFileFormat(cp,(HTAtom **)0x0,(char **)0x0);
                  if (cp != (char *)0x0) {
                    free(cp);
                    cp = (char *)0x0;
                  }
                  value = HTStackValue(format,format_out,filevalue,0);
                  if (cft == cftGzip) {
                    atomname = "application/x-gzip";
                  }
                  else if (cft < cftBzip2) {
                    if (cft == cftCompress) {
                      atomname = "application/x-compressed";
                    }
                  }
                  else if (cft == cftBzip2) {
                    atomname = "application/x-bzip2";
                  }
                  else if (cft == cftDeflate) {
                    atomname = "application/x-deflate";
                  }
                }
                if (atomname != (char *)0x0) {
                  value = HTStackValue(format,format_out,filevalue,0);
                  if (value <= 0.0) {
                    format = HTAtom_for(atomname);
                    value = HTStackValue(format,format_out,filevalue,0);
                  }
                  if (value <= 0.0) {
                    format = HTAtom_for("www/compressed");
                    value = HTStackValue(format,format_out,filevalue,0);
                  }
                }
              }
              if (value < -1e+20) {
                if (WWW_TraceFlag != '\0') {
                  dVar1 = (double)value;
                  pcVar3 = rep->name;
                  pFVar5 = TraceFP();
                  fprintf((FILE *)pFVar5,"HTLoadFile: value of presenting %s is %f\n",pcVar3,dVar1);
                }
                if (best < value) {
                  best_rep = rep;
                  best_enc = enc;
                  best = value;
                  HTSACopy(&best_name,dirbuf->d_name);
                }
              }
            }
          }
          closedir((DIR *)dp);
          if (best_rep == (HTFormat)0x0) {
            if (localname != (char *)0x0) {
              free(localname);
              localname = (char *)0x0;
            }
            if (nodename != (char *)0x0) {
              free(nodename);
              nodename = (char *)0x0;
            }
            pcVar3 = (char *)gettext("Could not find suitable representation for transmission.");
            iVar2 = HTLoadError((HTStream_conflict *)sink,0x193,pcVar3);
            return iVar2;
          }
          format = best_rep;
          myEncoding = best_enc;
          base[-1] = '/';
          *base = '\0';
          HTSACat(&localname,best_name);
          if (best_name != (char *)0x0) {
            free(best_name);
            best_name = (char *)0x0;
          }
        }
      }
      iVar2 = HTStat(localname,&dir_info);
      pcVar3 = localname;
      if (iVar2 == -1) {
        if (WWW_TraceFlag != '\0') {
          pFVar5 = TraceFP();
          fprintf((FILE *)pFVar5,"HTLoadFile: can\'t stat %s\n",pcVar3);
        }
      }
      else {
        if ((dir_info.st_mode & 0xf000) == 0x4000) {
          if (WWW_TraceFlag != '\0') {
            pFVar5 = TraceFP();
            fprintf((FILE *)pFVar5,"%s is a directory\n",pcVar3);
          }
          if (HTDirAccess == 0) {
            if (localname != (char *)0x0) {
              free(localname);
              localname = (char *)0x0;
            }
            if (nodename != (char *)0x0) {
              free(nodename);
              nodename = (char *)0x0;
            }
            pcVar3 = (char *)gettext("Directory browsing is not allowed.");
            iVar2 = HTLoadError((HTStream_conflict *)sink,0x193,pcVar3);
            return iVar2;
          }
          if (HTDirAccess == 1) {
            cp = (char *)0x0;
            HTSprintf0(&cp,"%s/%s",localname,".www_browsable");
            iVar2 = stat64(cp,(stat64 *)&file_info);
            if (iVar2 != 0) {
              if (localname != (char *)0x0) {
                free(localname);
                localname = (char *)0x0;
              }
              if (nodename != (char *)0x0) {
                free(nodename);
                nodename = (char *)0x0;
              }
              if (cp != (char *)0x0) {
                free(cp);
                cp = (char *)0x0;
              }
              pcVar3 = (char *)gettext("Selective access is not enabled for this directory");
              iVar2 = HTLoadError((HTStream_conflict *)sink,0x193,pcVar3);
              return iVar2;
            }
          }
          pcVar3 = localname;
          if (WWW_TraceFlag != '\0') {
            pFVar5 = TraceFP();
            fprintf((FILE *)pFVar5,"Opening directory %s\n",pcVar3);
          }
          dp_1 = (DIR *)opendir(localname);
          if (dp_1 == (DIR *)0x0) {
            if (localname != (char *)0x0) {
              free(localname);
              localname = (char *)0x0;
            }
            if (nodename != (char *)0x0) {
              free(nodename);
              nodename = (char *)0x0;
            }
            pcVar3 = (char *)gettext("This directory is not readable.");
            iVar2 = HTLoadError((HTStream_conflict *)sink,0x193,pcVar3);
            return iVar2;
          }
          status = print_local_dir(dp_1,localname,anchor,format_out,sink);
          closedir((DIR *)dp_1);
          if (localname != (char *)0x0) {
            free(localname);
            localname = (char *)0x0;
          }
          if (nodename != (char *)0x0) {
            free(nodename);
          }
          return status;
        }
        if ((((dir_info.st_mode & 0xf000) == 0x8000) && (dir_info.st_size._4_4_ < 1)) &&
           ((dir_info.st_size._4_4_ < 0 || ((uint)dir_info.st_size < 0x80000000)))) {
          anchor->content_length = (uint)dir_info.st_size;
        }
      }
      iVar2 = decompressAndParse(anchor,format_out,sink,nodename,localname,myEncoding,format,&status
                                );
      if (iVar2 != 0) {
        if (nodename != (char *)0x0) {
          free(nodename);
          nodename = (char *)0x0;
        }
        if (localname != (char *)0x0) {
          free(localname);
        }
        return status;
      }
      if (localname != (char *)0x0) {
        free(localname);
        localname = (char *)0x0;
      }
    }
    pcVar3 = HTHostName();
    iVar2 = strcmp(nodename,pcVar3);
    if (iVar2 == 0) {
      if (nodename != (char *)0x0) {
        free(nodename);
        nodename = (char *)0x0;
      }
      if (WWW_TraceFlag != '\0') {
        piVar6 = __errno_location();
        iVar2 = *piVar6;
        pFVar5 = TraceFP();
        fprintf((FILE *)pFVar5,"Can\'t open `%s\', errno=%d\n",addr,iVar2);
      }
      pcVar3 = (char *)gettext("Can\'t access requested file.");
      local_150 = HTLoadError((HTStream_conflict *)sink,0x193,pcVar3);
    }
    else {
      status = -1;
      if (nodename != (char *)0x0) {
        free(nodename);
        nodename = (char *)0x0;
      }
      iVar2 = strncmp(addr,"file://localhost",0x10);
      if (iVar2 != 0) {
        status = HTFTPLoad(addr,anchor,format_out,sink);
      }
      local_150 = status;
    }
    return local_150;
  }
LAB_0810b3a0:
  status = -1;
  if (newname != (char *)0x0) {
    free(newname);
    newname = (char *)0x0;
  }
  if (filename != (char *)0x0) {
    free(filename);
    filename = (char *)0x0;
  }
  if (nodename != (char *)0x0) {
    free(nodename);
    nodename = (char *)0x0;
  }
  if (acc_method != (char *)0x0) {
    free(acc_method);
    acc_method = (char *)0x0;
  }
  ftp_newhost = HTParse(addr,"",8);
  iVar2 = strcmp(ftp_lasthost,ftp_newhost);
  if (iVar2 != 0) {
    ftp_local_passive = ftp_passive;
  }
  status = HTFTPLoad(addr,anchor,format_out,sink);
  if ((ftp_passive == ftp_local_passive) && ((399 < status || (status < 0)))) {
    ftp_local_passive = ftp_passive == '\0';
    status = HTFTPLoad(addr,anchor,format_out,sink);
  }
  free(ftp_lasthost);
  ftp_lasthost = ftp_newhost;
  return status;
}



// WARNING: Unknown calling convention

char * HTGetProgramPath(ProgramPaths code)

{
  char *result;
  
  result = (char *)0x0;
  if ((code != ppUnknown) && (code < pp_Last)) {
    result = program_paths[code];
  }
  return result;
}



// WARNING: Unknown calling convention

void HTSetProgramPath(ProgramPaths code,char *path)

{
  char *local_8;
  
  if ((code != ppUnknown) && (code < pp_Last)) {
    if ((path == (char *)0x0) || (*path == '\0')) {
      local_8 = (char *)0x0;
    }
    else {
      local_8 = path;
    }
    program_paths[code] = local_8;
  }
  return;
}



// WARNING: Unknown calling convention

void HTInitProgramPaths(void)

{
  char *__ptr;
  char *test;
  char *path;
  int n;
  ProgramPaths code;
  
  n = 1;
  do {
    switch(n) {
    case 0:
    case 2:
    case 4:
    case 5:
    case 7:
    case 9:
    case 0xd:
    case 0xe:
    case 0x11:
    case 0x12:
      path = (char *)0x0;
      break;
    case 1:
      path = "/bin/bzip2";
      break;
    case 3:
      path = "/usr/bin/compress";
      break;
    case 6:
      path = "/bin/gzip";
      break;
    case 8:
      path = "/usr/bin/install";
      break;
    case 10:
      path = "/bin/mv";
      break;
    case 0xb:
      path = "/usr/bin/rlogin";
      break;
    case 0xc:
      path = "/bin/rm";
      break;
    case 0xf:
      path = "/bin/tar";
      break;
    case 0x10:
      path = "/usr/bin/telnet";
      break;
    case 0x13:
      path = "/bin/gunzip";
      break;
    case 0x14:
      path = "/usr/bin/unzip";
      break;
    case 0x15:
      path = "/usr/bin/uudecode";
      break;
    case 0x16:
      path = "/bin/zcat";
      break;
    case 0x17:
      path = "/usr/bin/zip";
      break;
    default:
      return;
    }
    __ptr = HTGetProgramPath(n);
    if ((__ptr != (char *)0x0) && (__ptr != path)) {
      free(__ptr);
    }
    HTSetProgramPath(n,path);
    n = n + 1;
  } while( true );
}



// WARNING: Unknown calling convention

HTBTree * HTBTree_new(HTComparer comp)

{
  HTBTree *pHVar1;
  HTBTree *tree;
  
  pHVar1 = (HTBTree *)malloc(8);
  if (pHVar1 == (HTBTree *)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTBTree.c","HTBTree_new");
  }
  pHVar1->compare = comp;
  pHVar1->top = (_HTBTree_element *)0x0;
  return pHVar1;
}



// WARNING: Unknown calling convention

void HTBTElement_free(HTBTElement *element)

{
  if (element != (HTBTElement *)0x0) {
    if (element->left != (_HTBTree_element *)0x0) {
      HTBTElement_free(element->left);
    }
    if (element->right != (_HTBTree_element *)0x0) {
      HTBTElement_free(element->right);
    }
    if (element != (HTBTElement *)0x0) {
      free(element);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void HTBTree_free(HTBTree *tree)

{
  HTBTElement_free(tree->top);
  if (tree != (HTBTree *)0x0) {
    free(tree);
  }
  return;
}



// WARNING: Unknown calling convention

void HTBTElementAndObject_free(HTBTElement *element)

{
  if (element != (HTBTElement *)0x0) {
    if (element->left != (_HTBTree_element *)0x0) {
      HTBTElementAndObject_free(element->left);
    }
    if (element->right != (_HTBTree_element *)0x0) {
      HTBTElementAndObject_free(element->right);
    }
    if (element->object != (void *)0x0) {
      free(element->object);
      element->object = (void *)0x0;
    }
    if (element != (HTBTElement *)0x0) {
      free(element);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void HTBTreeAndObject_free(HTBTree *tree)

{
  HTBTElementAndObject_free(tree->top);
  if (tree != (HTBTree *)0x0) {
    free(tree);
  }
  return;
}



// WARNING: Unknown calling convention

void * HTBTree_search(HTBTree *tree,void *object)

{
  int iVar1;
  int res;
  HTBTElement *cur;
  
  cur = tree->top;
  while( true ) {
    if (cur == (HTBTElement *)0x0) {
      return (void *)0x0;
    }
    iVar1 = (*tree->compare)(object,cur->object);
    if (iVar1 == 0) break;
    if (iVar1 < 0) {
      cur = cur->left;
    }
    else if (0 < iVar1) {
      cur = cur->right;
    }
  }
  return cur->object;
}



// WARNING: Unknown calling convention

void HTBTree_add(HTBTree *tree,void *object)

{
  HTBTElement *pHVar1;
  bool bVar2;
  bool bVar3;
  _HTBTree_element *p_Var4;
  int iVar5;
  int local_90;
  int local_88;
  int local_80;
  int local_78;
  int local_70;
  int local_68;
  int local_60;
  int local_58;
  int local_50;
  int local_48;
  int local_40;
  int local_38;
  int res;
  int corrections;
  int depth2;
  int depth;
  HTBTElement *father_of_forefather;
  HTBTElement *forefather_of_element;
  HTBTElement *added_element;
  HTBTElement *father_of_element;
  BOOLEAN first_time_1;
  BOOLEAN first_time;
  BOOLEAN top_found;
  BOOLEAN father_found;
  
  if (tree->top == (_HTBTree_element *)0x0) {
    p_Var4 = (_HTBTree_element *)malloc(0x18);
    tree->top = p_Var4;
    if (tree->top == (_HTBTree_element *)0x0) {
      outofmem("../../../WWW/Library/Implementation/HTBTree.c","HTBTree_add");
    }
    tree->top->up = (_HTBTree_element *)0x0;
    tree->top->object = object;
    tree->top->left = (_HTBTree_element *)0x0;
    tree->top->left_depth = 0;
    tree->top->right = (_HTBTree_element *)0x0;
    tree->top->right_depth = 0;
  }
  else {
    bVar3 = true;
    father_of_element = tree->top;
    added_element = (HTBTElement *)0x0;
    while (bVar3) {
      iVar5 = (*tree->compare)(object,father_of_element->object);
      if (iVar5 < 0) {
        if (father_of_element->left == (_HTBTree_element *)0x0) {
          bVar3 = false;
          p_Var4 = (_HTBTree_element *)malloc(0x18);
          father_of_element->left = p_Var4;
          if (father_of_element->left == (_HTBTree_element *)0x0) {
            outofmem("../../../WWW/Library/Implementation/HTBTree.c","HTBTree_add");
          }
          added_element = father_of_element->left;
          added_element->up = father_of_element;
          added_element->object = object;
          added_element->left = (_HTBTree_element *)0x0;
          added_element->left_depth = 0;
          added_element->right = (_HTBTree_element *)0x0;
          added_element->right_depth = 0;
        }
        else {
          father_of_element = father_of_element->left;
        }
      }
      else if (father_of_element->right == (_HTBTree_element *)0x0) {
        bVar3 = false;
        p_Var4 = (_HTBTree_element *)malloc(0x18);
        father_of_element->right = p_Var4;
        if (father_of_element->right == (_HTBTree_element *)0x0) {
          outofmem("../../../WWW/Library/Implementation/HTBTree.c","HTBTree_add");
        }
        added_element = father_of_element->right;
        added_element->up = father_of_element;
        added_element->object = object;
        added_element->left = (_HTBTree_element *)0x0;
        added_element->left_depth = 0;
        added_element->right = (_HTBTree_element *)0x0;
        added_element->right_depth = 0;
      }
      else {
        father_of_element = father_of_element->right;
      }
    }
    father_of_forefather = father_of_element;
    forefather_of_element = added_element;
    do {
      if (father_of_forefather->left == forefather_of_element) {
        depth = father_of_forefather->left_depth;
        local_90 = forefather_of_element->left_depth;
        if (forefather_of_element->left_depth < forefather_of_element->right_depth) {
          local_90 = forefather_of_element->right_depth;
        }
        father_of_forefather->left_depth = local_90 + 1;
        depth2 = father_of_forefather->left_depth;
      }
      else {
        depth = father_of_forefather->right_depth;
        local_88 = forefather_of_element->left_depth;
        if (forefather_of_element->left_depth < forefather_of_element->right_depth) {
          local_88 = forefather_of_element->right_depth;
        }
        father_of_forefather->right_depth = local_88 + 1;
        depth2 = father_of_forefather->right_depth;
      }
      forefather_of_element = father_of_forefather;
      father_of_forefather = father_of_forefather->up;
    } while ((depth != depth2) && (father_of_forefather != (_HTBTree_element *)0x0));
    bVar3 = true;
    corrections = 0;
    while ((bVar3 && (corrections < 7))) {
      if ((father_of_element->left_depth - father_of_element->right_depth < -1) ||
         (1 < father_of_element->left_depth - father_of_element->right_depth)) {
        corrections = corrections + 1;
        if ((((father_of_element->left == (_HTBTree_element *)0x0) &&
             (father_of_element->right->right == (_HTBTree_element *)0x0)) &&
            (father_of_element->right->left->left == (_HTBTree_element *)0x0)) &&
           (father_of_element->right->left->right == (_HTBTree_element *)0x0)) {
          corrections = 7;
        }
        if (((father_of_element->right == (_HTBTree_element *)0x0) &&
            (father_of_element->left->left == (_HTBTree_element *)0x0)) &&
           ((father_of_element->left->right->right == (_HTBTree_element *)0x0 &&
            (father_of_element->left->right->left == (_HTBTree_element *)0x0)))) {
          corrections = 7;
        }
        if (father_of_element->right_depth < father_of_element->left_depth) {
          pHVar1 = father_of_element->left;
          father_of_element->left_depth = pHVar1->right_depth;
          local_80 = father_of_element->left_depth;
          if (father_of_element->left_depth < father_of_element->right_depth) {
            local_80 = father_of_element->right_depth;
          }
          pHVar1->right_depth = local_80 + 1;
          if (father_of_element->up == (_HTBTree_element *)0x0) {
            pHVar1->up = (_HTBTree_element *)0x0;
            father_of_element->left = pHVar1->right;
            pHVar1->right = father_of_element;
          }
          else {
            father_of_forefather = father_of_element->up;
            bVar2 = true;
            forefather_of_element = pHVar1;
            do {
              if (father_of_forefather->left == forefather_of_element->up) {
                depth = father_of_forefather->left_depth;
                if (bVar2) {
                  local_78 = forefather_of_element->right_depth;
                  if (forefather_of_element->right_depth < forefather_of_element->left_depth) {
                    local_78 = forefather_of_element->left_depth;
                  }
                  father_of_forefather->left_depth = local_78 + 1;
                  bVar2 = false;
                }
                else {
                  local_70 = forefather_of_element->up->right_depth;
                  iVar5 = forefather_of_element->up->left_depth;
                  if (local_70 < iVar5) {
                    local_70 = iVar5;
                  }
                  father_of_forefather->left_depth = local_70 + 1;
                }
                depth2 = father_of_forefather->left_depth;
              }
              else {
                depth = father_of_forefather->right_depth;
                if (bVar2) {
                  local_68 = forefather_of_element->right_depth;
                  if (forefather_of_element->right_depth < forefather_of_element->left_depth) {
                    local_68 = forefather_of_element->left_depth;
                  }
                  father_of_forefather->right_depth = local_68 + 1;
                  bVar2 = false;
                }
                else {
                  local_60 = forefather_of_element->up->right_depth;
                  iVar5 = forefather_of_element->up->left_depth;
                  if (local_60 < iVar5) {
                    local_60 = iVar5;
                  }
                  father_of_forefather->right_depth = local_60 + 1;
                }
                depth2 = father_of_forefather->right_depth;
              }
              forefather_of_element = forefather_of_element->up;
              father_of_forefather = father_of_forefather->up;
            } while ((depth != depth2) && (father_of_forefather != (_HTBTree_element *)0x0));
            p_Var4 = father_of_element->up;
            if (p_Var4->left == father_of_element) {
              p_Var4->left = pHVar1;
              father_of_element->left = pHVar1->right;
              pHVar1->right = father_of_element;
            }
            if (p_Var4->right == father_of_element) {
              p_Var4->right = pHVar1;
              father_of_element->left = pHVar1->right;
              pHVar1->right = father_of_element;
            }
            pHVar1->up = p_Var4;
          }
          father_of_element->up = pHVar1;
          if (father_of_element->left != (_HTBTree_element *)0x0) {
            father_of_element->left->up = father_of_element;
          }
        }
        else {
          pHVar1 = father_of_element->right;
          father_of_element->right_depth = pHVar1->left_depth;
          local_58 = father_of_element->left_depth;
          if (father_of_element->left_depth < father_of_element->right_depth) {
            local_58 = father_of_element->right_depth;
          }
          pHVar1->left_depth = local_58 + 1;
          if (father_of_element->up == (_HTBTree_element *)0x0) {
            pHVar1->up = (_HTBTree_element *)0x0;
            father_of_element->right = pHVar1->left;
            pHVar1->left = father_of_element;
          }
          else {
            father_of_forefather = father_of_element->up;
            bVar2 = true;
            forefather_of_element = pHVar1;
            do {
              if (father_of_forefather->left == forefather_of_element->up) {
                depth = father_of_forefather->left_depth;
                if (bVar2) {
                  local_50 = forefather_of_element->right_depth;
                  if (forefather_of_element->right_depth < forefather_of_element->left_depth) {
                    local_50 = forefather_of_element->left_depth;
                  }
                  father_of_forefather->left_depth = local_50 + 1;
                  bVar2 = false;
                }
                else {
                  local_48 = forefather_of_element->up->right_depth;
                  iVar5 = forefather_of_element->up->left_depth;
                  if (local_48 < iVar5) {
                    local_48 = iVar5;
                  }
                  father_of_forefather->left_depth = local_48 + 1;
                }
                depth2 = father_of_forefather->left_depth;
              }
              else {
                depth = father_of_forefather->right_depth;
                if (bVar2) {
                  local_40 = forefather_of_element->right_depth;
                  if (forefather_of_element->right_depth < forefather_of_element->left_depth) {
                    local_40 = forefather_of_element->left_depth;
                  }
                  father_of_forefather->right_depth = local_40 + 1;
                  bVar2 = false;
                }
                else {
                  local_38 = forefather_of_element->up->right_depth;
                  iVar5 = forefather_of_element->up->left_depth;
                  if (local_38 < iVar5) {
                    local_38 = iVar5;
                  }
                  father_of_forefather->right_depth = local_38 + 1;
                }
                depth2 = father_of_forefather->right_depth;
              }
              father_of_forefather = father_of_forefather->up;
              forefather_of_element = forefather_of_element->up;
            } while ((depth != depth2) && (father_of_forefather != (_HTBTree_element *)0x0));
            p_Var4 = father_of_element->up;
            if (p_Var4->left == father_of_element) {
              p_Var4->left = pHVar1;
              father_of_element->right = pHVar1->left;
              pHVar1->left = father_of_element;
            }
            if (p_Var4->right == father_of_element) {
              p_Var4->right = pHVar1;
              father_of_element->right = pHVar1->left;
              pHVar1->left = father_of_element;
            }
            pHVar1->up = p_Var4;
          }
          father_of_element->up = pHVar1;
          if (father_of_element->right != (_HTBTree_element *)0x0) {
            father_of_element->right->up = father_of_element;
          }
        }
      }
      else if (father_of_element->up == (_HTBTree_element *)0x0) {
        bVar3 = false;
      }
      else {
        father_of_element = father_of_element->up;
      }
    }
    for (; father_of_element->up != (_HTBTree_element *)0x0;
        father_of_element = father_of_element->up) {
    }
    tree->top = father_of_element;
  }
  return;
}



// WARNING: Unknown calling convention

HTBTElement * HTBTree_next(HTBTree *tree,HTBTElement *ele)

{
  HTBTElement *father_of_forefather;
  HTBTElement *father_of_element;
  
  if (ele == (HTBTElement *)0x0) {
    father_of_element = tree->top;
    if (father_of_element != (_HTBTree_element *)0x0) {
      for (; father_of_element->left != (_HTBTree_element *)0x0;
          father_of_element = father_of_element->left) {
      }
    }
  }
  else {
    father_of_element = ele;
    if (ele->right == (_HTBTree_element *)0x0) {
      for (father_of_forefather = ele->up;
          (father_of_forefather != (HTBTElement *)0x0 &&
          (father_of_forefather->right == father_of_element));
          father_of_forefather = father_of_forefather->up) {
        father_of_element = father_of_forefather;
      }
      father_of_element = father_of_forefather;
    }
    else {
      for (father_of_element = ele->right; father_of_element->left != (_HTBTree_element *)0x0;
          father_of_element = father_of_element->left) {
      }
    }
  }
  return father_of_element;
}



// WARNING: Unknown calling convention

char * HTVMS_name(char *nn,char *fn)

{
  size_t sVar1;
  char *__dest;
  char *__dest_00;
  int iVar2;
  ushort **ppuVar3;
  char *pcVar4;
  char *pcVar5;
  undefined *__src;
  size_t __n;
  uint local_3c;
  uint local_38;
  char *p_1;
  char *r;
  char *q;
  char *p;
  char *hostname;
  char *last;
  char *second;
  char *nodename;
  char *filename;
  
  sVar1 = strlen(fn);
  __dest = (char *)malloc(sVar1 + 1);
  sVar1 = strlen(nn);
  __dest_00 = (char *)malloc(sVar1 + 3);
  p = HTHostName();
  if ((__dest == (char *)0x0) || (__dest_00 == (char *)0x0)) {
    outofmem("../../../WWW/Library/Implementation/HTFTP.c","HTVMSname");
  }
  strcpy(__dest,fn);
  memcpy(__dest_00,&DAT_08181050,1);
  iVar2 = strncmp(nn,"localhost",9);
  if (iVar2 != 0) {
    q = nn;
    while( true ) {
      if ((((*p == '\0') || (*p == '.')) || (*q == '\0')) || (*q == '.')) goto LAB_0810ce15;
      ppuVar3 = __ctype_b_loc();
      if (((*ppuVar3)[(byte)*p] & 0x200) == 0) {
        local_3c = (uint)(byte)*p;
      }
      else {
        local_3c = toupper((uint)(byte)*p);
      }
      ppuVar3 = __ctype_b_loc();
      if (((*ppuVar3)[(byte)*q] & 0x200) == 0) {
        local_38 = (uint)(byte)*q;
      }
      else {
        local_38 = toupper((uint)(byte)*q);
      }
      if (local_3c != local_38) break;
      p = p + 1;
      q = q + 1;
    }
    strcpy(__dest_00,nn);
    pcVar4 = strchr(__dest_00,0x2e);
    if (pcVar4 != (char *)0x0) {
      *pcVar4 = '\0';
    }
    __n = 3;
    __src = &DAT_0818105b;
    sVar1 = strlen(__dest_00);
    memcpy(__dest_00 + sVar1,__src,__n);
  }
LAB_0810ce15:
  pcVar4 = strchr(__dest + 1,0x2f);
  pcVar5 = strrchr(__dest,0x2f);
  if (pcVar4 == (char *)0x0) {
    HTSprintf0(&HTVMS_name::vmsname,"%s%s",__dest_00,__dest + 1);
  }
  else if (pcVar4 == pcVar5) {
    *pcVar4 = '\0';
    HTSprintf0(&HTVMS_name::vmsname,"%s%s:%s",__dest_00,__dest + 1,pcVar4 + 1);
    *pcVar4 = '/';
  }
  else {
    *pcVar4 = '\0';
    *pcVar5 = '\0';
    HTSprintf0(&HTVMS_name::vmsname,"%s%s:[%s]%s",__dest_00,__dest + 1,pcVar4 + 1,pcVar5 + 1);
    *pcVar5 = '/';
    *pcVar4 = *pcVar5;
    for (p_1 = strchr(HTVMS_name::vmsname,0x5b); *p_1 != ']'; p_1 = p_1 + 1) {
      if (*p_1 == '/') {
        *p_1 = '.';
      }
    }
  }
  if (__dest_00 != (char *)0x0) {
    free(__dest_00);
  }
  if (__dest != (char *)0x0) {
    free(__dest);
  }
  return HTVMS_name::vmsname;
}



// WARNING: Unknown calling convention

int next_data_char(void)

{
  byte bVar1;
  int iVar2;
  int status;
  
  if (data_write_pointer <= data_read_pointer) {
    iVar2 = HTDoRead(data_soc,data_buffer,0x800);
    if (iVar2 == -0x752e) {
      interrupted_in_next_data_char = 1;
    }
    if (iVar2 < 1) {
      return -1;
    }
    data_write_pointer = data_buffer + iVar2;
    data_read_pointer = data_buffer;
  }
  bVar1 = *data_read_pointer;
  data_read_pointer = data_read_pointer + 1;
  return (uint)bVar1;
}



// WARNING: Unknown calling convention

int close_connection(connection *con)

{
  int iVar1;
  FILE *pFVar2;
  int *piVar3;
  char *pcVar4;
  int local_1c;
  int status;
  connection *scan;
  
  if (WWW_TraceFlag != '\0') {
    iVar1 = con->socket;
    pFVar2 = TraceFP();
    fprintf((FILE *)pFVar2,"HTFTP: Closing control socket %d\n",iVar1);
  }
  local_1c = close(con->socket);
  if (((WWW_TraceFlag != '\0') && (local_1c != 0)) && (WWW_TraceFlag != '\0')) {
    piVar3 = __errno_location();
    pcVar4 = strerror(*piVar3);
    pFVar2 = TraceFP();
    fprintf((FILE *)pFVar2,"HTFTP:close_connection: %s",pcVar4);
  }
  con->socket = -1;
  if (connections == con) {
    connections = con->next;
  }
  else {
    for (scan = connections; scan != (connection *)0x0; scan = scan->next) {
      if (scan->next == con) {
        scan->next = con->next;
        if (control != con) {
          return local_1c;
        }
        control = (connection *)0x0;
        return local_1c;
      }
    }
    local_1c = -1;
  }
  return local_1c;
}



// WARNING: Unknown calling convention

void init_help_message_cache(void)

{
  if (help_message_buffer != (char *)0x0) {
    free(help_message_buffer);
    help_message_buffer = (char *)0x0;
  }
  return;
}



// WARNING: Unknown calling convention

void help_message_cache_add(char *string)

{
  FILE *__stream;
  
  if (help_message_buffer == (char *)0x0) {
    HTSACopy(&help_message_buffer,string);
  }
  else {
    HTSACat(&help_message_buffer,string);
  }
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"Adding message to help cache: %s\n",string);
  }
  return;
}



// WARNING: Unknown calling convention

char * help_message_cache_non_empty(void)

{
  return help_message_buffer;
}



// WARNING: Unknown calling convention

char * help_message_cache_contents(void)

{
  return help_message_buffer;
}



// WARNING: Unknown calling convention

int write_cmd(char *cmd)

{
  int iVar1;
  FILE *pFVar2;
  size_t __n;
  ssize_t sVar3;
  int local_1c;
  int status;
  
  if (control == (connection *)0x0) {
    if (WWW_TraceFlag != '\0') {
      pFVar2 = TraceFP();
      fprintf((FILE *)pFVar2,"HTFTP: No control connection set up!!\n");
    }
    local_1c = -99;
  }
  else {
    if (cmd != (char *)0x0) {
      if (WWW_TraceFlag != '\0') {
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2,"  Tx: %s",cmd);
      }
      __n = strlen(cmd);
      sVar3 = write(control->socket,cmd,__n);
      if (sVar3 < 0) {
        if (WWW_TraceFlag != '\0') {
          iVar1 = control->socket;
          pFVar2 = TraceFP();
          fprintf((FILE *)pFVar2,"HTFTP: Error %d sending command: closing socket %d\n",sVar3,iVar1)
          ;
        }
        close_connection(control);
        return sVar3;
      }
    }
    local_1c = 1;
  }
  return local_1c;
}



// WARNING: Unknown calling convention

BOOLEAN find_response(HTList *list)

{
  char *pcVar1;
  char *local_18;
  char *value;
  HTList *p;
  BOOLEAN result;
  
  p = list;
  while( true ) {
    if ((p == (HTList *)0x0) || (p = p->next, p == (HTList *)0x0)) {
      local_18 = (char *)0x0;
    }
    else {
      local_18 = (char *)p->object;
    }
    if (local_18 == (char *)0x0) break;
    pcVar1 = LYstrstr(response_text,local_18);
    if (pcVar1 != (char *)0x0) {
      return '\x01';
    }
  }
  return '\0';
}



// WARNING: Unknown calling convention

int response(char *cmd)

{
  char cVar1;
  BOOLEAN BVar2;
  int iVar3;
  FILE *pFVar4;
  int local_2c;
  int ich;
  char *p;
  int status;
  int continuation_response;
  int result;
  char continuation;
  
  continuation_response = -1;
  local_2c = write_cmd(cmd);
  if (-1 < local_2c) {
    do {
      p = response_text;
      while( true ) {
        iVar3 = HTGetCharacter();
        *p = (char)iVar3;
        cVar1 = *p;
        p = p + 1;
        if ((cVar1 == '\n') || (p == response_text + 0x100)) break;
        if (interrupted_in_htgetcharacter != 0) {
          if (WWW_TraceFlag != '\0') {
            pFVar4 = TraceFP();
            fprintf((FILE *)pFVar4,"HTFTP: Interrupted in HTGetCharacter, apparently.\n");
          }
          close(control->socket);
          control->socket = -1;
          return -0x752e;
        }
        if (iVar3 == -1) {
          if (WWW_TraceFlag != '\0') {
            iVar3 = control->socket;
            pFVar4 = TraceFP();
            fprintf((FILE *)pFVar4,"Error on rx: closing socket %d\n",iVar3);
          }
          memcpy(response_text,"000 *** TCP read error on response\n",0x24);
          close_connection(control);
          return -1;
        }
      }
      if (interrupted_in_htgetcharacter != 0) {
        if (WWW_TraceFlag != '\0') {
          pFVar4 = TraceFP();
          fprintf((FILE *)pFVar4,"HTFTP: Interrupted in HTGetCharacter, apparently.\n");
        }
        close(control->socket);
        control->socket = -1;
        return -0x752e;
      }
      *p = '\0';
      if (WWW_TraceFlag != '\0') {
        pFVar4 = TraceFP();
        fprintf((FILE *)pFVar4,"    Rx: %s",response_text);
      }
      iVar3 = strncmp(response_text,"230-",4);
      if (((iVar3 == 0) || (iVar3 = strncmp(response_text,"250-",4), iVar3 == 0)) ||
         (iVar3 = strncmp(response_text,"220-",4), iVar3 == 0)) {
        help_message_cache_add(response_text + 4);
      }
      sscanf(response_text,"%d%c",&result,&continuation);
      if (continuation_response == -1) {
        if (continuation == '-') {
          continuation_response = result;
        }
      }
      else if ((continuation_response == result) && (continuation == ' ')) {
        continuation_response = -1;
      }
      if (((result == 0xdc) && (BVar2 = find_response(broken_ftp_retr), BVar2 != '\0')) &&
         (Broken_RETR = 1, WWW_TraceFlag != '\0')) {
        pFVar4 = TraceFP();
        fprintf((FILE *)pFVar4,"This server is broken (RETR)\n");
      }
      if (((result == 0xdc) && (BVar2 = find_response(broken_ftp_epsv), BVar2 != '\0')) &&
         (Broken_EPSV = 1, WWW_TraceFlag != '\0')) {
        pFVar4 = TraceFP();
        fprintf((FILE *)pFVar4,"This server is broken (EPSV)\n");
      }
    } while (continuation_response != -1);
    if (result == 0x1a5) {
      if (WWW_TraceFlag != '\0') {
        iVar3 = control->socket;
        pFVar4 = TraceFP();
        fprintf((FILE *)pFVar4,"HTFTP: They close so we close socket %d\n",iVar3);
      }
      close_connection(control);
      local_2c = -1;
    }
    else {
      if (((result == 0xff) && (server_type == CMS_SERVER)) &&
         ((iVar3 = strncasecomp(cmd,"CWD",3), iVar3 == 0 ||
          (iVar3 = strcasecomp(cmd,"CDUP"), iVar3 == 0)))) {
        result = 0x22b;
      }
      local_2c = result / 100;
    }
  }
  return local_2c;
}



int send_cmd_1(char *verb)

{
  int iVar1;
  int iVar2;
  int in_GS_OFFSET;
  char *verb_local;
  char command [80];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  sprintf(command,"%.*s%c%c",0x4c,verb,0xd,10);
  iVar2 = response(command);
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar2;
}



// WARNING: Unknown calling convention

int send_cmd_2(char *verb,char *param)

{
  int iVar1;
  int status;
  char *command;
  
  command = (char *)0x0;
  HTSprintf0(&command,"%s %s%c%c",verb,param,0xd,10);
  iVar1 = response(command);
  if (command != (char *)0x0) {
    free(command);
  }
  return iVar1;
}



// WARNING: Unknown calling convention

int set_mac_binary(eServerType ServerType)

{
  int iVar1;
  uint local_8;
  
  if ((ServerType == APPLESHARE_SERVER) || (ServerType == NETPRESENZ_SERVER)) {
    iVar1 = response("MACB E\r\n");
  }
  else {
    iVar1 = response("MACB\r\n");
  }
  local_8 = (uint)(iVar1 == 2);
  return local_8;
}



// WARNING: Unknown calling convention

void get_ftp_pwd(eServerType *ServerType,BOOLEAN *UseList)

{
  int iVar1;
  char *pcVar2;
  FILE *pFVar3;
  size_t sVar4;
  eServerType local_1c;
  undefined *local_18;
  int status;
  char *cp;
  
  iVar1 = response("PWD\r\n");
  if (-1 < iVar1) {
    pcVar2 = strchr(response_text + 5,0x22);
    if (pcVar2 != (char *)0x0) {
      *pcVar2 = '\0';
    }
    if (*ServerType == TCPC_SERVER) {
      if (response_text[5] == '/') {
        local_1c = NCSA_SERVER;
      }
      else {
        local_1c = TCPC_SERVER;
      }
      *ServerType = local_1c;
      if (WWW_TraceFlag != '\0') {
        if (*ServerType == NCSA_SERVER) {
          local_18 = &DAT_0818126f;
        }
        else {
          local_18 = &DAT_08181274;
        }
        pFVar3 = TraceFP();
        fprintf((FILE *)pFVar3,"HTFTP: Treating as %s server.\n",local_18);
      }
    }
    else {
      if (response_text[5] == '/') {
        iVar1 = set_mac_binary(*ServerType);
        if (iVar1 == 0) {
          *ServerType = UNIX_SERVER;
          *UseList = '\x01';
          if (WWW_TraceFlag == '\0') {
            return;
          }
          pFVar3 = TraceFP();
          fprintf((FILE *)pFVar3,"HTFTP: Treating as Unix server.\n");
          return;
        }
        *ServerType = NCSA_SERVER;
        if (WWW_TraceFlag == '\0') {
          return;
        }
        pFVar3 = TraceFP();
        fprintf((FILE *)pFVar3,"HTFTP: Treating as NCSA server.\n");
        return;
      }
      sVar4 = strlen(response_text);
      if ((&DAT_081b349f)[sVar4] == ']') {
        *ServerType = VMS_SERVER;
        *UseList = '\x01';
        if (WWW_TraceFlag != '\0') {
          pFVar3 = TraceFP();
          fprintf((FILE *)pFVar3,"HTFTP: Treating as VMS server.\n");
        }
      }
      else {
        *ServerType = GENERIC_SERVER;
        if (WWW_TraceFlag != '\0') {
          pFVar3 = TraceFP();
          fprintf((FILE *)pFVar3,"HTFTP: Treating as Generic server.\n");
        }
      }
    }
    if ((((*ServerType == NCSA_SERVER) || (*ServerType == TCPC_SERVER)) ||
        (*ServerType == PETER_LEWIS_SERVER)) || (*ServerType == NETPRESENZ_SERVER)) {
      set_mac_binary(*ServerType);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void set_unix_dirstyle(eServerType *ServerType,BOOLEAN *UseList)

{
  int iVar1;
  FILE *__stream;
  char *pcVar2;
  int status;
  char *cp;
  
  iVar1 = response("SITE DIRSTYLE\r\n");
  if (iVar1 == 2) {
    *UseList = '\x01';
    pcVar2 = strstr(response_text + 4,"MSDOS");
    if ((pcVar2 != (char *)0x0) && (pcVar2 = strstr(pcVar2," off"), pcVar2 != (char *)0x0)) {
      return;
    }
    response("SITE DIRSTYLE\r\n");
  }
  else {
    *ServerType = GENERIC_SERVER;
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTFTP: DIRSTYLE failed, treating as Generic server.\n");
    }
  }
  return;
}



// WARNING: Unknown calling convention

int get_connection(char *arg,HTParentAnchor *anchor)

{
  connection *pcVar1;
  FILE *pFVar2;
  int iVar3;
  char *pcVar4;
  size_t sVar5;
  int local_50;
  char *local_4c;
  char *tilde;
  char *cp_1;
  char *host;
  char *tmp;
  char *the_address;
  char *cp;
  char *pw;
  char *p2;
  char *p1;
  char *password;
  char *username;
  connection *con;
  char *command;
  int status;
  
  command = (char *)0x0;
  username = (char *)0x0;
  password = (char *)0x0;
  if (get_connection::firstuse != '\0') {
    get_connection::firstuse = '\0';
  }
  if (control == (connection *)0x0) {
    con = (connection *)calloc(1,0x10);
    if (con == (connection *)0x0) {
      outofmem("../../../WWW/Library/Implementation/HTFTP.c","get_connection");
    }
  }
  else {
    if (control->socket != -1) {
      close(control->socket);
    }
    pcVar1 = control;
    con = control;
    control->addr = 0;
    pcVar1->binary = '\0';
  }
  con->socket = -1;
  if (arg == (char *)0x0) {
    local_50 = -1;
  }
  else if (*arg == '\0') {
    local_50 = -1;
  }
  else {
    if (WWW_TraceFlag != '\0') {
      pFVar2 = TraceFP();
      fprintf((FILE *)pFVar2,"get_connection(%s)\n",arg);
    }
    p1 = HTParse(arg,"",8);
    p2 = strrchr(p1,0x40);
    pcVar4 = p1;
    pw = (char *)0x0;
    if (p2 != (char *)0x0) {
      username = p1;
      *p2 = '\0';
      p1 = p2 + 1;
      pw = strchr(pcVar4,0x3a);
      if (pw != (char *)0x0) {
        *pw = '\0';
        pw = pw + 1;
        password = HTUnEscape(pw);
      }
      if (*username != '\0') {
        HTUnEscape(username);
      }
      if (password == (char *)0x0) {
        tmp = (char *)0x0;
        HTSprintf0(&tmp,"%s@%s",username,p1);
        if (((last_username_and_host == (char *)0x0) ||
            (iVar3 = strcmp(tmp,last_username_and_host), iVar3 != 0)) ||
           (user_entered_password == (char *)0x0)) {
          HTSACopy(&last_username_and_host,tmp);
          pcVar4 = (char *)gettext("Enter password for user %s@%s:");
          HTSprintf0(&tmp,pcVar4,username,p1);
          if (user_entered_password != (char *)0x0) {
            free(user_entered_password);
            user_entered_password = (char *)0x0;
          }
          user_entered_password = HTPromptPassword(tmp);
        }
        password = user_entered_password;
        if (tmp != (char *)0x0) {
          free(tmp);
          tmp = (char *)0x0;
        }
      }
    }
    if ((username == (char *)0x0) && (p1 != (char *)0x0)) {
      free(p1);
      p1 = (char *)0x0;
    }
    status = HTDoConnect(arg,"FTP",0x15,&con->socket);
    if (status < 0) {
      if (status == -0x752e) {
        if (WWW_TraceFlag != '\0') {
          pFVar2 = TraceFP();
          fprintf((FILE *)pFVar2,"HTFTP: Interrupted on connect\n");
        }
      }
      else if (WWW_TraceFlag != '\0') {
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2,"HTFTP: Unable to connect to remote host for `%s\'.\n",arg);
      }
      if (status == -0x752e) {
        mustshow = '\x01';
        pcVar4 = (char *)gettext("Connection interrupted.");
        HTProgress(pcVar4);
        status = -29999;
      }
      else {
        pcVar4 = (char *)gettext("Unable to connect to FTP host.");
        HTAlert(pcVar4);
      }
      if (con->socket != -1) {
        close(con->socket);
      }
      if (username != (char *)0x0) {
        free(username);
        username = (char *)0x0;
      }
      if (control == con) {
        control = (connection *)0x0;
      }
      if (con != (connection *)0x0) {
        free(con);
      }
      local_50 = status;
    }
    else {
      if (WWW_TraceFlag != '\0') {
        iVar3 = con->socket;
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2,"FTP connected, socket %d  control %p\n",iVar3,con);
      }
      control = con;
      HTInitInput(con->socket);
      init_help_message_cache();
      status = response((char *)0x0);
      if (status == -0x752e) {
        if (WWW_TraceFlag != '\0') {
          pFVar2 = TraceFP();
          fprintf((FILE *)pFVar2,"HTFTP: Interrupted at beginning of login.\n");
        }
        mustshow = '\x01';
        pcVar4 = (char *)gettext("Connection interrupted.");
        HTProgress(pcVar4);
        close(control->socket);
        control->socket = -1;
        local_50 = -0x752e;
      }
      else {
        server_type = GENERIC_SERVER;
        if (status == 2) {
          sVar5 = strlen(response_text);
          if (sVar5 < 5) {
            cp = response_text;
          }
          else {
            cp = strstr(response_text," awaits your command");
            if ((cp != (char *)0x0) || (cp = strstr(response_text," ready."), cp != (char *)0x0)) {
              *cp = '\0';
            }
            cp = response_text + 4;
            iVar3 = strncasecomp(response_text + 4,"NetPresenz",10);
            if (iVar3 == 0) {
              server_type = NETPRESENZ_SERVER;
            }
          }
          HTSACopy(&anchor->server,cp);
          if ((username == (char *)0x0) || (*username == '\0')) {
            local_4c = "anonymous";
          }
          else {
            local_4c = username;
          }
          status = send_cmd_2("USER",local_4c);
          if (status == -0x752e) {
            if (WWW_TraceFlag != '\0') {
              pFVar2 = TraceFP();
              fprintf((FILE *)pFVar2,"HTFTP: Interrupted while sending username.\n");
            }
            mustshow = '\x01';
            pcVar4 = (char *)gettext("Connection interrupted.");
            HTProgress(pcVar4);
            close(control->socket);
            control->socket = -1;
            return -0x752e;
          }
        }
        if (status == 3) {
          if (password == (char *)0x0) {
            tmp = (char *)0x0;
            the_address = anonftp_password;
            if ((anonftp_password == (char *)0x0) || (*anonftp_password == '\0')) {
              the_address = personal_mail_address;
            }
            if ((the_address == (char *)0x0) || (*the_address == '\0')) {
              the_address = LYGetEnv("USER");
            }
            if ((the_address == (char *)0x0) || (*the_address == '\0')) {
              the_address = "WWWuser";
            }
            HTSACopy(&tmp,the_address);
            pcVar4 = strchr(tmp,0x40);
            if (pcVar4 == (char *)0x0) {
              host = HTHostName();
            }
            else {
              *pcVar4 = '\0';
              host = pcVar4 + 1;
              if (*host == '\0') {
                host = HTHostName();
              }
            }
            if ((host == (char *)0x0) || (pcVar4 = strchr(host,0x2e), pcVar4 == (char *)0x0)) {
              host = "";
            }
            HTSprintf0(&command,"PASS %s@%s%c%c",tmp,host,0xd,10);
            if (tmp != (char *)0x0) {
              free(tmp);
              tmp = (char *)0x0;
            }
          }
          else {
            HTSprintf0(&command,"PASS %s%c%c",password,0xd,10);
          }
          status = response(command);
          if (command != (char *)0x0) {
            free(command);
            command = (char *)0x0;
          }
          if (status == -0x752e) {
            if (WWW_TraceFlag != '\0') {
              pFVar2 = TraceFP();
              fprintf((FILE *)pFVar2,"HTFTP: Interrupted while sending password.\n");
            }
            mustshow = '\x01';
            pcVar4 = (char *)gettext("Connection interrupted.");
            HTProgress(pcVar4);
            close(control->socket);
            control->socket = -1;
            return -0x752e;
          }
        }
        if (username != (char *)0x0) {
          free(username);
          username = (char *)0x0;
        }
        if ((status == 3) && (status = send_cmd_1("ACCT noaccount"), status == -0x752e)) {
          if (WWW_TraceFlag != '\0') {
            pFVar2 = TraceFP();
            fprintf((FILE *)pFVar2,"HTFTP: Interrupted while sending password.\n");
          }
          mustshow = '\x01';
          pcVar4 = (char *)gettext("Connection interrupted.");
          HTProgress(pcVar4);
          close(control->socket);
          control->socket = -1;
          local_50 = -0x752e;
        }
        else if (status == 2) {
          if (WWW_TraceFlag != '\0') {
            pFVar2 = TraceFP();
            fprintf((FILE *)pFVar2,"HTFTP: Logged in.\n");
          }
          if (server_type != NETPRESENZ_SERVER) {
            server_type = GENERIC_SERVER;
          }
          use_list = '\0';
          status = response("SYST\r\n");
          if (status == 2) {
            iVar3 = strncmp(response_text + 4,"UNIX Type: L8 MAC-OS MachTen",0x1c);
            if (iVar3 == 0) {
              server_type = MACHTEN_SERVER;
              use_list = '\x01';
              if (WWW_TraceFlag != '\0') {
                pFVar2 = TraceFP();
                fprintf((FILE *)pFVar2,"HTFTP: Treating as MachTen server.\n");
              }
            }
            else {
              pcVar4 = strstr(response_text + 4,"UNIX");
              if ((pcVar4 == (char *)0x0) &&
                 (pcVar4 = strstr(response_text + 4,"Unix"), pcVar4 == (char *)0x0)) {
                pcVar4 = strstr(response_text + 4,"MSDOS");
                if (pcVar4 == (char *)0x0) {
                  iVar3 = strncmp(response_text + 4,"VMS",3);
                  if (iVar3 == 0) {
                    pcVar4 = strstr(arg,"/~");
                    use_list = '\x01';
                    if (((pcVar4 == (char *)0x0) || (pcVar4[2] == '\0')) ||
                       (pcVar4 = strstr(response_text + 4,"MadGoat"), pcVar4 == (char *)0x0)) {
                      server_type = VMS_SERVER;
                      if (WWW_TraceFlag != '\0') {
                        pFVar2 = TraceFP();
                        fprintf((FILE *)pFVar2,"HTFTP: Treating as VMS server.\n");
                      }
                    }
                    else {
                      server_type = UNIX_SERVER;
                      if (WWW_TraceFlag != '\0') {
                        pFVar2 = TraceFP();
                        fprintf((FILE *)pFVar2,"HTFTP: Treating VMS as UNIX server.\n");
                      }
                    }
                  }
                  else {
                    iVar3 = strncmp(response_text + 4,"VM/CMS",6);
                    if ((iVar3 == 0) || (iVar3 = strncmp(response_text + 4,"VM ",3), iVar3 == 0)) {
                      server_type = CMS_SERVER;
                      use_list = '\x01';
                      if (WWW_TraceFlag != '\0') {
                        pFVar2 = TraceFP();
                        fprintf((FILE *)pFVar2,"HTFTP: Treating as CMS server.\n");
                      }
                    }
                    else {
                      iVar3 = strncmp(response_text + 4,"DCTS",4);
                      if (iVar3 == 0) {
                        server_type = DCTS_SERVER;
                        if (WWW_TraceFlag != '\0') {
                          pFVar2 = TraceFP();
                          fprintf((FILE *)pFVar2,"HTFTP: Treating as DCTS server.\n");
                        }
                      }
                      else {
                        pcVar4 = strstr(response_text + 4,"MAC-OS TCP/Connect II");
                        if (pcVar4 == (char *)0x0) {
                          if (server_type == NETPRESENZ_SERVER) {
                            use_list = '\x01';
                            set_mac_binary(NETPRESENZ_SERVER);
                            if (WWW_TraceFlag != '\0') {
                              pFVar2 = TraceFP();
                              fprintf((FILE *)pFVar2,
                                      "HTFTP: Treating as NetPresenz (MACOS) server.\n");
                            }
                          }
                          else {
                            iVar3 = strncmp(response_text + 4,"MACOS Peter\'s Server",0x14);
                            if (iVar3 == 0) {
                              server_type = PETER_LEWIS_SERVER;
                              use_list = '\x01';
                              set_mac_binary(PETER_LEWIS_SERVER);
                              if (WWW_TraceFlag != '\0') {
                                pFVar2 = TraceFP();
                                fprintf((FILE *)pFVar2,
                                        "HTFTP: Treating as Peter Lewis (MACOS) server.\n");
                              }
                            }
                            else {
                              iVar3 = strncmp(response_text + 4,"Windows_NT",10);
                              if (iVar3 == 0) {
                                server_type = WINDOWS_NT_SERVER;
                                if (WWW_TraceFlag != '\0') {
                                  pFVar2 = TraceFP();
                                  fprintf((FILE *)pFVar2,"HTFTP: Treating as Window_NT server.\n");
                                }
                                set_unix_dirstyle(&server_type,&use_list);
                              }
                              else {
                                iVar3 = strncmp(response_text + 4,"Windows2000",0xb);
                                if (iVar3 == 0) {
                                  server_type = WINDOWS_2K_SERVER;
                                  if (WWW_TraceFlag != '\0') {
                                    pFVar2 = TraceFP();
                                    fprintf((FILE *)pFVar2,"HTFTP: Treating as Window_2K server.\n")
                                    ;
                                  }
                                  set_unix_dirstyle(&server_type,&use_list);
                                }
                                else {
                                  iVar3 = strncmp(response_text + 4,"MS Windows",10);
                                  if (iVar3 == 0) {
                                    server_type = MS_WINDOWS_SERVER;
                                    use_list = '\x01';
                                    if (WWW_TraceFlag != '\0') {
                                      pFVar2 = TraceFP();
                                      fprintf((FILE *)pFVar2,
                                              "HTFTP: Treating as MS Windows server.\n");
                                    }
                                  }
                                  else {
                                    iVar3 = strncmp(response_text + 4,
                                                    "MACOS AppleShare IP FTP Server",0x1e);
                                    if (iVar3 == 0) {
                                      server_type = APPLESHARE_SERVER;
                                      use_list = '\x01';
                                      set_mac_binary(APPLESHARE_SERVER);
                                      if (WWW_TraceFlag != '\0') {
                                        pFVar2 = TraceFP();
                                        fprintf((FILE *)pFVar2,
                                                "HTFTP: Treating as AppleShare server.\n");
                                      }
                                    }
                                    else {
                                      server_type = GENERIC_SERVER;
                                      if (WWW_TraceFlag != '\0') {
                                        pFVar2 = TraceFP();
                                        fprintf((FILE *)pFVar2,"HTFTP: Ugh!  A Generic server.\n");
                                      }
                                      get_ftp_pwd(&server_type,&use_list);
                                      unsure_type = 1;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                        else {
                          server_type = TCPC_SERVER;
                          if (WWW_TraceFlag != '\0') {
                            pFVar2 = TraceFP();
                            fprintf((FILE *)pFVar2,"HTFTP: Looks like a TCPC server.\n");
                          }
                          get_ftp_pwd(&server_type,&use_list);
                          unsure_type = 1;
                        }
                      }
                    }
                  }
                }
                else {
                  server_type = MSDOS_SERVER;
                  use_list = '\x01';
                  if (WWW_TraceFlag != '\0') {
                    pFVar2 = TraceFP();
                    fprintf((FILE *)pFVar2,"HTFTP: Treating as MSDOS (Unix emulation) server.\n");
                  }
                }
              }
              else {
                server_type = UNIX_SERVER;
                unsure_type = 0;
                use_list = '\x01';
                if (WWW_TraceFlag != '\0') {
                  pFVar2 = TraceFP();
                  fprintf((FILE *)pFVar2,"HTFTP: Treating as Unix server.\n");
                }
              }
            }
          }
          else {
            get_ftp_pwd(&server_type,&use_list);
          }
          local_50 = con->socket;
        }
        else {
          if (WWW_TraceFlag != '\0') {
            pFVar2 = TraceFP();
            fprintf((FILE *)pFVar2,"HTFTP: Login fail: %s",response_text);
          }
          local_50 = -1;
        }
      }
    }
  }
  return local_50;
}



// WARNING: Unknown calling convention

void reset_master_socket(void)

{
  have_socket = '\0';
  return;
}



// WARNING: Unknown calling convention

void set_master_socket(int value)

{
  have_socket = -((char)~(byte)((uint)value >> 0x18) >> 7);
  if (have_socket != '\0') {
    master_socket = value;
  }
  return;
}



// WARNING: Unknown calling convention

int close_master_socket(void)

{
  uint uVar1;
  FILE *__stream;
  char *where;
  int local_1c;
  int status;
  
  if (have_socket != '\0') {
    open_sockets.fds_bits[master_socket >> 5] =
         ~(1 << ((byte)master_socket & 0x1f)) & open_sockets.fds_bits[master_socket >> 5];
  }
  local_1c = close(master_socket);
  uVar1 = master_socket;
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"HTFTP: Closed master socket %u\n",uVar1);
  }
  reset_master_socket();
  if (local_1c < 0) {
    where = (char *)gettext("close master socket");
    local_1c = HTInetStatus(where);
  }
  return local_1c;
}



// WARNING: Removing unreachable block (ram,0x0810eef1)
// WARNING: Unknown calling convention

int get_listen_socket(void)

{
  uint16_t uVar1;
  int iVar2;
  char *pcVar3;
  FILE *pFVar4;
  int in_GS_OFFSET;
  uint local_150;
  socklen_t local_14c;
  int status_1;
  socklen_t address_length;
  int status;
  fd_set *__arr;
  uint __i;
  int new_socket;
  socklen_t slen;
  int af;
  sockaddr_in *soc_in;
  sockaddr_storage soc_address;
  char portbuf [64];
  char hostbuf [64];
  int local_14;
  
  local_14 = *(int *)(in_GS_OFFSET + 0x14);
  soc_in = (sockaddr_in *)&soc_address;
  __arr = &open_sockets;
  for (__i = 0; __i < 0x20; __i = __i + 1) {
    open_sockets.fds_bits[__i] = 0;
  }
  num_sockets = 0;
  slen = 0x80;
  iVar2 = getsockname(control->socket,(sockaddr *)&soc_address,&slen);
  if (iVar2 < 0) {
    local_150 = HTInetStatus("getsockname failed");
  }
  else {
    af = (int)soc_address.ss_family;
    memset(&soc_address,0,0x80);
    new_socket = socket(af,1,6);
    if (new_socket < 0) {
      pcVar3 = (char *)gettext("socket for master socket");
      local_150 = HTInetStatus(pcVar3);
    }
    else {
      if (WWW_TraceFlag != '\0') {
        pFVar4 = TraceFP();
        fprintf((FILE *)pFVar4,"HTFTP: Opened master socket number %d\n",new_socket);
      }
      memset(&soc_address,0,0x80);
      soc_address.ss_family = (sa_family_t)af;
      if ((af != 2) && (af != 10)) {
        HTInetStatus("AF");
      }
      address_length = 0x80;
      status = getsockname(control->socket,(sockaddr *)&soc_address,&address_length);
      if (status < 0) {
        local_150 = HTInetStatus("getsockname");
      }
      else {
        if (WWW_TraceFlag != '\0') {
          pcVar3 = HTInetString((SockA *)soc_in);
          pFVar4 = TraceFP();
          fprintf((FILE *)pFVar4,"HTFTP: This host is %s\n",pcVar3);
        }
        soc_in->sin_port = 0;
        if (soc_address.ss_family == 10) {
          local_14c = 0x1c;
        }
        else {
          local_14c = 0x10;
        }
        status = bind(new_socket,(sockaddr *)&soc_address,local_14c);
        if (status < 0) {
          local_150 = HTInetStatus("bind");
        }
        else {
          address_length = 0x80;
          status = getsockname(new_socket,(sockaddr *)&soc_address,&address_length);
          if (status < 0) {
            local_150 = HTInetStatus("getsockname");
          }
          else {
            if (WWW_TraceFlag != '\0') {
              pcVar3 = HTInetString((SockA *)soc_in);
              uVar1 = ntohs(soc_in->sin_port);
              pFVar4 = TraceFP();
              fprintf((FILE *)pFVar4,"HTFTP: bound to port %d on %s\n",(uint)uVar1,pcVar3);
            }
            if (have_socket != '\0') {
              close_master_socket();
            }
            set_master_socket(new_socket);
            HTHostName();
            if (soc_address.ss_family == 2) {
              sprintf(port_command,"PORT %d,%d,%d,%d,%d,%d%c%c",
                      (uint)*(byte *)&(soc_in->sin_addr).s_addr,
                      (uint)*(byte *)((int)&(soc_in->sin_addr).s_addr + 1),
                      (uint)*(byte *)((int)&(soc_in->sin_addr).s_addr + 2),
                      (uint)*(byte *)((int)&(soc_in->sin_addr).s_addr + 3),
                      (uint)*(byte *)&soc_in->sin_port,(uint)*(byte *)((int)&soc_in->sin_port + 1),
                      0xd,10);
            }
            else if (soc_address.ss_family == 10) {
              getnameinfo((sockaddr *)&soc_address,0x1c,hostbuf,0x40,portbuf,0x40,3);
              sprintf(port_command,"EPRT |%d|%s|%s|%c%c",2,hostbuf,portbuf,0xd,10);
            }
            else {
              sprintf(port_command,"JUNK%c%c",0xd,10);
            }
            iVar2 = listen(master_socket,1);
            if (iVar2 < 0) {
              reset_master_socket();
              local_150 = HTInetStatus("listen");
            }
            else {
              if (WWW_TraceFlag != '\0') {
                pFVar4 = TraceFP();
                fprintf((FILE *)pFVar4,"TCP: Master socket(), bind() and listen() all OK\n");
              }
              open_sockets.fds_bits[master_socket >> 5] =
                   1 << ((byte)master_socket & 0x1f) | open_sockets.fds_bits[master_socket >> 5];
              if (num_sockets < master_socket + 1) {
                num_sockets = master_socket + 1;
              }
              local_150 = master_socket;
            }
          }
        }
      }
    }
  }
  if (local_14 == *(int *)(in_GS_OFFSET + 0x14)) {
    return local_150;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void set_years_and_date(void)

{
  int iVar1;
  char *pcVar2;
  int iVar3;
  int in_GS_OFFSET;
  int i;
  time_t NowTime;
  char date [12];
  char month [8];
  char day [8];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  NowTime = time((time_t *)0x0);
  pcVar2 = ctime(&NowTime);
  strncpy(day,pcVar2 + 8,2);
  day[2] = '\0';
  if (day[0] == ' ') {
    day[0] = '0';
  }
  pcVar2 = ctime(&NowTime);
  strncpy(month,pcVar2 + 4,3);
  month[3] = '\0';
  for (i = 0; i < 0xc; i = i + 1) {
    iVar3 = strcasecomp(month,months[i]);
    if (iVar3 == 0) break;
  }
  sprintf(date,"9999%02d%.2s",i + 1,day);
  TheDate = atoi(date);
  pcVar2 = ctime(&NowTime);
  strcpy(ThisYear,pcVar2 + 0x14);
  ThisYear[4] = '\0';
  iVar3 = atoi(ThisYear);
  sprintf(LastYear,"%d",iVar3 + -1);
  HaveYears = '\x01';
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



// WARNING: Unknown calling convention

void free_entryinfo_struct_contents(EntryInfo *entry_info)

{
  if (entry_info != (EntryInfo *)0x0) {
    if (entry_info->filename != (char *)0x0) {
      free(entry_info->filename);
      entry_info->filename = (char *)0x0;
    }
    if (entry_info->linkname != (char *)0x0) {
      free(entry_info->linkname);
      entry_info->linkname = (char *)0x0;
    }
    if (entry_info->type != (char *)0x0) {
      free(entry_info->type);
      entry_info->type = (char *)0x0;
    }
    if (entry_info->date != (char *)0x0) {
      free(entry_info->date);
      entry_info->date = (char *)0x0;
    }
  }
  return;
}



// WARNING: Unknown calling convention

BOOLEAN is_ls_date(char *s)

{
  ushort **ppuVar1;
  
  ppuVar1 = __ctype_b_loc();
  if (((*ppuVar1)[(byte)*s] & 0x400) != 0) {
    ppuVar1 = __ctype_b_loc();
    if (((*ppuVar1)[(byte)s[1]] & 0x400) != 0) {
      ppuVar1 = __ctype_b_loc();
      if (((*ppuVar1)[(byte)s[2]] & 0x400) != 0) {
        if ((s[3] != ' ') && (s[3] != '\x01')) {
          return '\0';
        }
        if ((s[4] != 0x20) && (ppuVar1 = __ctype_b_loc(), ((*ppuVar1)[(byte)s[4]] & 0x800) == 0)) {
          return '\0';
        }
        ppuVar1 = __ctype_b_loc();
        if (((*ppuVar1)[(byte)s[5]] & 0x800) == 0) {
          return '\0';
        }
        if (s[6] != ' ') {
          return '\0';
        }
        if ((s[7] != 0x20) && (ppuVar1 = __ctype_b_loc(), ((*ppuVar1)[(byte)s[7]] & 0x800) == 0)) {
          return '\0';
        }
        ppuVar1 = __ctype_b_loc();
        if (((*ppuVar1)[(byte)s[8]] & 0x800) == 0) {
          return '\0';
        }
        if ((s[9] != 0x3a) && (ppuVar1 = __ctype_b_loc(), ((*ppuVar1)[(byte)s[9]] & 0x800) == 0)) {
          return '\0';
        }
        ppuVar1 = __ctype_b_loc();
        if (((*ppuVar1)[(byte)s[10]] & 0x800) == 0) {
          return '\0';
        }
        if ((s[0xb] != 0x20) && (ppuVar1 = __ctype_b_loc(), ((*ppuVar1)[(byte)s[0xb]] & 0x800) == 0)
           ) {
          return '\0';
        }
        if (s[0xc] != ' ') {
          return '\0';
        }
        return '\x01';
      }
    }
  }
  return '\0';
}



void parse_eplf_line(char *line,EntryInfo *info)

{
  int iVar1;
  char cVar2;
  char *pcVar3;
  int in_GS_OFFSET;
  EntryInfo *info_local;
  char *line_local;
  tm t;
  time_t secs;
  ulong size;
  char *cp;
  char ct [26];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  cp = line;
  if (parse_eplf_line::flagbase == 0) {
    t.tm_year = 0x46;
    t.tm_mon = 0;
    t.tm_mday = 0;
    t.tm_hour = 0;
    t.tm_min = 0;
    t.tm_sec = 0;
    t.tm_isdst = -1;
    parse_eplf_line::base = mktime((tm *)&t);
    parse_eplf_line::flagbase = 1;
  }
LAB_0810f6cc:
  do {
    if (*cp == '\0') {
LAB_0810f6da:
      if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
        return;
      }
                    // WARNING: Subroutine does not return
      __stack_chk_fail();
    }
    cVar2 = *cp;
    if (cVar2 == 'm') {
      secs = 0;
      while ((cp = cp + 1, *cp != '\0' && (*cp != ','))) {
        secs = secs * 10 + *cp + -0x30;
      }
      secs = secs + parse_eplf_line::base;
      pcVar3 = ctime(&secs);
      strcpy(ct,pcVar3);
      ct[24] = '\0';
      HTSACopy(&info->date,ct);
      goto LAB_0810f6cc;
    }
    if (cVar2 < 'n') {
      if (cVar2 == '\t') {
        HTSACopy(&info->filename,cp + 1);
        goto LAB_0810f6da;
      }
      if (cVar2 == '/') {
        pcVar3 = (char *)gettext("Directory");
        HTSACopy(&info->type,pcVar3);
      }
LAB_0810f6c2:
      do {
        if (*cp == '\0') break;
        cVar2 = *cp;
        cp = cp + 1;
      } while (cVar2 != ',');
    }
    else {
      if (cVar2 != 's') goto LAB_0810f6c2;
      size = 0;
      while ((cp = cp + 1, *cp != '\0' && (*cp != ','))) {
        size = (size * 10 + (int)*cp) - 0x30;
      }
      info->size = size;
    }
  } while( true );
}



// WARNING: Unknown calling convention

void parse_ls_line(char *line,EntryInfo *entry_info)

{
  size_t sVar1;
  BOOLEAN BVar2;
  ushort **ppuVar3;
  int size_num;
  int base;
  int j;
  int i;
  
  base = 1;
  size_num = 0;
  i = strlen(line);
  do {
    sVar1 = i;
    i = sVar1 - 1;
    if (i < 0xe) break;
    ppuVar3 = __ctype_b_loc();
  } while ((((*ppuVar3)[(byte)line[i]] & 0x2000) == 0) ||
          (BVar2 = is_ls_date(line + (sVar1 - 0xd)), BVar2 == '\0'));
  line[i] = '\0';
  if (0xd < i) {
    HTSACopy(&entry_info->date,line + (sVar1 - 0xd));
    if ((entry_info->date[4] == ' ') || (entry_info->date[4] == '0')) {
      entry_info->date[4] = '\x01';
    }
    if (entry_info->date[0xb] == ' ') {
      for (j = 0xb; 6 < j; j = j + -1) {
        entry_info->date[j] = entry_info->date[j + -1];
      }
    }
  }
  j = sVar1 - 0xf;
  while (ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[(byte)line[j]] & 0x800) != 0) {
    size_num = size_num + (line[j] + -0x30) * base;
    base = base * 10;
    j = j + -1;
  }
  entry_info->size = size_num;
  HTSACopy(&entry_info->filename,line + sVar1);
  return;
}



// WARNING: Unknown calling convention

void parse_dls_line(char *line,EntryInfo *entry_info,char **pspilledname)

{
  size_t sVar1;
  char *pcVar2;
  ushort **ppuVar3;
  int iVar4;
  char *src;
  char *cps;
  int len;
  int size_num;
  int base;
  short j;
  
  base = 1;
  size_num = 0;
  sVar1 = strlen(line);
  if (sVar1 == 0) {
    if (*pspilledname != (char *)0x0) {
      free(*pspilledname);
      *pspilledname = (char *)0x0;
    }
    entry_info->display = '\0';
  }
  else {
    pcVar2 = LYSkipNonBlanks(line);
    if (*pcVar2 == '\0') {
      HTSACopy(pspilledname,line);
      entry_info->display = '\0';
    }
    else {
      if (((0x17 < (int)sVar1) && (line[0x17] == ' ')) &&
         ((ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[(byte)*line] & 0x2000) == 0 ||
          (*pspilledname != (char *)0x0)))) {
        j = 0x16;
        if ((line[0x16] == '=') || (line[0x16] == '-')) {
          pcVar2 = (char *)gettext("Directory");
          HTSACopy(&entry_info->type,pcVar2);
        }
        else {
          while (ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[(byte)line[j]] & 0x800) != 0) {
            size_num = size_num + (line[j] + -0x30) * base;
            base = base * 10;
            j = j + -1;
          }
        }
        entry_info->size = size_num;
        pcVar2 = LYSkipBlanks(line + 0x17);
        iVar4 = strncmp(pcVar2,"-> ",3);
        if (((iVar4 == 0) && (pcVar2[3] != '\0')) && (pcVar2[3] != ' ')) {
          src = (char *)gettext("Symbolic Link");
          HTSACopy(&entry_info->type,src);
          pcVar2 = LYSkipBlanks(pcVar2 + 3);
          HTSACopy(&entry_info->linkname,pcVar2);
          entry_info->size = 0;
        }
        if (0 < j) {
          line[j] = '\0';
        }
        LYTrimTrailing(line);
        len = strlen(line);
        if (((len == 0) && (*pspilledname != (char *)0x0)) && (**pspilledname != '\0')) {
          line = *pspilledname;
          len = strlen(*pspilledname);
        }
        if ((0 < len) && (line[len + -1] == '/')) {
          if (1 < len) {
            line[len + -1] = '\0';
          }
          if (entry_info->type == (char *)0x0) {
            pcVar2 = (char *)gettext("Directory");
            HTSACopy(&entry_info->type,pcVar2);
          }
        }
        HTSACopy(&entry_info->filename,line);
        if (*pspilledname == (char *)0x0) {
          return;
        }
        free(*pspilledname);
        *pspilledname = (char *)0x0;
        return;
      }
      ppuVar3 = __ctype_b_loc();
      if (((*ppuVar3)[(byte)*line] & 0x2000) == 0) {
        *pcVar2 = '\0';
      }
      if ((*pspilledname == (char *)0x0) || (*line != '\0')) {
        HTSACopy(&entry_info->filename,line);
        if ((pcVar2 == (char *)0x0) || ((pcVar2 == line || (pcVar2[-1] != '/')))) {
          HTSACopy(&entry_info->type,"");
        }
        else {
          pcVar2 = (char *)gettext("Directory");
          HTSACopy(&entry_info->type,pcVar2);
        }
        if (*pspilledname != (char *)0x0) {
          free(*pspilledname);
          *pspilledname = (char *)0x0;
        }
      }
      else {
        entry_info->filename = *pspilledname;
        *pspilledname = (char *)0x0;
        pcVar2 = entry_info->filename;
        sVar1 = strlen(entry_info->filename);
        if (pcVar2[sVar1 - 1] == '/') {
          pcVar2 = (char *)gettext("Directory");
          HTSACopy(&entry_info->type,pcVar2);
        }
        else {
          HTSACopy(&entry_info->type,"");
        }
      }
    }
  }
  return;
}



void parse_vms_dir_entry(char *line,EntryInfo *entry_info)

{
  int iVar1;
  char *pcVar2;
  char *pcVar3;
  int iVar4;
  size_t sVar5;
  ushort **ppuVar6;
  int iVar7;
  uint uVar8;
  char *pcVar9;
  FILE *__stream;
  int in_GS_OFFSET;
  char local_51;
  char local_49;
  char *local_44;
  EntryInfo *entry_info_local;
  char *line_local;
  char *sp;
  char *cps;
  char *cpd;
  char *cp;
  uint ialloc;
  int j;
  int i;
  char date [16];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if ((*line == '\0') || (cps = strchr(line,0x3b), cps == (char *)0x0)) {
    entry_info->display = '\0';
  }
  else {
    *cps = '\0';
    pcVar9 = cps + 1;
    HTSACopy(&entry_info->filename,line);
    pcVar2 = strstr(entry_info->filename,"READ");
    if (pcVar2 == (char *)0x0) {
      LYLowerCase(entry_info->filename);
      i = strlen(entry_info->filename);
    }
    else {
      pcVar3 = strstr(entry_info->filename,"READ");
      pcVar2 = entry_info->filename;
      iVar7 = 4 - (int)pcVar2;
      iVar4 = strncmp(pcVar3 + (int)(entry_info->filename + iVar7),"ME",2);
      if (iVar4 == 0) {
        for (i = (int)(pcVar3 + (6 - (int)pcVar2));
            (entry_info->filename[i] != '\0' && (entry_info->filename[i] != '.')); i = i + 1) {
        }
      }
      else {
        iVar7 = strncmp(pcVar3 + (int)(entry_info->filename + iVar7),".ME",3);
        if (iVar7 == 0) {
          i = strlen(entry_info->filename);
        }
        else {
          i = 0;
        }
      }
      LYLowerCase(entry_info->filename + i);
    }
    iVar7 = i + -1;
    if (((2 < iVar7) && (entry_info->filename[iVar7] == 'z')) &&
       ((entry_info->filename[i + -2] == '.' || (entry_info->filename[i + -2] == '_')))) {
      entry_info->filename[iVar7] = 'Z';
    }
    while (cps = strchr(cps + 1,9), cps != (char *)0x0) {
      *cps = ' ';
    }
    i = 0;
    j = 1;
    while (pcVar9[j] != '\0') {
      if ((pcVar9[i] == ' ') && (pcVar9[j] == ' ')) {
        j = j + 1;
      }
      else {
        i = i + 1;
        pcVar9[i] = pcVar9[j];
        j = j + 1;
      }
    }
    pcVar9[i + 1] = '\0';
    if (HaveYears == '\0') {
      set_years_and_date();
    }
    pcVar2 = strchr(pcVar9,0x2d);
    if ((((pcVar2 != (char *)0x0) && (sVar5 = strlen(pcVar2), 9 < sVar5)) &&
        (ppuVar6 = __ctype_b_loc(), ((*ppuVar6)[(byte)pcVar2[-1]] & 0x800) != 0)) &&
       ((ppuVar6 = __ctype_b_loc(), ((*ppuVar6)[(byte)pcVar2[1]] & 0x400) != 0 && (pcVar2[4] == '-')
        ))) {
      ppuVar6 = __ctype_b_loc();
      if (((*ppuVar6)[(byte)pcVar2[2]] & 0x100) == 0) {
        local_51 = pcVar2[2];
      }
      else {
        iVar7 = tolower((uint)(byte)pcVar2[2]);
        local_51 = (char)iVar7;
      }
      pcVar2[2] = local_51;
      ppuVar6 = __ctype_b_loc();
      if (((*ppuVar6)[(byte)pcVar2[3]] & 0x100) == 0) {
        local_49 = pcVar2[3];
      }
      else {
        iVar7 = tolower((uint)(byte)pcVar2[3]);
        local_49 = (char)iVar7;
      }
      pcVar2[3] = local_49;
      sprintf(date,"%.3s ",pcVar2 + 1);
      ppuVar6 = __ctype_b_loc();
      if (((*ppuVar6)[(byte)pcVar2[-2]] & 0x800) == 0) {
        sprintf(date + 4,"%c%.1s ",1,pcVar2 + -1);
      }
      else {
        sprintf(date + 4,"%.2s ",pcVar2 + -2);
      }
      iVar7 = strncmp(ThisYear,pcVar2 + 5,4);
      if (((iVar7 == 0) && (sVar5 = strlen(pcVar2), 0xf < sVar5)) && (pcVar2[0xc] == ':')) {
        sprintf(date + 7,"%.5s",pcVar2 + 10);
      }
      else {
        sprintf(date + 7," %.4s",pcVar2 + 5);
      }
      HTSACopy(&entry_info->date,date);
    }
    pcVar2 = strchr(pcVar9,0x2f);
    cps = pcVar2;
    if (pcVar2 == (char *)0x0) {
      pcVar9 = strtok(pcVar9," ");
      if (pcVar9 != (char *)0x0) {
        do {
          pcVar9 = strtok((char *)0x0," ");
          cpd = pcVar9;
          if (pcVar9 == (char *)0x0) goto LAB_08110308;
          while (ppuVar6 = __ctype_b_loc(), ((*ppuVar6)[(byte)*cpd] & 0x800) != 0) {
            cpd = cpd + 1;
          }
        } while (*cpd != '\0');
        iVar7 = atoi(pcVar9);
        entry_info->size = iVar7 << 9;
      }
    }
    else {
      while (ppuVar6 = __ctype_b_loc(), ((*ppuVar6)[(byte)cps[-1]] & 0x800) != 0) {
        cps = cps + -1;
      }
      if (cps < pcVar2) {
        *pcVar2 = '\0';
      }
      uVar8 = atoi(cps);
      entry_info->size = uVar8;
      cps = pcVar2;
      do {
        cps = cps + 1;
        ppuVar6 = __ctype_b_loc();
      } while (((*ppuVar6)[(byte)*cps] & 0x800) != 0);
      *cps = '\0';
      uVar8 = atoi(pcVar2 + 1);
      if (entry_info->size <= uVar8) {
        entry_info->size = entry_info->size << 9;
      }
    }
LAB_08110308:
    if (WWW_TraceFlag != '\0') {
      uVar8 = entry_info->size;
      if (entry_info->date == (char *)0x0) {
        local_44 = "";
      }
      else {
        local_44 = entry_info->date;
      }
      pcVar9 = entry_info->filename;
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTFTP: VMS filename: %s  date: %s  size: %u\n",pcVar9,local_44,uVar8
             );
    }
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void parse_ms_windows_dir_entry(char *line,EntryInfo *entry_info)

{
  int iVar1;
  size_t sVar2;
  char *pcVar3;
  char *pcVar4;
  byte *buffer;
  ushort **ppuVar5;
  uint uVar6;
  int iVar7;
  FILE *__stream;
  int in_GS_OFFSET;
  char *local_44;
  EntryInfo *entry_info_local;
  char *line_local;
  char *end;
  char *cpd;
  char *cps;
  char *cp;
  char date [16];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  sVar2 = strlen(line);
  pcVar3 = LYSkipBlanks(line);
  if (*pcVar3 == '\0') {
    entry_info->display = '\0';
  }
  else {
    pcVar4 = LYSkipNonBlanks(pcVar3);
    *pcVar4 = '\0';
    cpd = pcVar4 + 1;
    HTSACopy(&entry_info->filename,pcVar3);
    if (cpd < line + sVar2) {
      buffer = (byte *)LYSkipBlanks(cpd);
      pcVar3 = LYSkipNonBlanks((char *)buffer);
      *pcVar3 = '\0';
      cpd = pcVar3 + 1;
      ppuVar5 = __ctype_b_loc();
      if (((*ppuVar5)[*buffer] & 0x800) == 0) {
        pcVar3 = (char *)gettext("Directory");
        HTSACopy(&entry_info->type,pcVar3);
      }
      else {
        uVar6 = atoi((char *)buffer);
        entry_info->size = uVar6;
      }
    }
    else {
      HTSACopy(&entry_info->type,"");
    }
    if (HaveYears == '\0') {
      set_years_and_date();
    }
    if (cpd < line + sVar2) {
      pcVar3 = LYSkipBlanks(cpd);
      sVar2 = strlen(pcVar3);
      if (0x11 < sVar2) {
        pcVar3[6] = '\0';
        pcVar3[0xb] = '\0';
        pcVar3[0x11] = '\0';
        iVar7 = strcmp(ThisYear,pcVar3 + 7);
        if (iVar7 == 0) {
          sprintf(date,"%.6s %.5s",pcVar3,pcVar3 + 0xc);
        }
        else {
          sprintf(date,"%.6s  %.4s",pcVar3,pcVar3 + 7);
        }
        HTSACopy(&entry_info->date,date);
        if ((entry_info->date[4] == ' ') || (entry_info->date[4] == '0')) {
          entry_info->date[4] = '\x01';
        }
      }
    }
    if (WWW_TraceFlag != '\0') {
      uVar6 = entry_info->size;
      if (entry_info->date == (char *)0x0) {
        local_44 = "";
      }
      else {
        local_44 = entry_info->date;
      }
      pcVar3 = entry_info->filename;
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTFTP: MS Windows filename: %s  date: %s  size: %u\n",pcVar3,
              local_44,uVar6);
    }
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void parse_cms_dir_entry(char *line,EntryInfo *entry_info)

{
  int iVar1;
  uint uVar2;
  size_t sVar3;
  char *pcVar4;
  char *pcVar5;
  char *pcVar6;
  int iVar7;
  byte *pbVar8;
  ushort **ppuVar9;
  FILE *__stream;
  int in_GS_OFFSET;
  char *local_44;
  EntryInfo *entry_info_local;
  char *line_local;
  int i;
  int Records;
  int RecordLength;
  char *end;
  char *cpd;
  char *cps;
  char *cp;
  char date [16];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  sVar3 = strlen(line);
  pcVar4 = line + sVar3;
  RecordLength = 0;
  Records = 0;
  pcVar5 = LYSkipBlanks(line);
  if (*pcVar5 == '\0') {
    entry_info->display = '\0';
  }
  else {
    pcVar6 = LYSkipNonBlanks(pcVar5);
    *pcVar6 = '\0';
    HTSACopy(&entry_info->filename,pcVar5);
    pcVar5 = strchr(entry_info->filename,0x2e);
    if (pcVar5 == (char *)0x0) {
      pcVar5 = LYSkipBlanks(pcVar6 + 1);
      if (*pcVar5 == '\0') {
        if (entry_info->filename != (char *)0x0) {
          free(entry_info->filename);
          entry_info->filename = (char *)0x0;
        }
        if (entry_info->type != (char *)0x0) {
          free(entry_info->type);
          entry_info->type = (char *)0x0;
        }
        entry_info->display = '\0';
      }
      else {
        pcVar6 = LYSkipNonBlanks(pcVar5);
        *pcVar6 = '\0';
        cps = pcVar6 + 1;
        iVar7 = strcasecomp(pcVar5,"DIR");
        if ((iVar7 == 0) && (0x11 < (int)pcVar5 - (int)line)) {
          pcVar5 = (char *)gettext("Directory");
          HTSACopy(&entry_info->type,pcVar5);
          entry_info->size = 0;
        }
        else {
          pcVar5[-1] = '.';
          HTSACat(&entry_info->filename,pcVar5 + -1);
          if (cps < pcVar4) {
            pcVar5 = LYSkipBlanks(cps);
            pcVar5 = LYSkipNonBlanks(pcVar5);
            *pcVar5 = '\0';
            cps = pcVar5 + 1;
          }
        }
        if (cps < pcVar4) {
          pbVar8 = (byte *)LYSkipBlanks(cps);
          pcVar5 = LYSkipNonBlanks((char *)pbVar8);
          *pcVar5 = '\0';
          cps = pcVar5 + 1;
          ppuVar9 = __ctype_b_loc();
          if (((*ppuVar9)[*pbVar8] & 0x800) != 0) {
            RecordLength = atoi((char *)pbVar8);
          }
        }
        if (cps < pcVar4) {
          pbVar8 = (byte *)LYSkipBlanks(cps);
          pcVar5 = LYSkipNonBlanks((char *)pbVar8);
          *pcVar5 = '\0';
          cps = pcVar5 + 1;
          ppuVar9 = __ctype_b_loc();
          if (((*ppuVar9)[*pbVar8] & 0x800) != 0) {
            Records = atoi((char *)pbVar8);
          }
          if ((0 < Records) && (0 < RecordLength)) {
            entry_info->size = Records * RecordLength;
          }
        }
        if (HaveYears == '\0') {
          set_years_and_date();
        }
        if (cps < pcVar4) {
          pcVar5 = strchr(cps,0x3a);
          if ((pcVar5 != (char *)0x0) && (pcVar5 < pcVar4 + -3)) {
            ppuVar9 = __ctype_b_loc();
            if (((*ppuVar9)[(byte)pcVar5[1]] & 0x800) != 0) {
              ppuVar9 = __ctype_b_loc();
              if ((((*ppuVar9)[(byte)pcVar5[2]] & 0x800) != 0) && (pcVar5[3] == ':')) {
                pcVar5[3] = '\0';
                if (0xd < (int)(pcVar5 + 3) - (int)cps) {
                  pcVar4 = pcVar5 + -0xb;
                  pcVar5[-9] = '\0';
                  pcVar5[-6] = '\0';
                  pcVar5[-3] = '\0';
                  if (*pcVar4 == ' ') {
                    *pcVar4 = '0';
                  }
                  iVar7 = atoi(pcVar4);
                  pcVar4 = pcVar5 + -8;
                  sprintf(date,"%.3s %.2s",months[iVar7 + -1],pcVar4);
                  if (date[4] == '0') {
                    date[4] = ' ';
                  }
                  pcVar6 = pcVar5 + -5;
                  iVar7 = strcmp(ThisYear + 2,pcVar6);
                  if (iVar7 == 0) {
                    *pcVar5 = '\0';
                    iVar7 = atoi(pcVar5 + -2);
                    sprintf(date + 6," %02d:%.2s",iVar7,pcVar5 + 1);
                  }
                  else {
                    iVar7 = atoi(pcVar6);
                    if (iVar7 < 0x46) {
                      sprintf(date + 6,"  20%.2s",pcVar6,pcVar4);
                    }
                    else {
                      sprintf(date + 6,"  19%.2s",pcVar6,pcVar4);
                    }
                  }
                  HTSACopy(&entry_info->date,date);
                  if ((entry_info->date[4] == ' ') || (entry_info->date[4] == '0')) {
                    entry_info->date[4] = '\x01';
                  }
                }
              }
            }
          }
        }
        if (WWW_TraceFlag != '\0') {
          uVar2 = entry_info->size;
          if (entry_info->date == (char *)0x0) {
            local_44 = "";
          }
          else {
            local_44 = entry_info->date;
          }
          pcVar4 = entry_info->filename;
          __stream = TraceFP();
          fprintf((FILE *)__stream,"HTFTP: VM/CMS filename: %s  date: %s  size: %u\n",pcVar4,
                  local_44,uVar2);
        }
      }
    }
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



// WARNING: Unknown calling convention

EntryInfo * parse_dir_entry(char *entry,BOOLEAN *first,char **pspilledname)

{
  char *pcVar1;
  FILE *__stream;
  int iVar2;
  ushort **ppuVar3;
  size_t sVar4;
  bool bVar5;
  HTAtom *encoding;
  HTFormat format;
  char *cp2;
  char *cp;
  int len;
  int i;
  EntryInfo *entry_info;
  BOOLEAN remove_size;
  
  remove_size = '\0';
  entry_info = (EntryInfo *)malloc(0x18);
  if (entry_info == (EntryInfo *)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTFTP.c","parse_dir_entry");
  }
  entry_info->filename = (char *)0x0;
  entry_info->linkname = (char *)0x0;
  entry_info->type = (char *)0x0;
  entry_info->date = (char *)0x0;
  entry_info->size = 0;
  entry_info->display = '\x01';
  switch(server_type) {
  default:
    HTSACopy(&entry_info->filename,entry);
    return entry_info;
  case VMS_SERVER:
    parse_vms_dir_entry(entry,entry_info);
    if (entry_info->display == '\0') {
      return entry_info;
    }
    len = strlen(entry_info->filename);
    if ((4 < len) && (iVar2 = strcmp(entry_info->filename + (len - 4),".dir"), iVar2 == 0)) {
      entry_info->filename[len + -4] = '\0';
      pcVar1 = (char *)gettext("Directory");
      HTSACopy(&entry_info->type,pcVar1);
      remove_size = '\x01';
    }
    break;
  case CMS_SERVER:
    parse_cms_dir_entry(entry,entry_info);
    if (entry_info->display == '\0') {
      return entry_info;
    }
    if ((entry_info->type != (char *)0x0) && (*entry_info->type == '\0')) {
      if (entry_info->type != (char *)0x0) {
        free(entry_info->type);
        entry_info->type = (char *)0x0;
      }
      return entry_info;
    }
    break;
  case TCPC_SERVER:
  case NCSA_SERVER:
    HTSACopy(&entry_info->filename,entry);
    len = strlen(entry);
    if (entry[len - 1] == '/') {
      entry[len - 1] = '\0';
      pcVar1 = (char *)gettext("Directory");
      HTSACopy(&entry_info->type,pcVar1);
      remove_size = '\x01';
    }
    break;
  case MS_WINDOWS_SERVER:
    parse_ms_windows_dir_entry(entry,entry_info);
    if (entry_info->display == '\0') {
      return entry_info;
    }
    if ((entry_info->type != (char *)0x0) && (*entry_info->type == '\0')) {
      if (entry_info->type != (char *)0x0) {
        free(entry_info->type);
        entry_info->type = (char *)0x0;
      }
      return entry_info;
    }
    break;
  case DLS_SERVER:
    if (*first != '\0') {
      len = strlen(entry);
      if ((((len == 0) || (*entry == ' ')) || ((0x17 < len && (entry[0x17] != ' ')))) ||
         ((len < 0x18 && (pcVar1 = strchr(entry,0x20), pcVar1 != (char *)0x0)))) {
        server_type = UNIX_SERVER;
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"HTFTP: Falling back to treating as Unix server.\n");
        }
      }
      else {
        *first = '\0';
      }
    }
    if (server_type == DLS_SERVER) {
      parse_dls_line(entry,entry_info,pspilledname);
      if ((entry_info->filename == (char *)0x0) || (*entry_info->filename == '\0')) {
        entry_info->display = '\0';
        return entry_info;
      }
      iVar2 = strcmp(entry_info->filename,"..");
      if ((iVar2 == 0) || (iVar2 = strcmp(entry_info->filename,"."), iVar2 == 0)) {
        entry_info->display = '\0';
      }
      if ((entry_info->type != (char *)0x0) && (*entry_info->type == '\0')) {
        if (entry_info->type != (char *)0x0) {
          free(entry_info->type);
          entry_info->type = (char *)0x0;
        }
        return entry_info;
      }
      break;
    }
  case MACHTEN_SERVER:
  case UNIX_SERVER:
  case PETER_LEWIS_SERVER:
  case WINDOWS_NT_SERVER:
  case WINDOWS_2K_SERVER:
  case MSDOS_SERVER:
  case APPLESHARE_SERVER:
  case NETPRESENZ_SERVER:
    if (*entry == '+') {
      parse_eplf_line(entry,entry_info);
    }
    else {
      len = strlen(entry);
      if (*first != '\0') {
        iVar2 = strcmp(entry,"can not access directory .");
        if (iVar2 == 0) {
          entry_info->display = '\0';
          return entry_info;
        }
        *first = '\0';
        iVar2 = strncmp(entry,"total ",6);
        if ((iVar2 == 0) || (pcVar1 = strstr(entry,"not available"), pcVar1 != (char *)0x0)) {
          entry_info->display = '\0';
          return entry_info;
        }
        if (unsure_type != 0) {
          server_type = GENERIC_SERVER;
          entry_info->display = '\0';
          return entry_info;
        }
      }
      ppuVar3 = __ctype_b_loc();
      if (((*ppuVar3)[(byte)*entry] & 0x200) == 0) {
        bVar5 = *entry == 'D';
      }
      else {
        iVar2 = toupper((uint)(byte)*entry);
        bVar5 = iVar2 == 0x44;
      }
      if (bVar5) {
        pcVar1 = (char *)gettext("Directory");
        HTSACopy(&entry_info->type,pcVar1);
        remove_size = '\x01';
      }
      else if (*entry == 'l') {
        pcVar1 = (char *)gettext("Symbolic Link");
        HTSACopy(&entry_info->type,pcVar1);
        remove_size = '\x01';
        i = len;
        do {
          i = i + -1;
          if (i < 4) break;
          ppuVar3 = __ctype_b_loc();
        } while ((((((*ppuVar3)[(byte)entry[i]] & 0x2000) == 0) || (entry[i + -1] != '>')) ||
                 (entry[i + -2] != '-')) || (entry[i + -3] != ' '));
        if (3 < i) {
          entry[i + -3] = '\0';
          len = i + -3;
          pcVar1 = LYSkipBlanks(entry + i);
          HTSACopy(&entry_info->linkname,pcVar1);
        }
      }
      parse_ls_line(entry,entry_info);
      iVar2 = strcmp(entry_info->filename,"..");
      if ((iVar2 == 0) || (iVar2 = strcmp(entry_info->filename,"."), iVar2 == 0)) {
        entry_info->display = '\0';
      }
    }
  }
  if ((remove_size != '\0') && (entry_info->size != 0)) {
    entry_info->size = 0;
  }
  if (((((entry_info->filename != (char *)0x0) && (sVar4 = strlen(entry_info->filename), 3 < sVar4))
       && (cp = strrchr(entry_info->filename,0x2e), cp != (char *)0x0)) &&
      ((iVar2 = strncasecomp(cp,".me",3), iVar2 == 0 && ((cp[3] == '\0' || (cp[3] == ';')))))) &&
     ((server_type != UNIX_SERVER ||
      ((entry_info->filename + 3 < cp && (iVar2 = strncasecomp(cp + -4,"read.me",7), iVar2 == 0)))))
     ) {
    HTSACopy(&entry_info->type,"text/plain");
  }
  if (entry_info->type == (char *)0x0) {
    format = HTFileFormat(entry_info->filename,&encoding,&cp2);
    if (cp2 == (char *)0x0) {
      iVar2 = strncmp(format->name,"application",0xb);
      if (iVar2 == 0) {
        cp2 = format->name + 0xc;
        iVar2 = strncmp(cp2,"x-",2);
        if (iVar2 == 0) {
          cp2 = cp2 + 2;
        }
      }
      else {
        cp2 = format->name;
      }
    }
    HTSACopy(&entry_info->type,cp2);
  }
  return entry_info;
}



int compare_EntryInfo_structs(EntryInfo *entry1,EntryInfo *entry2)

{
  size_t sVar1;
  int iVar2;
  int in_GS_OFFSET;
  int local_50;
  EntryInfo *entry2_local;
  EntryInfo *entry1_local;
  char month [4];
  int status;
  int i;
  char date2 [16];
  char date1 [16];
  char time2 [8];
  char time1 [8];
  int local_8;
  
  local_8 = *(int *)(in_GS_OFFSET + 0x14);
  if (HTfileSortMethod == 2) {
    if (entry1->size == entry2->size) {
      local_50 = strcmp(entry1->filename,entry2->filename);
    }
    else if (entry2->size < entry1->size) {
      local_50 = 1;
    }
    else {
      local_50 = -1;
    }
  }
  else if (HTfileSortMethod == 3) {
    if ((entry1->date != (char *)0x0) && (entry2->date != (char *)0x0)) {
      sVar1 = strlen(entry1->date);
      if ((sVar1 != 0xc) || (sVar1 = strlen(entry2->date), sVar1 != 0xc)) {
        local_50 = strcmp(entry1->filename,entry2->filename);
        goto LAB_0811186f;
      }
      if (HaveYears == '\0') {
        set_years_and_date();
      }
      if (entry1->date[9] == ':') {
        memcpy(date1,&DAT_08181be0,5);
        strcpy(time1,entry1->date + 7);
        if (time1[0] == ' ') {
          time1[0] = '0';
        }
      }
      else {
        strcpy(date1,entry1->date + 8);
        memcpy(time1,"00:00",6);
      }
      strncpy(month,entry1->date,3);
      month[3] = '\0';
      i = 0;
      while ((i < 0xc && (iVar2 = strcasecomp(month,months[i]), iVar2 != 0))) {
        i = i + 1;
      }
      sprintf(month,"%02d",i + 1);
      strcat(date1,month);
      strncat(date1,entry1->date + 4,2);
      date1[8] = '\0';
      if ((date1[6] == ' ') || (date1[6] == '\x01')) {
        date1[6] = '0';
      }
      if ((date1[0] == '9') && (iVar2 = atoi(date1), TheDate + 1 < iVar2)) {
        for (i = 0; i < 4; i = i + 1) {
          date1[i] = LastYear[i];
        }
      }
      strcat(date1,time1);
      if (entry2->date[9] == ':') {
        memcpy(date2,&DAT_08181be0,5);
        strcpy(time2,entry2->date + 7);
        if (time2[0] == ' ') {
          time2[0] = '0';
        }
      }
      else {
        strcpy(date2,entry2->date + 8);
        memcpy(time2,"00:00",6);
      }
      strncpy(month,entry2->date,3);
      month[3] = '\0';
      i = 0;
      while ((i < 0xc && (iVar2 = strcasecomp(month,months[i]), iVar2 != 0))) {
        i = i + 1;
      }
      sprintf(month,"%02d",i + 1);
      strcat(date2,month);
      strncat(date2,entry2->date + 4,2);
      date2[8] = '\0';
      if ((date2[6] == ' ') || (date2[6] == '\x01')) {
        date2[6] = '0';
      }
      if ((date2[0] == '9') && (iVar2 = atoi(date2), TheDate + 1 < iVar2)) {
        for (i = 0; i < 4; i = i + 1) {
          date2[i] = LastYear[i];
        }
      }
      strcat(date2,time2);
      local_50 = strcasecomp(date2,date1);
      if (local_50 != 0) goto LAB_0811186f;
    }
    local_50 = strcmp(entry1->filename,entry2->filename);
  }
  else if (HTfileSortMethod == 1) {
    if (((entry1->type == (char *)0x0) || (entry2->type == (char *)0x0)) ||
       (local_50 = strcasecomp(entry1->type,entry2->type), local_50 == 0)) {
      local_50 = strcmp(entry1->filename,entry2->filename);
    }
  }
  else {
    local_50 = strcmp(entry1->filename,entry2->filename);
  }
LAB_0811186f:
  if (local_8 == *(int *)(in_GS_OFFSET + 0x14)) {
    return local_50;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int read_directory(HTParentAnchor *parent,char *address,HTFormat format_out,HTStream *sink)

{
  int iVar1;
  HTStructuredClass_conflict *pHVar2;
  _func_void_HTStructured_ptr_conflict *p_Var3;
  _func_void_HTStructured_ptr_char_conflict *p_Var4;
  _func_void_HTStructured_ptr_char_ptr_conflict *p_Var5;
  _func_int_HTStructured_ptr_int_BOOLEAN_ptr_char_ptr_ptr_int_char_ptr_ptr_conflict *p_Var6;
  _func_int_HTStructured_ptr_int_char_ptr_ptr_conflict *p_Var7;
  char *pcVar8;
  char c;
  char *pcVar9;
  int iVar10;
  ushort **ppuVar11;
  FILE *pFVar12;
  wchar_t wVar13;
  int in_GS_OFFSET;
  int local_110;
  HTStream *sink_local;
  HTFormat format_out_local;
  char *address_local;
  HTParentAnchor *parent_local;
  HTStructuredClass_conflict targetClass;
  int i;
  HTBTElement *ele;
  char *spilledname;
  int BytesReported;
  int BytesReceived;
  HTChunk *chunk;
  int ic;
  HTBTree *bt;
  char *cp;
  char *p;
  char *lastpath;
  EntryInfo *entry_info;
  char *filename;
  HTStructured_conflict *target;
  int status;
  BOOLEAN tildeIsTop;
  BOOLEAN need_parent_link;
  BOOLEAN first;
  BOOLEAN WasInterrupted;
  char NumBytes [64];
  char string_buffer [64];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  WasInterrupted = '\0';
  target = (HTStructured_conflict *)HTML_new(parent,format_out,(HTStream_conflict *)sink);
  filename = HTParse(address,"",5);
  first = '\x01';
  lastpath = (char *)0x0;
  need_parent_link = '\0';
  tildeIsTop = '\0';
  pHVar2 = target->isa;
  p_Var3 = pHVar2->_free;
  p_Var4 = pHVar2->put_character;
  p_Var5 = pHVar2->put_string;
  p_Var6 = pHVar2->start_element;
  p_Var7 = pHVar2->end_element;
  mustshow = '\x01';
  pcVar9 = (char *)gettext("Receiving FTP directory.");
  HTProgress(pcVar9);
  HaveYears = '\0';
  if (server_type == VMS_SERVER) {
    tildeIsTop = '\x01';
  }
  need_parent_link = HTDirTitles(target,parent,format_out,tildeIsTop);
  data_write_pointer = data_buffer;
  data_read_pointer = data_buffer;
  if (*filename == '\0') {
    HTSACopy(&lastpath,"/");
    goto LAB_08111c26;
  }
  iVar10 = strcmp(filename,"/");
  if (iVar10 == 0) {
    HTSACopy(&lastpath,"/foo/..");
    goto LAB_08111c26;
  }
  p = strrchr(filename,0x2f);
  if (server_type == CMS_SERVER) {
    HTSACopy(&lastpath,filename);
  }
  else {
    HTSACopy(&lastpath,p + 1);
  }
  cp = strrchr(lastpath,0x3b);
  if ((cp == (char *)0x0) || (iVar10 = strncasecomp(cp + 1,"type=",5), iVar10 != 0))
  goto LAB_08111c26;
  ppuVar11 = __ctype_b_loc();
  if (((*ppuVar11)[(byte)cp[6]] & 0x200) == 0) {
    if (cp[6] != 'D') goto LAB_08111b6d;
  }
  else {
    iVar10 = toupper((uint)(byte)cp[6]);
    if (iVar10 != 0x44) {
LAB_08111b6d:
      ppuVar11 = __ctype_b_loc();
      if (((*ppuVar11)[(byte)cp[6]] & 0x200) == 0) {
        if (cp[6] != 'A') goto LAB_08111bc5;
      }
      else {
        iVar10 = toupper((uint)(byte)cp[6]);
        if (iVar10 != 0x41) {
LAB_08111bc5:
          ppuVar11 = __ctype_b_loc();
          if (((*ppuVar11)[(byte)cp[6]] & 0x200) == 0) {
            if (cp[6] != 'I') goto LAB_08111c26;
          }
          else {
            iVar10 = toupper((uint)(byte)cp[6]);
            if (iVar10 != 0x49) goto LAB_08111c26;
          }
        }
      }
    }
  }
  *cp = '\0';
LAB_08111c26:
  if (filename != (char *)0x0) {
    free(filename);
    filename = (char *)0x0;
  }
  bt = HTBTree_new(compare_EntryInfo_structs);
  chunk = HTChunkCreate(0x80);
  BytesReceived = 0;
  BytesReported = 0;
  spilledname = (char *)0x0;
  (*p_Var4)(target,'\n');
  ic = 0;
  do {
    if (ic == -1) {
unload_btree:
      HTChunkFree(chunk);
      if (spilledname != (char *)0x0) {
        free(spilledname);
        spilledname = (char *)0x0;
      }
      pcVar9 = help_message_cache_non_empty();
      if (pcVar9 == (char *)0x0) {
        (*p_Var6)(target,0x56,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
        (*p_Var4)(target,'\n');
      }
      else {
        (*p_Var6)(target,0x56,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
        (*p_Var6)(target,0x36,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
        (*p_Var4)(target,'\n');
        pcVar9 = help_message_cache_contents();
        (*p_Var5)(target,pcVar9);
        init_help_message_cache();
        (*p_Var6)(target,0x36,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
        (*p_Var4)(target,'\n');
      }
      for (ele = HTBTree_next(bt,(HTBTElement *)0x0); ele != (HTBTElement *)0x0;
          ele = HTBTree_next(bt,ele)) {
        entry_info = (EntryInfo *)ele->object;
        if (entry_info->date == (char *)0x0) {
          (*p_Var5)(target,"     * ");
        }
        else {
          (*p_Var5)(target,entry_info->date);
          (*p_Var5)(target,"  ");
        }
        if (entry_info->type != (char *)0x0) {
          for (i = 0; (entry_info->type[i] != '\0' && (i < 0x10)); i = i + 1) {
            (*p_Var4)(target,entry_info->type[i]);
          }
          for (; i < 0x11; i = i + 1) {
            (*p_Var4)(target,' ');
          }
        }
        HTDirEntry(target,lastpath,entry_info->filename);
        (*p_Var5)(target,entry_info->filename);
        (*p_Var7)(target,0,(char **)0x0);
        if (entry_info->size == 0) {
          if (entry_info->linkname != (char *)0x0) {
            (*p_Var5)(target," -> ");
            (*p_Var5)(target,entry_info->linkname);
          }
        }
        else {
          if (entry_info->size < 0x400) {
            sprintf(string_buffer,"  %u bytes",entry_info->size);
          }
          else {
            sprintf(string_buffer,"  %uKb",entry_info->size >> 10);
          }
          (*p_Var5)(target,string_buffer);
        }
        (*p_Var4)(target,'\n');
        free_entryinfo_struct_contents(entry_info);
      }
      (*p_Var7)(target,0x56,(char **)0x0);
      (*p_Var7)(target,0x11,(char **)0x0);
      (*p_Var3)(target);
      HTBTreeAndObject_free(bt);
      if (lastpath != (char *)0x0) {
        free(lastpath);
        lastpath = (char *)0x0;
      }
      iVar10 = data_soc;
      if ((WasInterrupted != '\0') || (data_soc != -1)) {
        if (WWW_TraceFlag != '\0') {
          pFVar12 = TraceFP();
          fprintf((FILE *)pFVar12,"HTFTP: Closing data socket %d\n",iVar10);
        }
        status = close(data_soc);
        if (status == -1) {
          HTInetStatus("close");
        }
        data_soc = -1;
      }
      if ((WasInterrupted != '\0') || (wVar13 = HTCheckForInterrupt(), wVar13 != L'\0')) {
        mustshow = '\x01';
        pcVar9 = (char *)gettext("Data transfer interrupted.");
        HTProgress(pcVar9);
      }
      local_110 = 200;
LAB_08112639:
      if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
        return local_110;
      }
                    // WARNING: Subroutine does not return
      __stack_chk_fail();
    }
    HTChunkClear(chunk);
    wVar13 = HTCheckForInterrupt();
    if (wVar13 != L'\0') {
      if (WWW_TraceFlag != '\0') {
        pFVar12 = TraceFP();
        fprintf((FILE *)pFVar12,"read_directory: interrupted after %d bytes\n",BytesReceived);
      }
      WasInterrupted = '\x01';
      if (BytesReceived == 0) {
        (*p_Var3)(target);
        HTBTreeAndObject_free(bt);
        if (spilledname != (char *)0x0) {
          free(spilledname);
          spilledname = (char *)0x0;
        }
        local_110 = -0x752e;
        goto LAB_08112639;
      }
      goto unload_btree;
    }
    interrupted_in_next_data_char = 0;
LAB_08111d67:
    ic = next_data_char();
    while( true ) {
      if (interrupted_in_next_data_char != 0) {
        if (WWW_TraceFlag != '\0') {
          pFVar12 = TraceFP();
          fprintf((FILE *)pFVar12,"read_directory: interrupted_in_next_data_char after %d bytes\n",
                  BytesReceived);
        }
        WasInterrupted = '\x01';
        if (BytesReceived != 0) goto unload_btree;
        (*p_Var3)(target);
        HTBTreeAndObject_free(bt);
        if (spilledname != (char *)0x0) {
          free(spilledname);
          spilledname = (char *)0x0;
        }
        local_110 = -0x752e;
        goto LAB_08112639;
      }
      c = (char)ic;
      if ((c != '\r') && (c != '\n')) {
        if (ic == -1) goto LAB_08111f3c;
        HTChunkPutc(chunk,c);
        goto LAB_08111d67;
      }
      if (chunk->size == 0) goto LAB_08111d67;
      if (server_type != VMS_SERVER) goto LAB_08111f3c;
      if ((data_read_pointer < data_write_pointer) && (data_read_pointer[1] == ' ')) {
        data_read_pointer = data_read_pointer + 1;
        goto LAB_08111d67;
      }
      if (data_read_pointer < data_write_pointer) goto LAB_08111f3c;
      status = HTDoRead(data_soc,data_buffer,0x800);
      if (status != -0x752e) break;
      interrupted_in_next_data_char = 1;
    }
    if (0 < status) {
      data_write_pointer = data_buffer + status;
      data_read_pointer = data_buffer;
      if (data_buffer[0] != ' ') goto LAB_08111f3c;
      data_read_pointer = data_buffer + 1;
      goto LAB_08111d67;
    }
    ic = -1;
LAB_08111f3c:
    HTChunkTerminate(chunk);
    BytesReceived = BytesReceived + chunk->size;
    if (BytesReported + 0x400 < BytesReceived) {
      pcVar9 = (char *)gettext("Transferred %d bytes");
      sprintf(NumBytes,pcVar9,BytesReceived);
      HTProgress(NumBytes);
      BytesReported = BytesReceived;
    }
    pcVar9 = lastpath;
    if ((ic == -1) && (chunk->size == 1)) goto unload_btree;
    if (WWW_TraceFlag != '\0') {
      pcVar8 = chunk->data;
      pFVar12 = TraceFP();
      fprintf((FILE *)pFVar12,"HTFTP: Line in %s is %s\n",pcVar9,pcVar8);
    }
    entry_info = parse_dir_entry(chunk->data,&first,&spilledname);
    if (entry_info->display == '\0') {
      free_entryinfo_struct_contents(entry_info);
      if (entry_info != (EntryInfo *)0x0) {
        free(entry_info);
        entry_info = (EntryInfo *)0x0;
      }
    }
    else {
      if (spilledname != (char *)0x0) {
        free(spilledname);
        spilledname = (char *)0x0;
      }
      if (WWW_TraceFlag != '\0') {
        pcVar9 = entry_info->filename;
        pFVar12 = TraceFP();
        fprintf((FILE *)pFVar12,"Adding file to BTree: %s\n",pcVar9);
      }
      HTBTree_add(bt,entry_info);
    }
  } while( true );
}



int setup_connection(char *name,HTParentAnchor *anchor)

{
  int iVar1;
  FILE *pFVar2;
  int iVar3;
  char *pcVar4;
  ushort **ppuVar5;
  uint uVar6;
  int in_GS_OFFSET;
  HTParentAnchor *anchor_local;
  char *name_local;
  socklen_t sslen;
  int p1;
  int p0;
  int h3;
  int h2;
  int h1;
  int h0;
  char *p;
  char *command;
  int status;
  int retry;
  char c3;
  char c2;
  char c1;
  char c0;
  char dst [257];
  sockaddr_storage ss;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  status = -99;
  if (WWW_TraceFlag != '\0') {
    pFVar2 = TraceFP();
    fprintf((FILE *)pFVar2,"setup_connection(%s)\n",name);
  }
  use_list = '\0';
  server_type = GENERIC_SERVER;
  Broken_RETR = 0;
  Broken_EPSV = 0;
  retry = 0;
LAB_08112d91:
  if ((1 < retry) || (iVar3 = get_connection(name,anchor), status = iVar3, iVar3 < 0))
  goto LAB_08112d9e;
  if (ftp_local_passive == '\0') {
    status = get_listen_socket();
    if (status < 0) {
      close(control->socket);
      control->socket = -1;
      if (have_socket != '\0') {
        close_master_socket();
      }
      goto LAB_08112d9e;
    }
    status = response(port_command);
    if (status == -0x752e) {
      if (WWW_TraceFlag != '\0') {
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2,"HTFTP: Interrupted in response (port_command)\n");
      }
      mustshow = '\x01';
      pcVar4 = (char *)gettext("Connection interrupted.");
      HTProgress(pcVar4);
      close(control->socket);
      control->socket = -1;
      close_master_socket();
      status = -0x752e;
      goto LAB_08112d9e;
    }
    if (status == 2) {
      if (WWW_TraceFlag != '\0') {
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2,"HTFTP: Port defined.\n");
      }
      goto LAB_08112d7e;
    }
    if (-1 < status) {
      status = -status;
      goto LAB_08112d9e;
    }
  }
  else {
    command = (char *)0x0;
    p = "?";
    data_soc = iVar3;
    if (Broken_EPSV == 0) {
      p = "EPSV";
      status = send_cmd_1("EPSV");
    }
    else {
      status = 1;
    }
    if (-1 < status) {
      if (status != 2) {
        p = "PASV";
        status = send_cmd_1("PASV");
        if (status < 0) goto LAB_08112d8a;
        if (status != 2) {
          status = -status;
          goto LAB_08112d9e;
        }
      }
      iVar3 = strcmp(p,"PASV");
      if (iVar3 != 0) {
        iVar3 = strcmp(p,"EPSV");
        if (iVar3 == 0) {
          p = response_text;
          while ((*p != '\0' && (ppuVar5 = __ctype_b_loc(), ((*ppuVar5)[*p] & 0x2000) == 0))) {
            p = p + 1;
          }
          for (; (*p != '\0' && ((*p != '\0' && (*p != '(')))); p = p + 1) {
          }
          status = sscanf(p,"(%c%c%c%d%c)",&c0,&c1,&c2,&p0,&c3);
          if (status != 5) {
            pFVar2 = TraceFP();
            fwrite("HTFTP: EPSV reply has invalid format!\n",1,0x26,(FILE *)pFVar2);
            status = -99;
            goto LAB_08112d9e;
          }
          passive_port = (PortNumber)p0;
          sslen = 0x80;
          iVar3 = getpeername(control->socket,(sockaddr *)&ss,&sslen);
          if (iVar3 < 0) {
            pFVar2 = TraceFP();
            fwrite("HTFTP: getpeername(control) failed\n",1,0x23,(FILE *)pFVar2);
            status = -99;
            goto LAB_08112d9e;
          }
          iVar3 = getnameinfo((sockaddr *)&ss,sslen,dst,0x101,(char *)0x0,0,1);
          if (iVar3 != 0) {
            pFVar2 = TraceFP();
            fwrite("HTFTP: getnameinfo failed\n",1,0x1a,(FILE *)pFVar2);
            status = -99;
            goto LAB_08112d9e;
          }
        }
        goto LAB_08112c6c;
      }
      for (p = response_text; (*p != '\0' && (*p != ',')); p = p + 1) {
      }
      do {
        pcVar4 = p;
        p = p + -1;
        if ((p < response_text + 1) || (*p < '0')) break;
      } while (*p < ':');
      status = sscanf(pcVar4,"%d,%d,%d,%d,%d,%d",&h0,&h1,&h2,&h3,&p0,&p1);
      if (status < 4) {
        pFVar2 = TraceFP();
        fwrite("HTFTP: PASV reply has no inet address!\n",1,0x27,(FILE *)pFVar2);
        status = -99;
        goto LAB_08112d9e;
      }
      passive_port = (short)(p0 << 8) + (short)p1;
      sprintf(dst,"%d.%d.%d.%d",h0,h1,h2,h3);
LAB_08112c6c:
      if (WWW_TraceFlag != '\0') {
        uVar6 = (uint)passive_port;
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2,"HTFTP: Server is listening on port %d\n",uVar6);
      }
      HTSprintf0(&command,"%s//%s:%d/",&DAT_08181e7f,dst,(uint)passive_port);
      status = HTDoConnect(command,"FTP data",(uint)passive_port,&data_soc);
      if (command != (char *)0x0) {
        free(command);
        command = (char *)0x0;
      }
      iVar3 = data_soc;
      if (status < 0) {
        pcVar4 = (char *)gettext("connect for data");
        HTInetStatus(pcVar4);
        close(data_soc);
      }
      else {
        if (WWW_TraceFlag != '\0') {
          pFVar2 = TraceFP();
          fprintf((FILE *)pFVar2,"FTP data connected, socket %d\n",iVar3);
        }
LAB_08112d7e:
        status = 0;
      }
LAB_08112d9e:
      if (WWW_TraceFlag != '\0') {
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2,"setup_connection returns %d\n",status);
      }
      if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
        return status;
      }
                    // WARNING: Subroutine does not return
      __stack_chk_fail();
    }
  }
LAB_08112d8a:
  retry = retry + 1;
  goto LAB_08112d91;
}



int HTFTPLoad(char *name,HTParentAnchor *anchor,HTFormat format_out,HTStream *sink)

{
  int iVar1;
  FILE *pFVar2;
  ushort **ppuVar3;
  int iVar4;
  size_t sVar5;
  HTAtom *pHVar6;
  CompressFileType CVar7;
  char *pcVar8;
  int in_GS_OFFSET;
  bool bVar9;
  char *pcVar10;
  char *local_124;
  int local_120;
  uint local_118;
  char local_114;
  char *local_110;
  HTStream *sink_local;
  HTFormat format_out_local;
  HTParentAnchor *anchor_local;
  char *name_local;
  CompressFileType cft;
  char *fn;
  char *FileName;
  int rv;
  int check;
  int cplen;
  int i;
  char *cp2_2;
  char *cp1;
  char *mode;
  char *cp2_1;
  char *cp2;
  char *cp;
  char *types;
  char *type;
  char *vmsname;
  char *fname;
  char *filename;
  HTFormat format;
  int outstanding;
  int final_status;
  int status;
  HTAtom *encoding;
  BOOLEAN found_tilde;
  BOOLEAN included_device;
  BOOLEAN binary;
  BOOLEAN isDirectory;
  sockaddr_storage soc_address;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  isDirectory = '\0';
  encoding = (HTAtom *)0x0;
  outstanding = 1;
  if (WWW_TraceFlag != '\0') {
    if (ftp_local_passive == '\0') {
      local_124 = "normal";
    }
    else {
      local_124 = "passive";
    }
    pFVar2 = TraceFP();
    fprintf((FILE *)pFVar2,"HTFTPLoad(%s) %s connection\n",name,local_124);
  }
  HTReadProgress(0,0);
  local_120 = setup_connection(name,anchor);
  status = local_120;
  if (local_120 < 0) goto LAB_0811504e;
  fname = HTParse(name,"",5);
  vmsname = (char *)0x0;
  type = (char *)0x0;
  types = (char *)0x0;
  filename = fname;
  if ((server_type == CMS_SERVER) && (cp = strstr(fname,"%2"), cp != (char *)0x0)) {
    ppuVar3 = __ctype_b_loc();
    if (((*ppuVar3)[(byte)cp[2]] & 0x200) == 0) {
      bVar9 = cp[2] == 'F';
    }
    else {
      iVar4 = toupper((uint)(byte)cp[2]);
      bVar9 = iVar4 == 0x46;
    }
    if (bVar9) {
      if (fname != (char *)0x0) {
        free(fname);
        fname = (char *)0x0;
      }
      init_help_message_cache();
      close(control->socket);
      control->socket = -1;
      if (WWW_TraceFlag != '\0') {
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2,"HTFTP: Rejecting path due to illegal escaped slash.\n");
      }
      local_120 = -1;
      goto LAB_0811504e;
    }
  }
  if (*filename == '\0') {
    HTSACopy(&filename,"/");
    type = "D";
  }
  else {
    types = strrchr(filename,0x3b);
    type = types;
    if (types != (char *)0x0) {
      iVar4 = strncasecomp(types + 1,"type=",5);
      if (iVar4 == 0) {
        ppuVar3 = __ctype_b_loc();
        if (((*ppuVar3)[(byte)type[6]] & 0x200) == 0) {
          local_118 = (uint)(byte)type[6];
        }
        else {
          local_118 = toupper((uint)(byte)type[6]);
        }
        if (local_118 == 0x44) {
          *types = '\0';
          type = "D";
        }
        else if (local_118 == 0x49) {
          *types = '\0';
          type = "I";
        }
        else if (local_118 == 0x41) {
          *types = '\0';
          type = "A";
        }
        else {
          type = "";
        }
        if (*filename == '\0') {
          *filename = '/';
          filename[1] = '\0';
        }
      }
      if ((*type != '\0') && (WWW_TraceFlag != '\0')) {
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2,"HTFTP: type=%s\n",type);
      }
    }
  }
  HTUnEscape(filename);
  pcVar8 = filename;
  if (WWW_TraceFlag != '\0') {
    pFVar2 = TraceFP();
    fprintf((FILE *)pFVar2,"HTFTP: UnEscaped %s\n",pcVar8);
  }
  if (filename[1] == '~') {
    cp2 = (char *)0x0;
    fn = (char *)0x0;
    cp2 = strchr(filename + 1,0x2f);
    if (cp2 != (char *)0x0) {
      *cp2 = '\0';
    }
    status = send_cmd_1("PWD");
    if (((status == 2) && (response_text[5] == '/')) &&
       (status = send_cmd_2("CWD",filename + 1), status == 2)) {
      HTSACopy(&fn,filename + 1);
      pcVar8 = fn;
      if (cp2 != (char *)0x0) {
        *cp2 = '/';
        sVar5 = strlen(fn);
        if (pcVar8[sVar5 - 1] == '/') {
          HTSACat(&fn,cp2 + 1);
        }
        else {
          HTSACat(&fn,cp2);
        }
        cp2 = (char *)0x0;
      }
      if (fname != (char *)0x0) {
        free(fname);
      }
      filename = fn;
      fname = fn;
    }
    if (cp2 != (char *)0x0) {
      *cp2 = '/';
    }
  }
  sVar5 = strlen(filename);
  if (sVar5 < 4) {
    format = HTFileFormat(filename,&encoding,(char **)0x0);
  }
  else {
    cp2_1 = strrchr(filename,0x2e);
    if (((cp2_1 == (char *)0x0) || (iVar4 = strncasecomp(cp2_1,".me",3), iVar4 != 0)) ||
       ((cp2_1[3] != '\0' && (cp2_1[3] != ';')))) {
      format = HTFileFormat(filename,&encoding,(char **)0x0);
    }
    else if ((server_type == UNIX_SERVER) &&
            ((cp2_1 <= filename + 3 || (iVar4 = strncasecomp(cp2_1 + -4,"read.me",7), iVar4 != 0))))
    {
      format = HTFileFormat(filename,&encoding,(char **)0x0);
    }
    else {
      *cp2_1 = '\0';
      format = HTFileFormat(filename,&encoding,(char **)0x0);
      *cp2_1 = '.';
    }
  }
  format = HTCharsetFormat(format,anchor,-1);
  pHVar6 = HTAtom_for("8bit");
  if ((pHVar6 == encoding) || (pHVar6 = HTAtom_for("7bit"), pHVar6 == encoding)) {
    local_114 = '\0';
  }
  else {
    local_114 = '\x01';
  }
  binary = local_114;
  if ((local_114 == '\0') &&
     ((((format_out == WWW_SOURCE || (pHVar6 = HTAtom_for("www/download"), pHVar6 == format_out)) ||
       (pHVar6 = HTAtom_for("www/dump"), pHVar6 == format_out)) && (server_type != CMS_SERVER)))) {
    binary = '\x01';
  }
  if (((binary == '\0') && (type != (char *)0x0)) && (*type == 'I')) {
    binary = '\x01';
  }
  else if (((binary != '\0') && (type != (char *)0x0)) && (*type == 'A')) {
    binary = '\0';
  }
  if (control->binary != binary) {
    if (binary == '\0') {
      local_110 = "A";
    }
    else {
      local_110 = "I";
    }
    mode = local_110;
    status = send_cmd_2("TYPE",local_110);
    if (status != 2) {
      init_help_message_cache();
      local_120 = -((status >> 0x1f ^ status) - (status >> 0x1f));
      goto LAB_0811504e;
    }
    control->binary = binary;
  }
  if (server_type == VMS_SERVER) {
    included_device = '\0';
    found_tilde = '\0';
    pcVar8 = strchr(filename,0x3a);
    if ((pcVar8 != (char *)0x0) || (pcVar8 = strchr(filename,0x5b), pcVar8 != (char *)0x0)) {
      if (fname != (char *)0x0) {
        free(fname);
        fname = (char *)0x0;
      }
      init_help_message_cache();
      close(control->socket);
      control->socket = -1;
      if (WWW_TraceFlag != '\0') {
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2,"HTFTP: Rejecting path due to non-Unix-style syntax.\n");
      }
      local_120 = -1;
      goto LAB_0811504e;
    }
    pcVar10 = (char *)0x2;
    iVar4 = strncmp(filename,"//",2);
    pcVar8 = filename;
    if (iVar4 == 0) {
      included_device = '\x01';
      for (i = 0; filename[i + 1] != '\0'; i = i + 1) {
        filename[i] = filename[i + 1];
      }
      filename[i] = '\0';
      if (WWW_TraceFlag != '\0') {
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2,"HTFTP: Trimmed \'%s\'\n",pcVar8);
        pcVar10 = pcVar8;
      }
      cp = HTVMS_name("",filename);
      if (WWW_TraceFlag != '\0') {
        pFVar2 = TraceFP();
        pcVar10 = cp;
        fprintf((FILE *)pFVar2,"HTFTP: VMSized \'%s\'\n",cp);
      }
      cp1 = strrchr(cp,0x5d);
      if (cp1 == (char *)0x0) {
        cp1 = strchr(cp,0x3a);
        if (((cp1 == (char *)0x0) || (pcVar8 = strchr(cp,0x5b), pcVar8 != (char *)0x0)) ||
           (pcVar8 = strchr(cp,0x5d), pcVar8 != (char *)0x0)) {
          iVar4 = strcmp(cp,filename + 1);
          if (iVar4 == 0) {
            status = send_cmd_2("CWD",cp);
            if (status != 2) {
              pcVar10 = cp;
              HTSprintf0(&vmsname,"%s:",cp);
              status = send_cmd_2("CWD",vmsname);
              if (status != 2) {
                if (fname != (char *)0x0) {
                  free(fname);
                  fname = (char *)0x0;
                }
                init_help_message_cache();
                close(control->socket);
                control->socket = -1;
                local_120 = -((status >> 0x1f ^ status) - (status >> 0x1f));
                goto LAB_0811504e;
              }
            }
            HTSprintf0(&vmsname,"000000",pcVar10);
            filename = vmsname;
          }
        }
        else {
          cp1 = cp1 + 1;
          if (*cp1 != '\0') {
            cplen = (int)cp1 - (int)cp;
            strcpy(filename,cp1);
            pcVar8 = filename;
            if (WWW_TraceFlag != '\0') {
              pFVar2 = TraceFP();
              fprintf((FILE *)pFVar2,"HTFTP: Filename \'%s\'\n",pcVar8);
            }
            iVar4 = cplen;
            pcVar8 = cp;
            pcVar10 = filename;
            HTSprintf0(&vmsname,"%.*s[%s]",cplen,cp,filename);
            status = send_cmd_2("CWD",vmsname);
            if (status == 2) {
              HTSprintf0(&vmsname,"000000",iVar4,pcVar8,pcVar10);
              filename = vmsname;
            }
            else {
              HTSprintf(&vmsname,"%.*s[000000]",cplen,cp);
              status = send_cmd_2("CWD",vmsname);
              if (status != 2) {
                HTSprintf(&vmsname,"%.*s",cplen,cp);
                status = send_cmd_2("CWD",vmsname);
                if (status != 2) {
                  if (fname != (char *)0x0) {
                    free(fname);
                    fname = (char *)0x0;
                  }
                  init_help_message_cache();
                  close(control->socket);
                  control->socket = -1;
                  local_120 = -((status >> 0x1f ^ status) - (status >> 0x1f));
                  goto LAB_0811504e;
                }
              }
            }
          }
        }
      }
      else {
        cp1 = cp1 + 1;
        strcpy(filename,cp1);
        pcVar8 = filename;
        if (WWW_TraceFlag != '\0') {
          pFVar2 = TraceFP();
          fprintf((FILE *)pFVar2,"HTFTP: Filename \'%s\'\n",pcVar8);
        }
        *cp1 = '\0';
        status = send_cmd_2("CWD",cp);
        if (status != 2) {
          fn = (char *)0x0;
          cp1 = strchr(cp,0x5b);
          if (cp1 == (char *)0x0) {
            if (fname != (char *)0x0) {
              free(fname);
              fname = (char *)0x0;
            }
            init_help_message_cache();
            close(control->socket);
            control->socket = -1;
            local_120 = -((status >> 0x1f ^ status) - (status >> 0x1f));
            goto LAB_0811504e;
          }
          *cp1 = '\0';
          cp1 = cp1 + 1;
          status = send_cmd_2("CWD",cp);
          if (status != 2) {
            if (fname != (char *)0x0) {
              free(fname);
              fname = (char *)0x0;
            }
            init_help_message_cache();
            close(control->socket);
            control->socket = -1;
            local_120 = -((status >> 0x1f ^ status) - (status >> 0x1f));
            goto LAB_0811504e;
          }
          HTSprintf0(&fn,"[.%s",cp1);
          status = send_cmd_2("CWD",fn);
          if (fn != (char *)0x0) {
            free(fn);
            fn = (char *)0x0;
          }
          if (status != 2) {
            if (fname != (char *)0x0) {
              free(fname);
              fname = (char *)0x0;
            }
            init_help_message_cache();
            close(control->socket);
            control->socket = -1;
            local_120 = -((status >> 0x1f ^ status) - (status >> 0x1f));
            goto LAB_0811504e;
          }
        }
      }
    }
    sVar5 = strlen(filename);
    pcVar8 = filename;
    if ((1 < sVar5) && (sVar5 = strlen(filename), pcVar10 = filename, pcVar8[sVar5 - 1] == '/')) {
      sVar5 = strlen(filename);
      pcVar10[sVar5 - 1] = '\0';
    }
    iVar4 = strcmp(filename,"/~");
    if (((iVar4 != 0) &&
        ((included_device == '\0' || (iVar4 = strcmp(filename,"000000"), iVar4 != 0)))) &&
       ((sVar5 = strlen(filename), sVar5 != 1 || (*filename != '/')))) {
      iVar4 = strncmp(filename,"/~",2);
      if (iVar4 == 0) {
        filename = filename + 2;
        found_tilde = '\x01';
      }
      pcVar8 = filename;
      if (WWW_TraceFlag != '\0') {
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2,"check \'%s\' to translate x/y/ to [.x.y]\n",pcVar8);
      }
      if ((((included_device == '\0') && (cp = strchr(filename,0x2f), cp != (char *)0x0)) &&
          (cp1 = strrchr(cp,0x2f), cp1 != (char *)0x0)) && (1 < (int)cp1 - (int)cp)) {
        fn = (char *)0x0;
        HTSprintf0(&fn,"[.%.*s]",cp1 + (-1 - (int)cp),cp + 1);
        pcVar8 = fn;
        if (WWW_TraceFlag != '\0') {
          pFVar2 = TraceFP();
          fprintf((FILE *)pFVar2,"change path \'%s\'\n",pcVar8);
        }
        while (cp2_2 = strrchr(fn,0x2f), pcVar8 = fn, cp2_2 != (char *)0x0) {
          *cp2_2 = '.';
        }
        if (WWW_TraceFlag != '\0') {
          pFVar2 = TraceFP();
          fprintf((FILE *)pFVar2,"...to  path \'%s\'\n",pcVar8);
        }
        status = send_cmd_2("CWD",fn);
        if (fn != (char *)0x0) {
          free(fn);
          fn = (char *)0x0;
        }
        if (status != 2) {
          if (fname != (char *)0x0) {
            free(fname);
            fname = (char *)0x0;
          }
          init_help_message_cache();
          close(control->socket);
          control->socket = -1;
          local_120 = -((status >> 0x1f ^ status) - (status >> 0x1f));
          goto LAB_0811504e;
        }
        filename = cp1 + 1;
      }
      else if ((included_device == '\0') && (found_tilde == '\0')) {
        filename = filename + 1;
      }
      goto LAB_08114651;
    }
    isDirectory = '\x01';
    status = send_cmd_1("LIST");
    if (fname != (char *)0x0) {
      free(fname);
      fname = (char *)0x0;
    }
    if (status != 1) {
      init_help_message_cache();
      close(control->socket);
      control->socket = -1;
      local_120 = -((status >> 0x1f ^ status) - (status >> 0x1f));
      goto LAB_0811504e;
    }
  }
  else {
    if (server_type == CMS_SERVER) {
      sVar5 = strlen(filename);
      if ((((sVar5 == 1) && (*filename == '/')) ||
          ((iVar4 = strncasecomp(filename + 1,"vmsysu:",7), iVar4 == 0 &&
           ((cp = strchr(filename + 1,0x2e), cp != (char *)0x0 &&
            (pcVar8 = strchr(cp,0x2f), pcVar8 == (char *)0x0)))))) ||
         ((iVar4 = strncasecomp(filename + 1,"anonymou.",9), iVar4 == 0 &&
          (pcVar8 = strchr(filename + 1,0x2f), pcVar8 == (char *)0x0)))) {
        if ((filename[1] != '\0') && (status = send_cmd_2("CWD",filename + 1), status != 2)) {
          init_help_message_cache();
          close(control->socket);
          control->socket = -1;
          local_120 = -((status >> 0x1f ^ status) - (status >> 0x1f));
          goto LAB_0811504e;
        }
        isDirectory = '\x01';
        if (use_list == '\0') {
          status = send_cmd_1("NLST");
        }
        else {
          status = send_cmd_1("LIST");
        }
        if (fname != (char *)0x0) {
          free(fname);
          fname = (char *)0x0;
        }
        if (status != 1) {
          init_help_message_cache();
          close(control->socket);
          control->socket = -1;
          local_120 = -((status >> 0x1f ^ status) - (status >> 0x1f));
          goto LAB_0811504e;
        }
        goto listen;
      }
      filename = filename + 1;
      while (pcVar8 = strchr(filename,0x2f), pcVar8 != (char *)0x0) {
        *pcVar8 = '\0';
        cp = pcVar8 + 1;
        status = send_cmd_2("CWD",filename);
        if (status == 2) {
          if (*cp == '\0') {
            isDirectory = '\x01';
            if (use_list == '\0') {
              status = send_cmd_1("NLST");
            }
            else {
              status = send_cmd_1("LIST");
            }
            if (fname != (char *)0x0) {
              free(fname);
              fname = (char *)0x0;
            }
            if (status == 1) {
              init_help_message_cache();
              goto listen;
            }
            init_help_message_cache();
            close(control->socket);
            control->socket = -1;
            local_120 = -((status >> 0x1f ^ status) - (status >> 0x1f));
            goto LAB_0811504e;
          }
          filename = cp;
        }
      }
      cp = (char *)0x0;
    }
    else {
      iVar4 = strncmp(filename,"//",2);
      if (iVar4 == 0) {
        filename = filename + 1;
      }
    }
LAB_08114651:
    if ((type == (char *)0x0) || ((type != (char *)0x0 && (*type != 'D')))) {
      status = send_cmd_2("RETR",filename);
      if ((4 < status) && (Broken_RETR != 0)) {
        if (WWW_TraceFlag != '\0') {
          pFVar2 = TraceFP();
          fprintf((FILE *)pFVar2,"{{reconnecting...\n");
        }
        close_connection(control);
        check = setup_connection(name,anchor);
        if (WWW_TraceFlag != '\0') {
          pFVar2 = TraceFP();
          fprintf((FILE *)pFVar2,"...done }}reconnecting\n");
        }
        if (check < 0) {
          local_120 = check;
          goto LAB_0811504e;
        }
      }
    }
    else {
      status = 5;
    }
    if (status != 1) {
      iVar4 = strcmp(filename,"/");
      if (iVar4 != 0) {
        init_help_message_cache();
      }
      status = send_cmd_2("CWD",filename);
      if (status == 2) {
        isDirectory = '\x01';
        if (use_list == '\0') {
          status = send_cmd_1("NLST");
        }
        else {
          status = send_cmd_1("LIST");
        }
      }
    }
    if (fname != (char *)0x0) {
      free(fname);
      fname = (char *)0x0;
    }
    if (vmsname != (char *)0x0) {
      free(vmsname);
      vmsname = (char *)0x0;
    }
    if (status != 1) {
      init_help_message_cache();
      close(control->socket);
      control->socket = -1;
      if (status < 0) {
        local_120 = status;
      }
      else {
        local_120 = -status;
      }
      goto LAB_0811504e;
    }
  }
listen:
  if (ftp_local_passive == '\0') {
    fn = (char *)0x80;
    status = accept(master_socket,(sockaddr *)&soc_address,(socklen_t *)&fn);
    if (status < 0) {
      init_help_message_cache();
      local_120 = HTInetStatus("accept");
      goto LAB_0811504e;
    }
    if (WWW_TraceFlag != '\0') {
      pFVar2 = TraceFP();
      fprintf((FILE *)pFVar2,"TCP: Accepted new socket %d\n",status);
    }
    data_soc = status;
  }
  if (isDirectory == '\0') {
    FileName = HTParse(name,"",5);
    init_help_message_cache();
    HTUnEscape(FileName);
    if ((((encoding == (HTAtom *)0x0) || (pHVar6 = HTAtom_for("identity"), pHVar6 == encoding)) ||
        (pHVar6 = HTAtom_for("8bit"), pHVar6 == encoding)) ||
       ((pHVar6 = HTAtom_for("binary"), pHVar6 == encoding ||
        (pHVar6 = HTAtom_for("7bit"), pHVar6 == encoding)))) {
      CVar7 = HTCompressFileType(FileName,"._-",(int *)&fn);
      if (CVar7 != cftNone) {
        fn[(int)FileName] = '\0';
        format = HTFileFormat(FileName,&encoding,(char **)0x0);
        format = HTCharsetFormat(format,anchor,-1);
        HTSACopy(&anchor->content_type,format->name);
        format = HTAtom_for("www/compressed");
        if (CVar7 == cftGzip) {
          HTSACopy(&anchor->content_encoding,"x-gzip");
        }
        else if (CVar7 < cftBzip2) {
          if (CVar7 == cftCompress) {
            HTSACopy(&anchor->content_encoding,"x-compress");
          }
        }
        else if (CVar7 == cftBzip2) {
          HTSACopy(&anchor->content_encoding,"x-bzip2");
        }
        else if (CVar7 == cftDeflate) {
          HTSACopy(&anchor->content_encoding,"x-deflate");
        }
      }
    }
    else {
      HTSACopy(&anchor->content_type,format->name);
      HTSACopy(&anchor->content_encoding,encoding->name);
      format = HTAtom_for("www/compressed");
    }
    if (FileName != (char *)0x0) {
      free(FileName);
      FileName = (char *)0x0;
    }
    mustshow = '\x01';
    pcVar8 = (char *)gettext("Receiving FTP file.");
    HTProgress(pcVar8);
    rv = HTParseSocket(format,format_out,anchor,data_soc,(HTStream_conflict4 *)sink);
    HTInitInput(control->socket);
    iVar4 = data_soc;
    if (rv < 0) {
      if (rv == -2) {
        outstanding = outstanding + -1;
      }
      else if ((rv == -0x752e) || (rv == -1)) {
        outstanding = 0;
      }
      if (WWW_TraceFlag != '\0') {
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2,"HTFTP: Closing data socket %d\n",iVar4);
      }
      status = close(data_soc);
    }
    else {
      status = 2;
    }
    if (((status < 0) && (rv != -0x752e)) && (rv != -1)) {
      HTInetStatus("close");
    }
    else if ((rv != 200) && (bVar9 = outstanding != 0, outstanding = outstanding + -1, bVar9)) {
      status = response((char *)0x0);
      if ((status != 2) && ((rv != -0x752e && (rv != -1)))) {
        data_soc = -1;
        init_help_message_cache();
        local_120 = HTLoadError((HTStream_conflict *)sink,500,response_text);
        goto LAB_0811504e;
      }
      if (status < 1) {
        outstanding = 0;
      }
      else if ((status == 2) && (iVar4 = strncmp(response_text,"221",3), iVar4 == 0)) {
        outstanding = 0;
      }
    }
    final_status = 200;
  }
  else {
    if (((server_type == UNIX_SERVER) && (unsure_type == 0)) &&
       (iVar4 = strcmp(response_text,"150 Opening ASCII mode data connection for /bin/dl.\n"),
       iVar4 == 0)) {
      if (WWW_TraceFlag != '\0') {
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2,"HTFTP: Treating as \"dls\" server.\n");
      }
      server_type = DLS_SERVER;
    }
    final_status = read_directory(anchor,name,format_out,sink);
    if (final_status < 1) {
      outstanding = 0;
    }
    else if (((server_type != CMS_SERVER) &&
             (bVar9 = 0 < outstanding, outstanding = outstanding + -1, bVar9)) &&
            ((status = response((char *)0x0), status < 0 ||
             ((status == 2 && (iVar4 = strncmp(response_text,"221",3), iVar4 == 0)))))) {
      outstanding = 0;
    }
    iVar4 = data_soc;
    if (data_soc != -1) {
      if (WWW_TraceFlag != '\0') {
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2,"HTFTP: Closing data socket %d\n",iVar4);
      }
      status = close(data_soc);
      if (status == -1) {
        HTInetStatus("close");
      }
    }
    status = final_status;
  }
  do {
    iVar4 = outstanding + -1;
    bVar9 = outstanding < 1;
    outstanding = iVar4;
    if ((bVar9) || (status < 1)) break;
    status = response((char *)0x0);
  } while ((status != 2) || (iVar4 = strncmp(response_text,"221",3), iVar4 != 0));
  data_soc = -1;
  if (WWW_TraceFlag != '\0') {
    pFVar2 = TraceFP();
    fprintf((FILE *)pFVar2,"HTFTPLoad: normal end; ");
  }
  if (control->socket < 0) {
    if (WWW_TraceFlag != '\0') {
      iVar4 = control->socket;
      pFVar2 = TraceFP();
      fprintf((FILE *)pFVar2,"control socket is %d\n",iVar4);
    }
  }
  else {
    if (WWW_TraceFlag != '\0') {
      iVar4 = control->socket;
      pFVar2 = TraceFP();
      fprintf((FILE *)pFVar2,"closing control socket %d\n",iVar4);
    }
    status = close(control->socket);
    if (status == -1) {
      HTInetStatus("control connection close");
    }
  }
  control->socket = -1;
  init_help_message_cache();
  local_120 = final_status;
LAB_0811504e:
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return local_120;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void HTClearFTPPassword(void)

{
  if (user_entered_password != (char *)0x0) {
    free(user_entered_password);
    user_entered_password = (char *)0x0;
  }
  return;
}



// WARNING: Unknown calling convention

int HTInetStatus(char *where)

{
  int iVar1;
  int iVar2;
  int *piVar3;
  char *pcVar4;
  FILE *__stream;
  int saved_errno;
  int status;
  
  piVar3 = __errno_location();
  iVar1 = *piVar3;
  if (WWW_TraceFlag != '\0') {
    piVar3 = __errno_location();
    pcVar4 = strerror(*piVar3);
    piVar3 = __errno_location();
    iVar2 = *piVar3;
    __stream = TraceFP();
    fprintf((FILE *)__stream,"TCP: Error %d in `SOCKET_ERRNO\' after call to %s() failed.\n\t%s\n",
            iVar2,where,pcVar4);
  }
  piVar3 = __errno_location();
  *piVar3 = iVar1;
  piVar3 = __errno_location();
  return -*piVar3;
}



// WARNING: Unknown calling convention

uint HTCardinal(int *pstatus,char **pp,uint max_value)

{
  uint local_18;
  uint n;
  
  if ((**pp < '0') || ('9' < **pp)) {
    *pstatus = -3;
    local_18 = 0;
  }
  else {
    n = 0;
    while (('/' < **pp && (**pp < ':'))) {
      n = (n * 10 + (int)**pp) - 0x30;
      *pp = *pp + 1;
    }
    if (max_value < n) {
      *pstatus = -4;
      local_18 = 0;
    }
    else {
      local_18 = n;
    }
  }
  return local_18;
}



// WARNING: Unknown calling convention

char * HTInetString(SockA *soc_in)

{
  socklen_t local_8;
  
  if ((short)soc_in == 10) {
    local_8 = 0x1c;
  }
  else {
    local_8 = 0x10;
  }
  getnameinfo((sockaddr *)soc_in,local_8,HTInetString::hostbuf,0x40,(char *)0x0,0,1);
  return HTInetString::hostbuf;
}



// WARNING: Unknown calling convention

BOOLEAN valid_hostname(char *name)

{
  ushort **ppuVar1;
  BOOLEAN local_19;
  BOOLEAN local_18;
  char *cp;
  int iseg;
  int i;
  
  i = 1;
  iseg = 0;
  cp = name;
  if ((name == (char *)0x0) || (*name == '\0')) {
    local_19 = '\0';
  }
  else {
    for (; (*cp != '\0' && (i < 0xfe)); i = i + 1) {
      if (*cp == '.') {
        if (iseg == 0) {
          return '\0';
        }
        iseg = 0;
      }
      else {
        if ((iseg == 0) && ((*cp == '-' || (*cp == '+')))) {
          return '\0';
        }
        iseg = iseg + 1;
        if (0x3f < iseg) {
          return '\0';
        }
        ppuVar1 = __ctype_b_loc();
        if ((((((*ppuVar1)[(byte)*cp] & 8) == 0) && (*cp != '-')) && (*cp != '_')) &&
           ((*cp != '$' && (*cp != '+')))) {
          return '\0';
        }
      }
      cp = cp + 1;
    }
    if ((*cp == '\0') || (((*cp == '.' && (iseg != 0)) && (cp[1] == '\0')))) {
      local_18 = '\x01';
    }
    else {
      local_18 = '\0';
    }
    local_19 = local_18;
  }
  return local_19;
}



// WARNING: Unknown calling convention

void quench(int sig)

{
                    // WARNING: Subroutine does not return
  _exit(2);
}



// WARNING: Unknown calling convention

void dump_hostent(char *msgprefix,hostent *phost)

{
  byte bVar1;
  char *pcVar2;
  char **ppcVar3;
  char *pcVar4;
  int iVar5;
  FILE *pFVar6;
  undefined *local_34;
  undefined *local_30;
  undefined *local_28;
  undefined *local_24;
  undefined *local_1c;
  char **pcnt;
  int i;
  
  if (WWW_TraceFlag != '\0') {
    if (WWW_TraceFlag != '\0') {
      pFVar6 = TraceFP();
      fprintf((FILE *)pFVar6,"%s: %p ",msgprefix,phost);
    }
    if (phost != (hostent *)0x0) {
      if (WWW_TraceFlag != '\0') {
        pcVar2 = phost->h_name;
        pFVar6 = TraceFP();
        fprintf((FILE *)pFVar6,"{ h_name = %p",pcVar2);
      }
      if (phost->h_name == (char *)0x0) {
        if (WWW_TraceFlag != '\0') {
          pFVar6 = TraceFP();
          fprintf((FILE *)pFVar6,",");
        }
      }
      else if (WWW_TraceFlag != '\0') {
        pcVar2 = phost->h_name;
        pFVar6 = TraceFP();
        fprintf((FILE *)pFVar6," \"%s\",",pcVar2);
      }
      if (WWW_TraceFlag != '\0') {
        ppcVar3 = phost->h_aliases;
        pFVar6 = TraceFP();
        fprintf((FILE *)pFVar6,"\n\t h_aliases = %p",ppcVar3);
      }
      if (phost->h_aliases == (char **)0x0) {
        if (WWW_TraceFlag != '\0') {
          pFVar6 = TraceFP();
          fprintf((FILE *)pFVar6,",\n\t");
        }
      }
      else {
        if (WWW_TraceFlag != '\0') {
          pFVar6 = TraceFP();
          fprintf((FILE *)pFVar6," {");
        }
        for (pcnt = phost->h_aliases; *pcnt != (char *)0x0; pcnt = pcnt + 1) {
          if (WWW_TraceFlag != '\0') {
            pcVar2 = *pcnt;
            pcVar4 = *pcnt;
            if (phost->h_aliases == pcnt) {
              local_34 = &DAT_0818229c;
            }
            else {
              local_34 = &DAT_0818229e;
            }
            pFVar6 = TraceFP();
            fprintf((FILE *)pFVar6,"%s %p \"%s\"",local_34,pcVar4,pcVar2);
          }
        }
        if (WWW_TraceFlag != '\0') {
          if (*phost->h_aliases == (char *)0x0) {
            local_30 = &DAT_0818229c;
          }
          else {
            local_30 = &DAT_0818229e;
          }
          pFVar6 = TraceFP();
          fprintf((FILE *)pFVar6,"%s0x0 },\n\t",local_30);
        }
      }
      if (WWW_TraceFlag != '\0') {
        iVar5 = phost->h_addrtype;
        pFVar6 = TraceFP();
        fprintf((FILE *)pFVar6," h_addrtype = %d,",iVar5);
      }
      if (WWW_TraceFlag != '\0') {
        iVar5 = phost->h_length;
        pFVar6 = TraceFP();
        fprintf((FILE *)pFVar6," h_length = %d,\n\t",iVar5);
      }
      if (WWW_TraceFlag != '\0') {
        ppcVar3 = phost->h_addr_list;
        pFVar6 = TraceFP();
        fprintf((FILE *)pFVar6," h_addr_list = %p",ppcVar3);
      }
      if (phost->h_addr_list == (char **)0x0) {
        if (WWW_TraceFlag != '\0') {
          pFVar6 = TraceFP();
          fprintf((FILE *)pFVar6,"}");
        }
      }
      else {
        if (WWW_TraceFlag != '\0') {
          pFVar6 = TraceFP();
          fprintf((FILE *)pFVar6," {");
        }
        for (pcnt = phost->h_addr_list; *pcnt != (char *)0x0; pcnt = pcnt + 1) {
          if (WWW_TraceFlag != '\0') {
            pcVar2 = *pcnt;
            if (phost->h_addr_list == pcnt) {
              local_28 = &DAT_081822f1;
            }
            else {
              local_28 = &DAT_08182285;
            }
            pFVar6 = TraceFP();
            fprintf((FILE *)pFVar6,"%s %p",local_28,pcVar2);
          }
          for (i = 0; i < phost->h_length; i = i + 1) {
            if (WWW_TraceFlag != '\0') {
              if (i + 1 == phost->h_length) {
                local_24 = &DAT_081822f8;
              }
              else {
                local_24 = &DAT_081822f1;
              }
              bVar1 = (*pcnt)[i];
              if (i == 0) {
                local_1c = &DAT_081822fa;
              }
              else {
                local_1c = &DAT_081822fd;
              }
              pFVar6 = TraceFP();
              fprintf((FILE *)pFVar6,"%s%d%s",local_1c,(uint)bVar1,local_24);
            }
          }
        }
        if (*phost->h_addr_list == (char *)0x0) {
          if (WWW_TraceFlag != '\0') {
            pFVar6 = TraceFP();
            fprintf((FILE *)pFVar6," 0x0 } }");
          }
        }
        else if (WWW_TraceFlag != '\0') {
          pFVar6 = TraceFP();
          fprintf((FILE *)pFVar6,", 0x0 } }");
        }
      }
    }
    if (WWW_TraceFlag != '\0') {
      pFVar6 = TraceFP();
      fprintf((FILE *)pFVar6,"\n");
    }
    pFVar6 = TraceFP();
    fflush((FILE *)pFVar6);
  }
  return;
}



// WARNING: Unknown calling convention

size_t fill_rehostent(char *rehostent,size_t rehostentsize,hostent *phost)

{
  uint uVar1;
  size_t sVar2;
  size_t local_48;
  int i_alias;
  int i_addr;
  size_t required_this_alias;
  size_t mem_this_alias;
  size_t chk_available;
  size_t available;
  size_t curlen;
  size_t required_per_addr;
  size_t name_len;
  char **p_next_charptr;
  char *p_next_char;
  char **pcnt;
  int num_aliases;
  int num_addrs;
  AlignedHOSTENT *data;
  
  num_addrs = 0;
  num_aliases = 0;
  name_len = 0;
  available = rehostentsize - 0x14;
  if (phost == (hostent *)0x0) {
    local_48 = 0;
  }
  else {
    uVar1 = phost->h_length + 4;
    if (phost->h_addr_list != (char **)0x0) {
      available = rehostentsize - 0x18;
    }
    if (phost->h_aliases != (char **)0x0) {
      available = available - 4;
    }
    if (phost->h_name != (char *)0x0) {
      available = available - 1;
    }
    if (((phost->h_addr_list != (char **)0x0) && (*phost->h_addr_list != (char *)0x0)) &&
       (uVar1 <= available)) {
      num_addrs = 1;
      available = available - uVar1;
    }
    if (phost->h_name != (char *)0x0) {
      name_len = strlen(phost->h_name);
      if (available < name_len) {
        name_len = 0;
      }
      else {
        available = available - name_len;
      }
    }
    if (num_addrs != 0) {
      pcnt = phost->h_addr_list;
      for (; (pcnt = pcnt + 1, *pcnt != (char *)0x0 && (uVar1 <= available));
          available = available - uVar1) {
        num_addrs = num_addrs + 1;
      }
    }
    chk_available = available;
    if (phost->h_aliases != (char **)0x0) {
      for (pcnt = phost->h_aliases; *pcnt != (char *)0x0; pcnt = pcnt + 1) {
        sVar2 = strlen(*pcnt);
        if (sVar2 + 5 <= chk_available) {
          num_aliases = num_aliases + 1;
          chk_available = chk_available - (sVar2 + 5);
        }
      }
    }
    *(int *)(rehostent + 8) = phost->h_addrtype;
    *(int *)(rehostent + 0xc) = phost->h_length;
    p_next_charptr = (char **)(rehostent + 0x14);
    p_next_char = rehostent + 0x14;
    if (phost->h_addr_list != (char **)0x0) {
      p_next_char = p_next_char + (num_addrs + 1) * 4;
    }
    if (phost->h_aliases != (char **)0x0) {
      p_next_char = p_next_char + (num_aliases + 1) * 4;
    }
    if (phost->h_addr_list == (char **)0x0) {
      *(undefined4 *)(rehostent + 0x10) = 0;
    }
    else {
      *(char ***)(rehostent + 0x10) = p_next_charptr;
      pcnt = phost->h_addr_list;
      for (i_addr = 0; i_addr < num_addrs; i_addr = i_addr + 1) {
        memcpy(p_next_char,*pcnt,4);
        *p_next_charptr = p_next_char;
        p_next_charptr = p_next_charptr + 1;
        p_next_char = p_next_char + 4;
        pcnt = pcnt + 1;
      }
      *p_next_charptr = (char *)0x0;
      p_next_charptr = p_next_charptr + 1;
    }
    if (phost->h_name == (char *)0x0) {
      *(undefined4 *)rehostent = 0;
    }
    else {
      *(char **)rehostent = p_next_char;
      if (name_len == 0) {
        *p_next_char = '\0';
        p_next_char = p_next_char + 1;
      }
      else {
        strcpy(p_next_char,phost->h_name);
        p_next_char = p_next_char + name_len + 1;
      }
    }
    if (phost->h_aliases == (char **)0x0) {
      *(undefined4 *)(rehostent + 4) = 0;
    }
    else {
      *(char ***)(rehostent + 4) = p_next_charptr;
      pcnt = phost->h_aliases;
      for (i_alias = 0; (*pcnt != (char *)0x0 && (i_alias < num_addrs)); i_alias = i_alias + 1) {
        sVar2 = strlen(*pcnt);
        if (sVar2 + 5 <= available) {
          i_alias = i_alias + 1;
          available = available - (sVar2 + 5);
          strcpy(p_next_char,*pcnt);
          *p_next_charptr = p_next_char;
          p_next_charptr = p_next_charptr + 1;
          p_next_char = p_next_char + sVar2 + 1;
        }
        p_next_char = p_next_char + 4;
        pcnt = pcnt + 1;
      }
      *p_next_charptr = (char *)0x0;
    }
    local_48 = (int)p_next_char - (int)rehostent;
  }
  return local_48;
}



// WARNING: Unknown calling convention

uint readit(int fd,char *buffer,uint length)

{
  ssize_t sVar1;
  uint got;
  uint result;
  
  result = 0;
  while( true ) {
    if (length == 0) {
      return result;
    }
    sVar1 = read(fd,buffer,length);
    if (sVar1 == 0) break;
    result = result + sVar1;
    buffer = buffer + sVar1;
    length = length - sVar1;
  }
  return result;
}



// WARNING: Unknown calling convention

hostent * LYGetHostByName(char *str)

{
  BOOLEAN BVar1;
  FILE *pFVar2;
  wchar_t wVar3;
  int *piVar4;
  hostent *phost_00;
  time_t tVar5;
  uint uVar6;
  size_t sVar7;
  fd_set readfds;
  sigset_t new_sigset;
  sigset_t old_sigset;
  _statuses statuses;
  timeval one_second;
  int pfd [2];
  anon_union_4_2_13109f1b __u_8;
  anon_union_4_2_13109f1b __u_7;
  anon_union_4_2_13109f1b __u_6;
  anon_union_4_2_13109f1b __u_5;
  anon_union_4_2_13109f1b __u_4;
  anon_union_4_2_13109f1b __u_3;
  anon_union_4_2_13109f1b __u_2;
  anon_union_4_2_13109f1b __u_1;
  anon_union_4_2_13109f1b __u;
  int kbd_fd;
  fd_set *__arr;
  uint __i;
  hostent *phost;
  int child_exited;
  long dns_patience;
  time_t start_time;
  int waitstat;
  int readret;
  int selret;
  int waitret;
  int fpid;
  int got_rehostent;
  hostent *result_phost;
  size_t rehostentlen;
  char *rehostent;
  char *host;
  
  host = str;
  rehostent = (char *)&LYGetHostByName::aligned_full_rehostent;
  rehostentlen = 0;
  result_phost = (hostent *)0x0;
  if (str == (char *)0x0) {
    if (WWW_TraceFlag != '\0') {
      pFVar2 = TraceFP();
      fprintf((FILE *)pFVar2,"LYGetHostByName: Can\'t parse `NULL\'.\n");
    }
    lynx_nsl_status = -900;
  }
  else {
    if (WWW_TraceFlag != '\0') {
      pFVar2 = TraceFP();
      fprintf((FILE *)pFVar2,"LYGetHostByName: parsing `%s\'.\n",str);
    }
    wVar3 = HTCheckForInterrupt();
    if (wVar3 == L'\0') {
      BVar1 = valid_hostname(host);
      if (BVar1 == '\0') {
        lynx_nsl_status = -0x196;
        my_errno = 3;
      }
      else {
        if (WWW_TraceFlag != '\0') {
          pFVar2 = TraceFP();
          fflush((FILE *)pFVar2);
        }
        lynx_nsl_status = -900;
        statuses.h_errno_valid = '\0';
        got_rehostent = 0;
        waitstat = 0;
        start_time = time((time_t *)0x0);
        dns_patience = 0x1e;
        child_exited = 0;
        do {
          do {
            waitret = waitpid(-1,(int *)0x0,1);
          } while (0 < waitret);
        } while ((waitret == -1) && (piVar4 = __errno_location(), *piVar4 == 4));
        waitret = 0;
        pipe(pfd);
        sigemptyset((sigset_t *)&new_sigset);
        sigaddset((sigset_t *)&new_sigset,0xf);
        sigaddset((sigset_t *)&new_sigset,2);
        sigaddset((sigset_t *)&new_sigset,1);
        sigaddset((sigset_t *)&new_sigset,0x14);
        sigaddset((sigset_t *)&new_sigset,0x1c);
        sigprocmask(0,(sigset_t *)&new_sigset,(sigset_t *)&old_sigset);
        fpid = fork();
        if (fpid == 0) {
          signal(0xf,quench);
          signal(2,quench);
          signal(1,quench);
          if (no_suspend == '\0') {
            signal(0x14,(__sighandler_t)0x0);
          }
          else {
            signal(0x14,(__sighandler_t)0x1);
          }
          signal(0x1c,(__sighandler_t)0x1);
          signal(0xb,(__sighandler_t)0x0);
          signal(4,(__sighandler_t)0x0);
          sigprocmask(2,(sigset_t *)&old_sigset,(sigset_t *)0x0);
          close(pfd[0]);
          piVar4 = __errno_location();
          *piVar4 = 0;
          phost_00 = gethostbyname(host);
          piVar4 = __errno_location();
          statuses.child_errno = *piVar4;
          statuses.child_h_errno = my_errno;
          dump_hostent("CHILD gethostbyname",(hostent *)phost_00);
          if ((phost_00 != (hostent *)0x0) && (phost_00->h_length != 0)) {
            rehostentlen = fill_rehostent(rehostent,0x80,(hostent *)phost_00);
            dump_hostent("CHILD fill_rehostent",(hostent *)rehostent);
          }
          if (((rehostentlen < 0x15) || (rehostent == (char *)0x0)) ||
             (*(int *)(rehostent + 0xc) == 0)) {
            rehostentlen = 0;
            statuses.h_length = 0;
          }
          else {
            statuses.h_length = *(int *)(rehostent + 0xc);
          }
          if (statuses.child_errno == 0) {
            piVar4 = __errno_location();
            statuses.child_errno = *piVar4;
          }
          statuses.rehostentlen = rehostentlen;
          write(pfd[1],&statuses,0x14);
          if (rehostentlen != 0) {
            write(pfd[1],rehostent,rehostentlen);
            close(pfd[1]);
                    // WARNING: Subroutine does not return
            _exit(0);
          }
                    // WARNING: Subroutine does not return
          _exit(1);
        }
        sVar7 = 0;
        sigprocmask(2,(sigset_t *)&old_sigset,(sigset_t *)0x0);
        close(pfd[1]);
        if (fpid < 0) {
          close(pfd[0]);
failed:
          if (WWW_TraceFlag != '\0') {
            pFVar2 = TraceFP();
            fprintf((FILE *)pFVar2,"LYGetHostByName: Can\'t find internet node name `%s\'.\n",host);
          }
        }
        else {
LAB_08116337:
          do {
            if ((child_exited == 0) &&
               (tVar5 = time((time_t *)0x0), dns_patience <= tVar5 - start_time)) {
LAB_08116359:
              close(pfd[0]);
              if (waitret < 1) {
                kill(fpid,0xf);
                sVar7 = 1;
                waitret = waitpid(fpid,&waitstat,1);
              }
              if (0 < waitret) {
                if ((waitstat & 0x7fU) == 0) {
                  if (WWW_TraceFlag != '\0') {
                    uVar6 = waitstat & 0xff00;
                    pFVar2 = TraceFP();
                    sVar7 = waitret;
                    fprintf((FILE *)pFVar2,
                            "LYGetHostByName: NSL_FORK child %d exited, status 0x%x.\n",waitret,
                            (int)uVar6 >> 8);
                  }
                }
                else if ((char)(((byte)waitstat & 0x7f) + 1) >> 1 < '\x01') {
                  if (((waitstat & 0xffU) == 0x7f) && (WWW_TraceFlag != '\0')) {
                    uVar6 = waitstat & 0xff00;
                    pFVar2 = TraceFP();
                    sVar7 = waitret;
                    fprintf((FILE *)pFVar2,
                            "LYGetHostByName: NSL_FORK child %d is stopped, status 0x%x!\n",waitret,
                            (int)uVar6 >> 8);
                  }
                }
                else {
                  if (WWW_TraceFlag != '\0') {
                    uVar6 = waitstat & 0x7f;
                    pFVar2 = TraceFP();
                    sVar7 = waitret;
                    fprintf((FILE *)pFVar2,
                            "LYGetHostByName: NSL_FORK child %d got signal, status 0x%x!\n",waitret,
                            uVar6);
                  }
                  if (((waitstat & 0x80U) != 0) && (WWW_TraceFlag != '\0')) {
                    pFVar2 = TraceFP();
                    sVar7 = waitret;
                    fprintf((FILE *)pFVar2,"LYGetHostByName: NSL_FORK child %d dumped core!\n",
                            waitret);
                  }
                }
              }
              if (got_rehostent != 0) {
                dump_hostent("End of LYGetHostByName",result_phost);
                if (WWW_TraceFlag != '\0') {
                  pFVar2 = TraceFP();
                  fprintf((FILE *)pFVar2,"LYGetHostByName: Resolved name to a hostent.\n",sVar7);
                }
                return result_phost;
              }
              goto failed;
            }
            for (__i = 0; __i < 0x20; __i = __i + 1) {
              readfds.fds_bits[__i] = 0;
            }
            wVar3 = LYConsoleInputFD('\x01');
            if (wVar3 != L'\xffffffff') {
              readfds.fds_bits[(uint)wVar3 >> 5] =
                   1 << ((byte)wVar3 & 0x1f) | readfds.fds_bits[(uint)wVar3 >> 5];
            }
            one_second.tv_sec = 1;
            one_second.tv_usec = 0;
            readfds.fds_bits[(uint)pfd[0] >> 5] =
                 1 << ((byte)pfd[0] & 0x1f) | readfds.fds_bits[(uint)pfd[0] >> 5];
            selret = select(pfd[0] + 1,(fd_set *)&readfds,(fd_set *)0x0,(fd_set *)0x0,
                            (timeval *)&one_second);
            if ((0 < selret) &&
               ((readfds.fds_bits[(uint)pfd[0] >> 5] >> ((byte)pfd[0] & 0x1f) & 1U) != 0)) {
              sVar7 = 0x14;
              readret = readit(pfd[0],(char *)&statuses,0x14);
              if (readret == 0x14) {
                my_errno = statuses.child_h_errno;
                piVar4 = __errno_location();
                *piVar4 = statuses.child_errno;
                if (0x14 < statuses.rehostentlen) {
                  sVar7 = statuses.rehostentlen;
                  readret = readit(pfd[0],rehostent,statuses.rehostentlen);
                  dump_hostent("Read from pipe",(hostent *)rehostent);
                  if (statuses.rehostentlen == readret) {
                    got_rehostent = 1;
                    result_phost = (hostent *)rehostent;
                    lynx_nsl_status = 0;
                  }
                  else if (statuses.h_errno_valid == '\0') {
                    lynx_nsl_status = -900;
                  }
                }
              }
              else {
                lynx_nsl_status = -1;
              }
              if (child_exited == 0) {
                sVar7 = 1;
                waitret = waitpid(fpid,&waitstat,1);
              }
              if (((waitstat & 0x7fU) != 0) && ((char)(((byte)waitstat & 0x7f) + 1) >> 1 < '\x01'))
              {
                kill(fpid,0xf);
                sVar7 = 1;
                waitret = waitpid(fpid,&waitstat,1);
              }
              goto LAB_08116359;
            }
            if (child_exited != 0) {
              sVar7 = 1;
              waitret = waitpid(fpid,&waitstat,1);
              goto LAB_08116359;
            }
            sVar7 = 1;
            waitret = waitpid(fpid,&waitstat,1);
            if (0 < waitret) {
              child_exited = 1;
              goto LAB_08116337;
            }
            wVar3 = HTCheckForInterrupt();
          } while (wVar3 == L'\0');
          if (WWW_TraceFlag != '\0') {
            pFVar2 = TraceFP();
            fprintf((FILE *)pFVar2,"LYGetHostByName: INTERRUPTED gethostbyname.\n");
          }
          kill(fpid,0xf);
          waitpid(fpid,(int *)0x0,1);
          close(pfd[0]);
          lynx_nsl_status = -0x752e;
        }
      }
    }
    else {
      if (WWW_TraceFlag != '\0') {
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2,"LYGetHostByName: INTERRUPTED for \'%s\'.\n",str);
      }
      lynx_nsl_status = -0x752e;
    }
  }
  return (hostent *)0x0;
}



addrinfo_conflict * HTGetAddrInfo(char *str,int defport)

{
  int iVar1;
  char *pcVar2;
  FILE *__stream;
  int in_GS_OFFSET;
  char *str_local;
  addrinfo_conflict hints;
  char *port;
  char *host;
  char *s;
  char *p;
  int error;
  addrinfo_conflict *res;
  char pbuf [80];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  s = (char *)0x0;
  HTSACopy(&s,str);
  if (*s == '[') {
    pcVar2 = strchr(s,0x5d);
    if (pcVar2 != (char *)0x0) {
      *pcVar2 = '\0';
      p = pcVar2 + 1;
      host = s + 1;
      goto LAB_081165f0;
    }
  }
  p = s;
  host = s;
LAB_081165f0:
  pcVar2 = strrchr(p,0x3a);
  if (pcVar2 == (char *)0x0) {
    sprintf(pbuf,"%d",defport);
    port = pbuf;
  }
  else {
    *pcVar2 = '\0';
    port = pcVar2 + 1;
  }
  memset(&hints,0,0x20);
  hints.ai_family = 0;
  hints.ai_socktype = 1;
  error = getaddrinfo(host,port,(addrinfo *)&hints,(addrinfo **)&res);
  if ((error != 0) || (res == (addrinfo_conflict *)0x0)) {
    if (WWW_TraceFlag != '\0') {
      pcVar2 = gai_strerror(error);
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTGetAddrInfo: getaddrinfo(%s, %s): %s\n",host,port,pcVar2);
    }
    res = (addrinfo_conflict *)0x0;
  }
  free(s);
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return res;
}



// WARNING: Unknown calling convention

void get_host_details(void)

{
  int iVar1;
  char *pcVar2;
  FILE *__stream;
  int in_GS_OFFSET;
  int namelength;
  char name [65];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if (hostname == (char *)0x0) {
    gethostname(name,0x41);
    HTSACopy(&hostname,name);
    pcVar2 = hostname;
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"TCP: Local host name is %s\n",pcVar2);
    }
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



// WARNING: Unknown calling convention

char * HTHostName(void)

{
  get_host_details();
  return hostname;
}



// WARNING: Unknown calling convention

BOOLEAN HTWasInterrupted(int *status)

{
  wchar_t wVar1;
  int *piVar2;
  BOOLEAN result;
  
  wVar1 = HTCheckForInterrupt();
  if (wVar1 != L'\0') {
    *status = -0x752e;
    piVar2 = __errno_location();
    *piVar2 = 4;
  }
  return wVar1 != L'\0';
}



// WARNING: Unknown calling convention

void set_timeout(timeval *timeoutp)

{
  timeoutp->tv_sec = 0;
  timeoutp->tv_usec = 100000;
  return;
}



int HTDoConnect(char *url,char *protocol,int default_port,int *s)

{
  char *pcVar1;
  BOOLEAN BVar2;
  undefined4 uVar3;
  char *fmt;
  char *pcVar4;
  int *piVar5;
  FILE *__stream;
  int iVar6;
  int in_GS_OFFSET;
  int local_8e8;
  int *s_local;
  char *protocol_local;
  char *url_local;
  fd_set writefds;
  timeval select_timeout;
  int ret_2;
  int val;
  fd_set *__arr;
  uint __i;
  int tries;
  int ret_1;
  int ret;
  addrinfo_conflict *res0;
  addrinfo_conflict *res;
  char *host;
  char *at_sign;
  char *p1;
  char *line;
  int status;
  char portbuf [1024];
  char hostbuf [1024];
  int local_c;
  
  local_c = *(int *)(in_GS_OFFSET + 0x14);
  status = 0;
  line = (char *)0x0;
  p1 = (char *)0x0;
  at_sign = (char *)0x0;
  host = (char *)0x0;
  res = (addrinfo_conflict *)0x0;
  res0 = (addrinfo_conflict *)0x0;
  p1 = HTParse(url,"",8);
  at_sign = strchr(p1,0x40);
  if (at_sign == (char *)0x0) {
    HTSACopy(&host,p1);
  }
  else {
    HTSACopy(&host,at_sign + 1);
  }
  if (p1 != (char *)0x0) {
    free(p1);
    p1 = (char *)0x0;
  }
  pcVar4 = host;
  uVar3 = gettext("Looking up ");
  HTSprintf0(&line,"%s%s",uVar3,pcVar4);
  mustshow = '\x01';
  HTProgress(line);
  res0 = HTGetAddrInfo(host,default_port);
  pcVar1 = host;
  if (res0 == (addrinfo_conflict *)0x0) {
    fmt = (char *)gettext("Unable to locate remote host %s.");
    HTSprintf0(&line,fmt,pcVar1,pcVar4);
    mustshow = '\x01';
    HTProgress(line);
    if (host != (char *)0x0) {
      free(host);
      host = (char *)0x0;
    }
    if (line != (char *)0x0) {
      free(line);
      line = (char *)0x0;
    }
    local_8e8 = -0xcc;
  }
  else {
    pcVar4 = (char *)gettext("Making %s connection to %s");
    HTSprintf0(&line,pcVar4,protocol,pcVar1);
    mustshow = '\x01';
    HTProgress(line);
    if (host != (char *)0x0) {
      free(host);
      host = (char *)0x0;
    }
    if (line != (char *)0x0) {
      free(line);
      line = (char *)0x0;
    }
    for (res = res0; res != (addrinfo_conflict *)0x0; res = res->ai_next) {
      iVar6 = socket(res->ai_family,res->ai_socktype,res->ai_protocol);
      *s = iVar6;
      if (*s == -1) {
        getnameinfo((sockaddr *)res->ai_addr,res->ai_addrlen,hostbuf,0x400,portbuf,0x400,3);
        iVar6 = res->ai_family;
        pcVar4 = (char *)gettext("socket failed: family %d addr %s port %s.");
        HTSprintf0(&line,pcVar4,iVar6,hostbuf,portbuf);
        mustshow = '\x01';
        HTProgress(line);
        if (line != (char *)0x0) {
          free(line);
          line = (char *)0x0;
        }
      }
      else {
        val = 1;
        ret = ioctl(*s,0x5421,&val);
        if (ret == -1) {
          mustshow = '\x01';
          pcVar4 = (char *)gettext("Could not make connection non-blocking.");
          HTProgress(pcVar4);
        }
        status = connect(*s,(sockaddr *)res->ai_addr,res->ai_addrlen);
        if ((status < 0) &&
           ((piVar5 = __errno_location(), *piVar5 == 0x73 ||
            (piVar5 = __errno_location(), *piVar5 == 0xb)))) {
          tries = 0;
          HTInetStatus("this socket\'s first connect");
          ret_1 = 0;
          do {
            do {
              if (0 < ret_1) goto LAB_08116fbc;
              iVar6 = tries / 10;
              tries = tries + 1;
              if (connect_timeout <= iVar6) {
                pcVar4 = (char *)gettext("Connection failed (too many retries).");
                HTAlert(pcVar4);
                if (line != (char *)0x0) {
                  free(line);
                  line = (char *)0x0;
                }
                if (res0 != (addrinfo_conflict *)0x0) {
                  freeaddrinfo((addrinfo *)res0);
                }
                local_8e8 = -0xcc;
                goto LAB_081170b7;
              }
              set_timeout(&select_timeout);
              __arr = &writefds;
              for (__i = 0; __i < 0x20; __i = __i + 1) {
                writefds.fds_bits[__i] = 0;
              }
              writefds.fds_bits[(uint)*s >> 5] =
                   1 << ((byte)*s & 0x1f) | writefds.fds_bits[(uint)*s >> 5];
              ret_1 = select(*s + 1,(fd_set *)0x0,(fd_set *)&writefds,(fd_set *)0x0,
                             (timeval *)&select_timeout);
              if (tries == 1) {
                HTInetStatus("this socket\'s first select");
              }
            } while ((ret_1 == -1) && (piVar5 = __errno_location(), *piVar5 == 4));
            if (ret_1 < 0) {
              HTInetStatus("failed select");
            }
            if ((ret_1 < 0) && (piVar5 = __errno_location(), *piVar5 != 0x72)) {
              status = ret_1;
              goto LAB_08116fbc;
            }
            if (ret_1 < 1) {
              status = connect(*s,(sockaddr *)res->ai_addr,res->ai_addrlen);
              if ((((status < 0) && (piVar5 = __errno_location(), *piVar5 != 0x72)) &&
                  (piVar5 = __errno_location(), *piVar5 != 0xb)) &&
                 (piVar5 = __errno_location(), *piVar5 != 0x6a)) {
                HTInetStatus("confirm-not-ready connect");
                goto LAB_08116fbc;
              }
            }
            else {
              status = connect(*s,(sockaddr *)res->ai_addr,res->ai_addrlen);
              if ((status < 0) && (piVar5 = __errno_location(), *piVar5 == 0x6a)) {
                status = 0;
              }
              if ((status == 0) || (piVar5 = __errno_location(), *piVar5 != 0x72)) {
                if (status < 0) {
                  HTInetStatus("confirm-ready connect");
                }
                goto LAB_08116fbc;
              }
              ret_1 = 0;
            }
            BVar2 = HTWasInterrupted(&status);
          } while (BVar2 == '\0');
          if (WWW_TraceFlag != '\0') {
            __stream = TraceFP();
            fprintf((FILE *)__stream,"*** INTERRUPTED in middle of connect.\n");
          }
        }
        else if (status < 0) {
          HTInetStatus("this socket\'s first and only connect");
        }
LAB_08116fbc:
        if (-1 < status) break;
        close(*s);
        *s = -1;
      }
    }
    if (*s < 0) {
      close(*s);
    }
    else {
      val = 0;
      iVar6 = ioctl(*s,0x5421,&val);
      if (iVar6 == -1) {
        mustshow = '\x01';
        pcVar4 = (char *)gettext("Could not restore socket to blocking.");
        HTProgress(pcVar4);
      }
    }
    if (line != (char *)0x0) {
      free(line);
      line = (char *)0x0;
    }
    if (res0 != (addrinfo_conflict *)0x0) {
      freeaddrinfo((addrinfo *)res0);
    }
    local_8e8 = status;
  }
LAB_081170b7:
  if (local_c == *(int *)(in_GS_OFFSET + 0x14)) {
    return local_8e8;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

int HTDoRead(int fildes,void *buf,uint nbyte)

{
  BOOLEAN BVar1;
  int iVar2;
  FILE *pFVar3;
  char *Msg;
  int *piVar4;
  time_t tVar5;
  int local_c0;
  fd_set readfds;
  timeval select_timeout;
  fd_set *__arr;
  uint __i;
  time_t t;
  time_t start;
  time_t otime;
  int otries;
  int tries;
  int ret;
  int result;
  BOOLEAN ready;
  
  tries = 0;
  otries = 0;
  start = time((time_t *)0x0);
  if (fildes == 0) {
    iVar2 = isatty(0);
    if (iVar2 != 0) {
      if (WWW_TraceFlag != '\0') {
        pFVar3 = TraceFP();
        fprintf((FILE *)pFVar3,"HTDoRead - refusing to read fd 0 which is a tty!\n");
      }
      return -1;
    }
  }
  else if (fildes < 1) {
    if (WWW_TraceFlag != '\0') {
      pFVar3 = TraceFP();
      fprintf((FILE *)pFVar3,"HTDoRead - no file descriptor!\n");
    }
    return -1;
  }
  BVar1 = HTWasInterrupted(&result);
  if (BVar1 == '\0') {
    ready = '\0';
    otime = start;
    do {
      while( true ) {
        if (ready != '\0') goto LAB_0811735c;
        iVar2 = tries / 10;
        tries = tries + 1;
        if (reading_timeout <= iVar2) {
          Msg = (char *)gettext("Socket read failed (too many tries).");
          HTAlert(Msg);
          piVar4 = __errno_location();
          *piVar4 = 4;
          result = -0x752e;
          goto LAB_0811735c;
        }
        if ((10 < tries - otries) &&
           (tVar5 = time((time_t *)0x0), otries = tries, 4 < tVar5 - otime)) {
          HTReadProgress(-1,0);
          otime = tVar5;
        }
        do {
          set_timeout(&select_timeout);
          for (__i = 0; __i < 0x20; __i = __i + 1) {
            readfds.fds_bits[__i] = 0;
          }
          readfds.fds_bits[(uint)fildes >> 5] =
               1 << ((byte)fildes & 0x1f) | readfds.fds_bits[(uint)fildes >> 5];
          iVar2 = select(fildes + 1,(fd_set *)&readfds,(fd_set *)0x0,(fd_set *)0x0,
                         (timeval *)&select_timeout);
        } while ((iVar2 == -1) && (piVar4 = __errno_location(), *piVar4 == 4));
        if (iVar2 < 0) {
          result = -1;
          goto LAB_0811735c;
        }
        if (iVar2 < 1) break;
        ready = '\x01';
      }
      BVar1 = HTWasInterrupted(&result);
    } while (BVar1 == '\0');
LAB_0811735c:
    if (ready != '\0') {
      do {
        result = read(fildes,buf,nbyte);
        if (result != -1) goto LAB_081173a2;
        piVar4 = __errno_location();
      } while (*piVar4 == 4);
      HTInetStatus("read");
    }
LAB_081173a2:
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x100U) != 0)) {
      tVar5 = time((time_t *)0x0);
      iVar2 = result;
      pFVar3 = TraceFP();
      fprintf((FILE *)pFVar3,"...HTDoRead returns %d (%d seconds)\n",iVar2,tVar5 - start);
    }
    local_c0 = result;
  }
  else {
    if (WWW_TraceFlag != '\0') {
      pFVar3 = TraceFP();
      fprintf((FILE *)pFVar3,"HTDoRead - interrupted before starting!\n");
    }
    local_c0 = result;
  }
  return local_c0;
}



void fake_put_character(void *p,char c)

{
  char c_local;
  
  return;
}



// WARNING: Unknown calling convention

char * state_name(sgml_state n)

{
  char *result;
  
  result = "?";
  switch(n) {
  case S_text:
    result = "S_text";
    break;
  case S_attr:
    result = "S_attr";
    break;
  case S_attr_gap:
    result = "S_attr_gap";
    break;
  case S_comment:
    result = "S_comment";
    break;
  case S_cro:
    result = "S_cro";
    break;
  case S_doctype:
    result = "S_doctype";
    break;
  case S_dollar:
    result = "S_dollar";
    break;
  case S_dollar_dq:
    result = "S_dollar_dq";
    break;
  case S_dollar_paren:
    result = "S_dollar_paren";
    break;
  case S_dollar_paren_dq:
    result = "S_dollar_paren_dq";
    break;
  case S_dollar_paren_sq:
    result = "S_dollar_paren_sq";
    break;
  case S_dollar_sq:
    result = "S_dollar_sq";
    break;
  case S_dquoted:
    result = "S_dquoted";
    break;
  case S_end:
    result = "S_end";
    break;
  case S_entity:
    result = "S_entity";
    break;
  case S_equals:
    result = "S_equals";
    break;
  case S_ero:
    result = "S_ero";
    break;
  case S_esc:
    result = "S_esc";
    break;
  case S_esc_dq:
    result = "S_esc_dq";
    break;
  case S_esc_sq:
    result = "S_esc_sq";
    break;
  case S_exclamation:
    result = "S_exclamation";
    break;
  case S_in_kanji:
    result = "S_in_kanji";
    break;
  case S_incro:
    result = "S_incro";
    break;
  case S_junk_tag:
    result = "S_junk_tag";
    break;
  case S_litteral:
    result = "S_litteral";
    break;
  case S_marked:
    result = "S_marked";
    break;
  case S_nonascii_text:
    result = "S_nonascii_text";
    break;
  case S_nonascii_text_dq:
    result = "S_nonascii_text_dq";
    break;
  case S_nonascii_text_sq:
    result = "S_nonascii_text_sq";
    break;
  case S_paren:
    result = "S_paren";
    break;
  case S_paren_dq:
    result = "S_paren_dq";
    break;
  case S_paren_sq:
    result = "S_paren_sq";
    break;
  case S_pcdata:
    result = "S_pcdata";
    break;
  case S_pi:
    result = "S_pi";
    break;
  case S_script:
    result = "S_script";
    break;
  case S_sgmlatt:
    result = "S_sgmlatt";
    break;
  case S_sgmlele:
    result = "S_sgmlele";
    break;
  case S_sgmlent:
    result = "S_sgmlent";
    break;
  case S_squoted:
    result = "S_squoted";
    break;
  case S_tag:
    result = "S_tag";
    break;
  case S_tag_gap:
    result = "S_tag_gap";
    break;
  case S_tagname_slash:
    result = "S_tagname_slash";
    break;
  case S_value:
    result = "S_value";
  }
  return result;
}



// WARNING: Unknown calling convention

HTElement * pool_alloc(void)

{
  HTElement *local_8;
  
  depth = depth + 1;
  if (depth < 0xb) {
    local_8 = pool + -(1 - depth);
  }
  else {
    local_8 = (HTElement *)malloc(8);
  }
  return local_8;
}



// WARNING: Unknown calling convention

void pool_free(HTElement *e)

{
  if ((10 < depth) && (e != (HTElement *)0x0)) {
    free(e);
  }
  depth = depth + -1;
  return;
}



void HTMLSRC_apply_markup(HTStream_conflict2 *context,HTlexeme lexeme,BOOLEAN start)

{
  FILE *__stream;
  HT_tagspec **local_34;
  char *local_2c;
  BOOLEAN start_local;
  HT_tagspec *ts;
  
  if (start == '\0') {
    local_34 = lexeme_end;
  }
  else {
    local_34 = lexeme_start;
  }
  for (ts = local_34[lexeme]; ts != (HT_tagspec *)0x0; ts = ts->next) {
    if (ts->start != '\0') {
      current_tag_style = ts->style;
      force_current_tag_style = '\x01';
      forced_classname = ts->class_name;
      force_classname = '\x01';
    }
    if (WWW_TraceFlag != '\0') {
      if (ts->start == '\0') {
        local_2c = "SRCSTOP %d\n";
      }
      else {
        local_2c = "SRCSTART %d\n";
      }
      __stream = TraceFP();
      fprintf((FILE *)__stream,local_2c,lexeme);
    }
    if (ts->start == '\0') {
      (*context->actions->end_element)(context->target,ts->element,&context->include);
    }
    else {
      (*context->actions->start_element)
                (context->target,ts->element,ts->present,ts->value,context->current_tag_charset,
                 &context->include);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void set_chartrans_handling(HTStream_conflict2 *context,HTParentAnchor *anchor,int chndl)

{
  LYUCcharset *pLVar1;
  int iVar2;
  
  if (chndl < 0) {
    chndl = HTAnchor_getUCLYhndl(anchor,2);
    if (chndl < 0) {
      chndl = HTAnchor_getUCLYhndl(anchor,3);
    }
    if (chndl < 0) {
      chndl = current_char_set;
    }
    HTAnchor_setUCInfoStage(anchor,chndl,3,1);
    HTAnchor_setUCInfoStage(anchor,chndl,2,1);
    pLVar1 = HTAnchor_getUCInfoStage(anchor,2);
    context->outUCI = pLVar1;
    iVar2 = HTAnchor_getUCLYhndl(context->node_anchor,2);
    context->outUCLYhndl = iVar2;
  }
  UCSetTransParams(&context->T,context->inUCLYhndl,context->inUCI,context->outUCLYhndl,
                   context->outUCI);
  if ((context->T).transp == '\0') {
    if ((context->T).decode_utf8 == '\0') {
      if (((context->T).do_8bitraw == '\0') && ((context->T).use_raw_char_in == '\0')) {
        if (((context->T).output_utf8 == '\0') && ((context->T).trans_from_uni == '\0')) {
          context->current_tag_charset = LATIN1;
        }
        else {
          iVar2 = UCGetLYhndl_byMIME("utf-8");
          context->current_tag_charset = iVar2;
        }
      }
      else {
        context->current_tag_charset = context->inUCLYhndl;
      }
    }
    else {
      context->current_tag_charset = context->inUCLYhndl;
    }
  }
  else {
    context->current_tag_charset = context->inUCLYhndl;
  }
  return;
}



// WARNING: Unknown calling convention

void change_chartrans_handling(HTStream_conflict2 *context)

{
  int iVar1;
  LYUCcharset *pLVar2;
  LYUCcharset *pLVar3;
  int chndl;
  int next_LYhndl;
  LYUCcharset *next_UCI;
  LYUCcharset *new_UCI;
  int new_LYhndl;
  
  iVar1 = HTAnchor_getUCLYhndl(context->node_anchor,1);
  if ((context->inUCLYhndl != iVar1) && (-1 < iVar1)) {
    pLVar2 = HTAnchor_getUCInfoStage(context->node_anchor,1);
    if (pLVar2 != (LYUCcharset *)0x0) {
      pLVar3 = HTAnchor_getUCInfoStage(context->node_anchor,2);
      chndl = HTAnchor_getUCLYhndl(context->node_anchor,2);
      context->inUCI = pLVar2;
      context->inUCLYhndl = iVar1;
      context->outUCI = pLVar3;
      context->outUCLYhndl = chndl;
      set_chartrans_handling(context,context->node_anchor,chndl);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void handle_attribute_name(HTStream_conflict2 *context,char *s)

{
  HTTag *pHVar1;
  AttrList paVar2;
  int iVar3;
  ushort **ppuVar4;
  uint uVar5;
  FILE *pFVar6;
  int local_40;
  uint local_3c;
  uint local_38;
  uint local_34;
  uint local_30;
  char *local_2c;
  int diff;
  int i;
  int low;
  int high;
  attr *attributes;
  HTTag *tag;
  
  pHVar1 = context->current_tag;
  paVar2 = pHVar1->attributes;
  if (psrc_view != '\0') {
    context->cur_attr_is_href = '\0';
    context->cur_attr_is_name = '\0';
  }
  if (context->unknown_tag == pHVar1) {
    if (psrc_view != '\0') {
      context->current_attribute_number = 1;
    }
  }
  else {
    low = 0;
    iVar3 = pHVar1->number_of_attributes;
    while (high = iVar3, low < high) {
      iVar3 = (high - low) / 2 + low;
      ppuVar4 = __ctype_b_loc();
      if (((*ppuVar4)[(byte)*paVar2[iVar3].name] & 0x200) == 0) {
        local_3c = (uint)(byte)*paVar2[iVar3].name;
      }
      else {
        local_3c = toupper((uint)(byte)*paVar2[iVar3].name);
      }
      ppuVar4 = __ctype_b_loc();
      if (((*ppuVar4)[(byte)*s] & 0x200) == 0) {
        local_38 = (uint)(byte)*s;
      }
      else {
        local_38 = toupper((uint)(byte)*s);
      }
      if (local_3c == local_38) {
        local_40 = strcasecomp(paVar2[iVar3].name,s);
      }
      else {
        ppuVar4 = __ctype_b_loc();
        if (((*ppuVar4)[(byte)*paVar2[iVar3].name] & 0x200) == 0) {
          local_34 = (uint)(byte)*paVar2[iVar3].name;
        }
        else {
          local_34 = toupper((uint)(byte)*paVar2[iVar3].name);
        }
        ppuVar4 = __ctype_b_loc();
        if (((*ppuVar4)[(byte)*s] & 0x200) == 0) {
          local_30 = (uint)(byte)*s;
        }
        else {
          local_30 = toupper((uint)(byte)*s);
        }
        local_40 = local_34 - local_30;
      }
      if (local_40 == 0) {
        context->current_attribute_number = iVar3;
        if (psrc_view != '\0') {
          context->cur_attr_is_name = paVar2[iVar3].type == '\x01';
          context->cur_attr_is_href = paVar2[iVar3].type == '\x02';
          return;
        }
        context->present[iVar3] = '\x01';
        if (context->value[iVar3] != (char *)0x0) {
          *context->value[iVar3] = '\0';
        }
        uVar5 = (uint)(paVar2[iVar3].type == '\x04');
        if (WWW_TraceFlag == '\0') {
          current_is_class = uVar5;
          return;
        }
        current_is_class = uVar5;
        pFVar6 = TraceFP();
        fprintf((FILE *)pFVar6,"SGML: found attribute %s, %d\n",s,uVar5);
        return;
      }
      if (local_40 < 0) {
        low = iVar3 + 1;
        iVar3 = high;
      }
    }
    if (WWW_TraceFlag != '\0') {
      if (context->current_tag->name == (char *)0x0) {
        local_2c = "";
      }
      else {
        local_2c = context->current_tag->name;
      }
      pFVar6 = TraceFP();
      fprintf((FILE *)pFVar6,"SGML: Unknown attribute %s for tag %s\n",s,local_2c);
    }
    context->current_attribute_number = -1;
  }
  return;
}



// WARNING: Unknown calling convention

void handle_attribute_value(HTStream_conflict2 *context,char *s)

{
  FILE *pFVar1;
  
  if (context->current_attribute_number == -1) {
    if (WWW_TraceFlag != '\0') {
      pFVar1 = TraceFP();
      fprintf((FILE *)pFVar1,"SGML: Attribute value %s ***ignored\n",s);
    }
  }
  else {
    HTSACopy_extra(context->value + context->current_attribute_number,s);
    if (current_is_class == 0) {
      if (WWW_TraceFlag != '\0') {
        pFVar1 = TraceFP();
        fprintf((FILE *)pFVar1,"SGML: attribute value is \'%s\'\n",s);
      }
    }
    else {
      strncpy(class_string,s,0x100);
      if (WWW_TraceFlag != '\0') {
        pFVar1 = TraceFP();
        fprintf((FILE *)pFVar1,"SGML: class is \'%s\'\n",s);
      }
    }
  }
  context->current_attribute_number = -1;
  return;
}



// WARNING: Unknown calling convention

BOOLEAN put_special_unicodes(HTStream_conflict2 *context,UCode_t code)

{
  BOOLEAN local_5;
  
  if (context->no_lynx_specialcodes == '\0') {
    if (code == 0xa0) {
      if (psrc_view == '\0') {
        (*context->actions->put_character)(context->target,'\x01');
      }
    }
    else if (code == 0xad) {
      if (psrc_view == '\0') {
        (*context->actions->put_character)(context->target,'\a');
      }
    }
    else if ((code == 0x2002) || (code == 0x2009)) {
      if (psrc_view == '\0') {
        (*context->actions->put_character)(context->target,'\x02');
      }
    }
    else {
      if (code != 0x2003) {
        return '\0';
      }
      if (psrc_view == '\0') {
        (*context->actions->put_character)(context->target,'\x02');
      }
    }
    local_5 = '\x01';
  }
  else {
    local_5 = '\0';
  }
  return local_5;
}



// WARNING: Unknown calling convention

void put_pretty_entity(HTStream_conflict2 *context,int term)

{
  HTMLSRC_apply_markup(context,HTL_entity,'\x01');
  (*context->actions->put_character)(context->target,'&');
  (*context->actions->put_string)(context->target,entity_string);
  if (term != 0) {
    (*context->actions->put_character)(context->target,(char)term);
  }
  HTMLSRC_apply_markup(context,HTL_entity,'\0');
  return;
}



// WARNING: Unknown calling convention

void put_pretty_number(HTStream_conflict2 *context)

{
  char *local_8;
  
  HTMLSRC_apply_markup(context,HTL_entity,'\x01');
  if (context->isHex == '\0') {
    local_8 = "&#";
  }
  else {
    local_8 = "&#x";
  }
  (*context->actions->put_string)(context->target,local_8);
  (*context->actions->put_string)(context->target,entity_string);
  (*context->actions->put_character)(context->target,';');
  HTMLSRC_apply_markup(context,HTL_entity,'\0');
  return;
}



void handle_entity(HTStream_conflict2 *context,char term)

{
  char *name;
  BOOLEAN BVar1;
  char cVar2;
  UCode_t code_00;
  uint uVar3;
  int iVar4;
  FILE *pFVar5;
  bool local_19;
  char term_local;
  char *s;
  long uck;
  UCode_t code;
  
  uck = -1;
  name = context->string->data;
  FoundEntity = '\0';
  code_00 = HTMLGetEntityUCValue(name);
  if (code_00 != 0) {
    BVar1 = put_special_unicodes(context,code_00);
    if (BVar1 != '\0') {
      if (psrc_view != '\0') {
        put_pretty_entity(context,(int)term);
      }
      FoundEntity = '\x01';
      return;
    }
    uck = UCTransUniChar(code_00,context->outUCLYhndl);
    if (((0x1f < uck) && (uck < 0x100)) &&
       ((uck < 0x7f || (LYlowest_eightbit[context->outUCLYhndl] <= uck)))) {
      if (psrc_view == '\0') {
        (*context->actions->put_character)(context->target,(char)uck);
      }
      else {
        put_pretty_entity(context,(int)term);
      }
      FoundEntity = '\x01';
      return;
    }
    if ((uck == -4) || ((((context->T).repl_translated_C0 != '\0' && (0 < uck)) && (uck < 0x20)))) {
      uVar3 = UCTransUniCharStr(replace_buf,0x3c,code_00,context->outUCLYhndl,0);
      uck = -((int)~uVar3 >> 0x1f);
      if (uck != 0) {
        if (psrc_view == '\0') {
          (*context->actions->put_string)(context->target,replace_buf);
        }
        else {
          put_pretty_entity(context,(int)term);
        }
        FoundEntity = '\x01';
        return;
      }
    }
    if ((context->T).output_utf8 != '\0') {
      if (psrc_view == '\0') {
        cVar2 = UCPutUtf8_charstring
                          ((HTStream *)context->target,
                           (putc_func_t *)context->actions->put_character,code_00);
      }
      else {
        cVar2 = UCPutUtf8_charstring((HTStream *)context->target,fake_put_character,code_00);
      }
      local_19 = cVar2 != '\0';
      if (local_19) {
        if (psrc_view != '\0') {
          put_pretty_entity(context,(int)term);
        }
        FoundEntity = '\x01';
        return;
      }
    }
    if ((0x1f < code_00) && (code_00 < 0x7f)) {
      if (psrc_view == '\0') {
        (*context->actions->put_character)(context->target,(char)code_00);
      }
      else {
        put_pretty_entity(context,(int)term);
      }
      FoundEntity = '\x01';
      return;
    }
    iVar4 = strcmp(name,"zwnj");
    if ((iVar4 == 0) || (iVar4 = strcmp(name,"zwj"), iVar4 == 0)) {
      if (WWW_TraceFlag != '\0') {
        pFVar5 = TraceFP();
        fprintf((FILE *)pFVar5,"handle_entity: Ignoring \'%s\'.\n",name);
      }
      if (psrc_view != '\0') {
        put_pretty_entity(context,(int)term);
      }
      FoundEntity = '\x01';
      return;
    }
    iVar4 = strcmp(name,"lrm");
    if ((iVar4 == 0) || (iVar4 = strcmp(name,"rlm"), iVar4 == 0)) {
      if (WWW_TraceFlag != '\0') {
        pFVar5 = TraceFP();
        fprintf((FILE *)pFVar5,"handle_entity: Ignoring \'%s\'.\n",name);
      }
      if (psrc_view != '\0') {
        put_pretty_entity(context,(int)term);
      }
      FoundEntity = '\x01';
      return;
    }
  }
  if (psrc_view != '\0') {
    HTMLSRC_apply_markup(context,HTL_badseq,'\x01');
  }
  if (WWW_TraceFlag != '\0') {
    pFVar5 = TraceFP();
    fprintf((FILE *)pFVar5,"SGML: Unknown entity \'%s\' %ld %ld\n",name,code_00,uck);
  }
  (*context->actions->put_character)(context->target,'&');
  (*context->actions->put_string)(context->target,name);
  if (term != '\0') {
    (*context->actions->put_character)(context->target,term);
  }
  if (psrc_view != '\0') {
    HTMLSRC_apply_markup(context,HTL_badseq,'\0');
  }
  return;
}



// WARNING: Unknown calling convention

void handle_comment(HTStream_conflict2 *context)

{
  char *__s1;
  BOOLEAN BVar1;
  FILE *__stream;
  int iVar2;
  char *s;
  
  __s1 = context->string->data;
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"SGML Comment:\n<%s>\n",__s1);
  }
  if (((context->csi == (char *)0x0) && (iVar2 = strncmp(__s1,"!--#",4), iVar2 == 0)) &&
     (BVar1 = LYCheckForCSI(context->node_anchor,&context->url), BVar1 == '\x01')) {
    LYDoCSI(context->url,__s1,&context->csi);
    return;
  }
  LYCommentHacks(context->node_anchor,context->string->data);
  return;
}



// WARNING: Unknown calling convention

void handle_identifier(HTStream_conflict2 *context)

{
  char *pcVar1;
  FILE *__stream;
  char *s;
  
  pcVar1 = context->string->data;
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"SGML Identifier:\n<%s>\n",pcVar1);
  }
  return;
}



// WARNING: Unknown calling convention

void handle_doctype(HTStream_conflict2 *context)

{
  FILE *pFVar1;
  char *pcVar2;
  char *s;
  
  pcVar2 = context->string->data;
  if (WWW_TraceFlag != '\0') {
    pFVar1 = TraceFP();
    fprintf((FILE *)pFVar1,"SGML Doctype:\n<%s>\n",pcVar2);
  }
  pcVar2 = strstr(pcVar2,"DTD XHTML ");
  if (pcVar2 != (char *)0x0) {
    if (WWW_TraceFlag != '\0') {
      pFVar1 = TraceFP();
      fprintf((FILE *)pFVar1,"...processing extended HTML\n");
    }
    context->extended_html = '\x01';
  }
  return;
}



// WARNING: Unknown calling convention

void handle_marked(HTStream_conflict2 *context)

{
  char *pcVar1;
  FILE *__stream;
  int iVar2;
  char *s;
  
  pcVar1 = context->string->data;
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"SGML Marked Section:\n<%s>\n",pcVar1);
  }
  iVar2 = strncmp(context->string->data,"![INCLUDE[",10);
  if (iVar2 == 0) {
    context->string->data[context->string->size + -3] = '\0';
    HTSACat(&context->include,context->string->data + 10);
  }
  else {
    iVar2 = strncmp(context->string->data,"![CDATA[",8);
    if (iVar2 == 0) {
      (*context->actions->put_block)
                (context->target,context->string->data + 8,context->string->size + -0xb);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void handle_processing_instruction(HTStream_conflict2 *context)

{
  char cVar1;
  FILE *pFVar2;
  int iVar3;
  char *pcVar4;
  bool bVar5;
  char *t;
  int flag;
  char *s;
  
  pcVar4 = context->string->data;
  if (WWW_TraceFlag != '\0') {
    pFVar2 = TraceFP();
    fprintf((FILE *)pFVar2,"SGML Processing instruction:\n<%s>\n",pcVar4);
  }
  iVar3 = strncmp(pcVar4,"?xml ",5);
  if (iVar3 == 0) {
    cVar1 = (context->T).decode_utf8;
    context->strict_xml = '\x01';
    if (cVar1 == '\0') {
      pcVar4 = strstr(pcVar4,"encoding=");
      bVar5 = false;
      if (pcVar4 != (char *)0x0) {
        t = pcVar4 + 9;
        if (*t == '\"') {
          t = pcVar4 + 10;
        }
        iVar3 = strncmp(t,"utf-8",5);
        bVar5 = iVar3 == 0;
      }
      if (bVar5) {
        if (WWW_TraceFlag != '\0') {
          pFVar2 = TraceFP();
          fprintf((FILE *)pFVar2,"...Use UTF-8 for XML\n");
        }
        (context->T).decode_utf8 = '\x01';
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

void handle_sgmlent(HTStream_conflict2 *context)

{
  char *pcVar1;
  FILE *__stream;
  char *s;
  
  pcVar1 = context->string->data;
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"SGML Entity Declaration:\n<%s>\n",pcVar1);
  }
  return;
}



// WARNING: Unknown calling convention

void handle_sgmlele(HTStream_conflict2 *context)

{
  char *pcVar1;
  FILE *__stream;
  char *s;
  
  pcVar1 = context->string->data;
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"SGML Element Declaration:\n<%s>\n",pcVar1);
  }
  return;
}



// WARNING: Unknown calling convention

void handle_sgmlatt(HTStream_conflict2 *context)

{
  char *pcVar1;
  FILE *__stream;
  char *s;
  
  pcVar1 = context->string->data;
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"SGML Attribute Declaration:\n<%s>\n",pcVar1);
  }
  return;
}



BOOLEAN element_valid_within(HTTag *new_tag,HTTag *stacked_tag,BOOLEAN direct)

{
  uint uVar1;
  BOOLEAN local_29;
  uint local_24;
  BOOLEAN local_20;
  BOOLEAN local_1c;
  BOOLEAN direct_local;
  TagClass usecontained;
  TagClass usecontains;
  
  if ((stacked_tag == (HTTag *)0x0) || (new_tag == (HTTag *)0x0)) {
    local_29 = '\x01';
  }
  else {
    if (direct == '\0') {
      uVar1 = stacked_tag->icontains;
      local_24 = new_tag->icontained;
    }
    else {
      uVar1 = stacked_tag->contains;
      local_24 = new_tag->contained;
    }
    if (new_tag == stacked_tag) {
      if (((uVar1 & 0x80000) == 0) || ((local_24 & 0x80000) == 0)) {
        local_20 = '\0';
      }
      else {
        local_20 = '\x01';
      }
      local_29 = local_20;
    }
    else {
      if (((new_tag->tagclass & uVar1) == 0) || ((stacked_tag->tagclass & local_24) == 0)) {
        local_1c = '\0';
      }
      else {
        local_1c = '\x01';
      }
      local_29 = local_1c;
    }
  }
  return local_29;
}



// WARNING: Unknown calling convention

canclose_t can_close(HTTag *new_tag,HTTag *stacked_tag)

{
  canclose_t local_8;
  
  if (stacked_tag == (HTTag *)0x0) {
    local_8 = close_NO;
  }
  else if ((stacked_tag->flags & 1U) == 0) {
    if (new_tag == stacked_tag) {
      local_8 = (canclose_t)((new_tag->canclose & 0x80000U) != 0);
    }
    else {
      local_8 = (canclose_t)((new_tag->canclose & stacked_tag->tagclass) != 0);
    }
  }
  else {
    local_8 = close_valid;
  }
  return local_8;
}



// WARNING: Unknown calling convention

void do_close_stacked(HTStream_conflict2 *context)

{
  HTElement *e_00;
  int iVar1;
  int local_20;
  byte local_19;
  HTMLElement e;
  HTElement *stacked;
  
  e_00 = context->element_stack;
  if (e_00 != (HTElement *)0x0) {
    if (context->inSELECT != '\0') {
      iVar1 = strcasecomp(e_00->tag->name,"SELECT");
      if (iVar1 == 0) {
        context->inSELECT = '\0';
      }
    }
    if ((int)e_00->tag - (int)context->dtd->tags < 0x19d0) {
      local_20 = ((int)e_00->tag - (int)context->dtd->tags >> 3) * -0x49249249;
    }
    else {
      local_20 = 0x4f;
    }
    if (psrc_view == '\0') {
      (*context->actions->end_element)(context->target,local_20,&context->include);
    }
    context->element_stack = e_00->next;
    pool_free(e_00);
    if (context->element_stack == (HTElement *)0x0) {
      local_19 = 0;
    }
    else {
      local_19 = (byte)context->element_stack->tag->flags & 0x40;
    }
    context->no_lynx_specialcodes = local_19;
  }
  return;
}



// WARNING: Unknown calling convention

int is_on_stack(HTStream_conflict2 *context,HTTag *old_tag)

{
  int local_1c;
  int i;
  HTElement *stacked;
  
  stacked = context->element_stack;
  i = 1;
  while( true ) {
    if (stacked == (HTElement *)0x0) {
      return 0;
    }
    if (stacked->tag == old_tag) break;
    if ((uint)((int)old_tag + (-0x1148 - (int)context->dtd->tags)) < 0x38) {
      local_1c = 0x19d0;
    }
    else {
      local_1c = ((int)old_tag - (int)context->dtd->tags >> 3) * 8;
    }
    if (stacked->tag == (HTTag *)((int)&context->dtd->tags->name + local_1c)) {
      return i;
    }
    stacked = stacked->next;
    i = i + 1;
  }
  return i;
}



// WARNING: Unknown calling convention

void end_element(HTStream_conflict2 *context,HTTag *old_tag)

{
  char *pcVar1;
  char *pcVar2;
  char *pcVar3;
  HTElement *e_00;
  bool bVar4;
  BOOLEAN BVar5;
  FILE *pFVar6;
  int iVar7;
  char *local_60;
  char *local_54;
  HTTag *local_50;
  int local_48;
  int local_44;
  int local_38;
  byte local_31;
  HTTag *t;
  HTElement *N;
  HTMLElement e;
  int status;
  int stackpos;
  canclose_t canclose_check;
  BOOLEAN extra_action_taken;
  
  bVar4 = false;
  canclose_check = close_valid;
  stackpos = is_on_stack(context,old_tag);
  if (Old_DTD == 0) {
    while (((canclose_check != close_NO && (context->element_stack != (HTElement *)0x0)) &&
           ((1 < stackpos || ((!bVar4 && (stackpos == 0))))))) {
      if ((stackpos == 0) &&
         (((old_tag->flags & 2U) != 0 &&
          (BVar5 = element_valid_within(old_tag,context->element_stack->tag,'\x01'), BVar5 != '\0'))
         )) {
        if (WWW_TraceFlag == '\0') {
          return;
        }
        pcVar1 = old_tag->name;
        pFVar6 = TraceFP();
        fprintf((FILE *)pFVar6,"SGML: </%s> ignored\n",pcVar1);
        return;
      }
      canclose_check = can_close(old_tag,context->element_stack->tag);
      if (canclose_check != close_NO) {
        if (WWW_TraceFlag != '\0') {
          pcVar1 = old_tag->name;
          if (canclose_check == close_valid) {
            local_60 = "supplied,";
          }
          else {
            local_60 = "***forced by";
          }
          pcVar2 = context->element_stack->tag->name;
          pFVar6 = TraceFP();
          fprintf((FILE *)pFVar6,"SGML: End </%s> \t<- %s end </%s>\n",pcVar2,local_60,pcVar1);
        }
        do_close_stacked(context);
        bVar4 = true;
        stackpos = is_on_stack(context,old_tag);
      }
    }
    if ((stackpos == 0) && (old_tag->contents != SGML_EMPTY)) {
      if (WWW_TraceFlag == '\0') {
        return;
      }
      pcVar1 = old_tag->name;
      pcVar2 = old_tag->name;
      if (context->element_stack == (HTElement *)0x0) {
        local_54 = "none";
      }
      else {
        local_54 = context->element_stack->tag->name;
      }
      pFVar6 = TraceFP();
      fprintf((FILE *)pFVar6,"SGML: Still open %s, ***no open %s for </%s>\n",local_54,pcVar2,pcVar1
             );
      return;
    }
    if (1 < stackpos) {
      if (WWW_TraceFlag == '\0') {
        return;
      }
      pcVar1 = old_tag->name;
      pcVar2 = context->element_stack->tag->name;
      pcVar3 = old_tag->name;
      pFVar6 = TraceFP();
      fprintf((FILE *)pFVar6,"SGML: Nesting <%s>...<%s> \t<- ***invalid end </%s>\n",pcVar3,pcVar2,
              pcVar1);
      return;
    }
  }
  if (context->inSELECT != '\0') {
    iVar7 = strcasecomp(old_tag->name,"SELECT");
    if (iVar7 != 0) {
      if (WWW_TraceFlag == '\0') {
        return;
      }
      pcVar1 = old_tag->name;
      pFVar6 = TraceFP();
      fprintf((FILE *)pFVar6,"SGML: ***Ignoring end tag </%s> in SELECT block.\n",pcVar1);
      return;
    }
    context->inSELECT = '\0';
  }
  if (WWW_TraceFlag != '\0') {
    pcVar1 = old_tag->name;
    pFVar6 = TraceFP();
    fprintf((FILE *)pFVar6,"SGML: End </%s>\n",pcVar1);
  }
  if (old_tag->contents == SGML_EMPTY) {
    if (WWW_TraceFlag != '\0') {
      pcVar1 = old_tag->name;
      pFVar6 = TraceFP();
      fprintf((FILE *)pFVar6,"SGML: ***Illegal end tag </%s> found.\n",pcVar1);
    }
  }
  else if (context->element_stack == (HTElement *)0x0) {
    if (WWW_TraceFlag != '\0') {
      pcVar1 = old_tag->name;
      pFVar6 = TraceFP();
      fprintf((FILE *)pFVar6,"SGML: Extra end tag </%s> found and ignored.\n",pcVar1);
    }
  }
  else {
    status = 0;
    e_00 = context->element_stack;
    if (e_00->tag == old_tag) {
      local_50 = e_00->tag;
    }
    else {
      if ((int)e_00->tag - (int)context->dtd->tags < 0x19d0) {
        local_48 = ((int)e_00->tag - (int)context->dtd->tags >> 3) * 8;
      }
      else {
        local_48 = 0x1148;
      }
      local_50 = (HTTag *)((int)&context->dtd->tags->name + local_48);
    }
    if (old_tag != local_50) {
      if (context->element_stack->next == (HTElement *)0x0) {
        if (WWW_TraceFlag == '\0') {
          return;
        }
        pcVar1 = old_tag->name;
        pcVar2 = local_50->name;
        pcVar3 = old_tag->name;
        pFVar6 = TraceFP();
        fprintf((FILE *)pFVar6,"SGML: Found </%s> when expecting </%s>. </%s> ***Ignored.\n",pcVar3,
                pcVar2,pcVar1);
        return;
      }
      if (WWW_TraceFlag != '\0') {
        pcVar1 = local_50->name;
        pcVar2 = local_50->name;
        pcVar3 = old_tag->name;
        pFVar6 = TraceFP();
        fprintf((FILE *)pFVar6,"SGML: Found </%s> when expecting </%s>. </%s> ***assumed.\n",pcVar3,
                pcVar2,pcVar1);
      }
    }
    if ((int)local_50 - (int)context->dtd->tags < 0x19d0) {
      local_44 = ((int)local_50 - (int)context->dtd->tags >> 3) * -0x49249249;
    }
    else {
      local_44 = 0x4f;
    }
    if ((WWW_TraceFlag != '\0') && (((byte)WWW_TraceMask & 1) == 1)) {
      pFVar6 = TraceFP();
      fprintf((FILE *)pFVar6,"tagnum(%p) = %d\n",local_50,local_44);
    }
    if (psrc_view == '\0') {
      status = (*context->actions->end_element)(context->target,local_44,&context->include);
    }
    if (status == 700) {
      if (WWW_TraceFlag != '\0') {
        pcVar1 = local_50->name;
        pFVar6 = TraceFP();
        fprintf((FILE *)pFVar6,"SGML: Restart <%s>\n",pcVar1);
      }
      (*context->actions->start_element)
                (context->target,local_44,(BOOLEAN *)0x0,(char **)0x0,context->current_tag_charset,
                 &context->include);
    }
    else if (status == 0x2bd) {
      if (WWW_TraceFlag != '\0') {
        pcVar1 = local_50->name;
        pFVar6 = TraceFP();
        fprintf((FILE *)pFVar6,"SGML: Continue with other content model for <%s>\n",pcVar1);
      }
      if (local_44 == 0x4f) {
        local_38 = 0x19d0;
      }
      else {
        local_38 = local_44 * 0x38;
      }
      context->element_stack->tag = (HTTag *)((int)&context->dtd->tags->name + local_38);
    }
    else {
      context->element_stack = e_00->next;
      pool_free(e_00);
    }
    if (context->element_stack == (HTElement *)0x0) {
      local_31 = 0;
    }
    else {
      local_31 = (byte)context->element_stack->tag->flags & 0x40;
    }
    context->no_lynx_specialcodes = local_31;
  }
  return;
}



// WARNING: Unknown calling convention

void start_element(HTStream_conflict2 *context)

{
  BOOLEAN *pBVar1;
  char *pcVar2;
  char *pcVar3;
  char *pcVar4;
  bool bVar5;
  BOOLEAN BVar6;
  uint uVar7;
  FILE *pFVar8;
  ushort **ppuVar9;
  int iVar10;
  HTTag *old_tag;
  HTElement *pHVar11;
  bool bVar12;
  char *local_54;
  uint local_4c;
  uint local_48;
  uint local_44;
  uint local_40;
  int local_34;
  HTElement *N;
  int i;
  canclose_t canclose_check;
  HTMLElement e;
  HTTag *new_tag;
  int status;
  BOOLEAN has_attributes;
  BOOLEAN extra_action_taken;
  BOOLEAN direct_container;
  BOOLEAN valid;
  BOOLEAN ok;
  
  new_tag = context->current_tag;
  uVar7 = ((int)new_tag - (int)context->dtd->tags >> 3) * -0x49249249;
  bVar5 = false;
  valid = '\x01';
  direct_container = '\x01';
  bVar12 = false;
  canclose_check = close_valid;
  if (Old_DTD == 0) {
    while ((context->element_stack != (HTElement *)0x0 &&
           (((canclose_check == close_valid ||
             ((canclose_check == close_error && (context->element_stack->tag == new_tag)))) &&
            (valid = element_valid_within(new_tag,context->element_stack->tag,direct_container),
            valid == '\0'))))) {
      canclose_check = can_close(new_tag,context->element_stack->tag);
      if (canclose_check == close_NO) {
        if (WWW_TraceFlag != '\0') {
          pcVar2 = new_tag->name;
          pcVar3 = context->element_stack->tag->name;
          pFVar8 = TraceFP();
          fprintf((FILE *)pFVar8,"SGML: Still open %s \t<- ***invalid start <%s>\n",pcVar3,pcVar2);
        }
      }
      else {
        if (WWW_TraceFlag != '\0') {
          pcVar2 = new_tag->name;
          if (canclose_check == close_valid) {
            local_54 = "supplied,";
          }
          else {
            local_54 = "***forced by";
          }
          pcVar3 = context->element_stack->tag->name;
          pFVar8 = TraceFP();
          fprintf((FILE *)pFVar8,"SGML: End </%s> \t<- %s start <%s>\n",pcVar3,local_54,pcVar2);
        }
        do_close_stacked(context);
        bVar12 = true;
        if (canclose_check == close_error) {
          direct_container = '\0';
        }
      }
    }
    if ((((context->element_stack != (HTElement *)0x0) && (valid == '\0')) &&
        ((context->element_stack->tag->flags & 8U) != 0)) &&
       (valid = element_valid_within(new_tag,context->element_stack->tag,direct_container),
       valid == '\0')) {
      if (WWW_TraceFlag == '\0') {
        return;
      }
      pcVar2 = new_tag->name;
      pcVar3 = context->element_stack->tag->name;
      pFVar8 = TraceFP();
      fprintf((FILE *)pFVar8,"SGML: Still open %s \t<- ***ignoring start <%s>\n",pcVar3,pcVar2);
      return;
    }
    if (((context->element_stack != (HTElement *)0x0) && (!bVar12)) &&
       ((canclose_check == close_NO && ((valid == '\0' && ((new_tag->flags & 4U) != 0)))))) {
      i = 0;
      has_attributes = '\0';
      while ((i < new_tag->number_of_attributes && (has_attributes == '\0'))) {
        pBVar1 = context->present + i;
        i = i + 1;
        has_attributes = *pBVar1;
      }
      if (has_attributes == '\0') {
        if (WWW_TraceFlag != '\0') {
          pcVar2 = new_tag->name;
          pcVar3 = new_tag->name;
          pcVar4 = context->element_stack->tag->name;
          pFVar8 = TraceFP();
          fprintf((FILE *)pFVar8,"SGML: Still open %s, ***converting invalid <%s> to </%s>\n",pcVar4
                  ,pcVar3,pcVar2);
        }
        end_element(context,new_tag);
        return;
      }
    }
    if ((((context->element_stack != (HTElement *)0x0) && (canclose_check == close_error)) &&
        (BVar6 = element_valid_within(new_tag,context->element_stack->tag,direct_container),
        BVar6 == '\0')) && (WWW_TraceFlag != '\0')) {
      pcVar2 = new_tag->name;
      pcVar3 = context->element_stack->tag->name;
      pFVar8 = TraceFP();
      fprintf((FILE *)pFVar8,"SGML: Still open %s \t<- ***invalid start <%s>\n",pcVar3,pcVar2);
    }
  }
  if (context->inSELECT == '\0') {
    ppuVar9 = __ctype_b_loc();
    if (((*ppuVar9)[(byte)*new_tag->name] & 0x200) == 0) {
      local_4c = (uint)(byte)*new_tag->name;
    }
    else {
      local_4c = toupper((uint)(byte)*new_tag->name);
    }
    ppuVar9 = __ctype_b_loc();
    if (((*ppuVar9)[0x53] & 0x200) == 0) {
      local_48 = 0x53;
    }
    else {
      local_48 = toupper(0x53);
    }
    if (local_4c == local_48) {
      iVar10 = strcasecomp(new_tag->name,"SELECT");
      bVar12 = iVar10 == 0;
    }
    else {
      ppuVar9 = __ctype_b_loc();
      if (((*ppuVar9)[(byte)*new_tag->name] & 0x200) == 0) {
        local_44 = (uint)(byte)*new_tag->name;
      }
      else {
        local_44 = toupper((uint)(byte)*new_tag->name);
      }
      ppuVar9 = __ctype_b_loc();
      if (((*ppuVar9)[0x53] & 0x200) == 0) {
        local_40 = 0x53;
      }
      else {
        local_40 = toupper(0x53);
      }
      bVar12 = local_44 == local_40;
    }
    if (bVar12) {
      context->inSELECT = '\x01';
    }
    goto LAB_0811998c;
  }
  iVar10 = strcasecomp(new_tag->name,"OPTION");
  if (iVar10 == 0) goto LAB_0811998c;
  if (uVar7 == 0x3c) {
LAB_081198fc:
    bVar5 = true;
  }
  else {
    if (uVar7 < 0x3d) {
      if (((uVar7 != 0x28) && (uVar7 != 0x2c)) && (uVar7 != 0x15)) goto LAB_08119900;
      goto LAB_081198fc;
    }
    if (uVar7 == 0x5b) goto LAB_081198fc;
    if (uVar7 < 0x5c) {
      if (uVar7 - 0x41 < 2) goto LAB_081198fc;
    }
    else if (uVar7 == 0x69) goto LAB_081198fc;
  }
LAB_08119900:
  if (!bVar5) {
    if (WWW_TraceFlag == '\0') {
      return;
    }
    pcVar2 = new_tag->name;
    pFVar8 = TraceFP();
    fprintf((FILE *)pFVar8,"SGML: ***Ignoring start tag <%s> in SELECT block.\n",pcVar2);
    return;
  }
  if (WWW_TraceFlag != '\0') {
    pcVar2 = new_tag->name;
    pFVar8 = TraceFP();
    fprintf((FILE *)pFVar8,"SGML: ***Faking SELECT end tag before <%s> start tag.\n",pcVar2);
  }
  old_tag = SGMLFindTag(context->dtd,"SELECT");
  end_element(context,old_tag);
LAB_0811998c:
  if (WWW_TraceFlag != '\0') {
    pcVar2 = new_tag->name;
    pFVar8 = TraceFP();
    fprintf((FILE *)pFVar8,"SGML: Start <%s>\n",pcVar2);
  }
  iVar10 = (*context->actions->start_element)
                     (context->target,((int)new_tag - (int)context->dtd->tags >> 3) * -0x49249249,
                      context->present,context->value,context->current_tag_charset,&context->include
                     );
  if (iVar10 == 0x2bd) {
    if ((uint)((int)new_tag + (-0x1148 - (int)context->dtd->tags)) < 0x38) {
      local_34 = 0x19d0;
    }
    else {
      local_34 = ((int)new_tag - (int)context->dtd->tags >> 3) * 8;
    }
    new_tag = (HTTag *)((int)&context->dtd->tags->name + local_34);
  }
  if (new_tag->contents == SGML_EMPTY) {
    if (uVar7 == 0x4b) {
      change_chartrans_handling(context);
    }
  }
  else {
    pHVar11 = pool_alloc();
    if (pHVar11 == (HTElement *)0x0) {
      outofmem("../../../WWW/Library/Implementation/SGML.c","start_element");
    }
    pHVar11->next = context->element_stack;
    pHVar11->tag = new_tag;
    context->element_stack = pHVar11;
    context->no_lynx_specialcodes = (byte)new_tag->flags & 0x40;
  }
  return;
}



// WARNING: Unknown calling convention

HTTag * SGMLFindTag(SGML_dtd *dtd,char *s)

{
  HTTag **ppHVar1;
  int iVar2;
  ushort **ppuVar3;
  HTTag *local_40;
  int local_3c;
  uint local_38;
  uint local_34;
  uint local_30;
  uint local_2c;
  HTTag **res;
  int diff;
  int i;
  int low;
  int high;
  
  ppHVar1 = SGMLFindTag::last + ((byte)*s & 0x3f);
  if (*ppHVar1 != (HTTag *)0x0) {
    if ((*ppHVar1)->name == (char *)0x0) {
      return (HTTag *)0x0;
    }
    iVar2 = strcasecomp((*ppHVar1)->name,s);
    if (iVar2 == 0) {
      return *ppHVar1;
    }
  }
  low = 0;
  iVar2 = dtd->number_of_tags;
  while( true ) {
    high = iVar2;
    if (high <= low) {
      ppuVar3 = __ctype_b_loc();
      if (((*ppuVar3)[(byte)*s] & 0x400) == 0) {
        local_40 = (HTTag *)0x0;
      }
      else {
        local_40 = &HTTag_unrecognized;
      }
      return local_40;
    }
    iVar2 = (high - low) / 2 + low;
    ppuVar3 = __ctype_b_loc();
    if (((*ppuVar3)[(byte)*dtd->tags[iVar2].name] & 0x200) == 0) {
      local_38 = (uint)(byte)*dtd->tags[iVar2].name;
    }
    else {
      local_38 = toupper((uint)(byte)*dtd->tags[iVar2].name);
    }
    ppuVar3 = __ctype_b_loc();
    if (((*ppuVar3)[(byte)*s] & 0x200) == 0) {
      local_34 = (uint)(byte)*s;
    }
    else {
      local_34 = toupper((uint)(byte)*s);
    }
    if (local_38 == local_34) {
      local_3c = strcasecomp(dtd->tags[iVar2].name,s);
    }
    else {
      ppuVar3 = __ctype_b_loc();
      if (((*ppuVar3)[(byte)*dtd->tags[iVar2].name] & 0x200) == 0) {
        local_30 = (uint)(byte)*dtd->tags[iVar2].name;
      }
      else {
        local_30 = toupper((uint)(byte)*dtd->tags[iVar2].name);
      }
      ppuVar3 = __ctype_b_loc();
      if (((*ppuVar3)[(byte)*s] & 0x200) == 0) {
        local_2c = (uint)(byte)*s;
      }
      else {
        local_2c = toupper((uint)(byte)*s);
      }
      local_3c = local_30 - local_2c;
    }
    if (local_3c == 0) break;
    if (local_3c < 0) {
      low = iVar2 + 1;
      iVar2 = high;
    }
  }
  *ppHVar1 = dtd->tags + iVar2;
  return *ppHVar1;
}



// WARNING: Unknown calling convention

void SGML_free(HTStream_conflict2 *context)

{
  HTElement *e;
  HTTag *pHVar1;
  int local_18;
  HTTag *t;
  HTElement *cur;
  int i;
  
  if (context->recover != (char *)0x0) {
    free(context->recover);
    context->recover = (char *)0x0;
  }
  if (context->url != (char *)0x0) {
    free(context->url);
    context->url = (char *)0x0;
  }
  if (context->csi != (char *)0x0) {
    free(context->csi);
    context->csi = (char *)0x0;
  }
  if (context->include != (char *)0x0) {
    free(context->include);
    context->include = (char *)0x0;
  }
  if (context->active_include != (char *)0x0) {
    free(context->active_include);
    context->active_include = (char *)0x0;
  }
  while (context->element_stack != (HTElement *)0x0) {
    e = context->element_stack;
    pHVar1 = e->tag;
    context->element_stack = e->next;
    pool_free(e);
    if (psrc_view == '\0') {
      if ((int)pHVar1 - (int)context->dtd->tags < 0x19d0) {
        local_18 = ((int)pHVar1 - (int)context->dtd->tags >> 3) * -0x49249249;
      }
      else {
        local_18 = 0x4f;
      }
      (*context->actions->end_element)(context->target,local_18,&context->include);
    }
    if (context->include != (char *)0x0) {
      free(context->include);
      context->include = (char *)0x0;
    }
  }
  (*context->actions->_free)(context->target);
  HTChunkFree(context->string);
  for (i = 0; i < 0x24; i = i + 1) {
    if (context->value[i] != (char *)0x0) {
      HTSAFree_extra(context->value[i]);
      context->value[i] = (char *)0x0;
    }
  }
  if (context != (HTStream_conflict2 *)0x0) {
    free(context);
  }
  sgml_in_psrc_was_initialized = '\0';
  return;
}



// WARNING: Unknown calling convention

void SGML_abort(HTStream_conflict2 *context,HTError e)

{
  HTElement *e_00;
  HTElement *cur;
  int i;
  
  (*context->actions->_abort)(context->target,e);
  if (context->recover != (char *)0x0) {
    free(context->recover);
    context->recover = (char *)0x0;
  }
  if (context->include != (char *)0x0) {
    free(context->include);
    context->include = (char *)0x0;
  }
  if (context->active_include != (char *)0x0) {
    free(context->active_include);
    context->active_include = (char *)0x0;
  }
  if (context->url != (char *)0x0) {
    free(context->url);
    context->url = (char *)0x0;
  }
  if (context->csi != (char *)0x0) {
    free(context->csi);
    context->csi = (char *)0x0;
  }
  while (context->element_stack != (HTElement *)0x0) {
    e_00 = context->element_stack;
    context->element_stack = e_00->next;
    pool_free(e_00);
  }
  HTChunkFree(context->string);
  for (i = 0; i < 0x24; i = i + 1) {
    if (context->value[i] != (char *)0x0) {
      HTSAFree_extra(context->value[i]);
      context->value[i] = (char *)0x0;
    }
  }
  if (context != (HTStream_conflict2 *)0x0) {
    free(context);
  }
  sgml_in_psrc_was_initialized = '\0';
  return;
}



// WARNING: Unknown calling convention

void transform_tag(HTStream_conflict2 *context,HTChunk *string)

{
  if ((context->strict_xml == '\0') && (tagname_transform != 1)) {
    if (tagname_transform == 0) {
      LYLowerCase(string->data);
    }
    else {
      LYUpperCase(string->data);
    }
  }
  return;
}



// WARNING: Unknown calling convention

BOOLEAN ignore_when_empty(HTTag *tag)

{
  FILE *__stream;
  char *local_1c;
  undefined *local_18;
  BOOLEAN result;
  
  result = '\0';
  if ((((((LYPreparsedSource == '\0') && (LYxhtml_parsing != '\0')) && (tag->name != (char *)0x0))
       && (((tag->flags & 4U) == 0 && (tag->contents != SGML_EMPTY)))) && (tag->tagclass != 0x100))
     && ((tag->tagclass == 0x40 || ((tag->contains != 0 && (tag->icontains != 0)))))) {
    result = '\x01';
  }
  if (WWW_TraceFlag != '\0') {
    if (tag->name == (char *)0x0) {
      local_1c = "";
    }
    else {
      local_1c = tag->name;
    }
    if (result == '\0') {
      local_18 = &DAT_081830bf;
    }
    else {
      local_18 = &DAT_08182ae5;
    }
    __stream = TraceFP();
    fprintf((FILE *)__stream,"SGML Do%s ignore_when_empty:%s\n",local_18,local_1c);
  }
  return result;
}



// WARNING: Unknown calling convention

void discard_empty(HTStream_conflict2 *context)

{
  FILE *pFVar1;
  char *local_8;
  
  if (WWW_TraceFlag != '\0') {
    if (context->current_tag->name == (char *)0x0) {
      local_8 = "";
    }
    else {
      local_8 = context->current_tag->name;
    }
    pFVar1 = TraceFP();
    fprintf((FILE *)pFVar1,"SGML discarding empty %s\n",local_8);
  }
  if (WWW_TraceFlag != '\0') {
    pFVar1 = TraceFP();
    fflush((FILE *)pFVar1);
  }
  memset(&discard_empty::empty_tag,0,0x38);
  context->current_tag = &discard_empty::empty_tag;
  context->string->size = 0;
  return;
}



BOOLEAN end_if_prettysrc(HTStream_conflict2 *context,HTChunk *string,char end_ch)

{
  BOOLEAN BVar1;
  char end_ch_local;
  BOOLEAN result;
  
  BVar1 = psrc_view;
  if (psrc_view != '\0') {
    if (context->cur_attr_is_name == '\0') {
      if (context->cur_attr_is_href != '\0') {
        HTMLSRC_apply_markup(context,HTL_href,'\x01');
        HTStartAnchor((HTStructured_conflict *)context->target,(char *)0x0,string->data);
      }
    }
    else {
      HTStartAnchor((HTStructured_conflict *)context->target,string->data,(char *)0x0);
      (*context->actions->end_element)(context->target,0,&context->include);
    }
    psrc_convert_string = '\x01';
    (*context->actions->put_string)(context->target,string->data);
    if (context->cur_attr_is_href != '\0') {
      (*context->actions->end_element)(context->target,0,&context->include);
      HTMLSRC_apply_markup(context,HTL_href,'\0');
    }
    if (end_ch != '\0') {
      (*context->actions->put_character)(context->target,end_ch);
    }
    HTMLSRC_apply_markup(context,HTL_attrval,'\0');
  }
  return BVar1;
}



// WARNING: Removing unreachable block (ram,0x0811fdc7)
// WARNING: Removing unreachable block (ram,0x0811fdd2)
// WARNING: Removing unreachable block (ram,0x0811fdfb)
// WARNING: Removing unreachable block (ram,0x0811fe23)
// WARNING: Removing unreachable block (ram,0x0811fe14)
// WARNING: Removing unreachable block (ram,0x0811fe50)
// WARNING: Removing unreachable block (ram,0x0811ff85)
// WARNING: Removing unreachable block (ram,0x08120032)
// WARNING: Removing unreachable block (ram,0x0812003d)
// WARNING: Removing unreachable block (ram,0x0812005e)
// WARNING: Removing unreachable block (ram,0x08120069)
// WARNING: Removing unreachable block (ram,0x0811ffa3)
// WARNING: Removing unreachable block (ram,0x0811ffae)
// WARNING: Removing unreachable block (ram,0x0811ffef)
// WARNING: Removing unreachable block (ram,0x08120007)
// WARNING: Removing unreachable block (ram,0x0811fff8)
// WARNING: Removing unreachable block (ram,0x08120015)
// WARNING: Removing unreachable block (ram,0x08120025)
// WARNING: Removing unreachable block (ram,0x0811fe5f)
// WARNING: Removing unreachable block (ram,0x0811feae)
// WARNING: Removing unreachable block (ram,0x0811feb9)
// WARNING: Removing unreachable block (ram,0x0811feda)
// WARNING: Removing unreachable block (ram,0x0811ff0a)
// WARNING: Removing unreachable block (ram,0x0811ff2b)
// WARNING: Removing unreachable block (ram,0x0811ff3a)
// WARNING: Removing unreachable block (ram,0x0811fe79)
// WARNING: Removing unreachable block (ram,0x0811fe88)
// WARNING: Removing unreachable block (ram,0x081200af)
// WARNING: Removing unreachable block (ram,0x081200d7)
// WARNING: Removing unreachable block (ram,0x081200c8)

void SGML_character(HTStream_conflict2 *context,char c_in)

{
  int iVar1;
  ushort uVar2;
  char cVar3;
  BOOLEAN BVar4;
  int iVar5;
  FILE *pFVar6;
  ushort **ppuVar7;
  uint uVar8;
  uchar *unaff_EBX;
  HTTag *unaff_ESI;
  int in_GS_OFFSET;
  bool bVar9;
  char *local_fc;
  HTTag *local_f4;
  char local_f0;
  HTTag *local_ec;
  HTTag *local_e8;
  HTTag *local_e4;
  bool local_d5;
  char *local_cc;
  wchar_t local_c8;
  HTTag *local_c4;
  char *local_bc;
  sgml_state local_b4;
  HTTag *local_b0;
  sgml_state local_ac;
  sgml_state local_a8;
  sgml_state local_a4;
  char local_9c;
  int local_94;
  HTTag *local_88;
  char *local_7c;
  char c_in_local;
  HTStream_conflict2 *context_local;
  uchar sjis_lo;
  int i_2;
  int branch;
  HTMLElement e;
  HTTag *t_1;
  HTTag *t;
  int i_1;
  int i;
  int psrc_view_backup;
  int testlast;
  UCode_t uck;
  UCode_t clong;
  HTTag *testtag;
  char *EntityName;
  HTChunk *string;
  SGML_dtd *dtd;
  BOOLEAN tag_OK;
  BOOLEAN psrc_tagname_processed;
  uchar sjis_hi;
  char saved_char_in;
  uchar c;
  BOOLEAN chk;
  char temp [8];
  
  c = c_in;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  dtd = context->dtd;
  string = context->string;
  testtag = (HTTag *)0x0;
  uck = 0;
  saved_char_in = '\0';
  sgml_offset = sgml_offset + 1;
  clong = (UCode_t)(byte)c_in;
  if ((context->T).decode_utf8 != '\0') {
    if (c_in < '\0') {
      if ((context->utf_count < '\x01') || ((c_in & 0xc0U) != 0x80)) {
        context->utf_buf_p = context->utf_buf;
        *context->utf_buf_p = c_in;
        context->utf_buf_p = context->utf_buf_p + 1;
        if ((c_in & 0xe0U) == 0xc0) {
          context->utf_count = '\x01';
          context->utf_char = (byte)c_in & 0x1f;
        }
        else if ((c_in & 0xf0U) == 0xe0) {
          context->utf_count = '\x02';
          context->utf_char = (byte)c_in & 0xf;
        }
        else if ((c_in & 0xf8U) == 0xf0) {
          context->utf_count = '\x03';
          context->utf_char = (byte)c_in & 7;
        }
        else if ((c_in & 0xfcU) == 0xf8) {
          context->utf_count = '\x04';
          context->utf_char = (byte)c_in & 3;
        }
        else if ((c_in & 0xfeU) == 0xfc) {
          context->utf_count = '\x05';
          context->utf_char = (byte)c_in & 1;
        }
        else {
          context->utf_count = '\0';
          context->utf_buf_p = context->utf_buf;
          *context->utf_buf_p = '\0';
        }
      }
      else {
        context->utf_char = context->utf_char << 6 | (byte)c_in & 0x3f;
        context->utf_count = context->utf_count + -1;
        *context->utf_buf_p = c_in;
        context->utf_buf_p = context->utf_buf_p + 1;
        if (context->utf_count == '\0') {
          *context->utf_buf_p = '\0';
          clong = context->utf_char;
          if (0xff < clong) goto top1;
          c = (uchar)clong;
          goto top1;
        }
      }
      goto LAB_08120c0d;
    }
    context->utf_count = '\0';
    context->utf_buf_p = context->utf_buf;
    *context->utf_buf_p = '\0';
  }
  if (((context->T).trans_to_uni != '\0') &&
     ((iVar5 = strcmp(LYCharSet_UC[context->inUCLYhndl].MIMEname,"euc-jp"), iVar5 == 0 ||
      (iVar5 = strcmp(LYCharSet_UC[context->inUCLYhndl].MIMEname,"shift_jis"), iVar5 == 0)))) {
    iVar5 = strcmp(LYCharSet_UC[context->inUCLYhndl].MIMEname,"shift_jis");
    if (iVar5 != 0) {
      if (context->utf_count == '\0') {
        if (c < 0xa1) goto top1;
        if (c == 0xff) goto top1;
        context->utf_buf[0] = c;
        context->utf_count = '\x01';
        clong = -0xb;
        goto top1;
      }
      if ((0xa0 < c) && (c != 0xff)) {
        context->utf_buf[1] = c;
        clong = UCTransJPToUni(context->utf_buf,2,context->inUCLYhndl);
      }
      context->utf_count = '\0';
      goto top1;
    }
    if (context->utf_count == '\0') {
      if ((c < 0x81) || (0x9f < c)) {
        if (c < 0xe0) goto top1;
        if (0xef < c) goto top1;
      }
      context->utf_buf[0] = c;
      context->utf_count = '\x01';
      clong = -0xb;
      goto top1;
    }
    if (((0x3f < c) && (c != '\x7f')) && (c < 0xfd)) {
      context->utf_buf[1] = c;
      clong = UCTransJPToUni(context->utf_buf,2,context->inUCLYhndl);
    }
    context->utf_count = '\0';
    goto top1;
  }
  if (((context->T).trans_to_uni != '\0') &&
     ((LYlowest_eightbit[context->inUCLYhndl] <= clong ||
      (((clong < 0x20 && (clong != 0)) && ((context->T).trans_C0_to_uni != '\0')))))) {
    clong = UCTransToUni(c,context->inUCLYhndl);
    if (clong < 1) goto top1;
    saved_char_in = c;
    if (0xff < clong) goto top1;
    c = (uchar)clong;
    goto top1;
  }
  if (((clong < 0x20) && (clong != 0)) && ((context->T).trans_C0_to_uni != '\0')) {
    if (((context->T).trans_from_uni != '\0') &&
       ((clong = UCTransToUni(c,context->inUCLYhndl), 0x1f < clong ||
        (((context->T).transp != '\0' && (clong = UCTransToUni(c,context->inUCLYhndl), 0 < clong))))
       )) {
      saved_char_in = c;
      if (0xff < clong) goto top1;
      c = (uchar)clong;
      goto top1;
    }
    uck = -1;
    if ((context->T).transp != '\0') {
      uck = UCTransCharStr(replace_buf,0x3c,c,context->inUCLYhndl,context->inUCLYhndl,0);
    }
    if (((context->T).transp == '\0') || (uck < 0)) {
      uck = UCTransCharStr(replace_buf,0x3c,c,context->inUCLYhndl,context->outUCLYhndl,1);
    }
    if (uck == 0) {
LAB_08120c0d:
      if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
        return;
      }
                    // WARNING: Subroutine does not return
      __stack_chk_fail();
    }
    if (-1 < uck) {
      c = replace_buf[0];
      if ((replace_buf[0] != '\0') && (replace_buf[1] != '\0')) {
        if (context->state == S_text) {
          (*context->actions->put_string)(context->target,replace_buf);
          goto LAB_08120c0d;
        }
        HTSACat(&context->recover,replace_buf + 1);
      }
    }
  }
  do {
    context->utf_buf[0] = '\0';
    clong = (UCode_t)c;
top1:
    if (((((clong < 0x20) && (c != '\t')) && (c != '\n')) && ((c != '\r' && (HTCJK == NOCJK)))) ||
       ((((c == '\x7f' &&
          (((context->T).transp == '\0' && (clong < LYlowest_eightbit[context->inUCLYhndl])))) &&
         (HTCJK == NOCJK)) ||
        ((((0x7f < clong && (clong < 0xa0)) && ((context->T).transp == '\0')) &&
         ((clong < LYlowest_eightbit[context->inUCLYhndl] && (HTCJK == NOCJK))))))))
    goto after_switch;
    if (((((HTCJK == JAPANESE) && (context->state == S_in_kanji)) &&
         ((((c < 0x40 || (c == '\x7f')) || (0xfc < c)) ||
          (((context->kanji_buf < 0x81 || (0x9f < context->kanji_buf)) &&
           ((context->kanji_buf < 0xe0 || (0xef < context->kanji_buf)))))))) &&
        (((((context->kanji_buf < 0xa1 || (context->kanji_buf == 0xff)) || (c < 0xa1)) ||
          (c == 0xff)) && (((context->kanji_buf != 0x8e || (c < 0xa1)) || (0xdf < c)))))) &&
       ((context->T).decode_utf8 == '\0')) {
      if ((context->kanji_buf < 0xa1) || (0xdf < context->kanji_buf)) {
        (*context->actions->put_character)(context->target,context->kanji_buf);
      }
      else {
        JISx0201TO0208_SJIS((uchar)&sjis_hi,unaff_EBX,(uchar *)unaff_ESI);
        (*context->actions->put_character)(context->target,sjis_hi);
        (*context->actions->put_character)(context->target,sjis_lo);
      }
      context->state = S_text;
    }
    local_b0 = unaff_ESI;
    if ((WWW_TraceFlag != '\0') && (((byte)WWW_TraceMask & 1) == 1)) {
      uVar8 = (uint)c;
      if (string->data == (char *)0x0) {
        local_fc = "";
      }
      else {
        local_fc = string->data;
      }
      unaff_EBX = (uchar *)string->size;
      local_b0 = (HTTag *)state_name(context->state);
      pFVar6 = TraceFP();
      fprintf((FILE *)pFVar6,"SGML before %s|%.*s|%c|\n",local_b0,unaff_EBX,local_fc,uVar8);
    }
    if (S_value < context->state) goto LAB_0812082d;
    cVar3 = (char)clong;
    unaff_ESI = local_b0;
    switch(context->state) {
    case S_text:
      goto switchD_0811aee3_caseD_0;
    case S_attr:
      if (((c < 0x21) || (c == '>')) || (c == '=')) {
        if (((c == '>') && (string->size == 1)) && (*string->data == '/')) {
          if ((context->extended_html != '\0') &&
             (BVar4 = ignore_when_empty(context->current_tag), BVar4 != '\0')) {
            discard_empty(context);
          }
        }
        else {
          HTChunkTerminate(string);
          handle_attribute_name(context,string->data);
        }
        if (psrc_view == '\0') {
          string->size = 0;
          if (c == '>') {
            if (context->current_tag->name != (char *)0x0) {
              start_element(context);
            }
            context->state = S_text;
          }
          else {
LAB_0811edbe:
            if (c == '=') {
              local_a4 = S_equals;
            }
            else {
              local_a4 = S_attr_gap;
            }
            context->state = local_a4;
          }
        }
        else {
          (*context->actions->put_character)(context->target,' ');
          if (context->current_attribute_number == -1) {
            HTMLSRC_apply_markup(context,HTL_badattr,'\x01');
          }
          else {
            HTMLSRC_apply_markup(context,HTL_attrib,'\x01');
          }
          if (attrname_transform != 1) {
            if (attrname_transform == 0) {
              LYLowerCase(string->data);
            }
            else {
              LYUpperCase(string->data);
            }
          }
          (*context->actions->put_string)(context->target,string->data);
          if ((c == '=') || (c < 0x21)) {
            (*context->actions->put_character)(context->target,c);
          }
          if (((c == '=') || (c == '>')) || (c < 0x21)) {
            if (context->current_attribute_number == -1) {
              HTMLSRC_apply_markup(context,HTL_badattr,'\0');
            }
            else {
              HTMLSRC_apply_markup(context,HTL_attrib,'\0');
            }
          }
          if (c != '>') {
            string->size = 0;
            goto LAB_0811edbe;
          }
          HTMLSRC_apply_markup(context,HTL_abracket,'\x01');
          (*context->actions->put_character)(context->target,'>');
          HTMLSRC_apply_markup(context,HTL_abracket,'\0');
          context->state = S_text;
        }
      }
      else {
        HTChunkPutc(string,c);
      }
      break;
    case S_attr_gap:
      if (c < 0x21) {
        (*context->actions->put_character)(context->target,c);
      }
      else if (c == '>') {
        if (psrc_view == '\0') {
          if (context->current_tag->name != (char *)0x0) {
            start_element(context);
          }
        }
        else {
          if (context->current_attribute_number == -1) {
            HTMLSRC_apply_markup(context,HTL_badattr,'\0');
          }
          else {
            HTMLSRC_apply_markup(context,HTL_attrib,'\0');
          }
          HTMLSRC_apply_markup(context,HTL_abracket,'\x01');
          (*context->actions->put_character)(context->target,'>');
          HTMLSRC_apply_markup(context,HTL_abracket,'\0');
        }
        context->state = S_text;
      }
      else if (c == '=') {
        if (psrc_view != '\0') {
          (*context->actions->put_character)(context->target,'=');
          if (context->current_attribute_number == -1) {
            HTMLSRC_apply_markup(context,HTL_badattr,'\0');
          }
          else {
            HTMLSRC_apply_markup(context,HTL_attrib,'\0');
          }
        }
        context->state = S_equals;
      }
      else {
        HTChunkPutc(string,c);
        context->state = S_attr;
      }
      break;
    case S_comment:
      if (historical_comments == '\0') {
        if ((context->first_dash == '\0') && (c == '-')) {
          HTChunkPutc(string,'-');
          context->first_dash = '\x01';
        }
        else if ((context->first_dash == '\0') || (c != '-')) {
          if ((context->end_comment == '\0') || (c != '>')) {
            context->first_dash = '\0';
            if ((context->end_comment != '\0') &&
               (ppuVar7 = __ctype_b_loc(), ((*ppuVar7)[c] & 0x2000) == 0)) {
              context->end_comment = '\0';
            }
            goto S_comment_put_c;
          }
          HTChunkTerminate(string);
          if (psrc_view == '\0') {
            handle_comment(context);
          }
          else {
            HTMLSRC_apply_markup(context,HTL_comm,'\x01');
            (*context->actions->put_character)(context->target,'<');
            psrc_convert_string = '\x01';
            (*context->actions->put_string)(context->target,string->data);
            (*context->actions->put_character)(context->target,'>');
            HTMLSRC_apply_markup(context,HTL_comm,'\0');
          }
          string->size = 0;
          context->end_comment = '\0';
          context->first_dash = '\0';
          context->state = S_text;
        }
        else {
          HTChunkPutc(string,'-');
          context->first_dash = '\0';
          if (context->end_comment == '\0') {
            context->end_comment = '\x01';
          }
          else if (minimal_comments == '\0') {
            context->end_comment = '\0';
          }
        }
      }
      else if (c == '>') {
        HTChunkTerminate(string);
        if (psrc_view == '\0') {
          handle_comment(context);
        }
        else {
          HTMLSRC_apply_markup(context,HTL_comm,'\x01');
          (*context->actions->put_character)(context->target,'<');
          psrc_convert_string = '\x01';
          (*context->actions->put_string)(context->target,string->data);
          (*context->actions->put_character)(context->target,'>');
          HTMLSRC_apply_markup(context,HTL_comm,'\0');
        }
        string->size = 0;
        context->end_comment = '\0';
        context->first_dash = '\0';
        context->state = S_text;
      }
      else {
S_comment_put_c:
        if (((context->T).decode_utf8 == '\0') || (context->utf_buf[0] == '\0')) {
          if ((HTCJK == NOCJK) &&
             (((context->T).output_utf8 != '\0' || ((context->T).trans_from_uni != '\0')))) {
            if ((((clong == 0xfffd) && (saved_char_in != '\0')) && (HTPassEightBitRaw != '\0')) &&
               (LYlowest_eightbit[context->outUCLYhndl] <= (int)(uint)(byte)saved_char_in)) {
              if ((CONCAT11(0xf0,saved_char_in) < 0x80) && (string->size < string->allocated)) {
                iVar5 = string->size;
                string->data[iVar5] = saved_char_in;
                string->size = iVar5 + 1;
              }
              else {
                HTChunkPutUtf8Char(string,(uint)CONCAT11(0xf0,saved_char_in));
              }
            }
            else if ((clong < 0x80) && (string->size < string->allocated)) {
              iVar5 = string->size;
              string->data[iVar5] = (char)clong;
              string->size = iVar5 + 1;
            }
            else {
              HTChunkPutUtf8Char(string,clong);
            }
          }
          else if ((saved_char_in == '\0') || ((context->T).use_raw_char_in == '\0')) {
            HTChunkPutc(string,c);
          }
          else {
            HTChunkPutc(string,saved_char_in);
          }
        }
        else {
          HTChunkPuts(string,context->utf_buf);
          context->utf_buf_p = context->utf_buf;
          *context->utf_buf_p = '\0';
        }
      }
      break;
    case S_cro:
      if (clong < 0x7f) {
        ppuVar7 = __ctype_b_loc();
        if (((*ppuVar7)[c] & 0x100) == 0) {
          if (c != 'x') goto LAB_0811c347;
        }
        else {
          iVar5 = tolower((uint)c);
          if (iVar5 != 0x78) goto LAB_0811c347;
        }
        context->isHex = '\x01';
        context->state = S_incro;
      }
      else {
LAB_0811c347:
        if ((clong < 0x7f) && (ppuVar7 = __ctype_b_loc(), ((*ppuVar7)[c] & 0x800) != 0)) {
          HTChunkPutc(string,c);
          context->isHex = '\0';
          context->state = S_incro;
        }
        else if (string->size == 0) {
          if (psrc_view != '\0') {
            HTMLSRC_apply_markup(context,HTL_badseq,'\x01');
          }
          (*context->actions->put_character)(context->target,'&');
          (*context->actions->put_character)(context->target,'#');
          if (psrc_view != '\0') {
            HTMLSRC_apply_markup(context,HTL_badseq,'\0');
          }
          context->state = S_text;
          goto top1;
        }
      }
      break;
    case S_doctype:
      if (context->doctype_bracket == '\0') {
        if ((c == '[') && ((byte)string->data[string->size + -1] < 0x21)) {
          HTChunkPutc(string,'[');
          context->doctype_bracket = '\x01';
        }
        else if (c == '>') {
          HTChunkTerminate(string);
          if (psrc_view == '\0') {
            handle_doctype(context);
          }
          else {
            HTMLSRC_apply_markup(context,HTL_sgmlspecial,'\x01');
            (*context->actions->put_character)(context->target,'<');
            (*context->actions->put_string)(context->target,string->data);
            (*context->actions->put_character)(context->target,'>');
            HTMLSRC_apply_markup(context,HTL_sgmlspecial,'\0');
          }
          string->size = 0;
          context->state = S_text;
        }
        else {
          HTChunkPutc(string,c);
        }
      }
      else {
        HTChunkPutc(string,c);
        if (c == ']') {
          context->doctype_bracket = '\0';
        }
      }
      break;
    case S_dollar:
      if (((c == '@') || (c == 'B')) || (c == 'A')) {
        context->state = S_nonascii_text;
      }
      else if (c == '(') {
        context->state = S_dollar_paren;
      }
      (*context->actions->put_character)(context->target,c);
      break;
    case S_dollar_dq:
      if (((c == '@') || (c == 'B')) || (c == 'A')) {
        context->state = S_nonascii_text_dq;
      }
      else if (c == '(') {
        context->state = S_dollar_paren_dq;
      }
      HTChunkPutc(string,c);
      break;
    case S_dollar_paren:
      if (c == 'C') {
        context->state = S_nonascii_text;
      }
      else {
        context->state = S_text;
      }
      (*context->actions->put_character)(context->target,c);
      break;
    case S_dollar_paren_dq:
      if (c == 'C') {
        context->state = S_nonascii_text_dq;
      }
      else {
        context->state = S_dquoted;
      }
      HTChunkPutc(string,c);
      break;
    case S_dollar_paren_sq:
      if (c == 'C') {
        context->state = S_nonascii_text_sq;
      }
      else {
        context->state = S_squoted;
      }
      HTChunkPutc(string,c);
      break;
    case S_dollar_sq:
      if (((c == '@') || (c == 'B')) || (c == 'A')) {
        context->state = S_nonascii_text_sq;
      }
      else if (c == '(') {
        context->state = S_dollar_paren_sq;
      }
      HTChunkPutc(string,c);
      break;
    case S_dquoted:
      if ((c == '\"') || ((soft_dquotes != '\0' && (c == '>')))) {
        HTChunkTerminate(string);
        BVar4 = end_if_prettysrc(context,string,c);
        if (BVar4 == '\0') {
          handle_attribute_value(context,string->data);
        }
        string->size = 0;
        context->state = S_tag_gap;
        if (c == '>') goto top1;
      }
      else if (c == '\x1b') {
        context->state = S_esc_dq;
        HTChunkPutc(string,'\x1b');
      }
      else if (((context->T).decode_utf8 == '\0') || (context->utf_buf[0] == '\0')) {
        if ((HTCJK == NOCJK) &&
           (((context->T).output_utf8 != '\0' || ((context->T).trans_from_uni != '\0')))) {
          if ((((clong == 0xfffd) && (saved_char_in != '\0')) && (HTPassEightBitRaw != '\0')) &&
             (LYlowest_eightbit[context->outUCLYhndl] <= (int)(uint)(byte)saved_char_in)) {
            if ((CONCAT11(0xf0,saved_char_in) < 0x80) && (string->size < string->allocated)) {
              iVar5 = string->size;
              string->data[iVar5] = saved_char_in;
              string->size = iVar5 + 1;
            }
            else {
              HTChunkPutUtf8Char(string,(uint)CONCAT11(0xf0,saved_char_in));
            }
          }
          else if ((clong < 0x80) && (string->size < string->allocated)) {
            iVar5 = string->size;
            string->data[iVar5] = cVar3;
            string->size = iVar5 + 1;
          }
          else {
            HTChunkPutUtf8Char(string,clong);
          }
        }
        else if ((saved_char_in == '\0') || ((context->T).use_raw_char_in == '\0')) {
          HTChunkPutc(string,c);
        }
        else {
          HTChunkPutc(string,saved_char_in);
        }
      }
      else {
        HTChunkPuts(string,context->utf_buf);
        context->utf_buf_p = context->utf_buf;
        *context->utf_buf_p = '\0';
      }
      break;
    case S_end:
      if (clong < 0x7f) {
        if (string->size == 0) {
          ppuVar7 = __ctype_b_loc();
          if (((*ppuVar7)[c] & 0x400) == 0) goto LAB_0811f9da;
        }
        else {
          ppuVar7 = __ctype_b_loc();
          if ((((((*ppuVar7)[c] & 8) == 0) && (c != '_')) && (c != '-')) &&
             ((c != '.' && (c != ':')))) {
            bVar9 = false;
          }
          else {
            bVar9 = true;
          }
          if (!bVar9) goto LAB_0811f9da;
        }
        HTChunkPutc(string,c);
      }
      else {
LAB_0811f9da:
        t_1 = (HTTag *)0x0;
        psrc_tagname_processed = '\0';
        HTChunkTerminate(string);
        if (*string->data == '\0') {
          if (context->element_stack != (HTElement *)0x0) {
            t_1 = context->element_stack->tag;
          }
        }
        else {
          t_1 = SGMLFindTag(dtd,string->data);
        }
        if ((t_1 == (HTTag *)0x0) || (context->unknown_tag == t_1)) {
          if (WWW_TraceFlag != '\0') {
            unaff_EBX = (uchar *)string->data;
            pFVar6 = TraceFP();
            fprintf((FILE *)pFVar6,"Unknown end tag </%s>\n",unaff_EBX);
          }
          if (psrc_view != '\0') {
            HTMLSRC_apply_markup(context,HTL_abracket,'\x01');
            (*context->actions->put_string)(context->target,"</");
            HTMLSRC_apply_markup(context,HTL_abracket,'\0');
            HTMLSRC_apply_markup(context,HTL_badtag,'\x01');
            transform_tag(context,string);
            (*context->actions->put_string)(context->target,string->data);
            if (c == '>') {
              HTMLSRC_apply_markup(context,HTL_badtag,'\0');
              HTMLSRC_apply_markup(context,HTL_abracket,'\x01');
              (*context->actions->put_character)(context->target,'>');
              HTMLSRC_apply_markup(context,HTL_abracket,'\0');
            }
            else {
              (*context->actions->put_character)(context->target,c);
            }
            psrc_tagname_processed = '\x01';
          }
        }
        else if (psrc_view == '\0') {
          if ((c == '>') || (c < 0x21)) {
            local_9c = '\x01';
          }
          else {
            local_9c = '\0';
          }
          tag_OK = local_9c;
          iVar5 = (int)t_1 - (int)context->dtd->tags >> 3;
          e = iVar5 * -0x49249249;
          branch = 2;
          context->current_tag = t_1;
          local_b0 = (HTTag *)((int)t_1 - (int)context->dtd->tags);
          if ((local_b0 + -0x4f < (HTTag *)0x38) && (context->element_stack != (HTElement *)0x0)) {
            if ((uint)((int)t_1 + (-0x1148 - (int)context->dtd->tags)) < 0x38) {
              local_94 = 0x19d0;
            }
            else {
              local_b0 = (HTTag *)((int)t_1 - (int)context->dtd->tags);
              local_94 = ((int)local_b0 >> 3) * 8;
            }
            if ((HTTag *)((int)&context->dtd->tags->name + local_94) == context->element_stack->tag)
            {
              local_b0 = (HTTag *)((int)context->element_stack->tag - (int)context->dtd->tags);
              if ((int)local_b0 < 0x19d0) {
                local_b0 = (HTTag *)(((int)context->element_stack->tag - (int)context->dtd->tags >>
                                     3) * 8);
                local_88 = local_b0;
              }
              else {
                local_88 = (HTTag *)0x1148;
              }
              context->element_stack->tag =
                   (HTTag *)((int)&local_88->name + (int)context->dtd->tags);
            }
          }
          if (((local_9c != '\0') && (Old_DTD != 0)) && (e < HTML_UL)) {
                    // WARNING: Could not recover jumptable at 0x0811fd86. Too many branches
                    // WARNING: Treating indirect jump as call
            (*(code *)(&PTR_LAB_08183740)[iVar5 * -0x9249249])();
            return;
          }
          if (Old_DTD == 0) {
            end_element(context,context->current_tag);
          }
          else {
            end_element(context,context->current_tag);
          }
        }
        if ((psrc_view != '\0') && (psrc_tagname_processed == '\0')) {
          HTMLSRC_apply_markup(context,HTL_abracket,'\x01');
          (*context->actions->put_string)(context->target,"</");
          HTMLSRC_apply_markup(context,HTL_abracket,'\0');
          HTMLSRC_apply_markup(context,HTL_tag,'\x01');
          if (tagname_transform != 1) {
            if (tagname_transform == 0) {
              LYLowerCase(string->data);
            }
            else {
              LYUpperCase(string->data);
            }
          }
          (*context->actions->put_string)(context->target,string->data);
          HTMLSRC_apply_markup(context,HTL_tag,'\0');
          if (c == '>') {
            HTMLSRC_apply_markup(context,HTL_abracket,'\x01');
            (*context->actions->put_character)(context->target,'>');
            HTMLSRC_apply_markup(context,HTL_abracket,'\0');
          }
          else {
            HTMLSRC_apply_markup(context,HTL_badtag,'\x01');
            (*context->actions->put_character)(context->target,c);
          }
        }
        string->size = 0;
        context->current_attribute_number = -1;
        if (c == '>') {
          context->current_tag = (HTTag *)0x0;
          context->state = S_text;
        }
        else {
          if ((0x20 < c) && (WWW_TraceFlag != '\0')) {
            unaff_EBX = (uchar *)(uint)c;
            local_b0 = (HTTag *)string->data;
            pFVar6 = TraceFP();
            fprintf((FILE *)pFVar6,"SGML: `</%s%c\' found!\n",local_b0,unaff_EBX);
          }
          context->state = S_junk_tag;
        }
      }
      break;
    case S_entity:
switchD_0811aee3_caseD_e:
      if (clong < 0x7f) {
        if (string->size == 0) {
          ppuVar7 = __ctype_b_loc();
          uVar2 = (*ppuVar7)[c] & 0x400;
        }
        else {
          ppuVar7 = __ctype_b_loc();
          uVar2 = (*ppuVar7)[c] & 8;
        }
        if (uVar2 != 0) {
          HTChunkPutc(string,c);
          break;
        }
      }
      if (string->size == 0) {
        if (psrc_view != '\0') {
          HTMLSRC_apply_markup(context,HTL_badseq,'\x01');
        }
        (*context->actions->put_character)(context->target,'&');
        if (psrc_view != '\0') {
          HTMLSRC_apply_markup(context,HTL_badseq,'\0');
        }
        context->state = S_text;
        goto top1;
      }
      HTChunkTerminate(string);
      entity_string = string->data;
      iVar5 = strcmp(string->data,"zwnj");
      if ((iVar5 != 0) ||
         ((context->element_stack != (HTElement *)0x0 &&
          ((context->element_stack->tag == (HTTag *)0x0 ||
           (context->element_stack->tag->contents != SGML_MIXED)))))) {
        handle_entity(context,'\0');
        string->size = 0;
        context->state = S_text;
        if ((psrc_view != '\0') && ((FoundEntity != '\0' && (c == ';')))) {
          HTMLSRC_apply_markup(context,HTL_entity,'\x01');
          (*context->actions->put_character)(context->target,c);
          HTMLSRC_apply_markup(context,HTL_entity,'\0');
        }
        if (FoundEntity != '\0') goto joined_r0x0811cfcc;
        goto top1;
      }
      if (WWW_TraceFlag != '\0') {
        pFVar6 = TraceFP();
        fprintf((FILE *)pFVar6,"SGML_character: Handling \'zwnj\' entity as \'WBR\' element.\n");
      }
      if (c == ';') {
        memcpy(temp,"<WBR>",6);
      }
      else {
        sprintf(temp,"<WBR>%c",(uint)c);
      }
      if (context->recover == (char *)0x0) {
        HTSACopy(&context->recover,temp);
        context->recover_index = 0;
      }
      else {
        HTSACat(&context->recover,temp);
      }
      string->size = 0;
      context->state = S_text;
      break;
    case S_equals:
      if (c < 0x21) {
        (*context->actions->put_character)(context->target,c);
      }
      else if (c == '>') {
        if (WWW_TraceFlag != '\0') {
          pFVar6 = TraceFP();
          fprintf((FILE *)pFVar6,"SGML: found = but no value\n");
        }
        if (psrc_view == '\0') {
          if (context->current_tag->name != (char *)0x0) {
            start_element(context);
          }
        }
        else {
          HTMLSRC_apply_markup(context,HTL_abracket,'\x01');
          (*context->actions->put_character)(context->target,'>');
          HTMLSRC_apply_markup(context,HTL_abracket,'\0');
        }
        context->state = S_text;
      }
      else if (c == '\'') {
        if (psrc_view != '\0') {
          HTMLSRC_apply_markup(context,HTL_attrval,'\x01');
          (*context->actions->put_character)(context->target,c);
        }
        context->state = S_squoted;
      }
      else {
        if (c != '\"') {
          if (psrc_view != '\0') {
            HTMLSRC_apply_markup(context,HTL_attrval,'\x01');
          }
          context->state = S_value;
          goto switchD_0811aee3_caseD_2a;
        }
        if (psrc_view != '\0') {
          HTMLSRC_apply_markup(context,HTL_attrval,'\x01');
          (*context->actions->put_character)(context->target,c);
        }
        context->state = S_dquoted;
      }
      break;
    case S_ero:
      if (c != '#') {
        context->state = S_entity;
        goto switchD_0811aee3_caseD_e;
      }
      context->state = S_cro;
      break;
    case S_esc:
      if (c == '$') {
        context->state = S_dollar;
      }
      else if (c == '(') {
        context->state = S_paren;
      }
      else {
        context->state = S_text;
      }
      (*context->actions->put_character)(context->target,c);
      break;
    case S_esc_dq:
      if (c == '$') {
        context->state = S_dollar_dq;
      }
      else if (c == '(') {
        context->state = S_paren_dq;
      }
      else {
        context->state = S_dquoted;
      }
      HTChunkPutc(string,c);
      break;
    case S_esc_sq:
      if (c == '$') {
        context->state = S_dollar_sq;
      }
      else if (c == '(') {
        context->state = S_paren_sq;
      }
      else {
        context->state = S_squoted;
      }
      HTChunkPutc(string,c);
      break;
    case S_exclamation:
      if ((context->lead_exclamation == '\0') || (c != '-')) {
        if ((context->lead_exclamation == '\0') || (c != '[')) {
          if ((context->first_dash == '\0') || (c != '-')) {
            context->lead_exclamation = '\0';
            context->first_dash = '\0';
            if (c == '>') {
              HTChunkTerminate(string);
              if (psrc_view == '\0') {
                handle_identifier(context);
              }
              else {
                HTMLSRC_apply_markup(context,HTL_sgmlspecial,'\x01');
                (*context->actions->put_character)(context->target,'<');
                (*context->actions->put_string)(context->target,string->data);
                (*context->actions->put_character)(context->target,'>');
                HTMLSRC_apply_markup(context,HTL_sgmlspecial,'\0');
              }
              string->size = 0;
              context->state = S_text;
            }
            else if (c < 0x21) {
              if ((string->size == 8) &&
                 (iVar5 = strncasecomp(string->data,"!DOCTYPE",8), iVar5 == 0)) {
                HTChunkPutc(string,c);
                context->doctype_bracket = '\0';
                context->state = S_doctype;
              }
              else if ((string->size == 7) &&
                      (iVar5 = strncasecomp(string->data,"!ENTITY",7), iVar5 == 0)) {
                HTChunkPutc(string,c);
                context->first_dash = '\0';
                context->end_comment = '\x01';
                context->state = S_sgmlent;
              }
              else if ((string->size == 8) &&
                      (iVar5 = strncasecomp(string->data,"!ELEMENT",8), iVar5 == 0)) {
                HTChunkPutc(string,c);
                context->first_dash = '\0';
                context->end_comment = '\x01';
                context->state = S_sgmlele;
              }
              else {
                if ((string->size != 8) ||
                   (iVar5 = strncasecomp(string->data,"!ATTLIST",8), iVar5 != 0)) goto LAB_0811ddb0;
                HTChunkPutc(string,c);
                context->first_dash = '\0';
                context->end_comment = '\x01';
                context->state = S_sgmlatt;
              }
            }
            else {
LAB_0811ddb0:
              HTChunkPutc(string,c);
            }
          }
          else {
            context->lead_exclamation = '\0';
            context->first_dash = '\0';
            context->end_comment = '\0';
            HTChunkPutc(string,'-');
            context->state = S_comment;
          }
        }
        else {
          context->lead_exclamation = '\0';
          context->first_bracket = '\x01';
          context->second_bracket = '\0';
          HTChunkPutc(string,'[');
          context->state = S_marked;
        }
      }
      else {
        context->lead_exclamation = '\0';
        context->first_dash = '\x01';
        HTChunkPutc(string,'-');
      }
      break;
    case S_in_kanji:
      context->state = S_text;
      (*context->actions->put_character)(context->target,context->kanji_buf);
      (*context->actions->put_character)(context->target,c);
      break;
    case S_incro:
      if (clong < 0x7f) {
        if (context->isHex == '\0') {
          ppuVar7 = __ctype_b_loc();
          uVar2 = (*ppuVar7)[c] & 0x800;
        }
        else {
          ppuVar7 = __ctype_b_loc();
          uVar2 = (*ppuVar7)[c] & 0x1000;
        }
        if (uVar2 != 0) {
          HTChunkPutc(string,c);
          break;
        }
      }
      if (string->size == 0) {
        if (psrc_view != '\0') {
          HTMLSRC_apply_markup(context,HTL_badseq,'\x01');
        }
        (*context->actions->put_string)(context->target,"&#x");
        if (psrc_view != '\0') {
          HTMLSRC_apply_markup(context,HTL_badseq,'\0');
        }
        context->isHex = '\0';
        context->state = S_text;
        goto top1;
      }
      HTChunkTerminate(string);
      entity_string = string->data;
      if (context->isHex == '\0') {
        iVar5 = sscanf(string->data,"%lu",&sjis_lo);
      }
      else {
        iVar5 = sscanf(string->data,"%lx",&sjis_lo);
      }
      local_d5 = iVar5 != 1;
      if (local_d5) {
        string->size = string->size + -1;
        HTChunkPutc(string,c);
        HTChunkTerminate(string);
        if (psrc_view != '\0') {
          HTMLSRC_apply_markup(context,HTL_badseq,'\x01');
        }
        if (context->isHex == '\0') {
          (*context->actions->put_string)(context->target,"&#");
        }
        else {
          (*context->actions->put_string)(context->target,"&#x");
          context->isHex = '\0';
        }
        if (psrc_view != '\0') {
          HTMLSRC_apply_markup(context,HTL_badseq,'\0');
        }
        if (context->recover == (char *)0x0) {
          HTSACopy(&context->recover,string->data);
          context->recover_index = 0;
        }
        else {
          HTSACat(&context->recover,string->data);
        }
        string->size = 0;
        context->isHex = '\0';
        context->state = S_text;
        break;
      }
      if ((_sjis_lo == (HTTag *)0x1) || (((HTTag *)0x7f < _sjis_lo && (_sjis_lo < (HTTag *)0x9c))))
      {
        local_b0 = _sjis_lo;
        switch(_sjis_lo) {
        case (HTTag *)0x1:
          _sjis_lo = (HTTag *)0x263a;
          break;
        case (HTTag *)0x80:
          _sjis_lo = (HTTag *)0x20ac;
          break;
        case (HTTag *)0x82:
          _sjis_lo = (HTTag *)0x201a;
          break;
        case (HTTag *)0x84:
          _sjis_lo = (HTTag *)0x201e;
          break;
        case (HTTag *)0x85:
          _sjis_lo = (HTTag *)0x2026;
          break;
        case (HTTag *)0x86:
          _sjis_lo = (HTTag *)0x2020;
          break;
        case (HTTag *)0x87:
          _sjis_lo = (HTTag *)0x2021;
          break;
        case (HTTag *)0x89:
          _sjis_lo = (HTTag *)0x2030;
          break;
        case (HTTag *)0x8b:
          _sjis_lo = (HTTag *)0x2039;
          break;
        case (HTTag *)0x91:
          _sjis_lo = (HTTag *)0x2018;
          break;
        case (HTTag *)0x92:
          _sjis_lo = (HTTag *)0x2019;
          break;
        case (HTTag *)0x93:
          _sjis_lo = (HTTag *)0x201c;
          break;
        case (HTTag *)0x94:
          _sjis_lo = (HTTag *)0x201d;
          break;
        case (HTTag *)0x95:
          _sjis_lo = (HTTag *)0x2022;
          break;
        case (HTTag *)0x96:
          _sjis_lo = (HTTag *)0x2013;
          break;
        case (HTTag *)0x97:
          _sjis_lo = (HTTag *)0x2014;
          break;
        case (HTTag *)0x98:
          _sjis_lo = (HTTag *)0x2dc;
          break;
        case (HTTag *)0x99:
          _sjis_lo = (HTTag *)0x2122;
          break;
        case (HTTag *)0x9b:
          _sjis_lo = (HTTag *)0x203a;
        }
      }
      if ((_sjis_lo == (HTTag *)0x200c) &&
         ((context->element_stack == (HTElement *)0x0 ||
          ((context->element_stack->tag != (HTTag *)0x0 &&
           (context->element_stack->tag->contents == SGML_MIXED)))))) {
        if (WWW_TraceFlag != '\0') {
          pFVar6 = TraceFP();
          fprintf((FILE *)pFVar6,
                  "SGML_character: Handling \'8204\' (zwnj) reference as \'WBR\' element.\n");
        }
        if (c == ';') {
          memcpy(temp,"<WBR>",6);
        }
        else {
          sprintf(temp,"<WBR>%c",(uint)c);
        }
        if (context->recover == (char *)0x0) {
          HTSACopy(&context->recover,temp);
          context->recover_index = 0;
        }
        else {
          HTSACat(&context->recover,temp);
        }
        string->size = 0;
        context->isHex = '\0';
        context->state = S_text;
        break;
      }
      BVar4 = put_special_unicodes(context,(UCode_t)_sjis_lo);
      if (BVar4 == '\0') {
        uck = UCTransUniChar((long)_sjis_lo,context->outUCLYhndl);
        if (((uck < 0x20) || (0xff < uck)) ||
           ((0x7e < uck && (uck < LYlowest_eightbit[context->outUCLYhndl])))) {
          if ((uck == -4) ||
             ((((context->T).repl_translated_C0 != '\0' && (0 < uck)) && (uck < 0x20)))) {
            uVar8 = UCTransUniCharStr(replace_buf,0x3c,(long)_sjis_lo,context->outUCLYhndl,0);
            uck = -((int)~uVar8 >> 0x1f);
            if (uck != 0) {
              if (psrc_view == '\0') {
                (*context->actions->put_string)(context->target,replace_buf);
              }
              else {
                put_pretty_number(context);
              }
              goto LAB_0811cfab;
            }
          }
          if (((context->T).output_utf8 == '\0') ||
             (BVar4 = UCPutUtf8_charstring
                                ((HTStream *)context->target,
                                 (putc_func_t *)context->actions->put_character,(long)_sjis_lo),
             BVar4 == '\0')) {
            if ((_sjis_lo == (HTTag *)0x200d) ||
               ((_sjis_lo == (HTTag *)0x200e || (_sjis_lo == (HTTag *)0x200f)))) {
              if (WWW_TraceFlag != '\0') {
                string->size = string->size + -1;
                local_c8 = string->size;
                if (L'?' < local_c8) {
                  local_c8 = L'?';
                }
                LYstrncpy(replace_buf,string->data,local_c8);
                if (context->isHex == '\0') {
                  local_c4 = (HTTag *)&DAT_08182b6d;
                }
                else {
                  local_c4 = (HTTag *)&DAT_08182b69;
                }
                pFVar6 = TraceFP();
                fprintf((FILE *)pFVar6,"SGML_character: Ignoring \'%s%s\'.\n",local_c4,replace_buf);
                local_b0 = local_c4;
              }
              if (psrc_view != '\0') {
                HTMLSRC_apply_markup(context,HTL_badseq,'\x01');
                if (context->isHex == '\0') {
                  local_bc = "&#";
                }
                else {
                  local_bc = "&#x";
                }
                (*context->actions->put_string)(context->target,local_bc);
                (*context->actions->put_string)(context->target,entity_string);
                if (c == ';') {
                  (*context->actions->put_character)(context->target,';');
                }
                HTMLSRC_apply_markup(context,HTL_badseq,'\0');
              }
              string->size = 0;
              context->isHex = '\0';
              context->state = S_text;
              unaff_ESI = local_b0;
              if (c == ';') break;
              goto top1;
            }
            unaff_ESI = local_b0;
            if ((((HTTag *)0xff < _sjis_lo) ||
                (((((_sjis_lo < (HTTag *)0x20 && (_sjis_lo != (HTTag *)0x9)) &&
                   (_sjis_lo != (HTTag *)0xa)) && ((_sjis_lo != (HTTag *)0xd && (HTCJK == NOCJK))))
                 || ((_sjis_lo == (HTTag *)0x7f && ((HTPassHighCtrlRaw == '\0' && (HTCJK == NOCJK)))
                     ))))) ||
               (((HTTag *)0x7f < _sjis_lo &&
                ((_sjis_lo < (HTTag *)0xa0 && (HTPassHighCtrlNum == '\0')))))) {
              if (psrc_view != '\0') {
                HTMLSRC_apply_markup(context,HTL_badseq,'\x01');
              }
              if (context->isHex == '\0') {
                (*context->actions->put_string)(context->target,"&#");
              }
              else {
                (*context->actions->put_string)(context->target,"&#x");
                context->isHex = '\0';
              }
              string->size = string->size + -1;
              for (i_1 = 0; i_1 < string->size; i_1 = i_1 + 1) {
                (*context->actions->put_character)(context->target,string->data[i_1]);
              }
              if (psrc_view != '\0') {
                HTMLSRC_apply_markup(context,HTL_badseq,'\0');
              }
              string->size = 0;
              context->isHex = '\0';
              context->state = S_text;
              goto top1;
            }
            if ((((_sjis_lo < (HTTag *)0xa1) || (HTPassEightBitNum != '\0')) ||
                (context->outUCLYhndl == LATIN1)) ||
               ((context->outUCI != (LYUCcharset *)0x0 && ((context->outUCI->enc & 2U) != 0)))) {
              if (psrc_view == '\0') {
                (*context->actions->put_character)(context->target,(char)_sjis_lo);
              }
              else {
                put_pretty_number(context);
              }
            }
            else {
              _sjis_lo = (HTTag *)&_sjis_lo[-3].can_justify;
              EntityName = HTMLGetEntityName((UCode_t)_sjis_lo);
              if ((EntityName == (char *)0x0) || (*EntityName == '\0')) {
                if (psrc_view != '\0') {
                  HTMLSRC_apply_markup(context,HTL_badseq,'\x01');
                }
                if (context->isHex == '\0') {
                  (*context->actions->put_string)(context->target,"&#");
                }
                else {
                  (*context->actions->put_string)(context->target,"&#x");
                  context->isHex = '\0';
                }
                string->size = string->size + -1;
                for (i_1 = 0; i_1 < string->size; i_1 = i_1 + 1) {
                  (*context->actions->put_character)(context->target,string->data[i_1]);
                }
                if (psrc_view != '\0') {
                  HTMLSRC_apply_markup(context,HTL_badseq,'\0');
                }
                string->size = 0;
                context->isHex = '\0';
                context->state = S_text;
                goto top1;
              }
              string->size = 0;
              HTChunkPuts(string,EntityName);
              HTChunkTerminate(string);
              handle_entity(context,'\0');
              if (FoundEntity == '\0') {
                (*context->actions->put_character)(context->target,';');
              }
            }
          }
        }
        else if (psrc_view == '\0') {
          (*context->actions->put_character)(context->target,(char)uck);
        }
        else {
          put_pretty_number(context);
        }
LAB_0811cfab:
        string->size = 0;
        context->isHex = '\0';
        context->state = S_text;
      }
      else {
        if (psrc_view != '\0') {
          HTMLSRC_apply_markup(context,HTL_entity,'\x01');
          if (context->isHex == '\0') {
            local_cc = "&#";
          }
          else {
            local_cc = "&#x";
          }
          (*context->actions->put_string)(context->target,local_cc);
          (*context->actions->put_string)(context->target,entity_string);
          if (c == ';') {
            (*context->actions->put_character)(context->target,';');
          }
          HTMLSRC_apply_markup(context,HTL_entity,'\0');
        }
        string->size = 0;
        context->isHex = '\0';
        context->state = S_text;
      }
joined_r0x0811cfcc:
      unaff_ESI = local_b0;
      if (c != ';') goto top1;
      break;
    default:
      if (c == '>') {
        HTChunkTerminate(string);
        if (psrc_view != '\0') {
          if (context->state == S_junk_tag) {
            HTMLSRC_apply_markup(context,HTL_badtag,'\0');
          }
          HTMLSRC_apply_markup(context,HTL_abracket,'\x01');
          (*context->actions->put_character)(context->target,'>');
          HTMLSRC_apply_markup(context,HTL_abracket,'\0');
        }
        if (context->state == S_pi) {
          handle_processing_instruction(context);
        }
        string->size = 0;
        context->current_tag = (HTTag *)0x0;
        context->state = S_text;
      }
      else {
        HTChunkPutc(string,c);
        if (psrc_view != '\0') {
          (*context->actions->put_character)(context->target,c);
        }
      }
      break;
    case S_litteral:
case_S_litteral:
      HTChunkPutc(string,c);
      if (psrc_view == '\0') {
        if (context->element_stack == (HTElement *)0x0) {
          local_ec = (HTTag *)0x0;
        }
        else {
          local_ec = context->element_stack->tag;
        }
        testtag = local_ec;
      }
      else {
        testtag = context->current_tag;
      }
      if ((testtag == (HTTag *)0x0) || (testtag->name == (char *)0x0)) {
        string->size = string->size + -1;
        context->state = S_text;
        goto top1;
      }
      testlast = ((string->size + -2) - context->trailing_spaces) - context->leading_spaces;
      ppuVar7 = __ctype_b_loc();
      if (((*ppuVar7)[c] & 0x200) == 0) {
        local_b0 = (HTTag *)(uint)c;
        local_e8 = local_b0;
      }
      else {
        local_e8 = (HTTag *)toupper((uint)c);
      }
      if (testlast < 0) {
        local_e4 = (HTTag *)0x2f;
      }
      else {
        local_e4 = (HTTag *)(int)testtag->name[testlast];
      }
      if (local_e8 != local_e4) {
        if (((c == '>') && (-1 < testlast)) && (testtag->name[testlast] == '\0')) {
          if (psrc_view == '\0') {
            end_element(context,context->element_stack->tag);
          }
          else {
            HTMLSRC_apply_markup(context,HTL_abracket,'\x01');
            (*context->actions->put_string)(context->target,"</");
            HTMLSRC_apply_markup(context,HTL_abracket,'\0');
            HTMLSRC_apply_markup(context,HTL_tag,'\x01');
            strcpy(string->data,context->current_tag->name);
            transform_tag(context,string);
            (*context->actions->put_string)(context->target,string->data);
            HTMLSRC_apply_markup(context,HTL_tag,'\0');
            HTMLSRC_apply_markup(context,HTL_abracket,'\x01');
            (*context->actions->put_character)(context->target,'>');
            HTMLSRC_apply_markup(context,HTL_abracket,'\0');
            context->current_tag = (HTTag *)0x0;
          }
          string->size = 0;
          context->current_attribute_number = -1;
          context->state = S_text;
          context->leading_spaces = 0;
          context->trailing_spaces = 0;
        }
        else {
          ppuVar7 = __ctype_b_loc();
          if (((*ppuVar7)[c] & 0x2000) == 0) {
LAB_0811bdce:
            context->leading_spaces = 0;
            context->trailing_spaces = 0;
            unaff_ESI = local_b0;
            if (((((testtag->contents == SGML_LITTERAL) || ((testtag->flags & 8U) == 0)) &&
                 ((context->state != S_pcdata || ((testtag->flags & 9U) == 0)))) || (testlast < 0))
               || (((c != '>' && (testlast < 1)) &&
                   (ppuVar7 = __ctype_b_loc(), ((*ppuVar7)[c] & 0x400) == 0)))) {
              if ((((context->state != S_pcdata) || ((testtag->flags & 9U) == 0)) || (-1 < testlast)
                  ) || (ppuVar7 = __ctype_b_loc(), ((*ppuVar7)[c] & 0x400) == 0)) {
                (*context->actions->put_character)(context->target,'<');
                for (i = 0; i < string->size + -1; i = i + 1) {
                  (*context->actions->put_character)(context->target,string->data[i]);
                }
                string->size = 0;
                context->state = S_text;
                goto top1;
              }
              context->state = S_tag;
            }
            else {
              context->state = S_end;
              string->size = string->size + -1;
              for (i = 0; i < string->size; i = i + 1) {
                string->data[i] = string->data[i + 1];
              }
              if (string->size == 1) {
                ppuVar7 = __ctype_b_loc();
                bVar9 = ((*ppuVar7)[c] & 0x400) != 0;
              }
              else {
                ppuVar7 = __ctype_b_loc();
                if (((((*ppuVar7)[c] & 8) == 0) && (c != '_')) &&
                   ((c != '-' && ((c != '.' && (c != ':')))))) {
                  bVar9 = false;
                }
                else {
                  bVar9 = true;
                }
              }
              if (!bVar9) {
                string->size = string->size + -1;
                goto top1;
              }
            }
          }
          else if (testlast == -1) {
            context->leading_spaces = context->leading_spaces + 1;
            if ((WWW_TraceFlag != '\0') && (((byte)WWW_TraceMask & 1) == 1)) {
              unaff_EBX = (uchar *)context->leading_spaces;
              pFVar6 = TraceFP();
              fprintf((FILE *)pFVar6,"leading spaces: %d\n",unaff_EBX);
            }
          }
          else {
            if (testlast < 1) goto LAB_0811bdce;
            context->trailing_spaces = context->trailing_spaces + 1;
            if ((WWW_TraceFlag != '\0') && (((byte)WWW_TraceMask & 1) == 1)) {
              unaff_EBX = (uchar *)context->trailing_spaces;
              pFVar6 = TraceFP();
              fprintf((FILE *)pFVar6,"trailing spaces: %d\n",unaff_EBX);
            }
          }
        }
      }
      break;
    case S_marked:
      if ((context->first_bracket == '\0') || (c != '[')) {
        if ((context->second_bracket == '\0') ||
           ((c != ']' || (string->data[string->size + -1] != ']')))) {
          if ((context->second_bracket == '\0') && (c == '>')) {
            HTChunkTerminate(string);
            if (psrc_view == '\0') {
              handle_marked(context);
            }
            else {
              HTMLSRC_apply_markup(context,HTL_sgmlspecial,'\x01');
              (*context->actions->put_character)(context->target,'<');
              (*context->actions->put_string)(context->target,string->data);
              (*context->actions->put_character)(context->target,'>');
              HTMLSRC_apply_markup(context,HTL_sgmlspecial,'\0');
            }
            string->size = 0;
            context->state = S_text;
          }
          else {
            HTChunkPutc(string,c);
          }
        }
        else {
          HTChunkPutc(string,']');
          context->second_bracket = '\0';
        }
      }
      else {
        HTChunkPutc(string,'[');
        context->first_bracket = '\0';
        context->second_bracket = '\x01';
      }
      break;
    case S_nonascii_text:
      if (c == '\x1b') {
        context->state = S_esc;
      }
      (*context->actions->put_character)(context->target,c);
      if (c < 0x20) {
        context->state = S_text;
      }
      break;
    case S_nonascii_text_dq:
      if (c == '\x1b') {
        context->state = S_esc_dq;
      }
      HTChunkPutc(string,c);
      break;
    case S_nonascii_text_sq:
      if (c == '\x1b') {
        context->state = S_esc_sq;
      }
      HTChunkPutc(string,c);
      break;
    case S_paren:
      if (((c == 'B') || (c == 'J')) || (c == 'T')) {
        context->state = S_text;
      }
      else if (c == 'I') {
        context->state = S_nonascii_text;
      }
      else {
        context->state = S_text;
      }
      (*context->actions->put_character)(context->target,c);
      break;
    case S_paren_dq:
      if (((c == 'B') || (c == 'J')) || (c == 'T')) {
        context->state = S_dquoted;
      }
      else if (c == 'I') {
        context->state = S_nonascii_text_dq;
      }
      else {
        context->state = S_dquoted;
      }
      HTChunkPutc(string,c);
      break;
    case S_paren_sq:
      if (((c == 'B') || (c == 'J')) || (c == 'T')) {
        context->state = S_squoted;
      }
      else if (c == 'I') {
        context->state = S_nonascii_text_sq;
      }
      else {
        context->state = S_squoted;
      }
      HTChunkPutc(string,c);
      break;
    case S_pcdata:
      if ((string->size != 0) || (0x7e < clong)) goto case_S_litteral;
      if (c == '!') {
        context->state = S_exclamation;
        context->lead_exclamation = '\x01';
        context->doctype_bracket = '\0';
        context->first_bracket = '\0';
        HTChunkPutc(string,'!');
      }
      else {
        if (c != '?') goto case_S_litteral;
        if (WWW_TraceFlag != '\0') {
          pFVar6 = TraceFP();
          fprintf((FILE *)pFVar6,"SGML: Found PI in PCDATA, junking it until \'>\'\n");
        }
        if (psrc_view != '\0') {
          HTMLSRC_apply_markup(context,HTL_abracket,'\x01');
          (*context->actions->put_string)(context->target,"<?");
          HTMLSRC_apply_markup(context,HTL_abracket,'\0');
        }
        context->state = S_pi;
      }
      break;
    case S_script:
      if (((string->size != 0) || (0x7e < clong)) || (c != '!')) goto case_S_litteral;
      context->state = S_exclamation;
      context->lead_exclamation = '\x01';
      context->doctype_bracket = '\0';
      context->first_bracket = '\0';
      HTChunkPutc(string,'!');
      break;
    case S_sgmlatt:
      if ((context->first_dash == '\0') && (c == '-')) {
        HTChunkPutc(string,'-');
        context->first_dash = '\x01';
      }
      else if ((context->first_dash == '\0') || (c != '-')) {
        if ((context->end_comment == '\0') || (c != '>')) {
          context->first_dash = '\0';
          HTChunkPutc(string,c);
        }
        else {
          HTChunkTerminate(string);
          if (psrc_view == '\0') {
            handle_sgmlatt(context);
          }
          else {
            HTMLSRC_apply_markup(context,HTL_sgmlspecial,'\x01');
            (*context->actions->put_character)(context->target,'<');
            (*context->actions->put_string)(context->target,string->data);
            (*context->actions->put_character)(context->target,'>');
            HTMLSRC_apply_markup(context,HTL_sgmlspecial,'\0');
          }
          string->size = 0;
          context->end_comment = '\0';
          context->first_dash = '\0';
          context->state = S_text;
        }
      }
      else {
        HTChunkPutc(string,'-');
        context->first_dash = '\0';
        if (context->end_comment == '\0') {
          context->end_comment = '\x01';
        }
        else {
          context->end_comment = '\0';
        }
      }
      break;
    case S_sgmlele:
      if ((context->first_dash == '\0') && (c == '-')) {
        HTChunkPutc(string,'-');
        context->first_dash = '\x01';
      }
      else if ((context->first_dash == '\0') || (c != '-')) {
        if ((context->end_comment == '\0') || (c != '>')) {
          context->first_dash = '\0';
          HTChunkPutc(string,c);
        }
        else {
          HTChunkTerminate(string);
          if (psrc_view == '\0') {
            handle_sgmlele(context);
          }
          else {
            HTMLSRC_apply_markup(context,HTL_sgmlspecial,'\x01');
            (*context->actions->put_character)(context->target,'<');
            (*context->actions->put_string)(context->target,string->data);
            (*context->actions->put_character)(context->target,'>');
            HTMLSRC_apply_markup(context,HTL_sgmlspecial,'\0');
          }
          string->size = 0;
          context->end_comment = '\0';
          context->first_dash = '\0';
          context->state = S_text;
        }
      }
      else {
        HTChunkPutc(string,'-');
        context->first_dash = '\0';
        if (context->end_comment == '\0') {
          context->end_comment = '\x01';
        }
        else {
          context->end_comment = '\0';
        }
      }
      break;
    case S_sgmlent:
      if ((context->first_dash == '\0') && (c == '-')) {
        HTChunkPutc(string,'-');
        context->first_dash = '\x01';
      }
      else if ((context->first_dash == '\0') || (c != '-')) {
        if ((context->end_comment == '\0') || (c != '>')) {
          context->first_dash = '\0';
          HTChunkPutc(string,c);
        }
        else {
          HTChunkTerminate(string);
          if (psrc_view == '\0') {
            handle_sgmlent(context);
          }
          else {
            HTMLSRC_apply_markup(context,HTL_sgmlspecial,'\x01');
            (*context->actions->put_character)(context->target,'<');
            (*context->actions->put_string)(context->target,string->data);
            (*context->actions->put_character)(context->target,'>');
            HTMLSRC_apply_markup(context,HTL_sgmlspecial,'\0');
          }
          string->size = 0;
          context->end_comment = '\0';
          context->first_dash = '\0';
          context->state = S_text;
        }
      }
      else {
        HTChunkPutc(string,'-');
        context->first_dash = '\0';
        if (context->end_comment == '\0') {
          context->end_comment = '\x01';
        }
        else {
          context->end_comment = '\0';
        }
      }
      break;
    case S_squoted:
      if (c == '\'') {
        HTChunkTerminate(string);
        BVar4 = end_if_prettysrc(context,string,'\'');
        if (BVar4 == '\0') {
          handle_attribute_value(context,string->data);
        }
        string->size = 0;
        context->state = S_tag_gap;
      }
      else if (c == '\x1b') {
        context->state = S_esc_sq;
        HTChunkPutc(string,'\x1b');
      }
      else if (((context->T).decode_utf8 == '\0') || (context->utf_buf[0] == '\0')) {
        if ((HTCJK == NOCJK) &&
           (((context->T).output_utf8 != '\0' || ((context->T).trans_from_uni != '\0')))) {
          if ((((clong == 0xfffd) && (saved_char_in != '\0')) && (HTPassEightBitRaw != '\0')) &&
             (LYlowest_eightbit[context->outUCLYhndl] <= (int)(uint)(byte)saved_char_in)) {
            if ((CONCAT11(0xf0,saved_char_in) < 0x80) && (string->size < string->allocated)) {
              iVar5 = string->size;
              string->data[iVar5] = saved_char_in;
              string->size = iVar5 + 1;
            }
            else {
              HTChunkPutUtf8Char(string,(uint)CONCAT11(0xf0,saved_char_in));
            }
          }
          else if ((clong < 0x80) && (string->size < string->allocated)) {
            iVar5 = string->size;
            string->data[iVar5] = cVar3;
            string->size = iVar5 + 1;
          }
          else {
            HTChunkPutUtf8Char(string,clong);
          }
        }
        else if ((saved_char_in == '\0') || ((context->T).use_raw_char_in == '\0')) {
          HTChunkPutc(string,c);
        }
        else {
          HTChunkPutc(string,saved_char_in);
        }
      }
      else {
        HTChunkPuts(string,context->utf_buf);
        context->utf_buf_p = context->utf_buf;
        *context->utf_buf_p = '\0';
      }
      break;
    case S_tag:
      if (clong < 0x7f) {
        if (string->size == 0) {
          ppuVar7 = __ctype_b_loc();
          if (((*ppuVar7)[c] & 0x400) != 0) goto LAB_0811d1a2;
        }
        else {
          ppuVar7 = __ctype_b_loc();
          if (((((*ppuVar7)[c] & 8) == 0) && (c != '_')) &&
             ((c != '-' && ((c != '.' && (c != ':')))))) {
            bVar9 = false;
          }
          else {
            bVar9 = true;
          }
          if (bVar9) {
LAB_0811d1a2:
            HTChunkPutc(string,c);
            break;
          }
        }
      }
      if ((c == '!') && (string->size == 0)) {
        context->state = S_exclamation;
        context->lead_exclamation = '\x01';
        context->doctype_bracket = '\0';
        context->first_bracket = '\0';
        HTChunkPutc(string,'!');
        break;
      }
      if (((((string->size != 0) || (0xa0 < clong)) || (c == '/')) || ((c == '?' || (c == '_')))) ||
         (c == ':')) {
        if (c == '/') {
          if (string->size == 0) {
            context->state = S_end;
            break;
          }
          if (WWW_TraceFlag != '\0') {
            unaff_EBX = (uchar *)string->data;
            local_b0 = (HTTag *)string->size;
            pFVar6 = TraceFP();
            fprintf((FILE *)pFVar6,"SGML: `<%.*s/\' found!\n",local_b0,unaff_EBX);
          }
        }
        HTChunkTerminate(string);
        t = SGMLFindTag(dtd,string->data);
        if ((context->unknown_tag == t) &&
           ((((c == ':' && (string->size == 4)) &&
             (iVar5 = strcasecomp(string->data,"URL"), iVar5 == 0)) ||
            ((4 < string->size && (iVar5 = strncasecomp(string->data,"URL:",4), iVar5 == 0)))))) {
          if (psrc_view != '\0') {
            HTMLSRC_apply_markup(context,HTL_badseq,'\x01');
          }
          (*context->actions->put_character)(context->target,'<');
          (*context->actions->put_string)(context->target,string->data);
          (*context->actions->put_character)(context->target,c);
          if (psrc_view != '\0') {
            HTMLSRC_apply_markup(context,HTL_badseq,'\0');
          }
          if (WWW_TraceFlag != '\0') {
            unaff_EBX = (uchar *)(uint)c;
            local_b0 = (HTTag *)string->data;
            pFVar6 = TraceFP();
            fprintf((FILE *)pFVar6,"SGML: Treating <%s%c as text\n",local_b0,unaff_EBX);
          }
          string->size = 0;
          context->state = S_text;
        }
        else {
          if ((c == '/') && (t != (HTTag *)0x0)) {
            context->slashedtag = t;
          }
          if (t == (HTTag *)0x0) {
            if ((c == '?') && (string->size < 2)) {
              if (WWW_TraceFlag != '\0') {
                pFVar6 = TraceFP();
                fprintf((FILE *)pFVar6,"SGML: Found PI, looking for \'>\'\n");
              }
              if (psrc_view != '\0') {
                HTMLSRC_apply_markup(context,HTL_abracket,'\x01');
                (*context->actions->put_string)(context->target,"<?");
                HTMLSRC_apply_markup(context,HTL_abracket,'\0');
              }
              string->size = 0;
              context->state = S_pi;
              HTChunkPutc(string,c);
            }
            else {
              if (WWW_TraceFlag != '\0') {
                unaff_EBX = (uchar *)string->data;
                pFVar6 = TraceFP();
                fprintf((FILE *)pFVar6,"SGML: *** Invalid element %s\n",unaff_EBX);
              }
              if (psrc_view != '\0') {
                HTMLSRC_apply_markup(context,HTL_abracket,'\x01');
                (*context->actions->put_character)(context->target,'<');
                HTMLSRC_apply_markup(context,HTL_abracket,'\0');
                HTMLSRC_apply_markup(context,HTL_badtag,'\x01');
                transform_tag(context,string);
                (*context->actions->put_string)(context->target,string->data);
                if (c == '>') {
                  HTMLSRC_apply_markup(context,HTL_badtag,'\0');
                  HTMLSRC_apply_markup(context,HTL_abracket,'\x01');
                  (*context->actions->put_character)(context->target,'>');
                  HTMLSRC_apply_markup(context,HTL_abracket,'\0');
                }
                else {
                  (*context->actions->put_character)(context->target,c);
                }
              }
              if (c == '>') {
                local_b4 = S_text;
              }
              else {
                local_b4 = S_junk_tag;
              }
              context->state = local_b4;
            }
          }
          else {
            if ((context->unknown_tag == t) && (WWW_TraceFlag != '\0')) {
              unaff_EBX = (uchar *)string->data;
              pFVar6 = TraceFP();
              fprintf((FILE *)pFVar6,"SGML: *** Unknown element %s\n",unaff_EBX);
            }
            context->current_tag = t;
            if (psrc_view != '\0') {
              HTMLSRC_apply_markup(context,HTL_abracket,'\x01');
              (*context->actions->put_character)(context->target,'<');
              HTMLSRC_apply_markup(context,HTL_abracket,'\0');
              if (context->unknown_tag == t) {
                HTMLSRC_apply_markup(context,HTL_badtag,'\x01');
              }
              else {
                HTMLSRC_apply_markup(context,HTL_tag,'\x01');
              }
              transform_tag(context,string);
              (*context->actions->put_string)(context->target,string->data);
              if (context->unknown_tag == t) {
                HTMLSRC_apply_markup(context,HTL_badtag,'\0');
              }
              else {
                HTMLSRC_apply_markup(context,HTL_tag,'\0');
              }
            }
            if (psrc_view == '\0') {
              memset(context->present,0,context->current_tag->number_of_attributes);
            }
            string->size = 0;
            context->current_attribute_number = -1;
            if (psrc_view == '\0') {
              if (((c == '>') || (c == '<')) ||
                 ((c == '/' && (context->slashedtag != (HTTag *)0x0)))) {
                if (context->current_tag->name != (char *)0x0) {
                  start_element(context);
                }
                if (c == '>') {
                  local_ac = S_text;
                }
                else {
                  if (c == '<') {
                    local_a8 = S_tag;
                  }
                  else {
                    local_a8 = S_tagname_slash;
                  }
                  local_ac = local_a8;
                }
                context->state = local_ac;
              }
              else {
                context->state = S_tag_gap;
              }
            }
            else if (((c == '>') || (c == '<')) ||
                    ((c == '/' && (context->slashedtag != (HTTag *)0x0)))) {
              if (c == '<') {
                context->state = S_tag;
              }
              else {
                HTMLSRC_apply_markup(context,HTL_abracket,'\x01');
                (*context->actions->put_character)(context->target,c);
                HTMLSRC_apply_markup(context,HTL_abracket,'\0');
                if (c == '>') {
                  local_b0 = (HTTag *)0x0;
                }
                else {
                  local_b0 = (HTTag *)0x29;
                }
                context->state = (sgml_state)local_b0;
              }
            }
            else {
              if (0x20 < c) {
                (*context->actions->put_character)(context->target,c);
              }
              context->state = S_tag_gap;
            }
          }
        }
        break;
      }
      context->state = S_text;
      if (psrc_view != '\0') {
        HTMLSRC_apply_markup(context,HTL_badseq,'\x01');
      }
      (*context->actions->put_character)(context->target,'<');
      if (psrc_view != '\0') {
        HTMLSRC_apply_markup(context,HTL_badseq,'\0');
      }
      goto top1;
    case S_tag_gap:
      if (0x20 < c) {
        if (c == '>') {
          if ((psrc_view == '\0') && (context->current_tag->name != (char *)0x0)) {
            start_element(context);
          }
          if (psrc_view != '\0') {
            HTMLSRC_apply_markup(context,HTL_abracket,'\x01');
            (*context->actions->put_character)(context->target,'>');
            HTMLSRC_apply_markup(context,HTL_abracket,'\0');
          }
          context->state = S_text;
        }
        else {
          HTChunkPutc(string,c);
          context->state = S_attr;
        }
      }
      break;
    case S_tagname_slash:
      if (((c != '>') || (context->slashedtag == (HTTag *)0x0)) || (0x7e < clong)) {
        context->state = S_text;
      }
switchD_0811aee3_caseD_0:
      if (((HTCJK == NOCJK) || (-1 < (char)c)) || ((context->T).decode_utf8 != '\0')) {
        if ((HTCJK == NOCJK) || (c != '\x1b')) {
          if ((c == '&') || (c == '<')) {
            if (psrc_view == '\0') {
              if (context->element_stack == (HTElement *)0x0) {
                local_f4 = (HTTag *)0x0;
              }
              else {
                local_f4 = context->element_stack->tag;
              }
              testtag = local_f4;
              local_b0 = local_f4;
            }
            else {
              testtag = context->current_tag;
            }
          }
          if (((c == '&') && (clong < 0x7f)) &&
             ((testtag == (HTTag *)0x0 ||
              ((((testtag->contents == SGML_MIXED || (testtag->contents == SGML_ELEMENT)) ||
                (testtag->contents == SGML_PCDATA)) ||
               ((testtag->contents == SGML_EMPTY || (testtag->contents == SGML_RCDATA)))))))) {
            string->size = 0;
            context->state = S_ero;
          }
          else if ((c == '<') && (clong < 0x7f)) {
            string->size = 0;
            if ((testtag == (HTTag *)0x0) || (testtag->contents != SGML_PCDATA)) {
              if ((testtag == (HTTag *)0x0) ||
                 ((testtag->contents != SGML_LITTERAL && (testtag->contents != SGML_CDATA)))) {
                if ((testtag == (HTTag *)0x0) || (testtag->contents != SGML_SCRIPT)) {
                  context->state = S_tag;
                }
                else {
                  context->state = S_script;
                }
              }
              else {
                context->state = S_litteral;
              }
            }
            else {
              context->state = S_pcdata;
            }
            context->slashedtag = (HTTag *)0x0;
          }
          else if ((((context->slashedtag == (HTTag *)0x0) ||
                    (context->slashedtag->name == (char *)0x0)) ||
                   ((c != '/' && ((c != '>' || (context->state != S_tagname_slash)))))) ||
                  (0x7e < clong)) {
            if ((context->element_stack == (HTElement *)0x0) ||
               ((context->element_stack->tag->flags & 0x20U) == 0)) {
              if ((clong == 0xa0) &&
                 (((context->no_lynx_specialcodes == '\0' && ((context->T).pass_160_173_raw == '\0')
                   ) && (HTCJK == NOCJK)))) {
                (*context->actions->put_character)(context->target,'\x01');
              }
              else if ((((clong == 0xad) && (context->no_lynx_specialcodes == '\0')) &&
                       ((context->T).pass_160_173_raw == '\0')) && (HTCJK == NOCJK)) {
                (*context->actions->put_character)(context->target,'\a');
              }
              else if (((context->T).use_raw_char_in == '\0') || (saved_char_in == '\0')) {
                if (((context->T).trans_from_uni == '\0') || (clong < 0xa0)) {
                  local_f0 = '\0';
                }
                else {
                  local_f0 = '\x01';
                }
                chk = local_f0;
                if (((local_f0 == '\0') ||
                    (uck = UCTransUniChar(clong,context->outUCLYhndl), uck < 0x20)) || (0xff < uck))
                {
                  if ((chk != '\0') &&
                     ((uck == -4 ||
                      ((((context->T).repl_translated_C0 != '\0' && (0 < uck)) && (uck < 0x20))))))
                  {
                    uVar8 = UCTransUniCharStr(replace_buf,0x3c,clong,context->outUCLYhndl,0);
                    uck = -((int)~uVar8 >> 0x1f);
                    if (uck != 0) {
                      (*context->actions->put_string)(context->target,replace_buf);
                      break;
                    }
                  }
                  if (((context->T).output_utf8 == '\0') ||
                     (BVar4 = UCPutUtf8_charstring
                                        ((HTStream *)context->target,
                                         (putc_func_t *)context->actions->put_character,clong),
                     BVar4 == '\0')) {
                    if ((((clong < 0xa1) || ((0xff < clong || (HTPassEightBitRaw != '\0')))) ||
                        (((context->T).do_8bitraw != '\0' && ((context->T).trans_from_uni == '\0')))
                        ) || (((HTCJK != NOCJK || (context->outUCLYhndl == LATIN1)) ||
                              ((context->outUCI != (LYUCcharset *)0x0 &&
                               ((context->outUCI->enc & 2U) != 0)))))) {
                      if ((clong < 0x7f) && (0 < clong)) {
                        (*context->actions->put_character)(context->target,c);
                      }
                      else if (((context->T).output_utf8 == '\0') || (context->utf_buf[0] == '\0'))
                      {
                        if ((LYlowest_eightbit[context->outUCLYhndl] <= (int)(uint)c) &&
                           (((context->T).trans_from_uni == '\0' || (HTPassEightBitRaw != '\0')))) {
                          (*context->actions->put_character)(context->target,c);
                        }
                      }
                      else {
                        (*context->actions->put_string)(context->target,context->utf_buf);
                        context->utf_buf_p = context->utf_buf;
                        *context->utf_buf_p = '\0';
                      }
                    }
                    else {
                      psrc_view_backup = 0;
                      string->size = 0;
                      EntityName = HTMLGetEntityName(clong + -0xa0);
                      HTChunkPuts(string,EntityName);
                      HTChunkTerminate(string);
                      if (psrc_view != '\0') {
                        psrc_view_backup = 1;
                        psrc_view = '\0';
                      }
                      handle_entity(context,'\0');
                      if (psrc_view_backup != 0) {
                        psrc_view = '\x01';
                      }
                      string->size = 0;
                      if (FoundEntity == '\0') {
                        (*context->actions->put_character)(context->target,';');
                      }
                    }
                  }
                }
                else {
                  if (WWW_TraceFlag != '\0') {
                    unaff_EBX = (uchar *)(int)(char)uck;
                    pFVar6 = TraceFP();
                    fprintf((FILE *)pFVar6,"UCTransUniChar returned 0x%.2lX:\'%c\'.\n",uck,unaff_EBX
                           );
                  }
                  (*context->actions->put_character)(context->target,(char)uck);
                }
              }
              else {
                (*context->actions->put_character)(context->target,saved_char_in);
                saved_char_in = '\0';
              }
            }
            else if (((context->T).decode_utf8 == '\0') || (context->utf_buf[0] == '\0')) {
              if ((HTCJK == NOCJK) &&
                 (((context->T).output_utf8 != '\0' || ((context->T).trans_from_uni != '\0')))) {
                if (cVar3 < '\0') {
                  if ((((clong == 0xfffd) && (saved_char_in != '\0')) && (HTPassEightBitRaw != '\0')
                      ) && (LYlowest_eightbit[context->outUCLYhndl] <=
                            (int)(uint)(byte)saved_char_in)) {
                    UCPutUtf8_charstring
                              ((HTStream *)context->target,
                               (putc_func_t *)context->actions->put_character,
                               (uint)CONCAT11(0xf0,saved_char_in));
                  }
                  else {
                    UCPutUtf8_charstring
                              ((HTStream *)context->target,
                               (putc_func_t *)context->actions->put_character,clong);
                  }
                }
                else {
                  (*context->actions->put_character)(context->target,c);
                }
              }
              else if ((saved_char_in == '\0') || ((context->T).use_raw_char_in == '\0')) {
                (*context->actions->put_character)(context->target,c);
              }
              else {
                (*context->actions->put_character)(context->target,saved_char_in);
              }
            }
            else {
              (*context->actions->put_string)(context->target,context->utf_buf);
              context->utf_buf_p = context->utf_buf;
              *context->utf_buf_p = '\0';
            }
          }
          else {
            if (psrc_view == '\0') {
              if ((context->slashedtag != context->unknown_tag) &&
                 ((context->slashedtag->contents != SGML_EMPTY ||
                  ((context->slashedtag->flags & 0x10U) != 0)))) {
                if (context->recover == (char *)0x0) {
                  HTSACopy(&context->recover,"</");
                  context->recover_index = 0;
                }
                else {
                  HTSACat(&context->recover,"</");
                }
                HTSACat(&context->recover,context->slashedtag->name);
                HTSACat(&context->recover,">");
              }
            }
            else {
              HTMLSRC_apply_markup(context,HTL_abracket,'\x01');
              (*context->actions->put_character)(context->target,c);
              HTMLSRC_apply_markup(context,HTL_abracket,'\0');
            }
            context->slashedtag = (HTTag *)0x0;
          }
        }
        else {
          context->state = S_esc;
          (*context->actions->put_character)(context->target,'\x1b');
        }
      }
      else {
        context->state = S_in_kanji;
        context->kanji_buf = c;
      }
      break;
    case S_value:
switchD_0811aee3_caseD_2a:
      if ((c < 0x21) || (c == '>')) {
        HTChunkTerminate(string);
        BVar4 = end_if_prettysrc(context,string,'\0');
        if (BVar4 == '\0') {
          if (((HTCJK != NOCJK) && (*string->data == '$')) &&
             ((string->data[1] == 'B' || (string->data[1] == '@')))) {
            _sjis_lo = (HTTag *)0x0;
            HTSprintf0((char **)&sjis_lo,"\x1b%s",string->data);
            TO_EUC((uchar *)_sjis_lo,(uchar *)string->data);
            if (_sjis_lo != (HTTag *)0x0) {
              free(_sjis_lo);
              _sjis_lo = (HTTag *)0x0;
            }
          }
          handle_attribute_value(context,string->data);
        }
        string->size = 0;
        if (c == '>') {
          if (psrc_view == '\0') {
            if (context->current_tag->name != (char *)0x0) {
              start_element(context);
            }
          }
          else {
            HTMLSRC_apply_markup(context,HTL_abracket,'\x01');
            (*context->actions->put_character)(context->target,'>');
            HTMLSRC_apply_markup(context,HTL_abracket,'\0');
          }
          context->state = S_text;
        }
        else {
          context->state = S_tag_gap;
        }
      }
      else if (((context->T).decode_utf8 == '\0') || (context->utf_buf[0] == '\0')) {
        if ((HTCJK == NOCJK) &&
           (((context->T).output_utf8 != '\0' || ((context->T).trans_from_uni != '\0')))) {
          if ((((clong == 0xfffd) && (saved_char_in != '\0')) && (HTPassEightBitRaw != '\0')) &&
             (LYlowest_eightbit[context->outUCLYhndl] <= (int)(uint)(byte)saved_char_in)) {
            if ((CONCAT11(0xf0,saved_char_in) < 0x80) && (string->size < string->allocated)) {
              iVar5 = string->size;
              string->data[iVar5] = saved_char_in;
              string->size = iVar5 + 1;
            }
            else {
              HTChunkPutUtf8Char(string,(uint)CONCAT11(0xf0,saved_char_in));
            }
          }
          else if ((clong < 0x80) && (string->size < string->allocated)) {
            iVar5 = string->size;
            string->data[iVar5] = (char)clong;
            string->size = iVar5 + 1;
          }
          else {
            HTChunkPutUtf8Char(string,clong);
          }
        }
        else if ((saved_char_in == '\0') || ((context->T).use_raw_char_in == '\0')) {
          HTChunkPutc(string,c);
        }
        else {
          HTChunkPutc(string,saved_char_in);
        }
      }
      else {
        HTChunkPuts(string,context->utf_buf);
        context->utf_buf_p = context->utf_buf;
        *context->utf_buf_p = '\0';
      }
    }
LAB_0812082d:
    unaff_ESI = local_b0;
    if ((WWW_TraceFlag != '\0') && (((byte)WWW_TraceMask & 1) == 1)) {
      uVar8 = (uint)c;
      if (string->data == (char *)0x0) {
        local_7c = "";
      }
      else {
        local_7c = string->data;
      }
      unaff_EBX = (uchar *)string->size;
      unaff_ESI = (HTTag *)state_name(context->state);
      pFVar6 = TraceFP();
      fprintf((FILE *)pFVar6,"SGML after  %s|%.*s|%c|\n",unaff_ESI,unaff_EBX,local_7c,uVar8);
    }
after_switch:
    if (context->include != (char *)0x0) {
      if (*context->include == '\0') {
        if (context->include != (char *)0x0) {
          free(context->include);
          context->include = (char *)0x0;
        }
      }
      else {
        if ((context->active_include != (char *)0x0) &&
           (context->active_include[context->include_index] != '\0')) {
          HTSACat(&context->include,context->active_include + context->include_index);
        }
        if (context->active_include != (char *)0x0) {
          free(context->active_include);
          context->active_include = (char *)0x0;
        }
        context->active_include = context->include;
        context->include_index = 0;
        context->include = (char *)0x0;
      }
    }
    if (context->recover != (char *)0x0) {
      if (context->recover[context->recover_index] != '\0') {
        c = context->recover[context->recover_index];
        context->recover_index = context->recover_index + 1;
        goto top;
      }
      if (context->recover != (char *)0x0) {
        free(context->recover);
        context->recover = (char *)0x0;
      }
      context->recover_index = 0;
    }
    if (context->active_include == (char *)0x0) {
LAB_08120b71:
      if (context->csi == (char *)0x0) goto LAB_08120c0d;
      if (context->csi[context->csi_index] != '\0') {
        c = context->csi[context->csi_index];
        context->csi_index = context->csi_index + 1;
        goto top;
      }
      if (context->csi != (char *)0x0) {
        free(context->csi);
        context->csi = (char *)0x0;
      }
      context->csi_index = 0;
      goto LAB_08120c0d;
    }
    if (context->active_include[context->include_index] == '\0') {
      if (context->active_include != (char *)0x0) {
        free(context->active_include);
        context->active_include = (char *)0x0;
      }
      context->include_index = 0;
      goto LAB_08120b71;
    }
    if ((context->current_tag_charset == UTF8_handle) || ((context->T).trans_from_uni != '\0')) {
      _sjis_lo = (HTTag *)(context->active_include + context->include_index);
      c = *(uchar *)&_sjis_lo->name;
      clong = UCGetUniFromUtf8String((char **)&sjis_lo);
      if ((clong < 0x100) && (-1 < clong)) {
        c = (uchar)clong;
      }
      saved_char_in = '\0';
      unaff_ESI = (HTTag *)((int)_sjis_lo - (int)context->active_include);
      context->include_index = (int)((int)&unaff_ESI->name + 1);
      goto top1;
    }
    c = context->active_include[context->include_index];
    context->include_index = context->include_index + 1;
top:
    saved_char_in = '\0';
  } while( true );
}



// WARNING: Unknown calling convention

void SGML_string(HTStream_conflict2 *context,char *str)

{
  char *p;
  
  for (p = str; *p != '\0'; p = p + 1) {
    SGML_character(context,*p);
  }
  return;
}



// WARNING: Unknown calling convention

void SGML_write(HTStream_conflict2 *context,char *str,int l)

{
  char *e;
  char *p;
  
  for (p = str; p < str + l; p = p + 1) {
    SGML_character(context,*p);
  }
  return;
}



// WARNING: Unknown calling convention

HTStream_conflict2 * SGML_new(SGML_dtd *dtd,HTParentAnchor *anchor,HTStructured *target)

{
  HTStream_conflict2 *context_00;
  HTChunk *pHVar1;
  int iVar2;
  LYUCcharset *pLVar3;
  HTStream_conflict2 *context;
  
  context_00 = (HTStream_conflict2 *)calloc(1,0x154);
  if (context_00 == (HTStream_conflict2 *)0x0) {
    outofmem("../../../WWW/Library/Implementation/SGML.c","SGML_begin");
  }
  context_00->isa = &SGMLParser;
  pHVar1 = HTChunkCreate(0x80);
  context_00->string = pHVar1;
  context_00->dtd = dtd;
  context_00->target = target;
  context_00->actions = target->isa;
  context_00->unknown_tag = &HTTag_unrecognized;
  context_00->slashedtag = (HTTag *)0x0;
  context_00->current_tag = context_00->slashedtag;
  context_00->state = S_text;
  context_00->node_anchor = anchor;
  context_00->utf_buf_p = context_00->utf_buf;
  UCTransParams_clear(&context_00->T);
  iVar2 = HTAnchor_getUCLYhndl(anchor,1);
  context_00->inUCLYhndl = iVar2;
  if (context_00->inUCLYhndl < 0) {
    HTAnchor_copyUCInfoStage(anchor,1,0,-1);
    iVar2 = HTAnchor_getUCLYhndl(anchor,1);
    context_00->inUCLYhndl = iVar2;
  }
  pLVar3 = HTAnchor_getUCInfoStage(anchor,1);
  context_00->inUCI = pLVar3;
  set_chartrans_handling(context_00,anchor,-1);
  context_00->recover = (char *)0x0;
  context_00->recover_index = 0;
  context_00->include = (char *)0x0;
  context_00->active_include = (char *)0x0;
  context_00->include_index = 0;
  context_00->url = (char *)0x0;
  context_00->csi = (char *)0x0;
  context_00->csi_index = 0;
  if (psrc_view != '\0') {
    psrc_view = '\0';
    mark_htext_as_source = '\x01';
    SGML_string(context_00,"<HTML><HEAD><TITLE>source</TITLE></HEAD><BODY><PRE>");
    psrc_view = '\x01';
    psrc_convert_string = '\0';
    sgml_in_psrc_was_initialized = '\x01';
  }
  sgml_offset = 0;
  return context_00;
}



// WARNING: Unknown calling convention

int SGML_offset(void)

{
  return psrc_view + sgml_offset;
}



void JISx0201TO0208_EUC(uchar IHI,uchar ILO,uchar *OHI,uchar *OLO)

{
  uchar ILO_local;
  uchar IHI_local;
  
  if (((IHI == 0x8e) && (0xa0 < ILO)) && (ILO < 0xe0)) {
    *OHI = *JISx0201TO0208_EUC::table[ILO - 0xa1];
    *OLO = JISx0201TO0208_EUC::table[ILO - 0xa1][1];
  }
  else {
    *OHI = IHI;
    *OLO = ILO;
  }
  return;
}



// WARNING: Unknown calling convention

int IS_SJIS_STR(uchar *str)

{
  byte bVar1;
  bool bVar2;
  bool bVar3;
  int is_sjis;
  uchar *s;
  uchar ch;
  
  bVar2 = false;
  s = str;
  do {
    do {
      bVar1 = *s;
      s = s + 1;
      if (bVar1 == 0) {
        return 0;
      }
    } while (-1 < (char)bVar1);
    if (((*s < 0x40) || (*s == 0x7f)) || (0xfc < *s)) {
      bVar3 = false;
    }
    else if ((bVar1 < 0x81) || (0x9f < bVar1)) {
      if ((bVar2) && ((0xdf < bVar1 && (bVar1 < 0xf0)))) {
        bVar3 = true;
      }
      else {
        bVar3 = false;
      }
    }
    else {
      bVar2 = true;
      bVar3 = true;
    }
  } while (!bVar3);
  return 1;
}



uchar * SJIS_TO_JIS1(uchar HI,uchar LO,uchar *JCODE)

{
  char cVar1;
  byte local_7;
  uchar local_6;
  char local_5;
  
  local_7 = LO;
  if (HI < 0xa0) {
    local_5 = 'q';
  }
  else {
    local_5 = -0x4f;
  }
  cVar1 = (HI - local_5) * '\x02';
  local_6 = cVar1 + '\x01';
  if ((char)LO < '\0') {
    local_7 = LO - 1;
  }
  if (local_7 < 0x9e) {
    local_7 = local_7 - 0x1f;
  }
  else {
    local_7 = local_7 + 0x83;
    local_6 = cVar1 + '\x02';
  }
  *JCODE = local_6;
  JCODE[1] = local_7;
  return JCODE;
}



uchar * JIS_TO_SJIS1(uchar HI,uchar LO,uchar *SJCODE)

{
  char cVar1;
  byte local_6;
  byte local_5;
  
  if ((HI & 1) == 0) {
    local_6 = LO + 0x7d;
  }
  else {
    local_6 = LO + 0x1f;
  }
  if (0x7e < local_6) {
    local_6 = local_6 + 1;
  }
  cVar1 = (char)((int)(HI - 0x21) >> 1);
  local_5 = cVar1 + 0x81;
  if (0x9f < local_5) {
    local_5 = cVar1 - 0x3f;
  }
  *SJCODE = local_5;
  SJCODE[1] = local_6;
  return SJCODE;
}



uchar * EUC_TO_SJIS1(uchar HI,uchar LO,uchar *SJCODE)

{
  uchar LO_local;
  uchar HI_local;
  
  HI_local = HI;
  LO_local = LO;
  if (HI == 0x8e) {
    JISx0201TO0208_EUC(0x8e,LO,&HI_local,&LO_local);
  }
  JIS_TO_SJIS1(HI_local & 0x7f,LO_local & 0x7f,SJCODE);
  return SJCODE;
}



// WARNING: Unknown calling convention

void JISx0201TO0208_SJIS(uchar I,uchar *OHI,uchar *OLO)

{
  uchar in_stack_00000004;
  byte *in_stack_00000008;
  byte *in_stack_0000000c;
  uchar SJCODE [2];
  
  JISx0201TO0208_EUC(0x8e,in_stack_00000004,in_stack_00000008,in_stack_0000000c);
  JIS_TO_SJIS1(*in_stack_00000008 & 0x7f,*in_stack_0000000c & 0x7f,SJCODE);
  *in_stack_00000008 = SJCODE[0];
  *in_stack_0000000c = SJCODE[1];
  return;
}



uchar * SJIS_TO_EUC1(uchar HI,uchar LO,uchar *data)

{
  uchar LO_local;
  uchar HI_local;
  
  SJIS_TO_JIS1(HI,LO,data);
  *data = *data | 0x80;
  data[1] = data[1] | 0x80;
  return data;
}



// WARNING: Unknown calling convention

uchar * SJIS_TO_EUC(uchar *src,uchar *dst)

{
  byte LO;
  byte HI;
  bool bVar1;
  byte *local_10;
  byte *local_c;
  int local_8;
  
  local_8 = IS_SJIS_STR(src);
  local_10 = src;
  local_c = dst;
  do {
    while( true ) {
      HI = *local_10;
      if (HI == 0) {
        *local_c = 0;
        return dst;
      }
      LO = local_10[1];
      if ((((TREAT_SJIS != 0) && (0x3f < LO)) && (LO != 0x7f)) && (LO < 0xfd)) break;
LAB_081212fc:
      *local_c = *local_10;
      local_c = local_c + 1;
      local_10 = local_10 + 1;
    }
    if ((HI < 0x81) || (0x9f < HI)) {
      if ((local_8 == 0) || ((HI < 0xe0 || (0xef < HI)))) {
        bVar1 = false;
      }
      else {
        bVar1 = true;
      }
      if (!bVar1) goto LAB_081212fc;
    }
    else {
      local_8 = 1;
    }
    SJIS_TO_JIS1(HI,LO,local_c);
    *local_c = *local_c | 0x80;
    local_c[1] = local_c[1] | 0x80;
    local_c = local_c + 2;
    local_10 = local_10 + 2;
  } while( true );
}



// WARNING: Unknown calling convention

uchar * EUC_TO_SJIS(uchar *src,uchar *dst)

{
  byte *local_c;
  byte *local_8;
  
  local_c = src;
  local_8 = dst;
  while (*local_c != 0) {
    if ((char)*local_c < '\0') {
      if ((local_c[1] == 0) || (-1 < (char)local_c[1])) {
        local_c = local_c + 1;
      }
      else {
        JIS_TO_SJIS1(*local_c & 0x7f,local_c[1] & 0x7f,local_8);
        local_8 = local_8 + 2;
        local_c = local_c + 2;
      }
    }
    else {
      *local_8 = *local_c;
      local_8 = local_8 + 1;
      local_c = local_c + 1;
    }
  }
  *local_8 = 0;
  return dst;
}



// WARNING: Unknown calling convention

uchar * EUC_TO_JIS(uchar *src,uchar *dst,char *toK,char *toA)

{
  byte *pbVar1;
  byte bVar2;
  size_t sVar3;
  byte local_1e;
  byte *local_1c;
  byte *local_18;
  int is_JIS;
  
  local_1e = 0;
  local_1c = src;
  local_18 = dst;
  is_JIS = 0;
  pbVar1 = local_1c;
  while( true ) {
    local_1c = pbVar1;
    bVar2 = *local_1c;
    pbVar1 = local_1c + 1;
    if (bVar2 == 0) break;
    if ((char)bVar2 < '\0') {
      if (((((bVar2 < 0xa1) || (bVar2 == 0xff)) || (*pbVar1 < 0xa1)) || (*pbVar1 == 0xff)) &&
         (((bVar2 != 0x8e || (*pbVar1 < 0xa1)) || (0xdf < *pbVar1)))) {
        if ((bVar2 != 0xa0) || (is_JIS == 0)) {
          is_JIS = is_JIS + 1;
          *local_18 = bVar2;
          local_18 = local_18 + 1;
        }
      }
      else {
        if (local_1e == 0) {
          local_1e = 0xff;
          strcpy((char *)local_18,toK);
          sVar3 = strlen((char *)local_18);
          local_18 = local_18 + sVar3;
        }
        if ((char)*pbVar1 < '\0') {
          *local_18 = bVar2 & 0x7f;
          local_18[1] = *pbVar1 & 0x7f;
          local_18 = local_18 + 2;
          pbVar1 = local_1c + 2;
        }
      }
    }
    else {
      if (local_1e != 0) {
        local_1e = ~local_1e;
        strcpy((char *)local_18,toA);
        sVar3 = strlen((char *)local_18);
        local_18 = local_18 + sVar3;
      }
      *local_18 = bVar2;
      local_18 = local_18 + 1;
    }
  }
  if (local_1e != 0) {
    strcpy((char *)local_18,toA);
    sVar3 = strlen((char *)local_18);
    local_18 = local_18 + sVar3;
  }
  if (local_18 != (byte *)0x0) {
    *local_18 = 0;
  }
  return dst;
}



// WARNING: Unknown calling convention

uchar * repairJIStoEUC(uchar *src,uchar **dstp)

{
  byte bVar1;
  byte bVar2;
  uchar *d;
  uchar *s;
  uchar ch2;
  uchar ch1;
  
  d = *dstp;
  s = src;
  while( true ) {
    bVar1 = *s;
    if ((bVar1 == 0) || (bVar2 = s[1], bVar2 == 0)) {
      return (uchar *)0x0;
    }
    s = s + 2;
    if ((bVar1 == 0x28) && ((bVar2 == 0x42 || (bVar2 == 0x4a)))) break;
    if ((((bVar1 < 0x21) || (0x7e < bVar1)) || (bVar2 < 0x21)) || (0x7e < bVar2)) {
      return (uchar *)0x0;
    }
    *d = bVar1 | 0x80;
    d[1] = bVar2 | 0x80;
    d = d + 2;
  }
  *dstp = d;
  return s;
}



// WARNING: Unknown calling convention

uchar * TO_EUC(uchar *jis,uchar *euc)

{
  byte *pbVar1;
  byte HI;
  bool bVar2;
  byte *pbVar3;
  byte *local_28;
  byte local_21;
  int local_18;
  uchar *ts;
  int is_JIS;
  int n8bits;
  uchar *d;
  
  TO_EUC::nje = TO_EUC::nje + 1;
  n8bits = 0;
  local_28 = jis;
  d = euc;
  local_21 = 0;
  local_18 = IS_SJIS_STR(jis);
  is_JIS = 0;
  pbVar3 = local_28;
LAB_081218be:
  do {
    while( true ) {
      do {
        local_28 = pbVar3;
        HI = *local_28;
        pbVar1 = local_28 + 1;
        if (HI == 0) {
          *d = '\0';
          return euc;
        }
        pbVar3 = pbVar1;
      } while (((HI == 0x80) || ((HI == 0xa0 && (is_JIS != 0)))) ||
              ((HI == 0x24 &&
               ((((local_21 == 0 && (repair_JIS != 0)) && ((*pbVar1 == 0x42 || (*pbVar1 == 0x40))))
                && (pbVar3 = repairJIStoEUC(local_28 + 2,&d), pbVar3 != (byte *)0x0))))));
      if (HI == 0x1b) break;
LAB_08121756:
      if ((char)HI < '\0') {
        n8bits = n8bits + 1;
      }
      if (((*pbVar1 < 0x40) || (*pbVar1 == 0x7f)) || (0xfc < *pbVar1)) {
        bVar2 = false;
      }
      else if ((HI < 0x81) || (0x9f < HI)) {
        if ((local_18 == 0) || ((HI < 0xe0 || (0xef < HI)))) {
          bVar2 = false;
        }
        else {
          bVar2 = true;
        }
      }
      else {
        local_18 = 1;
        bVar2 = true;
      }
      if (bVar2) {
        SJIS_TO_EUC1(HI,*pbVar1,d);
        d = d + 2;
        is_JIS = is_JIS + 1;
        pbVar3 = local_28 + 2;
      }
      else if (local_21 == 0) {
        if ((n8bits != 0) || ((pbVar3 = pbVar1, HI != 0xf && (HI != 0xe)))) {
          *d = HI;
          d = d + 1;
          pbVar3 = pbVar1;
        }
      }
      else if ((HI < 0x21) || (0x7e < HI)) {
        *d = HI;
        d = d + 1;
        pbVar3 = pbVar1;
        if (HI == 10) {
          local_21 = 0;
        }
      }
      else if ((((HI < 0x21) || (0x7e < HI)) || (*pbVar1 < 0x21)) || (0x7e < *pbVar1)) {
        *d = HI;
        d = d + 1;
        pbVar3 = pbVar1;
      }
      else {
        *d = local_21 | HI;
        d[1] = *pbVar1 | local_21;
        d = d + 2;
        pbVar3 = local_28 + 2;
      }
    }
    if (*pbVar1 == 0x24) {
      if ((local_28[2] != 0x42) && (local_28[2] != 0x40)) {
        local_21 = 0;
        goto LAB_08121756;
      }
      local_21 = 0x80;
      is_JIS = is_JIS + 1;
      pbVar3 = local_28 + 3;
      goto LAB_081218be;
    }
    if (*pbVar1 != 0x28) {
      if (*pbVar1 == 0x2c) {
        local_21 = 0;
      }
      goto LAB_08121756;
    }
    local_21 = 0;
    if (((local_28[2] != 0x42) && (local_28[2] != 0x4a)) && (local_28[2] != 0x48))
    goto LAB_08121756;
    pbVar3 = local_28 + 3;
  } while( true );
}



// WARNING: Unknown calling convention

int is_EUC_JP(uchar *euc)

{
  byte bVar1;
  byte bVar2;
  int ch2;
  int ch1;
  uchar *cp;
  
  cp = euc;
  do {
    bVar2 = *cp;
    if (bVar2 == 0) {
      return 1;
    }
    if ((bVar2 & 0x80) != 0) {
      bVar1 = cp[1];
      if ((bVar1 & 0x80) == 0) {
        return 0;
      }
      if (((((bVar2 & 0x7f) < 0x21) || ((bVar2 & 0x7f) == 0x7f)) || ((bVar1 & 0x7f) < 0x21)) ||
         ((bVar1 & 0x7f) == 0x7f)) {
        return 0;
      }
      cp = cp + 1;
    }
    cp = cp + 1;
  } while( true );
}



// WARNING: Unknown calling convention

void TO_SJIS(uchar *arg,uchar *sjis)

{
  size_t sVar1;
  uchar *euc_00;
  int iVar2;
  uchar *euc;
  
  sVar1 = strlen((char *)arg);
  euc_00 = (uchar *)malloc(sVar1 + 1);
  if (euc_00 == (uchar *)0x0) {
    outofmem("../../../WWW/Library/Implementation/SGML.c","TO_SJIS");
  }
  TO_EUC(arg,euc_00);
  iVar2 = is_EUC_JP(euc_00);
  if (iVar2 == 0) {
    strcpy((char *)sjis,(char *)arg);
  }
  else {
    EUC_TO_SJIS(euc_00,sjis);
  }
  free(euc_00);
  return;
}



// WARNING: Unknown calling convention

void TO_JIS(uchar *arg,uchar *jis)

{
  size_t sVar1;
  uchar *euc_00;
  uchar *euc;
  
  if (*arg == '\0') {
    *jis = '\0';
  }
  else {
    sVar1 = strlen((char *)arg);
    euc_00 = (uchar *)malloc(sVar1 + 1);
    if (euc_00 == (uchar *)0x0) {
      outofmem("../../../WWW/Library/Implementation/SGML.c","TO_JIS");
    }
    TO_EUC(arg,euc_00);
    is_EUC_JP(euc_00);
    EUC_TO_JIS(euc_00,jis,"\x1b$B","\x1b(B");
    free(euc_00);
  }
  return;
}



// WARNING: Unknown calling convention

void HTSwitchDTD(int new_flag)

{
  FILE *__stream;
  char *local_8;
  
  if ((WWW_TraceFlag != '\0') && (WWW_TraceFlag != '\0')) {
    if (new_flag == 0) {
      local_8 = "tagsoup";
    }
    else {
      local_8 = "strict";
    }
    __stream = TraceFP();
    fprintf((FILE *)__stream,"HTMLDTD: Copying %s DTD element info of size %d, %d * %d\n",local_8,
            0x1a08,0x77,0x38);
  }
  if (new_flag == 0) {
    memcpy(tags,tags_table0,0x1a08);
  }
  else {
    memcpy(tags,tags_table1,0x1a08);
  }
  return;
}



void HTStartAnchor(HTStructured_conflict *obj,char *name,char *href)

{
  int iVar1;
  int in_GS_OFFSET;
  char *href_local;
  char *name_local;
  HTStructured_conflict *obj_local;
  char *value [25];
  int i;
  BOOLEAN present [25];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  for (i = 0; i < 0x19; i = i + 1) {
    present[i] = '\0';
  }
  if ((name != (char *)0x0) && (*name != '\0')) {
    present[12] = '\x01';
    value[12] = name;
  }
  if (href != (char *)0x0) {
    present[6] = '\x01';
    value[6] = href;
  }
  (*obj->isa->start_element)(obj,0,present,value,-1,(char **)0x0);
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void HTStartAnchor5(HTStructured_conflict *obj,char *name,char *href,char *linktype,int tag_charset)

{
  int iVar1;
  int in_GS_OFFSET;
  char *linktype_local;
  char *href_local;
  char *name_local;
  HTStructured_conflict *obj_local;
  char *value [25];
  int i;
  BOOLEAN present [25];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  for (i = 0; i < 0x19; i = i + 1) {
    present[i] = '\0';
  }
  if ((name != (char *)0x0) && (*name != '\0')) {
    present[12] = '\x01';
    value[12] = name;
  }
  if ((href != (char *)0x0) && (*href != '\0')) {
    present[6] = '\x01';
    value[6] = href;
  }
  if ((linktype != (char *)0x0) && (*linktype != '\0')) {
    present[23] = '\x01';
    value[23] = linktype;
  }
  (*obj->isa->start_element)(obj,0,present,value,tag_charset,(char **)0x0);
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void HTStartIsIndex(HTStructured_conflict *obj,char *prompt,char *href)

{
  int iVar1;
  int in_GS_OFFSET;
  char *href_local;
  char *prompt_local;
  HTStructured_conflict *obj_local;
  char *value [9];
  int i;
  BOOLEAN present [9];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  for (i = 0; i < 9; i = i + 1) {
    present[i] = '\0';
  }
  if ((prompt != (char *)0x0) && (*prompt != '\0')) {
    present[6] = '\x01';
    value[6] = prompt;
  }
  if (href != (char *)0x0) {
    present[3] = '\x01';
    value[3] = href;
  }
  (*obj->isa->start_element)(obj,0x3e,present,value,-1,(char **)0x0);
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



// WARNING: Unknown calling convention

void HTChunkInit(HTChunk *ch,int grow)

{
  ch->data = (char *)0x0;
  ch->growby = grow;
  ch->size = 0;
  ch->allocated = 0;
  return;
}



// WARNING: Unknown calling convention

HTChunk * HTChunkCreate(int grow)

{
  HTChunk *ch_00;
  HTChunk *ch;
  
  ch_00 = (HTChunk *)calloc(1,0x18);
  if (ch_00 == (HTChunk *)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTChunk.c","creation of chunk");
  }
  HTChunkInit(ch_00,grow);
  return ch_00;
}



// WARNING: Unknown calling convention

HTChunk * HTChunkCreateMayFail(int grow,int failok)

{
  HTChunk *ch_00;
  HTChunk *ch;
  
  ch_00 = (HTChunk *)calloc(1,0x18);
  if (ch_00 == (HTChunk *)0x0) {
    if (failok != 0) {
      return (HTChunk *)0x0;
    }
    outofmem("../../../WWW/Library/Implementation/HTChunk.c","creation of chunk");
  }
  HTChunkInit(ch_00,grow);
  ch_00->failok = failok;
  return ch_00;
}



// WARNING: Unknown calling convention

HTChunk * HTChunkCreate2(int grow,size_t needed)

{
  int iVar1;
  HTChunk *ch_00;
  FILE *__stream;
  char *pcVar2;
  HTChunk *ch;
  
  ch_00 = (HTChunk *)calloc(1,0x18);
  if (ch_00 == (HTChunk *)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTChunk.c","HTChunkCreate2");
  }
  HTChunkInit(ch_00,grow);
  if (needed != 0) {
    ch_00->allocated = (needed - (needed - 1) % (uint)ch_00->growby) + ch_00->growby + -1;
    if (WWW_TraceFlag != '\0') {
      iVar1 = ch_00->allocated;
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTChunkCreate2: requested %d, allocate %d\n",needed,iVar1);
    }
    pcVar2 = (char *)calloc(ch_00->allocated,1);
    ch_00->data = pcVar2;
    if (ch_00->data == (char *)0x0) {
      outofmem("../../../WWW/Library/Implementation/HTChunk.c","HTChunkCreate2 data");
    }
  }
  return ch_00;
}



// WARNING: Unknown calling convention

void HTChunkClear(HTChunk *ch)

{
  if (ch->data != (char *)0x0) {
    free(ch->data);
    ch->data = (char *)0x0;
  }
  ch->size = 0;
  ch->allocated = 0;
  return;
}



// WARNING: Unknown calling convention

void HTChunkFree(HTChunk *ch)

{
  HTChunk *pHVar1;
  HTChunk *next;
  
  do {
    pHVar1 = ch->next;
    if (ch->data != (char *)0x0) {
      free(ch->data);
      ch->data = (char *)0x0;
    }
    if (ch != (HTChunk *)0x0) {
      free(ch);
    }
    ch = pHVar1;
  } while (pHVar1 != (HTChunk *)0x0);
  return;
}



// WARNING: Unknown calling convention

BOOLEAN HTChunkRealloc(HTChunk *ch,int growby)

{
  char *local_1c;
  char *data;
  
  ch->allocated = ch->allocated + growby;
  if (ch->data == (char *)0x0) {
    local_1c = (char *)calloc(ch->allocated,1);
  }
  else {
    local_1c = (char *)realloc(ch->data,ch->allocated);
  }
  if (local_1c == (char *)0x0) {
    if (ch->failok != 0) {
      HTChunkClear(ch);
      return '\0';
    }
    outofmem("../../../WWW/Library/Implementation/HTChunk.c","HTChunkRealloc");
  }
  else {
    ch->data = local_1c;
  }
  return '\x01';
}



void HTChunkPutc(HTChunk *ch,char c)

{
  int iVar1;
  BOOLEAN BVar2;
  char c_local;
  
  if ((ch->allocated <= ch->size) && (BVar2 = HTChunkRealloc(ch,ch->growby), BVar2 == '\0')) {
    return;
  }
  iVar1 = ch->size;
  ch->data[iVar1] = c;
  ch->size = iVar1 + 1;
  return;
}



HTChunk * HTChunkPutc2(HTChunk *ch,char c)

{
  int iVar1;
  HTChunk *local_1c;
  char c_local;
  HTChunk *chunk;
  
  if (ch->size < ch->allocated) {
    iVar1 = ch->size;
    ch->data[iVar1] = c;
    ch->size = iVar1 + 1;
    local_1c = ch;
  }
  else {
    local_1c = HTChunkCreateMayFail(ch->growby,ch->failok);
    ch->next = local_1c;
    HTChunkPutc(local_1c,c);
  }
  return local_1c;
}



// WARNING: Unknown calling convention

void HTChunkEnsure(HTChunk *ch,int needed)

{
  char *local_8;
  
  if (ch->allocated < needed) {
    ch->allocated = ((needed + -1) - (needed + -1) % ch->growby) + ch->growby;
    if (ch->data == (char *)0x0) {
      local_8 = (char *)calloc(ch->allocated,1);
    }
    else {
      local_8 = (char *)realloc(ch->data,ch->allocated);
    }
    ch->data = local_8;
    if (ch->data == (char *)0x0) {
      outofmem("../../../WWW/Library/Implementation/HTChunk.c","HTChunkEnsure");
    }
  }
  return;
}



// WARNING: Unknown calling convention

void HTChunkPutb(HTChunk *ch,char *b,int l)

{
  BOOLEAN BVar1;
  int growby;
  
  if (0 < l) {
    if ((ch->allocated < ch->size + l) &&
       (BVar1 = HTChunkRealloc(ch,(l - l % ch->growby) + ch->growby), BVar1 == '\0')) {
      return;
    }
    memcpy(ch->data + ch->size,b,l);
    ch->size = ch->size + l;
  }
  return;
}



// WARNING: Unknown calling convention

HTChunk * HTChunkPutb2(HTChunk *ch,char *b,int l)

{
  size_t __n;
  HTChunk *local_18;
  int m;
  HTChunk *chunk;
  
  if (l < 1) {
    local_18 = ch;
  }
  else if (ch->allocated < ch->size + l) {
    __n = ch->allocated - ch->size;
    memcpy(ch->data + ch->size,b,__n);
    ch->size = ch->size + __n;
    local_18 = HTChunkCreateMayFail(ch->growby,ch->failok);
    ch->next = local_18;
    HTChunkPutb(local_18,b + __n,l - __n);
  }
  else {
    memcpy(ch->data + ch->size,b,l);
    ch->size = ch->size + l;
    local_18 = ch;
  }
  return local_18;
}



// WARNING: Unknown calling convention

void HTChunkPutUtf8Char(HTChunk *ch,UCode_t code)

{
  int iVar1;
  byte bVar2;
  byte bVar3;
  byte bVar4;
  byte bVar5;
  BOOLEAN BVar6;
  int local_18;
  int growby;
  int utflen;
  
  if (code < 0x80) {
    utflen = 1;
  }
  else if (code < 0x800) {
    utflen = 2;
  }
  else if (code < 0x10000) {
    utflen = 3;
  }
  else if (code < 0x200000) {
    utflen = 4;
  }
  else if (code < 0x4000000) {
    utflen = 5;
  }
  else {
    utflen = 6;
  }
  if (ch->allocated < ch->size + utflen) {
    local_18 = ch->growby;
    if (local_18 < utflen) {
      local_18 = utflen;
    }
    BVar6 = HTChunkRealloc(ch,local_18);
    if (BVar6 == '\0') {
      return;
    }
  }
  bVar2 = (byte)(code >> 6);
  bVar3 = (byte)(code >> 0xc);
  bVar4 = (byte)(code >> 0x12);
  bVar5 = (byte)((uint)code >> 0x18);
  switch(utflen) {
  case 0:
    goto switchD_081224f6_caseD_0;
  case 1:
    iVar1 = ch->size;
    ch->data[iVar1] = (byte)code;
    ch->size = iVar1 + 1;
    return;
  case 2:
    iVar1 = ch->size;
    ch->data[iVar1] = bVar2 | 0xc0;
    ch->size = iVar1 + 1;
    break;
  case 3:
    iVar1 = ch->size;
    ch->data[iVar1] = bVar3 | 0xe0;
    ch->size = iVar1 + 1;
    break;
  case 4:
    iVar1 = ch->size;
    ch->data[iVar1] = bVar4 | 0xf0;
    ch->size = iVar1 + 1;
    break;
  case 5:
    iVar1 = ch->size;
    ch->data[iVar1] = bVar5 | 0xf8;
    ch->size = iVar1 + 1;
    break;
  case 6:
    iVar1 = ch->size;
    ch->data[iVar1] = (char)bVar5 >> 6 | 0xfc;
    ch->size = iVar1 + 1;
  }
  switch(utflen) {
  case 6:
    iVar1 = ch->size;
    ch->data[iVar1] = bVar5 & 0x3f | 0x80;
    ch->size = iVar1 + 1;
  case 5:
    iVar1 = ch->size;
    ch->data[iVar1] = bVar4 & 0x3f | 0x80;
    ch->size = iVar1 + 1;
  case 4:
    iVar1 = ch->size;
    ch->data[iVar1] = bVar3 & 0x3f | 0x80;
    ch->size = iVar1 + 1;
  case 3:
    iVar1 = ch->size;
    ch->data[iVar1] = bVar2 & 0x3f | 0x80;
    ch->size = iVar1 + 1;
  case 2:
    iVar1 = ch->size;
    ch->data[iVar1] = (byte)code & 0x3f | 0x80;
    ch->size = iVar1 + 1;
  }
switchD_081224f6_caseD_0:
  return;
}



// WARNING: Unknown calling convention

void HTChunkTerminate(HTChunk *ch)

{
  HTChunkPutc(ch,'\0');
  return;
}



// WARNING: Unknown calling convention

void HTChunkPuts(HTChunk *ch,char *s)

{
  int iVar1;
  BOOLEAN BVar2;
  char *p;
  
  if (s != (char *)0x0) {
    for (p = s; *p != '\0'; p = p + 1) {
      if ((ch->allocated <= ch->size) && (BVar2 = HTChunkRealloc(ch,ch->growby), BVar2 == '\0')) {
        return;
      }
      iVar1 = ch->size;
      ch->data[iVar1] = *p;
      ch->size = iVar1 + 1;
    }
  }
  return;
}



// WARNING: Unknown calling convention

HTChunk * HTChunkPuts2(HTChunk *ch,char *s)

{
  int iVar1;
  HTChunk *ch_00;
  HTChunk *chunk;
  char *p;
  
  if (s != (char *)0x0) {
    for (p = s; *p != '\0'; p = p + 1) {
      if (ch->allocated <= ch->size) {
        ch_00 = HTChunkCreateMayFail(ch->growby,ch->failok);
        ch->next = ch_00;
        HTChunkPuts(ch_00,p);
        return ch_00;
      }
      iVar1 = ch->size;
      ch->data[iVar1] = *p;
      ch->size = iVar1 + 1;
    }
  }
  return ch;
}



// WARNING: Unknown calling convention

void HTPlain_getChartransInfo(HTStream_conflict3 *me,HTParentAnchor *anchor)

{
  int iVar1;
  LYUCcharset *pLVar2;
  int chndl;
  
  if (me->inUCLYhndl < 0) {
    HTAnchor_copyUCInfoStage(anchor,1,0,4);
    iVar1 = HTAnchor_getUCLYhndl(anchor,1);
    me->inUCLYhndl = iVar1;
  }
  if (me->outUCLYhndl < 0) {
    chndl = HTAnchor_getUCLYhndl(anchor,3);
    if (chndl < 0) {
      chndl = current_char_set;
      HTAnchor_setUCInfoStage(anchor,current_char_set,3,1);
    }
    HTAnchor_setUCInfoStage(anchor,chndl,3,1);
    iVar1 = HTAnchor_getUCLYhndl(anchor,3);
    me->outUCLYhndl = iVar1;
  }
  pLVar2 = HTAnchor_getUCInfoStage(anchor,1);
  me->inUCI = pLVar2;
  pLVar2 = HTAnchor_getUCInfoStage(anchor,3);
  me->outUCI = pLVar2;
  return;
}



void HTPlain_put_character(HTStream_conflict3 *me,char c)

{
  char c_local;
  UCode_t value;
  char *name;
  int diff;
  int i;
  int low;
  int high;
  int len;
  
  c_local = c;
  if ((HTPlain_lastraw == 0xd) && (c == '\n')) {
    HTPlain_lastraw = -1;
  }
  else if ((c == '\b') || ((c == '_' || (HTPlain_bs_pending != 0)))) {
    HTPlain_write(me,&c_local,1);
  }
  else {
    HTPlain_lastraw = (int)(byte)c;
    if (c == '\r') {
      HText_appendCharacter(me->text,L'\n');
    }
    else if ((byte)c < 0x7f) {
      if (HTCJK == NOCJK) {
        if ((((byte)c < 0x7f) || (0xa0 < (byte)c)) || (HTPassHighCtrlRaw == '\0')) {
          if (c == -0x60) {
            HText_appendCharacter(me->text,L' ');
          }
          else if (c != -0x53) {
            if ((((byte)c < 0x20) || (0x7e < (byte)c)) && ((c != '\n' && (c != '\t')))) {
              if (0xa0 < (byte)c) {
                if (((HTPassEightBitRaw == '\0') && (me->outUCLYhndl != LATIN1)) &&
                   ((me->outUCI->enc & 2U) == 0)) {
                  diff = 1;
                  value = (byte)c - 0xa0;
                  name = HTMLGetEntityName(value);
                  len = strlen(name);
                  low = 0;
                  high = 0x70;
                  while (low < high) {
                    i = (high - low) / 2 + low;
                    diff = strncmp(entities[i],name,len);
                    if (diff == 0) {
                      HText_appendText(me->text,LYCharSets[me->outUCLYhndl][i]);
                      break;
                    }
                    if (diff < 0) {
                      low = i + 1;
                    }
                    else {
                      high = i;
                    }
                  }
                  if (diff != 0) {
                    HText_appendCharacter(me->text,(int)c_local);
                  }
                }
                else {
                  HText_appendCharacter(me->text,(int)c);
                }
              }
            }
            else {
              HText_appendCharacter(me->text,(int)c);
            }
          }
        }
        else {
          HText_appendCharacter(me->text,(int)c);
        }
      }
      else {
        HText_appendCharacter(me->text,(int)c);
      }
    }
    else {
      HTPlain_write(me,&c_local,1);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void HTPlain_put_string(HTStream_conflict3 *me,char *s)

{
  char *p;
  
  if (s != (char *)0x0) {
    for (p = s; *p != '\0'; p = p + 1) {
      HTPlain_put_character(me,*p);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void HTPlain_write(HTStream_conflict3 *me,char *s,int l)

{
  BOOLEAN BVar1;
  FILE *pFVar2;
  uint uVar3;
  int iVar4;
  int iVar5;
  bool bVar6;
  UCode_t uck;
  UCode_t code;
  uint c_unsign;
  char *e;
  char *p;
  char saved_char_in;
  BOOLEAN chk;
  char c;
  
  uck = -1;
  p = s;
  do {
    if (s + l <= p) {
      return;
    }
    if (*p == '\b') {
      if (((HTPlain_lastraw < 0x20) || (HTPlain_lastraw == 0xd)) || (HTPlain_lastraw == 10)) {
LAB_08122c7c:
        if (1 < HTPlain_bs_pending) {
          HText_appendCharacter(me->text,L'_');
        }
        HTPlain_bs_pending = 0;
        goto LAB_08122cd8;
      }
      if (HTPlain_bs_pending == 0) {
        HTPlain_bs_pending = 1;
      }
      else {
        if (HTPlain_bs_pending != 2) goto LAB_08122c7c;
        HTPlain_bs_pending = 3;
      }
    }
    else {
      if ((*p == '_') && (HTPlain_bs_pending == 0)) {
        HTPlain_bs_pending = 2;
        HTPlain_lastraw = (int)(byte)*p;
        goto LAB_0812380c;
      }
LAB_08122cd8:
      if ((HTPlain_lastraw == 0xd) && (*p == '\n')) {
        HTPlain_lastraw = -1;
      }
      else {
        if ((HTPlain_bs_pending != 0) &&
           ((((byte)*p < 0x20 || (*p == '\r')) ||
            ((*p == '\n' ||
             ((((uint)(byte)*p != HTPlain_lastraw && (HTPlain_lastraw != 0x5f)) && (*p != '_')))))))
           ) {
          if (1 < HTPlain_bs_pending) {
            HText_appendCharacter(me->text,L'_');
          }
          goto LAB_08122e03;
        }
        if (HTPlain_bs_pending == 1) {
          HTPlain_bs_pending = 0;
        }
        else if (HTPlain_bs_pending == 3) {
          if (*p == '_') {
            HTPlain_bs_pending = 2;
          }
          else {
LAB_08122e03:
            HTPlain_bs_pending = 0;
            HTPlain_lastraw = (int)(byte)*p;
            if (*p == '\r') {
              HText_appendCharacter(me->text,L'\n');
            }
            else {
              c = *p;
              c_unsign = (uint)(byte)c;
              saved_char_in = '\0';
              code = c_unsign;
              if ((me->T).decode_utf8 != '\0') {
                if (0x7f < c_unsign) {
                  if ((me->utf_count < '\x01') || (((int)c & 0xc0U) != 0x80)) {
                    *me->utf_buf_p = c;
                    me->utf_buf_p = me->utf_buf + 1;
                    if (((int)*p & 0xe0U) == 0xc0) {
                      me->utf_count = '\x01';
                      me->utf_char = (int)c & 0x1f;
                    }
                    else if (((int)*p & 0xf0U) == 0xe0) {
                      me->utf_count = '\x02';
                      me->utf_char = (int)c & 0xf;
                    }
                    else if (((int)*p & 0xf8U) == 0xf0) {
                      me->utf_count = '\x03';
                      me->utf_char = (int)c & 7;
                    }
                    else if (((int)*p & 0xfcU) == 0xf8) {
                      me->utf_count = '\x04';
                      me->utf_char = (int)c & 3;
                    }
                    else if (((int)*p & 0xfeU) == 0xfc) {
                      me->utf_count = '\x05';
                      me->utf_char = (int)c & 1;
                    }
                    else {
                      me->utf_count = '\0';
                      *me->utf_buf_p = '\0';
                      me->utf_buf_p = me->utf_buf;
                    }
                  }
                  else {
                    me->utf_char = me->utf_char << 6 | (int)c & 0x3fU;
                    me->utf_count = me->utf_count + -1;
                    *me->utf_buf_p = c;
                    me->utf_buf_p = me->utf_buf_p + 1;
                    if (me->utf_count == '\0') {
                      *me->utf_buf_p = '\0';
                      code = me->utf_char;
                      if ((0 < code) && (code < 0x100)) {
                        c = (char)code;
                        c_unsign = code & 0xff;
                      }
                      goto LAB_0812307d;
                    }
                  }
                  goto LAB_0812380c;
                }
                if ('\0' < me->utf_count) {
                  me->utf_count = '\0';
                  me->utf_buf[0] = '\0';
                  me->utf_buf_p = me->utf_buf;
                }
              }
LAB_0812307d:
              if (((me->T).decode_utf8 == '\0') || (-1 < *p)) {
                if (((me->T).trans_to_uni == '\0') ||
                   ((code < LYlowest_eightbit[me->inUCLYhndl] &&
                    (((0x1f < code || (code == 0)) || ((me->T).trans_C0_to_uni == '\0')))))) {
                  if (((code < 0x20) && (code != 0)) && ((me->T).trans_C0_to_uni != '\0')) {
                    if (((me->T).trans_from_uni == '\0') ||
                       ((code = UCTransToUni(c,me->inUCLYhndl), code < 0x20 &&
                        (((me->T).transp == '\0' ||
                         (code = UCTransToUni(c,me->inUCLYhndl), code < 1)))))) {
                      uck = -1;
                      if ((me->T).transp != '\0') {
                        uck = UCTransCharStr(replace_buf,0x3c,c,me->inUCLYhndl,me->inUCLYhndl,0);
                      }
                      if (((me->T).transp == '\0') || (uck < 0)) {
                        uck = UCTransCharStr(replace_buf,0x3c,c,me->inUCLYhndl,me->outUCLYhndl,1);
                      }
                      if (uck == 0) goto LAB_0812380c;
                      if (uck < 0) {
                        me->utf_buf[0] = '\0';
                      }
                      else {
                        c = replace_buf[0];
                        if ((replace_buf[0] != '\0') && (replace_buf[1] != '\0')) {
                          HText_appendText(me->text,replace_buf);
                          goto LAB_0812380c;
                        }
                      }
                      me->utf_buf[0] = '\0';
                      code = (UCode_t)(byte)c;
                    }
                    else {
                      saved_char_in = c;
                      if (code < 0x100) {
                        c = (char)code;
                        c_unsign = code & 0xff;
                      }
                    }
                  }
                  else {
                    me->utf_buf[0] = '\0';
                    code = (UCode_t)(byte)c;
                  }
                }
                else {
                  code = UCTransToUni(c,me->inUCLYhndl);
                  if ((0 < code) && (saved_char_in = c, code < 0x100)) {
                    c = (char)code;
                    c_unsign = code & 0xff;
                  }
                }
              }
              if (HTCJK == NOCJK) {
                if ((((code < 0x7f) || (0xa0 < code)) ||
                    (((me->T).transp == '\0' && (code < LYlowest_eightbit[me->inUCLYhndl])))) ||
                   ((me->T).pass_160_173_raw == '\0')) {
                  if ((code == 0xad) && ((me->T).pass_160_173_raw != '\0')) {
                    HText_appendCharacter(me->text,(int)c);
                  }
                  else if (code == 0xa0) {
                    HText_appendCharacter(me->text,L' ');
                  }
                  else if (code != 0xad) {
                    if ((((code < 0x20) || (0x7e < code)) &&
                        (((HTPassEightBitRaw == '\0' &&
                          (((me->T).do_8bitraw == '\0' || ((me->T).trans_from_uni != '\0')))) ||
                         ((int)c < LYlowest_eightbit[me->outUCLYhndl])))) &&
                       ((*p != '\n' && (*p != '\t')))) {
                      if (((code == 0x2002) || (code == 0x2003)) || (code == 0x2009)) {
                        HText_appendCharacter(me->text,L' ');
                      }
                      else if (((me->T).use_raw_char_in == '\0') || (saved_char_in == '\0')) {
                        if (((me->T).trans_from_uni == '\0') || (code < 0xa0)) {
                          bVar6 = false;
                        }
                        else {
                          bVar6 = true;
                        }
                        if (((bVar6) && (uck = UCTransUniChar(code,me->outUCLYhndl), 0x1f < uck)) &&
                           (uck < 0x100)) {
                          if (WWW_TraceFlag != '\0') {
                            pFVar2 = TraceFP();
                            fprintf((FILE *)pFVar2,"UCTransUniChar returned 0x%.2lX:\'%c\'.\n",uck,
                                    (int)(char)uck);
                          }
                          HText_appendCharacter(me->text,(int)(char)uck);
                        }
                        else {
                          if ((bVar6) &&
                             ((uck == -4 ||
                              ((((me->T).repl_translated_C0 != '\0' && (0 < uck)) && (uck < 0x20))))
                             )) {
                            uVar3 = UCTransUniCharStr(replace_buf,0x3c,code,me->outUCLYhndl,0);
                            uck = -((int)~uVar3 >> 0x1f);
                            if (uck != 0) {
                              HText_appendText(me->text,replace_buf);
                              goto LAB_0812380c;
                            }
                          }
                          if (((bVar6) && (0x7f < code)) && ((me->T).output_utf8 != '\0')) {
                            if (me->utf_buf[0] == '\0') {
                              BVar1 = UCConvertUniToUtf8(code,replace_buf);
                              if (BVar1 == '\0') {
                                sprintf(replace_buf,"U%.2lX",code);
                                HText_appendText(me->text,replace_buf);
                              }
                              else {
                                HText_appendText(me->text,replace_buf);
                              }
                            }
                            else {
                              HText_appendText(me->text,me->utf_buf);
                              me->utf_buf[0] = '\0';
                              me->utf_buf_p = me->utf_buf;
                            }
                          }
                          else if (((c_unsign == 0) ||
                                   (LYlowest_eightbit[me->outUCLYhndl] <= (int)c_unsign)) &&
                                  (((me->T).trans_from_uni == '\0' || (HTPassEightBitRaw != '\0'))))
                          {
                            if ((c_unsign != 0) && (c_unsign < 0x100)) {
                              HText_appendCharacter(me->text,(int)c);
                            }
                          }
                          else {
                            iVar5 = me->outUCLYhndl;
                            iVar4 = UCGetLYhndl_byMIME("us-ascii");
                            bVar6 = iVar5 != iVar4;
                            if (bVar6) {
                              iVar5 = UCGetLYhndl_byMIME("us-ascii");
                              uck = UCTransUniChar(code,iVar5);
                              if ((0x1f < uck) && (uck < 0x7f)) {
                                HText_appendCharacter(me->text,(int)(char)uck);
                                goto LAB_0812380c;
                              }
                            }
                            if ((bVar6) && (uck == -4)) {
                              iVar5 = UCGetLYhndl_byMIME("us-ascii");
                              uVar3 = UCTransUniCharStr(replace_buf,0x3c,code,iVar5,0);
                              uck = -((int)~uVar3 >> 0x1f);
                              if (uck != 0) {
                                HText_appendText(me->text,replace_buf);
                                goto LAB_0812380c;
                              }
                            }
                            if ((code == 0x200c) || (code == 0x200d)) {
                              if (WWW_TraceFlag != '\0') {
                                pFVar2 = TraceFP();
                                fprintf((FILE *)pFVar2,"HTPlain_write: Ignoring \'%ld\'.\n",code);
                              }
                            }
                            else if (((code == 0x200e) || (code == 0x200f)) &&
                                    (WWW_TraceFlag != '\0')) {
                              pFVar2 = TraceFP();
                              fprintf((FILE *)pFVar2,"HTPlain_write: Ignoring \'%ld\'.\n",code);
                            }
                          }
                        }
                      }
                      else {
                        HText_appendCharacter(me->text,(int)saved_char_in);
                      }
                    }
                    else {
                      HText_appendCharacter(me->text,(int)c);
                    }
                  }
                }
                else {
                  HText_appendCharacter(me->text,(int)c);
                }
              }
              else {
                HText_appendCharacter(me->text,(int)c);
              }
            }
          }
        }
        else if ((HTPlain_bs_pending != 2) || (HText_appendCharacter(me->text,L'_'), *p != '_'))
        goto LAB_08122e03;
      }
    }
LAB_0812380c:
    p = p + 1;
  } while( true );
}



// WARNING: Unknown calling convention

void HTPlain_free(HTStream_conflict3 *me)

{
  if (1 < HTPlain_bs_pending) {
    HText_appendCharacter(me->text,L'_');
  }
  if (me != (HTStream_conflict3 *)0x0) {
    free(me);
  }
  return;
}



// WARNING: Unknown calling convention

void HTPlain_abort(HTStream_conflict3 *me,HTError e)

{
  HTPlain_free(me);
  return;
}



// WARNING: Unknown calling convention

HTStream_conflict3 *
HTPlainPresent(HTPresentation_conflict1 *pres,HTParentAnchor *anchor,HTStream_conflict3 *sink)

{
  HTStream_conflict3 *me_00;
  int iVar1;
  LYUCcharset *p_out;
  HText *pHVar2;
  HTStyle *style;
  HTStream_conflict3 *me;
  
  me_00 = (HTStream_conflict3 *)malloc(0x38);
  if (me_00 == (HTStream_conflict3 *)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTPlain.c","HTPlain_new");
  }
  me_00->isa = &HTPlain;
  HTPlain_lastraw = -1;
  me_00->utf_count = '\0';
  me_00->utf_char = 0;
  me_00->utf_buf[7] = '\0';
  me_00->utf_buf[6] = me_00->utf_buf[7];
  me_00->utf_buf[0] = me_00->utf_buf[6];
  me_00->utf_buf_p = me_00->utf_buf;
  iVar1 = HTAnchor_getUCLYhndl(anchor,3);
  me_00->outUCLYhndl = iVar1;
  iVar1 = HTAnchor_getUCLYhndl(anchor,1);
  me_00->inUCLYhndl = iVar1;
  HTPlain_getChartransInfo(me_00,anchor);
  p_out = HTAnchor_getUCInfoStage(anchor,3);
  UCSetTransParams(&me_00->T,me_00->inUCLYhndl,me_00->inUCI,me_00->outUCLYhndl,p_out);
  pHVar2 = HText_new(anchor);
  me_00->text = pHVar2;
  style = LYstyles(0x75);
  HText_setStyle(me_00->text,style);
  HText_beginAppend(me_00->text);
  return me_00;
}



// WARNING: Unknown calling convention

void flush_breaks(HTStructured_conflict1 *me)

{
  int i;
  
  for (i = 0; i < 0x15; i = i + 1) {
    me->line_break[i] = (char *)0x0;
  }
  return;
}



// WARNING: Unknown calling convention

void HTMLGen_flush(HTStructured_conflict1 *me)

{
  (*(me->targetClass).put_block)(me->target,me->buffer,(int)me->write_pointer - (int)me->buffer);
  me->write_pointer = me->buffer;
  flush_breaks(me);
  me->cleanness = 0;
  me->delete_line_break_char[0] = '\0';
  return;
}



// WARNING: Unknown calling convention

void do_cstyle_flush(HTStructured_conflict1 *me)

{
  if ((me->text == (HText *)0x0) && (LYPreparsedSource != '\0')) {
    me->text = HTMainText;
  }
  if (me->text != (HText *)0x0) {
    HTMLGen_flush(me);
  }
  return;
}



void allow_break(HTStructured_conflict1 *me,int new_cleanness,BOOLEAN dlbc)

{
  char *local_c;
  BOOLEAN dlbc_local;
  
  dlbc_local = dlbc;
  if ((dlbc != '\0') && (me->write_pointer == me->buffer)) {
    dlbc_local = '\0';
  }
  if (dlbc_local == '\0') {
    local_c = me->write_pointer;
  }
  else {
    local_c = me->write_pointer + -1;
  }
  me->line_break[new_cleanness] = local_c;
  me->delete_line_break_char[new_cleanness] = dlbc_local;
  if ((me->cleanness <= new_cleanness) &&
     ((me->overflowed != '\0' || (me->buffer < me->line_break[new_cleanness])))) {
    me->cleanness = new_cleanness;
  }
  return;
}



void HTMLGen_put_character(HTStructured_conflict1 *me,char c)

{
  char cVar1;
  char *pcVar2;
  char c_local;
  char delims [5];
  int i;
  char *q;
  char *p_1;
  char *saved;
  char *p;
  int new_cleanness;
  char line_break_char;
  
  c_local = c;
  if (((me->escape_specials != '\0') && ((byte)c < 0x20)) &&
     ((c == '\x01' || ((c == '\x02' || (c == '\a')))))) {
    HTMLGen_put_character(me,'&');
    HTMLGen_put_character(me,'#');
    HTMLGen_put_character(me,'x');
    if (c == '\x02') {
      HTMLGen_put_character(me,'2');
      HTMLGen_put_character(me,'0');
      HTMLGen_put_character(me,'0');
      HTMLGen_put_character(me,'2');
    }
    else if (c == '\a') {
      HTMLGen_put_character(me,'A');
      HTMLGen_put_character(me,'D');
    }
    else if (c == '\x01') {
      HTMLGen_put_character(me,'A');
      HTMLGen_put_character(me,'0');
    }
    c_local = ';';
  }
  pcVar2 = me->write_pointer;
  *pcVar2 = c_local;
  me->write_pointer = pcVar2 + 1;
  if (c_local == '\n') {
    HTMLGen_flush(me);
  }
  else {
    if ((me->preformatted == '\0') && ((c_local == ' ' || (c_local == '\t')))) {
      new_cleanness = 3;
      if (me->buffer + 1 < me->write_pointer) {
        memcpy(delims,&DAT_0818b340,5);
        pcVar2 = strchr(delims,(int)me->write_pointer[-2]);
        if (pcVar2 != (char *)0x0) {
          new_cleanness = (int)(pcVar2 + (6 - (int)delims));
        }
        if (me->in_attrval == '\0') {
          new_cleanness = new_cleanness + 10;
        }
      }
      allow_break(me,new_cleanness,'\x01');
    }
    if ((me->buffer + me->buffer_maxchars <= me->write_pointer) ||
       ((me->overflowed != '\0' && (me->cleanness != 0)))) {
      if (me->cleanness == 0) {
        (*(me->targetClass).put_block)(me->target,me->buffer,me->buffer_maxchars);
        me->write_pointer = me->buffer;
        flush_breaks(me);
        me->overflowed = '\x01';
      }
      else {
        cVar1 = *me->line_break[me->cleanness];
        saved = me->line_break[me->cleanness];
        if (me->delete_line_break_char[me->cleanness] != '\0') {
          saved = saved + 1;
        }
        *me->line_break[me->cleanness] = '\n';
        (*(me->targetClass).put_block)
                  (me->target,me->buffer,
                   (int)(me->line_break[me->cleanness] + (1 - (int)me->buffer)));
        *me->line_break[me->cleanness] = cVar1;
        q = me->buffer;
        for (p_1 = saved; p_1 < me->write_pointer; p_1 = p_1 + 1) {
          *q = *p_1;
          q = q + 1;
        }
        me->cleanness = 0;
        for (i = 0; i < 0x15; i = i + 1) {
          if ((me->line_break[i] == (char *)0x0) || (me->line_break[i] <= saved)) {
            me->line_break[i] = (char *)0x0;
          }
          else {
            me->line_break[i] = me->line_break[i] + (0x20 - (int)saved) + (int)(me->buffer + -0x20);
            me->cleanness = i;
          }
        }
        me->delete_line_break_char[0] = '\0';
        me->write_pointer = me->write_pointer + (int)me + (0x20 - (int)saved);
        me->overflowed = '\0';
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

void HTMLGen_put_string(HTStructured_conflict1 *me,char *s)

{
  char *p;
  
  for (p = s; *p != '\0'; p = p + 1) {
    HTMLGen_put_character(me,*p);
  }
  return;
}



// WARNING: Unknown calling convention

void HTMLGen_write(HTStructured_conflict1 *me,char *s,int l)

{
  char *p;
  
  for (p = s; p < s + l; p = p + 1) {
    HTMLGen_put_character(me,*p);
  }
  return;
}



// WARNING: Unknown calling convention

int HTMLGen_start_element
              (HTStructured_conflict1 *me,int element_number,BOOLEAN *present,char **value,
              int charset,char **insert)

{
  size_t sVar1;
  FILE *pFVar2;
  char *pcVar3;
  int iVar4;
  wchar_t wVar5;
  int iVar6;
  BOOLEAN local_3d;
  char *p;
  int hcd;
  char *rp;
  int len;
  char *title_tmp;
  char *title;
  HTTag *tag;
  int i;
  BOOLEAN had_attr;
  BOOLEAN was_preformatted;
  
  was_preformatted = me->preformatted;
  tag = tags + element_number;
  title = (char *)0x0;
  title_tmp = (char *)0x0;
  if (LYPreparsedSource != '\0') {
    HTSprintf(&Style_className,";%s",tags[element_number].name);
    strcpy(myHash,tags[element_number].name);
    if (class_string[0] != '\0') {
      sVar1 = strlen(myHash);
      sprintf(myHash + sVar1,".%.*s",0x7e - sVar1,class_string);
      HTSprintf(&Style_className,".%s",class_string);
    }
    class_string[0] = '\0';
    strtolower(myHash);
    hcode = hash_code(myHash);
    strtolower(Style_className);
    iVar6 = hcode;
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
      pFVar2 = TraceFP();
      fprintf((FILE *)pFVar2,"CSSTRIM:%s -> %d",myHash,iVar6);
      if (hashStyles[hcode].code == hcode) {
        iVar4 = hashStyles[hcode].color;
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2," ca=%d\n",iVar4,iVar6);
      }
      else {
        pcVar3 = strrchr(myHash,0x2e);
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2," (undefined) %s\n",myHash,iVar6);
        if (pcVar3 != (char *)0x0) {
          *pcVar3 = '\0';
          iVar4 = hash_code(myHash);
          pFVar2 = TraceFP();
          iVar6 = iVar4;
          fprintf((FILE *)pFVar2,"CSS:%s -> %d",myHash,iVar4);
          if (hashStyles[iVar4].code == iVar4) {
            iVar4 = hashStyles[iVar4].color;
            pFVar2 = TraceFP();
            fprintf((FILE *)pFVar2," ca=%d\n",iVar4,iVar6);
          }
          else {
            pFVar2 = TraceFP();
            fprintf((FILE *)pFVar2," (undefined) %s\n",myHash,iVar6);
          }
        }
      }
    }
    if (L'\xfffffffe' < displayStyles[element_number + 8].color) {
      if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
        pcVar3 = tags[element_number].name;
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2,"CSSTRIM: start_element: top <%s>\n",pcVar3);
      }
      do_cstyle_flush(me);
      _internal_HTC(me->text,hcode,L'\x01');
    }
  }
  me->preformatted = '\x01';
  HTMLGen_put_character(me,'<');
  HTMLGen_put_string(me,tag->name);
  if (present != (BOOLEAN *)0x0) {
    had_attr = '\0';
    for (i = 0; i < tag->number_of_attributes; i = i + 1) {
      if (present[i] != '\0') {
        had_attr = '\x01';
        HTMLGen_put_character(me,' ');
        allow_break(me,0xb,'\x01');
        if ((((LYPreparsedSource != '\0') && (element_number == 0x45)) && (title == (char *)0x0)) &&
           ((((present[1] != '\0' && (value != (char **)0x0)) &&
             ((*value[1] != '\0' && (present[9] == '\0')))) &&
            ((present[8] != '\0' || (present[3] != '\0')))))) {
          if ((present[0xc] != '\0') && (*value[0xc] != '\0')) {
            HTSACopy(&title,value[0xc]);
            LYTrimHead(title);
            LYTrimTail(title);
          }
          if (((title == (char *)0x0) || (*title == '\0')) && (present[8] != '\0')) {
            HTSACopy(&title,value[8]);
          }
          if ((title != (char *)0x0) && (*title != '\0')) {
            HTSprintf0(&title_tmp,"link.%s.%s",value[1],title);
            pcVar3 = title_tmp;
            if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
              pFVar2 = TraceFP();
              fprintf((FILE *)pFVar2,"CSSTRIM:link=%s\n",pcVar3);
            }
            do_cstyle_flush(me);
            wVar5 = hash_code(title_tmp);
            _internal_HTC(me->text,wVar5,L'\x01');
          }
        }
        HTMLGen_put_string(me,tag->attributes[i].name);
        if (value[i] != (char *)0x0) {
          me->preformatted = was_preformatted;
          me->in_attrval = '\x01';
          pcVar3 = strchr(value[i],0x22);
          if (pcVar3 == (char *)0x0) {
            HTMLGen_put_string(me,"=\"");
            HTMLGen_put_string(me,value[i]);
            HTMLGen_put_character(me,'\"');
          }
          else {
            pcVar3 = strchr(value[i],0x27);
            if (pcVar3 == (char *)0x0) {
              HTMLGen_put_string(me,"=\'");
              HTMLGen_put_string(me,value[i]);
              HTMLGen_put_character(me,'\'');
            }
            else {
              HTMLGen_put_string(me,"=\"");
              for (p = value[i]; *p != '\0'; p = p + 1) {
                if (*p == '\"') {
                  HTMLGen_put_string(me,"&#34;");
                }
                else {
                  HTMLGen_put_character(me,*p);
                }
              }
              HTMLGen_put_character(me,'\"');
            }
          }
          me->preformatted = '\x01';
          me->in_attrval = '\0';
        }
      }
    }
    if (((had_attr != '\0') && (LYPreparsedSource != '\0')) && (element_number == 0x45)) {
      if ((title != (char *)0x0) && (*title != '\0')) {
        do_cstyle_flush(me);
        wVar5 = hash_code(title_tmp);
        _internal_HTC(me->text,wVar5,L'\0');
        if (title_tmp != (char *)0x0) {
          free(title_tmp);
          title_tmp = (char *)0x0;
        }
      }
      if (title != (char *)0x0) {
        free(title);
        title = (char *)0x0;
      }
    }
    if (had_attr != '\0') {
      allow_break(me,0xc,'\0');
    }
  }
  HTMLGen_put_string(me,">");
  if (element_number == 0x56) {
    local_3d = '\x01';
  }
  else {
    local_3d = was_preformatted;
  }
  me->preformatted = local_3d;
  if ((me->preformatted == '\0') && (tag->contents != SGML_EMPTY)) {
    if (tags[element_number].contents == SGML_ELEMENT) {
      allow_break(me,0xf,'\0');
    }
    else {
      allow_break(me,2,'\0');
    }
  }
  if (((LYPreparsedSource != '\0') && (tags[element_number].contents == SGML_EMPTY)) &&
     ((tags[element_number].flags & 0x10U) == 0)) {
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
      pFVar2 = TraceFP();
      fprintf((FILE *)pFVar2,"STYLE:begin_element:ending EMPTY element style\n");
    }
    do_cstyle_flush(me);
    _internal_HTC(me->text,hcode,L'\0');
    TrimColorClass(tags[element_number].name,Style_className,&hcode);
  }
  if ((element_number == 0x4f) && (tag->contents == SGML_LITTERAL)) {
    if (present == (BOOLEAN *)0x0) {
      return 0x2bd;
    }
    if (((present[8] == '\0') &&
        (((present[0xf] == '\0' || (value[0xf] == (char *)0x0)) || (*value[0xf] == '\0')))) &&
       ((((present[0x11] != '\0' || (present[0x17] == '\0')) || (value[0x17] == (char *)0x0)) ||
        (*value[0x17] == '\0')))) {
      return 0x2bd;
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

int HTMLGen_end_element(HTStructured_conflict1 *me,int element_number,char **insert)

{
  FILE *__stream;
  
  if ((me->preformatted == '\0') && (tags[element_number].contents != SGML_EMPTY)) {
    if (tags[element_number].contents == SGML_ELEMENT) {
      allow_break(me,0xe,'\0');
    }
    else {
      allow_break(me,1,'\0');
    }
  }
  HTMLGen_put_string(me,"</");
  HTMLGen_put_string(me,tags[element_number].name);
  HTMLGen_put_character(me,'>');
  if (element_number == 0x56) {
    me->preformatted = '\0';
  }
  TrimColorClass(tags[element_number].name,Style_className,&hcode);
  if ((LYPreparsedSource != '\0') &&
     ((tags[element_number].contents != SGML_EMPTY || ((tags[element_number].flags & 0x10U) != 0))))
  {
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 2U) != 0)) {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"STYLE:end_element: ending non-EMPTY style\n");
    }
    do_cstyle_flush(me);
    _internal_HTC(me->text,hcode,L'\0');
  }
  return 0;
}



// WARNING: Unknown calling convention

int HTMLGen_put_entity(HTStructured_conflict1 *me,int entity_number)

{
  int nent;
  
  HTMLGen_put_character(me,'&');
  if (entity_number < (int)0x70) {
    HTMLGen_put_string(me,entities[entity_number]);
  }
  HTMLGen_put_character(me,';');
  return 0;
}



// WARNING: Unknown calling convention

void HTMLGen_free(HTStructured_conflict1 *me)

{
  (*(me->targetClass).put_character)(me->target,'\n');
  HTMLGen_flush(me);
  (*(me->targetClass)._free)(me->target);
  if (Style_className != (char *)0x0) {
    free(Style_className);
    Style_className = (char *)0x0;
  }
  if (me != (HTStructured_conflict1 *)0x0) {
    free(me);
  }
  return;
}



// WARNING: Unknown calling convention

void PlainToHTML_free(HTStructured_conflict1 *me)

{
  HTMLGen_end_element(me,0x56,(char **)0x0);
  HTMLGen_free(me);
  return;
}



// WARNING: Unknown calling convention

void HTMLGen_abort(HTStructured_conflict1 *me,HTError e)

{
  HTMLGen_free(me);
  if (Style_className != (char *)0x0) {
    free(Style_className);
    Style_className = (char *)0x0;
  }
  return;
}



// WARNING: Unknown calling convention

void PlainToHTML_abort(HTStructured_conflict1 *me,HTError e)

{
  PlainToHTML_free(me);
  return;
}



// WARNING: Unknown calling convention

HTStructured_conflict1 * HTMLGenerator(HTStream_conflict4 *output)

{
  HTStreamClass_conflict4 *pHVar1;
  HTStructured_conflict1 *me_00;
  HTStructured_conflict1 *me;
  
  me_00 = (HTStructured_conflict1 *)malloc(0x16c);
  if (me_00 == (HTStructured_conflict1 *)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTMLGen.c","HTMLGenerator");
  }
  me_00->isa = &HTMLGeneration;
  me_00->target = output;
  pHVar1 = me_00->target->isa;
  (me_00->targetClass).name = pHVar1->name;
  (me_00->targetClass)._free = pHVar1->_free;
  (me_00->targetClass)._abort = pHVar1->_abort;
  (me_00->targetClass).put_character = pHVar1->put_character;
  (me_00->targetClass).put_string = pHVar1->put_string;
  (me_00->targetClass).put_block = pHVar1->put_block;
  me_00->write_pointer = me_00->buffer;
  flush_breaks(me_00);
  me_00->line_break[0] = me_00->buffer;
  me_00->cleanness = 0;
  me_00->overflowed = '\0';
  me_00->delete_line_break_char[0] = '\0';
  me_00->preformatted = '\0';
  me_00->in_attrval = '\0';
  if (LYPreparsedSource == '\0') {
    me_00->buffer_maxchars = 0x50;
  }
  else if (dump_output_width < 2) {
    if (dump_output_immediately == '\0') {
      me_00->buffer_maxchars = (LYcols - (uint)(LYShowScrollbar != '\0')) + -1;
      if (me_00->buffer_maxchars < 0x26) {
        me_00->buffer_maxchars = 0x28;
      }
    }
    else {
      me_00->buffer_maxchars = 0x50;
    }
  }
  else {
    me_00->buffer_maxchars = dump_output_width;
  }
  if (900 < me_00->buffer_maxchars) {
    me_00->buffer_maxchars = 0x4e;
  }
  if (200 < me_00->buffer_maxchars) {
    me_00->buffer_maxchars = 0xc6;
  }
  me_00->escape_specials = LYPreparsedSource;
  me_00->text = (HText *)0x0;
  if (Style_className != (char *)0x0) {
    free(Style_className);
    Style_className = (char *)0x0;
  }
  class_string[0] = '\0';
  return me_00;
}



// WARNING: Unknown calling convention

HTStream_conflict4 *
HTPlainToHTML(HTPresentation_conflict2 *pres,HTParentAnchor *anchor,HTStream_conflict4 *sink)

{
  HTStreamClass_conflict4 *pHVar1;
  HTStructured_conflict1 *me_00;
  int local_18;
  HTStructured_conflict1 *me;
  
  me_00 = (HTStructured_conflict1 *)malloc(0x16c);
  if (me_00 == (HTStructured_conflict1 *)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTMLGen.c","PlainToHTML");
  }
  me_00->isa = &PlainToHTMLConversion;
  me_00->target = sink;
  pHVar1 = me_00->target->isa;
  (me_00->targetClass).name = pHVar1->name;
  (me_00->targetClass)._free = pHVar1->_free;
  (me_00->targetClass)._abort = pHVar1->_abort;
  (me_00->targetClass).put_character = pHVar1->put_character;
  (me_00->targetClass).put_string = pHVar1->put_string;
  (me_00->targetClass).put_block = pHVar1->put_block;
  me_00->write_pointer = me_00->buffer;
  flush_breaks(me_00);
  me_00->cleanness = 0;
  me_00->overflowed = '\0';
  me_00->delete_line_break_char[0] = '\0';
  if (dump_output_width < 2) {
    local_18 = 0x50;
  }
  else {
    local_18 = dump_output_width;
  }
  me_00->buffer_maxchars = local_18;
  HTMLGen_put_string(me_00,"<HTML>\n<BODY>\n<PRE>\n");
  me_00->preformatted = '\x01';
  me_00->escape_specials = '\0';
  me_00->in_attrval = '\0';
  return (HTStream_conflict4 *)me_00;
}



// WARNING: Unknown calling convention

HTAtom * HTAtom_for(char *string)

{
  size_t sVar1;
  int iVar2;
  HTAtom *pHVar3;
  char *pcVar4;
  uint uVar5;
  int i;
  HTAtom *a;
  int hash;
  
  if (initialised == '\0') {
    for (i = 0; i < 0x65; i = i + 1) {
      hash_table[i] = (HTAtom *)0x0;
    }
    initialised = '\x01';
  }
  sVar1 = strlen(string);
  uVar5 = (sVar1 * (byte)*string) % 0x65;
  a = hash_table[uVar5];
  while( true ) {
    if (a == (HTAtom *)0x0) {
      pHVar3 = (HTAtom *)malloc(8);
      if (pHVar3 == (HTAtom *)0x0) {
        outofmem("../../../WWW/Library/Implementation/HTAtom.c","HTAtom_for");
      }
      sVar1 = strlen(string);
      pcVar4 = (char *)malloc(sVar1 + 1);
      pHVar3->name = pcVar4;
      if (pHVar3->name == (char *)0x0) {
        outofmem("../../../WWW/Library/Implementation/HTAtom.c","HTAtom_for");
      }
      strcpy(pHVar3->name,string);
      pHVar3->next = hash_table[uVar5];
      hash_table[uVar5] = pHVar3;
      return pHVar3;
    }
    iVar2 = strcasecomp(a->name,string);
    if (iVar2 == 0) break;
    a = a->next;
  }
  return a;
}



// WARNING: Unknown calling convention

BOOLEAN mime_match(char *name,char *templ)

{
  char *pcVar1;
  char *pcVar2;
  int iVar3;
  char *t2;
  char *n2;
  
  if ((name != (char *)0x0) && (templ != (char *)0x0)) {
    HTSACopy(&mime_match::n1,name);
    HTSACopy(&mime_match::t1,templ);
    pcVar1 = strchr(mime_match::n1,0x2f);
    if ((pcVar1 != (char *)0x0) && (pcVar2 = strchr(mime_match::t1,0x2f), pcVar2 != (char *)0x0)) {
      *pcVar1 = '\0';
      *pcVar2 = '\0';
      iVar3 = strcmp(mime_match::t1,"*");
      if (((iVar3 == 0) || (iVar3 = strcmp(mime_match::t1,mime_match::n1), iVar3 == 0)) &&
         ((iVar3 = strcmp(pcVar2 + 1,"*"), iVar3 == 0 ||
          (iVar3 = strcmp(pcVar2 + 1,pcVar1 + 1), iVar3 == 0)))) {
        return '\x01';
      }
    }
  }
  return '\0';
}



// WARNING: Unknown calling convention

HTList * HTAtom_templateMatches(char *templ)

{
  BOOLEAN BVar1;
  HTList *me;
  HTAtom *cur;
  int i;
  HTList *matches;
  
  me = HTList_new();
  if ((initialised != '\0') && (templ != (char *)0x0)) {
    for (i = 0; i < 0x65; i = i + 1) {
      for (cur = hash_table[i]; cur != (HTAtom *)0x0; cur = cur->next) {
        BVar1 = mime_match(cur->name,templ);
        if (BVar1 != '\0') {
          HTList_addObject(me,cur);
        }
      }
    }
  }
  return me;
}



// WARNING: Unknown calling convention

ushort HASH_FUNCTION(char *cp_address)

{
  uint uVar1;
  ushort local_1c;
  uchar *p;
  ushort hash;
  
  hash = 0;
  for (p = (uchar *)cp_address; *p != '\0'; p = p + 1) {
    uVar1 = (uint)hash * 3 + (uint)*p;
    local_1c = (short)uVar1 + (short)(uVar1 / 0x3e9) * -0x3e9;
    hash = local_1c;
  }
  return hash;
}



HTParentAnchor0 * HTParentAnchor0_new(char *address,ushort hash)

{
  HTParentAnchor0 *pHVar1;
  ushort hash_local;
  HTParentAnchor0 *newAnchor;
  
  pHVar1 = (HTParentAnchor0 *)calloc(1,0x24);
  if (pHVar1 == (HTParentAnchor0 *)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTAnchor.c","HTParentAnchor0_new");
  }
  pHVar1->parent = pHVar1;
  HTSACopy(&pHVar1->address,address);
  pHVar1->adult_hash = hash;
  return pHVar1;
}



// WARNING: Unknown calling convention

HTParentAnchor * HTParentAnchor_new(HTParentAnchor0 *parent)

{
  HTParentAnchor *pHVar1;
  HTParentAnchor *newAnchor;
  
  pHVar1 = (HTParentAnchor *)calloc(1,0xb8);
  if (pHVar1 == (HTParentAnchor *)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTAnchor.c","HTParentAnchor_new");
  }
  pHVar1->parent = parent;
  parent->info = pHVar1;
  pHVar1->address = parent->address;
  pHVar1->isISMAPScript = '\0';
  pHVar1->isHEAD = '\0';
  pHVar1->safe = '\0';
  pHVar1->no_cache = '\0';
  pHVar1->inBASE = '\0';
  pHVar1->content_length = 0;
  return pHVar1;
}



// WARNING: Unknown calling convention

HTChildAnchor * HTChildAnchor_new(HTParentAnchor0 *parent)

{
  HTChildAnchor *pHVar1;
  HTChildAnchor *p;
  
  pHVar1 = (HTChildAnchor *)calloc(1,0x20);
  if (pHVar1 == (HTChildAnchor *)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTAnchor.c","HTChildAnchor_new");
  }
  pHVar1->parent = parent;
  return pHVar1;
}



// WARNING: Unknown calling convention

HTChildAnchor * HText_pool_ChildAnchor_new(HTParentAnchor *parent)

{
  HTChildAnchor *pHVar1;
  HTChildAnchor *p;
  
  pHVar1 = (HTChildAnchor *)HText_pool_calloc((HText *)parent->document,0x20);
  if (pHVar1 == (HTChildAnchor *)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTAnchor.c","HText_pool_ChildAnchor_new");
  }
  pHVar1->parent = parent->parent;
  return pHVar1;
}



// WARNING: Unknown calling convention

BOOLEAN HTSEquivalent(char *s,char *t)

{
  bool local_5;
  
  if ((s == (char *)0x0) || (t == (char *)0x0)) {
    local_5 = s == t;
  }
  else {
    for (; (*s != '\0' && (*t != '\0')); t = t + 1) {
      if (*s != *t) {
        return '\0';
      }
      s = s + 1;
    }
    local_5 = *s == *t;
  }
  return local_5;
}



// WARNING: Unknown calling convention

BOOLEAN HTBEquivalent(bstring *s,bstring *t)

{
  int local_30;
  int local_2c;
  int local_28;
  char *local_24;
  char *local_1c;
  int len;
  int j;
  
  if ((s != (bstring *)0x0) && (t != (bstring *)0x0)) {
    if (s == (bstring *)0x0) {
      local_30 = 0;
    }
    else {
      local_30 = s->len;
    }
    if (t == (bstring *)0x0) {
      local_2c = 0;
    }
    else {
      local_2c = t->len;
    }
    if (local_30 == local_2c) {
      if (s == (bstring *)0x0) {
        local_28 = 0;
      }
      else {
        local_28 = s->len;
      }
      j = 0;
      while( true ) {
        if (local_28 <= j) {
          return '\x01';
        }
        if (s == (bstring *)0x0) {
          local_24 = (char *)0x0;
        }
        else {
          local_24 = s->str;
        }
        if (t == (bstring *)0x0) {
          local_1c = (char *)0x0;
        }
        else {
          local_1c = t->str;
        }
        if (local_24[j] != local_1c[j]) break;
        j = j + 1;
      }
      return '\0';
    }
  }
  return s == t;
}



// WARNING: Unknown calling convention

int compare_anchors(void *l,void *r)

{
  int iVar1;
  char *b;
  char *a;
  
  iVar1 = strcmp(*(char **)((int)l + 4),*(char **)((int)r + 4));
  return iVar1;
}



// WARNING: Unknown calling convention

HTChildAnchor * HTAnchor_findNamedChild(HTParentAnchor0 *parent,char *tag)

{
  HTParentAnchor0 *pHVar1;
  HTChildAnchor *pHVar2;
  FILE *pFVar3;
  HTBTree *pHVar4;
  HTChildAnchor *local_40;
  char *local_38;
  HTChildAnchor sample;
  HTChildAnchor *child;
  
  if (((parent == (HTParentAnchor0 *)0x0) || (tag == (char *)0x0)) || (*tag == '\0')) {
    if (WWW_TraceFlag != '\0') {
      pFVar3 = TraceFP();
      fprintf((FILE *)pFVar3,"HTAnchor_findNamedChild called with NULL parent.\n");
    }
    local_40 = (HTChildAnchor *)0x0;
  }
  else {
    if (parent->children == (HTBTree *)0x0) {
      pHVar4 = HTBTree_new(compare_anchors);
      parent->children = pHVar4;
    }
    else {
      sample.tag = tag;
      pHVar2 = (HTChildAnchor *)HTBTree_search(parent->children,&sample);
      if (pHVar2 != (HTChildAnchor *)0x0) {
        if (WWW_TraceFlag == '\0') {
          return pHVar2;
        }
        pFVar3 = TraceFP();
        fprintf((FILE *)pFVar3,"Child anchor %p of parent %p with name `%s\' already exists.\n",
                pHVar2,parent,tag);
        return pHVar2;
      }
    }
    local_40 = HTChildAnchor_new(parent);
    if (WWW_TraceFlag != '\0') {
      pHVar1 = local_40->parent;
      if (tag == (char *)0x0) {
        local_38 = "";
      }
      else {
        local_38 = tag;
      }
      pFVar3 = TraceFP();
      fprintf((FILE *)pFVar3,"HTAnchor: New Anchor %p named `%s\' is child of %p\n",local_40,
              local_38,pHVar1);
    }
    HTSACopy(&local_40->tag,tag);
    HTBTree_add(parent->children,local_40);
  }
  return local_40;
}



// WARNING: Unknown calling convention

HTChildAnchor * HTAnchor_addChild(HTParentAnchor *parent)

{
  HTParentAnchor0 *pHVar1;
  FILE *pFVar2;
  HTChildAnchor *local_1c;
  HTChildAnchor *child;
  
  if (parent == (HTParentAnchor *)0x0) {
    if (WWW_TraceFlag != '\0') {
      pFVar2 = TraceFP();
      fprintf((FILE *)pFVar2,"HTAnchor_addChild called with NULL parent.\n");
    }
    local_1c = (HTChildAnchor *)0x0;
  }
  else {
    local_1c = HText_pool_ChildAnchor_new(parent);
    if (WWW_TraceFlag != '\0') {
      pHVar1 = local_1c->parent;
      pFVar2 = TraceFP();
      fprintf((FILE *)pFVar2,"HTAnchor: New unnamed Anchor %p is child of %p\n",local_1c,pHVar1);
    }
    local_1c->tag = (char *)0x0;
    HTList_linkObject(&parent->children_notag,local_1c,&local_1c->_add_children_notag);
  }
  return local_1c;
}



// WARNING: Unknown calling convention

HTChildAnchor *
HTAnchor_findChildAndLink(HTParentAnchor *parent,char *tag,char *href,HTLinkType *ltype)

{
  HTAnchor *pHVar1;
  FILE *pFVar2;
  char *local_4c;
  char *local_48;
  char *local_44;
  char *local_40;
  char *local_3c;
  DocAddress parsed_doc;
  char *relative_to;
  HTParentAnchor0 *dest;
  char *fragment;
  HTChildAnchor *child;
  
  if (WWW_TraceFlag != '\0') {
    if (href == (char *)0x0) {
      local_4c = "";
    }
    else {
      local_4c = href;
    }
    if (ltype == HTInternalLink) {
      local_48 = " (internal link)";
    }
    else {
      local_48 = "";
    }
    if (tag == (char *)0x0) {
      local_44 = "";
    }
    else {
      local_44 = tag;
    }
    pFVar2 = TraceFP();
    fprintf((FILE *)pFVar2,"Entered HTAnchor_findChildAndLink:  tag=`%s\',%s href=`%s\'\n",local_44,
            local_48,local_4c);
  }
  if ((tag == (char *)0x0) || (*tag == '\0')) {
    child = HTAnchor_addChild(parent);
  }
  else {
    child = HTAnchor_findNamedChild(parent->parent,tag);
  }
  if ((href != (char *)0x0) && (*href != '\0')) {
    if ((ltype == HTInternalLink) && (*href == '#')) {
      dest = parent->parent;
    }
    else {
      if ((parent->inBASE == '\0') || (*href == '#')) {
        local_40 = parent->address;
      }
      else {
        local_40 = parent->content_base;
      }
      parsed_doc.address = HTParse(href,local_40,0x1d);
      parsed_doc.post_data = (bstring *)0x0;
      parsed_doc.post_content_type = (char *)0x0;
      if (((ltype != (HTLinkType *)0x0) && (parent->post_data != (bstring *)0x0)) &&
         (ltype == HTInternalLink)) {
        parsed_doc.post_data = parent->post_data;
        parsed_doc.post_content_type = parent->post_content_type;
      }
      parsed_doc.bookmark = (char *)0x0;
      parsed_doc.isHEAD = '\0';
      parsed_doc.safe = '\0';
      dest = HTAnchor_findAddress_in_adult_table(&parsed_doc);
      if (parsed_doc.address != (char *)0x0) {
        free(parsed_doc.address);
        parsed_doc.address = (char *)0x0;
      }
    }
    if (*href == '#') {
      local_3c = href + 1;
    }
    else {
      local_3c = HTParseAnchor(href);
    }
    if (*local_3c != '\0') {
      dest = (HTParentAnchor0 *)HTAnchor_findNamedChild(dest,local_3c);
    }
    if (((tag != (char *)0x0) && (*tag != '\0')) && (child->dest != (HTAnchor *)0x0)) {
      if (WWW_TraceFlag != '\0') {
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2,"*** Duplicate ChildAnchor %p named `%s\'",child,tag);
      }
      if (((HTParentAnchor0 *)child->dest != dest) || (child->type != ltype)) {
        if (WWW_TraceFlag != '\0') {
          pHVar1 = child->dest;
          pFVar2 = TraceFP();
          fprintf((FILE *)pFVar2,", different dest %p or type, creating unnamed child\n",pHVar1);
        }
        child = HTAnchor_addChild(parent);
      }
    }
    HTAnchor_link(child,(HTAnchor *)dest,ltype);
  }
  return child;
}



// WARNING: Unknown calling convention

HTParentAnchor * HTAnchor_findAddress(DocAddress *newdoc)

{
  char *tag_00;
  FILE *__stream;
  HTParentAnchor0 *pHVar1;
  HTParentAnchor *local_28;
  DocAddress parsed_doc;
  HTChildAnchor *foundAnchor;
  HTParentAnchor0 *foundParent;
  char *tag;
  
  tag_00 = HTParseAnchor(newdoc->address);
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"Entered HTAnchor_findAddress\n");
  }
  if (*tag_00 == '\0') {
    pHVar1 = HTAnchor_findAddress_in_adult_table(newdoc);
    local_28 = HTAnchor_parent((HTAnchor *)pHVar1);
  }
  else {
    parsed_doc.address = HTParse(newdoc->address,"",0x1d);
    parsed_doc.post_data = newdoc->post_data;
    parsed_doc.post_content_type = newdoc->post_content_type;
    parsed_doc.bookmark = newdoc->bookmark;
    parsed_doc.isHEAD = newdoc->isHEAD;
    parsed_doc.safe = newdoc->safe;
    pHVar1 = HTAnchor_findAddress_in_adult_table(&parsed_doc);
    HTAnchor_findNamedChild(pHVar1,tag_00);
    if (parsed_doc.address != (char *)0x0) {
      free(parsed_doc.address);
      parsed_doc.address = (char *)0x0;
    }
    local_28 = HTAnchor_parent((HTAnchor *)pHVar1);
  }
  return local_28;
}



// WARNING: Unknown calling convention

HTParentAnchor0 * HTAnchor_findAddress_in_adult_table(DocAddress *newdoc)

{
  char *pcVar1;
  bool bVar2;
  BOOLEAN BVar3;
  ushort hash_00;
  HTParentAnchor0 *parent;
  FILE *pFVar4;
  HTParentAnchor *pHVar5;
  HTParentAnchor0 *local_38;
  int local_34;
  char *local_30;
  HTParentAnchor *p;
  HTParentAnchor0 *foundAnchor;
  HTList *grownups;
  HTList *adults;
  ushort hash;
  BOOLEAN need_extra_info;
  
  if ((((newdoc->post_data == (bstring *)0x0) && (newdoc->post_content_type == (char *)0x0)) &&
      (newdoc->bookmark == (char *)0x0)) && ((newdoc->isHEAD == '\0' && (newdoc->safe == '\0')))) {
    bVar2 = false;
  }
  else {
    bVar2 = true;
  }
  hash_00 = HASH_FUNCTION(newdoc->address);
  grownups = adult_table + hash_00;
  while( true ) {
    if ((grownups == (HTList *)0x0) || (grownups = grownups->next, grownups == (HTList *)0x0)) {
      local_38 = (HTParentAnchor0 *)0x0;
    }
    else {
      local_38 = (HTParentAnchor0 *)grownups->object;
    }
    if (local_38 == (HTParentAnchor0 *)0x0) break;
    BVar3 = HTSEquivalent(local_38->address,newdoc->address);
    if ((BVar3 != '\0') &&
       (((local_38->info == (HTParentAnchor *)0x0 && (!bVar2)) ||
        ((local_38->info != (HTParentAnchor *)0x0 &&
         ((BVar3 = HTBEquivalent(local_38->info->post_data,newdoc->post_data), BVar3 != '\0' &&
          (local_38->info->isHEAD == newdoc->isHEAD)))))))) {
      if (WWW_TraceFlag != '\0') {
        pcVar1 = newdoc->address;
        pFVar4 = TraceFP();
        fprintf((FILE *)pFVar4,"Anchor %p with address `%s\' already exists.\n",local_38,pcVar1);
      }
      return local_38;
    }
  }
  parent = HTParentAnchor0_new(newdoc->address,hash_00);
  if (WWW_TraceFlag != '\0') {
    pcVar1 = newdoc->address;
    pFVar4 = TraceFP();
    fprintf((FILE *)pFVar4,"New anchor %p has hash %d and address `%s\'\n",parent,(uint)hash_00,
            pcVar1);
  }
  if (bVar2) {
    pHVar5 = HTParentAnchor_new(parent);
    if (newdoc->post_data != (bstring *)0x0) {
      if (newdoc->post_data == (bstring *)0x0) {
        local_34 = 0;
      }
      else {
        local_34 = newdoc->post_data->len;
      }
      if (newdoc->post_data == (bstring *)0x0) {
        local_30 = (char *)0x0;
      }
      else {
        local_30 = newdoc->post_data->str;
      }
      HTSABCopy(&pHVar5->post_data,local_30,local_34);
    }
    if (newdoc->post_content_type != (char *)0x0) {
      HTSACopy(&pHVar5->post_content_type,newdoc->post_content_type);
    }
    if (newdoc->bookmark != (char *)0x0) {
      HTSACopy(&pHVar5->bookmark,newdoc->bookmark);
    }
    pHVar5->isHEAD = newdoc->isHEAD;
    pHVar5->safe = newdoc->safe;
  }
  HTList_linkObject(adult_table + hash_00,parent,&parent->_add_adult);
  return parent;
}



// WARNING: Unknown calling convention

HTParentAnchor * HTAnchor_findSimpleAddress(char *url)

{
  HTParentAnchor *pHVar1;
  DocAddress urldoc;
  
  urldoc.address = url;
  urldoc.post_data = (bstring *)0x0;
  urldoc.post_content_type = (char *)0x0;
  urldoc.bookmark = (char *)0x0;
  urldoc.isHEAD = '\0';
  urldoc.safe = '\0';
  pHVar1 = HTAnchor_findAddress(&urldoc);
  return pHVar1;
}



// WARNING: Unknown calling convention

BOOLEAN HTAnchor_link(HTChildAnchor *child,HTAnchor *destination,HTLinkType *type)

{
  FILE *pFVar1;
  BOOLEAN local_5;
  
  if ((child == (HTChildAnchor *)0x0) || (destination == (HTAnchor *)0x0)) {
    local_5 = '\0';
  }
  else {
    if (WWW_TraceFlag != '\0') {
      pFVar1 = TraceFP();
      fprintf((FILE *)pFVar1,"Linking child %p to anchor %p\n",child,destination);
    }
    if (child->dest == (HTAnchor *)0x0) {
      child->dest = destination;
      child->type = type;
      if (child->parent != destination->parent) {
        HTList_linkObject(&destination->parent->sources,child,&child->_add_sources);
      }
      local_5 = '\x01';
    }
    else {
      if (WWW_TraceFlag != '\0') {
        pFVar1 = TraceFP();
        fprintf((FILE *)pFVar1,"*** child anchor already has destination, exiting!\n");
      }
      local_5 = '\0';
    }
  }
  return local_5;
}



// WARNING: Unknown calling convention

void deleteLinks(HTChildAnchor *me)

{
  HTParentAnchor0 *me_00;
  HTParentAnchor0 *parent;
  
  if (me->dest != (HTAnchor *)0x0) {
    me_00 = me->dest->parent;
    me->dest = (HTAnchor *)0x0;
    if ((me->parent != me_00) && ((me_00->sources).next != (HTList *)0x0)) {
      HTList_unlinkObject(&me_00->sources,me);
    }
    if (((me->parent != me_00) && (me_00->underway == '\0')) &&
       ((me_00->info == (HTParentAnchor *)0x0 || (me_00->info->document == (HyperDoc *)0x0)))) {
      HTAnchor_delete(me_00);
    }
    me->type = (HTLinkType *)0x0;
  }
  return;
}



// WARNING: Unknown calling convention

BOOLEAN HTAnchor_delete(HTParentAnchor0 *me)

{
  void *__ptr;
  BOOLEAN local_15;
  HTChildAnchor *child;
  HTBTElement *ele;
  
  if (me == (HTParentAnchor0 *)0x0) {
    local_15 = '\0';
  }
  else if ((me->underway == '\0') &&
          ((me->info == (HTParentAnchor *)0x0 || (me->info->document == (HyperDoc *)0x0)))) {
    me->underway = '\x01';
    if (me->children != (HTBTree *)0x0) {
      for (ele = HTBTree_next(me->children,(HTBTElement *)0x0); ele != (HTBTElement *)0x0;
          ele = HTBTree_next(me->children,ele)) {
        if (((HTChildAnchor *)ele->object)->dest != (HTAnchor *)0x0) {
          deleteLinks((HTChildAnchor *)ele->object);
        }
      }
    }
    me->underway = '\0';
    if ((me->sources).next == (HTList *)0x0) {
      if (me->children != (HTBTree *)0x0) {
        for (ele = HTBTree_next(me->children,(HTBTElement *)0x0); ele != (HTBTElement *)0x0;
            ele = HTBTree_next(me->children,ele)) {
          __ptr = ele->object;
          if (*(int *)((int)__ptr + 4) != 0) {
            free(*(void **)((int)__ptr + 4));
            *(undefined4 *)((int)__ptr + 4) = 0;
          }
          if (__ptr != (void *)0x0) {
            free(__ptr);
          }
        }
        HTBTree_free(me->children);
      }
      if (me->info != (HTParentAnchor *)0x0) {
        HTParentAnchor_free(me->info);
        if (me->info != (HTParentAnchor *)0x0) {
          free(me->info);
          me->info = (HTParentAnchor *)0x0;
        }
      }
      HTList_unlinkObject(adult_table + me->adult_hash,me);
      if (me->address != (char *)0x0) {
        free(me->address);
        me->address = (char *)0x0;
      }
      if (me != (HTParentAnchor0 *)0x0) {
        free(me);
      }
      local_15 = '\x01';
    }
    else {
      local_15 = '\0';
    }
  }
  else {
    local_15 = '\0';
  }
  return local_15;
}



// WARNING: Unknown calling convention

void HTAnchor_delete_links(HTParentAnchor *me)

{
  HTChildAnchor *me_00;
  HTChildAnchor *child;
  HTList *cur;
  
  if ((me != (HTParentAnchor *)0x0) && (me->document != (HyperDoc *)0x0)) {
    me->parent->underway = '\x01';
    if ((me->children_notag).next != (HTList *)0x0) {
      while( true ) {
        me_00 = (HTChildAnchor *)HTList_unlinkLastObject(&me->children_notag);
        if (me_00 == (HTChildAnchor *)0x0) break;
        deleteLinks(me_00);
      }
    }
    me->parent->underway = '\0';
  }
  return;
}



// WARNING: Unknown calling convention

void HTParentAnchor_free(HTParentAnchor *me)

{
  FILE *__stream;
  FILE *fd;
  
  if (me->methods != (HTList *)0x0) {
    HTList_delete(me->methods);
    me->methods = (HTList *)0x0;
  }
  if (me->charset != (char *)0x0) {
    free(me->charset);
    me->charset = (char *)0x0;
  }
  if (me->isIndexAction != (char *)0x0) {
    free(me->isIndexAction);
    me->isIndexAction = (char *)0x0;
  }
  if (me->isIndexPrompt != (char *)0x0) {
    free(me->isIndexPrompt);
    me->isIndexPrompt = (char *)0x0;
  }
  if (me->title != (char *)0x0) {
    free(me->title);
    me->title = (char *)0x0;
  }
  if (me->physical != (char *)0x0) {
    free(me->physical);
    me->physical = (char *)0x0;
  }
  HTSABFree(&me->post_data);
  if (me->post_content_type != (char *)0x0) {
    free(me->post_content_type);
    me->post_content_type = (char *)0x0;
  }
  if (me->bookmark != (char *)0x0) {
    free(me->bookmark);
    me->bookmark = (char *)0x0;
  }
  if (me->owner != (char *)0x0) {
    free(me->owner);
    me->owner = (char *)0x0;
  }
  if (me->RevTitle != (char *)0x0) {
    free(me->RevTitle);
    me->RevTitle = (char *)0x0;
  }
  if (me->citehost != (char *)0x0) {
    free(me->citehost);
    me->citehost = (char *)0x0;
  }
  HTAnchor_clearSourceCache(me);
  if (me->FileCache != (char *)0x0) {
    __stream = fopen64(me->FileCache,"r");
    if (__stream != (FILE *)0x0) {
      fclose(__stream);
      remove(me->FileCache);
    }
    if (me->FileCache != (char *)0x0) {
      free(me->FileCache);
      me->FileCache = (char *)0x0;
    }
  }
  if (me->SugFname != (char *)0x0) {
    free(me->SugFname);
    me->SugFname = (char *)0x0;
  }
  if (me->cache_control != (char *)0x0) {
    free(me->cache_control);
    me->cache_control = (char *)0x0;
  }
  if (me->content_type_params != (char *)0x0) {
    free(me->content_type_params);
    me->content_type_params = (char *)0x0;
  }
  if (me->content_type != (char *)0x0) {
    free(me->content_type);
    me->content_type = (char *)0x0;
  }
  if (me->content_language != (char *)0x0) {
    free(me->content_language);
    me->content_language = (char *)0x0;
  }
  if (me->content_encoding != (char *)0x0) {
    free(me->content_encoding);
    me->content_encoding = (char *)0x0;
  }
  if (me->content_base != (char *)0x0) {
    free(me->content_base);
    me->content_base = (char *)0x0;
  }
  if (me->content_disposition != (char *)0x0) {
    free(me->content_disposition);
    me->content_disposition = (char *)0x0;
  }
  if (me->content_location != (char *)0x0) {
    free(me->content_location);
    me->content_location = (char *)0x0;
  }
  if (me->content_md5 != (char *)0x0) {
    free(me->content_md5);
    me->content_md5 = (char *)0x0;
  }
  if (me->message_id != (char *)0x0) {
    free(me->message_id);
    me->message_id = (char *)0x0;
  }
  if (me->subject != (char *)0x0) {
    free(me->subject);
    me->subject = (char *)0x0;
  }
  if (me->date != (char *)0x0) {
    free(me->date);
    me->date = (char *)0x0;
  }
  if (me->expires != (char *)0x0) {
    free(me->expires);
    me->expires = (char *)0x0;
  }
  if (me->last_modified != (char *)0x0) {
    free(me->last_modified);
    me->last_modified = (char *)0x0;
  }
  if (me->ETag != (char *)0x0) {
    free(me->ETag);
    me->ETag = (char *)0x0;
  }
  if (me->server != (char *)0x0) {
    free(me->server);
    me->server = (char *)0x0;
  }
  if (me->style != (char *)0x0) {
    free(me->style);
    me->style = (char *)0x0;
  }
  if (me->UCStages != (UCAnchorInfo *)0x0) {
    free(me->UCStages);
    me->UCStages = (UCAnchorInfo *)0x0;
  }
  ImageMapList_free(me->imaps);
  return;
}



// WARNING: Unknown calling convention

void HTAnchor_clearSourceCache(HTParentAnchor *me)

{
  char *pcVar1;
  HTChunk *pHVar2;
  FILE *pFVar3;
  
  if (me->source_cache_file != (char *)0x0) {
    if (WWW_TraceFlag != '\0') {
      pcVar1 = me->source_cache_file;
      pFVar3 = TraceFP();
      fprintf((FILE *)pFVar3,"SourceCache: Removing file %s\n",pcVar1);
    }
    LYRemoveTemp(me->source_cache_file);
    if (me->source_cache_file != (char *)0x0) {
      free(me->source_cache_file);
      me->source_cache_file = (char *)0x0;
    }
  }
  if (me->source_cache_chunk != (HTChunk *)0x0) {
    if (WWW_TraceFlag != '\0') {
      pHVar2 = me->source_cache_chunk;
      pFVar3 = TraceFP();
      fprintf((FILE *)pFVar3,"SourceCache: Removing memory chunk %p\n",pHVar2);
    }
    HTChunkFree(me->source_cache_chunk);
    me->source_cache_chunk = (HTChunk *)0x0;
  }
  return;
}



// WARNING: Unknown calling convention

HTParentAnchor * HTAnchor_parent(HTAnchor *me)

{
  HTParentAnchor *local_8;
  
  if (me == (HTAnchor *)0x0) {
    local_8 = (HTParentAnchor *)0x0;
  }
  else if (me->parent->info == (HTParentAnchor *)0x0) {
    local_8 = HTParentAnchor_new(me->parent);
  }
  else {
    local_8 = me->parent->info;
  }
  return local_8;
}



// WARNING: Unknown calling convention

void HTAnchor_setDocument(HTParentAnchor *me,HyperDoc *doc)

{
  if (me != (HTParentAnchor *)0x0) {
    me->document = doc;
  }
  return;
}



// WARNING: Unknown calling convention

HyperDoc * HTAnchor_document(HTParentAnchor *me)

{
  HyperDoc *local_8;
  
  if (me == (HTParentAnchor *)0x0) {
    local_8 = (HyperDoc *)0x0;
  }
  else {
    local_8 = me->document;
  }
  return local_8;
}



// WARNING: Unknown calling convention

char * HTAnchor_address(HTAnchor *me)

{
  char *addr;
  
  addr = (char *)0x0;
  if (me != (HTAnchor *)0x0) {
    if (((me->parent == (HTParentAnchor0 *)me) || (me->parent->info == (HTParentAnchor *)me)) ||
       (me[1].parent == (HTParentAnchor0 *)0x0)) {
      HTSACopy(&addr,me->parent->address);
    }
    else {
      HTSprintf0(&addr,"%s#%s",me->parent->address,me[1].parent);
    }
  }
  return addr;
}



// WARNING: Unknown calling convention

void HTAnchor_setFormat(HTParentAnchor *me,HTFormat form)

{
  if (me != (HTParentAnchor *)0x0) {
    me->format = form;
  }
  return;
}



// WARNING: Unknown calling convention

HTFormat HTAnchor_format(HTParentAnchor *me)

{
  HTFormat local_8;
  
  if (me == (HTParentAnchor *)0x0) {
    local_8 = (HTFormat)0x0;
  }
  else {
    local_8 = me->format;
  }
  return local_8;
}



// WARNING: Unknown calling convention

void HTAnchor_setIndex(HTParentAnchor *me,char *address)

{
  if (me != (HTParentAnchor *)0x0) {
    me->isIndex = '\x01';
    HTSACopy(&me->isIndexAction,address);
  }
  return;
}



// WARNING: Unknown calling convention

void HTAnchor_setPrompt(HTParentAnchor *me,char *prompt)

{
  if (me != (HTParentAnchor *)0x0) {
    HTSACopy(&me->isIndexPrompt,prompt);
  }
  return;
}



// WARNING: Unknown calling convention

BOOLEAN HTAnchor_isIndex(HTParentAnchor *me)

{
  BOOLEAN local_5;
  
  if (me == (HTParentAnchor *)0x0) {
    local_5 = '\0';
  }
  else {
    local_5 = me->isIndex;
  }
  return local_5;
}



// WARNING: Unknown calling convention

BOOLEAN HTAnchor_isISMAPScript(HTAnchor *me)

{
  BOOLEAN local_5;
  
  if ((me == (HTAnchor *)0x0) || (me->parent->info == (HTParentAnchor *)0x0)) {
    local_5 = '\0';
  }
  else {
    local_5 = me->parent->info->isISMAPScript;
  }
  return local_5;
}



// WARNING: Unknown calling convention

char * HTAnchor_style(HTParentAnchor *me)

{
  char *local_8;
  
  if (me == (HTParentAnchor *)0x0) {
    local_8 = (char *)0x0;
  }
  else {
    local_8 = me->style;
  }
  return local_8;
}



// WARNING: Unknown calling convention

void HTAnchor_setStyle(HTParentAnchor *me,char *style)

{
  if (me != (HTParentAnchor *)0x0) {
    HTSACopy(&me->style,style);
  }
  return;
}



// WARNING: Unknown calling convention

char * HTAnchor_title(HTParentAnchor *me)

{
  char *local_8;
  
  if (me == (HTParentAnchor *)0x0) {
    local_8 = (char *)0x0;
  }
  else {
    local_8 = me->title;
  }
  return local_8;
}



// WARNING: Unknown calling convention

void HTAnchor_setTitle(HTParentAnchor *me,char *title)

{
  char *pcVar1;
  FILE *pFVar2;
  int i;
  
  if (me != (HTParentAnchor *)0x0) {
    if (title == (char *)0x0) {
      if (WWW_TraceFlag != '\0') {
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2,"HTAnchor_setTitle: New title is NULL! ");
      }
      if (me->title == (char *)0x0) {
        if (WWW_TraceFlag != '\0') {
          pFVar2 = TraceFP();
          fprintf((FILE *)pFVar2,"Old title was NULL.\n");
        }
      }
      else {
        if (WWW_TraceFlag != '\0') {
          pcVar1 = me->title;
          pFVar2 = TraceFP();
          fprintf((FILE *)pFVar2,"Old title was \"%s\".\n",pcVar1);
        }
        if (me->title != (char *)0x0) {
          free(me->title);
          me->title = (char *)0x0;
        }
      }
    }
    else {
      HTSACopy(&me->title,title);
      for (i = 0; me->title[i] != '\0'; i = i + 1) {
        if ((me->title[i] == '\x01') || (me->title[i] == '\x02')) {
          me->title[i] = ' ';
        }
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

void HTAnchor_appendTitle(HTParentAnchor *me,char *title)

{
  int i;
  
  if (me != (HTParentAnchor *)0x0) {
    HTSACat(&me->title,title);
    for (i = 0; me->title[i] != '\0'; i = i + 1) {
      if ((me->title[i] == '\x01') || (me->title[i] == '\x02')) {
        me->title[i] = ' ';
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

char * HTAnchor_bookmark(HTParentAnchor *me)

{
  char *local_8;
  
  if (me == (HTParentAnchor *)0x0) {
    local_8 = (char *)0x0;
  }
  else {
    local_8 = me->bookmark;
  }
  return local_8;
}



// WARNING: Unknown calling convention

void HTAnchor_setBookmark(HTParentAnchor *me,char *bookmark)

{
  if (me != (HTParentAnchor *)0x0) {
    HTSACopy(&me->bookmark,bookmark);
  }
  return;
}



// WARNING: Unknown calling convention

char * HTAnchor_owner(HTParentAnchor *me)

{
  char *local_8;
  
  if (me == (HTParentAnchor *)0x0) {
    local_8 = (char *)0x0;
  }
  else {
    local_8 = me->owner;
  }
  return local_8;
}



// WARNING: Unknown calling convention

void HTAnchor_setOwner(HTParentAnchor *me,char *owner)

{
  if (me != (HTParentAnchor *)0x0) {
    HTSACopy(&me->owner,owner);
  }
  return;
}



// WARNING: Unknown calling convention

char * HTAnchor_RevTitle(HTParentAnchor *me)

{
  char *local_8;
  
  if (me == (HTParentAnchor *)0x0) {
    local_8 = (char *)0x0;
  }
  else {
    local_8 = me->RevTitle;
  }
  return local_8;
}



// WARNING: Unknown calling convention

void HTAnchor_setRevTitle(HTParentAnchor *me,char *title)

{
  int i;
  
  if (me != (HTParentAnchor *)0x0) {
    HTSACopy(&me->RevTitle,title);
    for (i = 0; me->RevTitle[i] != '\0'; i = i + 1) {
      if ((me->RevTitle[i] == '\x01') || (me->RevTitle[i] == '\x02')) {
        me->RevTitle[i] = ' ';
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

char * HTAnchor_citehost(HTParentAnchor *me)

{
  char *local_8;
  
  if (me == (HTParentAnchor *)0x0) {
    local_8 = (char *)0x0;
  }
  else {
    local_8 = me->citehost;
  }
  return local_8;
}



// WARNING: Unknown calling convention

void HTAnchor_setCitehost(HTParentAnchor *me,char *citehost)

{
  if (me != (HTParentAnchor *)0x0) {
    HTSACopy(&me->citehost,citehost);
  }
  return;
}



// WARNING: Unknown calling convention

char * HTAnchor_SugFname(HTParentAnchor *me)

{
  char *local_8;
  
  if (me == (HTParentAnchor *)0x0) {
    local_8 = (char *)0x0;
  }
  else {
    local_8 = me->SugFname;
  }
  return local_8;
}



// WARNING: Unknown calling convention

char * HTAnchor_content_type_params(HTParentAnchor *me)

{
  char *local_8;
  
  if (me == (HTParentAnchor *)0x0) {
    local_8 = (char *)0x0;
  }
  else {
    local_8 = me->content_type_params;
  }
  return local_8;
}



// WARNING: Unknown calling convention

char * HTAnchor_content_encoding(HTParentAnchor *me)

{
  char *local_8;
  
  if (me == (HTParentAnchor *)0x0) {
    local_8 = (char *)0x0;
  }
  else {
    local_8 = me->content_encoding;
  }
  return local_8;
}



// WARNING: Unknown calling convention

char * HTAnchor_content_type(HTParentAnchor *me)

{
  char *local_8;
  
  if (me == (HTParentAnchor *)0x0) {
    local_8 = (char *)0x0;
  }
  else {
    local_8 = me->content_type;
  }
  return local_8;
}



// WARNING: Unknown calling convention

char * HTAnchor_last_modified(HTParentAnchor *me)

{
  char *local_8;
  
  if (me == (HTParentAnchor *)0x0) {
    local_8 = (char *)0x0;
  }
  else {
    local_8 = me->last_modified;
  }
  return local_8;
}



// WARNING: Unknown calling convention

char * HTAnchor_date(HTParentAnchor *me)

{
  char *local_8;
  
  if (me == (HTParentAnchor *)0x0) {
    local_8 = (char *)0x0;
  }
  else {
    local_8 = me->date;
  }
  return local_8;
}



// WARNING: Unknown calling convention

char * HTAnchor_server(HTParentAnchor *me)

{
  char *local_8;
  
  if (me == (HTParentAnchor *)0x0) {
    local_8 = (char *)0x0;
  }
  else {
    local_8 = me->server;
  }
  return local_8;
}



// WARNING: Unknown calling convention

BOOLEAN HTAnchor_safe(HTParentAnchor *me)

{
  BOOLEAN local_5;
  
  if (me == (HTParentAnchor *)0x0) {
    local_5 = '\0';
  }
  else {
    local_5 = me->safe;
  }
  return local_5;
}



// WARNING: Unknown calling convention

char * HTAnchor_content_base(HTParentAnchor *me)

{
  char *local_8;
  
  if (me == (HTParentAnchor *)0x0) {
    local_8 = (char *)0x0;
  }
  else {
    local_8 = me->content_base;
  }
  return local_8;
}



// WARNING: Unknown calling convention

char * HTAnchor_content_location(HTParentAnchor *me)

{
  char *local_8;
  
  if (me == (HTParentAnchor *)0x0) {
    local_8 = (char *)0x0;
  }
  else {
    local_8 = me->content_location;
  }
  return local_8;
}



// WARNING: Unknown calling convention

char * HTAnchor_messageID(HTParentAnchor *me)

{
  char *local_8;
  
  if (me == (HTParentAnchor *)0x0) {
    local_8 = (char *)0x0;
  }
  else {
    local_8 = me->message_id;
  }
  return local_8;
}



// WARNING: Unknown calling convention

BOOLEAN HTAnchor_setMessageID(HTParentAnchor *me,char *messageid)

{
  BOOLEAN local_5;
  
  if (((me == (HTParentAnchor *)0x0) || (messageid == (char *)0x0)) || (*messageid == '\0')) {
    local_5 = '\0';
  }
  else {
    HTSACopy(&me->message_id,messageid);
    local_5 = '\x01';
  }
  return local_5;
}



// WARNING: Unknown calling convention

char * HTAnchor_subject(HTParentAnchor *me)

{
  char *local_8;
  
  if (me == (HTParentAnchor *)0x0) {
    local_8 = (char *)0x0;
  }
  else {
    local_8 = me->subject;
  }
  return local_8;
}



// WARNING: Unknown calling convention

BOOLEAN HTAnchor_setSubject(HTParentAnchor *me,char *subject)

{
  BOOLEAN local_5;
  
  if (((me == (HTParentAnchor *)0x0) || (subject == (char *)0x0)) || (*subject == '\0')) {
    local_5 = '\0';
  }
  else {
    HTSACopy(&me->subject,subject);
    local_5 = '\x01';
  }
  return local_5;
}



// WARNING: Unknown calling convention

HTAnchor * HTAnchor_followLink(HTChildAnchor *me)

{
  return me->dest;
}



// WARNING: Unknown calling convention

HTAnchor * HTAnchor_followTypedLink(HTChildAnchor *me,HTLinkType *type)

{
  HTAnchor *local_8;
  
  if (me->type == type) {
    local_8 = me->dest;
  }
  else {
    local_8 = (HTAnchor *)0x0;
  }
  return local_8;
}



// WARNING: Unknown calling convention

HTList * HTAnchor_methods(HTParentAnchor *me)

{
  HTList *pHVar1;
  
  if (me->methods == (HTList *)0x0) {
    pHVar1 = HTList_new();
    me->methods = pHVar1;
  }
  return me->methods;
}



// WARNING: Unknown calling convention

void * HTAnchor_protocol(HTParentAnchor *me)

{
  return me->protocol;
}



// WARNING: Unknown calling convention

void HTAnchor_setProtocol(HTParentAnchor *me,void *protocol)

{
  me->protocol = protocol;
  return;
}



// WARNING: Unknown calling convention

char * HTAnchor_physical(HTParentAnchor *me)

{
  return me->physical;
}



// WARNING: Unknown calling convention

void HTAnchor_setPhysical(HTParentAnchor *me,char *physical)

{
  if (me != (HTParentAnchor *)0x0) {
    HTSACopy(&me->physical,physical);
  }
  return;
}



// WARNING: Unknown calling convention

LYUCcharset * HTAnchor_getUCInfoStage(HTParentAnchor *me,int which_stage)

{
  UCAnchorInfo *pUVar1;
  LYUCcharset *local_18;
  UCAnchorInfo *stages;
  int chndl;
  int i;
  
  if ((me != (HTParentAnchor *)0x0) && (me->UCStages == (UCAnchorInfo *)0x0)) {
    chndl = UCLYhndl_for_unspec;
    pUVar1 = (UCAnchorInfo *)calloc(1,0xa0);
    if (pUVar1 == (UCAnchorInfo *)0x0) {
      outofmem("../../../WWW/Library/Implementation/HTAnchor.c","HTAnchor_getUCInfoStage");
    }
    for (i = 0; i < 4; i = i + 1) {
      pUVar1->s[i].C.MIMEname = "";
      pUVar1->s[i].LYhndl = -1;
    }
    if (me->charset != (char *)0x0) {
      chndl = UCGetLYhndl_byMIME(me->charset);
      if (chndl < 0) {
        chndl = UCLYhndl_for_unrec;
      }
      if (chndl < 0) {
        chndl = UCLYhndl_for_unspec;
      }
    }
    memcpy(&pUVar1->s[0].C,LYCharSet_UC + chndl,0x20);
    pUVar1->s[0].lock = 1;
    pUVar1->s[0].LYhndl = chndl;
    me->UCStages = pUVar1;
  }
  if (me == (HTParentAnchor *)0x0) {
    local_18 = (LYUCcharset *)0x0;
  }
  else {
    local_18 = &me->UCStages->s[which_stage].C;
  }
  return local_18;
}



// WARNING: Unknown calling convention

int HTAnchor_getUCLYhndl(HTParentAnchor *me,int which_stage)

{
  if (me != (HTParentAnchor *)0x0) {
    if (me->UCStages == (UCAnchorInfo *)0x0) {
      HTAnchor_getUCInfoStage(me,which_stage);
    }
    if (0 < me->UCStages->s[which_stage].lock) {
      return me->UCStages->s[which_stage].LYhndl;
    }
  }
  return -1;
}



// WARNING: Unknown calling convention

LYUCcharset * HTAnchor_setUCInfoStage(HTParentAnchor *me,int LYhndl,int which_stage,int set_by)

{
  LYUCcharset *local_18;
  LYUCcharset *p;
  
  if ((me == (HTParentAnchor *)0x0) ||
     (local_18 = HTAnchor_getUCInfoStage(me,which_stage), set_by < me->UCStages->s[which_stage].lock
     )) {
    local_18 = (LYUCcharset *)0x0;
  }
  else {
    me->UCStages->s[which_stage].lock = set_by;
    me->UCStages->s[which_stage].LYhndl = LYhndl;
    if (LYhndl < 0) {
      local_18->UChndl = -1;
    }
    else {
      memcpy(local_18,LYCharSet_UC + LYhndl,0x20);
    }
  }
  return local_18;
}



// WARNING: Unknown calling convention

LYUCcharset * HTAnchor_resetUCInfoStage(HTParentAnchor *me,int LYhndl,int which_stage,int set_by)

{
  LYUCcharset *local_18;
  int ohandle;
  
  if ((me == (HTParentAnchor *)0x0) || (me->UCStages == (UCAnchorInfo *)0x0)) {
    local_18 = (LYUCcharset *)0x0;
  }
  else {
    me->UCStages->s[which_stage].lock = set_by;
    me->UCStages->s[which_stage].LYhndl = LYhndl;
    local_18 = &me->UCStages->s[which_stage].C;
  }
  return local_18;
}



// WARNING: Unknown calling convention

LYUCcharset * HTAnchor_copyUCInfoStage(HTParentAnchor *me,int to_stage,int from_stage,int set_by)

{
  LYUCcharset *__src;
  LYUCcharset *__dest;
  LYUCcharset *p_to;
  LYUCcharset *p_from;
  
  if (me != (HTParentAnchor *)0x0) {
    __src = HTAnchor_getUCInfoStage(me,from_stage);
    __dest = HTAnchor_getUCInfoStage(me,to_stage);
    if (set_by == -1) {
      set_by = me->UCStages->s[from_stage].lock;
    }
    if (set_by == 0) {
      set_by = 1;
    }
    if (me->UCStages->s[to_stage].lock <= set_by) {
      me->UCStages->s[to_stage].lock = set_by;
      me->UCStages->s[to_stage].LYhndl = me->UCStages->s[from_stage].LYhndl;
      if (__dest == __src) {
        return __dest;
      }
      memcpy(__dest,__src,0x20);
      return __dest;
    }
  }
  return (LYUCcharset *)0x0;
}



// WARNING: Unknown calling convention

HTStyle * HTStyleNew(void)

{
  HTStyle *pHVar1;
  HTStyle *self;
  
  pHVar1 = (HTStyle *)calloc(1,0x50);
  if (pHVar1 == (HTStyle *)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTStyle.c","HTStyleNew");
  }
  return pHVar1;
}



// WARNING: Unknown calling convention

HTStyle * HTStyleNewNamed(char *name)

{
  HTStyle *pHVar1;
  HTStyle *self;
  
  pHVar1 = HTStyleNew();
  HTSACopy(&pHVar1->name,name);
  pHVar1->id = -1;
  return pHVar1;
}



// WARNING: Unknown calling convention

HTStyle * HTStyleFree(HTStyle *self)

{
  if (self->name != (char *)0x0) {
    free(self->name);
    self->name = (char *)0x0;
  }
  if (self->SGMLTag != (char *)0x0) {
    free(self->SGMLTag);
    self->SGMLTag = (char *)0x0;
  }
  if (self != (HTStyle *)0x0) {
    free(self);
  }
  return (HTStyle *)0x0;
}



// WARNING: Unknown calling convention

HTStyle * HTStyleNamed(HTStyleSheet *self,char *name)

{
  int iVar1;
  FILE *__stream;
  HTStyle *scan;
  
  scan = self->styles;
  while( true ) {
    if (scan == (HTStyle *)0x0) {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"StyleSheet: No style named `%s\'\n",name);
      }
      return (HTStyle *)0x0;
    }
    iVar1 = strcmp(scan->name,name);
    if (iVar1 == 0) break;
    scan = scan->next;
  }
  return scan;
}



// WARNING: Unknown calling convention

HTStyleSheet * HTStyleSheetAddStyle(HTStyleSheet *self,HTStyle *style)

{
  HTStyle *scan;
  
  style->next = (_HTStyle *)0x0;
  if (self->styles == (HTStyle *)0x0) {
    self->styles = style;
  }
  else {
    for (scan = self->styles; scan->next != (_HTStyle *)0x0; scan = scan->next) {
    }
    scan->next = style;
  }
  return self;
}



// WARNING: Unknown calling convention

HTStyleSheet * HTStyleSheetRemoveStyle(HTStyleSheet *self,HTStyle *style)

{
  HTStyleSheet *local_18;
  HTStyle *scan;
  
  if (self->styles == style) {
    self->styles = style->next;
    local_18 = self;
  }
  else {
    for (scan = self->styles; scan != (HTStyle *)0x0; scan = scan->next) {
      if (scan->next == style) {
        scan->next = style->next;
        return self;
      }
    }
    local_18 = (HTStyleSheet *)0x0;
  }
  return local_18;
}



// WARNING: Unknown calling convention

HTStyleSheet * HTStyleSheetNew(void)

{
  HTStyleSheet *pHVar1;
  HTStyleSheet *self;
  
  pHVar1 = (HTStyleSheet *)calloc(1,8);
  if (pHVar1 == (HTStyleSheet *)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTStyle.c","HTStyleSheetNew");
  }
  return pHVar1;
}



// WARNING: Unknown calling convention

HTStyleSheet * HTStyleSheetFree(HTStyleSheet *self)

{
  HTStyle *self_00;
  HTStyle *style;
  
  while (self_00 = self->styles, self_00 != (HTStyle *)0x0) {
    self->styles = self_00->next;
    HTStyleFree(self_00);
  }
  if (self != (HTStyleSheet *)0x0) {
    free(self);
  }
  return (HTStyleSheet *)0x0;
}



// WARNING: Unknown calling convention

HTList * HTList_new(void)

{
  HTList *pHVar1;
  HTList *newList;
  
  pHVar1 = (HTList *)malloc(8);
  if (pHVar1 == (HTList *)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTList.c","HTList_new");
  }
  pHVar1->object = (void *)0x0;
  pHVar1->next = (HTList *)0x0;
  return pHVar1;
}



// WARNING: Unknown calling convention

void HTList_delete(HTList *me)

{
  HTList *pHVar1;
  HTList *current;
  
  pHVar1 = me;
  while (me = pHVar1, me != (HTList *)0x0) {
    pHVar1 = me->next;
    if (me != (HTList *)0x0) {
      free(me);
    }
  }
  return;
}



// WARNING: Unknown calling convention

HTList * HTList_reverse(HTList *start)

{
  HTList *pHVar1;
  HTList *succ;
  HTList *cur;
  
  if (((start != (HTList *)0x0) && (start->next != (HTList *)0x0)) &&
     (cur = start->next->next, cur != (HTList *)0x0)) {
    start->next->next = (HTList *)0x0;
    while (cur != (HTList *)0x0) {
      pHVar1 = cur->next;
      cur->next = start->next;
      start->next = cur;
      cur = pHVar1;
    }
  }
  return start;
}



// WARNING: Unknown calling convention

HTList * HTList_appendList(HTList *start,HTList *tail)

{
  FILE *__stream;
  HTList *local_18;
  HTList *temp;
  
  temp = start;
  if (start == (HTList *)0x0) {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTList: Trying to append list %p to a nonexisting list\n",tail);
    }
    local_18 = (HTList *)0x0;
  }
  else if ((tail == (HTList *)0x0) || (tail->next == (HTList *)0x0)) {
    local_18 = start;
  }
  else {
    for (; temp->next != (HTList *)0x0; temp = temp->next) {
    }
    temp->next = tail->next;
    tail->next = (HTList *)0x0;
    local_18 = start;
  }
  return local_18;
}



// WARNING: Unknown calling convention

void HTList_linkObject(HTList *me,void *newObject,HTList *newNode)

{
  FILE *pFVar1;
  
  if (me == (HTList *)0x0) {
    if (WWW_TraceFlag != '\0') {
      pFVar1 = TraceFP();
      fprintf((FILE *)pFVar1,"HTList: Trying to link object %p to a nonexisting list\n",newObject);
    }
  }
  else if ((newNode->object == (void *)0x0) && (newNode->next == (HTList *)0x0)) {
    newNode->object = newObject;
    newNode->next = me->next;
    me->next = newNode;
  }
  else {
    if (WWW_TraceFlag != '\0') {
      pFVar1 = TraceFP();
      fprintf((FILE *)pFVar1,"*** HTList: Refuse linking already linked obj ");
    }
    if (WWW_TraceFlag != '\0') {
      pFVar1 = TraceFP();
      fprintf((FILE *)pFVar1,"%p, node %p, list %p\n",newObject,newNode,me);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void HTList_addObject(HTList *me,void *newObject)

{
  HTList *pHVar1;
  FILE *__stream;
  HTList *newNode;
  
  if (me == (HTList *)0x0) {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTList: Trying to add object %p to a nonexisting list\n",newObject);
    }
  }
  else {
    pHVar1 = (HTList *)malloc(8);
    if (pHVar1 == (HTList *)0x0) {
      outofmem("../../../WWW/Library/Implementation/HTList.c","HTList_addObject");
    }
    pHVar1->object = newObject;
    pHVar1->next = me->next;
    me->next = pHVar1;
  }
  return;
}



// WARNING: Unknown calling convention

void HTList_appendObject(HTList *me,void *newObject)

{
  HTList *temp;
  
  temp = me;
  if ((me != (HTList *)0x0) && (newObject != (void *)0x0)) {
    for (; temp->next != (HTList *)0x0; temp = temp->next) {
    }
    HTList_addObject(temp,newObject);
  }
  return;
}



// WARNING: Unknown calling convention

void HTList_insertObjectAt(HTList *me,void *newObject,int pos)

{
  HTList *pHVar1;
  FILE *pFVar2;
  HTList *pHVar3;
  int Pos;
  HTList *prevNode;
  HTList *temp;
  HTList *newNode;
  
  temp = me;
  Pos = pos;
  if (me == (HTList *)0x0) {
    if (WWW_TraceFlag != '\0') {
      pFVar2 = TraceFP();
      fprintf((FILE *)pFVar2,"HTList: Trying to add object %p to a nonexisting list\n",newObject);
    }
  }
  else {
    if ((pos < 0) && (Pos = 0, WWW_TraceFlag != '\0')) {
      pFVar2 = TraceFP();
      fprintf((FILE *)pFVar2,"HTList: Treating negative object position %d as %d.\n",pos,0);
    }
    while (pHVar1 = temp->next, pHVar1 != (HTList *)0x0) {
      if (Pos == 0) {
        pHVar3 = (HTList *)malloc(8);
        if (pHVar3 == (HTList *)0x0) {
          outofmem("../../../WWW/Library/Implementation/HTList.c","HTList_addObjectAt");
        }
        pHVar3->object = newObject;
        pHVar3->next = pHVar1;
        if (temp == (HTList *)0x0) {
          return;
        }
        temp->next = pHVar3;
        return;
      }
      Pos = Pos + -1;
      temp = pHVar1;
    }
    if (-1 < Pos) {
      HTList_addObject(temp,newObject);
    }
  }
  return;
}



// WARNING: Unknown calling convention

BOOLEAN HTList_unlinkObject(HTList *me,void *oldObject)

{
  HTList *pHVar1;
  BOOLEAN local_15;
  HTList *prevNode;
  HTList *temp;
  
  temp = me;
  if ((me == (HTList *)0x0) || (pHVar1 = temp, oldObject == (void *)0x0)) {
LAB_08127d08:
    local_15 = '\0';
  }
  else {
    do {
      temp = pHVar1;
      if (temp->next == (HTList *)0x0) goto LAB_08127d08;
      pHVar1 = temp->next;
    } while (pHVar1->object != oldObject);
    temp->next = pHVar1->next;
    pHVar1->next = (HTList *)0x0;
    pHVar1->object = (void *)0x0;
    local_15 = '\x01';
  }
  return local_15;
}



// WARNING: Unknown calling convention

BOOLEAN HTList_removeObject(HTList *me,void *oldObject)

{
  HTList *__ptr;
  BOOLEAN local_15;
  HTList *prevNode;
  HTList *temp;
  
  temp = me;
  if ((me == (HTList *)0x0) || (__ptr = temp, oldObject == (void *)0x0)) {
LAB_08127d79:
    local_15 = '\0';
  }
  else {
    do {
      temp = __ptr;
      if (temp->next == (HTList *)0x0) goto LAB_08127d79;
      __ptr = temp->next;
    } while (__ptr->object != oldObject);
    temp->next = __ptr->next;
    if (__ptr != (HTList *)0x0) {
      free(__ptr);
    }
    local_15 = '\x01';
  }
  return local_15;
}



// WARNING: Unknown calling convention

void * HTList_removeObjectAt(HTList *me,int position)

{
  HTList *__ptr;
  int pos;
  HTList *prevNode;
  HTList *temp;
  
  temp = me;
  pos = position;
  if ((me != (HTList *)0x0) && (-1 < position)) {
    while (__ptr = temp->next, __ptr != (HTList *)0x0) {
      if (pos == 0) {
        temp->next = __ptr->next;
        if (__ptr != (HTList *)0x0) {
          free(__ptr);
        }
        return __ptr->object;
      }
      pos = pos + -1;
      temp = __ptr;
    }
  }
  return (void *)0x0;
}



// WARNING: Unknown calling convention

void * HTList_unlinkLastObject(HTList *me)

{
  HTList *pHVar1;
  void *local_18;
  void *lastObject;
  HTList *lastNode;
  
  if ((me == (HTList *)0x0) || (me->next == (HTList *)0x0)) {
    local_18 = (void *)0x0;
  }
  else {
    pHVar1 = me->next;
    local_18 = pHVar1->object;
    me->next = pHVar1->next;
    pHVar1->next = (HTList *)0x0;
    pHVar1->object = (void *)0x0;
  }
  return local_18;
}



// WARNING: Unknown calling convention

void * HTList_removeLastObject(HTList *me)

{
  HTList *__ptr;
  void *local_18;
  void *lastObject;
  HTList *lastNode;
  
  if ((me == (HTList *)0x0) || (me->next == (HTList *)0x0)) {
    local_18 = (void *)0x0;
  }
  else {
    __ptr = me->next;
    local_18 = __ptr->object;
    me->next = __ptr->next;
    if (__ptr != (HTList *)0x0) {
      free(__ptr);
    }
  }
  return local_18;
}



// WARNING: Unknown calling convention

void * HTList_removeFirstObject(HTList *me)

{
  void *local_18;
  void *firstObject;
  HTList *prevNode;
  HTList *temp;
  
  temp = me;
  if (me == (HTList *)0x0) {
    local_18 = (void *)0x0;
  }
  else {
    prevNode = me;
    if (me->next == (HTList *)0x0) {
      local_18 = (void *)0x0;
    }
    else {
      for (; temp->next != (HTList *)0x0; temp = temp->next) {
        prevNode = temp;
      }
      local_18 = temp->object;
      prevNode->next = (HTList *)0x0;
      if (temp != (HTList *)0x0) {
        free(temp);
      }
    }
  }
  return local_18;
}



// WARNING: Unknown calling convention

int HTList_count(HTList *me)

{
  int count;
  HTList *temp;
  
  temp = me;
  count = 0;
  if (me != (HTList *)0x0) {
    while (temp = temp->next, temp != (HTList *)0x0) {
      count = count + 1;
    }
  }
  return count;
}



// WARNING: Unknown calling convention

int HTList_indexOf(HTList *me,void *object)

{
  int position;
  HTList *temp;
  
  temp = me;
  position = 0;
  if (me != (HTList *)0x0) {
    while (temp = temp->next, temp != (HTList *)0x0) {
      if (temp->object == object) {
        return position;
      }
      position = position + 1;
    }
  }
  return -1;
}



// WARNING: Unknown calling convention

void * HTList_objectAt(HTList *me,int position)

{
  int pos;
  HTList *temp;
  
  temp = me;
  pos = position;
  if ((me != (HTList *)0x0) && (-1 < position)) {
    while (temp = temp->next, temp != (HTList *)0x0) {
      if (pos == 0) {
        return temp->object;
      }
      pos = pos + -1;
    }
  }
  return (void *)0x0;
}



// WARNING: Unknown calling convention

int strcasecomp8(char *a,char *b)

{
  wchar_t wVar1;
  int local_18;
  int diff;
  char *q;
  char *p;
  
  p = a;
  for (q = b; (*p != '\0' && (*q != '\0')); q = q + 1) {
    wVar1 = UPPER8((int)*p,(int)*q);
    if (wVar1 != L'\0') {
      return wVar1;
    }
    p = p + 1;
  }
  if (*p == '\0') {
    if (*q == '\0') {
      local_18 = 0;
    }
    else {
      local_18 = -1;
    }
  }
  else {
    local_18 = 1;
  }
  return local_18;
}



// WARNING: Unknown calling convention

int strncasecomp8(char *a,char *b,int n)

{
  wchar_t wVar1;
  int diff;
  char *q;
  char *p;
  
  p = a;
  q = b;
  while( true ) {
    if (a + n == p) {
      return 0;
    }
    if ((*p == '\0') || (*q == '\0')) break;
    wVar1 = UPPER8((int)*p,(int)*q);
    if (wVar1 != L'\0') {
      return wVar1;
    }
    p = p + 1;
    q = q + 1;
  }
  return (int)*p - (int)*q;
}



// WARNING: Unknown calling convention

int strcasecomp(char *a,char *b)

{
  ushort **ppuVar1;
  uint local_20;
  uint local_1c;
  int local_18;
  int diff;
  char *q;
  char *p;
  
  p = a;
  q = b;
  while( true ) {
    if ((*p == '\0') || (*q == '\0')) {
      if (*p == '\0') {
        if (*q == '\0') {
          local_18 = 0;
        }
        else {
          local_18 = -1;
        }
      }
      else {
        local_18 = 1;
      }
      return local_18;
    }
    ppuVar1 = __ctype_b_loc();
    if (((*ppuVar1)[(byte)*p] & 0x100) == 0) {
      local_20 = (uint)(byte)*p;
    }
    else {
      local_20 = tolower((uint)(byte)*p);
    }
    ppuVar1 = __ctype_b_loc();
    if (((*ppuVar1)[(byte)*q] & 0x100) == 0) {
      local_1c = (uint)(byte)*q;
    }
    else {
      local_1c = tolower((uint)(byte)*q);
    }
    if (local_20 - local_1c != 0) break;
    p = p + 1;
    q = q + 1;
  }
  return local_20 - local_1c;
}



// WARNING: Unknown calling convention

int strncasecomp(char *a,char *b,int n)

{
  ushort **ppuVar1;
  uint local_1c;
  uint local_18;
  int diff;
  char *q;
  char *p;
  
  p = a;
  q = b;
  while( true ) {
    if (a + n == p) {
      return 0;
    }
    if ((*p == '\0') || (*q == '\0')) break;
    ppuVar1 = __ctype_b_loc();
    if (((*ppuVar1)[(byte)*p] & 0x100) == 0) {
      local_1c = (uint)(byte)*p;
    }
    else {
      local_1c = tolower((uint)(byte)*p);
    }
    ppuVar1 = __ctype_b_loc();
    if (((*ppuVar1)[(byte)*q] & 0x100) == 0) {
      local_18 = (uint)(byte)*q;
    }
    else {
      local_18 = tolower((uint)(byte)*q);
    }
    if (local_1c - local_18 != 0) {
      return local_1c - local_18;
    }
    p = p + 1;
    q = q + 1;
  }
  return (int)*p - (int)*q;
}



// WARNING: Unknown calling convention

int strcasecomp_asterisk(char *a,char *b)

{
  int iVar1;
  ushort **ppuVar2;
  bool bVar3;
  uint local_1c;
  uint local_18;
  int done;
  int result;
  char *p;
  
  result = 0;
  bVar3 = false;
  do {
    if (result != 0) {
      return result;
    }
    if (bVar3) {
      return 0;
    }
    if (*a == '*') {
      for (p = b; (*p != '.' && (*p != '\0')); p = p + 1) {
        iVar1 = strcasecomp_asterisk(a + 1,p);
        if (iVar1 == 0) {
          b = p + -1;
          result = 0;
          bVar3 = true;
          goto LAB_08128520;
        }
      }
      if ((a[1] == '.') || (a[1] == '\0')) {
        b = p + -1;
        result = 0;
      }
      else {
        result = 1;
      }
    }
    else if (*b == '*') {
      result = strcasecomp_asterisk(b,a);
      bVar3 = result == 0;
    }
    else {
      if ((*a == '\0') || (*b == '\0')) {
        return (uint)(*a != *b);
      }
      ppuVar2 = __ctype_b_loc();
      if (((*ppuVar2)[(byte)*a] & 0x100) == 0) {
        local_1c = (uint)(byte)*a;
      }
      else {
        local_1c = tolower((uint)(byte)*a);
      }
      ppuVar2 = __ctype_b_loc();
      if (((*ppuVar2)[(byte)*b] & 0x100) == 0) {
        local_18 = (uint)(byte)*b;
      }
      else {
        local_18 = tolower((uint)(byte)*b);
      }
      if (local_1c != local_18) {
        return 1;
      }
    }
LAB_08128520:
    a = a + 1;
    b = b + 1;
  } while( true );
}



// WARNING: Unknown calling convention

char * HTSACopy(char **dest,char *src)

{
  size_t sVar1;
  char *pcVar2;
  size_t size;
  
  if (src == (char *)0x0) {
    if (*dest != (char *)0x0) {
      free(*dest);
      *dest = (char *)0x0;
    }
  }
  else if (*dest != src) {
    sVar1 = strlen(src);
    if (*dest != (char *)0x0) {
      free(*dest);
      *dest = (char *)0x0;
    }
    pcVar2 = (char *)malloc(sVar1 + 1);
    *dest = pcVar2;
    if (*dest == (char *)0x0) {
      outofmem("../../../WWW/Library/Implementation/HTString.c","HTSACopy");
    }
    memcpy(*dest,src,sVar1 + 1);
  }
  return *dest;
}



// WARNING: Unknown calling convention

char * HTSACat(char **dest,char *src)

{
  size_t sVar1;
  size_t sVar2;
  char *pcVar3;
  size_t length;
  
  if (((src != (char *)0x0) && (*src != '\0')) && (*dest != src)) {
    if (*dest == (char *)0x0) {
      sVar1 = strlen(src);
      pcVar3 = (char *)malloc(sVar1 + 1);
      *dest = pcVar3;
      if (*dest == (char *)0x0) {
        outofmem("../../../WWW/Library/Implementation/HTString.c","HTSACat");
      }
      strcpy(*dest,src);
    }
    else {
      sVar1 = strlen(*dest);
      sVar2 = strlen(src);
      pcVar3 = (char *)realloc(*dest,sVar2 + sVar1 + 1);
      *dest = pcVar3;
      if (*dest == (char *)0x0) {
        outofmem("../../../WWW/Library/Implementation/HTString.c","HTSACat");
      }
      strcpy(*dest + sVar1,src);
    }
  }
  return *dest;
}



// WARNING: Unknown calling convention

void HTSAFree_extra(char *s)

{
  free(s + -4);
  return;
}



// WARNING: Unknown calling convention

char * HTSACopy_extra(char **dest,char *src)

{
  size_t sVar1;
  uint __n;
  char *pcVar2;
  size_t size;
  size_t srcsize;
  
  if (src == (char *)0x0) {
    if (*dest != (char *)0x0) {
      **dest = '\0';
    }
  }
  else {
    sVar1 = strlen(src);
    __n = sVar1 + 1;
    size = 0;
    if (*dest != (char *)0x0) {
      size = *(size_t *)(*dest + -4);
    }
    if (size < __n) {
      if (*dest != (char *)0x0) {
        HTSAFree_extra(*dest);
        *dest = (char *)0x0;
      }
      pcVar2 = (char *)malloc(__n * 2 + 4);
      *dest = pcVar2;
      if (*dest == (char *)0x0) {
        outofmem("../../../WWW/Library/Implementation/HTString.c","HTSACopy_extra");
      }
      *(uint *)*dest = __n * 2;
      *dest = *dest + 4;
    }
    memcpy(*dest,src,__n);
  }
  return *dest;
}



// WARNING: Unknown calling convention

char * HTNextField(char **pstr)

{
  char *local_18;
  char *start;
  char *p;
  
  for (p = *pstr; (*p != '\0' && ((byte)*p < 0x21)); p = p + 1) {
  }
  if (*p == '\0') {
    *pstr = p;
    local_18 = (char *)0x0;
  }
  else {
    if (*p == '\"') {
      start = p + 1;
      for (p = start; (*p != '\0' && (*p != '\"')); p = p + 1) {
        if ((*p == '\\') && (p[1] != '\0')) {
          p = p + 1;
        }
      }
    }
    else {
      start = p;
      for (; (*p != '\0' && (0x20 < (byte)*p)); p = p + 1) {
      }
    }
    if (*p != '\0') {
      *p = '\0';
      p = p + 1;
    }
    *pstr = p;
    local_18 = start;
  }
  return local_18;
}



// WARNING: Unknown calling convention

char * HTNextTok(char **pstr,char *delims,char *bracks,char *found)

{
  char cVar1;
  bool bVar2;
  bool bVar3;
  char *pcVar4;
  bool bVar5;
  bool bVar6;
  char *local_34;
  int comment_level;
  char *start;
  char *p;
  char closer;
  BOOLEAN get_closing_char_too;
  BOOLEAN get_comments;
  BOOLEAN skip_comments;
  BOOLEAN get_blanks;
  
  p = *pstr;
  start = (char *)0x0;
  bVar6 = false;
  if ((pstr == (char **)0x0) || (*pstr == (char *)0x0)) {
    local_34 = (char *)0x0;
  }
  else {
    if (delims == (char *)0x0) {
      delims = " ;,=";
    }
    if (bracks == (char *)0x0) {
      bracks = "<\"";
    }
    pcVar4 = strchr(delims,0x20);
    if ((pcVar4 == (char *)0x0) && (pcVar4 = strchr(bracks,0x20), pcVar4 == (char *)0x0)) {
      bVar2 = true;
    }
    else {
      bVar2 = false;
    }
    pcVar4 = strchr(bracks,0x28);
    bVar5 = pcVar4 != (char *)0x0;
    if (((bVar5) || (pcVar4 = strchr(delims,0x28), pcVar4 != (char *)0x0)) || (bVar2)) {
      bVar3 = false;
    }
    else {
      bVar3 = true;
    }
    for (; ((*p != '\0' && (!bVar2)) && ((byte)*p < 0x21)); p = p + 1) {
    }
    if (*p == '\0') {
      *pstr = p;
      if (found != (char *)0x0) {
        *found = '\0';
      }
      local_34 = (char *)0x0;
    }
    else {
LAB_08128a09:
      while( true ) {
        while ((*p != '\0' &&
               (((!bVar2 && ((byte)*p < 0x21)) ||
                (pcVar4 = strchr(delims,(int)*p), pcVar4 != (char *)0x0))))) {
          p = p + 1;
        }
        if (*p == '\0') {
          *pstr = p;
          if (found != (char *)0x0) {
            *found = p[-1];
          }
          return (char *)0x0;
        }
        if ((*p != '(') || ((!bVar3 && (!bVar5)))) break;
        comment_level = 0;
        if ((bVar5) && (start == (char *)0x0)) {
          start = p + 1;
        }
        while ((*p != '\0' &&
               ((*p != ')' || (comment_level = comment_level + -1, 0 < comment_level))))) {
          if (*p == '(') {
            comment_level = comment_level + 1;
          }
          else if (*p == '\"') {
            while ((pcVar4 = p, p = pcVar4 + 1, *p != '\0' && (*p != '\"'))) {
              if ((*p == '\\') && (pcVar4[2] != '\0')) {
                p = pcVar4 + 2;
              }
            }
            if (*p == '\0') break;
          }
          if ((*p == '\\') && (p[1] != '\0')) {
            p = p + 1;
          }
          p = p + 1;
        }
        if (bVar5) goto LAB_08128e17;
        if (*p != '\0') {
          p = p + 1;
        }
        if (bVar6) {
          if ((*p == '\0') ||
             ((pcVar4 = strchr(bracks,(int)*p), pcVar4 == (char *)0x0 &&
              (pcVar4 = strchr(delims,(int)*p), pcVar4 != (char *)0x0)))) goto LAB_08128e17;
          pcVar4 = strchr(bracks,(int)*p);
          bVar6 = pcVar4 != (char *)0x0;
        }
      }
      pcVar4 = strchr(bracks,(int)*p);
      if (pcVar4 != (char *)0x0) {
        cVar1 = *p;
        if (cVar1 == '<') {
          closer = '>';
        }
        else if (cVar1 < '=') {
          if (cVar1 == ':') {
            closer = ';';
          }
          else {
LAB_08128c4e:
            closer = *p;
          }
        }
        else if (cVar1 == '[') {
          closer = ']';
        }
        else {
          if (cVar1 != '{') goto LAB_08128c4e;
          closer = '}';
        }
        if (start == (char *)0x0) {
          start = p + 1;
          p = start;
        }
        for (; (*p != '\0' && (*p != closer)); p = p + 1) {
          if ((*p == '\\') && (p[1] != '\0')) {
            p = p + 1;
          }
        }
        if (((!bVar6) || (p = p + 1, *p == '\0')) ||
           ((pcVar4 = strchr(bracks,(int)*p), pcVar4 == (char *)0x0 &&
            (pcVar4 = strchr(delims,(int)*p), pcVar4 != (char *)0x0)))) goto LAB_08128e17;
        pcVar4 = strchr(bracks,(int)*p);
        bVar6 = pcVar4 != (char *)0x0;
        goto LAB_08128a09;
      }
      if (start == (char *)0x0) {
        start = p;
      }
      while ((*p != '\0' &&
             ((((bVar2 || (0x20 < (byte)*p)) &&
               (pcVar4 = strchr(bracks,(int)*p), pcVar4 == (char *)0x0)) &&
              (pcVar4 = strchr(delims,(int)*p), pcVar4 == (char *)0x0))))) {
        p = p + 1;
      }
      if ((*p != '\0') && (pcVar4 = strchr(bracks,(int)*p), pcVar4 != (char *)0x0)) {
        bVar6 = true;
        goto LAB_08128a09;
      }
      if ((*p == '(') && (bVar3)) {
        *pstr = p;
        HTNextTok(pstr,(char *)0x0,"(",found);
        *p = '\0';
        if ((*pstr != (char *)0x0) && (**pstr != '\0')) {
          *pstr = *pstr + 1;
        }
        return start;
      }
LAB_08128e17:
      if (found != (char *)0x0) {
        *found = *p;
      }
      if (*p != '\0') {
        *p = '\0';
        p = p + 1;
      }
      *pstr = p;
      local_34 = start;
    }
  }
  return local_34;
}



// WARNING: Unknown calling convention

char * HTAlloc(char *ptr,size_t length)

{
  if (ptr == (char *)0x0) {
    ptr = (char *)malloc(length);
  }
  else {
    ptr = (char *)realloc(ptr,length);
  }
  if (ptr == (char *)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTString.c","HTAlloc");
  }
  return ptr;
}



// WARNING: Unknown calling convention

char * StrAllocVsprintf(char **pstr,size_t dst_len,char *fmt,va_list *ap)

{
  int iVar1;
  size_t sVar2;
  char *local_18;
  int new_len;
  int src_len;
  char *temp;
  char *result;
  
  result = (char *)0x0;
  temp = (char *)0x0;
  if ((((pstr != (char **)0x0) && (dst_len == 0)) && (*pstr != (char *)0x0)) &&
     (*pstr != (char *)0x0)) {
    free(*pstr);
    *pstr = (char *)0x0;
  }
  iVar1 = vasprintf(&temp,fmt,*ap);
  if (-1 < iVar1) {
    if (dst_len == 0) {
      result = temp;
    }
    else {
      sVar2 = strlen(temp);
      if (pstr == (char **)0x0) {
        local_18 = (char *)0x0;
      }
      else {
        local_18 = *pstr;
      }
      result = HTAlloc(local_18,sVar2 + dst_len + 1);
      if (result != (char *)0x0) {
        strcpy(result + dst_len,temp);
      }
      free(temp);
    }
  }
  if (pstr != (char **)0x0) {
    *pstr = result;
  }
  return result;
}



// WARNING: Unknown calling convention

char * HTSprintf(char **pstr,char *fmt,...)

{
  char *pcVar1;
  va_list ap;
  size_t inuse;
  char *result;
  
  result = (char *)0x0;
  inuse = 0;
  ap = &stack0x0000000c;
  if ((pstr != (char **)0x0) && (*pstr != (char *)0x0)) {
    inuse = strlen(*pstr);
  }
  pcVar1 = StrAllocVsprintf(pstr,inuse,fmt,&ap);
  return pcVar1;
}



// WARNING: Unknown calling convention

char * HTSprintf0(char **pstr,char *fmt,...)

{
  char *pcVar1;
  va_list ap;
  char *result;
  
  result = (char *)0x0;
  ap = &stack0x0000000c;
  pcVar1 = StrAllocVsprintf(pstr,0,fmt,&ap);
  return pcVar1;
}



// WARNING: Unknown calling convention

char * HTQuoteParameter(char *parameter)

{
  size_t sVar1;
  ushort **ppuVar2;
  char *pcVar3;
  char *result;
  size_t quoted;
  size_t n;
  size_t last;
  size_t i;
  
  quoted = 0;
  if (parameter == (char *)0x0) {
    parameter = "";
  }
  sVar1 = strlen(parameter);
  i = 0;
  do {
    if (sVar1 <= i) {
      pcVar3 = (char *)malloc(quoted * 5 + sVar1 + 3);
      if (pcVar3 == (char *)0x0) {
        outofmem("../../../WWW/Library/Implementation/HTString.c","HTQuoteParameter");
      }
      if (quoted != 0) {
        *pcVar3 = '\'';
      }
      n = (size_t)(quoted != 0);
      for (i = 0; i < sVar1; i = i + 1) {
        if (parameter[i] == '\'') {
          pcVar3[n] = '\'';
          pcVar3[n + 1] = '\"';
          pcVar3[n + 2] = parameter[i];
          pcVar3[n + 3] = '\"';
          pcVar3[n + 4] = '\'';
          n = n + 5;
        }
        else {
          pcVar3[n] = parameter[i];
          n = n + 1;
        }
      }
      if (quoted != 0) {
        pcVar3[n] = '\'';
        n = n + 1;
      }
      pcVar3[n] = '\0';
      return pcVar3;
    }
    pcVar3 = strchr("\\&#$^*?(){}<>\"\';`|",(int)parameter[i]);
    if (pcVar3 == (char *)0x0) {
      ppuVar2 = __ctype_b_loc();
      if (((*ppuVar2)[(byte)parameter[i]] & 0x2000) != 0) goto LAB_081290bf;
    }
    else {
LAB_081290bf:
      quoted = quoted + 1;
    }
    i = i + 1;
  } while( true );
}



// WARNING: Unknown calling convention

int HTCountCommandArgs(char *command)

{
  int number;
  
  number = 0;
  for (; *command != '\0'; command = command + 1) {
    if ((*command == '%') && (command[1] == 's')) {
      number = number + 1;
    }
  }
  return number;
}



// WARNING: Unknown calling convention

char * HTAfterCommandArg(char *command,int number)

{
  for (; (0 < number && (*command != '\0')); command = command + 1) {
    if ((*command == '%') && (command[1] == 's')) {
      number = number + -1;
      command = command + 1;
    }
  }
  return command;
}



// WARNING: Unknown calling convention

void HTAddXpand(char **result,char *command,int number,char *parameter)

{
  char *pcVar1;
  FILE *__stream;
  size_t local_1c;
  size_t len;
  char *next;
  char *last;
  
  if (0 < number) {
    pcVar1 = HTAfterCommandArg(command,number + -1);
    next = pcVar1;
    if ((number < 2) && (*result != (char *)0x0)) {
      free(*result);
      *result = (char *)0x0;
    }
    for (; *next != '\0'; next = next + 1) {
      if ((*next == '%') && (next[1] == 's')) {
        if (next != pcVar1) {
          if (*result == (char *)0x0) {
            local_1c = 0;
          }
          else {
            local_1c = strlen(*result);
          }
          HTSACat(result,pcVar1);
          (*result)[(int)(next + (local_1c - (int)pcVar1))] = '\0';
        }
        HTSACat(result,parameter);
        if (WWW_TraceFlag == '\0') {
          return;
        }
        pcVar1 = *result;
        __stream = TraceFP();
        fprintf((FILE *)__stream,"PARAM-EXP:%s\n",pcVar1);
        return;
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

void HTAddToCmd(char **result,char *command,int number,char *string)

{
  char *pcVar1;
  FILE *__stream;
  size_t local_1c;
  size_t len;
  char *next;
  char *last;
  
  if (0 < number) {
    pcVar1 = HTAfterCommandArg(command,number + -1);
    if ((number < 2) && (*result != (char *)0x0)) {
      free(*result);
      *result = (char *)0x0;
    }
    next = pcVar1;
    if (string == (char *)0x0) {
      string = "";
    }
    for (; *next != '\0'; next = next + 1) {
      if ((*next == '%') && (next[1] == 's')) {
        if (next != pcVar1) {
          if (*result == (char *)0x0) {
            local_1c = 0;
          }
          else {
            local_1c = strlen(*result);
          }
          HTSACat(result,pcVar1);
          (*result)[(int)(next + (local_1c - (int)pcVar1))] = '\0';
        }
        HTSACat(result,string);
        if (WWW_TraceFlag == '\0') {
          return;
        }
        pcVar1 = *result;
        __stream = TraceFP();
        fprintf((FILE *)__stream,"PARAM-ADD:%s\n",pcVar1);
        return;
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

void HTAddParam(char **result,char *command,int number,char *parameter)

{
  char *string;
  char *quoted;
  
  if (0 < number) {
    string = HTQuoteParameter(parameter);
    HTAddToCmd(result,command,number,string);
    if (string != (char *)0x0) {
      free(string);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void HTEndParam(char **result,char *command,int number)

{
  int iVar1;
  char *pcVar2;
  FILE *__stream;
  int count;
  char *last;
  
  iVar1 = HTCountCommandArgs(command);
  if (iVar1 < number) {
    number = iVar1;
  }
  pcVar2 = HTAfterCommandArg(command,number);
  if (*pcVar2 != '\0') {
    HTSACat(result,pcVar2);
  }
  if (WWW_TraceFlag != '\0') {
    pcVar2 = *result;
    __stream = TraceFP();
    fprintf((FILE *)__stream,"PARAM-END:%s\n",pcVar2);
  }
  return;
}



// WARNING: Unknown calling convention

void HTSABCopy(bstring **dest,char *src,int len)

{
  FILE *pFVar1;
  bstring *pbVar2;
  char *pcVar3;
  int local_18;
  uint need;
  bstring *t;
  
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x10U) != 0)) {
    pFVar1 = TraceFP();
    fprintf((FILE *)pFVar1,"HTSABCopy(%p, %p, %d)\n",dest,src,len);
  }
  HTSABFree(dest);
  if (src != (char *)0x0) {
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x10U) != 0)) {
      if (WWW_TraceFlag != '\0') {
        pFVar1 = TraceFP();
        fprintf((FILE *)pFVar1,"===    %4d:",len);
      }
      trace_bstring2(src,len);
      if (WWW_TraceFlag != '\0') {
        pFVar1 = TraceFP();
        fprintf((FILE *)pFVar1,"\n");
      }
    }
    pbVar2 = (bstring *)malloc(8);
    if (pbVar2 == (bstring *)0x0) {
      outofmem("../../../WWW/Library/Implementation/HTString.c","HTSABCopy");
    }
    pcVar3 = (char *)malloc(len + 1);
    pbVar2->str = pcVar3;
    if (pbVar2->str == (char *)0x0) {
      outofmem("../../../WWW/Library/Implementation/HTString.c","HTSABCopy");
    }
    memcpy(pbVar2->str,src,len);
    pbVar2->len = len;
    pbVar2->str[pbVar2->len] = '\0';
    *dest = pbVar2;
  }
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x10U) != 0)) {
    if (WWW_TraceFlag != '\0') {
      if (*dest == (bstring *)0x0) {
        local_18 = 0;
      }
      else {
        local_18 = (*dest)->len;
      }
      pFVar1 = TraceFP();
      fprintf((FILE *)pFVar1,"=>     %4d:",local_18);
    }
    trace_bstring(*dest);
    if (WWW_TraceFlag != '\0') {
      pFVar1 = TraceFP();
      fprintf((FILE *)pFVar1,"\n");
    }
  }
  return;
}



// WARNING: Unknown calling convention

void HTSABCopy0(bstring **dest,char *src)

{
  size_t len;
  
  len = strlen(src);
  HTSABCopy(dest,src,len);
  return;
}



// WARNING: Unknown calling convention

void HTSABCat(bstring **dest,char *src,int len)

{
  FILE *pFVar1;
  char *pcVar2;
  int local_18;
  uint length;
  uint need;
  bstring *t;
  
  t = *dest;
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x10U) != 0)) {
    pFVar1 = TraceFP();
    fprintf((FILE *)pFVar1,"HTSABCat(%p, %p, %d)\n",dest,src,len);
  }
  if (src != (char *)0x0) {
    if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x10U) != 0)) {
      if (WWW_TraceFlag != '\0') {
        pFVar1 = TraceFP();
        fprintf((FILE *)pFVar1,"===    %4d:",len);
      }
      trace_bstring2(src,len);
      if (WWW_TraceFlag != '\0') {
        pFVar1 = TraceFP();
        fprintf((FILE *)pFVar1,"\n");
      }
    }
    if (t == (bstring *)0x0) {
      t = (bstring *)calloc(1,8);
      if (t == (bstring *)0x0) {
        outofmem("../../../WWW/Library/Implementation/HTString.c","HTSACat");
      }
      pcVar2 = (char *)malloc(len + 1U);
      t->str = pcVar2;
    }
    else {
      pcVar2 = (char *)realloc(t->str,t->len + len + 1U);
      t->str = pcVar2;
      if (t->str == (char *)0x0) {
        outofmem("../../../WWW/Library/Implementation/HTString.c","HTSACat");
      }
    }
    if (t->str == (char *)0x0) {
      outofmem("../../../WWW/Library/Implementation/HTString.c","HTSACat");
    }
    memcpy(t->str + t->len,src,len);
    t->len = t->len + len;
    t->str[t->len] = '\0';
    *dest = t;
  }
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 0x10U) != 0)) {
    if (WWW_TraceFlag != '\0') {
      if (*dest == (bstring *)0x0) {
        local_18 = 0;
      }
      else {
        local_18 = (*dest)->len;
      }
      pFVar1 = TraceFP();
      fprintf((FILE *)pFVar1,"=>     %4d:",local_18);
    }
    trace_bstring(*dest);
    if (WWW_TraceFlag != '\0') {
      pFVar1 = TraceFP();
      fprintf((FILE *)pFVar1,"\n");
    }
  }
  return;
}



// WARNING: Unknown calling convention

void HTSABCat0(bstring **dest,char *src)

{
  size_t len;
  
  len = strlen(src);
  HTSABCat(dest,src,len);
  return;
}



// WARNING: Unknown calling convention

BOOLEAN HTSABEql(bstring *a,bstring *b)

{
  int iVar1;
  int local_20;
  int local_1c;
  BOOLEAN local_15;
  uint len_b;
  uint len_a;
  
  if (a == (bstring *)0x0) {
    local_20 = 0;
  }
  else {
    local_20 = a->len;
  }
  if (b == (bstring *)0x0) {
    local_1c = 0;
  }
  else {
    local_1c = b->len;
  }
  if (local_20 == local_1c) {
    if (local_20 != 0) {
      iVar1 = memcmp(a->str,b->str,a->len);
      if (iVar1 != 0) goto LAB_08129ae3;
    }
    local_15 = '\x01';
  }
  else {
LAB_08129ae3:
    local_15 = '\0';
  }
  return local_15;
}



// WARNING: Unknown calling convention

void HTSABFree(bstring **ptr)

{
  if (*ptr != (bstring *)0x0) {
    if ((*ptr)->str != (char *)0x0) {
      free((*ptr)->str);
      (*ptr)->str = (char *)0x0;
    }
    if (*ptr != (bstring *)0x0) {
      free(*ptr);
      *ptr = (bstring *)0x0;
    }
    *ptr = (bstring *)0x0;
  }
  return;
}



// WARNING: Unknown calling convention

bstring * HTBprintf(bstring **pstr,char *fmt,...)

{
  size_t len;
  va_list ap;
  char *temp;
  bstring *result;
  
  result = (bstring *)0x0;
  temp = (char *)0x0;
  ap = &stack0x0000000c;
  temp = StrAllocVsprintf(&temp,0,fmt,&ap);
  if ((temp != (char *)0x0) && (*temp != '\0')) {
    len = strlen(temp);
    HTSABCat(pstr,temp,len);
  }
  if (temp != (char *)0x0) {
    free(temp);
  }
  return *pstr;
}



// WARNING: Unknown calling convention

void trace_bstring2(char *text,int size)

{
  uint __c;
  ushort **ppuVar1;
  FILE *pFVar2;
  int ch;
  int n;
  
  if (text != (char *)0x0) {
    for (n = 0; n < size; n = n + 1) {
      __c = (uint)(byte)text[n];
      if (__c == 0xc) {
        pFVar2 = TraceFP();
        fwrite(&DAT_0818bc11,1,2,(FILE *)pFVar2);
      }
      else if (__c < 0xd) {
        if (__c == 9) {
          pFVar2 = TraceFP();
          fwrite(&DAT_0818bc0e,1,2,(FILE *)pFVar2);
        }
        else {
LAB_08129ce2:
          ppuVar1 = __ctype_b_loc();
          if ((((*ppuVar1)[__c] & 0x4000) == 0) &&
             (ppuVar1 = __ctype_b_loc(), ((*ppuVar1)[__c] & 0x2000) == 0)) {
            pFVar2 = TraceFP();
            fprintf((FILE *)pFVar2,"\\%03o",__c);
          }
          else {
            pFVar2 = TraceFP();
            fputc(__c,(FILE *)pFVar2);
          }
        }
      }
      else if (__c == 0xd) {
        pFVar2 = TraceFP();
        fwrite(&DAT_0818bc0b,1,2,(FILE *)pFVar2);
      }
      else {
        if (__c != 0x5c) goto LAB_08129ce2;
        pFVar2 = TraceFP();
        fwrite(&DAT_0818bc08,1,2,(FILE *)pFVar2);
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

void trace_bstring(bstring *data)

{
  int local_c;
  char *local_8;
  
  if (data == (bstring *)0x0) {
    local_c = 0;
    local_8 = (char *)0x0;
  }
  else {
    local_c = data->len;
    local_8 = data->str;
  }
  trace_bstring2(local_8,local_c);
  return;
}



// WARNING: Unknown calling convention

int HTAddRule(HTRuleOp op,char *pattern,char *equiv,char *cond_op,char *cond)

{
  FILE *pFVar1;
  char *local_1c;
  char *pEquiv;
  char *pPattern;
  rule *temp;
  
  pPattern = (char *)0x0;
  temp = (rule *)calloc(1,0x18);
  if (temp == (rule *)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTRules.c","HTAddRule");
  }
  if (equiv == (char *)0x0) {
    temp->equiv = (char *)0x0;
  }
  else {
    pEquiv = (char *)0x0;
    HTSACopy(&pEquiv,equiv);
    temp->equiv = pEquiv;
  }
  if (cond_op != (char *)0x0) {
    HTSACopy(&temp->condition_op,cond_op);
    HTSACopy(&temp->condition,cond);
  }
  HTSACopy(&pPattern,pattern);
  temp->pattern = pPattern;
  temp->op = op;
  if (equiv == (char *)0x0) {
    if (WWW_TraceFlag != '\0') {
      pFVar1 = TraceFP();
      fprintf((FILE *)pFVar1,"Rule: For `%s\' op %d",pattern,op);
    }
  }
  else if (WWW_TraceFlag != '\0') {
    pFVar1 = TraceFP();
    fprintf((FILE *)pFVar1,"Rule: For `%s\' op %d `%s\'",pattern,op,equiv);
  }
  if (cond_op == (char *)0x0) {
    if (WWW_TraceFlag != '\0') {
      pFVar1 = TraceFP();
      fprintf((FILE *)pFVar1,"\n");
    }
  }
  else if (WWW_TraceFlag != '\0') {
    if (cond == (char *)0x0) {
      local_1c = "(null)";
    }
    else {
      local_1c = cond;
    }
    pFVar1 = TraceFP();
    fprintf((FILE *)pFVar1,"\t%s %s\n",cond_op,local_1c);
  }
  temp->next = (_rule *)0x0;
  if (rule_tail == (rule *)0x0) {
    rules = temp;
  }
  else {
    rule_tail->next = temp;
  }
  rule_tail = temp;
  return 0;
}



// WARNING: Unknown calling convention

void HTClearRules(void)

{
  char **ppcVar1;
  rule *__ptr;
  rule *prVar2;
  rule *temp;
  
  while (__ptr = rules, rules != (rule *)0x0) {
    prVar2 = rules->next;
    if (rules->pattern != (char *)0x0) {
      ppcVar1 = &rules->pattern;
      rules = rules->next;
      free(*ppcVar1);
      __ptr->pattern = (char *)0x0;
      prVar2 = rules;
    }
    rules = prVar2;
    if (__ptr->equiv != (char *)0x0) {
      free(__ptr->equiv);
      __ptr->equiv = (char *)0x0;
    }
    if (__ptr->condition_op != (char *)0x0) {
      free(__ptr->condition_op);
      __ptr->condition_op = (char *)0x0;
    }
    if (__ptr->condition != (char *)0x0) {
      free(__ptr->condition);
      __ptr->condition = (char *)0x0;
    }
    if (__ptr != (rule *)0x0) {
      free(__ptr);
    }
  }
  rule_tail = (rule *)0x0;
  return;
}



// WARNING: Unknown calling convention

BOOLEAN rule_cond_ok(rule *r)

{
  char *pcVar1;
  int iVar2;
  FILE *pFVar3;
  BOOLEAN local_1d;
  char *local_1c;
  BOOLEAN result;
  
  if (r->condition_op == (char *)0x0) {
    local_1d = '\x01';
  }
  else {
    iVar2 = strcmp(r->condition_op,"if");
    if ((iVar2 != 0) && (iVar2 = strcmp(r->condition_op,"unless"), iVar2 != 0)) {
      if (WWW_TraceFlag != '\0') {
        pcVar1 = r->condition_op;
        pFVar3 = TraceFP();
        fprintf((FILE *)pFVar3,"....... rule ignored, unrecognized `%s\'!\n",pcVar1);
      }
      return '\0';
    }
    iVar2 = strcmp(r->condition,"redirected");
    if (iVar2 == 0) {
      result = 0 < redirection_attempts;
    }
    else {
      iVar2 = strcmp(r->condition,"userspec");
      if (iVar2 != 0) {
        if (WWW_TraceFlag != '\0') {
          if (r->condition == (char *)0x0) {
            local_1c = "(null)";
          }
          else {
            local_1c = r->condition;
          }
          pcVar1 = r->condition_op;
          pFVar3 = TraceFP();
          fprintf((FILE *)pFVar3,"....... rule ignored, unrecognized `%s %s\'!\n",pcVar1,local_1c);
        }
        return '\0';
      }
      result = LYUserSpecifiedURL;
    }
    iVar2 = strcmp(r->condition_op,"if");
    if (iVar2 == 0) {
      local_1d = result;
    }
    else {
      local_1d = result == '\0';
    }
  }
  return local_1d;
}



// WARNING: Unknown calling convention

char * HTTranslate(char *required)

{
  HTRuleOp HVar1;
  char *pcVar2;
  BOOLEAN BVar3;
  size_t sVar4;
  size_t sVar5;
  int iVar6;
  char *pcVar7;
  FILE *pFVar8;
  char *local_78;
  char *local_74;
  char *local_70;
  char *local_68;
  char *local_64;
  char *local_60;
  char *local_58;
  char *local_54;
  char *local_50;
  char *p2;
  char *ins;
  char *prot_file;
  char *eff_ids;
  char *local_copy;
  char *q;
  int m;
  char *p;
  int permitredir_flag;
  int proxy_none_flag;
  char *pMsg;
  char *msgtmp;
  char *current;
  rule *r;
  
  current = (char *)0x0;
  msgtmp = (char *)0x0;
  proxy_none_flag = 0;
  permitredir_flag = 0;
  HTSACopy(&current,required);
  HTAA_clearProtections();
  r = rules;
  do {
    if (r == (rule *)0x0) {
      if (proxy_none_flag == 0) {
        local_58 = current;
      }
      else {
        p2 = (char *)0x0;
        HTSACopy(&p2,"NoProxy=");
        HTSACat(&p2,current);
        if (current != (char *)0x0) {
          free(current);
        }
        local_58 = p2;
      }
      return local_58;
    }
    p = r->pattern;
    m = 0;
    q = current;
    for (; ((*p != '\0' && (*q != '\0')) && (*p == *q)); p = p + 1) {
      q = q + 1;
    }
    if (*p == '*') {
      sVar4 = strlen(q);
      sVar5 = strlen(p + 1);
      m = sVar4 - sVar5;
      if ((-1 < m) && (iVar6 = strcmp(q + m,p + 1), iVar6 == 0)) goto LAB_0812a2c2;
    }
    else if (*p == *q) {
LAB_0812a2c2:
      BVar3 = rule_cond_ok(r);
      pcVar7 = current;
      if (BVar3 != '\0') {
        switch(r->op) {
        case HT_Invalid:
        case HT_Fail:
          if (WWW_TraceFlag != '\0') {
            pFVar8 = TraceFP();
            fprintf((FILE *)pFVar8,"HTRule: *** FAIL `%s\'\n",pcVar7);
          }
          if (current != (char *)0x0) {
            free(current);
          }
          return (char *)0x0;
        case HT_Pass:
          if (r->equiv == (char *)0x0) {
            if (proxy_none_flag != 0) {
              p2 = (char *)0x0;
              HTSACopy(&p2,"NoProxy=");
              HTSACat(&p2,current);
              if (current != (char *)0x0) {
                free(current);
              }
              current = p2;
            }
            pcVar7 = current;
            if (WWW_TraceFlag != '\0') {
              pFVar8 = TraceFP();
              fprintf((FILE *)pFVar8,"HTRule: Pass `%s\'\n",pcVar7);
            }
            return current;
          }
        case HT_Map:
        case HT_Redirect:
        case HT_RedirectPerm:
          if (*p == *q) {
            if (WWW_TraceFlag != '\0') {
              pcVar2 = r->equiv;
              pFVar8 = TraceFP();
              fprintf((FILE *)pFVar8,"For `%s\' using `%s\'\n",pcVar7,pcVar2);
            }
            HTSACopy(&current,r->equiv);
          }
          else {
            ins = strchr(r->equiv,0x2a);
            if (ins == (char *)0x0) {
              p2 = (char *)0x0;
              HTSACopy(&p2,r->equiv);
              pcVar2 = current;
              pcVar7 = p2;
              if (WWW_TraceFlag != '\0') {
                pFVar8 = TraceFP();
                fprintf((FILE *)pFVar8,"For `%s\' using `%s\'\n",pcVar2,pcVar7);
              }
              if (current != (char *)0x0) {
                free(current);
              }
              current = p2;
            }
            else {
              p2 = (char *)0x0;
              HTSprintf0(&p2,"%.*s%.*s%s",(int)ins - (int)r->equiv,r->equiv,m,q,ins + 1);
              pcVar2 = current;
              pcVar7 = p2;
              if (WWW_TraceFlag != '\0') {
                pFVar8 = TraceFP();
                fprintf((FILE *)pFVar8,"For `%s\' using `%s\'\n",pcVar2,pcVar7);
              }
              if (current != (char *)0x0) {
                free(current);
              }
              current = p2;
            }
          }
          pcVar7 = current;
          if (r->op == HT_Pass) {
            if (proxy_none_flag != 0) {
              p2 = (char *)0x0;
              HTSACopy(&p2,"NoProxy=");
              HTSACat(&p2,current);
              if (current != (char *)0x0) {
                free(current);
              }
              current = p2;
            }
            pcVar7 = current;
            if (WWW_TraceFlag != '\0') {
              pFVar8 = TraceFP();
              fprintf((FILE *)pFVar8,"HTRule: ...and pass `%s\'\n",pcVar7);
            }
            return current;
          }
          if (r->op == HT_Redirect) {
            if (WWW_TraceFlag != '\0') {
              pFVar8 = TraceFP();
              fprintf((FILE *)pFVar8,"HTRule: ...and redirect to `%s\'\n",pcVar7);
            }
            HTPermitRedir = permitredir_flag == 1;
            redirecting_url = current;
            return (char *)0x0;
          }
          if (r->op == HT_RedirectPerm) {
            if (WWW_TraceFlag != '\0') {
              pFVar8 = TraceFP();
              fprintf((FILE *)pFVar8,"HTRule: ...and redirect like 301 to `%s\'\n",pcVar7);
            }
            HTPermitRedir = permitredir_flag == 1;
            redirecting_url = current;
            permanent_redirection = '\x01';
            return (char *)0x0;
          }
          break;
        case HT_DefProt:
        case HT_Protect:
          local_copy = (char *)0x0;
          eff_ids = (char *)0x0;
          prot_file = (char *)0x0;
          if (WWW_TraceFlag != '\0') {
            if (r->equiv == (char *)0x0) {
              if (r->op == HT_Protect) {
                local_74 = "DEFAULT";
              }
              else {
                local_74 = "NULL!!";
              }
              local_78 = local_74;
            }
            else {
              local_78 = r->equiv;
            }
            if (r->op == HT_Protect) {
              local_70 = "Protect";
            }
            else {
              local_70 = "DefProt";
            }
            pFVar8 = TraceFP();
            fprintf((FILE *)pFVar8,"HTRule: `%s\' matched %s %s: `%s\'\n",pcVar7,local_70,
                    "rule, setup",local_78);
          }
          if (r->equiv != (char *)0x0) {
            HTSACopy(&local_copy,r->equiv);
            p2 = local_copy;
            prot_file = HTNextField(&p2);
            eff_ids = HTNextField(&p2);
          }
          if (r->op == HT_Protect) {
            HTAA_setCurrentProtection(current,prot_file,eff_ids);
          }
          else {
            HTAA_setDefaultProtection(current,prot_file,eff_ids);
          }
          if (local_copy != (char *)0x0) {
            free(local_copy);
            local_copy = (char *)0x0;
          }
          break;
        case HT_Progress:
        case HT_InfoMsg:
        case HT_Alert:
          LYFixCursesOn("show rule message:");
        case HT_AlwaysAlert:
          if (r->equiv == (char *)0x0) {
            if (r->op == HT_AlwaysAlert) {
              local_60 = "%s";
            }
            else {
              local_60 = "Rule: %s";
            }
            local_64 = local_60;
          }
          else {
            local_64 = r->equiv;
          }
          pMsg = local_64;
          pcVar7 = strchr(local_64,0x25);
          if (pcVar7 != (char *)0x0) {
            HTSprintf0(&msgtmp,pMsg,current);
            pMsg = msgtmp;
          }
          HVar1 = r->op;
          if (HVar1 == HT_InfoMsg) {
            HTInfoMsg(pMsg);
          }
          else if (HVar1 < HT_UserMsg) {
            if (HVar1 == HT_Progress) {
              HTProgress(pMsg);
            }
          }
          else if (HVar1 == HT_Alert) {
            HTAlert(pMsg);
          }
          else if (HVar1 == HT_AlwaysAlert) {
            HTAlwaysAlert("Rule alert:",pMsg);
          }
          if (msgtmp != (char *)0x0) {
            free(msgtmp);
            msgtmp = (char *)0x0;
          }
          break;
        case HT_UserMsg:
          LYFixCursesOn("show rule message:");
          if (r->equiv == (char *)0x0) {
            local_68 = "Rule: %s";
          }
          else {
            local_68 = r->equiv;
          }
          HTUserMsg2(local_68,current);
          break;
        case HT_PermitRedir:
          permitredir_flag = 1;
          if (WWW_TraceFlag != '\0') {
            pFVar8 = TraceFP();
            fprintf((FILE *)pFVar8,"HTRule: Mark for redirection permitted\n");
          }
          break;
        case HT_UseProxy:
          if ((r->equiv == (char *)0x0) ||
             (iVar6 = strcasecomp(r->equiv,"none"), pcVar7 = current, iVar6 != 0)) {
            pcVar7 = current;
            if (proxy_none_flag == 0) {
              p2 = (char *)0x0;
              HTSACopy(&p2,"Proxied=");
              HTSACat(&p2,r->equiv);
              HTSACat(&p2,current);
              if (WWW_TraceFlag != '\0') {
                if (r->equiv == (char *)0x0) {
                  local_50 = "(null)";
                }
                else {
                  local_50 = r->equiv;
                }
                pFVar8 = TraceFP();
                fprintf((FILE *)pFVar8,"HTRule: proxy server found: %s\n",local_50);
              }
              if (current != (char *)0x0) {
                free(current);
              }
              return p2;
            }
            if (WWW_TraceFlag != '\0') {
              if (r->equiv == (char *)0x0) {
                local_54 = "(null)";
              }
              else {
                local_54 = r->equiv;
              }
              pFVar8 = TraceFP();
              fprintf((FILE *)pFVar8,"For `%s\' proxy server ignored: %s\n",pcVar7,local_54);
            }
          }
          else {
            if (WWW_TraceFlag != '\0') {
              pFVar8 = TraceFP();
              fprintf((FILE *)pFVar8,"For `%s\' will not use proxy\n",pcVar7);
            }
            proxy_none_flag = 1;
          }
        }
      }
    }
    r = r->next;
  } while( true );
}



// WARNING: Unknown calling convention

int HTSetConfiguration(char *config)

{
  char *pcVar1;
  int iVar2;
  undefined4 uVar3;
  FILE *__stream;
  size_t sVar4;
  double local_c4;
  char *local_bc;
  long local_b8;
  double local_b4;
  double local_ac;
  double local_a4;
  HTRuleOp local_98;
  HTRuleOp local_94;
  HTRuleOp local_90;
  HTRuleOp local_8c;
  HTRuleOp local_88;
  HTRuleOp local_84;
  HTRuleOp local_80;
  HTRuleOp local_7c;
  HTRuleOp local_78;
  HTRuleOp local_74;
  HTRuleOp local_70;
  HTRuleOp local_6c;
  HTRuleOp local_68;
  HTRuleOp local_64;
  HTRuleOp local_60;
  off_t maxbytes;
  char *cp2;
  char *cp1;
  char *cp;
  char *encoding;
  char *p;
  int status;
  float secs_per_byte;
  float secs;
  float quality;
  char *cond;
  char *cond_op;
  char *word3;
  char *word2;
  char *word1;
  char *pointer;
  char *line;
  HTRuleOp op;
  
  line = (char *)0x0;
  pointer = (char *)0x0;
  cond_op = (char *)0x0;
  cond = (char *)0x0;
  HTSACopy(&line,config);
  p = strchr(line,0x23);
  if (p != (char *)0x0) {
    *p = '\0';
  }
  pointer = line;
  word1 = HTNextField(&pointer);
  if (word1 == (char *)0x0) {
    if (line != (char *)0x0) {
      free(line);
    }
    return 0;
  }
  word2 = HTNextField(&pointer);
  iVar2 = strcasecomp(word1,"defprot");
  if ((iVar2 == 0) || (iVar2 = strcasecomp(word1,"protect"), iVar2 == 0)) {
    word3 = pointer;
  }
  else {
    word3 = HTNextField(&pointer);
  }
  pcVar1 = line;
  if (word2 == (char *)0x0) {
    uVar3 = gettext("Insufficient operands:");
    fprintf(stderr,"HTRule: %s %s\n",uVar3,pcVar1);
    if (line != (char *)0x0) {
      free(line);
    }
    return -2;
  }
  iVar2 = strcasecomp(word1,"suffix");
  if (iVar2 == 0) {
    encoding = HTNextField(&pointer);
    if (pointer == (char *)0x0) {
      status = 0;
    }
    else {
      status = sscanf(pointer,"%f",&quality);
    }
    if (status < 1) {
      local_c4 = 1.0;
    }
    else {
      local_c4 = (double)quality;
    }
    if (encoding == (char *)0x0) {
      local_bc = "binary";
    }
    else {
      local_bc = encoding;
    }
    HTSetSuffix5(word2,word3,local_bc,(char *)0x0,local_c4);
    goto LAB_0812b632;
  }
  iVar2 = strcasecomp(word1,"presentation");
  if (iVar2 == 0) {
    if (pointer == (char *)0x0) {
      status = 0;
    }
    else {
      status = sscanf(pointer,"%f%f%f%lld",&quality,&secs,&secs_per_byte,&maxbytes);
    }
    if (status < 4) {
      local_b8 = 0;
    }
    else {
      local_b8 = (long)maxbytes;
    }
    if (status < 3) {
      local_b4 = 0.0;
    }
    else {
      local_b4 = (double)secs_per_byte;
    }
    if (status < 2) {
      local_ac = 0.0;
    }
    else {
      local_ac = (double)secs;
    }
    if (status < 1) {
      local_a4 = 1.0;
    }
    else {
      local_a4 = (double)quality;
    }
    HTSetPresentation(word2,word3,(char *)0x0,local_a4,local_ac,local_b4,local_b8,mediaCFG);
    goto LAB_0812b632;
  }
  iVar2 = strncasecomp(word1,"htbin",5);
  if ((iVar2 == 0) || (iVar2 = strncasecomp(word1,"bindir",6), iVar2 == 0)) {
    HTSACopy(&HTBinDir,word2);
    goto LAB_0812b632;
  }
  iVar2 = strncasecomp(word1,"search",6);
  if (iVar2 == 0) {
    HTSACopy(&HTSearchScript,word2);
    goto LAB_0812b632;
  }
  iVar2 = strcasecomp(word1,"map");
  if (iVar2 == 0) {
    local_98 = HT_Map;
  }
  else {
    iVar2 = strcasecomp(word1,"pass");
    if (iVar2 == 0) {
      local_94 = HT_Pass;
    }
    else {
      iVar2 = strcasecomp(word1,"fail");
      if (iVar2 == 0) {
        local_90 = HT_Fail;
      }
      else {
        iVar2 = strcasecomp(word1,"redirect");
        if (iVar2 == 0) {
          local_8c = HT_Redirect;
        }
        else {
          iVar2 = strncasecomp(word1,"redirectperm",0xc);
          if (iVar2 == 0) {
            local_88 = HT_RedirectPerm;
          }
          else {
            iVar2 = strcasecomp(word1,"redirecttemp");
            if (iVar2 == 0) {
              local_84 = HT_Redirect;
            }
            else {
              iVar2 = strcasecomp(word1,"permitredirection");
              if (iVar2 == 0) {
                local_80 = HT_PermitRedir;
              }
              else {
                iVar2 = strcasecomp(word1,"useproxy");
                if (iVar2 == 0) {
                  local_7c = HT_UseProxy;
                }
                else {
                  iVar2 = strcasecomp(word1,"alert");
                  if (iVar2 == 0) {
                    local_78 = HT_Alert;
                  }
                  else {
                    iVar2 = strcasecomp(word1,"alwaysalert");
                    if (iVar2 == 0) {
                      local_74 = HT_AlwaysAlert;
                    }
                    else {
                      iVar2 = strcasecomp(word1,"progress");
                      if (iVar2 == 0) {
                        local_70 = HT_Progress;
                      }
                      else {
                        iVar2 = strcasecomp(word1,"usermsg");
                        if (iVar2 == 0) {
                          local_6c = HT_UserMsg;
                        }
                        else {
                          iVar2 = strcasecomp(word1,"infomsg");
                          if (iVar2 == 0) {
                            local_68 = HT_InfoMsg;
                          }
                          else {
                            iVar2 = strcasecomp(word1,"defprot");
                            if (iVar2 == 0) {
                              local_64 = HT_DefProt;
                            }
                            else {
                              iVar2 = strcasecomp(word1,"protect");
                              if (iVar2 == 0) {
                                local_60 = HT_Protect;
                              }
                              else {
                                local_60 = HT_Invalid;
                              }
                              local_64 = local_60;
                            }
                            local_68 = local_64;
                          }
                          local_6c = local_68;
                        }
                        local_70 = local_6c;
                      }
                      local_74 = local_70;
                    }
                    local_78 = local_74;
                  }
                  local_7c = local_78;
                }
                local_80 = local_7c;
              }
              local_84 = local_80;
            }
            local_88 = local_84;
          }
          local_8c = local_88;
        }
        local_90 = local_8c;
      }
      local_94 = local_90;
    }
    local_98 = local_94;
  }
  op = local_98;
  switch(local_98) {
  case HT_Map:
  case HT_Redirect:
  case HT_RedirectPerm:
  case HT_UseProxy:
switchD_0812b1d4_caseD_1:
    cond_op = HTNextField(&pointer);
    if ((((op == HT_Redirect) && (iVar2 = strcasecomp(word1,"redirect"), iVar2 == 0)) &&
        (cond_op != (char *)0x0)) &&
       ((iVar2 = strcasecomp(cond_op,"if"), iVar2 != 0 &&
        (iVar2 = strcasecomp(cond_op,"unless"), iVar2 != 0)))) {
      iVar2 = strcmp(word2,"301");
      if ((iVar2 == 0) || (iVar2 = strcasecomp(word2,"permanent"), iVar2 == 0)) {
        op = HT_RedirectPerm;
      }
      else {
        iVar2 = strcmp(word2,"302");
        if (((iVar2 != 0) && (iVar2 = strcmp(word2,"303"), iVar2 != 0)) &&
           ((iVar2 = strcasecomp(word2,"temp"), iVar2 != 0 &&
            ((iVar2 = strcasecomp(word2,"seeother"), iVar2 != 0 && (WWW_TraceFlag != '\0')))))) {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"Rule: Ignoring `%s\' in Redirect\n",word2);
        }
      }
      word2 = word3;
      word3 = cond_op;
      cond_op = HTNextField(&pointer);
    }
    if ((cond_op != (char *)0x0) && (*cond_op != '\0')) {
      cond = HTNextField(&pointer);
    }
    break;
  case HT_Pass:
    if ((word3 == (char *)0x0) ||
       ((iVar2 = strcasecomp(word3,"if"), iVar2 != 0 &&
        (iVar2 = strcasecomp(word3,"unless"), iVar2 != 0)))) goto switchD_0812b1d4_caseD_1;
    cond_op = word3;
    word3 = (char *)0x0;
    cond = HTNextField(&pointer);
    break;
  case HT_Fail:
  case HT_PermitRedir:
    cond_op = word3;
    if ((word3 != (char *)0x0) && (*word3 != '\0')) {
      word3 = (char *)0x0;
      cond = HTNextField(&pointer);
    }
    break;
  case HT_DefProt:
  case HT_Protect:
    break;
  case HT_Progress:
  case HT_InfoMsg:
  case HT_UserMsg:
  case HT_Alert:
  case HT_AlwaysAlert:
    cond_op = HTNextField(&pointer);
    if ((cond_op != (char *)0x0) && (*cond_op != '\0')) {
      cond = HTNextField(&pointer);
    }
    if (word3 != (char *)0x0) {
      cp = word3;
      while (cp1 = strchr(cp,0x25), cp1 != (char *)0x0) {
        if (cp1[1] == '\0') {
          *cp1 = '\0';
          break;
        }
        if (cp1[1] != '%') goto LAB_0812b480;
        cp = cp1 + 2;
      }
    }
    break;
  default:
    uVar3 = gettext("Bad rule");
    fprintf(stderr,"HTRule: %s \'%s\'\n",uVar3,config);
    goto LAB_0812b632;
  }
switchD_0812b1d4_caseD_4:
  if ((((cond_op == (char *)0x0) || (cond == (char *)0x0)) || (*cond == '\0')) ||
     (iVar2 = strcasecomp(cond_op,"unless"), iVar2 != 0)) {
    if (((cond_op == (char *)0x0) || (cond == (char *)0x0)) ||
       ((*cond == '\0' || (iVar2 = strcasecomp(cond_op,"if"), iVar2 != 0)))) {
      if ((cond_op != (char *)0x0) || (cond != (char *)0x0)) {
        uVar3 = gettext("Bad rule");
        fprintf(stderr,"HTRule: %s \'%s\'\n",uVar3,config);
        if (line != (char *)0x0) {
          free(line);
        }
        return -2;
      }
    }
    else {
      cond_op = "if";
    }
  }
  else {
    cond_op = "unless";
  }
  if (cond == (char *)0x0) {
LAB_0812b5c8:
    if ((cond != (char *)0x0) && (sVar4 = strlen(cond), 7 < sVar4)) {
      sVar4 = strlen(cond);
      iVar2 = strncasecomp(cond,"userspecified",sVar4);
      if (iVar2 == 0) {
        cond = "userspec";
      }
    }
  }
  else {
    sVar4 = strlen(cond);
    iVar2 = strncasecomp(cond,"redirected",sVar4);
    if (iVar2 != 0) goto LAB_0812b5c8;
    cond = "redirected";
  }
  HTAddRule(op,word2,word3,cond_op,cond);
LAB_0812b632:
  if (line != (char *)0x0) {
    free(line);
  }
  return 0;
LAB_0812b480:
  cp2 = strchr(cp1 + 2,0x25);
  if (cp2 != (char *)0x0) {
    if (cp2[1] == '\0') {
      *cp2 = '\0';
      goto switchD_0812b1d4_caseD_4;
    }
    cp1 = cp2;
    if (cp2[1] != '%') {
      *cp2 = '?';
    }
    goto LAB_0812b480;
  }
  goto switchD_0812b1d4_caseD_4;
}



int HTLoadRules(char *filename)

{
  int iVar1;
  FILE *__stream;
  FILE *__stream_00;
  char *pcVar2;
  int in_GS_OFFSET;
  int local_11c;
  char *filename_local;
  FILE *fp;
  char line [257];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  __stream = fopen64(filename,"r");
  if (__stream == (FILE *)0x0) {
    if (WWW_TraceFlag != '\0') {
      __stream_00 = TraceFP();
      fprintf((FILE *)__stream_00,"HTRules: Can\'t open rules file %s\n",filename);
    }
    local_11c = -1;
  }
  else {
    while( true ) {
      pcVar2 = fgets(line,0x101,__stream);
      if (pcVar2 == (char *)0x0) break;
      HTSetConfiguration(line);
    }
    fclose(__stream);
    local_11c = 0;
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return local_11c;
}



void HTSetPresentation(char *representation,char *command,char *testcommand,double quality,
                      double secs,double secs_per_byte,long maxbytes,AcceptMedia media)

{
  HTPresentation_conflict2 *newObject;
  FILE *__stream;
  HTAtom *pHVar1;
  int iVar2;
  char *local_3c;
  char *local_38;
  char *local_34;
  double secs_per_byte_local;
  double secs_local;
  double quality_local;
  HTPresentation_conflict2 *pres;
  
  newObject = (HTPresentation_conflict2 *)calloc(1,0x30);
  if (newObject == (HTPresentation_conflict2 *)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTFormat.c","HTSetPresentation");
  }
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
    if (testcommand == (char *)0x0) {
      local_3c = "";
    }
    else {
      local_3c = testcommand;
    }
    if (command == (char *)0x0) {
      local_38 = "";
    }
    else {
      local_38 = command;
    }
    if (representation == (char *)0x0) {
      local_34 = "";
    }
    else {
      local_34 = representation;
    }
    __stream = TraceFP();
    fprintf((FILE *)__stream,"HTSetPresentation rep=%s, command=%s, test=%s, qual=%f\n",local_34,
            local_38,local_3c,quality);
  }
  pHVar1 = HTAtom_for(representation);
  newObject->rep = pHVar1;
  pHVar1 = HTAtom_for("www/present");
  newObject->rep_out = pHVar1;
  newObject->converter = HTSaveAndExecute;
  newObject->quality = (float)quality;
  newObject->secs = (float)secs;
  newObject->secs_per_byte = (float)secs_per_byte;
  *(long *)&newObject->maxbytes = maxbytes;
  *(long *)((int)&newObject->maxbytes + 4) = maxbytes >> 0x1f;
  newObject->get_accept = '\0';
  newObject->accept_opt = media;
  newObject->command = (char *)0x0;
  HTSACopy(&newObject->command,command);
  newObject->testcommand = (char *)0x0;
  HTSACopy(&newObject->testcommand,testcommand);
  if (HTPresentations == (HTList *)0x0) {
    HTPresentations = HTList_new();
  }
  iVar2 = strcmp(representation,"*");
  if (iVar2 == 0) {
    if (default_presentation != (HTPresentation_conflict2 *)0x0) {
      free(default_presentation);
    }
  }
  else {
    HTList_addObject(HTPresentations,newObject);
    newObject = default_presentation;
  }
  default_presentation = newObject;
  return;
}



// WARNING: Unknown calling convention

void HTSetConversion(char *representation_in,char *representation_out,
                    HTConverter_conflict2 *converter,float quality,float secs,float secs_per_byte,
                    long maxbytes,AcceptMedia media)

{
  HTAtom **newObject;
  FILE *__stream;
  HTAtom *pHVar1;
  char *local_1c;
  char *local_18;
  HTPresentation_conflict2 *pres;
  
  newObject = (HTAtom **)calloc(1,0x30);
  if (newObject == (HTAtom **)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTFormat.c","HTSetConversion");
  }
  if ((WWW_TraceFlag != '\0') && ((WWW_TraceMask & 8U) != 0)) {
    if (representation_out == (char *)0x0) {
      local_1c = "";
    }
    else {
      local_1c = representation_out;
    }
    if (representation_in == (char *)0x0) {
      local_18 = "";
    }
    else {
      local_18 = representation_in;
    }
    __stream = TraceFP();
    fprintf((FILE *)__stream,"HTSetConversion rep_in=%s, rep_out=%s, qual=%f\n",local_18,local_1c,
            (double)quality);
  }
  pHVar1 = HTAtom_for(representation_in);
  *newObject = pHVar1;
  pHVar1 = HTAtom_for(representation_out);
  newObject[1] = pHVar1;
  newObject[2] = (HTAtom *)converter;
  newObject[3] = (HTAtom *)0x0;
  newObject[4] = (HTAtom *)0x0;
  newObject[5] = (HTAtom *)quality;
  newObject[6] = (HTAtom *)secs;
  newObject[7] = (HTAtom *)secs_per_byte;
  newObject[8] = (HTAtom *)maxbytes;
  newObject[9] = (HTAtom *)(maxbytes >> 0x1f);
  *(undefined *)(newObject + 10) = 1;
  newObject[0xb] = (HTAtom *)media;
  if (HTPresentations == (HTList *)0x0) {
    HTPresentations = HTList_new();
  }
  HTList_addObject(HTPresentations,newObject);
  return;
}



// WARNING: Unknown calling convention

void HTInitInput(int file_number)

{
  input_file_number = file_number;
  input_limit = input_buffer;
  input_pointer = input_buffer;
  return;
}



// WARNING: Unknown calling convention

int HTGetCharacter(void)

{
  byte bVar1;
  int iVar2;
  FILE *pFVar3;
  int status;
  char ch;
  
  interrupted_in_htgetcharacter = 0;
  do {
    if (input_limit <= input_pointer) {
      iVar2 = HTDoRead(input_file_number,input_buffer,0x1000);
      if (iVar2 < 1) {
        if (iVar2 == 0) {
          return -1;
        }
        if (iVar2 == -0x752e) {
          if (WWW_TraceFlag != '\0') {
            pFVar3 = TraceFP();
            fprintf((FILE *)pFVar3,"HTFormat: Interrupted in HTGetCharacter\n");
          }
          interrupted_in_htgetcharacter = 1;
          return -1;
        }
        if (WWW_TraceFlag != '\0') {
          pFVar3 = TraceFP();
          fprintf((FILE *)pFVar3,"HTFormat: File read error %d\n",iVar2);
        }
        return -1;
      }
      input_pointer = input_buffer;
      input_limit = input_buffer + iVar2;
    }
    bVar1 = *input_pointer;
    input_pointer = input_pointer + 1;
    if (bVar1 != 0xd) {
      return (uint)bVar1;
    }
  } while( true );
}



// WARNING: Unknown calling convention

int half_match(char *trial_type,char *target)

{
  char *pcVar1;
  FILE *__stream;
  int iVar2;
  int local_18;
  char *cp;
  
  pcVar1 = strchr(trial_type,0x2f);
  if ((pcVar1 == (char *)0x0) || (pcVar1[1] != '*')) {
    local_18 = 0;
  }
  else {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTFormat: comparing %s and %s for half match\n",trial_type,target);
    }
    iVar2 = strncmp(trial_type,target,(size_t)(pcVar1 + (-1 - (int)trial_type)));
    if (iVar2 == 0) {
      local_18 = 1;
    }
    else {
      local_18 = 0;
    }
  }
  return local_18;
}



// WARNING: Unknown calling convention

BOOLEAN failsMailcap(HTPresentation_conflict2 *pres,HTParentAnchor *anchor)

{
  int iVar1;
  
  if ((pres->testcommand != (char *)0x0) &&
     (iVar1 = LYTestMailcapCommand(pres->testcommand,anchor->content_type_params), iVar1 != 0)) {
    return '\x01';
  }
  return '\0';
}



// WARNING: Unknown calling convention

HTPresentation_conflict2 *
HTFindPresentation(HTFormat rep_in,HTFormat rep_out,HTPresentation_conflict2 *fill_in,
                  HTParentAnchor *anchor)

{
  char *pcVar1;
  char *pcVar2;
  undefined3 uVar3;
  BOOLEAN BVar4;
  FILE *pFVar5;
  int iVar6;
  HTPresentation_conflict2 *pres_00;
  int iVar7;
  HTPresentation_conflict2 *local_4c;
  HTPresentation_conflict2 *local_48;
  HTPresentation_conflict2 *local_44;
  HTPresentation_conflict2 *local_40;
  HTPresentation_conflict2 *strong_subtype_wildcard_match;
  HTPresentation_conflict2 *last_default_match;
  HTPresentation_conflict2 *weak_wildcard_match;
  HTPresentation_conflict2 *strong_wildcard_match;
  HTPresentation_conflict2 *match;
  HTPresentation_conflict2 *pres;
  int i;
  int n;
  HTAtom *wildcard;
  
  wildcard = (HTAtom *)0x0;
  strong_wildcard_match = (HTPresentation_conflict2 *)0x0;
  weak_wildcard_match = (HTPresentation_conflict2 *)0x0;
  last_default_match = (HTPresentation_conflict2 *)0x0;
  strong_subtype_wildcard_match = (HTPresentation_conflict2 *)0x0;
  if (WWW_TraceFlag != '\0') {
    pcVar1 = rep_out->name;
    pcVar2 = rep_in->name;
    pFVar5 = TraceFP();
    fprintf((FILE *)pFVar5,"HTFormat: Looking up presentation for %s to %s\n",pcVar2,pcVar1);
  }
  iVar6 = HTList_count(HTPresentations);
  i = 0;
  do {
    if (iVar6 <= i) {
      if (strong_subtype_wildcard_match == (HTPresentation_conflict2 *)0x0) {
        if (strong_wildcard_match == (HTPresentation_conflict2 *)0x0) {
          if (weak_wildcard_match == (HTPresentation_conflict2 *)0x0) {
            local_40 = last_default_match;
          }
          else {
            local_40 = weak_wildcard_match;
          }
          local_44 = local_40;
        }
        else {
          local_44 = strong_wildcard_match;
        }
        local_48 = local_44;
      }
      else {
        local_48 = strong_subtype_wildcard_match;
      }
      if (local_48 == (HTPresentation_conflict2 *)0x0) {
        local_4c = (HTPresentation_conflict2 *)0x0;
      }
      else {
        fill_in->rep = local_48->rep;
        fill_in->rep_out = local_48->rep_out;
        fill_in->converter = local_48->converter;
        fill_in->command = local_48->command;
        fill_in->testcommand = local_48->testcommand;
        fill_in->quality = local_48->quality;
        fill_in->secs = local_48->secs;
        fill_in->secs_per_byte = local_48->secs_per_byte;
        *(undefined4 *)&fill_in->maxbytes = *(undefined4 *)&local_48->maxbytes;
        *(undefined4 *)((int)&fill_in->maxbytes + 4) = *(undefined4 *)((int)&local_48->maxbytes + 4)
        ;
        uVar3 = *(undefined3 *)&local_48->field_0x29;
        fill_in->get_accept = local_48->get_accept;
        *(undefined3 *)&fill_in->field_0x29 = uVar3;
        fill_in->accept_opt = local_48->accept_opt;
        fill_in->rep = rep_in;
        fill_in->rep_out = rep_out;
        local_4c = fill_in;
      }
      return local_4c;
    }
    pres_00 = (HTPresentation_conflict2 *)HTList_objectAt(HTPresentations,i);
    if (pres_00->rep == rep_in) {
      if (pres_00->rep_out == rep_out) {
        BVar4 = failsMailcap(pres_00,anchor);
        if (BVar4 == '\0') {
          if (WWW_TraceFlag == '\0') {
            return pres_00;
          }
          pcVar1 = pres_00->rep_out->name;
          pcVar2 = pres_00->rep->name;
          pFVar5 = TraceFP();
          fprintf((FILE *)pFVar5,"FindPresentation: found exact match: %s -> %s\n",pcVar2,pcVar1);
          return pres_00;
        }
      }
      else if (fill_in != (HTPresentation_conflict2 *)0x0) {
        if (wildcard == (HTAtom *)0x0) {
          wildcard = HTAtom_for("*");
        }
        if (pres_00->rep_out == wildcard) {
          BVar4 = failsMailcap(pres_00,anchor);
          if (BVar4 != '\0') goto LAB_0812bfa4;
          if (strong_wildcard_match == (HTPresentation_conflict2 *)0x0) {
            strong_wildcard_match = pres_00;
          }
          if (WWW_TraceFlag != '\0') {
            pcVar1 = pres_00->rep_out->name;
            pcVar2 = pres_00->rep->name;
            pFVar5 = TraceFP();
            fprintf((FILE *)pFVar5,"StreamStack: found strong wildcard match: %s -> %s\n",pcVar2,
                    pcVar1);
          }
        }
        goto LAB_0812bef2;
      }
    }
    else if (fill_in != (HTPresentation_conflict2 *)0x0) {
      iVar7 = half_match(pres_00->rep->name,rep_in->name);
      if ((iVar7 != 0) && (pres_00->rep_out == rep_out)) {
        BVar4 = failsMailcap(pres_00,anchor);
        if (BVar4 != '\0') goto LAB_0812bfa4;
        if (strong_subtype_wildcard_match == (HTPresentation_conflict2 *)0x0) {
          strong_subtype_wildcard_match = pres_00;
        }
        if (WWW_TraceFlag != '\0') {
          pcVar1 = pres_00->rep_out->name;
          pcVar2 = pres_00->rep->name;
          pFVar5 = TraceFP();
          fprintf((FILE *)pFVar5,"StreamStack: found strong subtype wildcard match: %s -> %s\n",
                  pcVar2,pcVar1);
        }
      }
LAB_0812bef2:
      if (pres_00->rep == WWW_SOURCE) {
        if (pres_00->rep_out == rep_out) {
          BVar4 = failsMailcap(pres_00,anchor);
          if (BVar4 == '\0') {
            if (weak_wildcard_match == (HTPresentation_conflict2 *)0x0) {
              weak_wildcard_match = pres_00;
            }
            if (WWW_TraceFlag != '\0') {
              pcVar1 = pres_00->rep_out->name;
              pFVar5 = TraceFP();
              fprintf((FILE *)pFVar5,"StreamStack: found weak wildcard match: %s\n",pcVar1);
            }
          }
        }
        else if (last_default_match == (HTPresentation_conflict2 *)0x0) {
          if (wildcard == (HTAtom *)0x0) {
            wildcard = HTAtom_for("*");
          }
          if ((pres_00->rep_out == wildcard) &&
             (BVar4 = failsMailcap(pres_00,anchor), BVar4 == '\0')) {
            last_default_match = pres_00;
          }
        }
      }
    }
LAB_0812bfa4:
    i = i + 1;
  } while( true );
}



// WARNING: Unknown calling convention

HTStream_conflict4 *
HTStreamStack(HTFormat rep_in,HTFormat rep_out,HTStream_conflict4 *sink,HTParentAnchor *anchor)

{
  char *pcVar1;
  char *pcVar2;
  FILE *pFVar3;
  HTPresentation_conflict2 *pHVar4;
  char *local_50;
  HTPresentation_conflict2 temp;
  HTStream_conflict4 *result;
  HTPresentation_conflict2 *match;
  
  if (WWW_TraceFlag != '\0') {
    if (anchor->content_type_params == (char *)0x0) {
      local_50 = "(null)";
    }
    else {
      local_50 = anchor->content_type_params;
    }
    pcVar1 = rep_out->name;
    pcVar2 = rep_in->name;
    pFVar3 = TraceFP();
    fprintf((FILE *)pFVar3,"HTFormat: Constructing stream stack for %s to %s (%s)\n",pcVar2,pcVar1,
            local_50);
  }
  if (rep_out == rep_in) {
    result = sink;
  }
  else {
    pHVar4 = HTFindPresentation(rep_in,rep_out,&temp,anchor);
    if (pHVar4 == (HTPresentation_conflict2 *)0x0) {
      result = (HTStream_conflict4 *)0x0;
    }
    else {
      if (pHVar4 == &temp) {
        if (WWW_TraceFlag != '\0') {
          pcVar1 = (temp.rep_out)->name;
          pFVar3 = TraceFP();
          fprintf((FILE *)pFVar3,"StreamStack: Using %s\n",pcVar1);
        }
      }
      else if (WWW_TraceFlag != '\0') {
        pcVar1 = pHVar4->rep_out->name;
        pcVar2 = pHVar4->rep->name;
        pFVar3 = TraceFP();
        fprintf((FILE *)pFVar3,"StreamStack: found exact match: %s -> %s\n",pcVar2,pcVar1);
      }
      result = (*pHVar4->converter)(pHVar4,anchor,sink);
    }
  }
  if (WWW_TraceFlag != '\0') {
    if (((result == (HTStream_conflict4 *)0x0) || (result->isa == (HTStreamClass_conflict4 *)0x0))
       || (result->isa->name == (char *)0x0)) {
      if (result == (HTStream_conflict4 *)0x0) {
        if (WWW_TraceFlag != '\0') {
          pFVar3 = TraceFP();
          fprintf((FILE *)pFVar3,"StreamStack: Returning NULL!\n");
        }
        if (WWW_TraceFlag != '\0') {
          pFVar3 = TraceFP();
          fflush((FILE *)pFVar3);
        }
      }
      else if (WWW_TraceFlag != '\0') {
        pFVar3 = TraceFP();
        fprintf((FILE *)pFVar3,"StreamStack: Returning *unknown* stream!\n");
      }
    }
    else if (WWW_TraceFlag != '\0') {
      pcVar1 = result->isa->name;
      pFVar3 = TraceFP();
      fprintf((FILE *)pFVar3,"StreamStack: Returning \"%s\"\n",pcVar1);
    }
  }
  return result;
}



// WARNING: Unknown calling convention

void HTReorderPresentation(HTFormat rep_in,HTFormat rep_out)

{
  HTPresentation_conflict2 *oldObject;
  HTPresentation_conflict2 *match;
  
  oldObject = HTFindPresentation(rep_in,rep_out,(HTPresentation_conflict2 *)0x0,
                                 (HTParentAnchor *)0x0);
  if (oldObject != (HTPresentation_conflict2 *)0x0) {
    HTList_removeObject(HTPresentations,oldObject);
    HTList_addObject(HTPresentations,oldObject);
  }
  return;
}



// WARNING: Unknown calling convention

void HTFilterPresentations(void)

{
  char *a;
  HTAtom *pHVar1;
  char *b;
  int iVar2;
  FILE *pFVar3;
  HTAtom **ppHVar4;
  HTAtom *pHVar5;
  int iVar6;
  int *piVar7;
  char *t;
  char *s;
  HTPresentation_conflict2 *q;
  HTPresentation_conflict2 *p;
  int n;
  int j;
  int i;
  BOOLEAN matched;
  
  iVar2 = HTList_count(HTPresentations);
  iVar6 = LYAcceptMedia;
  if (WWW_TraceFlag != '\0') {
    pFVar3 = TraceFP();
    fprintf((FILE *)pFVar3,"HTFilterPresentations (AcceptMedia %#x)\n",iVar6);
  }
  i = 0;
  do {
    if (iVar2 <= i) {
      return;
    }
    ppHVar4 = (HTAtom **)HTList_objectAt(HTPresentations,i);
    a = (*ppHVar4)->name;
    *(undefined *)(ppHVar4 + 10) = 0;
    if ((LYAcceptMedia & (uint)ppHVar4[0xb]) != 0) {
      pHVar1 = ppHVar4[1];
      pHVar5 = HTAtom_for("www/present");
      if ((pHVar1 == pHVar5) && (*ppHVar4 != WWW_SOURCE)) {
        iVar6 = strcasecomp(a,"www/mime");
        if (iVar6 != 0) {
          iVar6 = strcasecomp(a,"www/compressed");
          if (((iVar6 != 0) && ((float)ppHVar4[5] <= 1.0)) && (0.0 <= (float)ppHVar4[5])) {
            matched = '\x01';
            for (j = 0; j < i; j = j + 1) {
              piVar7 = (int *)HTList_objectAt(HTPresentations,j);
              b = *(char **)(*piVar7 + 4);
              iVar6 = strcasecomp(a,b);
              if (iVar6 == 0) {
                matched = '\0';
                if (WWW_TraceFlag != '\0') {
                  pFVar3 = TraceFP();
                  fprintf((FILE *)pFVar3,"  match %s %s\n",a,b);
                }
                break;
              }
            }
            *(BOOLEAN *)(ppHVar4 + 10) = matched;
          }
        }
      }
    }
    i = i + 1;
  } while( true );
}



// WARNING: Unknown calling convention

float HTStackValue(HTFormat rep_in,HTFormat rep_out,float initial_value,long length)

{
  char *pcVar1;
  char *pcVar2;
  HTAtom *pHVar3;
  FILE *__stream;
  int iVar4;
  HTFormat *ppHVar5;
  float local_30;
  float value;
  HTPresentation_conflict2 *pres;
  int i;
  int n;
  HTAtom *wildcard;
  
  pHVar3 = HTAtom_for("*");
  if (WWW_TraceFlag != '\0') {
    pcVar1 = rep_out->name;
    pcVar2 = rep_in->name;
    __stream = TraceFP();
    fprintf((FILE *)__stream,"HTFormat: Evaluating stream stack for %s worth %.3f to %s\n",pcVar2,
            (double)initial_value,pcVar1);
  }
  if ((rep_out == WWW_SOURCE) || (rep_out == rep_in)) {
    local_30 = 0.0;
  }
  else {
    iVar4 = HTList_count(HTPresentations);
    for (i = 0; i < iVar4; i = i + 1) {
      ppHVar5 = (HTFormat *)HTList_objectAt(HTPresentations,i);
      if ((*ppHVar5 == rep_in) && ((ppHVar5[1] == rep_out || (ppHVar5[1] == pHVar3)))) {
        value = (float)ppHVar5[5] * initial_value;
        if (0.0 < HTMaxSecs) {
          value = value - ((float)ppHVar5[6] + (float)ppHVar5[7] * (float)length) / HTMaxSecs;
        }
        return value;
      }
    }
    local_30 = -1e+30;
  }
  return local_30;
}



// WARNING: Unknown calling convention

void HTDisplayPartial(void)

{
  bool bVar1;
  BOOLEAN BVar2;
  wchar_t line_num;
  int iVar3;
  wchar_t wVar4;
  int Newline_partial;
  
  if (display_partial != '\0') {
    line_num = LYGetNewline();
    if (NumOfLines_partial < display_lines + line_num + L'\xffffffff') {
      if (partial_threshold < 1) {
        iVar3 = display_lines + line_num;
        wVar4 = HText_getNumOfLines();
        bVar1 = iVar3 + L'\xffffffff' <= wVar4;
      }
      else {
        iVar3 = partial_threshold + line_num;
        wVar4 = HText_getNumOfLines();
        bVar1 = iVar3 + L'\xffffffff' <= wVar4;
      }
      if (bVar1) {
        BVar2 = LYMainLoop_pageDisplay(line_num);
        if (BVar2 != '\0') {
          NumOfLines_partial = HText_getNumOfLines();
        }
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

void HTFinishDisplayPartial(void)

{
  display_partial = '\0';
  return;
}



// WARNING: Unknown calling convention

int HTCopy(HTParentAnchor *anchor,int file_number,void *handle,HTStream_conflict4 *sink)

{
  _func_void_HTStream_ptr_HTError_conflict3 *p_Var1;
  _func_void_HTStream_ptr_char_ptr_int_conflict3 *p_Var2;
  bool bVar3;
  wchar_t wVar4;
  char *pcVar5;
  int iVar6;
  int *piVar7;
  FILE *__stream;
  int iVar8;
  int local_44;
  int local_40;
  HTStreamClass_conflict4 targetClass;
  int status;
  int rv;
  int bytes;
  BOOLEAN suppress_readprogress;
  
  p_Var1 = sink->isa->_abort;
  p_Var2 = sink->isa->put_block;
  bytes = 0;
  HTReadProgress(0,0);
  do {
    if (LYCancelDownload != '\0') {
      LYCancelDownload = '\0';
      (*p_Var1)(sink,(HTError)0x0);
      rv = -1;
finished:
      HTFinishDisplayPartial();
      return rv;
    }
    wVar4 = HTCheckForInterrupt();
    if (wVar4 != L'\0') {
      mustshow = '\x01';
      pcVar5 = (char *)gettext("Data transfer interrupted.");
      HTProgress(pcVar5);
      (*p_Var1)(sink,(HTError)0x0);
      if (bytes == 0) {
        rv = -1;
      }
      else {
        rv = -0x752e;
      }
      goto finished;
    }
    iVar6 = HTDoRead(file_number,input_buffer,0x1000);
    if (iVar6 < 1) {
      if (iVar6 != 0) {
        if (iVar6 == -0x752e) {
          mustshow = '\x01';
          pcVar5 = (char *)gettext("Data transfer interrupted.");
          HTProgress(pcVar5);
          (*p_Var1)(sink,(HTError)0x0);
          if (bytes == 0) {
            rv = -1;
          }
          else {
            rv = -0x752e;
          }
          goto finished;
        }
        piVar7 = __errno_location();
        if (((*piVar7 != 0x6b) && (piVar7 = __errno_location(), *piVar7 != 0x68)) &&
           (piVar7 = __errno_location(), *piVar7 != 0x20)) {
          HTInetStatus("NETREAD");
          HTAlert("Unexpected read error.");
          if (bytes == 0) {
            (*p_Var1)(sink,(HTError)0x0);
            rv = -1;
          }
          else {
            close(file_number);
            rv = 200;
          }
          goto finished;
        }
        if (bytes < 1) {
          rv = -2;
          goto finished;
        }
        HTInetStatus("NETREAD");
        HTAlert("Unexpected server disconnect.");
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"HTCopy: Unexpected server disconnect. Treating as completed.\n")
          ;
        }
      }
      mustshow = '\x01';
      pcVar5 = (char *)gettext("Data transfer complete");
      HTProgress(pcVar5);
      close(file_number);
      rv = 200;
      goto finished;
    }
    if (((anchor == (HTParentAnchor *)0x0) || (anchor->content_type == (char *)0x0)) ||
       (iVar8 = strcmp(anchor->content_type,"message/x-http-redirection"), iVar8 != 0)) {
      bVar3 = false;
    }
    else {
      bVar3 = true;
    }
    (*p_Var2)(sink,input_buffer,iVar6);
    bytes = bytes + iVar6;
    if (!bVar3) {
      if (anchor == (HTParentAnchor *)0x0) {
        local_44 = 0;
        local_40 = 0;
      }
      else {
        local_44 = anchor->content_length;
        local_40 = local_44 >> 0x1f;
      }
      HTReadProgress((longlong)bytes,CONCAT44(local_40,local_44));
    }
    HTDisplayPartial();
  } while( true );
}



// WARNING: Unknown calling convention

int HTFileCopy(FILE *fp,HTStream_conflict4 *sink)

{
  _func_void_HTStream_ptr_char_ptr_int_conflict3 *p_Var1;
  size_t sVar2;
  int iVar3;
  FILE *__stream;
  wchar_t wVar4;
  char *Msg;
  HTStreamClass_conflict4 targetClass;
  int rv;
  int bytes;
  int status;
  
  p_Var1 = sink->isa->put_block;
  bytes = 0;
  HTReadProgress(0,0);
  do {
    sVar2 = fread(input_buffer,1,0x1000,(FILE *)fp);
    if (sVar2 == 0) {
      iVar3 = ferror((FILE *)fp);
      if (iVar3 == 0) {
        rv = 200;
      }
      else {
        if (WWW_TraceFlag != '\0') {
          iVar3 = ferror((FILE *)fp);
          __stream = TraceFP();
          fprintf((FILE *)__stream,"HTFormat: Read error, read returns %d\n",iVar3);
        }
        if (bytes == 0) {
          rv = -1;
        }
        else {
          rv = 0xce;
        }
      }
      goto LAB_0812cb35;
    }
    (*p_Var1)(sink,input_buffer,sVar2);
    bytes = bytes + sVar2;
    HTReadProgress((longlong)bytes,0);
    if ((display_partial != '\0') && (HTMainAnchor->content_length != bytes)) {
      HTDisplayPartial();
    }
    wVar4 = HTCheckForInterrupt();
  } while (wVar4 == L'\0');
  mustshow = '\x01';
  Msg = (char *)gettext("Data transfer interrupted.");
  HTProgress(Msg);
  if (bytes == 0) {
    rv = -1;
  }
  else {
    rv = -0x752e;
  }
LAB_0812cb35:
  HTFinishDisplayPartial();
  return rv;
}



// WARNING: Unknown calling convention

int HTMemCopy(HTChunk *chunk,HTStream_conflict4 *sink)

{
  _func_void_HTStream_ptr_char_ptr_int_conflict3 *p_Var1;
  wchar_t wVar2;
  char *Msg;
  HTStreamClass_conflict4 targetClass;
  int rv;
  int bytes;
  
  bytes = 0;
  rv = 0;
  p_Var1 = sink->isa->put_block;
  HTReadProgress(0,0);
  do {
    if (chunk == (HTChunk *)0x0) {
LAB_0812cc46:
      HTFinishDisplayPartial();
      return rv;
    }
    (*p_Var1)(sink,chunk->data,chunk->size);
    bytes = bytes + chunk->size;
    HTReadProgress((longlong)bytes,0);
    HTDisplayPartial();
    wVar2 = HTCheckForInterrupt();
    if (wVar2 != L'\0') {
      mustshow = '\x01';
      Msg = (char *)gettext("Data transfer interrupted.");
      HTProgress(Msg);
      if (bytes == 0) {
        rv = -1;
      }
      else {
        rv = -0x752e;
      }
      goto LAB_0812cc46;
    }
    chunk = chunk->next;
  } while( true );
}



// WARNING: Unknown calling convention

int HTGzFileCopy(gzFile gzfp,HTStream_conflict4 *sink)

{
  _func_void_HTStream_ptr_char_ptr_int_conflict3 *p_Var1;
  FILE *pFVar2;
  undefined4 uVar3;
  wchar_t wVar4;
  char *Msg;
  HTStreamClass_conflict4 targetClass;
  int rv;
  int gzerrnum;
  int bytes;
  int status;
  
  p_Var1 = sink->isa->put_block;
  bytes = 0;
  HTReadProgress(0,0);
  do {
    status = gzread(gzfp,input_buffer,0x1000);
    if (status < 1) {
      if (status == 0) {
        rv = 200;
      }
      else {
        if (WWW_TraceFlag != '\0') {
          pFVar2 = TraceFP();
          fprintf((FILE *)pFVar2,"HTGzFileCopy: Read error, gzread returns %d\n",status);
        }
        if (WWW_TraceFlag != '\0') {
          uVar3 = gzerror(gzfp,&gzerrnum);
          pFVar2 = TraceFP();
          fprintf((FILE *)pFVar2,"gzerror   : %s\n",uVar3);
        }
        if ((WWW_TraceFlag != '\0') && (gzerrnum == -1)) {
          perror("gzerror   ");
        }
        if (bytes == 0) {
          rv = -1;
        }
        else {
          rv = 0xce;
        }
      }
      goto LAB_0812ce12;
    }
    (*p_Var1)(sink,input_buffer,status);
    bytes = bytes + status;
    HTReadProgress((longlong)bytes,-1);
    HTDisplayPartial();
    wVar4 = HTCheckForInterrupt();
  } while (wVar4 == L'\0');
  mustshow = '\x01';
  Msg = (char *)gettext("Data transfer interrupted.");
  HTProgress(Msg);
  if (bytes == 0) {
    rv = -1;
  }
  else {
    rv = -0x752e;
  }
LAB_0812ce12:
  HTFinishDisplayPartial();
  return rv;
}



// WARNING: Unknown calling convention

char * LynxZError(int status)

{
  sprintf(LynxZError::result,"zlib error %d",status);
  return LynxZError::result;
}



int HTZzFileCopy(FILE *zzfp,HTStream_conflict4 *sink)

{
  int iVar1;
  _func_void_HTStream_ptr_char_ptr_int_conflict3 *p_Var2;
  int iVar3;
  char *pcVar4;
  FILE *pFVar5;
  wchar_t wVar6;
  int in_GS_OFFSET;
  bool bVar7;
  int local_108c;
  int local_1088;
  int local_1084;
  HTStream_conflict4 *sink_local;
  FILE *zzfp_local;
  z_stream s;
  HTStreamClass_conflict4 targetClass;
  int len;
  int retry;
  int flush;
  int status;
  int rv;
  int bytes;
  char output_buffer [4096];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  retry = 0;
  len = 0;
  p_Var2 = sink->isa->put_block;
  s.zalloc = (alloc_func)0x0;
  s.zfree = (free_func)0x0;
  s.opaque = (voidpf)0x0;
  iVar3 = inflateInit_(&s,"1.2.3.3",0x38);
  if (iVar3 != 0) {
    if (WWW_TraceFlag != '\0') {
      pcVar4 = LynxZError(iVar3);
      pFVar5 = TraceFP();
      fprintf((FILE *)pFVar5,"HTZzFileCopy inflateInit() %s\n",pcVar4);
    }
    exit_immediately(1);
  }
  s.avail_in = 0;
  s.next_out = (Bytef *)output_buffer;
  s.avail_out = 0x1000;
  bytes = 0;
  HTReadProgress(0,0);
  while( true ) {
    while( true ) {
      if (s.avail_in == 0) {
        s.next_in = (Bytef *)input_buffer;
        s.avail_in = fread(input_buffer,1,0x1000,(FILE *)zzfp);
        len = s.avail_in;
      }
      iVar3 = inflate(&s,0);
      if ((iVar3 == 1) || (iVar3 == -5)) {
        iVar3 = 0x1000 - s.avail_out;
        if (0 < iVar3) {
          (*p_Var2)(sink,output_buffer,iVar3);
          HTReadProgress((longlong)(bytes + iVar3),-1);
          HTDisplayPartial();
        }
        rv = 200;
        goto LAB_0812d311;
      }
      if ((iVar3 != -3) || (bVar7 = retry != 0, retry = retry + 1, bVar7)) break;
      iVar3 = inflateReset(&s);
      if (iVar3 != 0) {
        if (WWW_TraceFlag != '\0') {
          pcVar4 = LynxZError(iVar3);
          pFVar5 = TraceFP();
          fprintf((FILE *)pFVar5,"HTZzFileCopy inflateReset() %s\n",pcVar4);
        }
        if (bytes == 0) {
          local_108c = -1;
        }
        else {
          local_108c = 0xce;
        }
        rv = local_108c;
        goto LAB_0812d311;
      }
      s.next_in = (Bytef *)HTZzFileCopy::dummy_head;
      s.avail_in = 2;
      inflate(&s,0);
      s.next_in = (Bytef *)input_buffer;
      s.avail_in = len;
    }
    if (iVar3 != 0) break;
    if (s.avail_out == 0) {
      len = 0x1000;
      s.next_out = (Bytef *)output_buffer;
      s.avail_out = 0x1000;
      (*p_Var2)(sink,output_buffer,0x1000);
      bytes = bytes + 0x1000;
      HTReadProgress((longlong)bytes,-1);
      HTDisplayPartial();
      wVar6 = HTCheckForInterrupt();
      if (wVar6 != L'\0') {
        mustshow = '\x01';
        pcVar4 = (char *)gettext("Data transfer interrupted.");
        HTProgress(pcVar4);
        if (bytes == 0) {
          local_1084 = -1;
        }
        else {
          local_1084 = -0x752e;
        }
        rv = local_1084;
LAB_0812d311:
        inflateEnd(&s);
        HTFinishDisplayPartial();
        if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
          __stack_chk_fail();
        }
        return rv;
      }
    }
    retry = 1;
  }
  if (WWW_TraceFlag != '\0') {
    pcVar4 = LynxZError(iVar3);
    pFVar5 = TraceFP();
    fprintf((FILE *)pFVar5,"HTZzFileCopy inflate() %s\n",pcVar4);
  }
  if (bytes == 0) {
    local_1088 = -1;
  }
  else {
    local_1088 = 0xce;
  }
  rv = local_1088;
  goto LAB_0812d311;
}



// WARNING: Unknown calling convention

void HTCopyNoCR(HTParentAnchor *anchor,int file_number,HTStream_conflict4 *sink)

{
  _func_void_HTStream_ptr_char_conflict3 *p_Var1;
  int iVar2;
  HTStreamClass_conflict4 targetClass;
  int character;
  
  p_Var1 = sink->isa->put_character;
  HTInitInput(file_number);
  while( true ) {
    iVar2 = HTGetCharacter();
    if (iVar2 == -1) break;
    (*p_Var1)(sink,(char)iVar2);
  }
  return;
}



// WARNING: Unknown calling convention

int HTParseSocket(HTFormat rep_in,HTFormat format_out,HTParentAnchor *anchor,int file_number,
                 HTStream_conflict4 *sink)

{
  char *pcVar1;
  char *pcVar2;
  _func_void_HTStream_ptr_conflict3 *p_Var3;
  char *fmt;
  FILE *__stream;
  HTStreamClass_conflict4 targetClass;
  char *buffer;
  int rv;
  HTStream_conflict4 *stream;
  
  stream = HTStreamStack(rep_in,format_out,sink,anchor);
  if (stream == (HTStream_conflict4 *)0x0) {
    buffer = (char *)0x0;
    if (LYCancelDownload != '\0') {
      LYCancelDownload = '\0';
      return -1;
    }
    pcVar1 = format_out->name;
    pcVar2 = rep_in->name;
    fmt = (char *)gettext("Sorry, no known way of converting %s to %s.");
    HTSprintf0(&buffer,fmt,pcVar2,pcVar1);
    pcVar1 = buffer;
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTFormat: %s\n",pcVar1);
    }
    rv = HTLoadError((HTStream_conflict *)sink,0x1f5,buffer);
    if (buffer != (char *)0x0) {
      free(buffer);
    }
  }
  else {
    p_Var3 = stream->isa->_free;
    rv = HTCopy(anchor,file_number,(void *)0x0,stream);
    if ((rv != -1) && (rv != -0x752e)) {
      (*p_Var3)(stream);
    }
  }
  return rv;
}



// WARNING: Unknown calling convention

int HTParseFile(HTFormat rep_in,HTFormat format_out,HTParentAnchor *anchor,FILE *fp,
               HTStream_conflict4 *sink)

{
  char *pcVar1;
  char *pcVar2;
  _func_void_HTStream_ptr_conflict3 *p_Var3;
  _func_void_HTStream_ptr_HTError_conflict3 *p_Var4;
  char *fmt;
  FILE *__stream;
  int local_40;
  HTStreamClass_conflict4 targetClass;
  char *buffer;
  int rv;
  HTStream_conflict4 *stream;
  
  stream = HTStreamStack(rep_in,format_out,sink,anchor);
  if (stream == (HTStream_conflict4 *)0x0) {
    buffer = (char *)0x0;
    if (LYCancelDownload == '\0') {
      pcVar1 = format_out->name;
      pcVar2 = rep_in->name;
      fmt = (char *)gettext("Sorry, no known way of converting %s to %s.");
      HTSprintf0(&buffer,fmt,pcVar2,pcVar1);
      pcVar1 = buffer;
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HTFormat(in HTParseFile): %s\n",pcVar1);
      }
      rv = HTLoadError((HTStream_conflict *)sink,0x1f5,buffer);
      if (buffer != (char *)0x0) {
        free(buffer);
      }
      local_40 = rv;
    }
    else {
      LYCancelDownload = '\0';
      local_40 = -1;
    }
  }
  else {
    p_Var3 = stream->isa->_free;
    p_Var4 = stream->isa->_abort;
    rv = HTFileCopy(fp,stream);
    if ((rv == -1) || (rv == -0x752e)) {
      (*p_Var4)(stream,(HTError)0x0);
    }
    else {
      (*p_Var3)(stream);
    }
    if (rv == -1) {
      local_40 = -0xcc;
    }
    else if ((rv == -0x752e) || ((0 < rv && (rv != 200)))) {
      local_40 = 0xce;
    }
    else {
      local_40 = 200;
    }
  }
  return local_40;
}



// WARNING: Unknown calling convention

int HTParseMem(HTFormat rep_in,HTFormat format_out,HTParentAnchor *anchor,HTChunk *chunk,
              HTStream_conflict4 *sink)

{
  char *pcVar1;
  char *pcVar2;
  _func_void_HTStream_ptr_conflict3 *p_Var3;
  char *fmt;
  FILE *__stream;
  int local_40;
  HTStreamClass_conflict4 targetClass;
  char *buffer;
  int rv;
  HTStream_conflict4 *stream;
  
  stream = HTStreamStack(rep_in,format_out,sink,anchor);
  if (stream == (HTStream_conflict4 *)0x0) {
    buffer = (char *)0x0;
    pcVar1 = format_out->name;
    pcVar2 = rep_in->name;
    fmt = (char *)gettext("Sorry, no known way of converting %s to %s.");
    HTSprintf0(&buffer,fmt,pcVar2,pcVar1);
    pcVar1 = buffer;
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTFormat(in HTParseMem): %s\n",pcVar1);
    }
    rv = HTLoadError((HTStream_conflict *)sink,0x1f5,buffer);
    if (buffer != (char *)0x0) {
      free(buffer);
    }
    local_40 = rv;
  }
  else {
    p_Var3 = stream->isa->_free;
    rv = HTMemCopy(chunk,stream);
    (*p_Var3)(stream);
    local_40 = 200;
  }
  return local_40;
}



// WARNING: Unknown calling convention

int HTCloseGzFile(gzFile gzfp)

{
  FILE *__stream;
  int local_18;
  int gzres;
  
  if (gzfp == (gzFile)0x0) {
    local_18 = 0;
  }
  else {
    local_18 = gzclose(gzfp);
    if (WWW_TraceFlag != '\0') {
      if (local_18 == -1) {
        perror("gzclose   ");
      }
      else if ((local_18 != 0) && (WWW_TraceFlag != '\0')) {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"gzclose   : error number %d\n",local_18);
      }
    }
  }
  return local_18;
}



// WARNING: Unknown calling convention

int HTParseGzFile(HTFormat rep_in,HTFormat format_out,HTParentAnchor *anchor,gzFile gzfp,
                 HTStream_conflict4 *sink)

{
  char *pcVar1;
  char *pcVar2;
  _func_void_HTStream_ptr_conflict3 *p_Var3;
  _func_void_HTStream_ptr_HTError_conflict3 *p_Var4;
  char *fmt;
  FILE *__stream;
  int local_40;
  HTStreamClass_conflict4 targetClass;
  char *buffer;
  int rv;
  HTStream_conflict4 *stream;
  
  stream = HTStreamStack(rep_in,format_out,sink,anchor);
  if (stream == (HTStream_conflict4 *)0x0) {
    buffer = (char *)0x0;
    HTCloseGzFile(gzfp);
    if (LYCancelDownload == '\0') {
      pcVar1 = format_out->name;
      pcVar2 = rep_in->name;
      fmt = (char *)gettext("Sorry, no known way of converting %s to %s.");
      HTSprintf0(&buffer,fmt,pcVar2,pcVar1);
      pcVar1 = buffer;
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HTFormat(in HTParseGzFile): %s\n",pcVar1);
      }
      rv = HTLoadError((HTStream_conflict *)sink,0x1f5,buffer);
      if (buffer != (char *)0x0) {
        free(buffer);
      }
      local_40 = rv;
    }
    else {
      LYCancelDownload = '\0';
      local_40 = -1;
    }
  }
  else {
    p_Var3 = stream->isa->_free;
    p_Var4 = stream->isa->_abort;
    rv = HTGzFileCopy(gzfp,stream);
    if ((rv == -1) || (rv == -0x752e)) {
      (*p_Var4)(stream,(HTError)0x0);
    }
    else {
      (*p_Var3)(stream);
    }
    HTCloseGzFile(gzfp);
    if (rv == -1) {
      local_40 = -0xcc;
    }
    else if ((rv == -0x752e) || ((0 < rv && (rv != 200)))) {
      local_40 = 0xce;
    }
    else {
      local_40 = 200;
    }
  }
  return local_40;
}



// WARNING: Unknown calling convention

int HTParseZzFile(HTFormat rep_in,HTFormat format_out,HTParentAnchor *anchor,FILE *zzfp,
                 HTStream_conflict4 *sink)

{
  char *pcVar1;
  char *pcVar2;
  _func_void_HTStream_ptr_conflict3 *p_Var3;
  _func_void_HTStream_ptr_HTError_conflict3 *p_Var4;
  char *fmt;
  FILE *__stream;
  int local_40;
  HTStreamClass_conflict4 targetClass;
  char *buffer;
  int rv;
  HTStream_conflict4 *stream;
  
  stream = HTStreamStack(rep_in,format_out,sink,anchor);
  if (stream == (HTStream_conflict4 *)0x0) {
    buffer = (char *)0x0;
    fclose((FILE *)zzfp);
    if (LYCancelDownload == '\0') {
      pcVar1 = format_out->name;
      pcVar2 = rep_in->name;
      fmt = (char *)gettext("Sorry, no known way of converting %s to %s.");
      HTSprintf0(&buffer,fmt,pcVar2,pcVar1);
      pcVar1 = buffer;
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HTFormat(in HTParseGzFile): %s\n",pcVar1);
      }
      rv = HTLoadError((HTStream_conflict *)sink,0x1f5,buffer);
      if (buffer != (char *)0x0) {
        free(buffer);
      }
      local_40 = rv;
    }
    else {
      LYCancelDownload = '\0';
      local_40 = -1;
    }
  }
  else {
    p_Var3 = stream->isa->_free;
    p_Var4 = stream->isa->_abort;
    rv = HTZzFileCopy(zzfp,stream);
    if ((rv == -1) || (rv == -0x752e)) {
      (*p_Var4)(stream,(HTError)0x0);
    }
    else {
      (*p_Var3)(stream);
    }
    fclose((FILE *)zzfp);
    if (rv == -1) {
      local_40 = -0xcc;
    }
    else if ((rv == -0x752e) || ((0 < rv && (rv != 200)))) {
      local_40 = 0xce;
    }
    else {
      local_40 = 200;
    }
  }
  return local_40;
}



void NetToText_put_character(HTStream_conflict4 *me,char net_char)

{
  char net_char_local;
  char c;
  
  if (*(char *)&me->target != '\0') {
    if (net_char == '\n') {
      (**(code **)(*(int *)(me->targetClass).name + 0xc))((me->targetClass).name,10);
      *(undefined *)&me->target = 0;
      return;
    }
    (**(code **)(*(int *)(me->targetClass).name + 0xc))((me->targetClass).name,0xd);
  }
  *(bool *)&me->target = net_char == '\r';
  if (*(char *)&me->target == '\0') {
    (**(code **)(*(int *)(me->targetClass).name + 0xc))((me->targetClass).name,(int)net_char);
  }
  return;
}



// WARNING: Unknown calling convention

void NetToText_put_string(HTStream_conflict4 *me,char *s)

{
  char *p;
  
  for (p = s; *p != '\0'; p = p + 1) {
    NetToText_put_character(me,*p);
  }
  return;
}



// WARNING: Unknown calling convention

void NetToText_put_block(HTStream_conflict4 *me,char *s,int l)

{
  char *p;
  
  for (p = s; p < s + l; p = p + 1) {
    NetToText_put_character(me,*p);
  }
  return;
}



// WARNING: Unknown calling convention

void NetToText_free(HTStream_conflict4 *me)

{
  (**(code **)(*(int *)(me->targetClass).name + 4))((me->targetClass).name);
  if (me != (HTStream_conflict4 *)0x0) {
    free(me);
  }
  return;
}



// WARNING: Unknown calling convention

void NetToText_abort(HTStream_conflict4 *me,HTError e)

{
  (**(code **)(*(int *)(me->targetClass).name + 8))((me->targetClass).name,e);
  if (me != (HTStream_conflict4 *)0x0) {
    free(me);
  }
  return;
}



// WARNING: Unknown calling convention

HTStream_conflict4 * HTNetToText(HTStream_conflict4 *sink)

{
  HTStream_conflict4 *pHVar1;
  HTStream_conflict4 *me;
  
  pHVar1 = (HTStream_conflict4 *)calloc(1,0xc);
  if (pHVar1 == (HTStream_conflict4 *)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTFormat.c","NetToText");
  }
  pHVar1->isa = &NetToTextClass;
  *(undefined *)&pHVar1->target = 0;
  (pHVar1->targetClass).name = (char *)sink;
  return pHVar1;
}



void HTErrorStream_put_character(HTStream_conflict4 *me,char c)

{
  char c_local;
  
  LYCancelDownload = '\x01';
  return;
}



// WARNING: Unknown calling convention

void HTErrorStream_put_string(HTStream_conflict4 *me,char *s)

{
  if ((s != (char *)0x0) && (*s != '\0')) {
    LYCancelDownload = '\x01';
  }
  return;
}



// WARNING: Unknown calling convention

void HTErrorStream_write(HTStream_conflict4 *me,char *s,int l)

{
  if ((l != 0) && (s != (char *)0x0)) {
    LYCancelDownload = '\x01';
  }
  return;
}



// WARNING: Unknown calling convention

void HTErrorStream_free(HTStream_conflict4 *me)

{
  return;
}



// WARNING: Unknown calling convention

void HTErrorStream_abort(HTStream_conflict4 *me,HTError e)

{
  return;
}



// WARNING: Unknown calling convention

HTStream_conflict4 * HTErrorStream(void)

{
  FILE *__stream;
  
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"ErrorStream. Created\n");
  }
  HTBaseStreamInstance.isa = &HTErrorStreamClass;
  return (HTStream_conflict4 *)&HTBaseStreamInstance;
}



// WARNING: Unknown calling convention

void HTMIME_TrimDoubleQuotes(char *value)

{
  size_t sVar1;
  char *cp;
  int i;
  
  if (((value != (char *)0x0) && (*value != '\0')) && (*value == '\"')) {
    sVar1 = strlen(value);
    if (value[sVar1 - 1] == '\"') {
      value[sVar1 - 1] = '\0';
      for (i = 0; value[i] != '\0'; i = i + 1) {
        value[i] = value[i + 1];
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

BOOLEAN content_is_compressed(HTStream_conflict6 *me)

{
  CompressFileType CVar1;
  FILE *__stream;
  undefined *local_18;
  char *encoding;
  BOOLEAN result;
  
  CVar1 = HTEncodingToCompressType(me->anchor->content_encoding);
  if (WWW_TraceFlag != '\0') {
    if (CVar1 != cftNone) {
      local_18 = &DAT_0818c740;
    }
    else {
      local_18 = &DAT_0818c741;
    }
    __stream = TraceFP();
    fprintf((FILE *)__stream,"content is%s compressed\n",local_18);
  }
  return CVar1 != cftNone;
}



// WARNING: Unknown calling convention

void dequote(char *url)

{
  size_t sVar1;
  int len;
  
  sVar1 = strlen(url);
  if (((*url == '\'') && (1 < (int)sVar1)) && (url[sVar1 - 1] == *url)) {
    url[sVar1 - 1] = '\0';
    for (; *url = url[1], *url != '\0'; url = url + 1) {
    }
  }
  return;
}



// WARNING: Unknown calling convention

char * UncompressedContentType(HTStream_conflict6 *me,CompressFileType method)

{
  int iVar1;
  HTFormat pHVar2;
  char *description;
  HTAtom *pencoding;
  HTFormat format;
  char *actual;
  char *expected;
  char *address;
  char *result;
  
  result = (char *)0x0;
  address = me->anchor->address;
  expected = HTCompressTypeToSuffix(method);
  actual = strrchr(address,0x2e);
  if (actual != (char *)0x0) {
    iVar1 = strcasecomp(actual,expected);
    if (iVar1 == 0) {
      pencoding = (HTAtom *)0x0;
      description = (char *)0x0;
      pHVar2 = HTFileFormat(address,&pencoding,&description);
      result = pHVar2->name;
    }
  }
  return result;
}



// WARNING: Unknown calling convention

int pumpData(HTStream_conflict6 *me)

{
  HTStreamClass_conflict5 *pHVar1;
  BOOLEAN BVar2;
  FILE *pFVar3;
  HTAtom *pHVar4;
  char *pcVar5;
  int iVar6;
  ushort **ppuVar7;
  time_t tVar8;
  time_t tVar9;
  HTAtom *pHVar10;
  HTStream_conflict6 *pHVar11;
  char *pcVar12;
  char local_5c;
  char local_58;
  char local_54;
  char *local_50;
  char *base;
  char *txt;
  char *cp;
  char *cp3;
  LYUCcharset *p_out;
  LYUCcharset *p_in;
  int chndl;
  char *cp4;
  char *cp2;
  char *cp1;
  char *new_content;
  char *new_encoding;
  CompressFileType method;
  BOOLEAN given_and_display_8859like;
  BOOLEAN given_is_8859like;
  BOOLEAN given_is_8859;
  BOOLEAN chartrans_ok;
  
  if (WWW_TraceFlag != '\0') {
    pFVar3 = TraceFP();
    fprintf((FILE *)pFVar3,"Begin pumpData\n");
  }
  if (WWW_TraceFlag != '\0') {
    pcVar5 = me->anchor->address;
    pFVar3 = TraceFP();
    fprintf((FILE *)pFVar3,"...address{%s}\n",pcVar5);
  }
  method = HTContentTypeToCompressType(me->anchor->content_type_params);
  if ((method != cftNone) &&
     ((me->anchor->content_encoding == (char *)0x0 || (*me->anchor->content_encoding == '\0')))) {
    new_content = UncompressedContentType(me,method);
    if (new_content != (char *)0x0) {
      new_encoding = HTCompressTypeToEncoding(method);
      if (WWW_TraceFlag != '\0') {
        pFVar3 = TraceFP();
        fprintf((FILE *)pFVar3,"reinterpreting as content-type:%s, encoding:%s\n",new_content,
                new_encoding);
      }
      HTSACopy(&me->anchor->content_encoding,new_encoding);
      if (me->compression_encoding != (char *)0x0) {
        free(me->compression_encoding);
        me->compression_encoding = (char *)0x0;
      }
      HTSACopy(&me->compression_encoding,new_encoding);
      strcpy(me->value,new_content);
      HTSACopy(&me->anchor->content_type_params,me->value);
      pHVar4 = HTAtom_for(me->value);
      me->format = pHVar4;
    }
  }
  pcVar5 = strchr(me->format->name,0x3b);
  if (pcVar5 == (char *)0x0) goto LAB_0812e870;
  cp = (char *)0x0;
  cp3 = (char *)0x0;
  if (WWW_TraceFlag != '\0') {
    pcVar5 = me->format->name;
    pFVar3 = TraceFP();
    fprintf((FILE *)pFVar3,"HTMIME: Extended MIME Content-Type is %s\n",pcVar5);
  }
  HTSACopy(&cp,me->format->name);
  LYLowerCase(cp);
  cp1 = strchr(cp,0x3b);
  if (cp1 != (char *)0x0) {
    chartrans_ok = '\0';
    cp2 = strstr(cp1,"charset");
    if (cp2 == (char *)0x0) {
      *cp1 = '\0';
      pHVar4 = HTAtom_for(cp);
      me->format = pHVar4;
    }
    else {
      for (cp2 = cp2 + 7; ((*cp2 == ' ' || (*cp2 == '=')) || (*cp2 == '\"')); cp2 = cp2 + 1) {
      }
      HTSACopy(&cp3,cp2);
      for (cp4 = cp3;
          ((*cp4 != '\0' && (*cp4 != '\"')) &&
          ((*cp4 != ';' && ((*cp4 != ':' && (0x20 < (byte)*cp4)))))); cp4 = cp4 + 1) {
      }
      *cp4 = '\0';
      cp4 = cp3;
      chndl = UCGetLYhndl_byMIME(cp3);
      BVar2 = UCCanTranslateFromTo(chndl,current_char_set);
      if (BVar2 == '\0') {
        if (chndl < 0) {
          chndl = UCLYhndl_for_unrec;
          if (UCLYhndl_for_unrec < 0) {
            chndl = UCLYhndl_for_unspec;
          }
          BVar2 = UCCanTranslateFromTo(chndl,current_char_set);
          if (BVar2 != '\0') {
            chartrans_ok = '\x01';
            *cp1 = '\0';
            pHVar4 = HTAtom_for(cp);
            me->format = pHVar4;
            HTAnchor_setUCInfoStage(me->anchor,chndl,0,1);
          }
        }
        else {
          *cp1 = '\0';
          pHVar4 = HTAtom_for(cp);
          me->format = pHVar4;
          HTSACopy(&me->anchor->charset,cp4);
          HTAnchor_setUCInfoStage(me->anchor,chndl,0,5);
        }
      }
      else {
        chartrans_ok = '\x01';
        *cp1 = '\0';
        pHVar4 = HTAtom_for(cp);
        me->format = pHVar4;
        HTSACopy(&me->anchor->charset,cp4);
        HTAnchor_setUCInfoStage(me->anchor,chndl,0,5);
      }
      if (chartrans_ok == '\0') {
        iVar6 = strncmp(cp4,"iso-8859-",9);
        if (iVar6 == 0) {
          ppuVar7 = __ctype_b_loc();
          if (((*ppuVar7)[(byte)cp4[9]] & 0x800) == 0) goto LAB_0812e67c;
          local_5c = '\x01';
        }
        else {
LAB_0812e67c:
          local_5c = '\0';
        }
        given_is_8859 = local_5c;
        if (local_5c == '\0') {
          iVar6 = strncmp(cp4,"windows-",8);
          if (iVar6 == 0) goto LAB_0812e6ed;
          iVar6 = strncmp(cp4,"cp12",4);
          if (iVar6 == 0) goto LAB_0812e6ed;
          iVar6 = strncmp(cp4,"cp-12",5);
          if (iVar6 == 0) goto LAB_0812e6ed;
          local_58 = '\0';
        }
        else {
LAB_0812e6ed:
          local_58 = '\x01';
        }
        given_is_8859like = local_58;
        if (local_58 == '\0') {
LAB_0812e753:
          local_54 = '\0';
        }
        else {
          pcVar5 = strstr(LYchar_set_names[current_char_set],"ISO-8859");
          if (pcVar5 == (char *)0x0) {
            pcVar5 = strstr(LYchar_set_names[current_char_set],"windows-");
            if (pcVar5 == (char *)0x0) goto LAB_0812e753;
          }
          local_54 = '\x01';
        }
        given_and_display_8859like = local_54;
        if (local_54 != '\0') {
          *cp1 = '\0';
          pHVar4 = HTAtom_for(cp);
          me->format = pHVar4;
        }
        if (given_is_8859 != '\0') {
          for (cp1 = cp4 + 10; *cp1 != '\0'; cp1 = cp1 + 1) {
            ppuVar7 = __ctype_b_loc();
            if (((*ppuVar7)[(byte)*cp1] & 0x800) == 0) break;
          }
          *cp1 = '\0';
        }
        if (given_and_display_8859like != '\0') {
          HTSACopy(&me->anchor->charset,cp4);
          HTPassEightBitRaw = '\x01';
        }
        if (*cp4 == '\0') {
          local_50 = me->anchor->charset;
        }
        else {
          local_50 = cp4;
        }
        HTAlert(local_50);
      }
      else {
        p_in = HTAnchor_getUCInfoStage(me->anchor,0);
        p_out = HTAnchor_setUCInfoStage(me->anchor,current_char_set,3,1);
        if (p_out == (LYUCcharset *)0x0) {
          p_out = HTAnchor_getUCInfoStage(me->anchor,3);
        }
        iVar6 = strcmp(p_in->MIMEname,"x-transparent");
        if (iVar6 == 0) {
          HTPassEightBitRaw = '\x01';
          iVar6 = HTAnchor_getUCLYhndl(me->anchor,3);
          HTAnchor_setUCInfoStage(me->anchor,iVar6,0,1);
        }
        iVar6 = strcmp(p_out->MIMEname,"x-transparent");
        if (iVar6 == 0) {
          HTPassEightBitRaw = '\x01';
          iVar6 = HTAnchor_getUCLYhndl(me->anchor,0);
          HTAnchor_setUCInfoStage(me->anchor,iVar6,3,1);
        }
        if ((p_in->enc == 5) || ((p_in->enc == 7 && (p_out->enc == 5)))) {
          if (p_out->enc == 5) {
            Set_HTCJK(p_in->MIMEname,p_out->MIMEname);
          }
        }
        else {
          HTCJK = NOCJK;
          if (((p_in->codepoints & 1U) == 0) && (chndl == current_char_set)) {
            HTPassEightBitRaw = '\x01';
          }
        }
      }
      if (cp3 != (char *)0x0) {
        free(cp3);
        cp3 = (char *)0x0;
      }
    }
  }
  if (cp != (char *)0x0) {
    free(cp);
    cp = (char *)0x0;
  }
LAB_0812e870:
  if ((me->anchor->no_cache == '\0') && (me->anchor->expires != (char *)0x0)) {
    iVar6 = strcmp(me->anchor->expires,"0");
    if (iVar6 == 0) {
      me->anchor->no_cache = '\x01';
    }
    else if (me->anchor->date == (char *)0x0) {
      tVar8 = LYmktime(me->anchor->expires,'\0');
      if (tVar8 == 0) {
        me->anchor->no_cache = '\x01';
      }
    }
    else {
      tVar8 = LYmktime(me->anchor->expires,'\x01');
      tVar9 = LYmktime(me->anchor->date,'\x01');
      if (tVar8 <= tVar9) {
        me->anchor->no_cache = '\x01';
      }
    }
  }
  HTSACopy(&me->anchor->content_type,me->format->name);
  if ((me->set_cookie != (char *)0x0) || (me->set_cookie2 != (char *)0x0)) {
    LYSetCookie(me->set_cookie,me->set_cookie2,me->anchor->address);
    if (me->set_cookie != (char *)0x0) {
      free(me->set_cookie);
      me->set_cookie = (char *)0x0;
    }
    if (me->set_cookie2 != (char *)0x0) {
      free(me->set_cookie2);
      me->set_cookie2 = (char *)0x0;
    }
  }
  if (me->pickup_redirection != '\0') {
    if ((me->location == (char *)0x0) || (*me->location == '\0')) {
      permanent_redirection = '\0';
      if (me->location != (char *)0x0) {
        if (WWW_TraceFlag != '\0') {
          pFVar3 = TraceFP();
          fprintf((FILE *)pFVar3,"HTTP: \'Location:\' is zero-length!\n");
        }
        HTAlert("Got redirection with a bad Location header.");
      }
      if (WWW_TraceFlag != '\0') {
        pFVar3 = TraceFP();
        fprintf((FILE *)pFVar3,"HTTP: Failed to pick up location.\n");
      }
      if (me->location == (char *)0x0) {
        HTAlert("Got redirection with no Location header.");
      }
      else if (me->location != (char *)0x0) {
        free(me->location);
        me->location = (char *)0x0;
      }
    }
    else {
      redirecting_url = me->location;
      me->location = (char *)0x0;
      pHVar4 = me->targetRep;
      pHVar10 = HTAtom_for("www/debug");
      if ((pHVar4 != pHVar10) || (me->sink != (HTStream_conflict6 *)0x0)) {
        me->head_only = '\x01';
      }
    }
  }
  if (WWW_TraceFlag != '\0') {
    pFVar3 = TraceFP();
    fprintf((FILE *)pFVar3,"...pumpData finished reading header\n");
  }
  if (me->head_only == '\0') {
    if (me->no_streamstack == '\0') {
      if (me->compression_encoding == (char *)0x0) {
        if (WWW_TraceFlag != '\0') {
          pcVar5 = me->targetRep->name;
          pcVar12 = me->format->name;
          pFVar3 = TraceFP();
          fprintf((FILE *)pFVar3,"HTMIME: MIME Content-Type is \'%s\', converting to \'%s\'\n",
                  pcVar12,pcVar5);
        }
      }
      else {
        if (WWW_TraceFlag != '\0') {
          pcVar5 = me->format->name;
          pFVar3 = TraceFP();
          fprintf((FILE *)pFVar3,"HTMIME: MIME Content-Type is \'%s\',\n",pcVar5);
        }
        pHVar4 = HTAtom_for("www/compressed");
        me->format = pHVar4;
        if (WWW_TraceFlag != '\0') {
          pcVar5 = me->targetRep->name;
          pcVar12 = me->format->name;
          pFVar3 = TraceFP();
          fprintf((FILE *)pFVar3,"        Treating as \'%s\'.  Converting to \'%s\'\n",pcVar12,
                  pcVar5);
        }
        if (me->compression_encoding != (char *)0x0) {
          free(me->compression_encoding);
          me->compression_encoding = (char *)0x0;
        }
      }
      pHVar11 = (HTStream_conflict6 *)
                HTStreamStack(me->format,me->targetRep,(HTStream_conflict4 *)me->sink,me->anchor);
      me->target = pHVar11;
      if (me->target == (HTStream_conflict6 *)0x0) {
        if (WWW_TraceFlag != '\0') {
          pFVar3 = TraceFP();
          fprintf((FILE *)pFVar3,"HTMIME: Can\'t translate! ** \n");
        }
        me->target = me->sink;
      }
    }
    else {
      me->target = me->sink;
    }
    if (me->target == (HTStream_conflict6 *)0x0) {
      me->state = MIME_IGNORE;
    }
    else {
      pHVar1 = me->target->isa;
      (me->targetClass).name = pHVar1->name;
      (me->targetClass)._free = pHVar1->_free;
      (me->targetClass)._abort = pHVar1->_abort;
      (me->targetClass).put_character = pHVar1->put_character;
      (me->targetClass).put_string = pHVar1->put_string;
      (me->targetClass).put_block = pHVar1->put_block;
      me->state = (uint)(me->chunked_encoding != '\0');
    }
    if (me->refresh_url != (char *)0x0) {
      BVar2 = content_is_compressed(me);
      if (BVar2 == '\0') {
        cp3 = (char *)0x0;
        cp = (char *)0x0;
        txt = (char *)0x0;
        LYParseRefreshURL(me->refresh_url,&cp,&cp3);
        if (cp3 != (char *)0x0) {
          pHVar4 = me->format;
          pHVar10 = HTAtom_for("text/html");
          if (pHVar4 == pHVar10) {
            if (WWW_TraceFlag != '\0') {
              pFVar3 = TraceFP();
              fprintf((FILE *)pFVar3,"Formatting refresh-url as first line of result\n");
            }
            pcVar5 = (char *)gettext("Refresh: ");
            HTSprintf0(&txt,pcVar5);
            pcVar5 = cp;
            pcVar12 = (char *)gettext("%s seconds ");
            HTSprintf(&txt,pcVar12,pcVar5);
            dequote(cp3);
            HTSprintf(&txt,"<a href=\"%s%s\">%s</a><br>",&DAT_0818c740,cp3,cp3);
            pcVar5 = cp3;
            if (WWW_TraceFlag != '\0') {
              pFVar3 = TraceFP();
              fprintf((FILE *)pFVar3,"URL %s%s\n",&DAT_0818c740,pcVar5);
            }
            (*me->isa->put_string)(me,txt);
            free(txt);
          }
        }
        if (cp != (char *)0x0) {
          free(cp);
          cp = (char *)0x0;
        }
        if (cp3 != (char *)0x0) {
          free(cp3);
          cp3 = (char *)0x0;
        }
      }
    }
  }
  else {
    me->state = MIME_IGNORE;
  }
  if (WWW_TraceFlag != '\0') {
    pFVar3 = TraceFP();
    fprintf((FILE *)pFVar3,"...end of pumpData\n");
  }
  return 0;
}



// WARNING: Unknown calling convention

int dispatchField(HTStream_conflict6 *me)

{
  HTParentAnchor *pHVar1;
  char *pcVar2;
  BOOLEAN BVar3;
  char *pcVar4;
  ushort **ppuVar5;
  HTAtom *pHVar6;
  int iVar7;
  FILE *pFVar8;
  char local_2d;
  char *cp0;
  char *cp1;
  char *cp;
  int j;
  int i;
  
  *me->value_pointer = '\0';
  cp = me->value_pointer;
  while ((me->value < cp && (cp = cp + -1, *cp == ' '))) {
    *cp = '\0';
  }
  switch(me->field) {
  case miACCEPT_RANGES:
    HTMIME_TrimDoubleQuotes(me->value);
    if (WWW_TraceFlag != '\0') {
      pFVar8 = TraceFP();
      fprintf((FILE *)pFVar8,"HTMIME: PICKED UP Accept-Ranges: \'%s\'\n",me->value);
    }
    break;
  case miAGE:
    HTMIME_TrimDoubleQuotes(me->value);
    if (WWW_TraceFlag != '\0') {
      pFVar8 = TraceFP();
      fprintf((FILE *)pFVar8,"HTMIME: PICKED UP Age: \'%s\'\n",me->value);
    }
    break;
  default:
    return -1;
  case miALLOW:
    HTMIME_TrimDoubleQuotes(me->value);
    if (WWW_TraceFlag != '\0') {
      pFVar8 = TraceFP();
      fprintf((FILE *)pFVar8,"HTMIME: PICKED UP Allow: \'%s\'\n",me->value);
    }
    break;
  case miALTERNATES:
    HTMIME_TrimDoubleQuotes(me->value);
    if (WWW_TraceFlag != '\0') {
      pFVar8 = TraceFP();
      fprintf((FILE *)pFVar8,"HTMIME: PICKED UP Alternates: \'%s\'\n",me->value);
    }
    break;
  case miCACHE_CONTROL:
    HTMIME_TrimDoubleQuotes(me->value);
    if (WWW_TraceFlag != '\0') {
      pFVar8 = TraceFP();
      fprintf((FILE *)pFVar8,"HTMIME: PICKED UP Cache-Control: \'%s\'\n",me->value);
    }
    if (me->value[0] != '\0') {
      LYLowerCase(me->value);
      HTSACopy(&me->anchor->cache_control,me->value);
      cp0 = me->value;
      while (pcVar4 = strstr(cp0,"no-cache"), pcVar4 != (char *)0x0) {
        for (cp1 = pcVar4 + 8; (*cp1 != '\0' && ((byte)*cp1 < 0x21)); cp1 = cp1 + 1) {
        }
        if ((*cp1 == '\0') || (*cp1 == ';')) {
          me->anchor->no_cache = '\x01';
          break;
        }
        cp0 = cp1;
      }
      if (me->anchor->no_cache != '\x01') {
        cp0 = me->value;
        while (pcVar4 = strstr(cp0,"max-age"), pcVar4 != (char *)0x0) {
          for (cp1 = pcVar4 + 7; (*cp1 != '\0' && ((byte)*cp1 < 0x21)); cp1 = cp1 + 1) {
          }
          if (*cp1 == '=') {
            do {
              pcVar4 = cp1;
              cp1 = pcVar4 + 1;
              pcVar2 = cp1;
              if (*cp1 == '\0') break;
            } while ((byte)*cp1 < 0x21);
            ppuVar5 = __ctype_b_loc();
            if (((*ppuVar5)[(byte)*cp1] & 0x800) != 0) {
              while (ppuVar5 = __ctype_b_loc(), ((*ppuVar5)[(byte)*cp1] & 0x800) != 0) {
                cp1 = cp1 + 1;
              }
              if ((*pcVar2 == '0') && (pcVar4 + 2 == cp1)) {
                me->anchor->no_cache = '\x01';
                return 0;
              }
            }
          }
          cp0 = cp1;
        }
      }
    }
    break;
  case miCOOKIE:
    HTMIME_TrimDoubleQuotes(me->value);
    if (WWW_TraceFlag != '\0') {
      pFVar8 = TraceFP();
      fprintf((FILE *)pFVar8,"HTMIME: PICKED UP Cookie: \'%s\'\n",me->value);
    }
    break;
  case miCONNECTION:
    HTMIME_TrimDoubleQuotes(me->value);
    if (WWW_TraceFlag != '\0') {
      pFVar8 = TraceFP();
      fprintf((FILE *)pFVar8,"HTMIME: PICKED UP Connection: \'%s\'\n",me->value);
    }
    break;
  case miCONTENT_BASE:
    HTMIME_TrimDoubleQuotes(me->value);
    if (WWW_TraceFlag != '\0') {
      pFVar8 = TraceFP();
      fprintf((FILE *)pFVar8,"HTMIME: PICKED UP Content-Base: \'%s\'\n",me->value);
    }
    if (me->value[0] != '\0') {
      HTSACopy(&me->anchor->content_base,me->value);
    }
    break;
  case miCONTENT_DISPOSITION:
    HTMIME_TrimDoubleQuotes(me->value);
    if (WWW_TraceFlag != '\0') {
      pFVar8 = TraceFP();
      fprintf((FILE *)pFVar8,"HTMIME: PICKED UP Content-Disposition: \'%s\'\n",me->value);
    }
    if (me->value[0] != '\0') {
      HTSACopy(&me->anchor->content_disposition,me->value);
      cp = me->anchor->content_disposition;
      while ((*cp != '\0' && (iVar7 = strncasecomp(cp,"filename",8), iVar7 != 0))) {
        cp = cp + 1;
      }
      if (*cp != '\0') {
        for (cp = cp + 8; (*cp != '\0' && (((byte)*cp < 0x21 || (*cp == '=')))); cp = cp + 1) {
        }
        if (*cp != '\0') {
          for (; (*cp != '\0' && ((byte)*cp < 0x21)); cp = cp + 1) {
          }
          if (*cp != '\0') {
            HTSACopy(&me->anchor->SugFname,cp);
            if (*me->anchor->SugFname == '\"') {
              pcVar4 = strchr(me->anchor->SugFname + 1,0x22);
              if (pcVar4 == (char *)0x0) {
                if (me->anchor->SugFname == (char *)0x0) {
                  return 0;
                }
                free(me->anchor->SugFname);
                me->anchor->SugFname = (char *)0x0;
                return 0;
              }
              pcVar4[1] = '\0';
              HTMIME_TrimDoubleQuotes(me->anchor->SugFname);
            }
            for (cp = me->anchor->SugFname; (*cp != '\0' && (0x20 < (byte)*cp)); cp = cp + 1) {
            }
            *cp = '\0';
            if ((*me->anchor->SugFname == '\0') && (me->anchor->SugFname != (char *)0x0)) {
              free(me->anchor->SugFname);
              me->anchor->SugFname = (char *)0x0;
            }
          }
        }
      }
    }
    break;
  case miCONTENT_ENCODING:
    HTMIME_TrimDoubleQuotes(me->value);
    if (WWW_TraceFlag != '\0') {
      pFVar8 = TraceFP();
      fprintf((FILE *)pFVar8,"HTMIME: PICKED UP Content-Encoding: \'%s\'\n",me->value);
    }
    if ((me->value[0] != '\0') && (iVar7 = strcasecomp(me->value,"identity"), iVar7 != 0)) {
      LYLowerCase(me->value);
      HTSACopy(&me->anchor->content_encoding,me->value);
      if (me->compression_encoding != (char *)0x0) {
        free(me->compression_encoding);
        me->compression_encoding = (char *)0x0;
      }
      BVar3 = content_is_compressed(me);
      if (BVar3 == '\0') {
        if (WWW_TraceFlag != '\0') {
          pFVar8 = TraceFP();
          fprintf((FILE *)pFVar8,"                Ignoring it!\n");
        }
      }
      else {
        HTSACopy(&me->compression_encoding,me->value);
      }
    }
    break;
  case miCONTENT_FEATURES:
    HTMIME_TrimDoubleQuotes(me->value);
    if (WWW_TraceFlag != '\0') {
      pFVar8 = TraceFP();
      fprintf((FILE *)pFVar8,"HTMIME: PICKED UP Content-Features: \'%s\'\n",me->value);
    }
    break;
  case miCONTENT_LANGUAGE:
    HTMIME_TrimDoubleQuotes(me->value);
    if (WWW_TraceFlag != '\0') {
      pFVar8 = TraceFP();
      fprintf((FILE *)pFVar8,"HTMIME: PICKED UP Content-Language: \'%s\'\n",me->value);
    }
    if (me->value[0] != '\0') {
      LYLowerCase(me->value);
      HTSACopy(&me->anchor->content_language,me->value);
    }
    break;
  case miCONTENT_LENGTH:
    HTMIME_TrimDoubleQuotes(me->value);
    if (WWW_TraceFlag != '\0') {
      pFVar8 = TraceFP();
      fprintf((FILE *)pFVar8,"HTMIME: PICKED UP Content-Length: \'%s\'\n",me->value);
    }
    if (me->value[0] != '\0') {
      pHVar1 = me->anchor;
      iVar7 = atoi(me->value);
      pHVar1->content_length = iVar7;
      if (me->anchor->content_length < 0) {
        me->anchor->content_length = 0;
      }
      if (WWW_TraceFlag != '\0') {
        iVar7 = me->anchor->content_length;
        pFVar8 = TraceFP();
        fprintf((FILE *)pFVar8,"        Converted to integer: \'%d\'\n",iVar7);
      }
    }
    break;
  case miCONTENT_LOCATION:
    HTMIME_TrimDoubleQuotes(me->value);
    if (WWW_TraceFlag != '\0') {
      pFVar8 = TraceFP();
      fprintf((FILE *)pFVar8,"HTMIME: PICKED UP Content-Location: \'%s\'\n",me->value);
    }
    if (me->value[0] != '\0') {
      HTSACopy(&me->anchor->content_location,me->value);
    }
    break;
  case miCONTENT_MD5:
    HTMIME_TrimDoubleQuotes(me->value);
    if (WWW_TraceFlag != '\0') {
      pFVar8 = TraceFP();
      fprintf((FILE *)pFVar8,"HTMIME: PICKED UP Content-MD5: \'%s\'\n",me->value);
    }
    if (me->value[0] != '\0') {
      HTSACopy(&me->anchor->content_md5,me->value);
    }
    break;
  case miCONTENT_RANGE:
    HTMIME_TrimDoubleQuotes(me->value);
    if (WWW_TraceFlag != '\0') {
      pFVar8 = TraceFP();
      fprintf((FILE *)pFVar8,"HTMIME: PICKED UP Content-Range: \'%s\'\n",me->value);
    }
    break;
  case miCONTENT_TRANSFER_ENCODING:
    HTMIME_TrimDoubleQuotes(me->value);
    if (WWW_TraceFlag != '\0') {
      pFVar8 = TraceFP();
      fprintf((FILE *)pFVar8,"HTMIME: PICKED UP Content-Transfer-Encoding: \'%s\'\n",me->value);
    }
    if (me->value[0] != '\0') {
      LYLowerCase(me->value);
      pHVar6 = HTAtom_for(me->value);
      me->c_t_encoding = pHVar6;
    }
    break;
  case miCONTENT_TYPE:
    HTMIME_TrimDoubleQuotes(me->value);
    if (WWW_TraceFlag != '\0') {
      pFVar8 = TraceFP();
      fprintf((FILE *)pFVar8,"HTMIME: PICKED UP Content-Type: \'%s\'\n",me->value);
    }
    if (me->value[0] != '\0') {
      j = 0;
      for (i = 0; me->value[i] != '\0'; i = i + 1) {
        if ((me->value[i] != ' ') && (me->value[i] != '\"')) {
          ppuVar5 = __ctype_b_loc();
          if (((*ppuVar5)[(byte)me->value[i]] & 0x100) == 0) {
            local_2d = me->value[i];
          }
          else {
            iVar7 = tolower((uint)(byte)me->value[i]);
            local_2d = (char)iVar7;
          }
          me->value[j] = local_2d;
          j = j + 1;
        }
      }
      me->value[j] = '\0';
      pHVar6 = HTAtom_for(me->value);
      me->format = pHVar6;
      HTSACopy(&me->anchor->content_type_params,me->value);
    }
    break;
  case miDATE:
    HTMIME_TrimDoubleQuotes(me->value);
    if (WWW_TraceFlag != '\0') {
      pFVar8 = TraceFP();
      fprintf((FILE *)pFVar8,"HTMIME: PICKED UP Date: \'%s\'\n",me->value);
    }
    if (me->value[0] != '\0') {
      HTSACopy(&me->anchor->date,me->value);
    }
    break;
  case miETAG:
    if (WWW_TraceFlag != '\0') {
      pFVar8 = TraceFP();
      fprintf((FILE *)pFVar8,"HTMIME: PICKED UP ETag: %s\n",me->value);
    }
    if (me->value[0] != '\0') {
      HTSACopy(&me->anchor->ETag,me->value);
    }
    break;
  case miEXPIRES:
    HTMIME_TrimDoubleQuotes(me->value);
    if (WWW_TraceFlag != '\0') {
      pFVar8 = TraceFP();
      fprintf((FILE *)pFVar8,"HTMIME: PICKED UP Expires: \'%s\'\n",me->value);
    }
    if (me->value[0] != '\0') {
      HTSACopy(&me->anchor->expires,me->value);
    }
    break;
  case miKEEP_ALIVE:
    HTMIME_TrimDoubleQuotes(me->value);
    if (WWW_TraceFlag != '\0') {
      pFVar8 = TraceFP();
      fprintf((FILE *)pFVar8,"HTMIME: PICKED UP Keep-Alive: \'%s\'\n",me->value);
    }
    break;
  case miLAST_MODIFIED:
    HTMIME_TrimDoubleQuotes(me->value);
    if (WWW_TraceFlag != '\0') {
      pFVar8 = TraceFP();
      fprintf((FILE *)pFVar8,"HTMIME: PICKED UP Last-Modified: \'%s\'\n",me->value);
    }
    if (me->value[0] != '\0') {
      HTSACopy(&me->anchor->last_modified,me->value);
    }
    break;
  case miLINK:
    HTMIME_TrimDoubleQuotes(me->value);
    if (WWW_TraceFlag != '\0') {
      pFVar8 = TraceFP();
      fprintf((FILE *)pFVar8,"HTMIME: PICKED UP Link: \'%s\'\n",me->value);
    }
    break;
  case miLOCATION:
    HTMIME_TrimDoubleQuotes(me->value);
    if (WWW_TraceFlag != '\0') {
      pFVar8 = TraceFP();
      fprintf((FILE *)pFVar8,"HTMIME: PICKED UP Location: \'%s\'\n",me->value);
    }
    if ((me->pickup_redirection == '\0') || (me->location != (char *)0x0)) {
      if (WWW_TraceFlag != '\0') {
        pFVar8 = TraceFP();
        fprintf((FILE *)pFVar8,"HTMIME: *** Ignoring Location!\n");
      }
    }
    else {
      HTSACopy(&me->location,me->value);
    }
    break;
  case miPRAGMA:
    HTMIME_TrimDoubleQuotes(me->value);
    if (WWW_TraceFlag != '\0') {
      pFVar8 = TraceFP();
      fprintf((FILE *)pFVar8,"HTMIME: PICKED UP Pragma: \'%s\'\n",me->value);
    }
    if ((me->value[0] != '\0') && (iVar7 = strcmp(me->value,"no-cache"), iVar7 == 0)) {
      me->anchor->no_cache = '\x01';
    }
    break;
  case miPROXY_AUTHENTICATE:
    HTMIME_TrimDoubleQuotes(me->value);
    if (WWW_TraceFlag != '\0') {
      pFVar8 = TraceFP();
      fprintf((FILE *)pFVar8,"HTMIME: PICKED UP Proxy-Authenticate: \'%s\'\n",me->value);
    }
    break;
  case miPUBLIC:
    HTMIME_TrimDoubleQuotes(me->value);
    if (WWW_TraceFlag != '\0') {
      pFVar8 = TraceFP();
      fprintf((FILE *)pFVar8,"HTMIME: PICKED UP Public: \'%s\'\n",me->value);
    }
    break;
  case miREFRESH:
    HTMIME_TrimDoubleQuotes(me->value);
    if (WWW_TraceFlag != '\0') {
      pFVar8 = TraceFP();
      fprintf((FILE *)pFVar8,"HTMIME: PICKED UP Refresh: \'%s\'\n",me->value);
    }
    HTSACopy(&me->refresh_url,me->value);
    break;
  case miRETRY_AFTER:
    HTMIME_TrimDoubleQuotes(me->value);
    if (WWW_TraceFlag != '\0') {
      pFVar8 = TraceFP();
      fprintf((FILE *)pFVar8,"HTMIME: PICKED UP Retry-After: \'%s\'\n",me->value);
    }
    break;
  case miSAFE:
    HTMIME_TrimDoubleQuotes(me->value);
    if (WWW_TraceFlag != '\0') {
      pFVar8 = TraceFP();
      fprintf((FILE *)pFVar8,"HTMIME: PICKED UP Safe: \'%s\'\n",me->value);
    }
    if (me->value[0] != '\0') {
      iVar7 = strcasecomp(me->value,"YES");
      if ((iVar7 == 0) || (iVar7 = strcasecomp(me->value,"TRUE"), iVar7 == 0)) {
        me->anchor->safe = '\x01';
      }
      else {
        iVar7 = strcasecomp(me->value,"NO");
        if ((iVar7 == 0) || (iVar7 = strcasecomp(me->value,"FALSE"), iVar7 == 0)) {
          me->anchor->safe = '\0';
        }
      }
    }
    break;
  case miSERVER:
    HTMIME_TrimDoubleQuotes(me->value);
    if (WWW_TraceFlag != '\0') {
      pFVar8 = TraceFP();
      fprintf((FILE *)pFVar8,"HTMIME: PICKED UP Server: \'%s\'\n",me->value);
    }
    if (me->value[0] != '\0') {
      HTSACopy(&me->anchor->server,me->value);
    }
    break;
  case miSET_COOKIE1:
    HTMIME_TrimDoubleQuotes(me->value);
    if (WWW_TraceFlag != '\0') {
      pFVar8 = TraceFP();
      fprintf((FILE *)pFVar8,"HTMIME: PICKED UP Set-Cookie: \'%s\'\n",me->value);
    }
    if (me->set_cookie == (char *)0x0) {
      HTSACopy(&me->set_cookie,me->value);
    }
    else {
      HTSACat(&me->set_cookie,", ");
      HTSACat(&me->set_cookie,me->value);
    }
    break;
  case miSET_COOKIE2:
    HTMIME_TrimDoubleQuotes(me->value);
    if (WWW_TraceFlag != '\0') {
      pFVar8 = TraceFP();
      fprintf((FILE *)pFVar8,"HTMIME: PICKED UP Set-Cookie2: \'%s\'\n",me->value);
    }
    if (me->set_cookie2 == (char *)0x0) {
      HTSACopy(&me->set_cookie2,me->value);
    }
    else {
      HTSACat(&me->set_cookie2,", ");
      HTSACat(&me->set_cookie2,me->value);
    }
    break;
  case miTITLE:
    HTMIME_TrimDoubleQuotes(me->value);
    if (WWW_TraceFlag != '\0') {
      pFVar8 = TraceFP();
      fprintf((FILE *)pFVar8,"HTMIME: PICKED UP Title: \'%s\'\n",me->value);
    }
    break;
  case miTRANSFER_ENCODING:
    HTMIME_TrimDoubleQuotes(me->value);
    if (WWW_TraceFlag != '\0') {
      pFVar8 = TraceFP();
      fprintf((FILE *)pFVar8,"HTMIME: PICKED UP Transfer-Encoding: \'%s\'\n",me->value);
    }
    iVar7 = strcmp(me->value,"chunked");
    if (iVar7 == 0) {
      me->chunked_encoding = '\x01';
    }
    break;
  case miUPGRADE:
    HTMIME_TrimDoubleQuotes(me->value);
    if (WWW_TraceFlag != '\0') {
      pFVar8 = TraceFP();
      fprintf((FILE *)pFVar8,"HTMIME: PICKED UP Upgrade: \'%s\'\n",me->value);
    }
    break;
  case miURI:
    HTMIME_TrimDoubleQuotes(me->value);
    if (WWW_TraceFlag != '\0') {
      pFVar8 = TraceFP();
      fprintf((FILE *)pFVar8,"HTMIME: PICKED UP URI: \'%s\'\n",me->value);
    }
    break;
  case miVARY:
    HTMIME_TrimDoubleQuotes(me->value);
    if (WWW_TraceFlag != '\0') {
      pFVar8 = TraceFP();
      fprintf((FILE *)pFVar8,"HTMIME: PICKED UP Vary: \'%s\'\n",me->value);
    }
    break;
  case miVIA:
    HTMIME_TrimDoubleQuotes(me->value);
    if (WWW_TraceFlag != '\0') {
      pFVar8 = TraceFP();
      fprintf((FILE *)pFVar8,"HTMIME: PICKED UP Via: \'%s\'\n",me->value);
    }
    break;
  case miWARNING:
    HTMIME_TrimDoubleQuotes(me->value);
    if (WWW_TraceFlag != '\0') {
      pFVar8 = TraceFP();
      fprintf((FILE *)pFVar8,"HTMIME: PICKED UP Warning: \'%s\'\n",me->value);
    }
    break;
  case miWWW_AUTHENTICATE:
    HTMIME_TrimDoubleQuotes(me->value);
    if (WWW_TraceFlag != '\0') {
      pFVar8 = TraceFP();
      fprintf((FILE *)pFVar8,"HTMIME: PICKED UP WWW-Authenticate: \'%s\'\n",me->value);
    }
  }
  return 0;
}



void HTMIME_put_character(HTStream_conflict6 *me,char c)

{
  char cVar1;
  int iVar2;
  char *pcVar3;
  FILE *pFVar4;
  ushort **ppuVar5;
  uint uVar6;
  int local_64;
  MIME_state local_60;
  uint local_18;
  char c_local;
  
  c_local = c;
  switch(me->state) {
  case MIME_CHUNKED:
    while( true ) {
      me->chunked_size = 0;
      me->state = mcCHUNKED_COUNT_DIGIT;
switchD_081304f3_caseD_2:
      ppuVar5 = __ctype_b_loc();
      if (((*ppuVar5)[(byte)c] & 0x1000) != 0) {
        me->chunked_size = me->chunked_size << 4;
        ppuVar5 = __ctype_b_loc();
        if (((*ppuVar5)[(byte)c] & 0x800) != 0) {
          me->chunked_size = me->chunked_size + ((byte)c - 0x30);
          return;
        }
        iVar2 = me->chunked_size;
        ppuVar5 = __ctype_b_loc();
        if (((*ppuVar5)[(byte)c] & 0x200) == 0) {
          uVar6 = (uint)(byte)c;
        }
        else {
          uVar6 = toupper((uint)(byte)c);
        }
        local_64 = uVar6 - 0x37;
        me->chunked_size = iVar2 + local_64;
        return;
      }
      if (c == ';') {
        me->state = mcCHUNKED_EXTENSION;
      }
switchD_081304f3_caseD_5:
      if ((c != '\r') && (c != '\n')) break;
      me->state = mcCHUNKED_COUNT_CR;
switchD_081304f3_caseD_3:
      me->state = mcCHUNKED_COUNT_LF;
      if (c == '\r') {
        return;
      }
switchD_081304f3_caseD_4:
      if (me->chunked_size == 0) {
        local_60 = MIME_CHUNKED;
      }
      else {
        local_60 = mcCHUNKED_DATA;
      }
      me->state = local_60;
      if (c == '\n') {
        return;
      }
    }
    return;
  case mcCHUNKED_COUNT_DIGIT:
    goto switchD_081304f3_caseD_2;
  case mcCHUNKED_COUNT_CR:
    goto switchD_081304f3_caseD_3;
  case mcCHUNKED_COUNT_LF:
    goto switchD_081304f3_caseD_4;
  case mcCHUNKED_EXTENSION:
    goto switchD_081304f3_caseD_5;
  case mcCHUNKED_DATA:
    (*(me->targetClass).put_character)(me->target,c);
    me->chunked_size = me->chunked_size + -1;
    if (0 < me->chunked_size) {
      return;
    }
    me->state = mcCHUNKED_DATA_CR;
    return;
  case mcCHUNKED_DATA_CR:
    me->state = mcCHUNKED_DATA_LF;
    if (c == '\r') {
      return;
    }
  case mcCHUNKED_DATA_LF:
    me->state = MIME_CHUNKED;
    if (c == '\n') {
      return;
    }
    if (WWW_TraceFlag != '\0') {
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTIME_put_character expected LF in chunked data\n");
    }
    me->state = MIME_TRANSPARENT;
  case MIME_TRANSPARENT:
    (*(me->targetClass).put_character)(me->target,c);
    return;
  default:
    if (me->net_ascii != '\0') {
      if (c == '\r') {
        return;
      }
      if (c == '\n') {
        c_local = '\n';
      }
    }
  }
  switch(me->state) {
  default:
    goto switchD_08130774_caseD_0;
  case miA:
    switch(c_local) {
    case 'C':
    case 'c':
      me->check_pointer = "cept-ranges:";
      me->if_ok = miACCEPT_RANGES;
      me->state = miCHECK;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Was A, found C, checking for \'cept-ranges:\'\n");
      return;
    default:
      if (WWW_TraceFlag != '\0') {
        pFVar4 = TraceFP();
        fprintf((FILE *)pFVar4,"HTMIME: Bad character `%c\' found where `%s\' expected\n",
                (int)c_local,"\'g\' or \'l\'");
      }
      break;
    case 'G':
    case 'g':
      me->check_pointer = "e:";
      me->if_ok = miAGE;
      me->state = miCHECK;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Was A, found G, checking for \'e:\'\n");
      return;
    case 'L':
    case 'l':
      me->state = miAL;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Was A, found L, state now AL\'\n");
      return;
    }
    break;
  case miACCEPT_RANGES:
  case miAGE:
  case miALLOW:
  case miALTERNATES:
  case miCACHE_CONTROL:
  case miCOOKIE:
  case miCONNECTION:
  case miCONTENT_BASE:
  case miCONTENT_DISPOSITION:
  case miCONTENT_ENCODING:
  case miCONTENT_FEATURES:
  case miCONTENT_LANGUAGE:
  case miCONTENT_LENGTH:
  case miCONTENT_LOCATION:
  case miCONTENT_MD5:
  case miCONTENT_RANGE:
  case miCONTENT_TRANSFER_ENCODING:
  case miCONTENT_TYPE:
  case miDATE:
  case miETAG:
  case miEXPIRES:
  case miKEEP_ALIVE:
  case miLAST_MODIFIED:
  case miLINK:
  case miLOCATION:
  case miPRAGMA:
  case miPROXY_AUTHENTICATE:
  case miPUBLIC:
  case miREFRESH:
  case miRETRY_AFTER:
  case miSAFE:
  case miSERVER:
  case miSET_COOKIE1:
  case miSET_COOKIE2:
  case miTITLE:
  case miTRANSFER_ENCODING:
  case miUPGRADE:
  case miURI:
  case miVARY:
  case miVIA:
  case miWARNING:
  case miWWW_AUTHENTICATE:
    me->field = me->state;
    me->state = miSKIP_GET_VALUE;
  case miSKIP_GET_VALUE:
    if (c_local == '\n') {
      me->fold_state = me->state;
      me->state = miNEWLINE;
      return;
    }
    if ((byte)c_local < 0x21) {
      return;
    }
    me->value_pointer = me->value;
    me->state = miGET_VALUE;
  case miGET_VALUE:
GET_VALUE:
    if (c_local == '\n') {
switchD_08130774_caseD_4b:
      if (c_local != '\n') {
        return;
      }
      me->fold_state = me->state;
      me->state = miNEWLINE;
      return;
    }
    if (me->value_pointer < me->value + 0x13ff) {
      pcVar3 = me->value_pointer;
      *pcVar3 = c_local;
      me->value_pointer = pcVar3 + 1;
      return;
    }
    if (WWW_TraceFlag != '\0') {
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: *** Syntax error. (string too long)\n");
    }
    break;
  case miAL:
    if (c_local == 'T') {
LAB_08130cc9:
      me->check_pointer = "ernates:";
      me->if_ok = miALTERNATES;
      me->state = miCHECK;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Was AL, found T, checking for \'ernates:\'\n");
      return;
    }
    if (c_local < 'U') {
      if (c_local == 'L') {
LAB_08130c80:
        me->check_pointer = "ow:";
        me->if_ok = miALLOW;
        me->state = miCHECK;
        if (WWW_TraceFlag == '\0') {
          return;
        }
        pFVar4 = TraceFP();
        fprintf((FILE *)pFVar4,"HTMIME: Was AL, found L, checking for \'ow:\'\n");
        return;
      }
    }
    else {
      if (c_local == 'l') goto LAB_08130c80;
      if (c_local == 't') goto LAB_08130cc9;
    }
    if (WWW_TraceFlag != '\0') {
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Bad character `%c\' found where `%s\' expected\n",(int)c_local
              ,"\'l\' or \'t\'");
    }
    break;
  case miC:
    if (c_local == 'O') {
LAB_08130dc2:
      me->state = miCO;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Was C, found O, state now CO\'\n");
      return;
    }
    if (c_local < 'P') {
      if (c_local == 'A') {
LAB_08130d79:
        me->check_pointer = "che-control:";
        me->if_ok = miCACHE_CONTROL;
        me->state = miCHECK;
        if (WWW_TraceFlag == '\0') {
          return;
        }
        pFVar4 = TraceFP();
        fprintf((FILE *)pFVar4,"HTMIME: Was C, found A, checking for \'che-control:\'\n");
        return;
      }
    }
    else {
      if (c_local == 'a') goto LAB_08130d79;
      if (c_local == 'o') goto LAB_08130dc2;
    }
    if (WWW_TraceFlag != '\0') {
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Bad character `%c\' found where `%s\' expected\n",(int)c_local
              ,"\'a\' or \'o\'");
    }
    break;
  case miCO:
    if (c_local == 'O') {
LAB_08130e93:
      me->check_pointer = "kie:";
      me->if_ok = miCOOKIE;
      me->state = miCHECK;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Was CO, found O, checking for \'kie:\'\n");
      return;
    }
    if (c_local < 'P') {
      if (c_local == 'N') {
LAB_08130e5e:
        me->state = miCON;
        if (WWW_TraceFlag == '\0') {
          return;
        }
        pFVar4 = TraceFP();
        fprintf((FILE *)pFVar4,"HTMIME: Was CO, found N, state now CON\n");
        return;
      }
    }
    else {
      if (c_local == 'n') goto LAB_08130e5e;
      if (c_local == 'o') goto LAB_08130e93;
    }
    if (WWW_TraceFlag != '\0') {
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Bad character `%c\' found where `%s\' expected\n",(int)c_local
              ,"\'n\' or \'o\'");
    }
    break;
  case miCON:
    if (c_local == 'T') {
LAB_08130f8f:
      me->check_pointer = "ent-";
      me->if_ok = miCONTENT_;
      me->state = miCHECK;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Was CON, found T, checking for \'ent-\'\n");
      return;
    }
    if (c_local < 'U') {
      if (c_local == 'N') {
LAB_08130f46:
        me->check_pointer = "ection:";
        me->if_ok = miCONNECTION;
        me->state = miCHECK;
        if (WWW_TraceFlag == '\0') {
          return;
        }
        pFVar4 = TraceFP();
        fprintf((FILE *)pFVar4,"HTMIME: Was CON, found N, checking for \'ection:\'\n");
        return;
      }
    }
    else {
      if (c_local == 'n') goto LAB_08130f46;
      if (c_local == 't') goto LAB_08130f8f;
    }
    if (WWW_TraceFlag != '\0') {
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Bad character `%c\' found where `%s\' expected\n",(int)c_local
              ,"\'n\' or \'t\'");
    }
    break;
  case miCONTENT_:
    if (WWW_TraceFlag != '\0') {
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: in case CONTENT_\n");
    }
    switch(c_local) {
    case 'B':
    case 'b':
      me->check_pointer = "ase:";
      me->if_ok = miCONTENT_BASE;
      me->state = miCHECK;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Was CONTENT_, found B, checking for \'ase:\'\n");
      return;
    default:
      if (WWW_TraceFlag != '\0') {
        pFVar4 = TraceFP();
        fprintf((FILE *)pFVar4,"HTMIME: Was CONTENT_, found nothing; bleah\n");
      }
      break;
    case 'D':
    case 'd':
      me->check_pointer = "isposition:";
      me->if_ok = miCONTENT_DISPOSITION;
      me->state = miCHECK;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Was CONTENT_, found D, checking for \'isposition:\'\n");
      return;
    case 'E':
    case 'e':
      me->check_pointer = "ncoding:";
      me->if_ok = miCONTENT_ENCODING;
      me->state = miCHECK;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Was CONTENT_, found E, checking for \'ncoding:\'\n");
      return;
    case 'F':
    case 'f':
      me->check_pointer = "eatures:";
      me->if_ok = miCONTENT_FEATURES;
      me->state = miCHECK;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Was CONTENT_, found F, checking for \'eatures:\'\n");
      return;
    case 'L':
    case 'l':
      me->state = miCONTENT_L;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Was CONTENT_, found L, state now CONTENT_L\n");
      return;
    case 'M':
    case 'm':
      me->check_pointer = "d5:";
      me->if_ok = miCONTENT_MD5;
      me->state = miCHECK;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Was CONTENT_, found M, checking for \'d5:\'\n");
      return;
    case 'R':
    case 'r':
      me->check_pointer = "ange:";
      me->if_ok = miCONTENT_RANGE;
      me->state = miCHECK;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Was CONTENT_, found R, checking for \'ange:\'\n");
      return;
    case 'T':
    case 't':
      me->state = miCONTENT_T;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Was CONTENT_, found T, state now CONTENT_T\n");
      return;
    }
    break;
  case miCONTENT_L:
    if (WWW_TraceFlag != '\0') {
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: in case CONTENT_L\n");
    }
    switch(c_local) {
    case 'A':
    case 'a':
      me->check_pointer = "nguage:";
      me->if_ok = miCONTENT_LANGUAGE;
      me->state = miCHECK;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Was CONTENT_L, found A, checking for \'nguage:\'\n");
      return;
    default:
      if (WWW_TraceFlag != '\0') {
        pFVar4 = TraceFP();
        fprintf((FILE *)pFVar4,"HTMIME: Was CONTENT_L, found nothing; bleah\n");
      }
      break;
    case 'E':
    case 'e':
      me->check_pointer = "ngth:";
      me->if_ok = miCONTENT_LENGTH;
      me->state = miCHECK;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Was CONTENT_L, found E, checking for \'ngth:\'\n");
      return;
    case 'O':
    case 'o':
      me->check_pointer = "cation:";
      me->if_ok = miCONTENT_LOCATION;
      me->state = miCHECK;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Was CONTENT_L, found O, checking for \'cation:\'\n");
      return;
    }
    break;
  case miCONTENT_T:
    if (WWW_TraceFlag != '\0') {
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: in case CONTENT_T\n");
    }
    if (c_local == 'Y') {
LAB_08132194:
      me->check_pointer = "pe:";
      me->if_ok = miCONTENT_TYPE;
      me->state = miCHECK;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Was CONTENT_T, found Y, checking for \'pe:\'\n");
      return;
    }
    if (c_local < 'Z') {
      if (c_local == 'R') {
LAB_0813214b:
        me->check_pointer = "ansfer-encoding:";
        me->if_ok = miCONTENT_TRANSFER_ENCODING;
        me->state = miCHECK;
        if (WWW_TraceFlag == '\0') {
          return;
        }
        pFVar4 = TraceFP();
        fprintf((FILE *)pFVar4,"HTMIME: Was CONTENT_T, found R, checking for \'ansfer-encoding:\'\n"
               );
        return;
      }
    }
    else {
      if (c_local == 'r') goto LAB_0813214b;
      if (c_local == 'y') goto LAB_08132194;
    }
    if (WWW_TraceFlag != '\0') {
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Was CONTENT_T, found nothing; bleah\n");
    }
    break;
  case miE:
    if (c_local == 'X') {
LAB_0813108b:
      me->check_pointer = "pires:";
      me->if_ok = miEXPIRES;
      me->state = miCHECK;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Was E, found X, checking for \'pires:\'\n");
      return;
    }
    if (c_local < 'Y') {
      if (c_local == 'T') {
LAB_08131042:
        me->check_pointer = "ag:";
        me->if_ok = miETAG;
        me->state = miCHECK;
        if (WWW_TraceFlag == '\0') {
          return;
        }
        pFVar4 = TraceFP();
        fprintf((FILE *)pFVar4,"HTMIME: Was E, found T, checking for \'ag:\'\n");
        return;
      }
    }
    else {
      if (c_local == 't') goto LAB_08131042;
      if (c_local == 'x') goto LAB_0813108b;
    }
    if (WWW_TraceFlag != '\0') {
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Bad character `%c\' found where `%s\' expected\n",(int)c_local
              ,"\'t\' or \'x\'");
    }
    break;
  case miL:
    switch(c_local) {
    case 'A':
    case 'a':
      me->check_pointer = "st-modified:";
      me->if_ok = miLAST_MODIFIED;
      me->state = miCHECK;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Was L, found A, checking for \'st-modified:\'\n");
      return;
    default:
      if (WWW_TraceFlag != '\0') {
        pFVar4 = TraceFP();
        fprintf((FILE *)pFVar4,"HTMIME: Bad character `%c\' found where `%s\' expected\n",
                (int)c_local,"\'a\', \'i\' or \'o\'");
      }
      break;
    case 'I':
    case 'i':
      me->check_pointer = "nk:";
      me->if_ok = miLINK;
      me->state = miCHECK;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Was L, found I, checking for \'nk:\'\n");
      return;
    case 'O':
    case 'o':
      me->check_pointer = "cation:";
      me->if_ok = miLOCATION;
      me->state = miCHECK;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Was L, found O, checking for \'cation:\'\n");
      return;
    }
    break;
  case miP:
    if (c_local == 'U') {
LAB_081312a6:
      me->check_pointer = "blic:";
      me->if_ok = miPUBLIC;
      me->state = miCHECK;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Was P, found U, checking for \'blic:\'\n");
      return;
    }
    if (c_local < 'V') {
      if (c_local == 'R') {
LAB_08131271:
        me->state = miPR;
        if (WWW_TraceFlag == '\0') {
          return;
        }
        pFVar4 = TraceFP();
        fprintf((FILE *)pFVar4,"HTMIME: Was P, found R, state now PR\'\n");
        return;
      }
    }
    else {
      if (c_local == 'r') goto LAB_08131271;
      if (c_local == 'u') goto LAB_081312a6;
    }
    if (WWW_TraceFlag != '\0') {
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Bad character `%c\' found where `%s\' expected\n",(int)c_local
              ,"\'r\' or \'u\'");
    }
    break;
  case miPR:
    if (c_local == 'O') {
LAB_081313a2:
      me->check_pointer = "xy-authenticate:";
      me->if_ok = miPROXY_AUTHENTICATE;
      me->state = miCHECK;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Was PR, found O, checking for \'xy-authenticate\'\n");
      return;
    }
    if (c_local < 'P') {
      if (c_local == 'A') {
LAB_08131359:
        me->check_pointer = "gma:";
        me->if_ok = miPRAGMA;
        me->state = miCHECK;
        if (WWW_TraceFlag == '\0') {
          return;
        }
        pFVar4 = TraceFP();
        fprintf((FILE *)pFVar4,"HTMIME: Was PR, found A, checking for \'gma\'\n");
        return;
      }
    }
    else {
      if (c_local == 'a') goto LAB_08131359;
      if (c_local == 'o') goto LAB_081313a2;
    }
    if (WWW_TraceFlag != '\0') {
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Bad character `%c\' found where `%s\' expected\n",(int)c_local
              ,"\'a\' or \'o\'");
    }
    break;
  case miR:
    if ((c_local == 'E') || (c_local == 'e')) {
      me->state = miRE;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Was R, found E\n");
      return;
    }
    if (WWW_TraceFlag != '\0') {
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Bad character `%c\' found where `%s\' expected\n",(int)c_local
              ,&DAT_0818d9c9);
    }
    break;
  case miRE:
    if (c_local == 'T') {
LAB_0813152b:
      me->check_pointer = "ry-after:";
      me->if_ok = miRETRY_AFTER;
      me->state = miCHECK;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      pcVar3 = me->check_pointer;
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Was RE, found T, checking for \'%s\'\n",pcVar3);
      return;
    }
    if (c_local < 'U') {
      if (c_local == 'F') {
LAB_081314d8:
        me->check_pointer = "resh:";
        me->if_ok = miREFRESH;
        me->state = miCHECK;
        if (WWW_TraceFlag == '\0') {
          return;
        }
        pcVar3 = me->check_pointer;
        pFVar4 = TraceFP();
        fprintf((FILE *)pFVar4,"HTMIME: Was RE, found F, checking for \'%s\'\n",pcVar3);
        return;
      }
    }
    else {
      if (c_local == 'f') goto LAB_081314d8;
      if (c_local == 't') goto LAB_0813152b;
    }
    if (WWW_TraceFlag != '\0') {
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Bad character `%c\' found where `%s\' expected\n",(int)c_local
              ,"\'f\' or \'t\'");
    }
    break;
  case miS:
    if (c_local == 'E') {
LAB_0813162e:
      me->state = miSE;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Was S, found E, state now SE\'\n");
      return;
    }
    if (c_local < 'F') {
      if (c_local == 'A') {
LAB_081315e5:
        me->check_pointer = "fe:";
        me->if_ok = miSAFE;
        me->state = miCHECK;
        if (WWW_TraceFlag == '\0') {
          return;
        }
        pFVar4 = TraceFP();
        fprintf((FILE *)pFVar4,"HTMIME: Was S, found A, checking for \'fe:\'\n");
        return;
      }
    }
    else {
      if (c_local == 'a') goto LAB_081315e5;
      if (c_local == 'e') goto LAB_0813162e;
    }
    if (WWW_TraceFlag != '\0') {
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Bad character `%c\' found where `%s\' expected\n",(int)c_local
              ,"\'a\' or \'e\'");
    }
    break;
  case miSE:
    if (c_local == 'T') {
LAB_08131716:
      me->check_pointer = "-cookie";
      me->if_ok = miSET_COOKIE;
      me->state = miCHECK;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Was SE, found T, checking for \'-cookie\'\n");
      return;
    }
    if (c_local < 'U') {
      if (c_local == 'R') {
LAB_081316cd:
        me->check_pointer = "ver:";
        me->if_ok = miSERVER;
        me->state = miCHECK;
        if (WWW_TraceFlag == '\0') {
          return;
        }
        pFVar4 = TraceFP();
        fprintf((FILE *)pFVar4,"HTMIME: Was SE, found R, checking for \'ver\'\n");
        return;
      }
    }
    else {
      if (c_local == 'r') goto LAB_081316cd;
      if (c_local == 't') goto LAB_08131716;
    }
    if (WWW_TraceFlag != '\0') {
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Bad character `%c\' found where `%s\' expected\n",(int)c_local
              ,"\'r\' or \'t\'");
    }
    break;
  case miSET_COOKIE:
    if (c_local == '2') {
      me->check_pointer = ":";
      me->if_ok = miSET_COOKIE2;
      me->state = miCHECK;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Was SET_COOKIE, found 2, checking for \':\'\n");
      return;
    }
    if (c_local == ':') {
      me->field = miSET_COOKIE1;
      me->state = miSKIP_GET_VALUE;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Was SET_COOKIE, found :, processing\n");
      return;
    }
    if (WWW_TraceFlag != '\0') {
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Bad character `%c\' found where `%s\' expected\n",(int)c_local
              ,"\':\' or \'2\'");
    }
    break;
  case miT:
    if (c_local == 'R') {
LAB_081318ec:
      me->check_pointer = "ansfer-encoding:";
      me->if_ok = miTRANSFER_ENCODING;
      me->state = miCHECK;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Was T, found R, checking for \'ansfer-encoding\'\n");
      return;
    }
    if (c_local < 'S') {
      if (c_local == 'I') {
LAB_081318a3:
        me->check_pointer = "tle:";
        me->if_ok = miTITLE;
        me->state = miCHECK;
        if (WWW_TraceFlag == '\0') {
          return;
        }
        pFVar4 = TraceFP();
        fprintf((FILE *)pFVar4,"HTMIME: Was T, found I, checking for \'tle:\'\n");
        return;
      }
    }
    else {
      if (c_local == 'i') goto LAB_081318a3;
      if (c_local == 'r') goto LAB_081318ec;
    }
    if (WWW_TraceFlag != '\0') {
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Bad character `%c\' found where `%s\' expected\n",(int)c_local
              ,"\'i\' or \'r\'");
    }
    break;
  case miU:
    if (c_local == 'R') {
LAB_081319e8:
      me->check_pointer = "i:";
      me->if_ok = miURI;
      me->state = miCHECK;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Was U, found R, checking for \'i:\'\n");
      return;
    }
    if (c_local < 'S') {
      if (c_local == 'P') {
LAB_0813199f:
        me->check_pointer = "grade:";
        me->if_ok = miUPGRADE;
        me->state = miCHECK;
        if (WWW_TraceFlag == '\0') {
          return;
        }
        pFVar4 = TraceFP();
        fprintf((FILE *)pFVar4,"HTMIME: Was U, found P, checking for \'grade:\'\n");
        return;
      }
    }
    else {
      if (c_local == 'p') goto LAB_0813199f;
      if (c_local == 'r') goto LAB_081319e8;
    }
    if (WWW_TraceFlag != '\0') {
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Bad character `%c\' found where `%s\' expected\n",(int)c_local
              ,"\'p\' or \'r\'");
    }
    break;
  case miV:
    if (c_local == 'I') {
LAB_08131ae4:
      me->check_pointer = "a:";
      me->if_ok = miVIA;
      me->state = miCHECK;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Was V, found I, checking for \'a:\'\n");
      return;
    }
    if (c_local < 'J') {
      if (c_local == 'A') {
LAB_08131a9b:
        me->check_pointer = "ry:";
        me->if_ok = miVARY;
        me->state = miCHECK;
        if (WWW_TraceFlag == '\0') {
          return;
        }
        pFVar4 = TraceFP();
        fprintf((FILE *)pFVar4,"HTMIME: Was V, found A, checking for \'ry:\'\n");
        return;
      }
    }
    else {
      if (c_local == 'a') goto LAB_08131a9b;
      if (c_local == 'i') goto LAB_08131ae4;
    }
    if (WWW_TraceFlag != '\0') {
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Bad character `%c\' found where `%s\' expected\n",(int)c_local
              ,"\'a\' or \'i\'");
    }
    break;
  case miW:
    if (c_local == 'W') {
LAB_08131be0:
      me->check_pointer = "w-authenticate:";
      me->if_ok = miWWW_AUTHENTICATE;
      me->state = miCHECK;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Was W, found W, checking for \'w-authenticate:\'\n");
      return;
    }
    if (c_local < 'X') {
      if (c_local == 'A') {
LAB_08131b97:
        me->check_pointer = "rning:";
        me->if_ok = miWARNING;
        me->state = miCHECK;
        if (WWW_TraceFlag == '\0') {
          return;
        }
        pFVar4 = TraceFP();
        fprintf((FILE *)pFVar4,"HTMIME: Was W, found A, checking for \'rning:\'\n");
        return;
      }
    }
    else {
      if (c_local == 'a') goto LAB_08131b97;
      if (c_local == 'w') goto LAB_08131be0;
    }
    if (WWW_TraceFlag != '\0') {
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Bad character `%c\' found where `%s\' expected\n",(int)c_local
              ,"\'a\' or \'w\'");
    }
    break;
  case miJUNK_LINE:
    goto switchD_08130774_caseD_4b;
  case miNEWLINE:
    if ((c_local != '\n') && ((byte)c_local < 0x21)) {
      me->state = me->fold_state;
      if (me->state != miGET_VALUE) {
        return;
      }
      if (me->value_pointer == (char *)0x0) {
        return;
      }
      if (me->value_pointer == me->value) {
        return;
      }
      if ((byte)me->value_pointer[-1] < 0x21) {
        return;
      }
      c_local = ' ';
      goto GET_VALUE;
    }
    if (me->fold_state == miGET_VALUE) {
      dispatchField(me);
    }
  case miBEGINNING_OF_LINE:
    me->net_ascii = '\x01';
    switch(c_local) {
    case '\n':
      me->net_ascii = '\0';
      pumpData(me);
      return;
    case 'A':
    case 'a':
      me->state = miA;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Got \'A\' at beginning of line, state now A\n");
      return;
    case 'C':
    case 'c':
      me->state = miC;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Got \'C\' at beginning of line, state now C\n");
      return;
    case 'D':
    case 'd':
      me->check_pointer = "ate:";
      me->if_ok = miDATE;
      me->state = miCHECK;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Got \'D\' at beginning of line, checking for \'ate:\'\n");
      return;
    case 'E':
    case 'e':
      me->state = miE;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Got \'E\' at beginning of line, state now E\n");
      return;
    case 'K':
    case 'k':
      me->check_pointer = "eep-alive:";
      me->if_ok = miKEEP_ALIVE;
      me->state = miCHECK;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Got \'K\' at beginning of line, checking for \'eep-alive:\'\n"
             );
      return;
    case 'L':
    case 'l':
      me->state = miL;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Got \'L\' at beginning of line, state now L\n");
      return;
    case 'P':
    case 'p':
      me->state = miP;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Got \'P\' at beginning of line, state now P\n");
      return;
    case 'R':
    case 'r':
      me->state = miR;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Got \'R\' at beginning of line, state now R\n");
      return;
    case 'S':
    case 's':
      me->state = miS;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Got \'S\' at beginning of line, state now S\n");
      return;
    case 'T':
    case 't':
      me->state = miT;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Got \'T\' at beginning of line, state now T\n");
      return;
    case 'U':
    case 'u':
      me->state = miU;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Got \'U\' at beginning of line, state now U\n");
      return;
    case 'V':
    case 'v':
      me->state = miV;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Got \'V\' at beginning of line, state now V\n");
      return;
    case 'W':
    case 'w':
      me->state = miW;
      if (WWW_TraceFlag == '\0') {
        return;
      }
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Got \'W\' at beginning of line, state now W\n");
      return;
    }
    break;
  case miCHECK:
    ppuVar5 = __ctype_b_loc();
    if (((*ppuVar5)[(byte)c_local] & 0x100) == 0) {
      local_18 = (uint)(byte)c_local;
    }
    else {
      local_18 = tolower((uint)(byte)c_local);
    }
    cVar1 = *me->check_pointer;
    me->check_pointer = me->check_pointer + 1;
    if (local_18 == (int)cVar1) {
      if (*me->check_pointer != '\0') {
        return;
      }
      me->state = me->if_ok;
      return;
    }
    if (WWW_TraceFlag != '\0') {
      pcVar3 = me->check_pointer;
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTMIME: Bad character `%c\' found where `%s\' expected\n",(int)c_local
              ,pcVar3 + -1);
    }
    break;
  case MIME_NET_ASCII:
    (*(me->targetClass).put_character)(me->target,c_local);
    return;
  }
  me->state = miJUNK_LINE;
switchD_08130774_caseD_0:
  return;
}



// WARNING: Unknown calling convention

void HTMIME_put_string(HTStream_conflict6 *me,char *s)

{
  FILE *__stream;
  char *p;
  
  if (me->state == MIME_TRANSPARENT) {
    (*(me->targetClass).put_string)(me->target,s);
  }
  else if (me->state != MIME_IGNORE) {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME:  %s\n",s);
    }
    for (p = s; *p != '\0'; p = p + 1) {
      HTMIME_put_character(me,*p);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void HTMIME_write(HTStream_conflict6 *me,char *s,int l)

{
  FILE *__stream;
  char *p;
  
  if (me->state == MIME_TRANSPARENT) {
    (*(me->targetClass).put_block)(me->target,s,l);
  }
  else {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTMIME:  %.*s\n",l,s);
    }
    for (p = s; p < s + l; p = p + 1) {
      HTMIME_put_character(me,*p);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void HTMIME_free(HTStream_conflict6 *me)

{
  if (me != (HTStream_conflict6 *)0x0) {
    if (me->location != (char *)0x0) {
      free(me->location);
      me->location = (char *)0x0;
    }
    if (me->compression_encoding != (char *)0x0) {
      free(me->compression_encoding);
      me->compression_encoding = (char *)0x0;
    }
    if (me->target != (HTStream_conflict6 *)0x0) {
      (*(me->targetClass)._free)(me->target);
    }
    if (me != (HTStream_conflict6 *)0x0) {
      free(me);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void HTMIME_abort(HTStream_conflict6 *me,HTError e)

{
  if (me != (HTStream_conflict6 *)0x0) {
    if (me->location != (char *)0x0) {
      free(me->location);
      me->location = (char *)0x0;
    }
    if (me->compression_encoding != (char *)0x0) {
      free(me->compression_encoding);
      me->compression_encoding = (char *)0x0;
    }
    if (me->target != (HTStream_conflict6 *)0x0) {
      (*(me->targetClass)._abort)(me->target,e);
    }
    if (me != (HTStream_conflict6 *)0x0) {
      free(me);
    }
  }
  return;
}



// WARNING: Unknown calling convention

HTStream_conflict6 *
HTMIMEConvert(HTPresentation_conflict3 *pres,HTParentAnchor *anchor,HTStream_conflict6 *sink)

{
  HTStream_conflict6 *pHVar1;
  HTAtom *pHVar2;
  HTStream_conflict6 *me;
  
  pHVar1 = (HTStream_conflict6 *)calloc(1,0x1474);
  if (pHVar1 == (HTStream_conflict6 *)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTMIME.c","HTMIMEConvert");
  }
  pHVar1->isa = &HTMIME;
  pHVar1->sink = sink;
  pHVar1->anchor = anchor;
  pHVar1->anchor->safe = '\0';
  pHVar1->anchor->no_cache = '\0';
  if (pHVar1->anchor->cache_control != (char *)0x0) {
    free(pHVar1->anchor->cache_control);
    pHVar1->anchor->cache_control = (char *)0x0;
  }
  if (pHVar1->anchor->SugFname != (char *)0x0) {
    free(pHVar1->anchor->SugFname);
    pHVar1->anchor->SugFname = (char *)0x0;
  }
  if (pHVar1->anchor->charset != (char *)0x0) {
    free(pHVar1->anchor->charset);
    pHVar1->anchor->charset = (char *)0x0;
  }
  if (pHVar1->anchor->content_type_params != (char *)0x0) {
    free(pHVar1->anchor->content_type_params);
    pHVar1->anchor->content_type_params = (char *)0x0;
  }
  if (pHVar1->anchor->content_language != (char *)0x0) {
    free(pHVar1->anchor->content_language);
    pHVar1->anchor->content_language = (char *)0x0;
  }
  if (pHVar1->anchor->content_encoding != (char *)0x0) {
    free(pHVar1->anchor->content_encoding);
    pHVar1->anchor->content_encoding = (char *)0x0;
  }
  if (pHVar1->anchor->content_base != (char *)0x0) {
    free(pHVar1->anchor->content_base);
    pHVar1->anchor->content_base = (char *)0x0;
  }
  if (pHVar1->anchor->content_disposition != (char *)0x0) {
    free(pHVar1->anchor->content_disposition);
    pHVar1->anchor->content_disposition = (char *)0x0;
  }
  if (pHVar1->anchor->content_location != (char *)0x0) {
    free(pHVar1->anchor->content_location);
    pHVar1->anchor->content_location = (char *)0x0;
  }
  if (pHVar1->anchor->content_md5 != (char *)0x0) {
    free(pHVar1->anchor->content_md5);
    pHVar1->anchor->content_md5 = (char *)0x0;
  }
  pHVar1->anchor->content_length = 0;
  if (pHVar1->anchor->date != (char *)0x0) {
    free(pHVar1->anchor->date);
    pHVar1->anchor->date = (char *)0x0;
  }
  if (pHVar1->anchor->expires != (char *)0x0) {
    free(pHVar1->anchor->expires);
    pHVar1->anchor->expires = (char *)0x0;
  }
  if (pHVar1->anchor->last_modified != (char *)0x0) {
    free(pHVar1->anchor->last_modified);
    pHVar1->anchor->last_modified = (char *)0x0;
  }
  if (pHVar1->anchor->ETag != (char *)0x0) {
    free(pHVar1->anchor->ETag);
    pHVar1->anchor->ETag = (char *)0x0;
  }
  if (pHVar1->anchor->server != (char *)0x0) {
    free(pHVar1->anchor->server);
    pHVar1->anchor->server = (char *)0x0;
  }
  pHVar1->target = (HTStream_conflict6 *)0x0;
  pHVar1->state = miBEGINNING_OF_LINE;
  pHVar2 = HTAtom_for("text/html");
  pHVar1->format = pHVar2;
  pHVar1->targetRep = pres->rep_out;
  pHVar1->boundary = (char *)0x0;
  pHVar1->set_cookie = (char *)0x0;
  pHVar1->set_cookie2 = (char *)0x0;
  pHVar1->refresh_url = (char *)0x0;
  pHVar1->c_t_encoding = (HTFormat)0x0;
  pHVar1->compression_encoding = (char *)0x0;
  pHVar1->net_ascii = '\0';
  HTAnchor_setUCInfoStage(pHVar1->anchor,current_char_set,2,1);
  HTAnchor_setUCInfoStage(pHVar1->anchor,current_char_set,3,1);
  return pHVar1;
}



// WARNING: Unknown calling convention

HTStream_conflict6 *
HTNetMIME(HTPresentation_conflict3 *pres,HTParentAnchor *anchor,HTStream_conflict6 *sink)

{
  HTStream_conflict6 *local_18;
  HTStream_conflict6 *me;
  
  local_18 = HTMIMEConvert(pres,anchor,sink);
  if (local_18 == (HTStream_conflict6 *)0x0) {
    local_18 = (HTStream_conflict6 *)0x0;
  }
  else {
    local_18->net_ascii = '\x01';
  }
  return local_18;
}



// WARNING: Unknown calling convention

HTStream_conflict6 *
HTMIMERedirect(HTPresentation_conflict3 *pres,HTParentAnchor *anchor,HTStream_conflict6 *sink)

{
  HTAtom *pHVar1;
  HTAtom *pHVar2;
  HTStream_conflict6 *local_1c;
  HTStream_conflict6 *me;
  
  local_1c = HTMIMEConvert(pres,anchor,sink);
  if (local_1c == (HTStream_conflict6 *)0x0) {
    local_1c = (HTStream_conflict6 *)0x0;
  }
  else {
    local_1c->pickup_redirection = '\x01';
    pHVar1 = local_1c->targetRep;
    pHVar2 = HTAtom_for("www/debug");
    if ((pHVar1 == pHVar2) && (sink != (HTStream_conflict6 *)0x0)) {
      local_1c->no_streamstack = '\x01';
    }
  }
  return local_1c;
}



// WARNING: Unknown calling convention

void HTmmdec_base64(char **t,char *s)

{
  size_t sVar1;
  char *src;
  char *pcVar2;
  char *p;
  char nw [4];
  char *bp;
  char *buf;
  int val;
  int j;
  int count;
  int d;
  
  sVar1 = strlen(s);
  src = (char *)malloc(sVar1 * 3 + 1);
  bp = src;
  if (src == (char *)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTMIME.c","HTmmdec_base64");
  }
  do {
    if (*s == '\0') {
      *bp = '\0';
      HTSACopy(t,src);
      if (src != (char *)0x0) {
        free(src);
      }
      return;
    }
    val = 0;
    if (s[2] == '=') {
      count = 1;
    }
    else if (s[3] == '=') {
      count = 2;
    }
    else {
      count = 3;
    }
    for (j = 0; j <= count; j = j + 1) {
      pcVar2 = strchr(HTmm64,(int)s[j]);
      if (pcVar2 == (char *)0x0) {
        return;
      }
      val = val + ((int)(pcVar2 + -0x81aa1c0) << (('\x03' - (char)j) * '\x06' & 0x1fU));
    }
    for (j = 2; -1 < j; j = j + -1) {
      nw[j] = (char)val;
      val = val >> 8;
    }
    if (count != 0) {
      *bp = nw[0];
      bp = bp + 1;
    }
    if (count != 1) {
      *bp = nw[1];
      bp = bp + 1;
    }
    if (count != 2) {
      *bp = nw[2];
      bp = bp + 1;
    }
    s = s + 4;
  } while( true );
}



// WARNING: Unknown calling convention

void HTmmdec_quote(char **t,char *s)

{
  size_t sVar1;
  char *src;
  char *pcVar2;
  char *pcVar3;
  char *p;
  char *bp;
  char *buf;
  char cval;
  
  sVar1 = strlen(s);
  src = (char *)malloc(sVar1 + 1);
  bp = src;
  if (src == (char *)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTMIME.c","HTmmdec_quote");
  }
  while (*s != '\0') {
    if (*s == '=') {
      if ((s[1] == '\0') || (pcVar2 = strchr(HTmmquote,(int)s[1]), pcVar2 == (char *)0x0)) {
        *bp = *s;
        s = s + 1;
        bp = bp + 1;
      }
      else if ((s[2] == '\0') || (pcVar3 = strchr(HTmmquote,(int)s[2]), pcVar3 == (char *)0x0)) {
        *bp = *s;
        s = s + 1;
        bp = bp + 1;
      }
      else {
        *bp = (char)pcVar3 + (char)((int)(char)((char)pcVar2 + -2) << 4) + -2;
        s = s + 3;
        bp = bp + 1;
      }
    }
    else if (*s == '_') {
      *bp = ' ';
      s = s + 1;
      bp = bp + 1;
    }
    else {
      *bp = *s;
      s = s + 1;
      bp = bp + 1;
    }
  }
  *bp = '\0';
  HTSACopy(t,src);
  if (src != (char *)0x0) {
    free(src);
  }
  return;
}



// WARNING: Unknown calling convention

void HTmmdecode(char **target,char *source)

{
  size_t sVar1;
  int iVar2;
  int iVar3;
  int quote;
  int base64;
  char *u;
  char *t;
  char *s;
  char *m2buf;
  char *mmbuf;
  char *buf;
  
  mmbuf = (char *)0x0;
  m2buf = (char *)0x0;
  sVar1 = strlen(source);
  buf = (char *)malloc(sVar1 + 1);
  if (buf == (char *)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTMIME.c","HTmmdecode");
  }
  s = source;
  u = buf;
  while (*s != '\0') {
    iVar2 = strncasecomp(s,"=?ISO-2022-JP?B?",0x10);
    iVar3 = strncasecomp(s,"=?ISO-2022-JP?Q?",0x10);
    if ((iVar2 == 0) || (iVar3 == 0)) {
      t = s;
      if (HTmmcont != 0) {
        while ((t = t + -1, source <= t && ((*t == ' ' || (*t == '\t'))))) {
          u = u + -1;
        }
      }
      if (mmbuf == (char *)0x0) {
        HTSACopy(&mmbuf,source);
      }
      s = s + 0x10;
      t = mmbuf;
      while ((*s != '\0' && ((*s != '?' || (s[1] != '='))))) {
        *t = *s;
        t = t + 1;
        s = s + 1;
        *t = '\0';
      }
      if ((*s != '?') || (s[1] != '=')) goto end;
      s = s + 2;
      *t = '\0';
      if (iVar2 == 0) {
        HTmmdec_base64(&m2buf,mmbuf);
      }
      if (iVar3 == 0) {
        HTmmdec_quote(&m2buf,mmbuf);
      }
      for (t = m2buf; *t != '\0'; t = t + 1) {
        *u = *t;
        u = u + 1;
      }
      HTmmcont = 1;
    }
    else {
      if ((*s != ' ') && (*s != '\t')) {
        HTmmcont = 0;
      }
      *u = *s;
      u = u + 1;
      s = s + 1;
    }
  }
  *u = '\0';
end:
  HTSACopy(target,buf);
  if (m2buf != (char *)0x0) {
    free(m2buf);
    m2buf = (char *)0x0;
  }
  if (mmbuf != (char *)0x0) {
    free(mmbuf);
    mmbuf = (char *)0x0;
  }
  if (buf != (char *)0x0) {
    free(buf);
  }
  return;
}



// WARNING: Unknown calling convention

int HTrjis(char **t,char *s)

{
  bool bVar1;
  char *pcVar2;
  size_t sVar3;
  int iVar4;
  int local_18;
  int kanji;
  char *buf;
  char *p;
  
  bVar1 = false;
  pcVar2 = strchr(s,0x1b);
  if ((pcVar2 == (char *)0x0) && (pcVar2 = strchr(s,0x24), pcVar2 != (char *)0x0)) {
    sVar3 = strlen(s);
    pcVar2 = (char *)malloc(sVar3 * 2 + 1);
    p = pcVar2;
    if (pcVar2 == (char *)0x0) {
      outofmem("../../../WWW/Library/Implementation/HTMIME.c","HTrjis");
    }
    while (*s != '\0') {
      if (((bVar1) || (*s != '$')) || ((s[1] != '@' && (s[1] != 'B')))) {
        if (((bVar1) && (*s == '(')) && ((s[1] == 'J' || (s[1] == 'B')))) {
          bVar1 = false;
          *p = '\x1b';
          p[1] = *s;
          p[2] = s[1];
          s = s + 2;
          p = p + 3;
        }
        else {
          *p = *s;
          s = s + 1;
          p = p + 1;
        }
      }
      else {
        iVar4 = HTmaybekanji((int)s[2],(int)s[3]);
        if (iVar4 == 0) {
          *p = *s;
          s = s + 1;
          p = p + 1;
        }
        else {
          bVar1 = true;
          *p = '\x1b';
          p[1] = *s;
          p[2] = s[1];
          p[3] = s[2];
          p[4] = s[3];
          s = s + 4;
          p = p + 5;
        }
      }
    }
    *p = *s;
    HTSACopy(t,pcVar2);
    if (pcVar2 != (char *)0x0) {
      free(pcVar2);
    }
    local_18 = 0;
  }
  else {
    if (*t != s) {
      HTSACopy(t,s);
    }
    local_18 = 1;
  }
  return local_18;
}



// WARNING: Unknown calling convention

int HTmaybekanji(int c1,int c2)

{
  int iVar1;
  int local_c;
  
  if ((c2 < 0x21) || (0x7e < c2)) {
    local_c = 0;
  }
  else if ((c1 < 0x21) || (((0x28 < c1 && (c1 < 0x30)) || (0x74 < c1)))) {
    local_c = 0;
  }
  else {
    iVar1 = c2 + -0x20;
    switch(c1) {
    case 0x22:
      if ((0xe < iVar1) && (iVar1 < 0x1a)) {
        return 0;
      }
      if ((0x21 < iVar1) && (iVar1 < 0x2a)) {
        return 0;
      }
      if ((0x30 < iVar1) && (iVar1 < 0x3c)) {
        return 0;
      }
      if ((0x4a < iVar1) && (iVar1 < 0x52)) {
        return 0;
      }
      if ((0x59 < iVar1) && (iVar1 < 0x5e)) {
        return 0;
      }
      break;
    case 0x23:
      if (iVar1 < 0x10) {
        return 0;
      }
      if ((0x19 < iVar1) && (iVar1 < 0x21)) {
        return 0;
      }
      if ((0x3a < iVar1) && (iVar1 < 0x41)) {
        return 0;
      }
      if (0x5a < iVar1) {
        return 0;
      }
      break;
    case 0x24:
      if (0x53 < iVar1) {
        return 0;
      }
      break;
    case 0x25:
      if (0x56 < iVar1) {
        return 0;
      }
      break;
    case 0x26:
      if ((0x18 < iVar1) && (iVar1 < 0x21)) {
        return 0;
      }
      if (0x38 < iVar1) {
        return 0;
      }
      break;
    case 0x27:
      if ((0x21 < iVar1) && (iVar1 < 0x31)) {
        return 0;
      }
      if (0x51 < iVar1) {
        return 0;
      }
      break;
    case 0x28:
      if (0x20 < iVar1) {
        return 0;
      }
      break;
    case 0x4f:
      if (0x33 < iVar1) {
        return 0;
      }
      break;
    case 0x74:
      if (6 < iVar1) {
        return 0;
      }
    }
    local_c = 1;
  }
  return local_c;
}



// WARNING: Unknown calling convention

void free_NNTP_AuthInfo(void)

{
  void **local_18;
  NNTPAuth *auth;
  HTList *cur;
  
  cur = NNTP_AuthInfo;
  if (NNTP_AuthInfo != (HTList *)0x0) {
    while( true ) {
      if ((cur == (HTList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
        local_18 = (void **)0x0;
      }
      else {
        local_18 = (void **)cur->object;
      }
      if (local_18 == (void **)0x0) break;
      if (*local_18 != (void *)0x0) {
        free(*local_18);
        *local_18 = (void *)0x0;
      }
      if (local_18[1] != (void *)0x0) {
        free(local_18[1]);
        local_18[1] = (void *)0x0;
      }
      if (local_18[2] != (void *)0x0) {
        free(local_18[2]);
        local_18[2] = (void *)0x0;
      }
      if (local_18 != (void **)0x0) {
        free(local_18);
      }
    }
    HTList_delete(NNTP_AuthInfo);
    NNTP_AuthInfo = (HTList *)0x0;
  }
  return;
}



// WARNING: Unknown calling convention

void load_NNTP_AuthInfo(void)

{
  int iVar1;
  FILE *__stream;
  int iVar2;
  char **dest;
  char *pcVar3;
  int in_GS_OFFSET;
  NNTPAuth *auth;
  FILE *fp;
  char the_user [513];
  char the_pass [513];
  char the_host [513];
  char buffer [513];
  char fname [256];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  LYAddPathToHome(fname,0x100,".newsauth");
  __stream = fopen64(fname,"r");
  if (__stream != (FILE *)0x0) {
    while (pcVar3 = fgets(buffer,0x201,__stream), pcVar3 != (char *)0x0) {
      iVar2 = sscanf(buffer,"%s%s%s",the_host,the_pass,the_user);
      if ((((iVar2 == 3) && (the_host[0] != '\0')) && (the_pass[0] != '\0')) &&
         (the_user[0] != '\0')) {
        dest = (char **)calloc(1,0xc);
        if (dest == (char **)0x0) break;
        HTSACopy(dest,the_host);
        HTSACopy(dest + 2,the_pass);
        HTSACopy(dest + 1,the_user);
        HTList_appendObject(NNTP_AuthInfo,dest);
      }
    }
    fclose(__stream);
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

char * HTGetNewsHost(void)

{
  return HTNewsHost;
}



// WARNING: Unknown calling convention

void HTSetNewsHost(char *value)

{
  HTSACopy(&HTNewsHost,value);
  return;
}



// WARNING: Unknown calling convention

BOOLEAN initialize(void)

{
  int iVar1;
  char *pcVar2;
  FILE *pFVar3;
  FILE *__stream;
  int in_GS_OFFSET;
  char *p;
  FILE *fp;
  char server_name [65];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  pcVar2 = LYGetEnv("NNTPSERVER");
  if (pcVar2 == (char *)0x0) {
    __stream = fopen64("/usr/local/lib/rn/server","r");
    if (__stream != (FILE *)0x0) {
      pcVar2 = fgets(server_name,0x41,__stream);
      if (pcVar2 != (char *)0x0) {
        pcVar2 = strchr(server_name,10);
        if (pcVar2 != (char *)0x0) {
          *pcVar2 = '\0';
        }
        HTSACopy(&HTNewsHost,server_name);
        pcVar2 = HTNewsHost;
        if (WWW_TraceFlag != '\0') {
          pFVar3 = TraceFP();
          fprintf((FILE *)pFVar3,"HTNews: File %s defines news host as `%s\'\n",
                  "/usr/local/lib/rn/server",pcVar2);
        }
      }
      fclose(__stream);
    }
  }
  else {
    pcVar2 = LYGetEnv("NNTPSERVER");
    HTSACopy(&HTNewsHost,pcVar2);
    pcVar2 = HTNewsHost;
    if (WWW_TraceFlag != '\0') {
      pFVar3 = TraceFP();
      fprintf((FILE *)pFVar3,"HTNews: NNTPSERVER defined as `%s\'\n",pcVar2);
    }
  }
  if (HTNewsHost == (char *)0x0) {
    HTSACopy(&HTNewsHost,"news");
  }
  s = -1;
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return '\x01';
}



// WARNING: Unknown calling convention

int response(char *command)

{
  char *pcVar1;
  size_t __n;
  FILE *pFVar2;
  ssize_t sVar3;
  int iVar4;
  int local_2c;
  int length;
  int status;
  int ich;
  char *p;
  int result;
  
  p = response_text;
  pcVar1 = p;
  if (command != (char *)0x0) {
    __n = strlen(command);
    if (WWW_TraceFlag != '\0') {
      pFVar2 = TraceFP();
      fprintf((FILE *)pFVar2,"NNTP command to be sent: %s",command);
    }
    sVar3 = write(s,command,__n);
    if (sVar3 < 0) {
      if (WWW_TraceFlag != '\0') {
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2,"HTNews: Unable to send command. Disconnecting.\n");
      }
      close(s);
      s = -1;
      return sVar3;
    }
  }
  while( true ) {
    p = pcVar1;
    iVar4 = HTGetCharacter();
    *p = (char)iVar4;
    if ((*p == '\n') || (p + 1 == response_text + 0x200)) break;
    pcVar1 = p + 1;
    if (iVar4 == -1) {
      *p = '\0';
      iVar4 = s;
      if (interrupted_in_htgetcharacter == 0) {
        if (WWW_TraceFlag != '\0') {
          pFVar2 = TraceFP();
          fprintf((FILE *)pFVar2,"HTNews: EOF on read, closing socket %d\n",iVar4);
        }
      }
      else if (WWW_TraceFlag != '\0') {
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2,"HTNews: Interrupted on read, closing socket %d\n",iVar4);
      }
      close(s);
      s = -1;
      if (interrupted_in_htgetcharacter == 0) {
        local_2c = -1;
      }
      else {
        interrupted_in_htgetcharacter = 0;
        local_2c = -0x752e;
      }
      return local_2c;
    }
  }
  *p = '\0';
  if (WWW_TraceFlag != '\0') {
    pFVar2 = TraceFP();
    fprintf((FILE *)pFVar2,"NNTP Response: %s\n",response_text);
  }
  sscanf(response_text,"%d",&result);
  return result;
}



// WARNING: Unknown calling convention

BOOLEAN match(char *unknown,char *ctemplate)

{
  ushort **ppuVar1;
  uint local_18;
  char *t;
  char *u;
  
  u = unknown;
  for (t = ctemplate; (*u != '\0' && (*t != '\0')); t = t + 1) {
    ppuVar1 = __ctype_b_loc();
    if (((*ppuVar1)[(byte)*u] & 0x200) == 0) {
      local_18 = (uint)(byte)*u;
    }
    else {
      local_18 = toupper((uint)(byte)*u);
    }
    if (local_18 != (int)*t) break;
    u = u + 1;
  }
  return *t == '\0';
}



NNTPAuthResult HTHandleAuthInfo(char *host)

{
  int iVar1;
  BOOLEAN BVar2;
  char *pcVar3;
  int iVar4;
  int in_GS_OFFSET;
  NNTPAuthResult local_230;
  NNTPAuth *local_22c;
  char *host_local;
  int tries;
  int status;
  char *msg;
  char *PassWord;
  char *UserName;
  NNTPAuth *auth;
  HTList *cur;
  char buffer [512];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  cur = (HTList *)0x0;
  auth = (NNTPAuth *)0x0;
  UserName = (char *)0x0;
  PassWord = (char *)0x0;
  msg = (char *)0x0;
  if (((dump_output_immediately == '\0') && (host != (char *)0x0)) && (*host != '\0')) {
    if (NNTP_AuthInfo == (HTList *)0x0) {
      NNTP_AuthInfo = HTList_new();
      load_NNTP_AuthInfo();
    }
    cur = NNTP_AuthInfo;
    do {
      if ((cur == (HTList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
        local_22c = (NNTPAuth *)0x0;
      }
      else {
        local_22c = (NNTPAuth *)cur->object;
      }
      auth = local_22c;
      if (local_22c == (NNTPAuth *)0x0) goto LAB_08133cbb;
      iVar4 = strcmp(local_22c->host,host);
    } while (iVar4 != 0);
    UserName = auth->user;
    PassWord = auth->pass;
LAB_08133cbb:
    buffer[511] = '\0';
    tries = 3;
    do {
      if (tries == 0) {
LAB_081340ee:
        if (status != 0x17d) goto LAB_081346b4;
        tries = 3;
        goto LAB_081346a7;
      }
      if (UserName == (char *)0x0) {
        pcVar3 = (char *)gettext("Username for news host \'%s\':");
        HTSprintf0(&msg,pcVar3,host);
        UserName = HTPrompt(msg,(char *)0x0);
        if (msg != (char *)0x0) {
          free(msg);
          msg = (char *)0x0;
        }
        if ((UserName == (char *)0x0) || (*UserName == '\0')) {
          if (UserName != (char *)0x0) {
            free(UserName);
            UserName = (char *)0x0;
          }
          local_230 = NNTPAUTH_ERROR;
          goto LAB_081346be;
        }
      }
      sprintf(buffer,"AUTHINFO USER %.*s%c%c",0x1ef,UserName,0xd,10);
      status = response(buffer);
      if (status < 0) {
        if (status == -0x752e) {
          mustshow = '\x01';
          pcVar3 = (char *)gettext("Connection interrupted.");
          HTProgress(pcVar3);
        }
        else {
          pcVar3 = (char *)gettext("Connection closed ???");
          HTAlert(pcVar3);
        }
        if (auth == (NNTPAuth *)0x0) {
          if (UserName != (char *)0x0) {
            free(UserName);
            UserName = (char *)0x0;
          }
        }
        else if (auth->user != UserName) {
          if (auth->user != (char *)0x0) {
            free(auth->user);
            auth->user = (char *)0x0;
          }
          auth->user = UserName;
        }
        local_230 = NNTPAUTH_CLOSE;
        goto LAB_081346be;
      }
      if (status == 0x119) {
        if (auth == (NNTPAuth *)0x0) {
          auth = (NNTPAuth *)calloc(1,0xc);
          if (auth != (NNTPAuth *)0x0) {
            HTSACopy((char **)auth,host);
            auth->user = UserName;
            HTList_appendObject(NNTP_AuthInfo,auth);
          }
        }
        else if (auth->user != UserName) {
          if (auth->user != (char *)0x0) {
            free(auth->user);
            auth->user = (char *)0x0;
          }
          auth->user = UserName;
        }
        local_230 = NNTPAUTH_OK;
        goto LAB_081346be;
      }
      if (status == 0x17d) goto LAB_081340ee;
      HTAlert(response_text);
      tries = tries + -1;
      if (tries < 1) goto LAB_08134041;
      pcVar3 = (char *)gettext("Change username?");
      BVar2 = HTConfirm(pcVar3);
      if (BVar2 == '\0') goto LAB_08134041;
      if (((auth == (NNTPAuth *)0x0) || (auth->user != UserName)) && (UserName != (char *)0x0)) {
        free(UserName);
        UserName = (char *)0x0;
      }
      pcVar3 = (char *)gettext("Username:");
      UserName = HTPrompt(pcVar3,UserName);
      if ((UserName == (char *)0x0) || (*UserName == '\0')) goto LAB_08134041;
    } while( true );
  }
  local_230 = NNTPAUTH_ERROR;
  goto LAB_081346be;
LAB_08134041:
  if (auth != (NNTPAuth *)0x0) {
    if ((auth->user != UserName) && (auth->user != (char *)0x0)) {
      free(auth->user);
      auth->user = (char *)0x0;
    }
    if (auth->pass != (char *)0x0) {
      free(auth->pass);
      auth->pass = (char *)0x0;
    }
  }
  if (UserName != (char *)0x0) {
    free(UserName);
    UserName = (char *)0x0;
  }
  local_230 = NNTPAUTH_ERROR;
  goto LAB_081346be;
  while( true ) {
    pcVar3 = (char *)gettext("Change password?");
    BVar2 = HTConfirm(pcVar3);
    if (BVar2 == '\0') break;
LAB_081346a7:
    if (tries == 0) goto LAB_081346b4;
    if (PassWord == (char *)0x0) {
      pcVar3 = (char *)gettext("Password for news host \'%s\':");
      HTSprintf0(&msg,pcVar3,host);
      PassWord = HTPromptPassword(msg);
      if (msg != (char *)0x0) {
        free(msg);
        msg = (char *)0x0;
      }
      if ((PassWord == (char *)0x0) || (*PassWord == '\0')) {
        if (PassWord != (char *)0x0) {
          free(PassWord);
          PassWord = (char *)0x0;
        }
        local_230 = NNTPAUTH_ERROR;
        goto LAB_081346be;
      }
    }
    sprintf(buffer,"AUTHINFO PASS %.*s%c%c",0x1ef,PassWord,0xd,10);
    iVar4 = response(buffer);
    if (iVar4 < 0) {
      if (iVar4 == -0x752e) {
        mustshow = '\x01';
        pcVar3 = (char *)gettext("Connection interrupted.");
        HTProgress(pcVar3);
      }
      else {
        pcVar3 = (char *)gettext("Connection closed ???");
        HTAlert(pcVar3);
      }
      if (auth == (NNTPAuth *)0x0) {
        if (UserName != (char *)0x0) {
          free(UserName);
          UserName = (char *)0x0;
        }
        if (PassWord != (char *)0x0) {
          free(PassWord);
          PassWord = (char *)0x0;
        }
      }
      else {
        if (auth->user != UserName) {
          if (auth->user != (char *)0x0) {
            free(auth->user);
            auth->user = (char *)0x0;
          }
          auth->user = UserName;
        }
        if (auth->pass != PassWord) {
          if (auth->pass != (char *)0x0) {
            free(auth->pass);
            auth->pass = (char *)0x0;
          }
          auth->pass = PassWord;
        }
      }
      local_230 = NNTPAUTH_CLOSE;
      goto LAB_081346be;
    }
    if (iVar4 == 0x1f6) {
      HTAlert(response_text);
      if (auth != (NNTPAuth *)0x0) {
        if (auth->user == UserName) {
          UserName = (char *)0x0;
        }
        if (auth->user != (char *)0x0) {
          free(auth->user);
          auth->user = (char *)0x0;
        }
        if (auth->pass == PassWord) {
          PassWord = (char *)0x0;
        }
        if (auth->pass != (char *)0x0) {
          free(auth->pass);
          auth->pass = (char *)0x0;
        }
      }
      if (UserName != (char *)0x0) {
        free(UserName);
        UserName = (char *)0x0;
      }
      if (PassWord != (char *)0x0) {
        free(PassWord);
        PassWord = (char *)0x0;
      }
      local_230 = NNTPAUTH_CLOSE;
      goto LAB_081346be;
    }
    if (iVar4 == 0x119) {
      if (auth == (NNTPAuth *)0x0) {
        auth = (NNTPAuth *)calloc(1,0xc);
        if (auth != (NNTPAuth *)0x0) {
          HTSACopy((char **)auth,host);
          auth->user = UserName;
          auth->pass = PassWord;
          HTList_appendObject(NNTP_AuthInfo,auth);
        }
      }
      else {
        if (auth->user != UserName) {
          if (auth->user != (char *)0x0) {
            free(auth->user);
            auth->user = (char *)0x0;
          }
          auth->user = UserName;
        }
        if (auth->pass != PassWord) {
          if (auth->pass != (char *)0x0) {
            free(auth->pass);
            auth->pass = (char *)0x0;
          }
          auth->pass = PassWord;
        }
      }
      local_230 = NNTPAUTH_OK;
      goto LAB_081346be;
    }
    HTAlert(response_text);
    if ((auth == (NNTPAuth *)0x0) || (auth->pass != PassWord)) {
      if (PassWord != (char *)0x0) {
        free(PassWord);
        PassWord = (char *)0x0;
      }
    }
    else {
      PassWord = (char *)0x0;
    }
    tries = tries + -1;
    if (tries < 1) break;
  }
  if (auth != (NNTPAuth *)0x0) {
    if (auth->user == UserName) {
      UserName = (char *)0x0;
    }
    if (auth->user != (char *)0x0) {
      free(auth->user);
      auth->user = (char *)0x0;
    }
    if (auth->pass != (char *)0x0) {
      free(auth->pass);
      auth->pass = (char *)0x0;
    }
  }
  if (UserName != (char *)0x0) {
    free(UserName);
    UserName = (char *)0x0;
  }
LAB_081346b4:
  local_230 = NNTPAUTH_ERROR;
LAB_081346be:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return local_230;
}



// WARNING: Unknown calling convention

char * author_name(char *email)

{
  char cVar1;
  FILE *__stream;
  char *pcVar2;
  char *pcVar3;
  char *e;
  char *p;
  
  HTSACopy(&name,email);
  pcVar2 = name;
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"Trying to find name in: %s\n",pcVar2);
  }
  pcVar2 = strrchr(name,0x28);
  if (((pcVar2 != (char *)0x0) && (pcVar3 = strrchr(name,0x29), pcVar3 != (char *)0x0)) &&
     (pcVar2 < pcVar3)) {
    *pcVar3 = '\0';
    pcVar2 = HTStrip(pcVar2 + 1);
    return pcVar2;
  }
  p = strrchr(name,0x3c);
  if (((p != (char *)0x0) && (e = strrchr(name,0x3e), e != (char *)0x0)) && (p < e)) {
    do {
      e = e + 1;
      *p = *e;
      cVar1 = *p;
      p = p + 1;
    } while (cVar1 != '\0');
    pcVar2 = HTStrip(name);
    return pcVar2;
  }
  pcVar2 = HTStrip(name);
  return pcVar2;
}



// WARNING: Unknown calling convention

char * author_address(char *email)

{
  FILE *__stream;
  char *pcVar1;
  char *pcVar2;
  char *pcVar3;
  ushort **ppuVar4;
  char *local_1c;
  char *e;
  char *at;
  char *p;
  
  HTSACopy(&address,email);
  pcVar1 = address;
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"Trying to find address in: %s\n",pcVar1);
  }
  pcVar1 = strrchr(address,0x3c);
  if ((((pcVar1 == (char *)0x0) || (pcVar2 = strrchr(pcVar1,0x3e), pcVar2 == (char *)0x0)) ||
      (pcVar3 = strrchr(pcVar1,0x40), pcVar3 == (char *)0x0)) || (pcVar2 <= pcVar3)) {
    pcVar1 = strrchr(address,0x28);
    if (((pcVar1 == (char *)0x0) || (pcVar2 = strrchr(address,0x29), pcVar2 == (char *)0x0)) ||
       ((pcVar3 = strchr(address,0x40), pcVar3 == (char *)0x0 ||
        ((pcVar2 <= pcVar1 || (pcVar2 <= pcVar3)))))) {
      p = strrchr(address,0x40);
      if ((p == (char *)0x0) || (p <= address)) {
        p = address;
        while (ppuVar4 = __ctype_b_loc(), ((*ppuVar4)[(byte)*p] & 0x2000) != 0) {
          p = p + 1;
        }
        for (e = p; (ppuVar4 = __ctype_b_loc(), ((*ppuVar4)[(byte)*e] & 0x2000) == 0 && (*e != '\0')
                    ); e = e + 1) {
        }
        *e = '\0';
        local_1c = p;
      }
      else {
        e = p + 1;
        do {
          p = p + -1;
          if (p <= address) break;
          ppuVar4 = __ctype_b_loc();
        } while (((*ppuVar4)[(byte)*p] & 0x2000) == 0);
        while ((*e != '\0' && (ppuVar4 = __ctype_b_loc(), ((*ppuVar4)[(byte)*e] & 0x2000) == 0))) {
          e = e + 1;
        }
        *e = '\0';
        local_1c = HTStrip(p);
      }
    }
    else {
      *pcVar1 = '\0';
      local_1c = HTStrip(address);
    }
  }
  else {
    *pcVar2 = '\0';
    local_1c = HTStrip(pcVar1 + 1);
  }
  return local_1c;
}



void start_anchor(char *href)

{
  int iVar1;
  int in_GS_OFFSET;
  char *href_local;
  char *value [25];
  int i;
  BOOLEAN present [25];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  for (i = 0; i < 0x19; i = i + 1) {
    present[i] = i == 6;
  }
  value[6] = href;
  (*targetClass.start_element)(target,0,present,value,-1,(char **)0x0);
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void start_link(char *href,char *rev)

{
  int iVar1;
  int in_GS_OFFSET;
  BOOLEAN local_60;
  char *rev_local;
  char *href_local;
  char *value [14];
  int i;
  BOOLEAN present [14];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  for (i = 0; i < 0xe; i = i + 1) {
    if ((i == 3) || (i == 9)) {
      local_60 = '\x01';
    }
    else {
      local_60 = '\0';
    }
    present[i] = local_60;
  }
  value[3] = href;
  value[9] = rev;
  (*targetClass.start_element)(target,0x45,present,value,-1,(char **)0x0);
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



// WARNING: Unknown calling convention

void start_list(int seqnum)

{
  int iVar1;
  int in_GS_OFFSET;
  BOOLEAN local_68;
  char *value [12];
  int i;
  char SeqNum [20];
  BOOLEAN present [12];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  for (i = 0; i < 0xc; i = i + 1) {
    if ((i == 7) || (i == 8)) {
      local_68 = '\x01';
    }
    else {
      local_68 = '\0';
    }
    present[i] = local_68;
  }
  sprintf(SeqNum,"%d",seqnum);
  value[7] = SeqNum;
  value[8] = SeqNum;
  (*targetClass.start_element)(target,0x50,present,value,-1,(char **)0x0);
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void write_anchor(char *text,char *addr)

{
  int iVar1;
  size_t sVar2;
  int in_GS_OFFSET;
  char *addr_local;
  char *text_local;
  char *q;
  char *p;
  char href [513];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  for (p = addr; (((*p != '\0' && (*p != '>')) && (0x20 < (byte)*p)) && (*p != ',')); p = p + 1) {
  }
  sVar2 = strlen(NewsHREF);
  if (p + (sVar2 - (int)addr) + 1 < (char *)0x201) {
    q = href;
    strcpy(q,NewsHREF);
    strncat(q,addr,(int)p - (int)addr);
  }
  else {
    q = (char *)0x0;
    HTSprintf0(&q,"%s%.*s",NewsHREF,(int)p - (int)addr,addr);
  }
  start_anchor(q);
  (*targetClass.put_string)(target,text);
  (*targetClass.end_element)(target,0,(char **)0x0);
  if ((q != href) && (q != (char *)0x0)) {
    free(q);
    q = (char *)0x0;
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



// WARNING: Unknown calling convention

void write_anchors(char *text)

{
  char cVar1;
  char *end;
  char *start;
  char c;
  
  start = text;
  while( true ) {
    for (; (*start != '\0' && ((byte)*start < 0x21)); start = start + 1) {
    }
    if (*start == '\0') break;
    for (end = start; ((*end != '\0' && (*end != ' ')) && (*end != ',')); end = end + 1) {
    }
    if (*end != '\0') {
      end = end + 1;
    }
    cVar1 = *end;
    *end = '\0';
    if (*start == '<') {
      write_anchor(start,start + 1);
    }
    else {
      write_anchor(start,start);
    }
    (*targetClass.start_element)(target,0x14,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
    *end = cVar1;
    start = end;
  }
  return;
}



// WARNING: Unknown calling convention

void abort_socket(void)

{
  int iVar1;
  FILE *__stream;
  
  iVar1 = s;
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"HTNews: EOF on read, closing socket %d\n",iVar1);
  }
  close(s);
  if (rawtext == '\0') {
    (*targetClass.put_string)(target,"Network Error: connection lost");
    (*targetClass.put_character)(target,'\n');
  }
  else {
    (*rawtargetClass.put_string)(rawtarget,"Network Error: connection lost\n");
  }
  s = -1;
  return;
}



// WARNING: Unknown calling convention

BOOLEAN valid_header(char *line)

{
  char *pcVar1;
  char *pcVar2;
  ushort **ppuVar3;
  BOOLEAN local_15;
  char *space;
  char *colon;
  
  if ((*line == ' ') || (*line == '\t')) {
    local_15 = '\x01';
  }
  else {
    pcVar1 = strchr(line,0x3a);
    pcVar2 = strchr(line,0x20);
    ppuVar3 = __ctype_b_loc();
    if ((((*ppuVar3)[(byte)*line] & 0x400) == 0) ||
       ((pcVar1 == (char *)0x0 || (pcVar1 + 1 != pcVar2)))) {
      local_15 = '\0';
    }
    else {
      local_15 = '\x01';
    }
  }
  return local_15;
}



void post_article(char *postfile)

{
  int iVar1;
  bool bVar2;
  bool bVar3;
  bool bVar4;
  BOOLEAN BVar5;
  FILE *__stream;
  char *pcVar6;
  size_t sVar7;
  int iVar8;
  int in_GS_OFFSET;
  undefined *__src;
  size_t sVar9;
  size_t __n;
  char *local_440;
  char *postfile_local;
  int llen;
  int blen;
  int seen_fromline;
  int seen_header;
  int in_header;
  FILE *fd;
  int status;
  char *cp;
  char crlf [3];
  char buf [512];
  char line [512];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  bVar2 = true;
  bVar3 = false;
  bVar4 = false;
  blen = 0;
  if (postfile == (char *)0x0) {
    local_440 = "";
  }
  else {
    local_440 = postfile;
  }
  __stream = fopen64(local_440,"r");
  if (__stream == (FILE *)0x0) {
    pcVar6 = (char *)gettext("Cannot open temporary file for news POST.");
    HTAlert(pcVar6);
  }
  else {
    buf[0] = '\0';
    sprintf(crlf,"%c%c",0xd,10);
    while( true ) {
      pcVar6 = fgets(line,0x1fe,__stream);
      if (pcVar6 == (char *)0x0) break;
      pcVar6 = strchr(line,10);
      if (pcVar6 != (char *)0x0) {
        *pcVar6 = '\0';
      }
      if (line[0] == '.') {
        sVar9 = 2;
        __src = &DAT_0818ec97;
        sVar7 = strlen(buf);
        memcpy(buf + sVar7,__src,sVar9);
        blen = blen + 1;
      }
      sVar7 = strlen(line);
      if (bVar2) {
        iVar8 = strncasecomp(line,"From:",5);
        if (iVar8 == 0) {
          bVar3 = true;
          bVar4 = true;
        }
      }
      if ((bVar2) && (line[0] == '\0')) {
        if (bVar3) {
          bVar2 = false;
          if (!bVar4) {
            if (0x1dc < blen) {
              write(s,buf,blen);
              blen = 0;
              buf[0] = '\0';
            }
            __n = 0x21;
            pcVar6 = "From: anonymous@nowhere.you.know";
            sVar9 = strlen(buf);
            memcpy(buf + sVar9,pcVar6,__n);
            strcat(buf,crlf);
            blen = blen + 0x22;
          }
          goto LAB_08135348;
        }
      }
      else {
        if (!bVar2) goto LAB_08135348;
        BVar5 = valid_header(line);
        if (BVar5 != '\0') {
          bVar3 = true;
LAB_08135348:
          strcat(line,crlf);
          if (0x1fe < (int)(blen + sVar7 + 2)) {
            write(s,buf,blen);
            blen = 0;
            buf[0] = '\0';
          }
          strcat(buf,line);
          blen = blen + sVar7 + 2;
        }
      }
    }
    fclose(__stream);
    remove(postfile);
    if (0x1fb < blen) {
      write(s,buf,blen);
      blen = 0;
      buf[0] = '\0';
    }
    strcat(buf,".");
    strcat(buf,crlf);
    write(s,buf,blen + 3);
    iVar8 = response((char *)0x0);
    if (iVar8 == 0xf0) {
      HTProgress(response_text);
    }
    else {
      HTAlert(response_text);
    }
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



// WARNING: Unknown calling convention

char * decode_mime(char **str)

{
  int iVar1;
  char *local_8;
  
  HTmmdecode(str,*str);
  iVar1 = HTrjis(str,*str);
  if (iVar1 == 0) {
    local_8 = decode_mime::empty;
  }
  else {
    local_8 = *str;
  }
  return local_8;
}



int read_article(HTParentAnchor *thisanchor)

{
  char cVar1;
  _func_void_HTStructured_ptr_char_ptr_conflict *p_Var2;
  BOOLEAN BVar3;
  size_t sVar4;
  char *pcVar5;
  int iVar6;
  int iVar7;
  FILE *pFVar8;
  char *pcVar9;
  char *pcVar10;
  char *pcVar11;
  int in_GS_OFFSET;
  int local_28c;
  char *local_288;
  char *local_284;
  char *local_280;
  HTParentAnchor *thisanchor_local;
  char *at;
  char *q;
  char *p2;
  char *l;
  int ich_1;
  char *cp1;
  char *temp;
  char *msgid;
  int i;
  int ich;
  char *ccp;
  char *cp;
  char *p;
  char *href;
  char *followupto;
  char *newsgroups;
  char *references;
  char *organization;
  char *date;
  char *replyto;
  char *from;
  char *subject;
  char *full_line;
  char c;
  BOOLEAN done;
  char line [513];
  int local_c;
  
  local_c = *(int *)(in_GS_OFFSET + 0x14);
  full_line = (char *)0x0;
  subject = (char *)0x0;
  from = (char *)0x0;
  replyto = (char *)0x0;
  date = (char *)0x0;
  organization = (char *)0x0;
  references = (char *)0x0;
  newsgroups = (char *)0x0;
  followupto = (char *)0x0;
  href = (char *)0x0;
  p = line;
  done = '\0';
  if ((diagnostic == 0) && (pcVar5 = p, rawtext == '\0')) {
    while (p = pcVar5, done == '\0') {
      ich = HTGetCharacter();
      iVar6 = s;
      *p = (char)ich;
      pcVar5 = p + 1;
      if (ich == -1) {
        p = pcVar5;
        if (interrupted_in_htgetcharacter == 0) {
          abort_socket();
          local_28c = 200;
        }
        else {
          interrupted_in_htgetcharacter = 0;
          if (WWW_TraceFlag != '\0') {
            pFVar8 = TraceFP();
            fprintf((FILE *)pFVar8,"HTNews: Interrupted on read, closing socket %d\n",iVar6);
          }
          close(s);
          s = -1;
          local_28c = -0x752e;
        }
        goto LAB_08137be0;
      }
      if (((char)ich == '\n') || (pcVar5 == line + 0x200)) {
        *p = '\0';
        if (WWW_TraceFlag != '\0') {
          pFVar8 = TraceFP();
          fprintf((FILE *)pFVar8,"H %s\n",line);
        }
        if ((line[0] == '\t') || (line[0] == ' ')) {
          for (i = 0; line[i] != '\0'; i = i + 1) {
            if (line[i] == '\t') {
              line[i] = ' ';
            }
          }
          if (full_line == (char *)0x0) {
            HTSACopy(&full_line,line);
          }
          else {
            HTSACat(&full_line,line);
          }
        }
        else {
          HTSACopy(&full_line,line);
        }
        if (*full_line == '.') {
          if ((byte)full_line[1] < 0x20) {
            done = '\x01';
            break;
          }
        }
        else {
          if ((byte)*full_line < 0x20) break;
          BVar3 = match(full_line,"SUBJECT:");
          if (BVar3 == '\0') {
            BVar3 = match(full_line,"DATE:");
            if (BVar3 == '\0') {
              BVar3 = match(full_line,"ORGANIZATION:");
              if (BVar3 == '\0') {
                BVar3 = match(full_line,"FROM:");
                if (BVar3 == '\0') {
                  BVar3 = match(full_line,"REPLY-TO:");
                  if (BVar3 == '\0') {
                    BVar3 = match(full_line,"NEWSGROUPS:");
                    if (BVar3 == '\0') {
                      BVar3 = match(full_line,"REFERENCES:");
                      if (BVar3 == '\0') {
                        BVar3 = match(full_line,"FOLLOWUP-TO:");
                        if (BVar3 == '\0') {
                          BVar3 = match(full_line,"MESSAGE-ID:");
                          if (((BVar3 != '\0') && (msgid = HTStrip(full_line + 0xb), *msgid == '<'))
                             && (sVar4 = strlen(msgid), msgid[sVar4 - 1] == '>')) {
                            sVar4 = strlen(msgid);
                            msgid[sVar4 - 1] = '\0';
                            msgid = msgid + 1;
                            HTAnchor_setMessageID(thisanchor,msgid);
                          }
                        }
                        else {
                          pcVar5 = strchr(full_line,0x3a);
                          pcVar5 = HTStrip(pcVar5 + 1);
                          HTSACopy(&followupto,pcVar5);
                        }
                      }
                      else {
                        pcVar5 = strchr(full_line,0x3a);
                        pcVar5 = HTStrip(pcVar5 + 1);
                        HTSACopy(&references,pcVar5);
                      }
                    }
                    else {
                      pcVar5 = strchr(full_line,0x3a);
                      pcVar5 = HTStrip(pcVar5 + 1);
                      HTSACopy(&newsgroups,pcVar5);
                    }
                  }
                  else {
                    pcVar5 = strchr(full_line,0x3a);
                    pcVar5 = HTStrip(pcVar5 + 1);
                    HTSACopy(&replyto,pcVar5);
                    decode_mime(&replyto);
                  }
                }
                else {
                  pcVar5 = strchr(full_line,0x3a);
                  pcVar5 = HTStrip(pcVar5 + 1);
                  HTSACopy(&from,pcVar5);
                  decode_mime(&from);
                }
              }
              else {
                pcVar5 = strchr(full_line,0x3a);
                pcVar5 = HTStrip(pcVar5 + 1);
                HTSACopy(&organization,pcVar5);
                decode_mime(&organization);
              }
            }
            else {
              pcVar5 = strchr(full_line,0x3a);
              pcVar5 = HTStrip(pcVar5 + 1);
              HTSACopy(&date,pcVar5);
            }
          }
          else {
            pcVar5 = strchr(full_line,0x3a);
            pcVar5 = HTStrip(pcVar5 + 1);
            HTSACopy(&subject,pcVar5);
            decode_mime(&subject);
          }
        }
        pcVar5 = line;
      }
    }
    if (full_line != (char *)0x0) {
      free(full_line);
      full_line = (char *)0x0;
    }
    (*targetClass.start_element)(target,0x35,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
    (*targetClass.put_character)(target,'\n');
    (*targetClass.start_element)(target,0x6e,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
    if ((subject == (char *)0x0) || (*subject == '\0')) {
      (*targetClass.put_string)(target,"No Subject");
    }
    else {
      (*targetClass.put_string)(target,subject);
    }
    (*targetClass.end_element)(target,0x6e,(char **)0x0);
    (*targetClass.put_character)(target,'\n');
    if ((from != (char *)0x0) || (replyto != (char *)0x0)) {
      temp = (char *)0x0;
      if (replyto == (char *)0x0) {
        local_288 = from;
      }
      else {
        local_288 = replyto;
      }
      pcVar5 = author_address(local_288);
      HTSACopy(&temp,pcVar5);
      HTSACopy(&href,"mailto:");
      pcVar5 = strchr(temp,0x25);
      if ((pcVar5 == (char *)0x0) && (pcVar5 = strchr(temp,0x3f), pcVar5 == (char *)0x0)) {
        HTSACat(&href,temp);
      }
      else {
        cp = HTEscape(temp,'\x02');
        HTSACat(&href,cp);
        if (cp != (char *)0x0) {
          free(cp);
          cp = (char *)0x0;
        }
      }
      start_link(href,"made");
      (*targetClass.put_character)(target,'\n');
      if (temp != (char *)0x0) {
        free(temp);
        temp = (char *)0x0;
      }
    }
    (*targetClass.end_element)(target,0x35,(char **)0x0);
    (*targetClass.put_character)(target,'\n');
    (*targetClass.start_element)(target,0x2f,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
    if ((subject == (char *)0x0) || (*subject == '\0')) {
      (*targetClass.put_string)(target,"No Subject");
    }
    else {
      (*targetClass.put_string)(target,subject);
    }
    (*targetClass.end_element)(target,0x2f,(char **)0x0);
    (*targetClass.put_character)(target,'\n');
    if ((subject != (char *)0x0) && (subject != (char *)0x0)) {
      free(subject);
      subject = (char *)0x0;
    }
    (*targetClass.start_element)(target,0x24,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
    (*targetClass.put_character)(target,'\n');
    if ((from != (char *)0x0) || (replyto != (char *)0x0)) {
      (*targetClass.start_element)(target,0x25,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
      (*targetClass.start_element)(target,8,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
      (*targetClass.put_string)(target,"From:");
      (*targetClass.end_element)(target,8,(char **)0x0);
      (*targetClass.put_character)(target,' ');
      if (from == (char *)0x0) {
        (*targetClass.put_string)(target,replyto);
      }
      else {
        (*targetClass.put_string)(target,from);
      }
      if (tags[37].contents != SGML_EMPTY) {
        (*targetClass.end_element)(target,0x25,(char **)0x0);
      }
      (*targetClass.put_character)(target,'\n');
      if (replyto == (char *)0x0) {
        HTSACopy(&replyto,from);
      }
      (*targetClass.start_element)(target,0x25,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
      (*targetClass.start_element)(target,8,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
      (*targetClass.put_string)(target,"Reply to:");
      (*targetClass.end_element)(target,8,(char **)0x0);
      (*targetClass.put_character)(target,' ');
      start_anchor(href);
      p_Var2 = targetClass.put_string;
      if (*replyto == '<') {
        pcVar5 = author_address(replyto);
        (*p_Var2)(target,pcVar5);
      }
      else {
        pcVar5 = author_name(replyto);
        (*p_Var2)(target,pcVar5);
      }
      (*targetClass.end_element)(target,0,(char **)0x0);
      (*targetClass.start_element)(target,0x14,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
      if (tags[37].contents != SGML_EMPTY) {
        (*targetClass.end_element)(target,0x25,(char **)0x0);
      }
      (*targetClass.put_character)(target,'\n');
      if (from != (char *)0x0) {
        free(from);
        from = (char *)0x0;
      }
      if (replyto != (char *)0x0) {
        free(replyto);
        replyto = (char *)0x0;
      }
    }
    if (date != (char *)0x0) {
      (*targetClass.start_element)(target,0x25,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
      (*targetClass.start_element)(target,8,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
      (*targetClass.put_string)(target,"Date:");
      (*targetClass.end_element)(target,8,(char **)0x0);
      (*targetClass.put_character)(target,' ');
      (*targetClass.put_string)(target,date);
      if (tags[37].contents != SGML_EMPTY) {
        (*targetClass.end_element)(target,0x25,(char **)0x0);
      }
      (*targetClass.put_character)(target,'\n');
      if (date != (char *)0x0) {
        free(date);
        date = (char *)0x0;
      }
    }
    if (organization != (char *)0x0) {
      (*targetClass.start_element)(target,0x25,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
      (*targetClass.start_element)(target,8,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
      (*targetClass.put_string)(target,"Organization:");
      (*targetClass.end_element)(target,8,(char **)0x0);
      (*targetClass.put_character)(target,' ');
      (*targetClass.put_string)(target,organization);
      if (tags[37].contents != SGML_EMPTY) {
        (*targetClass.end_element)(target,0x25,(char **)0x0);
      }
      (*targetClass.put_character)(target,'\n');
      if (organization != (char *)0x0) {
        free(organization);
        organization = (char *)0x0;
      }
    }
    if ((newsgroups != (char *)0x0) &&
       ((cp = strchr(newsgroups,0x2f), cp != (char *)0x0 ||
        (cp = strchr(newsgroups,0x28), cp != (char *)0x0)))) {
      *cp = '\0';
    }
    if (((newsgroups != (char *)0x0) && (*newsgroups == '\0')) && (newsgroups != (char *)0x0)) {
      free(newsgroups);
      newsgroups = (char *)0x0;
    }
    if ((followupto != (char *)0x0) &&
       ((cp = strchr(followupto,0x2f), cp != (char *)0x0 ||
        (cp = strchr(followupto,0x28), cp != (char *)0x0)))) {
      *cp = '\0';
    }
    if (((followupto != (char *)0x0) && (*followupto == '\0')) && (followupto != (char *)0x0)) {
      free(followupto);
      followupto = (char *)0x0;
    }
    if ((newsgroups != (char *)0x0) && (HTCanPost != 0)) {
      (*targetClass.start_element)(target,0x25,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
      (*targetClass.start_element)(target,8,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
      (*targetClass.put_string)(target,"Newsgroups:");
      (*targetClass.end_element)(target,8,(char **)0x0);
      (*targetClass.put_character)(target,'\n');
      if (tags[37].contents != SGML_EMPTY) {
        (*targetClass.end_element)(target,0x25,(char **)0x0);
      }
      (*targetClass.start_element)(target,0x1e,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
      write_anchors(newsgroups);
      if (tags[30].contents != SGML_EMPTY) {
        (*targetClass.end_element)(target,0x1e,(char **)0x0);
      }
      (*targetClass.put_character)(target,'\n');
    }
    if ((followupto != (char *)0x0) && (iVar6 = strcasecomp(followupto,"poster"), iVar6 == 0)) {
      (*targetClass.start_element)(target,0x25,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
      (*targetClass.start_element)(target,8,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
      (*targetClass.put_string)(target,"Followup to:");
      (*targetClass.end_element)(target,8,(char **)0x0);
      (*targetClass.put_character)(target,' ');
      if (href == (char *)0x0) {
        (*targetClass.put_string)(target,"poster");
      }
      else {
        start_anchor(href);
        (*targetClass.put_string)(target,"poster");
        (*targetClass.end_element)(target,0,(char **)0x0);
      }
      if (tags[37].contents != SGML_EMPTY) {
        (*targetClass.end_element)(target,0x25,(char **)0x0);
      }
      (*targetClass.put_character)(target,'\n');
      if (followupto != (char *)0x0) {
        free(followupto);
        followupto = (char *)0x0;
      }
    }
    if ((newsgroups != (char *)0x0) && (HTCanPost != 0)) {
      iVar6 = strncasecomp(NewsHREF,"snews:",6);
      if (iVar6 == 0) {
        HTSACopy(&href,"snewsreply://");
      }
      else {
        HTSACopy(&href,"newsreply://");
      }
      HTSACat(&href,NewsHost);
      HTSACat(&href,"/");
      if (followupto == (char *)0x0) {
        local_284 = newsgroups;
      }
      else {
        local_284 = followupto;
      }
      HTSACat(&href,local_284);
      if (((*href == 'n') && (ccp = HTAnchor_messageID(thisanchor), ccp != (char *)0x0)) &&
         (*ccp != '\0')) {
        HTSACat(&href,";ref=");
        pcVar5 = strchr(ccp,0x3c);
        if (((((pcVar5 == (char *)0x0) && (pcVar5 = strchr(ccp,0x26), pcVar5 == (char *)0x0)) &&
             ((pcVar5 = strchr(ccp,0x20), pcVar5 == (char *)0x0 &&
              ((pcVar5 = strchr(ccp,0x3a), pcVar5 == (char *)0x0 &&
               (pcVar5 = strchr(ccp,0x2f), pcVar5 == (char *)0x0)))))) &&
            (pcVar5 = strchr(ccp,0x25), pcVar5 == (char *)0x0)) &&
           (pcVar5 = strchr(ccp,0x3b), pcVar5 == (char *)0x0)) {
          HTSACat(&href,ccp);
        }
        else {
          pcVar5 = HTEscape(ccp,'\x02');
          HTSACat(&href,pcVar5);
          if (pcVar5 != (char *)0x0) {
            free(pcVar5);
          }
        }
      }
      (*targetClass.start_element)(target,0x25,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
      (*targetClass.start_element)(target,8,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
      (*targetClass.put_string)(target,"Followup to:");
      (*targetClass.end_element)(target,8,(char **)0x0);
      (*targetClass.put_character)(target,' ');
      start_anchor(href);
      if (followupto == (char *)0x0) {
        local_280 = newsgroups;
      }
      else {
        local_280 = followupto;
      }
      pcVar5 = strchr(local_280,0x2c);
      if (pcVar5 == (char *)0x0) {
        (*targetClass.put_string)(target,"newsgroup");
      }
      else {
        (*targetClass.put_string)(target,"newsgroups");
      }
      (*targetClass.end_element)(target,0,(char **)0x0);
      if (tags[37].contents != SGML_EMPTY) {
        (*targetClass.end_element)(target,0x25,(char **)0x0);
      }
      (*targetClass.put_character)(target,'\n');
    }
    if (newsgroups != (char *)0x0) {
      free(newsgroups);
      newsgroups = (char *)0x0;
    }
    if (followupto != (char *)0x0) {
      free(followupto);
      followupto = (char *)0x0;
    }
    if (references != (char *)0x0) {
      (*targetClass.start_element)(target,0x25,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
      (*targetClass.start_element)(target,8,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
      (*targetClass.put_string)(target,"References:");
      (*targetClass.end_element)(target,8,(char **)0x0);
      if (tags[37].contents != SGML_EMPTY) {
        (*targetClass.end_element)(target,0x25,(char **)0x0);
      }
      (*targetClass.put_character)(target,'\n');
      (*targetClass.start_element)(target,0x1e,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
      write_anchors(references);
      if (tags[30].contents != SGML_EMPTY) {
        (*targetClass.end_element)(target,0x1e,(char **)0x0);
      }
      (*targetClass.put_character)(target,'\n');
      if (references != (char *)0x0) {
        free(references);
        references = (char *)0x0;
      }
    }
    (*targetClass.end_element)(target,0x24,(char **)0x0);
    (*targetClass.put_character)(target,'\n');
    if (href != (char *)0x0) {
      free(href);
      href = (char *)0x0;
    }
  }
  if (rawtext == '\0') {
    if (diagnostic == 0) {
      (*targetClass.start_element)(target,0x56,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
      (*targetClass.put_character)(target,'\n');
    }
    else {
      (*targetClass.start_element)(target,0x75,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
      (*targetClass.put_character)(target,'\n');
    }
  }
  pcVar5 = line;
  do {
    do {
      p = pcVar5;
      if (done != '\0') {
LAB_08137b5c:
        if (rawtext == '\0') {
          if (diagnostic == 0) {
            (*targetClass.end_element)(target,0x56,(char **)0x0);
          }
          else {
            (*targetClass.end_element)(target,0x75,(char **)0x0);
          }
          (*targetClass.put_character)(target,'\n');
          local_28c = 200;
        }
        else {
          local_28c = 200;
        }
LAB_08137be0:
        if (local_c == *(int *)(in_GS_OFFSET + 0x14)) {
          return local_28c;
        }
                    // WARNING: Subroutine does not return
        __stack_chk_fail();
      }
      iVar7 = HTGetCharacter();
      iVar6 = s;
      *p = (char)iVar7;
      pcVar5 = p + 1;
      if (iVar7 == -1) {
        p = pcVar5;
        if (interrupted_in_htgetcharacter == 0) {
          abort_socket();
          local_28c = 200;
        }
        else {
          interrupted_in_htgetcharacter = 0;
          if (WWW_TraceFlag != '\0') {
            pFVar8 = TraceFP();
            fprintf((FILE *)pFVar8,"HTNews: Interrupted on read, closing socket %d\n",iVar6);
          }
          close(s);
          s = -1;
          local_28c = -0x752e;
        }
        goto LAB_08137be0;
      }
    } while (((char)iVar7 != '\n') && (pcVar5 != line + 0x200));
    *pcVar5 = '\0';
    p = p + 2;
    if (WWW_TraceFlag != '\0') {
      pFVar8 = TraceFP();
      fprintf((FILE *)pFVar8,"B %s",line);
    }
    if (line[0] == '.') {
      if ((byte)line[1] < 0x20) {
        done = '\x01';
        goto LAB_08137b5c;
      }
      if (rawtext == '\0') {
        (*targetClass.put_string)(target,line + 1);
      }
      else {
        (*rawtargetClass.put_string)(rawtarget,line + 1);
      }
    }
    else if (rawtext == '\0') {
      if ((diagnostic == 0) && (scan_for_buried_news_references != '\0')) {
        l = line;
        while (pcVar5 = strstr(l,"rticle <"), pcVar5 != (char *)0x0) {
          pcVar9 = strrchr(pcVar5,0x3e);
          pcVar10 = strrchr(pcVar5,0x40);
          if (((pcVar9 == (char *)0x0) || (pcVar10 == (char *)0x0)) || (pcVar9 <= pcVar10)) break;
          c = pcVar9[1];
          pcVar9[1] = '\0';
          pcVar10 = pcVar5 + 7;
          *pcVar10 = '\0';
          while (*l != '\0') {
            iVar6 = strncmp(l,"news:",5);
            if ((((((iVar6 == 0) || (iVar6 = strncmp(l,"snews://",8), iVar6 == 0)) ||
                  (iVar6 = strncmp(l,"nntp://",7), iVar6 == 0)) ||
                 (((iVar6 = strncmp(l,"snewspost:",10), iVar6 == 0 ||
                   (iVar6 = strncmp(l,"snewsreply:",0xb), iVar6 == 0)) ||
                  ((iVar6 = strncmp(l,"newspost:",9), iVar6 == 0 ||
                   ((iVar6 = strncmp(l,"newsreply:",10), iVar6 == 0 ||
                    (iVar6 = strncmp(l,"ftp://",6), iVar6 == 0)))))))) ||
                ((iVar6 = strncmp(l,"file:/",6), iVar6 == 0 ||
                 (((iVar6 = strncmp(l,"finger://",9), iVar6 == 0 ||
                   (iVar6 = strncmp(l,"http://",7), iVar6 == 0)) ||
                  (iVar6 = strncmp(l,"https://",8), iVar6 == 0)))))) ||
               (((iVar6 = strncmp(l,"wais://",7), iVar6 == 0 ||
                 (iVar6 = strncmp(l,"mailto:",7), iVar6 == 0)) ||
                ((iVar6 = strncmp(l,"cso://",6), iVar6 == 0 ||
                 (iVar6 = strncmp(l,"gopher://",9), iVar6 == 0)))))) {
              HTSACopy(&href,l);
              pcVar11 = strtok(href," \r\n\t,>)\"");
              start_anchor(pcVar11);
              while ((*l != '\0' &&
                     (pcVar11 = strchr(" \r\n\t,>)\"",(int)*l), pcVar11 == (char *)0x0))) {
                cVar1 = *l;
                l = l + 1;
                (*targetClass.put_character)(target,cVar1);
              }
              (*targetClass.end_element)(target,0,(char **)0x0);
              if (href != (char *)0x0) {
                free(href);
                href = (char *)0x0;
              }
            }
            else {
              cVar1 = *l;
              l = l + 1;
              (*targetClass.put_character)(target,cVar1);
            }
          }
          *pcVar10 = '<';
          *pcVar9 = '\0';
          start_anchor(pcVar5 + 8);
          *pcVar9 = '>';
          (*targetClass.put_string)(target,pcVar10);
          (*targetClass.end_element)(target,0,(char **)0x0);
          pcVar9[1] = c;
          l = pcVar9 + 1;
        }
        while (*l != '\0') {
          iVar6 = strncmp(l,"news:",5);
          if ((((iVar6 == 0) || (iVar6 = strncmp(l,"snews://",8), iVar6 == 0)) ||
              ((iVar6 = strncmp(l,"nntp://",7), iVar6 == 0 ||
               ((iVar6 = strncmp(l,"snewspost:",10), iVar6 == 0 ||
                (iVar6 = strncmp(l,"snewsreply:",0xb), iVar6 == 0)))))) ||
             ((iVar6 = strncmp(l,"newspost:",9), iVar6 == 0 ||
              (((((((iVar6 = strncmp(l,"newsreply:",10), iVar6 == 0 ||
                    (iVar6 = strncmp(l,"ftp://",6), iVar6 == 0)) ||
                   (iVar6 = strncmp(l,"file:/",6), iVar6 == 0)) ||
                  ((iVar6 = strncmp(l,"finger://",9), iVar6 == 0 ||
                   (iVar6 = strncmp(l,"http://",7), iVar6 == 0)))) ||
                 (iVar6 = strncmp(l,"https://",8), iVar6 == 0)) ||
                ((iVar6 = strncmp(l,"wais://",7), iVar6 == 0 ||
                 (iVar6 = strncmp(l,"mailto:",7), iVar6 == 0)))) ||
               ((iVar6 = strncmp(l,"cso://",6), iVar6 == 0 ||
                (iVar6 = strncmp(l,"gopher://",9), iVar6 == 0)))))))) {
            HTSACopy(&href,l);
            pcVar5 = strtok(href," \r\n\t,>)\"");
            start_anchor(pcVar5);
            while ((*l != '\0' && (pcVar5 = strchr(" \r\n\t,>)\"",(int)*l), pcVar5 == (char *)0x0)))
            {
              cVar1 = *l;
              l = l + 1;
              (*targetClass.put_character)(target,cVar1);
            }
            (*targetClass.end_element)(target,0,(char **)0x0);
            if (href != (char *)0x0) {
              free(href);
              href = (char *)0x0;
            }
          }
          else {
            cVar1 = *l;
            l = l + 1;
            (*targetClass.put_character)(target,cVar1);
          }
        }
      }
      else {
        (*targetClass.put_string)(target,line);
      }
    }
    else {
      (*rawtargetClass.put_string)(rawtarget,line);
    }
    pcVar5 = line;
  } while( true );
}



int read_list(char *arg)

{
  size_t sVar1;
  FILE *pFVar2;
  int iVar3;
  char *pcVar4;
  int in_GS_OFFSET;
  int local_240;
  char *arg_local;
  char *msg;
  int i;
  int ich;
  int len;
  char *pattern;
  int listing;
  char *p;
  char ch;
  BOOLEAN skip_rest_of_line;
  BOOLEAN skip_this_line;
  BOOLEAN tail;
  BOOLEAN head;
  BOOLEAN done;
  char line [513];
  int local_c;
  
  local_c = *(int *)(in_GS_OFFSET + 0x14);
  done = '\0';
  head = '\0';
  tail = '\0';
  skip_this_line = '\0';
  skip_rest_of_line = '\0';
  listing = 0;
  pattern = (char *)0x0;
  len = 0;
  if ((arg != (char *)0x0) && (sVar1 = strlen(arg), 1 < sVar1)) {
    if (*arg == '*') {
      tail = '\x01';
      HTSACopy(&pattern,arg + 1);
    }
    else {
      sVar1 = strlen(arg);
      if (arg[sVar1 - 1] == '*') {
        head = '\x01';
        HTSACopy(&pattern,arg);
        pcVar4 = pattern;
        sVar1 = strlen(pattern);
        pcVar4[sVar1 - 1] = '\0';
      }
    }
    if ((tail != '\0') || (head != '\0')) {
      len = strlen(pattern);
    }
  }
  (*targetClass.start_element)(target,0x35,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
  (*targetClass.put_character)(target,'\n');
  (*targetClass.start_element)(target,0x6e,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
  (*targetClass.put_string)(target,"Newsgroups");
  (*targetClass.end_element)(target,0x6e,(char **)0x0);
  (*targetClass.put_character)(target,'\n');
  (*targetClass.end_element)(target,0x35,(char **)0x0);
  (*targetClass.put_character)(target,'\n');
  (*targetClass.start_element)(target,0x2f,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
  (*targetClass.put_string)(target,"Newsgroups");
  (*targetClass.end_element)(target,0x2f,(char **)0x0);
  (*targetClass.put_character)(target,'\n');
  p = line;
  (*targetClass.start_element)(target,0x24,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
  (*targetClass.put_character)(target,'\n');
LAB_0813859b:
  do {
    if (done != '\0') {
LAB_081385a8:
      if (listing == 0) {
        msg = (char *)0x0;
        (*targetClass.start_element)(target,0x25,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
        pcVar4 = (char *)gettext("No matches for: %s");
        HTSprintf0(&msg,pcVar4,arg);
        (*targetClass.put_string)(target,msg);
        if (tags[37].contents != SGML_EMPTY) {
          (*targetClass.end_element)(target,0x25,(char **)0x0);
        }
        if (msg != (char *)0x0) {
          free(msg);
          msg = (char *)0x0;
        }
      }
      (*targetClass.end_element)(target,0x24,(char **)0x0);
      (*targetClass.put_character)(target,'\n');
      if (pattern != (char *)0x0) {
        free(pattern);
        pattern = (char *)0x0;
      }
      local_240 = 200;
LAB_081386f3:
      if (local_c == *(int *)(in_GS_OFFSET + 0x14)) {
        return local_240;
      }
                    // WARNING: Subroutine does not return
      __stack_chk_fail();
    }
    ich = HTGetCharacter();
    iVar3 = s;
    ch = (char)ich;
    if (ich == -1) {
      if (interrupted_in_htgetcharacter == 0) {
        abort_socket();
        if (pattern != (char *)0x0) {
          free(pattern);
          pattern = (char *)0x0;
        }
        local_240 = 200;
      }
      else {
        interrupted_in_htgetcharacter = 0;
        if (WWW_TraceFlag != '\0') {
          pFVar2 = TraceFP();
          fprintf((FILE *)pFVar2,"HTNews: Interrupted on read, closing socket %d\n",iVar3);
        }
        close(s);
        s = -1;
        local_240 = -0x752e;
      }
      goto LAB_081386f3;
    }
    if (skip_this_line == '\0') {
      if (skip_rest_of_line == '\0') {
        if (p == line + 0x200) {
          if (WWW_TraceFlag != '\0') {
            iVar3 = (int)ch;
            pFVar2 = TraceFP();
            fprintf((FILE *)pFVar2,"b %.*s%c[...]\n",0x200,line,iVar3);
          }
          *p = '\0';
          if (ch != '\n') {
            if ((byte)ch < 0x21) {
              ch = '\n';
              skip_this_line = '\x01';
            }
            else {
              pcVar4 = strchr(line,0x20);
              if ((pcVar4 == (char *)0x0) && (pcVar4 = strchr(line,9), pcVar4 == (char *)0x0)) {
                if (WWW_TraceFlag != '\0') {
                  pFVar2 = TraceFP();
                  fprintf((FILE *)pFVar2,"HTNews..... group name too long, discarding.\n");
                }
                skip_this_line = '\x01';
                goto LAB_0813859b;
              }
              skip_rest_of_line = '\x01';
            }
          }
        }
        else {
          *p = ch;
          p = p + 1;
        }
      }
      else if (ch != '\n') goto LAB_0813859b;
      if (ch == '\n') {
        skip_rest_of_line = '\0';
        *p = '\0';
        if (WWW_TraceFlag != '\0') {
          pFVar2 = TraceFP();
          fprintf((FILE *)pFVar2,"B %s",line);
        }
        if (line[0] == '.') {
          if ((byte)line[1] < 0x20) {
            done = '\x01';
            goto LAB_081385a8;
          }
          (*targetClass.start_element)(target,0x25,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
          (*targetClass.put_string)(target,line + 1);
          if (tags[37].contents != SGML_EMPTY) {
            (*targetClass.end_element)(target,0x25,(char **)0x0);
          }
        }
        else {
          if (line[0] == '#') {
            p = line;
            goto LAB_0813859b;
          }
          for (i = 0; (line[i] != '\0' && (0x20 < (byte)line[i])); i = i + 1) {
          }
          if (line[i] == '\0') {
            if (((head != '\0') && (iVar3 = strncasecomp(line,pattern,len), iVar3 != 0)) ||
               ((tail != '\0' &&
                ((i < len || (iVar3 = strcasecomp(line + (i - len),pattern), iVar3 != 0)))))) {
              p = line;
              goto LAB_0813859b;
            }
            (*targetClass.start_element)(target,0x25,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
            write_anchor(line,line);
            if (tags[37].contents != SGML_EMPTY) {
              (*targetClass.end_element)(target,0x25,(char **)0x0);
            }
            listing = listing + 1;
          }
          else {
            line[i] = '\0';
            if (((head != '\0') && (iVar3 = strncasecomp(line,pattern,len), iVar3 != 0)) ||
               ((tail != '\0' &&
                ((i < len || (iVar3 = strcasecomp(line + (i - len),pattern), iVar3 != 0)))))) {
              p = line;
              goto LAB_0813859b;
            }
            (*targetClass.start_element)(target,0x25,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
            write_anchor(line,line);
            listing = listing + 1;
            if (tags[37].contents != SGML_EMPTY) {
              (*targetClass.end_element)(target,0x25,(char **)0x0);
            }
            (*targetClass.put_character)(target,'\n');
            (*targetClass.start_element)(target,0x1e,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
            (*targetClass.put_string)(target,line + i + 1);
            if (tags[30].contents != SGML_EMPTY) {
              (*targetClass.end_element)(target,0x1e,(char **)0x0);
            }
          }
        }
        p = line;
      }
      goto LAB_0813859b;
    }
    if (ch == '\n') {
      skip_rest_of_line = '\0';
      skip_this_line = '\0';
      p = line;
    }
  } while( true );
}



int read_group(char *groupName,int first_required,int last_required)

{
  _func_void_HTStructured_ptr_char_ptr_conflict *p_Var1;
  BOOLEAN BVar2;
  FILE *pFVar3;
  char *pcVar4;
  size_t sVar5;
  int iVar6;
  int in_GS_OFFSET;
  int *piVar7;
  int *piVar8;
  int *piVar9;
  int *piVar10;
  int local_46c;
  char *local_468;
  char *groupName_local;
  char *href;
  int after;
  char *p2;
  char *addr;
  int ich;
  int before;
  int last;
  int first;
  int count;
  int status;
  int art;
  char *reference;
  char *temp;
  char *p;
  int i;
  char *date;
  char *subject;
  char *author;
  BOOLEAN done;
  char buffer [513];
  char line [513];
  int local_14;
  
  local_14 = *(int *)(in_GS_OFFSET + 0x14);
  author = (char *)0x0;
  subject = (char *)0x0;
  date = (char *)0x0;
  temp = (char *)0x0;
  reference = (char *)0x0;
  (*targetClass.start_element)(target,0x35,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
  (*targetClass.put_character)(target,'\n');
  (*targetClass.start_element)(target,0x6e,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
  (*targetClass.put_string)(target,"Newsgroup ");
  (*targetClass.put_string)(target,groupName);
  (*targetClass.end_element)(target,0x6e,(char **)0x0);
  (*targetClass.put_character)(target,'\n');
  (*targetClass.end_element)(target,0x35,(char **)0x0);
  (*targetClass.put_character)(target,'\n');
  piVar9 = &last;
  piVar7 = &first;
  sscanf(response_text," %d %d %d %d",&status,&count,piVar7,piVar9);
  iVar6 = status;
  piVar8 = (int *)first;
  piVar10 = (int *)last;
  if (WWW_TraceFlag != '\0') {
    pFVar3 = TraceFP();
    fprintf((FILE *)pFVar3,"Newsgroup status=%d, count=%d, (%d-%d) required:(%d-%d)\n",iVar6,count,
            piVar8,piVar10,first_required,last_required);
    piVar7 = piVar8;
    piVar9 = piVar10;
  }
  p_Var1 = targetClass.put_string;
  if (last == 0) {
    pcVar4 = (char *)gettext("\nNo articles in this group.\n");
    (*p_Var1)(target,pcVar4);
  }
  else {
    if (first_required < first) {
      first_required = first;
    }
    if ((last_required == 0) || (last < last_required)) {
      last_required = last;
    }
    if (last_required < first_required) {
      pcVar4 = (char *)gettext("\nNo articles in this range.\n");
      (*p_Var1)(target,pcVar4);
    }
    else {
      if (HTNewsMaxChunk < (last_required - first_required) + 1) {
        first_required = (last_required - HTNewsChunkSize) + 1;
      }
      if (WWW_TraceFlag != '\0') {
        pFVar3 = TraceFP();
        fprintf((FILE *)pFVar3,"    Chunk will be (%d-%d)\n",first_required,last_required,piVar7,
                piVar9);
      }
      pcVar4 = (char *)gettext("%s,  Articles %d-%d");
      HTSprintf0(&temp,pcVar4,groupName,first_required,last_required);
      (*targetClass.start_element)(target,0x2f,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
      (*targetClass.put_string)(target,temp);
      if (temp != (char *)0x0) {
        free(temp);
        temp = (char *)0x0;
      }
      (*targetClass.end_element)(target,0x2f,(char **)0x0);
      (*targetClass.put_character)(target,'\n');
      if (first < first_required) {
        if (first < first_required - HTNewsMaxChunk) {
          before = first_required - HTNewsChunkSize;
        }
        else {
          before = first;
        }
        HTSprintf0(&dbuf,"%s%s/%d-%d",NewsHREF,groupName,before,first_required + -1);
        pcVar4 = dbuf;
        if (WWW_TraceFlag != '\0') {
          pFVar3 = TraceFP();
          fprintf((FILE *)pFVar3,"    Block before is %s\n",pcVar4);
        }
        (*targetClass.put_character)(target,'(');
        start_anchor(dbuf);
        p_Var1 = targetClass.put_string;
        pcVar4 = (char *)gettext("Earlier articles");
        (*p_Var1)(target,pcVar4);
        (*targetClass.end_element)(target,0,(char **)0x0);
        (*targetClass.put_string)(target,"...)\n");
        (*targetClass.start_element)(target,0x53,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
        (*targetClass.put_character)(target,'\n');
      }
      done = '\0';
      (*targetClass.start_element)(target,8,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
      p_Var1 = targetClass.put_string;
      if ((first == first_required) && (last == last_required)) {
        pcVar4 = (char *)gettext("All available articles in ");
        (*p_Var1)(target,pcVar4);
      }
      else {
        (*targetClass.put_string)(target,"Articles in ");
      }
      (*targetClass.put_string)(target,groupName);
      (*targetClass.end_element)(target,8,(char **)0x0);
      (*targetClass.put_character)(target,'\n');
      if (LYListNewsNumbers == '\0') {
        (*targetClass.start_element)(target,0x72,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
      }
      else {
        start_list(first_required);
      }
      for (art = first_required; art <= last_required; art = art + 1) {
        sprintf(buffer,"HEAD %d%c%c",art,0xd,10);
        status = response(buffer);
        iVar6 = s;
        if (status == 0xdd) {
          done = '\0';
          pcVar4 = line;
          while (p = pcVar4, done == '\0') {
            ich = HTGetCharacter();
            iVar6 = s;
            *p = (char)ich;
            pcVar4 = p + 1;
            if (ich == -1) {
              p = pcVar4;
              if (interrupted_in_htgetcharacter == 0) {
                abort_socket();
                local_46c = 200;
              }
              else {
                interrupted_in_htgetcharacter = 0;
                if (WWW_TraceFlag != '\0') {
                  pFVar3 = TraceFP();
                  fprintf((FILE *)pFVar3,"HTNews: Interrupted on read, closing socket %d\n",iVar6);
                }
                close(s);
                s = -1;
                local_46c = -0x752e;
              }
              goto LAB_08139a0a;
            }
            if (((char)ich == '\n') || (pcVar4 == line + 0x200)) {
              *p = '\0';
              p = line;
              if (WWW_TraceFlag != '\0') {
                pFVar3 = TraceFP();
                fprintf((FILE *)pFVar3,"G %s\n",line);
              }
              pcVar4 = p;
              switch(line[0]) {
              case '.':
                done = (byte)line[1] < 0x20;
                break;
              case 'D':
              case 'd':
                if ((LYListNewsDates != '\0') &&
                   (BVar2 = match(line,"DATE:"), pcVar4 = p, BVar2 != '\0')) {
                  pcVar4 = strchr(line,0x3a);
                  pcVar4 = HTStrip(pcVar4 + 1);
                  HTSACopy(&date,pcVar4);
                  pcVar4 = p;
                }
                break;
              case 'F':
              case 'f':
                BVar2 = match(line,"FROM:");
                pcVar4 = p;
                if (BVar2 != '\0') {
                  pcVar4 = strchr(line,0x3a);
                  HTSACopy(&author,pcVar4 + 1);
                  decode_mime(&author);
                  pcVar4 = author;
                  sVar5 = strlen(author);
                  p2 = pcVar4 + (sVar5 - 1);
                  pcVar4 = p;
                  if (*p2 == '\n') {
                    *p2 = '\0';
                  }
                }
                break;
              case 'M':
              case 'm':
                BVar2 = match(line,"MESSAGE-ID:");
                pcVar4 = p;
                if (BVar2 != '\0') {
                  pcVar4 = HTStrip(line + 0xb);
                  addr = pcVar4 + 1;
                  sVar5 = strlen(addr);
                  addr[sVar5 - 1] = '\0';
                  HTSACopy(&reference,addr);
                  pcVar4 = p;
                }
                break;
              case 'S':
              case 's':
                BVar2 = match(line,"SUBJECT:");
                pcVar4 = p;
                if (BVar2 != '\0') {
                  HTSACopy(&subject,line + 9);
                  decode_mime(&subject);
                  pcVar4 = p;
                }
              }
            }
          }
          (*targetClass.put_character)(target,'\n');
          (*targetClass.start_element)(target,0x44,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
          p = decode_mime(&subject);
          local_468 = p;
          if (p == (char *)0x0) {
            local_468 = "";
          }
          HTSprintf0(&temp,"\"%s\"",local_468);
          if (reference == (char *)0x0) {
            (*targetClass.put_string)(target,temp);
          }
          else {
            write_anchor(temp,reference);
            if (reference != (char *)0x0) {
              free(reference);
              reference = (char *)0x0;
            }
          }
          if (temp != (char *)0x0) {
            free(temp);
            temp = (char *)0x0;
          }
          if (author != (char *)0x0) {
            (*targetClass.put_string)(target," - ");
            if (LYListNewsDates != '\0') {
              (*targetClass.start_element)(target,0x39,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
            }
            p_Var1 = targetClass.put_string;
            pcVar4 = decode_mime(&author);
            (*p_Var1)(target,pcVar4);
            if (LYListNewsDates != '\0') {
              (*targetClass.end_element)(target,0x39,(char **)0x0);
            }
            if (author != (char *)0x0) {
              free(author);
              author = (char *)0x0;
            }
          }
          if (date != (char *)0x0) {
            if (diagnostic == 0) {
              for (i = 0; date[i] != '\0'; i = i + 1) {
                if (date[i] == ' ') {
                  date[i] = '\x01';
                }
              }
            }
            sprintf(buffer," [%.*s]",0x1fd,date);
            (*targetClass.put_string)(target,buffer);
            if (date != (char *)0x0) {
              free(date);
              date = (char *)0x0;
            }
          }
          if (tags[68].contents != SGML_EMPTY) {
            (*targetClass.end_element)(target,0x44,(char **)0x0);
          }
        }
        else {
          if (status == -0x752e) {
            interrupted_in_htgetcharacter = 0;
            if (WWW_TraceFlag != '\0') {
              pFVar3 = TraceFP();
              fprintf((FILE *)pFVar3,"HTNews: Interrupted on read, closing socket %d\n",iVar6);
            }
            close(s);
            s = -1;
            local_46c = -0x752e;
            goto LAB_08139a0a;
          }
          (*targetClass.put_character)(target,'\n');
          (*targetClass.start_element)(target,0x44,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
          (*targetClass.start_element)(target,0x39,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
          if (LYListNewsNumbers == '\0') {
            sprintf(buffer,"Status (ARTICLE %d):",art);
          }
          else {
            LYstrncpy(buffer,"Status:",L'');
          }
          (*targetClass.put_string)(target,buffer);
          (*targetClass.end_element)(target,0x39,(char **)0x0);
          (*targetClass.put_character)(target,' ');
          (*targetClass.put_string)(target,response_text);
          if (tags[68].contents != SGML_EMPTY) {
            (*targetClass.end_element)(target,0x44,(char **)0x0);
          }
        }
      }
      if (author != (char *)0x0) {
        free(author);
        author = (char *)0x0;
      }
      if (subject != (char *)0x0) {
        free(subject);
        subject = (char *)0x0;
      }
      (*targetClass.put_character)(target,'\n');
      if (LYListNewsNumbers == '\0') {
        (*targetClass.end_element)(target,0x72,(char **)0x0);
      }
      else {
        (*targetClass.end_element)(target,0x50,(char **)0x0);
      }
      (*targetClass.put_character)(target,'\n');
      if (last_required < last) {
        after = HTNewsChunkSize + last_required;
        if (after == last) {
          HTSprintf0(&dbuf,"%s%s",NewsHREF,groupName);
        }
        else {
          HTSprintf0(&dbuf,"%s%s/%d-%d",NewsHREF,groupName,last_required + 1,after);
        }
        pcVar4 = dbuf;
        if (WWW_TraceFlag != '\0') {
          pFVar3 = TraceFP();
          fprintf((FILE *)pFVar3,"    Block after is %s\n",pcVar4);
        }
        (*targetClass.put_character)(target,'(');
        start_anchor(dbuf);
        p_Var1 = targetClass.put_string;
        pcVar4 = (char *)gettext("Later articles");
        (*p_Var1)(target,pcVar4);
        (*targetClass.end_element)(target,0,(char **)0x0);
        (*targetClass.put_string)(target,"...)\n");
      }
    }
  }
  if (HTCanPost == 0) {
    (*targetClass.start_element)(target,0x36,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
  }
  else {
    href = (char *)0x0;
    (*targetClass.start_element)(target,0x36,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
    (*targetClass.put_character)(target,'\n');
    iVar6 = strncasecomp(NewsHREF,"snews:",6);
    if (iVar6 == 0) {
      HTSACopy(&href,"snewspost://");
    }
    else {
      HTSACopy(&href,"newspost://");
    }
    HTSACat(&href,NewsHost);
    HTSACat(&href,"/");
    HTSACat(&href,groupName);
    start_anchor(href);
    p_Var1 = targetClass.put_string;
    pcVar4 = (char *)gettext("Post to ");
    (*p_Var1)(target,pcVar4);
    (*targetClass.put_string)(target,groupName);
    (*targetClass.end_element)(target,0,(char **)0x0);
    if (href != (char *)0x0) {
      free(href);
      href = (char *)0x0;
    }
  }
  (*targetClass.put_character)(target,'\n');
  local_46c = 200;
LAB_08139a0a:
  if (local_14 == *(int *)(in_GS_OFFSET + 0x14)) {
    return local_46c;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int HTLoadNews(char *arg,HTParentAnchor *anAnchor,HTFormat format_out,HTStream *stream)

{
  HTStreamClass_conflict4 *pHVar1;
  HTStructuredClass *pHVar2;
  HTAtom *pHVar3;
  FILE *pFVar4;
  int iVar5;
  char *pcVar6;
  size_t sVar7;
  ushort **ppuVar8;
  uint uVar9;
  uint uVar10;
  char *pcVar11;
  NNTPAuthResult NVar12;
  int in_GS_OFFSET;
  int local_4c8;
  int local_4c4;
  char local_4c0;
  char local_4bc;
  char local_4b8;
  char local_4b4;
  char local_4b0;
  char local_4ac;
  BOOLEAN local_4a8;
  char *local_4a0;
  char *local_49c;
  char *local_498;
  undefined *local_494;
  undefined *local_48c;
  BOOLEAN local_488;
  BOOLEAN local_484;
  char *local_47c;
  HTStream *stream_local;
  HTFormat format_out_local;
  HTParentAnchor *anAnchor_local;
  char *arg_local;
  NNTPAuthResult auth_result_1;
  NNTPAuthResult auth_result;
  char *p;
  int add_close;
  int add_open;
  char *slash;
  char *p1;
  char *postfile;
  char *ProxyHREF;
  char *ProxyHost;
  char *ListArg;
  char *cp;
  int last;
  int first;
  int retries;
  int status;
  BOOLEAN head_wanted;
  BOOLEAN sreply_wanted;
  BOOLEAN spost_wanted;
  BOOLEAN reply_wanted;
  BOOLEAN post_wanted;
  BOOLEAN list_wanted;
  BOOLEAN group_wanted;
  BOOLEAN normal_url;
  char command [262];
  char url [260];
  char proxycmd [260];
  char groupName [256];
  int local_c;
  
  local_c = *(int *)(in_GS_OFFSET + 0x14);
  head_wanted = '\0';
  cp = (char *)0x0;
  ListArg = (char *)0x0;
  ProxyHost = (char *)0x0;
  ProxyHREF = (char *)0x0;
  postfile = (char *)0x0;
  if (((format_out == WWW_SOURCE) || (pHVar3 = HTAtom_for("www/download"), pHVar3 == format_out)) ||
     (pHVar3 = HTAtom_for("www/dump"), pHVar3 == format_out)) {
    local_4c8 = 1;
  }
  else {
    local_4c8 = 0;
  }
  diagnostic = local_4c8;
  rawtext = '\0';
  if (WWW_TraceFlag != '\0') {
    pFVar4 = TraceFP();
    fprintf((FILE *)pFVar4,"HTNews: Looking for %s\n",arg);
  }
  if (initialized == '\0') {
    initialized = initialize();
  }
  if (initialized == '\0') {
    local_4c4 = -1;
  }
  else {
    if (NewsHREF != (char *)0x0) {
      free(NewsHREF);
      NewsHREF = (char *)0x0;
    }
    command[0] = '\0';
    command[261] = '\0';
    proxycmd[0] = '\0';
    proxycmd[259] = '\0';
    iVar5 = strncmp(arg,"news:",5);
    if ((iVar5 == 0) || (iVar5 = strncmp(arg,"nntp:",5), iVar5 == 0)) {
      local_4c0 = '\x01';
    }
    else {
      local_4c0 = '\0';
    }
    normal_url = local_4c0;
    if ((local_4c0 == '\0') && (pcVar6 = strstr(arg,"snewspost:"), pcVar6 != (char *)0x0)) {
      local_4bc = '\x01';
    }
    else {
      local_4bc = '\0';
    }
    spost_wanted = local_4bc;
    if (((normal_url == '\0') && (local_4bc == '\0')) &&
       (pcVar6 = strstr(arg,"snewsreply:"), pcVar6 != (char *)0x0)) {
      local_4b8 = '\x01';
    }
    else {
      local_4b8 = '\0';
    }
    sreply_wanted = local_4b8;
    if (((normal_url == '\0') && (spost_wanted == '\0')) &&
       ((local_4b8 == '\0' && (pcVar6 = strstr(arg,"newspost:"), pcVar6 != (char *)0x0)))) {
      local_4b4 = '\x01';
    }
    else {
      local_4b4 = '\0';
    }
    post_wanted = local_4b4;
    if (((normal_url == '\0') && (spost_wanted == '\0')) &&
       ((sreply_wanted == '\0' &&
        ((local_4b4 == '\0' && (pcVar6 = strstr(arg,"newsreply:"), pcVar6 != (char *)0x0)))))) {
      local_4b0 = '\x01';
    }
    else {
      local_4b0 = '\0';
    }
    reply_wanted = local_4b0;
    if (((((spost_wanted == '\0') && (sreply_wanted == '\0')) && (post_wanted == '\0')) &&
        ((local_4b0 == '\0' && (pcVar6 = strchr(arg,0x40), pcVar6 == (char *)0x0)))) &&
       (pcVar6 = strchr(arg,0x2a), pcVar6 == (char *)0x0)) {
      local_4ac = '\x01';
    }
    else {
      local_4ac = '\0';
    }
    group_wanted = local_4ac;
    if ((((spost_wanted == '\0') && (sreply_wanted == '\0')) &&
        ((post_wanted == '\0' &&
         (((reply_wanted == '\0' && (local_4ac == '\0')) &&
          (pcVar6 = strchr(arg,0x40), pcVar6 == (char *)0x0)))))) &&
       (pcVar6 = strchr(arg,0x2a), pcVar6 != (char *)0x0)) {
      local_4a8 = '\x01';
    }
    else {
      local_4a8 = '\0';
    }
    list_wanted = local_4a8;
    iVar5 = strncasecomp(arg,"snewspost:",10);
    if ((iVar5 == 0) || (iVar5 = strncasecomp(arg,"snewsreply:",0xb), iVar5 == 0)) {
      pcVar6 = (char *)gettext("This client does not contain support for posting to news with SSL.")
      ;
      HTAlert(pcVar6);
      local_4c4 = -29999;
    }
    else {
      if (((post_wanted == '\0') && ((reply_wanted == '\0' && (spost_wanted == '\0')))) &&
         (sreply_wanted == '\0')) {
        iVar5 = strncasecomp(arg,"nntp:",5);
        if (iVar5 == 0) {
          if ((((arg[5] == '\0') || (iVar5 = strcmp(arg + 5,"/"), iVar5 == 0)) ||
              ((iVar5 = strcmp(arg + 5,"//"), iVar5 == 0 ||
               (iVar5 = strcmp(arg + 5,"///"), iVar5 == 0)))) ||
             ((iVar5 = strncmp(arg + 5,"//",2), iVar5 == 0 &&
              ((cp = strchr(arg + 7,0x2f), cp == (char *)0x0 || (cp[1] == '\0')))))) {
            p1 = "*";
            group_wanted = '\0';
            list_wanted = '\x01';
          }
          else if (arg[5] == '/') {
            if ((arg[5] == '/') && (arg[6] != '/')) {
              p1 = arg + 6;
            }
            else {
              p1 = cp + 1;
            }
          }
          else {
            p1 = arg + 5;
          }
          cp = HTParse(arg,"",8);
          if ((cp == (char *)0x0) || (*cp == '\0')) {
            if ((-1 < s) &&
               ((NewsHost != (char *)0x0 && (iVar5 = strcasecomp(NewsHost,HTNewsHost), iVar5 != 0)))
               ) {
              close(s);
              s = -1;
            }
            HTSACopy(&NewsHost,HTNewsHost);
          }
          else {
            if (((-1 < s) && (NewsHost != (char *)0x0)) &&
               (iVar5 = strcasecomp(NewsHost,cp), iVar5 != 0)) {
              close(s);
              s = -1;
            }
            HTSACopy(&NewsHost,cp);
          }
          if (cp != (char *)0x0) {
            free(cp);
            cp = (char *)0x0;
          }
          sprintf(command,"%s//%.*s/","nntp:",0xfd,NewsHost);
          HTSACopy(&NewsHREF,command);
        }
        else {
          iVar5 = strncasecomp(arg,"snews:",6);
          if (iVar5 == 0) {
            pcVar6 = (char *)gettext("This client does not contain support for SNEWS URLs.");
            HTAlert(pcVar6);
            local_4c4 = -29999;
            goto LAB_0813c941;
          }
          iVar5 = strncasecomp(arg,"news:/",6);
          if (iVar5 == 0) {
            if ((((arg[6] == '\0') || (iVar5 = strcmp(arg + 6,"/"), iVar5 == 0)) ||
                (iVar5 = strcmp(arg + 6,"//"), iVar5 == 0)) ||
               ((arg[6] == '/' &&
                ((cp = strchr(arg + 7,0x2f), cp == (char *)0x0 || (cp[1] == '\0')))))) {
              p1 = "*";
              group_wanted = '\0';
              list_wanted = '\x01';
            }
            else if (arg[6] == '/') {
              p1 = cp + 1;
            }
            else {
              p1 = arg + 6;
            }
            cp = HTParse(arg,"",8);
            if ((cp == (char *)0x0) || (*cp == '\0')) {
              if ((-1 < s) &&
                 ((NewsHost != (char *)0x0 && (iVar5 = strcasecomp(NewsHost,HTNewsHost), iVar5 != 0)
                  ))) {
                close(s);
                s = -1;
              }
              HTSACopy(&NewsHost,HTNewsHost);
            }
            else {
              if (((-1 < s) && (NewsHost != (char *)0x0)) &&
                 (iVar5 = strcasecomp(NewsHost,cp), iVar5 != 0)) {
                close(s);
                s = -1;
              }
              HTSACopy(&NewsHost,cp);
            }
            if (cp != (char *)0x0) {
              free(cp);
              cp = (char *)0x0;
            }
            sprintf(command,"news://%.*s/",0xfd,NewsHost);
            HTSACopy(&NewsHREF,command);
          }
          else {
            p1 = arg + 5;
            if (*p1 == '\0') {
              p1 = "*";
              group_wanted = '\0';
              list_wanted = '\x01';
            }
            if (((-1 < s) && (NewsHost != (char *)0x0)) &&
               (iVar5 = strcasecomp(NewsHost,HTNewsHost), iVar5 != 0)) {
              close(s);
              s = -1;
            }
            HTSACopy(&NewsHost,HTNewsHost);
            HTSACopy(&NewsHREF,"news:");
          }
        }
      }
      else {
        pcVar6 = strrchr(arg,0x2f);
        if (pcVar6 == (char *)0x0) {
          p1 = strrchr(arg,0x3a);
          if (p1 != (char *)0x0) {
            p1 = p1 + 1;
          }
        }
        else {
          p1 = pcVar6 + 1;
        }
        if ((p1 == (char *)0x0) || (*p1 == '\0')) {
          pcVar6 = (char *)gettext("Illegal URL: %s");
          HTAlert(pcVar6);
          local_4c4 = -0xcc;
          goto LAB_0813c941;
        }
        cp = HTParse(arg,"",8);
        if ((cp == (char *)0x0) || (*cp == '\0')) {
          if ((-1 < s) &&
             ((NewsHost != (char *)0x0 && (iVar5 = strcasecomp(NewsHost,HTNewsHost), iVar5 != 0))))
          {
            close(s);
            s = -1;
          }
          HTSACopy(&NewsHost,HTNewsHost);
        }
        else {
          if (((-1 < s) && (NewsHost != (char *)0x0)) &&
             (iVar5 = strcasecomp(NewsHost,cp), iVar5 != 0)) {
            close(s);
            s = -1;
          }
          HTSACopy(&NewsHost,cp);
        }
        if (cp != (char *)0x0) {
          free(cp);
          cp = (char *)0x0;
        }
        if (post_wanted == '\0') {
          if (reply_wanted == '\0') {
            if (spost_wanted == '\0') {
              local_498 = "snewsreply";
            }
            else {
              local_498 = "snewspost";
            }
            local_49c = local_498;
          }
          else {
            local_49c = "newreply";
          }
          local_4a0 = local_49c;
        }
        else {
          local_4a0 = "newspost";
        }
        HTSprintf0(&NewsHREF,"%s://%.*s/",local_4a0,0xf7,NewsHost);
        if ((spost_wanted != '\0') && (iVar5 = strncasecomp(arg,"snewspost:",10), iVar5 != 0)) {
          p1 = strstr(arg,"snewspost:");
        }
        if ((sreply_wanted != '\0') && (iVar5 = strncasecomp(arg,"snewsreply:",0xb), iVar5 != 0)) {
          p1 = strstr(arg,"snewsreply:");
        }
      }
      iVar5 = strncasecomp(p1,"snews:",6);
      if (((iVar5 == 0) || (iVar5 = strncasecomp(p1,"snewspost:",10), iVar5 == 0)) ||
         (iVar5 = strncasecomp(p1,"snewsreply:",0xb), iVar5 == 0)) {
        HTSACopy(&ProxyHost,NewsHost);
        cp = HTParse(p1,"",8);
        if ((cp == (char *)0x0) || (*cp == '\0')) {
          sprintf(command,"%s//%.*s","snews:",0xfc,NewsHost);
        }
        else {
          sprintf(command,"%s//%.*s","snews:",0xfc,cp);
          HTSACopy(&NewsHost,cp);
        }
        command[260] = '\0';
        if (cp != (char *)0x0) {
          free(cp);
          cp = (char *)0x0;
        }
        sprintf(proxycmd,"GET %.*s%c%c%c%c",0xfb,command,0xd,10,0xd,10);
        if (WWW_TraceFlag != '\0') {
          sVar7 = strlen(proxycmd);
          pFVar4 = TraceFP();
          fprintf((FILE *)pFVar4,"HTNews: Proxy command is \'%.*s\'\n",sVar7 - 4,proxycmd);
        }
        strcat(command,"/");
        HTSACopy(&ProxyHREF,NewsHREF);
        HTSACopy(&NewsHREF,command);
        if ((spost_wanted == '\0') && (sreply_wanted == '\0')) {
          cp = strrchr(p1 + 6,0x2f);
          if ((cp == (char *)0x0) || (cp[1] == '\0')) {
            p1 = "*";
            group_wanted = '\0';
            list_wanted = '\x01';
          }
          else {
            p1 = cp + 1;
          }
        }
        else {
          pcVar6 = strrchr(arg,0x2f);
          if (pcVar6 == (char *)0x0) {
            pcVar6 = strrchr(arg,0x3a);
            p1 = pcVar6 + 1;
          }
          else {
            p1 = pcVar6 + 1;
          }
        }
      }
      if ((((post_wanted == '\0') && (reply_wanted == '\0')) && (spost_wanted == '\0')) &&
         (sreply_wanted == '\0')) {
        if (list_wanted == '\0') {
          if (group_wanted == '\0') {
            pcVar6 = strchr(p1,0x3c);
            uVar9 = (uint)(pcVar6 == (char *)0x0);
            pcVar6 = strchr(p1,0x3e);
            uVar10 = (uint)(pcVar6 == (char *)0x0);
            sVar7 = strlen(p1);
            if (0xfb < sVar7 + uVar9 + uVar10) {
              if (ProxyHost != (char *)0x0) {
                free(ProxyHost);
                ProxyHost = (char *)0x0;
              }
              if (ProxyHREF != (char *)0x0) {
                free(ProxyHREF);
                ProxyHREF = (char *)0x0;
              }
              pcVar6 = (char *)gettext("URL too long");
              HTAlert(pcVar6);
              local_4c4 = -400;
              goto LAB_0813c941;
            }
            if (uVar10 == 0) {
              local_494 = &DAT_0818ec67;
            }
            else {
              local_494 = &DAT_0818f305;
            }
            if (uVar9 == 0) {
              local_48c = &DAT_0818ec67;
            }
            else {
              local_48c = &DAT_0818f307;
            }
            sprintf(command,"ARTICLE %s%.*s%s",local_48c,(-uVar10 - uVar9) + 0xfb,p1,local_494);
          }
          else {
            pcVar6 = strchr(p1,0x2f);
            first = 0;
            last = 0;
            if (pcVar6 == (char *)0x0) {
              sVar7 = strlen(p1);
              if (0xff < sVar7) {
                if (ProxyHost != (char *)0x0) {
                  free(ProxyHost);
                  ProxyHost = (char *)0x0;
                }
                if (ProxyHREF != (char *)0x0) {
                  free(ProxyHREF);
                  ProxyHREF = (char *)0x0;
                }
                pcVar6 = (char *)gettext("URL too long");
                HTAlert(pcVar6);
                local_4c4 = -400;
                goto LAB_0813c941;
              }
              LYstrncpy(groupName,p1,L'');
            }
            else {
              *pcVar6 = '\0';
              sVar7 = strlen(p1);
              if (0xff < sVar7) {
                if (ProxyHost != (char *)0x0) {
                  free(ProxyHost);
                  ProxyHost = (char *)0x0;
                }
                if (ProxyHREF != (char *)0x0) {
                  free(ProxyHREF);
                  ProxyHREF = (char *)0x0;
                }
                pcVar6 = (char *)gettext("URL too long");
                HTAlert(pcVar6);
                local_4c4 = -400;
                goto LAB_0813c941;
              }
              LYstrncpy(groupName,p1,L'');
              *pcVar6 = '/';
              sscanf(pcVar6 + 1,"%d-%d",&first,&last);
              if (((0 < first) &&
                  (ppuVar8 = __ctype_b_loc(), ((*ppuVar8)[(byte)pcVar6[1]] & 0x800) != 0)) &&
                 ((pcVar6 = strchr(pcVar6 + 1,0x2d), pcVar6 == (char *)0x0 || (first == last)))) {
                last = -1;
              }
            }
            sprintf(command,"GROUP %.*s",0xfd,groupName);
          }
        }
        else {
          sVar7 = strlen(p1);
          if (0xf9 < sVar7) {
            if (ProxyHost != (char *)0x0) {
              free(ProxyHost);
              ProxyHost = (char *)0x0;
            }
            if (ProxyHREF != (char *)0x0) {
              free(ProxyHREF);
              ProxyHREF = (char *)0x0;
            }
            pcVar6 = (char *)gettext("URL too long");
            HTAlert(pcVar6);
            local_4c4 = -400;
            goto LAB_0813c941;
          }
          sprintf(command,"XGTITLE %.*s",0xfb,p1);
        }
      }
      else {
        memcpy(command,&DAT_0818f2d5,5);
      }
      sVar7 = strlen(command);
      command[sVar7] = '\r';
      command[sVar7 + 1] = '\n';
      command[sVar7 + 2] = '\0';
      HTSACopy(&ListArg,p1);
      if (*arg != '\0') {
        if (((post_wanted == '\0') && (reply_wanted == '\0')) &&
           (((spost_wanted == '\0' && (sreply_wanted == '\0')) &&
            (((group_wanted == '\0' || (last == -1)) && (list_wanted == '\0')))))) {
          head_wanted = anAnchor->isHEAD;
          if ((head_wanted != '\0') && (iVar5 = strncmp(command,"ARTICLE ",8), iVar5 == 0)) {
            memcpy(command,"HEAD ",6);
            for (cp = command + 5; *cp = cp[3], *cp != '\0'; cp = cp + 1) {
            }
          }
          if ((head_wanted == '\0') && (keep_mime_headers == '\0')) {
            local_488 = '\0';
          }
          else {
            local_488 = '\x01';
          }
          rawtext = local_488;
        }
        if (rawtext == '\0') {
          if ((((post_wanted == '\0') && (reply_wanted == '\0')) && (spost_wanted == '\0')) &&
             (sreply_wanted == '\0')) {
            node_anchor = anAnchor;
            target = (HTStructured_conflict *)
                     HTML_new(anAnchor,format_out,(HTStream_conflict *)stream);
            pHVar2 = ((HTStructured *)target)->isa;
            targetClass.name = pHVar2->name;
            targetClass._free = (_func_void_HTStructured_ptr_conflict *)pHVar2->_free;
            targetClass._abort = (_func_void_HTStructured_ptr_HTError_conflict *)pHVar2->_abort;
            targetClass.put_character =
                 (_func_void_HTStructured_ptr_char_conflict *)pHVar2->put_character;
            targetClass.put_string =
                 (_func_void_HTStructured_ptr_char_ptr_conflict *)pHVar2->put_string;
            targetClass.put_block =
                 (_func_void_HTStructured_ptr_char_ptr_int_conflict *)pHVar2->put_block;
            targetClass.start_element =
                 (_func_int_HTStructured_ptr_int_BOOLEAN_ptr_char_ptr_ptr_int_char_ptr_ptr_conflict
                  *)pHVar2->start_element;
            targetClass.end_element =
                 (_func_int_HTStructured_ptr_int_char_ptr_ptr_conflict *)pHVar2->end_element;
            targetClass.put_entity = (_func_int_HTStructured_ptr_int_conflict *)pHVar2->put_entity;
          }
        }
        else {
          node_anchor = anAnchor;
          pHVar3 = HTAtom_for("text/plain");
          rawtarget = (HTStream *)
                      HTStreamStack(pHVar3,format_out,(HTStream_conflict4 *)stream,anAnchor);
          if ((HTStream_conflict4 *)rawtarget == (HTStream_conflict4 *)0x0) {
            if (NewsHost != (char *)0x0) {
              free(NewsHost);
              NewsHost = (char *)0x0;
            }
            if (NewsHREF != (char *)0x0) {
              free(NewsHREF);
              NewsHREF = (char *)0x0;
            }
            if (ProxyHost != (char *)0x0) {
              free(ProxyHost);
              ProxyHost = (char *)0x0;
            }
            if (ProxyHREF != (char *)0x0) {
              free(ProxyHREF);
              ProxyHREF = (char *)0x0;
            }
            if (ListArg != (char *)0x0) {
              free(ListArg);
              ListArg = (char *)0x0;
            }
            pcVar6 = (char *)gettext("No target for raw text!");
            HTAlert(pcVar6);
            local_4c4 = -29999;
            goto LAB_0813c941;
          }
          pHVar1 = ((HTStream_conflict4 *)rawtarget)->isa;
          rawtargetClass.name = pHVar1->name;
          rawtargetClass._free = (_func_void_HTStream_ptr *)pHVar1->_free;
          rawtargetClass._abort = (_func_void_HTStream_ptr_HTError *)pHVar1->_abort;
          rawtargetClass.put_character = (_func_void_HTStream_ptr_char *)pHVar1->put_character;
          rawtargetClass.put_string = (_func_void_HTStream_ptr_char_ptr *)pHVar1->put_string;
          rawtargetClass.put_block = (_func_void_HTStream_ptr_char_ptr_wchar_t *)pHVar1->put_block;
        }
        retries = 0;
LAB_0813c7eb:
        if (1 < retries) goto LAB_0813c7f8;
        if (-1 < s) {
LAB_0813bd99:
          if ((((post_wanted == '\0') && (reply_wanted == '\0')) && (spost_wanted == '\0')) &&
             (sreply_wanted == '\0')) {
            sprintf(url,"mode reader%c%c",0xd,10);
            status = response(url);
            if (status == -0x752e) {
              mustshow = '\x01';
              pcVar6 = (char *)gettext("Connection interrupted.");
              HTProgress(pcVar6);
              goto LAB_0813c7f8;
            }
            if (status == 0x1e0) {
              NVar12 = HTHandleAuthInfo(NewsHost);
              if ((((NVar12 == NNTPAUTH_CLOSE) && (s != -1)) && (ProxyHost == (char *)0x0)) &&
                 (ProxyHREF == (char *)0x0)) {
                close(s);
                s = -1;
              }
              if (NVar12 != NNTPAUTH_OK) goto LAB_0813c7f8;
              status = response(url);
              if (status == -0x752e) {
                mustshow = '\x01';
                pcVar6 = (char *)gettext("Connection interrupted.");
                HTProgress(pcVar6);
                goto LAB_0813c7f8;
              }
            }
          }
          else {
            if (HTCanPost == 0) {
              pcVar6 = (char *)gettext("Cannot POST to this host.");
              HTAlert(pcVar6);
              if (NewsHREF != (char *)0x0) {
                free(NewsHREF);
                NewsHREF = (char *)0x0;
              }
              if (ProxyHREF != (char *)0x0) {
                HTSACopy(&NewsHost,ProxyHost);
                if (ProxyHost != (char *)0x0) {
                  free(ProxyHost);
                  ProxyHost = (char *)0x0;
                }
                if (ProxyHREF != (char *)0x0) {
                  free(ProxyHREF);
                  ProxyHREF = (char *)0x0;
                }
              }
              if (ListArg != (char *)0x0) {
                free(ListArg);
                ListArg = (char *)0x0;
              }
              if ((postfile != (char *)0x0) && (remove(postfile), postfile != (char *)0x0)) {
                free(postfile);
              }
              local_4c4 = -29999;
              goto LAB_0813c941;
            }
            if (postfile == (char *)0x0) {
              if ((reply_wanted == '\0') && (sreply_wanted == '\0')) {
                local_484 = '\0';
              }
              else {
                local_484 = '\x01';
              }
              postfile = LYNewsPost(ListArg,local_484);
            }
            if (postfile == (char *)0x0) {
              pcVar6 = (char *)gettext("Cancelled!!!");
              HTProgress(pcVar6);
              if (NewsHREF != (char *)0x0) {
                free(NewsHREF);
                NewsHREF = (char *)0x0;
              }
              if (ProxyHREF != (char *)0x0) {
                HTSACopy(&NewsHost,ProxyHost);
                if (ProxyHost != (char *)0x0) {
                  free(ProxyHost);
                  ProxyHost = (char *)0x0;
                }
                if (ProxyHREF != (char *)0x0) {
                  free(ProxyHREF);
                  ProxyHREF = (char *)0x0;
                }
              }
              if (ListArg != (char *)0x0) {
                free(ListArg);
                ListArg = (char *)0x0;
              }
              local_4c4 = -29999;
              goto LAB_0813c941;
            }
          }
Send_NNTP_command:
          do {
            status = response(command);
            if (status == -0x752e) {
              mustshow = '\x01';
              pcVar6 = (char *)gettext("Connection interrupted.");
              HTProgress(pcVar6);
              goto LAB_0813c7f8;
            }
            if (status < 0) {
              if (0 < retries) goto LAB_0813c7f8;
              goto LAB_0813c7e4;
            }
            if (((status == 0x19b) && (group_wanted != '\0')) &&
               ((iVar5 = strncmp(command,"GROUP ",6), iVar5 == 0 &&
                ((iVar5 = strncasecomp(response_text + 3," No such group ",0xf), iVar5 == 0 &&
                 (iVar5 = strcmp(response_text + 0x12,groupName), iVar5 == 0)))))) {
              HTAlert(response_text);
              goto LAB_0813c7f8;
            }
            if ((((status == 0x1ae) && (group_wanted == '\0')) && (list_wanted == '\0')) &&
               ((iVar5 = strncmp(command,"ARTICLE <",9), iVar5 == 0 &&
                (iVar5 = strcasecomp(response_text + 3," No such article"), iVar5 == 0)))) {
              HTAlert(response_text);
              goto LAB_0813c7f8;
            }
            if (((99 < status - 200U) && (status != 0x154)) && (status != 0x1e0)) {
              if (retries == 0) {
                mustshow = '\x01';
                HTProgress(response_text);
              }
              else {
                if ((list_wanted != '\0') && (iVar5 = strncmp(command,"XGTITLE",7), iVar5 == 0)) {
                  sprintf(command,"LIST NEWSGROUPS%c%c",0xd,10);
                  goto Send_NNTP_command;
                }
                HTAlert(response_text);
              }
              close(s);
              s = -1;
              goto LAB_0813c7e4;
            }
            if (status != 0x1e0) {
              if (((post_wanted != '\0') || (reply_wanted != '\0')) ||
                 ((spost_wanted != '\0' || (sreply_wanted != '\0')))) {
                if (status == 0x154) {
                  post_article(postfile);
                }
                else {
                  pcVar6 = (char *)gettext("Cannot POST to this host.");
                  HTAlert(pcVar6);
                  if (postfile != (char *)0x0) {
                    remove(postfile);
                  }
                }
                if (postfile != (char *)0x0) {
                  free(postfile);
                  postfile = (char *)0x0;
                }
                status = -29999;
                goto LAB_0813c61c;
              }
              if (list_wanted != '\0') {
                mustshow = '\x01';
                pcVar6 = (char *)gettext("Reading list of available newsgroups.");
                HTProgress(pcVar6);
                status = read_list(ListArg);
                goto LAB_0813c61c;
              }
              if (group_wanted == '\0') {
                mustshow = '\x01';
                pcVar6 = (char *)gettext("Reading news article.");
                HTProgress(pcVar6);
                status = read_article(anAnchor);
                goto LAB_0813c61c;
              }
              if (-1 < last) {
                mustshow = '\x01';
                pcVar6 = (char *)gettext("Reading list of articles in newsgroup.");
                HTProgress(pcVar6);
                status = read_group(groupName,first,last);
                goto LAB_0813c61c;
              }
              if (head_wanted == '\0') {
                local_47c = "ARTICLE";
              }
              else {
                local_47c = "HEAD";
              }
              sprintf(command,"%s %d%c%c",local_47c,first,0xd,10);
              group_wanted = '\0';
              retries = 2;
              goto Send_NNTP_command;
            }
            if ((((list_wanted != '\0') && (iVar5 = strncmp(command,"XGTITLE",7), iVar5 == 0)) &&
                (pcVar6 = strstr(response_text,"uthenticat"), pcVar6 == (char *)0x0)) &&
               (pcVar6 = strstr(response_text,"uthor"), pcVar6 == (char *)0x0)) {
              sprintf(command,"LIST NEWSGROUPS%c%c",0xd,10);
              goto Send_NNTP_command;
            }
            NVar12 = HTHandleAuthInfo(NewsHost);
          } while (NVar12 == NNTPAUTH_OK);
          if (NVar12 == NNTPAUTH_CLOSE) {
            if (((s != -1) && (ProxyHost == (char *)0x0)) && (ProxyHREF == (char *)0x0)) {
              close(s);
              s = -1;
            }
            if (retries < 1) goto LAB_0813c7e4;
          }
          status = -29999;
LAB_0813c61c:
          if (status == -0x752e) {
            mustshow = '\x01';
            pcVar6 = (char *)gettext("Connection interrupted.");
            HTProgress(pcVar6);
            status = 200;
          }
          if (((post_wanted == '\0') && (reply_wanted == '\0')) &&
             ((spost_wanted == '\0' && (sreply_wanted == '\0')))) {
            if (status == -29999) {
              if (rawtext == '\0') {
                (*targetClass._abort)(target,(HTError)0x0);
              }
              else {
                (*rawtargetClass._abort)(rawtarget,(HTError)0x0);
              }
            }
            else if (rawtext == '\0') {
              (*targetClass._free)(target);
            }
            else {
              (*rawtargetClass._free)(rawtarget);
            }
          }
          if (NewsHREF != (char *)0x0) {
            free(NewsHREF);
            NewsHREF = (char *)0x0;
          }
          if (ProxyHREF != (char *)0x0) {
            HTSACopy(&NewsHost,ProxyHost);
            if (ProxyHost != (char *)0x0) {
              free(ProxyHost);
              ProxyHost = (char *)0x0;
            }
            if (ProxyHREF != (char *)0x0) {
              free(ProxyHREF);
              ProxyHREF = (char *)0x0;
            }
          }
          if (ListArg != (char *)0x0) {
            free(ListArg);
            ListArg = (char *)0x0;
          }
          if ((postfile != (char *)0x0) && (remove(postfile), postfile != (char *)0x0)) {
            free(postfile);
          }
          local_4c4 = status;
          goto LAB_0813c941;
        }
        iVar5 = strcmp(NewsHREF,"news:");
        if (iVar5 == 0) {
          sprintf(url,"lose://%.*s/",0xfb,NewsHost);
        }
        else if (ProxyHREF == (char *)0x0) {
          sprintf(url,"%.*s",0x103,NewsHREF);
        }
        else {
          sprintf(url,"%.*s",0x103,ProxyHREF);
        }
        if (WWW_TraceFlag != '\0') {
          pFVar4 = TraceFP();
          fprintf((FILE *)pFVar4,"News: doing HTDoConnect on \'%s\'\n",url);
        }
        mustshow = '\x01';
        pcVar6 = (char *)gettext("Connecting to NewsHost ...");
        HTProgress(pcVar6);
        status = HTDoConnect(url,"NNTP",0x77,&s);
        pcVar6 = NewsHost;
        if (status == -0x752e) {
          if (WWW_TraceFlag != '\0') {
            pFVar4 = TraceFP();
            fprintf((FILE *)pFVar4,"HTNews: Interrupted on connect; recovering cleanly.\n");
          }
          mustshow = '\x01';
          pcVar6 = (char *)gettext("Connection interrupted.");
          HTProgress(pcVar6);
          if (((post_wanted == '\0') && (reply_wanted == '\0')) &&
             ((spost_wanted == '\0' && (sreply_wanted == '\0')))) {
            if (rawtext == '\0') {
              (*targetClass._abort)(target,(HTError)0x0);
            }
            else {
              (*rawtargetClass._abort)(rawtarget,(HTError)0x0);
            }
          }
          if (NewsHost != (char *)0x0) {
            free(NewsHost);
            NewsHost = (char *)0x0;
          }
          if (NewsHREF != (char *)0x0) {
            free(NewsHREF);
            NewsHREF = (char *)0x0;
          }
          if (ProxyHost != (char *)0x0) {
            free(ProxyHost);
            ProxyHost = (char *)0x0;
          }
          if (ProxyHREF != (char *)0x0) {
            free(ProxyHREF);
            ProxyHREF = (char *)0x0;
          }
          if (ListArg != (char *)0x0) {
            free(ListArg);
            ListArg = (char *)0x0;
          }
          if ((postfile != (char *)0x0) && (remove(postfile), postfile != (char *)0x0)) {
            free(postfile);
          }
          local_4c4 = -29999;
          goto LAB_0813c941;
        }
        if (status < 0) {
          close(s);
          s = -1;
          if (WWW_TraceFlag != '\0') {
            pFVar4 = TraceFP();
            fprintf((FILE *)pFVar4,"HTNews: Unable to connect to news host.\n");
          }
          if (0 < retries) {
            if (((post_wanted == '\0') && (reply_wanted == '\0')) &&
               ((spost_wanted == '\0' && (sreply_wanted == '\0')))) {
              if (rawtext == '\0') {
                (*targetClass._abort)(target,(HTError)0x0);
              }
              else {
                (*rawtargetClass._abort)(rawtarget,(HTError)0x0);
              }
            }
            pcVar6 = NewsHost;
            pcVar11 = (char *)gettext("Could not access %s.");
            HTSprintf0(&dbuf,pcVar11,pcVar6);
            if (NewsHost != (char *)0x0) {
              free(NewsHost);
              NewsHost = (char *)0x0;
            }
            if (NewsHREF != (char *)0x0) {
              free(NewsHREF);
              NewsHREF = (char *)0x0;
            }
            if (ProxyHost != (char *)0x0) {
              free(ProxyHost);
              ProxyHost = (char *)0x0;
            }
            if (ProxyHREF != (char *)0x0) {
              free(ProxyHREF);
              ProxyHREF = (char *)0x0;
            }
            if (ListArg != (char *)0x0) {
              free(ListArg);
              ListArg = (char *)0x0;
            }
            if ((postfile != (char *)0x0) && (remove(postfile), postfile != (char *)0x0)) {
              free(postfile);
            }
            local_4c4 = HTLoadError((HTStream_conflict *)stream,500,dbuf);
            goto LAB_0813c941;
          }
        }
        else {
          if (WWW_TraceFlag != '\0') {
            pFVar4 = TraceFP();
            fprintf((FILE *)pFVar4,"HTNews: Connected to news host %s.\n",pcVar6);
          }
          HTInitInput(s);
          if (proxycmd[0] != '\0') {
            sVar7 = strlen(proxycmd);
            status = write(s,proxycmd,sVar7);
            if (WWW_TraceFlag != '\0') {
              pFVar4 = TraceFP();
              fprintf((FILE *)pFVar4,"HTNews: Proxy command returned status \'%d\'.\n",status);
            }
          }
          status = response((char *)0x0);
          if (status - 200U < 100) {
            if (status != 200) {
              HTCanPost = 0;
              if ((((post_wanted == '\0') && (reply_wanted == '\0')) && (spost_wanted == '\0')) &&
                 (sreply_wanted == '\0')) goto LAB_0813bd99;
              pcVar6 = (char *)gettext("Cannot POST to this host.");
              HTAlert(pcVar6);
              if (NewsHREF != (char *)0x0) {
                free(NewsHREF);
                NewsHREF = (char *)0x0;
              }
              if (ProxyHREF != (char *)0x0) {
                HTSACopy(&NewsHost,ProxyHost);
                if (ProxyHost != (char *)0x0) {
                  free(ProxyHost);
                  ProxyHost = (char *)0x0;
                }
                if (ProxyHREF != (char *)0x0) {
                  free(ProxyHREF);
                  ProxyHREF = (char *)0x0;
                }
              }
              if (ListArg != (char *)0x0) {
                free(ListArg);
                ListArg = (char *)0x0;
              }
              if ((postfile != (char *)0x0) && (remove(postfile), postfile != (char *)0x0)) {
                free(postfile);
              }
              local_4c4 = -29999;
              goto LAB_0813c941;
            }
            HTCanPost = 1;
            goto LAB_0813bd99;
          }
          close(s);
          s = -1;
          if (status == -0x752e) {
            mustshow = '\x01';
            pcVar6 = (char *)gettext("Connection interrupted.");
            HTProgress(pcVar6);
            if (((post_wanted == '\0') && (reply_wanted == '\0')) &&
               ((spost_wanted == '\0' && (sreply_wanted == '\0')))) {
              if (rawtext == '\0') {
                (*targetClass._abort)(target,(HTError)0x0);
              }
              else {
                (*rawtargetClass._abort)(rawtarget,(HTError)0x0);
              }
            }
            if (NewsHost != (char *)0x0) {
              free(NewsHost);
              NewsHost = (char *)0x0;
            }
            if (NewsHREF != (char *)0x0) {
              free(NewsHREF);
              NewsHREF = (char *)0x0;
            }
            if (ProxyHost != (char *)0x0) {
              free(ProxyHost);
              ProxyHost = (char *)0x0;
            }
            if (ProxyHREF != (char *)0x0) {
              free(ProxyHREF);
              ProxyHREF = (char *)0x0;
            }
            if (ListArg != (char *)0x0) {
              free(ListArg);
              ListArg = (char *)0x0;
            }
            if ((postfile != (char *)0x0) && (remove(postfile), postfile != (char *)0x0)) {
              free(postfile);
            }
            local_4c4 = -29999;
            goto LAB_0813c941;
          }
          if (0 < retries) {
            if (ProxyHost != (char *)0x0) {
              free(ProxyHost);
              ProxyHost = (char *)0x0;
            }
            if (ProxyHREF != (char *)0x0) {
              free(ProxyHREF);
              ProxyHREF = (char *)0x0;
            }
            if (ListArg != (char *)0x0) {
              free(ListArg);
              ListArg = (char *)0x0;
            }
            if (postfile != (char *)0x0) {
              free(postfile);
            }
            if ((((post_wanted == '\0') && (reply_wanted == '\0')) && (spost_wanted == '\0')) &&
               (sreply_wanted == '\0')) {
              if (rawtext == '\0') {
                (*targetClass._abort)(target,(HTError)0x0);
              }
              else {
                (*rawtargetClass._abort)(rawtarget,(HTError)0x0);
              }
            }
            pcVar6 = NewsHost;
            if (response_text[0] == '\0') {
              pcVar11 = (char *)gettext("Can\'t read news info, empty response from host %s");
              HTSprintf0(&dbuf,pcVar11,pcVar6);
            }
            else {
              pcVar11 = (char *)gettext("Can\'t read news info.  News host %.20s responded: %.200s")
              ;
              HTSprintf0(&dbuf,pcVar11,pcVar6,response_text);
            }
            local_4c4 = HTLoadError((HTStream_conflict *)stream,500,dbuf);
            goto LAB_0813c941;
          }
        }
LAB_0813c7e4:
        retries = retries + 1;
        goto LAB_0813c7eb;
      }
      if (NewsHREF != (char *)0x0) {
        free(NewsHREF);
        NewsHREF = (char *)0x0;
      }
      if (ProxyHost != (char *)0x0) {
        free(ProxyHost);
        ProxyHost = (char *)0x0;
      }
      if (ProxyHREF != (char *)0x0) {
        free(ProxyHREF);
        ProxyHREF = (char *)0x0;
      }
      if (ListArg != (char *)0x0) {
        free(ListArg);
        ListArg = (char *)0x0;
      }
      local_4c4 = 0;
    }
  }
  goto LAB_0813c941;
LAB_0813c7f8:
  if (((post_wanted == '\0') && (reply_wanted == '\0')) &&
     ((spost_wanted == '\0' && (sreply_wanted == '\0')))) {
    if (rawtext == '\0') {
      (*targetClass._abort)(target,(HTError)0x0);
    }
    else {
      (*rawtargetClass._abort)(rawtarget,(HTError)0x0);
    }
  }
  if (NewsHREF != (char *)0x0) {
    free(NewsHREF);
    NewsHREF = (char *)0x0;
  }
  if (ProxyHREF != (char *)0x0) {
    HTSACopy(&NewsHost,ProxyHost);
    if (ProxyHost != (char *)0x0) {
      free(ProxyHost);
      ProxyHost = (char *)0x0;
    }
    if (ProxyHREF != (char *)0x0) {
      free(ProxyHREF);
      ProxyHREF = (char *)0x0;
    }
  }
  if (ListArg != (char *)0x0) {
    free(ListArg);
    ListArg = (char *)0x0;
  }
  if ((postfile != (char *)0x0) && (remove(postfile), postfile != (char *)0x0)) {
    free(postfile);
  }
  local_4c4 = -29999;
LAB_0813c941:
  if (local_c == *(int *)(in_GS_OFFSET + 0x14)) {
    return local_4c4;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void HTClearNNTPAuthInfo(void)

{
  free_NNTP_AuthInfo();
  return;
}



// WARNING: Unknown calling convention

void init_acceptable(void)

{
  char *good;
  uint i;
  
  good = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789./-_$";
  for (i = 0; i < 0x100; i = i + 1) {
    acceptable[i] = '\0';
  }
  for (; *good != '\0'; good = good + 1) {
    acceptable[*good] = '\x01';
  }
  acceptable_inited = '\x01';
  return;
}



char from_hex(char c)

{
  char local_b;
  char local_a;
  char local_9;
  char c_local;
  
  if ((c < '0') || ('9' < c)) {
    if ((c < 'A') || ('F' < c)) {
      if ((c < 'a') || ('f' < c)) {
        local_9 = '\0';
      }
      else {
        local_9 = c + -0x57;
      }
      local_a = local_9;
    }
    else {
      local_a = c + -0x37;
    }
    local_b = local_a;
  }
  else {
    local_b = c + -0x30;
  }
  return local_b;
}



void write_anchor(char *text,char *addr)

{
  int iVar1;
  FILE *__stream;
  int in_GS_OFFSET;
  char *addr_local;
  char *text_local;
  char *value [25];
  int i;
  BOOLEAN present [25];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  for (i = 0; i < 0x19; i = i + 1) {
    present[i] = '\0';
  }
  present[6] = '\x01';
  value[6] = addr;
  present[22] = '\x01';
  value[22] = text;
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"HTGopher: adding URL: %s\n",addr);
  }
  HT_Is_Gopher_URL = '\x01';
  (*targetClass.start_element)(target,0,present,value,-1,(char **)0x0);
  (*targetClass.put_string)(target,text);
  (*targetClass.end_element)(target,0,(char **)0x0);
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void parse_menu(char *arg,HTParentAnchor *anAnchor)

{
  _func_void_HTStructured_ptr_char_ptr_conflict *p_Var1;
  FILE *pFVar2;
  char *__format;
  int iVar3;
  int in_GS_OFFSET;
  char *pcVar4;
  char *local_4d4;
  HTParentAnchor *anAnchor_local;
  char *arg_local;
  char *r;
  char *format;
  char *address;
  int i;
  char *junk;
  int BytesReported;
  int bytes;
  char *title;
  char *p;
  char *port;
  char *host;
  char *selector;
  char *name;
  int ich;
  char gtype;
  char line [1024];
  char buffer [128];
  int local_c;
  
  local_c = *(int *)(in_GS_OFFSET + 0x14);
  name = (char *)0x0;
  selector = (char *)0x0;
  host = (char *)0x0;
  p = line;
  bytes = 0;
  BytesReported = 0;
  (*targetClass.start_element)(target,0x37,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
  (*targetClass.put_character)(target,'\n');
  (*targetClass.start_element)(target,0x35,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
  (*targetClass.put_character)(target,'\n');
  (*targetClass.start_element)(target,0x6e,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
  title = HTAnchor_title(anAnchor);
  p_Var1 = targetClass.put_string;
  if (title == (char *)0x0) {
    pcVar4 = (char *)gettext("Gopher Menu");
    (*p_Var1)(target,pcVar4);
  }
  else {
    (*targetClass.put_string)(target,title);
  }
  (*targetClass.end_element)(target,0x6e,(char **)0x0);
  (*targetClass.put_character)(target,'\n');
  (*targetClass.end_element)(target,0x35,(char **)0x0);
  (*targetClass.put_character)(target,'\n');
  (*targetClass.start_element)(target,0x11,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
  (*targetClass.put_character)(target,'\n');
  (*targetClass.start_element)(target,0x2f,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
  title = HTAnchor_title(anAnchor);
  p_Var1 = targetClass.put_string;
  if (title == (char *)0x0) {
    pcVar4 = (char *)gettext("Gopher Menu");
    (*p_Var1)(target,pcVar4);
  }
  else {
    (*targetClass.put_string)(target,title);
  }
  (*targetClass.end_element)(target,0x2f,(char **)0x0);
  (*targetClass.put_character)(target,'\n');
  pcVar4 = (char *)0xffffffff;
  (*targetClass.start_element)(target,0x56,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
  (*targetClass.put_character)(target,'\n');
  do {
    ich = HTGetCharacter();
    if (ich == -1) {
end_html:
      (*targetClass.end_element)(target,0x56,(char **)0x0);
      (*targetClass.put_character)(target,'\n');
      (*targetClass.end_element)(target,0x11,(char **)0x0);
      (*targetClass.put_character)(target,'\n');
      (*targetClass.end_element)(target,0x37,(char **)0x0);
      (*targetClass.put_character)(target,'\n');
      (*targetClass._free)(target);
      if (local_c != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
        __stack_chk_fail();
      }
      return;
    }
    if (interrupted_in_htgetcharacter != 0) {
      if (WWW_TraceFlag != '\0') {
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2,"HTGopher: Interrupted in HTGetCharacter, apparently.\n");
      }
      goto end_html;
    }
    if ((char)ich == '\n') {
      *p = '\0';
      bytes = (int)(p + bytes + (1 - (int)line));
      p = line;
      port = (char *)0x0;
      if (WWW_TraceFlag != '\0') {
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2,"HTGopher: Menu item: %s\n",line);
      }
      gtype = *p;
      p = p + 1;
      if (BytesReported + 0x400 < bytes) {
        __format = (char *)gettext("Transferred %d bytes");
        sprintf(buffer,__format,bytes);
        HTProgress(buffer);
        BytesReported = bytes;
      }
      if ((gtype == '.') && ((*p == '\r' || (*p == '\0')))) goto end_html;
      if ((gtype != '\0') && (*p != '\0')) {
        name = p;
        selector = strchr(p,9);
        if (selector != (char *)0x0) {
          *selector = '\0';
          selector = selector + 1;
          if ((gtype == '0') && ((*selector == '9' || (*selector == '5')))) {
            gtype = *selector;
          }
          host = strchr(selector,9);
          if (host != (char *)0x0) {
            *host = '\0';
            host = host + 1;
            port = strchr(host,9);
            if (port != (char *)0x0) {
              *port = ':';
              junk = strchr(port,9);
              if (junk != (char *)0x0) {
                *junk = '\0';
                junk = junk + 1;
              }
              if ((port[1] == '0') && (port[2] == '\0')) {
                *port = '\0';
              }
            }
          }
        }
      }
      if (gtype == '0') {
        i = strlen(name);
        while ((i = i - 1, name[i] == ' ' && (-1 < i))) {
          name[i] = '\0';
        }
        if (i < 0) {
          gtype = 'i';
        }
      }
      if (gtype == 'w') {
        (*targetClass.put_string)(target,"(HTML) ");
        write_anchor(name,selector);
      }
      else if (gtype == 'i') {
        (*targetClass.put_string)(target,"       ");
        (*targetClass.put_string)(target,name);
      }
      else if (port == (char *)0x0) {
        if (WWW_TraceFlag != '\0') {
          pFVar2 = TraceFP();
          fprintf((FILE *)pFVar2,"HTGopher: Bad menu item.\n");
        }
        (*targetClass.put_string)(target,line);
      }
      else {
        address = (char *)0x0;
        if (*selector == '\0') {
          local_4d4 = "%s//%s/";
        }
        else {
          local_4d4 = "%s//%s@%s/";
        }
        if (gtype == '8') {
          (*targetClass.put_string)(target," (TEL) ");
          pcVar4 = host;
          HTSprintf0(&address,local_4d4,"telnet:",selector);
        }
        else if (gtype == 'T') {
          (*targetClass.put_string)(target,"(3270) ");
          pcVar4 = host;
          HTSprintf0(&address,local_4d4,"tn3270:",selector);
        }
        else {
          switch(gtype) {
          case '0':
            (*targetClass.put_string)(target,"(FILE) ");
            break;
          case '1':
            (*targetClass.put_string)(target," (DIR) ");
            break;
          case '2':
            (*targetClass.put_string)(target," (CSO) ");
            break;
          default:
            (*targetClass.put_string)(target,"(UNKN) ");
            break;
          case '4':
            (*targetClass.put_string)(target," (HQX) ");
            break;
          case '5':
            (*targetClass.put_string)(target," (BIN) ");
            break;
          case '6':
            (*targetClass.put_string)(target," (UUE) ");
            break;
          case '7':
            (*targetClass.put_string)(target,"  (?)  ");
            break;
          case '9':
            (*targetClass.put_string)(target," (BIN) ");
            break;
          case ':':
          case 'I':
          case 'g':
            (*targetClass.put_string)(target," (IMG) ");
            break;
          case ';':
            (*targetClass.put_string)(target," (MOV) ");
            break;
          case '<':
          case 's':
            (*targetClass.put_string)(target," (SND) ");
            break;
          case 'H':
          case 'h':
            (*targetClass.put_string)(target,"(HTML) ");
            break;
          case 'P':
            (*targetClass.put_string)(target," (PDF) ");
            break;
          case 'm':
            (*targetClass.put_string)(target,"(MIME) ");
          }
          iVar3 = (int)gtype;
          HTSprintf0(&address,"//%s/%c",host,iVar3);
          for (r = selector; *r != '\0'; r = r + 1) {
            if (acceptable[(byte)*r] == '\0') {
              pcVar4 = (char *)(int)"0123456789abcdef"[(int)*r & 0xf];
              iVar3 = (int)"0123456789abcdef"[*r >> 4];
              HTSprintf(&address,"%c%c%c",0x25,iVar3,pcVar4);
            }
            else {
              HTSprintf(&address,"%c",(int)*r,iVar3,pcVar4);
            }
          }
        }
        iVar3 = strcmp(address,"gopher://error.host:1/0");
        if (iVar3 == 0) {
          (*targetClass.put_string)(target,name);
        }
        else {
          write_anchor(name,address);
        }
        if (address != (char *)0x0) {
          free(address);
          address = (char *)0x0;
        }
      }
      (*targetClass.put_character)(target,'\n');
      p = line;
    }
    else {
      *p = (char)ich;
      if (p < line + 0x3ff) {
        p = p + 1;
      }
    }
  } while( true );
}



void parse_cso(char *arg,HTParentAnchor *anAnchor)

{
  _func_void_HTStructured_ptr_char_ptr_conflict *p_Var1;
  char *pcVar2;
  int iVar3;
  int in_GS_OFFSET;
  HTParentAnchor *anAnchor_local;
  char *arg_local;
  char *title;
  char *second_colon;
  char *first_colon;
  char *p;
  int ich;
  char last_char;
  char line [1024];
  int local_c;
  
  local_c = *(int *)(in_GS_OFFSET + 0x14);
  p = line;
  last_char = '\0';
  (*targetClass.start_element)(target,0x35,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
  (*targetClass.put_character)(target,'\n');
  (*targetClass.start_element)(target,0x6e,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
  pcVar2 = HTAnchor_title(anAnchor);
  p_Var1 = targetClass.put_string;
  if (pcVar2 == (char *)0x0) {
    pcVar2 = (char *)gettext("CSO Search Results");
    (*p_Var1)(target,pcVar2);
  }
  else {
    (*targetClass.put_string)(target,pcVar2);
  }
  (*targetClass.end_element)(target,0x6e,(char **)0x0);
  (*targetClass.put_character)(target,'\n');
  (*targetClass.end_element)(target,0x35,(char **)0x0);
  (*targetClass.put_character)(target,'\n');
  (*targetClass.start_element)(target,0x2f,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
  pcVar2 = HTAnchor_title(anAnchor);
  if (pcVar2 == (char *)0x0) {
    (*targetClass.put_string)(target,arg);
    p_Var1 = targetClass.put_string;
    pcVar2 = (char *)gettext(" Search Results");
    (*p_Var1)(target,pcVar2);
  }
  else {
    (*targetClass.put_string)(target,pcVar2);
  }
  (*targetClass.end_element)(target,0x2f,(char **)0x0);
  (*targetClass.put_character)(target,'\n');
  (*targetClass.start_element)(target,0x56,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
LAB_0813dd1a:
  do {
    iVar3 = HTGetCharacter();
    if (iVar3 == -1) {
LAB_0813dd32:
      (*targetClass.put_character)(target,'\n');
      (*targetClass.end_element)(target,0x56,(char **)0x0);
      (*targetClass.put_character)(target,'\n');
      (*targetClass._free)(target);
      if (local_c != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
        __stack_chk_fail();
      }
      return;
    }
    if ((char)iVar3 != '\n') {
      *p = (char)iVar3;
      if (p < line + 0x3ff) {
        p = p + 1;
      }
      goto LAB_0813dd1a;
    }
    *p = '\0';
    p = line;
    if (line[0] == '2') goto LAB_0813dd32;
    if (line[0] == '5') {
      (*targetClass.start_element)(target,0x30,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
      (*targetClass.put_string)(target,line + 4);
      (*targetClass.end_element)(target,0x30,(char **)0x0);
      goto LAB_0813dd32;
    }
    if (line[0] == '-') {
      second_colon = (char *)0x0;
      pcVar2 = strchr(p,0x3a);
      if (pcVar2 != (char *)0x0) {
        second_colon = strchr(pcVar2 + 1,0x3a);
      }
      if (second_colon != (char *)0x0) {
        if (second_colon[-1] != last_char) {
          (*targetClass.end_element)(target,0x56,(char **)0x0);
          (*targetClass.start_element)(target,0x30,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
        }
        (*targetClass.put_string)(target,second_colon + 1);
        (*targetClass.put_character)(target,'\n');
        if (second_colon[-1] != last_char) {
          (*targetClass.end_element)(target,0x30,(char **)0x0);
          (*targetClass.start_element)(target,0x56,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
        }
        last_char = second_colon[-1];
      }
    }
  } while( true );
}



// WARNING: Unknown calling convention

void display_cso(char *arg,HTParentAnchor *anAnchor)

{
  _func_void_HTStructured_ptr_char_ptr_conflict *p_Var1;
  char *pcVar2;
  char *title;
  
  (*targetClass.start_element)(target,0x35,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
  (*targetClass.put_character)(target,'\n');
  (*targetClass.start_element)(target,0x6e,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
  pcVar2 = HTAnchor_title(anAnchor);
  p_Var1 = targetClass.put_string;
  if (pcVar2 == (char *)0x0) {
    pcVar2 = (char *)gettext("CSO index");
    (*p_Var1)(target,pcVar2);
  }
  else {
    (*targetClass.put_string)(target,pcVar2);
  }
  (*targetClass.end_element)(target,0x6e,(char **)0x0);
  (*targetClass.put_character)(target,'\n');
  (*targetClass.start_element)(target,0x3e,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
  (*targetClass.put_character)(target,'\n');
  (*targetClass.end_element)(target,0x35,(char **)0x0);
  (*targetClass.put_character)(target,'\n');
  (*targetClass.start_element)(target,0x2f,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
  pcVar2 = HTAnchor_title(anAnchor);
  if (pcVar2 == (char *)0x0) {
    (*targetClass.put_string)(target,arg);
    p_Var1 = targetClass.put_string;
    pcVar2 = (char *)gettext(" index");
    (*p_Var1)(target,pcVar2);
  }
  else {
    (*targetClass.put_string)(target,pcVar2);
  }
  (*targetClass.end_element)(target,0x2f,(char **)0x0);
  p_Var1 = targetClass.put_string;
  pcVar2 = (char *)gettext("\nThis is a searchable index of a CSO database.\n");
  (*p_Var1)(target,pcVar2);
  (*targetClass.start_element)(target,0x53,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
  p_Var1 = targetClass.put_string;
  pcVar2 = (char *)gettext("\nPress the \'s\' key and enter search keywords.\n");
  (*p_Var1)(target,pcVar2);
  (*targetClass.start_element)(target,0x53,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
  p_Var1 = targetClass.put_string;
  pcVar2 = (char *)gettext("\nThe keywords that you enter will allow you to search on a");
  (*p_Var1)(target,pcVar2);
  p_Var1 = targetClass.put_string;
  pcVar2 = (char *)gettext(" person\'s name in the database.\n");
  (*p_Var1)(target,pcVar2);
  pcVar2 = HTAnchor_title(anAnchor);
  if (pcVar2 == (char *)0x0) {
    HTAnchor_setTitle(anAnchor,arg);
  }
  (*targetClass._free)(target);
  return;
}



// WARNING: Unknown calling convention

void display_index(char *arg,HTParentAnchor *anAnchor)

{
  _func_void_HTStructured_ptr_char_ptr_conflict *p_Var1;
  char *pcVar2;
  char *title;
  
  (*targetClass.start_element)(target,0x35,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
  (*targetClass.put_character)(target,'\n');
  (*targetClass.put_character)(target,'\n');
  (*targetClass.start_element)(target,0x6e,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
  pcVar2 = HTAnchor_title(anAnchor);
  p_Var1 = targetClass.put_string;
  if (pcVar2 == (char *)0x0) {
    pcVar2 = (char *)gettext("Gopher index");
    (*p_Var1)(target,pcVar2);
  }
  else {
    (*targetClass.put_string)(target,pcVar2);
  }
  (*targetClass.end_element)(target,0x6e,(char **)0x0);
  (*targetClass.put_character)(target,'\n');
  (*targetClass.start_element)(target,0x3e,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
  (*targetClass.put_character)(target,'\n');
  (*targetClass.end_element)(target,0x35,(char **)0x0);
  (*targetClass.put_character)(target,'\n');
  (*targetClass.start_element)(target,0x2f,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
  pcVar2 = HTAnchor_title(anAnchor);
  if (pcVar2 == (char *)0x0) {
    (*targetClass.put_string)(target,arg);
    p_Var1 = targetClass.put_string;
    pcVar2 = (char *)gettext(" index");
    (*p_Var1)(target,pcVar2);
  }
  else {
    (*targetClass.put_string)(target,pcVar2);
  }
  (*targetClass.end_element)(target,0x2f,(char **)0x0);
  p_Var1 = targetClass.put_string;
  pcVar2 = (char *)gettext("\nThis is a searchable Gopher index.\n");
  (*p_Var1)(target,pcVar2);
  (*targetClass.start_element)(target,0x53,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
  p_Var1 = targetClass.put_string;
  pcVar2 = (char *)gettext("\nPlease enter search keywords.\n");
  (*p_Var1)(target,pcVar2);
  pcVar2 = HTAnchor_title(anAnchor);
  if (pcVar2 == (char *)0x0) {
    HTAnchor_setTitle(anAnchor,arg);
  }
  (*targetClass._free)(target);
  return;
}



// WARNING: Unknown calling convention

void de_escape(char *command,char *selector)

{
  char *pcVar1;
  char cVar2;
  char cVar3;
  uint b;
  char *q;
  char *p;
  char c;
  
  p = selector;
  q = command;
  if (command == (char *)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTGopher.c","HTLoadGopher");
  }
  while (*p != '\0') {
    if (*p == '%') {
      pcVar1 = p + 2;
      cVar2 = from_hex(p[1]);
      p = p + 3;
      if (*pcVar1 == '\0') break;
      cVar3 = from_hex(*pcVar1);
      *q = (char)((int)cVar2 << 4) + cVar3;
      q = q + 1;
    }
    else {
      *q = *p;
      q = q + 1;
      p = p + 1;
    }
  }
  *q = '\0';
  return;
}



// WARNING: Unknown calling convention

void free_CSOfields(void)

{
  _CSOfield_info *p_Var1;
  CSOfield_info *prev;
  CSOfield_info *cur;
  
  cur = CSOfields;
  p_Var1 = cur;
  while (cur = p_Var1, cur != (CSOfield_info *)0x0) {
    if ((cur->name != cur->name_buf) && (cur->name != (char *)0x0)) {
      free(cur->name);
      cur->name = (char *)0x0;
    }
    if ((cur->attributes != cur->attr_buf) && (cur->attributes != (char *)0x0)) {
      free(cur->attributes);
      cur->attributes = (char *)0x0;
    }
    if ((cur->description != cur->desc_buf) && (cur->description != (char *)0x0)) {
      free(cur->description);
      cur->description = (char *)0x0;
    }
    p_Var1 = cur->next;
    if (cur != (CSOfield_info *)0x0) {
      free(cur);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void interpret_cso_key(char *key,char *buf,int *length,CSOformgen_context *ctx,HTStream *Target)

{
  CSOfield_info *pCVar1;
  _func_void_HTStream_ptr_char_ptr_wchar_t *p_Var2;
  bool bVar3;
  int iVar4;
  size_t sVar5;
  wchar_t wVar6;
  char *local_30;
  char *local_2c;
  int local_24;
  int local_1c;
  size_t out;
  int error;
  CSOfield_info *fld;
  
  pCVar1 = ctx->fld;
  if (pCVar1 != (CSOfield_info *)0x0) {
    bVar3 = false;
    iVar4 = strncmp(key,"$(FID)",6);
    if (iVar4 == 0) {
      sprintf(buf,"%d",pCVar1->id);
    }
    else {
      iVar4 = strncmp(key,"$(FDESC)",8);
      if (iVar4 == 0) {
        sprintf(buf,"%.2046s",pCVar1->description);
      }
      else {
        iVar4 = strncmp(key,"$(FDEF)",7);
        if (iVar4 == 0) {
          if (pCVar1->defreturn == 0) {
            local_30 = "";
          }
          else {
            local_30 = " checked";
          }
          strcpy(buf,local_30);
        }
        else {
          iVar4 = strncmp(key,"$(FNDX)",7);
          if (iVar4 == 0) {
            if (pCVar1->indexed == 0) {
              local_2c = "";
            }
            else {
              local_2c = "*";
            }
            strcpy(buf,local_2c);
          }
          else {
            iVar4 = strncmp(key,"$(FSIZE)",8);
            if (iVar4 == 0) {
              local_24 = pCVar1->max_size;
              if (0x37 < local_24) {
                local_24 = 0x37;
              }
              sprintf(buf," size=%d maxlength=%d",local_24,pCVar1->max_size);
            }
            else {
              iVar4 = strncmp(key,"$(FSIZE2)",9);
              if (iVar4 == 0) {
                sprintf(buf," maxlength=%d",pCVar1->max_size);
              }
              else {
                bVar3 = true;
              }
            }
          }
        }
      }
    }
    if (!bVar3) {
      sVar5 = strlen(buf);
      *length = sVar5;
      return;
    }
  }
  *buf = '\0';
  iVar4 = strncmp(key,"$(NEXTFLD)",10);
  if (iVar4 == 0) {
    if (ctx->fld == (CSOfield_info *)0x0) {
      fld = CSOfields;
    }
    else {
      fld = ctx->fld->next;
    }
    iVar4 = ctx->field_select;
    if (iVar4 == 1) {
      for (; (fld != (CSOfield_info *)0x0 && (fld->lookup != 1)); fld = fld->next) {
      }
    }
    else if (iVar4 == 2) {
      for (; (fld != (CSOfield_info *)0x0 && (fld->gpublic == 0)); fld = fld->next) {
      }
    }
    else if (iVar4 == 0) {
      for (; (fld != (CSOfield_info *)0x0 && ((fld->gpublic == 0 || (fld->lookup != 1))));
          fld = fld->next) {
      }
    }
    if (fld != (CSOfield_info *)0x0) {
      ctx->cur_line = ctx->rep_line;
      ctx->cur_off = ctx->rep_off;
    }
    ctx->fld = fld;
  }
  else {
    iVar4 = strncmp(key,"$(QFIELDS)",10);
    if ((iVar4 == 0) || (iVar4 = strncmp(key,"$(RFIELDS)",10), iVar4 == 0)) {
      ctx->rep_line = ctx->cur_line;
      ctx->rep_off = ctx->cur_off;
      ctx->fld = (CSOfield_info *)0x0;
      ctx->seek = "$(NEXTFLD)";
      if (key[2] == 'Q') {
        local_1c = 0;
      }
      else {
        local_1c = 2;
      }
      ctx->field_select = local_1c;
      if (ctx->public_override != 0) {
        ctx->field_select = ctx->field_select + 1;
      }
    }
    else {
      iVar4 = strncmp(key,"$(NAMEFLD)",10);
      if (iVar4 == 0) {
        for (fld = CSOfields; fld != (CSOfield_info *)0x0; fld = fld->next) {
          iVar4 = strcmp(fld->name,"name");
          if ((iVar4 == 0) || (iVar4 = strcmp(fld->name,"Name"), iVar4 == 0)) {
            if (fld->lookup != 0) {
              fld->lookup = 2;
            }
            break;
          }
        }
        ctx->fld = fld;
      }
      else {
        iVar4 = strncmp(key,"$(HOST)",7);
        if (iVar4 == 0) {
          strcpy(buf,ctx->host);
        }
        else {
          iVar4 = strncmp(key,"$(PORT)",7);
          if (iVar4 != 0) {
            out = 0;
            while ((*key != '\0' && (*key != ')'))) {
              buf[out] = *key;
              out = out + 1;
              key = key + 1;
              if (2 < out) {
                buf[out] = '\0';
                p_Var2 = Target->isa->put_block;
                wVar6 = strlen(buf);
                (*p_Var2)(Target,buf,wVar6);
                out = 0;
              }
            }
            buf[out] = ')';
            buf[out + 1] = '\0';
            sVar5 = strlen(buf);
            *length = sVar5;
            return;
          }
          sprintf(buf,"%d",ctx->port);
        }
      }
    }
  }
  sVar5 = strlen(buf);
  *length = sVar5;
  return;
}



// WARNING: Unknown calling convention

int parse_cso_field_info(CSOfield_info *blk)

{
  char *pcVar1;
  char *pcVar2;
  char *max_spec;
  char *info;
  
  blk->url = 0;
  blk->max_size = blk->url;
  blk->reserved = blk->max_size;
  blk->lookup = blk->reserved;
  blk->indexed = blk->lookup;
  blk->gpublic = 0;
  blk->explicit_return = blk->gpublic;
  blk->defreturn = blk->explicit_return;
  pcVar2 = blk->attributes;
  LYLowerCase(pcVar2);
  pcVar1 = strstr(pcVar2,"indexed ");
  if (pcVar1 != (char *)0x0) {
    blk->indexed = 1;
  }
  pcVar1 = strstr(pcVar2,"default ");
  if (pcVar1 != (char *)0x0) {
    blk->defreturn = 1;
  }
  pcVar1 = strstr(pcVar2,"public ");
  if (pcVar1 != (char *)0x0) {
    blk->gpublic = 1;
  }
  pcVar1 = strstr(pcVar2,"lookup ");
  if (pcVar1 != (char *)0x0) {
    blk->lookup = 1;
  }
  pcVar1 = strstr(pcVar2,"url ");
  if (pcVar1 != (char *)0x0) {
    blk->url = 1;
    blk->defreturn = 1;
  }
  pcVar2 = strstr(pcVar2,"max ");
  if (pcVar2 == (char *)0x0) {
    blk->max_size = 0x20;
  }
  else {
    sscanf(pcVar2 + 4,"%d",&blk->max_size);
  }
  return 0;
}



// WARNING: Unknown calling convention

int parse_cso_fields(char *buf,int size)

{
  CSOfield_info *pCVar1;
  FILE *__stream;
  size_t sVar2;
  char *pcVar3;
  CSOfield_info *blk;
  int iVar4;
  int local_38;
  CSOfield_info *newf;
  CSOfield_info *last;
  char *name;
  char *indx;
  size_t alen;
  int prev_code;
  int code;
  int i;
  char *p;
  int ich;
  
  p = buf;
  code = 0;
  CSOfields = (CSOfield_info *)0x0;
  last = (CSOfield_info *)0x0;
  prev_code = -0x9fb;
  *buf = '\0';
  while (iVar4 = HTGetCharacter(), iVar4 != -1) {
    if (interrupted_in_htgetcharacter != 0) {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"HTLoadCSO: Interrupted in HTGetCharacter, apparently.\n");
      }
      free_CSOfields();
      *buf = '\0';
      return -0x752e;
    }
    if ((char)iVar4 == '\n') {
      *p = '\0';
      p = buf;
      if (*buf == '2') break;
      if (*buf == '5') {
        strcpy(buf,buf);
        return 5;
      }
      if ((*buf == '-') && (buf[1] == '2')) {
        indx = (char *)0x0;
        name = (char *)0x0;
        for (i = 0; buf[i] != '\0'; i = i + 1) {
          if (buf[i] == ':') {
            buf[i] = '\0';
            if (indx == (char *)0x0) {
              indx = buf + i + 1;
              code = atoi(indx);
            }
            else {
              if (name != (char *)0x0) {
                i = i + 1;
                break;
              }
              name = buf + i + 1;
            }
          }
        }
        if (name == (char *)0x0) break;
        if (code == prev_code) {
          sVar2 = strlen(buf + i);
          if (0x20 < sVar2 + 1) {
            if ((last->description != last->desc_buf) && (last->description != (char *)0x0)) {
              free(last->description);
              last->description = (char *)0x0;
            }
            pcVar3 = (char *)malloc(sVar2 + 1);
            last->description = pcVar3;
            if (last->description == (char *)0x0) {
              outofmem("../../../WWW/Library/Implementation/HTGopher.c","HTLoadCSO");
            }
          }
          strcpy(last->description,buf + i);
        }
        else {
          blk = (CSOfield_info *)calloc(1,0xb4);
          if (blk == (CSOfield_info *)0x0) {
            outofmem("../../../WWW/Library/Implementation/HTGopher.c","HTLoadCSO");
          }
          pCVar1 = blk;
          if (last != (CSOfield_info *)0x0) {
            last->next = blk;
            pCVar1 = CSOfields;
          }
          CSOfields = pCVar1;
          blk->next = (_CSOfield_info *)0x0;
          blk->name = blk->name_buf;
          sVar2 = strlen(name);
          if (0x10 < sVar2 + 1) {
            pcVar3 = (char *)malloc(sVar2 + 1);
            blk->name = pcVar3;
            if (blk->name == (char *)0x0) {
              outofmem("../../../WWW/Library/Implementation/HTGopher.c","HTLoadCSO");
            }
          }
          strcpy(blk->name,name);
          blk->attributes = blk->attr_buf;
          sVar2 = strlen(buf + i);
          if (0x50 < sVar2 + 2) {
            pcVar3 = (char *)malloc(sVar2 + 2);
            blk->attributes = pcVar3;
            if (blk->attributes == (char *)0x0) {
              outofmem("../../../WWW/Library/Implementation/HTGopher.c","HTLoadCSO");
            }
          }
          strcpy(blk->attributes,buf + i);
          memcpy(blk->attributes + sVar2,&DAT_0818fb91,2);
          blk->description = blk->desc_buf;
          blk->desc_buf[0] = '\0';
          iVar4 = atoi(indx);
          blk->id = iVar4;
          parse_cso_field_info(blk);
          last = blk;
        }
        prev_code = code;
      }
    }
    else {
      *p = (char)iVar4;
      if (p < buf + size + -1) {
        p = p + 1;
      }
    }
  }
  if (*buf == '\0') {
    local_38 = -1;
  }
  else {
    *buf = '\0';
    local_38 = 0;
  }
  return local_38;
}



// WARNING: Unknown calling convention

int generate_cso_form(char *host,int port,char *buf,HTStream *Target)

{
  _func_void_HTStream_ptr_char_ptr_wchar_t *p_Var1;
  char *pcVar2;
  int iVar3;
  char *fmt;
  wchar_t wVar4;
  CSOformgen_context ctx;
  char *temp;
  int slen;
  char *line;
  char *key;
  int full_flag;
  size_t out;
  int length;
  int j;
  int i;
  
  full_flag = 1;
  out = 0;
  memset(&ctx,0,0x28);
  ctx.host = host;
  ctx.seek = (char *)0x0;
  ctx.port = port;
  ctx.fld = (CSOfield_info *)0x0;
  ctx.public_override = full_flag;
  out = 0;
  *buf = '\0';
  i = 0;
  do {
    if (generate_cso_form::ctemplate[i] == (char *)0x0) {
      if (out != 0) {
        p_Var1 = Target->isa->put_block;
        wVar4 = strlen(buf);
        (*p_Var1)(Target,buf,wVar4);
      }
      return 0;
    }
    line = generate_cso_form::ctemplate[i];
    for (j = 0; line[j] != '\0'; j = j + 1) {
      if ((line[j] == '$') && (line[j + 1] == '(')) {
        buf[out] = '\0';
        if (out != 0) {
          p_Var1 = Target->isa->put_block;
          wVar4 = strlen(buf);
          (*p_Var1)(Target,buf,wVar4);
        }
        out = 0;
        key = line + j;
        for (; (line[j + 1] != '\0' && (line[j] != ')')); j = j + 1) {
        }
        ctx.cur_line = i;
        ctx.cur_off = j;
        interpret_cso_key(key,buf,&length,&ctx,Target);
        i = ctx.cur_line;
        j = ctx.cur_off;
        line = generate_cso_form::ctemplate[ctx.cur_line];
        out = length;
        if (ctx.seek != (char *)0x0) {
          slen = strlen(ctx.seek);
          for (; generate_cso_form::ctemplate[i] != (char *)0x0; i = i + 1) {
            line = generate_cso_form::ctemplate[i];
            for (; line[j] != '\0'; j = j + 1) {
              if ((line[j] == '$') && (iVar3 = strncmp(ctx.seek,line + j,slen), iVar3 == 0)) {
                if (j == 0) {
                  i = i + -1;
                  j = strlen(generate_cso_form::ctemplate[i]);
                }
                j = j - 1;
                line = generate_cso_form::ctemplate[i];
                ctx.seek = (char *)0x0;
                break;
              }
            }
            if (ctx.seek == (char *)0x0) break;
            j = 0;
          }
          pcVar2 = ctx.seek;
          if (ctx.seek != (char *)0x0) {
            temp = (char *)0x0;
            fmt = (char *)gettext("Seek fail on %s\n");
            HTSprintf0(&temp,fmt,pcVar2);
            p_Var1 = Target->isa->put_block;
            wVar4 = strlen(temp);
            (*p_Var1)(Target,temp,wVar4);
            if (temp != (char *)0x0) {
              free(temp);
              temp = (char *)0x0;
            }
          }
        }
      }
      else {
        buf[out] = line[j];
        out = out + 1;
        if (1 < out) {
          buf[out] = '\0';
          p_Var1 = Target->isa->put_block;
          wVar4 = strlen(buf);
          (*p_Var1)(Target,buf,wVar4);
          out = 0;
        }
      }
    }
    buf[out] = '\n';
    out = out + 1;
    buf[out] = '\0';
    i = i + 1;
  } while( true );
}



int generate_cso_report(HTStream *Target)

{
  char cVar1;
  _func_void_HTStream_ptr_char_ptr_wchar_t *p_Var2;
  FILE *__stream;
  char *pcVar3;
  size_t sVar4;
  int iVar5;
  wchar_t wVar6;
  int in_GS_OFFSET;
  char *local_454;
  char *local_450;
  HTStream *Target_local;
  CSOfield_info *fld;
  char *l;
  char *fvalue;
  char *fname;
  char *ndx_str;
  char *rcode;
  int ndx;
  int prev_ndx;
  int i;
  int len;
  char *href;
  char *p;
  char *buf;
  int ich;
  BOOLEAN stop;
  char line [1024];
  int local_c;
  
  local_c = *(int *)(in_GS_OFFSET + 0x14);
  buf = (char *)0x0;
  p = line;
  href = (char *)0x0;
  stop = '\0';
  prev_ndx = -100;
  while( true ) {
    if ((stop != '\0') || (ich = HTGetCharacter(), ich == -1)) goto end_CSOreport;
    if (interrupted_in_htgetcharacter != 0) break;
    if ((char)ich == '\n') {
      *p = '\0';
      p = line;
      if ((line[0] != '-') && (line[0] != '1')) {
        stop = '\x01';
      }
      local_454 = p;
      if (line[0] == '-') {
        local_454 = line + 1;
      }
      fname = (char *)0x0;
      ndx_str = (char *)0x0;
      sVar4 = strlen(p);
      for (i = 0; i < (int)sVar4; i = i + 1) {
        if (p[i] == ':') {
          p[i] = '\0';
          if (ndx_str != (char *)0x0) {
            fname = p + i + 1;
            break;
          }
          fname = p + i + 1;
          ndx_str = fname;
        }
      }
      if (ndx_str == (char *)0x0) {
        HTSprintf0(&buf,"<DD>%s\n",local_454);
        p_Var2 = Target->isa->put_block;
        wVar6 = strlen(buf);
        (*p_Var2)(Target,buf,wVar6);
      }
      else {
        iVar5 = atoi(ndx_str);
        if (prev_ndx != iVar5) {
          if (prev_ndx != -100) {
            HTSprintf0(&buf,"</DL></DL>\n");
            p_Var2 = Target->isa->put_block;
            wVar6 = strlen(buf);
            (*p_Var2)(Target,buf,wVar6);
          }
          prev_ndx = iVar5;
          if (iVar5 == 0) {
            HTSprintf0(&buf,"<HR><DL><DT>Information/status<DD><DL><DT>\n");
            p_Var2 = Target->isa->put_block;
            wVar6 = strlen(buf);
            (*p_Var2)(Target,buf,wVar6);
          }
          else {
            HTSprintf0(&buf,"<HR><DL><DT>Entry %d:<DD><DL COMPACT><DT>\n",iVar5);
            p_Var2 = Target->isa->put_block;
            wVar6 = strlen(buf);
            (*p_Var2)(Target,buf,wVar6);
          }
        }
        if (((*local_454 < '2') || ('5' < *local_454)) || (fname == ndx_str)) {
          if (fname == (char *)0x0) {
            local_450 = local_454;
          }
          else {
            local_450 = fname;
          }
          HTSprintf0(&buf,"<DD>%s\n",local_450);
          p_Var2 = Target->isa->put_block;
          wVar6 = strlen(buf);
          (*p_Var2)(Target,buf,wVar6);
        }
        else {
          for (; *fname == ' '; fname = fname + 1) {
          }
          fvalue = fname;
          while( true ) {
            if (*fvalue == '\0') goto LAB_0813f8a6;
            if (*fvalue == ':') break;
            fvalue = fvalue + 1;
          }
          *fvalue = '\0';
          fvalue = fvalue + 1;
          i = strlen(fname);
          while ((i = i - 1, -1 < i && (fname[i] == ' '))) {
            fname[i] = '\0';
          }
LAB_0813f8a6:
          if (fvalue != (char *)0x0) {
            for (; *fvalue == ' '; fvalue = fvalue + 1) {
            }
          }
          if (*fname == '\0') {
            HTSprintf0(&buf,"<DD>");
            p_Var2 = Target->isa->put_block;
            wVar6 = strlen(buf);
            (*p_Var2)(Target,buf,wVar6);
            *buf = '\0';
            l = fvalue;
            while (*l != '\0') {
              if (*l == '<') {
                HTSACat(&buf,"&lt;");
                l = l + 1;
              }
              else if (*l == '>') {
                HTSACat(&buf,"&gt;");
                l = l + 1;
              }
              else {
                iVar5 = strncmp(l,"news:",5);
                if (((((iVar5 == 0) || (iVar5 = strncmp(l,"snews://",8), iVar5 == 0)) ||
                     ((iVar5 = strncmp(l,"nntp://",7), iVar5 == 0 ||
                      ((((iVar5 = strncmp(l,"snewspost:",10), iVar5 == 0 ||
                         (iVar5 = strncmp(l,"snewsreply:",0xb), iVar5 == 0)) ||
                        (iVar5 = strncmp(l,"newspost:",9), iVar5 == 0)) ||
                       ((iVar5 = strncmp(l,"newsreply:",10), iVar5 == 0 ||
                        (iVar5 = strncmp(l,"ftp://",6), iVar5 == 0)))))))) ||
                    ((iVar5 = strncmp(l,"file:/",6), iVar5 == 0 ||
                     ((iVar5 = strncmp(l,"finger://",9), iVar5 == 0 ||
                      (iVar5 = strncmp(l,"http://",7), iVar5 == 0)))))) ||
                   (((iVar5 = strncmp(l,"https://",8), iVar5 == 0 ||
                     (((iVar5 = strncmp(l,"wais://",7), iVar5 == 0 ||
                       (iVar5 = strncmp(l,"mailto:",7), iVar5 == 0)) ||
                      (iVar5 = strncmp(l,"cso://",6), iVar5 == 0)))) ||
                    (iVar5 = strncmp(l,"gopher://",9), iVar5 == 0)))) {
                  HTSACat(&buf,"<a href=\"");
                  HTSACopy(&href,l);
                  pcVar3 = strtok(href," \r\n\t,>)\"");
                  HTSACat(&buf,pcVar3);
                  HTSACat(&buf,"\">");
                  while ((*l != '\0' &&
                         (pcVar3 = strchr(" \r\n\t,>)\"",(int)*l), pcVar3 == (char *)0x0))) {
                    cVar1 = *l;
                    l = l + 1;
                    HTSprintf(&buf,"%c",(int)cVar1);
                  }
                  HTSACat(&buf,"</a>");
                  if (href != (char *)0x0) {
                    free(href);
                    href = (char *)0x0;
                  }
                }
                else {
                  cVar1 = *l;
                  l = l + 1;
                  HTSprintf(&buf,"%c",(int)cVar1);
                }
              }
            }
            HTSACat(&buf,"\n");
            p_Var2 = Target->isa->put_block;
            wVar6 = strlen(buf);
            (*p_Var2)(Target,buf,wVar6);
          }
          else {
            for (fld = CSOfields; fld != (CSOfield_info *)0x0; fld = fld->next) {
              iVar5 = strcmp(fld->name,fname);
              if (iVar5 == 0) {
                if (fld->description != (char *)0x0) {
                  fname = fld->description;
                }
                break;
              }
            }
            if ((fld == (CSOfield_info *)0x0) || (fld->url == 0)) {
              HTSprintf0(&buf,"<DT><I>%s</I><DD>",fname);
              p_Var2 = Target->isa->put_block;
              wVar6 = strlen(buf);
              (*p_Var2)(Target,buf,wVar6);
              *buf = '\0';
              l = fvalue;
              while (*l != '\0') {
                if (*l == '<') {
                  HTSACat(&buf,"&lt;");
                  l = l + 1;
                }
                else if (*l == '>') {
                  HTSACat(&buf,"&gt;");
                  l = l + 1;
                }
                else {
                  iVar5 = strncmp(l,"news:",5);
                  if ((((((iVar5 == 0) || (iVar5 = strncmp(l,"snews://",8), iVar5 == 0)) ||
                        (iVar5 = strncmp(l,"nntp://",7), iVar5 == 0)) ||
                       (((iVar5 = strncmp(l,"snewspost:",10), iVar5 == 0 ||
                         (iVar5 = strncmp(l,"snewsreply:",0xb), iVar5 == 0)) ||
                        ((iVar5 = strncmp(l,"newspost:",9), iVar5 == 0 ||
                         ((iVar5 = strncmp(l,"newsreply:",10), iVar5 == 0 ||
                          (iVar5 = strncmp(l,"ftp://",6), iVar5 == 0)))))))) ||
                      (iVar5 = strncmp(l,"file:/",6), iVar5 == 0)) ||
                     (((((iVar5 = strncmp(l,"finger://",9), iVar5 == 0 ||
                         (iVar5 = strncmp(l,"http://",7), iVar5 == 0)) ||
                        (iVar5 = strncmp(l,"https://",8), iVar5 == 0)) ||
                       ((iVar5 = strncmp(l,"wais://",7), iVar5 == 0 ||
                        (iVar5 = strncmp(l,"mailto:",7), iVar5 == 0)))) ||
                      ((iVar5 = strncmp(l,"cso://",6), iVar5 == 0 ||
                       (iVar5 = strncmp(l,"gopher://",9), iVar5 == 0)))))) {
                    HTSACat(&buf,"<a href=\"");
                    HTSACopy(&href,l);
                    pcVar3 = strtok(href," \r\n\t,>)\"");
                    HTSACat(&buf,pcVar3);
                    HTSACat(&buf,"\">");
                    while ((*l != '\0' &&
                           (pcVar3 = strchr(" \r\n\t,>)\"",(int)*l), pcVar3 == (char *)0x0))) {
                      cVar1 = *l;
                      l = l + 1;
                      HTSprintf(&buf,"%c",(int)cVar1);
                    }
                    HTSACat(&buf,"</a>");
                    if (href != (char *)0x0) {
                      free(href);
                      href = (char *)0x0;
                    }
                  }
                  else {
                    cVar1 = *l;
                    l = l + 1;
                    HTSprintf(&buf,"%c",(int)cVar1);
                  }
                }
              }
              HTSACat(&buf,"\n");
              p_Var2 = Target->isa->put_block;
              wVar6 = strlen(buf);
              (*p_Var2)(Target,buf,wVar6);
            }
            else {
              HTSprintf0(&buf,"<DT><I>%s</I><DD><A HREF=\"%s\">%s</A>\n",fname,fvalue,fvalue);
              p_Var2 = Target->isa->put_block;
              wVar6 = strlen(buf);
              (*p_Var2)(Target,buf,wVar6);
            }
          }
        }
      }
    }
    else {
      *p = (char)ich;
      if (p < line + 0x3ff) {
        p = p + 1;
      }
    }
  }
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"HTLoadCSO: Interrupted in HTGetCharacter, apparently.\n");
  }
  mustshow = '\x01';
  pcVar3 = (char *)gettext("Connection interrupted.");
  HTProgress(pcVar3);
end_CSOreport:
  if (prev_ndx != -100) {
    HTSprintf0(&buf,"</DL></DL>\n");
    p_Var2 = Target->isa->put_block;
    wVar6 = strlen(buf);
    (*p_Var2)(Target,buf,wVar6);
  }
  if (buf != (char *)0x0) {
    free(buf);
    buf = (char *)0x0;
  }
  if (local_c == *(int *)(in_GS_OFFSET + 0x14)) {
    return 0;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int HTLoadCSO(char *arg,HTParentAnchor *anAnchor,HTFormat format_out,HTStream *sink)

{
  int iVar1;
  char *pcVar2;
  _func_void_HTStream_ptr_char_ptr_wchar_t *p_Var3;
  FILE *pFVar4;
  char *pcVar5;
  char *fmt;
  int iVar6;
  wchar_t wVar7;
  int in_GS_OFFSET;
  int local_8c8;
  size_t local_8c4;
  char *local_8c0;
  wchar_t local_8b8;
  char *local_8b4;
  int local_8b0;
  char *local_8ac;
  char *local_8a8;
  int local_8a4;
  char *local_8a0;
  int local_89c;
  char *local_898;
  int local_894;
  wchar_t local_88c;
  char *local_888;
  size_t local_884;
  char *local_880;
  HTStream *sink_local;
  HTFormat format_out_local;
  HTParentAnchor *anAnchor_local;
  char *arg_local;
  char *temp;
  HTStream *Target;
  HTFormat format_in;
  CSOfield_info *fld;
  int has_indexed;
  int return_type;
  int ndx;
  int flen;
  int finish;
  int start;
  int j;
  int i;
  int len;
  bstring *content;
  bstring *command;
  int status;
  int port;
  char *data;
  char *cp;
  char *host;
  char buf [2048];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  port = 0x69;
  command = (bstring *)0x0;
  content = (bstring *)0x0;
  format_in = HTAtom_for("text/html");
  Target = (HTStream *)0x0;
  if (acceptable_inited == '\0') {
    init_acceptable();
  }
  if (arg == (char *)0x0) {
    local_8c8 = -3;
  }
  else if (*arg == '\0') {
    local_8c8 = -2;
  }
  else {
    if (WWW_TraceFlag != '\0') {
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"HTLoadCSO: Looking for %s\n",arg);
    }
    status = HTDoConnect(arg,"cso",0x69,&s);
    if (status == -0x752e) {
      if (WWW_TraceFlag != '\0') {
        pFVar4 = TraceFP();
        fprintf((FILE *)pFVar4,"HTLoadCSO: Interrupted on connect; recovering cleanly.\n");
      }
      mustshow = '\x01';
      pcVar5 = (char *)gettext("Connection interrupted.");
      HTProgress(pcVar5);
      local_8c8 = -29999;
    }
    else if (status < 0) {
      if (WWW_TraceFlag != '\0') {
        pFVar4 = TraceFP();
        fprintf((FILE *)pFVar4,"HTLoadCSO: Unable to connect to remote host for `%s\'.\n",arg);
      }
      local_8c8 = HTInetStatus("connect");
    }
    else {
      HTInitInput(s);
      HTBprintf(&command,"fields%c%c",0xd,10);
      if (WWW_TraceFlag != '\0') {
        if (WWW_TraceFlag != '\0') {
          pFVar4 = TraceFP();
          fprintf((FILE *)pFVar4,"HTLoadCSO: Connected, writing command `");
        }
        trace_bstring(command);
        iVar6 = s;
        if (WWW_TraceFlag != '\0') {
          pFVar4 = TraceFP();
          fprintf((FILE *)pFVar4,"\' to socket %d\n",iVar6);
        }
      }
      mustshow = '\x01';
      pcVar5 = (char *)gettext("Sending CSO/PH request.");
      HTProgress(pcVar5);
      if (command == (bstring *)0x0) {
        local_8c4 = 0;
        local_8c0 = (char *)0x0;
      }
      else {
        local_8c4 = command->len;
        local_8c0 = command->str;
      }
      status = write(s,local_8c0,local_8c4);
      HTSABFree(&command);
      if (status < 0) {
        if (WWW_TraceFlag != '\0') {
          pFVar4 = TraceFP();
          fprintf((FILE *)pFVar4,"HTLoadCSO: Unable to send command.\n");
        }
        local_8c8 = HTInetStatus("send");
      }
      else {
        mustshow = '\x01';
        pcVar5 = (char *)gettext("CSO/PH request sent; waiting for response.");
        HTProgress(pcVar5);
        status = parse_cso_fields(buf,0x800);
        if (status == 0) {
          Target = (HTStream *)
                   HTStreamStack(format_in,format_out,(HTStream_conflict4 *)sink,anAnchor);
          if (((HTStream_conflict4 *)Target == (HTStream_conflict4 *)0x0) ||
             ((HTStream_conflict4 *)Target == (HTStream_conflict4 *)0x0)) {
            temp = (char *)0x0;
            pcVar5 = format_out->name;
            pcVar2 = format_in->name;
            fmt = (char *)gettext("Sorry, no known way of converting %s to %s.");
            HTSprintf0(&temp,fmt,pcVar2,pcVar5);
            HTAlert(temp);
            if (temp != (char *)0x0) {
              free(temp);
              temp = (char *)0x0;
            }
            close(s);
            local_8c8 = -29999;
          }
          else {
            host = HTParse(arg,"",8);
            cp = strchr(host,0x3a);
            if ((((cp != (char *)0x0) && ('/' < cp[1])) && (cp[1] < ':')) &&
               (port = atoi(cp + 1), port == 0x69)) {
              *cp = '\0';
            }
            anAnchor->safe = '\x01';
            if (((anAnchor->post_data == (bstring *)0x0) || (anAnchor->post_data == (bstring *)0x0))
               || (anAnchor->post_data->len == 0)) {
              generate_cso_form(host,port,buf,Target);
              (*Target->isa->_free)(Target);
              if (host != (char *)0x0) {
                free(host);
                host = (char *)0x0;
              }
              close(s);
              free_CSOfields();
              local_8c8 = 200;
            }
            else {
              HTBprintf(&command,
                        "<HTML>\n<HEAD>\n<TITLE>CSO/PH Results on %s</TITLE>\n</HEAD>\n<BODY>\n",
                        host);
              if (command == (bstring *)0x0) {
                local_8b8 = L'\0';
                local_8b4 = (char *)0x0;
              }
              else {
                local_8b8 = command->len;
                local_8b4 = command->str;
              }
              (*Target->isa->put_block)(Target,local_8b4,local_8b8);
              HTSABFree(&command);
              if (host != (char *)0x0) {
                free(host);
                host = (char *)0x0;
              }
              if (anAnchor->post_data == (bstring *)0x0) {
                local_8b0 = 0;
              }
              else {
                local_8b0 = anAnchor->post_data->len;
              }
              if (anAnchor->post_data == (bstring *)0x0) {
                local_8ac = (char *)0x0;
              }
              else {
                local_8ac = anAnchor->post_data->str;
              }
              HTSABCopy(&content,local_8ac,local_8b0);
              if (content == (bstring *)0x0) {
                local_8a8 = (char *)0x0;
                local_8a4 = -1;
              }
              else {
                local_8a8 = content->str;
                local_8a4 = content->len + -1;
              }
              if (local_8a8[local_8a4] != '&') {
                HTSABCat0(&content,"&");
              }
              if (content == (bstring *)0x0) {
                local_8a0 = (char *)0x0;
                local_89c = 0;
              }
              else {
                local_8a0 = content->str;
                local_89c = content->len;
              }
              len = local_89c;
              for (i = 0; i < local_89c; i = i + 1) {
                if (local_8a0[i] == '+') {
                  local_8a0[i] = ' ';
                }
              }
              if (content == (bstring *)0x0) {
                local_898 = (char *)0x0;
              }
              else {
                local_898 = content->str;
              }
              data = local_898;
              HTUnEscape(local_898);
              if (content == (bstring *)0x0) {
                local_894 = 0;
              }
              else {
                local_894 = content->len;
              }
              len = local_894;
              return_type = 0;
              has_indexed = 0;
              finish = 0;
              start = 0;
              for (i = 0; i < len; i = i + 1) {
                if ((data[i] == '\0') || (data[i] == '&')) {
                  flen = i - start;
                  finish = start + flen;
                  data[finish] = '\0';
                  for (j = start; j < finish; j = j + 1) {
                    if (data[j] == '=') {
                      if ((data[start + 1] == '_') && ((data[start] == 'r' || (data[start] == 'q')))
                         ) {
                        sscanf(data + start + 2,"%d=",&ndx);
                        for (fld = CSOfields; fld != (CSOfield_info *)0x0; fld = fld->next) {
                          if (fld->id == ndx) {
                            if (j + 1 < finish) {
                              if (data[start] == 'q') {
                                if (fld->lookup == 0) {
                                  memcpy(buf,"Warning: non-lookup field ignored<BR>\n",0x27);
                                  p_Var3 = Target->isa->put_block;
                                  wVar7 = strlen(buf);
                                  (*p_Var3)(Target,buf,wVar7);
                                }
                                else {
                                  if (fld->indexed != 0) {
                                    has_indexed = 1;
                                  }
                                  if (((command == (bstring *)0x0) || (command == (bstring *)0x0))
                                     || (command->len == 0)) {
                                    HTSABCopy0(&command,"query ");
                                  }
                                  else {
                                    HTSABCat0(&command," ");
                                  }
                                  HTBprintf(&command,"%s=\"%s\"",fld->name,data + j + 1);
                                }
                              }
                              else if (data[start] == 'r') {
                                fld->explicit_return = 1;
                              }
                            }
                            break;
                          }
                        }
                      }
                      else {
                        iVar6 = strncmp(data + start,"return=",7);
                        if (iVar6 == 0) {
                          iVar6 = strcmp(data + start + 7,"all");
                          if (iVar6 == 0) {
                            return_type = 1;
                          }
                          else {
                            iVar6 = strcmp(data + start + 7,"selected");
                            if (iVar6 == 0) {
                              return_type = 2;
                            }
                          }
                        }
                      }
                    }
                  }
                  start = i + 1;
                }
              }
              HTSABFree(&content);
              if (((command == (bstring *)0x0) || (command == (bstring *)0x0)) ||
                 ((command->len == 0 || (has_indexed == 0)))) {
                close(s);
                memcpy(buf,"<EM>Error:</EM> At least one indexed field value must be specified!\n",
                       0x45);
                p_Var3 = Target->isa->put_block;
                wVar7 = strlen(buf);
                (*p_Var3)(Target,buf,wVar7);
                memcpy(buf,"</BODY>\n</HTML>\n",0x11);
                p_Var3 = Target->isa->put_block;
                wVar7 = strlen(buf);
                (*p_Var3)(Target,buf,wVar7);
                (*Target->isa->_free)(Target);
                free_CSOfields();
                local_8c8 = 200;
              }
              else {
                if (return_type == 1) {
                  HTSABCat0(&command," return all");
                }
                else if (return_type == 2) {
                  HTSABCat0(&command," return");
                  for (fld = CSOfields; fld != (CSOfield_info *)0x0; fld = fld->next) {
                    if (fld->explicit_return != 0) {
                      HTBprintf(&command," %s",fld->name);
                    }
                  }
                }
                HTBprintf(&command,"%c%c",0xd,10);
                memcpy(buf,"<H2>\n<EM>CSO/PH command:</EM> ",0x1f);
                p_Var3 = Target->isa->put_block;
                wVar7 = strlen(buf);
                (*p_Var3)(Target,buf,wVar7);
                if (command == (bstring *)0x0) {
                  local_88c = L'\0';
                  local_888 = (char *)0x0;
                }
                else {
                  local_88c = command->len;
                  local_888 = command->str;
                }
                (*Target->isa->put_block)(Target,local_888,local_88c);
                memcpy(buf,"</H2>\n",7);
                p_Var3 = Target->isa->put_block;
                wVar7 = strlen(buf);
                (*p_Var3)(Target,buf,wVar7);
                if (WWW_TraceFlag != '\0') {
                  if (WWW_TraceFlag != '\0') {
                    pFVar4 = TraceFP();
                    fprintf((FILE *)pFVar4,"HTLoadCSO: Writing command `");
                  }
                  trace_bstring(command);
                  iVar6 = s;
                  if (WWW_TraceFlag != '\0') {
                    pFVar4 = TraceFP();
                    fprintf((FILE *)pFVar4,"\' to socket %d\n",iVar6);
                  }
                }
                if (command == (bstring *)0x0) {
                  local_884 = 0;
                  local_880 = (char *)0x0;
                }
                else {
                  local_884 = command->len;
                  local_880 = command->str;
                }
                status = write(s,local_880,local_884);
                HTSABFree(&command);
                if (status < 0) {
                  if (WWW_TraceFlag != '\0') {
                    pFVar4 = TraceFP();
                    fprintf((FILE *)pFVar4,"HTLoadCSO: Unable to send command.\n");
                  }
                  free_CSOfields();
                  local_8c8 = HTInetStatus("send");
                }
                else {
                  generate_cso_report(Target);
                  close(s);
                  (*Target->isa->put_block)(Target,"</BODY>\n</HTML>\n",L'\x10');
                  (*Target->isa->_free)(Target);
                  if (host != (char *)0x0) {
                    free(host);
                    host = (char *)0x0;
                  }
                  free_CSOfields();
                  local_8c8 = 200;
                }
              }
            }
          }
        }
        else {
          close(s);
          if (status == -0x752e) {
            mustshow = '\x01';
            pcVar5 = (char *)gettext("Connection interrupted.");
            HTProgress(pcVar5);
          }
          else if (buf[0] == '\0') {
            pcVar5 = (char *)gettext("No response from server!");
            HTAlert(pcVar5);
          }
          else {
            HTAlert(buf);
          }
          local_8c8 = -29999;
        }
      }
    }
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return local_8c8;
}



// WARNING: Unknown calling convention

int HTLoadGopher(char *arg,HTParentAnchor *anAnchor,HTFormat format_out,HTStream *sink)

{
  HTStructuredClass *pHVar1;
  FILE *pFVar2;
  size_t sVar3;
  int iVar4;
  char *pcVar5;
  char *pcVar6;
  size_t sVar7;
  ssize_t sVar8;
  HTAtom *pHVar9;
  undefined *__src;
  int local_3c;
  char *p_2;
  char *p_1;
  char *query_1;
  char *p;
  char *query;
  char *p1;
  int len;
  char *selector;
  int status;
  char *command;
  char gtype;
  
  if (acceptable_inited == '\0') {
    init_acceptable();
  }
  if (arg == (char *)0x0) {
    local_3c = -3;
  }
  else if (*arg == '\0') {
    local_3c = -2;
  }
  else {
    if (WWW_TraceFlag != '\0') {
      pFVar2 = TraceFP();
      fprintf((FILE *)pFVar2,"HTGopher: Looking for %s\n",arg);
    }
    sVar3 = strlen(arg);
    if (((int)sVar3 < 6) || (iVar4 = strcmp(arg + (sVar3 - 6),":105/2"), iVar4 != 0)) {
      pcVar5 = strstr(arg,":79/0");
      if (pcVar5 == (char *)0x0) {
        pcVar5 = HTParse(arg,"",5);
        gtype = '1';
        selector = pcVar5 + 1;
        if ((*pcVar5 == '/') && (*selector != '\0')) {
          gtype = *selector;
          selector = pcVar5 + 2;
        }
        if (gtype == '7') {
          HTAnchor_setIndex(anAnchor,anAnchor->address);
          pcVar6 = strchr(selector,0x3f);
          if ((pcVar6 == (char *)0x0) || (pcVar6[1] == '\0')) {
            target = (HTStructured_conflict *)
                     HTML_new(anAnchor,format_out,(HTStream_conflict *)sink);
            pHVar1 = ((HTStructured *)target)->isa;
            targetClass.name = pHVar1->name;
            targetClass._free = (_func_void_HTStructured_ptr_conflict *)pHVar1->_free;
            targetClass._abort = (_func_void_HTStructured_ptr_HTError_conflict *)pHVar1->_abort;
            targetClass.put_character =
                 (_func_void_HTStructured_ptr_char_conflict *)pHVar1->put_character;
            targetClass.put_string =
                 (_func_void_HTStructured_ptr_char_ptr_conflict *)pHVar1->put_string;
            targetClass.put_block =
                 (_func_void_HTStructured_ptr_char_ptr_int_conflict *)pHVar1->put_block;
            targetClass.start_element =
                 (_func_int_HTStructured_ptr_int_BOOLEAN_ptr_char_ptr_ptr_int_char_ptr_ptr_conflict
                  *)pHVar1->start_element;
            targetClass.end_element =
                 (_func_int_HTStructured_ptr_int_char_ptr_ptr_conflict *)pHVar1->end_element;
            targetClass.put_entity = (_func_int_HTStructured_ptr_int_conflict *)pHVar1->put_entity;
            display_index(arg,anAnchor);
            return 200;
          }
          *pcVar6 = '\0';
          pcVar6 = pcVar6 + 1;
          sVar3 = strlen(selector);
          sVar7 = strlen(pcVar6);
          command = (char *)malloc(sVar3 + sVar7 + 4);
          if (command == (char *)0x0) {
            outofmem("../../../WWW/Library/Implementation/HTGopher.c","HTLoadGopher");
          }
          de_escape(command,selector);
          sVar7 = 2;
          __src = &DAT_08190506;
          sVar3 = strlen(command);
          memcpy(command + sVar3,__src,sVar7);
          for (p = pcVar6; *p != '\0'; p = p + 1) {
            if (*p == '+') {
              *p = ' ';
            }
          }
          sVar3 = strlen(command);
          de_escape(command + sVar3,pcVar6);
        }
        else if (gtype == '2') {
          pcVar6 = strchr(selector,0x3f);
          if ((pcVar6 == (char *)0x0) || (pcVar6[1] == '\0')) {
            target = (HTStructured_conflict *)
                     HTML_new(anAnchor,format_out,(HTStream_conflict *)sink);
            pHVar1 = ((HTStructured *)target)->isa;
            targetClass.name = pHVar1->name;
            targetClass._free = (_func_void_HTStructured_ptr_conflict *)pHVar1->_free;
            targetClass._abort = (_func_void_HTStructured_ptr_HTError_conflict *)pHVar1->_abort;
            targetClass.put_character =
                 (_func_void_HTStructured_ptr_char_conflict *)pHVar1->put_character;
            targetClass.put_string =
                 (_func_void_HTStructured_ptr_char_ptr_conflict *)pHVar1->put_string;
            targetClass.put_block =
                 (_func_void_HTStructured_ptr_char_ptr_int_conflict *)pHVar1->put_block;
            targetClass.start_element =
                 (_func_int_HTStructured_ptr_int_BOOLEAN_ptr_char_ptr_ptr_int_char_ptr_ptr_conflict
                  *)pHVar1->start_element;
            targetClass.end_element =
                 (_func_int_HTStructured_ptr_int_char_ptr_ptr_conflict *)pHVar1->end_element;
            targetClass.put_entity = (_func_int_HTStructured_ptr_int_conflict *)pHVar1->put_entity;
            display_cso(arg,anAnchor);
            return 200;
          }
          HTAnchor_setIndex(anAnchor,anAnchor->address);
          *pcVar6 = '\0';
          pcVar6 = pcVar6 + 1;
          sVar3 = strlen(pcVar6);
          command = (char *)malloc(sVar3 + 9);
          if (command == (char *)0x0) {
            outofmem("../../../WWW/Library/Implementation/HTGopher.c","HTLoadGopher");
          }
          de_escape(command,selector);
          memcpy(command,"query ",7);
          for (p_1 = pcVar6; *p_1 != '\0'; p_1 = p_1 + 1) {
            if (*p_1 == '+') {
              *p_1 = ' ';
            }
          }
          sVar3 = strlen(command);
          de_escape(command + sVar3,pcVar6);
        }
        else {
          sVar3 = strlen(selector);
          command = (char *)malloc(sVar3 + 3);
          if (command == (char *)0x0) {
            outofmem("../../../WWW/Library/Implementation/HTGopher.c","HTLoadGopher");
          }
          de_escape(command,selector);
        }
        if (pcVar5 != (char *)0x0) {
          free(pcVar5);
        }
        sVar3 = strlen(command);
        pcVar5 = command + sVar3;
        *pcVar5 = '\r';
        pcVar5[1] = '\n';
        pcVar5[2] = '\0';
        iVar4 = HTDoConnect(arg,"gopher",0x46,&s);
        if (iVar4 == -0x752e) {
          if (WWW_TraceFlag != '\0') {
            pFVar2 = TraceFP();
            fprintf((FILE *)pFVar2,"HTGopher: Interrupted on connect; recovering cleanly.\n");
          }
          mustshow = '\x01';
          pcVar5 = (char *)gettext("Connection interrupted.");
          HTProgress(pcVar5);
          if (command != (char *)0x0) {
            free(command);
          }
          local_3c = -29999;
        }
        else if (iVar4 < 0) {
          if (WWW_TraceFlag != '\0') {
            pFVar2 = TraceFP();
            fprintf((FILE *)pFVar2,"HTGopher: Unable to connect to remote host for `%s\'.\n",arg);
          }
          if (command != (char *)0x0) {
            free(command);
          }
          local_3c = HTInetStatus("connect");
        }
        else {
          HTInitInput(s);
          iVar4 = s;
          if (WWW_TraceFlag != '\0') {
            pFVar2 = TraceFP();
            fprintf((FILE *)pFVar2,"HTGopher: Connected, writing command `%s\' to socket %d\n",
                    command,iVar4);
          }
          mustshow = '\x01';
          pcVar5 = (char *)gettext("Sending Gopher request.");
          HTProgress(pcVar5);
          sVar3 = strlen(command);
          sVar8 = write(s,command,sVar3);
          if (command != (char *)0x0) {
            free(command);
          }
          if (sVar8 < 0) {
            if (WWW_TraceFlag != '\0') {
              pFVar2 = TraceFP();
              fprintf((FILE *)pFVar2,"HTGopher: Unable to send command.\n");
            }
            local_3c = HTInetStatus("send");
          }
          else {
            mustshow = '\x01';
            pcVar5 = (char *)gettext("Gopher request sent; waiting for response.");
            HTProgress(pcVar5);
            iVar4 = s;
            switch(gtype) {
            case '0':
              pHVar9 = HTAtom_for("text/plain");
              HTParseSocket(pHVar9,format_out,anAnchor,iVar4,(HTStream_conflict4 *)sink);
              break;
            case '1':
            case '7':
              target = (HTStructured_conflict *)
                       HTML_new(anAnchor,format_out,(HTStream_conflict *)sink);
              pHVar1 = ((HTStructured *)target)->isa;
              targetClass.name = pHVar1->name;
              targetClass._free = (_func_void_HTStructured_ptr_conflict *)pHVar1->_free;
              targetClass._abort = (_func_void_HTStructured_ptr_HTError_conflict *)pHVar1->_abort;
              targetClass.put_character =
                   (_func_void_HTStructured_ptr_char_conflict *)pHVar1->put_character;
              targetClass.put_string =
                   (_func_void_HTStructured_ptr_char_ptr_conflict *)pHVar1->put_string;
              targetClass.put_block =
                   (_func_void_HTStructured_ptr_char_ptr_int_conflict *)pHVar1->put_block;
              targetClass.start_element =
                   (_func_int_HTStructured_ptr_int_BOOLEAN_ptr_char_ptr_ptr_int_char_ptr_ptr_conflict
                    *)pHVar1->start_element;
              targetClass.end_element =
                   (_func_int_HTStructured_ptr_int_char_ptr_ptr_conflict *)pHVar1->end_element;
              targetClass.put_entity = (_func_int_HTStructured_ptr_int_conflict *)pHVar1->put_entity
              ;
              parse_menu(arg,anAnchor);
              break;
            case '2':
              target = (HTStructured_conflict *)
                       HTML_new(anAnchor,format_out,(HTStream_conflict *)sink);
              pHVar1 = ((HTStructured *)target)->isa;
              targetClass.name = pHVar1->name;
              targetClass._free = (_func_void_HTStructured_ptr_conflict *)pHVar1->_free;
              targetClass._abort = (_func_void_HTStructured_ptr_HTError_conflict *)pHVar1->_abort;
              targetClass.put_character =
                   (_func_void_HTStructured_ptr_char_conflict *)pHVar1->put_character;
              targetClass.put_string =
                   (_func_void_HTStructured_ptr_char_ptr_conflict *)pHVar1->put_string;
              targetClass.put_block =
                   (_func_void_HTStructured_ptr_char_ptr_int_conflict *)pHVar1->put_block;
              targetClass.start_element =
                   (_func_int_HTStructured_ptr_int_BOOLEAN_ptr_char_ptr_ptr_int_char_ptr_ptr_conflict
                    *)pHVar1->start_element;
              targetClass.end_element =
                   (_func_int_HTStructured_ptr_int_char_ptr_ptr_conflict *)pHVar1->end_element;
              targetClass.put_entity = (_func_int_HTStructured_ptr_int_conflict *)pHVar1->put_entity
              ;
              parse_cso(arg,anAnchor);
              break;
            default:
              pHVar9 = HTAtom_for("www/unknown");
              HTParseSocket(pHVar9,format_out,anAnchor,iVar4,(HTStream_conflict4 *)sink);
              break;
            case ':':
            case 'I':
            case 'g':
              pHVar9 = HTAtom_for("image/gif");
              HTParseSocket(pHVar9,format_out,anAnchor,iVar4,(HTStream_conflict4 *)sink);
              break;
            case ';':
              pHVar9 = HTAtom_for("video/mpeg");
              HTParseSocket(pHVar9,format_out,anAnchor,iVar4,(HTStream_conflict4 *)sink);
              break;
            case '<':
            case 's':
              pHVar9 = HTAtom_for("audio/basic");
              HTParseSocket(pHVar9,format_out,anAnchor,iVar4,(HTStream_conflict4 *)sink);
              break;
            case 'H':
            case 'h':
              pHVar9 = HTAtom_for("text/html");
              HTParseSocket(pHVar9,format_out,anAnchor,iVar4,(HTStream_conflict4 *)sink);
              break;
            case 'P':
              pHVar9 = HTAtom_for("application/pdf");
              HTParseSocket(pHVar9,format_out,anAnchor,iVar4,(HTStream_conflict4 *)sink);
            }
            close(s);
            local_3c = 200;
          }
        }
      }
      else {
        if (WWW_TraceFlag != '\0') {
          pFVar2 = TraceFP();
          fprintf((FILE *)pFVar2,"HTGopher: Passing to finger gateway.\n");
        }
        local_3c = HTLoadFinger(arg,anAnchor,format_out,sink);
      }
    }
    else {
      if (WWW_TraceFlag != '\0') {
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2,"HTGopher: Passing to CSO/PH gateway.\n");
      }
      local_3c = HTLoadCSO(arg,anAnchor,format_out,sink);
    }
  }
  return local_3c;
}



// WARNING: Unknown calling convention

void do_system(char *command)

{
  FILE *__stream;
  
  if ((command != (char *)0x0) && (*command != '\0')) {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTTelnet: Command is: %s\n\n",command);
    }
    LYSystem(command);
    if (command != (char *)0x0) {
      free(command);
    }
  }
  return;
}



// WARNING: Unknown calling convention

int remote_session(char *acc_method,char *host)

{
  BOOLEAN BVar1;
  int iVar2;
  char *pcVar3;
  ushort **ppuVar4;
  FILE *pFVar5;
  _login_protocol local_48;
  _login_protocol local_44;
  char *local_40;
  char *local_38;
  char *line;
  char *prefix;
  _login_protocol login_protocol;
  char *command;
  char *port;
  char *hostname;
  char *cp;
  char *password;
  char *user;
  char *program;
  
  user = host;
  password = (char *)0x0;
  command = (char *)0x0;
  iVar2 = strcmp(acc_method,"rlogin");
  if (iVar2 == 0) {
    local_48 = rlogin;
  }
  else {
    iVar2 = strcmp(acc_method,"tn3270");
    if (iVar2 == 0) {
      local_44 = tn3270;
    }
    else {
      local_44 = telnet;
    }
    local_48 = local_44;
  }
  login_protocol = local_48;
  pcVar3 = strchr(host,0x40);
  if (pcVar3 == (char *)0x0) {
    local_40 = host;
  }
  else {
    local_40 = strchr(host,0x40);
  }
  cp = local_40;
  do {
    if (*cp == '\0') {
LAB_081420ca:
      pcVar3 = strchr(host,0x40);
      if (pcVar3 == (char *)0x0) {
        hostname = host;
        user = (char *)0x0;
      }
      else {
        *pcVar3 = '\0';
        hostname = pcVar3 + 1;
      }
      port = strchr(hostname,0x3a);
      if (port != (char *)0x0) {
        *port = '\0';
        port = port + 1;
      }
      if ((hostname == (char *)0x0) || (*hostname == '\0')) {
        if (WWW_TraceFlag != '\0') {
          pFVar5 = TraceFP();
          fprintf((FILE *)pFVar5,"HTTelnet: No host specified!\n");
        }
      }
      else {
        BVar1 = valid_hostname(hostname);
        if (BVar1 == '\0') {
          prefix = (char *)0x0;
          line = (char *)0x0;
          if (WWW_TraceFlag != '\0') {
            pFVar5 = TraceFP();
            fprintf((FILE *)pFVar5,"HTTelnet: Invalid hostname %s!\n",host);
          }
          pcVar3 = (char *)gettext("remote %s session:");
          HTSprintf0(&prefix,pcVar3,acc_method);
          pcVar3 = (char *)gettext("Invalid hostname %s");
          HTSprintf0(&line,pcVar3,host);
          HTAlwaysAlert(prefix,line);
          if (prefix != (char *)0x0) {
            free(prefix);
            prefix = (char *)0x0;
          }
          if (line != (char *)0x0) {
            free(line);
          }
        }
        else {
          if ((user != (char *)0x0) && (password = strchr(user,0x3a), password != (char *)0x0)) {
            *password = '\0';
            password = password + 1;
          }
          if (HTSecure == '\0') {
            if ((user != (char *)0x0) && (login_protocol != rlogin)) {
              printf("When you are connected, log in as:  %s\n",user);
            }
            if ((password != (char *)0x0) && (login_protocol != rlogin)) {
              printf("                  The password is:  %s\n",password);
            }
            fflush(stdout);
            if (login_protocol == rlogin) {
              program = HTGetProgramPath(ppRLOGIN);
              if (program != (char *)0x0) {
                HTAddParam(&command,"%s %s%s%s",1,program);
                HTAddParam(&command,"%s %s%s%s",2,hostname);
                if (user == (char *)0x0) {
                  local_38 = "";
                }
                else {
                  local_38 = " -l ";
                }
                HTSACat(&command,local_38);
                HTAddParam(&command,"%s %s%s%s",4,user);
                HTEndParam(&command,"%s %s%s%s",4);
              }
            }
            else if (login_protocol == telnet) {
              program = HTGetProgramPath(ppTELNET);
              if (program != (char *)0x0) {
                HTAddParam(&command,"%s %s %s",1,program);
                HTAddParam(&command,"%s %s %s",2,hostname);
                HTAddParam(&command,"%s %s %s",3,port);
                HTEndParam(&command,"%s %s %s",3);
              }
            }
            else if ((login_protocol == tn3270) &&
                    (program = HTGetProgramPath(ppTN3270), program != (char *)0x0)) {
              HTAddParam(&command,"%s %s %s",1,program);
              HTAddParam(&command,"%s %s %s",2,hostname);
              HTAddParam(&command,"%s %s %s",3,port);
              HTEndParam(&command,"%s %s %s",3);
            }
            LYSystem(command);
          }
          else {
            puts("\n\nSorry, but the service you have selected is one");
            puts("to which you have to log in.  If you were running www");
            puts("on your own computer, you would be automatically connected.");
            puts("For security reasons, this is not allowed when");
            puts("you log in to this information service remotely.\n");
            printf("You can manually connect to this service using %s\n",acc_method);
            printf("to host %s",hostname);
            if (user != (char *)0x0) {
              printf(", user name %s",user);
            }
            if (password != (char *)0x0) {
              printf(", password %s",password);
            }
            if (port != (char *)0x0) {
              printf(", port %s",port);
            }
            puts(".\n");
          }
        }
      }
      return -0xcc;
    }
    ppuVar4 = __ctype_b_loc();
    if (((((((*ppuVar4)[(byte)*cp] & 8) == 0) && (*cp != '_')) && (*cp != '-')) &&
        ((*cp != ':' && (*cp != '.')))) && (*cp != '@')) {
      *cp = '\0';
      goto LAB_081420ca;
    }
    cp = cp + 1;
  } while( true );
}



// WARNING: Unknown calling convention

int HTLoadTelnet(char *addr,HTParentAnchor *anchor,HTFormat format_out,HTStream *sink)

{
  FILE *pFVar1;
  char *acc_method_00;
  char *host_00;
  int local_18;
  int status;
  char *host;
  char *acc_method;
  
  if (sink == (HTStream *)0x0) {
    acc_method_00 = HTParse(addr,"file:",0x10);
    host_00 = HTParse(addr,"",8);
    if ((host_00 == (char *)0x0) || (*host_00 == '\0')) {
      status = -0xcc;
      if (WWW_TraceFlag != '\0') {
        pFVar1 = TraceFP();
        fprintf((FILE *)pFVar1,"HTTelnet: No host specified!\n");
      }
    }
    else {
      status = remote_session(acc_method_00,host_00);
    }
    if (host_00 != (char *)0x0) {
      free(host_00);
    }
    if (acc_method_00 != (char *)0x0) {
      free(acc_method_00);
    }
    local_18 = status;
  }
  else {
    if (WWW_TraceFlag != '\0') {
      pFVar1 = TraceFP();
      fprintf((FILE *)pFVar1,"HTTelnet: Can\'t output a live session -- must be interactive!\n");
    }
    local_18 = -0xcc;
  }
  return local_18;
}



// WARNING: Unknown calling convention

BOOLEAN initialize(void)

{
  finger_fd = -1;
  return '\x01';
}



void start_anchor(char *href)

{
  int iVar1;
  int in_GS_OFFSET;
  char *href_local;
  char *value [25];
  int i;
  BOOLEAN present [25];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  for (i = 0; i < 0x19; i = i + 1) {
    present[i] = i == 6;
  }
  value[6] = href;
  (*targetClass.start_element)(target,0,present,value,-1,(char **)0x0);
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



int response(char *command,char *sitename,HTParentAnchor *anAnchor,HTFormat format_out,
            HTStream *sink)

{
  char cVar1;
  HTStructuredClass *pHVar2;
  FILE *pFVar3;
  char *pcVar4;
  int iVar5;
  int in_GS_OFFSET;
  int local_44c;
  HTStream *sink_local;
  HTFormat format_out_local;
  HTParentAnchor *anAnchor_local;
  char *sitename_local;
  char *command_local;
  char *href;
  char *p;
  char *cmd;
  char *l;
  int i;
  int ch;
  int length;
  int status;
  char line [1024];
  int local_8;
  
  local_8 = *(int *)(in_GS_OFFSET + 0x14);
  length = strlen(command);
  cmd = (char *)0x0;
  p = line;
  href = (char *)0x0;
  if (length == 0) {
    local_44c = -1;
  }
  else {
    HTInitInput(finger_fd);
    if (WWW_TraceFlag != '\0') {
      pFVar3 = TraceFP();
      fprintf((FILE *)pFVar3,"HTFinger command to be sent: %s",command);
    }
    status = write(finger_fd,command,length);
    if (status < 0) {
      if (WWW_TraceFlag != '\0') {
        pFVar3 = TraceFP();
        fprintf((FILE *)pFVar3,"HTFinger: Unable to send command. Disconnecting.\n");
      }
      close(finger_fd);
      finger_fd = -1;
      local_44c = status;
    }
    else {
      target = (HTStructured_conflict *)HTML_new(anAnchor,format_out,(HTStream_conflict *)sink);
      pHVar2 = ((HTStructured *)target)->isa;
      targetClass.name = pHVar2->name;
      targetClass._free = (_func_void_HTStructured_ptr_conflict *)pHVar2->_free;
      targetClass._abort = (_func_void_HTStructured_ptr_HTError_conflict *)pHVar2->_abort;
      targetClass.put_character = (_func_void_HTStructured_ptr_char_conflict *)pHVar2->put_character
      ;
      targetClass.put_string = (_func_void_HTStructured_ptr_char_ptr_conflict *)pHVar2->put_string;
      targetClass.put_block = (_func_void_HTStructured_ptr_char_ptr_int_conflict *)pHVar2->put_block
      ;
      targetClass.start_element =
           (_func_int_HTStructured_ptr_int_BOOLEAN_ptr_char_ptr_ptr_int_char_ptr_ptr_conflict *)
           pHVar2->start_element;
      targetClass.end_element =
           (_func_int_HTStructured_ptr_int_char_ptr_ptr_conflict *)pHVar2->end_element;
      targetClass.put_entity = (_func_int_HTStructured_ptr_int_conflict *)pHVar2->put_entity;
      if (WWW_TraceFlag != '\0') {
        pFVar3 = TraceFP();
        fprintf((FILE *)pFVar3,"HTFinger: Reading finger information\n");
      }
      (*targetClass.start_element)(target,0x37,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
      (*targetClass.put_character)(target,'\n');
      (*targetClass.start_element)(target,0x35,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
      (*targetClass.put_character)(target,'\n');
      (*targetClass.start_element)(target,0x6e,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
      (*targetClass.put_string)(target,"Finger server on ");
      (*targetClass.put_string)(target,sitename);
      (*targetClass.end_element)(target,0x6e,(char **)0x0);
      (*targetClass.put_character)(target,'\n');
      (*targetClass.end_element)(target,0x35,(char **)0x0);
      (*targetClass.put_character)(target,'\n');
      (*targetClass.start_element)(target,0x11,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
      (*targetClass.put_character)(target,'\n');
      (*targetClass.start_element)(target,0x2f,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
      (*targetClass.put_string)(target,"Finger server on ");
      (*targetClass.start_element)(target,0x26,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
      (*targetClass.put_string)(target,sitename);
      (*targetClass.end_element)(target,0x26,(char **)0x0);
      (*targetClass.put_string)(target,": ");
      if (command == (char *)0x0) {
        HTSACopy(&cmd,"");
      }
      else {
        HTSACopy(&cmd,command);
      }
      i = strlen(cmd);
      while ((i = i - 1, -1 < i && ((cmd[i] == '\n' || (cmd[i] == '\r'))))) {
        cmd[i] = '\0';
      }
      (*targetClass.put_string)(target,cmd);
      if (cmd != (char *)0x0) {
        free(cmd);
        cmd = (char *)0x0;
      }
      (*targetClass.end_element)(target,0x2f,(char **)0x0);
      (*targetClass.put_character)(target,'\n');
      (*targetClass.start_element)(target,0x56,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
      while( true ) {
        ch = HTGetCharacter();
        if (ch == -1) break;
        if (interrupted_in_htgetcharacter != 0) {
          if (WWW_TraceFlag != '\0') {
            pFVar3 = TraceFP();
            fprintf((FILE *)pFVar3,"HTFinger: Interrupted in HTGetCharacter, apparently.\n");
          }
          mustshow = '\x01';
          pcVar4 = (char *)gettext("Connection interrupted.");
          HTProgress(pcVar4);
          goto end_html;
        }
        if (ch == 10) {
          *p = '\0';
          p = line;
          l = p;
LAB_0814314c:
          if (*l != '\0') {
            iVar5 = strncmp(l,"news:",5);
            if (iVar5 != 0) {
              iVar5 = strncmp(l,"snews://",8);
              if (iVar5 != 0) {
                iVar5 = strncmp(l,"nntp://",7);
                if (iVar5 != 0) {
                  iVar5 = strncmp(l,"snewspost:",10);
                  if (iVar5 != 0) {
                    iVar5 = strncmp(l,"snewsreply:",0xb);
                    if (iVar5 != 0) {
                      iVar5 = strncmp(l,"newspost:",9);
                      if (iVar5 != 0) {
                        iVar5 = strncmp(l,"newsreply:",10);
                        if (iVar5 != 0) {
                          iVar5 = strncmp(l,"ftp://",6);
                          if (iVar5 != 0) {
                            iVar5 = strncmp(l,"file:/",6);
                            if (iVar5 != 0) {
                              iVar5 = strncmp(l,"finger://",9);
                              if (iVar5 != 0) {
                                iVar5 = strncmp(l,"http://",7);
                                if (iVar5 != 0) {
                                  iVar5 = strncmp(l,"https://",8);
                                  if (iVar5 != 0) {
                                    iVar5 = strncmp(l,"wais://",7);
                                    if (iVar5 != 0) {
                                      iVar5 = strncmp(l,"mailto:",7);
                                      if (iVar5 != 0) {
                                        iVar5 = strncmp(l,"cso://",6);
                                        if (iVar5 != 0) {
                                          iVar5 = strncmp(l,"gopher://",9);
                                          if (iVar5 != 0) {
                                            cVar1 = *l;
                                            l = l + 1;
                                            (*targetClass.put_character)(target,cVar1);
                                            goto LAB_0814314c;
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            HTSACopy(&href,l);
            pcVar4 = strtok(href," \r\n\t,>)\"");
            start_anchor(pcVar4);
            while (*l != '\0') {
              pcVar4 = strchr(" \r\n\t,>)\"",(int)*l);
              if (pcVar4 != (char *)0x0) break;
              cVar1 = *l;
              l = l + 1;
              (*targetClass.put_character)(target,cVar1);
            }
            (*targetClass.end_element)(target,0,(char **)0x0);
            if (href != (char *)0x0) {
              free(href);
              href = (char *)0x0;
            }
            goto LAB_0814314c;
          }
          (*targetClass.put_character)(target,'\n');
        }
        else {
          *p = (char)ch;
          if (p < line + 0x3ff) {
            p = p + 1;
          }
        }
      }
      close(finger_fd);
      finger_fd = -1;
end_html:
      (*targetClass.end_element)(target,0x56,(char **)0x0);
      (*targetClass.put_character)(target,'\n');
      (*targetClass.end_element)(target,0x11,(char **)0x0);
      (*targetClass.put_character)(target,'\n');
      (*targetClass.end_element)(target,0x37,(char **)0x0);
      (*targetClass.put_character)(target,'\n');
      (*targetClass._free)(target);
      local_44c = 0;
    }
  }
  if (local_8 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return local_44c;
}



// WARNING: Unknown calling convention

int HTLoadFinger(char *arg,HTParentAnchor *anAnchor,HTFormat format_out,HTStream *stream)

{
  FILE *pFVar1;
  char *pcVar2;
  int iVar3;
  int iVar4;
  char *local_50;
  int local_4c;
  char *p1;
  int result;
  int status;
  int port;
  char *param;
  char *str;
  char *command;
  char *at_sign;
  char *slash;
  char *colon;
  char *sitename;
  char *username;
  BOOLEAN IsGopherURL;
  
  result = 200;
  IsGopherURL = '\0';
  p1 = arg;
  if (WWW_TraceFlag != '\0') {
    if (arg == (char *)0x0) {
      local_50 = "NULL";
    }
    else {
      local_50 = arg;
    }
    pFVar1 = TraceFP();
    fprintf((FILE *)pFVar1,"HTFinger: Looking for %s\n",local_50);
  }
  if ((arg == (char *)0x0) || (*arg == '\0')) {
    pcVar2 = (char *)gettext("Could not load data.");
    HTAlert(pcVar2);
    local_4c = -29999;
  }
  else {
    if (initialized == '\0') {
      initialized = initialize();
    }
    if (initialized == '\0') {
      pcVar2 = (char *)gettext("Could not set up finger connection.");
      HTAlert(pcVar2);
      local_4c = -29999;
    }
    else {
      iVar3 = strncasecomp(arg,"finger://",9);
      if (iVar3 == 0) {
        p1 = arg + 9;
      }
      else {
        iVar3 = strncasecomp(arg,"gopher://",9);
        if (iVar3 == 0) {
          p1 = arg + 9;
          IsGopherURL = '\x01';
        }
      }
      param = (char *)0x0;
      sitename = HTSACopy(&param,p1);
      if (param == (char *)0x0) {
        pcVar2 = (char *)gettext("Could not load data.");
        HTAlert(pcVar2);
        local_4c = -29999;
      }
      else {
        slash = strchr(sitename,0x2f);
        if (slash != (char *)0x0) {
          *slash = '\0';
          slash = slash + 1;
          HTUnEscape(slash);
          if (IsGopherURL != '\0') {
            if (*slash != '0') {
              pcVar2 = (char *)gettext("Could not load data.");
              HTAlert(pcVar2);
              return -29999;
            }
            *slash = '\0';
            slash = slash + 1;
          }
        }
        at_sign = strchr(sitename,0x40);
        pcVar2 = sitename;
        if (at_sign == (char *)0x0) {
          at_sign = (char *)0x0;
          if (slash == (char *)0x0) {
            username = "";
          }
          else {
            username = slash;
          }
        }
        else {
          if (IsGopherURL != '\0') {
            pcVar2 = (char *)gettext("Could not load data.");
            HTAlert(pcVar2);
            return -29999;
          }
          *at_sign = '\0';
          at_sign = at_sign + 1;
          username = sitename;
          sitename = at_sign;
          HTUnEscape(pcVar2);
        }
        if (*sitename == '\0') {
          pcVar2 = (char *)gettext("Could not load data (no sitename in finger URL)");
          HTAlert(pcVar2);
          result = -29999;
        }
        else {
          colon = strchr(sitename,0x3a);
          if (colon != (char *)0x0) {
            *colon = '\0';
            colon = colon + 1;
            iVar3 = atoi(colon);
            if (iVar3 != 0x4f) {
              pcVar2 = (char *)gettext("Invalid port number - will only use port 79!");
              HTAlert(pcVar2);
              result = -29999;
            }
          }
        }
        if (result == 200) {
          str = (char *)0x0;
          HTSprintf0(&str,"lose://%s/",sitename);
          command = (char *)0x0;
          if ((at_sign == (char *)0x0) || (slash == (char *)0x0)) {
            if (at_sign == (char *)0x0) {
              if (*username == '/') {
                slash = strchr(username + 1,0x2f);
                if (slash != (char *)0x0) {
                  *slash = ' ';
                }
                HTSprintf0(&command,"%s%c%c",username,0xd,10);
              }
              else if (((*username == 'w') || (*username == 'W')) && (username[1] == '/')) {
                if (*username == -2) {
                  username[1] = '\0';
                }
                else {
                  username[1] = ' ';
                }
                HTSprintf0(&command,"/%s%c%c",username,0xd,10);
              }
              else if (((*username == 'w') || (*username == 'W')) && (username[1] == '\0')) {
                HTSprintf0(&command,"/%s%c%c",username,0xd,10);
              }
              else {
                slash = strchr(username,0x2f);
                if (slash == (char *)0x0) {
                  HTSprintf0(&command,"%s%c%c",username,0xd,10);
                }
                else {
                  *slash = '\0';
                  slash = slash + 1;
                  if ((*slash == 'w') || (*slash == 'W')) {
                    HTSprintf0(&command,"/w %s%c%c",username,0xd,10);
                  }
                  else {
                    HTSprintf0(&command,"%s%c%c",username,0xd,10);
                  }
                }
              }
            }
            else {
              HTSprintf0(&command,"%s%c%c",username,0xd,10);
            }
          }
          else if ((*slash == 'w') || (*slash == 'W')) {
            HTSprintf0(&command,"/w %s%c%c",username,0xd,10);
          }
          else {
            HTSprintf0(&command,"%s%c%c",username,0xd,10);
          }
          pcVar2 = str;
          if (WWW_TraceFlag != '\0') {
            pFVar1 = TraceFP();
            fprintf((FILE *)pFVar1,"HTFinger: doing HTDoConnect on \'%s\'\n",pcVar2);
          }
          iVar3 = 0x4f;
          iVar4 = HTDoConnect(str,"finger",0x4f,&finger_fd);
          if (WWW_TraceFlag != '\0') {
            pFVar1 = TraceFP();
            iVar3 = iVar4;
            fprintf((FILE *)pFVar1,"HTFinger: Done DoConnect; status %d\n",iVar4);
          }
          pcVar2 = str;
          if (iVar4 == -0x752e) {
            if (WWW_TraceFlag != '\0') {
              pFVar1 = TraceFP();
              fprintf((FILE *)pFVar1,"HTFinger: Interrupted on connect; recovering cleanly.\n",iVar3
                     );
            }
            pcVar2 = (char *)gettext("Connection interrupted.");
            HTProgress(pcVar2);
            result = -29999;
          }
          else if (iVar4 < 0) {
            close(finger_fd);
            finger_fd = -1;
            if (WWW_TraceFlag != '\0') {
              pFVar1 = TraceFP();
              fprintf((FILE *)pFVar1,"HTFinger: Unable to connect to finger host.\n",iVar3);
            }
            pcVar2 = (char *)gettext("Could not access finger host.");
            HTAlert(pcVar2);
            result = -29999;
          }
          else {
            if (WWW_TraceFlag != '\0') {
              pFVar1 = TraceFP();
              fprintf((FILE *)pFVar1,"HTFinger: Connected to finger host \'%s\'.\n",pcVar2);
            }
            iVar3 = response(command,sitename,anAnchor,format_out,stream);
            if (iVar3 != 0) {
              pcVar2 = (char *)gettext("No response from finger server.");
              HTAlert(pcVar2);
              result = -29999;
            }
          }
          if (str != (char *)0x0) {
            free(str);
            str = (char *)0x0;
          }
          if (command != (char *)0x0) {
            free(command);
            command = (char *)0x0;
          }
        }
        if (param != (char *)0x0) {
          free(param);
        }
        local_4c = result;
      }
    }
  }
  return local_4c;
}



char from_hex(char c)

{
  char local_b;
  char local_a;
  char local_9;
  char c_local;
  
  if ((c < '0') || ('9' < c)) {
    if ((c < 'A') || ('F' < c)) {
      if ((c < 'a') || ('f' < c)) {
        local_9 = '\0';
      }
      else {
        local_9 = c + -0x57;
      }
      local_a = local_9;
    }
    else {
      local_a = c + -0x37;
    }
    local_b = local_a;
  }
  else {
    local_b = c + -0x30;
  }
  return local_b;
}



void WSRCParser_put_character(HTStream_conflict7 *me,char c)

{
  int iVar1;
  FILE *__stream;
  tokenstate local_14;
  tokenstate local_10;
  char c_local;
  
  switch(me->state) {
  case beginning:
    if (c == '(') {
      me->state = before_tag;
    }
    break;
  case before_tag:
    if (c == ')') {
      me->state = done;
    }
    else if (c == ':') {
      me->param_count = 0;
      me->state = colon;
    }
    break;
  case colon:
    if ((byte)c < 0x21) {
      iVar1 = me->param_count;
      me->param[iVar1] = '\0';
      me->param_count = iVar1 + 1;
      me->param_number = 0;
      while ((par_name[me->param_number] != (char *)0x0 &&
             (iVar1 = strcmp(par_name[me->param_number],me->param), iVar1 != 0))) {
        me->param_number = me->param_number + 1;
      }
      if (par_name[me->param_number] == (char *)0x0) {
        if (WWW_TraceFlag != '\0') {
          __stream = TraceFP();
          fprintf((FILE *)__stream,"HTWSRC: Unknown field `%s\' in source file\n",me->param);
        }
        me->param_number = 0x16;
        me->state = before_value;
      }
      else {
        me->state = before_value;
      }
    }
    else if (me->param_count < 10000) {
      iVar1 = me->param_count;
      me->param[iVar1] = c;
      me->param_count = iVar1 + 1;
    }
    break;
  case before_value:
    if (c == ')') {
      me->state = done;
    }
    else if (0x20 < (byte)c) {
      me->param_count = 0;
      if (c == '\"') {
        me->state = quoted_value;
      }
      else {
        if (c == '\"') {
          local_14 = quoted_value;
        }
        else {
          if (c == '(') {
            local_10 = bracketed_value;
          }
          else {
            local_10 = value;
          }
          local_14 = local_10;
        }
        me->state = local_14;
        iVar1 = me->param_count;
        me->param[iVar1] = c;
        me->param_count = iVar1 + 1;
      }
    }
    break;
  case value:
    if ((byte)c < 0x21) {
      me->param[me->param_count] = '\0';
      HTSACopy(me->par_value + me->param_number,me->param);
      me->state = before_tag;
    }
    else if (me->param_count < 10000) {
      iVar1 = me->param_count;
      me->param[iVar1] = c;
      me->param_count = iVar1 + 1;
    }
    break;
  case bracketed_value:
    if (c == ')') {
      me->param[me->param_count] = '\0';
      HTSACopy(me->par_value + me->param_number,me->param);
      me->state = before_tag;
    }
    else if (me->param_count < 10000) {
      iVar1 = me->param_count;
      me->param[iVar1] = c;
      me->param_count = iVar1 + 1;
    }
    break;
  case quoted_value:
    if (c == '\"') {
      me->param[me->param_count] = '\0';
      HTSACopy(me->par_value + me->param_number,me->param);
      me->state = before_tag;
      return;
    }
    if (c == '\\') {
      me->state = escape_in_quoted;
      return;
    }
  case escape_in_quoted:
    if (me->param_count < 10000) {
      iVar1 = me->param_count;
      me->param[iVar1] = c;
      me->param_count = iVar1 + 1;
    }
    me->state = quoted_value;
  }
  return;
}



// WARNING: Unknown calling convention

void give_parameter(HTStream_conflict7 *me,int p)

{
  _func_void_HTStructured_ptr_char_ptr_conflict *p_Var1;
  char *pcVar2;
  
  (*me->target->isa->put_string)(me->target,par_name[p]);
  if (me->par_value[p] == (char *)0x0) {
    p_Var1 = me->target->isa->put_string;
    pcVar2 = (char *)gettext(" NOT GIVEN in source file; ");
    (*p_Var1)(me->target,pcVar2);
  }
  else {
    (*me->target->isa->put_string)(me->target,": ");
    (*me->target->isa->put_string)(me->target,me->par_value[p]);
    (*me->target->isa->put_string)(me->target,"; ");
  }
  return;
}



void WSRC_gen_html(HTStream_conflict7 *me,BOOLEAN source_file)

{
  _func_void_HTStructured_ptr_char_ptr_conflict *p_Var1;
  int iVar2;
  char *pcVar3;
  char *pcVar4;
  char *local_30;
  char *local_28;
  char *local_24;
  undefined *local_20;
  BOOLEAN source_file_local;
  char *www_database;
  char *shortname;
  int l;
  
  if (me->par_value[4] != (char *)0x0) {
    shortname = (char *)0x0;
    HTSACopy(&shortname,me->par_value[4]);
    l = strlen(shortname);
    if (4 < l) {
      iVar2 = strcasecomp(shortname + (l - 4),".src");
      if (iVar2 == 0) {
        shortname[l + -4] = '\0';
      }
    }
    (*me->target->isa->start_element)(me->target,0x35,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
    (*me->target->isa->put_character)(me->target,'\n');
    (*me->target->isa->start_element)(me->target,0x6e,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
    (*me->target->isa->put_string)(me->target,shortname);
    p_Var1 = me->target->isa->put_string;
    if (source_file == '\0') {
      local_30 = (char *)gettext(" index");
    }
    else {
      local_30 = (char *)gettext(" WAIS source file");
    }
    (*p_Var1)(me->target,local_30);
    (*me->target->isa->end_element)(me->target,0x6e,(char **)0x0);
    (*me->target->isa->put_character)(me->target,'\n');
    (*me->target->isa->end_element)(me->target,0x35,(char **)0x0);
    (*me->target->isa->start_element)(me->target,0x2f,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
    (*me->target->isa->put_string)(me->target,shortname);
    p_Var1 = me->target->isa->put_string;
    if (source_file == '\0') {
      local_28 = (char *)gettext(" index");
    }
    else {
      local_28 = (char *)gettext(" description");
    }
    (*p_Var1)(me->target,local_28);
    (*me->target->isa->end_element)(me->target,0x2f,(char **)0x0);
    (*me->target->isa->put_character)(me->target,'\n');
    if (shortname != (char *)0x0) {
      free(shortname);
      shortname = (char *)0x0;
    }
  }
  (*me->target->isa->start_element)(me->target,0x23,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
  if (source_file != '\0') {
    (*me->target->isa->start_element)(me->target,0x25,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
    p_Var1 = me->target->isa->put_string;
    pcVar3 = (char *)gettext("Access links");
    (*p_Var1)(me->target,pcVar3);
    if (tags[37].contents != SGML_EMPTY) {
      (*me->target->isa->end_element)(me->target,0x25,(char **)0x0);
    }
    (*me->target->isa->start_element)(me->target,0x1e,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
    if ((me->par_value[2] == (char *)0x0) || (me->par_value[4] == (char *)0x0)) {
      give_parameter(me,2);
      give_parameter(me,4);
    }
    else {
      shortname = (char *)0x0;
      pcVar3 = HTEscape(me->par_value[4],'\x01');
      if (me->par_value[3] == (char *)0x0) {
        local_24 = "";
      }
      else {
        local_24 = me->par_value[3];
      }
      if (me->par_value[3] == (char *)0x0) {
        local_20 = &DAT_08190f46;
      }
      else {
        local_20 = &DAT_08190f47;
      }
      HTSprintf0(&shortname,"%s//%s%s%s/%s","wais:",me->par_value[2],local_20,local_24,pcVar3);
      HTStartAnchor(me->target,(char *)0x0,shortname);
      p_Var1 = me->target->isa->put_string;
      pcVar4 = (char *)gettext("Direct access");
      (*p_Var1)(me->target,pcVar4);
      (*me->target->isa->end_element)(me->target,0,(char **)0x0);
      p_Var1 = me->target->isa->put_string;
      pcVar4 = (char *)gettext(" (or via proxy server, if defined)");
      (*p_Var1)(me->target,pcVar4);
      if (pcVar3 != (char *)0x0) {
        free(pcVar3);
      }
      if (shortname != (char *)0x0) {
        free(shortname);
        shortname = (char *)0x0;
      }
    }
    if (tags[30].contents != SGML_EMPTY) {
      (*me->target->isa->end_element)(me->target,0x1e,(char **)0x0);
    }
  }
  if (me->par_value[8] != (char *)0x0) {
    (*me->target->isa->start_element)(me->target,0x25,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
    p_Var1 = me->target->isa->put_string;
    pcVar3 = (char *)gettext("Maintainer");
    (*p_Var1)(me->target,pcVar3);
    if (tags[37].contents != SGML_EMPTY) {
      (*me->target->isa->end_element)(me->target,0x25,(char **)0x0);
    }
    (*me->target->isa->start_element)(me->target,0x1e,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
    (*me->target->isa->put_string)(me->target,me->par_value[8]);
    if (tags[30].contents != SGML_EMPTY) {
      (*me->target->isa->end_element)(me->target,0x1e,(char **)0x0);
    }
  }
  if (me->par_value[2] != (char *)0x0) {
    (*me->target->isa->start_element)(me->target,0x25,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
    p_Var1 = me->target->isa->put_string;
    pcVar3 = (char *)gettext(&DAT_08190f9a);
    (*p_Var1)(me->target,pcVar3);
    if (tags[37].contents != SGML_EMPTY) {
      (*me->target->isa->end_element)(me->target,0x25,(char **)0x0);
    }
    (*me->target->isa->start_element)(me->target,0x1e,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
    (*me->target->isa->put_string)(me->target,me->par_value[2]);
    if (tags[30].contents != SGML_EMPTY) {
      (*me->target->isa->end_element)(me->target,0x1e,(char **)0x0);
    }
  }
  (*me->target->isa->end_element)(me->target,0x23,(char **)0x0);
  if (me->par_value[9] != (char *)0x0) {
    (*me->target->isa->start_element)(me->target,0x56,(BOOLEAN *)0x0,(char **)0x0,-1,(char **)0x0);
    (*me->target->isa->put_string)(me->target,me->par_value[9]);
    (*me->target->isa->end_element)(me->target,0x56,(char **)0x0);
  }
  (*me->target->isa->_free)(me->target);
  return;
}



// WARNING: Unknown calling convention

void WSRCParser_put_string(HTStream_conflict7 *context,char *str)

{
  char *p;
  
  for (p = str; *p != '\0'; p = p + 1) {
    WSRCParser_put_character(context,*p);
  }
  return;
}



// WARNING: Unknown calling convention

void WSRCParser_write(HTStream_conflict7 *context,char *str,int l)

{
  char *e;
  char *p;
  
  for (p = str; p < str + l; p = p + 1) {
    WSRCParser_put_character(context,*p);
  }
  return;
}



// WARNING: Unknown calling convention

void WSRCParser_free(HTStream_conflict7 *me)

{
  int p;
  
  WSRC_gen_html(me,'\x01');
  for (p = 0; par_name[p] != (char *)0x0; p = p + 1) {
    if (me->par_value[p] != (char *)0x0) {
      free(me->par_value[p]);
      me->par_value[p] = (char *)0x0;
    }
  }
  if (me != (HTStream_conflict7 *)0x0) {
    free(me);
  }
  return;
}



// WARNING: Unknown calling convention

void WSRCParser_abort(HTStream_conflict7 *me,HTError e)

{
  WSRCParser_free(me);
  return;
}



// WARNING: Unknown calling convention

HTStream_conflict7 *
HTWSRCConvert(HTPresentation_conflict4 *pres,HTParentAnchor *anchor,HTStream_conflict7 *sink)

{
  HTStream_conflict7 *pHVar1;
  HTStructured *pHVar2;
  int p;
  HTStream_conflict7 *me;
  
  pHVar1 = (HTStream_conflict7 *)malloc(0x2784);
  if (pHVar1 == (HTStream_conflict7 *)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTWSRC.c","HTWSRCConvert");
  }
  pHVar1->isa = &WSRCParserClass;
  pHVar2 = HTML_new(anchor,pres->rep_out,(HTStream_conflict *)sink);
  pHVar1->target = (HTStructured_conflict *)pHVar2;
  for (p = 0; p < 0x17; p = p + 1) {
    pHVar1->par_value[p] = (char *)0x0;
  }
  pHVar1->state = beginning;
  return pHVar1;
}



// WARNING: Unknown calling convention

void HTAAForwardAuth_set(char *scheme_name,char *scheme_specifics)

{
  size_t sVar1;
  int local_1c;
  size_t local_18;
  int len;
  
  if (scheme_name == (char *)0x0) {
    local_1c = 0x14;
  }
  else {
    sVar1 = strlen(scheme_name);
    local_1c = sVar1 + 0x14;
  }
  if (scheme_specifics == (char *)0x0) {
    local_18 = 0;
  }
  else {
    local_18 = strlen(scheme_specifics);
  }
  if (HTAAForwardAuth != (char *)0x0) {
    free(HTAAForwardAuth);
    HTAAForwardAuth = (char *)0x0;
  }
  HTAAForwardAuth = (char *)calloc(local_1c + local_18,1);
  if (HTAAForwardAuth == (char *)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTAABrow.c","HTAAForwardAuth_set");
  }
  memcpy(HTAAForwardAuth,"Authorization: ",0x10);
  if (scheme_name != (char *)0x0) {
    strcat(HTAAForwardAuth,scheme_name);
    strcat(HTAAForwardAuth," ");
    if (scheme_specifics != (char *)0x0) {
      strcat(HTAAForwardAuth,scheme_specifics);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void HTAAForwardAuth_reset(void)

{
  if (HTAAForwardAuth != (char *)0x0) {
    free(HTAAForwardAuth);
    HTAAForwardAuth = (char *)0x0;
  }
  return;
}



HTAAServer * HTAAServer_new(char *hostname,int portnumber,BOOLEAN IsProxy)

{
  HTAAServer *dest;
  HTList *pHVar1;
  int local_1c;
  BOOLEAN IsProxy_local;
  HTAAServer *server;
  
  dest = (HTAAServer *)calloc(1,0x14);
  if (dest == (HTAAServer *)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTAABrow.c","HTAAServer_new");
  }
  dest->hostname = (char *)0x0;
  if (portnumber < 1) {
    local_1c = 0x50;
  }
  else {
    local_1c = portnumber;
  }
  dest->portnumber = local_1c;
  dest->IsProxy = IsProxy;
  pHVar1 = HTList_new();
  dest->setups = pHVar1;
  pHVar1 = HTList_new();
  dest->realms = pHVar1;
  if (hostname != (char *)0x0) {
    HTSACopy((char **)dest,hostname);
  }
  if (server_table == (HTList *)0x0) {
    server_table = HTList_new();
  }
  HTList_addObject(server_table,dest);
  return dest;
}



// WARNING: Unknown calling convention

void HTAAServer_delete(HTAAServer *killme)

{
  HTAASetup *killme_00;
  void **local_28;
  HTList *cur;
  HTAARealm *realm;
  HTAASetup *setup;
  int i;
  int n;
  
  if (killme != (HTAAServer *)0x0) {
    if (killme->setups != (HTList *)0x0) {
      i = HTList_count(killme->setups);
      while (i = i + -1, -1 < i) {
        killme_00 = (HTAASetup *)HTList_objectAt(killme->setups,i);
        if (killme_00 != (HTAASetup *)0x0) {
          HTAASetup_delete(killme_00);
        }
      }
      HTList_delete(killme->setups);
      killme->setups = (HTList *)0x0;
    }
    cur = killme->realms;
    while( true ) {
      if ((cur == (HTList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
        local_28 = (void **)0x0;
      }
      else {
        local_28 = (void **)cur->object;
      }
      if (local_28 == (void **)0x0) break;
      if (*local_28 != (void *)0x0) {
        free(*local_28);
        *local_28 = (void *)0x0;
      }
      if (local_28[1] != (void *)0x0) {
        free(local_28[1]);
        local_28[1] = (void *)0x0;
      }
      if (local_28[2] != (void *)0x0) {
        free(local_28[2]);
        local_28[2] = (void *)0x0;
      }
      if (local_28 != (void **)0x0) {
        free(local_28);
      }
    }
    HTList_delete(killme->realms);
    killme->realms = (HTList *)0x0;
    if (killme->hostname != (char *)0x0) {
      free(killme->hostname);
      killme->hostname = (char *)0x0;
    }
    HTList_removeObject(server_table,killme);
    if (killme != (HTAAServer *)0x0) {
      free(killme);
    }
  }
  return;
}



HTAAServer * HTAAServer_lookup(char *hostname,int portnumber,BOOLEAN IsProxy)

{
  int iVar1;
  HTAAServer *local_20;
  HTAAServer *local_1c;
  BOOLEAN IsProxy_local;
  HTAAServer *server;
  HTList *cur;
  
  if (hostname == (char *)0x0) {
LAB_08144e03:
    local_20 = (HTAAServer *)0x0;
  }
  else {
    cur = server_table;
    if (portnumber < 1) {
      portnumber = 0x50;
    }
    do {
      if ((cur == (HTList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
        local_1c = (HTAAServer *)0x0;
      }
      else {
        local_1c = (HTAAServer *)cur->object;
      }
      local_20 = local_1c;
      if (local_1c == (HTAAServer *)0x0) goto LAB_08144e03;
    } while (((local_1c->portnumber != portnumber) ||
             (iVar1 = strcmp(local_1c->hostname,hostname), iVar1 != 0)) ||
            (local_1c->IsProxy != IsProxy));
  }
  return local_20;
}



HTAASetup * HTAASetup_lookup(char *hostname,int portnumber,char *docname,BOOLEAN IsProxy)

{
  char *pcVar1;
  BOOLEAN BVar2;
  HTAAServer *pHVar3;
  FILE *pFVar4;
  char *local_2c;
  HTAASetup *local_24;
  char *local_20;
  BOOLEAN IsProxy_local;
  HTList *cur;
  HTAASetup *setup;
  HTAAServer *server;
  
  if (portnumber < 1) {
    portnumber = 0x50;
  }
  if ((((hostname != (char *)0x0) && (docname != (char *)0x0)) && (*hostname != '\0')) &&
     ((*docname != '\0' &&
      (pHVar3 = HTAAServer_lookup(hostname,portnumber,IsProxy), pHVar3 != (HTAAServer *)0x0)))) {
    cur = pHVar3->setups;
    if (WWW_TraceFlag != '\0') {
      if (IsProxy == '\0') {
        local_2c = "server";
      }
      else {
        local_2c = "proxy";
      }
      pFVar4 = TraceFP();
      fprintf((FILE *)pFVar4,"%s %s (%s:%d:%s)\n","HTAASetup_lookup: resolving setup for",local_2c,
              hostname,portnumber,docname);
    }
    while( true ) {
      if ((cur == (HTList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
        local_24 = (HTAASetup *)0x0;
      }
      else {
        local_24 = (HTAASetup *)cur->object;
      }
      if (local_24 == (HTAASetup *)0x0) break;
      BVar2 = HTAA_templateMatch(local_24->ctemplate,docname);
      if (BVar2 != '\0') {
        if (WWW_TraceFlag != '\0') {
          pcVar1 = local_24->ctemplate;
          pFVar4 = TraceFP();
          fprintf((FILE *)pFVar4,"%s `%s\' %s `%s\'\n","HTAASetup_lookup:",docname,
                  "matched template",pcVar1);
        }
        return local_24;
      }
      if (WWW_TraceFlag != '\0') {
        pcVar1 = local_24->ctemplate;
        pFVar4 = TraceFP();
        fprintf((FILE *)pFVar4,"%s `%s\' %s `%s\'\n","HTAASetup_lookup:",docname,
                "did NOT match template",pcVar1);
      }
    }
  }
  if (WWW_TraceFlag != '\0') {
    if (docname == (char *)0x0) {
      local_20 = "(null)";
    }
    else {
      local_20 = docname;
    }
    pFVar4 = TraceFP();
    fprintf((FILE *)pFVar4,"%s `%s\' %s\n","HTAASetup_lookup: No template matched",local_20,
            "(so probably not protected)");
  }
  return (HTAASetup *)0x0;
}



// WARNING: Unknown calling convention

HTAASetup *
HTAASetup_new(HTAAServer *server,char *ctemplate,HTList *valid_schemes,
             HTAssocList **scheme_specifics)

{
  HTAASetup *local_18;
  HTAASetup *setup;
  
  if (((server == (HTAAServer *)0x0) || (ctemplate == (char *)0x0)) || (*ctemplate == '\0')) {
    local_18 = (HTAASetup *)0x0;
  }
  else {
    local_18 = (HTAASetup *)calloc(1,0x14);
    if (local_18 == (HTAASetup *)0x0) {
      outofmem("../../../WWW/Library/Implementation/HTAABrow.c","HTAASetup_new");
    }
    local_18->retry = '\0';
    local_18->server = server;
    local_18->ctemplate = (char *)0x0;
    if (ctemplate != (char *)0x0) {
      HTSACopy(&local_18->ctemplate,ctemplate);
    }
    local_18->valid_schemes = valid_schemes;
    local_18->scheme_specifics = scheme_specifics;
    HTList_addObject(server->setups,local_18);
  }
  return local_18;
}



// WARNING: Unknown calling convention

void HTAASetup_delete(HTAASetup *killme)

{
  int scheme;
  
  if (killme != (HTAASetup *)0x0) {
    if (killme->ctemplate != (char *)0x0) {
      free(killme->ctemplate);
      killme->ctemplate = (char *)0x0;
    }
    if (killme->valid_schemes != (HTList *)0x0) {
      HTList_delete(killme->valid_schemes);
      killme->valid_schemes = (HTList *)0x0;
    }
    for (scheme = 0; scheme < 6; scheme = scheme + 1) {
      if (killme->scheme_specifics[scheme] != (HTAssocList *)0x0) {
        HTAssocList_delete(killme->scheme_specifics[scheme]);
      }
    }
    if (killme->scheme_specifics != (HTAssocList **)0x0) {
      free(killme->scheme_specifics);
      killme->scheme_specifics = (HTAssocList **)0x0;
    }
    if (killme != (HTAASetup *)0x0) {
      free(killme);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void HTAASetup_updateSpecifics(HTAASetup *setup,HTAssocList **specifics)

{
  int scheme;
  
  if (setup != (HTAASetup *)0x0) {
    if (setup->scheme_specifics != (HTAssocList **)0x0) {
      for (scheme = 0; scheme < 6; scheme = scheme + 1) {
        if (setup->scheme_specifics[scheme] != (HTAssocList *)0x0) {
          HTAssocList_delete(setup->scheme_specifics[scheme]);
        }
      }
      if (setup->scheme_specifics != (HTAssocList **)0x0) {
        free(setup->scheme_specifics);
        setup->scheme_specifics = (HTAssocList **)0x0;
      }
    }
    setup->scheme_specifics = specifics;
  }
  return;
}



// WARNING: Unknown calling convention

HTAARealm * HTAARealm_lookup(HTList *realm_table,char *realmname)

{
  int iVar1;
  HTAARealm *local_1c;
  HTAARealm *local_18;
  HTAARealm *realm;
  HTList *cur;
  
  if ((realm_table == (HTList *)0x0) || (realmname == (char *)0x0)) {
LAB_081452b2:
    local_1c = (HTAARealm *)0x0;
  }
  else {
    cur = realm_table;
    do {
      if ((cur == (HTList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
        local_18 = (HTAARealm *)0x0;
      }
      else {
        local_18 = (HTAARealm *)cur->object;
      }
      local_1c = local_18;
      if (local_18 == (HTAARealm *)0x0) goto LAB_081452b2;
      iVar1 = strcmp(local_18->realmname,realmname);
    } while (iVar1 != 0);
  }
  return local_1c;
}



// WARNING: Unknown calling convention

HTAARealm * HTAARealm_new(HTList *realm_table,char *realmname,char *username,char *password)

{
  HTAARealm *realm;
  
  realm = HTAARealm_lookup(realm_table,realmname);
  if (realm == (HTAARealm *)0x0) {
    realm = (HTAARealm *)calloc(1,0xc);
    if (realm == (HTAARealm *)0x0) {
      outofmem("../../../WWW/Library/Implementation/HTAABrow.c","HTAARealm_new");
    }
    realm->realmname = (char *)0x0;
    realm->username = (char *)0x0;
    realm->password = (char *)0x0;
    HTSACopy((char **)realm,realmname);
    if (realm_table != (HTList *)0x0) {
      HTList_addObject(realm_table,realm);
    }
  }
  if (username != (char *)0x0) {
    HTSACopy(&realm->username,username);
  }
  if (password != (char *)0x0) {
    HTSACopy(&realm->password,password);
  }
  return realm;
}



char * compose_auth_string(HTAAScheme scheme,HTAASetup *setup,BOOLEAN IsProxy)

{
  char *pcVar1;
  FILE *__stream;
  size_t sVar2;
  size_t sVar3;
  char *fmt;
  char *local_6c;
  char *local_68;
  char *local_64;
  char *local_60;
  char *local_5c;
  char *local_54;
  char *local_50;
  BOOLEAN IsProxy_local;
  char *timestamp;
  char *i_net_addr;
  HTAARealm *realm;
  char *thePort;
  char *proxiedHost;
  char *theHost;
  char *realmname;
  char *password;
  char *username;
  char *msg;
  int len;
  char *ciphertext;
  char *cleartext;
  
  cleartext = (char *)0x0;
  ciphertext = (char *)0x0;
  msg = (char *)0x0;
  username = (char *)0x0;
  password = (char *)0x0;
  realmname = (char *)0x0;
  theHost = (char *)0x0;
  proxiedHost = (char *)0x0;
  thePort = (char *)0x0;
  if (compose_auth_stringResult != (char *)0x0) {
    free(compose_auth_stringResult);
    compose_auth_stringResult = (char *)0x0;
  }
  if (((((scheme != HTAA_BASIC) && (scheme != HTAA_PUBKEY)) || (setup == (HTAASetup *)0x0)) ||
      ((setup->scheme_specifics == (HTAssocList **)0x0 ||
       (setup->scheme_specifics[scheme] == (HTAssocList *)0x0)))) ||
     ((setup->server == (HTAAServer *)0x0 || (setup->server->realms == (HTList *)0x0)))) {
    return (char *)0x0;
  }
  realmname = HTAssocList_lookup(setup->scheme_specifics[scheme],"realm");
  if (realmname == (char *)0x0) {
    return (char *)0x0;
  }
  realm = HTAARealm_lookup(setup->server->realms,realmname);
  if (((realm == (HTAARealm *)0x0) || (realm->username == (char *)0x0)) ||
     ((*realm->username == '\0' || ((realm->password == (char *)0x0 || (setup->retry != '\0')))))) {
    if (realm == (HTAARealm *)0x0) {
      if (WWW_TraceFlag != '\0') {
        __stream = TraceFP();
        fprintf((FILE *)__stream,"%s `%s\' %s\n","compose_auth_string: realm:",realmname,
                "not found -- creating");
      }
      realm = HTAARealm_new(setup->server->realms,realmname,(char *)0x0,(char *)0x0);
    }
    if ((((IsProxy == '\0') && (using_proxy != '\0')) && (setup->ctemplate != (char *)0x0)) &&
       ((proxiedHost = HTParse(setup->ctemplate,"",8), proxiedHost != (char *)0x0 &&
        (*proxiedHost != '\0')))) {
      theHost = proxiedHost;
    }
    if (theHost == (char *)0x0) {
      theHost = setup->server->hostname;
    }
    if ((0 < setup->server->portnumber) && (setup->server->portnumber != 0x50)) {
      HTSprintf0(&thePort,":%d",setup->server->portnumber);
    }
    sVar2 = strlen(realm->realmname);
    if (theHost == (char *)0x0) {
      local_6c = "??";
    }
    else {
      local_6c = theHost;
    }
    sVar3 = strlen(local_6c);
    len = sVar3 + sVar2 + 0x32;
    if (thePort == (char *)0x0) {
      local_68 = "";
    }
    else {
      local_68 = thePort;
    }
    if (theHost == (char *)0x0) {
      local_64 = "??";
    }
    else {
      local_64 = theHost;
    }
    if (IsProxy == '\0') {
      local_60 = "server";
    }
    else {
      local_60 = "proxy";
    }
    pcVar1 = realm->realmname;
    fmt = (char *)gettext("Username for \'%s\' at %s \'%s%s\':");
    HTSprintf0(&msg,fmt,pcVar1,local_60,local_64,local_68);
    if (proxiedHost != (char *)0x0) {
      free(proxiedHost);
      proxiedHost = (char *)0x0;
    }
    if (thePort != (char *)0x0) {
      free(thePort);
      thePort = (char *)0x0;
    }
    username = realm->username;
    password = (char *)0x0;
    HTPromptUsernameAndPassword(msg,&username,&password,IsProxy);
    if (msg != (char *)0x0) {
      free(msg);
      msg = (char *)0x0;
    }
    if (realm->username != (char *)0x0) {
      free(realm->username);
      realm->username = (char *)0x0;
    }
    if (realm->password != (char *)0x0) {
      free(realm->password);
      realm->password = (char *)0x0;
    }
    realm->username = username;
    realm->password = password;
    if ((realm->username == (char *)0x0) || (realm->password == (char *)0x0)) {
      return (char *)0x0;
    }
    if (*realm->username == '\0') {
      HTSACopy(&compose_auth_stringResult,"");
      return compose_auth_stringResult;
    }
  }
  if (realm->username == (char *)0x0) {
    local_5c = "";
  }
  else {
    local_5c = realm->username;
  }
  sVar2 = strlen(local_5c);
  if (realm->password == (char *)0x0) {
    local_54 = "";
  }
  else {
    local_54 = realm->password;
  }
  sVar3 = strlen(local_54);
  len = sVar3 + sVar2 + 3;
  if (scheme == HTAA_PUBKEY) {
    if (secret_key == (char *)0x0) {
      local_50 = "";
    }
    else {
      local_50 = secret_key;
    }
    sVar2 = strlen(local_50);
    len = sVar2 + len + 0x1e;
  }
  else if (secret_key != (char *)0x0) {
    free(secret_key);
    secret_key = (char *)0x0;
  }
  cleartext = (char *)calloc(len,1);
  if (cleartext == (char *)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTAABrow.c","compose_auth_string");
  }
  if (realm->username == (char *)0x0) {
    *cleartext = '\0';
  }
  else {
    strcpy(cleartext,realm->username);
  }
  strcat(cleartext,":");
  if (realm->password != (char *)0x0) {
    strcat(cleartext,realm->password);
  }
  if (scheme == HTAA_PUBKEY) {
    strcat(cleartext,":");
    strcat(cleartext,"0.0.0.0");
    strcat(cleartext,":");
    strcat(cleartext,"42");
    strcat(cleartext,":");
    if (secret_key != (char *)0x0) {
      strcat(cleartext,secret_key);
    }
    ciphertext = (char *)calloc(len * 2,1);
    if ((ciphertext == (char *)0x0) ||
       (compose_auth_stringResult = (char *)calloc(len * 3,1),
       compose_auth_stringResult == (char *)0x0)) {
      outofmem("../../../WWW/Library/Implementation/HTAABrow.c","compose_auth_string");
    }
    if (cleartext != (char *)0x0) {
      free(cleartext);
      cleartext = (char *)0x0;
    }
    if (ciphertext != (char *)0x0) {
      free(ciphertext);
    }
  }
  else {
    compose_auth_stringResult = (char *)calloc(((len + 2) / 3) * 4 + 1,1);
    if (compose_auth_stringResult == (char *)0x0) {
      outofmem("../../../WWW/Library/Implementation/HTAABrow.c","compose_auth_string");
    }
    pcVar1 = compose_auth_stringResult;
    sVar2 = strlen(cleartext);
    HTUU_encode((uchar *)cleartext,sVar2,pcVar1);
    if (cleartext != (char *)0x0) {
      free(cleartext);
    }
  }
  return compose_auth_stringResult;
}



// WARNING: Unknown calling convention

HTAAScheme HTAA_selectScheme(HTAASetup *setup)

{
  int iVar1;
  void *object;
  int scheme;
  
  if ((setup != (HTAASetup *)0x0) && (setup->valid_schemes != (HTList *)0x0)) {
    for (scheme = 2; scheme < 6; scheme = scheme + 1) {
      iVar1 = HTList_indexOf(setup->valid_schemes,(void *)scheme);
      if (-1 < iVar1) {
        return scheme;
      }
    }
  }
  return HTAA_BASIC;
}



// WARNING: Unknown calling convention

void free_HTAAGlobals(void)

{
  HTAAServer *killme;
  int i;
  int n;
  HTAAServer *server;
  
  if (server_table != (HTList *)0x0) {
    i = HTList_count(server_table);
    while (i = i + -1, -1 < i) {
      killme = (HTAAServer *)HTList_objectAt(server_table,i);
      if (killme != (HTAAServer *)0x0) {
        HTAAServer_delete(killme);
      }
    }
    HTList_delete(server_table);
    server_table = (HTList *)0x0;
  }
  HTAAForwardAuth_reset();
  if (HTAA_composeAuthResult != (char *)0x0) {
    free(HTAA_composeAuthResult);
    HTAA_composeAuthResult = (char *)0x0;
  }
  if (current_hostname != (char *)0x0) {
    free(current_hostname);
    current_hostname = (char *)0x0;
  }
  if (current_docname != (char *)0x0) {
    free(current_docname);
    current_docname = (char *)0x0;
  }
  if (proxy_hostname != (char *)0x0) {
    free(proxy_hostname);
    proxy_hostname = (char *)0x0;
  }
  if (proxy_docname != (char *)0x0) {
    free(proxy_docname);
    proxy_docname = (char *)0x0;
  }
  if (compose_auth_stringResult != (char *)0x0) {
    free(compose_auth_stringResult);
    compose_auth_stringResult = (char *)0x0;
  }
  if (secret_key != (char *)0x0) {
    free(secret_key);
    secret_key = (char *)0x0;
  }
  return;
}



char * HTAA_composeAuth(char *hostname,int portnumber,char *docname,BOOLEAN IsProxy)

{
  FILE *pFVar1;
  int iVar2;
  undefined4 uVar3;
  size_t sVar4;
  char *pcVar5;
  size_t sVar6;
  BOOLEAN IsProxy_local;
  char *msg;
  int len;
  HTAAScheme scheme;
  char *auth_string;
  BOOLEAN retry;
  
  if (free_HTAAGlobalsSet == '\0') {
    free_HTAAGlobalsSet = '\x01';
  }
  if (HTAAForwardAuth != (char *)0x0) {
    if (WWW_TraceFlag != '\0') {
      pFVar1 = TraceFP();
      fprintf((FILE *)pFVar1,"HTAA_composeAuth: %s\n","Forwarding received authorization");
    }
    HTSACopy(&HTAA_composeAuthResult,HTAAForwardAuth);
    HTAAForwardAuth_reset();
    return HTAA_composeAuthResult;
  }
  if (HTAA_composeAuthResult != (char *)0x0) {
    free(HTAA_composeAuthResult);
    HTAA_composeAuthResult = (char *)0x0;
  }
  if (IsProxy == '\0') {
    if (WWW_TraceFlag != '\0') {
      pFVar1 = TraceFP();
      fprintf((FILE *)pFVar1,"Composing Authorization for %s:%d/%s\n",hostname,portnumber,docname);
    }
    if (((((current_portnumber == portnumber) && (current_hostname != (char *)0x0)) &&
         (current_docname != (char *)0x0)) &&
        ((hostname != (char *)0x0 && (docname != (char *)0x0)))) &&
       ((iVar2 = strcmp(current_hostname,hostname), iVar2 == 0 &&
        (iVar2 = strcmp(current_docname,docname), iVar2 == 0)))) {
      retry = '\x01';
    }
    else {
      retry = '\0';
      current_portnumber = portnumber;
      if (hostname == (char *)0x0) {
        if (current_hostname != (char *)0x0) {
          free(current_hostname);
          current_hostname = (char *)0x0;
        }
      }
      else {
        HTSACopy(&current_hostname,hostname);
      }
      if (docname == (char *)0x0) {
        if (current_docname != (char *)0x0) {
          free(current_docname);
          current_docname = (char *)0x0;
        }
      }
      else {
        HTSACopy(&current_docname,docname);
      }
    }
    if ((current_setup == (HTAASetup *)0x0) || (retry == '\0')) {
      current_setup = HTAASetup_lookup(hostname,portnumber,docname,'\0');
    }
    if (current_setup == (HTAASetup *)0x0) {
      return (char *)0x0;
    }
    scheme = HTAA_selectScheme(current_setup);
    if (scheme + ~HTAA_NONE < 2) {
      auth_string = compose_auth_string(scheme,current_setup,'\0');
    }
    else {
      msg = (char *)0x0;
      pcVar5 = HTAAScheme_name(scheme);
      uVar3 = gettext(
                     "This client doesn\'t know how to compose authorization information for scheme"
                     );
      HTSprintf0(&msg,"%s `%s\'",uVar3,pcVar5);
      HTAlert(msg);
      if (msg != (char *)0x0) {
        free(msg);
        msg = (char *)0x0;
      }
      auth_string = (char *)0x0;
    }
    current_setup->retry = '\0';
    if (auth_string == (char *)0x0) {
      return (char *)0x0;
    }
    if (*auth_string == '\0') {
      HTSACopy(&HTAA_composeAuthResult,"");
      return HTAA_composeAuthResult;
    }
    sVar4 = strlen(auth_string);
    pcVar5 = HTAAScheme_name(scheme);
    sVar6 = strlen(pcVar5);
    len = sVar4 + sVar6 + 0x14;
    HTAA_composeAuthResult = (char *)calloc(len,1);
    if (HTAA_composeAuthResult == (char *)0x0) {
      outofmem("../../../WWW/Library/Implementation/HTAABrow.c","HTAA_composeAuth");
    }
    memcpy(HTAA_composeAuthResult,"Authorization: ",0x10);
  }
  else {
    if (WWW_TraceFlag != '\0') {
      pFVar1 = TraceFP();
      fprintf((FILE *)pFVar1,"Composing Proxy Authorization for %s:%d/%s\n",hostname,portnumber,
              docname);
    }
    if ((((proxy_portnumber == portnumber) && (proxy_hostname != (char *)0x0)) &&
        (proxy_docname != (char *)0x0)) &&
       (((hostname != (char *)0x0 && (docname != (char *)0x0)) &&
        ((iVar2 = strcmp(proxy_hostname,hostname), iVar2 == 0 &&
         (iVar2 = strcmp(proxy_docname,docname), iVar2 == 0)))))) {
      retry = '\x01';
    }
    else {
      retry = '\0';
      proxy_portnumber = portnumber;
      if (hostname == (char *)0x0) {
        if (proxy_hostname != (char *)0x0) {
          free(proxy_hostname);
          proxy_hostname = (char *)0x0;
        }
      }
      else {
        HTSACopy(&proxy_hostname,hostname);
      }
      if (docname == (char *)0x0) {
        if (proxy_docname != (char *)0x0) {
          free(proxy_docname);
          proxy_docname = (char *)0x0;
        }
      }
      else {
        HTSACopy(&proxy_docname,docname);
      }
    }
    if ((proxy_setup == (HTAASetup *)0x0) || (retry == '\0')) {
      proxy_setup = HTAASetup_lookup(hostname,portnumber,docname,IsProxy);
    }
    if (proxy_setup == (HTAASetup *)0x0) {
      return (char *)0x0;
    }
    scheme = HTAA_selectScheme(proxy_setup);
    if (scheme + ~HTAA_NONE < 2) {
      auth_string = compose_auth_string(scheme,proxy_setup,IsProxy);
    }
    else {
      msg = (char *)0x0;
      pcVar5 = HTAAScheme_name(scheme);
      uVar3 = gettext(
                     "This client doesn\'t know how to compose proxy authorization information for scheme"
                     );
      HTSprintf0(&msg,"%s `%s\'",uVar3,pcVar5);
      HTAlert(msg);
      if (msg != (char *)0x0) {
        free(msg);
        msg = (char *)0x0;
      }
      auth_string = (char *)0x0;
    }
    proxy_setup->retry = '\0';
    if (auth_string == (char *)0x0) {
      return (char *)0x0;
    }
    if (*auth_string == '\0') {
      HTSACopy(&HTAA_composeAuthResult,"");
      return HTAA_composeAuthResult;
    }
    sVar4 = strlen(auth_string);
    pcVar5 = HTAAScheme_name(scheme);
    sVar6 = strlen(pcVar5);
    len = sVar4 + sVar6 + 0x1a;
    HTAA_composeAuthResult = (char *)calloc(len,1);
    if (HTAA_composeAuthResult == (char *)0x0) {
      outofmem("../../../WWW/Library/Implementation/HTAABrow.c","HTAA_composeAuth");
    }
    memcpy(HTAA_composeAuthResult,"Proxy-Authorization: ",0x16);
  }
  pcVar5 = HTAAScheme_name(scheme);
  strcat(HTAA_composeAuthResult,pcVar5);
  strcat(HTAA_composeAuthResult," ");
  strcat(HTAA_composeAuthResult,auth_string);
  return HTAA_composeAuthResult;
}



BOOLEAN HTAA_shouldRetryWithAuth(char *start_of_headers,int length,int soc,BOOLEAN IsProxy)

{
  BOOLEAN BVar1;
  FILE *pFVar2;
  char *a;
  int iVar3;
  HTList *pHVar4;
  char *pcVar5;
  HTList **ppHVar6;
  char *local_68;
  undefined *local_64;
  char *local_60;
  undefined *local_5c;
  char *local_58;
  char *local_54;
  BOOLEAN local_4d;
  BOOLEAN IsProxy_local;
  HTAAServer *server_1;
  HTAAServer *server;
  int i;
  char *args;
  char *arg1;
  char *fieldname;
  char *p;
  char *temp;
  char *ctemplate;
  HTAssocList **scheme_specifics;
  HTList *valid_schemes;
  int num_schemes;
  char *line;
  HTAAScheme scheme;
  
  line = (char *)0x0;
  num_schemes = 0;
  valid_schemes = HTList_new();
  scheme_specifics = (HTAssocList **)0x0;
  ctemplate = (char *)0x0;
  temp = (char *)0x0;
  if (free_HTAAGlobalsSet == '\0') {
    free_HTAAGlobalsSet = '\x01';
  }
  if (WWW_TraceFlag != '\0') {
    pFVar2 = TraceFP();
    fprintf((FILE *)pFVar2,"Server reply header lines:\n");
  }
  HTAA_setupReader(start_of_headers,length,soc);
  while ((line = HTAA_getUnfoldedLine(), line != (char *)0x0 && (*line != '\0'))) {
    if (WWW_TraceFlag != '\0') {
      pFVar2 = TraceFP();
      fprintf((FILE *)pFVar2,"%s\n",line);
    }
    pcVar5 = strchr(line,0x3a);
    if (pcVar5 == (char *)0x0) {
      if (WWW_TraceFlag != '\0') {
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2,"Invalid header line `%s\' ignored\n",line);
      }
    }
    else {
      p = line;
      a = HTNextField(&p);
      local_54 = HTNextField(&p);
      pcVar5 = p;
      if (((IsProxy == '\0') || (iVar3 = strcasecomp(a,"Proxy-Authenticate:"), iVar3 != 0)) &&
         ((IsProxy != '\0' || (iVar3 = strcasecomp(a,"WWW-Authenticate:"), iVar3 != 0)))) {
        if ((IsProxy == '\0') && (iVar3 = strcasecomp(a,"WWW-Protection-Template:"), iVar3 == 0)) {
          if (WWW_TraceFlag != '\0') {
            pFVar2 = TraceFP();
            fprintf((FILE *)pFVar2,"Protection template set to `%s\'\n",local_54);
          }
          HTSACopy(&ctemplate,local_54);
        }
      }
      else if ((((local_54 == (char *)0x0) || (*local_54 == '\0')) || (pcVar5 == (char *)0x0)) ||
              (*pcVar5 == '\0')) {
        if ((pcVar5 == (char *)0x0) || (*pcVar5 == '\0')) {
          local_68 = "";
        }
        else {
          local_68 = pcVar5;
        }
        if ((pcVar5 == (char *)0x0) || (*pcVar5 == '\0')) {
          local_64 = &DAT_08191195;
        }
        else {
          local_64 = &DAT_0819103b;
        }
        if ((local_54 == (char *)0x0) || (local_60 = local_54, *local_54 == '\0')) {
          local_60 = "";
        }
        if ((local_54 == (char *)0x0) || (*local_54 == '\0')) {
          local_5c = &DAT_08191195;
        }
        else {
          local_5c = &DAT_0819103b;
        }
        pcVar5 = (char *)gettext("Invalid header \'%s%s%s%s%s\'");
        HTSprintf0(&temp,pcVar5,line,local_5c,local_60,local_64,local_68);
        HTAlert(temp);
        if (temp != (char *)0x0) {
          free(temp);
          temp = (char *)0x0;
        }
      }
      else {
        scheme = HTAAScheme_enum(local_54);
        if ((void *)scheme == (void *)0x0) {
          if (WWW_TraceFlag != '\0') {
            if (IsProxy == '\0') {
              local_58 = "in WWW-Authenticate: field";
            }
            else {
              local_58 = "in Proxy-Authenticate: field";
            }
            if (local_54 == (char *)0x0) {
              local_54 = "(null)";
            }
            pFVar2 = TraceFP();
            fprintf((FILE *)pFVar2,"Unknown scheme `%s\' %s\n",local_54,local_58);
          }
        }
        else {
          HTList_addObject(valid_schemes,(void *)scheme);
          if (scheme_specifics == (HTAssocList **)0x0) {
            scheme_specifics = (HTAssocList **)calloc(6,4);
            if (scheme_specifics == (HTAssocList **)0x0) {
              outofmem("../../../WWW/Library/Implementation/HTAABrow.c","HTAA_shouldRetryWithAuth");
            }
            for (i = 0; i < 6; i = i + 1) {
              scheme_specifics[i] = (HTAssocList *)0x0;
            }
          }
          ppHVar6 = scheme_specifics + scheme;
          pHVar4 = HTAA_parseArgList(pcVar5);
          *ppHVar6 = pHVar4;
          num_schemes = num_schemes + 1;
        }
      }
    }
    if (line != (char *)0x0) {
      free(line);
      line = (char *)0x0;
    }
  }
  if (line != (char *)0x0) {
    free(line);
    line = (char *)0x0;
  }
  if (IsProxy == '\0') {
    if (num_schemes == 0) {
      current_setup = (HTAASetup *)0x0;
      local_4d = '\0';
    }
    else if ((current_setup == (HTAASetup *)0x0) || (current_setup->server == (HTAAServer *)0x0)) {
      server_1 = HTAAServer_lookup(current_hostname,current_portnumber,'\0');
      if (server_1 == (HTAAServer *)0x0) {
        server_1 = HTAAServer_new(current_hostname,current_portnumber,'\0');
      }
      if (ctemplate == (char *)0x0) {
        ctemplate = HTAA_makeProtectionTemplate(current_docname);
      }
      current_setup = HTAASetup_new(server_1,ctemplate,valid_schemes,scheme_specifics);
      if (ctemplate != (char *)0x0) {
        free(ctemplate);
        ctemplate = (char *)0x0;
      }
      pcVar5 = (char *)gettext("Access without authorization denied -- retrying");
      HTAlert(pcVar5);
      local_4d = '\x01';
    }
    else {
      HTAASetup_updateSpecifics(current_setup,scheme_specifics);
      pcVar5 = (char *)gettext("Authorization failed.  Retry?");
      BVar1 = HTConfirm(pcVar5);
      if (BVar1 == '\0') {
        current_setup = (HTAASetup *)0x0;
        local_4d = '\0';
      }
      else {
        current_setup->retry = '\x01';
        local_4d = '\x01';
      }
    }
  }
  else if (num_schemes == 0) {
    proxy_setup = (HTAASetup *)0x0;
    local_4d = '\0';
  }
  else if ((proxy_setup == (HTAASetup *)0x0) || (proxy_setup->server == (HTAAServer *)0x0)) {
    server = HTAAServer_lookup(proxy_hostname,proxy_portnumber,IsProxy);
    if (server == (HTAAServer *)0x0) {
      server = HTAAServer_new(proxy_hostname,proxy_portnumber,IsProxy);
    }
    if (ctemplate == (char *)0x0) {
      HTSACopy(&ctemplate,"*");
    }
    proxy_setup = HTAASetup_new(server,ctemplate,valid_schemes,scheme_specifics);
    if (ctemplate != (char *)0x0) {
      free(ctemplate);
      ctemplate = (char *)0x0;
    }
    pcVar5 = (char *)gettext("Proxy authorization required -- retrying");
    HTAlert(pcVar5);
    local_4d = '\x01';
  }
  else {
    HTAASetup_updateSpecifics(proxy_setup,scheme_specifics);
    pcVar5 = (char *)gettext("Authorization failed.  Retry?");
    BVar1 = HTConfirm(pcVar5);
    if (BVar1 == '\0') {
      proxy_setup = (HTAASetup *)0x0;
      local_4d = '\0';
    }
    else {
      proxy_setup->retry = '\x01';
      local_4d = '\x01';
    }
  }
  return local_4d;
}



// WARNING: Unknown calling convention

void HTClearHTTPAuthInfo(void)

{
  free_HTAAGlobals();
  free_HTAAGlobalsSet = '\0';
  return;
}



// WARNING: Unknown calling convention

BOOLEAN isNumber(char *s)

{
  BOOLEAN local_15;
  char *cur;
  
  cur = s;
  if ((s == (char *)0x0) || (*s == '\0')) {
    local_15 = '\0';
  }
  else {
    if (*s == '-') {
      cur = s + 1;
    }
    for (; *cur != '\0'; cur = cur + 1) {
      if ((*cur < '0') || ('9' < *cur)) {
        return '\0';
      }
    }
    local_15 = '\x01';
  }
  return local_15;
}



// WARNING: Unknown calling convention

int HTAA_getUid(void)

{
  BOOLEAN BVar1;
  int iVar2;
  char *pcVar3;
  int local_18;
  int uid;
  
  if ((current_prot != (HTAAProt *)0x0) && (current_prot->uid_name != (char *)0x0)) {
    BVar1 = isNumber(current_prot->uid_name);
    if (BVar1 == '\0') {
      iVar2 = HTAA_NameToUid(current_prot->uid_name);
      if (iVar2 != 0xfffd) {
        return iVar2;
      }
    }
    else {
      iVar2 = atoi(current_prot->uid_name);
      pcVar3 = HTAA_UidToName(iVar2);
      if (*pcVar3 != '\0') {
        return iVar2;
      }
    }
  }
  local_18 = HTAA_NameToUid("nobody");
  if (local_18 == 0xfffd) {
    local_18 = 0xfffe;
  }
  return local_18;
}



// WARNING: Unknown calling convention

int HTAA_getGid(void)

{
  BOOLEAN BVar1;
  int iVar2;
  char *pcVar3;
  int local_18;
  int gid;
  
  if ((current_prot != (HTAAProt *)0x0) && (current_prot->gid_name != (char *)0x0)) {
    BVar1 = isNumber(current_prot->gid_name);
    if (BVar1 == '\0') {
      iVar2 = HTAA_NameToGid(current_prot->gid_name);
      if (iVar2 != 0xfffd) {
        return iVar2;
      }
    }
    else {
      iVar2 = atoi(current_prot->gid_name);
      pcVar3 = HTAA_GidToName(iVar2);
      if (*pcVar3 != '\0') {
        return iVar2;
      }
    }
  }
  local_18 = HTAA_NameToGid("nogroup");
  if (local_18 == 0xfffd) {
    local_18 = 0xfffe;
  }
  return local_18;
}



// WARNING: Unknown calling convention

void HTAA_setIds(HTAAProt *prot,char *ids)

{
  char *pcVar1;
  char *point;
  char *local_copy;
  
  if (ids == (char *)0x0) {
    HTSACopy(&prot->uid_name,"nobody");
    HTSACopy(&prot->gid_name,"nogroup");
  }
  else {
    local_copy = (char *)0x0;
    HTSACopy(&local_copy,ids);
    pcVar1 = strchr(local_copy,0x2e);
    if (pcVar1 == (char *)0x0) {
      HTSACopy(&prot->gid_name,"nogroup");
    }
    else {
      *pcVar1 = '\0';
      HTSACopy(&prot->gid_name,pcVar1 + 1);
    }
    HTSACopy(&prot->uid_name,local_copy);
    if (local_copy != (char *)0x0) {
      free(local_copy);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void HTAA_parseProtFile(HTAAProt *prot,FILE *fp)

{
  int iVar1;
  void *newObject;
  HTList *pHVar2;
  char *pcVar3;
  GroupDef *pGVar4;
  HTAssocList *pHVar5;
  FILE *pFVar6;
  HTAAScheme scheme;
  char *fieldname;
  LexItem lex_item;
  
  if ((prot != (HTAAProt *)0x0) && (fp != (FILE *)0x0)) {
    fieldname = (char *)0x0;
LAB_08146fc5:
    lex_item = lex(fp);
    if (lex_item != LEX_EOF) {
      while (lex_item == LEX_REC_SEP) {
        lex_item = lex(fp);
      }
      if (lex_item == LEX_EOF) goto LAB_08146fdd;
      if (lex_item == LEX_ALPH_STR) {
        HTSACopy(&fieldname,HTlex_buffer);
        lex_item = lex(fp);
        if (lex_item != LEX_FIELD_SEP) {
          unlex(lex_item);
        }
        iVar1 = strncasecomp(fieldname,"Auth",4);
        if (iVar1 == 0) {
          lex_item = lex(fp);
          while (lex_item == LEX_ALPH_STR) {
            newObject = (void *)HTAAScheme_enum(HTlex_buffer);
            if (newObject == (void *)0x0) {
              if (WWW_TraceFlag != '\0') {
                pFVar6 = TraceFP();
                fprintf((FILE *)pFVar6,"%s %s `%s\'\n","HTAA_parseProtFile: unknown",
                        "authentication scheme:",HTlex_buffer);
              }
            }
            else {
              if (prot->valid_schemes == (HTList *)0x0) {
                pHVar2 = HTList_new();
                prot->valid_schemes = pHVar2;
              }
              HTList_addObject(prot->valid_schemes,newObject);
              if (WWW_TraceFlag != '\0') {
                pcVar3 = HTAAScheme_name((HTAAScheme)newObject);
                pFVar6 = TraceFP();
                fprintf((FILE *)pFVar6,"%s %s `%s\'\n","HTAA_parseProtFile: valid",
                        "authentication scheme:",pcVar3);
              }
            }
            lex_item = lex(fp);
            if (lex_item != LEX_ITEM_SEP) break;
            do {
              lex_item = lex(fp);
            } while (lex_item == LEX_REC_SEP);
          }
        }
        else {
          iVar1 = strncasecomp(fieldname,"mask",4);
          if (iVar1 == 0) {
            pGVar4 = HTAA_parseGroupDef(fp);
            prot->mask_group = pGVar4;
            lex_item = LEX_REC_SEP;
            if (WWW_TraceFlag != '\0') {
              if (prot->mask_group == (GroupDef *)0x0) {
                pFVar6 = TraceFP();
                fwrite("HTAA_parseProtFile: Mask group syntax error\n",1,0x2c,(FILE *)pFVar6);
              }
              else {
                pFVar6 = TraceFP();
                fwrite("HTAA_parseProtFile: Mask group:\n",1,0x20,(FILE *)pFVar6);
                HTAA_printGroupDef(prot->mask_group);
              }
            }
          }
          else {
            lex_item = lex(fp);
            if (lex_item == LEX_ALPH_STR) {
              if (prot->values == (HTAssocList *)0x0) {
                pHVar5 = HTAssocList_new();
                prot->values = pHVar5;
              }
              HTAssocList_add(prot->values,fieldname,HTlex_buffer);
              lex_item = lex(fp);
              pcVar3 = fieldname;
              if (WWW_TraceFlag != '\0') {
                pFVar6 = TraceFP();
                fprintf((FILE *)pFVar6,"%s `%s\' bound to value `%s\'\n","HTAA_parseProtFile: Name",
                        pcVar3,HTlex_buffer);
              }
            }
          }
        }
      }
      iVar1 = HTlex_line;
      if ((lex_item != LEX_EOF) && (lex_item != LEX_REC_SEP)) {
        if (WWW_TraceFlag != '\0') {
          pFVar6 = TraceFP();
          fprintf((FILE *)pFVar6,"%s %s %d (that line ignored)\n","HTAA_parseProtFile: Syntax error"
                  ,"in protection setup file at line",iVar1);
        }
        do {
          lex_item = lex(fp);
          if (lex_item == LEX_EOF) break;
        } while (lex_item != LEX_REC_SEP);
      }
      goto LAB_08146fc5;
    }
LAB_08146fdd:
    if (fieldname != (char *)0x0) {
      free(fieldname);
    }
  }
  return;
}



// WARNING: Unknown calling convention

HTAAProt * HTAAProt_new(char *cur_docname,char *prot_filename,char *ids)

{
  int iVar1;
  FILE *pFVar2;
  HTList *pHVar3;
  HTAssocList *pHVar4;
  FILE *fp_00;
  char **dest;
  char **local_1c;
  char *local_18;
  FILE *fp;
  HTAAProt *prot;
  HTAAProtCache *cache_item;
  HTList *cur;
  
  cur = prot_cache;
  if (prot_cache == (HTList *)0x0) {
    prot_cache = HTList_new();
  }
  do {
    if ((cur == (HTList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
      local_1c = (char **)0x0;
    }
    else {
      local_1c = (char **)cur->object;
    }
    if (local_1c == (char **)0x0) break;
    iVar1 = strcmp(*local_1c,prot_filename);
  } while (iVar1 != 0);
  if (local_1c == (char **)0x0) {
    if (WWW_TraceFlag != '\0') {
      pFVar2 = TraceFP();
      fprintf((FILE *)pFVar2,"HTAAProt_new: Loading protection file `%s\'\n",prot_filename);
    }
    prot = (HTAAProt *)calloc(1,0x1c);
    if (prot == (HTAAProt *)0x0) {
      outofmem("../../../WWW/Library/Implementation/HTAAProt.c","HTAAProt_new");
    }
    prot->ctemplate = (char *)0x0;
    prot->filename = (char *)0x0;
    prot->uid_name = (char *)0x0;
    prot->gid_name = (char *)0x0;
    pHVar3 = HTList_new();
    prot->valid_schemes = pHVar3;
    prot->mask_group = (GroupDef *)0x0;
    pHVar4 = HTAssocList_new();
    prot->values = pHVar4;
    if (prot_filename != (char *)0x0) {
      fp_00 = fopen64(prot_filename,"r");
      if (fp_00 != (FILE *)0x0) {
        HTAA_parseProtFile(prot,(FILE *)fp_00);
        fclose(fp_00);
        dest = (char **)calloc(1,8);
        if (dest == (char **)0x0) {
          outofmem("../../../WWW/Library/Implementation/HTAAProt.c","HTAAProt_new");
        }
        dest[1] = (char *)prot;
        *dest = (char *)0x0;
        HTSACopy(dest,prot_filename);
        HTList_addObject(prot_cache,dest);
        goto LAB_08147257;
      }
    }
    if (WWW_TraceFlag != '\0') {
      if (prot_filename == (char *)0x0) {
        local_18 = "(null)";
      }
      else {
        local_18 = prot_filename;
      }
      pFVar2 = TraceFP();
      fprintf((FILE *)pFVar2,"HTAAProt_new: %s `%s\'\n","Unable to open protection setup file",
              local_18);
    }
  }
  else {
    prot = (HTAAProt *)local_1c[1];
    if (WWW_TraceFlag != '\0') {
      pFVar2 = TraceFP();
      fprintf((FILE *)pFVar2,"%s `%s\' already in cache\n","HTAAProt_new: Protection file",
              prot_filename);
    }
  }
LAB_08147257:
  if (cur_docname != (char *)0x0) {
    HTSACopy(&prot->filename,cur_docname);
  }
  HTAA_setIds(prot,ids);
  return prot;
}



// WARNING: Unknown calling convention

void HTAA_setDefaultProtection(char *cur_docname,char *prot_filename,char *ids)

{
  FILE *__stream;
  
  default_prot = (HTAAProt *)0x0;
  if (prot_filename == (char *)0x0) {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"%s %s\n","HTAA_setDefaultProtection: ERROR: Protection file",
              "not specified (obligatory for DefProt rule)!!\n");
    }
  }
  else {
    default_prot = HTAAProt_new(cur_docname,prot_filename,ids);
  }
  return;
}



// WARNING: Unknown calling convention

void HTAA_setCurrentProtection(char *cur_docname,char *prot_filename,char *ids)

{
  FILE *pFVar1;
  
  current_prot = (HTAAProt *)0x0;
  if (prot_filename == (char *)0x0) {
    if (default_prot == (HTAAProt *)0x0) {
      if (WWW_TraceFlag != '\0') {
        pFVar1 = TraceFP();
        fprintf((FILE *)pFVar1,"%s %s %s\n","HTAA_setCurrentProtection: ERROR: Protection",
                "file not specified for Protect rule, and","default protection is not set!!");
      }
    }
    else {
      current_prot = default_prot;
      HTAA_setIds(default_prot,ids);
      if (WWW_TraceFlag != '\0') {
        pFVar1 = TraceFP();
        fprintf((FILE *)pFVar1,"%s %s %s\n","HTAA_setCurrentProtection: Protection file",
                "not specified for Protect rule","-- using default protection");
      }
    }
  }
  else {
    current_prot = HTAAProt_new(cur_docname,prot_filename,ids);
  }
  return;
}



// WARNING: Unknown calling convention

HTAAProt * HTAA_getCurrentProtection(void)

{
  return current_prot;
}



// WARNING: Unknown calling convention

HTAAProt * HTAA_getDefaultProtection(void)

{
  if (current_prot == (HTAAProt *)0x0) {
    current_prot = default_prot;
    default_prot = (HTAAProt *)0x0;
  }
  return current_prot;
}



// WARNING: Unknown calling convention

void HTAA_clearProtections(void)

{
  current_prot = (HTAAProt *)0x0;
  default_prot = (HTAAProt *)0x0;
  return;
}



// WARNING: Unknown calling convention

void save_gid_info(char *name,int user)

{
  char **dest;
  USER_DATA *data;
  
  dest = (char **)calloc(1,8);
  if (dest != (char **)0x0) {
    if (known_grp == (HTList *)0x0) {
      known_grp = HTList_new();
      if (uidgid_cache_inited == '\0') {
        uidgid_cache_inited = '\x01';
      }
    }
    HTSACopy(dest,name);
    dest[1] = (char *)user;
    HTList_addObject(known_grp,dest);
  }
  return;
}



// WARNING: Unknown calling convention

void save_uid_info(char *name,int user)

{
  char **dest;
  USER_DATA *data;
  
  dest = (char **)calloc(1,8);
  if (dest != (char **)0x0) {
    if (known_pwd == (HTList *)0x0) {
      known_pwd = HTList_new();
      if (uidgid_cache_inited == '\0') {
        uidgid_cache_inited = '\x01';
      }
    }
    HTSACopy(dest,name);
    dest[1] = (char *)user;
    HTList_addObject(known_pwd,dest);
  }
  return;
}



// WARNING: Unknown calling convention

char * HTAA_UidToName(int uid)

{
  __uid_t _Var1;
  char *pcVar2;
  passwd *ppVar3;
  FILE *__stream;
  USER_DATA *data;
  HTList *me;
  passwd *pw;
  
  me = known_pwd;
  while (((me != (HTList *)0x0 && (me = me->next, me != (HTList *)0x0)) &&
         (me->object != (void *)0x0))) {
    if (*(char **)((int)me->object + 4) == (char *)uid) {
                    // WARNING: Load size is inaccurate
      return *me->object;
    }
  }
  ppVar3 = getpwuid(uid);
  if ((ppVar3 != (passwd *)0x0) && (ppVar3->pw_name != (char *)0x0)) {
    if (WWW_TraceFlag != '\0') {
      _Var1 = ppVar3->pw_uid;
      pcVar2 = ppVar3->pw_name;
      __stream = TraceFP();
      fprintf((FILE *)__stream,"%s(%d) returned (%s:%d:...)\n","HTAA_UidToName: getpwuid",uid,pcVar2
              ,_Var1);
    }
    save_uid_info(ppVar3->pw_name,ppVar3->pw_uid);
    return ppVar3->pw_name;
  }
  return "";
}



// WARNING: Unknown calling convention

int HTAA_NameToUid(char *name)

{
  char **ppcVar1;
  __uid_t _Var2;
  char *pcVar3;
  int iVar4;
  passwd *ppVar5;
  FILE *__stream;
  USER_DATA *data;
  HTList *me;
  passwd *pw;
  
  me = known_pwd;
  while (((me != (HTList *)0x0 && (me = me->next, me != (HTList *)0x0)) &&
         (me->object != (void *)0x0))) {
    ppcVar1 = (char **)me->object;
    iVar4 = strcmp(name,*ppcVar1);
    if (iVar4 == 0) {
      return (int)ppcVar1[1];
    }
  }
  ppVar5 = getpwnam(name);
  if (ppVar5 != (passwd *)0x0) {
    if (WWW_TraceFlag != '\0') {
      _Var2 = ppVar5->pw_uid;
      pcVar3 = ppVar5->pw_name;
      __stream = TraceFP();
      fprintf((FILE *)__stream,"%s(%s) returned (%s:%d:...)\n","HTAA_NameToUid: getpwnam",name,
              pcVar3,_Var2);
    }
    save_uid_info(ppVar5->pw_name,ppVar5->pw_uid);
    return ppVar5->pw_uid;
  }
  return 0xfffd;
}



// WARNING: Unknown calling convention

char * HTAA_GidToName(int gid)

{
  __gid_t _Var1;
  char *pcVar2;
  group *pgVar3;
  FILE *__stream;
  USER_DATA *data;
  HTList *me;
  group *gr;
  
  me = known_grp;
  while (((me != (HTList *)0x0 && (me = me->next, me != (HTList *)0x0)) &&
         (me->object != (void *)0x0))) {
    if (*(char **)((int)me->object + 4) == (char *)gid) {
                    // WARNING: Load size is inaccurate
      return *me->object;
    }
  }
  pgVar3 = getgrgid(gid);
  if ((pgVar3 != (group *)0x0) && (pgVar3->gr_name != (char *)0x0)) {
    if (WWW_TraceFlag != '\0') {
      _Var1 = pgVar3->gr_gid;
      pcVar2 = pgVar3->gr_name;
      __stream = TraceFP();
      fprintf((FILE *)__stream,"%s(%d) returned (%s:%d:...)\n","HTAA_GidToName: getgrgid",gid,pcVar2
              ,_Var1);
    }
    save_gid_info(pgVar3->gr_name,pgVar3->gr_gid);
    return pgVar3->gr_name;
  }
  return "";
}



// WARNING: Unknown calling convention

int HTAA_NameToGid(char *name)

{
  char **ppcVar1;
  __gid_t _Var2;
  char *pcVar3;
  int iVar4;
  group *pgVar5;
  FILE *__stream;
  USER_DATA *data;
  HTList *me;
  group *gr;
  
  me = known_grp;
  while (((me != (HTList *)0x0 && (me = me->next, me != (HTList *)0x0)) &&
         (me->object != (void *)0x0))) {
    ppcVar1 = (char **)me->object;
    iVar4 = strcmp(name,*ppcVar1);
    if (iVar4 == 0) {
      return (int)ppcVar1[1];
    }
  }
  pgVar5 = getgrnam(name);
  if (pgVar5 != (group *)0x0) {
    if (WWW_TraceFlag != '\0') {
      _Var2 = pgVar5->gr_gid;
      pcVar3 = pgVar5->gr_name;
      __stream = TraceFP();
      fprintf((FILE *)__stream,"%s(%s) returned (%s:%d:...)\n","HTAA_NameToGid: getgrnam",name,
              pcVar3,_Var2);
    }
    save_gid_info(pgVar5->gr_name,pgVar5->gr_gid);
    return pgVar5->gr_gid;
  }
  return 0xfffd;
}



// WARNING: Unknown calling convention

HTAssocList * HTAssocList_new(void)

{
  HTList *pHVar1;
  
  pHVar1 = HTList_new();
  return pHVar1;
}



// WARNING: Unknown calling convention

void HTAssocList_delete(HTAssocList *alist)

{
  void **local_18;
  HTAssoc *assoc;
  HTAssocList *cur;
  
  if (alist != (HTAssocList *)0x0) {
    cur = alist;
    while( true ) {
      if ((cur == (HTAssocList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
        local_18 = (void **)0x0;
      }
      else {
        local_18 = (void **)cur->object;
      }
      if (local_18 == (void **)0x0) break;
      if (*local_18 != (void *)0x0) {
        free(*local_18);
        *local_18 = (void *)0x0;
      }
      if (local_18[1] != (void *)0x0) {
        free(local_18[1]);
        local_18[1] = (void *)0x0;
      }
      if (local_18 != (void **)0x0) {
        free(local_18);
      }
    }
    HTList_delete(alist);
  }
  return;
}



// WARNING: Unknown calling convention

void HTAssocList_add(HTAssocList *alist,char *name,char *value)

{
  char **dest;
  FILE *__stream;
  HTAssoc *assoc;
  
  if (alist == (HTAssocList *)0x0) {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"HTAssoc_add: ERROR: assoc list NULL!!\n");
    }
  }
  else {
    dest = (char **)malloc(8);
    if (dest == (char **)0x0) {
      outofmem("../../../WWW/Library/Implementation/HTAssoc.c","HTAssoc_add");
    }
    *dest = (char *)0x0;
    dest[1] = (char *)0x0;
    if (name != (char *)0x0) {
      HTSACopy(dest,name);
    }
    if (value != (char *)0x0) {
      HTSACopy(dest + 1,value);
    }
    HTList_addObject(alist,dest);
  }
  return;
}



// WARNING: Unknown calling convention

char * HTAssocList_lookup(HTAssocList *alist,char *name)

{
  size_t n;
  int iVar1;
  char **local_18;
  HTAssoc *assoc;
  HTAssocList *cur;
  
  cur = alist;
  while( true ) {
    if ((cur == (HTAssocList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
      local_18 = (char **)0x0;
    }
    else {
      local_18 = (char **)cur->object;
    }
    if (local_18 == (char **)0x0) break;
    n = strlen(name);
    iVar1 = strncasecomp(*local_18,name,n);
    if (iVar1 == 0) {
      return local_18[1];
    }
  }
  return (char *)0x0;
}



// WARNING: Unknown calling convention

void unlex(LexItem lex_item)

{
  lex_pushed_back = lex_item;
  return;
}



// WARNING: Unknown calling convention

LexItem lex(FILE *fp)

{
  LexItem LVar1;
  int __c;
  LexItem ret;
  int ch;
  
  LVar1 = lex_pushed_back;
  if (fp != cache) {
    cache = fp;
    HTlex_line = 1;
  }
  if (lex_pushed_back != LEX_NONE) {
    lex_pushed_back = LEX_NONE;
    return LVar1;
  }
  lex_cnt = 0;
  lex_template = '\0';
  do {
    __c = _IO_getc((_IO_FILE *)fp);
    switch(__c) {
    default:
      if (lex_cnt < 0x27) {
        HTlex_buffer[lex_cnt] = (char)__c;
        lex_cnt = lex_cnt + 1;
      }
      HTlex_buffer[lex_cnt] = '\0';
      if (__c == 0x2a) {
        lex_template = '\x01';
      }
      break;
    case -1:
    case 9:
    case 10:
    case 0xd:
    case 0x20:
    case 0x28:
    case 0x29:
    case 0x2c:
    case 0x3a:
    case 0x40:
      if (0 < lex_cnt) {
        if (__c != -1) {
          ungetc(__c,(FILE *)fp);
        }
        if (lex_template != '\0') {
          return LEX_TMPL_STR;
        }
        return LEX_ALPH_STR;
      }
      switch(__c) {
      case 10:
        HTlex_line = HTlex_line + 1;
        return LEX_REC_SEP;
      case 0x28:
        return LEX_OPEN_PAREN;
      case 0x29:
        return LEX_CLOSE_PAREN;
      case 0x2c:
        return LEX_ITEM_SEP;
      case 0x3a:
        return LEX_FIELD_SEP;
      case 0x40:
        return LEX_AT_SIGN;
      case -1:
        return LEX_EOF;
      }
    }
  } while( true );
}



// WARNING: Unknown calling convention

char * lex_verbose(LexItem lex_item)

{
  char *local_8;
  
  switch(lex_item) {
  case LEX_NONE:
    local_8 = "NO-LEX-ITEM";
    break;
  case LEX_EOF:
    local_8 = "end-of-file";
    break;
  case LEX_REC_SEP:
    local_8 = "record separator (newline)";
    break;
  case LEX_FIELD_SEP:
    local_8 = "field separator \':\'";
    break;
  case LEX_ITEM_SEP:
    local_8 = "item separator \',\'";
    break;
  case LEX_OPEN_PAREN:
    local_8 = "\'(\'";
    break;
  case LEX_CLOSE_PAREN:
    local_8 = "\')\'";
    break;
  case LEX_AT_SIGN:
    local_8 = "address qualifier \'@\'";
    break;
  case LEX_ALPH_STR:
    sprintf(lex_verbose::msg,"alphanumeric string \'%.*s\'",0x28,HTlex_buffer);
    local_8 = lex_verbose::msg;
    break;
  case LEX_TMPL_STR:
    sprintf(lex_verbose::msg,"template string \'%.*s\'",0x28,HTlex_buffer);
    local_8 = lex_verbose::msg;
    break;
  default:
    local_8 = "UNKNOWN-LEX-ITEM";
  }
  return local_8;
}



// WARNING: Unknown calling convention

int HTUU_encode(uchar *bufin,uint nbytes,char *bufcoded)

{
  char *local_18;
  uint i;
  
  local_18 = bufcoded;
  for (i = 0; i < nbytes; i = i + 3) {
    *local_18 = six2pr[*bufin >> 2];
    local_18[1] = six2pr[(uint)(bufin[1] >> 4) | (*bufin & 3) << 4];
    local_18[2] = six2pr[(uint)(bufin[2] >> 6) | (bufin[1] & 0xf) << 2];
    local_18[3] = six2pr[bufin[2] & 0x3f];
    local_18 = local_18 + 4;
    bufin = bufin + 3;
  }
  if (nbytes + 1 == i) {
    local_18[-1] = '=';
  }
  else if (nbytes + 2 == i) {
    local_18[-1] = '=';
    local_18[-2] = '=';
  }
  *local_18 = '\0';
  return (int)local_18 - (int)bufcoded;
}



// WARNING: Unknown calling convention

int HTUU_decode(char *bufcoded,uchar *bufplain,int outbufsize)

{
  byte bVar1;
  byte *local_20;
  byte *local_1c;
  byte *local_18;
  int j;
  int nbytesdecoded;
  
  local_1c = bufplain;
  if (HTUU_decode::first != 0) {
    HTUU_decode::first = 0;
    for (j = 0; j < 0x100; j = j + 1) {
      pr2six[j] = '@';
    }
    for (j = 0; j < 0x40; j = j + 1) {
      pr2six[(byte)six2pr[j]] = (uchar)j;
    }
  }
  for (; (*bufcoded == ' ' || (*bufcoded == '\t')); bufcoded = bufcoded + 1) {
  }
  local_20 = (byte *)bufcoded;
  do {
    bVar1 = *local_20;
    local_20 = local_20 + 1;
  } while (pr2six[bVar1] < 0x40);
  local_18 = local_20 + (-1 - (int)bufcoded);
  nbytesdecoded =
       ((int)(local_20 + (2 - (int)bufcoded) +
             ((uint)((int)(local_20 + (2 - (int)bufcoded)) >> 0x1f) >> 0x1e)) >> 2) * 3;
  if (outbufsize < nbytesdecoded) {
    local_18 = (byte *)((outbufsize << 2) / 3);
  }
  local_20 = (byte *)bufcoded;
  for (; 0 < (int)local_18; local_18 = local_18 + -4) {
    *local_1c = pr2six[(char)local_20[1]] >> 4 | pr2six[(char)*local_20] << 2;
    local_1c[1] = pr2six[(char)local_20[2]] >> 2 | pr2six[(char)local_20[1]] << 4;
    local_1c[2] = pr2six[(char)local_20[3]] | pr2six[(char)local_20[2]] << 6;
    local_1c = local_1c + 3;
    local_20 = local_20 + 4;
  }
  if (((uint)local_18 & 3) != 0) {
    if (pr2six[(char)local_20[-2]] < 0x40) {
      nbytesdecoded = nbytesdecoded + -1;
    }
    else {
      nbytesdecoded = nbytesdecoded + -2;
    }
  }
  return nbytesdecoded;
}



// WARNING: Unknown calling convention

HTAAScheme HTAAScheme_enum(char *name)

{
  int iVar1;
  HTAAScheme local_18;
  char *upcased;
  
  upcased = (char *)0x0;
  if (name == (char *)0x0) {
    local_18 = HTAA_UNKNOWN;
  }
  else {
    HTSACopy(&upcased,name);
    LYUpperCase(upcased);
    iVar1 = strncmp(upcased,"NONE",4);
    if (iVar1 == 0) {
      if (upcased != (char *)0x0) {
        free(upcased);
      }
      local_18 = HTAA_NONE;
    }
    else {
      iVar1 = strncmp(upcased,"BASIC",5);
      if (iVar1 == 0) {
        if (upcased != (char *)0x0) {
          free(upcased);
        }
        local_18 = HTAA_BASIC;
      }
      else {
        iVar1 = strncmp(upcased,"PUBKEY",6);
        if (iVar1 == 0) {
          if (upcased != (char *)0x0) {
            free(upcased);
          }
          local_18 = HTAA_PUBKEY;
        }
        else {
          iVar1 = strncmp(upcased,"KERBEROSV4",10);
          if (iVar1 == 0) {
            if (upcased != (char *)0x0) {
              free(upcased);
            }
            local_18 = HTAA_KERBEROS_V4;
          }
          else {
            iVar1 = strncmp(upcased,"KERBEROSV5",10);
            if (iVar1 == 0) {
              if (upcased != (char *)0x0) {
                free(upcased);
              }
              local_18 = HTAA_KERBEROS_V5;
            }
            else {
              if (upcased != (char *)0x0) {
                free(upcased);
              }
              local_18 = HTAA_UNKNOWN;
            }
          }
        }
      }
    }
  }
  return local_18;
}



// WARNING: Unknown calling convention

char * HTAAScheme_name(HTAAScheme scheme)

{
  char *local_8;
  
  switch(scheme) {
  case HTAA_UNKNOWN:
    local_8 = "UNKNOWN";
    break;
  case HTAA_NONE:
    local_8 = "None";
    break;
  case HTAA_BASIC:
    local_8 = "Basic";
    break;
  case HTAA_PUBKEY:
    local_8 = "Pubkey";
    break;
  case HTAA_KERBEROS_V4:
    local_8 = "KerberosV4";
    break;
  case HTAA_KERBEROS_V5:
    local_8 = "KerberosV5";
    break;
  default:
    local_8 = "THIS-IS-A-BUG";
  }
  return local_8;
}



// WARNING: Unknown calling convention

HTAAMethod HTAAMethod_enum(char *name)

{
  int iVar1;
  HTAAMethod local_8;
  
  if (name == (char *)0x0) {
    local_8 = METHOD_UNKNOWN;
  }
  else {
    iVar1 = strcasecomp(name,"GET");
    if (iVar1 == 0) {
      local_8 = METHOD_GET;
    }
    else {
      iVar1 = strcasecomp(name,"PUT");
      if (iVar1 == 0) {
        local_8 = METHOD_PUT;
      }
      else {
        local_8 = METHOD_UNKNOWN;
      }
    }
  }
  return local_8;
}



// WARNING: Unknown calling convention

char * HTAAMethod_name(HTAAMethod method)

{
  char *local_8;
  
  if (method == METHOD_GET) {
    local_8 = "GET";
  }
  else if (method == METHOD_UNKNOWN) {
    local_8 = "UNKNOWN";
  }
  else if (method == METHOD_PUT) {
    local_8 = "PUT";
  }
  else {
    local_8 = "THIS-IS-A-BUG";
  }
  return local_8;
}



// WARNING: Unknown calling convention

BOOLEAN HTAAMethod_inList(HTAAMethod method,HTList *list)

{
  FILE *__stream;
  HTAAMethod HVar1;
  char *local_18;
  char *item;
  HTList *cur;
  
  cur = list;
  while( true ) {
    if ((cur == (HTList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
      local_18 = (char *)0x0;
    }
    else {
      local_18 = (char *)cur->object;
    }
    if (local_18 == (char *)0x0) break;
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream," %s",local_18);
    }
    HVar1 = HTAAMethod_enum(local_18);
    if (HVar1 == method) {
      return '\x01';
    }
  }
  return '\0';
}



// WARNING: Unknown calling convention

BOOLEAN HTAA_templateMatch(char *ctemplate,char *filename)

{
  size_t sVar1;
  size_t sVar2;
  int iVar3;
  BOOLEAN local_19;
  int m;
  char *q;
  char *p;
  
  q = filename;
  for (p = ctemplate; ((*p != '\0' && (*q != '\0')) && (*p == *q)); p = p + 1) {
    q = q + 1;
  }
  if ((*p == '\0') && (*q == '\0')) {
    local_19 = '\x01';
  }
  else if (*p == '*') {
    sVar1 = strlen(q);
    sVar2 = strlen(p + 1);
    if ((int)(sVar1 - sVar2) < 0) {
      local_19 = '\0';
    }
    else {
      iVar3 = strcmp(p + 1,q + (sVar1 - sVar2));
      if (iVar3 == 0) {
        local_19 = '\x01';
      }
      else {
        local_19 = '\0';
      }
    }
  }
  else {
    local_19 = '\0';
  }
  return local_19;
}



// WARNING: Unknown calling convention

BOOLEAN HTAA_templateCaseMatch(char *ctemplate,char *filename)

{
  ushort **ppuVar1;
  size_t sVar2;
  size_t sVar3;
  int iVar4;
  uint local_24;
  uint local_20;
  BOOLEAN local_19;
  int m;
  char *q;
  char *p;
  
  p = ctemplate;
  for (q = filename; (*p != '\0' && (*q != '\0')); q = q + 1) {
    ppuVar1 = __ctype_b_loc();
    if (((*ppuVar1)[(byte)*p] & 0x200) == 0) {
      local_24 = (uint)(byte)*p;
    }
    else {
      local_24 = toupper((uint)(byte)*p);
    }
    ppuVar1 = __ctype_b_loc();
    if (((*ppuVar1)[(byte)*q] & 0x200) == 0) {
      local_20 = (uint)(byte)*q;
    }
    else {
      local_20 = toupper((uint)(byte)*q);
    }
    if (local_24 != local_20) break;
    p = p + 1;
  }
  if ((*p == '\0') && (*q == '\0')) {
    local_19 = '\x01';
  }
  else if (*p == '*') {
    sVar2 = strlen(q);
    sVar3 = strlen(p + 1);
    if ((int)(sVar2 - sVar3) < 0) {
      local_19 = '\0';
    }
    else {
      iVar4 = strcasecomp(p + 1,q + (sVar2 - sVar3));
      if (iVar4 == 0) {
        local_19 = '\x01';
      }
      else {
        local_19 = '\0';
      }
    }
  }
  else {
    local_19 = '\0';
  }
  return local_19;
}



// WARNING: Unknown calling convention

char * HTAA_makeProtectionTemplate(char *docname)

{
  char *pcVar1;
  FILE *__stream;
  char *slash;
  char *ctemplate;
  
  ctemplate = (char *)0x0;
  if (docname == (char *)0x0) {
    HTSACopy(&ctemplate,"*");
  }
  else {
    HTSACopy(&ctemplate,docname);
    pcVar1 = strrchr(ctemplate,0x2f);
    if (pcVar1 == (char *)0x0) {
      slash = ctemplate;
    }
    else {
      slash = pcVar1 + 1;
    }
    *slash = '\0';
    HTSACat(&ctemplate,"*");
  }
  pcVar1 = ctemplate;
  if (WWW_TraceFlag != '\0') {
    __stream = TraceFP();
    fprintf((FILE *)__stream,"make_template: made template `%s\' for file `%s\'\n",pcVar1,docname);
  }
  return ctemplate;
}



// WARNING: Unknown calling convention

HTList * HTAA_parseArgList(char *str)

{
  HTAssocList *local_28;
  char *c_1;
  char *c;
  int n;
  char *name;
  char *cur;
  HTAssocList *assoc_list;
  
  local_28 = HTAssocList_new();
  cur = (char *)0x0;
  name = (char *)0x0;
  n = 0;
  assoc_list = local_28;
  if (str != (char *)0x0) {
    while (*str != '\0') {
      for (; (*str == ' ' || (*str == '\t')); str = str + 1) {
      }
      n = n + 1;
      for (cur = str; ((c = cur, *cur != '\0' && (*cur != '=')) && (*cur != ',')); cur = cur + 1) {
      }
      while ((c = c + -1, *c == ' ' || (*c == '\t'))) {
        *c = '\0';
      }
      if (*cur == '=') {
        *cur = '\0';
        cur = cur + 1;
        HTSACopy(&name,str);
        for (; (*cur == ' ' || (*cur == '\t')); cur = cur + 1) {
        }
        str = cur;
        if (*cur == '\"') {
          str = cur + 1;
          for (cur = str; (*cur != '\0' && (*cur != '\"')); cur = cur + 1) {
          }
          if (*cur == '\"') {
            *cur = '\0';
            cur = cur + 1;
          }
          for (; (*cur == ' ' || (*cur == '\t')); cur = cur + 1) {
          }
          if (*cur == ',') {
            cur = cur + 1;
          }
        }
        else {
          for (; (c_1 = cur, *cur != '\0' && (*cur != ',')); cur = cur + 1) {
          }
          while ((c_1 = c_1 + -1, *c_1 == ' ' || (*c_1 == '\t'))) {
            *c_1 = '\0';
          }
          if (*cur == ',') {
            *cur = '\0';
            cur = cur + 1;
          }
        }
      }
      else {
        if (*cur == ',') {
          *cur = '\0';
          cur = cur + 1;
        }
        HTSprintf0(&name,"%d",n);
      }
      HTAssocList_add(assoc_list,name,str);
      str = cur;
    }
    if (name != (char *)0x0) {
      free(name);
    }
    local_28 = assoc_list;
  }
  return local_28;
}



// WARNING: Unknown calling convention

void HTAA_setupReader(char *start_of_headers,int length,int soc)

{
  if (start_of_headers == (char *)0x0) {
    length = 0;
  }
  if (buffer == (char *)0x0) {
    buffer_length = length;
    if ((uint)length < 0x400) {
      buffer_length = 0x400;
    }
    buffer = (char *)malloc(buffer_length + 1);
  }
  else if ((int)buffer_length < length) {
    buffer_length = length;
    buffer = (char *)realloc(buffer,length + 1);
  }
  if (buffer == (char *)0x0) {
    outofmem("../../../WWW/Library/Implementation/HTAAUtil.c","HTAA_setupReader");
  }
  start_pointer = buffer;
  if (start_of_headers == (char *)0x0) {
    *buffer = '\0';
    end_pointer = start_pointer;
  }
  else {
    strncpy(buffer,start_of_headers,length);
    buffer[length] = '\0';
    end_pointer = buffer + length;
  }
  in_soc = soc;
  return;
}



// WARNING: Unknown calling convention

char * HTAA_getUnfoldedLine(void)

{
  FILE *__stream;
  int iVar1;
  int count;
  char *cur;
  char *line;
  BOOLEAN peek_for_folding;
  
  line = (char *)0x0;
  peek_for_folding = '\0';
  if (in_soc < 0) {
    if (WWW_TraceFlag != '\0') {
      __stream = TraceFP();
      fprintf((FILE *)__stream,"%s %s\n","HTAA_getUnfoldedLine: buffer not initialized",
              "with function HTAA_setupReader()");
    }
    return (char *)0x0;
  }
  do {
    if (end_pointer <= start_pointer) {
      iVar1 = HTDoRead(in_soc,buffer,0x400);
      if (iVar1 < 1) {
        in_soc = -1;
        return line;
      }
      start_pointer = buffer;
      end_pointer = buffer + iVar1;
      *end_pointer = '\0';
    }
    cur = start_pointer;
    if (peek_for_folding != '\0') {
      if ((*start_pointer != ' ') && (*start_pointer != '\t')) {
        return line;
      }
      peek_for_folding = '\0';
    }
    for (; (cur < end_pointer && (*cur != '\n')); cur = cur + 1) {
    }
    if (cur < end_pointer) {
      *cur = '\0';
      if (cur[-1] == '\r') {
        cur[-1] = '\0';
      }
      peek_for_folding = '\x01';
    }
    if (line == (char *)0x0) {
      HTSACopy(&line,start_pointer);
    }
    else {
      HTSACat(&line,start_pointer);
    }
    start_pointer = cur + 1;
  } while( true );
}



void syntax_error(FILE *fp,char *msg,LexItem lex_item)

{
  int iVar1;
  char *pcVar2;
  FILE *__stream;
  int in_GS_OFFSET;
  char *msg_local;
  FILE *fp_local;
  int ch;
  int cnt;
  char buffer [41];
  int local_10;
  
  local_10 = *(int *)(in_GS_OFFSET + 0x14);
  cnt = 0;
  while( true ) {
    iVar1 = _IO_getc((_IO_FILE *)fp);
    if ((iVar1 == -1) || (iVar1 == 10)) break;
    if (cnt < 0x28) {
      buffer[cnt] = (char)iVar1;
      cnt = cnt + 1;
    }
  }
  buffer[cnt] = '\0';
  if (WWW_TraceFlag != '\0') {
    pcVar2 = lex_verbose(lex_item);
    iVar1 = HTlex_line;
    __stream = TraceFP();
    fprintf((FILE *)__stream,"%s %d before: \'%s\'\nHTGroup.c: %s (got %s)\n",
            "HTGroup.c: Syntax error in rule file at line",iVar1,buffer,msg,pcVar2);
  }
  HTlex_line = HTlex_line + 1;
  if (local_10 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



// WARNING: Unknown calling convention

AddressDefList * parse_address_part(FILE *fp)

{
  bool bVar1;
  HTList *me;
  char **dest;
  Ref *ref;
  LexItem lex_item;
  AddressDefList *address_def_list;
  BOOLEAN only_one;
  
  bVar1 = false;
  lex_item = lex(fp);
  if ((lex_item == LEX_ALPH_STR) || (lex_item == LEX_TMPL_STR)) {
    bVar1 = true;
  }
  else if ((lex_item != LEX_OPEN_PAREN) ||
          ((lex_item = lex(fp), lex_item != LEX_ALPH_STR && (lex_item != LEX_TMPL_STR)))) {
    syntax_error(fp,"Expecting a single address or \'(\' beginning list",lex_item);
    return (AddressDefList *)0x0;
  }
  me = HTList_new();
  while( true ) {
    dest = (char **)calloc(1,8);
    if (dest == (char **)0x0) {
      outofmem("../../../WWW/Library/Implementation/HTGroup.c","parse_address_part");
    }
    *dest = (char *)0x0;
    dest[1] = (char *)0x0;
    HTSACopy(dest,HTlex_buffer);
    HTList_addObject(me,dest);
    if ((bVar1) || (lex_item = lex(fp), lex_item != LEX_ITEM_SEP)) break;
    do {
      lex_item = lex(fp);
    } while (lex_item == LEX_REC_SEP);
    if ((lex_item != LEX_ALPH_STR) && (lex_item != LEX_TMPL_STR)) {
      syntax_error(fp,"Expecting an address template",lex_item);
      HTList_delete(me);
      return (AddressDefList *)0x0;
    }
  }
  if (bVar1) {
    return me;
  }
  if (lex_item == LEX_CLOSE_PAREN) {
    return me;
  }
  HTList_delete(me);
  syntax_error(fp,"Expecting \')\' closing address list",lex_item);
  return (AddressDefList *)0x0;
}



// WARNING: Unknown calling convention

UserDefList * parse_user_part(FILE *fp)

{
  bool bVar1;
  HTList *me;
  char **dest;
  Ref *ref;
  LexItem lex_item;
  UserDefList *user_def_list;
  BOOLEAN only_one;
  
  bVar1 = false;
  lex_item = lex(fp);
  if (lex_item == LEX_ALPH_STR) {
    bVar1 = true;
    lex_item = LEX_ALPH_STR;
  }
  else if ((lex_item != LEX_OPEN_PAREN) || (lex_item = lex(fp), lex_item != LEX_ALPH_STR)) {
    syntax_error(fp,"Expecting a single name or \'(\' beginning list",lex_item);
    return (UserDefList *)0x0;
  }
  me = HTList_new();
  while( true ) {
    dest = (char **)calloc(1,8);
    if (dest == (char **)0x0) {
      outofmem("../../../WWW/Library/Implementation/HTGroup.c","parse_user_part");
    }
    *dest = (char *)0x0;
    dest[1] = (char *)0x0;
    HTSACopy(dest,HTlex_buffer);
    HTList_addObject(me,dest);
    if ((bVar1) || (lex_item = lex(fp), lex_item != LEX_ITEM_SEP)) break;
    do {
      lex_item = lex(fp);
    } while (lex_item == LEX_REC_SEP);
    if (lex_item != LEX_ALPH_STR) {
      syntax_error(fp,"Expecting user or group name",lex_item);
      HTList_delete(me);
      return (UserDefList *)0x0;
    }
  }
  if (bVar1) {
    return me;
  }
  if (lex_item == LEX_CLOSE_PAREN) {
    return me;
  }
  HTList_delete(me);
  syntax_error(fp,"Expecting \')\' closing user/group list",lex_item);
  return (UserDefList *)0x0;
}



// WARNING: Unknown calling convention

Item * parse_item(FILE *fp)

{
  Item *local_18;
  LexItem lex_item;
  AddressDefList *address_def_list;
  UserDefList *user_def_list;
  Item *item;
  
  user_def_list = (UserDefList *)0x0;
  address_def_list = (AddressDefList *)0x0;
  lex_item = lex(fp);
  if ((lex_item == LEX_ALPH_STR) || (lex_item == LEX_OPEN_PAREN)) {
    unlex(lex_item);
    user_def_list = parse_user_part(fp);
    lex_item = lex(fp);
  }
  if (lex_item == LEX_AT_SIGN) {
    lex_item = lex(fp);
    if (((lex_item != LEX_ALPH_STR) && (lex_item != LEX_TMPL_STR)) && (lex_item != LEX_OPEN_PAREN))
    {
      if (user_def_list != (UserDefList *)0x0) {
        HTList_delete(user_def_list);
      }
      syntax_error(fp,"Expected address part (single address or list)",lex_item);
      return (Item *)0x0;
    }
    unlex(lex_item);
    address_def_list = parse_address_part(fp);
  }
  else {
    unlex(lex_item);
  }
  if ((user_def_list == (UserDefList *)0x0) && (address_def_list == (AddressDefList *)0x0)) {
    syntax_error(fp,"Empty item not allowed",lex_item);
    local_18 = (Item *)0x0;
  }
  else {
    local_18 = (Item *)calloc(1,8);
    if (local_18 == (Item *)0x0) {
      outofmem("../../../WWW/Library/Implementation/HTGroup.c","parse_item");
    }
    local_18->user_def_list = user_def_list;
    local_18->address_def_list = address_def_list;
  }
  return local_18;
}



// WARNING: Unknown calling convention

ItemList * parse_item_list(FILE *fp)

{
  HTList *me;
  Item *newObject;
  LexItem LVar1;
  LexItem lex_item;
  Item *item;
  ItemList *item_list;
  
  me = HTList_new();
  while( true ) {
    newObject = parse_item(fp);
    if (newObject == (Item *)0x0) {
      HTList_delete(me);
      return (ItemList *)0x0;
    }
    HTList_addObject(me,newObject);
    LVar1 = lex(fp);
    if (LVar1 != LEX_ITEM_SEP) break;
    do {
      LVar1 = lex(fp);
    } while (LVar1 == LEX_REC_SEP);
    unlex(LVar1);
  }
  unlex(LVar1);
  return me;
}



// WARNING: Unknown calling convention

GroupDef * HTAA_parseGroupDef(FILE *fp)

{
  ItemList *pIVar1;
  LexItem lex_item_00;
  GroupDef *local_18;
  LexItem lex_item;
  GroupDef *group_def;
  ItemList *item_list;
  
  pIVar1 = parse_item_list(fp);
  if (pIVar1 == (ItemList *)0x0) {
    local_18 = (GroupDef *)0x0;
  }
  else {
    local_18 = (GroupDef *)calloc(1,8);
    if (local_18 == (GroupDef *)0x0) {
      outofmem("../../../WWW/Library/Implementation/HTGroup.c","HTAA_parseGroupDef");
    }
    local_18->group_name = (char *)0x0;
    local_18->item_list = pIVar1;
    lex_item_00 = lex(fp);
    if (lex_item_00 != LEX_REC_SEP) {
      syntax_error(fp,"Garbage after group definition",lex_item_00);
    }
  }
  return local_18;
}



// WARNING: Unknown calling convention

void print_item(Item *item)

{
  undefined4 uVar1;
  FILE *pFVar2;
  undefined4 *local_30;
  undefined4 *local_2c;
  char *local_28;
  char *local_24;
  undefined4 *local_20;
  undefined4 *local_1c;
  Ref *addr_ref;
  Ref *user_ref;
  AddressDefList *cur2;
  UserDefList *cur1;
  
  if (item == (Item *)0x0) {
    pFVar2 = TraceFP();
    fwrite("\tNULL-ITEM\n",1,0xb,(FILE *)pFVar2);
  }
  else {
    cur1 = item->user_def_list;
    cur2 = item->address_def_list;
    if ((cur1 == (UserDefList *)0x0) || (cur1 = cur1->next, cur1 == (HTList *)0x0)) {
      local_30 = (undefined4 *)0x0;
    }
    else {
      local_30 = (undefined4 *)cur1->object;
    }
    if ((cur2 == (AddressDefList *)0x0) || (cur2 = cur2->next, cur2 == (HTList *)0x0)) {
      local_2c = (undefined4 *)0x0;
    }
    else {
      local_2c = (undefined4 *)cur2->object;
    }
    if (local_30 == (undefined4 *)0x0) {
      pFVar2 = TraceFP();
      fwrite("\tANYBODY ",1,9,(FILE *)pFVar2);
    }
    else {
      if (local_30[1] == 0) {
        local_28 = "";
      }
      else {
        local_28 = "*REF*";
      }
      uVar1 = *local_30;
      pFVar2 = TraceFP();
      fprintf((FILE *)pFVar2,"\t[%s%s",uVar1,local_28);
      while( true ) {
        if ((cur1 == (UserDefList *)0x0) || (cur1 = cur1->next, cur1 == (HTList *)0x0)) {
          local_20 = (undefined4 *)0x0;
        }
        else {
          local_20 = (undefined4 *)cur1->object;
        }
        if (local_20 == (undefined4 *)0x0) break;
        if (local_20[1] == 0) {
          local_24 = "";
        }
        else {
          local_24 = "*REF*";
        }
        uVar1 = *local_20;
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2,"; %s%s",uVar1,local_24);
      }
      pFVar2 = TraceFP();
      fwrite(&DAT_08192010,1,2,(FILE *)pFVar2);
    }
    if (local_2c == (undefined4 *)0x0) {
      pFVar2 = TraceFP();
      fwrite("@ ANYADDRESS\n",1,0xd,(FILE *)pFVar2);
    }
    else {
      uVar1 = *local_2c;
      pFVar2 = TraceFP();
      fprintf((FILE *)pFVar2,"@ [%s",uVar1);
      while( true ) {
        if ((cur2 == (AddressDefList *)0x0) || (cur2 = cur2->next, cur2 == (HTList *)0x0)) {
          local_1c = (undefined4 *)0x0;
        }
        else {
          local_1c = (undefined4 *)cur2->object;
        }
        if (local_1c == (undefined4 *)0x0) break;
        uVar1 = *local_1c;
        pFVar2 = TraceFP();
        fprintf((FILE *)pFVar2,"; %s",uVar1);
      }
      pFVar2 = TraceFP();
      fwrite(&DAT_08192028,1,2,(FILE *)pFVar2);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void print_item_list(ItemList *item_list)

{
  FILE *__s;
  Item *local_18;
  Item *item;
  ItemList *cur;
  
  cur = item_list;
  if (item_list == (ItemList *)0x0) {
    __s = TraceFP();
    fwrite("EMPTY",1,5,(FILE *)__s);
  }
  else {
    while( true ) {
      if ((cur == (ItemList *)0x0) || (cur = cur->next, cur == (HTList *)0x0)) {
        local_18 = (Item *)0x0;
      }
      else {
        local_18 = (Item *)cur->object;
      }
      if (local_18 == (Item *)0x0) break;
      print_item(local_18);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void HTAA_printGroupDef(GroupDef *group_def)

{
  FILE *pFVar1;
  char *local_8;
  
  if (group_def == (GroupDef *)0x0) {
    pFVar1 = TraceFP();
    fwrite("\nNULL RECORD\n",1,0xd,(FILE *)pFVar1);
  }
  else {
    if (group_def->group_name == (char *)0x0) {
      local_8 = "NULL";
    }
    else {
      local_8 = group_def->group_name;
    }
    pFVar1 = TraceFP();
    fprintf((FILE *)pFVar1,"\nGroup %s:\n",local_8);
    print_item_list(group_def->item_list);
    pFVar1 = TraceFP();
    fputc(10,(FILE *)pFVar1);
  }
  return;
}



undefined8 __divdi3(uint param_1,uint param_2,uint param_3,uint param_4)

{
  ulonglong uVar1;
  ulonglong uVar2;
  ulonglong uVar3;
  longlong lVar4;
  int iVar5;
  byte bVar6;
  uint uVar7;
  uint uVar8;
  bool bVar9;
  uint local_20;
  uint local_18;
  byte bStack_14;
  
  local_20 = 0;
  if ((int)param_2 < 0) {
    bVar9 = param_1 != 0;
    param_1 = -param_1;
    param_2 = -(param_2 + bVar9);
    local_20 = 0xffffffff;
  }
  if ((int)param_4 < 0) {
    local_20 = ~local_20;
    bVar9 = param_3 != 0;
    param_3 = -param_3;
    param_4 = -(param_4 + bVar9);
  }
  if (param_4 == 0) {
    if (param_2 < param_3) {
      uVar8 = 0;
      iVar5 = (int)(CONCAT44(param_2,param_1) / (ulonglong)param_3);
    }
    else {
      local_18 = param_3;
      if (param_3 == 0) {
        local_18 = (uint)(1 / 0);
      }
      uVar8 = param_2 / local_18;
      iVar5 = (int)(((ulonglong)param_2 % (ulonglong)local_18 << 0x20 | (ulonglong)param_1) /
                   (ulonglong)local_18);
    }
    goto LAB_081495c5;
  }
  if (param_4 <= param_2) {
    uVar8 = 0x1f;
    if (param_4 != 0) {
      for (; param_4 >> uVar8 == 0; uVar8 = uVar8 - 1) {
      }
    }
    if ((uVar8 ^ 0x1f) != 0) {
      bStack_14 = (byte)(uVar8 ^ 0x1f);
      bVar6 = 0x20 - bStack_14;
      uVar1 = (ulonglong)(param_3 >> (bVar6 & 0x1f) | param_4 << (bStack_14 & 0x1f));
      uVar2 = CONCAT44(param_2 >> (bVar6 & 0x1f),
                       param_1 >> (bVar6 & 0x1f) | param_2 << (bStack_14 & 0x1f));
      uVar3 = uVar2 / uVar1;
      iVar5 = (int)uVar3;
      uVar8 = (uint)(uVar2 % uVar1);
      lVar4 = (ulonglong)(param_3 << (bStack_14 & 0x1f)) * (uVar3 & 0xffffffff);
      uVar7 = (uint)((ulonglong)lVar4 >> 0x20);
      if ((uVar8 < uVar7) || ((uVar8 == uVar7 && (param_1 << (bStack_14 & 0x1f) < (uint)lVar4)))) {
        uVar8 = 0;
        iVar5 = iVar5 + -1;
      }
      else {
        uVar8 = 0;
      }
      goto LAB_081495c5;
    }
    if ((param_4 < param_2) || (param_3 <= param_1)) {
      iVar5 = 1;
      uVar8 = 0;
      goto LAB_081495c5;
    }
  }
  iVar5 = 0;
  uVar8 = 0;
LAB_081495c5:
  if (local_20 != 0) {
    bVar9 = iVar5 != 0;
    iVar5 = -iVar5;
    uVar8 = -(uVar8 + bVar9);
  }
  return CONCAT44(uVar8,iVar5);
}



void __libc_csu_fini(void)

{
  return;
}



// WARNING: Function: __i686.get_pc_thunk.bx replaced with injection: get_pc_thunk_bx
// WARNING: Removing unreachable block (ram,0x0814972e)
// WARNING: Removing unreachable block (ram,0x08149730)

void __libc_csu_init(void)

{
  EVP_PKEY_CTX *in_stack_ffffffe4;
  
  _init(in_stack_ffffffe4);
  return;
}



// WARNING: This is an inlined function

void __i686_get_pc_thunk_bx(void)

{
  return;
}



// WARNING: Function: __i686.get_pc_thunk.bx replaced with injection: get_pc_thunk_bx

int stat64(char *__file,stat64 *__buf)

{
  int iVar1;
  
  iVar1 = __xstat64(3,__file,__buf);
  return iVar1;
}



// WARNING: Function: __i686.get_pc_thunk.bx replaced with injection: get_pc_thunk_bx

int lstat64(char *__file,stat64 *__buf)

{
  int iVar1;
  
  iVar1 = __lxstat64(3,__file,__buf);
  return iVar1;
}



// WARNING: Removing unreachable block (ram,0x081497f1)
// WARNING: Removing unreachable block (ram,0x081497f8)

void __do_global_ctors_aux(void)

{
  return;
}



void _fini(void)

{
  __do_global_dtors_aux();
  return;
}


