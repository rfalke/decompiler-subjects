//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <assert.h>
#include <ctype.h>
#include <dirent.h>
#include <errno.h>
#include <error.h>
#include <fnmatch.h>
#include <getopt.h>
#include <grp.h>
#include <inttypes.h>
#include <libintl.h>
#include <locale.h>
#include <math.h>
#include <pwd.h>
#include <setjmp.h>
#include <signal.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stropts.h>
#include <sys/sysmacros.h>
#include <sys/time.h>
#include <time.h>
#include <unistd.h>
#include <wchar.h>
#include <wctype.h>

// ---------------- Integer Types Definitions -----------------

typedef int8_t int3_t;
typedef int64_t int80_t;

// ----------------- Float Types Definitions ------------------

typedef float float16_t;
typedef float float32_t;
typedef double float64_t;
typedef long double float80_t;

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct _TYPEDEF___mbstate_t {
    int32_t e0;
    int32_t e1;
};

struct _TYPEDEF_sigset_t {
    int32_t e0[1];
};

struct __dirstream {
    int32_t e0;
};

struct dirent64 {
    int32_t e0;
    int32_t e1;
    int16_t e2;
    char e3;
    char e4[256];
};

struct group {
    char * e0;
    char * e1;
    int32_t e2;
    char ** e3;
};

struct lconv {
    char * e0;
    char * e1;
    char * e2;
    char * e3;
    char * e4;
    char * e5;
    char * e6;
    char * e7;
    char * e8;
    char * e9;
    char e10;
    char e11;
    char e12;
    char e13;
    char e14;
    char e15;
    char e16;
    char e17;
    char e18;
    char e19;
    char e20;
    char e21;
    char e22;
    char e23;
};

struct obstack {
    int32_t e0;
};

struct option {
    char * e0;
    int32_t e1;
    int32_t * e2;
    int32_t e3;
};

struct passwd {
    char * e0;
    char * e1;
    int32_t e2;
    int32_t e3;
    char * e4;
    char * e5;
    char * e6;
};

struct sigaction {
    void (*e0)(int32_t);
    int32_t e1;
    void (*e2)();
    struct _TYPEDEF_sigset_t e3;
};

struct stat64 {
    int64_t e0;
    int64_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int64_t e6;
    int64_t e7;
    int64_t e8;
    int32_t e9;
    int32_t e10;
    int64_t e11;
    int32_t e12;
    int32_t e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int32_t e17;
    int32_t e18;
    int32_t e19;
};

struct timespec {
    int32_t e0;
    int32_t e1;
};

struct timeval {
    int32_t e0;
    int32_t e1;
};

struct tm {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    char * e10;
};

// ------------------- Function Prototypes --------------------

int32_t __divdi3(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t __i686_get_pc_thunk_bx(int32_t a1);
int32_t __moddi3(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t __udivdi3(uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4);
int32_t __umoddi3(uint32_t result2, uint32_t a2, uint32_t a3, uint32_t a4);
int32_t __xargmatch_internal(char * context, char * arg, char ** arglist, char * vallist, int32_t valsize, void (*exit_fn)());
void add_ignore_pattern(char * pattern);
float64_t adjust_value(int32_t inexact_style, float64_t value);
int32_t * allocate_entry(int32_t * table);
char * areadlink_with_size(char * file, uint32_t size);
int32_t argmatch(char * arg, char ** arglist, char * vallist, int32_t valsize);
void argmatch_invalid(char * context, char * value, int32_t problem);
void argmatch_valid(char ** arglist, char * vallist, int32_t valsize);
void attach(char * dest, char * dirname, char * name);
int32_t base_len(char * name);
bool basename_is_dot_or_dotdot(char * name);
int32_t bkm_scale(int32_t * x, uint32_t scale_factor);
int32_t bkm_scale2(int64_t * x, uint32_t scale_factor);
int32_t bkm_scale_by_power(int32_t * x, int32_t base, int32_t power);
int32_t bkm_scale_by_power2(int64_t * x, int32_t base, int32_t power);
int32_t calculate_columns(bool by_columns);
bool check_tuning(int32_t * table);
void clear_files(void);
int32_t * clone_quoting_options(int32_t * o);
int32_t decode_switches(int32_t argc, char ** argv);
int64_t default_block_size(void);
void dev_ino_free(char * x);
int32_t dev_ino_pop(void);
void dired_dump_obstack(char * prefix, struct obstack * os);
bool dot_or_dotdot(char * file_name);
void emit_bug_reporting_address(void);
void extract_dirs_from_files(char * dirname, bool command_line_arg);
void file_failure(bool serious, char * message, char * file);
int32_t file_has_acl(char * name, int32_t * sb);
bool file_ignored(char * name);
char * file_name_concat(char * dir, char * abase, char ** base_in_result);
void filemodestring(int32_t * statp, char * str);
void format_group(int32_t g, int32_t width, bool stat_ok);
int32_t format_group_width(int32_t g);
void format_user(int32_t u, int32_t width, bool stat_ok);
void format_user_or_group(char * name, int32_t id, int32_t width);
int32_t format_user_or_group_width(char * name, int32_t id);
int32_t format_user_width(int32_t u);
void free_entry(int32_t * table, int32_t * entry);
void free_pending_ent(int32_t * p);
void freecon(char * con);
void fseterr(struct _IO_FILE * fp);
int32_t fstat64(int32_t a1, int32_t * a2);
char ftypelet(int32_t bits);
void get_current_time(void);
bool get_funky_string(char ** dest, char ** src, bool equals_end, int32_t * output_count);
void get_link_name(char * filename, int32_t * f, bool command_line_arg);
int32_t get_quoting_style(int32_t * o);
struct timespec get_stat_atime(int32_t * st);
struct timespec get_stat_ctime(int32_t * st);
struct timespec get_stat_mtime(int32_t * st);
char get_type_indicator(bool stat_ok, int32_t mode, int32_t type);
int32_t getfilecon(char * s, char ** con);
char * getgroup(int32_t gid);
char * gettext_quote(char * msgid, int32_t s);
char * getuser(int32_t uid);
int32_t gnu_mbswidth(char * string, int32_t flags);
int64_t gobble_file(char * name, int32_t type, int64_t inode, bool command_line_arg, char * dirname);
char * group_number(char * number, int32_t numberlen, char * grouping, char * thousands_sep);
bool hard_locale(int32_t category);
char * hash_delete(int32_t * table, int32_t * entry);
char * hash_find_entry(int32_t * table, int32_t * entry, int32_t ** bucket_head, bool delete);
void hash_free(int32_t * table);
int32_t hash_get_n_entries(int32_t * table);
int32_t * hash_initialize(int32_t candidate, int32_t * tuning, int32_t (*hasher)(int32_t *, int32_t), bool (*comparator)(int32_t *, int32_t *), void (*data_freer)(char *));
char * hash_insert(int32_t * table, int32_t * entry);
bool hash_rehash(int32_t * table, int32_t candidate);
int32_t human_options(char * spec, int32_t * opts, int64_t * block_size);
char * human_readable(int64_t n, char * buf, int32_t opts, int64_t from_block_size, int64_t to_block_size);
int32_t humblock(char * spec, int64_t * block_size, int32_t * options);
char * imaxtostr(int64_t i, char * buf);
void indent(uint32_t from, uint32_t to);
void init_column_info(void);
void initialize_exit_failure(int32_t status);
void initialize_ordering_vector(void);
bool is_colored(int32_t type);
bool is_directory(int32_t * f);
int32_t is_infinitel(float64_t x);
bool is_prime(uint32_t candidate);
int32_t iso_week_days(int32_t yday, int32_t wday);
char * last_component(char * name);
int32_t length_of_file_name_and_frills(int32_t * f);
int32_t lgetfilecon(char * s, char ** con);
int32_t long_time_expected_width(void);
char * longest_relative_suffix(char * f);
int32_t lstat64(int32_t a1, int32_t a2);
char * make_link_name(char * name, char * linkname);
int32_t mbsnwidth(char * string, int32_t nbytes, uint32_t flags);
char * memcpy_lowcase(char * dest, char * src, int32_t len);
char * memcpy_uppcase(char * dest, char * src, int32_t len);
char * mfile_name_concat(char * dir, char * abase, char ** base_in_result);
void mpsort(int32_t ** base, int32_t n, int32_t (*cmp)(int32_t *, int32_t *));
void mpsort_into_tmp(int32_t ** base, uint32_t n, int32_t ** tmp, int32_t (*cmp)(int32_t *, int32_t *));
void mpsort_with_tmp(int32_t ** base, uint32_t n, int32_t ** tmp, int32_t (*cmp)(int32_t *, int32_t *));
int32_t next_prime(uint32_t candidate);
int32_t nstrftime(char * s, int32_t maxsize, char * format2, struct tm * tp, int32_t ut, int32_t ns);
void parse_ls_color(void);
bool patterns_match(int32_t * patterns, char * file);
void prep_non_filename_text(void);
void print_color_indicator(char * name, int32_t mode, int32_t linkok, bool stat_ok, int32_t filetype);
void print_current_files(void);
void print_dir(char * name, char * realname, bool command_line_arg);
void print_file_name_and_frills(int32_t * f);
void print_horizontal(void);
void print_long_format(int32_t * f);
void print_many_per_line(void);
void print_name_with_quoting(char * p, int32_t mode, int32_t linkok, bool stat_ok, int32_t type, struct obstack * stack);
void print_type_indicator(bool stat_ok, int32_t mode, int32_t type);
void print_with_commas(void);
int32_t printf_fetchargs(char * args, int32_t * a);
int32_t printf_parse(char * format2, int32_t * d, int32_t * a);
void process_signals(void);
void put_indicator(int32_t * ind);
void queue_directory(char * name, char * realname, bool command_line_arg);
char * quote(char * name);
char * quote_n(int32_t n, char * name);
int32_t quote_name(struct _IO_FILE * out, char * name, int32_t * options, int32_t * width);
char * quotearg(char * arg);
int32_t quotearg_buffer(char * buffer, int32_t buffersize, char * arg, int32_t argsize, int32_t * o);
int32_t quotearg_buffer_restyled(char * buffer, uint32_t buffersize, char * arg, int32_t argsize, int32_t quoting_style, int32_t * o);
char * quotearg_char(char * arg, char ch);
char * quotearg_colon(char * arg);
char * quotearg_n(int32_t n, char * arg);
char * quotearg_n_options(uint32_t n, char * arg, int32_t argsize, int32_t * options);
char * quotearg_n_style(int32_t n, int32_t s, char * arg);
int32_t quoting_options_from_style(int32_t style);
void restore_default_color(void);
int32_t rpl_isnanl(float64_t x);
int32_t rpl_vfprintf(struct _IO_FILE * fp, char * format2, char * args);
int32_t set_char_quoting(int32_t * o, unsigned char c, uint32_t i);
void set_exit_status(bool serious);
void set_quoting_style(int32_t * o, int32_t s);
void sort_files(void);
int32_t stat64(int32_t a1, int32_t * a2);
int32_t strftime_case_(bool upcase, char * s, int32_t maxsize, char * format2, struct tm * tp, int32_t ut, int32_t ns);
void strmode(uint32_t mode, char * str);
char to_uchar(char ch);
char * umaxtostr(int64_t i, char * buf);
int64_t unsigned_file_size(int64_t size);
void usage(int32_t status);
char * vasnprintf(char * resultbuf, int32_t * lengthp, char * format2, char * args);
void version_etc(struct _IO_FILE * stream, char * command_name, char * package, char * version, ...);
void version_etc_va(struct _IO_FILE * stream, char * command_name, char * package, char * version, char * authors);
bool visit_dir(int64_t dev, int64_t ino);
void xalloc_die(void);
char * xcharalloc(int32_t n);
char * xmalloc(int32_t n);
int32_t xmax(uint32_t size1, uint32_t size2);
char * xmemdup(int32_t * p, int32_t s);
char * xnmalloc(uint32_t n, uint32_t s);
char * xnrealloc(char * p, uint32_t n, uint32_t s);
char * xrealloc(char * p, int32_t n);
char * xstrdup(char * string);
void xstrtol_error(uint32_t err, int32_t opt_idx, char c, struct option * long_options2, char * arg, int32_t exit_status2);
void xstrtol_fatal(int32_t err, int32_t opt_idx, char c, struct option * long_options2, char * arg);
int32_t xstrtoul(char * s, char ** ptr, uint32_t strtol_base, int32_t * val, char * valid_suffixes);
int32_t xstrtoumax(char * s, char ** ptr, uint32_t strtol_base, int64_t * val, char * valid_suffixes);
int32_t xsum(uint32_t size1, int32_t size2);
int32_t xsum2(uint32_t size1, int32_t size2);
int32_t xsum4(int32_t size1, int32_t size2, int32_t size3, int32_t size4);

// --------------------- Global Variables ---------------------

int32_t * active_dir_set = NULL; // 0x8064448
bool any_has_acl = false; // 0x8064469
void (*argmatch_die)() = (void (*)())0x8051a20; // 0x80643cc
int32_t author_width = 0; // 0x8064484
char * block_size_args[2] = {
    "human-readable",
    "si"
}; // 0x806191c
int32_t block_size_opts[2] = {176, 144}; // 0x8061928
int32_t block_size_width = 0; // 0x8064470
int32_t caught_signals = 0; // 0x8064500
bool check_symlink_color = false; // 0x80644c0
char * color_args[9] = {
    "always",
    "yes",
    "force",
    "never",
    "no",
    "none",
    "auto",
    "tty",
    "if-tty"
}; // 0x805ec20
int32_t color_buf = 0; // 0x80644bc
int32_t * color_ext_list = NULL; // 0x8064440
int32_t color_indicator = 2; // 0x80641e0
bool color_symlink_as_referent = false; // 0x8064460
int32_t color_types[9] = {1, 1, 1, 0, 0, 0, 2, 2, 2}; // 0x805ec60
int32_t * column_info = NULL; // 0x806458c
int32_t current_time = -0x80000000; // 0x80641c0
int32_t current_time_ns = -1; // 0x80641c4
int32_t * cwd_file = NULL; // 0x806444c
int32_t cwd_n_alloc = 0; // 0x8064450
int32_t cwd_n_used = 0; // 0x8064454
int32_t default_quoting_options = 0; // 0x8064720
int32_t default_tuning = 0; // 0x8061860
int32_t dereference = 0; // 0x80644c4
int32_t dev_ino_obstack = 0; // 0x8064620
bool directories_first = false; // 0x80644ca
bool dired = false; // 0x80644b0
int32_t dired_obstack = 0; // 0x80645a0
int32_t dired_pos = 0; // 0x8064594
int32_t * dirname_quoting_options = NULL; // 0x80644e0
int32_t exit_failure = 1; // 0x80643d0
int32_t exit_status = 0; // 0x8064588
int32_t failed_strcoll = 0; // 0x8064660
int64_t file_output_block_size = 1; // 0x80641d0
int32_t file_size_width = 0; // 0x8064490
int32_t * filename_quoting_options = NULL; // 0x80644dc
int32_t format = 0; // 0x8064494
char * format_args[7] = {
    "verbose",
    "long",
    "commas",
    "horizontal",
    "across",
    "vertical",
    "single-column"
}; // 0x805eb20
bool format_needs_stat = false; // 0x80644f0
bool format_needs_type = false; // 0x80644f1
int32_t format_types[7] = {0, 0, 4, 3, 3, 2, 1}; // 0x805eb40
int32_t g1 = -0x5e1a76ab; // 0x8049f5e
int32_t g2 = -0x5e1a76ab; // 0x8049f74
int32_t g3 = 0x6d005b1b; // 0x805e634
int32_t g4 = 20; // 0x805ed40
char * g5; // 0x805ed70
char * g6 = "s"; // 0x805efe2
char * g7 = "?"; // 0x805f99e
char * g8 = "."; // 0x80618f9
int32_t g9 = 0x302e2500; // 0x80618fb
char * g10; // 0x80619ac
int32_t g11 = 0x73650063; // 0x80619db
char * g12 = "\""; // 0x8061a3c
int32_t g13 = 0x37000000; // 0x8061d05
int32_t g14 = 0; // 0x80641d4
int32_t g16 = 1; // 0x80641e8
int32_t g17 = 0; // 0x80641f0
int32_t g18 = 0; // 0x80641f4
int32_t g19 = 1; // 0x80641f8
int32_t g20 = 5; // 0x8064210
char (*g21)[6] = "01;36"; // 0x8064214
int32_t g22 = 0; // 0x806423c
char (*g23)[12] = "%b %e %H:%M"; // 0x8064284
char g24 = 1; // 0x8064288
int32_t g25 = -1; // 0x8064380
int32_t g26 = 12; // 0x80643a0
int32_t g28 = 0; // 0x8064400
struct _IO_FILE * g29 = NULL; // 0x8064404
struct obstack * g30 = NULL; // 0x8064420
char * g31; // 0x8064424
int32_t g32 = 0; // 0x8064444
int32_t g33 = 0; // 0x80644ac
int32_t g34 = 0; // 0x80645ec
int32_t g35 = 0; // 0x80645f0
int32_t g36 = 0; // 0x8064628
int32_t g37 = 0; // 0x806462c
int32_t g38 = 0; // 0x8064630
int32_t * group_alist = NULL; // 0x8064708
int32_t group_width = 0; // 0x8064480
int32_t * hide_patterns = NULL; // 0x80644d4
int32_t human_output_opts = 0; // 0x80644a4
int32_t ignore_mode = 0; // 0x80644cc
int32_t * ignore_patterns = NULL; // 0x80644d0
bool immediate_dirs = false; // 0x80644c9
char * indicator_name[20] = {
    "lc",
    "rc",
    "ec",
    "no",
    "fi",
    "di",
    "ln",
    "pi",
    "so",
    "bd",
    "cd",
    "mi",
    "or",
    "ex",
    "do",
    "su",
    "sg",
    "st",
    "ow",
    "tw"
}; // 0x805e5e0
int32_t indicator_style = 0; // 0x80644b4
char * indicator_style_args[4] = {
    "none",
    "slash",
    "file-type",
    "classify"
}; // 0x805e56c
int32_t indicator_style_types[4] = {0, 1, 2, 3}; // 0x805e580
int32_t inode_number_width = 0; // 0x806446c
int32_t interrupt_signal = 0; // 0x8064580
int32_t line_length = 0; // 0x80644ec
int32_t long_options = 0x805e690; // 0x805e840
char * long_time_format[2] = {
    "z\xe6\x05\b\x84\xe6\x05\b\x01",
    "\x84\xe6\x05\b\x01"
}; // 0x8064280
int32_t ls_mode = 1; // 0x80643c8
int32_t major_device_number_width = 0; // 0x8064488
int32_t max_idx = 0; // 0x8064590
int32_t mbstate_zero = 0; // 0x8064860
int32_t minor_device_number_width = 0; // 0x806448c
int32_t nlink_width = 0; // 0x8064474
int32_t nslots = 1; // 0x80643d4
bool numeric_ids = false; // 0x80644a2
int64_t output_block_size = 0; // 0x80644a8
int32_t owner_width = 0; // 0x806447c
int32_t * pending_dirs = NULL; // 0x8064464
bool print_author = false; // 0x80644a1
bool print_block_size = false; // 0x80644a3
bool print_dir_name = false; // 0x80644e8
bool print_group = true; // 0x80641cb
bool print_inode = false; // 0x80644c1
bool print_owner = true; // 0x80641ca
bool print_scontext = false; // 0x8064468
bool print_with_color = false; // 0x80644b8
int32_t program_name = 0; // 0x8064868
bool qmark_funny_chars = false; // 0x80644d8
int32_t quoting_style_vals[7] = {0, 1, 2, 3, 4, 5, 6}; // 0x8061a20
bool recursive = false; // 0x80644c8
int32_t scontext_width = 0; // 0x8064478
char slot0[256]; // 0x8064760
int32_t * slotvec = (int32_t *)0x80643d8; // 0x80643e0
int32_t slotvec0 = 256; // 0x80643d8
char * sort_args[5] = {
    "none",
    "time",
    "size",
    "extension",
    "version"
}; // 0x805eb68
int32_t (*sort_functions[7][2][2][2])(int32_t *, int32_t *) = {
    {
        {
            {
                (int32_t (*)(int32_t *, int32_t *))0x804e3f1,
                (int32_t (*)(int32_t *, int32_t *))0x804e497            
},
            {
                (int32_t (*)(int32_t *, int32_t *))0x804e453,
                (int32_t (*)(int32_t *, int32_t *))0x804e587            
}        
},
        {
            {
                (int32_t (*)(int32_t *, int32_t *))0x804e431,
                (int32_t (*)(int32_t *, int32_t *))0x804e50f            
},
            {
                (int32_t (*)(int32_t *, int32_t *))0x804e475,
                (int32_t (*)(int32_t *, int32_t *))0x804e5ff            
}        
}    
},
    {
        {
            {
                (int32_t (*)(int32_t *, int32_t *))0x804e677,
                (int32_t (*)(int32_t *, int32_t *))0x804e7a0            
},
            {
                (int32_t (*)(int32_t *, int32_t *))0x804e75c,
                (int32_t (*)(int32_t *, int32_t *))0x804e890            
}        
},
        {
            {
                (int32_t (*)(int32_t *, int32_t *))0x804e73a,
                (int32_t (*)(int32_t *, int32_t *))0x804e818            
},
            {
                (int32_t (*)(int32_t *, int32_t *))0x804e77e,
                (int32_t (*)(int32_t *, int32_t *))0x804e908            
}        
}    
},
    {
        {
            {
                (int32_t (*)(int32_t *, int32_t *))0x804e0ce,
                (int32_t (*)(int32_t *, int32_t *))0x804e211            
},
            {
                (int32_t (*)(int32_t *, int32_t *))0x804e1cd,
                (int32_t (*)(int32_t *, int32_t *))0x804e301            
}        
},
        {
            {
                (int32_t (*)(int32_t *, int32_t *))0x804e1ab,
                (int32_t (*)(int32_t *, int32_t *))0x804e289            
},
            {
                (int32_t (*)(int32_t *, int32_t *))0x804e1ef,
                (int32_t (*)(int32_t *, int32_t *))0x804e379            
}        
}    
},
    {
        {
            {
                (int32_t (*)(int32_t *, int32_t *))0x804e980,
                (int32_t (*)(int32_t *, int32_t *))0x804e9d2            
},
            {
                (int32_t (*)(int32_t *, int32_t *))0x804e9b8,
                (int32_t (*)(int32_t *, int32_t *))0x804ea42            
}        
},
        {0}    
},
    {
        {
            {
                (int32_t (*)(int32_t *, int32_t *))0x804dac0,
                (int32_t (*)(int32_t *, int32_t *))0x804dbe7            
},
            {
                (int32_t (*)(int32_t *, int32_t *))0x804dba3,
                (int32_t (*)(int32_t *, int32_t *))0x804dcd7            
}        
},
        {
            {
                (int32_t (*)(int32_t *, int32_t *))0x804db81,
                (int32_t (*)(int32_t *, int32_t *))0x804dc5f            
},
            {
                (int32_t (*)(int32_t *, int32_t *))0x804dbc5,
                (int32_t (*)(int32_t *, int32_t *))0x804dd4f            
}        
}    
},
    {
        {
            {
                (int32_t (*)(int32_t *, int32_t *))0x804d775,
                (int32_t (*)(int32_t *, int32_t *))0x804d8e0            
},
            {
                (int32_t (*)(int32_t *, int32_t *))0x804d89c,
                (int32_t (*)(int32_t *, int32_t *))0x804d9d0            
}        
},
        {
            {
                (int32_t (*)(int32_t *, int32_t *))0x804d87a,
                (int32_t (*)(int32_t *, int32_t *))0x804d958            
},
            {
                (int32_t (*)(int32_t *, int32_t *))0x804d8be,
                (int32_t (*)(int32_t *, int32_t *))0x804da48            
}        
}    
},
    {
        {
            {
                (int32_t (*)(int32_t *, int32_t *))0x804ddc7,
                (int32_t (*)(int32_t *, int32_t *))0x804deee            
},
            {
                (int32_t (*)(int32_t *, int32_t *))0x804deaa,
                (int32_t (*)(int32_t *, int32_t *))0x804dfde            
}        
},
        {
            {
                (int32_t (*)(int32_t *, int32_t *))0x804de88,
                (int32_t (*)(int32_t *, int32_t *))0x804df66            
},
            {
                (int32_t (*)(int32_t *, int32_t *))0x804decc,
                (int32_t (*)(int32_t *, int32_t *))0x804e056            
}        
}    
}
}; // 0x80642a0
bool sort_reverse = false; // 0x80644a0
int32_t sort_type = 0; // 0x806449c
int32_t sort_types[5] = {-1, 4, 2, 1, 3}; // 0x805eb80
char ** sorted_file = NULL; // 0x8064458
int32_t sorted_file_alloc = 0; // 0x806445c
int32_t stop_signal_count = 0; // 0x8064584
int32_t subdired_obstack = 0; // 0x80645e0
int32_t tabsize = 0; // 0x80644e4
char * time_args[5] = {
    "atime",
    "access",
    "use",
    "ctime",
    "status"
}; // 0x805ebb4
char * time_style_args[4] = {
    "full-iso",
    "long-iso",
    "iso",
    "locale"
}; // 0x805e528
int32_t time_style_types[4] = {0, 1, 2, 3}; // 0x805e53c
int32_t time_type = 0; // 0x8064498
int32_t time_types[5] = {2, 2, 2, 1, 1}; // 0x805ebcc
int32_t * user_alist = NULL; // 0x8064700
int32_t g39;
int32_t g40;
int32_t g41;
int32_t g42;
int32_t g43;
int32_t g44;
int32_t g45;
int32_t g46;
int32_t g47;
int32_t g48;
int32_t g49;
int32_t g50;
int32_t g51;
int32_t g52;
int32_t g53;
int32_t g54;
int32_t g55;
int32_t g56;
int32_t * g15 = &g3; // 0x80641e4
char (*g27)[256] = &slot0; // 0x80643dc
char * quoting_style_args[7] = {
    "literal",
    "shell",
    "shell-always",
    (char *)&g11,
    "escape",
    "locale",
    "clocale"
}; // 0x8061a00

// ------------------------ Functions -------------------------

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/ls.c
// Address range: 0x8049b84 - 0x8049c3b
// Line range:    917 - 921
int32_t dev_ino_pop(void) {
    int32_t v1 = g37; // 0x8049ba8
    if (g37 - g36 < 16) {
        // 0x8049baa
        __assert_fail("sizeof (struct dev_ino) <= __extension__ ({ struct obstack const *__o = (&dev_ino_obstack); (unsigned) (__o->next_free - __o->object_base); })", "ls.c", 918, "dev_ino_pop");
        v1 = g37;
    }
    int32_t v2 = v1; // 0x8049bf3
    if (g38 - v1 <= 0xffffffef) {
        // 0x8049bf5
        _obstack_newchunk((struct obstack *)&dev_ino_obstack, -16);
        v2 = g37;
    }
    int32_t v3 = v2 - 16; // 0x8049c10
    g37 = v3;
    int32_t result; // 0x8049b84
    memmove((int32_t *)result, (int32_t *)v3, 16);
    return result;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/ls.c
// Address range: 0x8049c3b - 0x8049d54
// Line range:    940 - 955
void dired_dump_obstack(char * prefix, struct obstack * os) {
    int32_t v1 = (int32_t)os;
    int32_t * v2 = (int32_t *)(v1 + 12); // 0x8049c4b
    int32_t v3 = *v2; // 0x8049c4b
    int32_t * v4 = (int32_t *)(v1 + 8); // 0x8049c53
    int32_t v5 = *v4; // 0x8049c53
    uint32_t v6 = v3 - v5; // 0x8049c58
    if (v6 < 4) {
        // 0x8049d4e
        return;
    }
    int32_t v7 = v3; // 0x8049c84
    if (v3 == v5) {
        char * v8 = (char *)(v1 + 40); // 0x8049c89
        *v8 = *v8 | 2;
        v7 = *v2;
    }
    int32_t v9 = *(int32_t *)(v1 + 24); // 0x8049c9c
    int32_t v10 = v9 + v7 & -1 - v9; // 0x8049cac
    *v2 = v10;
    int32_t v11 = *(int32_t *)(v1 + 4); // 0x8049cc1
    if (v10 - v11 > v10 - v11) {
        // 0x8049ce0
        *v2 = v10;
    }
    // 0x8049d1b
    *v4 = v10;
    fputs_unlocked(prefix, (struct _IO_FILE *)g30);
    int32_t v12 = 0; // 0x8049d36
    printf(" %lu", *(int32_t *)(4 * v12 + v5));
    v12++;
    while (v12 != v6 / 4) {
        // 0x8049d1b
        printf(" %lu", *(int32_t *)(4 * v12 + v5));
        v12++;
    }
    // 0x8049d42
    putchar_unlocked(10);
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/ls.c
// Address range: 0x8049df4 - 0x8049e07
// Line range:    974 - 976
void dev_ino_free(char * x) {
    // 0x8049df4
    free((int32_t *)x);
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/ls.c
// Address range: 0x8049e07 - 0x8049e97
// Line range:    984 - 1011
bool visit_dir(int64_t dev, int64_t ino) {
    char * v1 = xmalloc(16); // 0x8049e2c
    int32_t v2 = (int32_t)v1; // 0x8049e34
    *(int32_t *)(v2 + 8) = (int32_t)dev;
    *(int32_t *)(v2 + 12) = (int32_t)ino;
    char * v3 = hash_insert(active_dir_set, (int32_t *)v1); // 0x8049e61
    if (v3 == NULL) {
        // 0x8049e6f
        xalloc_die();
        // UNREACHABLE
    }
    if (v3 != v1) {
        // 0x8049e86
        free((int32_t *)v1);
    }
    // 0x8049e91
    return v3 != v1;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/ls.c
// Address range: 0x8049e97 - 0x8049ec5
// Line range:    1015 - 1019
void free_pending_ent(int32_t * p) {
    // 0x8049e97
    free((int32_t *)*p);
    free((int32_t *)*(int32_t *)((int32_t)p + 4));
    free(p);
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/ls.c
// Address range: 0x8049ec5 - 0x8049f3e
// Line range:    1023 - 1029
bool is_colored(int32_t type) {
    int32_t v1 = 8 * type; // 0x8049ece
    int32_t v2 = *(int32_t *)(v1 + (int32_t)&color_indicator); // 0x8049ece
    if (v2 == 0) {
        // 0x8049f38
        return false;
    }
    char * v3 = (char *)v2; // 0x8049ed5
    char * str = (char *)*(int32_t *)(v1 + (int32_t)&g15); // 0x8049ee2
    if (v3 == (char *)1) {
        // 0x8049ef1
        if (*str == 48) {
            // 0x8049f38
            return false;
        }
    }
    // 0x8049f03
    if (v3 != (char *)2 || strncmp(str, "00", 2) != 0) {
        // 0x8049f38
        return true;
    }
    // 0x8049f38
    return false;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/ls.c
// Address range: 0x8049f3e - 0x8049f5e
// Line range:    1033 - 1036
void restore_default_color(void) {
    // 0x8049f3e
    put_indicator(&color_indicator);
    put_indicator(&g16);
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/ls.c
// Address range: 0x8049f8f - 0x804a04a
// Line range:    1068 - 1103
void process_signals(void) {
    // 0x8049f8f
    if ((stop_signal_count || interrupt_signal) == 0) {
        // 0x804a048
        return;
    }
    restore_default_color();
    fflush_unlocked((struct _IO_FILE *)g30);
    int32_t oset; // bp-140, 0x8049f8f
    sigprocmask(SIG_BLOCK, (struct _TYPEDEF_sigset_t *)&caught_signals, (struct _TYPEDEF_sigset_t *)&oset);
    int32_t sig_num; // 0x8049f8f
    if (stop_signal_count == 0) {
        // 0x8049ff7
        signal(interrupt_signal, SIG_DFL);
        sig_num = interrupt_signal;
    } else {
        // 0x8049fe3
        stop_signal_count--;
        sig_num = 19;
    }
    // 0x804a00a
    raise(sig_num);
    sigprocmask(SIG_SETMASK, (struct _TYPEDEF_sigset_t *)&oset, NULL);
    while ((stop_signal_count || interrupt_signal) != 0) {
        // 0x8049f9d
        restore_default_color();
        fflush_unlocked((struct _IO_FILE *)g30);
        sigprocmask(SIG_BLOCK, (struct _TYPEDEF_sigset_t *)&caught_signals, (struct _TYPEDEF_sigset_t *)&oset);
        if (stop_signal_count == 0) {
            // 0x8049ff7
            signal(interrupt_signal, SIG_DFL);
            sig_num = interrupt_signal;
        } else {
            // 0x8049fe3
            stop_signal_count--;
            sig_num = 19;
        }
        // 0x804a00a
        raise(sig_num);
        sigprocmask(SIG_SETMASK, (struct _TYPEDEF_sigset_t *)&oset, NULL);
    }
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/ls.c
// Address range: 0x804a04a - 0x804a844
// Line range:    1107 - 1368
int main(int argc, char ** argv) {
    // 0x804a04a
    int32_t v1; // 0x804a04a
    int32_t * v2 = (int32_t *)((int32_t)&v1 + 4); // 0x804a06c
    program_name = *(int32_t *)*v2;
    int32_t v3 = 6; // bp-272, 0x804a07e
    setlocale(LC_ALL, (char *)&g5);
    v3 = (int32_t)"coreutils";
    bindtextdomain("coreutils", "/usr/local/share/locale");
    v3 = (int32_t)"coreutils";
    textdomain("coreutils");
    v3 = 2;
    initialize_exit_failure(2);
    v3 = 0x8051e8d;
    atexit(0x8051e8d);
    exit_status = 0;
    *(char *)&print_dir_name = 1;
    *(int32_t *)&pending_dirs = 0;
    v3 = v1;
    int32_t v4 = decode_switches(v1, (char **)*v2); // 0x804a0f5
    if (*(char *)&print_with_color != 0) {
        // 0x804a10d
        parse_ls_color();
        if (*(char *)&print_with_color != 0) {
            // 0x804a11c
            v3 = 12;
            if (is_colored(12)) {
                // 0x804a166
                *(char *)&check_symlink_color = 1;
            } else {
                // 0x804a12c
                v3 = 13;
                is_colored(13);
                v3 = 11;
                is_colored(11);
            }
            // 0x804a16d
            v3 = 1;
            if (tcgetpgrp(1) >= 0) {
                // 0x804a181
                v3 = &caught_signals;
                sigemptyset((struct _TYPEDEF_sigset_t *)&caught_signals);
                int32_t oact; // bp-200, 0x804a04a
                for (int32_t i = 0; i < 12; i++) {
                    int32_t * sig_num2 = (int32_t *)(4 * i + (int32_t)&g4); // 0x804a199
                    int32_t sig_num = *sig_num2; // 0x804a199
                    v3 = sig_num;
                    sigaction(sig_num, NULL, (struct sigaction *)&oact);
                    if (oact != 1) {
                        // 0x804a1c5
                        v3 = &caught_signals;
                        sigaddset((struct _TYPEDEF_sigset_t *)&caught_signals, *sig_num2);
                    }
                }
                // 0x804a1e9
                int32_t v5; // bp-196, 0x804a04a
                __asm_rep_movsd_memcpy((char *)&v5, (char *)&caught_signals, 32);
                for (int32_t i = 0; i < 12; i++) {
                    int32_t * sig_num3 = (int32_t *)(4 * i + (int32_t)&g4); // 0x804a230
                    v3 = &caught_signals;
                    if (sigismember((struct _TYPEDEF_sigset_t *)&caught_signals, *sig_num3) != 0) {
                        int32_t v6 = *sig_num3; // 0x804a24e
                        int32_t v7 = v6 != 20 ? (int32_t)&g1 : (int32_t)&g2;
                        oact = v7;
                        int32_t sig_num4 = *sig_num3; // 0x804a27f
                        v3 = sig_num4;
                        sigaction(sig_num4, (struct sigaction *)&oact, NULL);
                    }
                }
            }
            // 0x804a2aa
            prep_non_filename_text();
        }
    }
    // 0x804a2af
    if (dereference == 1) {
        int32_t v8 = 2; // 0x804a2c2
        if (*(char *)&immediate_dirs == 0 && indicator_style != 3) {
            // 0x804a2ce
            v8 = format != 0 ? 4 : 2;
        }
        // 0x804a2ed
        dereference = v8;
    }
    // 0x804a2f9
    if (*(char *)&recursive != 0) {
        // 0x804a304
        v3 = 30;
        int32_t * v9 = hash_initialize(30, NULL, (int32_t (*)(int32_t *, int32_t))0x8049d54, (bool (*)(int32_t *, int32_t *))0x8049d8b, (void (*)(char *))0x8049df4); // 0x804a32b
        *(int32_t *)&active_dir_set = (int32_t)v9;
        if (v9 == NULL) {
            // 0x804a33e
            xalloc_die();
            // UNREACHABLE
        }
        // 0x804a343
        v3 = &dev_ino_obstack;
        _obstack_begin((struct obstack *)&dev_ino_obstack, 0, 0, (int32_t * (*)(int32_t))0x804993c, (void (*)(int32_t *))0x804970c);
    }
    // 0x804a370
    char v10; // 0x804a04a
    if (format == 0) {
        // 0x804a3b9
        *(char *)&format_needs_stat = 1;
        // 0x804a40c
        v10 = 0;
        goto lab_0x804a416;
    } else {
        // switch.early.test
        switch (sort_type) {
            case 4: {
                // 0x804a3b9
                *(char *)&format_needs_stat = 1;
                // 0x804a40c
                v10 = 0;
                goto lab_0x804a416;
            }
            case 2: {
                // 0x804a3b9
                *(char *)&format_needs_stat = 1;
                // 0x804a40c
                v10 = 0;
                goto lab_0x804a416;
            }
            default: {
                char v11 = *(char *)&print_scontext; // 0x804a38d
                char v12 = *(char *)&print_block_size; // 0x804a398
                *(char *)&format_needs_stat = (char)((v12 | v11) != 0);
                if ((v12 || v11) != 0) {
                    // 0x804a40c
                    v10 = 0;
                    goto lab_0x804a416;
                } else {
                    // 0x804a3d6
                    v10 = 1;
                    if (*(char *)&recursive != 0) {
                        goto lab_0x804a416;
                    } else {
                        // 0x804a3e1
                        v10 = 1;
                        if (*(char *)&print_with_color != 0) {
                            goto lab_0x804a416;
                        } else {
                            // 0x804a3ec
                            v10 = 1;
                            if (indicator_style == 0 == *(char *)&directories_first == 0) {
                                // 0x804a40c
                                v10 = 0;
                                goto lab_0x804a416;
                            } else {
                                goto lab_0x804a416;
                            }
                        }
                    }
                }
            }
        }
    }
  lab_0x804a6f0:;
    // 0x804a6f0
    int32_t v13; // 0x804a04a
    if (*(char *)&print_with_color != 0) {
        // 0x804a6ff
        restore_default_color();
        int32_t * v14 = (int32_t *)v13; // 0x804a709
        *v14 = (int32_t)g30;
        fflush_unlocked((struct _IO_FILE *)&g49);
        int32_t * v15 = (int32_t *)(v13 + 4); // 0x804a724
        for (int32_t i = 0; i < 12; i++) {
            int32_t * v16 = (int32_t *)(4 * i + (int32_t)&g4); // 0x804a71d
            *v15 = *v16;
            *v14 = (int32_t)&caught_signals;
            if (sigismember((struct _TYPEDEF_sigset_t *)i, (int32_t)&g49) != 0) {
                // 0x804a738
                *v15 = 0;
                *v14 = *v16;
                signal((int32_t)&g49, (void (*)(int32_t))&g49);
            }
        }
        // 0x804a75c
        if (stop_signal_count != 0) {
            *v14 = 19;
            raise(stop_signal_count);
            int32_t v17 = stop_signal_count - 1; // 0x804a772
            int32_t sig_num5 = v17; // 0x804a77a
            while (v17 != 0) {
                // 0x804a766
                *v14 = 19;
                raise(sig_num5);
                v17 = sig_num5 - 1;
                sig_num5 = v17;
            }
        }
        // 0x804a77c
        if (interrupt_signal != 0) {
            // 0x804a78a
            *v14 = interrupt_signal;
            raise(interrupt_signal);
        }
    }
    // 0x804a795
    if (*(char *)&dired != 0) {
        int32_t * v18 = (int32_t *)(v13 + 4); // 0x804a7a0
        *v18 = (int32_t)&dired_obstack;
        int32_t * v19 = (int32_t *)v13; // 0x804a7a8
        *v19 = (int32_t)"//DIRED//";
        dired_dump_obstack((char *)&g49, (struct obstack *)&g49);
        *v18 = (int32_t)&subdired_obstack;
        *v19 = (int32_t)"//SUBDIRED//";
        dired_dump_obstack((char *)&g49, (struct obstack *)&g49);
        *v19 = (int32_t)filename_quoting_options;
        int32_t v20 = get_quoting_style(&g49); // 0x804a7d0
        *v18 = *(int32_t *)(4 * v20 + (int32_t)&quoting_style_args);
        *v19 = (int32_t)"//DIRED-OPTIONS// --quoting-style=%s\n";
        printf((char *)&g49);
    }
    // 0x804a7ec
    if (active_dir_set == NULL) {
        // 0x804a837
        *(int32_t *)v13 = exit_status;
        exit((int32_t)&g49);
        return &g49;
    }
    int32_t * v21 = (int32_t *)v13;
    *v21 = (int32_t)active_dir_set;
    if (hash_get_n_entries(&g49) != 0) {
        // 0x804a806
        *(int32_t *)(v13 + 12) = (int32_t)"main";
        *(int32_t *)(v13 + 8) = 1364;
        *(int32_t *)(v13 + 4) = (int32_t)"ls.c";
        *v21 = (int32_t)"hash_get_n_entries (active_dir_set) == 0";
        __assert_fail((char *)&g49, (char *)&g49, (int32_t)&g49, (char *)&g49);
    }
    // 0x804a82a
    *v21 = (int32_t)active_dir_set;
    hash_free(&g49);
    // 0x804a837
    *v21 = exit_status;
    exit((int32_t)&g49);
    return &g49;
  lab_0x804a416:
    // 0x804a416
    *(char *)&format_needs_type = v10;
    if (*(char *)&dired != 0) {
        // 0x804a42d
        v3 = &dired_obstack;
        _obstack_begin((struct obstack *)&dired_obstack, 0, 0, (int32_t * (*)(int32_t))0x804993c, (void (*)(int32_t *))0x804970c);
        v3 = &subdired_obstack;
        _obstack_begin((struct obstack *)&subdired_obstack, 0, 0, (int32_t * (*)(int32_t))0x804993c, (void (*)(int32_t *))0x804970c);
    }
    // 0x804a487
    cwd_n_alloc = 100;
    v3 = 100;
    char * v22 = xnmalloc(100, 120); // 0x804a4a1
    *(int32_t *)&cwd_file = (int32_t)v22;
    cwd_n_used = 0;
    clear_files();
    int32_t v23 = v1 - v4; // 0x804a4c5
    if (v23 >= 0 == (v23 != 0)) {
        int32_t v24 = *(int32_t *)(4 * v4 + *v2); // 0x804a53e
        int32_t v25 = v4 + 1; // 0x804a540
        v3 = v24;
        gobble_file((char *)v24, 0, 0, false, (char *)1);
        int32_t v26 = v25; // 0x804a57f
        while (v25 < v1) {
            // 0x804a52f
            v24 = *(int32_t *)(4 * v26 + *v2);
            v25 = v26 + 1;
            v3 = v24;
            gobble_file((char *)v24, 0, 0, false, (char *)1);
            v26 = v25;
        }
    } else {
        // 0x804a4d0
        v3 = (int32_t)".";
        if (*(char *)&immediate_dirs == 0) {
            // 0x804a511
            queue_directory(".", NULL, true);
        } else {
            // 0x804a4db
            gobble_file(".", 3, 0, false, (char *)1);
        }
    }
    int32_t v27 = &v3; // 0x804a05a
    int32_t v28; // 0x804a04a
    if (cwd_n_used == 0) {
        goto lab_0x804a5ea;
    } else {
        // 0x804a58a
        sort_files();
        if (*(char *)&immediate_dirs != 1) {
            // 0x804a59d
            v3 = 0;
            extract_dirs_from_files(NULL, true);
        }
        // 0x804a5b1
        if (cwd_n_used == 0) {
            goto lab_0x804a5ea;
        } else {
            // 0x804a5ba
            print_current_files();
            v13 = v27;
            if (pending_dirs == NULL) {
                goto lab_0x804a6f0;
            } else {
                // 0x804a5cc
                v3 = 10;
                putchar_unlocked(10);
                dired_pos++;
                v28 = (int32_t)pending_dirs;
                goto lab_0x804a6e3;
            }
        }
    }
  lab_0x804a5ea:;
    int32_t v29 = (int32_t)pending_dirs;
    v28 = v29;
    int32_t v30; // 0x804a04a
    if (v23 > 1 || pending_dirs == NULL) {
        goto lab_0x804a6e3;
    } else {
        // 0x804a601
        v30 = v29;
        if (block_size_width == 0) {
            // 0x804a611
            *(char *)&print_dir_name = 0;
            v30 = v29;
        }
        goto lab_0x804a61d;
    }
  lab_0x804a6e3:
    // 0x804a6e3
    v30 = v28;
    v13 = v27;
    if (pending_dirs != NULL) {
        goto lab_0x804a61d;
    } else {
        goto lab_0x804a6f0;
    }
  lab_0x804a61d:;
    // 0x804a61d
    int32_t v31; // bp-60, 0x804a04a
    int32_t v32 = &v31;
    int32_t * v33 = (int32_t *)(v27 + 8);
    int32_t * v34 = (int32_t *)(v27 + 4);
    int32_t * v35 = (int32_t *)v27;
    int32_t * thispend; // bp-40, 0x804a04a
    *(int32_t *)&thispend = v30;
    *(int32_t *)&pending_dirs = block_size_width;
    while (block_size_width != 0 || active_dir_set == NULL) {
        // 0x804a6ac
        *v33 = (int32_t)*(char *)&inode_number_width;
        *v34 = *(int32_t *)&print_scontext;
        *v35 = block_size_width;
        print_dir((char *)thispend, (char *)&g49, (bool)&g49);
        *v35 = (int32_t)thispend;
        free_pending_ent(&g49);
        *(char *)&print_dir_name = 1;
        v13 = v27;
        if (pending_dirs == NULL) {
            // break (via goto) -> 0x804a6f0
            goto lab_0x804a6f0;
        }
        *(int32_t *)&thispend = (int32_t)pending_dirs;
        *(int32_t *)&pending_dirs = block_size_width;
    }
    // 0x804a644
    *v35 = v32;
    dev_ino_pop();
    int32_t v36 = v27 - 4; // 0x804a64f
    *v35 = v32;
    int32_t * v37 = (int32_t *)v36; // 0x804a65f
    *v37 = (int32_t)active_dir_set;
    char * v38 = hash_delete(&g49, &g49); // 0x804a662
    if (v38 == NULL) {
        // 0x804a670
        *v33 = (int32_t)"main";
        *v34 = 1310;
        *v35 = (int32_t)"ls.c";
        *v37 = (int32_t)"found";
        __assert_fail(v38, (char *)&g49, (int32_t)&g49, (char *)&g49);
    }
    // 0x804a694
    *v37 = (int32_t)v38;
    dev_ino_free((char *)&g49);
    *v37 = (int32_t)thispend;
    free_pending_ent(&g49);
    v13 = v36;
    while (pending_dirs != NULL) {
        int32_t v39 = v36;
        v33 = (int32_t *)(v39 + 8);
        v34 = (int32_t *)(v39 + 4);
        v35 = (int32_t *)v39;
        *(int32_t *)&thispend = (int32_t)pending_dirs;
        *(int32_t *)&pending_dirs = block_size_width;
        while (block_size_width != 0 || active_dir_set == NULL) {
            // 0x804a6ac
            *v33 = (int32_t)*(char *)&inode_number_width;
            *v34 = *(int32_t *)&print_scontext;
            *v35 = block_size_width;
            print_dir((char *)thispend, (char *)&g49, (bool)&g49);
            *v35 = (int32_t)thispend;
            free_pending_ent(&g49);
            *(char *)&print_dir_name = 1;
            v13 = v39;
            if (pending_dirs == NULL) {
                // break (via goto) -> 0x804a6f0
                goto lab_0x804a6f0;
            }
            *(int32_t *)&thispend = (int32_t)pending_dirs;
            *(int32_t *)&pending_dirs = block_size_width;
        }
        // 0x804a644
        *v35 = v32;
        dev_ino_pop();
        v36 = v39 - 4;
        *v35 = v32;
        v37 = (int32_t *)v36;
        *v37 = (int32_t)active_dir_set;
        v38 = hash_delete(&g49, &g49);
        if (v38 == NULL) {
            // 0x804a670
            *v33 = (int32_t)"main";
            *v34 = 1310;
            *v35 = (int32_t)"ls.c";
            *v37 = (int32_t)"found";
            __assert_fail(v38, (char *)&g49, (int32_t)&g49, (char *)&g49);
        }
        // 0x804a694
        *v37 = (int32_t)v38;
        dev_ino_free((char *)&g49);
        *v37 = (int32_t)thispend;
        free_pending_ent(&g49);
        v13 = v36;
    }
    goto lab_0x804a6f0;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/system.h
// Address range: 0x804a844 - 0x804a857
// Line range:    131 - 134
void initialize_exit_failure(int32_t status) {
    if (status != 1) {
        // 0x804a84d
        exit_failure = status;
    }
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/ls.c
// Address range: 0x804a857 - 0x804b7d9
// Line range:    1376 - 1932
int32_t decode_switches(int32_t argc, char ** argv) {
    // 0x804a857
    int16_t v1; // 0x804a857
    uint16_t v2 = v1;
    char * v3 = NULL; // bp-76, 0x804a861
    *(char *)&qmark_funny_chars = 0;
    switch (ls_mode) {
        case 2: {
            // 0x804a89b
            format = 2;
            set_quoting_style(NULL, 4);
            // break -> 0x804a916
            break;
        }
        case 3: {
            // 0x804a8bb
            format = 0;
            set_quoting_style(NULL, 4);
            // break -> 0x804a916
            break;
        }
        case 1: {
            // 0x804a8db
            if (isatty(1) == 0) {
                // 0x804a8fe
                format = 1;
                *(char *)&qmark_funny_chars = 0;
            } else {
                // 0x804a8eb
                format = 2;
                *(char *)&qmark_funny_chars = 1;
            }
            // break -> 0x804a916
            break;
        }
        default: {
            // 0x804a911
            abort();
            // UNREACHABLE
        }
    }
    // 0x804a916
    time_type = 0;
    sort_type = 0;
    *(char *)&sort_reverse = 0;
    *(char *)&numeric_ids = 0;
    *(char *)&print_block_size = 0;
    indicator_style = 0;
    *(char *)&print_inode = 0;
    dereference = 1;
    *(char *)&recursive = 0;
    *(char *)&immediate_dirs = 0;
    ignore_mode = 0;
    *(int32_t *)&ignore_patterns = 0;
    *(int32_t *)&hide_patterns = 0;
    *(char *)&print_scontext = 0;
    char * env_val = getenv("QUOTING_STYLE"); // 0x804a994
    if (env_val != NULL) {
        int32_t v4 = argmatch(env_val, quoting_style_args, (char *)&quoting_style_vals, 4); // 0x804a9c1
        if (v4 < 0) {
            // 0x804a9eb
            quotearg(env_val);
            error(0, 0, gettext("ignoring invalid value of environment variable QUOTING_STYLE: %s"));
        } else {
            // 0x804a9cf
            set_quoting_style(NULL, *(int32_t *)(4 * v4 + (int32_t)&quoting_style_vals));
        }
    }
    char * env_val2 = getenv("LS_BLOCK_SIZE"); // 0x804aa27
    human_options(env_val2, &human_output_opts, &output_block_size);
    if (env_val2 != NULL) {
        goto lab_0x804aa60;
    } else {
        // 0x804aa50
        if (getenv("BLOCK_SIZE") == NULL) {
            goto lab_0x804aa76;
        } else {
            goto lab_0x804aa60;
        }
    }
  lab_0x804abd4:;
    int32_t v5 = -1; // bp-96, 0x804abd4
    int32_t v6 = getopt_long(argc, argv, "abcdfghiklmnopqrstuvw:xABCDFGHI:LNQRST:UXZ1", (struct option *)&long_options, &v5); // 0x804abff
    int32_t v7 = v6; // 0x804ac0b
    char v8; // 0x804a857
    char v9 = v8; // 0x804ac0b
    char v10 = v8; // 0x804ac0b
    if (v6 == -1) {
        goto lab_0x804b459;
    }
    goto lab_0x804ac11;
  lab_0x804ae66:
    // 0x804ae66
    quotearg(g31);
    error(2, 0, gettext("invalid line width: %s"));
    goto lab_0x804ae9d;
  lab_0x804b246:
    // 0x804b246
    *(char *)&print_with_color = 1;
    tabsize = 0;
    char v11; // 0x804a857
    v8 = v11;
    goto lab_0x804abd4;
  lab_0x804ae9d:;
    // 0x804ae9d
    int32_t v14; // bp-100, 0x804a857
    line_length = v14;
    v8 = v11;
    goto lab_0x804abd4;
  lab_0x804aa60:
    // 0x804aa60
    *(int32_t *)&file_output_block_size = *(int32_t *)&output_block_size;
    g14 = g33;
    goto lab_0x804aa76;
  lab_0x804aa76:
    // 0x804aa76
    line_length = 80;
    char * env_val3 = getenv("COLUMNS"); // 0x804aa87
    if (env_val3 != NULL) {
        // 0x804aa95
        if (*env_val3 != 0) {
            // 0x804aa9f
            char * time_style_option; // bp-80, 0x804a857
            int32_t v25 = xstrtoul(env_val3, NULL, 0, (int32_t *)&time_style_option, NULL); // 0x804aac4
            if (v25 != 0 || time_style_option == NULL) {
                // 0x804aade
                quotearg(env_val3);
                error(0, 0, gettext("ignoring invalid width in environment variable COLUMNS: %s"));
            } else {
                // 0x804aad4
                line_length = (int32_t)time_style_option;
            }
        }
    }
    // 0x804ab13
    if (!((v2 == 0 | ioctl(1, 0x5413) == -1))) {
        // 0x804ab3c
        line_length = v2;
    }
    char * env_val4 = getenv("TABSIZE"); // 0x804ab4f
    tabsize = 8;
    if (env_val4 != NULL) {
        // 0x804ab67
        int32_t v26; // bp-92, 0x804a857
        if (xstrtoul(env_val4, NULL, 0, &v26, NULL) != 0) {
            // 0x804ab9f
            quotearg(env_val4);
            error(0, 0, gettext("ignoring invalid tab size in environment variable TABSIZE: %s"));
        } else {
            // 0x804ab95
            tabsize = v26;
        }
    }
    // 0x804abd4
    v5 = -1;
    int32_t v27 = getopt_long(argc, argv, "abcdfghiklmnopqrstuvw:xABCDFGHI:LNQRST:UXZ1", (struct option *)&long_options, &v5); // 0x804abff
    v10 = 0;
    if (v27 == -1) {
      lab_0x804b459:;
        int32_t v28 = 1; // 0x804b461
        if (line_length >= 3) {
            // 0x804b463
            v28 = line_length / 3;
        }
        // 0x804b48b
        max_idx = v28;
        int32_t * v29 = clone_quoting_options(NULL); // 0x804b49b
        *(int32_t *)&filename_quoting_options = (int32_t)v29;
        if (get_quoting_style(v29) == 4) {
            // 0x804b4b7
            set_char_quoting(filename_quoting_options, 32, 1);
        }
        // 0x804b4d4
        if (indicator_style >= 2) {
            char v30 = *(char *)&g6; // 0x804b51a
            if (v30 != 0) {
                set_char_quoting(filename_quoting_options, v30, 1);
                char * v31 = (char *)((int32_t)(char *)&g6 + 1); // 0x804b513
                char v32 = *v31; // 0x804b51a
                char v33 = v32; // 0x804b51f
                char * v34 = v31; // 0x804b51f
                while (v32 != 0) {
                    // 0x804b4f0
                    set_char_quoting(filename_quoting_options, v33, 1);
                    v31 = (char *)((int32_t)v34 + 1);
                    v32 = *v31;
                    v33 = v32;
                    v34 = v31;
                }
            }
        }
        int32_t * v35 = clone_quoting_options(NULL); // 0x804b528
        *(int32_t *)&dirname_quoting_options = (int32_t)v35;
        set_char_quoting(v35, 58, 1);
        if (*(char *)&dired != 0 && format != 0) {
            // 0x804b563
            *(char *)&dired = 0;
        }
        int32_t v36 = time_type; // 0x804b56a
        if (v10 != 1 && format != 0 && v36 != 1 != v36 != 2) {
            // 0x804b592
            sort_type = 4;
        }
        if (format != 0) {
            // 0x804b7cd
            return g28;
        }
        char * str = v3; // 0x804b5b3
        if (v3 == NULL) {
            char * env_val5 = getenv("TIME_STYLE"); // 0x804b5bc
            str = env_val5 != NULL ? env_val5 : "locale";
        }
        // 0x804b5f7
        if (strncmp(str, "posix-", 6) == 0) {
            // 0x804b5d3
            hard_locale(2);
            // 0x804b7cd
            return g28;
        }
        // 0x804b616
        if (*str != 43) {
            int32_t v37 = __xargmatch_internal("time style", str, time_style_args, (char *)&time_style_types, 4, argmatch_die); // 0x804b6ef
            int32_t v38 = *(int32_t *)(4 * v37 + (int32_t)&time_style_types); // 0x804b6f4
            switch (v38) {
                case 0: {
                    // 0x804b71b
                    *(int32_t *)&g23 = (int32_t)"%Y-%m-%d %H:%M:%S.%N %z";
                    *(int32_t *)&long_time_format = (int32_t)"%Y-%m-%d %H:%M:%S.%N %z";
                    // 0x804b7cd
                    return g28;
                }
                case 2: {
                    // 0x804b74a
                    *(int32_t *)&long_time_format = (int32_t)"%Y-%m-%d ";
                    *(int32_t *)&g23 = (int32_t)"%m-%d %H:%M";
                    // 0x804b7cd
                    return g28;
                }
                case 3: {
                    // 0x804b760
                    if (!hard_locale(2)) {
                        // 0x804b7cd
                        return g28;
                    }
                    int32_t v39 = 0;
                    int32_t * v40 = (int32_t *)(4 * v39 + (int32_t)&long_time_format); // 0x804b77c
                    int32_t v41 = (int32_t)dcgettext(NULL, (char *)*v40, 2); // 0x804b796
                    while (*v40 != v41) {
                        // 0x804b7ad
                        *v40 = v41;
                        if (v39 == 1) {
                            // 0x804b7cd
                            return g28;
                        }
                        v39 = 1;
                        v40 = (int32_t *)(4 * v39 + (int32_t)&long_time_format);
                        v41 = (int32_t)dcgettext(NULL, (char *)*v40, 2);
                    }
                }
                case 1: {
                    // 0x804b734
                    *(int32_t *)&g23 = (int32_t)"%Y-%m-%d %H:%M";
                    *(int32_t *)&long_time_format = (int32_t)"%Y-%m-%d %H:%M";
                    // 0x804b7cd
                    return g28;
                }
                default: {
                    // 0x804b7cd
                    return g28;
                }
            }
        }
        int32_t v42 = (int32_t)str + 1; // 0x804b627
        char * str2 = (char *)v42;
        char * found_char_pos = strchr(str2, 10); // 0x804b63b
        if (found_char_pos == NULL) {
            // 0x804b6aa
            *(int32_t *)&long_time_format = v42;
            *(int32_t *)&g23 = v42;
            // 0x804b7cd
            return g28;
        }
        int32_t str3 = (int32_t)found_char_pos + 1; // 0x804b654
        if (strchr((char *)str3, 10) != NULL) {
            // 0x804b66b
            quote(str2);
            error(2, 0, gettext("invalid time style format %s"));
        }
        // 0x804b6a0
        *found_char_pos = 0;
        // 0x804b6aa
        *(int32_t *)&long_time_format = v42;
        *(int32_t *)&g23 = str3;
        // 0x804b7cd
        return g28;
    }
    // 0x804ac11
    v7 = v27;
    v9 = 0;
    while (true) {
      lab_0x804ac11:
        // 0x804ac11
        v11 = v9;
        g48 = v7 + 131;
        switch (v7) {
            case -131: {
                char * v12 = "ls"; // 0x804b3d5
                if (ls_mode != 1) {
                    // 0x804b3d7
                    v12 = ls_mode != 2 ? "vdir" : "dir";
                }
                // 0x804b400
                version_etc((struct _IO_FILE *)g30, v12, "GNU coreutils", "6.10");
                exit(0);
                // UNREACHABLE
            }
            case -130: {
                // 0x804b3bc
                usage(0);
                // UNREACHABLE
            }
            case 49: {
                // 0x804b052
                v8 = v11;
                if (format != 0) {
                    // 0x804b05f
                    format = 1;
                    v8 = v11;
                }
                goto lab_0x804abd4;
            }
            case 65: {
                // 0x804aeb9
                v8 = v11;
                if (ignore_mode == 0) {
                    // 0x804aec6
                    ignore_mode = 1;
                    v8 = v11;
                }
                goto lab_0x804abd4;
            }
            case 66: {
                // 0x804aed5
                add_ignore_pattern("*~");
                add_ignore_pattern(".*~");
                v8 = v11;
                goto lab_0x804abd4;
            }
            case 67: {
                // 0x804aef2
                format = 2;
                v8 = v11;
                goto lab_0x804abd4;
            }
            case 68: {
                // 0x804af01
                *(char *)&dired = 1;
                v8 = v11;
                goto lab_0x804abd4;
            }
            case 70: {
                // 0x804af0d
                indicator_style = 3;
                v8 = v11;
                goto lab_0x804abd4;
            }
            case 71: {
                // 0x804af1c
                *(char *)&print_group = 0;
                v8 = v11;
                goto lab_0x804abd4;
            }
            case 72: {
                // 0x804af28
                dereference = 3;
                v8 = v11;
                goto lab_0x804abd4;
            }
            case 73: {
                // 0x804af46
                add_ignore_pattern(g31);
                v8 = v11;
                goto lab_0x804abd4;
            }
            case 76: {
                // 0x804af58
                dereference = 5;
                v8 = v11;
                goto lab_0x804abd4;
            }
            case 78: {
                // 0x804af67
                set_quoting_style(NULL, 0);
                v8 = v11;
                goto lab_0x804abd4;
            }
            case 81: {
                // 0x804af80
                set_quoting_style(NULL, 3);
                v8 = v11;
                goto lab_0x804abd4;
            }
            case 82: {
                // 0x804af99
                *(char *)&recursive = 1;
                v8 = v11;
                goto lab_0x804abd4;
            }
            case 83: {
                // 0x804afa5
                sort_type = 2;
                v8 = 1;
                goto lab_0x804abd4;
            }
            case 84: {
                // 0x804afb8
                int32_t v13; // bp-104, 0x804a857
                if (xstrtoul(g31, NULL, 0, &v13, NULL) != 0) {
                    // 0x804afe8
                    quotearg(g31);
                    error(2, 0, gettext("invalid tab size: %s"));
                }
                // 0x804b01f
                tabsize = v13;
                v8 = v11;
                goto lab_0x804abd4;
            }
            case 85: {
                // 0x804b02c
                sort_type = -1;
                v8 = 1;
                goto lab_0x804abd4;
            }
            case 88: {
                // 0x804b03f
                sort_type = 1;
                v8 = 1;
                goto lab_0x804abd4;
            }
            case 90: {
                // 0x804b3b0
                *(char *)&print_scontext = 1;
                v8 = v11;
                goto lab_0x804abd4;
            }
            case 97: {
                // 0x804ac3e
                ignore_mode = 2;
                v8 = v11;
                goto lab_0x804abd4;
            }
            case 98: {
                // 0x804ac4a
                set_quoting_style(NULL, 4);
                v8 = v11;
                goto lab_0x804abd4;
            }
            case 99: {
                // 0x804ac63
                time_type = 1;
                v8 = v11;
                goto lab_0x804abd4;
            }
            case 100: {
                // 0x804ac72
                *(char *)&immediate_dirs = 1;
                v8 = v11;
                goto lab_0x804abd4;
            }
            case 102: {
                // 0x804ac7e
                ignore_mode = 2;
                sort_type = -1;
                if (format == 0) {
                    // 0x804ac9f
                    format = isatty(1) == 0 ? 1 : 2;
                }
                // 0x804acc7
                *(char *)&print_block_size = 0;
                *(char *)&print_with_color = 0;
                v8 = 1;
                goto lab_0x804abd4;
            }
            case 103: {
                // 0x804ace9
                format = 0;
                *(char *)&print_owner = 0;
                v8 = v11;
                goto lab_0x804abd4;
            }
            case 104: {
                // 0x804acff
                human_output_opts = 176;
                *(int32_t *)&output_block_size = 1;
                g33 = 0;
                *(int32_t *)&file_output_block_size = 1;
                g14 = 0;
                v8 = v11;
                goto lab_0x804abd4;
            }
            case 105: {
                // 0x804ad38
                *(char *)&print_inode = 1;
                v8 = v11;
                goto lab_0x804abd4;
            }
            case 107: {
                // 0x804ad44
                human_output_opts = 0;
                *(int32_t *)&output_block_size = 1024;
                g33 = 0;
                *(int32_t *)&file_output_block_size = 1024;
                g14 = 0;
                v8 = v11;
                goto lab_0x804abd4;
            }
            case 108: {
                // 0x804ad7d
                format = 0;
                v8 = v11;
                goto lab_0x804abd4;
            }
            case 109: {
                // 0x804ad8c
                format = 4;
                v8 = v11;
                goto lab_0x804abd4;
            }
            case 110: {
                // 0x804ad9b
                *(char *)&numeric_ids = 1;
                format = 0;
                v8 = v11;
                goto lab_0x804abd4;
            }
            case 111: {
                // 0x804adb1
                format = 0;
                *(char *)&print_group = 0;
                v8 = v11;
                goto lab_0x804abd4;
            }
            case 112: {
                // 0x804adc7
                indicator_style = 1;
                v8 = v11;
                goto lab_0x804abd4;
            }
            case 113: {
                // 0x804add6
                *(char *)&qmark_funny_chars = 1;
                v8 = v11;
                goto lab_0x804abd4;
            }
            case 114: {
                // 0x804ade2
                *(char *)&sort_reverse = 1;
                v8 = v11;
                goto lab_0x804abd4;
            }
            case 115: {
                // 0x804adee
                *(char *)&print_block_size = 1;
                v8 = v11;
                goto lab_0x804abd4;
            }
            case 116: {
                // 0x804adfa
                sort_type = 4;
                v8 = 1;
                goto lab_0x804abd4;
            }
            case 117: {
                // 0x804ae0d
                time_type = 2;
                v8 = v11;
                goto lab_0x804abd4;
            }
            case 118: {
                // 0x804ae1c
                sort_type = 3;
                v8 = 1;
                goto lab_0x804abd4;
            }
            case 119: {
                // 0x804ae2f
                if (xstrtoul(g31, NULL, 0, &v14, NULL) != 0) {
                    goto lab_0x804ae66;
                } else {
                    // 0x804ae5f
                    if (v14 != 0) {
                        goto lab_0x804ae9d;
                    } else {
                        goto lab_0x804ae66;
                    }
                }
            }
            case 120: {
                // 0x804aeaa
                format = 3;
                v8 = v11;
                goto lab_0x804abd4;
            }
            case 128: {
                // 0x804b06e
                *(char *)&print_author = 1;
                v8 = v11;
                goto lab_0x804abd4;
            }
            case 129: {
                int32_t v15 = human_options(g31, &human_output_opts, &output_block_size); // 0x804b323
                if (v15 != 0) {
                    // 0x804b331
                    xstrtol_fatal(v15, v5, 0, (struct option *)&long_options, g31);
                    // UNREACHABLE
                }
                // 0x804b35c
                *(int32_t *)&file_output_block_size = *(int32_t *)&output_block_size;
                g14 = g33;
                v8 = v11;
                goto lab_0x804abd4;
            }
            case 130: {
                // 0x804b1ae
                if (g31 == NULL) {
                    goto lab_0x804b246;
                } else {
                    int32_t v16 = __xargmatch_internal("--color", g31, color_args, (char *)&color_types, 4, argmatch_die); // 0x804b1ea
                    int32_t v17 = *(int32_t *)(4 * v16 + (int32_t)&color_types); // 0x804b1ef
                    if (v17 == 1) {
                        goto lab_0x804b246;
                    } else {
                        if (v17 != 2) {
                            // 0x804b22e
                            *(char *)&print_with_color = 0;
                            v8 = v11;
                            goto lab_0x804abd4;
                        } else {
                            // 0x804b20e
                            if (isatty(1) == 0) {
                                // 0x804b22e
                                *(char *)&print_with_color = 0;
                                v8 = v11;
                                goto lab_0x804abd4;
                            } else {
                                goto lab_0x804b246;
                            }
                        }
                    }
                }
            }
            case 131: {
                // 0x804af37
                dereference = 4;
                v8 = v11;
                goto lab_0x804abd4;
            }
            case 132: {
                // 0x804acda
                indicator_style = 2;
                v8 = v11;
                goto lab_0x804abd4;
            }
            case 133: {
                int32_t v18 = __xargmatch_internal("--format", g31, format_args, (char *)&format_types, 4, argmatch_die); // 0x804b182
                format = *(int32_t *)(4 * v18 + (int32_t)&format_types);
                v8 = v11;
                goto lab_0x804abd4;
            }
            case 134: {
                // 0x804b198
                format = 0;
                v3 = "full-iso";
                v8 = v11;
                goto lab_0x804abd4;
            }
            case 135: {
                // 0x804b0fa
                *(char *)&directories_first = 1;
                v8 = v11;
                goto lab_0x804abd4;
            }
            case 136: {
                char * v19 = xmalloc(8); // 0x804b081
                int32_t v20 = (int32_t)v19; // 0x804b081
                *(int32_t *)v19 = (int32_t)g31;
                *(int32_t *)(v20 + 4) = (int32_t)hide_patterns;
                *(int32_t *)&hide_patterns = v20;
                v8 = v11;
                goto lab_0x804abd4;
            }
            case 137: {
                int32_t v21 = __xargmatch_internal("--indicator-style", g31, indicator_style_args, (char *)&indicator_style_types, 4, argmatch_die); // 0x804b288
                indicator_style = *(int32_t *)(4 * v21 + (int32_t)&indicator_style_types);
                v8 = v11;
                goto lab_0x804abd4;
            }
            case 138: {
                int32_t v22 = __xargmatch_internal("--quoting-style", g31, quoting_style_args, (char *)&quoting_style_vals, 4, argmatch_die); // 0x804b2d1
                set_quoting_style(NULL, *(int32_t *)(4 * v22 + (int32_t)&quoting_style_vals));
                v8 = v11;
                goto lab_0x804abd4;
            }
            case 139: {
                // 0x804b2ff
                *(char *)&qmark_funny_chars = 0;
                v8 = v11;
                goto lab_0x804abd4;
            }
            case 140: {
                // 0x804b377
                human_output_opts = 144;
                *(int32_t *)&output_block_size = 1;
                g33 = 0;
                *(int32_t *)&file_output_block_size = 1;
                g14 = 0;
                v8 = v11;
                goto lab_0x804abd4;
            }
            case 141: {
                int32_t v23 = __xargmatch_internal("--sort", g31, sort_args, (char *)&sort_types, 4, argmatch_die); // 0x804b0e0
                sort_type = *(int32_t *)(4 * v23 + (int32_t)&sort_types);
                v8 = 1;
                goto lab_0x804abd4;
            }
            case 142: {
                int32_t v24 = __xargmatch_internal("--time", g31, time_args, (char *)&time_types, 4, argmatch_die); // 0x804b139
                time_type = *(int32_t *)(4 * v24 + (int32_t)&time_types);
                v8 = v11;
                goto lab_0x804abd4;
            }
            case 143: {
                // 0x804b2f2
                *(int32_t *)&v3 = (int32_t)g31;
                v8 = v11;
                goto lab_0x804abd4;
            }
            default: {
                goto lab_0x804b448;
            }
        }
    }
  lab_0x804b448:
    // 0x804b448
    usage(2);
    // UNREACHABLE
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/ls.c
// Address range: 0x804b7d9 - 0x804bae2
// Line range:    1950 - 2140
bool get_funky_string(char ** dest, char ** src, bool equals_end, int32_t * output_count) {
    // 0x804b7d9
    char * q; // bp-12, 0x804b7d9
    *(int32_t *)&q = (int32_t)*src;
    char * v1 = *dest;
    char * v2; // bp-8, 0x804b7d9
    *(int32_t *)&v2 = (int32_t)v1;
    char * v3 = v1; // 0x804b7d9
    char * v4 = v1; // 0x804b7d9
    char * v5 = v1; // 0x804b7d9
    char * v6 = v1; // 0x804b7d9
    char * v7 = v1; // 0x804b7d9
    char * v8 = v1; // 0x804b7d9
    char * v9 = v1; // 0x804b7d9
    char * v10 = NULL; // 0x804b7d9
    char v11 = 0; // 0x804b7d9
    char * v12 = NULL; // 0x804b7d9
    char * v13; // 0x804b7d9
    char * v14; // 0x804b7d9
    char * v15; // 0x804b7d9
    char * v16; // 0x804b89c
    char * v17; // 0x804b7d9
    char * v18; // 0x804b7d9
    char * v19; // 0x804b7d9
    char * v20; // 0x804b7d9
    char * v21; // 0x804b7d9
    char * v22; // 0x804b7d9
    char v23; // 0x804b7d9
    char v24; // 0x804b827
    while (true) {
      lab_0x804b816:
        // 0x804b816
        v17 = v12;
        v23 = v11;
        v20 = v10;
        char * v25 = v9; // 0x804ba7c
        char * v26 = v8; // 0x804ba99
        char * v27 = v7; // 0x804ba3c
        char * v28 = v6; // 0x804b97b
        char * v29 = v5; // 0x804b946
        v16 = v4;
        char * v30 = v3;
        int32_t v31 = (int32_t)v20; // 0x804b816
        g50 = v31;
        switch (v31) {
            case 0: {
                char * v32 = q; // 0x804b824
                v24 = *v32;
                if (v24 == 61) {
                    // 0x804b884
                    v14 = v32;
                    v21 = (char *)5;
                    v18 = v17;
                    v15 = v30;
                    if (equals_end) {
                        goto lab_0x804bac1_2;
                    }
                    goto lab_0x804b896;
                } else {
                    if (v24 > 61) {
                        switch (v24) {
                            case 92: {
                                // 0x804b864
                                q = (char *)((int32_t)v32 + 1);
                                v13 = v30;
                                v4 = v16;
                                v5 = v29;
                                v6 = v28;
                                v7 = v27;
                                v8 = v26;
                                v9 = v25;
                                v19 = v17;
                                v11 = v23;
                                v22 = (char *)1;
                                goto lab_0x804bab7_2;
                            }
                            case 94: {
                                // 0x804b874
                                q = (char *)((int32_t)v32 + 1);
                                v13 = v30;
                                v4 = v16;
                                v5 = v29;
                                v6 = v28;
                                v7 = v27;
                                v8 = v26;
                                v9 = v25;
                                v19 = v17;
                                v11 = v23;
                                v22 = (char *)4;
                                goto lab_0x804bab7_2;
                            }
                            default: {
                                goto lab_0x804b896;
                            }
                        }
                    } else {
                        // 0x804b83c
                        v14 = v32;
                        v21 = (char *)5;
                        v18 = v17;
                        v15 = v30;
                        switch (v24) {
                            case 58: {
                                goto lab_0x804bac1_2;
                            }
                            case 0: {
                                goto lab_0x804bac1_2;
                            }
                            default: {
                                goto lab_0x804b896;
                            }
                        }
                    }
                }
            }
            case 1: {
                char * v33 = q; // 0x804b8b2
                int32_t v34 = (int32_t)*v33; // 0x804b8b8
                g51 = v34;
                char v35 = 7; // 0x804b8ce
                char * v36 = v30; // 0x804b8ce
                char * v37 = v16; // 0x804b8ce
                char * v38 = v33; // 0x804b8ce
                char * v39 = v29; // 0x804b8ce
                char * v40 = v28; // 0x804b8ce
                char * v41 = v27; // 0x804b8ce
                char * v42 = v26; // 0x804b8ce
                char * v43 = v25; // 0x804b8ce
                char v44 = 0; // 0x804b8ce
                char * v45 = v17; // 0x804b8ce
                char * v46 = (char *)3; // 0x804b8ce
                switch (v34) {
                    case 0: {
                        // 0x804b92e
                        v36 = v30;
                        v37 = v16;
                        v38 = v33;
                        v39 = v29;
                        v40 = v28;
                        v41 = v27;
                        v42 = v26;
                        v43 = v25;
                        v44 = v23;
                        v45 = v17;
                        v46 = (char *)6;
                    }
                    case 88: {
                    }
                    case 120: {
                      lab_0x804b95e:
                        // 0x804b95e
                        q = (char *)((int32_t)v38 + 1);
                        v13 = v36;
                        v4 = v37;
                        v5 = v39;
                        v6 = v40;
                        v7 = v41;
                        v8 = v42;
                        v9 = v43;
                        v19 = v45;
                        v11 = v44;
                        v22 = v46;
                        // break -> 0x804bab7
                        break;
                    }
                    case 48: {
                    }
                    case 49: {
                    }
                    case 50: {
                    }
                    case 51: {
                    }
                    case 52: {
                    }
                    case 53: {
                    }
                    case 54: {
                    }
                    case 55: {
                        // 0x804b8d0
                        v36 = v30;
                        v37 = v16;
                        v38 = v33;
                        v39 = v29;
                        v40 = v28;
                        v41 = v27;
                        v42 = v26;
                        v43 = v25;
                        v44 = *v33 - 48;
                        v45 = v17;
                        v46 = (char *)2;
                        // branch (via goto) -> 0x804b95e
                        goto lab_0x804b95e;
                    }
                    case 63: {
                        // 0x804b922
                        v35 = 127;
                    }
                    case 97: {
                      lab_0x804b940:;
                        char v47 = v35;
                        v36 = v30;
                        v37 = v16;
                        v38 = v33;
                        v39 = v29;
                        v40 = v28;
                        v41 = v27;
                        v42 = v26;
                        v43 = v25;
                        v44 = v47;
                        v45 = v17;
                        v46 = v20;
                        if (v20 == (char *)1) {
                            // 0x804b946
                            *v29 = v47;
                            char * v48 = (char *)((int32_t)v2 + 1); // 0x804b94f
                            v2 = v48;
                            v36 = v48;
                            v37 = v48;
                            v38 = q;
                            v39 = v48;
                            v40 = v48;
                            v41 = v48;
                            v42 = v48;
                            v43 = v48;
                            v44 = v47;
                            v45 = (char *)((int32_t)v17 + 1);
                            v46 = NULL;
                        }
                        // branch (via goto) -> 0x804b95e
                        goto lab_0x804b95e;
                    }
                    case 95: {
                        // 0x804b928
                        v35 = 32;
                        // branch (via goto) -> 0x804b940
                        goto lab_0x804b940;
                    }
                    case 98: {
                        // 0x804b8f8
                        v35 = 8;
                        // branch (via goto) -> 0x804b940
                        goto lab_0x804b940;
                    }
                    case 101: {
                        // 0x804b8fe
                        v35 = 27;
                        // branch (via goto) -> 0x804b940
                        goto lab_0x804b940;
                    }
                    case 102: {
                        // 0x804b904
                        v35 = 12;
                        // branch (via goto) -> 0x804b940
                        goto lab_0x804b940;
                    }
                    case 110: {
                        // 0x804b90a
                        v35 = 10;
                        // branch (via goto) -> 0x804b940
                        goto lab_0x804b940;
                    }
                    case 114: {
                        // 0x804b910
                        v35 = 13;
                        // branch (via goto) -> 0x804b940
                        goto lab_0x804b940;
                    }
                    case 116: {
                        // 0x804b916
                        v35 = 9;
                        // branch (via goto) -> 0x804b940
                        goto lab_0x804b940;
                    }
                    case 118: {
                        // 0x804b91c
                        v35 = 11;
                        // branch (via goto) -> 0x804b940
                        goto lab_0x804b940;
                    }
                    default: {
                        // 0x804b937
                        v35 = *v33;
                        // branch (via goto) -> 0x804b940
                        goto lab_0x804b940;
                    }
                }
                goto lab_0x804bab7_2;
            }
            case 2: {
                char * v49 = q; // 0x804b967
                char v50 = *v49; // 0x804b96a
                if ((v50 & -8) == 48) {
                    // 0x804b998
                    q = (char *)((int32_t)v49 + 1);
                    v13 = v30;
                    v4 = v16;
                    v5 = v29;
                    v6 = v28;
                    v7 = v27;
                    v8 = v26;
                    v9 = v25;
                    v19 = v17;
                    v11 = 8 * v23 - 48 + v50;
                    v22 = v20;
                } else {
                    // 0x804b97b
                    *v28 = v23;
                    char * v51 = (char *)((int32_t)v2 + 1); // 0x804b984
                    v2 = v51;
                    v13 = v51;
                    v4 = v51;
                    v5 = v51;
                    v6 = v51;
                    v7 = v51;
                    v8 = v51;
                    v9 = v51;
                    v19 = (char *)((int32_t)v17 + 1);
                    v11 = v23;
                    v22 = NULL;
                }
                goto lab_0x804bab7_2;
            }
            case 3: {
                char * v52 = q; // 0x804b9bb
                int32_t v53 = (int32_t)*v52; // 0x804b9c1
                g52 = v53 - 48;
                switch (v53) {
                    case 48: {
                    }
                    case 49: {
                    }
                    case 50: {
                    }
                    case 51: {
                    }
                    case 52: {
                    }
                    case 53: {
                    }
                    case 54: {
                    }
                    case 55: {
                    }
                    case 56: {
                    }
                    case 57: {
                        // 0x804b9dc
                        q = (char *)((int32_t)v52 + 1);
                        v13 = v30;
                        v4 = v16;
                        v5 = v29;
                        v6 = v28;
                        v7 = v27;
                        v8 = v26;
                        v9 = v25;
                        v19 = v17;
                        v11 = 16 * v23 - 48 + *v52;
                        v22 = v20;
                        // break -> 0x804bab7
                        break;
                    }
                    case 65: {
                    }
                    case 66: {
                    }
                    case 67: {
                    }
                    case 68: {
                    }
                    case 69: {
                    }
                    case 70: {
                        // 0x804ba1e
                        q = (char *)((int32_t)v52 + 1);
                        v13 = v30;
                        v4 = v16;
                        v5 = v29;
                        v6 = v28;
                        v7 = v27;
                        v8 = v26;
                        v9 = v25;
                        v19 = v17;
                        v11 = 16 * v23 - 55 + *v52;
                        v22 = v20;
                        // break -> 0x804bab7
                        break;
                    }
                    case 97: {
                    }
                    case 98: {
                    }
                    case 99: {
                    }
                    case 100: {
                    }
                    case 101: {
                    }
                    case 102: {
                        // 0x804b9fd
                        q = (char *)((int32_t)v52 + 1);
                        v13 = v30;
                        v4 = v16;
                        v5 = v29;
                        v6 = v28;
                        v7 = v27;
                        v8 = v26;
                        v9 = v25;
                        v19 = v17;
                        v11 = 16 * v23 - 87 + *v52;
                        v22 = v20;
                        // break -> 0x804bab7
                        break;
                    }
                    default: {
                        // 0x804ba3c
                        *v27 = v23;
                        char * v54 = (char *)((int32_t)v2 + 1); // 0x804ba45
                        v2 = v54;
                        v13 = v54;
                        v4 = v54;
                        v5 = v54;
                        v6 = v54;
                        v7 = v54;
                        v8 = v54;
                        v9 = v54;
                        v19 = (char *)((int32_t)v17 + 1);
                        v11 = v23;
                        v22 = NULL;
                        // break -> 0x804bab7
                        break;
                    }
                }
                goto lab_0x804bab7_2;
            }
            case 4: {
                char * v55 = q; // 0x804ba5d
                unsigned char v56 = *v55; // 0x804ba60
                if (v56 < 64 || v56 == 127) {
                    // 0x804ba8f
                    v14 = v55;
                    v21 = (char *)6;
                    v18 = v17;
                    v15 = v30;
                    if (v56 != 63) {
                        goto lab_0x804bac1_2;
                    }
                    // 0x804ba99
                    *v26 = 127;
                    char * v57 = (char *)((int32_t)v2 + 1); // 0x804ba9f
                    v2 = v57;
                    v13 = v57;
                    v4 = v57;
                    v5 = v57;
                    v6 = v57;
                    v7 = v57;
                    v8 = v57;
                    v9 = v57;
                    v19 = (char *)((int32_t)v17 + 1);
                    v11 = v23;
                    v22 = NULL;
                } else {
                    // 0x804ba71
                    *v25 = v56 % 32;
                    char * v58 = (char *)((int32_t)v2 + 1); // 0x804ba81
                    v2 = v58;
                    q = (char *)((int32_t)q + 1);
                    v13 = v58;
                    v4 = v58;
                    v5 = v58;
                    v6 = v58;
                    v7 = v58;
                    v8 = v58;
                    v9 = v58;
                    v19 = (char *)((int32_t)v17 + 1);
                    v11 = v23;
                    v22 = NULL;
                }
                goto lab_0x804bab7_2;
            }
            default: {
                goto lab_0x804bab2;
            }
        }
    }
  lab_0x804bab2:
    // 0x804bab2
    abort();
    // UNREACHABLE
  lab_0x804bac1_2:
    // 0x804bac1
    *(int32_t *)dest = (int32_t)v15;
    *(int32_t *)src = (int32_t)v14;
    *output_count = (int32_t)v18;
    return v21 != (char *)6;
  lab_0x804bab7_2:;
    char * v59 = v22;
    char * v60 = v19;
    char * v61 = v13; // 0x804bac4
    v3 = v61;
    v10 = v59;
    v12 = v60;
    if (v59 > (char *)4) {
        // 0x804bab7
        v14 = q;
        v21 = v59;
        v18 = v60;
        v15 = v61;
        goto lab_0x804bac1_2;
    }
    goto lab_0x804b816;
  lab_0x804b896:
    // 0x804b896
    *v16 = v24;
    char * v62 = (char *)((int32_t)v2 + 1); // 0x804b8a1
    v2 = v62;
    q = (char *)((int32_t)q + 1);
    v13 = v62;
    v4 = v62;
    v5 = v62;
    v6 = v62;
    v7 = v62;
    v8 = v62;
    v9 = v62;
    v19 = (char *)((int32_t)v17 + 1);
    v11 = v23;
    v22 = v20;
    goto lab_0x804bab7_2;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/ls.c
// Address range: 0x804bae2 - 0x804be91
// Line range:    2144 - 2267
void parse_ls_color(void) {
    char * env_val = getenv("LS_COLORS"); // 0x804baf0
    int32_t ind_no = (int32_t)env_val; // bp-32, 0x804baf5
    if (env_val == NULL || *env_val == 0) {
        // 0x804be8b
        return;
    }
    // 0x804bb11
    int32_t str; // bp-39, 0x804bae2
    memcpy(&str, (int32_t *)"??", 3);
    int32_t v1 = (int32_t)xstrdup(env_val); // 0x804bb39
    color_buf = v1;
    int32_t state = v1; // bp-36, 0x804bb48
    int32_t * v2 = (int32_t *)1;
    int32_t v3 = 0; // 0x804bae2
    int32_t * v4; // 0x804bae2
    while (true) {
      lab_0x804bb57:;
        int32_t v5 = v3;
        int32_t * v6 = v2;
        if (v6 == (int32_t *)2) {
            int32_t v7 = ind_no; // 0x804bc62
            v3 = v5;
            v4 = (int32_t *)-1;
            if (*(char *)v7 != 0) {
                // 0x804bc6c
                ind_no = v7 + 1;
                v3 = v5;
                v4 = (int32_t *)3;
            }
            goto lab_0x804bde7;
        } else {
            if (v6 > (int32_t *)2) {
                // 0x804bb78
                v3 = v5;
                v4 = v6;
                switch ((int32_t)v6) {
                    case 3: {
                        int32_t v8 = ind_no; // 0x804bc9a
                        ind_no = v8 + 1;
                        v3 = v5;
                        v4 = (int32_t *)-1;
                        int32_t str2 = (int32_t)"lc"; // 0x804bcad
                        if (*(char *)v8 == 61) {
                            int32_t v9 = 0;
                            while (strcmp((char *)&str, (char *)str2) != 0) {
                                int32_t v10 = v9 + 1; // 0x804bd2b
                                int32_t v11 = *(int32_t *)(4 * v10 + (int32_t)&indicator_name); // 0x804bd32
                                str2 = v11;
                                int32_t v12 = v10; // 0x804bd3b
                                if (v11 == 0) {
                                    goto lab_0x804bd4b;
                                }
                                v9 = v12;
                            }
                            int32_t v13 = 8 * v9; // 0x804bcdf
                            *(int32_t *)(v13 + (int32_t)&g15) = state;
                            bool v14 = get_funky_string((char **)&state, (char **)&ind_no, false, (int32_t *)(v13 + (int32_t)&color_indicator)); // 0x804bd0a
                            v3 = v5;
                            v4 = (int32_t *)1;
                            if (!v14) {
                              lab_0x804bd4b:
                                // 0x804bd4b
                                quotearg((char *)&str);
                                error(0, 0, gettext("unrecognized prefix: %s"));
                                v3 = v5;
                                v4 = (int32_t *)-1;
                            }
                        }
                        // break -> 0x804bde7
                        break;
                    }
                    case 4: {
                        int32_t v15 = ind_no; // 0x804bd82
                        ind_no = v15 + 1;
                        v3 = v5;
                        v4 = (int32_t *)-1;
                        if (*(char *)v15 == 61) {
                            // 0x804bd97
                            *(int32_t *)(v5 + 12) = state;
                            bool v16 = get_funky_string((char **)&state, (char **)&ind_no, false, (int32_t *)(v5 + 8)); // 0x804bdbf
                            v3 = v5;
                            v4 = !v16 ? (int32_t *)-1 : (int32_t *)1;
                        }
                        // break -> 0x804bde7
                        break;
                    }
                }
                goto lab_0x804bde7;
            } else {
                // 0x804bb6d
                v3 = v5;
                v4 = v6;
                if (v6 == (int32_t *)1) {
                    int32_t v17 = ind_no; // 0x804bb91
                    char v18 = *(char *)v17; // 0x804bb94
                    v3 = v5;
                    v4 = NULL;
                    switch (v18) {
                        case 42: {
                            char * v19 = xmalloc(20); // 0x804bbcd
                            int32_t v20 = (int32_t)v19; // 0x804bbcd
                            *(int32_t *)(v20 + 16) = (int32_t)color_ext_list;
                            *(int32_t *)&color_ext_list = v20;
                            ind_no++;
                            *(int32_t *)(v20 + 4) = state;
                            bool v21 = get_funky_string((char **)&state, (char **)&ind_no, true, (int32_t *)v19); // 0x804bc17
                            v3 = v20;
                            v4 = !v21 ? (int32_t *)-1 : (int32_t *)4;
                            goto lab_0x804bde7;
                        }
                        case 58: {
                            // 0x804bbb8
                            ind_no = v17 + 1;
                            v3 = v5;
                            v4 = (int32_t *)1;
                            goto lab_0x804bde7;
                        }
                        case 0: {
                            goto lab_0x804bde7;
                        }
                        default: {
                            // 0x804bc47
                            str = v18;
                            ind_no = v17 + 1;
                            v3 = v5;
                            v4 = (int32_t *)2;
                            goto lab_0x804bde7;
                        }
                    }
                } else {
                    goto lab_0x804bde7;
                }
            }
        }
    }
  lab_0x804bdf1:
    if (v2 < NULL) {
        // 0x804bdf7
        error(0, 0, gettext("unparsable value for LS_COLORS environment variable"));
        free((int32_t *)color_buf);
        if (color_ext_list != NULL) {
            int32_t v22 = (int32_t)color_ext_list;
            int32_t v23 = *(int32_t *)(v22 + 16); // 0x804be3b
            free((int32_t *)v22);
            while (v23 != 0) {
                // 0x804be32
                v22 = v23;
                v23 = *(int32_t *)(v22 + 16);
                free((int32_t *)v22);
            }
        }
        // 0x804be52
        *(char *)&print_with_color = 0;
    }
    // 0x804be59
    if (g20 != 6) {
        // 0x804be8b
        return;
    }
    // 0x804be63
    if (strncmp(g21, "target", 6) == 0) {
        // 0x804be84
        *(char *)&color_symlink_as_referent = 1;
    }
  lab_0x804bde7:
    // 0x804bde7
    v2 = v4;
    if (v2 >= NULL != v2 != NULL) {
        // break -> 0x804bdf1
        goto lab_0x804bdf1;
    }
    goto lab_0x804bb57;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/ls.c
// Address range: 0x804be91 - 0x804bec4
// Line range:    2274 - 2279
void set_exit_status(bool serious) {
    if (serious) {
        // 0x804bea3
        exit_status = 2;
        // 0x804bec2
        return;
    }
    // 0x804beaf
    if (exit_status == 0) {
        // 0x804beb8
        exit_status = 1;
    }
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/ls.c
// Address range: 0x804bec4 - 0x804bf12
// Line range:    2287 - 2290
void file_failure(bool serious, char * message, char * file) {
    // 0x804bec4
    quotearg_colon(file);
    error(0, *__errno_location(), message);
    set_exit_status(serious);
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/ls.c
// Address range: 0x804bf12 - 0x804bf98
// Line range:    2304 - 2311
void queue_directory(char * name, char * realname, bool command_line_arg) {
    char * v1 = xmalloc(16); // 0x804bf25
    int32_t v2 = 0; // 0x804bf31
    if (realname != NULL) {
        // 0x804bf33
        v2 = (int32_t)xstrdup(realname);
    }
    int32_t v3 = (int32_t)v1; // 0x804bf25
    *(int32_t *)(v3 + 4) = v2;
    int32_t v4 = 0; // 0x804bf57
    if (name != NULL) {
        // 0x804bf59
        v4 = (int32_t)xstrdup(name);
    }
    // 0x804bf70
    *(int32_t *)v1 = v4;
    *(char *)(v3 + 8) = (char)command_line_arg;
    *(int32_t *)(v3 + 12) = (int32_t)pending_dirs;
    *(int32_t *)&pending_dirs = v3;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/ls.c
// Address range: 0x804bf98 - 0x804c66f
// Line range:    2320 - 2454
void print_dir(char * name, char * realname, bool command_line_arg) {
    // 0x804bf98
    *__errno_location() = 0;
    struct __dirstream * dirp = opendir(name); // 0x804bfca
    if (dirp == NULL) {
        // 0x804bfd8
        file_failure(command_line_arg, gettext("cannot open directory %s"), name);
        // 0x804c666
        return;
    }
    // 0x804c003
    int32_t v1; // bp-720, 0x804bf98
    if (active_dir_set != NULL) {
        int32_t v2 = dirfd(dirp); // 0x804c016
        int32_t v3; // 0x804bf98
        if (v2 < 0) {
            // 0x804c044
            v3 = stat64((int32_t)name, &v1);
        } else {
            // 0x804c024
            v3 = fstat64(v2, &v1);
        }
        // 0x804c062
        if (v3 <= 0xffffffff) {
            // 0x804c06b
            file_failure(command_line_arg, gettext("cannot determine device and inode of %s"), name);
            closedir(dirp);
            // 0x804c666
            return;
        }
        // 0x804c0a3
        int64_t v4; // 0x804bf98
        if (visit_dir((int64_t)v1, 0x100000000 * v4 >> 32)) {
            // 0x804c0d3
            quotearg_colon(name);
            error(0, 0, gettext("%s: not listing already-listed directory"));
            closedir(dirp);
            // 0x804c666
            return;
        }
        // 0x804c118
        if (g38 - g37 <= 15) {
            // 0x804c13f
            _obstack_newchunk((struct obstack *)&dev_ino_obstack, 16);
        }
        int32_t v5 = g37; // 0x804c154
        g37 = v5 + 16;
        *(int32_t *)(v5 + 8) = v1;
        *(int32_t *)(v5 + 12) = (int32_t)v4;
    }
    // 0x804c196
    clear_files();
    char * v6 = NULL; // 0x804c196
    int32_t v7 = 0; // 0x804c196
    char * v8; // 0x804bf98
    int32_t v9; // 0x804bf98
    while (true) {
        // 0x804c19b
        v9 = v7;
        v8 = v6;
        *__errno_location() = 0;
        struct dirent64 * v10 = readdir64(dirp); // 0x804c1ac
        while (v10 == NULL) {
            // 0x804c287
            if (*__errno_location() == 0) {
                // break (via goto) -> 0x804c2ca
                goto lab_0x804c2ca_2;
            }
            // 0x804c292
            file_failure(command_line_arg, gettext("reading directory %s"), name);
            if (*__errno_location() != 75) {
                // break (via goto) -> 0x804c2ca
                goto lab_0x804c2ca_2;
            }
            *__errno_location() = 0;
            v10 = readdir64(dirp);
        }
        int32_t v11 = (int32_t)v10; // 0x804c1ac
        char * v12 = (char *)(v11 + 19); // 0x804c1c7
        file_ignored(v12);
        unsigned char v13 = *(char *)(v11 + 18); // 0x804c1dd
        g53 = v13;
        int32_t v14 = 0; // 0x804c200
        switch (v13) {
            case 1: {
                // 0x804c21d
                v14 = 1;
                // break -> 0x804c248
                break;
            }
            case 2: {
                // 0x804c20b
                v14 = 2;
                // break -> 0x804c248
                break;
            }
            case 4: {
                // 0x804c214
                v14 = 3;
                // break -> 0x804c248
                break;
            }
            case 6: {
                // 0x804c202
                v14 = 4;
                // break -> 0x804c248
                break;
            }
            case 8: {
                // 0x804c22f
                v14 = 5;
                // break -> 0x804c248
                break;
            }
            case 10: {
                // 0x804c226
                v14 = 6;
                // break -> 0x804c248
                break;
            }
            case 12: {
                // 0x804c238
                v14 = 7;
                // break -> 0x804c248
                break;
            }
            case 14: {
                // 0x804c241
                v14 = 8;
                // break -> 0x804c248
                break;
            }
        }
        int32_t v15 = v10->e0; // 0x804c24b
        uint32_t v16 = *(int32_t *)(v11 + 4); // 0x804c24d
        v7 = v9 + (int32_t)gobble_file(v12, v14, (int64_t)v15, v16 % 2 != 0, NULL);
        v6 = (char *)(v15 + (int32_t)v8 + (int32_t)(v7 < v9));
    }
  lab_0x804c2ca_2:
    // 0x804c2ca
    if (closedir(dirp) != 0) {
        // 0x804c2d9
        file_failure(command_line_arg, gettext("closing directory %s"), name);
    }
    // 0x804c2ff
    sort_files();
    char v17 = 0; // 0x804c30d
    if (*(char *)&recursive != 0) {
        // 0x804c30f
        extract_dirs_from_files(name, command_line_arg);
        v17 = *(char *)&recursive;
    }
    // 0x804c325
    if ((*(char *)&print_dir_name || v17) != 0) {
        // 0x804c343
        if (g24 != 1) {
            // 0x804c351
            putchar_unlocked(10);
            dired_pos++;
        }
        // 0x804c36a
        g24 = 0;
        if (*(char *)&dired != 0) {
            // 0x804c3ae
            fwrite_unlocked((int32_t *)"  ", 1, 2, (struct _IO_FILE *)g30);
            dired_pos += 2;
            if (*(char *)&dired != 0) {
                int32_t v18 = g34; // 0x804c3da
                if (g34 + 4 > g35) {
                    // 0x804c3dc
                    _obstack_newchunk((struct obstack *)&subdired_obstack, 4);
                    v18 = g34;
                }
                // 0x804c3ee
                memcpy((int32_t *)v18, &dired_pos, 4);
                g34 += 4;
            }
        }
        // 0x804c41c
        dired_pos += quote_name((struct _IO_FILE *)g30, realname == NULL ? name : realname, dirname_quoting_options, NULL);
        if (*(char *)&dired != 0) {
            int32_t v19 = g34; // 0x804c4a6
            if (g34 + 4 > g35) {
                // 0x804c4a8
                _obstack_newchunk((struct obstack *)&subdired_obstack, 4);
                v19 = g34;
            }
            // 0x804c4ba
            memcpy((int32_t *)v19, &dired_pos, 4);
            g34 += 4;
        }
        // 0x804c4e8
        fwrite_unlocked((int32_t *)":\n", 1, 2, (struct _IO_FILE *)g30);
        dired_pos += 2;
    }
    // 0x804c51a
    if (format != 0 != (*(char *)&print_block_size == 0)) {
        // 0x804c532
        if (*(char *)&dired != 0) {
            // 0x804c53d
            fwrite_unlocked((int32_t *)"  ", 1, 2, (struct _IO_FILE *)g30);
            dired_pos += 2;
        }
        char * str = gettext("total"); // 0x804c576
        fputs_unlocked(str, (struct _IO_FILE *)g30);
        dired_pos += strlen(str);
        putchar_unlocked(32);
        dired_pos++;
        char * str2 = human_readable((int64_t)v9, v8, (int32_t)&v1, (int64_t)human_output_opts, 512); // 0x804c609
        fputs_unlocked(str2, (struct _IO_FILE *)g30);
        dired_pos += strlen(str2);
        putchar_unlocked(10);
        dired_pos++;
    }
    // 0x804c658
    if (cwd_n_used != 0) {
        // 0x804c661
        print_current_files();
    }
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/ls.c
// Address range: 0x804c66f - 0x804c6a2
// Line range:    2461 - 2469
void add_ignore_pattern(char * pattern) {
    char * v1 = xmalloc(8); // 0x804c67c
    int32_t v2 = (int32_t)v1; // 0x804c67c
    *(int32_t *)v1 = (int32_t)pattern;
    *(int32_t *)(v2 + 4) = (int32_t)ignore_patterns;
    *(int32_t *)&ignore_patterns = v2;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/ls.c
// Address range: 0x804c6a2 - 0x804c6ef
// Line range:    2475 - 2481
bool patterns_match(int32_t * patterns, char * file) {
    // 0x804c6a2
    if (patterns == NULL) {
        // 0x804c6e9
        return false;
    }
    int32_t pattern = (int32_t)patterns; // 0x804c6d9
    bool result = true; // 0x804c6ce
    while (fnmatch((char *)*(int32_t *)pattern, file, 4) != 0) {
        // 0x804c6d6
        pattern += 4;
        result = false;
        if (pattern == 0) {
            // break -> 0x804c6e9
            break;
        }
        result = true;
    }
    // 0x804c6e9
    return result;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/ls.c
// Address range: 0x804c6ef - 0x804c78b
// Line range:    2487 - 2494
bool file_ignored(char * name) {
    // 0x804c6ef
    if (ignore_mode == 2) {
        // 0x804c75d
        return patterns_match(ignore_patterns, name);
    }
    // 0x804c6ff
    if (*name == 46) {
        if (ignore_mode == 0) {
            // 0x804c785
            return true;
        }
        int32_t v1 = (int32_t)name; // 0x804c712
        if (*(char *)((*(char *)(v1 + 1) != 46 ? 1 : 2) + v1) == 0) {
            // 0x804c785
            return true;
        }
    }
    if (ignore_mode != 0 || !patterns_match(hide_patterns, name)) {
        // 0x804c75d
        return patterns_match(ignore_patterns, name);
    }
    // 0x804c785
    return true;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/ls.c
// Address range: 0x804c78b - 0x804c7a5
// Line range:    2502 - 2504
int64_t unsigned_file_size(int64_t size) {
    // 0x804c78b
    return 0x100000000 * size >> 32;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/ls.c
// Address range: 0x804c7a5 - 0x804c883
// Line range:    2512 - 2536
void clear_files(void) {
    int32_t v1 = 0; // 0x804c80a
    if (cwd_n_used != 0) {
        int32_t v2 = *(int32_t *)(4 * v1 + (int32_t)sorted_file); // 0x804c7c3
        free((int32_t *)*(int32_t *)v2);
        free((int32_t *)*(int32_t *)(v2 + 4));
        int32_t v3 = *(int32_t *)(v2 + 112); // 0x804c7e6
        if (v3 != (int32_t)"?") {
            // 0x804c7f0
            freecon((char *)v3);
        }
        // 0x804c7fe
        v1++;
        while (v1 < cwd_n_used) {
            // 0x804c7b4
            v2 = *(int32_t *)(4 * v1 + (int32_t)sorted_file);
            free((int32_t *)*(int32_t *)v2);
            free((int32_t *)*(int32_t *)(v2 + 4));
            v3 = *(int32_t *)(v2 + 112);
            if (v3 != (int32_t)"?") {
                // 0x804c7f0
                freecon((char *)v3);
            }
            // 0x804c7fe
            v1++;
        }
    }
    // 0x804c80c
    cwd_n_used = 0;
    *(char *)&any_has_acl = 0;
    inode_number_width = 0;
    block_size_width = 0;
    nlink_width = 0;
    owner_width = 0;
    group_width = 0;
    author_width = 0;
    scontext_width = 0;
    major_device_number_width = 0;
    minor_device_number_width = 0;
    file_size_width = 0;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/../lib/selinux/selinux.h
// Address range: 0x804c883 - 0x804c888
// Line range:    21 - 21
void freecon(char * con) {
    // 0x804c883
    return;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/ls.c
// Address range: 0x804c888 - 0x804d30d
// Line range:    2545 - 2834
int64_t gobble_file(char * name, int32_t type, int64_t inode, bool command_line_arg, char * dirname) {
    uint32_t v1 = (int32_t)dirname;
    int64_t v2 = 0x100000000 * inode >> 32; // 0x804c898
    char v3 = v1; // 0x804c8a7
    int32_t v4; // bp-908, 0x804c888
    if (v3 != 0) {
        if ((int32_t)v2 == 0 != !command_line_arg) {
            // 0x804c8d6
            v4 = (int32_t)"! command_line_arg || inode == NOT_AN_INODE_NUMBER";
            __assert_fail("! command_line_arg || inode == NOT_AN_INODE_NUMBER", "ls.c", 2551, "gobble_file");
        }
    }
    int32_t * v5 = cwd_file; // 0x804c907
    if (cwd_n_used == cwd_n_alloc) {
        // 0x804c909
        v4 = (int32_t)cwd_file;
        char * v6 = xnrealloc((char *)cwd_file, cwd_n_alloc, 240); // 0x804c923
        *(int32_t *)&cwd_file = (int32_t)v6;
        cwd_n_alloc *= 2;
        v5 = (int32_t *)v6;
    }
    int32_t v7 = &v4; // 0x804c88c
    int32_t v8 = 120 * cwd_n_used + (int32_t)v5; // 0x804c952
    v4 = v8;
    int32_t * v9 = (int32_t *)v8; // 0x804c96e
    memset(v9, 0, 120);
    int32_t v10 = v2; // 0x804c976
    int32_t * v11 = (int32_t *)(v8 + 96); // 0x804c982
    *v11 = v10;
    int32_t * v12 = (int32_t *)(v8 + 100); // 0x804c985
    *v12 = (int32_t)command_line_arg;
    int32_t * v13 = (int32_t *)(v8 + 104); // 0x804c98e
    *v13 = type;
    if (v3 != 0) {
        goto lab_0x804caa3;
    } else {
        // 0x804c99e
        if (*(char *)&format_needs_stat != 0) {
            goto lab_0x804caa3;
        } else {
            if (type != 3) {
                goto lab_0x804c9c2;
            } else {
                // 0x804c9b3
                if (*(char *)&print_with_color != 0) {
                    goto lab_0x804caa3;
                } else {
                    goto lab_0x804c9c2;
                }
            }
        }
    }
  lab_0x804caa3:;
    int32_t v14 = (int32_t)name;
    int32_t v15; // 0x804c888
    char * v16; // bp-84, 0x804c888
    if (*name == 47) {
        // 0x804cab7
        *(int32_t *)&v16 = v14;
        v15 = v7;
        goto lab_0x804cb2c;
    } else {
        // 0x804caad
        char * str; // 0x804c888
        if (*str != 0) {
            // 0x804cabf
            v4 = v14;
            int32_t len = strlen(name); // 0x804cac5
            int32_t v17 = (int32_t)str; // 0x804cacc
            v4 = v17;
            int32_t v18 = v7 - (len + 32 + strlen(str) & -16); // 0x804cae9
            int32_t v19 = v18 + 47 & -16; // 0x804cafe
            v16 = (char *)v19;
            *(int32_t *)(v18 + 8) = v14;
            *(int32_t *)(v18 + 4) = v17;
            *(int32_t *)v18 = v19;
            attach((char *)&g49, (char *)&g49, (char *)&g49);
            v15 = v18;
            goto lab_0x804cb2c;
        } else {
            // 0x804cab7
            *(int32_t *)&v16 = v14;
            v15 = v7;
            goto lab_0x804cb2c;
        }
    }
  lab_0x804cb2c:;
    // 0x804cb2c
    char ** v20; // 0x804c888
    char v21; // 0x804c888
    if (dereference < 3) {
        goto lab_0x804cbef;
    } else {
        if (dereference < 5) {
            if (v3 == 0) {
                goto lab_0x804cbef;
            } else {
                // 0x804cb84
                *(int32_t *)(v15 + 4) = v8 + 8;
                *(int32_t *)v15 = (int32_t)v16;
                int32_t v22 = stat64(dereference, &g49); // 0x804cb94
                char ** v23 = (char **)v22; // 0x804cb99
                v20 = v23;
                v21 = 1;
                if (dereference == 3) {
                    goto lab_0x804cc0b;
                } else {
                    bool v24; // 0x804c888
                    if (v22 >= 0) {
                        // 0x804cbc3
                        v24 = (*(int32_t *)(v8 + 24) & 0xf000) != 0x4000;
                    } else {
                        // 0x804cbb0
                        v24 = *__errno_location() == 2;
                    }
                    // 0x804cbda
                    v20 = v23;
                    v21 = 1;
                    if (!v24) {
                        goto lab_0x804cc0b;
                    } else {
                        goto lab_0x804cbef;
                    }
                }
            }
        } else {
            if (dereference != 5) {
                goto lab_0x804cbef;
            } else {
                // 0x804cb5a
                *(int32_t *)(v15 + 4) = v8 + 8;
                *(int32_t *)v15 = (int32_t)v16;
                v20 = (char **)stat64(dereference, &g49);
                v21 = 1;
                goto lab_0x804cc0b;
            }
        }
    }
  lab_0x804c9c2:;
    char v25 = *(char *)&print_inode; // 0x804c9c2
    char v26 = *(char *)&format_needs_type; // 0x804c9cd
    if ((v26 || v25) == 0) {
        goto lab_0x804ca28;
    } else {
        if (type != 6 == (type != 0)) {
            goto lab_0x804ca28;
        } else {
            // 0x804c9e4
            if (dereference == 5) {
                goto lab_0x804caa3;
            } else {
                if (v3 == 1 == (dereference != 2)) {
                    goto lab_0x804caa3;
                } else {
                    // 0x804ca0e
                    if (*(char *)&color_symlink_as_referent != 0) {
                        goto lab_0x804caa3;
                    } else {
                        // 0x804ca1d
                        if (*(char *)&check_symlink_color != 0) {
                            goto lab_0x804caa3;
                        } else {
                            goto lab_0x804ca28;
                        }
                    }
                }
            }
        }
    }
  lab_0x804cbef:
    // 0x804cbef
    *(int32_t *)(v15 + 4) = v8 + 8;
    *(int32_t *)v15 = (int32_t)v16;
    int32_t v27 = lstat64((int32_t)&g49, (int32_t)&g49); // 0x804cbff
    v20 = (char **)v27;
    v21 = 0;
    goto lab_0x804cc0b;
  lab_0x804ca28:
    if (v25 != 1) {
        goto lab_0x804ca48;
    } else {
        if (v10 == 0 == !command_line_arg) {
            goto lab_0x804caa3;
        } else {
            goto lab_0x804ca48;
        }
    }
  lab_0x804cc0b:
    // 0x804cc0b
    if (v20 != NULL) {
        int32_t * v28 = (int32_t *)v15; // 0x804cc15
        *v28 = (int32_t)"cannot access %s";
        char * v29 = gettext((char *)(int32_t)v21); // 0x804cc1c
        *(int32_t *)(v15 + 8) = (int32_t)v16;
        *(int32_t *)(v15 + 4) = (int32_t)v29;
        *v28 = v1 % 256;
        file_failure((bool)&g49, (char *)&g49, (char *)&g49);
        if (v3 == 0) {
            // 0x804cc5d
            *v28 = v14;
            *v9 = (int32_t)xstrdup((char *)&g49);
            cwd_n_used++;
        }
        // 0x804d2fc
        return 0;
    }
    // 0x804cc95
    *(char *)(v8 + 116) = 1;
    char v30; // 0x804c888
    char ** v31; // 0x804c888
    int32_t * v32; // 0x804c888
    int32_t * v33; // 0x804c888
    if (format != 0 == *(char *)&print_scontext == 0) {
        goto lab_0x804cdf6;
    } else {
        int32_t v34 = v8 + 112;
        v32 = (int32_t *)(v15 + 4);
        *v32 = v34;
        v33 = (int32_t *)v15;
        *v33 = (int32_t)v16;
        char * v35 = (char *)(int32_t)v21;
        int32_t str2; // 0x804c888
        if (v21 == 0) {
            // 0x804ccdb
            str2 = lgetfilecon(v35, NULL);
        } else {
            // 0x804ccbe
            str2 = getfilecon(v35, NULL);
        }
        char ** v36 = (char **)(int32_t)(str2 < 0); // 0x804cd05
        int32_t * v37 = (int32_t *)v34;
        if (str2 < 0) {
            // 0x804cd2e
            *v37 = (int32_t)"?";
            if (*__errno_location() == 95) {
                // 0x804cd50
                v31 = NULL;
                v30 = 0;
                goto lab_0x804cd57;
            } else {
                int32_t * v38 = __errno_location(); // 0x804cd44
                v31 = v36;
                v30 = 0;
                if (*v38 != 61) {
                    goto lab_0x804cd57;
                } else {
                    // 0x804cd50
                    v31 = NULL;
                    v30 = 0;
                    goto lab_0x804cd57;
                }
            }
        } else {
            // 0x804cd0e
            *v32 = *v37;
            *v33 = (int32_t)"unlabeled";
            int32_t strcmp_rc = strcmp((char *)str2, (char *)&g49); // 0x804cd1f
            v31 = v36;
            v30 = strcmp_rc != 0;
            goto lab_0x804cd57;
        }
    }
  lab_0x804ca48:;
    int64_t v39 = 0; // 0x804ca54
    int32_t v40 = v7; // 0x804ca54
    if (v26 != 1) {
        goto lab_0x804d284;
    } else {
        if (type == 0) {
            goto lab_0x804caa3;
        } else {
            // 0x804ca69
            v39 = 0;
            v40 = v7;
            if (type != 5) {
                goto lab_0x804d284;
            } else {
                // 0x804ca73
                if (indicator_style == 3) {
                    goto lab_0x804caa3;
                } else {
                    // 0x804ca7d
                    v39 = 0;
                    v40 = v7;
                    if (*(char *)&print_with_color != 1) {
                        goto lab_0x804d284;
                    } else {
                        // 0x804ca8f
                        v4 = 13;
                        v39 = 0;
                        v40 = v7;
                        if (!is_colored(13)) {
                            goto lab_0x804d284;
                        } else {
                            goto lab_0x804caa3;
                        }
                    }
                }
            }
        }
    }
  lab_0x804cdf6:;
    int32_t * v41 = (int32_t *)(v8 + 24); // 0x804cdf9
    int32_t v42 = *v41 & 0xf000;
    int32_t v43 = v42; // 0x804ce06
    int32_t v44; // bp-816, 0x804c888
    if (v42 == 0xa000) {
        // 0x804ce0c
        v43 = v42;
        if (format != 0 != (*(char *)&check_symlink_color == 0)) {
            // 0x804ce24
            *(int32_t *)(v15 + 8) = v1 % 256;
            int32_t * v45 = (int32_t *)(v15 + 4); // 0x804ce32
            *v45 = v8;
            int32_t * v46 = (int32_t *)v15; // 0x804ce39
            *v46 = (int32_t)v16;
            get_link_name((char *)&g49, &g49, (bool)&g49);
            *v45 = *(int32_t *)(v8 + 4);
            *v46 = (int32_t)v16;
            char * v47 = make_link_name((char *)&g49, (char *)&g49); // 0x804ce51
            int32_t v48 = (int32_t)v47; // 0x804ce51
            if (v47 != NULL) {
                // 0x804ce5f
                if (indicator_style < 2 != (*(char *)&check_symlink_color == 0)) {
                    // 0x804ce74
                    *v45 = (int32_t)&v44;
                    *v46 = v48;
                    if (stat64(v48, &g49) == 0) {
                        // 0x804ce8d
                        *(char *)(v8 + 117) = 1;
                        int32_t v49; // 0x804c888
                        if ((v49 & 0xf000) == 0x4000 != (v3 == 1 == (format != 0))) {
                            // branch -> 0x804cec9
                        }
                    }
                }
            }
            // 0x804cec9
            *v46 = v48;
            free(&g49);
            v43 = *v41 & 0xf000;
        }
    }
    int32_t v50 = v43; // 0x804cee4
    if (*(char *)&check_symlink_color != 1 && v43 == 0xa000) {
        // 0x804cef4
        *(char *)(v8 + 117) = 1;
        v50 = *v41 & 0xf000;
    }
    // 0x804cefb
    if (v50 != 0xa000) {
        if (v50 != 0x4000) {
            // 0x804cf5d
            *v13 = 5;
        } else {
            // 0x804cf2b
            if (((*(char *)&immediate_dirs ^ 1) & v3) == 0) {
                // 0x804cf51
                *v13 = 3;
            } else {
                // 0x804cf45
                *v13 = 9;
            }
        }
    } else {
        // 0x804cf0d
        *v13 = 6;
    }
    int32_t v51 = *(int32_t *)(v8 + 64); // 0x804cf6d
    int64_t v52 = v51; // 0x804cf70
    if (format != 0 != (*(char *)&print_block_size == 0)) {
        int32_t v53 = *(int32_t *)(v8 + 68); // 0x804cf6a
        *(int32_t *)(v15 + 24) = *(int32_t *)&output_block_size;
        *(int32_t *)(v15 + 28) = g33;
        *(int32_t *)(v15 + 16) = 512;
        *(int32_t *)(v15 + 20) = 0;
        *(int32_t *)(v15 + 12) = human_output_opts;
        *(int32_t *)(v15 + 8) = (int32_t)&v44;
        int32_t * v54 = (int32_t *)v15; // 0x804cfc7
        *v54 = v51;
        int32_t * v55 = (int32_t *)(v15 + 4); // 0x804cfca
        *v55 = v53;
        char * v56 = human_readable(v52, (char *)v53, (int32_t)&g49, (int64_t)&g49, (int64_t)&g49); // 0x804cfce
        *v55 = 0;
        *v54 = (int32_t)v56;
        int32_t v57 = gnu_mbswidth((char *)&g49, (int32_t)&g49); // 0x804cfde
        if (block_size_width < v57) {
            // 0x804cff0
            block_size_width = v57;
        }
    }
    // 0x804cff8
    if (format == 0) {
        // 0x804d005
        if (*(char *)&print_owner != 0) {
            // 0x804d010
            *(int32_t *)v15 = *(int32_t *)(v8 + 32);
            int32_t v58 = format_user_width((int32_t)&g49); // 0x804d019
            if (owner_width < v58) {
                // 0x804d02b
                owner_width = v58;
            }
        }
        // 0x804d033
        if (*(char *)&print_group != 0) {
            // 0x804d03e
            *(int32_t *)v15 = *(int32_t *)(v8 + 36);
            int32_t v59 = format_group_width((int32_t)&g49); // 0x804d047
            if (group_width < v59) {
                // 0x804d059
                group_width = v59;
            }
        }
        // 0x804d061
        if (*(char *)&print_author != 0) {
            // 0x804d06c
            *(int32_t *)v15 = *(int32_t *)(v8 + 32);
            int32_t v60 = format_user_width((int32_t)&g49); // 0x804d075
            if (author_width < v60) {
                // 0x804d087
                author_width = v60;
            }
        }
    }
    // 0x804d08f
    if (*(char *)&print_scontext != 0) {
        // 0x804d09a
        *(int32_t *)v15 = *(int32_t *)(v8 + 112);
        int32_t len2 = strlen((char *)&g49); // 0x804d0a3
        if (scontext_width < len2) {
            // 0x804d0b5
            scontext_width = len2;
        }
    }
    // 0x804d0bd
    v39 = v52;
    v40 = v15;
    if (format == 0) {
        int32_t * v61 = (int32_t *)(v15 + 8); // 0x804d0da
        int32_t v62; // bp-121, 0x804c888
        *v61 = (int32_t)&v62;
        int32_t * v63 = (int32_t *)v15; // 0x804d0de
        *v63 = *(int32_t *)(v8 + 28);
        int32_t * v64 = (int32_t *)(v15 + 4); // 0x804d0e1
        *v64 = 0;
        *v63 = (int32_t)umaxtostr((int64_t)&g49, (char *)&g49);
        int32_t len3 = strlen((char *)&g49); // 0x804d0ed
        if (nlink_width < len3) {
            // 0x804d0ff
            nlink_width = len3;
        }
        int32_t v65 = *v41 & 0xf000; // 0x804d10d
        if (v65 != 0x2000 == (v65 != 0x6000)) {
            int32_t v66 = *(int32_t *)(v8 + 56); // 0x804d1fe
            *v63 = *(int32_t *)(v8 + 52);
            *v64 = v66;
            int64_t v67 = unsigned_file_size((int64_t)&g49); // 0x804d20b
            *(int32_t *)(v15 + 24) = *(int32_t *)&file_output_block_size;
            *(int32_t *)(v15 + 28) = g14;
            *(int32_t *)(v15 + 16) = 1;
            *(int32_t *)(v15 + 20) = 0;
            *(int32_t *)(v15 + 12) = human_output_opts;
            *v61 = (int32_t)&v44;
            *v63 = (int32_t)v67;
            *v64 = v66;
            char * v68 = human_readable((int64_t)&g49, (char *)&g49, (int32_t)&g49, (int64_t)&g49, (int64_t)&g49); // 0x804d25a
            *v64 = 0;
            *v63 = (int32_t)v68;
            int32_t v69 = gnu_mbswidth((char *)&g49, (int32_t)&g49); // 0x804d26a
            v39 = v52;
            v40 = v15;
            if (file_size_width < v69) {
                // 0x804d27c
                file_size_width = v69;
                v39 = v52;
                v40 = v15;
            }
        } else {
            int32_t * v70 = (int32_t *)(v8 + 44); // 0x804d132
            int32_t * v71 = (int32_t *)(v8 + 40); // 0x804d135
            *v63 = *v71;
            *v64 = *v70;
            int32_t v72 = gnu_dev_major((int64_t)&g49); // 0x804d13f
            int32_t v73; // bp-142, 0x804c888
            int32_t v74 = &v73; // 0x804d151
            *v61 = v74;
            *v63 = v72;
            *v64 = 0;
            *v63 = (int32_t)umaxtostr((int64_t)&g49, (char *)&g49);
            int32_t len4 = strlen((char *)&g49); // 0x804d164
            if (major_device_number_width < len4) {
                // 0x804d176
                major_device_number_width = len4;
            }
            // 0x804d17e
            *v63 = *v71;
            *v64 = *v70;
            int32_t v75 = gnu_dev_minor((int64_t)&g49); // 0x804d18e
            *v61 = v74;
            *v63 = v75;
            *v64 = 0;
            *v63 = (int32_t)umaxtostr((int64_t)&g49, (char *)&g49);
            int32_t len5 = strlen((char *)&g49); // 0x804d1b3
            int32_t v76 = minor_device_number_width; // 0x804d1c3
            if (minor_device_number_width < len5) {
                // 0x804d1c5
                minor_device_number_width = len5;
                v76 = len5;
            }
            int32_t v77 = v76 + 2 + major_device_number_width; // 0x804d1da
            v39 = v52;
            v40 = v15;
            if (file_size_width < v77) {
                // 0x804d1ee
                file_size_width = v77;
                v39 = v52;
                v40 = v15;
            }
        }
    }
    goto lab_0x804d284;
  lab_0x804d284:;
    // 0x804d284
    int32_t * v78; // 0x804c888
    if (*(char *)&print_inode == 0) {
        // 0x804d284
        v78 = (int32_t *)v40;
    } else {
        // 0x804d28f
        int32_t v79; // bp-163, 0x804c888
        *(int32_t *)(v40 + 8) = (int32_t)&v79;
        int32_t * v80 = (int32_t *)v40;
        *v80 = *v11;
        *(int32_t *)(v40 + 4) = *v12;
        *v80 = (int32_t)umaxtostr((int64_t)&g49, (char *)&g49);
        int32_t len6 = strlen((char *)&g49); // 0x804d2b1
        v78 = v80;
        if (inode_number_width < len6) {
            // 0x804d2c3
            inode_number_width = len6;
            v78 = v80;
        }
    }
    // 0x804d2cb
    *v78 = (int32_t)name;
    *v9 = (int32_t)xstrdup((char *)&g49);
    cwd_n_used++;
    // 0x804d2fc
    return 0x100000000 * v39 >> 32;
  lab_0x804cd57:;
    char ** v81 = v31; // 0x804cd5b
    char v82 = v30; // 0x804cd5b
    if (v31 == NULL && v30 != 1) {
        // 0x804cd68
        v81 = v31;
        v82 = 0;
        if (format == 0) {
            // 0x804cd71
            *v32 = v8 + 8;
            *v33 = (int32_t)v16;
            int32_t v83 = file_has_acl((char *)&g49, &g49); // 0x804cd81
            v81 = (char **)(int32_t)(v83 < 0);
            v82 = v83 >= 0 == (v83 != 0);
        }
    }
    // 0x804cd9c
    *(char *)(v8 + 118) = v82;
    char v84 = *(char *)&any_has_acl; // 0x804cda6
    *(char *)&any_has_acl = (char)((v84 | v82) != 0);
    if (v81 != NULL) {
        // 0x804cdc6
        *v33 = (int32_t)v16;
        char * v85 = quotearg_colon((char *)&g49); // 0x804cdcc
        int32_t v86 = *__errno_location(); // 0x804cdd8
        *(int32_t *)(v15 + 12) = (int32_t)v85;
        *(int32_t *)(v15 + 8) = (int32_t)"%s";
        *v32 = v86;
        *v33 = 0;
        error((int32_t)&g49, (int32_t)&g49, (char *)&g49);
    }
    goto lab_0x804cdf6;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/../lib/selinux/selinux.h
// Address range: 0x804d30d - 0x804d325
// Line range:    33 - 33
int32_t getfilecon(char * s, char ** con) {
    // 0x804d30d
    *__errno_location() = 95;
    return -1;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/../lib/selinux/selinux.h
// Address range: 0x804d325 - 0x804d33d
// Line range:    35 - 35
int32_t lgetfilecon(char * s, char ** con) {
    // 0x804d325
    *__errno_location() = 95;
    return -1;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/ls.c
// Address range: 0x804d33d - 0x804d36f
// Line range:    2839 - 2841
bool is_directory(int32_t * f) {
    int32_t v1 = *(int32_t *)((int32_t)f + 104); // 0x804d346
    if (v1 == 3) {
        // 0x804d369
        return true;
    }
    // 0x804d34e
    return v1 == 9;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/ls.c
// Address range: 0x804d36f - 0x804d3ca
// Line range:    2849 - 2854
void get_link_name(char * filename, int32_t * f, bool command_line_arg) {
    int32_t v1 = (int32_t)f;
    char * v2 = areadlink_with_size(filename, *(int32_t *)(v1 + 52)); // 0x804d38e
    *(int32_t *)(v1 + 4) = (int32_t)v2;
    if (v2 == NULL) {
        // 0x804d3a5
        file_failure(command_line_arg, gettext("cannot read symbolic link %s"), filename);
    }
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/ls.c
// Address range: 0x804d3ca - 0x804d495
// Line range:    2863 - 2884
char * make_link_name(char * name, char * linkname) {
    // 0x804d3ca
    if (linkname == NULL) {
        // 0x804d490
        return NULL;
    }
    // 0x804d3e2
    if (*linkname == 47) {
        // 0x804d490
        return xstrdup(linkname);
    }
    char * found_char_pos = strrchr(name, 47); // 0x804d40d
    char * result; // 0x804d3ca
    if (found_char_pos != NULL) {
        int32_t v1 = (int32_t)found_char_pos - (int32_t)name; // 0x804d433
        int32_t n = v1 + 1; // 0x804d437
        char * str = xmalloc(v1 + 2 + strlen(linkname)); // 0x804d451
        strncpy(str, name, n);
        strcpy((char *)(n + (int32_t)str), linkname);
        result = str;
    } else {
        // 0x804d41b
        result = xstrdup(linkname);
    }
    // 0x804d490
    return result;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/ls.c
// Address range: 0x804d495 - 0x804d4b6
// Line range:    2891 - 2894
bool basename_is_dot_or_dotdot(char * name) {
    // 0x804d495
    return dot_or_dotdot(last_component(name));
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/system.h
// Address range: 0x804d4b6 - 0x804d51e
// Line range:    365 - 373
bool dot_or_dotdot(char * file_name) {
    // 0x804d4b6
    if (*file_name != 46) {
        // 0x804d518
        return false;
    }
    int32_t v1 = (int32_t)file_name; // 0x804d4c6
    char v2 = *(char *)((*(char *)(v1 + 1) != 46 ? 1 : 2) + v1); // 0x804d4e9
    if (v2 == 0) {
        // 0x804d518
        return true;
    }
    // 0x804d4f5
    return v2 == 47;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/ls.c
// Address range: 0x804d51e - 0x804d6bb
// Line range:    2906 - 2952
void extract_dirs_from_files(char * dirname, bool command_line_arg) {
    // 0x804d51e
    if (dirname != NULL && active_dir_set != NULL) {
        // 0x804d543
        queue_directory(NULL, dirname, false);
    }
    int32_t v1 = cwd_n_used; // 0x804d55e
    int32_t v2 = v1; // 0x804d654
    int32_t v3; // 0x804d51e
    int32_t v4; // 0x804d51e
    int32_t v5; // 0x804d57a
    int32_t * v6; // 0x804d51e
    if (v1 != 0) {
        // 0x804d56b
        v3 = v1;
        while (true) {
          lab_0x804d56b:
            // 0x804d56b
            v4 = v3 - 1;
            v5 = *(int32_t *)(4 * v4 + (int32_t)sorted_file);
            v6 = (int32_t *)v5;
            if (!is_directory(v6)) {
                goto lab_0x804d647;
            } else {
                if (dirname != NULL) {
                    // 0x804d59d
                    basename_is_dot_or_dotdot((char *)*v6);
                }
                char * v7 = (char *)*v6;
                if (dirname == NULL) {
                    // 0x804d5c7
                    queue_directory(v7, (char *)*(int32_t *)(v5 + 4), command_line_arg);
                    goto lab_0x804d62f;
                } else {
                    // 0x804d5bb
                    if (*v7 != 47) {
                        char * v8 = file_name_concat(dirname, v7, NULL); // 0x804d5ff
                        queue_directory(v8, (char *)*(int32_t *)(v5 + 4), command_line_arg);
                        free((int32_t *)v8);
                        goto lab_0x804d62f;
                    } else {
                        // 0x804d5c7
                        queue_directory(v7, (char *)*(int32_t *)(v5 + 4), command_line_arg);
                        goto lab_0x804d62f;
                    }
                }
            }
        }
      lab_0x804d647_2:
        // 0x804d647
        v2 = cwd_n_used;
    }
    int32_t v9 = 0; // 0x804d6af
    int32_t v10 = 0; // 0x804d6af
    if (v2 == 0) {
        // 0x804d6b1
        cwd_n_used = 0;
        return;
    }
    int32_t v11 = (int32_t)sorted_file; // 0x804d66a
    int32_t v12 = *(int32_t *)(4 * v10 + v11); // 0x804d679
    *(int32_t *)(4 * v9 + v11) = v12;
    v9 += (int32_t)(*(int32_t *)(v12 + 104) != 9);
    v10++;
    while (v10 < cwd_n_used) {
        // 0x804d66a
        v11 = (int32_t)sorted_file;
        v12 = *(int32_t *)(4 * v10 + v11);
        *(int32_t *)(4 * v9 + v11) = v12;
        v9 += (int32_t)(*(int32_t *)(v12 + 104) != 9);
        v10++;
    }
    // 0x804d6b1
    cwd_n_used = v9;
  lab_0x804d647:
    // 0x804d647
    v3 = v4;
    if (v4 == 0) {
        // break -> 0x804d647
        goto lab_0x804d647_2;
    }
    goto lab_0x804d56b;
  lab_0x804d62f:
    // 0x804d62f
    if (*(int32_t *)(v5 + 104) == 9) {
        // 0x804d63a
        free((int32_t *)*v6);
    }
    goto lab_0x804d647;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/../lib/stat-time.h
// Address range: 0x804d81c - 0x804d836
// Line range:    117 - 126
struct timespec get_stat_ctime(int32_t * st) {
    struct timespec result; // 0x804d833
    int32_t v1 = (int32_t)st;
    int32_t v2; // 0x804d81c
    *st = *(int32_t *)(v2 + 80);
    *(int32_t *)(v1 + 4) = *(int32_t *)(v2 + 84);
    result = (struct {int32_t e0; int32_t e1;}){
        .e0 = 0,
        .e1 = 0
    };
    result.e0 = v1;
    return result;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/../lib/stat-time.h
// Address range: 0x804db67 - 0x804db81
// Line range:    131 - 140
struct timespec get_stat_mtime(int32_t * st) {
    struct timespec result; // 0x804db7e
    int32_t v1 = (int32_t)st;
    int32_t v2; // 0x804db67
    *st = *(int32_t *)(v2 + 72);
    *(int32_t *)(v1 + 4) = *(int32_t *)(v2 + 76);
    result = (struct {int32_t e0; int32_t e1;}){
        .e0 = 0,
        .e1 = 0
    };
    result.e0 = v1;
    return result;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/../lib/stat-time.h
// Address range: 0x804de6e - 0x804de88
// Line range:    103 - 112
struct timespec get_stat_atime(int32_t * st) {
    struct timespec result; // 0x804de85
    int32_t v1 = (int32_t)st;
    int32_t v2; // 0x804de6e
    *st = *(int32_t *)(v2 + 64);
    *(int32_t *)(v1 + 4) = *(int32_t *)(v2 + 68);
    result = (struct {int32_t e0; int32_t e1;}){
        .e0 = 0,
        .e1 = 0
    };
    result.e0 = v1;
    return result;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/ls.c
// Address range: 0x804eab2 - 0x804eb01
// Line range:    3177 - 3181
void initialize_ordering_vector(void) {
    // 0x804eab2
    if (cwd_n_used == 0) {
        // 0x804eafb
        return;
    }
    int32_t v1 = 0;
    *(int32_t *)(4 * v1 + (int32_t)sorted_file) = 120 * v1 + (int32_t)cwd_file;
    int32_t v2 = v1 + 1; // 0x804eaed
    while (v2 < cwd_n_used) {
        // 0x804eac2
        v1 = v2;
        *(int32_t *)(4 * v1 + (int32_t)sorted_file) = 120 * v1 + (int32_t)cwd_file;
        v2 = v1 + 1;
    }
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/ls.c
// Address range: 0x804eb01 - 0x804ec2e
// Line range:    3187 - 3221
void sort_files(void) {
    uint32_t v1 = cwd_n_used;
    if (v1 / 2 + v1 > sorted_file_alloc) {
        // 0x804eb22
        free((int32_t *)sorted_file);
        char * v2 = xnmalloc(cwd_n_used, 12); // 0x804eb3f
        *(int32_t *)&sorted_file = (int32_t)v2;
        sorted_file_alloc = 3 * cwd_n_used;
    }
    // 0x804eb5a
    initialize_ordering_vector();
    if (sort_type == -1) {
        // 0x804ec27
        return;
    }
    int32_t v3 = _setjmp({
        (struct {int32_t e0[8]; int32_t e1; struct {int32_t e0[1];} e2;}){
            .e0 = {(int32_t)&failed_strcoll, 0, 0, 0, 0, 0, 0, 0},
            .e1 = 0,
            .e2 = (struct {int32_t e0[1];}){
                .e0 = {0}
            }
        }    
}); // 0x804eb74
    int32_t v4 = 0; // 0x804eb7b
    if (v3 != 0) {
        // 0x804eb83
        if (sort_type == 3) {
            // 0x804eb91
            __assert_fail("sort_type != sort_version", "ls.c", 3212, "sort_files");
        }
        // 0x804ebb5
        initialize_ordering_vector();
        v4 = 2;
    }
    int32_t v5 = sort_type != 4 ? 0 : time_type;
    unsigned char v6 = *(char *)&sort_reverse; // 0x804ebe3
    unsigned char v7 = *(char *)&directories_first; // 0x804ebed
    int32_t v8 = *(int32_t *)(4 * (2 * ((4 * (v5 + sort_type) | v4) + (int32_t)v6) + (int32_t)v7) + (int32_t)&sort_functions); // 0x804ec04
    mpsort((int32_t **)sorted_file, cwd_n_used, (int32_t (*)(int32_t *, int32_t *))v8);
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/ls.c
// Address range: 0x804ec2e - 0x804ecf0
// Line range:    3227 - 3260
void print_current_files(void) {
    // 0x804ec2e
    g54 = format;
    switch (format) {
        case 0: {
            // 0x804ece4
            for (int32_t i = 0; i < cwd_n_used; i++) {
                // 0x804ecae
                print_long_format((int32_t *)*(int32_t *)(4 * i + (int32_t)sorted_file));
                putchar_unlocked(10);
                dired_pos++;
            }
            // break -> 0x804ecee
            break;
        }
        case 1: {
            // 0x804ec84
            for (int32_t i = 0; i < cwd_n_used; i++) {
                int32_t v1 = *(int32_t *)(4 * i + (int32_t)sorted_file); // 0x804ec6a
                print_file_name_and_frills((int32_t *)v1);
                putchar_unlocked(10);
            }
            // break -> 0x804ecee
            break;
        }
        case 2: {
            // 0x804ec90
            print_many_per_line();
            // 0x804ecee
            return;
        }
        case 3: {
            // 0x804ec97
            print_horizontal();
            // 0x804ecee
            return;
        }
        case 4: {
            // 0x804ec9e
            print_with_commas();
            // 0x804ecee
            return;
        }
    }
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/ls.c
// Address range: 0x804ecf0 - 0x804ed9d
// Line range:    3267 - 3296
int32_t long_time_expected_width(void) {
    int32_t result = g25; // 0x804ecf9
    if (result >= 0) {
        // 0x804ed96
        return result;
    }
    int32_t timep = 0; // bp-16, 0x804ed06
    struct tm * time_info = localtime(&timep); // 0x804ed13
    if (time_info != NULL) {
        int32_t v1 = *(int32_t *)&long_time_format; // 0x804ed21
        int32_t v2; // bp-1017, 0x804ecf0
        int32_t v3 = nstrftime((char *)&v2, 1001, (char *)v1, time_info, 0, 0); // 0x804ed53
        if (v3 != 0) {
            // 0x804ed61
            g25 = mbsnwidth((char *)&v2, v3, 0);
        }
    }
    int32_t result2 = g25; // 0x804ed8a
    if (g25 < 0) {
        // 0x804ed8c
        g25 = 0;
        result2 = 0;
    }
    // 0x804ed96
    return result2;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/ls.c
// Address range: 0x804ed9d - 0x804edfc
// Line range:    3302 - 3332
void get_current_time(void) {
    // 0x804ed9d
    int32_t tp; // bp-12, 0x804ed9d
    int32_t v1; // 0x804ed9d
    if (clock_gettime(0, (struct timespec *)&tp) != 0) {
        // 0x804edcc
        int32_t tp2; // bp-20, 0x804ed9d
        gettimeofday((struct timeval *)&tp2, NULL);
        current_time = tp2;
        int64_t v2; // 0x804ed9d
        v1 = 1000 * (int32_t)v2 + 999;
    } else {
        // 0x804edba
        current_time = tp;
    }
    // 0x804edfa
    current_time_ns = v1;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/ls.c
// Address range: 0x804edfc - 0x804eeac
// Line range:    3339 - 3360
void format_user_or_group(char * name, int32_t id, int32_t width) {
    if (name == NULL) {
        // 0x804ee7a
        printf("%*lu ", width, id);
        // 0x804ee9a
        dired_pos += width + 1;
        return;
    }
    int32_t v1 = width - gnu_mbswidth(name, 0); // 0x804ee20
    int32_t v2 = v1 & (int32_t)(v1 < 0) - 1; // 0x804ee2d
    fputs_unlocked(name, (struct _IO_FILE *)g30);
    int32_t len = strlen(name); // 0x804ee4d
    int32_t v3 = v2; // 0x804ee5a
    putchar_unlocked(32);
    while (v3 != 0) {
        // 0x804ee5d
        v3--;
        putchar_unlocked(32);
    }
    // 0x804ee9a
    dired_pos += len + v2 + 1;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/ls.c
// Address range: 0x804eeac - 0x804ef0a
// Line range:    3367 - 3370
void format_user(int32_t u, int32_t width, bool stat_ok) {
    // 0x804eeac
    if (!stat_ok) {
        // 0x804eeef
        format_user_or_group((char *)&g7, u, width);
        return;
    }
    char * v1 = NULL; // 0x804eec7
    if (*(char *)&numeric_ids == 0) {
        // 0x804eed2
        v1 = getuser(u);
    }
    // 0x804eeef
    format_user_or_group(v1, u, width);
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/ls.c
// Address range: 0x804ef0a - 0x804ef68
// Line range:    3376 - 3379
void format_group(int32_t g, int32_t width, bool stat_ok) {
    // 0x804ef0a
    if (!stat_ok) {
        // 0x804ef4d
        format_user_or_group((char *)&g7, g, width);
        return;
    }
    char * v1 = NULL; // 0x804ef25
    if (*(char *)&numeric_ids == 0) {
        // 0x804ef30
        v1 = getgroup(g);
    }
    // 0x804ef4d
    format_user_or_group(v1, g, width);
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/ls.c
// Address range: 0x804ef68 - 0x804efc9
// Line range:    3385 - 3397
int32_t format_user_or_group_width(char * name, int32_t id) {
    int32_t len; // 0x804ef68
    if (name == NULL) {
        // 0x804ef9c
        int32_t str; // bp-19, 0x804ef68
        sprintf((char *)&str, "%lu", id);
        len = strlen((char *)&str);
    } else {
        int32_t v1 = gnu_mbswidth(name, 0); // 0x804ef82
        len = v1 & (int32_t)(v1 < 0) - 1;
    }
    // 0x804efc4
    return len;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/ls.c
// Address range: 0x804efc9 - 0x804f005
// Line range:    3403 - 3405
int32_t format_user_width(int32_t u) {
    char * v1 = NULL; // 0x804efd8
    if (*(char *)&numeric_ids == 0) {
        // 0x804efe3
        v1 = getuser(u);
    }
    // 0x804eff1
    return format_user_or_group_width(v1, u);
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/ls.c
// Address range: 0x804f005 - 0x804f041
// Line range:    3411 - 3413
int32_t format_group_width(int32_t g) {
    char * v1 = NULL; // 0x804f014
    if (*(char *)&numeric_ids == 0) {
        // 0x804f01f
        v1 = getgroup(g);
    }
    // 0x804f02d
    return format_user_or_group_width(v1, g);
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/ls.c
// Address range: 0x804f041 - 0x804fa54
// Line range:    3420 - 3641
void print_long_format(int32_t * f) {
    int32_t v1 = (int32_t)f;
    char * v2 = (char *)(v1 + 116); // 0x804f050
    int32_t v3; // bp-84, 0x804f041
    if (*v2 == 0) {
        char v4 = *(char *)(*(int32_t *)(v1 + 104) + (int32_t)"?pcdb-lswd"); // 0x804f075
        v3 = v4;
        int32_t v5; // bp-83, 0x804f041
        memset(&v5, 63, 10);
    } else {
        // 0x804f058
        filemodestring(&((struct obstack *)(v1 + 8))->e0, (char *)&v3);
    }
    // 0x804f0a1
    int32_t timep; // bp-3736, 0x804f041
    int32_t v6; // bp-4508, 0x804f041
    switch (time_type) {
        case 1: {
            // 0x804f0ef
            get_stat_ctime(&v6);
            timep = v6;
            // break -> 0x804f193
            break;
        }
        case 0: {
            // 0x804f124
            get_stat_mtime(&v6);
            timep = v6;
            // break -> 0x804f193
            break;
        }
        case 2: {
            // 0x804f159
            get_stat_atime(&v6);
            timep = v6;
            // break -> 0x804f193
            break;
        }
        default: {
            // 0x804f18e
            abort();
            // UNREACHABLE
        }
    }
    int32_t v7 = v6; // 0x804f193
    int32_t str; // bp-3727, 0x804f041
    int32_t v8 = &str; // 0x804f1ab
    int32_t v9 = v8; // 0x804f1b7
    if (*(char *)&print_inode != 0) {
        int32_t v10 = *(int32_t *)(v1 + 100); // 0x804f1bc
        int32_t v11 = *(int32_t *)(v1 + 96); // 0x804f1bf
        char * v12 = (char *)&g7; // 0x804f1c6
        if ((v11 || v10) != 0) {
            // 0x804f1c8
            v12 = umaxtostr((int64_t)v11, (char *)v10);
        }
        // 0x804f1f9
        sprintf((char *)&str, "%*s ", inode_number_width, v12);
        v9 = strlen((char *)&str) + v8;
    }
    int32_t v13 = v9; // 0x804f236
    int32_t v14; // bp-4493, 0x804f041
    if (*(char *)&print_block_size != 0) {
        char * v15 = (char *)&g7; // 0x804f245
        if (*v2 != 0) {
            int32_t v16 = *(int32_t *)(v1 + 68); // 0x804f261
            int32_t v17 = *(int32_t *)(v1 + 64); // 0x804f264
            v15 = human_readable((int64_t)v17, (char *)v16, (int32_t)&v14, (int64_t)human_output_opts, 512);
        }
        // 0x804f2b5
        char * v18; // bp-52, 0x804f041
        *(int32_t *)&v18 = (int32_t)v15;
        int32_t v19 = block_size_width - gnu_mbswidth(v15, 0); // 0x804f2d9
        v18 = v15;
        int32_t v20 = v9; // 0x804f2f4
        if (v19 >= 0 == (v19 != 0)) {
            *(char *)v9 = 32;
            int32_t v21 = v9 + 1; // 0x804f2e8
            int32_t v22 = v19 - 1; // 0x804f2ec
            int32_t v23 = v22; // 0x804f2f4
            int32_t v24 = v21; // 0x804f2f4
            while (v22 >= 0 == (v22 != 0)) {
                // 0x804f2e2
                *(char *)v24 = 32;
                v21 = v24 + 1;
                v22 = v23 - 1;
                v23 = v22;
                v24 = v21;
            }
            // 0x804f2f0
            v20 = v21;
        }
        char v25 = *v18; // 0x804f2f9
        char * v26 = (char *)v20;
        *v26 = v25;
        v13 = v20 + 1;
        char * v27 = (char *)((int32_t)v18 + 1); // 0x804f310
        v18 = v27;
        int32_t v28 = v13; // 0x804f316
        while (v25 != 0) {
            // 0x804f2f6
            v25 = *v27;
            v26 = (char *)v28;
            *v26 = v25;
            v13 = v28 + 1;
            v27 = (char *)((int32_t)v18 + 1);
            v18 = v27;
            v28 = v13;
        }
        // 0x804f318
        *v26 = 32;
    }
    char * v29 = (char *)&g7; // 0x804f32a
    if (*v2 != 0) {
        // 0x804f32c
        v29 = umaxtostr((int64_t)*(int32_t *)(v1 + 28), NULL);
    }
    char * str2 = (char *)v13; // 0x804f386
    sprintf(str2, "%s %*s ", &v3, nlink_width, v29);
    int32_t len = strlen(str2); // 0x804f394
    if (*(char *)&dired != 0) {
        // 0x804f3a7
        fwrite_unlocked((int32_t *)"  ", 1, 2, (struct _IO_FILE *)g30);
        dired_pos += 2;
    }
    int32_t v30 = len + v13; // 0x804f399
    char v31 = *(char *)&print_author; // 0x804f3ef
    char v32 = *(char *)&print_scontext; // 0x804f3fb
    int32_t str3 = v30; // 0x804f409
    if ((*(char *)&print_group | *(char *)&print_owner || v31 || v32) != 0) {
        // 0x804f40f
        fputs_unlocked((char *)&str, (struct _IO_FILE *)g30);
        dired_pos += v30 - v8;
        if (*(char *)&print_owner != 0) {
            // 0x804f44f
            format_user(*(int32_t *)(v1 + 32), owner_width, *v2 % 2 != 0);
        }
        // 0x804f475
        if (*(char *)&print_group != 0) {
            // 0x804f480
            format_group(*(int32_t *)(v1 + 36), group_width, *v2 % 2 != 0);
        }
        // 0x804f4a6
        if (*(char *)&print_author != 0) {
            // 0x804f4b1
            format_user(*(int32_t *)(v1 + 32), author_width, *v2 % 2 != 0);
        }
        // 0x804f4d7
        str3 = v8;
        if (*(char *)&print_scontext != 0) {
            // 0x804f4e2
            format_user_or_group((char *)*(int32_t *)(v1 + 112), 0, scontext_width);
            str3 = v8;
        }
    }
    char v33 = *v2;
    int32_t v34; // 0x804f041
    if (v33 != 1) {
        goto lab_0x804f61d;
    } else {
        int32_t v35 = *(int32_t *)(v1 + 24) & 0xf000; // 0x804f522
        if (v35 != 0x2000 == (v35 != 0x6000)) {
            goto lab_0x804f61d;
        } else {
            int32_t v36 = -2 - major_device_number_width - minor_device_number_width + file_size_width; // 0x804f561
            int32_t * v37 = (int32_t *)(v1 + 40); // 0x804f56d
            char * v38 = umaxtostr((int64_t)gnu_dev_minor((int64_t)*v37), NULL); // 0x804f594
            char * v39 = umaxtostr((int64_t)gnu_dev_major((int64_t)*v37), NULL); // 0x804f5ce
            sprintf((char *)str3, "%*s, %*s ", major_device_number_width + (v36 & (int32_t)(v36 < 0) - 1), v39, minor_device_number_width, v38);
            v34 = str3 + 1 + file_size_width;
            goto lab_0x804f703;
        }
    }
  lab_0x804f61d:;
    char * v40 = (char *)&g7; // 0x804f626
    if (v33 != 0) {
        int32_t v41 = *(int32_t *)(v1 + 56); // 0x804f63d
        int64_t v42 = unsigned_file_size((int64_t)*(int32_t *)(v1 + 52)); // 0x804f64a
        char * v43 = human_readable(0x100000000 * v42 >> 32, (char *)v41, (int32_t)&v14, (int64_t)human_output_opts, 1); // 0x804f680
        v40 = v43;
    }
    // 0x804f697
    char * v44; // bp-40, 0x804f041
    *(int32_t *)&v44 = (int32_t)v40;
    int32_t v45 = file_size_width - gnu_mbswidth(v40, 0); // 0x804f6bb
    char * v46 = v40; // 0x804f6d6
    int32_t v47 = str3; // 0x804f6d6
    if (v45 >= 0 == (v45 != 0)) {
        *(char *)str3 = 32;
        int32_t v48 = str3 + 1; // 0x804f6ca
        int32_t v49 = v45 - 1; // 0x804f6ce
        int32_t v50 = v49; // 0x804f6d6
        int32_t v51 = v48; // 0x804f6d6
        while (v49 >= 0 == (v49 != 0)) {
            // 0x804f6c4
            *(char *)v51 = 32;
            v48 = v51 + 1;
            v49 = v50 - 1;
            v50 = v49;
            v51 = v48;
        }
        // 0x804f6d2
        v46 = v44;
        v47 = v48;
    }
    char v52 = *v46; // 0x804f6db
    char * v53 = (char *)v47;
    *v53 = v52;
    int32_t v54 = v47 + 1; // 0x804f6ee
    char * v55 = (char *)((int32_t)v44 + 1); // 0x804f6f2
    v44 = v55;
    int32_t v56 = v54; // 0x804f6f8
    while (v52 != 0) {
        // 0x804f6d8
        v52 = *v55;
        v53 = (char *)v56;
        *v53 = v52;
        v54 = v56 + 1;
        v55 = (char *)((int32_t)v44 + 1);
        v44 = v55;
        v56 = v54;
    }
    // 0x804f6fa
    *v53 = 32;
    v34 = v54;
    goto lab_0x804f703;
  lab_0x804f703:;
    struct tm * time_info = localtime(&timep); // 0x804f70c
    char * str4 = (char *)v34; // 0x804f71e
    *str4 = 1;
    char v57 = *v2;
    char v58 = v57; // 0x804f72a
    int32_t v59; // 0x804f041
    int32_t v60; // 0x804f041
    if (time_info == NULL || v57 == 0) {
        goto lab_0x804f819;
    } else {
        // 0x804f73a
        if (current_time < v7) {
            goto lab_0x804f758;
        } else {
            // 0x804f744
            v59 = current_time;
            if (current_time == v7 == current_time_ns < v60) {
                goto lab_0x804f758;
            } else {
                goto lab_0x804f75d;
            }
        }
    }
  lab_0x804f819:;
    char * v61 = (char *)&g7; // 0x804f822
    if (v58 != 0) {
        // 0x804f824
        v61 = imaxtostr((int64_t)v7, (char *)(v7 >> 31));
    }
    // 0x804f856
    sprintf(str4, "%*s ", long_time_expected_width(), v61);
    int32_t v62 = strlen(str4) + v34; // 0x804f887
    goto lab_0x804f88a;
  lab_0x804f88a:
    // 0x804f88a
    fputs_unlocked((char *)&str, (struct _IO_FILE *)g30);
    dired_pos += v62 - v8;
    int32_t * v63 = (int32_t *)(v1 + 104); // 0x804f8c2
    int32_t v64 = *v63; // 0x804f8c2
    unsigned char v65 = *v2; // 0x804f8ce
    char * v66 = (char *)(v1 + 117); // 0x804f8de
    unsigned char v67 = *v66; // 0x804f8de
    char v68 = *(char *)&color_symlink_as_referent; // 0x804f8eb
    int32_t v69 = *(int32_t *)(((v68 & v67) == 0 ? 24 : 108) + v1);
    int32_t v70 = *f; // 0x804f922
    print_name_with_quoting((char *)v70, v69, (int32_t)v67, v65 % 2 != 0, v64, (struct obstack *)&dired_obstack);
    int32_t v71 = *v63; // 0x804f95f
    if (v71 != 6) {
        // 0x804fa1d
        if (indicator_style != 0) {
            // 0x804fa26
            print_type_indicator(*v2 % 2 != 0, *(int32_t *)(v1 + 24), v71);
        }
        // 0x804fa4c
        return;
    }
    int32_t * v72 = (int32_t *)(v1 + 4); // 0x804f96e
    if (*v72 == 0) {
        // 0x804fa4c
        return;
    }
    // 0x804f979
    fwrite_unlocked((int32_t *)" -> ", 1, 4, (struct _IO_FILE *)g30);
    dired_pos += 4;
    int32_t v73 = *v63; // 0x804f9ae
    unsigned char v74 = *v2; // 0x804f9b4
    unsigned char v75 = *v66; // 0x804f9be
    int32_t * v76 = (int32_t *)(v1 + 108); // 0x804f9cb
    int32_t v77 = *v76; // 0x804f9cb
    int32_t v78 = *v72; // 0x804f9d1
    print_name_with_quoting((char *)v78, v77, (int32_t)v75 - 1, v74 % 2 != 0, v73, NULL);
    if (indicator_style != 0) {
        // 0x804f9fd
        print_type_indicator(true, *v76, 0);
    }
  lab_0x804f758:
    // 0x804f758
    get_current_time();
    v59 = current_time;
    goto lab_0x804f75d;
  lab_0x804f75d:;
    // 0x804f75d
    int32_t v79; // 0x804f041
    if (v59 - 0xf0c2ac > v7) {
        // 0x804f79c
        v79 = (int32_t)&long_time_format;
        goto lab_0x804f7f1;
    } else {
        // 0x804f772
        v79 = (int32_t)&long_time_format + 4;
        if (v59 > v7) {
            goto lab_0x804f7f1;
        } else {
            // 0x804f77c
            v79 = (int32_t)&long_time_format + 4;
            if (v59 != v7 || current_time_ns < v60) {
                // 0x804f79c
                v79 = (int32_t)&long_time_format;
                goto lab_0x804f7f1;
            } else {
                goto lab_0x804f7f1;
            }
        }
    }
  lab_0x804f7f1:;
    int32_t v80 = nstrftime(str4, 1001, (char *)*(int32_t *)v79, time_info, 0, v60); // 0x804f7e9
    if (v80 != 0) {
        goto lab_0x804f801;
    } else {
        // 0x804f7f7
        if (*str4 != 0) {
            // 0x804f819
            v58 = *v2;
            goto lab_0x804f819;
        } else {
            goto lab_0x804f801;
        }
    }
  lab_0x804f801:;
    int32_t v81 = v80 + v34; // 0x804f804
    *(char *)v81 = 32;
    int32_t v82 = v81 + 1; // 0x804f80d
    *(char *)v82 = 0;
    v62 = v82;
    goto lab_0x804f88a;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/ls.c
// Address range: 0x804fa54 - 0x804fdef
// Line range:    3652 - 3811
int32_t quote_name(struct _IO_FILE * out, char * name, int32_t * options, int32_t * width) {
    char smallbuf[8192]; // bp-8256, 0x804fa54
    // 0x804fa54
    char * v1; // bp-8300, 0x804fa54
    int32_t v2 = (int32_t)&v1; // 0x804fa58
    int32_t v3; // bp-8248, 0x804fa54
    v1 = (char *)&v3;
    int32_t v4 = quotearg_buffer((char *)&v3, 0x2000, name, -1, options); // 0x804fa85
    int32_t v5; // 0x804fa54
    int32_t v6; // 0x804fa54
    if (v4 < 0x2000) {
        // 0x804fa96
        v5 = &v3;
        v6 = v2;
    } else {
        int32_t v7 = v2 - (v4 + 31 & -16); // 0x804fab3
        int32_t v8 = v7 + 35 & -16; // 0x804fac8
        *(int32_t *)(v7 + 16) = (int32_t)options;
        *(int32_t *)(v7 + 12) = -1;
        *(int32_t *)(v7 + 8) = (int32_t)name;
        *(int32_t *)(v7 + 4) = v4 + 1;
        *(int32_t *)v7 = v8;
        quotearg_buffer((char *)v4, (int32_t)&g49, (char *)&g49, (int32_t)&g49, &g49);
        v5 = v8;
        v6 = v7;
    }
    // 0x804fb08
    char * v9; // 0x804fa54
    char * v10; // 0x804fb99
    int32_t result; // 0x804fa54
    char * v11; // 0x804fa54
    char * v12; // 0x804fa54
    char * v13; // 0x804fa54
    char * v14; // bp-44, 0x804fa54
    struct _TYPEDEF___mbstate_t * v15; // 0x804fa54
    struct _TYPEDEF___mbstate_t * v16; // 0x804fa54
    struct _TYPEDEF___mbstate_t * v17; // 0x804fa54
    char * v18; // 0x804fb33
    int32_t v19; // 0x804fa54
    char v20; // 0x804fb4b
    if (*(char *)&qmark_funny_chars == 0) {
        // 0x804fd26
        result = v4;
        if (width != NULL) {
            // 0x804fd30
            if (__ctype_get_mb_cur_max() < 2) {
                uint32_t v21 = v5 + v4; // 0x804fd65
                result = v4;
                v17 = NULL;
                if (v21 > v5) {
                    int32_t v22 = v5; // 0x804fda6
                    struct _TYPEDEF___mbstate_t * v23 = NULL;
                    int16_t * v24 = *__ctype_b_loc(); // 0x804fd78
                    *(int32_t *)v6 = (int32_t)*(char *)v22;
                    unsigned char v25 = to_uchar((char)&g49); // 0x804fd86
                    int16_t v26 = *(int16_t *)(2 * (int32_t)v25 + (int32_t)v24); // 0x804fd93
                    struct _TYPEDEF___mbstate_t * v27 = (v26 & 0x4000) == 0 ? v23 : (struct _TYPEDEF___mbstate_t *)((int32_t)v23 + 1);
                    v22++;
                    result = v4;
                    v17 = v27;
                    while (v22 != v21) {
                        // 0x804fd73
                        v23 = v27;
                        v24 = *__ctype_b_loc();
                        *(int32_t *)v6 = (int32_t)*(char *)v22;
                        v25 = to_uchar((char)&g49);
                        v26 = *(int16_t *)(2 * (int32_t)v25 + (int32_t)v24);
                        v27 = (v26 & 0x4000) == 0 ? v23 : (struct _TYPEDEF___mbstate_t *)((int32_t)v23 + 1);
                        v22++;
                        result = v4;
                        v17 = v27;
                    }
                }
            } else {
                // 0x804fd3a
                *(int32_t *)(v6 + 8) = 0;
                *(int32_t *)(v6 + 4) = v4;
                *(int32_t *)v6 = v5;
                int32_t v28 = mbsnwidth((char *)&g49, (int32_t)&g49, (int32_t)&g49); // 0x804fd4f
                result = v4;
                v17 = (struct _TYPEDEF___mbstate_t *)v28;
            }
        }
    } else {
        char * v29 = (char *)v5;
        if (__ctype_get_mb_cur_max() < 2) {
            uint32_t v30 = v5 + v4; // 0x804fcd3
            if (v30 > v5) {
                int32_t v31 = v5; // 0x804fd0f
                int16_t * v32 = *__ctype_b_loc(); // 0x804fcdf
                *(int32_t *)v6 = (int32_t)*v29;
                unsigned char v33 = to_uchar((char)&g49); // 0x804fced
                if ((*(int16_t *)(2 * (int32_t)v33 + (int32_t)v32) & 0x4000) == 0) {
                    // 0x804fd09
                    *v29 = 63;
                }
                // 0x804fd0f
                v31++;
                while (v31 != v30) {
                    char * v34 = (char *)v31;
                    v32 = *__ctype_b_loc();
                    *(int32_t *)v6 = (int32_t)*v34;
                    v33 = to_uchar((char)&g49);
                    if ((*(int16_t *)(2 * (int32_t)v33 + (int32_t)v32) & 0x4000) == 0) {
                        // 0x804fd09
                        *v34 = 63;
                    }
                    // 0x804fd0f
                    v31++;
                }
            }
            // 0x804fd1b
            result = v4;
            v17 = (struct _TYPEDEF___mbstate_t *)v4;
        } else {
            // 0x804fb25
            v14 = v29;
            v18 = (char *)(v5 + v4);
            v13 = v29;
            v16 = NULL;
            if (v29 < v18) {
                // 0x804fb48
                v19 = (int32_t)&smallbuf;
                v9 = v29;
                v15 = NULL;
                v11 = v29;
                while (true) {
                  lab_0x804fb48:
                    // 0x804fb48
                    v12 = v11;
                    v10 = v9;
                    v20 = *v10;
                    int32_t v35 = v20; // 0x804fb4e
                    if (v20 > 95) {
                        if (v35 < 127) {
                            goto lab_0x804fb99;
                        } else {
                            goto lab_0x804fbb5;
                        }
                    } else {
                        if (v20 > 64) {
                            goto lab_0x804fb99;
                        } else {
                            if (v20 < 32) {
                                goto lab_0x804fbb5;
                            } else {
                                if (v20 < 36 || v35 < 64) {
                                    goto lab_0x804fb99;
                                } else {
                                    goto lab_0x804fbb5;
                                }
                            }
                        }
                    }
                }
            }
          lab_0x804fcb7:
            // 0x804fcb7
            result = (int32_t)v13 - v5;
            v17 = v16;
        }
    }
    // 0x804fdb2
    if (out != NULL) {
        // 0x804fdb8
        *(int32_t *)(v6 + 12) = (int32_t)out;
        *(int32_t *)(v6 + 8) = result;
        *(int32_t *)(v6 + 4) = 1;
        *(int32_t *)v6 = v5;
        fwrite_unlocked(&g49, (int32_t)&g49, (int32_t)&g49, (struct _IO_FILE *)&g49);
    }
    if (width != NULL) {
        // 0x804fddf
        *width = (int32_t)v17;
    }
    // 0x804fde7
    return result;
  lab_0x804fcab:;
    struct _TYPEDEF___mbstate_t * v36 = (struct _TYPEDEF___mbstate_t *)((int32_t)v15 + 1);
    v9 = v14;
    v15 = v36;
    char * v37; // 0x804fa54
    v11 = v37;
    v13 = v37;
    v16 = v36;
    if (v14 >= v18) {
        // break -> 0x804fcb7
        goto lab_0x804fcb7;
    }
    goto lab_0x804fb48;
  lab_0x804fb99:
    // 0x804fb99
    *v12 = v20;
    v14 = (char *)((int32_t)v14 + 1);
    v37 = (char *)((int32_t)v12 + 1);
    goto lab_0x804fcab;
  lab_0x804fbb5:
    // 0x804fbb5
    smallbuf = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    *(int32_t *)(v6 + 12) = v19;
    *(int32_t *)(v6 + 8) = (int32_t)v18 - (int32_t)v10;
    *(int32_t *)(v6 + 4) = (int32_t)v14;
    int32_t v38; // bp-8260, 0x804fa54
    *(int32_t *)v6 = (int32_t)&v38;
    int32_t v39 = mbrtowc(&g49, (char *)&g49, (int32_t)&g49, (struct _TYPEDEF___mbstate_t *)&g49); // 0x804fbf5
    if (v39 != -1) {
        char * v40; // 0x804fa54
        char * v41 = v40;
        struct _TYPEDEF___mbstate_t * v42; // 0x804fa54
        struct _TYPEDEF___mbstate_t * v43 = v42;
        int32_t v44; // 0x804fa54
        int32_t v45 = v44;
        char * v46; // bp-40, 0x804fa54
        while (v45 != -2) {
            int32_t v47 = v45 != 0 ? v45 : 1;
            int32_t v48 = v38; // 0x804fc43
            int32_t * v49; // 0x804fa54
            *v49 = v48;
            int32_t v50 = wcwidth(v47); // 0x804fc4c
            char * v51; // 0x804fa54
            int32_t v52; // 0x804fa54
            if (v50 < 0) {
                char * v53 = v14; // 0x804fc84
                v14 = (char *)(v47 + (int32_t)v53);
                *v41 = 63;
                v51 = (char *)((int32_t)v41 + 1);
                v52 = (int32_t)v43 + 1;
            } else {
                char * v54 = v41; // 0x804fc77
                if (v47 != 0) {
                    char * v55 = v14;
                    char * v56 = v55; // 0x804fa54
                    int32_t v57 = v47; // 0x804fa54
                    char * v58 = v41; // 0x804fa54
                    char * v59 = v58;
                    int32_t v60 = v57;
                    char * v61 = v56; // 0x804fc5c
                    char v62 = *v61; // 0x804fc5f
                    *v59 = v62;
                    char * v63 = (char *)((int32_t)v59 + 1);
                    char * v64 = v14; // 0x804fc6b
                    char * v65 = (char *)((int32_t)v64 + 1); // 0x804fc6b
                    v14 = v65;
                    int32_t v66 = v60 - 1; // 0x804fc6f
                    v56 = v65;
                    v57 = v66;
                    v58 = v63;
                    v54 = v63;
                    while (v66 != 0) {
                        // 0x804fc5c
                        v59 = v58;
                        v60 = v57;
                        v61 = v56;
                        v62 = *v61;
                        *v59 = v62;
                        v63 = (char *)((int32_t)v59 + 1);
                        v64 = v14;
                        v65 = (char *)((int32_t)v64 + 1);
                        v14 = v65;
                        v66 = v60 - 1;
                        v56 = v65;
                        v57 = v66;
                        v58 = v63;
                        v54 = v63;
                    }
                }
                char * v67 = v54;
                v51 = v67;
                v52 = v50 + (int32_t)v43;
            }
            int32_t v68 = v52;
            char * v69 = v51;
            struct _TYPEDEF___mbstate_t * ps = (struct _TYPEDEF___mbstate_t *)v68;
            *v49 = v19;
            v37 = v69;
            if (mbsinit(ps) != 0) {
                goto lab_0x804fcab;
            }
            char * v70 = v46;
            char * v71 = v14;
            int32_t * v72; // 0x804fa54
            *v72 = v19;
            int32_t * v73; // 0x804fa54
            *v73 = (int32_t)v70 - (int32_t)v71;
            char * v74 = v14; // 0x804fbe5
            int32_t * v75; // 0x804fa54
            *v75 = (int32_t)v74;
            int32_t v76; // 0x804fa54
            *v49 = v76;
            int32_t v77 = mbrtowc(&g49, (char *)&g49, (int32_t)&g49, (struct _TYPEDEF___mbstate_t *)&g49); // 0x804fbf5
            v44 = v77;
            v42 = ps;
            v40 = v69;
            if (v77 == -1) {
                goto lab_0x804fc03;
            }
            v41 = v40;
            v43 = v42;
            v45 = v44;
        }
        char * v78 = v46;
        *(int32_t *)&v14 = (int32_t)v78;
        *v41 = 63;
        v37 = (char *)((int32_t)v41 + 1);
    } else {
      lab_0x804fc03:
        // 0x804fc03
        v14 = (char *)((int32_t)v14 + 1);
        *v12 = 63;
        v37 = (char *)((int32_t)v12 + 1);
    }
    goto lab_0x804fcab;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/system.h
// Address range: 0x804fdef - 0x804fe01
// Line range:    263 - 263
char to_uchar(char ch) {
    // 0x804fdef
    return ch;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/ls.c
// Address range: 0x804fe01 - 0x804ff72
// Line range:    3817 - 3834
void print_name_with_quoting(char * p, int32_t mode, int32_t linkok, bool stat_ok, int32_t type, struct obstack * stack) {
    // 0x804fe01
    if (*(char *)&print_with_color != 0) {
        // 0x804fe18
        print_color_indicator(p, mode, linkok, stat_ok, type);
    }
    // 0x804fe40
    if (!((stack == NULL | *(char *)&dired == 0))) {
        int32_t v1 = (int32_t)stack;
        int32_t * v2 = (int32_t *)(v1 + 12);
        int32_t v3 = *v2; // 0x804fe61
        int32_t v4 = v3; // 0x804fe71
        if (v3 + 4 > *(int32_t *)(v1 + 16)) {
            // 0x804fe73
            _obstack_newchunk(stack, 4);
            v4 = *v2;
        }
        // 0x804fe85
        memcpy(&((struct obstack *)v4)->e0, &dired_pos, 4);
        *v2 = *v2 + 4;
    }
    // 0x804feb3
    dired_pos += quote_name((struct _IO_FILE *)g30, p, filename_quoting_options, NULL);
    if (!((stack == NULL | *(char *)&dired == 0))) {
        int32_t v5 = (int32_t)stack;
        int32_t * v6 = (int32_t *)(v5 + 12);
        int32_t v7 = *v6; // 0x804ff09
        int32_t v8 = v7; // 0x804ff19
        if (v7 + 4 > *(int32_t *)(v5 + 16)) {
            // 0x804ff1b
            _obstack_newchunk(stack, 4);
            v8 = *v6;
        }
        // 0x804ff2d
        memcpy(&((struct obstack *)v8)->e0, &dired_pos, 4);
        *v6 = *v6 + 4;
    }
    // 0x804ff5b
    if (*(char *)&print_with_color != 0) {
        // 0x804ff66
        process_signals();
        prep_non_filename_text();
    }
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/ls.c
// Address range: 0x804ff72 - 0x804ffb5
// Line range:    3838 - 3847
void prep_non_filename_text(void) {
    // 0x804ff72
    if (g18 == 0) {
        // 0x804ff8f
        put_indicator(&color_indicator);
        put_indicator(&g19);
        put_indicator(&g16);
    } else {
        // 0x804ff81
        put_indicator(&g17);
    }
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/ls.c
// Address range: 0x804ffb5 - 0x8050215
// Line range:    3855 - 3875
void print_file_name_and_frills(int32_t * f) {
    char buf[652]; // bp-676, 0x804ffb5
    char v1[652]; // 0x804ffb5
    char v2[652]; // 0x8050198
    char v3[652]; // 0x805018a
    int32_t v4 = (int32_t)f;
    if (*(char *)&print_inode != 0) {
        int32_t v5 = *(int32_t *)(v4 + 100); // 0x804ffd2
        char * v6 = umaxtostr((int64_t)*(int32_t *)(v4 + 96), (char *)v5); // 0x804ffe6
        printf("%*s ", format == 4 ? 0 : inode_number_width, v6);
    }
    // 0x8050032
    if (*(char *)&print_block_size != 0) {
        int32_t v7 = *(int32_t *)(v4 + 68); // 0x805005c
        int32_t v8 = *(int32_t *)(v4 + 64); // 0x805005f
        int32_t v9; // bp-668, 0x804ffb5
        char * v10 = human_readable((int64_t)v8, (char *)v7, (int32_t)&v9, (int64_t)human_output_opts, 512); // 0x8050099
        printf("%*s ", format == 4 ? 0 : block_size_width, v10);
    }
    // 0x80500e6
    if (*(char *)&print_scontext != 0) {
        // 0x80500f1
        printf("%*s ", format == 4 ? 0 : scontext_width, (char *)*(int32_t *)(v4 + 112));
    }
    int32_t * v11 = (int32_t *)(v4 + 104); // 0x8050141
    int32_t v12 = *v11; // 0x8050141
    char * v13 = (char *)(v4 + 116); // 0x805014d
    unsigned char v14 = *v13; // 0x805014d
    unsigned char v15 = *(char *)(v4 + 117); // 0x805015d
    if ((*(char *)&color_symlink_as_referent & v15) == 0) {
        // 0x8050192
        v2[0] = (char)*(int32_t *)(v4 + 24);
        v1 = v2;
    } else {
        // 0x8050184
        v3[0] = (char)*(int32_t *)(v4 + 108);
        v1 = v3;
    }
    // 0x805019e
    buf = v1;
    int32_t v16 = *(int32_t *)&buf; // 0x80501c9
    print_name_with_quoting((char *)*f, v16, (int32_t)v15, v14 % 2 != 0, v12, NULL);
    if (indicator_style != 0) {
        // 0x80501e4
        print_type_indicator(*v13 % 2 != 0, *(int32_t *)(v4 + 24), *v11);
    }
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/ls.c
// Address range: 0x8050215 - 0x8050368
// Line range:    3881 - 3909
char get_type_indicator(bool stat_ok, int32_t mode, int32_t type) {
    int32_t v1 = mode & 0xf000;
    if (!stat_ok ? type == 5 : v1 == 0x8000) {
        // 0x8050362
        return 0;
    }
    bool v2; // 0x8050215
    if (!stat_ok) {
        // 0x8050292
        v2 = type == 9;
        if (type == 3) {
            // 0x8050362
            return 47;
        }
    } else {
        // 0x805027f
        v2 = v1 == 0x4000;
    }
    // 0x80502b5
    if (v2) {
        // 0x8050362
        return 47;
    }
    // 0x80502c4
    if (indicator_style == 1) {
        // 0x8050362
        return 0;
    }
    // 0x80502d7
    if (!stat_ok ? type == 6 : v1 == 0xa000) {
        // 0x8050362
        return 64;
    }
    char result = 124; // 0x8050329
    if (!((!stat_ok ? type == 1 : v1 == 0x1000))) {
        // 0x8050331
        result = !((!stat_ok ? type == 7 : v1 == 0xc000)) ? 0 : 61;
    }
    // 0x8050362
    return result;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/ls.c
// Address range: 0x8050368 - 0x80503b2
// Line range:    3913 - 3917
void print_type_indicator(bool stat_ok, int32_t mode, int32_t type) {
    unsigned char v1 = get_type_indicator(stat_ok, mode, type); // 0x8050389
    if (v1 != 0) {
        // 0x8050397
        putchar_unlocked((int32_t)(v1 % 2 != 0));
        dired_pos++;
    }
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/ls.c
// Address range: 0x80503b2 - 0x805060f
// Line range:    3922 - 3999
void print_color_indicator(char * name, int32_t mode, int32_t linkok, bool stat_ok, int32_t filetype) {
    int32_t v1 = 11; // 0x80503c2
    int32_t v2 = 0; // 0x80503c2
    if (linkok != -1 || g22 == 0) {
        int32_t v3 = *(int32_t *)(4 * filetype + (int32_t)&g26); // 0x80503e7
        v1 = v3;
        v2 = 0;
        if (v3 == 4) {
            uint32_t len = strlen(name); // 0x8050571
            int32_t v4 = len + (int32_t)name; // 0x805057c
            int32_t v5 = (int32_t)color_ext_list; // 0x805057f
            v1 = v3;
            v2 = v5;
            if (color_ext_list != NULL) {
                uint32_t n = *(int32_t *)v5; // 0x805058c
                int32_t str; // 0x805059b
                if (n <= len) {
                    // 0x8050593
                    str = *(int32_t *)(v5 + 4);
                    if (strncmp((char *)(v4 - n), (char *)str, n) == 0) {
                        // break -> 0x80505cb
                        break;
                    }
                }
                int32_t v6 = *(int32_t *)(v5 + 16); // 0x80505bf
                v1 = v3;
                v2 = v6;
                while (v6 != 0) {
                    int32_t v7 = v6;
                    n = *(int32_t *)v7;
                    if (n <= len) {
                        // 0x8050593
                        str = *(int32_t *)(v7 + 4);
                        v1 = v3;
                        v2 = v7;
                        if (strncmp((char *)(v4 - n), (char *)str, n) == 0) {
                            // break -> 0x80505cb
                            break;
                        }
                    }
                    // 0x80505bc
                    v6 = *(int32_t *)(v7 + 16);
                    v1 = v3;
                    v2 = v6;
                }
            }
        }
    }
    int32_t v8 = v2;
    put_indicator(&color_indicator);
    int32_t v9 = v8 == 0 ? 8 * v1 + (int32_t)&color_indicator : v8 + 8;
    put_indicator((int32_t *)v9);
    put_indicator(&g16);
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/ls.c
// Address range: 0x805060f - 0x8050649
// Line range:    4004 - 4012
void put_indicator(int32_t * ind) {
    int32_t v1 = *ind; // 0x8050621
    if (v1 == 0) {
        // 0x8050647
        return;
    }
    int32_t v2 = v1; // 0x805063d
    int32_t c = *(int32_t *)((int32_t)ind + 4); // 0x805060f
    putchar_unlocked((int32_t)*(char *)c);
    v2--;
    c++;
    while (v2 != 0) {
        // 0x8050628
        putchar_unlocked((int32_t)*(char *)c);
        v2--;
        c++;
    }
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/ls.c
// Address range: 0x8050649 - 0x8050817
// Line range:    4016 - 4046
int32_t length_of_file_name_and_frills(int32_t * f) {
    int32_t v1 = (int32_t)f;
    int32_t v2 = 0; // 0x8050665
    if (*(char *)&print_inode != 0) {
        // 0x8050667
        int32_t len2; // 0x8050649
        if (format != 4) {
            // 0x80506a3
            len2 = inode_number_width;
        } else {
            int32_t v3 = *(int32_t *)(v1 + 96); // 0x8050674
            int32_t v4 = *(int32_t *)(v1 + 100); // 0x8050677
            len2 = strlen(umaxtostr((int64_t)v3, (char *)v4));
        }
        // 0x80506b1
        v2 = len2 + 1;
    }
    int32_t v5 = v2; // 0x80506c3
    if (*(char *)&print_block_size != 0) {
        // 0x80506c9
        int32_t len3; // 0x8050649
        if (format != 4) {
            // 0x8050742
            len3 = block_size_width;
        } else {
            int32_t v6 = *(int32_t *)(v1 + 68); // 0x80506ed
            int32_t v7 = *(int32_t *)(v1 + 64); // 0x80506f0
            int32_t v8; // bp-680, 0x8050649
            char * str = human_readable((int64_t)v7, (char *)v6, (int32_t)&v8, (int64_t)human_output_opts, 512); // 0x805072a
            len3 = strlen(str);
        }
        // 0x8050750
        v5 = v2 + 1 + len3;
    }
    int32_t v9 = v5; // 0x8050762
    if (*(char *)&print_scontext != 0) {
        // 0x8050764
        int32_t len4; // 0x8050649
        if (format != 4) {
            // 0x8050787
            len4 = scontext_width;
        } else {
            // 0x805076e
            len4 = strlen((char *)*(int32_t *)(v1 + 112));
        }
        // 0x8050795
        v9 = v5 + 1 + len4;
    }
    // 0x805079e
    int32_t len; // bp-28, 0x8050649
    quote_name(NULL, (char *)*f, filename_quoting_options, &len);
    int32_t v10 = len + v9; // 0x80507c7
    int32_t result = v10; // 0x80507d1
    if (indicator_style != 0) {
        int32_t v11 = *(int32_t *)(v1 + 104); // 0x80507d6
        int32_t v12 = *(int32_t *)(v1 + 24); // 0x80507dc
        unsigned char v13 = *(char *)(v1 + 116); // 0x80507e2
        result = v10 + (int32_t)(get_type_indicator(v13 % 2 != 0, v12, v11) != 0);
    }
    // 0x8050809
    return result;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/ls.c
// Address range: 0x8050817 - 0x8050931
// Line range:    4050 - 4082
void print_many_per_line(void) {
    uint32_t v1 = calculate_columns(true); // 0x8050824
    uint32_t v2 = cwd_n_used;
    uint32_t v3 = v2 / v1 + (int32_t)(v2 % v1 != 0); // 0x8050873
    if (v3 == 0) {
        // 0x805092f
        return;
    }
    int32_t * v4 = (int32_t *)(12 * v1 - 4 + (int32_t)column_info);
    for (int32_t i = 0; i < v3; i++) {
        int32_t v5 = i; // 0x80508e1
        int32_t v6 = 0; // 0x80508f4
        int32_t v7 = 0;
        int32_t * v8 = (int32_t *)*(int32_t *)(4 * v5 + (int32_t)sorted_file); // 0x80508b3
        int32_t v9 = length_of_file_name_and_frills(v8); // 0x80508b3
        int32_t v10 = *(int32_t *)(*v4 + 4 * v7); // 0x80508ca
        print_file_name_and_frills(v8);
        v5 += v3;
        while (v5 < cwd_n_used) {
            int32_t v11 = v6;
            v6 = v10 + v11;
            indent(v9 + v11, v6);
            v7++;
            v8 = (int32_t *)*(int32_t *)(4 * v5 + (int32_t)sorted_file);
            v9 = length_of_file_name_and_frills(v8);
            v10 = *(int32_t *)(*v4 + 4 * v7);
            print_file_name_and_frills(v8);
            v5 += v3;
        }
        // 0x8050913
        putchar_unlocked(10);
    }
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/ls.c
// Address range: 0x8050931 - 0x8050a55
// Line range:    4086 - 4121
void print_horizontal(void) {
    uint32_t v1 = calculate_columns(false); // 0x8050945
    int32_t v2 = length_of_file_name_and_frills((int32_t *)sorted_file); // 0x8050978
    int32_t * v3 = (int32_t *)(12 * v1 - 4 + (int32_t)column_info); // 0x8050983
    print_file_name_and_frills((int32_t *)sorted_file);
    int32_t v4 = 1; // 0x8050a41
    if (cwd_n_used <= 1) {
        // 0x8050a47
        putchar_unlocked(10);
        return;
    }
    uint32_t v5 = v4 % v1;
    int32_t * v6; // 0x8050931
    int32_t v7; // 0x80509d4
    int32_t v8; // 0x80509d7
    if (v5 != 0) {
        // 0x80509d1
        v7 = (int32_t)NULL;
        v8 = *(int32_t *)*v3 + v7;
        indent(v2 + v7, v8);
        v6 = (int32_t *)v8;
    } else {
        // 0x80509bc
        putchar_unlocked(10);
        v6 = NULL;
    }
    int32_t * v9 = (int32_t *)*(int32_t *)(4 * v4 + (int32_t)sorted_file);
    print_file_name_and_frills(v9);
    int32_t v10 = length_of_file_name_and_frills(v9); // 0x8050a19
    v4++;
    int32_t v11 = *(int32_t *)(*v3 + 4 * v5); // 0x8050a41
    int32_t v12 = v10; // 0x8050a41
    while (v4 < cwd_n_used) {
        // 0x80509a2
        v5 = v4 % v1;
        if (v5 != 0) {
            // 0x80509d1
            v7 = (int32_t)v6;
            v8 = v11 + v7;
            indent(v12 + v7, v8);
            v6 = (int32_t *)v8;
        } else {
            // 0x80509bc
            putchar_unlocked(10);
            v6 = NULL;
        }
        // 0x80509f4
        v9 = (int32_t *)*(int32_t *)(4 * v4 + (int32_t)sorted_file);
        print_file_name_and_frills(v9);
        v10 = length_of_file_name_and_frills(v9);
        v4++;
        v11 = *(int32_t *)(*v3 + 4 * v5);
        v12 = v10;
    }
    // 0x8050a47
    putchar_unlocked(10);
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/ls.c
// Address range: 0x8050a55 - 0x8050b05
// Line range:    4125 - 4157
void print_with_commas(void) {
    int32_t v1 = 0; // 0x8050af1
    if (cwd_n_used == 0) {
        // 0x8050af7
        putchar_unlocked(10);
        return;
    }
    int32_t v2 = 0;
    int32_t * v3 = (int32_t *)*(int32_t *)(4 * v1 + (int32_t)sorted_file); // 0x8050a85
    int32_t v4 = length_of_file_name_and_frills(v3); // 0x8050a85
    int32_t v5 = v2; // 0x8050a91
    int32_t v6; // 0x8050a55
    if (v1 != 0) {
        // 0x8050a93
        v6 = v2 + 2;
        v5 = v4 + v6 >= line_length ? 0 : v6;
        putchar_unlocked(44);
        putchar_unlocked(v4 + v6 >= line_length ? 10 : 32);
    }
    // 0x8050ad4
    print_file_name_and_frills(v3);
    v1++;
    while (v1 < cwd_n_used) {
        // 0x8050a6b
        v2 = v5 + v4;
        v3 = (int32_t *)*(int32_t *)(4 * v1 + (int32_t)sorted_file);
        v4 = length_of_file_name_and_frills(v3);
        v5 = v2;
        if (v1 != 0) {
            // 0x8050a93
            v6 = v2 + 2;
            v5 = v4 + v6 >= line_length ? 0 : v6;
            putchar_unlocked(44);
            putchar_unlocked(v4 + v6 >= line_length ? 10 : 32);
        }
        // 0x8050ad4
        print_file_name_and_frills(v3);
        v1++;
    }
    // 0x8050af7
    putchar_unlocked(10);
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/ls.c
// Address range: 0x8050b05 - 0x8050baf
// Line range:    4164 - 4178
void indent(uint32_t from, uint32_t to) {
    // 0x8050b05
    if (from >= to) {
        // 0x8050ba9
        return;
    }
    int32_t v1 = from; // 0x8050ba3
    int32_t v2; // 0x8050b05
    int32_t v3; // 0x8050b05
    while (true) {
      lab_0x8050b11_2:;
        uint32_t v4 = v1;
        uint32_t v5 = tabsize; // 0x8050b11
        if (v5 == 0) {
            // 0x8050b11
            v2 = v4 + 1;
            goto lab_0x8050ba9;
        } else {
            int32_t v6 = v4 + 1;
            v2 = v6;
            if (to / v5 > v6 / v5) {
                // 0x8050b56
                putchar_unlocked(9);
                uint32_t v7 = tabsize;
                v3 = v7 + v4 - v4 % v7;
                goto lab_0x8050b9d;
            } else {
                goto lab_0x8050ba9;
            }
        }
    }
  lab_0x8050ba9:
    // 0x8050b8d
    putchar_unlocked(32);
    v3 = v2;
    goto lab_0x8050b9d;
  lab_0x8050b9d:
    // 0x8050b9d
    v1 = v3;
    if (v1 >= to) {
        // break -> 0x8050ba9
        goto lab_0x8050ba9;
    }
    goto lab_0x8050b11_2;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/ls.c
// Address range: 0x8050baf - 0x8050c37
// Line range:    4186 - 4201
void attach(char * dest, char * dirname, char * name) {
    char v1 = *dirname; // 0x8050bbe
    char * v2; // 0x8050baf
    if (v1 != 46) {
        goto lab_0x8050be7;
    } else {
        // 0x8050bc5
        v2 = dest;
        if (*(char *)((int32_t)dirname + 1) == 0) {
            goto lab_0x8050c25;
        } else {
            goto lab_0x8050be7;
        }
    }
  lab_0x8050be7:
    // 0x8050be7
    v2 = dest;
    if (v1 != 0) {
        char * v3 = dirname;
        *dest = v1;
        int32_t v4 = (int32_t)dest;
        char * v5 = (char *)(v4 + 1);
        char * v6 = (char *)((int32_t)v3 + 1);
        char v7 = *v6; // 0x8050bea
        char * v8 = v5; // 0x8050bef
        while (v7 != 0) {
            // 0x8050bd4
            v3 = v6;
            *v8 = v7;
            v4 = (int32_t)v8;
            v5 = (char *)(v4 + 1);
            v6 = (char *)((int32_t)v3 + 1);
            v7 = *v6;
            v8 = v5;
        }
        // 0x8050bf1
        v2 = v5;
        if (v6 > dirname) {
            // 0x8050bf9
            v2 = v5;
            if (*v3 != 47) {
                // 0x8050c06
                *v5 = 47;
                v2 = (char *)(v4 + 2);
            }
        }
    }
    goto lab_0x8050c25;
  lab_0x8050c25:;
    char v9 = *name; // 0x8050c28
    if (v9 == 0) {
        // 0x8050c2f
        *v2 = 0;
        return;
    }
    *v2 = v9;
    char * v10 = (char *)((int32_t)v2 + 1);
    char * v11 = (char *)((int32_t)name + 1); // 0x8050c21
    char v12 = *v11; // 0x8050c28
    char * v13 = v11; // 0x8050c2d
    char * v14 = v10; // 0x8050c2d
    while (v12 != 0) {
        // 0x8050c12
        *v14 = v12;
        v10 = (char *)((int32_t)v14 + 1);
        v11 = (char *)((int32_t)v13 + 1);
        v12 = *v11;
        v13 = v11;
        v14 = v10;
    }
    // 0x8050c2f
    *v10 = 0;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/ls.c
// Address range: 0x8050c37 - 0x8050e06
// Line range:    4209 - 4270
void init_column_info(void) {
    uint32_t v1 = cwd_n_used; // 0x8050c3d
    uint32_t v2 = max_idx; // 0x8050c42
    uint32_t v3 = v1 > v2 ? v2 : v1;
    if (g32 < v3) {
        // 0x8050c70
        int32_t v4; // 0x8050c37
        if (v2 / 2 > v3) {
            char * v5 = xnrealloc((char *)column_info, v3, 24); // 0x8050c94
            *(int32_t *)&column_info = (int32_t)v5;
            v4 = 2 * v3;
        } else {
            char * v6 = xnrealloc((char *)column_info, v2, 12); // 0x8050cc2
            *(int32_t *)&column_info = (int32_t)v6;
            v4 = max_idx;
        }
        uint32_t v7 = v4 + 1 + g32; // 0x8050cea
        if (v7 < v4) {
            // 0x8050d12
            xalloc_die();
            // UNREACHABLE
        }
        uint32_t v8 = v4 - g32; // 0x8050cdd
        uint32_t v9 = v7 * v8; // 0x8050cf3
        if (v7 != v9 / v8) {
            // 0x8050d12
            xalloc_die();
            // UNREACHABLE
        }
        char * v10 = xnmalloc(v9 / 2, 4); // 0x8050d27
        int32_t v11 = g32; // 0x8050d2f
        if (v11 < v4) {
            int32_t v12 = (int32_t)v10; // 0x8050c37
            *(int32_t *)(12 * v11 + 8 + (int32_t)column_info) = v12;
            int32_t v13 = v11 + 1; // 0x8050d60
            v12 = v12 + 4 + 4 * v11;
            while (v13 != v4) {
                int32_t v14 = v13;
                *(int32_t *)(12 * v14 + 8 + (int32_t)column_info) = v12;
                v13 = v14 + 1;
                v12 = v12 + 4 + 4 * v14;
            }
        }
        // 0x8050d6c
        g32 = v4;
    }
    int32_t v15 = 1; // 0x8050dfe
    if (v3 == 0) {
        // 0x8050e04
        return;
    }
    int32_t v16 = 0; // 0x8050dfe
    int32_t v17 = 12 * v16; // 0x8050d8c
    *(char *)(v17 + (int32_t)column_info) = 1;
    *(int32_t *)(v17 + 4 + (int32_t)column_info) = 3 * v16 + 3;
    int32_t v18 = 0; // 0x8050de8
    int32_t v19 = *(int32_t *)(v17 + 8 + (int32_t)column_info); // 0x8050dd6
    *(int32_t *)(v19 + 4 * v18) = 3;
    v18++;
    while (v18 != v15) {
        // 0x8050dc1
        v19 = *(int32_t *)(v17 + 8 + (int32_t)column_info);
        *(int32_t *)(v19 + 4 * v18) = 3;
        v18++;
    }
    // 0x8050df4
    v16++;
    v15++;
    while (v16 < v3) {
        // 0x8050d7d
        v17 = 12 * v16;
        *(char *)(v17 + (int32_t)column_info) = 1;
        *(int32_t *)(v17 + 4 + (int32_t)column_info) = 3 * v16 + 3;
        v18 = 0;
        v19 = *(int32_t *)(v17 + 8 + (int32_t)column_info);
        *(int32_t *)(v19 + 4 * v18) = 3;
        v18++;
        while (v18 != v15) {
            // 0x8050dc1
            v19 = *(int32_t *)(v17 + 8 + (int32_t)column_info);
            *(int32_t *)(v19 + 4 * v18) = 3;
            v18++;
        }
        // 0x8050df4
        v16++;
        v15++;
    }
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/ls.c
// Address range: 0x8050e06 - 0x805105c
// Line range:    4277 - 4324
int32_t calculate_columns(bool by_columns) {
    uint32_t v1 = cwd_n_used; // 0x8050e14
    uint32_t v2 = max_idx; // 0x8050e19
    int32_t result = v1 > v2 ? v2 : v1;
    init_column_info();
    if (cwd_n_used != 0) {
        uint32_t v3 = 0;
        int32_t v4 = *(int32_t *)(4 * v3 + (int32_t)sorted_file); // 0x8050e59
        int32_t v5 = length_of_file_name_and_frills((int32_t *)v4); // 0x8050e64
        int32_t v6; // 0x8050e06
        int32_t v7; // 0x8050e06
        int32_t v8; // 0x8050e87
        int32_t v9; // 0x8050e06
        int32_t v10; // 0x8050fff
        uint32_t v11; // 0x8050f14
        int32_t v12; // 0x8050f35
        uint32_t v13; // 0x8050f3b
        int32_t * v14; // 0x8050f70
        int32_t v15; // 0x8050fb6
        int32_t v16; // 0x8050fd8
        if (result != 0) {
            v6 = 0;
            v8 = 12 * v6;
            v9 = v8 + (int32_t)column_info;
            if (*(char *)v9 != 0) {
                if (!by_columns) {
                    // 0x8050ed8
                    v7 = v3 % (v6 + 1);
                } else {
                    // 0x8050e9e
                    v7 = v3 / ((cwd_n_used + v6) / (v6 + 1));
                }
                // 0x8050ef3
                v11 = (v7 != v6 ? 2 : 0) + v5;
                v12 = 4 * v7;
                v13 = *(int32_t *)(*(int32_t *)(v9 + 8) + v12);
                if (v11 > v13) {
                    // 0x8050f46
                    v14 = (int32_t *)(v9 + 4);
                    *v14 = v11 - v13 + *v14;
                    v15 = *(int32_t *)(v8 + 8 + (int32_t)column_info);
                    *(int32_t *)(v15 + v12) = v11;
                    v16 = v8 + (int32_t)column_info;
                    *(char *)v16 = (char)(*(int32_t *)(v16 + 4) < line_length);
                }
            }
            // 0x8050fff
            v10 = v6 + 1;
            while (v10 < result) {
                // 0x8050e78
                v6 = v10;
                v8 = 12 * v6;
                v9 = v8 + (int32_t)column_info;
                if (*(char *)v9 != 0) {
                    if (!by_columns) {
                        // 0x8050ed8
                        v7 = v3 % (v6 + 1);
                    } else {
                        // 0x8050e9e
                        v7 = v3 / ((cwd_n_used + v6) / (v6 + 1));
                    }
                    // 0x8050ef3
                    v11 = (v7 != v6 ? 2 : 0) + v5;
                    v12 = 4 * v7;
                    v13 = *(int32_t *)(*(int32_t *)(v9 + 8) + v12);
                    if (v11 > v13) {
                        // 0x8050f46
                        v14 = (int32_t *)(v9 + 4);
                        *v14 = v11 - v13 + *v14;
                        v15 = *(int32_t *)(v8 + 8 + (int32_t)column_info);
                        *(int32_t *)(v15 + v12) = v11;
                        v16 = v8 + (int32_t)column_info;
                        *(char *)v16 = (char)(*(int32_t *)(v16 + 4) < line_length);
                    }
                }
                // 0x8050fff
                v10 = v6 + 1;
            }
        }
        int32_t v17 = v3 + 1; // 0x805100f
        while (v17 < cwd_n_used) {
            // 0x8050e4a
            v3 = v17;
            v4 = *(int32_t *)(4 * v3 + (int32_t)sorted_file);
            v5 = length_of_file_name_and_frills((int32_t *)v4);
            if (result != 0) {
                v6 = 0;
                v8 = 12 * v6;
                v9 = v8 + (int32_t)column_info;
                if (*(char *)v9 != 0) {
                    if (!by_columns) {
                        // 0x8050ed8
                        v7 = v3 % (v6 + 1);
                    } else {
                        // 0x8050e9e
                        v7 = v3 / ((cwd_n_used + v6) / (v6 + 1));
                    }
                    // 0x8050ef3
                    v11 = (v7 != v6 ? 2 : 0) + v5;
                    v12 = 4 * v7;
                    v13 = *(int32_t *)(*(int32_t *)(v9 + 8) + v12);
                    if (v11 > v13) {
                        // 0x8050f46
                        v14 = (int32_t *)(v9 + 4);
                        *v14 = v11 - v13 + *v14;
                        v15 = *(int32_t *)(v8 + 8 + (int32_t)column_info);
                        *(int32_t *)(v15 + v12) = v11;
                        v16 = v8 + (int32_t)column_info;
                        *(char *)v16 = (char)(*(int32_t *)(v16 + 4) < line_length);
                    }
                }
                // 0x8050fff
                v10 = v6 + 1;
                while (v10 < result) {
                    // 0x8050e78
                    v6 = v10;
                    v8 = 12 * v6;
                    v9 = v8 + (int32_t)column_info;
                    if (*(char *)v9 != 0) {
                        if (!by_columns) {
                            // 0x8050ed8
                            v7 = v3 % (v6 + 1);
                        } else {
                            // 0x8050e9e
                            v7 = v3 / ((cwd_n_used + v6) / (v6 + 1));
                        }
                        // 0x8050ef3
                        v11 = (v7 != v6 ? 2 : 0) + v5;
                        v12 = 4 * v7;
                        v13 = *(int32_t *)(*(int32_t *)(v9 + 8) + v12);
                        if (v11 > v13) {
                            // 0x8050f46
                            v14 = (int32_t *)(v9 + 4);
                            *v14 = v11 - v13 + *v14;
                            v15 = *(int32_t *)(v8 + 8 + (int32_t)column_info);
                            *(int32_t *)(v15 + v12) = v11;
                            v16 = v8 + (int32_t)column_info;
                            *(char *)v16 = (char)(*(int32_t *)(v16 + 4) < line_length);
                        }
                    }
                    // 0x8050fff
                    v10 = v6 + 1;
                }
            }
            // 0x805100f
            v17 = v3 + 1;
        }
    }
    // 0x805104c
    if (result < 2) {
        // 0x8051052
        return result;
    }
    int32_t v18 = result; // 0x8051048
    int32_t result2 = v18; // 0x8051046
    while (*(char *)((int32_t)column_info - 12 + 12 * v18) == 0) {
        // 0x8051048
        v18--;
        result2 = 1;
        if (v18 < 2) {
            // break -> 0x8051052
            break;
        }
        result2 = v18;
    }
    // 0x8051052
    return result2;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/ls.c
// Address range: 0x805105c - 0x80513b2
// Line range:    4328 - 4488
void usage(int32_t status) {
    if (status == 0) {
        // 0x8051096
        printf(gettext("Usage: %s [OPTION]... [FILE]...\n"));
        fputs_unlocked(gettext("List information about the FILEs (the current directory by default).\nSort entries alphabetically if none of -cftuvSUX nor --sort.\n\n"), (struct _IO_FILE *)g30);
        fputs_unlocked(gettext("Mandatory arguments to long options are mandatory for short options too.\n"), (struct _IO_FILE *)g30);
        fputs_unlocked(gettext("  -a, --all                  do not ignore entries starting with .\n  -A, --almost-all           do not list implied . and ..\n      --author               with -l, print the author of each file\n  -b, --escape               print octal escapes for nongraphic characters\n"), (struct _IO_FILE *)g30);
        fputs_unlocked(gettext("      --block-size=SIZE      use SIZE-byte blocks\n  -B, --ignore-backups       do not list implied entries ending with ~\n  -c                         with -lt: sort by, and show, ctime (time of last\n                               modification of file status information)\n                               with -l: show ctime and sort by name\n                               otherwise: sort by ctime\n"), (struct _IO_FILE *)g30);
        fputs_unlocked(gettext("  -C                         list entries by columns\n      --color[=WHEN]         control whether color is used to distinguish file\n                               types.  WHEN may be `never', `always', or `auto'\n  -d, --directory            list directory entries instead of contents,\n                               and do not dereference symbolic links\n  -D, --dired                generate output designed for Emacs' dired mode\n"), (struct _IO_FILE *)g30);
        fputs_unlocked(gettext("  -f                         do not sort, enable -aU, disable -ls --color\n  -F, --classify             append indicator (one of */=>@|) to entries\n      --file-type            likewise, except do not append `*'\n      --format=WORD          across -x, commas -m, horizontal -x, long -l,\n                               single-column -1, verbose -l, vertical -C\n      --full-time            like -l --time-style=full-iso\n"), (struct _IO_FILE *)g30);
        fputs_unlocked(gettext("  -g                         like -l, but do not list owner\n"), (struct _IO_FILE *)g30);
        fputs_unlocked(gettext("      --group-directories-first\n                             group directories before files\n"), (struct _IO_FILE *)g30);
        fputs_unlocked(gettext("  -G, --no-group             in a long listing, don't print group names\n  -h, --human-readable       with -l, print sizes in human readable format\n                               (e.g., 1K 234M 2G)\n      --si                   likewise, but use powers of 1000 not 1024\n"), (struct _IO_FILE *)g30);
        fputs_unlocked(gettext("  -H, --dereference-command-line\n                             follow symbolic links listed on the command line\n      --dereference-command-line-symlink-to-dir\n                             follow each command line symbolic link\n                             that points to a directory\n      --hide=PATTERN         do not list implied entries matching shell PATTERN\n                               (overridden by -a or -A)\n"), (struct _IO_FILE *)g30);
        fputs_unlocked(gettext("      --indicator-style=WORD  append indicator with style WORD to entry names:\n                               none (default), slash (-p),\n                               file-type (--file-type), classify (-F)\n  -i, --inode                print the index number of each file\n  -I, --ignore=PATTERN       do not list implied entries matching shell PATTERN\n  -k                         like --block-size=1K\n"), (struct _IO_FILE *)g30);
        fputs_unlocked(gettext("  -l                         use a long listing format\n  -L, --dereference          when showing file information for a symbolic\n                               link, show information for the file the link\n                               references rather than for the link itself\n  -m                         fill width with a comma separated list of entries\n"), (struct _IO_FILE *)g30);
        fputs_unlocked(gettext("  -n, --numeric-uid-gid      like -l, but list numeric user and group IDs\n  -N, --literal              print raw entry names (don't treat e.g. control\n                               characters specially)\n  -o                         like -l, but do not list group information\n  -p, --indicator-style=slash\n                             append / indicator to directories\n"), (struct _IO_FILE *)g30);
        fputs_unlocked(gettext("  -q, --hide-control-chars   print ? instead of non graphic characters\n      --show-control-chars   show non graphic characters as-is (default\n                             unless program is `ls' and output is a terminal)\n  -Q, --quote-name           enclose entry names in double quotes\n      --quoting-style=WORD   use quoting style WORD for entry names:\n                               literal, locale, shell, shell-always, c, escape\n"), (struct _IO_FILE *)g30);
        fputs_unlocked(gettext("  -r, --reverse              reverse order while sorting\n  -R, --recursive            list subdirectories recursively\n  -s, --size                 print the size of each file, in blocks\n"), (struct _IO_FILE *)g30);
        fputs_unlocked(gettext("  -S                         sort by file size\n      --sort=WORD            sort by WORD instead of name: none -U,\n                             extension -X, size -S, time -t, version -v\n      --time=WORD            with -l, show time as WORD instead of modification\n                             time: atime -u, access -u, use -u, ctime -c,\n                             or status -c; use specified time as sort key\n                             if --sort=time\n"), (struct _IO_FILE *)g30);
        fputs_unlocked(gettext("      --time-style=STYLE     with -l, show times using style STYLE:\n                             full-iso, long-iso, iso, locale, +FORMAT.\n                             FORMAT is interpreted like `date'; if FORMAT is\n                             FORMAT1<newline>FORMAT2, FORMAT1 applies to\n                             non-recent files and FORMAT2 to recent files;\n                             if STYLE is prefixed with `posix-', STYLE\n                             takes effect only outside the POSIX locale\n"), (struct _IO_FILE *)g30);
        fputs_unlocked(gettext("  -t                         sort by modification time\n  -T, --tabsize=COLS         assume tab stops at each COLS instead of 8\n"), (struct _IO_FILE *)g30);
        fputs_unlocked(gettext("  -u                         with -lt: sort by, and show, access time\n                               with -l: show access time and sort by name\n                               otherwise: sort by access time\n  -U                         do not sort; list entries in directory order\n  -v                         sort by version\n"), (struct _IO_FILE *)g30);
        fputs_unlocked(gettext("  -w, --width=COLS           assume screen width instead of current value\n  -x                         list entries by lines instead of by columns\n  -X                         sort alphabetically by entry extension\n  -Z, --context              print any SELinux security context of each file\n  -1                         list one file per line\n"), (struct _IO_FILE *)g30);
        fputs_unlocked(gettext("      --help     display this help and exit\n"), (struct _IO_FILE *)g30);
        fputs_unlocked(gettext("      --version  output version information and exit\n"), (struct _IO_FILE *)g30);
        fputs_unlocked(gettext("\nSIZE may be (or may be an integer optionally followed by) one of following:\nkB 1000, K 1024, MB 1000*1000, M 1024*1024, and so on for G, T, P, E, Z, Y.\n"), (struct _IO_FILE *)g30);
        fputs_unlocked(gettext("\nBy default, color is not used to distinguish types of files.  That is\nequivalent to using --color=none.  Using the --color option without the\noptional WHEN argument is equivalent to using --color=always.  With\n--color=auto, color codes are output only if standard output is connected\nto a terminal (tty).  The environment variable LS_COLORS can influence the\ncolors, and can be set easily by the dircolors command.\n"), (struct _IO_FILE *)g30);
        fputs_unlocked(gettext("\nExit status is 0 if OK, 1 if minor problems, 2 if serious trouble.\n"), (struct _IO_FILE *)g30);
        emit_bug_reporting_address();
    } else {
        // 0x8051069
        fprintf(g29, gettext("Try `%s --help' for more information.\n"));
    }
    // 0x80513a7
    exit(status);
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/src/system.h
// Address range: 0x80513b2 - 0x80513d6
// Line range:    575 - 581
void emit_bug_reporting_address(void) {
    // 0x80513b2
    printf(gettext("\nReport bugs to <%s>.\n"));
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/areadlink-with-size.c
// Address range: 0x80513d8 - 0x805150c
// Line range:    57 - 108
char * areadlink_with_size(char * file, uint32_t size) {
    int32_t size2 = size >= 1025 ? 1025 : size + 1;
    int32_t * mem = malloc(size2); // 0x8051430
    if (mem == NULL) {
        // 0x8051507
        return NULL;
    }
    uint32_t buf_size = size2;
    int32_t * v1 = mem;
    char * buf = (char *)mem;
    int32_t v2 = readlink(file, buf, buf_size); // 0x805145e
    char * result; // 0x80513d8
    int32_t v3; // 0x8051483
    if (v2 < 0) {
        // 0x8051472
        if (*__errno_location() != 34) {
            // 0x805147e
            v3 = *__errno_location();
            free(v1);
            *__errno_location() = v3;
            result = NULL;
            return result;
        }
    }
    while (v2 >= buf_size) {
        // 0x80514c4
        free(v1);
        int32_t size3; // 0x80513d8
        if (buf_size < 0x40000000) {
            // 0x80514d8
            size3 = 2 * buf_size;
        } else {
            // 0x80514e0
            size3 = 0x7fffffff;
            if (buf_size >= 0x7fffffff) {
                // 0x80514f5
                *__errno_location() = 12;
                result = NULL;
                return result;
            }
        }
        int32_t * mem2 = malloc(size3); // 0x8051430
        if (mem2 == NULL) {
            // 0x8051507
            result = NULL;
            return result;
        }
        buf_size = size3;
        v1 = mem2;
        buf = (char *)mem2;
        v2 = readlink(file, buf, buf_size);
        if (v2 < 0) {
            // 0x8051472
            if (*__errno_location() != 34) {
                // 0x805147e
                v3 = *__errno_location();
                free(v1);
                *__errno_location() = v3;
                result = NULL;
                return result;
            }
        }
    }
    // 0x80514b0
    *(char *)(v2 + (int32_t)buf) = 0;
    result = buf;
  lab_0x8051507_2:
    // 0x8051507
    return result;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/mbswidth.c
// Address range: 0x805150c - 0x8051537
// Line range:    52 - 54
int32_t gnu_mbswidth(char * string, int32_t flags) {
    // 0x805150c
    return mbsnwidth(string, strlen(string), flags);
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/mbswidth.c
// Address range: 0x8051537 - 0x805174d
// Line range:    63 - 175
int32_t mbsnwidth(char * string, int32_t nbytes, uint32_t flags) {
    int32_t v1 = (int32_t)string + nbytes; // 0x8051549
    char * v2 = (char *)v1;
    int32_t result; // 0x8051537
    if (__ctype_get_mb_cur_max() < 2) {
        // 0x805173a
        if (v2 <= string) {
            // 0x8051748
            return 0;
        }
        char * v3 = string; // 0x80516d8
        char * v4 = NULL;
        int16_t * v5 = *__ctype_b_loc(); // 0x80516e1
        int32_t v6 = 2 * (int32_t)*v3; // 0x80516e7
        int32_t v7; // 0x8051537
        int16_t v8; // 0x805171b
        if ((*(int16_t *)(v6 + (int32_t)v5) & 0x4000) == 0) {
            // 0x8051701
            if ((flags & 2) != 0) {
                // break -> 0x8051748
                break;
            }
            // 0x805170b
            v8 = *(int16_t *)(v6 + (int32_t)*__ctype_b_loc());
            v7 = (int32_t)((v8 & 2) == 0) + (int32_t)v4;
        } else {
            // 0x80516fb
            v7 = (int32_t)v4 + 1;
        }
        // 0x805173a
        v3 = (char *)((int32_t)v3 + 1);
        result = v7;
        while (v3 < v2) {
            // 0x80516cf
            v4 = (char *)v7;
            v5 = *__ctype_b_loc();
            v6 = 2 * (int32_t)*v3;
            if ((*(int16_t *)(v6 + (int32_t)v5) & 0x4000) == 0) {
                // 0x8051701
                result = -1;
                if ((flags & 2) != 0) {
                    // break -> 0x8051748
                    break;
                }
                // 0x805170b
                v8 = *(int16_t *)(v6 + (int32_t)*__ctype_b_loc());
                v7 = (int32_t)((v8 & 2) == 0) + (int32_t)v4;
            } else {
                // 0x80516fb
                v7 = (int32_t)v4 + 1;
            }
            // 0x805173a
            v3 = (char *)((int32_t)v3 + 1);
            result = v7;
        }
        // 0x8051748
        return result;
    }
    // 0x80516bb
    if (v2 <= string) {
        // 0x8051748
        return 0;
    }
    char * v9 = string; // 0x80516bb
    char * v10 = NULL; // 0x8051537
    int32_t v11; // 0x8051537
    char * wstr; // 0x80515a4
    char * v12; // 0x8051537
    int32_t v13; // 0x8051537
    while (true) {
      lab_0x8051568:
        // 0x8051568
        v12 = v10;
        wstr = v9;
        char v14 = *wstr; // 0x805156b
        int32_t v15 = v14; // 0x805156e
        if (v14 > 95) {
            if (v15 < 127) {
                // 0x80515a4
                v11 = (int32_t)wstr + 1;
                v13 = (int32_t)v12 + 1;
                goto lab_0x80516bb;
            } else {
                goto lab_0x80515b1;
            }
        } else {
            if (v14 > 64) {
                // 0x80515a4
                v11 = (int32_t)wstr + 1;
                v13 = (int32_t)v12 + 1;
                goto lab_0x80516bb;
            } else {
                if (v14 < 32) {
                    goto lab_0x80515b1;
                } else {
                    if (v14 < 36 || v15 < 64) {
                        // 0x80515a4
                        v11 = (int32_t)wstr + 1;
                        v13 = (int32_t)v12 + 1;
                        goto lab_0x80516bb;
                    } else {
                        goto lab_0x80515b1;
                    }
                }
            }
        }
    }
  lab_0x8051748_3:
    // 0x8051748
    return result;
  lab_0x80516bb:
    // 0x80516bb
    v9 = (char *)v11;
    v10 = (char *)v13;
    result = v13;
    if (v9 >= v2) {
        return result;
    }
    goto lab_0x8051568;
  lab_0x80515b1:;
    // 0x80515b1
    int32_t ps; // bp-40, 0x8051537
    memset(&ps, 0, 8);
    char * v16 = v12;
    int32_t v17 = (int32_t)wstr;
    char * plimit; // bp-24, 0x8051537
    int32_t v18 = mbrtowc((int32_t *)&plimit, wstr, v1 - v17, (struct _TYPEDEF___mbstate_t *)&ps); // 0x80515f2
    while (v18 != -1) {
        if (v18 == -2) {
            // 0x8051629
            result = -1;
            if (flags % 2 != 0) {
                goto lab_0x8051748_3;
            } else {
                // 0x80516bb
                result = (int32_t)v16 + 1;
                goto lab_0x8051748_3;
            }
        }
        int32_t v19 = wcwidth((int32_t)plimit); // 0x805165e
        int32_t v20; // 0x8051537
        if (v19 < 0) {
            // 0x8051674
            result = -1;
            if ((flags & 2) != 0) {
                // break (via goto) -> 0x8051748
                goto lab_0x8051748_3;
            }
            // 0x805167e
            v20 = (int32_t)(iswcntrl((int32_t)plimit) == 0) + (int32_t)v16;
        } else {
            // 0x805166c
            v20 = v19 + (int32_t)v16;
        }
        int32_t v21 = (v18 != 0 ? v18 : 1) + v17; // 0x80516a5
        int32_t v22 = mbsinit((struct _TYPEDEF___mbstate_t *)&ps); // 0x80516ae
        v11 = v21;
        v13 = v20;
        char * wstr2 = (char *)v21; // 0x80516b5
        char * v23 = (char *)v20; // 0x80516b5
        if (v22 != 0) {
            goto lab_0x80516bb;
        }
        v16 = v23;
        v17 = (int32_t)wstr2;
        v18 = mbrtowc((int32_t *)&plimit, wstr2, v1 - v17, (struct _TYPEDEF___mbstate_t *)&ps);
    }
    // 0x8051600
    result = -1;
    if (flags % 2 != 0) {
        // break -> 0x8051748
        goto lab_0x8051748_3;
    }
    // 0x805160a
    v11 = v17 + 1;
    v13 = (int32_t)v16 + 1;
    goto lab_0x80516bb;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/version-etc.c
// Address range: 0x8051750 - 0x80519af
// Line range:    43 - 147
void version_etc_va(struct _IO_FILE * stream, char * command_name, char * package, char * version, char * authors) {
    int32_t v1 = 0; // 0x8051779
    if (*(int32_t *)authors != 0) {
        int32_t v2 = 0; // 0x8051766
        int32_t v3 = (int32_t)authors; // 0x805176d
        v3 += 4;
        v2++;
        v1 = v2;
        while (*(int32_t *)v3 != 0) {
            // 0x8051766
            v3 += 4;
            v2++;
            v1 = v2;
        }
    }
    // 0x805177b
    if (command_name == NULL) {
        // 0x80517ab
        fprintf(stream, "%s %s\n", package, version);
    } else {
        // 0x8051781
        fprintf(stream, "%s (%s) %s\n", command_name, package, version);
    }
    // 0x80517cc
    fprintf(stream, "Copyright %s %d Free Software Foundation, Inc.", gettext("(C)"), 2008);
    fputs_unlocked(gettext("\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n\n"), stream);
    g55 = v1;
    switch (v1) {
        case 0: {
            // 0x805182c
            abort();
            // UNREACHABLE
        }
        case 1: {
            // 0x8051831
            rpl_vfprintf(stream, gettext("Written by %s.\n"), authors);
            // 0x80519a9
            return;
        }
        case 2: {
            // 0x8051858
            rpl_vfprintf(stream, gettext("Written by %s and %s.\n"), authors);
            // 0x80519a9
            return;
        }
        case 3: {
            // 0x805187f
            rpl_vfprintf(stream, gettext("Written by %s, %s, and %s.\n"), authors);
            // 0x80519a9
            return;
        }
        case 4: {
            // 0x80518a6
            rpl_vfprintf(stream, gettext("Written by %s, %s, %s,\nand %s.\n"), authors);
            // 0x80519a9
            return;
        }
        case 5: {
            // 0x80518cd
            rpl_vfprintf(stream, gettext("Written by %s, %s, %s,\n%s, and %s.\n"), authors);
            // 0x80519a9
            return;
        }
        case 6: {
            // 0x80518f4
            rpl_vfprintf(stream, gettext("Written by %s, %s, %s,\n%s, %s, and %s.\n"), authors);
            // 0x80519a9
            return;
        }
        case 7: {
            // 0x805191b
            rpl_vfprintf(stream, gettext("Written by %s, %s, %s,\n%s, %s, %s, and %s.\n"), authors);
            // 0x80519a9
            return;
        }
        case 8: {
            // 0x805193f
            rpl_vfprintf(stream, gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n"), authors);
            // 0x80519a9
            return;
        }
        case 9: {
            // 0x8051963
            rpl_vfprintf(stream, gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n"), authors);
            // 0x80519a9
            return;
        }
    }
    // 0x8051987
    rpl_vfprintf(stream, gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n"), authors);
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/version-etc.c
// Address range: 0x80519af - 0x80519e4
// Line range:    167 - 172
void version_etc(struct _IO_FILE * stream, char * command_name, char * package, char * version, ...) {
    // 0x80519af
    int32_t v1; // bp+20, 0x80519af
    version_etc_va(stream, command_name, package, version, (char *)&v1);
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/xalloc-die.c
// Address range: 0x80519e4 - 0x8051a1d
// Line range:    33 - 40
void xalloc_die(void) {
    // 0x80519e4
    error(exit_failure, 0, "%s", gettext("memory exhausted"));
    abort();
    // UNREACHABLE
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/argmatch.c
// Address range: 0x8051a34 - 0x8051b1c
// Line range:    85 - 122
int32_t argmatch(char * arg, char ** arglist, char * vallist, int32_t valsize) {
    int32_t len = strlen(arg); // 0x8051a4b
    char * v1 = *arglist;
    if (v1 == NULL) {
        // 0x8051b17
        return -1;
    }
    int32_t v2 = (int32_t)vallist;
    int32_t str = (int32_t)v1; // 0x8051af8
    int32_t * str2 = (int32_t *)arglist; // 0x8051a34
    int32_t v3 = 0; // 0x8051aeb
    int32_t result2 = -1;
    char v4 = 0;
    int32_t v5; // 0x8051a34
    char v6; // 0x8051a34
    int32_t v7; // 0x8051a34
    while (true) {
      lab_0x8051a5f:;
        char v8 = v4;
        int32_t v9 = result2;
        v7 = v3;
        v6 = v8;
        v5 = v9;
        if (strncmp((char *)str, arg, len) != 0) {
            goto lab_0x8051aeb;
        } else {
            int32_t result = v7; // 0x8051a9a
            if (strlen((char *)*str2) == len) {
                // 0x8051b17
                return result;
            }
            // 0x8051aa4
            v6 = v8;
            v5 = v7;
            if (v9 != -1) {
                if (vallist == NULL) {
                    // 0x8051ae7
                    v6 = 1;
                    v5 = v9;
                    goto lab_0x8051aeb;
                } else {
                    int32_t memcmp_rc = memcmp((int32_t *)(v9 * valsize + v2), (int32_t *)(v7 * valsize + v2), valsize); // 0x8051ade
                    v6 = v8;
                    v5 = v9;
                    if (memcmp_rc == 0) {
                        goto lab_0x8051aeb;
                    } else {
                        // 0x8051ae7
                        v6 = 1;
                        v5 = v9;
                        goto lab_0x8051aeb;
                    }
                }
            } else {
                goto lab_0x8051aeb;
            }
        }
    }
  lab_0x8051b02:
    // 0x8051b02
    if (v4 != 0) {
        // 0x8051b17
        return -2;
    }
    // 0x8051b17
    return result2;
  lab_0x8051aeb:
    // 0x8051aeb
    result2 = v5;
    v4 = v6;
    v3 = v7 + 1;
    int32_t * v10 = (int32_t *)(4 * v3 + (int32_t)arglist); // 0x8051af8
    str = *v10;
    str2 = v10;
    if (str == 0) {
        // break -> 0x8051b02
        goto lab_0x8051b02;
    }
    goto lab_0x8051a5f;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/argmatch.c
// Address range: 0x8051b1c - 0x8051ba8
// Line range:    131 - 138
void argmatch_invalid(char * context, char * value, int32_t problem) {
    char * format2; // 0x8051b1c
    if (problem != -1) {
        // 0x8051b3a
        format2 = gettext("ambiguous argument %s for %s");
    } else {
        // 0x8051b29
        format2 = gettext("invalid argument %s for %s");
    }
    // 0x8051b49
    quote_n(1, context);
    quotearg_n_style(0, 5, value);
    error(0, 0, format2);
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/argmatch.c
// Address range: 0x8051ba8 - 0x8051c92
// Line range:    147 - 166
void argmatch_valid(char ** arglist, char * vallist, int32_t valsize) {
    // 0x8051ba8
    fprintf(g29, gettext("Valid arguments are:"));
    char * v1 = *arglist;
    if (v1 == NULL) {
        // 0x8051c7b
        putc_unlocked(10, g29);
        return;
    }
    int32_t v2 = (int32_t)v1; // 0x8051c71
    int32_t * v3 = (int32_t *)arglist; // 0x8051ba8
    int32_t v4 = 0; // 0x8051c64
    int32_t v5 = 0; // 0x8051ba8
    int32_t str; // 0x8051ba8
    int32_t v6; // 0x8051ba8
    int32_t v7; // 0x8051ba8
    while (true) {
      lab_0x8051bdf:
        // 0x8051bdf
        str = v4 * valsize + (int32_t)vallist;
        v6 = v2;
        if (v4 == 0) {
            goto lab_0x8051c0b;
        } else {
            int32_t v8 = v5;
            int32_t memcmp_rc = memcmp(&((struct _IO_FILE *)v8)->e0, (int32_t *)str, valsize); // 0x8051c02
            int32_t v9 = *v3;
            v6 = v9;
            if (memcmp_rc == 0) {
                // 0x8051c3f
                fprintf(g29, ", `%s'", (char *)v9);
                v7 = v8;
                goto lab_0x8051c64;
            } else {
                goto lab_0x8051c0b;
            }
        }
    }
  lab_0x8051c7b:
    // 0x8051c7b
    putc_unlocked(10, g29);
  lab_0x8051c0b:
    // 0x8051c0b
    fprintf(g29, "\n  - `%s'", (char *)v6);
    v7 = str;
    goto lab_0x8051c64;
  lab_0x8051c64:
    // 0x8051c64
    v4++;
    int32_t * v10 = (int32_t *)(4 * v4 + (int32_t)arglist); // 0x8051c71
    v2 = *v10;
    v3 = v10;
    v5 = v7;
    if (v2 == 0) {
        // break -> 0x8051c7b
        goto lab_0x8051c7b;
    }
    goto lab_0x8051bdf;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/argmatch.c
// Address range: 0x8051c92 - 0x8051d0c
// Line range:    179 - 191
int32_t __xargmatch_internal(char * context, char * arg, char ** arglist, char * vallist, int32_t valsize, void (*exit_fn)()) {
    int32_t v1 = argmatch(arg, arglist, vallist, valsize); // 0x8051cb3
    int32_t result = v1; // 0x8051cbf
    if (v1 < 0) {
        // 0x8051cc9
        argmatch_invalid(context, arg, v1);
        argmatch_valid(arglist, vallist, valsize);
        result = -1;
    }
    // 0x8051d07
    return result;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/basename.c
// Address range: 0x8051d70 - 0x8051dcb
// Line range:    33 - 53
char * last_component(char * name) {
    char v1 = *name; // 0x8051d89
    char v2 = v1; // 0x8051d8e
    char * result = name; // 0x8051d8e
    int32_t v3 = (int32_t)name; // 0x8051d8e
    if (v1 == 47) {
        int32_t v4 = (int32_t)name + 1; // 0x8051d82
        char * v5 = (char *)v4;
        char v6 = *v5; // 0x8051d89
        v2 = v6;
        result = v5;
        v3 = v4;
        while (v6 == 47) {
            // 0x8051d82
            v4 = (int32_t)v5 + 1;
            v5 = (char *)v4;
            v6 = *v5;
            v2 = v6;
            result = v5;
            v3 = v4;
        }
    }
    // 0x8051d90
    if (v2 == 0) {
        // 0x8051dc6
        return result;
    }
    int32_t v7 = v3;
    int32_t v8 = v2 != 47 ? v7 : v7;
    int32_t v9 = (int32_t)result + 1; // 0x8051db8
    char * v10 = (char *)v9; // 0x8051db8
    char v11 = *v10; // 0x8051dbf
    char v12 = v2 == 47; // 0x8051dc4
    while (v11 != 0) {
        char v13 = v11;
        v7 = v8;
        v8 = v13 != 47 ? v12 == 0 ? v7 : v9 : v7;
        v9 = (int32_t)v10 + 1;
        v10 = (char *)v9;
        v11 = *v10;
        v12 = v13 == 47;
    }
    // 0x8051dc6
    return (char *)v8;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/basename.c
// Address range: 0x8051e43 - 0x8051e7f
// Line range:    112 - 128
int32_t base_len(char * name) {
    uint32_t len = strlen(name);
    while (len >= 2) {
        int32_t v1 = len - 1; // 0x8051e6d
        if (*(char *)(v1 + (int32_t)name) != 47) {
            // break -> 0x8051e7a
            break;
        }
        len = v1;
    }
    // 0x8051e7a
    return len;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/file-has-acl.c
// Address range: 0x8051f54 - 0x8051f5e
// Line range:    32 - 86
int32_t file_has_acl(char * name, int32_t * sb) {
    // 0x8051f54
    return 0;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/filemode.c
// Address range: 0x8051f60 - 0x8052006
// Line range:    55 - 91
char ftypelet(int32_t bits) {
    int32_t v1 = bits & 0xf000; // 0x8051f69
    if (v1 == 0x8000) {
        // 0x8052000
        return 45;
    }
    // 0x8051f7e
    if (v1 == 0x4000) {
        // 0x8052000
        return 100;
    }
    // 0x8051f93
    if (v1 == 0x6000) {
        // 0x8052000
        return 98;
    }
    // 0x8051fa8
    if (v1 == 0x2000) {
        // 0x8052000
        return 99;
    }
    // 0x8051fbd
    if (v1 == 0xa000) {
        // 0x8052000
        return 108;
    }
    char result = 112; // 0x8051fdf
    if (v1 != 0x1000) {
        // 0x8051fe7
        result = v1 != 0xc000 ? 63 : 115;
    }
    // 0x8052000
    return result;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/filemode.c
// Address range: 0x8052006 - 0x805221c
// Line range:    97 - 116
void strmode(uint32_t mode, char * str) {
    int32_t v1 = (int32_t)str;
    *str = ftypelet(mode);
    *(char *)(v1 + 1) = (mode & 256) == 0 ? 45 : 114;
    *(char *)(v1 + 2) = (char)mode > -1 ? 45 : 119;
    char v2 = (mode & 2048) == 0 ? (mode & 64) == 0 ? 45 : 120 : (mode & 64) == 0 ? 83 : 115;
    *(char *)(v1 + 3) = v2;
    *(char *)(v1 + 4) = (mode & 32) == 0 ? 45 : 114;
    *(char *)(v1 + 5) = (mode & 16) == 0 ? 45 : 119;
    char v3 = (mode & 1024) == 0 ? (mode & 8) == 0 ? 45 : 120 : (mode & 8) == 0 ? 83 : 115;
    *(char *)(v1 + 6) = v3;
    *(char *)(v1 + 7) = (mode & 4) == 0 ? 45 : 114;
    *(char *)(v1 + 8) = (mode & 2) == 0 ? 45 : 119;
    char v4 = (mode & 512) == 0 ? mode % 2 == 0 ? 45 : 120 : mode % 2 == 0 ? 84 : 116;
    *(char *)(v1 + 9) = v4;
    *(char *)(v1 + 10) = 32;
    *(char *)(v1 + 11) = 0;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/filemode.c
// Address range: 0x805221c - 0x8052239
// Line range:    167 - 180
void filemodestring(int32_t * statp, char * str) {
    // 0x805221c
    strmode(*(int32_t *)((int32_t)statp + 16), str);
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/filenamecat.c
// Address range: 0x805223c - 0x8052254
// Line range:    40 - 44
char * longest_relative_suffix(char * f) {
    // 0x805223c
    if (*f != 47) {
        // 0x805224f
        return f;
    }
    char * result = f; // 0x805224d
    result = (char *)((int32_t)result + 1);
    while (*result == 47) {
        // 0x8052241
        result = (char *)((int32_t)result + 1);
    }
    // 0x805224f
    return result;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/filenamecat.c
// Address range: 0x8052254 - 0x805236d
// Line range:    63 - 89
char * mfile_name_concat(char * dir, char * abase, char ** base_in_result) {
    char * v1 = last_component(dir); // 0x8052260
    int32_t v2 = (int32_t)v1; // 0x8052260
    int32_t v3 = base_len(v1); // 0x805226e
    int32_t v4; // 0x8052254
    if (v3 == 0) {
        // 0x80522a7
        v4 = 0;
        goto lab_0x80522ae;
    } else {
        // 0x805228e
        v4 = 1;
        if (*(char *)(v3 - 1 + v2) == 47) {
            // 0x80522a7
            v4 = 0;
            goto lab_0x80522ae;
        } else {
            goto lab_0x80522ae;
        }
    }
  lab_0x80522ae:;
    int32_t v5 = v2 - (int32_t)dir + v3; // 0x8052282
    char * str = longest_relative_suffix(abase); // 0x80522ba
    int32_t len = strlen(str); // 0x80522c8
    int32_t * mem = malloc(v5 + 1 + v4 + len); // 0x80522e1
    if (mem == NULL) {
        // 0x8052368
        return NULL;
    }
    int32_t * v6 = mempcpy(mem, (int32_t *)dir, v5); // 0x805230c
    *(char *)v6 = 47;
    int32_t v7 = v4 + (int32_t)v6; // 0x805231d
    if (base_in_result != NULL) {
        // 0x8052326
        *(int32_t *)base_in_result = v7 + (int32_t)(*abase == 47);
    }
    // 0x8052340
    *(char *)mempcpy((int32_t *)v7, (int32_t *)str, len) = 0;
    // 0x8052368
    return (char *)mem;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/filenamecat.c
// Address range: 0x805236d - 0x805239f
// Line range:    97 - 102
char * file_name_concat(char * dir, char * abase, char ** base_in_result) {
    char * result = mfile_name_concat(dir, abase, base_in_result); // 0x8052387
    if (result != NULL) {
        // 0x805239a
        return result;
    }
    // 0x8052395
    xalloc_die();
    // UNREACHABLE
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/hard-locale.c
// Address range: 0x80523a0 - 0x80523fe
// Line range:    37 - 70
bool hard_locale(int32_t category) {
    char * locale = setlocale(category, NULL); // 0x80523b8
    if (locale == NULL) {
        // 0x80523f8
        return true;
    }
    // 0x80523c6
    if (strcmp(locale, "C") == 0) {
        // 0x80523f8
        return false;
    }
    // 0x80523dd
    if (strcmp(locale, "POSIX") != 0) {
        // 0x80523f8
        return true;
    }
    // 0x80523f8
    return false;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/hash.c
// Address range: 0x8052416 - 0x8052421
// Line range:    164 - 166
int32_t hash_get_n_entries(int32_t * table) {
    // 0x8052416
    return *(int32_t *)((int32_t)table + 16);
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/hash.c
// Address range: 0x80528aa - 0x805290d
// Line range:    435 - 447
bool is_prime(uint32_t candidate) {
    int32_t v1 = 3; // 0x80528da
    if (candidate <= 9) {
        // 0x80528f3
        return candidate % 3 != 0;
    }
    int32_t v2 = 9; // 0x80528da
    while (candidate % v1 != 0) {
        // 0x80528c3
        v2 = v2 + 4 + 4 * v1;
        v1 += 2;
        if (v2 >= candidate) {
            // break -> 0x80528f3
            break;
        }
    }
    // 0x80528f3
    return candidate % v1 != 0;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/hash.c
// Address range: 0x805290d - 0x8052941
// Line range:    454 - 466
int32_t next_prime(uint32_t candidate) {
    int32_t v1 = (candidate > 10 ? candidate : 10) | 1; // 0x8052924
    while (true) {
        // 0x805292a
        is_prime(v1);
        v1 += 2;
    }
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/hash.c
// Address range: 0x8052978 - 0x8052a2a
// Line range:    482 - 503
bool check_tuning(int32_t * table) {
    int32_t * v1 = (int32_t *)((int32_t)table + 20); // 0x8052981
    int32_t v2 = *v1; // 0x8052981
    float32_t * v3 = (float32_t *)(v2 + 8); // 0x8052992
    int3_t v4; // 0x8052978
    int3_t v5 = v4 - 1; // 0x8052992
    __frontend_reg_store_fpr(v5, (float80_t)*v3);
    int3_t v6 = v4 - 2; // 0x8052995
    __frontend_reg_store_fpr(v6, 0.1L);
    float80_t v7 = __frontend_reg_load_fpr(v6); // 0x8052998
    __frontend_reg_store_fpr(v6, __frontend_reg_load_fpr(v5));
    __frontend_reg_store_fpr(v5, v7);
    __frontend_reg_load_fpr(v6);
    __frontend_reg_load_fpr(v5);
    int32_t v8; // 0x8052978
    if ((v8 & 0x4100) != 0) {
        // 0x8052a16
        *v1 = (int32_t)&default_tuning;
        // 0x8052a24
        return false;
    }
    float32_t * v9 = (float32_t *)v2; // 0x8052984
    __frontend_reg_store_fpr(v5, (float80_t)*v3);
    __frontend_reg_store_fpr(v6, 1.0L);
    __frontend_reg_store_fpr(v6, __frontend_reg_load_fpr(v6) - 0.1L);
    __frontend_reg_load_fpr(v6);
    __frontend_reg_load_fpr(v5);
    __frontend_reg_store_fpr(v5, 0.1L);
    __frontend_reg_store_fpr(v6, 1.0L);
    __frontend_reg_store_fpr(v5, __frontend_reg_load_fpr(v6) + __frontend_reg_load_fpr(v5));
    __frontend_reg_store_fpr(v6, (float80_t)*(float32_t *)(v2 + 12));
    __frontend_reg_load_fpr(v6);
    __frontend_reg_load_fpr(v5);
    __frontend_reg_store_fpr(v5, (float80_t)*v9);
    __frontend_reg_store_fpr(v6, 0.0L);
    float80_t v10 = __frontend_reg_load_fpr(v6); // 0x80529ce
    __frontend_reg_store_fpr(v6, __frontend_reg_load_fpr(v5));
    __frontend_reg_store_fpr(v5, v10);
    __frontend_reg_load_fpr(v6);
    __frontend_reg_load_fpr(v5);
    if ((v8 & 256) != 0) {
        // 0x8052a16
        *v1 = (int32_t)&default_tuning;
        // 0x8052a24
        return false;
    }
    // 0x80529fb
    __frontend_reg_store_fpr(v5, (float80_t)*v9);
    __frontend_reg_store_fpr(v5, __frontend_reg_load_fpr(v5) + 0.1L);
    float32_t * v11 = (float32_t *)(v2 + 4); // 0x80529e2
    __frontend_reg_store_fpr(v6, (float80_t)*v11);
    __frontend_reg_load_fpr(v6);
    __frontend_reg_load_fpr(v5);
    __frontend_reg_store_fpr(v5, (float80_t)*v11);
    __frontend_reg_store_fpr(v6, 1.0L);
    __frontend_reg_load_fpr(v6);
    __frontend_reg_load_fpr(v5);
    __frontend_reg_store_fpr(v5, (float80_t)*v9);
    __frontend_reg_store_fpr(v5, __frontend_reg_load_fpr(v5) + 0.1L);
    __frontend_reg_store_fpr(v6, (float80_t)*v3);
    __frontend_reg_load_fpr(v6);
    __frontend_reg_load_fpr(v5);
    // 0x8052a24
    return true;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/hash.c
// Address range: 0x8052a2a - 0x8052bb8
// Line range:    540 - 597
int32_t * hash_initialize(int32_t candidate, int32_t * tuning, int32_t (*hasher)(int32_t *, int32_t), bool (*comparator)(int32_t *, int32_t *), void (*data_freer)(char *)) {
    if (hasher != NULL != comparator != NULL) {
        // 0x8052bb3
        return NULL;
    }
    int32_t * mem = malloc(40); // 0x8052a4f
    if (mem != NULL) {
        int32_t v1 = tuning != NULL ? (int32_t)tuning : (int32_t)&default_tuning;
        *(int32_t *)((int32_t)mem + 20) = v1;
        check_tuning(mem);
        free(mem);
    }
    // 0x8052bb3
    return NULL;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/hash.c
// Address range: 0x8052c86 - 0x8052d72
// Line range:    648 - 696
void hash_free(int32_t * table) {
    int32_t v1 = (int32_t)table;
    if (*(int32_t *)(v1 + 32) != 0) {
        // 0x8052c96
        if (*(int32_t *)(v1 + 16) != 0) {
            uint32_t v2 = *table; // 0x8052ca3
            uint32_t v3 = *(int32_t *)(v1 + 4); // 0x8052ce1
            if (v3 > v2) {
                int32_t v4 = v2;
                int32_t v5 = v4; // 0x8052cb1
                int32_t v6; // 0x8052cce
                if (*(int32_t *)v4 != 0 == (v4 != 0)) {
                    v6 = *(int32_t *)(v5 + 4);
                    v5 = v6;
                    while (v6 != 0) {
                        // 0x8052cbb
                        v6 = *(int32_t *)(v5 + 4);
                        v5 = v6;
                    }
                }
                int32_t v7 = v4 + 8; // 0x8052cda
                while (v3 > v7) {
                    // 0x8052caa
                    v4 = v7;
                    v5 = v4;
                    if (*(int32_t *)v4 != 0 == (v4 != 0)) {
                        v6 = *(int32_t *)(v5 + 4);
                        v5 = v6;
                        while (v6 != 0) {
                            // 0x8052cbb
                            v6 = *(int32_t *)(v5 + 4);
                            v5 = v6;
                        }
                    }
                    // 0x8052cda
                    v7 = v4 + 8;
                }
            }
        }
    }
    uint32_t v8 = *table; // 0x8052cec
    int32_t * v9 = (int32_t *)(v1 + 4); // 0x8052d25
    uint32_t v10 = *v9; // 0x8052d25
    int32_t v11 = v8; // 0x8052d2b
    if (v10 > v8) {
        int32_t v12 = *(int32_t *)(v11 + 4); // 0x8052cf6
        int32_t v13 = v12; // 0x8052d1c
        int32_t v14 = v10; // 0x8052d1c
        int32_t v15; // 0x8052d01
        if (v12 != 0) {
            v15 = *(int32_t *)(v13 + 4);
            free((int32_t *)v13);
            v13 = v15;
            while (v15 != 0) {
                // 0x8052cfe
                v15 = *(int32_t *)(v13 + 4);
                free((int32_t *)v13);
                v13 = v15;
            }
            // 0x8052d18
            v14 = *v9;
        }
        int32_t v16 = v14; // 0x8052d25
        v11 += 8;
        while (v16 > v11) {
            // 0x8052cf3
            v12 = *(int32_t *)(v11 + 4);
            v13 = v12;
            v14 = v16;
            if (v12 != 0) {
                v15 = *(int32_t *)(v13 + 4);
                free((int32_t *)v13);
                v13 = v15;
                while (v15 != 0) {
                    // 0x8052cfe
                    v15 = *(int32_t *)(v13 + 4);
                    free((int32_t *)v13);
                    v13 = v15;
                }
                // 0x8052d18
                v14 = *v9;
            }
            // 0x8052d1e
            v16 = v14;
            v11 += 8;
        }
    }
    int32_t v17 = *(int32_t *)(v1 + 36); // 0x8052d30
    if (v17 == 0) {
        // 0x8052d58
        free((int32_t *)*table);
        free(table);
        return;
    }
    int32_t v18 = *(int32_t *)(v17 + 4); // 0x8052d3b
    free((int32_t *)v17);
    while (v18 != 0) {
        int32_t v19 = v18;
        v18 = *(int32_t *)(v19 + 4);
        free((int32_t *)v19);
    }
    // 0x8052d58
    free((int32_t *)*table);
    free(table);
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/hash.c
// Address range: 0x8052d72 - 0x8052dad
// Line range:    705 - 723
int32_t * allocate_entry(int32_t * table) {
    int32_t * v1 = (int32_t *)((int32_t)table + 36); // 0x8052d7b
    int32_t v2 = *v1; // 0x8052d7b
    int32_t mem; // 0x8052d72
    if (v2 == 0) {
        // 0x8052d99
        mem = (int32_t)malloc(8);
    } else {
        // 0x8052d82
        *v1 = *(int32_t *)(v2 + 4);
        mem = v2;
    }
    // 0x8052da8
    return (int32_t *)mem;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/hash.c
// Address range: 0x8052dad - 0x8052dd0
// Line range:    730 - 734
void free_entry(int32_t * table, int32_t * entry) {
    int32_t v1 = (int32_t)entry;
    *entry = 0;
    int32_t * v2 = (int32_t *)((int32_t)table + 36); // 0x8052dbc
    *(int32_t *)(v1 + 4) = *v2;
    *v2 = v1;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/hash.c
// Address range: 0x8052dd0 - 0x8052f2d
// Line range:    745 - 807
char * hash_find_entry(int32_t * table, int32_t * entry, int32_t ** bucket_head, bool delete) {
    int32_t v1 = (int32_t)entry;
    int32_t v2 = *table + 8 * v1; // 0x8052dfd
    if (*(int32_t *)((int32_t)table + 4) <= v2) {
        // 0x8052e0e
        abort();
        // UNREACHABLE
    }
    // 0x8052e13
    *(int32_t *)bucket_head = v2;
    int32_t * v3 = (int32_t *)v2; // 0x8052e1e
    int32_t v4 = *v3; // 0x8052e1e
    if (v4 == 0) {
        // 0x8052f24
        return NULL;
    }
    int32_t v5 = v2; // 0x8052e49
    if ((char)v1 == 0) {
        v5 += 4;
        while (v5 != 0) {
            // 0x8052f13
            v5 += 4;
        }
        // 0x8052f24
        return NULL;
    }
    if (delete) {
        int32_t * v6 = (int32_t *)(v2 + 4); // 0x8052e5c
        int32_t v7 = *v6; // 0x8052e5c
        if (v7 == 0) {
            // 0x8052e90
            *v3 = 0;
        } else {
            int32_t * v8 = (int32_t *)v7; // 0x8052e69
            *v3 = *v8;
            *v6 = *(int32_t *)(v7 + 4);
            free_entry(table, v8);
        }
    }
    // 0x8052f24
    return (char *)v4;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/hash.c
// Address range: 0x8052f2d - 0x8053109
// Line range:    819 - 900
bool hash_rehash(int32_t * table, int32_t candidate) {
    int32_t v1 = (int32_t)table;
    int32_t v2 = *(int32_t *)(v1 + 32); // 0x8052f37
    int32_t v3 = *(int32_t *)(v1 + 28); // 0x8052f3d
    int32_t v4 = *(int32_t *)(v1 + 24); // 0x8052f43
    int32_t v5 = *(int32_t *)(v1 + 20); // 0x8052f49
    int32_t * v6 = hash_initialize(candidate, (int32_t *)v5, (int32_t (*)(int32_t *, int32_t))v4, (bool (*)(int32_t *, int32_t *))v3, (void (*)(char *))v2); // 0x8052f62
    if (v6 == NULL) {
        // 0x80530ff
        return false;
    }
    int32_t v7 = (int32_t)v6; // 0x8052f62
    int32_t * v8 = (int32_t *)(v1 + 36); // 0x8052f7c
    int32_t * v9 = (int32_t *)(v7 + 36); // 0x8052f82
    *v9 = *v8;
    uint32_t v10 = *table; // 0x8052f88
    int32_t * v11 = (int32_t *)v10;
    int32_t * v12 = (int32_t *)(v1 + 4); // 0x805309d
    int32_t * v13; // 0x8052f2d
    int32_t * v14; // 0x8052f2d
    int32_t * v15; // 0x8052f2d
    if (*v12 > v10) {
        int32_t * v16 = (int32_t *)(v7 + 4);
        int32_t * v17 = (int32_t *)(v7 + 12);
        int32_t v18; // 0x8052f2d
        int32_t * bucket; // bp-24, 0x8052f2d
        int32_t * new_table; // bp-20, 0x8052f2d
        int32_t * v19; // 0x8052ffa
        int32_t v20; // 0x8052fad
        uint32_t v21; // 0x8052fd2
        int32_t * v22; // 0x8052fd5
        int32_t * v23; // 0x8052feb
        int32_t v24; // 0x8052f2d
        int32_t * v25; // 0x8053041
        int32_t * v26; // 0x8053008
        int32_t v27; // 0x8053008
        int32_t * v28; // 0x805302a
        if (*v11 != 0) {
            // 0x8052f9f
            *(int32_t *)&new_table = v10;
            if (v10 != 0) {
                v19 = (int32_t *)v10;
                v20 = *v19;
                v21 = *v6 + 8 * v20;
                if (*v16 <= v21) {
                    // 0x8052fe3
                    abort();
                    // UNREACHABLE
                }
                // 0x8052fe8
                v22 = (int32_t *)v21;
                v23 = (int32_t *)(v10 + 4);
                bucket = (int32_t *)*v23;
                if (*v22 == 0) {
                    // 0x8053055
                    *v22 = v20;
                    *v17 = *v17 + 1;
                    if (new_table != v11) {
                        // 0x8053074
                        free_entry(v6, new_table);
                    }
                } else {
                    if (v11 != v19) {
                        // 0x805303e
                        v25 = (int32_t *)(v21 + 4);
                        *v23 = *v25;
                        *v25 = (int32_t)new_table;
                    } else {
                        // 0x8053002
                        v26 = allocate_entry(v6);
                        if (v26 == NULL) {
                            // 0x80530ff
                            return false;
                        }
                        // 0x805301f
                        v27 = (int32_t)v26;
                        *v26 = v20;
                        v28 = (int32_t *)(v21 + 4);
                        *(int32_t *)(v27 + 4) = *v28;
                        *v28 = v27;
                    }
                }
                // 0x8053086
                v24 = (int32_t)bucket;
                *(int32_t *)&new_table = v24;
                v18 = v24;
                while (bucket != NULL) {
                    // 0x8052faa
                    v19 = (int32_t *)v18;
                    v20 = *v19;
                    v21 = *v6 + 8 * v20;
                    if (*v16 <= v21) {
                        // 0x8052fe3
                        abort();
                        // UNREACHABLE
                    }
                    // 0x8052fe8
                    v22 = (int32_t *)v21;
                    v23 = (int32_t *)(v18 + 4);
                    bucket = (int32_t *)*v23;
                    if (*v22 == 0) {
                        // 0x8053055
                        *v22 = v20;
                        *v17 = *v17 + 1;
                        if (new_table != v11) {
                            // 0x8053074
                            free_entry(v6, new_table);
                        }
                    } else {
                        if (v11 != v19) {
                            // 0x805303e
                            v25 = (int32_t *)(v21 + 4);
                            *v23 = *v25;
                            *v25 = (int32_t)new_table;
                        } else {
                            // 0x8053002
                            v26 = allocate_entry(v6);
                            if (v26 == NULL) {
                                // 0x80530ff
                                return false;
                            }
                            // 0x805301f
                            v27 = (int32_t)v26;
                            *v26 = v20;
                            v28 = (int32_t *)(v21 + 4);
                            *(int32_t *)(v27 + 4) = *v28;
                            *v28 = v27;
                        }
                    }
                    // 0x8053086
                    v24 = (int32_t)bucket;
                    *(int32_t *)&new_table = v24;
                    v18 = v24;
                }
            }
        }
        int32_t v29 = (int32_t)v11 + 8; // 0x8053096
        int32_t v30 = v29; // 0x80530a3
        while (*v12 > v29) {
            int32_t * v31 = (int32_t *)v29;
            if (*v31 != 0) {
                // 0x8052f9f
                *(int32_t *)&new_table = v30;
                v18 = v30;
                if (v30 != 0) {
                    v19 = (int32_t *)v18;
                    v20 = *v19;
                    v21 = *v6 + 8 * v20;
                    if (*v16 <= v21) {
                        // 0x8052fe3
                        abort();
                        // UNREACHABLE
                    }
                    // 0x8052fe8
                    v22 = (int32_t *)v21;
                    v23 = (int32_t *)(v18 + 4);
                    bucket = (int32_t *)*v23;
                    if (*v22 == 0) {
                        // 0x8053055
                        *v22 = v20;
                        *v17 = *v17 + 1;
                        if (new_table != v31) {
                            // 0x8053074
                            free_entry(v6, new_table);
                        }
                    } else {
                        if (v31 != v19) {
                            // 0x805303e
                            v25 = (int32_t *)(v21 + 4);
                            *v23 = *v25;
                            *v25 = (int32_t)new_table;
                        } else {
                            // 0x8053002
                            v26 = allocate_entry(v6);
                            if (v26 == NULL) {
                                // 0x80530ff
                                return false;
                            }
                            // 0x805301f
                            v27 = (int32_t)v26;
                            *v26 = v20;
                            v28 = (int32_t *)(v21 + 4);
                            *(int32_t *)(v27 + 4) = *v28;
                            *v28 = v27;
                        }
                    }
                    // 0x8053086
                    v24 = (int32_t)bucket;
                    *(int32_t *)&new_table = v24;
                    v18 = v24;
                    while (bucket != NULL) {
                        // 0x8052faa
                        v19 = (int32_t *)v18;
                        v20 = *v19;
                        v21 = *v6 + 8 * v20;
                        if (*v16 <= v21) {
                            // 0x8052fe3
                            abort();
                            // UNREACHABLE
                        }
                        // 0x8052fe8
                        v22 = (int32_t *)v21;
                        v23 = (int32_t *)(v18 + 4);
                        bucket = (int32_t *)*v23;
                        if (*v22 == 0) {
                            // 0x8053055
                            *v22 = v20;
                            *v17 = *v17 + 1;
                            if (new_table != v31) {
                                // 0x8053074
                                free_entry(v6, new_table);
                            }
                        } else {
                            if (v31 != v19) {
                                // 0x805303e
                                v25 = (int32_t *)(v21 + 4);
                                *v23 = *v25;
                                *v25 = (int32_t)new_table;
                            } else {
                                // 0x8053002
                                v26 = allocate_entry(v6);
                                if (v26 == NULL) {
                                    // 0x80530ff
                                    return false;
                                }
                                // 0x805301f
                                v27 = (int32_t)v26;
                                *v26 = v20;
                                v28 = (int32_t *)(v21 + 4);
                                *(int32_t *)(v27 + 4) = *v28;
                                *v28 = v27;
                            }
                        }
                        // 0x8053086
                        v24 = (int32_t)bucket;
                        *(int32_t *)&new_table = v24;
                        v18 = v24;
                    }
                }
            }
            // 0x8053096
            v29 = (int32_t)v31 + 8;
            v30 = v29;
        }
        // 0x805309a
        v14 = v17;
        v13 = v16;
        v15 = (int32_t *)*table;
    } else {
        // 0x8052f79
        v14 = (int32_t *)(v7 + 12);
        v13 = (int32_t *)(v7 + 4);
        v15 = v11;
    }
    // 0x80530a9
    free(v15);
    *table = *v6;
    *v12 = *v13;
    *(int32_t *)(v1 + 8) = *(int32_t *)(v7 + 8);
    *(int32_t *)(v1 + 12) = *v14;
    *v8 = *v9;
    free(v6);
    // 0x80530ff
    return true;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/hash.c
// Address range: 0x8053109 - 0x8053324
// Line range:    908 - 975
char * hash_insert(int32_t * table, int32_t * entry) {
    char * result3 = (char *)entry;
    if (entry == NULL) {
        // 0x8053115
        abort();
        // UNREACHABLE
    }
    // 0x805311a
    char * data; // bp-12, 0x8053109
    char * result = hash_find_entry(table, entry, (int32_t **)&data, false); // 0x8053136
    if (result != NULL) {
        // 0x805331f
        return result;
    }
    int32_t v1 = (int32_t)table;
    if (*(int32_t *)data != 0) {
        int32_t * v2 = allocate_entry(table); // 0x805315e
        char * result2 = NULL; // 0x805316a
        if (v2 != NULL) {
            // 0x8053178
            *v2 = (int32_t)entry;
            int32_t v3 = (int32_t)v2; // 0x8053186
            *(int32_t *)(v3 + 4) = *(int32_t *)((int32_t)data + 4);
            *(int32_t *)((int32_t)data + 4) = v3;
            int32_t * v4 = (int32_t *)(v1 + 16); // 0x8053198
            *v4 = *v4 + 1;
            result2 = result3;
        }
        // 0x805331f
        return result2;
    }
    // 0x80531af
    *(int32_t *)data = (int32_t)entry;
    int32_t * v5 = (int32_t *)(v1 + 16); // 0x80531ba
    *v5 = *v5 + 1;
    int32_t * v6 = (int32_t *)(v1 + 12); // 0x80531c9
    int32_t v7 = *v6 + 1; // 0x80531cc
    *v6 = v7;
    int3_t v8; // 0x8053109
    int3_t v9 = v8 - 1; // 0x80531e2
    __frontend_reg_store_fpr(v9, (float80_t)v7);
    int32_t * v10 = (int32_t *)(v1 + 20); // 0x80531ec
    int3_t v11 = v8 - 2; // 0x80531ef
    __frontend_reg_store_fpr(v11, (float80_t)*(float32_t *)(*v10 + 8));
    int32_t * v12 = (int32_t *)(v1 + 8); // 0x80531f5
    int3_t v13 = v8 - 3; // 0x80531ff
    __frontend_reg_store_fpr(v13, (float80_t)*v12);
    __frontend_reg_store_fpr(v11, __frontend_reg_load_fpr(v13) * __frontend_reg_load_fpr(v11));
    float80_t v14 = __frontend_reg_load_fpr(v11); // 0x8053208
    __frontend_reg_store_fpr(v11, __frontend_reg_load_fpr(v9));
    __frontend_reg_store_fpr(v9, v14);
    __frontend_reg_load_fpr(v11);
    __frontend_reg_load_fpr(v9);
    int32_t v15; // 0x8053109
    if ((v15 & 0x4100) != 0) {
        // 0x805331f
        return result3;
    }
    // 0x8053260
    check_tuning(table);
    __frontend_reg_store_fpr(v9, (float80_t)*v6);
    __frontend_reg_store_fpr(v11, (float80_t)*(float32_t *)(*v10 + 8));
    __frontend_reg_store_fpr(v13, (float80_t)*v12);
    __frontend_reg_store_fpr(v11, __frontend_reg_load_fpr(v13) * __frontend_reg_load_fpr(v11));
    float80_t v16 = __frontend_reg_load_fpr(v11); // 0x8053253
    __frontend_reg_store_fpr(v11, __frontend_reg_load_fpr(v9));
    __frontend_reg_store_fpr(v9, v16);
    __frontend_reg_load_fpr(v11);
    __frontend_reg_load_fpr(v9);
    int32_t v17 = *v10; // 0x8053263
    __frontend_reg_store_fpr(v9, (float80_t)*v12);
    __frontend_reg_store_fpr(v11, (float80_t)*(float32_t *)(v17 + 12));
    __frontend_reg_store_fpr(v9, __frontend_reg_load_fpr(v11) * __frontend_reg_load_fpr(v9));
    float80_t v18; // 0x8053109
    if (*(char *)(v17 + 16) == 0) {
        // 0x8053295
        __frontend_reg_store_fpr(v11, (float80_t)*(float32_t *)(v17 + 8));
        __frontend_reg_store_fpr(v9, __frontend_reg_load_fpr(v11) * __frontend_reg_load_fpr(v9));
        v18 = __frontend_reg_load_fpr(v9);
    } else {
        // 0x8053274
        v18 = __frontend_reg_load_fpr(v9);
    }
    // 0x80532bc
    __frontend_reg_store_fpr(v9, v18);
    float80_t v19 = __frontend_reg_load_fpr(v9); // 0x80532bf
    __frontend_reg_store_fpr(v9, v19);
    __frontend_reg_store_fpr(v11, 4294967296.0L);
    float80_t v20 = __frontend_reg_load_fpr(v11); // 0x80532cb
    __frontend_reg_store_fpr(v11, __frontend_reg_load_fpr(v9));
    __frontend_reg_store_fpr(v9, v20);
    __frontend_reg_load_fpr(v11);
    __frontend_reg_load_fpr(v9);
    if ((v15 & 256) != 0) {
        // 0x80532dd
        __frontend_reg_store_fpr(v9, v19);
        hash_rehash(table, (int32_t)(int64_t)__frontend_reg_load_fpr(v9));
    }
    // 0x805331f
    return NULL;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/hash.c
// Address range: 0x8053324 - 0x80534c7
// Line range:    983 - 1021
char * hash_delete(int32_t * table, int32_t * entry) {
    // 0x8053324
    char * data; // bp-12, 0x8053324
    char * result = hash_find_entry(table, entry, (int32_t **)&data, true); // 0x8053346
    if (result == NULL) {
        // 0x80534c2
        return NULL;
    }
    int32_t v1 = (int32_t)table;
    int32_t * v2 = (int32_t *)(v1 + 16); // 0x8053363
    *v2 = *v2 - 1;
    if (*(int32_t *)data != 0) {
        // 0x80534c2
        return result;
    }
    int32_t * v3 = (int32_t *)(v1 + 12); // 0x805337f
    int32_t v4 = *v3 - 1; // 0x8053382
    *v3 = v4;
    int3_t v5; // 0x8053324
    int3_t v6 = v5 - 1; // 0x8053398
    __frontend_reg_store_fpr(v6, (float80_t)v4);
    int32_t * v7 = (int32_t *)(v1 + 20); // 0x80533a2
    int3_t v8 = v5 - 2; // 0x80533a5
    __frontend_reg_store_fpr(v8, (float80_t)*(float32_t *)*v7);
    int32_t * v9 = (int32_t *)(v1 + 8); // 0x80533aa
    int3_t v10 = v5 - 3; // 0x80533b4
    __frontend_reg_store_fpr(v10, (float80_t)*v9);
    __frontend_reg_store_fpr(v8, __frontend_reg_load_fpr(v10) * __frontend_reg_load_fpr(v8));
    __frontend_reg_load_fpr(v8);
    __frontend_reg_load_fpr(v6);
    int32_t v11; // 0x8053324
    if ((v11 & 0x4100) != 0) {
        // 0x80534c2
        return result;
    }
    // 0x8053410
    check_tuning(table);
    __frontend_reg_store_fpr(v6, (float80_t)*v3);
    __frontend_reg_store_fpr(v8, (float80_t)*(float32_t *)*v7);
    __frontend_reg_store_fpr(v10, (float80_t)*v9);
    __frontend_reg_store_fpr(v8, __frontend_reg_load_fpr(v10) * __frontend_reg_load_fpr(v8));
    __frontend_reg_load_fpr(v8);
    __frontend_reg_load_fpr(v6);
    int32_t v12 = *v7; // 0x8053413
    __frontend_reg_store_fpr(v6, (float80_t)*v9);
    __frontend_reg_store_fpr(v8, (float80_t)*(float32_t *)(v12 + 4));
    __frontend_reg_store_fpr(v6, __frontend_reg_load_fpr(v8) * __frontend_reg_load_fpr(v6));
    int32_t v13; // 0x8053324
    if (*(char *)(v12 + 16) == 0) {
        // 0x8053461
        __frontend_reg_store_fpr(v8, (float80_t)*(float32_t *)(v12 + 8));
        __frontend_reg_store_fpr(v6, __frontend_reg_load_fpr(v8) * __frontend_reg_load_fpr(v6));
        v13 = __frontend_reg_load_fpr(v6);
    } else {
        // 0x8053424
        v13 = __frontend_reg_load_fpr(v6);
    }
    // 0x80534a4
    hash_rehash(table, v13);
    // 0x80534c2
    return result;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/human.c
// Address range: 0x80534c8 - 0x8053603
// Line range:    56 - 68
float64_t adjust_value(int32_t inexact_style, float64_t value) {
    // 0x80534c8
    int32_t v1; // 0x80534c8
    uint32_t v2 = v1;
    float80_t v3 = value;
    int3_t v4; // 0x80534c8
    int3_t v5 = v4 - 1;
    float80_t result; // 0x80534c8
    if (inexact_style == 1) {
        // 0x80535e8
        __frontend_reg_store_fpr(v5, v3);
        return result;
    }
    // 0x80534d9
    __frontend_reg_store_fpr(v5, v3);
    int3_t v6 = v4 - 2; // 0x80534dc
    __frontend_reg_store_fpr(v6, 1.84467e+19L);
    __frontend_reg_load_fpr(v6);
    __frontend_reg_load_fpr(v5);
    if ((v2 & 0x4100) != 0) {
        // 0x80535e8
        __frontend_reg_store_fpr(v5, v3);
        return result;
    }
    // 0x80534ed
    __frontend_reg_store_fpr(v5, v3);
    __frontend_reg_store_fpr(v6, 9.22337e+18L);
    float80_t v7 = __frontend_reg_load_fpr(v6); // 0x80534f6
    __frontend_reg_store_fpr(v6, __frontend_reg_load_fpr(v5));
    __frontend_reg_store_fpr(v5, v7);
    __frontend_reg_load_fpr(v6);
    __frontend_reg_load_fpr(v5);
    __frontend_reg_store_fpr(v5, v3);
    int32_t v8; // 0x80534c8
    int32_t v9; // 0x80534c8
    if ((v2 & 256) == 0) {
        // 0x805351a
        __frontend_reg_store_fpr(v6, 9.22337e+18L);
        __frontend_reg_store_fpr(v5, __frontend_reg_load_fpr(v5) - __frontend_reg_load_fpr(v6));
        v8 = v1 ^ -0x80000000;
        v9 = __frontend_reg_load_fpr(v5);
    } else {
        // 0x80534ff
        v9 = __frontend_reg_load_fpr(v5);
    }
    // 0x8053554
    int32_t v10; // 0x80534c8
    if (inexact_style != 0) {
        // 0x80535a3
        v10 = 0;
        goto lab_0x80535aa;
    } else {
        // 0x8053566
        __frontend_reg_store_fpr(v5, (float80_t)v9);
        float80_t v11 = __frontend_reg_load_fpr(v5); // 0x8053569
        float80_t v12 = v11; // 0x8053570
        if (v8 < 0) {
            // 0x8053572
            __frontend_reg_store_fpr(v5, 1.84467e+19L);
            __frontend_reg_store_fpr(v6, v11);
            __frontend_reg_store_fpr(v5, __frontend_reg_load_fpr(v6) + __frontend_reg_load_fpr(v5));
            v12 = __frontend_reg_load_fpr(v5);
        }
        // 0x8053580
        __frontend_reg_store_fpr(v5, v3);
        __frontend_reg_store_fpr(v6, v12);
        __frontend_reg_load_fpr(v6);
        __frontend_reg_load_fpr(v5);
        char v13 = v2 / 256; // 0x805358a
        v10 = 1;
        if ((v13 & 4) == 0 && (v13 & 64) != 0) {
            // 0x80535a3
            v10 = 0;
            goto lab_0x80535aa;
        } else {
            goto lab_0x80535aa;
        }
    }
  lab_0x80535aa:;
    int32_t v14 = v10 + v9; // 0x80535be
    __frontend_reg_store_fpr(v5, (float80_t)v14);
    float80_t v15 = __frontend_reg_load_fpr(v5); // 0x80535cd
    float80_t v16 = v15; // 0x80535d2
    if (v8 + (int32_t)(v14 < v10) < 0) {
        // 0x80535d4
        __frontend_reg_store_fpr(v5, 1.84467e+19L);
        __frontend_reg_store_fpr(v6, v15);
        __frontend_reg_store_fpr(v5, __frontend_reg_load_fpr(v6) + __frontend_reg_load_fpr(v5));
        v16 = __frontend_reg_load_fpr(v5);
    }
    // 0x80535e2
    __frontend_reg_store_fpr(v5, v16);
    // 0x80535e8
    __frontend_reg_store_fpr(v5, __frontend_reg_load_fpr(v5));
    return result;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/human.c
// Address range: 0x8053603 - 0x805370f
// Line range:    82 - 117
char * group_number(char * number, int32_t numberlen, char * grouping, char * thousands_sep) {
    int32_t v1 = __readgsdword(20); // 0x805361b
    int32_t len = strlen(thousands_sep); // 0x8053633
    int32_t v2; // bp-49, 0x8053603
    memcpy(&v2, (int32_t *)number, numberlen);
    int32_t v3 = &v2; // 0x80536af
    uint32_t v4 = numberlen;
    unsigned char v5 = *grouping; // 0x8053668
    char * v6 = grouping; // 0x8053672
    int32_t v7 = -1; // 0x8053672
    if (v5 != 0) {
        // 0x8053674
        v7 = v5 < 127 ? (int32_t)v5 : v4;
        v6 = (char *)((int32_t)grouping + 1);
    }
    uint32_t v8 = v7;
    int32_t v9 = v4 >= v8 ? v8 : v4;
    int32_t v10 = (int32_t)number + numberlen - v9; // 0x80536a6
    int32_t v11 = v4 - v9; // 0x80536ac
    memcpy((int32_t *)v10, (int32_t *)(v11 + v3), v9);
    while (v11 != 0) {
        int32_t v12 = v10 - len; // 0x80536e7
        memcpy((int32_t *)v12, (int32_t *)thousands_sep, len);
        v4 = v11;
        char * v13 = v6;
        v5 = *v13;
        v6 = v13;
        v7 = v9;
        if (v5 != 0) {
            // 0x8053674
            v7 = v5 < 127 ? (int32_t)v5 : v4;
            v6 = (char *)((int32_t)v13 + 1);
        }
        // 0x8053693
        v8 = v7;
        v9 = v4 >= v8 ? v8 : v4;
        v10 = v12 - v9;
        v11 = v4 - v9;
        memcpy((int32_t *)v10, (int32_t *)(v11 + v3), v9);
    }
    int32_t v14 = v10; // 0x80536de
    if (v1 != __readgsdword(20)) {
        // 0x8053708
        __stack_chk_fail();
        v14 = &g49;
    }
    // 0x805370d
    return (char *)v14;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/human.c
// Address range: 0x805370f - 0x8054394
// Line range:    156 - 389
char * human_readable(int64_t n, char * buf, int32_t opts, int64_t from_block_size, int64_t to_block_size) {
    // 0x805370f
    int3_t v1; // 0x805370f
    int3_t v2 = v1;
    int32_t v3; // 0x805370f
    uint32_t v4 = v3;
    uint32_t v5 = v3;
    struct lconv * locale_info = localeconv(); // 0x80537ad
    int32_t str = *(int32_t *)locale_info; // 0x80537b8
    int64_t v6 = str; // bp-444, 0x80537ba
    strlen((char *)str);
    char * v7 = (char *)&g8; // 0x80537c9
    int32_t v8 = 1; // 0x80537c9
    if (v8 != 0 && (char *)v8 <= (char *)16) {
        // 0x80537d1
        v7 = (char *)*(int32_t *)locale_info;
    }
    int32_t v9 = (int32_t)locale_info; // 0x80537df
    int32_t * v10 = (int32_t *)(v9 + 4); // 0x80537eb
    int32_t str2 = *v10; // 0x80537eb
    v6 = str2;
    uint32_t len = strlen((char *)str2); // 0x80537f1
    int32_t v11 = &g9; // 0x80537f9
    if (len < 17) {
        // 0x80537fb
        v11 = *v10;
    }
    int32_t v12 = from_block_size;
    int64_t v13 = v12;
    int32_t v14 = &v6; // 0x8053715
    int64_t v15 = 0x100000000 * n >> 32; // 0x805371e
    int64_t v16 = 0x100000000 * to_block_size >> 32; // 0x8053730
    uint32_t v17 = v12 % 4; // 0x8053754
    uint32_t v18 = (v12 & 32) == 0 ? 1000 : 1024;
    int32_t v19 = opts + 648; // 0x8053807
    int32_t v20; // 0x805370f
    char * v21; // 0x805370f
    int32_t v22; // 0x805370f
    char * v23; // 0x805370f
    int32_t v24; // 0x805370f
    if (v4 > v5) {
        // 0x8053804
        v20 = v16;
        goto lab_0x8053943;
    } else {
        int32_t v25 = v16;
        v20 = v25;
        if (v3 > v25 == v4 >= v5) {
            goto lab_0x8053943;
        } else {
            // 0x805385f
            v6 = v16;
            if ((__umoddi3(v25, v5, v3, v4) || v4) != 0) {
                goto lab_0x8053b62;
            } else {
                // 0x8053895
                v6 = v16;
                uint32_t v26 = __udivdi3(v25, v5, v3, v4); // 0x80538bc
                int32_t v27 = (int32_t)buf; // 0x80538c7
                int32_t v28 = v15;
                uint64_t v29 = (v15 & 0xffffffff) * (int64_t)v26; // 0x80538e2
                int32_t v30 = v29; // 0x80538e2
                int32_t v31 = v26 * v27 + v5 * v28 + (int32_t)(v29 / 0x100000000); // 0x80538e8
                v6 = v30;
                if (__udivdi3(v30, v31, v26, v5) == v28 != (v31 == v27)) {
                    goto lab_0x8053b62;
                } else {
                    // 0x8053930
                    v21 = NULL;
                    v24 = v30;
                    v23 = (char *)v31;
                    v22 = 0;
                    goto lab_0x8053e12;
                }
            }
        }
    }
  lab_0x8053943:;
    // 0x8053943
    int32_t v32; // 0x805370f
    uint32_t v33; // 0x80539b6
    uint32_t v34; // 0x8053a38
    uint32_t v35; // 0x8053a3c
    int32_t v36; // 0x8053a6b
    int32_t v37; // 0x8053a97
    if ((v20 || v5) == 0) {
        goto lab_0x8053b62;
    } else {
        int64_t v38 = v3; // 0x8053742
        v6 = v38;
        if ((__umoddi3(v3, v4, v20, v5) || v5) != 0) {
            goto lab_0x8053b62;
        } else {
            // 0x805398f
            v6 = v38;
            v33 = __udivdi3(v3, v4, v20, v5);
            int32_t v39 = (int32_t)buf; // 0x80539c7
            v6 = v15;
            int32_t v40 = v15; // 0x80539e2
            int32_t v41 = 10 * v4 + __umoddi3(v40, v39, v33, v4) / 0x1999999a; // 0x80539f6
            v6 = 0;
            int32_t v42 = __umoddi3(0, v41, v33, v4); // 0x8053a33
            v34 = 2 * v4 | (int32_t)(v42 < 0);
            v35 = 2 * v42;
            v6 = v15;
            v36 = __udivdi3(v40, v39, v33, v4);
            v6 = 0;
            v37 = __udivdi3(0, v41, v33, v4);
            if (v34 > v4) {
                goto lab_0x8053af6;
            } else {
                if (v34 >= v4 == v35 >= v33) {
                    goto lab_0x8053af6;
                } else {
                    // 0x8053ad8
                    v32 = (v34 | v35) != 0;
                    goto lab_0x8053b54;
                }
            }
        }
    }
  lab_0x8053b62:;
    int3_t v43 = v2 - 1; // 0x8053b62
    __frontend_reg_store_fpr(v43, (float80_t)v3);
    float80_t v44 = __frontend_reg_load_fpr(v43); // 0x8053b68
    float80_t v45 = v44; // 0x8053b75
    if (v4 < 0) {
        // 0x8053b77
        __frontend_reg_store_fpr(v43, 1.84467e+19L);
        int3_t v46 = v2 - 2; // 0x8053b7d
        __frontend_reg_store_fpr(v46, v44);
        __frontend_reg_store_fpr(v43, __frontend_reg_load_fpr(v46) + __frontend_reg_load_fpr(v43));
        v45 = __frontend_reg_load_fpr(v43);
    }
    // 0x8053b8b
    __frontend_reg_store_fpr(v43, v45);
    float80_t v47 = __frontend_reg_load_fpr(v43); // 0x8053b91
    __frontend_reg_store_fpr(v43, (float80_t)v15);
    float80_t v48 = __frontend_reg_load_fpr(v43); // 0x8053b9d
    float80_t v49 = v48; // 0x8053baa
    if (buf < NULL) {
        // 0x8053bac
        __frontend_reg_store_fpr(v43, 1.84467e+19L);
        int3_t v50 = v2 - 2; // 0x8053bb2
        __frontend_reg_store_fpr(v50, v48);
        __frontend_reg_store_fpr(v43, __frontend_reg_load_fpr(v50) + __frontend_reg_load_fpr(v43));
        v49 = __frontend_reg_load_fpr(v43);
    }
    // 0x8053bc0
    __frontend_reg_store_fpr(v43, (float80_t)v16);
    float80_t v51 = __frontend_reg_load_fpr(v43); // 0x8053bc6
    int3_t v52; // 0x805370f
    float80_t v53; // 0x805370f
    if (v5 >= 0) {
        // 0x8053bc0
        v52 = v2 - 2;
        v53 = v51;
    } else {
        // 0x8053bd5
        __frontend_reg_store_fpr(v43, 1.84467e+19L);
        int3_t v54 = v2 - 2;
        __frontend_reg_store_fpr(v54, v51);
        __frontend_reg_store_fpr(v43, __frontend_reg_load_fpr(v54) + __frontend_reg_load_fpr(v43));
        v52 = v54;
        v53 = __frontend_reg_load_fpr(v43);
    }
    // 0x8053be9
    __frontend_reg_store_fpr(v43, v47);
    __frontend_reg_store_fpr(v52, v53);
    __frontend_reg_store_fpr(v43, __frontend_reg_load_fpr(v52) / __frontend_reg_load_fpr(v43));
    __frontend_reg_store_fpr(v52, v49);
    __frontend_reg_store_fpr(v43, __frontend_reg_load_fpr(v52) * __frontend_reg_load_fpr(v43));
    float80_t v55 = __frontend_reg_load_fpr(v43); // 0x8053bff
    int32_t * v56; // 0x805370f
    int32_t * v57; // 0x805370f
    int32_t v58; // 0x805370f
    int32_t * len3; // 0x805370f
    int32_t v59; // 0x805370f
    float80_t v60; // 0x8053cfa
    int32_t v61; // 0x805370f
    int32_t * v62; // 0x805370f
    int32_t * v63; // 0x805370f
    float80_t * v64; // 0x8053d29
    int32_t v65; // 0x8053cb0
    if ((v13 & 16) != 0) {
        int32_t * v66 = (int32_t *)(v14 - 4); // 0x8053c99
        int32_t v67 = v14 - 8; // 0x8053c9a
        int32_t * v68 = (int32_t *)v67; // 0x8053c9a
        int64_t * v69 = (int64_t *)v67; // 0x8053c9b
        *v66 = 0;
        *v68 = v18;
        __frontend_reg_store_fpr(v43, (float80_t)*v69);
        __frontend_reg_store_fpr(v52, 0.0L);
        __frontend_reg_store_fpr(v43, __frontend_reg_load_fpr(v52) * __frontend_reg_load_fpr(v43));
        float80_t v70 = __frontend_reg_load_fpr(v43); // 0x8053caa
        v65 = 1;
        *v66 = 0;
        *v68 = v18;
        __frontend_reg_store_fpr(v43, (float80_t)*v69);
        __frontend_reg_store_fpr(v52, v70);
        __frontend_reg_store_fpr(v43, __frontend_reg_load_fpr(v52) * __frontend_reg_load_fpr(v43));
        __frontend_reg_store_fpr(v52, v55);
        __frontend_reg_load_fpr(v52);
        __frontend_reg_load_fpr(v43);
        int32_t v71 = v65; // 0x8053ce2
        float80_t v72 = v70; // 0x8053ce2
        while ((v3 & 1280) == 0 == v65 < 8) {
            // 0x8053c91
            *v66 = 0;
            *v68 = v18;
            __frontend_reg_store_fpr(v43, (float80_t)*v69);
            __frontend_reg_store_fpr(v52, v72);
            __frontend_reg_store_fpr(v43, __frontend_reg_load_fpr(v52) * __frontend_reg_load_fpr(v43));
            v70 = __frontend_reg_load_fpr(v43);
            v65 = v71 + 1;
            *v66 = 0;
            *v68 = v18;
            __frontend_reg_store_fpr(v43, (float80_t)*v69);
            __frontend_reg_store_fpr(v52, v70);
            __frontend_reg_store_fpr(v43, __frontend_reg_load_fpr(v52) * __frontend_reg_load_fpr(v43));
            __frontend_reg_store_fpr(v52, v55);
            __frontend_reg_load_fpr(v52);
            __frontend_reg_load_fpr(v43);
            v71 = v65;
            v72 = v70;
        }
        // 0x8053cec
        __frontend_reg_store_fpr(v43, v55);
        __frontend_reg_store_fpr(v52, v70);
        __frontend_reg_store_fpr(v43, __frontend_reg_load_fpr(v43) / __frontend_reg_load_fpr(v52));
        v60 = __frontend_reg_load_fpr(v43);
        v61 = v14 | 4;
        v62 = (int32_t *)v61;
        *v62 = (int32_t)(float32_t)v60;
        int32_t v73 = v14 + 8;
        v63 = (int32_t *)v73;
        *(int32_t *)&v6 = v17;
        adjust_value((int32_t)(float32_t)v60, (float64_t)(int64_t)&g49);
        float80_t v74 = __frontend_reg_load_fpr(v2); // 0x8053d29
        v64 = (float80_t *)v73;
        *v64 = v74;
        *v62 = (int32_t)"%.1Lf";
        *(int32_t *)&v6 = opts;
        sprintf((char *)&g49, (char *)&g49);
        *(int32_t *)&v6 = opts;
        uint32_t len2 = strlen((char *)&g49); // 0x8053d46
        int32_t v75 = v8 + 1; // 0x8053d51
        if (v75 + ((v13 & 32) == 0 ? 2 : 1) < len2) {
            goto lab_0x8053d8a;
        } else {
            int32_t * v76 = (int32_t *)len2; // 0x8053d4b
            v57 = v62;
            v56 = v63;
            v58 = v65;
            len3 = v76;
            v59 = v75;
            if ((v13 & 8) == 0) {
                goto lab_0x8053ddb;
            } else {
                // 0x8053d7a
                v57 = v62;
                v56 = v63;
                v58 = v65;
                len3 = v76;
                v59 = v75;
                if (*(char *)(opts - 1 + len2) != 48) {
                    goto lab_0x8053ddb;
                } else {
                    goto lab_0x8053d8a;
                }
            }
        }
    } else {
        // 0x8053c0f
        v6 = v17;
        adjust_value(v17, (float64_t)v55);
        int64_t v77 = opts; // 0x8053c47
        v6 = v77;
        char * str3 = (char *)opts; // 0x8053c4a
        sprintf(str3, "%.0Lf", __frontend_reg_load_fpr(v2));
        v6 = v77;
        v57 = (int32_t *)(v14 | 4);
        v56 = (int32_t *)(v14 + 8);
        v58 = -1;
        len3 = (int32_t *)strlen(str3);
        v59 = 0;
        goto lab_0x8053ddb;
    }
  lab_0x8053d8a:;
    int3_t v78 = v2 + 1; // 0x8053d29
    __frontend_reg_store_fpr(v2, v60);
    __frontend_reg_store_fpr(v43, 10.0L);
    __frontend_reg_store_fpr(v2, __frontend_reg_load_fpr(v43) * __frontend_reg_load_fpr(v2));
    *(float80_t *)v61 = __frontend_reg_load_fpr(v2);
    *(int32_t *)&v6 = v17;
    adjust_value((int32_t)&g49, (float64_t)(int64_t)&g49);
    __frontend_reg_store_fpr(v2, 10.0L);
    __frontend_reg_store_fpr(v78, __frontend_reg_load_fpr(v78) / __frontend_reg_load_fpr(v2));
    *v64 = __frontend_reg_load_fpr(v78);
    *v62 = (int32_t)"%.0Lf";
    *(int32_t *)&v6 = opts;
    sprintf((char *)&g49, (char *)&g49);
    *(int32_t *)&v6 = opts;
    int32_t len4 = strlen((char *)&g49); // 0x8053dcc
    v57 = v62;
    v56 = v63;
    v58 = v65;
    len3 = (int32_t *)len4;
    v59 = 0;
    goto lab_0x8053ddb;
  lab_0x8053ddb:;
    int32_t v79 = (int32_t)len3; // 0x8053ddb
    int32_t v80 = v19 - v79; // 0x8053de0
    *v56 = v79;
    *v57 = opts;
    *(int32_t *)&v6 = v80;
    memmove((int32_t *)v59, len3, (int32_t)&g49);
    int32_t v81 = v58; // 0x8053e0d
    int32_t v82 = v80; // 0x8053e0d
    int32_t v83 = v79 - v59 + v80; // 0x8053e0d
    goto lab_0x80541eb;
  lab_0x8053af6:
    if (v4 > v34) {
        // 0x8053b48
        v32 = (int32_t)(char *)2;
        goto lab_0x8053b54;
    } else {
        // 0x8053b16
        if (v4 >= v34 == v33 >= v35) {
            // 0x8053b48
            v32 = (int32_t)(char *)2;
            goto lab_0x8053b54;
        } else {
            // 0x8053b48
            v32 = (int32_t)(char *)3;
            goto lab_0x8053b54;
        }
    }
  lab_0x8053e12:;
    char * v113 = (char *)v24;
    char * v106 = v21; // 0x8053e1a
    int32_t v101 = -1; // 0x8053e1a
    int32_t v102 = v19; // 0x8053e1a
    char * v103 = v113; // 0x8053e1a
    char * v104 = v23; // 0x8053e1a
    int32_t v105 = v22; // 0x8053e1a
    int32_t v114; // 0x805370f
    char * v115; // 0x805370f
    int32_t v116; // 0x8053f55
    if ((v13 & 16) == 0) {
        goto lab_0x8054088;
    } else {
        // 0x8053e20
        v106 = v21;
        v101 = 0;
        v102 = v19;
        v103 = v113;
        v104 = NULL;
        v105 = v22;
        if (v18 > v24 == v23 == NULL) {
            goto lab_0x8054088;
        } else {
            int32_t v117 = (int32_t)v23;
            int32_t v118 = (int32_t)v113; // 0x8053e6c
            int64_t v119 = v118; // 0x8053e7a
            v6 = v119;
            uint32_t v120 = 10 * __umoddi3(v118, v117, v18, 0) + v22; // 0x8053e9e
            int32_t v121 = (int32_t)v21; // 0x8053ec0
            uint32_t v122 = 2 * (v120 % v18) + (v121 >> 1); // 0x8053ec5
            v6 = v119;
            uint32_t v123 = __udivdi3(v118, v117, v18, 0); // 0x8053ee8
            int32_t v124; // 0x805370f
            if (v122 >= v18) {
                // 0x8053f1f
                v124 = v122 + v121 > v18 ? 3 : 2;
            } else {
                // 0x8053f09
                v124 = v122 != -v121;
            }
            char * v125 = (char *)v123;
            int32_t v126 = v120 / v18;
            int32_t v127 = v124;
            char * v128 = (char *)v127;
            v116 = 1;
            char * v129 = v128; // 0x8053f81
            int32_t v130 = v116; // 0x8053f81
            int32_t v131 = v126; // 0x8053f81
            while (v116 < 8 == (v23 == NULL != v18 > v123)) {
                // 0x8053e64
                v118 = (int32_t)v125;
                v119 = v118;
                v6 = v119;
                v120 = 10 * __umoddi3(v118, v117, v18, 0) + v131;
                v121 = (int32_t)v129;
                v122 = 2 * (v120 % v18) + (v121 >> 1);
                v6 = v119;
                v123 = __udivdi3(v118, v117, v18, 0);
                if (v122 >= v18) {
                    // 0x8053f1f
                    v124 = v122 + v121 > v18 ? 3 : 2;
                } else {
                    // 0x8053f09
                    v124 = v122 != -v121;
                }
                // 0x8053f4c
                v125 = (char *)v123;
                v126 = v120 / v18;
                v127 = v124;
                v128 = (char *)v127;
                v116 = v130 + 1;
                v129 = v128;
                v130 = v116;
                v131 = v126;
            }
            // 0x8053f9a
            v106 = v128;
            v101 = v116;
            v102 = v19;
            v103 = v125;
            v104 = v23;
            v105 = v126;
            if (v23 != NULL || v125 > (char *)9) {
                goto lab_0x8054088;
            } else {
                bool v132; // 0x805370f
                if (v17 != 1) {
                    // 0x8053fcf
                    v132 = v17 == 0 == v128 >= (char *)1;
                } else {
                    int32_t v133 = (v126 | -2) + v127; // 0x8053fc3
                    v132 = v133 >= 0 == (v133 != 0);
                }
                char * v134 = v128; // 0x8054005
                v115 = v125;
                char * v135 = NULL; // 0x8054005
                v114 = v126;
                if (v132) {
                    // 0x8054007
                    v134 = NULL;
                    v115 = v125;
                    v135 = NULL;
                    v114 = v126 + 1;
                    if (v126 == 9) {
                        // 0x8054018
                        v134 = NULL;
                        v115 = (char *)(v123 + 1);
                        v135 = (char *)((int32_t)(v125 == (char *)-1) + v117);
                        v114 = 0;
                    }
                }
                // 0x8054027
                v106 = v134;
                v101 = v116;
                v102 = v19;
                v103 = v115;
                v104 = v135;
                v105 = v114;
                if (v115 > (char *)9 || v135 != NULL) {
                    goto lab_0x8054088;
                } else {
                    if (v114 != 0) {
                        goto lab_0x8054049;
                    } else {
                        // 0x805403f
                        v106 = v134;
                        v101 = v116;
                        v102 = v19;
                        v103 = v115;
                        v104 = NULL;
                        v105 = v114;
                        if ((v13 & 8) != 0) {
                            goto lab_0x8054088;
                        } else {
                            goto lab_0x8054049;
                        }
                    }
                }
            }
        }
    }
  lab_0x80541eb:;
    int32_t v84 = v82; // 0x80541f3
    if ((v13 & 4) != 0) {
        // 0x80541f5
        *(int32_t *)(v14 + 12) = v11;
        *(int32_t *)(v14 + 8) = *(int32_t *)(v9 + 8);
        *(int32_t *)(v14 | 4) = v83 - v82;
        *(int32_t *)&v6 = v82;
        char * v85 = group_number((char *)&g49, (int32_t)&g49, (char *)&g49, (char *)&g49); // 0x805421b
        v84 = (int32_t)v85;
    }
    // 0x8054223
    if ((char)from_block_size > -1) {
        // 0x8054380
        *(char *)v19 = 0;
        return (char *)v84;
    }
    int32_t v86 = v81; // 0x8054237
    if (v81 < 0) {
        uint32_t v87 = 0;
        int64_t v88 = 1;
        if (v87 >= v4) {
            // 0x80542ce
            if (v87 <= v4 != v3 > (int32_t)v88) {
                // break -> 0x80542ee
                break;
            }
        }
        int32_t v89 = 1; // 0x805425a
        v86 = 8;
        while (v89 != 8) {
            uint64_t v90 = (v88 & 0xffffffff) * (int64_t)v18; // 0x8054286
            v87 = v87 * v18 + (int32_t)(v90 / 0x100000000);
            v88 = 0x100000000 * v90 / 0x100000000;
            int32_t v91 = v89;
            if (v87 >= v4) {
                // 0x80542ce
                v86 = v91;
                if (v87 <= v4 != v3 > (int32_t)v88) {
                    // break -> 0x80542ee
                    break;
                }
            }
            // 0x805425a
            v89 = v91 + 1;
            v86 = 8;
        }
    }
    int32_t v92 = v19; // 0x80542fb
    if ((v13 & 64) != 0 && (v86 || v12 & 256) != 0) {
        // 0x8054307
        *(char *)v19 = 32;
        v92 = opts + 649;
    }
    int32_t v93 = v92; // 0x8054315
    if (v86 != 0) {
        char v94 = 107; // 0x805431f
        if ((v13 & 32) == 0 != (v86 == 1)) {
            // 0x8054327
            v94 = *(char *)(v86 + (int32_t)"\x00KMGTPEZY");
        }
        // 0x8054340
        *(char *)v92 = v94;
        v93 = v92 + 1;
    }
    // 0x8054350
    if ((v13 & 256) == 0) {
        // 0x8054380
        *(char *)v93 = 0;
        return (char *)v84;
    }
    int32_t v95 = v93; // 0x8054364
    if ((v13 & 32) != 0 && v86 != 0) {
        // 0x805436c
        *(char *)v93 = 105;
        v95 = v93 + 1;
    }
    // 0x8054376
    *(char *)v95 = 66;
    // 0x8054380
    *(char *)(v95 + 1) = 0;
    return (char *)v84;
  lab_0x8054088:;
    // 0x8054088
    int32_t v96; // 0x805370f
    int32_t v97; // 0x805370f
    int32_t v98; // 0x805370f
    char * v99; // 0x805370f
    char * v100; // 0x805370f
    if (v17 != 1) {
        // 0x80540c5
        v97 = v101;
        v98 = v102;
        v100 = v103;
        v99 = v104;
        if (v17 != 0) {
            goto lab_0x805417b;
        } else {
            // 0x80540cb
            v97 = v101;
            v98 = v102;
            v100 = v103;
            v99 = v104;
            if (v105 + (int32_t)v106 < 1) {
                goto lab_0x805417b;
            } else {
                // 0x80540cb
                v96 = (int32_t)v103;
                goto lab_0x8054104;
            }
        }
    } else {
        int32_t v107 = (int32_t)v106; // 0x805408e
        int32_t v108 = (int32_t)v103;
        uint32_t v109 = v108 % 2; // 0x80540a0
        uint32_t v110 = v109 + v107; // 0x80540a8
        int32_t v111 = v105 + (int32_t)(((v107 >> 31) + (int32_t)(v110 < v109) | v110) != 0); // 0x80540b6
        int32_t v112 = v111 - 5; // 0x80540b9
        v96 = v108;
        v97 = v101;
        v98 = v102;
        v100 = v103;
        v99 = v104;
        if (v112 < 0 == (4 - v111 & v111) < 0 != v112 != 0) {
            goto lab_0x805417b;
        } else {
            goto lab_0x8054104;
        }
    }
  lab_0x8053b54:
    // 0x8053b54
    v21 = (char *)v32;
    v24 = v36;
    v23 = buf;
    v22 = v37;
    goto lab_0x8053e12;
  lab_0x805417b:;
    int32_t v136 = (int32_t)v99; // 0x8054184
    int32_t v137 = (int32_t)v100; // 0x8054181
    int64_t v138 = v137; // 0x8054197
    v6 = v138;
    int32_t v139 = __umoddi3(v137, v136, 10, 0); // 0x805419e
    int32_t v140 = v98 - 1; // 0x80541a6
    *(char *)v140 = (char)v139 + 48;
    v6 = v138;
    int32_t v141 = __udivdi3(v137, v136, 10, 0); // 0x80541d4
    int32_t v142 = v140; // 0x80541e9
    v81 = v97;
    v82 = v140;
    v83 = v98;
    while ((v141 || v136) != 0) {
        // 0x8054181
        v137 = (int32_t)(char *)v141;
        v138 = v137;
        v6 = v138;
        v139 = __umoddi3(v137, v136, 10, 0);
        v140 = v142 - 1;
        *(char *)v140 = (char)v139 + 48;
        v6 = v138;
        v141 = __udivdi3(v137, v136, 10, 0);
        v142 = v140;
        v81 = v97;
        v82 = v140;
        v83 = v98;
    }
    goto lab_0x80541eb;
  lab_0x8054104:;
    int32_t v143 = v96 + 1; // 0x8054104
    char * v144 = (char *)v143; // 0x8054104
    int32_t v145 = (int32_t)v104 + (int32_t)(v103 == (char *)-1); // 0x8054108
    char * v146 = (char *)v145; // 0x8054108
    v97 = v101;
    v98 = v102;
    v100 = v144;
    v99 = v146;
    if ((v13 & 16) != 0) {
        // 0x8054116
        v97 = v101;
        v98 = v102;
        v100 = v144;
        v99 = v146;
        if (v101 < 8 == (v143 ^ v18 || v145) == 0) {
            int32_t v147 = v101 + 1; // 0x8054134
            v97 = v147;
            v98 = v102;
            v100 = (char *)1;
            v99 = NULL;
            if ((v13 & 8) == 0) {
                int32_t v148 = v102 - 1; // 0x8054142
                *(char *)v148 = 48;
                int32_t v149 = v148 - v8; // 0x8054151
                v6 = v149;
                memcpy((int32_t *)v149, (int32_t *)v7, v8);
                v97 = v147;
                v98 = v149;
                v100 = (char *)1;
                v99 = NULL;
            }
        }
    }
    goto lab_0x805417b;
  lab_0x8054049:;
    int32_t v150 = opts + 647; // 0x8054049
    *(char *)v150 = (char)v114 + 48;
    int32_t v151 = v150 - v8; // 0x805405f
    v6 = v151;
    memcpy((int32_t *)v151, (int32_t *)v7, v8);
    v106 = NULL;
    v101 = v116;
    v102 = v151;
    v103 = v115;
    v104 = NULL;
    v105 = 0;
    goto lab_0x8054088;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/human.c
// Address range: 0x8054394 - 0x80543d0
// Line range:    407 - 409
int64_t default_block_size(void) {
    // 0x8054394
    return getenv("POSIXLY_CORRECT") == NULL ? 1024 : 512;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/human.c
// Address range: 0x80543d0 - 0x8054532
// Line range:    413 - 459
int32_t humblock(char * spec, int64_t * block_size, int32_t * options) {
    char * v1 = spec; // 0x80543e1
    if (spec == NULL) {
        char * env_val = getenv("BLOCK_SIZE"); // 0x80543ea
        v1 = env_val;
        if (env_val == NULL) {
            char * env_val2 = getenv("BLOCKSIZE"); // 0x80543ff
            v1 = env_val2;
            if (env_val2 == NULL) {
                // 0x805440d
                *(int32_t *)block_size = (int32_t)default_block_size();
                // 0x805452d
                *options = 0;
                return 0;
            }
        }
    }
    char v2 = *v1; // 0x8054422
    int32_t v3 = (int32_t)v1;
    int32_t v4 = v3 + 1;
    char * v5 = v2 != 39 ? v1 : (char *)v4;
    int32_t v6 = v2 != 39 ? 0 : 4;
    uint32_t v7 = argmatch(v5, block_size_args, (char *)&block_size_opts, 4); // 0x8054450
    if (v7 >= 0) {
        // 0x805445e
        *(int32_t *)block_size = 1;
        *(int32_t *)((int32_t)block_size + 4) = 0;
        // 0x805452d
        *options = *(int32_t *)(4 * v7 + (int32_t)&block_size_opts) | v6;
        return 0;
    }
    int32_t v8 = v2 != 39 ? v3 : v4;
    int32_t i; // bp-16, 0x80543d0
    int32_t result = xstrtoumax((char *)v8, (char **)&i, 0, block_size, "eEgGkKmMpPtTyYzZ0"); // 0x80544a4
    if (result != 0) {
        // 0x805452d
        *options = 0;
        return result;
    }
    // 0x805450a
    if (*v5 <= 57) {
        // 0x805452d
        *options = v6;
        return 0;
    }
    int32_t v9 = (int32_t)v5; // 0x80544c6
    while (i != v9) {
        char * v10 = (char *)(v9 + 1); // 0x8054506
        if (*v10 <= 57) {
            // 0x805452d
            *options = v6;
            return 0;
        }
        v9 = (int32_t)v10;
    }
    char v11 = *(char *)(i - 1); // 0x80544d8
    int32_t v12 = v6 | 384;
    if (v11 == 66) {
        // 0x80544f3
        if (*(char *)(i - 2) != 105) {
            // 0x805452d
            *options = v12;
            return 0;
        }
    }
    // 0x805452d
    *options = (v11 != 66 ? v6 | 128 : v12) | 32;
    return 0;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/human.c
// Address range: 0x8054532 - 0x805457b
// Line range:    463 - 471
int32_t human_options(char * spec, int32_t * opts, int64_t * block_size) {
    int32_t v1 = humblock(spec, block_size, opts); // 0x805454c
    int32_t * v2 = (int32_t *)((int32_t)block_size + 4); // 0x8054557
    int32_t v3 = *v2; // 0x8054557
    int32_t result = v1; // 0x8054560
    if ((*(int32_t *)block_size || v3) == 0) {
        // 0x8054562
        *(int32_t *)block_size = (int32_t)default_block_size();
        *v2 = v3;
        result = 4;
    }
    // 0x8054576
    return result;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/idcache.c
// Address range: 0x805457c - 0x8054651
// Line range:    69 - 96
char * getuser(int32_t uid) {
    // 0x805457c
    char * v1; // 0x8054632
    if (user_alist != NULL) {
        int32_t v2 = (int32_t)user_alist;
        int32_t * v3 = (int32_t *)v2;
        while (*v3 != uid) {
            int32_t v4 = *(int32_t *)(v2 + 4); // 0x80545a8
            if (v4 == 0) {
                goto lab_0x80545ba;
            }
            v2 = v4;
            v3 = (int32_t *)v2;
        }
        // 0x80545b4
        if (v2 != 0) {
            // 0x805462f
            v1 = (char *)((int32_t)v3 + 8);
            return *v1 == 0 ? NULL : v1;
        }
    }
  lab_0x80545ba:;
    struct passwd * v5 = getpwuid(uid); // 0x80545c0
    char * str = (char *)&g10; // 0x80545cc
    if (v5 != NULL) {
        // 0x80545ce
        str = (char *)*(int32_t *)v5;
    }
    char * v6 = xmalloc(strlen(str) + 9); // 0x80545f6
    *(int32_t *)v6 = uid;
    int32_t v7 = (int32_t)v6; // 0x8054606
    strcpy((char *)(v7 + 8), str);
    *(int32_t *)(v7 + 4) = (int32_t)user_alist;
    *(int32_t *)&user_alist = v7;
    // 0x805462f
    v1 = (char *)((int32_t)(int32_t *)v6 + 8);
    return *v1 == 0 ? NULL : v1;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/idcache.c
// Address range: 0x805477c - 0x8054851
// Line range:    151 - 178
char * getgroup(int32_t gid) {
    // 0x805477c
    char * v1; // 0x8054832
    if (group_alist != NULL) {
        int32_t v2 = (int32_t)group_alist;
        int32_t * v3 = (int32_t *)v2;
        while (*v3 != gid) {
            int32_t v4 = *(int32_t *)(v2 + 4); // 0x80547a8
            if (v4 == 0) {
                goto lab_0x80547ba;
            }
            v2 = v4;
            v3 = (int32_t *)v2;
        }
        // 0x80547b4
        if (v2 != 0) {
            // 0x805482f
            v1 = (char *)((int32_t)v3 + 8);
            return *v1 == 0 ? NULL : v1;
        }
    }
  lab_0x80547ba:;
    struct group * v5 = getgrgid(gid); // 0x80547c0
    char * str = (char *)&g10; // 0x80547cc
    if (v5 != NULL) {
        // 0x80547ce
        str = (char *)*(int32_t *)v5;
    }
    char * v6 = xmalloc(strlen(str) + 9); // 0x80547f6
    *(int32_t *)v6 = gid;
    int32_t v7 = (int32_t)v6; // 0x8054806
    strcpy((char *)(v7 + 8), str);
    *(int32_t *)(v7 + 4) = (int32_t)group_alist;
    *(int32_t *)&group_alist = v7;
    // 0x805482f
    v1 = (char *)((int32_t)(int32_t *)v6 + 8);
    return *v1 == 0 ? NULL : v1;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/inttostr.c
// Address range: 0x805497c - 0x8054a82
// Line range:    30 - 50
char * imaxtostr(int64_t i, char * buf) {
    // 0x805497c
    int32_t v1; // 0x805497c
    char * v2 = (char *)(v1 + 20); // 0x8054994
    *v2 = 0;
    int32_t v3 = i;
    int32_t v4 = (int32_t)buf;
    int32_t v5 = v3; // 0x80549a1
    int32_t v6 = v3; // 0x80549a1
    char * result = v2; // 0x80549a1
    if (buf >= NULL) {
        result = (char *)((int32_t)result - 1);
        *result = (char)__moddi3(v6, v4, 10, 0) + 48;
        v6 = __divdi3(v6, v4, 10, 0);
        while ((v6 || v4) != 0) {
            // 0x8054a19
            result = (char *)((int32_t)result - 1);
            *result = (char)__moddi3(v6, v4, 10, 0) + 48;
            v6 = __divdi3(v6, v4, 10, 0);
        }
        // 0x8054a7d
        return result;
    }
    int32_t v7 = (int32_t)v2;
    char * v8 = (char *)(v7 - 1); // 0x80549a3
    *v8 = 48 - (char)__moddi3(v5, v4, 10, 0);
    v5 = __divdi3(v5, v4, 10, 0);
    while ((v5 || v4) != 0) {
        // 0x80549a3
        v7 = (int32_t)v8;
        v8 = (char *)(v7 - 1);
        *v8 = 48 - (char)__moddi3(v5, v4, 10, 0);
        v5 = __divdi3(v5, v4, 10, 0);
    }
    char * result2 = (char *)(v7 - 2); // 0x8054a0d
    *result2 = 45;
    // 0x8054a7d
    return result2;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/mpsort.c
// Address range: 0x8054a84 - 0x8054bbb
// Line range:    40 - 79
void mpsort_into_tmp(int32_t ** base, uint32_t n, int32_t ** tmp, int32_t (*cmp)(int32_t *, int32_t *)) {
    int32_t v1 = (int32_t)base;
    uint32_t v2 = n % 2;
    int32_t v3 = 0;
    int32_t v4 = v3 + v1;
    mpsort_with_tmp((int32_t **)v4, v2, tmp, cmp);
    mpsort_with_tmp(base, 0, tmp, cmp);
    int32_t * v5 = (int32_t *)v4;
    if (cmp >= NULL != cmp != NULL) {
        int32_t v6 = 0; // 0x8054b3c
        *(int32_t *)tmp = *(int32_t *)base;
        int32_t v7 = (int32_t)tmp + 4; // 0x8054b38
        v6++;
        while (v6 != 0) {
            // 0x8054b56
            *(int32_t *)v7 = *(int32_t *)(4 * v6 + v1);
            v7 = (int32_t)(int32_t **)v7 + 4;
            v6++;
        }
        // 0x8054b8e
        memcpy((int32_t *)v7, v5, 4 * v2);
        return;
    }
    // 0x8054b66
    *(int32_t *)tmp = *v5;
    int32_t v8 = (int32_t)tmp + 4; // 0x8054b6e
    int32_t v9 = 1; // 0x8054b72
    int32_t v10 = v8; // 0x8054b7c
    if (v9 != n) {
        *(int32_t *)v8 = *(int32_t *)(4 * v9 + v1);
        int32_t v11 = v8 + 4; // 0x8054b6e
        int32_t v12 = v9 + 1; // 0x8054b72
        int32_t v13 = v12; // 0x8054b7c
        int32_t v14 = v11; // 0x8054b7c
        v10 = v11;
        while (v12 != n) {
            // 0x8054b7e
            *(int32_t *)v14 = *(int32_t *)(4 * v13 + v1);
            v11 = v14 + 4;
            v12 = v13 + 1;
            v13 = v12;
            v14 = v11;
            v10 = v11;
        }
    }
    // 0x8054b8e
    memcpy((int32_t *)v10, (int32_t *)base, v3);
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/mpsort.c
// Address range: 0x8054bbb - 0x8054d6f
// Line range:    89 - 146
void mpsort_with_tmp(int32_t ** base, uint32_t n, int32_t ** tmp, int32_t (*cmp)(int32_t *, int32_t *)) {
    int32_t v1 = (int32_t)base;
    if (n < 3) {
        if (n == 2 == cmp > NULL) {
            int32_t * v2 = (int32_t *)(v1 + 4); // 0x8054bdf
            *(int32_t *)base = *v2;
            *v2 = (int32_t)*base;
        }
        // 0x8054d6d
        return;
    }
    int32_t v3 = 0;
    int32_t v4 = v3 + v1;
    mpsort_with_tmp((int32_t **)v4, n % 2, tmp, cmp);
    if (n == 3) {
        // 0x8054c70
        *(int32_t *)tmp = (int32_t)*base;
    } else {
        // 0x8054c7c
        mpsort_into_tmp(base, 0, tmp, cmp);
    }
    int32_t v5 = 0; // 0x8054cd3
    if (cmp >= NULL != cmp != NULL) {
        *(int32_t *)base = *(int32_t *)tmp;
        v5++;
        while (v5 != 0) {
            int32_t v6 = 4 * v5;
            *(int32_t *)(v6 + v1) = *(int32_t *)(v6 + (int32_t)tmp);
            v5++;
        }
        // 0x8054d6d
        return;
    }
    // 0x8054d05
    *(int32_t *)base = *(int32_t *)v4;
    int32_t v7 = 1; // 0x8054d19
    int32_t v8 = v7; // 0x8054d23
    int32_t v9 = 1; // 0x8054d23
    if (v7 == n) {
        // 0x8054d25
        memcpy((int32_t *)(4 + v1), (int32_t *)tmp, v3);
        // 0x8054d6d
        return;
    }
    *(int32_t *)(4 * v9 + v1) = *(int32_t *)(4 * v8 + v1);
    v9++;
    v8++;
    while (v8 != n) {
        // 0x8054d5a
        *(int32_t *)(4 * v9 + v1) = *(int32_t *)(4 * v8 + v1);
        v9++;
        v8++;
    }
    // 0x8054d25
    memcpy((int32_t *)(4 * v9 + v1), (int32_t *)tmp, v3);
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/mpsort.c
// Address range: 0x8054d6f - 0x8054d9f
// Line range:    154 - 156
void mpsort(int32_t ** base, int32_t n, int32_t (*cmp)(int32_t *, int32_t *)) {
    // 0x8054d6f
    mpsort_with_tmp(base, n, (int32_t **)(4 * n + (int32_t)base), cmp);
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/quote.c
// Address range: 0x8054da0 - 0x8054dc2
// Line range:    30 - 32
char * quote_n(int32_t n, char * name) {
    // 0x8054da0
    return quotearg_n_style(n, 5, name);
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/quote.c
// Address range: 0x8054dc2 - 0x8054ddd
// Line range:    38 - 40
char * quote(char * name) {
    // 0x8054dc2
    return quote_n(0, name);
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/quotearg.c
// Address range: 0x8054de0 - 0x8054e2c
// Line range:    106 - 112
int32_t * clone_quoting_options(int32_t * o) {
    int32_t v1 = *__errno_location(); // 0x8054deb
    char * v2 = xmemdup(o == NULL ? &default_quoting_options : o, 36); // 0x8054e13
    *__errno_location() = v1;
    return (int32_t *)v2;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/quotearg.c
// Address range: 0x8054e2c - 0x8054e4e
// Line range:    117 - 119
int32_t get_quoting_style(int32_t * o) {
    // 0x8054e2c
    return *((o == NULL ? &default_quoting_options : o));
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/quotearg.c
// Address range: 0x8054e4e - 0x8054e73
// Line range:    125 - 127
void set_quoting_style(int32_t * o, int32_t s) {
    // 0x8054e4e
    *((o == NULL ? &default_quoting_options : o)) = s;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/quotearg.c
// Address range: 0x8054e73 - 0x8054eed
// Line range:    136 - 144
int32_t set_char_quoting(int32_t * o, unsigned char c, uint32_t i) {
    int32_t v1 = o == NULL ? (int32_t)&default_quoting_options + 4 : (int32_t)o + 4; // 0x8054e9e
    uint32_t v2 = (int32_t)(c % 32); // 0x8054eb8
    int32_t * v3 = (int32_t *)(v1 + (int32_t)(4 * c / 32)); // 0x8054ec1
    uint32_t v4 = *v3;
    uint32_t result = (v4 >> v2) % 2; // 0x8054ec8
    *v3 = (result ^ i % 2) << v2 ^ v4;
    return result;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/quotearg.c
// Address range: 0x8054eed - 0x8054f1b
// Line range:    150 - 155
char * gettext_quote(char * msgid, int32_t s) {
    char * v1 = gettext(msgid); // 0x8054ef9
    return s == 6 == v1 == msgid ? (char *)&g12 : v1;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/quotearg.c
// Address range: 0x8054f1b - 0x8055667
// Line range:    175 - 508
int32_t quotearg_buffer_restyled(char * buffer, uint32_t buffersize, char * arg, int32_t argsize, int32_t quoting_style, int32_t * o) {
    int32_t v1 = __ctype_get_mb_cur_max(); // 0x8054f3a
    g56 = quoting_style;
    char v2 = 0; // 0x8054f5e
    int32_t len = 0; // 0x8054f5e
    int32_t str2 = 0; // 0x8054f5e
    int32_t v3 = 0; // 0x8054f5e
    switch (quoting_style) {
        case 2: {
            // 0x8055011
            v2 = 0;
            len = 1;
            str2 = (int32_t)"'";
            v3 = 1;
            if (buffersize != 0) {
                // 0x8055019
                *buffer = 39;
                v2 = 0;
                len = 1;
                str2 = (int32_t)"'";
                v3 = 1;
            }
            // break -> 0x8055037
            break;
        }
        case 3: {
            // 0x8054f60
            v2 = 1;
            len = 1;
            str2 = (int32_t)&g12;
            v3 = 1;
            if (buffersize != 0) {
                // 0x8054f68
                *buffer = 34;
                v2 = 1;
                len = 1;
                str2 = (int32_t)&g12;
                v3 = 1;
            }
            // break -> 0x8055037
            break;
        }
        case 4: {
            // 0x8054f8f
            v2 = 1;
            len = 0;
            str2 = 0;
            v3 = 0;
            // break -> 0x8055037
            break;
        }
        case 5: {
        }
        case 6: {
            char * v4 = gettext_quote("`", quoting_style); // 0x8054fa6
            char * str = gettext_quote("'", quoting_style); // 0x8054fbc
            char v5 = *v4; // 0x8054ff0
            int32_t v6 = 0; // 0x8054ff5
            if (v5 != 0) {
                int32_t v7 = (int32_t)v4; // 0x8054fe9
                uint32_t v8 = 0;
                if (v8 < buffersize) {
                    // 0x8054fd4
                    *(char *)(v8 + (int32_t)buffer) = v5;
                }
                int32_t v9 = v8 + 1; // 0x8054fe5
                v7++;
                char v10 = *(char *)v7; // 0x8054ff0
                v6 = v9;
                while (v10 != 0) {
                    // 0x8054fcc
                    v8 = v9;
                    if (v8 < buffersize) {
                        // 0x8054fd4
                        *(char *)(v8 + (int32_t)buffer) = v10;
                    }
                    // 0x8054fe5
                    v9 = v8 + 1;
                    v7++;
                    v10 = *(char *)v7;
                    v6 = v9;
                }
            }
            // 0x8054ff7
            v2 = 1;
            len = strlen(str);
            str2 = (int32_t)str;
            v3 = v6;
            // break -> 0x8055037
            break;
        }
    }
    int32_t v11 = (int32_t)arg;
    bool v12 = v2 == 0 | len == 0;
    int32_t v13 = (int32_t)buffer;
    int32_t v14 = v11 + 1;
    int32_t v15 = (int32_t)o + 4;
    int32_t v16 = argsize; // 0x805503e
    int32_t v17 = v3; // 0x805503e
    int32_t v18 = 0; // 0x805503e
    int32_t v19; // 0x8054f1b
    int32_t v20; // 0x8054f1b
    int32_t v21; // 0x8054f1b
    int32_t v22; // 0x8054f1b
    int32_t v23; // 0x8054f1b
    int32_t v24; // 0x8054f1b
    int32_t v25; // 0x8054f1b
    int32_t v26; // 0x8054f1b
    int32_t v27; // 0x8054f1b
    int32_t v28; // 0x8054f1b
    int32_t v29; // 0x8054f1b
    int32_t v30; // 0x8054f1b
    int32_t v31; // 0x8054f1b
    int32_t v32; // 0x8054f1b
    char v33; // 0x8054f1b
    char v34; // 0x8054f1b
    char v35; // 0x8054f1b
    char v36; // 0x8054f1b
    int32_t v37; // 0x8054f1b
    char v38; // 0x80550a0
    while (true) {
      lab_0x80555a8:
        // 0x80555a8
        v37 = v18;
        v23 = v17;
        v27 = v16;
        bool v39; // 0x8054f1b
        if (v27 != -1) {
            // 0x80555c1
            v39 = v37 == v27;
        } else {
            // 0x80555ae
            v39 = *(char *)(v37 + v11) == 0;
        }
        // 0x80555cb
        if (v39) {
            // break -> 0x80555d5
            break;
        }
        int32_t v40 = v37 + v11;
        int32_t v41 = v23; // 0x8055047
        if (!v12 && v37 + len <= v27) {
            int32_t memcmp_rc = memcmp(&((struct _TYPEDEF___mbstate_t *)v40)->e0, (int32_t *)str2, len); // 0x8055077
            v41 = v23;
            if (memcmp_rc == 0) {
                if (v23 < buffersize) {
                    // 0x8055088
                    *(char *)(v23 + v13) = 92;
                }
                // 0x8055094
                v41 = v23 + 1;
            }
        }
        // 0x8055098
        v20 = v41;
        v38 = *(char *)v40;
        g39 = v38;
        v35 = 110;
        v36 = 97;
        v29 = v37;
        v26 = v27;
        v33 = v38;
        v21 = v20;
        switch (v38) {
            case 0: {
                // 0x80550c3
                v30 = v37;
                v16 = v27;
                v34 = 0;
                v22 = v20;
                if (v2 == 0) {
                    goto lab_0x8055589;
                } else {
                    if (v20 < buffersize) {
                        // 0x80550d5
                        *(char *)(v20 + v13) = 92;
                    }
                    uint32_t v42 = v20 + 1; // 0x80550e1
                    if (v42 < buffersize) {
                        // 0x80550ed
                        *(char *)(v42 + v13) = 48;
                    }
                    uint32_t v43 = v20 + 2; // 0x80550f9
                    if (v43 < buffersize) {
                        // 0x8055105
                        *(char *)(v43 + v13) = 48;
                    }
                    // 0x8055111
                    v29 = v37;
                    v26 = v27;
                    v33 = 48;
                    v21 = v20 + 3;
                    goto lab_0x805553f;
                }
            }
            case 7: {
                goto lab_0x805522d;
            }
            case 8: {
                // 0x80551f8
                v36 = 98;
                goto lab_0x805522d;
            }
            case 9: {
                // 0x8055210
                v35 = 116;
                goto lab_0x8055223;
            }
            case 10: {
                goto lab_0x8055223;
            }
            case 11: {
                // 0x8055216
                v36 = 118;
                goto lab_0x805522d;
            }
            case 12: {
                // 0x80551fe
                v36 = 102;
                goto lab_0x805522d;
            }
            case 13: {
                // 0x805520a
                v35 = 114;
                goto lab_0x8055223;
            }
            case 32: {
                goto lab_0x8055276;
            }
            case 33: {
                goto lab_0x8055276;
            }
            case 34: {
                goto lab_0x8055276;
            }
            case 35: {
                goto lab_0x805526c;
            }
            case 36: {
                goto lab_0x8055276;
            }
            case 37: {
                goto lab_0x805553f;
            }
            case 38: {
                goto lab_0x8055276;
            }
            case 39: {
                // 0x8055285
                v28 = v27;
                if (quoting_style == 1) {
                    // 0x8055662
                    return quotearg_buffer_restyled(buffer, buffersize, arg, v28, 2, o);
                }
                // 0x8055295
                v29 = v37;
                v26 = v27;
                v33 = 39;
                v21 = v20;
                if (quoting_style == 2) {
                    if (v20 < buffersize) {
                        // 0x80552a7
                        *(char *)(v20 + v13) = 39;
                    }
                    uint32_t v44 = v20 + 1; // 0x80552b3
                    if (v44 < buffersize) {
                        // 0x80552bf
                        *(char *)(v44 + v13) = 92;
                    }
                    uint32_t v45 = v20 + 2; // 0x80552cb
                    if (v45 < buffersize) {
                        // 0x80552d7
                        *(char *)(v45 + v13) = 39;
                    }
                    // 0x80552e3
                    v29 = v37;
                    v26 = v27;
                    v33 = 39;
                    v21 = v20 + 3;
                }
                goto lab_0x805553f;
            }
            case 40: {
                goto lab_0x8055276;
            }
            case 41: {
                goto lab_0x8055276;
            }
            case 42: {
                goto lab_0x8055276;
            }
            case 43: {
                goto lab_0x805553f;
            }
            case 44: {
                goto lab_0x805553f;
            }
            case 45: {
                goto lab_0x805553f;
            }
            case 46: {
                goto lab_0x805553f;
            }
            case 47: {
                goto lab_0x805553f;
            }
            case 48: {
                goto lab_0x805553f;
            }
            case 49: {
                goto lab_0x805553f;
            }
            case 50: {
                goto lab_0x805553f;
            }
            case 51: {
                goto lab_0x805553f;
            }
            case 52: {
                goto lab_0x805553f;
            }
            case 53: {
                goto lab_0x805553f;
            }
            case 54: {
                goto lab_0x805553f;
            }
            case 55: {
                goto lab_0x805553f;
            }
            case 56: {
                goto lab_0x805553f;
            }
            case 57: {
                goto lab_0x805553f;
            }
            case 58: {
                goto lab_0x805553f;
            }
            case 59: {
                goto lab_0x8055276;
            }
            case 60: {
                goto lab_0x8055276;
            }
            case 61: {
                goto lab_0x8055276;
            }
            case 62: {
                goto lab_0x8055276;
            }
            case 63: {
                // 0x805511e
                v28 = v27;
                if (quoting_style == 1) {
                  lab_0x8055630:
                    // 0x8055662
                    return quotearg_buffer_restyled(buffer, buffersize, arg, v28, 2, o);
                }
                // 0x805512e
                v29 = v37;
                v26 = v27;
                v33 = 63;
                v21 = v20;
                if (quoting_style == 3) {
                    int32_t v46 = v37 + 2; // 0x805513b
                    v29 = v37;
                    v26 = v27;
                    v33 = 63;
                    v21 = v20;
                    if (v46 < v27) {
                        // 0x8055147
                        v29 = v37;
                        v26 = v27;
                        v33 = 63;
                        v21 = v20;
                        if (*(char *)(v37 + v14) == 63) {
                            char v47 = *(char *)(v46 + v11); // 0x8055164
                            uint32_t v48 = (int32_t)v47 - 33; // 0x805516a
                            v29 = v37;
                            v26 = v27;
                            v33 = 63;
                            v21 = v20;
                            if (v47 == 62 || v48 < 29) {
                                // 0x805517a
                                v29 = v37;
                                v26 = v27;
                                v33 = 63;
                                v21 = v20;
                                if ((1 << v48 % 32 & 0x380051c1) != 0) {
                                    if (v20 < buffersize) {
                                        // 0x80551ad
                                        *(char *)(v20 + v13) = 63;
                                    }
                                    uint32_t v49 = v20 + 1; // 0x80551b9
                                    if (v49 < buffersize) {
                                        // 0x80551c5
                                        *(char *)(v49 + v13) = 92;
                                    }
                                    uint32_t v50 = v20 + 2; // 0x80551d1
                                    if (v50 < buffersize) {
                                        // 0x80551dd
                                        *(char *)(v50 + v13) = 63;
                                    }
                                    // 0x80551e9
                                    v29 = v46;
                                    v26 = v27;
                                    v33 = v47;
                                    v21 = v20 + 3;
                                }
                            }
                        }
                    }
                }
                goto lab_0x805553f;
            }
            case 65: {
                goto lab_0x805553f;
            }
            case 66: {
                goto lab_0x805553f;
            }
            case 67: {
                goto lab_0x805553f;
            }
            case 68: {
                goto lab_0x805553f;
            }
            case 69: {
                goto lab_0x805553f;
            }
            case 70: {
                goto lab_0x805553f;
            }
            case 71: {
                goto lab_0x805553f;
            }
            case 72: {
                goto lab_0x805553f;
            }
            case 73: {
                goto lab_0x805553f;
            }
            case 74: {
                goto lab_0x805553f;
            }
            case 75: {
                goto lab_0x805553f;
            }
            case 76: {
                goto lab_0x805553f;
            }
            case 77: {
                goto lab_0x805553f;
            }
            case 78: {
                goto lab_0x805553f;
            }
            case 79: {
                goto lab_0x805553f;
            }
            case 80: {
                goto lab_0x805553f;
            }
            case 81: {
                goto lab_0x805553f;
            }
            case 82: {
                goto lab_0x805553f;
            }
            case 83: {
                goto lab_0x805553f;
            }
            case 84: {
                goto lab_0x805553f;
            }
            case 85: {
                goto lab_0x805553f;
            }
            case 86: {
                goto lab_0x805553f;
            }
            case 87: {
                goto lab_0x805553f;
            }
            case 88: {
                goto lab_0x805553f;
            }
            case 89: {
                goto lab_0x805553f;
            }
            case 90: {
                goto lab_0x805553f;
            }
            case 91: {
                goto lab_0x8055276;
            }
            case 92: {
                // 0x805521c
                v35 = 92;
                goto lab_0x8055223;
            }
            case 93: {
                goto lab_0x805553f;
            }
            case 94: {
                goto lab_0x8055276;
            }
            case 95: {
                goto lab_0x805553f;
            }
            case 96: {
                goto lab_0x8055276;
            }
            case 97: {
                goto lab_0x805553f;
            }
            case 98: {
                goto lab_0x805553f;
            }
            case 99: {
                goto lab_0x805553f;
            }
            case 100: {
                goto lab_0x805553f;
            }
            case 101: {
                goto lab_0x805553f;
            }
            case 102: {
                goto lab_0x805553f;
            }
            case 103: {
                goto lab_0x805553f;
            }
            case 104: {
                goto lab_0x805553f;
            }
            case 105: {
                goto lab_0x805553f;
            }
            case 106: {
                goto lab_0x805553f;
            }
            case 107: {
                goto lab_0x805553f;
            }
            case 108: {
                goto lab_0x805553f;
            }
            case 109: {
                goto lab_0x805553f;
            }
            case 110: {
                goto lab_0x805553f;
            }
            case 111: {
                goto lab_0x805553f;
            }
            case 112: {
                goto lab_0x805553f;
            }
            case 113: {
                goto lab_0x805553f;
            }
            case 114: {
                goto lab_0x805553f;
            }
            case 115: {
                goto lab_0x805553f;
            }
            case 116: {
                goto lab_0x805553f;
            }
            case 117: {
                goto lab_0x805553f;
            }
            case 118: {
                goto lab_0x805553f;
            }
            case 119: {
                goto lab_0x805553f;
            }
            case 120: {
                goto lab_0x805553f;
            }
            case 121: {
                goto lab_0x805553f;
            }
            case 122: {
                goto lab_0x805553f;
            }
            case 123: {
                goto lab_0x8055243;
            }
            case 124: {
                goto lab_0x8055276;
            }
            case 125: {
                goto lab_0x8055243;
            }
            case 126: {
                goto lab_0x805526c;
            }
            default: {
                if (v1 != 1) {
                    // 0x8055321
                    int32_t ps; // bp-64, 0x8054f1b
                    memset(&ps, 0, 8);
                    int32_t len2 = v27; // 0x805534b
                    if (v27 == -1) {
                        // 0x805534d
                        len2 = strlen(arg);
                    }
                    // 0x805535b
                    v24 = len2;
                    int32_t v51 = 0;
                    int32_t v52 = v51 + v37;
                    int32_t wstr = v52 + v11;
                    int32_t pwc; // bp-44, 0x8054f1b
                    uint32_t v53 = mbrtowc(&pwc, (char *)wstr, v24 - v52, (struct _TYPEDEF___mbstate_t *)&ps); // 0x805538d
                    v25 = v24;
                    v32 = v51;
                    while (v53 != 0 == (v53 != -1)) {
                        if (v53 == -2) {
                            // 0x80553be
                            v19 = v52;
                            v31 = v51;
                            v25 = v24;
                            v32 = v51;
                            if (v24 <= v52) {
                                goto lab_0x8055457;
                            } else {
                                goto lab_0x80553d0;
                            }
                        }
                        int32_t v54 = 1; // 0x80553e8
                        if (quoting_style == 1 == v53 > 1) {
                            while (true) {
                                int32_t v55 = (int32_t)*(char *)(v54 + wstr); // 0x8055404
                                g40 = v55 - 91;
                                v28 = v24;
                                switch (v55) {
                                    case 91: {
                                        return quotearg_buffer_restyled(buffer, buffersize, arg, v28, 2, o);
                                    }
                                    case 92: {
                                        return quotearg_buffer_restyled(buffer, buffersize, arg, v28, 2, o);
                                    }
                                    case 94: {
                                        return quotearg_buffer_restyled(buffer, buffersize, arg, v28, 2, o);
                                    }
                                    case 96: {
                                        return quotearg_buffer_restyled(buffer, buffersize, arg, v28, 2, o);
                                    }
                                    case 124: {
                                        return quotearg_buffer_restyled(buffer, buffersize, arg, v28, 2, o);
                                    }
                                    default: {
                                        int32_t v56 = v54 + 1; // 0x805541f
                                        v54 = v56;
                                        if (v56 >= v53) {
                                            // break -> 0x805542b
                                            break;
                                        }
                                        goto lab_0x80553f3;
                                    }
                                }
                            }
                        }
                        // 0x805542b
                        iswprint(pwc);
                        int32_t v57 = v53 + v51; // 0x8055441
                        int32_t v58 = mbsinit((struct _TYPEDEF___mbstate_t *)&ps); // 0x805544a
                        v25 = v24;
                        v32 = v57;
                        if (v58 != 0) {
                            // break -> 0x8055457
                            break;
                        }
                        v51 = v57;
                        v52 = v51 + v37;
                        wstr = v52 + v11;
                        v53 = mbrtowc(&pwc, (char *)wstr, v24 - v52, (struct _TYPEDEF___mbstate_t *)&ps);
                        v25 = v24;
                        v32 = v51;
                    }
                } else {
                    // 0x80552f2
                    __ctype_b_loc();
                    v25 = v27;
                    v32 = 1;
                }
                goto lab_0x8055457;
            }
        }
    }
    // 0x80555d5
    if (quoting_style == 1 == v37 == 0) {
        // 0x8055662
        return quotearg_buffer_restyled(buffer, buffersize, arg, v27, 2, o);
    }
    int32_t result = v23; // 0x80555e5
    if (str2 != 0) {
        char v59 = *(char *)str2; // 0x805560d
        result = v23;
        if (v59 != 0) {
            if (v23 < buffersize) {
                // 0x80555f1
                *(char *)(v23 + v13) = v59;
            }
            int32_t v60 = v23 + 1; // 0x8055602
            int32_t v61 = str2 + 1; // 0x8055606
            char v62 = *(char *)v61; // 0x805560d
            int32_t v63 = v61; // 0x8055612
            result = v60;
            while (v62 != 0) {
                uint32_t v64 = v60;
                if (v64 < buffersize) {
                    // 0x80555f1
                    *(char *)(v64 + v13) = v62;
                }
                // 0x8055602
                v60 = v64 + 1;
                v61 = v63 + 1;
                v62 = *(char *)v61;
                v63 = v61;
                result = v60;
            }
        }
    }
    // 0x8055614
    if (result < buffersize) {
        // 0x805561c
        *(char *)(result + v13) = 0;
    }
    // 0x8055662
    return result;
  lab_0x805522d:;
    int32_t v65 = v37; // 0x8055231
    int32_t v66 = v27; // 0x8055231
    char v67 = v36; // 0x8055231
    int32_t v68 = v20; // 0x8055231
    v30 = v37;
    v16 = v27;
    v34 = v38;
    v22 = v20;
    if (v2 == 0) {
        goto lab_0x8055589;
    } else {
        goto lab_0x8055571;
    }
  lab_0x8055223:
    // 0x8055223
    v36 = v35;
    v28 = v27;
    if (quoting_style == 1) {
        // 0x8055662
        return quotearg_buffer_restyled(buffer, buffersize, arg, v28, 2, o);
    }
    goto lab_0x805522d;
  lab_0x8055276:
    // 0x8055276
    v29 = v37;
    v26 = v27;
    v33 = v38;
    v21 = v20;
    v28 = v27;
    if (quoting_style == 1) {
        // 0x8055662
        return quotearg_buffer_restyled(buffer, buffersize, arg, v28, 2, o);
    }
    goto lab_0x805553f;
  lab_0x805526c:
    // 0x805526c
    v29 = v37;
    v26 = v27;
    v33 = v38;
    v21 = v20;
    v28 = v27;
    if (quoting_style == 1 == v37 == 0) {
        // 0x8055662
        return quotearg_buffer_restyled(buffer, buffersize, arg, v28, 2, o);
    }
    goto lab_0x805553f;
  lab_0x805553f:;
    int32_t v69 = v21;
    char v70 = v33;
    int32_t v71 = v26;
    int32_t v72 = v29;
    v30 = v72;
    v16 = v71;
    v34 = v70;
    v22 = v69;
    if (v2 != 1) {
        goto lab_0x8055589;
    } else {
        int32_t v73 = *(int32_t *)(v15 + (int32_t)(4 * v70 / 32)); // 0x8055557
        unsigned char v74 = v70 % 32;
        v65 = v72;
        v66 = v71;
        v67 = v70;
        v68 = v69;
        v30 = v72;
        v16 = v71;
        v34 = v70;
        v22 = v69;
        if ((v73 & (v74 == 0 ? 1 : 1 << (int32_t)v74)) == 0) {
            goto lab_0x8055589;
        } else {
            goto lab_0x8055571;
        }
    }
  lab_0x8055243:;
    bool v75; // 0x8054f1b
    if (v27 != -1) {
        // 0x805525a
        v75 = v27 == 1;
    } else {
        // 0x8055249
        v75 = *(char *)v14 == 0;
    }
    // 0x8055262
    v29 = v37;
    v26 = v27;
    v33 = v38;
    v21 = v20;
    if (!v75) {
        goto lab_0x805553f;
    } else {
        goto lab_0x805526c;
    }
  lab_0x8055457:;
    uint32_t v76 = v32;
    int32_t v77 = v25;
    v29 = v37;
    v26 = v77;
    v33 = v38;
    v21 = v20;
    if (v2 != 1 == v76 < 2) {
        goto lab_0x805553f;
    } else {
        int32_t v78 = v20;
        unsigned char v79 = v38;
        char v80 = v79; // 0x805548b
        int32_t v81 = v78; // 0x805548b
        uint32_t v82; // 0x80554ac
        uint32_t v83; // 0x80554cd
        if (v2 != 0) {
            if (v78 < buffersize) {
                // 0x80554a0
                *(char *)(v78 + v13) = 92;
            }
            // 0x80554ac
            v82 = v78 + 1;
            if (v82 < buffersize) {
                // 0x80554b8
                *(char *)(v82 + v13) = v79 / 64 | 48;
            }
            // 0x80554cd
            v83 = v78 + 2;
            if (v83 < buffersize) {
                // 0x80554d9
                *(char *)(v83 + v13) = v79 / 8 % 8 | 48;
            }
            // 0x80554f1
            v80 = v79 % 8 | 48;
            v81 = v78 + 3;
        }
        int32_t v84 = v81;
        char v85 = v80;
        int32_t v86 = v37 + 1; // 0x8055505
        v30 = v37;
        v16 = v77;
        v34 = v85;
        v22 = v84;
        while (v86 < v76 + v37) {
            if (v84 < buffersize) {
                // 0x8055515
                *(char *)(v84 + v13) = v85;
            }
            // 0x8055524
            v78 = v84 + 1;
            v79 = *(char *)(v86 + v11);
            int32_t v87 = v86;
            v80 = v79;
            v81 = v78;
            if (v2 != 0) {
                if (v78 < buffersize) {
                    // 0x80554a0
                    *(char *)(v78 + v13) = 92;
                }
                // 0x80554ac
                v82 = v78 + 1;
                if (v82 < buffersize) {
                    // 0x80554b8
                    *(char *)(v82 + v13) = v79 / 64 | 48;
                }
                // 0x80554cd
                v83 = v78 + 2;
                if (v83 < buffersize) {
                    // 0x80554d9
                    *(char *)(v83 + v13) = v79 / 8 % 8 | 48;
                }
                // 0x80554f1
                v80 = v79 % 8 | 48;
                v81 = v78 + 3;
            }
            // 0x8055502
            v84 = v81;
            v85 = v80;
            v86 = v87 + 1;
            v30 = v87;
            v16 = v77;
            v34 = v85;
            v22 = v84;
        }
        goto lab_0x8055589;
    }
  lab_0x8055589:;
    uint32_t v88 = v22;
    if (v88 < buffersize) {
        // 0x8055591
        *(char *)(v88 + v13) = v34;
    }
    // 0x80555a0
    v17 = v88 + 1;
    v18 = v30 + 1;
    goto lab_0x80555a8;
  lab_0x8055571:;
    uint32_t v89 = v68;
    if (v89 < buffersize) {
        // 0x8055579
        *(char *)(v89 + v13) = 92;
    }
    // 0x8055585
    v30 = v65;
    v16 = v66;
    v34 = v67;
    v22 = v89 + 1;
    goto lab_0x8055589;
  lab_0x80553d0:;
    int32_t v90 = v31;
    v25 = v24;
    v32 = v90;
    if (*(char *)(v19 + v11) != 0) {
        int32_t v91 = v90 + 1; // 0x80553ba
        int32_t v92 = v91 + v37; // 0x80553c4
        v19 = v92;
        v31 = v91;
        v25 = v24;
        v32 = v91;
        if (v92 >= v24) {
            goto lab_0x8055457;
        } else {
            goto lab_0x80553d0;
        }
    } else {
        goto lab_0x8055457;
    }
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/quotearg.c
// Address range: 0x8055667 - 0x80556d6
// Line range:    523 - 530
int32_t quotearg_buffer(char * buffer, int32_t buffersize, char * arg, int32_t argsize, int32_t * o) {
    int32_t v1 = *__errno_location(); // 0x805568d
    int32_t * v2 = o == NULL ? &default_quoting_options : o; // 0x8055695
    int32_t result = quotearg_buffer_restyled(buffer, buffersize, arg, argsize, *v2, v2); // 0x80556bd
    *__errno_location() = v1;
    return result;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/quotearg.c
// Address range: 0x80557ed - 0x80559ad
// Line range:    592 - 638
char * quotearg_n_options(uint32_t n, char * arg, int32_t argsize, int32_t * options) {
    int32_t * v1 = __errno_location(); // 0x80557f4
    if (n < 0) {
        // 0x8055812
        abort();
        // UNREACHABLE
    }
    int32_t v2 = *v1; // 0x80557f9
    int32_t * v3 = slotvec; // 0x8055804
    int32_t v4 = (int32_t)v3; // 0x805581f
    if (nslots <= n) {
        int32_t v5 = n + 1; // 0x8055828
        if (v5 >= 0x20000000) {
            // 0x8055844
            xalloc_die();
            // UNREACHABLE
        }
        char * v6 = xrealloc(v3 != &slotvec0 ? (char *)v3 : NULL, 8 * v5); // 0x8055874
        v4 = (int32_t)v6;
        *(int32_t *)&slotvec = v4;
        if (v3 == &slotvec0) {
            // 0x805588a
            *(int32_t *)v6 = slotvec0;
            *(int32_t *)(v4 + 4) = (int32_t)g27;
        }
        int32_t v7 = nslots;
        memset((int32_t *)(8 * v7 + v4), 0, 8 * (v5 - v7));
        nslots = v5;
    }
    int32_t v8 = v4 + 8 * n; // 0x80558dc
    int32_t * v9 = (int32_t *)v8; // 0x80558df
    uint32_t v10 = *v9; // 0x80558df
    int32_t * v11 = (int32_t *)(v8 + 4); // 0x80558ed
    int32_t v12 = *v11; // 0x80558ed
    char * result = (char *)v12; // 0x80558f0
    uint32_t v13 = quotearg_buffer(result, v10, arg, argsize, options); // 0x8055915
    if (v10 > v13) {
        // 0x8055998
        *__errno_location() = v2;
        return result;
    }
    int32_t v14 = v13 + 1; // 0x8055933
    *v9 = v14;
    if (result != &slot0[0]) {
        // 0x8055947
        free((int32_t *)v12);
    }
    char * result2 = xcharalloc(v14); // 0x8055963
    *v11 = (int32_t)result2;
    quotearg_buffer(result2, v14, arg, argsize, options);
    // 0x8055998
    *__errno_location() = v2;
    return result2;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/quotearg.c
// Address range: 0x80559ad - 0x80559d7
// Line range:    642 - 644
char * quotearg_n(int32_t n, char * arg) {
    // 0x80559ad
    return quotearg_n_options(n, arg, -1, &default_quoting_options);
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/quotearg.c
// Address range: 0x80559d7 - 0x80559f2
// Line range:    648 - 650
char * quotearg(char * arg) {
    // 0x80559d7
    return quotearg_n(0, arg);
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/quotearg.c
// Address range: 0x80559f2 - 0x8055a5f
// Line range:    655 - 660
int32_t quoting_options_from_style(int32_t style) {
    // 0x80559f2
    int32_t v1; // bp-40, 0x80559f2
    memset(&v1, 0, 32);
    *(int32_t *)(style + 4) = v1;
    return style;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/quotearg.c
// Address range: 0x8055a5f - 0x8055a9d
// Line range:    664 - 667
char * quotearg_n_style(int32_t n, int32_t s, char * arg) {
    // 0x8055a5f
    int32_t v1; // bp-40, 0x8055a5f
    quoting_options_from_style((int32_t)&v1);
    return quotearg_n_options(n, arg, -1, &v1);
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/quotearg.c
// Address range: 0x8055afc - 0x8055b8f
// Line range:    685 - 690
char * quotearg_char(char * arg, char ch) {
    int32_t v1 = default_quoting_options; // bp-40, 0x8055b0d
    set_char_quoting(&v1, ch, 1);
    return quotearg_n_options(0, arg, -1, &v1);
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/quotearg.c
// Address range: 0x8055b8f - 0x8055baa
// Line range:    694 - 696
char * quotearg_colon(char * arg) {
    // 0x8055b8f
    return quotearg_char(arg, 58);
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/strftime.c
// Address range: 0x8055bac - 0x8055bee
// Line range:    314 - 318
char * memcpy_lowcase(char * dest, char * src, int32_t len) {
    if (len == 0) {
        // 0x8055be5
        return dest;
    }
    int32_t v1 = len;
    v1--;
    int32_t v2 = tolower((int32_t)*(char *)(v1 + (int32_t)src)); // 0x8055bcf
    *(char *)(v1 + (int32_t)dest) = (char)v2;
    while (v1 != 0) {
        // 0x8055bb5
        v1--;
        v2 = tolower((int32_t)*(char *)(v1 + (int32_t)src));
        *(char *)(v1 + (int32_t)dest) = (char)v2;
    }
    // 0x8055be5
    return dest;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/strftime.c
// Address range: 0x8055bee - 0x8055c30
// Line range:    323 - 327
char * memcpy_uppcase(char * dest, char * src, int32_t len) {
    if (len == 0) {
        // 0x8055c27
        return dest;
    }
    int32_t v1 = len;
    v1--;
    int32_t v2 = toupper((int32_t)*(char *)(v1 + (int32_t)src)); // 0x8055c11
    *(char *)(v1 + (int32_t)dest) = (char)v2;
    while (v1 != 0) {
        // 0x8055bf7
        v1--;
        v2 = toupper((int32_t)*(char *)(v1 + (int32_t)src));
        *(char *)(v1 + (int32_t)dest) = (char)v2;
    }
    // 0x8055c27
    return dest;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/strftime.c
// Address range: 0x8055c30 - 0x805865e
// Line range:    420 - 1430
int32_t strftime_case_(bool upcase, char * s, int32_t maxsize, char * format2, struct tm * tp, int32_t ut, int32_t ns) {
    int32_t v1 = (int32_t)tp;
    int32_t v2 = __readgsdword(20); // bp-16, 0x8055c65
    int32_t * v3 = (int32_t *)(v1 + 8); // 0x8055c70
    int32_t v4 = *v3; // 0x8055c70
    int32_t v5; // 0x8055c30
    if (v4 < 13) {
        // 0x8055cc4
        v5 = v4 != 0 ? v4 : 12;
    } else {
        // 0x8055cbb
        v5 = v4 - 12;
    }
    char v6 = *format2; // 0x805860e
    int32_t v7 = 0; // 0x8058613
    char * v8 = s; // 0x8058613
    char v9; // 0x8055c30
    char * v10; // 0x8055c30
    char v11; // 0x8055e8c
    char * str2; // 0x8055c30
    char * v12; // 0x8055c30
    char * v13; // 0x8055c30
    int32_t v14; // 0x8055c30
    int32_t v15; // 0x8055c30
    int32_t v16; // 0x8055c30
    int32_t v17; // 0x8055c30
    int32_t v18; // 0x8055c30
    char * v19; // 0x8055c30
    char * v20; // 0x8055c30
    bool v21; // 0x8055c30
    bool v22; // 0x8055c30
    char v23; // 0x8055c30
    char v24; // 0x8055c30
    int32_t tm; // bp-1428, 0x8055c30
    int32_t v25; // 0x8055c30
    int32_t v26; // 0x8055c30
    int32_t v27; // 0x8055c30
    int32_t * v28; // 0x8055c30
    int32_t * v29; // 0x8055c30
    int32_t v30; // 0x8055c30
    int32_t v31; // 0x8055c30
    char * v32; // 0x8055c30
    char * v33; // 0x8055c30
    int32_t v34; // 0x8056139
    char v35; // 0x8056146
    int32_t * v36; // 0x8055c30
    int32_t * v37; // 0x8055c30
    char * v38; // 0x8055c30
    char * v39; // 0x8055c30
    if (v6 != 0) {
        // 0x8055ce8
        v36 = (int32_t *)(v1 + 20);
        v37 = (int32_t *)(v1 + 24);
        v28 = (int32_t *)(v1 + 28);
        v29 = (int32_t *)(v1 + 12);
        v30 = &v2;
        v31 = &tm;
        v32 = (char *)(v31 | 1);
        v33 = (char *)(v31 | 2);
        v9 = v6;
        v10 = format2;
        v26 = (int32_t)format2;
        v14 = *(int32_t *)(v1 + 40);
        v19 = NULL;
        v38 = s;
        v16 = 0;
        while (true) {
          lab_0x8055ce8:
            // 0x8055ce8
            v17 = v16;
            v39 = v38;
            v20 = v19;
            v15 = v14;
            v27 = v26;
            str2 = v10;
            v11 = v9;
            int32_t v40 = v11; // 0x8055d2a
            if (v11 > 63) {
                if (v11 == 64) {
                    goto lab_0x8055eb4;
                } else {
                    if (v11 < 96 || v40 < 127) {
                        goto lab_0x8055da5;
                    } else {
                        goto lab_0x8055eb4;
                    }
                }
            } else {
                if (v11 > 37) {
                    goto lab_0x8055da5;
                } else {
                    if (v11 > 35) {
                        // 0x8055d6b
                        v18 = v27;
                        v12 = NULL;
                        v22 = upcase;
                        v23 = 0;
                        if (v11 == 37) {
                            while (true) {
                              lab_0x8056139_2:
                                // 0x8056139
                                v13 = v12;
                                int32_t v41 = v18; // 0x8055c30
                                bool v42 = v22; // 0x8055c30
                                char v43 = v23; // 0x8055c30
                                while (true) {
                                    // 0x8056139
                                    v21 = v42;
                                    int32_t v44 = v41; // 0x8055c30
                                    char v45 = v43; // 0x8055c30
                                    while (true) {
                                      lab_0x8056139:
                                        // 0x8056139
                                        v24 = v45;
                                        v34 = v44 + 1;
                                        v35 = *(char *)v34;
                                        if (v35 == 48) {
                                            // break (via goto) -> 0x805618a
                                            goto lab_0x805618a;
                                        }
                                        if (v35 > 48) {
                                            // break -> 0x8056178
                                            break;
                                        }
                                        // 0x8056164
                                        v44 = v34;
                                        v45 = 1;
                                        switch (v35) {
                                            case 35: {
                                                goto lab_0x8056139;
                                            }
                                            case 45: {
                                                goto lab_0x805618a;
                                            }
                                            default: {
                                                goto lab_0x80561b0;
                                            }
                                        }
                                    }
                                    // 0x8056178
                                    v41 = v34;
                                    v42 = true;
                                    v43 = v24;
                                    if (v35 != 94) {
                                        if (v35 != 95) {
                                            goto lab_0x80561b0;
                                        } else {
                                            goto lab_0x805618a;
                                        }
                                    }
                                }
                                goto lab_0x805618a;
                            }
                            goto lab_0x80561b0;
                        } else {
                            goto lab_0x8055eb4;
                        }
                    } else {
                        if (v11 > 31 || v40 < 14) {
                            goto lab_0x8055da5;
                        } else {
                            goto lab_0x8055eb4;
                        }
                    }
                }
            }
        }
    } else {
      lab_0x8058619:
        // 0x8058619
        v25 = v7;
        if (maxsize != 0 && v8 != NULL) {
            // 0x8058628
            *v8 = 0;
            v25 = v7;
        }
    }
  lab_0x805863d_12:;
    int32_t result = v25; // 0x805864d
    if (v2 != __readgsdword(20)) {
        // 0x805864f
        __stack_chk_fail();
        result = &g49;
    }
    // 0x8058654
    return result;
  lab_0x805618a:
    // 0x805618a
    v18 = v34;
    v12 = (char *)(int32_t)v35;
    v22 = v21;
    v23 = v24;
    goto lab_0x8056139_2;
  lab_0x80561b0:;
    int32_t v46 = v35;
    if (v35 == 57 || v46 < 57) {
        int32_t v47; // 0x8055c30
        uint32_t v48 = v47;
        int32_t v49; // 0x8055c30
        int32_t v50 = v49;
        int32_t v51 = 0x7fffffff; // 0x80561dc
        char v52; // 0x8055c30
        char v53; // 0x8056225
        if (v48 <= 0xccccccc) {
            // 0x80561de
            v53 = v52;
            v51 = 0x7fffffff;
            if (v53 < 56 || v48 != 0xccccccc) {
                // 0x805620a
                v51 = (int32_t)v53 - 48 + 10 * v48;
            }
        }
        int32_t v54 = v51;
        int32_t v55 = v50 + 1; // 0x8056234
        char v56 = *(char *)v55; // 0x8056241
        int32_t v57 = v56;
        v52 = v56;
        v49 = v55;
        v47 = v54;
        while (v56 == 57 || v57 < 57) {
            // 0x80561d2
            v48 = v47;
            v50 = v49;
            v51 = 0x7fffffff;
            if (v48 <= 0xccccccc) {
                // 0x80561de
                v53 = v52;
                v51 = 0x7fffffff;
                if (v53 < 56 || v48 != 0xccccccc) {
                    // 0x805620a
                    v51 = (int32_t)v53 - 48 + 10 * v48;
                }
            }
            // 0x8056234
            v54 = v51;
            v55 = v50 + 1;
            v56 = *(char *)v55;
            v57 = v56;
            v52 = v56;
            v49 = v55;
            v47 = v54;
        }
    }
    int32_t v58 = -1;
    char v59 = v35; // 0x8056255
    int32_t v60 = v34 + (int32_t)(v59 != 69 != v59 != 79);
    char * v61 = v59 != 69 == (v59 != 79) ? NULL : (char *)v46;
    char * v62 = (char *)v60; // 0x805629e
    char v63 = *v62; // 0x805629e
    int32_t v64 = v63; // 0x80562b7
    g41 = v64;
    char * v65 = "%H:%M"; // 0x80562c6
    char v66 = 0; // 0x80562c6
    bool v67 = v21; // 0x80562c6
    char v68 = v63; // 0x80562c6
    char v69 = 0; // 0x80562c6
    char v70 = v63; // 0x80562c6
    int32_t v71 = v60; // 0x80562c6
    int32_t v72 = 0; // 0x80562c6
    int32_t v73 = v60; // 0x80562c6
    bool v74 = v21; // 0x80562c6
    bool v75; // 0x8055c30
    char * v76; // 0x8055c30
    char * v77; // 0x8055c30
    char * v78; // 0x8055c30
    char * v79; // 0x8055c30
    int32_t v80; // 0x8055c30
    int32_t v81; // 0x8055c30
    int32_t v82; // 0x8055c30
    int32_t v83; // 0x8055c30
    int32_t v84; // 0x8055c30
    int32_t v85; // 0x8055c30
    char * v86; // 0x8055c30
    int32_t v87; // 0x8055c30
    bool v88; // 0x8055c30
    char v89; // 0x8055c30
    int32_t v90; // 0x8055c30
    int32_t v91; // 0x8055c30
    int32_t v92; // 0x8055c30
    int32_t v93; // 0x8055c30
    int32_t v94; // 0x8055c30
    int32_t v95; // 0x8055c30
    int32_t v96; // 0x8055c30
    char * v97; // 0x8055c30
    int32_t v98; // 0x8055c30
    int32_t v99; // 0x8055c30
    int32_t v100; // 0x8055c30
    int32_t v101; // 0x8055c30
    char * v102; // 0x8055c30
    switch (v64) {
        case 0: {
            // 0x8058437
            v73 = v60 - 1;
            v74 = v21;
            goto lab_0x805843e;
        }
        case 37: {
            // 0x80562c8
            v73 = v60;
            v74 = v21;
            if (v61 != NULL) {
                goto lab_0x805843e;
            } else {
                int32_t v103 = v58 - 1; // 0x80562eb
                uint32_t v104 = (v103 & (int32_t)(v103 < 0) - 1) + 1; // 0x8056304
                if (v104 >= maxsize - v17) {
                    // break -> 0x805863d
                    break;
                }
                char * v105 = NULL; // 0x805633b
                if (v39 != NULL) {
                    char * v106 = v39; // 0x8056348
                    if (v103 >= 1) {
                        if (v13 != (char *)48) {
                            // 0x805638a
                            memset((int32_t *)v39, 32, v103);
                            v106 = (char *)(v103 + (int32_t)v39);
                        } else {
                            // 0x805635c
                            memset((int32_t *)v39, 48, v103);
                            v106 = (char *)(v103 + (int32_t)v39);
                        }
                    }
                    // 0x80563b6
                    *v106 = *v62;
                    v105 = (char *)((int32_t)v106 + 1);
                }
                // 0x80563d3
                v81 = v104 + v17;
                v102 = v105;
                v86 = v20;
                v80 = v15;
                v85 = v60;
                goto lab_0x8058601;
            }
        }
        case 58: {
            int32_t v107 = 1;
            int32_t v108 = v107 + v60; // 0x80581a6
            char v109 = *(char *)v108; // 0x80581a8
            int32_t v110 = v107 + 1; // 0x80581ad
            while (v109 == 58) {
                // 0x805819a
                v107 = v110;
                v108 = v107 + v60;
                v109 = *(char *)v108;
                v110 = v107 + 1;
            }
            // 0x80581af
            v71 = v108;
            v72 = v107;
            v73 = v60;
            v74 = v21;
            if (v109 != 122) {
                goto lab_0x805843e;
            } else {
                goto lab_0x80581e0;
            }
        }
        case 65: {
            // 0x8056411
            v73 = v60;
            v74 = v21;
            if (v61 != NULL) {
                goto lab_0x805843e;
            } else {
                // 0x805641e
                v66 = 0;
                v67 = v21 | v24 != 0;
                v68 = v63;
                goto lab_0x805663b;
            }
        }
        case 66: {
            // 0x8056467
            v73 = v60;
            v74 = v21;
            if (v61 != NULL) {
                goto lab_0x805843e;
            } else {
                // 0x8056474
                v66 = 0;
                v67 = v21 | v24 != 0;
                v68 = v63;
                goto lab_0x805663b;
            }
        }
        case 67: {
            // 0x805686c
            v66 = 0;
            v67 = v21;
            v68 = v63;
            v73 = v60;
            v74 = v21;
            switch ((int32_t)v61) {
                case 79: {
                    goto lab_0x805843e;
                }
                case 69: {
                    goto lab_0x805663b;
                }
                default: {
                    int32_t v111 = *v36; // 0x805688c
                    int32_t v112 = v111 / 100; // 0x80568ab
                    int32_t v113 = v112 + 19; // 0x80568af
                    int32_t v114 = v111 + 1900; // 0x805693d
                    v83 = v60;
                    v78 = v13;
                    v92 = 2;
                    v100 = v58;
                    v88 = v114 < 0 != ((v114 ^ v111) & (v111 ^ -0x80000000)) < 0;
                    v95 = v113 - (int32_t)(v113 > 0 == -100 * v112 + v111 < 0);
                    v89 = 0;
                    v96 = 0;
                    goto lab_0x8056a2b;
                }
            }
        }
        case 68: {
            // 0x805696e
            v65 = "%m/%d/%y";
            v73 = v60;
            v74 = v21;
            if (v61 != NULL) {
                goto lab_0x805843e;
            } else {
                goto lab_0x80564a6;
            }
        }
        case 70: {
            // 0x80572d0
            v65 = "%Y-%m-%d";
            v73 = v60;
            v74 = v21;
            if (v61 != NULL) {
                goto lab_0x805843e;
            } else {
                goto lab_0x80564a6;
            }
        }
        case 71: {
            goto lab_0x8057992;
        }
        case 72: {
            // 0x80572ec
            v73 = v60;
            v74 = v21;
            if (v61 == (char *)69) {
                goto lab_0x805843e;
            } else {
                // 0x80572f9
                v77 = v13;
                v91 = 2;
                v99 = v58;
                v94 = *v3;
                goto lab_0x80569ff;
            }
        }
        case 73: {
            // 0x8057317
            v77 = v13;
            v91 = 2;
            v99 = v58;
            v94 = v5;
            v73 = v60;
            v74 = v21;
            if (v61 == (char *)69) {
                goto lab_0x805843e;
            } else {
                goto lab_0x80569ff;
            }
        }
        case 77: {
            // 0x80573d5
            v73 = v60;
            v74 = v21;
            if (v61 == (char *)69) {
                goto lab_0x805843e;
            } else {
                // 0x80573e2
                v77 = v13;
                v91 = 2;
                v99 = v58;
                v94 = *(int32_t *)(v1 + 4);
                goto lab_0x80569ff;
            }
        }
        case 78: {
            // 0x8057443
            v73 = v60;
            v74 = v21;
            if (v61 == (char *)69) {
                goto lab_0x805843e;
            } else {
                // 0x8057450
                v77 = v13;
                v91 = 9;
                v99 = 9;
                v94 = ns;
                if (v58 != -1) {
                    // 0x80574af
                    v77 = v13;
                    v91 = v58;
                    v99 = v58;
                    v94 = ns;
                    int32_t v115 = v58; // 0x80574b6
                    if (v58 < 9) {
                        int32_t v116 = ns / 10; // 0x805749e
                        int32_t v117 = v115 + 1; // 0x80574a8
                        v77 = v13;
                        v91 = v58;
                        v99 = v58;
                        v94 = v116;
                        v115 = v117;
                        int32_t v118 = v116; // 0x80574b6
                        while (v117 != 9) {
                            // 0x805747c
                            v116 = v118 / 10;
                            v117 = v115 + 1;
                            v77 = v13;
                            v91 = v58;
                            v99 = v58;
                            v94 = v116;
                            v115 = v117;
                            v118 = v116;
                        }
                    }
                }
                goto lab_0x80569ff;
            }
        }
        case 80: {
            // 0x80575d0
            v69 = 1;
            v70 = 112;
            goto lab_0x80575e1;
        }
        case 82: {
            goto lab_0x80564a6;
        }
        case 83: {
            // 0x8057610
            v73 = v60;
            v74 = v21;
            if (v61 == (char *)69) {
                goto lab_0x805843e;
            } else {
                // 0x805761d
                v77 = v13;
                v91 = 2;
                v99 = v58;
                v94 = tp->e0;
                goto lab_0x80569ff;
            }
        }
        case 84: {
            // 0x80577ae
            v65 = "%H:%M:%S";
            goto lab_0x80564a6;
        }
        case 85: {
            // 0x8057930
            v73 = v60;
            v74 = v21;
            if (v61 == (char *)69) {
                goto lab_0x805843e;
            } else {
                int32_t v119 = *v28 - *v37 + 7; // 0x805795f
                v77 = v13;
                v91 = 2;
                v99 = v58;
                v94 = (v119 + (int32_t)(-0x6db6db6d * (int64_t)v119 / 0x100000000) >> 2) - (v119 >> 31);
                goto lab_0x80569ff;
            }
        }
        case 86: {
            goto lab_0x8057992;
        }
        case 87: {
            // 0x8057dff
            v73 = v60;
            v74 = v21;
            if (v61 == (char *)69) {
                goto lab_0x805843e;
            } else {
                int32_t v120 = *v28; // 0x8057e1c
                int32_t v121 = *v37; // 0x8057e25
                int32_t v122 = v121 + 6; // 0x8057e28
                int32_t v123 = v120 + 1 - v121 + 7 * ((v122 + (int32_t)(-0x6db6db6d * (int64_t)v122 / 0x100000000) >> 2) - (v122 >> 31)); // 0x8057e75
                v77 = v13;
                v91 = 2;
                v99 = v58;
                v94 = (v123 + (int32_t)(-0x6db6db6d * (int64_t)v123 / 0x100000000) >> 2) - (v123 >> 31);
                goto lab_0x80569ff;
            }
        }
        case 88: {
            // 0x805779c
            v66 = 0;
            v67 = v21;
            v68 = v63;
            v73 = v60;
            v74 = v21;
            if (v61 == (char *)79) {
                goto lab_0x805843e;
            } else {
                goto lab_0x805663b;
            }
        }
        case 89: {
            // 0x8057ed3
            v66 = 0;
            v67 = v21;
            v68 = v63;
            v73 = v60;
            v74 = v21;
            switch ((int32_t)v61) {
                case 69: {
                    goto lab_0x805663b;
                }
                case 79: {
                    goto lab_0x805843e;
                }
                default: {
                    int32_t v124 = *v36; // 0x8057efd
                    int32_t v125 = v124 + 1900; // 0x8057f00
                    v83 = v60;
                    v78 = v13;
                    v92 = 4;
                    v100 = v58;
                    v88 = v125 < 0 != ((v125 ^ v124) & (v124 ^ -0x80000000)) < 0;
                    v95 = v125;
                    v89 = 0;
                    v96 = 0;
                    goto lab_0x8056a2b;
                }
            }
        }
        case 90: {
            int32_t v126 = v15 != 0 ? v15 : (int32_t)&g13;
            char * str = (char *)v126; // 0x805800c
            int32_t len = strlen(str); // 0x805800c
            int32_t v127 = v58 - len; // 0x8058023
            uint32_t v128 = (v127 & (int32_t)(v127 < 0) - 1) + len; // 0x805803c
            if (v128 >= maxsize - v17) {
                // break -> 0x805863d
                break;
            }
            char * v129 = NULL; // 0x8058073
            if (v39 != NULL) {
                char * v130 = v39; // 0x8058080
                if (v127 >= 1) {
                    if (v13 != (char *)48) {
                        // 0x80580c2
                        memset((int32_t *)v39, 32, v127);
                        v130 = (char *)(v127 + (int32_t)v39);
                    } else {
                        // 0x8058094
                        memset((int32_t *)v39, 48, v127);
                        v130 = (char *)(v127 + (int32_t)v39);
                    }
                }
                char * v131 = v130;
                if (v24 == 0) {
                    if (v21 != (v24 == 0)) {
                        // 0x8058148
                        memcpy((int32_t *)v131, (int32_t *)v126, len);
                    } else {
                        // 0x8058124
                        memcpy_uppcase(v131, str, len);
                    }
                } else {
                    // 0x80580f7
                    memcpy_lowcase(v131, str, len);
                }
                // 0x805816a
                v129 = (char *)(len + (int32_t)v131);
            }
            // 0x8058176
            v81 = v128 + v17;
            v102 = v129;
            v86 = v20;
            v80 = v126;
            v85 = v60;
            goto lab_0x8058601;
        }
        case 97: {
            // 0x80563e4
            v73 = v60;
            v74 = v21;
            if (v61 != NULL) {
                goto lab_0x805843e;
            } else {
                // 0x80563f1
                v66 = 0;
                v67 = v21 | v24 != 0;
                v68 = v63;
                goto lab_0x805663b;
            }
        }
        case 98: {
            goto lab_0x805643e;
        }
        case 99: {
            // 0x8056494
            v66 = 0;
            v67 = v21;
            v68 = v63;
            v73 = v60;
            v74 = v21;
            if (v61 == (char *)79) {
                goto lab_0x805843e;
            } else {
                goto lab_0x805663b;
            }
        }
        case 100: {
            // 0x805698a
            v73 = v60;
            v74 = v21;
            if (v61 == (char *)69) {
                goto lab_0x805843e;
            } else {
                // 0x8056997
                v77 = v13;
                v91 = 2;
                v99 = v58;
                v94 = *v29;
                goto lab_0x80569ff;
            }
        }
        case 101: {
            // 0x80569b2
            v73 = v60;
            v74 = v21;
            if (v61 == (char *)69) {
                goto lab_0x805843e;
            } else {
                // 0x80569bf
                v93 = *v29;
                goto lab_0x80569e3;
            }
        }
        case 103: {
            goto lab_0x8057992;
        }
        case 104: {
            goto lab_0x805643e;
        }
        case 106: {
            // 0x8057392
            v73 = v60;
            v74 = v21;
            if (v61 == (char *)69) {
                goto lab_0x805843e;
            } else {
                int32_t v132 = *v28; // 0x80573af
                int32_t v133 = v132 + 1; // 0x80573b2
                v83 = v60;
                v78 = v13;
                v92 = 3;
                v100 = v58;
                v88 = v133 < 0 != (v133 & (v132 ^ -0x80000000)) < 0;
                v95 = v133;
                v89 = 0;
                v96 = 0;
                goto lab_0x8056a2b;
            }
        }
        case 107: {
            // 0x805733f
            v73 = v60;
            v74 = v21;
            if (v61 == (char *)69) {
                goto lab_0x805843e;
            } else {
                // 0x805734c
                v93 = *v3;
                goto lab_0x80569e3;
            }
        }
        case 108: {
            // 0x805736a
            v93 = v5;
            v73 = v60;
            v74 = v21;
            if (v61 == (char *)69) {
                goto lab_0x805843e;
            } else {
                goto lab_0x80569e3;
            }
        }
        case 109: {
            // 0x8057400
            v73 = v60;
            v74 = v21;
            if (v61 == (char *)69) {
                goto lab_0x805843e;
            } else {
                int32_t v134 = *(int32_t *)(v1 + 16); // 0x805741d
                int32_t v135 = v134 + 1; // 0x8057420
                v83 = v60;
                v78 = v13;
                v92 = 2;
                v100 = v58;
                v88 = v135 < 0 != (v135 & (v134 ^ -0x80000000)) < 0;
                v95 = v135;
                v89 = 0;
                v96 = 0;
                goto lab_0x8056a2b;
            }
        }
        case 110: {
            int32_t v136 = v58 - 1; // 0x80574df
            uint32_t v137 = (v136 & (int32_t)(v136 < 0) - 1) + 1; // 0x80574f8
            if (v137 >= maxsize - v17) {
                // break -> 0x805863d
                break;
            }
            char * v138 = NULL; // 0x805752f
            if (v39 != NULL) {
                char * v139 = v39; // 0x805753c
                if (v136 >= 1) {
                    if (v13 != (char *)48) {
                        // 0x805757e
                        memset((int32_t *)v39, 32, v136);
                        v139 = (char *)(v136 + (int32_t)v39);
                    } else {
                        // 0x8057550
                        memset((int32_t *)v39, 48, v136);
                        v139 = (char *)(v136 + (int32_t)v39);
                    }
                }
                // 0x80575aa
                *v139 = 10;
                v138 = (char *)((int32_t)v139 + 1);
            }
            // 0x80575bf
            v81 = v137 + v17;
            v102 = v138;
            v86 = v20;
            v80 = v15;
            v85 = v60;
            goto lab_0x8058601;
        }
        case 112: {
            goto lab_0x80575e1;
        }
        case 114: {
            goto lab_0x805663b;
        }
        case 115: {
            // 0x805763a
            tm = tp->e0;
            int32_t time_info = mktime((struct tm *)&tm); // 0x80576ab
            int32_t v140 = time_info;
            int32_t v141 = v140 / 10; // 0x80576f1
            char v142 = -10 * v141 + v140; // 0x8057702
            char * v143 = (char *)((int32_t)(char *)&v2 - 1);
            *v143 = (time_info > -1 ? v142 : -v142) + 48;
            char * v144 = v143; // 0x8057780
            while (v140 >= 10) {
                // 0x80576d1
                v140 = v141;
                v141 = v140 / 10;
                v142 = -10 * v141 + v140;
                v143 = (char *)((int32_t)v144 - 1);
                *v143 = (time_info > -1 ? v142 : -v142) + 48;
                v144 = v143;
            }
            // 0x8056b1a
            v75 = time_info > -1;
            v87 = v58 > 1 ? v58 : 1;
            v97 = v143;
            v101 = v58;
            v79 = v13;
            v84 = v60;
            goto lab_dec_label_pc_unknown;
        }
        case 116: {
            int32_t v145 = v58 - 1; // 0x80577d3
            uint32_t v146 = (v145 & (int32_t)(v145 < 0) - 1) + 1; // 0x80577ec
            if (v146 >= maxsize - v17) {
                // break -> 0x805863d
                break;
            }
            char * v147 = NULL; // 0x8057823
            if (v39 != NULL) {
                char * v148 = v39; // 0x8057830
                if (v145 >= 1) {
                    if (v13 != (char *)48) {
                        // 0x8057872
                        memset((int32_t *)v39, 32, v145);
                        v148 = (char *)(v145 + (int32_t)v39);
                    } else {
                        // 0x8057844
                        memset((int32_t *)v39, 48, v145);
                        v148 = (char *)(v145 + (int32_t)v39);
                    }
                }
                // 0x805789e
                *v148 = 9;
                v147 = (char *)((int32_t)v148 + 1);
            }
            // 0x80578b3
            v81 = v146 + v17;
            v102 = v147;
            v86 = v20;
            v80 = v15;
            v85 = v60;
            goto lab_0x8058601;
        }
        case 117: {
            int32_t v149 = *v37; // 0x80578d4
            int32_t v150 = v149 + 6; // 0x80578d7
            v77 = v13;
            v91 = 1;
            v99 = v58;
            v94 = v149 + 7 + -7 * ((v150 + (int32_t)(-0x6db6db6d * (int64_t)v150 / 0x100000000) >> 2) - (v150 >> 31));
            goto lab_0x80569ff;
        }
        case 119: {
            // 0x8057ea8
            v73 = v60;
            v74 = v21;
            if (v61 == (char *)69) {
                goto lab_0x805843e;
            } else {
                // 0x8057eb5
                v77 = v13;
                v91 = 1;
                v99 = v58;
                v94 = *v37;
                goto lab_0x80569ff;
            }
        }
        case 120: {
            // 0x805695c
            v66 = 0;
            v67 = v21;
            v68 = v63;
            v73 = v60;
            v74 = v21;
            if (v61 == (char *)79) {
                goto lab_0x805843e;
            } else {
                goto lab_0x805663b;
            }
        }
        case 121: {
            // 0x8057f27
            v82 = v60;
            v76 = v13;
            v90 = 0;
            v98 = v58;
            if (v61 == (char *)69) {
                goto lab_0x805663b_2;
            } else {
                int32_t v151 = *v36 % 100;
                v77 = v13;
                v91 = 2;
                v99 = v58;
                v94 = v151;
                if (v151 < 0) {
                    // 0x8057f81
                    int32_t v152; // 0x8057f3a
                    int32_t v153 = v152 > -1901 ? v151 + 100 : -v151;
                    v77 = v13;
                    v91 = 2;
                    v99 = v58;
                    v94 = v153;
                }
                goto lab_0x80569ff;
            }
        }
        case 122: {
            goto lab_0x80581e0;
        }
        default: {
            goto lab_0x805843e;
        }
    }
  lab_0x8055eb4:
    // 0x8055eb4
    tm = mbstate_zero;
    char * v154 = v20; // 0x8055edc
    if (v20 == NULL) {
        // 0x8055ede
        v154 = (char *)(v27 + 1 + strlen(str2));
    }
    int32_t v155 = (int32_t)v154 - v27; // 0x8055f07
    int32_t v156 = 0;
    char * wstr = (char *)(v156 + v27);
    int32_t v157 = mbrlen(wstr, v155 - v156, (struct _TYPEDEF___mbstate_t *)&tm); // 0x8055f3f
    int32_t v158 = v156; // 0x8055f51
    while (v157 != 0) {
        if (v157 == -2) {
            // 0x8055f5c
            v158 = strlen(wstr) + v156;
            goto lab_0x8055fae;
        }
        if (v157 == -1) {
            // 0x8055f83
            v158 = v156 + 1;
            goto lab_0x8055fae;
        }
        int32_t v159 = v157 + v156; // 0x8055f92
        int32_t v160 = mbsinit((struct _TYPEDEF___mbstate_t *)&tm); // 0x8055fa1
        int32_t v161 = v159; // 0x8055fa8
        v158 = v159;
        if (v160 != 0) {
            // break -> 0x8055fae
            break;
        }
        v156 = v161;
        wstr = (char *)(v156 + v27);
        v157 = mbrlen(wstr, v155 - v156, (struct _TYPEDEF___mbstate_t *)&tm);
        v158 = v156;
    }
    goto lab_0x8055fae;
  lab_0x8055da5:
    // 0x8055da5
    v25 = 0;
    if (maxsize - v17 <= 1) {
        // break -> 0x805863d
        goto lab_0x805863d_12;
    }
    char * v309 = NULL; // 0x8055e0b
    if (v39 != NULL) {
        // 0x8055e86
        *v39 = v11;
        v309 = (char *)((int32_t)v39 + 1);
    }
    // 0x8055ea3
    v81 = v17 + 1;
    v102 = v309;
    v86 = v20;
    v80 = v15;
    v85 = v27;
    goto lab_0x8058601;
  lab_0x8055fae:;
    int32_t v162 = v158;
    int32_t v163 = -1 - v162;
    uint32_t v164 = (v162 >> 31 & v163) + v162; // 0x8055fdf
    v25 = 0;
    if (v164 >= maxsize - v17) {
        // break -> 0x805863d
        goto lab_0x805863d_12;
    }
    char * v165 = NULL; // 0x8056016
    if (v39 != NULL) {
        char * v166 = v39; // 0x8056023
        if (v162 <= 0xfffffffe) {
            // 0x8056065
            memset((int32_t *)v39, 32, v163);
            v166 = (char *)(v163 + (int32_t)v39);
        }
        char * v167 = v166;
        if (!upcase) {
            // 0x80560eb
            memcpy((int32_t *)v167, (int32_t *)v27, v162);
        } else {
            // 0x80560c7
            memcpy_uppcase(v167, str2, v162);
        }
        // 0x805610d
        v165 = (char *)(v162 + (int32_t)v167);
    }
    // 0x8056119
    v81 = v164 + v17;
    v102 = v165;
    v86 = v154;
    v80 = v15;
    v85 = v27 - 1 + v162;
    goto lab_0x8058601;
  lab_0x8058601:;
    int32_t v168 = v85 + 1; // 0x8058601
    char * v169 = (char *)v168; // 0x805860e
    char v170 = *v169; // 0x805860e
    v9 = v170;
    v10 = v169;
    v26 = v168;
    v14 = v80;
    v19 = v86;
    v38 = v102;
    v16 = v81;
    v7 = v81;
    v8 = v102;
    if (v170 == 0) {
        goto lab_0x8058619;
    }
    goto lab_0x8055ce8;
  lab_0x8057992:
    // 0x8057992
    v73 = v60;
    v74 = v21;
    int32_t v171; // 0x8055c30
    int32_t v172; // 0x8055c30
    int32_t v173; // 0x8057a06
    int32_t v174; // 0x8055c30
    int32_t v175; // 0x8055c30
    if (v61 == (char *)69) {
        goto lab_0x805843e;
    } else {
        int32_t v176 = *v36;
        int32_t v177 = (v176 >= 0 ? -100 : 300) + v176; // 0x80579d7
        v173 = iso_week_days(*v28, *v37);
        v174 = *v37;
        v175 = *v28;
        if (v173 >= 0) {
            if (v177 % 4 != 0) {
                // 0x8057bf5
                v172 = -365;
                goto lab_0x8057bff;
            } else {
                // 0x8057b5e
                v172 = -366;
                if (v177 % 100 != 0) {
                    goto lab_0x8057bff;
                } else {
                    // 0x8057ba2
                    v172 = -366;
                    if (v177 != 0) {
                        // 0x8057bf5
                        v172 = -365;
                        goto lab_0x8057bff;
                    } else {
                        goto lab_0x8057bff;
                    }
                }
            }
        } else {
            if ((v177 + 3) % 4 != 0) {
                // 0x8057af7
                v171 = 365;
                goto lab_0x8057b01;
            } else {
                int32_t v178 = v177 - 1; // 0x8057a60
                v171 = 366;
                if (v178 % 100 != 0) {
                    goto lab_0x8057b01;
                } else {
                    // 0x8057aa1
                    v171 = 366;
                    if (v178 != 0) {
                        // 0x8057af7
                        v171 = 365;
                        goto lab_0x8057b01;
                    } else {
                        goto lab_0x8057b01;
                    }
                }
            }
        }
    }
  lab_0x80564a6:;
    char * v179 = v65;
    int32_t v180 = strftime_case_(v21, NULL, -1, v179, tp, ut, ns); // 0x80564e2
    int32_t v181 = v58 - v180; // 0x8056505
    uint32_t v182 = (v181 & (int32_t)(v181 < 0) - 1) + v180; // 0x805651e
    uint32_t v183 = maxsize - v17; // 0x8056539
    v25 = 0;
    if (v182 >= v183) {
        // break -> 0x805863d
        goto lab_0x805863d_12;
    }
    char * v184 = NULL; // 0x8056555
    if (v39 != NULL) {
        char * v185 = v39; // 0x8056562
        if (v181 >= 1) {
            if (v13 != (char *)48) {
                // 0x80565a4
                memset((int32_t *)v39, 32, v181);
                v185 = (char *)(v181 + (int32_t)v39);
            } else {
                // 0x8056576
                memset((int32_t *)v39, 48, v181);
                v185 = (char *)(v181 + (int32_t)v39);
            }
        }
        // 0x80565d0
        strftime_case_(v21, v185, v183, v179, tp, ut, ns);
        v184 = (char *)(v180 + (int32_t)v185);
    }
    // 0x805662a
    v81 = v182 + v17;
    v102 = v184;
    v86 = v20;
    v80 = v15;
    v85 = v60;
    goto lab_0x8058601;
  lab_0x805643e:;
    bool v186 = v21 | v24 != 0;
    v66 = 0;
    v67 = v186;
    v68 = v63;
    v73 = v60;
    v74 = v186;
    if (v61 != NULL) {
        goto lab_0x805843e;
    } else {
        goto lab_0x805663b;
    }
  lab_0x80575e1:
    // 0x80575e1
    v66 = v24 == 0 ? v69 : 1;
    v67 = v21 == v24 == 0;
    v68 = v70;
    goto lab_0x805663b;
  lab_0x805663b:
    // 0x805663b
    *(char *)&tm = 32;
    *v32 = 37;
    char v187 = v68; // 0x805666e
    bool v188 = v67; // 0x805666e
    char v189 = v66; // 0x805666e
    int32_t v190 = v58; // 0x805666e
    int32_t v191 = 0; // 0x805666e
    char * v192 = v13; // 0x805666e
    int32_t v193 = v60; // 0x805666e
    char v194 = v68; // 0x805666e
    bool v195 = v67; // 0x805666e
    char v196 = v66; // 0x805666e
    int32_t v197 = v58; // 0x805666e
    int32_t v198 = 0; // 0x805666e
    char * v199 = v13; // 0x805666e
    int32_t v200 = v60; // 0x805666e
    char * v201 = v33; // 0x805666e
    if (v61 == NULL) {
        goto lab_0x8056687;
    } else {
        goto lab_0x8056670;
    }
  lab_0x80581e0:;
    int32_t v202 = v71;
    v81 = v17;
    v102 = v39;
    v86 = v20;
    v80 = v15;
    v85 = v202;
    int32_t v203; // 0x8055c30
    int32_t v204; // 0x8055c30
    int32_t v205; // 0x8055c30
    int32_t v206; // 0x80581f7
    int32_t v207; // 0x8058227
    int32_t v208; // 0x805829b
    int32_t v209; // 0x80582e0
    if (*(int32_t *)(v1 + 32) < 0) {
        goto lab_0x8058601;
    } else {
        // 0x80581f1
        v206 = *(int32_t *)(v1 + 36);
        int64_t v210 = v206; // 0x8058216
        int32_t v211 = v206 >> 31; // 0x8058222
        v207 = (v206 + (int32_t)(-0x6e5d4c3b * v210 / 0x100000000) >> 11) - v211;
        int32_t v212 = (v206 + (int32_t)(-0x77777777 * v210 / 0x100000000) >> 5) - v211; // 0x8058258
        v208 = -60 * ((v212 + (int32_t)(-0x77777777 * (int64_t)v212 / 0x100000000) >> 5) - (v212 >> 31)) + v212;
        v209 = -60 * v212 + v206;
        v73 = v202;
        v74 = v21;
        switch (v72) {
            case 1: {
                goto lab_0x8058364;
            }
            case 0: {
                // 0x8058327
                v203 = 5;
                v204 = v208 + 100 * v207;
                v205 = 0;
                goto lab_0x80569da;
            }
            case 2: {
                goto lab_0x80583a1;
            }
            case 3: {
                if (v209 != 0) {
                    goto lab_0x80583a1;
                } else {
                    // 0x80583f6
                    v203 = 3;
                    v204 = v207;
                    v205 = 0;
                    if (v208 != 0) {
                        goto lab_0x8058364;
                    } else {
                        goto lab_0x80569da;
                    }
                }
            }
            default: {
                goto lab_0x805843e;
            }
        }
    }
  lab_0x805843e:;
    bool v213 = v74;
    int32_t v214 = 1;
    int32_t v215 = 1 - v214 + v73; // 0x805845c
    char * v216 = (char *)v215;
    int32_t v217 = v214 + 1; // 0x8058467
    while (*v216 != 37) {
        // 0x8058451
        v214 = v217;
        v215 = 1 - v214 + v73;
        v216 = (char *)v215;
        v217 = v214 + 1;
    }
    int32_t v218 = v58 - v214; // 0x8058481
    uint32_t v219 = (v218 & (int32_t)(v218 < 0) - 1) + v214; // 0x805849a
    v25 = 0;
    if (v219 >= maxsize - v17) {
        // break -> 0x805863d
        goto lab_0x805863d_12;
    }
    char * v220 = NULL; // 0x80584d1
    if (v39 != NULL) {
        char * v221 = v39; // 0x80584de
        if (v218 >= 1) {
            if (v13 != (char *)48) {
                // 0x8058520
                memset((int32_t *)v39, 32, v218);
                v221 = (char *)(v218 + (int32_t)v39);
            } else {
                // 0x80584f2
                memset((int32_t *)v39, 48, v218);
                v221 = (char *)(v218 + (int32_t)v39);
            }
        }
        char * v222 = v221;
        if (!v213) {
            // 0x80585bc
            memcpy((int32_t *)v222, (int32_t *)v215, v214);
        } else {
            // 0x805858d
            memcpy_uppcase(v222, v216, v214);
        }
        // 0x80585e9
        v220 = (char *)(v214 + (int32_t)v222);
    }
    // 0x80585f5
    v81 = v219 + v17;
    v102 = v220;
    v86 = v20;
    v80 = v15;
    v85 = v73;
    goto lab_0x8058601;
  lab_0x80569ff:
    // 0x80569ff
    v83 = v60;
    v78 = v77;
    v92 = v91;
    v100 = v99;
    v88 = v94 < 0;
    v95 = v94;
    v89 = 0;
    v96 = 0;
    goto lab_0x8056a2b;
  lab_0x80569e3:;
    int32_t v295 = v93;
    v77 = v13;
    v91 = 2;
    v99 = v58;
    v94 = v295;
    switch ((int32_t)v13) {
        case 48: {
            goto lab_0x80569ff;
        }
        case 45: {
            goto lab_0x80569ff;
        }
        default: {
            // 0x80569f5
            v77 = (char *)95;
            v91 = 2;
            v99 = v58;
            v94 = v295;
            goto lab_0x80569ff;
        }
    }
  lab_0x8056687:;
    int32_t v296 = v200;
    char * v297 = v199;
    int32_t v298 = v198;
    int32_t v299 = v197;
    char v300 = v196;
    bool v301 = v195;
    *v201 = v194;
    *(char *)((int32_t)v201 + 1) = 0;
    int32_t str3; // bp-1054, 0x8055c30
    int32_t copied_chars = strftime((char *)&str3, 1024, (char *)&tm, tp); // 0x80566cc
    v81 = v17;
    v102 = v39;
    v86 = v20;
    v80 = v15;
    v85 = v296;
    if (copied_chars != 0) {
        int32_t v302 = copied_chars - 1; // 0x80566ea
        int32_t v303 = v299 - v302; // 0x80566ff
        uint32_t v304 = (v303 & (int32_t)(v303 < 0) - 1) + v302; // 0x8056718
        v25 = 0;
        if (v304 >= maxsize - v17) {
            // break -> 0x805863d
            goto lab_0x805863d_12;
        }
        char * v305 = NULL; // 0x805674f
        if (v39 != NULL) {
            char * v306 = v39; // 0x805675c
            if (v298 == 0 && v303 >= 1) {
                if (v297 != (char *)48) {
                    // 0x805679e
                    memset((int32_t *)v39, 32, v303);
                    v306 = (char *)(v303 + (int32_t)v39);
                } else {
                    // 0x8056770
                    memset((int32_t *)v39, 48, v303);
                    v306 = (char *)(v303 + (int32_t)v39);
                }
            }
            char * v307 = v306;
            int32_t v308; // bp-1053, 0x8055c30
            if (v300 == 0) {
                if (!v301) {
                    // 0x805682a
                    memcpy((int32_t *)v307, &v308, v302);
                } else {
                    // 0x8056803
                    memcpy_uppcase(v307, (char *)&v308, v302);
                }
            } else {
                // 0x80567d3
                memcpy_lowcase(v307, (char *)&v308, v302);
            }
            // 0x805684f
            v305 = (char *)(v302 + (int32_t)v307);
        }
        // 0x805685b
        v81 = v304 + v17;
        v102 = v305;
        v86 = v20;
        v80 = v15;
        v85 = v296;
    }
    goto lab_0x8058601;
  lab_0x8056670:
    // 0x8056670
    *v33 = (char)(int32_t)v61;
    v194 = v187;
    v195 = v188;
    v196 = v189;
    v197 = v190;
    v198 = v191;
    v199 = v192;
    v200 = v193;
    v201 = (char *)(v31 | 3);
    goto lab_0x8056687;
  lab_dec_label_pc_unknown:;
    bool v236 = v75; // 0x8055c30
    int32_t v237 = v87; // 0x8055c30
    char * v238 = v97; // 0x8055c30
    int32_t v239 = v101; // 0x8055c30
    char * v240 = v79; // 0x8055c30
    int32_t v241 = v84; // 0x8055c30
    char v242 = 0; // 0x8055c30
    goto lab_dec_label_pc_unknown_2;
  lab_0x805663b_2:
    // 0x805663b
    *(char *)&tm = 32;
    *v32 = 37;
    v187 = v63;
    v188 = v21;
    v189 = 0;
    v190 = v98;
    v191 = v90;
    v192 = v76;
    v193 = v82;
    goto lab_0x8056670;
  lab_0x8056a2b:;
    bool v223 = v88;
    int32_t v224 = v100;
    int32_t v225 = v92;
    char * v226 = v78;
    int32_t v227 = v83;
    v82 = v227;
    v76 = v226;
    v90 = v225;
    v98 = v224;
    if (v61 == (char *)79 == !v223) {
        goto lab_0x805663b_2;
    } else {
        int32_t v228 = v95;
        int32_t v229 = !v223 ? v228 : -v228; // 0x8056aa5
        int32_t v230 = v96; // 0x8056a7e
        char * v231 = (char *)&v2;
        uint32_t v232 = v229;
        char * v233 = v231; // 0x8056a6c
        if (v230 % 2 != 0) {
            // 0x8056a6e
            v233 = (char *)((int32_t)v231 - 1);
            *v233 = 58;
        }
        // 0x8056a7e
        v230 >>= 1;
        char * v234 = (char *)((int32_t)v233 - 1);
        v229 = v232 / 10;
        *v234 = (char)(v232 - 2 * v229) + 48;
        while ((v230 || v229) != 0) {
            // 0x8056a61
            v231 = v234;
            v232 = v229;
            v233 = v231;
            if (v230 % 2 != 0) {
                // 0x8056a6e
                v233 = (char *)((int32_t)v231 - 1);
                *v233 = 58;
            }
            // 0x8056a7e
            v230 >>= 1;
            v234 = (char *)((int32_t)v233 - 1);
            v229 = v232 / 10;
            *v234 = (char)(v232 - 2 * v229) + 48;
        }
        int32_t v235 = v225 < v224 ? v224 : v225;
        v75 = !v223;
        v87 = v235;
        v97 = v234;
        v101 = v224;
        v79 = v226;
        v84 = v227;
        v236 = !v223;
        v237 = v235;
        v238 = v234;
        v239 = v224;
        v240 = v226;
        v241 = v227;
        v242 = 43;
        if (v89 == 0) {
            goto lab_dec_label_pc_unknown;
        } else {
            goto lab_dec_label_pc_unknown_2;
        }
    }
  lab_dec_label_pc_unknown_2:;
    char * v243 = v240;
    int32_t v244 = v239;
    char * v245 = v238;
    uint32_t v246 = v237;
    char v247 = v236 ? v242 : 45;
    int32_t v248; // 0x8055c30
    int32_t v249; // 0x8055c30
    char * v250; // 0x8055c30
    if (v243 != (char *)45) {
        int32_t v251 = v246 - v30 + (int32_t)v245 + (int32_t)(v247 != 0); // 0x8056cc9
        if (v251 < 1) {
            // 0x8057031
            v248 = v17;
            v250 = v39;
            v249 = v244;
            if (v247 != 0) {
                int32_t v252 = v244 - 1; // 0x8057054
                uint32_t v253 = (v252 & (int32_t)(v252 < 0) - 1) + 1; // 0x805706d
                v25 = 0;
                if (v253 >= maxsize - v17) {
                    // break -> 0x805863d
                    goto lab_0x805863d_12;
                }
                char * v254 = NULL; // 0x80570a4
                if (v39 != NULL) {
                    // 0x80570aa
                    if (v246 == 0 && v252 >= 1) {
                        if (v243 != (char *)48) {
                            // 0x80570f3
                            memset((int32_t *)v39, 32, v252);
                        } else {
                            // 0x80570c5
                            memset((int32_t *)v39, 48, v252);
                        }
                    }
                    // 0x805711f
                    *v39 = v247;
                    v254 = (char *)((int32_t)v39 + 1);
                }
                // 0x805713a
                v248 = v253 + v17;
                v250 = v254;
                v249 = v244;
            }
        } else {
            uint32_t v255 = maxsize - v17;
            if (v243 != (char *)95) {
                // 0x8056ea8
                v25 = 0;
                if (v246 >= v255) {
                    // break -> 0x805863d
                    goto lab_0x805863d_12;
                }
                int32_t v256 = v17; // 0x8056ed3
                char * v257 = v39; // 0x8056ed3
                if (v247 != 0) {
                    int32_t v258 = v244 - 1; // 0x8056eef
                    uint32_t v259 = (v258 & (int32_t)(v258 < 0) - 1) + 1; // 0x8056f08
                    v25 = 0;
                    if (v259 >= v255) {
                        // break -> 0x805863d
                        goto lab_0x805863d_12;
                    }
                    char * v260 = NULL; // 0x8056f3f
                    if (v39 != NULL) {
                        char * v261 = v39; // 0x8056f4c
                        if (v246 == 0 && v258 >= 1) {
                            if (v243 != (char *)48) {
                                // 0x8056f8e
                                memset((int32_t *)v39, 32, v258);
                                v261 = (char *)(v258 + (int32_t)v39);
                            } else {
                                // 0x8056f60
                                memset((int32_t *)v39, 48, v258);
                                v261 = (char *)(v258 + (int32_t)v39);
                            }
                        }
                        // 0x8056fba
                        *v261 = v247;
                        v260 = (char *)((int32_t)v261 + 1);
                    }
                    // 0x8056fd5
                    v256 = v259 + v17;
                    v257 = v260;
                }
                char * v262 = v257;
                char * v263 = NULL; // 0x8056fe8
                if (v262 != NULL) {
                    // 0x8056fea
                    memset((int32_t *)v262, 48, v251);
                    v263 = (char *)(v251 + (int32_t)v262);
                }
                // 0x8057016
                v248 = v256 + v251;
                v250 = v263;
                v249 = 0;
            } else {
                // 0x8056ced
                v25 = 0;
                if (v251 >= v255) {
                    // break -> 0x805863d
                    goto lab_0x805863d_12;
                }
                char * v264 = NULL; // 0x8056d18
                if (v39 != NULL) {
                    // 0x8056d1a
                    memset((int32_t *)v39, 32, v251);
                    v264 = (char *)(v251 + (int32_t)v39);
                }
                char * v265 = v264;
                int32_t v266 = v251 + v17; // 0x8056d4c
                int32_t v267 = v244 > v251 ? v244 - v251 : 0;
                v248 = v266;
                v250 = v265;
                v249 = v267;
                if (v247 != 0) {
                    int32_t v268 = v267 - 1; // 0x8056db1
                    uint32_t v269 = (v268 & (int32_t)(v268 < 0) - 1) + 1; // 0x8056dca
                    v25 = 0;
                    if (v269 >= maxsize - v266) {
                        // break -> 0x805863d
                        goto lab_0x805863d_12;
                    }
                    char * v270 = NULL; // 0x8056e01
                    if (v265 != NULL) {
                        char * v271 = v265; // 0x8056e0e
                        if (v246 == 0 && v268 >= 1) {
                            if (v243 != (char *)48) {
                                // 0x8056e50
                                memset((int32_t *)v265, 32, v268);
                                v271 = (char *)(v268 + (int32_t)v265);
                            } else {
                                // 0x8056e22
                                memset((int32_t *)v265, 48, v268);
                                v271 = (char *)(v268 + (int32_t)v265);
                            }
                        }
                        // 0x8056e7c
                        *v271 = v247;
                        v270 = (char *)((int32_t)v271 + 1);
                    }
                    // 0x8056e97
                    v248 = v269 + v266;
                    v250 = v270;
                    v249 = v267;
                }
            }
        }
    } else {
        // 0x8056b86
        v248 = v17;
        v250 = v39;
        v249 = v244;
        if (v247 != 0) {
            int32_t v272 = v244 - 1; // 0x8056ba9
            uint32_t v273 = (v272 & (int32_t)(v272 < 0) - 1) + 1; // 0x8056bc2
            v25 = 0;
            if (v273 >= maxsize - v17) {
                // break -> 0x805863d
                goto lab_0x805863d_12;
            }
            char * v274 = NULL; // 0x8056bf9
            if (v39 != NULL) {
                char * v275 = v39; // 0x8056c06
                if (v246 == 0 && v272 >= 1) {
                    if (v243 != (char *)48) {
                        // 0x8056c48
                        memset((int32_t *)v39, 32, v272);
                        v275 = (char *)(v272 + (int32_t)v39);
                    } else {
                        // 0x8056c1a
                        memset((int32_t *)v39, 48, v272);
                        v275 = (char *)(v272 + (int32_t)v39);
                    }
                }
                // 0x8056c74
                *v275 = v247;
                v274 = (char *)((int32_t)v275 + 1);
            }
            // 0x8056c8f
            v248 = v273 + v17;
            v250 = v274;
            v249 = v244;
        }
    }
    int32_t v276 = v30 - (int32_t)v245; // 0x8057156
    int32_t v277 = v249 - v276; // 0x805716c
    uint32_t v278 = (v277 & (int32_t)(v277 < 0) - 1) + v276; // 0x8057185
    v25 = 0;
    if (v278 >= maxsize - v248) {
        // break -> 0x805863d
        goto lab_0x805863d_12;
    }
    char * v279 = v250;
    char * v280 = NULL; // 0x80571bc
    if (v279 != NULL) {
        char * v281 = v279; // 0x80571c9
        if (v246 == 0 && v277 >= 1) {
            if (v243 != (char *)48) {
                // 0x805720b
                memset((int32_t *)v279, 32, v277);
                v281 = (char *)(v277 + (int32_t)v279);
            } else {
                // 0x80571dd
                memset((int32_t *)v279, 48, v277);
                v281 = (char *)(v277 + (int32_t)v279);
            }
        }
        char * v282 = v281;
        if (!v21) {
            // 0x8057291
            memcpy((int32_t *)v282, (int32_t *)v245, v276);
        } else {
            // 0x805726d
            memcpy_uppcase(v282, v245, v276);
        }
        // 0x80572b3
        v280 = (char *)(v276 + (int32_t)v282);
    }
    // 0x80572bf
    v81 = v278 + v248;
    v102 = v280;
    v86 = v20;
    v80 = v15;
    v85 = v241;
    goto lab_0x8058601;
  lab_0x8058364:
    // 0x8058364
    v203 = 6;
    v204 = v208 + 100 * v207;
    v205 = 4;
    goto lab_0x80569da;
  lab_0x80583a1:
    // 0x80583a1
    v203 = 9;
    v204 = v209 + 0x2710 * v207 + 100 * v208;
    v205 = 20;
    goto lab_0x80569da;
  lab_0x80569da:
    // 0x80569da
    v83 = v202;
    v78 = v13;
    v92 = v203;
    v100 = v58;
    v88 = v206 < 0;
    v95 = v204;
    v89 = 1;
    v96 = v205;
    goto lab_0x8056a2b;
  lab_0x8057bff:;
    int32_t v283 = iso_week_days(v172 + v175, v174); // 0x8057c1d
    int32_t v284 = v283 >= 0; // 0x8055c30
    int32_t v285 = v283 < 0 ? v173 : v283; // 0x8055c30
    goto lab_0x8057c47;
  lab_0x8057b01:
    // 0x8057b01
    v284 = -1;
    v285 = iso_week_days(v171 + v175, v174);
    goto lab_0x8057c47;
  lab_0x8057c47:;
    int32_t v286 = v284;
    char v287 = *v62; // 0x8057c4d
    if (v287 == 71) {
        int32_t v288 = *v36; // 0x8057d7f
        int32_t v289 = -1900 - v286; // 0x8057d87
        int32_t v290 = v288 - v289; // 0x8057d8d
        v83 = v60;
        v78 = v13;
        v92 = 4;
        v100 = v58;
        v88 = v290 < 0 != ((v290 ^ v288) & (v288 ^ v289)) < 0;
        v95 = v286 + 1900 + v288;
        v89 = 0;
        v96 = 0;
        goto lab_0x8056a2b;
    } else {
        if (v287 != 103) {
            int32_t v291 = v285;
            int32_t v292 = v291 < 0 ? 2 : 1; // 0x8057ded
            v77 = v13;
            v91 = 2;
            v99 = v58;
            v94 = v292 + (v291 + (int32_t)(-0x6db6db6d * (int64_t)v291 / 0x100000000) >> 2);
        } else {
            int32_t v293 = *v36; // 0x8057c79
            int32_t v294 = (v293 % 100 + v286) % 100;
            v77 = v13;
            v91 = 2;
            v99 = v58;
            v94 = v294;
            if (v294 < 0) {
                // 0x8057d0b
                v77 = v13;
                v91 = 2;
                v99 = v58;
                v94 = v293 < -1900 - v286 ? -v294 : v294 + 100;
            }
        }
        goto lab_0x80569ff;
    }
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/strftime.c
// Address range: 0x805865e - 0x80586bb
// Line range:    371 - 377
int32_t iso_week_days(int32_t yday, int32_t wday) {
    int32_t v1 = yday - wday; // 0x8058672
    int32_t v2 = v1 + 382; // 0x8058679
    return yday - 379 - v1 + 7 * ((v2 + (int32_t)(-0x6db6db6d * (int64_t)v2 / 0x100000000) >> 2) - (v2 >> 31));
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/strftime.c
// Address range: 0x80586bb - 0x80586f9
// Line range:    1442 - 1445
int32_t nstrftime(char * s, int32_t maxsize, char * format2, struct tm * tp, int32_t ut, int32_t ns) {
    // 0x80586bb
    return strftime_case_(false, s, maxsize, format2, tp, ut, ns);
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/inttostr.c
// Address range: 0x80586fc - 0x8058786
// Line range:    30 - 50
char * umaxtostr(int64_t i, char * buf) {
    // 0x80586fc
    int32_t v1; // 0x80586fc
    char * v2 = (char *)(v1 + 20); // 0x8058714
    *v2 = 0;
    int32_t v3 = (int32_t)buf; // 0x8058724
    int32_t v4 = i; // 0x805871a
    char * result = v2; // 0x805871a
    result = (char *)((int32_t)result - 1);
    *result = (char)__umoddi3(v4, v3, 10, 0) + 48;
    v4 = __udivdi3(v4, v3, 10, 0);
    while ((v4 || v3) != 0) {
        // 0x805871d
        result = (char *)((int32_t)result - 1);
        *result = (char)__umoddi3(v4, v3, 10, 0) + 48;
        v4 = __udivdi3(v4, v3, 10, 0);
    }
    // 0x8058781
    return result;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/vfprintf.c
// Address range: 0x8058788 - 0x80588ef
// Line range:    44 - 78
int32_t rpl_vfprintf(struct _IO_FILE * fp, char * format2, char * args) {
    char buf2[2000]; // bp-2012, 0x8058788
    char buf[2000]; // bp-2016, 0x8058788
    char v1[2000]; // 0x80587ed
    char v2[2000]; // 0x80587f9
    int32_t v3 = __readgsdword(20); // 0x80587ac
    char * output = (char *)2000; // bp-2020, 0x80587b7
    int32_t v4; // bp-2008, 0x8058788
    char * v5 = vasnprintf((char *)&v4, (int32_t *)&output, format2, args); // 0x80587e8
    v1[0] = (int32_t)v5;
    buf2 = v1;
    v2[0] = (int32_t)output;
    buf = v2;
    int32_t v6 = *(int32_t *)&buf2; // 0x80587ff
    int32_t v7; // 0x8058788
    if (v6 != 0) {
        int32_t nmemb = *(int32_t *)&buf;
        if (fwrite(&((struct _IO_FILE *)v6)->e0, 1, nmemb, fp) >= nmemb) {
            // 0x805889b
            v7 = nmemb;
            if (nmemb < 0) {
                // 0x80588a5
                *__errno_location() = 75;
                fseterr(fp);
                v7 = -1;
            }
        } else {
            // 0x8058857
            v7 = -1;
            if (v6 != (int32_t)&v4) {
                int32_t v8 = *__errno_location(); // 0x805886a
                free(&((struct _IO_FILE *)v6)->e0);
                *__errno_location() = v8;
                v7 = -1;
            }
        }
    } else {
        // 0x8058808
        fseterr(fp);
        v7 = -1;
    }
    int32_t result = v7; // 0x80588e6
    if (v3 != __readgsdword(20)) {
        // 0x80588e8
        __stack_chk_fail();
        result = &g49;
    }
    // 0x80588ed
    return result;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/xalloc.h
// Address range: 0x80588f0 - 0x805891e
// Line range:    113 - 117
char * xnmalloc(uint32_t n, uint32_t s) {
    if (0xffffffff / s >= n) {
        // 0x805890d
        return xmalloc(s * n);
    }
    // 0x8058908
    xalloc_die();
    // UNREACHABLE
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/xalloc.h
// Address range: 0x805891e - 0x8058953
// Line range:    124 - 128
char * xnrealloc(char * p, uint32_t n, uint32_t s) {
    if (0xffffffff / s >= n) {
        // 0x805893b
        return xrealloc(p, s * n);
    }
    // 0x8058936
    xalloc_die();
    // UNREACHABLE
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/xalloc.h
// Address range: 0x80589ce - 0x80589e1
// Line range:    224 - 226
char * xcharalloc(int32_t n) {
    // 0x80589ce
    return xmalloc(n);
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/xmalloc.c
// Address range: 0x80589e1 - 0x8058a0b
// Line range:    48 - 53
char * xmalloc(int32_t n) {
    int32_t * mem = malloc(n); // 0x80589ed
    if (n == 0 || mem != NULL) {
        // 0x8058a06
        return (char *)mem;
    }
    // 0x8058a01
    xalloc_die();
    // UNREACHABLE
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/xmalloc.c
// Address range: 0x8058a0b - 0x8058a3c
// Line range:    60 - 65
char * xrealloc(char * p, int32_t n) {
    int32_t * mem = realloc((int32_t *)p, n); // 0x8058a1e
    if (n == 0 || mem != NULL) {
        // 0x8058a37
        return (char *)mem;
    }
    // 0x8058a32
    xalloc_die();
    // UNREACHABLE
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/xmalloc.c
// Address range: 0x8058ab5 - 0x8058ae0
// Line range:    112 - 114
char * xmemdup(int32_t * p, int32_t s) {
    // 0x8058ab5
    return (char *)memcpy((int32_t *)xmalloc(s), p, s);
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/xmalloc.c
// Address range: 0x8058ae0 - 0x8058b05
// Line range:    120 - 122
char * xstrdup(char * string) {
    // 0x8058ae0
    return xmemdup((int32_t *)string, strlen(string) + 1);
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/xstrtol-error.c
// Address range: 0x8058b08 - 0x8058bc6
// Line range:    51 - 87
void xstrtol_error(uint32_t err, int32_t opt_idx, char c, struct option * long_options2, char * arg, int32_t exit_status2) {
    char * v1 = (char *)err; // 0x8058b1e
    char * v2; // 0x8058b08
    if (err >= 4) {
        // 0x8058b35
        v2 = "invalid %s%s argument `%s'";
        if (v1 == (char *)4) {
            // 0x8058b59
            error(exit_failure, 0, gettext(v2));
            return;
        }
        // 0x8058b3b
        abort();
        // UNREACHABLE
    }
    // 0x8058b27
    v2 = "invalid suffix in %s%s argument `%s'";
    if (v1 >= (char *)2) {
        // 0x8058b59
        error(exit_failure, 0, gettext(v2));
        return;
    }
    // 0x8058b2d
    v2 = "%s%s argument `%s' too large";
    if (v1 == (char *)1) {
        // 0x8058b59
        error(exit_failure, 0, gettext(v2));
        return;
    }
    // 0x8058b3b
    abort();
    // UNREACHABLE
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/xstrtol-error.c
// Address range: 0x8058bc6 - 0x8058c08
// Line range:    95 - 97
void xstrtol_fatal(int32_t err, int32_t opt_idx, char c, struct option * long_options2, char * arg) {
    // 0x8058bc6
    xstrtol_error(err, opt_idx, c, long_options2, arg, exit_failure);
    abort();
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/xstrtol.c
// Address range: 0x8058c08 - 0x8058c5a
// Line range:    48 - 61
int32_t bkm_scale(int32_t * x, uint32_t scale_factor) {
    uint32_t v1 = *x; // 0x8058c26
    *x = 0xffffffff / scale_factor >= v1 ? v1 * scale_factor : -1;
    return 0xffffffff / scale_factor < v1;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/xstrtol.c
// Address range: 0x8058c5a - 0x8058c92
// Line range:    65 - 70
int32_t bkm_scale_by_power(int32_t * x, int32_t base, int32_t power) {
    int32_t result = 0; // 0x8058c8b
    if (power == 0) {
        // 0x8058c8d
        return 0;
    }
    int32_t v1 = power; // 0x8058c8b
    v1--;
    result |= bkm_scale(x, base);
    while (v1 != 0) {
        // 0x8058c69
        v1--;
        result |= bkm_scale(x, base);
    }
    // 0x8058c8d
    return result;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/xstrtol.c
// Address range: 0x8058c92 - 0x8059076
// Line range:    77 - 228
int32_t xstrtoul(char * s, char ** ptr, uint32_t strtol_base, int32_t * val, char * valid_suffixes) {
    if (strtol_base >= 37) {
        // 0x8058cab
        __assert_fail("0 <= strtol_base && strtol_base <= 36", "xstrtol.c", 83, "xstrtoul");
    }
    unsigned char v1 = *s;
    int16_t v2 = *(int16_t *)(2 * (int32_t)v1 + (int32_t)*__ctype_b_loc()); // 0x8058d17
    int32_t v3 = (int32_t)s; // 0x8058d24
    char v4 = v1; // 0x8058d24
    if ((v2 & 0x2000) != 0) {
        v3++;
        unsigned char v5 = *(char *)v3;
        int16_t v6 = *(int16_t *)(2 * (int32_t)v5 + (int32_t)*__ctype_b_loc()); // 0x8058d17
        v4 = v5;
        while ((v6 & 0x2000) != 0) {
            // 0x8058cfa
            v3++;
            v5 = *(char *)v3;
            v6 = *(int16_t *)(2 * (int32_t)v5 + (int32_t)*__ctype_b_loc());
            v4 = v5;
        }
    }
    // 0x8058d26
    if (v4 == 45) {
        // 0x8059071
        return 4;
    }
    // 0x8058d38
    int32_t v7; // bp-12, 0x8058c92
    char ** endptr = ptr != NULL ? ptr : (char **)&v7;
    *__errno_location() = 0;
    char * t_ptr = (char *)strtoul(s, endptr, strtol_base); // bp-20, 0x8058d5c
    char * v8 = *endptr;
    char ** v9; // 0x8058c92
    if (v8 != s) {
        int32_t v10 = *__errno_location(); // 0x8058db3
        char ** v11 = NULL; // 0x8058db7
        if (v10 != 0) {
            int32_t v12 = *__errno_location(); // 0x8058dbe
            v11 = (char **)1;
            if (v12 != 34) {
                // 0x8059071
                return 4;
            }
        }
        // 0x8058dd8
        v9 = v11;
        if (valid_suffixes == NULL) {
            // 0x8058dde
            *val = (int32_t)t_ptr;
            // 0x8059071
            return (int32_t)v11;
        }
    } else {
        // 0x8058d69
        if (valid_suffixes == NULL) {
            // 0x8059071
            return 4;
        }
        char c = *v8; // 0x8058d74
        if (c == 0 || strchr(valid_suffixes, (int32_t)c) == NULL) {
            // 0x8059071
            return 4;
        }
        // 0x8058dd8
        t_ptr = (char *)1;
        v9 = NULL;
    }
    char c2 = **endptr; // 0x8058df6
    char ** v13 = v9; // 0x8058dfb
    if (c2 != 0) {
        // 0x8058e01
        if (strchr(valid_suffixes, (int32_t)c2) == NULL) {
            // 0x8058e2d
            *val = (int32_t)t_ptr;
            // 0x8059071
            return (int32_t)v9 | 2;
        }
        char * found_char_pos = strchr(valid_suffixes, 48); // 0x8058e53
        char * v14 = *endptr;
        int32_t v15 = 1024; // 0x8058e5a
        int32_t v16 = 1; // 0x8058e5a
        if (found_char_pos != NULL) {
            int32_t v17 = (int32_t)v14;
            v15 = 1024;
            v16 = 1;
            switch (*(char *)(v17 + 1)) {
                case 68: {
                }
                case 66: {
                    // 0x8058e96
                    v15 = 1000;
                    v16 = 2;
                    // break -> 0x8058ea1
                    break;
                }
                case 105: {
                    // 0x8058e81
                    v15 = 1024;
                    v16 = *(char *)(v17 + 2) != 66 ? 1 : 3;
                    // break -> 0x8058ea1
                    break;
                }
            }
        }
        int32_t v18 = (int32_t)*v14; // 0x8058ea9
        g42 = v18 - 66;
        int32_t v19 = 0; // 0x8058ec6
        switch (v18) {
            case 66: {
                // 0x8058ee3
                v19 = bkm_scale((int32_t *)&t_ptr, 1024);
            }
            case 99: {
              lab_0x805903e:;
                int32_t v20 = v19 | (int32_t)v9; // 0x8059041
                int32_t v21 = v16 + (int32_t)*endptr; // 0x805904c
                *(int32_t *)endptr = v21;
                v13 = (char **)v20;
                if (*(char *)v21 != 0) {
                    // 0x805905f
                    v13 = (char **)(v20 | 2);
                }
                // break -> 0x8059063
                break;
            }
            case 69: {
                // 0x8058f0a
                v19 = bkm_scale_by_power((int32_t *)&t_ptr, v15, 6);
                // branch (via goto) -> 0x805903e
                goto lab_0x805903e;
            }
            case 71: {
            }
            case 103: {
                // 0x8058f2c
                v19 = bkm_scale_by_power((int32_t *)&t_ptr, v15, 3);
                // branch (via goto) -> 0x805903e
                goto lab_0x805903e;
            }
            case 75: {
            }
            case 107: {
                // 0x8058f4e
                v19 = bkm_scale_by_power((int32_t *)&t_ptr, v15, 1);
                // branch (via goto) -> 0x805903e
                goto lab_0x805903e;
            }
            case 77: {
            }
            case 109: {
                // 0x8058f70
                v19 = bkm_scale_by_power((int32_t *)&t_ptr, v15, 2);
                // branch (via goto) -> 0x805903e
                goto lab_0x805903e;
            }
            case 80: {
                // 0x8058f92
                v19 = bkm_scale_by_power((int32_t *)&t_ptr, v15, 5);
                // branch (via goto) -> 0x805903e
                goto lab_0x805903e;
            }
            case 84: {
            }
            case 116: {
                // 0x8058fb4
                v19 = bkm_scale_by_power((int32_t *)&t_ptr, v15, 4);
                // branch (via goto) -> 0x805903e
                goto lab_0x805903e;
            }
            case 89: {
                // 0x8058feb
                v19 = bkm_scale_by_power((int32_t *)&t_ptr, v15, 8);
                // branch (via goto) -> 0x805903e
                goto lab_0x805903e;
            }
            case 90: {
                // 0x805900a
                v19 = bkm_scale_by_power((int32_t *)&t_ptr, v15, 7);
                // branch (via goto) -> 0x805903e
                goto lab_0x805903e;
            }
            case 98: {
                // 0x8058ec8
                v19 = bkm_scale((int32_t *)&t_ptr, 512);
                // branch (via goto) -> 0x805903e
                goto lab_0x805903e;
            }
            case 119: {
                // 0x8058fd3
                v19 = bkm_scale((int32_t *)&t_ptr, 2);
                // branch (via goto) -> 0x805903e
                goto lab_0x805903e;
            }
            default: {
                // 0x8059029
                *val = (int32_t)t_ptr;
                // 0x8059071
                return (int32_t)v9 | 2;
            }
        }
    }
    // 0x8059063
    *val = (int32_t)t_ptr;
    // 0x8059071
    return (int32_t)v13;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/fseterr.c
// Address range: 0x8059078 - 0x805908c
// Line range:    26 - 79
void fseterr(struct _IO_FILE * fp) {
    // 0x8059078
    fp->e0 |= 32;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/xstrtol.c
// Address range: 0x80590b8 - 0x8059166
// Line range:    48 - 61
int32_t bkm_scale2(int64_t * x, uint32_t scale_factor) {
    uint32_t v1 = (int32_t)scale_factor >> 31; // 0x80590c6
    uint32_t v2 = __udivdi3(-1, -1, scale_factor, v1); // 0x80590e0
    int32_t * v3 = (int32_t *)((int32_t)x + 4); // 0x80590f0
    uint32_t v4 = *v3; // 0x80590f0
    uint32_t v5 = *(int32_t *)x;
    int32_t v6; // 0x80590b8
    int32_t v7; // 0x80590b8
    int32_t result; // 0x80590b8
    if (v1 > v4) {
        goto lab_0x805912a;
    } else {
        // 0x8059101
        v7 = -1;
        v6 = -1;
        result = 1;
        if (v1 >= v4 == v2 >= v5) {
            goto lab_0x805912a;
        } else {
            goto lab_0x805915b;
        }
    }
  lab_0x805912a:;
    uint64_t v8 = (int64_t)v5 * (int64_t)scale_factor; // 0x8059146
    v7 = v8;
    v6 = v5 * v1 + v4 * scale_factor + (int32_t)(v8 / 0x100000000);
    result = 0;
    goto lab_0x805915b;
  lab_0x805915b:
    // 0x805915b
    *(int32_t *)x = v7;
    *v3 = v6;
    return result;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/xstrtol.c
// Address range: 0x8059166 - 0x805919e
// Line range:    65 - 70
int32_t bkm_scale_by_power2(int64_t * x, int32_t base, int32_t power) {
    int32_t result = 0; // 0x8059197
    if (power == 0) {
        // 0x8059199
        return 0;
    }
    int32_t v1 = power; // 0x8059197
    v1--;
    result |= bkm_scale2(x, base);
    while (v1 != 0) {
        // 0x8059175
        v1--;
        result |= bkm_scale2(x, base);
    }
    // 0x8059199
    return result;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/xstrtol.c
// Address range: 0x805919e - 0x80595a4
// Line range:    77 - 228
int32_t xstrtoumax(char * s, char ** ptr, uint32_t strtol_base, int64_t * val, char * valid_suffixes) {
    if (strtol_base >= 37) {
        // 0x80591b7
        __assert_fail("0 <= strtol_base && strtol_base <= 36", "xstrtol.c", 83, "xstrtoumax");
    }
    unsigned char v1 = *s;
    int32_t v2 = (int32_t)*__ctype_b_loc(); // 0x8059218
    char v3 = v1; // 0x8059230
    int32_t v4 = v2; // 0x8059230
    if ((*(int16_t *)(2 * (int32_t)v1 + v2) & 0x2000) != 0) {
        int32_t v5 = (int32_t)(char **)s + 1; // 0x8059206
        unsigned char v6 = *(char *)v5;
        int32_t v7 = (int32_t)*__ctype_b_loc();
        char ** v8 = (char **)v5; // 0x8059230
        v3 = v6;
        v4 = v7;
        while ((*(int16_t *)(2 * (int32_t)v6 + v7) & 0x2000) != 0) {
            // 0x8059206
            v5 = (int32_t)v8 + 1;
            v6 = *(char *)v5;
            v7 = (int32_t)*__ctype_b_loc();
            v8 = (char **)v5;
            v3 = v6;
            v4 = v7;
        }
    }
    // 0x8059232
    if (v3 == 45) {
        // 0x805959f
        return 4;
    }
    // 0x8059244
    int32_t v9; // bp-12, 0x805919e
    char ** endptr = ptr != NULL ? ptr : (char **)&v9;
    *__errno_location() = 0;
    int32_t v10 = strtoumax(s, endptr, strtol_base); // bp-44, 0x8059268
    char * v11 = *endptr;
    int32_t v12; // 0x805919e
    char * v13; // 0x805919e
    if (v11 != s) {
        int32_t v14 = *__errno_location(); // 0x80592c9
        char * v15 = NULL; // 0x80592cd
        if (v14 != 0) {
            int32_t v16 = *__errno_location(); // 0x80592d4
            v15 = (char *)1;
            if (v16 != 34) {
                // 0x805959f
                return 4;
            }
        }
        // 0x80592ee
        v12 = v4;
        v13 = v15;
        if (valid_suffixes == NULL) {
            // 0x80592f4
            *(int32_t *)val = v10;
            *(int32_t *)((int32_t)val + 4) = v4;
            // 0x805959f
            return (int32_t)v15;
        }
    } else {
        // 0x8059278
        if (valid_suffixes == NULL) {
            // 0x805959f
            return 4;
        }
        char c = *v11; // 0x8059283
        if (c == 0 || strchr(valid_suffixes, (int32_t)c) == NULL) {
            // 0x805959f
            return 4;
        }
        // 0x80592ee
        v10 = 1;
        v12 = 0;
        v13 = NULL;
    }
    char c2 = **endptr; // 0x8059312
    char * v17 = v13; // 0x8059317
    if (c2 != 0) {
        // 0x805931d
        if (strchr(valid_suffixes, (int32_t)c2) == NULL) {
            // 0x8059349
            *(int32_t *)val = v10;
            *(int32_t *)((int32_t)val + 4) = v12;
            // 0x805959f
            return (int32_t)v13 | 2;
        }
        char * found_char_pos = strchr(valid_suffixes, 48); // 0x8059375
        char * v18 = *endptr;
        int32_t v19 = 1024; // 0x805937c
        int32_t v20 = 1; // 0x805937c
        if (found_char_pos != NULL) {
            int32_t v21 = (int32_t)v18;
            v19 = 1024;
            v20 = 1;
            switch (*(char *)(v21 + 1)) {
                case 68: {
                }
                case 66: {
                    // 0x80593b8
                    v19 = 1000;
                    v20 = 2;
                    // break -> 0x80593c3
                    break;
                }
                case 105: {
                    // 0x80593a3
                    v19 = 1024;
                    v20 = *(char *)(v21 + 2) != 66 ? 1 : 3;
                    // break -> 0x80593c3
                    break;
                }
            }
        }
        int32_t v22 = (int32_t)*v18; // 0x80593cb
        g43 = v22 - 66;
        int32_t v23 = 0; // 0x80593e8
        switch (v22) {
            case 66: {
                // 0x8059405
                v23 = bkm_scale2((int64_t *)&v10, 1024);
            }
            case 99: {
              lab_0x8059566:;
                int32_t v24 = v23 | (int32_t)v13; // 0x8059569
                int32_t v25 = v20 + (int32_t)*endptr; // 0x8059574
                *(int32_t *)endptr = v25;
                v17 = (char *)v24;
                if (*(char *)v25 != 0) {
                    // 0x8059587
                    v17 = (char *)(v24 | 2);
                }
                // break -> 0x805958b
                break;
            }
            case 69: {
                // 0x805942c
                v23 = bkm_scale_by_power2((int64_t *)&v10, v19, 6);
                // branch (via goto) -> 0x8059566
                goto lab_0x8059566;
            }
            case 71: {
            }
            case 103: {
                // 0x805944e
                v23 = bkm_scale_by_power2((int64_t *)&v10, v19, 3);
                // branch (via goto) -> 0x8059566
                goto lab_0x8059566;
            }
            case 75: {
            }
            case 107: {
                // 0x8059470
                v23 = bkm_scale_by_power2((int64_t *)&v10, v19, 1);
                // branch (via goto) -> 0x8059566
                goto lab_0x8059566;
            }
            case 77: {
            }
            case 109: {
                // 0x8059492
                v23 = bkm_scale_by_power2((int64_t *)&v10, v19, 2);
                // branch (via goto) -> 0x8059566
                goto lab_0x8059566;
            }
            case 80: {
                // 0x80594b4
                v23 = bkm_scale_by_power2((int64_t *)&v10, v19, 5);
                // branch (via goto) -> 0x8059566
                goto lab_0x8059566;
            }
            case 84: {
            }
            case 116: {
                // 0x80594d6
                v23 = bkm_scale_by_power2((int64_t *)&v10, v19, 4);
                // branch (via goto) -> 0x8059566
                goto lab_0x8059566;
            }
            case 89: {
                // 0x805950d
                v23 = bkm_scale_by_power2((int64_t *)&v10, v19, 8);
                // branch (via goto) -> 0x8059566
                goto lab_0x8059566;
            }
            case 90: {
                // 0x805952c
                v23 = bkm_scale_by_power2((int64_t *)&v10, v19, 7);
                // branch (via goto) -> 0x8059566
                goto lab_0x8059566;
            }
            case 98: {
                // 0x80593ea
                v23 = bkm_scale2((int64_t *)&v10, 512);
                // branch (via goto) -> 0x8059566
                goto lab_0x8059566;
            }
            case 119: {
                // 0x80594f5
                v23 = bkm_scale2((int64_t *)&v10, 2);
                // branch (via goto) -> 0x8059566
                goto lab_0x8059566;
            }
            default: {
                // 0x805954b
                *(int32_t *)val = v10;
                *(int32_t *)((int32_t)val + 4) = v12;
                // 0x805959f
                return (int32_t)v13 | 2;
            }
        }
    }
    // 0x805958b
    *(int32_t *)val = v10;
    *(int32_t *)((int32_t)val + 4) = v12;
    // 0x805959f
    return (int32_t)v17;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/vasnprintf.c
// Address range: 0x8059634 - 0x805969a
// Line range:    251 - 253
int32_t is_infinitel(float64_t x) {
    // 0x8059634
    if (rpl_isnanl(x) != 0) {
        // 0x8059695
        return 1;
    }
    float80_t v1 = x;
    int3_t v2; // 0x8059634
    int3_t v3 = v2 - 1; // 0x8059657
    __frontend_reg_store_fpr(v3, v1);
    int3_t v4 = v2 - 2; // 0x805965a
    __frontend_reg_store_fpr(v4, __frontend_reg_load_fpr(v3));
    __frontend_reg_store_fpr(v3, __frontend_reg_load_fpr(v4) + __frontend_reg_load_fpr(v3));
    __frontend_reg_store_fpr(v4, v1);
    __frontend_reg_load_fpr(v4);
    __frontend_reg_load_fpr(v3);
    int32_t v5; // 0x8059634
    char v6 = (uint32_t)v5 / 256; // 0x8059665
    if ((v6 & 64) != 0 != ((v6 & 4) == 0)) {
        // 0x8059695
        return 0;
    }
    // 0x8059675
    __frontend_reg_store_fpr(v3, v1);
    __frontend_reg_store_fpr(v4, 0.0L);
    float80_t v7 = __frontend_reg_load_fpr(v4); // 0x805967a
    __frontend_reg_store_fpr(v4, __frontend_reg_load_fpr(v3));
    __frontend_reg_store_fpr(v3, v7);
    __frontend_reg_load_fpr(v4);
    __frontend_reg_load_fpr(v3);
    if ((v6 & 68) != 64) {
        // 0x8059695
        return 1;
    }
    // 0x8059695
    return 0;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/vasnprintf.c
// Address range: 0x805969a - 0x805cad5
// Line range:    1419 - 4678
char * vasnprintf(char * resultbuf, int32_t * lengthp, char * format2, char * args) {
    // 0x805969a
    int32_t v1; // 0x805969a
    uint32_t v2 = v1;
    int32_t v3 = __readgsdword(20); // 0x80596ca
    char * v4 = format2; // bp-1372, 0x80596ef
    int32_t v5; // bp-1044, 0x805969a
    int32_t v6; // bp-1132, 0x805969a
    int32_t v7 = printf_parse(format2, &v6, &v5); // 0x80596f2
    int32_t v8 = 0; // 0x80596f9
    int32_t v9; // 0x805969a
    char * v10; // 0x805969a
    int32_t v11; // 0x805969a
    int32_t v12; // 0x805969a
    int32_t v13; // 0x805969a
    if (v7 >= 0) {
        // 0x805970a
        *(int32_t *)&v4 = (int32_t)args;
        if (printf_fetchargs(args, &v5) >= 0) {
            int32_t v14 = (int32_t)&v4; // 0x80596a0
            v4 = (char *)7;
            int32_t size = xsum4(7, v1, v1, 6); // 0x8059789
            if (size < 4000) {
                int32_t v15 = v14 - (size + 30 & -16); // 0x80597b2
                v10 = (char *)(v15 + 51 & -16);
                v9 = v15;
                v13 = 0;
                goto lab_0x8059831;
            } else {
                // 0x80597eb
                v12 = -1;
                if (size == -1) {
                    goto lab_0x805ca7b;
                } else {
                    // 0x8059804
                    v4 = (char *)size;
                    int32_t * mem = malloc(size); // 0x805980d
                    v12 = size;
                    if (mem == NULL) {
                        goto lab_0x805ca7b;
                    } else {
                        // 0x8059825
                        v10 = (char *)mem;
                        v11 = size;
                        v9 = v14;
                        v13 = (int32_t)mem;
                        goto lab_0x8059831;
                    }
                }
            }
        } else {
            // 0x8059726
            v4 = (char *)v1;
            free((int32_t *)v1);
            if (v1 != 0) {
                // 0x805973e
                v4 = (char *)v1;
                free((int32_t *)v1);
            }
            // 0x805974c
            *__errno_location() = 22;
            v8 = 0;
            goto lab_0x805cab6;
        }
    } else {
        goto lab_0x805cab6;
    }
  lab_0x805ca3f_12:;
    // 0x805ca3f
    char * v16; // bp-764, 0x805969a
    char * v17 = v16; // 0x805ca3f
    int32_t * v18; // 0x805969a
    if (v17 != resultbuf && v17 != NULL) {
        // 0x805ca56
        *v18 = (int32_t)v17;
        free(&g49);
    }
    // 0x805ca64
    v12 = v11;
    if (v13 != 0) {
        // 0x805ca6d
        *v18 = v13;
        free(&g49);
        v12 = v11;
    }
    goto lab_0x805ca7b;
  lab_0x805c539:;
    // 0x805c539
    float80_t v99; // 0x805969a
    float80_t v100 = v99; // 0x805c539
    int32_t v101; // 0x805969a
    if ((int16_t)(float16_t)v100 < 0) {
        char * v102 = v16; // 0x805c543
        if (v102 == resultbuf || v102 == NULL) {
            goto lab_0x805c568;
        } else {
            // 0x805c55a
            *v18 = (int32_t)v102;
            free((int32_t *)(int32_t)(float32_t)(float80_t)(int80_t)v101);
            goto lab_0x805c568;
        }
    }
    int32_t v103 = (float16_t)v100; // 0x805c5bf
    uint32_t v104; // 0x805969a
    if (v103 + 1 < v104) {
        // break (via goto) -> 0x805c773
        goto lab_0x805c773;
    }
    if (v104 == 0x7fffffff) {
        char * v105 = v16; // 0x805c9c6
        if (v105 == resultbuf || v105 == NULL) {
            goto lab_0x805c9eb;
        } else {
            // 0x805c9dd
            *v18 = (int32_t)v105;
            free((int32_t *)(int32_t)(float32_t)(float80_t)(int80_t)v101);
            goto lab_0x805c9eb;
        }
    }
    // 0x805c5e4
    int32_t * v22; // 0x805969a
    *v22 = v103 + 2;
    int32_t v98; // 0x805aa7f
    *v18 = v98;
    int32_t v106; // 0x805969a
    int32_t v107 = xsum(v106, (int32_t)&g49); // 0x805c61e
    *v22 = v106;
    *v18 = v107;
    uint32_t v108 = xmax((int32_t)&g49, (int32_t)&g49); // 0x805c630
    int32_t v97; // 0x805969a
    int32_t v109; // 0x805969a
    int32_t * mem6; // 0x805969a
    if (v108 > v109) {
        uint32_t size5 = v109 == 0 ? 12 : v106;
        v97 = v108 > size5 ? v108 : size5;
        if (v97 == -1) {
            goto lab_0x805ca3f_12;
        } else {
            char * v110 = v16; // 0x805c6d1
            if (v110 != resultbuf == (v110 != NULL)) {
                // 0x805c6fe
                *v22 = v97;
                *v18 = (int32_t)v16;
                mem6 = realloc((int32_t *)size5, (int32_t)&g49);
                goto lab_0x805c71c;
            } else {
                // 0x805c6e8
                *v18 = v97;
                mem6 = malloc(size5);
                goto lab_0x805c71c;
            }
        }
    }
    goto lab_0x805abec_2;
  lab_0x805abec_3:;
    // 0x805abec
    int32_t * v95; // 0x805969a
    v16 = (char *)v95;
    int32_t v96; // 0x805969a
    int32_t v141 = v96; // 0x805969a
    goto lab_0x805abec_4;
  lab_0x805c77f:;
    // 0x805c77f
    int32_t v46; // 0x805969a
    char * v146 = (char *)*(int32_t *)(v46 + 4); // 0x805c788
    char * v21 = v146; // bp-752, 0x805c788
    char * v42 = v146; // 0x805c79c
    int32_t v73; // 0x805969a
    int32_t v43 = v73; // 0x805c79c
    int16_t v74; // 0x805969a
    int16_t v44 = v74; // 0x805c79c
    int32_t v48; // 0x805969a
    int32_t v45 = v48 + 1; // 0x805c79c
    int32_t v47 = v46 + 44; // 0x805c79c
    goto lab_0x8059896;
  lab_0x8059d92:;
    // 0x8059d92
    int32_t v69; // 0x805969a
    int32_t v147 = 16 * v69 + v1; // 0x8059da4
    int32_t v70 = v69; // 0x8059dac
    int32_t v65; // 0x805969a
    int16_t v64; // 0x805969a
    float80_t v35; // bp-940, 0x805969a
    int32_t * v23; // 0x805969a
    char v25; // 0x805969a
    int32_t v27; // 0x805969a
    char * v66; // 0x8059a66
    int32_t * v68; // 0x805969a
    if (*(int32_t *)v147 != 12) {
        goto lab_0x805a758;
    } else {
        // 0x8059db2
        *v18 = *(int32_t *)(v147 + 4);
        *v22 = *(int32_t *)(v147 + 8);
        *v23 = *(int32_t *)(v147 + 12);
        if (is_infinitel((float64_t)(int64_t)&g49) == 0) {
            // 0x8059db2
            v70 = *v68;
            goto lab_0x805a758;
        } else {
            // 0x8059de8
            if (*(int32_t *)(v46 + 12) != *(int32_t *)(v46 + 16)) {
                int32_t v148 = *(int32_t *)(v46 + 20); // 0x8059e2b
                int32_t v149 = 0; // 0x8059e31
                int32_t v150; // 0x8059e11
                int32_t v151 = v150; // 0x8059e31
                if (v148 == -1) {
                    int32_t v152 = v151;
                    uint32_t v153 = v149;
                    char v154 = *(char *)v152; // 0x8059ebb
                    int32_t v155 = (int32_t)v154 - 48; // 0x8059ec1
                    int32_t v156 = v152 + 1; // 0x8059eca
                    int32_t v157 = v153 < 0x1999999a ? 10 * v153 : -1;
                    *v22 = v155;
                    *v18 = v157;
                    int32_t v158 = xsum(v155, v157); // 0x8059f12
                    int32_t * v159; // 0x8059e1a
                    int32_t v160 = *v159; // 0x8059f23
                    v149 = v158;
                    v151 = v156;
                    while (v160 != v156) {
                        // 0x8059eb5
                        v152 = v151;
                        v153 = v149;
                        v154 = *(char *)v152;
                        v155 = (int32_t)v154 - 48;
                        v156 = v152 + 1;
                        v157 = v153 < 0x1999999a ? 10 * v153 : -1;
                        *v22 = v155;
                        *v18 = v157;
                        v158 = xsum(v155, v157);
                        v160 = *v159;
                        v149 = v158;
                        v151 = v156;
                    }
                } else {
                    // 0x8059e33
                    int32_t v161; // 0x805969a
                    int32_t v162 = 16 * v148 + v161; // 0x8059e45
                    int32_t v163 = *(int32_t *)v162; // 0x8059e48
                    if (v163 != 5) {
                        // 0x8059e4f
                        abort();
                        // UNREACHABLE
                    }
                    int32_t v164 = *(int32_t *)(v162 + 4); // 0x8059e69
                    if (v164 < 0) {
                        // branch -> 0x8059f38
                    }
                }
            }
            uint32_t v165 = 0;
            int32_t v166 = *(int32_t *)(v46 + 8);
            int32_t v167 = *(int32_t *)(v46 + 24); // 0x8059f52
            int32_t v168 = *(int32_t *)(v46 + 28); // 0x8059f5b
            int32_t v169 = 0; // 0x8059f60
            int32_t v170 = 0; // 0x8059f60
            if (v167 != v168) {
                int32_t v171 = *(int32_t *)(v46 + 32); // 0x8059f6c
                if (v171 == -1) {
                    // 0x805a061
                    v169 = 1;
                    v170 = 0;
                    if (v168 != v167 + 1) {
                        int32_t v172; // 0x805969a
                        uint32_t v173 = v172;
                        int32_t v174; // 0x805969a
                        int32_t v175 = v174;
                        char v176 = *(char *)v175; // 0x8059fff
                        int32_t v177 = (int32_t)v176 - 48; // 0x805a005
                        int32_t v178 = v173 < 0x1999999a ? 10 * v173 : -1;
                        *v22 = v177;
                        *v18 = v178;
                        int32_t v179 = xsum(v177, v178); // 0x805a056
                        int32_t v180 = v175 + 1;
                        int32_t * v181; // 0x8059f5b
                        int32_t v182 = *v181; // 0x805a067
                        v174 = v180;
                        v172 = v179;
                        v169 = 1;
                        v170 = v179;
                        while (v182 != v180) {
                            // 0x8059ff9
                            v173 = v172;
                            v175 = v174;
                            v176 = *(char *)v175;
                            v177 = (int32_t)v176 - 48;
                            v178 = v173 < 0x1999999a ? 10 * v173 : -1;
                            *v22 = v177;
                            *v18 = v178;
                            v179 = xsum(v177, v178);
                            v180 = v175 + 1;
                            v182 = *v181;
                            v174 = v180;
                            v172 = v179;
                            v169 = 1;
                            v170 = v179;
                        }
                    }
                } else {
                    int32_t v183 = 16 * v171 + v1; // 0x8059f86
                    if (*(int32_t *)v183 != 5) {
                        // 0x8059f90
                        abort();
                        // UNREACHABLE
                    }
                    int32_t v184 = *(int32_t *)(v183 + 4); // 0x8059faa
                    v169 = v184 >= 0;
                    v170 = v184 < 0 ? 0 : v184;
                }
            }
            int32_t v185 = v169 != 0 ? v170 : 6;
            *v22 = 12;
            *v18 = v185 == 0 ? 0 : v185;
            uint32_t v186 = xsum(v185, v169); // 0x805a0c4
            *v22 = 1;
            *v18 = v186 >= v165 ? v186 : v165;
            uint32_t size7 = xsum((int32_t)&g49, (int32_t)&g49); // 0x805a0fa
            int32_t v187 = v27; // 0x805a10f
            if (size7 >= 701) {
                if (size7 == -1) {
                    goto lab_0x805ca3f_12;
                }
                // 0x805a138
                *v18 = size7;
                int32_t * mem8 = malloc(size7); // 0x805a141
                if (mem8 == NULL) {
                    goto lab_0x805ca3f_12;
                }
                // 0x805a138
                v187 = (int32_t)mem8;
            }
            int32_t v188 = v187;
            char * v189 = (char *)(int32_t)(float32_t)(float64_t)(int64_t)v188; // bp-840, 0x805a169
            int32_t v190 = 16 * *v68 + v1; // 0x805a181
            int32_t v191 = *(int32_t *)(v190 + 12); // 0x805a184
            int32_t v192 = *(int32_t *)(v190 + 8); // 0x805a187
            int32_t v193 = *(int32_t *)(v190 + 4); // 0x805a18a
            *v18 = v193;
            *v22 = v192;
            *v23 = v191;
            char * v194; // 0x805969a
            if (rpl_isnanl((float64_t)(int64_t)v188) == 0) {
                float80_t v195 = v35; // 0x805a25f
                v35 = (int80_t)((int16_t)(float16_t)v195 | 768);
                *v18 = (int32_t)(float32_t)(float80_t)(int80_t)v193;
                *v22 = v192;
                *v23 = v191;
                if (__signbitl(v35) == 0) {
                    if ((v166 & 4) == 0) {
                        if ((v166 & 8) != 0) {
                            // 0x805a309
                            *v189 = 32;
                            v189 = (char *)((int32_t)v189 + 1);
                        }
                    } else {
                        // 0x805a2ea
                        *v189 = 43;
                        v189 = (char *)((int32_t)v189 + 1);
                    }
                } else {
                    // 0x805a2cb
                    *v189 = 45;
                    v189 = (char *)((int32_t)v189 + 1);
                }
                if ((v2 & 0x4100) == 0 != ((v25 & 64) != 0 == (v25 & 4) == 0)) {
                    // 0x805a3f2
                    abort();
                    // UNREACHABLE
                }
                char * v196 = v189;
                int32_t v197; // 0x805969a
                if (*v66 > 90) {
                    // 0x805a3ac
                    *v196 = 105;
                    int32_t v198 = (int32_t)v189; // 0x805a3b5
                    *(char *)(v198 + 1) = 110;
                    *(char *)(v198 + 2) = 102;
                    v197 = v198;
                } else {
                    // 0x805a37a
                    *v196 = 73;
                    int32_t v199 = (int32_t)v189; // 0x805a383
                    *(char *)(v199 + 1) = 78;
                    *(char *)(v199 + 2) = 70;
                    v197 = v199;
                }
                char * v200 = (char *)(v197 + 3);
                v189 = v200;
                v35 = v195;
                v194 = v200;
            } else {
                char * v201 = v189;
                if (*v66 > 90) {
                    // 0x805a21a
                    *v201 = 110;
                    int32_t v202 = (int32_t)v189; // 0x805a223
                    *(char *)(v202 + 1) = 97;
                    *(char *)(v202 + 2) = 110;
                    char * v203 = (char *)(v202 + 3); // 0x805a243
                    v189 = v203;
                    v194 = v203;
                } else {
                    // 0x805a1e5
                    *v201 = 78;
                    int32_t v204 = (int32_t)v189; // 0x805a1ee
                    *(char *)(v204 + 1) = 65;
                    *(char *)(v204 + 2) = 78;
                    char * v205 = (char *)(v204 + 3); // 0x805a20e
                    v189 = v205;
                    v194 = v205;
                }
            }
            char * v206 = v194; // 0x805a52a
            char * v207 = v206; // 0x805a3fe
            uint32_t v208 = (int32_t)v207 - (int32_t)(float32_t)(float64_t)(int64_t)v188; // 0x805a574
            if (v208 >= size7) {
                // 0x805a58c
                abort();
                // UNREACHABLE
            }
            int32_t v209 = v64; // 0x805a591
            int32_t v210 = v65; // 0x805a5a9
            if (v65 - v209 <= v208) {
                // 0x805a5af
                *v22 = v208;
                *v18 = v209;
                uint32_t v211 = xsum((int32_t)v189, (int32_t)&g49); // 0x805a5c2
                v210 = v65;
                if (v211 > v65) {
                    int32_t v212 = 12; // 0x805a5e6
                    if (v65 != 0) {
                        // 0x805a5e8
                        v212 = v65 < 0 ? -1 : 2 * v65;
                    }
                    uint32_t size8 = v212;
                    int32_t v213 = v211 > size8 ? v211 : size8;
                    if (v213 == -1) {
                        goto lab_0x805ca3f_12;
                    }
                    char * v214 = v16; // 0x805a663
                    int32_t * mem9; // 0x805969a
                    if (v214 != resultbuf == (v214 != NULL)) {
                        // 0x805a690
                        *v22 = v213;
                        *v18 = (int32_t)v16;
                        mem9 = realloc((int32_t *)size8, (int32_t)&g49);
                    } else {
                        // 0x805a67a
                        *v18 = v213;
                        mem9 = malloc(size8);
                    }
                    int32_t * v215 = mem9;
                    if (v215 == NULL) {
                        goto lab_0x805ca3f_12;
                    }
                    // 0x805a6bb
                    if (v64 != 0 && v16 == resultbuf) {
                        // 0x805a6d2
                        *v23 = v209;
                        *v22 = (int32_t)v16;
                        *v18 = (int32_t)v215;
                        memcpy(v215, &g49, (int32_t)&g49);
                    }
                    // 0x805a6f4
                    v16 = (char *)v215;
                    v210 = v213;
                }
            }
            // 0x805a700
            *v23 = v208;
            *v22 = (int32_t)(float32_t)(float64_t)(int64_t)v188;
            *v18 = (int32_t)v16 + v209;
            memcpy(&g49, &g49, (int32_t)&g49);
            if ((int32_t)(float32_t)(float64_t)(int64_t)v188 != v27) {
                // 0x805a739
                *v18 = (int32_t)(float32_t)(float64_t)(int64_t)v188;
                free(&g49);
            }
            // 0x805a747
            v73 = v210;
            v74 = v64 + (int16_t)v208;
            goto lab_0x805c77f;
        }
    }
  lab_0x805a758:;
    uint32_t v111 = *(int32_t *)(16 * v70 + v1); // 0x805a76d
    uint32_t v216 = *(int32_t *)(v46 + 8); // 0x805a77b
    *v10 = 37;
    int32_t v29; // 0x805969a
    int32_t v217 = v29; // 0x805a7ab
    int32_t v28; // 0x805969a
    if (v216 % 2 != 0) {
        // 0x805a7ad
        *(char *)v29 = 39;
        v217 = v28 + 2;
    }
    int32_t v218 = v217;
    int32_t v219 = v218; // 0x805a7c8
    if ((v216 & 2) != 0) {
        // 0x805a7ca
        *(char *)v218 = 45;
        v219 = v218 + 1;
    }
    int32_t v220 = v219;
    int32_t v221 = v220; // 0x805a7e5
    if ((v216 & 4) != 0) {
        // 0x805a7e7
        *(char *)v220 = 43;
        v221 = v220 + 1;
    }
    int32_t v222 = v221;
    int32_t v223 = v222; // 0x805a802
    if ((v216 & 8) != 0) {
        // 0x805a804
        *(char *)v222 = 32;
        v223 = v222 + 1;
    }
    int32_t v224 = v223;
    int32_t v225 = v224; // 0x805a81f
    if ((v216 & 16) != 0) {
        // 0x805a821
        *(char *)v224 = 35;
        v225 = v224 + 1;
    }
    int32_t v226 = v225;
    int32_t v227 = v226; // 0x805a83c
    if ((v216 & 32) != 0) {
        // 0x805a83e
        *(char *)v226 = 48;
        v227 = v226 + 1;
    }
    int32_t v228 = v227;
    int32_t v229 = *(int32_t *)(v46 + 12); // 0x805a854
    int32_t v230 = *(int32_t *)(v46 + 16); // 0x805a85d
    int32_t v231 = v228; // 0x805a862
    if (v230 != v229) {
        int32_t v232 = v230 - v229; // 0x805a87a
        *v23 = v232;
        *v22 = v229;
        *v18 = v228;
        memcpy((int32_t *)v228, (int32_t *)v111, (int32_t)&g49);
        v231 = v232 + v228;
    }
    int32_t v233 = v231;
    int32_t v234 = *(int32_t *)(v46 + 24); // 0x805a8bb
    int32_t v235 = *(int32_t *)(v46 + 28); // 0x805a8c4
    int32_t v236 = v233; // 0x805a8c9
    if (v235 != v234) {
        int32_t v237 = v235 - v234; // 0x805a8e1
        *v23 = v237;
        *v22 = v234;
        *v18 = v233;
        memcpy((int32_t *)v233, &g49, (int32_t)&g49);
        v236 = v237 + v233;
    }
    int32_t v238 = v236;
    int32_t v239 = v238; // 0x805a923
    int32_t v240; // 0x805969a
    if (v111 < 17) {
        uint32_t v241 = v111 % 32; // 0x805a932
        int32_t v242 = 1 << v241;
        v240 = v238;
        if ((v242 & 0x14180) != 0) {
            goto lab_0x805a977;
        } else {
            if (v241 == 12) {
                // 0x805a989
                *(char *)v238 = 76;
                v239 = v238 + 1;
                goto lab_0x805a999;
            } else {
                // 0x805a958
                v239 = v238;
                if ((v242 & 1536) == 0) {
                    goto lab_0x805a999;
                } else {
                    // 0x805a967
                    *(char *)v238 = 108;
                    v240 = v238 + 1;
                    goto lab_0x805a977;
                }
            }
        }
    } else {
        goto lab_0x805a999;
    }
  lab_0x805a999:
    // 0x805a999
    *(char *)v239 = *v66;
    char * v138 = (char *)(v239 + 1); // 0x805a9b4
    *v138 = 0;
    int32_t v243 = *(int32_t *)(v46 + 20); // 0x805a9c7
    int32_t v244 = 0; // 0x805a9cd
    int32_t v31; // 0x805969a
    if (v243 != -1) {
        int32_t v245 = 16 * v243 + v1; // 0x805a9e1
        if (*(int32_t *)v245 != 5) {
            // 0x805a9eb
            abort();
            // UNREACHABLE
        }
        // 0x805a9f0
        *(int32_t *)v31 = *(int32_t *)(v245 + 4);
        v244 = 1;
    }
    int32_t v246 = v244;
    int32_t v247 = *(int32_t *)(v46 + 32); // 0x805aa22
    int32_t v248 = v246; // 0x805aa28
    if (v247 != -1) {
        int32_t v249 = 16 * v247 + v1; // 0x805aa3c
        if (*(int32_t *)v249 != 5) {
            // 0x805aa46
            abort();
            // UNREACHABLE
        }
        // 0x805aa4b
        *(int32_t *)(4 * v246 + v31) = *(int32_t *)(v249 + 4);
        v248 = v246 + 1;
    }
    int32_t v113 = v248;
    *v22 = 2;
    v98 = v64;
    *v18 = v98;
    char * v250; // 0x805969a
    int32_t v251; // 0x805969a
    if (xsum(v113, v239) > v65) {
        int32_t v252 = 12; // 0x805aaa0
        if (v65 != 0) {
            // 0x805aaa2
            v252 = v65 < 0 ? -1 : 2 * v65;
        }
        // 0x805aade
        *v22 = 2;
        *v18 = v98;
        uint32_t v253 = xsum(v252, (int32_t)&g49); // 0x805aafb
        int32_t v254 = v252; // 0x805ab06
        if (v253 > v252) {
            // 0x805ab08
            *v22 = 2;
            *v18 = v98;
            v254 = xsum((int32_t)&g49, (int32_t)&g49);
        }
        int32_t size9 = v254;
        if (size9 == -1) {
            goto lab_0x805ca3f_12;
        }
        char * v255 = v16; // 0x805ab3d
        int32_t * mem10; // 0x805969a
        if (v255 != resultbuf == (v255 != NULL)) {
            // 0x805ab6a
            *v22 = size9;
            *v18 = (int32_t)v16;
            mem10 = realloc((int32_t *)size9, (int32_t)&g49);
        } else {
            // 0x805ab54
            *v18 = size9;
            mem10 = malloc(size9);
        }
        int32_t * v256 = mem10;
        if (v256 == NULL) {
            goto lab_0x805ca3f_12;
        }
        // 0x805ab95
        if (v64 != 0 && v16 == resultbuf) {
            // 0x805abac
            *v23 = v98;
            *v22 = (int32_t)v16;
            *v18 = (int32_t)v256;
            memcpy(v256, &g49, (int32_t)&g49);
        }
        // 0x805abce
        v16 = (char *)v256;
        v250 = (char *)v256;
        v251 = size9;
    } else {
        // 0x805aa77
        v250 = v16;
        v251 = v65;
    }
    // 0x805abda
    *(char *)((int32_t)v250 + v98) = 0;
    char * str = (char *)v113;
    v141 = v251;
    int32_t v24; // 0x805969a
    int32_t v32; // 0x805969a
    int32_t * v33; // 0x805969a
    int32_t v34; // 0x805969a
    int32_t v36; // 0x805969a
    int32_t * v37; // 0x805969a
    int32_t v38; // 0x805969a
    int32_t * v39; // 0x805969a
    int32_t * v40; // 0x805969a
    int32_t * v41; // 0x805969a
    while (true) {
      lab_0x805abec_4:
        // 0x805abec
        v109 = v141;
        int32_t v142 = v109 - v98; // 0x805ac0c
        v104 = v142 >= 0 ? v142 : 0x7fffffff;
        v106 = v109 < 0 ? -1 : 2 * v109;
        uint32_t v139; // 0x805c3ea
        while (true) {
          lab_0x805abec_2:
            // 0x805abec
            v35 = -NAN;
            g45 = v111;
            int32_t chars_printed; // 0x805969a
            switch (v111) {
                case 1: {
                    int32_t v112 = (int32_t)*(char *)(16 * *v68 + v24); // 0x805ac5f
                    switch (v113) {
                        case 1: {
                            // 0x805ace2
                            *v39 = v34;
                            *v33 = v112;
                            *v23 = v28;
                            *v22 = v104;
                            *v18 = (int32_t)v16 + v98;
                            chars_printed = snprintf(str, (int32_t)&g49, (char *)&g49);
                            // break -> 0x805c32e
                            break;
                        }
                        case 0: {
                            // 0x805ac98
                            *v33 = v34;
                            *v37 = v112;
                            *v23 = v28;
                            *v22 = v104;
                            *v18 = (int32_t)v16 + v98;
                            chars_printed = snprintf(str, (int32_t)&g49, (char *)&g49);
                            // break -> 0x805c32e
                            break;
                        }
                        default: {
                            if (str != (char *)2) {
                                // 0x805ad94
                                abort();
                                // UNREACHABLE
                            }
                            // 0x805ad36
                            *v40 = v34;
                            *v39 = v112;
                            *v23 = v28;
                            *v22 = v104;
                            *v18 = (int32_t)v16 + v98;
                            int32_t chars_printed2 = snprintf((char *)2, (int32_t)&g49, (char *)&g49); // 0x805ad84
                            chars_printed = chars_printed2;
                            // break -> 0x805c32e
                            break;
                        }
                    }
                    // break -> 0x805c32e
                    break;
                }
                case 2: {
                    int32_t v114 = (int32_t)*(char *)(16 * *v68 + v24); // 0x805adae
                    switch (v113) {
                        case 1: {
                            // 0x805ae35
                            *v39 = v34;
                            *v33 = v114;
                            *v23 = v28;
                            *v22 = v104;
                            *v18 = (int32_t)v16 + v98;
                            chars_printed = snprintf(str, (int32_t)&g49, (char *)&g49);
                            // break -> 0x805c32e
                            break;
                        }
                        case 0: {
                            // 0x805adeb
                            *v33 = v34;
                            *v37 = v114;
                            *v23 = v28;
                            *v22 = v104;
                            *v18 = (int32_t)v16 + v98;
                            chars_printed = snprintf(str, (int32_t)&g49, (char *)&g49);
                            // break -> 0x805c32e
                            break;
                        }
                        default: {
                            if (str != (char *)2) {
                                // 0x805aee7
                                abort();
                                // UNREACHABLE
                            }
                            // 0x805ae89
                            *v40 = v34;
                            *v39 = v114;
                            *v23 = v28;
                            *v22 = v104;
                            *v18 = (int32_t)v16 + v98;
                            int32_t chars_printed3 = snprintf((char *)2, (int32_t)&g49, (char *)&g49); // 0x805aed7
                            chars_printed = chars_printed3;
                            // break -> 0x805c32e
                            break;
                        }
                    }
                    // break -> 0x805c32e
                    break;
                }
                case 3: {
                    int32_t v115 = (int32_t)*(int16_t *)(16 * *v68 + v24); // 0x805af05
                    switch (v113) {
                        case 1: {
                            // 0x805af86
                            *v39 = v34;
                            *v33 = v115;
                            *v23 = v28;
                            *v22 = v104;
                            *v18 = (int32_t)v16 + v98;
                            chars_printed = snprintf(str, (int32_t)&g49, (char *)&g49);
                            // break -> 0x805c32e
                            break;
                        }
                        case 0: {
                            // 0x805af3c
                            *v33 = v34;
                            *v37 = v115;
                            *v23 = v28;
                            *v22 = v104;
                            *v18 = (int32_t)v16 + v98;
                            chars_printed = snprintf(str, (int32_t)&g49, (char *)&g49);
                            // break -> 0x805c32e
                            break;
                        }
                        default: {
                            if (str != (char *)2) {
                                // 0x805b038
                                abort();
                                // UNREACHABLE
                            }
                            // 0x805afda
                            *v40 = v34;
                            *v39 = v115;
                            *v23 = v28;
                            *v22 = v104;
                            *v18 = (int32_t)v16 + v98;
                            int32_t chars_printed4 = snprintf((char *)2, (int32_t)&g49, (char *)&g49); // 0x805b028
                            chars_printed = chars_printed4;
                            // break -> 0x805c32e
                            break;
                        }
                    }
                    // break -> 0x805c32e
                    break;
                }
                case 4: {
                    int32_t v116 = (int32_t)*(int16_t *)(16 * *v68 + v24); // 0x805b052
                    switch (v113) {
                        case 1: {
                            // 0x805b0d9
                            *v39 = v34;
                            *v33 = v116;
                            *v23 = v28;
                            *v22 = v104;
                            *v18 = (int32_t)v16 + v98;
                            chars_printed = snprintf(str, (int32_t)&g49, (char *)&g49);
                            // break -> 0x805c32e
                            break;
                        }
                        case 0: {
                            // 0x805b08f
                            *v33 = v34;
                            *v37 = v116;
                            *v23 = v28;
                            *v22 = v104;
                            *v18 = (int32_t)v16 + v98;
                            chars_printed = snprintf(str, (int32_t)&g49, (char *)&g49);
                            // break -> 0x805c32e
                            break;
                        }
                        default: {
                            if (str != (char *)2) {
                                // 0x805b18b
                                abort();
                                // UNREACHABLE
                            }
                            // 0x805b12d
                            *v40 = v34;
                            *v39 = v116;
                            *v23 = v28;
                            *v22 = v104;
                            *v18 = (int32_t)v16 + v98;
                            int32_t chars_printed5 = snprintf((char *)2, (int32_t)&g49, (char *)&g49); // 0x805b17b
                            chars_printed = chars_printed5;
                            // break -> 0x805c32e
                            break;
                        }
                    }
                    // break -> 0x805c32e
                    break;
                }
                case 5: {
                    int32_t v117 = *(int32_t *)(16 * *v68 + v24); // 0x805b1a5
                    switch (v113) {
                        case 1: {
                            // 0x805b228
                            *v39 = v34;
                            *v33 = v117;
                            *v23 = v28;
                            *v22 = v104;
                            *v18 = (int32_t)v16 + v98;
                            chars_printed = snprintf(str, (int32_t)&g49, (char *)&g49);
                            // break -> 0x805c32e
                            break;
                        }
                        case 0: {
                            // 0x805b1de
                            *v33 = v34;
                            *v37 = v117;
                            *v23 = v28;
                            *v22 = v104;
                            *v18 = (int32_t)v16 + v98;
                            chars_printed = snprintf(str, (int32_t)&g49, (char *)&g49);
                            // break -> 0x805c32e
                            break;
                        }
                        default: {
                            if (str != (char *)2) {
                                // 0x805b2da
                                abort();
                                // UNREACHABLE
                            }
                            // 0x805b27c
                            *v40 = v34;
                            *v39 = v117;
                            *v23 = v28;
                            *v22 = v104;
                            *v18 = (int32_t)v16 + v98;
                            int32_t chars_printed6 = snprintf((char *)2, (int32_t)&g49, (char *)&g49); // 0x805b2ca
                            chars_printed = chars_printed6;
                            // break -> 0x805c32e
                            break;
                        }
                    }
                    // break -> 0x805c32e
                    break;
                }
                case 6: {
                    int32_t v118 = *(int32_t *)(16 * *v68 + v24); // 0x805b2f4
                    switch (v113) {
                        case 1: {
                            // 0x805b377
                            *v39 = v34;
                            *v33 = v118;
                            *v23 = v28;
                            *v22 = v104;
                            *v18 = (int32_t)v16 + v98;
                            chars_printed = snprintf(str, (int32_t)&g49, (char *)&g49);
                            // break -> 0x805c32e
                            break;
                        }
                        case 0: {
                            // 0x805b32d
                            *v33 = v34;
                            *v37 = v118;
                            *v23 = v28;
                            *v22 = v104;
                            *v18 = (int32_t)v16 + v98;
                            chars_printed = snprintf(str, (int32_t)&g49, (char *)&g49);
                            // break -> 0x805c32e
                            break;
                        }
                        default: {
                            if (str != (char *)2) {
                                // 0x805b429
                                abort();
                                // UNREACHABLE
                            }
                            // 0x805b3cb
                            *v40 = v34;
                            *v39 = v118;
                            *v23 = v28;
                            *v22 = v104;
                            *v18 = (int32_t)v16 + v98;
                            int32_t chars_printed7 = snprintf((char *)2, (int32_t)&g49, (char *)&g49); // 0x805b419
                            chars_printed = chars_printed7;
                            // break -> 0x805c32e
                            break;
                        }
                    }
                    // break -> 0x805c32e
                    break;
                }
                case 7: {
                    int32_t v119 = *(int32_t *)(16 * *v68 + v24); // 0x805b443
                    switch (v113) {
                        case 1: {
                            // 0x805b4c6
                            *v39 = v34;
                            *v33 = v119;
                            *v23 = v28;
                            *v22 = v104;
                            *v18 = (int32_t)v16 + v98;
                            chars_printed = snprintf(str, (int32_t)&g49, (char *)&g49);
                            // break -> 0x805c32e
                            break;
                        }
                        case 0: {
                            // 0x805b47c
                            *v33 = v34;
                            *v37 = v119;
                            *v23 = v28;
                            *v22 = v104;
                            *v18 = (int32_t)v16 + v98;
                            chars_printed = snprintf(str, (int32_t)&g49, (char *)&g49);
                            // break -> 0x805c32e
                            break;
                        }
                        default: {
                            if (str != (char *)2) {
                                // 0x805b578
                                abort();
                                // UNREACHABLE
                            }
                            // 0x805b51a
                            *v40 = v34;
                            *v39 = v119;
                            *v23 = v28;
                            *v22 = v104;
                            *v18 = (int32_t)v16 + v98;
                            int32_t chars_printed8 = snprintf((char *)2, (int32_t)&g49, (char *)&g49); // 0x805b568
                            chars_printed = chars_printed8;
                            // break -> 0x805c32e
                            break;
                        }
                    }
                    // break -> 0x805c32e
                    break;
                }
                case 8: {
                    int32_t v120 = *(int32_t *)(16 * *v68 + v24); // 0x805b592
                    switch (v113) {
                        case 1: {
                            // 0x805b615
                            *v39 = v34;
                            *v33 = v120;
                            *v23 = v28;
                            *v22 = v104;
                            *v18 = (int32_t)v16 + v98;
                            chars_printed = snprintf(str, (int32_t)&g49, (char *)&g49);
                            // break -> 0x805c32e
                            break;
                        }
                        case 0: {
                            // 0x805b5cb
                            *v33 = v34;
                            *v37 = v120;
                            *v23 = v28;
                            *v22 = v104;
                            *v18 = (int32_t)v16 + v98;
                            chars_printed = snprintf(str, (int32_t)&g49, (char *)&g49);
                            // break -> 0x805c32e
                            break;
                        }
                        default: {
                            if (str != (char *)2) {
                                // 0x805b6c7
                                abort();
                                // UNREACHABLE
                            }
                            // 0x805b669
                            *v40 = v34;
                            *v39 = v120;
                            *v23 = v28;
                            *v22 = v104;
                            *v18 = (int32_t)v16 + v98;
                            int32_t chars_printed9 = snprintf((char *)2, (int32_t)&g49, (char *)&g49); // 0x805b6b7
                            chars_printed = chars_printed9;
                            // break -> 0x805c32e
                            break;
                        }
                    }
                    // break -> 0x805c32e
                    break;
                }
                case 9: {
                    int32_t v121 = 16 * *v68 + v1; // 0x805b6de
                    int32_t v122 = *(int32_t *)(v121 + 8); // 0x805b6e1
                    int32_t v123 = *(int32_t *)(v121 + 4); // 0x805b6e4
                    switch (v113) {
                        case 1: {
                            // 0x805b777
                            *v40 = v34;
                            *v33 = v123;
                            *v39 = v122;
                            *v23 = v28;
                            *v22 = v104;
                            *v18 = (int32_t)v16 + v98;
                            chars_printed = snprintf(str, (int32_t)&g49, (char *)&g49);
                            // break -> 0x805c32e
                            break;
                        }
                        case 0: {
                            // 0x805b723
                            *v39 = v34;
                            *v37 = v123;
                            *v33 = v122;
                            *v23 = v28;
                            *v22 = v104;
                            *v18 = (int32_t)v16 + v98;
                            chars_printed = snprintf(str, (int32_t)&g49, (char *)&g49);
                            // break -> 0x805c32e
                            break;
                        }
                        default: {
                            if (str != (char *)2) {
                                // 0x805b83d
                                abort();
                                // UNREACHABLE
                            }
                            // 0x805b7d5
                            *v41 = v34;
                            *v39 = v123;
                            *v40 = v122;
                            *v23 = v28;
                            *v22 = v104;
                            *v18 = (int32_t)v16 + v98;
                            int32_t chars_printed10 = snprintf((char *)2, (int32_t)&g49, (char *)&g49); // 0x805b82d
                            chars_printed = chars_printed10;
                            // break -> 0x805c32e
                            break;
                        }
                    }
                    // break -> 0x805c32e
                    break;
                }
                case 10: {
                    int32_t v124 = 16 * *v68 + v1; // 0x805b854
                    int32_t v125 = *(int32_t *)(v124 + 8); // 0x805b857
                    int32_t v126 = *(int32_t *)(v124 + 4); // 0x805b85a
                    switch (v113) {
                        case 1: {
                            // 0x805b8ed
                            *v40 = v34;
                            *v33 = v126;
                            *v39 = v125;
                            *v23 = v28;
                            *v22 = v104;
                            *v18 = (int32_t)v16 + v98;
                            chars_printed = snprintf(str, (int32_t)&g49, (char *)&g49);
                            // break -> 0x805c32e
                            break;
                        }
                        case 0: {
                            // 0x805b899
                            *v39 = v34;
                            *v37 = v126;
                            *v33 = v125;
                            *v23 = v28;
                            *v22 = v104;
                            *v18 = (int32_t)v16 + v98;
                            chars_printed = snprintf(str, (int32_t)&g49, (char *)&g49);
                            // break -> 0x805c32e
                            break;
                        }
                        default: {
                            if (str != (char *)2) {
                                // 0x805b9b3
                                abort();
                                // UNREACHABLE
                            }
                            // 0x805b94b
                            *v41 = v34;
                            *v39 = v126;
                            *v40 = v125;
                            *v23 = v28;
                            *v22 = v104;
                            *v18 = (int32_t)v16 + v98;
                            int32_t chars_printed11 = snprintf((char *)2, (int32_t)&g49, (char *)&g49); // 0x805b9a3
                            chars_printed = chars_printed11;
                            // break -> 0x805c32e
                            break;
                        }
                    }
                    // break -> 0x805c32e
                    break;
                }
                case 11: {
                    float64_t v127 = *(float64_t *)(16 * *v68 + v24); // 0x805b9cd
                    switch (v113) {
                        case 1: {
                            // 0x805ba50
                            *v40 = v34;
                            *(float64_t *)v32 = v127;
                            *v23 = v28;
                            *v22 = v104;
                            *v18 = (int32_t)v16 + v98;
                            chars_printed = snprintf(str, (int32_t)&g49, (char *)&g49);
                            // break -> 0x805c32e
                            break;
                        }
                        case 0: {
                            // 0x805ba06
                            *v39 = v34;
                            *(float64_t *)v36 = v127;
                            *v23 = v28;
                            *v22 = v104;
                            *v18 = (int32_t)v16 + v98;
                            chars_printed = snprintf(str, (int32_t)&g49, (char *)&g49);
                            // break -> 0x805c32e
                            break;
                        }
                        default: {
                            if (str != (char *)2) {
                                // 0x805bb02
                                abort();
                                // UNREACHABLE
                            }
                            // 0x805baa4
                            *v41 = v34;
                            *(float64_t *)v38 = v127;
                            *v23 = v28;
                            *v22 = v104;
                            *v18 = (int32_t)v16 + v98;
                            int32_t chars_printed12 = snprintf((char *)2, (int32_t)&g49, (char *)&g49); // 0x805baf2
                            chars_printed = chars_printed12;
                            // break -> 0x805c32e
                            break;
                        }
                    }
                    // break -> 0x805c32e
                    break;
                }
                case 12: {
                    int32_t v128 = 16 * *v68 + v1; // 0x805bb19
                    int32_t v129 = *(int32_t *)(v128 + 12); // 0x805bb1c
                    int32_t v130 = *(int32_t *)(v128 + 8); // 0x805bb1f
                    int32_t v131 = *(int32_t *)(v128 + 4); // 0x805bb22
                    switch (v113) {
                        case 1: {
                            // 0x805bbc5
                            *v41 = v34;
                            *v33 = v131;
                            *v39 = v130;
                            *v40 = v129;
                            *v23 = v28;
                            *v22 = v104;
                            *v18 = (int32_t)v16 + v98;
                            chars_printed = snprintf(str, (int32_t)&g49, (char *)&g49);
                            // break -> 0x805c32e
                            break;
                        }
                        case 0: {
                            // 0x805bb67
                            *v40 = v34;
                            *v37 = v131;
                            *v33 = v130;
                            *v39 = v129;
                            *v23 = v28;
                            *v22 = v104;
                            *v18 = (int32_t)v16 + v98;
                            chars_printed = snprintf(str, (int32_t)&g49, (char *)&g49);
                            // break -> 0x805c32e
                            break;
                        }
                        default: {
                            if (str != (char *)2) {
                                // 0x805bc9f
                                abort();
                                // UNREACHABLE
                            }
                            // 0x805bc2d
                            *(int32_t *)(v9 + 32) = v34;
                            *v39 = v131;
                            *v40 = v130;
                            *v41 = v129;
                            *v23 = v28;
                            *v22 = v104;
                            *v18 = (int32_t)v16 + v98;
                            int32_t chars_printed13 = snprintf((char *)2, (int32_t)&g49, (char *)&g49); // 0x805bc8f
                            chars_printed = chars_printed13;
                            // break -> 0x805c32e
                            break;
                        }
                    }
                    // break -> 0x805c32e
                    break;
                }
                case 13: {
                    int32_t v132 = *(int32_t *)(16 * *v68 + v24); // 0x805bcb9
                    switch (v113) {
                        case 1: {
                            // 0x805bd3c
                            *v39 = v34;
                            *v33 = v132;
                            *v23 = v28;
                            *v22 = v104;
                            *v18 = (int32_t)v16 + v98;
                            chars_printed = snprintf(str, (int32_t)&g49, (char *)&g49);
                            // break -> 0x805c32e
                            break;
                        }
                        case 0: {
                            // 0x805bcf2
                            *v33 = v34;
                            *v37 = v132;
                            *v23 = v28;
                            *v22 = v104;
                            *v18 = (int32_t)v16 + v98;
                            chars_printed = snprintf(str, (int32_t)&g49, (char *)&g49);
                            // break -> 0x805c32e
                            break;
                        }
                        default: {
                            if (str != (char *)2) {
                                // 0x805bdee
                                abort();
                                // UNREACHABLE
                            }
                            // 0x805bd90
                            *v40 = v34;
                            *v39 = v132;
                            *v23 = v28;
                            *v22 = v104;
                            *v18 = (int32_t)v16 + v98;
                            int32_t chars_printed14 = snprintf((char *)2, (int32_t)&g49, (char *)&g49); // 0x805bdde
                            chars_printed = chars_printed14;
                            // break -> 0x805c32e
                            break;
                        }
                    }
                    // break -> 0x805c32e
                    break;
                }
                case 14: {
                    int32_t v133 = *(int32_t *)(16 * *v68 + v24); // 0x805be08
                    switch (v113) {
                        case 1: {
                            // 0x805be8b
                            *v39 = v34;
                            *v33 = v133;
                            *v23 = v28;
                            *v22 = v104;
                            *v18 = (int32_t)v16 + v98;
                            chars_printed = snprintf(str, (int32_t)&g49, (char *)&g49);
                            // break -> 0x805c32e
                            break;
                        }
                        case 0: {
                            // 0x805be41
                            *v33 = v34;
                            *v37 = v133;
                            *v23 = v28;
                            *v22 = v104;
                            *v18 = (int32_t)v16 + v98;
                            chars_printed = snprintf(str, (int32_t)&g49, (char *)&g49);
                            // break -> 0x805c32e
                            break;
                        }
                        default: {
                            if (str != (char *)2) {
                                // 0x805bf3d
                                abort();
                                // UNREACHABLE
                            }
                            // 0x805bedf
                            *v40 = v34;
                            *v39 = v133;
                            *v23 = v28;
                            *v22 = v104;
                            *v18 = (int32_t)v16 + v98;
                            int32_t chars_printed15 = snprintf((char *)2, (int32_t)&g49, (char *)&g49); // 0x805bf2d
                            chars_printed = chars_printed15;
                            // break -> 0x805c32e
                            break;
                        }
                    }
                    // break -> 0x805c32e
                    break;
                }
                case 15: {
                    int32_t v134 = *(int32_t *)(16 * *v68 + v24); // 0x805bf57
                    switch (v113) {
                        case 1: {
                            // 0x805bfda
                            *v39 = v34;
                            *v33 = v134;
                            *v23 = v28;
                            *v22 = v104;
                            *v18 = (int32_t)v16 + v98;
                            chars_printed = snprintf(str, (int32_t)&g49, (char *)&g49);
                            // break -> 0x805c32e
                            break;
                        }
                        case 0: {
                            // 0x805bf90
                            *v33 = v34;
                            *v37 = v134;
                            *v23 = v28;
                            *v22 = v104;
                            *v18 = (int32_t)v16 + v98;
                            chars_printed = snprintf(str, (int32_t)&g49, (char *)&g49);
                            // break -> 0x805c32e
                            break;
                        }
                        default: {
                            if (str != (char *)2) {
                                // 0x805c08c
                                abort();
                                // UNREACHABLE
                            }
                            // 0x805c02e
                            *v40 = v34;
                            *v39 = v134;
                            *v23 = v28;
                            *v22 = v104;
                            *v18 = (int32_t)v16 + v98;
                            int32_t chars_printed16 = snprintf((char *)2, (int32_t)&g49, (char *)&g49); // 0x805c07c
                            chars_printed = chars_printed16;
                            // break -> 0x805c32e
                            break;
                        }
                    }
                    // break -> 0x805c32e
                    break;
                }
                case 16: {
                    int32_t v135 = *(int32_t *)(16 * *v68 + v24); // 0x805c0a6
                    switch (v113) {
                        case 1: {
                            // 0x805c129
                            *v39 = v34;
                            *v33 = v135;
                            *v23 = v28;
                            *v22 = v104;
                            *v18 = (int32_t)v16 + v98;
                            chars_printed = snprintf(str, (int32_t)&g49, (char *)&g49);
                            // break -> 0x805c32e
                            break;
                        }
                        case 0: {
                            // 0x805c0df
                            *v33 = v34;
                            *v37 = v135;
                            *v23 = v28;
                            *v22 = v104;
                            *v18 = (int32_t)v16 + v98;
                            chars_printed = snprintf(str, (int32_t)&g49, (char *)&g49);
                            // break -> 0x805c32e
                            break;
                        }
                        default: {
                            if (str != (char *)2) {
                                // 0x805c1db
                                abort();
                                // UNREACHABLE
                            }
                            // 0x805c17d
                            *v40 = v34;
                            *v39 = v135;
                            *v23 = v28;
                            *v22 = v104;
                            *v18 = (int32_t)v16 + v98;
                            int32_t chars_printed17 = snprintf((char *)2, (int32_t)&g49, (char *)&g49); // 0x805c1cb
                            chars_printed = chars_printed17;
                            // break -> 0x805c32e
                            break;
                        }
                    }
                    // break -> 0x805c32e
                    break;
                }
                case 17: {
                    int32_t v136 = *(int32_t *)(16 * *v68 + v24); // 0x805c1f5
                    switch (v113) {
                        case 1: {
                            // 0x805c278
                            *v39 = v34;
                            *v33 = v136;
                            *v23 = v28;
                            *v22 = v104;
                            *v18 = (int32_t)v16 + v98;
                            chars_printed = snprintf(str, (int32_t)&g49, (char *)&g49);
                            // break -> 0x805c32e
                            break;
                        }
                        case 0: {
                            // 0x805c22e
                            *v33 = v34;
                            *v37 = v136;
                            *v23 = v28;
                            *v22 = v104;
                            *v18 = (int32_t)v16 + v98;
                            chars_printed = snprintf(str, (int32_t)&g49, (char *)&g49);
                            // break -> 0x805c32e
                            break;
                        }
                        default: {
                            if (str != (char *)2) {
                                // 0x805c324
                                abort();
                                // UNREACHABLE
                            }
                            // 0x805c2c9
                            *v40 = v34;
                            *v39 = v136;
                            *v23 = v28;
                            *v22 = v104;
                            *v18 = (int32_t)v16 + v98;
                            int32_t chars_printed18 = snprintf((char *)2, (int32_t)&g49, (char *)&g49); // 0x805c317
                            chars_printed = chars_printed18;
                            // break -> 0x805c32e
                            break;
                        }
                    }
                    // break -> 0x805c32e
                    break;
                }
                default: {
                    // 0x805c329
                    abort();
                    // UNREACHABLE
                }
            }
            // 0x805c32e
            v101 = chars_printed;
            float80_t v137 = v35; // 0x805c32e
            if ((int16_t)(float16_t)v137 < 0) {
                // 0x805c387
                if (*v138 == 0) {
                    if ((int32_t)(float32_t)(float80_t)(int80_t)v101 >= 0) {
                        // 0x805c52d
                        v35 = (int80_t)v101;
                        v99 = (int80_t)v101;
                        goto lab_0x805c539;
                    } else {
                        // 0x805c3b5
                        *v22 = 12;
                        *v18 = v106;
                        v139 = xsum(v106, (int32_t)&g49);
                        if (v139 > v109) {
                            // break -> 0x805c407
                            break;
                        }
                        goto lab_0x805abec_2;
                    }
                } else {
                    // 0x805c397
                    *v138 = 0;
                    goto lab_0x805abec_2;
                }
            } else {
                int32_t v140 = (float16_t)v137;
                if (v104 > v140) {
                    // 0x805c346
                    if (*(char *)(v140 + v98 + (int32_t)v16) != 0) {
                        // 0x805c35f
                        abort();
                        // UNREACHABLE
                    }
                }
                // 0x805c364
                v99 = v137;
                if ((int32_t)(float32_t)(float80_t)(int80_t)v101 > v140) {
                    // 0x805c376
                    v35 = (int80_t)v101;
                    v99 = (int80_t)v101;
                }
                goto lab_0x805c539;
            }
        }
        uint32_t size6 = v109 == 0 ? 12 : v106;
        int32_t v143 = v139 > size6 ? v139 : size6;
        if (v143 == -1) {
            goto lab_0x805ca3f_12;
        }
        char * v144 = v16; // 0x805c48b
        int32_t * mem7; // 0x805969a
        if (v144 != resultbuf == (v144 != NULL)) {
            // 0x805c4b8
            *v22 = v143;
            *v18 = (int32_t)v16;
            mem7 = realloc((int32_t *)size6, (int32_t)&g49);
        } else {
            // 0x805c4a2
            *v18 = v143;
            mem7 = malloc(size6);
        }
        int32_t * v145 = mem7;
        if (v145 == NULL) {
            goto lab_0x805ca3f_12;
        }
        // 0x805c4e3
        v95 = v145;
        v96 = v143;
        if (v64 != 0 && v16 == resultbuf) {
            // 0x805c4fa
            *v23 = v98;
            *v22 = (int32_t)v16;
            *v18 = (int32_t)v145;
            memcpy(v145, &g49, (int32_t)&g49);
            v95 = v145;
            v96 = v143;
        }
        goto lab_0x805abec_3;
    }
  lab_0x805c773:
    // 0x805c773
    v73 = v109;
    v74 = v64 + (int16_t)(float16_t)v100;
    goto lab_0x805c77f;
  lab_0x805a977:
    // 0x805a977
    *(char *)v240 = 108;
    v239 = v240 + 1;
    goto lab_0x805a999;
  lab_0x805cab6:;
    int32_t v19 = v8; // 0x805cac6
    if (v3 != __readgsdword(20)) {
        // 0x805cac8
        __stack_chk_fail();
        v19 = &g49;
    }
    // 0x805cacd
    return (char *)v19;
  lab_0x8059831:;
    // 0x8059831
    int32_t v20; // 0x805969a
    if (resultbuf == NULL) {
        // 0x8059856
        v16 = NULL;
        v20 = 0;
    } else {
        // 0x805983a
        v16 = resultbuf;
        v20 = *lengthp;
    }
    // 0x805986a
    *(int32_t *)&v21 = (int32_t)format2;
    v22 = (int32_t *)(v9 + 4);
    v18 = (int32_t *)v9;
    v23 = (int32_t *)(v9 + 8);
    v24 = v1 + 4;
    v25 = v2 / 256;
    int32_t v26; // bp-732, 0x805969a
    v27 = &v26;
    v28 = (int32_t)v10;
    v29 = v28 + 1;
    int32_t v30; // bp-4, 0x805969a
    v31 = (int32_t)&v30 - 1048;
    v32 = v9 + 16;
    v33 = (int32_t *)v32;
    v34 = &v35;
    v36 = v9 + 12;
    v37 = (int32_t *)v36;
    v38 = v9 + 20;
    v39 = (int32_t *)v38;
    v40 = (int32_t *)(v9 + 24);
    v41 = (int32_t *)(v9 + 28);
    v42 = format2;
    v43 = v20;
    v44 = 0;
    v45 = 0;
    while (true) {
      lab_0x8059896:
        // 0x8059896
        v46 = v47;
        v48 = v45;
        int16_t v49 = v44;
        int32_t v50 = v43;
        int32_t v51 = *(int32_t *)v46; // 0x805989c
        int32_t v52 = (int32_t)v42; // 0x805989e
        int32_t v53 = v50; // 0x80598a4
        int16_t v54 = v49; // 0x80598a4
        if (v51 != v52) {
            int32_t v55 = v51 - v52; // 0x80598bc
            *v22 = v55;
            int32_t v56 = v49; // 0x80598d0
            *v18 = v56;
            uint32_t v57 = xsum(v46, v48); // 0x80598d9
            char * v58; // 0x805969a
            int32_t v59; // 0x805969a
            if (v57 > v50) {
                int32_t v60 = 12; // 0x80598fd
                if (v50 != 0) {
                    // 0x80598ff
                    v60 = v50 < 0 ? -1 : 2 * v50;
                }
                uint32_t size2 = v60;
                int32_t v61 = v57 > size2 ? v57 : size2;
                if (v61 == -1) {
                    goto lab_0x805ca3f_12;
                }
                char * v62 = v16; // 0x805997a
                int32_t * mem2; // 0x805969a
                if (v62 != resultbuf == (v62 != NULL)) {
                    // 0x80599a7
                    *v22 = v61;
                    *v18 = (int32_t)v16;
                    mem2 = realloc((int32_t *)size2, (int32_t)&g49);
                } else {
                    // 0x8059991
                    *v18 = v61;
                    mem2 = malloc(size2);
                }
                int32_t * v63 = mem2;
                if (v63 == NULL) {
                    goto lab_0x805ca3f_12;
                }
                // 0x80599d2
                if (v49 != 0 && v16 == resultbuf) {
                    // 0x80599e9
                    *v23 = v56;
                    *v22 = (int32_t)v16;
                    *v18 = (int32_t)v63;
                    memcpy(v63, &g49, (int32_t)&g49);
                }
                // 0x8059a0b
                v16 = (char *)v63;
                v58 = (char *)v63;
                v59 = v61;
            } else {
                // 0x80598aa
                v58 = v16;
                v59 = v50;
            }
            // 0x8059a17
            *v23 = v55;
            *v22 = (int32_t)v21;
            *v18 = (int32_t)v58 + v56;
            memcpy(&g49, &g49, (int32_t)&g49);
            v53 = v59;
            v54 = v57;
        }
        // 0x8059a4e
        v64 = v54;
        v65 = v53;
        if (v6 == v48) {
            // break -> 0x805c7a1
            break;
        }
        // 0x8059a60
        v66 = (char *)(v46 + 36);
        char v67 = *v66; // 0x8059a66
        v68 = (int32_t *)(v46 + 40);
        v69 = *v68;
        if (v67 != 37) {
            if (v69 == -1) {
                // 0x8059c04
                abort();
                // UNREACHABLE
            }
            if (v67 != 110) {
                switch (v67) {
                    case 102: {
                        goto lab_0x8059d92;
                    }
                    case 70: {
                        goto lab_0x8059d92;
                    }
                    case 101: {
                        goto lab_0x8059d92;
                    }
                    case 69: {
                        goto lab_0x8059d92;
                    }
                    case 103: {
                        goto lab_0x8059d92;
                    }
                    case 71: {
                        goto lab_0x8059d92;
                    }
                    case 97: {
                        goto lab_0x8059d92;
                    }
                    default: {
                        // 0x8059d80
                        v70 = v69;
                        if (v67 != 65) {
                            goto lab_0x805a758;
                        } else {
                            goto lab_0x8059d92;
                        }
                    }
                }
            } else {
                int32_t v71 = *(int32_t *)(16 * v69 + v1); // 0x8059c30
                g44 = v71 - 18;
                switch (v71) {
                    case 18: {
                        int32_t v72 = *(int32_t *)(16 * *v68 + v24); // 0x8059c6c
                        *(char *)v72 = (char)v64;
                        v73 = v65;
                        v74 = v64;
                        // break -> 0x805c77f
                        break;
                    }
                    case 19: {
                        // 0x8059c7c
                        *(int16_t *)*(int32_t *)(16 * *v68 + v24) = v64;
                        v73 = v65;
                        v74 = v64;
                        // break -> 0x805c77f
                        break;
                    }
                    case 20: {
                        int32_t v75 = *(int32_t *)(16 * *v68 + v24); // 0x8059cb7
                        *(int32_t *)v75 = (int32_t)v64;
                        v73 = v65;
                        v74 = v64;
                        // break -> 0x805c77f
                        break;
                    }
                    case 21: {
                        int32_t v76 = *(int32_t *)(16 * *v68 + v24); // 0x8059cdc
                        *(int32_t *)v76 = (int32_t)v64;
                        v73 = v65;
                        v74 = v64;
                        // break -> 0x805c77f
                        break;
                    }
                    case 22: {
                        int32_t v77 = *(int32_t *)(16 * *v68 + v24); // 0x8059d01
                        *(int32_t *)v77 = (int32_t)v64;
                        *(int32_t *)(v77 + 4) = 0;
                        v73 = v65;
                        v74 = v64;
                        // break -> 0x805c77f
                        break;
                    }
                    default: {
                        // 0x8059d19
                        abort();
                        // UNREACHABLE
                    }
                }
                goto lab_0x805c77f;
            }
        } else {
            if (v69 != -1) {
                // 0x8059a80
                abort();
                // UNREACHABLE
            }
            // 0x8059a85
            *v22 = 1;
            int32_t v78 = v64; // 0x8059a8d
            *v18 = v78;
            uint32_t v79 = xsum((int32_t)&g49, (int32_t)&g49); // 0x8059a96
            char * v80; // 0x805969a
            int32_t v81; // 0x805969a
            if (v79 > v65) {
                int32_t v82 = 12; // 0x8059aba
                if (v65 != 0) {
                    // 0x8059abc
                    v82 = v65 < 0 ? -1 : 2 * v65;
                }
                uint32_t size3 = v82;
                uint32_t v83 = 0x10000 * v79 / 0x10000; // 0x8059b04
                int32_t v84 = size3 < v83 ? v83 : size3;
                if (v84 == -1) {
                    goto lab_0x805ca3f_12;
                }
                char * v85 = v16; // 0x8059b37
                int32_t * mem3; // 0x805969a
                if (v85 != resultbuf == (v85 != NULL)) {
                    // 0x8059b64
                    *v22 = v84;
                    *v18 = (int32_t)v16;
                    mem3 = realloc((int32_t *)size3, (int32_t)&g49);
                } else {
                    // 0x8059b4e
                    *v18 = v84;
                    mem3 = malloc(size3);
                }
                int32_t * v86 = mem3;
                if (v86 == NULL) {
                    goto lab_0x805ca3f_12;
                }
                // 0x8059b8f
                if (v64 != 0 && v16 == resultbuf) {
                    // 0x8059ba6
                    *v23 = v78;
                    *v22 = (int32_t)v16;
                    *v18 = (int32_t)v86;
                    memcpy(v86, &g49, (int32_t)&g49);
                }
                // 0x8059bc8
                v16 = (char *)v86;
                v80 = (char *)v86;
                v81 = v84;
            } else {
                // 0x8059a85
                v80 = v16;
                v81 = v65;
            }
            // 0x8059bd4
            *(char *)((int32_t)v80 + v78) = 37;
            v73 = v81;
            v74 = v79;
            goto lab_0x805c77f;
        }
    }
    // 0x805c7a1
    *v22 = 1;
    int32_t v87 = v64; // 0x805c7a9
    *v18 = v87;
    char * v88; // 0x805969a
    int32_t v89; // 0x805969a
    if (xsum((int32_t)&g49, (int32_t)&g49) > v65) {
        int32_t v90 = 12; // 0x805c7ca
        if (v65 != 0) {
            // 0x805c7cc
            v90 = v65 < 0 ? -1 : 2 * v65;
        }
        // 0x805c808
        *v22 = 1;
        *v18 = v87;
        uint32_t v91 = xsum(v90, (int32_t)&g49); // 0x805c825
        int32_t size4 = v90; // 0x805c830
        if (v91 > v90) {
            // 0x805c832
            *v22 = 1;
            *v18 = v87;
            size4 = xsum((int32_t)&g49, (int32_t)&g49);
        }
        // 0x805c84e
        if (size4 == -1) {
            goto lab_0x805ca3f_12;
        } else {
            char * v92 = v16; // 0x805c867
            int32_t * mem4; // 0x805969a
            if (v92 != resultbuf == (v92 != NULL)) {
                // 0x805c894
                *v22 = size4;
                *v18 = (int32_t)v16;
                mem4 = realloc((int32_t *)size4, (int32_t)&g49);
            } else {
                // 0x805c87e
                *v18 = size4;
                mem4 = malloc(size4);
            }
            // 0x805c8b2
            if (mem4 == NULL) {
                goto lab_0x805ca3f_12;
            } else {
                // 0x805c8bf
                if (v64 != 0 && v16 == resultbuf) {
                    // 0x805c8d6
                    *v23 = v87;
                    *v22 = (int32_t)v16;
                    *v18 = (int32_t)mem4;
                    memcpy(mem4, &g49, (int32_t)&g49);
                }
                // 0x805c8f8
                v16 = (char *)mem4;
                v88 = (char *)mem4;
                v89 = size4;
                goto lab_0x805c904;
            }
        }
    } else {
        // 0x805c7a1
        v88 = v16;
        v89 = v65;
        goto lab_0x805c904;
    }
  lab_0x805ca7b:
    // 0x805ca7b
    free((int32_t *)v12);
    if (v1 != 0) {
        // 0x805ca93
        free(&g49);
    }
    // 0x805caa1
    *__errno_location() = 12;
    v8 = 0;
    goto lab_0x805cab6;
  lab_0x805c904:
    // 0x805c904
    *(char *)((int32_t)v88 + v87) = 0;
    if (v16 != resultbuf) {
        uint32_t v93 = v87 + 1; // 0x805c929
        if (v93 < v89) {
            // 0x805c934
            *v22 = v93;
            *v18 = (int32_t)v16;
            int32_t * mem5 = realloc(&g49, (int32_t)&g49); // 0x805c94a
            if (mem5 != NULL) {
                // 0x805c95e
                v16 = (char *)mem5;
            }
        }
    }
    if (v13 != 0) {
        // 0x805c973
        *v18 = v13;
        free(&g49);
    }
    // 0x805c981
    free(&g49);
    if (v1 != 0) {
        // 0x805c999
        free(&g49);
    }
    // 0x805c9a7
    *lengthp = v87;
    v8 = (int32_t)v16;
    goto lab_0x805cab6;
  lab_0x805c568:
    if (v13 == 0) {
        goto lab_0x805c57f;
    } else {
        // 0x805c571
        *v18 = v13;
        free(&g49);
        goto lab_0x805c57f;
    }
  lab_0x805c57f:
    // 0x805c57f
    free(&g49);
    if (v1 == 0) {
        goto lab_0x805c5a5;
    } else {
        // 0x805c597
        free(&g49);
        goto lab_0x805c5a5;
    }
  lab_0x805c5a5:
    // 0x805c5a5
    *__errno_location() = 22;
    v8 = 0;
    goto lab_0x805cab6;
  lab_0x805c9eb:
    if (v13 == 0) {
        goto lab_0x805ca02;
    } else {
        // 0x805c9f4
        *v18 = v13;
        free(&g49);
        goto lab_0x805ca02;
    }
  lab_0x805ca02:
    // 0x805ca02
    free(&g49);
    if (v1 == 0) {
        goto lab_0x805ca28;
    } else {
        // 0x805ca1a
        free(&g49);
        goto lab_0x805ca28;
    }
  lab_0x805ca28:
    // 0x805ca28
    *__errno_location() = 75;
    v8 = 0;
    goto lab_0x805cab6;
  lab_0x805c71c:;
    int32_t * v94 = mem6;
    if (v94 == NULL) {
        goto lab_0x805ca3f_12;
    } else {
        // 0x805c729
        v95 = v94;
        v96 = v97;
        if (v64 == 0 || v16 != resultbuf) {
            goto lab_0x805abec_3;
        } else {
            // 0x805c740
            *v23 = v98;
            *v22 = (int32_t)v16;
            *v18 = (int32_t)v94;
            memcpy(v94, &g49, (int32_t)&g49);
            v95 = v94;
            v96 = v97;
            goto lab_0x805abec_3;
        }
    }
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/xsize.h
// Address range: 0x805cad5 - 0x805cb11
// Line range:    80 - 82
int32_t xsum4(int32_t size1, int32_t size2, int32_t size3, int32_t size4) {
    // 0x805cad5
    return xsum(xsum(xsum(size1, size2), size3), size4);
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/xsize.h
// Address range: 0x805cb11 - 0x805cb36
// Line range:    90 - 94
int32_t xmax(uint32_t size1, uint32_t size2) {
    // 0x805cb11
    return size1 >= size2 ? size1 : size2;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/xsize.h
// Address range: 0x805cb36 - 0x805cb63
// Line range:    59 - 62
int32_t xsum(uint32_t size1, int32_t size2) {
    uint32_t v1 = size2 + size1; // 0x805cb42
    return v1 < size1 ? -1 : v1;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/isnan.c
// Address range: 0x805cb64 - 0x805cbcf
// Line range:    72 - 161
int32_t rpl_isnanl(float64_t x) {
    // 0x805cb64
    int32_t v1; // 0x805cb64
    uint32_t v2 = (uint32_t)v1 % 0x8000; // 0x805cb7f
    if (v2 == 0) {
        // 0x805cbca
        return v1 < 0;
    }
    bool result; // 0x805cb64
    if (v2 != 0x7fff) {
        // 0x805cbbe
        result = v1 > -1;
    } else {
        // 0x805cba1
        result = (v1 ^ -0x80000000 | (int32_t)(float32_t)x) != 0;
    }
    // 0x805cbca
    return result;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/printf-args.c
// Address range: 0x805cbd0 - 0x805ce89
// Line range:    39 - 189
int32_t printf_fetchargs(char * args, int32_t * a) {
    // 0x805cbd0
    if (*a == 0) {
        // 0x805ce80
        return 0;
    }
    int32_t v1 = 0; // 0x805ce63
    int32_t v2 = *(int32_t *)((int32_t)a + 4);
    int32_t v3 = *(int32_t *)v2; // 0x805cbef
    g46 = v3;
    int32_t v4; // 0x805cbd0
    int32_t v5; // 0x805ccd4
    int32_t v6; // 0x805ccf2
    int32_t v7; // 0x805cd28
    int32_t v8; // 0x805cd87
    int32_t v9; // 0x805cdb7
    switch (v3) {
        case 1: {
            // 0x805cc0a
            *(char *)(v2 + 4) = (char)*(int32_t *)args;
            v4 = (int32_t)args + 4;
            // break -> 0x805ce63
            break;
        }
        case 2: {
            // 0x805cc24
            *(char *)(v2 + 4) = (char)*(int32_t *)args;
            v4 = (int32_t)args + 4;
            // break -> 0x805ce63
            break;
        }
        case 3: {
            // 0x805cc3e
            *(int16_t *)(v2 + 4) = (int16_t)*(int32_t *)args;
            v4 = (int32_t)args + 4;
            // break -> 0x805ce63
            break;
        }
        case 4: {
            // 0x805cc59
            *(int16_t *)(v2 + 4) = (int16_t)*(int32_t *)args;
            v4 = (int32_t)args + 4;
            // break -> 0x805ce63
            break;
        }
        case 5: {
            // 0x805cc74
            *(int32_t *)(v2 + 4) = *(int32_t *)args;
            v4 = (int32_t)args + 4;
            // break -> 0x805ce63
            break;
        }
        case 6: {
            // 0x805cc8c
            *(int32_t *)(v2 + 4) = *(int32_t *)args;
            v4 = (int32_t)args + 4;
            // break -> 0x805ce63
            break;
        }
        case 7: {
            // 0x805cca4
            *(int32_t *)(v2 + 4) = *(int32_t *)args;
            v4 = (int32_t)args + 4;
            // break -> 0x805ce63
            break;
        }
        case 8: {
            // 0x805ccbc
            *(int32_t *)(v2 + 4) = *(int32_t *)args;
            v4 = (int32_t)args + 4;
            // break -> 0x805ce63
            break;
        }
        case 9: {
            // 0x805ccd4
            v5 = (int32_t)args;
            *(int32_t *)(v2 + 4) = *(int32_t *)args;
            *(int32_t *)(v2 + 8) = *(int32_t *)(v5 + 4);
            v4 = v5 + 8;
            // break -> 0x805ce63
            break;
        }
        case 10: {
            // 0x805ccf2
            v6 = (int32_t)args;
            *(int32_t *)(v2 + 4) = *(int32_t *)args;
            *(int32_t *)(v2 + 8) = *(int32_t *)(v6 + 4);
            v4 = v6 + 8;
            // break -> 0x805ce63
            break;
        }
        case 11: {
            // 0x805cd10
            *(float64_t *)(v2 + 4) = *(float64_t *)args;
            v4 = (int32_t)args + 8;
            // break -> 0x805ce63
            break;
        }
        case 12: {
            // 0x805cd28
            v7 = (int32_t)args;
            *(int32_t *)(v2 + 4) = *(int32_t *)args;
            *(int32_t *)(v2 + 8) = *(int32_t *)(v7 + 4);
            *(int32_t *)(v2 + 12) = *(int32_t *)(v7 + 8);
            v4 = v7 + 12;
            // break -> 0x805ce63
            break;
        }
        case 13: {
            // 0x805cd4c
            *(int32_t *)(v2 + 4) = *(int32_t *)args;
            v4 = (int32_t)args + 4;
            // break -> 0x805ce63
            break;
        }
        case 14: {
            // 0x805cd64
            *(int32_t *)(v2 + 4) = *(int32_t *)args;
            v4 = (int32_t)args + 4;
            // break -> 0x805ce63
            break;
        }
        case 15: {
            // 0x805cd7c
            v8 = *(int32_t *)args;
            *(int32_t *)(v2 + 4) = v8 != 0 ? v8 : (int32_t)"(NULL)";
            v4 = (int32_t)args + 4;
            // break -> 0x805ce63
            break;
        }
        case 16: {
            // 0x805cdac
            v9 = *(int32_t *)args;
            *(int32_t *)(v2 + 4) = v9 != 0 ? v9 : (int32_t)L"(NULL)";
            v4 = (int32_t)args + 4;
            // break -> 0x805ce63
            break;
        }
        case 17: {
            // 0x805cddc
            *(int32_t *)(v2 + 4) = *(int32_t *)args;
            v4 = (int32_t)args + 4;
            // break -> 0x805ce63
            break;
        }
        case 18: {
            // 0x805cdf1
            *(int32_t *)(v2 + 4) = *(int32_t *)args;
            v4 = (int32_t)args + 4;
            // break -> 0x805ce63
            break;
        }
        case 19: {
            // 0x805ce06
            *(int32_t *)(v2 + 4) = *(int32_t *)args;
            v4 = (int32_t)args + 4;
            // break -> 0x805ce63
            break;
        }
        case 20: {
            // 0x805ce1b
            *(int32_t *)(v2 + 4) = *(int32_t *)args;
            v4 = (int32_t)args + 4;
            // break -> 0x805ce63
            break;
        }
        case 21: {
            // 0x805ce30
            *(int32_t *)(v2 + 4) = *(int32_t *)args;
            v4 = (int32_t)args + 4;
            // break -> 0x805ce63
            break;
        }
        case 22: {
            // 0x805ce45
            *(int32_t *)(v2 + 4) = *(int32_t *)args;
            v4 = (int32_t)args + 4;
            // break -> 0x805ce63
            break;
        }
        default: {
            // 0x805ce80
            return -1;
        }
    }
    // 0x805ce63
    v1++;
    int32_t v10 = v2 + 16; // 0x805ce73
    while (*a > v1) {
        char * v11 = (char *)v4;
        v2 = v10;
        v3 = *(int32_t *)v2;
        g46 = v3;
        switch (v3) {
            case 1: {
                // 0x805cc0a
                *(char *)(v2 + 4) = (char)*(int32_t *)v11;
                v4 = (int32_t)v11 + 4;
                // break -> 0x805ce63
                break;
            }
            case 2: {
                // 0x805cc24
                *(char *)(v2 + 4) = (char)*(int32_t *)v11;
                v4 = (int32_t)v11 + 4;
                // break -> 0x805ce63
                break;
            }
            case 3: {
                // 0x805cc3e
                *(int16_t *)(v2 + 4) = (int16_t)*(int32_t *)v11;
                v4 = (int32_t)v11 + 4;
                // break -> 0x805ce63
                break;
            }
            case 4: {
                // 0x805cc59
                *(int16_t *)(v2 + 4) = (int16_t)*(int32_t *)v11;
                v4 = (int32_t)v11 + 4;
                // break -> 0x805ce63
                break;
            }
            case 5: {
                // 0x805cc74
                *(int32_t *)(v2 + 4) = *(int32_t *)v11;
                v4 = (int32_t)v11 + 4;
                // break -> 0x805ce63
                break;
            }
            case 6: {
                // 0x805cc8c
                *(int32_t *)(v2 + 4) = *(int32_t *)v11;
                v4 = (int32_t)v11 + 4;
                // break -> 0x805ce63
                break;
            }
            case 7: {
                // 0x805cca4
                *(int32_t *)(v2 + 4) = *(int32_t *)v11;
                v4 = (int32_t)v11 + 4;
                // break -> 0x805ce63
                break;
            }
            case 8: {
                // 0x805ccbc
                *(int32_t *)(v2 + 4) = *(int32_t *)v11;
                v4 = (int32_t)v11 + 4;
                // break -> 0x805ce63
                break;
            }
            case 9: {
                // 0x805ccd4
                v5 = (int32_t)v11;
                *(int32_t *)(v2 + 4) = *(int32_t *)v11;
                *(int32_t *)(v2 + 8) = *(int32_t *)(v5 + 4);
                v4 = v5 + 8;
                // break -> 0x805ce63
                break;
            }
            case 10: {
                // 0x805ccf2
                v6 = (int32_t)v11;
                *(int32_t *)(v2 + 4) = *(int32_t *)v11;
                *(int32_t *)(v2 + 8) = *(int32_t *)(v6 + 4);
                v4 = v6 + 8;
                // break -> 0x805ce63
                break;
            }
            case 11: {
                // 0x805cd10
                *(float64_t *)(v2 + 4) = *(float64_t *)v11;
                v4 = (int32_t)v11 + 8;
                // break -> 0x805ce63
                break;
            }
            case 12: {
                // 0x805cd28
                v7 = (int32_t)v11;
                *(int32_t *)(v2 + 4) = *(int32_t *)v11;
                *(int32_t *)(v2 + 8) = *(int32_t *)(v7 + 4);
                *(int32_t *)(v2 + 12) = *(int32_t *)(v7 + 8);
                v4 = v7 + 12;
                // break -> 0x805ce63
                break;
            }
            case 13: {
                // 0x805cd4c
                *(int32_t *)(v2 + 4) = *(int32_t *)v11;
                v4 = (int32_t)v11 + 4;
                // break -> 0x805ce63
                break;
            }
            case 14: {
                // 0x805cd64
                *(int32_t *)(v2 + 4) = *(int32_t *)v11;
                v4 = (int32_t)v11 + 4;
                // break -> 0x805ce63
                break;
            }
            case 15: {
                // 0x805cd7c
                v8 = *(int32_t *)v11;
                *(int32_t *)(v2 + 4) = v8 != 0 ? v8 : (int32_t)"(NULL)";
                v4 = (int32_t)v11 + 4;
                // break -> 0x805ce63
                break;
            }
            case 16: {
                // 0x805cdac
                v9 = *(int32_t *)v11;
                *(int32_t *)(v2 + 4) = v9 != 0 ? v9 : (int32_t)L"(NULL)";
                v4 = (int32_t)v11 + 4;
                // break -> 0x805ce63
                break;
            }
            case 17: {
                // 0x805cddc
                *(int32_t *)(v2 + 4) = *(int32_t *)v11;
                v4 = (int32_t)v11 + 4;
                // break -> 0x805ce63
                break;
            }
            case 18: {
                // 0x805cdf1
                *(int32_t *)(v2 + 4) = *(int32_t *)v11;
                v4 = (int32_t)v11 + 4;
                // break -> 0x805ce63
                break;
            }
            case 19: {
                // 0x805ce06
                *(int32_t *)(v2 + 4) = *(int32_t *)v11;
                v4 = (int32_t)v11 + 4;
                // break -> 0x805ce63
                break;
            }
            case 20: {
                // 0x805ce1b
                *(int32_t *)(v2 + 4) = *(int32_t *)v11;
                v4 = (int32_t)v11 + 4;
                // break -> 0x805ce63
                break;
            }
            case 21: {
                // 0x805ce30
                *(int32_t *)(v2 + 4) = *(int32_t *)v11;
                v4 = (int32_t)v11 + 4;
                // break -> 0x805ce63
                break;
            }
            case 22: {
                // 0x805ce45
                *(int32_t *)(v2 + 4) = *(int32_t *)v11;
                v4 = (int32_t)v11 + 4;
                // break -> 0x805ce63
                break;
            }
            default: {
                // 0x805ce80
                return -1;
            }
        }
        // 0x805ce63
        v1++;
        v10 = v2 + 16;
    }
    // 0x805ce80
    return 0;
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/printf-parse.c
// Address range: 0x805ce8c - 0x805dced
// Line range:    84 - 623
int32_t printf_parse(char * format2, int32_t * d, int32_t * a) {
    int32_t v1 = (int32_t)d;
    *d = 0;
    int32_t * mem = malloc(44); // 0x805cec9
    int32_t * v2 = (int32_t *)(v1 + 4); // 0x805ced3
    *v2 = (int32_t)mem;
    if (mem == NULL) {
      lab_0x805dcd0:
        // 0x805dcd0
        *__errno_location() = 12;
        // 0x805dce5
        return -1;
    }
    // 0x805cee4
    *a = 0;
    int32_t * v3 = (int32_t *)((int32_t)a + 4); // 0x805cef7
    *v3 = 0;
    char * v4 = format2; // 0x805cefe
    int32_t v5 = 0; // 0x805cefe
    int32_t v6 = 0; // 0x805cefe
    char * v7 = (char *)1; // 0x805cefe
    char * v8 = NULL; // 0x805cefe
    int32_t v9 = 0; // 0x805cefe
    char * v10; // 0x805ce8c
    char * v11; // 0x805ce8c
    char v12; // 0x805ce8c
    char * v13; // 0x805dc15
    uint32_t v14; // 0x805ce8c
    int32_t v15; // 0x805ce8c
    char * v16; // 0x805ce8c
    int32_t v17; // 0x805ce8c
    int32_t v18; // 0x805ce8c
    int32_t v19; // 0x805ce8c
    int32_t v20; // 0x805ce8c
    int32_t v21; // 0x805ce8c
    int32_t v22; // 0x805ce8c
    char v23; // 0x805ce8c
    char v24; // 0x805ce8c
    int32_t v25; // 0x805cf2f
    int32_t * v26; // 0x805cf89
    uint32_t v27; // 0x805ce8c
    int32_t v28; // 0x805ce8c
    while (true) {
        // 0x805dc15
        v27 = (int32_t)v7;
        while (true) {
          lab_0x805dc15:;
            int32_t v29 = v9;
            char * v30 = v8;
            v17 = v6;
            v14 = v5;
            v13 = v4;
            char v31 = *v13; // 0x805dc18
            if (v31 == 0) {
                // break (via goto) -> 0x805dc23
                goto lab_0x805dc23;
            }
            int32_t v32 = (int32_t)v13;
            char * v33 = (char *)(v32 + 1);
            while (v31 != 37) {
                // 0x805dc15
                v13 = v33;
                v31 = *v13;
                if (v31 == 0) {
                    // break (via goto) -> 0x805dc23
                    goto lab_0x805dc23;
                }
                // 0x805cf03
                v32 = (int32_t)v13;
                v33 = (char *)(v32 + 1);
            }
            // 0x805cf1a
            v25 = 44 * *d + *v2;
            *(int32_t *)v25 = v32;
            int32_t * v34 = (int32_t *)(v25 + 8); // 0x805cf43
            *v34 = 0;
            int32_t * v35 = (int32_t *)(v25 + 12); // 0x805cf4d
            *v35 = 0;
            int32_t * v36 = (int32_t *)(v25 + 16); // 0x805cf57
            *v36 = 0;
            int32_t * v37 = (int32_t *)(v25 + 20); // 0x805cf61
            *v37 = -1;
            int32_t * v38 = (int32_t *)(v25 + 24); // 0x805cf6b
            *v38 = 0;
            int32_t * v39 = (int32_t *)(v25 + 28); // 0x805cf75
            *v39 = 0;
            int32_t * v40 = (int32_t *)(v25 + 32); // 0x805cf7f
            *v40 = -1;
            v26 = (int32_t *)(v25 + 40);
            *v26 = -1;
            char v41 = *v33; // 0x805cf93
            char * v42 = v33; // 0x805cf98
            char * v43 = v33; // 0x805cf98
            int32_t v44 = -1; // 0x805cf98
            if (v41 <= 57) {
                char * v45 = (char *)((int32_t)v42 + 1); // 0x805cfb4
                char v46 = *v45; // 0x805cfbb
                v42 = v45;
                while (v46 < 58) {
                    // 0x805cfb4
                    v45 = (char *)((int32_t)v42 + 1);
                    v46 = *v45;
                    v42 = v45;
                }
                char * v47 = v33; // 0x805cfd4
                char v48 = v41; // 0x805cfd4
                v43 = v33;
                v44 = -1;
                if (v46 == 36) {
                    uint32_t v49 = 0;
                    int32_t v50 = v49 < 0x1999999a ? 10 * v49 : -1;
                    int32_t v51 = xsum2(v50, (int32_t)v48 - 48); // 0x805d036
                    int32_t v52 = (int32_t)v47;
                    char * v53 = (char *)(v52 + 1); // 0x805d03e
                    char v54 = *v53; // 0x805d045
                    v47 = v53;
                    v48 = v54;
                    while (v54 < 58) {
                        // 0x805cfe9
                        v49 = v51;
                        v50 = v49 < 0x1999999a ? 10 * v49 : -1;
                        v51 = xsum2(v50, (int32_t)v48 - 48);
                        v52 = (int32_t)v47;
                        v53 = (char *)(v52 + 1);
                        v54 = *v53;
                        v47 = v53;
                        v48 = v54;
                    }
                    if (v51 < 1) {
                        goto lab_0x805dc59_9;
                    }
                    // 0x805d06a
                    v43 = (char *)(v52 + 2);
                    v44 = v51 - 1;
                }
            }
            // 0x805d07c
            v18 = v44;
            char * v55 = v43; // 0x805ce8c
            char * v56; // 0x805ce8c
            char v57; // 0x805d07f
            while (true) {
                // 0x805d07c
                v56 = v55;
                v57 = *v56;
                if (v57 != 39) {
                    if (v57 != 45) {
                        if (v57 != 43) {
                            if (v57 != 32) {
                                if (v57 != 35) {
                                    if (v57 != 48) {
                                        // break -> 0x805d14b
                                        break;
                                    }
                                    // 0x805d131
                                    *v34 = *v34 | 32;
                                } else {
                                    // 0x805d10d
                                    *v34 = *v34 | 16;
                                }
                            } else {
                                // 0x805d0e9
                                *v34 = *v34 | 8;
                            }
                        } else {
                            // 0x805d0c8
                            *v34 = *v34 | 4;
                        }
                    } else {
                        // 0x805d0a7
                        *v34 = *v34 | 2;
                    }
                } else {
                    // 0x805d086
                    *v34 = *v34 | 1;
                }
                // 0x805d07c
                v55 = (char *)((int32_t)v56 + 1);
            }
            int32_t v58; // 0x805ce8c
            char * v59; // 0x805ce8c
            char * v60; // 0x805ce8c
            if (v57 != 42) {
                // 0x805d3ee
                v60 = v56;
                v6 = v17;
                v59 = v30;
                v58 = v29;
                if (v57 <= 57) {
                    int32_t v61 = (int32_t)v56; // 0x805d405
                    *v35 = v61;
                    int32_t v62 = v61; // 0x805d419
                    char * v63 = v56; // 0x805d419
                    int32_t v64 = v61; // 0x805d419
                    if (*v56 < 58) {
                        int32_t v65 = v62 + 1; // 0x805d40d
                        char * v66 = (char *)v65;
                        v62 = v65;
                        v63 = v66;
                        v64 = v65;
                        while (*v66 < 58) {
                            // 0x805d40d
                            v65 = v62 + 1;
                            v66 = (char *)v65;
                            v62 = v65;
                            v63 = v66;
                            v64 = v65;
                        }
                    }
                    // 0x805d425
                    *v36 = v64;
                    uint32_t v67 = v64 - *v35; // 0x805d43e
                    v60 = v63;
                    v6 = v17 >= v67 ? v17 : v67;
                    v59 = v30;
                    v58 = v29;
                }
            } else {
                int32_t v68 = (int32_t)v56; // 0x805d15c
                *v35 = v68;
                int32_t v69 = v68 + 1; // 0x805d162
                char * v70 = (char *)v69; // 0x805d162
                *v36 = v69;
                char v71 = *v70; // 0x805d17f
                char * v72 = v70; // 0x805d184
                if (v71 <= 57) {
                    // 0x805d1a0
                    char * v73; // bp-52, 0x805ce8c
                    *(int32_t *)&v73 = v69;
                    char * v74 = (char *)((int32_t)v70 + 1);
                    char v75 = *v74; // 0x805d1a7
                    char * v76 = v74; // 0x805d1ac
                    while (v75 < 58) {
                        // 0x805d1a0
                        v74 = (char *)((int32_t)v76 + 1);
                        v75 = *v74;
                        v76 = v74;
                    }
                    // 0x805d1b8
                    v73 = v74;
                    v72 = v70;
                    if (v75 == 36) {
                        // 0x805d1d5
                        *(int32_t *)&v73 = v69;
                        uint32_t v77 = 0;
                        int32_t v78 = v77 < 0x1999999a ? 10 * v77 : -1;
                        int32_t v79 = xsum2(v78, (int32_t)v71 - 48); // 0x805d222
                        char * v80 = (char *)((int32_t)v70 + 1);
                        char v81 = *v80; // 0x805d231
                        char * v82 = v80; // 0x805d236
                        while (v81 < 58) {
                            // 0x805d1d5
                            v77 = v79;
                            v78 = v77 < 0x1999999a ? 10 * v77 : -1;
                            v79 = xsum2(v78, (int32_t)v81 - 48);
                            v80 = (char *)((int32_t)v82 + 1);
                            v81 = *v80;
                            v82 = v80;
                        }
                        // 0x805d242
                        v73 = v80;
                        if (v79 < 1) {
                            goto lab_0x805dc59_9;
                        }
                        // 0x805d256
                        *v37 = v79 - 1;
                        v72 = (char *)((int32_t)v73 + 1);
                    }
                }
                char * v83 = v72;
                int32_t v84 = *v37; // 0x805d26e
                int32_t v85 = v84; // 0x805d274
                char * v86 = v30; // 0x805d274
                if (v84 == -1) {
                    // 0x805d276
                    v85 = (int32_t)v30;
                    *v37 = v85;
                    v86 = (char *)(v85 + 1);
                    if (v30 == (char *)-1) {
                        goto lab_0x805dc59_9;
                    }
                }
                char * v87 = v86;
                uint32_t v88 = v85; // 0x805d295
                int32_t v89; // 0x805ce8c
                int32_t v90; // 0x805ce8c
                if (v88 < v29) {
                    // 0x805d292
                    v89 = *v3;
                    v90 = v29;
                } else {
                    int32_t v91 = v29 < 0 ? -1 : 2 * v29;
                    int32_t v92 = v91; // 0x805d2d4
                    if (v91 <= v88) {
                        // 0x805d2d6
                        v92 = xsum2(v88, 1);
                    }
                    // 0x805d2ec
                    if (v92 > 0xfffffff) {
                        goto lab_0x805dca0_8;
                    }
                    int32_t size = 16 * v92;
                    int32_t v93 = *v3; // 0x805d325
                    int32_t * mem2; // 0x805ce8c
                    if (v93 == 0) {
                        // 0x805d349
                        mem2 = malloc(size);
                    } else {
                        // 0x805d32c
                        mem2 = realloc((int32_t *)v93, size);
                    }
                    // 0x805d35a
                    if (mem2 == NULL) {
                        goto lab_0x805dca0_8;
                    }
                    int32_t v94 = (int32_t)mem2;
                    *v3 = v94;
                    v89 = v94;
                    v90 = v92;
                }
                int32_t v95 = v90;
                uint32_t v96 = *a; // 0x805d39c
                int32_t v97 = v89; // 0x805d3a1
                int32_t v98 = v96; // 0x805d3a1
                int32_t v99 = v89; // 0x805d3a1
                if (v96 <= v88) {
                    *(int32_t *)(16 * v98 + v97) = 0;
                    int32_t v100 = v98 + 1; // 0x805d391
                    *a = v100;
                    int32_t v101 = *v3;
                    v98 = v100;
                    v99 = v101;
                    while (v100 <= v88) {
                        // 0x805d378
                        *(int32_t *)(16 * v98 + v101) = 0;
                        v100 = v98 + 1;
                        *a = v100;
                        v101 = *v3;
                        v98 = v100;
                        v99 = v101;
                    }
                }
                int32_t v102 = v17 != 0 ? v17 : 1;
                int32_t * v103 = (int32_t *)(v99 + 16 * v88); // 0x805d3b2
                int32_t v104 = *v103; // 0x805d3b2
                if (v104 != 0) {
                    // 0x805d3d2
                    v60 = v83;
                    v6 = v102;
                    v59 = v87;
                    v58 = v95;
                    if (v104 != 5) {
                        goto lab_0x805dc59_9;
                    }
                } else {
                    // 0x805d3b8
                    *v103 = 5;
                    v60 = v83;
                    v6 = v102;
                    v59 = v87;
                    v58 = v95;
                }
            }
            int32_t v105 = v58;
            char * v106 = v59;
            char * v107 = v60;
            char * v108 = v107; // 0x805d45b
            v5 = v14;
            char * v109 = v106; // 0x805d45b
            int32_t v110 = v105; // 0x805d45b
            if (*v107 == 46) {
                int32_t v111 = (int32_t)v107; // 0x805d461
                int32_t v112 = v111 + 1; // 0x805d461
                char * v113 = (char *)v112; // 0x805d461
                *v38 = v111;
                if (*v113 != 42) {
                    int32_t v114 = v112; // 0x805d722
                    char * v115 = v113; // 0x805d722
                    int32_t v116 = v112; // 0x805d722
                    if (*v113 < 58) {
                        int32_t v117 = v114 + 1; // 0x805d716
                        char * v118 = (char *)v117;
                        v114 = v117;
                        v115 = v118;
                        v116 = v117;
                        while (*v118 < 58) {
                            // 0x805d716
                            v117 = v114 + 1;
                            v118 = (char *)v117;
                            v114 = v117;
                            v115 = v118;
                            v116 = v117;
                        }
                    }
                    // 0x805d72e
                    *v39 = v116;
                    uint32_t v119 = v116 - *v38; // 0x805d747
                    v108 = v115;
                    v5 = v14 >= v119 ? v14 : v119;
                    v109 = v106;
                    v110 = v105;
                } else {
                    int32_t v120 = v111 + 2; // 0x805d47f
                    char * v121 = (char *)v120; // 0x805d47f
                    *v39 = v120;
                    char v122 = *v121; // 0x805d49c
                    char * v123 = v121; // 0x805d4a1
                    if (v122 <= 57) {
                        // 0x805d4bd
                        char * v124; // bp-76, 0x805ce8c
                        *(int32_t *)&v124 = v120;
                        char * v125 = (char *)((int32_t)v121 + 1);
                        char v126 = *v125; // 0x805d4c4
                        char * v127 = v125; // 0x805d4c9
                        while (v126 < 58) {
                            // 0x805d4bd
                            v125 = (char *)((int32_t)v127 + 1);
                            v126 = *v125;
                            v127 = v125;
                        }
                        // 0x805d4d5
                        v124 = v125;
                        v123 = v121;
                        if (v126 == 36) {
                            // 0x805d4f2
                            *(int32_t *)&v124 = v120;
                            uint32_t v128 = 0;
                            int32_t v129 = v128 < 0x1999999a ? 10 * v128 : -1;
                            int32_t v130 = xsum2(v129, (int32_t)v122 - 48); // 0x805d53f
                            char * v131 = (char *)((int32_t)v121 + 1);
                            char v132 = *v131; // 0x805d54e
                            char * v133 = v131; // 0x805d553
                            while (v132 < 58) {
                                // 0x805d4f2
                                v128 = v130;
                                v129 = v128 < 0x1999999a ? 10 * v128 : -1;
                                v130 = xsum2(v129, (int32_t)v132 - 48);
                                v131 = (char *)((int32_t)v133 + 1);
                                v132 = *v131;
                                v133 = v131;
                            }
                            // 0x805d55f
                            v124 = v131;
                            if (v130 < 1) {
                                goto lab_0x805dc59_9;
                            }
                            // 0x805d573
                            *v40 = v130 - 1;
                            v123 = (char *)((int32_t)v124 + 1);
                        }
                    }
                    char * v134 = v123;
                    int32_t v135 = *v40; // 0x805d58b
                    int32_t v136 = v135; // 0x805d591
                    char * v137 = v106; // 0x805d591
                    if (v135 == -1) {
                        // 0x805d593
                        v136 = (int32_t)v106;
                        *v40 = v136;
                        v137 = (char *)(v136 + 1);
                        if (v106 == (char *)-1) {
                            goto lab_0x805dc59_9;
                        }
                    }
                    char * v138 = v137;
                    uint32_t v139 = v136; // 0x805d5b2
                    int32_t v140; // 0x805ce8c
                    int32_t v141; // 0x805ce8c
                    if (v139 < v105) {
                        // 0x805d5af
                        v140 = *v3;
                        v141 = v105;
                    } else {
                        int32_t v142 = v105 < 0 ? -1 : 2 * v105;
                        int32_t v143 = v142; // 0x805d5f1
                        if (v142 <= v139) {
                            // 0x805d5f3
                            v143 = xsum2(v139, 1);
                        }
                        // 0x805d609
                        if (v143 > 0xfffffff) {
                            goto lab_0x805dca0_8;
                        }
                        int32_t size2 = 16 * v143;
                        int32_t v144 = *v3; // 0x805d642
                        int32_t * mem3; // 0x805ce8c
                        if (v144 == 0) {
                            // 0x805d666
                            mem3 = malloc(size2);
                        } else {
                            // 0x805d649
                            mem3 = realloc((int32_t *)v144, size2);
                        }
                        // 0x805d677
                        if (mem3 == NULL) {
                            goto lab_0x805dca0_8;
                        }
                        int32_t v145 = (int32_t)mem3;
                        *v3 = v145;
                        v140 = v145;
                        v141 = v143;
                    }
                    int32_t v146 = v141;
                    uint32_t v147 = *a; // 0x805d6b9
                    int32_t v148 = v140; // 0x805d6be
                    int32_t v149 = v147; // 0x805d6be
                    int32_t v150 = v140; // 0x805d6be
                    if (v147 <= v139) {
                        *(int32_t *)(16 * v149 + v148) = 0;
                        int32_t v151 = v149 + 1; // 0x805d6ae
                        *a = v151;
                        int32_t v152 = *v3;
                        v149 = v151;
                        v150 = v152;
                        while (v151 <= v139) {
                            // 0x805d695
                            *(int32_t *)(16 * v149 + v152) = 0;
                            v151 = v149 + 1;
                            *a = v151;
                            v152 = *v3;
                            v149 = v151;
                            v150 = v152;
                        }
                    }
                    int32_t v153 = v14 > 2 ? v14 : 2;
                    int32_t * v154 = (int32_t *)(v150 + 16 * v139); // 0x805d6cf
                    int32_t v155 = *v154; // 0x805d6cf
                    if (v155 != 0) {
                        // 0x805d6ec
                        v108 = v134;
                        v5 = v153;
                        v109 = v138;
                        v110 = v146;
                        if (v155 != 5) {
                            goto lab_0x805dc59_9;
                        }
                    } else {
                        // 0x805d6d5
                        *v154 = 5;
                        v108 = v134;
                        v5 = v153;
                        v109 = v138;
                        v110 = v146;
                    }
                }
            }
            // 0x805d75c
            v15 = v110;
            v16 = v109;
            v11 = v108;
            v21 = 0;
            while (true) {
              lab_0x805d763_2:
                // 0x805d763
                v22 = v21;
                char v156 = *v11; // 0x805d766
                char * v157 = v11; // 0x805d76b
                char v158 = v156; // 0x805d76b
                char * v159 = v11; // 0x805d76b
                if (v156 != 104) {
                    char * v160 = v159;
                    v12 = v158;
                    while (v12 != 76) {
                        if (v12 == 108) {
                            // 0x805d7a3
                            v10 = v160;
                            v20 = v22 + 8;
                            goto lab_0x805d763;
                        }
                        if (v12 == 106) {
                            // 0x805d7b7
                            v10 = v160;
                            v20 = v22 + 16;
                            goto lab_0x805d763;
                        }
                        int32_t v161; // 0x805ce8c
                        if (v12 != 122 == (v12 != 90)) {
                            // 0x805d7db
                            v28 = (int32_t)v160 + 1;
                            v161 = v28;
                            if (v12 != 116) {
                                // break (via goto) -> 0x805d7ee
                                goto lab_0x805d7ee;
                            }
                        } else {
                            // 0x805d7d5
                            v161 = (int32_t)v160 + 1;
                        }
                        char * v162 = (char *)v161; // 0x805d763
                        char v163 = *v162; // 0x805d766
                        v157 = v162;
                        v158 = v163;
                        v159 = v162;
                        if (v163 == 104) {
                            goto lab_0x805d76d;
                        }
                        v160 = v159;
                        v12 = v158;
                    }
                    // 0x805d78f
                    v10 = v160;
                    v20 = v22 | 4;
                } else {
                  lab_0x805d76d:
                    // 0x805d76d
                    v10 = v157;
                    v20 = 1 << v22 % 2 | v22;
                }
                goto lab_0x805d763;
            }
          lab_0x805d7ee:;
            int32_t v164 = v12; // 0x805d7fb
            g47 = v164 - 37;
            v24 = 99;
            v19 = 14;
            v23 = v12;
            v8 = v16;
            v9 = v15;
            switch (v164) {
                case 37: {
                    goto lab_0x805db61;
                }
                case 65: {
                    goto lab_0x805d8f0;
                }
                case 67: {
                    goto lab_0x805d9dc;
                }
                case 69: {
                    goto lab_0x805d8f0;
                }
                case 70: {
                    goto lab_0x805d8f0;
                }
                case 71: {
                    goto lab_0x805d8f0;
                }
                case 83: {
                    // 0x805d95e
                    v24 = 115;
                    v19 = 16;
                    goto lab_0x805d9dc;
                }
                case 88: {
                    goto lab_0x805d88a;
                }
                case 97: {
                    goto lab_0x805d8f0;
                }
                case 99: {
                    // 0x805d918
                    v24 = v12;
                    v19 = v22 < 8 ? 13 : 14;
                    goto lab_0x805d9dc;
                }
                case 100: {
                    goto lab_0x805d824;
                }
                case 101: {
                    goto lab_0x805d8f0;
                }
                case 102: {
                    goto lab_0x805d8f0;
                }
                case 103: {
                    goto lab_0x805d8f0;
                }
                case 105: {
                    goto lab_0x805d824;
                }
                case 110: {
                    // 0x805d974
                    v24 = v12;
                    v19 = 22;
                    if (v22 < 16 == (v22 & 4) == 0) {
                        // 0x805d98d
                        v24 = v12;
                        v19 = 21;
                        if (v22 < 8) {
                            // 0x805d99c
                            v24 = v12;
                            v19 = 18;
                            if ((v22 & 2) == 0) {
                                // 0x805d9af
                                v24 = v12;
                                v19 = v22 % 2 == 0 ? 20 : 19;
                            }
                        }
                    }
                    goto lab_0x805d9dc;
                }
                case 111: {
                    goto lab_0x805d88a;
                }
                case 112: {
                    // 0x805d96b
                    v24 = v12;
                    v19 = 17;
                    goto lab_0x805d9dc;
                }
                case 115: {
                    // 0x805d946
                    v24 = v12;
                    v19 = v22 < 8 ? 15 : 16;
                    goto lab_0x805d9dc;
                }
                case 117: {
                    goto lab_0x805d88a;
                }
                case 120: {
                    goto lab_0x805d88a;
                }
                default: {
                    goto lab_0x805dc59_9;
                }
            }
        }
      lab_0x805db8f:
        // 0x805db8f
        v7 = v7 < NULL ? (char *)-1 : (char *)(2 * v27);
        if (v7 > (char *)0x5d1745d) {
            goto lab_0x805dca0_8;
        }
        int32_t * mem4 = realloc((int32_t *)*v2, 44 * (int32_t)v7); // 0x805dbfa
        if (mem4 == NULL) {
            goto lab_0x805dca0_8;
        }
        // 0x805dc0c
        *v2 = (int32_t)mem4;
    }
  lab_0x805dc23:
    // 0x805dc23
    *(int32_t *)(44 * *d + *v2) = (int32_t)v13;
    *(int32_t *)(v1 + 8) = v17;
    *(int32_t *)(v1 + 12) = v14;
    // 0x805dce5
    return 0;
  lab_0x805dc59_9:;
    int32_t v165 = *v3; // 0x805dc5c
    if (v165 != 0) {
        // 0x805dc63
        free((int32_t *)v165);
    }
    int32_t v166 = *v2; // 0x805dc74
    if (v166 != 0) {
        // 0x805dc7b
        free((int32_t *)v166);
    }
    // 0x805dc89
    *__errno_location() = 22;
    // 0x805dce5
    return -1;
  lab_0x805dca0_8:;
    int32_t v167 = *v3; // 0x805dca3
    if (v167 == 0) {
        goto lab_0x805dcb8;
    } else {
        // 0x805dcaa
        free((int32_t *)v167);
        goto lab_0x805dcb8;
    }
  lab_0x805d763:
    // 0x805d763
    v11 = (char *)((int32_t)v10 + 1);
    v21 = v20;
    goto lab_0x805d763_2;
  lab_0x805db61:
    // 0x805db61
    v4 = (char *)v28;
    *(char *)(v25 + 36) = v23;
    *(int32_t *)(v25 + 4) = v28;
    uint32_t v168 = *d + 1; // 0x805db79
    *d = v168;
    if (v168 >= v27) {
        // break -> 0x805db8f
        goto lab_0x805db8f;
    }
    goto lab_0x805dc15;
  lab_0x805d8f0:;
    int32_t v169 = v22 < 16 == (v22 & 4) == 0 ? 11 : 12;
    v24 = v12;
    v19 = v169;
    goto lab_0x805d9dc;
  lab_0x805d9dc:;
    int32_t v170 = v19;
    char v171 = v24;
    *v26 = v18;
    int32_t v172 = v18; // 0x805d9ee
    char * v173 = v16; // 0x805d9ee
    if (v18 == -1) {
        int32_t v174 = (int32_t)v16; // 0x805d9f3
        *v26 = v174;
        v172 = v174;
        v173 = (char *)(v174 + 1);
        if (v16 == (char *)-1) {
            goto lab_0x805dc59_9;
        }
    }
    char * v175 = v173;
    uint32_t v176 = v172; // 0x805da0f
    int32_t v177; // 0x805ce8c
    int32_t v178; // 0x805ce8c
    if (v176 < v15) {
        // 0x805da0c
        v177 = *v3;
        v178 = v15;
    } else {
        int32_t v179 = v15 < 0 ? -1 : 2 * v15;
        int32_t v180 = v179; // 0x805da4e
        if (v179 <= v176) {
            // 0x805da50
            v180 = xsum2(v176, 1);
        }
        // 0x805da66
        if (v180 > 0xfffffff) {
            goto lab_0x805dca0_8;
        }
        int32_t size3 = 16 * v180;
        int32_t v181 = *v3; // 0x805da9f
        int32_t * mem5; // 0x805ce8c
        if (v181 == 0) {
            // 0x805dac3
            mem5 = malloc(size3);
        } else {
            // 0x805daa6
            mem5 = realloc((int32_t *)v181, size3);
        }
        // 0x805dad4
        if (mem5 == NULL) {
            goto lab_0x805dca0_8;
        }
        int32_t v182 = (int32_t)mem5;
        *v3 = v182;
        v177 = v182;
        v178 = v180;
    }
    int32_t v183 = v178;
    uint32_t v184 = *a; // 0x805db16
    int32_t v185 = v177; // 0x805db1b
    int32_t v186 = v184; // 0x805db1b
    int32_t v187 = v177; // 0x805db1b
    if (v184 <= v176) {
        *(int32_t *)(16 * v186 + v185) = 0;
        int32_t v188 = v186 + 1; // 0x805db0b
        *a = v188;
        int32_t v189 = *v3;
        v186 = v188;
        v187 = v189;
        while (v188 <= v176) {
            // 0x805daf2
            *(int32_t *)(16 * v186 + v189) = 0;
            v188 = v186 + 1;
            *a = v188;
            v189 = *v3;
            v186 = v188;
            v187 = v189;
        }
    }
    int32_t * v190 = (int32_t *)(v187 + 16 * v176); // 0x805db2c
    int32_t v191 = *v190; // 0x805db2c
    if (v191 != 0) {
        // 0x805db47
        v23 = v171;
        v8 = v175;
        v9 = v183;
        if (v191 != v170) {
            goto lab_0x805dc59_9;
        }
    } else {
        // 0x805db32
        *v190 = v170;
        v23 = v171;
        v8 = v175;
        v9 = v183;
    }
    goto lab_0x805db61;
  lab_0x805d88a:
    // 0x805d88a
    v24 = v12;
    v19 = 10;
    if (v22 < 16 == (v22 & 4) == 0) {
        // 0x805d8a6
        v24 = v12;
        v19 = 8;
        if (v22 < 8) {
            // 0x805d8b8
            v24 = v12;
            v19 = 2;
            if ((v22 & 2) == 0) {
                // 0x805d8ce
                v24 = v12;
                v19 = v22 % 2 == 0 ? 6 : 4;
            }
        }
    }
    goto lab_0x805d9dc;
  lab_0x805d824:
    // 0x805d824
    v24 = v12;
    v19 = 9;
    if (v22 < 16 == (v22 & 4) == 0) {
        // 0x805d840
        v24 = v12;
        v19 = 7;
        if (v22 < 8) {
            // 0x805d852
            v24 = v12;
            v19 = 1;
            if ((v22 & 2) == 0) {
                // 0x805d868
                v24 = v12;
                v19 = v22 % 2 == 0 ? 5 : 3;
            }
        }
    }
    goto lab_0x805d9dc;
  lab_0x805dcb8:;
    int32_t v192 = *v2; // 0x805dcbb
    if (v192 == 0) {
        goto lab_0x805dcd0;
    } else {
        // 0x805dcc2
        free((int32_t *)v192);
        goto lab_0x805dcd0;
    }
}

// From module:   /home/naftali/source/coreutils-6.10/coreutils-6.10/lib/xsize.h
// Address range: 0x805dced - 0x805dd1a
// Line range:    59 - 62
int32_t xsum2(uint32_t size1, int32_t size2) {
    uint32_t v1 = size2 + size1; // 0x805dcf9
    return v1 < size1 ? -1 : v1;
}

// Address range: 0x805dd20 - 0x805dead
int32_t __divdi3(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1; // 0x805dd20
    int32_t v2; // 0x805dd20
    int32_t v3; // 0x805dd20
    int32_t v4; // 0x805dd20
    int32_t v5; // 0x805dd20
    int32_t v6; // 0x805dd20
    int32_t v7; // 0x805dd20
    int32_t v8; // 0x805dd20
    if (a2 < 0) {
        int32_t v9 = -a1; // 0x805ddd3
        int32_t v10 = -(((int32_t)(a1 != 0) + a2)); // 0x805ddd8
        v7 = -1;
        v1 = a3;
        v4 = a4;
        v5 = v9;
        v2 = v10;
        v8 = 0;
        v6 = v9;
        v3 = v10;
        if (a4 >= 0) {
            goto lab_0x805dd54;
        } else {
            goto lab_0x805dde9;
        }
    } else {
        // 0x805dd49
        v7 = 0;
        v1 = a3;
        v4 = a4;
        v5 = a1;
        v2 = a2;
        v8 = -1;
        v6 = a1;
        v3 = a2;
        if (a4 < 0) {
            goto lab_0x805dde9;
        } else {
            goto lab_0x805dd54;
        }
    }
  lab_0x805dd54:;
    uint32_t v11 = v2;
    uint32_t v12 = v1;
    int32_t v13; // 0x805dd20
    if (v4 == 0) {
        int32_t v14; // 0x805dd20
        if (v12 > v11) {
            // 0x805dd6a
            v14 = (0x100000000 * (int64_t)v11 | (int64_t)v5) / (int64_t)v12;
        } else {
            uint32_t v15 = v12 != 0 ? v12 : (int32_t)(v12 == 1);
            v14 = (0x100000000 * (int64_t)(v11 % v15) | (int64_t)v5) / (int64_t)v15;
        }
        // 0x805dd85
        v13 = v14;
        return v7 == 0 ? v13 : -v13;
    }
    // 0x805dd78
    if (v4 > v11) {
        // 0x805dd85
        v13 = 0;
        return v7 == 0 ? v13 : -v13;
    }
    uint32_t v16 = llvm_ctlz_i32(v4, true); // 0x805de00
    if (v16 == 0) {
        // 0x805dd85
        v13 = v12 <= v5 | v4 < v11;
        return v7 == 0 ? v13 : -v13;
    }
    uint32_t v17 = -v16 % 32; // 0x805de3f
    uint64_t v18 = 0x100000000 * (int64_t)(v11 >> v17) | (int64_t)(v5 >> v17 | v11 << v16); // 0x805de6b
    uint64_t v19 = (int64_t)(v12 >> v17 | v4 << v16); // 0x805de6b
    uint64_t v20 = v18 / v19; // 0x805de6b
    int32_t v21 = v20; // 0x805de6b
    uint32_t v22 = (int32_t)(v18 % v19); // 0x805de6b
    uint64_t v23 = (v20 & 0xffffffff) * (int64_t)(v12 << v16); // 0x805de75
    uint32_t v24 = (int32_t)(v23 / 0x100000000); // 0x805de75
    if (v22 < v24) {
        // 0x805dd85
        v13 = v21 - 1;
        return v7 == 0 ? v13 : -v13;
    }
    // 0x805de7e
    if (v22 != v24 || v5 << v16 >= (int32_t)v23) {
        // 0x805dd85
        v13 = v21;
        return v7 == 0 ? v13 : -v13;
    }
    // 0x805dd85
    v13 = v21 - 1;
    return v7 == 0 ? v13 : -v13;
  lab_0x805dde9:
    // 0x805dde9
    v7 = v8;
    v1 = -a3;
    v4 = -(((int32_t)(a3 != 0) + a4));
    v5 = v6;
    v2 = v3;
    goto lab_0x805dd54;
}

// Address range: 0x805deb0 - 0x805e082
int32_t __moddi3(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1; // 0x805deb0
    int32_t v2; // 0x805deb0
    int32_t v3; // 0x805deb0
    int32_t v4; // 0x805deb0
    int32_t v5; // 0x805deb0
    int32_t v6; // 0x805deb0
    int32_t v7; // 0x805deb0
    int32_t v8; // 0x805deb0
    if (a2 < 0) {
        int32_t v9 = -a1; // 0x805df73
        int32_t v10 = -(((int32_t)(a1 != 0) + a2)); // 0x805df78
        v5 = -1;
        v7 = a4;
        v8 = a3;
        v1 = v9;
        v3 = v10;
        v6 = -1;
        v2 = v9;
        v4 = v10;
        if (a4 >= 0) {
            goto lab_0x805def0;
        } else {
            goto lab_0x805df89;
        }
    } else {
        // 0x805dee5
        v5 = 0;
        v7 = a4;
        v8 = a3;
        v1 = a1;
        v3 = a2;
        v6 = 0;
        v2 = a1;
        v4 = a2;
        if (a4 < 0) {
            goto lab_0x805df89;
        } else {
            goto lab_0x805def0;
        }
    }
  lab_0x805def0:;
    uint32_t v11 = v3;
    uint32_t v12 = v8;
    int32_t v13; // bp-20, 0x805deb0
    int32_t v14 = &v13; // 0x805def8
    int32_t v15; // 0x805deb0
    int32_t v16; // 0x805deb0
    uint32_t v17; // 0x805e02f
    uint32_t v18; // 0x805deb0
    uint32_t v19; // 0x805dfa8
    uint32_t v20; // 0x805dffa
    if (v7 != 0) {
        if (v11 < v7) {
            // 0x805df29
            v13 = v1;
            *(int32_t *)(v14 + 4) = v11;
            goto lab_0x805df31;
        } else {
            // 0x805dfa8
            v19 = llvm_ctlz_i32(v7, true);
            if (v19 != 0) {
                // 0x805dfe0
                v20 = -v19 % 32;
                uint32_t v21 = v12 >> v20 | v7 << v19; // 0x805e000
                uint64_t v22 = (int64_t)v21;
                uint32_t v23 = v12 << v19;
                uint64_t v24 = 0x100000000 * (int64_t)(v11 >> v20) | (int64_t)(v11 << v19 | v1 >> v20); // 0x805e02f
                v17 = (int32_t)(v24 % v22);
                v18 = v1 << v19;
                uint64_t v25 = (v24 / v22 & 0xffffffff) * (int64_t)v23; // 0x805e037
                uint32_t v26 = (int32_t)v25; // 0x805e037
                int32_t v27 = v25 / 0x100000000; // 0x805e037
                if (v17 >= v27) {
                    // 0x805e078
                    v15 = v26;
                    v16 = v27;
                    if (v18 < v26 == v17 == v27) {
                        // 0x805e03e
                        v15 = v26 - v23;
                        v16 = v27 - v21 + (int32_t)(v23 > v26);
                        goto lab_0x805e043;
                    } else {
                        goto lab_0x805e043;
                    }
                } else {
                    // 0x805e03e
                    v15 = v26 - v23;
                    v16 = v27 - v21 + (int32_t)(v23 > v26);
                    goto lab_0x805e043;
                }
            } else {
                int32_t v28 = v1; // 0x805dfb7
                int32_t v29 = v11; // 0x805dfb7
                if (v1 < v12 != v11 <= v7) {
                    // 0x805dfbe
                    v28 = v1 - v12;
                    v29 = v11 - v7 + (int32_t)(v1 < v12);
                }
                // 0x805dfc9
                *(int32_t *)(v14 + 4) = v29;
                v13 = v28;
                goto lab_0x805df31;
            }
        }
    } else {
        int32_t v30; // 0x805deb0
        if (v12 > v11) {
            // 0x805df0f
            v30 = (0x100000000 * (int64_t)v11 | (int64_t)v1) % (int64_t)v12;
        } else {
            uint32_t v31 = v12 != 0 ? v12 : (int32_t)(v12 == 1);
            v30 = (0x100000000 * (int64_t)(v11 % v31) | (int64_t)v1) % (int64_t)v31;
        }
        // 0x805df11
        v13 = v30;
        *(int32_t *)(v14 + 4) = 0;
        goto lab_0x805df31;
    }
  lab_0x805df89:
    // 0x805df89
    v5 = v6;
    v7 = -(((int32_t)(a3 != 0) + a4));
    v8 = -a3;
    v1 = v2;
    v3 = v4;
    goto lab_0x805def0;
  lab_0x805df31:;
    int32_t result = v13; // 0x805df36
    if (v5 != 0) {
        int32_t v32 = -v13; // 0x805df38
        v13 = v32;
        result = v32;
    }
    // 0x805df42
    return result;
  lab_0x805e043:;
    uint32_t v33 = v17 - v16 + (int32_t)(v18 < v15); // 0x805e048
    v13 = v33 << v20 | v18 - v15 >> v19;
    *(int32_t *)(v14 + 4) = v33 >> v19;
    goto lab_0x805df31;
}

// Address range: 0x805e090 - 0x805e1bd
int32_t __udivdi3(uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4) {
    if (a4 == 0) {
        if (a3 > a2) {
            // 0x805e100
            return (uint64_t)(0x100000000 * (int64_t)a2 | (int64_t)a1) / (uint64_t)(int64_t)a3;
        }
        uint32_t v1 = a3 != 0 ? a3 : (int32_t)(bool)(a3 == 1);
        return (0x100000000 * (int64_t)(a2 % v1) | (int64_t)a1) / (int64_t)v1;
    }
    // 0x805e0e8
    if (a4 > a2) {
        // 0x805e0f1
        return 0;
    }
    uint32_t v2 = llvm_ctlz_i32(a4, true); // 0x805e118
    if (v2 == 0) {
        // 0x805e120
        return a3 <= a1 | a4 < a2;
    }
    uint32_t v3 = -v2 % 32; // 0x805e150
    uint64_t v4 = (int64_t)(a3 >> v3 | a4 << v2);
    uint64_t v5 = 0x100000000 * (int64_t)(a2 >> v3) | (int64_t)(a1 >> v3 | a2 << v2); // 0x805e17b
    uint64_t v6 = v5 / v4; // 0x805e17b
    int32_t result = v6; // 0x805e17b
    uint32_t v7 = (int32_t)(v5 % v4); // 0x805e17b
    uint64_t v8 = (v6 & 0xffffffff) * (int64_t)(a3 << v2); // 0x805e186
    uint32_t v9 = (int32_t)(v8 / 0x100000000); // 0x805e186
    if (v7 < v9) {
        // 0x805e0f1
        return result - 1;
    }
    // 0x805e190
    if (v7 != v9 || a1 << v2 >= (int32_t)v8) {
        // 0x805e0f1
        return result;
    }
    // 0x805e0f1
    return result - 1;
}

// Address range: 0x805e1c0 - 0x805e305
int32_t __umoddi3(uint32_t result2, uint32_t a2, uint32_t a3, uint32_t a4) {
    if (a4 == 0) {
        int32_t result; // 0x805e1c0
        if (a3 > a2) {
            // 0x805e1e4
            result = (uint64_t)(0x100000000 * (int64_t)a2 | (int64_t)result2) % (uint64_t)(int64_t)a3;
        } else {
            uint32_t v1 = a3 != 0 ? a3 : (int32_t)(bool)(a3 == 1);
            result = (0x100000000 * (int64_t)(a2 % v1) | (int64_t)result2) % (int64_t)v1;
        }
        // 0x805e1ea
        return result;
    }
    // 0x805e1f8
    if (a4 > a2) {
        // 0x805e1ea
        return result2;
    }
    uint32_t v2 = llvm_ctlz_i32(a4, true); // 0x805e228
    if (v2 == 0) {
        // 0x805e233
        return result2 - (result2 < a3 == a4 >= a2 ? 0 : a3);
    }
    uint32_t v3 = -v2 % 32; // 0x805e269
    uint32_t v4 = a3 >> v3 | a4 << v2; // 0x805e26f
    uint64_t v5 = (int64_t)v4;
    uint32_t v6 = a3 << v2;
    uint64_t v7 = 0x100000000 * (int64_t)(a2 >> v3) | (int64_t)(result2 >> v3 | a2 << v2); // 0x805e2a3
    uint32_t v8 = (int32_t)(v7 % v5); // 0x805e2a3
    uint32_t v9 = result2 << v2;
    uint64_t v10 = (v7 / v5 & 0xffffffff) * (int64_t)v6; // 0x805e2aa
    uint32_t v11 = (int32_t)v10; // 0x805e2aa
    int32_t v12 = v10 / 0x100000000; // 0x805e2aa
    uint32_t v13; // 0x805e1c0
    if (v8 >= v12) {
        // 0x805e2e0
        if (v9 < v11 != (v8 == v12)) {
            // 0x805e2b7
            v13 = v11;
            // 0x805e1ea
            return v8 - v12 + (int32_t)(v9 < v13) << v3 | v9 - v13 >> v2;
        }
    }
    int32_t v14 = v12 - v4 + (int32_t)(v6 > v11);
    v13 = v11 - v6;
    // 0x805e1ea
    return v8 - v14 + (int32_t)(v9 < v13) << v3 | v9 - v13 >> v2;
}

// Address range: 0x805e37a - 0x805e37e
int32_t __i686_get_pc_thunk_bx(int32_t a1) {
    // 0x805e37a
    int32_t result; // 0x805e37a
    return result;
}

// Address range: 0x805e3c0 - 0x805e3f2
int32_t stat64(int32_t a1, int32_t * a2) {
    // 0x805e3c0
    int32_t v1; // 0x805e3c0
    return __xstat64(3, (char *)a1, (struct stat64 *)__i686_get_pc_thunk_bx(v1));
}

// Address range: 0x805e400 - 0x805e432
int32_t fstat64(int32_t a1, int32_t * a2) {
    // 0x805e400
    int32_t v1; // 0x805e400
    return __fxstat64(3, a1, (struct stat64 *)__i686_get_pc_thunk_bx(v1));
}

// Address range: 0x805e440 - 0x805e472
int32_t lstat64(int32_t a1, int32_t a2) {
    // 0x805e440
    int32_t v1; // 0x805e440
    return __lxstat64(3, (char *)a1, (struct stat64 *)__i686_get_pc_thunk_bx(v1));
}

// --------------- Statically Linked Functions ----------------

// int32_t atexit(int32_t a1);

// --------------- Dynamically Linked Functions ---------------

// void __assert_fail(const char * assertion, const char * file, unsigned int line, const char * function);
// const unsigned short int ** __ctype_b_loc(void);
// size_t __ctype_get_mb_cur_max(void);
// int __cxa_atexit(void(* func)(void *), void * arg, void * dso_handle);
// int * __errno_location(void);
// int __fxstat64(int ver, int fildes, struct stat64 * stat_buf);
// int __lxstat64(int ver, const char * filename, struct stat64 * stat_buf);
// int __signbitl(long double);
// void __stack_chk_fail(void);
// int __xstat64(int ver, const char * filename, struct stat64 * stat_buf);
// int _obstack_begin(struct obstack *, int, int, void *(*)(long), void(*)(void *));
// void _obstack_newchunk(struct obstack *, int);
// int _setjmp(struct __jmp_buf_tag env[1]);
// void abort(void);
// char * bindtextdomain(const char * domainname, const char * dirname);
// int clock_gettime(clockid_t clock_id, struct timespec * tp);
// int closedir(DIR * dirp);
// char * dcgettext(const char * domainname, const char * msgid, int category);
// int dirfd(DIR * dirp);
// void error(int status, int errnum, const char * format, ...);
// void exit(int status);
// int fflush_unlocked(FILE * stream);
// int fnmatch(const char * pattern, const char * name, int flags);
// int fprintf(FILE * restrict stream, const char * restrict format, ...);
// int fputs_unlocked(const char * restrict s, FILE * restrict stream);
// void free(void * ptr);
// size_t fwrite(const void * restrict ptr, size_t size, size_t n, FILE * restrict s);
// size_t fwrite_unlocked(const void * restrict ptr, size_t size, size_t n, FILE * restrict stream);
// char * getenv(const char * name);
// struct group * getgrgid(__gid_t gid);
// int getopt_long(int argc, char * const * argv, const char * shortopts, const struct option * longopts, int * longind);
// struct passwd * getpwuid(__uid_t uid);
// char * gettext(const char * msgid);
// int gettimeofday(struct timeval * restrict tv, __timezone_ptr_t tz);
// unsigned int gnu_dev_major(unsigned long long maj);
// unsigned int gnu_dev_minor(unsigned long long min);
// int ioctl(int fd, unsigned long int request, ...);
// int isatty(int fd);
// int iswcntrl(wint_t wc);
// int iswprint(wint_t wc);
// struct lconv * localeconv(void);
// struct tm * localtime(const time_t * timer);
// void * malloc(size_t size);
// size_t mbrlen(const char * restrict s, size_t n, mbstate_t * restrict ps);
// size_t mbrtowc(wchar_t * restrict pwc, const char * restrict s, size_t n, mbstate_t * restrict p);
// int mbsinit(const mbstate_t * ps);
// int memcmp(const void * s1, const void * s2, size_t n);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// void * memmove(void * dest, const void * src, size_t n);
// void * mempcpy(void * restrict dest, const void * restrict src, size_t n);
// void * memset(void * s, int c, size_t n);
// time_t mktime(struct tm * tp);
// DIR * opendir(const char * name);
// int printf(const char * restrict format, ...);
// int putc_unlocked(int c, FILE * stream);
// int putchar_unlocked(int c);
// int raise(int sig);
// struct dirent64 * readdir64(DIR * dirp);
// ssize_t readlink(const char * restrict path, char * restrict buf, size_t len);
// void * realloc(void * ptr, size_t size);
// char * setlocale(int category, const char * locale);
// int sigaction(int sig, const struct sigaction * restrict act, struct sigaction * restrict oact);
// int sigaddset(sigset_t * set, int signo);
// int sigemptyset(sigset_t * set);
// int sigismember(const sigset_t * set, int signo);
// __sighandler_t signal(int sig, __sighandler_t handler);
// int sigprocmask(int how, const sigset_t * restrict set, sigset_t * restrict oset);
// int snprintf(char * restrict s, size_t maxlen, const char * restrict format, ...);
// int sprintf(char * restrict s, const char * restrict format, ...);
// char * strchr(char * s, int c);
// int strcmp(const char * s1, const char * s2);
// char * strcpy(char * restrict dest, const char * restrict src);
// size_t strftime(char * restrict s, size_t maxsize, const char * restrict format, const struct tm * restrict tp);
// size_t strlen(const char * s);
// int strncmp(const char * s1, const char * s2, size_t n);
// char * strncpy(char * restrict dest, const char * restrict src, size_t n);
// char * strrchr(char * s, int c);
// unsigned long int strtoul(const char * restrict nptr, char ** restrict endptr, int base);
// uintmax_t strtoumax(const char * restrict nptr, char ** restrict endptr, int base);
// __pid_t tcgetpgrp(int fd);
// char * textdomain(const char * domainname);
// int tolower(int c);
// int toupper(int c);
// int wcwidth(wchar_t c);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (4.6.3)
// Detected functions: 166

