/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

int init_proc();
int sub_80494AC();
// void abort(void);
// int *__errno_location(void);
// int putc_unlocked(int c, FILE *stream);
// int sigemptyset(sigset_t *set);
// int sprintf(char *s, const char *format, ...);
// struct lconv *localeconv(void);
// int dirfd(DIR *dirp);
// int __cdecl __cxa_atexit(void (__cdecl *lpfunc)(void *), void *obj, void *lpdso_handle);
// int strcoll(const char *s1, const char *s2);
// int memcmp(const void *s1, const void *s2, size_t n);
// int __cdecl fputs_unlocked(_DWORD, _DWORD); weak
// size_t __ctype_get_mb_cur_max(void);
// __sighandler_t signal(int sig, __sighandler_t handler);
// int sigismember(const sigset_t *set, int signo);
// int __gmon_start__(void); weak
// void *realloc(void *ptr, size_t size);
// int __cdecl __xstat64(_DWORD, _DWORD, _DWORD); weak
// struct tm *localtime(const time_t *timer);
// struct group *getgrnam(const char *name);
// char *strchr(const char *s, int c);
// char *getenv(const char *name);
// void *calloc(size_t nmemb, size_t size);
// char *strncpy(char *dest, const char *src, size_t n);
// unsigned int gnu_dev_minor(unsigned __int64 dev);
// int toupper(int c);
// void *memset(void *s, int c, size_t n);
// int __cdecl __libc_start_main(int (__cdecl *main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end);
// int __cdecl mempcpy(_DWORD, _DWORD, _DWORD); weak
// int _obstack_begin(struct obstack *, int, int, void *(*)(int), void (*)(void *));
// int ferror_unlocked(FILE *stream);
// void _exit(int status);
// char *strrchr(const char *s, int c);
// void __assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// char *bindtextdomain(const char *domainname, const char *dirname);
// size_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *p);
// char *gettext(const char *msgid);
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// void free(void *ptr);
// int __cdecl __lxstat64(_DWORD, _DWORD, _DWORD); weak
// uintmax_t strtoumax(const char *nptr, char **endptr, int base);
// void _obstack_newchunk(struct obstack *, int);
// char *dcgettext(const char *domainname, const char *msgid, int category);
// int sigaction(int sig, const struct sigaction *act, struct sigaction *oact);
// int __cdecl strverscmp(_DWORD, _DWORD); weak
// DIR *opendir(const char *name);
// int getopt_long(int argc, char *const *argv, const char *shortopts, const struct option *longopts, int *longind);
// int ioctl(int fd, unsigned int request, ...);
// const unsigned __int16 **__ctype_b_loc(void);
// int iswcntrl(wint_t wc);
// int isatty(int fd);
// int fclose(FILE *stream);
// int mbsinit(const mbstate_t *ps);
// int _setjmp(struct __jmp_buf_tag env[1]);
// __pid_t tcgetpgrp(int fd);
// time_t mktime(struct tm *tp);
// int __cdecl readdir64(_DWORD); weak
// void *memcpy(void *dest, const void *src, size_t n);
// unsigned int strtoul(const char *nptr, char **endptr, int base);
// size_t strlen(const char *s);
// struct passwd *getpwuid(__uid_t uid);
// char *setlocale(int category, const char *locale);
// char *strcpy(char *dest, const char *src);
// void longjmp(struct __jmp_buf_tag env[1], int val);
// int printf(const char *format, ...);
// int raise(int sig);
// size_t mbrlen(const char *s, size_t n, mbstate_t *ps);
// size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream);
// int __cdecl __signbitl(_DWORD, _DWORD, _DWORD); weak
// int clock_gettime(clockid_t clock_id, struct timespec *tp);
// int closedir(DIR *dirp);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// int fprintf(FILE *stream, const char *format, ...);
// void *malloc(size_t size);
// int sigprocmask(int how, const sigset_t *set, sigset_t *oset);
// size_t __fpending(FILE *fp);
// void error(int status, int errnum, const char *format, ...);
// struct group *getgrgid(__gid_t gid);
// int sigaddset(sigset_t *set, int signo);
// ssize_t readlink(const char *path, char *buf, size_t len);
// void *memmove(void *dest, const void *src, size_t n);
// int __cdecl strndup(_DWORD, _DWORD); weak
// char *textdomain(const char *domainname);
// int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD); weak
// unsigned int gnu_dev_major(unsigned __int64 dev);
// int fnmatch(const char *pattern, const char *name, int flags);
// int strncmp(const char *s1, const char *s2, size_t n);
// int fflush_unlocked(FILE *stream);
// size_t strftime(char *s, size_t maxsize, const char *format, const struct tm *tp);
// int snprintf(char *s, size_t maxlen, const char *format, ...);
// int __cdecl wcwidth(_DWORD); weak
// int iswprint(wint_t wc);
// struct passwd *getpwnam(const char *name);
// int tolower(int c);
// int strcmp(const char *s1, const char *s2);
// void exit(int status);
// int putchar_unlocked(int c);
// void __usercall __noreturn start(int a1@<eax>, void (*a2)(void)@<edx>);
void _do_global_dtors_aux();
int frame_dummy();
dev_ino *__stdcall dev_ino_pop(dev_ino *retstr);
void __cdecl dired_dump_obstack(const char *prefix, obstack *os);
size_t __cdecl dev_ino_hash(const void *x, size_t table_size);
bool __cdecl dev_ino_compare(const void *x, const void *y);
void __cdecl dev_ino_free(void *x);
bool __cdecl visit_dir(dev_t dev, ino_t ino);
void __cdecl free_pending_ent(pending *p);
bool __cdecl is_colored(indicator_no type);
void restore_default_color(); // idb
void __cdecl sighandler(int sig);
void __cdecl stophandler(int sig);
void process_signals(); // idb
int __cdecl main(int argc, const char **argv, const char **envp);
void __cdecl initialize_exit_failure(int status);
int __cdecl decode_switches(int argc, char **argv);
bool __cdecl get_funky_string(char **dest, const char **src, bool equals_end, size_t *output_count);
void parse_ls_color(); // idb
void __cdecl set_exit_status(bool serious);
void __cdecl file_failure(bool serious, const char *message, const char *file);
void __cdecl queue_directory(const char *name, const char *realname, bool command_line_arg);
void __cdecl print_dir(const char *name, const char *realname, bool command_line_arg);
void __cdecl add_ignore_pattern(const char *pattern);
bool __cdecl patterns_match(const ignore_pattern *patterns, const char *file);
bool __cdecl file_ignored(const char *name);
uintmax_t __cdecl unsigned_file_size(off_t size);
void clear_files(); // idb
void __cdecl freecon(char *con);
uintmax_t __cdecl gobble_file(const char *name, filetype type, ino_t inode, bool command_line_arg, const char *dirname);
int __cdecl getfilecon(const char *s, char **con);
int __cdecl lgetfilecon(const char *s, char **con);
bool __cdecl is_directory(const fileinfo *f);
void __cdecl get_link_name(const char *filename, fileinfo *f, bool command_line_arg);
char *__cdecl make_link_name(const char *name, const char *linkname);
bool __cdecl basename_is_dot_or_dotdot(const char *name);
bool __cdecl dot_or_dotdot(const char *file_name);
void __cdecl extract_dirs_from_files(const char *dirname, bool command_line_arg);
int __cdecl xstrcoll(const char *a, const char *b);
int __cdecl xstrcoll_ctime(V a, V b);
int __cdecl cmp_ctime(const fileinfo *a, const fileinfo *b, int (*cmp)(const char *, const char *));
timespec *get_stat_ctime(timespec *__return_ptr __struct_ptr retstr, const stat *st);
int __cdecl timespec_cmp(timespec a, timespec b);
int __cdecl strcmp_ctime(V a, V b);
int __cdecl rev_xstrcoll_ctime(V a, V b);
int __cdecl rev_strcmp_ctime(V a, V b);
int __cdecl xstrcoll_df_ctime(V a, V b);
int __cdecl strcmp_df_ctime(V a, V b);
int __cdecl rev_xstrcoll_df_ctime(V a, V b);
int __cdecl rev_strcmp_df_ctime(V a, V b);
int __cdecl xstrcoll_mtime(V a, V b);
int __cdecl cmp_mtime(const fileinfo *a, const fileinfo *b, int (*cmp)(const char *, const char *));
timespec *get_stat_mtime(timespec *__return_ptr __struct_ptr retstr, const stat *st);
int __cdecl strcmp_mtime(V a, V b);
int __cdecl rev_xstrcoll_mtime(V a, V b);
int __cdecl rev_strcmp_mtime(V a, V b);
int __cdecl xstrcoll_df_mtime(V a, V b);
int __cdecl strcmp_df_mtime(V a, V b);
int __cdecl rev_xstrcoll_df_mtime(V a, V b);
int __cdecl rev_strcmp_df_mtime(V a, V b);
int __cdecl xstrcoll_atime(V a, V b);
int __cdecl cmp_atime(const fileinfo *a, const fileinfo *b, int (*cmp)(const char *, const char *));
timespec *get_stat_atime(timespec *__return_ptr __struct_ptr retstr, const stat *st);
int __cdecl strcmp_atime(V a, V b);
int __cdecl rev_xstrcoll_atime(V a, V b);
int __cdecl rev_strcmp_atime(V a, V b);
int __cdecl xstrcoll_df_atime(V a, V b);
int __cdecl strcmp_df_atime(V a, V b);
int __cdecl rev_xstrcoll_df_atime(V a, V b);
int __cdecl rev_strcmp_df_atime(V a, V b);
int __cdecl xstrcoll_size(V a, V b);
int __cdecl cmp_size(const fileinfo *a, const fileinfo *b, int (*cmp)(const char *, const char *));
int __cdecl strcmp_size(V a, V b);
int __cdecl rev_xstrcoll_size(V a, V b);
int __cdecl rev_strcmp_size(V a, V b);
int __cdecl xstrcoll_df_size(V a, V b);
int __cdecl strcmp_df_size(V a, V b);
int __cdecl rev_xstrcoll_df_size(V a, V b);
int __cdecl rev_strcmp_df_size(V a, V b);
int __cdecl xstrcoll_name(V a, V b);
int __cdecl cmp_name(const fileinfo *a, const fileinfo *b, int (*cmp)(const char *, const char *));
int __cdecl strcmp_name(V a, V b);
int __cdecl rev_xstrcoll_name(V a, V b);
int __cdecl rev_strcmp_name(V a, V b);
int __cdecl xstrcoll_df_name(V a, V b);
int __cdecl strcmp_df_name(V a, V b);
int __cdecl rev_xstrcoll_df_name(V a, V b);
int __cdecl rev_strcmp_df_name(V a, V b);
int __cdecl xstrcoll_extension(V a, V b);
int __cdecl cmp_extension(const fileinfo *a, const fileinfo *b, int (*cmp)(const char *, const char *));
int __cdecl strcmp_extension(V a, V b);
int __cdecl rev_xstrcoll_extension(V a, V b);
int __cdecl rev_strcmp_extension(V a, V b);
int __cdecl xstrcoll_df_extension(V a, V b);
int __cdecl strcmp_df_extension(V a, V b);
int __cdecl rev_xstrcoll_df_extension(V a, V b);
int __cdecl rev_strcmp_df_extension(V a, V b);
int __cdecl xstrcoll_version(V a, V b);
int __cdecl cmp_version(const fileinfo *a, const fileinfo *b);
int __cdecl rev_xstrcoll_version(V a, V b);
int __cdecl xstrcoll_df_version(V a, V b);
int __cdecl rev_xstrcoll_df_version(V a, V b);
void initialize_ordering_vector(); // idb
void sort_files(); // idb
void print_current_files(); // idb
int long_time_expected_width(); // idb
void get_current_time(); // idb
void __cdecl format_user_or_group(const char *name, unsigned int id, int width);
void __cdecl format_user(uid_t u, int width, bool stat_ok);
void __cdecl format_group(gid_t g, int width, bool stat_ok);
int __cdecl format_user_or_group_width(const char *name, unsigned int id);
int __cdecl format_user_width(uid_t u);
int __cdecl format_group_width(gid_t g);
void __cdecl print_long_format(const fileinfo *f);
size_t __cdecl quote_name(FILE *out, const char *name, const quoting_options *options, size_t *width);
unsigned __int8 __cdecl to_uchar(char ch_0);
void __cdecl print_name_with_quoting(const char *p, mode_t mode, int linkok, bool stat_ok, filetype type, obstack *stack);
void prep_non_filename_text(); // idb
void __cdecl print_file_name_and_frills(const fileinfo *f);
char __cdecl get_type_indicator(bool stat_ok, mode_t mode, filetype type);
void __cdecl print_type_indicator(bool stat_ok, mode_t mode, filetype type);
void __cdecl print_color_indicator(const char *name, mode_t mode, int linkok, bool stat_ok, filetype filetype);
void __cdecl put_indicator(const bin_str *ind);
size_t __cdecl length_of_file_name_and_frills(const fileinfo *f);
void print_many_per_line(); // idb
void print_horizontal(); // idb
void print_with_commas(); // idb
void __cdecl indent(size_t from, size_t to);
void __cdecl attach(char *dest, const char *dirname, const char *name);
void init_column_info(); // idb
size_t __cdecl calculate_columns(bool by_columns);
void __cdecl usage(int status);
void emit_bug_reporting_address(); // idb
char *__cdecl areadlink_with_size(const char *file, size_t size);
int __cdecl gnu_mbswidth(const char *string, int flags);
int __cdecl mbsnwidth(const char *string, size_t nbytes, int flags);
void __cdecl version_etc_va(FILE *stream, const char *command_name, const char *package, const char *version, va_list authors);
void version_etc(FILE *stream, const char *command_name, const char *package, const char *version, ...);
void __noreturn xalloc_die();
void __noreturn _argmatch_die();
ptrdiff_t __cdecl argmatch(const char *arg, const char *const *arglist, const char *vallist, size_t valsize);
void __cdecl argmatch_invalid(const char *context, const char *value, ptrdiff_t problem);
void __cdecl argmatch_valid(const char *const *arglist, const char *vallist, size_t valsize);
ptrdiff_t __cdecl _xargmatch_internal(const char *context, const char *arg, const char *const *arglist, const char *vallist, size_t valsize, argmatch_exit_fn exit_fn);
const char *__cdecl argmatch_to_argument(const char *value, const char *const *arglist, const char *vallist, size_t valsize);
char *__cdecl last_component(const char *name);
char *__cdecl base_name(const char *name);
size_t __cdecl base_len(const char *name);
void __cdecl close_stdout_set_file_name(const char *file);
void close_stdout(); // idb
int __cdecl file_has_acl(const char *name, const stat *sb);
char __cdecl ftypelet(mode_t bits);
void __cdecl strmode(mode_t mode, char *str);
void __cdecl filemodestring(const stat *statp, char *str);
const char *__cdecl longest_relative_suffix(const char *f);
char *__cdecl mfile_name_concat(const char *dir, const char *abase, char **base_in_result);
char *__cdecl file_name_concat(const char *dir, const char *abase, char **base_in_result);
bool __cdecl hard_locale(int category);
size_t __cdecl hash_get_n_buckets(const Hash_table *table);
size_t __cdecl hash_get_n_buckets_used(const Hash_table *table);
size_t __cdecl hash_get_n_entries(const Hash_table *table);
size_t __cdecl hash_get_max_bucket_length(const Hash_table *table);
bool __cdecl hash_table_ok(const Hash_table *table);
void __cdecl hash_print_statistics(const Hash_table *table, FILE *stream);
void *__cdecl hash_lookup(const Hash_table *table, const void *entry);
void *__cdecl hash_get_first(const Hash_table *table);
void *__cdecl hash_get_next(const Hash_table *table, const void *entry);
size_t __cdecl hash_get_entries(const Hash_table *table, void **buffer, size_t buffer_size);
size_t __cdecl hash_do_for_each(const Hash_table *table, Hash_processor processor, void *processor_data);
size_t __cdecl hash_string(const char *string, size_t n_buckets);
bool __cdecl is_prime(size_t candidate);
size_t __cdecl next_prime(size_t candidate);
void __cdecl hash_reset_tuning(Hash_tuning *tuning);
bool __cdecl check_tuning(Hash_table *table);
Hash_table *__cdecl hash_initialize(size_t candidate, const Hash_tuning *tuning, Hash_hasher hasher, Hash_comparator comparator, Hash_data_freer data_freer);
void __cdecl hash_clear(Hash_table *table);
void __cdecl hash_free(Hash_table *table);
hash_entry *__cdecl allocate_entry(Hash_table *table);
void __cdecl free_entry(Hash_table *table, hash_entry *entry);
void *__cdecl hash_find_entry(Hash_table *table, const void *entry, hash_entry **bucket_head, bool delete);
bool __cdecl hash_rehash(Hash_table *table, size_t candidate);
void *__cdecl hash_insert(Hash_table *table, const void *entry);
void *__cdecl hash_delete(Hash_table *table, const void *entry);
long double __cdecl adjust_value(int inexact_style, long double value);
char *__cdecl group_number(char *number, size_t numberlen, const char *grouping, const char *thousands_sep);
char *__cdecl human_readable(uintmax_t n, char *buf, int opts, uintmax_t from_block_size, uintmax_t to_block_size);
uintmax_t default_block_size(); // idb
strtol_error_0 __cdecl humblock(const char *spec, uintmax_t *block_size, int *options);
strtol_error __cdecl human_options(const char *spec, int *opts, uintmax_t *block_size);
char *__cdecl getuser(uid_t uid);
uid_t *__cdecl getuidbyname(const char *user);
char *__cdecl getgroup(gid_t gid);
gid_t *__cdecl getgidbyname(const char *group);
char *__cdecl imaxtostr(intmax_t i, char *buf);
void __cdecl mpsort_into_tmp(const void **base, size_t n, const void **tmp, comparison_function cmp);
void __cdecl mpsort_with_tmp(const void **base, size_t n, const void **tmp, comparison_function cmp);
void __cdecl mpsort(const void **base, size_t n, comparison_function cmp);
const char *__cdecl _ZNK6idVec58ToStringEi(int n, const char *name);
const char *__cdecl quote(const char *name);
quoting_options *__cdecl clone_quoting_options(quoting_options *o);
quoting_style __cdecl get_quoting_style(quoting_options *o);
void __cdecl set_quoting_style(quoting_options *o, quoting_style s);
int __cdecl set_char_quoting(quoting_options *o, char c, int i);
const char *__cdecl gettext_quote(const char *msgid, quoting_style s);
size_t __cdecl quotearg_buffer_restyled(char *buffer, size_t buffersize, const char *arg, size_t argsize, quoting_style quoting_style, const quoting_options *o);
size_t __cdecl quotearg_buffer(char *buffer, size_t buffersize, const char *arg, size_t argsize, const quoting_options *o);
char *__cdecl quotearg_alloc(const char *arg, size_t argsize, const quoting_options *o);
void quotearg_free(); // idb
char *__cdecl quotearg_n_options(int n, const char *arg, size_t argsize, const quoting_options *options);
char *__cdecl quotearg_n(int n, const char *arg);
char *__cdecl quotearg(const char *arg);
quoting_options *quoting_options_from_style(quoting_options *__return_ptr __struct_ptr retstr, quoting_style style);
char *__cdecl quotearg_n_style(int n, quoting_style s, const char *arg);
char *__cdecl quotearg_n_style_mem(int n, quoting_style s, const char *arg, size_t argsize);
char *__cdecl quotearg_style(quoting_style s, const char *arg);
char *__cdecl quotearg_char(const char *arg, char ch_0);
char *__cdecl quotearg_colon(const char *arg);
char *__cdecl memcpy_lowcase(char *dest, const char *src, size_t len);
char *__cdecl memcpy_uppcase(char *dest, const char *src, size_t len);
size_t __cdecl strftime_case_(bool upcase, char *s, size_t maxsize, const char *format, const tm *tp, int ut, int ns);
int __cdecl iso_week_days(int yday, int wday);
size_t __cdecl nstrftime(char *s, size_t maxsize, const char *format, const tm *tp, int ut, int ns);
char *__cdecl umaxtostr(uintmax_t i, char *buf);
int __cdecl rpl_vfprintf(FILE *fp, const char *format, va_list args);
void *__cdecl xnmalloc(size_t n, size_t s);
void *__cdecl xnrealloc(void *p, size_t n, size_t s);
void *__cdecl x2nrealloc(void *p, size_t *pn, size_t s);
char *__cdecl xcharalloc(size_t n);
void *__cdecl xmalloc(size_t n);
void *__cdecl xrealloc(void *p, size_t n);
void *__cdecl _ZN10Fl_Browser10bottomlineEi(void *p, size_t *pn);
void *__cdecl xzalloc(size_t s);
void *__cdecl xcalloc(size_t n, size_t s);
void *__cdecl xmemdup(const void *p, size_t s);
char *__cdecl xstrdup(const char *string);
void __cdecl xstrtol_error(strtol_error err, int opt_idx, char c, const option *long_options, const char *arg, int exit_status);
void __cdecl xstrtol_fatal(strtol_error err, int opt_idx, char c, const option *long_options, const char *arg);
strtol_error_0 __cdecl bkm_scale(unsigned int *x, int scale_factor);
strtol_error_0 __cdecl bkm_scale_by_power(unsigned int *x, int base, int power);
strtol_error_0 __cdecl xstrtoul(const char *s, char **ptr, int strtol_base, unsigned int *val, const char *valid_suffixes);
void __cdecl fseterr(FILE *fp);
char *__cdecl xstrndup(const char *string, size_t n);
strtol_error_0 __cdecl bkm_scale_0(uintmax_t *x, int scale_factor);
strtol_error_0 __cdecl bkm_scale_by_power_0(uintmax_t *x, int base, int power);
strtol_error_0 __cdecl xstrtoumax(const char *s, char **ptr, int strtol_base, uintmax_t *val, const char *valid_suffixes);
int __cdecl close_stream(FILE *stream);
int __cdecl is_infinitel(long double x);
char *__cdecl vasnprintf(char *resultbuf, size_t *lengthp, const char *format, va_list args);
size_t __cdecl xsum4(size_t size1, size_t size2, size_t size3, size_t size4);
size_t __cdecl xmax(size_t size1, size_t size2);
size_t __cdecl xsum(size_t size1, size_t size2);
int __cdecl rpl_isnanl(long double x);
int __cdecl printf_fetchargs(va_list args, arguments *a);
int __cdecl printf_parse(const char *format, char_directives *d, arguments *a);
size_t __cdecl xsum_0(size_t size1, size_t size2);
void _libc_csu_fini(void); // idb
void _libc_csu_init(void); // idb
int __cdecl atexit(void (__cdecl *lpfunc)(void *)); // idb
int __cdecl stat64(int a1, int a2);
int __cdecl fstat64(int a1, int a2);
int __cdecl lstat64(int a1, int a2);
void (*_do_global_ctors_aux())(void);
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

const char filetype_letter[11] = "?pcdb-lswd"; // idb
const char *const time_style_args[5] = { "full-iso", "long-iso", "iso", "locale", NULL }; // idb
const time_style time_style_types[4] = { full_iso_time_style, long_iso_time_style, iso_time_style, locale_time_style }; // idb
const char *const indicator_style_args[5] = { "none", "slash", "file-type", "classify", NULL }; // idb
const indicator_style indicator_style_types[4] = { none, slash, file_type, classify }; // idb
const char *const indicator_name[21] =
{
  &unk_805E590,
  &unk_805E593,
  &unk_805E596,
  &unk_805E599,
  &unk_805E59C,
  &unk_805E59F,
  &unk_805E5A2,
  &unk_805E5A5,
  &unk_805E5A8,
  &unk_805E5AB,
  &unk_805E5AE,
  &unk_805E5B1,
  &unk_805E5B4,
  &unk_805E5B7,
  &unk_805E5BA,
  &unk_805E5BD,
  &unk_805E5C0,
  &unk_805E5C3,
  &unk_805E5C6,
  &unk_805E5C9,
  NULL
}; // idb
_UNKNOWN unk_805E639; // weak
const option long_options[42] =
{
  { "all", 0, NULL, 97 },
  { "escape", 0, NULL, 98 },
  { "directory", 0, NULL, 100 },
  { "dired", 0, NULL, 68 },
  { "full-time", 0, NULL, 134 },
  { "group-directories-first", 0, NULL, 135 },
  { "human-readable", 0, NULL, 104 },
  { "inode", 0, NULL, 105 },
  { "numeric-uid-gid", 0, NULL, 110 },
  { "no-group", 0, NULL, 71 },
  { "hide-control-chars", 0, NULL, 113 },
  { "reverse", 0, NULL, 114 },
  { "size", 0, NULL, 115 },
  { "width", 1, NULL, 119 },
  { "almost-all", 0, NULL, 65 },
  { "ignore-backups", 0, NULL, 66 },
  { "classify", 0, NULL, 70 },
  { "file-type", 0, NULL, 132 },
  { "si", 0, NULL, 140 },
  { "dereference-command-line", 0, NULL, 72 },
  { "dereference-command-line-symlink-to-dir", 0, NULL, 131 },
  { "hide", 1, NULL, 136 },
  { "ignore", 1, NULL, 73 },
  { "indicator-style", 1, NULL, 137 },
  { "dereference", 0, NULL, 76 },
  { "literal", 0, NULL, 78 },
  { "quote-name", 0, NULL, 81 },
  { "quoting-style", 1, NULL, 138 },
  { "recursive", 0, NULL, 82 },
  { "format", 1, NULL, 133 },
  { "show-control-chars", 0, NULL, 139 },
  { "sort", 1, NULL, 141 },
  { "tabsize", 1, NULL, 84 },
  { "time", 1, NULL, 142 },
  { "time-style", 1, NULL, 143 },
  { "color", 2, NULL, 130 },
  { "block-size", 1, NULL, 129 },
  { "context", 0, NULL, 90 },
  { "author", 0, NULL, 128 },
  { "help", 0, NULL, -130 },
  { "version", 0, NULL, -131 },
  { NULL, 0, NULL, 0 }
}; // idb
const char *const format_args[8] =
{
  "verbose",
  "long",
  "commas",
  "horizontal",
  "across",
  "vertical",
  "single-column",
  NULL
}; // idb
const format format_types[7] =
{
  long_format,
  long_format,
  with_commas,
  horizontal,
  horizontal,
  many_per_line,
  one_per_line
}; // idb
const char *const sort_args[6] = { "none", "time", "size", "extension", "version", NULL }; // idb
const sort_type sort_types[5] = { sort_none, sort_time, sort_size, sort_extension, sort_version }; // idb
const char *const time_args[6] = { "atime", "access", "use", "ctime", "status", NULL }; // idb
const time_type time_types[5] = { time_atime, time_atime, time_atime, time_ctime, time_ctime }; // idb
const char *const color_args[10] =
{
  "always",
  "yes",
  "force",
  "never",
  &unk_805E599,
  "none",
  "auto",
  "tty",
  "if-tty",
  NULL
}; // idb
const color_type color_types[9] =
{
  color_always,
  color_always,
  color_always,
  color_never,
  color_never,
  color_never,
  color_if_tty,
  color_if_tty,
  color_if_tty
}; // idb
const int sig_6258[12] = { 20, 14, 1, 2, 13, 3, 15, 29, 27, 26, 24, 25 }; // idb
const char locale = '\0'; // idb
const Hash_tuning default_tuning = {  0.0,  1.0,  0.80000001,  1.414, false }; // idb
const char power_letter[9] = { '\0', 'K', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y' }; // idb
_UNKNOWN unk_80618F9; // weak
_UNKNOWN unk_80618FB; // weak
const char *const block_size_args[3] = { "human-readable", "si", NULL }; // idb
const int block_size_opts[2] = { 176, 144 }; // idb
_UNKNOWN unk_80619AC; // weak
const char *const quoting_style_args[8] = { "literal", "shell", "shell-always", "c", "escape", "locale", "clocale", NULL }; // idb
const quoting_style quoting_style_vals[7] =
{
  literal_quoting_style,
  shell_quoting_style,
  shell_always_quoting_style,
  c_quoting_style,
  escape_quoting_style,
  locale_quoting_style,
  clocale_quoting_style
}; // idb
_UNKNOWN unk_8061D05; // weak
_UNKNOWN unk_8061EF4; // weak
const wchar_t wide_null_string_1636[7] = { 40, 78, 85, 76, 76, 41, 0 }; // idb
int _CTOR_LIST__ = -1; // weak
int _DTOR_LIST__[] = { -1 }; // weak
int _DTOR_END__ = 0; // weak
int _JCR_LIST__ = 0; // weak
int (*dword_8063FFC)(void) = NULL; // weak
_DWORD _dso_handle[7] = { 0, 0, 0, 0, 0, 0, 0 }; // idb
time_t current_time = 2147483648; // idb
int current_time_ns = -1; // idb
char UNKNOWN_SECURITY_CONTEXT[2] = "?"; // idb
bool print_owner = true; // idb
bool print_group = true; // idb
uintmax_t file_output_block_size = 1uLL; // idb
bin_str color_indicator[20] =
{
  { 2u, &unk_805E634 },
  { 1u, &unk_805E637 },
  { 0u, NULL },
  { 1u, &unk_805E639 },
  { 1u, &unk_805E639 },
  { 5u, "01;34" },
  { 5u, "01;36" },
  { 2u, "33" },
  { 5u, "01;35" },
  { 5u, "01;33" },
  { 5u, "01;33" },
  { 0u, NULL },
  { 0u, NULL },
  { 5u, "01;32" },
  { 5u, "01;35" },
  { 5u, "37;41" },
  { 5u, "30;43" },
  { 5u, "37;44" },
  { 5u, "34;42" },
  { 5u, "30;42" }
}; // idb
const char *long_time_format[2] = { "%b %e  %Y", "%b %e %H:%M" }; // idb
bool first_7139 = true; // idb
qsortFunc sort_functions[7][2][2][2] =
{
  {
    {
      { &xstrcoll_name, &xstrcoll_df_name },
      { &rev_xstrcoll_name, &rev_xstrcoll_df_name }
    },
    {
      { &strcmp_name, &strcmp_df_name },
      { &rev_strcmp_name, &rev_strcmp_df_name }
    }
  },
  {
    {
      { &xstrcoll_extension, &xstrcoll_df_extension },
      { &rev_xstrcoll_extension, &rev_xstrcoll_df_extension }
    },
    {
      { &strcmp_extension, &strcmp_df_extension },
      { &rev_strcmp_extension, &rev_strcmp_df_extension }
    }
  },
  {
    {
      { &xstrcoll_size, &xstrcoll_df_size },
      { &rev_xstrcoll_size, &rev_xstrcoll_df_size }
    },
    {
      { &strcmp_size, &strcmp_df_size },
      { &rev_strcmp_size, &rev_strcmp_df_size }
    }
  },
  {
    {
      { &xstrcoll_version, &xstrcoll_df_version },
      { &rev_xstrcoll_version, &rev_xstrcoll_df_version }
    },
    { { NULL, NULL }, { NULL, NULL } }
  },
  {
    {
      { &xstrcoll_mtime, &xstrcoll_df_mtime },
      { &rev_xstrcoll_mtime, &rev_xstrcoll_df_mtime }
    },
    {
      { &strcmp_mtime, &strcmp_df_mtime },
      { &rev_strcmp_mtime, &rev_strcmp_df_mtime }
    }
  },
  {
    {
      { &xstrcoll_ctime, &xstrcoll_df_ctime },
      { &rev_xstrcoll_ctime, &rev_xstrcoll_df_ctime }
    },
    {
      { &strcmp_ctime, &strcmp_df_ctime },
      { &rev_strcmp_ctime, &rev_strcmp_df_ctime }
    }
  },
  {
    {
      { &xstrcoll_atime, &xstrcoll_df_atime },
      { &rev_xstrcoll_atime, &rev_xstrcoll_df_atime }
    },
    {
      { &strcmp_atime, &strcmp_df_atime },
      { &rev_strcmp_atime, &rev_strcmp_df_atime }
    }
  }
}; // idb
int width_9028 = -1; // idb
indicator_no filetype_indicator_9866[10] = { C_ORPHAN, C_FIFO, C_CHR, C_DIR, C_BLK, C_FILE, C_LINK, C_SOCK, C_FILE, C_DIR }; // idb
int ls_mode = 1; // idb
argmatch_exit_fn argmatch_die = &_argmatch_die; // idb
volatile int exit_failure = 1; // idb
unsigned int nslots = 1u; // idb
slotvec slotvec0 = { 256u, &slot0 }; // idb
slotvec *slotvec_0 = &slotvec0; // idb
int optind; // weak
FILE *stderr; // idb
FILE *stdout; // idb
char *optarg; // idb
char completed_6635; // weak
int dtor_idx_6637; // weak
color_ext_type *color_ext_list; // idb
size_t column_info_alloc_10187; // idb
Hash_table *active_dir_set; // idb
fileinfo *cwd_file; // idb
size_t cwd_n_alloc; // idb
size_t cwd_n_used; // idb
void **sorted_file; // idb
size_t sorted_file_alloc; // idb
bool color_symlink_as_referent; // idb
pending *pending_dirs; // idb
bool print_scontext; // idb
bool any_has_acl; // idb
int inode_number_width; // idb
int block_size_width; // idb
int nlink_width; // idb
int scontext_width; // idb
int owner_width; // idb
int group_width; // idb
int author_width; // idb
int major_device_number_width; // idb
int minor_device_number_width; // idb
int file_size_width; // idb
format format_0; // idb
time_type time_type_0; // idb
sort_type sort_type_0; // idb
bool sort_reverse; // idb
bool print_author; // idb
bool numeric_ids; // idb
bool print_block_size; // idb
int human_output_opts; // idb
uintmax_t output_block_size; // idb
bool dired; // idb
indicator_style indicator_style_0; // idb
bool print_with_color; // idb
char *color_buf; // idb
bool check_symlink_color; // idb
bool print_inode; // idb
Dereference_symlink dereference; // idb
bool recursive; // idb
bool immediate_dirs; // idb
bool directories_first; // idb
$BC0F73628CF3D7A4B76FB1684D8A42FF ignore_mode; // idb
ignore_pattern *ignore_patterns; // idb
ignore_pattern *hide_patterns; // idb
bool qmark_funny_chars; // idb
quoting_options *filename_quoting_options; // idb
quoting_options *dirname_quoting_options; // idb
size_t tabsize; // idb
bool print_dir_name; // idb
size_t line_length; // idb
bool format_needs_stat; // idb
bool format_needs_type; // idb
sigset_t caught_signals; // idb
volatile sig_atomic_t interrupt_signal; // idb
volatile sig_atomic_t stop_signal_count; // idb
int exit_status; // idb
column_info *column_info_0; // idb
size_t max_idx; // idb
size_t dired_pos; // idb
obstack dired_obstack; // idb
obstack subdired_obstack; // idb
obstack dev_ino_obstack; // idb
jmp_buf failed_strcoll; // idb
const char *file_name; // idb
userid *user_alist; // idb
userid *nouser_alist; // idb
userid *group_alist; // idb
userid *nogroup_alist; // idb
quoting_options default_quoting_options; // idb
char slot0[256]; // idb
const mbstate_t mbstate_zero; // idb
char *program_name; // idb
// extern _UNKNOWN _gmon_start__; weak


//----- (0804947C) --------------------------------------------------------
int init_proc()
{
  int v1; // [esp+0h] [ebp-8h]

  if ( &_gmon_start__ )
    __gmon_start__();
  frame_dummy();
  _do_global_ctors_aux();
  return v1;
}
// 80494A8: variable 'v1' is possibly undefined
// 804959C: using guessed type int __gmon_start__(void);

//----- (080494AC) --------------------------------------------------------
int sub_80494AC()
{
  return dword_8063FFC();
}
// 8063FFC: using guessed type int (*dword_8063FFC)(void);

//----- (08049AD0) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall __noreturn start(int a1@<eax>, void (*a2)(void)@<edx>)
{
  int v2; // esi
  int v3; // [esp-4h] [ebp-4h] BYREF
  char *retaddr; // [esp+0h] [ebp+0h] BYREF

  v2 = v3;
  v3 = a1;
  __libc_start_main((int (__cdecl *)(int, char **, char **))main, v2, &retaddr, _libc_csu_init, _libc_csu_fini, a2, &v3);
  __halt();
}
// 8049AD3: positive sp value 4 has been found

//----- (08049B00) --------------------------------------------------------
void _do_global_dtors_aux()
{
  int v0; // edx
  unsigned int i; // ebx

  if ( !completed_6635 )
  {
    v0 = dtor_idx_6637;
    for ( i = &_DTOR_END__ - _DTOR_LIST__ - 1; dtor_idx_6637 < i; v0 = dtor_idx_6637 )
    {
      dtor_idx_6637 = v0 + 1;
      ((void (*)(void))_DTOR_LIST__[v0 + 1])();
    }
    completed_6635 = 1;
  }
}
// 8063F08: using guessed type int _DTOR_LIST__[];
// 8063F0C: using guessed type int _DTOR_END__;
// 8064428: using guessed type char completed_6635;
// 806442C: using guessed type int dtor_idx_6637;

//----- (08049B60) --------------------------------------------------------
int frame_dummy()
{
  int result; // eax

  result = _JCR_LIST__;
  if ( _JCR_LIST__ )
    result = 0;
  return result;
}
// 8063F10: using guessed type int _JCR_LIST__;

//----- (08049B84) --------------------------------------------------------
dev_ino *__stdcall dev_ino_pop(dev_ino *retstr)
{
  if ( (unsigned int)(dev_ino_obstack.next_free - dev_ino_obstack.object_base) <= 0xF )
    __assert_fail(
      "sizeof (struct dev_ino) <= __extension__ ({ struct obstack const *__o = (&dev_ino_obstack); (unsigned) (__o->next_"
      "free - __o->object_base); })",
      "ls.c",
      0x396u,
      "dev_ino_pop");
  if ( dev_ino_obstack.chunk_limit - dev_ino_obstack.next_free < -16 )
    _obstack_newchunk(&dev_ino_obstack, -16);
  dev_ino_obstack.next_free -= 16;
  memmove(retstr, dev_ino_obstack.next_free, 0x10u);
  return retstr;
}

//----- (08049C3B) --------------------------------------------------------
void __cdecl dired_dump_obstack(const char *prefix, obstack *os)
{
  unsigned int n_pos; // [esp+1Ch] [ebp-1Ch]
  size_t i; // [esp+24h] [ebp-14h]
  char *__value; // [esp+30h] [ebp-8h]

  n_pos = (unsigned int)(os->next_free - os->object_base) >> 2;
  if ( n_pos )
  {
    __value = os->object_base;
    if ( os->next_free == __value )
      *((_BYTE *)os + 40) |= 2u;
    os->next_free = (char *)((int)&os->next_free[os->alignment_mask] & ~os->alignment_mask);
    if ( os->next_free - (char *)os->chunk > os->chunk_limit - (char *)os->chunk )
      os->next_free = os->chunk_limit;
    os->object_base = os->next_free;
    fputs_unlocked(prefix, stdout);
    for ( i = 0; i < n_pos; ++i )
      printf(" %lu", *(_DWORD *)&__value[4 * i]);
    putchar_unlocked(10);
  }
}
// 804955C: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (08049D54) --------------------------------------------------------
size_t __cdecl dev_ino_hash(const void *x, size_t table_size)
{
  return *(_QWORD *)x % (unsigned __int64)table_size;
}

//----- (08049D8B) --------------------------------------------------------
bool __cdecl dev_ino_compare(const void *x, const void *y)
{
  return *(_QWORD *)x == *(_QWORD *)y && *((_QWORD *)x + 1) == *((_QWORD *)y + 1);
}

//----- (08049DF4) --------------------------------------------------------
void __cdecl dev_ino_free(void *x)
{
  free(x);
}

//----- (08049E07) --------------------------------------------------------
bool __cdecl visit_dir(dev_t dev, ino_t ino)
{
  dev_ino *ent; // [esp+1Ch] [ebp-Ch]
  dev_ino *ent_from_table; // [esp+20h] [ebp-8h]

  ent = (dev_ino *)xmalloc(0x10u);
  ent->st_ino = ino;
  ent->st_dev = dev;
  ent_from_table = (dev_ino *)hash_insert(active_dir_set, ent);
  if ( !ent_from_table )
    xalloc_die();
  if ( ent_from_table != ent )
    free(ent);
  return ent_from_table != ent;
}

//----- (08049E97) --------------------------------------------------------
void __cdecl free_pending_ent(pending *p)
{
  free(p->name);
  free(p->realname);
  free(p);
}

//----- (08049EC5) --------------------------------------------------------
bool __cdecl is_colored(indicator_no type)
{
  size_t len; // [esp+20h] [ebp-8h]
  const char *s; // [esp+24h] [ebp-4h]

  len = color_indicator[type].len;
  s = color_indicator[type].string;
  return len && (len != 1 || *s != unk_805E639) && (len != 2 || strncmp(s, "00", 2u));
}

//----- (08049F3E) --------------------------------------------------------
void restore_default_color()
{
  put_indicator(color_indicator);
  put_indicator(&color_indicator[1]);
}

//----- (08049F5E) --------------------------------------------------------
void __cdecl sighandler(int sig)
{
  if ( !interrupt_signal )
    interrupt_signal = sig;
}

//----- (08049F74) --------------------------------------------------------
void __cdecl stophandler(int sig)
{
  if ( !interrupt_signal )
    ++stop_signal_count;
}

//----- (08049F8F) --------------------------------------------------------
void process_signals()
{
  sigset_t oldset; // [esp+20h] [ebp-88h] BYREF
  int sig; // [esp+A0h] [ebp-8h]
  int stops; // [esp+A4h] [ebp-4h]

  while ( __PAIR64__(stop_signal_count, interrupt_signal) )
  {
    restore_default_color();
    fflush_unlocked(stdout);
    sigprocmask(0, &caught_signals, &oldset);
    sig = interrupt_signal;
    stops = stop_signal_count;
    if ( stop_signal_count )
    {
      stop_signal_count = stops - 1;
      sig = 19;
    }
    else
    {
      signal(sig, 0);
    }
    raise(sig);
    sigprocmask(2, &oldset, 0);
  }
}

//----- (0804A04A) --------------------------------------------------------
int __cdecl __noreturn main(int argc, const char **argv, const char **envp)
{
  const char *v3; // eax
  quoting_style v4; // eax
  void (*v5)(int); // [esp+10h] [ebp-DCh]
  Dereference_symlink v6; // [esp+14h] [ebp-D8h]
  bool v7; // [esp+18h] [ebp-D4h]
  bool v8; // [esp+1Ch] [ebp-D0h]
  sigaction act; // [esp+2Ch] [ebp-C0h] BYREF
  dev_ino di_0; // [esp+B8h] [ebp-34h] BYREF
  int i; // [esp+C8h] [ebp-24h]
  pending *thispend; // [esp+CCh] [ebp-20h]
  int n_files; // [esp+D0h] [ebp-1Ch]
  int j; // [esp+D4h] [ebp-18h]
  dev_ino *found; // [esp+D8h] [ebp-14h]
  int j_0; // [esp+DCh] [ebp-10h]
  int *v17; // [esp+E0h] [ebp-Ch]

  v17 = &argc;
  program_name = (char *)*argv;
  setlocale(6, &locale);
  bindtextdomain("coreutils", "/usr/local/share/locale");
  textdomain("coreutils");
  initialize_exit_failure(2);
  atexit((void (__cdecl *)(void *))close_stdout);
  exit_status = 0;
  print_dir_name = 1;
  pending_dirs = 0;
  i = decode_switches(argc, (char **)argv);
  if ( print_with_color )
    parse_ls_color();
  if ( print_with_color )
  {
    if ( is_colored(C_ORPHAN)
      || is_colored(C_EXEC) && color_symlink_as_referent
      || is_colored(C_MISSING) && format_0 == long_format )
    {
      check_symlink_color = 1;
    }
    if ( tcgetpgrp(1) >= 0 )
    {
      sigemptyset(&caught_signals);
      for ( j = 0; j <= 11; ++j )
      {
        sigaction(sig_6258[j], 0, &act);
        if ( act.sa_handler != (__sighandler_t)1 )
          sigaddset(&caught_signals, sig_6258[j]);
      }
      qmemcpy(&act.sa_mask, &caught_signals, sizeof(act.sa_mask));
      act.sa_flags = 0x10000000;
      for ( j = 0; j <= 11; ++j )
      {
        if ( sigismember(&caught_signals, sig_6258[j]) )
        {
          if ( sig_6258[j] == 20 )
            v5 = stophandler;
          else
            v5 = sighandler;
          act.sa_handler = v5;
          sigaction(sig_6258[j], &act, 0);
        }
      }
    }
    prep_non_filename_text();
  }
  if ( dereference == DEREF_UNDEFINED )
  {
    if ( immediate_dirs || indicator_style_0 == classify || format_0 == long_format )
      v6 = DEREF_NEVER;
    else
      v6 = DEREF_COMMAND_LINE_SYMLINK_TO_DIR;
    dereference = v6;
  }
  if ( recursive )
  {
    active_dir_set = hash_initialize(0x1Eu, 0, dev_ino_hash, dev_ino_compare, dev_ino_free);
    if ( !active_dir_set )
      xalloc_die();
    _obstack_begin(&dev_ino_obstack, 0, 0, (void *(*)(int))malloc, free);
  }
  v7 = sort_type_0 == sort_time
    || sort_type_0 == sort_size
    || format_0 == long_format
    || print_scontext
    || print_block_size;
  format_needs_stat = v7;
  v8 = !v7 && (recursive || print_with_color || indicator_style_0 || directories_first);
  format_needs_type = v8;
  if ( dired )
  {
    _obstack_begin(&dired_obstack, 0, 0, (void *(*)(int))malloc, free);
    _obstack_begin(&subdired_obstack, 0, 0, (void *(*)(int))malloc, free);
  }
  cwd_n_alloc = 100;
  cwd_file = (fileinfo *)xnmalloc(0x64u, 0x78u);
  cwd_n_used = 0;
  clear_files();
  n_files = argc - i;
  if ( argc - i > 0 )
  {
    do
    {
      v3 = argv[i++];
      gobble_file(v3, unknown, 0LL, 1, &locale);
    }
    while ( i < argc );
  }
  else if ( immediate_dirs )
  {
    gobble_file(".", directory, 0LL, 1, &locale);
  }
  else
  {
    queue_directory(".", 0, 1);
  }
  if ( cwd_n_used )
  {
    sort_files();
    if ( !immediate_dirs )
      extract_dirs_from_files(0, 1);
  }
  if ( cwd_n_used )
  {
    print_current_files();
    if ( pending_dirs )
    {
      putchar_unlocked(10);
      ++dired_pos;
    }
  }
  else if ( n_files <= 1 && pending_dirs && !pending_dirs->next )
  {
    print_dir_name = 0;
  }
  while ( pending_dirs )
  {
    thispend = pending_dirs;
    pending_dirs = pending_dirs->next;
    if ( !active_dir_set || thispend->name )
    {
      print_dir(thispend->name, thispend->realname, thispend->command_line_arg);
      free_pending_ent(thispend);
      print_dir_name = 1;
    }
    else
    {
      dev_ino_pop(&di_0);
      found = (dev_ino *)hash_delete(active_dir_set, &di_0);
      if ( !found )
        __assert_fail("found", "ls.c", 0x51Eu, "main");
      dev_ino_free(found);
      free_pending_ent(thispend);
    }
  }
  if ( print_with_color )
  {
    restore_default_color();
    fflush_unlocked(stdout);
    for ( j_0 = 0; j_0 <= 11; ++j_0 )
    {
      if ( sigismember(&caught_signals, sig_6258[j_0]) )
        signal(sig_6258[j_0], 0);
    }
    for ( j_0 = stop_signal_count; j_0; --j_0 )
      raise(19);
    j_0 = interrupt_signal;
    if ( interrupt_signal )
      raise(j_0);
  }
  if ( dired )
  {
    dired_dump_obstack("//DIRED//", &dired_obstack);
    dired_dump_obstack("//SUBDIRED//", &subdired_obstack);
    v4 = get_quoting_style(filename_quoting_options);
    printf("//DIRED-OPTIONS// --quoting-style=%s\n", quoting_style_args[v4]);
  }
  if ( active_dir_set )
  {
    if ( hash_get_n_entries(active_dir_set) )
      __assert_fail("hash_get_n_entries (active_dir_set) == 0", "ls.c", 0x554u, "main");
    hash_free(active_dir_set);
  }
  exit(exit_status);
}

//----- (0804A844) --------------------------------------------------------
void __cdecl initialize_exit_failure(int status)
{
  if ( status != 1 )
    exit_failure = status;
}

//----- (0804A857) --------------------------------------------------------
int __cdecl decode_switches(int argc, char **argv)
{
  char *v2; // ebx
  char *v3; // eax
  char *v4; // ebx
  char *v5; // eax
  char *v6; // ebx
  char *v7; // eax
  char *v8; // ebx
  char *v9; // eax
  char *v10; // ebx
  char *v11; // eax
  ptrdiff_t v12; // eax
  const char *v13; // ebx
  char *v14; // eax
  int result; // eax
  format v16; // [esp+28h] [ebp-80h]
  bool v17; // [esp+2Ch] [ebp-7Ch]
  char *command_name; // [esp+30h] [ebp-78h]
  const char *v19; // [esp+34h] [ebp-74h]
  size_t v20; // [esp+38h] [ebp-70h]
  time_style v22; // [esp+40h] [ebp-68h]
  unsigned int tmp_ulong_2; // [esp+44h] [ebp-64h] BYREF
  unsigned int tmp_ulong_1; // [esp+48h] [ebp-60h] BYREF
  int oi; // [esp+4Ch] [ebp-5Ch] BYREF
  unsigned int tmp_ulong_0; // [esp+50h] [ebp-58h] BYREF
  winsize ws; // [esp+54h] [ebp-54h] BYREF
  unsigned int tmp_ulong; // [esp+5Ch] [ebp-4Ch] BYREF
  char *time_style_option; // [esp+60h] [ebp-48h]
  bool sort_type_specified; // [esp+67h] [ebp-41h]
  const char *q_style; // [esp+68h] [ebp-40h]
  int i; // [esp+6Ch] [ebp-3Ch]
  const char *ls_block_size; // [esp+70h] [ebp-38h]
  const char *p; // [esp+74h] [ebp-34h]
  const char *p_0; // [esp+78h] [ebp-30h]
  int c; // [esp+7Ch] [ebp-2Ch]
  ignore_pattern *hide; // [esp+80h] [ebp-28h]
  int i_0; // [esp+84h] [ebp-24h]
  strtol_error e; // [esp+88h] [ebp-20h]
  const char *p_1; // [esp+8Ch] [ebp-1Ch]
  char *style; // [esp+90h] [ebp-18h]
  char *p0; // [esp+94h] [ebp-14h]
  char *p1; // [esp+98h] [ebp-10h]
  int i_1; // [esp+9Ch] [ebp-Ch]
  const char *locale_format; // [esp+A0h] [ebp-8h]

  time_style_option = 0;
  sort_type_specified = 0;
  qmark_funny_chars = 0;
  if ( ls_mode == 2 )
  {
    format_0 = many_per_line;
    set_quoting_style(0, escape_quoting_style);
  }
  else if ( ls_mode == 3 )
  {
    format_0 = long_format;
    set_quoting_style(0, escape_quoting_style);
  }
  else
  {
    if ( ls_mode != 1 )
      abort();
    if ( isatty(1) )
    {
      format_0 = many_per_line;
      qmark_funny_chars = 1;
    }
    else
    {
      format_0 = one_per_line;
      qmark_funny_chars = 0;
    }
  }
  time_type_0 = time_mtime;
  sort_type_0 = sort_name;
  sort_reverse = 0;
  numeric_ids = 0;
  print_block_size = 0;
  indicator_style_0 = none;
  print_inode = 0;
  dereference = DEREF_UNDEFINED;
  recursive = 0;
  immediate_dirs = 0;
  ignore_mode = IGNORE_DEFAULT;
  ignore_patterns = 0;
  hide_patterns = 0;
  print_scontext = 0;
  q_style = getenv("QUOTING_STYLE");
  if ( q_style )
  {
    i = argmatch(q_style, quoting_style_args, (const char *)quoting_style_vals, 4u);
    if ( i < 0 )
    {
      v2 = quotearg(q_style);
      v3 = gettext("ignoring invalid value of environment variable QUOTING_STYLE: %s");
      error(0, 0, v3, v2);
    }
    else
    {
      set_quoting_style(0, quoting_style_vals[i]);
    }
  }
  ls_block_size = getenv("LS_BLOCK_SIZE");
  human_options(ls_block_size, &human_output_opts, &output_block_size);
  if ( ls_block_size || getenv("BLOCK_SIZE") )
    file_output_block_size = output_block_size;
  line_length = 80;
  p = getenv("COLUMNS");
  if ( p && *p )
  {
    if ( xstrtoul(p, 0, 0, &tmp_ulong, 0) || !tmp_ulong )
    {
      v4 = quotearg(p);
      v5 = gettext("ignoring invalid width in environment variable COLUMNS: %s");
      error(0, 0, v5, v4);
    }
    else
    {
      line_length = tmp_ulong;
    }
  }
  if ( ioctl(1, 0x5413u, &ws) != -1 && ws.ws_col )
    line_length = ws.ws_col;
  p_0 = getenv("TABSIZE");
  tabsize = 8;
  if ( p_0 )
  {
    if ( xstrtoul(p_0, 0, 0, &tmp_ulong_0, 0) )
    {
      v6 = quotearg(p_0);
      v7 = gettext("ignoring invalid tab size in environment variable TABSIZE: %s");
      error(0, 0, v7, v6);
    }
    else
    {
      tabsize = tmp_ulong_0;
    }
  }
  while ( 1 )
  {
    oi = -1;
    c = getopt_long(argc, argv, "abcdfghiklmnopqrstuvw:xABCDFGHI:LNQRST:UXZ1", long_options, &oi);
    if ( c == -1 )
      break;
    switch ( c )
    {
      case -131:
        if ( ls_mode == 1 )
        {
          command_name = "ls";
        }
        else
        {
          if ( ls_mode == 2 )
            v19 = "dir";
          else
            v19 = "vdir";
          command_name = (char *)v19;
        }
        version_etc(stdout, command_name, "GNU coreutils", "6.10", "Richard Stallman", "David MacKenzie", 0);
        exit(0);
        return result;
      case -130:
        usage(0);
        return result;
      case 49:
        format_0 = format_0 != long_format;
        break;
      case 65:
        if ( ignore_mode == IGNORE_DEFAULT )
          ignore_mode = IGNORE_DOT_AND_DOTDOT;
        break;
      case 66:
        add_ignore_pattern("*~");
        add_ignore_pattern(".*~");
        break;
      case 67:
        format_0 = many_per_line;
        break;
      case 68:
        dired = 1;
        break;
      case 70:
        indicator_style_0 = classify;
        break;
      case 71:
        print_group = 0;
        break;
      case 72:
        dereference = DEREF_COMMAND_LINE_ARGUMENTS;
        break;
      case 73:
        add_ignore_pattern(optarg);
        break;
      case 76:
        dereference = DEREF_ALWAYS;
        break;
      case 78:
        set_quoting_style(0, literal_quoting_style);
        break;
      case 81:
        set_quoting_style(0, c_quoting_style);
        break;
      case 82:
        recursive = 1;
        break;
      case 83:
        sort_type_0 = sort_size;
        sort_type_specified = 1;
        break;
      case 84:
        if ( xstrtoul(optarg, 0, 0, &tmp_ulong_2, 0) )
        {
          v10 = quotearg(optarg);
          v11 = gettext("invalid tab size: %s");
          error(2, 0, v11, v10);
        }
        tabsize = tmp_ulong_2;
        break;
      case 85:
        sort_type_0 = sort_none;
        sort_type_specified = 1;
        break;
      case 88:
        sort_type_0 = sort_extension;
        sort_type_specified = 1;
        break;
      case 90:
        print_scontext = 1;
        break;
      case 97:
        ignore_mode = IGNORE_MINIMAL;
        break;
      case 98:
        set_quoting_style(0, escape_quoting_style);
        break;
      case 99:
        time_type_0 = time_ctime;
        break;
      case 100:
        immediate_dirs = 1;
        break;
      case 102:
        ignore_mode = IGNORE_MINIMAL;
        sort_type_0 = sort_none;
        sort_type_specified = 1;
        if ( format_0 == long_format )
        {
          if ( isatty(1) )
            v16 = many_per_line;
          else
            v16 = one_per_line;
          format_0 = v16;
        }
        print_block_size = 0;
        print_with_color = 0;
        break;
      case 103:
        format_0 = long_format;
        print_owner = 0;
        break;
      case 104:
        human_output_opts = 176;
        output_block_size = 1LL;
        file_output_block_size = 1LL;
        break;
      case 105:
        print_inode = 1;
        break;
      case 107:
        human_output_opts = 0;
        output_block_size = 1024LL;
        file_output_block_size = 1024LL;
        break;
      case 108:
        format_0 = long_format;
        break;
      case 109:
        format_0 = with_commas;
        break;
      case 110:
        numeric_ids = 1;
        format_0 = long_format;
        break;
      case 111:
        format_0 = long_format;
        print_group = 0;
        break;
      case 112:
        indicator_style_0 = slash;
        break;
      case 113:
        qmark_funny_chars = 1;
        break;
      case 114:
        sort_reverse = 1;
        break;
      case 115:
        print_block_size = 1;
        break;
      case 116:
        sort_type_0 = sort_time;
        sort_type_specified = 1;
        break;
      case 117:
        time_type_0 = time_atime;
        break;
      case 118:
        sort_type_0 = sort_version;
        sort_type_specified = 1;
        break;
      case 119:
        if ( xstrtoul(optarg, 0, 0, &tmp_ulong_1, 0) || !tmp_ulong_1 )
        {
          v8 = quotearg(optarg);
          v9 = gettext("invalid line width: %s");
          error(2, 0, v9, v8);
        }
        line_length = tmp_ulong_1;
        break;
      case 120:
        format_0 = horizontal;
        break;
      case 128:
        print_author = 1;
        break;
      case 129:
        e = human_options(optarg, &human_output_opts, &output_block_size);
        if ( e )
          xstrtol_fatal(e, oi, 0, long_options, optarg);
        file_output_block_size = output_block_size;
        break;
      case 130:
        if ( optarg )
          i_0 = color_types[_xargmatch_internal(
                              "--color",
                              optarg,
                              color_args,
                              (const char *)color_types,
                              4u,
                              argmatch_die)];
        else
          i_0 = 1;
        v17 = i_0 == 1 || i_0 == 2 && isatty(1);
        print_with_color = v17;
        if ( v17 )
          tabsize = 0;
        break;
      case 131:
        dereference = DEREF_COMMAND_LINE_SYMLINK_TO_DIR;
        break;
      case 132:
        indicator_style_0 = file_type;
        break;
      case 133:
        format_0 = format_types[_xargmatch_internal(
                                  "--format",
                                  optarg,
                                  format_args,
                                  (const char *)format_types,
                                  4u,
                                  argmatch_die)];
        break;
      case 134:
        format_0 = long_format;
        time_style_option = "full-iso";
        break;
      case 135:
        directories_first = 1;
        break;
      case 136:
        hide = (ignore_pattern *)xmalloc(8u);
        hide->pattern = optarg;
        hide->next = hide_patterns;
        hide_patterns = hide;
        break;
      case 137:
        indicator_style_0 = indicator_style_types[_xargmatch_internal(
                                                    "--indicator-style",
                                                    optarg,
                                                    indicator_style_args,
                                                    (const char *)indicator_style_types,
                                                    4u,
                                                    argmatch_die)];
        break;
      case 138:
        v12 = _xargmatch_internal(
                "--quoting-style",
                optarg,
                quoting_style_args,
                (const char *)quoting_style_vals,
                4u,
                argmatch_die);
        set_quoting_style(0, quoting_style_vals[v12]);
        break;
      case 139:
        qmark_funny_chars = 0;
        break;
      case 140:
        human_output_opts = 144;
        output_block_size = 1LL;
        file_output_block_size = 1LL;
        break;
      case 141:
        sort_type_0 = sort_types[_xargmatch_internal(
                                   "--sort",
                                   optarg,
                                   sort_args,
                                   (const char *)sort_types,
                                   4u,
                                   argmatch_die)];
        sort_type_specified = 1;
        break;
      case 142:
        time_type_0 = time_types[_xargmatch_internal(
                                   "--time",
                                   optarg,
                                   time_args,
                                   (const char *)time_types,
                                   4u,
                                   argmatch_die)];
        break;
      case 143:
        time_style_option = optarg;
        break;
      default:
        usage(2);
        return result;
    }
  }
  if ( line_length <= 2 )
    v20 = 1;
  else
    v20 = line_length / 3;
  max_idx = v20;
  filename_quoting_options = clone_quoting_options(0);
  if ( get_quoting_style(filename_quoting_options) == escape_quoting_style )
    set_char_quoting(filename_quoting_options, 32, 1);
  if ( (unsigned int)indicator_style_0 > slash )
  {
    for ( p_1 = (const char *)(indicator_style_0 - 2 + 134606820); *p_1; ++p_1 )
      set_char_quoting(filename_quoting_options, *p_1, 1);
  }
  dirname_quoting_options = clone_quoting_options(0);
  set_char_quoting(dirname_quoting_options, 58, 1);
  if ( dired && format_0 )
    dired = 0;
  if ( (time_type_0 == time_ctime || time_type_0 == time_atime) && !sort_type_specified && format_0 )
    sort_type_0 = sort_time;
  if ( format_0 == long_format )
  {
    style = time_style_option;
    if ( !time_style_option )
    {
      style = getenv("TIME_STYLE");
      if ( !style )
        style = "locale";
    }
    while ( !strncmp(style, "posix-", 6u) )
    {
      if ( !hard_locale(2) )
        return optind;
      style += 6;
    }
    if ( *style == 43 )
    {
      p0 = style + 1;
      p1 = strchr(style + 1, 10);
      if ( p1 )
      {
        if ( strchr(p1 + 1, 10) )
        {
          v13 = quote(p0);
          v14 = gettext("invalid time style format %s");
          error(2, 0, v14, v13);
        }
        *p1++ = 0;
      }
      else
      {
        p1 = p0;
      }
      long_time_format[0] = p0;
      long_time_format[1] = p1;
    }
    else
    {
      v22 = time_style_types[_xargmatch_internal(
                               "time style",
                               style,
                               time_style_args,
                               (const char *)time_style_types,
                               4u,
                               argmatch_die)];
      if ( v22 == long_iso_time_style )
      {
case_long_iso_time_style:
        long_time_format[1] = "%Y-%m-%d %H:%M";
        long_time_format[0] = "%Y-%m-%d %H:%M";
      }
      else if ( v22 )
      {
        if ( v22 == iso_time_style )
        {
          long_time_format[0] = "%Y-%m-%d ";
          long_time_format[1] = "%m-%d %H:%M";
        }
        else if ( v22 == locale_time_style && hard_locale(2) )
        {
          for ( i_1 = 0; i_1 <= 1; ++i_1 )
          {
            locale_format = dcgettext(0, long_time_format[i_1], 2);
            if ( long_time_format[i_1] == locale_format )
              goto case_long_iso_time_style;
            long_time_format[i_1] = locale_format;
          }
        }
      }
      else
      {
        long_time_format[1] = "%Y-%m-%d %H:%M:%S.%N %z";
        long_time_format[0] = "%Y-%m-%d %H:%M:%S.%N %z";
      }
    }
  }
  return optind;
}
// 8064400: using guessed type int optind;

//----- (0804B7D9) --------------------------------------------------------
bool __cdecl get_funky_string(char **dest, const char **src, bool equals_end, size_t *output_count)
{
  bool result; // al
  int v5; // [esp+Ch] [ebp-2Ch]
  char num; // [esp+27h] [ebp-11h]
  size_t count; // [esp+28h] [ebp-10h]
  get_funky_string::$516E7AD2FAB920DC4733ED9CB2E6B3C9 state; // [esp+2Ch] [ebp-Ch]
  const char *p; // [esp+30h] [ebp-8h]
  char *q; // [esp+34h] [ebp-4h]

  p = *src;
  q = *dest;
  count = 0;
  num = 0;
  state = ST_GND;
LABEL_51:
  while ( (unsigned int)state <= ST_CARET )
  {
    switch ( state )
    {
      case ST_GND:
        v5 = *p;
        if ( v5 == 61 )
        {
          if ( equals_end )
          {
            state = ST_END;
            goto LABEL_51;
          }
        }
        else if ( v5 > 61 )
        {
          if ( v5 == 92 )
          {
            state = ST_BACKSLASH;
            ++p;
            goto LABEL_51;
          }
          if ( v5 == 94 )
          {
            state = ST_CARET;
            ++p;
            goto LABEL_51;
          }
        }
        else if ( !*p || v5 == 58 )
        {
          state = ST_END;
          goto LABEL_51;
        }
        *q++ = *p++;
        ++count;
        break;
      case ST_BACKSLASH:
        switch ( *p )
        {
          case 0:
            state = ST_ERROR;
            break;
          case 0x30:
          case 0x31:
          case 0x32:
          case 0x33:
          case 0x34:
          case 0x35:
          case 0x36:
          case 0x37:
            state = ST_OCTAL;
            num = *p - 48;
            break;
          case 0x3F:
            num = 127;
            break;
          case 0x58:
          case 0x78:
            state = ST_HEX;
            num = 0;
            break;
          case 0x5F:
            num = 32;
            break;
          case 0x61:
            num = 7;
            break;
          case 0x62:
            num = 8;
            break;
          case 0x65:
            num = 27;
            break;
          case 0x66:
            num = 12;
            break;
          case 0x6E:
            num = 10;
            break;
          case 0x72:
            num = 13;
            break;
          case 0x74:
            num = 9;
            break;
          case 0x76:
            num = 11;
            break;
          default:
            num = *p;
            break;
        }
        if ( state == ST_BACKSLASH )
        {
          *q++ = num;
          ++count;
          state = ST_GND;
        }
        ++p;
        goto LABEL_51;
      case ST_OCTAL:
        if ( *p > 47 && *p <= 55 )
        {
          num = 8 * num + *p++ - 48;
        }
        else
        {
          *q++ = num;
          ++count;
          state = ST_GND;
        }
        goto LABEL_51;
      case ST_HEX:
        switch ( *p )
        {
          case '0':
          case '1':
          case '2':
          case '3':
          case '4':
          case '5':
          case '6':
          case '7':
          case '8':
          case '9':
            num = 16 * num + *p++ - 48;
            break;
          case 'A':
          case 'B':
          case 'C':
          case 'D':
          case 'E':
          case 'F':
            num = 16 * num + *p++ - 55;
            break;
          case 'a':
          case 'b':
          case 'c':
          case 'd':
          case 'e':
          case 'f':
            num = 16 * num + *p++ - 87;
            break;
          default:
            *q++ = num;
            ++count;
            state = ST_GND;
            break;
        }
        goto LABEL_51;
      case ST_CARET:
        state = ST_GND;
        if ( *p <= 63 || *p == 127 )
        {
          if ( *p == 63 )
          {
            *q++ = 127;
            ++count;
          }
          else
          {
            state = ST_ERROR;
          }
        }
        else
        {
          *q++ = *p++ & 0x1F;
          ++count;
        }
        goto LABEL_51;
      default:
        abort();
        return result;
    }
  }
  *dest = q;
  *src = p;
  *output_count = count;
  return state != ST_ERROR;
}

//----- (0804BAE2) --------------------------------------------------------
void parse_ls_color()
{
  char *v1; // ebx
  char *v2; // eax
  char *v4; // eax
  int v5; // [esp+14h] [ebp-34h]
  int v6; // [esp+18h] [ebp-30h]
  int v7; // [esp+1Ch] [ebp-2Ch]
  int v8; // [esp+20h] [ebp-28h]
  char label[3]; // [esp+25h] [ebp-23h] BYREF
  char *buf; // [esp+28h] [ebp-20h] BYREF
  const char *p; // [esp+2Ch] [ebp-1Ch] BYREF
  int state; // [esp+30h] [ebp-18h]
  int ind_no; // [esp+34h] [ebp-14h]
  color_ext_type *ext; // [esp+38h] [ebp-10h]
  color_ext_type *e; // [esp+3Ch] [ebp-Ch]
  color_ext_type *e2; // [esp+40h] [ebp-8h]

  p = getenv("LS_COLORS");
  if ( p && *p )
  {
    ext = 0;
    memcpy(label, "??", sizeof(label));
    color_buf = xstrdup(p);
    buf = color_buf;
    state = 1;
    while ( state > 0 )
    {
      if ( state == 2 )
      {
        if ( *p )
        {
          label[1] = *p++;
          state = 3;
        }
        else
        {
          state = -1;
        }
      }
      else if ( state <= 2 )
      {
        v5 = *p;
        if ( v5 == 42 )
        {
          ext = (color_ext_type *)xmalloc(0x14u);
          ext->next = color_ext_list;
          color_ext_list = ext;
          ++p;
          ext->ext.string = buf;
          if ( get_funky_string(&buf, &p, 1, &ext->ext.len) )
            v6 = 4;
          else
            v6 = -1;
          state = v6;
        }
        else if ( v5 == 58 )
        {
          ++p;
        }
        else if ( *p )
        {
          label[0] = *p++;
          state = 2;
        }
        else
        {
          state = 0;
        }
      }
      else if ( state == 3 )
      {
        state = -1;
        if ( *p++ == 61 )
        {
          for ( ind_no = 0; indicator_name[ind_no]; ++ind_no )
          {
            if ( !strcmp(label, indicator_name[ind_no]) )
            {
              color_indicator[ind_no].string = buf;
              if ( get_funky_string(&buf, &p, 0, (size_t *)(8 * ind_no + 134627808)) )
                v7 = 1;
              else
                v7 = -1;
              state = v7;
              break;
            }
          }
          if ( state == -1 )
          {
            v1 = quotearg(label);
            v2 = gettext("unrecognized prefix: %s");
            error(0, 0, v2, v1);
          }
        }
      }
      else if ( state == 4 )
      {
        if ( *p++ == 61 )
        {
          ext->seq.string = buf;
          if ( get_funky_string(&buf, &p, 0, &ext->seq.len) )
            v8 = 1;
          else
            v8 = -1;
          state = v8;
        }
        else
        {
          state = -1;
        }
      }
    }
    if ( state < 0 )
    {
      v4 = gettext("unparsable value for LS_COLORS environment variable");
      error(0, 0, v4);
      free(color_buf);
      e = color_ext_list;
      while ( e )
      {
        e2 = e;
        e = e->next;
        free(e2);
      }
      print_with_color = 0;
    }
    if ( color_indicator[6].len == 6 && !strncmp(color_indicator[6].string, "target", 6u) )
      color_symlink_as_referent = 1;
  }
}
// 804BB71: conditional instruction was optimized away because of '%state.4==1'

//----- (0804BE91) --------------------------------------------------------
void __cdecl set_exit_status(bool serious)
{
  if ( serious )
  {
    exit_status = 2;
  }
  else if ( !exit_status )
  {
    exit_status = 1;
  }
}

//----- (0804BEC4) --------------------------------------------------------
void __cdecl file_failure(bool serious, const char *message, const char *file)
{
  char *v3; // ebx
  int v4; // edx

  v3 = quotearg_colon(file);
  v4 = *__errno_location();
  error(0, v4, message, v3);
  set_exit_status(serious);
}

//----- (0804BF12) --------------------------------------------------------
void __cdecl queue_directory(const char *name, const char *realname, bool command_line_arg)
{
  char *v3; // [esp+Ch] [ebp-1Ch]
  char *v4; // [esp+10h] [ebp-18h]
  pending *newa; // [esp+24h] [ebp-4h]

  newa = (pending *)xmalloc(0x10u);
  if ( realname )
    v3 = xstrdup(realname);
  else
    v3 = 0;
  newa->realname = v3;
  if ( name )
    v4 = xstrdup(name);
  else
    v4 = 0;
  newa->name = v4;
  newa->command_line_arg = command_line_arg;
  newa->next = pending_dirs;
  pending_dirs = newa;
}

//----- (0804BF98) --------------------------------------------------------
void __cdecl print_dir(const char *name, const char *realname, bool command_line_arg)
{
  char *v3; // eax
  char *v4; // edx
  char *v5; // ebx
  char *v6; // eax
  int v7; // edx
  char *v8; // ecx
  int v9; // edx
  dev_ino *v10; // ecx
  uintmax_t v11; // rax
  char *v12; // edx
  char *v13; // eax
  bool v14; // [esp+2Fh] [ebp-2E9h]
  char *v15; // [esp+38h] [ebp-2E0h]
  char buf[652]; // [esp+4Ch] [ebp-2CCh] BYREF
  DIR *dirp; // [esp+2D8h] [ebp-40h]
  dirent *next; // [esp+2DCh] [ebp-3Ch]
  uintmax_t total_blocks; // [esp+2E0h] [ebp-38h]
  int fd; // [esp+2E8h] [ebp-30h]
  dev_ino *di_0; // [esp+2ECh] [ebp-2Ch]
  obstack *__o; // [esp+2F0h] [ebp-28h]
  int __len; // [esp+2F4h] [ebp-24h]
  filetype type; // [esp+2F8h] [ebp-20h]
  obstack *__o_0; // [esp+2FCh] [ebp-1Ch]
  int __len_0; // [esp+300h] [ebp-18h]
  obstack *__o_1; // [esp+304h] [ebp-14h]
  int __len_1; // [esp+308h] [ebp-10h]
  const char *p; // [esp+30Ch] [ebp-Ch]

  total_blocks = 0LL;
  *__errno_location() = 0;
  dirp = opendir(name);
  if ( !dirp )
  {
    v3 = gettext("cannot open directory %s");
    file_failure(command_line_arg, v3, name);
    return;
  }
  if ( active_dir_set )
  {
    fd = dirfd(dirp);
    if ( fd < 0 )
      v14 = stat64((int)name, (int)buf) < 0;
    else
      v14 = fstat64(fd, (int)buf) < 0;
    if ( v14 )
    {
      v4 = gettext("cannot determine device and inode of %s");
      file_failure(command_line_arg, v4, name);
      closedir(dirp);
      return;
    }
    if ( visit_dir(*(dev_t *)buf, *(ino_t *)&buf[88]) )
    {
      v5 = quotearg_colon(name);
      v6 = gettext("%s: not listing already-listed directory");
      error(0, 0, v6, v5);
      closedir(dirp);
      return;
    }
    __o = &dev_ino_obstack;
    __len = 16;
    if ( dev_ino_obstack.chunk_limit - dev_ino_obstack.next_free < 16 )
      _obstack_newchunk(__o, __len);
    __o->next_free += __len;
    di_0 = (dev_ino *)(dev_ino_obstack.next_free - 16);
    v7 = *(_DWORD *)&buf[4];
    v8 = dev_ino_obstack.next_free - 16;
    *((_DWORD *)v8 + 2) = *(_DWORD *)buf;
    *((_DWORD *)v8 + 3) = v7;
    v9 = *(_DWORD *)&buf[92];
    v10 = di_0;
    LODWORD(di_0->st_ino) = *(_DWORD *)&buf[88];
    HIDWORD(v10->st_ino) = v9;
  }
  clear_files();
  do
  {
    while ( 1 )
    {
      *__errno_location() = 0;
      next = (dirent *)readdir64(dirp);
      if ( !next )
        break;
      if ( !file_ignored(next->d_name) )
      {
        type = unknown;
        switch ( next->d_type )
        {
          case 1u:
            type = fifo;
            break;
          case 2u:
            type = chardev;
            break;
          case 4u:
            type = directory;
            break;
          case 6u:
            type = blockdev;
            break;
          case 8u:
            type = normal;
            break;
          case 0xAu:
            type = symbolic_link;
            break;
          case 0xCu:
            type = sock;
            break;
          case 0xEu:
            type = whiteout;
            break;
          default:
            break;
        }
        v11 = gobble_file(next->d_name, type, next->d_ino, 0, name);
        total_blocks += v11;
      }
    }
    if ( !*__errno_location() )
      break;
    v12 = gettext("reading directory %s");
    file_failure(command_line_arg, v12, name);
  }
  while ( *__errno_location() == 75 );
  if ( closedir(dirp) )
  {
    v13 = gettext("closing directory %s");
    file_failure(command_line_arg, v13, name);
  }
  sort_files();
  if ( recursive )
    extract_dirs_from_files(name, command_line_arg);
  if ( recursive || print_dir_name )
  {
    if ( !first_7139 )
    {
      putchar_unlocked(10);
      ++dired_pos;
    }
    first_7139 = 0;
    if ( dired )
    {
      fwrite_unlocked("  ", 1u, 2u, stdout);
      dired_pos += 2;
    }
    if ( dired )
    {
      __o_0 = &subdired_obstack;
      __len_0 = 4;
      if ( subdired_obstack.next_free + 4 > subdired_obstack.chunk_limit )
        _obstack_newchunk(__o_0, __len_0);
      memcpy(__o_0->next_free, &dired_pos, __len_0);
      __o_0->next_free += __len_0;
    }
    if ( realname )
      v15 = (char *)realname;
    else
      v15 = (char *)name;
    dired_pos += quote_name(stdout, v15, dirname_quoting_options, 0);
    if ( dired )
    {
      __o_1 = &subdired_obstack;
      __len_1 = 4;
      if ( subdired_obstack.next_free + 4 > subdired_obstack.chunk_limit )
        _obstack_newchunk(__o_1, __len_1);
      memcpy(__o_1->next_free, &dired_pos, __len_1);
      __o_1->next_free += __len_1;
    }
    fwrite_unlocked(":\n", 1u, 2u, stdout);
    dired_pos += 2;
  }
  if ( format_0 == long_format || print_block_size )
  {
    if ( dired )
    {
      fwrite_unlocked("  ", 1u, 2u, stdout);
      dired_pos += 2;
    }
    p = gettext("total");
    fputs_unlocked(p, stdout);
    dired_pos += strlen(p);
    putchar_unlocked(32);
    ++dired_pos;
    p = human_readable(total_blocks, buf, human_output_opts, 0x200uLL, output_block_size);
    fputs_unlocked(p, stdout);
    dired_pos += strlen(p);
    putchar_unlocked(10);
    ++dired_pos;
  }
  if ( cwd_n_used )
    print_current_files();
}
// 804955C: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 804982C: using guessed type int __cdecl readdir64(_DWORD);

//----- (0804C66F) --------------------------------------------------------
void __cdecl add_ignore_pattern(const char *pattern)
{
  ignore_pattern *ignore; // [esp+14h] [ebp-4h]

  ignore = (ignore_pattern *)xmalloc(8u);
  ignore->pattern = pattern;
  ignore->next = ignore_patterns;
  ignore_patterns = ignore;
}

//----- (0804C6A2) --------------------------------------------------------
bool __cdecl patterns_match(const ignore_pattern *patterns, const char *file)
{
  while ( patterns )
  {
    if ( !fnmatch(patterns->pattern, file, 4) )
      return 1;
    patterns = patterns->next;
  }
  return 0;
}

//----- (0804C6EF) --------------------------------------------------------
bool __cdecl file_ignored(const char *name)
{
  bool v2; // [esp+10h] [ebp-8h]
  int v3; // [esp+14h] [ebp-4h]

  v2 = ignore_mode != IGNORE_MINIMAL
    && *name == 46
    && (ignore_mode == IGNORE_DEFAULT || (name[1] != 46 ? (v3 = 1) : (v3 = 2), !name[v3]))
    || ignore_mode == IGNORE_DEFAULT && patterns_match(hide_patterns, name)
    || patterns_match(ignore_patterns, name);
  return v2;
}

//----- (0804C78B) --------------------------------------------------------
uintmax_t __cdecl unsigned_file_size(off_t size)
{
  return size;
}

//----- (0804C7A5) --------------------------------------------------------
void clear_files()
{
  size_t i; // [esp+10h] [ebp-8h]
  fileinfo *f; // [esp+14h] [ebp-4h]

  for ( i = 0; i < cwd_n_used; ++i )
  {
    f = (fileinfo *)sorted_file[i];
    free(f->name);
    free(f->linkname);
    if ( f->scontext != UNKNOWN_SECURITY_CONTEXT )
      freecon(f->scontext);
  }
  cwd_n_used = 0;
  any_has_acl = 0;
  inode_number_width = 0;
  block_size_width = 0;
  nlink_width = 0;
  owner_width = 0;
  group_width = 0;
  author_width = 0;
  scontext_width = 0;
  major_device_number_width = 0;
  minor_device_number_width = 0;
  file_size_width = 0;
}

//----- (0804C883) --------------------------------------------------------
void __cdecl freecon(char *con)
{
  ;
}

//----- (0804C888) --------------------------------------------------------
uintmax_t __cdecl gobble_file(const char *name, filetype type, ino_t inode, bool command_line_arg, const char *dirname)
{
  fileinfo *v5; // ecx
  int v6; // edx
  size_t v7; // ebx
  void *v8; // esp
  char *v9; // eax
  char *v10; // eax
  char *v11; // ebx
  int *v12; // eax
  int v13; // edx
  char *v14; // eax
  char *v15; // eax
  unsigned int v16; // eax
  char *v17; // eax
  unsigned int v18; // eax
  char *v19; // eax
  char *v20; // eax
  char *v21; // eax
  char *v22; // eax
  char *v24; // [esp+2Ch] [ebp-35Ch] BYREF
  unsigned int v25; // [esp+30h] [ebp-358h]
  bool v26; // [esp+37h] [ebp-351h]
  unsigned int v28; // [esp+40h] [ebp-348h]
  bool command_line_arga; // [esp+44h] [ebp-344h]
  ino_t inodea; // [esp+48h] [ebp-340h]
  char buf[652]; // [esp+5Ch] [ebp-32Ch] BYREF
  char buf_1[21]; // [esp+2E9h] [ebp-9Fh] BYREF
  char buf_0[21]; // [esp+2FEh] [ebp-8Ah] BYREF
  char b[21]; // [esp+313h] [ebp-75h] BYREF
  uintmax_t blocks; // [esp+328h] [ebp-60h]
  fileinfo *f; // [esp+334h] [ebp-54h]
  char *absolute_name; // [esp+338h] [ebp-50h]
  bool do_deref; // [esp+33Fh] [ebp-49h]
  int err; // [esp+340h] [ebp-48h]
  bool need_lstat; // [esp+346h] [ebp-42h]
  bool have_acl; // [esp+347h] [ebp-41h]
  int attr_len; // [esp+348h] [ebp-40h]
  int n; // [esp+34Ch] [ebp-3Ch]
  char *linkname; // [esp+350h] [ebp-38h]
  int len; // [esp+354h] [ebp-34h]
  int len_0; // [esp+358h] [ebp-30h]
  int len_1; // [esp+35Ch] [ebp-2Ch]
  int len_2; // [esp+360h] [ebp-28h]
  int len_3; // [esp+364h] [ebp-24h]
  int b_len; // [esp+368h] [ebp-20h]
  int len_4; // [esp+36Ch] [ebp-1Ch]
  uintmax_t size; // [esp+370h] [ebp-18h]
  int len_5; // [esp+378h] [ebp-10h]
  int len_6; // [esp+37Ch] [ebp-Ch]

  inodea = inode;
  command_line_arga = command_line_arg;
  blocks = 0LL;
  if ( command_line_arg && inodea )
    __assert_fail("! command_line_arg || inode == NOT_AN_INODE_NUMBER", "ls.c", 0x9F7u, "gobble_file");
  if ( cwd_n_used == cwd_n_alloc )
  {
    cwd_file = (fileinfo *)xnrealloc(cwd_file, cwd_n_alloc, 0xF0u);
    cwd_n_alloc *= 2;
  }
  f = &cwd_file[cwd_n_used];
  memset(f, 0, sizeof(fileinfo));
  v5 = f;
  v6 = HIDWORD(inodea);
  LODWORD(f->stat.st_ino) = inodea;
  HIDWORD(v5->stat.st_ino) = v6;
  f->filetype = type;
  if ( !command_line_arga
    && !format_needs_stat
    && (type != directory || !print_with_color)
    && (!print_inode && !format_needs_type
     || type != symbolic_link && type
     || dereference != DEREF_ALWAYS
     && (!command_line_arga || dereference == DEREF_NEVER)
     && !color_symlink_as_referent
     && !check_symlink_color)
    && (!print_inode || inodea)
    && (!format_needs_type
     || type && (type != normal || indicator_style_0 != classify && (!print_with_color || !is_colored(C_EXEC)))) )
  {
    goto LABEL_114;
  }
  if ( *name != 47 && *dirname )
  {
    v7 = strlen(name);
    v8 = alloca(16 * ((v7 + strlen(dirname) + 32) >> 4));
    v24 = (char *)(16 * (((unsigned int)&v24 + 3) >> 4));
    absolute_name = v24;
    attach(v24, dirname, name);
  }
  else
  {
    absolute_name = (char *)name;
  }
  v25 = dereference;
  if ( (unsigned int)dereference < DEREF_COMMAND_LINE_ARGUMENTS )
    goto LABEL_41;
  if ( v25 <= 4 )
  {
    if ( command_line_arga )
    {
      err = stat64((int)absolute_name, (int)&f->stat);
      do_deref = 1;
      if ( dereference == DEREF_COMMAND_LINE_ARGUMENTS )
        goto LABEL_42;
      v26 = err >= 0 ? (f->stat.st_mode & 0xF000) != 0x4000 : *__errno_location() == 2;
      need_lstat = v26;
      if ( !v26 )
        goto LABEL_42;
    }
    goto LABEL_41;
  }
  if ( v25 != 5 )
  {
LABEL_41:
    err = lstat64((int)absolute_name, (int)&f->stat);
    do_deref = 0;
    goto LABEL_42;
  }
  err = stat64((int)absolute_name, (int)&f->stat);
  do_deref = 1;
LABEL_42:
  if ( err )
  {
    v9 = gettext("cannot access %s");
    file_failure(command_line_arga, v9, absolute_name);
    if ( !command_line_arga )
    {
      v10 = xstrdup(name);
      f->name = v10;
      ++cwd_n_used;
    }
    return 0LL;
  }
  f->stat_ok = 1;
  if ( format_0 == long_format || print_scontext )
  {
    have_acl = 0;
    if ( do_deref )
      v28 = getfilecon(absolute_name, &f->scontext);
    else
      v28 = lgetfilecon(absolute_name, &f->scontext);
    attr_len = v28;
    err = v28 >> 31;
    if ( (v28 & 0x80000000) != 0 )
    {
      f->scontext = UNKNOWN_SECURITY_CONTEXT;
      if ( *__errno_location() == 95 || *__errno_location() == 61 )
        err = 0;
    }
    else
    {
      have_acl = strcmp("unlabeled", f->scontext) != 0;
    }
    if ( !err && !have_acl && format_0 == long_format )
    {
      n = file_has_acl(absolute_name, &f->stat);
      err = (unsigned int)n >> 31;
      have_acl = n > 0;
    }
    f->have_acl = have_acl;
    any_has_acl = any_has_acl || have_acl;
    if ( err )
    {
      v11 = quotearg_colon(absolute_name);
      v12 = __errno_location();
      error(0, *v12, "%s", v11);
    }
  }
  if ( (f->stat.st_mode & 0xF000) == 40960 && (format_0 == long_format || check_symlink_color) )
  {
    get_link_name(absolute_name, f, command_line_arga);
    linkname = make_link_name(absolute_name, f->linkname);
    if ( linkname
      && ((unsigned int)indicator_style_0 > slash || check_symlink_color)
      && !stat64((int)linkname, (int)buf) )
    {
      f->linkok = 1;
      if ( !command_line_arga || format_0 == long_format || (*(_WORD *)&buf[16] & 0xF000) != 0x4000 )
        f->linkmode = *(_DWORD *)&buf[16];
    }
    free(linkname);
  }
  if ( (f->stat.st_mode & 0xF000) == 40960 && !check_symlink_color )
    f->linkok = 1;
  if ( (f->stat.st_mode & 0xF000) == 40960 )
  {
    f->filetype = symbolic_link;
  }
  else if ( (f->stat.st_mode & 0xF000) == 0x4000 )
  {
    if ( command_line_arga && !immediate_dirs )
      f->filetype = arg_directory;
    else
      f->filetype = directory;
  }
  else
  {
    f->filetype = normal;
  }
  v13 = HIDWORD(f->stat.st_blocks);
  LODWORD(blocks) = f->stat.st_blocks;
  HIDWORD(blocks) = v13;
  if ( format_0 == long_format || print_block_size )
  {
    v14 = human_readable(blocks, buf, human_output_opts, 0x200uLL, output_block_size);
    len = gnu_mbswidth(v14, 0);
    if ( block_size_width < len )
      block_size_width = len;
  }
  if ( format_0 == long_format )
  {
    if ( print_owner )
    {
      len_0 = format_user_width(f->stat.st_uid);
      if ( owner_width < len_0 )
        owner_width = len_0;
    }
    if ( print_group )
    {
      len_1 = format_group_width(f->stat.st_gid);
      if ( group_width < len_1 )
        group_width = len_1;
    }
    if ( print_author )
    {
      len_2 = format_user_width(f->stat.st_uid);
      if ( author_width < len_2 )
        author_width = len_2;
    }
  }
  if ( print_scontext )
  {
    len_3 = strlen(f->scontext);
    if ( scontext_width < len_3 )
      scontext_width = len_3;
  }
  if ( format_0 == long_format )
  {
    v15 = umaxtostr(f->stat.st_nlink, b);
    b_len = strlen(v15);
    if ( nlink_width < b_len )
      nlink_width = b_len;
    if ( (f->stat.st_mode & 0xF000) == 0x2000 || (f->stat.st_mode & 0xF000) == 24576 )
    {
      v16 = gnu_dev_major(f->stat.st_rdev);
      v17 = umaxtostr(v16, buf_0);
      len_4 = strlen(v17);
      if ( major_device_number_width < len_4 )
        major_device_number_width = len_4;
      v18 = gnu_dev_minor(f->stat.st_rdev);
      v19 = umaxtostr(v18, buf_0);
      len_4 = strlen(v19);
      if ( minor_device_number_width < len_4 )
        minor_device_number_width = len_4;
      len_4 = major_device_number_width + 2 + minor_device_number_width;
      if ( file_size_width < len_4 )
        file_size_width = len_4;
    }
    else
    {
      size = unsigned_file_size(f->stat.st_size);
      v20 = human_readable(size, buf, human_output_opts, 1uLL, file_output_block_size);
      len_5 = gnu_mbswidth(v20, 0);
      if ( file_size_width < len_5 )
        file_size_width = len_5;
    }
  }
LABEL_114:
  if ( print_inode )
  {
    v21 = umaxtostr(f->stat.st_ino, buf_1);
    len_6 = strlen(v21);
    if ( inode_number_width < len_6 )
      inode_number_width = len_6;
  }
  v22 = xstrdup(name);
  f->name = v22;
  ++cwd_n_used;
  return blocks;
}
// 804CA67: conditional instruction was optimized away because of '%command_line_arg.1==0'

//----- (0804D30D) --------------------------------------------------------
int __cdecl getfilecon(const char *s, char **con)
{
  *__errno_location() = 95;
  return -1;
}

//----- (0804D325) --------------------------------------------------------
int __cdecl lgetfilecon(const char *s, char **con)
{
  *__errno_location() = 95;
  return -1;
}

//----- (0804D33D) --------------------------------------------------------
bool __cdecl is_directory(const fileinfo *f)
{
  return f->filetype == directory || f->filetype == arg_directory;
}

//----- (0804D36F) --------------------------------------------------------
void __cdecl get_link_name(const char *filename, fileinfo *f, bool command_line_arg)
{
  char *v3; // eax

  f->linkname = areadlink_with_size(filename, f->stat.st_size);
  if ( !f->linkname )
  {
    v3 = gettext("cannot read symbolic link %s");
    file_failure(command_line_arg, v3, filename);
  }
}

//----- (0804D3CA) --------------------------------------------------------
char *__cdecl make_link_name(const char *name, const char *linkname)
{
  size_t v2; // eax
  char *linkbuf; // [esp+20h] [ebp-8h]
  char *linkbufa; // [esp+20h] [ebp-8h]
  size_t bufsiz; // [esp+24h] [ebp-4h]

  if ( !linkname )
    return 0;
  if ( *linkname == 47 )
    return xstrdup(linkname);
  linkbuf = strrchr(name, 47);
  if ( !linkbuf )
    return xstrdup(linkname);
  bufsiz = linkbuf - name + 1;
  v2 = strlen(linkname);
  linkbufa = (char *)xmalloc(bufsiz + v2 + 1);
  strncpy(linkbufa, name, bufsiz);
  strcpy(&linkbufa[bufsiz], linkname);
  return linkbufa;
}

//----- (0804D495) --------------------------------------------------------
bool __cdecl basename_is_dot_or_dotdot(const char *name)
{
  char *base; // [esp+14h] [ebp-4h]

  base = last_component(name);
  return dot_or_dotdot(base);
}

//----- (0804D4B6) --------------------------------------------------------
bool __cdecl dot_or_dotdot(const char *file_name)
{
  int v2; // [esp+0h] [ebp-1Ch]
  char sep; // [esp+1Bh] [ebp-1h]

  if ( *file_name != 46 )
    return 0;
  if ( file_name[1] == 46 )
    v2 = 2;
  else
    v2 = 1;
  sep = file_name[v2];
  return !sep || sep == 47;
}

//----- (0804D51E) --------------------------------------------------------
void __cdecl extract_dirs_from_files(const char *dirname, bool command_line_arg)
{
  size_t i; // [esp+20h] [ebp-18h]
  size_t ia; // [esp+20h] [ebp-18h]
  size_t j; // [esp+24h] [ebp-14h]
  fileinfo *f; // [esp+2Ch] [ebp-Ch]
  char *name; // [esp+30h] [ebp-8h]
  fileinfo *f_0; // [esp+34h] [ebp-4h]

  if ( dirname && active_dir_set )
    queue_directory(0, dirname, 0);
  i = cwd_n_used;
  while ( i-- != 0 )
  {
    f = (fileinfo *)sorted_file[i];
    if ( is_directory(f) && (!dirname || !basename_is_dot_or_dotdot(f->name)) )
    {
      if ( dirname && *f->name != 47 )
      {
        name = file_name_concat(dirname, f->name, 0);
        queue_directory(name, f->linkname, command_line_arg);
        free(name);
      }
      else
      {
        queue_directory(f->name, f->linkname, command_line_arg);
      }
      if ( f->filetype == arg_directory )
        free(f->name);
    }
  }
  ia = 0;
  j = 0;
  while ( ia < cwd_n_used )
  {
    f_0 = (fileinfo *)sorted_file[ia];
    sorted_file[j] = f_0;
    j += f_0->filetype != arg_directory;
    ++ia;
  }
  cwd_n_used = j;
}

//----- (0804D6BB) --------------------------------------------------------
int __cdecl xstrcoll(const char *a, const char *b)
{
  const char *v2; // edi
  const char *v3; // ebx
  char *v4; // esi
  int *v5; // eax
  int diff; // [esp+28h] [ebp-10h]

  *__errno_location() = 0;
  diff = strcoll(a, b);
  if ( *__errno_location() )
  {
    v2 = _ZNK6idVec58ToStringEi(1, b);
    v3 = _ZNK6idVec58ToStringEi(0, a);
    v4 = gettext("cannot compare file names %s and %s");
    v5 = __errno_location();
    error(0, *v5, v4, v3, v2);
    set_exit_status(0);
    longjmp(failed_strcoll, 1);
  }
  return diff;
}

//----- (0804D775) --------------------------------------------------------
int __cdecl xstrcoll_ctime(V a, V b)
{
  return cmp_ctime((const fileinfo *)a, (const fileinfo *)b, xstrcoll);
}

//----- (0804D797) --------------------------------------------------------
int __cdecl cmp_ctime(const fileinfo *a, const fileinfo *b, int (*cmp)(const char *, const char *))
{
  int v4; // [esp+14h] [ebp-24h]
  timespec v5; // [esp+24h] [ebp-14h] BYREF
  timespec v6; // [esp+2Ch] [ebp-Ch] BYREF
  int diff; // [esp+34h] [ebp-4h]

  get_stat_ctime(&v5, &a->stat);
  get_stat_ctime(&v6, &b->stat);
  diff = timespec_cmp(v6, v5);
  if ( diff )
    v4 = diff;
  else
    v4 = cmp(a->name, b->name);
  return v4;
}

//----- (0804D81C) --------------------------------------------------------
timespec *get_stat_ctime(timespec *retstr, const stat *st)
{
  int v2; // edx

  v2 = st->st_ctim.tv_nsec;
  retstr->tv_sec = st->st_ctim.tv_sec;
  retstr->tv_nsec = v2;
  return retstr;
}
// 804D81C: inconsistent function type and number of purged bytes

//----- (0804D836) --------------------------------------------------------
int __cdecl timespec_cmp(timespec a, timespec b)
{
  int v4; // [esp+4h] [ebp-4h]

  if ( a.tv_sec < b.tv_sec )
    return -1;
  if ( a.tv_sec > b.tv_sec )
    v4 = 1;
  else
    v4 = a.tv_nsec - b.tv_nsec;
  return v4;
}

//----- (0804D87A) --------------------------------------------------------
int __cdecl strcmp_ctime(V a, V b)
{
  return cmp_ctime((const fileinfo *)a, (const fileinfo *)b, strcmp);
}

//----- (0804D89C) --------------------------------------------------------
int __cdecl rev_xstrcoll_ctime(V a, V b)
{
  return cmp_ctime((const fileinfo *)b, (const fileinfo *)a, xstrcoll);
}

//----- (0804D8BE) --------------------------------------------------------
int __cdecl rev_strcmp_ctime(V a, V b)
{
  return cmp_ctime((const fileinfo *)b, (const fileinfo *)a, strcmp);
}

//----- (0804D8E0) --------------------------------------------------------
int __cdecl xstrcoll_df_ctime(V a, V b)
{
  bool a_is_dir; // [esp+26h] [ebp-2h]
  bool b_is_dir; // [esp+27h] [ebp-1h]

  a_is_dir = is_directory((const fileinfo *)a);
  b_is_dir = is_directory((const fileinfo *)b);
  if ( a_is_dir && !b_is_dir )
    return -1;
  if ( !a_is_dir && b_is_dir )
    return 1;
  return cmp_ctime((const fileinfo *)a, (const fileinfo *)b, xstrcoll);
}

//----- (0804D958) --------------------------------------------------------
int __cdecl strcmp_df_ctime(V a, V b)
{
  bool a_is_dir; // [esp+26h] [ebp-2h]
  bool b_is_dir; // [esp+27h] [ebp-1h]

  a_is_dir = is_directory((const fileinfo *)a);
  b_is_dir = is_directory((const fileinfo *)b);
  if ( a_is_dir && !b_is_dir )
    return -1;
  if ( !a_is_dir && b_is_dir )
    return 1;
  return cmp_ctime((const fileinfo *)a, (const fileinfo *)b, strcmp);
}

//----- (0804D9D0) --------------------------------------------------------
int __cdecl rev_xstrcoll_df_ctime(V a, V b)
{
  bool a_is_dir; // [esp+26h] [ebp-2h]
  bool b_is_dir; // [esp+27h] [ebp-1h]

  a_is_dir = is_directory((const fileinfo *)a);
  b_is_dir = is_directory((const fileinfo *)b);
  if ( a_is_dir && !b_is_dir )
    return -1;
  if ( !a_is_dir && b_is_dir )
    return 1;
  return cmp_ctime((const fileinfo *)b, (const fileinfo *)a, xstrcoll);
}

//----- (0804DA48) --------------------------------------------------------
int __cdecl rev_strcmp_df_ctime(V a, V b)
{
  bool a_is_dir; // [esp+26h] [ebp-2h]
  bool b_is_dir; // [esp+27h] [ebp-1h]

  a_is_dir = is_directory((const fileinfo *)a);
  b_is_dir = is_directory((const fileinfo *)b);
  if ( a_is_dir && !b_is_dir )
    return -1;
  if ( !a_is_dir && b_is_dir )
    return 1;
  return cmp_ctime((const fileinfo *)b, (const fileinfo *)a, strcmp);
}

//----- (0804DAC0) --------------------------------------------------------
int __cdecl xstrcoll_mtime(V a, V b)
{
  return cmp_mtime((const fileinfo *)a, (const fileinfo *)b, xstrcoll);
}

//----- (0804DAE2) --------------------------------------------------------
int __cdecl cmp_mtime(const fileinfo *a, const fileinfo *b, int (*cmp)(const char *, const char *))
{
  int v4; // [esp+14h] [ebp-24h]
  timespec v5; // [esp+24h] [ebp-14h] BYREF
  timespec v6; // [esp+2Ch] [ebp-Ch] BYREF
  int diff; // [esp+34h] [ebp-4h]

  get_stat_mtime(&v5, &a->stat);
  get_stat_mtime(&v6, &b->stat);
  diff = timespec_cmp(v6, v5);
  if ( diff )
    v4 = diff;
  else
    v4 = cmp(a->name, b->name);
  return v4;
}

//----- (0804DB67) --------------------------------------------------------
timespec *get_stat_mtime(timespec *retstr, const stat *st)
{
  int v2; // edx

  v2 = st->st_mtim.tv_nsec;
  retstr->tv_sec = st->st_mtim.tv_sec;
  retstr->tv_nsec = v2;
  return retstr;
}
// 804DB67: inconsistent function type and number of purged bytes

//----- (0804DB81) --------------------------------------------------------
int __cdecl strcmp_mtime(V a, V b)
{
  return cmp_mtime((const fileinfo *)a, (const fileinfo *)b, strcmp);
}

//----- (0804DBA3) --------------------------------------------------------
int __cdecl rev_xstrcoll_mtime(V a, V b)
{
  return cmp_mtime((const fileinfo *)b, (const fileinfo *)a, xstrcoll);
}

//----- (0804DBC5) --------------------------------------------------------
int __cdecl rev_strcmp_mtime(V a, V b)
{
  return cmp_mtime((const fileinfo *)b, (const fileinfo *)a, strcmp);
}

//----- (0804DBE7) --------------------------------------------------------
int __cdecl xstrcoll_df_mtime(V a, V b)
{
  bool a_is_dir; // [esp+26h] [ebp-2h]
  bool b_is_dir; // [esp+27h] [ebp-1h]

  a_is_dir = is_directory((const fileinfo *)a);
  b_is_dir = is_directory((const fileinfo *)b);
  if ( a_is_dir && !b_is_dir )
    return -1;
  if ( !a_is_dir && b_is_dir )
    return 1;
  return cmp_mtime((const fileinfo *)a, (const fileinfo *)b, xstrcoll);
}

//----- (0804DC5F) --------------------------------------------------------
int __cdecl strcmp_df_mtime(V a, V b)
{
  bool a_is_dir; // [esp+26h] [ebp-2h]
  bool b_is_dir; // [esp+27h] [ebp-1h]

  a_is_dir = is_directory((const fileinfo *)a);
  b_is_dir = is_directory((const fileinfo *)b);
  if ( a_is_dir && !b_is_dir )
    return -1;
  if ( !a_is_dir && b_is_dir )
    return 1;
  return cmp_mtime((const fileinfo *)a, (const fileinfo *)b, strcmp);
}

//----- (0804DCD7) --------------------------------------------------------
int __cdecl rev_xstrcoll_df_mtime(V a, V b)
{
  bool a_is_dir; // [esp+26h] [ebp-2h]
  bool b_is_dir; // [esp+27h] [ebp-1h]

  a_is_dir = is_directory((const fileinfo *)a);
  b_is_dir = is_directory((const fileinfo *)b);
  if ( a_is_dir && !b_is_dir )
    return -1;
  if ( !a_is_dir && b_is_dir )
    return 1;
  return cmp_mtime((const fileinfo *)b, (const fileinfo *)a, xstrcoll);
}

//----- (0804DD4F) --------------------------------------------------------
int __cdecl rev_strcmp_df_mtime(V a, V b)
{
  bool a_is_dir; // [esp+26h] [ebp-2h]
  bool b_is_dir; // [esp+27h] [ebp-1h]

  a_is_dir = is_directory((const fileinfo *)a);
  b_is_dir = is_directory((const fileinfo *)b);
  if ( a_is_dir && !b_is_dir )
    return -1;
  if ( !a_is_dir && b_is_dir )
    return 1;
  return cmp_mtime((const fileinfo *)b, (const fileinfo *)a, strcmp);
}

//----- (0804DDC7) --------------------------------------------------------
int __cdecl xstrcoll_atime(V a, V b)
{
  return cmp_atime((const fileinfo *)a, (const fileinfo *)b, xstrcoll);
}

//----- (0804DDE9) --------------------------------------------------------
int __cdecl cmp_atime(const fileinfo *a, const fileinfo *b, int (*cmp)(const char *, const char *))
{
  int v4; // [esp+14h] [ebp-24h]
  timespec v5; // [esp+24h] [ebp-14h] BYREF
  timespec v6; // [esp+2Ch] [ebp-Ch] BYREF
  int diff; // [esp+34h] [ebp-4h]

  get_stat_atime(&v5, &a->stat);
  get_stat_atime(&v6, &b->stat);
  diff = timespec_cmp(v6, v5);
  if ( diff )
    v4 = diff;
  else
    v4 = cmp(a->name, b->name);
  return v4;
}

//----- (0804DE6E) --------------------------------------------------------
timespec *get_stat_atime(timespec *retstr, const stat *st)
{
  int v2; // edx

  v2 = st->st_atim.tv_nsec;
  retstr->tv_sec = st->st_atim.tv_sec;
  retstr->tv_nsec = v2;
  return retstr;
}
// 804DE6E: inconsistent function type and number of purged bytes

//----- (0804DE88) --------------------------------------------------------
int __cdecl strcmp_atime(V a, V b)
{
  return cmp_atime((const fileinfo *)a, (const fileinfo *)b, strcmp);
}

//----- (0804DEAA) --------------------------------------------------------
int __cdecl rev_xstrcoll_atime(V a, V b)
{
  return cmp_atime((const fileinfo *)b, (const fileinfo *)a, xstrcoll);
}

//----- (0804DECC) --------------------------------------------------------
int __cdecl rev_strcmp_atime(V a, V b)
{
  return cmp_atime((const fileinfo *)b, (const fileinfo *)a, strcmp);
}

//----- (0804DEEE) --------------------------------------------------------
int __cdecl xstrcoll_df_atime(V a, V b)
{
  bool a_is_dir; // [esp+26h] [ebp-2h]
  bool b_is_dir; // [esp+27h] [ebp-1h]

  a_is_dir = is_directory((const fileinfo *)a);
  b_is_dir = is_directory((const fileinfo *)b);
  if ( a_is_dir && !b_is_dir )
    return -1;
  if ( !a_is_dir && b_is_dir )
    return 1;
  return cmp_atime((const fileinfo *)a, (const fileinfo *)b, xstrcoll);
}

//----- (0804DF66) --------------------------------------------------------
int __cdecl strcmp_df_atime(V a, V b)
{
  bool a_is_dir; // [esp+26h] [ebp-2h]
  bool b_is_dir; // [esp+27h] [ebp-1h]

  a_is_dir = is_directory((const fileinfo *)a);
  b_is_dir = is_directory((const fileinfo *)b);
  if ( a_is_dir && !b_is_dir )
    return -1;
  if ( !a_is_dir && b_is_dir )
    return 1;
  return cmp_atime((const fileinfo *)a, (const fileinfo *)b, strcmp);
}

//----- (0804DFDE) --------------------------------------------------------
int __cdecl rev_xstrcoll_df_atime(V a, V b)
{
  bool a_is_dir; // [esp+26h] [ebp-2h]
  bool b_is_dir; // [esp+27h] [ebp-1h]

  a_is_dir = is_directory((const fileinfo *)a);
  b_is_dir = is_directory((const fileinfo *)b);
  if ( a_is_dir && !b_is_dir )
    return -1;
  if ( !a_is_dir && b_is_dir )
    return 1;
  return cmp_atime((const fileinfo *)b, (const fileinfo *)a, xstrcoll);
}

//----- (0804E056) --------------------------------------------------------
int __cdecl rev_strcmp_df_atime(V a, V b)
{
  bool a_is_dir; // [esp+26h] [ebp-2h]
  bool b_is_dir; // [esp+27h] [ebp-1h]

  a_is_dir = is_directory((const fileinfo *)a);
  b_is_dir = is_directory((const fileinfo *)b);
  if ( a_is_dir && !b_is_dir )
    return -1;
  if ( !a_is_dir && b_is_dir )
    return 1;
  return cmp_atime((const fileinfo *)b, (const fileinfo *)a, strcmp);
}

//----- (0804E0CE) --------------------------------------------------------
int __cdecl xstrcoll_size(V a, V b)
{
  return cmp_size((const fileinfo *)a, (const fileinfo *)b, xstrcoll);
}

//----- (0804E0F0) --------------------------------------------------------
int __cdecl cmp_size(const fileinfo *a, const fileinfo *b, int (*cmp)(const char *, const char *))
{
  int v4; // [esp+Ch] [ebp-3Ch]
  int v5; // [esp+34h] [ebp-14h]

  if ( b->stat.st_size < a->stat.st_size )
    v4 = -1;
  else
    v4 = b->stat.st_size > a->stat.st_size;
  if ( v4 )
    v5 = v4;
  else
    v5 = cmp(a->name, b->name);
  return v5;
}

//----- (0804E1AB) --------------------------------------------------------
int __cdecl strcmp_size(V a, V b)
{
  return cmp_size((const fileinfo *)a, (const fileinfo *)b, strcmp);
}

//----- (0804E1CD) --------------------------------------------------------
int __cdecl rev_xstrcoll_size(V a, V b)
{
  return cmp_size((const fileinfo *)b, (const fileinfo *)a, xstrcoll);
}

//----- (0804E1EF) --------------------------------------------------------
int __cdecl rev_strcmp_size(V a, V b)
{
  return cmp_size((const fileinfo *)b, (const fileinfo *)a, strcmp);
}

//----- (0804E211) --------------------------------------------------------
int __cdecl xstrcoll_df_size(V a, V b)
{
  bool a_is_dir; // [esp+26h] [ebp-2h]
  bool b_is_dir; // [esp+27h] [ebp-1h]

  a_is_dir = is_directory((const fileinfo *)a);
  b_is_dir = is_directory((const fileinfo *)b);
  if ( a_is_dir && !b_is_dir )
    return -1;
  if ( !a_is_dir && b_is_dir )
    return 1;
  return cmp_size((const fileinfo *)a, (const fileinfo *)b, xstrcoll);
}

//----- (0804E289) --------------------------------------------------------
int __cdecl strcmp_df_size(V a, V b)
{
  bool a_is_dir; // [esp+26h] [ebp-2h]
  bool b_is_dir; // [esp+27h] [ebp-1h]

  a_is_dir = is_directory((const fileinfo *)a);
  b_is_dir = is_directory((const fileinfo *)b);
  if ( a_is_dir && !b_is_dir )
    return -1;
  if ( !a_is_dir && b_is_dir )
    return 1;
  return cmp_size((const fileinfo *)a, (const fileinfo *)b, strcmp);
}

//----- (0804E301) --------------------------------------------------------
int __cdecl rev_xstrcoll_df_size(V a, V b)
{
  bool a_is_dir; // [esp+26h] [ebp-2h]
  bool b_is_dir; // [esp+27h] [ebp-1h]

  a_is_dir = is_directory((const fileinfo *)a);
  b_is_dir = is_directory((const fileinfo *)b);
  if ( a_is_dir && !b_is_dir )
    return -1;
  if ( !a_is_dir && b_is_dir )
    return 1;
  return cmp_size((const fileinfo *)b, (const fileinfo *)a, xstrcoll);
}

//----- (0804E379) --------------------------------------------------------
int __cdecl rev_strcmp_df_size(V a, V b)
{
  bool a_is_dir; // [esp+26h] [ebp-2h]
  bool b_is_dir; // [esp+27h] [ebp-1h]

  a_is_dir = is_directory((const fileinfo *)a);
  b_is_dir = is_directory((const fileinfo *)b);
  if ( a_is_dir && !b_is_dir )
    return -1;
  if ( !a_is_dir && b_is_dir )
    return 1;
  return cmp_size((const fileinfo *)b, (const fileinfo *)a, strcmp);
}

//----- (0804E3F1) --------------------------------------------------------
int __cdecl xstrcoll_name(V a, V b)
{
  return cmp_name((const fileinfo *)a, (const fileinfo *)b, xstrcoll);
}

//----- (0804E413) --------------------------------------------------------
int __cdecl cmp_name(const fileinfo *a, const fileinfo *b, int (*cmp)(const char *, const char *))
{
  return cmp(a->name, b->name);
}

//----- (0804E431) --------------------------------------------------------
int __cdecl strcmp_name(V a, V b)
{
  return cmp_name((const fileinfo *)a, (const fileinfo *)b, strcmp);
}

//----- (0804E453) --------------------------------------------------------
int __cdecl rev_xstrcoll_name(V a, V b)
{
  return cmp_name((const fileinfo *)b, (const fileinfo *)a, xstrcoll);
}

//----- (0804E475) --------------------------------------------------------
int __cdecl rev_strcmp_name(V a, V b)
{
  return cmp_name((const fileinfo *)b, (const fileinfo *)a, strcmp);
}

//----- (0804E497) --------------------------------------------------------
int __cdecl xstrcoll_df_name(V a, V b)
{
  bool a_is_dir; // [esp+26h] [ebp-2h]
  bool b_is_dir; // [esp+27h] [ebp-1h]

  a_is_dir = is_directory((const fileinfo *)a);
  b_is_dir = is_directory((const fileinfo *)b);
  if ( a_is_dir && !b_is_dir )
    return -1;
  if ( !a_is_dir && b_is_dir )
    return 1;
  return cmp_name((const fileinfo *)a, (const fileinfo *)b, xstrcoll);
}

//----- (0804E50F) --------------------------------------------------------
int __cdecl strcmp_df_name(V a, V b)
{
  bool a_is_dir; // [esp+26h] [ebp-2h]
  bool b_is_dir; // [esp+27h] [ebp-1h]

  a_is_dir = is_directory((const fileinfo *)a);
  b_is_dir = is_directory((const fileinfo *)b);
  if ( a_is_dir && !b_is_dir )
    return -1;
  if ( !a_is_dir && b_is_dir )
    return 1;
  return cmp_name((const fileinfo *)a, (const fileinfo *)b, strcmp);
}

//----- (0804E587) --------------------------------------------------------
int __cdecl rev_xstrcoll_df_name(V a, V b)
{
  bool a_is_dir; // [esp+26h] [ebp-2h]
  bool b_is_dir; // [esp+27h] [ebp-1h]

  a_is_dir = is_directory((const fileinfo *)a);
  b_is_dir = is_directory((const fileinfo *)b);
  if ( a_is_dir && !b_is_dir )
    return -1;
  if ( !a_is_dir && b_is_dir )
    return 1;
  return cmp_name((const fileinfo *)b, (const fileinfo *)a, xstrcoll);
}

//----- (0804E5FF) --------------------------------------------------------
int __cdecl rev_strcmp_df_name(V a, V b)
{
  bool a_is_dir; // [esp+26h] [ebp-2h]
  bool b_is_dir; // [esp+27h] [ebp-1h]

  a_is_dir = is_directory((const fileinfo *)a);
  b_is_dir = is_directory((const fileinfo *)b);
  if ( a_is_dir && !b_is_dir )
    return -1;
  if ( !a_is_dir && b_is_dir )
    return 1;
  return cmp_name((const fileinfo *)b, (const fileinfo *)a, strcmp);
}

//----- (0804E677) --------------------------------------------------------
int __cdecl xstrcoll_extension(V a, V b)
{
  return cmp_extension((const fileinfo *)a, (const fileinfo *)b, xstrcoll);
}

//----- (0804E699) --------------------------------------------------------
int __cdecl cmp_extension(const fileinfo *a, const fileinfo *b, int (*cmp)(const char *, const char *))
{
  const char *v4; // [esp+Ch] [ebp-1Ch]
  const char *v5; // [esp+10h] [ebp-18h]
  int v6; // [esp+14h] [ebp-14h]
  char *base1; // [esp+1Ch] [ebp-Ch]
  char *base2; // [esp+20h] [ebp-8h]
  int diff; // [esp+24h] [ebp-4h]

  base1 = strrchr(a->name, 46);
  base2 = strrchr(b->name, 46);
  if ( base2 )
    v4 = base2;
  else
    v4 = &locale;
  if ( base1 )
    v5 = base1;
  else
    v5 = &locale;
  diff = cmp(v5, v4);
  if ( diff )
    v6 = diff;
  else
    v6 = cmp(a->name, b->name);
  return v6;
}

//----- (0804E73A) --------------------------------------------------------
int __cdecl strcmp_extension(V a, V b)
{
  return cmp_extension((const fileinfo *)a, (const fileinfo *)b, strcmp);
}

//----- (0804E75C) --------------------------------------------------------
int __cdecl rev_xstrcoll_extension(V a, V b)
{
  return cmp_extension((const fileinfo *)b, (const fileinfo *)a, xstrcoll);
}

//----- (0804E77E) --------------------------------------------------------
int __cdecl rev_strcmp_extension(V a, V b)
{
  return cmp_extension((const fileinfo *)b, (const fileinfo *)a, strcmp);
}

//----- (0804E7A0) --------------------------------------------------------
int __cdecl xstrcoll_df_extension(V a, V b)
{
  bool a_is_dir; // [esp+26h] [ebp-2h]
  bool b_is_dir; // [esp+27h] [ebp-1h]

  a_is_dir = is_directory((const fileinfo *)a);
  b_is_dir = is_directory((const fileinfo *)b);
  if ( a_is_dir && !b_is_dir )
    return -1;
  if ( !a_is_dir && b_is_dir )
    return 1;
  return cmp_extension((const fileinfo *)a, (const fileinfo *)b, xstrcoll);
}

//----- (0804E818) --------------------------------------------------------
int __cdecl strcmp_df_extension(V a, V b)
{
  bool a_is_dir; // [esp+26h] [ebp-2h]
  bool b_is_dir; // [esp+27h] [ebp-1h]

  a_is_dir = is_directory((const fileinfo *)a);
  b_is_dir = is_directory((const fileinfo *)b);
  if ( a_is_dir && !b_is_dir )
    return -1;
  if ( !a_is_dir && b_is_dir )
    return 1;
  return cmp_extension((const fileinfo *)a, (const fileinfo *)b, strcmp);
}

//----- (0804E890) --------------------------------------------------------
int __cdecl rev_xstrcoll_df_extension(V a, V b)
{
  bool a_is_dir; // [esp+26h] [ebp-2h]
  bool b_is_dir; // [esp+27h] [ebp-1h]

  a_is_dir = is_directory((const fileinfo *)a);
  b_is_dir = is_directory((const fileinfo *)b);
  if ( a_is_dir && !b_is_dir )
    return -1;
  if ( !a_is_dir && b_is_dir )
    return 1;
  return cmp_extension((const fileinfo *)b, (const fileinfo *)a, xstrcoll);
}

//----- (0804E908) --------------------------------------------------------
int __cdecl rev_strcmp_df_extension(V a, V b)
{
  bool a_is_dir; // [esp+26h] [ebp-2h]
  bool b_is_dir; // [esp+27h] [ebp-1h]

  a_is_dir = is_directory((const fileinfo *)a);
  b_is_dir = is_directory((const fileinfo *)b);
  if ( a_is_dir && !b_is_dir )
    return -1;
  if ( !a_is_dir && b_is_dir )
    return 1;
  return cmp_extension((const fileinfo *)b, (const fileinfo *)a, strcmp);
}

//----- (0804E980) --------------------------------------------------------
int __cdecl xstrcoll_version(V a, V b)
{
  return cmp_version((const fileinfo *)a, (const fileinfo *)b);
}

//----- (0804E99A) --------------------------------------------------------
int __cdecl cmp_version(const fileinfo *a, const fileinfo *b)
{
  return strverscmp(a->name, b->name);
}
// 804976C: using guessed type int __cdecl strverscmp(_DWORD, _DWORD);

//----- (0804E9B8) --------------------------------------------------------
int __cdecl rev_xstrcoll_version(V a, V b)
{
  return cmp_version((const fileinfo *)b, (const fileinfo *)a);
}

//----- (0804E9D2) --------------------------------------------------------
int __cdecl xstrcoll_df_version(V a, V b)
{
  bool a_is_dir; // [esp+26h] [ebp-2h]
  bool b_is_dir; // [esp+27h] [ebp-1h]

  a_is_dir = is_directory((const fileinfo *)a);
  b_is_dir = is_directory((const fileinfo *)b);
  if ( a_is_dir && !b_is_dir )
    return -1;
  if ( !a_is_dir && b_is_dir )
    return 1;
  return cmp_version((const fileinfo *)a, (const fileinfo *)b);
}

//----- (0804EA42) --------------------------------------------------------
int __cdecl rev_xstrcoll_df_version(V a, V b)
{
  bool a_is_dir; // [esp+26h] [ebp-2h]
  bool b_is_dir; // [esp+27h] [ebp-1h]

  a_is_dir = is_directory((const fileinfo *)a);
  b_is_dir = is_directory((const fileinfo *)b);
  if ( a_is_dir && !b_is_dir )
    return -1;
  if ( !a_is_dir && b_is_dir )
    return 1;
  return cmp_version((const fileinfo *)b, (const fileinfo *)a);
}

//----- (0804EAB2) --------------------------------------------------------
void initialize_ordering_vector()
{
  size_t i; // [esp+Ch] [ebp-8h]

  for ( i = 0; i < cwd_n_used; ++i )
    sorted_file[i] = &cwd_file[i];
}

//----- (0804EB01) --------------------------------------------------------
void sort_files()
{
  time_type v0; // [esp+1Ch] [ebp-1Ch]
  bool use_strcmp; // [esp+2Fh] [ebp-9h]

  if ( cwd_n_used + (cwd_n_used >> 1) > sorted_file_alloc )
  {
    free(sorted_file);
    sorted_file = (void **)xnmalloc(cwd_n_used, 0xCu);
    sorted_file_alloc = 3 * cwd_n_used;
  }
  initialize_ordering_vector();
  if ( sort_type_0 != sort_none )
  {
    if ( _setjmp(failed_strcoll) )
    {
      use_strcmp = 1;
      if ( sort_type_0 == sort_version )
        __assert_fail("sort_type != sort_version", "ls.c", 0xC8Cu, "sort_files");
      initialize_ordering_vector();
    }
    else
    {
      use_strcmp = 0;
    }
    if ( sort_type_0 == sort_time )
      v0 = time_type_0;
    else
      v0 = time_mtime;
    mpsort(
      (const void **)sorted_file,
      cwd_n_used,
      *(&sort_functions[sort_type_0][2 * v0][2 * use_strcmp][2 * sort_reverse] + directories_first));
  }
}

//----- (0804EC2E) --------------------------------------------------------
void print_current_files()
{
  size_t i; // [esp+14h] [ebp-4h]
  size_t ia; // [esp+14h] [ebp-4h]

  switch ( format_0 )
  {
    case long_format:
      for ( ia = 0; ia < cwd_n_used; ++ia )
      {
        print_long_format((const fileinfo *)sorted_file[ia]);
        putchar_unlocked(10);
        ++dired_pos;
      }
      break;
    case one_per_line:
      for ( i = 0; i < cwd_n_used; ++i )
      {
        print_file_name_and_frills((const fileinfo *)sorted_file[i]);
        putchar_unlocked(10);
      }
      break;
    case many_per_line:
      print_many_per_line();
      break;
    case horizontal:
      print_horizontal();
      break;
    case with_commas:
      print_with_commas();
      break;
    default:
      return;
  }
}

//----- (0804ECF0) --------------------------------------------------------
int long_time_expected_width()
{
  char buf[1001]; // [esp+23h] [ebp-3F5h] BYREF
  time_t epoch; // [esp+40Ch] [ebp-Ch] BYREF
  const tm *tm; // [esp+410h] [ebp-8h]
  size_t len; // [esp+414h] [ebp-4h]

  if ( width_9028 < 0 )
  {
    epoch = 0;
    tm = localtime(&epoch);
    if ( tm )
    {
      len = nstrftime(buf, 0x3E9u, long_time_format[0], tm, 0, 0);
      if ( len )
        width_9028 = mbsnwidth(buf, len, 0);
    }
    if ( width_9028 < 0 )
      width_9028 = 0;
  }
  return width_9028;
}

//----- (0804ED9D) --------------------------------------------------------
void get_current_time()
{
  timeval timeval; // [esp+8h] [ebp-10h] BYREF
  timespec timespec; // [esp+10h] [ebp-8h] BYREF

  if ( clock_gettime(0, &timespec) )
  {
    gettimeofday(&timeval, 0);
    current_time = timeval.tv_sec;
    current_time_ns = 1000 * timeval.tv_usec + 999;
  }
  else
  {
    current_time = timespec.tv_sec;
    current_time_ns = timespec.tv_nsec;
  }
}

//----- (0804EDFC) --------------------------------------------------------
void __cdecl format_user_or_group(const char *name, unsigned int id, int width)
{
  int len; // [esp+1Ch] [ebp-Ch]
  int width_gap; // [esp+20h] [ebp-8h]
  int pad; // [esp+24h] [ebp-4h]

  if ( name )
  {
    width_gap = width - gnu_mbswidth(name, 0);
    pad = width_gap & ~(width_gap >> 31);
    fputs_unlocked(name, stdout);
    len = strlen(name) + pad;
    do
      putchar_unlocked(32);
    while ( pad-- != 0 );
  }
  else
  {
    printf("%*lu ", width, id);
    len = width;
  }
  dired_pos += len + 1;
}
// 804955C: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804EEAC) --------------------------------------------------------
void __cdecl format_user(uid_t u, int width, bool stat_ok)
{
  char *name; // [esp+Ch] [ebp-Ch]
  char *v4; // [esp+10h] [ebp-8h]

  if ( stat_ok )
  {
    if ( numeric_ids )
      v4 = 0;
    else
      v4 = getuser(u);
    name = v4;
  }
  else
  {
    name = "?";
  }
  format_user_or_group(name, u, width);
}

//----- (0804EF0A) --------------------------------------------------------
void __cdecl format_group(gid_t g, int width, bool stat_ok)
{
  char *name; // [esp+Ch] [ebp-Ch]
  char *v4; // [esp+10h] [ebp-8h]

  if ( stat_ok )
  {
    if ( numeric_ids )
      v4 = 0;
    else
      v4 = getgroup(g);
    name = v4;
  }
  else
  {
    name = "?";
  }
  format_user_or_group(name, g, width);
}

//----- (0804EF68) --------------------------------------------------------
int __cdecl format_user_or_group_width(const char *name, unsigned int id)
{
  int v2; // eax
  int v4; // [esp+14h] [ebp-14h]
  char buf[11]; // [esp+19h] [ebp-Fh] BYREF

  if ( name )
  {
    v2 = gnu_mbswidth(name, 0);
    v4 = ~(v2 >> 31) & v2;
  }
  else
  {
    sprintf(buf, "%lu", id);
    v4 = strlen(buf);
  }
  return v4;
}

//----- (0804EFC9) --------------------------------------------------------
int __cdecl format_user_width(uid_t u)
{
  const char *name; // [esp+14h] [ebp-4h]

  if ( numeric_ids )
    name = 0;
  else
    name = getuser(u);
  return format_user_or_group_width(name, u);
}

//----- (0804F005) --------------------------------------------------------
int __cdecl format_group_width(gid_t g)
{
  const char *name; // [esp+14h] [ebp-4h]

  if ( numeric_ids )
    name = 0;
  else
    name = getgroup(g);
  return format_user_or_group_width(name, g);
}

//----- (0804F041) --------------------------------------------------------
void __cdecl print_long_format(const fileinfo *f)
{
  size_t v1; // eax
  int v2; // ebx
  bool v3; // al
  size_t v4; // eax
  unsigned int v5; // eax
  char *v6; // ebx
  int v7; // esi
  unsigned int v8; // eax
  char *v9; // eax
  uintmax_t v10; // kr00_8
  int v11; // edi
  uintmax_t v12; // rax
  int v13; // ebx
  bool v14; // al
  int v15; // eax
  size_t v16; // eax
  char *v17; // [esp+24h] [ebp-11C4h]
  char *v18; // [esp+28h] [ebp-11C0h]
  char *v19; // [esp+30h] [ebp-11B8h]
  char *v20; // [esp+34h] [ebp-11B4h]
  bool v21; // [esp+38h] [ebp-11B0h]
  char *v22; // [esp+3Ch] [ebp-11ACh]
  filetype type; // [esp+40h] [ebp-11A8h]
  bool stat_ok; // [esp+44h] [ebp-11A4h]
  _BOOL4 linkok; // [esp+48h] [ebp-11A0h]
  timespec v26; // [esp+50h] [ebp-1198h] BYREF
  char hbuf_0[652]; // [esp+5Fh] [ebp-1189h] BYREF
  char hbuf_2[21]; // [esp+2EBh] [ebp-EFDh] BYREF
  char minorbuf[21]; // [esp+300h] [ebp-EE8h] BYREF
  char majorbuf[21]; // [esp+315h] [ebp-ED3h] BYREF
  char hbuf_1[21]; // [esp+32Ah] [ebp-EBEh] BYREF
  char hbuf[21]; // [esp+33Fh] [ebp-EA9h] BYREF
  timespec when_timespec; // [esp+354h] [ebp-E94h] BYREF
  char buf[3643]; // [esp+35Dh] [ebp-E8Bh] BYREF
  char modebuf[12]; // [esp+1198h] [ebp-50h] BYREF
  size_t s; // [esp+11A4h] [ebp-44h]
  char *p; // [esp+11A8h] [ebp-40h]
  time_t when; // [esp+11ACh] [ebp-3Ch]
  int when_ns; // [esp+11B0h] [ebp-38h]
  tm *when_local; // [esp+11B4h] [ebp-34h]
  const char *blocks; // [esp+11B8h] [ebp-30h]
  int pad; // [esp+11BCh] [ebp-2Ch]
  int blanks_width; // [esp+11C0h] [ebp-28h]
  const char *size; // [esp+11C4h] [ebp-24h]
  int pad_0; // [esp+11C8h] [ebp-20h]
  time_t six_months_ago; // [esp+11CCh] [ebp-1Ch]
  bool recent; // [esp+11D3h] [ebp-15h]
  const char *fmt; // [esp+11D4h] [ebp-14h]

  if ( f->stat_ok )
  {
    filemodestring(&f->stat, modebuf);
  }
  else
  {
    modebuf[0] = filetype_letter[f->filetype];
    memset(&modebuf[1], 63, 0xAu);
    modebuf[11] = 0;
  }
  if ( !any_has_acl )
  {
    modebuf[10] = 0;
  }
  else if ( f->have_acl )
  {
    modebuf[10] = 43;
  }
  if ( time_type_0 == time_ctime )
  {
    get_stat_ctime(&v26, &f->stat);
    when_timespec = v26;
  }
  else if ( time_type_0 )
  {
    if ( time_type_0 != time_atime )
      abort();
    get_stat_atime(&v26, &f->stat);
    when_timespec = v26;
  }
  else
  {
    get_stat_mtime(&v26, &f->stat);
    when_timespec = v26;
  }
  when = when_timespec.tv_sec;
  when_ns = when_timespec.tv_nsec;
  p = buf;
  if ( print_inode )
  {
    if ( f->stat.st_ino )
      v17 = umaxtostr(f->stat.st_ino, hbuf);
    else
      v17 = "?";
    sprintf(p, "%*s ", inode_number_width, v17);
    v1 = strlen(p);
    p += v1;
  }
  if ( print_block_size )
  {
    if ( f->stat_ok )
      v18 = human_readable(f->stat.st_blocks, hbuf_0, human_output_opts, 0x200uLL, output_block_size);
    else
      v18 = "?";
    blocks = v18;
    v2 = block_size_width;
    for ( pad = v2 - gnu_mbswidth(v18, 0); pad > 0; --pad )
      *p++ = 32;
    do
    {
      *p = *blocks;
      v3 = *p++ != 0;
      ++blocks;
    }
    while ( v3 );
    *(p - 1) = 32;
  }
  if ( f->stat_ok )
    v19 = umaxtostr(f->stat.st_nlink, hbuf_1);
  else
    v19 = "?";
  sprintf(p, "%s %*s ", modebuf, nlink_width, v19);
  v4 = strlen(p);
  p += v4;
  if ( dired )
  {
    fwrite_unlocked("  ", 1u, 2u, stdout);
    dired_pos += 2;
  }
  if ( print_author || print_group || print_owner || print_scontext )
  {
    fputs_unlocked(buf, stdout);
    dired_pos += p - buf;
    if ( print_owner )
      format_user(f->stat.st_uid, owner_width, f->stat_ok);
    if ( print_group )
      format_group(f->stat.st_gid, group_width, f->stat_ok);
    if ( print_author )
      format_user(f->stat.st_uid, author_width, f->stat_ok);
    if ( print_scontext )
      format_user_or_group(f->scontext, 0, scontext_width);
    p = buf;
  }
  if ( f->stat_ok && ((f->stat.st_mode & 0xF000) == 0x2000 || (f->stat.st_mode & 0xF000) == 24576) )
  {
    blanks_width = -2 - major_device_number_width - minor_device_number_width + file_size_width;
    v5 = gnu_dev_minor(f->stat.st_rdev);
    v6 = umaxtostr(v5, minorbuf);
    v7 = minor_device_number_width;
    v8 = gnu_dev_major(f->stat.st_rdev);
    v9 = umaxtostr(v8, majorbuf);
    sprintf(p, "%*s, %*s ", (blanks_width & ~(blanks_width >> 31)) + major_device_number_width, v9, v7, v6);
    p += file_size_width + 1;
  }
  else
  {
    if ( f->stat_ok )
    {
      v10 = file_output_block_size;
      v11 = human_output_opts;
      v12 = unsigned_file_size(f->stat.st_size);
      v20 = human_readable(v12, hbuf_0, v11, 1uLL, v10);
    }
    else
    {
      v20 = "?";
    }
    size = v20;
    v13 = file_size_width;
    for ( pad_0 = v13 - gnu_mbswidth(v20, 0); pad_0 > 0; --pad_0 )
      *p++ = 32;
    do
    {
      *p = *size;
      v14 = *p++ != 0;
      ++size;
    }
    while ( v14 );
    *(p - 1) = 32;
  }
  when_local = localtime(&when_timespec.tv_sec);
  s = 0;
  *p = 1;
  if ( f->stat_ok && when_local )
  {
    if ( current_time < when || current_time == when && current_time_ns < when_ns )
      get_current_time();
    six_months_ago = current_time - 15778476;
    v21 = current_time - 15778476 <= when && (when < current_time || when == current_time && when_ns <= current_time_ns);
    recent = v21;
    fmt = long_time_format[v21];
    s = nstrftime(p, 0x3E9u, fmt, when_local, 0, when_ns);
  }
  if ( !s && *p )
  {
    if ( f->stat_ok )
      v22 = imaxtostr(when, hbuf_2);
    else
      v22 = "?";
    v15 = long_time_expected_width();
    sprintf(p, "%*s ", v15, v22);
    v16 = strlen(p);
    p += v16;
  }
  else
  {
    p += s;
    *p++ = 32;
    *p = 0;
  }
  fputs_unlocked(buf, stdout);
  dired_pos += p - buf;
  type = f->filetype;
  stat_ok = f->stat_ok;
  linkok = f->linkok;
  if ( color_symlink_as_referent && linkok )
    print_name_with_quoting(f->name, f->linkmode, linkok, stat_ok, type, &dired_obstack);
  else
    print_name_with_quoting(f->name, f->stat.st_mode, linkok, stat_ok, type, &dired_obstack);
  if ( f->filetype == symbolic_link )
  {
    if ( f->linkname )
    {
      fwrite_unlocked(" -> ", 1u, 4u, stdout);
      dired_pos += 4;
      print_name_with_quoting(f->linkname, f->linkmode, f->linkok - 1, f->stat_ok, f->filetype, 0);
      if ( indicator_style_0 )
        print_type_indicator(1, f->linkmode, unknown);
    }
  }
  else if ( indicator_style_0 )
  {
    print_type_indicator(f->stat_ok, f->stat.st_mode, f->filetype);
  }
}
// 804955C: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804FA54) --------------------------------------------------------
size_t __cdecl quote_name(FILE *out, const char *name, const quoting_options *options, size_t *width)
{
  void *v4; // esp
  const unsigned __int16 *v5; // ebx
  const unsigned __int16 *v6; // ebx
  int v8; // [esp+20h] [ebp-2048h] BYREF
  wchar_t wc; // [esp+28h] [ebp-2040h] BYREF
  mbstate_t mbstate; // [esp+2Ch] [ebp-203Ch] BYREF
  char smallbuf[8192]; // [esp+34h] [ebp-2034h] BYREF
  size_t len; // [esp+2034h] [ebp-34h]
  char *buf; // [esp+2038h] [ebp-30h]
  size_t displayed_width; // [esp+203Ch] [ebp-2Ch]
  const char *p; // [esp+2040h] [ebp-28h]
  const char *plimit; // [esp+2044h] [ebp-24h]
  char *q; // [esp+2048h] [ebp-20h]
  size_t bytes; // [esp+204Ch] [ebp-1Ch]
  int w; // [esp+2050h] [ebp-18h]
  char *p_0; // [esp+2054h] [ebp-14h]
  const char *plimit_0; // [esp+2058h] [ebp-10h]
  const char *p_1; // [esp+205Ch] [ebp-Ch]
  const char *plimit_1; // [esp+2060h] [ebp-8h]

  len = quotearg_buffer(smallbuf, 0x2000u, name, 0xFFFFFFFF, options);
  if ( len > 0x1FFF )
  {
    v4 = alloca(16 * ((len + 31) >> 4));
    buf = (char *)(16 * (((unsigned int)&v8 + 3) >> 4));
    quotearg_buffer(buf, len + 1, name, 0xFFFFFFFF, options);
  }
  else
  {
    buf = smallbuf;
  }
  if ( qmark_funny_chars )
  {
    if ( __ctype_get_mb_cur_max() > 1 )
    {
      p = buf;
      plimit = &buf[len];
      q = buf;
      for ( displayed_width = 0; ; ++displayed_width )
      {
        while ( 1 )
        {
LABEL_29:
          if ( p >= plimit )
          {
            len = q - buf;
            goto LABEL_45;
          }
          v8 = *p;
          if ( v8 <= 95 )
            break;
          if ( (unsigned int)(v8 - 97) <= 0x1D )
            goto LABEL_14;
LABEL_15:
          mbstate.__count = 0;
          mbstate.__wch = 0;
          while ( 1 )
          {
            bytes = mbrtowc(&wc, p, plimit - p, &mbstate);
            if ( bytes == -1 )
            {
              ++p;
              *q++ = 63;
              ++displayed_width;
              goto LABEL_29;
            }
            if ( bytes == -2 )
              break;
            if ( !bytes )
              bytes = 1;
            w = wcwidth(wc);
            if ( w < 0 )
            {
              p += bytes;
              *q++ = 63;
              ++displayed_width;
            }
            else
            {
              while ( bytes )
              {
                *q++ = *p++;
                --bytes;
              }
              displayed_width += w;
            }
            if ( mbsinit(&mbstate) )
              goto LABEL_29;
          }
          p = plimit;
          *q++ = 63;
          ++displayed_width;
        }
        if ( v8 < 65 && (v8 < 32 || v8 > 35 && (unsigned int)(v8 - 37) > 0x1A) )
          goto LABEL_15;
LABEL_14:
        *q++ = *p++;
      }
    }
    p_0 = buf;
    plimit_0 = &buf[len];
    while ( p_0 < plimit_0 )
    {
      v5 = *__ctype_b_loc();
      if ( (v5[to_uchar(*p_0)] & 0x4000) == 0 )
        *p_0 = 63;
      ++p_0;
    }
    displayed_width = len;
  }
  else if ( width )
  {
    if ( __ctype_get_mb_cur_max() <= 1 )
    {
      p_1 = buf;
      plimit_1 = &buf[len];
      displayed_width = 0;
      while ( p_1 < plimit_1 )
      {
        v6 = *__ctype_b_loc();
        if ( (v6[to_uchar(*p_1)] & 0x4000) != 0 )
          ++displayed_width;
        ++p_1;
      }
    }
    else
    {
      displayed_width = mbsnwidth(buf, len, 0);
    }
  }
LABEL_45:
  if ( out )
    fwrite_unlocked(buf, 1u, len, out);
  if ( width )
    *width = displayed_width;
  return len;
}
// 8049A5C: using guessed type int __cdecl wcwidth(_DWORD);

//----- (0804FDEF) --------------------------------------------------------
unsigned __int8 __cdecl to_uchar(char ch_0)
{
  return ch_0;
}

//----- (0804FE01) --------------------------------------------------------
void __cdecl print_name_with_quoting(const char *p, mode_t mode, int linkok, bool stat_ok, filetype type, obstack *stack)
{
  if ( print_with_color )
    print_color_indicator(p, mode, linkok, stat_ok, type);
  if ( stack && dired )
  {
    if ( stack->next_free + 4 > stack->chunk_limit )
      _obstack_newchunk(stack, 4);
    memcpy(stack->next_free, &dired_pos, 4u);
    stack->next_free += 4;
  }
  dired_pos += quote_name(stdout, p, filename_quoting_options, 0);
  if ( stack && dired )
  {
    if ( stack->next_free + 4 > stack->chunk_limit )
      _obstack_newchunk(stack, 4);
    memcpy(stack->next_free, &dired_pos, 4u);
    stack->next_free += 4;
  }
  if ( print_with_color )
  {
    process_signals();
    prep_non_filename_text();
  }
}

//----- (0804FF72) --------------------------------------------------------
void prep_non_filename_text()
{
  if ( color_indicator[2].string )
  {
    put_indicator(&color_indicator[2]);
  }
  else
  {
    put_indicator(color_indicator);
    put_indicator(&color_indicator[3]);
    put_indicator(&color_indicator[1]);
  }
}

//----- (0804FFB5) --------------------------------------------------------
void __cdecl print_file_name_and_frills(const fileinfo *f)
{
  char *v1; // [esp+20h] [ebp-2C8h]
  int v2; // [esp+24h] [ebp-2C4h]
  char *v3; // [esp+2Ch] [ebp-2BCh]
  int v4; // [esp+30h] [ebp-2B8h]
  int v5; // [esp+38h] [ebp-2B0h]
  mode_t mode; // [esp+48h] [ebp-2A0h]
  char buf[652]; // [esp+50h] [ebp-298h] BYREF

  if ( print_inode )
  {
    v1 = umaxtostr(f->stat.st_ino, buf);
    if ( format_0 == with_commas )
      v2 = 0;
    else
      v2 = inode_number_width;
    printf("%*s ", v2, v1);
  }
  if ( print_block_size )
  {
    v3 = human_readable(f->stat.st_blocks, buf, human_output_opts, 0x200uLL, output_block_size);
    if ( format_0 == with_commas )
      v4 = 0;
    else
      v4 = block_size_width;
    printf("%*s ", v4, v3);
  }
  if ( print_scontext )
  {
    if ( format_0 == with_commas )
      v5 = 0;
    else
      v5 = scontext_width;
    printf("%*s ", v5, f->scontext);
  }
  if ( color_symlink_as_referent && f->linkok )
    mode = f->linkmode;
  else
    mode = f->stat.st_mode;
  print_name_with_quoting(f->name, mode, f->linkok, f->stat_ok, f->filetype, 0);
  if ( indicator_style_0 )
    print_type_indicator(f->stat_ok, f->stat.st_mode, f->filetype);
}

//----- (08050215) --------------------------------------------------------
char __cdecl get_type_indicator(bool stat_ok, mode_t mode, filetype type)
{
  bool v4; // [esp+2h] [ebp-1Eh]
  bool v5; // [esp+3h] [ebp-1Dh]
  bool v6; // [esp+4h] [ebp-1Ch]
  bool v7; // [esp+9h] [ebp-17h]
  bool v8; // [esp+Ah] [ebp-16h]
  bool v9; // [esp+Bh] [ebp-15h]
  char c; // [esp+1Fh] [ebp-1h]

  if ( stat_ok )
    v4 = (mode & 0xF000) == 0x8000;
  else
    v4 = type == normal;
  if ( v4 )
  {
    if ( stat_ok && indicator_style_0 == classify && (mode & 0x49) != 0 )
      c = 42;
    else
      c = 0;
  }
  else
  {
    if ( stat_ok )
    {
      v5 = (mode & 0xF000) == 0x4000;
    }
    else
    {
      v6 = type == directory || type == arg_directory;
      v5 = v6;
    }
    if ( v5 )
    {
      c = 47;
    }
    else if ( indicator_style_0 == slash )
    {
      c = 0;
    }
    else
    {
      if ( stat_ok )
        v7 = (mode & 0xF000) == 40960;
      else
        v7 = type == symbolic_link;
      if ( v7 )
      {
        c = 64;
      }
      else
      {
        if ( stat_ok )
          v8 = (mode & 0xF000) == 4096;
        else
          v8 = type == fifo;
        if ( v8 )
        {
          c = 124;
        }
        else
        {
          if ( stat_ok )
            v9 = (mode & 0xF000) == 49152;
          else
            v9 = type == sock;
          if ( v9 )
            c = 61;
          else
            c = 0;
        }
      }
    }
  }
  return c;
}

//----- (08050368) --------------------------------------------------------
void __cdecl print_type_indicator(bool stat_ok, mode_t mode, filetype type)
{
  char c; // [esp+27h] [ebp-1h]

  c = get_type_indicator(stat_ok, mode, type);
  if ( c )
  {
    putchar_unlocked(c);
    ++dired_pos;
  }
}

//----- (080503B2) --------------------------------------------------------
void __cdecl print_color_indicator(const char *name, mode_t mode, int linkok, bool stat_ok, filetype filetype)
{
  int v5; // [esp+Ch] [ebp-1Ch]
  bin_str *ind; // [esp+10h] [ebp-18h]
  int type; // [esp+1Ch] [ebp-Ch]
  color_ext_type *ext; // [esp+20h] [ebp-8h]
  size_t len; // [esp+24h] [ebp-4h]
  const char *namea; // [esp+30h] [ebp+8h]

  if ( linkok == -1 && color_indicator[11].string )
  {
    type = 11;
  }
  else if ( !stat_ok )
  {
    type = filetype_indicator_9866[filetype];
  }
  else
  {
    switch ( mode & 0xF000 )
    {
      case 0x8000u:
        type = 4;
        if ( (mode & 0x800) != 0 )
        {
          type = 15;
        }
        else if ( (mode & 0x400) != 0 )
        {
          type = 16;
        }
        else if ( (mode & 0x49) != 0 )
        {
          type = 13;
        }
        break;
      case 0x4000u:
        if ( (mode & 0x200) != 0 && (mode & 2) != 0 )
        {
          type = 19;
        }
        else if ( (mode & 2) != 0 )
        {
          type = 18;
        }
        else if ( (mode & 0x200) != 0 )
        {
          type = 17;
        }
        else
        {
          type = 5;
        }
        break;
      case 0xA000u:
        if ( linkok || !color_indicator[12].string )
          v5 = 6;
        else
          v5 = 12;
        type = v5;
        break;
      case 0x1000u:
        type = 7;
        break;
      case 0xC000u:
        type = 8;
        break;
      case 0x6000u:
        type = 9;
        break;
      case 0x2000u:
        type = 10;
        break;
      default:
        type = 12;
        break;
    }
  }
  ext = 0;
  if ( type == 4 )
  {
    len = strlen(name);
    namea = &name[len];
    for ( ext = color_ext_list;
          ext && (ext->ext.len > len || strncmp(&namea[-ext->ext.len], ext->ext.string, ext->ext.len));
          ext = ext->next )
    {
      ;
    }
  }
  put_indicator(color_indicator);
  if ( ext )
    ind = &ext->seq;
  else
    ind = (bin_str *)(8 * type + 134627808);
  put_indicator(ind);
  put_indicator(&color_indicator[1]);
}

//----- (0805060F) --------------------------------------------------------
void __cdecl put_indicator(const bin_str *ind)
{
  int v1; // eax
  bin_str i; // [esp+10h] [ebp-8h]

  for ( i = *ind; i.len; --i.len )
  {
    v1 = *i.string++;
    putchar_unlocked(v1);
  }
}

//----- (08050649) --------------------------------------------------------
size_t __cdecl length_of_file_name_and_frills(const fileinfo *f)
{
  char *v1; // eax
  char *v2; // eax
  int v4; // [esp+2Ch] [ebp-2BCh]
  int v5; // [esp+30h] [ebp-2B8h]
  int v6; // [esp+38h] [ebp-2B0h]
  char buf[652]; // [esp+44h] [ebp-2A4h] BYREF
  size_t name_width; // [esp+2D0h] [ebp-18h] BYREF
  size_t len; // [esp+2D4h] [ebp-14h]
  char c; // [esp+2DBh] [ebp-Dh]

  len = 0;
  if ( print_inode )
  {
    if ( format_0 == with_commas )
    {
      v1 = umaxtostr(f->stat.st_ino, buf);
      v4 = strlen(v1) + 1;
    }
    else
    {
      v4 = inode_number_width + 1;
    }
    len += v4;
  }
  if ( print_block_size )
  {
    if ( format_0 == with_commas )
    {
      v2 = human_readable(f->stat.st_blocks, buf, human_output_opts, 0x200uLL, output_block_size);
      v5 = strlen(v2) + 1;
    }
    else
    {
      v5 = block_size_width + 1;
    }
    len += v5;
  }
  if ( print_scontext )
  {
    if ( format_0 == with_commas )
      v6 = strlen(f->scontext) + 1;
    else
      v6 = scontext_width + 1;
    len += v6;
  }
  quote_name(0, f->name, filename_quoting_options, &name_width);
  len += name_width;
  if ( indicator_style_0 )
  {
    c = get_type_indicator(f->stat_ok, f->stat.st_mode, f->filetype);
    len += c != 0;
  }
  return len;
}

//----- (08050817) --------------------------------------------------------
void print_many_per_line()
{
  size_t row; // [esp+20h] [ebp-28h]
  size_t cols; // [esp+24h] [ebp-24h]
  const column_info *line_fmt; // [esp+28h] [ebp-20h]
  size_t rows; // [esp+2Ch] [ebp-1Ch]
  size_t col; // [esp+30h] [ebp-18h]
  size_t filesno; // [esp+34h] [ebp-14h]
  size_t pos; // [esp+38h] [ebp-10h]
  const fileinfo *f; // [esp+3Ch] [ebp-Ch]
  size_t name_length; // [esp+40h] [ebp-8h]
  size_t max_name_length; // [esp+44h] [ebp-4h]

  cols = calculate_columns(1);
  line_fmt = &column_info_0[cols - 1];
  rows = cwd_n_used / cols + (cwd_n_used % cols != 0);
  for ( row = 0; row < rows; ++row )
  {
    col = 0;
    filesno = row;
    for ( pos = 0; ; pos += max_name_length )
    {
      f = (const fileinfo *)sorted_file[filesno];
      name_length = length_of_file_name_and_frills(f);
      max_name_length = line_fmt->col_arr[col++];
      print_file_name_and_frills(f);
      filesno += rows;
      if ( filesno >= cwd_n_used )
        break;
      indent(name_length + pos, pos + max_name_length);
    }
    putchar_unlocked(10);
  }
}

//----- (08050931) --------------------------------------------------------
void print_horizontal()
{
  size_t filesno; // [esp+18h] [ebp-20h]
  size_t pos; // [esp+1Ch] [ebp-1Ch]
  size_t cols; // [esp+20h] [ebp-18h]
  const column_info *line_fmt; // [esp+24h] [ebp-14h]
  const fileinfo *f; // [esp+28h] [ebp-10h]
  const fileinfo *fa; // [esp+28h] [ebp-10h]
  size_t name_length; // [esp+2Ch] [ebp-Ch]
  size_t max_name_length; // [esp+30h] [ebp-8h]

  pos = 0;
  cols = calculate_columns(0);
  line_fmt = &column_info_0[cols - 1];
  f = (const fileinfo *)*sorted_file;
  name_length = length_of_file_name_and_frills((const fileinfo *)*sorted_file);
  max_name_length = *line_fmt->col_arr;
  print_file_name_and_frills(f);
  for ( filesno = 1; filesno < cwd_n_used; ++filesno )
  {
    if ( filesno % cols )
    {
      indent(name_length + pos, pos + max_name_length);
      pos += max_name_length;
    }
    else
    {
      putchar_unlocked(10);
      pos = 0;
    }
    fa = (const fileinfo *)sorted_file[filesno];
    print_file_name_and_frills(fa);
    name_length = length_of_file_name_and_frills(fa);
    max_name_length = line_fmt->col_arr[filesno % cols];
  }
  putchar_unlocked(10);
}

//----- (08050A55) --------------------------------------------------------
void print_with_commas()
{
  size_t filesno; // [esp+14h] [ebp-14h]
  size_t pos; // [esp+18h] [ebp-10h]
  const fileinfo *f; // [esp+1Ch] [ebp-Ch]
  size_t len; // [esp+20h] [ebp-8h]
  char separator; // [esp+27h] [ebp-1h]

  pos = 0;
  for ( filesno = 0; filesno < cwd_n_used; ++filesno )
  {
    f = (const fileinfo *)sorted_file[filesno];
    len = length_of_file_name_and_frills(f);
    if ( filesno )
    {
      if ( len + pos + 2 >= line_length )
      {
        pos = 0;
        separator = 10;
      }
      else
      {
        pos += 2;
        separator = 32;
      }
      putchar_unlocked(44);
      putchar_unlocked(separator);
    }
    print_file_name_and_frills(f);
    pos += len;
  }
  putchar_unlocked(10);
}

//----- (08050B05) --------------------------------------------------------
void __cdecl indent(size_t from, size_t to)
{
  while ( from < to )
  {
    if ( tabsize && to / tabsize > (from + 1) / tabsize )
    {
      putchar_unlocked(9);
      from += tabsize - from % tabsize;
    }
    else
    {
      putchar_unlocked(32);
      ++from;
    }
  }
}

//----- (08050BAF) --------------------------------------------------------
void __cdecl attach(char *dest, const char *dirname, const char *name)
{
  const char *dirnamep; // [esp+Ch] [ebp-4h]

  dirnamep = dirname;
  if ( *dirname != 46 || dirname[1] )
  {
    while ( *dirnamep )
      *dest++ = *dirnamep++;
    if ( dirnamep > dirname && *(dirnamep - 1) != 47 )
      *dest++ = 47;
  }
  while ( *name )
    *dest++ = *name++;
  *dest = 0;
}

//----- (08050C37) --------------------------------------------------------
void init_column_info()
{
  size_t v0; // [esp+10h] [ebp-28h]
  size_t i; // [esp+18h] [ebp-20h]
  size_t ia; // [esp+18h] [ebp-20h]
  size_t new_column_info_alloc; // [esp+20h] [ebp-18h]
  size_t *p; // [esp+24h] [ebp-14h]
  size_t t; // [esp+30h] [ebp-8h]
  size_t j; // [esp+34h] [ebp-4h]

  v0 = cwd_n_used;
  if ( cwd_n_used > max_idx )
    v0 = max_idx;
  if ( column_info_alloc_10187 < v0 )
  {
    if ( max_idx >> 1 <= v0 )
    {
      column_info_0 = (column_info *)xnrealloc(column_info_0, max_idx, 0xCu);
      new_column_info_alloc = max_idx;
    }
    else
    {
      column_info_0 = (column_info *)xnrealloc(column_info_0, v0, 0x18u);
      new_column_info_alloc = 2 * v0;
    }
    t = (new_column_info_alloc - column_info_alloc_10187) * (new_column_info_alloc + column_info_alloc_10187 + 1);
    if ( new_column_info_alloc + column_info_alloc_10187 + 1 < new_column_info_alloc
      || t / (new_column_info_alloc - column_info_alloc_10187) != new_column_info_alloc + column_info_alloc_10187 + 1 )
    {
      xalloc_die();
    }
    p = (size_t *)xnmalloc(t >> 1, 4u);
    for ( i = column_info_alloc_10187; i < new_column_info_alloc; ++i )
    {
      column_info_0[i].col_arr = p;
      p += i + 1;
    }
    column_info_alloc_10187 = new_column_info_alloc;
  }
  for ( ia = 0; ia < v0; ++ia )
  {
    column_info_0[ia].valid_len = 1;
    column_info_0[ia].line_len = 3 * (ia + 1);
    for ( j = 0; j <= ia; ++j )
      column_info_0[ia].col_arr[j] = 3;
  }
}

//----- (08050E06) --------------------------------------------------------
size_t __cdecl calculate_columns(bool by_columns)
{
  size_t v2; // [esp+1Ch] [ebp-3Ch]
  size_t v3; // [esp+24h] [ebp-34h]
  int v4; // [esp+28h] [ebp-30h]
  size_t filesno; // [esp+30h] [ebp-28h]
  size_t cols; // [esp+34h] [ebp-24h]
  size_t name_length; // [esp+40h] [ebp-18h]
  size_t i; // [esp+44h] [ebp-14h]
  size_t real_length; // [esp+4Ch] [ebp-Ch]

  v2 = cwd_n_used;
  if ( cwd_n_used > max_idx )
    v2 = max_idx;
  init_column_info();
  for ( filesno = 0; filesno < cwd_n_used; ++filesno )
  {
    name_length = length_of_file_name_and_frills((const fileinfo *)sorted_file[filesno]);
    for ( i = 0; i < v2; ++i )
    {
      if ( column_info_0[i].valid_len )
      {
        v3 = by_columns ? filesno / ((cwd_n_used + i) / (i + 1)) : filesno % (i + 1);
        v4 = v3 == i ? 0 : 2;
        real_length = name_length + v4;
        if ( column_info_0[i].col_arr[v3] < name_length + v4 )
        {
          column_info_0[i].line_len += real_length - column_info_0[i].col_arr[v3];
          column_info_0[i].col_arr[v3] = real_length;
          column_info_0[i].valid_len = column_info_0[i].line_len < line_length;
        }
      }
    }
  }
  for ( cols = v2; cols > 1 && !column_info_0[cols - 1].valid_len; --cols )
    ;
  return cols;
}

//----- (0805105C) --------------------------------------------------------
void __cdecl __noreturn usage(int status)
{
  char *v1; // ebx
  char *v2; // eax
  char *v3; // eax
  FILE *v4; // ebx
  char *v5; // eax
  FILE *v6; // ebx
  char *v7; // eax
  FILE *v8; // ebx
  char *v9; // eax
  FILE *v10; // ebx
  char *v11; // eax
  FILE *v12; // ebx
  char *v13; // eax
  FILE *v14; // ebx
  char *v15; // eax
  FILE *v16; // ebx
  char *v17; // eax
  FILE *v18; // ebx
  char *v19; // eax
  FILE *v20; // ebx
  char *v21; // eax
  FILE *v22; // ebx
  char *v23; // eax
  FILE *v24; // ebx
  char *v25; // eax
  FILE *v26; // ebx
  char *v27; // eax
  FILE *v28; // ebx
  char *v29; // eax
  FILE *v30; // ebx
  char *v31; // eax
  FILE *v32; // ebx
  char *v33; // eax
  FILE *v34; // ebx
  char *v35; // eax
  FILE *v36; // ebx
  char *v37; // eax
  FILE *v38; // ebx
  char *v39; // eax
  FILE *v40; // ebx
  char *v41; // eax
  FILE *v42; // ebx
  char *v43; // eax
  FILE *v44; // ebx
  char *v45; // eax
  FILE *v46; // ebx
  char *v47; // eax
  FILE *v48; // ebx
  char *v49; // eax
  FILE *v50; // ebx
  char *v51; // eax
  FILE *v52; // ebx
  char *v53; // eax

  v1 = program_name;
  if ( status )
  {
    v2 = gettext("Try `%s --help' for more information.\n");
    fprintf(stderr, v2, v1);
  }
  else
  {
    v3 = gettext("Usage: %s [OPTION]... [FILE]...\n");
    printf(v3, v1);
    v4 = stdout;
    v5 = gettext(
           "List information about the FILEs (the current directory by default).\n"
           "Sort entries alphabetically if none of -cftuvSUX nor --sort.\n"
           "\n");
    fputs_unlocked(v5, v4);
    v6 = stdout;
    v7 = gettext("Mandatory arguments to long options are mandatory for short options too.\n");
    fputs_unlocked(v7, v6);
    v8 = stdout;
    v9 = gettext(
           "  -a, --all                  do not ignore entries starting with .\n"
           "  -A, --almost-all           do not list implied . and ..\n"
           "      --author               with -l, print the author of each file\n"
           "  -b, --escape               print octal escapes for nongraphic characters\n");
    fputs_unlocked(v9, v8);
    v10 = stdout;
    v11 = gettext(
            "      --block-size=SIZE      use SIZE-byte blocks\n"
            "  -B, --ignore-backups       do not list implied entries ending with ~\n"
            "  -c                         with -lt: sort by, and show, ctime (time of last\n"
            "                               modification of file status information)\n"
            "                               with -l: show ctime and sort by name\n"
            "                               otherwise: sort by ctime\n");
    fputs_unlocked(v11, v10);
    v12 = stdout;
    v13 = gettext(
            "  -C                         list entries by columns\n"
            "      --color[=WHEN]         control whether color is used to distinguish file\n"
            "                               types.  WHEN may be `never', `always', or `auto'\n"
            "  -d, --directory            list directory entries instead of contents,\n"
            "                               and do not dereference symbolic links\n"
            "  -D, --dired                generate output designed for Emacs' dired mode\n");
    fputs_unlocked(v13, v12);
    v14 = stdout;
    v15 = gettext(
            "  -f                         do not sort, enable -aU, disable -ls --color\n"
            "  -F, --classify             append indicator (one of */=>@|) to entries\n"
            "      --file-type            likewise, except do not append `*'\n"
            "      --format=WORD          across -x, commas -m, horizontal -x, long -l,\n"
            "                               single-column -1, verbose -l, vertical -C\n"
            "      --full-time            like -l --time-style=full-iso\n");
    fputs_unlocked(v15, v14);
    v16 = stdout;
    v17 = gettext("  -g                         like -l, but do not list owner\n");
    fputs_unlocked(v17, v16);
    v18 = stdout;
    v19 = gettext("      --group-directories-first\n                             group directories before files\n");
    fputs_unlocked(v19, v18);
    v20 = stdout;
    v21 = gettext(
            "  -G, --no-group             in a long listing, don't print group names\n"
            "  -h, --human-readable       with -l, print sizes in human readable format\n"
            "                               (e.g., 1K 234M 2G)\n"
            "      --si                   likewise, but use powers of 1000 not 1024\n");
    fputs_unlocked(v21, v20);
    v22 = stdout;
    v23 = gettext(
            "  -H, --dereference-command-line\n"
            "                             follow symbolic links listed on the command line\n"
            "      --dereference-command-line-symlink-to-dir\n"
            "                             follow each command line symbolic link\n"
            "                             that points to a directory\n"
            "      --hide=PATTERN         do not list implied entries matching shell PATTERN\n"
            "                               (overridden by -a or -A)\n");
    fputs_unlocked(v23, v22);
    v24 = stdout;
    v25 = gettext(
            "      --indicator-style=WORD  append indicator with style WORD to entry names:\n"
            "                               none (default), slash (-p),\n"
            "                               file-type (--file-type), classify (-F)\n"
            "  -i, --inode                print the index number of each file\n"
            "  -I, --ignore=PATTERN       do not list implied entries matching shell PATTERN\n"
            "  -k                         like --block-size=1K\n");
    fputs_unlocked(v25, v24);
    v26 = stdout;
    v27 = gettext(
            "  -l                         use a long listing format\n"
            "  -L, --dereference          when showing file information for a symbolic\n"
            "                               link, show information for the file the link\n"
            "                               references rather than for the link itself\n"
            "  -m                         fill width with a comma separated list of entries\n");
    fputs_unlocked(v27, v26);
    v28 = stdout;
    v29 = gettext(
            "  -n, --numeric-uid-gid      like -l, but list numeric user and group IDs\n"
            "  -N, --literal              print raw entry names (don't treat e.g. control\n"
            "                               characters specially)\n"
            "  -o                         like -l, but do not list group information\n"
            "  -p, --indicator-style=slash\n"
            "                             append / indicator to directories\n");
    fputs_unlocked(v29, v28);
    v30 = stdout;
    v31 = gettext(
            "  -q, --hide-control-chars   print ? instead of non graphic characters\n"
            "      --show-control-chars   show non graphic characters as-is (default\n"
            "                             unless program is `ls' and output is a terminal)\n"
            "  -Q, --quote-name           enclose entry names in double quotes\n"
            "      --quoting-style=WORD   use quoting style WORD for entry names:\n"
            "                               literal, locale, shell, shell-always, c, escape\n");
    fputs_unlocked(v31, v30);
    v32 = stdout;
    v33 = gettext(
            "  -r, --reverse              reverse order while sorting\n"
            "  -R, --recursive            list subdirectories recursively\n"
            "  -s, --size                 print the size of each file, in blocks\n");
    fputs_unlocked(v33, v32);
    v34 = stdout;
    v35 = gettext(
            "  -S                         sort by file size\n"
            "      --sort=WORD            sort by WORD instead of name: none -U,\n"
            "                             extension -X, size -S, time -t, version -v\n"
            "      --time=WORD            with -l, show time as WORD instead of modification\n"
            "                             time: atime -u, access -u, use -u, ctime -c,\n"
            "                             or status -c; use specified time as sort key\n"
            "                             if --sort=time\n");
    fputs_unlocked(v35, v34);
    v36 = stdout;
    v37 = gettext(
            "      --time-style=STYLE     with -l, show times using style STYLE:\n"
            "                             full-iso, long-iso, iso, locale, +FORMAT.\n"
            "                             FORMAT is interpreted like `date'; if FORMAT is\n"
            "                             FORMAT1<newline>FORMAT2, FORMAT1 applies to\n"
            "                             non-recent files and FORMAT2 to recent files;\n"
            "                             if STYLE is prefixed with `posix-', STYLE\n"
            "                             takes effect only outside the POSIX locale\n");
    fputs_unlocked(v37, v36);
    v38 = stdout;
    v39 = gettext(
            "  -t                         sort by modification time\n"
            "  -T, --tabsize=COLS         assume tab stops at each COLS instead of 8\n");
    fputs_unlocked(v39, v38);
    v40 = stdout;
    v41 = gettext(
            "  -u                         with -lt: sort by, and show, access time\n"
            "                               with -l: show access time and sort by name\n"
            "                               otherwise: sort by access time\n"
            "  -U                         do not sort; list entries in directory order\n"
            "  -v                         sort by version\n");
    fputs_unlocked(v41, v40);
    v42 = stdout;
    v43 = gettext(
            "  -w, --width=COLS           assume screen width instead of current value\n"
            "  -x                         list entries by lines instead of by columns\n"
            "  -X                         sort alphabetically by entry extension\n"
            "  -Z, --context              print any SELinux security context of each file\n"
            "  -1                         list one file per line\n");
    fputs_unlocked(v43, v42);
    v44 = stdout;
    v45 = gettext("      --help     display this help and exit\n");
    fputs_unlocked(v45, v44);
    v46 = stdout;
    v47 = gettext("      --version  output version information and exit\n");
    fputs_unlocked(v47, v46);
    v48 = stdout;
    v49 = gettext(
            "\n"
            "SIZE may be (or may be an integer optionally followed by) one of following:\n"
            "kB 1000, K 1024, MB 1000*1000, M 1024*1024, and so on for G, T, P, E, Z, Y.\n");
    fputs_unlocked(v49, v48);
    v50 = stdout;
    v51 = gettext(
            "\n"
            "By default, color is not used to distinguish types of files.  That is\n"
            "equivalent to using --color=none.  Using the --color option without the\n"
            "optional WHEN argument is equivalent to using --color=always.  With\n"
            "--color=auto, color codes are output only if standard output is connected\n"
            "to a terminal (tty).  The environment variable LS_COLORS can influence the\n"
            "colors, and can be set easily by the dircolors command.\n");
    fputs_unlocked(v51, v50);
    v52 = stdout;
    v53 = gettext("\nExit status is 0 if OK, 1 if minor problems, 2 if serious trouble.\n");
    fputs_unlocked(v53, v52);
    emit_bug_reporting_address();
  }
  exit(status);
}
// 804955C: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (080513B2) --------------------------------------------------------
void emit_bug_reporting_address()
{
  char *v0; // eax

  v0 = gettext("\nReport bugs to <%s>.\n");
  printf(v0, "bug-coreutils@gnu.org");
}

//----- (080513D8) --------------------------------------------------------
char *__cdecl areadlink_with_size(const char *file, size_t size)
{
  size_t v3; // [esp+10h] [ebp-28h]
  int saved_errno; // [esp+18h] [ebp-20h]
  char *buffer; // [esp+1Ch] [ebp-1Ch]
  signed int link_length; // [esp+20h] [ebp-18h]
  size_t buf_size; // [esp+28h] [ebp-10h]

  if ( size >= 0x401 )
    v3 = 1025;
  else
    v3 = size + 1;
  for ( buf_size = v3; ; buf_size = 0x7FFFFFFF )
  {
    while ( 1 )
    {
      buffer = (char *)malloc(buf_size);
      if ( !buffer )
        return 0;
      link_length = readlink(file, buffer, buf_size);
      if ( link_length < 0 && *__errno_location() != 34 )
      {
        saved_errno = *__errno_location();
        free(buffer);
        *__errno_location() = saved_errno;
        return 0;
      }
      if ( link_length < buf_size )
      {
        buffer[link_length] = 0;
        return buffer;
      }
      free(buffer);
      if ( buf_size > 0x3FFFFFFF )
        break;
      buf_size *= 2;
    }
    if ( buf_size > 0x7FFFFFFE )
      break;
  }
  *__errno_location() = 12;
  return 0;
}

//----- (0805150C) --------------------------------------------------------
int __cdecl gnu_mbswidth(const char *string, int flags)
{
  size_t v3; // [esp+4h] [ebp-14h]

  v3 = strlen(string);
  return mbsnwidth(string, v3, flags);
}

//----- (08051537) --------------------------------------------------------
int __cdecl mbsnwidth(const char *string, size_t nbytes, int flags)
{
  int v3; // eax
  int v5; // [esp+10h] [ebp-38h]
  mbstate_t mbstate; // [esp+24h] [ebp-24h] BYREF
  int w; // [esp+2Ch] [ebp-1Ch]
  size_t bytes; // [esp+30h] [ebp-18h]
  wchar_t wc; // [esp+34h] [ebp-14h] BYREF
  int width; // [esp+38h] [ebp-10h]
  const char *plimit; // [esp+3Ch] [ebp-Ch]
  const char *p; // [esp+40h] [ebp-8h]
  unsigned __int8 c; // [esp+47h] [ebp-1h]

  p = string;
  plimit = &string[nbytes];
  width = 0;
  if ( __ctype_get_mb_cur_max() > 1 )
  {
    while ( 1 )
    {
LABEL_28:
      if ( p >= plimit )
        return width;
      v5 = *p;
      if ( v5 > 95 )
      {
        if ( (unsigned int)(v5 - 97) > 0x1D )
          goto LABEL_11;
      }
      else if ( v5 < 65 && (v5 < 32 || v5 > 35 && (unsigned int)(v5 - 37) > 0x1A) )
      {
LABEL_11:
        memset(&mbstate, 0, sizeof(mbstate));
        while ( 1 )
        {
          bytes = mbrtowc(&wc, p, plimit - p, &mbstate);
          if ( bytes == -1 )
          {
            if ( (flags & 1) == 0 )
            {
              ++p;
              ++width;
              goto LABEL_28;
            }
            return -1;
          }
          if ( bytes == -2 )
            break;
          if ( !bytes )
            bytes = 1;
          w = wcwidth(wc);
          if ( w < 0 )
          {
            if ( (flags & 2) != 0 )
              return -1;
            v3 = iswcntrl(wc);
            width += v3 == 0;
          }
          else
          {
            width += w;
          }
          p += bytes;
          if ( mbsinit(&mbstate) )
            goto LABEL_28;
        }
        if ( (flags & 1) == 0 )
        {
          p = plimit;
          ++width;
          continue;
        }
        return -1;
      }
      ++p;
      ++width;
    }
  }
  while ( 1 )
  {
    while ( 1 )
    {
      if ( p >= plimit )
        return width;
      c = *p++;
      if ( ((*__ctype_b_loc())[c] & 0x4000) == 0 )
        break;
      ++width;
    }
    if ( (flags & 2) != 0 )
      break;
    width += ((*__ctype_b_loc())[c] & 2) == 0;
  }
  return -1;
}
// 8049A5C: using guessed type int __cdecl wcwidth(_DWORD);

//----- (08051750) --------------------------------------------------------
void __cdecl version_etc_va(FILE *stream, const char *command_name, const char *package, const char *version, va_list authors)
{
  _DWORD *v5; // edx
  char *v6; // edx
  char *v7; // [esp+4h] [ebp-24h]
  char *v8; // [esp+4h] [ebp-24h]
  char *v9; // [esp+4h] [ebp-24h]
  char *v10; // [esp+4h] [ebp-24h]
  char *v11; // [esp+4h] [ebp-24h]
  char *v12; // [esp+4h] [ebp-24h]
  char *v13; // [esp+4h] [ebp-24h]
  char *v14; // [esp+4h] [ebp-24h]
  char *v15; // [esp+4h] [ebp-24h]
  char *v16; // [esp+4h] [ebp-24h]
  char *v17; // [esp+8h] [ebp-20h]
  va_list tmp_authors; // [esp+1Ch] [ebp-Ch]
  size_t n_authors; // [esp+20h] [ebp-8h]

  tmp_authors = authors;
  for ( n_authors = 0; ; ++n_authors )
  {
    v5 = tmp_authors;
    tmp_authors += 4;
    if ( !*v5 )
      break;
  }
  if ( command_name )
    fprintf(stream, "%s (%s) %s\n", command_name, package, version);
  else
    fprintf(stream, "%s %s\n", package, version);
  v17 = gettext("(C)");
  fprintf(stream, "Copyright %s %d Free Software Foundation, Inc.", v17, 2008);
  v6 = gettext(
         "\n"
         "License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\n"
         "This is free software: you are free to change and redistribute it.\n"
         "There is NO WARRANTY, to the extent permitted by law.\n"
         "\n");
  fputs_unlocked(v6, stream);
  switch ( n_authors )
  {
    case 0u:
      abort();
      return;
    case 1u:
      v7 = gettext("Written by %s.\n");
      rpl_vfprintf(stream, v7, authors);
      break;
    case 2u:
      v8 = gettext("Written by %s and %s.\n");
      rpl_vfprintf(stream, v8, authors);
      break;
    case 3u:
      v9 = gettext("Written by %s, %s, and %s.\n");
      rpl_vfprintf(stream, v9, authors);
      break;
    case 4u:
      v10 = gettext("Written by %s, %s, %s,\nand %s.\n");
      rpl_vfprintf(stream, v10, authors);
      break;
    case 5u:
      v11 = gettext("Written by %s, %s, %s,\n%s, and %s.\n");
      rpl_vfprintf(stream, v11, authors);
      break;
    case 6u:
      v12 = gettext("Written by %s, %s, %s,\n%s, %s, and %s.\n");
      rpl_vfprintf(stream, v12, authors);
      break;
    case 7u:
      v13 = gettext("Written by %s, %s, %s,\n%s, %s, %s, and %s.\n");
      rpl_vfprintf(stream, v13, authors);
      break;
    case 8u:
      v14 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n");
      rpl_vfprintf(stream, v14, authors);
      break;
    case 9u:
      v15 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n");
      rpl_vfprintf(stream, v15, authors);
      break;
    default:
      v16 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n");
      rpl_vfprintf(stream, v16, authors);
      break;
  }
}
// 804955C: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (080519AF) --------------------------------------------------------
void version_etc(FILE *stream, const char *command_name, const char *package, const char *version, ...)
{
  va_list va; // [esp+40h] [ebp+18h] BYREF

  va_start(va, version);
  version_etc_va(stream, command_name, package, version, va);
}

//----- (080519E4) --------------------------------------------------------
void __noreturn xalloc_die()
{
  char *v0; // eax

  v0 = gettext("memory exhausted");
  error(exit_failure, 0, "%s", v0);
  abort();
}

//----- (08051A20) --------------------------------------------------------
void __noreturn _argmatch_die()
{
  usage(1);
}

//----- (08051A34) --------------------------------------------------------
ptrdiff_t __cdecl argmatch(const char *arg, const char *const *arglist, const char *vallist, size_t valsize)
{
  ptrdiff_t v5; // [esp+14h] [ebp-14h]
  ptrdiff_t matchind; // [esp+18h] [ebp-10h]
  size_t arglen; // [esp+1Ch] [ebp-Ch]
  size_t i; // [esp+20h] [ebp-8h]
  bool ambiguous; // [esp+27h] [ebp-1h]

  matchind = -1;
  ambiguous = 0;
  arglen = strlen(arg);
  for ( i = 0; arglist[i]; ++i )
  {
    if ( !strncmp(arglist[i], arg, arglen) )
    {
      if ( strlen(arglist[i]) == arglen )
        return i;
      if ( matchind == -1 )
      {
        matchind = i;
      }
      else if ( !vallist || memcmp(&vallist[valsize * matchind], &vallist[i * valsize], valsize) )
      {
        ambiguous = 1;
      }
    }
  }
  if ( ambiguous )
    v5 = -2;
  else
    v5 = matchind;
  return v5;
}

//----- (08051B1C) --------------------------------------------------------
void __cdecl argmatch_invalid(const char *context, const char *value, ptrdiff_t problem)
{
  const char *v3; // ebx
  char *v4; // [esp+Ch] [ebp-2Ch]
  char *v5; // [esp+20h] [ebp-18h]

  if ( problem == -1 )
    v5 = gettext("invalid argument %s for %s");
  else
    v5 = gettext("ambiguous argument %s for %s");
  v3 = _ZNK6idVec58ToStringEi(1, context);
  v4 = quotearg_n_style(0, locale_quoting_style, value);
  error(0, 0, v5, v4, v3);
}

//----- (08051BA8) --------------------------------------------------------
void __cdecl argmatch_valid(const char *const *arglist, const char *vallist, size_t valsize)
{
  char *v3; // eax
  const char *last_val; // [esp+20h] [ebp-8h]
  size_t i; // [esp+24h] [ebp-4h]

  last_val = 0;
  v3 = gettext("Valid arguments are:");
  fprintf(stderr, v3);
  for ( i = 0; arglist[i]; ++i )
  {
    if ( i && !memcmp(last_val, &vallist[i * valsize], valsize) )
    {
      fprintf(stderr, ", `%s'", arglist[i]);
    }
    else
    {
      fprintf(stderr, "\n  - `%s'", arglist[i]);
      last_val = &vallist[i * valsize];
    }
  }
  putc_unlocked(10, stderr);
}

//----- (08051C92) --------------------------------------------------------
ptrdiff_t __cdecl _xargmatch_internal(const char *context, const char *arg, const char *const *arglist, const char *vallist, size_t valsize, argmatch_exit_fn exit_fn)
{
  int res; // [esp+24h] [ebp-4h]

  res = argmatch(arg, arglist, vallist, valsize);
  if ( res >= 0 )
    return res;
  argmatch_invalid(context, arg, res);
  argmatch_valid(arglist, vallist, valsize);
  exit_fn();
  return -1;
}

//----- (08051D0C) --------------------------------------------------------
const char *__cdecl argmatch_to_argument(const char *value, const char *const *arglist, const char *vallist, size_t valsize)
{
  size_t i; // [esp+24h] [ebp-4h]

  for ( i = 0; arglist[i]; ++i )
  {
    if ( !memcmp(value, &vallist[i * valsize], valsize) )
      return arglist[i];
  }
  return 0;
}

//----- (08051D70) --------------------------------------------------------
char *__cdecl last_component(const char *name)
{
  const char *p; // [esp+4h] [ebp-Ch]
  bool saw_slash; // [esp+Fh] [ebp-1h]

  saw_slash = 0;
  while ( *name == 47 )
    ++name;
  for ( p = name; *p; ++p )
  {
    if ( *p == 47 )
    {
      saw_slash = 1;
    }
    else if ( saw_slash )
    {
      name = p;
      saw_slash = 0;
    }
  }
  return (char *)name;
}

//----- (08051DCB) --------------------------------------------------------
char *__cdecl base_name(const char *name)
{
  size_t v2; // [esp+4h] [ebp-24h]
  char *v3; // [esp+14h] [ebp-14h]
  size_t length; // [esp+20h] [ebp-8h]
  char *base; // [esp+24h] [ebp-4h]

  base = last_component(name);
  if ( *base )
  {
    length = base_len(base);
    if ( base[length] == 47 )
      ++length;
    v3 = xstrndup(base, length);
  }
  else
  {
    v2 = base_len(name);
    v3 = xstrndup(name, v2);
  }
  return v3;
}

//----- (08051E43) --------------------------------------------------------
size_t __cdecl base_len(const char *name)
{
  size_t len; // [esp+14h] [ebp-4h]

  for ( len = strlen(name); len > 1 && name[len - 1] == 47; --len )
    ;
  return len;
}

//----- (08051E80) --------------------------------------------------------
void __cdecl close_stdout_set_file_name(const char *file)
{
  file_name = file;
}

//----- (08051E8D) --------------------------------------------------------
void close_stdout()
{
  char *v0; // ebx
  int *v1; // eax
  int *v2; // eax
  char *write_error; // [esp+20h] [ebp-8h]

  if ( close_stream(stdout) )
  {
    write_error = gettext("write error");
    if ( file_name )
    {
      v0 = quotearg_colon(file_name);
      v1 = __errno_location();
      error(0, *v1, "%s: %s", v0, write_error);
    }
    else
    {
      v2 = __errno_location();
      error(0, *v2, "%s", write_error);
    }
    _exit(exit_failure);
  }
  if ( close_stream(stderr) )
    _exit(exit_failure);
}

//----- (08051F54) --------------------------------------------------------
int __cdecl file_has_acl(const char *name, const stat *sb)
{
  return 0;
}

//----- (08051F60) --------------------------------------------------------
char __cdecl ftypelet(mode_t bits)
{
  switch ( bits & 0xF000 )
  {
    case 0x8000u:
      return 45;
    case 0x4000u:
      return 100;
    case 0x6000u:
      return 98;
    case 0x2000u:
      return 99;
    case 0xA000u:
      return 108;
    case 0x1000u:
      return 112;
    case 0xC000u:
      return 115;
  }
  return 63;
}

//----- (08052006) --------------------------------------------------------
void __cdecl strmode(mode_t mode, char *str)
{
  char v2; // [esp+Bh] [ebp-41h]
  char v3; // [esp+13h] [ebp-39h]
  char v4; // [esp+19h] [ebp-33h]
  char v5; // [esp+1Ah] [ebp-32h]
  char v6; // [esp+1Bh] [ebp-31h]
  char v7; // [esp+23h] [ebp-29h]
  char v8; // [esp+2Bh] [ebp-21h]
  char v9; // [esp+31h] [ebp-1Bh]
  char v10; // [esp+32h] [ebp-1Ah]
  char v11; // [esp+33h] [ebp-19h]
  char v12; // [esp+3Bh] [ebp-11h]
  char v13; // [esp+43h] [ebp-9h]
  char v14; // [esp+49h] [ebp-3h]
  char v15; // [esp+4Ah] [ebp-2h]
  char v16; // [esp+4Bh] [ebp-1h]

  *str = ftypelet(mode);
  if ( (mode & 0x100) != 0 )
    v2 = 114;
  else
    v2 = 45;
  str[1] = v2;
  if ( (mode & 0x80) != 0 )
    v3 = 119;
  else
    v3 = 45;
  str[2] = v3;
  if ( (mode & 0x800) != 0 )
  {
    if ( (mode & 0x40) != 0 )
      v5 = 115;
    else
      v5 = 83;
    v4 = v5;
  }
  else
  {
    if ( (mode & 0x40) != 0 )
      v6 = 120;
    else
      v6 = 45;
    v4 = v6;
  }
  str[3] = v4;
  if ( (mode & 0x20) != 0 )
    v7 = 114;
  else
    v7 = 45;
  str[4] = v7;
  if ( (mode & 0x10) != 0 )
    v8 = 119;
  else
    v8 = 45;
  str[5] = v8;
  if ( (mode & 0x400) != 0 )
  {
    if ( (mode & 8) != 0 )
      v10 = 115;
    else
      v10 = 83;
    v9 = v10;
  }
  else
  {
    if ( (mode & 8) != 0 )
      v11 = 120;
    else
      v11 = 45;
    v9 = v11;
  }
  str[6] = v9;
  if ( (mode & 4) != 0 )
    v12 = 114;
  else
    v12 = 45;
  str[7] = v12;
  if ( (mode & 2) != 0 )
    v13 = 119;
  else
    v13 = 45;
  str[8] = v13;
  if ( (mode & 0x200) != 0 )
  {
    if ( (mode & 1) != 0 )
      v15 = 116;
    else
      v15 = 84;
    v14 = v15;
  }
  else
  {
    if ( (mode & 1) != 0 )
      v16 = 120;
    else
      v16 = 45;
    v14 = v16;
  }
  str[9] = v14;
  str[10] = 32;
  str[11] = 0;
}

//----- (0805221C) --------------------------------------------------------
void __cdecl filemodestring(const stat *statp, char *str)
{
  strmode(statp->st_mode, str);
}

//----- (0805223C) --------------------------------------------------------
const char *__cdecl longest_relative_suffix(const char *f)
{
  while ( *f == 47 )
    ++f;
  return f;
}

//----- (08052254) --------------------------------------------------------
char *__cdecl mfile_name_concat(const char *dir, const char *abase, char **base_in_result)
{
  _BOOL4 v4; // [esp+10h] [ebp-28h]
  char *pa; // [esp+18h] [ebp-20h]
  char *p; // [esp+18h] [ebp-20h]
  char *p_concat; // [esp+1Ch] [ebp-1Ch]
  size_t baselen; // [esp+20h] [ebp-18h]
  const char *base; // [esp+24h] [ebp-14h]
  size_t dirlen; // [esp+2Ch] [ebp-Ch]
  size_t dirbaselen; // [esp+30h] [ebp-8h]
  char *dirbase; // [esp+34h] [ebp-4h]

  dirbase = last_component(dir);
  dirbaselen = base_len(dirbase);
  dirlen = dirbaselen + dirbase - dir;
  v4 = dirbaselen && dirbase[dirbaselen - 1] != 47;
  base = longest_relative_suffix(abase);
  baselen = strlen(base);
  p_concat = (char *)malloc(baselen + v4 + dirlen + 1);
  if ( !p_concat )
    return 0;
  pa = (char *)mempcpy(p_concat, dir, dirlen);
  *pa = 47;
  p = &pa[v4];
  if ( base_in_result )
    *base_in_result = &p[-(*abase == 47)];
  *(_BYTE *)mempcpy(p, base, baselen) = 0;
  return p_concat;
}
// 804966C: using guessed type int __cdecl mempcpy(_DWORD, _DWORD, _DWORD);

//----- (0805236D) --------------------------------------------------------
char *__cdecl file_name_concat(const char *dir, const char *abase, char **base_in_result)
{
  char *p; // [esp+24h] [ebp-4h]

  p = mfile_name_concat(dir, abase, base_in_result);
  if ( !p )
    xalloc_die();
  return p;
}

//----- (080523A0) --------------------------------------------------------
bool __cdecl hard_locale(int category)
{
  char *p; // [esp+10h] [ebp-8h]
  bool hard; // [esp+17h] [ebp-1h]

  hard = 1;
  p = setlocale(category, 0);
  if ( p && (!strcmp(p, "C") || !strcmp(p, "POSIX")) )
    hard = 0;
  return hard;
}

//----- (08052400) --------------------------------------------------------
size_t __cdecl hash_get_n_buckets(const Hash_table *table)
{
  return table->n_buckets;
}

//----- (0805240B) --------------------------------------------------------
size_t __cdecl hash_get_n_buckets_used(const Hash_table *table)
{
  return table->n_buckets_used;
}

//----- (08052416) --------------------------------------------------------
size_t __cdecl hash_get_n_entries(const Hash_table *table)
{
  return table->n_entries;
}

//----- (08052421) --------------------------------------------------------
size_t __cdecl hash_get_max_bucket_length(const Hash_table *table)
{
  size_t bucket_length; // [esp+0h] [ebp-10h]
  const hash_entry *cursor; // [esp+4h] [ebp-Ch]
  size_t max_bucket_length; // [esp+8h] [ebp-8h]
  hash_entry *bucket; // [esp+Ch] [ebp-4h]

  max_bucket_length = 0;
  for ( bucket = table->bucket; table->bucket_limit > bucket; ++bucket )
  {
    if ( bucket->data )
    {
      cursor = bucket;
      for ( bucket_length = 1; ; ++bucket_length )
      {
        cursor = cursor->next;
        if ( !cursor )
          break;
      }
      if ( bucket_length > max_bucket_length )
        max_bucket_length = bucket_length;
    }
  }
  return max_bucket_length;
}

//----- (08052485) --------------------------------------------------------
bool __cdecl hash_table_ok(const Hash_table *table)
{
  const hash_entry *cursor; // [esp+4h] [ebp-10h]
  size_t n_entries; // [esp+8h] [ebp-Ch]
  size_t n_buckets_used; // [esp+Ch] [ebp-8h]
  hash_entry *bucket; // [esp+10h] [ebp-4h]

  n_buckets_used = 0;
  n_entries = 0;
  for ( bucket = table->bucket; table->bucket_limit > bucket; ++bucket )
  {
    if ( bucket->data )
    {
      cursor = bucket;
      ++n_buckets_used;
      ++n_entries;
      while ( 1 )
      {
        cursor = cursor->next;
        if ( !cursor )
          break;
        ++n_entries;
      }
    }
  }
  return table->n_buckets_used == n_buckets_used && table->n_entries == n_entries;
}

//----- (08052504) --------------------------------------------------------
void __cdecl hash_print_statistics(const Hash_table *table, FILE *stream)
{
  size_t max_bucket_length; // [esp+18h] [ebp-10h]
  size_t n_buckets_used; // [esp+1Ch] [ebp-Ch]
  size_t n_buckets; // [esp+20h] [ebp-8h]
  size_t n_entries; // [esp+24h] [ebp-4h]

  n_entries = hash_get_n_entries(table);
  n_buckets = hash_get_n_buckets(table);
  n_buckets_used = hash_get_n_buckets_used(table);
  max_bucket_length = hash_get_max_bucket_length(table);
  fprintf(stream, "# entries:         %lu\n", n_entries);
  fprintf(stream, "# buckets:         %lu\n", n_buckets);
  fprintf(
    stream,
    "# buckets used:    %lu (%.2f%%)\n",
    n_buckets_used,
    (double)((long double)n_buckets_used * 100.0 / (long double)n_buckets));
  fprintf(stream, "max bucket length: %lu\n", max_bucket_length);
}

//----- (080525DC) --------------------------------------------------------
void *__cdecl hash_lookup(const Hash_table *table, const void *entry)
{
  hash_entry *v2; // ebx
  const hash_entry *cursor; // [esp+1Ch] [ebp-Ch]
  const hash_entry *bucket; // [esp+20h] [ebp-8h]

  v2 = table->bucket;
  bucket = &v2[table->hasher(entry, table->n_buckets)];
  if ( table->bucket_limit <= bucket )
    abort();
  if ( !bucket->data )
    return 0;
  for ( cursor = bucket; cursor; cursor = cursor->next )
  {
    if ( table->comparator(entry, cursor->data) )
      return cursor->data;
  }
  return 0;
}

//----- (08052677) --------------------------------------------------------
void *__cdecl hash_get_first(const Hash_table *table)
{
  hash_entry *bucket; // [esp+14h] [ebp-4h]

  if ( !table->n_entries )
    return 0;
  for ( bucket = table->bucket; ; ++bucket )
  {
    if ( table->bucket_limit <= bucket )
      abort();
    if ( bucket->data )
      break;
  }
  return bucket->data;
}

//----- (080526C6) --------------------------------------------------------
void *__cdecl hash_get_next(const Hash_table *table, const void *entry)
{
  hash_entry *v2; // ebx
  const hash_entry *cursor; // [esp+1Ch] [ebp-Ch]
  const hash_entry *bucket; // [esp+20h] [ebp-8h]

  v2 = table->bucket;
  bucket = &v2[table->hasher(entry, table->n_buckets)];
  if ( table->bucket_limit <= bucket )
    abort();
  for ( cursor = bucket; cursor; cursor = cursor->next )
  {
    if ( cursor->data == entry && cursor->next )
      return cursor->next->data;
  }
  while ( ++bucket < table->bucket_limit )
  {
    if ( bucket->data )
      return bucket->data;
  }
  return 0;
}

//----- (0805276F) --------------------------------------------------------
size_t __cdecl hash_get_entries(const Hash_table *table, void **buffer, size_t buffer_size)
{
  const hash_entry *cursor; // [esp+8h] [ebp-Ch]
  hash_entry *bucket; // [esp+Ch] [ebp-8h]
  size_t counter; // [esp+10h] [ebp-4h]

  counter = 0;
  for ( bucket = table->bucket; table->bucket_limit > bucket; ++bucket )
  {
    if ( bucket->data )
    {
      for ( cursor = bucket; cursor; cursor = cursor->next )
      {
        if ( counter >= buffer_size )
          return counter;
        buffer[counter++] = cursor->data;
      }
    }
  }
  return counter;
}

//----- (080527E6) --------------------------------------------------------
size_t __cdecl hash_do_for_each(const Hash_table *table, Hash_processor processor, void *processor_data)
{
  const hash_entry *cursor; // [esp+1Ch] [ebp-Ch]
  hash_entry *bucket; // [esp+20h] [ebp-8h]
  size_t counter; // [esp+24h] [ebp-4h]

  counter = 0;
  for ( bucket = table->bucket; table->bucket_limit > bucket; ++bucket )
  {
    if ( bucket->data )
    {
      for ( cursor = bucket; cursor; cursor = cursor->next )
      {
        if ( !processor(cursor->data, processor_data) )
          return counter;
        ++counter;
      }
    }
  }
  return counter;
}

//----- (0805285E) --------------------------------------------------------
size_t __cdecl hash_string(const char *string, size_t n_buckets)
{
  unsigned int value; // [esp+10h] [ebp-8h]

  value = 0;
  while ( *string )
    value = (*(unsigned __int8 *)string++ + 31 * value) % n_buckets;
  return value;
}

//----- (080528AA) --------------------------------------------------------
bool __cdecl is_prime(size_t candidate)
{
  size_t square; // [esp+14h] [ebp-8h]
  size_t divisor; // [esp+18h] [ebp-4h]
  size_t divisora; // [esp+18h] [ebp-4h]

  divisor = 3;
  square = 9;
  while ( square < candidate && candidate % divisor )
  {
    divisora = divisor + 1;
    square += 4 * divisora;
    divisor = divisora + 1;
  }
  return candidate % divisor != 0;
}

//----- (0805290D) --------------------------------------------------------
size_t __cdecl next_prime(size_t candidate)
{
  size_t candidatea; // [esp+Ch] [ebp+8h]

  if ( candidate <= 9 )
    candidate = 10;
  for ( candidatea = candidate | 1; !is_prime(candidatea); candidatea += 2 )
    ;
  return candidatea;
}

//----- (08052941) --------------------------------------------------------
void __cdecl hash_reset_tuning(Hash_tuning *tuning)
{
  tuning->shrink_threshold = 0.0;
  tuning->shrink_factor = 1.0;
  tuning->growth_threshold = 0.80000001;
  tuning->growth_factor = 1.414;
  tuning->is_n_buckets = 0;
}

//----- (08052978) --------------------------------------------------------
bool __cdecl check_tuning(Hash_table *table)
{
  const Hash_tuning *tuning; // [esp+1Ch] [ebp-4h]

  tuning = table->tuning;
  if ( tuning->growth_threshold > 0.1
    && 1.0 - 0.1 > tuning->growth_threshold
    && tuning->growth_factor > 0.1 + 1.0
    && tuning->shrink_threshold >= 0.0
    && tuning->shrink_factor > tuning->shrink_threshold + 0.1
    && tuning->shrink_factor <= 1.0
    && tuning->growth_threshold > tuning->shrink_threshold + 0.1 )
  {
    return 1;
  }
  table->tuning = &default_tuning;
  return 0;
}

//----- (08052A2A) --------------------------------------------------------
Hash_table *__cdecl hash_initialize(size_t candidate, const Hash_tuning *tuning, Hash_hasher hasher, Hash_comparator comparator, Hash_data_freer data_freer)
{
  float new_candidate; // [esp+30h] [ebp-8h]
  Hash_table *table; // [esp+34h] [ebp-4h]

  if ( hasher && comparator )
  {
    table = (Hash_table *)malloc(0x28u);
    if ( !table )
      return 0;
    if ( !tuning )
      tuning = &default_tuning;
    table->tuning = tuning;
    if ( check_tuning(table) )
    {
      if ( !tuning->is_n_buckets )
      {
        new_candidate = (long double)candidate / tuning->growth_threshold;
        if ( new_candidate >= 4294967300.0 )
          goto fail;
        candidate = (__int64)new_candidate;
      }
      if ( candidate <= 0x1FFFFFFF )
      {
        table->n_buckets = next_prime(candidate);
        if ( table->n_buckets <= 0x1FFFFFFF )
        {
          table->bucket = (hash_entry *)calloc(table->n_buckets, 8u);
          if ( table->bucket )
          {
            table->bucket_limit = &table->bucket[table->n_buckets];
            table->n_buckets_used = 0;
            table->n_entries = 0;
            table->hasher = hasher;
            table->comparator = comparator;
            table->data_freer = data_freer;
            table->free_entry_list = 0;
            return table;
          }
        }
      }
    }
fail:
    free(table);
    return 0;
  }
  return 0;
}

//----- (08052BB8) --------------------------------------------------------
void __cdecl hash_clear(Hash_table *table)
{
  hash_entry *next; // [esp+Ch] [ebp-Ch]
  hash_entry *cursor; // [esp+10h] [ebp-8h]
  hash_entry *bucket; // [esp+14h] [ebp-4h]

  for ( bucket = table->bucket; table->bucket_limit > bucket; ++bucket )
  {
    if ( bucket->data )
    {
      for ( cursor = bucket->next; cursor; cursor = next )
      {
        if ( table->data_freer )
          table->data_freer(cursor->data);
        cursor->data = 0;
        next = cursor->next;
        cursor->next = table->free_entry_list;
        table->free_entry_list = cursor;
      }
      if ( table->data_freer )
        table->data_freer(bucket->data);
      bucket->data = 0;
      bucket->next = 0;
    }
  }
  table->n_buckets_used = 0;
  table->n_entries = 0;
}

//----- (08052C86) --------------------------------------------------------
void __cdecl hash_free(Hash_table *table)
{
  hash_entry *next; // [esp+Ch] [ebp-Ch]
  hash_entry *nexta; // [esp+Ch] [ebp-Ch]
  hash_entry *cursor; // [esp+10h] [ebp-8h]
  hash_entry *cursora; // [esp+10h] [ebp-8h]
  hash_entry *cursorb; // [esp+10h] [ebp-8h]
  hash_entry *bucket; // [esp+14h] [ebp-4h]
  hash_entry *bucketa; // [esp+14h] [ebp-4h]

  if ( table->data_freer && table->n_entries )
  {
    for ( bucket = table->bucket; table->bucket_limit > bucket; ++bucket )
    {
      if ( bucket->data )
      {
        for ( cursor = bucket; cursor; cursor = cursor->next )
          table->data_freer(cursor->data);
      }
    }
  }
  for ( bucketa = table->bucket; table->bucket_limit > bucketa; ++bucketa )
  {
    for ( cursora = bucketa->next; cursora; cursora = next )
    {
      next = cursora->next;
      free(cursora);
    }
  }
  for ( cursorb = table->free_entry_list; cursorb; cursorb = nexta )
  {
    nexta = cursorb->next;
    free(cursorb);
  }
  free(table->bucket);
  free(table);
}

//----- (08052D72) --------------------------------------------------------
hash_entry *__cdecl allocate_entry(Hash_table *table)
{
  hash_entry *newa; // [esp+14h] [ebp-4h]

  if ( !table->free_entry_list )
    return (hash_entry *)malloc(8u);
  newa = table->free_entry_list;
  table->free_entry_list = newa->next;
  return newa;
}

//----- (08052DAD) --------------------------------------------------------
void __cdecl free_entry(Hash_table *table, hash_entry *entry)
{
  entry->data = 0;
  entry->next = table->free_entry_list;
  table->free_entry_list = entry;
}

//----- (08052DD0) --------------------------------------------------------
void *__cdecl hash_find_entry(Hash_table *table, const void *entry, hash_entry **bucket_head, bool delete)
{
  hash_entry *v4; // ebx
  hash_entry *v5; // edx
  void *v7; // [esp+Ch] [ebp-2Ch]
  hash_entry *next_0; // [esp+1Ch] [ebp-1Ch]
  void *data_0; // [esp+20h] [ebp-18h]
  hash_entry *next; // [esp+24h] [ebp-14h]
  void *data; // [esp+28h] [ebp-10h]
  hash_entry *cursor; // [esp+2Ch] [ebp-Ch]
  hash_entry *bucket; // [esp+30h] [ebp-8h]

  v4 = table->bucket;
  bucket = &v4[table->hasher(entry, table->n_buckets)];
  if ( table->bucket_limit <= bucket )
    abort();
  *bucket_head = bucket;
  if ( !bucket->data )
    return 0;
  if ( table->comparator(entry, bucket->data) )
  {
    data = bucket->data;
    if ( delete )
    {
      if ( bucket->next )
      {
        next = bucket->next;
        v5 = next->next;
        bucket->data = next->data;
        bucket->next = v5;
        free_entry(table, next);
      }
      else
      {
        bucket->data = 0;
      }
    }
    v7 = data;
  }
  else
  {
    for ( cursor = bucket; ; cursor = cursor->next )
    {
      if ( !cursor->next )
        return 0;
      if ( table->comparator(entry, cursor->next->data) )
        break;
    }
    data_0 = cursor->next->data;
    if ( delete )
    {
      next_0 = cursor->next;
      cursor->next = next_0->next;
      free_entry(table, next_0);
    }
    v7 = data_0;
  }
  return v7;
}

//----- (08052F2D) --------------------------------------------------------
bool __cdecl hash_rehash(Hash_table *table, size_t candidate)
{
  hash_entry *v2; // ebx
  hash_entry *new_entry; // [esp+28h] [ebp-20h]
  hash_entry *new_bucket; // [esp+2Ch] [ebp-1Ch]
  void *data; // [esp+30h] [ebp-18h]
  hash_entry *next; // [esp+34h] [ebp-14h]
  hash_entry *cursor; // [esp+38h] [ebp-10h]
  hash_entry *bucket; // [esp+3Ch] [ebp-Ch]
  Hash_table *new_table; // [esp+40h] [ebp-8h]

  new_table = hash_initialize(candidate, table->tuning, table->hasher, table->comparator, table->data_freer);
  if ( !new_table )
    return 0;
  new_table->free_entry_list = table->free_entry_list;
  for ( bucket = table->bucket; table->bucket_limit > bucket; ++bucket )
  {
    if ( bucket->data )
    {
      for ( cursor = bucket; cursor; cursor = next )
      {
        data = cursor->data;
        v2 = new_table->bucket;
        new_bucket = &v2[new_table->hasher(cursor->data, new_table->n_buckets)];
        if ( new_table->bucket_limit <= new_bucket )
          abort();
        next = cursor->next;
        if ( new_bucket->data )
        {
          if ( cursor == bucket )
          {
            new_entry = allocate_entry(new_table);
            if ( !new_entry )
              return 0;
            new_entry->data = data;
            new_entry->next = new_bucket->next;
            new_bucket->next = new_entry;
          }
          else
          {
            cursor->next = new_bucket->next;
            new_bucket->next = cursor;
          }
        }
        else
        {
          new_bucket->data = data;
          ++new_table->n_buckets_used;
          if ( cursor != bucket )
            free_entry(new_table, cursor);
        }
      }
    }
  }
  free(table->bucket);
  table->bucket = new_table->bucket;
  table->bucket_limit = new_table->bucket_limit;
  table->n_buckets = new_table->n_buckets;
  table->n_buckets_used = new_table->n_buckets_used;
  table->free_entry_list = new_table->free_entry_list;
  free(new_table);
  return 1;
}

//----- (08053109) --------------------------------------------------------
void *__cdecl hash_insert(Hash_table *table, const void *entry)
{
  long double v2; // fst7
  float v5; // [esp+24h] [ebp-34h]
  const Hash_tuning *tuning; // [esp+48h] [ebp-10h]
  hash_entry *new_entry; // [esp+4Ch] [ebp-Ch]
  hash_entry *bucket; // [esp+50h] [ebp-8h] BYREF
  void *data; // [esp+54h] [ebp-4h]

  if ( !entry )
    abort();
  data = hash_find_entry(table, entry, &bucket, 0);
  if ( data )
    return data;
  if ( !bucket->data )
  {
    bucket->data = (void *)entry;
    ++table->n_entries;
    if ( (long double)++table->n_buckets_used > table->tuning->growth_threshold * (long double)table->n_buckets )
    {
      check_tuning(table);
      if ( (long double)table->n_buckets_used > table->tuning->growth_threshold * (long double)table->n_buckets )
      {
        tuning = table->tuning;
        if ( tuning->is_n_buckets )
          v2 = (long double)table->n_buckets * tuning->growth_factor;
        else
          v2 = (long double)table->n_buckets * tuning->growth_factor * tuning->growth_threshold;
        v5 = v2;
        if ( v5 >= 4294967300.0 )
          return 0;
        if ( !hash_rehash(table, (__int64)v5) )
          entry = 0;
      }
    }
    return (void *)entry;
  }
  new_entry = allocate_entry(table);
  if ( !new_entry )
    return 0;
  new_entry->data = (void *)entry;
  new_entry->next = bucket->next;
  bucket->next = new_entry;
  ++table->n_entries;
  return (void *)entry;
}

//----- (08053324) --------------------------------------------------------
void *__cdecl hash_delete(Hash_table *table, const void *entry)
{
  long double v2; // fst7
  const Hash_tuning *tuning; // [esp+3Ch] [ebp-Ch]
  hash_entry *bucket; // [esp+40h] [ebp-8h] BYREF
  void *data; // [esp+44h] [ebp-4h]

  data = hash_find_entry(table, entry, &bucket, 1);
  if ( !data )
    return 0;
  --table->n_entries;
  if ( !bucket->data
    && table->tuning->shrink_threshold * (long double)table->n_buckets > (long double)--table->n_buckets_used )
  {
    check_tuning(table);
    if ( table->tuning->shrink_threshold * (long double)table->n_buckets > (long double)table->n_buckets_used )
    {
      tuning = table->tuning;
      if ( tuning->is_n_buckets )
        v2 = (long double)table->n_buckets * tuning->shrink_factor;
      else
        v2 = (long double)table->n_buckets * tuning->shrink_factor * tuning->growth_threshold;
      hash_rehash(table, (__int64)v2);
    }
  }
  return data;
}

//----- (080534C8) --------------------------------------------------------
long double __cdecl adjust_value(int inexact_style, long double value)
{
  __int64 v2; // rax
  _BOOL4 v4; // [esp+3Ch] [ebp-2Ch]
  uintmax_t u; // [esp+58h] [ebp-10h]

  if ( inexact_style != 1 && value < 1.8446744073709551615e19 )
  {
    if ( value >= 9.223372036854775808e18 )
    {
      v2 = (__int64)(value - 9.223372036854775808e18);
      HIDWORD(v2) ^= 0x80000000;
      u = v2;
    }
    else
    {
      u = (__int64)value;
    }
    v4 = !inexact_style && (long double)u != value;
    value = (long double)(u + v4);
  }
  return value;
}

//----- (08053603) --------------------------------------------------------
char *__cdecl group_number(char *number, size_t numberlen, const char *grouping, const char *thousands_sep)
{
  size_t v5; // [esp+14h] [ebp-54h]
  char *d; // [esp+18h] [ebp-50h]
  char *da; // [esp+18h] [ebp-50h]
  size_t i; // [esp+2Ch] [ebp-3Ch]
  size_t thousands_seplen; // [esp+30h] [ebp-38h]
  size_t grouplen; // [esp+34h] [ebp-34h]
  unsigned __int8 g; // [esp+3Ah] [ebp-2Eh]
  char buf[41]; // [esp+3Bh] [ebp-2Dh] BYREF
  unsigned int v14; // [esp+64h] [ebp-4h]

  v14 = __readgsdword(0x14u);
  grouplen = -1;
  thousands_seplen = strlen(thousands_sep);
  i = numberlen;
  memcpy(buf, number, numberlen);
  for ( d = &number[numberlen]; ; memcpy(d, thousands_sep, thousands_seplen) )
  {
    g = *grouping;
    if ( *grouping )
    {
      if ( g > 0x7Eu )
        v5 = i;
      else
        v5 = g;
      grouplen = v5;
      ++grouping;
    }
    if ( i < grouplen )
      grouplen = i;
    da = &d[-grouplen];
    i -= grouplen;
    memcpy(da, &buf[i], grouplen);
    if ( !i )
      break;
    d = &da[-thousands_seplen];
  }
  return da;
}

//----- (0805370F) --------------------------------------------------------
char *__cdecl human_readable(uintmax_t n, char *buf, int opts, uintmax_t from_block_size, uintmax_t to_block_size)
{
  uintmax_t v5; // rax
  int v6; // ecx
  __int64 v7; // rax
  long double v8; // fst7
  long double v9; // fst7
  long double v10; // fst7
  unsigned int v12; // [esp+2Ch] [ebp-18Ch]
  unsigned int v13; // [esp+74h] [ebp-144h]
  _BOOL4 v14; // [esp+78h] [ebp-140h]
  int v15; // [esp+7Ch] [ebp-13Ch]
  _BOOL4 v16; // [esp+B0h] [ebp-108h]
  int v17; // [esp+B4h] [ebp-104h]
  bool v18; // [esp+C7h] [ebp-F1h]
  bool v19; // [esp+C8h] [ebp-F0h]
  bool v20; // [esp+CFh] [ebp-E9h]
  bool v21; // [esp+D0h] [ebp-E8h]
  char v22; // [esp+D7h] [ebp-E1h]
  long double e; // [esp+F0h] [ebp-C8h]
  long double damt; // [esp+100h] [ebp-B8h]
  long double damta; // [esp+100h] [ebp-B8h]
  uintmax_t power; // [esp+120h] [ebp-98h]
  unsigned __int64 r2; // [esp+128h] [ebp-90h]
  uintmax_t r10_0; // [esp+130h] [ebp-88h]
  uintmax_t amt; // [esp+148h] [ebp-70h]
  unsigned int r2_0; // [esp+154h] [ebp-64h]
  size_t nonintegerlen; // [esp+15Ch] [ebp-5Ch]
  size_t buflen; // [esp+160h] [ebp-58h]
  size_t pointlen; // [esp+164h] [ebp-54h]
  struct lconv *l; // [esp+168h] [ebp-50h]
  const char *thousands_sep; // [esp+16Ch] [ebp-4Ch]
  const char *grouping; // [esp+170h] [ebp-48h]
  size_t decimal_pointlen; // [esp+174h] [ebp-44h]
  const char *decimal_point; // [esp+178h] [ebp-40h]
  int rounding; // [esp+17Ch] [ebp-3Ch]
  const char *integerlim; // [esp+180h] [ebp-38h]
  char *psuffix; // [esp+184h] [ebp-34h]
  char *p; // [esp+188h] [ebp-30h]
  char *pa; // [esp+188h] [ebp-30h]
  int exponent; // [esp+190h] [ebp-28h]
  int tenths; // [esp+194h] [ebp-24h]
  int inexact_style; // [esp+19Ch] [ebp-1Ch]

  inexact_style = opts & 3;
  if ( (opts & 0x20) != 0 )
    v13 = 1024;
  else
    v13 = 1000;
  exponent = -1;
  decimal_point = (const char *)&unk_80618F9;
  decimal_pointlen = 1;
  thousands_sep = (const char *)&unk_80618FB;
  l = localeconv();
  pointlen = strlen(l->decimal_point);
  if ( pointlen && pointlen <= 0x10 )
  {
    decimal_point = l->decimal_point;
    decimal_pointlen = pointlen;
  }
  grouping = l->grouping;
  if ( strlen(l->thousands_sep) <= 0x10 )
    thousands_sep = l->thousands_sep;
  psuffix = buf + 648;
  p = buf + 648;
  if ( to_block_size > from_block_size )
  {
    if ( from_block_size && !(to_block_size % from_block_size) )
    {
      v5 = n % (to_block_size / from_block_size);
      v6 = 10 * HIDWORD(v5);
      v7 = 10LL * (unsigned int)v5;
      LODWORD(r10_0) = v7;
      HIDWORD(r10_0) = HIDWORD(v7) + v6;
      r2 = 2 * (__PAIR64__(HIDWORD(v7) + v6, v7) % (to_block_size / from_block_size));
      amt = n / (to_block_size / from_block_size);
      tenths = r10_0 / (to_block_size / from_block_size);
      if ( r2 >= to_block_size / from_block_size )
      {
        if ( to_block_size / from_block_size >= r2 )
          v15 = 2;
        else
          v15 = 3;
        v14 = v15;
      }
      else
      {
        v14 = r2 != 0;
      }
      rounding = v14;
use_integer_arithmetic:
      if ( (opts & 0x10) != 0 )
      {
        exponent = 0;
        if ( v13 <= amt )
        {
          do
          {
            v12 = 10 * (amt % v13) + tenths;
            r2_0 = 2 * (v12 % v13) + (rounding >> 1);
            amt /= v13;
            tenths = v12 / v13;
            if ( r2_0 >= v13 )
            {
              if ( r2_0 + rounding <= v13 )
                v17 = 2;
              else
                v17 = 3;
              v16 = v17;
            }
            else
            {
              v16 = r2_0 + rounding != 0;
            }
            rounding = v16;
            ++exponent;
          }
          while ( v13 <= amt && exponent < 8 );
          if ( amt <= 9 )
          {
            if ( inexact_style == 1 )
            {
              v18 = (int)(v16 + ((v12 / v13) & 1)) > 2;
            }
            else
            {
              v19 = (opts & 3) == 0 && v16 > 0;
              v18 = v19;
            }
            if ( v18 )
            {
              ++tenths;
              rounding = 0;
              if ( tenths == 10 )
              {
                ++amt;
                tenths = 0;
              }
            }
            if ( amt <= 9 && (tenths || (opts & 8) == 0) )
            {
              buf[647] = tenths + 48;
              p = &buf[-decimal_pointlen + 647];
              memcpy(p, decimal_point, decimal_pointlen);
              rounding = 0;
              tenths = 0;
            }
          }
        }
      }
      if ( inexact_style == 1 )
      {
        v20 = tenths + (rounding + (amt & 1) != 0) > 5;
      }
      else
      {
        v21 = (opts & 3) == 0 && tenths + rounding > 0;
        v20 = v21;
      }
      if ( v20 )
      {
        ++amt;
        if ( (opts & 0x10) != 0 && amt == v13 && exponent < 8 )
        {
          ++exponent;
          if ( (opts & 8) == 0 )
          {
            pa = p - 1;
            *pa = 48;
            p = &pa[-decimal_pointlen];
            memcpy(p, decimal_point, decimal_pointlen);
          }
          amt = 1LL;
        }
      }
      integerlim = p;
      do
      {
        *--p = amt % 0xA + 48;
        amt /= 0xAuLL;
      }
      while ( amt );
      goto do_grouping;
    }
  }
  else if ( !(from_block_size % to_block_size) )
  {
    amt = from_block_size / to_block_size * n;
    if ( n == amt / (from_block_size / to_block_size) )
    {
      tenths = 0;
      rounding = 0;
      goto use_integer_arithmetic;
    }
  }
  damt = (long double)from_block_size / (long double)to_block_size * (long double)n;
  if ( (opts & 0x10) != 0 )
  {
    e = 1.0;
    exponent = 0;
    do
    {
      e = (long double)v13 * e;
      ++exponent;
    }
    while ( damt >= (long double)v13 * e && exponent < 8 );
    damta = damt / e;
    v9 = adjust_value(inexact_style, damta);
    sprintf(buf, "%.1Lf", v9);
    buflen = strlen(buf);
    nonintegerlen = decimal_pointlen + 1;
    if ( decimal_pointlen + 1 + ((opts & 0x20) == 0) + 1 < buflen || (opts & 8) != 0 && buf[buflen - 1] == 48 )
    {
      v10 = adjust_value(inexact_style, damta * 10.0);
      sprintf(buf, "%.0Lf", v10 / 10.0);
      buflen = strlen(buf);
      nonintegerlen = 0;
    }
  }
  else
  {
    v8 = adjust_value(inexact_style, damt);
    sprintf(buf, "%.0Lf", v8);
    buflen = strlen(buf);
    nonintegerlen = 0;
  }
  p = &psuffix[-buflen];
  memmove(&psuffix[-buflen], buf, buflen);
  integerlim = &psuffix[-nonintegerlen];
do_grouping:
  if ( (opts & 4) != 0 )
    p = group_number(p, integerlim - p, grouping, thousands_sep);
  if ( (opts & 0x80) != 0 )
  {
    if ( exponent < 0 )
    {
      exponent = 0;
      for ( power = 1LL; power < to_block_size; power *= v13 )
      {
        if ( ++exponent == 8 )
          break;
      }
    }
    if ( exponent | opts & 0x100 && (opts & 0x40) != 0 )
    {
      *psuffix = 32;
      psuffix = buf + 649;
    }
    if ( exponent )
    {
      if ( (opts & 0x20) == 0 && exponent == 1 )
        v22 = 107;
      else
        v22 = power_letter[exponent];
      *psuffix++ = v22;
    }
    if ( (opts & 0x100) != 0 )
    {
      if ( (opts & 0x20) != 0 && exponent )
        *psuffix++ = 105;
      *psuffix++ = 66;
    }
  }
  *psuffix = 0;
  return p;
}

//----- (08054394) --------------------------------------------------------
uintmax_t default_block_size()
{
  int v1; // [esp+10h] [ebp-8h]

  if ( getenv("POSIXLY_CORRECT") )
    v1 = 512;
  else
    v1 = 1024;
  return (unsigned int)v1;
}

//----- (080543D0) --------------------------------------------------------
strtol_error_0 __cdecl humblock(const char *spec, uintmax_t *block_size, int *options)
{
  strtol_error_0 e; // [esp+18h] [ebp-10h]
  char *ptr; // [esp+1Ch] [ebp-Ch] BYREF
  int opts; // [esp+20h] [ebp-8h]
  int i; // [esp+24h] [ebp-4h]

  opts = 0;
  if ( !spec )
  {
    spec = getenv("BLOCK_SIZE");
    if ( !spec )
    {
      spec = getenv("BLOCKSIZE");
      if ( !spec )
      {
        *block_size = default_block_size();
LABEL_20:
        *options = opts;
        return 0;
      }
    }
  }
  if ( *spec == 39 )
  {
    opts |= 4u;
    ++spec;
  }
  i = argmatch(spec, block_size_args, (const char *)block_size_opts, 4u);
  if ( i >= 0 )
  {
    opts |= block_size_opts[i];
    *block_size = 1LL;
    goto LABEL_20;
  }
  e = xstrtoumax(spec, &ptr, 0, block_size, "eEgGkKmMpPtTyYzZ0");
  if ( e == LONGINT_OK )
  {
    while ( *spec <= 47 || *spec > 57 )
    {
      if ( spec == ptr )
      {
        opts |= 0x80u;
        if ( *(ptr - 1) == 66 )
          opts |= 0x100u;
        if ( *(ptr - 1) != 66 || *(ptr - 2) == 105 )
          opts |= 0x20u;
        goto LABEL_20;
      }
      ++spec;
    }
    goto LABEL_20;
  }
  *options = 0;
  return e;
}

//----- (08054532) --------------------------------------------------------
strtol_error __cdecl human_options(const char *spec, int *opts, uintmax_t *block_size)
{
  strtol_error e; // [esp+24h] [ebp-4h]

  e = humblock(spec, block_size, opts);
  if ( !*block_size )
  {
    *block_size = default_block_size();
    e = LONGINT_INVALID;
  }
  return e;
}

//----- (0805457C) --------------------------------------------------------
char *__cdecl getuser(uid_t uid)
{
  size_t v1; // eax
  const char *v3; // [esp+10h] [ebp-18h]
  char *v4; // [esp+14h] [ebp-14h]
  passwd *pwent; // [esp+1Ch] [ebp-Ch]
  userid *match; // [esp+20h] [ebp-8h]
  userid *tail; // [esp+24h] [ebp-4h]

  match = 0;
  for ( tail = user_alist; tail; tail = tail->next )
  {
    if ( tail->id.u == uid )
    {
      match = tail;
      break;
    }
  }
  if ( !match )
  {
    pwent = getpwuid(uid);
    if ( pwent )
      v3 = pwent->pw_name;
    else
      v3 = (const char *)&unk_80619AC;
    v1 = strlen(v3);
    match = (userid *)xmalloc(v1 + 9);
    match->id.u = uid;
    strcpy(match->name, v3);
    match->next = user_alist;
    user_alist = match;
  }
  if ( match->name[0] )
    v4 = match->name;
  else
    v4 = 0;
  return v4;
}

//----- (08054651) --------------------------------------------------------
uid_t *__cdecl getuidbyname(const char *user)
{
  size_t v1; // eax
  uid_t *v3; // [esp+14h] [ebp-14h]
  passwd *pwent; // [esp+20h] [ebp-8h]
  userid *tail; // [esp+24h] [ebp-4h]
  userid *taila; // [esp+24h] [ebp-4h]
  userid *tailb; // [esp+24h] [ebp-4h]

  for ( tail = user_alist; tail; tail = tail->next )
  {
    if ( tail->name[0] == *user && !strcmp(tail->name, user) )
      return &tail->id.u;
  }
  for ( taila = nouser_alist; taila; taila = taila->next )
  {
    if ( taila->name[0] == *user && !strcmp(taila->name, user) )
      return 0;
  }
  pwent = getpwnam(user);
  v1 = strlen(user);
  tailb = (userid *)xmalloc(v1 + 9);
  strcpy(tailb->name, user);
  if ( pwent )
  {
    tailb->id.u = pwent->pw_uid;
    tailb->next = user_alist;
    user_alist = tailb;
    v3 = &tailb->id.u;
  }
  else
  {
    tailb->next = nouser_alist;
    nouser_alist = tailb;
    v3 = 0;
  }
  return v3;
}

//----- (0805477C) --------------------------------------------------------
char *__cdecl getgroup(gid_t gid)
{
  size_t v1; // eax
  const char *v3; // [esp+10h] [ebp-18h]
  char *v4; // [esp+14h] [ebp-14h]
  group *grent; // [esp+1Ch] [ebp-Ch]
  userid *match; // [esp+20h] [ebp-8h]
  userid *tail; // [esp+24h] [ebp-4h]

  match = 0;
  for ( tail = group_alist; tail; tail = tail->next )
  {
    if ( tail->id.u == gid )
    {
      match = tail;
      break;
    }
  }
  if ( !match )
  {
    grent = getgrgid(gid);
    if ( grent )
      v3 = grent->gr_name;
    else
      v3 = (const char *)&unk_80619AC;
    v1 = strlen(v3);
    match = (userid *)xmalloc(v1 + 9);
    match->id.u = gid;
    strcpy(match->name, v3);
    match->next = group_alist;
    group_alist = match;
  }
  if ( match->name[0] )
    v4 = match->name;
  else
    v4 = 0;
  return v4;
}

//----- (08054851) --------------------------------------------------------
gid_t *__cdecl getgidbyname(const char *group)
{
  size_t v1; // eax
  gid_t *v3; // [esp+14h] [ebp-14h]
  group *grent; // [esp+20h] [ebp-8h]
  userid *tail; // [esp+24h] [ebp-4h]
  userid *taila; // [esp+24h] [ebp-4h]
  userid *tailb; // [esp+24h] [ebp-4h]

  for ( tail = group_alist; tail; tail = tail->next )
  {
    if ( tail->name[0] == *group && !strcmp(tail->name, group) )
      return &tail->id.u;
  }
  for ( taila = nogroup_alist; taila; taila = taila->next )
  {
    if ( taila->name[0] == *group && !strcmp(taila->name, group) )
      return 0;
  }
  grent = getgrnam(group);
  v1 = strlen(group);
  tailb = (userid *)xmalloc(v1 + 9);
  strcpy(tailb->name, group);
  if ( grent )
  {
    tailb->id.u = grent->gr_gid;
    tailb->next = group_alist;
    group_alist = tailb;
    v3 = &tailb->id.u;
  }
  else
  {
    tailb->next = nogroup_alist;
    nogroup_alist = tailb;
    v3 = 0;
  }
  return v3;
}

//----- (0805497C) --------------------------------------------------------
char *__cdecl imaxtostr(intmax_t i, char *buf)
{
  intmax_t ia; // [esp+10h] [ebp-18h]
  char *p; // [esp+24h] [ebp-4h]

  ia = i;
  p = buf + 20;
  buf[20] = 0;
  if ( i >= 0 )
  {
    do
    {
      *--p = ia % 10 + 48;
      ia /= 10LL;
    }
    while ( ia );
  }
  else
  {
    do
    {
      *--p = 48 - ia % 10;
      ia /= 10LL;
    }
    while ( ia );
    *--p = 45;
  }
  return p;
}

//----- (08054A84) --------------------------------------------------------
void __cdecl mpsort_into_tmp(const void **base, size_t n, const void **tmp, comparison_function cmp)
{
  const void *bb; // [esp+18h] [ebp-20h]
  const void *ba; // [esp+1Ch] [ebp-1Ch]
  size_t b; // [esp+24h] [ebp-14h]
  size_t alim; // [esp+28h] [ebp-10h]
  size_t a; // [esp+2Ch] [ebp-Ch]

  a = 0;
  alim = n >> 1;
  b = n >> 1;
  mpsort_with_tmp(&base[n >> 1], n - (n >> 1), tmp, cmp);
  mpsort_with_tmp(base, n >> 1, tmp, cmp);
  ba = *base;
  bb = base[n >> 1];
  while ( 1 )
  {
    while ( cmp(ba, bb) > 0 )
    {
      *tmp++ = bb;
      if ( ++b == n )
        goto LABEL_8;
      bb = base[b];
    }
    *tmp++ = ba;
    if ( ++a == alim )
      break;
    ba = base[a];
  }
  a = b;
  alim = n;
LABEL_8:
  memcpy(tmp, &base[a], 4 * (alim - a));
}

//----- (08054BBB) --------------------------------------------------------
void __cdecl mpsort_with_tmp(const void **base, size_t n, const void **tmp, comparison_function cmp)
{
  const void *tt; // [esp+1Ch] [ebp-2Ch]
  const void *bb; // [esp+20h] [ebp-28h]
  size_t b; // [esp+28h] [ebp-20h]
  size_t tlim; // [esp+2Ch] [ebp-1Ch]
  size_t t; // [esp+30h] [ebp-18h]
  size_t i; // [esp+34h] [ebp-14h]
  const void *p1; // [esp+40h] [ebp-8h]
  const void *p0; // [esp+44h] [ebp-4h]

  if ( n > 2 )
  {
    t = 0;
    tlim = n >> 1;
    b = n >> 1;
    mpsort_with_tmp(&base[n >> 1], n - (n >> 1), tmp, cmp);
    if ( n >> 1 > 1 )
      mpsort_into_tmp(base, n >> 1, tmp, cmp);
    else
      *tmp = *base;
    tt = *tmp;
    bb = base[b];
    i = 0;
    while ( 1 )
    {
      while ( cmp(tt, bb) <= 0 )
      {
        base[i++] = tt;
        if ( ++t == tlim )
          return;
        tt = tmp[t];
      }
      base[i++] = bb;
      if ( ++b == n )
        break;
      bb = base[b];
    }
    memcpy(&base[i], &tmp[t], 4 * (tlim - t));
  }
  else if ( n == 2 )
  {
    p0 = *base;
    p1 = base[1];
    if ( cmp(*base, p1) > 0 )
    {
      *base = p1;
      base[1] = p0;
    }
  }
}

//----- (08054D6F) --------------------------------------------------------
void __cdecl mpsort(const void **base, size_t n, comparison_function cmp)
{
  mpsort_with_tmp(base, n, &base[n], cmp);
}

//----- (08054DA0) --------------------------------------------------------
const char *__cdecl _ZNK6idVec58ToStringEi(int n, const char *name)
{
  return quotearg_n_style(n, locale_quoting_style, name);
}

//----- (08054DC2) --------------------------------------------------------
const char *__cdecl quote(const char *name)
{
  return _ZNK6idVec58ToStringEi(0, name);
}

//----- (08054DE0) --------------------------------------------------------
quoting_options *__cdecl clone_quoting_options(quoting_options *o)
{
  quoting_options *v2; // [esp+14h] [ebp-14h]
  quoting_options *p; // [esp+20h] [ebp-8h]
  int e; // [esp+24h] [ebp-4h]

  e = *__errno_location();
  if ( o )
    v2 = o;
  else
    v2 = &default_quoting_options;
  p = (quoting_options *)xmemdup(v2, 0x24u);
  *__errno_location() = e;
  return p;
}

//----- (08054E2C) --------------------------------------------------------
quoting_style __cdecl get_quoting_style(quoting_options *o)
{
  quoting_options *v2; // [esp+0h] [ebp-4h]

  if ( o )
    v2 = o;
  else
    v2 = &default_quoting_options;
  return v2->style;
}

//----- (08054E4E) --------------------------------------------------------
void __cdecl set_quoting_style(quoting_options *o, quoting_style s)
{
  quoting_options *v2; // [esp+0h] [ebp-4h]

  if ( o )
    v2 = o;
  else
    v2 = &default_quoting_options;
  v2->style = s;
}

//----- (08054E73) --------------------------------------------------------
int __cdecl set_char_quoting(quoting_options *o, char c, int i)
{
  quoting_options *v4; // [esp+0h] [ebp-18h]
  int r; // [esp+8h] [ebp-10h]

  if ( o )
    v4 = o;
  else
    v4 = &default_quoting_options;
  r = (v4->quote_these_too[(unsigned __int8)c >> 5] >> (c & 0x1F)) & 1;
  v4->quote_these_too[(unsigned __int8)c >> 5] ^= (r ^ i & 1) << (c & 0x1F);
  return r;
}

//----- (08054EED) --------------------------------------------------------
const char *__cdecl gettext_quote(const char *msgid, quoting_style s)
{
  char *translation; // [esp+14h] [ebp-4h]

  translation = gettext(msgid);
  if ( translation == msgid && s == clocale_quoting_style )
    translation = (char *)L"\"`'";
  return translation;
}
// 8061A3C: using guessed type __int16 asc_8061A3C[4];

//----- (08054F1B) --------------------------------------------------------
size_t __cdecl quotearg_buffer_restyled(char *buffer, size_t buffersize, const char *arg, size_t argsize, quoting_style quoting_style, const quoting_options *o)
{
  unsigned int v7; // [esp+24h] [ebp-54h]
  bool v8; // [esp+32h] [ebp-46h]
  mbstate_t mbstate; // [esp+3Ch] [ebp-3Ch] BYREF
  size_t ilim; // [esp+44h] [ebp-34h]
  size_t j; // [esp+48h] [ebp-30h]
  size_t bytes; // [esp+4Ch] [ebp-2Ch]
  wchar_t w; // [esp+50h] [ebp-28h] BYREF
  size_t m; // [esp+54h] [ebp-24h]
  const char *right; // [esp+58h] [ebp-20h]
  const char *left; // [esp+5Ch] [ebp-1Ch]
  size_t quote_string_len; // [esp+60h] [ebp-18h]
  const char *quote_string; // [esp+64h] [ebp-14h]
  size_t len; // [esp+68h] [ebp-10h]
  size_t i; // [esp+6Ch] [ebp-Ch]
  bool printable; // [esp+73h] [ebp-5h]
  unsigned __int8 esc; // [esp+74h] [ebp-4h]
  unsigned __int8 c; // [esp+75h] [ebp-3h]
  bool unibyte_locale; // [esp+76h] [ebp-2h]
  bool backslash_escapes; // [esp+77h] [ebp-1h]

  len = 0;
  quote_string = 0;
  quote_string_len = 0;
  backslash_escapes = 0;
  unibyte_locale = __ctype_get_mb_cur_max() == 1;
  switch ( quoting_style )
  {
    case shell_always_quoting_style:
      if ( len < buffersize )
        buffer[len] = 39;
      ++len;
      quote_string = (_BYTE *)(L"\"`'" + 4);
      quote_string_len = 1;
      break;
    case c_quoting_style:
      if ( len < buffersize )
        buffer[len] = 34;
      ++len;
      backslash_escapes = 1;
      quote_string = (const char *)L"\"`'";
      quote_string_len = 1;
      break;
    case escape_quoting_style:
      backslash_escapes = 1;
      break;
    case locale_quoting_style:
    case clocale_quoting_style:
      left = gettext_quote((const char *)L"`'", quoting_style);
      right = gettext_quote((const char *)L"'", quoting_style);
      for ( quote_string = left; *quote_string; ++quote_string )
      {
        if ( len < buffersize )
          buffer[len] = *quote_string;
        ++len;
      }
      backslash_escapes = 1;
      quote_string = right;
      quote_string_len = strlen(right);
      break;
    default:
      break;
  }
  for ( i = 0; argsize == -1 ? arg[i] != 0 : i != argsize; ++i )
  {
    if ( backslash_escapes
      && quote_string_len
      && i + quote_string_len <= argsize
      && !memcmp(&arg[i], quote_string, quote_string_len) )
    {
      if ( len < buffersize )
        buffer[len] = 92;
      ++len;
    }
    c = arg[i];
    switch ( c )
    {
      case 0u:
        if ( backslash_escapes )
        {
          if ( len < buffersize )
            buffer[len] = 92;
          if ( ++len < buffersize )
            buffer[len] = 48;
          if ( ++len < buffersize )
            buffer[len] = 48;
          ++len;
          c = 48;
        }
        goto LABEL_110;
      case 7u:
        esc = 97;
        goto c_escape;
      case 8u:
        esc = 98;
        goto c_escape;
      case 9u:
        esc = 116;
        goto c_and_shell_escape;
      case 0xAu:
        esc = 110;
        goto c_and_shell_escape;
      case 0xBu:
        esc = 118;
        goto c_escape;
      case 0xCu:
        esc = 102;
        goto c_escape;
      case 0xDu:
        esc = 114;
        goto c_and_shell_escape;
      case 0x20u:
      case 0x21u:
      case 0x22u:
      case 0x24u:
      case 0x26u:
      case 0x28u:
      case 0x29u:
      case 0x2Au:
      case 0x3Bu:
      case 0x3Cu:
      case 0x3Du:
      case 0x3Eu:
      case 0x5Bu:
      case 0x5Eu:
      case 0x60u:
      case 0x7Cu:
        goto LABEL_61;
      case 0x23u:
      case 0x7Eu:
        goto LABEL_60;
      case 0x25u:
      case 0x2Bu:
      case 0x2Cu:
      case 0x2Du:
      case 0x2Eu:
      case 0x2Fu:
      case 0x30u:
      case 0x31u:
      case 0x32u:
      case 0x33u:
      case 0x34u:
      case 0x35u:
      case 0x36u:
      case 0x37u:
      case 0x38u:
      case 0x39u:
      case 0x3Au:
      case 0x41u:
      case 0x42u:
      case 0x43u:
      case 0x44u:
      case 0x45u:
      case 0x46u:
      case 0x47u:
      case 0x48u:
      case 0x49u:
      case 0x4Au:
      case 0x4Bu:
      case 0x4Cu:
      case 0x4Du:
      case 0x4Eu:
      case 0x4Fu:
      case 0x50u:
      case 0x51u:
      case 0x52u:
      case 0x53u:
      case 0x54u:
      case 0x55u:
      case 0x56u:
      case 0x57u:
      case 0x58u:
      case 0x59u:
      case 0x5Au:
      case 0x5Du:
      case 0x5Fu:
      case 0x61u:
      case 0x62u:
      case 0x63u:
      case 0x64u:
      case 0x65u:
      case 0x66u:
      case 0x67u:
      case 0x68u:
      case 0x69u:
      case 0x6Au:
      case 0x6Bu:
      case 0x6Cu:
      case 0x6Du:
      case 0x6Eu:
      case 0x6Fu:
      case 0x70u:
      case 0x71u:
      case 0x72u:
      case 0x73u:
      case 0x74u:
      case 0x75u:
      case 0x76u:
      case 0x77u:
      case 0x78u:
      case 0x79u:
      case 0x7Au:
        goto LABEL_110;
      case 0x27u:
        if ( quoting_style == shell_quoting_style )
          return quotearg_buffer_restyled(buffer, buffersize, arg, argsize, shell_always_quoting_style, o);
        if ( quoting_style == shell_always_quoting_style )
        {
          if ( len < buffersize )
            buffer[len] = 39;
          if ( ++len < buffersize )
            buffer[len] = 92;
          if ( ++len < buffersize )
            buffer[len] = 39;
          ++len;
        }
        goto LABEL_110;
      case 0x3Fu:
        if ( quoting_style == shell_quoting_style )
          return quotearg_buffer_restyled(buffer, buffersize, arg, argsize, shell_always_quoting_style, o);
        if ( quoting_style == c_quoting_style && i + 2 < argsize && arg[i + 1] == 63 )
        {
          v7 = arg[i + 2] - 33;
          if ( v7 <= 0x1D && ((1 << v7) & 0x380051C1) != 0 )
          {
            c = arg[i + 2];
            i += 2;
            if ( len < buffersize )
              buffer[len] = 63;
            if ( ++len < buffersize )
              buffer[len] = 92;
            if ( ++len < buffersize )
              buffer[len] = 63;
            ++len;
          }
        }
        goto LABEL_110;
      case 0x5Cu:
        esc = c;
c_and_shell_escape:
        if ( quoting_style == shell_quoting_style )
          return quotearg_buffer_restyled(buffer, buffersize, arg, argsize, shell_always_quoting_style, o);
c_escape:
        if ( !backslash_escapes )
          goto LABEL_110;
        c = esc;
        goto store_escape;
      case 0x7Bu:
      case 0x7Du:
        if ( argsize == -1 )
          v8 = arg[1] != 0;
        else
          v8 = argsize != 1;
        if ( v8 )
          goto LABEL_110;
LABEL_60:
        if ( i )
          goto LABEL_110;
LABEL_61:
        if ( quoting_style != shell_quoting_style )
          goto LABEL_110;
        return quotearg_buffer_restyled(buffer, buffersize, arg, argsize, shell_always_quoting_style, o);
      default:
        if ( unibyte_locale )
        {
          m = 1;
          printable = ((*__ctype_b_loc())[c] & 0x4000) != 0;
          goto LABEL_93;
        }
        memset(&mbstate, 0, sizeof(mbstate));
        m = 0;
        printable = 1;
        if ( argsize == -1 )
          argsize = strlen(arg);
        break;
    }
    do
    {
      bytes = mbrtowc(&w, &arg[m + i], argsize - (i + m), &mbstate);
      if ( !bytes )
        break;
      if ( bytes == -1 )
      {
        printable = 0;
        break;
      }
      if ( bytes == -2 )
      {
        printable = 0;
        while ( i + m < argsize && arg[m + i] )
          ++m;
        break;
      }
      if ( quoting_style == shell_quoting_style )
      {
        j = 1;
        while ( 2 )
        {
          if ( j < bytes )
          {
            switch ( arg[j + m + i] )
            {
              case '[':
              case '\\':
              case '^':
              case '`':
              case '|':
                return quotearg_buffer_restyled(buffer, buffersize, arg, argsize, shell_always_quoting_style, o);
              default:
                ++j;
                continue;
            }
          }
          break;
        }
      }
      if ( !iswprint(w) )
        printable = 0;
      m += bytes;
    }
    while ( !mbsinit(&mbstate) );
LABEL_93:
    if ( m <= 1 && (!backslash_escapes || printable) )
    {
LABEL_110:
      if ( backslash_escapes && (o->quote_these_too[c >> 5] & (1 << (c & 0x1F))) != 0 )
      {
store_escape:
        if ( len < buffersize )
          buffer[len] = 92;
        ++len;
      }
    }
    else
    {
      ilim = i + m;
      while ( 1 )
      {
        if ( backslash_escapes && !printable )
        {
          if ( len < buffersize )
            buffer[len] = 92;
          if ( ++len < buffersize )
            buffer[len] = (c >> 6) + 48;
          if ( ++len < buffersize )
            buffer[len] = ((c >> 3) & 7) + 48;
          ++len;
          c = (c & 7) + 48;
        }
        if ( i + 1 >= ilim )
          break;
        if ( len < buffersize )
          buffer[len] = c;
        ++len;
        c = arg[++i];
      }
    }
    if ( len < buffersize )
      buffer[len] = c;
    ++len;
  }
  if ( !i && quoting_style == shell_quoting_style )
    return quotearg_buffer_restyled(buffer, buffersize, arg, argsize, shell_always_quoting_style, o);
  if ( quote_string )
  {
    while ( *quote_string )
    {
      if ( len < buffersize )
        buffer[len] = *quote_string;
      ++len;
      ++quote_string;
    }
  }
  if ( len < buffersize )
    buffer[len] = 0;
  return len;
}
// 8061A3C: using guessed type __int16 asc_8061A3C[4];

//----- (08055667) --------------------------------------------------------
size_t __cdecl quotearg_buffer(char *buffer, size_t buffersize, const char *arg, size_t argsize, const quoting_options *o)
{
  quoting_options *v6; // [esp+24h] [ebp-14h]
  size_t r; // [esp+2Ch] [ebp-Ch]
  int e; // [esp+30h] [ebp-8h]

  if ( o )
    v6 = (quoting_options *)o;
  else
    v6 = &default_quoting_options;
  e = *__errno_location();
  r = quotearg_buffer_restyled(buffer, buffersize, arg, argsize, v6->style, v6);
  *__errno_location() = e;
  return r;
}

//----- (080556D6) --------------------------------------------------------
char *__cdecl quotearg_alloc(const char *arg, size_t argsize, const quoting_options *o)
{
  char *buf; // [esp+1Ch] [ebp-Ch]
  size_t bufsize; // [esp+20h] [ebp-8h]
  int e; // [esp+24h] [ebp-4h]

  e = *__errno_location();
  bufsize = quotearg_buffer(0, 0, arg, argsize, o) + 1;
  buf = xcharalloc(bufsize);
  quotearg_buffer(buf, bufsize, arg, argsize, o);
  *__errno_location() = e;
  return buf;
}

//----- (0805575B) --------------------------------------------------------
void quotearg_free()
{
  unsigned int i; // [esp+10h] [ebp-8h]
  slotvec *sv; // [esp+14h] [ebp-4h]

  sv = slotvec_0;
  for ( i = 1; i < nslots; ++i )
    free(sv[i].val);
  if ( sv->val != slot0 )
  {
    free(sv->val);
    slotvec0.size = 256;
    slotvec0.val = slot0;
  }
  if ( sv != &slotvec0 )
  {
    free(sv);
    slotvec_0 = &slotvec0;
  }
  nslots = 1;
}

//----- (080557ED) --------------------------------------------------------
char *__cdecl quotearg_n_options(int n, const char *arg, size_t argsize, const quoting_options *options)
{
  char *v4; // edx
  slotvec *p; // [esp+20h] [ebp-28h]
  size_t qsize; // [esp+24h] [ebp-24h]
  char *val; // [esp+28h] [ebp-20h]
  size_t sizea; // [esp+2Ch] [ebp-1Ch]
  size_t size; // [esp+2Ch] [ebp-1Ch]
  size_t n1; // [esp+30h] [ebp-18h]
  slotvec *sv; // [esp+34h] [ebp-14h]
  int e; // [esp+3Ch] [ebp-Ch]
  bool preallocated; // [esp+43h] [ebp-5h]

  e = *__errno_location();
  sv = slotvec_0;
  if ( n < 0 )
    abort();
  if ( nslots <= n )
  {
    n1 = n + 1;
    preallocated = slotvec_0 == &slotvec0;
    if ( (unsigned int)(n + 1) > 0x1FFFFFFF )
      xalloc_die();
    if ( slotvec_0 == &slotvec0 )
      p = 0;
    else
      p = slotvec_0;
    sv = (slotvec *)xrealloc(p, 8 * n1);
    slotvec_0 = sv;
    if ( preallocated )
    {
      v4 = slotvec0.val;
      sv->size = slotvec0.size;
      sv->val = v4;
    }
    memset(&sv[nslots], 0, 8 * (n1 - nslots));
    nslots = n + 1;
  }
  sizea = sv[n].size;
  val = sv[n].val;
  qsize = quotearg_buffer(val, sizea, arg, argsize, options);
  if ( sizea <= qsize )
  {
    size = qsize + 1;
    sv[n].size = qsize + 1;
    if ( val != slot0 )
      free(val);
    val = xcharalloc(size);
    sv[n].val = val;
    quotearg_buffer(val, size, arg, argsize, options);
  }
  *__errno_location() = e;
  return val;
}

//----- (080559AD) --------------------------------------------------------
char *__cdecl quotearg_n(int n, const char *arg)
{
  return quotearg_n_options(n, arg, 0xFFFFFFFF, &default_quoting_options);
}

//----- (080559D7) --------------------------------------------------------
char *__cdecl quotearg(const char *arg)
{
  return quotearg_n(0, arg);
}

//----- (080559F2) --------------------------------------------------------
quoting_options *quoting_options_from_style(quoting_options *retstr, quoting_style style)
{
  quoting_options o; // [esp+20h] [ebp-28h] BYREF

  memset(o.quote_these_too, 0, sizeof(o.quote_these_too));
  retstr->style = style;
  retstr->quote_these_too[0] = o.quote_these_too[0];
  retstr->quote_these_too[1] = o.quote_these_too[1];
  retstr->quote_these_too[2] = o.quote_these_too[2];
  retstr->quote_these_too[3] = o.quote_these_too[3];
  retstr->quote_these_too[4] = o.quote_these_too[4];
  retstr->quote_these_too[5] = o.quote_these_too[5];
  retstr->quote_these_too[6] = o.quote_these_too[6];
  retstr->quote_these_too[7] = o.quote_these_too[7];
  return retstr;
}
// 80559F2: inconsistent function type and number of purged bytes

//----- (08055A5F) --------------------------------------------------------
char *__cdecl quotearg_n_style(int n, quoting_style s, const char *arg)
{
  quoting_options o; // [esp+24h] [ebp-24h] BYREF

  quoting_options_from_style(&o, s);
  return quotearg_n_options(n, arg, 0xFFFFFFFF, &o);
}

//----- (08055A9D) --------------------------------------------------------
char *__cdecl quotearg_n_style_mem(int n, quoting_style s, const char *arg, size_t argsize)
{
  quoting_options o; // [esp+24h] [ebp-24h] BYREF

  quoting_options_from_style(&o, s);
  return quotearg_n_options(n, arg, argsize, &o);
}

//----- (08055ADA) --------------------------------------------------------
char *__cdecl quotearg_style(quoting_style s, const char *arg)
{
  return quotearg_n_style(0, s, arg);
}

//----- (08055AFC) --------------------------------------------------------
char *__cdecl quotearg_char(const char *arg, char ch_0)
{
  quoting_options options; // [esp+24h] [ebp-24h] BYREF

  options = default_quoting_options;
  set_char_quoting(&options, ch_0, 1);
  return quotearg_n_options(0, arg, 0xFFFFFFFF, &options);
}

//----- (08055B8F) --------------------------------------------------------
char *__cdecl quotearg_colon(const char *arg)
{
  return quotearg_char(arg, 58);
}

//----- (08055BAC) --------------------------------------------------------
char *__cdecl memcpy_lowcase(char *dest, const char *src, size_t len)
{
  while ( len-- != 0 )
    dest[len] = tolower((unsigned __int8)src[len]);
  return dest;
}

//----- (08055BEE) --------------------------------------------------------
char *__cdecl memcpy_uppcase(char *dest, const char *src, size_t len)
{
  while ( len-- != 0 )
    dest[len] = toupper((unsigned __int8)src[len]);
  return dest;
}

//----- (08055C30) --------------------------------------------------------
size_t __cdecl strftime_case_(bool upcase, char *s, size_t maxsize, const char *format, const tm *tp, int ut, int ns)
{
  size_t v7; // eax
  size_t v8; // eax
  int v10; // [esp+2Ch] [ebp-61Ch]
  int v12; // [esp+34h] [ebp-614h]
  int v13; // [esp+38h] [ebp-610h]
  int v14; // [esp+3Ch] [ebp-60Ch]
  char v15; // [esp+4Ah] [ebp-5FEh]
  char v16; // [esp+4Bh] [ebp-5FDh]
  int v17; // [esp+4Ch] [ebp-5FCh]
  char v18; // [esp+53h] [ebp-5F5h]
  int v19; // [esp+5Ch] [ebp-5ECh]
  _BOOL4 v20; // [esp+68h] [ebp-5E0h]
  _BOOL4 v21; // [esp+7Ch] [ebp-5CCh]
  int v22; // [esp+88h] [ebp-5C0h]
  int v23; // [esp+90h] [ebp-5B8h]
  int v24; // [esp+94h] [ebp-5B4h]
  int v25; // [esp+9Ch] [ebp-5ACh]
  tm ltm; // [esp+B8h] [ebp-590h] BYREF
  int _incr_12; // [esp+E4h] [ebp-564h]
  int _delta_12; // [esp+E8h] [ebp-560h]
  int _n_12; // [esp+ECh] [ebp-55Ch]
  int flen; // [esp+F0h] [ebp-558h]
  int sec_diff; // [esp+F4h] [ebp-554h]
  int min_diff; // [esp+F8h] [ebp-550h]
  int hour_diff; // [esp+FCh] [ebp-54Ch]
  int diff; // [esp+100h] [ebp-548h]
  int _incr_11; // [esp+104h] [ebp-544h]
  int _delta_11; // [esp+108h] [ebp-540h]
  int _n_11; // [esp+10Ch] [ebp-53Ch]
  int yy_0; // [esp+110h] [ebp-538h]
  int yy; // [esp+114h] [ebp-534h]
  int d_0; // [esp+118h] [ebp-530h]
  int days; // [esp+11Ch] [ebp-52Ch]
  int year_adjust; // [esp+120h] [ebp-528h]
  int year; // [esp+124h] [ebp-524h]
  int _incr_10; // [esp+128h] [ebp-520h]
  int _delta_10; // [esp+12Ch] [ebp-51Ch]
  int _n_10; // [esp+130h] [ebp-518h]
  int d; // [esp+134h] [ebp-514h]
  time_t t; // [esp+138h] [ebp-510h]
  int _incr_9; // [esp+13Ch] [ebp-50Ch]
  int _delta_9; // [esp+140h] [ebp-508h]
  int _n_9; // [esp+144h] [ebp-504h]
  int j; // [esp+148h] [ebp-500h]
  int _incr_8; // [esp+14Ch] [ebp-4FCh]
  int _delta_8; // [esp+150h] [ebp-4F8h]
  int _n_8; // [esp+154h] [ebp-4F4h]
  int _incr_7; // [esp+158h] [ebp-4F0h]
  int _delta_7; // [esp+15Ch] [ebp-4ECh]
  int _n_7; // [esp+160h] [ebp-4E8h]
  int _incr_6; // [esp+164h] [ebp-4E4h]
  int _delta_6; // [esp+168h] [ebp-4E0h]
  int _n_6; // [esp+16Ch] [ebp-4DCh]
  int _incr_5; // [esp+170h] [ebp-4D8h]
  int _delta_5; // [esp+174h] [ebp-4D4h]
  int _n_5; // [esp+178h] [ebp-4D0h]
  int padding; // [esp+17Ch] [ebp-4CCh]
  int _incr_4; // [esp+180h] [ebp-4C8h]
  int _delta_4; // [esp+184h] [ebp-4C4h]
  int _n_4; // [esp+188h] [ebp-4C0h]
  int century; // [esp+18Ch] [ebp-4BCh]
  int _incr_3; // [esp+190h] [ebp-4B8h]
  int _delta_3; // [esp+194h] [ebp-4B4h]
  int _n_3; // [esp+198h] [ebp-4B0h]
  size_t len_1; // [esp+19Ch] [ebp-4ACh]
  char *u; // [esp+1A0h] [ebp-4A8h]
  int _incr_2; // [esp+1A4h] [ebp-4A4h]
  int _delta_2; // [esp+1A8h] [ebp-4A0h]
  int _n_2; // [esp+1ACh] [ebp-49Ch]
  size_t len_0; // [esp+1B0h] [ebp-498h]
  int _incr_1; // [esp+1B4h] [ebp-494h]
  int _delta_1; // [esp+1B8h] [ebp-490h]
  int _n_1; // [esp+1BCh] [ebp-48Ch]
  int _incr_0; // [esp+1C0h] [ebp-488h]
  int _delta_0; // [esp+1C4h] [ebp-484h]
  int _n_0; // [esp+1C8h] [ebp-480h]
  size_t bytes; // [esp+1CCh] [ebp-47Ch]
  size_t fsize; // [esp+1D0h] [ebp-478h]
  size_t len; // [esp+1D4h] [ebp-474h]
  int _incr; // [esp+1D8h] [ebp-470h]
  int _delta; // [esp+1DCh] [ebp-46Ch]
  int _n; // [esp+1E0h] [ebp-468h]
  int format_char; // [esp+1E4h] [ebp-464h]
  size_t colons; // [esp+1E8h] [ebp-460h]
  int width; // [esp+1ECh] [ebp-45Ch]
  char *bufp; // [esp+1F0h] [ebp-458h]
  const char *subfmt; // [esp+1F4h] [ebp-454h]
  int tz_colon_mask; // [esp+1F8h] [ebp-450h]
  unsigned int u_number_value; // [esp+1FCh] [ebp-44Ch]
  int number_value; // [esp+200h] [ebp-448h]
  int digits; // [esp+204h] [ebp-444h]
  int modifier; // [esp+208h] [ebp-440h]
  int pad; // [esp+20Ch] [ebp-43Ch]
  const char *format_end; // [esp+210h] [ebp-438h]
  const char *f; // [esp+214h] [ebp-434h]
  char *p; // [esp+218h] [ebp-430h]
  size_t i; // [esp+21Ch] [ebp-42Ch]
  const char *zone; // [esp+220h] [ebp-428h]
  int hour12; // [esp+224h] [ebp-424h]
  bool change_case; // [esp+228h] [ebp-420h]
  bool to_uppcase; // [esp+229h] [ebp-41Fh]
  bool to_lowcase; // [esp+22Ah] [ebp-41Eh]
  char sign_char; // [esp+22Bh] [ebp-41Dh]
  bool always_output_a_sign; // [esp+22Ch] [ebp-41Ch]
  bool negative_number; // [esp+22Dh] [ebp-41Bh]
  char ubuf[1024]; // [esp+22Eh] [ebp-41Ah] BYREF
  int v115[3]; // [esp+63Ch] [ebp-Ch] BYREF

  v115[0] = __readgsdword(0x14u);
  hour12 = tp->tm_hour;
  i = 0;
  p = s;
  format_end = 0;
  zone = 0;
  zone = tp->tm_zone;
  if ( hour12 <= 12 )
  {
    if ( !hour12 )
      hour12 = 12;
  }
  else
  {
    hour12 -= 12;
  }
  for ( f = format; ; ++f )
  {
    if ( !*f )
    {
      if ( p && maxsize )
        *p = 0;
      return i;
    }
    pad = 0;
    digits = 0;
    width = -1;
    to_lowcase = 0;
    to_uppcase = upcase;
    change_case = 0;
    v10 = *f;
    if ( v10 > 63 )
    {
      if ( v10 >= 65 && (v10 <= 95 || (unsigned int)(v10 - 97) <= 0x1D) )
        goto LABEL_17;
      goto LABEL_24;
    }
    if ( v10 >= 38 )
      goto LABEL_17;
    if ( v10 <= 35 )
      break;
    if ( v10 != 37 )
      goto LABEL_24;
    while ( 1 )
    {
      while ( 1 )
      {
        v12 = *++f;
        if ( v12 == 48 )
          goto LABEL_56;
        if ( v12 > 48 )
          break;
        if ( v12 == 35 )
        {
          change_case = 1;
        }
        else
        {
          if ( v12 != 45 )
            goto LABEL_59;
LABEL_56:
          pad = *f;
        }
      }
      if ( v12 != 94 )
        break;
      to_uppcase = 1;
    }
    if ( v12 == 95 )
      goto LABEL_56;
LABEL_59:
    if ( (unsigned int)(*f - 48) <= 9 )
    {
      width = 0;
      do
      {
        if ( width > 214748364 || width == 214748364 && *f - 48 > 7 )
        {
          width = 0x7FFFFFFF;
        }
        else
        {
          width *= 10;
          width += *f - 48;
        }
        ++f;
      }
      while ( (unsigned int)(*f - 48) <= 9 );
    }
    v13 = *f;
    if ( v13 == 69 || v13 == 79 )
      modifier = *f++;
    else
      modifier = 0;
    format_char = *f;
    switch ( format_char )
    {
      case 0:
        --f;
        goto bad_format;
      case 37:
        if ( modifier )
          goto bad_format;
        _n_1 = 1;
        _delta_1 = width - 1;
        _incr_1 = ((width - 1) & ~((width - 1) >> 31)) + 1;
        if ( _incr_1 >= maxsize - i )
          return 0;
        if ( p )
        {
          if ( _delta_1 > 0 )
          {
            if ( pad == 48 )
              memset(p, 48, _delta_1);
            else
              memset(p, 32, _delta_1);
            p += _delta_1;
          }
          *p = *f;
          p += _n_1;
        }
        i += _incr_1;
        break;
      case 58:
        for ( colons = 1; f[colons] == 58; ++colons )
          ;
        if ( f[colons] != 122 )
          goto bad_format;
        f += colons;
        goto do_z_conversion;
      case 65:
        if ( modifier )
          goto bad_format;
        if ( change_case )
        {
          to_uppcase = 1;
          to_lowcase = 0;
        }
        goto underlying_strftime;
      case 66:
        if ( modifier )
          goto bad_format;
        if ( change_case )
        {
          to_uppcase = 1;
          to_lowcase = 0;
        }
        goto underlying_strftime;
      case 67:
        if ( modifier == 79 )
          goto bad_format;
        if ( modifier == 69 )
          goto underlying_strftime;
        century = tp->tm_year / 100 + 19;
        v14 = tp->tm_year % 100 < 0 && century > 0;
        century -= v14;
        digits = 2;
        negative_number = tp->tm_year < -1900;
        u_number_value = century;
        goto do_signed_number;
      case 68:
        if ( modifier )
          goto bad_format;
        subfmt = "%m/%d/%y";
        goto subformat;
      case 70:
        if ( modifier )
          goto bad_format;
        subfmt = "%Y-%m-%d";
subformat:
        len_0 = strftime_case_(to_uppcase, 0, 0xFFFFFFFF, subfmt, tp, ut, ns);
        _n_2 = len_0;
        _delta_2 = width - len_0;
        _incr_2 = len_0 + ((width - len_0) & ~((int)(width - len_0) >> 31));
        if ( _incr_2 >= maxsize - i )
          return 0;
        if ( p )
        {
          if ( !digits && _delta_2 > 0 )
          {
            if ( pad == 48 )
              memset(p, 48, _delta_2);
            else
              memset(p, 32, _delta_2);
            p += _delta_2;
          }
          strftime_case_(to_uppcase, p, maxsize - i, subfmt, tp, ut, ns);
          p += _n_2;
        }
        i += _incr_2;
        continue;
      case 71:
      case 86:
      case 103:
        if ( modifier == 69 )
          goto bad_format;
        if ( tp->tm_year >= 0 )
          v19 = -100;
        else
          v19 = 300;
        year = v19 + tp->tm_year;
        year_adjust = 0;
        days = iso_week_days(tp->tm_yday, tp->tm_wday);
        if ( days >= 0 )
        {
          v21 = (year & 3) == 0 && (year % 100 || !(year % 400));
          d_0 = iso_week_days(tp->tm_yday + -365 - v21, tp->tm_wday);
          if ( d_0 >= 0 )
          {
            year_adjust = 1;
            days = d_0;
          }
        }
        else
        {
          year_adjust = -1;
          v20 = (((_BYTE)year - 1) & 3) == 0 && ((year - 1) % 100 || !((year - 1) % 400));
          days = iso_week_days(tp->tm_yday + v20 + 365, tp->tm_wday);
        }
        v22 = *f;
        if ( v22 == 71 )
        {
          digits = 4;
          negative_number = tp->tm_year < -1900 - year_adjust;
          u_number_value = tp->tm_year + year_adjust + 1900;
        }
        else
        {
          if ( v22 == 103 )
          {
            yy = (year_adjust + tp->tm_year % 100) % 100;
            digits = 2;
            if ( yy >= 0 )
            {
              v23 = yy;
            }
            else
            {
              if ( tp->tm_year >= -1900 - year_adjust )
                v24 = yy + 100;
              else
                v24 = -yy;
              v23 = v24;
            }
            number_value = v23;
          }
          else
          {
            digits = 2;
            number_value = days / 7 + 1;
          }
do_number:
          negative_number = number_value < 0;
          u_number_value = number_value;
        }
do_signed_number:
        always_output_a_sign = 0;
        tz_colon_mask = 0;
        goto do_number_body;
      case 72:
        if ( modifier == 69 )
          goto bad_format;
        digits = 2;
        number_value = tp->tm_hour;
        goto do_number;
      case 73:
        if ( modifier == 69 )
          goto bad_format;
        digits = 2;
        number_value = hour12;
        goto do_number;
      case 77:
        if ( modifier == 69 )
          goto bad_format;
        digits = 2;
        number_value = tp->tm_min;
        goto do_number;
      case 78:
        if ( modifier == 69 )
          goto bad_format;
        number_value = ns;
        if ( width == -1 )
        {
          width = 9;
        }
        else
        {
          for ( j = width; j <= 8; ++j )
            number_value /= 10;
        }
        digits = width;
        goto do_number;
      case 80:
        to_lowcase = 1;
        format_char = 112;
        goto LABEL_275;
      case 82:
        subfmt = "%H:%M";
        goto subformat;
      case 83:
        if ( modifier == 69 )
          goto bad_format;
        digits = 2;
        number_value = tp->tm_sec;
        goto do_number;
      case 84:
        subfmt = "%H:%M:%S";
        goto subformat;
      case 85:
        if ( modifier == 69 )
          goto bad_format;
        digits = 2;
        number_value = (tp->tm_yday - tp->tm_wday + 7) / 7;
        goto do_number;
      case 87:
        if ( modifier == 69 )
          goto bad_format;
        digits = 2;
        number_value = (tp->tm_yday - (tp->tm_wday + 6) % 7 + 7) / 7;
        goto do_number;
      case 88:
        if ( modifier != 79 )
          goto underlying_strftime;
        goto bad_format;
      case 89:
        if ( modifier == 69 )
          goto underlying_strftime;
        if ( modifier == 79 )
          goto bad_format;
        digits = 4;
        negative_number = tp->tm_year < -1900;
        u_number_value = tp->tm_year + 1900;
        goto do_signed_number;
      case 90:
        if ( change_case )
        {
          to_uppcase = 0;
          to_lowcase = 1;
        }
        if ( !zone )
          zone = (const char *)&unk_8061D05;
        _n_11 = strlen(zone);
        _delta_11 = width - _n_11;
        _incr_11 = _n_11 + ((width - _n_11) & ~((width - _n_11) >> 31));
        if ( _incr_11 >= maxsize - i )
          return 0;
        if ( p )
        {
          if ( !digits && _delta_11 > 0 )
          {
            if ( pad == 48 )
              memset(p, 48, _delta_11);
            else
              memset(p, 32, _delta_11);
            p += _delta_11;
          }
          if ( to_lowcase )
          {
            memcpy_lowcase(p, zone, _n_11);
          }
          else if ( to_uppcase )
          {
            memcpy_uppcase(p, zone, _n_11);
          }
          else
          {
            memcpy(p, zone, _n_11);
          }
          p += _n_11;
        }
        i += _incr_11;
        continue;
      case 97:
        if ( modifier )
          goto bad_format;
        if ( change_case )
        {
          to_uppcase = 1;
          to_lowcase = 0;
        }
        goto underlying_strftime;
      case 98:
      case 104:
        if ( change_case )
        {
          to_uppcase = 1;
          to_lowcase = 0;
        }
        if ( !modifier )
          goto underlying_strftime;
        goto bad_format;
      case 99:
        if ( modifier != 79 )
          goto underlying_strftime;
        goto bad_format;
      case 100:
        if ( modifier == 69 )
          goto bad_format;
        digits = 2;
        number_value = tp->tm_mday;
        goto do_number;
      case 101:
        if ( modifier == 69 )
          goto bad_format;
        digits = 2;
        number_value = tp->tm_mday;
        goto do_number_spacepad;
      case 106:
        if ( modifier == 69 )
          goto bad_format;
        digits = 3;
        negative_number = tp->tm_yday < -1;
        u_number_value = tp->tm_yday + 1;
        goto do_signed_number;
      case 107:
        if ( modifier == 69 )
          goto bad_format;
        digits = 2;
        number_value = tp->tm_hour;
        goto do_number_spacepad;
      case 108:
        if ( modifier == 69 )
          goto bad_format;
        digits = 2;
        number_value = hour12;
do_number_spacepad:
        if ( pad != 48 && pad != 45 )
          pad = 95;
        goto do_number;
      case 109:
        if ( modifier == 69 )
          goto bad_format;
        digits = 2;
        negative_number = tp->tm_mon < -1;
        u_number_value = tp->tm_mon + 1;
        goto do_signed_number;
      case 110:
        _n_9 = 1;
        _delta_9 = width - 1;
        _incr_9 = ((width - 1) & ~((width - 1) >> 31)) + 1;
        if ( _incr_9 >= maxsize - i )
          return 0;
        if ( p )
        {
          if ( _delta_9 > 0 )
          {
            if ( pad == 48 )
              memset(p, 48, _delta_9);
            else
              memset(p, 32, _delta_9);
            p += _delta_9;
          }
          *p = 10;
          p += _n_9;
        }
        i += _incr_9;
        continue;
      case 112:
LABEL_275:
        if ( change_case )
        {
          to_uppcase = 0;
          to_lowcase = 1;
        }
        goto underlying_strftime;
      case 114:
        goto underlying_strftime;
      case 115:
        ltm = *tp;
        t = mktime(&ltm);
        bufp = (char *)v115;
        negative_number = t < 0;
        do
        {
          d = t % 10;
          t /= 10;
          --bufp;
          if ( negative_number )
            v18 = 48 - d;
          else
            v18 = d + 48;
          *bufp = v18;
        }
        while ( t );
        digits = 1;
        always_output_a_sign = 0;
        goto do_number_sign_and_padding;
      case 116:
        _n_10 = 1;
        _delta_10 = width - 1;
        _incr_10 = ((width - 1) & ~((width - 1) >> 31)) + 1;
        if ( _incr_10 >= maxsize - i )
          return 0;
        if ( p )
        {
          if ( _delta_10 > 0 )
          {
            if ( pad == 48 )
              memset(p, 48, _delta_10);
            else
              memset(p, 32, _delta_10);
            p += _delta_10;
          }
          *p = 9;
          p += _n_10;
        }
        i += _incr_10;
        continue;
      case 117:
        digits = 1;
        number_value = (tp->tm_wday + 6) % 7 + 1;
        goto do_number;
      case 119:
        if ( modifier == 69 )
          goto bad_format;
        digits = 1;
        number_value = tp->tm_wday;
        goto do_number;
      case 120:
        if ( modifier != 79 )
          goto underlying_strftime;
        goto bad_format;
      case 121:
        if ( modifier == 69 )
          goto underlying_strftime;
        yy_0 = tp->tm_year % 100;
        if ( yy_0 < 0 )
        {
          if ( tp->tm_year >= -1900 )
            v25 = yy_0 + 100;
          else
            v25 = -yy_0;
          yy_0 = v25;
        }
        digits = 2;
        number_value = yy_0;
        goto do_number;
      case 122:
        colons = 0;
do_z_conversion:
        if ( tp->tm_isdst < 0 )
          continue;
        diff = tp->tm_gmtoff;
        hour_diff = diff / 3600;
        min_diff = diff / 60 % 60;
        sec_diff = diff % 60;
        if ( colons == 1 )
          goto tz_hh_mm;
        if ( colons )
        {
          if ( colons == 2 )
            goto tz_hh_mm_ss;
          if ( colons != 3 )
          {
bad_format:
            for ( flen = 1; f[1 - flen] != 37; ++flen )
              ;
            _n_12 = flen;
            _delta_12 = width - flen;
            _incr_12 = flen + ((width - flen) & ~((width - flen) >> 31));
            if ( _incr_12 >= maxsize - i )
              return 0;
            if ( p )
            {
              if ( _delta_12 > 0 )
              {
                if ( pad == 48 )
                  memset(p, 48, _delta_12);
                else
                  memset(p, 32, _delta_12);
                p += _delta_12;
              }
              if ( to_lowcase )
              {
                memcpy_lowcase(p, &f[1 - flen], _n_12);
              }
              else if ( to_uppcase )
              {
                memcpy_uppcase(p, &f[1 - flen], _n_12);
              }
              else
              {
                memcpy(p, &f[1 - flen], _n_12);
              }
              p += _n_12;
            }
            i += _incr_12;
            continue;
          }
          if ( sec_diff )
          {
tz_hh_mm_ss:
            digits = 9;
            negative_number = diff < 0;
            tz_colon_mask = 20;
            u_number_value = sec_diff + 10000 * hour_diff + 100 * min_diff;
          }
          else if ( min_diff )
          {
tz_hh_mm:
            digits = 6;
            negative_number = diff < 0;
            tz_colon_mask = 4;
            u_number_value = min_diff + 100 * hour_diff;
          }
          else
          {
            digits = 3;
            negative_number = diff < 0;
            tz_colon_mask = 0;
            u_number_value = hour_diff;
          }
        }
        else
        {
          digits = 5;
          negative_number = diff < 0;
          tz_colon_mask = 0;
          u_number_value = min_diff + 100 * hour_diff;
        }
        always_output_a_sign = 1;
do_number_body:
        if ( modifier == 79 && !negative_number )
        {
underlying_strftime:
          LOWORD(ltm.tm_sec) = 9504;
          u = (char *)&ltm.tm_sec + 2;
          if ( modifier )
            *u++ = modifier;
          *u++ = format_char;
          *u = 0;
          len_1 = strftime(ubuf, 0x400u, (const char *)&ltm, tp);
          if ( len_1 )
          {
            _n_3 = len_1 - 1;
            _delta_3 = width - (len_1 - 1);
            _incr_3 = len_1 - 1 + (_delta_3 & ~(_delta_3 >> 31));
            if ( _incr_3 >= maxsize - i )
              return 0;
            if ( p )
            {
              if ( !digits && _delta_3 > 0 )
              {
                if ( pad == 48 )
                  memset(p, 48, _delta_3);
                else
                  memset(p, 32, _delta_3);
                p += _delta_3;
              }
              if ( to_lowcase )
              {
                memcpy_lowcase(p, &ubuf[1], _n_3);
              }
              else if ( to_uppcase )
              {
                memcpy_uppcase(p, &ubuf[1], _n_3);
              }
              else
              {
                memcpy(p, &ubuf[1], _n_3);
              }
              p += _n_3;
            }
            i += _incr_3;
          }
        }
        else
        {
          bufp = (char *)v115;
          if ( negative_number )
            u_number_value = -u_number_value;
          do
          {
            if ( (tz_colon_mask & 1) != 0 )
              *--bufp = 58;
            tz_colon_mask >>= 1;
            *--bufp = u_number_value % 0xA + 48;
            u_number_value /= 0xAu;
          }
          while ( u_number_value || tz_colon_mask );
do_number_sign_and_padding:
          if ( digits < width )
            digits = width;
          if ( negative_number )
          {
            v15 = 45;
          }
          else
          {
            if ( always_output_a_sign )
              v16 = 43;
            else
              v16 = 0;
            v15 = v16;
          }
          sign_char = v15;
          if ( pad == 45 )
          {
            if ( sign_char )
            {
              _n_4 = 1;
              _delta_4 = width - 1;
              _incr_4 = ((width - 1) & ~((width - 1) >> 31)) + 1;
              if ( _incr_4 >= maxsize - i )
                return 0;
              if ( p )
              {
                if ( !digits && _delta_4 > 0 )
                {
                  memset(p, 32, _delta_4);
                  p += _delta_4;
                }
                *p = sign_char;
                p += _n_4;
              }
              i += _incr_4;
            }
          }
          else
          {
            padding = digits + bufp - (char *)v115 - (sign_char != 0);
            if ( padding <= 0 )
            {
              if ( sign_char )
              {
                _n_7 = 1;
                _delta_7 = width - 1;
                _incr_7 = ((width - 1) & ~((width - 1) >> 31)) + 1;
                if ( _incr_7 >= maxsize - i )
                  return 0;
                if ( p )
                {
                  if ( !digits && _delta_7 > 0 )
                  {
                    if ( pad == 48 )
                      memset(p, 48, _delta_7);
                    else
                      memset(p, 32, _delta_7);
                    p += _delta_7;
                  }
                  *p = sign_char;
                  p += _n_7;
                }
                i += _incr_7;
              }
            }
            else if ( pad == 95 )
            {
              if ( padding >= maxsize - i )
                return 0;
              if ( p )
              {
                memset(p, 32, padding);
                p += padding;
              }
              i += padding;
              if ( width <= padding )
                v17 = 0;
              else
                v17 = width - padding;
              width = v17;
              if ( sign_char )
              {
                _n_5 = 1;
                _delta_5 = width - 1;
                _incr_5 = ((width - 1) & ~((width - 1) >> 31)) + 1;
                if ( _incr_5 >= maxsize - i )
                  return 0;
                if ( p )
                {
                  if ( !digits && _delta_5 > 0 )
                  {
                    if ( pad == 48 )
                      memset(p, 48, _delta_5);
                    else
                      memset(p, 32, _delta_5);
                    p += _delta_5;
                  }
                  *p = sign_char;
                  p += _n_5;
                }
                i += _incr_5;
              }
            }
            else
            {
              if ( digits >= maxsize - i )
                return 0;
              if ( sign_char )
              {
                _n_6 = 1;
                _delta_6 = width - 1;
                _incr_6 = ((width - 1) & ~((width - 1) >> 31)) + 1;
                if ( _incr_6 >= maxsize - i )
                  return 0;
                if ( p )
                {
                  if ( !digits && _delta_6 > 0 )
                  {
                    if ( pad == 48 )
                      memset(p, 48, _delta_6);
                    else
                      memset(p, 32, _delta_6);
                    p += _delta_6;
                  }
                  *p = sign_char;
                  p += _n_6;
                }
                i += _incr_6;
              }
              if ( p )
              {
                memset(p, 48, padding);
                p += padding;
              }
              i += padding;
              width = 0;
            }
          }
          _n_8 = (char *)v115 - bufp;
          _delta_8 = width - ((char *)v115 - bufp);
          _incr_8 = (char *)v115 - bufp + (_delta_8 & ~(_delta_8 >> 31));
          if ( _incr_8 >= maxsize - i )
            return 0;
          if ( p )
          {
            if ( !digits && _delta_8 > 0 )
            {
              if ( pad == 48 )
                memset(p, 48, _delta_8);
              else
                memset(p, 32, _delta_8);
              p += _delta_8;
            }
            if ( to_lowcase )
            {
              memcpy_lowcase(p, bufp, _n_8);
            }
            else if ( to_uppcase )
            {
              memcpy_uppcase(p, bufp, _n_8);
            }
            else
            {
              memcpy(p, bufp, _n_8);
            }
            p += _n_8;
          }
          i += _incr_8;
        }
        continue;
      default:
        goto bad_format;
    }
LABEL_402:
    ;
  }
  if ( v10 >= 32 || (unsigned int)(v10 - 8) <= 5 )
  {
LABEL_17:
    _n = 1;
    _delta = width - 1;
    _incr = ((width - 1) & ~((width - 1) >> 31)) + 1;
    if ( _incr < maxsize - i )
    {
      if ( p )
      {
        if ( _delta > 0 )
        {
          memset(p, 32, _delta);
          p += _delta;
        }
        *p = *f;
        p += _n;
      }
      i += _incr;
      goto LABEL_402;
    }
    return 0;
  }
LABEL_24:
  ltm.tm_sec = mbstate_zero.__count;
  ltm.tm_min = mbstate_zero.__wch;
  len = 0;
  if ( !format_end )
  {
    v7 = strlen(f);
    format_end = &f[v7 + 1];
  }
  fsize = format_end - f;
  do
  {
    bytes = mbrlen(&f[len], fsize - len, (mbstate_t *)&ltm);
    if ( !bytes )
      break;
    if ( bytes == -2 )
    {
      v8 = strlen(&f[len]);
      len += v8;
      break;
    }
    if ( bytes == -1 )
    {
      ++len;
      break;
    }
    len += bytes;
  }
  while ( !mbsinit((const mbstate_t *)&ltm) );
  _n_0 = len;
  _delta_0 = width - len;
  _incr_0 = len + ((width - len) & ~((int)(width - len) >> 31));
  if ( _incr_0 < maxsize - i )
  {
    if ( p )
    {
      if ( !digits && _delta_0 > 0 )
      {
        if ( pad == 48 )
          memset(p, 48, _delta_0);
        else
          memset(p, 32, _delta_0);
        p += _delta_0;
      }
      if ( to_lowcase )
      {
        memcpy_lowcase(p, f, _n_0);
      }
      else if ( to_uppcase )
      {
        memcpy_uppcase(p, f, _n_0);
      }
      else
      {
        memcpy(p, f, _n_0);
      }
      p += _n_0;
    }
    i += _incr_0;
    f += len - 1;
    goto LABEL_402;
  }
  return 0;
}
// 8055E18: conditional instruction was optimized away because of '%digits.4==0'
// 8055E2A: conditional instruction was optimized away because of '%pad.4==0'
// 8056348: conditional instruction was optimized away because of '%digits.4==0'
// 8056C18: conditional instruction was optimized away because of '%pad.4==2D'
// 805753C: conditional instruction was optimized away because of '%digits.4==0'
// 8057830: conditional instruction was optimized away because of '%digits.4==0'
// 80584DE: conditional instruction was optimized away because of '%digits.4==0'

//----- (0805865E) --------------------------------------------------------
int __cdecl iso_week_days(int yday, int wday)
{
  return yday - (yday - wday + 382) % 7 + 3;
}

//----- (080586BB) --------------------------------------------------------
size_t __cdecl nstrftime(char *s, size_t maxsize, const char *format, const tm *tp, int ut, int ns)
{
  return strftime_case_(0, s, maxsize, format, tp, ut, ns);
}

//----- (080586FC) --------------------------------------------------------
char *__cdecl umaxtostr(uintmax_t i, char *buf)
{
  char *p; // [esp+24h] [ebp-4h]

  p = buf + 20;
  buf[20] = 0;
  do
  {
    *--p = i % 0xA + 48;
    i /= 0xAuLL;
  }
  while ( i );
  return p;
}

//----- (08058788) --------------------------------------------------------
int __cdecl rpl_vfprintf(FILE *fp, const char *format, va_list args)
{
  size_t v3; // eax
  int v5; // [esp+18h] [ebp-800h]
  int saved_errno; // [esp+34h] [ebp-7E4h]
  size_t lenbuf; // [esp+38h] [ebp-7E0h] BYREF
  size_t len; // [esp+3Ch] [ebp-7DCh]
  char *output; // [esp+40h] [ebp-7D8h]
  char buf[2000]; // [esp+44h] [ebp-7D4h] BYREF
  unsigned int v11; // [esp+814h] [ebp-4h]

  v11 = __readgsdword(0x14u);
  lenbuf = 2000;
  output = vasnprintf(buf, &lenbuf, format, args);
  len = lenbuf;
  if ( output )
  {
    v3 = fwrite(output, 1u, len, fp);
    if ( v3 >= len )
    {
      if ( (len & 0x80000000) == 0 )
      {
        v5 = len;
      }
      else
      {
        *__errno_location() = 75;
        fseterr(fp);
        v5 = -1;
      }
    }
    else
    {
      if ( output != buf )
      {
        saved_errno = *__errno_location();
        free(output);
        *__errno_location() = saved_errno;
      }
      v5 = -1;
    }
  }
  else
  {
    fseterr(fp);
    v5 = -1;
  }
  return v5;
}

//----- (080588F0) --------------------------------------------------------
void *__cdecl xnmalloc(size_t n, size_t s)
{
  if ( 0xFFFFFFFF / s < n )
    xalloc_die();
  return xmalloc(s * n);
}

//----- (0805891E) --------------------------------------------------------
void *__cdecl xnrealloc(void *p, size_t n, size_t s)
{
  if ( 0xFFFFFFFF / s < n )
    xalloc_die();
  return xrealloc(p, s * n);
}

//----- (08058953) --------------------------------------------------------
void *__cdecl x2nrealloc(void *p, size_t *pn, size_t s)
{
  unsigned int n; // [esp+24h] [ebp-4h]

  n = *pn;
  if ( p )
  {
    if ( 0xAAAAAAAA / s <= n )
      xalloc_die();
    n += (n + 1) >> 1;
  }
  else if ( !n )
  {
    n = (0x40 / s == 0) + 0x40 / s;
  }
  *pn = n;
  return xrealloc(p, s * n);
}

//----- (080589CE) --------------------------------------------------------
char *__cdecl xcharalloc(size_t n)
{
  return (char *)xmalloc(n);
}

//----- (080589E1) --------------------------------------------------------
void *__cdecl xmalloc(size_t n)
{
  void *p; // [esp+14h] [ebp-4h]

  p = malloc(n);
  if ( !p && n )
    xalloc_die();
  return p;
}

//----- (08058A0B) --------------------------------------------------------
void *__cdecl xrealloc(void *p, size_t n)
{
  void *pa; // [esp+10h] [ebp+8h]

  pa = realloc(p, n);
  if ( !pa && n )
    xalloc_die();
  return pa;
}

//----- (08058A3C) --------------------------------------------------------
void *__cdecl _ZN10Fl_Browser10bottomlineEi(void *p, size_t *pn)
{
  return x2nrealloc(p, pn, 1u);
}

//----- (08058A5E) --------------------------------------------------------
void *__cdecl xzalloc(size_t s)
{
  void *v1; // edx

  v1 = xmalloc(s);
  return memset(v1, 0, s);
}

//----- (08058A8A) --------------------------------------------------------
void *__cdecl xcalloc(size_t n, size_t s)
{
  void *p; // [esp+14h] [ebp-4h]

  p = calloc(n, s);
  if ( !p )
    xalloc_die();
  return p;
}

//----- (08058AB5) --------------------------------------------------------
void *__cdecl xmemdup(const void *p, size_t s)
{
  void *v2; // edx

  v2 = xmalloc(s);
  return memcpy(v2, p, s);
}

//----- (08058AE0) --------------------------------------------------------
char *__cdecl xstrdup(const char *string)
{
  size_t v2; // [esp+4h] [ebp-4h]

  v2 = strlen(string) + 1;
  return (char *)xmemdup(string, v2);
}

//----- (08058B08) --------------------------------------------------------
void __cdecl xstrtol_error(strtol_error err, int opt_idx, char c, const option *long_options, const char *arg, int exit_status)
{
  char *v6; // edx
  const char *option; // [esp+28h] [ebp-10h]
  const char *msgid; // [esp+2Ch] [ebp-Ch]
  const char *hyphens; // [esp+30h] [ebp-8h]
  char option_buffer[2]; // [esp+36h] [ebp-2h] BYREF

  hyphens = (const char *)&unk_8061EF4;
  if ( (unsigned int)err > LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW )
  {
    if ( err != LONGINT_INVALID )
      goto LABEL_6;
    msgid = "invalid %s%s argument `%s'";
  }
  else if ( (unsigned int)err >= LONGINT_INVALID_SUFFIX_CHAR )
  {
    msgid = "invalid suffix in %s%s argument `%s'";
  }
  else
  {
    if ( err != LONGINT_OVERFLOW )
LABEL_6:
      abort();
    msgid = "%s%s argument `%s' too large";
  }
  if ( opt_idx >= 0 )
  {
    option = long_options[opt_idx].name;
  }
  else
  {
    hyphens = (char *)&unk_8061EF4 - opt_idx;
    option_buffer[0] = c;
    option_buffer[1] = 0;
    option = option_buffer;
  }
  v6 = gettext(msgid);
  error(exit_failure, 0, v6, hyphens, option, arg);
}

//----- (08058BC6) --------------------------------------------------------
void __cdecl __noreturn xstrtol_fatal(strtol_error err, int opt_idx, char c, const option *long_options, const char *arg)
{
  xstrtol_error(err, opt_idx, c, long_options, arg, exit_failure);
  abort();
}

//----- (08058C08) --------------------------------------------------------
strtol_error_0 __cdecl bkm_scale(unsigned int *x, int scale_factor)
{
  strtol_error_0 v3; // [esp+8h] [ebp-4h]

  if ( 0xFFFFFFFF / scale_factor >= *x )
  {
    *x *= scale_factor;
    v3 = LONGINT_OK;
  }
  else
  {
    *x = -1;
    v3 = LONGINT_OVERFLOW;
  }
  return v3;
}

//----- (08058C5A) --------------------------------------------------------
strtol_error_0 __cdecl bkm_scale_by_power(unsigned int *x, int base, int power)
{
  strtol_error_0 err; // [esp+14h] [ebp-4h]

  for ( err = LONGINT_OK; power-- != 0; err |= bkm_scale(x, base) )
    ;
  return err;
}

//----- (08058C92) --------------------------------------------------------
strtol_error_0 __cdecl xstrtoul(const char *s, char **ptr, int strtol_base, unsigned int *val, const char *valid_suffixes)
{
  char **v6; // [esp+1Ch] [ebp-3Ch]
  int v8; // [esp+24h] [ebp-34h]
  strtol_error_0 overflow; // [esp+34h] [ebp-24h]
  int suffixes; // [esp+38h] [ebp-20h]
  int base; // [esp+3Ch] [ebp-1Ch]
  const char *q; // [esp+40h] [ebp-18h]
  strtol_error_0 err; // [esp+44h] [ebp-14h]
  unsigned int tmp; // [esp+48h] [ebp-10h] BYREF
  char **p; // [esp+4Ch] [ebp-Ch]
  char *t_ptr; // [esp+50h] [ebp-8h] BYREF
  unsigned __int8 ch_0; // [esp+57h] [ebp-1h]

  err = LONGINT_OK;
  if ( strtol_base < 0 || strtol_base > 36 )
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "xstrtol.c", 0x53u, "xstrtoul");
  if ( ptr )
    v6 = ptr;
  else
    v6 = &t_ptr;
  p = v6;
  q = s;
  for ( ch_0 = *s; ((*__ctype_b_loc())[ch_0] & 0x2000) != 0; ch_0 = *q )
    ++q;
  if ( ch_0 != 45 )
  {
    *__errno_location() = 0;
    tmp = strtoul(s, p, strtol_base);
    if ( *p == s )
    {
      if ( !valid_suffixes || !**p || !strchr(valid_suffixes, **p) )
        return 4;
      tmp = 1;
    }
    else if ( *__errno_location() )
    {
      if ( *__errno_location() != 34 )
        return 4;
      err = LONGINT_OVERFLOW;
    }
    if ( !valid_suffixes )
    {
      *val = tmp;
      return err;
    }
    if ( !**p )
    {
LABEL_51:
      *val = tmp;
      return err;
    }
    base = 1024;
    suffixes = 1;
    if ( !strchr(valid_suffixes, **p) )
    {
      *val = tmp;
      return err | 2;
    }
    if ( strchr(valid_suffixes, 48) )
    {
      v8 = (*p)[1];
      if ( v8 == 68 )
      {
LABEL_34:
        base = 1000;
        suffixes = 2;
        goto LABEL_35;
      }
      if ( v8 != 105 )
      {
        if ( v8 != 66 )
          goto LABEL_35;
        goto LABEL_34;
      }
      if ( (*p)[2] == 66 )
        suffixes = 3;
    }
LABEL_35:
    switch ( **p )
    {
      case 'B':
        overflow = bkm_scale(&tmp, 1024);
        goto LABEL_49;
      case 'E':
        overflow = bkm_scale_by_power(&tmp, base, 6);
        goto LABEL_49;
      case 'G':
      case 'g':
        overflow = bkm_scale_by_power(&tmp, base, 3);
        goto LABEL_49;
      case 'K':
      case 'k':
        overflow = bkm_scale_by_power(&tmp, base, 1);
        goto LABEL_49;
      case 'M':
      case 'm':
        overflow = bkm_scale_by_power(&tmp, base, 2);
        goto LABEL_49;
      case 'P':
        overflow = bkm_scale_by_power(&tmp, base, 5);
        goto LABEL_49;
      case 'T':
      case 't':
        overflow = bkm_scale_by_power(&tmp, base, 4);
        goto LABEL_49;
      case 'Y':
        overflow = bkm_scale_by_power(&tmp, base, 8);
        goto LABEL_49;
      case 'Z':
        overflow = bkm_scale_by_power(&tmp, base, 7);
        goto LABEL_49;
      case 'b':
        overflow = bkm_scale(&tmp, 512);
        goto LABEL_49;
      case 'c':
        overflow = LONGINT_OK;
        goto LABEL_49;
      case 'w':
        overflow = bkm_scale(&tmp, 2);
LABEL_49:
        err |= overflow;
        *p += suffixes;
        if ( **p )
          err |= 2u;
        goto LABEL_51;
      default:
        *val = tmp;
        return err | 2;
    }
  }
  return 4;
}

//----- (08059078) --------------------------------------------------------
void __cdecl fseterr(FILE *fp)
{
  fp->_flags |= 0x20u;
}

//----- (0805908C) --------------------------------------------------------
char *__cdecl xstrndup(const char *string, size_t n)
{
  char *s; // [esp+14h] [ebp-4h]

  s = (char *)strndup(string, n);
  if ( !s )
    xalloc_die();
  return s;
}
// 80499CC: using guessed type int __cdecl strndup(_DWORD, _DWORD);

//----- (080590B8) --------------------------------------------------------
strtol_error_0 __cdecl bkm_scale_0(uintmax_t *x, int scale_factor)
{
  strtol_error_0 v3; // [esp+14h] [ebp-24h]

  if ( 0xFFFFFFFFFFFFFFFFLL / scale_factor >= *x )
  {
    *x *= scale_factor;
    v3 = LONGINT_OK;
  }
  else
  {
    *(_DWORD *)x = -1;
    *((_DWORD *)x + 1) = -1;
    v3 = LONGINT_OVERFLOW;
  }
  return v3;
}

//----- (08059166) --------------------------------------------------------
strtol_error_0 __cdecl bkm_scale_by_power_0(uintmax_t *x, int base, int power)
{
  strtol_error_0 err; // [esp+14h] [ebp-4h]

  for ( err = LONGINT_OK; power-- != 0; err |= bkm_scale_0(x, base) )
    ;
  return err;
}

//----- (0805919E) --------------------------------------------------------
strtol_error_0 __cdecl xstrtoumax(const char *s, char **ptr, int strtol_base, uintmax_t *val, const char *valid_suffixes)
{
  int v5; // edx
  int v6; // edx
  int v7; // edx
  char **v9; // [esp+1Ch] [ebp-3Ch]
  int v11; // [esp+24h] [ebp-34h]
  uintmax_t tmp; // [esp+30h] [ebp-28h] BYREF
  strtol_error_0 overflow; // [esp+38h] [ebp-20h]
  int suffixes; // [esp+3Ch] [ebp-1Ch]
  int base; // [esp+40h] [ebp-18h]
  const char *q; // [esp+44h] [ebp-14h]
  strtol_error_0 err; // [esp+48h] [ebp-10h]
  char **p; // [esp+4Ch] [ebp-Ch]
  char *t_ptr; // [esp+50h] [ebp-8h] BYREF
  unsigned __int8 ch_0; // [esp+57h] [ebp-1h]

  err = LONGINT_OK;
  if ( strtol_base < 0 || strtol_base > 36 )
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "xstrtol.c", 0x53u, "xstrtoumax");
  if ( ptr )
    v9 = ptr;
  else
    v9 = &t_ptr;
  p = v9;
  q = s;
  for ( ch_0 = *s; ((*__ctype_b_loc())[ch_0] & 0x2000) != 0; ch_0 = *q )
    ++q;
  if ( ch_0 != 45 )
  {
    *__errno_location() = 0;
    tmp = strtoumax(s, p, strtol_base);
    if ( *p == s )
    {
      if ( !valid_suffixes || !**p || !strchr(valid_suffixes, **p) )
        return 4;
      tmp = 1LL;
    }
    else if ( *__errno_location() )
    {
      if ( *__errno_location() != 34 )
        return 4;
      err = LONGINT_OVERFLOW;
    }
    if ( !valid_suffixes )
    {
      *val = tmp;
      return err;
    }
    if ( !**p )
    {
LABEL_51:
      v7 = HIDWORD(tmp);
      *(_DWORD *)val = tmp;
      *((_DWORD *)val + 1) = v7;
      return err;
    }
    base = 1024;
    suffixes = 1;
    if ( !strchr(valid_suffixes, **p) )
    {
      v5 = HIDWORD(tmp);
      *(_DWORD *)val = tmp;
      *((_DWORD *)val + 1) = v5;
      return err | 2;
    }
    if ( strchr(valid_suffixes, 48) )
    {
      v11 = (*p)[1];
      if ( v11 == 68 )
      {
LABEL_34:
        base = 1000;
        ++suffixes;
        goto LABEL_35;
      }
      if ( v11 != 105 )
      {
        if ( v11 != 66 )
          goto LABEL_35;
        goto LABEL_34;
      }
      if ( (*p)[2] == 66 )
        suffixes += 2;
    }
LABEL_35:
    switch ( **p )
    {
      case 'B':
        overflow = bkm_scale_0(&tmp, 1024);
        goto LABEL_49;
      case 'E':
        overflow = bkm_scale_by_power_0(&tmp, base, 6);
        goto LABEL_49;
      case 'G':
      case 'g':
        overflow = bkm_scale_by_power_0(&tmp, base, 3);
        goto LABEL_49;
      case 'K':
      case 'k':
        overflow = bkm_scale_by_power_0(&tmp, base, 1);
        goto LABEL_49;
      case 'M':
      case 'm':
        overflow = bkm_scale_by_power_0(&tmp, base, 2);
        goto LABEL_49;
      case 'P':
        overflow = bkm_scale_by_power_0(&tmp, base, 5);
        goto LABEL_49;
      case 'T':
      case 't':
        overflow = bkm_scale_by_power_0(&tmp, base, 4);
        goto LABEL_49;
      case 'Y':
        overflow = bkm_scale_by_power_0(&tmp, base, 8);
        goto LABEL_49;
      case 'Z':
        overflow = bkm_scale_by_power_0(&tmp, base, 7);
        goto LABEL_49;
      case 'b':
        overflow = bkm_scale_0(&tmp, 512);
        goto LABEL_49;
      case 'c':
        overflow = LONGINT_OK;
        goto LABEL_49;
      case 'w':
        overflow = bkm_scale_0(&tmp, 2);
LABEL_49:
        err |= overflow;
        *p += suffixes;
        if ( **p )
          err |= 2u;
        goto LABEL_51;
      default:
        v6 = HIDWORD(tmp);
        *(_DWORD *)val = tmp;
        *((_DWORD *)val + 1) = v6;
        return err | 2;
    }
  }
  return 4;
}

//----- (080595A4) --------------------------------------------------------
int __cdecl close_stream(FILE *stream)
{
  bool fclose_fail; // [esp+15h] [ebp-3h]
  bool prev_fail; // [esp+16h] [ebp-2h]
  bool some_pending; // [esp+17h] [ebp-1h]

  some_pending = __fpending(stream) != 0;
  prev_fail = ferror_unlocked(stream) != 0;
  fclose_fail = fclose(stream) != 0;
  if ( !prev_fail && (!fclose_fail || !some_pending && *__errno_location() == 9) )
    return 0;
  if ( !fclose_fail )
    *__errno_location() = 0;
  return -1;
}

//----- (08059634) --------------------------------------------------------
int __cdecl is_infinitel(long double x)
{
  return rpl_isnanl(x) || x == x + x && x != 0.0;
}

//----- (0805969A) --------------------------------------------------------
char *__cdecl vasnprintf(char *resultbuf, size_t *lengthp, const char *format, va_list args)
{
  void *v4; // esp
  _DWORD *v5; // ecx
  argument *v6; // eax
  unsigned int v7; // ecx
  unsigned int v8; // edx
  __int16 v9; // ax
  size_t v10; // eax
  size_t v11; // eax
  argument *v12; // eax
  int v13; // edx
  argument *v14; // eax
  unsigned int v15; // ecx
  unsigned int v16; // edx
  size_t v17; // eax
  size_t v18; // eax
  size_t v19; // eax
  char *v20; // eax
  long double v21; // [esp+0h] [ebp-558h]
  char v22; // [esp+33h] [ebp-525h] BYREF
  unsigned int v23; // [esp+38h] [ebp-520h]
  unsigned int v24; // [esp+3Ch] [ebp-51Ch]
  unsigned int v25; // [esp+40h] [ebp-518h]
  unsigned int v26; // [esp+44h] [ebp-514h]
  unsigned int v27; // [esp+48h] [ebp-510h]
  unsigned int v28; // [esp+4Ch] [ebp-50Ch]
  unsigned int v29; // [esp+50h] [ebp-508h]
  unsigned int v30; // [esp+54h] [ebp-504h]
  unsigned int v31; // [esp+58h] [ebp-500h]
  unsigned int v32; // [esp+5Ch] [ebp-4FCh]
  unsigned int v33; // [esp+60h] [ebp-4F8h]
  unsigned int v34; // [esp+64h] [ebp-4F4h]
  unsigned int v35; // [esp+68h] [ebp-4F0h]
  unsigned int v36; // [esp+6Ch] [ebp-4ECh]
  unsigned int v37; // [esp+70h] [ebp-4E8h]
  unsigned int v38; // [esp+74h] [ebp-4E4h]
  unsigned int v39; // [esp+78h] [ebp-4E0h]
  int v40; // [esp+7Ch] [ebp-4DCh]
  int v41; // [esp+84h] [ebp-4D4h]
  char *v43; // [esp+8Ch] [ebp-4CCh]
  size_t v44; // [esp+90h] [ebp-4C8h]
  size_t v45; // [esp+94h] [ebp-4C4h]
  size_t v46; // [esp+98h] [ebp-4C0h]
  size_t v47; // [esp+9Ch] [ebp-4BCh]
  size_t size2; // [esp+A0h] [ebp-4B8h]
  size_t size1; // [esp+A4h] [ebp-4B4h]
  size_t v50; // [esp+A8h] [ebp-4B0h]
  size_t v51; // [esp+ACh] [ebp-4ACh]
  size_t v52; // [esp+B0h] [ebp-4A8h]
  size_t v53; // [esp+B4h] [ebp-4A4h]
  size_t v54; // [esp+B8h] [ebp-4A0h]
  size_t v55; // [esp+BCh] [ebp-49Ch]
  size_t v56; // [esp+C0h] [ebp-498h]
  size_t v57; // [esp+C4h] [ebp-494h]
  size_t v58; // [esp+C8h] [ebp-490h]
  size_t v59; // [esp+CCh] [ebp-48Ch]
  size_t v60; // [esp+D0h] [ebp-488h]
  size_t v61; // [esp+D4h] [ebp-484h]
  size_t v62; // [esp+D8h] [ebp-480h]
  size_t v63; // [esp+DCh] [ebp-47Ch]
  va_list argsa; // [esp+E0h] [ebp-478h]
  const char *formata; // [esp+E4h] [ebp-474h]
  size_t *lengthpa; // [esp+E8h] [ebp-470h]
  char *resultbufa; // [esp+ECh] [ebp-46Ch]
  char_directives d; // [esp+F0h] [ebp-468h] BYREF
  long double v69; // [esp+100h] [ebp-458h]
  long double x; // [esp+110h] [ebp-448h]
  double v71; // [esp+128h] [ebp-430h]
  unsigned __int64 v72; // [esp+130h] [ebp-428h]
  __int64 v73; // [esp+138h] [ebp-420h]
  int prefixes[2]; // [esp+140h] [ebp-418h]
  arguments a; // [esp+148h] [ebp-410h] BYREF
  char *memory_6; // [esp+150h] [ebp-408h]
  char *memory_5; // [esp+154h] [ebp-404h]
  size_t memory_size_5; // [esp+158h] [ebp-400h]
  char *memory_4; // [esp+15Ch] [ebp-3FCh]
  size_t memory_size_4; // [esp+160h] [ebp-3F8h]
  size_t n_3; // [esp+164h] [ebp-3F4h]
  char *memory_3; // [esp+168h] [ebp-3F0h]
  size_t memory_size_3; // [esp+16Ch] [ebp-3ECh]
  size_t bigger_need; // [esp+170h] [ebp-3E8h]
  void *v85; // [esp+174h] [ebp-3E4h]
  const wchar_t *v86; // [esp+178h] [ebp-3E0h]
  const char *v87; // [esp+17Ch] [ebp-3DCh]
  wint_t v88; // [esp+180h] [ebp-3D8h]
  int v89; // [esp+184h] [ebp-3D4h]
  unsigned int v90; // [esp+188h] [ebp-3D0h]
  int v91; // [esp+18Ch] [ebp-3CCh]
  unsigned int v92; // [esp+190h] [ebp-3C8h]
  int v93; // [esp+194h] [ebp-3C4h]
  unsigned int v94; // [esp+198h] [ebp-3C0h]
  int v95; // [esp+19Ch] [ebp-3BCh]
  unsigned int v96; // [esp+1A0h] [ebp-3B8h]
  int v97; // [esp+1A4h] [ebp-3B4h]
  size_t maxlen; // [esp+1A8h] [ebp-3B0h]
  int retcount; // [esp+1ACh] [ebp-3ACh]
  int count_0; // [esp+1B0h] [ebp-3A8h] BYREF
  char *memory_2; // [esp+1B4h] [ebp-3A4h]
  size_t memory_size_2; // [esp+1B8h] [ebp-3A0h]
  size_t n_2; // [esp+1C0h] [ebp-398h]
  size_t n_1; // [esp+1C8h] [ebp-390h]
  unsigned int prefix_count; // [esp+1CCh] [ebp-38Ch]
  char *fbp; // [esp+1D0h] [ebp-388h]
  int flags_0; // [esp+1D4h] [ebp-384h]
  arg_type type; // [esp+1D8h] [ebp-380h]
  char *memory_1; // [esp+1DCh] [ebp-37Ch]
  size_t memory_size_1; // [esp+1E0h] [ebp-378h]
  size_t n_0; // [esp+1E4h] [ebp-374h]
  size_t count; // [esp+1E8h] [ebp-370h]
  char *q_0; // [esp+1ECh] [ebp-36Ch]
  char *q; // [esp+1F0h] [ebp-368h]
  char *end; // [esp+1F4h] [ebp-364h]
  size_t pad; // [esp+1F8h] [ebp-360h]
  int sign; // [esp+1FCh] [ebp-35Ch]
  size_t tmp_memsize; // [esp+200h] [ebp-358h]
  const char *digitp_0; // [esp+204h] [ebp-354h]
  int v120; // [esp+208h] [ebp-350h]
  const char *digitp; // [esp+20Ch] [ebp-34Ch]
  int arg; // [esp+210h] [ebp-348h]
  char *p; // [esp+214h] [ebp-344h]
  char *pad_ptr; // [esp+218h] [ebp-340h]
  char *tmp; // [esp+21Ch] [ebp-33Ch]
  size_t tmp_length; // [esp+220h] [ebp-338h]
  size_t precision; // [esp+224h] [ebp-334h]
  int has_precision; // [esp+228h] [ebp-330h]
  size_t width; // [esp+22Ch] [ebp-32Ch]
  int has_width; // [esp+230h] [ebp-328h]
  int flags; // [esp+234h] [ebp-324h]
  char *memory_0; // [esp+238h] [ebp-320h]
  size_t memory_size_0; // [esp+23Ch] [ebp-31Ch]
  size_t augmented_length_0; // [esp+240h] [ebp-318h]
  char *memory; // [esp+244h] [ebp-314h]
  size_t memory_size; // [esp+248h] [ebp-310h]
  size_t augmented_length; // [esp+24Ch] [ebp-30Ch]
  size_t n; // [esp+250h] [ebp-308h]
  size_t buf_memsize; // [esp+254h] [ebp-304h]
  size_t length; // [esp+258h] [ebp-300h]
  size_t allocated; // [esp+25Ch] [ebp-2FCh]
  char *result; // [esp+260h] [ebp-2F8h]
  char_directive *dp; // [esp+264h] [ebp-2F4h]
  size_t i; // [esp+268h] [ebp-2F0h]
  const char *cp; // [esp+26Ch] [ebp-2ECh]
  char *buf_malloced; // [esp+270h] [ebp-2E8h]
  char *buf; // [esp+274h] [ebp-2E4h]
  size_t buf_neededlength; // [esp+278h] [ebp-2E0h]
  fpucw_t oldcw; // [esp+27Eh] [ebp-2DAh]
  char tmpbuf[700]; // [esp+280h] [ebp-2D8h] BYREF
  unsigned int v151; // [esp+53Ch] [ebp-1Ch]

  resultbufa = resultbuf;
  lengthpa = lengthp;
  formata = format;
  argsa = args;
  v151 = __readgsdword(0x14u);
  if ( printf_parse(format, &d, &a) < 0 )
    return 0;
  if ( printf_fetchargs(argsa, &a) < 0 )
  {
    free(d.dir);
    if ( a.arg )
      free(a.arg);
    *__errno_location() = 22;
    return 0;
  }
  buf_neededlength = xsum4(7u, d.max_width_length, d.max_precision_length, 6u);
  if ( buf_neededlength > 0xF9F )
  {
    buf_memsize = buf_neededlength;
    if ( buf_neededlength == -1 )
      goto out_of_memory_1;
    buf = (char *)malloc(buf_memsize);
    if ( !buf )
      goto out_of_memory_1;
    buf_malloced = buf;
  }
  else
  {
    v4 = alloca(16 * ((buf_neededlength + 30) >> 4));
    v43 = (char *)(16 * ((unsigned int)&v22 >> 4));
    buf = v43;
    buf_malloced = 0;
  }
  if ( resultbufa )
  {
    result = resultbufa;
    allocated = *lengthpa;
  }
  else
  {
    result = 0;
    allocated = 0;
  }
  length = 0;
  cp = formata;
  i = 0;
  for ( dp = d.dir; ; ++dp )
  {
    if ( dp->dir_start != cp )
    {
      n = dp->dir_start - cp;
      augmented_length = xsum(length, n);
      if ( augmented_length > allocated )
      {
        if ( allocated )
        {
          if ( (allocated & 0x80000000) != 0 )
            v45 = -1;
          else
            v45 = 2 * allocated;
          v44 = v45;
        }
        else
        {
          v44 = 12;
        }
        allocated = v44;
        if ( augmented_length > v44 )
          allocated = augmented_length;
        memory_size = allocated;
        if ( allocated == -1 )
          goto out_of_memory;
        memory = (char *)(result != resultbufa && result ? realloc(result, memory_size) : malloc(memory_size));
        if ( !memory )
          goto out_of_memory;
        if ( result == resultbufa && length )
          memcpy(memory, result, length);
        result = memory;
      }
      memcpy(&result[length], cp, n);
      length = augmented_length;
    }
    if ( d.count == i )
      break;
    if ( dp->conversion == 37 )
    {
      if ( dp->arg_index != -1 )
        abort();
      augmented_length_0 = xsum(length, 1u);
      if ( augmented_length_0 > allocated )
      {
        if ( allocated )
        {
          if ( (allocated & 0x80000000) != 0 )
            v47 = -1;
          else
            v47 = 2 * allocated;
          v46 = v47;
        }
        else
        {
          v46 = 12;
        }
        allocated = v46;
        if ( augmented_length_0 > v46 )
          allocated = augmented_length_0;
        memory_size_0 = allocated;
        if ( allocated == -1 )
          goto out_of_memory;
        memory_0 = (char *)(result != resultbufa && result ? realloc(result, memory_size_0) : malloc(memory_size_0));
        if ( !memory_0 )
          goto out_of_memory;
        if ( result == resultbufa && length )
          memcpy(memory_0, result, length);
        result = memory_0;
      }
      result[length] = 37;
      length = augmented_length_0;
    }
    else
    {
      if ( dp->arg_index == -1 )
        abort();
      if ( dp->conversion == 110 )
      {
        v41 = a.arg[dp->arg_index].type - 18;
        switch ( v41 )
        {
          case 0:
            *a.arg[dp->arg_index].a.a_count_schar_pointer = length;
            break;
          case 1:
            *a.arg[dp->arg_index].a.a_count_short_pointer = length;
            break;
          case 2:
            *a.arg[dp->arg_index].a.a_count_int_pointer = length;
            break;
          case 3:
            *a.arg[dp->arg_index].a.a_count_int_pointer = length;
            break;
          case 4:
            v5 = a.arg[dp->arg_index].a.a_count_int_pointer;
            *v5 = length;
            v5[1] = 0;
            break;
          default:
            abort();
            return v20;
        }
      }
      else
      {
        if ( dp->conversion != 102
          && dp->conversion != 70
          && dp->conversion != 101
          && dp->conversion != 69
          && dp->conversion != 103
          && dp->conversion != 71
          && dp->conversion != 97
          && dp->conversion != 65
          || a.arg[dp->arg_index].type != TYPE_LONGDOUBLE
          || !is_infinitel(a.arg[dp->arg_index].a.a_longdouble) )
        {
          type = a.arg[dp->arg_index].type;
          flags_0 = dp->flags;
          fbp = buf;
          *buf = 37;
          ++fbp;
          if ( (flags_0 & 1) != 0 )
            *fbp++ = 39;
          if ( (flags_0 & 2) != 0 )
            *fbp++ = 45;
          if ( (flags_0 & 4) != 0 )
            *fbp++ = 43;
          if ( (flags_0 & 8) != 0 )
            *fbp++ = 32;
          if ( (flags_0 & 0x10) != 0 )
            *fbp++ = 35;
          if ( (flags_0 & 0x20) != 0 )
            *fbp++ = 48;
          if ( dp->width_start != dp->width_end )
          {
            n_1 = dp->width_end - dp->width_start;
            memcpy(fbp, dp->width_start, n_1);
            fbp += n_1;
          }
          if ( dp->precision_start != dp->precision_end )
          {
            n_2 = dp->precision_end - dp->precision_start;
            memcpy(fbp, dp->precision_start, n_2);
            fbp += n_2;
          }
          if ( (unsigned int)type <= TYPE_WIDE_STRING )
          {
            v40 = 1 << type;
            if ( ((1 << type) & 0x14180) != 0 )
              goto LABEL_207;
            if ( (v40 & 0x1000) != 0 )
            {
              *fbp++ = 76;
            }
            else if ( (v40 & 0x600) != 0 )
            {
              *fbp++ = 108;
LABEL_207:
              *fbp++ = 108;
            }
          }
          *(_WORD *)fbp = (unsigned __int8)dp->conversion;
          prefix_count = 0;
          if ( dp->width_arg_index != -1 )
          {
            if ( a.arg[dp->width_arg_index].type != TYPE_INT )
              abort();
            prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;
          }
          if ( dp->precision_arg_index != -1 )
          {
            if ( a.arg[dp->precision_arg_index].type != TYPE_INT )
              abort();
            prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;
          }
          v10 = xsum(length, 2u);
          if ( v10 > allocated )
          {
            if ( allocated )
            {
              if ( (allocated & 0x80000000) != 0 )
                v55 = -1;
              else
                v55 = 2 * allocated;
              v54 = v55;
            }
            else
            {
              v54 = 12;
            }
            allocated = v54;
            v11 = xsum(length, 2u);
            if ( v11 > allocated )
              allocated = xsum(length, 2u);
            memory_size_2 = allocated;
            if ( allocated != -1 )
            {
              memory_2 = (char *)(result != resultbufa && result ? realloc(result, memory_size_2) : malloc(memory_size_2));
              if ( memory_2 )
              {
                if ( result == resultbufa && length )
                  memcpy(memory_2, result, length);
                result = memory_2;
                goto LABEL_236;
              }
            }
out_of_memory:
            if ( result != resultbufa && result )
              free(result);
            if ( buf_malloced )
              free(buf_malloced);
out_of_memory_1:
            free(d.dir);
            if ( a.arg )
              free(a.arg);
            *__errno_location() = 12;
            return 0;
          }
LABEL_236:
          result[length] = 0;
          while ( 1 )
          {
            count_0 = -1;
            retcount = 0;
            maxlen = allocated - length;
            if ( (int)(allocated - length) < 0 )
              maxlen = 0x7FFFFFFF;
            switch ( type )
            {
              case TYPE_SCHAR:
                v97 = a.arg[dp->arg_index].a.a_schar;
                v39 = prefix_count;
                if ( prefix_count == 1 )
                {
                  retcount = snprintf(&result[length], maxlen, buf, prefixes[0], v97, &count_0);
                }
                else if ( v39 )
                {
                  if ( v39 != 2 )
                    abort();
                  retcount = snprintf(&result[length], maxlen, buf, prefixes[0], prefixes[1], v97, &count_0);
                }
                else
                {
                  retcount = snprintf(&result[length], maxlen, buf, v97, &count_0);
                }
                break;
              case TYPE_UCHAR:
                v96 = a.arg[dp->arg_index].a.a_uchar;
                v38 = prefix_count;
                if ( prefix_count == 1 )
                {
                  retcount = snprintf(&result[length], maxlen, buf, prefixes[0], v96, &count_0);
                }
                else if ( v38 )
                {
                  if ( v38 != 2 )
                    abort();
                  retcount = snprintf(&result[length], maxlen, buf, prefixes[0], prefixes[1], v96, &count_0);
                }
                else
                {
                  retcount = snprintf(&result[length], maxlen, buf, v96, &count_0);
                }
                break;
              case TYPE_SHORT:
                v95 = a.arg[dp->arg_index].a.a_short;
                v37 = prefix_count;
                if ( prefix_count == 1 )
                {
                  retcount = snprintf(&result[length], maxlen, buf, prefixes[0], v95, &count_0);
                }
                else if ( v37 )
                {
                  if ( v37 != 2 )
                    abort();
                  retcount = snprintf(&result[length], maxlen, buf, prefixes[0], prefixes[1], v95, &count_0);
                }
                else
                {
                  retcount = snprintf(&result[length], maxlen, buf, v95, &count_0);
                }
                break;
              case TYPE_USHORT:
                v94 = a.arg[dp->arg_index].a.a_ushort;
                v36 = prefix_count;
                if ( prefix_count == 1 )
                {
                  retcount = snprintf(&result[length], maxlen, buf, prefixes[0], v94, &count_0);
                }
                else if ( v36 )
                {
                  if ( v36 != 2 )
                    abort();
                  retcount = snprintf(&result[length], maxlen, buf, prefixes[0], prefixes[1], v94, &count_0);
                }
                else
                {
                  retcount = snprintf(&result[length], maxlen, buf, v94, &count_0);
                }
                break;
              case TYPE_INT:
                v93 = a.arg[dp->arg_index].a.a_int;
                v35 = prefix_count;
                if ( prefix_count == 1 )
                {
                  retcount = snprintf(&result[length], maxlen, buf, prefixes[0], v93, &count_0);
                }
                else if ( v35 )
                {
                  if ( v35 != 2 )
                    abort();
                  retcount = snprintf(&result[length], maxlen, buf, prefixes[0], prefixes[1], v93, &count_0);
                }
                else
                {
                  retcount = snprintf(&result[length], maxlen, buf, v93, &count_0);
                }
                break;
              case TYPE_UINT:
                v92 = a.arg[dp->arg_index].a.a_uint;
                v34 = prefix_count;
                if ( prefix_count == 1 )
                {
                  retcount = snprintf(&result[length], maxlen, buf, prefixes[0], v92, &count_0);
                }
                else if ( v34 )
                {
                  if ( v34 != 2 )
                    abort();
                  retcount = snprintf(&result[length], maxlen, buf, prefixes[0], prefixes[1], v92, &count_0);
                }
                else
                {
                  retcount = snprintf(&result[length], maxlen, buf, v92, &count_0);
                }
                break;
              case TYPE_LONGINT:
                v91 = a.arg[dp->arg_index].a.a_int;
                v33 = prefix_count;
                if ( prefix_count == 1 )
                {
                  retcount = snprintf(&result[length], maxlen, buf, prefixes[0], v91, &count_0);
                }
                else if ( v33 )
                {
                  if ( v33 != 2 )
                    abort();
                  retcount = snprintf(&result[length], maxlen, buf, prefixes[0], prefixes[1], v91, &count_0);
                }
                else
                {
                  retcount = snprintf(&result[length], maxlen, buf, v91, &count_0);
                }
                break;
              case TYPE_ULONGINT:
                v90 = a.arg[dp->arg_index].a.a_uint;
                v32 = prefix_count;
                if ( prefix_count == 1 )
                {
                  retcount = snprintf(&result[length], maxlen, buf, prefixes[0], v90, &count_0);
                }
                else if ( v32 )
                {
                  if ( v32 != 2 )
                    abort();
                  retcount = snprintf(&result[length], maxlen, buf, prefixes[0], prefixes[1], v90, &count_0);
                }
                else
                {
                  retcount = snprintf(&result[length], maxlen, buf, v90, &count_0);
                }
                break;
              case TYPE_LONGLONGINT:
                v12 = &a.arg[dp->arg_index];
                v13 = *((_DWORD *)&v12->a.a_ushort + 1);
                LODWORD(v73) = v12->a.a_int;
                HIDWORD(v73) = v13;
                v31 = prefix_count;
                if ( prefix_count == 1 )
                {
                  retcount = snprintf(&result[length], maxlen, buf, prefixes[0], v73, &count_0);
                }
                else if ( v31 )
                {
                  if ( v31 != 2 )
                    abort();
                  retcount = snprintf(&result[length], maxlen, buf, prefixes[0], prefixes[1], v73, &count_0);
                }
                else
                {
                  retcount = snprintf(&result[length], maxlen, buf, v73, &count_0);
                }
                break;
              case TYPE_ULONGLONGINT:
                v72 = a.arg[dp->arg_index].a.a_ulonglongint;
                v30 = prefix_count;
                if ( prefix_count == 1 )
                {
                  retcount = snprintf(&result[length], maxlen, buf, prefixes[0], v72, &count_0);
                }
                else if ( v30 )
                {
                  if ( v30 != 2 )
                    abort();
                  retcount = snprintf(&result[length], maxlen, buf, prefixes[0], prefixes[1], v72, &count_0);
                }
                else
                {
                  retcount = snprintf(&result[length], maxlen, buf, v72, &count_0);
                }
                break;
              case TYPE_DOUBLE:
                v71 = a.arg[dp->arg_index].a.a_double;
                v29 = prefix_count;
                if ( prefix_count == 1 )
                {
                  retcount = snprintf(&result[length], maxlen, buf, prefixes[0], v71, &count_0);
                }
                else if ( v29 )
                {
                  if ( v29 != 2 )
                    abort();
                  retcount = snprintf(&result[length], maxlen, buf, prefixes[0], prefixes[1], v71, &count_0);
                }
                else
                {
                  retcount = snprintf(&result[length], maxlen, buf, v71, &count_0);
                }
                break;
              case TYPE_LONGDOUBLE:
                v14 = &a.arg[dp->arg_index];
                v15 = *(&v14->a.a_ulongint + 2);
                v16 = *((_DWORD *)&v14->a.a_ushort + 1);
                LODWORD(v69) = v14->a.a_int;
                *(_QWORD *)((char *)&v69 + 4) = __PAIR64__(v15, v16);
                v28 = prefix_count;
                if ( prefix_count == 1 )
                {
                  retcount = snprintf(
                               &result[length],
                               maxlen,
                               buf,
                               prefixes[0],
                               *(_QWORD *)&v69,
                               HIDWORD(v69),
                               &count_0);
                }
                else if ( v28 )
                {
                  if ( v28 != 2 )
                    abort();
                  retcount = snprintf(
                               &result[length],
                               maxlen,
                               buf,
                               prefixes[0],
                               prefixes[1],
                               *(_QWORD *)&v69,
                               HIDWORD(v69),
                               &count_0);
                }
                else
                {
                  retcount = snprintf(&result[length], maxlen, buf, *(_QWORD *)&v69, HIDWORD(v69), &count_0);
                }
                break;
              case TYPE_CHAR:
                v89 = a.arg[dp->arg_index].a.a_int;
                v27 = prefix_count;
                if ( prefix_count == 1 )
                {
                  retcount = snprintf(&result[length], maxlen, buf, prefixes[0], v89, &count_0);
                }
                else if ( v27 )
                {
                  if ( v27 != 2 )
                    abort();
                  retcount = snprintf(&result[length], maxlen, buf, prefixes[0], prefixes[1], v89, &count_0);
                }
                else
                {
                  retcount = snprintf(&result[length], maxlen, buf, v89, &count_0);
                }
                break;
              case TYPE_WIDE_CHAR:
                v88 = a.arg[dp->arg_index].a.a_uint;
                v26 = prefix_count;
                if ( prefix_count == 1 )
                {
                  retcount = snprintf(&result[length], maxlen, buf, prefixes[0], v88, &count_0);
                }
                else if ( v26 )
                {
                  if ( v26 != 2 )
                    abort();
                  retcount = snprintf(&result[length], maxlen, buf, prefixes[0], prefixes[1], v88, &count_0);
                }
                else
                {
                  retcount = snprintf(&result[length], maxlen, buf, v88, &count_0);
                }
                break;
              case TYPE_STRING:
                v87 = a.arg[dp->arg_index].a.a_string;
                v25 = prefix_count;
                if ( prefix_count == 1 )
                {
                  retcount = snprintf(&result[length], maxlen, buf, prefixes[0], v87, &count_0);
                }
                else if ( v25 )
                {
                  if ( v25 != 2 )
                    abort();
                  retcount = snprintf(&result[length], maxlen, buf, prefixes[0], prefixes[1], v87, &count_0);
                }
                else
                {
                  retcount = snprintf(&result[length], maxlen, buf, v87, &count_0);
                }
                break;
              case TYPE_WIDE_STRING:
                v86 = a.arg[dp->arg_index].a.a_wide_string;
                v24 = prefix_count;
                if ( prefix_count == 1 )
                {
                  retcount = snprintf(&result[length], maxlen, buf, prefixes[0], v86, &count_0);
                }
                else if ( v24 )
                {
                  if ( v24 != 2 )
                    abort();
                  retcount = snprintf(&result[length], maxlen, buf, prefixes[0], prefixes[1], v86, &count_0);
                }
                else
                {
                  retcount = snprintf(&result[length], maxlen, buf, v86, &count_0);
                }
                break;
              case TYPE_POINTER:
                v85 = a.arg[dp->arg_index].a.a_pointer;
                v23 = prefix_count;
                if ( prefix_count == 1 )
                {
                  retcount = snprintf(&result[length], maxlen, buf, prefixes[0], v85, &count_0);
                }
                else if ( v23 )
                {
                  if ( v23 != 2 )
                    abort();
                  retcount = snprintf(&result[length], maxlen, buf, prefixes[0], prefixes[1], v85, &count_0);
                }
                else
                {
                  retcount = snprintf(&result[length], maxlen, buf, v85, &count_0);
                }
                break;
              default:
                abort();
                return v20;
            }
            if ( count_0 < 0 )
            {
              if ( fbp[1] )
              {
                fbp[1] = 0;
                continue;
              }
              if ( retcount < 0 )
              {
                if ( (allocated & 0x80000000) != 0 )
                  v56 = -1;
                else
                  v56 = 2 * allocated;
                bigger_need = xsum(v56, 0xCu);
                if ( bigger_need > allocated )
                {
                  if ( allocated )
                  {
                    if ( (allocated & 0x80000000) != 0 )
                      v58 = -1;
                    else
                      v58 = 2 * allocated;
                    v57 = v58;
                  }
                  else
                  {
                    v57 = 12;
                  }
                  allocated = v57;
                  if ( bigger_need > v57 )
                    allocated = bigger_need;
                  memory_size_3 = allocated;
                  if ( allocated == -1 )
                    goto out_of_memory;
                  memory_3 = (char *)(result != resultbufa && result ? realloc(result, memory_size_3) : malloc(memory_size_3));
                  if ( !memory_3 )
                    goto out_of_memory;
                  if ( result == resultbufa && length )
                    memcpy(memory_3, result, length);
                  result = memory_3;
                }
                continue;
              }
              count_0 = retcount;
            }
            else
            {
              if ( count_0 < maxlen && result[length + count_0] )
                abort();
              if ( retcount > count_0 )
                count_0 = retcount;
            }
            if ( count_0 < 0 )
            {
              if ( result != resultbufa && result )
                free(result);
              if ( buf_malloced )
                free(buf_malloced);
              free(d.dir);
              if ( a.arg )
                free(a.arg);
              *__errno_location() = 22;
              return 0;
            }
            if ( count_0 + 1 < maxlen )
            {
              length += count_0;
              goto LABEL_426;
            }
            if ( maxlen == 0x7FFFFFFF )
            {
              if ( result != resultbufa && result )
                free(result);
              if ( buf_malloced )
                free(buf_malloced);
              free(d.dir);
              if ( a.arg )
                free(a.arg);
              *__errno_location() = 75;
              return 0;
            }
            if ( (allocated & 0x80000000) != 0 )
              v59 = -1;
            else
              v59 = 2 * allocated;
            v17 = xsum(length, count_0 + 2);
            n_3 = xmax(v17, v59);
            if ( n_3 > allocated )
            {
              if ( allocated )
              {
                if ( (allocated & 0x80000000) != 0 )
                  v61 = -1;
                else
                  v61 = 2 * allocated;
                v60 = v61;
              }
              else
              {
                v60 = 12;
              }
              allocated = v60;
              if ( n_3 > v60 )
                allocated = n_3;
              memory_size_4 = allocated;
              if ( allocated == -1 )
                goto out_of_memory;
              memory_4 = (char *)(result != resultbufa && result ? realloc(result, memory_size_4) : malloc(memory_size_4));
              if ( !memory_4 )
                goto out_of_memory;
              if ( result == resultbufa && length )
                memcpy(memory_4, result, length);
              result = memory_4;
            }
          }
        }
        flags = dp->flags;
        has_width = 0;
        width = 0;
        if ( dp->width_start != dp->width_end )
        {
          if ( dp->width_arg_index == -1 )
          {
            digitp = dp->width_start;
            do
            {
              size2 = *digitp++ - 48;
              if ( width > 0x19999999 )
                size1 = -1;
              else
                size1 = 10 * width;
              width = xsum(size1, size2);
            }
            while ( dp->width_end != digitp );
          }
          else
          {
            if ( a.arg[dp->width_arg_index].type != TYPE_INT )
              abort();
            arg = a.arg[dp->width_arg_index].a.a_int;
            if ( arg >= 0 )
            {
              width = arg;
            }
            else
            {
              flags |= 2u;
              width = -arg;
            }
          }
          has_width = 1;
        }
        has_precision = 0;
        precision = 0;
        if ( dp->precision_start != dp->precision_end )
        {
          if ( dp->precision_arg_index == -1 )
          {
            digitp_0 = dp->precision_start + 1;
            precision = 0;
            while ( dp->precision_end != digitp_0 )
            {
              v50 = *digitp_0++ - 48;
              if ( precision > 0x19999999 )
                v51 = -1;
              else
                v51 = 10 * precision;
              precision = xsum(v51, v50);
            }
            has_precision = 1;
          }
          else
          {
            if ( a.arg[dp->precision_arg_index].type != TYPE_INT )
              abort();
            v120 = a.arg[dp->precision_arg_index].a.a_int;
            if ( v120 >= 0 )
            {
              precision = v120;
              has_precision = 1;
            }
          }
        }
        if ( !has_precision )
          precision = 6;
        tmp_length = 0;
        if ( precision )
          tmp_length = precision;
        tmp_length = xsum(tmp_length, 0xCu);
        if ( tmp_length < width )
          tmp_length = width;
        tmp_length = xsum(tmp_length, 1u);
        if ( tmp_length > 0x2BC )
        {
          tmp_memsize = tmp_length;
          if ( tmp_length == -1 )
            goto out_of_memory;
          tmp = (char *)malloc(tmp_memsize);
          if ( !tmp )
            goto out_of_memory;
        }
        else
        {
          tmp = tmpbuf;
        }
        pad_ptr = 0;
        p = tmp;
        v6 = &a.arg[dp->arg_index];
        v7 = *(&v6->a.a_ulongint + 2);
        v8 = *((_DWORD *)&v6->a.a_ushort + 1);
        LODWORD(x) = v6->a.a_int;
        *(_QWORD *)((char *)&x + 4) = __PAIR64__(v7, v8);
        LODWORD(v21) = LODWORD(x);
        *(_QWORD *)((char *)&v21 + 4) = __PAIR64__(v7, v8);
        if ( rpl_isnanl(v21) )
        {
          if ( dp->conversion <= 64 || dp->conversion > 90 )
          {
            *p++ = 110;
            *p++ = 97;
            *p++ = 110;
          }
          else
          {
            *p++ = 78;
            *p++ = 65;
            *p++ = 78;
          }
        }
        else
        {
          sign = 0;
          oldcw = count_0;
          LOBYTE(v9) = count_0;
          HIBYTE(v9) = BYTE1(count_0) | 3;
          LOWORD(count_0) = v9;
          if ( __signbitl(LODWORD(x), DWORD1(x), HIDWORD(x)) )
          {
            sign = -1;
            x = -x;
          }
          if ( sign >= 0 )
          {
            if ( (flags & 4) != 0 )
            {
              *p++ = 43;
            }
            else if ( (flags & 8) != 0 )
            {
              *p++ = 32;
            }
          }
          else
          {
            *p++ = 45;
          }
          if ( x <= 0.0 || x != x + x )
            abort();
          if ( dp->conversion <= 64 || dp->conversion > 90 )
          {
            *p++ = 105;
            *p++ = 110;
            *p++ = 102;
          }
          else
          {
            *p++ = 73;
            *p++ = 78;
            *p++ = 70;
          }
          LOWORD(count_0) = oldcw;
        }
        if ( has_width && p - tmp < width )
        {
          pad = width + tmp - p;
          end = &tmp[width];
          if ( (flags & 2) != 0 )
          {
            while ( pad )
            {
              *p++ = 32;
              --pad;
            }
          }
          else if ( (flags & 0x20) != 0 && pad_ptr )
          {
            q = end;
            while ( p > pad_ptr )
              *--q = *--p;
            while ( pad )
            {
              *p++ = 48;
              --pad;
            }
          }
          else
          {
            q_0 = end;
            while ( p > tmp )
              *--q_0 = *--p;
            while ( pad )
            {
              *p++ = 32;
              --pad;
            }
          }
          p = end;
        }
        count = p - tmp;
        if ( p - tmp >= tmp_length )
          abort();
        if ( allocated - length <= count )
        {
          n_0 = xsum(length, count);
          if ( n_0 > allocated )
          {
            if ( allocated )
            {
              if ( (allocated & 0x80000000) != 0 )
                v53 = -1;
              else
                v53 = 2 * allocated;
              v52 = v53;
            }
            else
            {
              v52 = 12;
            }
            allocated = v52;
            if ( n_0 > v52 )
              allocated = n_0;
            memory_size_1 = allocated;
            if ( allocated == -1 )
              goto out_of_memory;
            memory_1 = (char *)(result != resultbufa && result ? realloc(result, memory_size_1) : malloc(memory_size_1));
            if ( !memory_1 )
              goto out_of_memory;
            if ( result == resultbufa && length )
              memcpy(memory_1, result, length);
            result = memory_1;
          }
        }
        memcpy(&result[length], tmp, count);
        if ( tmp != tmpbuf )
          free(tmp);
        length += count;
      }
    }
LABEL_426:
    cp = dp->dir_end;
    ++i;
  }
  v18 = xsum(length, 1u);
  if ( v18 > allocated )
  {
    if ( allocated )
    {
      if ( (allocated & 0x80000000) != 0 )
        v63 = -1;
      else
        v63 = 2 * allocated;
      v62 = v63;
    }
    else
    {
      v62 = 12;
    }
    allocated = v62;
    v19 = xsum(length, 1u);
    if ( v19 > allocated )
      allocated = xsum(length, 1u);
    memory_size_5 = allocated;
    if ( allocated == -1 )
      goto out_of_memory;
    memory_5 = (char *)(result != resultbufa && result ? realloc(result, memory_size_5) : malloc(memory_size_5));
    if ( !memory_5 )
      goto out_of_memory;
    if ( result == resultbufa && length )
      memcpy(memory_5, result, length);
    result = memory_5;
  }
  result[length] = 0;
  if ( result != resultbufa && length + 1 < allocated )
  {
    memory_6 = (char *)realloc(result, length + 1);
    if ( memory_6 )
      result = memory_6;
  }
  if ( buf_malloced )
    free(buf_malloced);
  free(d.dir);
  if ( a.arg )
    free(a.arg);
  *lengthpa = length;
  return result;
}
// 80498EC: using guessed type int __cdecl __signbitl(_DWORD, _DWORD, _DWORD);

//----- (0805CAD5) --------------------------------------------------------
size_t __cdecl xsum4(size_t size1, size_t size2, size_t size3, size_t size4)
{
  size_t v4; // edx
  size_t v5; // edx

  v4 = xsum(size1, size2);
  v5 = xsum(v4, size3);
  return xsum(v5, size4);
}

//----- (0805CB11) --------------------------------------------------------
size_t __cdecl xmax(size_t size1, size_t size2)
{
  size_t v3; // [esp+4h] [ebp-4h]

  v3 = size1;
  if ( size1 < size2 )
    v3 = size2;
  return v3;
}

//----- (0805CB36) --------------------------------------------------------
size_t __cdecl xsum(size_t size1, size_t size2)
{
  size_t v3; // [esp+0h] [ebp-14h]

  if ( size2 + size1 < size1 )
    v3 = -1;
  else
    v3 = size2 + size1;
  return v3;
}

//----- (0805CB64) --------------------------------------------------------
int __cdecl rpl_isnanl(long double x)
{
  if ( (WORD4(x) & 0x7FFF) == 0 )
    return DWORD1(x) >> 31;
  if ( (WORD4(x) & 0x7FFF) == 0x7FFF )
    return (DWORD1(x) ^ 0x80000000 | LODWORD(x)) != 0;
  return (DWORD1(x) & 0x80000000) == 0;
}

//----- (0805CBD0) --------------------------------------------------------
int __cdecl printf_fetchargs(va_list args, arguments *a)
{
  va_list v2; // edx
  va_list v3; // edx
  va_list v4; // edx
  va_list v5; // edx
  va_list v6; // edx
  va_list v7; // edx
  va_list v8; // edx
  va_list v9; // edx
  va_list v10; // edx
  int *v11; // eax
  int v12; // edx
  va_list v13; // edx
  va_list v14; // edx
  int *v15; // eax
  unsigned int v16; // ecx
  int v17; // edx
  va_list v18; // edx
  va_list v19; // edx
  va_list v20; // edx
  va_list v21; // edx
  va_list v22; // edx
  va_list v23; // edx
  va_list v24; // edx
  va_list v25; // edx
  va_list v26; // edx
  va_list v27; // edx
  argument *ap; // [esp+10h] [ebp-Ch]
  size_t i; // [esp+14h] [ebp-8h]

  i = 0;
  ap = a->arg;
  while ( 2 )
  {
    if ( a->count > i )
    {
      switch ( ap->type )
      {
        case TYPE_SCHAR:
          v2 = args;
          args += 4;
          ap->a.a_schar = *(_DWORD *)v2;
          goto LABEL_27;
        case TYPE_UCHAR:
          v3 = args;
          args += 4;
          ap->a.a_schar = *(_DWORD *)v3;
          goto LABEL_27;
        case TYPE_SHORT:
          v4 = args;
          args += 4;
          ap->a.a_short = *(_DWORD *)v4;
          goto LABEL_27;
        case TYPE_USHORT:
          v5 = args;
          args += 4;
          ap->a.a_short = *(_DWORD *)v5;
          goto LABEL_27;
        case TYPE_INT:
          v6 = args;
          args += 4;
          ap->a.a_int = *(_DWORD *)v6;
          goto LABEL_27;
        case TYPE_UINT:
          v7 = args;
          args += 4;
          ap->a.a_int = *(_DWORD *)v7;
          goto LABEL_27;
        case TYPE_LONGINT:
          v8 = args;
          args += 4;
          ap->a.a_int = *(_DWORD *)v8;
          goto LABEL_27;
        case TYPE_ULONGINT:
          v9 = args;
          args += 4;
          ap->a.a_int = *(_DWORD *)v9;
          goto LABEL_27;
        case TYPE_LONGLONGINT:
        case TYPE_ULONGLONGINT:
          v10 = args;
          args += 8;
          v11 = (int *)v10;
          v12 = *((_DWORD *)v10 + 1);
          ap->a.a_int = *v11;
          *((_DWORD *)&ap->a.a_ushort + 1) = v12;
          goto LABEL_27;
        case TYPE_DOUBLE:
          v13 = args;
          args += 8;
          ap->a.a_double = *(double *)v13;
          goto LABEL_27;
        case TYPE_LONGDOUBLE:
          v14 = args;
          args += 12;
          v15 = (int *)v14;
          v16 = *((_DWORD *)v14 + 2);
          v17 = *((_DWORD *)v14 + 1);
          ap->a.a_int = *v15;
          *((_DWORD *)&ap->a.a_ushort + 1) = v17;
          *(&ap->a.a_ulongint + 2) = v16;
          goto LABEL_27;
        case TYPE_CHAR:
          v18 = args;
          args += 4;
          ap->a.a_int = *(_DWORD *)v18;
          goto LABEL_27;
        case TYPE_WIDE_CHAR:
          v19 = args;
          args += 4;
          ap->a.a_int = *(_DWORD *)v19;
          goto LABEL_27;
        case TYPE_STRING:
          v20 = args;
          args += 4;
          ap->a.a_int = *(_DWORD *)v20;
          if ( !ap->a.a_int )
            ap->a.a_int = (int)"(NULL)";
          goto LABEL_27;
        case TYPE_WIDE_STRING:
          v21 = args;
          args += 4;
          ap->a.a_int = *(_DWORD *)v21;
          if ( !ap->a.a_int )
            ap->a.a_int = (int)wide_null_string_1636;
          goto LABEL_27;
        case TYPE_POINTER:
          v22 = args;
          args += 4;
          ap->a.a_int = *(_DWORD *)v22;
          goto LABEL_27;
        case TYPE_COUNT_SCHAR_POINTER:
          v23 = args;
          args += 4;
          ap->a.a_int = *(_DWORD *)v23;
          goto LABEL_27;
        case TYPE_COUNT_SHORT_POINTER:
          v24 = args;
          args += 4;
          ap->a.a_int = *(_DWORD *)v24;
          goto LABEL_27;
        case TYPE_COUNT_INT_POINTER:
          v25 = args;
          args += 4;
          ap->a.a_int = *(_DWORD *)v25;
          goto LABEL_27;
        case TYPE_COUNT_LONGINT_POINTER:
          v26 = args;
          args += 4;
          ap->a.a_int = *(_DWORD *)v26;
          goto LABEL_27;
        case TYPE_COUNT_LONGLONGINT_POINTER:
          v27 = args;
          args += 4;
          ap->a.a_int = *(_DWORD *)v27;
LABEL_27:
          ++i;
          ++ap;
          continue;
        default:
          return -1;
      }
    }
    return 0;
  }
}

//----- (0805CE8C) --------------------------------------------------------
int __cdecl printf_parse(const char *format, char_directives *d, arguments *a)
{
  size_t v3; // edx
  size_t v4; // edx
  size_t v5; // edx
  int size1; // [esp+14h] [ebp-C4h]
  int v8; // [esp+1Ch] [ebp-BCh]
  unsigned int v9; // [esp+20h] [ebp-B8h]
  size_t v10; // [esp+24h] [ebp-B4h]
  argument *v11; // [esp+28h] [ebp-B0h]
  int v12; // [esp+30h] [ebp-A8h]
  unsigned int v13; // [esp+34h] [ebp-A4h]
  size_t v14; // [esp+38h] [ebp-A0h]
  argument *v15; // [esp+3Ch] [ebp-9Ch]
  unsigned int v16; // [esp+40h] [ebp-98h]
  size_t v17; // [esp+44h] [ebp-94h]
  argument *v18; // [esp+48h] [ebp-90h]
  unsigned int v19; // [esp+4Ch] [ebp-8Ch]
  size_t v20; // [esp+50h] [ebp-88h]
  char_directive *memory_2; // [esp+60h] [ebp-78h]
  size_t n_4; // [esp+70h] [ebp-68h]
  int flags; // [esp+74h] [ebp-64h]
  arg_type type; // [esp+78h] [ebp-60h]
  size_t n_3; // [esp+88h] [ebp-50h]
  size_t n_2; // [esp+8Ch] [ebp-4Ch]
  char *np_1; // [esp+90h] [ebp-48h]
  const char *np_1a; // [esp+90h] [ebp-48h]
  size_t n_1; // [esp+A0h] [ebp-38h]
  size_t n_0; // [esp+A4h] [ebp-34h]
  char *np_0; // [esp+A8h] [ebp-30h]
  const char *np_0a; // [esp+A8h] [ebp-30h]
  size_t n; // [esp+ACh] [ebp-2Ch]
  char *np; // [esp+B0h] [ebp-28h]
  const char *npa; // [esp+B0h] [ebp-28h]
  char_directive *dp; // [esp+B4h] [ebp-24h]
  size_t v38; // [esp+B8h] [ebp-20h]
  unsigned int max_precision_length; // [esp+BCh] [ebp-1Ch]
  unsigned int max_width_length; // [esp+C0h] [ebp-18h]
  int a_allocated; // [esp+C4h] [ebp-14h]
  signed int d_allocated; // [esp+C8h] [ebp-10h]
  size_t v43; // [esp+CCh] [ebp-Ch]
  char ca; // [esp+D7h] [ebp-1h]
  char c; // [esp+D7h] [ebp-1h]

  v43 = 0;
  max_width_length = 0;
  max_precision_length = 0;
  d->count = 0;
  d_allocated = 1;
  d->dir = (char_directive *)malloc(0x2Cu);
  if ( !d->dir )
  {
out_of_memory_1:
    *__errno_location() = 12;
    return -1;
  }
  a->count = 0;
  a_allocated = 0;
  a->arg = 0;
  while ( 1 )
  {
    do
    {
      if ( !*format )
      {
        d->dir[d->count].dir_start = format;
        d->max_width_length = max_width_length;
        d->max_precision_length = max_precision_length;
        return 0;
      }
      ca = *format++;
    }
    while ( ca != 37 );
    v38 = -1;
    dp = &d->dir[d->count];
    dp->dir_start = format - 1;
    dp->flags = 0;
    dp->width_start = 0;
    dp->width_end = 0;
    dp->width_arg_index = -1;
    dp->precision_start = 0;
    dp->precision_end = 0;
    dp->precision_arg_index = -1;
    dp->arg_index = -1;
    if ( *format > 47 && *format <= 57 )
    {
      for ( np = (char *)format; *np > 47 && *np <= 57; ++np )
        ;
      if ( *np == 36 )
        break;
    }
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            while ( 1 )
            {
LABEL_21:
              while ( *format == 39 )
              {
                dp->flags |= 1u;
                ++format;
              }
              if ( *format != 45 )
                break;
              dp->flags |= 2u;
              ++format;
            }
            if ( *format != 43 )
              break;
            dp->flags |= 4u;
            ++format;
          }
          if ( *format != 32 )
            break;
          dp->flags |= 8u;
          ++format;
        }
        if ( *format != 35 )
          break;
        dp->flags |= 0x10u;
        ++format;
      }
      if ( *format != 48 )
        break;
      dp->flags |= 0x20u;
      ++format;
    }
    if ( *format == 42 )
    {
      dp->width_start = format++;
      dp->width_end = format;
      if ( !max_width_length )
        max_width_length = 1;
      if ( *format > 47 && *format <= 57 )
      {
        for ( np_0 = (char *)format; *np_0 > 47 && *np_0 <= 57; ++np_0 )
          ;
        if ( *np_0 == 36 )
        {
          n_0 = 0;
          for ( np_0a = format; *np_0a > 47 && *np_0a <= 57; ++np_0a )
          {
            if ( n_0 > 0x19999999 )
              v8 = -1;
            else
              v8 = 10 * n_0;
            n_0 = xsum_0(v8, *np_0a - 48);
          }
          if ( !n_0 || n_0 == -1 )
            goto error;
          dp->width_arg_index = n_0 - 1;
          format = np_0a + 1;
        }
      }
      if ( dp->width_arg_index == -1 )
      {
        dp->width_arg_index = v43++;
        if ( dp->width_arg_index == -1 )
          goto error;
      }
      n_1 = dp->width_arg_index;
      if ( n_1 >= a_allocated )
      {
        if ( a_allocated < 0 )
          v9 = -1;
        else
          v9 = 2 * a_allocated;
        a_allocated = v9;
        if ( v9 <= n_1 )
          a_allocated = xsum_0(n_1, 1u);
        if ( (unsigned int)a_allocated > 0xFFFFFFF )
          v10 = -1;
        else
          v10 = 16 * a_allocated;
        if ( v10 == -1 || (!a->arg ? (v11 = (argument *)malloc(v10)) : (v11 = (argument *)realloc(a->arg, v10)), !v11) )
        {
out_of_memory:
          if ( a->arg )
            free(a->arg);
          if ( d->dir )
            free(d->dir);
          goto out_of_memory_1;
        }
        a->arg = v11;
      }
      while ( a->count <= n_1 )
      {
        v3 = a->count;
        a->arg[a->count].type = TYPE_NONE;
        a->count = v3 + 1;
      }
      if ( a->arg[n_1].type )
      {
        if ( a->arg[n_1].type != TYPE_INT )
          goto error;
      }
      else
      {
        a->arg[n_1].type = TYPE_INT;
      }
    }
    else if ( *format > 47 && *format <= 57 )
    {
      dp->width_start = format;
      while ( *format > 47 && *format <= 57 )
        ++format;
      dp->width_end = format;
      if ( max_width_length < dp->width_end - dp->width_start )
        max_width_length = dp->width_end - dp->width_start;
    }
    if ( *format == 46 )
    {
      if ( *++format == 42 )
      {
        dp->precision_start = format++ - 1;
        dp->precision_end = format;
        if ( max_precision_length <= 1 )
          max_precision_length = 2;
        if ( *format > 47 && *format <= 57 )
        {
          for ( np_1 = (char *)format; *np_1 > 47 && *np_1 <= 57; ++np_1 )
            ;
          if ( *np_1 == 36 )
          {
            n_2 = 0;
            for ( np_1a = format; *np_1a > 47 && *np_1a <= 57; ++np_1a )
            {
              if ( n_2 > 0x19999999 )
                v12 = -1;
              else
                v12 = 10 * n_2;
              n_2 = xsum_0(v12, *np_1a - 48);
            }
            if ( !n_2 || n_2 == -1 )
              goto error;
            dp->precision_arg_index = n_2 - 1;
            format = np_1a + 1;
          }
        }
        if ( dp->precision_arg_index == -1 )
        {
          dp->precision_arg_index = v43++;
          if ( dp->precision_arg_index == -1 )
            goto error;
        }
        n_3 = dp->precision_arg_index;
        if ( n_3 >= a_allocated )
        {
          if ( a_allocated < 0 )
            v13 = -1;
          else
            v13 = 2 * a_allocated;
          a_allocated = v13;
          if ( v13 <= n_3 )
            a_allocated = xsum_0(n_3, 1u);
          if ( (unsigned int)a_allocated > 0xFFFFFFF )
            v14 = -1;
          else
            v14 = 16 * a_allocated;
          if ( v14 == -1 )
            goto out_of_memory;
          v15 = (argument *)(a->arg ? realloc(a->arg, v14) : malloc(v14));
          if ( !v15 )
            goto out_of_memory;
          a->arg = v15;
        }
        while ( a->count <= n_3 )
        {
          v4 = a->count;
          a->arg[a->count].type = TYPE_NONE;
          a->count = v4 + 1;
        }
        if ( a->arg[n_3].type )
        {
          if ( a->arg[n_3].type != TYPE_INT )
            goto error;
        }
        else
        {
          a->arg[n_3].type = TYPE_INT;
        }
      }
      else
      {
        dp->precision_start = format - 1;
        while ( *format > 47 && *format <= 57 )
          ++format;
        dp->precision_end = format;
        if ( max_precision_length < dp->precision_end - dp->precision_start )
          max_precision_length = dp->precision_end - dp->precision_start;
      }
    }
    flags = 0;
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            while ( 1 )
            {
              while ( *format == 104 )
              {
                flags |= 1 << (flags & 1);
                ++format;
              }
              if ( *format != 76 )
                break;
              flags |= 4u;
              ++format;
            }
            if ( *format != 108 )
              break;
            flags += 8;
            ++format;
          }
          if ( *format != 106 )
            break;
          flags += 16;
          ++format;
        }
        if ( *format != 122 && *format != 90 )
          break;
        ++format;
      }
      if ( *format != 116 )
        break;
      ++format;
    }
    c = *format++;
    switch ( c )
    {
      case '%':
        type = TYPE_NONE;
        break;
      case 'A':
      case 'E':
      case 'F':
      case 'G':
      case 'a':
      case 'e':
      case 'f':
      case 'g':
        if ( flags > 15 || (flags & 4) != 0 )
          type = TYPE_LONGDOUBLE;
        else
          type = TYPE_DOUBLE;
        break;
      case 'C':
        type = TYPE_WIDE_CHAR;
        c = 99;
        break;
      case 'S':
        type = TYPE_WIDE_STRING;
        c = 115;
        break;
      case 'X':
      case 'o':
      case 'u':
      case 'x':
        if ( flags > 15 || (flags & 4) != 0 )
        {
          type = TYPE_ULONGLONGINT;
        }
        else if ( flags <= 7 )
        {
          if ( (flags & 2) != 0 )
          {
            type = TYPE_UCHAR;
          }
          else if ( (flags & 1) != 0 )
          {
            type = TYPE_USHORT;
          }
          else
          {
            type = TYPE_UINT;
          }
        }
        else
        {
          type = TYPE_ULONGINT;
        }
        break;
      case 'c':
        if ( flags <= 7 )
          type = TYPE_CHAR;
        else
          type = TYPE_WIDE_CHAR;
        break;
      case 'd':
      case 'i':
        if ( flags > 15 || (flags & 4) != 0 )
        {
          type = TYPE_LONGLONGINT;
        }
        else if ( flags <= 7 )
        {
          if ( (flags & 2) != 0 )
          {
            type = TYPE_SCHAR;
          }
          else if ( (flags & 1) != 0 )
          {
            type = TYPE_SHORT;
          }
          else
          {
            type = TYPE_INT;
          }
        }
        else
        {
          type = TYPE_LONGINT;
        }
        break;
      case 'n':
        if ( flags > 15 || (flags & 4) != 0 )
        {
          type = TYPE_COUNT_LONGLONGINT_POINTER;
        }
        else if ( flags <= 7 )
        {
          if ( (flags & 2) != 0 )
          {
            type = TYPE_COUNT_SCHAR_POINTER;
          }
          else if ( (flags & 1) != 0 )
          {
            type = TYPE_COUNT_SHORT_POINTER;
          }
          else
          {
            type = TYPE_COUNT_INT_POINTER;
          }
        }
        else
        {
          type = TYPE_COUNT_LONGINT_POINTER;
        }
        break;
      case 'p':
        type = TYPE_POINTER;
        break;
      case 's':
        if ( flags <= 7 )
          type = TYPE_STRING;
        else
          type = TYPE_WIDE_STRING;
        break;
      default:
        goto error;
    }
    if ( type )
    {
      dp->arg_index = v38;
      if ( dp->arg_index == -1 )
      {
        dp->arg_index = v43++;
        if ( dp->arg_index == -1 )
          goto error;
      }
      n_4 = dp->arg_index;
      if ( n_4 >= a_allocated )
      {
        if ( a_allocated < 0 )
          v16 = -1;
        else
          v16 = 2 * a_allocated;
        a_allocated = v16;
        if ( v16 <= n_4 )
          a_allocated = xsum_0(n_4, 1u);
        if ( (unsigned int)a_allocated > 0xFFFFFFF )
          v17 = -1;
        else
          v17 = 16 * a_allocated;
        if ( v17 == -1 )
          goto out_of_memory;
        v18 = (argument *)(a->arg ? realloc(a->arg, v17) : malloc(v17));
        if ( !v18 )
          goto out_of_memory;
        a->arg = v18;
      }
      while ( a->count <= n_4 )
      {
        v5 = a->count;
        a->arg[a->count].type = TYPE_NONE;
        a->count = v5 + 1;
      }
      if ( a->arg[n_4].type )
      {
        if ( a->arg[n_4].type != type )
          goto error;
      }
      else
      {
        a->arg[n_4].type = type;
      }
    }
    dp->conversion = c;
    dp->dir_end = format;
    if ( ++d->count >= d_allocated )
    {
      if ( d_allocated < 0 )
        v19 = -1;
      else
        v19 = 2 * d_allocated;
      d_allocated = v19;
      if ( v19 > 0x5D1745D )
        v20 = -1;
      else
        v20 = 44 * v19;
      if ( v20 == -1 )
        goto out_of_memory;
      memory_2 = (char_directive *)realloc(d->dir, v20);
      if ( !memory_2 )
        goto out_of_memory;
      d->dir = memory_2;
    }
  }
  n = 0;
  for ( npa = format; *npa > 47 && *npa <= 57; ++npa )
  {
    if ( n > 0x19999999 )
      size1 = -1;
    else
      size1 = 10 * n;
    n = xsum_0(size1, *npa - 48);
  }
  if ( n && n != -1 )
  {
    v38 = n - 1;
    format = npa + 1;
    goto LABEL_21;
  }
error:
  if ( a->arg )
    free(a->arg);
  if ( d->dir )
    free(d->dir);
  *__errno_location() = 22;
  return -1;
}

//----- (0805DCED) --------------------------------------------------------
size_t __cdecl xsum_0(size_t size1, size_t size2)
{
  size_t v3; // [esp+0h] [ebp-14h]

  if ( size2 + size1 < size1 )
    v3 = -1;
  else
    v3 = size2 + size1;
  return v3;
}

//----- (0805E310) --------------------------------------------------------
void _libc_csu_fini(void)
{
  ;
}

//----- (0805E320) --------------------------------------------------------
void _libc_csu_init(void)
{
  init_proc();
}

//----- (0805E380) --------------------------------------------------------
int __cdecl atexit(void (__cdecl *lpfunc)(void *))
{
  void *v1; // eax

  v1 = 0;
  if ( _dso_handle )
    v1 = (void *)_dso_handle[0];
  return __cxa_atexit(lpfunc, 0, v1);
}

//----- (0805E3C0) --------------------------------------------------------
int __cdecl stat64(int a1, int a2)
{
  return __xstat64(3, a1, a2);
}
// 80495BC: using guessed type int __cdecl __xstat64(_DWORD, _DWORD, _DWORD);

//----- (0805E400) --------------------------------------------------------
int __cdecl fstat64(int a1, int a2)
{
  return __fxstat64(3, a1, a2);
}
// 80499EC: using guessed type int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD);

//----- (0805E440) --------------------------------------------------------
int __cdecl lstat64(int a1, int a2)
{
  return __lxstat64(3, a1, a2);
}
// 804971C: using guessed type int __cdecl __lxstat64(_DWORD, _DWORD, _DWORD);

//----- (0805E480) --------------------------------------------------------
void (*_do_global_ctors_aux())(void)
{
  void (*result)(void); // eax
  void (**v1)(void); // ebx

  result = (void (*)(void))_CTOR_LIST__;
  if ( _CTOR_LIST__ != -1 )
  {
    v1 = (void (**)(void))&_CTOR_LIST__;
    do
    {
      --v1;
      result();
      result = *v1;
    }
    while ( *v1 != (void (*)(void))-1 );
  }
  return result;
}
// 8063F00: using guessed type int _CTOR_LIST__;

//----- (0805E4AC) --------------------------------------------------------
void term_proc()
{
  _do_global_dtors_aux();
}

// nfuncs=465 queued=266 decompiled=266 lumina nreq=0 worse=0 better=0
// ALL OK, 266 function(s) have been successfully decompiled
