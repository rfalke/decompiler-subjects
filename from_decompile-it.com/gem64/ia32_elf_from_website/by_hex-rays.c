/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

int init_proc();
int sub_8048A74();
// int fputs(const char *s, FILE *stream);
// int *__errno_location(void);
// int sprintf(char *s, const char *format, ...);
// void srand(unsigned int seed);
// int open(const char *file, int oflag, ...);
// char *strerror(int errnum);
// int __cdecl __cxa_atexit(void (__cdecl *lpfunc)(void *), void *obj, void *lpdso_handle);
// int __isoc99_fscanf(_DWORD, const char *, ...); weak
// int __xstat(int ver, const char *filename, struct stat *stat_buf);
// int __gmon_start__(void); weak
// void rewind(FILE *stream);
// int __isoc99_sscanf(_DWORD, const char *, ...); weak
// int vsprintf(char *s, const char *format, __gnuc_va_list arg);
// char *strchr(const char *s, int c);
// char *getenv(const char *name);
// void *calloc(size_t nmemb, size_t size);
// int system(const char *command);
// char *strncpy(char *dest, const char *src, size_t n);
// char *fgets(char *s, int n, FILE *stream);
// int __cdecl __libc_start_main(int (__cdecl *main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end);
// char *strrchr(const char *s, int c);
// struct dirent *readdir(DIR *dirp);
// int strtol(const char *nptr, char **endptr, int base);
// void free(void *ptr);
// int fflush(FILE *stream);
// int mkstemp(char *template);
// DIR *opendir(const char *name);
// int getopt_long(int argc, char *const *argv, const char *shortopts, const struct option *longopts, int *longind);
// int fclose(FILE *stream);
// void *memcpy(void *dest, const void *src, size_t n);
// size_t strlen(const char *s);
// FILE *fopen(const char *filename, const char *modes);
// char *strcpy(char *dest, const char *src);
// int chdir(const char *path);
// int putenv(char *string);
// int closedir(DIR *dirp);
// int close(int fd);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// int fprintf(FILE *stream, const char *format, ...);
// char *strstr(const char *haystack, const char *needle);
// int setvbuf(FILE *stream, char *buf, int modes, size_t n);
// int remove(const char *filename);
// void *malloc(size_t size);
// int fputc(int c, FILE *stream);
// char *strtok(char *s, const char *delim);
// char *strcat(char *dest, const char *src);
// char *getcwd(char *buf, size_t size);
// int rand(void);
// char *strdup(const char *s);
// int strcmp(const char *s1, const char *s2);
// void exit(int status);
// void __usercall __noreturn start(int a1@<eax>, void (*a2)(void)@<edx>);
void _do_global_dtors_aux();
int frame_dummy();
void exit_env(); // idb
void exit_tmp(); // idb
void exit_db(); // idb
void exit_msg(); // idb
void print_error(int err_code, char *msg, ...);
void print_warning(char *msg, ...);
void print_done(); // idb
char *__cdecl basename(char *path);
void __cdecl mkdir_s(char *pathname, char *mode);
int __cdecl chop(char *string);
int __cdecl insert_str(char *str, int pos, char **strarr);
int __cdecl delete_str(int pos, char **strarr);
int __cdecl find_pos(char *str, char **strarr, int start);
void __cdecl dump_str(FILE *f, char **strarr);
void __cdecl get_package_name(char *path, char *name);
char *__cdecl nc_fgets(char *s, int size, FILE *stream);
char *__cdecl nc_fgets_html(char *s, int size, FILE *stream);
int __cdecl is_text(char *s);
char *__cdecl nc_fgets_nb(char *s, int size, FILE *stream);
void __cdecl dump_ascii(char *file, char *heading);
void __cdecl dump_plain(char *file, char *tmpfile);
void __cdecl dump_html(char *file, char *tmpfile);
void __cdecl list_binaries(char *package);
int __cdecl binaries_exist(char *package, char *binaries);
int __cdecl check_filetype(char *myfile);
void __cdecl wget_extension(char *url);
void __cdecl su(char *gisbase, char *cmd);
int __cdecl vercmp(int major, int minor, int revision, int major2, int minor2, int revision2);
char *__cdecl depstr(char *package, char *gisbase);
void __cdecl register_extension(char *gisbase, char *bins, char *pkg_short_name, int pkg_major, int pkg_minor, int pkg_revision);
void __cdecl deregister_extension(char *package, char *pkg_short_name, char *gisbase);
void __cdecl check_dependencies(char *package, char *gisbase, char *grass_version);
int __cdecl is_submenu(char *item);
int __cdecl check_ext_menu(char **tcl_lines);
int __cdecl new_submenu(char *pkg_short_name, char *menu, char **tcl_lines);
int __cdecl new_item(char *item, char *menu, char **tcl_lines, int line_no);
void __cdecl register_entries_gisman(char *pkg_short_name, char *gisbase);
void __cdecl register_entries_gisman2(char *pkg_short_name, char *gisbase);
int __cdecl deregister_entries_gisman(char *pkg_short_name, char *gisbase);
void __cdecl deregister_entries_gisman2(char *pkg_short_name, char *gisbase);
int __cdecl restore_entries_gisman(char *gisbase);
void __cdecl new_ext_html(char *ext, char *gisbase, char **html, int major, int minor, int revision);
void __cdecl delete_ext_html(char *ext, char *gisbase, char **html);
void __cdecl register_html(char *pkg_short_name, char *gisbase, int major, int minor, int revision);
void __cdecl deregister_html(char *pkg_short_name, char *gisbase);
int __cdecl restore_html(char *gisbase);
void __cdecl check_extension(char *package, char *name, int *major, int *minor, int *revision);
void __cdecl unpack_extension(char *package);
void __cdecl query_extension(char *package, char *name, int major, int minor, int revision, char *short_name, char *invocation, char *org_name);
void print_cfg(); // idb
void __cdecl source_install(char *package, char *gisbase, char *pkg_short_name, int pkg_major, int pkg_minor, int pkg_revision, char *grass_version);
void __cdecl bin_install(char *package, char *gisbase, char *bins, char *pkg_short_name, int pkg_major, int pkg_minor, int pkg_revision, char *grass_version);
void __cdecl test_install(char *package, char *gisbase, char *pkg_short_name, int pkg_major, int pkg_minor, int pkg_revision, char *grass_version);
void __cdecl uninstall(char *package, char *pkg_short_name, char *gisbase, char *grass_version);
int __cdecl source_clean(char *package);
void __cdecl restore(char *gisbase, char *grass_version);
void __cdecl list_extensions(char *gisbase);
void __cdecl run_post(char *package, int action, char *bins, char *gisbase);
void __noreturn show_help();
void __cdecl show_details(char *package);
void __cdecl show_license(char *package);
void __noreturn show_version();
void __cdecl get_configure_options(char *gisbase);
int __cdecl main(int argc, const char **argv, const char **envp);
void _libc_csu_fini(void); // idb
void _libc_csu_init(void); // idb
int __cdecl atexit(void (__cdecl *lpfunc)(void *)); // idb
int __cdecl stat_0(char *filename, int); // idb
void (*_do_global_ctors_aux())(void);
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN unk_8054D15; // weak
_UNKNOWN unk_8055722; // weak
const char byte_805698C[4] = { '\0', '\0', '\0', '\0' }; // idb
_UNKNOWN unk_8057925; // weak
int _CTOR_LIST__ = -1; // weak
int _DTOR_LIST__[] = { -1 }; // weak
int _DTOR_END__ = 0; // weak
int _JCR_LIST__ = 0; // weak
int (*dword_8058FFC)(void) = NULL; // weak
_DWORD _dso_handle[7] = { 0, 0, 0, 0, 0, 0, 0 }; // idb
option long_options_3722[20] =
{
  { "install", 1, NULL, 105 },
  { "uninstall", 1, NULL, 117 },
  { "query", 2, NULL, 113 },
  { "details", 1, NULL, 100 },
  { "clean", 1, NULL, 99 },
  { "test", 1, NULL, 116 },
  { "license", 1, NULL, 108 },
  { "restore", 0, NULL, 114 },
  { "help", 0, NULL, 104 },
  { "version", 0, NULL, 86 },
  { "grass", 1, NULL, 103 },
  { "options", 1, NULL, 111 },
  { "binary", 1, NULL, 98 },
  { "force", 0, NULL, 102 },
  { "verbose", 0, NULL, 118 },
  { "skip-config", 0, NULL, 115 },
  { "config-opts", 1, NULL, 120 },
  { "config-cmd", 1, NULL, 67 },
  { "make-cmd", 1, NULL, 109 },
  { NULL, 0, NULL, 0 }
}; // idb
int optopt; // weak
FILE *stderr; // idb
FILE *stdout; // idb
int opterr; // weak
char *optarg; // idb
char completed_7065; // weak
int dtor_idx_7067; // weak
unsigned int next_4089; // idb
char GINSTALL_DST[2048]; // idb
char GINSTALL_INC[2048]; // idb
char GINSTALL_LIB[2048]; // idb
char UNINSTALL_BASE[2048]; // idb
char GEM_EXT_NAME[2048]; // idb
char GEM_EXT_VERSION[2048]; // idb
char GEM_EXT_DESCR[2048]; // idb
char GEM_EXT_INFO[2048]; // idb
char GEM_EXT_DEPS[2048]; // idb
char GEM_EXT_BUGS[2048]; // idb
char GEM_EXT_AUTHORS[2048]; // idb
char GEM_GRASS_DIR[2048]; // idb
char GEM_ACTION[2048]; // idb
char INSTALL_BASE[2048]; // idb
char INSTALL_TYPE[2048]; // idb
char GEM_FORCE[2048]; // idb
char GEM_VERBOSE[2048]; // idb
char GEM_GUI[2048]; // idb
char GEM_C_OPTS[2048]; // idb
char EXT_BASE[2048]; // idb
int VERBOSE; // idb
char TMPDIR[2048]; // idb
char TMPDB[2048]; // idb
char TMP_GISMAN[2048]; // idb
char TMP_DESCR[2048]; // idb
char TMP_INFO[2048]; // idb
char TMP_DEPS[2048]; // idb
char TMP_BUGS[2048]; // idb
char TMP_AUTHORS[2048]; // idb
char TMP_NULL[2048]; // idb
char TMP_HTML[2048]; // idb
int TMPCLEAN; // idb
int TMPDBCLEAN; // idb
int FORCE; // idb
int UPGRADE; // idb
int SKIP_CFG; // idb
char GISMAN_CMD[2048]; // idb
char GISMAN2_CMD[2048]; // idb
char HTML_CMD[2048]; // idb
char QGIS_CMD[2048]; // idb
char UNINSTALL_CMD[2048]; // idb
char CONFIG_OPTS[2048]; // idb
char CONFIG_CMD[2048]; // idb
char MAKE_CMD[2048]; // idb
char CWD[2048]; // idb
int ERROR; // idb
int WARNINGS; // idb
// extern _UNKNOWN _gmon_start__; weak


//----- (08048A44) --------------------------------------------------------
int init_proc()
{
  int v1; // [esp+0h] [ebp-8h]

  if ( &_gmon_start__ )
    __gmon_start__();
  frame_dummy();
  _do_global_ctors_aux();
  return v1;
}
// 8048A70: variable 'v1' is possibly undefined
// 8048B14: using guessed type int __gmon_start__(void);

//----- (08048A74) --------------------------------------------------------
int sub_8048A74()
{
  return dword_8058FFC();
}
// 8058FFC: using guessed type int (*dword_8058FFC)(void);

//----- (08048DD0) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall __noreturn start(int a1@<eax>, void (*a2)(void)@<edx>)
{
  int v2; // esi
  int v3; // [esp-4h] [ebp-4h] BYREF
  char *retaddr; // [esp+0h] [ebp+0h] BYREF

  v2 = v3;
  v3 = a1;
  __libc_start_main((int (__cdecl *)(int, char **, char **))main, v2, &retaddr, _libc_csu_init, _libc_csu_fini, a2, &v3);
  __halt();
}
// 8048DD3: positive sp value 4 has been found

//----- (08048E00) --------------------------------------------------------
void _do_global_dtors_aux()
{
  int v0; // eax
  unsigned int i; // ebx

  if ( !completed_7065 )
  {
    v0 = dtor_idx_7067;
    for ( i = &_DTOR_END__ - _DTOR_LIST__ - 1; dtor_idx_7067 < i; v0 = dtor_idx_7067 )
    {
      dtor_idx_7067 = v0 + 1;
      ((void (*)(void))_DTOR_LIST__[v0 + 1])();
    }
    completed_7065 = 1;
  }
}
// 8058F18: using guessed type int _DTOR_LIST__[];
// 8058F1C: using guessed type int _DTOR_END__;
// 8059284: using guessed type char completed_7065;
// 8059288: using guessed type int dtor_idx_7067;

//----- (08048E60) --------------------------------------------------------
int frame_dummy()
{
  int result; // eax

  result = _JCR_LIST__;
  if ( _JCR_LIST__ )
    result = 0;
  return result;
}
// 8058F20: using guessed type int _JCR_LIST__;

//----- (08048E84) --------------------------------------------------------
void exit_env()
{
  ;
}

//----- (08048E89) --------------------------------------------------------
void exit_tmp()
{
  char tmp[2048]; // [esp+1Ch] [ebp-80Ch] BYREF
  unsigned int v1; // [esp+81Ch] [ebp-Ch]

  v1 = __readgsdword(0x14u);
  if ( TMPDIR[0] )
  {
    if ( !TMPCLEAN )
    {
      chdir(CWD);
      sprintf(tmp, "rm -rf %s/*", TMPDIR);
      if ( VERBOSE )
        fwrite("Removing temporary extension files...", 1u, 0x25u, stdout);
      system(tmp);
      sprintf(tmp, "rmdir %s", TMPDIR);
      system(tmp);
      if ( opendir(TMPDIR) )
        print_warning("could not remove temporary directory %s.\nPlease remove manually.\n", TMPDIR);
      if ( VERBOSE )
        print_done();
      TMPCLEAN = 1;
    }
  }
  else
  {
    TMPCLEAN = 1;
  }
}

//----- (08048FC2) --------------------------------------------------------
void exit_db()
{
  char tmp[2048]; // [esp+1Ch] [ebp-80Ch] BYREF
  unsigned int v1; // [esp+81Ch] [ebp-Ch]

  v1 = __readgsdword(0x14u);
  if ( !TMPDBCLEAN )
  {
    chdir(CWD);
    if ( VERBOSE )
      fwrite("Removing temporary registration files...", 1u, 0x28u, stdout);
    if ( TMPDB[0] )
    {
      sprintf(tmp, "rm -rf %s", TMPDB);
      if ( system(tmp) )
        print_warning("could not remove temporary file %s.\nPlease remove manually.\n", TMPDB);
    }
    if ( TMP_GISMAN[0] )
    {
      sprintf(tmp, "rm -f %s", TMP_GISMAN);
      if ( system(tmp) )
        print_warning("could not remove temporary file %s.\nPlease remove manually.\n", TMP_GISMAN);
    }
    if ( TMP_DESCR[0] )
    {
      sprintf(tmp, "rm -f %s", TMP_DESCR);
      if ( system(tmp) )
        print_warning("could not remove temporary file %s.\nPlease remove manually.\n", TMP_DESCR);
    }
    if ( TMP_INFO[0] )
    {
      sprintf(tmp, "rm -f %s", TMP_INFO);
      if ( system(tmp) )
        print_warning("could not remove temporary file %s.\nPlease remove manually.\n", TMP_INFO);
    }
    if ( TMP_DEPS[0] )
    {
      sprintf(tmp, "rm -f %s", TMP_DEPS);
      if ( system(tmp) )
        print_warning("could not remove temporary file %s.\nPlease remove manually.\n", TMP_INFO);
    }
    if ( TMP_BUGS[0] )
    {
      sprintf(tmp, "rm -f %s", TMP_BUGS);
      if ( system(tmp) )
        print_warning("could not remove temporary file %s.\nPlease remove manually.\n", TMP_INFO);
    }
    if ( TMP_AUTHORS[0] )
    {
      sprintf(tmp, "rm -f %s", TMP_AUTHORS);
      if ( system(tmp) )
        print_warning("could not remove temporary file %s.\nPlease remove manually.\n", TMP_INFO);
    }
    if ( TMP_HTML[0] )
    {
      sprintf(tmp, "rm -f %s", TMP_HTML);
      if ( system(tmp) )
        print_warning("could not remove temporary file %s.\nPlease remove manually.\n", TMP_HTML);
    }
    if ( !VERBOSE )
    {
      if ( TMP_NULL[0] )
      {
        sprintf(tmp, "rm -f %s", TMP_NULL);
        if ( system(tmp) )
          print_warning("could not remove temporary file %s.\nPlease remove manually.\n", TMP_NULL);
      }
    }
    if ( VERBOSE )
      print_done();
    TMPDBCLEAN = 1;
  }
}

//----- (08049390) --------------------------------------------------------
void exit_msg()
{
  if ( ERROR >= 0 )
  {
    if ( WARNINGS == 1 )
      fwrite("Job done but there was one warning. Please check.\n", 1u, 0x32u, stdout);
    if ( WARNINGS > 1 )
      fprintf(stdout, "Job done but there were %i warnings. Please check.\n", WARNINGS);
  }
  else
  {
    fprintf(stdout, "Program exited with an error (code %i). Operation aborted.\n", ERROR);
  }
}

//----- (08049420) --------------------------------------------------------
void __noreturn print_error(int err_code, char *msg, ...)
{
  char buffer[2048]; // [esp+2Ch] [ebp-80Ch] BYREF
  unsigned int v3; // [esp+82Ch] [ebp-Ch]
  va_list va; // [esp+848h] [ebp+10h] BYREF

  va_start(va, msg);
  v3 = __readgsdword(0x14u);
  vsprintf(buffer, msg, va);
  fprintf(stderr, "\x1B[1;31m\nERROR:\x1B[0m %s", buffer);
  ERROR = err_code;
  exit(err_code);
}

//----- (0804949B) --------------------------------------------------------
void print_warning(char *msg, ...)
{
  char buffer[2048]; // [esp+2Ch] [ebp-80Ch] BYREF
  unsigned int v2; // [esp+82Ch] [ebp-Ch]
  va_list va; // [esp+844h] [ebp+Ch] BYREF

  va_start(va, msg);
  v2 = __readgsdword(0x14u);
  vsprintf(buffer, msg, va);
  fprintf(stderr, "\x1B[0;33m\nWARNING:\x1B[0m %s", buffer);
  ++WARNINGS;
}

//----- (08049523) --------------------------------------------------------
void print_done()
{
  fwrite("\x1B[0;32mDONE.\n\x1B[0m", 1u, 0x11u, stdout);
}

//----- (08049554) --------------------------------------------------------
char *__cdecl basename(char *path)
{
  char *result; // eax
  char *backup; // [esp+14h] [ebp-14h]
  const char *element; // [esp+18h] [ebp-10h]
  char *copy; // [esp+1Ch] [ebp-Ch]

  copy = strdup(path);
  element = strtok(copy, "/");
  if ( element )
  {
LABEL_11:
    backup = strdup(element);
    while ( element )
    {
      element = strtok(0, "/");
      if ( backup && element )
        free(backup);
      if ( element && *element )
        goto LABEL_11;
    }
    if ( copy )
      free(copy);
    result = backup;
  }
  else
  {
    if ( copy )
      free(copy);
    result = 0;
  }
  return result;
}

//----- (0804961D) --------------------------------------------------------
void __cdecl mkdir_s(char *pathname, char *mode)
{
  char tmp[5000]; // [esp+24h] [ebp-1394h] BYREF
  unsigned int v3; // [esp+13ACh] [ebp-Ch]

  v3 = __readgsdword(0x14u);
  sprintf(tmp, "mkdir %s --mode=%s -p", pathname, mode);
  system(tmp);
}

//----- (0804968F) --------------------------------------------------------
int __cdecl chop(char *string)
{
  int stop; // [esp+14h] [ebp-14h]
  int chopped; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]

  chopped = 0;
  for ( i = strlen(string) - 1; i >= 0; --i )
  {
    stop = 1;
    if ( string[i] == 10 || string[i] == 9 || string[i] == 32 || string[i] == 12 || string[i] == 13 )
    {
      ++chopped;
      stop = 0;
    }
    if ( stop == 1 )
      break;
  }
  string[strlen(string) - chopped] = 0;
  return chopped;
}

//----- (08049737) --------------------------------------------------------
int __cdecl insert_str(char *str, int pos, char **strarr)
{
  int result; // eax
  size_t v4; // eax
  size_t v5; // eax
  int len; // [esp+20h] [ebp-1818h]
  int lena; // [esp+20h] [ebp-1818h]
  int j; // [esp+24h] [ebp-1814h]
  int n; // [esp+28h] [ebp-1810h]
  int na; // [esp+28h] [ebp-1810h]
  int nb; // [esp+28h] [ebp-1810h]
  char last[2048]; // [esp+2Ch] [ebp-180Ch] BYREF
  char insert[2048]; // [esp+82Ch] [ebp-100Ch] BYREF
  char save[2048]; // [esp+102Ch] [ebp-80Ch] BYREF
  unsigned int v15; // [esp+182Ch] [ebp-Ch]

  v15 = __readgsdword(0x14u);
  for ( n = 0; strarr[n]; ++n )
    ;
  if ( pos < 0 || pos > n )
    print_error(-21, "insert: invalid line number %i.\n", pos);
  if ( pos == n )
  {
    len = strlen(str) + 1;
    strarr[n] = (char *)malloc(len);
    strcpy(strarr[n], str);
    na = n + 2;
    strarr[na - 1] = 0;
    result = na;
  }
  else
  {
    strcpy(last, strarr[n - 1]);
    strcpy(insert, strarr[pos]);
    free(strarr[pos]);
    v4 = strlen(str);
    strarr[pos] = (char *)malloc(v4 + 1);
    strcpy(strarr[pos], str);
    for ( j = pos; n - 1 > j; ++j )
    {
      strcpy(save, strarr[j + 1]);
      free(strarr[j + 1]);
      lena = strlen(insert) + 1;
      strarr[j + 1] = (char *)malloc(lena);
      strcpy(strarr[j + 1], insert);
      strcpy(insert, save);
    }
    v5 = strlen(last);
    strarr[n] = (char *)malloc(v5 + 1);
    strcpy(strarr[n], last);
    nb = n + 2;
    strarr[nb - 1] = 0;
    result = nb;
  }
  return result;
}

//----- (08049A5E) --------------------------------------------------------
int __cdecl delete_str(int pos, char **strarr)
{
  size_t v2; // eax
  int i; // [esp+1Ch] [ebp-Ch]
  int ia; // [esp+1Ch] [ebp-Ch]
  int ib; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; strarr[i]; ++i )
    ;
  if ( pos < 0 || pos > i )
    print_error(-21, "delete: invalid line number %i.\n", pos);
  for ( ia = pos; strarr[ia]; ++ia )
  {
    free(strarr[ia]);
    if ( strarr[ia + 1] )
    {
      v2 = strlen(strarr[ia + 1]);
      strarr[ia] = (char *)malloc(v2 + 1);
      strcpy(strarr[ia], strarr[ia + 1]);
    }
  }
  ib = ia - 1;
  strarr[ib] = 0;
  return ib;
}

//----- (08049B5F) --------------------------------------------------------
int __cdecl find_pos(char *str, char **strarr, int start)
{
  int j; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; strarr[i]; ++i )
    ;
  if ( start < 0 || start > i )
    exit(-21);
  for ( j = start; j < i; ++j )
  {
    if ( strstr(strarr[j], str) )
      return j;
  }
  return -1;
}

//----- (08049BD9) --------------------------------------------------------
void __cdecl dump_str(FILE *f, char **strarr)
{
  int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; strarr[i]; ++i )
    fprintf(f, "%i: %s", i, strarr[i]);
}

//----- (08049C27) --------------------------------------------------------
void __cdecl get_package_name(char *path, char *name)
{
  FILE *f; // [esp+28h] [ebp-1010h]
  char tmp[2048]; // [esp+2Ch] [ebp-100Ch] BYREF
  char file[2048]; // [esp+82Ch] [ebp-80Ch] BYREF
  unsigned int v5; // [esp+102Ch] [ebp-Ch]

  v5 = __readgsdword(0x14u);
  sprintf(file, "%s/%s", path, "name");
  f = fopen(file, "r");
  if ( !f )
    print_error(-6, "'name' file not readable.\n");
  if ( !nc_fgets_nb(tmp, 2048, f) )
  {
    fclose(f);
    print_error(-6, "invalid or missing extension name.\n");
  }
  chop(tmp);
  strcpy(name, tmp);
  fclose(f);
}

//----- (08049D41) --------------------------------------------------------
char *__cdecl nc_fgets(char *s, int size, FILE *stream)
{
  char *tmp; // [esp+18h] [ebp-10h]
  char *tmpa; // [esp+18h] [ebp-10h]
  char *hashmark; // [esp+1Ch] [ebp-Ch]

  if ( !fgets(s, size, stream) )
    return 0;
  hashmark = strchr(s, 35);
  if ( hashmark )
  {
    if ( s == hashmark )
      return nc_fgets(s, size, stream);
    tmp = (char *)malloc(0x800u);
    strcpy(tmp, s);
    tmpa = strtok(tmp, "#");
    sprintf(s, "%s\n", tmpa);
    free(tmpa);
  }
  return s;
}

//----- (08049E14) --------------------------------------------------------
char *__cdecl nc_fgets_html(char *s, int size, FILE *stream)
{
  size_t v4; // eax
  size_t v5; // eax
  int space; // [esp+1Ch] [ebp-2Ch]
  char *insert; // [esp+20h] [ebp-28h]
  char *pos; // [esp+24h] [ebp-24h]
  char *tag_content; // [esp+28h] [ebp-20h]
  char *tag; // [esp+34h] [ebp-14h]
  char *tmp; // [esp+38h] [ebp-10h]
  char *tmpa; // [esp+38h] [ebp-10h]
  char *tmpb; // [esp+38h] [ebp-10h]
  char *hashmark; // [esp+3Ch] [ebp-Ch]

  if ( !fgets(s, size, stream) )
    return 0;
  v4 = strlen(s);
  tmp = (char *)malloc(v4 + 1);
  v5 = strlen(s);
  tag_content = (char *)malloc(v5 + 1);
  insert = tmp;
  for ( pos = s; *pos; ++pos )
  {
    if ( *pos == 60 )
    {
      tag = pos--;
      if ( pos >= s )
        space = *pos == 32;
      while ( *tag )
      {
        *tag_content = *tag;
        ++*tag_content;
        if ( *tag == 62 )
        {
          *tag_content = 0;
          if ( tag[1] != 10 )
          {
            if ( strstr(tag_content, "<br>") && insert > tmp )
            {
              *insert = 10;
              ++*insert;
            }
            if ( strstr(tag_content, "<BR>") && insert > tmp )
            {
              *insert = 10;
              ++*insert;
            }
            if ( strstr(tag_content, "<p>") )
            {
              if ( insert > tmp )
              {
                *insert = 10;
                ++*insert;
              }
              *insert = 10;
              ++*insert;
            }
            if ( strstr(tag_content, "<P>") )
            {
              if ( insert > tmp )
              {
                *insert = 10;
                ++*insert;
              }
              *insert = 10;
              ++*insert;
            }
          }
          pos = tag;
          if ( *tag == 32 && space == 1 )
          {
            pos = tag + 1;
            space = 0;
          }
          break;
        }
        ++tag;
      }
    }
    if ( *pos != 62 )
      *insert++ = *pos;
  }
  *insert = 0;
  strcpy(s, tmp);
  free(tmp);
  free(tag_content);
  hashmark = strchr(s, 35);
  if ( hashmark )
  {
    if ( s == hashmark )
      return nc_fgets_html(s, size, stream);
    tmpa = (char *)malloc(0x800u);
    strcpy(tmpa, s);
    tmpb = strtok(tmpa, "#");
    sprintf(s, "%s\n", tmpb);
    free(tmpb);
  }
  return s;
}
// 804A01D: variable 'space' is possibly undefined

//----- (0804A146) --------------------------------------------------------
int __cdecl is_text(char *s)
{
  int nonws; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]

  nonws = 0;
  for ( i = strlen(s) - 1; i >= 0; --i )
  {
    if ( s[i] != 32 && s[i] != 9 && s[i] != 10 && s[i] != 12 && s[i] != 13 )
      return 1;
    nonws = 0;
  }
  return nonws;
}

//----- (0804A1C8) --------------------------------------------------------
char *__cdecl nc_fgets_nb(char *s, int size, FILE *stream)
{
  char *tmp; // [esp+18h] [ebp-10h]
  char *tmpa; // [esp+18h] [ebp-10h]
  char *hashmark; // [esp+1Ch] [ebp-Ch]

  if ( !fgets(s, size, stream) )
    return 0;
  if ( !is_text(s) )
    return nc_fgets_nb(s, size, stream);
  hashmark = strchr(s, 35);
  if ( hashmark )
  {
    if ( s == hashmark )
      return nc_fgets_nb(s, size, stream);
    tmp = (char *)malloc(0x800u);
    strcpy(tmp, s);
    tmpa = strtok(tmp, "#");
    sprintf(s, "%s\n", tmpa);
    free(tmpa);
  }
  return s;
}

//----- (0804A2C8) --------------------------------------------------------
void __cdecl dump_ascii(char *file, char *heading)
{
  FILE *f; // [esp+28h] [ebp-810h]
  char tmp[2048]; // [esp+2Ch] [ebp-80Ch] BYREF
  unsigned int v4; // [esp+82Ch] [ebp-Ch]

  v4 = __readgsdword(0x14u);
  fprintf(stdout, "%s\n", heading);
  f = fopen(file, "r");
  if ( f )
  {
    while ( nc_fgets_html(tmp, 2048, f) )
      fprintf(stdout, "  %s", tmp);
    fputc(10, stdout);
    fclose(f);
  }
  else
  {
    fwrite("  No information available.\n", 1u, 0x1Cu, stdout);
  }
}

//----- (0804A3DB) --------------------------------------------------------
void __cdecl dump_plain(char *file, char *tmpfile)
{
  int *v2; // eax
  char *i; // eax
  char *v4; // [esp+Ch] [ebp-82Ch]
  FILE *f_out; // [esp+24h] [ebp-814h]
  FILE *f_in; // [esp+28h] [ebp-810h]
  char tmp[2048]; // [esp+2Ch] [ebp-80Ch] BYREF
  unsigned int v8; // [esp+82Ch] [ebp-Ch]

  v8 = __readgsdword(0x14u);
  memcpy(tmpfile, "/tmp/grass.extensions.db.XXXXXX", 0x20u);
  mkstemp(tmpfile);
  f_out = fopen(tmpfile, "w+");
  if ( !f_out )
  {
    v2 = __errno_location();
    v4 = strerror(*v2);
    print_error(
      -23,
      "could not create temp file '%s': %s\n"
      " \t\tMake sure that directory /tmp exists on your system and you have write permission.\n",
      tmpfile,
      v4);
  }
  atexit((void (__cdecl *)(void *))exit_db);
  f_in = fopen(file, "r");
  for ( i = nc_fgets(tmp, 2048, f_in); i; i = nc_fgets(tmp, 2048, f_in) )
    fprintf(f_out, tmp);
  fclose(f_in);
  fclose(f_out);
}

//----- (0804A51B) --------------------------------------------------------
void __cdecl dump_html(char *file, char *tmpfile)
{
  int *v2; // eax
  char *i; // eax
  char *v4; // [esp+Ch] [ebp-102Ch]
  int fd; // [esp+20h] [ebp-1018h]
  FILE *f_out; // [esp+24h] [ebp-1014h]
  FILE *f_in; // [esp+28h] [ebp-1010h]
  char line[2048]; // [esp+2Ch] [ebp-100Ch] BYREF
  char tmp[2048]; // [esp+82Ch] [ebp-80Ch] BYREF
  unsigned int v10; // [esp+102Ch] [ebp-Ch]

  v10 = __readgsdword(0x14u);
  memcpy(tmpfile, "/tmp/grass.extensions.db.XXXXXX", 0x20u);
  mkstemp(tmpfile);
  f_out = fopen(tmpfile, "w+");
  if ( !f_out )
  {
    v2 = __errno_location();
    v4 = strerror(*v2);
    print_error(
      -23,
      "could not create temp file '%s': %s\n"
      " \t\tMake sure that directory /tmp exists on your system and you have write permission.\n",
      tmpfile,
      v4);
  }
  atexit((void (__cdecl *)(void *))exit_db);
  f_in = fopen(file, "r");
  for ( i = nc_fgets(line, 2048, f_in); i; i = nc_fgets(line, 2048, f_in) )
  {
    chop(line);
    if ( is_text(line) )
    {
      sprintf(tmp, "%s <br>\n", line);
      fprintf(f_out, tmp);
    }
    else
    {
      fwrite("<p>\n", 1u, 4u, f_out);
    }
  }
  fclose(f_in);
  fclose(f_out);
  close(fd);
}
// 804A6C2: variable 'fd' is possibly undefined

//----- (0804A6DA) --------------------------------------------------------
void __cdecl list_binaries(char *package)
{
  stat buf; // [esp+28h] [ebp-870h] BYREF
  int n_dirs; // [esp+80h] [ebp-818h]
  dirent *dir_entry; // [esp+84h] [ebp-814h]
  DIR *dir; // [esp+88h] [ebp-810h]
  char tmp[2048]; // [esp+8Ch] [ebp-80Ch] BYREF
  unsigned int v6; // [esp+88Ch] [ebp-Ch]

  v6 = __readgsdword(0x14u);
  n_dirs = 0;
  fwrite("Binary installation files\n", 1u, 0x1Au, stdout);
  dir = opendir(package);
  if ( dir )
  {
    for ( dir_entry = readdir(dir); dir_entry; dir_entry = readdir(dir) )
    {
      if ( strcmp(dir_entry->d_name, ".") )
      {
        if ( strcmp(dir_entry->d_name, "..") )
        {
          if ( strcmp(dir_entry->d_name, "src") )
          {
            sprintf(tmp, "%s/%s", package, dir_entry->d_name);
            stat_0(tmp, (int)&buf);
            if ( (buf.st_mode & 0xF000) == 0x4000 )
            {
              if ( n_dirs )
                fprintf(stdout, ", %s", dir_entry->d_name);
              else
                fprintf(stdout, "  %s", dir_entry->d_name);
              ++n_dirs;
            }
          }
        }
      }
    }
    if ( !n_dirs )
      fwrite("  None.", 1u, 7u, stdout);
    fwrite("\n\n", 1u, 2u, stdout);
  }
  else
  {
    fwrite("  None.\n\n", 1u, 9u, stdout);
  }
}

//----- (0804A92C) --------------------------------------------------------
int __cdecl binaries_exist(char *package, char *binaries)
{
  stat buf; // [esp+2Ch] [ebp-86Ch] BYREF
  dirent *dir_entry; // [esp+84h] [ebp-814h]
  DIR *dir; // [esp+88h] [ebp-810h]
  char tmp[2048]; // [esp+8Ch] [ebp-80Ch] BYREF
  unsigned int v7; // [esp+88Ch] [ebp-Ch]

  v7 = __readgsdword(0x14u);
  dir = opendir(package);
  if ( !dir )
    return 0;
  for ( dir_entry = readdir(dir); dir_entry; dir_entry = readdir(dir) )
  {
    if ( strcmp(dir_entry->d_name, ".") )
    {
      if ( strcmp(dir_entry->d_name, "..") )
      {
        if ( strcmp(dir_entry->d_name, "src") )
        {
          sprintf(tmp, "%s/%s", package, dir_entry->d_name);
          stat_0(tmp, (int)&buf);
          if ( (buf.st_mode & 0xF000) == 0x4000 && !strcmp(dir_entry->d_name, binaries) )
            return 1;
        }
      }
    }
  }
  return 0;
}

//----- (0804AAA8) --------------------------------------------------------
int __cdecl check_filetype(char *myfile)
{
  if ( strstr(myfile, ".tar.gz") )
    return 1;
  if ( strstr(myfile, ".tgz") )
    return 1;
  if ( strstr(myfile, ".tar.bz2") )
    return 2;
  if ( strstr(myfile, ".tbz") )
    return 2;
  if ( strstr(myfile, ".zip") )
    return 3;
  if ( strstr(myfile, ".tar") )
    return 4;
  return 0;
}

//----- (0804AB6C) --------------------------------------------------------
void __cdecl wget_extension(char *url)
{
  int error; // [esp+28h] [ebp-810h]
  char str[2048]; // [esp+2Ch] [ebp-80Ch] BYREF
  unsigned int v3; // [esp+82Ch] [ebp-Ch]

  v3 = __readgsdword(0x14u);
  fwrite("Downloading...", 1u, 0xEu, stdout);
  if ( VERBOSE )
    sprintf(str, "wget -N %s", url);
  else
    sprintf(str, "wget -N -q %s", url);
  error = system(str);
  if ( error == -1 )
    print_error(-20, "could not run 'wget' to download extension. Is it installed?\n");
  if ( error > 0 )
    print_error(-20, "running command '%s'.\n", str);
  print_done();
}

//----- (0804AC6E) --------------------------------------------------------
void __cdecl su(char *gisbase, char *cmd)
{
  int v2; // eax
  FILE *f; // [esp+24h] [ebp-814h]
  char tmpfile[2048]; // [esp+2Ch] [ebp-80Ch] BYREF
  unsigned int v5; // [esp+82Ch] [ebp-Ch]

  v5 = __readgsdword(0x14u);
  next_4089 = 1103515245 * next_4089 + 54321;
  next_4089 = HIWORD(next_4089) & 0x7FFF;
  srand(next_4089);
  v2 = rand();
  sprintf(tmpfile, "%s/gem.test.%i", gisbase, v2);
  f = fopen(tmpfile, "w+");
  if ( *__errno_location() == 13 )
    print_error(
      -5,
      "You don't have write access to your local GRASS installation.\nPlease consult your system administrator.\n");
  remove(tmpfile);
  fclose(f);
  if ( system(cmd) )
    print_error(-9, "could not run '%s'.\n", cmd);
}

//----- (0804AD9B) --------------------------------------------------------
int __cdecl vercmp(int major, int minor, int revision, int major2, int minor2, int revision2)
{
  if ( major == major2 && minor == minor2 && revision == revision2 )
    return 0;
  if ( major2 > major )
    return -1;
  if ( major2 < major )
    return 1;
  if ( minor2 > minor )
    return -1;
  if ( minor2 < minor )
    return 1;
  if ( revision2 <= revision )
    return revision2 < revision;
  return -1;
}

//----- (0804AE20) --------------------------------------------------------
char *__cdecl depstr(char *package, char *gisbase)
{
  char *result; // eax
  int *v3; // eax
  char *v4; // eax
  FILE *f_deps; // [esp+2Ch] [ebp-181Ch]
  int first; // [esp+34h] [ebp-1814h]
  char *str; // [esp+38h] [ebp-1810h]
  char short_name[2048]; // [esp+3Ch] [ebp-180Ch] BYREF
  char line[2048]; // [esp+83Ch] [ebp-100Ch] BYREF
  char file[2048]; // [esp+103Ch] [ebp-80Ch] BYREF
  unsigned int v11; // [esp+183Ch] [ebp-Ch]

  v11 = __readgsdword(0x14u);
  memcpy(file, "../depends", 0xBu);
  f_deps = fopen(file, "r");
  if ( f_deps )
  {
    first = 1;
    str = (char *)malloc(0x800u);
    while ( nc_fgets_nb(line, 2048, f_deps) )
    {
      if ( line[0] && __isoc99_sscanf(line, "%s", short_name) > 0 && strcmp("GRASS", short_name) )
      {
        if ( first )
        {
          strcat(str, "\t");
          strcat(str, short_name);
          first = 0;
        }
        else
        {
          strcat(str, ",");
          strcat(str, short_name);
        }
      }
    }
    fclose(f_deps);
    result = str;
  }
  else
  {
    if ( *__errno_location() != 2 )
    {
      v3 = __errno_location();
      v4 = strerror(*v3);
      print_error(-17, "checking for file '%s': %s\n", file, v4);
    }
    result = (char *)&unk_8054D15;
  }
  return result;
}
// 8048B34: using guessed type int __isoc99_sscanf(_DWORD, const char *, ...);

//----- (0804B014) --------------------------------------------------------
void __cdecl register_extension(char *gisbase, char *bins, char *pkg_short_name, int pkg_major, int pkg_minor, int pkg_revision)
{
  int *v6; // eax
  char *v7; // eax
  int *v8; // eax
  char *v9; // eax
  char *v10; // eax
  char *v11; // eax
  int *v12; // eax
  char *v13; // eax
  char *v14; // eax
  int revision; // [esp+30h] [ebp-2838h] BYREF
  int minor; // [esp+34h] [ebp-2834h] BYREF
  int major; // [esp+38h] [ebp-2830h] BYREF
  FILE *f_out; // [esp+3Ch] [ebp-282Ch]
  FILE *f_in; // [esp+40h] [ebp-2828h]
  int ext_exists; // [esp+44h] [ebp-2824h]
  int copy_thru; // [esp+48h] [ebp-2820h]
  int must_register; // [esp+4Ch] [ebp-281Ch]
  int db_exists; // [esp+50h] [ebp-2818h]
  int error; // [esp+54h] [ebp-2814h]
  int n_lines; // [esp+58h] [ebp-2810h]
  char deps[2048]; // [esp+5Ch] [ebp-280Ch] BYREF
  char inst_bins[2048]; // [esp+85Ch] [ebp-200Ch] BYREF
  char short_name[2048]; // [esp+105Ch] [ebp-180Ch] BYREF
  char str[2048]; // [esp+185Ch] [ebp-100Ch] BYREF
  char file[2048]; // [esp+205Ch] [ebp-80Ch] BYREF
  unsigned int v31; // [esp+285Ch] [ebp-Ch]

  v31 = __readgsdword(0x14u);
  db_exists = 1;
  sprintf(file, "%s/etc/extensions.db", gisbase);
  f_in = fopen(file, "r");
  if ( !f_in )
  {
    if ( *__errno_location() != 2 )
    {
      fclose(f_in);
      v6 = __errno_location();
      v7 = strerror(*v6);
      print_error(-15, "checking for file '%s': %s\n", file, v7);
    }
    db_exists = 0;
  }
  if ( db_exists )
  {
    memcpy(TMPDB, "/tmp/grass.extensions.db.XXXXXX", 0x20u);
    mkstemp(TMPDB);
    f_out = fopen(TMPDB, "w+");
    if ( !f_out )
    {
      v8 = __errno_location();
      v9 = strerror(*v8);
      print_error(
        -15,
        "could not create temp file '%s': %s\n"
        " \t\t\t\t\t\t\tMake sure that directory /tmp exists on your system and you have write permission.\n",
        TMPDB,
        v9);
    }
    atexit((void (__cdecl *)(void *))exit_db);
    n_lines = 0;
    must_register = 1;
    ext_exists = 0;
    while ( nc_fgets_nb(str, 2048, f_in) )
    {
      ++n_lines;
      copy_thru = 1;
      __isoc99_sscanf(str, "%s\t%i.%i.%i\t%s\t%s", short_name, &major, &minor, &revision, inst_bins, deps);
      if ( !strcmp(short_name, pkg_short_name) )
      {
        ext_exists = 1;
        error = vercmp(major, minor, revision, pkg_major, pkg_minor, pkg_revision);
        if ( !FORCE )
        {
          if ( error < 0 )
            print_error(
              -16,
              "Extension '%s' with lower version (%i.%i.%i) already installed. You can use -f to overwrite this version, "
              "if you know what you are doing.\n",
              pkg_short_name,
              major,
              minor,
              revision);
          print_error(
            -16,
            "Extension '%s' with same or higher version (%i.%i.%i) already installed. You can use -f to overwrite this ve"
            "rsion, if you know what you are doing.\n",
            pkg_short_name,
            major,
            minor,
            revision);
        }
        if ( error )
        {
          must_register = 1;
          copy_thru = 0;
        }
        else
        {
          must_register = 0;
        }
      }
      if ( copy_thru )
      {
        fprintf(f_out, str);
        fflush(f_out);
      }
    }
    if ( must_register )
    {
      if ( ext_exists )
      {
        v11 = depstr(pkg_short_name, gisbase);
        strcpy(deps, v11);
        fprintf(f_out, "%s\t%i.%i.%i\t%s\t%s\n", short_name, pkg_major, pkg_minor, pkg_revision, inst_bins, deps);
      }
      else
      {
        v10 = depstr(pkg_short_name, gisbase);
        strcpy(deps, v10);
        fprintf(f_out, "%s\t%i.%i.%i\t%s\t%s\n", pkg_short_name, pkg_major, pkg_minor, pkg_revision, bins, deps);
      }
    }
    fclose(f_out);
    fclose(f_in);
  }
  if ( !n_lines || !db_exists )
  {
    memcpy(TMPDB, "/tmp/grass.extensions.db.XXXXXX", 0x20u);
    mkstemp(TMPDB);
    f_out = fopen(TMPDB, "w+");
    if ( !f_out )
    {
      v12 = __errno_location();
      v13 = strerror(*v12);
      print_error(
        -15,
        "could not create temp db '%s': %s\n"
        " \t\t\t\t\tMake sure that directory /tmp exists on your system and you have write permission.\n",
        file,
        v13);
    }
    atexit((void (__cdecl *)(void *))exit_db);
    v14 = depstr(pkg_short_name, gisbase);
    strcpy(deps, v14);
    fprintf(f_out, "%s\t%i.%i.%i\t%s\t%s\n", pkg_short_name, pkg_major, pkg_minor, pkg_revision, bins, deps);
    fclose(f_out);
  }
}
// 8048B34: using guessed type int __isoc99_sscanf(_DWORD, const char *, ...);

//----- (0804B5E3) --------------------------------------------------------
void __cdecl deregister_extension(char *package, char *pkg_short_name, char *gisbase)
{
  int *v3; // eax
  char *v4; // eax
  int *v5; // eax
  char *v6; // eax
  int revision; // [esp+38h] [ebp-2830h] BYREF
  int minor; // [esp+3Ch] [ebp-282Ch] BYREF
  int major; // [esp+40h] [ebp-2828h] BYREF
  int found_ext; // [esp+44h] [ebp-2824h]
  FILE *f_out; // [esp+48h] [ebp-2820h]
  FILE *f_in; // [esp+4Ch] [ebp-281Ch]
  int copy_thru; // [esp+50h] [ebp-2818h]
  int db_exists; // [esp+54h] [ebp-2814h]
  int error; // [esp+58h] [ebp-2810h]
  char deps[2048]; // [esp+5Ch] [ebp-280Ch] BYREF
  char inst_bins[2048]; // [esp+85Ch] [ebp-200Ch] BYREF
  char short_name[2048]; // [esp+105Ch] [ebp-180Ch] BYREF
  char str[2048]; // [esp+185Ch] [ebp-100Ch] BYREF
  char file[2048]; // [esp+205Ch] [ebp-80Ch] BYREF
  unsigned int v21; // [esp+285Ch] [ebp-Ch]

  v21 = __readgsdword(0x14u);
  db_exists = 0;
  sprintf(file, "%s/etc/extensions.db", gisbase);
  f_in = fopen(file, "r");
  if ( f_in )
  {
    db_exists = 1;
  }
  else
  {
    if ( *__errno_location() == 2 && !FORCE )
    {
      fclose(f_in);
      print_error(-19, "could not deregister: no extensions installed\n");
    }
    if ( !FORCE )
    {
      fclose(f_in);
      v3 = __errno_location();
      v4 = strerror(*v3);
      print_error(-19, "checking for file '%s': %s\n", file, v4);
    }
  }
  if ( db_exists )
  {
    db_exists = 0;
    memcpy(TMPDB, "/tmp/grass.extensions.db.XXXXXX", 0x20u);
    mkstemp(TMPDB);
    f_out = fopen(TMPDB, "w+");
    if ( !f_out && !FORCE )
    {
      v5 = __errno_location();
      v6 = strerror(*v5);
      print_error(
        -19,
        "could not create temp db '%s': %s\n"
        " \t\t\t\t\t\t\tMake sure that directory /tmp exists on your system and you have write permission.\n",
        file,
        v6);
    }
    db_exists = 1;
    atexit((void (__cdecl *)(void *))exit_db);
  }
  if ( db_exists )
  {
    found_ext = 0;
    while ( nc_fgets_nb(str, 2048, f_in) )
    {
      error = __isoc99_sscanf(str, "%s\t%i.%i.%i\t%s\t%s", short_name, &major, &minor, &revision, inst_bins, deps);
      if ( error > 0 )
      {
        copy_thru = 1;
        if ( !strcmp(pkg_short_name, short_name) )
        {
          copy_thru = 0;
          found_ext = 1;
        }
        if ( copy_thru )
        {
          if ( strstr(deps, pkg_short_name) && !FORCE )
            print_error(-19, "cannot uninstall extension '%s' it is needed by '%s'.\n", pkg_short_name, short_name);
          fprintf(f_out, str);
        }
      }
    }
    if ( !found_ext )
      print_error(-19, "no extension '%s' registered/installed in '%s'.\n", pkg_short_name, gisbase);
    fclose(f_in);
    fclose(f_out);
  }
}
// 8048B34: using guessed type int __isoc99_sscanf(_DWORD, const char *, ...);

//----- (0804B961) --------------------------------------------------------
void __cdecl check_dependencies(char *package, char *gisbase, char *grass_version)
{
  int *v3; // eax
  char *v4; // eax
  int *v5; // eax
  char *v6; // eax
  int dep_revision; // [esp+40h] [ebp-2848h] BYREF
  int dep_minor; // [esp+44h] [ebp-2844h] BYREF
  int dep_major; // [esp+48h] [ebp-2840h] BYREF
  int revision; // [esp+4Ch] [ebp-283Ch] BYREF
  int minor; // [esp+50h] [ebp-2838h] BYREF
  int major; // [esp+54h] [ebp-2834h] BYREF
  FILE *f_db; // [esp+58h] [ebp-2830h]
  FILE *f_deps; // [esp+5Ch] [ebp-282Ch]
  int satisfied; // [esp+60h] [ebp-2828h]
  int db_exists; // [esp+64h] [ebp-2824h]
  int error; // [esp+68h] [ebp-2820h]
  char dep_short_name[2048]; // [esp+6Ch] [ebp-281Ch] BYREF
  char short_name[2048]; // [esp+86Ch] [ebp-201Ch] BYREF
  char dbstr[2048]; // [esp+106Ch] [ebp-181Ch] BYREF
  char str[2048]; // [esp+186Ch] [ebp-101Ch] BYREF
  char file[2048]; // [esp+206Ch] [ebp-81Ch] BYREF
  unsigned int v23; // [esp+286Ch] [ebp-1Ch]

  v23 = __readgsdword(0x14u);
  if ( !FORCE )
  {
    f_deps = fopen("../depends", "r");
    if ( f_deps )
    {
      db_exists = 1;
      sprintf(file, "%s/etc/extensions.db", gisbase);
      f_db = fopen(file, "r");
      if ( !f_db )
      {
        if ( *__errno_location() != 2 )
        {
          fclose(f_db);
          v5 = __errno_location();
          v6 = strerror(*v5);
          print_error(-17, "checking for file '%s': %s\n", file, v6);
        }
        db_exists = 0;
      }
      satisfied = 0;
      while ( nc_fgets_nb(str, 2048, f_deps) )
      {
        major = 0;
        minor = 0;
        revision = 0;
        dep_major = 0;
        dep_minor = 0;
        dep_revision = 0;
        error = __isoc99_sscanf(str, "%s\t%i.%i.%i", dep_short_name, &dep_major, &dep_minor, &dep_revision);
        if ( error > 0 )
        {
          if ( !strcmp(dep_short_name, "GRASS") )
          {
            __isoc99_sscanf(grass_version, "%i.%i.%i", &major, &minor, &revision);
            if ( vercmp(major, minor, revision, dep_major, dep_minor, dep_revision) < 0 )
              print_error(
                -18,
                "installed version (%s) of GRASS is too low. Required version is %i.%i.%i\n",
                grass_version,
                dep_major,
                dep_minor,
                dep_revision);
            satisfied = 1;
          }
          else if ( db_exists )
          {
            satisfied = 0;
            rewind(f_db);
            while ( nc_fgets_nb(dbstr, 2048, f_db) )
            {
              major = 0;
              minor = 0;
              revision = 0;
              error = __isoc99_sscanf(dbstr, "%s\t%i.%i.%i", short_name, &major, &minor, &revision);
              if ( error > 0 && !strcmp(short_name, dep_short_name) )
              {
                if ( vercmp(major, minor, revision, dep_major, dep_minor, dep_revision) < 0 )
                  print_error(
                    -18,
                    "installed version %i.%i.%i of required extension '%s' is too low.\n"
                    " \t\t\t\t\t\t\t\t\t\t\t\t\tRequired version is %i.%i.%i\n",
                    major,
                    minor,
                    revision,
                    dep_short_name,
                    dep_major,
                    dep_minor,
                    dep_revision);
                satisfied = 1;
              }
            }
            if ( !satisfied )
              print_error(-18, "required extension '%s' not found in '%s'.\n", dep_short_name, gisbase);
          }
        }
      }
      if ( db_exists )
        fclose(f_db);
      fclose(f_deps);
    }
    else
    {
      if ( *__errno_location() != 2 )
      {
        fclose(f_deps);
        v3 = __errno_location();
        v4 = strerror(*v3);
        print_error(-17, "checking for file '%s': %s\n", file, v4);
      }
      fprintf(stderr, "\n%s/depends ENOENT\n", package);
    }
  }
}
// 8048B34: using guessed type int __isoc99_sscanf(_DWORD, const char *, ...);

//----- (0804BE84) --------------------------------------------------------
int __cdecl is_submenu(char *item)
{
  char *v2; // ebx

  if ( !strchr(item, 91) )
    return 0;
  if ( !strrchr(item, 93) )
    return 0;
  v2 = strchr(item, 91);
  return v2 <= strrchr(item, 93);
}

//----- (0804BF05) --------------------------------------------------------
int __cdecl check_ext_menu(char **tcl_lines)
{
  int idx; // [esp+1Ch] [ebp-Ch]
  int idxa; // [esp+1Ch] [ebp-Ch]
  int idxb; // [esp+1Ch] [ebp-Ch]
  int idxc; // [esp+1Ch] [ebp-Ch]

  idx = find_pos("\"&Xtns\" all options 1", tcl_lines, 0);
  if ( idx != -1 )
    return idx;
  idxa = find_pos("\"&Help\" all options", tcl_lines, 0);
  if ( idxa != -1 )
  {
    insert_str(" \"&Xtns\" all options 1 {\n", idxa, tcl_lines);
    idx = idxa + 1;
    insert_str(" }\n", idx, tcl_lines);
    return idx;
  }
  idxb = find_pos("}]", tcl_lines, 0);
  if ( idxb == -1 )
    print_error(-21, "could not parse 'menu.tcl'.\n");
  insert_str(" \"&Xtns\" all options 1 {\n", idxb, tcl_lines);
  idxc = idxb + 1;
  insert_str(" }\n", idxc, tcl_lines);
  return idxc;
}

//----- (0804C009) --------------------------------------------------------
int __cdecl new_submenu(char *pkg_short_name, char *menu, char **tcl_lines)
{
  int v3; // eax
  int result; // eax
  char *v5; // ebx
  size_t v6; // ebx
  char *v7; // eax
  int terminator; // [esp+2Ch] [ebp-182Ch]
  char *second_quote; // [esp+34h] [ebp-1824h]
  char *first_quote; // [esp+38h] [ebp-1820h]
  int last; // [esp+3Ch] [ebp-181Ch]
  int insert_here; // [esp+40h] [ebp-1818h]
  int idx2; // [esp+44h] [ebp-1814h]
  int idx2a; // [esp+44h] [ebp-1814h]
  int idx; // [esp+48h] [ebp-1810h]
  char searchstr[2048]; // [esp+4Ch] [ebp-180Ch] BYREF
  char tmp2[2048]; // [esp+84Ch] [ebp-100Ch] BYREF
  char tmp[2048]; // [esp+104Ch] [ebp-80Ch] BYREF
  unsigned int v19; // [esp+184Ch] [ebp-Ch]

  v19 = __readgsdword(0x14u);
  idx = find_pos("\"&Xtns\" all options", tcl_lines, 0);
  v3 = find_pos("\" all options", tcl_lines, idx + 1);
  last = v3 - 1;
  if ( !v3 )
    last = find_pos("}]", tcl_lines, 0);
  if ( is_submenu(menu) )
  {
    v5 = strrchr(menu, 93);
    v6 = v5 - strchr(menu, 91);
    v7 = strchr(menu, 91);
    strncpy(tmp, v7 + 1, v6);
    tmp[v6 - 1] = 0;
    sprintf(searchstr, "{cascad \"%s\"", tmp);
    idx2 = find_pos(searchstr, tcl_lines, idx);
    if ( idx2 == -1 || idx2 >= last )
    {
      insert_here = idx + 1;
      for ( idx2a = find_pos("{cascad ", tcl_lines, idx);
            idx2a != -1 && idx2a < last;
            idx2a = find_pos("{cascad ", tcl_lines, idx) )
      {
        first_quote = strchr(tcl_lines[idx2a], 34);
        second_quote = strchr(first_quote + 1, 34);
        strncpy(tmp2, first_quote + 1, second_quote - first_quote);
        tmp2[second_quote - first_quote - 1] = 0;
        if ( strcmp(tmp, tmp2) < 0 )
        {
          insert_here = idx2a;
          break;
        }
        ++idx;
      }
      sprintf(tmp, " \t\t\t%s {} \"\" 1 {\n", searchstr);
      insert_str(tmp, insert_here, tcl_lines);
      insert_str(" \t\t\t}}\n", insert_here + 1, tcl_lines);
      terminator = find_pos("}]", tcl_lines, 0);
      sprintf(tmp, "#(DO_NOT_REMOVE_THIS_COMMENT) <%s> %s {} \"\" 1 {\n", pkg_short_name, searchstr);
      insert_str(tmp, terminator + 1, tcl_lines);
      result = insert_here + 1;
    }
    else
    {
      print_warning("submenu '%s' exists in GIS Manager's Xtns menu.\n", tmp);
      result = -1;
    }
  }
  else
  {
    print_warning("first line not a submenu specifier in 'entries-gisman'.\n");
    result = -1;
  }
  return result;
}

//----- (0804C41B) --------------------------------------------------------
int __cdecl new_item(char *item, char *menu, char **tcl_lines, int line_no)
{
  int result; // eax
  int num_tokens; // [esp+34h] [ebp-1814h]
  const char *token; // [esp+38h] [ebp-1810h]
  char tmp[2048]; // [esp+3Ch] [ebp-180Ch] BYREF
  char command[2048]; // [esp+83Ch] [ebp-100Ch] BYREF
  char entry[2048]; // [esp+103Ch] [ebp-80Ch] BYREF
  unsigned int v10; // [esp+183Ch] [ebp-Ch]

  v10 = __readgsdword(0x14u);
  chop(item);
  token = strtok(item, ";");
  if ( token )
  {
    strcpy(entry, token);
    num_tokens = 0;
    while ( token )
    {
      token = strtok(0, ";");
      if ( token )
        strcpy(command, token);
      ++num_tokens;
    }
    if ( num_tokens <= 2 )
    {
      if ( !strcmp(entry, "-") && !strcmp(entry, "-") )
        memcpy(tmp, " \t\t\t {separator}\n", 0x12u);
      else
        sprintf(tmp, " \t\t\t {command \"%s\" {} \"%s\" {} -command {%s }}\n", entry, command, command);
      insert_str(tmp, line_no, tcl_lines);
      result = line_no + 1;
    }
    else
    {
      print_warning("invalid number of tokens (%i) in 'entries-gisman'.\n", num_tokens);
      result = -1;
    }
  }
  else
  {
    print_warning("invalid token in 'entries-gisman'.\n");
    result = -1;
  }
  return result;
}

//----- (0804C5F0) --------------------------------------------------------
void __cdecl register_entries_gisman(char *pkg_short_name, char *gisbase)
{
  int *v2; // eax
  char *v3; // eax
  int *v4; // eax
  char *v5; // eax
  int *v6; // eax
  char *v7; // eax
  size_t v8; // eax
  char *v9; // ebx
  int v10; // ebx
  char *v11; // eax
  FILE *f_out; // [esp+50h] [ebp-1838h]
  FILE *f_in; // [esp+54h] [ebp-1834h]
  FILE *f_gisman; // [esp+58h] [ebp-1830h]
  int line_no; // [esp+5Ch] [ebp-182Ch]
  int n_lines_new; // [esp+60h] [ebp-1828h]
  int i; // [esp+68h] [ebp-1820h]
  int ia; // [esp+68h] [ebp-1820h]
  int ib; // [esp+68h] [ebp-1820h]
  int ic; // [esp+68h] [ebp-1820h]
  int id; // [esp+68h] [ebp-1820h]
  int n_lines; // [esp+6Ch] [ebp-181Ch]
  int n_entries; // [esp+70h] [ebp-1818h]
  char **line; // [esp+74h] [ebp-1814h]
  int len; // [esp+78h] [ebp-1810h]
  char menu[2048]; // [esp+7Ch] [ebp-180Ch] BYREF
  char str[2048]; // [esp+87Ch] [ebp-100Ch] BYREF
  char file[2048]; // [esp+107Ch] [ebp-80Ch] BYREF
  unsigned int v29; // [esp+187Ch] [ebp-Ch]

  v29 = __readgsdword(0x14u);
  memcpy(file, "../entries-gisman", 0x12u);
  f_gisman = fopen(file, "r");
  if ( f_gisman )
  {
    sprintf(file, "%s/etc/dm/menu.tcl", gisbase);
    f_in = fopen(file, "r");
    if ( f_in )
    {
      memcpy(TMP_GISMAN, "/tmp/grass.extensions.db.XXXXXX", 0x20u);
      mkstemp(TMP_GISMAN);
      f_out = fopen(TMP_GISMAN, "w+");
      if ( !f_out )
      {
        v6 = __errno_location();
        v7 = strerror(*v6);
        print_error(
          -21,
          "could not create temp file '%s': %s\n"
          " \t\t\tMake sure that directory /tmp exists on your system and you have write permission.\n",
          TMP_GISMAN,
          v7);
      }
      atexit((void (__cdecl *)(void *))exit_db);
      if ( VERBOSE )
        sprintf(
          str,
          "mkdir --verbose %s/etc/dm/gem-entries ; cp -vf ../entries-gisman %s/etc/dm/gem-entries/%s ; \t\t\t\t\tcp -vf %"
          "s/etc/dm/menu.tcl %s/etc/dm/menu.tcl.gem.bak ; \t\t\t\t\tcp -vf %s %s/etc/dm/menu.tcl ; chmod -v a+r %s/etc/dm/menu.tcl ;",
          gisbase,
          gisbase,
          pkg_short_name,
          gisbase,
          gisbase,
          TMP_GISMAN,
          gisbase,
          gisbase);
      else
        sprintf(
          str,
          "mkdir %s/etc/dm/gem-entries &> %s ; cp -f ../entries-gisman %s/etc/dm/gem-entries/%s &> %s ; \t\t\t\t\tcp -f %"
          "s/etc/dm/menu.tcl %s/etc/dm/menu.tcl.gem.bak &> %s ; \t\t\t\t\tcp -f %s %s/etc/dm/menu.tcl &> %s ; chmod a+r %"
          "s/etc/dm/menu.tcl &> %s ;",
          gisbase,
          TMP_NULL,
          gisbase,
          pkg_short_name,
          TMP_NULL,
          gisbase,
          gisbase,
          TMP_NULL,
          TMP_GISMAN,
          gisbase,
          TMP_NULL,
          gisbase,
          TMP_NULL);
      strcpy(GISMAN_CMD, str);
      n_entries = 0;
      while ( fgets(str, 2048, f_gisman) )
        ++n_entries;
      if ( n_entries )
      {
        rewind(f_gisman);
        n_lines = 0;
        while ( fgets(str, 2048, f_in) )
          ++n_lines;
        if ( n_lines )
        {
          rewind(f_in);
          line = (char **)calloc(n_lines + 2 * n_entries + 6, 4u);
          for ( i = 0; n_lines + 2 * n_entries + 6 > i; ++i )
            line[i] = 0;
          ia = 0;
          while ( fgets(str, 2048, f_in) )
          {
            v8 = strlen(str);
            line[ia] = (char *)malloc(v8 + 1);
            strcpy(line[ia++], str);
          }
          check_ext_menu(line);
          ib = 1;
          while ( nc_fgets_nb(str, 2048, f_gisman) )
          {
            if ( ib == 1 )
            {
              v9 = strrchr(str, 93);
              len = v9 - strchr(str, 91);
              v10 = len;
              v11 = strchr(str, 91);
              strncpy(menu, v11 + 1, v10);
              menu[len - 1] = 0;
              line_no = new_submenu(pkg_short_name, str, line);
              if ( line_no < 0 )
              {
                print_warning("no GIS Manager menu entries created.\n");
                break;
              }
              ib = 2;
            }
            else
            {
              line_no = new_item(str, menu, line, line_no);
              if ( line_no < 0 )
              {
                print_warning("error creating GIS Manager menu entries.\n");
                break;
              }
              ++ib;
            }
          }
          for ( ic = 0; line[ic]; ++ic )
            fprintf(f_out, line[ic]);
          fflush(f_out);
          rewind(f_out);
          n_lines_new = 0;
          while ( fgets(str, 2048, f_out) )
            ++n_lines_new;
          if ( !n_lines_new || n_lines_new < n_lines )
          {
            print_warning("file truncation detected. Retaining orginal file 'menu.tcl'.\n");
            memcpy(GISMAN_CMD, &unk_8055722, 1u);
          }
          fclose(f_in);
          fclose(f_gisman);
          fclose(f_out);
          for ( id = 0; n_lines + 2 * n_entries + 6 > id; ++id )
            free(line[id]);
          free(line);
        }
      }
    }
    else if ( *__errno_location() != 2 )
    {
      fclose(0);
      v4 = __errno_location();
      v5 = strerror(*v4);
      print_error(-21, "checking for file '%s': %s\n", file, v5);
    }
  }
  else if ( *__errno_location() != 2 )
  {
    fclose(0);
    v2 = __errno_location();
    v3 = strerror(*v2);
    print_error(-21, "checking for file '%s': %s\n", file, v3);
  }
}
// 804CB9A: variable 'line_no' is possibly undefined

//----- (0804CD6C) --------------------------------------------------------
void __cdecl register_entries_gisman2(char *pkg_short_name, char *gisbase)
{
  int *v2; // eax
  char *v3; // eax
  char str[2048]; // [esp+3Ch] [ebp-100Ch] BYREF
  char file[2048]; // [esp+83Ch] [ebp-80Ch] BYREF
  unsigned int v6; // [esp+103Ch] [ebp-Ch]

  v6 = __readgsdword(0x14u);
  memcpy(file, "../entries-gisman2", 0x13u);
  if ( fopen(file, "r") )
  {
    if ( VERBOSE )
      sprintf(
        str,
        "mkdir --verbose -p %s/etc/gm/Xtns ; cp -fv ../entries-gisman2 %s/etc/gm/Xtns/%s.gem ; ",
        gisbase,
        gisbase,
        pkg_short_name);
    else
      sprintf(
        str,
        "mkdir -p %s/etc/gm/Xtns ; cp -f ../entries-gisman2 %s/etc/gm/Xtns/%s.gem ; ",
        gisbase,
        gisbase,
        pkg_short_name);
    strcpy(GISMAN2_CMD, str);
  }
  else if ( *__errno_location() != 2 )
  {
    fclose(0);
    v2 = __errno_location();
    v3 = strerror(*v2);
    print_error(-32, "checking for file '%s': %s\n", file, v3);
  }
}

//----- (0804CEC7) --------------------------------------------------------
int __cdecl deregister_entries_gisman(char *pkg_short_name, char *gisbase)
{
  int result; // eax
  int *v3; // eax
  char *v4; // eax
  int *v5; // eax
  char *v6; // eax
  size_t v7; // eax
  int v8; // eax
  int num_removed; // [esp+40h] [ebp-1848h]
  int num_removeda; // [esp+40h] [ebp-1848h]
  char *rq; // [esp+44h] [ebp-1844h]
  char *lq; // [esp+48h] [ebp-1840h]
  int end_sub; // [esp+4Ch] [ebp-183Ch]
  int start_sub; // [esp+50h] [ebp-1838h]
  int end; // [esp+54h] [ebp-1834h]
  int enda; // [esp+54h] [ebp-1834h]
  int start; // [esp+58h] [ebp-1830h]
  int starta; // [esp+58h] [ebp-1830h]
  int pos; // [esp+5Ch] [ebp-182Ch]
  int posa; // [esp+5Ch] [ebp-182Ch]
  FILE *f_out; // [esp+60h] [ebp-1828h]
  FILE *f_in; // [esp+64h] [ebp-1824h]
  int n_lines_new; // [esp+68h] [ebp-1820h]
  int i; // [esp+70h] [ebp-1818h]
  int ia; // [esp+70h] [ebp-1818h]
  int ib; // [esp+70h] [ebp-1818h]
  int ic; // [esp+70h] [ebp-1818h]
  int id; // [esp+70h] [ebp-1818h]
  int ie; // [esp+70h] [ebp-1818h]
  int n_lines; // [esp+74h] [ebp-1814h]
  char **line; // [esp+78h] [ebp-1810h]
  char tmp[2048]; // [esp+7Ch] [ebp-180Ch] BYREF
  char str[2048]; // [esp+87Ch] [ebp-100Ch] BYREF
  char file[2048]; // [esp+107Ch] [ebp-80Ch] BYREF
  unsigned int v35; // [esp+187Ch] [ebp-Ch]

  v35 = __readgsdword(0x14u);
  sprintf(file, "%s/etc/dm/menu.tcl", gisbase);
  f_in = fopen(file, "r");
  if ( f_in )
  {
    memcpy(TMP_GISMAN, "/tmp/grass.extensions.db.XXXXXX", 0x20u);
    mkstemp(TMP_GISMAN);
    f_out = fopen(TMP_GISMAN, "w+");
    if ( !f_out )
    {
      v5 = __errno_location();
      v6 = strerror(*v5);
      print_error(
        -21,
        "could not create temp file '%s': %s\n"
        " \t\t\tMake sure that directory /tmp exists on your system and you have write permission.\n",
        TMP_GISMAN,
        v6);
    }
    atexit((void (__cdecl *)(void *))exit_db);
    if ( VERBOSE )
      sprintf(
        str,
        "cp -vf %s/etc/dm/menu.tcl %s/etc/dm/menu.tcl.gem.bak ; \t\t\t\t\t\tcp -vf %s %s/etc/dm/menu.tcl ; chmod -v a+r %"
        "s/etc/dm/menu.tcl ;",
        gisbase,
        gisbase,
        TMP_GISMAN,
        gisbase,
        gisbase);
    else
      sprintf(
        str,
        "cp -f %s/etc/dm/menu.tcl %s/etc/dm/menu.tcl.gem.bak &> %s ; \t\t\t\t\t\tcp -f %s %s/etc/dm/menu.tcl &> %s ; chmo"
        "d a+r %s/etc/dm/menu.tcl &> %s ;",
        gisbase,
        gisbase,
        TMP_NULL,
        TMP_GISMAN,
        gisbase,
        TMP_NULL,
        gisbase,
        TMP_NULL);
    strcpy(GISMAN_CMD, str);
    n_lines = 0;
    while ( fgets(str, 2048, f_in) )
      ++n_lines;
    if ( n_lines )
    {
      rewind(f_in);
      line = (char **)calloc(n_lines + 1, 4u);
      for ( i = 0; n_lines + 1 > i; ++i )
        line[i] = 0;
      ia = 0;
      while ( fgets(str, 2048, f_in) )
      {
        v7 = strlen(str);
        line[ia] = (char *)malloc(v7 + 1);
        strcpy(line[ia++], str);
      }
      sprintf(str, "#(DO_NOT_REMOVE_THIS_COMMENT) <%s> {cascad", pkg_short_name);
      pos = find_pos(str, line, 0);
      if ( pos == -1 )
      {
        print_warning("could not find uninstall information in 'menu.tcl'.\n");
        result = -1;
      }
      else
      {
        lq = strchr(line[pos], 34) + 1;
        rq = strchr(lq, 34);
        strcpy(tmp, lq);
        tmp[rq - lq] = 0;
        start = find_pos("\"&Xtns\" all options 1", line, 0);
        v8 = find_pos("\" all options", line, start + 1);
        end = v8 - 1;
        if ( !v8 )
          end = find_pos("}]", line, 0);
        if ( start == -1 )
        {
          print_warning("menu 'Xtns' does not exist.\n");
          result = -1;
        }
        else
        {
          sprintf(str, "{cascad \"%s\"", tmp);
          start_sub = find_pos(str, line, start);
          if ( start_sub == -1 || start_sub > end )
          {
            print_warning("could not find submenu entry '%s' in 'menu.tcl'.\n", tmp);
            result = -1;
          }
          else
          {
            end_sub = find_pos(" \t\t\t}}", line, start_sub);
            if ( end_sub == -1 || end_sub > end )
            {
              print_warning("could not find end of submenu entry '%s' in 'menu.tcl'.\n", tmp);
              result = -1;
            }
            else
            {
              num_removed = 0;
              for ( ib = 0; end_sub - start_sub + 1 > ib; ++ib )
              {
                delete_str(start_sub, line);
                ++num_removed;
              }
              sprintf(str, "#(DO_NOT_REMOVE_THIS_COMMENT) <%s> {cascad", pkg_short_name);
              posa = find_pos(str, line, 0);
              delete_str(posa, line);
              num_removeda = num_removed + 1;
              starta = find_pos("\"&Xtns\" all options 1", line, 0);
              enda = find_pos("\" all options", line, starta + 1) - 1;
              if ( enda - starta <= 2 )
              {
                for ( ic = 0; enda - starta + 1 > ic; ++ic )
                {
                  delete_str(starta, line);
                  ++num_removeda;
                }
              }
              for ( id = 0; line[id]; ++id )
                fprintf(f_out, line[id]);
              fflush(f_out);
              rewind(f_out);
              n_lines_new = 0;
              while ( fgets(str, 2048, f_out) )
                ++n_lines_new;
              if ( !n_lines_new )
              {
                print_warning("file truncation detected. Retaining orginal file 'menu.tcl'.\n");
                memcpy(GISMAN_CMD, &unk_8055722, 1u);
              }
              fclose(f_in);
              fclose(f_out);
              for ( ie = 0; n_lines + 1 > ie; ++ie )
                free(line[ie]);
              free(line);
              result = num_removeda;
            }
          }
        }
      }
    }
    else
    {
      result = -1;
    }
  }
  else
  {
    if ( *__errno_location() != 2 )
    {
      fclose(0);
      v3 = __errno_location();
      v4 = strerror(*v3);
      print_error(-22, "checking for file '%s': %s\n", file, v4);
    }
    result = 0;
  }
  return result;
}

//----- (0804D743) --------------------------------------------------------
void __cdecl deregister_entries_gisman2(char *pkg_short_name, char *gisbase)
{
  int *v2; // eax
  char *v3; // eax
  char str[2048]; // [esp+2Ch] [ebp-100Ch] BYREF
  char file[2048]; // [esp+82Ch] [ebp-80Ch] BYREF
  unsigned int v6; // [esp+102Ch] [ebp-Ch]

  v6 = __readgsdword(0x14u);
  sprintf(file, "%s/etc/gm/Xtns/%s.gem", gisbase, pkg_short_name);
  if ( fopen(file, "r") )
  {
    if ( VERBOSE )
      sprintf(str, "rm -vf %s/etc/gm/Xtns/%s.gem ; ", gisbase, pkg_short_name);
    else
      sprintf(str, "rm -f %s/etc/gm/Xtns/%s.gem ; ", gisbase, pkg_short_name);
    strcpy(GISMAN_CMD, str);
  }
  else if ( *__errno_location() != 2 )
  {
    fclose(0);
    v2 = __errno_location();
    v3 = strerror(*v2);
    print_error(-33, "checking for file '%s': %s\n", file, v3);
  }
}

//----- (0804D896) --------------------------------------------------------
int __cdecl restore_entries_gisman(char *gisbase)
{
  int result; // eax
  int *v2; // eax
  char *v3; // eax
  int *v4; // eax
  char *v5; // eax
  size_t v6; // eax
  char *v7; // ebx
  size_t v8; // ebx
  char *v9; // eax
  int n_files; // [esp+48h] [ebp-2840h]
  int num_restored; // [esp+4Ch] [ebp-283Ch]
  dirent *ep; // [esp+50h] [ebp-2838h]
  dirent *epa; // [esp+50h] [ebp-2838h]
  DIR *dirp; // [esp+54h] [ebp-2834h]
  DIR *dirpa; // [esp+54h] [ebp-2834h]
  FILE *f_out; // [esp+58h] [ebp-2830h]
  FILE *f_in; // [esp+5Ch] [ebp-282Ch]
  FILE *f_gisman; // [esp+60h] [ebp-2828h]
  FILE *f_gismana; // [esp+60h] [ebp-2828h]
  int line_no; // [esp+64h] [ebp-2824h]
  int i; // [esp+68h] [ebp-2820h]
  int ia; // [esp+68h] [ebp-2820h]
  int ib; // [esp+68h] [ebp-2820h]
  int ic; // [esp+68h] [ebp-2820h]
  int id; // [esp+68h] [ebp-2820h]
  int n_lines; // [esp+6Ch] [ebp-281Ch]
  int n_entries; // [esp+70h] [ebp-2818h]
  char **line; // [esp+74h] [ebp-2814h]
  char pkg_short_name[2048]; // [esp+7Ch] [ebp-280Ch] BYREF
  char dir[2048]; // [esp+87Ch] [ebp-200Ch] BYREF
  char file[2048]; // [esp+107Ch] [ebp-180Ch] BYREF
  char menu[2048]; // [esp+187Ch] [ebp-100Ch] BYREF
  char str[2048]; // [esp+207Ch] [ebp-80Ch] BYREF
  unsigned int v34; // [esp+287Ch] [ebp-Ch]

  v34 = __readgsdword(0x14u);
  sprintf(file, "%s/etc/dm/menu.tcl", gisbase);
  f_in = fopen(file, "r");
  if ( f_in )
  {
    memcpy(TMP_GISMAN, "/tmp/grass.extensions.db.XXXXXX", 0x20u);
    mkstemp(TMP_GISMAN);
    f_out = fopen(TMP_GISMAN, "w+");
    if ( !f_out )
    {
      v4 = __errno_location();
      v5 = strerror(*v4);
      print_error(
        -21,
        "could not create temp file '%s': %s\n"
        " \t\t\tMake sure that directory /tmp exists on your system and you have write permission.\n",
        TMP_GISMAN,
        v5);
    }
    atexit((void (__cdecl *)(void *))exit_db);
    if ( VERBOSE )
      sprintf(
        str,
        "cp -vf %s/etc/dm/menu.tcl %s/etc/dm/menu.tcl.gem.bak ; \t\t\t\t\t\tcp -vf %s %s/etc/dm/menu.tcl ; chmod -v a+r %"
        "s/etc/dm/menu.tcl ;",
        gisbase,
        gisbase,
        TMP_GISMAN,
        gisbase,
        gisbase);
    else
      sprintf(
        str,
        "cp -f %s/etc/dm/menu.tcl %s/etc/dm/menu.tcl.gem.bak &> %s ; \t\t\t\t\t\tcp -f %s %s/etc/dm/menu.tcl &> %s ; chmo"
        "d a+r %s/etc/dm/menu.tcl &> %s ;",
        gisbase,
        gisbase,
        TMP_NULL,
        TMP_GISMAN,
        gisbase,
        TMP_NULL,
        gisbase,
        TMP_NULL);
    strcpy(GISMAN_CMD, str);
    sprintf(dir, "%s/etc/dm/gem-entries", gisbase);
    dirp = opendir(dir);
    if ( dirp )
    {
      n_entries = 0;
      n_files = 0;
      while ( 1 )
      {
        ep = readdir(dirp);
        if ( !ep )
          break;
        sprintf(file, "%s/%s", dir, ep->d_name);
        f_gisman = fopen(file, "r");
        if ( !strcmp(ep->d_name, ".") || !strcmp(ep->d_name, "..") )
        {
          fclose(f_gisman);
        }
        else if ( f_gisman )
        {
          while ( fgets(str, 2048, f_gisman) )
            ++n_entries;
          ++n_files;
          fclose(f_gisman);
        }
        else
        {
          fclose(0);
        }
      }
      closedir(dirp);
      n_lines = 0;
      while ( fgets(str, 2048, f_in) )
        ++n_lines;
      if ( n_lines )
      {
        rewind(f_in);
        line = (char **)calloc(n_lines + 2 * n_entries + 5 * n_files + 1, 4u);
        for ( i = 0; n_lines + 2 * n_entries + 5 * n_files + 1 > i; ++i )
          line[i] = 0;
        ia = 0;
        while ( fgets(str, 2048, f_in) )
        {
          v6 = strlen(str);
          line[ia] = (char *)malloc(v6 + 1);
          strcpy(line[ia++], str);
        }
        line[ia] = 0;
        check_ext_menu(line);
        dirpa = opendir(dir);
        num_restored = 0;
        while ( 1 )
        {
          epa = readdir(dirpa);
          if ( !epa )
            break;
          sprintf(file, "%s/%s", dir, epa->d_name);
          if ( strcmp(epa->d_name, ".") )
          {
            if ( strcmp(epa->d_name, "..") )
            {
              f_gismana = fopen(file, "r");
              if ( f_gismana )
              {
                ib = 1;
                while ( nc_fgets_nb(str, 2048, f_gismana) )
                {
                  if ( ib == 1 )
                  {
                    v7 = strrchr(str, 93);
                    v8 = v7 - strchr(str, 91);
                    v9 = strchr(str, 91);
                    strncpy(menu, v9 + 1, v8);
                    menu[v8 - 1] = 0;
                    line_no = new_submenu(pkg_short_name, str, line);
                    if ( line_no < 0 )
                      break;
                    ib = 2;
                    ++num_restored;
                  }
                  else
                  {
                    line_no = new_item(str, menu, line, line_no);
                    if ( line_no < 0 )
                      break;
                    ++ib;
                    ++num_restored;
                  }
                }
                fclose(f_gismana);
              }
            }
          }
        }
        closedir(dirpa);
        for ( ic = 0; line[ic]; ++ic )
          fprintf(f_out, line[ic]);
        fflush(f_out);
        fclose(f_in);
        fclose(f_out);
        for ( id = 0; n_lines + 2 * n_entries + 5 * n_files + 1 > id; ++id )
          free(line[id]);
        free(line);
        result = num_restored;
      }
      else
      {
        result = 0;
      }
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    if ( *__errno_location() != 2 )
    {
      fclose(0);
      v2 = __errno_location();
      v3 = strerror(*v2);
      print_error(-21, "checking for file '%s': %s\n", file, v3);
    }
    result = 0;
  }
  return result;
}
// 804DF71: variable 'line_no' is possibly undefined

//----- (0804E100) --------------------------------------------------------
void __cdecl new_ext_html(char *ext, char *gisbase, char **html, int major, int minor, int revision)
{
  char *last_char; // [esp+3Ch] [ebp-82Ch]
  char *first_char; // [esp+40h] [ebp-828h]
  int insert_here; // [esp+44h] [ebp-824h]
  int end; // [esp+48h] [ebp-820h]
  int start; // [esp+4Ch] [ebp-81Ch]
  int pos3; // [esp+50h] [ebp-818h]
  int pos3a; // [esp+50h] [ebp-818h]
  int pos2; // [esp+54h] [ebp-814h]
  int pos1; // [esp+58h] [ebp-810h]
  char item[2048]; // [esp+5Ch] [ebp-80Ch] BYREF
  unsigned int v16; // [esp+85Ch] [ebp-Ch]

  v16 = __readgsdword(0x14u);
  pos1 = find_pos("<b>Drivers sections:</b>", html, 0);
  if ( pos1 >= 0
    || (pos1 = find_pos("<!-- GEM Extensions StartHTML. Do not delete or change this comment! -->", html, 0), pos1 >= 0) )
  {
    pos2 = find_pos("<hr>", html, pos1);
    if ( find_pos("<h3>Installed extensions:</h3>", html, pos1) == -1 )
    {
      insert_str("<h3>Installed extensions:</h3>\n", pos2, html);
      insert_str("<ul>\n", pos2 + 1, html);
      insert_str("</ul>\n", pos2 + 2, html);
      insert_str("<p>\n", pos2 + 3, html);
    }
    start = find_pos("<h3>Installed extensions:</h3>", html, pos1);
    end = find_pos("</ul>", html, start);
    insert_here = start + 2;
    sprintf(item, "\">%s", ext);
    pos3 = find_pos(item, html, start + 2);
    if ( pos3 == -1 )
    {
      for ( pos3a = find_pos("<li><a href=", html, start);
            pos3a != -1 && pos3a < end;
            pos3a = find_pos("<li><a href=", html, start) )
      {
        first_char = strrchr(html[pos3a], 34);
        last_char = strrchr(html[pos3a], 60);
        strncpy(item, first_char + 2, last_char - first_char);
        item[last_char - first_char - 1] = 0;
        if ( strcmp(ext, item) < 0 )
        {
          insert_here = pos3a;
          break;
        }
        ++start;
      }
      sprintf(item, "<li><a href=\"../extensions/%s/index.html\">%s (%i.%i.%i)</a>\n", ext, ext, major, minor, revision);
      insert_str(item, insert_here, html);
    }
    else
    {
      print_warning("list item '%s' exists in index.html.\n", ext);
      if ( FORCE )
      {
        if ( UPGRADE )
        {
          sprintf(
            item,
            "<li><a href=\"../extensions/%s/index.html\">%s (%i.%i.%i)</a>\n",
            ext,
            ext,
            major,
            minor,
            revision);
          strcpy(html[pos3], item);
        }
      }
    }
  }
  else
  {
    print_warning("Unknown format of index.html. Unable to register HTML man pages.\n");
  }
}

//----- (0804E56F) --------------------------------------------------------
void __cdecl delete_ext_html(char *ext, char *gisbase, char **html)
{
  int i; // [esp+20h] [ebp-828h]
  int end; // [esp+28h] [ebp-820h]
  int enda; // [esp+28h] [ebp-820h]
  int start; // [esp+2Ch] [ebp-81Ch]
  int pos3; // [esp+30h] [ebp-818h]
  int pos3a; // [esp+30h] [ebp-818h]
  int pos1; // [esp+38h] [ebp-810h]
  char item[2048]; // [esp+3Ch] [ebp-80Ch] BYREF
  unsigned int v11; // [esp+83Ch] [ebp-Ch]

  v11 = __readgsdword(0x14u);
  pos1 = find_pos("<b>Drivers sections:</b>", html, 0);
  if ( pos1 >= 0
    || (pos1 = find_pos("<!-- GEM Extensions StartHTML. Do not delete or change this comment! -->", html, 0), pos1 >= 0) )
  {
    find_pos("<hr>", html, pos1);
    if ( find_pos("<h3>Installed extensions:</h3>", html, pos1) == -1 )
    {
      print_warning("no extensions section found in index.html.\n");
    }
    else
    {
      start = find_pos("<h3>Installed extensions:</h3>", html, pos1);
      end = find_pos("</ul>", html, start);
      sprintf(item, "\">%s", ext);
      pos3 = find_pos(item, html, start);
      if ( pos3 == -1 )
      {
        print_warning("extension '%s' not listed in index.html.\n", ext);
      }
      else
      {
        if ( pos3 < end )
          delete_str(pos3, html);
        enda = end - 1;
        pos3a = find_pos("<ul>", html, start);
        if ( pos3a != -1 && enda > pos3a && enda - pos3a <= 1 )
        {
          for ( i = 0; i <= 3; ++i )
            delete_str(pos3a - 1, html);
        }
      }
    }
  }
  else
  {
    print_warning("Unknown format of index.html. Unable to de-register HTML man pages.\n");
  }
}

//----- (0804E7F3) --------------------------------------------------------
void __cdecl register_html(char *pkg_short_name, char *gisbase, int major, int minor, int revision)
{
  int *v5; // eax
  char *v6; // eax
  int *v7; // eax
  char *v8; // eax
  size_t v9; // eax
  FILE *f_out; // [esp+38h] [ebp-1020h]
  FILE *f_in; // [esp+3Ch] [ebp-101Ch]
  int i; // [esp+40h] [ebp-1018h]
  int ia; // [esp+40h] [ebp-1018h]
  int ib; // [esp+40h] [ebp-1018h]
  int ic; // [esp+40h] [ebp-1018h]
  int n_lines; // [esp+44h] [ebp-1014h]
  char **line; // [esp+48h] [ebp-1010h]
  char str[2048]; // [esp+4Ch] [ebp-100Ch] BYREF
  char file[2048]; // [esp+84Ch] [ebp-80Ch] BYREF
  unsigned int v20; // [esp+104Ch] [ebp-Ch]

  v20 = __readgsdword(0x14u);
  sprintf(file, "%s/docs/html/index.html", gisbase);
  f_in = fopen(file, "r");
  if ( f_in )
  {
    memcpy(TMP_HTML, "/tmp/grass.extensions.db.XXXXXX", 0x20u);
    mkstemp(TMP_HTML);
    f_out = fopen(TMP_HTML, "w+");
    if ( !f_out )
    {
      v7 = __errno_location();
      v8 = strerror(*v7);
      print_error(
        -24,
        "could not create temp file '%s': %s\n"
        " \t\tMake sure that directory /tmp exists on your system and you have write permission.\n",
        TMP_HTML,
        v8);
    }
    atexit((void (__cdecl *)(void *))exit_db);
    if ( VERBOSE )
      sprintf(
        str,
        "cp -vf %s %s/docs/html/index.html ; chmod -v a+r %s/docs/html/index.html ;",
        TMP_HTML,
        gisbase,
        gisbase);
    else
      sprintf(
        str,
        "cp -f %s %s/docs/html/index.html &>%s ; chmod a+r %s/docs/html/index.html &>%s ;",
        TMP_HTML,
        gisbase,
        TMP_NULL,
        gisbase,
        TMP_NULL);
    strcpy(HTML_CMD, str);
    n_lines = 0;
    while ( fgets(str, 2048, f_in) )
      ++n_lines;
    if ( n_lines )
    {
      rewind(f_in);
      line = (char **)calloc(n_lines + 10, 4u);
      for ( i = 0; n_lines + 10 > i; ++i )
        line[i] = 0;
      ia = 0;
      while ( fgets(str, 2048, f_in) )
      {
        v9 = strlen(str);
        line[ia] = (char *)malloc(v9 + 1);
        strcpy(line[ia++], str);
      }
      new_ext_html(pkg_short_name, gisbase, line, major, minor, revision);
      for ( ib = 0; line[ib]; ++ib )
        fprintf(f_out, line[ib]);
      fflush(f_out);
      fclose(f_in);
      fclose(f_out);
      for ( ic = 0; n_lines + 10 > ic; ++ic )
        free(line[ic]);
      free(line);
    }
  }
  else if ( *__errno_location() != 2 )
  {
    fclose(0);
    v5 = __errno_location();
    v6 = strerror(*v5);
    print_error(-24, "checking for file '%s': %s\n", file, v6);
  }
}

//----- (0804EC17) --------------------------------------------------------
void __cdecl deregister_html(char *pkg_short_name, char *gisbase)
{
  int *v2; // eax
  char *v3; // eax
  int *v4; // eax
  char *v5; // eax
  size_t v6; // eax
  FILE *f_out; // [esp+38h] [ebp-1020h]
  FILE *f_in; // [esp+3Ch] [ebp-101Ch]
  int i; // [esp+40h] [ebp-1018h]
  int ia; // [esp+40h] [ebp-1018h]
  int ib; // [esp+40h] [ebp-1018h]
  int ic; // [esp+40h] [ebp-1018h]
  int n_lines; // [esp+44h] [ebp-1014h]
  char **line; // [esp+48h] [ebp-1010h]
  char str[2048]; // [esp+4Ch] [ebp-100Ch] BYREF
  char file[2048]; // [esp+84Ch] [ebp-80Ch] BYREF
  unsigned int v17; // [esp+104Ch] [ebp-Ch]

  v17 = __readgsdword(0x14u);
  sprintf(file, "%s/docs/html/index.html", gisbase);
  f_in = fopen(file, "r");
  if ( f_in )
  {
    memcpy(TMP_HTML, "/tmp/grass.extensions.db.XXXXXX", 0x20u);
    mkstemp(TMP_HTML);
    f_out = fopen(TMP_HTML, "w+");
    if ( !f_out )
    {
      v4 = __errno_location();
      v5 = strerror(*v4);
      print_error(
        -24,
        "could not create temp file '%s': %s\n"
        " \t\tMake sure that directory /tmp exists on your system and you have write permission.\n",
        TMP_HTML,
        v5);
    }
    atexit((void (__cdecl *)(void *))exit_db);
    if ( VERBOSE )
      sprintf(
        str,
        "cp -vf %s %s/docs/html/index.html ; chmod -v a+r %s/docs/html/index.html ;",
        TMP_HTML,
        gisbase,
        gisbase);
    else
      sprintf(
        str,
        "cp -f %s %s/docs/html/index.html &>%s ; chmod a+r %s/docs/html/index.html &>%s ;",
        TMP_HTML,
        gisbase,
        TMP_NULL,
        gisbase,
        TMP_NULL);
    strcpy(HTML_CMD, str);
    n_lines = 0;
    while ( fgets(str, 2048, f_in) )
      ++n_lines;
    if ( n_lines )
    {
      rewind(f_in);
      line = (char **)calloc(n_lines + 1, 4u);
      for ( i = 0; n_lines + 1 > i; ++i )
        line[i] = 0;
      ia = 0;
      while ( fgets(str, 2048, f_in) )
      {
        v6 = strlen(str);
        line[ia] = (char *)malloc(v6 + 1);
        strcpy(line[ia++], str);
      }
      delete_ext_html(pkg_short_name, gisbase, line);
      for ( ib = 0; line[ib]; ++ib )
        fprintf(f_out, line[ib]);
      fflush(f_out);
      fclose(f_in);
      fclose(f_out);
      for ( ic = 0; n_lines + 1 > ic; ++ic )
        free(line[ic]);
      free(line);
    }
  }
  else if ( *__errno_location() != 2 )
  {
    fclose(0);
    v2 = __errno_location();
    v3 = strerror(*v2);
    print_error(-24, "checking for file '%s': %s\n", file, v3);
  }
}

//----- (0804F026) --------------------------------------------------------
int __cdecl restore_html(char *gisbase)
{
  int result; // eax
  int *v2; // eax
  char *v3; // eax
  int *v4; // eax
  char *v5; // eax
  size_t v6; // eax
  char *v7; // eax
  int revision; // [esp+30h] [ebp-2848h] BYREF
  int minor; // [esp+34h] [ebp-2844h] BYREF
  int major; // [esp+38h] [ebp-2840h] BYREF
  int n_subdirs; // [esp+3Ch] [ebp-283Ch]
  int num_restored; // [esp+40h] [ebp-2838h]
  dirent *ep; // [esp+44h] [ebp-2834h]
  DIR *subdirp; // [esp+48h] [ebp-2830h]
  DIR *dirp; // [esp+4Ch] [ebp-282Ch]
  FILE *f_ext; // [esp+50h] [ebp-2828h]
  FILE *f_out; // [esp+54h] [ebp-2824h]
  FILE *f_in; // [esp+58h] [ebp-2820h]
  int i; // [esp+5Ch] [ebp-281Ch]
  int n_lines; // [esp+60h] [ebp-2818h]
  int n_entries; // [esp+64h] [ebp-2814h]
  char **line; // [esp+68h] [ebp-2810h]
  char subdir[2048]; // [esp+6Ch] [ebp-280Ch] BYREF
  char dir[2048]; // [esp+86Ch] [ebp-200Ch] BYREF
  char ext_idx[2048]; // [esp+106Ch] [ebp-180Ch] BYREF
  char idx[2048]; // [esp+186Ch] [ebp-100Ch] BYREF
  char str[2048]; // [esp+206Ch] [ebp-80Ch] BYREF
  unsigned int v28; // [esp+286Ch] [ebp-Ch]

  v28 = __readgsdword(0x14u);
  sprintf(idx, "%s/docs/html/index.html", gisbase);
  f_in = fopen(idx, "r");
  if ( f_in )
  {
    memcpy(TMP_HTML, "/tmp/grass.extensions.db.XXXXXX", 0x20u);
    mkstemp(TMP_HTML);
    f_out = fopen(TMP_HTML, "w+");
    if ( !f_out )
    {
      v4 = __errno_location();
      v5 = strerror(*v4);
      print_error(
        -24,
        "could not create temp file '%s': %s\n"
        " \t\tMake sure that directory /tmp exists on your system and you have write permission.\n",
        TMP_HTML,
        v5);
    }
    if ( VERBOSE )
      sprintf(
        str,
        "cp -vf %s %s/docs/html/index.html ; chmod -v a+r %s/docs/html/index.html ;",
        TMP_HTML,
        gisbase,
        gisbase);
    else
      sprintf(
        str,
        "cp -f %s %s/docs/html/index.html &>%s ; chmod a+r %s/docs/html/index.html &>%s ;",
        TMP_HTML,
        gisbase,
        TMP_NULL,
        gisbase,
        TMP_NULL);
    strcpy(HTML_CMD, str);
    atexit((void (__cdecl *)(void *))exit_db);
    sprintf(dir, "%s/docs/extensions", gisbase);
    dirp = opendir(dir);
    if ( dirp )
    {
      n_entries = 0;
      n_subdirs = 0;
      while ( 1 )
      {
        ep = readdir(dirp);
        if ( !ep )
          break;
        sprintf(subdir, "%s/%s", dir, ep->d_name);
        if ( strcmp(ep->d_name, ".") )
        {
          if ( strcmp(ep->d_name, "..") )
          {
            subdirp = opendir(subdir);
            if ( subdirp )
            {
              ++n_subdirs;
              closedir(subdirp);
            }
          }
        }
      }
      closedir(dirp);
      n_lines = 0;
      while ( fgets(str, 2048, f_in) )
        ++n_lines;
      if ( n_lines )
      {
        rewind(f_in);
        line = (char **)calloc(n_lines + n_subdirs + 10, 4u);
        for ( i = 0; n_lines + n_subdirs + 10 > i; ++i )
          line[i] = 0;
        i = 0;
        while ( fgets(str, 2048, f_in) )
        {
          v6 = strlen(str);
          line[i] = (char *)malloc(v6 + 1);
          strcpy(line[i++], str);
        }
        line[i] = 0;
        dirp = opendir(dir);
        num_restored = 0;
        while ( 1 )
        {
          ep = readdir(dirp);
          if ( !ep )
            break;
          sprintf(subdir, "%s/%s", dir, ep->d_name);
          if ( strcmp(ep->d_name, ".") )
          {
            if ( strcmp(ep->d_name, "..") )
            {
              subdirp = opendir(subdir);
              if ( subdirp )
              {
                closedir(subdirp);
                sprintf(ext_idx, "%s/index.html", subdir);
                f_ext = fopen(ext_idx, "r");
                if ( f_ext )
                {
                  major = 0;
                  minor = 0;
                  revision = 0;
                  i = 0;
                  while ( fgets(str, 2048, f_ext) )
                  {
                    if ( strstr(str, "<title>") )
                    {
                      i = 1;
                      break;
                    }
                  }
                  if ( i )
                  {
                    v7 = strchr(str, 40);
                    __isoc99_sscanf(v7 + 1, "%i.%i.%i", &major, &minor, &revision);
                    new_ext_html(ep->d_name, gisbase, line, major, minor, revision);
                    ++num_restored;
                    fclose(f_ext);
                  }
                }
              }
            }
          }
        }
        closedir(dirp);
        for ( i = 0; line[i]; ++i )
          fprintf(f_out, line[i]);
        fflush(f_out);
        fclose(f_in);
        fclose(f_out);
        for ( i = 0; n_lines + n_subdirs + 10 > i; ++i )
          free(line[i]);
        free(line);
        result = num_restored;
      }
      else
      {
        result = 0;
      }
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    if ( *__errno_location() != 2 )
    {
      fclose(f_in);
      v2 = __errno_location();
      v3 = strerror(*v2);
      print_error(-24, "checking for file '%s': %s\n", idx, v3);
    }
    result = 0;
  }
  return result;
}
// 8048B34: using guessed type int __isoc99_sscanf(_DWORD, const char *, ...);

//----- (0804F7E8) --------------------------------------------------------
void __cdecl check_extension(char *package, char *name, int *major, int *minor, int *revision)
{
  int *v5; // eax
  char *v6; // [esp+Ch] [ebp-84Ch]
  FILE *f; // [esp+44h] [ebp-814h]
  FILE *fa; // [esp+44h] [ebp-814h]
  char tmp[2048]; // [esp+4Ch] [ebp-80Ch] BYREF
  unsigned int v10; // [esp+84Ch] [ebp-Ch]

  v10 = __readgsdword(0x14u);
  *(_DWORD *)tmp = 0;
  memset(&tmp[4], 0, 0x7FCu);
  fwrite("Checking extension ...", 1u, 0x16u, stdout);
  strcpy(tmp, package);
  if ( chdir(tmp) < 0 )
  {
    v5 = __errno_location();
    v6 = strerror(*v5);
    print_error(-2, "extension '%s' not accessible: %s\n", package, v6);
  }
  f = fopen("id", "r");
  if ( !f )
    print_error(-6, "'id' file not readable.\n");
  __isoc99_fscanf(f, "%[<GRASS extension package>] ", tmp);
  if ( strcmp("<GRASS extension package>", tmp) )
  {
    fclose(f);
    print_error(-6, "unknown file identifier.\n");
  }
  fclose(f);
  get_package_name(".", name);
  fa = fopen("version", "r");
  if ( !fa )
    print_error(-6, "'version' file not readable.\n");
  nc_fgets_nb(tmp, 2048, fa);
  *minor = 0;
  *revision = 0;
  if ( __isoc99_sscanf(tmp, "%i.%i.%i", major, minor, revision) <= 0 )
  {
    fclose(fa);
    print_error(-6, "invalid or missing version information.\n");
  }
  print_done();
  chdir("..");
  fclose(fa);
}
// 8048AF4: using guessed type int __isoc99_fscanf(_DWORD, const char *, ...);
// 8048B34: using guessed type int __isoc99_sscanf(_DWORD, const char *, ...);

//----- (0804FAAB) --------------------------------------------------------
void __cdecl unpack_extension(char *package)
{
  int *v1; // eax
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  char *v9; // eax
  int ftype; // [esp+30h] [ebp-818h]
  int fd; // [esp+34h] [ebp-814h]
  char tmp[2048]; // [esp+3Ch] [ebp-80Ch] BYREF
  unsigned int v13; // [esp+83Ch] [ebp-Ch]

  v13 = __readgsdword(0x14u);
  fwrite("Uncompressing files...", 1u, 0x16u, stdout);
  memcpy(TMPDIR, "/tmp/grass.extension.XXXXXX", 0x1Cu);
  mkstemp(TMPDIR);
  fd = open(TMPDIR, 64, 511);
  if ( fd == -1 )
  {
    v1 = __errno_location();
    v2 = strerror(*v1);
    print_error(-7, "could not create temp directory name: %s", v2);
  }
  if ( VERBOSE )
    fprintf(stdout, "\nUncompressing to: %s.\n", TMPDIR);
  close(fd);
  remove(TMPDIR);
  mkdir_s(TMPDIR, "0700");
  atexit((void (__cdecl *)(void *))exit_tmp);
  sprintf(tmp, "cp %s %s", package, TMPDIR);
  if ( system(tmp) < 0 )
    print_error(-7, "could not copy extension files to temp dir.\n");
  ftype = check_filetype(package);
  if ( !ftype )
  {
    print_warning("file name not '.tar.gz', '.tgz', '.tar.bz2', '.tbz' or '.zip'. Assuming '.tgz'.\n");
    ftype = 1;
  }
  if ( ftype == 1 )
  {
    if ( VERBOSE )
    {
      v3 = basename(package);
      sprintf(tmp, "tar -xzvf %s/%s -C %s", TMPDIR, v3, TMPDIR);
    }
    else
    {
      v4 = basename(package);
      sprintf(tmp, "tar -xzf %s/%s -C %s", TMPDIR, v4, TMPDIR);
    }
  }
  if ( ftype == 2 )
  {
    v5 = basename(package);
    sprintf(tmp, "tar -xjvf %s/%s -C %s", TMPDIR, v5, TMPDIR);
  }
  if ( ftype == 3 )
  {
    if ( VERBOSE )
    {
      v6 = basename(package);
      sprintf(tmp, "unzip %s/%s -d %s", TMPDIR, v6, TMPDIR);
    }
    else
    {
      v7 = basename(package);
      sprintf(tmp, "unzip -qq %s/%s -d %s", TMPDIR, v7, TMPDIR);
    }
  }
  if ( ftype == 4 )
  {
    if ( VERBOSE )
    {
      v8 = basename(package);
      sprintf(tmp, "tar -xvf %s/%s -C %s", TMPDIR, v8, TMPDIR);
    }
    else
    {
      v9 = basename(package);
      sprintf(tmp, "tar -xf %s/%s -C %s", TMPDIR, v9, TMPDIR);
    }
  }
  if ( system(tmp) < 0 )
  {
    if ( ftype == 1 )
      print_error(
        -7,
        "could not extract files using 'tar' and 'gzip'. \n \t\t\t\t\tExtract manually using 'tar -xzvf %s'.\n",
        package);
    if ( ftype == 2 )
      print_error(
        -7,
        "could not extract files using 'tar' and 'bunzip2'.\n \t\t\t\tExtract manually using 'tar -xjvf %s'.\n",
        package);
    if ( ftype == 3 )
      print_error(-7, "could not extract files using 'unzip'.\n \t\t\t\tExtract manually using 'unzip %s'.\n", package);
    exit(-7);
  }
  print_done();
}

//----- (0804FF43) --------------------------------------------------------
void __cdecl __noreturn query_extension(char *package, char *name, int major, int minor, int revision, char *short_name, char *invocation, char *org_name)
{
  char *v8; // eax
  int *v9; // eax
  char *v10; // [esp+Ch] [ebp-84Ch]
  char tmp[2048]; // [esp+4Ch] [ebp-80Ch] BYREF
  unsigned int v12; // [esp+84Ch] [ebp-Ch]

  v12 = __readgsdword(0x14u);
  v8 = basename(package);
  strcpy(tmp, v8);
  if ( chdir(tmp) < 0 )
  {
    v9 = __errno_location();
    v10 = strerror(*v9);
    print_error(-2, "extension '%s' not accessible: %s\n", package, v10);
  }
  fprintf(stdout, "\nExtension '%s', version %i.%i.%i\n\n", name, major, minor, revision);
  dump_ascii("description", "Description");
  dump_ascii("commands", "Commands provided");
  dump_ascii("libs", "Libraries provided");
  dump_ascii("headers", "Header files provided");
  dump_ascii("depends", "Dependencies");
  dump_ascii("bugs", "Bugs");
  sprintf(tmp, "../%s", package);
  list_binaries(tmp);
  dump_ascii("authors", "Author(s)");
  fprintf(stdout, "Type '%s -d %s' to see more detailed information.\n", invocation, org_name);
  fprintf(stdout, "Type '%s -l %s' to see copyright information.\n", invocation, org_name);
  system("sh post");
  exit(0);
}

//----- (0805014E) --------------------------------------------------------
void print_cfg()
{
  FILE *fp; // [esp+18h] [ebp-810h]
  char line[2048]; // [esp+1Ch] [ebp-80Ch] BYREF
  unsigned int v2; // [esp+81Ch] [ebp-Ch]

  v2 = __readgsdword(0x14u);
  fp = fopen("config.msg", "r");
  if ( fp )
  {
    fwrite("\nResult of configuration: \n", 1u, 0x1Bu, stdout);
    while ( fgets(line, 2048, fp) )
      fputs(line, stdout);
    fputc(10, stdout);
  }
  remove("config.msg");
}

//----- (08050220) --------------------------------------------------------
void __cdecl source_install(char *package, char *gisbase, char *pkg_short_name, int pkg_major, int pkg_minor, int pkg_revision, char *grass_version)
{
  int *v7; // eax
  char *v8; // eax
  char *v9; // eax
  int *v10; // eax
  int *v11; // eax
  char *v12; // eax
  char *v13; // [esp+Ch] [ebp-28BCh]
  stat buf; // [esp+40h] [ebp-2888h] BYREF
  int revision; // [esp+98h] [ebp-2830h]
  int minor; // [esp+9Ch] [ebp-282Ch]
  int major; // [esp+A0h] [ebp-2828h]
  char *grass_revision; // [esp+A4h] [ebp-2824h]
  char *grass_minor; // [esp+A8h] [ebp-2820h]
  char *grass_major; // [esp+ACh] [ebp-281Ch]
  char *verstr; // [esp+B0h] [ebp-2818h]
  FILE *f; // [esp+B4h] [ebp-2814h]
  int error; // [esp+B8h] [ebp-2810h]
  char sysstr[2048]; // [esp+BCh] [ebp-280Ch] BYREF
  char post_cmd[2048]; // [esp+8BCh] [ebp-200Ch] BYREF
  char install_cmd[2048]; // [esp+10BCh] [ebp-180Ch] BYREF
  char dir[2048]; // [esp+18BCh] [ebp-100Ch] BYREF
  char tmp[2048]; // [esp+20BCh] [ebp-80Ch] BYREF
  unsigned int v29; // [esp+28BCh] [ebp-Ch]

  v29 = __readgsdword(0x14u);
  error = stat_0(gisbase, (int)&buf);
  if ( error < 0 )
  {
    v7 = __errno_location();
    v8 = strerror(*v7);
    print_error(-5, "installation directory invalid: %s\n", v8);
  }
  sprintf(GINSTALL_DST, "GINSTALL_DST=%s", gisbase);
  putenv(GINSTALL_DST);
  sprintf(tmp, "%s/include", gisbase);
  sprintf(GINSTALL_INC, "GINSTALL_INC=%s", tmp);
  putenv(GINSTALL_INC);
  sprintf(tmp, "%s/lib", gisbase);
  sprintf(GINSTALL_LIB, "GINSTALL_LIB=%s", tmp);
  putenv(GINSTALL_LIB);
  sprintf(GEM_GRASS_DIR, "GEM_GRASS_DIR=%s", gisbase);
  putenv(GEM_GRASS_DIR);
  verstr = strdup(grass_version);
  grass_major = strtok(verstr, ".");
  grass_minor = strtok(0, ".");
  grass_revision = strtok(0, ".");
  major = strtol(grass_major, 0, 10);
  minor = strtol(grass_minor, 0, 10);
  revision = strtol(grass_revision, 0, 10);
  free(verstr);
  atexit((void (__cdecl *)(void *))exit_tmp);
  v9 = basename(package);
  sprintf(dir, "%s/src", v9);
  error = chdir(dir);
  if ( error < 0 )
  {
    v10 = __errno_location();
    v13 = strerror(*v10);
    print_error(-2, "extension files in '%s' not accessible: %s\n", package, v13);
  }
  if ( !SKIP_CFG )
  {
    if ( VERBOSE )
    {
      fwrite("Running configure script:\n", 1u, 0x1Au, stdout);
      sprintf(sysstr, "sh %s %s", CONFIG_CMD, CONFIG_OPTS);
    }
    else
    {
      fwrite("Configuring...", 1u, 0xEu, stdout);
      sprintf(sysstr, "sh %s %s --quiet &> %s", CONFIG_CMD, CONFIG_OPTS, TMP_NULL);
    }
    error = system(sysstr);
    if ( error == -1 )
      print_error(-27, "could not run configure script.\n");
    if ( error > 0 )
      print_error(-3, "system configuration failed.\n");
    print_done();
    print_cfg();
  }
  sprintf(GEM_EXT_NAME, "GEM_EXT_NAME=%s", pkg_short_name);
  putenv(GEM_EXT_NAME);
  sprintf(tmp, "%i.%i.%i", pkg_major, pkg_minor, pkg_revision);
  sprintf(GEM_EXT_VERSION, "GEM_EXT_VERSION=%s", tmp);
  putenv(GEM_EXT_VERSION);
  dump_html("../description", TMP_DESCR);
  dump_html("../info", TMP_INFO);
  dump_html("../depends", TMP_DEPS);
  dump_html("../bugs", TMP_BUGS);
  dump_html("../authors", TMP_AUTHORS);
  sprintf(GEM_EXT_DESCR, "GEM_EXT_DESCR=%s", TMP_DESCR);
  putenv(GEM_EXT_DESCR);
  sprintf(GEM_EXT_INFO, "GEM_EXT_INFO=%s", TMP_INFO);
  putenv(GEM_EXT_INFO);
  sprintf(GEM_EXT_DEPS, "GEM_EXT_DEPS=%s", TMP_DEPS);
  putenv(GEM_EXT_DEPS);
  sprintf(GEM_EXT_BUGS, "GEM_EXT_BUGS=%s", TMP_BUGS);
  putenv(GEM_EXT_BUGS);
  sprintf(GEM_EXT_AUTHORS, "GEM_EXT_AUTHORS=%s", TMP_AUTHORS);
  putenv(GEM_EXT_AUTHORS);
  atexit((void (__cdecl *)(void *))exit_tmp);
  check_dependencies(package, gisbase, grass_version);
  if ( VERBOSE )
  {
    fprintf(stdout, "Running '%s':\n", MAKE_CMD);
    sprintf(sysstr, "%s -f Makefile", MAKE_CMD);
  }
  else
  {
    fwrite("Compiling...", 1u, 0xCu, stdout);
    sprintf(sysstr, "%s -f Makefile &> %s", MAKE_CMD, TMP_NULL);
  }
  error = system(sysstr);
  if ( error == -1 && !VERBOSE )
    print_error(-9, "could not run '%s' do you have make tools installed?\n", MAKE_CMD);
  if ( error > 0 )
    print_error(
      -4,
      "source code could not be compiled.\n \t\t\tRun again with option -v to see what is causing trouble.\n");
  print_done();
  fwrite("Installing...", 1u, 0xDu, stdout);
  f = fopen("../uninstall", "r");
  if ( f )
  {
    if ( VERBOSE )
      sprintf(tmp, "cp -vf ../uninstall %s/etc/uninstall.%s ;", gisbase, pkg_short_name);
    else
      sprintf(tmp, "cp -f ../uninstall %s/etc/uninstall.%s &> %s ;", gisbase, pkg_short_name, TMP_NULL);
    strcpy(UNINSTALL_CMD, tmp);
    fclose(f);
  }
  else
  {
    v11 = __errno_location();
    v12 = strerror(*v11);
    print_warning(
      "error checking for uninstall script: %s\n"
      " \t\t\t\tUninstalling this extension may leave orphaned files on your system",
      v12);
  }
  register_extension(gisbase, "src", pkg_short_name, pkg_major, pkg_minor, pkg_revision);
  check_dependencies(package, gisbase, grass_version);
  if ( major == 6 && minor <= 0 )
    register_entries_gisman(pkg_short_name, gisbase);
  register_entries_gisman2(pkg_short_name, gisbase);
  register_html(pkg_short_name, gisbase, pkg_major, pkg_minor, pkg_revision);
  if ( VERBOSE )
  {
    fprintf(stdout, "Running '%s install':\n", MAKE_CMD);
    sprintf(
      install_cmd,
      "%s -f Makefile install ; \t\t\t\t\tcp -vf %s %s/etc/extensions.db ; chmod -v a+r %s/etc/extensions.db ;",
      MAKE_CMD,
      TMPDB,
      gisbase,
      gisbase);
  }
  else
  {
    sprintf(
      install_cmd,
      "%s -f Makefile -s install &> %s ; \t\t\t\t\tcp -f %s %s/etc/extensions.db &> %s ; chmod a+r %s/etc/extensions.db &> %s ;",
      MAKE_CMD,
      TMP_NULL,
      TMPDB,
      gisbase,
      TMP_NULL,
      gisbase,
      TMP_NULL);
  }
  if ( VERBOSE )
    memcpy(post_cmd, "sh ../post", 0xBu);
  else
    sprintf(post_cmd, "sh ../post &> %s", TMP_NULL);
  sprintf(tmp, "%s %s %s %s %s %s", install_cmd, UNINSTALL_CMD, GISMAN_CMD, GISMAN2_CMD, HTML_CMD, post_cmd);
  su(gisbase, tmp);
  print_done();
}

//----- (08050C67) --------------------------------------------------------
void __cdecl bin_install(char *package, char *gisbase, char *bins, char *pkg_short_name, int pkg_major, int pkg_minor, int pkg_revision, char *grass_version)
{
  int *v8; // eax
  char *v9; // eax
  char *v10; // eax
  int *v11; // eax
  int *v12; // eax
  char *v13; // eax
  char *v14; // [esp+Ch] [ebp-20CCh]
  stat buf; // [esp+50h] [ebp-2088h] BYREF
  int revision; // [esp+A8h] [ebp-2030h]
  int minor; // [esp+ACh] [ebp-202Ch]
  int major; // [esp+B0h] [ebp-2028h]
  char *grass_revision; // [esp+B4h] [ebp-2024h]
  char *grass_minor; // [esp+B8h] [ebp-2020h]
  char *grass_major; // [esp+BCh] [ebp-201Ch]
  char *verstr; // [esp+C0h] [ebp-2018h]
  FILE *f; // [esp+C4h] [ebp-2014h]
  int error; // [esp+C8h] [ebp-2010h]
  char post_cmd[2048]; // [esp+CCh] [ebp-200Ch] BYREF
  char install_cmd[2048]; // [esp+8CCh] [ebp-180Ch] BYREF
  char dir[2048]; // [esp+10CCh] [ebp-100Ch] BYREF
  char tmp[2048]; // [esp+18CCh] [ebp-80Ch] BYREF
  unsigned int v29; // [esp+20CCh] [ebp-Ch]

  v29 = __readgsdword(0x14u);
  error = stat_0(gisbase, (int)&buf);
  if ( error < 0 )
  {
    v8 = __errno_location();
    v9 = strerror(*v8);
    print_error(-5, "installation directory invalid: %s\n", v9);
  }
  sprintf(GINSTALL_DST, "GINSTALL_DST=%s", gisbase);
  putenv(GINSTALL_DST);
  sprintf(tmp, "%s/include", gisbase);
  sprintf(GINSTALL_INC, "GINSTALL_INC=%s", tmp);
  putenv(GINSTALL_INC);
  sprintf(tmp, "%s/lib", gisbase);
  sprintf(GINSTALL_LIB, "GINSTALL_LIB=%s", tmp);
  putenv(GINSTALL_LIB);
  sprintf(GEM_GRASS_DIR, "GEM_GRASS_DIR=%s", gisbase);
  putenv(GEM_GRASS_DIR);
  verstr = strdup(grass_version);
  grass_major = strtok(verstr, ".");
  grass_minor = strtok(0, ".");
  grass_revision = strtok(0, ".");
  major = strtol(grass_major, 0, 10);
  minor = strtol(grass_minor, 0, 10);
  revision = strtol(grass_revision, 0, 10);
  free(verstr);
  atexit((void (__cdecl *)(void *))exit_tmp);
  v10 = basename(package);
  sprintf(dir, "%s/%s", v10, bins);
  error = chdir(dir);
  if ( error < 0 )
  {
    v11 = __errno_location();
    v14 = strerror(*v11);
    print_error(-2, "extension file binaries in '%s' not accessible: %s\n", package, v14);
  }
  sprintf(GEM_EXT_NAME, "GEM_EXT_NAME=%s", pkg_short_name);
  putenv(GEM_EXT_NAME);
  sprintf(tmp, "%i.%i.%i", pkg_major, pkg_minor, pkg_revision);
  sprintf(GEM_EXT_VERSION, "GEM_EXT_VERSION=%s", tmp);
  putenv(GEM_EXT_VERSION);
  dump_html("../description", TMP_DESCR);
  dump_html("../info", TMP_INFO);
  dump_html("../depends", TMP_DEPS);
  dump_html("../bugs", TMP_BUGS);
  dump_html("../authors", TMP_AUTHORS);
  sprintf(GEM_EXT_DESCR, "GEM_EXT_DESCR=%s", TMP_DESCR);
  putenv(GEM_EXT_DESCR);
  sprintf(GEM_EXT_INFO, "GEM_EXT_INFO=%s", TMP_INFO);
  putenv(GEM_EXT_INFO);
  sprintf(GEM_EXT_DEPS, "GEM_EXT_DEPS=%s", TMP_DEPS);
  putenv(GEM_EXT_DEPS);
  sprintf(GEM_EXT_BUGS, "GEM_EXT_BUGS=%s", TMP_BUGS);
  putenv(GEM_EXT_BUGS);
  sprintf(GEM_EXT_AUTHORS, "GEM_EXT_AUTHORS=%s", TMP_AUTHORS);
  putenv(GEM_EXT_AUTHORS);
  atexit((void (__cdecl *)(void *))exit_tmp);
  check_dependencies(package, gisbase, grass_version);
  fwrite("Installing...", 1u, 0xDu, stdout);
  f = fopen("../uninstall", "r");
  if ( f )
  {
    if ( VERBOSE )
      sprintf(tmp, "cp -vf ../uninstall %s/etc/uninstall.%s ;", gisbase, pkg_short_name);
    else
      sprintf(tmp, "cp -f ../uninstall %s/etc/uninstall.%s &> %s ;", gisbase, pkg_short_name, TMP_NULL);
    strcpy(UNINSTALL_CMD, tmp);
    fclose(f);
  }
  else
  {
    v12 = __errno_location();
    v13 = strerror(*v12);
    print_warning(
      "error checking for uninstall script: %s\n"
      " \t\t\t\tUninstalling this extension may leave orphaned files on your system",
      v13);
  }
  register_extension(gisbase, bins, pkg_short_name, pkg_major, pkg_minor, pkg_revision);
  check_dependencies(package, gisbase, grass_version);
  if ( major == 6 && minor <= 0 )
    register_entries_gisman(pkg_short_name, gisbase);
  register_entries_gisman2(pkg_short_name, gisbase);
  register_html(pkg_short_name, gisbase, pkg_major, pkg_minor, pkg_revision);
  if ( VERBOSE )
  {
    fprintf(stdout, "Running '%s install':\n", MAKE_CMD);
    sprintf(
      install_cmd,
      "bin/%s -f Makefile install ; \t\t\t\t\tcp -vf %s %s/etc/extensions.db ; chmod -v a+r %s/etc/extensions.db ;",
      MAKE_CMD,
      TMPDB,
      gisbase,
      gisbase);
  }
  else
  {
    sprintf(
      install_cmd,
      "bin/%s -f Makefile -s install &> %s ; \t\t\t\t\tcp -f %s %s/etc/extensions.db &> %s ; chmod a+r %s/etc/extensions.db &> %s ;",
      MAKE_CMD,
      TMP_NULL,
      TMPDB,
      gisbase,
      TMP_NULL,
      gisbase,
      TMP_NULL);
  }
  if ( VERBOSE )
    memcpy(post_cmd, "sh ../post", 0xBu);
  else
    sprintf(post_cmd, "sh ../post &> %s", TMP_NULL);
  sprintf(tmp, "%s %s %s %s %s %s", install_cmd, UNINSTALL_CMD, GISMAN_CMD, GISMAN2_CMD, HTML_CMD, post_cmd);
  su(gisbase, tmp);
  print_done();
}

//----- (0805148A) --------------------------------------------------------
void __cdecl test_install(char *package, char *gisbase, char *pkg_short_name, int pkg_major, int pkg_minor, int pkg_revision, char *grass_version)
{
  int *v7; // eax
  char *v8; // eax
  char *v9; // eax
  int *v10; // eax
  int *v11; // eax
  char *v12; // eax
  char *v13; // [esp+Ch] [ebp-18ACh]
  stat buf; // [esp+30h] [ebp-1888h] BYREF
  int revision; // [esp+88h] [ebp-1830h]
  int minor; // [esp+8Ch] [ebp-182Ch]
  int major; // [esp+90h] [ebp-1828h]
  char *grass_revision; // [esp+94h] [ebp-1824h]
  char *grass_minor; // [esp+98h] [ebp-1820h]
  char *grass_major; // [esp+9Ch] [ebp-181Ch]
  char *verstr; // [esp+A0h] [ebp-1818h]
  FILE *f; // [esp+A4h] [ebp-1814h]
  int error; // [esp+A8h] [ebp-1810h]
  char sysstr[2048]; // [esp+ACh] [ebp-180Ch] BYREF
  char dir[2048]; // [esp+8ACh] [ebp-100Ch] BYREF
  char tmp[2048]; // [esp+10ACh] [ebp-80Ch] BYREF
  unsigned int v27; // [esp+18ACh] [ebp-Ch]

  v27 = __readgsdword(0x14u);
  error = stat_0(gisbase, (int)&buf);
  if ( error < 0 )
  {
    v7 = __errno_location();
    v8 = strerror(*v7);
    print_error(-5, "installation directory invalid: %s\n", v8);
  }
  sprintf(GINSTALL_DST, "GINSTALL_DST=%s", gisbase);
  putenv(GINSTALL_DST);
  sprintf(tmp, "%s/include", gisbase);
  sprintf(GINSTALL_INC, "GINSTALL_INC=%s", tmp);
  putenv(GINSTALL_INC);
  sprintf(tmp, "%s/lib", gisbase);
  sprintf(GINSTALL_LIB, "GINSTALL_LIB=%s", tmp);
  putenv(GINSTALL_LIB);
  sprintf(GEM_GRASS_DIR, "GEM_GRASS_DIR=%s", gisbase);
  putenv(GEM_GRASS_DIR);
  verstr = strdup(grass_version);
  grass_major = strtok(verstr, ".");
  grass_minor = strtok(0, ".");
  grass_revision = strtok(0, ".");
  major = strtol(grass_major, 0, 10);
  minor = strtol(grass_minor, 0, 10);
  revision = strtol(grass_revision, 0, 10);
  free(verstr);
  atexit((void (__cdecl *)(void *))exit_tmp);
  v9 = basename(package);
  sprintf(dir, "%s/src", v9);
  error = chdir(dir);
  if ( error < 0 )
  {
    v10 = __errno_location();
    v13 = strerror(*v10);
    print_error(-2, "extension files in '%s' not accessible: %s\n", package, v13);
  }
  if ( !SKIP_CFG )
  {
    if ( VERBOSE )
    {
      fwrite("Running configure script:\n", 1u, 0x1Au, stdout);
      sprintf(sysstr, "sh %s %s", CONFIG_CMD, CONFIG_OPTS);
    }
    else
    {
      fwrite("Configuring...", 1u, 0xEu, stdout);
      sprintf(sysstr, "sh %s %s --quiet &> %s", CONFIG_CMD, CONFIG_OPTS, TMP_NULL);
    }
    error = system(sysstr);
    if ( error == -1 )
      print_error(-27, "could not run configure script.\n");
    if ( error > 0 )
      print_error(-3, "system configuration failed.\n");
    print_done();
    print_cfg();
  }
  sprintf(GEM_EXT_NAME, "GEM_EXT_NAME=%s", pkg_short_name);
  putenv(GEM_EXT_NAME);
  sprintf(tmp, "%i.%i.%i", pkg_major, pkg_minor, pkg_revision);
  sprintf(GEM_EXT_VERSION, "GEM_EXT_VERSION=%s", tmp);
  putenv(GEM_EXT_VERSION);
  dump_plain("../description", TMP_DESCR);
  dump_plain("../info", TMP_INFO);
  dump_plain("../depends", TMP_DEPS);
  dump_plain("../bugs", TMP_BUGS);
  dump_plain("../authors", TMP_AUTHORS);
  sprintf(GEM_EXT_DESCR, "GEM_EXT_DESCR=%s", TMP_DESCR);
  putenv(GEM_EXT_DESCR);
  sprintf(GEM_EXT_INFO, "GEM_EXT_INFO=%s", TMP_INFO);
  putenv(GEM_EXT_INFO);
  sprintf(GEM_EXT_DEPS, "GEM_EXT_DEPS=%s", TMP_DEPS);
  putenv(GEM_EXT_DEPS);
  sprintf(GEM_EXT_BUGS, "GEM_EXT_BUGS=%s", TMP_BUGS);
  putenv(GEM_EXT_BUGS);
  sprintf(GEM_EXT_AUTHORS, "GEM_EXT_AUTHORS=%s", TMP_AUTHORS);
  putenv(GEM_EXT_AUTHORS);
  atexit((void (__cdecl *)(void *))exit_tmp);
  check_dependencies(package, gisbase, grass_version);
  if ( VERBOSE )
  {
    fprintf(stdout, "Running '%s':\n", MAKE_CMD);
    sprintf(sysstr, "%s -f Makefile", MAKE_CMD);
  }
  else
  {
    fwrite("Compiling...", 1u, 0xCu, stdout);
    sprintf(sysstr, "%s -f Makefile &> %s", MAKE_CMD, TMP_NULL);
  }
  error = system(sysstr);
  if ( error == -1 && !VERBOSE )
    print_error(-9, "could not run '%s' do you have make tools installed?\n", MAKE_CMD);
  if ( error > 0 )
    print_error(
      -4,
      "source code could not be compiled.\n \t\t\tRun again with option -v to see what is causing trouble.\n");
  print_done();
  fwrite("Installing...", 1u, 0xDu, stdout);
  f = fopen("../uninstall", "r");
  if ( f )
  {
    fclose(f);
  }
  else
  {
    v11 = __errno_location();
    v12 = strerror(*v11);
    print_warning(
      "error checking for uninstall script: %s\n"
      " \t\t\t\tUninstalling this extension may leave orphaned files on your system",
      v12);
  }
  register_extension(gisbase, "src", pkg_short_name, pkg_major, pkg_minor, pkg_revision);
  check_dependencies(package, gisbase, grass_version);
  if ( major == 6 && minor <= 0 )
    register_entries_gisman(pkg_short_name, gisbase);
  register_entries_gisman2(pkg_short_name, gisbase);
  register_html(pkg_short_name, gisbase, pkg_major, pkg_minor, pkg_revision);
  fprintf(stdout, "(skipping '%s install')...", MAKE_CMD);
  print_done();
}

//----- (08051CF4) --------------------------------------------------------
void __cdecl uninstall(char *package, char *pkg_short_name, char *gisbase, char *grass_version)
{
  int *v4; // eax
  char *v5; // eax
  stat buf; // [esp+60h] [ebp-1088h] BYREF
  int revision; // [esp+B8h] [ebp-1030h]
  int minor; // [esp+BCh] [ebp-102Ch]
  int major; // [esp+C0h] [ebp-1028h]
  char *grass_revision; // [esp+C4h] [ebp-1024h]
  char *grass_minor; // [esp+C8h] [ebp-1020h]
  char *grass_major; // [esp+CCh] [ebp-101Ch]
  char *verstr; // [esp+D0h] [ebp-1018h]
  int no_script; // [esp+D4h] [ebp-1014h]
  int error; // [esp+D8h] [ebp-1010h]
  char script[2048]; // [esp+DCh] [ebp-100Ch] BYREF
  char tmp[2048]; // [esp+8DCh] [ebp-80Ch] BYREF
  unsigned int v18; // [esp+10DCh] [ebp-Ch]

  v18 = __readgsdword(0x14u);
  fwrite("Un-installing...", 1u, 0x10u, stdout);
  sprintf(UNINSTALL_BASE, "UNINSTALL_BASE=%s", gisbase);
  putenv(UNINSTALL_BASE);
  verstr = strdup(grass_version);
  grass_major = strtok(verstr, ".");
  grass_minor = strtok(0, ".");
  grass_revision = strtok(0, ".");
  major = strtol(grass_major, 0, 10);
  minor = strtol(grass_minor, 0, 10);
  revision = strtol(grass_revision, 0, 10);
  free(verstr);
  atexit((void (__cdecl *)(void *))exit_tmp);
  deregister_extension(package, pkg_short_name, gisbase);
  if ( major == 6 && minor <= 0 )
  {
    error = deregister_entries_gisman(pkg_short_name, gisbase);
    if ( error == -1 )
    {
      print_warning("GIS Manager menu entries could not be removed.\n");
      memcpy(GISMAN_CMD, byte_805698C, 1u);
    }
    if ( !error )
    {
      print_warning("no entries found to remove from GIS Manager.\n");
      memcpy(GISMAN_CMD, byte_805698C, 1u);
    }
  }
  deregister_entries_gisman2(pkg_short_name, gisbase);
  deregister_html(pkg_short_name, gisbase);
  sprintf(script, "%s/etc/uninstall.%s", gisbase, pkg_short_name);
  no_script = 0;
  error = stat_0(script, (int)&buf);
  if ( error < 0 )
  {
    print_warning("no uninstall script available for this extension.\n"
                  " \t\t\tUnneeded files may have been left on your system.\n");
    no_script = 1;
  }
  if ( no_script )
  {
    v4 = __errno_location();
    v5 = strerror(*v4);
    print_warning(
      "error checking for uninstall script: %s\n"
      " \t\t\t\tUninstalling this extension may leave orphaned files on your system",
      v5);
  }
  else
  {
    if ( VERBOSE )
      sprintf(
        tmp,
        "sh %s ; rm -vf %s ; \t\t\t\t\t \t\trm -vrf %s/docs/extensions/%s ; rm -vf %s/etc/dm/gem-entries/%s ; \t\t\t\t\t\t"
        "\tcp -vf %s %s/etc/extensions.db ; chmod -v a+r %s/etc/extensions.db ;",
        script,
        script,
        gisbase,
        pkg_short_name,
        gisbase,
        pkg_short_name,
        TMPDB,
        gisbase,
        gisbase);
    else
      sprintf(
        tmp,
        "sh %s &> %s ; rm -vf %s &> %s ; \t\t\t\t\t \t\trm -vrf %s/docs/extensions/%s &> %s ; rm -vf %s/etc/dm/gem-entrie"
        "s/%s &> %s ; \t\t\t\t\t\t\tcp -vf %s %s/etc/extensions.db &> %s ; chmod -v a+r %s/etc/extensions.db &> %s ;",
        script,
        TMP_NULL,
        script,
        TMP_NULL,
        gisbase,
        pkg_short_name,
        TMP_NULL,
        gisbase,
        pkg_short_name,
        TMP_NULL,
        TMPDB,
        gisbase,
        TMP_NULL,
        gisbase,
        TMP_NULL);
    strcpy(UNINSTALL_CMD, tmp);
  }
  sprintf(tmp, "%s %s %s", UNINSTALL_CMD, GISMAN_CMD, HTML_CMD);
  su(gisbase, tmp);
  print_done();
}

//----- (080521A4) --------------------------------------------------------
int __cdecl source_clean(char *package)
{
  char *v1; // eax
  char sysstr[2048]; // [esp+2Ch] [ebp-100Ch] BYREF
  char dir[2048]; // [esp+82Ch] [ebp-80Ch] BYREF
  unsigned int v5; // [esp+102Ch] [ebp-Ch]

  v5 = __readgsdword(0x14u);
  v1 = basename(package);
  sprintf(dir, "%s/src", v1);
  if ( chdir(dir) < 0 )
    print_error(-2, "extension '%s' not accessible: ", package);
  if ( VERBOSE )
  {
    fprintf(stdout, "Running '%s clean':\n", MAKE_CMD);
    sprintf(sysstr, "%s -f Makefile clean", MAKE_CMD);
  }
  else
  {
    fwrite("Cleaning up...", 1u, 0xEu, stdout);
    sprintf(sysstr, "%s -f Makefile -s clean &> %s", MAKE_CMD, TMP_NULL);
  }
  if ( system(sysstr) == -1 )
    print_error(-9, "could not run '%s clean' do you have make tools installed?\n", MAKE_CMD);
  print_done();
  system("sh ../post");
  return 0;
}

//----- (08052334) --------------------------------------------------------
void __cdecl restore(char *gisbase, char *grass_version)
{
  int minor; // [esp+50h] [ebp-828h]
  int major; // [esp+54h] [ebp-824h]
  const char *grass_revision; // [esp+58h] [ebp-820h]
  const char *grass_minor; // [esp+5Ch] [ebp-81Ch]
  const char *grass_major; // [esp+60h] [ebp-818h]
  char *verstr; // [esp+64h] [ebp-814h]
  int num_restored; // [esp+68h] [ebp-810h]
  int num_restoreda; // [esp+68h] [ebp-810h]
  char tmp[2048]; // [esp+6Ch] [ebp-80Ch] BYREF
  unsigned int v11; // [esp+86Ch] [ebp-Ch]

  v11 = __readgsdword(0x14u);
  verstr = strdup(grass_version);
  grass_major = strtok(verstr, ".");
  grass_minor = strtok(0, ".");
  grass_revision = strtok(0, ".");
  major = strtol(grass_major, 0, 10);
  minor = strtol(grass_minor, 0, 10);
  strtol(grass_revision, 0, 10);
  free(verstr);
  fwrite("Restoring...", 1u, 0xCu, stdout);
  if ( major == 6 && minor <= 0 )
  {
    num_restored = restore_entries_gisman(gisbase);
    if ( VERBOSE )
      fprintf(stdout, "\nRestored entries for GIS Manager: %i\n", num_restored);
  }
  num_restoreda = restore_html(gisbase);
  if ( VERBOSE )
    fprintf(stdout, "\nRestored links in index.hml: %i\n", num_restoreda);
  if ( num_restoreda > 0 )
  {
    if ( VERBOSE )
      sprintf(
        tmp,
        "cp -f %s %s/etc/dm/menu.tcl ; chmod a+r %s/etc/dm/menu.tcl ; \t\t\t\t\t\t\tcp -f %s %s/docs/html/index.html ; ch"
        "mod a+r %s/docs/html/index.html",
        TMP_GISMAN,
        gisbase,
        gisbase,
        TMP_HTML,
        gisbase,
        gisbase);
    else
      sprintf(
        tmp,
        "cp -f %s %s/etc/dm/menu.tcl ; chmod a+r %s/etc/dm/menu.tcl &> %s ; \t\t\t\t\t\t\tcp -f %s %s/docs/html/index.htm"
        "l ; chmod a+r %s/docs/html/index.html",
        TMP_GISMAN,
        gisbase,
        gisbase,
        TMP_NULL,
        TMP_HTML,
        gisbase,
        gisbase);
    su(gisbase, tmp);
  }
  if ( !num_restoreda )
    print_error(-26, "could not find anything to restore.\n");
  print_done();
}

//----- (080525FC) --------------------------------------------------------
void __cdecl list_extensions(char *gisbase)
{
  int *v1; // eax
  char *v2; // eax
  FILE *f_in; // [esp+28h] [ebp-810h]
  char file[2048]; // [esp+2Ch] [ebp-80Ch] BYREF
  unsigned int v5; // [esp+82Ch] [ebp-Ch]

  v5 = __readgsdword(0x14u);
  fprintf(stdout, "\nExtensions in '%s' (name, version, type, depends):\n", gisbase);
  sprintf(file, "%s/etc/extensions.db", gisbase);
  f_in = fopen(file, "r");
  if ( !f_in )
  {
    if ( *__errno_location() == 2 )
    {
      fwrite("NONE.\n", 1u, 6u, stderr);
      fclose(0);
      exit(0);
    }
    fclose(0);
    v1 = __errno_location();
    v2 = strerror(*v1);
    print_error(-29, "checking for file '%s': %s\n", file, v2);
  }
  fclose(f_in);
  dump_ascii(file, (char *)byte_805698C);
}

//----- (08052748) --------------------------------------------------------
void __cdecl run_post(char *package, int action, char *bins, char *gisbase)
{
  char *v4; // eax
  char tmp2[2048]; // [esp+2Ch] [ebp-100Ch] BYREF
  char tmp[2048]; // [esp+82Ch] [ebp-80Ch] BYREF
  unsigned int v7; // [esp+102Ch] [ebp-Ch]

  v7 = __readgsdword(0x14u);
  switch ( action )
  {
    case 3:
    case 4:
      memcpy(GEM_ACTION, "GEM_ACTION=INSTALL", 0x13u);
      break;
    case 5:
      memcpy(GEM_ACTION, "GEM_ACTION=QUERY", 0x11u);
      break;
    case 6:
      memcpy(GEM_ACTION, "GEM_ACTION=CLEAN", 0x11u);
      break;
    case 7:
      memcpy(GEM_ACTION, "GEM_ACTION=LICENSE", 0x13u);
      break;
    case 9:
      memcpy(GEM_ACTION, "GEM_ACTION=DETAILS", 0x13u);
      break;
    default:
      break;
  }
  putenv(GEM_ACTION);
  if ( gisbase )
    sprintf(INSTALL_BASE, "INSTALL_BASE=%s", gisbase);
  else
    memcpy(INSTALL_BASE, "INSTALL_BASE=UNDEFINED", 0x17u);
  putenv(INSTALL_BASE);
  getcwd(tmp, 0x800u);
  v4 = basename(package);
  sprintf(tmp2, "%s/%s/src", tmp, v4);
  sprintf(EXT_BASE, "EXT_BASE=%s", tmp2);
  putenv(EXT_BASE);
  if ( bins )
    sprintf(INSTALL_TYPE, "INSTALL_TYPE=%s", bins);
  else
    memcpy(INSTALL_TYPE, "INSTALL_TYPE=src", 0x11u);
  putenv(INSTALL_TYPE);
  sprintf(tmp, "%i", FORCE);
  sprintf(GEM_FORCE, "GEM_FORCE=%s", tmp);
  putenv(GEM_FORCE);
  sprintf(tmp, "%i", VERBOSE);
  sprintf(GEM_VERBOSE, "GEM_VERBOSE=%s", tmp);
  putenv(GEM_VERBOSE);
  memcpy(GEM_GUI, "GEM_GUI=0", 0xAu);
  putenv(GEM_GUI);
  atexit((void (__cdecl *)(void *))exit_tmp);
}

//----- (08052A50) --------------------------------------------------------
void __noreturn show_help()
{
  fwrite("Usage: gem64 [OPTION] [ACTION] [FILE|DIR]\n", 1u, 0x2Au, stdout);
  fwrite("Install a GRASS extension from FILE or DIR.\n", 1u, 0x2Cu, stdout);
  fwrite("Manage (installed) GRASS extension(s).\n", 1u, 0x27u, stdout);
  fwrite("\nPossible ACTIONs are:\n", 1u, 0x17u, stdout);
  fwrite("  -i, --install=EXT\tinstall a GRASS extension\n", 1u, 0x2Eu, stdout);
  fwrite("  -u, --uninstall=EXT\tremove an extension from GRASS\n", 1u, 0x35u, stdout);
  fwrite("  -q, --query=EXT\tdisplay information about extension/list installed\n", 1u, 0x45u, stdout);
  fwrite("  -d, --details=EXT\tdisplay additional details about an extension\n", 1u, 0x42u, stdout);
  fwrite("  -c, --clean=EXT\tclean extension's source code directories\n", 1u, 0x3Cu, stdout);
  fwrite("  -t, --test=EXT\tconfigure and compile extension, but don't install\n", 1u, 0x44u, stdout);
  fwrite("  -l, --license=EXT\tshow copyright information for an extension\n", 1u, 0x40u, stdout);
  fwrite("  -r, --restore\t\trecreate HTML links and GIS Manager entries\n", 1u, 0x3Du, stdout);
  fwrite("  -h, --help\t\tdisplay this help and exit\n", 1u, 0x29u, stdout);
  fwrite("  -V, --version\t\toutput version information and exit\n\n", 1u, 0x36u, stdout);
  fwrite("\nPossible OPTIONs are:\n", 1u, 0x17u, stdout);
  fwrite("  -g, --grass=PATH\tpath to GRASS installation dir\n", 1u, 0x32u, stdout);
  fwrite("  -b, --binary=NAME\tno compilation: use binary files for system NAME\n", 1u, 0x45u, stdout);
  fwrite("  -f, --force\t\tforce action, regardless of dependencies\n", 1u, 0x38u, stdout);
  fwrite("  -v, --verbose\t\tdisplay detailed status information\n", 1u, 0x35u, stdout);
  fwrite("  -s, --skip-config\tskip configure script\n", 1u, 0x2Au, stdout);
  fwrite("  -x, --config-opts=OPTS\tpass OPTS to configure script\n", 1u, 0x37u, stdout);
  fwrite("  -o, --options=OPTS\toptions to pass to the C compiler/linker\n", 1u, 0x3Eu, stdout);
  fwrite("  -C, --config-cmd=CMD\tDefine custom 'configure' command (default=configure)\n", 1u, 0x4Du, stdout);
  fwrite("  -m, --make-cmd=CMD\tDefine custom 'make' command (default=make)\n", 1u, 0x41u, stdout);
  fwrite("\nWhen run from within a GRASS session, locations of libs, header files\n", 1u, 0x47u, stdout);
  fwrite("and installation target dir will be assumed to match those of the active\n", 1u, 0x49u, stdout);
  fwrite("GRASS version. ", 1u, 0xFu, stdout);
  fwrite("Option -g can be used to override these or install extensions\nfrom outside", 1u, 0x4Au, stdout);
  fwrite("of a GRASS session.\n", 1u, 0x14u, stdout);
  fwrite("Per default, extensions will be compiled from source and then installed.\n", 1u, 0x49u, stdout);
  fwrite("If the exension package contains binaries for the user's platform, they can\n", 1u, 0x4Cu, stdout);
  fwrite("be installed instead using the -b option. ", 1u, 0x2Au, stdout);
  fwrite("For installation from source code, a C compiler and make tools are needed.\n", 1u, 0x4Bu, stdout);
  fwrite("\nExample:\n", 1u, 0xAu, stdout);
  fwrite("\tgem64 -b macosx --grass=/usr/local/grass-6.4.0 -i myExtension\n", 1u, 0x3Fu, stdout);
  fwrite("Installs the MacOS X binaries for 'myExtension' in /usr/local/grass-6.4.0.\n", 1u, 0x4Bu, stdout);
  exit(0);
}

//----- (08053002) --------------------------------------------------------
void __cdecl __noreturn show_details(char *package)
{
  char *v1; // eax
  int *v2; // eax
  char *v3; // [esp+Ch] [ebp-82Ch]
  char tmp[2048]; // [esp+2Ch] [ebp-80Ch] BYREF
  unsigned int v5; // [esp+82Ch] [ebp-Ch]

  v5 = __readgsdword(0x14u);
  v1 = basename(package);
  strcpy(tmp, v1);
  if ( chdir(tmp) < 0 )
  {
    v2 = __errno_location();
    v3 = strerror(*v2);
    print_error(-2, "extension '%s' not accessible: (%s)\n", package, v3);
  }
  dump_ascii("info", "Detailed information");
  system("sh post");
  exit(0);
}

//----- (080530B9) --------------------------------------------------------
void __cdecl __noreturn show_license(char *package)
{
  char *v1; // eax
  int *v2; // eax
  char *v3; // [esp+Ch] [ebp-82Ch]
  char tmp[2048]; // [esp+2Ch] [ebp-80Ch] BYREF
  unsigned int v5; // [esp+82Ch] [ebp-Ch]

  v5 = __readgsdword(0x14u);
  v1 = basename(package);
  strcpy(tmp, v1);
  if ( chdir(tmp) < 0 )
  {
    v2 = __errno_location();
    v3 = strerror(*v2);
    print_error(-2, "extension '%s' not accessible: (%s)\n", package, v3);
  }
  dump_ascii("license", "Detailed information");
  system("sh post");
  exit(0);
}

//----- (08053170) --------------------------------------------------------
void __noreturn show_version()
{
  fprintf(stdout, "gem64 (GRASS extensions manager) %.2f\n", (double)1.03);
  fwrite("Written by Benjamin Ducke\n", 1u, 0x1Au, stdout);
  fwrite("\nCopyright (C) 2005 Benjamin Ducke\n", 1u, 0x23u, stdout);
  fwrite("This is free software; see the source for copying conditions.  There is NO\n", 1u, 0x4Bu, stdout);
  fwrite("warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n", 1u, 0x4Cu, stdout);
  exit(0);
}

//----- (08053242) --------------------------------------------------------
void __cdecl get_configure_options(char *gisbase)
{
  FILE *fp; // [esp+28h] [ebp-810h]
  char str[2048]; // [esp+2Ch] [ebp-80Ch] BYREF
  unsigned int v3; // [esp+82Ch] [ebp-Ch]

  v3 = __readgsdword(0x14u);
  if ( !CONFIG_OPTS[0] )
  {
    sprintf(str, "%s/etc/config.system", gisbase);
    fp = fopen(str, "r");
    if ( fp )
    {
      if ( nc_fgets_nb(str, 2048, fp) )
        strcpy(CONFIG_OPTS, str);
    }
    else
    {
      print_warning("could not open %s for read access. Using default configure options.\n", str);
    }
  }
}

//----- (0805331E) --------------------------------------------------------
int __cdecl main(int argc, const char **argv, const char **envp)
{
  size_t v3; // eax
  size_t v4; // eax
  int *v5; // eax
  char *v6; // eax
  int *v7; // eax
  char *v8; // eax
  int result; // eax
  int v10[4]; // [esp+34h] [ebp-392Ch] BYREF
  __int16 v11; // [esp+44h] [ebp-391Ch]
  int v12[4]; // [esp+8Ch] [ebp-38D4h] BYREF
  __int16 v13; // [esp+9Ch] [ebp-38C4h]
  int longind; // [esp+E4h] [ebp-387Ch] BYREF
  int v15; // [esp+E8h] [ebp-3878h]
  struct dirent *v16; // [esp+ECh] [ebp-3874h]
  DIR *v17; // [esp+F0h] [ebp-3870h]
  int v18; // [esp+F4h] [ebp-386Ch]
  int v19; // [esp+F8h] [ebp-3868h]
  int v20; // [esp+FCh] [ebp-3864h]
  int v21; // [esp+100h] [ebp-3860h]
  int i; // [esp+104h] [ebp-385Ch]
  int v23; // [esp+108h] [ebp-3858h]
  int v24; // [esp+10Ch] [ebp-3854h]
  int v25; // [esp+110h] [ebp-3850h]
  int v26; // [esp+114h] [ebp-384Ch]
  FILE *v27; // [esp+118h] [ebp-3848h]
  int revision; // [esp+11Ch] [ebp-3844h] BYREF
  int minor; // [esp+120h] [ebp-3840h] BYREF
  int major; // [esp+124h] [ebp-383Ch] BYREF
  char *v31; // [esp+128h] [ebp-3838h]
  const char *v32; // [esp+12Ch] [ebp-3834h]
  char *v33; // [esp+130h] [ebp-3830h]
  char *v34; // [esp+134h] [ebp-382Ch]
  char *v35; // [esp+138h] [ebp-3828h]
  char *v36; // [esp+13Ch] [ebp-3824h]
  char *v37; // [esp+140h] [ebp-3820h]
  char *v38; // [esp+144h] [ebp-381Ch]
  char *v39; // [esp+148h] [ebp-3818h]
  char v40[2048]; // [esp+14Ch] [ebp-3814h] BYREF
  char dest[2048]; // [esp+94Ch] [ebp-3014h] BYREF
  char name[2048]; // [esp+114Ch] [ebp-2814h] BYREF
  char v43[2048]; // [esp+194Ch] [ebp-2014h] BYREF
  char org_name[2048]; // [esp+214Ch] [ebp-1814h] BYREF
  char haystack[2048]; // [esp+294Ch] [ebp-1014h] BYREF
  char s[2048]; // [esp+314Ch] [ebp-814h] BYREF
  unsigned int v47; // [esp+394Ch] [ebp-14h]

  v47 = __readgsdword(0x14u);
  v18 = 0;
  longind = 0;
  VERBOSE = 0;
  TMPCLEAN = 0;
  TMPDBCLEAN = 0;
  FORCE = 0;
  UPGRADE = 0;
  ERROR = 0;
  WARNINGS = 0;
  SKIP_CFG = 0;
  memcpy(GISMAN_CMD, &unk_8057925, 1u);
  memcpy(GISMAN2_CMD, &unk_8057925, 1u);
  memcpy(QGIS_CMD, &unk_8057925, 1u);
  memcpy(UNINSTALL_CMD, &unk_8057925, 1u);
  memcpy(HTML_CMD, &unk_8057925, 1u);
  memcpy(TMPDIR, &unk_8057925, 1u);
  memcpy(TMPDB, &unk_8057925, 1u);
  memcpy(TMP_GISMAN, &unk_8057925, 1u);
  memcpy(TMP_DESCR, &unk_8057925, 1u);
  memcpy(TMP_INFO, &unk_8057925, 1u);
  memcpy(TMP_DEPS, &unk_8057925, 1u);
  memcpy(TMP_BUGS, &unk_8057925, 1u);
  memcpy(TMP_AUTHORS, &unk_8057925, 1u);
  memcpy(TMP_HTML, &unk_8057925, 1u);
  memcpy(TMP_NULL, &unk_8057925, 1u);
  memcpy(CONFIG_OPTS, &unk_8057925, 1u);
  memcpy(CONFIG_CMD, "configure", 0xAu);
  memcpy(MAKE_CMD, "make", 5u);
  getcwd(CWD, 0x800u);
  fwrite("\x1B[0m", 1u, 4u, stdout);
  v34 = (char *)malloc(0x800u);
  strcpy(dest, *argv);
  setvbuf(stdout, 0, 2, 0);
  if ( argc == 1 )
    show_help();
  atexit((void (__cdecl *)(void *))exit_msg);
  v20 = 0;
  v31 = 0;
  v39 = 0;
  opterr = 0;
  for ( i = getopt_long(argc, (char *const *)argv, ":i:u:q:d:c:C:t:l:m:o:x:rhVg:b:fvs", long_options_3722, &longind);
        ;
        i = getopt_long(argc, (char *const *)argv, ":i:u:q:d:c:t:l:o:x:rhVg:b:fvs", long_options_3722, &longind) )
  {
    if ( i == -1 )
      goto LABEL_65;
    if ( i == 63 )
      print_error(-1, "unknown option or action specified.\n");
    if ( i == 58 )
    {
      if ( optopt == 105
        || optopt == 117
        || optopt == 100
        || optopt == 99
        || optopt == 116
        || optopt == 108
        || optopt == 114 )
      {
        print_error(-1, "missing file or directory name.\n");
      }
      if ( optopt == 103 )
        print_error(-1, "missing path to GRASS 6.\n");
      if ( optopt == 98 )
        print_error(-1, "missing name of binary architecture.\n");
      if ( optopt == 113 )
        break;
    }
    if ( i == 105
      || i == 117
      || i == 113
      || i == 100
      || i == 99
      || i == 116
      || i == 108
      || i == 114
      || i == 104
      || i == 86 )
    {
      ++v20;
      switch ( i )
      {
        case 'V':
          v21 = 2;
          break;
        case 'c':
          v21 = 6;
          break;
        case 'd':
          v21 = 9;
          break;
        case 'h':
          v21 = 1;
          break;
        case 'i':
          if ( v21 != 4 )
            v21 = 3;
          break;
        case 'l':
          v21 = 7;
          break;
        case 'q':
          v21 = 5;
          break;
        case 'r':
          v21 = 11;
          break;
        case 't':
          v21 = 8;
          break;
        case 'u':
          v21 = 10;
          break;
        default:
          break;
      }
      if ( optarg )
      {
        strcpy(haystack, optarg);
        strcpy(org_name, optarg);
      }
    }
    if ( i == 103 )
    {
      v3 = strlen(optarg);
      v39 = (char *)malloc(v3 + 1);
      strcpy(v39, optarg);
    }
    if ( i == 98 )
    {
      v4 = strlen(optarg);
      v31 = (char *)malloc(v4 + 1);
      strcpy(v31, optarg);
      v21 = 4;
    }
    if ( i == 120 )
      strcpy(CONFIG_OPTS, optarg);
    if ( i == 102 )
      FORCE = 1;
    if ( i == 118 )
      VERBOSE = 1;
    if ( i == 115 )
      SKIP_CFG = 1;
    if ( i == 111 )
      strcat(v40, optarg);
    if ( i == 67 )
      strcpy(CONFIG_CMD, optarg);
    if ( i == 109 )
      strcpy(MAKE_CMD, optarg);
  }
  v21 = 12;
  ++v20;
LABEL_65:
  if ( v20 <= 0 )
    print_error(-1, "please specify a valid action.\n");
  if ( v20 > 1 )
    print_error(-1, "please specify only one action.\n");
  sprintf(GEM_C_OPTS, "GEM_C_OPTS=%s", v40);
  putenv(GEM_C_OPTS);
  if ( v21 == 1 )
    show_help();
  if ( v21 == 2 )
    show_version();
  if ( !VERBOSE )
  {
    memcpy(TMP_NULL, "/tmp/grass.extension.log.XXXXXX", 0x20u);
    mkstemp(TMP_NULL);
    v26 = open(TMP_NULL, 64, 511);
    if ( v26 == -1 )
    {
      v5 = __errno_location();
      v6 = strerror(*v5);
      print_error(-30, "could not create temp file: %s", v6);
    }
  }
  if ( v21 == 11 )
  {
    if ( !v39 )
    {
      v39 = getenv("GISBASE");
      if ( !v39 )
        print_error(-1, "GISBASE environment variable not set and path to GRASS not given.\n");
    }
    if ( VERBOSE )
      fprintf(stdout, "Path to GRASS is %s.\n", v39);
    restore(v39, v38);
    exit(0);
  }
  if ( v21 == 12 )
  {
    if ( !v39 )
    {
      v39 = getenv("GISBASE");
      if ( !v39 )
        print_error(-1, "GISBASE environment variable not set and path to GRASS not given.\n");
    }
    if ( VERBOSE )
      fprintf(stdout, "Path to GRASS is %s.\n", v39);
    list_extensions(v39);
    exit(0);
  }
  if ( strstr(haystack, "http://") || strstr(haystack, "ftp://") )
  {
    wget_extension(haystack);
    v33 = (char *)malloc(0x800u);
    strcpy(v33, haystack);
    v32 = strrchr(v33, 47) + 1;
    strcpy(haystack, v32);
    free(v33);
  }
  if ( VERBOSE )
    fprintf(stdout, "Extension location is '%s'.\n", haystack);
  if ( v21 != 10 )
  {
    v19 = stat_0(haystack, (int)v12);
    if ( v19 < 0 )
    {
      v7 = __errno_location();
      v8 = strerror(*v7);
      print_error(-2, "extension FILE or DIR '%s' invalid: %s\n", haystack, v8);
    }
    if ( (v13 & 0xF000) == 0x4000 )
    {
      v18 = 1;
      if ( VERBOSE )
        fwrite("Extension files stored in a directory.\n", 1u, 0x27u, stdout);
    }
    else
    {
      if ( VERBOSE )
        fwrite("Extension files stored in a package file.\n", 1u, 0x2Au, stdout);
      unpack_extension(haystack);
      v17 = opendir(TMPDIR);
      v16 = readdir(v17);
      v15 = 0;
      while ( 1 )
      {
        if ( !v16 )
          goto LABEL_110;
        if ( strcmp(v16->d_name, ".") )
        {
          if ( strcmp(v16->d_name, "..") )
          {
            sprintf(v34, "%s/%s", TMPDIR, v16->d_name);
            stat_0(v34, (int)v10);
            if ( (v11 & 0xF000) == 0x4000 )
              break;
          }
        }
        v16 = readdir(v17);
      }
      v15 = 1;
LABEL_110:
      strcpy(haystack, v34);
      if ( !v15 )
        print_error(-7, "no top-level directory found in extension package.\n");
    }
  }
  if ( v21 == 10 )
    strcpy(name, haystack);
  else
    get_package_name(haystack, name);
  if ( v20 > 0 )
  {
    if ( !v39 )
      v39 = getenv("GISBASE");
    run_post(haystack, v21, v31, v39);
  }
  if ( VERBOSE )
    fprintf(stdout, "Extension will be installed from '%s'\n", haystack);
  if ( v21 != 10 )
    check_extension(haystack, v43, &major, &minor, &revision);
  if ( v21 == 5 )
    query_extension(haystack, v43, major, minor, revision, name, dest, org_name);
  if ( v21 == 9 )
    show_details(haystack);
  if ( v21 == 7 )
    show_license(haystack);
  if ( v21 == 6 )
  {
    source_clean(haystack);
    exit(0);
  }
  if ( !v39 )
  {
    v39 = getenv("GISBASE");
    if ( !v39 )
      print_error(-1, "GISBASE environment variable not set and path to GRASS not given.\n");
  }
  if ( VERBOSE )
    fprintf(stdout, "Path to GRASS is %s.\n", v39);
  v38 = getenv("GRASS_VERSION");
  if ( !v38 )
  {
    sprintf(s, "%s/etc/VERSIONNUMBER", v39);
    v27 = fopen(s, "r");
    if ( !v27 )
      print_error(-11, "Could not read GRASS version. Did you specify the right path?\n");
    v38 = (char *)malloc(0x10u);
    v19 = __isoc99_fscanf(v27, "%s", v38);
    fclose(v27);
    if ( v19 <= 0 )
      print_error(-11, "Could not read GRASS version. Did you specify the right path?\n");
  }
  if ( v38 )
  {
    v34 = strdup(v38);
    v37 = strtok(v34, ".");
    v36 = strtok(0, ".");
    v35 = strtok(0, ".");
    v25 = strtol(v37, 0, 10);
    v24 = strtol(v36, 0, 10);
    v23 = strtol(v35, 0, 10);
    v38 = (char *)malloc(0x800u);
    sprintf(v38, "%i.%i.%i", v25, v24, v23);
    if ( VERBOSE )
      fprintf(stdout, "GRASS version is %s.\n", v38);
    if ( v25 <= 5 )
      print_error(-11, "extensions only work with GRASS version 6 and above.\n");
  }
  sprintf(v40, "-L%s/lib -I/usr/local/grasslib/include/ ", v39);
  if ( v21 == 3 )
  {
    source_install(haystack, v39, name, major, minor, revision, v38);
    exit(0);
  }
  if ( v21 == 10 )
  {
    uninstall(haystack, name, v39, v38);
    exit(0);
  }
  if ( v21 == 8 )
  {
    test_install(haystack, v39, name, major, minor, revision, v38);
    exit(0);
  }
  if ( v21 == 4 )
  {
    if ( binaries_exist(haystack, v31) )
    {
      bin_install(haystack, v39, v31, name, major, minor, revision, v38);
      exit(0);
    }
    print_error(-12, "no binaries for system '%s'\n", v31);
  }
  exit(0);
  return result;
}
// 805331E: variable 'result' is possibly undefined
// 8048AF4: using guessed type int __isoc99_fscanf(_DWORD, const char *, ...);
// 8059240: using guessed type int optopt;
// 8059264: using guessed type int opterr;

//----- (080546E0) --------------------------------------------------------
void _libc_csu_fini(void)
{
  ;
}

//----- (080546F0) --------------------------------------------------------
void _libc_csu_init(void)
{
  init_proc();
}

//----- (08054750) --------------------------------------------------------
int __cdecl atexit(void (__cdecl *lpfunc)(void *))
{
  _DWORD *v1; // eax

  v1 = _dso_handle;
  if ( _dso_handle )
    v1 = (_DWORD *)_dso_handle[0];
  return __cxa_atexit(lpfunc, 0, v1);
}

//----- (08054790) --------------------------------------------------------
int __cdecl stat_0(char *filename, int a2)
{
  return __xstat(3, filename, (struct stat *)a2);
}

//----- (080547D0) --------------------------------------------------------
void (*_do_global_ctors_aux())(void)
{
  void (*result)(void); // eax
  void (**v1)(void); // ebx

  result = (void (*)(void))_CTOR_LIST__;
  if ( _CTOR_LIST__ != -1 )
  {
    v1 = (void (**)(void))&_CTOR_LIST__;
    do
    {
      --v1;
      result();
      result = *v1;
    }
    while ( *v1 != (void (*)(void))-1 );
  }
  return result;
}
// 8058F10: using guessed type int _CTOR_LIST__;

//----- (080547FC) --------------------------------------------------------
void term_proc()
{
  _do_global_dtors_aux();
}

// nfuncs=180 queued=75 decompiled=75 lumina nreq=0 worse=0 better=0
// ALL OK, 75 function(s) have been successfully decompiled
