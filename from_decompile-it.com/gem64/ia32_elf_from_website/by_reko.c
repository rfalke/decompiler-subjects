// subject_bss_0000.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 optopt = 269165696; // 08059240
FILE * stderr = &g_t100B2488; // 08059244
FILE * stdout = &g_t100B24C0; // 08059260
word32 opterr = 269165768; // 08059264
char * optarg = &g_str100B2500; // 08059280
byte g_b8059284 = 0x00; // 08059284
uint32 dtor_idx.7067 = 0x00; // 08059288
Eq_2139 next.4089 = // 0805928C
	{
		0
	};
word32 menu_created = 0x00; // 08059290
void g_v805F2A0 = ??void??; // 0805F2A0
void g_v805FAA0 = ??void??; // 0805FAA0
void g_v80602A0 = ??void??; // 080602A0
void g_v8061AA0 = ??void??; // 08061AA0
int32 VERBOSE = 0; // 080632A0
byte g_b80632C0 = 0x00; // 080632C0
byte g_b8063AC0 = 0x00; // 08063AC0
byte g_b80642C0 = 0x00; // 080642C0
byte g_b8064AC0 = 0x00; // 08064AC0
byte g_b80652C0 = 0x00; // 080652C0
byte g_b8065AC0 = 0x00; // 08065AC0
byte g_b80662C0 = 0x00; // 080662C0
byte g_b8066AC0 = 0x00; // 08066AC0
byte g_b80672C0 = 0x00; // 080672C0
byte g_b8067AC0 = 0x00; // 08067AC0
word32 TMPCLEAN = 0x00; // 080682C0
word32 TMPDBCLEAN = 0x00; // 080682C4
int32 FORCE = 0; // 080682C8
word32 UPGRADE = 0x00; // 080682CC
word32 SKIP_CFG = 0x00; // 080682D0
char g_b80682E0 = '\0'; // 080682E0
char g_b8068AE0 = '\0'; // 08068AE0
// subject_bss_0001.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

char g_b80692E0 = '\0'; // 080692E0
void g_v8069AE0 = ??void??; // 08069AE0
char g_b806A2E0 = '\0'; // 0806A2E0
byte g_b806AAE0 = 0x00; // 0806AAE0
char g_b806B2E0 = '\0'; // 0806B2E0
char g_b806BAE0 = '\0'; // 0806BAE0
char g_b806C2E0 = '\0'; // 0806C2E0
int32 ERROR = 0; // 0806CAE0
int32 WARNINGS = 0; // 0806CAE4
// subject_ctors.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * g_ptr8058F10 = &g_tFFFFFFFF; // 08058F10
// subject_data.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

Eq_11444 g_t80590E4 = // 080590E4
	{
		null,
	};
Eq_10521 g_t8059100 = // 08059100
	{
	};
// subject_dtors.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * g_a8058F18[] = // 08058F18
	{
	};
// subject_fini.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 080547FC: void _fini()
void _fini()
{
	__do_global_dtors_aux();
}

// subject_got.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 g_dw8058FEC = 0x00; // 08058FEC
struct Eq_11444 * g_ptr8058FF0 = &g_t80590E4; // 08058FF0
// subject_init.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 08048A44: void _init()
// Called from:
//      __libc_csu_init
void _init()
{
	if (g_dw8058FEC != 0x00)
		__gmon_start__();
	frame_dummy();
	__do_global_ctors_aux();
}

// subject_jcr.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 g_dw8058F20 = 0x00; // 08058F20
// subject_plt.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 08048A84: void fputs()
void fputs()
{
}

// 08048A94: void __errno_location()
void __errno_location()
{
}

// 08048AA4: void sprintf()
void sprintf()
{
}

// 08048AB4: void srand()
void srand()
{
}

// 08048AC4: void open()
void open()
{
}

// 08048AD4: void strerror()
void strerror()
{
}

// 08048AE4: void __cxa_atexit()
void __cxa_atexit()
{
}

// 08048AF4: void __isoc99_fscanf()
void __isoc99_fscanf()
{
}

// 08048B04: void __xstat()
void __xstat()
{
}

// 08048B14: void __gmon_start__()
void __gmon_start__()
{
}

// 08048B24: void rewind()
void rewind()
{
}

// 08048B34: void __isoc99_sscanf()
void __isoc99_sscanf()
{
}

// 08048B44: void vsprintf()
void vsprintf()
{
}

// 08048B54: void strchr()
void strchr()
{
}

// 08048B64: void getenv()
void getenv()
{
}

// 08048B74: void calloc()
void calloc()
{
}

// 08048B84: void system()
void system()
{
}

// 08048B94: void strncpy()
void strncpy()
{
}

// 08048BA4: void fgets()
void fgets()
{
}

// 08048BB4: void __libc_start_main()
void __libc_start_main()
{
}

// 08048BC4: void strrchr()
void strrchr()
{
}

// 08048BD4: void readdir()
void readdir()
{
}

// 08048BE4: void strtol()
void strtol()
{
}

// 08048BF4: void free()
void free()
{
}

// 08048C04: void fflush()
void fflush()
{
}

// 08048C14: void mkstemp()
void mkstemp()
{
}

// 08048C24: void opendir()
void opendir()
{
}

// 08048C34: void getopt_long()
void getopt_long()
{
}

// 08048C44: void fclose()
void fclose()
{
}

// 08048C54: void memcpy()
void memcpy()
{
}

// 08048C64: void strlen()
void strlen()
{
}

// 08048C74: void fopen()
void fopen()
{
}

// 08048C84: void strcpy()
void strcpy()
{
}

// 08048C94: void chdir()
void chdir()
{
}

// 08048CA4: void putenv()
void putenv()
{
}

// 08048CB4: void closedir()
void closedir()
{
}

// 08048CC4: void close()
void close()
{
}

// 08048CD4: void fwrite()
void fwrite()
{
}

// 08048CE4: void fprintf()
void fprintf()
{
}

// 08048CF4: void strstr()
void strstr()
{
}

// 08048D04: void setvbuf()
void setvbuf()
{
}

// 08048D14: void remove()
void remove()
{
}

// 08048D24: void malloc()
void malloc()
{
}

// 08048D34: void __stack_chk_fail()
void __stack_chk_fail()
{
}

// 08048D44: void fputc()
void fputc()
{
}

// 08048D54: void strtok()
void strtok()
{
}

// 08048D64: void strcat()
void strcat()
{
}

// 08048D74: void getcwd()
void getcwd()
{
}

// 08048D84: void rand()
void rand()
{
}

// 08048D94: void strdup()
void strdup()
{
}

// 08048DA4: void strcmp()
void strcmp()
{
}

// 08048DB4: void exit()
void exit()
{
}

// subject_rodata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 _fp_hw = 0x03; // 08054818
word32 _IO_stdin_used = 0x00020001; // 0805481C
char g_str8054820[] = "rm -rf %s/*"; // 08054820
void g_v805482C = ??void??; // 0805482C
char g_str8054852[] = "rmdir %s"; // 08054852
void g_v80548A0 = ??void??; // 080548A0
char g_str80548C9[] = "rm -rf %s"; // 080548C9
char g_str8054911[] = "rm -f %s"; // 08054911
char g_str805491C[] = "Program exited with an error (code %i). Operation aborted.\n"; // 0805491C
void g_v8054958 = ??void??; // 08054958
char g_str805498C[] = "Job done but there were %i warnings. Please check.\n"; // 0805498C
char g_str80549C0[] = "\x1B[1;31m\nERROR:\x1B[0m %s"; // 080549C0
char g_str80549D6[] = "\x1B[0;33m\nWARNING:\x1B[0m %s"; // 080549D6
void g_v80549EE = ??void??; // 080549EE
char g_str8054A00[] = "/"; // 08054A00
char g_str8054A02[] = "mkdir %s --mode=%s -p"; // 08054A02
char g_str8054A5D[] = "%i: %s"; // 08054A5D
char g_str8054A64[] = "%s/%s"; // 08054A64
char g_str8054A6A[] = "name"; // 08054A6A
char g_str8054A6F[] = "r"; // 08054A6F
char g_str8054AB0[] = "#"; // 08054AB0
char g_str8054AB2[] = "%s\n"; // 08054AB2
char g_str8054AB6[] = "<br>"; // 08054AB6
char g_str8054ABB[] = "<BR>"; // 08054ABB
char g_str8054AC0[] = "<p>"; // 08054AC0
char g_str8054AC4[] = "<P>"; // 08054AC4
void g_v8054AC8 = ??void??; // 08054AC8
char g_str8054AE5[] = "  %s"; // 08054AE5
void g_v8054AEC = ??void??; // 08054AEC
char g_str8054B0C[] = "w+"; // 08054B0C
void g_v8054B8B = ??void??; // 08054B8B
char g_str8054B90[] = "%s <br>\n"; // 08054B90
void g_v8054B99 = ??void??; // 08054B99
void g_v8054BB4 = ??void??; // 08054BB4
char g_str8054BBE[] = "."; // 08054BBE
char g_str8054BC0[] = ".."; // 08054BC0
char g_str8054BC3[] = "src"; // 08054BC3
char g_str8054BC7[] = ", %s"; // 08054BC7
void g_v8054BCC = ??void??; // 08054BCC
void g_v8054BD4 = ??void??; // 08054BD4
char g_str8054BD7[] = ".tar.gz"; // 08054BD7
char g_str8054BDF[] = ".tgz"; // 08054BDF
char g_str8054BE4[] = ".tar.bz2"; // 08054BE4
char g_str8054BED[] = ".tbz"; // 08054BED
char g_str8054BF2[] = ".zip"; // 08054BF2
char g_str8054BF7[] = ".tar"; // 08054BF7
void g_v8054BFC = ??void??; // 08054BFC
char g_str8054C0B[] = "wget -N %s"; // 08054C0B
char g_str8054C16[] = "wget -N -q %s"; // 08054C16
char g_str8054C79[] = "%s/gem.test.%i"; // 08054C79
char g_str8054D08[] = "../depends"; // 08054D08
char g_str8054D13[] = "r"; // 08054D13
char g_str8054D32[] = "%s"; // 08054D32
char g_str8054D35[] = "GRASS"; // 08054D35
char g_str8054D3B[] = "\t"; // 08054D3B
char g_str8054D3D[] = ","; // 08054D3D
char g_str8054D3F[] = "%s/etc/extensions.db"; // 08054D3F
void g_v8054D54 = ??void??; // 08054D54
char g_str8054D74[] = "w+"; // 08054D74
char g_str8054DF8[] = "%s\t%i.%i.%i\t%s\t%s"; // 08054DF8
char g_str8054F2C[] = "%s\t%i.%i.%i\t%s\t%s\n"; // 08054F2C
char g_str80550D5[] = "\n%s/depends ENOENT\n"; // 080550D5
char g_str80550E9[] = "%s\t%i.%i.%i"; // 080550E9
char g_str80550F5[] = "%i.%i.%i"; // 080550F5
char g_str80551E8[] = "\"&Xtns\" all options 1"; // 080551E8
char g_str80551FE[] = "\"&Help\" all options"; // 080551FE
char g_str8055212[] = "}]"; // 08055212
Eq_649 g_t8055232 = // 08055232
	{
		' '
	};
Eq_649 g_t805524C = // 0805524C
	{
		' '
	};
char g_str8055250[] = "\"&Xtns\" all options"; // 08055250
char g_str8055264[] = "\" all options"; // 08055264
char g_str80552AD[] = "{cascad \"%s\""; // 080552AD
char g_str80552ED[] = "{cascad "; // 080552ED
char g_str80552F6[] = " \t\t\t%s {} \"\" 1 {\n"; // 080552F6
Eq_649 g_t8055308 = // 08055308
	{
		' '
	};
char g_str8055310[] = "#(DO_NOT_REMOVE_THIS_COMMENT) <%s> %s {} \"\" 1 {\n"; // 08055310
char g_str8055341[] = ";"; // 08055341
char g_str805539C[] = "-"; // 0805539C
void g_v805539E = ??void??; // 0805539E
char g_str80553B0[] = " \t\t\t {command \"%s\" {} \"%s\" {} -command {%s }}\n"; // 080553B0
void g_v80553DF = ??void??; // 080553DF
char g_str80553F1[] = "r"; // 080553F1
char g_str805540F[] = "%s/etc/dm/menu.tcl"; // 0805540F
void g_v8055424 = ??void??; // 08055424
char g_str8055444[] = "w+"; // 08055444
char g_str80554C4[] = "mkdir --verbose %s/etc/dm/gem-entries ; cp -vf ../entries-gisman %s/etc/dm/gem-entries/%s ; \t\t\t\t\tcp -vf %s/etc/dm/menu.tcl %s/etc/dm/menu.tcl.gem.bak ; \t\t\t\t\tcp -vf %s %s/etc/dm/menu.tcl ; chmod -v a+r %s/etc/dm/menu.tcl ;"; // 080554C4
char g_str80555A4[] = "mkdir %s/etc/dm/gem-entries &> %s ; cp -f ../entries-gisman %s/etc/dm/gem-entries/%s &> %s ; \t\t\t\t\tcp -f %s/etc/dm/menu.tcl %s/etc/dm/menu.tcl.gem.bak &> %s ; \t\t\t\t\tcp -f %s %s/etc/dm/menu.tcl &> %s ; chmod a+r %s/etc/dm/menu.tcl &> %s ;"; // 080555A4
void g_v8055722 = ??void??; // 08055722
void g_v8055723 = ??void??; // 08055723
char g_str8055738[] = "mkdir --verbose -p %s/etc/gm/Xtns ; cp -fv ../entries-gisman2 %s/etc/gm/Xtns/%s.gem ; "; // 08055738
char g_str8055790[] = "mkdir -p %s/etc/gm/Xtns ; cp -f ../entries-gisman2 %s/etc/gm/Xtns/%s.gem ; "; // 08055790
char g_str80557DC[] = "cp -vf %s/etc/dm/menu.tcl %s/etc/dm/menu.tcl.gem.bak ; \t\t\t\t\t\tcp -vf %s %s/etc/dm/menu.tcl ; chmod -v a+r %s/etc/dm/menu.tcl ;"; // 080557DC
char g_str805585C[] = "cp -f %s/etc/dm/menu.tcl %s/etc/dm/menu.tcl.gem.bak &> %s ; \t\t\t\t\t\tcp -f %s %s/etc/dm/menu.tcl &> %s ; chmod a+r %s/etc/dm/menu.tcl &> %s ;"; // 0805585C
char g_str80558E8[] = "#(DO_NOT_REMOVE_THIS_COMMENT) <%s> {cascad"; // 080558E8
char g_str805599A[] = " \t\t\t}}"; // 0805599A
char g_str80559DD[] = "%s/etc/gm/Xtns/%s.gem"; // 080559DD
char g_str80559F4[] = "rm -vf %s/etc/gm/Xtns/%s.gem ; "; // 080559F4
char g_str8055A14[] = "rm -f %s/etc/gm/Xtns/%s.gem ; "; // 08055A14
char g_str8055A33[] = "%s/etc/dm/gem-entries"; // 08055A33
char g_str8055A49[] = "%s/%s"; // 08055A49
char g_str8055A4F[] = "."; // 08055A4F
char g_str8055A51[] = ".."; // 08055A51
char g_str8055A54[] = "<b>Drivers sections:</b>"; // 08055A54
char g_str8055A70[] = "<!-- GEM Extensions StartHTML. Do not delete or change this comment! -->"; // 08055A70
char g_str8055AFE[] = "<hr>"; // 08055AFE
char g_str8055B04[] = "<h3>Installed extensions:</h3>"; // 08055B04
Eq_649 g_t8055B24 = // 08055B24
	{
		'<'
	};
Eq_649 g_t8055B44 = // 08055B44
	{
		'<'
	};
Eq_649 g_t8055B4A = // 08055B4A
	{
		'<'
	};
Eq_649 g_t8055B51 = // 08055B51
	{
		'<'
	};
char g_str8055B56[] = "</ul>"; // 08055B56
char g_str8055B5C[] = "\">%s"; // 08055B5C
char g_str8055B8C[] = "<li><a href=\"../extensions/%s/index.html\">%s (%i.%i.%i)</a>\n"; // 08055B8C
char g_str8055BC9[] = "<li><a href="; // 08055BC9
char g_str8055C76[] = "<ul>"; // 08055C76
char g_str8055C7B[] = "%s/docs/html/index.html"; // 08055C7B
char g_str8055C93[] = "r"; // 08055C93
void g_v8055CB4 = ??void??; // 08055CB4
char g_str8055CD4[] = "w+"; // 08055CD4
char g_str8055D54[] = "cp -vf %s %s/docs/html/index.html ; chmod -v a+r %s/docs/html/index.html ;"; // 08055D54
char g_str8055DA0[] = "cp -f %s %s/docs/html/index.html &>%s ; chmod a+r %s/docs/html/index.html &>%s ;"; // 08055DA0
char g_str8055DF1[] = "%s/docs/extensions"; // 08055DF1
char g_str8055E04[] = "%s/%s"; // 08055E04
char g_str8055E0A[] = "."; // 08055E0A
char g_str8055E0C[] = ".."; // 08055E0C
char g_str8055E0F[] = "%s/index.html"; // 08055E0F
char g_str8055E1D[] = "<title>"; // 08055E1D
char g_str8055E25[] = "%i.%i.%i"; // 08055E25
void g_v8055E30 = ??void??; // 08055E30
char g_str8055E6B[] = "r"; // 08055E6B
char g_str8055E6D[] = "id"; // 08055E6D
char g_str8055EA7[] = "<GRASS extension package>"; // 08055EA7
char g_str8055EDB[] = "."; // 08055EDB
char g_str8055EDD[] = "version"; // 08055EDD
char g_str8055F03[] = "%i.%i.%i"; // 08055F03
void g_v8055F38 = ??void??; // 08055F38
void g_v8055F4F = ??void??; // 08055F4F
char g_str8055F95[] = "\nUncompressing to: %s.\n"; // 08055F95
char g_str8055FAD[] = "0700"; // 08055FAD
char g_str8055FB2[] = "cp %s %s"; // 08055FB2
char g_str805603D[] = "tar -xzvf %s/%s -C %s"; // 0805603D
char g_str8056053[] = "tar -xzf %s/%s -C %s"; // 08056053
char g_str8056068[] = "tar -xjvf %s/%s -C %s"; // 08056068
char g_str805607E[] = "unzip %s/%s -d %s"; // 0805607E
char g_str8056090[] = "unzip -qq %s/%s -d %s"; // 08056090
char g_str80560A6[] = "tar -xvf %s/%s -C %s"; // 080560A6
char g_str80560BB[] = "tar -xf %s/%s -C %s"; // 080560BB
char g_str80561E0[] = "\nExtension '%s', version %i.%i.%i\n\n"; // 080561E0
char g_str8056204[] = "Description"; // 08056204
char g_str8056210[] = "description"; // 08056210
char g_str805621C[] = "Commands provided"; // 0805621C
char g_str805622E[] = "commands"; // 0805622E
char g_str8056237[] = "Libraries provided"; // 08056237
char g_str805624A[] = "libs"; // 0805624A
char g_str805624F[] = "Header files provided"; // 0805624F
char g_str8056265[] = "headers"; // 08056265
char g_str805626D[] = "Dependencies"; // 0805626D
char g_str805627A[] = "depends"; // 0805627A
char g_str8056282[] = "Bugs"; // 08056282
char g_str8056287[] = "bugs"; // 08056287
char g_str805628C[] = "../%s"; // 0805628C
char g_str8056292[] = "Author(s)"; // 08056292
char g_str805629C[] = "authors"; // 0805629C
char g_str80562A4[] = "Type '%s -d %s' to see more detailed information.\n"; // 080562A4
char g_str80562D8[] = "Type '%s -l %s' to see copyright information.\n"; // 080562D8
char g_str8056307[] = "sh post"; // 08056307
char g_str805630F[] = "config.msg"; // 0805630F
void g_v805631A = ??void??; // 0805631A
char g_str805635C[] = "GINSTALL_DST=%s"; // 0805635C
char g_str805636C[] = "%s/include"; // 0805636C
char g_str8056377[] = "GINSTALL_INC=%s"; // 08056377
char g_str8056387[] = "%s/lib"; // 08056387
char g_str805638E[] = "GINSTALL_LIB=%s"; // 0805638E
char g_str805639E[] = "GEM_GRASS_DIR=%s"; // 0805639E
char g_str80563AF[] = "%s/src"; // 080563AF
void g_v80563E4 = ??void??; // 080563E4
char g_str80563FF[] = "sh %s %s"; // 080563FF
void g_v8056408 = ??void??; // 08056408
char g_str8056417[] = "sh %s %s --quiet &> %s"; // 08056417
char g_str805646F[] = "GEM_EXT_NAME=%s"; // 0805646F
char g_str805647F[] = "GEM_EXT_VERSION=%s"; // 0805647F
char g_str8056492[] = "../description"; // 08056492
char g_str80564A1[] = "../info"; // 080564A1
char g_str80564A9[] = "../depends"; // 080564A9
char g_str80564B4[] = "../bugs"; // 080564B4
char g_str80564BC[] = "../authors"; // 080564BC
char g_str80564C7[] = "GEM_EXT_DESCR=%s"; // 080564C7
char g_str80564D8[] = "GEM_EXT_INFO=%s"; // 080564D8
char g_str80564E8[] = "GEM_EXT_DEPS=%s"; // 080564E8
char g_str80564F8[] = "GEM_EXT_BUGS=%s"; // 080564F8
char g_str8056508[] = "GEM_EXT_AUTHORS=%s"; // 08056508
char g_str805651B[] = "Running '%s':\n"; // 0805651B
char g_str805652A[] = "%s -f Makefile"; // 0805652A
void g_v8056539 = ??void??; // 08056539
char g_str8056546[] = "%s -f Makefile &> %s"; // 08056546
void g_v80565F5 = ??void??; // 080565F5
char g_str8056603[] = "../uninstall"; // 08056603
char g_str8056684[] = "cp -vf ../uninstall %s/etc/uninstall.%s ;"; // 08056684
char g_str80566B0[] = "cp -f ../uninstall %s/etc/uninstall.%s &> %s ;"; // 080566B0
char g_str80566DF[] = "src"; // 080566DF
char g_str80566E3[] = "Running '%s install':\n"; // 080566E3
char g_str80566FC[] = "%s -f Makefile install ; \t\t\t\t\tcp -vf %s %s/etc/extensions.db ; chmod -v a+r %s/etc/extensions.db ;"; // 080566FC
char g_str8056760[] = "%s -f Makefile -s install &> %s ; \t\t\t\t\tcp -f %s %s/etc/extensions.db &> %s ; chmod a+r %s/etc/extensions.db &> %s ;"; // 08056760
char g_str80567D4[] = "sh ../post"; // 080567D4
char g_str80567DF[] = "sh ../post &> %s"; // 080567DF
char g_str80567F0[] = "%s %s %s %s %s %s"; // 080567F0
char g_str8056802[] = "%s/%s"; // 08056802
char g_str805683C[] = "bin/%s -f Makefile install ; \t\t\t\t\tcp -vf %s %s/etc/extensions.db ; chmod -v a+r %s/etc/extensions.db ;"; // 0805683C
char g_str80568A4[] = "bin/%s -f Makefile -s install &> %s ; \t\t\t\t\tcp -f %s %s/etc/extensions.db &> %s ; chmod a+r %s/etc/extensions.db &> %s ;"; // 080568A4
char g_str805691C[] = "(skipping '%s install')..."; // 0805691C
void g_v8056937 = ??void??; // 08056937
char g_str8056948[] = "UNINSTALL_BASE=%s"; // 08056948
char g_str805698C[] = ""; // 0805698C
char g_str80569BE[] = "%s/etc/uninstall.%s"; // 080569BE
char g_str8056A40[] = "sh %s ; rm -vf %s ; \t\t\t\t\t \t\trm -vrf %s/docs/extensions/%s ; rm -vf %s/etc/dm/gem-entries/%s ; \t\t\t\t\t\t\tcp -vf %s %s/etc/extensions.db ; chmod -v a+r %s/etc/extensions.db ;"; // 08056A40
char g_str8056AEC[] = "sh %s &> %s ; rm -vf %s &> %s ; \t\t\t\t\t \t\trm -vrf %s/docs/extensions/%s &> %s ; rm -vf %s/etc/dm/gem-entries/%s &> %s ; \t\t\t\t\t\t\tcp -vf %s %s/etc/extensions.db &> %s ; chmod -v a+r %s/etc/extensions.db &> %s ;"; // 08056AEC
char g_str8056BBA[] = "%s %s %s"; // 08056BBA
char g_str8056BE4[] = "Running '%s clean':\n"; // 08056BE4
char g_str8056BF9[] = "%s -f Makefile clean"; // 08056BF9
void g_v8056C0E = ??void??; // 08056C0E
char g_str8056C1D[] = "%s -f Makefile -s clean &> %s"; // 08056C1D
void g_v8056C78 = ??void??; // 08056C78
char g_str8056C88[] = "\nRestored entries for GIS Manager: %i\n"; // 08056C88
char g_str8056CB0[] = "\nRestored links in index.hml: %i\n"; // 08056CB0
char g_str8056CD4[] = "cp -f %s %s/etc/dm/menu.tcl ; chmod a+r %s/etc/dm/menu.tcl ; \t\t\t\t\t\t\tcp -f %s %s/docs/html/index.html ; chmod a+r %s/docs/html/index.html"; // 08056CD4
char g_str8056D60[] = "cp -f %s %s/etc/dm/menu.tcl ; chmod a+r %s/etc/dm/menu.tcl &> %s ; \t\t\t\t\t\t\tcp -f %s %s/docs/html/index.html ; chmod a+r %s/docs/html/index.html"; // 08056D60
char g_str8056E18[] = "\nExtensions in '%s' (name, version, type, depends):\n"; // 08056E18
char g_str8056E4D[] = "%s/etc/extensions.db"; // 08056E4D
void g_v8056E62 = ??void??; // 08056E62
void g_v8056E85 = ??void??; // 08056E85
void g_v8056E98 = ??void??; // 08056E98
void g_v8056EA9 = ??void??; // 08056EA9
void g_v8056EBA = ??void??; // 08056EBA
void g_v8056ECD = ??void??; // 08056ECD
char g_str8056EE0[] = "INSTALL_BASE=%s"; // 08056EE0
void g_v8056EF0 = ??void??; // 08056EF0
char g_str8056F07[] = "%s/%s/src"; // 08056F07
char g_str8056F11[] = "EXT_BASE=%s"; // 08056F11
void g_v8056F1D = ??void??; // 08056F1D
char g_str8056F2E[] = "INSTALL_TYPE=%s"; // 08056F2E
char g_str8056F3E[] = "%i"; // 08056F3E
char g_str8056F41[] = "GEM_FORCE=%s"; // 08056F41
char g_str8056F4E[] = "GEM_VERBOSE=%s"; // 08056F4E
void g_v8056F5D = ??void??; // 08056F5D
void g_v8056F88 = ??void??; // 08056F88
void g_v8056FB4 = ??void??; // 08056FB4
void g_v8056FE4 = ??void??; // 08056FE4
void g_v805700C = ??void??; // 0805700C
void g_v8057024 = ??void??; // 08057024
void g_v8057054 = ??void??; // 08057054
void g_v805708C = ??void??; // 0805708C
void g_v80570D4 = ??void??; // 080570D4
void g_v8057118 = ??void??; // 08057118
void g_v8057158 = ??void??; // 08057158
void g_v80571A0 = ??void??; // 080571A0
void g_v80571E4 = ??void??; // 080571E4
void g_v8057224 = ??void??; // 08057224
void g_v8057250 = ??void??; // 08057250
void g_v8057287 = ??void??; // 08057287
void g_v80572A0 = ??void??; // 080572A0
void g_v80572D4 = ??void??; // 080572D4
void g_v805731C = ??void??; // 0805731C
void g_v8057358 = ??void??; // 08057358
void g_v8057390 = ??void??; // 08057390
void g_v80573BC = ??void??; // 080573BC
void g_v80573F4 = ??void??; // 080573F4
void g_v8057434 = ??void??; // 08057434
void g_v8057484 = ??void??; // 08057484
void g_v80574C8 = ??void??; // 080574C8
void g_v8057510 = ??void??; // 08057510
void g_v805755A = ??void??; // 0805755A
void g_v805756C = ??void??; // 0805756C
void g_v80575B7 = ??void??; // 080575B7
void g_v80575CC = ??void??; // 080575CC
void g_v8057618 = ??void??; // 08057618
void g_v8057668 = ??void??; // 08057668
void g_v8057694 = ??void??; // 08057694
void g_v80576E0 = ??void??; // 080576E0
void g_v80576EC = ??void??; // 080576EC
void g_v805772C = ??void??; // 0805772C
char g_str805779D[] = "Detailed information"; // 0805779D
char g_str80577B2[] = "info"; // 080577B2
char g_str80577B7[] = "sh post"; // 080577B7
char g_str80577BF[] = "license"; // 080577BF
char g_str80577C8[] = "gem64 (GRASS extensions manager) %.2f\n"; // 080577C8
void g_v80577EF = ??void??; // 080577EF
void g_v805780C = ??void??; // 0805780C
void g_v8057830 = ??void??; // 08057830
void g_v805787C = ??void??; // 0805787C
char g_str80578C9[] = "%s/etc/config.system"; // 080578C9
char g_str80578DE[] = "r"; // 080578DE
void g_v8057925 = ??void??; // 08057925
void g_v8057926 = ??void??; // 08057926
void g_v8057930 = ??void??; // 08057930
void g_v8057935 = ??void??; // 08057935
char g_str805793C[] = ":i:u:q:d:c:C:t:l:m:o:x:rhVg:b:fvs"; // 0805793C
char g_str8057A06[] = ":i:u:q:d:c:t:l:o:x:rhVg:b:fvs"; // 08057A06
char g_str8057A65[] = "GEM_C_OPTS=%s"; // 08057A65
void g_v8057A74 = ??void??; // 08057A74
char g_str8057AB3[] = "GISBASE"; // 08057AB3
char g_str8057AFF[] = "Path to GRASS is %s.\n"; // 08057AFF
char g_str8057B15[] = "http://"; // 08057B15
char g_str8057B1D[] = "ftp://"; // 08057B1D
char g_str8057B24[] = "Extension location is '%s'.\n"; // 08057B24
void g_v8057B6C = ??void??; // 08057B6C
void g_v8057B94 = ??void??; // 08057B94
char g_str8057BBF[] = "."; // 08057BBF
char g_str8057BC1[] = ".."; // 08057BC1
char g_str8057BC4[] = "%s/%s"; // 08057BC4
char g_str8057C00[] = "Extension will be installed from '%s'\n"; // 08057C00
char g_str8057C27[] = "GRASS_VERSION"; // 08057C27
char g_str8057C35[] = "%s/etc/VERSIONNUMBER"; // 08057C35
char g_str8057C8E[] = "%i.%i.%i"; // 08057C8E
char g_str8057C97[] = "GRASS version is %s.\n"; // 08057C97
char g_str8057CE8[] = "-L%s/lib -I/usr/local/grasslib/include/ "; // 08057CE8
real64 g_r8057E40 = 1.03; // 08057E40
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 08048DD0: void _start(Register (ptr32 Eq_15) edx, Stack int32 dwArg00, Stack (ptr32 char) ptrArg04)
void _start(void (* edx)(), int32 dwArg00, char * ptrArg04)
{
	void * fp;
	__align_stack<word32>(&ptrArg04);
	__libc_start_main(&g_t805331E, dwArg00, &ptrArg04, &g_t80546F0, &g_t80546E0, edx, fp);
	__halt();
}

// 08048E00: void __do_global_dtors_aux()
// Called from:
//      _fini
void __do_global_dtors_aux()
{
	if (g_b8059284 == 0x00)
	{
		uint32 eax_14 = dtor_idx.7067;
		while (eax_14 < 0x00)
		{
			uint32 eax_24 = eax_14 + 0x01;
			dtor_idx.7067 = eax_24;
			(*((char *) g_a8058F18 + eax_24 * 0x04))();
			eax_14 = dtor_idx.7067;
		}
		g_b8059284 = 0x01;
	}
}

// 08048E60: void frame_dummy()
// Called from:
//      _init
void frame_dummy()
{
}

// 08048E84: void exit_env()
void exit_env()
{
}

// 08048E89: void exit_tmp(Register (ptr32 Eq_67) gs)
void exit_tmp(struct Eq_67 * gs)
{
	char bLoc0810;
	word32 eax_10 = gs->dw0014;
	if (g_b80632C0 == 0x00)
		TMPCLEAN = 0x01;
	else if (TMPCLEAN == 0x00)
	{
		chdir(0x0806C2E0);
		sprintf(&bLoc0810, "rm -rf %s/*", &g_b80632C0);
		if (VERBOSE != 0x00)
			fwrite(&g_v805482C, 0x01, 0x25, stdout);
		system(&bLoc0810);
		sprintf(&bLoc0810, "rmdir %s", &g_b80632C0);
		system(&bLoc0810);
		if (opendir(&g_b80632C0) != null)
			print_warning(gs, 0x0805485C);
		if (VERBOSE != 0x00)
			print_done();
		TMPCLEAN = 0x01;
	}
	if ((eax_10 ^ gs->dw0014) == 0x00)
		return;
	__stack_chk_fail();
}

// 08048FC2: void exit_db(Register (ptr32 Eq_67) gs)
void exit_db(struct Eq_67 * gs)
{
	char bLoc0810;
	word32 eax_10 = gs->dw0014;
	if (TMPDBCLEAN == 0x00)
	{
		chdir(0x0806C2E0);
		if (VERBOSE != 0x00)
			fwrite(&g_v80548A0, 0x01, 0x28, stdout);
		if (g_b8063AC0 != 0x00)
		{
			sprintf(&bLoc0810, "rm -rf %s", &g_b8063AC0);
			if (system(&bLoc0810) != 0x00)
				print_warning(gs, 0x080548D4);
		}
		if (g_b80642C0 != 0x00)
		{
			sprintf(&bLoc0810, "rm -f %s", &g_b80642C0);
			if (system(&bLoc0810) != 0x00)
				print_warning(gs, 0x080548D4);
		}
		if (g_b8064AC0 != 0x00)
		{
			sprintf(&bLoc0810, "rm -f %s", &g_b8064AC0);
			if (system(&bLoc0810) != 0x00)
				print_warning(gs, 0x080548D4);
		}
		if (g_b80652C0 != 0x00)
		{
			sprintf(&bLoc0810, "rm -f %s", &g_b80652C0);
			if (system(&bLoc0810) != 0x00)
				print_warning(gs, 0x080548D4);
		}
		if (g_b8065AC0 != 0x00)
		{
			sprintf(&bLoc0810, "rm -f %s", &g_b8065AC0);
			if (system(&bLoc0810) != 0x00)
				print_warning(gs, 0x080548D4);
		}
		if (g_b80662C0 != 0x00)
		{
			sprintf(&bLoc0810, "rm -f %s", &g_b80662C0);
			if (system(&bLoc0810) != 0x00)
				print_warning(gs, 0x080548D4);
		}
		if (g_b8066AC0 != 0x00)
		{
			sprintf(&bLoc0810, "rm -f %s", &g_b8066AC0);
			if (system(&bLoc0810) != 0x00)
				print_warning(gs, 0x080548D4);
		}
		if (g_b8067AC0 != 0x00)
		{
			sprintf(&bLoc0810, "rm -f %s", &g_b8067AC0);
			if (system(&bLoc0810) != 0x00)
				print_warning(gs, 0x080548D4);
		}
		if (VERBOSE == 0x00 && g_b80672C0 != 0x00)
		{
			sprintf(&bLoc0810, "rm -f %s", &g_b80672C0);
			if (system(&bLoc0810) != 0x00)
				print_warning(gs, 0x080548D4);
		}
		if (VERBOSE != 0x00)
			print_done();
		TMPDBCLEAN = 0x01;
	}
	if ((eax_10 ^ gs->dw0014) == 0x00)
		return;
	__stack_chk_fail();
}

// 08049390: void exit_msg()
void exit_msg()
{
	if (ERROR < 0x00)
		fprintf(stdout, "Program exited with an error (code %i). Operation aborted.\n", ERROR);
	else
	{
		if (WARNINGS == 0x01)
			fwrite(&g_v8054958, 0x01, 0x32, stdout);
		if (WARNINGS > 0x01)
			fprintf(stdout, "Job done but there were %i warnings. Please check.\n", WARNINGS);
	}
}

// 08049420: void print_error(Register (ptr32 Eq_67) gs, Stack int32 dwArg04, Stack word32 dwArg08)
// Called from:
//      insert_str
//      delete_str
//      get_package_name
//      dump_plain
//      dump_html
//      wget_extension
//      su
//      depstr
//      register_extension
//      deregister_extension
//      check_dependencies
//      check_ext_menu
//      register_entries_gisman
//      register_entries_gisman2
//      deregister_entries_gisman
//      deregister_entries_gisman2
//      restore_entries_gisman
//      register_html
//      deregister_html
//      restore_html
//      check_extension
//      unpack_extension
//      query_extension
//      source_install
//      bin_install
//      test_install
//      source_clean
//      restore
//      list_extensions
//      show_details
//      show_license
//      main
void print_error(struct Eq_67 * gs, int32 dwArg04, word32 dwArg08)
{
	ptr32 fp;
	char bLoc0810;
	vsprintf(&bLoc0810, dwArg08, fp + 0x0C, dwArg08, fp + 0x0C, gs->dw0014);
	fprintf(stderr, "\x1B[1;31m\nERROR:\x1B[0m %s", &bLoc0810);
	ERROR = dwArg04;
	exit(dwArg04);
}

// 0804949B: void print_warning(Register (ptr32 Eq_67) gs, Stack word32 dwArg04)
// Called from:
//      exit_tmp
//      exit_db
//      new_submenu
//      new_item
//      register_entries_gisman
//      deregister_entries_gisman
//      new_ext_html
//      delete_ext_html
//      unpack_extension
//      source_install
//      bin_install
//      test_install
//      uninstall
//      get_configure_options
void print_warning(struct Eq_67 * gs, word32 dwArg04)
{
	ptr32 fp;
	char bLoc0810;
	word32 eax_12 = gs->dw0014;
	vsprintf(&bLoc0810, dwArg04, fp + 8, dwArg04, fp + 8, eax_12);
	fprintf(stderr, "\x1B[0;33m\nWARNING:\x1B[0m %s", &bLoc0810);
	++WARNINGS;
	if ((eax_12 ^ gs->dw0014) == 0x00)
		return;
	__stack_chk_fail();
}

// 08049523: void print_done()
// Called from:
//      exit_tmp
//      exit_db
//      wget_extension
//      check_extension
//      unpack_extension
//      source_install
//      bin_install
//      test_install
//      uninstall
//      source_clean
//      restore
void print_done()
{
	fwrite(&g_v80549EE, 0x01, 0x11, stdout);
}

// 08049554: Register (ptr32 char) basename(Stack (ptr32 char) dwArg04)
// Called from:
//      unpack_extension
//      query_extension
//      source_install
//      bin_install
//      test_install
//      source_clean
//      run_post
//      show_details
//      show_license
char * basename(char * dwArg04)
{
	char * eax_112;
	char * eax_11 = strdup(dwArg04);
	char * eax_18 = strtok(eax_11, "/");
	char * dwLoc14_84 = eax_18;
	if (eax_18 == null)
	{
		if (eax_11 != null)
			free(eax_11);
		eax_112 = null;
	}
	else
	{
		char * dwLoc18_86 = strdup(eax_18);
		while (dwLoc14_84 != null)
		{
			char * eax_34 = strtok(null, "/");
			dwLoc14_84 = eax_34;
			if (dwLoc18_86 != null && eax_34 != null)
				free(dwLoc18_86);
			if (eax_34 != null && *eax_34 != 0x00)
				dwLoc18_86 = strdup(eax_34);
		}
		if (eax_11 != null)
			free(eax_11);
		eax_112 = dwLoc18_86;
	}
	return eax_112;
}

// 0804961D: void mkdir_s(Register (ptr32 Eq_67) gs, Stack (ptr32 char) dwArg04, Stack (ptr32 char) dwArg08)
// Called from:
//      unpack_extension
void mkdir_s(struct Eq_67 * gs, char * dwArg04, char * dwArg08)
{
	char bLoc1398;
	word32 eax_14 = gs->dw0014;
	sprintf(&bLoc1398, "mkdir %s --mode=%s -p", dwArg04, dwArg08);
	system(&bLoc1398);
	if ((eax_14 ^ gs->dw0014) == 0x00)
		return;
	__stack_chk_fail();
}

// 0804968F: void chop(Stack Eq_599 dwArg04)
// Called from:
//      get_package_name
//      dump_html
//      new_item
void chop(Eq_599 dwArg04)
{
	Eq_600 dwLoc14_104 = 0x00;
	Eq_602 dwLoc10_88;
	for (dwLoc10_88 = strlen(dwArg04) - 0x01; dwLoc10_88 >= null; dwLoc10_88 -= (char *) 0x01)
	{
		word32 dwLoc18_90 = 0x01;
		if (Mem21[dwLoc10_88 + dwArg04:byte] == 0x0A || (Mem21[dwLoc10_88 + dwArg04:byte] == 0x09 || (Mem21[dwLoc10_88 + dwArg04:byte] == 0x20 || (Mem21[dwLoc10_88 + dwArg04:byte] == 0x0C || Mem21[dwLoc10_88 + dwArg04:byte] == 0x0D))))
		{
			dwLoc14_104 = (word32) dwLoc14_104 + 1;
			dwLoc18_90 = 0x00;
		}
		if (dwLoc18_90 == 0x01)
			break;
	}
	Mem78[strlen(dwArg04) - dwLoc14_104 + dwArg04:byte] = 0x00;
}

// 08049737: void insert_str(Register (ptr32 Eq_67) gs, Stack (ptr32 Eq_649) dwArg04, Stack int32 dwArg08, Stack (arr (ptr32 char)) dwArg0C)
// Called from:
//      check_ext_menu
//      new_submenu
//      new_item
//      new_ext_html
void insert_str(struct Eq_67 * gs, union Eq_649 * dwArg04, int32 dwArg08, char * dwArg0C[])
{
	char bLoc1810;
	char bLoc1010;
	char bLoc0810;
	word32 eax_17 = gs->dw0014;
	int32 dwLoc1814_237 = 0x00;
	while (dwArg0C[dwLoc1814_237] != null)
		++dwLoc1814_237;
	if (dwArg08 < 0x00 || dwArg08 > dwLoc1814_237)
		print_error(gs, ~0x14, 0x08054A18);
	else
	{
		if (dwArg08 == dwLoc1814_237)
		{
			dwArg0C[dwLoc1814_237] = malloc((word32) strlen(dwArg04) + 1);
			strcpy(dwArg0C[dwLoc1814_237], dwArg04);
			dwArg0C[dwLoc1814_237 + 0x01] = null;
		}
		else
		{
			strcpy(&bLoc1810, dwArg0C[dwLoc1814_237 - 0x01]);
			strcpy(&bLoc1010, dwArg0C[dwArg08]);
			free(dwArg0C[dwArg08]);
			dwArg0C[dwArg08] = malloc((word32) strlen(dwArg04) + 1);
			strcpy(dwArg0C[dwArg08], dwArg04);
			int32 dwLoc1818_253;
			for (dwLoc1818_253 = dwArg08; dwLoc1814_237 - 0x01 > dwLoc1818_253; ++dwLoc1818_253)
			{
				strcpy(&bLoc0810, dwArg0C[dwLoc1818_253 + 0x01]);
				free(dwArg0C[dwLoc1818_253 + 0x01]);
				dwArg0C[dwLoc1818_253 + 0x01] = malloc((word32) strlen(&bLoc1010) + 1);
				strcpy(dwArg0C[dwLoc1818_253 + 0x01], &bLoc1010);
				strcpy(&bLoc1010, &bLoc0810);
			}
			dwArg0C[dwLoc1814_237] = malloc((word32) strlen(&bLoc1810) + 1);
			strcpy(dwArg0C[dwLoc1814_237], &bLoc1810);
			dwArg0C[dwLoc1814_237 + 0x01] = null;
		}
		if ((eax_17 ^ gs->dw0014) == 0x00)
			return;
		__stack_chk_fail();
	}
}

// 08049A5E: void delete_str(Register (ptr32 Eq_67) gs, Stack int32 dwArg04, Stack (arr (ptr32 char)) dwArg08)
// Called from:
//      deregister_entries_gisman
//      delete_ext_html
void delete_str(struct Eq_67 * gs, int32 dwArg04, char * dwArg08[])
{
	int32 dwLoc10_120 = 0x00;
	while (dwArg08[dwLoc10_120] != null)
		++dwLoc10_120;
	if (dwArg04 < 0x00 || dwArg04 > dwLoc10_120)
		print_error(gs, ~0x14, 134564412);
	else
	{
		int32 dwLoc10_126 = dwArg04;
		while (dwArg08[dwLoc10_126] != null)
		{
			free(dwArg08[dwLoc10_126]);
			if (dwArg08[dwLoc10_126 + 0x01] != null)
			{
				dwArg08[dwLoc10_126] = malloc((word32) strlen(dwArg08[dwLoc10_126 + 0x01]) + 1);
				strcpy(dwArg08[dwLoc10_126], dwArg08[dwLoc10_126 + 0x01]);
			}
			++dwLoc10_126;
		}
		dwArg08[dwLoc10_126 - 0x01] = null;
	}
}

// 08049B5F: Register int32 find_pos(Stack (ptr32 char) dwArg04, Stack (arr (ptr32 char)) dwArg08, Stack int32 dwArg0C)
// Called from:
//      check_ext_menu
//      new_submenu
//      deregister_entries_gisman
//      new_ext_html
//      delete_ext_html
int32 find_pos(char * dwArg04, char * dwArg08[], int32 dwArg0C)
{
	int32 dwLoc10_63 = 0x00;
	while (dwArg08[dwLoc10_63] != null)
		++dwLoc10_63;
	if (dwArg0C < 0x00 || dwArg0C > dwLoc10_63)
		exit(~0x14);
	else
	{
		int32 dwLoc14_69 = dwArg0C;
		while (true)
		{
			int32 eax_52;
			if (dwLoc14_69 >= dwLoc10_63)
				break;
			if (strstr(dwArg08[dwLoc14_69], dwArg04) != null)
			{
				eax_52 = dwLoc14_69;
				return eax_52;
			}
			++dwLoc14_69;
		}
		eax_52 = ~0x00;
		return eax_52;
	}
}

// 08049BD9: void dump_str(Stack (ptr32 Eq_135) dwArg04, Stack (arr (ptr32 char)) dwArg08)
void dump_str(FILE * dwArg04, char * dwArg08[])
{
	int32 dwLoc10_41 = 0x00;
	while (dwArg08[dwLoc10_41] != null)
	{
		fprintf(dwArg04, "%i: %s", dwLoc10_41, dwArg08[dwLoc10_41]);
		++dwLoc10_41;
	}
}

// 08049C27: void get_package_name(Register (ptr32 Eq_67) gs, Stack (ptr32 char) dwArg04, Stack (ptr32 char) dwArg08)
// Called from:
//      check_extension
//      main
void get_package_name(struct Eq_67 * gs, char * dwArg04, char * dwArg08)
{
	char bLoc1010;
	char bLoc0810;
	word32 eax_14 = gs->dw0014;
	sprintf(&bLoc0810, "%s/%s", dwArg04, "name");
	FILE * eax_29 = fopen(&bLoc0810, "r");
	if (eax_29 != null)
	{
		if (nc_fgets_nb(&bLoc1010, 0x0800, eax_29) != 0x00)
		{
			chop(&bLoc1010);
			strcpy(dwArg08, &bLoc1010);
			fclose(eax_29);
			if ((eax_14 ^ gs->dw0014) == 0x00)
				return;
			__stack_chk_fail();
		}
		else
		{
			fclose(eax_29);
			print_error(gs, ~0x05, 0x08054A8C);
		}
	}
	else
		print_error(gs, ~0x05, 134564465);
}

// 08049D41: Register Eq_95 nc_fgets(Stack Eq_95 dwArg04, Stack int32 dwArg08, Stack (ptr32 Eq_1060) dwArg0C)
// Called from:
//      nc_fgets
//      dump_plain
//      dump_html
Eq_95 nc_fgets(Eq_95 dwArg04, int32 dwArg08, FILE * dwArg0C)
{
	Eq_95 eax_104;
	if (fgets(dwArg04, dwArg08, dwArg0C) != null)
	{
		Eq_95 eax_23 = strchr(dwArg04, '#');
		if (eax_23 != 0x00)
		{
			if (dwArg04 == eax_23)
			{
				eax_104 = nc_fgets(dwArg04, dwArg08, dwArg0C);
				return eax_104;
			}
			char * eax_31 = malloc(0x0800);
			strcpy(eax_31, dwArg04);
			char * eax_42 = strtok(eax_31, "#");
			sprintf(dwArg04, "%s\n", eax_42);
			free(eax_42);
		}
		eax_104 = dwArg04;
		return eax_104;
	}
	else
	{
		&eax_104.u0->b0000 = 0x00;
		return eax_104;
	}
}

// 08049E14: Register Eq_95 nc_fgets_html(Stack Eq_95 dwArg04, Stack int32 dwArg08, Stack (ptr32 Eq_1114) dwArg0C)
// Called from:
//      nc_fgets_html
//      dump_ascii
Eq_95 nc_fgets_html(Eq_95 dwArg04, int32 dwArg08, FILE * dwArg0C)
{
	word32 dwLoc30;
	Eq_95 eax_294;
	if (fgets(dwArg04, dwArg08, dwArg0C) != null)
	{
		char * eax_25 = malloc((word32) strlen(dwArg04) + 1);
		char * eax_33 = malloc((word32) strlen(dwArg04) + 1);
		char * dwLoc2C_337 = eax_25;
		Eq_95 dwLoc28_338 = dwArg04;
		while (dwLoc28_338.u0->b0000 != 0x00)
		{
			if (dwLoc28_338.u0->b0000 == 0x3C)
			{
				Eq_95 v12_57 = dwLoc28_338 - 0x01;
				Eq_95 dwLoc18_340 = dwLoc28_338;
				dwLoc28_338 = v12_57;
				if (v12_57 >= dwArg04)
				{
					if (v12_57.u0->b0000 == 0x20)
						dwLoc30 = 0x01;
					else
						dwLoc30 = 0x00;
				}
				while (dwLoc18_340.u0->b0000 != 0x00)
				{
					*eax_33 = dwLoc18_340.u0->b0000;
					++*eax_33;
					if (dwLoc18_340.u0->b0000 == 0x3E)
					{
						*eax_33 = 0x00;
						if (dwLoc18_340.u0[1] != 0x0A)
						{
							if (strstr(eax_33, "<br>") != null && dwLoc2C_337 > eax_25)
							{
								*dwLoc2C_337 = 0x0A;
								++*dwLoc2C_337;
							}
							if (strstr(eax_33, "<BR>") != null && dwLoc2C_337 > eax_25)
							{
								*dwLoc2C_337 = 0x0A;
								++*dwLoc2C_337;
							}
							if (strstr(eax_33, "<p>") != null)
							{
								if (dwLoc2C_337 > eax_25)
								{
									*dwLoc2C_337 = 0x0A;
									++*dwLoc2C_337;
								}
								*dwLoc2C_337 = 0x0A;
								++*dwLoc2C_337;
							}
							if (strstr(eax_33, "<P>") != null)
							{
								if (dwLoc2C_337 > eax_25)
								{
									*dwLoc2C_337 = 0x0A;
									++*dwLoc2C_337;
								}
								*dwLoc2C_337 = 0x0A;
								++*dwLoc2C_337;
							}
						}
						dwLoc28_338 = dwLoc18_340;
						if (dwLoc18_340.u0->b0000 == 0x20 && dwLoc30 == 0x01)
						{
							&dwLoc28_338.u0->b0000 = dwLoc18_340.u0 + 1;
							dwLoc30 = 0x00;
						}
						break;
					}
					&dwLoc18_340.u0->b0000 = dwLoc18_340.u0 + 1;
				}
			}
			if (dwLoc28_338.u0->b0000 != 0x3E)
			{
				*dwLoc2C_337 = dwLoc28_338.u0->b0000;
				++dwLoc2C_337;
			}
			&dwLoc28_338.u0->b0000 = dwLoc28_338.u0 + 1;
		}
		*dwLoc2C_337 = 0x00;
		strcpy(dwArg04, eax_25);
		free(eax_25);
		free(eax_33);
		Eq_95 eax_262 = strchr(dwArg04, '#');
		if (eax_262 != 0x00)
		{
			if (dwArg04 == eax_262)
			{
				eax_294 = nc_fgets_html(dwArg04, dwArg08, dwArg0C);
				return eax_294;
			}
			char * eax_270 = malloc(0x0800);
			strcpy(eax_270, dwArg04);
			char * eax_281 = strtok(eax_270, "#");
			sprintf(dwArg04, "%s\n", eax_281);
			free(eax_281);
		}
		eax_294 = dwArg04;
		return eax_294;
	}
	else
	{
		&eax_294.u0->b0000 = 0x00;
		return eax_294;
	}
}

// 0804A146: Register word32 is_text(Stack Eq_95 dwArg04)
// Called from:
//      nc_fgets_nb
//      dump_html
word32 is_text(Eq_95 dwArg04)
{
	Eq_1399 dwLoc10_66 = strlen(dwArg04) - 0x01;
	while (true)
	{
		word32 dwLoc14_69 = 0x00;
		if (dwLoc10_66 < null)
			break;
		if (Mem17[dwLoc10_66 + dwArg04:byte] != 0x20 && (Mem17[dwLoc10_66 + dwArg04:byte] != 0x09 && (Mem17[dwLoc10_66 + dwArg04:byte] != 0x0A && (Mem17[dwLoc10_66 + dwArg04:byte] != 0x0C && Mem17[dwLoc10_66 + dwArg04:byte] != 0x0D))))
		{
			dwLoc14_69 = 0x01;
			return dwLoc14_69;
		}
		--dwLoc10_66;
	}
	return dwLoc14_69;
}

// 0804A1C8: Register Eq_95 nc_fgets_nb(Stack Eq_95 dwArg04, Stack int32 dwArg08, Stack (ptr32 Eq_1002) dwArg0C)
// Called from:
//      get_package_name
//      nc_fgets_nb
//      depstr
//      register_extension
//      deregister_extension
//      check_dependencies
//      register_entries_gisman
//      restore_entries_gisman
//      check_extension
//      get_configure_options
Eq_95 nc_fgets_nb(Eq_95 dwArg04, int32 dwArg08, FILE * dwArg0C)
{
	Eq_95 eax_129;
	if (fgets(dwArg04, dwArg08, dwArg0C) != null)
	{
		if (is_text(dwArg04) != 0x00)
		{
			Eq_95 eax_34 = strchr(dwArg04, '#');
			if (eax_34 != 0x00)
			{
				if (dwArg04 == eax_34)
				{
					eax_129 = nc_fgets_nb(dwArg04, dwArg08, dwArg0C);
					return eax_129;
				}
				char * eax_42 = malloc(0x0800);
				strcpy(eax_42, dwArg04);
				char * eax_53 = strtok(eax_42, "#");
				sprintf(dwArg04, "%s\n", eax_53);
				free(eax_53);
			}
			eax_129 = dwArg04;
			return eax_129;
		}
		else
		{
			eax_129 = nc_fgets_nb(dwArg04, dwArg08, dwArg0C);
			return eax_129;
		}
	}
	else
	{
		&eax_129.u0->b0000 = 0x00;
		return eax_129;
	}
}

// 0804A2C8: void dump_ascii(Register (ptr32 Eq_67) gs, Stack (ptr32 char) dwArg04, Stack (ptr32 char) dwArg08)
// Called from:
//      query_extension
//      list_extensions
//      show_details
//      show_license
void dump_ascii(struct Eq_67 * gs, char * dwArg04, char * dwArg08)
{
	char bLoc0810;
	word32 eax_14 = gs->dw0014;
	fprintf(stdout, "%s\n", dwArg08);
	FILE * eax_28 = fopen(dwArg04, "r");
	if (eax_28 == null)
		fwrite(&g_v8054AC8, 0x01, 0x1C, stdout);
	else
	{
		while (nc_fgets_html(&bLoc0810, 0x0800, eax_28) != 0x00)
			fprintf(stdout, "  %s", &bLoc0810);
		fputc(0x0A, stdout);
		fclose(eax_28);
	}
	if ((eax_14 ^ gs->dw0014) == 0x00)
		return;
	__stack_chk_fail();
}

// 0804A3DB: void dump_plain(Register (ptr32 Eq_67) gs, Stack (ptr32 char) dwArg04, Stack (ptr32 char) dwArg08)
// Called from:
//      test_install
void dump_plain(struct Eq_67 * gs, char * dwArg04, char * dwArg08)
{
	char bLoc0810;
	word32 eax_14 = gs->dw0014;
	memcpy(dwArg08, &g_v8054AEC, 0x20);
	mkstemp(dwArg08, dwArg08, 134564588, 0x20, dwArg08, dwArg04, eax_14);
	FILE * eax_35 = fopen(dwArg08, "w+");
	if (eax_35 != null)
	{
		atexit(&g_t8048FC2);
		FILE * eax_59 = fopen(dwArg04, "r");
		while (nc_fgets(&bLoc0810, 0x0800, eax_59) != 0x00)
			fprintf(eax_35, &bLoc0810, 0x00);
		fclose(eax_59);
		fclose(eax_35);
		if ((eax_14 ^ gs->dw0014) == 0x00)
			return;
		__stack_chk_fail();
	}
	else
	{
		strerror(*__errno_location());
		print_error(gs, ~0x16, 0x08054B10);
	}
}

// 0804A51B: void dump_html(Register (ptr32 Eq_67) gs, Stack (ptr32 char) dwArg04, Stack (ptr32 char) dwArg08)
// Called from:
//      source_install
//      bin_install
void dump_html(struct Eq_67 * gs, char * dwArg04, char * dwArg08)
{
	char bLoc1010;
	char bLoc0810;
	int32 dwLoc101C;
	word32 eax_14 = gs->dw0014;
	memcpy(dwArg08, &g_v8054AEC, 0x20);
	mkstemp(dwArg08, dwArg08, 134564588, 0x20, dwArg08, dwArg04, eax_14);
	FILE * eax_35 = fopen(dwArg08, "w+");
	if (eax_35 != null)
	{
		atexit(&g_t8048FC2);
		FILE * eax_59 = fopen(dwArg04, "r");
		while (nc_fgets(&bLoc1010, 0x0800, eax_59) != 0x00)
		{
			chop(&bLoc1010);
			if (is_text(&bLoc1010) == 0x00)
				fwrite(&g_v8054B8B, 0x01, 0x04, eax_35);
			else
			{
				sprintf(&bLoc0810, "%s <br>\n", &bLoc1010);
				fprintf(eax_35, &bLoc0810, 0x00);
			}
		}
		fclose(eax_59);
		fclose(eax_35);
		close(dwLoc101C);
		if ((eax_14 ^ gs->dw0014) == 0x00)
			return;
		__stack_chk_fail();
	}
	else
	{
		strerror(*__errno_location());
		print_error(gs, ~0x16, 0x08054B10);
	}
}

// 0804A6DA: void list_binaries(Register (ptr32 Eq_67) gs, Stack (ptr32 char) dwArg04)
// Called from:
//      query_extension
void list_binaries(struct Eq_67 * gs, char * dwArg04)
{
	word32 dwLoc0874;
	char bLoc0810;
	ui32 dwLoc0864;
	word32 eax_12 = gs->dw0014;
	fwrite(&g_v8054B99, 0x01, 0x1A, stdout);
	word32 dwLoc081C_171 = 0x00;
	DIR * eax_26 = opendir(dwArg04);
	if (eax_26 == null)
		fwrite(&g_v8054BB4, 0x01, 0x09, stdout);
	else
	{
		struct dirent * dwLoc0818_179 = readdir(eax_26);
		while (dwLoc0818_179 != null)
		{
			if (strcmp((char *) dwLoc0818_179 + 11, ".") != 0x00 && (strcmp((char *) dwLoc0818_179 + 11, "..") != 0x00 && strcmp((char *) dwLoc0818_179 + 11, "src") != 0x00))
			{
				sprintf(&bLoc0810, "%s/%s", dwArg04, (char *) dwLoc0818_179 + 11);
				stat(&bLoc0810, &dwLoc0874);
				if ((dwLoc0864 & 0xF000) == 0x4000)
				{
					if (dwLoc081C_171 == 0x00)
						fprintf(stdout, "  %s", (char *) dwLoc0818_179 + 11);
					else
						fprintf(stdout, ", %s", (char *) dwLoc0818_179 + 11);
					++dwLoc081C_171;
				}
			}
			dwLoc0818_179 = readdir(eax_26);
		}
		if (dwLoc081C_171 == 0x00)
			fwrite(&g_v8054BCC, 0x01, 0x07, stdout);
		fwrite(&g_v8054BD4, 0x01, 0x02, stdout);
	}
	if ((eax_12 ^ gs->dw0014) == 0x00)
		return;
	__stack_chk_fail();
}

// 0804A92C: Register word32 binaries_exist(Register (ptr32 Eq_67) gs, Stack (ptr32 char) dwArg04, Stack (ptr32 char) dwArg08)
// Called from:
//      main
word32 binaries_exist(struct Eq_67 * gs, char * dwArg04, char * dwArg08)
{
	word32 dwLoc0870;
	char bLoc0810;
	ui32 dwLoc0860;
	word32 eax_100;
	word32 eax_14 = gs->dw0014;
	DIR * eax_19 = opendir(dwArg04);
	if (eax_19 == null)
		eax_100 = 0x00;
	else
	{
		struct dirent * dwLoc0818_127 = readdir(eax_19);
		while (dwLoc0818_127 != null)
		{
			if (strcmp((char *) dwLoc0818_127 + 11, ".") != 0x00 && (strcmp((char *) dwLoc0818_127 + 11, "..") != 0x00 && strcmp((char *) dwLoc0818_127 + 11, "src") != 0x00))
			{
				sprintf(&bLoc0810, "%s/%s", dwArg04, (char *) dwLoc0818_127 + 11);
				stat(&bLoc0810, &dwLoc0870);
				if ((dwLoc0860 & 0xF000) == 0x4000 && strcmp((char *) dwLoc0818_127 + 11, dwArg08) == 0x00)
				{
					eax_100 = 0x01;
					goto l0804AA95;
				}
			}
			dwLoc0818_127 = readdir(eax_19);
		}
		eax_100 = 0x00;
	}
l0804AA95:
	if ((eax_14 ^ gs->dw0014) == 0x00)
		return eax_100;
	__stack_chk_fail();
}

// 0804AAA8: Register word32 check_filetype(Stack (ptr32 char) dwArg04)
// Called from:
//      unpack_extension
word32 check_filetype(char * dwArg04)
{
	word32 eax_57;
	if (strstr(dwArg04, ".tar.gz") != null)
		eax_57 = 0x01;
	else if (strstr(dwArg04, ".tgz") != null)
		eax_57 = 0x01;
	else if (strstr(dwArg04, ".tar.bz2") != null)
		eax_57 = 0x02;
	else if (strstr(dwArg04, ".tbz") != null)
		eax_57 = 0x02;
	else if (strstr(dwArg04, ".zip") != null)
		eax_57 = 0x03;
	else if (strstr(dwArg04, ".tar") != null)
		eax_57 = 0x04;
	else
		eax_57 = 0x00;
	return eax_57;
}

// 0804AB6C: void wget_extension(Register (ptr32 Eq_67) gs, Stack (ptr32 char) dwArg04)
// Called from:
//      main
void wget_extension(struct Eq_67 * gs, char * dwArg04)
{
	char bLoc0810;
	word32 eax_12 = gs->dw0014;
	fwrite(&g_v8054BFC, 0x01, 0x0E, stdout);
	if (VERBOSE != 0x00)
		sprintf(&bLoc0810, "wget -N %s", dwArg04);
	else
		sprintf(&bLoc0810, "wget -N -q %s", dwArg04);
	int32 eax_46 = system(&bLoc0810);
	if (eax_46 != ~0x00)
	{
		if (eax_46 <= 0x00)
		{
			print_done();
			if ((eax_12 ^ gs->dw0014) == 0x00)
				return;
			__stack_chk_fail();
		}
		else
			print_error(gs, ~0x13, 0x08054C62);
	}
	else
		print_error(gs, ~0x13, 0x08054C24);
}

// 0804AC6E: void su(Register (ptr32 Eq_67) gs, Stack Eq_95 dwArg04, Stack (ptr32 char) dwArg08)
// Called from:
//      source_install
//      bin_install
//      uninstall
//      restore
void su(struct Eq_67 * gs, Eq_95 dwArg04, char * dwArg08)
{
	char bLoc0810;
	word32 eax_14 = gs->dw0014;
	next.4089.u0 = (int32) (next.4089.u0 *s 1103515245 + 0xD431);
	next.4089.u0 = (int32) (next.4089.u0 >> 0x10 & 0x7FFF);
	srand(next.4089.u0);
	sprintf(&bLoc0810, "%s/gem.test.%i", dwArg04, rand());
	FILE * eax_40 = fopen(&bLoc0810, "w+");
	if (*__errno_location() != 0x0D)
	{
		remove(&bLoc0810);
		fclose(eax_40);
		if (system(dwArg08) == 0x00)
		{
			if ((eax_14 ^ gs->dw0014) == 0x00)
				return;
			__stack_chk_fail();
		}
		else
			print_error(gs, ~0x08, 134565105);
	}
	else
		print_error(gs, ~0x04, 0x08054C88);
}

// 0804AD9B: Register word32 vercmp(Stack int32 dwArg04, Stack int32 dwArg08, Stack int32 dwArg0C, Stack int32 dwArg10, Stack int32 dwArg14, Stack int32 dwArg18)
// Called from:
//      register_extension
//      check_dependencies
word32 vercmp(int32 dwArg04, int32 dwArg08, int32 dwArg0C, int32 dwArg10, int32 dwArg14, int32 dwArg18)
{
	word32 eax_37;
	if (dwArg04 == dwArg10 && (dwArg08 == dwArg14 && dwArg0C == dwArg18))
		eax_37 = 0x00;
	else if (dwArg10 > dwArg04)
		eax_37 = ~0x00;
	else if (dwArg10 < dwArg04)
		eax_37 = 0x01;
	else if (dwArg14 > dwArg08)
		eax_37 = ~0x00;
	else if (dwArg14 < dwArg08)
		eax_37 = 0x01;
	else if (dwArg18 > dwArg0C)
		eax_37 = ~0x00;
	else if (dwArg18 < dwArg0C)
		eax_37 = 0x01;
	else
		eax_37 = 0x00;
	return eax_37;
}

// 0804AE20: void depstr(Register (ptr32 Eq_67) gs)
// Called from:
//      register_extension
void depstr(struct Eq_67 * gs)
{
	char bLoc1810;
	char bLoc1010;
	word32 dwLoc0810;
	word32 eax_14 = gs->dw0014;
	memcpy(&dwLoc0810, &g_v8054D08, 11);
	FILE * eax_27 = fopen(&dwLoc0810, "r");
	if (eax_27 == null)
	{
		if (*__errno_location() != 0x02)
		{
			strerror(*__errno_location());
			print_error(gs, ~0x10, 134565142);
		}
	}
	else
	{
		word32 dwLoc1818_148 = 0x01;
		char * eax_46 = malloc(0x0800);
		while (nc_fgets_nb(&bLoc1010, 0x0800, eax_27) != 0x00)
		{
			if (bLoc1010 != 0x00 && (__isoc99_sscanf(&bLoc1010, "%s", &bLoc1810) > 0x00 && strcmp("GRASS", &bLoc1810) != 0x00))
			{
				if (dwLoc1818_148 != 0x00)
				{
					strcat(eax_46, "\t");
					strcat(eax_46, &bLoc1810);
					dwLoc1818_148 = 0x00;
				}
				else
				{
					strcat(eax_46, ",");
					strcat(eax_46, &bLoc1810);
				}
			}
		}
		fclose(eax_27);
	}
	if ((eax_14 ^ gs->dw0014) == 0x00)
		return;
	__stack_chk_fail();
}

// 0804B014: void register_extension(Register (ptr32 Eq_67) gs, Stack Eq_95 dwArg04, Stack (ptr32 char) dwArg08, Stack (ptr32 char) dwArg0C, Stack int32 dwArg10, Stack int32 dwArg14, Stack int32 dwArg18)
// Called from:
//      source_install
//      bin_install
//      test_install
void register_extension(struct Eq_67 * gs, Eq_95 dwArg04, char * dwArg08, char * dwArg0C, int32 dwArg10, int32 dwArg14, int32 dwArg18)
{
	int32 dwLoc283C;
	int32 dwLoc2838;
	int32 dwLoc2834;
	char bLoc2810;
	char bLoc2010;
	char bLoc1810;
	char bLoc1010;
	char bLoc0810;
	word32 dwLoc2814;
	word32 eax_19 = gs->dw0014;
	sprintf(&bLoc0810, "%s/etc/extensions.db", dwArg04);
	word32 dwLoc281C_419 = 0x01;
	FILE * eax_34 = fopen(&bLoc0810, "r");
	if (eax_34 == null)
	{
		if (*__errno_location() != 0x02)
		{
			fclose(eax_34);
			strerror(*__errno_location());
			print_error(gs, ~0x0E, 134565142);
		}
		dwLoc281C_419 = 0x00;
	}
	if (dwLoc281C_419 != 0x00)
	{
		memcpy(&g_b8063AC0, &g_v8054D54, 0x20);
		mkstemp(0x08063AC0, 0x08063AC0, 0x08054D54, 0x20);
		FILE * eax_77 = fopen(&g_b8063AC0, "w+");
		if (eax_77 == null)
		{
			strerror(*__errno_location());
			print_error(gs, ~0x0E, 0x08054D78);
		}
		atexit(&g_t8048FC2);
		dwLoc2814 = 0x00;
		word32 dwLoc2820_454 = 0x01;
		word32 dwLoc2828_455 = 0x00;
		while (nc_fgets_nb(&bLoc1010, 0x0800, eax_34) != 0x00)
		{
			__isoc99_sscanf(&bLoc1010, "%s\t%i.%i.%i\t%s\t%s", &bLoc1810, &dwLoc2834, &dwLoc2838, &dwLoc283C, &bLoc2010, &bLoc2810);
			++dwLoc2814;
			word32 dwLoc2824_462 = 0x01;
			if (strcmp(&bLoc1810, dwArg0C) == 0x00)
			{
				int32 eax_160 = vercmp(dwLoc2834, dwLoc2838, dwLoc283C, dwArg10, dwArg14, dwArg18);
				dwLoc2828_455 = 0x01;
				if (FORCE == 0x00)
				{
					if (eax_160 >= 0x00)
						print_error(gs, ~0x0F, 0x08054E98);
					else
						print_error(gs, ~0x0F, 0x08054E0C);
				}
				if (FORCE != 0x00)
				{
					if (eax_160 == 0x00)
						dwLoc2820_454 = 0x00;
					else
					{
						dwLoc2820_454 = 0x01;
						dwLoc2824_462 = 0x00;
					}
				}
			}
			if (dwLoc2824_462 != 0x00)
			{
				fprintf(eax_77, &bLoc1010, 0x00);
				fflush(eax_77);
			}
		}
		if (dwLoc2820_454 != 0x00)
		{
			if (dwLoc2828_455 == 0x00)
			{
				depstr(gs);
				strcpy(&bLoc2810, dwArg0C);
				fprintf(eax_77, "%s\t%i.%i.%i\t%s\t%s\n", dwArg0C, dwArg10, dwArg14, dwArg18, dwArg08, &bLoc2810);
			}
			else
			{
				depstr(gs);
				strcpy(&bLoc2810, dwArg0C);
				fprintf(eax_77, "%s\t%i.%i.%i\t%s\t%s\n", &bLoc1810, dwArg10, dwArg14, dwArg18, &bLoc2010, &bLoc2810);
			}
		}
		fclose(eax_77);
		fclose(eax_34);
	}
	if (dwLoc2814 == 0x00 || dwLoc281C_419 == 0x00)
	{
		memcpy(&g_b8063AC0, &g_v8054D54, 0x20);
		mkstemp(0x08063AC0, 0x08063AC0, 0x08054D54, 0x20);
		FILE * eax_330 = fopen(&g_b8063AC0, "w+");
		if (eax_330 == null)
		{
			strerror(*__errno_location());
			print_error(gs, ~0x0E, 0x08054F40);
		}
		atexit(&g_t8048FC2);
		depstr(gs);
		strcpy(&bLoc2810, dwArg0C);
		fprintf(eax_330, "%s\t%i.%i.%i\t%s\t%s\n", dwArg0C, dwArg10, dwArg14, dwArg18, dwArg08, &bLoc2810);
		fclose(eax_330);
	}
	if ((eax_19 ^ gs->dw0014) == 0x00)
		return;
	__stack_chk_fail();
}

// 0804B5E3: void deregister_extension(Register (ptr32 Eq_67) gs, Stack (ptr32 char) dwArg08, Stack Eq_95 dwArg0C)
// Called from:
//      uninstall
void deregister_extension(struct Eq_67 * gs, char * dwArg08, Eq_95 dwArg0C)
{
	int32 dwLoc2834;
	int32 dwLoc2830;
	int32 dwLoc282C;
	char bLoc2810;
	char bLoc2010;
	char bLoc1810;
	char bLoc1010;
	char bLoc0810;
	FILE * dwLoc2824;
	word32 eax_16 = gs->dw0014;
	sprintf(&bLoc0810, "%s/etc/extensions.db", dwArg0C);
	word32 dwLoc2818_258 = 0x00;
	FILE * eax_31 = fopen(&bLoc0810, "r");
	if (eax_31 == null)
	{
		if (*__errno_location() == 0x02 && FORCE == 0x00)
		{
			fclose(eax_31);
			print_error(gs, ~0x12, 0x08054FBC);
		}
		if (FORCE == 0x00)
		{
			fclose(eax_31);
			strerror(*__errno_location());
			print_error(gs, ~0x12, 134565142);
		}
	}
	else
		dwLoc2818_258 = 0x01;
	if (dwLoc2818_258 != 0x00)
	{
		memcpy(&g_b8063AC0, &g_v8054D54, 0x20);
		mkstemp(0x08063AC0, 0x08063AC0, 0x08054D54, 0x20, 0x00);
		FILE * eax_94 = fopen(&g_b8063AC0, "w+");
		dwLoc2824 = eax_94;
		if (eax_94 == null && FORCE == 0x00)
		{
			strerror(*__errno_location());
			print_error(gs, ~0x12, 134565868);
		}
		atexit(&g_t8048FC2);
		dwLoc2818_258 = 0x01;
	}
	if (dwLoc2818_258 != 0x00)
	{
		word32 dwLoc2828_301 = 0x00;
		while (nc_fgets_nb(&bLoc1010, 0x0800, eax_31) != 0x00)
		{
			if (__isoc99_sscanf(&bLoc1010, "%s\t%i.%i.%i\t%s\t%s", &bLoc1810, &dwLoc282C, &dwLoc2830, &dwLoc2834, &bLoc2010, &bLoc2810) <= 0x00)
				continue;
			word32 dwLoc281C_315 = 0x01;
			if (strcmp(dwArg08, &bLoc1810) == 0x00)
			{
				dwLoc281C_315 = 0x00;
				dwLoc2828_301 = 0x01;
			}
			if (dwLoc281C_315 == 0x00)
				continue;
			if (strstr(&bLoc2810, dwArg08) != null && FORCE == 0x00)
				print_error(gs, ~0x12, 0x0805506C);
			fprintf(dwLoc2824, &bLoc1010, 0x00);
		}
		if (dwLoc2828_301 == 0x00)
			print_error(gs, ~0x12, 0x080550A4);
		fclose(eax_31);
		fclose(dwLoc2824);
	}
	if ((eax_16 ^ gs->dw0014) == 0x00)
		return;
	__stack_chk_fail();
}

// 0804B961: void check_dependencies(Register (ptr32 Eq_67) gs, Stack (ptr32 char) dwArg04, Stack Eq_95 dwArg08, Stack Eq_95 dwArg0C)
// Called from:
//      source_install
//      bin_install
//      test_install
void check_dependencies(struct Eq_67 * gs, char * dwArg04, Eq_95 dwArg08, Eq_95 dwArg0C)
{
	int32 dwLoc284C;
	int32 dwLoc2848;
	int32 dwLoc2844;
	int32 dwLoc2840;
	int32 dwLoc283C;
	int32 dwLoc2838;
	char bLoc2820;
	char bLoc2020;
	char bLoc1820;
	char bLoc1020;
	char bLoc0820;
	word32 eax_25 = gs->dw0014;
	if (FORCE == 0x00)
	{
		FILE * eax_37 = fopen("../depends", "r");
		if (eax_37 != null)
		{
			sprintf(&bLoc0820, "%s/etc/extensions.db", dwArg08);
			word32 dwLoc2828_366 = 0x01;
			FILE * eax_69 = fopen(&bLoc0820, "r");
			if (eax_69 == null)
			{
				if (*__errno_location() != 0x02)
				{
					fclose(eax_69);
					strerror(*__errno_location());
					print_error(gs, ~0x10, 134565142);
				}
				dwLoc2828_366 = 0x00;
			}
			do
			{
				if (nc_fgets_nb(&bLoc1020, 0x0800, eax_37) == 0x00)
				{
					if (dwLoc2828_366 != 0x00)
						fclose(eax_69);
					fclose(eax_37);
					goto l0804BE67;
				}
				dwLoc2838 = 0x00;
				dwLoc283C = 0x00;
				dwLoc2840 = 0x00;
				dwLoc2844 = 0x00;
				dwLoc2848 = 0x00;
				dwLoc284C = 0x00;
				if (__isoc99_sscanf(&bLoc1020, "%s\t%i.%i.%i", &bLoc2820, &dwLoc2844, &dwLoc2848, &dwLoc284C) <= 0x00)
					continue;
				if (strcmp(&bLoc2820, "GRASS") != 0x00)
				{
					if (dwLoc2828_366 == 0x00)
						continue;
					rewind(eax_69);
					word32 dwLoc282C_395 = 0x00;
					while (nc_fgets_nb(&bLoc1820, 0x0800, eax_69) != 0x00)
					{
						dwLoc2838 = 0x00;
						dwLoc283C = 0x00;
						dwLoc2840 = 0x00;
						if (__isoc99_sscanf(&bLoc1820, "%s\t%i.%i.%i", &bLoc2020, &dwLoc2838, &dwLoc283C, &dwLoc2840) <= 0x00 || strcmp(&bLoc2020, &bLoc2820) != 0x00)
							continue;
						if (vercmp(dwLoc2838, dwLoc283C, dwLoc2840, dwLoc2844, dwLoc2848, dwLoc284C) < 0x00)
							print_error(gs, ~0x11, 0x0805514C);
						dwLoc282C_395 = 0x01;
					}
					if (dwLoc282C_395 != 0x00)
						continue;
					print_error(gs, ~0x11, 0x080551BC);
				}
				__isoc99_sscanf(dwArg0C, "%i.%i.%i", &dwLoc2838, &dwLoc283C, &dwLoc2840);
			} while (vercmp(dwLoc2838, dwLoc283C, dwLoc2840, dwLoc2844, dwLoc2848, dwLoc284C) >= 0x00);
			print_error(gs, ~0x11, 0x08055100);
		}
		if (*__errno_location() != 0x02)
		{
			fclose(eax_37);
			strerror(*__errno_location());
			print_error(gs, ~0x10, 134565142);
		}
		fprintf(stderr, "\n%s/depends ENOENT\n", dwArg04);
	}
l0804BE67:
	if ((eax_25 ^ gs->dw0014) == 0x00)
		return;
	__stack_chk_fail();
}

// 0804BE84: Register word32 is_submenu(Stack (ptr32 char) dwArg04)
// Called from:
//      new_submenu
word32 is_submenu(char * dwArg04)
{
	word32 eax_39;
	if (strchr(dwArg04, '[') == null)
		eax_39 = 0x00;
	else if (strrchr(dwArg04, ']') == null)
		eax_39 = 0x00;
	else if (strchr(dwArg04, '[') > strrchr(dwArg04, ']'))
		eax_39 = 0x00;
	else
		eax_39 = 0x01;
	return eax_39;
}

// 0804BF05: void check_ext_menu(Register (ptr32 Eq_67) gs, Stack (ptr32 (arr (ptr32 char))) dwArg04)
// Called from:
//      register_entries_gisman
//      restore_entries_gisman
void check_ext_menu(struct Eq_67 * gs, char * (* dwArg04)[])
{
	if (find_pos("\"&Xtns\" all options 1", dwArg04, 0x00) != ~0x00)
		return;
	int32 eax_28 = find_pos("\"&Help\" all options", dwArg04, 0x00);
	if (eax_28 != ~0x00)
	{
		insert_str(gs, &g_t8055232, eax_28, dwArg04);
		insert_str(gs, &g_t805524C, eax_28 + 0x01, dwArg04);
	}
	else
	{
		int32 eax_73 = find_pos("}]", dwArg04, 0x00);
		if (eax_73 != ~0x00)
		{
			insert_str(gs, &g_t8055232, eax_73, dwArg04);
			insert_str(gs, &g_t805524C, eax_73 + 0x01, dwArg04);
		}
		else
			print_error(gs, ~0x14, 0x08055215);
	}
}

// 0804C009: Register word32 new_submenu(Register (ptr32 Eq_67) gs, Stack (ptr32 char) dwArg04, Stack (ptr32 char) dwArg08, Stack (arr (ptr32 char)) dwArg0C)
// Called from:
//      register_entries_gisman
//      restore_entries_gisman
word32 new_submenu(struct Eq_67 * gs, char * dwArg04, char * dwArg08, char * dwArg0C[])
{
	char bLoc1810;
	char bLoc1010;
	char bLoc0810;
	word32 eax_19 = gs->dw0014;
	int32 eax_29 = find_pos("\"&Xtns\" all options", dwArg0C, 0x00);
	int32 eax_44 = find_pos("\" all options", dwArg0C, eax_29 + 0x01);
	int32 dwLoc1814_350 = eax_29;
	int32 dwLoc1820_354 = eax_44 - 0x01;
	if (eax_44 == 0x00)
		dwLoc1820_354 = find_pos("}]", dwArg0C, 0x00);
	word32 eax_297;
	if (is_submenu(dwArg08) == 0x00)
	{
		print_warning(gs, 134566516);
		eax_297 = ~0x00;
	}
	else
	{
		int32 edx_92 = strrchr(dwArg08, ']') - strchr(dwArg08, '[');
		strncpy(&bLoc0810, strchr(dwArg08, '[') + 1, edx_92);
		(&bLoc0810)[edx_92 - 0x01].u0 = 0x00;
		sprintf(&bLoc1810, "{cascad \"%s\"", &bLoc0810);
		int32 eax_123 = find_pos(&bLoc1810, dwArg0C, eax_29);
		if (eax_123 != ~0x00 && eax_123 < dwLoc1820_354)
		{
			print_warning(gs, 0x080552BC);
			eax_297 = ~0x00;
		}
		else
		{
			int32 dwLoc181C_385 = eax_29 + 0x01;
			int32 dwLoc1818_390 = find_pos("{cascad ", dwArg0C, eax_29);
			while (dwLoc1818_390 != ~0x00 && dwLoc1818_390 < dwLoc1820_354)
			{
				char * eax_170 = strchr(dwArg0C[dwLoc1818_390], '\"');
				int32 ecx_181 = strchr(eax_170 + 1, '\"') - eax_170;
				strncpy(&bLoc1010, eax_170 + 1, ecx_181);
				(&bLoc1010)[ecx_181 - 0x01].u0 = 0x00;
				if (strcmp(&bLoc0810, &bLoc1010) < 0x00)
				{
					dwLoc181C_385 = dwLoc1818_390;
					break;
				}
				int32 v18_204 = dwLoc1814_350 + 0x01;
				dwLoc1814_350 = v18_204;
				dwLoc1818_390 = find_pos("{cascad ", dwArg0C, v18_204);
			}
			sprintf(&bLoc0810, " \t\t\t%s {} \"\" 1 {\n", &bLoc1810);
			insert_str(gs, &bLoc0810, dwLoc181C_385, dwArg0C);
			insert_str(gs, &g_t8055308, dwLoc181C_385 + 1, dwArg0C);
			int32 eax_265 = find_pos("}]", dwArg0C, 0x00);
			sprintf(&bLoc0810, "#(DO_NOT_REMOVE_THIS_COMMENT) <%s> %s {} \"\" 1 {\n", dwArg04, &bLoc1810);
			insert_str(gs, &bLoc0810, eax_265 + 1, dwArg0C);
			eax_297 = dwLoc181C_385 + 0x01;
		}
	}
	if ((eax_19 ^ gs->dw0014) == 0x00)
		return eax_297;
	__stack_chk_fail();
}

// 0804C41B: Register word32 new_item(Register (ptr32 Eq_67) gs, Stack Eq_599 dwArg04, Stack (ptr32 (arr (ptr32 char))) dwArg0C, Stack int32 dwArg10)
// Called from:
//      register_entries_gisman
//      restore_entries_gisman
word32 new_item(struct Eq_67 * gs, Eq_599 dwArg04, char * (* dwArg0C)[], int32 dwArg10)
{
	word32 dwLoc1810;
	char bLoc1010;
	char bLoc0810;
	word32 eax_126;
	word32 eax_16 = gs->dw0014;
	chop(dwArg04);
	char * eax_34 = strtok(dwArg04, ";");
	char * dwLoc1814_174 = eax_34;
	if (eax_34 == null)
	{
		print_warning(gs, 0x08055344);
		eax_126 = ~0x00;
	}
	else
	{
		strcpy(&bLoc0810, eax_34);
		int32 dwLoc1818_177 = 0x00;
		while (dwLoc1814_174 != null)
		{
			char * eax_52 = strtok(null, ";");
			dwLoc1814_174 = eax_52;
			if (eax_52 != null)
				strcpy(&bLoc1010, eax_52);
			++dwLoc1818_177;
		}
		if (dwLoc1818_177 > 0x02)
		{
			print_warning(gs, 0x08055368);
			eax_126 = ~0x00;
		}
		else
		{
			if (strcmp(&bLoc0810, "-") == 0x00 && strcmp(&bLoc0810, "-") == 0x00)
				memcpy(&dwLoc1810, &g_v805539E, 0x12);
			else
				sprintf(&dwLoc1810, " \t\t\t {command \"%s\" {} \"%s\" {} -command {%s }}\n", &bLoc0810, &bLoc1010, &bLoc1010);
			insert_str(gs, &dwLoc1810, dwArg10, dwArg0C);
			eax_126 = dwArg10 + 0x01;
		}
	}
	if ((eax_16 ^ gs->dw0014) == 0x00)
		return eax_126;
	__stack_chk_fail();
}

// 0804C5F0: void register_entries_gisman(Register (ptr32 Eq_67) gs, Stack (ptr32 char) dwArg04, Stack Eq_95 dwArg08)
// Called from:
//      source_install
//      bin_install
//      test_install
void register_entries_gisman(struct Eq_67 * gs, char * dwArg04, Eq_95 dwArg08)
{
	char bLoc1810;
	char bLoc1010;
	word32 dwLoc0810;
	int32 dwLoc1830;
	word32 eax_17 = gs->dw0014;
	memcpy(&dwLoc0810, &g_v80553DF, 0x12);
	FILE * eax_30 = fopen(&dwLoc0810, "r");
	if (eax_30 == null)
	{
		if (*__errno_location() != 0x02)
		{
			fclose(eax_30);
			strerror(*__errno_location());
			print_error(gs, ~0x14, 0x080553F3);
		}
	}
	else
	{
		sprintf(&dwLoc0810, "%s/etc/dm/menu.tcl", dwArg08);
		FILE * eax_61 = fopen(&dwLoc0810, "r");
		if (eax_61 == null)
		{
			if (*__errno_location() != 0x02)
			{
				fclose(eax_61);
				strerror(*__errno_location());
				print_error(gs, ~0x14, 0x080553F3);
			}
		}
		else
		{
			memcpy(&g_b80642C0, &g_v8055424, 0x20);
			mkstemp(0x080642C0, 0x080642C0, 0x08055424, 0x20);
			FILE * eax_94 = fopen(&g_b80642C0, "w+");
			if (eax_94 == null)
			{
				strerror(*__errno_location());
				print_error(gs, ~0x14, 0x08055448);
			}
			atexit(&g_t8048FC2);
			if (VERBOSE != 0x00)
				sprintf(&bLoc1010, "mkdir --verbose %s/etc/dm/gem-entries ; cp -vf ../entries-gisman %s/etc/dm/gem-entries/%s ; \t\t\t\t\tcp -vf %s/etc/dm/menu.tcl %s/etc/dm/menu.tcl.gem.bak ; \t\t\t\t\tcp -vf %s %s/etc/dm/menu.tcl ; chmod -v a+r %s/etc/dm/menu.tcl ;", dwArg08, dwArg08, dwArg04, dwArg08, dwArg08, &g_b80642C0, dwArg08, dwArg08);
			else
				sprintf(&bLoc1010, "mkdir %s/etc/dm/gem-entries &> %s ; cp -f ../entries-gisman %s/etc/dm/gem-entries/%s &> %s ; \t\t\t\t\tcp -f %s/etc/dm/menu.tcl %s/etc/dm/menu.tcl.gem.bak &> %s ; \t\t\t\t\tcp -f %s %s/etc/dm/menu.tcl &> %s ; chmod a+r %s/etc/dm/menu.tcl &> %s ;", dwArg08, &g_b80672C0, dwArg08, dwArg04, &g_b80672C0, dwArg08, dwArg08, &g_b80672C0, &g_b80642C0, dwArg08, &g_b80672C0, dwArg08, &g_b80672C0);
			strcpy(&g_b80682E0, &bLoc1010);
			ui32 dwLoc181C_601 = 0x00;
			while (fgets(&bLoc1010, 0x0800, eax_30) != null)
				++dwLoc181C_601;
			if (dwLoc181C_601 != 0x00)
			{
				rewind(eax_30);
				int32 dwLoc1820_620 = 0x00;
				while (fgets(&bLoc1010, 0x0800, eax_61) != null)
					++dwLoc1820_620;
				if (dwLoc1820_620 != 0x00)
				{
					rewind(eax_61, dwLoc1820_620);
					char * eax_235[] = calloc(dwLoc181C_601 * 0x02 + dwLoc1820_620 + 0x06, 0x04);
					int32 dwLoc1824_639;
					for (dwLoc1824_639 = 0x00; dwLoc181C_601 * 0x02 + dwLoc1820_620 + 0x06 > dwLoc1824_639; ++dwLoc1824_639)
						eax_235[dwLoc1824_639] = null;
					ui32 dwLoc1824_645 = 0x00;
					while (fgets(&bLoc1010, 0x0800, eax_61) != null)
					{
						eax_235[dwLoc1824_645] = malloc((word32) strlen(&bLoc1010) + 1);
						strcpy(eax_235[dwLoc1824_645], &bLoc1010);
						++dwLoc1824_645;
					}
					check_ext_menu(gs, eax_235);
					word32 dwLoc1824_658 = 0x01;
					while (nc_fgets_nb(&bLoc1010, 0x0800, eax_30) != 0x00)
					{
						if (dwLoc1824_658 != 0x01)
						{
							int32 eax_331 = new_item(gs, &bLoc1010, eax_235, dwLoc1830);
							dwLoc1830 = eax_331;
							if (eax_331 >= 0x00)
							{
								++dwLoc1824_658;
								continue;
							}
							else
							{
								print_warning(gs, 0x080556B8);
								break;
							}
						}
						int32 edx_361 = strrchr(&bLoc1010, ']') - strchr(&bLoc1010, '[');
						strncpy(&bLoc1810, strchr(&bLoc1010, '[') + 1, edx_361);
						(&bLoc1810)[edx_361 - 0x01].u0 = 0x00;
						int32 eax_385 = new_submenu(gs, dwArg04, &bLoc1010, eax_235);
						dwLoc1830 = eax_385;
						if (eax_385 < 0x00)
						{
							print_warning(gs, 0x08055690);
							break;
						}
						++dwLoc1824_658;
					}
					ui32 dwLoc1824_693 = 0x00;
					while (eax_235[dwLoc1824_693] != null)
					{
						fprintf(eax_94, eax_235[dwLoc1824_693], 0x00);
						++dwLoc1824_693;
					}
					fflush(eax_94);
					rewind(eax_94, eax_94);
					int32 dwLoc182C_727 = 0x00;
					while (fgets(&bLoc1010, 0x0800, eax_94) != null)
						++dwLoc182C_727;
					if (dwLoc182C_727 == 0x00 || dwLoc182C_727 < dwLoc1820_620)
					{
						print_warning(gs, 0x080556E4);
						memcpy(&g_b80682E0, &g_v8055722, 0x01);
					}
					fclose(eax_61);
					fclose(eax_30);
					fclose(eax_94);
					int32 dwLoc1824_760;
					for (dwLoc1824_760 = 0x00; dwLoc181C_601 * 0x02 + dwLoc1820_620 + 0x06 > dwLoc1824_760; ++dwLoc1824_760)
						free(eax_235[dwLoc1824_760]);
					free(eax_235);
				}
			}
		}
	}
	if ((eax_17 ^ gs->dw0014) == 0x00)
		return;
	__stack_chk_fail();
}

// 0804CD6C: void register_entries_gisman2(Register (ptr32 Eq_67) gs, Stack (ptr32 char) dwArg04, Stack Eq_95 dwArg08)
// Called from:
//      source_install
//      bin_install
//      test_install
void register_entries_gisman2(struct Eq_67 * gs, char * dwArg04, Eq_95 dwArg08)
{
	char bLoc1010;
	word32 dwLoc0810;
	word32 eax_14 = gs->dw0014;
	memcpy(&dwLoc0810, &g_v8055723, 0x13);
	FILE * eax_27 = fopen(&dwLoc0810, "r");
	if (eax_27 == null)
	{
		if (*__errno_location() != 0x02)
		{
			fclose(eax_27);
			strerror(*__errno_location());
			print_error(gs, ~0x1F, 0x080553F3);
		}
	}
	else
	{
		if (VERBOSE != 0x00)
			sprintf(&bLoc1010, "mkdir --verbose -p %s/etc/gm/Xtns ; cp -fv ../entries-gisman2 %s/etc/gm/Xtns/%s.gem ; ", dwArg08, dwArg08, dwArg04);
		else
			sprintf(&bLoc1010, "mkdir -p %s/etc/gm/Xtns ; cp -f ../entries-gisman2 %s/etc/gm/Xtns/%s.gem ; ", dwArg08, dwArg08, dwArg04);
		strcpy(&g_b8068AE0, &bLoc1010);
	}
	if ((eax_14 ^ gs->dw0014) == 0x00)
		return;
	__stack_chk_fail();
}

// 0804CEC7: Register word32 deregister_entries_gisman(Register (ptr32 Eq_67) gs, Stack (ptr32 char) dwArg04, Stack Eq_95 dwArg08)
// Called from:
//      uninstall
word32 deregister_entries_gisman(struct Eq_67 * gs, char * dwArg04, Eq_95 dwArg08)
{
	char bLoc1810;
	char bLoc1010;
	char bLoc0810;
	word32 eax_594;
	word32 eax_17 = gs->dw0014;
	sprintf(&bLoc0810, "%s/etc/dm/menu.tcl", dwArg08);
	FILE * eax_31 = fopen(&bLoc0810, "r");
	if (eax_31 == null)
	{
		if (*__errno_location() != 0x02)
		{
			fclose(eax_31);
			strerror(*__errno_location());
			print_error(gs, ~0x15, 0x080553F3);
		}
		eax_594 = 0x00;
	}
	else
	{
		memcpy(&g_b80642C0, &g_v8055424, 0x20);
		mkstemp(0x080642C0, 0x080642C0, 0x08055424, 0x20);
		FILE * eax_65 = fopen(&g_b80642C0, "w+");
		if (eax_65 == null)
		{
			strerror(*__errno_location());
			print_error(gs, ~0x14, 0x08055448);
		}
		atexit(&g_t8048FC2);
		if (VERBOSE != 0x00)
			sprintf(&bLoc1010, "cp -vf %s/etc/dm/menu.tcl %s/etc/dm/menu.tcl.gem.bak ; \t\t\t\t\t\tcp -vf %s %s/etc/dm/menu.tcl ; chmod -v a+r %s/etc/dm/menu.tcl ;", dwArg08, dwArg08, &g_b80642C0, dwArg08, dwArg08);
		else
			sprintf(&bLoc1010, "cp -f %s/etc/dm/menu.tcl %s/etc/dm/menu.tcl.gem.bak &> %s ; \t\t\t\t\t\tcp -f %s %s/etc/dm/menu.tcl &> %s ; chmod a+r %s/etc/dm/menu.tcl &> %s ;", dwArg08, dwArg08, &g_b80672C0, &g_b80642C0, dwArg08, &g_b80672C0, dwArg08, &g_b80672C0);
		strcpy(&g_b80682E0, &bLoc1010);
		word32 dwLoc1818_709 = 0x00;
		while (fgets(&bLoc1010, 0x0800, eax_31) != null)
			++dwLoc1818_709;
		if (dwLoc1818_709 == 0x00)
			eax_594 = ~0x00;
		else
		{
			rewind(eax_31);
			char * eax_164[] = calloc(dwLoc1818_709 + 0x01, 0x04);
			int32 dwLoc181C_731;
			for (dwLoc181C_731 = 0x00; dwLoc1818_709 + 0x01 > dwLoc181C_731; ++dwLoc181C_731)
				eax_164[dwLoc181C_731] = null;
			ui32 dwLoc181C_736 = 0x00;
			while (fgets(&bLoc1010, 0x0800, eax_31) != null)
			{
				eax_164[dwLoc181C_736] = malloc((word32) strlen(&bLoc1010) + 1);
				strcpy(eax_164[dwLoc181C_736], &bLoc1010);
				++dwLoc181C_736;
			}
			sprintf(&bLoc1010, "#(DO_NOT_REMOVE_THIS_COMMENT) <%s> {cascad", dwArg04);
			int32 eax_228 = find_pos(&bLoc1010, eax_164, 0x00);
			if (eax_228 == ~0x00)
			{
				print_warning(gs, 0x08055914);
				eax_594 = ~0x00;
			}
			else
			{
				char * eax_244 = strchr(eax_164[eax_228], '\"');
				char * eax_251 = strchr(eax_244 + 1, '\"');
				strcpy(&bLoc1810, eax_244 + 1);
				(&bLoc1810)[eax_251 - (eax_244 + 1)].u0 = 0x00;
				int32 eax_269 = find_pos("\"&Xtns\" all options 1", eax_164, 0x00);
				int32 eax_284 = find_pos("\" all options", eax_164, eax_269 + 0x01);
				int32 dwLoc1838_777 = eax_284 - 0x01;
				if (eax_284 == 0x00)
					dwLoc1838_777 = find_pos("}]", eax_164, 0x00);
				if (eax_269 == ~0x00)
				{
					print_warning(gs, 0x08055949);
					eax_594 = ~0x00;
				}
				else
				{
					sprintf(&bLoc1010, "{cascad \"%s\"", &bLoc1810);
					int32 eax_325 = find_pos(&bLoc1010, eax_164, eax_269);
					if (eax_325 != ~0x00 && eax_325 <= dwLoc1838_777)
					{
						int32 eax_343 = find_pos(" \t\t\t}}", eax_164, eax_325);
						if (eax_343 != ~0x00 && eax_343 <= dwLoc1838_777)
						{
							word32 dwLoc184C_796 = 0x01;
							int32 dwLoc181C_797;
							for (dwLoc181C_797 = 0x00; eax_343 - eax_325 + 0x01 > dwLoc181C_797; ++dwLoc181C_797)
							{
								delete_str(gs, eax_325, eax_164);
								++dwLoc184C_796;
							}
							sprintf(&bLoc1010, "#(DO_NOT_REMOVE_THIS_COMMENT) <%s> {cascad", dwArg04);
							delete_str(gs, find_pos(&bLoc1010, eax_164, 0x00), eax_164);
							int32 eax_424 = find_pos("\"&Xtns\" all options 1", eax_164, 0x00);
							int32 eax_439 = find_pos("\" all options", eax_164, eax_424 + 0x01);
							word32 dwLoc184C_818 = dwLoc184C_796 + 0x00;
							if (eax_439 - 0x01 - eax_424 <= 0x02)
							{
								int32 dwLoc181C_827;
								for (dwLoc181C_827 = 0x00; eax_439 - 0x01 - eax_424 + 0x01 > dwLoc181C_827; ++dwLoc181C_827)
								{
									delete_str(gs, eax_424, eax_164);
									++dwLoc184C_818;
								}
							}
							ui32 dwLoc181C_837 = 0x00;
							while (eax_164[dwLoc181C_837] != null)
							{
								fprintf(eax_65, eax_164[dwLoc181C_837], 0x00);
								++dwLoc181C_837;
							}
							fflush(eax_65);
							rewind(eax_65, eax_65);
							word32 dwLoc1824_881 = 0x00;
							while (fgets(&bLoc1010, 0x0800, eax_65) != null)
								++dwLoc1824_881;
							if (dwLoc1824_881 == 0x00)
							{
								print_warning(gs, 0x080556E4);
								memcpy(&g_b80682E0, &g_v8055722, 0x01);
							}
							fclose(eax_31);
							fclose(eax_65);
							int32 dwLoc181C_902;
							for (dwLoc181C_902 = 0x00; dwLoc1818_709 + 0x01 > dwLoc181C_902; ++dwLoc181C_902)
								free(eax_164[dwLoc181C_902]);
							free(eax_164);
							eax_594 = dwLoc184C_818;
						}
						else
						{
							print_warning(gs, 0x080559A4);
							eax_594 = ~0x00;
						}
					}
					else
					{
						print_warning(gs, 0x08055968);
						eax_594 = ~0x00;
					}
				}
			}
		}
	}
	if ((eax_17 ^ gs->dw0014) == 0x00)
		return eax_594;
	__stack_chk_fail();
}

// 0804D743: void deregister_entries_gisman2(Register (ptr32 Eq_67) gs, Stack (ptr32 char) dwArg04, Stack Eq_95 dwArg08)
// Called from:
//      uninstall
void deregister_entries_gisman2(struct Eq_67 * gs, char * dwArg04, Eq_95 dwArg08)
{
	char bLoc1010;
	char bLoc0810;
	word32 eax_14 = gs->dw0014;
	sprintf(&bLoc0810, "%s/etc/gm/Xtns/%s.gem", dwArg08, dwArg04);
	FILE * eax_30 = fopen(&bLoc0810, "r");
	if (eax_30 == null)
	{
		if (*__errno_location() != 0x02)
		{
			fclose(eax_30);
			strerror(*__errno_location());
			print_error(gs, ~0x20, 0x080553F3);
		}
	}
	else
	{
		if (VERBOSE != 0x00)
			sprintf(&bLoc1010, "rm -vf %s/etc/gm/Xtns/%s.gem ; ", dwArg08, dwArg04);
		else
			sprintf(&bLoc1010, "rm -f %s/etc/gm/Xtns/%s.gem ; ", dwArg08, dwArg04);
		strcpy(&g_b80682E0, &bLoc1010);
	}
	if ((eax_14 ^ gs->dw0014) == 0x00)
		return;
	__stack_chk_fail();
}

// 0804D896: Register word32 restore_entries_gisman(Register (ptr32 Eq_67) gs, Stack Eq_95 dwArg04)
// Called from:
//      restore
word32 restore_entries_gisman(struct Eq_67 * gs, Eq_95 dwArg04)
{
	char bLoc2810;
	char bLoc2010;
	char bLoc1810;
	char bLoc1010;
	char bLoc0810;
	int32 dwLoc2828;
	word32 eax_556;
	word32 eax_15 = gs->dw0014;
	sprintf(&bLoc1810, "%s/etc/dm/menu.tcl", dwArg04);
	FILE * eax_29 = fopen(&bLoc1810, "r");
	if (eax_29 == null)
	{
		if (*__errno_location() != 0x02)
		{
			fclose(eax_29);
			strerror(*__errno_location());
			print_error(gs, ~0x14, 0x080553F3);
		}
		eax_556 = 0x00;
	}
	else
	{
		memcpy(&g_b80642C0, &g_v8055424, 0x20);
		mkstemp(0x080642C0, 0x080642C0, 0x08055424, 0x20);
		FILE * eax_63 = fopen(&g_b80642C0, "w+");
		if (eax_63 == null)
		{
			strerror(*__errno_location());
			print_error(gs, ~0x14, 0x08055448);
		}
		atexit(&g_t8048FC2);
		if (VERBOSE != 0x00)
			sprintf(&bLoc0810, "cp -vf %s/etc/dm/menu.tcl %s/etc/dm/menu.tcl.gem.bak ; \t\t\t\t\t\tcp -vf %s %s/etc/dm/menu.tcl ; chmod -v a+r %s/etc/dm/menu.tcl ;", dwArg04, dwArg04, &g_b80642C0, dwArg04, dwArg04);
		else
			sprintf(&bLoc0810, "cp -f %s/etc/dm/menu.tcl %s/etc/dm/menu.tcl.gem.bak &> %s ; \t\t\t\t\t\tcp -f %s %s/etc/dm/menu.tcl &> %s ; chmod a+r %s/etc/dm/menu.tcl &> %s ;", dwArg04, dwArg04, &g_b80672C0, &g_b80642C0, dwArg04, &g_b80672C0, dwArg04, &g_b80672C0);
		strcpy(&g_b80682E0, &bLoc0810);
		sprintf(&bLoc2010, "%s/etc/dm/gem-entries", dwArg04);
		DIR * eax_133 = opendir(&bLoc2010);
		if (eax_133 == null)
			eax_556 = 0x00;
		else
		{
			ui32 dwLoc281C_630 = 0x00;
			ui32 dwLoc2844_631 = 0x00;
			while (true)
			{
				struct dirent * eax_144 = readdir(eax_133);
				if (eax_144 == null)
					break;
				sprintf(&bLoc1810, "%s/%s", &bLoc2010, (char *) eax_144 + 11);
				FILE * eax_162 = fopen(&bLoc1810, "r");
				if (strcmp((char *) eax_144 + 11, ".") != 0x00 && strcmp((char *) eax_144 + 11, "..") != 0x00)
				{
					if (eax_162 == null)
						fclose(eax_162);
					else
					{
						while (fgets(&bLoc0810, 0x0800, eax_162) != null)
							++dwLoc281C_630;
						fclose(eax_162);
						++dwLoc2844_631;
					}
				}
				else
					fclose(eax_162);
			}
			closedir(eax_133);
			word32 dwLoc2820_660 = 0x00;
			while (fgets(&bLoc0810, 0x0800, eax_29) != null)
				++dwLoc2820_660;
			if (dwLoc2820_660 == 0x00)
				eax_556 = 0x00;
			else
			{
				rewind(eax_29);
				char * eax_270[] = calloc(dwLoc281C_630 * 0x02 + dwLoc2844_631 * 0x05 + dwLoc2820_660 + 0x01, 0x04);
				int32 dwLoc2824_705;
				for (dwLoc2824_705 = 0x00; dwLoc281C_630 * 0x02 + dwLoc2844_631 * 0x05 + dwLoc2820_660 + 0x01 > dwLoc2824_705; ++dwLoc2824_705)
					eax_270[dwLoc2824_705] = null;
				ui32 dwLoc2824_712 = 0x00;
				while (fgets(&bLoc0810, 0x0800, eax_29) != null)
				{
					eax_270[dwLoc2824_712] = malloc((word32) strlen(&bLoc0810) + 1);
					strcpy(eax_270[dwLoc2824_712], &bLoc0810);
					++dwLoc2824_712;
				}
				eax_270[dwLoc2824_712] = null;
				check_ext_menu(gs, eax_270);
				DIR * eax_347 = opendir(&bLoc2010);
				word32 dwLoc2840_727 = 0x00;
				while (true)
				{
					struct dirent * eax_355 = readdir(eax_347);
					if (eax_355 == null)
						break;
					sprintf(&bLoc1810, "%s/%s", &bLoc2010, (char *) eax_355 + 11);
					if (strcmp((char *) eax_355 + 11, ".") != 0x00 && strcmp((char *) eax_355 + 11, "..") != 0x00)
					{
						FILE * eax_391 = fopen(&bLoc1810, "r");
						if (eax_391 != null)
						{
							word32 dwLoc2824_742 = 0x01;
							while (nc_fgets_nb(&bLoc0810, 0x0800, eax_391) != 0x00)
							{
								if (dwLoc2824_742 != 0x01)
								{
									int32 eax_426 = new_item(gs, &bLoc0810, eax_270, dwLoc2828);
									dwLoc2828 = eax_426;
									if (eax_426 < 0x00)
										break;
									++dwLoc2824_742;
									++dwLoc2840_727;
									continue;
								}
								int32 edx_450 = strrchr(&bLoc0810, ']') - strchr(&bLoc0810, '[');
								strncpy(&bLoc1010, strchr(&bLoc0810, '[') + 1, edx_450);
								(&bLoc1010)[edx_450 - 0x01].u0 = 0x00;
								int32 eax_474 = new_submenu(gs, &bLoc2810, &bLoc0810, eax_270);
								dwLoc2828 = eax_474;
								if (eax_474 < 0x00)
									break;
								++dwLoc2824_742;
								++dwLoc2840_727;
							}
							fclose(eax_391);
						}
					}
				}
				closedir(eax_347);
				ui32 dwLoc2824_780 = 0x00;
				while (eax_270[dwLoc2824_780] != null)
				{
					fprintf(eax_63, eax_270[dwLoc2824_780], 0x00);
					++dwLoc2824_780;
				}
				fflush(eax_63);
				fclose(eax_29);
				fclose(eax_63);
				int32 dwLoc2824_794;
				for (dwLoc2824_794 = 0x00; dwLoc281C_630 * 0x02 + dwLoc2844_631 * 0x05 + dwLoc2820_660 + 0x01 > dwLoc2824_794; ++dwLoc2824_794)
					free(eax_270[dwLoc2824_794]);
				free(eax_270);
				eax_556 = dwLoc2840_727;
			}
		}
	}
	if ((eax_15 ^ gs->dw0014) == 0x00)
		return eax_556;
	__stack_chk_fail();
}

// 0804E100: void new_ext_html(Register (ptr32 Eq_67) gs, Stack (ptr32 char) dwArg04, Stack (arr (ptr32 char)) dwArg0C, Stack int32 dwArg10, Stack int32 dwArg14, Stack int32 dwArg18)
// Called from:
//      register_html
//      restore_html
void new_ext_html(struct Eq_67 * gs, char * dwArg04, char * dwArg0C[], int32 dwArg10, int32 dwArg14, int32 dwArg18)
{
	char bLoc0810;
	word32 eax_16 = gs->dw0014;
	int32 eax_26 = find_pos("<b>Drivers sections:</b>", dwArg0C, 0x00);
	int32 dwLoc0814_379 = eax_26;
	if (eax_26 < 0x00)
	{
		int32 eax_40 = find_pos("<!-- GEM Extensions StartHTML. Do not delete or change this comment! -->", dwArg0C, 0x00);
		dwLoc0814_379 = eax_40;
		if (eax_40 < 0x00)
		{
			print_warning(gs, 134568636);
			goto l0804E55C;
		}
	}
	int32 eax_58 = find_pos("<hr>", dwArg0C, dwLoc0814_379);
	if (find_pos("<h3>Installed extensions:</h3>", dwArg0C, dwLoc0814_379) == ~0x00)
	{
		insert_str(gs, &g_t8055B24, eax_58, dwArg0C);
		insert_str(gs, &g_t8055B44, eax_58 + 1, dwArg0C);
		insert_str(gs, &g_t8055B4A, eax_58 + 2, dwArg0C);
		insert_str(gs, &g_t8055B51, eax_58 + 3, dwArg0C);
	}
	int32 eax_140 = find_pos("<h3>Installed extensions:</h3>", dwArg0C, dwLoc0814_379);
	int32 eax_153 = find_pos("</ul>", dwArg0C, eax_140);
	sprintf(&bLoc0810, "\">%s", dwArg04);
	int32 dwLoc0820_410 = eax_140;
	int32 dwLoc0828_415 = eax_140 + 0x02;
	int32 eax_178 = find_pos(&bLoc0810, dwArg0C, eax_140 + 0x02);
	if (eax_178 != ~0x00)
	{
		print_warning(gs, 0x08055B64);
		if (FORCE != 0x00 && UPGRADE != 0x00)
		{
			sprintf(&bLoc0810, "<li><a href=\"../extensions/%s/index.html\">%s (%i.%i.%i)</a>\n", dwArg04, dwArg04, dwArg10, dwArg14, dwArg18);
			strcpy(dwArg0C[eax_178], &bLoc0810);
		}
	}
	else
	{
		int32 dwLoc081C_428 = find_pos("<li><a href=", dwArg0C, eax_140);
		while (dwLoc081C_428 != ~0x00 && dwLoc081C_428 < eax_153)
		{
			char * eax_215 = strrchr(dwArg0C[dwLoc081C_428], '\"');
			int32 ecx_228 = strrchr(dwArg0C[dwLoc081C_428], '<') - eax_215;
			strncpy(&bLoc0810, eax_215 + 2, ecx_228);
			(&bLoc0810)[ecx_228 - 0x01].u0 = 0x00;
			if (strcmp(dwArg04, &bLoc0810) < 0x00)
			{
				dwLoc0828_415 = dwLoc081C_428;
				break;
			}
			int32 v17_251 = dwLoc0820_410 + 0x01;
			dwLoc0820_410 = v17_251;
			dwLoc081C_428 = find_pos("<li><a href=", dwArg0C, v17_251);
		}
		sprintf(&bLoc0810, "<li><a href=\"../extensions/%s/index.html\">%s (%i.%i.%i)</a>\n", dwArg04, dwArg04, dwArg10, dwArg14, dwArg18);
		insert_str(gs, &bLoc0810, dwLoc0828_415, dwArg0C);
	}
l0804E55C:
	if ((eax_16 ^ gs->dw0014) == 0x00)
		return;
	__stack_chk_fail();
}

// 0804E56F: void delete_ext_html(Register (ptr32 Eq_67) gs, Stack (ptr32 char) dwArg04, Stack (ptr32 (arr (ptr32 char))) dwArg0C)
// Called from:
//      deregister_html
void delete_ext_html(struct Eq_67 * gs, char * dwArg04, char * (* dwArg0C)[])
{
	char bLoc0810;
	word32 eax_16 = gs->dw0014;
	int32 eax_26 = find_pos("<b>Drivers sections:</b>", dwArg0C, 0x00);
	int32 dwLoc0814_249 = eax_26;
	if (eax_26 < 0x00)
	{
		int32 eax_40 = find_pos("<!-- GEM Extensions StartHTML. Do not delete or change this comment! -->", dwArg0C, 0x00);
		dwLoc0814_249 = eax_40;
		if (eax_40 < 0x00)
		{
			print_warning(gs, 0x08055BD8);
			goto l0804E7E0;
		}
	}
	find_pos("<hr>", dwArg0C, dwLoc0814_249);
	if (find_pos("<h3>Installed extensions:</h3>", dwArg0C, dwLoc0814_249) == ~0x00)
		print_warning(gs, 0x08055C20);
	else
	{
		int32 eax_85 = find_pos("<h3>Installed extensions:</h3>", dwArg0C, dwLoc0814_249);
		int32 eax_98 = find_pos("</ul>", dwArg0C, eax_85);
		sprintf(&bLoc0810, "\">%s", dwArg04);
		int32 eax_120 = find_pos(&bLoc0810, dwArg0C, eax_85);
		if (eax_120 == ~0x00)
			print_warning(gs, 0x08055C4C);
		else
		{
			if (eax_120 < eax_98)
				delete_str(gs, eax_120, dwArg0C);
			int32 eax_156 = find_pos("<ul>", dwArg0C, eax_85);
			if (eax_156 != ~0x00 && (eax_98 - 0x01 > eax_156 && (eax_98 - 0x01) - eax_156 <= 0x01))
			{
				int32 dwLoc082C_290;
				for (dwLoc082C_290 = 0x00; dwLoc082C_290 <= 0x03; ++dwLoc082C_290)
					delete_str(gs, eax_156 - 1, dwArg0C);
			}
		}
	}
l0804E7E0:
	if ((eax_16 ^ gs->dw0014) == 0x00)
		return;
	__stack_chk_fail();
}

// 0804E7F3: void register_html(Register (ptr32 Eq_67) gs, Stack (ptr32 char) dwArg04, Stack Eq_95 dwArg08, Stack int32 dwArg0C, Stack int32 dwArg10, Stack int32 dwArg14)
// Called from:
//      source_install
//      bin_install
//      test_install
void register_html(struct Eq_67 * gs, char * dwArg04, Eq_95 dwArg08, int32 dwArg0C, int32 dwArg10, int32 dwArg14)
{
	char bLoc1010;
	char bLoc0810;
	word32 eax_17 = gs->dw0014;
	sprintf(&bLoc0810, "%s/docs/html/index.html", dwArg08);
	FILE * eax_31 = fopen(&bLoc0810, "r");
	if (eax_31 == null)
	{
		if (*__errno_location() != 0x02)
		{
			fclose(eax_31);
			strerror(*__errno_location());
			print_error(gs, ~0x17, 0x08055C95);
		}
	}
	else
	{
		memcpy(&g_b8067AC0, &g_v8055CB4, 0x20);
		mkstemp(0x08067AC0, 0x08067AC0, 0x08055CB4, 0x20);
		FILE * eax_64 = fopen(&g_b8067AC0, "w+");
		if (eax_64 == null)
		{
			strerror(*__errno_location());
			print_error(gs, ~0x17, 0x08055CD8);
		}
		atexit(&g_t8048FC2);
		if (VERBOSE != 0x00)
			sprintf(&bLoc1010, "cp -vf %s %s/docs/html/index.html ; chmod -v a+r %s/docs/html/index.html ;", &g_b8067AC0, dwArg08, dwArg08);
		else
			sprintf(&bLoc1010, "cp -f %s %s/docs/html/index.html &>%s ; chmod a+r %s/docs/html/index.html &>%s ;", &g_b8067AC0, dwArg08, &g_b80672C0, dwArg08, &g_b80672C0);
		strcpy(&g_b80692E0, &bLoc1010);
		word32 dwLoc1018_331 = 0x00;
		while (fgets(&bLoc1010, 0x0800, eax_31) != null)
			++dwLoc1018_331;
		if (dwLoc1018_331 != 0x00)
		{
			rewind(eax_31);
			char * eax_151[] = calloc(dwLoc1018_331 + 0x0A, 0x04);
			int32 dwLoc101C_350;
			for (dwLoc101C_350 = 0x00; dwLoc1018_331 + 0x0A > dwLoc101C_350; ++dwLoc101C_350)
				eax_151[dwLoc101C_350] = null;
			ui32 dwLoc101C_355 = 0x00;
			while (fgets(&bLoc1010, 0x0800, eax_31) != null)
			{
				eax_151[dwLoc101C_355] = malloc((word32) strlen(&bLoc1010) + 1);
				strcpy(eax_151[dwLoc101C_355], &bLoc1010);
				++dwLoc101C_355;
			}
			new_ext_html(gs, dwArg04, eax_151, dwArg0C, dwArg10, dwArg14);
			ui32 dwLoc101C_396 = 0x00;
			while (eax_151[dwLoc101C_396] != null)
			{
				fprintf(eax_64, eax_151[dwLoc101C_396], 0x00);
				++dwLoc101C_396;
			}
			fflush(eax_64);
			fclose(eax_31);
			fclose(eax_64);
			int32 dwLoc101C_407;
			for (dwLoc101C_407 = 0x00; dwLoc1018_331 + 0x0A > dwLoc101C_407; ++dwLoc101C_407)
				free(eax_151[dwLoc101C_407]);
			free(eax_151);
		}
	}
	if ((eax_17 ^ gs->dw0014) == 0x00)
		return;
	__stack_chk_fail();
}

// 0804EC17: void deregister_html(Register (ptr32 Eq_67) gs, Stack (ptr32 char) dwArg04, Stack Eq_95 dwArg08)
// Called from:
//      uninstall
void deregister_html(struct Eq_67 * gs, char * dwArg04, Eq_95 dwArg08)
{
	char bLoc1010;
	char bLoc0810;
	word32 eax_17 = gs->dw0014;
	sprintf(&bLoc0810, "%s/docs/html/index.html", dwArg08);
	FILE * eax_31 = fopen(&bLoc0810, "r");
	if (eax_31 == null)
	{
		if (*__errno_location() != 0x02)
		{
			fclose(eax_31);
			strerror(*__errno_location());
			print_error(gs, ~0x17, 0x08055C95);
		}
	}
	else
	{
		memcpy(&g_b8067AC0, &g_v8055CB4, 0x20);
		mkstemp(0x08067AC0, 0x08067AC0, 0x08055CB4, 0x20);
		FILE * eax_64 = fopen(&g_b8067AC0, "w+");
		if (eax_64 == null)
		{
			strerror(*__errno_location());
			print_error(gs, ~0x17, 0x08055CD8);
		}
		atexit(&g_t8048FC2);
		if (VERBOSE != 0x00)
			sprintf(&bLoc1010, "cp -vf %s %s/docs/html/index.html ; chmod -v a+r %s/docs/html/index.html ;", &g_b8067AC0, dwArg08, dwArg08);
		else
			sprintf(&bLoc1010, "cp -f %s %s/docs/html/index.html &>%s ; chmod a+r %s/docs/html/index.html &>%s ;", &g_b8067AC0, dwArg08, &g_b80672C0, dwArg08, &g_b80672C0);
		strcpy(&g_b80692E0, &bLoc1010);
		word32 dwLoc1018_325 = 0x00;
		while (fgets(&bLoc1010, 0x0800, eax_31) != null)
			++dwLoc1018_325;
		if (dwLoc1018_325 != 0x00)
		{
			rewind(eax_31);
			char * eax_151[] = calloc(dwLoc1018_325 + 0x01, 0x04);
			int32 dwLoc101C_344;
			for (dwLoc101C_344 = 0x00; dwLoc1018_325 + 0x01 > dwLoc101C_344; ++dwLoc101C_344)
				eax_151[dwLoc101C_344] = null;
			ui32 dwLoc101C_349 = 0x00;
			while (fgets(&bLoc1010, 0x0800, eax_31) != null)
			{
				eax_151[dwLoc101C_349] = malloc((word32) strlen(&bLoc1010) + 1);
				strcpy(eax_151[dwLoc101C_349], &bLoc1010);
				++dwLoc101C_349;
			}
			delete_ext_html(gs, dwArg04, eax_151);
			ui32 dwLoc101C_372 = 0x00;
			while (eax_151[dwLoc101C_372] != null)
			{
				fprintf(eax_64, eax_151[dwLoc101C_372], 0x00);
				++dwLoc101C_372;
			}
			fflush(eax_64);
			fclose(eax_31);
			fclose(eax_64);
			int32 dwLoc101C_383;
			for (dwLoc101C_383 = 0x00; dwLoc1018_325 + 0x01 > dwLoc101C_383; ++dwLoc101C_383)
				free(eax_151[dwLoc101C_383]);
			free(eax_151);
		}
	}
	if ((eax_17 ^ gs->dw0014) == 0x00)
		return;
	__stack_chk_fail();
}

// 0804F026: Register word32 restore_html(Register (ptr32 Eq_67) gs, Stack Eq_95 dwArg04)
// Called from:
//      restore
word32 restore_html(struct Eq_67 * gs, Eq_95 dwArg04)
{
	int32 dwLoc284C;
	int32 dwLoc2848;
	int32 dwLoc2844;
	char bLoc2810;
	char bLoc2010;
	char bLoc1810;
	char bLoc1010;
	char bLoc0810;
	word32 eax_480;
	word32 eax_15 = gs->dw0014;
	sprintf(&bLoc1010, "%s/docs/html/index.html", dwArg04);
	FILE * eax_29 = fopen(&bLoc1010, "r");
	if (eax_29 == null)
	{
		if (*__errno_location() != 0x02)
		{
			fclose(eax_29);
			strerror(*__errno_location());
			print_error(gs, ~0x17, 0x08055C95);
		}
		eax_480 = 0x00;
	}
	else
	{
		memcpy(&g_b8067AC0, &g_v8055CB4, 0x20);
		mkstemp(0x08067AC0, 0x08067AC0, 0x08055CB4, 0x20);
		FILE * eax_63 = fopen(&g_b8067AC0, "w+");
		if (eax_63 == null)
		{
			strerror(*__errno_location());
			print_error(gs, ~0x17, 0x08055CD8);
		}
		if (VERBOSE != 0x00)
			sprintf(&bLoc0810, "cp -vf %s %s/docs/html/index.html ; chmod -v a+r %s/docs/html/index.html ;", &g_b8067AC0, dwArg04, dwArg04);
		else
			sprintf(&bLoc0810, "cp -f %s %s/docs/html/index.html &>%s ; chmod a+r %s/docs/html/index.html &>%s ;", &g_b8067AC0, dwArg04, &g_b80672C0, dwArg04, &g_b80672C0);
		strcpy(&g_b80692E0, &bLoc0810);
		atexit(&g_t8048FC2);
		sprintf(&bLoc2010, "%s/docs/extensions", dwArg04);
		DIR * eax_124 = opendir(&bLoc2010);
		if (eax_124 == null)
			eax_480 = 0x00;
		else
		{
			word32 dwLoc2840_553 = 0x00;
			while (true)
			{
				struct dirent * eax_135 = readdir(eax_124);
				if (eax_135 == null)
					break;
				sprintf(&bLoc2810, "%s/%s", &bLoc2010, (char *) eax_135 + 11);
				if (strcmp((char *) eax_135 + 11, ".") != 0x00 && strcmp((char *) eax_135 + 11, "..") != 0x00)
				{
					DIR * eax_169 = opendir(&bLoc2810);
					if (eax_169 != null)
					{
						closedir(eax_169);
						++dwLoc2840_553;
					}
				}
			}
			closedir(eax_124);
			word32 dwLoc281C_571 = 0x00;
			while (fgets(&bLoc0810, 0x0800, eax_29) != null)
				++dwLoc281C_571;
			if (dwLoc281C_571 == 0x00)
				eax_480 = 0x00;
			else
			{
				rewind(eax_29);
				char * eax_223[] = calloc(dwLoc281C_571 + dwLoc2840_553 + 0x0A, 0x04);
				int32 dwLoc2820_610;
				for (dwLoc2820_610 = 0x00; dwLoc281C_571 + dwLoc2840_553 + 0x0A > dwLoc2820_610; ++dwLoc2820_610)
					eax_223[dwLoc2820_610] = null;
				ui32 dwLoc2820_616 = 0x00;
				while (fgets(&bLoc0810, 0x0800, eax_29) != null)
				{
					eax_223[dwLoc2820_616] = malloc((word32) strlen(&bLoc0810) + 1);
					strcpy(eax_223[dwLoc2820_616], &bLoc0810);
					++dwLoc2820_616;
				}
				eax_223[dwLoc2820_616] = null;
				DIR * eax_284 = opendir(&bLoc2010);
				word32 dwLoc283C_630 = 0x00;
				while (true)
				{
					struct dirent * eax_292 = readdir(eax_284);
					if (eax_292 == null)
						break;
					sprintf(&bLoc2810, "%s/%s", &bLoc2010, (char *) eax_292 + 11);
					if (strcmp((char *) eax_292 + 11, ".") != 0x00 && strcmp((char *) eax_292 + 11, "..") != 0x00)
					{
						DIR * eax_326 = opendir(&bLoc2810);
						if (eax_326 != null)
						{
							closedir(eax_326);
							sprintf(&bLoc1810, "%s/index.html", &bLoc2810);
							FILE * eax_344 = fopen(&bLoc1810, "r");
							if (eax_344 != null)
							{
								dwLoc2844 = 0x00;
								dwLoc2848 = 0x00;
								dwLoc284C = 0x00;
								word32 dwLoc2820_651 = 0x00;
								do
								{
									if (fgets(&bLoc0810, 0x0800, eax_344) == null)
										goto l0804F611;
								} while (strstr(&bLoc0810, "<title>") == null);
								dwLoc2820_651 = 0x01;
l0804F611:
								if (dwLoc2820_651 != 0x00)
								{
									__isoc99_sscanf(strchr(&bLoc0810, '(') + 1, "%i.%i.%i", &dwLoc2844, &dwLoc2848, &dwLoc284C);
									new_ext_html(gs, (char *) eax_292 + 11, eax_223, dwLoc2844, dwLoc2848, dwLoc284C);
									fclose(eax_344);
									++dwLoc283C_630;
								}
							}
						}
					}
				}
				closedir(eax_284);
				ui32 dwLoc2820_690 = 0x00;
				while (eax_223[dwLoc2820_690] != null)
				{
					fprintf(eax_63, eax_223[dwLoc2820_690], 0x00);
					++dwLoc2820_690;
				}
				fflush(eax_63);
				fclose(eax_29);
				fclose(eax_63);
				int32 dwLoc2820_704;
				for (dwLoc2820_704 = 0x00; dwLoc281C_571 + dwLoc2840_553 + 0x0A > dwLoc2820_704; ++dwLoc2820_704)
					free(eax_223[dwLoc2820_704]);
				free(eax_223);
				eax_480 = dwLoc283C_630;
			}
		}
	}
	if ((eax_15 ^ gs->dw0014) == 0x00)
		return eax_480;
	__stack_chk_fail();
}

// 0804F7E8: void check_extension(Register (ptr32 Eq_67) gs, Stack (ptr32 char) dwArg04, Stack (ptr32 char) dwArg08, Stack (ptr32 int32) dwArg0C, Stack (ptr32 int32) dwArg10, Stack (ptr32 int32) dwArg14)
// Called from:
//      main
void check_extension(struct Eq_67 * gs, char * dwArg04, char * dwArg08, int32 * dwArg0C, int32 * dwArg10, int32 * dwArg14)
{
	ptr32 fp;
	char bLoc0810;
	word32 eax_26 = gs->dw0014;
	bLoc0810 = (char) 0x00;
	word32 * edi_198 = fp + ~0x080B;
	word32 ecx_199;
	for (ecx_199 = 0x01FF; ecx_199 != 0x00; --ecx_199)
	{
		*edi_198 = 0x00;
		++edi_198;
	}
	FILE * eax_40 = stdout;
	fwrite(&g_v8055E30, 0x01, 22, eax_40);
	strcpy(&bLoc0810, dwArg04);
	if (chdir(&bLoc0810, 0x08055E30, dwArg04, 0x01, 22, eax_40) >= 0x00)
	{
		FILE * eax_81 = fopen("id", "r");
		if (eax_81 != null)
		{
			__isoc99_fscanf(eax_81, 0x08055E89, &bLoc0810);
			if (strcmp("<GRASS extension package>", &bLoc0810) == 0x00)
			{
				fclose(eax_81);
				get_package_name(gs, ".", dwArg08);
				FILE * eax_127 = fopen("version", "r");
				if (eax_127 != null)
				{
					nc_fgets_nb(&bLoc0810, 0x0800, eax_127);
					*dwArg10 = 0x00;
					*dwArg14 = 0x00;
					if (__isoc99_sscanf(&bLoc0810, "%i.%i.%i", dwArg0C, dwArg10, dwArg14) > 0x00)
					{
						print_done();
						chdir(0x08055F35);
						fclose(eax_127);
						if ((eax_26 ^ gs->dw0014) == 0x00)
							return;
						__stack_chk_fail();
					}
					else
					{
						fclose(eax_127);
						print_error(gs, ~0x05, 0x08055F0C);
					}
				}
				else
					print_error(gs, ~0x05, 0x08055EE5);
			}
			else
			{
				fclose(eax_81);
				print_error(gs, ~0x05, 0x08055EC1);
			}
		}
		else
			print_error(gs, ~0x05, 0x08055E70);
	}
	else
	{
		strerror(*__errno_location());
		print_error(gs, ~0x01, 0x08055E48);
	}
}

// 0804FAAB: void unpack_extension(Register (ptr32 Eq_67) gs, Stack (ptr32 char) dwArg04)
// Called from:
//      main
void unpack_extension(struct Eq_67 * gs, char * dwArg04)
{
	char bLoc0810;
	word32 eax_12 = gs->dw0014;
	FILE * eax_18 = stdout;
	fwrite(&g_v8055F38, 0x01, 22, eax_18);
	memcpy(&g_b80632C0, &g_v8055F4F, 0x1C);
	mkstemp(0x080632C0, 0x080632C0, 0x08055F38, 0x08055F4F, 0x01, 0x1C, 22, eax_18, dwArg04, eax_12);
	int32 eax_38 = open(&g_b80632C0, 0x40);
	if (eax_38 != ~0x00)
	{
		if (VERBOSE != 0x00)
			fprintf(stdout, "\nUncompressing to: %s.\n", &g_b80632C0);
		close(eax_38);
		remove(0x080632C0, eax_38);
		mkdir_s(gs, &g_b80632C0, "0700");
		atexit(&g_t8048E89);
		sprintf(&bLoc0810, "cp %s %s", dwArg04, &g_b80632C0);
		if (system(&bLoc0810) >= 0x00)
		{
			word32 eax_96 = check_filetype(dwArg04);
			word32 dwLoc081C_376 = eax_96;
			if (eax_96 == 0x00)
			{
				print_warning(gs, 0x08055FEC);
				dwLoc081C_376 = 0x01;
			}
			if (dwLoc081C_376 == 0x01)
			{
				if (VERBOSE != 0x00)
					sprintf(&bLoc0810, "tar -xzvf %s/%s -C %s", &g_b80632C0, basename(dwArg04), &g_b80632C0);
				else
					sprintf(&bLoc0810, "tar -xzf %s/%s -C %s", &g_b80632C0, basename(dwArg04), &g_b80632C0);
			}
			if (dwLoc081C_376 == 0x02)
			{
				if (VERBOSE != 0x00)
					sprintf(&bLoc0810, "tar -xjvf %s/%s -C %s", &g_b80632C0, basename(dwArg04), &g_b80632C0);
				else
					sprintf(&bLoc0810, "tar -xjvf %s/%s -C %s", &g_b80632C0, basename(dwArg04), &g_b80632C0);
			}
			if (dwLoc081C_376 == 0x03)
			{
				if (VERBOSE != 0x00)
					sprintf(&bLoc0810, "unzip %s/%s -d %s", &g_b80632C0, basename(dwArg04), &g_b80632C0);
				else
					sprintf(&bLoc0810, "unzip -qq %s/%s -d %s", &g_b80632C0, basename(dwArg04), &g_b80632C0);
			}
			if (dwLoc081C_376 == 0x04)
			{
				if (VERBOSE != 0x00)
					sprintf(&bLoc0810, "tar -xvf %s/%s -C %s", &g_b80632C0, basename(dwArg04), &g_b80632C0);
				else
					sprintf(&bLoc0810, "tar -xf %s/%s -C %s", &g_b80632C0, basename(dwArg04), &g_b80632C0);
			}
			if (system(&bLoc0810) >= 0x00)
			{
				print_done();
				if ((eax_12 ^ gs->dw0014) == 0x00)
					return;
				__stack_chk_fail();
			}
			else if (dwLoc081C_376 != 0x01)
			{
				if (dwLoc081C_376 != 0x02)
				{
					if (dwLoc081C_376 != 0x03)
						exit(~0x06);
					else
						print_error(gs, ~0x06, 0x08056190);
				}
				else
					print_error(gs, ~0x06, 0x08056130);
			}
			else
				print_error(gs, ~0x06, 0x080560D0);
		}
		else
			print_error(gs, ~0x06, 0x08055FBC);
	}
	else
	{
		strerror(*__errno_location());
		print_error(gs, ~0x06, 0x08055F6C);
	}
}

// 0804FF43: void query_extension(Register (ptr32 Eq_67) gs, Stack (ptr32 char) dwArg04, Stack (ptr32 char) dwArg08, Stack int32 dwArg0C, Stack int32 dwArg10, Stack int32 dwArg14, Stack (ptr32 char) dwArg1C, Stack (ptr32 char) dwArg20)
// Called from:
//      main
void query_extension(struct Eq_67 * gs, char * dwArg04, char * dwArg08, int32 dwArg0C, int32 dwArg10, int32 dwArg14, char * dwArg1C, char * dwArg20)
{
	char bLoc0810;
	char * eax_28 = basename(dwArg04);
	strcpy(&bLoc0810, eax_28);
	if (chdir(&bLoc0810, eax_28) >= 0x00)
	{
		fprintf(stdout, "\nExtension '%s', version %i.%i.%i\n\n", dwArg08, dwArg0C, dwArg10, dwArg14);
		dump_ascii(gs, "description", "Description");
		dump_ascii(gs, "commands", "Commands provided");
		dump_ascii(gs, "libs", "Libraries provided");
		dump_ascii(gs, "headers", "Header files provided");
		dump_ascii(gs, "depends", "Dependencies");
		dump_ascii(gs, "bugs", "Bugs");
		sprintf(&bLoc0810, "../%s", dwArg04);
		list_binaries(gs, &bLoc0810);
		dump_ascii(gs, "authors", "Author(s)");
		fprintf(stdout, "Type '%s -d %s' to see more detailed information.\n", dwArg1C, dwArg20);
		fprintf(stdout, "Type '%s -l %s' to see copyright information.\n", dwArg1C, dwArg20);
		system("sh post");
		exit(0x00);
	}
	else
	{
		strerror(*__errno_location());
		print_error(gs, ~0x01, 0x08055E48);
	}
}

// 0805014E: void print_cfg(Register (ptr32 Eq_67) gs)
// Called from:
//      source_install
//      test_install
void print_cfg(struct Eq_67 * gs)
{
	char bLoc0810;
	word32 eax_10 = gs->dw0014;
	FILE * eax_17 = fopen("config.msg", "r");
	if (eax_17 != null)
	{
		fwrite(&g_v805631A, 0x01, 0x1B, stdout);
		while (fgets(&bLoc0810, 0x0800, eax_17) != null)
			fputs(&bLoc0810, stdout);
		fputc(0x0A, stdout);
	}
	remove(0x0805630F);
	if ((eax_10 ^ gs->dw0014) == 0x00)
		return;
	__stack_chk_fail();
}

// 08050220: void source_install(Register (ptr32 Eq_67) gs, Stack (ptr32 char) dwArg04, Stack Eq_95 dwArg08, Stack (ptr32 char) dwArg0C, Stack int32 dwArg10, Stack int32 dwArg14, Stack int32 dwArg18, Stack Eq_95 dwArg1C)
// Called from:
//      main
void source_install(struct Eq_67 * gs, char * dwArg04, Eq_95 dwArg08, char * dwArg0C, int32 dwArg10, int32 dwArg14, int32 dwArg18, Eq_95 dwArg1C)
{
	word32 dwLoc288C;
	char bLoc2810;
	word32 dwLoc2010;
	char bLoc1810;
	char bLoc1010;
	char bLoc0810;
	word32 eax_18 = gs->dw0014;
	if (stat(dwArg08, &dwLoc288C) >= 0x00)
	{
		sprintf(0x080592A0, "GINSTALL_DST=%s", dwArg08);
		putenv(0x080592A0, 0x080592A0, 0x0805635C, dwArg08);
		sprintf(&bLoc0810, "%s/include", dwArg08);
		sprintf(0x08059AA0, "GINSTALL_INC=%s", &bLoc0810);
		putenv(0x08059AA0, 0x08059AA0, 0x08056377, 0x0805636C, dwArg08);
		sprintf(&bLoc0810, "%s/lib", dwArg08);
		sprintf(0x0805A2A0, "GINSTALL_LIB=%s", &bLoc0810);
		putenv(0x0805A2A0, 0x0805A2A0, 0x0805638E, 0x08056387, dwArg08);
		sprintf(0x0805EAA0, "GEM_GRASS_DIR=%s", dwArg08);
		putenv(0x0805EAA0, 0x0805EAA0, 0x0805639E, dwArg08);
		char * eax_99 = strdup(dwArg1C);
		char * eax_105 = strtok(eax_99, ".");
		char * eax_110 = strtok(null, ".");
		char * eax_115 = strtok(null, ".");
		int32 eax_121 = strtol(eax_105);
		int32 eax_127 = strtol(eax_110);
		strtol(eax_115);
		free(eax_99);
		atexit(&g_t8048E89);
		char * eax_146 = basename(dwArg04);
		sprintf(&bLoc1010, "%s/src", eax_146);
		if (chdir(&bLoc1010, 0x080563AF, eax_146) >= 0x00)
		{
			if (SKIP_CFG == 0x00)
			{
				int32 dwLoc2814_797;
				if (VERBOSE != 0x00)
				{
					fwrite(&g_v80563E4, 0x01, 0x1A, stdout);
					sprintf(&bLoc2810, "sh %s %s", &g_b806B2E0, &g_b806AAE0);
					dwLoc2814_797 = system(&bLoc2810);
				}
				else
				{
					fwrite(&g_v8056408, 0x01, 0x0E, stdout);
					sprintf(&bLoc2810, "sh %s %s --quiet &> %s", &g_b806B2E0, &g_b806AAE0, &g_b80672C0);
					dwLoc2814_797 = system(&bLoc2810);
				}
				if (dwLoc2814_797 == ~0x00)
					print_error(gs, ~0x1A, 0x08056430);
				if (dwLoc2814_797 > 0x00)
					print_error(gs, ~0x02, 0x08056451);
				print_done();
				print_cfg(gs);
			}
			int32 dwLoc2814_909;
			sprintf(0x0805B2A0, "GEM_EXT_NAME=%s", dwArg0C);
			putenv(0x0805B2A0, 0x0805B2A0, 134571119, dwArg0C);
			sprintf(&bLoc0810, "%i.%i.%i", dwArg10, dwArg14, dwArg18);
			sprintf(0x0805BAA0, "GEM_EXT_VERSION=%s", &bLoc0810);
			putenv(0x0805BAA0, 0x0805BAA0, 134571135, 0x08055F03, dwArg10, dwArg14, dwArg18);
			dump_html(gs, "../description", &g_b8064AC0);
			dump_html(gs, "../info", &g_b80652C0);
			dump_html(gs, "../depends", &g_b8065AC0);
			dump_html(gs, "../bugs", &g_b80662C0);
			dump_html(gs, "../authors", &g_b8066AC0);
			sprintf(0x0805C2A0, "GEM_EXT_DESCR=%s", &g_b8064AC0);
			putenv(0x0805C2A0, 0x0805C2A0, 0x080564C7, 0x08064AC0);
			sprintf(0x0805CAA0, "GEM_EXT_INFO=%s", &g_b80652C0);
			putenv(0x0805CAA0, 0x0805CAA0, 0x080564D8, 0x080652C0);
			sprintf(0x0805D2A0, "GEM_EXT_DEPS=%s", &g_b8065AC0);
			putenv(0x0805D2A0, 0x0805D2A0, 0x080564E8, 134634176);
			sprintf(0x0805DAA0, "GEM_EXT_BUGS=%s", &g_b80662C0);
			putenv(0x0805DAA0, 0x0805DAA0, 0x080564F8, 0x080662C0);
			sprintf(0x0805E2A0, "GEM_EXT_AUTHORS=%s", &g_b8066AC0);
			putenv(0x0805E2A0, 0x0805E2A0, 0x08056508, 0x08066AC0);
			atexit(&g_t8048E89);
			check_dependencies(gs, dwArg04, dwArg08, dwArg1C);
			if (VERBOSE != 0x00)
			{
				fprintf(stdout, "Running '%s':\n", &g_b806BAE0);
				sprintf(&bLoc2810, "%s -f Makefile", &g_b806BAE0);
				dwLoc2814_909 = system(&bLoc2810);
			}
			else
			{
				fwrite(&g_v8056539, 0x01, 0x0C, stdout);
				sprintf(&bLoc2810, "%s -f Makefile &> %s", &g_b806BAE0, &g_b80672C0);
				dwLoc2814_909 = system(&bLoc2810);
			}
			if (dwLoc2814_909 != ~0x00 || VERBOSE != 0x00)
			{
				if (dwLoc2814_909 <= 0x00)
				{
					print_done();
					fwrite(&g_v80565F5, 0x01, 0x0D, stdout);
					FILE * eax_475 = fopen("../uninstall", "r");
					if (eax_475 == null)
					{
						strerror(*__errno_location());
						print_warning(gs, 0x08056610);
					}
					else
					{
						if (VERBOSE != 0x00)
						{
							sprintf(&bLoc0810, "cp -vf ../uninstall %s/etc/uninstall.%s ;", dwArg08, dwArg0C);
							strcpy(&g_b806A2E0, &bLoc0810);
						}
						else
						{
							sprintf(&bLoc0810, "cp -f ../uninstall %s/etc/uninstall.%s &> %s ;", dwArg08, dwArg0C, &g_b80672C0);
							strcpy(&g_b806A2E0, &bLoc0810);
						}
						fclose(eax_475);
					}
					register_extension(gs, dwArg08, "src", dwArg0C, dwArg10, dwArg14, dwArg18);
					check_dependencies(gs, dwArg04, dwArg08, dwArg1C);
					if (eax_121 == 0x06 && eax_127 <= 0x00)
						register_entries_gisman(gs, dwArg0C, dwArg08);
					register_entries_gisman2(gs, dwArg0C, dwArg08);
					register_html(gs, dwArg0C, dwArg08, dwArg10, dwArg14, dwArg18);
					if (VERBOSE != 0x00)
					{
						fprintf(stdout, "Running '%s install':\n", &g_b806BAE0);
						sprintf(&bLoc1810, "%s -f Makefile install ; \t\t\t\t\tcp -vf %s %s/etc/extensions.db ; chmod -v a+r %s/etc/extensions.db ;", &g_b806BAE0, &g_b8063AC0, dwArg08, dwArg08);
					}
					else
						sprintf(&bLoc1810, "%s -f Makefile -s install &> %s ; \t\t\t\t\tcp -f %s %s/etc/extensions.db &> %s ; chmod a+r %s/etc/extensions.db &> %s ;", &g_b806BAE0, &g_b80672C0, &g_b8063AC0, dwArg08, &g_b80672C0, dwArg08, &g_b80672C0);
					if (VERBOSE != 0x00)
						memcpy(&dwLoc2010, &g_v80567D4, 11);
					else
						sprintf(&dwLoc2010, "sh ../post &> %s", &g_b80672C0);
					sprintf(&bLoc0810, "%s %s %s %s %s %s", &bLoc1810, &g_b806A2E0, &g_b80682E0, &g_b8068AE0, &g_b80692E0, &dwLoc2010);
					su(gs, dwArg08, &bLoc0810);
					print_done();
					if ((eax_18 ^ gs->dw0014) == 0x00)
						return;
					__stack_chk_fail();
				}
				else
					print_error(gs, ~0x03, 0x08056594);
			}
			else
				print_error(gs, ~0x08, 0x0805655C);
		}
		else
		{
			strerror(*__errno_location());
			print_error(gs, ~0x01, 0x080563B8);
		}
	}
	else
	{
		strerror(*__errno_location());
		print_error(gs, ~0x04, 0x08056338);
	}
}

// 08050C67: void bin_install(Register (ptr32 Eq_67) gs, Stack (ptr32 char) dwArg04, Stack Eq_95 dwArg08, Stack (ptr32 char) dwArg0C, Stack (ptr32 char) dwArg10, Stack int32 dwArg14, Stack int32 dwArg18, Stack int32 dwArg1C, Stack Eq_95 dwArg20)
// Called from:
//      main
void bin_install(struct Eq_67 * gs, char * dwArg04, Eq_95 dwArg08, char * dwArg0C, char * dwArg10, int32 dwArg14, int32 dwArg18, int32 dwArg1C, Eq_95 dwArg20)
{
	word32 dwLoc208C;
	word32 dwLoc2010;
	char bLoc1810;
	char bLoc1010;
	char bLoc0810;
	word32 eax_20 = gs->dw0014;
	if (stat(dwArg08, &dwLoc208C) >= 0x00)
	{
		sprintf(0x080592A0, "GINSTALL_DST=%s", dwArg08);
		putenv(0x080592A0, 0x080592A0, 0x0805635C, dwArg08);
		sprintf(&bLoc0810, "%s/include", dwArg08);
		sprintf(0x08059AA0, "GINSTALL_INC=%s", &bLoc0810);
		putenv(0x08059AA0, 0x08059AA0, 0x08056377, 0x0805636C, dwArg08);
		sprintf(&bLoc0810, "%s/lib", dwArg08);
		sprintf(0x0805A2A0, "GINSTALL_LIB=%s", &bLoc0810);
		putenv(0x0805A2A0, 0x0805A2A0, 0x0805638E, 0x08056387, dwArg08);
		sprintf(0x0805EAA0, "GEM_GRASS_DIR=%s", dwArg08);
		putenv(0x0805EAA0, 0x0805EAA0, 0x0805639E, dwArg08);
		char * eax_105 = strdup(dwArg20);
		char * eax_111 = strtok(eax_105, ".");
		char * eax_116 = strtok(null, ".");
		char * eax_121 = strtok(null, ".");
		int32 eax_127 = strtol(eax_111);
		int32 eax_133 = strtol(eax_116);
		strtol(eax_121);
		free(eax_105);
		atexit(&g_t8048E89);
		char * eax_152 = basename(dwArg04);
		sprintf(&bLoc1010, "%s/%s", eax_152, dwArg0C);
		if (chdir(&bLoc1010, 0x08056802, eax_152, dwArg0C) >= 0x00)
		{
			sprintf(0x0805B2A0, "GEM_EXT_NAME=%s", dwArg10);
			putenv(0x0805B2A0, 0x0805B2A0, 134571119, dwArg10);
			sprintf(&bLoc0810, "%i.%i.%i", dwArg14, dwArg18, dwArg1C);
			sprintf(0x0805BAA0, "GEM_EXT_VERSION=%s", &bLoc0810);
			putenv(0x0805BAA0, 0x0805BAA0, 134571135, 0x08055F03, dwArg14, dwArg18, dwArg1C);
			dump_html(gs, "../description", &g_b8064AC0);
			dump_html(gs, "../info", &g_b80652C0);
			dump_html(gs, "../depends", &g_b8065AC0);
			dump_html(gs, "../bugs", &g_b80662C0);
			dump_html(gs, "../authors", &g_b8066AC0);
			sprintf(0x0805C2A0, "GEM_EXT_DESCR=%s", &g_b8064AC0);
			putenv(0x0805C2A0, 0x0805C2A0, 0x080564C7, 0x08064AC0);
			sprintf(0x0805CAA0, "GEM_EXT_INFO=%s", &g_b80652C0);
			putenv(0x0805CAA0, 0x0805CAA0, 0x080564D8, 0x080652C0);
			sprintf(0x0805D2A0, "GEM_EXT_DEPS=%s", &g_b8065AC0);
			putenv(0x0805D2A0, 0x0805D2A0, 0x080564E8, 134634176);
			sprintf(0x0805DAA0, "GEM_EXT_BUGS=%s", &g_b80662C0);
			putenv(0x0805DAA0, 0x0805DAA0, 0x080564F8, 0x080662C0);
			sprintf(0x0805E2A0, "GEM_EXT_AUTHORS=%s", &g_b8066AC0);
			putenv(0x0805E2A0, 0x0805E2A0, 0x08056508, 0x08066AC0);
			atexit(&g_t8048E89);
			check_dependencies(gs, dwArg04, dwArg08, dwArg20);
			fwrite(&g_v80565F5, 0x01, 0x0D, stdout);
			FILE * eax_343 = fopen("../uninstall", "r");
			if (eax_343 == null)
			{
				strerror(*__errno_location());
				print_warning(gs, 0x08056610);
			}
			else
			{
				if (VERBOSE != 0x00)
				{
					sprintf(&bLoc0810, "cp -vf ../uninstall %s/etc/uninstall.%s ;", dwArg08, dwArg10);
					strcpy(&g_b806A2E0, &bLoc0810);
				}
				else
				{
					sprintf(&bLoc0810, "cp -f ../uninstall %s/etc/uninstall.%s &> %s ;", dwArg08, dwArg10, &g_b80672C0);
					strcpy(&g_b806A2E0, &bLoc0810);
				}
				fclose(eax_343);
			}
			register_extension(gs, dwArg08, dwArg0C, dwArg10, dwArg14, dwArg18, dwArg1C);
			check_dependencies(gs, dwArg04, dwArg08, dwArg20);
			if (eax_127 == 0x06 && eax_133 <= 0x00)
				register_entries_gisman(gs, dwArg10, dwArg08);
			register_entries_gisman2(gs, dwArg10, dwArg08);
			register_html(gs, dwArg10, dwArg08, dwArg14, dwArg18, dwArg1C);
			if (VERBOSE != 0x00)
			{
				fprintf(stdout, "Running '%s install':\n", &g_b806BAE0);
				sprintf(&bLoc1810, "bin/%s -f Makefile install ; \t\t\t\t\tcp -vf %s %s/etc/extensions.db ; chmod -v a+r %s/etc/extensions.db ;", &g_b806BAE0, &g_b8063AC0, dwArg08, dwArg08);
			}
			else
				sprintf(&bLoc1810, "bin/%s -f Makefile -s install &> %s ; \t\t\t\t\tcp -f %s %s/etc/extensions.db &> %s ; chmod a+r %s/etc/extensions.db &> %s ;", &g_b806BAE0, &g_b80672C0, &g_b8063AC0, dwArg08, &g_b80672C0, dwArg08, &g_b80672C0);
			if (VERBOSE != 0x00)
				memcpy(&dwLoc2010, &g_v80567D4, 11);
			else
				sprintf(&dwLoc2010, "sh ../post &> %s", &g_b80672C0);
			sprintf(&bLoc0810, "%s %s %s %s %s %s", &bLoc1810, &g_b806A2E0, &g_b80682E0, &g_b8068AE0, &g_b80692E0, &dwLoc2010);
			su(gs, dwArg08, &bLoc0810);
			print_done();
			if ((eax_20 ^ gs->dw0014) == 0x00)
				return;
			__stack_chk_fail();
		}
		else
		{
			strerror(*__errno_location());
			print_error(gs, ~0x01, 0x08056808);
		}
	}
	else
	{
		strerror(*__errno_location());
		print_error(gs, ~0x04, 0x08056338);
	}
}

// 0805148A: void test_install(Register (ptr32 Eq_67) gs, Stack (ptr32 char) dwArg04, Stack Eq_95 dwArg08, Stack (ptr32 char) dwArg0C, Stack int32 dwArg10, Stack int32 dwArg14, Stack int32 dwArg18, Stack Eq_95 dwArg1C)
// Called from:
//      main
void test_install(struct Eq_67 * gs, char * dwArg04, Eq_95 dwArg08, char * dwArg0C, int32 dwArg10, int32 dwArg14, int32 dwArg18, Eq_95 dwArg1C)
{
	word32 dwLoc188C;
	char bLoc1810;
	char bLoc1010;
	char bLoc0810;
	word32 eax_18 = gs->dw0014;
	if (stat(dwArg08, &dwLoc188C) >= 0x00)
	{
		sprintf(0x080592A0, "GINSTALL_DST=%s", dwArg08);
		putenv(0x080592A0, 0x080592A0, 0x0805635C, dwArg08);
		sprintf(&bLoc0810, "%s/include", dwArg08);
		sprintf(0x08059AA0, "GINSTALL_INC=%s", &bLoc0810);
		putenv(0x08059AA0, 0x08059AA0, 0x08056377, 0x0805636C, dwArg08);
		sprintf(&bLoc0810, "%s/lib", dwArg08);
		sprintf(0x0805A2A0, "GINSTALL_LIB=%s", &bLoc0810);
		putenv(0x0805A2A0, 0x0805A2A0, 0x0805638E, 0x08056387, dwArg08);
		sprintf(0x0805EAA0, "GEM_GRASS_DIR=%s", dwArg08);
		putenv(0x0805EAA0, 0x0805EAA0, 0x0805639E, dwArg08);
		char * eax_99 = strdup(dwArg1C);
		char * eax_105 = strtok(eax_99, ".");
		char * eax_110 = strtok(null, ".");
		char * eax_115 = strtok(null, ".");
		int32 eax_121 = strtol(eax_105);
		int32 eax_127 = strtol(eax_110);
		strtol(eax_115);
		free(eax_99);
		atexit(&g_t8048E89);
		char * eax_146 = basename(dwArg04);
		sprintf(&bLoc1010, "%s/src", eax_146);
		if (chdir(&bLoc1010, 0x080563AF, eax_146) >= 0x00)
		{
			if (SKIP_CFG == 0x00)
			{
				int32 dwLoc1814_682;
				if (VERBOSE != 0x00)
				{
					fwrite(&g_v80563E4, 0x01, 0x1A, stdout);
					sprintf(&bLoc1810, "sh %s %s", &g_b806B2E0, &g_b806AAE0);
					dwLoc1814_682 = system(&bLoc1810);
				}
				else
				{
					fwrite(&g_v8056408, 0x01, 0x0E, stdout);
					sprintf(&bLoc1810, "sh %s %s --quiet &> %s", &g_b806B2E0, &g_b806AAE0, &g_b80672C0);
					dwLoc1814_682 = system(&bLoc1810);
				}
				if (dwLoc1814_682 == ~0x00)
					print_error(gs, ~0x1A, 0x08056430);
				if (dwLoc1814_682 > 0x00)
					print_error(gs, ~0x02, 0x08056451);
				print_done();
				print_cfg(gs);
			}
			int32 dwLoc1814_790;
			sprintf(0x0805B2A0, "GEM_EXT_NAME=%s", dwArg0C);
			putenv(0x0805B2A0, 0x0805B2A0, 134571119, dwArg0C);
			sprintf(&bLoc0810, "%i.%i.%i", dwArg10, dwArg14, dwArg18);
			sprintf(0x0805BAA0, "GEM_EXT_VERSION=%s", &bLoc0810);
			putenv(0x0805BAA0, 0x0805BAA0, 134571135, 0x08055F03, dwArg10, dwArg14, dwArg18);
			dump_plain(gs, "../description", &g_b8064AC0);
			dump_plain(gs, "../info", &g_b80652C0);
			dump_plain(gs, "../depends", &g_b8065AC0);
			dump_plain(gs, "../bugs", &g_b80662C0);
			dump_plain(gs, "../authors", &g_b8066AC0);
			sprintf(0x0805C2A0, "GEM_EXT_DESCR=%s", &g_b8064AC0);
			putenv(0x0805C2A0, 0x0805C2A0, 0x080564C7, 0x08064AC0);
			sprintf(0x0805CAA0, "GEM_EXT_INFO=%s", &g_b80652C0);
			putenv(0x0805CAA0, 0x0805CAA0, 0x080564D8, 0x080652C0);
			sprintf(0x0805D2A0, "GEM_EXT_DEPS=%s", &g_b8065AC0);
			putenv(0x0805D2A0, 0x0805D2A0, 0x080564E8, 134634176);
			sprintf(0x0805DAA0, "GEM_EXT_BUGS=%s", &g_b80662C0);
			putenv(0x0805DAA0, 0x0805DAA0, 0x080564F8, 0x080662C0);
			sprintf(0x0805E2A0, "GEM_EXT_AUTHORS=%s", &g_b8066AC0);
			putenv(0x0805E2A0, 0x0805E2A0, 0x08056508, 0x08066AC0);
			atexit(&g_t8048E89);
			check_dependencies(gs, dwArg04, dwArg08, dwArg1C);
			if (VERBOSE != 0x00)
			{
				fprintf(stdout, "Running '%s':\n", &g_b806BAE0);
				sprintf(&bLoc1810, "%s -f Makefile", &g_b806BAE0);
				dwLoc1814_790 = system(&bLoc1810);
			}
			else
			{
				fwrite(&g_v8056539, 0x01, 0x0C, stdout);
				sprintf(&bLoc1810, "%s -f Makefile &> %s", &g_b806BAE0, &g_b80672C0);
				dwLoc1814_790 = system(&bLoc1810);
			}
			if (dwLoc1814_790 != ~0x00 || VERBOSE != 0x00)
			{
				if (dwLoc1814_790 <= 0x00)
				{
					print_done();
					fwrite(&g_v80565F5, 0x01, 0x0D, stdout);
					FILE * eax_475 = fopen("../uninstall", "r");
					if (eax_475 == null)
					{
						strerror(*__errno_location());
						print_warning(gs, 0x08056610);
					}
					else
						fclose(eax_475);
					register_extension(gs, dwArg08, "src", dwArg0C, dwArg10, dwArg14, dwArg18);
					check_dependencies(gs, dwArg04, dwArg08, dwArg1C);
					if (eax_121 == 0x06 && eax_127 <= 0x00)
						register_entries_gisman(gs, dwArg0C, dwArg08);
					register_entries_gisman2(gs, dwArg0C, dwArg08);
					register_html(gs, dwArg0C, dwArg08, dwArg10, dwArg14, dwArg18);
					fprintf(stdout, "(skipping '%s install')...", &g_b806BAE0);
					print_done();
					if ((eax_18 ^ gs->dw0014) == 0x00)
						return;
					__stack_chk_fail();
				}
				else
					print_error(gs, ~0x03, 0x08056594);
			}
			else
				print_error(gs, ~0x08, 0x0805655C);
		}
		else
		{
			strerror(*__errno_location());
			print_error(gs, ~0x01, 0x080563B8);
		}
	}
	else
	{
		strerror(*__errno_location());
		print_error(gs, ~0x04, 0x08056338);
	}
}

// 08051CF4: void uninstall(Register (ptr32 Eq_67) gs, Stack (ptr32 char) dwArg04, Stack (ptr32 char) dwArg08, Stack Eq_95 dwArg0C, Stack Eq_95 dwArg10)
// Called from:
//      main
void uninstall(struct Eq_67 * gs, char * dwArg04, char * dwArg08, Eq_95 dwArg0C, Eq_95 dwArg10)
{
	word32 dwLoc108C;
	char bLoc1010;
	char bLoc0810;
	word32 eax_18 = gs->dw0014;
	FILE * eax_24 = stdout;
	fwrite(&g_v8056937, 0x01, 0x10, eax_24);
	sprintf(0x0805AAA0, "UNINSTALL_BASE=%s", dwArg0C);
	putenv(0x0805AAA0, 0x0805AAA0, 134572343, 0x08056948, 0x01, dwArg0C, 0x10, eax_24, dwArg10, dwArg0C, dwArg08, dwArg04, eax_18);
	char * eax_44 = strdup(dwArg10);
	char * eax_50 = strtok(eax_44, ".");
	char * eax_55 = strtok(null, ".");
	char * eax_60 = strtok(null, ".");
	int32 eax_66 = strtol(eax_50);
	int32 eax_72 = strtol(eax_55);
	strtol(eax_60);
	free(eax_44);
	atexit(&g_t8048E89);
	deregister_extension(gs, dwArg08, dwArg0C);
	if (eax_66 == 0x06 && eax_72 <= 0x00)
	{
		word32 eax_109 = deregister_entries_gisman(gs, dwArg08, dwArg0C);
		if (eax_109 == ~0x00)
		{
			print_warning(gs, 0x0805695C);
			memcpy(&g_b80682E0, &g_v805698C, 0x01);
		}
		if (eax_109 == 0x00)
		{
			print_warning(gs, 0x08056990);
			memcpy(&g_b80682E0, &g_v805698C, 0x01);
		}
	}
	deregister_entries_gisman2(gs, dwArg08, dwArg0C);
	deregister_html(gs, dwArg08, dwArg0C);
	sprintf(&bLoc1010, "%s/etc/uninstall.%s", dwArg0C, dwArg08);
	word32 dwLoc1018_401 = 0x00;
	if (stat(&bLoc1010, &dwLoc108C) < 0x00)
	{
		print_warning(gs, 0x080569D4);
		dwLoc1018_401 = 0x01;
	}
	if (dwLoc1018_401 != 0x00)
	{
		strerror(*__errno_location());
		print_warning(gs, 0x08056610);
	}
	else if (VERBOSE != 0x00)
	{
		sprintf(&bLoc0810, "sh %s ; rm -vf %s ; \t\t\t\t\t \t\trm -vrf %s/docs/extensions/%s ; rm -vf %s/etc/dm/gem-entries/%s ; \t\t\t\t\t\t\tcp -vf %s %s/etc/extensions.db ; chmod -v a+r %s/etc/extensions.db ;", &bLoc1010, &bLoc1010, dwArg0C, dwArg08, dwArg0C, dwArg08, &g_b8063AC0, dwArg0C, dwArg0C);
		strcpy(&g_b806A2E0, &bLoc0810);
	}
	else
	{
		sprintf(&bLoc0810, "sh %s &> %s ; rm -vf %s &> %s ; \t\t\t\t\t \t\trm -vrf %s/docs/extensions/%s &> %s ; rm -vf %s/etc/dm/gem-entries/%s &> %s ; \t\t\t\t\t\t\tcp -vf %s %s/etc/extensions.db &> %s ; chmod -v a+r %s/etc/extensions.db &> %s ;", &bLoc1010, &g_b80672C0, &bLoc1010, &g_b80672C0, dwArg0C, dwArg08, &g_b80672C0, dwArg0C, dwArg08, &g_b80672C0, &g_b8063AC0, dwArg0C, &g_b80672C0, dwArg0C, &g_b80672C0);
		strcpy(&g_b806A2E0, &bLoc0810);
	}
	sprintf(&bLoc0810, "%s %s %s", &g_b806A2E0, &g_b80682E0, &g_b80692E0);
	su(gs, dwArg0C, &bLoc0810);
	print_done();
	if ((eax_18 ^ gs->dw0014) == 0x00)
		return;
	__stack_chk_fail();
}

// 080521A4: void source_clean(Register (ptr32 Eq_67) gs, Stack (ptr32 char) dwArg04)
// Called from:
//      main
void source_clean(struct Eq_67 * gs, char * dwArg04)
{
	char bLoc1010;
	char bLoc0810;
	word32 eax_12 = gs->dw0014;
	char * eax_20 = basename(dwArg04);
	sprintf(&bLoc0810, "%s/src", eax_20);
	if (chdir(&bLoc0810, 0x080563AF, eax_20) >= 0x00)
	{
		int32 dwLoc1014_132;
		if (VERBOSE != 0x00)
		{
			fprintf(stdout, "Running '%s clean':\n", &g_b806BAE0);
			sprintf(&bLoc1010, "%s -f Makefile clean", &g_b806BAE0);
			dwLoc1014_132 = system(&bLoc1010);
		}
		else
		{
			fwrite(&g_v8056C0E, 0x01, 0x0E, stdout);
			sprintf(&bLoc1010, "%s -f Makefile -s clean &> %s", &g_b806BAE0, &g_b80672C0);
			dwLoc1014_132 = system(&bLoc1010);
		}
		if (dwLoc1014_132 != ~0x00)
		{
			print_done();
			system("sh ../post");
			if ((eax_12 ^ gs->dw0014) == 0x00)
				return;
			__stack_chk_fail();
		}
		else
			print_error(gs, ~0x08, 0x08056C3C);
	}
	else
		print_error(gs, ~0x01, 0x08056BC4);
}

// 08052334: void restore(Register (ptr32 Eq_67) gs, Stack Eq_95 dwArg04, Stack (ptr32 char) dwArg08)
// Called from:
//      main
void restore(struct Eq_67 * gs, Eq_95 dwArg04, char * dwArg08)
{
	char bLoc0810;
	word32 eax_14 = gs->dw0014;
	char * eax_19 = strdup(dwArg08);
	char * eax_25 = strtok(eax_19, ".");
	char * eax_30 = strtok(null, ".");
	char * eax_35 = strtok(null, ".");
	int32 eax_41 = strtol(eax_25);
	int32 eax_47 = strtol(eax_30);
	strtol(eax_35);
	free(eax_19);
	fwrite(&g_v8056C78, 0x01, 0x0C, stdout);
	if (eax_41 == 0x06 && eax_47 <= 0x00)
	{
		int32 eax_71 = restore_entries_gisman(gs, dwArg04);
		if (VERBOSE != 0x00)
			fprintf(stdout, "\nRestored entries for GIS Manager: %i\n", eax_71);
	}
	int32 eax_98 = restore_html(gs, dwArg04);
	if (VERBOSE != 0x00)
		fprintf(stdout, "\nRestored links in index.hml: %i\n", eax_98);
	if (eax_98 > 0x00)
	{
		if (VERBOSE != 0x00)
			sprintf(&bLoc0810, "cp -f %s %s/etc/dm/menu.tcl ; chmod a+r %s/etc/dm/menu.tcl ; \t\t\t\t\t\t\tcp -f %s %s/docs/html/index.html ; chmod a+r %s/docs/html/index.html", &g_b80642C0, dwArg04, dwArg04, &g_b8067AC0, dwArg04, dwArg04);
		else
			sprintf(&bLoc0810, "cp -f %s %s/etc/dm/menu.tcl ; chmod a+r %s/etc/dm/menu.tcl &> %s ; \t\t\t\t\t\t\tcp -f %s %s/docs/html/index.html ; chmod a+r %s/docs/html/index.html", &g_b80642C0, dwArg04, dwArg04, &g_b80672C0, &g_b8067AC0, dwArg04, dwArg04);
		su(gs, dwArg04, &bLoc0810);
	}
	if (eax_98 != 0x00)
	{
		print_done();
		if ((eax_14 ^ gs->dw0014) == 0x00)
			return;
		__stack_chk_fail();
	}
	else
		print_error(gs, ~0x19, 0x08056DF0);
}

// 080525FC: void list_extensions(Register (ptr32 Eq_67) gs, Stack Eq_95 dwArg04)
// Called from:
//      main
void list_extensions(struct Eq_67 * gs, Eq_95 dwArg04)
{
	char bLoc0810;
	word32 eax_12 = gs->dw0014;
	fprintf(stdout, "\nExtensions in '%s' (name, version, type, depends):\n", dwArg04);
	sprintf(&bLoc0810, "%s/etc/extensions.db", dwArg04);
	FILE * eax_33 = fopen(&bLoc0810, "r");
	if (eax_33 != null)
	{
		fclose(eax_33);
		dump_ascii(gs, &bLoc0810, "");
		if ((eax_12 ^ gs->dw0014) == 0x00)
			return;
		__stack_chk_fail();
	}
	else if (*__errno_location() != 0x02)
	{
		fclose(eax_33);
		strerror(*__errno_location());
		print_error(gs, ~0x1C, 0x08056E69);
	}
	else
	{
		fwrite(&g_v8056E62, 0x01, 0x06, stderr);
		fclose(eax_33);
		exit(0x00);
	}
}

// 08052748: void run_post(Register (ptr32 Eq_67) gs, Stack (ptr32 char) dwArg04, Stack up32 dwArg08, Stack (ptr32 char) dwArg0C, Stack Eq_95 dwArg10)
// Called from:
//      main
void run_post(struct Eq_67 * gs, char * dwArg04, up32 dwArg08, char * dwArg0C, Eq_95 dwArg10)
{
	char bLoc1010;
	char bLoc0810;
	word32 eax_16 = gs->dw0014;
	if (dwArg08 <= 0x09 && dwArg08 >= 0x03)
	{
		switch (dwArg08)
		{
		case 0x03:
			memcpy(&g_v805F2A0, &g_v8056E85, 0x13);
			break;
		case 0x04:
			memcpy(&g_v805F2A0, &g_v8056E85, 0x13);
			break;
		case 0x05:
			memcpy(&g_v805F2A0, &g_v8056E98, 0x11);
			break;
		case 0x06:
			memcpy(&g_v805F2A0, &g_v8056EA9, 0x11);
			break;
		case 0x07:
			memcpy(&g_v805F2A0, &g_v8056EBA, 0x13);
			break;
		case 0x08:
			break;
		case 0x09:
			memcpy(&g_v805F2A0, &g_v8056ECD, 0x13);
			break;
		}
	}
	putenv(0x0805F2A0);
	if (dwArg10 != 0x00)
		sprintf(0x0805FAA0, "INSTALL_BASE=%s", dwArg10);
	else
		memcpy(&g_v805FAA0, &g_v8056EF0, 0x17);
	putenv(0x0805FAA0);
	getcwd(&bLoc0810, 0x0800);
	char * eax_90 = basename(dwArg04);
	sprintf(&bLoc1010, "%s/%s/src", &bLoc0810, eax_90);
	sprintf(0x08062AA0, "EXT_BASE=%s", &bLoc1010);
	putenv(0x08062AA0, 0x08062AA0, 0x08056F11, 0x08056F07, eax_90);
	if (dwArg0C == null)
		memcpy(&g_v80602A0, &g_v8056F1D, 0x11);
	else
		sprintf(134611616, "INSTALL_TYPE=%s", dwArg0C);
	putenv(134611616);
	int32 edx_135 = FORCE;
	sprintf(&bLoc0810, "%i", edx_135);
	sprintf(0x08060AA0, "GEM_FORCE=%s", &bLoc0810);
	putenv(0x08060AA0, 0x08060AA0, 0x08056F41, 0x08056F3E, edx_135);
	int32 edx_152 = VERBOSE;
	sprintf(&bLoc0810, "%i", edx_152);
	sprintf(0x080612A0, "GEM_VERBOSE=%s", &bLoc0810);
	putenv(0x080612A0, 0x080612A0, 0x08056F4E, 0x08056F3E, edx_152);
	memcpy(&g_v8061AA0, &g_v8056F5D, 0x0A);
	putenv(0x08061AA0, 0x08061AA0, 0x08056F5D, 0x0A);
	atexit(&g_t8048E89);
	if ((eax_16 ^ gs->dw0014) == 0x00)
		return;
	__stack_chk_fail();
}

// 08052A50: void show_help()
// Called from:
//      main
void show_help()
{
	fwrite(&g_v8056F88, 0x01, 0x2A, stdout);
	fwrite(&g_v8056FB4, 0x01, 44, stdout);
	fwrite(&g_v8056FE4, 0x01, 0x27, stdout);
	fwrite(&g_v805700C, 0x01, 0x17, stdout);
	fwrite(&g_v8057024, 0x01, 0x2E, stdout);
	fwrite(&g_v8057054, 0x01, 0x35, stdout);
	fwrite(&g_v805708C, 0x01, 0x45, stdout);
	fwrite(&g_v80570D4, 0x01, 66, stdout);
	fwrite(&g_v8057118, 0x01, 0x3C, stdout);
	fwrite(&g_v8057158, 0x01, 0x44, stdout);
	fwrite(&g_v80571A0, 0x01, 0x40, stdout);
	fwrite(&g_v80571E4, 0x01, 0x3D, stdout);
	fwrite(&g_v8057224, 0x01, 0x29, stdout);
	fwrite(&g_v8057250, 0x01, 0x36, stdout);
	fwrite(&g_v8057287, 0x01, 0x17, stdout);
	fwrite(&g_v80572A0, 0x01, 0x32, stdout);
	fwrite(&g_v80572D4, 0x01, 0x45, stdout);
	fwrite(&g_v805731C, 0x01, 0x38, stdout);
	fwrite(&g_v8057358, 0x01, 0x35, stdout);
	fwrite(&g_v8057390, 0x01, 0x2A, stdout);
	fwrite(&g_v80573BC, 0x01, 55, stdout);
	fwrite(&g_v80573F4, 0x01, 0x3E, stdout);
	fwrite(&g_v8057434, 0x01, 77, stdout);
	fwrite(&g_v8057484, 0x01, 0x41, stdout);
	fwrite(&g_v80574C8, 0x01, 0x47, stdout);
	fwrite(&g_v8057510, 0x01, 0x49, stdout);
	fwrite(&g_v805755A, 0x01, 0x0F, stdout);
	fwrite(&g_v805756C, 0x01, 0x4A, stdout);
	fwrite(&g_v80575B7, 0x01, 0x14, stdout);
	fwrite(&g_v80575CC, 0x01, 0x49, stdout);
	fwrite(&g_v8057618, 0x01, 0x4C, stdout);
	fwrite(&g_v8057668, 0x01, 0x2A, stdout);
	fwrite(&g_v8057694, 0x01, 0x4B, stdout);
	fwrite(&g_v80576E0, 0x01, 0x0A, stdout);
	fwrite(&g_v80576EC, 0x01, 0x3F, stdout);
	fwrite(&g_v805772C, 0x01, 0x4B, stdout);
	exit(0x00);
}

// 08053002: void show_details(Register (ptr32 Eq_67) gs, Stack (ptr32 char) dwArg04)
// Called from:
//      main
void show_details(struct Eq_67 * gs, char * dwArg04)
{
	char bLoc0810;
	char * eax_20 = basename(dwArg04);
	strcpy(&bLoc0810, eax_20);
	if (chdir(&bLoc0810, eax_20) >= 0x00)
	{
		dump_ascii(gs, "info", "Detailed information");
		system("sh post");
		exit(0x00);
	}
	else
	{
		strerror(*__errno_location());
		print_error(gs, ~0x01, 0x08057778);
	}
}

// 080530B9: void show_license(Register (ptr32 Eq_67) gs, Stack (ptr32 char) dwArg04)
// Called from:
//      main
void show_license(struct Eq_67 * gs, char * dwArg04)
{
	char bLoc0810;
	char * eax_20 = basename(dwArg04);
	strcpy(&bLoc0810, eax_20);
	if (chdir(&bLoc0810, eax_20) >= 0x00)
	{
		dump_ascii(gs, "license", "Detailed information");
		system("sh post");
		exit(0x00);
	}
	else
	{
		strerror(*__errno_location());
		print_error(gs, ~0x01, 0x08057778);
	}
}

// 08053170: void show_version()
// Called from:
//      main
void show_version()
{
	fprintf(stdout, "gem64 (GRASS extensions manager) %.2f\n", 1.03);
	fwrite(&g_v80577EF, 0x01, 0x1A, stdout);
	fwrite(&g_v805780C, 0x01, 0x23, stdout);
	fwrite(&g_v8057830, 0x01, 0x4B, stdout);
	fwrite(&g_v805787C, 0x01, 0x4C, stdout);
	exit(0x00);
}

// 08053242: void get_configure_options(Register (ptr32 Eq_67) gs, Stack (ptr32 char) dwArg04)
void get_configure_options(struct Eq_67 * gs, char * dwArg04)
{
	char bLoc0810;
	word32 eax_12 = gs->dw0014;
	if (g_b806AAE0 == 0x00)
	{
		sprintf(&bLoc0810, "%s/etc/config.system", dwArg04);
		FILE * eax_33 = fopen(&bLoc0810, "r");
		if (eax_33 == null)
			print_warning(gs, 0x080578E0);
		else if (nc_fgets_nb(&bLoc0810, 0x0800, eax_33) != 0x00)
			strcpy(&g_b806AAE0, &bLoc0810);
	}
	if ((eax_12 ^ gs->dw0014) == 0x00)
		return;
	__stack_chk_fail();
}

// 0805331E: void main(Register (ptr32 Eq_67) gs, Stack int32 dwArg04, Stack (ptr32 (ptr32 char)) dwArg08)
void main(struct Eq_67 * gs, int32 dwArg04, char ** dwArg08)
{
	ptr32 fp;
	word32 dwLoc3930;
	word32 dwLoc38D8;
	int32 dwLoc3880;
	Eq_10256 tLoc3848;
	int32 tLoc3844;
	int32 dwLoc3840;
	char bLoc3818;
	char bLoc3018;
	char bLoc2818;
	char bLoc2018;
	char bLoc1818;
	char bLoc1018;
	char bLoc0818;
	ui32 dwLoc38C8;
	char * dwLoc3820;
	up32 dwLoc3864;
	ui32 dwLoc3920;
	__align_stack<word32>(fp - 4);
	dwLoc3880 = 0x00;
	VERBOSE = 0x00;
	TMPCLEAN = 0x00;
	TMPDBCLEAN = 0x00;
	FORCE = 0x00;
	UPGRADE = 0x00;
	ERROR = 0x00;
	WARNINGS = 0x00;
	SKIP_CFG = 0x00;
	memcpy(&g_b80682E0, &g_v8057925, 0x01);
	memcpy(&g_b8068AE0, &g_v8057925, 0x01);
	memcpy(&g_v8069AE0, &g_v8057925, 0x01);
	memcpy(&g_b806A2E0, &g_v8057925, 0x01);
	memcpy(&g_b80692E0, &g_v8057925, 0x01);
	memcpy(&g_b80632C0, &g_v8057925, 0x01);
	memcpy(&g_b8063AC0, &g_v8057925, 0x01);
	memcpy(&g_b80642C0, &g_v8057925, 0x01);
	memcpy(&g_b8064AC0, &g_v8057925, 0x01);
	memcpy(&g_b80652C0, &g_v8057925, 0x01);
	memcpy(&g_b8065AC0, &g_v8057925, 0x01);
	memcpy(&g_b80662C0, &g_v8057925, 0x01);
	memcpy(&g_b8066AC0, &g_v8057925, 0x01);
	memcpy(&g_b8067AC0, &g_v8057925, 0x01);
	memcpy(&g_b80672C0, &g_v8057925, 0x01);
	memcpy(&g_b806AAE0, &g_v8057925, 0x01);
	memcpy(&g_b806B2E0, &g_v8057926, 0x0A);
	memcpy(&g_b806BAE0, &g_v8057930, 0x05);
	getcwd(&g_b806C2E0, 0x0800);
	fwrite(&g_v8057935, 0x01, 0x04, stdout);
	Eq_95 eax_130 = malloc(0x0800);
	strcpy(&bLoc3018, *dwArg08);
	setvbuf(stdout, null, 0x02, 0x00);
	if (dwArg04 != 0x01)
	{
		atexit(&g_t8049390);
		opterr = 0x00;
		int32 dwLoc3868_1321 = 0x00;
		char * dwLoc383C_1322 = null;
		Eq_95 dwLoc381C_1323 = 0x00;
		Eq_10515 dwLoc3860_1329 = getopt_long(dwArg04, dwArg08, ":i:u:q:d:c:C:t:l:m:o:x:rhVg:b:fvs", &g_t8059100, &dwLoc3880);
		while (dwLoc3860_1329 != ~0x00)
		{
			if (dwLoc3860_1329 == 0x3F)
				print_error(gs, ~0x00, 0x08057960);
			if (dwLoc3860_1329 == 0x3A)
			{
				if (optopt == 0x69 || (optopt == 117 || (optopt == 100 || (optopt == 99 || (optopt == 116 || (optopt == 0x6C || optopt == 114))))))
					print_error(gs, ~0x00, 0x08057988);
				if (optopt == 0x67)
					print_error(gs, ~0x00, 0x080579A9);
				if (optopt == 0x62)
					print_error(gs, ~0x00, 0x080579C4);
				if (optopt == 0x62)
					print_error(gs, ~0x00, 0x080579EA);
				if (optopt == 113)
				{
					dwLoc3864 = 0x0C;
					++dwLoc3868_1321;
					break;
				}
			}
			if (dwLoc3860_1329 == 0x69 || (dwLoc3860_1329 == 117 || (dwLoc3860_1329 == 113 || (dwLoc3860_1329 == 100 || (dwLoc3860_1329 == 99 || (dwLoc3860_1329 == 116 || (dwLoc3860_1329 == 0x6C || (dwLoc3860_1329 == 114 || (dwLoc3860_1329 == 0x68 || dwLoc3860_1329 == 0x56)))))))))
			{
				++dwLoc3868_1321;
				if (dwLoc3860_1329 <= 117 && dwLoc3860_1329 >= 0x56)
				{
					switch (dwLoc3860_1329)
					{
					case 0x56:
						dwLoc3864 = 0x02;
						break;
					case 0x57:
					case 88:
					case 0x59:
					case 0x5A:
					case 0x5B:
					case 0x5C:
					case 0x5D:
					case 0x5E:
					case 0x5F:
					case 0x60:
					case 0x61:
					case 0x62:
					case 101:
					case 0x66:
					case 0x67:
					case 0x6A:
					case 0x6B:
					case 0x6D:
					case 110:
					case 111:
					case 0x70:
					case 115:
						break;
					case 99:
						dwLoc3864 = 0x06;
						break;
					case 100:
						dwLoc3864 = 0x09;
						break;
					case 0x68:
						dwLoc3864 = 0x01;
						break;
					case 0x69:
						if (dwLoc3864 != 0x04)
							dwLoc3864 = 0x03;
						break;
					case 0x6C:
						dwLoc3864 = 0x07;
						break;
					case 113:
						dwLoc3864 = 0x05;
						break;
					case 114:
						dwLoc3864 = 11;
						break;
					case 116:
						dwLoc3864 = 0x08;
						break;
					case 117:
						dwLoc3864 = 0x0A;
						break;
					}
				}
				if (optarg != null)
				{
					strcpy(&bLoc1018, optarg);
					strcpy(&bLoc1818, optarg);
				}
			}
			if (dwLoc3860_1329 == 0x67)
			{
				Eq_95 eax_292 = malloc((word32) strlen(optarg) + 1);
				strcpy(eax_292, optarg);
				dwLoc381C_1323 = eax_292;
			}
			if (dwLoc3860_1329 == 0x62)
			{
				char * eax_309 = malloc((word32) strlen(optarg) + 1);
				strcpy(eax_309, optarg);
				dwLoc383C_1322 = eax_309;
				dwLoc3864 = 0x04;
			}
			if (dwLoc3860_1329 == 0x78)
				strcpy(&g_b806AAE0, optarg);
			if (dwLoc3860_1329 == 0x66)
				FORCE = 0x01;
			if (dwLoc3860_1329 == 118)
				VERBOSE = 0x01;
			if (dwLoc3860_1329 == 115)
				SKIP_CFG = 0x01;
			if (dwLoc3860_1329 == 111)
				strcat(&bLoc3818, optarg);
			if (dwLoc3860_1329 == 0x43)
				strcpy(&g_b806B2E0, optarg);
			if (dwLoc3860_1329 == 0x6D)
				strcpy(&g_b806BAE0, optarg);
			dwLoc3860_1329 = getopt_long(dwArg04, dwArg08, ":i:u:q:d:c:t:l:o:x:rhVg:b:fvs", &g_t8059100, &dwLoc3880);
		}
		if (dwLoc3868_1321 > 0x00)
		{
			if (dwLoc3868_1321 <= 0x01)
			{
				sprintf(0x080622A0, "GEM_C_OPTS=%s", &bLoc3818);
				putenv(0x080622A0, 0x080622A0, 0x08057A65);
				if (dwLoc3864 != 0x01)
				{
					if (dwLoc3864 != 0x02)
					{
						if (VERBOSE == 0x00)
						{
							memcpy(&g_b80672C0, &g_v8057A74, 0x20);
							mkstemp(0x080672C0, 0x080672C0, 0x08057A74, 0x20);
							if (open(&g_b80672C0, 0x40) == ~0x00)
							{
								strerror(*__errno_location());
								print_error(gs, ~0x1D, 0x08057A94);
							}
						}
						if (dwLoc3864 != 11)
						{
							if (dwLoc3864 != 0x0C)
							{
								if (strstr(&bLoc1018, "http://") != null || strstr(&bLoc1018, "ftp://") != null)
								{
									wget_extension(gs, &bLoc1018);
									char * eax_508 = malloc(0x0800);
									strcpy(eax_508, &bLoc1018);
									strcpy(&bLoc1018, strrchr(eax_508, '/') + 1);
									free(eax_508);
								}
								if (VERBOSE != 0x00)
									fprintf(stdout, "Extension location is '%s'.\n", &bLoc1018);
								if (dwLoc3864 != 0x0A)
								{
									if (stat(&bLoc1018, &dwLoc38D8) < 0x00)
									{
										strerror(*__errno_location());
										print_error(gs, ~0x01, 0x08057B44);
									}
									if ((dwLoc38C8 & 0xF000) == 0x4000)
									{
										if (VERBOSE != 0x00)
											fwrite(&g_v8057B6C, 0x01, 0x27, stdout);
									}
									else
									{
										if (VERBOSE != 0x00)
											fwrite(&g_v8057B94, 0x01, 0x2A, stdout);
										unpack_extension(gs, &bLoc1018);
										DIR * eax_601 = opendir(&g_b80632C0);
										struct dirent * dwLoc3878_1709 = readdir(eax_601);
										word32 dwLoc387C_1710 = 0x00;
										while (dwLoc3878_1709 != null)
										{
											if (strcmp((char *) dwLoc3878_1709 + 11, ".") != 0x00 && strcmp((char *) dwLoc3878_1709 + 11, "..") != 0x00)
											{
												sprintf(eax_130, "%s/%s", &g_b80632C0, (char *) dwLoc3878_1709 + 11);
												stat(eax_130, &dwLoc3930);
												if ((dwLoc3920 & 0xF000) == 0x4000)
												{
													dwLoc387C_1710 = 0x01;
													break;
												}
											}
											dwLoc3878_1709 = readdir(eax_601);
										}
										strcpy(&bLoc1018, eax_130);
										if (dwLoc387C_1710 == 0x00)
											print_error(gs, ~0x06, 0x08057BCC);
									}
								}
								if (dwLoc3864 == 0x0A)
									strcpy(&bLoc2818, &bLoc1018);
								else
									get_package_name(gs, &bLoc1018, &bLoc2818);
								if (dwLoc3868_1321 > 0x00)
								{
									if (dwLoc381C_1323 == 0x00)
										dwLoc381C_1323 = getenv("GISBASE");
									run_post(gs, &bLoc1018, dwLoc3864, dwLoc383C_1322, dwLoc381C_1323);
								}
								if (VERBOSE != 0x00)
									fprintf(stdout, "Extension will be installed from '%s'\n", &bLoc1018);
								if (dwLoc3864 != 0x0A)
									check_extension(gs, &bLoc1018, &bLoc2018, &dwLoc3840, &tLoc3844, &tLoc3848);
								if (dwLoc3864 != 0x05)
								{
									if (dwLoc3864 != 0x09)
									{
										if (dwLoc3864 != 0x07)
										{
											if (dwLoc3864 != 0x06)
											{
												if (dwLoc381C_1323 == 0x00)
												{
													Eq_95 eax_787 = getenv("GISBASE");
													dwLoc381C_1323 = eax_787;
													if (eax_787 == 0x00)
														print_error(gs, ~0x00, 0x08057ABC);
												}
												if (VERBOSE != 0x00)
													fprintf(stdout, "Path to GRASS is %s.\n", dwLoc381C_1323);
												Eq_95 eax_810 = getenv("GRASS_VERSION");
												Eq_95 dwLoc3820_1842 = eax_810;
												if (eax_810 == 0x00)
												{
													sprintf(&bLoc0818, "%s/etc/VERSIONNUMBER", dwLoc381C_1323);
													FILE * eax_825 = fopen(&bLoc0818, "r");
													if (eax_825 == null)
														print_error(gs, ~0x0A, 0x08057C4C);
													Eq_95 eax_830 = malloc(0x10);
													int32 eax_888 = __isoc99_fscanf(eax_825, 0x10, 0x08057C8B, eax_830);
													fclose(eax_825);
													dwLoc3820_1842 = eax_830;
													if (eax_888 <= 0x00)
														print_error(gs, ~0x0A, 0x08057C4C);
												}
												if (dwLoc3820_1842 != 0x00)
												{
													char * eax_914 = strtok(strdup(dwLoc3820_1842), ".");
													char * eax_919 = strtok(null, ".");
													char * eax_924 = strtok(null, ".");
													int32 eax_930 = strtol(eax_914);
													int32 eax_936 = strtol(eax_919);
													int32 eax_942 = strtol(eax_924);
													Eq_95 eax_945 = malloc(0x0800);
													sprintf(eax_945, "%i.%i.%i", eax_930, eax_936, eax_942);
													dwLoc3820_1842 = eax_945;
													if (VERBOSE != 0x00)
														fprintf(stdout, "GRASS version is %s.\n", eax_945);
													if (eax_930 <= 0x05)
														print_error(gs, ~0x0A, 0x08057CB0);
												}
												sprintf(&bLoc3818, "-L%s/lib -I/usr/local/grasslib/include/ ", dwLoc381C_1323);
												if (dwLoc3864 != 0x03)
												{
													if (dwLoc3864 != 0x0A)
													{
														if (dwLoc3864 != 0x08)
														{
															if (dwLoc3864 != 0x04)
																exit(0x00);
															else if (binaries_exist(gs, &bLoc1018, dwLoc383C_1322) == 0x00)
																print_error(gs, ~0x0B, 0x08057D11);
															else
															{
																bin_install(gs, &bLoc1018, dwLoc381C_1323, dwLoc383C_1322, &bLoc2818, dwLoc3840, tLoc3844, tLoc3848, dwLoc3820_1842);
																exit(0x00);
															}
														}
														else
														{
															test_install(gs, &bLoc1018, dwLoc381C_1323, &bLoc2818, dwLoc3840, tLoc3844, tLoc3848, dwLoc3820_1842);
															exit(0x00);
														}
													}
													else
													{
														uninstall(gs, &bLoc1018, &bLoc2818, dwLoc381C_1323, dwLoc3820_1842);
														exit(0x00);
													}
												}
												else
												{
													source_install(gs, &bLoc1018, dwLoc381C_1323, &bLoc2818, dwLoc3840, tLoc3844, tLoc3848, dwLoc3820_1842);
													exit(0x00);
												}
											}
											else
											{
												source_clean(gs, &bLoc1018);
												exit(0x00);
											}
										}
										else
											show_license(gs, &bLoc1018);
									}
									else
										show_details(gs, &bLoc1018);
								}
								else
									query_extension(gs, &bLoc1018, &bLoc2018, dwLoc3840, tLoc3844, tLoc3848, &bLoc3018, &bLoc1818);
							}
							else
							{
								if (dwLoc381C_1323 == 0x00)
								{
									Eq_95 eax_1137 = getenv("GISBASE");
									dwLoc381C_1323 = eax_1137;
									if (eax_1137 == 0x00)
										print_error(gs, ~0x00, 0x08057ABC);
								}
								if (VERBOSE != 0x00)
									fprintf(stdout, "Path to GRASS is %s.\n", dwLoc381C_1323);
								list_extensions(gs, dwLoc381C_1323);
								exit(0x00);
							}
						}
						else
						{
							if (dwLoc381C_1323 == 0x00)
							{
								Eq_95 eax_1175 = getenv("GISBASE");
								dwLoc381C_1323 = eax_1175;
								if (eax_1175 == 0x00)
									print_error(gs, ~0x00, 0x08057ABC);
							}
							if (VERBOSE != 0x00)
								fprintf(stdout, "Path to GRASS is %s.\n", dwLoc381C_1323);
							restore(gs, dwLoc381C_1323, dwLoc3820);
							exit(0x00);
						}
					}
					else
						show_version();
				}
				else
					show_help();
			}
			else
				print_error(gs, ~0x00, 0x08057A44);
		}
		else
			print_error(gs, ~0x00, 134576676);
	}
	else
		show_help();
}

// 080546E0: void __libc_csu_fini()
void __libc_csu_fini()
{
}

// 080546F0: void __libc_csu_init(Stack word32 dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C)
void __libc_csu_init(word32 dwArg04, word32 dwArg08, word32 dwArg0C)
{
	_init();
	int32 edi_30 = &g_ptr8058F10 - &g_ptr8058F10;
	if (edi_30 >> 0x02 != 0x00)
	{
		Eq_11435 esi_36 = 0x00;
		do
		{
			(*((char *) &g_ptr8058F10 + esi_36 * 0x04))();
			esi_36 = (word32) esi_36.u1 + 1;
		} while (esi_36 < edi_30 >> 0x02);
	}
}

// 0805474A: void __i686.get_pc_thunk.bx()
void __i686.get_pc_thunk.bx()
{
}

// 08054750: void atexit(Stack (ptr32 Eq_1589) dwArg04)
// Called from:
//      dump_plain
//      dump_html
//      register_extension
//      deregister_extension
//      register_entries_gisman
//      deregister_entries_gisman
//      restore_entries_gisman
//      register_html
//      deregister_html
//      restore_html
//      unpack_extension
//      source_install
//      bin_install
//      test_install
//      uninstall
//      run_post
//      main
void atexit(void (* dwArg04)(void * ptrArg04))
{
	struct Eq_11444 * eax_14 = g_ptr8058FF0;
	if (eax_14 != null)
		eax_14 = eax_14->ptr0000;
	__cxa_atexit(dwArg04, null, eax_14);
}

// 08054790: Register int32 stat(Stack Eq_95 dwArg04, Stack (ptr32 Eq_1884) dwArg08)
// Called from:
//      list_binaries
//      binaries_exist
//      source_install
//      bin_install
//      test_install
//      uninstall
//      main
int32 stat(Eq_95 dwArg04, struct stat * dwArg08)
{
	return __xstat(0x03, dwArg04, dwArg08);
}

// 080547D0: void __do_global_ctors_aux()
// Called from:
//      _init
void __do_global_ctors_aux()
{
	<anonymous> * eax_12 = g_ptr8058F10;
	if (eax_12 != (<anonymous> *) ~0x00)
	{
		word32 * ebx_15 = &g_ptr8058F10;
		do
		{
			eax_12();
			ebx_15 -= 0x04;
			eax_12 = *ebx_15;
		} while (eax_12 != (<anonymous> *) ~0x00);
	}
}

