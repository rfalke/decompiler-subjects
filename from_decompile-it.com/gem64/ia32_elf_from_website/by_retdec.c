//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) Retargetable Decompiler <info@retdec.com>
//

#include <dirent.h>
#include <errno.h>
#include <fcntl.h>
#include <getopt.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct __dirstream {
    int32_t e0;
};

struct dirent {
    int32_t e0;
    int32_t e1;
    int16_t e2;
    char e3;
    char e4[256];
};

struct option {
    char * e0;
    int32_t e1;
    int32_t * e2;
    int32_t e3;
};

// ------------------- Function Prototypes --------------------

int32_t __i686_get_pc_thunk_bx(int32_t a1, int32_t a2);
char * basename(char * path);
void bin_install(char * package, char * gisbase, char * bins, char * pkg_short_name, int32_t pkg_major, int32_t pkg_minor, int32_t pkg_revision, char * grass_version);
int32_t binaries_exist(char * package, char * binaries);
void check_dependencies(char * package, char * gisbase, char * grass_version);
int32_t check_ext_menu(char ** tcl_lines);
void check_extension(char * package, char * name, int32_t * major, int32_t * minor, int32_t * revision);
int32_t check_filetype(char * myfile);
int32_t chop(char * string);
void delete_ext_html(char * ext, char * gisbase, char ** html);
int32_t delete_str(int32_t pos, char ** strarr);
char * depstr(char * package, char * gisbase);
int32_t deregister_entries_gisman(char * pkg_short_name, char * gisbase);
void deregister_entries_gisman2(char * pkg_short_name, char * gisbase);
void deregister_extension(char * package, char * pkg_short_name, char * gisbase);
void deregister_html(char * pkg_short_name, char * gisbase);
void dump_ascii(char * file, char * heading);
void dump_html(char * file, char * tmpfile);
void dump_plain(char * file, char * tmpfile);
int32_t find_pos(char * str, char ** strarr, int32_t start);
void get_package_name(char * path, char * name);
int32_t insert_str(char * str, int32_t pos, char ** strarr);
int32_t is_submenu(char * item);
int32_t is_text(char * s);
void list_binaries(char * package);
void list_extensions(char * gisbase);
void mkdir_s(char * pathname, char * mode);
char * nc_fgets(char * s, int32_t size, struct _IO_FILE * stream);
char * nc_fgets_html(char * s, int32_t size, struct _IO_FILE * stream);
char * nc_fgets_nb(char * s, int32_t size, struct _IO_FILE * stream);
void new_ext_html(char * ext, char * gisbase, char ** html, int32_t major, int32_t minor, int32_t revision);
int32_t new_item(char * item, char * menu, char ** tcl_lines, int32_t line_no);
int32_t new_submenu(char * pkg_short_name, char * menu, char ** tcl_lines);
void print_cfg(void);
void print_done(void);
void print_error(int32_t err_code, char * msg, ...);
void print_warning(char * msg, ...);
void query_extension(char * package, char * name, int32_t major, int32_t minor, int32_t revision, char * short_name, char * invocation, char * org_name);
void register_entries_gisman(char * pkg_short_name, char * gisbase);
void register_entries_gisman2(char * pkg_short_name, char * gisbase);
void register_extension(char * gisbase, char * bins, char * pkg_short_name, int32_t pkg_major, int32_t pkg_minor, int32_t pkg_revision);
void register_html(char * pkg_short_name, char * gisbase, int32_t major, int32_t minor, int32_t revision);
void restore(char * gisbase, char * grass_version);
int32_t restore_entries_gisman(char * gisbase);
int32_t restore_html(char * gisbase);
void run_post(char * package, int32_t action, char * bins, char * gisbase);
void show_details(char * package);
void show_help(void);
void show_license(char * package);
void show_version(void);
int32_t source_clean(char * package);
void source_install(char * package, char * gisbase, char * pkg_short_name, int32_t pkg_major, int32_t pkg_minor, int32_t pkg_revision, char * grass_version);
void su(char * gisbase, char * cmd);
void test_install(char * package, char * gisbase, char * pkg_short_name, int32_t pkg_major, int32_t pkg_minor, int32_t pkg_revision, char * grass_version);
void uninstall(char * package, char * pkg_short_name, char * gisbase, char * grass_version);
void unpack_extension(char * package);
int32_t vercmp(int32_t major, int32_t minor, uint32_t revision, int32_t major2, int32_t minor2, uint32_t revision2);
void wget_extension(char * url);

// --------------------- Global Variables ---------------------

char CONFIG_CMD[2048]; // 0x806b2e0
char CONFIG_OPTS[2048]; // 0x806aae0
char CWD[2048]; // 0x806c2e0
int32_t ERROR = 0; // 0x806cae0
char EXT_BASE[2048]; // 0x8062aa0
int32_t FORCE = 0; // 0x80682c8
char GEM_ACTION[2048]; // 0x805f2a0
char GEM_C_OPTS[2048]; // 0x80622a0
char GEM_EXT_AUTHORS[2048]; // 0x805e2a0
char GEM_EXT_BUGS[2048]; // 0x805daa0
char GEM_EXT_DEPS[2048]; // 0x805d2a0
char GEM_EXT_DESCR[2048]; // 0x805c2a0
char GEM_EXT_INFO[2048]; // 0x805caa0
char GEM_EXT_NAME[2048]; // 0x805b2a0
char GEM_EXT_VERSION[2048]; // 0x805baa0
char GEM_FORCE[2048]; // 0x8060aa0
char GEM_GRASS_DIR[2048]; // 0x805eaa0
char GEM_GUI[2048]; // 0x8061aa0
char GEM_VERBOSE[2048]; // 0x80612a0
char GINSTALL_DST[2048]; // 0x80592a0
char GINSTALL_INC[2048]; // 0x8059aa0
char GINSTALL_LIB[2048]; // 0x805a2a0
char GISMAN2_CMD[2048]; // 0x8068ae0
char GISMAN_CMD[2048]; // 0x80682e0
char HTML_CMD[2048]; // 0x80692e0
char INSTALL_BASE[2048]; // 0x805faa0
char INSTALL_TYPE[2048]; // 0x80602a0
char MAKE_CMD[2048]; // 0x806bae0
char QGIS_CMD[2048]; // 0x8069ae0
int32_t SKIP_CFG = 0; // 0x80682d0
int32_t TMPCLEAN = 0; // 0x80682c0
char TMPDB[2048]; // 0x8063ac0
int32_t TMPDBCLEAN = 0; // 0x80682c4
char TMPDIR[2048]; // 0x80632c0
char TMP_AUTHORS[2048]; // 0x8066ac0
char TMP_BUGS[2048]; // 0x80662c0
char TMP_DEPS[2048]; // 0x8065ac0
char TMP_DESCR[2048]; // 0x8064ac0
char TMP_GISMAN[2048]; // 0x80642c0
char TMP_HTML[2048]; // 0x8067ac0
char TMP_INFO[2048]; // 0x80652c0
char TMP_NULL[2048]; // 0x80672c0
char UNINSTALL_BASE[2048]; // 0x805aaa0
char UNINSTALL_CMD[2048]; // 0x806a2e0
int32_t UPGRADE = 0; // 0x80682cc
int32_t VERBOSE = 0; // 0x80632a0
int32_t WARNINGS = 0; // 0x806cae4
char * g1 = "\x1b[1;31m\nERROR:\x1b[0m %s"; // 0x80549c0
char * g2 = "\x1b[0;33m\nWARNING:\x1b[0m %s"; // 0x80549d6
int32_t g3 = 0x3b305b1b; // 0x80549ee
char * g4; // 0x8054d15
int32_t g5 = 0x2f2e2e00; // 0x8055722
char * g6; // 0x805698c
int32_t g7 = 0x6e6f6300; // 0x8057925
int32_t g8 = 0x6d305b1b; // 0x8057935
char (*g9)[8] = "install"; // 0x8059100
int32_t g10 = 0; // 0x8059240
struct _IO_FILE * g11 = NULL; // 0x8059244
struct __dirstream * g12 = NULL; // 0x8059260
int32_t g13 = 0; // 0x8059264
char * g14; // 0x8059280
struct _IO_FILE * g15 = NULL; // 0x805928c
int32_t g16;
int32_t g17;
int32_t g18;

// ------------------------ Functions -------------------------

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/error.c
// Address range: 0x8049420 - 0x804949b
// Line range:    32 - 45
void print_error(int32_t err_code, char * msg, ...) {
    char buffer[2048]; // bp-2068, 0x8049420
    char v1[2048]; // 0x8049440
    // 0x8049420
    __readgsdword(20);
    int32_t v2; // bp+12, 0x8049420
    v1[0] = &v2;
    buffer = v1;
    int32_t str; // bp-2064, 0x8049420
    vsprintf((char *)&str, msg, *(int32_t *)&buffer);
    fprintf(g11, (char *)&g1);
    ERROR = err_code;
    exit(err_code);
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/error.c
// Address range: 0x804949b - 0x8049523
// Line range:    52 - 64
void print_warning(char * msg, ...) {
    char buffer[2048]; // bp-2068, 0x804949b
    char v1[2048]; // 0x80494bb
    int32_t v2 = __readgsdword(20); // 0x80494ad
    int32_t v3; // 0x804949b
    v1[0] = &v3;
    buffer = v1;
    int32_t str; // bp-2064, 0x804949b
    vsprintf((char *)&str, msg, *(int32_t *)&buffer);
    fprintf(g11, (char *)&g2);
    WARNINGS++;
    if (v2 != __readgsdword(20)) {
        // 0x804951c
        __stack_chk_fail();
    }
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/error.c
// Address range: 0x8049523 - 0x8049553
// Line range:    70 - 73
void print_done(void) {
    // 0x8049523
    fwrite(&g3, 1, 17, (struct _IO_FILE *)g12);
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/tools.c
// Address range: 0x8049554 - 0x804961d
// Line range:    33 - 66
char * basename(char * path) {
    char * str = strdup(path); // 0x8049560
    char * next_token = strtok(str, "/"); // 0x804957e
    if (next_token == NULL) {
        // 0x804958c
        if (str != NULL) {
            // 0x8049592
            free((int32_t *)str);
        }
        // 0x804961b
        return NULL;
    }
    char * v1 = strdup(next_token); // 0x80495aa
    int32_t v2 = (int32_t)v1;
    char * result = v1;
    char * next_token2 = strtok(NULL, "/"); // 0x80495c4
    char * v3 = v1; // 0x80495d0
    if (v1 != NULL && next_token2 != NULL) {
        // 0x80495d8
        free((int32_t *)v2);
        v3 = (char *)v2;
    }
    while (next_token2 != NULL) {
        int32_t v4 = v2; // 0x80495f1
        char * v5 = v3; // 0x80495f1
        if (*next_token2 != 0) {
            // 0x80495f3
            v5 = strdup(next_token2);
            v4 = (int32_t)v5;
        }
        v2 = v4;
        result = v5;
        next_token2 = strtok(NULL, "/");
        v3 = v5;
        if (v5 != NULL && next_token2 != NULL) {
            // 0x80495d8
            free((int32_t *)v2);
            v3 = (char *)v2;
        }
    }
    // 0x8049607
    if (str != NULL) {
        // 0x804960d
        free((int32_t *)str);
    }
    // 0x804961b
    return result;
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/tools.c
// Address range: 0x804961d - 0x804968f
// Line range:    73 - 80
void mkdir_s(char * pathname, char * mode) {
    char tmp[5000]; // bp-5024, 0x804961d
    char v1[5000]; // 0x8049629
    // 0x804961d
    v1[0] = (int32_t)pathname;
    tmp = v1;
    int32_t v2 = __readgsdword(20); // 0x8049638
    int32_t v3 = *(int32_t *)&tmp; // 0x8049652
    int32_t str; // bp-5016, 0x804961d
    sprintf((char *)&str, "mkdir %s --mode=%s -p", (char *)v3, mode);
    system((char *)&str);
    if (v2 != __readgsdword(20)) {
        // 0x8049688
        __stack_chk_fail();
    }
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/tools.c
// Address range: 0x804968f - 0x8049737
// Line range:    86 - 113
int32_t chop(char * string) {
    int32_t v1 = strlen(string) - 1;
    int32_t v2 = (int32_t)string;
    int32_t v3 = v1; // 0x8049717
    int32_t v4 = 0; // 0x8049717
    if (v1 < 0) {
        int32_t result = 0;
        *(char *)(v2 - result + strlen(string)) = 0;
        return result;
    }
    while (true) {
      lab_0x80496b6:;
        char v5 = *(char *)(v3 + v2); // 0x80496c3
        switch (v5) {
            case 10: {
                goto lab_0x8049709;
            }
            case 9: {
                goto lab_0x8049709;
            }
            case 32: {
                goto lab_0x8049709;
            }
            case 12: {
                goto lab_0x8049709;
            }
            default: {
                // 0x80496f1
                if (v5 != 13) {
                    // break -> 0x804971c
                    break;
                }
                goto lab_0x8049709;
            }
        }
    }
  lab_0x804971c:;
    // 0x804971c
    int32_t result2; // 0x804968f
    *(char *)(v2 - result2 + strlen(string)) = 0;
    return result2;
  lab_0x8049709:
    // 0x8049709
    v4++;
    v3--;
    result2 = v4;
    if (v3 < 0) {
        // break -> 0x804971c
        goto lab_0x804971c;
    }
    goto lab_0x80496b6;
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/tools.c
// Address range: 0x8049737 - 0x8049a5e
// Line range:    125 - 180
int32_t insert_str(char * str, int32_t pos, char ** strarr) {
    char last2[2048]; // bp-6164, 0x8049737
    char last[2048]; // bp-6168, 0x8049737
    char v1[2048]; // 0x80498ee
    char v2[2048]; // 0x804981c
    char v3[2048]; // 0x8049a1f
    char v4[2048]; // 0x80499b4
    char v5[2048]; // 0x804976a
    int32_t v6 = (int32_t)strarr;
    int32_t v7 = __readgsdword(20); // 0x8049753
    last2 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    int32_t v8 = *(int32_t *)&last2; // 0x8049771
    int32_t v9 = 4 * v8; // 0x8049777
    int32_t v10 = v8; // 0x8049784
    int32_t v11 = v9; // 0x8049784
    if (*(int32_t *)(v9 + v6) != 0) {
        v5[0] = (char)v8 + 1;
        last2 = v5;
        int32_t v12 = *(int32_t *)&last2; // 0x8049771
        int32_t v13 = 4 * v12; // 0x8049777
        v10 = v12;
        v11 = v13;
        while (*(int32_t *)(v13 + v6) != 0) {
            // 0x804976a
            v5[0] = (char)v12 + 1;
            last2 = v5;
            v12 = *(int32_t *)&last2;
            v13 = 4 * v12;
            v10 = v12;
            v11 = v13;
        }
    }
    // 0x8049786
    if (pos < 0 || v10 < pos) {
        // 0x8049797
        print_error(-21, "insert: invalid line number %i.\n", pos);
        // UNREACHABLE
    }
    if (v10 != pos) {
        int32_t v14 = v6 - 4;
        int32_t str3 = *(int32_t *)(v11 + v14); // 0x8049858
        int32_t str2; // bp-6160, 0x8049737
        strcpy((char *)&str2, (char *)str3);
        int32_t * str5 = (int32_t *)(4 * pos + v6); // 0x8049878
        int32_t str4; // bp-4112, 0x8049737
        strcpy((char *)&str4, (char *)*str5);
        free((int32_t *)*str5);
        int32_t * mem = malloc(strlen(str) + 1); // 0x80498c4
        *str5 = (int32_t)mem;
        strcpy((char *)mem, str);
        v1[0] = pos;
        last = v1;
        int32_t v15 = *(int32_t *)&last2; // 0x80499bb
        int32_t v16 = *(int32_t *)&last; // 0x80499c4
        int32_t v17 = v15; // 0x80499ca
        if (v15 - 1 > v16) {
            int32_t v18 = v6 + 4;
            int32_t * str7 = (int32_t *)(4 * v16 + v18);
            int32_t str6; // bp-2064, 0x8049737
            strcpy((char *)&str6, (char *)*str7);
            free((int32_t *)*str7);
            *str7 = (int32_t)malloc(strlen((char *)&str4) + 1);
            int32_t v19 = *(int32_t *)&last;
            strcpy((char *)*(int32_t *)(4 * v19 + v18), (char *)&str4);
            strcpy((char *)&str4, (char *)&str6);
            v4[0] = (char)v19 + 1;
            last = v4;
            int32_t v20 = *(int32_t *)&last2; // 0x80499bb
            uint32_t v21 = *(int32_t *)&last; // 0x80499c4
            v17 = v20;
            while (v20 - 1 > v21) {
                // 0x80498f9
                str7 = (int32_t *)(4 * v21 + v18);
                strcpy((char *)&str6, (char *)*str7);
                free((int32_t *)*str7);
                *str7 = (int32_t)malloc(strlen((char *)&str4) + 1);
                v19 = *(int32_t *)&last;
                strcpy((char *)*(int32_t *)(4 * v19 + v18), (char *)&str4);
                strcpy((char *)&str4, (char *)&str6);
                v4[0] = (char)v19 + 1;
                last = v4;
                v20 = *(int32_t *)&last2;
                v21 = *(int32_t *)&last;
                v17 = v20;
            }
        }
        int32_t * mem2 = malloc(strlen((char *)&str2) + 1); // 0x80499f5
        *(int32_t *)(4 * v17 + v6) = (int32_t)mem2;
        int32_t v22 = *(int32_t *)&last2;
        strcpy((char *)*(int32_t *)(4 * v22 + v6), (char *)&str2);
        v3[0] = (char)v22 + 2;
        last2 = v3;
        *(int32_t *)(4 * *(int32_t *)&last2 + v14) = 0;
    } else {
        // 0x80497c1
        *(int32_t *)(4 * v10 + v6) = (int32_t)malloc(strlen(str) + 1);
        int32_t v23 = *(int32_t *)&last2;
        strcpy((char *)*(int32_t *)(4 * v23 + v6), str);
        v2[0] = (char)v23 + 2;
        last2 = v2;
        *(int32_t *)(v6 - 4 + 4 * *(int32_t *)&last2) = 0;
    }
    int32_t result = *(int32_t *)&last2; // 0x8049a4e
    if (v7 != __readgsdword(20)) {
        // 0x8049a50
        __stack_chk_fail();
        result = &g18;
    }
    // 0x8049a55
    return result;
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/tools.c
// Address range: 0x8049a5e - 0x8049b5f
// Line range:    190 - 221
int32_t delete_str(int32_t pos, char ** strarr) {
    int32_t v1 = (int32_t)strarr;
    int32_t v2 = 0; // 0x8049a6c
    while (*(int32_t *)(4 * v2 + v1) != 0) {
        // 0x8049a72
        v2++;
    }
    if (pos < 0 || v2 < pos) {
        // 0x8049a8f
        print_error(-21, "delete: invalid line number %i.\n", pos);
        // UNREACHABLE
    }
    int32_t v3 = 4 * pos; // 0x8049b33
    int32_t * v4 = (int32_t *)(v3 + v1); // 0x8049b39
    int32_t v5 = *v4; // 0x8049b39
    int32_t result; // 0x8049b43
    if (v5 == 0) {
        // 0x8049b43
        result = pos - 1;
        *(int32_t *)(4 * result + v1) = 0;
        return result;
    }
    int32_t v6 = pos; // 0x8049b2c
    free((int32_t *)v5);
    int32_t * str2 = (int32_t *)(v1 + 4 + v3); // 0x8049ad1
    int32_t str = *str2; // 0x8049ad1
    int32_t * mem; // 0x8049afe
    if (str != 0) {
        // 0x8049ad7
        mem = malloc(strlen((char *)str) + 1);
        *v4 = (int32_t)mem;
        strcpy((char *)mem, (char *)*str2);
    }
    // 0x8049b2c
    v6++;
    int32_t v7 = 4 * v6; // 0x8049b33
    int32_t * v8 = (int32_t *)(v7 + v1); // 0x8049b39
    int32_t v9 = *v8; // 0x8049b39
    int32_t * v10 = v8; // 0x8049b3d
    while (v9 != 0) {
        // 0x8049ab2
        free((int32_t *)v9);
        str2 = (int32_t *)(v1 + 4 + v7);
        str = *str2;
        if (str != 0) {
            // 0x8049ad7
            mem = malloc(strlen((char *)str) + 1);
            *v10 = (int32_t)mem;
            strcpy((char *)mem, (char *)*str2);
        }
        // 0x8049b2c
        v6++;
        v7 = 4 * v6;
        v8 = (int32_t *)(v7 + v1);
        v9 = *v8;
        v10 = v8;
    }
    // 0x8049b43
    result = v6 - 1;
    *(int32_t *)(4 * result + v1) = 0;
    return result;
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/tools.c
// Address range: 0x8049b5f - 0x8049bd9
// Line range:    230 - 251
int32_t find_pos(char * str, char ** strarr, int32_t start) {
    int32_t v1 = (int32_t)strarr;
    uint32_t v2 = 0; // 0x8049b6c
    while (*(int32_t *)(4 * v2 + v1) != 0) {
        // 0x8049b72
        v2++;
    }
    if (start < 0 || v2 < start) {
        // 0x8049b8f
        exit(-21);
        // UNREACHABLE
    }
    // 0x8049bca
    if (v2 <= start) {
        // 0x8049bd7
        return -1;
    }
    int32_t v3 = start; // 0x8049bd0
    int32_t result = v3; // 0x8049bbf
    while (strstr((char *)*(int32_t *)(4 * v3 + v1), str) == NULL) {
        // 0x8049bc6
        v3++;
        result = -1;
        if (v3 >= v2) {
            // break -> 0x8049bd7
            break;
        }
        result = v3;
    }
    // 0x8049bd7
    return result;
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/tools.c
// Address range: 0x8049c27 - 0x8049d41
// Line range:    273 - 298
void get_package_name(char * path, char * name) {
    char tmp[2048]; // bp-4116, 0x8049c27
    char v1[2048]; // 0x8049c8d
    int32_t v2 = __readgsdword(20); // 0x8049c42
    int32_t str; // bp-2064, 0x8049c27
    sprintf((char *)&str, "%s/%s", path, "name");
    struct _IO_FILE * file = fopen((char *)&str, "r"); // 0x8049c88
    v1[0] = (int32_t)file;
    tmp = v1;
    int32_t v3 = *(int32_t *)&tmp; // 0x8049c93
    if (v3 == 0) {
        // 0x8049c9c
        print_error(-6, "'name' file not readable.\n");
        // UNREACHABLE
    }
    struct _IO_FILE * file2 = (struct _IO_FILE *)v3;
    int32_t str2; // bp-4112, 0x8049c27
    if (nc_fgets_nb((char *)&str2, 2048, file2) == NULL) {
        // 0x8049cd6
        fclose(file2);
        print_error(-6, "invalid or missing extension name.\n");
        // UNREACHABLE
    }
    // 0x8049cfa
    chop((char *)&str2);
    strcpy(name, (char *)&str2);
    fclose(file2);
    if (v2 != __readgsdword(20)) {
        // 0x8049d3a
        __stack_chk_fail();
    }
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/tools.c
// Address range: 0x8049d41 - 0x8049e14
// Line range:    307 - 333
char * nc_fgets(char * s, int32_t size, struct _IO_FILE * stream) {
    // 0x8049d41
    if (fgets(s, size, stream) == NULL) {
        // 0x8049e12
        return (char *)0;
    }
    int32_t v1 = (int32_t)s;
    char * found_char_pos = strchr(s, 35); // 0x8049d7c
    if (found_char_pos == NULL) {
        // 0x8049e12
        return (char *)v1;
    }
    int32_t v2; // 0x8049d41
    if (found_char_pos != s) {
        int32_t * mem = malloc(2048); // 0x8049db8
        strcpy((char *)mem, s);
        char * next_token = strtok((char *)mem, "#"); // 0x8049de1
        sprintf(s, "%s\n", next_token);
        free((int32_t *)next_token);
        v2 = v1;
    } else {
        // 0x8049d96
        v2 = (int32_t)nc_fgets(s, size, stream);
    }
    // 0x8049e12
    return (char *)v2;
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/tools.c
// Address range: 0x8049e14 - 0x804a146
// Line range:    339 - 467
char * nc_fgets_html(char * s, int32_t size, struct _IO_FILE * stream) {
    // 0x8049e14
    if (fgets(s, size, stream) == NULL) {
        // 0x804a144
        return (char *)0;
    }
    int32_t v1 = (int32_t)s;
    int32_t * mem = malloc(strlen(s) + 1); // 0x8049e52
    char * tag_2 = (char *)malloc(strlen(s) + 1); // bp-36, 0x8049e70
    char * tag_insert; // bp-40, 0x8049e14
    *(int32_t *)&tag_insert = v1;
    char v2 = *s; // 0x804a067
    char * v3; // 0x8049e14
    char * v4; // 0x8049e14
    int32_t v5; // 0x8049e14
    char v6; // 0x8049e14
    char v7; // 0x8049e14
    char * v8; // 0x8049e14
    char * v9; // 0x8049e14
    char * v10; // 0x8049e14
    char * v11; // 0x8049e14
    char * v12; // 0x8049e14
    char * v13; // 0x8049e14
    char * v14; // 0x8049e14
    if (v2 != 0) {
        // 0x8049e84
        v4 = s;
        v5 = v1;
        v6 = v2;
        v12 = (char *)mem;
        while (true) {
          lab_0x8049e84:
            // 0x8049e84
            v13 = v12;
            char * v15 = v11;
            v3 = v4;
            v9 = v15;
            if (v6 != 60) {
                goto lab_0x804a047;
            } else {
                // 0x8049e92
                char * hashmark; // bp-24, 0x8049e14
                *(int32_t *)&hashmark = v5;
                char * tag; // bp-32, 0x8049e14
                *(int32_t *)&tag = (int32_t)tag_2;
                uint32_t v16 = v5 - 1; // 0x8049e9e
                char * v17 = (char *)v16; // 0x8049e9e
                tag_insert = v17;
                char * v18 = v15; // 0x8049ea8
                if (v16 >= (int32_t)s) {
                    // 0x8049eae
                    v18 = *v17 != 32 ? NULL : (char *)1;
                }
                char * v19 = (char *)v5;
                char * v20 = v18;
                char v21 = *v19; // 0x804a036
                char * v22 = v19; // 0x804a03b
                char v23 = v21; // 0x804a03b
                v3 = v17;
                v9 = v20;
                if (v21 != 0) {
                    char * v24 = v22;
                    *tag_2 = v23 + 1;
                    while (*v24 != 62) {
                        char * v25 = (char *)((int32_t)v24 + 1);
                        char v26 = *v25; // 0x804a036
                        v22 = v25;
                        v23 = v26;
                        if (v26 == 0) {
                            // 0x804a033
                            hashmark = v25;
                            v3 = tag_insert;
                            v9 = v20;
                            goto lab_0x804a047;
                        }
                        v24 = v22;
                        *tag_2 = v23 + 1;
                    }
                    // 0x8049ef7
                    hashmark = v24;
                    *tag = 0;
                    if (*(char *)((int32_t)v24 + 1) != 10) {
                        char * substr_pos = strstr(tag_2, "<br>"); // 0x8049f23
                        char * str = tag_2; // 0x8049f2a
                        if (v13 > (char *)mem == (substr_pos != NULL)) {
                            // 0x8049f34
                            *v13 = 11;
                            str = tag_2;
                        }
                        // 0x8049f48
                        if (v13 > (char *)mem == (strstr(str, "<BR>") != NULL)) {
                            // 0x8049f67
                            *v13 = 11;
                        }
                        char * substr_pos2 = strstr(tag_2, "<p>"); // 0x8049f89
                        char * str2 = tag_2; // 0x8049f90
                        if (substr_pos2 != NULL) {
                            if (v13 > (char *)mem) {
                                // 0x8049f9a
                                *v13 = 11;
                            }
                            // 0x8049fae
                            *v13 = 11;
                            str2 = tag_2;
                        }
                        // 0x8049fc2
                        if (strstr(str2, "<P>") != NULL) {
                            if (v13 > (char *)mem) {
                                // 0x8049fe1
                                *v13 = 11;
                            }
                            // 0x8049ff5
                            *v13 = 11;
                        }
                    }
                    char * v27 = hashmark; // 0x804a009
                    tag_insert = v27;
                    char v28 = *v27;
                    v7 = v28;
                    v8 = v27;
                    v10 = v20;
                    if (v20 == (char *)1 == v28 == 32) {
                        char * v29 = (char *)((int32_t)v27 + 1); // 0x804a01f
                        tag_insert = v29;
                        v3 = v29;
                        v9 = NULL;
                        goto lab_0x804a047;
                    } else {
                        goto lab_0x804a047_2;
                    }
                } else {
                    goto lab_0x804a047;
                }
            }
        }
    } else {
        // 0x8049e41
        v14 = (char *)mem;
    }
  lab_0x804a072:
    // 0x804a072
    *v14 = 0;
    int32_t v30 = (int32_t)s;
    strcpy(s, (char *)mem);
    free(mem);
    free((int32_t *)tag_2);
    char * found_char_pos = strchr(s, 35); // 0x804a0ae
    if (found_char_pos == NULL) {
        // 0x804a144
        return (char *)v30;
    }
    int32_t v31; // 0x8049e14
    if (found_char_pos != s) {
        int32_t * mem2 = malloc(2048); // 0x804a0ea
        strcpy((char *)mem2, s);
        char * next_token = strtok((char *)mem2, "#"); // 0x804a113
        sprintf(s, "%s\n", next_token);
        free((int32_t *)next_token);
        v31 = v30;
    } else {
        // 0x804a0c8
        v31 = (int32_t)nc_fgets_html(s, size, stream);
    }
    // 0x804a144
    return (char *)v31;
  lab_0x804a047:
    // 0x804a047
    v7 = *v3;
    v8 = v3;
    v10 = v9;
    goto lab_0x804a047_2;
  lab_0x804a047_2:;
    char v32 = v7; // 0x804a04a
    char * v33 = v8; // 0x804a04f
    char * v34 = v13; // 0x804a04f
    if (v32 != 62) {
        // 0x804a051
        *v13 = v32;
        v33 = tag_insert;
        v34 = (char *)((int32_t)v13 + 1);
    }
    int32_t v35 = (int32_t)v33 + 1; // 0x804a060
    char * v36 = (char *)v35; // 0x804a060
    tag_insert = v36;
    char v37 = *v36; // 0x804a067
    v4 = v36;
    v5 = v35;
    v6 = v37;
    v11 = v10;
    v12 = v34;
    v14 = v34;
    if (v37 == 0) {
        // break -> 0x804a072
        goto lab_0x804a072;
    }
    goto lab_0x8049e84;
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/tools.c
// Address range: 0x804a146 - 0x804a1c8
// Line range:    474 - 493
int32_t is_text(char * s) {
    int32_t v1 = strlen(s) - 1;
    if (v1 < 0) {
        // 0x804a1c3
        return 0;
    }
    int32_t v2 = v1;
    while (true) {
      lab_0x804a166:;
        char v3 = *(char *)(v2 + (int32_t)s); // 0x804a16c
        switch (v3) {
            case 32: {
                goto lab_0x804a1a7;
            }
            case 9: {
                goto lab_0x804a1a7;
            }
            case 10: {
                goto lab_0x804a1a7;
            }
            case 12: {
                goto lab_0x804a1a7;
            }
            default: {
                // 0x804a19a
                if (v3 != 13) {
                    // break -> 0x804a1c3
                    break;
                }
                goto lab_0x804a1a7;
            }
        }
    }
    // 0x804a1c3
    return 0;
  lab_0x804a1a7:
    // 0x804a1a7
    v2--;
    if (v2 < 0) {
        return 0;
    }
    goto lab_0x804a166;
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/tools.c
// Address range: 0x804a1c8 - 0x804a2c8
// Line range:    500 - 532
char * nc_fgets_nb(char * s, int32_t size, struct _IO_FILE * stream) {
    // 0x804a1c8
    if (fgets(s, size, stream) == NULL) {
        // 0x804a2c6
        return (char *)0;
    }
    // 0x804a1f5
    if (is_text(s) == 0) {
        // 0x804a2c6
        return (char *)(int32_t)nc_fgets_nb(s, size, stream);
    }
    int32_t v1 = (int32_t)s;
    char * found_char_pos = strchr(s, 35); // 0x804a230
    if (found_char_pos == NULL) {
        // 0x804a2c6
        return (char *)v1;
    }
    int32_t v2; // 0x804a1c8
    if (found_char_pos != s) {
        int32_t * mem = malloc(2048); // 0x804a26c
        strcpy((char *)mem, s);
        char * next_token = strtok((char *)mem, "#"); // 0x804a295
        sprintf(s, "%s\n", next_token);
        free((int32_t *)next_token);
        v2 = v1;
    } else {
        // 0x804a24a
        v2 = (int32_t)nc_fgets_nb(s, size, stream);
    }
    // 0x804a2c6
    return (char *)v2;
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/tools.c
// Address range: 0x804a2c8 - 0x804a3db
// Line range:    539 - 556
void dump_ascii(char * file, char * heading) {
    char tmp[2048]; // bp-2068, 0x804a2c8
    char v1[2048]; // 0x804a325
    int32_t v2 = __readgsdword(20); // 0x804a2e3
    fprintf((struct _IO_FILE *)g12, "%s\n", heading);
    struct _IO_FILE * file2 = fopen(file, "r"); // 0x804a320
    v1[0] = (int32_t)file2;
    tmp = v1;
    int32_t v3 = *(int32_t *)&tmp; // 0x804a32b
    if (v3 != 0) {
        struct _IO_FILE * file3 = (struct _IO_FILE *)v3;
        int32_t v4; // bp-2064, 0x804a2c8
        if (nc_fgets_html((char *)&v4, 2048, file3) != NULL) {
            fprintf((struct _IO_FILE *)g12, "  %s", &v4);
            while (nc_fgets_html((char *)&v4, 2048, file3) != NULL) {
                // 0x804a35e
                fprintf((struct _IO_FILE *)g12, "  %s", &v4);
            }
        }
        // 0x804a3a5
        fputc(10, (struct _IO_FILE *)g12);
        fclose(file3);
    } else {
        // 0x804a334
        fwrite((int32_t *)"  No information available.\n", 1, 28, (struct _IO_FILE *)g12);
    }
    // 0x804a3c8
    if (v2 != __readgsdword(20)) {
        // 0x804a3d4
        __stack_chk_fail();
    }
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/tools.c
// Address range: 0x804a3db - 0x804a51b
// Line range:    563 - 590
void dump_plain(char * file, char * tmpfile) {
    char tmp2[2048]; // bp-2068, 0x804a3db
    char tmp[2048]; // bp-2072, 0x804a3db
    char v1[2048]; // 0x804a445
    char v2[2048]; // 0x804a4a8
    int32_t v3 = __readgsdword(20); // 0x804a3f6
    memcpy((int32_t *)tmpfile, (int32_t *)"/tmp/grass.extensions.db.XXXXXX", 32);
    mkstemp(tmpfile);
    struct _IO_FILE * file2 = fopen(tmpfile, "w+"); // 0x804a440
    v1[0] = (int32_t)file2;
    tmp = v1;
    int32_t v4 = *(int32_t *)&tmp; // 0x804a44b
    if (v4 == 0) {
        int32_t err_num = *__errno_location(); // 0x804a459
        print_error(-23, "could not create temp file '%s': %s\n \t\tMake sure that directory /tmp exists on your system and you have write permission.\n", tmpfile, strerror(err_num));
        // UNREACHABLE
    }
    // 0x804a485
    atexit(0x8048fc2);
    struct _IO_FILE * file3 = fopen(file, "r"); // 0x804a4a3
    v2[0] = (int32_t)file3;
    tmp2 = v2;
    struct _IO_FILE * file4 = (struct _IO_FILE *)*(int32_t *)&tmp2;
    int32_t format; // bp-2064, 0x804a3db
    char * v5 = nc_fgets((char *)&format, 2048, file4); // 0x804a4e3
    struct _IO_FILE * stream = (struct _IO_FILE *)v4;
    if (v5 != NULL) {
        fprintf(stream, (char *)&format);
        while (nc_fgets((char *)&format, 2048, file4) != NULL) {
            // 0x804a4b0
            fprintf(stream, (char *)&format);
        }
    }
    // 0x804a4ec
    fclose(file4);
    fclose(stream);
    if (v3 != __readgsdword(20)) {
        // 0x804a514
        __stack_chk_fail();
    }
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/tools.c
// Address range: 0x804a51b - 0x804a6da
// Line range:    597 - 634
void dump_html(char * file, char * tmpfile) {
    char line2[2048]; // bp-4116, 0x804a51b
    char line[2048]; // bp-4120, 0x804a51b
    char v1[2048]; // 0x804a585
    char v2[2048]; // 0x804a5e8
    int32_t v3 = __readgsdword(20); // 0x804a536
    memcpy((int32_t *)tmpfile, (int32_t *)"/tmp/grass.extensions.db.XXXXXX", 32);
    mkstemp(tmpfile);
    struct _IO_FILE * file2 = fopen(tmpfile, "w+"); // 0x804a580
    v1[0] = (int32_t)file2;
    line = v1;
    int32_t v4 = *(int32_t *)&line; // 0x804a58b
    if (v4 == 0) {
        int32_t err_num = *__errno_location(); // 0x804a599
        print_error(-23, "could not create temp file '%s': %s\n \t\tMake sure that directory /tmp exists on your system and you have write permission.\n", tmpfile, strerror(err_num));
        // UNREACHABLE
    }
    // 0x804a5c5
    atexit(0x8048fc2);
    struct _IO_FILE * file3 = fopen(file, "r"); // 0x804a5e3
    v2[0] = (int32_t)file3;
    line2 = v2;
    struct _IO_FILE * file4 = (struct _IO_FILE *)*(int32_t *)&line2;
    int32_t v5; // bp-4112, 0x804a51b
    char * v6 = nc_fgets((char *)&v5, 2048, file4); // 0x804a690
    struct _IO_FILE * stream = (struct _IO_FILE *)v4;
    if (v6 != NULL) {
        chop((char *)&v5);
        int32_t str; // bp-2064, 0x804a51b
        if (is_text((char *)&v5) != 0) {
            // 0x804a63c
            sprintf((char *)&str, "%s <br>\n", &v5);
            fprintf(stream, (char *)&str);
        } else {
            // 0x804a613
            fwrite((int32_t *)"<p>\n", 1, 4, stream);
        }
        while (nc_fgets((char *)&v5, 2048, file4) != NULL) {
            // 0x804a5f3
            chop((char *)&v5);
            if (is_text((char *)&v5) != 0) {
                // 0x804a63c
                sprintf((char *)&str, "%s <br>\n", &v5);
                fprintf(stream, (char *)&str);
            } else {
                // 0x804a613
                fwrite((int32_t *)"<p>\n", 1, 4, stream);
            }
        }
    }
    // 0x804a69d
    fclose(file4);
    fclose(stream);
    int32_t fd; // 0x804a51b
    close(fd);
    if (v3 != __readgsdword(20)) {
        // 0x804a6d3
        __stack_chk_fail();
    }
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/tools.c
// Address range: 0x804a6da - 0x804a92c
// Line range:    642 - 683
void list_binaries(char * package) {
    char tmp2[2048]; // bp-2068, 0x804a6da
    char tmp[2048]; // bp-2072, 0x804a6da
    char v1[2048]; // 0x804a781
    char v2[2048]; // 0x804a8ad
    char v3[2048]; // 0x804a737
    int32_t v4 = __readgsdword(20); // 0x804a6ec
    fwrite((int32_t *)"Binary installation files\n", 1, 26, (struct _IO_FILE *)g12);
    struct __dirstream * v5 = opendir(package); // 0x804a732
    v3[0] = (int32_t)v5;
    tmp2 = v3;
    int32_t v6 = *(int32_t *)&tmp2; // 0x804a73d
    if (v6 != 0) {
        struct __dirstream * dirp = (struct __dirstream *)v6;
        struct dirent * v7 = readdir(dirp); // 0x804a77c
        v1[0] = (int32_t)v7;
        tmp = v1;
        int32_t v8 = *(int32_t *)&tmp; // 0x804a8b3
        if (v8 != 0) {
            int32_t v9 = 0;
            char * str = (char *)(v8 + 11);
            int32_t v10 = v9; // 0x804a7a7
            int32_t str2; // bp-2064, 0x804a6da
            int32_t buf; // bp-2164, 0x804a6da
            int32_t v11; // 0x804a6da
            if (strcmp(str, ".") != 0) {
                // 0x804a7ad
                v10 = v9;
                if (strcmp(str, "..") != 0) {
                    // 0x804a7ce
                    v10 = v9;
                    if (strcmp(str, "src") != 0) {
                        // 0x804a7ef
                        sprintf((char *)&str2, "%s/%s", package, str);
                        stat(&str2, &buf);
                        v10 = v9;
                        if ((v11 & 0xf000) == 0x4000) {
                            // 0x804a847
                            if (v9 != 0) {
                                // 0x804a875
                                fprintf((struct _IO_FILE *)g12, ", %s", str);
                            } else {
                                // 0x804a850
                                fprintf((struct _IO_FILE *)g12, "  %s", str);
                            }
                            // 0x804a898
                            v10 = v9 + 1;
                        }
                    }
                }
            }
            int32_t v12 = v10;
            struct dirent * v13 = readdir(dirp); // 0x804a8a8
            v2[0] = (int32_t)v13;
            tmp = v2;
            int32_t v14 = *(int32_t *)&tmp; // 0x804a8b3
            while (v14 != 0) {
                // 0x804a78c
                v9 = v12;
                str = (char *)(v14 + 11);
                v10 = v9;
                if (strcmp(str, ".") != 0) {
                    // 0x804a7ad
                    v10 = v9;
                    if (strcmp(str, "..") != 0) {
                        // 0x804a7ce
                        v10 = v9;
                        if (strcmp(str, "src") != 0) {
                            // 0x804a7ef
                            sprintf((char *)&str2, "%s/%s", package, str);
                            stat(&str2, &buf);
                            v10 = v9;
                            if ((v11 & 0xf000) == 0x4000) {
                                // 0x804a847
                                if (v9 != 0) {
                                    // 0x804a875
                                    fprintf((struct _IO_FILE *)g12, ", %s", str);
                                } else {
                                    // 0x804a850
                                    fprintf((struct _IO_FILE *)g12, "  %s", str);
                                }
                                // 0x804a898
                                v10 = v9 + 1;
                            }
                        }
                    }
                }
                // 0x804a89f
                v12 = v10;
                v13 = readdir(dirp);
                v2[0] = (int32_t)v13;
                tmp = v2;
                v14 = *(int32_t *)&tmp;
            }
            if (v12 != 0) {
                // 0x804a8f1
                fwrite((int32_t *)"\n\n", 1, 2, (struct _IO_FILE *)g12);
                goto lab_0x804a919;
            } else {
                // 0x804a8c9
                fwrite((int32_t *)"  None.", 1, 7, (struct _IO_FILE *)g12);
                // 0x804a8f1
                fwrite((int32_t *)"\n\n", 1, 2, (struct _IO_FILE *)g12);
                goto lab_0x804a919;
            }
        } else {
            // 0x804a8c9
            fwrite((int32_t *)"  None.", 1, 7, (struct _IO_FILE *)g12);
            // 0x804a8f1
            fwrite((int32_t *)"\n\n", 1, 2, (struct _IO_FILE *)g12);
            goto lab_0x804a919;
        }
    } else {
        // 0x804a746
        fwrite((int32_t *)"  None.\n\n", 1, 9, (struct _IO_FILE *)g12);
        goto lab_0x804a919;
    }
  lab_0x804a919:
    // 0x804a919
    if (v4 != __readgsdword(20)) {
        // 0x804a925
        __stack_chk_fail();
    }
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/tools.c
// Address range: 0x804a92c - 0x804aaa8
// Line range:    690 - 720
int32_t binaries_exist(char * package, char * binaries) {
    char tmp2[2048]; // bp-2068, 0x804a92c
    char tmp[2048]; // bp-2072, 0x804a92c
    char v1[2048]; // 0x804aa7d
    char v2[2048]; // 0x804a960
    char v3[2048]; // 0x804a987
    int32_t v4 = __readgsdword(20); // 0x804a947
    struct __dirstream * v5 = opendir(package); // 0x804a95b
    v2[0] = (int32_t)v5;
    tmp2 = v2;
    int32_t v6 = *(int32_t *)&tmp2; // 0x804a966
    int32_t v7 = 0; // 0x804a96d
    if (v6 != 0) {
        struct __dirstream * dirp = (struct __dirstream *)v6;
        struct dirent * v8 = readdir(dirp); // 0x804a982
        v3[0] = (int32_t)v8;
        tmp = v3;
        int32_t v9 = *(int32_t *)&tmp; // 0x804aa83
        v7 = 0;
        if (v9 != 0) {
            char * str = (char *)(v9 + 11);
            int32_t str2; // bp-2064, 0x804a92c
            int32_t buf; // bp-2160, 0x804a92c
            int32_t v10; // 0x804a92c
            if (strcmp(str, ".") != 0) {
                // 0x804a9b3
                if (strcmp(str, "..") != 0) {
                    // 0x804a9d4
                    if (strcmp(str, "src") != 0) {
                        // 0x804a9f1
                        sprintf((char *)&str2, "%s/%s", package, str);
                        stat(&str2, &buf);
                        if ((v10 & 0xf000) == 0x4000) {
                            // 0x804aa49
                            if (strcmp(str, binaries) == 0) {
                                // break -> 0x804aa95
                                break;
                            }
                        }
                    }
                }
            }
            struct dirent * v11 = readdir(dirp); // 0x804aa78
            v1[0] = (int32_t)v11;
            tmp = v1;
            int32_t v12 = *(int32_t *)&tmp; // 0x804aa83
            v7 = 0;
            while (v12 != 0) {
                // 0x804a992
                str = (char *)(v12 + 11);
                if (strcmp(str, ".") != 0) {
                    // 0x804a9b3
                    if (strcmp(str, "..") != 0) {
                        // 0x804a9d4
                        if (strcmp(str, "src") != 0) {
                            // 0x804a9f1
                            sprintf((char *)&str2, "%s/%s", package, str);
                            stat(&str2, &buf);
                            if ((v10 & 0xf000) == 0x4000) {
                                // 0x804aa49
                                v7 = 1;
                                if (strcmp(str, binaries) == 0) {
                                    // break -> 0x804aa95
                                    break;
                                }
                            }
                        }
                    }
                }
                // 0x804aa6f
                v11 = readdir(dirp);
                v1[0] = (int32_t)v11;
                tmp = v1;
                v12 = *(int32_t *)&tmp;
                v7 = 0;
            }
        }
    }
    int32_t result = v7; // 0x804aa9f
    if (v4 != __readgsdword(20)) {
        // 0x804aaa1
        __stack_chk_fail();
        result = &g18;
    }
    // 0x804aaa6
    return result;
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/tools.c
// Address range: 0x804aaa8 - 0x804ab6c
// Line range:    737 - 760
int32_t check_filetype(char * myfile) {
    // 0x804aaa8
    if (strstr(myfile, ".tar.gz") != NULL || strstr(myfile, ".tgz") != NULL) {
        // 0x804ab6a
        return 1;
    }
    // 0x804aaed
    if (strstr(myfile, ".tar.bz2") != NULL || strstr(myfile, ".tbz") != NULL) {
        // 0x804ab6a
        return 2;
    }
    int32_t result = 3; // 0x804ab3e
    if (strstr(myfile, ".zip") == NULL) {
        // 0x804ab47
        result = strstr(myfile, ".tar") == NULL ? 0 : 4;
    }
    // 0x804ab6a
    return result;
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/tools.c
// Address range: 0x804ab6c - 0x804ac6e
// Line range:    766 - 789
void wget_extension(char * url) {
    char str[2048]; // bp-2068, 0x804ab6c
    char v1[2048]; // 0x804ac0c
    int32_t v2 = __readgsdword(20); // 0x804ab7e
    fwrite((int32_t *)"Downloading...", 1, 14, (struct _IO_FILE *)g12);
    int32_t str2; // bp-2064, 0x804ab6c
    if (VERBOSE == 0) {
        // 0x804abdd
        sprintf((char *)&str2, "wget -N -q %s", url);
    } else {
        // 0x804abba
        sprintf((char *)&str2, "wget -N %s", url);
    }
    int32_t system_rc = system((char *)&str2); // 0x804ac07
    v1[0] = system_rc;
    str = v1;
    uint32_t v3 = *(int32_t *)&str; // 0x804ac12
    if (v3 == -1) {
        // 0x804ac1b
        print_error(-20, "could not run 'wget' to download extension. Is it installed?\n");
        // UNREACHABLE
    }
    if (v3 >= 1) {
        // 0x804ac38
        print_error(-20, "running command '%s'.\n", &str2);
        // UNREACHABLE
    }
    // 0x804ac56
    print_done();
    if (v2 != __readgsdword(20)) {
        // 0x804ac67
        __stack_chk_fail();
    }
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/tools.c
// Address range: 0x804ac6e - 0x804ad9b
// Line range:    796 - 823
void su(char * gisbase, char * cmd) {
    char tmpfile2[2048]; // bp-2068, 0x804ac6e
    char tmpfile[2048]; // bp-2072, 0x804ac6e
    char v1[2048]; // 0x804ad5b
    char v2[2048]; // 0x804ad09
    int32_t v3 = __readgsdword(20); // 0x804ac89
    uint32_t seed = (0x41c64e6d * (int32_t)g15 + 0xd431) / 0x10000 % 0x8000; // 0x804acb1
    g15 = (struct _IO_FILE *)seed;
    srand(seed);
    int32_t str; // bp-2064, 0x804ac6e
    sprintf((char *)&str, "%s/gem.test.%i", gisbase, rand());
    struct _IO_FILE * file = fopen((char *)&str, "w+"); // 0x804ad04
    v2[0] = (int32_t)file;
    tmpfile = v2;
    if (*__errno_location() == 13) {
        // 0x804ad1b
        print_error(-5, "You don't have write access to your local GRASS installation.\nPlease consult your system administrator.\n");
        // UNREACHABLE
    }
    // 0x804ad31
    remove((char *)&str);
    fclose((struct _IO_FILE *)*(int32_t *)&tmpfile);
    int32_t system_rc = system(cmd); // 0x804ad56
    v1[0] = system_rc;
    tmpfile2 = v1;
    if (*(int32_t *)&tmpfile2 != 0) {
        // 0x804ad6a
        print_error(-9, "could not run '%s'.\n", cmd);
        // UNREACHABLE
    }
    // 0x804ad88
    if (v3 != __readgsdword(20)) {
        // 0x804ad94
        __stack_chk_fail();
    }
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/tools.c
// Address range: 0x804ad9b - 0x804ae1e
// Line range:    832 - 858
int32_t vercmp(int32_t major, int32_t minor, uint32_t revision, int32_t major2, int32_t minor2, uint32_t revision2) {
    // 0x804ad9b
    if (major == major2 == minor == minor2 == revision == revision2) {
        // 0x804ae1c
        return 0;
    }
    // 0x804adbd
    if (major2 > major) {
        // 0x804ae1c
        return -1;
    }
    // 0x804adcc
    if (major2 < major) {
        // 0x804ae1c
        return 1;
    }
    // 0x804addb
    if (minor2 > minor) {
        // 0x804ae1c
        return -1;
    }
    // 0x804adea
    if (minor2 < minor) {
        // 0x804ae1c
        return 1;
    }
    int32_t result = -1; // 0x804adff
    if (revision2 <= revision) {
        // 0x804ae08
        result = revision2 < revision;
    }
    // 0x804ae1c
    return result;
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/reg_deps.c
// Address range: 0x804ae20 - 0x804b014
// Line range:    32 - 79
char * depstr(char * package, char * gisbase) {
    char short_name[2048]; // bp-6164, 0x804ae20
    char short_name2[2048]; // bp-6168, 0x804ae20
    char v1[2048]; // 0x804aee8
    int32_t v2 = __readgsdword(20); // 0x804ae3b
    int32_t file_path; // bp-2064, 0x804ae20
    memcpy(&file_path, (int32_t *)"../depends", 11);
    struct _IO_FILE * file = fopen((char *)&file_path, "r"); // 0x804ae77
    int32_t v3; // 0x804ae20
    if (file != NULL) {
        // 0x804aed2
        short_name2 = {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
        int32_t * mem = malloc(2048); // 0x804aee3
        v1[0] = (int32_t)mem;
        short_name = v1;
        int32_t v4; // 0x804ae20
        int32_t str; // bp-4112, 0x804ae20
        if (nc_fgets_nb((char *)&str, 2048, file) != NULL) {
            int32_t v5 = *(int32_t *)&short_name;
            char * str3 = (char *)v5;
            int32_t str2; // bp-6160, 0x804ae20
            if ((char)str != 0) {
                // 0x804af04
                if (sscanf((char *)&str, "%s", &str2) >= 1) {
                    // 0x804af38
                    if (strcmp("GRASS", (char *)&str2) != 0) {
                        // 0x804af52
                        if (*(int32_t *)&short_name2 == 0) {
                            // 0x804af96
                            strcat(str3, ",");
                            strcat(str3, (char *)&str2);
                        } else {
                            // 0x804af5b
                            strcat(str3, "\t");
                            strcat(str3, (char *)&str2);
                            short_name2 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
                        }
                    }
                }
            }
            char * v6 = nc_fgets_nb((char *)&str, 2048, file); // 0x804afe0
            v4 = v5;
            while (v6 != NULL) {
                // 0x804aef3
                if ((char)str != 0) {
                    // 0x804af04
                    if (sscanf((char *)&str, "%s", &str2) >= 1) {
                        // 0x804af38
                        if (strcmp("GRASS", (char *)&str2) != 0) {
                            // 0x804af52
                            if (*(int32_t *)&short_name2 == 0) {
                                // 0x804af96
                                strcat(str3, ",");
                                strcat(str3, (char *)&str2);
                            } else {
                                // 0x804af5b
                                strcat(str3, "\t");
                                strcat(str3, (char *)&str2);
                                short_name2 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
                            }
                        }
                    }
                }
                // 0x804afc5
                v6 = nc_fgets_nb((char *)&str, 2048, file);
                v4 = v5;
            }
        } else {
            // 0x804aed2
            v4 = *(int32_t *)&short_name;
        }
        // 0x804afed
        fclose(file);
        v3 = v4;
    } else {
        int32_t v7 = *__errno_location(); // 0x804ae90
        v3 = (int32_t)&g4;
        if (v7 != 2) {
            char * err_str = strerror(*__errno_location()); // 0x804aeab
            print_error(-17, "checking for file '%s': %s\n", &file_path, err_str);
            // UNREACHABLE
        }
    }
    int32_t v8 = v3; // 0x804b00b
    if (v2 != __readgsdword(20)) {
        // 0x804b00d
        __stack_chk_fail();
        v8 = &g18;
    }
    // 0x804b012
    return (char *)v8;
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/reg_deps.c
// Address range: 0x804b014 - 0x804b5e3
// Line range:    87 - 229
void register_extension(char * gisbase, char * bins, char * pkg_short_name, int32_t pkg_major, int32_t pkg_minor, int32_t pkg_revision) {
    char deps2[2048]; // bp-10260, 0x804b014
    char deps[2048]; // bp-10264, 0x804b014
    char v1[2048]; // 0x804b1a5
    char v2[2048]; // 0x804b26a
    int32_t v3 = __readgsdword(20); // 0x804b039
    int32_t str; // bp-2064, 0x804b014
    sprintf((char *)&str, "%s/etc/extensions.db", gisbase);
    struct _IO_FILE * file = fopen((char *)&str, "r"); // 0x804b081
    int32_t v4; // 0x804b014
    int32_t v5; // 0x804b014
    int32_t v6; // 0x804b014
    int32_t v7; // 0x804b014
    int32_t v8; // 0x804b014
    int32_t v9; // 0x804b014
    int32_t v10; // 0x804b014
    int32_t str4; // bp-10256, 0x804b014
    int32_t str2; // bp-4112, 0x804b014
    int32_t str3; // bp-6160, 0x804b014
    int32_t v11; // bp-8208, 0x804b014
    struct _IO_FILE * file2; // 0x804b133
    if (file != NULL) {
        // 0x804b0f9
        memcpy((int32_t *)&TMPDB, (int32_t *)"/tmp/grass.extensions.db.XXXXXX", 32);
        mkstemp(TMPDB);
        file2 = fopen(TMPDB, "w+");
        if (file2 == NULL) {
            char * err_str = strerror(*__errno_location()); // 0x804b151
            print_error(-15, "could not create temp file '%s': %s\n \t\t\t\t\t\t\tMake sure that directory /tmp exists on your system and you have write permission.\n", TMPDB, err_str);
            // UNREACHABLE
        }
        // 0x804b176
        atexit(0x8048fc2);
        deps2 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
        char * v12 = nc_fgets_nb((char *)&str2, 2048, file); // 0x804b37c
        v10 = 0;
        if (v12 != NULL) {
            // 0x804b1a5
            v8 = 0;
            v5 = 1;
            int32_t f_in; // bp-10292, 0x804b014
            int32_t f_out; // bp-10296, 0x804b014
            int32_t major; // bp-10300, 0x804b014
            int32_t v13; // 0x804b014
            while (true) {
              lab_0x804b1a5:
                // 0x804b1a5
                v1[0] = (char)*(int32_t *)&deps2 + 1;
                deps2 = v1;
                sscanf((char *)&str2, "%s\t%i.%i.%i\t%s\t%s", &str3, &f_in, &f_out, &major, &v11, &str4);
                int32_t strcmp_rc = strcmp((char *)&str3, pkg_short_name); // 0x804b21c
                v7 = v8;
                v4 = v5;
                if (strcmp_rc != 0) {
                    goto lab_0x804b33b;
                } else {
                    int32_t v14 = vercmp(f_in, f_out, major, pkg_major, pkg_minor, pkg_revision); // 0x804b265
                    v2[0] = v14;
                    deps = v2;
                    v13 = *(int32_t *)&deps;
                    if (FORCE == 0) {
                        // break -> 0x804b27d
                        break;
                    }
                    // 0x804b332
                    v6 = 1;
                    v9 = 1;
                    v7 = 1;
                    v4 = 0;
                    if (v13 != 0) {
                        goto lab_0x804b361;
                    } else {
                        goto lab_0x804b33b;
                    }
                }
            }
            // 0x804b27d
            if (v13 >= 0) {
                // 0x804b2c4
                print_error(-16, "Extension '%s' with same or higher version (%i.%i.%i) already installed. You can use -f to overwrite this version, if you know what you are doing.\n", pkg_short_name, f_in, f_out, major);
                // UNREACHABLE
            }
            // 0x804b286
            print_error(-16, "Extension '%s' with lower version (%i.%i.%i) already installed. You can use -f to overwrite this version, if you know what you are doing.\n", pkg_short_name, f_in, f_out, major);
            // UNREACHABLE
        }
        goto lab_0x804b396;
    } else {
        // 0x804b095
        if (*__errno_location() != 2) {
            // 0x804b0ad
            fclose(file);
            char * err_str2 = strerror(*__errno_location()); // 0x804b0c5
            print_error(-15, "checking for file '%s': %s\n", &str, err_str2);
            // UNREACHABLE
        }
        goto lab_0x804b4bb;
    }
  lab_0x804b33b:
    // 0x804b33b
    fprintf(file2, (char *)&str2);
    fflush(file2);
    v6 = v4;
    v9 = v7;
    goto lab_0x804b361;
  lab_0x804b361:;
    int32_t v15 = v9;
    int32_t v16 = v6;
    char * v17 = nc_fgets_nb((char *)&str2, 2048, file); // 0x804b37c
    v8 = v15;
    v5 = v16;
    if (v17 == NULL) {
        // 0x804b389
        v10 = v15;
        if (v16 == 0) {
            goto lab_0x804b4a5;
        } else {
            goto lab_0x804b396;
        }
    }
    goto lab_0x804b1a5;
  lab_0x804b396:
    // 0x804b396
    strcpy((char *)&str4, depstr(pkg_short_name, gisbase));
    if (v10 != 0) {
        // 0x804b415
        fprintf(file2, "%s\t%i.%i.%i\t%s\t%s\n", &str3, pkg_major, pkg_minor, pkg_revision, &v11, &str4);
    } else {
        // 0x804b39f
        fprintf(file2, "%s\t%i.%i.%i\t%s\t%s\n", pkg_short_name, pkg_major, pkg_minor, pkg_revision, bins, &str4);
    }
    goto lab_0x804b4a5;
  lab_0x804b4bb:
    // 0x804b4bb
    memcpy((int32_t *)&TMPDB, (int32_t *)"/tmp/grass.extensions.db.XXXXXX", 32);
    mkstemp(TMPDB);
    struct _IO_FILE * file3 = fopen(TMPDB, "w+"); // 0x804b4f5
    if (file3 == NULL) {
        char * err_str3 = strerror(*__errno_location()); // 0x804b513
        print_error(-15, "could not create temp db '%s': %s\n \t\t\t\t\tMake sure that directory /tmp exists on your system and you have write permission.\n", &str, err_str3);
        // UNREACHABLE
    }
    // 0x804b53a
    atexit(0x8048fc2);
    strcpy((char *)&str4, depstr(pkg_short_name, gisbase));
    fprintf(file3, "%s\t%i.%i.%i\t%s\t%s\n", pkg_short_name, pkg_major, pkg_minor, pkg_revision, bins, &str4);
    fclose(file3);
    goto lab_0x804b5c9;
  lab_0x804b4a5:
    // 0x804b4a5
    fclose(file2);
    fclose(file);
    if (*(int32_t *)&deps2 == 0) {
        goto lab_0x804b4bb;
    } else {
        goto lab_0x804b5c9;
    }
  lab_0x804b5c9:
    // 0x804b5c9
    if (v3 != __readgsdword(20)) {
        // 0x804b5d5
        __stack_chk_fail();
    }
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/reg_deps.c
// Address range: 0x804b5e3 - 0x804b961
// Line range:    235 - 332
void deregister_extension(char * package, char * pkg_short_name, char * gisbase) {
    char deps[2048]; // bp-10260, 0x804b5e3
    char deps2[2048]; // bp-10264, 0x804b5e3
    char v1[2048]; // 0x804b81e
    int32_t v2 = __readgsdword(20); // 0x804b607
    deps2 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    int32_t str; // bp-2064, 0x804b5e3
    sprintf((char *)&str, "%s/etc/extensions.db", gisbase);
    struct _IO_FILE * file = fopen((char *)&str, "r"); // 0x804b64f
    if (file != NULL) {
        // 0x804b6eb
        deps2 = {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    } else {
        // 0x804b667
        if (*__errno_location() == 2 == FORCE == 0) {
            // 0x804b67c
            fclose(file);
            print_error(-19, "could not deregister: no extensions installed\n");
            // UNREACHABLE
        }
        if (FORCE == 0) {
            // 0x804b6aa
            fclose(file);
            char * err_str = strerror(*__errno_location()); // 0x804b6c2
            print_error(-19, "checking for file '%s': %s\n", &str, err_str);
            // UNREACHABLE
        }
    }
    // 0x804b6f8
    if (*(int32_t *)&deps2 != 0) {
        // 0x804b705
        deps2 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
        memcpy((int32_t *)&TMPDB, (int32_t *)"/tmp/grass.extensions.db.XXXXXX", 32);
        mkstemp(TMPDB);
        struct _IO_FILE * file2 = fopen(TMPDB, "w+"); // 0x804b749
        if (file2 == NULL) {
            // 0x804b75d
            if (FORCE == 0) {
                char * err_str2 = strerror(*__errno_location()); // 0x804b770
                print_error(-19, "could not create temp db '%s': %s\n \t\t\t\t\t\t\tMake sure that directory /tmp exists on your system and you have write permission.\n", &str, err_str2);
                // UNREACHABLE
            }
        }
        // 0x804b7af
        deps2 = {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
        atexit(0x8048fc2);
        if (*(int32_t *)&deps2 != 0) {
            int32_t v3 = 0;
            int32_t v4; // 0x804b5e3
            while (true) {
                // 0x804b8d9
                v4 = v3;
                int32_t str2; // bp-4112, 0x804b5e3
                if (nc_fgets_nb((char *)&str2, 2048, file) == NULL) {
                    // break (via goto) -> 0x804b901
                    goto lab_0x804b901;
                }
                // 0x804b7cb
                int32_t f_out; // bp-10284, 0x804b5e3
                int32_t found_ext; // bp-10288, 0x804b5e3
                int32_t major; // bp-10292, 0x804b5e3
                int32_t str4; // bp-10256, 0x804b5e3
                int32_t str3; // bp-6160, 0x804b5e3
                int32_t v5; // bp-8208, 0x804b5e3
                int32_t items_assigned = sscanf((char *)&str2, "%s\t%i.%i.%i\t%s\t%s", &str3, &f_out, &found_ext, &major, &v5, &str4); // 0x804b819
                v1[0] = items_assigned;
                deps = v1;
                while (*(int32_t *)&deps < 1) {
                    // 0x804b8d9
                    if (nc_fgets_nb((char *)&str2, 2048, file) == NULL) {
                        // break (via goto) -> 0x804b901
                        goto lab_0x804b901;
                    }
                    // 0x804b7cb
                    items_assigned = sscanf((char *)&str2, "%s\t%i.%i.%i\t%s\t%s", &str3, &f_out, &found_ext, &major, &v5, &str4);
                    v1[0] = items_assigned;
                    deps = v1;
                }
                int32_t strcmp_rc = strcmp(pkg_short_name, (char *)&str3); // 0x804b84e
                if (strcmp_rc != 0) {
                    // 0x804b874
                    if (strstr((char *)&str4, pkg_short_name) != NULL) {
                        // 0x804b890
                        if (FORCE == 0) {
                            // 0x804b899
                            print_error(-19, "cannot uninstall extension '%s' it is needed by '%s'.\n", pkg_short_name, &str3);
                            // UNREACHABLE
                        }
                    }
                    // 0x804b8c1
                    fprintf(file2, (char *)&str2);
                }
                // 0x804b8d9
                v3 = strcmp_rc != 0 ? v4 : 1;
            }
          lab_0x804b901:
            if (v4 == 0) {
                // 0x804b90a
                print_error(-19, "no extension '%s' registered/installed in '%s'.\n", pkg_short_name, gisbase);
                // UNREACHABLE
            }
            // 0x804b932
            fclose(file);
            fclose(file2);
        }
    }
    // 0x804b94e
    if (v2 != __readgsdword(20)) {
        // 0x804b95a
        __stack_chk_fail();
    }
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/reg_deps.c
// Address range: 0x804b961 - 0x804be83
// Line range:    340 - 462
void check_dependencies(char * package, char * gisbase, char * grass_version) {
    char dep_short_name2[2048]; // bp-10276, 0x804b961
    char dep_short_name[2048]; // bp-10280, 0x804b961
    char v1[2048]; // 0x804bb67
    char v2[2048]; // 0x804bce3
    int32_t v3 = __readgsdword(20); // 0x804b988
    if (FORCE == 0) {
        struct _IO_FILE * file = fopen("../depends", "r"); // 0x804b9b1
        int32_t str; // bp-2080, 0x804b961
        if (file != NULL) {
            // 0x804ba35
            dep_short_name = {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
            sprintf((char *)&str, "%s/etc/extensions.db", gisbase);
            struct _IO_FILE * file2 = fopen((char *)&str, "r"); // 0x804ba72
            if (file2 == NULL) {
                // 0x804ba86
                if (*__errno_location() != 2) {
                    // 0x804ba9e
                    fclose(file2);
                    char * err_str = strerror(*__errno_location()); // 0x804bab6
                    print_error(-17, "checking for file '%s': %s\n", &str, err_str);
                    // UNREACHABLE
                }
                // 0x804ba92
                dep_short_name = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
            }
            // 0x804badd
            int32_t v4; // 0x804b961
            int32_t str2; // bp-4128, 0x804b961
            if (nc_fgets_nb((char *)&str2, 2048, file) != NULL) {
                int32_t v5 = *(int32_t *)&dep_short_name;
                int32_t f_deps = 0; // bp-10296, 0x804baec
                int32_t f_db = 0; // bp-10300, 0x804baf6
                int32_t major = 0; // bp-10304, 0x804bb00
                int32_t minor = 0; // bp-10308, 0x804bb0a
                int32_t revision = 0; // bp-10312, 0x804bb14
                int32_t dep_major = 0; // bp-10316, 0x804bb1e
                int32_t str3; // bp-10272, 0x804b961
                int32_t items_assigned = sscanf((char *)&str2, "%s\t%i.%i.%i", &str3, &minor, &revision, &dep_major); // 0x804bb62
                v1[0] = items_assigned;
                dep_short_name2 = v1;
                int32_t v6; // 0x804b961
                int32_t str4; // bp-6176, 0x804b961
                int32_t str5; // bp-8224, 0x804b961
                int32_t items_assigned2; // 0x804bcde
                if (*(int32_t *)&dep_short_name2 >= 1) {
                    // 0x804bb7a
                    if (strcmp((char *)&str3, "GRASS") != 0) {
                        if (v5 != 0) {
                            // 0x804bc69
                            rewind(file2);
                            v6 = 0;
                            while (nc_fgets_nb((char *)&str4, 2048, file2) != NULL) {
                                // 0x804bdbe
                                while (true) {
                                    // 0x804bc86
                                    f_deps = 0;
                                    f_db = 0;
                                    major = 0;
                                    items_assigned2 = sscanf((char *)&str4, "%s\t%i.%i.%i", &str5, &f_deps, &f_db, &major);
                                    v2[0] = items_assigned2;
                                    dep_short_name2 = v2;
                                    if (*(int32_t *)&dep_short_name2 >= 1) {
                                        // 0x804bcf6
                                        if (strcmp((char *)&str5, (char *)&str3) == 0) {
                                            // break -> 0x804bd16
                                            break;
                                        }
                                    }
                                    // 0x804bdbe
                                    if (nc_fgets_nb((char *)&str4, 2048, file2) == NULL) {
                                        // break (via goto) -> 0x804bde6
                                        goto lab_0x804bde6;
                                    }
                                }
                                // 0x804bd16
                                if (vercmp(f_deps, f_db, major, minor, revision, dep_major) < 0) {
                                    // 0x804bd5a
                                    print_error(-18, "installed version %i.%i.%i of required extension '%s' is too low.\n \t\t\t\t\t\t\t\t\t\t\t\t\tRequired version is %i.%i.%i\n", f_deps, f_db, major, &str3, minor, revision, dep_major);
                                    // UNREACHABLE
                                }
                                v6 = 1;
                            }
                            if (v6 == 0) {
                                // 0x804bdef
                                print_error(-18, "required extension '%s' not found in '%s'.\n", &str3, gisbase);
                                // UNREACHABLE
                            }
                        }
                    } else {
                        // 0x804bb98
                        sscanf(grass_version, "%i.%i.%i", &f_deps, &f_db, &major);
                        if (vercmp(f_deps, f_db, major, minor, revision, dep_major) < 0) {
                            // 0x804bc11
                            print_error(-18, "installed version (%s) of GRASS is too low. Required version is %i.%i.%i\n", grass_version, minor, revision, dep_major);
                            // UNREACHABLE
                        }
                    }
                }
                char * v7 = nc_fgets_nb((char *)&str2, 2048, file); // 0x804be32
                v4 = v5;
                while (v7 != NULL) {
                    // 0x804baec
                    f_deps = 0;
                    f_db = 0;
                    major = 0;
                    minor = 0;
                    revision = 0;
                    dep_major = 0;
                    items_assigned = sscanf((char *)&str2, "%s\t%i.%i.%i", &str3, &minor, &revision, &dep_major);
                    v1[0] = items_assigned;
                    dep_short_name2 = v1;
                    if (*(int32_t *)&dep_short_name2 >= 1) {
                        // 0x804bb7a
                        if (strcmp((char *)&str3, "GRASS") != 0) {
                            if (v5 != 0) {
                                // 0x804bc69
                                rewind(file2);
                                v6 = 0;
                                while (nc_fgets_nb((char *)&str4, 2048, file2) != NULL) {
                                    // 0x804bdbe
                                    while (true) {
                                        // 0x804bc86
                                        f_deps = 0;
                                        f_db = 0;
                                        major = 0;
                                        items_assigned2 = sscanf((char *)&str4, "%s\t%i.%i.%i", &str5, &f_deps, &f_db, &major);
                                        v2[0] = items_assigned2;
                                        dep_short_name2 = v2;
                                        if (*(int32_t *)&dep_short_name2 >= 1) {
                                            // 0x804bcf6
                                            if (strcmp((char *)&str5, (char *)&str3) == 0) {
                                                // break -> 0x804bd16
                                                break;
                                            }
                                        }
                                        // 0x804bdbe
                                        if (nc_fgets_nb((char *)&str4, 2048, file2) == NULL) {
                                            // break (via goto) -> 0x804bde6
                                            goto lab_0x804bde6;
                                        }
                                    }
                                    // 0x804bd16
                                    if (vercmp(f_deps, f_db, major, minor, revision, dep_major) < 0) {
                                        // 0x804bd5a
                                        print_error(-18, "installed version %i.%i.%i of required extension '%s' is too low.\n \t\t\t\t\t\t\t\t\t\t\t\t\tRequired version is %i.%i.%i\n", f_deps, f_db, major, &str3, minor, revision, dep_major);
                                        // UNREACHABLE
                                    }
                                    v6 = 1;
                                }
                                if (v6 == 0) {
                                    // 0x804bdef
                                    print_error(-18, "required extension '%s' not found in '%s'.\n", &str3, gisbase);
                                    // UNREACHABLE
                                }
                            }
                        } else {
                            // 0x804bb98
                            sscanf(grass_version, "%i.%i.%i", &f_deps, &f_db, &major);
                            if (vercmp(f_deps, f_db, major, minor, revision, dep_major) < 0) {
                                // 0x804bc11
                                print_error(-18, "installed version (%s) of GRASS is too low. Required version is %i.%i.%i\n", grass_version, minor, revision, dep_major);
                                // UNREACHABLE
                            }
                        }
                    }
                    // 0x804be17
                    v7 = nc_fgets_nb((char *)&str2, 2048, file);
                    v4 = v5;
                }
            } else {
                // 0x804badd
                v4 = *(int32_t *)&dep_short_name;
            }
            // 0x804be3f
            if (v4 != 0) {
                // 0x804be48
                fclose(file2);
            }
            // 0x804be56
            fclose(file);
        } else {
            // 0x804b9c5
            if (*__errno_location() != 2) {
                // 0x804b9f6
                fclose(file);
                char * err_str2 = strerror(*__errno_location()); // 0x804ba0e
                print_error(-17, "checking for file '%s': %s\n", &str, err_str2);
                // UNREACHABLE
            }
            // 0x804b9d1
            fprintf(g11, "\n%s/depends ENOENT\n", package);
        }
    }
    // 0x804be67
    if (v3 != __readgsdword(20)) {
        // 0x804be73
        __stack_chk_fail();
    }
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/reg_entries.c
// Address range: 0x804be84 - 0x804bf05
// Line range:    36 - 48
int32_t is_submenu(char * item) {
    // 0x804be84
    if (strchr(item, 91) == NULL) {
        // 0x804beff
        return 0;
    }
    int32_t result = 0; // 0x804bebe
    if (strrchr(item, 93) != NULL) {
        // 0x804bec7
        result = strchr(item, 91) <= strrchr(item, 93);
    }
    // 0x804beff
    return result;
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/reg_entries.c
// Address range: 0x804bf05 - 0x804c009
// Line range:    57 - 81
int32_t check_ext_menu(char ** tcl_lines) {
    int32_t result = find_pos("\"&Xtns\" all options 1", tcl_lines, 0); // 0x804bf21
    if (result != -1) {
        // 0x804c007
        return result;
    }
    int32_t v1 = find_pos("\"&Help\" all options", tcl_lines, 0); // 0x804bf49
    if (v1 != -1) {
        // 0x804bfcc
        insert_str(" \"&Xtns\" all options 1 {\n", v1, tcl_lines);
        int32_t result2 = v1 + 1; // 0x804bfe6
        insert_str(" }\n", result2, tcl_lines);
        // 0x804c007
        return result2;
    }
    int32_t v2 = find_pos("}]", tcl_lines, 0); // 0x804bf6d
    if (v2 == -1) {
        // 0x804bf7b
        print_error(-21, "could not parse 'menu.tcl'.\n");
        // UNREACHABLE
    }
    // 0x804bf8f
    insert_str(" \"&Xtns\" all options 1 {\n", v2, tcl_lines);
    int32_t result3 = v2 + 1; // 0x804bfa9
    insert_str(" }\n", result3, tcl_lines);
    // 0x804c007
    return result3;
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/reg_entries.c
// Address range: 0x804c009 - 0x804c41b
// Line range:    90 - 165
int32_t new_submenu(char * pkg_short_name, char * menu, char ** tcl_lines) {
    char searchstr[2048]; // bp-6164, 0x804c009
    char searchstr2[2048]; // bp-6168, 0x804c009
    char v1[2048]; // 0x804c1a1
    char v2[2048]; // 0x804c20d
    char v3[2048]; // 0x804c057
    char v4[2048]; // 0x804c2d6
    char v5[2048]; // 0x804c2fd
    int32_t v6 = __readgsdword(20); // 0x804c02e
    int32_t v7 = find_pos("\"&Xtns\" all options", tcl_lines, 0); // 0x804c052
    v3[0] = v7;
    searchstr = v3;
    int32_t v8 = find_pos("\" all options", tcl_lines, *(int32_t *)&searchstr + 1); // 0x804c07b
    int32_t v9 = v8 - 1; // 0x804c090
    if (v8 == 0) {
        // 0x804c092
        v9 = find_pos("}]", tcl_lines, 0);
    }
    // 0x804c0b6
    int32_t v10; // 0x804c009
    if (is_submenu(menu) != 0) {
        // 0x804c0de
        int32_t v11; // bp-4, 0x804c009
        int32_t v12 = &v11; // 0x804c00a
        int32_t n = (int32_t)strrchr(menu, 93) - (int32_t)strchr(menu, 91); // 0x804c10e
        char * found_char_pos = strchr(menu, 91); // 0x804c12f
        int32_t str; // bp-2064, 0x804c009
        strncpy((char *)&str, (char *)((int32_t)found_char_pos + 1), n);
        *(char *)(v12 - 2061 + n) = 0;
        int32_t str2; // bp-6160, 0x804c009
        sprintf((char *)&str2, "{cascad \"%s\"", &str);
        int32_t v13 = *(int32_t *)&searchstr; // 0x804c17f
        int32_t v14 = find_pos((char *)&str2, tcl_lines, v13); // 0x804c19c
        v1[0] = v14;
        searchstr2 = v1;
        int32_t v15 = *(int32_t *)&searchstr2; // 0x804c1a7
        if (v15 != -1 == v15 < v9) {
            // 0x804c1be
            print_warning("submenu '%s' exists in GIS Manager's Xtns menu.\n", &str);
            v10 = -1;
        } else {
            int32_t v16 = v13 + 1; // 0x804c1e4
            int32_t v17 = find_pos("{cascad ", tcl_lines, v13); // 0x804c208
            v2[0] = v17;
            searchstr2 = v2;
            int32_t v18 = *(int32_t *)&searchstr2; // 0x804c303
            int32_t v19 = v16; // 0x804c30a
            if (v18 != -1 == v18 < v9) {
                int32_t str3 = *(int32_t *)(4 * v18 + (int32_t)tcl_lines); // 0x804c227
                int32_t found_char_pos2 = (int32_t)strchr((char *)str3, 34); // 0x804c234
                char * str4 = (char *)(found_char_pos2 + 1); // 0x804c250
                int32_t n2 = (int32_t)strchr(str4, 34) - found_char_pos2; // 0x804c26c
                int32_t str5; // bp-4112, 0x804c009
                strncpy((char *)&str5, str4, n2);
                *(char *)(v12 - 0x100d + n2) = 0;
                while (strcmp((char *)&str, (char *)&str5) >= 0) {
                    // 0x804c2d6
                    v4[0] = (char)*(int32_t *)&searchstr + 1;
                    searchstr = v4;
                    int32_t v20 = find_pos("{cascad ", tcl_lines, *(int32_t *)&searchstr); // 0x804c2f8
                    v5[0] = v20;
                    searchstr2 = v5;
                    int32_t v21 = *(int32_t *)&searchstr2; // 0x804c303
                    v19 = v16;
                    if (v21 != -1 != v21 < v9) {
                        goto lab_0x804c31e;
                    }
                    str3 = *(int32_t *)(4 * v21 + (int32_t)tcl_lines);
                    found_char_pos2 = (int32_t)strchr((char *)str3, 34);
                    str4 = (char *)(found_char_pos2 + 1);
                    n2 = (int32_t)strchr(str4, 34) - found_char_pos2;
                    strncpy((char *)&str5, str4, n2);
                    *(char *)(v12 - 0x100d + n2) = 0;
                }
                // 0x804c2c8
                v19 = *(int32_t *)&searchstr2;
            }
          lab_0x804c31e:
            // 0x804c31e
            sprintf((char *)&str, " \t\t\t%s {} \"\" 1 {\n", &str2);
            insert_str((char *)&str, v19, tcl_lines);
            int32_t v22 = v19 + 1; // 0x804c367
            insert_str(" \t\t\t}}\n", v22, tcl_lines);
            int32_t v23 = find_pos("}]", tcl_lines, 0); // 0x804c39d
            sprintf((char *)&str, "#(DO_NOT_REMOVE_THIS_COMMENT) <%s> %s {} \"\" 1 {\n", pkg_short_name, &str2);
            insert_str((char *)&str, v23 + 1, tcl_lines);
            v10 = v22;
        }
    } else {
        // 0x804c0c8
        print_warning("first line not a submenu specifier in 'entries-gisman'.\n");
        v10 = -1;
    }
    int32_t result = v10; // 0x804c40b
    if (v6 != __readgsdword(20)) {
        // 0x804c40d
        __stack_chk_fail();
        result = &g18;
    }
    // 0x804c412
    return result;
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/reg_entries.c
// Address range: 0x804c41b - 0x804c5f0
// Line range:    173 - 221
int32_t new_item(char * item, char * menu, char ** tcl_lines, int32_t line_no) {
    char tmp[2048]; // bp-6164, 0x804c41b
    char tmp2[2048]; // bp-6168, 0x804c41b
    char v1[2048]; // 0x804c4f4
    char v2[2048]; // 0x804c4cd
    char v3[2048]; // 0x804c46f
    char v4[2048]; // 0x804c4cd
    char v5[2048]; // 0x804c4f4
    int32_t v6 = __readgsdword(20); // 0x804c43f
    chop(item);
    char * next_token = strtok(item, ";"); // 0x804c46a
    v3[0] = (int32_t)next_token;
    tmp = v3;
    int32_t str2 = *(int32_t *)&tmp; // 0x804c475
    int32_t v7; // 0x804c41b
    int32_t str6; // bp-6160, 0x804c41b
    if (str2 != 0) {
        // 0x804c4b8
        int32_t str; // bp-2064, 0x804c41b
        strcpy((char *)&str, (char *)str2);
        tmp2 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
        char * next_token2 = strtok(NULL, ";"); // 0x804c4c8
        v4[0] = (int32_t)next_token2;
        tmp = v4;
        int32_t str4 = *(int32_t *)&tmp; // 0x804c4d3
        int32_t str3; // bp-4112, 0x804c41b
        if (str4 != 0) {
            strcpy((char *)&str3, (char *)str4);
            v1[0] = (char)*(int32_t *)&tmp2 + 1;
            tmp2 = v1;
            char * next_token3 = strtok(NULL, ";"); // 0x804c4c8
            v2[0] = (int32_t)next_token3;
            tmp = v2;
            int32_t v8 = *(int32_t *)&tmp; // 0x804c4d3
            int32_t str5 = v8; // 0x804c4da
            while (v8 != 0) {
                // 0x804c4f4
                strcpy((char *)&str3, (char *)str5);
                v1[0] = (char)*(int32_t *)&tmp2 + 1;
                tmp2 = v1;
                next_token3 = strtok(NULL, ";");
                v2[0] = (int32_t)next_token3;
                tmp = v2;
                v8 = *(int32_t *)&tmp;
                str5 = v8;
            }
        }
        // 0x804c504
        v5[0] = (char)*(int32_t *)&tmp2 + 1;
        tmp2 = v5;
        int32_t v9 = *(int32_t *)&tmp2; // 0x804c504
        if (v9 < 3) {
            // 0x804c52d
            if (strcmp((char *)&str, "-") != 0) {
                // 0x804c582
                sprintf((char *)&str6, " \t\t\t {command \"%s\" {} \"%s\" {} -command {%s }}\n", &str, &str3, &str3);
                goto lab_0x804c5b7;
            } else {
                // 0x804c547
                if (strcmp((char *)&str, "-") != 0) {
                    // 0x804c582
                    sprintf((char *)&str6, " \t\t\t {command \"%s\" {} \"%s\" {} -command {%s }}\n", &str, &str3, &str3);
                    goto lab_0x804c5b7;
                } else {
                    // 0x804c561
                    memcpy(&str6, (int32_t *)" \t\t\t {separator}\n", 18);
                    goto lab_0x804c5b7;
                }
            }
        } else {
            // 0x804c50d
            print_warning("invalid number of tokens (%i) in 'entries-gisman'.\n", v9);
            v7 = -1;
            goto lab_0x804c5dd;
        }
    } else {
        // 0x804c47e
        print_warning("invalid token in 'entries-gisman'.\n");
        v7 = -1;
        goto lab_0x804c5dd;
    }
  lab_0x804c5dd:;
    int32_t result = v7; // 0x804c5e7
    if (v6 != __readgsdword(20)) {
        // 0x804c5e9
        __stack_chk_fail();
        result = &g18;
    }
    // 0x804c5ee
    return result;
  lab_0x804c5b7:
    // 0x804c5b7
    insert_str((char *)&str6, line_no, tcl_lines);
    v7 = line_no + 1;
    goto lab_0x804c5dd;
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/reg_entries.c
// Address range: 0x804c5f0 - 0x804cd6c
// Line range:    232 - 404
void register_entries_gisman(char * pkg_short_name, char * gisbase) {
    char menu2[2048]; // bp-6164, 0x804c5f0
    char menu[2048]; // bp-6168, 0x804c5f0
    char v1[2048]; // 0x804c9b1
    char v2[2048]; // 0x804cadc
    int32_t v3 = __readgsdword(20); // 0x804c60c
    int32_t file_path; // bp-2064, 0x804c5f0
    memcpy(&file_path, (int32_t *)"../entries-gisman", 18);
    struct _IO_FILE * file = fopen((char *)&file_path, "r"); // 0x804c648
    int32_t v4; // 0x804c5f0
    int32_t str6; // bp-4112, 0x804c5f0
    int32_t v5; // 0x804c93e
    int32_t nmemb; // 0x804c99e
    struct _IO_FILE * file2; // 0x804c6de
    struct _IO_FILE * file3; // 0x804c77b
    if (file != NULL) {
        // 0x804c6ab
        sprintf((char *)&file_path, "%s/etc/dm/menu.tcl", gisbase);
        file2 = fopen((char *)&file_path, "r");
        if (file2 != NULL) {
            // 0x804c741
            memcpy((int32_t *)&TMP_GISMAN, (int32_t *)"/tmp/grass.extensions.db.XXXXXX", 32);
            mkstemp(TMP_GISMAN);
            file3 = fopen(TMP_GISMAN, "w+");
            if (file3 == NULL) {
                char * err_str = strerror(*__errno_location()); // 0x804c799
                print_error(-21, "could not create temp file '%s': %s\n \t\t\tMake sure that directory /tmp exists on your system and you have write permission.\n", TMP_GISMAN, err_str);
                // UNREACHABLE
            }
            // 0x804c7be
            atexit(0x8048fc2);
            if (VERBOSE == 0) {
                // 0x804c83d
                sprintf((char *)&str6, "mkdir %s/etc/dm/gem-entries &> %s ; cp -f ../entries-gisman %s/etc/dm/gem-entries/%s &> %s ; \t\t\t\t\tcp -f %s/etc/dm/menu.tcl %s/etc/dm/menu.tcl.gem.bak &> %s ; \t\t\t\t\tcp -f %s %s/etc/dm/menu.tcl &> %s ; chmod a+r %s/etc/dm/menu.tcl &> %s ;", gisbase, TMP_NULL, gisbase, pkg_short_name, TMP_NULL, gisbase, gisbase, TMP_NULL, TMP_GISMAN, gisbase, TMP_NULL, gisbase, TMP_NULL);
            } else {
                // 0x804c7d3
                sprintf((char *)&str6, "mkdir --verbose %s/etc/dm/gem-entries ; cp -vf ../entries-gisman %s/etc/dm/gem-entries/%s ; \t\t\t\t\tcp -vf %s/etc/dm/menu.tcl %s/etc/dm/menu.tcl.gem.bak ; \t\t\t\t\tcp -vf %s %s/etc/dm/menu.tcl ; chmod -v a+r %s/etc/dm/menu.tcl ;", gisbase, gisbase, pkg_short_name, gisbase, gisbase, TMP_GISMAN, gisbase, gisbase);
            }
            // 0x804c8ca
            strcpy(GISMAN_CMD, (char *)&str6);
            int32_t v6 = 0;
            char * str = fgets((char *)&str6, 2048, file); // 0x804c90e
            int32_t v7 = v6 + 1; // 0x804c915
            while (str != NULL) {
                // 0x804c8f3
                v6 = v7;
                str = fgets((char *)&str6, 2048, file);
                v7 = v6 + 1;
            }
            if (v6 == 0) {
                goto lab_0x804cd52;
            } else {
                // 0x804c924
                rewind(file);
                if (fgets((char *)&str6, 2048, file2) != NULL) {
                    v5 = (int32_t)NULL + 1;
                    char * str2 = fgets((char *)&str6, 2048, file2); // 0x804c960
                    char ** v8 = (char **)v5; // 0x804c967
                    while (str2 != NULL) {
                        // 0x804c93e
                        v5 = (int32_t)v8 + 1;
                        str2 = fgets((char *)&str6, 2048, file2);
                        v8 = (char **)v5;
                    }
                    if (v5 == 0) {
                        goto lab_0x804cd52;
                    } else {
                        // 0x804c976
                        rewind(file2);
                        nmemb = 2 * v6 + 6 + v5;
                        int32_t * mem = calloc(nmemb, 4); // 0x804c9ac
                        v1[0] = (int32_t)mem;
                        menu = v1;
                        int32_t v9 = 0; // 0x804c9f6
                        if (nmemb > 0) {
                            *(int32_t *)(*(int32_t *)&menu + 4 * v9) = 0;
                            int32_t v10 = v9 + 1; // 0x804c9d8
                            v9 = v10;
                            while (v10 != nmemb) {
                                // 0x804c9c3
                                *(int32_t *)(*(int32_t *)&menu + 4 * v9) = 0;
                                v10 = v9 + 1;
                                v9 = v10;
                            }
                        }
                        char * str3 = fgets((char *)&str6, 2048, file2); // 0x804ca75
                        int32_t v11 = *(int32_t *)&menu;
                        int32_t v12 = 0; // 0x804ca7c
                        int32_t v13 = v11; // 0x804ca7c
                        if (str3 != NULL) {
                            int32_t v14 = 4 * v12; // 0x804ca0a
                            int32_t * mem2 = malloc(strlen((char *)&str6) + 1); // 0x804ca29
                            *(int32_t *)(v14 + v11) = (int32_t)mem2;
                            int32_t v15 = *(int32_t *)&menu; // 0x804ca3f
                            strcpy((char *)*(int32_t *)(v15 + v14), (char *)&str6);
                            char * str4 = fgets((char *)&str6, 2048, file2); // 0x804ca75
                            int32_t v16 = v15; // 0x804ca7c
                            v12++;
                            v13 = v15;
                            while (str4 != NULL) {
                                // 0x804ca04
                                v14 = 4 * v12;
                                mem2 = malloc(strlen((char *)&str6) + 1);
                                *(int32_t *)(v14 + v16) = (int32_t)mem2;
                                v15 = *(int32_t *)&menu;
                                strcpy((char *)*(int32_t *)(v15 + v14), (char *)&str6);
                                str4 = fgets((char *)&str6, 2048, file2);
                                v16 = v15;
                                v12++;
                                v13 = v15;
                            }
                        }
                        // 0x804ca7e
                        check_ext_menu((char **)v13);
                        char * v17 = nc_fgets_nb((char *)&str6, 2048, file); // 0x804cbde
                        v4 = v13;
                        if (v17 != NULL) {
                            int32_t v18 = v13; // 0x804c5f0
                            int32_t v19 = 1; // 0x804c5f0
                            int32_t v20; // 0x804cb7d
                            while (true) {
                                // 0x804ca9b
                                int32_t v21; // 0x804c5f0
                                int32_t v22; // 0x804c5f0
                                int32_t v23; // 0x804c5f0
                                int32_t str7; // bp-6160, 0x804c5f0
                                if (v19 != 1) {
                                    // 0x804cb73
                                    v20 = v18;
                                    int32_t v24 = new_item((char *)&str6, (char *)&str7, (char **)v20, v22); // 0x804cb9a
                                    v21 = v20;
                                    v23 = v24;
                                    if (v24 < 0) {
                                        // break -> 0x804cbae
                                        break;
                                    }
                                } else {
                                    char * found_char_pos = strrchr((char *)&str6, 93); // 0x804cab9
                                    char * found_char_pos2 = strchr((char *)&str6, 91); // 0x804cad1
                                    v2[0] = (int32_t)found_char_pos - (int32_t)found_char_pos2;
                                    menu2 = v2;
                                    int32_t n = *(int32_t *)&menu2;
                                    char * found_char_pos3 = strchr((char *)&str6, 91); // 0x804caf9
                                    strncpy((char *)&str7, (char *)((int32_t)found_char_pos3 + 1), n);
                                    int32_t v25; // bp-4, 0x804c5f0
                                    *(char *)((int32_t)&v25 - 0x180d + n) = 0;
                                    int32_t v26 = *(int32_t *)&menu; // 0x804cb28
                                    int32_t v27 = new_submenu(pkg_short_name, (char *)&str6, (char **)v26); // 0x804cb45
                                    v21 = v26;
                                    v23 = v27;
                                    if (v27 < 0) {
                                        // 0x804cb59
                                        print_warning("no GIS Manager menu entries created.\n");
                                        v4 = v26;
                                        goto lab_0x804cbeb;
                                    }
                                }
                                char * v28 = nc_fgets_nb((char *)&str6, 2048, file); // 0x804cbde
                                v18 = v21;
                                v22 = v23;
                                v19++;
                                v4 = v21;
                                if (v28 == NULL) {
                                    goto lab_0x804cbeb;
                                }
                            }
                            // 0x804cbae
                            print_warning("error creating GIS Manager menu entries.\n");
                            v4 = v20;
                        }
                        goto lab_0x804cbeb;
                    }
                } else {
                    goto lab_0x804cd52;
                }
            }
        } else {
            // 0x804c6f2
            if (*__errno_location() != 2) {
                // 0x804c702
                fclose(file2);
                char * err_str2 = strerror(*__errno_location()); // 0x804c71a
                print_error(-21, "checking for file '%s': %s\n", &file_path, err_str2);
                // UNREACHABLE
            }
            goto lab_0x804cd52;
        }
    } else {
        // 0x804c65c
        if (*__errno_location() != 2) {
            // 0x804c66c
            fclose(file);
            char * err_str3 = strerror(*__errno_location()); // 0x804c684
            print_error(-21, "checking for file '%s': %s\n", &file_path, err_str3);
            // UNREACHABLE
        }
        goto lab_0x804cd52;
    }
  lab_0x804cbeb:;
    int32_t * v29 = (int32_t *)v4;
    int32_t format = *v29; // 0x804cc30
    if (format != 0) {
        fprintf(file3, (char *)format);
        int32_t v30 = 1; // 0x804cc1a
        int32_t v31 = *(int32_t *)(4 * v30 + v4); // 0x804cc30
        int32_t format2 = v31; // 0x804cc34
        int32_t v32 = v30; // 0x804cc34
        while (v31 != 0) {
            // 0x804cbf7
            fprintf(file3, (char *)format2);
            v30 = v32 + 1;
            v31 = *(int32_t *)(4 * v30 + v4);
            format2 = v31;
            v32 = v30;
        }
    }
    // 0x804cc36
    fflush(file3);
    rewind(file3);
    int32_t v33 = 0;
    char * str5 = fgets((char *)&str6, 2048, file3); // 0x804cc80
    int32_t v34 = v33 + 1; // 0x804cc87
    while (str5 != NULL) {
        // 0x804cc65
        v33 = v34;
        str5 = fgets((char *)&str6, 2048, file3);
        v34 = v33 + 1;
    }
    if (v33 == 0 || v33 < v5) {
        // 0x804cca0
        print_warning("file truncation detected. Retaining orginal file 'menu.tcl'.\n");
        memcpy((int32_t *)&GISMAN_CMD, &g5, 1);
    }
    // 0x804ccc9
    fclose(file2);
    fclose(file);
    fclose(file3);
    int32_t v35 = 0; // 0x804cd36
    if (nmemb > 0) {
        free((int32_t *)*(int32_t *)(4 * v35 + v4));
        int32_t v36 = v35 + 1; // 0x804cd18
        v35 = v36;
        while (v36 != nmemb) {
            // 0x804ccff
            free((int32_t *)*(int32_t *)(4 * v35 + v4));
            v36 = v35 + 1;
            v35 = v36;
        }
    }
    // 0x804cd38
    free(v29);
    goto lab_0x804cd52;
  lab_0x804cd52:
    // 0x804cd52
    if (v3 != __readgsdword(20)) {
        // 0x804cd5e
        __stack_chk_fail();
    }
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/reg_entries.c
// Address range: 0x804cd6c - 0x804cec7
// Line range:    415 - 451
void register_entries_gisman2(char * pkg_short_name, char * gisbase) {
    char str[2048]; // bp-4116, 0x804cd6c
    char v1[2048]; // 0x804cdc8
    int32_t v2 = __readgsdword(20); // 0x804cd87
    int32_t file_path; // bp-2064, 0x804cd6c
    memcpy(&file_path, (int32_t *)"../entries-gisman2", 19);
    struct _IO_FILE * file = fopen((char *)&file_path, "r"); // 0x804cdc3
    v1[0] = (int32_t)file;
    str = v1;
    int32_t file2 = *(int32_t *)&str; // 0x804cdce
    if (file2 != 0) {
        // 0x804ce26
        int32_t str2; // bp-4112, 0x804cd6c
        if (VERBOSE == 0) {
            // 0x804ce66
            sprintf((char *)&str2, "mkdir -p %s/etc/gm/Xtns ; cp -f ../entries-gisman2 %s/etc/gm/Xtns/%s.gem ; ", gisbase, gisbase, pkg_short_name);
        } else {
            // 0x804ce2f
            sprintf((char *)&str2, "mkdir --verbose -p %s/etc/gm/Xtns ; cp -fv ../entries-gisman2 %s/etc/gm/Xtns/%s.gem ; ", gisbase, gisbase, pkg_short_name);
        }
        // 0x804ce9b
        strcpy(GISMAN2_CMD, (char *)&str2);
    } else {
        // 0x804cdd7
        if (*__errno_location() != 2) {
            // 0x804cde7
            fclose((struct _IO_FILE *)file2);
            char * err_str = strerror(*__errno_location()); // 0x804cdff
            print_error(-32, "checking for file '%s': %s\n", &file_path, err_str);
            // UNREACHABLE
        }
    }
    // 0x804ceb4
    if (v2 != __readgsdword(20)) {
        // 0x804cec0
        __stack_chk_fail();
    }
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/reg_entries.c
// Address range: 0x804cec7 - 0x804d743
// Line range:    461 - 646
int32_t deregister_entries_gisman(char * pkg_short_name, char * gisbase) {
    char tmp2[2048]; // bp-6164, 0x804cec7
    char tmp[2048]; // bp-6168, 0x804cec7
    char v1[2048]; // 0x804d0e6
    char v2[2048]; // 0x804d157
    int32_t v3 = __readgsdword(20); // 0x804cee3
    int32_t str6; // bp-2064, 0x804cec7
    sprintf((char *)&str6, "%s/etc/dm/menu.tcl", gisbase);
    struct _IO_FILE * file = fopen((char *)&str6, "r"); // 0x804cf21
    int32_t v4; // 0x804cec7
    if (file != NULL) {
        // 0x804cf8a
        memcpy((int32_t *)&TMP_GISMAN, (int32_t *)"/tmp/grass.extensions.db.XXXXXX", 32);
        mkstemp(TMP_GISMAN);
        struct _IO_FILE * file2 = fopen(TMP_GISMAN, "w+"); // 0x804cfc4
        if (file2 == NULL) {
            char * err_str = strerror(*__errno_location()); // 0x804cfe2
            print_error(-21, "could not create temp file '%s': %s\n \t\t\tMake sure that directory /tmp exists on your system and you have write permission.\n", TMP_GISMAN, err_str);
            // UNREACHABLE
        }
        // 0x804d007
        atexit(0x8048fc2);
        int32_t str7; // bp-4112, 0x804cec7
        if (VERBOSE == 0) {
            // 0x804d065
            sprintf((char *)&str7, "cp -f %s/etc/dm/menu.tcl %s/etc/dm/menu.tcl.gem.bak &> %s ; \t\t\t\t\t\tcp -f %s %s/etc/dm/menu.tcl &> %s ; chmod a+r %s/etc/dm/menu.tcl &> %s ;", gisbase, gisbase, TMP_NULL, TMP_GISMAN, gisbase, TMP_NULL, gisbase, TMP_NULL);
        } else {
            // 0x804d01c
            sprintf((char *)&str7, "cp -vf %s/etc/dm/menu.tcl %s/etc/dm/menu.tcl.gem.bak ; \t\t\t\t\t\tcp -vf %s %s/etc/dm/menu.tcl ; chmod -v a+r %s/etc/dm/menu.tcl ;", gisbase, gisbase, TMP_GISMAN, gisbase, gisbase);
        }
        // 0x804d0c4
        strcpy(GISMAN_CMD, (char *)&str7);
        tmp = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
        char * str = fgets((char *)&str7, 2048, file); // 0x804d108
        int32_t v5 = *(int32_t *)&tmp;
        int32_t v6 = v5; // 0x804d10f
        if (str != NULL) {
            v1[0] = (char)v5 + 1;
            tmp = v1;
            char * str2 = fgets((char *)&str7, 2048, file); // 0x804d108
            int32_t v7 = *(int32_t *)&tmp;
            v6 = v7;
            while (str2 != NULL) {
                // 0x804d0e6
                v1[0] = (char)v7 + 1;
                tmp = v1;
                str2 = fgets((char *)&str7, 2048, file);
                v7 = *(int32_t *)&tmp;
                v6 = v7;
            }
        }
        // 0x804d111
        v4 = -1;
        if (v6 != 0) {
            // 0x804d124
            rewind(file);
            int32_t nmemb = v6 + 1;
            int32_t * mem = calloc(nmemb, 4); // 0x804d152
            v2[0] = (int32_t)mem;
            tmp2 = v2;
            int32_t v8 = 0; // 0x804d194
            if (nmemb > 0) {
                *(int32_t *)(*(int32_t *)&tmp2 + 4 * v8) = 0;
                int32_t v9 = v8 + 1; // 0x804d17e
                v8 = v9;
                while (*(int32_t *)&tmp + 1 > v9) {
                    // 0x804d169
                    *(int32_t *)(*(int32_t *)&tmp2 + 4 * v8) = 0;
                    v9 = v8 + 1;
                    v8 = v9;
                }
            }
            char * str3 = fgets((char *)&str7, 2048, file); // 0x804d213
            int32_t v10 = *(int32_t *)&tmp2;
            int32_t v11 = v10; // 0x804d21a
            if (str3 != NULL) {
                int32_t v12 = (int32_t)NULL; // 0x804d1a2
                int32_t v13 = 4 * v12; // 0x804d1a8
                int32_t * mem2 = malloc(strlen((char *)&str7) + 1); // 0x804d1c7
                *(int32_t *)(v13 + v10) = (int32_t)mem2;
                int32_t v14 = *(int32_t *)&tmp2; // 0x804d1dd
                strcpy((char *)*(int32_t *)(v14 + v13), (char *)&str7);
                char * str4 = fgets((char *)&str7, 2048, file); // 0x804d213
                int32_t v15 = v14; // 0x804d21a
                char ** v16 = (char **)(v12 + 1); // 0x804d21a
                v11 = v14;
                while (str4 != NULL) {
                    // 0x804d1a2
                    v12 = (int32_t)v16;
                    v13 = 4 * v12;
                    mem2 = malloc(strlen((char *)&str7) + 1);
                    *(int32_t *)(v13 + v15) = (int32_t)mem2;
                    v14 = *(int32_t *)&tmp2;
                    strcpy((char *)*(int32_t *)(v14 + v13), (char *)&str7);
                    str4 = fgets((char *)&str7, 2048, file);
                    v15 = v14;
                    v16 = (char **)(v12 + 1);
                    v11 = v14;
                }
            }
            // 0x804d21c
            sprintf((char *)&str7, "#(DO_NOT_REMOVE_THIS_COMMENT) <%s> {cascad", pkg_short_name);
            int32_t v17 = find_pos((char *)&str7, (char **)v11, 0); // 0x804d258
            if (v17 != -1) {
                int32_t found_char_pos = (int32_t)strchr((char *)*(int32_t *)(4 * v17 + v11), 34); // 0x804d29e
                char * str8 = (char *)(found_char_pos + 1); // 0x804d2be
                char * found_char_pos2 = strchr(str8, 34); // 0x804d2c1
                int32_t str9; // bp-6160, 0x804cec7
                strcpy((char *)&str9, str8);
                int32_t v18; // bp-4, 0x804cec7
                *(char *)((int32_t)&v18 - 0x180c + -1 - found_char_pos + (int32_t)found_char_pos2) = 0;
                int32_t v19 = *(int32_t *)&tmp2;
                char ** v20 = (char **)v19;
                int32_t v21 = find_pos("\"&Xtns\" all options 1", v20, 0); // 0x804d317
                int32_t v22 = find_pos("\" all options", v20, v21 + 1); // 0x804d340
                int32_t v23 = v22 - 1; // 0x804d355
                if (v22 == 0) {
                    // 0x804d357
                    v23 = find_pos("}]", v20, 0);
                }
                if (v21 != -1) {
                    // 0x804d39a
                    sprintf((char *)&str7, "{cascad \"%s\"", &str9);
                    int32_t v24 = find_pos((char *)&str7, v20, v21); // 0x804d3d8
                    if (v24 == -1 || v24 > v23) {
                        // 0x804d3fa
                        print_warning("could not find submenu entry '%s' in 'menu.tcl'.\n", &str9);
                        v4 = -1;
                    } else {
                        int32_t v25 = find_pos(" \t\t\t}}", v20, v24); // 0x804d435
                        if (v25 == -1 || v25 > v23) {
                            // 0x804d457
                            print_warning("could not find end of submenu entry '%s' in 'menu.tcl'.\n", &str9);
                            v4 = -1;
                        } else {
                            char * v26 = (char *)1; // 0x804d4ce
                            if (1 - v24 + v25 > 0) {
                                int32_t v27 = 2 - v24 + v25;
                                int32_t v28 = 1;
                                delete_str(v24, v20);
                                while (v28 + 1 != v27) {
                                    // 0x804d48d
                                    v28++;
                                    delete_str(v24, v20);
                                }
                                // 0x804d4b3
                                v26 = (char *)v27;
                            }
                            // 0x804d4d0
                            sprintf((char *)&str7, "#(DO_NOT_REMOVE_THIS_COMMENT) <%s> {cascad", pkg_short_name);
                            int32_t v29 = find_pos((char *)&str7, v20, 0); // 0x804d50c
                            delete_str(v29, v20);
                            int32_t v30 = find_pos("\"&Xtns\" all options 1", v20, 0); // 0x804d54f
                            uint32_t v31 = find_pos("\" all options", v20, v30 + 1) + -1 - v30; // 0x804d594
                            char * v32 = v26; // 0x804d59b
                            if (v31 <= 2) {
                                int32_t v33 = v31 + 1; // 0x804d5e1
                                v32 = v26;
                                if (v33 > 0) {
                                    delete_str(v30, v20);
                                    char * v34 = (char *)((int32_t)v26 + 1);
                                    int32_t v35 = 1; // 0x804d5c8
                                    int32_t v36 = v35; // 0x804d5ea
                                    char * v37 = v34; // 0x804d5ea
                                    v32 = v34;
                                    while (v35 != v33) {
                                        // 0x804d5a9
                                        delete_str(v30, v20);
                                        v34 = (char *)((int32_t)v37 + 1);
                                        v35 = v36 + 1;
                                        v36 = v35;
                                        v37 = v34;
                                        v32 = v34;
                                    }
                                }
                            }
                            int32_t * v38 = (int32_t *)v19;
                            int32_t format = *v38; // 0x804d631
                            if (format != 0) {
                                fprintf(file2, (char *)format);
                                int32_t v39 = 1; // 0x804d61b
                                int32_t v40 = *(int32_t *)(4 * v39 + v19); // 0x804d631
                                int32_t format2 = v40; // 0x804d635
                                int32_t v41 = v39; // 0x804d635
                                while (v40 != 0) {
                                    // 0x804d5f8
                                    fprintf(file2, (char *)format2);
                                    v39 = v41 + 1;
                                    v40 = *(int32_t *)(4 * v39 + v19);
                                    format2 = v40;
                                    v41 = v39;
                                }
                            }
                            // 0x804d637
                            fflush(file2);
                            rewind(file2);
                            int32_t v42 = 0;
                            char * str5 = fgets((char *)&str7, 2048, file2); // 0x804d681
                            int32_t v43 = v42 + 1; // 0x804d688
                            while (str5 != NULL) {
                                // 0x804d666
                                v42 = v43;
                                str5 = fgets((char *)&str7, 2048, file2);
                                v43 = v42 + 1;
                            }
                            if (v42 == 0) {
                                // 0x804d693
                                print_warning("file truncation detected. Retaining orginal file 'menu.tcl'.\n");
                                memcpy((int32_t *)&GISMAN_CMD, &g5, 1);
                            }
                            // 0x804d6bc
                            fclose(file);
                            fclose(file2);
                            int32_t v44 = *(int32_t *)&tmp + 1;
                            int32_t v45 = 0; // 0x804d713
                            if (v44 > 0) {
                                free((int32_t *)*(int32_t *)(4 * v45 + v19));
                                int32_t v46 = v45 + 1; // 0x804d6fd
                                v45 = v46;
                                while (v46 != v44) {
                                    // 0x804d6e4
                                    free((int32_t *)*(int32_t *)(4 * v45 + v19));
                                    v46 = v45 + 1;
                                    v45 = v46;
                                }
                            }
                            // 0x804d715
                            free(v38);
                            v4 = (int32_t)v32;
                        }
                    }
                } else {
                    // 0x804d384
                    print_warning("menu 'Xtns' does not exist.\n");
                    v4 = -1;
                }
            } else {
                // 0x804d26c
                print_warning("could not find uninstall information in 'menu.tcl'.\n");
                v4 = -1;
            }
        }
    } else {
        int32_t v47 = *__errno_location(); // 0x804cf3a
        v4 = 0;
        if (v47 != 2) {
            // 0x804cf4b
            fclose(file);
            char * err_str2 = strerror(*__errno_location()); // 0x804cf63
            print_error(-22, "checking for file '%s': %s\n", &str6, err_str2);
            // UNREACHABLE
        }
    }
    int32_t result = v4; // 0x804d733
    if (v3 != __readgsdword(20)) {
        // 0x804d735
        __stack_chk_fail();
        result = &g18;
    }
    // 0x804d73a
    return result;
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/reg_entries.c
// Address range: 0x804d743 - 0x804d896
// Line range:    653 - 686
void deregister_entries_gisman2(char * pkg_short_name, char * gisbase) {
    char str[2048]; // bp-4116, 0x804d743
    char v1[2048]; // 0x804d7ab
    int32_t v2 = __readgsdword(20); // 0x804d75e
    int32_t str2; // bp-2064, 0x804d743
    sprintf((char *)&str2, "%s/etc/gm/Xtns/%s.gem", gisbase, pkg_short_name);
    struct _IO_FILE * file = fopen((char *)&str2, "r"); // 0x804d7a6
    v1[0] = (int32_t)file;
    str = v1;
    int32_t file2 = *(int32_t *)&str; // 0x804d7b1
    if (file2 != 0) {
        // 0x804d809
        int32_t str3; // bp-4112, 0x804d743
        if (VERBOSE == 0) {
            // 0x804d83f
            sprintf((char *)&str3, "rm -f %s/etc/gm/Xtns/%s.gem ; ", gisbase, pkg_short_name);
        } else {
            // 0x804d812
            sprintf((char *)&str3, "rm -vf %s/etc/gm/Xtns/%s.gem ; ", gisbase, pkg_short_name);
        }
        // 0x804d86a
        strcpy(GISMAN_CMD, (char *)&str3);
    } else {
        // 0x804d7ba
        if (*__errno_location() != 2) {
            // 0x804d7ca
            fclose((struct _IO_FILE *)file2);
            char * err_str = strerror(*__errno_location()); // 0x804d7e2
            print_error(-33, "checking for file '%s': %s\n", &str2, err_str);
            // UNREACHABLE
        }
    }
    // 0x804d883
    if (v2 != __readgsdword(20)) {
        // 0x804d88f
        __stack_chk_fail();
    }
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/reg_entries.c
// Address range: 0x804d896 - 0x804e100
// Line range:    692 - 873
int32_t restore_entries_gisman(char * gisbase) {
    char pkg_short_name2[2048]; // bp-10260, 0x804d896
    char pkg_short_name[2048]; // bp-10264, 0x804d896
    char v1[2048]; // 0x804dcab
    char v2[2048]; // 0x804deb9
    int32_t v3 = __readgsdword(20); // 0x804d8a9
    int32_t str6; // bp-6160, 0x804d896
    sprintf((char *)&str6, "%s/etc/dm/menu.tcl", gisbase);
    struct _IO_FILE * file = fopen((char *)&str6, "r"); // 0x804d8e7
    struct dirent * v4; // 0x804d896
    struct dirent * v5; // 0x804d896
    int32_t v6; // 0x804d896
    int32_t v7; // 0x804d896
    int32_t v8; // 0x804d896
    int32_t v9; // 0x804d896
    int32_t v10; // 0x804d896
    int32_t v11; // 0x804d896
    int32_t str7; // bp-2064, 0x804d896
    struct __dirstream * dirp; // 0x804daca
    struct _IO_FILE * file3; // 0x804db41
    if (file != NULL) {
        // 0x804d950
        memcpy((int32_t *)&TMP_GISMAN, (int32_t *)"/tmp/grass.extensions.db.XXXXXX", 32);
        mkstemp(TMP_GISMAN);
        struct _IO_FILE * file2 = fopen(TMP_GISMAN, "w+"); // 0x804d98a
        if (file2 == NULL) {
            char * err_str = strerror(*__errno_location()); // 0x804d9a8
            print_error(-21, "could not create temp file '%s': %s\n \t\t\tMake sure that directory /tmp exists on your system and you have write permission.\n", TMP_GISMAN, err_str);
            // UNREACHABLE
        }
        // 0x804d9cd
        atexit(0x8048fc2);
        if (VERBOSE == 0) {
            // 0x804da2b
            sprintf((char *)&str7, "cp -f %s/etc/dm/menu.tcl %s/etc/dm/menu.tcl.gem.bak &> %s ; \t\t\t\t\t\tcp -f %s %s/etc/dm/menu.tcl &> %s ; chmod a+r %s/etc/dm/menu.tcl &> %s ;", gisbase, gisbase, TMP_NULL, TMP_GISMAN, gisbase, TMP_NULL, gisbase, TMP_NULL);
        } else {
            // 0x804d9e2
            sprintf((char *)&str7, "cp -vf %s/etc/dm/menu.tcl %s/etc/dm/menu.tcl.gem.bak ; \t\t\t\t\t\tcp -vf %s %s/etc/dm/menu.tcl ; chmod -v a+r %s/etc/dm/menu.tcl ;", gisbase, gisbase, TMP_GISMAN, gisbase, gisbase);
        }
        // 0x804da8a
        strcpy(GISMAN_CMD, (char *)&str7);
        int32_t str8; // bp-8208, 0x804d896
        sprintf((char *)&str8, "%s/etc/dm/gem-entries", gisbase);
        dirp = opendir((char *)&str8);
        v6 = 0;
        if (dirp != NULL) {
            struct dirent * v12 = readdir(dirp); // 0x804dbfb
            v5 = v12;
            v7 = 0;
            v10 = 0;
            v11 = 0;
            v8 = 0;
            if (v12 != NULL) {
                while (true) {
                  lab_0x804db01_2:
                    // 0x804db01
                    v4 = v5;
                    while (true) {
                      lab_0x804db01:;
                        char * str9 = (char *)((int32_t)v4 + 11); // 0x804db2a
                        sprintf((char *)&str6, "%s/%s", &str8, str9);
                        file3 = fopen((char *)&str6, "r");
                        if (strcmp(str9, ".") == 0) {
                            // 0x804db86
                            fclose(file3);
                            goto lab_0x804dbf2;
                        } else {
                            // 0x804db69
                            if (strcmp(str9, "..") != 0) {
                                // 0x804db96
                                int32_t v13; // 0x804d896
                                v9 = v13;
                                if (file3 != NULL) {
                                    goto lab_0x804dbb9;
                                }
                                // 0x804db9f
                                fclose(file3);
                                goto lab_0x804dbf2;
                            } else {
                                // 0x804db86
                                fclose(file3);
                                goto lab_0x804dbf2;
                            }
                        }
                    }
                    goto lab_0x804dbdd;
                }
            }
          lab_0x804dc13_2:
            // 0x804dc13
            closedir(dirp);
            char * str = fgets((char *)&str7, 2048, file); // 0x804dc4f
            v6 = 0;
            if (str != NULL) {
                int32_t v14 = (int32_t)NULL + 1; // 0x804dc2d
                char * str2 = fgets((char *)&str7, 2048, file); // 0x804dc4f
                char ** v15 = (char **)v14; // 0x804dc56
                while (str2 != NULL) {
                    // 0x804dc2d
                    v14 = (int32_t)v15 + 1;
                    str2 = fgets((char *)&str7, 2048, file);
                    v15 = (char **)v14;
                }
                // 0x804dc58
                v6 = 0;
                if (v14 != 0) {
                    // 0x804dc6b
                    rewind(file);
                    int32_t nmemb = (2 * v11 | 1) + 5 * v8 + v14; // 0x804dc98
                    int32_t * mem = calloc(nmemb, 4); // 0x804dca6
                    v1[0] = (int32_t)mem;
                    pkg_short_name = v1;
                    int32_t v16 = 0; // 0x804dd01
                    if (nmemb > 0) {
                        *(int32_t *)(*(int32_t *)&pkg_short_name + 4 * v16) = 0;
                        int32_t v17 = v16 + 1; // 0x804dcd2
                        v16 = v17;
                        while (v17 != nmemb) {
                            // 0x804dcbd
                            *(int32_t *)(*(int32_t *)&pkg_short_name + 4 * v16) = 0;
                            v17 = v16 + 1;
                            v16 = v17;
                        }
                    }
                    char * str3 = fgets((char *)&str7, 2048, file); // 0x804dd80
                    int32_t v18 = *(int32_t *)&pkg_short_name;
                    int32_t v19 = v18; // 0x804dd87
                    if (str3 != NULL) {
                        *(int32_t *)v18 = (int32_t)malloc(strlen((char *)&str7) + 1);
                        int32_t str10 = *(int32_t *)&pkg_short_name;
                        strcpy((char *)*(int32_t *)str10, (char *)&str7);
                        int32_t v20 = 1; // 0x804dd5e
                        char * str4 = fgets((char *)&str7, 2048, file); // 0x804dd80
                        int32_t v21 = 4 * v20;
                        int32_t v22 = str10 + v21;
                        int32_t v23 = v22; // 0x804dd87
                        int32_t v24 = v21; // 0x804dd87
                        int32_t v25 = v20; // 0x804dd87
                        v19 = v22;
                        while (str4 != NULL) {
                            int32_t * mem2 = malloc(strlen((char *)&str7) + 1); // 0x804dd34
                            *(int32_t *)v23 = (int32_t)mem2;
                            str10 = *(int32_t *)&pkg_short_name;
                            strcpy((char *)*(int32_t *)(str10 + v24), (char *)&str7);
                            v20 = v25 + 1;
                            str4 = fgets((char *)&str7, 2048, file);
                            v21 = 4 * v20;
                            v22 = str10 + v21;
                            v23 = v22;
                            v24 = v21;
                            v25 = v20;
                            v19 = v22;
                        }
                    }
                    // 0x804dd89
                    *(int32_t *)v19 = 0;
                    int32_t v26 = *(int32_t *)&pkg_short_name; // 0x804dd9e
                    check_ext_menu((char **)v26);
                    struct __dirstream * dirp2 = opendir((char *)&str8); // 0x804ddb5
                    struct dirent * v27 = readdir(dirp2); // 0x804dfe1
                    int32_t v28 = v26; // 0x804dff3
                    int32_t v29 = 0; // 0x804dff3
                    if (v27 != NULL) {
                        int32_t v30 = 0;
                        struct dirent * v31 = v27; // 0x804dfe1
                        char * str11; // 0x804ddf8
                        struct _IO_FILE * file4; // 0x804de51
                        while (true) {
                            // 0x804ddcf
                            str11 = (char *)((int32_t)v31 + 11);
                            sprintf((char *)&str6, "%s/%s", &str8, str11);
                            if (strcmp(str11, ".") != 0) {
                                // 0x804de1e
                                if (strcmp(str11, "..") != 0) {
                                    // 0x804de3f
                                    file4 = fopen((char *)&str6, "r");
                                    if (file4 != NULL) {
                                        // break -> 0x804df93
                                        break;
                                    }
                                }
                            }
                            // 0x804dfd8
                            v31 = readdir(dirp2);
                            v28 = v26;
                            v29 = v30;
                            if (v31 == NULL) {
                                // break (via goto) -> 0x804dff9
                                goto lab_0x804dff9;
                            }
                        }
                        char * v32 = nc_fgets_nb((char *)&str7, 2048, file4); // 0x804dfae
                        int32_t v33; // 0x804d896
                        int32_t v34 = v33; // 0x804dfb5
                        int32_t v35 = v30; // 0x804dfb5
                        int32_t v36 = v26; // 0x804dfb5
                        int32_t v37 = v30; // 0x804dfb5
                        int32_t v38 = v33; // 0x804dfb5
                        int32_t v39; // 0x804d896
                        int32_t v40; // 0x804d896
                        int32_t v41; // 0x804d896
                        int32_t v42; // 0x804d896
                        int32_t v43; // 0x804d896
                        int32_t v44; // 0x804d896
                        int32_t v45; // 0x804d896
                        int32_t v46; // bp-10256, 0x804d896
                        int32_t v47; // bp-4, 0x804d896
                        int32_t str12; // bp-4112, 0x804d896
                        int32_t v48; // 0x804df71
                        char * found_char_pos; // 0x804de96
                        char * found_char_pos2; // 0x804deae
                        int32_t n; // 0x804d896
                        char * found_char_pos3; // 0x804ded6
                        int32_t v49; // 0x804df05
                        int32_t v50; // 0x804df22
                        char * v51; // 0x804dfae
                        if (v32 != NULL) {
                            v44 = 1;
                            if (v44 != 1) {
                                // 0x804df4a
                                v48 = new_item((char *)&str7, (char *)&str12, (char **)v26, v34);
                                v40 = v26;
                                v45 = v48;
                                if (v48 < 0) {
                                    // break -> 0x804dfc1
                                    break;
                                }
                            } else {
                                // 0x804de85
                                found_char_pos = strrchr((char *)&str7, 93);
                                found_char_pos2 = strchr((char *)&str7, 91);
                                v2[0] = (int32_t)found_char_pos - (int32_t)found_char_pos2;
                                pkg_short_name2 = v2;
                                n = *(int32_t *)&pkg_short_name2;
                                found_char_pos3 = strchr((char *)&str7, 91);
                                strncpy((char *)&str12, (char *)((int32_t)found_char_pos3 + 1), n);
                                *(char *)((int32_t)&v47 - 0x100d + n) = 0;
                                v49 = *(int32_t *)&pkg_short_name;
                                v50 = new_submenu((char *)&v46, (char *)&str7, (char **)v49);
                                v40 = v49;
                                v45 = v50;
                                if (v50 < 0) {
                                    // break -> 0x804dfc1
                                    break;
                                }
                            }
                            // 0x804df93
                            v42 = v35 + 1;
                            v51 = nc_fgets_nb((char *)&str7, 2048, file4);
                            v39 = v40;
                            v34 = v45;
                            v43 = v44 + 1;
                            v36 = v40;
                            v37 = v42;
                            v38 = v45;
                            while (v51 != NULL) {
                                // 0x804de78
                                v44 = v43;
                                v41 = v42;
                                if (v44 != 1) {
                                    // 0x804df4a
                                    v48 = new_item((char *)&str7, (char *)&str12, (char **)v39, v34);
                                    v40 = v39;
                                    v45 = v48;
                                    v36 = v39;
                                    v37 = v41;
                                    v38 = v48;
                                    if (v48 < 0) {
                                        // break -> 0x804dfc1
                                        break;
                                    }
                                } else {
                                    // 0x804de85
                                    found_char_pos = strrchr((char *)&str7, 93);
                                    found_char_pos2 = strchr((char *)&str7, 91);
                                    v2[0] = (int32_t)found_char_pos - (int32_t)found_char_pos2;
                                    pkg_short_name2 = v2;
                                    n = *(int32_t *)&pkg_short_name2;
                                    found_char_pos3 = strchr((char *)&str7, 91);
                                    strncpy((char *)&str12, (char *)((int32_t)found_char_pos3 + 1), n);
                                    *(char *)((int32_t)&v47 - 0x100d + n) = 0;
                                    v49 = *(int32_t *)&pkg_short_name;
                                    v50 = new_submenu((char *)&v46, (char *)&str7, (char **)v49);
                                    v40 = v49;
                                    v45 = v50;
                                    v36 = v49;
                                    v37 = v41;
                                    v38 = v50;
                                    if (v50 < 0) {
                                        // break -> 0x804dfc1
                                        break;
                                    }
                                }
                                // 0x804df93
                                v42 = v41 + 1;
                                v51 = nc_fgets_nb((char *)&str7, 2048, file4);
                                v39 = v40;
                                v34 = v45;
                                v43 = v44 + 1;
                                v36 = v40;
                                v37 = v42;
                                v38 = v45;
                            }
                        }
                        int32_t v52 = v37;
                        int32_t v53 = v36;
                        fclose(file4);
                        struct dirent * v54 = readdir(dirp2); // 0x804dfe1
                        v33 = v38;
                        v28 = v53;
                        v29 = v52;
                        while (v54 != NULL) {
                            // 0x804ddcf
                            v30 = v52;
                            int32_t v55 = v53;
                            v31 = v54;
                            while (true) {
                                // 0x804ddcf
                                str11 = (char *)((int32_t)v31 + 11);
                                sprintf((char *)&str6, "%s/%s", &str8, str11);
                                if (strcmp(str11, ".") != 0) {
                                    // 0x804de1e
                                    if (strcmp(str11, "..") != 0) {
                                        // 0x804de3f
                                        file4 = fopen((char *)&str6, "r");
                                        if (file4 != NULL) {
                                            // break -> 0x804df93
                                            break;
                                        }
                                    }
                                }
                                // 0x804dfd8
                                v31 = readdir(dirp2);
                                v28 = v55;
                                v29 = v30;
                                if (v31 == NULL) {
                                    // break (via goto) -> 0x804dff9
                                    goto lab_0x804dff9;
                                }
                            }
                            // 0x804df93
                            v32 = nc_fgets_nb((char *)&str7, 2048, file4);
                            v39 = v55;
                            v34 = v33;
                            v35 = v30;
                            v36 = v55;
                            v37 = v30;
                            v38 = v33;
                            if (v32 != NULL) {
                                v44 = 1;
                                if (v44 != 1) {
                                    // 0x804df4a
                                    v48 = new_item((char *)&str7, (char *)&str12, (char **)v39, v34);
                                    v40 = v39;
                                    v45 = v48;
                                    if (v48 < 0) {
                                        // break -> 0x804dfc1
                                        break;
                                    }
                                } else {
                                    // 0x804de85
                                    found_char_pos = strrchr((char *)&str7, 93);
                                    found_char_pos2 = strchr((char *)&str7, 91);
                                    v2[0] = (int32_t)found_char_pos - (int32_t)found_char_pos2;
                                    pkg_short_name2 = v2;
                                    n = *(int32_t *)&pkg_short_name2;
                                    found_char_pos3 = strchr((char *)&str7, 91);
                                    strncpy((char *)&str12, (char *)((int32_t)found_char_pos3 + 1), n);
                                    *(char *)((int32_t)&v47 - 0x100d + n) = 0;
                                    v49 = *(int32_t *)&pkg_short_name;
                                    v50 = new_submenu((char *)&v46, (char *)&str7, (char **)v49);
                                    v40 = v49;
                                    v45 = v50;
                                    if (v50 < 0) {
                                        // break -> 0x804dfc1
                                        break;
                                    }
                                }
                                // 0x804df93
                                v42 = v35 + 1;
                                v51 = nc_fgets_nb((char *)&str7, 2048, file4);
                                v39 = v40;
                                v34 = v45;
                                v43 = v44 + 1;
                                v36 = v40;
                                v37 = v42;
                                v38 = v45;
                                while (v51 != NULL) {
                                    // 0x804de78
                                    v44 = v43;
                                    v41 = v42;
                                    if (v44 != 1) {
                                        // 0x804df4a
                                        v48 = new_item((char *)&str7, (char *)&str12, (char **)v39, v34);
                                        v40 = v39;
                                        v45 = v48;
                                        v36 = v39;
                                        v37 = v41;
                                        v38 = v48;
                                        if (v48 < 0) {
                                            // break -> 0x804dfc1
                                            break;
                                        }
                                    } else {
                                        // 0x804de85
                                        found_char_pos = strrchr((char *)&str7, 93);
                                        found_char_pos2 = strchr((char *)&str7, 91);
                                        v2[0] = (int32_t)found_char_pos - (int32_t)found_char_pos2;
                                        pkg_short_name2 = v2;
                                        n = *(int32_t *)&pkg_short_name2;
                                        found_char_pos3 = strchr((char *)&str7, 91);
                                        strncpy((char *)&str12, (char *)((int32_t)found_char_pos3 + 1), n);
                                        *(char *)((int32_t)&v47 - 0x100d + n) = 0;
                                        v49 = *(int32_t *)&pkg_short_name;
                                        v50 = new_submenu((char *)&v46, (char *)&str7, (char **)v49);
                                        v40 = v49;
                                        v45 = v50;
                                        v36 = v49;
                                        v37 = v41;
                                        v38 = v50;
                                        if (v50 < 0) {
                                            // break -> 0x804dfc1
                                            break;
                                        }
                                    }
                                    // 0x804df93
                                    v42 = v41 + 1;
                                    v51 = nc_fgets_nb((char *)&str7, 2048, file4);
                                    v39 = v40;
                                    v34 = v45;
                                    v43 = v44 + 1;
                                    v36 = v40;
                                    v37 = v42;
                                    v38 = v45;
                                }
                            }
                            // 0x804dfc1
                            v52 = v37;
                            v53 = v36;
                            fclose(file4);
                            v54 = readdir(dirp2);
                            v33 = v38;
                            v28 = v53;
                            v29 = v52;
                        }
                    }
                  lab_0x804dff9:
                    // 0x804dff9
                    closedir(dirp2);
                    int32_t * v56 = (int32_t *)v28;
                    int32_t format = *v56; // 0x804e04c
                    if (format != 0) {
                        fprintf(file2, (char *)format);
                        int32_t v57 = 1; // 0x804e036
                        int32_t v58 = *(int32_t *)(4 * v57 + v28); // 0x804e04c
                        int32_t format2 = v58; // 0x804e050
                        int32_t v59 = v57; // 0x804e050
                        while (v58 != 0) {
                            // 0x804e013
                            fprintf(file2, (char *)format2);
                            v57 = v59 + 1;
                            v58 = *(int32_t *)(4 * v57 + v28);
                            format2 = v58;
                            v59 = v57;
                        }
                    }
                    // 0x804e052
                    fflush(file2);
                    fclose(file);
                    fclose(file2);
                    int32_t v60 = 0; // 0x804e0d0
                    if (nmemb > 0) {
                        free((int32_t *)*(int32_t *)(4 * v60 + v28));
                        int32_t v61 = v60 + 1; // 0x804e0a1
                        v60 = v61;
                        while (v61 != nmemb) {
                            // 0x804e088
                            free((int32_t *)*(int32_t *)(4 * v60 + v28));
                            v61 = v60 + 1;
                            v60 = v61;
                        }
                    }
                    // 0x804e0d2
                    free(v56);
                    v6 = v29;
                }
            }
        }
    } else {
        int32_t v62 = *__errno_location(); // 0x804d900
        v6 = 0;
        if (v62 != 2) {
            // 0x804d911
            fclose(file);
            char * err_str2 = strerror(*__errno_location()); // 0x804d929
            print_error(-21, "checking for file '%s': %s\n", &str6, err_str2);
            // UNREACHABLE
        }
    }
    int32_t result = v6; // 0x804e0f0
    if (v3 != __readgsdword(20)) {
        // 0x804e0f2
        __stack_chk_fail();
        result = &g18;
    }
    // 0x804e0f7
    return result;
  lab_0x804dbb9:;
    int32_t v63 = v9;
    char * str5 = fgets((char *)&str7, 2048, file3); // 0x804dbd4
    v9 = v63 + 1;
    if (str5 != NULL) {
        goto lab_0x804dbb9;
    } else {
        goto lab_0x804dbdd;
    }
  lab_0x804dbf2:;
    struct dirent * v64 = readdir(dirp); // 0x804dbfb
    v4 = v64;
    v11 = v10;
    v8 = v7;
    if (v64 == NULL) {
        // break (via goto) -> 0x804dc13
        goto lab_0x804dc13_2;
    }
    goto lab_0x804db01;
  lab_0x804dbdd:;
    int32_t v65 = v7 + 1; // 0x804dbdd
    fclose(file3);
    struct dirent * v66 = readdir(dirp); // 0x804dbfb
    v5 = v66;
    v7 = v65;
    v10 = v63;
    v11 = v63;
    v8 = v65;
    if (v66 == NULL) {
        // break -> 0x804dc13
        goto lab_0x804dc13_2;
    }
    goto lab_0x804db01_2;
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/reg_html.c
// Address range: 0x804e100 - 0x804e56f
// Line range:    29 - 107
void new_ext_html(char * ext, char * gisbase, char ** html, int32_t major, int32_t minor, int32_t revision) {
    char item2[2048]; // bp-2068, 0x804e100
    char item[2048]; // bp-2072, 0x804e100
    char v1[2048]; // 0x804e14d
    char v2[2048]; // 0x804e1ba
    char v3[2048]; // 0x804e17a
    int32_t v4 = __readgsdword(20); // 0x804e124
    int32_t v5 = find_pos("<b>Drivers sections:</b>", html, 0); // 0x804e148
    v1[0] = v5;
    item2 = v1;
    int32_t v6 = *(int32_t *)&item2; // 0x804e153
    int32_t v7 = v6; // 0x804e15a
    if (v6 >= 0) {
        goto lab_0x804e19a;
    } else {
        int32_t v8 = find_pos("<!-- GEM Extensions StartHTML. Do not delete or change this comment! -->", html, 0); // 0x804e175
        v3[0] = v8;
        item2 = v3;
        v7 = *(int32_t *)&item2;
        if (v7 >= 0) {
            goto lab_0x804e19a;
        } else {
            // 0x804e189
            print_warning("Unknown format of index.html. Unable to register HTML man pages.\n");
            goto lab_0x804e55c;
        }
    }
  lab_0x804e19a:;
    int32_t v9 = find_pos("<hr>", html, v7); // 0x804e1b5
    v2[0] = v9;
    item = v2;
    if (find_pos("<h3>Installed extensions:</h3>", html, v7) == -1) {
        int32_t v10 = *(int32_t *)&item;
        insert_str("<h3>Installed extensions:</h3>\n", v10, html);
        insert_str("<ul>\n", v10 + 1, html);
        insert_str("</ul>\n", v10 + 2, html);
        insert_str("<p>\n", v10 + 3, html);
    }
    int32_t v11 = find_pos("<h3>Installed extensions:</h3>", html, v7); // 0x804e28d
    int32_t v12 = find_pos("</ul>", html, v11); // 0x804e2b3
    int32_t v13 = v11 + 2; // 0x804e2c4
    int32_t str; // bp-2064, 0x804e100
    sprintf((char *)&str, "\">%s", ext);
    int32_t v14 = find_pos((char *)&str, html, v13); // 0x804e30b
    if (v14 == -1) {
        int32_t v15 = find_pos("<li><a href=", html, v11); // 0x804e3d6
        int32_t v16 = v13; // 0x804e4e0
        if (v15 != -1 == v15 < v12) {
            int32_t v17 = v11; // 0x804e4ac
            int32_t * str2 = (int32_t *)(4 * v15 + (int32_t)html); // 0x804e3f5
            int32_t found_char_pos = (int32_t)strrchr((char *)*str2, 34); // 0x804e402
            int32_t n = (int32_t)strrchr((char *)*str2, 60) - found_char_pos; // 0x804e442
            strncpy((char *)&str, (char *)(found_char_pos + 2), n);
            int32_t v18; // bp-4, 0x804e100
            *(char *)((int32_t)&v18 - 2061 + n) = 0;
            int32_t strcmp_rc = strcmp(ext, (char *)&str); // 0x804e495
            v16 = v15;
            while (strcmp_rc >= 0) {
                // 0x804e4ac
                v17++;
                int32_t v19 = find_pos("<li><a href=", html, v17); // 0x804e4ce
                v16 = v13;
                if (v19 != -1 != v19 < v12) {
                    // break -> 0x804e4f4
                    break;
                }
                str2 = (int32_t *)(4 * v19 + (int32_t)html);
                found_char_pos = (int32_t)strrchr((char *)*str2, 34);
                n = (int32_t)strrchr((char *)*str2, 60) - found_char_pos;
                strncpy((char *)&str, (char *)(found_char_pos + 2), n);
                *(char *)((int32_t)&v18 - 2061 + n) = 0;
                strcmp_rc = strcmp(ext, (char *)&str);
                v16 = v19;
            }
        }
        char * v20 = ext;
        sprintf((char *)&str, "<li><a href=\"../extensions/%s/index.html\">%s (%i.%i.%i)</a>\n", v20, v20, major, minor, revision);
        insert_str((char *)&str, v16, html);
    } else {
        // 0x804e323
        print_warning("list item '%s' exists in index.html.\n", ext);
        if (FORCE != 0 && UPGRADE != 0) {
            // 0x804e353
            sprintf((char *)&str, "<li><a href=\"../extensions/%s/index.html\">%s (%i.%i.%i)</a>\n", ext, ext, major, minor, revision);
            int32_t str3 = *(int32_t *)(4 * v14 + (int32_t)html); // 0x804e3a8
            strcpy((char *)str3, (char *)&str);
        }
    }
    goto lab_0x804e55c;
  lab_0x804e55c:
    // 0x804e55c
    if (v4 != __readgsdword(20)) {
        // 0x804e568
        __stack_chk_fail();
    }
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/reg_html.c
// Address range: 0x804e56f - 0x804e7f3
// Line range:    110 - 166
void delete_ext_html(char * ext, char * gisbase, char ** html) {
    char item[2048]; // bp-2068, 0x804e56f
    char v1[2048]; // 0x804e5bc
    char v2[2048]; // 0x804e5e9
    int32_t v3 = __readgsdword(20); // 0x804e593
    int32_t v4 = find_pos("<b>Drivers sections:</b>", html, 0); // 0x804e5b7
    v1[0] = v4;
    item = v1;
    int32_t v5 = *(int32_t *)&item; // 0x804e5c2
    int32_t v6 = v5; // 0x804e5c9
    if (v5 >= 0) {
        goto lab_0x804e609;
    } else {
        int32_t v7 = find_pos("<!-- GEM Extensions StartHTML. Do not delete or change this comment! -->", html, 0); // 0x804e5e4
        v2[0] = v7;
        item = v2;
        v6 = *(int32_t *)&item;
        if (v6 >= 0) {
            goto lab_0x804e609;
        } else {
            // 0x804e5f8
            print_warning("Unknown format of index.html. Unable to de-register HTML man pages.\n");
            goto lab_0x804e7e0;
        }
    }
  lab_0x804e609:
    // 0x804e609
    find_pos("<hr>", html, v6);
    if (find_pos("<h3>Installed extensions:</h3>", html, v6) != -1) {
        int32_t v8 = find_pos("<h3>Installed extensions:</h3>", html, v6); // 0x804e680
        int32_t v9 = find_pos("</ul>", html, v8); // 0x804e6a6
        int32_t str; // bp-2064, 0x804e56f
        sprintf((char *)&str, "\">%s", ext);
        int32_t v10 = find_pos((char *)&str, html, v8); // 0x804e6f9
        if (v10 != -1) {
            if (v10 < v9) {
                // 0x804e736
                delete_str(v10, html);
            }
            int32_t v11 = v9 - 1; // 0x804e74e
            int32_t v12 = find_pos("<ul>", html, v8); // 0x804e770
            if (v11 > v12 && v12 != -1 && v11 - v12 <= 1) {
                for (int32_t i = 0; i < 4; i++) {
                    // 0x804e7b5
                    delete_str(v12 - 1, html);
                }
            }
        } else {
            // 0x804e70d
            print_warning("extension '%s' not listed in index.html.\n", ext);
        }
    } else {
        // 0x804e654
        print_warning("no extensions section found in index.html.\n");
    }
    goto lab_0x804e7e0;
  lab_0x804e7e0:
    // 0x804e7e0
    if (v3 != __readgsdword(20)) {
        // 0x804e7ec
        __stack_chk_fail();
    }
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/reg_html.c
// Address range: 0x804e7f3 - 0x804ec17
// Line range:    169 - 268
void register_html(char * pkg_short_name, char * gisbase, int32_t major, int32_t minor, int32_t revision) {
    char str2[2048]; // bp-4116, 0x804e7f3
    char str[2048]; // bp-4120, 0x804e7f3
    char v1[2048]; // 0x804e9dc
    char v2[2048]; // 0x804ea3b
    int32_t v3 = __readgsdword(20); // 0x804e80f
    int32_t str7; // bp-2064, 0x804e7f3
    sprintf((char *)&str7, "%s/docs/html/index.html", gisbase);
    struct _IO_FILE * file = fopen((char *)&str7, "r"); // 0x804e84d
    if (file != NULL) {
        // 0x804e8b0
        memcpy((int32_t *)&TMP_HTML, (int32_t *)"/tmp/grass.extensions.db.XXXXXX", 32);
        mkstemp(TMP_HTML);
        struct _IO_FILE * file2 = fopen(TMP_HTML, "w+"); // 0x804e8ea
        if (file2 == NULL) {
            char * err_str = strerror(*__errno_location()); // 0x804e908
            print_error(-24, "could not create temp file '%s': %s\n \t\tMake sure that directory /tmp exists on your system and you have write permission.\n", TMP_HTML, err_str);
            // UNREACHABLE
        }
        // 0x804e92d
        atexit(0x8048fc2);
        int32_t str8; // bp-4112, 0x804e7f3
        if (VERBOSE == 0) {
            // 0x804e977
            sprintf((char *)&str8, "cp -f %s %s/docs/html/index.html &>%s ; chmod a+r %s/docs/html/index.html &>%s ;", TMP_HTML, gisbase, TMP_NULL, gisbase, TMP_NULL);
        } else {
            // 0x804e942
            sprintf((char *)&str8, "cp -vf %s %s/docs/html/index.html ; chmod -v a+r %s/docs/html/index.html ;", TMP_HTML, gisbase, gisbase);
        }
        // 0x804e9ba
        strcpy(HTML_CMD, (char *)&str8);
        str = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
        char * str3 = fgets((char *)&str8, 2048, file); // 0x804e9fe
        int32_t v4 = *(int32_t *)&str;
        int32_t v5 = v4; // 0x804ea05
        if (str3 != NULL) {
            v1[0] = (char)v4 + 1;
            str = v1;
            char * str4 = fgets((char *)&str8, 2048, file); // 0x804e9fe
            int32_t v6 = *(int32_t *)&str;
            v5 = v6;
            while (str4 != NULL) {
                // 0x804e9dc
                v1[0] = (char)v6 + 1;
                str = v1;
                str4 = fgets((char *)&str8, 2048, file);
                v6 = *(int32_t *)&str;
                v5 = v6;
            }
        }
        // 0x804ea07
        if (v5 != 0) {
            // 0x804ea14
            rewind(file);
            int32_t nmemb = v5 + 10;
            int32_t * mem = calloc(nmemb, 4); // 0x804ea36
            v2[0] = (int32_t)mem;
            str2 = v2;
            int32_t v7 = 0; // 0x804ea78
            if (nmemb > 0) {
                *(int32_t *)(*(int32_t *)&str2 + 4 * v7) = 0;
                int32_t v8 = v7 + 1; // 0x804ea62
                v7 = v8;
                while (*(int32_t *)&str + 10 > v8) {
                    // 0x804ea4d
                    *(int32_t *)(*(int32_t *)&str2 + 4 * v7) = 0;
                    v8 = v7 + 1;
                    v7 = v8;
                }
            }
            char * str5 = fgets((char *)&str8, 2048, file); // 0x804eaf7
            int32_t v9 = *(int32_t *)&str2;
            int32_t v10 = v9; // 0x804eafe
            if (str5 != NULL) {
                int32_t v11 = (int32_t)NULL; // 0x804ea86
                int32_t v12 = 4 * v11; // 0x804ea8c
                int32_t * mem2 = malloc(strlen((char *)&str8) + 1); // 0x804eaab
                *(int32_t *)(v12 + v9) = (int32_t)mem2;
                int32_t v13 = *(int32_t *)&str2; // 0x804eac1
                strcpy((char *)*(int32_t *)(v13 + v12), (char *)&str8);
                char * str6 = fgets((char *)&str8, 2048, file); // 0x804eaf7
                int32_t v14 = v13; // 0x804eafe
                char ** v15 = (char **)(v11 + 1); // 0x804eafe
                v10 = v13;
                while (str6 != NULL) {
                    // 0x804ea86
                    v11 = (int32_t)v15;
                    v12 = 4 * v11;
                    mem2 = malloc(strlen((char *)&str8) + 1);
                    *(int32_t *)(v12 + v14) = (int32_t)mem2;
                    v13 = *(int32_t *)&str2;
                    strcpy((char *)*(int32_t *)(v13 + v12), (char *)&str8);
                    str6 = fgets((char *)&str8, 2048, file);
                    v14 = v13;
                    v15 = (char **)(v11 + 1);
                    v10 = v13;
                }
            }
            // 0x804eb00
            new_ext_html(pkg_short_name, gisbase, (char **)v10, major, minor, revision);
            int32_t * v16 = (int32_t *)v10;
            int32_t format = *v16; // 0x804eb7c
            if (format != 0) {
                fprintf(file2, (char *)format);
                int32_t v17 = 1; // 0x804eb66
                int32_t v18 = *(int32_t *)(4 * v17 + v10); // 0x804eb7c
                int32_t format2 = v18; // 0x804eb80
                int32_t v19 = v17; // 0x804eb80
                while (v18 != 0) {
                    // 0x804eb43
                    fprintf(file2, (char *)format2);
                    v17 = v19 + 1;
                    v18 = *(int32_t *)(4 * v17 + v10);
                    format2 = v18;
                    v19 = v17;
                }
            }
            // 0x804eb82
            fflush(file2);
            fclose(file);
            fclose(file2);
            int32_t v20 = *(int32_t *)&str + 10;
            int32_t v21 = 0; // 0x804ebe7
            if (v20 > 0) {
                free((int32_t *)*(int32_t *)(4 * v21 + v10));
                int32_t v22 = v21 + 1; // 0x804ebd1
                v21 = v22;
                while (v22 != v20) {
                    // 0x804ebb8
                    free((int32_t *)*(int32_t *)(4 * v21 + v10));
                    v22 = v21 + 1;
                    v21 = v22;
                }
            }
            // 0x804ebe9
            free(v16);
        }
    } else {
        // 0x804e861
        if (*__errno_location() != 2) {
            // 0x804e871
            fclose(file);
            char * err_str2 = strerror(*__errno_location()); // 0x804e889
            print_error(-24, "checking for file '%s': %s\n", &str7, err_str2);
            // UNREACHABLE
        }
    }
    // 0x804ebfd
    if (v3 != __readgsdword(20)) {
        // 0x804ec09
        __stack_chk_fail();
    }
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/reg_html.c
// Address range: 0x804ec17 - 0x804f026
// Line range:    271 - 368
void deregister_html(char * pkg_short_name, char * gisbase) {
    char str2[2048]; // bp-4116, 0x804ec17
    char str[2048]; // bp-4120, 0x804ec17
    char v1[2048]; // 0x804ee00
    char v2[2048]; // 0x804ee5f
    int32_t v3 = __readgsdword(20); // 0x804ec33
    int32_t str7; // bp-2064, 0x804ec17
    sprintf((char *)&str7, "%s/docs/html/index.html", gisbase);
    struct _IO_FILE * file = fopen((char *)&str7, "r"); // 0x804ec71
    if (file != NULL) {
        // 0x804ecd4
        memcpy((int32_t *)&TMP_HTML, (int32_t *)"/tmp/grass.extensions.db.XXXXXX", 32);
        mkstemp(TMP_HTML);
        struct _IO_FILE * file2 = fopen(TMP_HTML, "w+"); // 0x804ed0e
        if (file2 == NULL) {
            char * err_str = strerror(*__errno_location()); // 0x804ed2c
            print_error(-24, "could not create temp file '%s': %s\n \t\tMake sure that directory /tmp exists on your system and you have write permission.\n", TMP_HTML, err_str);
            // UNREACHABLE
        }
        // 0x804ed51
        atexit(0x8048fc2);
        int32_t str8; // bp-4112, 0x804ec17
        if (VERBOSE == 0) {
            // 0x804ed9b
            sprintf((char *)&str8, "cp -f %s %s/docs/html/index.html &>%s ; chmod a+r %s/docs/html/index.html &>%s ;", TMP_HTML, gisbase, TMP_NULL, gisbase, TMP_NULL);
        } else {
            // 0x804ed66
            sprintf((char *)&str8, "cp -vf %s %s/docs/html/index.html ; chmod -v a+r %s/docs/html/index.html ;", TMP_HTML, gisbase, gisbase);
        }
        // 0x804edde
        strcpy(HTML_CMD, (char *)&str8);
        str = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
        char * str3 = fgets((char *)&str8, 2048, file); // 0x804ee22
        int32_t v4 = *(int32_t *)&str;
        int32_t v5 = v4; // 0x804ee29
        if (str3 != NULL) {
            v1[0] = (char)v4 + 1;
            str = v1;
            char * str4 = fgets((char *)&str8, 2048, file); // 0x804ee22
            int32_t v6 = *(int32_t *)&str;
            v5 = v6;
            while (str4 != NULL) {
                // 0x804ee00
                v1[0] = (char)v6 + 1;
                str = v1;
                str4 = fgets((char *)&str8, 2048, file);
                v6 = *(int32_t *)&str;
                v5 = v6;
            }
        }
        // 0x804ee2b
        if (v5 != 0) {
            // 0x804ee38
            rewind(file);
            int32_t nmemb = v5 + 1;
            int32_t * mem = calloc(nmemb, 4); // 0x804ee5a
            v2[0] = (int32_t)mem;
            str2 = v2;
            int32_t v7 = 0; // 0x804ee9c
            if (nmemb > 0) {
                *(int32_t *)(*(int32_t *)&str2 + 4 * v7) = 0;
                int32_t v8 = v7 + 1; // 0x804ee86
                v7 = v8;
                while (*(int32_t *)&str + 1 > v8) {
                    // 0x804ee71
                    *(int32_t *)(*(int32_t *)&str2 + 4 * v7) = 0;
                    v8 = v7 + 1;
                    v7 = v8;
                }
            }
            char * str5 = fgets((char *)&str8, 2048, file); // 0x804ef1b
            int32_t v9 = *(int32_t *)&str2;
            int32_t v10 = v9; // 0x804ef22
            if (str5 != NULL) {
                int32_t v11 = (int32_t)NULL; // 0x804eeaa
                int32_t v12 = 4 * v11; // 0x804eeb0
                int32_t * mem2 = malloc(strlen((char *)&str8) + 1); // 0x804eecf
                *(int32_t *)(v12 + v9) = (int32_t)mem2;
                int32_t v13 = *(int32_t *)&str2; // 0x804eee5
                strcpy((char *)*(int32_t *)(v13 + v12), (char *)&str8);
                char * str6 = fgets((char *)&str8, 2048, file); // 0x804ef1b
                int32_t v14 = v13; // 0x804ef22
                char ** v15 = (char **)(v11 + 1); // 0x804ef22
                v10 = v13;
                while (str6 != NULL) {
                    // 0x804eeaa
                    v11 = (int32_t)v15;
                    v12 = 4 * v11;
                    mem2 = malloc(strlen((char *)&str8) + 1);
                    *(int32_t *)(v12 + v14) = (int32_t)mem2;
                    v13 = *(int32_t *)&str2;
                    strcpy((char *)*(int32_t *)(v13 + v12), (char *)&str8);
                    str6 = fgets((char *)&str8, 2048, file);
                    v14 = v13;
                    v15 = (char **)(v11 + 1);
                    v10 = v13;
                }
            }
            // 0x804ef24
            delete_ext_html(pkg_short_name, gisbase, (char **)v10);
            int32_t * v16 = (int32_t *)v10;
            int32_t format = *v16; // 0x804ef8b
            if (format != 0) {
                fprintf(file2, (char *)format);
                int32_t v17 = 1; // 0x804ef75
                int32_t v18 = *(int32_t *)(4 * v17 + v10); // 0x804ef8b
                int32_t format2 = v18; // 0x804ef8f
                int32_t v19 = v17; // 0x804ef8f
                while (v18 != 0) {
                    // 0x804ef52
                    fprintf(file2, (char *)format2);
                    v17 = v19 + 1;
                    v18 = *(int32_t *)(4 * v17 + v10);
                    format2 = v18;
                    v19 = v17;
                }
            }
            // 0x804ef91
            fflush(file2);
            fclose(file);
            fclose(file2);
            int32_t v20 = *(int32_t *)&str + 1;
            int32_t v21 = 0; // 0x804eff6
            if (v20 > 0) {
                free((int32_t *)*(int32_t *)(4 * v21 + v10));
                int32_t v22 = v21 + 1; // 0x804efe0
                v21 = v22;
                while (v22 != v20) {
                    // 0x804efc7
                    free((int32_t *)*(int32_t *)(4 * v21 + v10));
                    v22 = v21 + 1;
                    v21 = v22;
                }
            }
            // 0x804eff8
            free(v16);
        }
    } else {
        // 0x804ec85
        if (*__errno_location() != 2) {
            // 0x804ec95
            fclose(file);
            char * err_str2 = strerror(*__errno_location()); // 0x804ecad
            print_error(-24, "checking for file '%s': %s\n", &str7, err_str2);
            // UNREACHABLE
        }
    }
    // 0x804f00c
    if (v3 != __readgsdword(20)) {
        // 0x804f018
        __stack_chk_fail();
    }
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/reg_html.c
// Address range: 0x804f026 - 0x804f7e5
// Line range:    374 - 549
int32_t restore_html(char * gisbase) {
    char subdir[2048]; // bp-10260, 0x804f026
    char v1[2048]; // 0x804f3ad
    int32_t v2 = __readgsdword(20); // 0x804f039
    int32_t str5; // bp-4112, 0x804f026
    sprintf((char *)&str5, "%s/docs/html/index.html", gisbase);
    struct _IO_FILE * file = fopen((char *)&str5, "r"); // 0x804f077
    int32_t v3; // 0x804f026
    if (file != NULL) {
        // 0x804f0e0
        memcpy((int32_t *)&TMP_HTML, (int32_t *)"/tmp/grass.extensions.db.XXXXXX", 32);
        mkstemp(TMP_HTML);
        struct _IO_FILE * file2 = fopen(TMP_HTML, "w+"); // 0x804f11a
        if (file2 == NULL) {
            char * err_str = strerror(*__errno_location()); // 0x804f138
            print_error(-24, "could not create temp file '%s': %s\n \t\tMake sure that directory /tmp exists on your system and you have write permission.\n", TMP_HTML, err_str);
            // UNREACHABLE
        }
        // 0x804f15d
        int32_t str6; // bp-2064, 0x804f026
        if (VERBOSE == 0) {
            // 0x804f19b
            sprintf((char *)&str6, "cp -f %s %s/docs/html/index.html &>%s ; chmod a+r %s/docs/html/index.html &>%s ;", TMP_HTML, gisbase, TMP_NULL, gisbase, TMP_NULL);
        } else {
            // 0x804f166
            sprintf((char *)&str6, "cp -vf %s %s/docs/html/index.html ; chmod -v a+r %s/docs/html/index.html ;", TMP_HTML, gisbase, gisbase);
        }
        // 0x804f1de
        strcpy(HTML_CMD, (char *)&str6);
        atexit(0x8048fc2);
        int32_t str7; // bp-8208, 0x804f026
        sprintf((char *)&str7, "%s/docs/extensions", gisbase);
        struct __dirstream * dirp = opendir((char *)&str7); // 0x804f22a
        v3 = 0;
        if (dirp != NULL) {
            struct dirent * v4 = readdir(dirp); // 0x804f30d
            int32_t v5 = 0; // 0x804f31f
            int32_t str8; // bp-10256, 0x804f026
            if (v4 != NULL) {
                int32_t v6 = 0;
                struct dirent * v7 = v4; // 0x804f30d
                char * str9; // 0x804f28a
                struct __dirstream * dirp2; // 0x804f2d2
                while (true) {
                    // 0x804f261
                    str9 = (char *)((int32_t)v7 + 11);
                    sprintf((char *)&str8, "%s/%s", &str7, str9);
                    if (strcmp(str9, ".") != 0) {
                        // 0x804f2ac
                        if (strcmp(str9, "..") != 0) {
                            // 0x804f2c9
                            dirp2 = opendir((char *)&str8);
                            if (dirp2 != NULL) {
                                // break -> 0x804f2e6
                                break;
                            }
                        }
                    }
                    // 0x804f304
                    v7 = readdir(dirp);
                    v5 = v6;
                    if (v7 == NULL) {
                        // break (via goto) -> 0x804f325
                        goto lab_0x804f325;
                    }
                }
                int32_t v8 = v6 + 1; // 0x804f2e6
                closedir(dirp2);
                struct dirent * v9 = readdir(dirp); // 0x804f30d
                v5 = v8;
                while (v9 != NULL) {
                    // 0x804f261
                    v6 = v8;
                    v7 = v9;
                    while (true) {
                        // 0x804f261
                        str9 = (char *)((int32_t)v7 + 11);
                        sprintf((char *)&str8, "%s/%s", &str7, str9);
                        if (strcmp(str9, ".") != 0) {
                            // 0x804f2ac
                            if (strcmp(str9, "..") != 0) {
                                // 0x804f2c9
                                dirp2 = opendir((char *)&str8);
                                if (dirp2 != NULL) {
                                    // break -> 0x804f2e6
                                    break;
                                }
                            }
                        }
                        // 0x804f304
                        v7 = readdir(dirp);
                        v5 = v6;
                        if (v7 == NULL) {
                            // break (via goto) -> 0x804f325
                            goto lab_0x804f325;
                        }
                    }
                    // 0x804f2e6
                    v8 = v6 + 1;
                    closedir(dirp2);
                    v9 = readdir(dirp);
                    v5 = v8;
                }
            }
          lab_0x804f325:
            // 0x804f325
            closedir(dirp);
            char * str = fgets((char *)&str6, 2048, file); // 0x804f361
            v3 = 0;
            if (str != NULL) {
                int32_t v10 = (int32_t)NULL + 1; // 0x804f33f
                char * str2 = fgets((char *)&str6, 2048, file); // 0x804f361
                char ** v11 = (char **)v10; // 0x804f368
                while (str2 != NULL) {
                    // 0x804f33f
                    v10 = (int32_t)v11 + 1;
                    str2 = fgets((char *)&str6, 2048, file);
                    v11 = (char **)v10;
                }
                // 0x804f36a
                v3 = 0;
                if (v10 != 0) {
                    // 0x804f37d
                    rewind(file);
                    int32_t nmemb = v5 + 10 + v10; // 0x804f39a
                    int32_t * mem = calloc(nmemb, 4); // 0x804f3a8
                    v1[0] = (int32_t)mem;
                    subdir = v1;
                    int32_t v12 = 0; // 0x804f3f3
                    if (nmemb > 0) {
                        *(int32_t *)(*(int32_t *)&subdir + 4 * v12) = 0;
                        int32_t v13 = v12 + 1; // 0x804f3d4
                        v12 = v13;
                        while (v13 != nmemb) {
                            // 0x804f3bf
                            *(int32_t *)(*(int32_t *)&subdir + 4 * v12) = 0;
                            v13 = v12 + 1;
                            v12 = v13;
                        }
                    }
                    char * str3 = fgets((char *)&str6, 2048, file); // 0x804f472
                    int32_t v14 = *(int32_t *)&subdir;
                    int32_t v15 = v14; // 0x804f479
                    if (str3 != NULL) {
                        *(int32_t *)v14 = (int32_t)malloc(strlen((char *)&str6) + 1);
                        int32_t str10 = *(int32_t *)&subdir;
                        strcpy((char *)*(int32_t *)str10, (char *)&str6);
                        int32_t v16 = 1; // 0x804f450
                        char * str4 = fgets((char *)&str6, 2048, file); // 0x804f472
                        int32_t v17 = 4 * v16;
                        int32_t v18 = str10 + v17;
                        int32_t v19 = v18; // 0x804f479
                        int32_t v20 = v17; // 0x804f479
                        int32_t v21 = v16; // 0x804f479
                        v15 = v18;
                        while (str4 != NULL) {
                            int32_t * mem2 = malloc(strlen((char *)&str6) + 1); // 0x804f426
                            *(int32_t *)v19 = (int32_t)mem2;
                            str10 = *(int32_t *)&subdir;
                            strcpy((char *)*(int32_t *)(str10 + v20), (char *)&str6);
                            v16 = v21 + 1;
                            str4 = fgets((char *)&str6, 2048, file);
                            v17 = 4 * v16;
                            v18 = str10 + v17;
                            v19 = v18;
                            v20 = v17;
                            v21 = v16;
                            v15 = v18;
                        }
                    }
                    // 0x804f47b
                    *(int32_t *)v15 = 0;
                    struct __dirstream * dirp3 = opendir((char *)&str7); // 0x804f499
                    struct dirent * v22 = readdir(dirp3); // 0x804f6d6
                    int32_t v23; // 0x804f026
                    int32_t v24; // 0x804f026
                    if (v22 != NULL) {
                        int32_t v25 = *(int32_t *)&subdir;
                        struct dirent * v26 = v22; // 0x804f6d6
                        int32_t v27 = 0; // 0x804f6a9
                        while (true) {
                            int32_t v28 = v27;
                            struct dirent * v29 = v26; // 0x804f6d6
                            int32_t major; // bp-10316, 0x804f026
                            int32_t n_subdirs; // bp-10312, 0x804f026
                            int32_t num_restored; // bp-10308, 0x804f026
                            char * str11; // 0x804f026
                            struct _IO_FILE * file3; // 0x804f585
                            while (true) {
                                // 0x804f4b3
                                str11 = (char *)((int32_t)v29 + 11);
                                sprintf((char *)&str8, "%s/%s", &str7, str11);
                                if (strcmp(str11, ".") != 0) {
                                    // 0x804f502
                                    if (strcmp(str11, "..") != 0) {
                                        struct __dirstream * dirp4 = opendir((char *)&str8); // 0x804f52c
                                        if (dirp4 != NULL) {
                                            // 0x804f544
                                            closedir(dirp4);
                                            int32_t str12; // bp-6160, 0x804f026
                                            sprintf((char *)&str12, "%s/index.html", &str8);
                                            file3 = fopen((char *)&str12, "r");
                                            if (file3 != NULL) {
                                                // 0x804f59d
                                                num_restored = 0;
                                                n_subdirs = 0;
                                                major = 0;
                                                while (fgets((char *)&str6, 2048, file3) != NULL) {
                                                    // 0x804f5c7
                                                    if (strstr((char *)&str6, "<title>") != NULL) {
                                                        // break (via goto) -> 0x804f61e
                                                        goto lab_0x804f61e;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                // 0x804f6cd
                                v29 = readdir(dirp3);
                                v23 = v25;
                                v24 = v28;
                                if (v29 == NULL) {
                                    // break (via goto) -> 0x804f6ee
                                    goto lab_0x804f6ee;
                                }
                            }
                          lab_0x804f61e:;
                            char * found_char_pos = strchr((char *)&str6, 40); // 0x804f634
                            sscanf((char *)((int32_t)found_char_pos + 1), "%i.%i.%i", &num_restored, &n_subdirs, &major);
                            new_ext_html(str11, gisbase, (char **)v25, num_restored, n_subdirs, major);
                            v27 = v28 + 1;
                            fclose(file3);
                            v26 = readdir(dirp3);
                            v23 = v25;
                            v24 = v27;
                            if (v26 == NULL) {
                                // break -> 0x804f6ee
                                break;
                            }
                        }
                    } else {
                        // 0x804f47b
                        v23 = *(int32_t *)&subdir;
                        v24 = 0;
                    }
                  lab_0x804f6ee:
                    // 0x804f6ee
                    closedir(dirp3);
                    int32_t * v30 = (int32_t *)v23;
                    int32_t format = *v30; // 0x804f741
                    if (format != 0) {
                        fprintf(file2, (char *)format);
                        int32_t v31 = 1; // 0x804f72b
                        int32_t v32 = *(int32_t *)(4 * v31 + v23); // 0x804f741
                        int32_t format2 = v32; // 0x804f745
                        int32_t v33 = v31; // 0x804f745
                        while (v32 != 0) {
                            // 0x804f708
                            fprintf(file2, (char *)format2);
                            v31 = v33 + 1;
                            v32 = *(int32_t *)(4 * v31 + v23);
                            format2 = v32;
                            v33 = v31;
                        }
                    }
                    // 0x804f747
                    fflush(file2);
                    fclose(file);
                    fclose(file2);
                    int32_t v34 = 0; // 0x804f7b5
                    if (nmemb > 0) {
                        free((int32_t *)*(int32_t *)(4 * v34 + v23));
                        int32_t v35 = v34 + 1; // 0x804f796
                        v34 = v35;
                        while (v35 != nmemb) {
                            // 0x804f77d
                            free((int32_t *)*(int32_t *)(4 * v34 + v23));
                            v35 = v34 + 1;
                            v34 = v35;
                        }
                    }
                    // 0x804f7b7
                    free(v30);
                    v3 = v24;
                }
            }
        }
    } else {
        int32_t v36 = *__errno_location(); // 0x804f090
        v3 = 0;
        if (v36 != 2) {
            // 0x804f0a1
            fclose(file);
            char * err_str2 = strerror(*__errno_location()); // 0x804f0b9
            print_error(-24, "checking for file '%s': %s\n", &str5, err_str2);
            // UNREACHABLE
        }
    }
    int32_t result = v3; // 0x804f7d5
    if (v2 != __readgsdword(20)) {
        // 0x804f7d7
        __stack_chk_fail();
        result = &g18;
    }
    // 0x804f7dc
    return result;
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/actions.c
// Address range: 0x804f7e8 - 0x804faab
// Line range:    29 - 81
void check_extension(char * package, char * name, int32_t * major, int32_t * minor, int32_t * revision) {
    char tmp2[2048]; // bp-2068, 0x804f7e8
    char tmp[2048]; // bp-2072, 0x804f7e8
    char v1[2048]; // 0x804f9ab
    char v2[2048]; // 0x804fa40
    char v3[2048]; // 0x804f899
    char v4[2048]; // 0x804f8ef
    int32_t v5 = __readgsdword(20); // 0x804f820
    int32_t str = 0; // bp-2064, 0x804f82b
    int32_t v6; // bp-2060, 0x804f7e8
    __asm_rep_stosd_memset((char *)&v6, 0, 511);
    fwrite((int32_t *)"Checking extension ...", 1, 22, (struct _IO_FILE *)g12);
    strcpy((char *)&str, package);
    int32_t v7 = chdir((char *)&str); // 0x804f894
    v3[0] = v7;
    tmp2 = v3;
    if (*(int32_t *)&tmp2 < 0) {
        int32_t * err_num = __errno_location(); // 0x804f8a8
        print_error(-2, "extension '%s' not accessible: %s\n", package, strerror(*err_num));
        // UNREACHABLE
    }
    struct _IO_FILE * file = fopen("id", "r"); // 0x804f8ea
    v4[0] = (int32_t)file;
    tmp = v4;
    int32_t v8 = *(int32_t *)&tmp; // 0x804f8f5
    if (v8 == 0) {
        // 0x804f8fe
        print_error(-6, "'id' file not readable.\n");
        // UNREACHABLE
    }
    struct _IO_FILE * stream = (struct _IO_FILE *)v8;
    fscanf(stream, "%[<GRASS extension package>] ", &str);
    int32_t strcmp_rc = strcmp("<GRASS extension package>", (char *)&str); // 0x804f946
    fclose(stream);
    if (strcmp_rc != 0) {
        // 0x804f94f
        print_error(-6, "unknown file identifier.\n");
        // UNREACHABLE
    }
    // 0x804f971
    get_package_name(".", name);
    struct _IO_FILE * file2 = fopen("version", "r"); // 0x804f9a6
    v1[0] = (int32_t)file2;
    tmp = v1;
    int32_t v9 = *(int32_t *)&tmp; // 0x804f9b1
    if (v9 == 0) {
        // 0x804f9ba
        print_error(-6, "'version' file not readable.\n");
        // UNREACHABLE
    }
    struct _IO_FILE * file3 = (struct _IO_FILE *)v9;
    nc_fgets_nb((char *)&str, 2048, file3);
    *minor = 0;
    *revision = 0;
    int32_t items_assigned = sscanf((char *)&str, "%i.%i.%i", major, minor, revision); // 0x804fa3b
    v2[0] = items_assigned;
    tmp2 = v2;
    int32_t v10 = *(int32_t *)&tmp2; // 0x804fa46
    if (v10 >= 0 != v10 != 0) {
        // 0x804fa4f
        fclose(file3);
        print_error(-6, "invalid or missing version information.\n");
        // UNREACHABLE
    }
    // 0x804fa71
    print_done();
    chdir("..");
    fclose(file3);
    if (v5 != __readgsdword(20)) {
        // 0x804fa9c
        __stack_chk_fail();
    }
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/actions.c
// Address range: 0x804faab - 0x804ff43
// Line range:    88 - 198
void unpack_extension(char * package) {
    char tmp2[2048]; // bp-2068, 0x804faab
    char tmp[2048]; // bp-2072, 0x804faab
    char v1[2048]; // 0x804fc0f
    char v2[2048]; // 0x804fe97
    char v3[2048]; // 0x804fb35
    int32_t v4 = __readgsdword(20); // 0x804fabd
    fwrite((int32_t *)"Uncompressing files...", 1, 22, (struct _IO_FILE *)g12);
    memcpy((int32_t *)&TMPDIR, (int32_t *)"/tmp/grass.extension.XXXXXX", 28);
    mkstemp(TMPDIR);
    int32_t fd = open(TMPDIR, O_CREAT); // 0x804fb30
    v3[0] = fd;
    tmp = v3;
    int32_t fd2 = *(int32_t *)&tmp; // 0x804fb3b
    if (fd2 == -1) {
        int32_t err_num = *__errno_location(); // 0x804fb49
        print_error(-7, "could not create temp directory name: %s", strerror(err_num));
        // UNREACHABLE
    }
    // 0x804fb77
    if (VERBOSE != 0) {
        // 0x804fb80
        fprintf((struct _IO_FILE *)g12, "\nUncompressing to: %s.\n", TMPDIR);
    }
    // 0x804fb9e
    close(fd2);
    remove(TMPDIR);
    mkdir_s(TMPDIR, "0700");
    atexit(0x8048e89);
    int32_t str; // bp-2064, 0x804faab
    sprintf((char *)&str, "cp %s %s", package, TMPDIR);
    int32_t system_rc = system((char *)&str); // 0x804fc0a
    v1[0] = system_rc;
    tmp2 = v1;
    if (*(int32_t *)&tmp2 < 0) {
        // 0x804fc1e
        print_error(-7, "could not copy extension files to temp dir.\n");
        // UNREACHABLE
    }
    int32_t v5 = check_filetype(package); // 0x804fc47
    bool v6; // 0x804faab
    int32_t v7; // 0x804faab
    int32_t v8; // 0x804faab
    if (v5 != 0) {
        // 0x804fc71
        v7 = v5;
        v6 = true;
        v8 = v5;
        if (v5 != 1) {
            goto lab_0x804fcf7;
        } else {
            goto lab_0x804fc7a;
        }
    } else {
        // 0x804fc71
        print_warning("file name not '.tar.gz', '.tgz', '.tar.bz2', '.tbz' or '.zip'. Assuming '.tgz'.\n");
        v7 = 1;
        goto lab_0x804fc7a;
    }
  lab_0x804fcf7:
    // 0x804fcf7
    if (v8 == 2) {
        char * v9 = basename(package);
        sprintf((char *)&str, "tar -xjvf %s/%s -C %s", TMPDIR, v9, TMPDIR);
    }
    if (v8 == 3) {
        char * v10 = basename(package);
        if (VERBOSE == 0) {
            // 0x804fdca
            sprintf((char *)&str, "unzip -qq %s/%s -d %s", TMPDIR, v10, TMPDIR);
        } else {
            // 0x804fd8f
            sprintf((char *)&str, "unzip %s/%s -d %s", TMPDIR, v10, TMPDIR);
        }
    }
    if (v8 == 4) {
        char * v11 = basename(package);
        if (VERBOSE == 0) {
            // 0x804fe50
            sprintf((char *)&str, "tar -xf %s/%s -C %s", TMPDIR, v11, TMPDIR);
        } else {
            // 0x804fe15
            sprintf((char *)&str, "tar -xvf %s/%s -C %s", TMPDIR, v11, TMPDIR);
        }
    }
    int32_t system_rc2 = system((char *)&str); // 0x804fe92
    v2[0] = system_rc2;
    tmp2 = v2;
    if (*(int32_t *)&tmp2 >= 0) {
        // 0x804ff2b
        print_done();
        if (v4 != __readgsdword(20)) {
            // 0x804ff3c
            __stack_chk_fail();
        }
        // 0x804ff41
        return;
    }
    if (!v6) {
        // 0x804feb3
        print_error(-7, "could not extract files using 'tar' and 'gzip'. \n \t\t\t\t\tExtract manually using 'tar -xzvf %s'.\n", package);
        // UNREACHABLE
    }
    if (v8 == 2) {
        // 0x804feda
        print_error(-7, "could not extract files using 'tar' and 'bunzip2'.\n \t\t\t\tExtract manually using 'tar -xjvf %s'.\n", package);
        // UNREACHABLE
    }
    if (v8 != 3) {
        // 0x804ff1f
        exit(-7);
        // UNREACHABLE
    }
    // 0x804ff01
    print_error(-7, "could not extract files using 'unzip'.\n \t\t\t\tExtract manually using 'unzip %s'.\n", package);
    // UNREACHABLE
  lab_0x804fc7a:;
    char * v12 = basename(package);
    if (VERBOSE == 0) {
        // 0x804fcbe
        sprintf((char *)&str, "tar -xzf %s/%s -C %s", TMPDIR, v12, TMPDIR);
        v6 = false;
        v8 = v7;
    } else {
        // 0x804fc83
        sprintf((char *)&str, "tar -xzvf %s/%s -C %s", TMPDIR, v12, TMPDIR);
        v6 = false;
        v8 = v7;
    }
    goto lab_0x804fcf7;
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/actions.c
// Address range: 0x804ff43 - 0x805014e
// Line range:    201 - 235
void query_extension(char * package, char * name, int32_t major, int32_t minor, int32_t revision, char * short_name, char * invocation, char * org_name) {
    char tmp[2048]; // bp-2068, 0x804ff43
    char v1[2048]; // 0x804ffb2
    // 0x804ff43
    __readgsdword(20);
    int32_t str; // bp-2064, 0x804ff43
    strcpy((char *)&str, basename(package));
    int32_t v2 = chdir((char *)&str); // 0x804ffad
    v1[0] = v2;
    tmp = v1;
    if (*(int32_t *)&tmp < 0) {
        int32_t err_num = *__errno_location(); // 0x804ffc6
        print_error(-2, "extension '%s' not accessible: %s\n", package, strerror(err_num));
        // UNREACHABLE
    }
    // 0x804fff2
    fprintf((struct _IO_FILE *)g12, "\nExtension '%s', version %i.%i.%i\n\n", name, major, minor, revision);
    dump_ascii("description", "Description");
    dump_ascii("commands", "Commands provided");
    dump_ascii("libs", "Libraries provided");
    dump_ascii("headers", "Header files provided");
    dump_ascii("depends", "Dependencies");
    dump_ascii("bugs", "Bugs");
    sprintf((char *)&str, "../%s", package);
    list_binaries((char *)&str);
    dump_ascii("authors", "Author(s)");
    fprintf((struct _IO_FILE *)g12, "Type '%s -d %s' to see more detailed information.\n", invocation, org_name);
    fprintf((struct _IO_FILE *)g12, "Type '%s -l %s' to see copyright information.\n", invocation, org_name);
    system("sh post");
    exit(0);
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/actions.c
// Address range: 0x805014e - 0x8050220
// Line range:    242 - 258
void print_cfg(void) {
    char line[2048]; // bp-2068, 0x805014e
    char v1[2048]; // 0x8050178
    int32_t v2 = __readgsdword(20); // 0x8050157
    struct _IO_FILE * file = fopen("config.msg", "r"); // 0x8050173
    v1[0] = (int32_t)file;
    line = v1;
    int32_t v3 = *(int32_t *)&line; // 0x805017e
    if (v3 != 0) {
        // 0x8050187
        fwrite((int32_t *)"\nResult of configuration: \n", 1, 27, (struct _IO_FILE *)g12);
        struct _IO_FILE * stream = (struct _IO_FILE *)v3;
        int32_t str3; // bp-2064, 0x805014e
        char * str = fgets((char *)&str3, 2048, stream); // 0x80501e3
        struct _IO_FILE * stream3 = (struct _IO_FILE *)g12; // 0x80501ea
        if (str != NULL) {
            fputs((char *)&str3, (struct _IO_FILE *)g12);
            char * str2 = fgets((char *)&str3, 2048, stream); // 0x80501e3
            struct _IO_FILE * stream2 = (struct _IO_FILE *)g12; // 0x80501ea
            stream3 = (struct _IO_FILE *)g12;
            while (str2 != NULL) {
                // 0x80501b1
                fputs((char *)&str3, stream2);
                str2 = fgets((char *)&str3, 2048, stream);
                stream2 = (struct _IO_FILE *)g12;
                stream3 = (struct _IO_FILE *)g12;
            }
        }
        // 0x80501ec
        fputc(10, stream3);
    }
    // 0x8050201
    remove("config.msg");
    if (v2 != __readgsdword(20)) {
        // 0x8050219
        __stack_chk_fail();
    }
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/actions.c
// Address range: 0x8050220 - 0x8050c67
// Line range:    263 - 469
void source_install(char * package, char * gisbase, char * pkg_short_name, int32_t pkg_major, int32_t pkg_minor, int32_t pkg_revision, char * grass_version) {
    char v1[2048]; // 0x8050220
    char v2[2048]; // 0x8050220
    char sysstr[2048]; // bp-10260, 0x8050220
    char sysstr2[2048]; // bp-10264, 0x8050220
    char v3[2048]; // 0x80504b8
    char v4[2048]; // 0x80508bc
    char v5[2048]; // 0x8050270
    char v6[2048]; // 0x8050857
    char v7[2048]; // 0x80505d8
    char v8[2048]; // 0x805056b
    char v9[2048]; // 0x8050950
    int32_t v10 = __readgsdword(20); // 0x805024d
    int32_t buf; // bp-10380, 0x8050220
    int32_t v11 = stat((int32_t *)gisbase, &buf); // 0x805026b
    v5[0] = v11;
    sysstr = v5;
    if (*(int32_t *)&sysstr < 0) {
        int32_t err_num = *__errno_location(); // 0x8050284
        print_error(-5, "installation directory invalid: %s\n", strerror(err_num));
        // UNREACHABLE
    }
    // 0x80502a6
    sprintf(GINSTALL_DST, "GINSTALL_DST=%s", gisbase);
    putenv(GINSTALL_DST);
    int32_t str; // bp-2064, 0x8050220
    sprintf((char *)&str, "%s/include", gisbase);
    sprintf(GINSTALL_INC, "GINSTALL_INC=%s", &str);
    putenv(GINSTALL_INC);
    sprintf((char *)&str, "%s/lib", gisbase);
    sprintf(GINSTALL_LIB, "GINSTALL_LIB=%s", &str);
    putenv(GINSTALL_LIB);
    sprintf(GEM_GRASS_DIR, "GEM_GRASS_DIR=%s", gisbase);
    putenv(GEM_GRASS_DIR);
    char * str2 = strdup(grass_version); // 0x805039d
    char * next_token = strtok(str2, "."); // 0x80503ba
    char * next_token2 = strtok(NULL, "."); // 0x80503d5
    char * next_token3 = strtok(NULL, "."); // 0x80503f0
    int32_t str_as_l = strtol(next_token, NULL, 10); // 0x8050414
    int32_t str_as_l2 = strtol(next_token2, NULL, 10); // 0x8050438
    strtol(next_token3, NULL, 10);
    free((int32_t *)str2);
    atexit(0x8048e89);
    int32_t str3; // bp-4112, 0x8050220
    sprintf((char *)&str3, "%s/src", basename(package));
    int32_t v12 = chdir((char *)&str3); // 0x80504b3
    v3[0] = v12;
    sysstr = v3;
    if (*(int32_t *)&sysstr < 0) {
        int32_t err_num2 = *__errno_location(); // 0x80504cc
        print_error(-2, "extension files in '%s' not accessible: %s\n", package, strerror(err_num2));
        // UNREACHABLE
    }
    // 0x80504f8
    int32_t str4; // bp-10256, 0x8050220
    if (SKIP_CFG == 0) {
        // 0x8050505
        if (VERBOSE == 0) {
            // 0x8050573
            fwrite((int32_t *)"Configuring...", 1, 14, (struct _IO_FILE *)g12);
            sprintf((char *)&str4, "sh %s %s --quiet &> %s", CONFIG_CMD, CONFIG_OPTS, TMP_NULL);
            int32_t system_rc = system((char *)&str4); // 0x80505d3
            v7[0] = system_rc;
            v2 = v7;
        } else {
            // 0x805050e
            fwrite((int32_t *)"Running configure script:\n", 1, 26, (struct _IO_FILE *)g12);
            sprintf((char *)&str4, "sh %s %s", CONFIG_CMD, CONFIG_OPTS);
            int32_t system_rc2 = system((char *)&str4); // 0x8050566
            v8[0] = system_rc2;
            v2 = v8;
        }
        // 0x80505de
        sysstr = v2;
        uint32_t v13 = *(int32_t *)&sysstr; // 0x80505de
        if (v13 == -1) {
            // 0x80505e7
            print_error(-27, "could not run configure script.\n");
            // UNREACHABLE
        }
        if (v13 >= 1) {
            // 0x8050604
            print_error(-3, "system configuration failed.\n");
            // UNREACHABLE
        }
        // 0x8050618
        print_done();
        print_cfg();
    }
    // 0x8050622
    sprintf(GEM_EXT_NAME, "GEM_EXT_NAME=%s", pkg_short_name);
    putenv(GEM_EXT_NAME);
    sprintf((char *)&str, "%i.%i.%i", pkg_major, pkg_minor, pkg_revision);
    sprintf(GEM_EXT_VERSION, "GEM_EXT_VERSION=%s", &str);
    putenv(GEM_EXT_VERSION);
    dump_html("../description", TMP_DESCR);
    dump_html("../info", TMP_INFO);
    dump_html("../depends", TMP_DEPS);
    dump_html("../bugs", TMP_BUGS);
    dump_html("../authors", TMP_AUTHORS);
    sprintf(GEM_EXT_DESCR, "GEM_EXT_DESCR=%s", TMP_DESCR);
    putenv(GEM_EXT_DESCR);
    sprintf(GEM_EXT_INFO, "GEM_EXT_INFO=%s", TMP_INFO);
    putenv(GEM_EXT_INFO);
    sprintf(GEM_EXT_DEPS, "GEM_EXT_DEPS=%s", TMP_DEPS);
    putenv(GEM_EXT_DEPS);
    sprintf(GEM_EXT_BUGS, "GEM_EXT_BUGS=%s", TMP_BUGS);
    putenv(GEM_EXT_BUGS);
    sprintf(GEM_EXT_AUTHORS, "GEM_EXT_AUTHORS=%s", TMP_AUTHORS);
    putenv(GEM_EXT_AUTHORS);
    atexit(0x8048e89);
    check_dependencies(package, gisbase, grass_version);
    if (VERBOSE == 0) {
        // 0x805085f
        fwrite((int32_t *)"Compiling...", 1, 12, (struct _IO_FILE *)g12);
        sprintf((char *)&str4, "%s -f Makefile &> %s", MAKE_CMD, TMP_NULL);
        int32_t system_rc3 = system((char *)&str4); // 0x80508b7
        v4[0] = system_rc3;
        v1 = v4;
    } else {
        // 0x805080c
        fprintf((struct _IO_FILE *)g12, "Running '%s':\n", MAKE_CMD);
        sprintf((char *)&str4, "%s -f Makefile", MAKE_CMD);
        int32_t system_rc4 = system((char *)&str4); // 0x8050852
        v6[0] = system_rc4;
        v1 = v6;
    }
    // 0x80508c2
    sysstr = v1;
    uint32_t v14 = *(int32_t *)&sysstr;
    if (v14 == -1) {
        // 0x80508cb
        if (VERBOSE == 0) {
            // 0x80508d4
            print_error(-9, "could not run '%s' do you have make tools installed?\n", MAKE_CMD);
            // UNREACHABLE
        }
    }
    if (v14 >= 1) {
        // 0x80508f9
        print_error(-4, "source code could not be compiled.\n \t\t\tRun again with option -v to see what is causing trouble.\n");
        // UNREACHABLE
    }
    // 0x805090d
    print_done();
    fwrite((int32_t *)"Installing...", 1, 13, (struct _IO_FILE *)g12);
    struct _IO_FILE * file = fopen("../uninstall", "r"); // 0x805094b
    v9[0] = (int32_t)file;
    sysstr2 = v9;
    int32_t file2 = *(int32_t *)&sysstr2; // 0x8050956
    if (file2 != 0) {
        // 0x8050983
        if (VERBOSE == 0) {
            // 0x80509cf
            sprintf((char *)&str, "cp -f ../uninstall %s/etc/uninstall.%s &> %s ;", gisbase, pkg_short_name, TMP_NULL);
            strcpy(UNINSTALL_CMD, (char *)&str);
        } else {
            // 0x805098c
            sprintf((char *)&str, "cp -vf ../uninstall %s/etc/uninstall.%s ;", gisbase, pkg_short_name);
            strcpy(UNINSTALL_CMD, (char *)&str);
        }
        // 0x8050a18
        fclose((struct _IO_FILE *)file2);
    } else {
        int32_t err_num3 = *__errno_location(); // 0x8050964
        print_warning("error checking for uninstall script: %s\n \t\t\t\tUninstalling this extension may leave orphaned files on your system", strerror(err_num3));
    }
    // 0x8050a26
    register_extension(gisbase, "src", pkg_short_name, pkg_major, pkg_minor, pkg_revision);
    check_dependencies(package, gisbase, grass_version);
    if ((char *)str_as_l == (char *)6) {
        if (str_as_l2 >= 0 != str_as_l2 != 0) {
            // 0x8050a8f
            register_entries_gisman(pkg_short_name, gisbase);
        }
    }
    // 0x8050aa7
    register_entries_gisman2(pkg_short_name, gisbase);
    register_html(pkg_short_name, gisbase, pkg_major, pkg_minor, pkg_revision);
    int32_t str5; // bp-6160, 0x8050220
    if (VERBOSE == 0) {
        // 0x8050b50
        sprintf((char *)&str5, "%s -f Makefile -s install &> %s ; \t\t\t\t\tcp -f %s %s/etc/extensions.db &> %s ; chmod a+r %s/etc/extensions.db &> %s ;", MAKE_CMD, TMP_NULL, TMPDB, gisbase, TMP_NULL, gisbase, TMP_NULL);
    } else {
        // 0x8050af5
        fprintf((struct _IO_FILE *)g12, "Running '%s install':\n", MAKE_CMD);
        sprintf((char *)&str5, "%s -f Makefile install ; \t\t\t\t\tcp -vf %s %s/etc/extensions.db ; chmod -v a+r %s/etc/extensions.db ;", MAKE_CMD, TMPDB, gisbase, gisbase);
    }
    // 0x8050ba3
    int32_t str6; // bp-8208, 0x8050220
    if (VERBOSE == 0) {
        // 0x8050bcd
        sprintf((char *)&str6, "sh ../post &> %s", TMP_NULL);
    } else {
        // 0x8050bac
        memcpy(&str6, (int32_t *)"sh ../post", 11);
    }
    // 0x8050bec
    sprintf((char *)&str, "%s %s %s %s %s %s", &str5, UNINSTALL_CMD, GISMAN_CMD, GISMAN2_CMD, HTML_CMD, &str6);
    su(gisbase, (char *)&str);
    print_done();
    if (v10 != __readgsdword(20)) {
        // 0x8050c60
        __stack_chk_fail();
    }
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/actions.c
// Address range: 0x8050c67 - 0x805148a
// Line range:    475 - 633
void bin_install(char * package, char * gisbase, char * bins, char * pkg_short_name, int32_t pkg_major, int32_t pkg_minor, int32_t pkg_revision, char * grass_version) {
    char post_cmd[2048]; // bp-8212, 0x8050c67
    char post_cmd2[2048]; // bp-8216, 0x8050c67
    char v1[2048]; // 0x8050f12
    char v2[2048]; // 0x8051171
    char v3[2048]; // 0x8050cc0
    int32_t v4 = __readgsdword(20); // 0x8050c9d
    int32_t buf; // bp-8332, 0x8050c67
    int32_t v5 = stat((int32_t *)gisbase, &buf); // 0x8050cbb
    v3[0] = v5;
    post_cmd = v3;
    if (*(int32_t *)&post_cmd < 0) {
        int32_t err_num = *__errno_location(); // 0x8050cd4
        print_error(-5, "installation directory invalid: %s\n", strerror(err_num));
        // UNREACHABLE
    }
    // 0x8050cf6
    sprintf(GINSTALL_DST, "GINSTALL_DST=%s", gisbase);
    putenv(GINSTALL_DST);
    int32_t str; // bp-2064, 0x8050c67
    sprintf((char *)&str, "%s/include", gisbase);
    sprintf(GINSTALL_INC, "GINSTALL_INC=%s", &str);
    putenv(GINSTALL_INC);
    sprintf((char *)&str, "%s/lib", gisbase);
    sprintf(GINSTALL_LIB, "GINSTALL_LIB=%s", &str);
    putenv(GINSTALL_LIB);
    sprintf(GEM_GRASS_DIR, "GEM_GRASS_DIR=%s", gisbase);
    putenv(GEM_GRASS_DIR);
    char * str2 = strdup(grass_version); // 0x8050ded
    char * next_token = strtok(str2, "."); // 0x8050e0a
    char * next_token2 = strtok(NULL, "."); // 0x8050e25
    char * next_token3 = strtok(NULL, "."); // 0x8050e40
    int32_t str_as_l = strtol(next_token, NULL, 10); // 0x8050e64
    int32_t str_as_l2 = strtol(next_token2, NULL, 10); // 0x8050e88
    strtol(next_token3, NULL, 10);
    free((int32_t *)str2);
    atexit(0x8048e89);
    int32_t str3; // bp-4112, 0x8050c67
    sprintf((char *)&str3, "%s/%s", basename(package), bins);
    int32_t v6 = chdir((char *)&str3); // 0x8050f0d
    v1[0] = v6;
    post_cmd = v1;
    if (*(int32_t *)&post_cmd < 0) {
        int32_t err_num2 = *__errno_location(); // 0x8050f26
        print_error(-2, "extension file binaries in '%s' not accessible: %s\n", package, strerror(err_num2));
        // UNREACHABLE
    }
    // 0x8050f52
    sprintf(GEM_EXT_NAME, "GEM_EXT_NAME=%s", pkg_short_name);
    putenv(GEM_EXT_NAME);
    sprintf((char *)&str, "%i.%i.%i", pkg_major, pkg_minor, pkg_revision);
    sprintf(GEM_EXT_VERSION, "GEM_EXT_VERSION=%s", &str);
    putenv(GEM_EXT_VERSION);
    dump_html("../description", TMP_DESCR);
    dump_html("../info", TMP_INFO);
    dump_html("../depends", TMP_DEPS);
    dump_html("../bugs", TMP_BUGS);
    dump_html("../authors", TMP_AUTHORS);
    sprintf(GEM_EXT_DESCR, "GEM_EXT_DESCR=%s", TMP_DESCR);
    putenv(GEM_EXT_DESCR);
    sprintf(GEM_EXT_INFO, "GEM_EXT_INFO=%s", TMP_INFO);
    putenv(GEM_EXT_INFO);
    sprintf(GEM_EXT_DEPS, "GEM_EXT_DEPS=%s", TMP_DEPS);
    putenv(GEM_EXT_DEPS);
    sprintf(GEM_EXT_BUGS, "GEM_EXT_BUGS=%s", TMP_BUGS);
    putenv(GEM_EXT_BUGS);
    sprintf(GEM_EXT_AUTHORS, "GEM_EXT_AUTHORS=%s", TMP_AUTHORS);
    putenv(GEM_EXT_AUTHORS);
    atexit(0x8048e89);
    check_dependencies(package, gisbase, grass_version);
    fwrite((int32_t *)"Installing...", 1, 13, (struct _IO_FILE *)g12);
    struct _IO_FILE * file = fopen("../uninstall", "r"); // 0x805116c
    v2[0] = (int32_t)file;
    post_cmd2 = v2;
    int32_t file2 = *(int32_t *)&post_cmd2; // 0x8051177
    if (file2 != 0) {
        // 0x80511a4
        if (VERBOSE == 0) {
            // 0x80511f0
            sprintf((char *)&str, "cp -f ../uninstall %s/etc/uninstall.%s &> %s ;", gisbase, pkg_short_name, TMP_NULL);
            strcpy(UNINSTALL_CMD, (char *)&str);
        } else {
            // 0x80511ad
            sprintf((char *)&str, "cp -vf ../uninstall %s/etc/uninstall.%s ;", gisbase, pkg_short_name);
            strcpy(UNINSTALL_CMD, (char *)&str);
        }
        // 0x8051239
        fclose((struct _IO_FILE *)file2);
    } else {
        int32_t err_num3 = *__errno_location(); // 0x8051185
        print_warning("error checking for uninstall script: %s\n \t\t\t\tUninstalling this extension may leave orphaned files on your system", strerror(err_num3));
    }
    // 0x8051247
    register_extension(gisbase, bins, pkg_short_name, pkg_major, pkg_minor, pkg_revision);
    check_dependencies(package, gisbase, grass_version);
    if ((char *)str_as_l == (char *)6) {
        if (str_as_l2 >= 0 != str_as_l2 != 0) {
            // 0x80512b2
            register_entries_gisman(pkg_short_name, gisbase);
        }
    }
    // 0x80512ca
    register_entries_gisman2(pkg_short_name, gisbase);
    register_html(pkg_short_name, gisbase, pkg_major, pkg_minor, pkg_revision);
    int32_t str4; // bp-6160, 0x8050c67
    if (VERBOSE == 0) {
        // 0x8051373
        sprintf((char *)&str4, "bin/%s -f Makefile -s install &> %s ; \t\t\t\t\tcp -f %s %s/etc/extensions.db &> %s ; chmod a+r %s/etc/extensions.db &> %s ;", MAKE_CMD, TMP_NULL, TMPDB, gisbase, TMP_NULL, gisbase, TMP_NULL);
    } else {
        // 0x8051318
        fprintf((struct _IO_FILE *)g12, "Running '%s install':\n", MAKE_CMD);
        sprintf((char *)&str4, "bin/%s -f Makefile install ; \t\t\t\t\tcp -vf %s %s/etc/extensions.db ; chmod -v a+r %s/etc/extensions.db ;", MAKE_CMD, TMPDB, gisbase, gisbase);
    }
    // 0x80513c6
    int32_t str5; // bp-8208, 0x8050c67
    if (VERBOSE == 0) {
        // 0x80513f0
        sprintf((char *)&str5, "sh ../post &> %s", TMP_NULL);
    } else {
        // 0x80513cf
        memcpy(&str5, (int32_t *)"sh ../post", 11);
    }
    // 0x805140f
    sprintf((char *)&str, "%s %s %s %s %s %s", &str4, UNINSTALL_CMD, GISMAN_CMD, GISMAN2_CMD, HTML_CMD, &str5);
    su(gisbase, (char *)&str);
    print_done();
    if (v4 != __readgsdword(20)) {
        // 0x8051483
        __stack_chk_fail();
    }
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/actions.c
// Address range: 0x805148a - 0x8051cf4
// Line range:    636 - 805
void test_install(char * package, char * gisbase, char * pkg_short_name, int32_t pkg_major, int32_t pkg_minor, int32_t pkg_revision, char * grass_version) {
    char v1[2048]; // 0x805148a
    char v2[2048]; // 0x805148a
    char sysstr[2048]; // bp-6164, 0x805148a
    char sysstr2[2048]; // bp-6168, 0x805148a
    char v3[2048]; // 0x8051722
    char v4[2048]; // 0x8051b26
    char v5[2048]; // 0x80514da
    char v6[2048]; // 0x8051ac1
    char v7[2048]; // 0x8051842
    char v8[2048]; // 0x80517d5
    char v9[2048]; // 0x8051bba
    int32_t v10 = __readgsdword(20); // 0x80514b7
    int32_t buf; // bp-6284, 0x805148a
    int32_t v11 = stat((int32_t *)gisbase, &buf); // 0x80514d5
    v5[0] = v11;
    sysstr = v5;
    if (*(int32_t *)&sysstr < 0) {
        int32_t err_num = *__errno_location(); // 0x80514ee
        print_error(-5, "installation directory invalid: %s\n", strerror(err_num));
        // UNREACHABLE
    }
    // 0x8051510
    sprintf(GINSTALL_DST, "GINSTALL_DST=%s", gisbase);
    putenv(GINSTALL_DST);
    int32_t str; // bp-2064, 0x805148a
    sprintf((char *)&str, "%s/include", gisbase);
    sprintf(GINSTALL_INC, "GINSTALL_INC=%s", &str);
    putenv(GINSTALL_INC);
    sprintf((char *)&str, "%s/lib", gisbase);
    sprintf(GINSTALL_LIB, "GINSTALL_LIB=%s", &str);
    putenv(GINSTALL_LIB);
    sprintf(GEM_GRASS_DIR, "GEM_GRASS_DIR=%s", gisbase);
    putenv(GEM_GRASS_DIR);
    char * str2 = strdup(grass_version); // 0x8051607
    char * next_token = strtok(str2, "."); // 0x8051624
    char * next_token2 = strtok(NULL, "."); // 0x805163f
    char * next_token3 = strtok(NULL, "."); // 0x805165a
    int32_t str_as_l = strtol(next_token, NULL, 10); // 0x805167e
    int32_t str_as_l2 = strtol(next_token2, NULL, 10); // 0x80516a2
    strtol(next_token3, NULL, 10);
    free((int32_t *)str2);
    atexit(0x8048e89);
    int32_t str3; // bp-4112, 0x805148a
    sprintf((char *)&str3, "%s/src", basename(package));
    int32_t v12 = chdir((char *)&str3); // 0x805171d
    v3[0] = v12;
    sysstr = v3;
    if (*(int32_t *)&sysstr < 0) {
        int32_t err_num2 = *__errno_location(); // 0x8051736
        print_error(-2, "extension files in '%s' not accessible: %s\n", package, strerror(err_num2));
        // UNREACHABLE
    }
    // 0x8051762
    int32_t str4; // bp-6160, 0x805148a
    if (SKIP_CFG == 0) {
        // 0x805176f
        if (VERBOSE == 0) {
            // 0x80517dd
            fwrite((int32_t *)"Configuring...", 1, 14, (struct _IO_FILE *)g12);
            sprintf((char *)&str4, "sh %s %s --quiet &> %s", CONFIG_CMD, CONFIG_OPTS, TMP_NULL);
            int32_t system_rc = system((char *)&str4); // 0x805183d
            v7[0] = system_rc;
            v2 = v7;
        } else {
            // 0x8051778
            fwrite((int32_t *)"Running configure script:\n", 1, 26, (struct _IO_FILE *)g12);
            sprintf((char *)&str4, "sh %s %s", CONFIG_CMD, CONFIG_OPTS);
            int32_t system_rc2 = system((char *)&str4); // 0x80517d0
            v8[0] = system_rc2;
            v2 = v8;
        }
        // 0x8051848
        sysstr = v2;
        uint32_t v13 = *(int32_t *)&sysstr; // 0x8051848
        if (v13 == -1) {
            // 0x8051851
            print_error(-27, "could not run configure script.\n");
            // UNREACHABLE
        }
        if (v13 >= 1) {
            // 0x805186e
            print_error(-3, "system configuration failed.\n");
            // UNREACHABLE
        }
        // 0x8051882
        print_done();
        print_cfg();
    }
    // 0x805188c
    sprintf(GEM_EXT_NAME, "GEM_EXT_NAME=%s", pkg_short_name);
    putenv(GEM_EXT_NAME);
    sprintf((char *)&str, "%i.%i.%i", pkg_major, pkg_minor, pkg_revision);
    sprintf(GEM_EXT_VERSION, "GEM_EXT_VERSION=%s", &str);
    putenv(GEM_EXT_VERSION);
    dump_plain("../description", TMP_DESCR);
    dump_plain("../info", TMP_INFO);
    dump_plain("../depends", TMP_DEPS);
    dump_plain("../bugs", TMP_BUGS);
    dump_plain("../authors", TMP_AUTHORS);
    sprintf(GEM_EXT_DESCR, "GEM_EXT_DESCR=%s", TMP_DESCR);
    putenv(GEM_EXT_DESCR);
    sprintf(GEM_EXT_INFO, "GEM_EXT_INFO=%s", TMP_INFO);
    putenv(GEM_EXT_INFO);
    sprintf(GEM_EXT_DEPS, "GEM_EXT_DEPS=%s", TMP_DEPS);
    putenv(GEM_EXT_DEPS);
    sprintf(GEM_EXT_BUGS, "GEM_EXT_BUGS=%s", TMP_BUGS);
    putenv(GEM_EXT_BUGS);
    sprintf(GEM_EXT_AUTHORS, "GEM_EXT_AUTHORS=%s", TMP_AUTHORS);
    putenv(GEM_EXT_AUTHORS);
    atexit(0x8048e89);
    check_dependencies(package, gisbase, grass_version);
    if (VERBOSE == 0) {
        // 0x8051ac9
        fwrite((int32_t *)"Compiling...", 1, 12, (struct _IO_FILE *)g12);
        sprintf((char *)&str4, "%s -f Makefile &> %s", MAKE_CMD, TMP_NULL);
        int32_t system_rc3 = system((char *)&str4); // 0x8051b21
        v4[0] = system_rc3;
        v1 = v4;
    } else {
        // 0x8051a76
        fprintf((struct _IO_FILE *)g12, "Running '%s':\n", MAKE_CMD);
        sprintf((char *)&str4, "%s -f Makefile", MAKE_CMD);
        int32_t system_rc4 = system((char *)&str4); // 0x8051abc
        v6[0] = system_rc4;
        v1 = v6;
    }
    // 0x8051b2c
    sysstr = v1;
    uint32_t v14 = *(int32_t *)&sysstr;
    if (v14 == -1) {
        // 0x8051b35
        if (VERBOSE == 0) {
            // 0x8051b3e
            print_error(-9, "could not run '%s' do you have make tools installed?\n", MAKE_CMD);
            // UNREACHABLE
        }
    }
    if (v14 >= 1) {
        // 0x8051b63
        print_error(-4, "source code could not be compiled.\n \t\t\tRun again with option -v to see what is causing trouble.\n");
        // UNREACHABLE
    }
    // 0x8051b77
    print_done();
    fwrite((int32_t *)"Installing...", 1, 13, (struct _IO_FILE *)g12);
    struct _IO_FILE * file = fopen("../uninstall", "r"); // 0x8051bb5
    v9[0] = (int32_t)file;
    sysstr2 = v9;
    int32_t file2 = *(int32_t *)&sysstr2; // 0x8051bc0
    if (file2 != 0) {
        // 0x8051bea
        fclose((struct _IO_FILE *)file2);
    } else {
        int32_t err_num3 = *__errno_location(); // 0x8051bce
        print_warning("error checking for uninstall script: %s\n \t\t\t\tUninstalling this extension may leave orphaned files on your system", strerror(err_num3));
    }
    // 0x8051bf8
    register_extension(gisbase, "src", pkg_short_name, pkg_major, pkg_minor, pkg_revision);
    check_dependencies(package, gisbase, grass_version);
    if ((char *)str_as_l == (char *)6) {
        if (str_as_l2 >= 0 != str_as_l2 != 0) {
            // 0x8051c61
            register_entries_gisman(pkg_short_name, gisbase);
        }
    }
    // 0x8051c79
    register_entries_gisman2(pkg_short_name, gisbase);
    register_html(pkg_short_name, gisbase, pkg_major, pkg_minor, pkg_revision);
    fprintf((struct _IO_FILE *)g12, "(skipping '%s install')...", MAKE_CMD);
    print_done();
    if (v10 != __readgsdword(20)) {
        // 0x8051ced
        __stack_chk_fail();
    }
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/actions.c
// Address range: 0x8051cf4 - 0x80521a4
// Line range:    812 - 904
void uninstall(char * package, char * pkg_short_name, char * gisbase, char * grass_version) {
    char script2[2048]; // bp-4116, 0x8051cf4
    char script[2048]; // bp-4120, 0x8051cf4
    char v1[2048]; // 0x8051fa7
    char v2[2048]; // 0x8051ec0
    int32_t v3 = __readgsdword(20); // 0x8051d21
    fwrite((int32_t *)"Un-installing...", 1, 16, (struct _IO_FILE *)g12);
    sprintf(UNINSTALL_BASE, "UNINSTALL_BASE=%s", gisbase);
    putenv(UNINSTALL_BASE);
    char * str = strdup(grass_version); // 0x8051d88
    char * next_token = strtok(str, "."); // 0x8051da5
    char * next_token2 = strtok(NULL, "."); // 0x8051dc0
    char * next_token3 = strtok(NULL, "."); // 0x8051ddb
    int32_t str_as_l = strtol(next_token, NULL, 10); // 0x8051dff
    int32_t str_as_l2 = strtol(next_token2, NULL, 10); // 0x8051e23
    strtol(next_token3, NULL, 10);
    free((int32_t *)str);
    atexit(0x8048e89);
    deregister_extension(package, pkg_short_name, gisbase);
    if (str_as_l == 6) {
        if (str_as_l2 >= 0 != str_as_l2 != 0) {
            int32_t v4 = deregister_entries_gisman(pkg_short_name, gisbase); // 0x8051ebb
            v2[0] = v4;
            script2 = v2;
            int32_t v5 = *(int32_t *)&script2; // 0x8051ec6
            if (v5 == -1) {
                // 0x8051ecf
                print_warning("GIS Manager menu entries could not be removed.\n");
                memcpy((int32_t *)&GISMAN_CMD, (int32_t *)&g6, 1);
            }
            if (v5 == 0) {
                // 0x8051f01
                print_warning("no entries found to remove from GIS Manager.\n");
                memcpy((int32_t *)&GISMAN_CMD, (int32_t *)&g6, 1);
            }
        }
    }
    // 0x8051f2a
    deregister_entries_gisman2(pkg_short_name, gisbase);
    deregister_html(pkg_short_name, gisbase);
    int32_t str2; // bp-4112, 0x8051cf4
    sprintf((char *)&str2, "%s/etc/uninstall.%s", gisbase, pkg_short_name);
    script = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    int32_t buf; // bp-4236, 0x8051cf4
    int32_t v6 = stat(&str2, &buf); // 0x8051fa2
    v1[0] = v6;
    script2 = v1;
    if (*(int32_t *)&script2 < 0) {
        // 0x8051fb6
        print_warning("no uninstall script available for this extension.\n \t\t\tUnneeded files may have been left on your system.\n");
        script = {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    }
    // 0x8051fcc
    int32_t str3; // bp-2064, 0x8051cf4
    if (*(int32_t *)&script == 0) {
        // 0x8051ff9
        if (VERBOSE == 0) {
            // 0x8052090
            sprintf((char *)&str3, "sh %s &> %s ; rm -vf %s &> %s ; \t\t\t\t\t \t\trm -vrf %s/docs/extensions/%s &> %s ; rm -vf %s/etc/dm/gem-entries/%s &> %s ; \t\t\t\t\t\t\tcp -vf %s %s/etc/extensions.db &> %s ; chmod -v a+r %s/etc/extensions.db &> %s ;", &str2, TMP_NULL, &str2, TMP_NULL, gisbase, pkg_short_name, TMP_NULL, gisbase, pkg_short_name, TMP_NULL, TMPDB, gisbase, TMP_NULL, gisbase, TMP_NULL);
            strcpy(UNINSTALL_CMD, (char *)&str3);
        } else {
            // 0x8052006
            sprintf((char *)&str3, "sh %s ; rm -vf %s ; \t\t\t\t\t \t\trm -vrf %s/docs/extensions/%s ; rm -vf %s/etc/dm/gem-entries/%s ; \t\t\t\t\t\t\tcp -vf %s %s/etc/extensions.db ; chmod -v a+r %s/etc/extensions.db ;", &str2, &str2, gisbase, pkg_short_name, gisbase, pkg_short_name, TMPDB, gisbase, gisbase);
            strcpy(UNINSTALL_CMD, (char *)&str3);
        }
    } else {
        int32_t err_num = *__errno_location(); // 0x8051fda
        print_warning("error checking for uninstall script: %s\n \t\t\t\tUninstalling this extension may leave orphaned files on your system", strerror(err_num));
    }
    char * str4 = (char *)&str3;
    sprintf(str4, "%s %s %s", UNINSTALL_CMD, GISMAN_CMD, HTML_CMD);
    su(gisbase, str4);
    print_done();
    if (v3 != __readgsdword(20)) {
        // 0x805219d
        __stack_chk_fail();
    }
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/actions.c
// Address range: 0x80521a4 - 0x8052334
// Line range:    907 - 946
int32_t source_clean(char * package) {
    char v1[2048]; // 0x80521a4
    char sysstr[2048]; // bp-4116, 0x80521a4
    char v2[2048]; // 0x8052279
    char v3[2048]; // 0x80521f8
    char v4[2048]; // 0x80522de
    int32_t v5 = __readgsdword(20); // 0x80521b6
    int32_t str; // bp-2064, 0x80521a4
    sprintf((char *)&str, "%s/src", basename(package));
    int32_t v6 = chdir((char *)&str); // 0x80521f3
    v3[0] = v6;
    sysstr = v3;
    if (*(int32_t *)&sysstr < 0) {
        // 0x8052207
        print_error(-2, "extension '%s' not accessible: ", package);
        // UNREACHABLE
    }
    // 0x8052225
    int32_t str2; // bp-4112, 0x80521a4
    if (VERBOSE == 0) {
        // 0x8052281
        fwrite((int32_t *)"Cleaning up...", 1, 14, (struct _IO_FILE *)g12);
        sprintf((char *)&str2, "%s -f Makefile -s clean &> %s", MAKE_CMD, TMP_NULL);
        int32_t system_rc = system((char *)&str2); // 0x80522d9
        v4[0] = system_rc;
        v1 = v4;
    } else {
        // 0x805222e
        fprintf((struct _IO_FILE *)g12, "Running '%s clean':\n", MAKE_CMD);
        sprintf((char *)&str2, "%s -f Makefile clean", MAKE_CMD);
        int32_t system_rc2 = system((char *)&str2); // 0x8052274
        v2[0] = system_rc2;
        v1 = v2;
    }
    // 0x80522e4
    sysstr = v1;
    if (*(int32_t *)&sysstr == -1) {
        // 0x80522ed
        print_error(-9, "could not run '%s clean' do you have make tools installed?\n", MAKE_CMD);
        // UNREACHABLE
    }
    // 0x805230b
    print_done();
    system("sh ../post");
    int32_t result = 0; // 0x805232b
    if (v5 != __readgsdword(20)) {
        // 0x805232d
        __stack_chk_fail();
        result = &g18;
    }
    // 0x8052332
    return result;
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/actions.c
// Address range: 0x8052334 - 0x80525fc
// Line range:    952 - 1016
void restore(char * gisbase, char * grass_version) {
    char tmp2[2048]; // bp-2068, 0x8052334
    char tmp[2048]; // bp-2072, 0x8052334
    char v1[2048]; // 0x80524c0
    char v2[2048]; // 0x8052483
    char v3[2048]; // 0x8052368
    int32_t v4 = __readgsdword(20); // 0x805234f
    char * v5 = strdup(grass_version); // 0x8052363
    v3[0] = (int32_t)v5;
    tmp = v3;
    int32_t str = *(int32_t *)&tmp;
    char * next_token = strtok((char *)str, "."); // 0x8052380
    char * next_token2 = strtok(NULL, "."); // 0x805239b
    char * next_token3 = strtok(NULL, "."); // 0x80523b6
    int32_t str_as_l = strtol(next_token, NULL, 10); // 0x80523da
    int32_t str_as_l2 = strtol(next_token2, NULL, 10); // 0x80523fe
    strtol(next_token3, NULL, 10);
    free(&((struct __dirstream *)str)->e0);
    fwrite((int32_t *)"Restoring...", 1, 12, (struct _IO_FILE *)g12);
    if (str_as_l == 6) {
        if (str_as_l2 >= 0 != str_as_l2 != 0) {
            int32_t v6 = restore_entries_gisman(gisbase); // 0x805247e
            v2[0] = v6;
            tmp2 = v2;
            if (VERBOSE != 0) {
                int32_t v7 = *(int32_t *)&tmp2; // 0x805249c
                fprintf((struct _IO_FILE *)g12, "\nRestored entries for GIS Manager: %i\n", v7);
            }
        }
    }
    int32_t v8 = restore_html(gisbase); // 0x80524bb
    v1[0] = v8;
    tmp2 = v1;
    int32_t v9; // 0x8052334
    if (VERBOSE == 0) {
        // 0x80524b2
        v9 = *(int32_t *)&tmp2;
    } else {
        int32_t v10 = *(int32_t *)&tmp2; // 0x80524d9
        fprintf((struct _IO_FILE *)g12, "\nRestored links in index.hml: %i\n", v10);
        v9 = v10;
    }
    // 0x80524ef
    if (v9 < 1) {
        if (v9 == 0) {
            // 0x80525ce
            print_error(-26, "could not find anything to restore.\n");
            // UNREACHABLE
        }
    } else {
        // 0x80524fc
        int32_t str2; // bp-2064, 0x8052334
        if (VERBOSE == 0) {
            // 0x8052556
            sprintf((char *)&str2, "cp -f %s %s/etc/dm/menu.tcl ; chmod a+r %s/etc/dm/menu.tcl &> %s ; \t\t\t\t\t\t\tcp -f %s %s/docs/html/index.html ; chmod a+r %s/docs/html/index.html", TMP_GISMAN, gisbase, gisbase, TMP_NULL, TMP_HTML, gisbase, gisbase);
        } else {
            // 0x8052505
            sprintf((char *)&str2, "cp -f %s %s/etc/dm/menu.tcl ; chmod a+r %s/etc/dm/menu.tcl ; \t\t\t\t\t\t\tcp -f %s %s/docs/html/index.html ; chmod a+r %s/docs/html/index.html", TMP_GISMAN, gisbase, gisbase, TMP_HTML, gisbase, gisbase);
        }
        // 0x80525c5
        su(gisbase, (char *)&str2);
    }
    // 0x80525e4
    print_done();
    if (v4 != __readgsdword(20)) {
        // 0x80525f5
        __stack_chk_fail();
    }
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/actions.c
// Address range: 0x80525fc - 0x8052748
// Line range:    1022 - 1050
void list_extensions(char * gisbase) {
    char file[2048]; // bp-2068, 0x80525fc
    char v1[2048]; // 0x8052671
    int32_t v2 = __readgsdword(20); // 0x805260e
    fprintf((struct _IO_FILE *)g12, "\nExtensions in '%s' (name, version, type, depends):\n", gisbase);
    int32_t str; // bp-2064, 0x80525fc
    sprintf((char *)&str, "%s/etc/extensions.db", gisbase);
    struct _IO_FILE * file2 = fopen((char *)&str, "r"); // 0x805266c
    v1[0] = (int32_t)file2;
    file = v1;
    int32_t file3 = *(int32_t *)&file; // 0x8052677
    if (file3 != 0) {
        // 0x8052711
        fclose((struct _IO_FILE *)file3);
        dump_ascii((char *)&str, (char *)&g6);
        if (v2 != __readgsdword(20)) {
            // 0x8052741
            __stack_chk_fail();
        }
        // 0x8052746
        return;
    }
    // 0x8052684
    if (*__errno_location() != 2) {
        // 0x80526d2
        fclose((struct _IO_FILE *)file3);
        char * err_str = strerror(*__errno_location()); // 0x80526ea
        print_error(-29, "checking for file '%s': %s\n", &str, err_str);
        // UNREACHABLE
    }
    // 0x8052690
    fwrite((int32_t *)"NONE.\n", 1, 6, g11);
    fclose((struct _IO_FILE *)file3);
    exit(0);
    // UNREACHABLE
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/actions.c
// Address range: 0x8052748 - 0x8052a50
// Line range:    1057 - 1122
void run_post(char * package, int32_t action, char * bins, char * gisbase) {
    int32_t v1 = __readgsdword(20); // 0x805276c
    g16 = action - 3;
    switch (action) {
        case 3: {
            // 0x805278f
            memcpy((int32_t *)&GEM_ACTION, (int32_t *)"GEM_ACTION=INSTALL", 19);
            // break -> 0x805284a
            break;
        }
        case 4: {
            // 0x80527b1
            memcpy((int32_t *)&GEM_ACTION, (int32_t *)"GEM_ACTION=INSTALL", 19);
            // break -> 0x805284a
            break;
        }
        case 5: {
            // 0x80527d0
            memcpy((int32_t *)&GEM_ACTION, (int32_t *)"GEM_ACTION=QUERY", 17);
            // break -> 0x805284a
            break;
        }
        case 6: {
            // 0x80527ef
            memcpy((int32_t *)&GEM_ACTION, (int32_t *)"GEM_ACTION=CLEAN", 17);
            // break -> 0x805284a
            break;
        }
        case 7: {
            // 0x805280e
            memcpy((int32_t *)&GEM_ACTION, (int32_t *)"GEM_ACTION=LICENSE", 19);
            // break -> 0x805284a
            break;
        }
        case 9: {
            // 0x805282d
            memcpy((int32_t *)&GEM_ACTION, (int32_t *)"GEM_ACTION=DETAILS", 19);
            // break -> 0x805284a
            break;
        }
    }
    // 0x805284a
    putenv(GEM_ACTION);
    if (gisbase == NULL) {
        // 0x8052880
        memcpy((int32_t *)&INSTALL_BASE, (int32_t *)"INSTALL_BASE=UNDEFINED", 23);
    } else {
        // 0x805285f
        sprintf(INSTALL_BASE, "INSTALL_BASE=%s", gisbase);
    }
    // 0x805289d
    putenv(INSTALL_BASE);
    int32_t buf; // bp-2064, 0x8052748
    getcwd((char *)&buf, 2048);
    int32_t str; // bp-4112, 0x8052748
    sprintf((char *)&str, "%s/%s/src", &buf, basename(package));
    sprintf(EXT_BASE, "EXT_BASE=%s", &str);
    putenv(EXT_BASE);
    if (bins != NULL) {
        // 0x8052945
        sprintf(INSTALL_TYPE, "INSTALL_TYPE=%s", bins);
    } else {
        // 0x8052926
        memcpy((int32_t *)&INSTALL_TYPE, (int32_t *)"INSTALL_TYPE=src", 17);
    }
    // 0x8052964
    putenv(INSTALL_TYPE);
    sprintf((char *)&buf, "%i", FORCE);
    sprintf(GEM_FORCE, "GEM_FORCE=%s", &buf);
    putenv(GEM_FORCE);
    sprintf((char *)&buf, "%i", VERBOSE);
    sprintf(GEM_VERBOSE, "GEM_VERBOSE=%s", &buf);
    putenv(GEM_VERBOSE);
    memcpy((int32_t *)&GEM_GUI, (int32_t *)"GEM_GUI=0", 10);
    putenv(GEM_GUI);
    atexit(0x8048e89);
    if (v1 != __readgsdword(20)) {
        // 0x8052a49
        __stack_chk_fail();
    }
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/main.c
// Address range: 0x8052a50 - 0x8053002
// Line range:    148 - 209
void show_help(void) {
    // 0x8052a50
    fwrite((int32_t *)"Usage: gem64 [OPTION] [ACTION] [FILE|DIR]\n", 1, 42, (struct _IO_FILE *)g12);
    fwrite((int32_t *)"Install a GRASS extension from FILE or DIR.\n", 1, 44, (struct _IO_FILE *)g12);
    fwrite((int32_t *)"Manage (installed) GRASS extension(s).\n", 1, 39, (struct _IO_FILE *)g12);
    fwrite((int32_t *)"\nPossible ACTIONs are:\n", 1, 23, (struct _IO_FILE *)g12);
    fwrite((int32_t *)"  -i, --install=EXT\tinstall a GRASS extension\n", 1, 46, (struct _IO_FILE *)g12);
    fwrite((int32_t *)"  -u, --uninstall=EXT\tremove an extension from GRASS\n", 1, 53, (struct _IO_FILE *)g12);
    fwrite((int32_t *)"  -q, --query=EXT\tdisplay information about extension/list installed\n", 1, 69, (struct _IO_FILE *)g12);
    fwrite((int32_t *)"  -d, --details=EXT\tdisplay additional details about an extension\n", 1, 66, (struct _IO_FILE *)g12);
    fwrite((int32_t *)"  -c, --clean=EXT\tclean extension's source code directories\n", 1, 60, (struct _IO_FILE *)g12);
    fwrite((int32_t *)"  -t, --test=EXT\tconfigure and compile extension, but don't install\n", 1, 68, (struct _IO_FILE *)g12);
    fwrite((int32_t *)"  -l, --license=EXT\tshow copyright information for an extension\n", 1, 64, (struct _IO_FILE *)g12);
    fwrite((int32_t *)"  -r, --restore\t\trecreate HTML links and GIS Manager entries\n", 1, 61, (struct _IO_FILE *)g12);
    fwrite((int32_t *)"  -h, --help\t\tdisplay this help and exit\n", 1, 41, (struct _IO_FILE *)g12);
    fwrite((int32_t *)"  -V, --version\t\toutput version information and exit\n\n", 1, 54, (struct _IO_FILE *)g12);
    fwrite((int32_t *)"\nPossible OPTIONs are:\n", 1, 23, (struct _IO_FILE *)g12);
    fwrite((int32_t *)"  -g, --grass=PATH\tpath to GRASS installation dir\n", 1, 50, (struct _IO_FILE *)g12);
    fwrite((int32_t *)"  -b, --binary=NAME\tno compilation: use binary files for system NAME\n", 1, 69, (struct _IO_FILE *)g12);
    fwrite((int32_t *)"  -f, --force\t\tforce action, regardless of dependencies\n", 1, 56, (struct _IO_FILE *)g12);
    fwrite((int32_t *)"  -v, --verbose\t\tdisplay detailed status information\n", 1, 53, (struct _IO_FILE *)g12);
    fwrite((int32_t *)"  -s, --skip-config\tskip configure script\n", 1, 42, (struct _IO_FILE *)g12);
    fwrite((int32_t *)"  -x, --config-opts=OPTS\tpass OPTS to configure script\n", 1, 55, (struct _IO_FILE *)g12);
    fwrite((int32_t *)"  -o, --options=OPTS\toptions to pass to the C compiler/linker\n", 1, 62, (struct _IO_FILE *)g12);
    fwrite((int32_t *)"  -C, --config-cmd=CMD\tDefine custom 'configure' command (default=configure)\n", 1, 77, (struct _IO_FILE *)g12);
    fwrite((int32_t *)"  -m, --make-cmd=CMD\tDefine custom 'make' command (default=make)\n", 1, 65, (struct _IO_FILE *)g12);
    fwrite((int32_t *)"\nWhen run from within a GRASS session, locations of libs, header files\n", 1, 71, (struct _IO_FILE *)g12);
    fwrite((int32_t *)"and installation target dir will be assumed to match those of the active\n", 1, 73, (struct _IO_FILE *)g12);
    fwrite((int32_t *)"GRASS version. ", 1, 15, (struct _IO_FILE *)g12);
    fwrite((int32_t *)"Option -g can be used to override these or install extensions\nfrom outside", 1, 74, (struct _IO_FILE *)g12);
    fwrite((int32_t *)"of a GRASS session.\n", 1, 20, (struct _IO_FILE *)g12);
    fwrite((int32_t *)"Per default, extensions will be compiled from source and then installed.\n", 1, 73, (struct _IO_FILE *)g12);
    fwrite((int32_t *)"If the exension package contains binaries for the user's platform, they can\n", 1, 76, (struct _IO_FILE *)g12);
    fwrite((int32_t *)"be installed instead using the -b option. ", 1, 42, (struct _IO_FILE *)g12);
    fwrite((int32_t *)"For installation from source code, a C compiler and make tools are needed.\n", 1, 75, (struct _IO_FILE *)g12);
    fwrite((int32_t *)"\nExample:\n", 1, 10, (struct _IO_FILE *)g12);
    fwrite((int32_t *)"\tgem64 -b macosx --grass=/usr/local/grass-6.4.0 -i myExtension\n", 1, 63, (struct _IO_FILE *)g12);
    fwrite((int32_t *)"Installs the MacOS X binaries for 'myExtension' in /usr/local/grass-6.4.0.\n", 1, 75, (struct _IO_FILE *)g12);
    exit(0);
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/main.c
// Address range: 0x8053002 - 0x80530b9
// Line range:    213 - 232
void show_details(char * package) {
    char tmp[2048]; // bp-2068, 0x8053002
    char v1[2048]; // 0x805304d
    // 0x8053002
    __readgsdword(20);
    int32_t str; // bp-2064, 0x8053002
    strcpy((char *)&str, basename(package));
    int32_t v2 = chdir((char *)&str); // 0x8053048
    v1[0] = v2;
    tmp = v1;
    if (*(int32_t *)&tmp < 0) {
        int32_t err_num = *__errno_location(); // 0x8053061
        print_error(-2, "extension '%s' not accessible: (%s)\n", package, strerror(err_num));
        // UNREACHABLE
    }
    // 0x805308d
    dump_ascii("info", "Detailed information");
    system("sh post");
    exit(0);
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/main.c
// Address range: 0x80530b9 - 0x8053170
// Line range:    236 - 254
void show_license(char * package) {
    char tmp[2048]; // bp-2068, 0x80530b9
    char v1[2048]; // 0x8053104
    // 0x80530b9
    __readgsdword(20);
    int32_t str; // bp-2064, 0x80530b9
    strcpy((char *)&str, basename(package));
    int32_t v2 = chdir((char *)&str); // 0x80530ff
    v1[0] = v2;
    tmp = v1;
    if (*(int32_t *)&tmp < 0) {
        int32_t err_num = *__errno_location(); // 0x8053118
        print_error(-2, "extension '%s' not accessible: (%s)\n", package, strerror(err_num));
        // UNREACHABLE
    }
    // 0x8053144
    dump_ascii("license", "Detailed information");
    system("sh post");
    exit(0);
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/main.c
// Address range: 0x8053170 - 0x8053242
// Line range:    258 - 267
void show_version(void) {
    // 0x8053170
    fprintf((struct _IO_FILE *)g12, "gem64 (GRASS extensions manager) %.2f\n", 1.03);
    fwrite((int32_t *)"Written by Benjamin Ducke\n", 1, 0, (struct _IO_FILE *)g12);
    fwrite((int32_t *)"\nCopyright (C) 2005 Benjamin Ducke\n", 1, 0, (struct _IO_FILE *)g12);
    fwrite((int32_t *)"This is free software; see the source for copying conditions.  There is NO\n", 1, 0, (struct _IO_FILE *)g12);
    fwrite((int32_t *)"warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n", 1, 0, (struct _IO_FILE *)g12);
    exit(0);
}

// From module:   /home/naftali/source/grass-6.4.0~rc6+42329/gem/main.c
// Address range: 0x805331e - 0x80546dd
// Line range:    302 - 857
int main(int argc, char ** argv) {
    char coptions[2048]; // bp-14372, 0x805331e
    char invocation[2048]; // bp-12324, 0x805331e
    char orgname[2048]; // bp-6180, 0x805331e
    char package[2048]; // bp-4132, 0x805331e
    char pkg_name[2048]; // bp-8228, 0x805331e
    char pkg_short_name[2048]; // bp-10276, 0x805331e
    char version_file[2048]; // bp-2084, 0x805331e
    // 0x805331e
    __readgsdword(20);
    int32_t option_index = 0; // bp-14476, 0x805334c
    VERBOSE = 0;
    TMPCLEAN = 0;
    TMPDBCLEAN = 0;
    FORCE = 0;
    UPGRADE = 0;
    ERROR = 0;
    WARNINGS = 0;
    SKIP_CFG = 0;
    memcpy((int32_t *)&GISMAN_CMD, &g7, 1);
    memcpy((int32_t *)&GISMAN2_CMD, &g7, 1);
    memcpy((int32_t *)&QGIS_CMD, &g7, 1);
    memcpy((int32_t *)&UNINSTALL_CMD, &g7, 1);
    memcpy((int32_t *)&HTML_CMD, &g7, 1);
    memcpy((int32_t *)&TMPDIR, &g7, 1);
    memcpy((int32_t *)&TMPDB, &g7, 1);
    memcpy((int32_t *)&TMP_GISMAN, &g7, 1);
    memcpy((int32_t *)&TMP_DESCR, &g7, 1);
    memcpy((int32_t *)&TMP_INFO, &g7, 1);
    memcpy((int32_t *)&TMP_DEPS, &g7, 1);
    memcpy((int32_t *)&TMP_BUGS, &g7, 1);
    memcpy((int32_t *)&TMP_AUTHORS, &g7, 1);
    memcpy((int32_t *)&TMP_HTML, &g7, 1);
    memcpy((int32_t *)&TMP_NULL, &g7, 1);
    memcpy((int32_t *)&CONFIG_OPTS, &g7, 1);
    memcpy((int32_t *)&CONFIG_CMD, (int32_t *)"configure", 10);
    memcpy((int32_t *)&MAKE_CMD, (int32_t *)"make", 5);
    getcwd(CWD, 2048);
    fwrite(&g8, 1, 4, (struct _IO_FILE *)g12);
    int32_t * mem = malloc(2048); // 0x80535f4
    strcpy(invocation, *argv);
    setvbuf((struct _IO_FILE *)g12, NULL, 2, 0);
    if (argc == 1) {
        // 0x8053644
        show_help();
        // UNREACHABLE
    }
    // 0x8053655
    atexit(0x8049390);
    char * gisbase = NULL; // bp-14376, 0x8053677
    g13 = 0;
    int32_t v1 = getopt_long(argc, argv, ":i:u:q:d:c:C:t:l:m:o:x:rhVg:b:fvs", (struct option *)&g9, &option_index); // 0x80536b5
    char * v2 = NULL; // 0x8053aa3
    int32_t v3 = 0; // 0x8053aa3
    char * v4; // 0x805331e
    char * v5; // 0x805331e
    int32_t v6; // 0x805331e
    int32_t v7; // 0x805331e
    int32_t v8; // 0x805331e
    int32_t v9; // 0x805331e
    char * v10; // 0x805331e
    char * v11; // 0x805331e
    int32_t v12; // 0x805331e
    int32_t v13; // 0x805331e
    int32_t v14; // 0x805331e
    int32_t v15; // 0x805331e
    int32_t v16; // 0x805331e
    if (v1 != -1) {
        // 0x80536c6
        v4 = gisbase;
        v12 = v1;
        v15 = 0;
        v10 = NULL;
        while (true) {
          lab_0x80536c6:
            // 0x80536c6
            v13 = v12;
            v5 = v4;
            if (v13 == 63) {
                // break -> 0x80536d0
                break;
            }
            // 0x80536e4
            v11 = v10;
            v8 = v7;
            v16 = v15;
            if (v13 == 58) {
                // 0x80536f2
                switch (g10) {
                    case 117: {
                    }
                    case 116: {
                    }
                    case 108: {
                    }
                    case 105: {
                    }
                    case 100: {
                    }
                    case 99: {
                        // 0x8053738
                        gisbase = v5;
                        print_error(-1, "missing file or directory name.\n");
                        // UNREACHABLE
                    }
                }
                if (g10 == 114) {
                    // 0x8053738
                    gisbase = v5;
                    print_error(-1, "missing file or directory name.\n");
                    // UNREACHABLE
                }
                if (g10 == 103) {
                    // 0x8053756
                    gisbase = v5;
                    print_error(-1, "missing path to GRASS 6.\n");
                    // UNREACHABLE
                }
                if (g10 == 98) {
                    // 0x8053774
                    gisbase = v5;
                    print_error(-1, "missing name of binary architecture.\n");
                    // UNREACHABLE
                }
                if (g10 == 113) {
                    // 0x80537b0
                    gisbase = v5;
                    v2 = v11;
                    v9 = 12;
                    v3 = v16 + 1;
                    goto lab_0x8053aa9_2;
                }
            }
            switch (v13) {
                case 117: {
                    goto lab_0x8053830;
                }
                case 116: {
                    goto lab_0x8053830;
                }
                case 114: {
                    goto lab_0x8053830;
                }
                case 113: {
                    goto lab_0x8053830;
                }
                case 108: {
                    goto lab_0x8053830;
                }
                case 105: {
                    goto lab_0x8053830;
                }
                case 104: {
                    goto lab_0x8053830;
                }
                case 100: {
                    goto lab_0x8053830;
                }
                case 99: {
                    goto lab_0x8053830;
                }
                default: {
                    // 0x8053822
                    v6 = v8;
                    v14 = v16;
                    if (v13 != 86) {
                        goto lab_0x805391e;
                    } else {
                        goto lab_0x8053830;
                    }
                }
            }
        }
        // 0x80536d0
        gisbase = v5;
        print_error(-1, "unknown option or action specified.\n");
        // UNREACHABLE
    }
    goto lab_0x8053aa9_2;
  lab_0x8053830:
    // 0x8053830
    g17 = v13 - 86;
    int32_t v30 = v8; // 0x8053852
    switch (v13) {
        case 86: {
            // 0x80538d7
            v30 = 2;
            // break -> 0x80538e5
            break;
        }
        case 99: {
            // 0x8053896
            v30 = 6;
            // break -> 0x80538e5
            break;
        }
        case 100: {
            // 0x8053889
            v30 = 9;
            // break -> 0x80538e5
            break;
        }
        case 104: {
            // 0x80538ca
            v30 = 1;
            // break -> 0x80538e5
            break;
        }
        case 105: {
            // 0x8053854
            v30 = v8 == 4 ? 4 : 3;
            // break -> 0x80538e5
            break;
        }
        case 108: {
            // 0x80538b0
            v30 = 7;
            // break -> 0x80538e5
            break;
        }
        case 113: {
            // 0x805387c
            v30 = 5;
            // break -> 0x80538e5
            break;
        }
        case 114: {
            // 0x80538bd
            v30 = 11;
            // break -> 0x80538e5
            break;
        }
        case 116: {
            // 0x80538a3
            v30 = 8;
            // break -> 0x80538e5
            break;
        }
        case 117: {
            // 0x805386f
            v30 = 10;
            // break -> 0x80538e5
            break;
        }
    }
    int32_t v31 = v16 + 1; // 0x8053830
    int32_t v32 = v30;
    v6 = v32;
    v14 = v31;
    if (g14 != NULL) {
        // 0x80538ee
        strcpy(package, g14);
        strcpy(orgname, g14);
        v6 = v32;
        v14 = v31;
    }
    goto lab_0x805391e;
  lab_0x805391e:;
    int32_t v33 = v14;
    char * v34 = v5; // 0x8053926
    if (v13 == 103) {
        int32_t * mem5 = malloc(strlen(g14) + 1); // 0x805393b
        strcpy((char *)mem5, g14);
        v34 = (char *)mem5;
    }
    char * v35 = v34;
    char * v36 = v11; // 0x8053967
    int32_t v37 = v6; // 0x8053967
    if (v13 == 98) {
        int32_t * mem6 = malloc(strlen(g14) + 1); // 0x805397c
        strcpy((char *)mem6, g14);
        v36 = (char *)mem6;
        v37 = 4;
    }
    int32_t v38 = v37;
    char * v39 = v36;
    if (v13 == 120) {
        // 0x80539b5
        strcpy(CONFIG_OPTS, g14);
    }
    if (v13 == 102) {
        // 0x80539d4
        FORCE = 1;
    }
    if (v13 == 118) {
        // 0x80539e8
        VERBOSE = 1;
    }
    if (v13 == 115) {
        // 0x80539fc
        SKIP_CFG = 1;
    }
    if (v13 == 111) {
        // 0x8053a10
        strcat(coptions, g14);
    }
    if (v13 == 67) {
        // 0x8053a32
        strcpy(CONFIG_CMD, g14);
    }
    if (v13 == 109) {
        // 0x8053a51
        strcpy(MAKE_CMD, g14);
    }
    int32_t v40 = getopt_long(argc, argv, ":i:u:q:d:c:t:l:o:x:rhVg:b:fvs", (struct option *)&g9, &option_index); // 0x8053a8f
    v4 = v35;
    v12 = v40;
    v15 = v33;
    v7 = v38;
    v10 = v39;
    if (v40 == -1) {
        // 0x8053aa9
        gisbase = v35;
        v2 = v39;
        v9 = v38;
        v3 = v33;
        goto lab_0x8053aa9_2;
    }
    goto lab_0x80536c6;
  lab_0x8053aa9_2:;
    uint32_t v17 = v3;
    if (v17 >= 0 != v17 != 0) {
        // 0x8053ab3
        print_error(-1, "please specify a valid action.\n");
        // UNREACHABLE
    }
    if (v17 >= 2) {
        // 0x8053ad1
        print_error(-1, "please specify only one action.\n");
        // UNREACHABLE
    }
    // 0x8053ae5
    sprintf(GEM_C_OPTS, "GEM_C_OPTS=%s", coptions);
    putenv(GEM_C_OPTS);
    if (v9 == 1) {
        // 0x8053b1b
        show_help();
        // UNREACHABLE
    }
    if (v9 == 2) {
        // 0x8053b36
        show_version();
        // UNREACHABLE
    }
    // 0x8053b47
    if (VERBOSE == 0) {
        // 0x8053b54
        memcpy((int32_t *)&TMP_NULL, (int32_t *)"/tmp/grass.extension.log.XXXXXX", 32);
        mkstemp(TMP_NULL);
        if (open(TMP_NULL, O_CREAT) == -1) {
            int32_t err_num = *__errno_location(); // 0x8053baf
            print_error(-30, "could not create temp file: %s", strerror(err_num));
            // UNREACHABLE
        }
    }
    if (v9 == 11) {
        char * env_val = gisbase; // 0x8053bf3
        if (gisbase == NULL) {
            // 0x8053bf5
            env_val = getenv("GISBASE");
            gisbase = env_val;
            if (env_val == NULL) {
                // 0x8053c12
                print_error(-1, "GISBASE environment variable not set and path to GRASS not given.\n");
                // UNREACHABLE
            }
        }
        // 0x8053c26
        char * v18; // 0x805331e
        if (VERBOSE == 0) {
            // 0x8053c26
            v18 = env_val;
        } else {
            // 0x8053c2f
            fprintf((struct _IO_FILE *)g12, "Path to GRASS is %s.\n", env_val);
            v18 = gisbase;
        }
        // 0x8053c50
        char * v19; // 0x805331e
        restore(v18, v19);
        exit(0);
        // UNREACHABLE
    }
    if (v9 == 12) {
        char * env_val2 = gisbase; // 0x8053c8c
        if (gisbase == NULL) {
            // 0x8053c8e
            env_val2 = getenv("GISBASE");
            gisbase = env_val2;
            if (env_val2 == NULL) {
                // 0x8053cab
                print_error(-1, "GISBASE environment variable not set and path to GRASS not given.\n");
                // UNREACHABLE
            }
        }
        // 0x8053cbf
        char * v20; // 0x805331e
        if (VERBOSE == 0) {
            // 0x8053cbf
            v20 = env_val2;
        } else {
            // 0x8053cc8
            fprintf((struct _IO_FILE *)g12, "Path to GRASS is %s.\n", env_val2);
            v20 = gisbase;
        }
        // 0x8053ce9
        list_extensions(v20);
        exit(0);
        // UNREACHABLE
    }
    // 0x8053d04
    if (strstr(package, "http://") != NULL) {
        goto lab_0x8053d3e;
    } else {
        // 0x8053d1f
        if (strstr(package, "ftp://") == NULL) {
            goto lab_0x8053dc9;
        } else {
            goto lab_0x8053d3e;
        }
    }
  lab_0x8053d3e:
    // 0x8053d3e
    wget_extension(package);
    int32_t * mem2 = malloc(2048); // 0x8053d54
    strcpy((char *)mem2, package);
    char * found_char_pos = strrchr((char *)mem2, 47); // 0x8053d8c
    strcpy(package, (char *)((int32_t)found_char_pos + 1));
    free(mem2);
    goto lab_0x8053dc9;
  lab_0x8053dc9:
    // 0x8053dc9
    if (VERBOSE != 0) {
        // 0x8053dd2
        fprintf((struct _IO_FILE *)g12, "Extension location is '%s'.\n", package);
    }
    char * v21; // 0x805331e
    bool v22; // 0x805331e
    if (v9 == 10) {
        // 0x8054037
        strcpy(pkg_short_name, package);
        v21 = &pkg_short_name[0];
        v22 = false;
        goto lab_0x805406d;
    } else {
        // 0x8053e01
        int32_t buf; // bp-14564, 0x805331e
        if (stat((int32_t *)&package, &buf) < 0) {
            char * err_str = strerror(*__errno_location()); // 0x8053e36
            print_error(-2, "extension FILE or DIR '%s' invalid: %s\n", package, err_str);
            // UNREACHABLE
        }
        // 0x8053e5e
        int32_t v23; // 0x805331e
        if ((v23 & 0xf000) != 0x4000) {
            if (VERBOSE != 0) {
                struct __dirstream * stream = g12; // 0x8053ebf
                fwrite((int32_t *)"Extension files stored in a package file.\n", 1, 42, (struct _IO_FILE *)stream);
            }
            // 0x8053ee7
            unpack_extension(package);
            struct __dirstream * dirp = opendir(TMPDIR); // 0x8053efd
            struct dirent * v24 = readdir(dirp); // 0x8053f13
            if (v24 == NULL) {
                // 0x8054019
                strcpy(package, (char *)mem);
                print_error(-7, "no top-level directory found in extension package.\n");
                // UNREACHABLE
            }
            char * str = (char *)((int32_t)v24 + 11); // 0x8053f41
            int32_t buf2; // bp-14652, 0x805331e
            if (strcmp(str, ".") != 0) {
                // 0x8053f51
                if (strcmp(str, "..") != 0) {
                    // 0x8053f6f
                    sprintf((char *)mem, "%s/%s", TMPDIR, str);
                    stat(mem, &buf2);
                    if ((v23 & 0xf000) == 0x4000) {
                        // 0x805402d
                        strcpy(package, (char *)mem);
                        goto lab_0x8054053;
                    }
                }
            }
            struct dirent * v25 = readdir(dirp); // 0x8053fdb
            while (v25 != NULL) {
                // 0x8053f2f
                str = (char *)((int32_t)v25 + 11);
                if (strcmp(str, ".") != 0) {
                    // 0x8053f51
                    if (strcmp(str, "..") != 0) {
                        // 0x8053f6f
                        sprintf((char *)mem, "%s/%s", TMPDIR, str);
                        stat(mem, &buf2);
                        if ((v23 & 0xf000) == 0x4000) {
                            // 0x805402d
                            strcpy(package, (char *)mem);
                            goto lab_0x8054053;
                        }
                    }
                }
                // 0x8053fd1
                v25 = readdir(dirp);
            }
            // 0x8054019
            strcpy(package, (char *)mem);
            print_error(-7, "no top-level directory found in extension package.\n");
            // UNREACHABLE
        }
        if (VERBOSE != 0) {
            // 0x8053e89
            fwrite((int32_t *)"Extension files stored in a directory.\n", 1, 39, (struct _IO_FILE *)g12);
        }
        // 0x805402d
        goto lab_0x8054053;
    }
  lab_0x805406d:
    // 0x805406d
    if (v17 >= 1) {
        char * env_val3 = gisbase; // 0x805407f
        if (gisbase == NULL) {
            // 0x8054081
            env_val3 = getenv("GISBASE");
            gisbase = env_val3;
        }
        // 0x8054094
        run_post(package, v9, v2, env_val3);
    }
    // 0x80540c4
    if (VERBOSE != 0) {
        // 0x80540cd
        fprintf((struct _IO_FILE *)g12, "Extension will be installed from '%s'\n", package);
    }
    int32_t pkg_major; // bp-14412, 0x805331e
    int32_t pkg_minor; // bp-14416, 0x805331e
    int32_t pkg_revision; // bp-14420, 0x805331e
    if (v9 != 10) {
        // 0x8054133
        check_extension(package, pkg_name, &pkg_major, &pkg_minor, &pkg_revision);
        if (v9 == 5) {
            // 0x805413d
            query_extension(package, pkg_name, pkg_major, pkg_minor, pkg_revision, v21, invocation, orgname);
            // UNREACHABLE
        }
        if (v9 == 9) {
            // 0x80541af
            show_details(package);
            // UNREACHABLE
        }
        if (v9 == 7) {
            // 0x80541d4
            show_license(package);
            // UNREACHABLE
        }
        if (v9 == 6) {
            // 0x80541f9
            source_clean(package);
            exit(0);
            // UNREACHABLE
        }
    }
    char * v26 = gisbase; // 0x805421c
    if (gisbase == NULL) {
        char * env_val4 = getenv("GISBASE"); // 0x8054225
        gisbase = env_val4;
        v26 = env_val4;
        if (env_val4 == NULL) {
            // 0x805423b
            print_error(-1, "GISBASE environment variable not set and path to GRASS not given.\n");
            // UNREACHABLE
        }
    }
    // 0x805424f
    if (VERBOSE != 0) {
        // 0x8054258
        fprintf((struct _IO_FILE *)g12, "Path to GRASS is %s.\n", v26);
    }
    char * env_val5 = getenv("GRASS_VERSION"); // 0x8054280
    int32_t str2 = (int32_t)env_val5; // 0x8054294
    char * v27 = env_val5; // 0x8054294
    if (env_val5 == NULL) {
        // 0x805429a
        sprintf(version_file, "%s/etc/VERSIONNUMBER", gisbase);
        struct _IO_FILE * file = fopen(version_file, "r"); // 0x80542d0
        if (file == NULL) {
            // 0x80542e6
            print_error(-11, "Could not read GRASS version. Did you specify the right path?\n");
            // UNREACHABLE
        }
        int32_t * mem3 = malloc(16); // 0x8054303
        int32_t items_assigned = fscanf(file, "%s", mem3); // 0x805432d
        fclose(file);
        if (items_assigned >= 0 != items_assigned != 0) {
            // 0x8054352
            print_error(-11, "Could not read GRASS version. Did you specify the right path?\n");
            // UNREACHABLE
        }
        // 0x8054366
        str2 = (int32_t)mem3;
        v27 = (char *)mem3;
    }
    char * v28 = NULL; // 0x805436e
    if (v27 != NULL) {
        char * next_token = strtok(strdup((char *)str2), "."); // 0x805439d
        char * next_token2 = strtok(NULL, "."); // 0x80543b9
        char * next_token3 = strtok(NULL, "."); // 0x80543d5
        uint32_t str_as_l = strtol(next_token, NULL, 10); // 0x80543fb
        int32_t str_as_l2 = strtol(next_token2, NULL, 10); // 0x8054421
        int32_t str_as_l3 = strtol(next_token3, NULL, 10); // 0x8054447
        int32_t * mem4 = malloc(2048); // 0x805445a
        sprintf((char *)mem4, "%i.%i.%i", str_as_l, str_as_l2, str_as_l3);
        if (VERBOSE != 0) {
            // 0x80544a8
            fprintf((struct _IO_FILE *)g12, "GRASS version is %s.\n", mem4);
        }
        // 0x80544c9
        v28 = (char *)mem4;
        if (str_as_l <= 5) {
            // 0x80544d3
            print_error(-11, "extensions only work with GRASS version 6 and above.\n");
            // UNREACHABLE
        }
    }
    // 0x80544e7
    sprintf(coptions, "-L%s/lib -I/usr/local/grasslib/include/ ", gisbase);
    if (v9 == 3) {
        // 0x8054514
        source_install(package, gisbase, v21, pkg_major, pkg_minor, pkg_revision, v28);
        exit(0);
        // UNREACHABLE
    }
    if (!v22) {
        // 0x805457b
        uninstall(package, v21, gisbase, v28);
        exit(0);
        // UNREACHABLE
    }
    if (v9 == 8) {
        // 0x80545c1
        test_install(package, gisbase, v21, pkg_major, pkg_minor, pkg_revision, v28);
        exit(0);
        // UNREACHABLE
    }
    if (v9 != 4) {
        // 0x80546d1
        exit(0);
        // UNREACHABLE
    }
    // 0x805462c
    if (binaries_exist(package, v2) == 0) {
        // 0x80546b2
        print_error(-12, "no binaries for system '%s'\n", v2);
        // UNREACHABLE
    }
    // 0x805464a
    bin_install(package, gisbase, v2, v21, pkg_major, pkg_minor, pkg_revision, v28);
    exit(0);
    // UNREACHABLE
  lab_0x8054053:;
    char * v29 = &pkg_short_name[0];
    get_package_name(package, v29);
    v21 = v29;
    v22 = true;
    goto lab_0x805406d;
}

// Address range: 0x805474a - 0x805474e
int32_t __i686_get_pc_thunk_bx(int32_t a1, int32_t a2) {
    // 0x805474a
    int32_t result; // 0x805474a
    return result;
}

// --------------- Statically Linked Functions ----------------

// int32_t atexit(int32_t a1);
// int32_t stat(int32_t * a1, int32_t * a2);

// --------------- Dynamically Linked Functions ---------------

// int __cxa_atexit(void(* func)(void *), void * arg, void * dso_handle);
// int * __errno_location(void);
// void __stack_chk_fail(void);
// int __xstat(int ver, const char * filename, struct stat * stat_buf);
// void * calloc(size_t nmemb, size_t size);
// int chdir(const char * path);
// int close(int fd);
// int closedir(DIR * dirp);
// void exit(int status);
// int fclose(FILE * stream);
// int fflush(FILE * stream);
// char * fgets(char * restrict s, int n, FILE * restrict stream);
// FILE * fopen(const char * restrict filename, const char * restrict modes);
// int fprintf(FILE * restrict stream, const char * restrict format, ...);
// int fputc(int c, FILE * stream);
// int fputs(const char * restrict s, FILE * restrict stream);
// void free(void * ptr);
// int fscanf(FILE * restrict stream, const char * restrict format, ...);
// size_t fwrite(const void * restrict ptr, size_t size, size_t n, FILE * restrict s);
// char * getcwd(char * buf, size_t size);
// char * getenv(const char * name);
// int getopt_long(int argc, char * const * argv, const char * shortopts, const struct option * longopts, int * longind);
// void * malloc(size_t size);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// int mkstemp(char * template);
// int open(const char * file, int oflag, ...);
// DIR * opendir(const char * name);
// int putenv(char * string);
// int rand(void);
// struct dirent * readdir(DIR * dirp);
// int remove(const char * filename);
// void rewind(FILE * stream);
// int setvbuf(FILE * restrict stream, char * restrict buf, int modes, size_t n);
// int sprintf(char * restrict s, const char * restrict format, ...);
// void srand(unsigned int seed);
// int sscanf(const char * restrict s, const char * restrict format, ...);
// char * strcat(char * restrict dest, const char * restrict src);
// char * strchr(char * s, int c);
// int strcmp(const char * s1, const char * s2);
// char * strcpy(char * restrict dest, const char * restrict src);
// char * strdup(const char * s);
// char * strerror(int errnum);
// size_t strlen(const char * s);
// char * strncpy(char * restrict dest, const char * restrict src, size_t n);
// char * strrchr(char * s, int c);
// char * strstr(char * haystack, const char * needle);
// char * strtok(char * restrict s, const char * restrict delim);
// long int strtol(const char * restrict nptr, char ** restrict endptr, int base);
// int system(const char * command);
// int vsprintf(char * restrict s, const char * restrict format, _G_va_list arg);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (4.4.5)
// Detected functions: 59

