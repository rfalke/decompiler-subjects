/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

int sub_8048ACC();
// int getpagesize(void);
// void abort(void);
// int *__errno_location(void);
// int __cdecl __cxa_atexit(void (__cdecl *lpfunc)(void *), void *obj, void *lpdso_handle);
// int memcmp(const void *s1, const void *s2, size_t n);
// int __cdecl open64(_DWORD, _DWORD); weak
// int __cdecl fputs_unlocked(_DWORD, _DWORD); weak
// size_t __ctype_get_mb_cur_max(void);
// void *realloc(void *ptr, size_t size);
// void *calloc(size_t nmemb, size_t size);
// ssize_t write(int fd, const void *buf, size_t n);
// void *memset(void *s, int c, size_t n);
// int __cdecl stpcpy(_DWORD, _DWORD); weak
// int ferror_unlocked(FILE *stream);
// void _exit(int status);
// char *bindtextdomain(const char *domainname, const char *dirname);
// size_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *p);
// ssize_t read(int fd, void *buf, size_t nbytes);
// char *gettext(const char *msgid);
// void free(void *ptr);
// int getopt_long(int argc, char *const *argv, const char *shortopts, const struct option *longopts, int *longind);
// int ioctl(int fd, unsigned int request, ...);
// const unsigned __int16 **__ctype_b_loc(void);
// int fclose(FILE *stream);
// int mbsinit(const mbstate_t *ps);
// void *memcpy(void *dest, const void *src, size_t n);
// size_t strlen(const char *s);
// char *setlocale(int category, const char *locale);
// int printf(const char *format, ...);
// int __cdecl __signbitl(_DWORD, _DWORD, _DWORD); weak
// int close(int fd);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// int fprintf(FILE *stream, const char *format, ...);
// void *malloc(size_t size);
// size_t __fpending(FILE *fp);
// void error(int status, int errnum, const char *format, ...);
// void *memmove(void *dest, const void *src, size_t n);
// char *textdomain(const char *domainname);
// int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD); weak
// int snprintf(char *s, size_t maxlen, const char *format, ...);
// int iswprint(wint_t wc);
// int strcmp(const char *s1, const char *s2);
// void exit(int status);
void __cdecl usage(int status);
void emit_bug_reporting_address(); // idb
void next_line_num(); // idb
bool __cdecl simple_cat(char *buf, size_t bufsize);
bool __cdecl cat(char *inbuf, size_t insize, char *outbuf, size_t outsize, bool show_nonprinting, bool show_tabs, bool number, bool number_nonblank, bool show_ends, bool squeeze_blank);
void __cdecl write_pending(char *outbuf, char **bpout);
int __cdecl main(int argc, const char **argv, const char **envp);
void *__cdecl ptr_align(const void *ptr, size_t alignment);
size_t __cdecl full_write(int fd, const void *buf, size_t count);
void __cdecl version_etc_va(FILE *stream, const char *command_name, const char *package, const char *version, va_list authors);
void version_etc(FILE *stream, const char *command_name, const char *package, const char *version, ...);
void __cdecl close_stdout_set_file_name(const char *file);
void close_stdout(); // idb
const char *__cdecl quote_n(int n, const char *name);
const char *__cdecl quote(const char *name);
quoting_options *__cdecl clone_quoting_options(quoting_options *o);
quoting_style __cdecl get_quoting_style(quoting_options *o);
void __cdecl set_quoting_style(quoting_options *o, quoting_style s);
int __cdecl set_char_quoting(quoting_options *o, char c, int i);
const char *__cdecl gettext_quote(const char *msgid, quoting_style s);
size_t __cdecl quotearg_buffer_restyled(char *buffer, size_t buffersize, const char *arg, size_t argsize, quoting_style quoting_style, const quoting_options *o);
size_t __cdecl quotearg_buffer(char *buffer, size_t buffersize, const char *arg, size_t argsize, const quoting_options *o);
char *__cdecl quotearg_alloc(const char *arg, size_t argsize, const quoting_options *o);
void quotearg_free(); // idb
char *__cdecl quotearg_n_options(int n, const char *arg, size_t argsize, const quoting_options *options);
char *__cdecl quotearg_n(int n, const char *arg);
char *__cdecl quotearg(const char *arg);
quoting_options *quoting_options_from_style(quoting_options *__return_ptr __struct_ptr retstr, quoting_style style);
char *__cdecl quotearg_n_style(int n, quoting_style s, const char *arg);
char *__cdecl quotearg_n_style_mem(int n, quoting_style s, const char *arg, size_t argsize);
char *__cdecl quotearg_style(quoting_style s, const char *arg);
char *__cdecl quotearg_char(const char *arg, char ch_0);
char *__cdecl quotearg_colon(const char *arg);
size_t __cdecl safe_read(int fd, void *buf, size_t count);
size_t __cdecl safe_write(int fd, const void *buf, size_t count);
int __cdecl rpl_vfprintf(FILE *fp, const char *format, va_list args);
void *__cdecl xnmalloc(size_t n, size_t s);
void *__cdecl xnrealloc(void *p, size_t n, size_t s);
void *__cdecl x2nrealloc(void *p, size_t *pn, size_t s);
char *__cdecl xcharalloc(size_t n);
void *__cdecl xmalloc(size_t n);
void *__cdecl xrealloc(void *p, size_t n);
void *__cdecl x2realloc(void *p, size_t *pn);
void *__cdecl xzalloc(size_t s);
void *__cdecl xcalloc(size_t n, size_t s);
void *__cdecl xmemdup(const void *p, size_t s);
char *__cdecl xstrdup(const char *string);
void __cdecl fseterr(FILE *fp);
void __noreturn xalloc_die();
int __cdecl close_stream(FILE *stream);
int __cdecl is_infinitel(long double x);
char *__cdecl vasnprintf(char *resultbuf, size_t *lengthp, const char *format, va_list args);
size_t __cdecl xsum4(size_t size1, size_t size2, size_t size3, size_t size4);
size_t __cdecl xmax(size_t size1, size_t size2);
size_t __cdecl xsum(size_t size1, size_t size2);
int __cdecl rpl_isnanl(long double x);
int __cdecl printf_fetchargs(va_list args, arguments *a);
int __cdecl printf_parse(const char *format, char_directives *d, arguments *a);
size_t __cdecl xsum_0(size_t size1, size_t size2);
int __cdecl atexit(void (__cdecl *lpfunc)(void *)); // idb
int __cdecl fstat64(int, int);

//-------------------------------------------------------------------------
// Data declarations

const option long_options_4647[10] =
{
  { "number-nonblank", 0, NULL, 98 },
  { "number", 0, NULL, 110 },
  { "squeeze-blank", 0, NULL, 115 },
  { "show-nonprinting", 0, NULL, 118 },
  { "show-ends", 0, NULL, 69 },
  { "show-tabs", 0, NULL, 84 },
  { "show-all", 0, NULL, 65 },
  { "help", 0, NULL, -130 },
  { "version", 0, NULL, -131 },
  { NULL, 0, NULL, 0 }
}; // idb
const char locale = '\0'; // idb
const wchar_t wide_null_string_1636[7] = { 40, 78, 85, 76, 76, 41, 0 }; // idb
int (*dword_8051FFC)(void) = NULL; // weak
_DWORD _dso_handle = 0; // weak
char line_buf[20] = "                 0\t"; // idb
char *line_num_print = (char *)0x80520CC; // idb
char *line_num_start = (char *)0x80520D1; // idb
char *line_num_end = (char *)0x80520D1; // idb
volatile int exit_failure = 1; // idb
unsigned int nslots = 1u; // idb
slotvec slotvec0 = { 256u, &slot0 }; // idb
slotvec *slotvec_0 = &slotvec0; // idb
int optind; // weak
FILE *stderr; // idb
FILE *stdout; // idb
int newlines2; // idb
const char *infile; // idb
int input_desc; // idb
const char *file_name; // idb
quoting_options default_quoting_options; // idb
char slot0[256]; // idb
char *program_name; // idb


//----- (08048ACC) --------------------------------------------------------
int sub_8048ACC()
{
  return dword_8051FFC();
}
// 8051FFC: using guessed type int (*dword_8051FFC)(void);

//----- (08048E74) --------------------------------------------------------
void __cdecl __noreturn usage(int status)
{
  char *v1; // ebx
  char *v2; // eax
  char *v3; // eax
  FILE *v4; // ebx
  char *v5; // eax
  FILE *v6; // ebx
  char *v7; // eax
  FILE *v8; // ebx
  char *v9; // eax
  FILE *v10; // ebx
  char *v11; // eax
  FILE *v12; // ebx
  char *v13; // eax
  char *v14; // ebx
  char *v15; // esi
  char *v16; // eax

  v1 = program_name;
  if ( status )
  {
    v2 = gettext("Try `%s --help' for more information.\n");
    fprintf(stderr, v2, v1);
  }
  else
  {
    v3 = gettext("Usage: %s [OPTION] [FILE]...\n");
    printf(v3, v1);
    v4 = stdout;
    v5 = gettext(
           "Concatenate FILE(s), or standard input, to standard output.\n"
           "\n"
           "  -A, --show-all           equivalent to -vET\n"
           "  -b, --number-nonblank    number nonempty output lines\n"
           "  -e                       equivalent to -vE\n"
           "  -E, --show-ends          display $ at end of each line\n"
           "  -n, --number             number all output lines\n"
           "  -s, --squeeze-blank      suppress repeated empty output lines\n");
    fputs_unlocked(v5, v4);
    v6 = stdout;
    v7 = gettext(
           "  -t                       equivalent to -vT\n"
           "  -T, --show-tabs          display TAB characters as ^I\n"
           "  -u                       (ignored)\n"
           "  -v, --show-nonprinting   use ^ and M- notation, except for LFD and TAB\n");
    fputs_unlocked(v7, v6);
    v8 = stdout;
    v9 = gettext("      --help     display this help and exit\n");
    fputs_unlocked(v9, v8);
    v10 = stdout;
    v11 = gettext("      --version  output version information and exit\n");
    fputs_unlocked(v11, v10);
    v12 = stdout;
    v13 = gettext("\nWith no FILE, or when FILE is -, read standard input.\n");
    fputs_unlocked(v13, v12);
    v14 = program_name;
    v15 = program_name;
    v16 = gettext(
            "\n"
            "Examples:\n"
            "  %s f - g  Output f's contents, then standard input, then g's contents.\n"
            "  %s        Copy standard input to standard output.\n");
    printf(v16, v15, v14);
    emit_bug_reporting_address();
  }
  exit(status);
}
// 8048B3C: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (08048F9B) --------------------------------------------------------
void emit_bug_reporting_address()
{
  char *v0; // eax

  v0 = gettext("\nReport bugs to <%s>.\n");
  printf(v0, "bug-coreutils@gnu.org");
}

//----- (08048FBF) --------------------------------------------------------
void next_line_num()
{
  char *endp; // [esp+Ch] [ebp-4h]

  endp = line_num_end;
  while ( (*endp)++ > 56 )
  {
    *endp-- = 48;
    if ( endp < line_num_start )
    {
      if ( line_num_start <= line_buf )
        line_buf[0] = 62;
      else
        *--line_num_start = 49;
      if ( line_num_start < line_num_print )
        --line_num_print;
      return;
    }
  }
}

//----- (08049040) --------------------------------------------------------
bool __cdecl simple_cat(char *buf, size_t bufsize)
{
  const char *v2; // ebx
  int *v3; // eax
  char *v4; // ebx
  int *v5; // eax
  size_t n_read; // [esp+20h] [ebp-8h]

  while ( 1 )
  {
    n_read = safe_read(input_desc, buf, bufsize);
    if ( n_read == -1 )
    {
      v2 = infile;
      v3 = __errno_location();
      error(0, *v3, "%s", v2);
      return 0;
    }
    if ( !n_read )
      break;
    if ( full_write(1, buf, n_read) != n_read )
    {
      v4 = gettext("write error");
      v5 = __errno_location();
      error(1, *v5, v4);
    }
  }
  return 1;
}

//----- (08049108) --------------------------------------------------------
bool __cdecl cat(
        char *inbuf,
        size_t insize,
        char *outbuf,
        size_t outsize,
        bool show_nonprinting,
        bool show_tabs,
        bool number,
        bool number_nonblank,
        bool show_ends,
        bool squeeze_blank)
{
  char *v10; // ebx
  int *v11; // eax
  const char *v12; // esi
  char *v13; // ebx
  int *v14; // eax
  const char *v15; // ebx
  int *v16; // eax
  char *v17; // eax
  char *v18; // eax
  char *v19; // eax
  char *v20; // eax
  char *v21; // eax
  char *v22; // edx
  char *v23; // eax
  char *v24; // eax
  char *v25; // eax
  char *v26; // eax
  char *v27; // eax
  char *v28; // eax
  int n_to_read; // [esp+38h] [ebp-30h] BYREF
  size_t remaining_bytes; // [esp+3Ch] [ebp-2Ch]
  char *wp; // [esp+40h] [ebp-28h]
  int newlines; // [esp+44h] [ebp-24h]
  size_t n_read; // [esp+48h] [ebp-20h]
  char *bpout; // [esp+4Ch] [ebp-1Ch] BYREF
  char *eob; // [esp+50h] [ebp-18h]
  char *bpin; // [esp+54h] [ebp-14h]
  bool input_pending; // [esp+59h] [ebp-Fh]
  bool use_fionread; // [esp+5Ah] [ebp-Eh]
  unsigned __int8 ch_0; // [esp+5Bh] [ebp-Dh]

  newlines = newlines2;
  use_fionread = 1;
  eob = inbuf;
  bpin = inbuf + 1;
  bpout = outbuf;
LABEL_2:
  while ( 2 )
  {
    if ( &outbuf[outsize] <= bpout )
    {
      wp = outbuf;
      do
      {
        if ( full_write(1, wp, outsize) != outsize )
        {
          v10 = gettext("write error");
          v11 = __errno_location();
          error(1, *v11, v10);
        }
        wp += outsize;
        remaining_bytes = bpout - wp;
      }
      while ( outsize <= bpout - wp );
      memmove(outbuf, wp, remaining_bytes);
      bpout = &outbuf[remaining_bytes];
    }
    if ( bpin <= eob )
    {
      if ( ++newlines > 0 )
      {
        if ( newlines > 1 )
        {
          newlines = 2;
          if ( squeeze_blank )
          {
            ch_0 = *bpin++;
            goto LABEL_37;
          }
        }
        if ( number && !number_nonblank )
        {
          next_line_num();
          bpout = (char *)stpcpy(bpout, line_num_print);
        }
      }
      if ( show_ends )
      {
        v17 = bpout;
        *bpout = 36;
        bpout = v17 + 1;
      }
      v18 = bpout;
      *bpout = 10;
      bpout = v18 + 1;
LABEL_36:
      ch_0 = *bpin++;
LABEL_37:
      if ( ch_0 == 10 )
        continue;
      if ( newlines >= 0 && number )
      {
        next_line_num();
        bpout = (char *)stpcpy(bpout, line_num_print);
      }
      if ( show_nonprinting )
      {
        while ( 1 )
        {
          if ( ch_0 <= 0x1Fu )
          {
            if ( ch_0 != 9 || show_tabs )
            {
              if ( ch_0 == 10 )
              {
                newlines = -1;
                goto LABEL_2;
              }
              v26 = bpout;
              *bpout = 94;
              v26[1] = ch_0 + 64;
              bpout = v26 + 2;
            }
            else
            {
              v25 = bpout;
              *bpout = 9;
              bpout = v25 + 1;
            }
          }
          else if ( ch_0 > 0x7Eu )
          {
            if ( ch_0 == 127 )
            {
              v20 = bpout;
              *bpout = 94;
              *++v20 = 63;
              bpout = v20 + 1;
            }
            else
            {
              v21 = bpout;
              *bpout = 77;
              *++v21 = 45;
              bpout = v21 + 1;
              if ( ch_0 <= 0x9Fu )
              {
                v24 = bpout;
                *bpout = 94;
                v24[1] = ch_0 - 64;
                bpout = v24 + 2;
              }
              else if ( ch_0 == 0xFF )
              {
                v23 = bpout;
                *bpout = 94;
                *++v23 = 63;
                bpout = v23 + 1;
              }
              else
              {
                v22 = bpout;
                *bpout = ch_0 + 0x80;
                bpout = v22 + 1;
              }
            }
          }
          else
          {
            v19 = bpout;
            *bpout = ch_0;
            bpout = v19 + 1;
          }
          ch_0 = *bpin++;
        }
      }
      while ( 1 )
      {
        if ( ch_0 != 9 || !show_tabs )
        {
          if ( ch_0 == 10 )
          {
            newlines = -1;
            goto LABEL_2;
          }
          v28 = bpout;
          *bpout = ch_0;
          bpout = v28 + 1;
        }
        else
        {
          v27 = bpout;
          *bpout = 94;
          v27[1] = ch_0 + 64;
          bpout = v27 + 2;
        }
        ch_0 = *bpin++;
      }
    }
    break;
  }
  input_pending = 0;
  n_to_read = 0;
  if ( !use_fionread || ioctl(input_desc, 0x541Bu, &n_to_read) >= 0 )
  {
LABEL_18:
    if ( n_to_read )
      input_pending = 1;
    if ( input_pending )
      write_pending(outbuf, &bpout);
    n_read = safe_read(input_desc, inbuf, insize);
    if ( n_read == -1 )
    {
      v15 = infile;
      v16 = __errno_location();
      error(0, *v16, "%s", v15);
      write_pending(outbuf, &bpout);
      newlines2 = newlines;
      return 0;
    }
    if ( !n_read )
    {
      write_pending(outbuf, &bpout);
      newlines2 = newlines;
      return 1;
    }
    bpin = inbuf;
    eob = &inbuf[n_read];
    inbuf[n_read] = 10;
    goto LABEL_36;
  }
  if ( *__errno_location() == 95
    || *__errno_location() == 25
    || *__errno_location() == 22
    || *__errno_location() == 19
    || *__errno_location() == 38 )
  {
    use_fionread = 0;
    goto LABEL_18;
  }
  v12 = quote(infile);
  v13 = gettext("cannot do ioctl on %s");
  v14 = __errno_location();
  error(0, *v14, v13, v12);
  newlines2 = newlines;
  return 0;
}
// 8048BBC: using guessed type int __cdecl stpcpy(_DWORD, _DWORD);

//----- (080495FB) --------------------------------------------------------
void __cdecl write_pending(char *outbuf, char **bpout)
{
  char *v2; // ebx
  int *v3; // eax
  int n_write; // [esp+20h] [ebp-8h]

  n_write = *bpout - outbuf;
  if ( n_write )
  {
    if ( full_write(1, outbuf, n_write) != n_write )
    {
      v2 = gettext("write error");
      v3 = __errno_location();
      error(1, *v3, v2);
    }
    *bpout = outbuf;
  }
}

//----- (08049671) --------------------------------------------------------
int __cdecl __noreturn main(int argc, const char **argv, const char **envp)
{
  char *v3; // ebx
  int *v4; // eax
  const char *v5; // ebx
  int *v6; // eax
  const char *v7; // ebx
  char *v8; // eax
  bool v9; // bl
  char *v10; // eax
  bool v11; // bl
  bool v12; // si
  bool v13; // di
  char *v14; // eax
  const char *v15; // ebx
  int *v16; // eax
  char *v17; // ebx
  int *v18; // eax
  size_t v19; // [esp+4h] [ebp-DCh]
  size_t st_blksize; // [esp+10h] [ebp-D0h]
  size_t v21; // [esp+14h] [ebp-CCh]
  bool v22; // [esp+18h] [ebp-C8h]
  bool v23; // [esp+1Ch] [ebp-C4h]
  bool v24; // [esp+20h] [ebp-C0h]
  bool v25; // [esp+24h] [ebp-BCh]
  char *v26; // [esp+28h] [ebp-B8h]
  stat stat_buf; // [esp+30h] [ebp-B0h] BYREF
  ino_t out_ino; // [esp+90h] [ebp-50h]
  dev_t out_dev; // [esp+98h] [ebp-48h]
  int file_open_mode; // [esp+A4h] [ebp-3Ch]
  int argind; // [esp+A8h] [ebp-38h]
  int c; // [esp+ACh] [ebp-34h]
  char *outbuf; // [esp+B0h] [ebp-30h]
  char *inbuf; // [esp+B4h] [ebp-2Ch]
  size_t page_size; // [esp+B8h] [ebp-28h]
  size_t insize; // [esp+BCh] [ebp-24h]
  size_t outsize; // [esp+C0h] [ebp-20h]
  bool show_tabs; // [esp+C7h] [ebp-19h]
  bool show_nonprinting; // [esp+C8h] [ebp-18h]
  bool show_ends; // [esp+C9h] [ebp-17h]
  bool squeeze_blank; // [esp+CAh] [ebp-16h]
  bool number_nonblank; // [esp+CBh] [ebp-15h]
  bool number; // [esp+CCh] [ebp-14h]
  bool have_read_stdin; // [esp+CDh] [ebp-13h]
  bool check_redirection; // [esp+CEh] [ebp-12h]
  bool ok; // [esp+CFh] [ebp-11h]
  int *p_argc; // [esp+D0h] [ebp-10h]

  p_argc = &argc;
  page_size = getpagesize();
  ok = 1;
  check_redirection = 1;
  have_read_stdin = 0;
  number = 0;
  number_nonblank = 0;
  squeeze_blank = 0;
  show_ends = 0;
  show_nonprinting = 0;
  show_tabs = 0;
  file_open_mode = 0;
  program_name = (char *)*argv;
  setlocale(6, &locale);
  bindtextdomain("coreutils", "/usr/local/share/locale");
  textdomain("coreutils");
  atexit((void (__cdecl *)(void *))close_stdout);
  while ( 1 )
  {
    c = getopt_long(argc, (char *const *)argv, "benstuvAET", long_options_4647, 0);
    if ( c == -1 )
      break;
    if ( c == 98 )
    {
      number = 1;
      number_nonblank = 1;
    }
    else if ( c > 98 )
    {
      if ( c == 115 )
      {
        squeeze_blank = 1;
      }
      else if ( c > 115 )
      {
        if ( c != 117 )
        {
          if ( c < 117 )
          {
            show_tabs = 1;
            show_nonprinting = 1;
          }
          else
          {
            if ( c != 118 )
              goto LABEL_32;
            show_nonprinting = 1;
          }
        }
      }
      else if ( c == 101 )
      {
        show_ends = 1;
        show_nonprinting = 1;
      }
      else
      {
        if ( c != 110 )
          goto LABEL_32;
        number = 1;
      }
    }
    else if ( c == 65 )
    {
      show_nonprinting = 1;
      show_ends = 1;
      show_tabs = 1;
    }
    else
    {
      if ( c <= 65 )
      {
        if ( c == -131 )
        {
          version_etc(stdout, "cat", "GNU coreutils", "6.10", "Torbjorn Granlund", "Richard M. Stallman", 0);
          exit(0);
        }
        if ( c == -130 )
          usage(0);
LABEL_32:
        usage(1);
      }
      if ( c == 69 )
      {
        show_ends = 1;
      }
      else
      {
        if ( c != 84 )
          goto LABEL_32;
        show_tabs = 1;
      }
    }
  }
  if ( fstat64(1, (int)&stat_buf) < 0 )
  {
    v3 = gettext("standard output");
    v4 = __errno_location();
    error(1, *v4, v3);
  }
  if ( stat_buf.st_blksize <= 0 || stat_buf.st_blksize > 0x20000000u )
    st_blksize = 512;
  else
    st_blksize = stat_buf.st_blksize;
  outsize = st_blksize;
  if ( (stat_buf.st_mode & 0xF000) == 0x8000 )
  {
    out_dev = stat_buf.st_dev;
    out_ino = stat_buf.st_ino;
  }
  else
  {
    check_redirection = 0;
  }
  infile = "-";
  argind = optind;
  while ( 1 )
  {
    if ( argind < argc )
      infile = argv[argind];
    if ( !strcmp(infile, "-") )
    {
      have_read_stdin = 1;
      input_desc = 0;
    }
    else
    {
      input_desc = open64(infile, file_open_mode);
      if ( input_desc < 0 )
        goto LABEL_68;
    }
    if ( fstat64(input_desc, (int)&stat_buf) >= 0 )
    {
      if ( stat_buf.st_blksize <= 0 || stat_buf.st_blksize > 0x20000000u )
        v21 = 512;
      else
        v21 = stat_buf.st_blksize;
      insize = v21;
      if ( check_redirection && out_dev == stat_buf.st_dev && out_ino == stat_buf.st_ino && input_desc )
      {
        v7 = infile;
        v8 = gettext("%s: input file is output file");
        error(0, 0, v8, v7);
        ok = 0;
      }
      else
      {
        if ( show_tabs || show_nonprinting || show_ends || number || squeeze_blank )
        {
          inbuf = (char *)xmalloc(page_size + insize);
          outbuf = (char *)xmalloc(page_size + outsize + 4 * insize + 18);
          v11 = ok;
          v12 = squeeze_blank;
          v13 = show_ends;
          v22 = number_nonblank;
          v23 = number;
          v24 = show_tabs;
          v25 = show_nonprinting;
          v26 = (char *)ptr_align(outbuf, page_size);
          v14 = (char *)ptr_align(inbuf, page_size);
          ok = (v11 & cat(v14, insize, v26, outsize, v25, v24, v23, v22, v13, v12)) != 0;
          free(outbuf);
        }
        else
        {
          v19 = outsize;
          if ( outsize < insize )
            v19 = insize;
          insize = v19;
          inbuf = (char *)xmalloc(page_size + v19 - 1);
          v9 = ok;
          v10 = (char *)ptr_align(inbuf, page_size);
          ok = (v9 & simple_cat(v10, insize)) != 0;
        }
        free(inbuf);
      }
    }
    else
    {
      v5 = infile;
      v6 = __errno_location();
      error(0, *v6, "%s", v5);
      ok = 0;
    }
    if ( strcmp(infile, "-") && close(input_desc) < 0 )
    {
LABEL_68:
      v15 = infile;
      v16 = __errno_location();
      error(0, *v16, "%s", v15);
      ok = 0;
    }
    if ( ++argind >= argc )
    {
      if ( have_read_stdin && close(0) < 0 )
      {
        v17 = gettext("closing standard input");
        v18 = __errno_location();
        error(1, *v18, v17);
      }
      exit(!ok);
    }
  }
}
// 8048B2C: using guessed type int __cdecl open64(_DWORD, _DWORD);
// 8052100: using guessed type int optind;

//----- (08049DB4) --------------------------------------------------------
void *__cdecl ptr_align(const void *ptr, size_t alignment)
{
  return (char *)ptr + alignment - ((unsigned int)ptr + alignment - 1) % alignment - 1;
}

//----- (08049DE8) --------------------------------------------------------
size_t __cdecl full_write(int fd, const void *buf, size_t count)
{
  size_t n_rw; // [esp+1Ch] [ebp-Ch]
  size_t total; // [esp+24h] [ebp-4h]

  total = 0;
  while ( count )
  {
    n_rw = safe_write(fd, buf, count);
    if ( n_rw == -1 )
      break;
    if ( !n_rw )
    {
      *__errno_location() = 28;
      return total;
    }
    total += n_rw;
    buf = (char *)buf + n_rw;
    count -= n_rw;
  }
  return total;
}

//----- (08049E50) --------------------------------------------------------
void __cdecl version_etc_va(
        FILE *stream,
        const char *command_name,
        const char *package,
        const char *version,
        va_list authors)
{
  _DWORD *v5; // edx
  char *v6; // edx
  char *v7; // [esp+4h] [ebp-24h]
  char *v8; // [esp+4h] [ebp-24h]
  char *v9; // [esp+4h] [ebp-24h]
  char *v10; // [esp+4h] [ebp-24h]
  char *v11; // [esp+4h] [ebp-24h]
  char *v12; // [esp+4h] [ebp-24h]
  char *v13; // [esp+4h] [ebp-24h]
  char *v14; // [esp+4h] [ebp-24h]
  char *v15; // [esp+4h] [ebp-24h]
  char *v16; // [esp+4h] [ebp-24h]
  char *v17; // [esp+8h] [ebp-20h]
  va_list tmp_authors; // [esp+1Ch] [ebp-Ch]
  size_t n_authors; // [esp+20h] [ebp-8h]

  tmp_authors = authors;
  for ( n_authors = 0; ; ++n_authors )
  {
    v5 = tmp_authors;
    tmp_authors += 4;
    if ( !*v5 )
      break;
  }
  if ( command_name )
    fprintf(stream, "%s (%s) %s\n", command_name, package, version);
  else
    fprintf(stream, "%s %s\n", package, version);
  v17 = gettext("(C)");
  fprintf(stream, "Copyright %s %d Free Software Foundation, Inc.", v17, 2008);
  v6 = gettext(
         "\n"
         "License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\n"
         "This is free software: you are free to change and redistribute it.\n"
         "There is NO WARRANTY, to the extent permitted by law.\n"
         "\n");
  fputs_unlocked(v6, stream);
  switch ( n_authors )
  {
    case 0u:
      abort();
      return;
    case 1u:
      v7 = gettext("Written by %s.\n");
      rpl_vfprintf(stream, v7, authors);
      break;
    case 2u:
      v8 = gettext("Written by %s and %s.\n");
      rpl_vfprintf(stream, v8, authors);
      break;
    case 3u:
      v9 = gettext("Written by %s, %s, and %s.\n");
      rpl_vfprintf(stream, v9, authors);
      break;
    case 4u:
      v10 = gettext("Written by %s, %s, %s,\nand %s.\n");
      rpl_vfprintf(stream, v10, authors);
      break;
    case 5u:
      v11 = gettext("Written by %s, %s, %s,\n%s, and %s.\n");
      rpl_vfprintf(stream, v11, authors);
      break;
    case 6u:
      v12 = gettext("Written by %s, %s, %s,\n%s, %s, and %s.\n");
      rpl_vfprintf(stream, v12, authors);
      break;
    case 7u:
      v13 = gettext("Written by %s, %s, %s,\n%s, %s, %s, and %s.\n");
      rpl_vfprintf(stream, v13, authors);
      break;
    case 8u:
      v14 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n");
      rpl_vfprintf(stream, v14, authors);
      break;
    case 9u:
      v15 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n");
      rpl_vfprintf(stream, v15, authors);
      break;
    default:
      v16 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n");
      rpl_vfprintf(stream, v16, authors);
      break;
  }
}
// 8048B3C: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (0804A0AF) --------------------------------------------------------
void version_etc(FILE *stream, const char *command_name, const char *package, const char *version, ...)
{
  va_list va; // [esp+40h] [ebp+18h] BYREF

  va_start(va, version);
  version_etc_va(stream, command_name, package, version, va);
}

//----- (0804A0E4) --------------------------------------------------------
void __cdecl close_stdout_set_file_name(const char *file)
{
  file_name = file;
}

//----- (0804A0F1) --------------------------------------------------------
void close_stdout()
{
  char *v0; // ebx
  int *v1; // eax
  int *v2; // eax
  char *write_error; // [esp+20h] [ebp-8h]

  if ( close_stream(stdout) )
  {
    write_error = gettext("write error");
    if ( file_name )
    {
      v0 = quotearg_colon(file_name);
      v1 = __errno_location();
      error(0, *v1, "%s: %s", v0, write_error);
    }
    else
    {
      v2 = __errno_location();
      error(0, *v2, "%s", write_error);
    }
    _exit(exit_failure);
  }
  if ( close_stream(stderr) )
    _exit(exit_failure);
}

//----- (0804A1B8) --------------------------------------------------------
const char *__cdecl quote_n(int n, const char *name)
{
  return quotearg_n_style(n, locale_quoting_style, name);
}

//----- (0804A1DA) --------------------------------------------------------
const char *__cdecl quote(const char *name)
{
  return quote_n(0, name);
}

//----- (0804A1F8) --------------------------------------------------------
quoting_options *__cdecl clone_quoting_options(quoting_options *o)
{
  quoting_options *v2; // [esp+14h] [ebp-14h]
  quoting_options *p; // [esp+20h] [ebp-8h]
  int e; // [esp+24h] [ebp-4h]

  e = *__errno_location();
  if ( o )
    v2 = o;
  else
    v2 = &default_quoting_options;
  p = (quoting_options *)xmemdup(v2, 0x24u);
  *__errno_location() = e;
  return p;
}

//----- (0804A244) --------------------------------------------------------
quoting_style __cdecl get_quoting_style(quoting_options *o)
{
  quoting_options *v2; // [esp+0h] [ebp-4h]

  if ( o )
    v2 = o;
  else
    v2 = &default_quoting_options;
  return v2->style;
}

//----- (0804A266) --------------------------------------------------------
void __cdecl set_quoting_style(quoting_options *o, quoting_style s)
{
  quoting_options *v2; // [esp+0h] [ebp-4h]

  if ( o )
    v2 = o;
  else
    v2 = &default_quoting_options;
  v2->style = s;
}

//----- (0804A28B) --------------------------------------------------------
int __cdecl set_char_quoting(quoting_options *o, char c, int i)
{
  quoting_options *v4; // [esp+0h] [ebp-18h]
  int r; // [esp+8h] [ebp-10h]

  if ( o )
    v4 = o;
  else
    v4 = &default_quoting_options;
  r = (v4->quote_these_too[(unsigned __int8)c >> 5] >> (c & 0x1F)) & 1;
  v4->quote_these_too[(unsigned __int8)c >> 5] ^= (r ^ i & 1) << (c & 0x1F);
  return r;
}

//----- (0804A305) --------------------------------------------------------
const char *__cdecl gettext_quote(const char *msgid, quoting_style s)
{
  char *translation; // [esp+14h] [ebp-4h]

  translation = gettext(msgid);
  if ( translation == msgid && s == clocale_quoting_style )
    return (const char *)L"\"`'";
  return translation;
}
// 805067C: using guessed type __int16 asc_805067C[4];

//----- (0804A333) --------------------------------------------------------
size_t __cdecl quotearg_buffer_restyled(
        char *buffer,
        size_t buffersize,
        const char *arg,
        size_t argsize,
        quoting_style quoting_style,
        const quoting_options *o)
{
  unsigned int v7; // [esp+24h] [ebp-54h]
  bool v8; // [esp+32h] [ebp-46h]
  mbstate_t mbstate; // [esp+3Ch] [ebp-3Ch] BYREF
  size_t ilim; // [esp+44h] [ebp-34h]
  size_t j; // [esp+48h] [ebp-30h]
  size_t bytes; // [esp+4Ch] [ebp-2Ch]
  wchar_t w; // [esp+50h] [ebp-28h] BYREF
  size_t m; // [esp+54h] [ebp-24h]
  const char *right; // [esp+58h] [ebp-20h]
  const char *left; // [esp+5Ch] [ebp-1Ch]
  size_t quote_string_len; // [esp+60h] [ebp-18h]
  const char *quote_string; // [esp+64h] [ebp-14h]
  size_t len; // [esp+68h] [ebp-10h]
  size_t i; // [esp+6Ch] [ebp-Ch]
  bool printable; // [esp+73h] [ebp-5h]
  unsigned __int8 esc; // [esp+74h] [ebp-4h]
  unsigned __int8 c; // [esp+75h] [ebp-3h]
  bool unibyte_locale; // [esp+76h] [ebp-2h]
  bool backslash_escapes; // [esp+77h] [ebp-1h]

  len = 0;
  quote_string = 0;
  quote_string_len = 0;
  backslash_escapes = 0;
  unibyte_locale = __ctype_get_mb_cur_max() == 1;
  switch ( quoting_style )
  {
    case shell_always_quoting_style:
      if ( len < buffersize )
        buffer[len] = 39;
      ++len;
      quote_string = (_BYTE *)(L"\"`'" + 4);
      quote_string_len = 1;
      break;
    case c_quoting_style:
      if ( len < buffersize )
        buffer[len] = 34;
      ++len;
      backslash_escapes = 1;
      quote_string = (const char *)L"\"`'";
      quote_string_len = 1;
      break;
    case escape_quoting_style:
      backslash_escapes = 1;
      break;
    case locale_quoting_style:
    case clocale_quoting_style:
      left = gettext_quote((const char *)L"`'", quoting_style);
      right = gettext_quote((const char *)L"'", quoting_style);
      for ( quote_string = left; *quote_string; ++quote_string )
      {
        if ( len < buffersize )
          buffer[len] = *quote_string;
        ++len;
      }
      backslash_escapes = 1;
      quote_string = right;
      quote_string_len = strlen(right);
      break;
    default:
      break;
  }
  for ( i = 0; argsize == -1 ? arg[i] != 0 : i != argsize; ++i )
  {
    if ( backslash_escapes
      && quote_string_len
      && i + quote_string_len <= argsize
      && !memcmp(&arg[i], quote_string, quote_string_len) )
    {
      if ( len < buffersize )
        buffer[len] = 92;
      ++len;
    }
    c = arg[i];
    switch ( c )
    {
      case 0u:
        if ( backslash_escapes )
        {
          if ( len < buffersize )
            buffer[len] = 92;
          if ( ++len < buffersize )
            buffer[len] = 48;
          if ( ++len < buffersize )
            buffer[len] = 48;
          ++len;
          c = 48;
        }
        goto LABEL_110;
      case 7u:
        esc = 97;
        goto c_escape;
      case 8u:
        esc = 98;
        goto c_escape;
      case 9u:
        esc = 116;
        goto c_and_shell_escape;
      case 0xAu:
        esc = 110;
        goto c_and_shell_escape;
      case 0xBu:
        esc = 118;
        goto c_escape;
      case 0xCu:
        esc = 102;
        goto c_escape;
      case 0xDu:
        esc = 114;
        goto c_and_shell_escape;
      case 0x20u:
      case 0x21u:
      case 0x22u:
      case 0x24u:
      case 0x26u:
      case 0x28u:
      case 0x29u:
      case 0x2Au:
      case 0x3Bu:
      case 0x3Cu:
      case 0x3Du:
      case 0x3Eu:
      case 0x5Bu:
      case 0x5Eu:
      case 0x60u:
      case 0x7Cu:
        goto LABEL_61;
      case 0x23u:
      case 0x7Eu:
        goto LABEL_60;
      case 0x25u:
      case 0x2Bu:
      case 0x2Cu:
      case 0x2Du:
      case 0x2Eu:
      case 0x2Fu:
      case 0x30u:
      case 0x31u:
      case 0x32u:
      case 0x33u:
      case 0x34u:
      case 0x35u:
      case 0x36u:
      case 0x37u:
      case 0x38u:
      case 0x39u:
      case 0x3Au:
      case 0x41u:
      case 0x42u:
      case 0x43u:
      case 0x44u:
      case 0x45u:
      case 0x46u:
      case 0x47u:
      case 0x48u:
      case 0x49u:
      case 0x4Au:
      case 0x4Bu:
      case 0x4Cu:
      case 0x4Du:
      case 0x4Eu:
      case 0x4Fu:
      case 0x50u:
      case 0x51u:
      case 0x52u:
      case 0x53u:
      case 0x54u:
      case 0x55u:
      case 0x56u:
      case 0x57u:
      case 0x58u:
      case 0x59u:
      case 0x5Au:
      case 0x5Du:
      case 0x5Fu:
      case 0x61u:
      case 0x62u:
      case 0x63u:
      case 0x64u:
      case 0x65u:
      case 0x66u:
      case 0x67u:
      case 0x68u:
      case 0x69u:
      case 0x6Au:
      case 0x6Bu:
      case 0x6Cu:
      case 0x6Du:
      case 0x6Eu:
      case 0x6Fu:
      case 0x70u:
      case 0x71u:
      case 0x72u:
      case 0x73u:
      case 0x74u:
      case 0x75u:
      case 0x76u:
      case 0x77u:
      case 0x78u:
      case 0x79u:
      case 0x7Au:
        goto LABEL_110;
      case 0x27u:
        if ( quoting_style == shell_quoting_style )
          return quotearg_buffer_restyled(buffer, buffersize, arg, argsize, shell_always_quoting_style, o);
        if ( quoting_style == shell_always_quoting_style )
        {
          if ( len < buffersize )
            buffer[len] = 39;
          if ( ++len < buffersize )
            buffer[len] = 92;
          if ( ++len < buffersize )
            buffer[len] = 39;
          ++len;
        }
        goto LABEL_110;
      case 0x3Fu:
        if ( quoting_style == shell_quoting_style )
          return quotearg_buffer_restyled(buffer, buffersize, arg, argsize, shell_always_quoting_style, o);
        if ( quoting_style == c_quoting_style && i + 2 < argsize && arg[i + 1] == 63 )
        {
          v7 = arg[i + 2] - 33;
          if ( v7 <= 0x1D && ((1 << v7) & 0x380051C1) != 0 )
          {
            c = arg[i + 2];
            i += 2;
            if ( len < buffersize )
              buffer[len] = 63;
            if ( ++len < buffersize )
              buffer[len] = 92;
            if ( ++len < buffersize )
              buffer[len] = 63;
            ++len;
          }
        }
        goto LABEL_110;
      case 0x5Cu:
        esc = c;
c_and_shell_escape:
        if ( quoting_style == shell_quoting_style )
          return quotearg_buffer_restyled(buffer, buffersize, arg, argsize, shell_always_quoting_style, o);
c_escape:
        if ( !backslash_escapes )
          goto LABEL_110;
        c = esc;
        goto store_escape;
      case 0x7Bu:
      case 0x7Du:
        if ( argsize == -1 )
          v8 = arg[1] != 0;
        else
          v8 = argsize != 1;
        if ( v8 )
          goto LABEL_110;
LABEL_60:
        if ( i )
          goto LABEL_110;
LABEL_61:
        if ( quoting_style != shell_quoting_style )
          goto LABEL_110;
        return quotearg_buffer_restyled(buffer, buffersize, arg, argsize, shell_always_quoting_style, o);
      default:
        if ( unibyte_locale )
        {
          m = 1;
          printable = ((*__ctype_b_loc())[c] & 0x4000) != 0;
          goto LABEL_93;
        }
        memset(&mbstate, 0, sizeof(mbstate));
        m = 0;
        printable = 1;
        if ( argsize == -1 )
          argsize = strlen(arg);
        break;
    }
    do
    {
      bytes = mbrtowc(&w, &arg[m + i], argsize - (i + m), &mbstate);
      if ( !bytes )
        break;
      if ( bytes == -1 )
      {
        printable = 0;
        break;
      }
      if ( bytes == -2 )
      {
        printable = 0;
        while ( i + m < argsize && arg[m + i] )
          ++m;
        break;
      }
      if ( quoting_style == shell_quoting_style )
      {
        j = 1;
        while ( 2 )
        {
          if ( j < bytes )
          {
            switch ( arg[j + m + i] )
            {
              case '[':
              case '\\':
              case '^':
              case '`':
              case '|':
                return quotearg_buffer_restyled(buffer, buffersize, arg, argsize, shell_always_quoting_style, o);
              default:
                ++j;
                continue;
            }
          }
          break;
        }
      }
      if ( !iswprint(w) )
        printable = 0;
      m += bytes;
    }
    while ( !mbsinit(&mbstate) );
LABEL_93:
    if ( m <= 1 && (!backslash_escapes || printable) )
    {
LABEL_110:
      if ( backslash_escapes && (o->quote_these_too[c >> 5] & (1 << (c & 0x1F))) != 0 )
      {
store_escape:
        if ( len < buffersize )
          buffer[len] = 92;
        ++len;
      }
    }
    else
    {
      ilim = i + m;
      while ( 1 )
      {
        if ( backslash_escapes && !printable )
        {
          if ( len < buffersize )
            buffer[len] = 92;
          if ( ++len < buffersize )
            buffer[len] = (c >> 6) + 48;
          if ( ++len < buffersize )
            buffer[len] = ((c >> 3) & 7) + 48;
          ++len;
          c = (c & 7) + 48;
        }
        if ( i + 1 >= ilim )
          break;
        if ( len < buffersize )
          buffer[len] = c;
        ++len;
        c = arg[++i];
      }
    }
    if ( len < buffersize )
      buffer[len] = c;
    ++len;
  }
  if ( !i && quoting_style == shell_quoting_style )
    return quotearg_buffer_restyled(buffer, buffersize, arg, argsize, shell_always_quoting_style, o);
  if ( quote_string )
  {
    while ( *quote_string )
    {
      if ( len < buffersize )
        buffer[len] = *quote_string;
      ++len;
      ++quote_string;
    }
  }
  if ( len < buffersize )
    buffer[len] = 0;
  return len;
}
// 805067C: using guessed type __int16 asc_805067C[4];

//----- (0804AA7F) --------------------------------------------------------
size_t __cdecl quotearg_buffer(
        char *buffer,
        size_t buffersize,
        const char *arg,
        size_t argsize,
        const quoting_options *o)
{
  quoting_options *v6; // [esp+24h] [ebp-14h]
  size_t r; // [esp+2Ch] [ebp-Ch]
  int e; // [esp+30h] [ebp-8h]

  if ( o )
    v6 = (quoting_options *)o;
  else
    v6 = &default_quoting_options;
  e = *__errno_location();
  r = quotearg_buffer_restyled(buffer, buffersize, arg, argsize, v6->style, v6);
  *__errno_location() = e;
  return r;
}

//----- (0804AAEE) --------------------------------------------------------
char *__cdecl quotearg_alloc(const char *arg, size_t argsize, const quoting_options *o)
{
  char *buf; // [esp+1Ch] [ebp-Ch]
  size_t bufsize; // [esp+20h] [ebp-8h]
  int e; // [esp+24h] [ebp-4h]

  e = *__errno_location();
  bufsize = quotearg_buffer(0, 0, arg, argsize, o) + 1;
  buf = xcharalloc(bufsize);
  quotearg_buffer(buf, bufsize, arg, argsize, o);
  *__errno_location() = e;
  return buf;
}

//----- (0804AB73) --------------------------------------------------------
void quotearg_free()
{
  unsigned int i; // [esp+10h] [ebp-8h]
  slotvec *sv; // [esp+14h] [ebp-4h]

  sv = slotvec_0;
  for ( i = 1; i < nslots; ++i )
    free(sv[i].val);
  if ( sv->val != slot0 )
  {
    free(sv->val);
    slotvec0.size = 256;
    slotvec0.val = slot0;
  }
  if ( sv != &slotvec0 )
  {
    free(sv);
    slotvec_0 = &slotvec0;
  }
  nslots = 1;
}

//----- (0804AC05) --------------------------------------------------------
char *__cdecl quotearg_n_options(int n, const char *arg, size_t argsize, const quoting_options *options)
{
  char *v4; // edx
  slotvec *p; // [esp+20h] [ebp-28h]
  size_t qsize; // [esp+24h] [ebp-24h]
  char *val; // [esp+28h] [ebp-20h]
  size_t sizea; // [esp+2Ch] [ebp-1Ch]
  size_t size; // [esp+2Ch] [ebp-1Ch]
  size_t n1; // [esp+30h] [ebp-18h]
  slotvec *sv; // [esp+34h] [ebp-14h]
  int e; // [esp+3Ch] [ebp-Ch]
  bool preallocated; // [esp+43h] [ebp-5h]

  e = *__errno_location();
  sv = slotvec_0;
  if ( n < 0 )
    abort();
  if ( nslots <= n )
  {
    n1 = n + 1;
    preallocated = slotvec_0 == &slotvec0;
    if ( (unsigned int)(n + 1) > 0x1FFFFFFF )
      xalloc_die();
    if ( slotvec_0 == &slotvec0 )
      p = 0;
    else
      p = slotvec_0;
    sv = (slotvec *)xrealloc(p, 8 * n1);
    slotvec_0 = sv;
    if ( preallocated )
    {
      v4 = slotvec0.val;
      sv->size = slotvec0.size;
      sv->val = v4;
    }
    memset(&sv[nslots], 0, 8 * (n1 - nslots));
    nslots = n + 1;
  }
  sizea = sv[n].size;
  val = sv[n].val;
  qsize = quotearg_buffer(val, sizea, arg, argsize, options);
  if ( sizea <= qsize )
  {
    size = qsize + 1;
    sv[n].size = qsize + 1;
    if ( val != slot0 )
      free(val);
    val = xcharalloc(size);
    sv[n].val = val;
    quotearg_buffer(val, size, arg, argsize, options);
  }
  *__errno_location() = e;
  return val;
}

//----- (0804ADC5) --------------------------------------------------------
char *__cdecl quotearg_n(int n, const char *arg)
{
  return quotearg_n_options(n, arg, 0xFFFFFFFF, &default_quoting_options);
}

//----- (0804ADEF) --------------------------------------------------------
char *__cdecl quotearg(const char *arg)
{
  return quotearg_n(0, arg);
}

//----- (0804AE0A) --------------------------------------------------------
quoting_options *quoting_options_from_style(quoting_options *retstr, quoting_style style)
{
  quoting_options o; // [esp+20h] [ebp-28h] BYREF

  memset(o.quote_these_too, 0, sizeof(o.quote_these_too));
  retstr->style = style;
  retstr->quote_these_too[0] = o.quote_these_too[0];
  retstr->quote_these_too[1] = o.quote_these_too[1];
  retstr->quote_these_too[2] = o.quote_these_too[2];
  retstr->quote_these_too[3] = o.quote_these_too[3];
  retstr->quote_these_too[4] = o.quote_these_too[4];
  retstr->quote_these_too[5] = o.quote_these_too[5];
  retstr->quote_these_too[6] = o.quote_these_too[6];
  retstr->quote_these_too[7] = o.quote_these_too[7];
  return retstr;
}
// 804AE0A: inconsistent function type and number of purged bytes

//----- (0804AE77) --------------------------------------------------------
char *__cdecl quotearg_n_style(int n, quoting_style s, const char *arg)
{
  quoting_options o; // [esp+24h] [ebp-24h] BYREF

  quoting_options_from_style(&o, s);
  return quotearg_n_options(n, arg, 0xFFFFFFFF, &o);
}

//----- (0804AEB5) --------------------------------------------------------
char *__cdecl quotearg_n_style_mem(int n, quoting_style s, const char *arg, size_t argsize)
{
  quoting_options o; // [esp+24h] [ebp-24h] BYREF

  quoting_options_from_style(&o, s);
  return quotearg_n_options(n, arg, argsize, &o);
}

//----- (0804AEF2) --------------------------------------------------------
char *__cdecl quotearg_style(quoting_style s, const char *arg)
{
  return quotearg_n_style(0, s, arg);
}

//----- (0804AF14) --------------------------------------------------------
char *__cdecl quotearg_char(const char *arg, char ch_0)
{
  quoting_options options; // [esp+24h] [ebp-24h] BYREF

  options = default_quoting_options;
  set_char_quoting(&options, ch_0, 1);
  return quotearg_n_options(0, arg, 0xFFFFFFFF, &options);
}

//----- (0804AFA7) --------------------------------------------------------
char *__cdecl quotearg_colon(const char *arg)
{
  return quotearg_char(arg, 58);
}

//----- (0804AFC4) --------------------------------------------------------
size_t __cdecl safe_read(int fd, void *buf, size_t count)
{
  signed int result; // [esp+24h] [ebp-4h]

  while ( 1 )
  {
    do
    {
      result = read(fd, buf, count);
      if ( result >= 0 )
        return result;
    }
    while ( *__errno_location() == 4 );
    if ( *__errno_location() != 22 || count <= 0x7FFFE000 )
      break;
    count = 2147475456;
  }
  return result;
}

//----- (0804B02C) --------------------------------------------------------
size_t __cdecl safe_write(int fd, const void *buf, size_t count)
{
  signed int result; // [esp+24h] [ebp-4h]

  while ( 1 )
  {
    do
    {
      result = write(fd, buf, count);
      if ( result >= 0 )
        return result;
    }
    while ( *__errno_location() == 4 );
    if ( *__errno_location() != 22 || count <= 0x7FFFE000 )
      break;
    count = 2147475456;
  }
  return result;
}

//----- (0804B094) --------------------------------------------------------
int __cdecl rpl_vfprintf(FILE *fp, const char *format, va_list args)
{
  size_t v3; // eax
  int saved_errno; // [esp+34h] [ebp-7E4h]
  size_t lenbuf; // [esp+38h] [ebp-7E0h] BYREF
  size_t len; // [esp+3Ch] [ebp-7DCh]
  char *output; // [esp+40h] [ebp-7D8h]
  char buf[2000]; // [esp+44h] [ebp-7D4h] BYREF
  unsigned int v11; // [esp+814h] [ebp-4h]

  v11 = __readgsdword(0x14u);
  lenbuf = 2000;
  output = vasnprintf(buf, &lenbuf, format, args);
  len = lenbuf;
  if ( output )
  {
    v3 = fwrite(output, 1u, len, fp);
    if ( v3 >= len )
    {
      if ( (len & 0x80000000) == 0 )
      {
        return len;
      }
      else
      {
        *__errno_location() = 75;
        fseterr(fp);
        return -1;
      }
    }
    else
    {
      if ( output != buf )
      {
        saved_errno = *__errno_location();
        free(output);
        *__errno_location() = saved_errno;
      }
      return -1;
    }
  }
  else
  {
    fseterr(fp);
    return -1;
  }
}

//----- (0804B1FC) --------------------------------------------------------
void *__cdecl xnmalloc(size_t n, size_t s)
{
  if ( 0xFFFFFFFF / s < n )
    xalloc_die();
  return xmalloc(s * n);
}

//----- (0804B22A) --------------------------------------------------------
void *__cdecl xnrealloc(void *p, size_t n, size_t s)
{
  if ( 0xFFFFFFFF / s < n )
    xalloc_die();
  return xrealloc(p, s * n);
}

//----- (0804B25F) --------------------------------------------------------
void *__cdecl x2nrealloc(void *p, size_t *pn, size_t s)
{
  unsigned int n; // [esp+24h] [ebp-4h]

  n = *pn;
  if ( p )
  {
    if ( 0xAAAAAAAA / s <= n )
      xalloc_die();
    n += (n + 1) >> 1;
  }
  else if ( !n )
  {
    n = (0x40 / s == 0) + 0x40 / s;
  }
  *pn = n;
  return xrealloc(p, s * n);
}

//----- (0804B2DA) --------------------------------------------------------
char *__cdecl xcharalloc(size_t n)
{
  return (char *)xmalloc(n);
}

//----- (0804B2ED) --------------------------------------------------------
void *__cdecl xmalloc(size_t n)
{
  void *p; // [esp+14h] [ebp-4h]

  p = malloc(n);
  if ( !p && n )
    xalloc_die();
  return p;
}

//----- (0804B317) --------------------------------------------------------
void *__cdecl xrealloc(void *p, size_t n)
{
  void *pa; // [esp+10h] [ebp+8h]

  pa = realloc(p, n);
  if ( !pa && n )
    xalloc_die();
  return pa;
}

//----- (0804B348) --------------------------------------------------------
void *__cdecl x2realloc(void *p, size_t *pn)
{
  return x2nrealloc(p, pn, 1u);
}

//----- (0804B36A) --------------------------------------------------------
void *__cdecl xzalloc(size_t s)
{
  void *v1; // edx

  v1 = xmalloc(s);
  return memset(v1, 0, s);
}

//----- (0804B396) --------------------------------------------------------
void *__cdecl xcalloc(size_t n, size_t s)
{
  void *p; // [esp+14h] [ebp-4h]

  p = calloc(n, s);
  if ( !p )
    xalloc_die();
  return p;
}

//----- (0804B3C1) --------------------------------------------------------
void *__cdecl xmemdup(const void *p, size_t s)
{
  void *v2; // edx

  v2 = xmalloc(s);
  return memcpy(v2, p, s);
}

//----- (0804B3EC) --------------------------------------------------------
char *__cdecl xstrdup(const char *string)
{
  size_t v2; // [esp+4h] [ebp-4h]

  v2 = strlen(string) + 1;
  return (char *)xmemdup(string, v2);
}

//----- (0804B414) --------------------------------------------------------
void __cdecl fseterr(FILE *fp)
{
  fp->_flags |= 0x20u;
}

//----- (0804B428) --------------------------------------------------------
void __noreturn xalloc_die()
{
  char *v0; // eax

  v0 = gettext("memory exhausted");
  error(exit_failure, 0, "%s", v0);
  abort();
}

//----- (0804B464) --------------------------------------------------------
int __cdecl close_stream(FILE *stream)
{
  bool fclose_fail; // [esp+15h] [ebp-3h]
  bool prev_fail; // [esp+16h] [ebp-2h]
  bool some_pending; // [esp+17h] [ebp-1h]

  some_pending = __fpending(stream) != 0;
  prev_fail = ferror_unlocked(stream) != 0;
  fclose_fail = fclose(stream) != 0;
  if ( !prev_fail && (!fclose_fail || !some_pending && *__errno_location() == 9) )
    return 0;
  if ( !fclose_fail )
    *__errno_location() = 0;
  return -1;
}

//----- (0804B4F4) --------------------------------------------------------
int __cdecl is_infinitel(long double x)
{
  return rpl_isnanl(x) || x == x + x && x != 0.0;
}

//----- (0804B55A) --------------------------------------------------------
char *__cdecl vasnprintf(char *resultbuf, size_t *lengthp, const char *format, va_list args)
{
  void *v4; // esp
  _DWORD *a_count_int_pointer; // ecx
  argument *v6; // eax
  unsigned int v7; // ecx
  unsigned int v8; // edx
  __int16 v9; // ax
  size_t v10; // eax
  size_t v11; // eax
  argument *v12; // eax
  int v13; // edx
  argument *v14; // eax
  unsigned int v15; // ecx
  unsigned int v16; // edx
  size_t v17; // eax
  size_t v18; // eax
  size_t v19; // eax
  char *v20; // eax
  long double v21; // [esp+0h] [ebp-558h]
  long double v22; // [esp+0h] [ebp-558h]
  _BYTE v23[8]; // [esp+30h] [ebp-528h] BYREF
  unsigned int v24; // [esp+38h] [ebp-520h]
  unsigned int v25; // [esp+3Ch] [ebp-51Ch]
  unsigned int v26; // [esp+40h] [ebp-518h]
  unsigned int v27; // [esp+44h] [ebp-514h]
  unsigned int v28; // [esp+48h] [ebp-510h]
  unsigned int v29; // [esp+4Ch] [ebp-50Ch]
  unsigned int v30; // [esp+50h] [ebp-508h]
  unsigned int v31; // [esp+54h] [ebp-504h]
  unsigned int v32; // [esp+58h] [ebp-500h]
  unsigned int v33; // [esp+5Ch] [ebp-4FCh]
  unsigned int v34; // [esp+60h] [ebp-4F8h]
  unsigned int v35; // [esp+64h] [ebp-4F4h]
  unsigned int v36; // [esp+68h] [ebp-4F0h]
  unsigned int v37; // [esp+6Ch] [ebp-4ECh]
  unsigned int v38; // [esp+70h] [ebp-4E8h]
  unsigned int v39; // [esp+74h] [ebp-4E4h]
  unsigned int v40; // [esp+78h] [ebp-4E0h]
  int v41; // [esp+7Ch] [ebp-4DCh]
  int v42; // [esp+84h] [ebp-4D4h]
  _BYTE *v44; // [esp+8Ch] [ebp-4CCh]
  size_t v45; // [esp+90h] [ebp-4C8h]
  size_t v46; // [esp+94h] [ebp-4C4h]
  size_t v47; // [esp+98h] [ebp-4C0h]
  size_t v48; // [esp+9Ch] [ebp-4BCh]
  size_t size2; // [esp+A0h] [ebp-4B8h]
  size_t size1; // [esp+A4h] [ebp-4B4h]
  size_t v51; // [esp+A8h] [ebp-4B0h]
  size_t v52; // [esp+ACh] [ebp-4ACh]
  size_t v53; // [esp+B0h] [ebp-4A8h]
  size_t v54; // [esp+B4h] [ebp-4A4h]
  size_t v55; // [esp+B8h] [ebp-4A0h]
  size_t v56; // [esp+BCh] [ebp-49Ch]
  size_t v57; // [esp+C0h] [ebp-498h]
  size_t v58; // [esp+C4h] [ebp-494h]
  size_t v59; // [esp+C8h] [ebp-490h]
  size_t v60; // [esp+CCh] [ebp-48Ch]
  size_t v61; // [esp+D0h] [ebp-488h]
  size_t v62; // [esp+D4h] [ebp-484h]
  size_t v63; // [esp+D8h] [ebp-480h]
  size_t v64; // [esp+DCh] [ebp-47Ch]
  va_list argsa; // [esp+E0h] [ebp-478h]
  const char *formata; // [esp+E4h] [ebp-474h]
  size_t *lengthpa; // [esp+E8h] [ebp-470h]
  char *resultbufa; // [esp+ECh] [ebp-46Ch]
  char_directives d; // [esp+F0h] [ebp-468h] BYREF
  long double v70; // [esp+100h] [ebp-458h]
  long double x; // [esp+110h] [ebp-448h]
  double a_double; // [esp+128h] [ebp-430h]
  unsigned __int64 a_ulonglongint; // [esp+130h] [ebp-428h]
  __int64 v74; // [esp+138h] [ebp-420h]
  int prefixes[2]; // [esp+140h] [ebp-418h]
  arguments a; // [esp+148h] [ebp-410h] BYREF
  char *memory_6; // [esp+150h] [ebp-408h]
  char *memory_5; // [esp+154h] [ebp-404h]
  size_t memory_size_5; // [esp+158h] [ebp-400h]
  char *memory_4; // [esp+15Ch] [ebp-3FCh]
  size_t memory_size_4; // [esp+160h] [ebp-3F8h]
  size_t n_3; // [esp+164h] [ebp-3F4h]
  char *memory_3; // [esp+168h] [ebp-3F0h]
  size_t memory_size_3; // [esp+16Ch] [ebp-3ECh]
  size_t bigger_need; // [esp+170h] [ebp-3E8h]
  void *a_pointer; // [esp+174h] [ebp-3E4h]
  const wchar_t *a_wide_string; // [esp+178h] [ebp-3E0h]
  const char *a_string; // [esp+17Ch] [ebp-3DCh]
  wint_t v89; // [esp+180h] [ebp-3D8h]
  int v90; // [esp+184h] [ebp-3D4h]
  unsigned int v91; // [esp+188h] [ebp-3D0h]
  int v92; // [esp+18Ch] [ebp-3CCh]
  unsigned int a_uint; // [esp+190h] [ebp-3C8h]
  int a_int; // [esp+194h] [ebp-3C4h]
  unsigned int a_ushort; // [esp+198h] [ebp-3C0h]
  int a_short; // [esp+19Ch] [ebp-3BCh]
  unsigned int a_uchar; // [esp+1A0h] [ebp-3B8h]
  int a_schar; // [esp+1A4h] [ebp-3B4h]
  size_t maxlen; // [esp+1A8h] [ebp-3B0h]
  int retcount; // [esp+1ACh] [ebp-3ACh]
  int count_0; // [esp+1B0h] [ebp-3A8h] BYREF
  char *memory_2; // [esp+1B4h] [ebp-3A4h]
  size_t memory_size_2; // [esp+1B8h] [ebp-3A0h]
  size_t n_2; // [esp+1C0h] [ebp-398h]
  size_t n_1; // [esp+1C8h] [ebp-390h]
  unsigned int prefix_count; // [esp+1CCh] [ebp-38Ch]
  char *fbp; // [esp+1D0h] [ebp-388h]
  int flags_0; // [esp+1D4h] [ebp-384h]
  arg_type type; // [esp+1D8h] [ebp-380h]
  char *memory_1; // [esp+1DCh] [ebp-37Ch]
  size_t memory_size_1; // [esp+1E0h] [ebp-378h]
  size_t n_0; // [esp+1E4h] [ebp-374h]
  size_t count; // [esp+1E8h] [ebp-370h]
  char *q_0; // [esp+1ECh] [ebp-36Ch]
  char *q; // [esp+1F0h] [ebp-368h]
  char *end; // [esp+1F4h] [ebp-364h]
  size_t pad; // [esp+1F8h] [ebp-360h]
  int sign; // [esp+1FCh] [ebp-35Ch]
  size_t tmp_memsize; // [esp+200h] [ebp-358h]
  const char *digitp_0; // [esp+204h] [ebp-354h]
  int v121; // [esp+208h] [ebp-350h]
  const char *digitp; // [esp+20Ch] [ebp-34Ch]
  int arg; // [esp+210h] [ebp-348h]
  char *p; // [esp+214h] [ebp-344h]
  char *pad_ptr; // [esp+218h] [ebp-340h]
  char *tmp; // [esp+21Ch] [ebp-33Ch]
  size_t tmp_length; // [esp+220h] [ebp-338h]
  size_t precision; // [esp+224h] [ebp-334h]
  int has_precision; // [esp+228h] [ebp-330h]
  size_t width; // [esp+22Ch] [ebp-32Ch]
  int has_width; // [esp+230h] [ebp-328h]
  int flags; // [esp+234h] [ebp-324h]
  char *memory_0; // [esp+238h] [ebp-320h]
  size_t memory_size_0; // [esp+23Ch] [ebp-31Ch]
  size_t augmented_length_0; // [esp+240h] [ebp-318h]
  char *memory; // [esp+244h] [ebp-314h]
  size_t memory_size; // [esp+248h] [ebp-310h]
  size_t augmented_length; // [esp+24Ch] [ebp-30Ch]
  size_t n; // [esp+250h] [ebp-308h]
  size_t buf_memsize; // [esp+254h] [ebp-304h]
  size_t length; // [esp+258h] [ebp-300h]
  size_t allocated; // [esp+25Ch] [ebp-2FCh]
  char *result; // [esp+260h] [ebp-2F8h]
  char_directive *dp; // [esp+264h] [ebp-2F4h]
  size_t i; // [esp+268h] [ebp-2F0h]
  const char *cp; // [esp+26Ch] [ebp-2ECh]
  char *buf_malloced; // [esp+270h] [ebp-2E8h]
  char *buf; // [esp+274h] [ebp-2E4h]
  size_t buf_neededlength; // [esp+278h] [ebp-2E0h]
  fpucw_t oldcw; // [esp+27Eh] [ebp-2DAh]
  char tmpbuf[700]; // [esp+280h] [ebp-2D8h] BYREF
  unsigned int v152; // [esp+53Ch] [ebp-1Ch]

  resultbufa = resultbuf;
  lengthpa = lengthp;
  formata = format;
  argsa = args;
  v152 = __readgsdword(0x14u);
  if ( printf_parse(format, &d, &a) < 0 )
    return 0;
  if ( printf_fetchargs(argsa, &a) < 0 )
  {
    free(d.dir);
    if ( a.arg )
      free(a.arg);
    *__errno_location() = 22;
    return 0;
  }
  buf_neededlength = xsum4(7u, d.max_width_length, d.max_precision_length, 6u);
  if ( buf_neededlength > 0xF9F )
  {
    buf_memsize = buf_neededlength;
    if ( buf_neededlength == -1 )
      goto out_of_memory_1;
    buf = (char *)malloc(buf_memsize);
    if ( !buf )
      goto out_of_memory_1;
    buf_malloced = buf;
  }
  else
  {
    v4 = alloca(16 * ((buf_neededlength + 30) >> 4));
    v44 = v23;
    buf = v23;
    buf_malloced = 0;
  }
  if ( resultbufa )
  {
    result = resultbufa;
    allocated = *lengthpa;
  }
  else
  {
    result = 0;
    allocated = 0;
  }
  length = 0;
  cp = formata;
  i = 0;
  for ( dp = d.dir; ; ++dp )
  {
    if ( dp->dir_start != cp )
    {
      n = dp->dir_start - cp;
      augmented_length = xsum(length, n);
      if ( augmented_length > allocated )
      {
        if ( allocated )
        {
          if ( (allocated & 0x80000000) != 0 )
            v46 = -1;
          else
            v46 = 2 * allocated;
          v45 = v46;
        }
        else
        {
          v45 = 12;
        }
        allocated = v45;
        if ( augmented_length > v45 )
          allocated = augmented_length;
        memory_size = allocated;
        if ( allocated == -1 )
          goto out_of_memory;
        memory = (char *)(result != resultbufa && result ? realloc(result, memory_size) : malloc(memory_size));
        if ( !memory )
          goto out_of_memory;
        if ( result == resultbufa && length )
          memcpy(memory, result, length);
        result = memory;
      }
      memcpy(&result[length], cp, n);
      length = augmented_length;
    }
    if ( d.count == i )
      break;
    if ( dp->conversion == 37 )
    {
      if ( dp->arg_index != -1 )
        abort();
      augmented_length_0 = xsum(length, 1u);
      if ( augmented_length_0 > allocated )
      {
        if ( allocated )
        {
          if ( (allocated & 0x80000000) != 0 )
            v48 = -1;
          else
            v48 = 2 * allocated;
          v47 = v48;
        }
        else
        {
          v47 = 12;
        }
        allocated = v47;
        if ( augmented_length_0 > v47 )
          allocated = augmented_length_0;
        memory_size_0 = allocated;
        if ( allocated == -1 )
          goto out_of_memory;
        memory_0 = (char *)(result != resultbufa && result ? realloc(result, memory_size_0) : malloc(memory_size_0));
        if ( !memory_0 )
          goto out_of_memory;
        if ( result == resultbufa && length )
          memcpy(memory_0, result, length);
        result = memory_0;
      }
      result[length] = 37;
      length = augmented_length_0;
    }
    else
    {
      if ( dp->arg_index == -1 )
        abort();
      if ( dp->conversion == 110 )
      {
        v42 = a.arg[dp->arg_index].type - 18;
        switch ( v42 )
        {
          case 0:
            *a.arg[dp->arg_index].a.a_count_schar_pointer = length;
            break;
          case 1:
            *a.arg[dp->arg_index].a.a_count_short_pointer = length;
            break;
          case 2:
            *a.arg[dp->arg_index].a.a_count_int_pointer = length;
            break;
          case 3:
            *a.arg[dp->arg_index].a.a_count_int_pointer = length;
            break;
          case 4:
            a_count_int_pointer = a.arg[dp->arg_index].a.a_count_int_pointer;
            *a_count_int_pointer = length;
            a_count_int_pointer[1] = 0;
            break;
          default:
            abort();
            return v20;
        }
      }
      else
      {
        if ( dp->conversion != 102
          && dp->conversion != 70
          && dp->conversion != 101
          && dp->conversion != 69
          && dp->conversion != 103
          && dp->conversion != 71
          && dp->conversion != 97
          && dp->conversion != 65
          || a.arg[dp->arg_index].type != TYPE_LONGDOUBLE
          || !is_infinitel(a.arg[dp->arg_index].a.a_longdouble) )
        {
          type = a.arg[dp->arg_index].type;
          flags_0 = dp->flags;
          fbp = buf;
          *buf = 37;
          ++fbp;
          if ( (flags_0 & 1) != 0 )
            *fbp++ = 39;
          if ( (flags_0 & 2) != 0 )
            *fbp++ = 45;
          if ( (flags_0 & 4) != 0 )
            *fbp++ = 43;
          if ( (flags_0 & 8) != 0 )
            *fbp++ = 32;
          if ( (flags_0 & 0x10) != 0 )
            *fbp++ = 35;
          if ( (flags_0 & 0x20) != 0 )
            *fbp++ = 48;
          if ( dp->width_start != dp->width_end )
          {
            n_1 = dp->width_end - dp->width_start;
            memcpy(fbp, dp->width_start, n_1);
            fbp += n_1;
          }
          if ( dp->precision_start != dp->precision_end )
          {
            n_2 = dp->precision_end - dp->precision_start;
            memcpy(fbp, dp->precision_start, n_2);
            fbp += n_2;
          }
          if ( (unsigned int)type <= TYPE_WIDE_STRING )
          {
            v41 = 1 << type;
            if ( ((1 << type) & 0x14180) != 0 )
              goto LABEL_207;
            if ( (v41 & 0x1000) != 0 )
            {
              *fbp++ = 76;
            }
            else if ( (v41 & 0x600) != 0 )
            {
              *fbp++ = 108;
LABEL_207:
              *fbp++ = 108;
            }
          }
          *(_WORD *)fbp = (unsigned __int8)dp->conversion;
          prefix_count = 0;
          if ( dp->width_arg_index != -1 )
          {
            if ( a.arg[dp->width_arg_index].type != TYPE_INT )
              abort();
            prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;
          }
          if ( dp->precision_arg_index != -1 )
          {
            if ( a.arg[dp->precision_arg_index].type != TYPE_INT )
              abort();
            prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;
          }
          v10 = xsum(length, 2u);
          if ( v10 > allocated )
          {
            if ( allocated )
            {
              if ( (allocated & 0x80000000) != 0 )
                v56 = -1;
              else
                v56 = 2 * allocated;
              v55 = v56;
            }
            else
            {
              v55 = 12;
            }
            allocated = v55;
            v11 = xsum(length, 2u);
            if ( v11 > allocated )
              allocated = xsum(length, 2u);
            memory_size_2 = allocated;
            if ( allocated != -1 )
            {
              memory_2 = (char *)(result != resultbufa && result ? realloc(result, memory_size_2) : malloc(memory_size_2));
              if ( memory_2 )
              {
                if ( result == resultbufa && length )
                  memcpy(memory_2, result, length);
                result = memory_2;
                goto LABEL_236;
              }
            }
out_of_memory:
            if ( result != resultbufa && result )
              free(result);
            if ( buf_malloced )
              free(buf_malloced);
out_of_memory_1:
            free(d.dir);
            if ( a.arg )
              free(a.arg);
            *__errno_location() = 12;
            return 0;
          }
LABEL_236:
          result[length] = 0;
          while ( 1 )
          {
            count_0 = -1;
            retcount = 0;
            maxlen = allocated - length;
            if ( (int)(allocated - length) < 0 )
              maxlen = 0x7FFFFFFF;
            switch ( type )
            {
              case TYPE_SCHAR:
                a_schar = a.arg[dp->arg_index].a.a_schar;
                v40 = prefix_count;
                if ( prefix_count == 1 )
                {
                  retcount = snprintf(&result[length], maxlen, buf, prefixes[0], a_schar, &count_0);
                }
                else if ( v40 )
                {
                  if ( v40 != 2 )
                    abort();
                  retcount = snprintf(&result[length], maxlen, buf, prefixes[0], prefixes[1], a_schar, &count_0);
                }
                else
                {
                  retcount = snprintf(&result[length], maxlen, buf, a_schar, &count_0);
                }
                break;
              case TYPE_UCHAR:
                a_uchar = a.arg[dp->arg_index].a.a_uchar;
                v39 = prefix_count;
                if ( prefix_count == 1 )
                {
                  retcount = snprintf(&result[length], maxlen, buf, prefixes[0], a_uchar, &count_0);
                }
                else if ( v39 )
                {
                  if ( v39 != 2 )
                    abort();
                  retcount = snprintf(&result[length], maxlen, buf, prefixes[0], prefixes[1], a_uchar, &count_0);
                }
                else
                {
                  retcount = snprintf(&result[length], maxlen, buf, a_uchar, &count_0);
                }
                break;
              case TYPE_SHORT:
                a_short = a.arg[dp->arg_index].a.a_short;
                v38 = prefix_count;
                if ( prefix_count == 1 )
                {
                  retcount = snprintf(&result[length], maxlen, buf, prefixes[0], a_short, &count_0);
                }
                else if ( v38 )
                {
                  if ( v38 != 2 )
                    abort();
                  retcount = snprintf(&result[length], maxlen, buf, prefixes[0], prefixes[1], a_short, &count_0);
                }
                else
                {
                  retcount = snprintf(&result[length], maxlen, buf, a_short, &count_0);
                }
                break;
              case TYPE_USHORT:
                a_ushort = a.arg[dp->arg_index].a.a_ushort;
                v37 = prefix_count;
                if ( prefix_count == 1 )
                {
                  retcount = snprintf(&result[length], maxlen, buf, prefixes[0], a_ushort, &count_0);
                }
                else if ( v37 )
                {
                  if ( v37 != 2 )
                    abort();
                  retcount = snprintf(&result[length], maxlen, buf, prefixes[0], prefixes[1], a_ushort, &count_0);
                }
                else
                {
                  retcount = snprintf(&result[length], maxlen, buf, a_ushort, &count_0);
                }
                break;
              case TYPE_INT:
                a_int = a.arg[dp->arg_index].a.a_int;
                v36 = prefix_count;
                if ( prefix_count == 1 )
                {
                  retcount = snprintf(&result[length], maxlen, buf, prefixes[0], a_int, &count_0);
                }
                else if ( v36 )
                {
                  if ( v36 != 2 )
                    abort();
                  retcount = snprintf(&result[length], maxlen, buf, prefixes[0], prefixes[1], a_int, &count_0);
                }
                else
                {
                  retcount = snprintf(&result[length], maxlen, buf, a_int, &count_0);
                }
                break;
              case TYPE_UINT:
                a_uint = a.arg[dp->arg_index].a.a_uint;
                v35 = prefix_count;
                if ( prefix_count == 1 )
                {
                  retcount = snprintf(&result[length], maxlen, buf, prefixes[0], a_uint, &count_0);
                }
                else if ( v35 )
                {
                  if ( v35 != 2 )
                    abort();
                  retcount = snprintf(&result[length], maxlen, buf, prefixes[0], prefixes[1], a_uint, &count_0);
                }
                else
                {
                  retcount = snprintf(&result[length], maxlen, buf, a_uint, &count_0);
                }
                break;
              case TYPE_LONGINT:
                v92 = a.arg[dp->arg_index].a.a_int;
                v34 = prefix_count;
                if ( prefix_count == 1 )
                {
                  retcount = snprintf(&result[length], maxlen, buf, prefixes[0], v92, &count_0);
                }
                else if ( v34 )
                {
                  if ( v34 != 2 )
                    abort();
                  retcount = snprintf(&result[length], maxlen, buf, prefixes[0], prefixes[1], v92, &count_0);
                }
                else
                {
                  retcount = snprintf(&result[length], maxlen, buf, v92, &count_0);
                }
                break;
              case TYPE_ULONGINT:
                v91 = a.arg[dp->arg_index].a.a_uint;
                v33 = prefix_count;
                if ( prefix_count == 1 )
                {
                  retcount = snprintf(&result[length], maxlen, buf, prefixes[0], v91, &count_0);
                }
                else if ( v33 )
                {
                  if ( v33 != 2 )
                    abort();
                  retcount = snprintf(&result[length], maxlen, buf, prefixes[0], prefixes[1], v91, &count_0);
                }
                else
                {
                  retcount = snprintf(&result[length], maxlen, buf, v91, &count_0);
                }
                break;
              case TYPE_LONGLONGINT:
                v12 = &a.arg[dp->arg_index];
                v13 = *((_DWORD *)&v12->a.a_ushort + 1);
                LODWORD(v74) = v12->a.a_int;
                HIDWORD(v74) = v13;
                v32 = prefix_count;
                if ( prefix_count == 1 )
                {
                  retcount = snprintf(&result[length], maxlen, buf, prefixes[0], v74, &count_0);
                }
                else if ( v32 )
                {
                  if ( v32 != 2 )
                    abort();
                  retcount = snprintf(&result[length], maxlen, buf, prefixes[0], prefixes[1], v74, &count_0);
                }
                else
                {
                  retcount = snprintf(&result[length], maxlen, buf, v74, &count_0);
                }
                break;
              case TYPE_ULONGLONGINT:
                a_ulonglongint = a.arg[dp->arg_index].a.a_ulonglongint;
                v31 = prefix_count;
                if ( prefix_count == 1 )
                {
                  retcount = snprintf(&result[length], maxlen, buf, prefixes[0], a_ulonglongint, &count_0);
                }
                else if ( v31 )
                {
                  if ( v31 != 2 )
                    abort();
                  retcount = snprintf(&result[length], maxlen, buf, prefixes[0], prefixes[1], a_ulonglongint, &count_0);
                }
                else
                {
                  retcount = snprintf(&result[length], maxlen, buf, a_ulonglongint, &count_0);
                }
                break;
              case TYPE_DOUBLE:
                a_double = a.arg[dp->arg_index].a.a_double;
                v30 = prefix_count;
                if ( prefix_count == 1 )
                {
                  retcount = snprintf(&result[length], maxlen, buf, prefixes[0], a_double, &count_0);
                }
                else if ( v30 )
                {
                  if ( v30 != 2 )
                    abort();
                  retcount = snprintf(&result[length], maxlen, buf, prefixes[0], prefixes[1], a_double, &count_0);
                }
                else
                {
                  retcount = snprintf(&result[length], maxlen, buf, a_double, &count_0);
                }
                break;
              case TYPE_LONGDOUBLE:
                v14 = &a.arg[dp->arg_index];
                v15 = *(&v14->a.a_ulongint + 2);
                v16 = *((_DWORD *)&v14->a.a_ushort + 1);
                LODWORD(v70) = v14->a.a_int;
                *(_QWORD *)((char *)&v70 + 4) = __PAIR64__(v15, v16);
                v29 = prefix_count;
                if ( prefix_count == 1 )
                {
                  retcount = snprintf(
                               &result[length],
                               maxlen,
                               buf,
                               prefixes[0],
                               *(_QWORD *)&v70,
                               HIDWORD(v70),
                               &count_0);
                }
                else if ( v29 )
                {
                  if ( v29 != 2 )
                    abort();
                  retcount = snprintf(
                               &result[length],
                               maxlen,
                               buf,
                               prefixes[0],
                               prefixes[1],
                               *(_QWORD *)&v70,
                               HIDWORD(v70),
                               &count_0);
                }
                else
                {
                  retcount = snprintf(&result[length], maxlen, buf, *(_QWORD *)&v70, HIDWORD(v70), &count_0);
                }
                break;
              case TYPE_CHAR:
                v90 = a.arg[dp->arg_index].a.a_int;
                v28 = prefix_count;
                if ( prefix_count == 1 )
                {
                  retcount = snprintf(&result[length], maxlen, buf, prefixes[0], v90, &count_0);
                }
                else if ( v28 )
                {
                  if ( v28 != 2 )
                    abort();
                  retcount = snprintf(&result[length], maxlen, buf, prefixes[0], prefixes[1], v90, &count_0);
                }
                else
                {
                  retcount = snprintf(&result[length], maxlen, buf, v90, &count_0);
                }
                break;
              case TYPE_WIDE_CHAR:
                v89 = a.arg[dp->arg_index].a.a_uint;
                v27 = prefix_count;
                if ( prefix_count == 1 )
                {
                  retcount = snprintf(&result[length], maxlen, buf, prefixes[0], v89, &count_0);
                }
                else if ( v27 )
                {
                  if ( v27 != 2 )
                    abort();
                  retcount = snprintf(&result[length], maxlen, buf, prefixes[0], prefixes[1], v89, &count_0);
                }
                else
                {
                  retcount = snprintf(&result[length], maxlen, buf, v89, &count_0);
                }
                break;
              case TYPE_STRING:
                a_string = a.arg[dp->arg_index].a.a_string;
                v26 = prefix_count;
                if ( prefix_count == 1 )
                {
                  retcount = snprintf(&result[length], maxlen, buf, prefixes[0], a_string, &count_0);
                }
                else if ( v26 )
                {
                  if ( v26 != 2 )
                    abort();
                  retcount = snprintf(&result[length], maxlen, buf, prefixes[0], prefixes[1], a_string, &count_0);
                }
                else
                {
                  retcount = snprintf(&result[length], maxlen, buf, a_string, &count_0);
                }
                break;
              case TYPE_WIDE_STRING:
                a_wide_string = a.arg[dp->arg_index].a.a_wide_string;
                v25 = prefix_count;
                if ( prefix_count == 1 )
                {
                  retcount = snprintf(&result[length], maxlen, buf, prefixes[0], a_wide_string, &count_0);
                }
                else if ( v25 )
                {
                  if ( v25 != 2 )
                    abort();
                  retcount = snprintf(&result[length], maxlen, buf, prefixes[0], prefixes[1], a_wide_string, &count_0);
                }
                else
                {
                  retcount = snprintf(&result[length], maxlen, buf, a_wide_string, &count_0);
                }
                break;
              case TYPE_POINTER:
                a_pointer = a.arg[dp->arg_index].a.a_pointer;
                v24 = prefix_count;
                if ( prefix_count == 1 )
                {
                  retcount = snprintf(&result[length], maxlen, buf, prefixes[0], a_pointer, &count_0);
                }
                else if ( v24 )
                {
                  if ( v24 != 2 )
                    abort();
                  retcount = snprintf(&result[length], maxlen, buf, prefixes[0], prefixes[1], a_pointer, &count_0);
                }
                else
                {
                  retcount = snprintf(&result[length], maxlen, buf, a_pointer, &count_0);
                }
                break;
              default:
                abort();
                return v20;
            }
            if ( count_0 < 0 )
            {
              if ( fbp[1] )
              {
                fbp[1] = 0;
                continue;
              }
              if ( retcount < 0 )
              {
                if ( (allocated & 0x80000000) != 0 )
                  v57 = -1;
                else
                  v57 = 2 * allocated;
                bigger_need = xsum(v57, 0xCu);
                if ( bigger_need > allocated )
                {
                  if ( allocated )
                  {
                    if ( (allocated & 0x80000000) != 0 )
                      v59 = -1;
                    else
                      v59 = 2 * allocated;
                    v58 = v59;
                  }
                  else
                  {
                    v58 = 12;
                  }
                  allocated = v58;
                  if ( bigger_need > v58 )
                    allocated = bigger_need;
                  memory_size_3 = allocated;
                  if ( allocated == -1 )
                    goto out_of_memory;
                  memory_3 = (char *)(result != resultbufa && result ? realloc(result, memory_size_3) : malloc(memory_size_3));
                  if ( !memory_3 )
                    goto out_of_memory;
                  if ( result == resultbufa && length )
                    memcpy(memory_3, result, length);
                  result = memory_3;
                }
                continue;
              }
              count_0 = retcount;
            }
            else
            {
              if ( count_0 < maxlen && result[length + count_0] )
                abort();
              if ( retcount > count_0 )
                count_0 = retcount;
            }
            if ( count_0 < 0 )
            {
              if ( result != resultbufa && result )
                free(result);
              if ( buf_malloced )
                free(buf_malloced);
              free(d.dir);
              if ( a.arg )
                free(a.arg);
              *__errno_location() = 22;
              return 0;
            }
            if ( count_0 + 1 < maxlen )
            {
              length += count_0;
              goto LABEL_426;
            }
            if ( maxlen == 0x7FFFFFFF )
            {
              if ( result != resultbufa && result )
                free(result);
              if ( buf_malloced )
                free(buf_malloced);
              free(d.dir);
              if ( a.arg )
                free(a.arg);
              *__errno_location() = 75;
              return 0;
            }
            if ( (allocated & 0x80000000) != 0 )
              v60 = -1;
            else
              v60 = 2 * allocated;
            v17 = xsum(length, count_0 + 2);
            n_3 = xmax(v17, v60);
            if ( n_3 > allocated )
            {
              if ( allocated )
              {
                if ( (allocated & 0x80000000) != 0 )
                  v62 = -1;
                else
                  v62 = 2 * allocated;
                v61 = v62;
              }
              else
              {
                v61 = 12;
              }
              allocated = v61;
              if ( n_3 > v61 )
                allocated = n_3;
              memory_size_4 = allocated;
              if ( allocated == -1 )
                goto out_of_memory;
              memory_4 = (char *)(result != resultbufa && result ? realloc(result, memory_size_4) : malloc(memory_size_4));
              if ( !memory_4 )
                goto out_of_memory;
              if ( result == resultbufa && length )
                memcpy(memory_4, result, length);
              result = memory_4;
            }
          }
        }
        flags = dp->flags;
        has_width = 0;
        width = 0;
        if ( dp->width_start != dp->width_end )
        {
          if ( dp->width_arg_index == -1 )
          {
            digitp = dp->width_start;
            do
            {
              size2 = *digitp++ - 48;
              if ( width > 0x19999999 )
                size1 = -1;
              else
                size1 = 10 * width;
              width = xsum(size1, size2);
            }
            while ( dp->width_end != digitp );
          }
          else
          {
            if ( a.arg[dp->width_arg_index].type != TYPE_INT )
              abort();
            arg = a.arg[dp->width_arg_index].a.a_int;
            if ( arg >= 0 )
            {
              width = arg;
            }
            else
            {
              flags |= 2u;
              width = -arg;
            }
          }
          has_width = 1;
        }
        has_precision = 0;
        precision = 0;
        if ( dp->precision_start != dp->precision_end )
        {
          if ( dp->precision_arg_index == -1 )
          {
            digitp_0 = dp->precision_start + 1;
            precision = 0;
            while ( dp->precision_end != digitp_0 )
            {
              v51 = *digitp_0++ - 48;
              if ( precision > 0x19999999 )
                v52 = -1;
              else
                v52 = 10 * precision;
              precision = xsum(v52, v51);
            }
            has_precision = 1;
          }
          else
          {
            if ( a.arg[dp->precision_arg_index].type != TYPE_INT )
              abort();
            v121 = a.arg[dp->precision_arg_index].a.a_int;
            if ( v121 >= 0 )
            {
              precision = v121;
              has_precision = 1;
            }
          }
        }
        if ( !has_precision )
          precision = 6;
        tmp_length = 0;
        if ( precision )
          tmp_length = precision;
        tmp_length = xsum(tmp_length, 0xCu);
        if ( tmp_length < width )
          tmp_length = width;
        tmp_length = xsum(tmp_length, 1u);
        if ( tmp_length > 0x2BC )
        {
          tmp_memsize = tmp_length;
          if ( tmp_length == -1 )
            goto out_of_memory;
          tmp = (char *)malloc(tmp_memsize);
          if ( !tmp )
            goto out_of_memory;
        }
        else
        {
          tmp = tmpbuf;
        }
        pad_ptr = 0;
        p = tmp;
        v6 = &a.arg[dp->arg_index];
        v7 = *(&v6->a.a_ulongint + 2);
        v8 = *((_DWORD *)&v6->a.a_ushort + 1);
        LODWORD(x) = v6->a.a_int;
        *(_QWORD *)((char *)&x + 4) = __PAIR64__(v7, v8);
        *(_QWORD *)&v21 = __PAIR64__(v8, LODWORD(x));
        HIDWORD(v21) = v7;
        if ( rpl_isnanl(v21) )
        {
          if ( dp->conversion <= 64 || dp->conversion > 90 )
          {
            *p++ = 110;
            *p++ = 97;
            *p++ = 110;
          }
          else
          {
            *p++ = 78;
            *p++ = 65;
            *p++ = 78;
          }
        }
        else
        {
          sign = 0;
          oldcw = count_0;
          LOBYTE(v9) = count_0;
          HIBYTE(v9) = BYTE1(count_0) | 3;
          LOWORD(count_0) = v9;
          v22 = x;
          if ( __signbitl(LODWORD(v22), DWORD1(v22), HIDWORD(v22)) )
          {
            sign = -1;
            x = -x;
          }
          if ( sign >= 0 )
          {
            if ( (flags & 4) != 0 )
            {
              *p++ = 43;
            }
            else if ( (flags & 8) != 0 )
            {
              *p++ = 32;
            }
          }
          else
          {
            *p++ = 45;
          }
          if ( x <= 0.0 || x != x + x )
            abort();
          if ( dp->conversion <= 64 || dp->conversion > 90 )
          {
            *p++ = 105;
            *p++ = 110;
            *p++ = 102;
          }
          else
          {
            *p++ = 73;
            *p++ = 78;
            *p++ = 70;
          }
          LOWORD(count_0) = oldcw;
        }
        if ( has_width && p - tmp < width )
        {
          pad = width + tmp - p;
          end = &tmp[width];
          if ( (flags & 2) != 0 )
          {
            while ( pad )
            {
              *p++ = 32;
              --pad;
            }
          }
          else if ( (flags & 0x20) != 0 && pad_ptr )
          {
            q = end;
            while ( p > pad_ptr )
              *--q = *--p;
            while ( pad )
            {
              *p++ = 48;
              --pad;
            }
          }
          else
          {
            q_0 = end;
            while ( p > tmp )
              *--q_0 = *--p;
            while ( pad )
            {
              *p++ = 32;
              --pad;
            }
          }
          p = end;
        }
        count = p - tmp;
        if ( p - tmp >= tmp_length )
          abort();
        if ( allocated - length <= count )
        {
          n_0 = xsum(length, count);
          if ( n_0 > allocated )
          {
            if ( allocated )
            {
              if ( (allocated & 0x80000000) != 0 )
                v54 = -1;
              else
                v54 = 2 * allocated;
              v53 = v54;
            }
            else
            {
              v53 = 12;
            }
            allocated = v53;
            if ( n_0 > v53 )
              allocated = n_0;
            memory_size_1 = allocated;
            if ( allocated == -1 )
              goto out_of_memory;
            memory_1 = (char *)(result != resultbufa && result ? realloc(result, memory_size_1) : malloc(memory_size_1));
            if ( !memory_1 )
              goto out_of_memory;
            if ( result == resultbufa && length )
              memcpy(memory_1, result, length);
            result = memory_1;
          }
        }
        memcpy(&result[length], tmp, count);
        if ( tmp != tmpbuf )
          free(tmp);
        length += count;
      }
    }
LABEL_426:
    cp = dp->dir_end;
    ++i;
  }
  v18 = xsum(length, 1u);
  if ( v18 > allocated )
  {
    if ( allocated )
    {
      if ( (allocated & 0x80000000) != 0 )
        v64 = -1;
      else
        v64 = 2 * allocated;
      v63 = v64;
    }
    else
    {
      v63 = 12;
    }
    allocated = v63;
    v19 = xsum(length, 1u);
    if ( v19 > allocated )
      allocated = xsum(length, 1u);
    memory_size_5 = allocated;
    if ( allocated == -1 )
      goto out_of_memory;
    memory_5 = (char *)(result != resultbufa && result ? realloc(result, memory_size_5) : malloc(memory_size_5));
    if ( !memory_5 )
      goto out_of_memory;
    if ( result == resultbufa && length )
      memcpy(memory_5, result, length);
    result = memory_5;
  }
  result[length] = 0;
  if ( result != resultbufa && length + 1 < allocated )
  {
    memory_6 = (char *)realloc(result, length + 1);
    if ( memory_6 )
      result = memory_6;
  }
  if ( buf_malloced )
    free(buf_malloced);
  free(d.dir);
  if ( a.arg )
    free(a.arg);
  *lengthpa = length;
  return result;
}
// 8048CCC: using guessed type int __cdecl __signbitl(_DWORD, _DWORD, _DWORD);

//----- (0804E995) --------------------------------------------------------
size_t __cdecl xsum4(size_t size1, size_t size2, size_t size3, size_t size4)
{
  size_t v4; // edx
  size_t v5; // edx

  v4 = xsum(size1, size2);
  v5 = xsum(v4, size3);
  return xsum(v5, size4);
}

//----- (0804E9D1) --------------------------------------------------------
size_t __cdecl xmax(size_t size1, size_t size2)
{
  size_t v3; // [esp+4h] [ebp-4h]

  v3 = size1;
  if ( size1 < size2 )
    return size2;
  return v3;
}

//----- (0804E9F6) --------------------------------------------------------
size_t __cdecl xsum(size_t size1, size_t size2)
{
  if ( size2 + size1 < size1 )
    return -1;
  else
    return size2 + size1;
}

//----- (0804EA24) --------------------------------------------------------
int __cdecl rpl_isnanl(long double x)
{
  if ( (WORD4(x) & 0x7FFF) == 0 )
    return DWORD1(x) >> 31;
  if ( (WORD4(x) & 0x7FFF) == 0x7FFF )
    return (DWORD1(x) ^ 0x80000000 | LODWORD(x)) != 0;
  return (DWORD1(x) & 0x80000000) == 0;
}

//----- (0804EA90) --------------------------------------------------------
int __cdecl printf_fetchargs(va_list args, arguments *a)
{
  va_list v2; // edx
  va_list v3; // edx
  va_list v4; // edx
  va_list v5; // edx
  va_list v6; // edx
  va_list v7; // edx
  va_list v8; // edx
  va_list v9; // edx
  va_list v10; // edx
  int *v11; // eax
  int v12; // edx
  va_list v13; // edx
  va_list v14; // edx
  int *v15; // eax
  unsigned int v16; // ecx
  int v17; // edx
  va_list v18; // edx
  va_list v19; // edx
  va_list v20; // edx
  va_list v21; // edx
  va_list v22; // edx
  va_list v23; // edx
  va_list v24; // edx
  va_list v25; // edx
  va_list v26; // edx
  va_list v27; // edx
  argument *ap; // [esp+10h] [ebp-Ch]
  size_t i; // [esp+14h] [ebp-8h]

  i = 0;
  ap = a->arg;
  while ( 2 )
  {
    if ( a->count > i )
    {
      switch ( ap->type )
      {
        case TYPE_SCHAR:
          v2 = args;
          args += 4;
          ap->a.a_schar = *(_DWORD *)v2;
          goto LABEL_27;
        case TYPE_UCHAR:
          v3 = args;
          args += 4;
          ap->a.a_schar = *(_DWORD *)v3;
          goto LABEL_27;
        case TYPE_SHORT:
          v4 = args;
          args += 4;
          ap->a.a_short = *(_DWORD *)v4;
          goto LABEL_27;
        case TYPE_USHORT:
          v5 = args;
          args += 4;
          ap->a.a_short = *(_DWORD *)v5;
          goto LABEL_27;
        case TYPE_INT:
          v6 = args;
          args += 4;
          ap->a.a_int = *(_DWORD *)v6;
          goto LABEL_27;
        case TYPE_UINT:
          v7 = args;
          args += 4;
          ap->a.a_int = *(_DWORD *)v7;
          goto LABEL_27;
        case TYPE_LONGINT:
          v8 = args;
          args += 4;
          ap->a.a_int = *(_DWORD *)v8;
          goto LABEL_27;
        case TYPE_ULONGINT:
          v9 = args;
          args += 4;
          ap->a.a_int = *(_DWORD *)v9;
          goto LABEL_27;
        case TYPE_LONGLONGINT:
        case TYPE_ULONGLONGINT:
          v10 = args;
          args += 8;
          v11 = (int *)v10;
          v12 = *((_DWORD *)v10 + 1);
          ap->a.a_int = *v11;
          *((_DWORD *)&ap->a.a_ushort + 1) = v12;
          goto LABEL_27;
        case TYPE_DOUBLE:
          v13 = args;
          args += 8;
          ap->a.a_double = *(double *)v13;
          goto LABEL_27;
        case TYPE_LONGDOUBLE:
          v14 = args;
          args += 12;
          v15 = (int *)v14;
          v16 = *((_DWORD *)v14 + 2);
          v17 = *((_DWORD *)v14 + 1);
          ap->a.a_int = *v15;
          *((_DWORD *)&ap->a.a_ushort + 1) = v17;
          *(&ap->a.a_ulongint + 2) = v16;
          goto LABEL_27;
        case TYPE_CHAR:
          v18 = args;
          args += 4;
          ap->a.a_int = *(_DWORD *)v18;
          goto LABEL_27;
        case TYPE_WIDE_CHAR:
          v19 = args;
          args += 4;
          ap->a.a_int = *(_DWORD *)v19;
          goto LABEL_27;
        case TYPE_STRING:
          v20 = args;
          args += 4;
          ap->a.a_int = *(_DWORD *)v20;
          if ( !ap->a.a_int )
            ap->a.a_int = (int)"(NULL)";
          goto LABEL_27;
        case TYPE_WIDE_STRING:
          v21 = args;
          args += 4;
          ap->a.a_int = *(_DWORD *)v21;
          if ( !ap->a.a_int )
            ap->a.a_int = (int)wide_null_string_1636;
          goto LABEL_27;
        case TYPE_POINTER:
          v22 = args;
          args += 4;
          ap->a.a_int = *(_DWORD *)v22;
          goto LABEL_27;
        case TYPE_COUNT_SCHAR_POINTER:
          v23 = args;
          args += 4;
          ap->a.a_int = *(_DWORD *)v23;
          goto LABEL_27;
        case TYPE_COUNT_SHORT_POINTER:
          v24 = args;
          args += 4;
          ap->a.a_int = *(_DWORD *)v24;
          goto LABEL_27;
        case TYPE_COUNT_INT_POINTER:
          v25 = args;
          args += 4;
          ap->a.a_int = *(_DWORD *)v25;
          goto LABEL_27;
        case TYPE_COUNT_LONGINT_POINTER:
          v26 = args;
          args += 4;
          ap->a.a_int = *(_DWORD *)v26;
          goto LABEL_27;
        case TYPE_COUNT_LONGLONGINT_POINTER:
          v27 = args;
          args += 4;
          ap->a.a_int = *(_DWORD *)v27;
LABEL_27:
          ++i;
          ++ap;
          continue;
        default:
          return -1;
      }
    }
    return 0;
  }
}

//----- (0804ED4C) --------------------------------------------------------
int __cdecl printf_parse(const char *format, char_directives *d, arguments *a)
{
  size_t count; // edx
  size_t v4; // edx
  size_t v5; // edx
  int size1; // [esp+14h] [ebp-C4h]
  int v8; // [esp+1Ch] [ebp-BCh]
  unsigned int v9; // [esp+20h] [ebp-B8h]
  size_t v10; // [esp+24h] [ebp-B4h]
  argument *v11; // [esp+28h] [ebp-B0h]
  int v12; // [esp+30h] [ebp-A8h]
  unsigned int v13; // [esp+34h] [ebp-A4h]
  size_t v14; // [esp+38h] [ebp-A0h]
  argument *v15; // [esp+3Ch] [ebp-9Ch]
  unsigned int v16; // [esp+40h] [ebp-98h]
  size_t v17; // [esp+44h] [ebp-94h]
  argument *v18; // [esp+48h] [ebp-90h]
  unsigned int v19; // [esp+4Ch] [ebp-8Ch]
  size_t v20; // [esp+50h] [ebp-88h]
  char_directive *memory_2; // [esp+60h] [ebp-78h]
  size_t n_4; // [esp+70h] [ebp-68h]
  int flags; // [esp+74h] [ebp-64h]
  arg_type type; // [esp+78h] [ebp-60h]
  size_t n_3; // [esp+88h] [ebp-50h]
  size_t n_2; // [esp+8Ch] [ebp-4Ch]
  char *np_1; // [esp+90h] [ebp-48h]
  const char *np_1a; // [esp+90h] [ebp-48h]
  size_t n_1; // [esp+A0h] [ebp-38h]
  size_t n_0; // [esp+A4h] [ebp-34h]
  char *np_0; // [esp+A8h] [ebp-30h]
  const char *np_0a; // [esp+A8h] [ebp-30h]
  size_t n; // [esp+ACh] [ebp-2Ch]
  char *np; // [esp+B0h] [ebp-28h]
  const char *npa; // [esp+B0h] [ebp-28h]
  char_directive *dp; // [esp+B4h] [ebp-24h]
  size_t v38; // [esp+B8h] [ebp-20h]
  unsigned int max_precision_length; // [esp+BCh] [ebp-1Ch]
  unsigned int max_width_length; // [esp+C0h] [ebp-18h]
  int a_allocated; // [esp+C4h] [ebp-14h]
  signed int d_allocated; // [esp+C8h] [ebp-10h]
  size_t v43; // [esp+CCh] [ebp-Ch]
  char ca; // [esp+D7h] [ebp-1h]
  char c; // [esp+D7h] [ebp-1h]

  v43 = 0;
  max_width_length = 0;
  max_precision_length = 0;
  d->count = 0;
  d_allocated = 1;
  d->dir = (char_directive *)malloc(0x2Cu);
  if ( !d->dir )
  {
out_of_memory_1:
    *__errno_location() = 12;
    return -1;
  }
  a->count = 0;
  a_allocated = 0;
  a->arg = 0;
  while ( 1 )
  {
    do
    {
      if ( !*format )
      {
        d->dir[d->count].dir_start = format;
        d->max_width_length = max_width_length;
        d->max_precision_length = max_precision_length;
        return 0;
      }
      ca = *format++;
    }
    while ( ca != 37 );
    v38 = -1;
    dp = &d->dir[d->count];
    dp->dir_start = format - 1;
    dp->flags = 0;
    dp->width_start = 0;
    dp->width_end = 0;
    dp->width_arg_index = -1;
    dp->precision_start = 0;
    dp->precision_end = 0;
    dp->precision_arg_index = -1;
    dp->arg_index = -1;
    if ( *format > 47 && *format <= 57 )
    {
      for ( np = (char *)format; *np > 47 && *np <= 57; ++np )
        ;
      if ( *np == 36 )
        break;
    }
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            while ( 1 )
            {
LABEL_21:
              while ( *format == 39 )
              {
                dp->flags |= 1u;
                ++format;
              }
              if ( *format != 45 )
                break;
              dp->flags |= 2u;
              ++format;
            }
            if ( *format != 43 )
              break;
            dp->flags |= 4u;
            ++format;
          }
          if ( *format != 32 )
            break;
          dp->flags |= 8u;
          ++format;
        }
        if ( *format != 35 )
          break;
        dp->flags |= 0x10u;
        ++format;
      }
      if ( *format != 48 )
        break;
      dp->flags |= 0x20u;
      ++format;
    }
    if ( *format == 42 )
    {
      dp->width_start = format++;
      dp->width_end = format;
      if ( !max_width_length )
        max_width_length = 1;
      if ( *format > 47 && *format <= 57 )
      {
        for ( np_0 = (char *)format; *np_0 > 47 && *np_0 <= 57; ++np_0 )
          ;
        if ( *np_0 == 36 )
        {
          n_0 = 0;
          for ( np_0a = format; *np_0a > 47 && *np_0a <= 57; ++np_0a )
          {
            if ( n_0 > 0x19999999 )
              v8 = -1;
            else
              v8 = 10 * n_0;
            n_0 = xsum_0(v8, *np_0a - 48);
          }
          if ( !n_0 || n_0 == -1 )
            goto error;
          dp->width_arg_index = n_0 - 1;
          format = np_0a + 1;
        }
      }
      if ( dp->width_arg_index == -1 )
      {
        dp->width_arg_index = v43++;
        if ( dp->width_arg_index == -1 )
          goto error;
      }
      n_1 = dp->width_arg_index;
      if ( n_1 >= a_allocated )
      {
        if ( a_allocated < 0 )
          v9 = -1;
        else
          v9 = 2 * a_allocated;
        a_allocated = v9;
        if ( v9 <= n_1 )
          a_allocated = xsum_0(n_1, 1u);
        if ( (unsigned int)a_allocated > 0xFFFFFFF )
          v10 = -1;
        else
          v10 = 16 * a_allocated;
        if ( v10 == -1 || (!a->arg ? (v11 = (argument *)malloc(v10)) : (v11 = (argument *)realloc(a->arg, v10)), !v11) )
        {
out_of_memory:
          if ( a->arg )
            free(a->arg);
          if ( d->dir )
            free(d->dir);
          goto out_of_memory_1;
        }
        a->arg = v11;
      }
      while ( a->count <= n_1 )
      {
        count = a->count;
        a->arg[a->count].type = TYPE_NONE;
        a->count = count + 1;
      }
      if ( a->arg[n_1].type )
      {
        if ( a->arg[n_1].type != TYPE_INT )
          goto error;
      }
      else
      {
        a->arg[n_1].type = TYPE_INT;
      }
    }
    else if ( *format > 47 && *format <= 57 )
    {
      dp->width_start = format;
      while ( *format > 47 && *format <= 57 )
        ++format;
      dp->width_end = format;
      if ( max_width_length < dp->width_end - dp->width_start )
        max_width_length = dp->width_end - dp->width_start;
    }
    if ( *format == 46 )
    {
      if ( *++format == 42 )
      {
        dp->precision_start = format++ - 1;
        dp->precision_end = format;
        if ( max_precision_length <= 1 )
          max_precision_length = 2;
        if ( *format > 47 && *format <= 57 )
        {
          for ( np_1 = (char *)format; *np_1 > 47 && *np_1 <= 57; ++np_1 )
            ;
          if ( *np_1 == 36 )
          {
            n_2 = 0;
            for ( np_1a = format; *np_1a > 47 && *np_1a <= 57; ++np_1a )
            {
              if ( n_2 > 0x19999999 )
                v12 = -1;
              else
                v12 = 10 * n_2;
              n_2 = xsum_0(v12, *np_1a - 48);
            }
            if ( !n_2 || n_2 == -1 )
              goto error;
            dp->precision_arg_index = n_2 - 1;
            format = np_1a + 1;
          }
        }
        if ( dp->precision_arg_index == -1 )
        {
          dp->precision_arg_index = v43++;
          if ( dp->precision_arg_index == -1 )
            goto error;
        }
        n_3 = dp->precision_arg_index;
        if ( n_3 >= a_allocated )
        {
          if ( a_allocated < 0 )
            v13 = -1;
          else
            v13 = 2 * a_allocated;
          a_allocated = v13;
          if ( v13 <= n_3 )
            a_allocated = xsum_0(n_3, 1u);
          if ( (unsigned int)a_allocated > 0xFFFFFFF )
            v14 = -1;
          else
            v14 = 16 * a_allocated;
          if ( v14 == -1 )
            goto out_of_memory;
          v15 = (argument *)(a->arg ? realloc(a->arg, v14) : malloc(v14));
          if ( !v15 )
            goto out_of_memory;
          a->arg = v15;
        }
        while ( a->count <= n_3 )
        {
          v4 = a->count;
          a->arg[a->count].type = TYPE_NONE;
          a->count = v4 + 1;
        }
        if ( a->arg[n_3].type )
        {
          if ( a->arg[n_3].type != TYPE_INT )
            goto error;
        }
        else
        {
          a->arg[n_3].type = TYPE_INT;
        }
      }
      else
      {
        dp->precision_start = format - 1;
        while ( *format > 47 && *format <= 57 )
          ++format;
        dp->precision_end = format;
        if ( max_precision_length < dp->precision_end - dp->precision_start )
          max_precision_length = dp->precision_end - dp->precision_start;
      }
    }
    flags = 0;
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            while ( 1 )
            {
              while ( *format == 104 )
              {
                flags |= 1 << (flags & 1);
                ++format;
              }
              if ( *format != 76 )
                break;
              flags |= 4u;
              ++format;
            }
            if ( *format != 108 )
              break;
            flags += 8;
            ++format;
          }
          if ( *format != 106 )
            break;
          flags += 16;
          ++format;
        }
        if ( *format != 122 && *format != 90 )
          break;
        ++format;
      }
      if ( *format != 116 )
        break;
      ++format;
    }
    c = *format++;
    switch ( c )
    {
      case '%':
        type = TYPE_NONE;
        break;
      case 'A':
      case 'E':
      case 'F':
      case 'G':
      case 'a':
      case 'e':
      case 'f':
      case 'g':
        if ( flags > 15 || (flags & 4) != 0 )
          type = TYPE_LONGDOUBLE;
        else
          type = TYPE_DOUBLE;
        break;
      case 'C':
        type = TYPE_WIDE_CHAR;
        c = 99;
        break;
      case 'S':
        type = TYPE_WIDE_STRING;
        c = 115;
        break;
      case 'X':
      case 'o':
      case 'u':
      case 'x':
        if ( flags > 15 || (flags & 4) != 0 )
        {
          type = TYPE_ULONGLONGINT;
        }
        else if ( flags <= 7 )
        {
          if ( (flags & 2) != 0 )
          {
            type = TYPE_UCHAR;
          }
          else if ( (flags & 1) != 0 )
          {
            type = TYPE_USHORT;
          }
          else
          {
            type = TYPE_UINT;
          }
        }
        else
        {
          type = TYPE_ULONGINT;
        }
        break;
      case 'c':
        if ( flags <= 7 )
          type = TYPE_CHAR;
        else
          type = TYPE_WIDE_CHAR;
        break;
      case 'd':
      case 'i':
        if ( flags > 15 || (flags & 4) != 0 )
        {
          type = TYPE_LONGLONGINT;
        }
        else if ( flags <= 7 )
        {
          if ( (flags & 2) != 0 )
          {
            type = TYPE_SCHAR;
          }
          else if ( (flags & 1) != 0 )
          {
            type = TYPE_SHORT;
          }
          else
          {
            type = TYPE_INT;
          }
        }
        else
        {
          type = TYPE_LONGINT;
        }
        break;
      case 'n':
        if ( flags > 15 || (flags & 4) != 0 )
        {
          type = TYPE_COUNT_LONGLONGINT_POINTER;
        }
        else if ( flags <= 7 )
        {
          if ( (flags & 2) != 0 )
          {
            type = TYPE_COUNT_SCHAR_POINTER;
          }
          else if ( (flags & 1) != 0 )
          {
            type = TYPE_COUNT_SHORT_POINTER;
          }
          else
          {
            type = TYPE_COUNT_INT_POINTER;
          }
        }
        else
        {
          type = TYPE_COUNT_LONGINT_POINTER;
        }
        break;
      case 'p':
        type = TYPE_POINTER;
        break;
      case 's':
        if ( flags <= 7 )
          type = TYPE_STRING;
        else
          type = TYPE_WIDE_STRING;
        break;
      default:
        goto error;
    }
    if ( type )
    {
      dp->arg_index = v38;
      if ( dp->arg_index == -1 )
      {
        dp->arg_index = v43++;
        if ( dp->arg_index == -1 )
          goto error;
      }
      n_4 = dp->arg_index;
      if ( n_4 >= a_allocated )
      {
        if ( a_allocated < 0 )
          v16 = -1;
        else
          v16 = 2 * a_allocated;
        a_allocated = v16;
        if ( v16 <= n_4 )
          a_allocated = xsum_0(n_4, 1u);
        if ( (unsigned int)a_allocated > 0xFFFFFFF )
          v17 = -1;
        else
          v17 = 16 * a_allocated;
        if ( v17 == -1 )
          goto out_of_memory;
        v18 = (argument *)(a->arg ? realloc(a->arg, v17) : malloc(v17));
        if ( !v18 )
          goto out_of_memory;
        a->arg = v18;
      }
      while ( a->count <= n_4 )
      {
        v5 = a->count;
        a->arg[a->count].type = TYPE_NONE;
        a->count = v5 + 1;
      }
      if ( a->arg[n_4].type )
      {
        if ( a->arg[n_4].type != type )
          goto error;
      }
      else
      {
        a->arg[n_4].type = type;
      }
    }
    dp->conversion = c;
    dp->dir_end = format;
    if ( ++d->count >= d_allocated )
    {
      if ( d_allocated < 0 )
        v19 = -1;
      else
        v19 = 2 * d_allocated;
      d_allocated = v19;
      if ( v19 > 0x5D1745D )
        v20 = -1;
      else
        v20 = 44 * v19;
      if ( v20 == -1 )
        goto out_of_memory;
      memory_2 = (char_directive *)realloc(d->dir, v20);
      if ( !memory_2 )
        goto out_of_memory;
      d->dir = memory_2;
    }
  }
  n = 0;
  for ( npa = format; *npa > 47 && *npa <= 57; ++npa )
  {
    if ( n > 0x19999999 )
      size1 = -1;
    else
      size1 = 10 * n;
    n = xsum_0(size1, *npa - 48);
  }
  if ( n && n != -1 )
  {
    v38 = n - 1;
    format = npa + 1;
    goto LABEL_21;
  }
error:
  if ( a->arg )
    free(a->arg);
  if ( d->dir )
    free(d->dir);
  *__errno_location() = 22;
  return -1;
}

//----- (0804FBAD) --------------------------------------------------------
size_t __cdecl xsum_0(size_t size1, size_t size2)
{
  if ( size2 + size1 < size1 )
    return -1;
  else
    return size2 + size1;
}

//----- (0804FC50) --------------------------------------------------------
int __cdecl atexit(void (__cdecl *lpfunc)(void *))
{
  void *v1; // eax

  v1 = 0;
  if ( &_dso_handle )
    v1 = (void *)_dso_handle;
  return __cxa_atexit(lpfunc, 0, v1);
}
// 80520BC: using guessed type _DWORD _dso_handle;

//----- (0804FC90) --------------------------------------------------------
int __cdecl fstat64(int a1, int a2)
{
  return __fxstat64(3, a1, a2);
}
// 8048D6C: using guessed type int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD);

// nfuncs=163 queued=62 decompiled=62 lumina nreq=0 worse=0 better=0
// ALL OK, 62 function(s) have been successfully decompiled
