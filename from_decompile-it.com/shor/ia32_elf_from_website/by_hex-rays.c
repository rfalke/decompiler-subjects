/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <math.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

int init_proc();
int sub_8048814();
// void abort(void);
// void srand(unsigned int seed);
// int __cdecl __cxa_atexit(void (__cdecl *lpfunc)(void *), void *obj, void *lpdso_handle);
// int __gmon_start__(void); weak
// void *realloc(void *ptr, size_t size);
// char *getenv(const char *name);
// void *calloc(size_t nmemb, size_t size);
// int putchar(int c);
// double pow(double x, double y);
// int __cdecl __libc_start_main(int (__cdecl *main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end);
// void perror(const char *s);
// void free(void *ptr);
// int fflush(FILE *stream);
// double sqrt(double x);
// int fclose(FILE *stream);
// void *memcpy(void *dest, const void *src, size_t n);
// FILE *fopen(const char *filename, const char *modes);
// double cos(double x);
// int fgetc(FILE *stream);
// int feof(FILE *stream);
// int printf(const char *format, ...);
// int atoi(const char *nptr);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// int fprintf(FILE *stream, const char *format, ...);
// time_t time(time_t *timer);
// void *malloc(size_t size);
// double log(double x);
// int puts(const char *s);
// int rand(void);
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
// double sin(double x);
// void __usercall __noreturn start(int a1@<eax>, void (*a2)(void)@<edx>);
void _do_global_dtors_aux();
int frame_dummy();
int __cdecl quantum_ipow(int a, int b);
int __cdecl quantum_gcd(int u, int v);
void __cdecl quantum_frac_approx(int *a, int *b, int width);
int __cdecl quantum_getwidth(int n);
int __cdecl quantum_inverse_mod(int n, int c);
complex_float __cdecl quantum_conj(complex_float a);
float __cdecl quantum_real(complex_float a);
float __cdecl quantum_imag(complex_float a);
float __cdecl quantum_prob(complex_float a);
float __cdecl quantum_prob_inline(complex_float a);
complex_float __cdecl quantum_cexp(float phi);
long double quantum_get_decoherence();
void __cdecl quantum_set_decoherence(float l);
void __cdecl quantum_decohere(quantum_reg *reg);
// quantum_density_op *__userpurge quantum_new_density_op@<eax>(quantum_density_op *retstr, int num, float *prob, quantum_reg *reg);
quantum_density_op *quantum_qureg2density_op(quantum_density_op *__return_ptr __struct_ptr retstr, quantum_reg *reg);
void __cdecl quantum_reduced_density_op(int pos, quantum_density_op *rho);
float __cdecl quantum_prob_inline_0(complex_float a);
float __cdecl quantum_real_0(complex_float a);
float __cdecl quantum_imag_0(complex_float a);
quantum_matrix *quantum_density_matrix(quantum_matrix *__return_ptr __struct_ptr retstr, quantum_density_op *rho);
void __cdecl quantum_reconstruct_hash(quantum_reg *reg);
void __cdecl quantum_add_hash(unsigned __int64 a, int pos, quantum_reg *reg);
unsigned int __cdecl quantum_hash64(unsigned __int64 key, int width);
int __cdecl quantum_get_state(unsigned __int64 a, quantum_reg reg);
void __cdecl quantum_print_density_matrix(quantum_density_op *rho);
void __cdecl quantum_delete_density_op(quantum_density_op *rho);
float __cdecl quantum_purity(quantum_density_op *rho);
void *__cdecl quantum_error_handler(void *(*f)(int));
const char *__cdecl quantum_strerr(int errno);
void __cdecl quantum_error(int errno);
void __cdecl quantum_exp_mod_n(int N, int x, int width_input, int width, quantum_reg *reg);
void __cdecl quantum_cnot(int control, int target, quantum_reg *reg);
void __cdecl quantum_toffoli(int control1, int control2, int target, quantum_reg *reg);
void quantum_unbounded_toffoli(int controlling, quantum_reg *reg, ...);
void __cdecl quantum_sigma_x(int target, quantum_reg *reg);
void __cdecl quantum_sigma_y(int target, quantum_reg *reg);
void __cdecl quantum_sigma_z(int target, quantum_reg *reg);
void __cdecl quantum_swaptheleads(int width, quantum_reg *reg);
void __cdecl quantum_swaptheleads_omuln_controlled(int control, int width, quantum_reg *reg);
void __cdecl quantum_gate1(int target, quantum_matrix m, quantum_reg *reg);
void __cdecl quantum_reconstruct_hash_0(quantum_reg *reg);
void __cdecl quantum_add_hash_0(unsigned __int64 a, int pos, quantum_reg *reg);
unsigned int __cdecl quantum_hash64_0(unsigned __int64 key, int width);
int __cdecl quantum_get_state_0(unsigned __int64 a, quantum_reg reg);
float __cdecl quantum_prob_inline_1(complex_float a);
float __cdecl quantum_real_1(complex_float a);
float __cdecl quantum_imag_1(complex_float a);
void __cdecl quantum_gate2(int target1, int target2, quantum_matrix m, quantum_reg *reg);
int __cdecl quantum_bitmask(unsigned __int64 a, int width, int *bits);
void __cdecl quantum_hadamard(int target, quantum_reg *reg);
void __cdecl quantum_walsh(int width, quantum_reg *reg);
void __cdecl quantum_r_x(int target, float gamma, quantum_reg *reg);
void __cdecl quantum_r_y(int target, float gamma, quantum_reg *reg);
void __cdecl quantum_r_z(int target, float gamma, quantum_reg *reg);
void __cdecl quantum_phase_scale(int target, float gamma, quantum_reg *reg);
void __cdecl quantum_phase_kick(int target, float gamma, quantum_reg *reg);
void __cdecl quantum_cond_phase(int control, int target, quantum_reg *reg);
void __cdecl quantum_cond_phase_inv(int control, int target, quantum_reg *reg);
void __cdecl quantum_cond_phase_kick(int control, int target, float gamma, quantum_reg *reg);
int __cdecl quantum_gate_counter(int inc);
unsigned int __cdecl quantum_memman(int change);
// quantum_matrix *__userpurge quantum_new_matrix@<eax>(quantum_matrix *retstr, int cols, int rows);
void __cdecl quantum_delete_matrix(quantum_matrix *m);
void __cdecl quantum_print_matrix(quantum_matrix m);
float __cdecl quantum_imag_2(complex_float a);
float __cdecl quantum_real_2(complex_float a);
// quantum_matrix *__userpurge quantum_mmult@<eax>(quantum_matrix *retstr, quantum_matrix A, quantum_matrix B);
long double quantum_frand();
unsigned __int64 __cdecl quantum_measure(quantum_reg reg);
float __cdecl quantum_prob_inline_2(complex_float a);
float __cdecl quantum_real_3(complex_float a);
float __cdecl quantum_imag_3(complex_float a);
int __cdecl quantum_bmeasure(int pos, quantum_reg *reg);
int __cdecl quantum_bmeasure_bitpreserve(int pos, quantum_reg *reg);
void __cdecl test_sum(int compare, int width, quantum_reg *reg);
void __cdecl muxfa(int a, int b_in, int c_in, int c_out, int xlt_l, int L, int total, quantum_reg *reg);
void __cdecl muxfa_inv(int a, int b_in, int c_in, int c_out, int xlt_l, int L, int total, quantum_reg *reg);
void __cdecl muxha(int a, int b_in, int c_in, int xlt_l, int L, int total, quantum_reg *reg);
void __cdecl muxha_inv(int a, int b_in, int c_in, int xlt_l, int L, int total, quantum_reg *reg);
void __cdecl madd(int a, int a_inv, int width, quantum_reg *reg);
void __cdecl madd_inv(int a, int a_inv, int width, quantum_reg *reg);
void __cdecl addn(int N, int a, int width, quantum_reg *reg);
void __cdecl addn_inv(int N, int a, int width, quantum_reg *reg);
void __cdecl add_mod_n(int N, int a, int width, quantum_reg *reg);
void __cdecl quantum_mu2char(unsigned __int64 mu, unsigned __int8 *buf);
void __cdecl quantum_int2char(int j, unsigned __int8 *buf);
void __cdecl quantum_double2char(double d, unsigned __int8 *buf);
unsigned __int64 __cdecl quantum_char2mu(unsigned __int8 *buf);
int __cdecl quantum_char2int(unsigned __int8 *buf);
double __cdecl quantum_char2double(unsigned __int8 *buf);
void quantum_objcode_start(); // idb
void quantum_objcode_stop(); // idb
int quantum_objcode_put(unsigned __int8 operation, ...);
int __cdecl quantum_objcode_write(char *file);
void __cdecl quantum_objcode_file(char *file);
void __cdecl quantum_objcode_exit(char *file);
void __cdecl quantum_objcode_run(char *file, quantum_reg *reg);
void __cdecl emul(int a, int L, int width, quantum_reg *reg);
void __cdecl muln(int N, int a, int ctl, int width, quantum_reg *reg);
void __cdecl muln_inv(int N, int a, int ctl, int width, quantum_reg *reg);
void __cdecl mul_mod_n(int N, int a, int ctl, int width, quantum_reg *reg);
void __cdecl quantum_qec_set_status(int stype, int swidth);
void __cdecl quantum_qec_get_status(int *ptype, int *pwidth);
void __cdecl quantum_qec_encode(int type, int width, quantum_reg *reg);
void __cdecl quantum_qec_decode(int type, int width, quantum_reg *reg);
int __cdecl quantum_qec_counter(int inc, int frequency, quantum_reg *reg);
void __cdecl quantum_sigma_x_ft(int target, quantum_reg *reg);
void __cdecl quantum_cnot_ft(int control, int target, quantum_reg *reg);
void __cdecl quantum_toffoli_ft(int control1, int control2, int target, quantum_reg *reg);
void __cdecl quantum_qft(int width, quantum_reg *reg);
void __cdecl quantum_qft_inv(int width, quantum_reg *reg);
void __cdecl quantum_rk4(quantum_reg *reg, double t, double dt, quantum_reg *(*H)(quantum_reg *__return_ptr __struct_ptr retstr, unsigned __int64, double));
double __cdecl quantum_rk4a(quantum_reg *reg, double t, double *dt, double epsilon, quantum_reg *(*H)(quantum_reg *__return_ptr __struct_ptr retstr, unsigned __int64, double));
float __cdecl quantum_real_4(complex_float a);
float __cdecl quantum_imag_4(complex_float a);
// quantum_reg *__userpurge quantum_matrix2qureg@<eax>(quantum_reg *retstr, quantum_matrix *m, int width);
// quantum_reg *__userpurge quantum_new_qureg@<eax>(quantum_reg *retstr, unsigned __int64 initval, int width);
// quantum_reg *__userpurge quantum_new_qureg_size@<eax>(quantum_reg *retstr, int n, int width);
// quantum_matrix *__userpurge quantum_qureg2matrix@<eax>(quantum_matrix *retstr, quantum_reg reg);
void __cdecl quantum_destroy_hash(quantum_reg *reg);
void __cdecl quantum_delete_qureg(quantum_reg *reg);
void __cdecl quantum_delete_qureg_hashpreserve(quantum_reg *reg);
void __cdecl quantum_copy_qureg(quantum_reg *src, quantum_reg *dst);
void __cdecl quantum_print_qureg(quantum_reg reg);
float __cdecl quantum_prob_inline_3(complex_float a);
float __cdecl quantum_imag_5(complex_float a);
float __cdecl quantum_real_5(complex_float a);
void __cdecl quantum_print_expn(quantum_reg reg);
void __cdecl quantum_addscratch(int bits, quantum_reg *reg);
void __cdecl quantum_print_hash(quantum_reg reg);
// quantum_reg *__userpurge quantum_kronecker@<eax>(quantum_reg *retstr, quantum_reg *reg1, quantum_reg *reg2);
// quantum_reg *__userpurge quantum_state_collapse@<eax>(quantum_reg *retstr, int pos, int value, quantum_reg reg);
complex_float __cdecl quantum_dot_product(quantum_reg *reg1, quantum_reg *reg2);
void __cdecl quantum_reconstruct_hash_1(quantum_reg *reg);
void __cdecl quantum_add_hash_1(unsigned __int64 a, int pos, quantum_reg *reg);
unsigned int __cdecl quantum_hash64_1(unsigned __int64 key, int width);
int __cdecl quantum_get_state_1(unsigned __int64 a, quantum_reg reg);
complex_float __cdecl quantum_dot_product_noconj(quantum_reg *reg1, quantum_reg *reg2);
// quantum_reg *__userpurge quantum_vectoradd@<eax>(quantum_reg *retstr, quantum_reg *reg1, quantum_reg *reg2);
void __cdecl quantum_vectoradd_inplace(quantum_reg *reg1, quantum_reg *reg2);
// quantum_reg *__userpurge quantum_matrix_qureg@<eax>(quantum_reg *retstr, quantum_reg *(*A)(quantum_reg *__return_ptr __struct_ptr retstr, unsigned __int64, double), double t, quantum_reg *reg);
void __cdecl quantum_scalar_qureg(complex_float r, quantum_reg *reg);
void __cdecl quantum_print_timeop(int width, void (*f)(quantum_reg *));
int __cdecl main(int argc, const char **argv, const char **envp);
const char *quantum_get_version(); // idb
int __cdecl _mulsc3(float, float, float, float); // idb
// double *__userpurge _muldc3@<eax>(double *a1, double a2, double a3, double a4, double a5);
int __cdecl _divsc3(float, float, float, float); // idb
// double *__userpurge _divdc3@<eax>(double *a1, double a2, double a3, double a4, double a5);
void _libc_csu_fini(void); // idb
void _libc_csu_init(void); // idb
int __cdecl atexit(void (__cdecl *lpfunc)(void *)); // idb
void (*_do_global_ctors_aux())(void);
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

int _CTOR_LIST__ = -1; // weak
int _DTOR_LIST__[] = { -1 }; // weak
int _DTOR_END__ = 0; // weak
int _JCR_LIST__ = 0; // weak
int (*dword_8055FFC)(void) = NULL; // weak
_DWORD _dso_handle = 0; // idb
int freq_2127 = 1073741824; // idb
FILE *stderr; // idb
FILE *stdout; // idb
char completed_6635; // weak
int dtor_idx_6637; // weak
int quantum_status; // idb
float quantum_lambda; // idb
void *errfunc_2059; // idb
int counter_4541; // idb
int max_2106; // idb
int mem_2105; // idb
int opstatus; // idb
unsigned __int8 *objcode; // idb
size_t position; // idb
unsigned int allocated; // idb
int type; // idb
int width; // idb
int counter_2126; // idb
char *globalfile; // idb
// extern _UNKNOWN _gmon_start__; weak


//----- (080487E4) --------------------------------------------------------
int init_proc()
{
  int v1; // [esp+0h] [ebp-8h]

  if ( &_gmon_start__ )
    __gmon_start__();
  frame_dummy();
  _do_global_ctors_aux();
  return v1;
}
// 8048810: variable 'v1' is possibly undefined
// 8048854: using guessed type int __gmon_start__(void);

//----- (08048814) --------------------------------------------------------
int sub_8048814()
{
  return dword_8055FFC();
}
// 8055FFC: using guessed type int (*dword_8055FFC)(void);

//----- (08048A30) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall __noreturn start(int a1@<eax>, void (*a2)(void)@<edx>)
{
  int v2; // esi
  int v3; // [esp-4h] [ebp-4h] BYREF
  char *retaddr; // [esp+0h] [ebp+0h] BYREF

  v2 = v3;
  v3 = a1;
  __libc_start_main((int (__cdecl *)(int, char **, char **))main, v2, &retaddr, _libc_csu_init, _libc_csu_fini, a2, &v3);
  __halt();
}
// 8048A33: positive sp value 4 has been found

//----- (08048A60) --------------------------------------------------------
void _do_global_dtors_aux()
{
  int v0; // edx
  unsigned int i; // ebx

  if ( !completed_6635 )
  {
    v0 = dtor_idx_6637;
    for ( i = &_DTOR_END__ - _DTOR_LIST__ - 1; dtor_idx_6637 < i; v0 = dtor_idx_6637 )
    {
      dtor_idx_6637 = v0 + 1;
      ((void (*)(void))_DTOR_LIST__[v0 + 1])();
    }
    completed_6635 = 1;
  }
}
// 8055F08: using guessed type int _DTOR_LIST__[];
// 8055F0C: using guessed type int _DTOR_END__;
// 80560C4: using guessed type char completed_6635;
// 80560C8: using guessed type int dtor_idx_6637;

//----- (08048AC0) --------------------------------------------------------
int frame_dummy()
{
  int result; // eax

  result = _JCR_LIST__;
  if ( _JCR_LIST__ )
    result = 0;
  return result;
}
// 8055F10: using guessed type int _JCR_LIST__;

//----- (08048AE4) --------------------------------------------------------
int __cdecl quantum_ipow(int a, int b)
{
  int r; // [esp+8h] [ebp-8h]
  int i; // [esp+Ch] [ebp-4h]

  r = 1;
  for ( i = 0; i < b; ++i )
    r *= a;
  return r;
}

//----- (08048B15) --------------------------------------------------------
int __cdecl quantum_gcd(int u, int v)
{
  int r; // [esp+10h] [ebp-4h]

  while ( v )
  {
    r = u % v;
    u = v;
    v = r;
  }
  return u;
}

//----- (08048B42) --------------------------------------------------------
void __cdecl quantum_frac_approx(int *a, int *b, int width)
{
  int den; // [esp+18h] [ebp-24h]
  int num; // [esp+1Ch] [ebp-20h]
  int den1; // [esp+20h] [ebp-1Ch]
  int num1; // [esp+24h] [ebp-18h]
  int den2; // [esp+28h] [ebp-14h]
  int num2; // [esp+2Ch] [ebp-10h]
  int i; // [esp+30h] [ebp-Ch]
  float g; // [esp+34h] [ebp-8h]
  float ga; // [esp+34h] [ebp-8h]
  float f; // [esp+38h] [ebp-4h]

  f = (long double)*a / (long double)*b;
  g = f;
  num2 = 0;
  den2 = 1;
  num1 = 1;
  den1 = 0;
  num = 0;
  den = 0;
  do
  {
    i = (int)(g + 0.000005);
    ga = g - ((long double)i - 0.000005);
    g = 1.0 / ga;
    if ( den2 + den1 * i > 1 << width )
      break;
    num = num2 + num1 * i;
    den = den2 + den1 * i;
    num2 = num1;
    den2 = den1;
    num1 = num;
    den1 = den;
  }
  while ( fabs((long double)num / (long double)den - f) > 1.0 / (long double)(2 << width) );
  *a = num;
  *b = den;
}

//----- (08048C63) --------------------------------------------------------
int __cdecl quantum_getwidth(int n)
{
  int i; // [esp+Ch] [ebp-4h]

  for ( i = 1; 1 << i < n; ++i )
    ;
  return i;
}

//----- (08048C8A) --------------------------------------------------------
int __cdecl quantum_inverse_mod(int n, int c)
{
  int i; // [esp+10h] [ebp-4h]

  for ( i = 1; c * i % n != 1; ++i )
    ;
  return i;
}

//----- (08048CBC) --------------------------------------------------------
complex_float __cdecl quantum_conj(complex_float a)
{
  float v1; // edx
  complex_float result; // rax
  float v3; // [esp+18h] [ebp-20h]
  float v4; // [esp+18h] [ebp-20h]
  float i; // [esp+24h] [ebp-14h]
  float r; // [esp+28h] [ebp-10h]

  r = quantum_real(a);
  i = quantum_imag(a);
  v3 = r + COERCE_FLOAT(_mulsc3(i, 0.0, -0.0, -1.0));
  result.real = v3;
  v4 = v1 + 0.0;
  result.imag = v4;
  return result;
}
// 8048D3F: variable 'v1' is possibly undefined

//----- (08048D63) --------------------------------------------------------
float __cdecl quantum_real(complex_float a)
{
  return a.real;
}

//----- (08048D7C) --------------------------------------------------------
float __cdecl quantum_imag(complex_float a)
{
  return a.imag;
}

//----- (08048D98) --------------------------------------------------------
float __cdecl quantum_prob(complex_float a)
{
  return quantum_prob_inline(a);
}

//----- (08048DBE) --------------------------------------------------------
float __cdecl quantum_prob_inline(complex_float a)
{
  float i; // [esp+10h] [ebp-8h]
  float r; // [esp+14h] [ebp-4h]

  r = quantum_real(a);
  i = quantum_imag(a);
  return r * r + i * i;
}

//----- (08048DFE) --------------------------------------------------------
complex_float __cdecl quantum_cexp(float phi)
{
  long double v1; // fst7
  long double v2; // fst7
  unsigned int v4; // [esp+34h] [ebp-34h]
  double v5; // [esp+40h] [ebp-28h]
  float v6; // [esp+4Ch] [ebp-1Ch]
  unsigned int v7; // [esp+4Ch] [ebp-1Ch]
  double v8[2]; // [esp+50h] [ebp-18h] BYREF

  v5 = cos(phi);
  v1 = sin(phi);
  _muldc3(v8, v1, 0.0, 0.0, 1.0);
  v6 = v5 + v8[0];
  v2 = v6;
  *(float *)&v7 = (double)0.0 + v8[1];
  *(float *)&v4 = v2;
  return (complex_float)__PAIR64__(v7, v4);
}

//----- (08048E84) --------------------------------------------------------
long double quantum_get_decoherence()
{
  return quantum_lambda;
}

//----- (08048E97) --------------------------------------------------------
void __cdecl quantum_set_decoherence(float l)
{
  if ( l == 0.0 )
  {
    quantum_status = 0;
  }
  else
  {
    quantum_status = 1;
    quantum_lambda = l;
  }
}

//----- (08048ECA) --------------------------------------------------------
void __cdecl quantum_decohere(quantum_reg *reg)
{
  long double v1; // fst7
  long double v2; // fst7
  quantum_reg_node *v3; // eax
  unsigned int v4; // edx
  int v5; // eax
  unsigned int v6; // edx
  long double v7; // fst7
  quantum_reg_node *v8; // edi
  float v9; // esi
  complex_float v10; // rax
  float v11; // edx
  float v12; // [esp+40h] [ebp-38h]
  int j; // [esp+48h] [ebp-30h]
  int i; // [esp+4Ch] [ebp-2Ch]
  int ia; // [esp+4Ch] [ebp-2Ch]
  float angle; // [esp+50h] [ebp-28h]
  float *nrands; // [esp+54h] [ebp-24h]
  float x; // [esp+58h] [ebp-20h]
  float xa; // [esp+58h] [ebp-20h]
  float s; // [esp+5Ch] [ebp-1Ch]
  float v; // [esp+60h] [ebp-18h]
  float u; // [esp+64h] [ebp-14h]

  quantum_gate_counter(1);
  if ( quantum_status )
  {
    nrands = (float *)calloc(reg->width, 4u);
    if ( !nrands )
      quantum_error(2);
    quantum_memman(4 * reg->width);
    for ( i = 0; reg->width > i; ++i )
    {
      do
      {
        v1 = quantum_frand();
        u = v1 + v1 - 1.0;
        v2 = quantum_frand();
        v = v2 + v2 - 1.0;
        s = u * u + v * v;
      }
      while ( s >= 1.0 );
      x = (double)sqrt((double)(log(s) * -2.0 / s)) * u;
      xa = sqrt(quantum_lambda + quantum_lambda) * x;
      nrands[i] = xa / 2.0;
    }
    for ( ia = 0; reg->size > ia; ++ia )
    {
      angle = 0.0;
      for ( j = 0; reg->width > j; ++j )
      {
        v3 = &reg->node[ia];
        v4 = HIDWORD(v3->state);
        v5 = v3->state >> j;
        v6 = v4 >> j;
        if ( (j & 0x20) != 0 )
          LOBYTE(v5) = v6;
        if ( (v5 & 1) != 0 )
          v7 = nrands[j] + angle;
        else
          v7 = angle - nrands[j];
        angle = v7;
      }
      v8 = &reg->node[ia];
      v9 = v8->amplitude.real;
      v12 = v8->amplitude.imag;
      v10 = quantum_cexp(angle);
      LODWORD(v8->amplitude.real) = _mulsc3(v9, v12, v10.real, v10.imag);
      v8->amplitude.imag = v11;
    }
    free(nrands);
    quantum_memman(-4 * reg->width);
  }
}
// 80490E1: variable 'v11' is possibly undefined

//----- (0804911C) --------------------------------------------------------
quantum_density_op *__userpurge quantum_new_density_op@<eax>(quantum_density_op *retstr, int num, float *prob, quantum_reg *reg)
{
  quantum_reg *v4; // ecx
  quantum_reg *v5; // edx
  float *rho_4; // [esp+14h] [ebp-14h]
  quantum_reg *rho_8; // [esp+18h] [ebp-10h]
  int hashw; // [esp+1Ch] [ebp-Ch]
  int *phash; // [esp+20h] [ebp-8h]
  int i; // [esp+24h] [ebp-4h]

  rho_4 = (float *)calloc(num, 4u);
  if ( !rho_4 )
    quantum_error(2);
  rho_8 = (quantum_reg *)calloc(num, 0x14u);
  if ( !rho_8 )
    quantum_error(2);
  quantum_memman(24 * num);
  *rho_4 = *prob;
  phash = reg->hash;
  hashw = reg->hashw;
  *rho_8 = *reg;
  reg->size = 0;
  reg->width = 0;
  reg->node = 0;
  reg->hash = 0;
  for ( i = 1; i < num; ++i )
  {
    rho_4[i] = prob[i];
    v4 = &rho_8[i];
    v5 = &reg[i];
    v4->width = v5->width;
    v4->size = v5->size;
    v4->hashw = v5->hashw;
    v4->node = v5->node;
    v4->hash = v5->hash;
    v4->hash = phash;
    v4->hashw = hashw;
    v5->size = 0;
    v5->width = 0;
    v5->node = 0;
    v5->hash = 0;
  }
  retstr->num = num;
  retstr->prob = rho_4;
  retstr->reg = rho_8;
  return retstr;
}

//----- (08049315) --------------------------------------------------------
quantum_density_op *quantum_qureg2density_op(quantum_density_op *retstr, quantum_reg *reg)
{
  float f; // [esp+20h] [ebp-8h] BYREF

  f = 1.0;
  quantum_new_density_op(retstr, 1, &f, reg);
  return retstr;
}
// 8049315: inconsistent function type and number of purged bytes

//----- (08049351) --------------------------------------------------------
void __cdecl quantum_reduced_density_op(int pos, quantum_density_op *rho)
{
  long double v2; // fst7
  float *v3; // eax
  float *v4; // eax
  quantum_reg *v5; // ebx
  quantum_reg *v6; // ebx
  quantum_reg v7; // [esp+20h] [ebp-78h] BYREF
  float v8; // [esp+4Ch] [ebp-4Ch]
  quantum_reg rtmp; // [esp+5Ch] [ebp-3Ch] BYREF
  unsigned __int64 pos2; // [esp+70h] [ebp-28h]
  double ptmp; // [esp+78h] [ebp-20h]
  double p0; // [esp+80h] [ebp-18h]
  int j; // [esp+88h] [ebp-10h]
  int i; // [esp+8Ch] [ebp-Ch]

  p0 = 0.0;
  rho->prob = (float *)realloc(rho->prob, 8 * rho->num);
  if ( !rho->prob )
    quantum_error(2);
  rho->reg = (quantum_reg *)realloc(rho->reg, 40 * rho->num);
  if ( !rho->reg )
    quantum_error(2);
  quantum_memman(24 * rho->num);
  pos2 = 1LL << pos;
  for ( i = 0; rho->num > i; ++i )
  {
    ptmp = rho->prob[i];
    rtmp = rho->reg[i];
    p0 = 0.0;
    for ( j = 0; rho->reg[i].size > j; ++j )
    {
      if ( (pos2 & rho->reg[i].node[j].state) == 0 )
      {
        v2 = quantum_prob_inline_0(rho->reg[i].node[j].amplitude);
        p0 = v2 + p0;
      }
    }
    v3 = &rho->prob[i];
    v8 = ptmp * p0;
    *v3 = v8;
    v4 = &rho->prob[i + rho->num];
    v8 = (1.0 - p0) * ptmp;
    *v4 = v8;
    v5 = &rho->reg[i];
    quantum_state_collapse(&v7, pos, 0, rtmp);
    *v5 = v7;
    v6 = &rho->reg[i + rho->num];
    quantum_state_collapse(&v7, pos, 1, rtmp);
    *v6 = v7;
    quantum_delete_qureg_hashpreserve(&rtmp);
  }
  rho->num *= 2;
}

//----- (0804966A) --------------------------------------------------------
float __cdecl quantum_prob_inline_0(complex_float a)
{
  float i; // [esp+10h] [ebp-8h]
  float r; // [esp+14h] [ebp-4h]

  r = quantum_real_0(a);
  i = quantum_imag_0(a);
  return r * r + i * i;
}

//----- (080496AA) --------------------------------------------------------
float __cdecl quantum_real_0(complex_float a)
{
  return a.real;
}

//----- (080496C3) --------------------------------------------------------
float __cdecl quantum_imag_0(complex_float a)
{
  return a.imag;
}

//----- (080496DF) --------------------------------------------------------
quantum_matrix *quantum_density_matrix(quantum_matrix *retstr, quantum_density_op *rho)
{
  complex_float *v2; // edi
  quantum_reg_node *v3; // eax
  float v4; // esi
  float v5; // edx
  complex_float v6; // rax
  float v7; // edx
  float v8; // eax
  float v10; // [esp+1Ch] [ebp-4Ch]
  float v11; // [esp+1Ch] [ebp-4Ch]
  float v12; // [esp+20h] [ebp-48h]
  float v13; // [esp+24h] [ebp-44h]
  float v14; // [esp+28h] [ebp-40h]
  quantum_matrix m; // [esp+38h] [ebp-30h] BYREF
  int dim; // [esp+44h] [ebp-24h]
  int l2; // [esp+48h] [ebp-20h]
  int l1; // [esp+4Ch] [ebp-1Ch]
  int k; // [esp+50h] [ebp-18h]
  int j; // [esp+54h] [ebp-14h]
  int i; // [esp+58h] [ebp-10h]

  dim = 1 << rho->reg->width;
  if ( dim < 0 )
    quantum_error(3);
  quantum_new_matrix(&m, dim, dim);
  for ( k = 0; rho->num > k; ++k )
  {
    quantum_reconstruct_hash(&rho->reg[k]);
    for ( i = 0; i < dim; ++i )
    {
      for ( j = 0; j < dim; ++j )
      {
        l1 = quantum_get_state(i, rho->reg[k]);
        l2 = quantum_get_state(j, rho->reg[k]);
        if ( l1 >= 0 && l2 >= 0 )
        {
          v2 = &m.t[i + j * m.cols];
          v13 = v2->real;
          v12 = v2->imag;
          v3 = &rho->reg[k].node[l2];
          v4 = COERCE_FLOAT(_mulsc3(rho->prob[k], 0.0, v3->amplitude.real, v3->amplitude.imag));
          v14 = v5;
          v6 = quantum_conj(rho->reg[k].node[l1].amplitude);
          v10 = v13 + COERCE_FLOAT(_mulsc3(v4, v14, v6.real, v6.imag));
          v8 = v10;
          v11 = v12 + v7;
          v2->real = v8;
          v2->imag = v11;
        }
      }
    }
  }
  *retstr = m;
  return retstr;
}
// 80498B0: variable 'v5' is possibly undefined
// 8049924: variable 'v7' is possibly undefined
// 80496DF: inconsistent function type and number of purged bytes

//----- (08049996) --------------------------------------------------------
void __cdecl quantum_reconstruct_hash(quantum_reg *reg)
{
  int i; // [esp+24h] [ebp-4h]
  int ia; // [esp+24h] [ebp-4h]

  for ( i = 0; 1 << reg->hashw > i; ++i )
    reg->hash[i] = 0;
  for ( ia = 0; reg->size > ia; ++ia )
    quantum_add_hash(reg->node[ia].state, ia, reg);
}

//----- (08049A19) --------------------------------------------------------
void __cdecl quantum_add_hash(unsigned __int64 a, int pos, quantum_reg *reg)
{
  int mark; // [esp+20h] [ebp-8h]
  int i; // [esp+24h] [ebp-4h]

  mark = 0;
  i = quantum_hash64(a, reg->hashw);
  while ( reg->hash[i] )
  {
    if ( 1 << reg->hashw == ++i )
    {
      if ( mark )
      {
        quantum_error(5);
      }
      else
      {
        i = 0;
        mark = 1;
      }
    }
  }
  reg->hash[i] = pos + 1;
}

//----- (08049AB8) --------------------------------------------------------
unsigned int __cdecl quantum_hash64(unsigned __int64 key, int width)
{
  return (-1640562687 * ((unsigned int)key ^ HIDWORD(key))) >> (32 - width);
}

//----- (08049AFA) --------------------------------------------------------
int __cdecl quantum_get_state(unsigned __int64 a, quantum_reg reg)
{
  int i; // [esp+2Ch] [ebp-4h]

  if ( !reg.hashw )
    return a;
  i = quantum_hash64(a, reg.hashw);
  while ( reg.hash[i] )
  {
    if ( a == reg.node[-(1 - reg.hash[i])].state )
      return reg.hash[i] - 1;
    if ( 1 << SLOBYTE(reg.hashw) == ++i )
      i = 0;
  }
  return -1;
}

//----- (08049BC0) --------------------------------------------------------
void __cdecl quantum_print_density_matrix(quantum_density_op *rho)
{
  quantum_matrix v1; // [esp+10h] [ebp-28h] BYREF
  quantum_matrix m; // [esp+24h] [ebp-14h] BYREF

  quantum_density_matrix(&v1, rho);
  m = v1;
  quantum_print_matrix(v1);
  quantum_delete_matrix(&m);
}

//----- (08049C13) --------------------------------------------------------
void __cdecl quantum_delete_density_op(quantum_density_op *rho)
{
  int i; // [esp+14h] [ebp-4h]

  quantum_destroy_hash(rho->reg);
  for ( i = 0; rho->num > i; ++i )
    quantum_delete_qureg_hashpreserve(&rho->reg[i]);
  free(rho->prob);
  free(rho->reg);
  quantum_memman(-24 * rho->num);
  rho->prob = 0;
  rho->reg = 0;
}

//----- (08049C9E) --------------------------------------------------------
float __cdecl quantum_purity(quantum_density_op *rho)
{
  float v1; // ebx
  quantum_reg_node *v2; // eax
  float v3; // edx
  float v4; // esi
  float v5; // edx
  float v6; // edi
  complex_float v7; // rax
  float v8; // edx
  long double v9; // fst7
  float v11; // [esp+28h] [ebp-40h]
  complex_float dp; // [esp+38h] [ebp-30h]
  complex_float g; // [esp+40h] [ebp-28h]
  float f; // [esp+48h] [ebp-20h]
  int l; // [esp+4Ch] [ebp-1Ch]
  int k; // [esp+50h] [ebp-18h]
  int j; // [esp+54h] [ebp-14h]
  int i; // [esp+58h] [ebp-10h]
  int ia; // [esp+58h] [ebp-10h]

  f = 0.0;
  for ( i = 0; rho->num > i; ++i )
    f = rho->prob[i] * rho->prob[i] + f;
  for ( ia = 0; rho->num > ia; ++ia )
  {
    for ( j = 0; j < ia; ++j )
    {
      dp = quantum_dot_product(&rho->reg[ia], &rho->reg[j]);
      for ( k = 0; rho->reg[ia].size > k; ++k )
      {
        l = quantum_get_state(rho->reg[ia].node[k].state, rho->reg[j]);
        if ( l < 0 )
        {
          g = 0LL;
        }
        else
        {
          v11 = rho->prob[ia] * rho->prob[j];
          v1 = COERCE_FLOAT(_mulsc3(v11, 0.0, dp.real, dp.imag));
          v2 = &rho->reg[ia].node[k];
          v4 = COERCE_FLOAT(_mulsc3(v1, v3, v2->amplitude.real, v2->amplitude.imag));
          v6 = v5;
          v7 = quantum_conj(rho->reg[j].node[l].amplitude);
          LODWORD(g.real) = _mulsc3(v4, v6, v7.real, v7.imag);
          g.imag = v8;
        }
        v9 = quantum_real_0(g);
        f = v9 + v9 + f;
      }
    }
  }
  return f;
}
// 8049E64: variable 'v3' is possibly undefined
// 8049E73: variable 'v5' is possibly undefined
// 8049ED6: variable 'v8' is possibly undefined

//----- (08049F64) --------------------------------------------------------
void *__cdecl quantum_error_handler(void *(*f)(int))
{
  if ( f )
    errfunc_2059 = f;
  return errfunc_2059;
}

//----- (08049F7C) --------------------------------------------------------
const char *__cdecl quantum_strerr(int errno)
{
  const char *v2; // [esp+4h] [ebp-4h]

  if ( errno == 3 )
    return "matrix too large";
  if ( errno > 3 )
  {
    if ( errno == 5 )
    {
      v2 = "hash table full";
    }
    else if ( errno < 5 )
    {
      v2 = "wrong matrix size";
    }
    else if ( errno == 0x10000 )
    {
      v2 = "single-column matrix expected";
    }
    else
    {
      if ( errno != 65537 )
        return "unknown error code";
      v2 = "unknown opcode";
    }
  }
  else if ( errno == 1 )
  {
    v2 = "failure";
  }
  else if ( errno > 1 )
  {
    v2 = "malloc failed";
  }
  else
  {
    if ( errno )
      return "unknown error code";
    v2 = "success";
  }
  return v2;
}

//----- (0804A01C) --------------------------------------------------------
void __cdecl quantum_error(int errno)
{
  const char *v1; // eax
  void (*p)(int); // [esp+24h] [ebp-4h]

  p = (void (*)(int))quantum_error_handler(0);
  if ( !p )
  {
    fflush(stdout);
    v1 = quantum_strerr(errno);
    fprintf(stderr, "ERROR: %s\n", v1);
    fflush(stderr);
    abort();
  }
  p(errno);
}

//----- (0804A088) --------------------------------------------------------
void __cdecl quantum_exp_mod_n(int N, int x, int width_input, int width, quantum_reg *reg)
{
  int f; // [esp+2Ch] [ebp-Ch]
  int j; // [esp+30h] [ebp-8h]
  int i; // [esp+34h] [ebp-4h]

  quantum_sigma_x(2 * (width + 1), reg);
  for ( i = 1; i <= width_input; ++i )
  {
    f = x % N;
    for ( j = 1; j < i; ++j )
      f = f * f % N;
    mul_mod_n(N, f, i + 3 * width + 1, width, reg);
  }
}

//----- (0804A130) --------------------------------------------------------
void __cdecl quantum_cnot(int control, int target, quantum_reg *reg)
{
  quantum_reg_node *v3; // eax
  unsigned int v4; // edx
  int v5; // eax
  unsigned int v6; // edx
  int v7; // edi
  quantum_reg_node *v8; // [esp+24h] [ebp-24h]
  int qec; // [esp+30h] [ebp-18h] BYREF
  int i; // [esp+34h] [ebp-14h]

  quantum_qec_get_status(&qec, 0);
  if ( qec )
  {
    quantum_cnot_ft(control, target, reg);
  }
  else if ( !quantum_objcode_put(1u, control, target) )
  {
    for ( i = 0; reg->size > i; ++i )
    {
      v3 = &reg->node[i];
      v4 = HIDWORD(v3->state);
      v5 = v3->state >> control;
      v6 = v4 >> control;
      if ( (control & 0x20) != 0 )
        LOBYTE(v5) = v6;
      if ( (v5 & 1) != 0 )
      {
        v8 = &reg->node[i];
        v7 = HIDWORD(v8->state);
        LODWORD(v8->state) ^= 1LL << target;
        HIDWORD(v8->state) = ((unsigned __int64)(1LL << target) >> 32) ^ v7;
      }
    }
    quantum_decohere(reg);
  }
}

//----- (0804A252) --------------------------------------------------------
void __cdecl quantum_toffoli(int control1, int control2, int target, quantum_reg *reg)
{
  quantum_reg_node *v4; // eax
  unsigned int v5; // edx
  int v6; // eax
  unsigned int v7; // edx
  quantum_reg_node *v8; // eax
  unsigned int v9; // edx
  int v10; // eax
  unsigned int v11; // edx
  int v12; // edi
  quantum_reg_node *v13; // [esp+24h] [ebp-24h]
  int qec; // [esp+30h] [ebp-18h] BYREF
  int i; // [esp+34h] [ebp-14h]

  quantum_qec_get_status(&qec, 0);
  if ( qec )
  {
    quantum_toffoli_ft(control1, control2, target, reg);
  }
  else if ( !quantum_objcode_put(2u, control1, control2, target) )
  {
    for ( i = 0; reg->size > i; ++i )
    {
      v4 = &reg->node[i];
      v5 = HIDWORD(v4->state);
      v6 = v4->state >> control1;
      v7 = v5 >> control1;
      if ( (control1 & 0x20) != 0 )
        LOBYTE(v6) = v7;
      if ( (v6 & 1) != 0 )
      {
        v8 = &reg->node[i];
        v9 = HIDWORD(v8->state);
        v10 = v8->state >> control2;
        v11 = v9 >> control2;
        if ( (control2 & 0x20) != 0 )
          LOBYTE(v10) = v11;
        if ( (v10 & 1) != 0 )
        {
          v13 = &reg->node[i];
          v12 = HIDWORD(v13->state);
          LODWORD(v13->state) ^= 1LL << target;
          HIDWORD(v13->state) = ((unsigned __int64)(1LL << target) >> 32) ^ v12;
        }
      }
    }
    quantum_decohere(reg);
  }
}

//----- (0804A3B3) --------------------------------------------------------
void quantum_unbounded_toffoli(int controlling, quantum_reg *reg, ...)
{
  _DWORD *v2; // edx
  int v3; // ecx
  unsigned __int64 v4; // rax
  int v5; // edi
  quantum_reg_node *v6; // [esp+14h] [ebp-34h]
  int j; // [esp+24h] [ebp-24h]
  int i; // [esp+28h] [ebp-20h]
  int ia; // [esp+28h] [ebp-20h]
  int *controls; // [esp+2Ch] [ebp-1Ch]
  int target; // [esp+30h] [ebp-18h]
  va_list bits; // [esp+34h] [ebp-14h]
  va_list va; // [esp+58h] [ebp+10h] BYREF

  va_start(va, reg);
  controls = (int *)malloc(4 * controlling);
  if ( !controls )
    quantum_error(2);
  quantum_memman(4 * controlling);
  va_copy(bits, va);
  for ( i = 0; i < controlling; ++i )
  {
    v2 = bits;
    bits += 4;
    controls[i] = *v2;
  }
  target = *(_DWORD *)bits;
  for ( ia = 0; reg->size > ia; ++ia )
  {
    for ( j = 0; j < controlling; ++j )
    {
      v3 = controls[j];
      v4 = reg->node[ia].state >> (v3 & 0x1F);
      if ( (v3 & 0x20) != 0 )
        LOBYTE(v4) = reg->node[ia].state >> (v3 & 0x1F) >> 32;
      if ( (v4 & 1) == 0 )
        break;
    }
    if ( j == controlling )
    {
      v6 = &reg->node[ia];
      v5 = HIDWORD(v6->state);
      LODWORD(v6->state) ^= 1LL << target;
      HIDWORD(v6->state) = ((unsigned __int64)(1LL << target) >> 32) ^ v5;
    }
  }
  free(controls);
  quantum_memman(-4 * controlling);
  quantum_decohere(reg);
}

//----- (0804A535) --------------------------------------------------------
void __cdecl quantum_sigma_x(int target, quantum_reg *reg)
{
  int v2; // edi
  quantum_reg_node *v3; // [esp+14h] [ebp-24h]
  int qec; // [esp+20h] [ebp-18h] BYREF
  int i; // [esp+24h] [ebp-14h]

  quantum_qec_get_status(&qec, 0);
  if ( qec )
  {
    quantum_sigma_x_ft(target, reg);
  }
  else if ( !quantum_objcode_put(3u, target) )
  {
    for ( i = 0; reg->size > i; ++i )
    {
      v3 = &reg->node[i];
      v2 = HIDWORD(v3->state);
      LODWORD(v3->state) ^= 1LL << target;
      HIDWORD(v3->state) = ((unsigned __int64)(1LL << target) >> 32) ^ v2;
    }
    quantum_decohere(reg);
  }
}

//----- (0804A615) --------------------------------------------------------
void __cdecl quantum_sigma_y(int target, quantum_reg *reg)
{
  int v2; // edi
  quantum_reg_node *v3; // eax
  unsigned int v4; // edx
  int v5; // eax
  unsigned int v6; // edx
  quantum_reg_node *v7; // esi
  float v8; // edx
  quantum_reg_node *v9; // [esp+24h] [ebp-24h]
  int i; // [esp+34h] [ebp-14h]

  if ( !quantum_objcode_put(4u, target) )
  {
    for ( i = 0; reg->size > i; ++i )
    {
      v9 = &reg->node[i];
      v2 = HIDWORD(v9->state);
      LODWORD(v9->state) ^= 1LL << target;
      HIDWORD(v9->state) = ((unsigned __int64)(1LL << target) >> 32) ^ v2;
      v3 = &reg->node[i];
      v4 = HIDWORD(v3->state);
      v5 = v3->state >> target;
      v6 = v4 >> target;
      if ( (target & 0x20) != 0 )
        LOBYTE(v5) = v6;
      v7 = &reg->node[i];
      if ( (v5 & 1) != 0 )
        LODWORD(v7->amplitude.real) = _mulsc3(reg->node[i].amplitude.real, reg->node[i].amplitude.imag, 0.0, 1.0);
      else
        LODWORD(v7->amplitude.real) = _mulsc3(reg->node[i].amplitude.real, reg->node[i].amplitude.imag, 0.0, -1.0);
      v7->amplitude.imag = v8;
    }
    quantum_decohere(reg);
  }
}
// 804A721: variable 'v8' is possibly undefined

//----- (0804A79E) --------------------------------------------------------
void __cdecl quantum_sigma_z(int target, quantum_reg *reg)
{
  quantum_reg_node *v2; // eax
  unsigned int v3; // edx
  int v4; // eax
  unsigned int v5; // edx
  quantum_reg_node *v6; // ecx
  float v7; // eax
  float v8; // [esp+14h] [ebp-14h]
  float v9; // [esp+14h] [ebp-14h]
  int i; // [esp+24h] [ebp-4h]

  if ( !quantum_objcode_put(5u, target) )
  {
    for ( i = 0; reg->size > i; ++i )
    {
      v2 = &reg->node[i];
      v3 = HIDWORD(v2->state);
      v4 = v2->state >> target;
      v5 = v3 >> target;
      if ( (target & 0x20) != 0 )
        LOBYTE(v4) = v5;
      if ( (v4 & 1) != 0 )
      {
        v6 = &reg->node[i];
        v8 = -v6->amplitude.real;
        v7 = v8;
        v9 = -v6->amplitude.imag;
        v6->amplitude.real = v7;
        v6->amplitude.imag = v9;
      }
    }
    quantum_decohere(reg);
  }
}

//----- (0804A85F) --------------------------------------------------------
void __cdecl quantum_swaptheleads(int width, quantum_reg *reg)
{
  __int64 v2; // rax
  __int64 v3; // rax
  int qec; // [esp+24h] [ebp-24h] BYREF
  int pat2; // [esp+28h] [ebp-20h]
  int pat1; // [esp+2Ch] [ebp-1Ch]
  int j; // [esp+30h] [ebp-18h]
  int i; // [esp+34h] [ebp-14h]

  quantum_qec_get_status(&qec, 0);
  if ( qec )
  {
    for ( i = 0; i < width; ++i )
    {
      quantum_cnot(i, width + i, reg);
      quantum_cnot(width + i, i, reg);
      quantum_cnot(i, width + i, reg);
    }
  }
  else
  {
    for ( i = 0; reg->size > i && !quantum_objcode_put(0xEu, width); ++i )
    {
      v2 = 1LL << (width & 0x1F);
      if ( (width & 0x20) != 0 )
        LODWORD(v2) = 0;
      pat1 = LODWORD(reg->node[i].state) & (v2 - 1);
      pat2 = 0;
      for ( j = 0; j < width; ++j )
      {
        v3 = 1LL << ((width + j) & 0x1F);
        if ( (((_BYTE)width + (_BYTE)j) & 0x20) != 0 )
          LODWORD(v3) = 0;
        pat2 += v3 & LODWORD(reg->node[i].state);
      }
      reg->node[i].state = (pat2 >> width) + (pat1 << width) + reg->node[i].state - (pat2 + pat1);
    }
  }
}

//----- (0804AA4B) --------------------------------------------------------
void __cdecl quantum_swaptheleads_omuln_controlled(int control, int width, quantum_reg *reg)
{
  int i; // [esp+24h] [ebp-4h]

  for ( i = 0; i < width; ++i )
  {
    quantum_toffoli(control, width + i, i + 2 * width + 2, reg);
    quantum_toffoli(control, i + 2 * width + 2, width + i, reg);
    quantum_toffoli(control, width + i, i + 2 * width + 2, reg);
  }
}

//----- (0804AAF9) --------------------------------------------------------
void __cdecl quantum_gate1(int target, quantum_matrix m, quantum_reg *reg)
{
  quantum_reg_node *v3; // eax
  quantum_reg_node *v4; // edx
  __int64 v5; // rax
  quantum_reg_node *v6; // eax
  quantum_reg_node *v7; // eax
  quantum_reg_node *v8; // esi
  float v9; // edi
  float v10; // edx
  float v11; // edx
  float v12; // eax
  float v13; // edi
  float v14; // edx
  float v15; // edx
  quantum_reg_node *v16; // esi
  float v17; // edi
  float v18; // edx
  float v19; // edx
  float v20; // eax
  float v21; // edi
  float v22; // edx
  float v23; // edx
  quantum_reg_node *v24; // eax
  int v25; // edi
  quantum_reg_node *v26; // esi
  float v27; // edx
  quantum_reg_node *v28; // ecx
  quantum_reg_node *v29; // eax
  int v30; // edx
  quantum_reg_node *v31; // ecx
  quantum_reg_node *v32; // eax
  float v33; // edx
  float v34; // eax
  float v35; // [esp+2Ch] [ebp-9Ch]
  float v36; // [esp+2Ch] [ebp-9Ch]
  float v37; // [esp+2Ch] [ebp-9Ch]
  float v38; // [esp+2Ch] [ebp-9Ch]
  float v39; // [esp+2Ch] [ebp-9Ch]
  float v40; // [esp+2Ch] [ebp-9Ch]
  long double v41; // [esp+40h] [ebp-88h]
  float v42; // [esp+50h] [ebp-78h]
  float v43; // [esp+54h] [ebp-74h]
  float v44; // [esp+58h] [ebp-70h]
  float v45; // [esp+5Ch] [ebp-6Ch]
  quantum_reg_node *v46; // [esp+60h] [ebp-68h]
  float tnot; // [esp+7Ch] [ebp-4Ch]
  float tnot_4; // [esp+80h] [ebp-48h]
  float t; // [esp+84h] [ebp-44h]
  float t_4; // [esp+88h] [ebp-40h]
  char *done; // [esp+8Ch] [ebp-3Ch]
  float limit; // [esp+90h] [ebp-38h]
  int sorted; // [esp+94h] [ebp-34h]
  int decsize; // [esp+98h] [ebp-30h]
  int addsize; // [esp+9Ch] [ebp-2Ch]
  int iset; // [esp+A0h] [ebp-28h]
  int k; // [esp+A4h] [ebp-24h]
  int j; // [esp+A8h] [ebp-20h]
  int ja; // [esp+A8h] [ebp-20h]
  int i; // [esp+ACh] [ebp-1Ch]
  int ia; // [esp+ACh] [ebp-1Ch]
  int ib; // [esp+ACh] [ebp-1Ch]
  int ic; // [esp+ACh] [ebp-1Ch]

  addsize = 0;
  decsize = 0;
  sorted = 1;
  if ( m.cols != 2 || m.rows != 2 )
    quantum_error(4);
  quantum_reconstruct_hash_0(reg);
  for ( i = 0; reg->size > i; ++i )
  {
    if ( sorted && reg->node[i].state != i )
      sorted = 0;
    if ( quantum_get_state_0((1LL << target) ^ reg->node[i].state, *reg) == -1 )
      ++addsize;
  }
  reg->node = (quantum_reg_node *)realloc(reg->node, 16 * (addsize + reg->size));
  if ( !reg->node )
    quantum_error(2);
  quantum_memman(16 * addsize);
  for ( ia = 0; ia < addsize; ++ia )
  {
    v3 = &reg->node[ia + reg->size];
    LODWORD(v3->state) = 0;
    HIDWORD(v3->state) = 0;
    v4 = &reg->node[ia + reg->size];
    v4->amplitude.real = 0.0;
    v4->amplitude.imag = 0.0;
  }
  done = (char *)calloc(addsize + reg->size, 1u);
  if ( !done )
    quantum_error(2);
  quantum_memman(reg->size + addsize);
  k = reg->size;
  v41 = (long double)(unsigned __int64)(1LL << reg->width);
  for ( ib = 0; reg->size > ib; ++ib )
  {
    if ( !done[ib] )
    {
      v5 = 1LL << (target & 0x1F);
      if ( (target & 0x20) != 0 )
        LODWORD(v5) = 0;
      iset = LODWORD(reg->node[ib].state) & v5;
      tnot = 0.0;
      tnot_4 = 0.0;
      j = quantum_get_state_0((1LL << target) ^ reg->node[ib].state, *reg);
      v6 = &reg->node[ib];
      t = v6->amplitude.real;
      t_4 = v6->amplitude.imag;
      if ( j >= 0 )
      {
        v7 = &reg->node[j];
        tnot = v7->amplitude.real;
        tnot_4 = v7->amplitude.imag;
      }
      v8 = &reg->node[ib];
      if ( iset )
      {
        v9 = COERCE_FLOAT(_mulsc3(m.t[2].real, m.t[2].imag, tnot, tnot_4));
        v42 = v10;
        v35 = v9 + COERCE_FLOAT(_mulsc3(m.t[3].real, m.t[3].imag, t, t_4));
        v12 = v35;
        v36 = v42 + v11;
      }
      else
      {
        v13 = COERCE_FLOAT(_mulsc3(m.t->real, m.t->imag, t, t_4));
        v43 = v14;
        v37 = v13 + COERCE_FLOAT(_mulsc3(m.t[1].real, m.t[1].imag, tnot, tnot_4));
        v12 = v37;
        v36 = v43 + v15;
      }
      v8->amplitude.real = v12;
      v8->amplitude.imag = v36;
      if ( j < 0 )
      {
        if ( 0.0 == m.t[1].real && 0.0 == m.t[1].imag && iset || 0.0 == m.t[2].real && 0.0 == m.t[2].imag && !iset )
          break;
        v46 = &reg->node[k];
        v24 = &reg->node[ib];
        v25 = HIDWORD(v24->state);
        LODWORD(v46->state) = (1LL << target) ^ LODWORD(v24->state);
        HIDWORD(v46->state) = ((unsigned __int64)(1LL << target) >> 32) ^ v25;
        v26 = &reg->node[k];
        if ( iset )
          LODWORD(v26->amplitude.real) = _mulsc3(m.t[1].real, m.t[1].imag, t, t_4);
        else
          LODWORD(v26->amplitude.real) = _mulsc3(m.t[2].real, m.t[2].imag, t, t_4);
        v26->amplitude.imag = v27;
        ++k;
      }
      else
      {
        v16 = &reg->node[j];
        if ( iset )
        {
          v17 = COERCE_FLOAT(_mulsc3(m.t->real, m.t->imag, tnot, tnot_4));
          v44 = v18;
          v38 = v17 + COERCE_FLOAT(_mulsc3(m.t[1].real, m.t[1].imag, t, t_4));
          v20 = v38;
          v39 = v44 + v19;
        }
        else
        {
          v21 = COERCE_FLOAT(_mulsc3(m.t[2].real, m.t[2].imag, t, t_4));
          v45 = v22;
          v40 = v21 + COERCE_FLOAT(_mulsc3(m.t[3].real, m.t[3].imag, tnot, tnot_4));
          v20 = v40;
          v39 = v45 + v23;
        }
        v16->amplitude.real = v20;
        v16->amplitude.imag = v39;
      }
      if ( j >= 0 )
        done[j] = 1;
    }
  }
  reg->size += addsize;
  free(done);
  quantum_memman(-reg->size);
  if ( !sorted )
  {
    ic = 0;
    ja = 0;
    while ( reg->size > ic )
    {
      limit = 1.0 / (double)v41 * 0.000001;
      if ( (long double)limit <= quantum_prob_inline_1(reg->node[ic].amplitude) )
      {
        if ( ja )
        {
          v28 = &reg->node[ic - ja];
          v29 = &reg->node[ic];
          v30 = HIDWORD(v29->state);
          LODWORD(v28->state) = v29->state;
          HIDWORD(v28->state) = v30;
          v31 = &reg->node[ic - ja];
          v32 = &reg->node[ic];
          v33 = v32->amplitude.real;
          v34 = v32->amplitude.imag;
          v31->amplitude.real = v33;
          v31->amplitude.imag = v34;
        }
      }
      else
      {
        ++ja;
        ++decsize;
      }
      ++ic;
    }
    if ( decsize )
    {
      reg->size -= decsize;
      reg->node = (quantum_reg_node *)realloc(reg->node, 16 * reg->size);
      if ( !reg->node )
        quantum_error(2);
      quantum_memman(-16 * decsize);
    }
  }
  quantum_decohere(reg);
}
// 804AEF5: variable 'v10' is possibly undefined
// 804AF50: variable 'v11' is possibly undefined
// 804AFB9: variable 'v14' is possibly undefined
// 804B014: variable 'v15' is possibly undefined
// 804B08C: variable 'v18' is possibly undefined
// 804B0E7: variable 'v19' is possibly undefined
// 804B153: variable 'v22' is possibly undefined
// 804B1AE: variable 'v23' is possibly undefined
// 804B332: variable 'v27' is possibly undefined

//----- (0804B509) --------------------------------------------------------
void __cdecl quantum_reconstruct_hash_0(quantum_reg *reg)
{
  int i; // [esp+24h] [ebp-4h]
  int ia; // [esp+24h] [ebp-4h]

  for ( i = 0; 1 << reg->hashw > i; ++i )
    reg->hash[i] = 0;
  for ( ia = 0; reg->size > ia; ++ia )
    quantum_add_hash_0(reg->node[ia].state, ia, reg);
}

//----- (0804B58C) --------------------------------------------------------
void __cdecl quantum_add_hash_0(unsigned __int64 a, int pos, quantum_reg *reg)
{
  int mark; // [esp+20h] [ebp-8h]
  int i; // [esp+24h] [ebp-4h]

  mark = 0;
  i = quantum_hash64_0(a, reg->hashw);
  while ( reg->hash[i] )
  {
    if ( 1 << reg->hashw == ++i )
    {
      if ( mark )
      {
        quantum_error(5);
      }
      else
      {
        i = 0;
        mark = 1;
      }
    }
  }
  reg->hash[i] = pos + 1;
}

//----- (0804B62B) --------------------------------------------------------
unsigned int __cdecl quantum_hash64_0(unsigned __int64 key, int width)
{
  return (-1640562687 * ((unsigned int)key ^ HIDWORD(key))) >> (32 - width);
}

//----- (0804B66D) --------------------------------------------------------
int __cdecl quantum_get_state_0(unsigned __int64 a, quantum_reg reg)
{
  int i; // [esp+2Ch] [ebp-4h]

  if ( !reg.hashw )
    return a;
  i = quantum_hash64_0(a, reg.hashw);
  while ( reg.hash[i] )
  {
    if ( a == reg.node[-(1 - reg.hash[i])].state )
      return reg.hash[i] - 1;
    if ( 1 << SLOBYTE(reg.hashw) == ++i )
      i = 0;
  }
  return -1;
}

//----- (0804B733) --------------------------------------------------------
float __cdecl quantum_prob_inline_1(complex_float a)
{
  float i; // [esp+10h] [ebp-8h]
  float r; // [esp+14h] [ebp-4h]

  r = quantum_real_1(a);
  i = quantum_imag_1(a);
  return r * r + i * i;
}

//----- (0804B773) --------------------------------------------------------
float __cdecl quantum_real_1(complex_float a)
{
  return a.real;
}

//----- (0804B78C) --------------------------------------------------------
float __cdecl quantum_imag_1(complex_float a)
{
  return a.imag;
}

//----- (0804B7A8) --------------------------------------------------------
void __cdecl quantum_gate2(int target1, int target2, quantum_matrix m, quantum_reg *reg)
{
  quantum_reg_node *v4; // eax
  quantum_reg_node *v5; // edx
  quantum_reg_node *v6; // eax
  int v7; // edi
  int v8; // eax
  int v9; // esi
  int v10; // ebx
  unsigned __int64 v11; // rcx
  int v12; // ecx
  quantum_reg_node *v13; // eax
  float v14; // edx
  float v15; // eax
  quantum_reg_node *v16; // edx
  quantum_reg_node *v17; // edi
  float v18; // edx
  float v19; // eax
  long double v20; // fst7
  quantum_reg_node *v21; // ecx
  quantum_reg_node *v22; // eax
  int v23; // edx
  quantum_reg_node *v24; // ecx
  quantum_reg_node *v25; // eax
  float v26; // edx
  float v27; // eax
  float v28; // [esp+3Ch] [ebp-BCh]
  float v29; // [esp+3Ch] [ebp-BCh]
  int v30; // [esp+60h] [ebp-98h]
  int v31; // [esp+64h] [ebp-94h]
  int v32; // [esp+68h] [ebp-90h]
  float v33; // [esp+6Ch] [ebp-8Ch]
  float v34; // [esp+70h] [ebp-88h]
  complex_float psi_sub[4]; // [esp+88h] [ebp-70h]
  int base[4]; // [esp+A8h] [ebp-50h]
  int bits[2]; // [esp+B8h] [ebp-40h] BYREF
  char *done; // [esp+C0h] [ebp-38h]
  float limit; // [esp+C4h] [ebp-34h]
  int decsize; // [esp+C8h] [ebp-30h]
  int addsize; // [esp+CCh] [ebp-2Ch]
  int l; // [esp+D0h] [ebp-28h]
  int k; // [esp+D4h] [ebp-24h]
  int j; // [esp+D8h] [ebp-20h]
  int i; // [esp+DCh] [ebp-1Ch]

  addsize = 0;
  decsize = 0;
  if ( m.cols != 4 || m.rows != 4 )
    quantum_error(4);
  for ( i = 0; 1 << reg->hashw > i; ++i )
    reg->hash[i] = 0;
  for ( i = 0; reg->size > i; ++i )
    quantum_add_hash_0(reg->node[i].state, i, reg);
  for ( i = 0; reg->size > i; ++i )
  {
    if ( quantum_get_state_0((1LL << target1) ^ reg->node[i].state, *reg) == -1 )
      ++addsize;
    if ( quantum_get_state_0((1LL << target2) ^ reg->node[i].state, *reg) == -1 )
      ++addsize;
  }
  reg->node = (quantum_reg_node *)realloc(reg->node, 16 * (addsize + reg->size));
  if ( !reg->node )
    quantum_error(4);
  quantum_memman(16 * addsize);
  for ( i = 0; i < addsize; ++i )
  {
    v4 = &reg->node[i + reg->size];
    LODWORD(v4->state) = 0;
    HIDWORD(v4->state) = 0;
    v5 = &reg->node[i + reg->size];
    v5->amplitude.real = 0.0;
    v5->amplitude.imag = 0.0;
  }
  done = (char *)calloc(addsize + reg->size, 1u);
  if ( !done )
    quantum_error(4);
  quantum_memman(reg->size + addsize);
  l = reg->size;
  limit = 1.0 / (double)(unsigned __int64)(1LL << reg->width) / 1000000.0;
  bits[0] = target1;
  bits[1] = target2;
  for ( i = 0; reg->size > i; ++i )
  {
    if ( !done[i] )
    {
      j = quantum_bitmask(reg->node[i].state, 2, bits);
      base[j] = i;
      v30 = j ^ 1;
      base[v30] = quantum_get_state_0((1LL << target2) ^ reg->node[i].state, *reg);
      v31 = j ^ 2;
      base[v31] = quantum_get_state_0((1LL << target1) ^ reg->node[i].state, *reg);
      v6 = &reg->node[i];
      v7 = HIDWORD(v6->state);
      v8 = (1LL << target1) ^ LODWORD(v6->state);
      v9 = (unsigned __int64)(1LL << target2) >> 32;
      v10 = 1 << target2;
      if ( (target2 & 0x20) != 0 )
      {
        v9 = 1 << target2;
        v10 = 0;
      }
      LODWORD(v11) = v8 ^ v10;
      HIDWORD(v11) = ((unsigned __int64)(1LL << target1) >> 32) ^ v7 ^ v9;
      v32 = j ^ 3;
      base[v32] = quantum_get_state_0(v11, *reg);
      for ( j = 0; j <= 3; ++j )
      {
        if ( base[j] == -1 )
          base[j] = l++;
        v12 = j;
        v13 = &reg->node[base[j]];
        v14 = v13->amplitude.real;
        v15 = v13->amplitude.imag;
        psi_sub[j].real = v14;
        psi_sub[v12].imag = v15;
      }
      for ( j = 0; j <= 3; ++j )
      {
        v16 = &reg->node[base[j]];
        v16->amplitude.real = 0.0;
        v16->amplitude.imag = 0.0;
        for ( k = 0; k <= 3; ++k )
        {
          v17 = &reg->node[base[j]];
          v34 = v17->amplitude.real;
          v33 = v17->amplitude.imag;
          v28 = v34
              + COERCE_FLOAT(_mulsc3(m.t[k + j * m.cols].real, m.t[k + j * m.cols].imag, psi_sub[k].real, psi_sub[k].imag));
          v19 = v28;
          v29 = v33 + v18;
          v17->amplitude.real = v19;
          v17->amplitude.imag = v29;
        }
        done[base[j]] = 1;
      }
    }
  }
  reg->size += addsize;
  free(done);
  quantum_memman(-reg->size);
  i = 0;
  j = 0;
  while ( reg->size > i )
  {
    v20 = quantum_prob_inline_1(reg->node[i].amplitude);
    if ( limit <= v20 )
    {
      if ( j )
      {
        v21 = &reg->node[i - j];
        v22 = &reg->node[i];
        v23 = HIDWORD(v22->state);
        LODWORD(v21->state) = v22->state;
        HIDWORD(v21->state) = v23;
        v24 = &reg->node[i - j];
        v25 = &reg->node[i];
        v26 = v25->amplitude.real;
        v27 = v25->amplitude.imag;
        v24->amplitude.real = v26;
        v24->amplitude.imag = v27;
      }
    }
    else
    {
      ++j;
      ++decsize;
    }
    ++i;
  }
  if ( decsize )
  {
    reg->size -= decsize;
    reg->node = (quantum_reg_node *)realloc(reg->node, 16 * reg->size);
    if ( !reg->node )
      quantum_error(2);
    quantum_memman(-16 * decsize);
  }
  quantum_decohere(reg);
}
// 804BE9B: variable 'v18' is possibly undefined

//----- (0804C059) --------------------------------------------------------
int __cdecl quantum_bitmask(unsigned __int64 a, int width, int *bits)
{
  int v3; // ecx
  unsigned __int64 v4; // rax
  int mask; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  mask = 0;
  for ( i = 0; i < width; ++i )
  {
    v3 = bits[i];
    v4 = a >> (v3 & 0x1F);
    if ( (v3 & 0x20) != 0 )
      LOBYTE(v4) = a >> (v3 & 0x1F) >> 32;
    if ( (v4 & 1) != 0 )
      mask += 1 << i;
  }
  return mask;
}

//----- (0804C0BF) --------------------------------------------------------
void __cdecl quantum_hadamard(int target, quantum_reg *reg)
{
  complex_float *v2; // edx
  complex_float *v3; // edx
  complex_float *v4; // edx
  complex_float *v5; // edx
  quantum_matrix v6; // [esp+20h] [ebp-28h] BYREF
  quantum_matrix m; // [esp+34h] [ebp-14h] BYREF

  if ( !quantum_objcode_put(6u, target) )
  {
    quantum_new_matrix(&v6, 2, 2);
    m = v6;
    v2 = v6.t;
    v6.t->real = 0.70710677;
    v2->imag = 0.0;
    v3 = m.t + 1;
    m.t[1].real = 0.70710677;
    v3->imag = 0.0;
    v4 = m.t + 2;
    m.t[2].real = 0.70710677;
    v4->imag = 0.0;
    v5 = m.t + 3;
    m.t[3].real = -0.70710677;
    v5->imag = 0.0;
    quantum_gate1(target, m, reg);
    quantum_delete_matrix(&m);
  }
}

//----- (0804C195) --------------------------------------------------------
void __cdecl quantum_walsh(int width, quantum_reg *reg)
{
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i < width; ++i )
    quantum_hadamard(i, reg);
}

//----- (0804C1C4) --------------------------------------------------------
void __cdecl quantum_r_x(int target, float gamma, quantum_reg *reg)
{
  complex_float *v3; // ebx
  complex_float *v4; // ebx
  long double v5; // fst7
  long double v6; // fst7
  float v7; // edx
  complex_float *v8; // ebx
  long double v9; // fst7
  long double v10; // fst7
  float v11; // edx
  complex_float *v12; // ebx
  float v13; // [esp+3Ch] [ebp-4Ch]
  float v14; // [esp+3Ch] [ebp-4Ch]
  double v15; // [esp+48h] [ebp-40h] BYREF
  double v16; // [esp+50h] [ebp-38h]
  float v17; // [esp+5Ch] [ebp-2Ch]
  quantum_matrix v18; // [esp+60h] [ebp-28h] BYREF
  quantum_matrix m; // [esp+74h] [ebp-14h] BYREF

  if ( !quantum_objcode_put(7u, target, gamma) )
  {
    quantum_new_matrix(&v18, 2, 2);
    m = v18;
    v3 = v18.t;
    v17 = cos(gamma / 2.0);
    v3->real = v17;
    v3->imag = 0.0;
    v4 = m.t + 1;
    v5 = sin(gamma / 2.0);
    _muldc3(&v15, v5, 0.0, 0.0, -1.0);
    v17 = v15;
    v6 = v17;
    v17 = v16;
    v13 = v6;
    v7 = v17;
    v4->real = v13;
    v4->imag = v7;
    v8 = m.t + 2;
    v9 = sin(gamma / 2.0);
    _muldc3(&v15, v9, 0.0, 0.0, -1.0);
    v17 = v15;
    v10 = v17;
    v17 = v16;
    v14 = v10;
    v11 = v17;
    v8->real = v14;
    v8->imag = v11;
    v12 = m.t + 3;
    v17 = cos(gamma / 2.0);
    v12->real = v17;
    v12->imag = 0.0;
    quantum_gate1(target, m, reg);
    quantum_delete_matrix(&m);
  }
}

//----- (0804C382) --------------------------------------------------------
void __cdecl quantum_r_y(int target, float gamma, quantum_reg *reg)
{
  complex_float *v3; // ebx
  complex_float *v4; // ebx
  complex_float *v5; // ebx
  complex_float *v6; // ebx
  float v7; // [esp+3Ch] [ebp-2Ch]
  float v8; // [esp+3Ch] [ebp-2Ch]
  float v9; // [esp+3Ch] [ebp-2Ch]
  float v10; // [esp+3Ch] [ebp-2Ch]
  quantum_matrix v11; // [esp+40h] [ebp-28h] BYREF
  quantum_matrix m; // [esp+54h] [ebp-14h] BYREF

  if ( !quantum_objcode_put(8u, target, gamma) )
  {
    quantum_new_matrix(&v11, 2, 2);
    m = v11;
    v3 = v11.t;
    v7 = cos(gamma / 2.0);
    v3->real = v7;
    v3->imag = 0.0;
    v4 = m.t + 1;
    v8 = sin(gamma / -2.0);
    v4->real = v8;
    v4->imag = 0.0;
    v5 = m.t + 2;
    v9 = sin(gamma / 2.0);
    v5->real = v9;
    v5->imag = 0.0;
    v6 = m.t + 3;
    v10 = cos(gamma / 2.0);
    v6->real = v10;
    v6->imag = 0.0;
    quantum_gate1(target, m, reg);
    quantum_delete_matrix(&m);
  }
}

//----- (0804C4CB) --------------------------------------------------------
void __cdecl quantum_r_z(int target, float gamma, quantum_reg *reg)
{
  quantum_reg_node *v3; // eax
  unsigned int v4; // edx
  int v5; // eax
  unsigned int v6; // edx
  quantum_reg_node *v7; // esi
  float v8; // edx
  float v9; // [esp+0h] [ebp-28h]
  complex_float z; // [esp+14h] [ebp-14h]
  int i; // [esp+1Ch] [ebp-Ch]

  if ( !quantum_objcode_put(9u, target, gamma) )
  {
    v9 = gamma / 2.0;
    z = quantum_cexp(v9);
    for ( i = 0; reg->size > i; ++i )
    {
      v3 = &reg->node[i];
      v4 = HIDWORD(v3->state);
      v5 = v3->state >> target;
      v6 = v4 >> target;
      if ( (target & 0x20) != 0 )
        LOBYTE(v5) = v6;
      v7 = &reg->node[i];
      if ( (v5 & 1) != 0 )
        LODWORD(v7->amplitude.real) = _mulsc3(reg->node[i].amplitude.real, reg->node[i].amplitude.imag, z.real, z.imag);
      else
        LODWORD(v7->amplitude.real) = _divsc3(reg->node[i].amplitude.real, reg->node[i].amplitude.imag, z.real, z.imag);
      v7->amplitude.imag = v8;
    }
    quantum_decohere(reg);
  }
}
// 804C59A: variable 'v8' is possibly undefined

//----- (0804C612) --------------------------------------------------------
void __cdecl quantum_phase_scale(int target, float gamma, quantum_reg *reg)
{
  quantum_reg_node *v3; // esi
  float v4; // edx
  complex_float z; // [esp+14h] [ebp-14h]
  int i; // [esp+1Ch] [ebp-Ch]

  if ( !quantum_objcode_put(0xBu, target, gamma) )
  {
    z = quantum_cexp(gamma);
    for ( i = 0; reg->size > i; ++i )
    {
      v3 = &reg->node[i];
      LODWORD(v3->amplitude.real) = _mulsc3(v3->amplitude.real, v3->amplitude.imag, z.real, z.imag);
      v3->amplitude.imag = v4;
    }
    quantum_decohere(reg);
  }
}
// 804C6A9: variable 'v4' is possibly undefined

//----- (0804C6CD) --------------------------------------------------------
void __cdecl quantum_phase_kick(int target, float gamma, quantum_reg *reg)
{
  quantum_reg_node *v3; // eax
  unsigned int v4; // edx
  int v5; // eax
  unsigned int v6; // edx
  quantum_reg_node *v7; // esi
  float v8; // edx
  complex_float z; // [esp+14h] [ebp-14h]
  int i; // [esp+1Ch] [ebp-Ch]

  if ( !quantum_objcode_put(0xAu, target, gamma) )
  {
    z = quantum_cexp(gamma);
    for ( i = 0; reg->size > i; ++i )
    {
      v3 = &reg->node[i];
      v4 = HIDWORD(v3->state);
      v5 = v3->state >> target;
      v6 = v4 >> target;
      if ( (target & 0x20) != 0 )
        LOBYTE(v5) = v6;
      if ( (v5 & 1) != 0 )
      {
        v7 = &reg->node[i];
        LODWORD(v7->amplitude.real) = _mulsc3(v7->amplitude.real, v7->amplitude.imag, z.real, z.imag);
        v7->amplitude.imag = v8;
      }
    }
    quantum_decohere(reg);
  }
}
// 804C791: variable 'v8' is possibly undefined

//----- (0804C7B9) --------------------------------------------------------
void __cdecl quantum_cond_phase(int control, int target, quantum_reg *reg)
{
  quantum_reg_node *v3; // eax
  unsigned int v4; // edx
  int v5; // eax
  unsigned int v6; // edx
  quantum_reg_node *v7; // eax
  unsigned int v8; // edx
  int v9; // eax
  unsigned int v10; // edx
  quantum_reg_node *v11; // esi
  float v12; // edx
  float v13; // [esp+24h] [ebp-24h]
  complex_float z; // [esp+34h] [ebp-14h]
  int i; // [esp+3Ch] [ebp-Ch]

  if ( !quantum_objcode_put(0xCu, control, target) )
  {
    v13 = 3.141592653589793 / (double)(unsigned __int64)(1LL << ((unsigned __int8)control - (unsigned __int8)target));
    z = quantum_cexp(v13);
    for ( i = 0; reg->size > i; ++i )
    {
      v3 = &reg->node[i];
      v4 = HIDWORD(v3->state);
      v5 = v3->state >> control;
      v6 = v4 >> control;
      if ( (control & 0x20) != 0 )
        LOBYTE(v5) = v6;
      if ( (v5 & 1) != 0 )
      {
        v7 = &reg->node[i];
        v8 = HIDWORD(v7->state);
        v9 = v7->state >> target;
        v10 = v8 >> target;
        if ( (target & 0x20) != 0 )
          LOBYTE(v9) = v10;
        if ( (v9 & 1) != 0 )
        {
          v11 = &reg->node[i];
          LODWORD(v11->amplitude.real) = _mulsc3(v11->amplitude.real, v11->amplitude.imag, z.real, z.imag);
          v11->amplitude.imag = v12;
        }
      }
    }
    quantum_decohere(reg);
  }
}
// 804C901: variable 'v12' is possibly undefined

//----- (0804C929) --------------------------------------------------------
void __cdecl quantum_cond_phase_inv(int control, int target, quantum_reg *reg)
{
  quantum_reg_node *v3; // eax
  unsigned int v4; // edx
  int v5; // eax
  unsigned int v6; // edx
  quantum_reg_node *v7; // eax
  unsigned int v8; // edx
  int v9; // eax
  unsigned int v10; // edx
  quantum_reg_node *v11; // esi
  float v12; // edx
  float v13; // [esp+24h] [ebp-24h]
  complex_float z; // [esp+34h] [ebp-14h]
  int i; // [esp+3Ch] [ebp-Ch]

  v13 = -3.141592653589793 / (double)(unsigned __int64)(1LL << ((unsigned __int8)control - (unsigned __int8)target));
  z = quantum_cexp(v13);
  for ( i = 0; reg->size > i; ++i )
  {
    v3 = &reg->node[i];
    v4 = HIDWORD(v3->state);
    v5 = v3->state >> control;
    v6 = v4 >> control;
    if ( (control & 0x20) != 0 )
      LOBYTE(v5) = v6;
    if ( (v5 & 1) != 0 )
    {
      v7 = &reg->node[i];
      v8 = HIDWORD(v7->state);
      v9 = v7->state >> target;
      v10 = v8 >> target;
      if ( (target & 0x20) != 0 )
        LOBYTE(v9) = v10;
      if ( (v9 & 1) != 0 )
      {
        v11 = &reg->node[i];
        LODWORD(v11->amplitude.real) = _mulsc3(v11->amplitude.real, v11->amplitude.imag, z.real, z.imag);
        v11->amplitude.imag = v12;
      }
    }
  }
  quantum_decohere(reg);
}
// 804CA4F: variable 'v12' is possibly undefined

//----- (0804CA77) --------------------------------------------------------
void __cdecl quantum_cond_phase_kick(int control, int target, float gamma, quantum_reg *reg)
{
  quantum_reg_node *v4; // eax
  unsigned int v5; // edx
  int v6; // eax
  unsigned int v7; // edx
  quantum_reg_node *v8; // eax
  unsigned int v9; // edx
  int v10; // eax
  unsigned int v11; // edx
  quantum_reg_node *v12; // esi
  float v13; // edx
  complex_float z; // [esp+24h] [ebp-14h]
  int i; // [esp+2Ch] [ebp-Ch]

  if ( !quantum_objcode_put(0xCu, control, target, gamma) )
  {
    z = quantum_cexp(gamma);
    for ( i = 0; reg->size > i; ++i )
    {
      v4 = &reg->node[i];
      v5 = HIDWORD(v4->state);
      v6 = v4->state >> control;
      v7 = v5 >> control;
      if ( (control & 0x20) != 0 )
        LOBYTE(v6) = v7;
      if ( (v6 & 1) != 0 )
      {
        v8 = &reg->node[i];
        v9 = HIDWORD(v8->state);
        v10 = v8->state >> target;
        v11 = v9 >> target;
        if ( (target & 0x20) != 0 )
          LOBYTE(v10) = v11;
        if ( (v10 & 1) != 0 )
        {
          v12 = &reg->node[i];
          LODWORD(v12->amplitude.real) = _mulsc3(v12->amplitude.real, v12->amplitude.imag, z.real, z.imag);
          v12->amplitude.imag = v13;
        }
      }
    }
    quantum_decohere(reg);
  }
}
// 804CB72: variable 'v13' is possibly undefined

//----- (0804CB9A) --------------------------------------------------------
int __cdecl quantum_gate_counter(int inc)
{
  if ( inc <= 0 )
  {
    if ( inc < 0 )
      counter_4541 = 0;
  }
  else
  {
    counter_4541 += inc;
  }
  return counter_4541;
}

//----- (0804CBCC) --------------------------------------------------------
unsigned int __cdecl quantum_memman(int change)
{
  mem_2105 += change;
  if ( mem_2105 > max_2106 )
    max_2106 = mem_2105;
  return mem_2105;
}

//----- (0804CBFC) --------------------------------------------------------
quantum_matrix *__userpurge quantum_new_matrix@<eax>(quantum_matrix *retstr, int cols, int rows)
{
  complex_float *m_8; // [esp+14h] [ebp-4h]

  m_8 = (complex_float *)calloc(rows * cols, 8u);
  if ( !m_8 )
    quantum_error(2);
  quantum_memman(8 * cols * rows);
  retstr->rows = rows;
  retstr->cols = cols;
  retstr->t = m_8;
  return retstr;
}

//----- (0804CC70) --------------------------------------------------------
void __cdecl quantum_delete_matrix(quantum_matrix *m)
{
  free(m->t);
  quantum_memman(-8 * m->cols * m->rows);
  m->t = 0;
}

//----- (0804CCAD) --------------------------------------------------------
void __cdecl quantum_print_matrix(quantum_matrix m)
{
  long double v2; // fst7
  double v3; // [esp+20h] [ebp-18h]
  int z; // [esp+2Ch] [ebp-Ch]
  int j; // [esp+30h] [ebp-8h]
  int i; // [esp+34h] [ebp-4h]

  z = 0;
  while ( 1 << z++ < m.rows )
    ;
  for ( i = 0; m.rows > i; ++i )
  {
    for ( j = 0; m.cols > j; ++j )
    {
      v3 = quantum_imag_2(m.t[j + i * m.cols]);
      v2 = quantum_real_2(m.t[j + i * m.cols]);
      printf("%g %+gi ", (double)v2, v3);
    }
    putchar(10);
  }
  putchar(10);
}

//----- (0804CD85) --------------------------------------------------------
float __cdecl quantum_imag_2(complex_float a)
{
  return a.imag;
}

//----- (0804CDA1) --------------------------------------------------------
float __cdecl quantum_real_2(complex_float a)
{
  return a.real;
}

//----- (0804CDBA) --------------------------------------------------------
quantum_matrix *__userpurge quantum_mmult@<eax>(quantum_matrix *retstr, quantum_matrix A, quantum_matrix B)
{
  complex_float *v3; // esi
  float v4; // edi
  float v5; // edx
  float v6; // eax
  float v8; // [esp+14h] [ebp-34h]
  float v9; // [esp+14h] [ebp-34h]
  float v10; // [esp+18h] [ebp-30h]
  quantum_matrix C; // [esp+24h] [ebp-24h] BYREF
  int k; // [esp+30h] [ebp-18h]
  int j; // [esp+34h] [ebp-14h]
  int i; // [esp+38h] [ebp-10h]

  if ( A.cols != B.rows )
    quantum_error(4);
  quantum_new_matrix(&C, B.cols, A.rows);
  for ( i = 0; B.cols > i; ++i )
  {
    for ( j = 0; A.rows > j; ++j )
    {
      for ( k = 0; B.rows > k; ++k )
      {
        v3 = &C.t[i + j * C.cols];
        v4 = v3->real;
        v10 = v3->imag;
        v8 = v4
           + COERCE_FLOAT(
               _mulsc3(
                 A.t[k + j * A.cols].real,
                 A.t[k + j * A.cols].imag,
                 B.t[i + k * B.cols].real,
                 B.t[i + k * B.cols].imag));
        v6 = v8;
        v9 = v10 + v5;
        v3->real = v6;
        v3->imag = v9;
      }
    }
  }
  *retstr = C;
  return retstr;
}
// 804CEB0: variable 'v5' is possibly undefined

//----- (0804CF20) --------------------------------------------------------
long double quantum_frand()
{
  return (long double)rand() / 2147483647.0;
}

//----- (0804CF3D) --------------------------------------------------------
unsigned __int64 __cdecl quantum_measure(quantum_reg reg)
{
  double r; // [esp+18h] [ebp-10h]
  int i; // [esp+24h] [ebp-4h]

  if ( quantum_objcode_put(0x80u) )
    return 0LL;
  r = quantum_frand();
  for ( i = 0; reg.size > i; ++i )
  {
    r = r - quantum_prob_inline_2(reg.node[i].amplitude);
    if ( r <= 0.0 )
      return reg.node[i].state;
  }
  return -1LL;
}

//----- (0804CFE0) --------------------------------------------------------
float __cdecl quantum_prob_inline_2(complex_float a)
{
  float i; // [esp+10h] [ebp-8h]
  float r; // [esp+14h] [ebp-4h]

  r = quantum_real_3(a);
  i = quantum_imag_3(a);
  return r * r + i * i;
}

//----- (0804D020) --------------------------------------------------------
float __cdecl quantum_real_3(complex_float a)
{
  return a.real;
}

//----- (0804D039) --------------------------------------------------------
float __cdecl quantum_imag_3(complex_float a)
{
  return a.imag;
}

//----- (0804D055) --------------------------------------------------------
int __cdecl quantum_bmeasure(int pos, quantum_reg *reg)
{
  quantum_reg out; // [esp+3Ch] [ebp-3Ch] BYREF
  unsigned __int64 pos2; // [esp+50h] [ebp-28h]
  double r; // [esp+58h] [ebp-20h]
  double pa; // [esp+60h] [ebp-18h]
  int result; // [esp+68h] [ebp-10h]
  int i; // [esp+6Ch] [ebp-Ch]

  result = 0;
  pa = 0.0;
  if ( quantum_objcode_put(0x81u, pos) )
    return 0;
  pos2 = 1LL << pos;
  for ( i = 0; reg->size > i; ++i )
  {
    if ( (pos2 & reg->node[i].state) == 0 )
      pa = quantum_prob_inline_2(reg->node[i].amplitude) + pa;
  }
  r = quantum_frand();
  if ( r > (long double)pa )
    result = 1;
  quantum_state_collapse(&out, pos, result, *reg);
  quantum_delete_qureg_hashpreserve(reg);
  *reg = out;
  return result;
}

//----- (0804D1A8) --------------------------------------------------------
int __cdecl quantum_bmeasure_bitpreserve(int pos, quantum_reg *reg)
{
  quantum_reg_node *v2; // edx
  quantum_reg_node *v3; // edx
  quantum_reg_node *v4; // eax
  quantum_reg_node *v5; // ecx
  quantum_reg_node *v6; // eax
  int v7; // edx
  int v8; // eax
  int *v9; // ecx
  int v10; // edx
  float v13; // [esp+3Ch] [ebp-5Ch]
  int out; // [esp+4Ch] [ebp-4Ch]
  int out_8; // [esp+54h] [ebp-44h]
  quantum_reg_node *out_12; // [esp+58h] [ebp-40h]
  int *out_16; // [esp+5Ch] [ebp-3Ch]
  unsigned __int64 pos2; // [esp+60h] [ebp-38h]
  double pa; // [esp+70h] [ebp-28h]
  double d; // [esp+78h] [ebp-20h]
  int result; // [esp+80h] [ebp-18h]
  int size; // [esp+84h] [ebp-14h]
  int j; // [esp+88h] [ebp-10h]
  int i; // [esp+8Ch] [ebp-Ch]
  int ia; // [esp+8Ch] [ebp-Ch]
  int ib; // [esp+8Ch] [ebp-Ch]

  size = 0;
  result = 0;
  d = 0.0;
  pa = 0.0;
  if ( quantum_objcode_put(0x82u, pos) )
    return 0;
  pos2 = 1LL << pos;
  for ( i = 0; reg->size > i; ++i )
  {
    if ( (pos2 & reg->node[i].state) == 0 )
      pa = quantum_prob_inline_2(reg->node[i].amplitude) + pa;
  }
  if ( (double)quantum_frand() > (long double)pa )
    result = 1;
  for ( ia = 0; reg->size > ia; ++ia )
  {
    if ( (pos2 & reg->node[ia].state) != 0 )
    {
      if ( !result )
      {
        v2 = &reg->node[ia];
        v2->amplitude.real = 0.0;
        v2->amplitude.imag = 0.0;
        continue;
      }
    }
    else if ( result )
    {
      v3 = &reg->node[ia];
      v3->amplitude.real = 0.0;
      v3->amplitude.imag = 0.0;
      continue;
    }
    d = quantum_prob_inline_2(reg->node[ia].amplitude) + d;
    ++size;
  }
  out_12 = (quantum_reg_node *)calloc(size, 0x10u);
  if ( !out_12 )
    quantum_error(2);
  quantum_memman(16 * size);
  out_8 = reg->hashw;
  out_16 = reg->hash;
  out = reg->width;
  ib = 0;
  j = 0;
  while ( reg->size > ib )
  {
    v4 = &reg->node[ib];
    if ( v4->amplitude.real != 0.0 || v4->amplitude.imag != 0.0 )
    {
      v5 = &out_12[j];
      v6 = &reg->node[ib];
      v7 = HIDWORD(v6->state);
      LODWORD(v5->state) = v6->state;
      HIDWORD(v5->state) = v7;
      v13 = sqrt(d);
      v8 = _divsc3(reg->node[ib].amplitude.real, reg->node[ib].amplitude.imag, v13, 0.0);
      v9 = (int *)&out_12[j];
      *v9 = v8;
      v9[1] = v10;
      ++j;
    }
    ++ib;
  }
  quantum_delete_qureg_hashpreserve(reg);
  reg->width = out;
  reg->size = size;
  reg->hashw = out_8;
  reg->node = out_12;
  reg->hash = out_16;
  return result;
}
// 804D4DE: variable 'v10' is possibly undefined

//----- (0804D538) --------------------------------------------------------
void __cdecl test_sum(int compare, int width, quantum_reg *reg)
{
  int v3; // eax
  int i; // [esp+1Ch] [ebp-Ch]
  int ia; // [esp+1Ch] [ebp-Ch]

  v3 = (unsigned __int64)compare >> ((unsigned __int8)width - 1);
  if ( (((_BYTE)width - 1) & 0x20) != 0 )
    v3 = (unsigned int)(compare >> 31) >> (width - 1);
  if ( (v3 & 1) != 0 )
  {
    quantum_cnot(2 * width - 1, width - 1, reg);
    quantum_sigma_x(2 * width - 1, reg);
    quantum_cnot(2 * width - 1, 0, reg);
  }
  else
  {
    quantum_sigma_x(2 * width - 1, reg);
    quantum_cnot(2 * width - 1, width - 1, reg);
  }
  for ( i = width - 2; i > 0; --i )
  {
    if ( ((compare >> i) & 1) != 0 )
    {
      quantum_toffoli(i + 1, width + i, i, reg);
      quantum_sigma_x(width + i, reg);
      quantum_toffoli(i + 1, width + i, 0, reg);
    }
    else
    {
      quantum_sigma_x(width + i, reg);
      quantum_toffoli(i + 1, width + i, i, reg);
    }
  }
  if ( (compare & 1) != 0 )
  {
    quantum_sigma_x(width, reg);
    quantum_toffoli(width, 1, 0, reg);
  }
  quantum_toffoli(2 * width + 1, 0, 2 * width, reg);
  if ( (compare & 1) != 0 )
  {
    quantum_toffoli(width, 1, 0, reg);
    quantum_sigma_x(width, reg);
  }
  for ( ia = 1; width - 2 >= ia; ++ia )
  {
    if ( ((compare >> ia) & 1) != 0 )
    {
      quantum_toffoli(ia + 1, width + ia, 0, reg);
      quantum_sigma_x(width + ia, reg);
      quantum_toffoli(ia + 1, width + ia, ia, reg);
    }
    else
    {
      quantum_toffoli(ia + 1, width + ia, ia, reg);
      quantum_sigma_x(width + ia, reg);
    }
  }
  if ( ((compare >> (width - 1)) & 1) != 0 )
  {
    quantum_cnot(2 * width - 1, 0, reg);
    quantum_sigma_x(2 * width - 1, reg);
    quantum_cnot(2 * width - 1, width - 1, reg);
  }
  else
  {
    quantum_cnot(2 * width - 1, width - 1, reg);
    quantum_sigma_x(2 * width - 1, reg);
  }
}

//----- (0804D8FE) --------------------------------------------------------
void __cdecl muxfa(int a, int b_in, int c_in, int c_out, int xlt_l, int L, int total, quantum_reg *reg)
{
  if ( !a )
  {
    quantum_toffoli(b_in, c_in, c_out, reg);
    quantum_cnot(b_in, c_in, reg);
  }
  if ( a == 3 )
  {
    quantum_toffoli(L, c_in, c_out, reg);
    quantum_cnot(L, c_in, reg);
    quantum_toffoli(b_in, c_in, c_out, reg);
    quantum_cnot(b_in, c_in, reg);
  }
  if ( a == 1 )
  {
    quantum_toffoli(L, xlt_l, b_in, reg);
    quantum_toffoli(b_in, c_in, c_out, reg);
    quantum_toffoli(L, xlt_l, b_in, reg);
    quantum_toffoli(b_in, c_in, c_out, reg);
    quantum_toffoli(L, xlt_l, c_in, reg);
    quantum_toffoli(b_in, c_in, c_out, reg);
    quantum_cnot(b_in, c_in, reg);
  }
  if ( a == 2 )
  {
    quantum_sigma_x(xlt_l, reg);
    quantum_toffoli(L, xlt_l, b_in, reg);
    quantum_toffoli(b_in, c_in, c_out, reg);
    quantum_toffoli(L, xlt_l, b_in, reg);
    quantum_toffoli(b_in, c_in, c_out, reg);
    quantum_toffoli(L, xlt_l, c_in, reg);
    quantum_toffoli(b_in, c_in, c_out, reg);
    quantum_cnot(b_in, c_in, reg);
    quantum_sigma_x(xlt_l, reg);
  }
}

//----- (0804DBA7) --------------------------------------------------------
void __cdecl muxfa_inv(int a, int b_in, int c_in, int c_out, int xlt_l, int L, int total, quantum_reg *reg)
{
  if ( !a )
  {
    quantum_cnot(b_in, c_in, reg);
    quantum_toffoli(b_in, c_in, c_out, reg);
  }
  if ( a == 3 )
  {
    quantum_cnot(b_in, c_in, reg);
    quantum_toffoli(b_in, c_in, c_out, reg);
    quantum_cnot(L, c_in, reg);
    quantum_toffoli(L, c_in, c_out, reg);
  }
  if ( a == 1 )
  {
    quantum_cnot(b_in, c_in, reg);
    quantum_toffoli(b_in, c_in, c_out, reg);
    quantum_toffoli(L, xlt_l, c_in, reg);
    quantum_toffoli(b_in, c_in, c_out, reg);
    quantum_toffoli(L, xlt_l, b_in, reg);
    quantum_toffoli(b_in, c_in, c_out, reg);
    quantum_toffoli(L, xlt_l, b_in, reg);
  }
  if ( a == 2 )
  {
    quantum_sigma_x(xlt_l, reg);
    quantum_cnot(b_in, c_in, reg);
    quantum_toffoli(b_in, c_in, c_out, reg);
    quantum_toffoli(L, xlt_l, c_in, reg);
    quantum_toffoli(b_in, c_in, c_out, reg);
    quantum_toffoli(L, xlt_l, b_in, reg);
    quantum_toffoli(b_in, c_in, c_out, reg);
    quantum_toffoli(L, xlt_l, b_in, reg);
    quantum_sigma_x(xlt_l, reg);
  }
}

//----- (0804DE50) --------------------------------------------------------
void __cdecl muxha(int a, int b_in, int c_in, int xlt_l, int L, int total, quantum_reg *reg)
{
  if ( !a )
    quantum_cnot(b_in, c_in, reg);
  if ( a == 3 )
  {
    quantum_cnot(L, c_in, reg);
    quantum_cnot(b_in, c_in, reg);
  }
  if ( a == 1 )
  {
    quantum_toffoli(L, xlt_l, c_in, reg);
    quantum_cnot(b_in, c_in, reg);
  }
  if ( a == 2 )
  {
    quantum_sigma_x(xlt_l, reg);
    quantum_toffoli(L, xlt_l, c_in, reg);
    quantum_cnot(b_in, c_in, reg);
    quantum_sigma_x(xlt_l, reg);
  }
}

//----- (0804DF51) --------------------------------------------------------
void __cdecl muxha_inv(int a, int b_in, int c_in, int xlt_l, int L, int total, quantum_reg *reg)
{
  if ( !a )
    quantum_cnot(b_in, c_in, reg);
  if ( a == 3 )
  {
    quantum_cnot(b_in, c_in, reg);
    quantum_cnot(L, c_in, reg);
  }
  if ( a == 1 )
  {
    quantum_cnot(b_in, c_in, reg);
    quantum_toffoli(L, xlt_l, c_in, reg);
  }
  if ( a == 2 )
  {
    quantum_sigma_x(xlt_l, reg);
    quantum_cnot(b_in, c_in, reg);
    quantum_toffoli(L, xlt_l, c_in, reg);
    quantum_sigma_x(xlt_l, reg);
  }
}

//----- (0804E052) --------------------------------------------------------
void __cdecl madd(int a, int a_inv, int width, quantum_reg *reg)
{
  int total; // [esp+24h] [ebp-14h]
  int j; // [esp+28h] [ebp-10h]
  int ja; // [esp+28h] [ebp-10h]
  int i; // [esp+2Ch] [ebp-Ch]

  total = 2 * (2 * width + 1);
  for ( i = 0; width - 1 > i; ++i )
  {
    if ( ((a >> i) & 1) != 0 )
      j = 2;
    else
      j = 0;
    if ( ((a_inv >> i) & 1) != 0 )
      ++j;
    muxfa(j, width + i, i, i + 1, 2 * width, 2 * width + 1, total, reg);
  }
  ja = 0;
  if ( ((a >> (width - 1)) & 1) != 0 )
    ja = 2;
  if ( ((a_inv >> (width - 1)) & 1) != 0 )
    ++ja;
  muxha(ja, 2 * width - 1, width - 1, 2 * width, 2 * width + 1, total, reg);
}

//----- (0804E187) --------------------------------------------------------
void __cdecl madd_inv(int a, int a_inv, int width, quantum_reg *reg)
{
  int total; // [esp+24h] [ebp-14h]
  int j; // [esp+28h] [ebp-10h]
  int ja; // [esp+28h] [ebp-10h]
  int i; // [esp+2Ch] [ebp-Ch]

  total = 2 * (2 * width + 1);
  j = 0;
  if ( ((a >> (width - 1)) & 1) != 0 )
    j = 2;
  if ( ((a_inv >> (width - 1)) & 1) != 0 )
    ++j;
  muxha_inv(j, width - 1, 2 * width - 1, 2 * width, 2 * width + 1, total, reg);
  for ( i = width - 2; i >= 0; --i )
  {
    if ( ((a >> i) & 1) != 0 )
      ja = 2;
    else
      ja = 0;
    if ( ((a_inv >> i) & 1) != 0 )
      ++ja;
    muxfa_inv(ja, i, width + i, i + width + 1, 2 * width, 2 * width + 1, total, reg);
  }
}

//----- (0804E2BE) --------------------------------------------------------
void __cdecl addn(int N, int a, int width, quantum_reg *reg)
{
  test_sum(N - a, width, reg);
  madd(a + (1 << width) - N, a, width, reg);
}

//----- (0804E317) --------------------------------------------------------
void __cdecl addn_inv(int N, int a, int width, quantum_reg *reg)
{
  quantum_cnot(2 * width + 1, 2 * width, reg);
  madd_inv((1 << width) - a, N - a, width, reg);
  quantum_swaptheleads(width, reg);
  test_sum(a, width, reg);
}

//----- (0804E3A0) --------------------------------------------------------
void __cdecl add_mod_n(int N, int a, int width, quantum_reg *reg)
{
  addn(N, a, width, reg);
  addn_inv(N, a, width, reg);
}

//----- (0804E3E8) --------------------------------------------------------
void __cdecl quantum_mu2char(unsigned __int64 mu, unsigned __int8 *buf)
{
  char v2; // cl
  unsigned __int64 v3; // rax
  int i; // [esp+14h] [ebp-Ch]

  for ( i = 0; i < 8; ++i )
  {
    v2 = 8 * ~(i - 8);
    v3 = mu >> (v2 & 0x1F);
    if ( (v2 & 0x20) != 0 )
      LOBYTE(v3) = mu >> (v2 & 0x1F) >> 32;
    buf[i] = v3;
    mu &= (1LL << (8 * ~((unsigned __int8)i - 8))) - 1;
  }
}

//----- (0804E481) --------------------------------------------------------
void __cdecl quantum_int2char(int j, unsigned __int8 *buf)
{
  int i; // [esp+1Ch] [ebp-8h]

  for ( i = 0; i < 4; ++i )
  {
    buf[i] = j / (1 << (8 * ~(i - 4)));
    j %= 1 << (8 * ~(i - 4));
  }
}

//----- (0804E509) --------------------------------------------------------
void __cdecl quantum_double2char(double d, unsigned __int8 *buf)
{
  double da; // [esp+0h] [ebp-18h] BYREF
  unsigned __int8 *p; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  da = d;
  p = (unsigned __int8 *)&da;
  for ( i = 0; (unsigned int)i <= 7; ++i )
    buf[i] = p[i];
}

//----- (0804E54B) --------------------------------------------------------
unsigned __int64 __cdecl quantum_char2mu(unsigned __int8 *buf)
{
  unsigned __int64 mu; // [esp+0h] [ebp-18h]
  int i; // [esp+Ch] [ebp-Ch]

  mu = 0LL;
  for ( i = 7; i >= 0; --i )
    mu += (unsigned __int64)buf[i] << (8 * ~((unsigned __int8)i - 8));
  return mu;
}

//----- (0804E5C6) --------------------------------------------------------
int __cdecl quantum_char2int(unsigned __int8 *buf)
{
  int j; // [esp+4h] [ebp-10h]
  int i; // [esp+Ch] [ebp-8h]

  j = 0;
  for ( i = 3; i >= 0; --i )
    j += buf[i] << (8 * ~(i - 4));
  return j;
}

//----- (0804E61D) --------------------------------------------------------
double __cdecl quantum_char2double(unsigned __int8 *buf)
{
  return *(double *)buf;
}

//----- (0804E630) --------------------------------------------------------
void quantum_objcode_start()
{
  opstatus = 1;
  allocated = 1;
  objcode = (unsigned __int8 *)malloc(0x10000u);
  if ( !objcode )
    quantum_error(2);
  quantum_memman(0x10000);
}

//----- (0804E67E) --------------------------------------------------------
void quantum_objcode_stop()
{
  opstatus = 0;
  free(objcode);
  objcode = 0;
  quantum_memman(-65536 * allocated);
  allocated = 0;
}

//----- (0804E6C3) --------------------------------------------------------
int quantum_objcode_put(unsigned __int8 operation, ...)
{
  int size; // [esp+3Ch] [ebp-5Ch]
  int i; // [esp+40h] [ebp-58h]
  unsigned __int8 buf[80]; // [esp+44h] [ebp-54h] BYREF
  unsigned int v6; // [esp+94h] [ebp-4h]
  __int128 v7; // [esp+A4h] [ebp+Ch]
  va_list va; // [esp+B4h] [ebp+1Ch] BYREF

  va_start(va, operation);
  v7 = va_arg(va, _OWORD);
  v6 = __readgsdword(0x14u);
  size = 0;
  if ( !opstatus )
    return 0;
  buf[0] = operation;
  if ( operation > 0xBu )
  {
    if ( operation != 128 )
    {
      if ( operation <= 0x80u )
      {
        if ( operation == 13 )
        {
          quantum_int2char(v7, &buf[1]);
          quantum_int2char(SDWORD1(v7), &buf[5]);
          quantum_double2char(*((double *)&v7 + 1), &buf[9]);
          size = 17;
          goto LABEL_26;
        }
        if ( operation < 0xDu )
          goto LABEL_19;
        if ( operation == 14 )
        {
LABEL_21:
          quantum_int2char(v7, &buf[1]);
          size = 5;
          goto LABEL_26;
        }
LABEL_25:
        quantum_error(65537);
        goto LABEL_26;
      }
      if ( operation <= 0x82u )
        goto LABEL_21;
      if ( operation != 255 )
        goto LABEL_25;
    }
    size = 1;
    goto LABEL_26;
  }
  if ( operation >= 7u )
  {
    quantum_int2char(v7, &buf[1]);
    quantum_double2char(*(double *)((char *)&v7 + 4), &buf[5]);
    size = 13;
    goto LABEL_26;
  }
  if ( operation == 2 )
  {
    quantum_int2char(v7, &buf[1]);
    quantum_int2char(SDWORD1(v7), &buf[5]);
    quantum_int2char(SDWORD2(v7), &buf[9]);
    size = 13;
    goto LABEL_26;
  }
  if ( operation > 2u )
    goto LABEL_21;
  if ( operation )
  {
LABEL_19:
    quantum_int2char(v7, &buf[1]);
    quantum_int2char(SDWORD1(v7), &buf[5]);
    size = 9;
    goto LABEL_26;
  }
  quantum_mu2char(v7, &buf[1]);
  size = 9;
LABEL_26:
  if ( (position + size) >> 16 > HIWORD(position) )
  {
    objcode = (unsigned __int8 *)realloc(objcode, ++allocated << 16);
    if ( !objcode )
      quantum_error(2);
    quantum_memman(0x10000);
  }
  for ( i = 0; i < size; ++i )
    objcode[position++] = buf[i];
  return 1;
}
// 804E73B: conditional instruction was optimized away because of '%var_78.4==1'

//----- (0804EA7D) --------------------------------------------------------
int __cdecl quantum_objcode_write(char *file)
{
  int v2; // [esp+14h] [ebp-14h]
  FILE *fhd; // [esp+24h] [ebp-4h]

  if ( opstatus )
  {
    if ( !file )
      file = globalfile;
    fhd = fopen(file, "w");
    if ( fhd )
    {
      fwrite(objcode, position, 1u, fhd);
      fclose(fhd);
      v2 = 0;
    }
    else
    {
      v2 = -1;
    }
  }
  else
  {
    fwrite("Object code generation not active! Forgot to call quantum_objcode_start?\n", 1u, 0x49u, stderr);
    v2 = 1;
  }
  return v2;
}

//----- (0804EB2B) --------------------------------------------------------
void __cdecl quantum_objcode_file(char *file)
{
  globalfile = file;
}

//----- (0804EB38) --------------------------------------------------------
void __cdecl quantum_objcode_exit(char *file)
{
  quantum_objcode_write(0);
  quantum_objcode_stop();
}

//----- (0804EB51) --------------------------------------------------------
void __cdecl quantum_objcode_run(char *file, quantum_reg *reg)
{
  quantum_reg *v2; // ebx
  long double v3; // fst7
  float v4; // [esp+3Ch] [ebp-BCh]
  float v5; // [esp+3Ch] [ebp-BCh]
  float v6; // [esp+3Ch] [ebp-BCh]
  float v7; // [esp+3Ch] [ebp-BCh]
  float v8; // [esp+3Ch] [ebp-BCh]
  float v9; // [esp+3Ch] [ebp-BCh]
  quantum_reg v10; // [esp+40h] [ebp-B8h] BYREF
  quantum_reg *rega; // [esp+68h] [ebp-90h]
  char *filea; // [esp+6Ch] [ebp-8Ch]
  double d; // [esp+70h] [ebp-88h]
  unsigned __int64 mu; // [esp+78h] [ebp-80h]
  FILE *fhd; // [esp+84h] [ebp-74h]
  int l; // [esp+88h] [ebp-70h]
  int k; // [esp+8Ch] [ebp-6Ch]
  int j; // [esp+90h] [ebp-68h]
  int i; // [esp+94h] [ebp-64h]
  unsigned __int8 operation; // [esp+9Bh] [ebp-5Dh]
  unsigned __int8 buf[80]; // [esp+9Ch] [ebp-5Ch] BYREF
  unsigned int v22; // [esp+ECh] [ebp-Ch]

  filea = file;
  rega = reg;
  v22 = __readgsdword(0x14u);
  fhd = fopen(file, "r");
  if ( !fhd )
  {
    fprintf(stderr, "quantum_objcode_run: Could not open %s: ", filea);
    perror(0);
    return;
  }
  i = 0;
  while ( !feof(fhd) )
  {
    for ( j = 0; j <= 79; ++j )
      buf[j] = 0;
    operation = fgetc(fhd);
    if ( operation > 0xBu )
    {
      if ( operation == 128 )
      {
        quantum_measure(*rega);
        goto LABEL_55;
      }
      if ( operation <= 0x80u )
      {
        if ( operation == 13 )
        {
          fread(buf, 4u, 1u, fhd);
          j = quantum_char2int(buf);
          fread(buf, 4u, 1u, fhd);
          k = quantum_char2int(buf);
          fread(buf, 8u, 1u, fhd);
          v3 = quantum_char2double(buf);
          d = v3;
          v9 = v3;
          quantum_cond_phase_kick(j, k, v9, rega);
          goto LABEL_55;
        }
        if ( operation < 0xDu )
          goto LABEL_23;
        if ( operation != 14 )
          goto LABEL_54;
LABEL_29:
        fread(buf, 4u, 1u, fhd);
        j = quantum_char2int(buf);
        if ( operation == 6 )
        {
          quantum_hadamard(j, rega);
        }
        else if ( operation > 6u )
        {
          switch ( operation )
          {
            case 0x81u:
              quantum_bmeasure(j, rega);
              break;
            case 0x82u:
              quantum_bmeasure_bitpreserve(j, rega);
              break;
            case 0xEu:
              quantum_swaptheleads(j, rega);
              break;
          }
        }
        else if ( operation == 4 )
        {
          quantum_sigma_y(j, rega);
        }
        else if ( operation > 4u )
        {
          quantum_sigma_z(j, rega);
        }
        else if ( operation == 3 )
        {
          quantum_sigma_x(j, rega);
        }
        goto LABEL_55;
      }
      if ( operation <= 0x82u )
        goto LABEL_29;
      if ( operation != 255 )
      {
LABEL_54:
        fprintf(stderr, "%i: Unknown opcode 0x(%X)!\n", i, operation);
        return;
      }
    }
    else
    {
      if ( operation < 7u )
      {
        if ( operation == 2 )
        {
          fread(buf, 4u, 1u, fhd);
          j = quantum_char2int(buf);
          fread(buf, 4u, 1u, fhd);
          k = quantum_char2int(buf);
          fread(buf, 4u, 1u, fhd);
          l = quantum_char2int(buf);
          quantum_toffoli(j, k, l, rega);
          goto LABEL_55;
        }
        if ( operation <= 2u )
        {
          if ( !operation )
          {
            fread(buf, 8u, 1u, fhd);
            mu = quantum_char2mu(buf);
            v2 = rega;
            quantum_new_qureg(&v10, mu, 12);
            *v2 = v10;
            goto LABEL_55;
          }
LABEL_23:
          fread(buf, 4u, 1u, fhd);
          j = quantum_char2int(buf);
          fread(buf, 4u, 1u, fhd);
          k = quantum_char2int(buf);
          if ( operation == 1 )
          {
            quantum_cnot(j, k, rega);
          }
          else if ( operation == 12 )
          {
            quantum_cond_phase(j, k, rega);
          }
          goto LABEL_55;
        }
        goto LABEL_29;
      }
      fread(buf, 4u, 1u, fhd);
      j = quantum_char2int(buf);
      fread(buf, 8u, 1u, fhd);
      d = quantum_char2double(buf);
      switch ( operation )
      {
        case 7u:
          v4 = d;
          quantum_r_x(j, v4, rega);
          break;
        case 8u:
          v5 = d;
          quantum_r_y(j, v5, rega);
          break;
        case 9u:
          v6 = d;
          quantum_r_z(j, v6, rega);
          break;
        case 0xAu:
          v7 = d;
          quantum_phase_kick(j, v7, rega);
          break;
        case 0xBu:
          v8 = d;
          quantum_phase_scale(j, v8, rega);
          break;
        default:
          break;
      }
    }
LABEL_55:
    ++i;
  }
  fclose(fhd);
}
// 804EC47: conditional instruction was optimized away because of '%var_C8.4==1'

//----- (0804F2F4) --------------------------------------------------------
void __cdecl emul(int a, int L, int width, quantum_reg *reg)
{
  int i; // [esp+24h] [ebp-4h]

  for ( i = width - 1; i >= 0; --i )
  {
    if ( ((a >> i) & 1) != 0 )
      quantum_toffoli(2 * (width + 1), L, width + i, reg);
  }
}

//----- (0804F34C) --------------------------------------------------------
void __cdecl muln(int N, int a, int ctl, int width, quantum_reg *reg)
{
  int L; // [esp+20h] [ebp-8h]
  int i; // [esp+24h] [ebp-4h]

  L = 2 * width + 1;
  quantum_toffoli(ctl, 2 * (width + 1), L, reg);
  emul(a % N, L, width, reg);
  quantum_toffoli(ctl, 2 * (width + 1), L, reg);
  for ( i = 1; i < width; ++i )
  {
    quantum_toffoli(ctl, i + 2 * (width + 1), L, reg);
    add_mod_n(N, (a << i) % N, width, reg);
    quantum_toffoli(ctl, i + 2 * (width + 1), L, reg);
  }
}

//----- (0804F472) --------------------------------------------------------
void __cdecl muln_inv(int N, int a, int ctl, int width, quantum_reg *reg)
{
  int L; // [esp+20h] [ebp-8h]
  int i; // [esp+24h] [ebp-4h]
  int aa; // [esp+34h] [ebp+Ch]

  L = 2 * width + 1;
  aa = quantum_inverse_mod(N, a);
  for ( i = width - 1; i > 0; --i )
  {
    quantum_toffoli(ctl, i + 2 * (width + 1), L, reg);
    add_mod_n(N, N - (aa << i) % N, width, reg);
    quantum_toffoli(ctl, i + 2 * (width + 1), L, reg);
  }
  quantum_toffoli(ctl, 2 * (width + 1), L, reg);
  emul(aa % N, L, width, reg);
  quantum_toffoli(ctl, 2 * (width + 1), L, reg);
}

//----- (0804F5B6) --------------------------------------------------------
void __cdecl mul_mod_n(int N, int a, int ctl, int width, quantum_reg *reg)
{
  muln(N, a, ctl, width, reg);
  quantum_swaptheleads_omuln_controlled(ctl, width, reg);
  muln_inv(N, a, ctl, width, reg);
}

//----- (0804F628) --------------------------------------------------------
void __cdecl quantum_qec_set_status(int stype, int swidth)
{
  type = stype;
  width = swidth;
}

//----- (0804F63D) --------------------------------------------------------
void __cdecl quantum_qec_get_status(int *ptype, int *pwidth)
{
  if ( ptype )
    *ptype = type;
  if ( pwidth )
    *pwidth = width;
}

//----- (0804F664) --------------------------------------------------------
void __cdecl quantum_qec_encode(int type, int width, quantum_reg *reg)
{
  float lambda; // [esp+20h] [ebp-8h]
  int i; // [esp+24h] [ebp-4h]

  lambda = quantum_get_decoherence();
  quantum_set_decoherence(0.0);
  for ( i = 0; reg->width > i; ++i )
  {
    if ( reg->width - 1 == i )
      quantum_set_decoherence(lambda);
    if ( i >= width )
    {
      quantum_cnot(i, i + reg->width, reg);
      quantum_cnot(i, i + 2 * reg->width, reg);
    }
    else
    {
      quantum_hadamard(i + reg->width, reg);
      quantum_hadamard(i + 2 * reg->width, reg);
      quantum_cnot(i + reg->width, i, reg);
      quantum_cnot(i + 2 * reg->width, i, reg);
    }
  }
  quantum_qec_set_status(1, reg->width);
  reg->width *= 3;
}

//----- (0804F79F) --------------------------------------------------------
void __cdecl quantum_qec_decode(int type, int width, quantum_reg *reg)
{
  float lambda; // [esp+24h] [ebp-14h]
  int swidth; // [esp+28h] [ebp-10h]
  int b; // [esp+2Ch] [ebp-Ch]
  int a; // [esp+30h] [ebp-8h]
  int i; // [esp+34h] [ebp-4h]
  int ia; // [esp+34h] [ebp-4h]

  lambda = quantum_get_decoherence();
  quantum_set_decoherence(0.0);
  swidth = reg->width / 3;
  quantum_qec_set_status(0, 0);
  for ( i = reg->width / 3 - 1; i >= 0; --i )
  {
    if ( !i )
      quantum_set_decoherence(lambda);
    if ( i >= width )
    {
      quantum_cnot(i, i + 2 * swidth, reg);
      quantum_cnot(i, swidth + i, reg);
    }
    else
    {
      quantum_cnot(i + 2 * swidth, i, reg);
      quantum_cnot(swidth + i, i, reg);
      quantum_hadamard(i + 2 * swidth, reg);
      quantum_hadamard(swidth + i, reg);
    }
  }
  for ( ia = 1; ia <= swidth; ++ia )
  {
    a = quantum_bmeasure(swidth, reg);
    b = quantum_bmeasure(2 * swidth - ia, reg);
    if ( a == 1 && b == 1 && ia - 1 < width )
      quantum_sigma_z(ia - 1, reg);
  }
}

//----- (0804F96E) --------------------------------------------------------
int __cdecl quantum_qec_counter(int inc, int frequency, quantum_reg *reg)
{
  if ( inc <= 0 )
  {
    if ( inc < 0 )
      counter_2126 = 0;
  }
  else
  {
    counter_2126 += inc;
  }
  if ( frequency > 0 )
    freq_2127 = frequency;
  if ( counter_2126 >= freq_2127 )
  {
    counter_2126 = 0;
    quantum_qec_decode(type, width, reg);
    quantum_qec_encode(type, width, reg);
  }
  return counter_2126;
}

//----- (0804FA05) --------------------------------------------------------
void __cdecl quantum_sigma_x_ft(int target, quantum_reg *reg)
{
  float lambda; // [esp+20h] [ebp-8h]
  int tmp; // [esp+24h] [ebp-4h]

  tmp = type;
  type = 0;
  lambda = quantum_get_decoherence();
  quantum_set_decoherence(0.0);
  quantum_sigma_x(target, reg);
  quantum_sigma_x(target + width, reg);
  quantum_set_decoherence(lambda);
  quantum_sigma_x(target + 2 * width, reg);
  quantum_qec_counter(1, 0, reg);
  type = tmp;
}

//----- (0804FAA8) --------------------------------------------------------
void __cdecl quantum_cnot_ft(int control, int target, quantum_reg *reg)
{
  float lambda; // [esp+20h] [ebp-8h]
  int tmp; // [esp+24h] [ebp-4h]

  tmp = type;
  type = 0;
  lambda = quantum_get_decoherence();
  quantum_set_decoherence(0.0);
  quantum_cnot(control, target, reg);
  quantum_cnot(control + width, target + width, reg);
  quantum_set_decoherence(lambda);
  quantum_cnot(control + 2 * width, target + 2 * width, reg);
  quantum_qec_counter(1, 0, reg);
  type = tmp;
}

//----- (0804FB70) --------------------------------------------------------
void __cdecl quantum_toffoli_ft(int control1, int control2, int target, quantum_reg *reg)
{
  int v4; // esi
  int v5; // ebx
  quantum_reg_node *v6; // eax
  unsigned int v7; // edx
  int v8; // eax
  unsigned int v9; // edx
  unsigned __int64 v10; // rax
  char v11; // cl
  unsigned __int64 v12; // rax
  quantum_reg_node *v13; // eax
  unsigned int v14; // edx
  int v15; // eax
  unsigned int v16; // edx
  unsigned __int64 v17; // rax
  char v18; // cl
  unsigned __int64 v19; // rax
  unsigned __int64 mask; // [esp+18h] [ebp-20h]
  int c2; // [esp+24h] [ebp-14h]
  int c1; // [esp+28h] [ebp-10h]
  int i; // [esp+2Ch] [ebp-Ch]

  v4 = (unsigned __int64)(1LL << target) >> 32;
  v5 = 1 << target;
  if ( (target & 0x20) != 0 )
  {
    v4 = 1 << target;
    v5 = 0;
  }
  mask = (1LL << ((unsigned __int8)target + (unsigned __int8)width))
       + __PAIR64__(v4, v5)
       + (1LL << (target + 2 * (unsigned __int8)width));
  for ( i = 0; reg->size > i; ++i )
  {
    c1 = 0;
    c2 = 0;
    v6 = &reg->node[i];
    v7 = HIDWORD(v6->state);
    v8 = v6->state >> control1;
    v9 = v7 >> control1;
    if ( (control1 & 0x20) != 0 )
      LOBYTE(v8) = v9;
    if ( (v8 & 1) != 0 )
      c1 = 1;
    v10 = reg->node[i].state >> ((control1 + width) & 0x1F);
    if ( (((_BYTE)control1 + (_BYTE)width) & 0x20) != 0 )
      LOBYTE(v10) = reg->node[i].state >> ((control1 + width) & 0x1F) >> 32;
    if ( (v10 & 1) != 0 )
      c1 ^= 1u;
    v11 = control1 + 2 * width;
    v12 = reg->node[i].state >> (v11 & 0x1F);
    if ( (v11 & 0x20) != 0 )
      LOBYTE(v12) = reg->node[i].state >> (v11 & 0x1F) >> 32;
    if ( (v12 & 1) != 0 )
      c1 ^= 1u;
    v13 = &reg->node[i];
    v14 = HIDWORD(v13->state);
    v15 = v13->state >> control2;
    v16 = v14 >> control2;
    if ( (control2 & 0x20) != 0 )
      LOBYTE(v15) = v16;
    if ( (v15 & 1) != 0 )
      c2 = 1;
    v17 = reg->node[i].state >> ((control2 + width) & 0x1F);
    if ( (((_BYTE)control2 + (_BYTE)width) & 0x20) != 0 )
      LOBYTE(v17) = reg->node[i].state >> ((control2 + width) & 0x1F) >> 32;
    if ( (v17 & 1) != 0 )
      c2 ^= 1u;
    v18 = control2 + 2 * width;
    v19 = reg->node[i].state >> (v18 & 0x1F);
    if ( (v18 & 0x20) != 0 )
      LOBYTE(v19) = reg->node[i].state >> (v18 & 0x1F) >> 32;
    if ( (v19 & 1) != 0 )
      c2 ^= 1u;
    if ( c1 == 1 && c2 == 1 )
      reg->node[i].state ^= mask;
  }
  quantum_decohere(reg);
  quantum_qec_counter(1, 0, reg);
}

//----- (0804FDE4) --------------------------------------------------------
void __cdecl quantum_qft(int width, quantum_reg *reg)
{
  int j; // [esp+20h] [ebp-8h]
  int i; // [esp+24h] [ebp-4h]

  for ( i = width - 1; i >= 0; --i )
  {
    for ( j = width - 1; j > i; --j )
      quantum_cond_phase(j, i, reg);
    quantum_hadamard(i, reg);
  }
}

//----- (0804FE43) --------------------------------------------------------
void __cdecl quantum_qft_inv(int width, quantum_reg *reg)
{
  int j; // [esp+20h] [ebp-8h]
  int i; // [esp+24h] [ebp-4h]

  for ( i = 0; i < width; ++i )
  {
    quantum_hadamard(i, reg);
    for ( j = i + 1; j < width; ++j )
      quantum_cond_phase_inv(j, i, reg);
  }
}

//----- (0804FEA4) --------------------------------------------------------
void __cdecl quantum_rk4(quantum_reg *reg, double t, double dt, quantum_reg *(*H)(quantum_reg *__return_ptr __struct_ptr retstr, unsigned __int64, double))
{
  long double v4; // fst7
  long double v5; // fst7
  long double v6; // fst7
  long double v7; // fst7
  long double v8; // fst7
  unsigned int v9; // [esp+3Ch] [ebp-BCh]
  unsigned int v10; // [esp+3Ch] [ebp-BCh]
  unsigned int v11; // [esp+3Ch] [ebp-BCh]
  unsigned int v12; // [esp+3Ch] [ebp-BCh]
  float v13; // [esp+4Ch] [ebp-ACh]
  unsigned int v14; // [esp+4Ch] [ebp-ACh]
  float v15; // [esp+4Ch] [ebp-ACh]
  unsigned int v16; // [esp+4Ch] [ebp-ACh]
  float v17; // [esp+4Ch] [ebp-ACh]
  unsigned int v18; // [esp+4Ch] [ebp-ACh]
  float v19; // [esp+4Ch] [ebp-ACh]
  unsigned int v20; // [esp+4Ch] [ebp-ACh]
  double v21; // [esp+50h] [ebp-A8h] BYREF
  double v22; // [esp+58h] [ebp-A0h]
  quantum_reg v23; // [esp+60h] [ebp-98h] BYREF
  double dta; // [esp+80h] [ebp-78h]
  double ta; // [esp+88h] [ebp-70h]
  quantum_reg tmp; // [esp+9Ch] [ebp-5Ch] BYREF
  quantum_reg out; // [esp+B0h] [ebp-48h] BYREF
  quantum_reg k; // [esp+C4h] [ebp-34h] BYREF
  double r; // [esp+D8h] [ebp-20h]
  int hashw; // [esp+E4h] [ebp-14h]
  void *hash; // [esp+E8h] [ebp-10h]
  int i; // [esp+ECh] [ebp-Ch]

  ta = t;
  dta = dt;
  r = 0.0;
  hash = reg->hash;
  reg->hash = 0;
  hashw = reg->hashw;
  reg->hashw = 0;
  quantum_matrix_qureg(&v23, H, ta, reg);
  k = v23;
  _muldc3(&v21, dta, 0.0, 0.0, -1.0);
  _divdc3(&v21, v21, v22, 2.0, 0.0);
  v13 = v21;
  v4 = v13;
  *(float *)&v14 = v22;
  *(float *)&v9 = v4;
  quantum_scalar_qureg((complex_float)__PAIR64__(v14, v9), &k);
  quantum_vectoradd(&v23, reg, &k);
  tmp = v23;
  quantum_scalar_qureg((complex_float)1051372203LL, &k);
  quantum_vectoradd(&v23, reg, &k);
  out = v23;
  quantum_delete_qureg(&k);
  quantum_matrix_qureg(&v23, H, dta / 2.0 + ta, &tmp);
  k = v23;
  quantum_delete_qureg(&tmp);
  _muldc3(&v21, dta, 0.0, 0.0, -1.0);
  _divdc3(&v21, v21, v22, 2.0, 0.0);
  v15 = v21;
  v5 = v15;
  *(float *)&v16 = v22;
  *(float *)&v10 = v5;
  quantum_scalar_qureg((complex_float)__PAIR64__(v16, v10), &k);
  quantum_vectoradd(&v23, reg, &k);
  tmp = v23;
  quantum_scalar_qureg((complex_float)1059760811LL, &k);
  quantum_vectoradd_inplace(&out, &k);
  quantum_delete_qureg(&k);
  quantum_matrix_qureg(&v23, H, dta / 2.0 + ta, &tmp);
  k = v23;
  quantum_delete_qureg(&tmp);
  _muldc3(&v21, dta, 0.0, 0.0, -1.0);
  v17 = v21;
  v6 = v17;
  *(float *)&v18 = v22;
  *(float *)&v11 = v6;
  quantum_scalar_qureg((complex_float)__PAIR64__(v18, v11), &k);
  quantum_vectoradd(&v23, reg, &k);
  tmp = v23;
  quantum_scalar_qureg((complex_float)1051372203LL, &k);
  quantum_vectoradd_inplace(&out, &k);
  quantum_delete_qureg(&k);
  quantum_matrix_qureg(&v23, H, ta + dta, &tmp);
  k = v23;
  quantum_delete_qureg(&tmp);
  _muldc3(&v21, dta, 0.0, 0.0, -1.0);
  _divdc3(&v21, v21, v22, 6.0, 0.0);
  v19 = v21;
  v7 = v19;
  *(float *)&v20 = v22;
  *(float *)&v12 = v7;
  quantum_scalar_qureg((complex_float)__PAIR64__(v20, v12), &k);
  quantum_vectoradd_inplace(&out, &k);
  quantum_delete_qureg(&k);
  quantum_delete_qureg(reg);
  for ( i = 0; out.size > i; ++i )
  {
    v8 = quantum_prob(out.node[i].amplitude);
    r = v8 + r;
  }
  out.hash = (int *)hash;
  out.hashw = hashw;
  *reg = out;
}

//----- (0805057C) --------------------------------------------------------
double __cdecl quantum_rk4a(quantum_reg *reg, double t, double *dt, double epsilon, quantum_reg *(*H)(quantum_reg *__return_ptr __struct_ptr retstr, unsigned __int64, double))
{
  quantum_reg_node *v5; // eax
  float v6; // ecx
  float v7; // ebx
  quantum_reg_node *v8; // eax
  long double v9; // fst7
  float v10; // eax
  quantum_reg_node *v11; // eax
  float v12; // ecx
  float v13; // ebx
  quantum_reg_node *v14; // eax
  long double v15; // fst7
  float v16; // eax
  quantum_reg_node *v17; // eax
  float v18; // ecx
  float v19; // ebx
  quantum_reg_node *v20; // eax
  long double v21; // fst7
  float v22; // eax
  long double v23; // fst7
  quantum_reg_node *v24; // eax
  float v25; // ecx
  float v26; // ebx
  quantum_reg_node *v27; // eax
  long double v28; // fst7
  float v29; // eax
  quantum_reg_node *v30; // eax
  float v31; // ecx
  float v32; // ebx
  quantum_reg_node *v33; // eax
  long double v34; // fst7
  float v35; // eax
  long double v36; // fst7
  quantum_reg_node *v37; // eax
  float v38; // ecx
  float v39; // ebx
  quantum_reg_node *v40; // eax
  long double v41; // fst7
  float v42; // eax
  float a; // [esp+1Ch] [ebp-ACh]
  unsigned int aa; // [esp+1Ch] [ebp-ACh]
  float ab; // [esp+1Ch] [ebp-ACh]
  unsigned int ac; // [esp+1Ch] [ebp-ACh]
  float ad; // [esp+1Ch] [ebp-ACh]
  unsigned int ae; // [esp+1Ch] [ebp-ACh]
  float af; // [esp+1Ch] [ebp-ACh]
  unsigned int ag; // [esp+1Ch] [ebp-ACh]
  float ah; // [esp+1Ch] [ebp-ACh]
  unsigned int ai; // [esp+1Ch] [ebp-ACh]
  float aj; // [esp+1Ch] [ebp-ACh]
  unsigned int ak; // [esp+1Ch] [ebp-ACh]
  float v56; // [esp+2Ch] [ebp-9Ch]
  float v57; // [esp+30h] [ebp-98h]
  float v58; // [esp+34h] [ebp-94h]
  double v59; // [esp+38h] [ebp-90h]
  quantum_reg tmp; // [esp+5Ch] [ebp-6Ch]
  quantum_reg old; // [esp+70h] [ebp-58h] BYREF
  quantum_reg reg2; // [esp+84h] [ebp-44h] BYREF
  double dtused; // [esp+98h] [ebp-30h]
  double r; // [esp+A0h] [ebp-28h]
  double delta; // [esp+A8h] [ebp-20h]
  int hashw; // [esp+B4h] [ebp-14h]
  void *hash; // [esp+B8h] [ebp-10h]
  int i; // [esp+BCh] [ebp-Ch]

  hash = reg->hash;
  reg->hash = 0;
  hashw = reg->hashw;
  reg->hashw = 0;
  quantum_copy_qureg(reg, &old);
  quantum_copy_qureg(reg, &reg2);
  do
  {
    quantum_rk4(reg, t, *dt, H);
    quantum_rk4(&reg2, t, *dt / 2.0, H);
    quantum_rk4(&reg2, t, *dt / 2.0, H);
    delta = 0.0;
    for ( i = 0; reg->size > i; ++i )
    {
      v5 = &reg->node[i];
      v6 = v5->amplitude.real;
      v7 = v5->amplitude.imag;
      v8 = &reg2.node[i];
      v9 = v7 - v8->amplitude.imag;
      a = v6 - v8->amplitude.real;
      v10 = a;
      *(float *)&aa = v9;
      v56 = quantum_real_4((complex_float)__PAIR64__(aa, LODWORD(v10)));
      v11 = &reg->node[i];
      v12 = v11->amplitude.real;
      v13 = v11->amplitude.imag;
      v14 = &reg2.node[i];
      v15 = v13 - v14->amplitude.imag;
      ab = v12 - v14->amplitude.real;
      v16 = ab;
      *(float *)&ac = v15;
      if ( (long double)v56 <= quantum_imag_4((complex_float)__PAIR64__(ac, LODWORD(v16))) )
      {
        v30 = &reg->node[i];
        v31 = v30->amplitude.real;
        v32 = v30->amplitude.imag;
        v33 = &reg2.node[i];
        v34 = v32 - v33->amplitude.imag;
        ah = v31 - v33->amplitude.real;
        v35 = ah;
        *(float *)&ai = v34;
        v36 = quantum_imag_4((complex_float)__PAIR64__(ai, LODWORD(v35)));
        v58 = v36 + v36;
        v37 = &reg->node[i];
        v38 = v37->amplitude.real;
        v39 = v37->amplitude.imag;
        v40 = &reg2.node[i];
        v41 = v39 + v40->amplitude.imag;
        aj = v38 + v40->amplitude.real;
        v42 = aj;
        *(float *)&ak = v41;
        r = v58 / quantum_imag_4((complex_float)__PAIR64__(ak, LODWORD(v42)));
      }
      else
      {
        v17 = &reg->node[i];
        v18 = v17->amplitude.real;
        v19 = v17->amplitude.imag;
        v20 = &reg2.node[i];
        v21 = v19 - v20->amplitude.imag;
        ad = v18 - v20->amplitude.real;
        v22 = ad;
        *(float *)&ae = v21;
        v23 = quantum_real_4((complex_float)__PAIR64__(ae, LODWORD(v22)));
        v57 = v23 + v23;
        v24 = &reg->node[i];
        v25 = v24->amplitude.real;
        v26 = v24->amplitude.imag;
        v27 = &reg2.node[i];
        v28 = v26 + v27->amplitude.imag;
        af = v25 + v27->amplitude.real;
        v29 = af;
        *(float *)&ag = v28;
        r = v57 / quantum_real_4((complex_float)__PAIR64__(ag, LODWORD(v29)));
      }
      if ( r > (long double)delta )
        delta = r;
    }
    dtused = *dt;
    v59 = *dt;
    *dt = pow(epsilon / delta, 0.2) * v59;
    if ( delta > (long double)epsilon )
    {
      tmp = *reg;
      *reg = old;
      old = tmp;
      memcpy(reg2.node, reg->node, 16 * reg->size);
      memcpy(old.node, reg->node, 16 * reg->size);
    }
  }
  while ( delta > (long double)epsilon );
  reg->hash = (int *)hash;
  reg->hashw = hashw;
  return dtused;
}

//----- (08050B0E) --------------------------------------------------------
float __cdecl quantum_real_4(complex_float a)
{
  return a.real;
}

//----- (08050B27) --------------------------------------------------------
float __cdecl quantum_imag_4(complex_float a)
{
  return a.imag;
}

//----- (08050B44) --------------------------------------------------------
quantum_reg *__userpurge quantum_matrix2qureg@<eax>(quantum_reg *retstr, quantum_matrix *m, int width)
{
  complex_float *v3; // eax
  complex_float *v4; // eax
  float *v5; // ecx
  complex_float *v6; // eax
  float v7; // edx
  float v8; // eax
  int reg_8; // [esp+20h] [ebp-18h]
  quantum_reg_node *reg_12; // [esp+24h] [ebp-14h]
  int *reg_16; // [esp+28h] [ebp-10h]
  int size; // [esp+2Ch] [ebp-Ch]
  int j; // [esp+30h] [ebp-8h]
  int i; // [esp+34h] [ebp-4h]
  int ia; // [esp+34h] [ebp-4h]

  size = 0;
  if ( m->cols != 1 )
    quantum_error(0x10000);
  for ( i = 0; m->rows > i; ++i )
  {
    v3 = &m->t[i];
    if ( v3->real != 0.0 || v3->imag != 0.0 )
      ++size;
  }
  reg_8 = width + 2;
  reg_12 = (quantum_reg_node *)calloc(size, 0x10u);
  if ( !reg_12 )
    quantum_error(2);
  quantum_memman(16 * size);
  reg_16 = (int *)calloc(1 << reg_8, 4u);
  if ( !reg_16 )
    quantum_error(2);
  quantum_memman(4 << reg_8);
  ia = 0;
  j = 0;
  while ( m->rows > ia )
  {
    v4 = &m->t[ia];
    if ( v4->real != 0.0 || v4->imag != 0.0 )
    {
      reg_12[j].state = ia;
      v5 = &reg_12[j].amplitude.real;
      v6 = &m->t[ia];
      v7 = v6->real;
      v8 = v6->imag;
      *v5 = v7;
      v5[1] = v8;
      ++j;
    }
    ++ia;
  }
  retstr->width = width;
  retstr->size = size;
  retstr->hashw = reg_8;
  retstr->node = reg_12;
  retstr->hash = reg_16;
  return retstr;
}

//----- (08050D20) --------------------------------------------------------
quantum_reg *__userpurge quantum_new_qureg@<eax>(quantum_reg *retstr, unsigned __int64 initval, int width)
{
  int reg_8; // [esp+28h] [ebp-10h]
  _QWORD *reg_12; // [esp+2Ch] [ebp-Ch]
  int *reg_16; // [esp+30h] [ebp-8h]
  char *c; // [esp+34h] [ebp-4h]

  reg_8 = width + 2;
  reg_12 = calloc(1u, 0x10u);
  if ( !reg_12 )
    quantum_error(2);
  quantum_memman(16);
  reg_16 = (int *)calloc(1 << reg_8, 4u);
  if ( !reg_16 )
    quantum_error(2);
  quantum_memman(4 << reg_8);
  reg_12[1] = initval;
  *(_DWORD *)reg_12 = 1065353216;
  *((_DWORD *)reg_12 + 1) = 0;
  c = getenv("QUOBFILE");
  if ( c )
  {
    quantum_objcode_start();
    quantum_objcode_file(c);
    atexit((void (__cdecl *)(void *))quantum_objcode_exit);
  }
  quantum_objcode_put(0, initval);
  retstr->width = width;
  retstr->size = 1;
  retstr->hashw = reg_8;
  retstr->node = (quantum_reg_node *)reg_12;
  retstr->hash = reg_16;
  return retstr;
}

//----- (08050E60) --------------------------------------------------------
quantum_reg *__userpurge quantum_new_qureg_size@<eax>(quantum_reg *retstr, int n, int width)
{
  quantum_reg_node *reg_12; // [esp+20h] [ebp-8h]

  reg_12 = (quantum_reg_node *)calloc(n, 0x10u);
  if ( !reg_12 )
    quantum_error(2);
  quantum_memman(16 * n);
  retstr->width = width;
  retstr->size = n;
  retstr->hashw = 0;
  retstr->node = reg_12;
  retstr->hash = 0;
  return retstr;
}

//----- (08050EEA) --------------------------------------------------------
quantum_matrix *__userpurge quantum_qureg2matrix@<eax>(quantum_matrix *retstr, quantum_reg reg)
{
  complex_float *v2; // ecx
  quantum_reg_node *v3; // eax
  float v4; // edx
  float v5; // eax
  quantum_matrix m; // [esp+18h] [ebp-10h] BYREF
  int i; // [esp+24h] [ebp-4h]

  quantum_new_matrix(&m, 1, 1 << SLOBYTE(reg.width));
  for ( i = 0; reg.size > i; ++i )
  {
    v2 = &m.t[LODWORD(reg.node[i].state)];
    v3 = &reg.node[i];
    v4 = v3->amplitude.real;
    v5 = v3->amplitude.imag;
    v2->real = v4;
    v2->imag = v5;
  }
  *retstr = m;
  return retstr;
}

//----- (08050F7A) --------------------------------------------------------
void __cdecl quantum_destroy_hash(quantum_reg *reg)
{
  free(reg->hash);
  quantum_memman(-4 << reg->hashw);
  reg->hash = 0;
}

//----- (08050FAF) --------------------------------------------------------
void __cdecl quantum_delete_qureg(quantum_reg *reg)
{
  if ( reg->hashw && reg->hash )
    quantum_destroy_hash(reg);
  free(reg->node);
  quantum_memman(-16 * reg->size);
  reg->node = 0;
}

//----- (08051001) --------------------------------------------------------
void __cdecl quantum_delete_qureg_hashpreserve(quantum_reg *reg)
{
  free(reg->node);
  quantum_memman(-16 * reg->size);
  reg->node = 0;
}

//----- (08051034) --------------------------------------------------------
void __cdecl quantum_copy_qureg(quantum_reg *src, quantum_reg *dst)
{
  *dst = *src;
  dst->node = (quantum_reg_node *)calloc(dst->size, 0x10u);
  if ( !dst->node )
    quantum_error(2);
  quantum_memman(16 * dst->size);
  if ( dst->hashw )
  {
    dst->hash = (int *)calloc(1 << dst->hashw, 4u);
    if ( !dst->hash )
      quantum_error(2);
    quantum_memman(4 << dst->hashw);
  }
  memcpy(dst->node, src->node, 16 * src->size);
}

//----- (08051124) --------------------------------------------------------
void __cdecl quantum_print_qureg(quantum_reg reg)
{
  quantum_reg_node *v1; // eax
  unsigned int v2; // ebx
  unsigned int v3; // esi
  long double v4; // fst7
  quantum_reg_node *v5; // eax
  unsigned int v6; // edx
  int v7; // eax
  unsigned int v8; // edx
  double v9; // [esp+30h] [ebp-28h]
  double v10; // [esp+38h] [ebp-20h]
  int j; // [esp+48h] [ebp-10h]
  int i; // [esp+4Ch] [ebp-Ch]

  for ( i = 0; reg.size > i; ++i )
  {
    v9 = quantum_prob_inline_3(reg.node[i].amplitude);
    v1 = &reg.node[i];
    v2 = v1->state;
    v3 = HIDWORD(v1->state);
    v10 = quantum_imag_5(v1->amplitude);
    v4 = quantum_real_5(reg.node[i].amplitude);
    printf("% f %+fi|%lli> (%e) (|", (double)v4, v10, __PAIR64__(v3, v2), v9);
    for ( j = reg.width - 1; j >= 0; --j )
    {
      if ( j % 4 == 3 )
        putchar(32);
      v5 = &reg.node[i];
      v6 = HIDWORD(v5->state);
      v7 = v5->state >> j;
      v8 = v6 >> j;
      if ( (j & 0x20) != 0 )
        LOBYTE(v7) = v8;
      printf("%i", v7 & 1);
    }
    puts(">)");
  }
  putchar(10);
}

//----- (0805126A) --------------------------------------------------------
float __cdecl quantum_prob_inline_3(complex_float a)
{
  float i; // [esp+10h] [ebp-8h]
  float r; // [esp+14h] [ebp-4h]

  r = quantum_real_5(a);
  i = quantum_imag_5(a);
  return r * r + i * i;
}

//----- (080512AA) --------------------------------------------------------
float __cdecl quantum_imag_5(complex_float a)
{
  return a.imag;
}

//----- (080512C6) --------------------------------------------------------
float __cdecl quantum_real_5(complex_float a)
{
  return a.real;
}

//----- (080512DF) --------------------------------------------------------
void __cdecl quantum_print_expn(quantum_reg reg)
{
  int i; // [esp+2Ch] [ebp-Ch]

  for ( i = 0; reg.size > i; ++i )
    printf("%i: %lli\n", i, reg.node[i].state - (i << (reg.width / 2)));
}

//----- (0805135C) --------------------------------------------------------
void __cdecl quantum_addscratch(int bits, quantum_reg *reg)
{
  int i; // [esp+Ch] [ebp-4h]

  reg->width += bits;
  for ( i = 0; reg->size > i; ++i )
    reg->node[i].state <<= bits;
}

//----- (080513DA) --------------------------------------------------------
void __cdecl quantum_print_hash(quantum_reg reg)
{
  int i; // [esp+20h] [ebp-8h]

  for ( i = 0; 1 << SLOBYTE(reg.hashw) > i; ++i )
  {
    if ( i )
      printf("%i: %i %llu\n", i, reg.hash[i] - 1, reg.node[-(1 - reg.hash[i])].state);
  }
}

//----- (08051461) --------------------------------------------------------
quantum_reg *__userpurge quantum_kronecker@<eax>(quantum_reg *retstr, quantum_reg *reg1, quantum_reg *reg2)
{
  quantum_reg_node *v3; // eax
  int v4; // ebx
  int v5; // edi
  int v6; // esi
  quantum_reg_node *v7; // eax
  int v8; // ebx
  _DWORD *v9; // edi
  int v10; // edx
  int v12; // [esp+18h] [ebp-30h]
  quantum_reg reg; // [esp+20h] [ebp-28h]
  int j; // [esp+34h] [ebp-14h]
  int i; // [esp+38h] [ebp-10h]

  reg.width = reg1->width + reg2->width;
  reg.size = reg1->size * reg2->size;
  reg.hashw = reg.size + 2;
  reg.node = (quantum_reg_node *)calloc(reg.size, 0x10u);
  if ( !reg.node )
    quantum_error(2);
  quantum_memman(16 * reg.size);
  reg.hash = (int *)calloc(1 << SLOBYTE(reg.hashw), 4u);
  if ( !reg.hash )
    quantum_error(2);
  quantum_memman(4 << SLOBYTE(reg.hashw));
  for ( i = 0; reg1->size > i; ++i )
  {
    for ( j = 0; reg2->size > j; ++j )
    {
      v12 = (int)&reg.node[j + i * reg2->size];
      v3 = &reg1->node[i];
      v4 = v3->state;
      v5 = v3->state << reg2->width >> 32;
      v6 = v4 << reg2->width;
      if ( (reg2->width & 0x20) != 0 )
      {
        v5 = v4 << reg2->width;
        v6 = 0;
      }
      v7 = &reg2->node[j];
      v8 = HIDWORD(v7->state);
      *(_DWORD *)(v12 + 8) = LODWORD(v7->state) | v6;
      *(_DWORD *)(v12 + 12) = v8 | v5;
      v9 = (_DWORD *)&reg.node[j + i * reg2->size].amplitude.real;
      *v9 = _mulsc3(
              reg1->node[i].amplitude.real,
              reg1->node[i].amplitude.imag,
              reg2->node[j].amplitude.real,
              reg2->node[j].amplitude.imag);
      v9[1] = v10;
    }
  }
  *retstr = reg;
  return retstr;
}
// 80515FC: variable 'v10' is possibly undefined

//----- (0805165E) --------------------------------------------------------
quantum_reg *__userpurge quantum_state_collapse@<eax>(quantum_reg *retstr, int pos, int value, quantum_reg reg)
{
  _DWORD *v4; // esi
  int v5; // edx
  float v7; // [esp+2Ch] [ebp-5Ch]
  quantum_reg_node *out_12; // [esp+48h] [ebp-40h]
  unsigned __int64 pos2; // [esp+50h] [ebp-38h]
  unsigned __int64 rpat; // [esp+58h] [ebp-30h]
  unsigned __int64 rpata; // [esp+58h] [ebp-30h]
  unsigned __int64 lpat; // [esp+60h] [ebp-28h]
  unsigned __int64 lpata; // [esp+60h] [ebp-28h]
  double d; // [esp+68h] [ebp-20h]
  int size; // [esp+70h] [ebp-18h]
  int k; // [esp+74h] [ebp-14h]
  int ka; // [esp+74h] [ebp-14h]
  int j; // [esp+78h] [ebp-10h]
  int i; // [esp+7Ch] [ebp-Ch]
  int ia; // [esp+7Ch] [ebp-Ch]

  size = 0;
  d = 0.0;
  pos2 = 1LL << pos;
  for ( i = 0; reg.size > i; ++i )
  {
    if ( (pos2 & reg.node[i].state) != 0 && value || (pos2 & reg.node[i].state) == 0 && !value )
    {
      d = quantum_prob_inline_3(reg.node[i].amplitude) + d;
      ++size;
    }
  }
  out_12 = (quantum_reg_node *)calloc(size, 0x10u);
  if ( !out_12 )
    quantum_error(2);
  quantum_memman(16 * size);
  ia = 0;
  j = 0;
  while ( reg.size > ia )
  {
    if ( (pos2 & reg.node[ia].state) != 0 && value || (pos2 & reg.node[ia].state) == 0 && !value )
    {
      k = 0;
      rpat = 0LL;
      while ( k < pos )
        rpat += 1LL << k++;
      rpata = reg.node[ia].state & rpat;
      ka = 63;
      lpat = 0LL;
      while ( ka > pos )
        lpat += 1LL << ka--;
      lpata = reg.node[ia].state & lpat;
      v4 = (_DWORD *)&out_12[j].amplitude.real;
      v4[2] = rpata | (lpata >> 1);
      v4[3] = HIDWORD(rpata) | (HIDWORD(lpata) >> 1);
      v7 = sqrt(d);
      *v4 = _divsc3(reg.node[ia].amplitude.real, reg.node[ia].amplitude.imag, v7, 0.0);
      v4[1] = v5;
      ++j;
    }
    ++ia;
  }
  retstr->width = reg.width - 1;
  retstr->size = size;
  retstr->hashw = reg.hashw;
  retstr->node = out_12;
  retstr->hash = reg.hash;
  return retstr;
}
// 805196A: variable 'v5' is possibly undefined

//----- (080519B9) --------------------------------------------------------
complex_float __cdecl quantum_dot_product(quantum_reg *reg1, quantum_reg *reg2)
{
  complex_float v2; // rax
  float v3; // edx
  float v4; // eax
  float v6; // [esp+1Ch] [ebp-1Ch]
  unsigned int v7; // [esp+1Ch] [ebp-1Ch]
  unsigned __int64 f; // [esp+20h] [ebp-18h]
  int j; // [esp+28h] [ebp-10h]
  int i; // [esp+2Ch] [ebp-Ch]

  f = 0LL;
  if ( reg2->hashw )
    quantum_reconstruct_hash_1(reg2);
  for ( i = 0; reg1->size > i; ++i )
  {
    j = quantum_get_state_1(reg1->node[i].state, *reg2);
    if ( j >= 0 )
    {
      v2 = quantum_conj(reg1->node[i].amplitude);
      v6 = COERCE_FLOAT(_mulsc3(v2.real, v2.imag, reg2->node[j].amplitude.real, reg2->node[j].amplitude.imag))
         + *(float *)&f;
      v4 = v6;
      *(float *)&v7 = v3 + *((float *)&f + 1);
      f = __PAIR64__(v7, LODWORD(v4));
    }
  }
  return (complex_float)f;
}
// 8051AAD: variable 'v3' is possibly undefined

//----- (08051AF8) --------------------------------------------------------
void __cdecl quantum_reconstruct_hash_1(quantum_reg *reg)
{
  int i; // [esp+24h] [ebp-4h]
  int ia; // [esp+24h] [ebp-4h]

  for ( i = 0; 1 << reg->hashw > i; ++i )
    reg->hash[i] = 0;
  for ( ia = 0; reg->size > ia; ++ia )
    quantum_add_hash_1(reg->node[ia].state, ia, reg);
}

//----- (08051B7B) --------------------------------------------------------
void __cdecl quantum_add_hash_1(unsigned __int64 a, int pos, quantum_reg *reg)
{
  int mark; // [esp+20h] [ebp-8h]
  int i; // [esp+24h] [ebp-4h]

  mark = 0;
  i = quantum_hash64_1(a, reg->hashw);
  while ( reg->hash[i] )
  {
    if ( 1 << reg->hashw == ++i )
    {
      if ( mark )
      {
        quantum_error(5);
      }
      else
      {
        i = 0;
        mark = 1;
      }
    }
  }
  reg->hash[i] = pos + 1;
}

//----- (08051C1A) --------------------------------------------------------
unsigned int __cdecl quantum_hash64_1(unsigned __int64 key, int width)
{
  return (-1640562687 * ((unsigned int)key ^ HIDWORD(key))) >> (32 - width);
}

//----- (08051C5C) --------------------------------------------------------
int __cdecl quantum_get_state_1(unsigned __int64 a, quantum_reg reg)
{
  int i; // [esp+2Ch] [ebp-4h]

  if ( !reg.hashw )
    return a;
  i = quantum_hash64_1(a, reg.hashw);
  while ( reg.hash[i] )
  {
    if ( a == reg.node[-(1 - reg.hash[i])].state )
      return reg.hash[i] - 1;
    if ( 1 << SLOBYTE(reg.hashw) == ++i )
      i = 0;
  }
  return -1;
}

//----- (08051D22) --------------------------------------------------------
complex_float __cdecl quantum_dot_product_noconj(quantum_reg *reg1, quantum_reg *reg2)
{
  float v2; // edx
  float v3; // eax
  float v5; // [esp+1Ch] [ebp-1Ch]
  unsigned int v6; // [esp+1Ch] [ebp-1Ch]
  unsigned __int64 f; // [esp+20h] [ebp-18h]
  int j; // [esp+28h] [ebp-10h]
  int i; // [esp+2Ch] [ebp-Ch]

  f = 0LL;
  if ( reg2->hashw )
    quantum_reconstruct_hash_1(reg2);
  for ( i = 0; reg1->size > i; ++i )
  {
    j = quantum_get_state_1(reg1->node[i].state, *reg2);
    if ( j >= 0 )
    {
      v5 = COERCE_FLOAT(
             _mulsc3(
               reg1->node[i].amplitude.real,
               reg1->node[i].amplitude.imag,
               reg2->node[j].amplitude.real,
               reg2->node[j].amplitude.imag))
         + *(float *)&f;
      v3 = v5;
      *(float *)&v6 = v2 + *((float *)&f + 1);
      f = __PAIR64__(v6, LODWORD(v3));
    }
  }
  return (complex_float)f;
}
// 8051DFB: variable 'v2' is possibly undefined

//----- (08051E46) --------------------------------------------------------
quantum_reg *__userpurge quantum_vectoradd@<eax>(quantum_reg *retstr, quantum_reg *reg1, quantum_reg *reg2)
{
  quantum_reg_node *v3; // esi
  quantum_reg_node *v4; // eax
  long double v5; // fst7
  float v6; // eax
  quantum_reg_node *v7; // ecx
  quantum_reg_node *v8; // eax
  int v9; // edx
  quantum_reg_node *v10; // ecx
  quantum_reg_node *v11; // eax
  float v12; // edx
  float v13; // eax
  float v15; // [esp+1Ch] [ebp-3Ch]
  float v16; // [esp+1Ch] [ebp-3Ch]
  quantum_reg reg; // [esp+2Ch] [ebp-2Ch] BYREF
  int addsize; // [esp+40h] [ebp-18h]
  int k; // [esp+44h] [ebp-14h]
  int j; // [esp+48h] [ebp-10h]
  int i; // [esp+4Ch] [ebp-Ch]

  addsize = 0;
  quantum_copy_qureg(reg1, &reg);
  if ( reg1->hashw || reg2->hashw )
  {
    quantum_reconstruct_hash_1(reg1);
    quantum_copy_qureg(reg1, &reg);
    for ( i = 0; reg2->size > i; ++i )
    {
      if ( quantum_get_state_1(reg2->node[i].state, *reg1) == -1 )
        ++addsize;
    }
  }
  reg.size += addsize;
  reg.node = (quantum_reg_node *)realloc(reg.node, 16 * reg.size);
  if ( !reg.node )
    quantum_error(2);
  quantum_memman(16 * addsize);
  k = reg1->size;
  for ( i = 0; reg2->size > i; ++i )
  {
    j = quantum_get_state_1(reg2->node[i].state, *reg1);
    if ( j < 0 )
    {
      v7 = &reg.node[k];
      v8 = &reg2->node[i];
      v9 = HIDWORD(v8->state);
      LODWORD(v7->state) = v8->state;
      HIDWORD(v7->state) = v9;
      v10 = &reg.node[k];
      v11 = &reg2->node[i];
      v12 = v11->amplitude.real;
      v13 = v11->amplitude.imag;
      v10->amplitude.real = v12;
      v10->amplitude.imag = v13;
      ++k;
    }
    else
    {
      v3 = &reg.node[j];
      v4 = &reg2->node[i];
      v5 = v3->amplitude.imag + v4->amplitude.imag;
      v15 = v3->amplitude.real + v4->amplitude.real;
      v6 = v15;
      v16 = v5;
      v3->amplitude.real = v6;
      v3->amplitude.imag = v16;
    }
  }
  *retstr = reg;
  return retstr;
}

//----- (080520A8) --------------------------------------------------------
void __cdecl quantum_vectoradd_inplace(quantum_reg *reg1, quantum_reg *reg2)
{
  quantum_reg_node *v2; // esi
  quantum_reg_node *v3; // eax
  long double v4; // fst7
  float v5; // eax
  quantum_reg_node *v6; // ecx
  quantum_reg_node *v7; // eax
  int v8; // edx
  quantum_reg_node *v9; // ecx
  quantum_reg_node *v10; // eax
  float v11; // edx
  float v12; // eax
  float v13; // [esp+1Ch] [ebp-1Ch]
  float v14; // [esp+1Ch] [ebp-1Ch]
  int addsize; // [esp+20h] [ebp-18h]
  int k; // [esp+24h] [ebp-14h]
  int j; // [esp+28h] [ebp-10h]
  int i; // [esp+2Ch] [ebp-Ch]
  int ia; // [esp+2Ch] [ebp-Ch]

  addsize = 0;
  if ( reg1->hashw || reg2->hashw )
  {
    quantum_reconstruct_hash_1(reg1);
    for ( i = 0; reg2->size > i; ++i )
    {
      if ( quantum_get_state_1(reg2->node[i].state, *reg1) == -1 )
        ++addsize;
    }
  }
  reg1->node = (quantum_reg_node *)realloc(reg1->node, 16 * (addsize + reg1->size));
  if ( !reg1->node )
    quantum_error(2);
  quantum_memman(16 * addsize);
  k = reg1->size;
  for ( ia = 0; reg2->size > ia; ++ia )
  {
    j = quantum_get_state_1(reg2->node[ia].state, *reg1);
    if ( j < 0 )
    {
      v6 = &reg1->node[k];
      v7 = &reg2->node[ia];
      v8 = HIDWORD(v7->state);
      LODWORD(v6->state) = v7->state;
      HIDWORD(v6->state) = v8;
      v9 = &reg1->node[k];
      v10 = &reg2->node[ia];
      v11 = v10->amplitude.real;
      v12 = v10->amplitude.imag;
      v9->amplitude.real = v11;
      v9->amplitude.imag = v12;
      ++k;
    }
    else
    {
      v2 = &reg1->node[j];
      v3 = &reg2->node[ia];
      v4 = v2->amplitude.imag + v3->amplitude.imag;
      v13 = v2->amplitude.real + v3->amplitude.real;
      v5 = v13;
      v14 = v4;
      v2->amplitude.real = v5;
      v2->amplitude.imag = v14;
    }
  }
  reg1->size += addsize;
}

//----- (080522D8) --------------------------------------------------------
quantum_reg *__userpurge quantum_matrix_qureg@<eax>(quantum_reg *retstr, quantum_reg *(*A)(quantum_reg *__return_ptr __struct_ptr retstr, unsigned __int64, double), double t, quantum_reg *reg)
{
  quantum_reg_node *v4; // ecx
  int v5; // edx
  quantum_reg_node *v6; // esi
  quantum_reg v8; // [esp+30h] [ebp-68h] BYREF
  double ta; // [esp+58h] [ebp-40h]
  quantum_reg tmp; // [esp+60h] [ebp-38h] BYREF
  quantum_reg reg2; // [esp+74h] [ebp-24h]
  unsigned __int64 i; // [esp+88h] [ebp-10h]

  ta = t;
  reg2.width = reg->width;
  reg2.size = 1 << SLOBYTE(reg2.width);
  reg2.hashw = 0;
  reg2.hash = 0;
  reg2.node = (quantum_reg_node *)calloc(1 << SLOBYTE(reg2.width), 0x10u);
  if ( !reg2.node )
    quantum_error(2);
  quantum_memman(16 * reg2.size);
  for ( i = 0LL; 1 << reg->width > i; ++i )
  {
    v4 = &reg2.node[i];
    v5 = HIDWORD(i);
    LODWORD(v4->state) = i;
    HIDWORD(v4->state) = v5;
    ((void (__stdcall *)(quantum_reg *))A)(&v8);
    tmp = v8;
    v6 = &reg2.node[i];
    v6->amplitude = quantum_dot_product_noconj(&tmp, reg);
    quantum_delete_qureg(&tmp);
  }
  *retstr = reg2;
  return retstr;
}

//----- (08052462) --------------------------------------------------------
void __cdecl quantum_scalar_qureg(complex_float r, quantum_reg *reg)
{
  quantum_reg_node *v2; // esi
  float v3; // edx
  int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; reg->size > i; ++i )
  {
    v2 = &reg->node[i];
    LODWORD(v2->amplitude.real) = _mulsc3(v2->amplitude.real, v2->amplitude.imag, r.real, r.imag);
    v2->amplitude.imag = v3;
  }
}
// 80524BE: variable 'v3' is possibly undefined

//----- (080524D7) --------------------------------------------------------
void __cdecl quantum_print_timeop(int width, void (*f)(quantum_reg *))
{
  complex_float *v2; // ecx
  quantum_reg_node *v3; // eax
  float v4; // edx
  float v5; // eax
  quantum_reg v6; // [esp+10h] [ebp-68h] BYREF
  quantum_matrix v7; // [esp+30h] [ebp-48h] BYREF
  quantum_reg tmp; // [esp+48h] [ebp-30h] BYREF
  quantum_matrix m; // [esp+5Ch] [ebp-1Ch] BYREF
  int j; // [esp+68h] [ebp-10h]
  int i; // [esp+6Ch] [ebp-Ch]

  quantum_new_matrix(&v7, 1 << width, 1 << width);
  m = v7;
  for ( i = 0; 1 << width > i; ++i )
  {
    quantum_new_qureg(&v6, i, width);
    tmp = v6;
    f(&tmp);
    for ( j = 0; tmp.size > j; ++j )
    {
      v2 = &m.t[LODWORD(tmp.node[j].state) + i * m.cols];
      v3 = &tmp.node[j];
      v4 = v3->amplitude.real;
      v5 = v3->amplitude.imag;
      v2->real = v4;
      v2->imag = v5;
    }
    quantum_delete_qureg(&tmp);
  }
  quantum_print_matrix(m);
  quantum_delete_matrix(&m);
}

//----- (08052614) --------------------------------------------------------
int __cdecl main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v4; // eax
  int v5; // eax
  int v7; // [esp+4Ch] [ebp-6Ch]
  quantum_reg v8; // [esp+50h] [ebp-68h] BYREF
  quantum_reg qr; // [esp+74h] [ebp-44h] BYREF
  int factor; // [esp+88h] [ebp-30h]
  int b; // [esp+8Ch] [ebp-2Ch]
  int a; // [esp+90h] [ebp-28h]
  int q; // [esp+94h] [ebp-24h] BYREF
  int c; // [esp+98h] [ebp-20h] BYREF
  int N; // [esp+9Ch] [ebp-1Ch]
  int x; // [esp+A0h] [ebp-18h]
  int swidth; // [esp+A4h] [ebp-14h]
  int width; // [esp+A8h] [ebp-10h]
  int i; // [esp+ACh] [ebp-Ch]

  x = 0;
  v3 = time(0);
  srand(v3);
  if ( argc == 1 )
  {
    puts("Usage: shor [number]\n");
    v7 = 3;
  }
  else
  {
    N = atoi(argv[1]);
    if ( N > 14 )
    {
      width = quantum_getwidth(N * N);
      swidth = quantum_getwidth(N);
      printf("N = %i, %i qubits required\n", N, width + 3 * swidth + 2);
      if ( argc > 2 )
        x = atoi(argv[2]);
      while ( quantum_gcd(N, x) > 1 || x <= 1 )
        x = rand() % N;
      printf("Random seed: %i\n", x);
      quantum_new_qureg(&v8, 0LL, width);
      qr = v8;
      for ( i = 0; i < width; ++i )
        quantum_hadamard(i, &qr);
      quantum_addscratch(3 * swidth + 2, &qr);
      quantum_exp_mod_n(N, x, width, swidth, &qr);
      for ( i = 0; 3 * swidth + 2 > i; ++i )
        quantum_bmeasure(0, &qr);
      quantum_qft(width, &qr);
      for ( i = 0; width / 2 > i; ++i )
      {
        quantum_cnot(i, width - i - 1, &qr);
        quantum_cnot(width - i - 1, i, &qr);
        quantum_cnot(i, width - i - 1, &qr);
      }
      c = quantum_measure(qr);
      if ( c == -1 )
      {
        puts("Impossible Measurement!");
        v7 = 1;
      }
      else if ( c )
      {
        q = 1 << width;
        printf("Measured %i (%f), ", c, (double)((long double)c / (long double)(1 << width)));
        quantum_frac_approx(&c, &q, width);
        printf("fractional approximation is %i/%i.\n", c, q);
        if ( q % 2 == 1 && 2 * q < 1 << width )
        {
          puts("Odd denominator, trying to expand by 2.");
          q *= 2;
        }
        if ( q % 2 == 1 )
        {
          puts("Odd period, try again.");
          v7 = 2;
        }
        else
        {
          printf("Possible period is %i.\n", q);
          v4 = quantum_ipow(x, q / 2);
          a = v4 + 1 % N;
          v5 = quantum_ipow(x, q / 2);
          b = v5 - 1 % N;
          a = quantum_gcd(N, a);
          b = quantum_gcd(N, b);
          if ( a <= b )
            factor = b;
          else
            factor = a;
          if ( factor >= N || factor <= 1 )
          {
            puts("Unable to determine factors, try again.");
            v7 = 2;
          }
          else
          {
            printf("%i = %i * %i\n", N, factor, N / factor);
            quantum_delete_qureg(&qr);
            v7 = 0;
          }
        }
      }
      else
      {
        puts("Measured zero, try again.");
        v7 = 2;
      }
    }
    else
    {
      puts("Invalid number\n");
      v7 = 3;
    }
  }
  return v7;
}

//----- (08052B30) --------------------------------------------------------
const char *quantum_get_version()
{
  return "0.9.1";
}

//----- (08052B40) --------------------------------------------------------
int __cdecl _mulsc3(float a1, float a2, float a3, float a4)
{
  float v5; // [esp+4h] [ebp-38h]
  float v6; // [esp+34h] [ebp-8h]
  float v7; // [esp+38h] [ebp-4h]

  v7 = a1 * a3;
  v6 = a2 * a4;
  v5 = v7 - v6;
  return LODWORD(v5);
}

//----- (080531E0) --------------------------------------------------------
double *__userpurge _muldc3@<eax>(double *a1, double a2, double a3, double a4, double a5)
{
  double *result; // eax

  *a1 = a2 * a4 - a3 * a5;
  result = a1;
  a1[1] = a2 * a5 + a3 * a4;
  return result;
}

//----- (08053890) --------------------------------------------------------
int __cdecl _divsc3(float a1, float a2, float a3, float a4)
{
  long double v4; // fst7
  long double v5; // fst6
  long double v6; // fst5
  long double v7; // fst4
  long double v8; // fst2
  float v10; // [esp+0h] [ebp-8h]

  v4 = a1;
  v5 = a2;
  v6 = a3;
  v7 = a4;
  if ( fabs(a4) <= fabs(a3) )
    v8 = (v5 * (v7 / v6) + v4) / (v7 * (v7 / v6) + v6);
  else
    v8 = (v4 * (v6 / v7) + v5) / (v6 * (v6 / v7) + v7);
  v10 = v8;
  return LODWORD(v10);
}

//----- (08053D00) --------------------------------------------------------
double *__userpurge _divdc3@<eax>(double *a1, double a2, double a3, double a4, double a5)
{
  long double v5; // fst7
  long double v6; // fst6
  long double v7; // fst5
  long double v8; // fst4
  long double v9; // fst2
  long double v10; // rt1
  long double v11; // fst2
  long double v12; // fst3
  double *result; // eax
  long double v14; // fst2
  long double v15; // rtt

  v5 = a2;
  v6 = a3;
  v7 = a4;
  v8 = a5;
  if ( fabs(a5) <= fabs(a4) )
  {
    v14 = v8 * (v8 / v7) + v7;
    v15 = (v6 - v8 / v7 * v5) / v14;
    v11 = (v6 * (v8 / v7) + v5) / v14;
    v12 = v15;
  }
  else
  {
    v9 = v7 * (v7 / v8) + v8;
    v10 = (v7 / v8 * v6 - v5) / v9;
    v11 = (v5 * (v7 / v8) + v6) / v9;
    v12 = v10;
  }
  *a1 = v11;
  result = a1;
  a1[1] = v12;
  return result;
}

//----- (08054170) --------------------------------------------------------
void _libc_csu_fini(void)
{
  ;
}

//----- (08054180) --------------------------------------------------------
void _libc_csu_init(void)
{
  init_proc();
}

//----- (080541E0) --------------------------------------------------------
int __cdecl atexit(void (__cdecl *lpfunc)(void *))
{
  void *v1; // eax

  v1 = 0;
  if ( &_dso_handle )
    v1 = (void *)_dso_handle;
  return __cxa_atexit(lpfunc, 0, v1);
}

//----- (08054220) --------------------------------------------------------
void (*_do_global_ctors_aux())(void)
{
  void (*result)(void); // eax
  void (**v1)(void); // ebx

  result = (void (*)(void))_CTOR_LIST__;
  if ( _CTOR_LIST__ != -1 )
  {
    v1 = (void (**)(void))&_CTOR_LIST__;
    do
    {
      --v1;
      result();
      result = *v1;
    }
    while ( *v1 != (void (*)(void))-1 );
  }
  return result;
}
// 8055F00: using guessed type int _CTOR_LIST__;

//----- (0805424C) --------------------------------------------------------
void term_proc()
{
  _do_global_dtors_aux();
}

// nfuncs=226 queued=160 decompiled=160 lumina nreq=0 worse=0 better=0
// ALL OK, 160 function(s) have been successfully decompiled
