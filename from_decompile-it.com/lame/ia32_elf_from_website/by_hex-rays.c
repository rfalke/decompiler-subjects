/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <math.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

int sub_804A03C();
// int fileno(FILE *stream);
// double ldexp(double x, int exponent);
// int __cdecl lame_get_in_samplerate(_DWORD); weak
// int fputs(const char *s, FILE *stream);
// int get_lame_version(void); weak
// int sprintf(char *s, const char *format, ...);
// FILE *popen(const char *command, const char *modes);
// int __cdecl lame_set_num_channels(_DWORD, _DWORD); weak
// int __cdecl id3tag_v1_only(_DWORD); weak
// int __cdecl id3tag_v2_only(_DWORD); weak
// int __cdecl id3tag_set_albumart(_DWORD, _DWORD, _DWORD); weak
// int memcmp(const void *s1, const void *s2, size_t n);
// int __cdecl lame_stereo_mode_hist(_DWORD, _DWORD); weak
// int __cdecl lame_get_RadioGain(_DWORD); weak
// int __cdecl lame_set_scale_right(_DWORD, _DWORD); weak
// int getchar(void);
// int __cdecl lame_set_decode_only(_DWORD, _DWORD); weak
// int __cdecl lame_bitrate_hist(_DWORD, _DWORD); weak
// int __cdecl lame_get_noclipGainChange(_DWORD); weak
// int __cdecl id3tag_init(_DWORD); weak
// int __isoc99_sscanf(_DWORD, const char *, ...); weak
// int __cdecl __xstat64(_DWORD, _DWORD, _DWORD); weak
// int __cdecl lame_get_id3v2_tag(_DWORD, _DWORD, _DWORD); weak
// int get_lame_os_bitness(void); weak
// char *getenv(const char *name);
// char *strncpy(char *dest, const char *src, size_t n);
// int __cdecl lame_set_error_protection(_DWORD, _DWORD); weak
// int __cdecl lame_get_num_samples(_DWORD); weak
// int __cdecl lame_set_debugf(_DWORD, _DWORD); weak
// long double __cdecl lame_get_noclipScale(_DWORD); weak
// long double __cdecl lame_get_compression_ratio(_DWORD); weak
// int __cdecl lame_get_VBR_max_bitrate_kbps(_DWORD); weak
// void *memset(void *s, int c, size_t n);
// int __cdecl fopen64(_DWORD, _DWORD); weak
// int __cdecl lame_encode_buffer_int(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl lame_get_VBR_min_bitrate_kbps(_DWORD); weak
// int get_lame_url(void); weak
// int __cdecl lame_set_write_id3tag_automatic(_DWORD, _DWORD); weak
// int __cdecl id3tag_set_comment(_DWORD, _DWORD); weak
// int __cdecl lame_set_decode_on_the_fly(_DWORD, _DWORD); weak
// int _IO_getc(_IO_FILE *fp);
// int __cdecl lame_set_VBR_hard_min(_DWORD, _DWORD); weak
// int __cdecl lame_get_decode_only(_DWORD); weak
// int __cdecl lame_get_lametag_frame(_DWORD, _DWORD, _DWORD); weak
// int __cdecl lame_set_strict_ISO(_DWORD, _DWORD); weak
// int __cdecl lame_set_useTemporal(_DWORD, _DWORD); weak
// int __cdecl lame_set_force_ms(_DWORD, _DWORD); weak
// int __cdecl lame_set_compression_ratio(_DWORD, _DWORD); weak
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// void free(void *ptr);
// int __cdecl lame_set_VBR_quality(_DWORD, _DWORD); weak
// int __cdecl lame_set_disable_reservoir(_DWORD, _DWORD); weak
// int __cdecl hip_decode1_headers(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl lame_close(_DWORD); weak
// int __cdecl lame_set_nogap_total(_DWORD, _DWORD); weak
// int tgetent(char *, const char *);
// int fflush(FILE *stream);
// int __cdecl lame_get_encoder_delay(_DWORD); weak
// int fseek(FILE *stream, int off, int whence);
// int __cdecl lame_set_VBR_min_bitrate_kbps(_DWORD, _DWORD); weak
// int __cdecl lame_set_free_format(_DWORD, _DWORD); weak
// int fclose(FILE *stream);
// int __cdecl lame_set_errorf(_DWORD, _DWORD); weak
// int __cdecl lame_init_bitstream(_DWORD); weak
// int __cdecl lame_set_exp_nspsytune(_DWORD, _DWORD); weak
// clock_t clock(void);
// void *memcpy(void *dest, const void *src, size_t n);
// int __cdecl lame_get_decode_on_the_fly(_DWORD); weak
// size_t strlen(const char *s);
// int __cdecl lame_set_VBR(_DWORD, _DWORD); weak
// int __cdecl lame_print_config(_DWORD); weak
// int __cdecl lame_get_bWriteVbrTag(_DWORD); weak
// int __cdecl lame_bitrate_stereo_mode_hist(_DWORD, _DWORD); weak
// int __cdecl lame_set_nogap_currentindex(_DWORD, _DWORD); weak
// int __cdecl lame_set_msfix(_DWORD, _DWORD, _DWORD); weak
// int __cdecl lame_get_VBR(_DWORD); weak
// int __cdecl lame_set_athaa_sensitivity(_DWORD, _DWORD); weak
// int feof(FILE *stream);
// char *strcpy(char *dest, const char *src);
// int ftell(FILE *stream);
// int __cdecl lame_set_out_samplerate(_DWORD, _DWORD); weak
// int __cdecl lame_set_asm_optimizations(_DWORD, _DWORD, _DWORD); weak
// int __cdecl lame_get_quality(_DWORD); weak
// int __cdecl id3tag_set_title(_DWORD, _DWORD); weak
// int __cdecl lame_block_type_hist(_DWORD, _DWORD); weak
// int __cdecl lame_set_brate(_DWORD, _DWORD); weak
// int atoi(const char *nptr);
// int __cdecl lame_bitrate_kbps(_DWORD, _DWORD); weak
// int __cdecl lame_set_findReplayGain(_DWORD, _DWORD); weak
// int __cdecl lame_get_framesize(_DWORD); weak
// double atof(const char *nptr);
// int __cdecl id3tag_set_artist(_DWORD, _DWORD); weak
// int __cdecl lame_encode_flush(_DWORD, _DWORD, _DWORD); weak
// int __cdecl lame_set_highpassfreq(_DWORD, _DWORD); weak
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// int fprintf(FILE *stream, const char *format, ...);
// int __cdecl lame_set_VBR_mean_bitrate_kbps(_DWORD, _DWORD); weak
// int __cdecl lame_set_quality(_DWORD, _DWORD); weak
// int setvbuf(FILE *stream, char *buf, int modes, size_t n);
// char *strncat(char *dest, const char *src, size_t n);
// int __cdecl lame_get_mode(_DWORD); weak
// int __cdecl lame_set_msgf(_DWORD, _DWORD); weak
// int __cdecl id3tag_set_year(_DWORD, _DWORD); weak
// int __cdecl id3tag_set_album(_DWORD, _DWORD); weak
// void *malloc(size_t size);
// int __cdecl lame_get_totalframes(_DWORD); weak
// int __cdecl id3tag_set_pad(_DWORD, _DWORD); weak
// int __cdecl lame_encode_flush_nogap(_DWORD, _DWORD, _DWORD); weak
// int fputc(int c, FILE *stream);
// int __cdecl lame_set_VBR_max_bitrate_kbps(_DWORD, _DWORD); weak
// int __cdecl lame_get_num_channels(_DWORD); weak
// int hip_decode_init(void); weak
// int __cdecl lame_set_original(_DWORD, _DWORD); weak
// int __cdecl id3tag_pad_v2(_DWORD); weak
// int tgetnum(const char *);
// int __cdecl lame_get_version(_DWORD); weak
// int __cdecl id3tag_add_v2(_DWORD); weak
// int __cdecl lame_init_params(_DWORD); weak
// int __cdecl lame_set_bWriteVbrTag(_DWORD, _DWORD); weak
// char *strcat(char *dest, const char *src);
// int __cdecl lame_get_id3v1_tag(_DWORD, _DWORD, _DWORD); weak
// int __cdecl id3tag_genre_list(_DWORD, _DWORD); weak
// int __cdecl lame_get_exp_nspsytune(_DWORD); weak
// int __cdecl id3tag_set_track(_DWORD, _DWORD); weak
// int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD); weak
// int __cdecl lame_get_frameNum(_DWORD); weak
// int __cdecl lame_set_interChRatio(_DWORD, _DWORD); weak
// int __cdecl id3tag_set_genre(_DWORD, _DWORD); weak
// int __cdecl lame_set_num_samples(_DWORD, _DWORD); weak
// int __cdecl lame_set_preset(_DWORD, _DWORD); weak
// int __cdecl lame_get_free_format(_DWORD); weak
// int __cdecl lame_set_emphasis(_DWORD, _DWORD); weak
// int __cdecl lame_set_mode(_DWORD, _DWORD); weak
// int __cdecl hip_decode_exit(_DWORD); weak
// int __cdecl lame_print_internals(_DWORD); weak
// int vfprintf(FILE *s, const char *format, __gnuc_va_list arg);
// int __cdecl lame_set_experimentalY(_DWORD, _DWORD); weak
// int _IO_putc(int c, _IO_FILE *fp);
// long double __cdecl lame_get_VBR_quality(_DWORD); weak
// int __cdecl lame_get_findReplayGain(_DWORD); weak
// int __cdecl lame_set_in_samplerate(_DWORD, _DWORD); weak
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
// int __cdecl lame_get_out_samplerate(_DWORD); weak
// int __cdecl lame_set_VBR_q(_DWORD, _DWORD); weak
// char *tgetstr(const char *, char **);
// int __cdecl lame_get_force_ms(_DWORD); weak
// int __cdecl lame_set_lowpassfreq(_DWORD, _DWORD); weak
// int __cdecl lame_set_scale_left(_DWORD, _DWORD); weak
// int __cdecl lame_get_brate(_DWORD); weak
// int lame_init(void); weak
// int __cdecl lame_set_highpasswidth(_DWORD, _DWORD); weak
// char *strdup(const char *s);
// int __cdecl id3tag_set_fieldvalue(_DWORD, _DWORD); weak
// int __cdecl lame_set_scale(_DWORD, _DWORD); weak
// int ferror(FILE *stream);
// int __cdecl hip_decode1_headersB(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int tolower(int c);
// int __cdecl lame_set_copyright(_DWORD, _DWORD); weak
// int __cdecl lame_set_lowpasswidth(_DWORD, _DWORD); weak
// int strcmp(const char *s1, const char *s2);
// void exit(int status);
// int __cdecl id3tag_space_v1(_DWORD); weak
// int __cdecl lame_get_VBR_q(_DWORD); weak
// int pclose(FILE *stream);
// int __cdecl lame_get_VBR_mean_bitrate_kbps(_DWORD); weak
int __cdecl parse_args_from_string(lame_global_flags *const gfp, const char *p, char *inPath, char *outPath);
FILE *__cdecl init_files(lame_global_flags *gf, char *inPath, char *outPath, int *enc_delay, int *enc_padding);
int __cdecl lame_decoder(lame_global_flags *gfp, FILE *outf, int skip_start, char *inPath, char *outPath, int *enc_delay, int *enc_padding);
void __cdecl print_lame_tag_leading_info(lame_global_flags *gf);
void __cdecl print_trailing_info(lame_global_flags *gf);
int __cdecl write_xing_frame(lame_global_flags *gf, FILE *outf);
int __cdecl lame_encoder(lame_global_flags *gf, FILE *outf, int nogap, char *inPath, char *outPath);
void __cdecl brhist_init_package(lame_global_flags *gf);
void __cdecl parse_nogap_filenames(int nogapout, char *inPath, char *outPath, char *outdir);
int __cdecl main(int argc, const char **argv, const char **envp);
int __cdecl my_console_printing(FILE *fp, const char *format, va_list ap);
int __cdecl my_error_printing(FILE *fp, const char *format, va_list ap);
int __cdecl my_report_printing(FILE *fp, const char *format, va_list ap);
void __cdecl apply_termcap_settings(Console_IO_t *const mfp);
int __cdecl init_console(Console_IO_t *const mfp);
void __cdecl deinit_console(Console_IO_t *const mfp);
int frontend_open_console(); // idb
void frontend_close_console(); // idb
void __cdecl frontend_debugf(const char *format, va_list ap);
void __cdecl frontend_msgf(const char *format, va_list ap);
void __cdecl frontend_errorf(const char *format, va_list ap);
int console_printf(const char *format, ...);
int error_printf(const char *format, ...);
int report_printf(const char *format, ...);
void console_flush(); // idb
void error_flush(); // idb
void report_flush(); // idb
void __cdecl console_up(int n_lines);
void __cdecl set_debug_file(const char *fn);
size_t __cdecl min_size_t(size_t a, size_t b);
ByteOrder machine_byte_order(); // idb
int __cdecl fskip(FILE *fp, int offset, int whence);
FILE *__cdecl init_outfile(char *outPath, int decode);
void __cdecl init_infile(lame_global_flags *gfp, char *inPath, int *enc_delay, int *enc_padding);
void close_infile(); // idb
void __cdecl SwapBytesInWords(__int16 *ptr, int short_words);
int __cdecl get_audio(lame_global_flags *const gfp, int (*buffer)[1152]);
int __cdecl get_audio16(lame_global_flags *const gfp, __int16 (*buffer)[1152]);
int __cdecl get_audio_common(lame_global_flags *const gfp, int (*buffer)[1152], __int16 (*buffer16)[1152]);
int __cdecl read_samples_mp3(lame_global_flags *const gfp, FILE *const musicin, __int16 (*mpg123pcm)[1152]);
int __cdecl WriteWaveHeader(FILE *const fp, const int pcmbytes, const int freq, const int channels, const int bits);
int __cdecl unpack_read_samples(const int samples_to_read, const int bytes_per_sample, const int swap_order, int *sample_buffer, FILE *pcm_in);
int __cdecl read_samples_pcm(FILE *musicin, int *sample_buffer, int samples_to_read);
int __cdecl parse_wave_header(lame_global_flags *gfp, FILE *sf_0);
int __cdecl aiff_check2(IFF_AIFF *const pcm_aiff_data);
int __cdecl make_even_number_of_bytes_in_length(int x);
int __cdecl parse_aiff_header(lame_global_flags *gfp, FILE *sf_0);
int __cdecl parse_file_header(lame_global_flags *gfp, FILE *sf_0);
void __cdecl CloseSndFile(sound_file_format input, FILE *musicin);
FILE *__cdecl OpenSndFile(lame_global_flags *gfp, char *inPath, int *enc_delay, int *enc_padding);
int __cdecl check_aid(const unsigned __int8 *header);
int __cdecl is_syncword_mp123(const void *const headerptr);
int __cdecl lame_decode_initfile(FILE *fd, mp3data_struct *mp3data, int *enc_delay, int *enc_padding);
int __cdecl lame_decode_fromfile(FILE *fd, __int16 *pcm_l, __int16 *pcm_r, mp3data_struct *mp3data);
int __cdecl is_mpeg_file_format(int input_file_format);
long double GetCPUTime();
long double GetRealTime();
int __cdecl lame_set_stream_binary_mode(FILE *const fp);
off_t __cdecl lame_get_file_size(const char *const filename);
int __cdecl set_id3tag(lame_global_flags *gfp, int type, const char *str);
int __cdecl id3_tag(lame_global_flags *gfp, int type, TextEncoding_0 enc, char *str);
int __cdecl lame_version_print(FILE *const fp);
int __cdecl print_license(FILE *const fp);
int __cdecl usage(FILE *const fp, const char *ProgramName);
int __cdecl short_help(const lame_global_flags *gfp, FILE *const fp, const char *ProgramName);
void __cdecl wait_for(FILE *const fp, int lessmode);
int __cdecl long_help(const lame_global_flags *gfp, FILE *const fp, const char *ProgramName, int lessmode);
void __cdecl display_bitrate(FILE *const fp, const char *const version, const int d, const int indx);
int __cdecl display_bitrates(FILE *const fp);
void __cdecl presets_longinfo_dm(FILE *msgfp);
int __cdecl presets_set(lame_t gfp, int fast, int cbr, const char *preset_name, const char *ProgramName);
void __cdecl genre_list_handler(int num, const char *name, void *cookie);
int __cdecl local_strcasecmp(const char *s1, const char *s2);
int __cdecl filename_to_type(const char *FileName);
int __cdecl resample_rate(double freq);
int __cdecl set_id3_albumart(lame_t gfp, const char *file_name);
int __cdecl parse_args(lame_global_flags *gfp, int argc, char **argv, char *const inPath, char *const outPath, char **nogap_inPath, int *num_nogap);
int __cdecl ReadByte(FILE *fp);
int __cdecl Read16BitsLowHigh(FILE *fp);
int __cdecl Read16BitsHighLow(FILE *fp);
void __cdecl Write8Bits(FILE *fp, int i);
void __cdecl Write16BitsLowHigh(FILE *fp, int i);
void __cdecl Write16BitsHighLow(FILE *fp, int i);
int __cdecl Read24BitsHighLow(FILE *fp);
int __cdecl Read32Bits(FILE *fp);
int __cdecl Read32BitsHighLow(FILE *fp);
void __cdecl Write32Bits(FILE *fp, int i);
void __cdecl Write32BitsLowHigh(FILE *fp, int i);
void __cdecl Write32BitsHighLow(FILE *fp, int i);
void __cdecl ReadBytes(FILE *fp, char *p, int n);
void __cdecl ReadBytesSwapped(FILE *fp, char *p, int n);
void __cdecl WriteBytes(FILE *fp, char *p, int n);
void __cdecl WriteBytesSwapped(FILE *fp, char *p, int n);
double __cdecl ConvertFromIeeeExtended(char *bytes);
double __cdecl ReadIeeeExtendedHighLow(FILE *fp);
void __cdecl ts_calc_times(timestatus_t *const tstime, const int sample_freq, const int frameNum, const int totalframes, const int framesize);
void __cdecl ts_time_decompose(const unsigned int time_in_sec, const char padded_char);
void __cdecl timestatus(const lame_global_flags *const gfp);
void timestatus_finish(); // idb
void __cdecl encoder_progress_begin(const lame_global_flags *gf, const char *inPath, const char *outPath);
void __cdecl encoder_progress(const lame_global_flags *gf);
void __cdecl encoder_progress_end(const lame_global_flags *gf);
void __cdecl decoder_progress(const mp3data_struct *const mp3data);
void decoder_progress_finish(); // idb
int __cdecl calculate_index(const int *const array, const int len, const int value);
int __cdecl brhist_init(const lame_global_flags *gf, const int bitrate_kbps_min, const int bitrate_kbps_max);
int __cdecl digits(unsigned int number);
void __cdecl brhist_disp_line(int i, int br_hist_TOT, int br_hist_LR, int full, int frames);
void __cdecl progress_line(const lame_global_flags *gf, int full, int frames);
int __cdecl stats_value(double x);
int __cdecl stats_head(double x, const char *txt);
void __cdecl stats_line(double *stat);
void __cdecl brhist_disp(const lame_global_flags *gf);
void brhist_jump_back(); // idb
int __cdecl stat64(int, int);
int __cdecl fstat64(int, int);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN unk_80548B4; // weak
const int IFF_ID_FORM = 1179603533; // idb
const int IFF_ID_AIFF = 1095321158; // idb
const int IFF_ID_AIFC = 1095321155; // idb
const int IFF_ID_COMM = 1129270605; // idb
const int IFF_ID_SSND = 1397968452; // idb
const int IFF_ID_NONE = 1313820229; // idb
const int IFF_ID_2CBE = 1953984371; // idb
const int IFF_ID_2CLE = 1936684916; // idb
const int WAV_ID_RIFF = 1380533830; // idb
const int WAV_ID_WAVE = 1463899717; // idb
const int WAV_ID_FMT = 1718449184; // idb
const int WAV_ID_DATA = 1684108385; // idb
const __int16 WAVE_FORMAT_PCM = 1; // idb
const __int16 WAVE_FORMAT_EXTENSIBLE = -2; // idb
_UNKNOWN unk_805540A; // weak
const char abl2_5481[16] =
{
  '\0',
  '\a',
  '\a',
  '\a',
  '\0',
  '\a',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b'
}; // idb
_UNKNOWN unk_8055592; // weak
_UNKNOWN unk_8058E4C; // weak
_UNKNOWN unk_8059978; // weak
_UNKNOWN unk_8059B6F; // weak
int (*dword_805AFFC)(void) = NULL; // weak
int in_signed = -1; // idb
int in_bitwidth = 16; // idb
const char *mode_names_3185[2][4] =
{
  { "stereo", "j-stereo", "dual-ch", "single-ch" },
  { "stereo", "force-ms", "dual-ch", "single-ch" }
}; // idb
int bitrate_table[48]; // weak
FILE *stderr; // idb
int stdin; // weak
FILE *stdout; // idb
get_audio_global_data_0 global; // idb
int swapbytes; // idb
ByteOrder in_endian; // idb
int flush_write; // idb
int last_3337; // idb
double last_time_3286; // idb
timestatus_t real_time_3105; // idb
timestatus_t proc_time_3106; // idb
int init_3108; // idb
$DB849BC57864895E335F6A20A53EF64C brhist; // idb
Console_IO_t Console_IO; // idb
int mp3_delay; // idb
sound_file_format input_format; // idb
int mp3_delay_set; // idb
int silent; // idb
float update_interval; // idb
int print_clipping_info; // idb
int disable_wav_header; // idb
int brhist_0; // idb
mp3data_struct mp3input_data; // idb
int ignore_tag_errors; // idb


//----- (0804A03C) --------------------------------------------------------
int sub_804A03C()
{
  return dword_805AFFC();
}
// 805AFFC: using guessed type int (*dword_805AFFC)(void);

//----- (0804AB84) --------------------------------------------------------
int __cdecl parse_args_from_string(lame_global_flags *const gfp, const char *p, char *inPath, char *outPath)
{
  size_t v5; // eax
  char *r[128]; // [esp+20h] [ebp-218h] BYREF
  int ret; // [esp+220h] [ebp-18h]
  int c; // [esp+224h] [ebp-14h]
  char *f; // [esp+228h] [ebp-10h]
  char *q; // [esp+22Ch] [ebp-Ch]

  c = 0;
  if ( !p || !*p )
    return 0;
  v5 = strlen(p);
  q = (char *)malloc(v5 + 1);
  f = q;
  strcpy(q, p);
  r[c++] = "lhama";
  while ( 1 )
  {
    r[c++] = q;
    while ( *q != 32 && *q )
      ++q;
    if ( !*q )
      break;
    *q++ = 0;
  }
  r[c] = 0;
  ret = parse_args(gfp, c, r, inPath, outPath, 0, 0);
  free(f);
  return ret;
}

//----- (0804AC92) --------------------------------------------------------
FILE *__cdecl init_files(lame_global_flags *gf, char *inPath, char *outPath, int *enc_delay, int *enc_padding)
{
  int decode_only; // [esp+4h] [ebp-24h]
  FILE *outf; // [esp+1Ch] [ebp-Ch]

  if ( !strcmp("-", outPath) || strcmp(inPath, outPath) )
  {
    init_infile(gf, inPath, enc_delay, enc_padding);
    decode_only = lame_get_decode_only(gf);
    outf = init_outfile(outPath, decode_only);
    if ( outf )
    {
      return outf;
    }
    else
    {
      error_printf("Can't init outfile '%s'\n", outPath);
      return 0;
    }
  }
  else
  {
    error_printf("Input file and Output file are the same. Abort.\n");
    return 0;
  }
}
// 804A30C: using guessed type int __cdecl lame_get_decode_only(_DWORD);

//----- (0804AD3A) --------------------------------------------------------
int __cdecl lame_decoder(
        lame_global_flags *gfp,
        FILE *outf,
        int skip_start,
        char *inPath,
        char *outPath,
        int *enc_delay,
        int *enc_padding)
{
  const char *v7; // esi
  const char *v8; // ebx
  char *v9; // eax
  const char *v10; // ebx
  int v11; // eax
  const char *v12; // ebx
  int v13; // eax
  const char *v14; // ebx
  int version; // eax
  const char *v16; // ebx
  char *v17; // eax
  void (*v18)(FILE *, char *, int); // eax
  int v19; // eax
  int v20; // edx
  int result; // eax
  int v22; // [esp+8h] [ebp-1270h]
  double v23; // [esp+38h] [ebp-1240h]
  __int16 Buffer[2][1152]; // [esp+50h] [ebp-1228h] BYREF
  double wavsize; // [esp+1250h] [ebp-28h]
  int tmp_num_channels; // [esp+125Ch] [ebp-1Ch]
  void (*WriteFunction)(FILE *, char *, int); // [esp+1260h] [ebp-18h]
  int i; // [esp+1264h] [ebp-14h]
  int skip_end; // [esp+1268h] [ebp-10h]
  int iread; // [esp+126Ch] [ebp-Ch]

  skip_end = 0;
  tmp_num_channels = lame_get_num_channels(gfp);
  if ( silent <= 9 )
  {
    if ( tmp_num_channels == 1 )
      v7 = (const char *)&unk_80548B4;
    else
      v7 = "s";
    v23 = (long double)lame_get_in_samplerate(gfp) / 1000.0;
    if ( strlen(inPath) <= 0x1A )
      v8 = "  ";
    else
      v8 = "\n\t";
    if ( !strcmp(inPath, "-") )
      v9 = "<stdin>";
    else
      v9 = inPath;
    console_printf("\rinput:  %s%s(%g kHz, %i channel%s, ", v9, v8, v23, tmp_num_channels, v7);
  }
  switch ( input_format )
  {
    case sf_raw:
      if ( silent <= 9 )
        console_printf("raw PCM data");
      goto LABEL_49;
    case sf_wave:
      if ( silent <= 9 )
        console_printf("Microsoft WAVE");
      goto LABEL_49;
    case sf_aiff:
      if ( silent <= 9 )
        console_printf("SGI/Apple AIFF");
      goto LABEL_49;
    case sf_mp1:
      skip_start += 241;
      if ( silent <= 9 )
      {
        if ( lame_get_out_samplerate(gfp) > 15999 )
          v14 = (const char *)&unk_80548B4;
        else
          v14 = ".5";
        version = lame_get_version(gfp);
        console_printf("MPEG-%u%s Layer %s", 2 - version, v14, "I");
      }
      goto LABEL_50;
    case sf_mp2:
      skip_start += 241;
      if ( silent <= 9 )
      {
        if ( lame_get_out_samplerate(gfp) > 15999 )
          v12 = (const char *)&unk_80548B4;
        else
          v12 = ".5";
        v13 = lame_get_version(gfp);
        console_printf("MPEG-%u%s Layer %s", 2 - v13, v12, "II");
      }
      goto LABEL_50;
    case sf_mp3:
      if ( skip_start )
      {
        skip_start += 529;
      }
      else if ( *enc_delay < 0 && *enc_padding < 0 )
      {
        skip_start = lame_get_encoder_delay(gfp) + 529;
      }
      else
      {
        if ( *enc_delay >= 0 )
          skip_start = *enc_delay + 529;
        if ( *enc_padding >= 0 )
          skip_end = *enc_padding - 529;
      }
      if ( silent <= 9 )
      {
        if ( lame_get_out_samplerate(gfp) > 15999 )
          v10 = (const char *)&unk_80548B4;
        else
          v10 = ".5";
        v11 = lame_get_version(gfp);
        console_printf("MPEG-%u%s Layer %s", 2 - v11, v10, "III");
      }
      goto LABEL_50;
    case sf_mp123:
      error_printf("Internal error.  Aborting.");
      exit(-1);
      return result;
    default:
      if ( silent <= 9 )
        console_printf("unknown");
LABEL_49:
      mp3input_data.nsamp = lame_get_num_samples(gfp);
      mp3input_data.framesize = 1152;
      skip_start = 0;
LABEL_50:
      if ( silent <= 9 )
      {
        if ( strlen(outPath) <= 0x2D )
          v16 = "  ";
        else
          v16 = "\n\t";
        if ( !strcmp(outPath, "-") )
          v17 = "<stdout>";
        else
          v17 = outPath;
        console_printf(")\noutput: %s%s(16 bit, Microsoft WAVE)\n", v17, v16);
        if ( skip_start > 0 )
          console_printf("skipping initial %i samples (encoder+decoder delay)\n", skip_start);
        if ( skip_end > 0 )
          console_printf("skipping final %i samples (encoder padding-decoder delay)\n", skip_end);
      }
      if ( !disable_wav_header )
      {
        v22 = lame_get_in_samplerate(gfp);
        WriteWaveHeader(outf, 0x7FFFFFFF, v22, tmp_num_channels, 16);
      }
      wavsize = (double)-(skip_start + skip_end);
      if ( swapbytes )
        v18 = WriteBytesSwapped;
      else
        v18 = WriteBytes;
      WriteFunction = v18;
      mp3input_data.totalframes = mp3input_data.nsamp / mp3input_data.framesize;
      do
      {
        iread = get_audio16(gfp, Buffer);
        if ( iread >= 0 )
        {
          mp3input_data.framenum += iread / mp3input_data.framesize;
          wavsize = (long double)iread + wavsize;
          if ( silent <= 0 )
          {
            decoder_progress(&mp3input_data);
            console_flush();
          }
          v19 = skip_start;
          if ( iread <= skip_start )
            v19 = iread;
          i = v19;
          skip_start -= v19;
          if ( skip_end <= 1152 || mp3input_data.framenum + 2 <= mp3input_data.totalframes )
          {
            if ( mp3input_data.framenum == mp3input_data.totalframes && iread )
              iread -= skip_end;
          }
          else
          {
            iread += 1152 - skip_end;
            skip_end = 1152;
          }
          while ( i < iread )
          {
            if ( disable_wav_header )
            {
              WriteFunction(outf, (char *)Buffer + 2 * i, 2);
              if ( tmp_num_channels == 2 )
                WriteFunction(outf, (char *)&Buffer[1][i], 2);
            }
            else
            {
              Write16BitsLowHigh(outf, Buffer[0][i]);
              if ( tmp_num_channels == 2 )
                Write16BitsLowHigh(outf, Buffer[1][i]);
            }
            ++i;
          }
          if ( flush_write == 1 )
            fflush(outf);
        }
      }
      while ( iread > 0 );
      i = 2 * tmp_num_channels;
      if ( wavsize > 0.0 )
      {
        if ( wavsize <= (long double)(0xFFFFFFD0 / i) )
        {
          wavsize = (long double)i * wavsize;
        }
        else
        {
          if ( silent <= 9 )
            error_printf("Very huge WAVE file, can't set filesize accordingly\n");
          wavsize = 4294967248.0;
        }
      }
      else
      {
        if ( silent <= 9 )
          error_printf("WAVE file contains 0 PCM samples\n");
        wavsize = 0.0;
      }
      if ( !disable_wav_header && strcmp("-", outPath) && !fseek(outf, 0, 0) )
      {
        v20 = lame_get_in_samplerate(gfp);
        WriteWaveHeader(outf, (int)wavsize, v20, tmp_num_channels, 16);
      }
      fclose(outf);
      if ( silent <= 0 )
        decoder_progress_finish();
      return 0;
  }
}
// 804A06C: using guessed type int __cdecl lame_get_in_samplerate(_DWORD);
// 804A20C: using guessed type int __cdecl lame_get_num_samples(_DWORD);
// 804A3FC: using guessed type int __cdecl lame_get_encoder_delay(_DWORD);
// 804A75C: using guessed type int __cdecl lame_get_num_channels(_DWORD);
// 804A7AC: using guessed type int __cdecl lame_get_version(_DWORD);
// 804A95C: using guessed type int __cdecl lame_get_out_samplerate(_DWORD);

//----- (0804B4F0) --------------------------------------------------------
void __cdecl print_lame_tag_leading_info(lame_global_flags *gf)
{
  if ( lame_get_bWriteVbrTag(gf) )
    console_printf("Writing LAME Tag...");
}
// 804A4DC: using guessed type int __cdecl lame_get_bWriteVbrTag(_DWORD);

//----- (0804B513) --------------------------------------------------------
void __cdecl print_trailing_info(lame_global_flags *gf)
{
  const char *v1; // eax
  float noclipScale; // [esp+24h] [ebp-14h]
  float noclipGainChange; // [esp+28h] [ebp-10h]
  int RadioGain; // [esp+2Ch] [ebp-Ch]

  if ( lame_get_bWriteVbrTag(gf) )
    console_printf("done\n");
  if ( lame_get_findReplayGain(gf) )
  {
    RadioGain = lame_get_RadioGain(gf);
    v1 = RadioGain <= 0 ? (const char *)&unk_80548B4 : "+";
    console_printf("ReplayGain: %s%.1fdB\n", v1, (double)((long double)RadioGain / 10.0));
    if ( RadioGain > 510 || RadioGain < -510 )
      error_printf(
        "WARNING: ReplayGain exceeds the -51dB to +51dB range. Such a result is too\n"
        "         high to be stored in the header.\n");
  }
  if ( print_clipping_info && lame_get_decode_on_the_fly(gf) )
  {
    noclipGainChange = (long double)lame_get_noclipGainChange(gf) / 10.0;
    noclipScale = lame_get_noclipScale(gf);
    if ( noclipGainChange <= 0.0 )
    {
      if ( noclipGainChange <= -0.1 )
        console_printf("\nThe waveform does not clip and is at least %.1fdB away from full scale.\n", -noclipGainChange);
      else
        console_printf("\nThe waveform does not clip and is less than 0.1dB away from full scale.\n");
    }
    else
    {
      console_printf(
        "WARNING: clipping occurs at the current gain. Set your decoder to decrease\n"
        "         the  gain  by  at least %.1fdB or encode again ",
        noclipGainChange);
      if ( noclipScale <= 0.0 )
      {
        console_printf(
          "using --scale <arg>\n"
          "         (For   a   suggestion  on  the  optimal  value  of  <arg>  encode\n"
          "         with  --scale 1  first)\n");
      }
      else
      {
        console_printf("using  --scale %.2f\n", noclipScale);
        console_printf("         or less (the value under --scale is approximate).\n");
      }
    }
  }
}
// 804A11C: using guessed type int __cdecl lame_get_RadioGain(_DWORD);
// 804A16C: using guessed type int __cdecl lame_get_noclipGainChange(_DWORD);
// 804A22C: using guessed type long double __cdecl lame_get_noclipScale(_DWORD);
// 804A49C: using guessed type int __cdecl lame_get_decode_on_the_fly(_DWORD);
// 804A4DC: using guessed type int __cdecl lame_get_bWriteVbrTag(_DWORD);
// 804A92C: using guessed type int __cdecl lame_get_findReplayGain(_DWORD);

//----- (0804B68B) --------------------------------------------------------
int __cdecl write_xing_frame(lame_global_flags *gf, FILE *outf)
{
  unsigned int imp3; // [esp+28h] [ebp-24010h]
  unsigned __int8 mp3buffer[147456]; // [esp+2Ch] [ebp-2400Ch] BYREF
  unsigned int v5; // [esp+2402Ch] [ebp-Ch]

  v5 = __readgsdword(0x14u);
  imp3 = lame_get_lametag_frame(gf, mp3buffer, 147456);
  if ( imp3 <= 0x24000 )
  {
    if ( imp3 )
    {
      if ( fwrite(mp3buffer, 1u, imp3, outf) == imp3 )
      {
        if ( flush_write == 1 )
          fflush(outf);
        return imp3;
      }
      else
      {
        error_printf("Error writing LAME-tag \n");
        return -1;
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    error_printf("Error writing LAME-tag frame: buffer too small: buffer size=%d  frame size=%d\n", 147456, imp3);
    return -1;
  }
}
// 804A31C: using guessed type int __cdecl lame_get_lametag_frame(_DWORD, _DWORD, _DWORD);

//----- (0804B79A) --------------------------------------------------------
int __cdecl lame_encoder(lame_global_flags *gf, FILE *outf, int nogap, char *inPath, char *outPath)
{
  int Buffer[2][1152]; // [esp+3Ch] [ebp-2641Ch] BYREF
  int id3v2_size; // [esp+243Ch] [ebp-2401Ch]
  int owrite; // [esp+2440h] [ebp-24018h]
  int imp3; // [esp+2444h] [ebp-24014h]
  int iread; // [esp+2448h] [ebp-24010h]
  unsigned __int8 mp3buffer[147456]; // [esp+244Ch] [ebp-2400Ch] BYREF
  unsigned int v12; // [esp+2644Ch] [ebp-Ch]

  v12 = __readgsdword(0x14u);
  encoder_progress_begin(gf, inPath, outPath);
  imp3 = lame_get_id3v2_tag(gf, mp3buffer, 147456);
  if ( (unsigned int)imp3 <= 0x24000 )
  {
    owrite = fwrite(mp3buffer, 1u, imp3, outf);
    if ( owrite == imp3 )
    {
      if ( flush_write == 1 )
        fflush(outf);
      id3v2_size = imp3;
      do
      {
        iread = get_audio(gf, Buffer);
        if ( iread >= 0 )
        {
          encoder_progress(gf);
          imp3 = lame_encode_buffer_int(gf, Buffer, Buffer[1], iread, mp3buffer, 147456);
          if ( imp3 < 0 )
          {
            if ( imp3 == -1 )
              error_printf("mp3 buffer is not big enough... \n");
            else
              error_printf("mp3 internal error:  error code=%i\n", imp3);
            return 1;
          }
          owrite = fwrite(mp3buffer, 1u, imp3, outf);
          if ( owrite != imp3 )
            goto LABEL_15;
        }
        if ( flush_write == 1 )
          fflush(outf);
      }
      while ( iread > 0 );
      if ( nogap )
        imp3 = lame_encode_flush_nogap(gf, mp3buffer, 147456);
      else
        imp3 = lame_encode_flush(gf, mp3buffer, 147456);
      if ( imp3 >= 0 )
      {
        encoder_progress_end(gf);
        owrite = fwrite(mp3buffer, 1u, imp3, outf);
        if ( owrite != imp3 )
        {
LABEL_15:
          error_printf("Error writing mp3 output \n");
          return 1;
        }
        if ( flush_write == 1 )
          fflush(outf);
        imp3 = lame_get_id3v1_tag(gf, mp3buffer, 147456);
        if ( (unsigned int)imp3 <= 0x24000 )
        {
          if ( imp3 > 0 )
          {
            owrite = fwrite(mp3buffer, 1u, imp3, outf);
            if ( owrite != imp3 )
            {
              error_printf("Error writing ID3v1 tag \n");
              return 1;
            }
            if ( flush_write == 1 )
              fflush(outf);
          }
        }
        else
        {
          error_printf("Error writing ID3v1 tag: buffer too small: buffer size=%d  ID3v1 size=%d\n", 147456, imp3);
        }
        if ( silent <= 0 )
          print_lame_tag_leading_info(gf);
        if ( fseek(outf, id3v2_size, 0) )
          error_printf("fatal error: can't update LAME-tag frame!\n");
        else
          write_xing_frame(gf, outf);
        if ( silent <= 0 )
          print_trailing_info(gf);
        return 0;
      }
      else
      {
        if ( imp3 == -1 )
          error_printf("mp3 buffer is not big enough... \n");
        else
          error_printf("mp3 internal error:  error code=%i\n", imp3);
        return 1;
      }
    }
    else
    {
      encoder_progress_end(gf);
      error_printf("Error writing ID3v2 tag \n");
      return 1;
    }
  }
  else
  {
    encoder_progress_end(gf);
    error_printf("Error writing ID3v2 tag: buffer too small: buffer size=%d  ID3v2 size=%d\n", 147456, imp3);
    return 1;
  }
}
// 804A1BC: using guessed type int __cdecl lame_get_id3v2_tag(_DWORD, _DWORD, _DWORD);
// 804A27C: using guessed type int __cdecl lame_encode_buffer_int(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 804A62C: using guessed type int __cdecl lame_encode_flush(_DWORD, _DWORD, _DWORD);
// 804A72C: using guessed type int __cdecl lame_encode_flush_nogap(_DWORD, _DWORD, _DWORD);
// 804A7FC: using guessed type int __cdecl lame_get_id3v1_tag(_DWORD, _DWORD, _DWORD);

//----- (0804BC85) --------------------------------------------------------
void __cdecl brhist_init_package(lame_global_flags *gf)
{
  int VBR_max_bitrate_kbps; // ebx
  int VBR_min_bitrate_kbps; // [esp+4h] [ebp-14h]

  if ( brhist_0 )
  {
    VBR_max_bitrate_kbps = lame_get_VBR_max_bitrate_kbps(gf);
    VBR_min_bitrate_kbps = lame_get_VBR_min_bitrate_kbps(gf);
    if ( brhist_init(gf, VBR_min_bitrate_kbps, VBR_max_bitrate_kbps) )
      brhist_0 = 0;
  }
  else
  {
    brhist_init(gf, 128, 128);
  }
}
// 804A24C: using guessed type int __cdecl lame_get_VBR_max_bitrate_kbps(_DWORD);
// 804A28C: using guessed type int __cdecl lame_get_VBR_min_bitrate_kbps(_DWORD);

//----- (0804BCF1) --------------------------------------------------------
void __cdecl parse_nogap_filenames(int nogapout, char *inPath, char *outPath, char *outdir)
{
  size_t n; // [esp+18h] [ebp-10h]
  char *slasher; // [esp+1Ch] [ebp-Ch]

  strcpy(outPath, outdir);
  if ( nogapout )
  {
    for ( slasher = inPath + 4093; *slasher != 47 && *slasher != 92 && slasher != inPath && *slasher != 58; --slasher )
      ;
    if ( slasher != inPath
      && (outPath[strlen(outPath) - 1] == 47 || outPath[strlen(outPath) - 1] == 92 || outPath[strlen(outPath) - 1] == 58) )
    {
      ++slasher;
    }
    else if ( slasher == inPath
           && outPath[strlen(outPath) - 1] != 47
           && outPath[strlen(outPath) - 1] != 92
           && outPath[strlen(outPath) - 1] != 58 )
    {
      strcat(outPath, "/");
    }
    strncat(outPath, slasher, 0xFFDu);
    n = strlen(outPath);
    if ( outPath[n - 3] == 119 && outPath[n - 2] == 97 && outPath[n - 1] == 118 && outPath[n - 4] == 46 )
    {
      outPath[n - 3] = 109;
      outPath[n - 2] = 112;
      outPath[n - 1] = 51;
      return;
    }
  }
  else
  {
    strncpy(outPath, inPath, 0xFFDu);
    n = strlen(outPath);
    if ( outPath[n - 3] == 119 && outPath[n - 2] == 97 && outPath[n - 1] == 118 && outPath[n - 4] == 46 )
    {
      outPath[n - 3] = 109;
      outPath[n - 2] = 112;
      outPath[n - 1] = 51;
      return;
    }
  }
  outPath[n] = 46;
  outPath[n + 1] = 109;
  outPath[n + 2] = 112;
  outPath[n + 3] = 51;
  outPath[n + 4] = 0;
}

//----- (0804BFA5) --------------------------------------------------------
int __cdecl main(int argc, const char **argv, const char **envp)
{
  char *v4; // eax
  char s[819400]; // [esp+3Ch] [ebp-CB424h] BYREF
  char *nogap_inPath[200]; // [esp+C8104h] [ebp-335Ch] BYREF
  int v7; // [esp+C8424h] [ebp-303Ch]
  FILE *inited; // [esp+C8428h] [ebp-3038h]
  int i; // [esp+C842Ch] [ebp-3034h]
  int num_nogap; // [esp+C8430h] [ebp-3030h] BYREF
  int v11; // [esp+C8434h] [ebp-302Ch]
  int enc_padding; // [esp+C8438h] [ebp-3028h] BYREF
  int enc_delay; // [esp+C843Ch] [ebp-3024h] BYREF
  lame_global_flags *v14; // [esp+C8440h] [ebp-3020h]
  int v15; // [esp+C8444h] [ebp-301Ch]
  char inPath[4097]; // [esp+C8449h] [ebp-3017h] BYREF
  char dest[4097]; // [esp+C944Ah] [ebp-2016h] BYREF
  char outPath[4097]; // [esp+CA44Bh] [ebp-1015h] BYREF
  unsigned int v19; // [esp+CB44Ch] [ebp-14h]

  v19 = __readgsdword(0x14u);
  enc_delay = -1;
  enc_padding = -1;
  v11 = 0;
  num_nogap = 200;
  memset(s, 0, sizeof(s));
  for ( i = 0; i <= 199; ++i )
    nogap_inPath[i] = &s[4097 * i];
  memset(inPath, 0, sizeof(inPath));
  frontend_open_console();
  input_format = sf_unknown;
  v14 = (lame_global_flags *)lame_init();
  if ( v14 )
  {
    lame_set_errorf(v14, frontend_errorf);
    lame_set_debugf(v14, frontend_debugf);
    lame_set_msgf(v14, frontend_msgf);
    if ( argc > 1 )
    {
      v4 = getenv("LAMEOPT");
      parse_args_from_string(v14, v4, inPath, outPath);
      v15 = parse_args(v14, argc, (char **)argv, inPath, outPath, nogap_inPath, &num_nogap);
      if ( v15 >= 0 )
      {
        if ( update_interval < 0.0 )
          update_interval = 2.0;
        if ( outPath[0] && num_nogap > 0 )
        {
          strncpy(dest, outPath, 0x1001u);
          v11 = 1;
        }
        if ( num_nogap <= 0 )
        {
          inited = init_files(v14, inPath, outPath, &enc_delay, &enc_padding);
        }
        else
        {
          parse_nogap_filenames(v11, nogap_inPath[0], outPath, dest);
          inited = init_files(v14, nogap_inPath[0], outPath, &enc_delay, &enc_padding);
        }
        if ( inited )
        {
          lame_set_write_id3tag_automatic(v14, 0);
          i = lame_init_params(v14);
          if ( i >= 0 )
          {
            if ( silent > 0 )
              brhist_0 = 0;
            if ( lame_get_decode_only(v14) )
            {
              if ( mp3_delay_set )
                lame_decoder(v14, inited, mp3_delay, inPath, outPath, &enc_delay, &enc_padding);
              else
                lame_decoder(v14, inited, 0, inPath, outPath, &enc_delay, &enc_padding);
            }
            else if ( num_nogap <= 0 )
            {
              brhist_init_package(v14);
              v15 = lame_encoder(v14, inited, 0, inPath, outPath);
              fclose(inited);
              close_infile();
            }
            else
            {
              for ( i = 0; i < num_nogap; ++i )
              {
                v7 = num_nogap - 1 != i;
                if ( i > 0 )
                {
                  parse_nogap_filenames(v11, nogap_inPath[i], outPath, dest);
                  inited = init_files(v14, nogap_inPath[i], outPath, &enc_delay, &enc_padding);
                  lame_init_bitstream(v14);
                }
                brhist_init_package(v14);
                lame_set_nogap_total(v14, num_nogap);
                lame_set_nogap_currentindex(v14, i);
                v15 = lame_encoder(v14, inited, v7, nogap_inPath[i], outPath);
                fclose(inited);
                close_infile();
              }
            }
            lame_close(v14);
            frontend_close_console();
            return v15;
          }
          else
          {
            if ( i == -1 )
              display_bitrates(stderr);
            error_printf("fatal error during initialization\n");
            lame_close(v14);
            frontend_close_console();
            return i;
          }
        }
        else
        {
          lame_close(v14);
          frontend_close_console();
          return -1;
        }
      }
      else
      {
        lame_close(v14);
        frontend_close_console();
        return v15 != -2;
      }
    }
    else
    {
      usage(stderr, *argv);
      lame_close(v14);
      frontend_close_console();
      return 1;
    }
  }
  else
  {
    error_printf("fatal error during initialization\n");
    frontend_close_console();
    return 1;
  }
}
// 804A21C: using guessed type int __cdecl lame_set_debugf(_DWORD, _DWORD);
// 804A2AC: using guessed type int __cdecl lame_set_write_id3tag_automatic(_DWORD, _DWORD);
// 804A30C: using guessed type int __cdecl lame_get_decode_only(_DWORD);
// 804A3BC: using guessed type int __cdecl lame_close(_DWORD);
// 804A3CC: using guessed type int __cdecl lame_set_nogap_total(_DWORD, _DWORD);
// 804A44C: using guessed type int __cdecl lame_set_errorf(_DWORD, _DWORD);
// 804A45C: using guessed type int __cdecl lame_init_bitstream(_DWORD);
// 804A4FC: using guessed type int __cdecl lame_set_nogap_currentindex(_DWORD, _DWORD);
// 804A6BC: using guessed type int __cdecl lame_set_msgf(_DWORD, _DWORD);
// 804A7CC: using guessed type int __cdecl lame_init_params(_DWORD);
// 804A9CC: using guessed type int lame_init(void);

//----- (0804C6C0) --------------------------------------------------------
int __cdecl my_console_printing(FILE *fp, const char *format, va_list ap)
{
  if ( fp )
    return vfprintf(fp, format, ap);
  else
    return 0;
}

//----- (0804C6EE) --------------------------------------------------------
int __cdecl my_error_printing(FILE *fp, const char *format, va_list ap)
{
  if ( fp )
    return vfprintf(fp, format, ap);
  else
    return 0;
}

//----- (0804C71C) --------------------------------------------------------
int __cdecl my_report_printing(FILE *fp, const char *format, va_list ap)
{
  if ( fp )
    return vfprintf(fp, format, ap);
  else
    return 0;
}

//----- (0804C74A) --------------------------------------------------------
void __cdecl apply_termcap_settings(Console_IO_t *const mfp)
{
  int val; // [esp+24h] [ebp-824h]
  int vala; // [esp+24h] [ebp-824h]
  char *tp; // [esp+28h] [ebp-820h] BYREF
  const char *term_name; // [esp+2Ch] [ebp-81Ch]
  char term_buff[2048]; // [esp+32h] [ebp-816h] BYREF
  char tc[10]; // [esp+832h] [ebp-16h] BYREF
  unsigned int v7; // [esp+83Ch] [ebp-Ch]

  v7 = __readgsdword(0x14u);
  term_name = getenv("TERM");
  if ( term_name && tgetent(term_buff, term_name) == 1 )
  {
    val = tgetnum("co");
    if ( val > 39 && val <= 512 )
      mfp->disp_width = val;
    vala = tgetnum("li");
    if ( vala > 15 && vala <= 256 )
      mfp->disp_height = vala;
    tp = tc;
    tc[0] = 0;
    tp = tgetstr("up", &tp);
    if ( tp )
      strcpy(mfp->str_up, tp);
    tp = tc;
    tc[0] = 0;
    tp = tgetstr("ce", &tp);
    if ( tp )
      strcpy(mfp->str_clreoln, tp);
    tp = tc;
    tc[0] = 0;
    tp = tgetstr("md", &tp);
    if ( tp )
      strcpy(mfp->str_emph, tp);
    tp = tc;
    tc[0] = 0;
    tp = tgetstr("me", &tp);
    if ( tp )
      strcpy(mfp->str_norm, tp);
  }
}

//----- (0804C978) --------------------------------------------------------
int __cdecl init_console(Console_IO_t *const mfp)
{
  mfp->disp_width = 80;
  mfp->disp_height = 25;
  mfp->Console_fp = stderr;
  mfp->Error_fp = stderr;
  mfp->Report_fp = 0;
  setvbuf(mfp->Console_fp, mfp->Console_buff, 0, 0x800u);
  memcpy(mfp->str_up, "\x1B[A", 4u);
  apply_termcap_settings(mfp);
  mfp->ClassID = 1129270867;
  mfp->Console_file_type = 0;
  return 0;
}

//----- (0804CA23) --------------------------------------------------------
void __cdecl deinit_console(Console_IO_t *const mfp)
{
  if ( mfp->Report_fp )
  {
    fclose(mfp->Report_fp);
    mfp->Report_fp = 0;
  }
  fflush(mfp->Console_fp);
  setvbuf(mfp->Console_fp, 0, 2, 0);
  memset(mfp->Console_buff, 85, 0x400u);
}

//----- (0804CA9F) --------------------------------------------------------
int frontend_open_console()
{
  return init_console(&Console_IO);
}

//----- (0804CAB3) --------------------------------------------------------
void frontend_close_console()
{
  deinit_console(&Console_IO);
}

//----- (0804CAC7) --------------------------------------------------------
void __cdecl frontend_debugf(const char *format, va_list ap)
{
  my_report_printing(Console_IO.Report_fp, format, ap);
}

//----- (0804CAEA) --------------------------------------------------------
void __cdecl frontend_msgf(const char *format, va_list ap)
{
  my_console_printing(Console_IO.Console_fp, format, ap);
}

//----- (0804CB0D) --------------------------------------------------------
void __cdecl frontend_errorf(const char *format, va_list ap)
{
  my_error_printing(Console_IO.Error_fp, format, ap);
}

//----- (0804CB30) --------------------------------------------------------
int console_printf(const char *format, ...)
{
  va_list va; // [esp+34h] [ebp+Ch] BYREF

  va_start(va, format);
  return my_console_printing(Console_IO.Console_fp, format, va);
}

//----- (0804CB5F) --------------------------------------------------------
int error_printf(const char *format, ...)
{
  va_list va; // [esp+34h] [ebp+Ch] BYREF

  va_start(va, format);
  return my_console_printing(Console_IO.Error_fp, format, va);
}

//----- (0804CB8E) --------------------------------------------------------
int report_printf(const char *format, ...)
{
  va_list va; // [esp+34h] [ebp+Ch] BYREF

  va_start(va, format);
  return my_console_printing(Console_IO.Report_fp, format, va);
}

//----- (0804CBBD) --------------------------------------------------------
void console_flush()
{
  fflush(Console_IO.Console_fp);
}

//----- (0804CBD2) --------------------------------------------------------
void error_flush()
{
  fflush(Console_IO.Error_fp);
}

//----- (0804CBE7) --------------------------------------------------------
void report_flush()
{
  fflush(Console_IO.Report_fp);
}

//----- (0804CBFC) --------------------------------------------------------
void __cdecl console_up(int n_lines)
{
  while ( n_lines-- > 0 )
    fputs(Console_IO.str_up, Console_IO.Console_fp);
  console_flush();
}

//----- (0804CC31) --------------------------------------------------------
void __cdecl set_debug_file(const char *fn)
{
  if ( !Console_IO.Report_fp )
  {
    Console_IO.Report_fp = (FILE *)fopen64(fn, "a");
    if ( Console_IO.Report_fp )
      error_printf("writing debug info into: %s\n", fn);
    else
      error_printf("Error: can't open for debug info: %s\n", fn);
  }
}
// 804A26C: using guessed type int __cdecl fopen64(_DWORD, _DWORD);

//----- (0804CC8C) --------------------------------------------------------
size_t __cdecl min_size_t(size_t a, size_t b)
{
  if ( a >= b )
    return b;
  else
    return a;
}

//----- (0804CCA1) --------------------------------------------------------
ByteOrder machine_byte_order()
{
  return 0;
}

//----- (0804CCBE) --------------------------------------------------------
int __cdecl fskip(FILE *fp, int offset, int whence)
{
  stat file_stat; // [esp+28h] [ebp-1080h] BYREF
  size_t read_0; // [esp+88h] [ebp-1020h]
  size_t bytes_to_skip_0; // [esp+8Ch] [ebp-101Ch]
  size_t read; // [esp+90h] [ebp-1018h]
  size_t bytes_to_skip; // [esp+94h] [ebp-1014h]
  int fd; // [esp+98h] [ebp-1010h]
  char buffer[4096]; // [esp+9Ch] [ebp-100Ch] BYREF
  unsigned int v11; // [esp+109Ch] [ebp-Ch]

  v11 = __readgsdword(0x14u);
  fd = fileno(fp);
  if ( fstat64(fd, (int)&file_stat) || (file_stat.st_mode & 0xF000) != 4096 )
  {
    if ( fseek(fp, offset, whence) )
    {
      if ( whence == 1 && offset >= 0 )
      {
        while ( offset > 0 )
        {
          bytes_to_skip_0 = min_size_t(0x1000u, offset);
          read_0 = fread(buffer, 1u, bytes_to_skip_0, fp);
          if ( !read_0 )
            return -1;
          offset -= read_0;
        }
        return 0;
      }
      else
      {
        if ( silent <= 9 )
          error_printf(
            "fskip problem: Mostly the return status of functions is not evaluate so it is more secure to polute <stderr>.\n");
        return -1;
      }
    }
    else
    {
      return 0;
    }
  }
  else if ( whence == 1 && offset >= 0 )
  {
    while ( offset > 0 )
    {
      bytes_to_skip = min_size_t(0x1000u, offset);
      read = fread(buffer, 1u, bytes_to_skip, fp);
      if ( !read )
        return -1;
      offset -= read;
    }
    return 0;
  }
  else
  {
    return -1;
  }
}

//----- (0804CE8D) --------------------------------------------------------
FILE *__cdecl init_outfile(char *outPath, int decode)
{
  FILE *outf; // [esp+1Ch] [ebp-Ch]

  if ( !strcmp(outPath, "-") )
  {
    outf = stdout;
    lame_set_stream_binary_mode(stdout);
  }
  else
  {
    outf = (FILE *)fopen64(outPath, "w+b");
    if ( !outf )
      return 0;
  }
  return outf;
}
// 804A26C: using guessed type int __cdecl fopen64(_DWORD, _DWORD);

//----- (0804CEE8) --------------------------------------------------------
void __cdecl init_infile(lame_global_flags *gfp, char *inPath, int *enc_delay, int *enc_padding)
{
  global.count_samples_carefully = 0;
  global.num_samples_read = 0;
  global.pcmbitwidth = in_bitwidth;
  global.pcmswapbytes = swapbytes;
  global.pcm_is_unsigned_8bit = in_signed != 1;
  global.musicin = OpenSndFile(gfp, inPath, enc_delay, enc_padding);
}

//----- (0804CF50) --------------------------------------------------------
void close_infile()
{
  CloseSndFile(input_format, global.musicin);
}

//----- (0804CF6F) --------------------------------------------------------
void __cdecl SwapBytesInWords(__int16 *ptr, int short_words)
{
  __int16 *ptra; // [esp+18h] [ebp+8h]

  while ( short_words > 1 )
  {
    *(_DWORD *)ptr = (*(_DWORD *)ptr >> 8) & 0xFF00FF | (*(_DWORD *)ptr << 8) & 0xFF00FF00;
    short_words -= 2;
    ptr += 2;
  }
  ptra = ptr;
  while ( short_words > 0 )
  {
    *ptra = (*ptra << 8) | (unsigned __int8)HIBYTE(*ptra);
    --short_words;
    ++ptra;
  }
}

//----- (0804CFF1) --------------------------------------------------------
int __cdecl get_audio(lame_global_flags *const gfp, int (*buffer)[1152])
{
  return get_audio_common(gfp, buffer, 0);
}

//----- (0804D013) --------------------------------------------------------
int __cdecl get_audio16(lame_global_flags *const gfp, __int16 (*buffer)[1152])
{
  return get_audio_common(gfp, 0, buffer);
}

//----- (0804D035) --------------------------------------------------------
int __cdecl get_audio_common(lame_global_flags *const gfp, int (*buffer)[1152], __int16 (*buffer16)[1152])
{
  unsigned int num_samples_read; // eax
  int insamp[2304]; // [esp+10h] [ebp-3628h] BYREF
  __int16 buf_tmp16[2][1152]; // [esp+2410h] [ebp-1228h] BYREF
  int *p; // [esp+3610h] [ebp-28h]
  int i; // [esp+3614h] [ebp-24h]
  unsigned int tmp_num_samples; // [esp+3618h] [ebp-20h]
  unsigned int remaining; // [esp+361Ch] [ebp-1Ch]
  int samples_to_read; // [esp+3620h] [ebp-18h]
  int framesize; // [esp+3624h] [ebp-14h]
  int samples_read; // [esp+3628h] [ebp-10h]
  int num_channels; // [esp+362Ch] [ebp-Ch]

  num_channels = lame_get_num_channels(gfp);
  framesize = lame_get_framesize(gfp);
  samples_to_read = framesize;
  tmp_num_samples = lame_get_num_samples(gfp);
  if ( global.count_samples_carefully )
  {
    num_samples_read = tmp_num_samples;
    if ( global.num_samples_read <= tmp_num_samples )
      num_samples_read = global.num_samples_read;
    remaining = tmp_num_samples - num_samples_read;
    if ( framesize > tmp_num_samples - num_samples_read && tmp_num_samples )
      samples_to_read = remaining;
  }
  if ( is_mpeg_file_format(input_format) )
  {
    if ( buffer )
      samples_read = read_samples_mp3(gfp, global.musicin, buf_tmp16);
    else
      samples_read = read_samples_mp3(gfp, global.musicin, buffer16);
    if ( samples_read < 0 )
      return samples_read;
  }
  else
  {
    samples_read = read_samples_pcm(global.musicin, insamp, samples_to_read * num_channels);
    if ( samples_read < 0 )
      return samples_read;
    p = &insamp[samples_read];
    samples_read /= num_channels;
    if ( buffer )
    {
      if ( num_channels == 2 )
      {
        for ( i = samples_read; --i >= 0; (*buffer)[i] = *p )
        {
          (*buffer)[i + 1152] = *--p;
          --p;
        }
      }
      else if ( num_channels == 1 )
      {
        memset(&(*buffer)[1152], 0, 4 * samples_read);
        for ( i = samples_read; --i >= 0; (*buffer)[i] = *p )
          --p;
      }
    }
    else if ( num_channels == 2 )
    {
      for ( i = samples_read; --i >= 0; (*buffer16)[i] = HIWORD(*p) )
      {
        (*buffer16)[i + 1152] = HIWORD(*--p);
        --p;
      }
    }
    else if ( num_channels == 1 )
    {
      memset(&(*buffer16)[1152], 0, 2 * samples_read);
      for ( i = samples_read; --i >= 0; (*buffer16)[i] = HIWORD(*p) )
        --p;
    }
  }
  if ( is_mpeg_file_format(input_format) && buffer )
  {
    for ( i = samples_read; --i >= 0; (*buffer)[i] = buf_tmp16[0][i] << 16 )
      ;
    if ( num_channels == 2 )
    {
      for ( i = samples_read; --i >= 0; (*buffer)[i + 1152] = buf_tmp16[1][i] << 16 )
        ;
    }
    else if ( num_channels == 1 )
    {
      memset(&(*buffer)[1152], 0, 4 * samples_read);
    }
  }
  if ( tmp_num_samples != -1 )
    global.num_samples_read += samples_read;
  return samples_read;
}
// 804A20C: using guessed type int __cdecl lame_get_num_samples(_DWORD);
// 804A5FC: using guessed type int __cdecl lame_get_framesize(_DWORD);
// 804A75C: using guessed type int __cdecl lame_get_num_channels(_DWORD);

//----- (0804D384) --------------------------------------------------------
int __cdecl read_samples_mp3(lame_global_flags *const gfp, FILE *const musicin, __int16 (*mpg123pcm)[1152])
{
  int out; // [esp+1Ch] [ebp-Ch]

  out = lame_decode_fromfile(musicin, (__int16 *)mpg123pcm, &(*mpg123pcm)[1152], &mp3input_data);
  if ( out >= 0 )
  {
    if ( lame_get_num_channels(gfp) != mp3input_data.stereo )
    {
      if ( silent <= 9 )
        error_printf("Error: number of channels has changed in %s - not supported\n", "MP3 file");
      out = -1;
    }
    if ( lame_get_in_samplerate(gfp) != mp3input_data.samplerate )
    {
      if ( silent <= 9 )
        error_printf("Error: sample frequency has changed in %s - not supported\n", "MP3 file");
      return -1;
    }
    return out;
  }
  else
  {
    memset(mpg123pcm, 0, 0x1200u);
    return 0;
  }
}
// 804A06C: using guessed type int __cdecl lame_get_in_samplerate(_DWORD);
// 804A75C: using guessed type int __cdecl lame_get_num_channels(_DWORD);

//----- (0804D455) --------------------------------------------------------
int __cdecl WriteWaveHeader(FILE *const fp, const int pcmbytes, const int freq, const int channels, const int bits)
{
  int v5; // eax
  int bytes; // [esp+1Ch] [ebp-Ch]

  v5 = bits + 7;
  if ( bits + 7 < 0 )
    v5 = bits + 14;
  bytes = v5 >> 3;
  fwrite("RIFF", 1u, 4u, fp);
  Write32BitsLowHigh(fp, pcmbytes + 36);
  fwrite("WAVEfmt ", 2u, 4u, fp);
  Write32BitsLowHigh(fp, 16);
  Write16BitsLowHigh(fp, 1);
  Write16BitsLowHigh(fp, channels);
  Write32BitsLowHigh(fp, freq);
  Write32BitsLowHigh(fp, bytes * channels * freq);
  Write16BitsLowHigh(fp, bytes * channels);
  Write16BitsLowHigh(fp, bits);
  fwrite("data", 1u, 4u, fp);
  Write32BitsLowHigh(fp, pcmbytes);
  if ( ferror(fp) )
    return -1;
  else
    return 0;
}

//----- (0804D5A8) --------------------------------------------------------
int __cdecl unpack_read_samples(
        const int samples_to_read,
        const int bytes_per_sample,
        const int swap_order,
        int *sample_buffer,
        FILE *pcm_in)
{
  int *op; // [esp+24h] [ebp-14h]
  int i; // [esp+28h] [ebp-10h]
  int ia; // [esp+28h] [ebp-10h]
  int ib; // [esp+28h] [ebp-10h]
  int ic; // [esp+28h] [ebp-10h]
  int id; // [esp+28h] [ebp-10h]
  int ie; // [esp+28h] [ebp-10h]
  int ig; // [esp+28h] [ebp-10h]
  int ih; // [esp+28h] [ebp-10h]
  int samples_read; // [esp+2Ch] [ebp-Ch]

  samples_read = fread(sample_buffer, bytes_per_sample, samples_to_read, pcm_in);
  op = &sample_buffer[samples_read];
  if ( swap_order )
  {
    if ( bytes_per_sample == 1 )
    {
      for ( id = samples_read; --id >= 0; *op = ((*((_BYTE *)sample_buffer + id) ^ 0x80) << 24) | 0x7F0000 )
        --op;
    }
    if ( bytes_per_sample == 2 )
    {
      for ( ie = 2 * samples_read;
            ;
            *op = (*((unsigned __int8 *)sample_buffer + ie + 1) << 16) | (*((unsigned __int8 *)sample_buffer + ie) << 24) )
      {
        ie -= 2;
        if ( ie < 0 )
          break;
        --op;
      }
    }
    if ( bytes_per_sample == 3 )
    {
      for ( ig = 3 * samples_read;
            ;
            *op = (*((unsigned __int8 *)sample_buffer + ig + 2) << 8) | (*((unsigned __int8 *)sample_buffer + ig + 1) << 16) | (*((unsigned __int8 *)sample_buffer + ig) << 24) )
      {
        ig -= 3;
        if ( ig < 0 )
          break;
        --op;
      }
    }
    if ( bytes_per_sample == 4 )
    {
      for ( ih = samples_read;
            --ih >= 0;
            *op = HIBYTE(sample_buffer[ih]) | (BYTE2(sample_buffer[ih]) << 8) | (BYTE1(sample_buffer[ih]) << 16) | (LOBYTE(sample_buffer[ih]) << 24) )
      {
        --op;
      }
    }
  }
  else
  {
    if ( bytes_per_sample == 1 )
    {
      for ( i = samples_read; --i >= 0; *op = *((unsigned __int8 *)sample_buffer + i) << 24 )
        --op;
    }
    if ( bytes_per_sample == 2 )
    {
      for ( ia = 2 * samples_read;
            ;
            *op = (*((unsigned __int8 *)sample_buffer + ia + 1) << 24) | (*((unsigned __int8 *)sample_buffer + ia) << 16) )
      {
        ia -= 2;
        if ( ia < 0 )
          break;
        --op;
      }
    }
    if ( bytes_per_sample == 3 )
    {
      for ( ib = 3 * samples_read;
            ;
            *op = (*((unsigned __int8 *)sample_buffer + ib + 2) << 24) | (*((unsigned __int8 *)sample_buffer + ib + 1) << 16) | (*((unsigned __int8 *)sample_buffer + ib) << 8) )
      {
        ib -= 3;
        if ( ib < 0 )
          break;
        --op;
      }
    }
    if ( bytes_per_sample == 4 )
    {
      for ( ic = samples_read;
            --ic >= 0;
            *op = (HIBYTE(sample_buffer[ic]) << 24) | (BYTE2(sample_buffer[ic]) << 16) | (BYTE1(sample_buffer[ic]) << 8) | LOBYTE(sample_buffer[ic]) )
      {
        --op;
      }
    }
  }
  return samples_read;
}

//----- (0804D9AB) --------------------------------------------------------
int __cdecl read_samples_pcm(FILE *musicin, int *sample_buffer, int samples_to_read)
{
  int swap_byte_order; // [esp+28h] [ebp-10h]
  int samples_read; // [esp+2Ch] [ebp-Ch]

  if ( global.pcmbitwidth == 16 )
  {
LABEL_7:
    if ( !in_signed )
    {
      error_printf("Unsigned input only supported with bitwidth 8\n");
      exit(1);
    }
    swap_byte_order = in_endian != ByteOrderLittleEndian;
    if ( global.pcmswapbytes )
      swap_byte_order = in_endian == ByteOrderLittleEndian;
    samples_read = unpack_read_samples(samples_to_read, global.pcmbitwidth / 8, swap_byte_order, sample_buffer, musicin);
    goto LABEL_16;
  }
  if ( global.pcmbitwidth > 16 )
  {
    if ( global.pcmbitwidth != 24 && global.pcmbitwidth != 32 )
      goto LABEL_13;
    goto LABEL_7;
  }
  if ( global.pcmbitwidth != 8 )
  {
LABEL_13:
    if ( silent <= 9 )
      error_printf("Only 8, 16, 24 and 32 bit input files supported \n");
    exit(1);
  }
  samples_read = unpack_read_samples(samples_to_read, 1, global.pcm_is_unsigned_8bit, sample_buffer, musicin);
LABEL_16:
  if ( ferror(musicin) )
  {
    if ( silent <= 9 )
      error_printf("Error reading input file\n");
    exit(1);
  }
  return samples_read;
}

//----- (0804DAE3) --------------------------------------------------------
int __cdecl parse_wave_header(lame_global_flags *gfp, FILE *sf_0)
{
  int v3; // eax
  int v4; // [esp+4h] [ebp-54h]
  int type; // [esp+20h] [ebp-38h]
  int loop_sanity; // [esp+24h] [ebp-34h]
  int subSize; // [esp+28h] [ebp-30h]
  int subSizea; // [esp+28h] [ebp-30h]
  int data_length; // [esp+30h] [ebp-28h]
  int is_wav; // [esp+34h] [ebp-24h]
  int samples_per_sec; // [esp+3Ch] [ebp-1Ch]
  int bits_per_sample; // [esp+40h] [ebp-18h]
  int channels; // [esp+48h] [ebp-10h]
  int format_tag; // [esp+4Ch] [ebp-Ch]

  format_tag = 0;
  channels = 0;
  bits_per_sample = 0;
  samples_per_sec = 0;
  is_wav = 0;
  data_length = 0;
  Read32BitsHighLow(sf_0);
  if ( Read32BitsHighLow(sf_0) != WAV_ID_WAVE )
    return -1;
  for ( loop_sanity = 0; loop_sanity <= 19; ++loop_sanity )
  {
    type = Read32BitsHighLow(sf_0);
    if ( type == WAV_ID_FMT )
    {
      subSize = Read32Bits(sf_0);
      if ( subSize <= 15 )
        return -1;
      format_tag = Read16BitsLowHigh(sf_0);
      channels = Read16BitsLowHigh(sf_0);
      samples_per_sec = Read32Bits(sf_0);
      Read32Bits(sf_0);
      Read16BitsLowHigh(sf_0);
      bits_per_sample = Read16BitsLowHigh(sf_0);
      subSizea = subSize - 16;
      if ( subSizea > 9 && WAVE_FORMAT_EXTENSIBLE == format_tag )
      {
        Read16BitsLowHigh(sf_0);
        Read16BitsLowHigh(sf_0);
        Read32Bits(sf_0);
        format_tag = Read16BitsLowHigh(sf_0);
        subSizea -= 10;
      }
      if ( subSizea > 0 && fskip(sf_0, subSizea, 1) )
        return -1;
    }
    else
    {
      if ( type == WAV_ID_DATA )
      {
        data_length = Read32Bits(sf_0);
        is_wav = 1;
        break;
      }
      v4 = Read32Bits(sf_0);
      if ( fskip(sf_0, v4, 1) )
        return -1;
    }
  }
  if ( !is_wav )
    return -1;
  if ( WAVE_FORMAT_PCM == format_tag )
  {
    if ( lame_set_num_channels(gfp, channels) == -1 )
    {
      if ( silent <= 9 )
        error_printf("Unsupported number of channels: %u\n", channels);
      return 0;
    }
    else
    {
      lame_set_in_samplerate(gfp, samples_per_sec);
      global.pcmbitwidth = bits_per_sample;
      global.pcm_is_unsigned_8bit = 1;
      v3 = bits_per_sample + 7;
      if ( bits_per_sample + 7 < 0 )
        v3 = bits_per_sample + 14;
      lame_set_num_samples(gfp, data_length / (channels * (v3 >> 3)));
      return 1;
    }
  }
  else
  {
    if ( silent <= 9 )
      error_printf("Unsupported data format: 0x%04X\n", format_tag);
    return 0;
  }
}
// 804A0BC: using guessed type int __cdecl lame_set_num_channels(_DWORD, _DWORD);
// 804A87C: using guessed type int __cdecl lame_set_num_samples(_DWORD, _DWORD);
// 804A93C: using guessed type int __cdecl lame_set_in_samplerate(_DWORD, _DWORD);

//----- (0804DDD0) --------------------------------------------------------
int __cdecl aiff_check2(IFF_AIFF *const pcm_aiff_data)
{
  unsigned int v2; // eax

  if ( pcm_aiff_data->sampleType == IFF_ID_SSND )
  {
    v2 = pcm_aiff_data->sampleSize - 8;
    if ( v2 <= 0x18 && ((1 << v2) & 0x1010101) != 0 )
    {
      if ( pcm_aiff_data->numChannels == 1 || pcm_aiff_data->numChannels == 2 )
      {
        if ( pcm_aiff_data->blkAlgn.blockSize )
        {
          if ( silent <= 9 )
            error_printf("ERROR: block size of input sound data is not 0 bytes\n");
          return 1;
        }
        else
        {
          return 0;
        }
      }
      else
      {
        if ( silent <= 9 )
          error_printf("ERROR: input sound data is not mono or stereo\n");
        return 1;
      }
    }
    else
    {
      if ( silent <= 9 )
        error_printf("ERROR: input sound data is not 8, 16, 24 or 32 bits\n");
      return 1;
    }
  }
  else
  {
    if ( silent <= 9 )
      error_printf("ERROR: input sound data is not PCM\n");
    return 1;
  }
}

//----- (0804DEB2) --------------------------------------------------------
int __cdecl make_even_number_of_bytes_in_length(int x)
{
  if ( (x & 1) != 0 )
    return x + 1;
  else
    return x;
}

//----- (0804DECC) --------------------------------------------------------
int __cdecl parse_aiff_header(lame_global_flags *gfp, FILE *sf_0)
{
  IFF_AIFF aiff_info; // [esp+2Ch] [ebp-4Ch] BYREF
  int type; // [esp+4Ch] [ebp-2Ch]
  int ckSize; // [esp+50h] [ebp-28h]
  int pcm_data_pos; // [esp+54h] [ebp-24h]
  int seen_ssnd_chunk; // [esp+58h] [ebp-20h]
  int seen_comm_chunk; // [esp+5Ch] [ebp-1Ch]
  int dataType; // [esp+60h] [ebp-18h]
  int typeID; // [esp+64h] [ebp-14h]
  int subSize; // [esp+68h] [ebp-10h]
  int chunkSize; // [esp+6Ch] [ebp-Ch]

  chunkSize = 0;
  subSize = 0;
  typeID = 0;
  dataType = IFF_ID_NONE;
  seen_comm_chunk = 0;
  seen_ssnd_chunk = 0;
  pcm_data_pos = -1;
  memset(&aiff_info, 0, sizeof(aiff_info));
  chunkSize = Read32BitsHighLow(sf_0);
  typeID = Read32BitsHighLow(sf_0);
  if ( typeID != IFF_ID_AIFF && typeID != IFF_ID_AIFC )
    return -1;
  while ( chunkSize > 0 )
  {
    type = Read32BitsHighLow(sf_0);
    chunkSize -= 4;
    if ( type == IFF_ID_COMM )
    {
      seen_comm_chunk = seen_ssnd_chunk + 1;
      subSize = Read32BitsHighLow(sf_0);
      ckSize = make_even_number_of_bytes_in_length(subSize);
      chunkSize -= ckSize;
      aiff_info.numChannels = Read16BitsHighLow(sf_0);
      ckSize -= 2;
      aiff_info.numSampleFrames = Read32BitsHighLow(sf_0);
      ckSize -= 4;
      aiff_info.sampleSize = Read16BitsHighLow(sf_0);
      ckSize -= 2;
      aiff_info.sampleRate = ReadIeeeExtendedHighLow(sf_0);
      ckSize -= 10;
      if ( typeID == IFF_ID_AIFC )
      {
        dataType = Read32BitsHighLow(sf_0);
        ckSize -= 4;
      }
      if ( fskip(sf_0, ckSize, 1) )
        return -1;
    }
    else if ( type == IFF_ID_SSND )
    {
      seen_ssnd_chunk = 1;
      subSize = Read32BitsHighLow(sf_0);
      ckSize = make_even_number_of_bytes_in_length(subSize);
      chunkSize -= ckSize;
      aiff_info.blkAlgn.offset = Read32BitsHighLow(sf_0);
      ckSize -= 4;
      aiff_info.blkAlgn.blockSize = Read32BitsHighLow(sf_0);
      ckSize -= 4;
      aiff_info.sampleType = IFF_ID_SSND;
      if ( seen_comm_chunk > 0 )
      {
        if ( fskip(sf_0, aiff_info.blkAlgn.offset, 1) )
          return -1;
        break;
      }
      pcm_data_pos = ftell(sf_0);
      if ( pcm_data_pos >= 0 )
        pcm_data_pos += aiff_info.blkAlgn.offset;
      if ( fskip(sf_0, ckSize, 1) )
        return -1;
    }
    else
    {
      subSize = Read32BitsHighLow(sf_0);
      ckSize = make_even_number_of_bytes_in_length(subSize);
      chunkSize -= ckSize;
      if ( fskip(sf_0, ckSize, 1) )
        return -1;
    }
  }
  if ( dataType == IFF_ID_2CLE )
  {
    global.pcmswapbytes = swapbytes;
  }
  else if ( dataType == IFF_ID_2CBE )
  {
    global.pcmswapbytes = swapbytes == 0;
  }
  else
  {
    if ( dataType != IFF_ID_NONE )
      return -1;
    global.pcmswapbytes = swapbytes == 0;
  }
  if ( !seen_comm_chunk || seen_ssnd_chunk <= 0 && aiff_info.numSampleFrames )
    return -1;
  if ( aiff_check2(&aiff_info) )
    return 0;
  if ( lame_set_num_channels(gfp, aiff_info.numChannels) == -1 )
  {
    if ( silent <= 9 )
      error_printf("Unsupported number of channels: %u\n", aiff_info.numChannels);
    return 0;
  }
  else
  {
    lame_set_in_samplerate(gfp, (int)aiff_info.sampleRate);
    lame_set_num_samples(gfp, aiff_info.numSampleFrames);
    global.pcmbitwidth = aiff_info.sampleSize;
    global.pcm_is_unsigned_8bit = 0;
    if ( pcm_data_pos >= 0 && fseek(sf_0, pcm_data_pos, 0) )
    {
      if ( silent <= 9 )
        error_printf("Can't rewind stream to audio data position\n");
      return 0;
    }
    else
    {
      return 1;
    }
  }
}
// 804A0BC: using guessed type int __cdecl lame_set_num_channels(_DWORD, _DWORD);
// 804A87C: using guessed type int __cdecl lame_set_num_samples(_DWORD, _DWORD);
// 804A93C: using guessed type int __cdecl lame_set_in_samplerate(_DWORD, _DWORD);

//----- (0804E2E4) --------------------------------------------------------
int __cdecl parse_file_header(lame_global_flags *gfp, FILE *sf_0)
{
  int ret_0; // [esp+14h] [ebp-14h]
  int ret; // [esp+18h] [ebp-10h]
  int type; // [esp+1Ch] [ebp-Ch]

  type = Read32BitsHighLow(sf_0);
  global.count_samples_carefully = 0;
  global.pcm_is_unsigned_8bit = in_signed != 1;
  if ( type == WAV_ID_RIFF )
  {
    ret = parse_wave_header(gfp, sf_0);
    if ( ret > 0 )
    {
      global.count_samples_carefully = 1;
      return 2;
    }
    if ( ret < 0 && silent <= 9 )
      error_printf("Warning: corrupt or unsupported WAVE format\n");
  }
  else if ( type == IFF_ID_FORM )
  {
    ret_0 = parse_aiff_header(gfp, sf_0);
    if ( ret_0 > 0 )
    {
      global.count_samples_carefully = 1;
      return 3;
    }
    if ( ret_0 < 0 && silent <= 9 )
      error_printf("Warning: corrupt or unsupported AIFF format\n");
  }
  else if ( silent <= 9 )
  {
    error_printf("Warning: unsupported audio format\n");
  }
  return 0;
}

//----- (0804E3E1) --------------------------------------------------------
void __cdecl CloseSndFile(sound_file_format input, FILE *musicin)
{
  if ( fclose(musicin) )
  {
    if ( silent <= 9 )
      error_printf("Could not close audio input file\n");
    exit(2);
  }
}

//----- (0804E41A) --------------------------------------------------------
FILE *__cdecl OpenSndFile(lame_global_flags *gfp, char *inPath, int *enc_delay, int *enc_padding)
{
  long double v4; // fst7
  long double v5; // fst7
  double totalseconds; // [esp+28h] [ebp-20h]
  double flen; // [esp+30h] [ebp-18h]
  FILE *musicin; // [esp+3Ch] [ebp-Ch]

  lame_set_num_samples(gfp, -1);
  if ( !strcmp(inPath, "-") )
  {
    musicin = (FILE *)stdin;
    lame_set_stream_binary_mode((FILE *const)stdin);
  }
  else
  {
    musicin = (FILE *)fopen64(inPath, "rb");
    if ( !musicin )
    {
      if ( silent <= 9 )
        error_printf("Could not find \"%s\".\n", inPath);
      exit(1);
    }
  }
  if ( is_mpeg_file_format(input_format) )
  {
    if ( lame_decode_initfile(musicin, &mp3input_data, enc_delay, enc_padding) == -1 )
    {
      if ( silent <= 9 )
        error_printf("Error reading headers in mp3 input file %s.\n", inPath);
      exit(1);
    }
    if ( lame_set_num_channels(gfp, mp3input_data.stereo) == -1 )
    {
      if ( silent <= 9 )
        error_printf("Unsupported number of channels: %ud\n", mp3input_data.stereo);
      exit(1);
    }
    lame_set_in_samplerate(gfp, mp3input_data.samplerate);
    lame_set_num_samples(gfp, mp3input_data.nsamp);
  }
  else
  {
    if ( input_format == sf_ogg )
    {
      if ( silent <= 9 )
        error_printf("sorry, vorbis support in LAME is deprecated.\n");
      exit(1);
    }
    if ( input_format == sf_raw )
    {
      if ( silent <= 9 )
      {
        console_printf("Assuming raw pcm input file");
        if ( swapbytes )
          console_printf(" : Forcing byte-swapping\n");
        else
          console_printf("\n");
      }
      global.pcmswapbytes = swapbytes;
    }
    else
    {
      input_format = parse_file_header(gfp, musicin);
    }
  }
  if ( input_format == sf_unknown )
    exit(1);
  if ( lame_get_num_samples(gfp) == -1 && musicin != (FILE *)stdin )
  {
    flen = (double)lame_get_file_size(inPath);
    if ( flen >= 0.0 )
    {
      if ( is_mpeg_file_format(input_format) )
      {
        if ( mp3input_data.bitrate > 0 )
        {
          totalseconds = flen * 8.0 / ((long double)mp3input_data.bitrate * 1000.0);
          v4 = (long double)lame_get_in_samplerate(gfp) * totalseconds;
          lame_set_num_samples(gfp, (__int64)v4);
          mp3input_data.nsamp = (__int64)v4;
        }
      }
      else
      {
        v5 = flen / (long double)(2 * lame_get_num_channels(gfp));
        lame_set_num_samples(gfp, (__int64)v5);
      }
    }
  }
  return musicin;
}
// 804A06C: using guessed type int __cdecl lame_get_in_samplerate(_DWORD);
// 804A0BC: using guessed type int __cdecl lame_set_num_channels(_DWORD, _DWORD);
// 804A20C: using guessed type int __cdecl lame_get_num_samples(_DWORD);
// 804A26C: using guessed type int __cdecl fopen64(_DWORD, _DWORD);
// 804A75C: using guessed type int __cdecl lame_get_num_channels(_DWORD);
// 804A87C: using guessed type int __cdecl lame_set_num_samples(_DWORD, _DWORD);
// 804A93C: using guessed type int __cdecl lame_set_in_samplerate(_DWORD, _DWORD);
// 805B3A4: using guessed type int stdin;

//----- (0804E748) --------------------------------------------------------
int __cdecl check_aid(const unsigned __int8 *header)
{
  return memcmp(header, &unk_805540A, 4u) == 0;
}

//----- (0804E773) --------------------------------------------------------
int __cdecl is_syncword_mp123(const void *const headerptr)
{
  int v2; // eax

  if ( *(_BYTE *)headerptr != 0xFF )
    return 0;
  if ( (*((_BYTE *)headerptr + 1) & 0xE0) != 224 )
    return 0;
  if ( (*((_BYTE *)headerptr + 1) & 0x18) == 8 )
    return 0;
  v2 = *((_BYTE *)headerptr + 1) & 6;
  switch ( v2 )
  {
    case 4:
      if ( input_format != sf_mp2 && input_format != sf_mp123 )
        return 0;
      input_format = sf_mp2;
      break;
    case 6:
      if ( input_format != sf_mp1 && input_format != sf_mp123 )
        return 0;
      input_format = sf_mp1;
      break;
    case 2:
      if ( input_format != sf_mp3 && input_format != sf_mp123 )
        return 0;
      input_format = sf_mp3;
      break;
    default:
      return 0;
  }
  if ( (*((_BYTE *)headerptr + 1) & 6) == 0 )
    return 0;
  if ( (*((_BYTE *)headerptr + 2) & 0xF0) == 240 )
    return 0;
  if ( (*((_BYTE *)headerptr + 2) & 0xC) == 12 )
    return 0;
  if ( (*((_BYTE *)headerptr + 1) & 0x18) == 24
    && (*((_BYTE *)headerptr + 1) & 6) == 4
    && ((abl2_5481[*((_BYTE *)headerptr + 2) >> 4] >> (*((_BYTE *)headerptr + 3) >> 6)) & 1) != 0 )
  {
    return 0;
  }
  return (*((_BYTE *)headerptr + 3) & 3) != 2;
}

//----- (0804E961) --------------------------------------------------------
int __cdecl lame_decode_initfile(FILE *fd, mp3data_struct *mp3data, int *enc_delay, int *enc_padding)
{
  __int16 pcm_r[1152]; // [esp+34h] [ebp-1284h] BYREF
  __int16 pcm_l[1152]; // [esp+934h] [ebp-984h] BYREF
  unsigned int i; // [esp+1234h] [ebp-84h]
  int freeformat; // [esp+1238h] [ebp-80h]
  int aid_header; // [esp+123Ch] [ebp-7Ch]
  size_t len; // [esp+1240h] [ebp-78h]
  int ret; // [esp+1244h] [ebp-74h]
  unsigned __int8 buf[100]; // [esp+1248h] [ebp-70h] BYREF
  unsigned int v13; // [esp+12ACh] [ebp-Ch]

  v13 = __readgsdword(0x14u);
  freeformat = 0;
  memset(mp3data, 0, sizeof(mp3data_struct));
  if ( global.hip )
    hip_decode_exit(global.hip);
  global.hip = (hip_t)hip_decode_init();
  len = 4;
  if ( fread(buf, 1u, 4u, fd) != 4 )
    return -1;
  if ( buf[0] == 73 && buf[1] == 68 && buf[2] == 51 )
  {
    if ( silent <= 9 )
      console_printf("ID3v2 found. Be aware that the ID3 tag is currently lost when transcoding.\n");
    if ( fread(buf, 1u, 6u, fd) != 6 )
      return -1;
    buf[2] &= ~0x80u;
    buf[3] &= ~0x80u;
    buf[4] &= ~0x80u;
    buf[5] &= ~0x80u;
    fskip(fd, (((((buf[2] << 7) + buf[3]) << 7) + buf[4]) << 7) + buf[5], 1);
    len = 4;
    if ( fread(buf, 1u, 4u, fd) != 4 )
      return -1;
  }
  aid_header = check_aid(buf);
  if ( !aid_header )
    goto LABEL_21;
  if ( fread(buf, 1u, 2u, fd) != 2 )
    return -1;
  aid_header = (buf[1] << 8) + buf[0];
  if ( silent <= 9 )
    console_printf("Album ID found.  length=%i \n", aid_header);
  fskip(fd, aid_header - 6, 1);
  if ( fread(buf, 1u, len, fd) != len )
    return -1;
LABEL_21:
  len = 4;
  while ( !is_syncword_mp123(buf) )
  {
    for ( i = 0; len - 1 > i; ++i )
      buf[i] = buf[i + 1];
    if ( fread(&buf[len - 1], 1u, 1u, fd) != 1 )
      return -1;
  }
  if ( (buf[2] & 0xF0) == 0 )
  {
    if ( silent <= 9 )
      console_printf("Input file is freeformat.\n");
    freeformat = 1;
  }
  ret = hip_decode1_headersB(global.hip, buf, len, pcm_l, pcm_r, mp3data, enc_delay, enc_padding);
  if ( ret == -1 )
    return -1;
  while ( !mp3data->header_parsed )
  {
    len = fread(buf, 1u, 0x64u, fd);
    if ( len != 100 )
      return -1;
    ret = hip_decode1_headersB(global.hip, buf, 100, pcm_l, pcm_r, mp3data, enc_delay, enc_padding);
    if ( ret == -1 )
      return -1;
  }
  if ( mp3data->bitrate || freeformat )
  {
    if ( mp3data->totalframes <= 0 )
      mp3data->nsamp = -1;
    return 0;
  }
  else
  {
    if ( silent <= 9 )
      error_printf("fail to sync...\n");
    return lame_decode_initfile(fd, mp3data, enc_delay, enc_padding);
  }
}
// 804A76C: using guessed type int hip_decode_init(void);
// 804A8CC: using guessed type int __cdecl hip_decode_exit(_DWORD);
// 804AA2C: using guessed type int __cdecl hip_decode1_headersB(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0804EE68) --------------------------------------------------------
int __cdecl lame_decode_fromfile(FILE *fd, __int16 *pcm_l, __int16 *pcm_r, mp3data_struct *mp3data)
{
  size_t len; // [esp+34h] [ebp-414h]
  int ret; // [esp+38h] [ebp-410h]
  int reta; // [esp+38h] [ebp-410h]
  unsigned __int8 buf[1024]; // [esp+3Ch] [ebp-40Ch] BYREF
  unsigned int v9; // [esp+43Ch] [ebp-Ch]

  v9 = __readgsdword(0x14u);
  ret = hip_decode1_headers(global.hip, buf, 0, pcm_l, pcm_r, mp3data);
  if ( ret )
    return ret;
  while ( 1 )
  {
    len = fread(buf, 1u, 0x400u, fd);
    if ( !len )
      break;
    reta = hip_decode1_headers(global.hip, buf, len, pcm_l, pcm_r, mp3data);
    if ( reta == -1 )
      goto LABEL_5;
    if ( reta > 0 )
      return reta;
  }
  reta = hip_decode1_headers(global.hip, buf, 0, pcm_l, pcm_r, mp3data);
  if ( reta <= 0 )
  {
LABEL_5:
    hip_decode_exit(global.hip);
    global.hip = 0;
    return -1;
  }
  return reta;
}
// 804A3AC: using guessed type int __cdecl hip_decode1_headers(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 804A8CC: using guessed type int __cdecl hip_decode_exit(_DWORD);

//----- (0804F04D) --------------------------------------------------------
int __cdecl is_mpeg_file_format(int input_file_format)
{
  if ( input_file_format == 5 )
    return 2;
  if ( input_file_format > 5 )
  {
    if ( input_file_format == 6 )
      return 3;
    if ( input_file_format == 7 )
      return -1;
  }
  else if ( input_file_format == 4 )
  {
    return 1;
  }
  return 0;
}

//----- (0804F094) --------------------------------------------------------
long double GetCPUTime()
{
  return (long double)clock() / 1000000.0;
}

//----- (0804F0AF) --------------------------------------------------------
long double GetRealTime()
{
  timeval t; // [esp+28h] [ebp-10h] BYREF

  gettimeofday(&t, 0);
  return (long double)t.tv_sec + (long double)t.tv_usec * 0.000001;
}

//----- (0804F0E6) --------------------------------------------------------
int __cdecl lame_set_stream_binary_mode(FILE *const fp)
{
  return 0;
}

//----- (0804F0F0) --------------------------------------------------------
off_t __cdecl lame_get_file_size(const char *const filename)
{
  stat sb; // [esp+10h] [ebp-68h] BYREF

  if ( stat64((int)filename, (int)&sb) )
    return -1LL;
  else
    return sb.st_size;
}

//----- (0804F120) --------------------------------------------------------
int __cdecl set_id3tag(lame_global_flags *gfp, int type, const char *str)
{
  int result; // eax

  switch ( type )
  {
    case 'a':
      id3tag_set_artist(gfp, str);
      result = 0;
      break;
    case 'c':
      id3tag_set_comment(gfp, str);
      result = 0;
      break;
    case 'g':
      result = id3tag_set_genre(gfp, str);
      break;
    case 'l':
      id3tag_set_album(gfp, str);
      result = 0;
      break;
    case 'n':
      result = id3tag_set_track(gfp, str);
      break;
    case 't':
      id3tag_set_title(gfp, str);
      result = 0;
      break;
    case 'v':
      result = id3tag_set_fieldvalue(gfp, str);
      break;
    case 'y':
      id3tag_set_year(gfp, str);
      result = 0;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}
// 804A2CC: using guessed type int __cdecl id3tag_set_comment(_DWORD, _DWORD);
// 804A59C: using guessed type int __cdecl id3tag_set_title(_DWORD, _DWORD);
// 804A61C: using guessed type int __cdecl id3tag_set_artist(_DWORD, _DWORD);
// 804A6CC: using guessed type int __cdecl id3tag_set_year(_DWORD, _DWORD);
// 804A6DC: using guessed type int __cdecl id3tag_set_album(_DWORD, _DWORD);
// 804A82C: using guessed type int __cdecl id3tag_set_track(_DWORD, _DWORD);
// 804A86C: using guessed type int __cdecl id3tag_set_genre(_DWORD, _DWORD);
// 804A9FC: using guessed type int __cdecl id3tag_set_fieldvalue(_DWORD, _DWORD);

//----- (0804F204) --------------------------------------------------------
int __cdecl id3_tag(lame_global_flags *gfp, int type, TextEncoding_0 enc, char *str)
{
  int result; // [esp+18h] [ebp-10h]
  char *x; // [esp+1Ch] [ebp-Ch]

  x = strdup(str);
  result = set_id3tag(gfp, type, x);
  free(x);
  return result;
}

//----- (0804F24B) --------------------------------------------------------
int __cdecl lame_version_print(FILE *const fp)
{
  size_t lenu; // [esp+28h] [ebp-20h]
  size_t lenv; // [esp+2Ch] [ebp-1Ch]
  size_t lenb; // [esp+30h] [ebp-18h]
  const char *u; // [esp+34h] [ebp-14h]
  const char *v; // [esp+38h] [ebp-10h]
  const char *b; // [esp+3Ch] [ebp-Ch]

  b = (const char *)get_lame_os_bitness();
  v = (const char *)get_lame_version();
  u = (const char *)get_lame_url();
  lenb = strlen(b);
  lenv = strlen(v);
  lenu = strlen(u);
  if ( lenu + lenb + lenv + 16 > 0x50 && lenu + 2 <= 0x50 )
  {
    if ( lenb )
      fprintf(fp, "LAME %s version %s\n%*s(%s)\n\n", b, v, 80 - lenu - 2, (const char *)&unk_8055592, u);
    else
      fprintf(fp, "LAME version %s\n%*s(%s)\n\n", v, 80 - lenu - 2, (const char *)&unk_8055592, u);
  }
  else if ( lenb )
  {
    fprintf(fp, "LAME %s version %s (%s)\n\n", b, v, u);
  }
  else
  {
    fprintf(fp, "LAME version %s (%s)\n\n", v, u);
  }
  return 0;
}
// 804A08C: using guessed type int get_lame_version(void);
// 804A1CC: using guessed type int get_lame_os_bitness(void);
// 804A29C: using guessed type int get_lame_url(void);

//----- (0804F3AB) --------------------------------------------------------
int __cdecl print_license(FILE *const fp)
{
  lame_version_print(fp);
  fwrite(
    "Can I use LAME in my commercial program?\n"
    "\n"
    "Yes, you can, under the restrictions of the LGPL.  In particular, you\n"
    "can include a compiled version of the LAME library (for example,\n"
    "lame.dll) with a commercial program.  Some notable requirements of\n"
    "the LGPL:\n"
    "\n",
    1u,
    0xFFu,
    fp);
  fwrite(
    "1. In your program, you cannot include any source code from LAME, with\n"
    "   the exception of files whose only purpose is to describe the library\n"
    "   interface (such as lame.h).\n"
    "\n",
    1u,
    0xAFu,
    fp);
  fwrite(
    "2. Any modifications of LAME must be released under the LGPL.\n"
    "   The LAME project (www.mp3dev.org) would appreciate being\n"
    "   notified of any modifications.\n"
    "\n",
    1u,
    0x9Du,
    fp);
  fwrite(
    "3. You must give prominent notice that your program is:\n"
    "      A. using LAME (including version number)\n"
    "      B. LAME is under the LGPL\n"
    "      C. Provide a copy of the LGPL.  (the file COPYING contains the LGPL)\n"
    "      D. Provide a copy of LAME source, or a pointer where the LAME\n"
    "         source can be obtained (such as www.mp3dev.org)\n"
    "   An example of prominent notice would be an \"About the LAME encoding engine\"\n"
    "   button in some pull down menu within the executable of your program.\n"
    "\n",
    1u,
    0x1E7u,
    fp);
  fwrite(
    "4. If you determine that distribution of LAME requires a patent license,\n   you must obtain such license.\n\n\n",
    1u,
    0x6Cu,
    fp);
  fwrite(
    "*** IMPORTANT NOTE ***\n"
    "\n"
    "The decoding functions provided in LAME use the mpglib decoding engine which\n"
    "is under the GPL.  They may not be used by any program not released under the\n"
    "GPL unless you obtain such permission from the MPG123 project (www.mpg123.de).\n"
    "\n",
    1u,
    0x103u,
    fp);
  return 0;
}

//----- (0804F49B) --------------------------------------------------------
int __cdecl usage(FILE *const fp, const char *ProgramName)
{
  lame_version_print(fp);
  fprintf(
    fp,
    "usage: %s [options] <infile> [outfile]\n"
    "\n"
    "    <infile> and/or <outfile> can be \"-\", which means stdin/stdout.\n"
    "\n"
    "Try:\n"
    "     \"%s --help\"           for general usage information\n"
    " or:\n"
    "     \"%s --preset help\"    for information on suggested predefined settings\n"
    " or:\n"
    "     \"%s --longhelp\"\n"
    "  or \"%s -?\"              for a complete options list\n"
    "\n",
    ProgramName,
    ProgramName,
    ProgramName,
    ProgramName,
    ProgramName);
  return 0;
}

//----- (0804F4EA) --------------------------------------------------------
int __cdecl short_help(const lame_global_flags *gfp, FILE *const fp, const char *ProgramName)
{
  int VBR_q; // [esp+8h] [ebp-10h]

  lame_version_print(fp);
  fprintf(
    fp,
    "usage: %s [options] <infile> [outfile]\n"
    "\n"
    "    <infile> and/or <outfile> can be \"-\", which means stdin/stdout.\n"
    "\n"
    "RECOMMENDED:\n"
    "    lame -V2 input.wav output.mp3\n"
    "\n",
    ProgramName);
  VBR_q = lame_get_VBR_q(gfp);
  fprintf(
    fp,
    "OPTIONS:\n"
    "    -b bitrate      set the bitrate, default 128 kbps\n"
    "    -h              higher quality, but a little slower.  Recommended.\n"
    "    -f              fast mode (lower quality)\n"
    "    -V n            quality setting for VBR.  default n=%i\n"
    "                    0=high quality,bigger files. 9=smaller files\n",
    VBR_q);
  fwrite(
    "    --preset type   type must be \"medium\", \"standard\", \"extreme\", \"insane\",\n"
    "                    or a value for an average desired bitrate and depending\n"
    "                    on the value specified, appropriate quality settings will\n"
    "                    be used.\n"
    "                    \"--preset help\" gives more info on these\n"
    "\n",
    1u,
    0x141u,
    fp);
  fwrite("    --longhelp      full list of options\n\n    --license       print License information\n\n", 1u, 0x59u, fp);
  return 0;
}
// 804AA9C: using guessed type int __cdecl lame_get_VBR_q(_DWORD);

//----- (0804F588) --------------------------------------------------------
void __cdecl wait_for(FILE *const fp, int lessmode)
{
  if ( lessmode )
  {
    fflush(fp);
    getchar();
  }
  else
  {
    fputc(10, fp);
  }
  fputc(10, fp);
}

//----- (0804F5CE) --------------------------------------------------------
int __cdecl long_help(const lame_global_flags *gfp, FILE *const fp, const char *ProgramName, int lessmode)
{
  int VBR_q; // [esp+8h] [ebp-10h]

  lame_version_print(fp);
  fprintf(
    fp,
    "usage: %s [options] <infile> [outfile]\n"
    "\n"
    "    <infile> and/or <outfile> can be \"-\", which means stdin/stdout.\n"
    "\n"
    "RECOMMENDED:\n"
    "    lame -V2 input.wav output.mp3\n"
    "\n",
    ProgramName);
  fwrite(
    "OPTIONS:\n"
    "  Input options:\n"
    "    --scale <arg>   scale input (multiply PCM data) by <arg>\n"
    "    --scale-l <arg> scale channel 0 (left) input (multiply PCM data) by <arg>\n"
    "    --scale-r <arg> scale channel 1 (right) input (multiply PCM data) by <arg>\n"
    "    --mp1input      input file is a MPEG Layer I   file\n"
    "    --mp2input      input file is a MPEG Layer II  file\n"
    "    --mp3input      input file is a MPEG Layer III file\n"
    "    --nogap <file1> <file2> <...>\n"
    "                    gapless encoding for a set of contiguous files\n"
    "    --nogapout <dir>\n"
    "                    output dir for gapless encoding (must precede --nogap)\n"
    "    --nogaptags     allow the use of VBR tags in gapless encoding\n",
    1u,
    0x2A3u,
    fp);
  fwrite(
    "\n"
    "  Input options for RAW PCM:\n"
    "    -r              input is raw pcm\n"
    "    -x              force byte-swapping of input\n"
    "    -s sfreq        sampling frequency of input file (kHz) - default 44.1 kHz\n"
    "    --bitwidth w    input bit width is w (default 16)\n"
    "    --signed        input is signed (default)\n"
    "    --unsigned      input is unsigned\n"
    "    --little-endian input is little-endian (default)\n"
    "    --big-endian    input is big-endian\n",
    1u,
    0x1A9u,
    fp);
  wait_for(fp, lessmode);
  fwrite(
    "  Operational options:\n"
    "    -a              downmix from stereo to mono file for mono encoding\n"
    "    -m <mode>       (j)oint, (s)imple, (f)orce, (d)dual-mono, (m)ono\n"
    "                    default is (j) or (s) depending on bitrate\n"
    "                    joint  = joins the best possible of MS and LR stereo\n"
    "                    simple = force LR stereo on all frames\n"
    "                    force  = force MS stereo on all frames.\n"
    "    --preset type   type must be \"medium\", \"standard\", \"extreme\", \"insane\",\n"
    "                    or a value for an average desired bitrate and depending\n"
    "                    on the value specified, appropriate quality settings will\n"
    "                    be used.\n"
    "                    \"--preset help\" gives more info on these\n"
    "    --comp  <arg>   choose bitrate to achive a compression ratio of <arg>\n",
    1u,
    0x32Cu,
    fp);
  fwrite(
    "    --replaygain-fast   compute RG fast but slightly inaccurately (default)\n"
    "    --replaygain-accurate   compute RG more accurately and find the peak sample\n"
    "    --noreplaygain  disable ReplayGain analysis\n"
    "    --clipdetect    enable --replaygain-accurate and print a message whether\n"
    "                    clipping occurs and how far the waveform is from full scale\n",
    1u,
    0x169u,
    fp);
  fwrite(
    "    --flush         flush output stream as soon as possible\n"
    "    --freeformat    produce a free format bitstream\n"
    "    --decode        input=mp3 file, output=wav\n"
    "    -t              disable writing wav header when using --decode\n",
    1u,
    0xE2u,
    fp);
  wait_for(fp, lessmode);
  fwrite(
    "  Verbosity:\n"
    "    --disptime <arg>print progress report every arg seconds\n"
    "    -S              don't print progress report, VBR histograms\n"
    "    --nohist        disable VBR histogram display\n"
    "    --silent        don't print anything on screen\n"
    "    --quiet         don't print anything on screen\n"
    "    --brief         print more useful information\n"
    "    --verbose       print a lot of useful information\n"
    "\n",
    1u,
    0x18Au,
    fp);
  fwrite(
    "  Noise shaping & psycho acoustic algorithms:\n"
    "    -q <arg>        <arg> = 0...9.  Default  -q 5 \n"
    "                    -q 0:  Highest quality, very slow \n"
    "                    -q 9:  Poor quality, but fast \n"
    "    -h              Same as -q 2.   Recommended.\n"
    "    -f              Same as -q 7.   Fast, ok quality\n",
    1u,
    0x131u,
    fp);
  wait_for(fp, lessmode);
  fwrite(
    "  CBR (constant bitrate, the default) options:\n"
    "    -b <bitrate>    set the bitrate in kbps, default 128 kbps\n"
    "    --cbr           enforce use of constant bitrate\n"
    "\n"
    "  ABR options:\n"
    "    --abr <bitrate> specify average bitrate desired (instead of quality)\n"
    "\n",
    1u,
    0xFBu,
    fp);
  VBR_q = lame_get_VBR_q(gfp);
  fprintf(
    fp,
    "  VBR options:\n"
    "    -V n            quality setting for VBR.  default n=%i\n"
    "                    0=high quality,bigger files. 9=smaller files\n"
    "    -v              the same as -V 4\n"
    "    --vbr-old       use old variable bitrate (VBR) routine\n"
    "    --vbr-new       use new variable bitrate (VBR) routine (default)\n",
    VBR_q);
  fwrite(
    "    -b <bitrate>    specify minimum allowed bitrate, default  32 kbps\n"
    "    -B <bitrate>    specify maximum allowed bitrate, default 320 kbps\n"
    "    -F              strictly enforce the -b option, for use with players that\n"
    "                    do not support low bitrate mp3\n"
    "    -t              disable writing LAME Tag\n"
    "    -T              enable and force writing LAME Tag\n",
    1u,
    0x170u,
    fp);
  wait_for(fp, lessmode);
  fwrite("  PSY related:\n", 1u, 0xFu, fp);
  fwrite(
    "    --temporal-masking x   x=0 disables, x=1 enables temporal masking effect\n"
    "    --nssafejoint   M/S switching criterion\n"
    "    --nsmsfix <arg> M/S switching tuning [effective 0-3.5]\n"
    "    --interch x     adjust inter-channel masking ratio\n"
    "    --ns-bass x     adjust masking for sfbs  0 -  6 (long)  0 -  5 (short)\n"
    "    --ns-alto x     adjust masking for sfbs  7 - 13 (long)  6 - 10 (short)\n"
    "    --ns-treble x   adjust masking for sfbs 14 - 21 (long) 11 - 12 (short)\n",
    1u,
    0x1CCu,
    fp);
  fwrite("    --ns-sfb21 x    change ns-treble by x dB for sfb21\n", 1u, 0x37u, fp);
  wait_for(fp, lessmode);
  fwrite("  experimental switches:\n    -Y              lets LAME ignore noise in sfb21, like in CBR\n", 1u, 0x5Au, fp);
  wait_for(fp, lessmode);
  fwrite(
    "  MP3 header/stream options:\n"
    "    -e <emp>        de-emphasis n/5/c  (obsolete)\n"
    "    -c              mark as copyright\n"
    "    -o              mark as non-original\n"
    "    -p              error protection.  adds 16 bit checksum to every frame\n"
    "                    (the checksum is computed correctly)\n"
    "    --nores         disable the bit reservoir\n"
    "    --strictly-enforce-ISO   comply as much as possible to ISO MPEG spec\n"
    "\n",
    1u,
    0x19Au,
    fp);
  fprintf(
    fp,
    "  Filter options:\n"
    "  --lowpass <freq>        frequency(kHz), lowpass filter cutoff above freq\n"
    "  --lowpass-width <freq>  frequency(kHz) - default 15%% of lowpass freq\n"
    "  --highpass <freq>       frequency(kHz), highpass filter cutoff below freq\n"
    "  --highpass-width <freq> frequency(kHz) - default 15%% of highpass freq\n");
  fwrite("  --resample <sfreq>  sampling frequency of output file(kHz)- default=automatic\n", 1u, 0x50u, fp);
  wait_for(fp, lessmode);
  fwrite(
    "  ID3 tag options:\n"
    "    --tt <title>    audio/song title (max 30 chars for version 1 tag)\n"
    "    --ta <artist>   audio/song artist (max 30 chars for version 1 tag)\n"
    "    --tl <album>    audio/song album (max 30 chars for version 1 tag)\n"
    "    --ty <year>     audio/song year of issue (1 to 9999)\n"
    "    --tc <comment>  user-defined text (max 30 chars for v1 tag, 28 for v1.1)\n"
    "    --tn <track[/total]>   audio/song track number and (optionally) the total\n"
    "                           number of tracks on the original recording. (track\n"
    "                           and total each 1 to 255. just the track number\n"
    "                           creates v1.1 tag, providing a total forces v2.0).\n"
    "    --tg <genre>    audio/song genre (name or number in list)\n"
    "    --ti <file>     audio/song albumArt (jpeg/png/gif file, 128KB max, v2.3)\n"
    "    --tv <id=value> user-defined frame specified by id and value (v2.3 tag)\n",
    1u,
    0x376u,
    fp);
  fwrite(
    "    --add-id3v2     force addition of version 2 tag\n"
    "    --id3v1-only    add only a version 1 tag\n"
    "    --id3v2-only    add only a version 2 tag\n"
    "    --space-id3v1   pad version 1 tag with spaces instead of nulls\n"
    "    --pad-id3v2     same as '--pad-id3v2-size 128'\n"
    "    --pad-id3v2-size <value> adds version 2 tag, pad with extra <value> bytes\n"
    "    --genre-list    print alphabetically sorted ID3 genre list and exit\n"
    "    --ignore-tag-errors  ignore errors in values passed for tags\n"
    "\n",
    1u,
    0x1DCu,
    fp);
  fwrite(
    "    Note: A version 2 tag will NOT be added unless one of the input fields\n"
    "    won't fit in a version 1 tag (e.g. the title string is longer than 30\n"
    "    characters), or the '--add-id3v2' or '--id3v2-only' options are used,\n"
    "    or output is redirected to stdout.\n"
    "\n"
    "Misc:\n"
    "    --license       print License information\n"
    "\n",
    1u,
    0x13Cu,
    fp);
  wait_for(fp, lessmode);
  fwrite(
    "  Platform specific:\n    --noasm <instructions> disable assembly optimizations for mmx/3dnow/sse\n",
    1u,
    0x61u,
    fp);
  wait_for(fp, lessmode);
  display_bitrates(fp);
  return 0;
}
// 804AA9C: using guessed type int __cdecl lame_get_VBR_q(_DWORD);

//----- (0804F991) --------------------------------------------------------
void __cdecl display_bitrate(FILE *const fp, const char *const version, const int d, const int indx)
{
  int nBitrates; // [esp+28h] [ebp-10h]
  int i; // [esp+2Ch] [ebp-Ch]

  nBitrates = 14;
  if ( d == 4 )
    nBitrates = 8;
  fprintf(
    fp,
    "\nMPEG-%-3s layer III sample frequencies (kHz):  %2d  %2d  %g\nbitrates (kbps):",
    version,
    32 / d,
    48 / d,
    (double)(44.1 / (long double)d));
  for ( i = 1; i <= nBitrates; ++i )
    fprintf(fp, " %2i", bitrate_table[16 * indx + i]);
  fputc(10, fp);
}
// 805B2E0: using guessed type int bitrate_table[48];

//----- (0804FA50) --------------------------------------------------------
int __cdecl display_bitrates(FILE *const fp)
{
  display_bitrate(fp, "1", 1, 1);
  display_bitrate(fp, "2", 2, 0);
  display_bitrate(fp, "2.5", 4, 0);
  fputc(10, fp);
  fflush(fp);
  return 0;
}

//----- (0804FAE4) --------------------------------------------------------
void __cdecl presets_longinfo_dm(FILE *msgfp)
{
  fwrite("\nThe --preset switches are aliases over LAME settings.\n\n\n", 1u, 0x39u, msgfp);
  fwrite("To activate these presets:\n\n   For VBR modes (generally highest quality):\n\n", 1u, 0x4Bu, msgfp);
  fwrite(
    "     \"--preset medium\" This preset should provide near transparency\n"
    "                             to most people on most music.\n"
    "\n"
    "     \"--preset standard\" This preset should generally be transparent\n"
    "                             to most people on most music and is already\n"
    "                             quite high in quality.\n"
    "\n",
    1u,
    0x143u,
    msgfp);
  fwrite(
    "     \"--preset extreme\" If you have extremely good hearing and similar\n"
    "                             equipment, this preset will generally provide\n"
    "                             slightly higher quality than the \"standard\"\n"
    "                             mode.\n"
    "\n",
    1u,
    0xFFu,
    msgfp);
  fwrite(
    "   For CBR 320kbps (highest quality possible from the --preset switches):\n"
    "\n"
    "     \"--preset insane\"  This preset will usually be overkill for most\n"
    "                             people and most situations, but if you must\n"
    "                             have the absolute highest quality with no\n"
    "                             regard to filesize, this is the way to go.\n"
    "\n",
    1u,
    0x16Au,
    msgfp);
  fwrite(
    "   For ABR modes (high quality per given bitrate but not as high as VBR):\n"
    "\n"
    "     \"--preset <kbps>\"  Using this preset will usually give you good\n"
    "                             quality at a specified bitrate. Depending on the\n"
    "                             bitrate entered, this preset will determine the\n",
    1u,
    0x12Bu,
    msgfp);
  fwrite(
    "                             optimal settings for that particular situation.\n"
    "                             While this approach works, it is not nearly as\n"
    "                             flexible as VBR, and usually will not attain the\n"
    "                             same level of quality as VBR at higher bitrates.\n"
    "\n",
    1u,
    0x136u,
    msgfp);
  fwrite(
    "The following options are also available for the corresponding profiles:\n"
    "\n"
    "   <fast>        standard\n"
    "   <fast>        extreme\n"
    "                 insane\n"
    "   <cbr> (ABR Mode) - The ABR Mode is implied. To use it,\n"
    "                      simply specify a bitrate. For example:\n"
    "                      \"--preset 185\" activates this\n"
    "                      preset and uses 185 as an average kbps.\n"
    "\n",
    1u,
    0x17Fu,
    msgfp);
  fwrite("   \"fast\" - Enables the fast VBR mode for a particular profile.\n\n", 1u, 0x41u, msgfp);
  fwrite(
    "   \"cbr\"  - If you use the ABR mode (read above) with a significant\n"
    "            bitrate such as 80, 96, 112, 128, 160, 192, 224, 256, 320,\n"
    "            you can use the \"cbr\" option to force CBR mode encoding\n"
    "            instead of the standard abr mode. ABR does provide higher\n"
    "            quality but CBR may be useful in situations such as when\n"
    "            streaming an mp3 over the internet may be important.\n"
    "\n",
    1u,
    0x19Cu,
    msgfp);
  fwrite(
    "    For example:\n"
    "\n"
    "    \"--preset fast standard <input file> <output file>\"\n"
    " or \"--preset cbr 192 <input file> <output file>\"\n"
    " or \"--preset 172 <input file> <output file>\"\n"
    " or \"--preset extreme <input file> <output file>\"\n"
    "\n"
    "\n",
    1u,
    0xDEu,
    msgfp);
  fwrite(
    "A few aliases are also available for ABR mode:\n"
    "phone => 16kbps/mono        phon+/lw/mw-eu/sw => 24kbps/mono\n"
    "mw-us => 40kbps/mono        voice => 56kbps/mono\n"
    "fm/radio/tape => 112kbps    hifi => 160kbps\n"
    "cd => 192kbps               studio => 256kbps\n",
    1u,
    0xF7u,
    msgfp);
}

//----- (0804FC9C) --------------------------------------------------------
int __cdecl presets_set(lame_t gfp, int fast, int cbr, const char *preset_name, const char *ProgramName)
{
  int v6; // [esp+4h] [ebp-34h]
  int mono; // [esp+2Ch] [ebp-Ch]

  mono = 0;
  if ( !strcmp(preset_name, "help") && fast <= 0 && cbr <= 0 )
  {
    lame_version_print(stdout);
    presets_longinfo_dm(stdout);
    return -1;
  }
  else
  {
    if ( !strcmp(preset_name, "phone") )
    {
      preset_name = "16";
      mono = 1;
    }
    if ( !strcmp(preset_name, "phon+")
      || !strcmp(preset_name, "lw")
      || !strcmp(preset_name, "mw-eu")
      || !strcmp(preset_name, "sw") )
    {
      preset_name = "24";
      mono = 1;
    }
    if ( !strcmp(preset_name, "mw-us") )
    {
      preset_name = "40";
      mono = 1;
    }
    if ( !strcmp(preset_name, "voice") )
    {
      preset_name = "56";
      mono = 1;
    }
    if ( !strcmp(preset_name, "fm") )
      preset_name = "112";
    if ( !strcmp(preset_name, "radio") || !strcmp(preset_name, "tape") )
      preset_name = "112";
    if ( !strcmp(preset_name, "hifi") )
      preset_name = "160";
    if ( !strcmp(preset_name, "cd") )
      preset_name = "192";
    if ( !strcmp(preset_name, "studio") )
      preset_name = "256";
    if ( !strcmp(preset_name, "medium") )
    {
      lame_set_VBR_q(gfp, 4);
      if ( fast <= 0 )
        lame_set_VBR(gfp, 2);
      else
        lame_set_VBR(gfp, 4);
      return 0;
    }
    else if ( !strcmp(preset_name, "standard") )
    {
      lame_set_VBR_q(gfp, 2);
      if ( fast <= 0 )
        lame_set_VBR(gfp, 2);
      else
        lame_set_VBR(gfp, 4);
      return 0;
    }
    else if ( !strcmp(preset_name, "extreme") )
    {
      lame_set_VBR_q(gfp, 0);
      if ( fast <= 0 )
        lame_set_VBR(gfp, 2);
      else
        lame_set_VBR(gfp, 4);
      return 0;
    }
    else if ( !strcmp(preset_name, "insane") && fast <= 0 )
    {
      lame_set_preset(gfp, 1003);
      return 0;
    }
    else if ( atoi(preset_name) <= 0 || fast > 0 )
    {
      lame_version_print(Console_IO.Error_fp);
      error_printf(
        "Error: You did not enter a valid profile and/or options with --preset\n"
        "\n"
        "Available profiles are:\n"
        "\n"
        "   <fast>        medium\n"
        "   <fast>        standard\n"
        "   <fast>        extreme\n"
        "                 insane\n"
        "          <cbr> (ABR Mode) - The ABR Mode is implied. To use it,\n"
        "                             simply specify a bitrate. For example:\n"
        "                             \"--preset 185\" activates this\n"
        "                             preset and uses 185 as an average kbps.\n"
        "\n");
      error_printf(
        "    Some examples:\n"
        "\n"
        " or \"%s --preset fast standard <input file> <output file>\"\n"
        " or \"%s --preset cbr 192 <input file> <output file>\"\n"
        " or \"%s --preset 172 <input file> <output file>\"\n"
        " or \"%s --preset extreme <input file> <output file>\"\n"
        "\n"
        "For further information try: \"%s --preset help\"\n",
        ProgramName,
        ProgramName,
        ProgramName,
        ProgramName,
        ProgramName);
      return -1;
    }
    else if ( atoi(preset_name) <= 7 || atoi(preset_name) > 320 )
    {
      lame_version_print(Console_IO.Error_fp);
      error_printf(
        "Error: The bitrate specified is out of the valid range for this preset\n"
        "\n"
        "When using this mode you must enter a value between \"32\" and \"320\"\n"
        "\n"
        "For further information try: \"%s --preset help\"\n",
        ProgramName);
      return -1;
    }
    else
    {
      v6 = atoi(preset_name);
      lame_set_preset(gfp, v6);
      if ( cbr == 1 )
        lame_set_VBR(gfp, 0);
      if ( mono == 1 )
        lame_set_mode(gfp, 3);
      return 0;
    }
  }
}
// 804A4BC: using guessed type int __cdecl lame_set_VBR(_DWORD, _DWORD);
// 804A88C: using guessed type int __cdecl lame_set_preset(_DWORD, _DWORD);
// 804A8BC: using guessed type int __cdecl lame_set_mode(_DWORD, _DWORD);
// 804A96C: using guessed type int __cdecl lame_set_VBR_q(_DWORD, _DWORD);

//----- (080500DE) --------------------------------------------------------
void __cdecl genre_list_handler(int num, const char *name, void *cookie)
{
  console_printf("%3d %s\n", num, name);
}

//----- (08050100) --------------------------------------------------------
int __cdecl local_strcasecmp(const char *s1, const char *s2)
{
  unsigned __int8 c2; // [esp+1Eh] [ebp-Ah]
  unsigned __int8 c1; // [esp+1Fh] [ebp-9h]

  do
  {
    c1 = tolower(*s1);
    c2 = tolower(*s2);
    if ( !c1 )
      break;
    ++s1;
    ++s2;
  }
  while ( c1 == c2 );
  return c1 - c2;
}

//----- (08050158) --------------------------------------------------------
int __cdecl filename_to_type(const char *FileName)
{
  size_t len; // [esp+1Ch] [ebp-Ch]
  const char *FileNamea; // [esp+30h] [ebp+8h]

  len = strlen(FileName);
  if ( len <= 3 )
    return 0;
  FileNamea = &FileName[len - 4];
  if ( !local_strcasecmp(FileNamea, ".mpg") )
    return 7;
  if ( !local_strcasecmp(FileNamea, ".mp1") )
    return 7;
  if ( !local_strcasecmp(FileNamea, ".mp2") )
    return 7;
  if ( !local_strcasecmp(FileNamea, ".mp3") )
    return 7;
  if ( !local_strcasecmp(FileNamea, ".wav") )
    return 2;
  if ( !local_strcasecmp(FileNamea, ".aif") )
    return 3;
  if ( !local_strcasecmp(FileNamea, ".raw") )
    return 1;
  if ( local_strcasecmp(FileNamea, ".ogg") )
    return 0;
  return 8;
}

//----- (08050285) --------------------------------------------------------
int __cdecl resample_rate(double freq)
{
  int result; // eax
  double freqa; // [esp+18h] [ebp-10h]

  freqa = freq;
  if ( freq >= 1000.0 )
    freqa = freq * 0.001;
  switch ( (int)freqa )
  {
    case 8:
      result = 8000;
      break;
    case 11:
      result = 11025;
      break;
    case 12:
      result = 12000;
      break;
    case 16:
      result = 16000;
      break;
    case 22:
      result = 22050;
      break;
    case 24:
      result = 24000;
      break;
    case 32:
      result = 32000;
      break;
    case 44:
      result = 44100;
      break;
    case 48:
      result = 48000;
      break;
    default:
      error_printf("Illegal resample frequency: %.3f kHz\n", freqa);
      result = 0;
      break;
  }
  return result;
}

//----- (08050341) --------------------------------------------------------
int __cdecl set_id3_albumart(lame_t gfp, const char *file_name)
{
  int v3; // eax
  int size; // [esp+10h] [ebp-18h]
  char *albumart; // [esp+14h] [ebp-14h]
  FILE *fpi; // [esp+18h] [ebp-10h]
  int ret; // [esp+1Ch] [ebp-Ch]

  if ( !file_name )
    return 0;
  fpi = (FILE *)fopen64(file_name, &unk_8058E4C);
  if ( fpi )
  {
    fseek(fpi, 0, 2);
    size = ftell(fpi);
    fseek(fpi, 0, 0);
    albumart = (char *)malloc(size);
    if ( albumart )
    {
      if ( fread(albumart, 1u, size, fpi) == size )
      {
        if ( id3tag_set_albumart(gfp, albumart, size) )
          v3 = 4;
        else
          v3 = 0;
        ret = v3;
      }
      else
      {
        ret = 3;
      }
      free(albumart);
    }
    else
    {
      ret = 2;
    }
    fclose(fpi);
  }
  else
  {
    ret = 1;
  }
  if ( ret == 2 )
  {
    error_printf("Insufficient memory for reading the albumart.\n");
  }
  else if ( ret > 2 )
  {
    if ( ret == 3 )
      error_printf("Read error: '%s'.\n", file_name);
    else
      error_printf("Unsupported image: '%s'.\nSpecify JPEG/PNG/GIF image (128KB maximum)\n", file_name);
  }
  else if ( ret == 1 )
  {
    error_printf("Could not find: '%s'.\n", file_name);
  }
  return ret;
}
// 8050483: conditional instruction was optimized away because %ret.4==4
// 804A0EC: using guessed type int __cdecl id3tag_set_albumart(_DWORD, _DWORD, _DWORD);
// 804A26C: using guessed type int __cdecl fopen64(_DWORD, _DWORD);

//----- (080504D7) --------------------------------------------------------
int __cdecl parse_args(
        lame_global_flags *gfp,
        int argc,
        char **argv,
        char *const inPath,
        char *const outPath,
        char **nogap_inPath,
        int *num_nogap)
{
  char *v8; // eax
  long double v9; // fst7
  int VBR_mean_bitrate_kbps; // eax
  int v11; // eax
  int v13; // eax
  int v14; // eax
  long double v15; // fst7
  long double v16; // fst7
  long double v17; // fst7
  long double v18; // fst7
  int v19; // eax
  int v20; // eax
  int v21; // eax
  int exp_nspsytune; // eax
  char *v23; // eax
  char *v24; // eax
  long double v25; // fst7
  int v26; // eax
  const char *v27; // edx
  char *v28; // eax
  int v29; // eax
  int v30; // [esp+4h] [ebp-D4h]
  int v31; // [esp+4h] [ebp-D4h]
  int v32; // [esp+4h] [ebp-D4h]
  _BOOL4 v33; // [esp+4h] [ebp-D4h]
  int v34; // [esp+4h] [ebp-D4h]
  int v35; // [esp+4h] [ebp-D4h]
  int brate; // [esp+4h] [ebp-D4h]
  int v37; // [esp+4h] [ebp-D4h]
  float v38; // [esp+2Ch] [ebp-ACh]
  float v39; // [esp+2Ch] [ebp-ACh]
  float v40; // [esp+2Ch] [ebp-ACh]
  float v41; // [esp+2Ch] [ebp-ACh]
  float v42; // [esp+2Ch] [ebp-ACh]
  float v43; // [esp+2Ch] [ebp-ACh]
  float v44; // [esp+2Ch] [ebp-ACh]
  float v45; // [esp+2Ch] [ebp-ACh]
  double val; // [esp+50h] [ebp-88h]
  double vala; // [esp+50h] [ebp-88h]
  double valb; // [esp+50h] [ebp-88h]
  double valc; // [esp+50h] [ebp-88h]
  double vald; // [esp+50h] [ebp-88h]
  double vale; // [esp+50h] [ebp-88h]
  int n_1; // [esp+5Ch] [ebp-7Ch] BYREF
  int n_0; // [esp+60h] [ebp-78h]
  int x; // [esp+64h] [ebp-74h] BYREF
  int tmp_quality; // [esp+68h] [ebp-70h]
  int cbr; // [esp+70h] [ebp-68h]
  int fast; // [esp+74h] [ebp-64h]
  FILE *fp; // [esp+78h] [ebp-60h]
  int k_2; // [esp+7Ch] [ebp-5Ch]
  int k_1; // [esp+80h] [ebp-58h]
  int k_0; // [esp+84h] [ebp-54h]
  int k; // [esp+88h] [ebp-50h]
  int n; // [esp+8Ch] [ebp-4Ch]
  int ret_0; // [esp+90h] [ebp-48h]
  int ret; // [esp+94h] [ebp-44h]
  int argUsed; // [esp+98h] [ebp-40h]
  char *nextArg; // [esp+9Ch] [ebp-3Ch]
  char *arg; // [esp+A0h] [ebp-38h]
  char *token; // [esp+A4h] [ebp-34h]
  int id3tag_mode; // [esp+A8h] [ebp-30h]
  int noreplaygain; // [esp+ACh] [ebp-2Ch]
  int count_nogap; // [esp+B0h] [ebp-28h]
  const char *ProgramName; // [esp+B4h] [ebp-24h]
  int nogap_tags; // [esp+B8h] [ebp-20h]
  int nogap; // [esp+BCh] [ebp-1Ch]
  int autoconvert; // [esp+C0h] [ebp-18h]
  int i; // [esp+C4h] [ebp-14h]
  int input_file; // [esp+C8h] [ebp-10h]
  char c; // [esp+CFh] [ebp-9h]

  input_file = 0;
  autoconvert = 0;
  nogap = 0;
  nogap_tags = 0;
  ProgramName = *argv;
  count_nogap = 0;
  noreplaygain = 0;
  id3tag_mode = 0;
  *inPath = 0;
  *outPath = 0;
  silent = 0;
  ignore_tag_errors = 0;
  brhist_0 = 1;
  mp3_delay = 0;
  mp3_delay_set = 0;
  print_clipping_info = 0;
  disable_wav_header = 0;
  id3tag_init(gfp);
  i = 0;
LABEL_342:
  while ( ++i < argc )
  {
    token = argv[i];
    if ( *token++ == 45 )
    {
      argUsed = 0;
      if ( i + 1 >= argc )
        v8 = (char *)&unk_8055592;
      else
        v8 = argv[i + 1];
      nextArg = v8;
      if ( !*token )
      {
        input_file = 1;
        if ( *inPath )
        {
          if ( !*outPath )
            strncpy(outPath, argv[i], 0x1001u);
        }
        else
        {
          strncpy(inPath, argv[i], 0x1001u);
        }
      }
      if ( *token != 45 )
      {
        while ( 1 )
        {
          c = *token++;
          if ( !c )
            goto LABEL_342;
          if ( *token )
            v24 = token;
          else
            v24 = nextArg;
          arg = v24;
          switch ( c )
          {
            case '?':
              long_help(gfp, stdout, ProgramName, 0);
              return -1;
            case 'B':
              argUsed = 1;
              v37 = atoi(arg);
              lame_set_VBR_max_bitrate_kbps(gfp, v37);
              goto LABEL_325;
            case 'F':
              lame_set_VBR_hard_min(gfp, 1);
              goto LABEL_325;
            case 'S':
              silent = 10;
              goto LABEL_325;
            case 'T':
              lame_set_bWriteVbrTag(gfp, 1);
              nogap_tags = 1;
              disable_wav_header = 0;
              goto LABEL_325;
            case 'V':
              argUsed = 1;
              if ( !lame_get_VBR(gfp) )
                lame_set_VBR(gfp, 4);
              v45 = atof(arg);
              lame_set_VBR_quality(gfp, LODWORD(v45));
              goto LABEL_325;
            case 'X':
              n_0 = __isoc99_sscanf(arg, "%d,%d", &x, &n_1);
              if ( n_0 == 1 )
                n_1 = x;
              argUsed = 1;
              goto LABEL_325;
            case 'Y':
              lame_set_experimentalY(gfp, 1);
              goto LABEL_325;
            case 'Z':
              n_1 = 1;
              argUsed = __isoc99_sscanf(arg, "%d", &n_1);
              goto LABEL_325;
            case 'a':
              autoconvert = 1;
              lame_set_mode(gfp, 3);
              goto LABEL_325;
            case 'b':
              argUsed = 1;
              v35 = atoi(arg);
              lame_set_brate(gfp, v35);
              brate = lame_get_brate(gfp);
              lame_set_VBR_min_bitrate_kbps(gfp, brate);
              goto LABEL_325;
            case 'c':
              lame_set_copyright(gfp, 1);
              goto LABEL_325;
            case 'd':
            case 'k':
              error_printf("WARNING: -%c is obsolete.\n", c);
              goto LABEL_325;
            case 'e':
              argUsed = 1;
              v26 = *arg;
              switch ( v26 )
              {
                case 'c':
                  lame_set_emphasis(gfp, 3);
                  break;
                case 'n':
                  lame_set_emphasis(gfp, 0);
                  break;
                case '5':
                  lame_set_emphasis(gfp, 1);
                  break;
                default:
                  error_printf("%s: -e emp must be n/5/c not %s\n", ProgramName, arg);
                  return -1;
              }
LABEL_325:
              if ( argUsed )
              {
                if ( arg == token )
                  token = (char *)&unk_8055592;
                else
                  ++i;
                arg = (char *)&unk_8055592;
                argUsed = 0;
              }
              break;
            case 'f':
              lame_set_quality(gfp, 7);
              goto LABEL_325;
            case 'h':
              lame_set_quality(gfp, 2);
              goto LABEL_325;
            case 'm':
              argUsed = 1;
              switch ( *arg )
              {
                case 'a':
                case 'j':
                  goto LABEL_279;
                case 'd':
                  lame_set_mode(gfp, 2);
                  goto LABEL_325;
                case 'f':
                  lame_set_force_ms(gfp, 1);
LABEL_279:
                  lame_set_mode(gfp, 1);
                  goto LABEL_325;
                case 'm':
                  lame_set_mode(gfp, 3);
                  goto LABEL_325;
                case 's':
                  lame_set_mode(gfp, 0);
                  goto LABEL_325;
                default:
                  error_printf("%s: -m mode must be s/d/j/f/m not %s\n", ProgramName, arg);
                  return -1;
              }
            case 'o':
              lame_set_original(gfp, 0);
              goto LABEL_325;
            case 'p':
              lame_set_error_protection(gfp, 1);
              goto LABEL_325;
            case 'q':
              argUsed = 1;
              tmp_quality = atoi(arg);
              if ( tmp_quality < 0 )
                tmp_quality = 0;
              if ( tmp_quality > 9 )
                tmp_quality = 9;
              lame_set_quality(gfp, tmp_quality);
              goto LABEL_325;
            case 'r':
              input_format = sf_raw;
              goto LABEL_325;
            case 's':
              argUsed = 1;
              vale = atof(arg);
              if ( vale > 192.0 )
                v25 = 1.0;
              else
                v25 = 1000.0;
              lame_set_in_samplerate(gfp, (int)(v25 * vale + 0.5));
              goto LABEL_325;
            case 't':
              lame_set_bWriteVbrTag(gfp, 0);
              disable_wav_header = 1;
              goto LABEL_325;
            case 'v':
              if ( !lame_get_VBR(gfp) )
                lame_set_VBR(gfp, 4);
              goto LABEL_325;
            case 'x':
              swapbytes = 1;
              goto LABEL_325;
            default:
              error_printf("%s: unrecognized option -%c\n", ProgramName, c);
              return -1;
          }
        }
      }
      if ( local_strcasecmp(++token, "resample") )
      {
        if ( local_strcasecmp(token, "vbr-old") )
        {
          if ( local_strcasecmp(token, "vbr-new") && local_strcasecmp(token, "vbr-mtrh") )
          {
            if ( local_strcasecmp(token, "cbr") )
            {
              if ( local_strcasecmp(token, "abr") )
              {
                if ( local_strcasecmp(token, "r3mix") )
                {
                  if ( local_strcasecmp(token, "bitwidth") )
                  {
                    if ( local_strcasecmp(token, "signed") )
                    {
                      if ( local_strcasecmp(token, "unsigned") )
                      {
                        if ( local_strcasecmp(token, "little-endian") )
                        {
                          if ( local_strcasecmp(token, "big-endian") )
                          {
                            if ( local_strcasecmp(token, "mp1input") )
                            {
                              if ( local_strcasecmp(token, "mp2input") )
                              {
                                if ( local_strcasecmp(token, "mp3input") )
                                {
                                  if ( !local_strcasecmp(token, "ogginput") )
                                    goto LABEL_50;
                                  if ( local_strcasecmp(token, "phone") )
                                  {
                                    if ( local_strcasecmp(token, "voice") )
                                    {
                                      if ( local_strcasecmp(token, "decode") )
                                      {
                                        if ( local_strcasecmp(token, "flush") )
                                        {
                                          if ( local_strcasecmp(token, "decode-mp3delay") )
                                          {
                                            if ( local_strcasecmp(token, "nores") )
                                            {
                                              if ( local_strcasecmp(token, "strictly-enforce-ISO") )
                                              {
                                                if ( local_strcasecmp(token, "scale") )
                                                {
                                                  if ( local_strcasecmp(token, "scale-l") )
                                                  {
                                                    if ( local_strcasecmp(token, "scale-r") )
                                                    {
                                                      if ( local_strcasecmp(token, "noasm") )
                                                      {
                                                        if ( local_strcasecmp(token, "freeformat") )
                                                        {
                                                          if ( local_strcasecmp(token, "replaygain-fast") )
                                                          {
                                                            if ( local_strcasecmp(token, "replaygain-accurate") )
                                                            {
                                                              if ( local_strcasecmp(token, "noreplaygain") )
                                                              {
                                                                if ( local_strcasecmp(token, "clipdetect") )
                                                                {
                                                                  if ( local_strcasecmp(token, "nohist") )
                                                                  {
                                                                    if ( local_strcasecmp(token, "tt") )
                                                                    {
                                                                      if ( local_strcasecmp(token, "ta") )
                                                                      {
                                                                        if ( local_strcasecmp(token, "tl") )
                                                                        {
                                                                          if ( local_strcasecmp(token, "ty") )
                                                                          {
                                                                            if ( local_strcasecmp(token, "tc") )
                                                                            {
                                                                              if ( local_strcasecmp(token, "tn") )
                                                                              {
                                                                                if ( local_strcasecmp(token, "tg") )
                                                                                {
                                                                                  if ( local_strcasecmp(token, "tv") )
                                                                                  {
                                                                                    if ( local_strcasecmp(token, "ti") )
                                                                                    {
                                                                                      if ( local_strcasecmp(
                                                                                             token,
                                                                                             "ignore-tag-errors") )
                                                                                      {
                                                                                        if ( local_strcasecmp(
                                                                                               token,
                                                                                               "add-id3v2") )
                                                                                        {
                                                                                          if ( local_strcasecmp(
                                                                                                 token,
                                                                                                 "id3v1-only") )
                                                                                          {
                                                                                            if ( local_strcasecmp(
                                                                                                   token,
                                                                                                   "id3v2-only") )
                                                                                            {
                                                                                              if ( local_strcasecmp(
                                                                                                     token,
                                                                                                     "space-id3v1") )
                                                                                              {
                                                                                                if ( local_strcasecmp(token, "pad-id3v2") )
                                                                                                {
                                                                                                  if ( local_strcasecmp(token, "pad-id3v2-size") )
                                                                                                  {
                                                                                                    if ( !local_strcasecmp(token, "genre-list") )
                                                                                                    {
                                                                                                      id3tag_genre_list(genre_list_handler, 0);
                                                                                                      return -2;
                                                                                                    }
                                                                                                    if ( local_strcasecmp(token, "lowpass") )
                                                                                                    {
                                                                                                      if ( local_strcasecmp(token, "lowpass-width") )
                                                                                                      {
                                                                                                        if ( local_strcasecmp(token, "highpass") )
                                                                                                        {
                                                                                                          if ( local_strcasecmp(token, "highpass-width") )
                                                                                                          {
                                                                                                            if ( local_strcasecmp(token, "comp") )
                                                                                                            {
                                                                                                              if ( local_strcasecmp(token, "notemp") )
                                                                                                              {
                                                                                                                if ( local_strcasecmp(token, "interch") )
                                                                                                                {
                                                                                                                  if ( local_strcasecmp(token, "temporal-masking") )
                                                                                                                  {
                                                                                                                    if ( local_strcasecmp(token, "nspsytune") )
                                                                                                                    {
                                                                                                                      if ( local_strcasecmp(token, "nssafejoint") )
                                                                                                                      {
                                                                                                                        if ( local_strcasecmp(token, "nsmsfix") )
                                                                                                                        {
                                                                                                                          if ( local_strcasecmp(token, "ns-bass") )
                                                                                                                          {
                                                                                                                            if ( local_strcasecmp(token, "ns-alto") )
                                                                                                                            {
                                                                                                                              if ( local_strcasecmp(token, "ns-treble") )
                                                                                                                              {
                                                                                                                                if ( local_strcasecmp(token, "ns-sfb21") )
                                                                                                                                {
                                                                                                                                  if ( local_strcasecmp(token, "nspsytune2") )
                                                                                                                                  {
                                                                                                                                    if ( local_strcasecmp(token, "quiet") && local_strcasecmp(token, "silent") )
                                                                                                                                    {
                                                                                                                                      if ( local_strcasecmp(token, "brief") )
                                                                                                                                      {
                                                                                                                                        if ( local_strcasecmp(token, "verbose") )
                                                                                                                                        {
                                                                                                                                          if ( !local_strcasecmp(token, "version") || !local_strcasecmp(token, "license") )
                                                                                                                                          {
                                                                                                                                            print_license(stdout);
                                                                                                                                            return -2;
                                                                                                                                          }
                                                                                                                                          if ( !local_strcasecmp(token, "help") || !local_strcasecmp(token, "usage") )
                                                                                                                                          {
                                                                                                                                            short_help(gfp, stdout, ProgramName);
                                                                                                                                            return -2;
                                                                                                                                          }
                                                                                                                                          if ( !local_strcasecmp(token, "longhelp") )
                                                                                                                                          {
                                                                                                                                            long_help(gfp, stdout, ProgramName, 0);
                                                                                                                                            return -2;
                                                                                                                                          }
                                                                                                                                          if ( !local_strcasecmp(token, "?") )
                                                                                                                                          {
                                                                                                                                            fp = popen("less -Mqc", "w");
                                                                                                                                            long_help(gfp, fp, ProgramName, 0);
                                                                                                                                            pclose(fp);
                                                                                                                                            return -2;
                                                                                                                                          }
                                                                                                                                          if ( local_strcasecmp(token, "preset") && local_strcasecmp(token, "alt-preset") )
                                                                                                                                          {
                                                                                                                                            if ( local_strcasecmp(token, "disptime") )
                                                                                                                                            {
                                                                                                                                              if ( local_strcasecmp(token, "nogaptags") )
                                                                                                                                              {
                                                                                                                                                if ( local_strcasecmp(token, "nogapout") )
                                                                                                                                                {
                                                                                                                                                  if ( local_strcasecmp(token, "nogap") )
                                                                                                                                                  {
                                                                                                                                                    if ( local_strcasecmp(token, "athaa-sensitivity") )
                                                                                                                                                    {
                                                                                                                                                      error_printf("%s: unrecognized option --%s\n", ProgramName, token);
                                                                                                                                                      return -1;
                                                                                                                                                    }
                                                                                                                                                    argUsed = 1;
                                                                                                                                                    v44 = atof(nextArg);
                                                                                                                                                    lame_set_athaa_sensitivity(gfp, LODWORD(v44));
                                                                                                                                                  }
                                                                                                                                                  else
                                                                                                                                                  {
                                                                                                                                                    nogap = 1;
                                                                                                                                                  }
                                                                                                                                                }
                                                                                                                                                else
                                                                                                                                                {
                                                                                                                                                  strcpy(outPath, nextArg);
                                                                                                                                                  argUsed = 1;
                                                                                                                                                }
                                                                                                                                              }
                                                                                                                                              else
                                                                                                                                              {
                                                                                                                                                nogap_tags = 1;
                                                                                                                                              }
                                                                                                                                            }
                                                                                                                                            else
                                                                                                                                            {
                                                                                                                                              argUsed = 1;
                                                                                                                                              v43 = atof(nextArg);
                                                                                                                                              update_interval = v43;
                                                                                                                                            }
                                                                                                                                          }
                                                                                                                                          else
                                                                                                                                          {
                                                                                                                                            argUsed = 1;
                                                                                                                                            fast = 0;
                                                                                                                                            cbr = 0;
                                                                                                                                            while ( !strcmp(nextArg, "fast") || !strcmp(nextArg, "cbr") )
                                                                                                                                            {
                                                                                                                                              if ( !strcmp(nextArg, "fast") && fast <= 0 )
                                                                                                                                                fast = 1;
                                                                                                                                              if ( !strcmp(nextArg, "cbr") && cbr <= 0 )
                                                                                                                                                cbr = 1;
                                                                                                                                              ++argUsed;
                                                                                                                                              if ( i + argUsed >= argc )
                                                                                                                                                v23 = (char *)&unk_8055592;
                                                                                                                                              else
                                                                                                                                                v23 = (&argv[i])[argUsed];
                                                                                                                                              nextArg = v23;
                                                                                                                                            }
                                                                                                                                            if ( presets_set(gfp, fast, cbr, nextArg, ProgramName) < 0 )
                                                                                                                                              return -1;
                                                                                                                                          }
                                                                                                                                        }
                                                                                                                                        else
                                                                                                                                        {
                                                                                                                                          silent = -10;
                                                                                                                                        }
                                                                                                                                      }
                                                                                                                                      else
                                                                                                                                      {
                                                                                                                                        silent = -5;
                                                                                                                                      }
                                                                                                                                    }
                                                                                                                                    else
                                                                                                                                    {
                                                                                                                                      silent = 10;
                                                                                                                                    }
                                                                                                                                  }
                                                                                                                                }
                                                                                                                                else
                                                                                                                                {
                                                                                                                                  argUsed = 1;
                                                                                                                                  k_2 = (int)(atof(nextArg) * 4.0);
                                                                                                                                  if ( k_2 < -32 )
                                                                                                                                    k_2 = -32;
                                                                                                                                  if ( k_2 > 31 )
                                                                                                                                    k_2 = 31;
                                                                                                                                  k_2 += k_2 < 0 ? 0x40 : 0;
                                                                                                                                  exp_nspsytune = lame_get_exp_nspsytune(gfp);
                                                                                                                                  lame_set_exp_nspsytune(gfp, (k_2 << 20) | exp_nspsytune);
                                                                                                                                }
                                                                                                                              }
                                                                                                                              else
                                                                                                                              {
                                                                                                                                argUsed = 1;
                                                                                                                                k_1 = (int)(atof(nextArg) * 4.0);
                                                                                                                                if ( k_1 < -32 )
                                                                                                                                  k_1 = -32;
                                                                                                                                if ( k_1 > 31 )
                                                                                                                                  k_1 = 31;
                                                                                                                                k_1 += k_1 < 0 ? 0x40 : 0;
                                                                                                                                v21 = lame_get_exp_nspsytune(gfp);
                                                                                                                                lame_set_exp_nspsytune(gfp, (k_1 << 14) | v21);
                                                                                                                              }
                                                                                                                            }
                                                                                                                            else
                                                                                                                            {
                                                                                                                              argUsed = 1;
                                                                                                                              k_0 = (int)(atof(nextArg) * 4.0);
                                                                                                                              if ( k_0 < -32 )
                                                                                                                                k_0 = -32;
                                                                                                                              if ( k_0 > 31 )
                                                                                                                                k_0 = 31;
                                                                                                                              k_0 += k_0 < 0 ? 0x40 : 0;
                                                                                                                              v20 = lame_get_exp_nspsytune(gfp);
                                                                                                                              lame_set_exp_nspsytune(gfp, (k_0 << 8) | v20);
                                                                                                                            }
                                                                                                                          }
                                                                                                                          else
                                                                                                                          {
                                                                                                                            argUsed = 1;
                                                                                                                            k = (int)(atof(nextArg) * 4.0);
                                                                                                                            if ( k < -32 )
                                                                                                                              k = -32;
                                                                                                                            if ( k > 31 )
                                                                                                                              k = 31;
                                                                                                                            k += k < 0 ? 0x40 : 0;
                                                                                                                            v19 = lame_get_exp_nspsytune(gfp);
                                                                                                                            lame_set_exp_nspsytune(gfp, (4 * k) | v19);
                                                                                                                          }
                                                                                                                        }
                                                                                                                        else
                                                                                                                        {
                                                                                                                          argUsed = 1;
                                                                                                                          v18 = atof(nextArg);
                                                                                                                          lame_set_msfix(gfp, COERCE_UNSIGNED_INT64(v18), HIDWORD(COERCE_UNSIGNED_INT64(v18)));
                                                                                                                        }
                                                                                                                      }
                                                                                                                      else
                                                                                                                      {
                                                                                                                        v34 = lame_get_exp_nspsytune(gfp) | 2;
                                                                                                                        lame_set_exp_nspsytune(gfp, v34);
                                                                                                                      }
                                                                                                                    }
                                                                                                                  }
                                                                                                                  else
                                                                                                                  {
                                                                                                                    argUsed = 1;
                                                                                                                    v33 = atoi(nextArg) != 0;
                                                                                                                    lame_set_useTemporal(gfp, v33);
                                                                                                                  }
                                                                                                                }
                                                                                                                else
                                                                                                                {
                                                                                                                  argUsed = 1;
                                                                                                                  v42 = atof(nextArg);
                                                                                                                  lame_set_interChRatio(gfp, LODWORD(v42));
                                                                                                                }
                                                                                                              }
                                                                                                              else
                                                                                                              {
                                                                                                                lame_set_useTemporal(gfp, 0);
                                                                                                              }
                                                                                                            }
                                                                                                            else
                                                                                                            {
                                                                                                              argUsed = 1;
                                                                                                              vald = atof(nextArg);
                                                                                                              if ( vald < 1.0 )
                                                                                                              {
                                                                                                                error_printf("Must specify compression ratio >= 1.0\n");
                                                                                                                return -1;
                                                                                                              }
                                                                                                              v41 = vald;
                                                                                                              lame_set_compression_ratio(gfp, LODWORD(v41));
                                                                                                            }
                                                                                                          }
                                                                                                          else
                                                                                                          {
                                                                                                            valc = atof(nextArg);
                                                                                                            argUsed = 1;
                                                                                                            if ( valc < 0.001 || valc > 50000.0 )
                                                                                                            {
                                                                                                              error_printf("Must specify highpass width with --highpass-width freq, freq >= 0.001 kHz\n");
                                                                                                              return -1;
                                                                                                            }
                                                                                                            lame_set_highpasswidth(gfp, (int)valc);
                                                                                                          }
                                                                                                        }
                                                                                                        else
                                                                                                        {
                                                                                                          valb = atof(nextArg);
                                                                                                          argUsed = 1;
                                                                                                          if ( valb >= 0.0 )
                                                                                                          {
                                                                                                            if ( valb < 0.001 || valb > 50000.0 )
                                                                                                            {
                                                                                                              error_printf("Must specify highpass with --highpass freq, freq >= 0.001 kHz\n");
                                                                                                              return -1;
                                                                                                            }
                                                                                                            if ( valb >= 16.0 )
                                                                                                              v17 = 1.0;
                                                                                                            else
                                                                                                              v17 = 1000.0;
                                                                                                            lame_set_highpassfreq(gfp, (int)(v17 * valb + 0.5));
                                                                                                          }
                                                                                                          else
                                                                                                          {
                                                                                                            lame_set_highpassfreq(gfp, -1);
                                                                                                          }
                                                                                                        }
                                                                                                      }
                                                                                                      else
                                                                                                      {
                                                                                                        vala = atof(nextArg);
                                                                                                        argUsed = 1;
                                                                                                        if ( vala < 0.001 || vala > 50000.0 )
                                                                                                        {
                                                                                                          error_printf("Must specify lowpass width with --lowpass-width freq, freq >= 0.001 kHz\n");
                                                                                                          return -1;
                                                                                                        }
                                                                                                        if ( vala >= 16.0 )
                                                                                                          v16 = 1.0;
                                                                                                        else
                                                                                                          v16 = 1000.0;
                                                                                                        lame_set_lowpasswidth(gfp, (int)(v16 * vala + 0.5));
                                                                                                      }
                                                                                                    }
                                                                                                    else
                                                                                                    {
                                                                                                      val = atof(nextArg);
                                                                                                      argUsed = 1;
                                                                                                      if ( val >= 0.0 )
                                                                                                      {
                                                                                                        if ( val < 0.001 || val > 50000.0 )
                                                                                                        {
                                                                                                          error_printf("Must specify lowpass with --lowpass freq, freq >= 0.001 kHz\n");
                                                                                                          return -1;
                                                                                                        }
                                                                                                        if ( val >= 50.0 )
                                                                                                          v15 = 1.0;
                                                                                                        else
                                                                                                          v15 = 1000.0;
                                                                                                        lame_set_lowpassfreq(gfp, (int)(v15 * val + 0.5));
                                                                                                      }
                                                                                                      else
                                                                                                      {
                                                                                                        lame_set_lowpassfreq(gfp, -1);
                                                                                                      }
                                                                                                    }
                                                                                                  }
                                                                                                  else
                                                                                                  {
                                                                                                    n = atoi(nextArg);
                                                                                                    v13 = 128000;
                                                                                                    if ( n <= 128000 )
                                                                                                      v13 = n;
                                                                                                    n = v13;
                                                                                                    v14 = 0;
                                                                                                    if ( n >= 0 )
                                                                                                      v14 = n;
                                                                                                    n = v14;
                                                                                                    id3tag_set_pad(gfp, v14);
                                                                                                    argUsed = 1;
                                                                                                  }
                                                                                                }
                                                                                                else
                                                                                                {
                                                                                                  id3tag_pad_v2(gfp);
                                                                                                }
                                                                                              }
                                                                                              else
                                                                                              {
                                                                                                id3tag_space_v1(gfp);
                                                                                              }
                                                                                            }
                                                                                            else
                                                                                            {
                                                                                              id3tag_v2_only(gfp);
                                                                                              id3tag_mode = 2;
                                                                                            }
                                                                                          }
                                                                                          else
                                                                                          {
                                                                                            id3tag_v1_only(gfp);
                                                                                            id3tag_mode = 1;
                                                                                          }
                                                                                        }
                                                                                        else
                                                                                        {
                                                                                          id3tag_add_v2(gfp);
                                                                                        }
                                                                                      }
                                                                                      else
                                                                                      {
                                                                                        ignore_tag_errors = 1;
                                                                                      }
                                                                                    }
                                                                                    else
                                                                                    {
                                                                                      argUsed = 1;
                                                                                      if ( set_id3_albumart(
                                                                                             gfp,
                                                                                             nextArg)
                                                                                        && !ignore_tag_errors )
                                                                                      {
                                                                                        return -1;
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                  else
                                                                                  {
                                                                                    argUsed = 1;
                                                                                    if ( id3_tag(
                                                                                           gfp,
                                                                                           118,
                                                                                           TENC_RAW,
                                                                                           nextArg)
                                                                                      && silent <= 9 )
                                                                                    {
                                                                                      error_printf(
                                                                                        "Invalid field value: '%s'. Ignored\n",
                                                                                        nextArg);
                                                                                    }
                                                                                  }
                                                                                }
                                                                                else
                                                                                {
                                                                                  ret_0 = id3_tag(
                                                                                            gfp,
                                                                                            103,
                                                                                            TENC_RAW,
                                                                                            nextArg);
                                                                                  argUsed = 1;
                                                                                  if ( ret_0 && !ignore_tag_errors )
                                                                                  {
                                                                                    if ( ret_0 == -1 )
                                                                                    {
                                                                                      error_printf(
                                                                                        "Unknown ID3v1 genre number: '%s'.\n",
                                                                                        nextArg);
                                                                                      return -1;
                                                                                    }
                                                                                    if ( ret_0 != -2 )
                                                                                    {
                                                                                      error_printf("Internal error.\n");
                                                                                      return -1;
                                                                                    }
                                                                                    if ( id3tag_mode == 1 )
                                                                                    {
                                                                                      error_printf(
                                                                                        "Unknown ID3v1 genre: '%s'.\n",
                                                                                        nextArg);
                                                                                      return -1;
                                                                                    }
                                                                                    if ( id3tag_mode != 2 && silent <= 9 )
                                                                                      error_printf(
                                                                                        "Unknown ID3v1 genre: '%s'.  Sett"
                                                                                        "ing ID3v1 genre to 'Other'\n",
                                                                                        nextArg);
                                                                                  }
                                                                                }
                                                                              }
                                                                              else
                                                                              {
                                                                                ret = id3_tag(
                                                                                        gfp,
                                                                                        110,
                                                                                        TENC_RAW,
                                                                                        nextArg);
                                                                                argUsed = 1;
                                                                                if ( ret && !ignore_tag_errors )
                                                                                {
                                                                                  if ( id3tag_mode == 1 )
                                                                                  {
                                                                                    error_printf(
                                                                                      "The track number has to be between"
                                                                                      " 1 and 255 for ID3v1.\n");
                                                                                    return -1;
                                                                                  }
                                                                                  if ( id3tag_mode != 2 && silent <= 9 )
                                                                                    error_printf(
                                                                                      "The track number has to be between"
                                                                                      " 1 and 255 for ID3v1, ignored for ID3v1.\n");
                                                                                }
                                                                              }
                                                                            }
                                                                            else
                                                                            {
                                                                              argUsed = 1;
                                                                              id3_tag(gfp, 99, TENC_RAW, nextArg);
                                                                            }
                                                                          }
                                                                          else
                                                                          {
                                                                            argUsed = 1;
                                                                            id3_tag(gfp, 121, TENC_RAW, nextArg);
                                                                          }
                                                                        }
                                                                        else
                                                                        {
                                                                          argUsed = 1;
                                                                          id3_tag(gfp, 108, TENC_RAW, nextArg);
                                                                        }
                                                                      }
                                                                      else
                                                                      {
                                                                        argUsed = 1;
                                                                        id3_tag(gfp, 97, TENC_RAW, nextArg);
                                                                      }
                                                                    }
                                                                    else
                                                                    {
                                                                      argUsed = 1;
                                                                      id3_tag(gfp, 116, TENC_RAW, nextArg);
                                                                    }
                                                                  }
                                                                  else
                                                                  {
                                                                    brhist_0 = 0;
                                                                  }
                                                                }
                                                                else
                                                                {
                                                                  print_clipping_info = 1;
                                                                  lame_set_decode_on_the_fly(gfp, 1);
                                                                }
                                                              }
                                                              else
                                                              {
                                                                noreplaygain = 1;
                                                                lame_set_findReplayGain(gfp, 0);
                                                              }
                                                            }
                                                            else
                                                            {
                                                              lame_set_decode_on_the_fly(gfp, 1);
                                                              lame_set_findReplayGain(gfp, 1);
                                                            }
                                                          }
                                                          else
                                                          {
                                                            lame_set_findReplayGain(gfp, 1);
                                                          }
                                                        }
                                                        else
                                                        {
                                                          lame_set_free_format(gfp, 1);
                                                        }
                                                      }
                                                      else
                                                      {
                                                        argUsed = 1;
                                                        if ( !strcmp(nextArg, "mmx") )
                                                          lame_set_asm_optimizations(gfp, 1, 0);
                                                        if ( !strcmp(nextArg, "3dnow") )
                                                          lame_set_asm_optimizations(gfp, 2, 0);
                                                        if ( !strcmp(nextArg, "sse") )
                                                          lame_set_asm_optimizations(gfp, 3, 0);
                                                      }
                                                    }
                                                    else
                                                    {
                                                      argUsed = 1;
                                                      v40 = atof(nextArg);
                                                      lame_set_scale_right(gfp, LODWORD(v40));
                                                    }
                                                  }
                                                  else
                                                  {
                                                    argUsed = 1;
                                                    v39 = atof(nextArg);
                                                    lame_set_scale_left(gfp, LODWORD(v39));
                                                  }
                                                }
                                                else
                                                {
                                                  argUsed = 1;
                                                  v38 = atof(nextArg);
                                                  lame_set_scale(gfp, LODWORD(v38));
                                                }
                                              }
                                              else
                                              {
                                                lame_set_strict_ISO(gfp, 1);
                                              }
                                            }
                                            else
                                            {
                                              lame_set_disable_reservoir(gfp, 1);
                                            }
                                          }
                                          else
                                          {
                                            mp3_delay = atoi(nextArg);
                                            mp3_delay_set = 1;
                                            argUsed = 1;
                                          }
                                        }
                                        else
                                        {
                                          flush_write = 1;
                                        }
                                      }
                                      else
                                      {
                                        lame_set_decode_only(gfp, 1);
                                      }
                                    }
                                    else
                                    {
                                      if ( presets_set(gfp, 0, 0, token, ProgramName) < 0 )
                                        return -1;
                                      error_printf("Warning: --voice is deprecated, use --preset voice instead!");
                                    }
                                  }
                                  else
                                  {
                                    if ( presets_set(gfp, 0, 0, token, ProgramName) < 0 )
                                      return -1;
                                    error_printf("Warning: --phone is deprecated, use --preset phone instead!");
                                  }
                                }
                                else
                                {
                                  input_format = sf_mp3;
                                }
                              }
                              else
                              {
                                input_format = sf_mp2;
                              }
                            }
                            else
                            {
                              input_format = sf_mp1;
                            }
                          }
                          else
                          {
                            in_endian = ByteOrderBigEndian;
                          }
                        }
                        else
                        {
                          in_endian = ByteOrderLittleEndian;
                        }
                      }
                      else
                      {
                        in_signed = 0;
                      }
                    }
                    else
                    {
                      in_signed = 1;
                    }
                  }
                  else
                  {
                    argUsed = 1;
                    in_bitwidth = atoi(nextArg);
                  }
                }
                else
                {
                  lame_set_preset(gfp, 1000);
                }
              }
              else
              {
                argUsed = 1;
                lame_set_VBR(gfp, 3);
                v31 = atoi(nextArg);
                lame_set_VBR_mean_bitrate_kbps(gfp, v31);
                if ( lame_get_VBR_mean_bitrate_kbps(gfp) > 7999 )
                {
                  v32 = (lame_get_VBR_mean_bitrate_kbps(gfp) + 500) / 1000;
                  lame_set_VBR_mean_bitrate_kbps(gfp, v32);
                }
                if ( lame_get_VBR_mean_bitrate_kbps(gfp) > 319 )
                  VBR_mean_bitrate_kbps = 320;
                else
                  VBR_mean_bitrate_kbps = lame_get_VBR_mean_bitrate_kbps(gfp);
                lame_set_VBR_mean_bitrate_kbps(gfp, VBR_mean_bitrate_kbps);
                if ( lame_get_VBR_mean_bitrate_kbps(gfp) <= 8 )
                  v11 = 8;
                else
                  v11 = lame_get_VBR_mean_bitrate_kbps(gfp);
                lame_set_VBR_mean_bitrate_kbps(gfp, v11);
              }
            }
            else
            {
              lame_set_VBR(gfp, 0);
            }
          }
          else
          {
            lame_set_VBR(gfp, 4);
          }
        }
        else
        {
          lame_set_VBR(gfp, 2);
        }
      }
      else
      {
        argUsed = 1;
        v9 = atof(nextArg);
        v30 = resample_rate(v9);
        lame_set_out_samplerate(gfp, v30);
      }
      i += argUsed;
    }
    else if ( nogap )
    {
      if ( !num_nogap || *num_nogap <= count_nogap )
      {
        error_printf(
          "Error: 'nogap option'.  Calling program does not allow nogap option, or\n"
          "you have exceeded maximum number of input files for the nogap option\n");
        *num_nogap = -1;
        return -1;
      }
      v27 = argv[i];
      v28 = nogap_inPath[count_nogap++];
      strncpy(v28, v27, 0x1001u);
      input_file = 1;
    }
    else if ( *inPath )
    {
      if ( *outPath )
      {
        error_printf("%s: excess arg %s\n", ProgramName, argv[i]);
        return -1;
      }
      strncpy(outPath, argv[i], 0x1001u);
    }
    else
    {
      strncpy(inPath, argv[i], 0x1001u);
      input_file = 1;
    }
  }
  if ( input_file )
  {
    if ( *inPath == 45 )
    {
      v29 = silent;
      if ( silent <= 0 )
        v29 = 1;
      silent = v29;
    }
    if ( !*outPath && !count_nogap )
    {
      if ( *inPath == 45 )
      {
        memcpy(outPath, "-", 2u);
      }
      else
      {
        strncpy(outPath, inPath, 0xFFDu);
        if ( lame_get_decode_only(gfp) )
          strcat(outPath, ".wav");
        else
          strcat(outPath, ".mp3");
      }
    }
    if ( !noreplaygain )
      lame_set_findReplayGain(gfp, 1);
    if ( nogap && lame_get_bWriteVbrTag(gfp) && !nogap_tags )
    {
      console_printf("Note: Disabling VBR Xing/Info tag since it interferes with --nogap\n");
      lame_set_bWriteVbrTag(gfp, 0);
    }
    if ( *outPath == 45 )
      lame_set_bWriteVbrTag(gfp, 0);
    if ( input_format == sf_unknown )
      input_format = filename_to_type(inPath);
    if ( input_format == sf_ogg )
    {
LABEL_50:
      error_printf("sorry, vorbis support in LAME is deprecated.\n");
      return -1;
    }
    if ( autoconvert || lame_get_mode(gfp) != 3 )
      lame_set_num_channels(gfp, 2);
    else
      lame_set_num_channels(gfp, 1);
    if ( lame_get_free_format(gfp) && (lame_get_brate(gfp) <= 7 || lame_get_brate(gfp) > 640) )
    {
      error_printf("For free format, specify a bitrate between 8 and 640 kbps\n");
      error_printf("with the -b <bitrate> option\n");
      return -1;
    }
    else
    {
      if ( num_nogap )
        *num_nogap = count_nogap;
      return 0;
    }
  }
  else
  {
    usage(Console_IO.Console_fp, ProgramName);
    return -1;
  }
}
// 804A0BC: using guessed type int __cdecl lame_set_num_channels(_DWORD, _DWORD);
// 804A0CC: using guessed type int __cdecl id3tag_v1_only(_DWORD);
// 804A0DC: using guessed type int __cdecl id3tag_v2_only(_DWORD);
// 804A12C: using guessed type int __cdecl lame_set_scale_right(_DWORD, _DWORD);
// 804A14C: using guessed type int __cdecl lame_set_decode_only(_DWORD, _DWORD);
// 804A17C: using guessed type int __cdecl id3tag_init(_DWORD);
// 804A19C: using guessed type int __isoc99_sscanf(_DWORD, const char *, ...);
// 804A1FC: using guessed type int __cdecl lame_set_error_protection(_DWORD, _DWORD);
// 804A2DC: using guessed type int __cdecl lame_set_decode_on_the_fly(_DWORD, _DWORD);
// 804A2FC: using guessed type int __cdecl lame_set_VBR_hard_min(_DWORD, _DWORD);
// 804A30C: using guessed type int __cdecl lame_get_decode_only(_DWORD);
// 804A32C: using guessed type int __cdecl lame_set_strict_ISO(_DWORD, _DWORD);
// 804A33C: using guessed type int __cdecl lame_set_useTemporal(_DWORD, _DWORD);
// 804A34C: using guessed type int __cdecl lame_set_force_ms(_DWORD, _DWORD);
// 804A35C: using guessed type int __cdecl lame_set_compression_ratio(_DWORD, _DWORD);
// 804A38C: using guessed type int __cdecl lame_set_VBR_quality(_DWORD, _DWORD);
// 804A39C: using guessed type int __cdecl lame_set_disable_reservoir(_DWORD, _DWORD);
// 804A41C: using guessed type int __cdecl lame_set_VBR_min_bitrate_kbps(_DWORD, _DWORD);
// 804A42C: using guessed type int __cdecl lame_set_free_format(_DWORD, _DWORD);
// 804A46C: using guessed type int __cdecl lame_set_exp_nspsytune(_DWORD, _DWORD);
// 804A4BC: using guessed type int __cdecl lame_set_VBR(_DWORD, _DWORD);
// 804A4DC: using guessed type int __cdecl lame_get_bWriteVbrTag(_DWORD);
// 804A50C: using guessed type int __cdecl lame_set_msfix(_DWORD, _DWORD, _DWORD);
// 804A51C: using guessed type int __cdecl lame_get_VBR(_DWORD);
// 804A52C: using guessed type int __cdecl lame_set_athaa_sensitivity(_DWORD, _DWORD);
// 804A56C: using guessed type int __cdecl lame_set_out_samplerate(_DWORD, _DWORD);
// 804A57C: using guessed type int __cdecl lame_set_asm_optimizations(_DWORD, _DWORD, _DWORD);
// 804A5BC: using guessed type int __cdecl lame_set_brate(_DWORD, _DWORD);
// 804A5EC: using guessed type int __cdecl lame_set_findReplayGain(_DWORD, _DWORD);
// 804A63C: using guessed type int __cdecl lame_set_highpassfreq(_DWORD, _DWORD);
// 804A66C: using guessed type int __cdecl lame_set_VBR_mean_bitrate_kbps(_DWORD, _DWORD);
// 804A67C: using guessed type int __cdecl lame_set_quality(_DWORD, _DWORD);
// 804A6AC: using guessed type int __cdecl lame_get_mode(_DWORD);
// 804A71C: using guessed type int __cdecl id3tag_set_pad(_DWORD, _DWORD);
// 804A74C: using guessed type int __cdecl lame_set_VBR_max_bitrate_kbps(_DWORD, _DWORD);
// 804A77C: using guessed type int __cdecl lame_set_original(_DWORD, _DWORD);
// 804A78C: using guessed type int __cdecl id3tag_pad_v2(_DWORD);
// 804A7BC: using guessed type int __cdecl id3tag_add_v2(_DWORD);
// 804A7DC: using guessed type int __cdecl lame_set_bWriteVbrTag(_DWORD, _DWORD);
// 804A80C: using guessed type int __cdecl id3tag_genre_list(_DWORD, _DWORD);
// 804A81C: using guessed type int __cdecl lame_get_exp_nspsytune(_DWORD);
// 804A85C: using guessed type int __cdecl lame_set_interChRatio(_DWORD, _DWORD);
// 804A88C: using guessed type int __cdecl lame_set_preset(_DWORD, _DWORD);
// 804A89C: using guessed type int __cdecl lame_get_free_format(_DWORD);
// 804A8AC: using guessed type int __cdecl lame_set_emphasis(_DWORD, _DWORD);
// 804A8BC: using guessed type int __cdecl lame_set_mode(_DWORD, _DWORD);
// 804A8FC: using guessed type int __cdecl lame_set_experimentalY(_DWORD, _DWORD);
// 804A93C: using guessed type int __cdecl lame_set_in_samplerate(_DWORD, _DWORD);
// 804A99C: using guessed type int __cdecl lame_set_lowpassfreq(_DWORD, _DWORD);
// 804A9AC: using guessed type int __cdecl lame_set_scale_left(_DWORD, _DWORD);
// 804A9BC: using guessed type int __cdecl lame_get_brate(_DWORD);
// 804A9DC: using guessed type int __cdecl lame_set_highpasswidth(_DWORD, _DWORD);
// 804AA0C: using guessed type int __cdecl lame_set_scale(_DWORD, _DWORD);
// 804AA4C: using guessed type int __cdecl lame_set_copyright(_DWORD, _DWORD);
// 804AA5C: using guessed type int __cdecl lame_set_lowpasswidth(_DWORD, _DWORD);
// 804AA8C: using guessed type int __cdecl id3tag_space_v1(_DWORD);
// 804AABC: using guessed type int __cdecl lame_get_VBR_mean_bitrate_kbps(_DWORD);

//----- (08052914) --------------------------------------------------------
int __cdecl ReadByte(FILE *fp)
{
  unsigned __int8 v1; // al
  int result; // [esp+1Ch] [ebp-Ch]

  v1 = _IO_getc(fp);
  result = v1;
  if ( (v1 & 0x80) != 0 )
    return v1 - 256;
  return result;
}

//----- (08052945) --------------------------------------------------------
int __cdecl Read16BitsLowHigh(FILE *fp)
{
  unsigned __int8 v1; // al
  int result; // [esp+14h] [ebp-14h]
  int first; // [esp+1Ch] [ebp-Ch]

  first = (unsigned __int8)_IO_getc(fp);
  v1 = _IO_getc(fp);
  result = first + (v1 << 8);
  if ( (((_WORD)first + (v1 << 8)) & 0x8000) != 0 )
    result -= 0x10000;
  return result;
}

//----- (08052995) --------------------------------------------------------
int __cdecl Read16BitsHighLow(FILE *fp)
{
  unsigned __int8 v1; // al
  int result; // [esp+14h] [ebp-14h]
  int first; // [esp+1Ch] [ebp-Ch]

  first = (unsigned __int8)_IO_getc(fp);
  v1 = _IO_getc(fp);
  result = v1 + (first << 8);
  if ( ((v1 + ((_WORD)first << 8)) & 0x8000) != 0 )
    result -= 0x10000;
  return result;
}

//----- (080529E5) --------------------------------------------------------
void __cdecl Write8Bits(FILE *fp, int i)
{
  _IO_putc((unsigned __int8)i, fp);
}

//----- (08052A02) --------------------------------------------------------
void __cdecl Write16BitsLowHigh(FILE *fp, int i)
{
  _IO_putc((unsigned __int8)i, fp);
  _IO_putc(BYTE1(i), fp);
}

//----- (08052A37) --------------------------------------------------------
void __cdecl Write16BitsHighLow(FILE *fp, int i)
{
  _IO_putc(BYTE1(i), fp);
  _IO_putc((unsigned __int8)i, fp);
}

//----- (08052A6C) --------------------------------------------------------
int __cdecl Read24BitsHighLow(FILE *fp)
{
  int result; // [esp+10h] [ebp-18h]
  int second; // [esp+18h] [ebp-10h]
  int first; // [esp+1Ch] [ebp-Ch]

  first = (unsigned __int8)_IO_getc(fp);
  second = (unsigned __int8)_IO_getc(fp);
  result = (unsigned __int8)_IO_getc(fp) + (first << 16) + (second << 8);
  if ( (result & 0x800000) != 0 )
    result -= 0x1000000;
  return result;
}

//----- (08052ADA) --------------------------------------------------------
int __cdecl Read32Bits(FILE *fp)
{
  int first; // [esp+1Ch] [ebp-Ch]

  first = (unsigned __int16)Read16BitsLowHigh(fp);
  return first + ((unsigned __int16)Read16BitsLowHigh(fp) << 16);
}

//----- (08052B17) --------------------------------------------------------
int __cdecl Read32BitsHighLow(FILE *fp)
{
  int first; // [esp+1Ch] [ebp-Ch]

  first = (unsigned __int16)Read16BitsHighLow(fp);
  return (unsigned __int16)Read16BitsHighLow(fp) + (first << 16);
}

//----- (08052B54) --------------------------------------------------------
void __cdecl Write32Bits(FILE *fp, int i)
{
  Write16BitsLowHigh(fp, (unsigned __int16)i);
  Write16BitsLowHigh(fp, HIWORD(i));
}

//----- (08052B88) --------------------------------------------------------
void __cdecl Write32BitsLowHigh(FILE *fp, int i)
{
  Write16BitsLowHigh(fp, (unsigned __int16)i);
  Write16BitsLowHigh(fp, HIWORD(i));
}

//----- (08052BBC) --------------------------------------------------------
void __cdecl Write32BitsHighLow(FILE *fp, int i)
{
  Write16BitsHighLow(fp, HIWORD(i));
  Write16BitsHighLow(fp, (unsigned __int16)i);
}

//----- (08052BF0) --------------------------------------------------------
void __cdecl ReadBytes(FILE *fp, char *p, int n)
{
  while ( (feof(fp) == 0) & (n-- > 0) )
    *p++ = _IO_getc(fp);
}

//----- (08052C31) --------------------------------------------------------
void __cdecl ReadBytesSwapped(FILE *fp, char *p, int n)
{
  char *i; // ebx
  char *j; // ebx
  char na; // [esp+28h] [ebp+10h]

  for ( i = p; (feof(fp) == 0) & (n-- > 0); ++i )
    *i = _IO_getc(fp);
  for ( j = i - 1; p < j; --j )
  {
    na = *p;
    *p = *j;
    *j = na;
    ++p;
  }
}

//----- (08052C9E) --------------------------------------------------------
void __cdecl WriteBytes(FILE *fp, char *p, int n)
{
  int v3; // eax

  while ( n-- > 0 )
  {
    v3 = *p++;
    _IO_putc(v3, fp);
  }
}

//----- (08052CD3) --------------------------------------------------------
void __cdecl WriteBytesSwapped(FILE *fp, char *p, int n)
{
  int v3; // eax
  char *pa; // [esp+24h] [ebp+Ch]

  for ( pa = &p[n - 1]; n-- > 0; --pa )
  {
    v3 = *pa;
    _IO_putc(v3, fp);
  }
}

//----- (08052D11) --------------------------------------------------------
double __cdecl ConvertFromIeeeExtended(char *bytes)
{
  double f; // [esp+28h] [ebp-20h]
  double fa; // [esp+28h] [ebp-20h]
  int loMant; // [esp+34h] [ebp-14h]
  int hiMant; // [esp+38h] [ebp-10h]
  int expon; // [esp+3Ch] [ebp-Ch]
  int expona; // [esp+3Ch] [ebp-Ch]

  expon = ((*bytes & 0x7F) << 8) | (unsigned __int8)bytes[1];
  hiMant = (unsigned __int16)(bytes[4] << 8) | ((unsigned __int8)bytes[3] << 16) | (bytes[2] << 24) | (unsigned __int8)bytes[5];
  loMant = (unsigned __int16)(bytes[8] << 8) | ((unsigned __int8)bytes[7] << 16) | (bytes[6] << 24) | (unsigned __int8)bytes[9];
  if ( expon || hiMant || loMant )
  {
    if ( expon == 0x7FFF )
    {
      f = INFINITY;
    }
    else
    {
      expona = expon - 16414;
      fa = ldexp((double)(unsigned int)hiMant, expona);
      f = ldexp((double)(unsigned int)loMant, expona - 32) + fa;
    }
  }
  else
  {
    f = 0.0;
  }
  if ( *bytes >= 0 )
    return f;
  else
    return -f;
}

//----- (08052E8B) --------------------------------------------------------
double __cdecl ReadIeeeExtendedHighLow(FILE *fp)
{
  char bytes[10]; // [esp+22h] [ebp-16h] BYREF
  unsigned int v3; // [esp+2Ch] [ebp-Ch]

  v3 = __readgsdword(0x14u);
  ReadBytes(fp, bytes, 10);
  return ConvertFromIeeeExtended(bytes);
}

//----- (08052EDC) --------------------------------------------------------
void __cdecl ts_calc_times(
        timestatus_t *const tstime,
        const int sample_freq,
        const int frameNum,
        const int totalframes,
        const int framesize)
{
  if ( frameNum <= 0 || tstime->elapsed_time <= 0.0 )
  {
    tstime->estimated_time = 0.0;
    tstime->speed_index = 0.0;
  }
  else
  {
    tstime->estimated_time = tstime->elapsed_time * (long double)totalframes / (long double)frameNum;
    tstime->speed_index = (long double)(frameNum * framesize) / ((long double)sample_freq * tstime->elapsed_time);
  }
}

//----- (08052F47) --------------------------------------------------------
void __cdecl ts_time_decompose(const unsigned int time_in_sec, const char padded_char)
{
  unsigned int sec; // [esp+44h] [ebp-14h]
  unsigned int min; // [esp+48h] [ebp-10h]
  unsigned int hour; // [esp+4Ch] [ebp-Ch]

  hour = time_in_sec / 0xE10;
  min = time_in_sec / 0x3C % 0x3C;
  sec = time_in_sec % 0x3C;
  if ( time_in_sec / 0xE10 )
  {
    if ( hour > 0x63 )
      console_printf("%6lu h%c", hour, padded_char);
    else
      console_printf("%2lu:%02u:%02u%c", hour, min, sec, padded_char);
  }
  else
  {
    console_printf("   %2u:%02u%c", min, sec, padded_char);
  }
}

//----- (0805303F) --------------------------------------------------------
void __cdecl timestatus(const lame_global_flags *const gfp)
{
  const char *v1; // eax
  double delta; // [esp+38h] [ebp-30h]
  double deltaa; // [esp+38h] [ebp-30h]
  double tmx; // [esp+40h] [ebp-28h]
  double tmxa; // [esp+40h] [ebp-28h]
  int framesize; // [esp+4Ch] [ebp-1Ch]
  int totalframes; // [esp+50h] [ebp-18h]
  int frameNum; // [esp+54h] [ebp-14h]
  int samp_rate; // [esp+58h] [ebp-10h]
  int percent; // [esp+5Ch] [ebp-Ch]

  samp_rate = lame_get_out_samplerate(gfp);
  frameNum = lame_get_frameNum(gfp);
  totalframes = lame_get_totalframes(gfp);
  framesize = lame_get_framesize(gfp);
  if ( totalframes < frameNum )
    totalframes = frameNum;
  if ( !frameNum )
  {
    real_time_3105.last_time = GetRealTime();
    proc_time_3106.last_time = GetCPUTime();
    real_time_3105.elapsed_time = 0.0;
    proc_time_3106.elapsed_time = 0.0;
  }
  tmx = GetRealTime();
  delta = tmx - real_time_3105.last_time;
  if ( delta < 0.0 )
    delta = 0.0;
  real_time_3105.elapsed_time = real_time_3105.elapsed_time + delta;
  real_time_3105.last_time = tmx;
  tmxa = GetCPUTime();
  deltaa = tmxa - proc_time_3106.last_time;
  if ( deltaa < 0.0 )
    deltaa = 0.0;
  proc_time_3106.elapsed_time = proc_time_3106.elapsed_time + deltaa;
  proc_time_3106.last_time = tmxa;
  if ( frameNum || init_3108 )
  {
    if ( frameNum > 0 )
      init_3108 = 0;
    ts_calc_times(&real_time_3105, samp_rate, frameNum, totalframes, framesize);
    ts_calc_times(&proc_time_3106, samp_rate, frameNum, totalframes, framesize);
    if ( frameNum >= totalframes )
      percent = 100;
    else
      percent = (int)((long double)frameNum * 100.0 / (long double)totalframes + 0.5);
    console_printf("\r%6i/%-6i", frameNum, totalframes);
    if ( percent > 99 )
      v1 = "(%3.3d%%)|";
    else
      v1 = " (%2d%%)|";
    console_printf(v1, percent);
    ts_time_decompose((__int64)proc_time_3106.elapsed_time, 47);
    ts_time_decompose((__int64)proc_time_3106.estimated_time, 124);
    ts_time_decompose((__int64)real_time_3105.elapsed_time, 47);
    ts_time_decompose((__int64)real_time_3105.estimated_time, 124);
    if ( proc_time_3106.speed_index > 1.0 )
      console_printf("%#9.5gx|", proc_time_3106.speed_index);
    else
      console_printf("%9.4fx|", proc_time_3106.speed_index);
    ts_time_decompose((__int64)(real_time_3105.estimated_time - real_time_3105.elapsed_time), 32);
  }
  else
  {
    console_printf(
      "\r    Frame          |  CPU time/estim | REAL time/estim | play/CPU |    ETA \n"
      "     0/       ( 0%%)|    0:00/     :  |    0:00/     :  |         x|     :  \r");
    init_3108 = 1;
  }
}
// 804A5FC: using guessed type int __cdecl lame_get_framesize(_DWORD);
// 804A6FC: using guessed type int __cdecl lame_get_totalframes(_DWORD);
// 804A84C: using guessed type int __cdecl lame_get_frameNum(_DWORD);
// 804A95C: using guessed type int __cdecl lame_get_out_samplerate(_DWORD);

//----- (08053376) --------------------------------------------------------
void timestatus_finish()
{
  console_printf("\n");
}

//----- (0805338A) --------------------------------------------------------
void __cdecl encoder_progress_begin(const lame_global_flags *gf, const char *inPath, const char *outPath)
{
  const char *v3; // esi
  size_t v4; // ebx
  const char *v5; // ebx
  const char *v6; // eax
  unsigned int VBR; // eax
  int quality; // edi
  const char *v9; // esi
  int force_ms; // ebx
  int mode; // eax
  const char *v12; // edi
  int v13; // esi
  int v14; // ebx
  int v15; // eax
  int v16; // ebx
  const char *v17; // edi
  int v18; // esi
  int v19; // eax
  int v20; // ebx
  const char *v21; // edi
  int v22; // esi
  int v23; // eax
  double VBR_quality; // [esp+28h] [ebp-60h]
  int v25; // [esp+34h] [ebp-54h]
  double v26; // [esp+38h] [ebp-50h]
  int VBR_mean_bitrate_kbps; // [esp+44h] [ebp-44h]
  double v28; // [esp+48h] [ebp-40h]
  int v29; // [esp+50h] [ebp-38h]
  int brate; // [esp+54h] [ebp-34h]
  double v31; // [esp+58h] [ebp-30h]
  int v32; // [esp+64h] [ebp-24h]
  int out_samplerate; // [esp+68h] [ebp-20h]

  if ( silent <= 9 )
  {
    lame_print_config(gf);
    if ( !strcmp(outPath, "-") )
      v3 = "<stdout>";
    else
      v3 = outPath;
    v4 = strlen(inPath);
    if ( v4 + strlen(outPath) > 0x41 )
      v5 = "\n     ";
    else
      v5 = (const char *)&unk_8059978;
    if ( !strcmp(inPath, "-") )
      v6 = "<stdin>";
    else
      v6 = inPath;
    console_printf("Encoding %s%s to %s\n", v6, v5, v3);
    out_samplerate = lame_get_out_samplerate(gf);
    console_printf("Encoding as %g kHz ", (double)((long double)out_samplerate * 0.001));
    VBR = lame_get_VBR(gf);
    if ( VBR == 2 )
    {
      quality = lame_get_quality(gf);
      VBR_quality = lame_get_VBR_quality(gf);
      if ( lame_get_out_samplerate(gf) > 15999 )
        v9 = (const char *)&unk_8059978;
      else
        v9 = ".5";
      v25 = 2 - lame_get_version(gf);
      force_ms = lame_get_force_ms(gf);
      mode = lame_get_mode(gf);
      console_printf(
        "%s MPEG-%u%s Layer III VBR(q=%g) qval=%i\n",
        mode_names_3185[force_ms][mode],
        v25,
        v9,
        VBR_quality,
        quality);
      goto LABEL_34;
    }
    if ( VBR > 2 )
    {
      if ( VBR == 3 )
      {
        v16 = lame_get_quality(gf);
        VBR_mean_bitrate_kbps = lame_get_VBR_mean_bitrate_kbps(gf);
        v28 = (long double)(int)(lame_get_compression_ratio(gf) * 10.0 + 0.5) * 0.1;
        if ( lame_get_out_samplerate(gf) > 15999 )
          v17 = (const char *)&unk_8059978;
        else
          v17 = ".5";
        v29 = 2 - lame_get_version(gf);
        v18 = lame_get_force_ms(gf);
        v19 = lame_get_mode(gf);
        console_printf(
          "%s MPEG-%u%s Layer III (%gx) average %d kbps qval=%i\n",
          mode_names_3185[v18][v19],
          v29,
          v17,
          v28,
          VBR_mean_bitrate_kbps,
          v16);
        goto LABEL_34;
      }
      if ( VBR != 4 )
        goto LABEL_30;
    }
    else if ( VBR != 1 )
    {
LABEL_30:
      v20 = lame_get_quality(gf);
      brate = lame_get_brate(gf);
      v31 = (long double)(int)(lame_get_compression_ratio(gf) * 10.0 + 0.5) * 0.1;
      if ( lame_get_out_samplerate(gf) > 15999 )
        v21 = (const char *)&unk_8059978;
      else
        v21 = ".5";
      v32 = 2 - lame_get_version(gf);
      v22 = lame_get_force_ms(gf);
      v23 = lame_get_mode(gf);
      console_printf(
        "%s MPEG-%u%s Layer III (%gx) %3d kbps qval=%i\n",
        mode_names_3185[v22][v23],
        v32,
        v21,
        v31,
        brate,
        v20);
LABEL_34:
      if ( silent < -9 )
        lame_print_internals(gf);
      return;
    }
    v26 = lame_get_VBR_quality(gf);
    if ( lame_get_out_samplerate(gf) > 15999 )
      v12 = (const char *)&unk_8059978;
    else
      v12 = ".5";
    v13 = 2 - lame_get_version(gf);
    v14 = lame_get_force_ms(gf);
    v15 = lame_get_mode(gf);
    console_printf("%s MPEG-%u%s Layer III VBR(q=%g)\n", mode_names_3185[v14][v15], v13, v12, v26);
    goto LABEL_34;
  }
}
// 804A23C: using guessed type long double __cdecl lame_get_compression_ratio(_DWORD);
// 804A4CC: using guessed type int __cdecl lame_print_config(_DWORD);
// 804A51C: using guessed type int __cdecl lame_get_VBR(_DWORD);
// 804A58C: using guessed type int __cdecl lame_get_quality(_DWORD);
// 804A6AC: using guessed type int __cdecl lame_get_mode(_DWORD);
// 804A7AC: using guessed type int __cdecl lame_get_version(_DWORD);
// 804A8DC: using guessed type int __cdecl lame_print_internals(_DWORD);
// 804A91C: using guessed type long double __cdecl lame_get_VBR_quality(_DWORD);
// 804A95C: using guessed type int __cdecl lame_get_out_samplerate(_DWORD);
// 804A98C: using guessed type int __cdecl lame_get_force_ms(_DWORD);
// 804A9BC: using guessed type int __cdecl lame_get_brate(_DWORD);
// 804AABC: using guessed type int __cdecl lame_get_VBR_mean_bitrate_kbps(_DWORD);

//----- (080537BE) --------------------------------------------------------
void __cdecl encoder_progress(const lame_global_flags *gf)
{
  double dif; // [esp+18h] [ebp-20h]
  int frames; // [esp+2Ch] [ebp-Ch]

  if ( silent <= 0 )
  {
    frames = lame_get_frameNum(gf);
    if ( update_interval > 0.0 )
    {
      if ( frames )
      {
        if ( frames != 9 )
        {
          dif = (double)GetRealTime() - last_time_3286;
          if ( dif >= 0.0 && update_interval > (long double)dif )
            return;
        }
      }
      last_time_3286 = GetRealTime();
    }
    else if ( frames % 100 )
    {
      return;
    }
    if ( brhist_0 )
      brhist_jump_back();
    timestatus(gf);
    if ( brhist_0 )
      brhist_disp(gf);
    console_flush();
  }
}
// 804A84C: using guessed type int __cdecl lame_get_frameNum(_DWORD);

//----- (080538AF) --------------------------------------------------------
void __cdecl encoder_progress_end(const lame_global_flags *gf)
{
  if ( silent <= 0 )
  {
    if ( brhist_0 )
      brhist_jump_back();
    timestatus(gf);
    if ( brhist_0 )
      brhist_disp(gf);
    timestatus_finish();
  }
}

//----- (080538F2) --------------------------------------------------------
void __cdecl decoder_progress(const mp3data_struct *const mp3data)
{
  int v1; // eax
  int v2; // edx
  int v3; // eax
  const char *v4; // eax
  int curr; // [esp+1Ch] [ebp-Ch]

  console_printf("\rFrame#%6i/%-6i %3i kbps", mp3data->framenum, mp3data->totalframes, mp3data->bitrate);
  if ( mp3data->mode == 1 )
  {
    curr = mp3data->mode_ext;
    if ( (mp3data->mode_ext & 1) != 0 )
    {
      if ( (last_3337 & 1) != 0 )
        v1 = 73;
      else
        v1 = 105;
      v2 = v1;
    }
    else
    {
      if ( (last_3337 & 1) != 0 )
        v3 = 105;
      else
        v3 = 32;
      v2 = v3;
    }
    if ( (curr & 2) != 0 )
    {
      if ( (last_3337 & 2) != 0 )
        v4 = " MS ";
      else
        v4 = "LMSR";
    }
    else if ( (last_3337 & 2) != 0 )
    {
      v4 = "LMSR";
    }
    else
    {
      v4 = "L  R";
    }
    console_printf("  %s  %c", v4, v2);
    last_3337 = curr;
  }
  else
  {
    console_printf("         ");
    last_3337 = 0;
  }
  console_printf("        \b\b\b\b\b\b\b\b");
}

//----- (080539F8) --------------------------------------------------------
void decoder_progress_finish()
{
  console_printf("\n");
}

//----- (08053A0C) --------------------------------------------------------
int __cdecl calculate_index(const int *const array, const int len, const int value)
{
  int i; // [esp+Ch] [ebp-4h]

  for ( i = 0; i < len; ++i )
  {
    if ( array[i] == value )
      return i;
  }
  return -1;
}

//----- (08053A43) --------------------------------------------------------
int __cdecl brhist_init(const lame_global_flags *gf, const int bitrate_kbps_min, const int bitrate_kbps_max)
{
  brhist.hist_printed_lines = 0;
  lame_bitrate_kbps(gf, 134591624);
  brhist.vbr_bitrate_min_index = calculate_index(brhist.kbps, 14, bitrate_kbps_min);
  brhist.vbr_bitrate_max_index = calculate_index(brhist.kbps, 14, bitrate_kbps_max);
  if ( brhist.vbr_bitrate_min_index <= 13 && brhist.vbr_bitrate_max_index <= 13 )
  {
    memset(brhist.bar_asterisk, 42, 0x200u);
    memset(brhist.bar_percent, 37, 0x200u);
    memset(brhist.bar_space, 45, 0x200u);
    memset(brhist.bar_coded, 45, 0x200u);
    return 0;
  }
  else
  {
    error_printf(
      "lame internal error: VBR min %d kbps or VBR max %d kbps not allowed.\n",
      bitrate_kbps_min,
      bitrate_kbps_max);
    return -1;
  }
}
// 804A5DC: using guessed type int __cdecl lame_bitrate_kbps(_DWORD, _DWORD);

//----- (08053B52) --------------------------------------------------------
int __cdecl digits(unsigned int number)
{
  int ret; // [esp+10h] [ebp-4h]

  ret = 1;
  if ( number > 0x5F5E0FF )
  {
    ret = 9;
    number /= 0x5F5E100u;
  }
  if ( number > 0x270F )
  {
    ret += 4;
    number /= 0x2710u;
  }
  if ( number > 0x63 )
  {
    ret += 2;
    number /= 0x64u;
  }
  if ( number > 9 )
    ++ret;
  return ret;
}

//----- (08053BDA) --------------------------------------------------------
void __cdecl brhist_disp_line(int i, int br_hist_TOT, int br_hist_LR, int full, int frames)
{
  int v5; // eax
  int res; // [esp+3Ch] [ebp-2Ch]
  int barlen_LR; // [esp+44h] [ebp-24h]
  int barlen_TOT; // [esp+48h] [ebp-20h]
  char brppt[14]; // [esp+4Eh] [ebp-1Ah] BYREF
  unsigned int v10; // [esp+5Ch] [ebp-Ch]

  v10 = __readgsdword(0x14u);
  res = digits(frames) + 8;
  if ( full )
  {
    barlen_TOT = (full + br_hist_TOT * (Console_IO.disp_width - res) - 1) / full;
    barlen_LR = (full + br_hist_LR * (Console_IO.disp_width - res) - 1) / full;
  }
  else
  {
    barlen_LR = 0;
    barlen_TOT = 0;
  }
  v5 = digits(frames);
  sprintf(brppt, " [%*i]", v5, br_hist_TOT);
  if ( Console_IO.str_clreoln[0] )
    console_printf(
      "\n%3d%s %.*s%.*s%s",
      brhist.kbps[i],
      brppt,
      barlen_LR,
      brhist.bar_percent,
      barlen_TOT - barlen_LR,
      brhist.bar_asterisk,
      Console_IO.str_clreoln);
  else
    console_printf(
      "\n%3d%s %.*s%.*s%*s",
      brhist.kbps[i],
      brppt,
      barlen_LR,
      brhist.bar_percent,
      barlen_TOT - barlen_LR,
      brhist.bar_asterisk,
      Console_IO.disp_width - res - barlen_TOT,
      (const char *)&unk_8059B6F);
  ++brhist.hist_printed_lines;
}

//----- (08053D7C) --------------------------------------------------------
void __cdecl progress_line(const lame_global_flags *gf, int full, int frames)
{
  int v3; // eax
  int srate; // [esp+40h] [ebp-48h]
  int fsize; // [esp+44h] [ebp-44h]
  unsigned int sec; // [esp+48h] [ebp-40h]
  unsigned int min; // [esp+4Ch] [ebp-3Ch]
  unsigned int hour; // [esp+50h] [ebp-38h]
  float time_in_sec; // [esp+54h] [ebp-34h]
  float time_in_seca; // [esp+54h] [ebp-34h]
  float time_in_secb; // [esp+54h] [ebp-34h]
  float time_in_secc; // [esp+54h] [ebp-34h]
  float time_in_secd; // [esp+54h] [ebp-34h]
  int res; // [esp+58h] [ebp-30h]
  int barlen_RST; // [esp+5Ch] [ebp-2Ch]
  int barlen_COD; // [esp+60h] [ebp-28h]
  int barlen_TOT; // [esp+64h] [ebp-24h]
  char rst[20]; // [esp+68h] [ebp-20h] BYREF
  unsigned int v19; // [esp+7Ch] [ebp-Ch]

  v19 = __readgsdword(0x14u);
  memset(rst, 0, sizeof(rst));
  res = 1;
  time_in_sec = 0.0;
  fsize = lame_get_framesize(gf);
  srate = lame_get_out_samplerate(gf);
  if ( full < frames )
    full = frames;
  if ( srate > 0 )
  {
    time_in_seca = (float)(full - frames);
    time_in_secb = (long double)fsize * time_in_seca;
    time_in_sec = time_in_secb / (long double)srate;
  }
  hour = (__int64)(time_in_sec / 3600.0);
  time_in_secc = time_in_sec - (long double)(3600 * hour);
  min = (__int64)(time_in_secc / 60.0);
  time_in_secd = time_in_secc - (long double)(60 * min);
  sec = (__int64)time_in_secd;
  if ( full )
  {
    if ( hour )
    {
      v3 = digits(hour);
      sprintf(rst, "%*d:%02u:%02u", v3, hour, min, sec);
      res = digits(hour) + 7;
    }
    else
    {
      sprintf(rst, "%02u:%02u", min, sec);
      res = 6;
    }
    barlen_TOT = (full * (Console_IO.disp_width - res + 1) - 1) / full;
    barlen_COD = (full + frames * (Console_IO.disp_width - res) - 1) / full;
    barlen_RST = barlen_TOT - barlen_COD;
    if ( barlen_TOT == barlen_COD )
      sprintf(rst, "%.*s", res - 1, brhist.bar_coded);
  }
  else
  {
    barlen_RST = 0;
    barlen_COD = 0;
    barlen_TOT = 0;
  }
  if ( Console_IO.str_clreoln[0] )
    console_printf(
      "\n%.*s%s%.*s%s",
      barlen_COD,
      brhist.bar_coded,
      rst,
      barlen_RST,
      brhist.bar_space,
      Console_IO.str_clreoln);
  else
    console_printf(
      "\n%.*s%s%.*s%*s",
      barlen_COD,
      brhist.bar_coded,
      rst,
      barlen_RST,
      brhist.bar_space,
      Console_IO.disp_width - res - barlen_TOT,
      (const char *)&unk_8059B6F);
  ++brhist.hist_printed_lines;
}
// 804A5FC: using guessed type int __cdecl lame_get_framesize(_DWORD);
// 804A95C: using guessed type int __cdecl lame_get_out_samplerate(_DWORD);

//----- (0805409D) --------------------------------------------------------
int __cdecl stats_value(double x)
{
  if ( x <= 0.0 )
    return 0;
  console_printf(" %5.1f", x);
  return 6;
}

//----- (080540E2) --------------------------------------------------------
int __cdecl stats_head(double x, const char *txt)
{
  if ( x <= 0.0 )
    return 0;
  console_printf(txt);
  return 6;
}

//----- (0805411F) --------------------------------------------------------
void __cdecl stats_line(double *stat)
{
  int nb; // [esp+1Ch] [ebp-Ch]
  int nc; // [esp+1Ch] [ebp-Ch]
  int nd; // [esp+1Ch] [ebp-Ch]
  int ne; // [esp+1Ch] [ebp-Ch]
  int nf; // [esp+1Ch] [ebp-Ch]
  int ng; // [esp+1Ch] [ebp-Ch]
  int nh; // [esp+1Ch] [ebp-Ch]
  int ni; // [esp+1Ch] [ebp-Ch]
  int n; // [esp+1Ch] [ebp-Ch]
  int nj; // [esp+1Ch] [ebp-Ch]
  int nk; // [esp+1Ch] [ebp-Ch]
  int nl; // [esp+1Ch] [ebp-Ch]
  int nm; // [esp+1Ch] [ebp-Ch]
  int nn; // [esp+1Ch] [ebp-Ch]
  int no; // [esp+1Ch] [ebp-Ch]
  int np; // [esp+1Ch] [ebp-Ch]
  int na; // [esp+1Ch] [ebp-Ch]

  console_printf("\n   kbps     ");
  nb = stats_head(stat[1], "  mono") + 13;
  nc = stats_head(stat[2], "   IS ") + nb;
  nd = stats_head(stat[3], "   LR ") + nc;
  ne = stats_head(stat[4], "   MS ") + nd;
  console_printf(" %%    ");
  nf = stats_head(stat[5], " long ") + ne + 6;
  ng = stats_head(stat[6], "switch") + nf;
  nh = stats_head(stat[7], " short") + ng;
  ni = stats_head(stat[8], " mixed") + nh;
  n = console_printf(" %%") + ni;
  if ( Console_IO.str_clreoln[0] )
    console_printf("%s", Console_IO.str_clreoln);
  else
    console_printf("%*s", Console_IO.disp_width - n, (const char *)&unk_8059B6F);
  ++brhist.hist_printed_lines;
  console_printf("\n  %5.1f     ", *stat);
  nj = stats_value(stat[1]) + 13;
  nk = stats_value(stat[2]) + nj;
  nl = stats_value(stat[3]) + nk;
  nm = stats_value(stat[4]) + nl;
  console_printf("      ");
  nn = stats_value(stat[5]) + nm + 6;
  no = stats_value(stat[6]) + nn;
  np = stats_value(stat[7]) + no;
  na = stats_value(stat[8]) + np;
  if ( Console_IO.str_clreoln[0] )
    console_printf("%s", Console_IO.str_clreoln);
  else
    console_printf("%*s", Console_IO.disp_width - na, (const char *)&unk_8059B6F);
  ++brhist.hist_printed_lines;
}

//----- (08054399) --------------------------------------------------------
void __cdecl brhist_disp(const lame_global_flags *gf)
{
  int v1; // eax
  int totalframes; // [esp+4h] [ebp-1E4h]
  int br_sm_hist[14][4]; // [esp+38h] [ebp-1B0h] BYREF
  double stat[9]; // [esp+118h] [ebp-D0h] BYREF
  int br_hist[14]; // [esp+160h] [ebp-88h] BYREF
  int bl_type[6]; // [esp+198h] [ebp-50h] BYREF
  int st_mode[4]; // [esp+1B0h] [ebp-38h] BYREF
  double sum; // [esp+1C0h] [ebp-28h]
  int show; // [esp+1C8h] [ebp-20h]
  int st_frames; // [esp+1CCh] [ebp-1Ch]
  int most_often; // [esp+1D0h] [ebp-18h]
  int frames; // [esp+1D4h] [ebp-14h]
  int lines_used; // [esp+1D8h] [ebp-10h]
  int i; // [esp+1DCh] [ebp-Ch]

  lines_used = 0;
  sum = 0.0;
  memset(stat, 0, sizeof(stat));
  st_frames = 0;
  brhist.hist_printed_lines = 0;
  lame_bitrate_stereo_mode_hist(gf, br_sm_hist);
  lame_bitrate_hist(gf, br_hist);
  lame_stereo_mode_hist(gf, st_mode);
  lame_block_type_hist(gf, bl_type);
  most_often = 0;
  frames = 0;
  for ( i = 0; i <= 13; ++i )
  {
    frames += br_hist[i];
    sum = (long double)(br_hist[i] * brhist.kbps[i]) + sum;
    if ( br_hist[i] > most_often )
      most_often = br_hist[i];
    if ( br_hist[i] )
      ++lines_used;
  }
  for ( i = 0; i <= 13; ++i )
  {
    show = br_hist[i];
    v1 = show && lines_used > 1;
    show = v1;
    if ( v1 || brhist.vbr_bitrate_min_index <= i && brhist.vbr_bitrate_max_index >= i )
      brhist_disp_line(i, br_hist[i], br_sm_hist[i][0], most_often, frames);
  }
  for ( i = 0; i <= 3; ++i )
    st_frames += st_mode[i];
  if ( frames > 0 )
  {
    stat[0] = sum / (long double)frames;
    stat[1] = (long double)(frames - st_frames) * 100.0 / (long double)frames;
  }
  if ( st_frames > 0 )
  {
    stat[2] = 0.0;
    stat[3] = (long double)st_mode[0] * 100.0 / (long double)st_frames;
    stat[4] = (long double)st_mode[2] * 100.0 / (long double)st_frames;
  }
  if ( bl_type[5] > 0 )
  {
    stat[5] = (long double)bl_type[0] * 100.0 / (long double)bl_type[5];
    stat[6] = (long double)(bl_type[1] + bl_type[3]) * 100.0 / (long double)bl_type[5];
    stat[7] = (long double)bl_type[2] * 100.0 / (long double)bl_type[5];
    stat[8] = (long double)bl_type[4] * 100.0 / (long double)bl_type[5];
  }
  totalframes = lame_get_totalframes(gf);
  progress_line(gf, totalframes, frames);
  stats_line(stat);
}
// 804A10C: using guessed type int __cdecl lame_stereo_mode_hist(_DWORD, _DWORD);
// 804A15C: using guessed type int __cdecl lame_bitrate_hist(_DWORD, _DWORD);
// 804A4EC: using guessed type int __cdecl lame_bitrate_stereo_mode_hist(_DWORD, _DWORD);
// 804A5AC: using guessed type int __cdecl lame_block_type_hist(_DWORD, _DWORD);
// 804A6FC: using guessed type int __cdecl lame_get_totalframes(_DWORD);

//----- (080546F4) --------------------------------------------------------
void brhist_jump_back()
{
  console_up(brhist.hist_printed_lines);
  brhist.hist_printed_lines = 0;
}

//----- (08054790) --------------------------------------------------------
int __cdecl stat64(int a1, int a2)
{
  return __xstat64(3, a1, a2);
}
// 804A1AC: using guessed type int __cdecl __xstat64(_DWORD, _DWORD, _DWORD);

//----- (080547D0) --------------------------------------------------------
int __cdecl fstat64(int a1, int a2)
{
  return __fxstat64(3, a1, a2);
}
// 804A83C: using guessed type int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD);

// nfuncs=462 queued=117 decompiled=117 lumina nreq=0 worse=0 better=0
// ALL OK, 117 function(s) have been successfully decompiled
