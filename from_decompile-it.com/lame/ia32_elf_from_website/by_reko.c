// subject_bss.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

int32 g_a805B2E0[] = // 0805B2E0
	{
	};
FILE * stderr = &g_t100B6740; // 0805B3A0
FILE * stdin = &g_t100B6748; // 0805B3A4
FILE * stdout = &g_t100B6780; // 0805B3C0
byte g_b805B3C4 = 0x00; // 0805B3C4
uint32 dtor_idx.7067 = 0x00; // 0805B3C8
word32 g_dw805B3CC = 0x00; // 0805B3CC
int32 g_dw805B3D0 = 0; // 0805B3D0
word32 g_dw805B3D4 = 0x00; // 0805B3D4
word32 g_dw805B3D8 = 0x00; // 0805B3D8
up32 g_dw805B3DC = 0x00; // 0805B3DC
FILE * g_ptr805B3E0 = null; // 0805B3E0
word32 g_dw805B3E4 = 0x00; // 0805B3E4
word32 swapbytes = 0x00; // 0805B3E8
word32 in_endian = 0x00; // 0805B3EC
word32 flush_write = 0x00; // 0805B3F0
ui32 last.3337 = 0x00; // 0805B400
real64 g_r805B408 = 0.0; // 0805B408
real64 g_r805B420 = 0.0; // 0805B420
real64 g_r805B428 = 0.0; // 0805B428
real64 g_r805B430 = 0.0; // 0805B430
real64 g_r805B440 = 0.0; // 0805B440
real64 g_r805B448 = 0.0; // 0805B448
real64 g_r805B450 = 0.0; // 0805B450
Eq_9404 g_t805B458 = // 0805B458
	{
		0.0
	};
word32 init.3108 = 0x00; // 0805B460
int32 g_dw805B480 = 0; // 0805B480
int32 g_dw805B484 = 0; // 0805B484
word32 g_a805B488[] = // 0805B488
	{
	};
int32 g_dw805B4C0 = 0; // 0805B4C0
void g_v805B4C4 = ??void??; // 0805B4C4
void g_v805B6C5 = ??void??; // 0805B6C5
void g_v805B8C6 = ??void??; // 0805B8C6
void g_v805BAC7 = ??void??; // 0805BAC7
Eq_1778 g_t805BCE0 = // 0805BCE0
	{
		0x00,
		null,
		null,
		0x00,
		0,
		0,
		0x00,
	};
FILE * g_ptr805BCE8 = null; // 0805BCE8
FILE * g_ptr805BCEC = null; // 0805BCEC
FILE * g_ptr805BCF0 = null; // 0805BCF0
int32 g_dw805BCF4 = 0; // 0805BCF4
char g_b805BCFC = '\0'; // 0805BCFC
byte g_b805BD06 = 0x00; // 0805BD06
Eq_212 mp3_delay = // 0805C540
	{
		0
	};
Eq_228 input_format = // 0805C544
	{
		0
	};
word32 mp3_delay_set = 0x00; // 0805C548
int32 silent = 0; // 0805C54C
real32 update_interval = 0.0F; // 0805C550
word32 print_clipping_info = 0x00; // 0805C554
word32 disable_wav_header = 0x00; // 0805C558
word32 brhist = 0x00; // 0805C55C
Eq_448 g_t805C560 = // 0805C560
	{
		0x00,
		0x00,
	};
word32 g_dw805C564 = 0x00; // 0805C564
word32 g_dw805C568 = 0x00; // 0805C568
int32 g_dw805C56C = 0; // 0805C56C
Eq_289 g_t805C578 = // 0805C578
	{
		0
	};
word32 g_dw805C57C = 0x00; // 0805C57C
Eq_422 g_t805C580 = // 0805C580
	{
		0
	};
Eq_422 g_t805C584 = // 0805C584
	{
		0
	};
word32 ignore_tag_errors = 0x00; // 0805C588
// subject_ctors.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * g_ptr805AEFC = &g_tFFFFFFFF; // 0805AEFC
// subject_data.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 in_signed = ~0x00; // 0805B2A8
int32 in_bitwidth = 16; // 0805B2AC
// subject_dtors.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * g_a805AF04[] = // 0805AF04
	{
	};
// subject_fini.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0805483C: void _fini()
void _fini()
{
	__do_global_dtors_aux();
}

// subject_got.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 g_dw805AFF0 = 0x00; // 0805AFF0
// subject_init.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0804A00C: void _init()
// Called from:
//      __libc_csu_init
void _init()
{
	if (g_dw805AFF0 != 0x00)
		__gmon_start__();
	frame_dummy();
	__do_global_ctors_aux();
}

// subject_jcr.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 g_dw805AF0C = 0x00; // 0805AF0C
// subject_plt.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0804A04C: void fileno()
void fileno()
{
}

// 0804A05C: void ldexp()
void ldexp()
{
}

// 0804A06C: void lame_get_in_samplerate()
void lame_get_in_samplerate()
{
}

// 0804A07C: void fputs()
void fputs()
{
}

// 0804A08C: void get_lame_version()
void get_lame_version()
{
}

// 0804A09C: void sprintf()
void sprintf()
{
}

// 0804A0AC: void popen()
void popen()
{
}

// 0804A0BC: void lame_set_num_channels()
void lame_set_num_channels()
{
}

// 0804A0CC: void id3tag_v1_only()
void id3tag_v1_only()
{
}

// 0804A0DC: void id3tag_v2_only()
void id3tag_v2_only()
{
}

// 0804A0EC: void id3tag_set_albumart()
void id3tag_set_albumart()
{
}

// 0804A0FC: void memcmp()
void memcmp()
{
}

// 0804A10C: void lame_stereo_mode_hist()
void lame_stereo_mode_hist()
{
}

// 0804A11C: void lame_get_RadioGain()
void lame_get_RadioGain()
{
}

// 0804A12C: void lame_set_scale_right()
void lame_set_scale_right()
{
}

// 0804A13C: void getchar()
void getchar()
{
}

// 0804A14C: void lame_set_decode_only()
void lame_set_decode_only()
{
}

// 0804A15C: void lame_bitrate_hist()
void lame_bitrate_hist()
{
}

// 0804A16C: void lame_get_noclipGainChange()
void lame_get_noclipGainChange()
{
}

// 0804A17C: void id3tag_init()
void id3tag_init()
{
}

// 0804A18C: void __gmon_start__()
void __gmon_start__()
{
}

// 0804A19C: void __isoc99_sscanf()
void __isoc99_sscanf()
{
}

// 0804A1AC: void __xstat64()
void __xstat64()
{
}

// 0804A1BC: void lame_get_id3v2_tag()
void lame_get_id3v2_tag()
{
}

// 0804A1CC: void get_lame_os_bitness()
void get_lame_os_bitness()
{
}

// 0804A1DC: void getenv()
void getenv()
{
}

// 0804A1EC: void strncpy()
void strncpy()
{
}

// 0804A1FC: void lame_set_error_protection()
void lame_set_error_protection()
{
}

// 0804A20C: void lame_get_num_samples()
void lame_get_num_samples()
{
}

// 0804A21C: void lame_set_debugf()
void lame_set_debugf()
{
}

// 0804A22C: void lame_get_noclipScale()
void lame_get_noclipScale()
{
}

// 0804A23C: void lame_get_compression_ratio()
void lame_get_compression_ratio()
{
}

// 0804A24C: void lame_get_VBR_max_bitrate_kbps()
void lame_get_VBR_max_bitrate_kbps()
{
}

// 0804A25C: void memset()
void memset()
{
}

// 0804A26C: void fopen64()
void fopen64()
{
}

// 0804A27C: void lame_encode_buffer_int()
void lame_encode_buffer_int()
{
}

// 0804A28C: void lame_get_VBR_min_bitrate_kbps()
void lame_get_VBR_min_bitrate_kbps()
{
}

// 0804A29C: void get_lame_url()
void get_lame_url()
{
}

// 0804A2AC: void lame_set_write_id3tag_automatic()
void lame_set_write_id3tag_automatic()
{
}

// 0804A2BC: void __libc_start_main()
void __libc_start_main()
{
}

// 0804A2CC: void id3tag_set_comment()
void id3tag_set_comment()
{
}

// 0804A2DC: void lame_set_decode_on_the_fly()
void lame_set_decode_on_the_fly()
{
}

// 0804A2EC: void _IO_getc()
void _IO_getc()
{
}

// 0804A2FC: void lame_set_VBR_hard_min()
void lame_set_VBR_hard_min()
{
}

// 0804A30C: void lame_get_decode_only()
void lame_get_decode_only()
{
}

// 0804A31C: void lame_get_lametag_frame()
void lame_get_lametag_frame()
{
}

// 0804A32C: void lame_set_strict_ISO()
void lame_set_strict_ISO()
{
}

// 0804A33C: void lame_set_useTemporal()
void lame_set_useTemporal()
{
}

// 0804A34C: void lame_set_force_ms()
void lame_set_force_ms()
{
}

// 0804A35C: void lame_set_compression_ratio()
void lame_set_compression_ratio()
{
}

// 0804A36C: void gettimeofday()
void gettimeofday()
{
}

// 0804A37C: void free()
void free()
{
}

// 0804A38C: void lame_set_VBR_quality()
void lame_set_VBR_quality()
{
}

// 0804A39C: void lame_set_disable_reservoir()
void lame_set_disable_reservoir()
{
}

// 0804A3AC: void hip_decode1_headers()
void hip_decode1_headers()
{
}

// 0804A3BC: void lame_close()
void lame_close()
{
}

// 0804A3CC: void lame_set_nogap_total()
void lame_set_nogap_total()
{
}

// 0804A3DC: void tgetent()
void tgetent()
{
}

// 0804A3EC: void fflush()
void fflush()
{
}

// 0804A3FC: void lame_get_encoder_delay()
void lame_get_encoder_delay()
{
}

// 0804A40C: void fseek()
void fseek()
{
}

// 0804A41C: void lame_set_VBR_min_bitrate_kbps()
void lame_set_VBR_min_bitrate_kbps()
{
}

// 0804A42C: void lame_set_free_format()
void lame_set_free_format()
{
}

// 0804A43C: void fclose()
void fclose()
{
}

// 0804A44C: void lame_set_errorf()
void lame_set_errorf()
{
}

// 0804A45C: void lame_init_bitstream()
void lame_init_bitstream()
{
}

// 0804A46C: void lame_set_exp_nspsytune()
void lame_set_exp_nspsytune()
{
}

// 0804A47C: void clock()
void clock()
{
}

// 0804A48C: void memcpy()
void memcpy()
{
}

// 0804A49C: void lame_get_decode_on_the_fly()
void lame_get_decode_on_the_fly()
{
}

// 0804A4AC: void strlen()
void strlen()
{
}

// 0804A4BC: void lame_set_VBR()
void lame_set_VBR()
{
}

// 0804A4CC: void lame_print_config()
void lame_print_config()
{
}

// 0804A4DC: void lame_get_bWriteVbrTag()
void lame_get_bWriteVbrTag()
{
}

// 0804A4EC: void lame_bitrate_stereo_mode_hist()
void lame_bitrate_stereo_mode_hist()
{
}

// 0804A4FC: void lame_set_nogap_currentindex()
void lame_set_nogap_currentindex()
{
}

// 0804A50C: void lame_set_msfix()
void lame_set_msfix()
{
}

// 0804A51C: void lame_get_VBR()
void lame_get_VBR()
{
}

// 0804A52C: void lame_set_athaa_sensitivity()
void lame_set_athaa_sensitivity()
{
}

// 0804A53C: void feof()
void feof()
{
}

// 0804A54C: void strcpy()
void strcpy()
{
}

// 0804A55C: void ftell()
void ftell()
{
}

// 0804A56C: void lame_set_out_samplerate()
void lame_set_out_samplerate()
{
}

// 0804A57C: void lame_set_asm_optimizations()
void lame_set_asm_optimizations()
{
}

// 0804A58C: void lame_get_quality()
void lame_get_quality()
{
}

// 0804A59C: void id3tag_set_title()
void id3tag_set_title()
{
}

// 0804A5AC: void lame_block_type_hist()
void lame_block_type_hist()
{
}

// 0804A5BC: void lame_set_brate()
void lame_set_brate()
{
}

// 0804A5CC: void atoi()
void atoi()
{
}

// 0804A5DC: void lame_bitrate_kbps()
void lame_bitrate_kbps()
{
}

// 0804A5EC: void lame_set_findReplayGain()
void lame_set_findReplayGain()
{
}

// 0804A5FC: void lame_get_framesize()
void lame_get_framesize()
{
}

// 0804A60C: void atof()
void atof()
{
}

// 0804A61C: void id3tag_set_artist()
void id3tag_set_artist()
{
}

// 0804A62C: void lame_encode_flush()
void lame_encode_flush()
{
}

// 0804A63C: void lame_set_highpassfreq()
void lame_set_highpassfreq()
{
}

// 0804A64C: void fwrite()
void fwrite()
{
}

// 0804A65C: void fprintf()
void fprintf()
{
}

// 0804A66C: void lame_set_VBR_mean_bitrate_kbps()
void lame_set_VBR_mean_bitrate_kbps()
{
}

// 0804A67C: void lame_set_quality()
void lame_set_quality()
{
}

// 0804A68C: void setvbuf()
void setvbuf()
{
}

// 0804A69C: void strncat()
void strncat()
{
}

// 0804A6AC: void lame_get_mode()
void lame_get_mode()
{
}

// 0804A6BC: void lame_set_msgf()
void lame_set_msgf()
{
}

// 0804A6CC: void id3tag_set_year()
void id3tag_set_year()
{
}

// 0804A6DC: void id3tag_set_album()
void id3tag_set_album()
{
}

// 0804A6EC: void malloc()
void malloc()
{
}

// 0804A6FC: void lame_get_totalframes()
void lame_get_totalframes()
{
}

// 0804A70C: void __stack_chk_fail()
void __stack_chk_fail()
{
}

// 0804A71C: void id3tag_set_pad()
void id3tag_set_pad()
{
}

// 0804A72C: void lame_encode_flush_nogap()
void lame_encode_flush_nogap()
{
}

// 0804A73C: void fputc()
void fputc()
{
}

// 0804A74C: void lame_set_VBR_max_bitrate_kbps()
void lame_set_VBR_max_bitrate_kbps()
{
}

// 0804A75C: void lame_get_num_channels()
void lame_get_num_channels()
{
}

// 0804A76C: void hip_decode_init()
void hip_decode_init()
{
}

// 0804A77C: void lame_set_original()
void lame_set_original()
{
}

// 0804A78C: void id3tag_pad_v2()
void id3tag_pad_v2()
{
}

// 0804A79C: void tgetnum()
void tgetnum()
{
}

// 0804A7AC: void lame_get_version()
void lame_get_version()
{
}

// 0804A7BC: void id3tag_add_v2()
void id3tag_add_v2()
{
}

// 0804A7CC: void lame_init_params()
void lame_init_params()
{
}

// 0804A7DC: void lame_set_bWriteVbrTag()
void lame_set_bWriteVbrTag()
{
}

// 0804A7EC: void strcat()
void strcat()
{
}

// 0804A7FC: void lame_get_id3v1_tag()
void lame_get_id3v1_tag()
{
}

// 0804A80C: void id3tag_genre_list()
void id3tag_genre_list()
{
}

// 0804A81C: void lame_get_exp_nspsytune()
void lame_get_exp_nspsytune()
{
}

// 0804A82C: void id3tag_set_track()
void id3tag_set_track()
{
}

// 0804A83C: void __fxstat64()
void __fxstat64()
{
}

// 0804A84C: void lame_get_frameNum()
void lame_get_frameNum()
{
}

// 0804A85C: void lame_set_interChRatio()
void lame_set_interChRatio()
{
}

// 0804A86C: void id3tag_set_genre()
void id3tag_set_genre()
{
}

// 0804A87C: void lame_set_num_samples()
void lame_set_num_samples()
{
}

// 0804A88C: void lame_set_preset()
void lame_set_preset()
{
}

// 0804A89C: void lame_get_free_format()
void lame_get_free_format()
{
}

// 0804A8AC: void lame_set_emphasis()
void lame_set_emphasis()
{
}

// 0804A8BC: void lame_set_mode()
void lame_set_mode()
{
}

// 0804A8CC: void hip_decode_exit()
void hip_decode_exit()
{
}

// 0804A8DC: void lame_print_internals()
void lame_print_internals()
{
}

// 0804A8EC: void vfprintf()
void vfprintf()
{
}

// 0804A8FC: void lame_set_experimentalY()
void lame_set_experimentalY()
{
}

// 0804A90C: void _IO_putc()
void _IO_putc()
{
}

// 0804A91C: void lame_get_VBR_quality()
void lame_get_VBR_quality()
{
}

// 0804A92C: void lame_get_findReplayGain()
void lame_get_findReplayGain()
{
}

// 0804A93C: void lame_set_in_samplerate()
void lame_set_in_samplerate()
{
}

// 0804A94C: void fread()
void fread()
{
}

// 0804A95C: void lame_get_out_samplerate()
void lame_get_out_samplerate()
{
}

// 0804A96C: void lame_set_VBR_q()
void lame_set_VBR_q()
{
}

// 0804A97C: void tgetstr()
void tgetstr()
{
}

// 0804A98C: void lame_get_force_ms()
void lame_get_force_ms()
{
}

// 0804A99C: void lame_set_lowpassfreq()
void lame_set_lowpassfreq()
{
}

// 0804A9AC: void lame_set_scale_left()
void lame_set_scale_left()
{
}

// 0804A9BC: void lame_get_brate()
void lame_get_brate()
{
}

// 0804A9CC: void lame_init()
void lame_init()
{
}

// 0804A9DC: void lame_set_highpasswidth()
void lame_set_highpasswidth()
{
}

// 0804A9EC: void strdup()
void strdup()
{
}

// 0804A9FC: void id3tag_set_fieldvalue()
void id3tag_set_fieldvalue()
{
}

// 0804AA0C: void lame_set_scale()
void lame_set_scale()
{
}

// 0804AA1C: void ferror()
void ferror()
{
}

// 0804AA2C: void hip_decode1_headersB()
void hip_decode1_headersB()
{
}

// 0804AA3C: void tolower()
void tolower()
{
}

// 0804AA4C: void lame_set_copyright()
void lame_set_copyright()
{
}

// 0804AA5C: void lame_set_lowpasswidth()
void lame_set_lowpasswidth()
{
}

// 0804AA6C: void strcmp()
void strcmp()
{
}

// 0804AA7C: void exit()
void exit()
{
}

// 0804AA8C: void id3tag_space_v1()
void id3tag_space_v1()
{
}

// 0804AA9C: void lame_get_VBR_q()
void lame_get_VBR_q()
{
}

// 0804AAAC: void pclose()
void pclose()
{
}

// 0804AABC: void lame_get_VBR_mean_bitrate_kbps()
void lame_get_VBR_mean_bitrate_kbps()
{
}

// subject_rodata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 _fp_hw = 0x03; // 08054858
word32 _IO_stdin_used = 0x00020001; // 0805485C
char g_str8054866[] = "-"; // 08054866
char g_str8054868[] = "Input file and Output file are the same. Abort.\n"; // 08054868
char g_str8054899[] = "Can't init outfile '%s'\n"; // 08054899
char g_str80548C4[] = "\rinput:  %s%s(%g kHz, %i channel%s, "; // 080548C4
char g_str80548E9[] = "Internal error.  Aborting."; // 080548E9
char g_str805490B[] = "MPEG-%u%s Layer %s"; // 0805490B
char g_str8054923[] = "raw PCM data"; // 08054923
char g_str8054930[] = "Microsoft WAVE"; // 08054930
char g_str805493F[] = "SGI/Apple AIFF"; // 0805493F
char g_str805494E[] = "unknown"; // 0805494E
char g_str8054960[] = ")\noutput: %s%s(16 bit, Microsoft WAVE)\n"; // 08054960
char g_str8054988[] = "skipping initial %i samples (encoder+decoder delay)\n"; // 08054988
char g_str80549C0[] = "skipping final %i samples (encoder padding-decoder delay)\n"; // 080549C0
char g_str80549FC[] = "WAVE file contains 0 PCM samples\n"; // 080549FC
char g_str8054A20[] = "Very huge WAVE file, can't set filesize accordingly\n"; // 08054A20
char g_str8054A78[] = "Writing LAME Tag..."; // 08054A78
char g_str8054A8C[] = "done\n"; // 08054A8C
char g_str8054A94[] = "ReplayGain: %s%.1fdB\n"; // 08054A94
char g_str8054AAC[] = "WARNING: ReplayGain exceeds the -51dB to +51dB range. Such a result is too\n         high to be stored in the header.\n"; // 08054AAC
char g_str8054B24[] = "WARNING: clipping occurs at the current gain. Set your decoder to decrease\n         the  gain  by  at least %.1fdB or encode again "; // 08054B24
char g_str8054BA8[] = "using  --scale %.2f\n"; // 08054BA8
char g_str8054BC0[] = "         or less (the value under --scale is approximate).\n"; // 08054BC0
char g_str8054BFC[] = "using --scale <arg>\n         (For   a   suggestion  on  the  optimal  value  of  <arg>  encode\n         with  --scale 1  first)\n"; // 08054BFC
char g_str8054C80[] = "\nThe waveform does not clip and is less than 0.1dB away from full scale.\n"; // 08054C80
char g_str8054CCC[] = "\nThe waveform does not clip and is at least %.1fdB away from full scale.\n"; // 08054CCC
char g_str8054D18[] = "Error writing LAME-tag frame: buffer too small: buffer size=%d  frame size=%d\n"; // 08054D18
char g_str8054D67[] = "Error writing LAME-tag \n"; // 08054D67
char g_str8054D80[] = "Error writing ID3v2 tag: buffer too small: buffer size=%d  ID3v2 size=%d\n"; // 08054D80
char g_str8054DCA[] = "Error writing ID3v2 tag \n"; // 08054DCA
char g_str8054DE4[] = "mp3 buffer is not big enough... \n"; // 08054DE4
char g_str8054E08[] = "mp3 internal error:  error code=%i\n"; // 08054E08
char g_str8054E2C[] = "Error writing mp3 output \n"; // 08054E2C
char g_str8054E48[] = "Error writing ID3v1 tag: buffer too small: buffer size=%d  ID3v1 size=%d\n"; // 08054E48
char g_str8054E92[] = "Error writing ID3v1 tag \n"; // 08054E92
char g_str8054EAC[] = "fatal error: can't update LAME-tag frame!\n"; // 08054EAC
char g_str8054ED7[] = "/"; // 08054ED7
char g_str8054EDC[] = "fatal error during initialization\n"; // 08054EDC
char g_str8054EFF[] = "LAMEOPT"; // 08054EFF
real64 g_r8054F10 = 4294967248.0; // 08054F10
real32 g_r8054F20 = 10.0F; // 08054F20
Eq_744 g_t8054F28 = // 08054F28
	{
		-0.1
	};
char g_str8054F30[] = "TERM"; // 08054F30
void g_v8054F47 = ??void??; // 08054F47
char g_str8054F4B[] = "a"; // 08054F4B
char g_str8054F4D[] = "writing debug info into: %s\n"; // 08054F4D
char g_str8054F6C[] = "Error: can't open for debug info: %s\n"; // 08054F6C
char g_str8054F98[] = "fskip problem: Mostly the return status of functions is not evaluate so it is more secure to polute <stderr>.\n"; // 08054F98
char g_str8055007[] = "-"; // 08055007
char g_str8055009[] = "w+b"; // 08055009
char g_str8055010[] = "Error: number of channels has changed in %s - not supported\n"; // 08055010
char g_str8055050[] = "Error: sample frequency has changed in %s - not supported\n"; // 08055050
void g_v805508B = ??void??; // 0805508B
void g_v8055090 = ??void??; // 08055090
void g_v8055099 = ??void??; // 08055099
char g_str80550A0[] = "Unsigned input only supported with bitwidth 8\n"; // 080550A0
char g_str80550D0[] = "Only 8, 16, 24 and 32 bit input files supported \n"; // 080550D0
char g_str8055102[] = "Error reading input file\n"; // 08055102
FILE * IFF_ID_FORM = &g_t464F524D; // 0805511C
FILE * IFF_ID_AIFF = &g_t41494646; // 08055120
FILE * IFF_ID_AIFC = &g_t41494643; // 08055124
FILE * IFF_ID_COMM = &g_t434F4D4D; // 08055128
FILE * IFF_ID_SSND = &g_t53534E44; // 0805512C
word32 IFF_ID_MPEG = 0x4D504547; // 08055130
FILE * IFF_ID_NONE = &g_t4E4F4E45; // 08055134
FILE * IFF_ID_2CBE = &g_t74776F73; // 08055138
FILE * IFF_ID_2CLE = &g_t736F7774; // 0805513C
FILE * WAV_ID_RIFF = &g_t52494646; // 08055140
FILE * WAV_ID_WAVE = &g_t57415645; // 08055144
FILE * WAV_ID_FMT = &g_t666D7420; // 08055148
FILE * WAV_ID_DATA = &g_t64617461; // 0805514C
word16 g_w8055150 = 0x01; // 08055150
word16 g_w8055152 = ~0x01; // 08055152
char g_str8055154[] = "Unsupported data format: 0x%04X\n"; // 08055154
char g_str8055178[] = "Unsupported number of channels: %u\n"; // 08055178
char g_str805519C[] = "ERROR: input sound data is not PCM\n"; // 0805519C
char g_str80551C0[] = "ERROR: input sound data is not 8, 16, 24 or 32 bits\n"; // 080551C0
char g_str80551F8[] = "ERROR: input sound data is not mono or stereo\n"; // 080551F8
char g_str8055228[] = "ERROR: block size of input sound data is not 0 bytes\n"; // 08055228
char g_str8055260[] = "Can't rewind stream to audio data position\n"; // 08055260
char g_str805528C[] = "Warning: corrupt or unsupported WAVE format\n"; // 0805528C
char g_str80552BC[] = "Warning: corrupt or unsupported AIFF format\n"; // 080552BC
char g_str80552EC[] = "Warning: unsupported audio format\n"; // 080552EC
char g_str8055310[] = "Could not close audio input file\n"; // 08055310
char g_str8055332[] = "rb"; // 08055332
char g_str8055335[] = "Could not find \"%s\".\n"; // 08055335
char g_str805534C[] = "Error reading headers in mp3 input file %s.\n"; // 0805534C
char g_str805537C[] = "Unsupported number of channels: %ud\n"; // 0805537C
char g_str80553A4[] = "sorry, vorbis support in LAME is deprecated.\n"; // 080553A4
char g_str80553D2[] = "Assuming raw pcm input file"; // 080553D2
char g_str80553EE[] = " : Forcing byte-swapping\n"; // 080553EE
char g_str8055408[] = "\n"; // 08055408
void g_v805540A = ??void??; // 0805540A
char g_str8055410[] = "ID3v2 found. Be aware that the ID3 tag is currently lost when transcoding.\n"; // 08055410
char g_str805545C[] = "Album ID found.  length=%i \n"; // 0805545C
char g_str8055479[] = "Input file is freeformat.\n"; // 08055479
char g_str8055494[] = "fail to sync...\n"; // 08055494
byte g_a80554A5[] = // 080554A5
	{
	};
Eq_3877 g_t80554C0 = // 080554C0
	{
		8.0
	};
real64 g_r80554C8 = 1000.0; // 080554C8
real64 g_r80554D0 = 1000000.0; // 080554D0
real64 g_r80554D8 = 1e-06; // 080554D8
char g_str8055544[] = "LAME %s version %s (%s)\n\n"; // 08055544
char g_str805555E[] = "LAME version %s (%s)\n\n"; // 0805555E
char g_str8055575[] = "LAME %s version %s\n%*s(%s)\n\n"; // 08055575
char g_str8055592[] = ""; // 08055592
char g_str8055593[] = "LAME version %s\n%*s(%s)\n\n"; // 08055593
void g_v80555B0 = ??void??; // 080555B0
void g_v80556B0 = ??void??; // 080556B0
void g_v8055760 = ??void??; // 08055760
void g_v8055800 = ??void??; // 08055800
void g_v80559E8 = ??void??; // 080559E8
void g_v8055A58 = ??void??; // 08055A58
char g_str8055B5C[] = "usage: %s [options] <infile> [outfile]\n\n    <infile> and/or <outfile> can be \"-\", which means stdin/stdout.\n\nTry:\n     \"%s --help\"           for general usage information\n or:\n     \"%s --preset help\"    for information on suggested predefined settings\n or:\n     \"%s --longhelp\"\n  or \"%s -?\"              for a complete options list\n\n"; // 08055B5C
char g_str8055CAC[] = "usage: %s [options] <infile> [outfile]\n\n    <infile> and/or <outfile> can be \"-\", which means stdin/stdout.\n\nRECOMMENDED:\n    lame -V2 input.wav output.mp3\n\n"; // 08055CAC
char g_str8055D4C[] = "OPTIONS:\n    -b bitrate      set the bitrate, default 128 kbps\n    -h              higher quality, but a little slower.  Recommended.\n    -f              fast mode (lower quality)\n    -V n            quality setting for VBR.  default n=%i\n                    0=high quality,bigger files. 9=smaller files\n"; // 08055D4C
void g_v8055E80 = ??void??; // 08055E80
void g_v8055FC4 = ??void??; // 08055FC4
void g_v8056020 = ??void??; // 08056020
void g_v80562C4 = ??void??; // 080562C4
void g_v8056470 = ??void??; // 08056470
void g_v80567A0 = ??void??; // 080567A0
void g_v805690C = ??void??; // 0805690C
void g_v80569F0 = ??void??; // 080569F0
void g_v8056B7C = ??void??; // 08056B7C
void g_v8056CB0 = ??void??; // 08056CB0
char g_str8056DAC[] = "  VBR options:\n    -V n            quality setting for VBR.  default n=%i\n                    0=high quality,bigger files. 9=smaller files\n    -v              the same as -V 4\n    --vbr-old       use old variable bitrate (VBR) routine\n    --vbr-new       use new variable bitrate (VBR) routine (default)\n"; // 08056DAC
void g_v8056EE0 = ??void??; // 08056EE0
void g_v8057051 = ??void??; // 08057051
void g_v8057064 = ??void??; // 08057064
void g_v8057234 = ??void??; // 08057234
void g_v805726C = ??void??; // 0805726C
void g_v80572C8 = ??void??; // 080572C8
char g_str8057464[] = "  Filter options:\n  --lowpass <freq>        frequency(kHz), lowpass filter cutoff above freq\n  --lowpass-width <freq>  frequency(kHz) - default 15%% of lowpass freq\n  --highpass <freq>       frequency(kHz), highpass filter cutoff below freq\n  --highpass-width <freq> frequency(kHz) - default 15%% of highpass freq\n"; // 08057464
void g_v80575A0 = ??void??; // 080575A0
void g_v80575F4 = ??void??; // 080575F4
void g_v805796C = ??void??; // 0805796C
void g_v8057B4C = ??void??; // 08057B4C
void g_v8057C8C = ??void??; // 08057C8C
char g_str8057CF0[] = "\nMPEG-%-3s layer III sample frequencies (kHz):  %2d  %2d  %g\nbitrates (kbps):"; // 08057CF0
char g_str8057D3E[] = " %2i"; // 08057D3E
char g_str8057D43[] = "1"; // 08057D43
char g_str8057D45[] = "2"; // 08057D45
char g_str8057D47[] = "2.5"; // 08057D47
void g_v8057D4C = ??void??; // 08057D4C
void g_v8057D88 = ??void??; // 08057D88
void g_v8057DD4 = ??void??; // 08057DD4
void g_v8057F18 = ??void??; // 08057F18
void g_v8058018 = ??void??; // 08058018
void g_v8058184 = ??void??; // 08058184
void g_v80582B0 = ??void??; // 080582B0
void g_v80583E8 = ??void??; // 080583E8
void g_v8058568 = ??void??; // 08058568
void g_v80585AC = ??void??; // 080585AC
void g_v805874C = ??void??; // 0805874C
void g_v805882C = ??void??; // 0805882C
char g_str8058924[] = "help"; // 08058924
char g_str8058929[] = "phone"; // 08058929
char g_str805892F[] = "16"; // 0805892F
char g_str8058932[] = "phon+"; // 08058932
char g_str8058938[] = "lw"; // 08058938
char g_str805893B[] = "mw-eu"; // 0805893B
char g_str8058941[] = "sw"; // 08058941
char g_str8058944[] = "24"; // 08058944
char g_str8058947[] = "mw-us"; // 08058947
char g_str805894D[] = "40"; // 0805894D
char g_str8058950[] = "voice"; // 08058950
char g_str8058956[] = "56"; // 08058956
char g_str8058959[] = "fm"; // 08058959
char g_str805895C[] = "112"; // 0805895C
char g_str8058960[] = "radio"; // 08058960
char g_str8058966[] = "tape"; // 08058966
char g_str805896B[] = "hifi"; // 0805896B
char g_str8058970[] = "160"; // 08058970
char g_str8058974[] = "cd"; // 08058974
char g_str8058977[] = "192"; // 08058977
char g_str805897B[] = "studio"; // 0805897B
char g_str8058982[] = "256"; // 08058982
char g_str8058986[] = "medium"; // 08058986
char g_str805898D[] = "standard"; // 0805898D
char g_str8058996[] = "extreme"; // 08058996
char g_str805899E[] = "insane"; // 0805899E
char g_str80589A8[] = "Error: The bitrate specified is out of the valid range for this preset\n\nWhen using this mode you must enter a value between \"32\" and \"320\"\n\nFor further information try: \"%s --preset help\"\n"; // 080589A8
char g_str8058A68[] = "Error: You did not enter a valid profile and/or options with --preset\n\nAvailable profiles are:\n\n   <fast>        medium\n   <fast>        standard\n   <fast>        extreme\n                 insane\n          <cbr> (ABR Mode) - The ABR Mode is implied. To use it,\n                             simply specify a bitrate. For example:\n                             \"--preset 185\" activates this\n                             preset and uses 185 as an average kbps.\n\n"; // 08058A68
char g_str8058C34[] = "    Some examples:\n\n or \"%s --preset fast standard <input file> <output file>\"\n or \"%s --preset cbr 192 <input file> <output file>\"\n or \"%s --preset 172 <input file> <output file>\"\n or \"%s --preset extreme <input file> <output file>\"\n\nFor further information try: \"%s --preset help\"\n"; // 08058C34
char g_str8058D50[] = "%3d %s\n"; // 08058D50
byte g_b8058D58 = 0x2E; // 08058D58
byte g_b8058D5D = 0x2E; // 08058D5D
byte g_b8058D62 = 0x2E; // 08058D62
char g_str8058D67[] = ".mp3"; // 08058D67
char g_str8058D6C[] = ".wav"; // 08058D6C
byte g_b8058D71 = 0x2E; // 08058D71
byte g_b8058D76 = 0x2E; // 08058D76
byte g_b8058D7B = 0x2E; // 08058D7B
char g_str8058D80[] = "Illegal resample frequency: %.3f kHz\n"; // 08058D80
char g_str8058E4C[] = "rb"; // 08058E4C
char g_str8058E4F[] = "Could not find: '%s'.\n"; // 08058E4F
char g_str8058E68[] = "Insufficient memory for reading the albumart.\n"; // 08058E68
char g_str8058E97[] = "Read error: '%s'.\n"; // 08058E97
char g_str8058EAC[] = "Unsupported image: '%s'.\nSpecify JPEG/PNG/GIF image (128KB maximum)\n"; // 08058EAC
byte g_b8058EF1 = 114; // 08058EF1
byte g_b8058EFA = 118; // 08058EFA
byte g_b8058F02 = 118; // 08058F02
byte g_b8058F0A = 118; // 08058F0A
char g_str8058F13[] = "cbr"; // 08058F13
byte g_b8058F17 = 0x61; // 08058F17
byte g_b8058F1B = 114; // 08058F1B
byte g_b8058F21 = 0x62; // 08058F21
byte g_b8058F2A = 115; // 08058F2A
byte g_b8058F31 = 117; // 08058F31
byte g_b8058F3A = 0x6C; // 08058F3A
byte g_b8058F48 = 0x62; // 08058F48
byte g_b8058F53 = 0x6D; // 08058F53
byte g_b8058F5C = 0x6D; // 08058F5C
byte g_b8058F65 = 0x6D; // 08058F65
byte g_b8058F6E = 111; // 08058F6E
char g_str8058F78[] = "sorry, vorbis support in LAME is deprecated.\n"; // 08058F78
char g_str8058FA8[] = "Warning: --phone is deprecated, use --preset phone instead!"; // 08058FA8
char g_str8058FE4[] = "Warning: --voice is deprecated, use --preset voice instead!"; // 08058FE4
byte g_b8059020 = 100; // 08059020
byte g_b8059027 = 0x66; // 08059027
byte g_b805902D = 100; // 0805902D
byte g_b805903D = 110; // 0805903D
byte g_b8059043 = 115; // 08059043
byte g_b8059058 = 115; // 08059058
byte g_b805905E = 115; // 0805905E
byte g_b8059066 = 115; // 08059066
byte g_b805906E = 110; // 0805906E
char g_str8059074[] = "mmx"; // 08059074
char g_str8059078[] = "3dnow"; // 08059078
char g_str805907E[] = "sse"; // 0805907E
byte g_b8059082 = 0x66; // 08059082
byte g_b805908D = 114; // 0805908D
byte g_b805909D = 114; // 0805909D
byte g_b80590B1 = 110; // 080590B1
byte g_b80590BE = 99; // 080590BE
byte g_b80590C9 = 110; // 080590C9
byte g_b80590D0 = 116; // 080590D0
byte g_b80590D3 = 116; // 080590D3
byte g_b80590D6 = 116; // 080590D6
byte g_b80590D9 = 116; // 080590D9
byte g_b80590DC = 116; // 080590DC
byte g_b80590DF = 116; // 080590DF
char g_str80590E4[] = "The track number has to be between 1 and 255 for ID3v1.\n"; // 080590E4
char g_str8059120[] = "The track number has to be between 1 and 255 for ID3v1, ignored for ID3v1.\n"; // 08059120
byte g_b805916C = 116; // 0805916C
char g_str8059170[] = "Unknown ID3v1 genre number: '%s'.\n"; // 08059170
char g_str8059193[] = "Unknown ID3v1 genre: '%s'.\n"; // 08059193
char g_str80591B0[] = "Unknown ID3v1 genre: '%s'.  Setting ID3v1 genre to 'Other'\n"; // 080591B0
char g_str80591EC[] = "Internal error.\n"; // 080591EC
byte g_b80591FD = 116; // 080591FD
char g_str8059200[] = "Invalid field value: '%s'. Ignored\n"; // 08059200
byte g_b8059224 = 116; // 08059224
byte g_b8059227 = 0x69; // 08059227
byte g_b8059239 = 0x61; // 08059239
byte g_b8059243 = 0x69; // 08059243
byte g_b805924E = 0x69; // 0805924E
byte g_b8059259 = 115; // 08059259
byte g_b8059265 = 0x70; // 08059265
byte g_b805926F = 0x70; // 0805926F
byte g_b805927E = 0x67; // 0805927E
byte g_b8059289 = 0x6C; // 08059289
char g_str8059294[] = "Must specify lowpass with --lowpass freq, freq >= 0.001 kHz\n"; // 08059294
byte g_b80592D1 = 0x6C; // 080592D1
char g_str80592E0[] = "Must specify lowpass width with --lowpass-width freq, freq >= 0.001 kHz\n"; // 080592E0
byte g_b8059329 = 0x68; // 08059329
char g_str8059334[] = "Must specify highpass with --highpass freq, freq >= 0.001 kHz\n"; // 08059334
byte g_b8059373 = 0x68; // 08059373
char g_str8059384[] = "Must specify highpass width with --highpass-width freq, freq >= 0.001 kHz\n"; // 08059384
byte g_b80593CF = 99; // 080593CF
char g_str80593D4[] = "Must specify compression ratio >= 1.0\n"; // 080593D4
byte g_b80593FB = 110; // 080593FB
byte g_b8059402 = 0x69; // 08059402
byte g_b805940A = 116; // 0805940A
byte g_b805941B = 110; // 0805941B
byte g_b8059425 = 110; // 08059425
byte g_b8059431 = 110; // 08059431
byte g_b8059439 = 110; // 08059439
byte g_b8059441 = 110; // 08059441
byte g_b8059449 = 110; // 08059449
byte g_b8059453 = 110; // 08059453
byte g_b805945C = 110; // 0805945C
byte g_b8059467 = 113; // 08059467
byte g_b805946D = 115; // 0805946D
byte g_b8059474 = 0x62; // 08059474
byte g_b805947A = 118; // 0805947A
byte g_b8059482 = 118; // 08059482
byte g_b805948A = 0x6C; // 0805948A
byte g_b8059492 = 117; // 08059492
byte g_b8059498 = 0x6C; // 08059498
byte g_b80594A1 = 0x3F; // 080594A1
byte g_b80594AF = 0x70; // 080594AF
byte g_b80594B6 = 0x61; // 080594B6
char g_str80594C1[] = "fast"; // 080594C1
byte g_b80594C6 = 100; // 080594C6
byte g_b80594CF = 110; // 080594CF
byte g_b80594D9 = 110; // 080594D9
byte g_b80594E2 = 110; // 080594E2
byte g_b80594E8 = 0x61; // 080594E8
char g_str80594FA[] = "%s: unrecognized option --%s\n"; // 080594FA
char g_str8059518[] = "%s: -m mode must be s/d/j/f/m not %s\n"; // 08059518
char g_str805953E[] = "WARNING: -%c is obsolete.\n"; // 0805953E
char g_str8059559[] = "%d,%d"; // 08059559
char g_str805955F[] = "%d"; // 0805955F
char g_str8059564[] = "%s: -e emp must be n/5/c not %s\n"; // 08059564
char g_str8059585[] = "%s: unrecognized option -%c\n"; // 08059585
char g_str80595A4[] = "Error: 'nogap option'.  Calling program does not allow nogap option, or\nyou have exceeded maximum number of input files for the nogap option\n"; // 080595A4
char g_str8059632[] = "%s: excess arg %s\n"; // 08059632
void g_v8059645 = ??void??; // 08059645
char g_str8059648[] = "Note: Disabling VBR Xing/Info tag since it interferes with --nogap\n"; // 08059648
char g_str805968C[] = "For free format, specify a bitrate between 8 and 640 kbps\n"; // 0805968C
char g_str80596C7[] = "with the -b <bitrate> option\n"; // 080596C7
real64 g_r8059820 = 44.1; // 08059820
Eq_5769 g_t8059828 = // 08059828
	{
		1000.0
	};
Eq_5769 g_t8059830 = // 08059830
	{
		0.001
	};
Eq_5769 g_t8059838 = // 08059838
	{
		50000.0
	};
Eq_5769 g_t8059840 = // 08059840
	{
		50.0
	};
real64 g_r8059848 = 0.5; // 08059848
Eq_5769 g_t8059850 = // 08059850
	{
		16.0
	};
Eq_5769 g_t8059858 = // 08059858
	{
		4.0
	};
Eq_5769 g_t8059860 = // 08059860
	{
		192.0
	};
Eq_3417 g_t8059868 = // 08059868
	{
		Infinity.0
	};
real64 g_r8059870 = 2147483648.0; // 08059870
char g_str8059878[] = "   %2u:%02u%c"; // 08059878
char g_str8059886[] = "%2lu:%02u:%02u%c"; // 08059886
char g_str8059897[] = "%6lu h%c"; // 08059897
char g_str80598A0[] = "\r    Frame          |  CPU time/estim | REAL time/estim | play/CPU |    ETA \n     0/       ( 0%%)|    0:00/     :  |    0:00/     :  |         x|     :  \r"; // 080598A0
char g_str805993B[] = "\r%6i/%-6i"; // 0805993B
char g_str8059945[] = " (%2d%%)|"; // 08059945
char g_str805994F[] = "(%3.3d%%)|"; // 0805994F
char g_str805995A[] = "%9.4fx|"; // 0805995A
char g_str8059962[] = "%#9.5gx|"; // 08059962
char g_str805996B[] = "\n"; // 0805996B
char g_str805996D[] = "-"; // 0805996D
char g_str8059988[] = "Encoding %s%s to %s\n"; // 08059988
char g_str805999D[] = "Encoding as %g kHz "; // 0805999D
char g_str80599B4[] = "%s MPEG-%u%s Layer III VBR(q=%g) qval=%i\n"; // 080599B4
char g_str80599E0[] = "%s MPEG-%u%s Layer III VBR(q=%g)\n"; // 080599E0
char g_str8059A04[] = "%s MPEG-%u%s Layer III (%gx) average %d kbps qval=%i\n"; // 08059A04
char g_str8059A3C[] = "%s MPEG-%u%s Layer III (%gx) %3d kbps qval=%i\n"; // 08059A3C
char g_str8059A6B[] = "\rFrame#%6i/%-6i %3i kbps"; // 08059A6B
char g_str8059A93[] = "  %s  %c"; // 08059A93
char g_str8059A9C[] = "         "; // 08059A9C
char g_str8059AA6[] = "        \b\b\b\b\b\b\b\b"; // 08059AA6
real64 g_r8059AE8 = 100.0; // 08059AE8
real64 g_r8059AF0 = 0.5; // 08059AF0
real64 g_r8059B00 = 10.0; // 08059B00
real64 g_r8059B08 = 0.1; // 08059B08
char g_str8059B10[] = "lame internal error: VBR min %d kbps or VBR max %d kbps not allowed.\n"; // 08059B10
char g_str8059B56[] = " [%*i]"; // 08059B56
char g_str8059B5D[] = "\n%3d%s %.*s%.*s%s"; // 08059B5D
char g_str8059B70[] = "\n%3d%s %.*s%.*s%*s"; // 08059B70
char g_str8059B83[] = "%*d:%02u:%02u"; // 08059B83
char g_str8059B91[] = "%02u:%02u"; // 08059B91
char g_str8059B9B[] = "%.*s"; // 08059B9B
char g_str8059BA0[] = "\n%.*s%s%.*s%s"; // 08059BA0
char g_str8059BAE[] = "\n%.*s%s%.*s%*s"; // 08059BAE
word16 g_w8059BBD = 0x00; // 08059BBD
char g_str8059BD1[] = " %5.1f"; // 08059BD1
char g_str8059BD8[] = "\n   kbps     "; // 08059BD8
char g_str8059BE6[] = "  mono"; // 08059BE6
char g_str8059BED[] = "   IS "; // 08059BED
char g_str8059BF4[] = "   LR "; // 08059BF4
char g_str8059BFB[] = "   MS "; // 08059BFB
char g_str8059C02[] = " %%    "; // 08059C02
char g_str8059C0A[] = " long "; // 08059C0A
char g_str8059C11[] = "switch"; // 08059C11
char g_str8059C18[] = " short"; // 08059C18
char g_str8059C1F[] = " mixed"; // 08059C1F
char g_str8059C26[] = " %%"; // 08059C26
char g_str8059C2A[] = "%s"; // 08059C2A
char g_str8059C2D[] = "%*s"; // 08059C2D
char g_str8059C31[] = "\n  %5.1f     "; // 08059C31
char g_str8059C3F[] = "      "; // 08059C3F
real32 g_r8059C48 = 3600.0F; // 08059C48
real32 g_r8059C4C = 60.0F; // 08059C4C
real64 g_r8059C50 = 100.0; // 08059C50
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0804AAD0: void _start(Register (ptr32 Eq_15) edx, Stack int32 dwArg00, Stack (ptr32 char) ptrArg04)
void _start(void (* edx)(), int32 dwArg00, char * ptrArg04)
{
	void * fp;
	__align_stack<word32>(&ptrArg04);
	__libc_start_main(&g_t804BFA5, dwArg00, &ptrArg04, &g_t8054730, &g_t8054720, edx, fp);
	__halt();
}

// 0804AB00: void __do_global_dtors_aux()
// Called from:
//      _fini
void __do_global_dtors_aux()
{
	if (g_b805B3C4 == 0x00)
	{
		uint32 eax_14 = dtor_idx.7067;
		while (eax_14 < 0x00)
		{
			uint32 eax_24 = eax_14 + 0x01;
			dtor_idx.7067 = eax_24;
			(*((char *) g_a805AF04 + eax_24 * 0x04))();
			eax_14 = dtor_idx.7067;
		}
		g_b805B3C4 = 0x01;
	}
}

// 0804AB60: void frame_dummy()
// Called from:
//      _init
void frame_dummy()
{
}

// 0804AB84: void parse_args_from_string(Stack (ptr32 Eq_67) dwArg04, Stack (ptr32 char) dwArg08, Stack (ptr32 Eq_69) dwArg0C, Stack (ptr32 char) dwArg10)
// Called from:
//      main
void parse_args_from_string(FILE * dwArg04, char * dwArg08, union Eq_69 * dwArg0C, char * dwArg10)
{
	Eq_71 tLoc021C;
	if (dwArg08 != null && *dwArg08 != 0x00)
	{
		char * eax_24 = malloc((word32) strlen(dwArg08) + 1);
		strcpy(eax_24, dwArg08);
		tLoc021C = (Eq_71) 0x08054860;
		char * dwLoc10_121 = eax_24;
		int32 dwLoc18_125 = 0x01;
		while (true)
		{
			(&tLoc021C)[dwLoc18_125] = (struct Eq_152) dwLoc10_121;
			int32 v14_43 = dwLoc18_125 + 0x01;
			dwLoc18_125 = v14_43;
			while (*dwLoc10_121 != 0x20 && *dwLoc10_121 != 0x00)
				++dwLoc10_121;
			if (*dwLoc10_121 == 0x00)
				break;
			*dwLoc10_121 = 0x00;
			++dwLoc10_121;
		}
		(&tLoc021C)[v14_43] = (struct Eq_127) 0x00;
		int8 Top_189;
		parse_args(dwArg04, v14_43, &tLoc021C, dwArg0C, dwArg10, null, null, out Top_189);
		free(eax_24);
	}
}

// 0804AC92: Register word32 init_files(Register (ptr32 Eq_159) gs, Stack (ptr32 Eq_67) dwArg04, Stack (ptr32 Eq_161) dwArg08, Stack (ptr32 char) dwArg0C, Stack (ptr32 Eq_163) dwArg10, Stack (ptr32 Eq_164) dwArg14)
// Called from:
//      main
word32 init_files(struct Eq_159 * gs, FILE * dwArg04, union Eq_161 * dwArg08, char * dwArg0C, struct Eq_163 * dwArg10, struct Eq_164 * dwArg14)
{
	word32 eax_119;
	if (strcmp("-", dwArg0C) != 0x00 && strcmp(dwArg08, dwArg0C) == 0x00)
	{
		error_printf("Input file and Output file are the same. Abort.\n");
		eax_119 = 0x00;
	}
	else
	{
		init_infile(gs, dwArg04, dwArg08, dwArg10, dwArg14);
		lame_get_decode_only(dwArg04);
		word32 eax_58 = init_outfile(dwArg0C);
		if (eax_58 == 0x00)
		{
			error_printf("Can't init outfile '%s'\n");
			eax_119 = 0x00;
		}
		else
			eax_119 = eax_58;
	}
	return eax_119;
}

// 0804AD3A: void lame_decoder(Register (ptr32 Eq_159) gs, Stack (ptr32 Eq_67) dwArg04, Stack (ptr32 Eq_211) dwArg08, Stack Eq_212 dwArg0C, Stack (ptr32 Eq_213) dwArg10, Stack (ptr32 char) dwArg14, Stack (ptr32 int32) dwArg18, Stack (ptr32 int32) dwArg1C)
// Called from:
//      main
void lame_decoder(struct Eq_159 * gs, FILE * dwArg04, union Eq_211 * dwArg08, Eq_212 dwArg0C, union Eq_213 * dwArg10, char * dwArg14, int32 * dwArg18, int32 * dwArg1C)
{
	struct Eq_217 * fp;
	Eq_218 eax_19 = lame_get_num_channels(dwArg04);
	Eq_222 dwLoc14_1022 = 0x00;
	if (silent <= 0x09)
	{
		lame_get_in_samplerate(dwArg04);
		strlen(dwArg10) <= 0x1A;
		strcmp(dwArg10, "-") == 0x00;
		console_printf("\rinput:  %s%s(%g kHz, %i channel%s, ");
	}
	Eq_228 eax_96 = input_format.u0;
	if (eax_96 <= 0x07)
	{
		switch (eax_96)
		{
		case 0x00:
			goto l0804B07E;
		case 0x01:
			if (silent <= 0x09)
				console_printf("raw PCM data");
			g_dw805C57C = lame_get_num_samples(dwArg04);
			g_t805C578.u0 = 0x0480;
			dwArg0C.u0 = 0x00;
			break;
		case 0x02:
			if (silent <= 0x09)
				console_printf("Microsoft WAVE");
			g_dw805C57C = lame_get_num_samples(dwArg04);
			g_t805C578.u0 = 0x0480;
			dwArg0C.u0 = 0x00;
			break;
		case 0x03:
			if (silent <= 0x09)
				console_printf("SGI/Apple AIFF");
			g_dw805C57C = lame_get_num_samples(dwArg04);
			g_t805C578.u0 = 0x0480;
			dwArg0C.u0 = 0x00;
			break;
		case 0x04:
			dwArg0C = (word32) dwArg0C.u0 + 0x00F1;
			if (silent <= 0x09)
			{
				lame_get_out_samplerate(dwArg04) > 15999;
				lame_get_version(dwArg04);
				console_printf("MPEG-%u%s Layer %s");
			}
			break;
		case 0x05:
			dwArg0C = (word32) dwArg0C + 0x00F1;
			if (silent <= 0x09)
			{
				lame_get_out_samplerate(dwArg04) > 15999;
				lame_get_version(dwArg04);
				console_printf("MPEG-%u%s Layer %s");
			}
			break;
		case 0x06:
			if (dwArg0C == 0x00)
			{
				if (*dwArg18 < 0x00 && *dwArg1C < 0x00)
					dwArg0C = lame_get_encoder_delay(dwArg04) + 0x0211;
				else
				{
					if (*dwArg18 >= 0x00)
						dwArg0C = *dwArg18 + 0x0211;
					if (*dwArg1C >= 0x00)
						dwLoc14_1022 = *dwArg1C - 0x0211;
				}
			}
			else
				dwArg0C = (word32) dwArg0C.u0 + 0x0211;
			if (silent <= 0x09)
			{
				lame_get_out_samplerate(dwArg04) > 15999;
				lame_get_version(dwArg04);
				console_printf("MPEG-%u%s Layer %s");
			}
			break;
		case 0x07:
			error_printf("Internal error.  Aborting.");
			exit(~0x00);
		}
	}
	else
	{
l0804B07E:
		if (silent <= 0x09)
			console_printf("unknown");
		g_dw805C57C = lame_get_num_samples(dwArg04);
		g_t805C578.u0 = 0x0480;
		dwArg0C.u0 = 0x00;
	}
	if (silent <= 0x09)
	{
		strlen(dwArg14) <= 0x2D;
		strcmp(dwArg14, "-") == 0x00;
		console_printf(")\noutput: %s%s(16 bit, Microsoft WAVE)\n");
		if (dwArg0C > 0x00)
			console_printf("skipping initial %i samples (encoder+decoder delay)\n");
		if (dwLoc14_1022 > 0x00)
			console_printf("skipping final %i samples (encoder padding-decoder delay)\n");
	}
	if (disable_wav_header == 0x00)
		WriteWaveHeader(dwArg08, 0x7FFFFFFF, lame_get_in_samplerate(dwArg04), eax_19, 0x10);
	real64 rLoc2C_1231 = CONVERT(-(dwArg0C + dwLoc14_1022), word32, real64);
	g_t805C580.u0 = (int32) (uint32) ((uint64) g_dw805C57C /u g_t805C578.u0);
	do
	{
		Eq_212 eax_543 = get_audio16(gs, dwArg04, fp->aFFFFEDD4);
		Eq_212 dwLoc10_1237 = eax_543;
		if (eax_543 >= 0x00)
		{
			g_t805C584.u0 = (int32) (g_t805C584.u0 + (int32) (SEQ(eax_543 >> 0x1F, eax_543) /32 g_t805C578.u0));
			rLoc2C_1231 = (real64) eax_543 + rLoc2C_1231;
			if (silent <= 0x00)
			{
				decoder_progress(&g_t805C560);
				console_flush();
			}
			Eq_212 eax_597 = dwArg0C;
			if (eax_543 <= dwArg0C)
				eax_597 = eax_543;
			Eq_212 dwLoc18_1248 = eax_597;
			dwArg0C -= eax_597;
			if (dwLoc14_1022 > 0x0480 && g_t805C584.u0 + 2 > g_t805C580.u0)
			{
				dwLoc10_1237 = eax_543 + (0x0480 - dwLoc14_1022);
				dwLoc14_1022.u0 = 0x0480;
			}
			else if (g_t805C584.u0 == g_t805C580.u0 && eax_543 != 0x00)
				dwLoc10_1237 = eax_543 - dwLoc14_1022;
			while (dwLoc18_1248 < dwLoc10_1237)
			{
				if (disable_wav_header != 0x00)
				{
					WriteBytesSwapped(dwArg08, fp->aFFFFEDD4 + dwLoc18_1248, 0x02);
					if (eax_19 == 0x02)
						WriteBytesSwapped(dwArg08, fp->aFFFFEDD4 + ((word32) dwLoc18_1248 + 1152), 0x02);
				}
				else
				{
					Write16BitsLowHigh(dwArg08, (int32) fp->aFFFFEDD4[dwLoc18_1248]);
					if (eax_19 == 0x02)
						Write16BitsLowHigh(dwArg08, (int32) fp->aFFFFEDD4[(word32) dwLoc18_1248 + 1152]);
				}
				dwLoc18_1248 = (word32) dwLoc18_1248.u0 + 1;
			}
			if (flush_write == 0x01)
				fflush(dwArg08);
		}
	} while (dwLoc10_1237 > 0x00);
	real64 rLoc2C_1303;
	if ((int8) (rLoc2C_1231 <= 0.0) != 0x00)
	{
		if (silent <= 0x09)
			error_printf("WAVE file contains 0 PCM samples\n");
		rLoc2C_1303 = 0.0;
	}
	else if ((int8) (rLoc2C_1231 > (real64) ((uint64) ((uint32) (0xFFFFFFD0 /u (eax_19 * 0x02))))) != 0x00)
	{
		if (silent <= 0x09)
			error_printf("Very huge WAVE file, can't set filesize accordingly\n");
		rLoc2C_1303 = 4294967248.0;
	}
	else
		rLoc2C_1303 = (real64) (eax_19 * 0x02) * rLoc2C_1231;
	if (disable_wav_header == 0x00 && (strcmp("-", dwArg14) != 0x00 && fseek(dwArg08, 0x00, 0x00) == 0x00))
	{
		Eq_381 eax_867 = lame_get_in_samplerate(dwArg04);
		Eq_559 wLoc122E_1392 = __fstcw();
		__fldcw(SEQ(0x0C, (byte) wLoc122E_1392));
		__fldcw(wLoc122E_1392);
		WriteWaveHeader(dwArg08, (int32) rLoc2C_1303, eax_867, eax_19, 0x10);
	}
	fclose(dwArg08);
	if (silent <= 0x00)
		decoder_progress_finish();
}

// 0804B4F0: void print_lame_tag_leading_info(Stack (ptr32 Eq_67) dwArg04)
// Called from:
//      lame_encoder
void print_lame_tag_leading_info(FILE * dwArg04)
{
	if (lame_get_bWriteVbrTag(dwArg04) != 0x00)
		console_printf("Writing LAME Tag...");
}

// 0804B513: Register int8 print_trailing_info(Stack (ptr32 Eq_67) dwArg04, FpuStack real64 rArg0, FpuStack out Eq_684 rArg0Out)
// Called from:
//      lame_encoder
int8 print_trailing_info(FILE * dwArg04, real64 rArg0, union Eq_684 & rArg0Out)
{
	if (lame_get_bWriteVbrTag(dwArg04) != 0x00)
		console_printf("done\n");
	if (lame_get_findReplayGain(dwArg04) != 0x00)
	{
		int32 eax_39 = lame_get_RadioGain(dwArg04);
		console_printf("ReplayGain: %s%.1fdB\n");
		if (eax_39 > 0x01FE || eax_39 < ~0x01FD)
			error_printf("WARNING: ReplayGain exceeds the -51dB to +51dB range. Such a result is too\n         high to be stored in the header.\n");
	}
	int8 Top_146 = 0;
	if (print_clipping_info != 0x00 && lame_get_decode_on_the_fly(dwArg04) != 0x00)
	{
		word32 eax_100 = lame_get_noclipGainChange(dwArg04);
		real32 rLoc14_251 = (real32) ((real64) eax_100 / (real64) 10.0F);
		lame_get_noclipScale(dwArg04, eax_100);
		real32 rLoc18_258 = (real32) rArg0;
		if ((int8) ((real64) rLoc14_251 > 0.0) != 0x00)
		{
			console_printf("WARNING: clipping occurs at the current gain. Set your decoder to decrease\n         the  gain  by  at least %.1fdB or encode again ");
			Top_146 = 0x01;
			if ((int8) ((real64) rLoc18_258 > 0.0) != 0x00)
			{
				console_printf("using  --scale %.2f\n");
				console_printf("         or less (the value under --scale is approximate).\n");
				Top_146 = 0x01;
			}
			else
				console_printf("using --scale <arg>\n         (For   a   suggestion  on  the  optimal  value  of  <arg>  encode\n         with  --scale 1  first)\n");
		}
		else
		{
			Top_146 = 0x01;
			if ((int8) ((real64) rLoc14_251 > g_t8054F28.u0) != 0x00)
				console_printf("\nThe waveform does not clip and is less than 0.1dB away from full scale.\n");
			else
			{
				console_printf("\nThe waveform does not clip and is at least %.1fdB away from full scale.\n");
				Top_146 = 0x01;
			}
		}
	}
	rArg0Out.u0 = <invalid>;
	return Top_146;
}

// 0804B68B: void write_xing_frame(Register (ptr32 Eq_159) gs, Stack (ptr32 Eq_67) dwArg04, Stack (ptr32 Eq_211) dwArg08)
// Called from:
//      lame_encoder
void write_xing_frame(struct Eq_159 * gs, FILE * dwArg04, union Eq_211 * dwArg08)
{
	word32 dwLoc24010;
	word32 eax_14 = gs->dw0014;
	Eq_82 eax_25 = lame_get_lametag_frame(dwArg04, &dwLoc24010, 0x00024000, dwArg08, dwArg04, eax_14);
	if (eax_25 > 0x00024000)
		error_printf("Error writing LAME-tag frame: buffer too small: buffer size=%d  frame size=%d\n");
	else if (eax_25 != 0x00)
	{
		if (fwrite(&dwLoc24010, 0x01, eax_25, dwArg08) != eax_25)
			error_printf("Error writing LAME-tag \n");
		else if (flush_write == 0x01)
			fflush(dwArg08);
	}
	if ((eax_14 ^ gs->dw0014) == 0x00)
		return;
	__stack_chk_fail();
}

// 0804B79A: Register (ptr8 real64) lame_encoder(Register (ptr32 Eq_159) gs, Stack (ptr32 Eq_67) dwArg04, Stack (ptr32 Eq_211) dwArg08, Stack word32 dwArg0C, Stack (ptr32 Eq_838) dwArg10, Stack (ptr32 char) dwArg14, FpuStack real64 rArg0)
// Called from:
//      main
real64 * lame_encoder(struct Eq_159 * gs, FILE * dwArg04, union Eq_211 * dwArg08, word32 dwArg0C, union Eq_838 * dwArg10, char * dwArg14, real64 rArg0)
{
	ptr32 fp;
	word32 dwLoc24010;
	word32 eax_18 = gs->dw0014;
	real64 rRet0_39;
	real64 * Top_32 = encoder_progress_begin(dwArg04, dwArg10, dwArg14, rArg0, out rRet0_39);
	*Top_32 = rRet0_39;
	Eq_82 eax_46 = lame_get_id3v2_tag(dwArg04, &dwLoc24010, 0x00024000);
	if (eax_46 > 0x00024000)
	{
		encoder_progress_end(gs, dwArg04);
		error_printf("Error writing ID3v2 tag: buffer too small: buffer size=%d  ID3v2 size=%d\n");
		goto l0804BC72;
	}
	if (fwrite(&dwLoc24010, 0x01, eax_46, dwArg08) != eax_46)
	{
		encoder_progress_end(gs, dwArg04);
		error_printf("Error writing ID3v2 tag \n");
		goto l0804BC72;
	}
	if (flush_write == 0x01)
		fflush(dwArg08);
	do
	{
		int32 eax_83 = get_audio(gs, dwArg04, fp + ~0x0002641F);
		if (eax_83 >= 0x00)
		{
			encoder_progress(gs, dwArg04);
			Eq_82 eax_117 = lame_encode_buffer_int(dwArg04, fp + ~0x0002641F, fp + ~0x0002521F, eax_83, &dwLoc24010, 0x00024000);
			if (eax_117 < 0x00)
			{
				if (eax_117 == ~0x00)
					error_printf("mp3 buffer is not big enough... \n");
				else
					error_printf("mp3 internal error:  error code=%i\n");
				goto l0804BC72;
			}
			if (fwrite(&dwLoc24010, 0x01, eax_117, dwArg08) != eax_117)
			{
				error_printf("Error writing mp3 output \n");
				goto l0804BC72;
			}
		}
		if (flush_write == 0x01)
			fflush(dwArg08);
	} while (eax_83 > 0x00);
	Eq_82 dwLoc24018_529;
	if (dwArg0C != 0x00)
		dwLoc24018_529 = lame_encode_flush_nogap(dwArg04, &dwLoc24010, 0x00024000);
	else
		dwLoc24018_529 = lame_encode_flush(dwArg04, &dwLoc24010, 0x00024000);
	if (dwLoc24018_529 < 0x00)
	{
		if (dwLoc24018_529 == ~0x00)
			error_printf("mp3 buffer is not big enough... \n");
		else
			error_printf("mp3 internal error:  error code=%i\n");
	}
	else
	{
		encoder_progress_end(gs, dwArg04);
		if (fwrite(&dwLoc24010, 0x01, dwLoc24018_529, dwArg08) != dwLoc24018_529)
		{
			error_printf("Error writing mp3 output \n");
			goto l0804BC72;
		}
		if (flush_write == 0x01)
			fflush(dwArg08);
		Eq_82 eax_220 = lame_get_id3v1_tag(dwArg04, &dwLoc24010, 0x00024000);
		if (eax_220 > 0x00024000)
			error_printf("Error writing ID3v1 tag: buffer too small: buffer size=%d  ID3v1 size=%d\n");
		else if (eax_220 > 0x00)
		{
			if (fwrite(&dwLoc24010, 0x01, eax_220, dwArg08) != eax_220)
			{
				error_printf("Error writing ID3v1 tag \n");
				goto l0804BC72;
			}
			if (flush_write == 0x01)
				fflush(dwArg08);
		}
		if (silent <= 0x00)
			print_lame_tag_leading_info(dwArg04);
		if (fseek(dwArg08, eax_46, 0x00) != 0x00)
			error_printf("fatal error: can't update LAME-tag frame!\n");
		else
			write_xing_frame(gs, dwArg04, dwArg08);
		if (silent <= 0x00)
		{
			real64 rRet0_342;
			Top_32 = print_trailing_info(dwArg04, *Top_32, out rRet0_342);
			*Top_32 = rRet0_342;
		}
	}
l0804BC72:
	if ((eax_18 ^ gs->dw0014) == 0x00)
		return Top_32;
	__stack_chk_fail();
}

// 0804BC85: void brhist_init_package(Stack (ptr32 Eq_67) dwArg04)
// Called from:
//      main
void brhist_init_package(FILE * dwArg04)
{
	if (brhist != 0x00)
	{
		if (brhist_init(dwArg04, lame_get_VBR_min_bitrate_kbps(dwArg04), lame_get_VBR_max_bitrate_kbps(dwArg04)) != 0x00)
			brhist = 0x00;
	}
	else
		brhist_init(dwArg04, 0x80, 0x80);
}

// 0804BCF1: void parse_nogap_filenames(Stack word32 dwArg04, Stack (ptr32 Eq_161) dwArg08, Stack Eq_1106 dwArg0C, Stack (ptr32 char) dwArg10)
// Called from:
//      main
void parse_nogap_filenames(word32 dwArg04, union Eq_161 * dwArg08, Eq_1106 dwArg0C, char * dwArg10)
{
	strcpy(dwArg0C, dwArg10);
	if (dwArg04 == 0x00)
	{
		strncpy(dwArg0C, dwArg08, 0x0FFD);
		Eq_82 eax_207 = strlen(dwArg0C);
		if (Mem208[eax_207 - 0x03 + dwArg0C:byte] == 0x77 && (Mem208[(eax_207 - 0x02) + dwArg0C:byte] == 0x61 && (Mem208[(eax_207 - 0x01) + dwArg0C:byte] == 118 && Mem208[(eax_207 - 0x04) + dwArg0C:byte] == 0x2E)))
		{
			Mem263[eax_207 - 0x03 + dwArg0C:byte] = 0x6D;
			Mem267[eax_207 - 0x02 + dwArg0C:byte] = 0x70;
			Mem272[eax_207 - 0x01 + dwArg0C:byte] = 0x33;
		}
		else
		{
			Mem242[dwArg0C + eax_207:byte] = 0x2E;
			Mem246[eax_207 + 0x01 + dwArg0C:byte] = 0x6D;
			Mem250[eax_207 + 0x02 + dwArg0C:byte] = 0x70;
			Mem254[eax_207 + 0x03 + dwArg0C:byte] = 0x33;
			Mem259[eax_207 + 0x04 + dwArg0C:byte] = 0x00;
		}
	}
	else
	{
		union Eq_161 * dwLoc10_286 = &dwArg08->u0 + 0x0FFD;
		while (dwLoc10_286->u0 != 0x2F && (dwLoc10_286->u0 != 0x5C && (dwLoc10_286 != dwArg08 && dwLoc10_286->u0 != 0x3A)))
			--dwLoc10_286;
		if (dwLoc10_286 != dwArg08 && (Mem52[(strlen(dwArg0C) - 0x01) + dwArg0C:byte] == 0x2F || (Mem61[(strlen(dwArg0C) - 0x01) + dwArg0C:byte] == 0x5C || Mem70[(strlen(dwArg0C) - 0x01) + dwArg0C:byte] == 0x3A)))
			dwLoc10_286 = (union Eq_161 *) ((char *) dwLoc10_286 + 1);
		else if (dwLoc10_286 == dwArg08 && (Mem85[(strlen(dwArg0C) - 0x01) + dwArg0C:byte] != 0x2F && (Mem94[(strlen(dwArg0C) - 0x01) + dwArg0C:byte] != 0x5C && Mem103[(strlen(dwArg0C) - 0x01) + dwArg0C:byte] != 0x3A)))
			strcat(dwArg0C, "/");
		strncat(dwArg0C, dwLoc10_286, 0x0FFD);
		Eq_82 eax_133 = strlen(dwArg0C);
		if (Mem134[eax_133 - 0x03 + dwArg0C:byte] == 0x77 && (Mem134[(eax_133 - 0x02) + dwArg0C:byte] == 0x61 && (Mem134[(eax_133 - 0x01) + dwArg0C:byte] == 118 && Mem134[(eax_133 - 0x04) + dwArg0C:byte] == 0x2E)))
		{
			Mem189[eax_133 - 0x03 + dwArg0C:byte] = 0x6D;
			Mem193[eax_133 - 0x02 + dwArg0C:byte] = 0x70;
			Mem198[eax_133 - 0x01 + dwArg0C:byte] = 0x33;
		}
		else
		{
			Mem168[dwArg0C + eax_133:byte] = 0x2E;
			Mem172[eax_133 + 0x01 + dwArg0C:byte] = 0x6D;
			Mem176[eax_133 + 0x02 + dwArg0C:byte] = 0x70;
			Mem180[eax_133 + 0x03 + dwArg0C:byte] = 0x33;
			Mem185[eax_133 + 0x04 + dwArg0C:byte] = 0x00;
		}
	}
}

// 0804BFA5: void main(Register (ptr32 Eq_159) gs, Stack int32 dwArg04, Stack (ptr32 Eq_137) dwArg08)
void main(struct Eq_159 * gs, int32 dwArg04, struct Eq_137 * dwArg08)
{
	ptr32 fp;
	word32 dwLocCB428;
	Eq_1359 tLoc3034;
	Eq_1360 tLoc302C;
	Eq_1361 tLoc3028;
	word32 dwLoc301B;
	char bLoc201A;
	char tLoc1019;
	union Eq_161 * dwLoc3360;
	__align_stack<word32>(fp - 4);
	word32 eax_15 = gs->dw0014;
	tLoc3028 = (Eq_1361) ~0x00;
	tLoc302C = (Eq_1360) ~0x00;
	tLoc3034 = (Eq_1359) 200;
	memset(&dwLocCB428, 0x00, 0x000C80C8);
	word32 dwLoc3030_657 = 0x00;
	int32 dwLoc3038_661;
	for (dwLoc3038_661 = 0x00; dwLoc3038_661 <= 199; ++dwLoc3038_661)
		(fp - 0x3360)[dwLoc3038_661] = &dwLocCB428 + dwLoc3038_661 * 0x1001;
	memset(&dwLoc301B, 0x00, 0x1001);
	frontend_open_console(gs);
	input_format.u0 = 0x00;
	FILE * eax_62 = lame_init();
	if (eax_62 == null)
	{
		error_printf("fatal error during initialization\n");
		frontend_close_console();
	}
	else
	{
		lame_set_errorf(eax_62, 134531853);
		lame_set_debugf(eax_62, 0x0804CAC7);
		lame_set_msgf(eax_62, 134531818);
		if (dwArg04 <= 0x01)
		{
			usage(stderr, dwArg08->a0000[0]);
			lame_close(eax_62);
			frontend_close_console();
		}
		else
		{
			parse_args_from_string(eax_62, getenv("LAMEOPT"), &dwLoc301B, &tLoc1019);
			struct Eq_1475 * Top_127;
			if (parse_args(eax_62, dwArg04, dwArg08, &dwLoc301B, &tLoc1019, fp - 0x3360, &tLoc3034, out Top_127) < 0x00)
			{
				lame_close(eax_62);
				frontend_close_console();
			}
			else
			{
				Top_127->tFFFFFFFF.u0 = (real64) update_interval;
				Top_127->tFFFFFFFE.u0 = 0.0;
				Top_127->tFFFFFFFF.u0 = Top_127->tFFFFFFFF.u0;
				struct Eq_1475 * Top_143 = Top_127;
				if ((int8) (Top_127->tFFFFFFFE.u0 > (Top_127->tFFFFFFFF).u0) != 0x00)
					update_interval = 2.0F;
				if (tLoc1019 != 0x00 && tLoc3034 > 0x00)
				{
					strncpy(&bLoc201A, &tLoc1019, 0x1001);
					dwLoc3030_657 = 0x01;
				}
				union Eq_211 * dwLoc303C_709;
				if (tLoc3034 > 0x00)
				{
					parse_nogap_filenames(dwLoc3030_657, dwLoc3360, &tLoc1019, &bLoc201A);
					dwLoc303C_709 = init_files(gs, eax_62, dwLoc3360, &tLoc1019, &tLoc3028, &tLoc302C);
				}
				else
					dwLoc303C_709 = init_files(gs, eax_62, &dwLoc301B, &tLoc1019, &tLoc3028, &tLoc302C);
				if (dwLoc303C_709 == null)
				{
					lame_close(eax_62);
					frontend_close_console();
				}
				else
				{
					lame_set_write_id3tag_automatic(eax_62, 0x00);
					int32 eax_256 = lame_init_params(eax_62);
					if (eax_256 < 0x00)
					{
						if (eax_256 == ~0x00)
							display_bitrates(stderr);
						error_printf("fatal error during initialization\n");
						lame_close(eax_62);
						frontend_close_console();
					}
					else
					{
						if (silent > 0x00)
							brhist = 0x00;
						if (lame_get_decode_only(eax_62) != 0x00)
						{
							if (mp3_delay_set != 0x00)
								lame_decoder(gs, eax_62, dwLoc303C_709, mp3_delay.u0, &dwLoc301B, &tLoc1019, &tLoc3028, &tLoc302C);
							else
								lame_decoder(gs, eax_62, dwLoc303C_709, 0x00, &dwLoc301B, &tLoc1019, &tLoc3028, &tLoc302C);
						}
						else if (tLoc3034 > 0x00)
						{
							int32 dwLoc3038_782;
							for (dwLoc3038_782 = 0x00; dwLoc3038_782 < tLoc3034; ++dwLoc3038_782)
							{
								word32 eax_345 = (word32) (tLoc3034 - 0x01 != dwLoc3038_782);
								if (dwLoc3038_782 > 0x00)
								{
									parse_nogap_filenames(dwLoc3030_657, (fp - 0x3360)[dwLoc3038_782], &tLoc1019, &bLoc201A);
									dwLoc303C_709 = init_files(gs, eax_62, (fp - 0x3360)[dwLoc3038_782], &tLoc1019, &tLoc3028, &tLoc302C);
									lame_init_bitstream(eax_62);
								}
								brhist_init_package(eax_62);
								lame_set_nogap_total(eax_62, tLoc3034);
								lame_set_nogap_currentindex(eax_62, dwLoc3038_782);
								Top_143 = lame_encoder(gs, eax_62, dwLoc303C_709, eax_345, (fp - 0x3360)[dwLoc3038_782], &tLoc1019, Top_143->r0000);
								fclose(dwLoc303C_709);
								close_infile();
							}
						}
						else
						{
							brhist_init_package(eax_62);
							lame_encoder(gs, eax_62, dwLoc303C_709, 0x00, &dwLoc301B, &tLoc1019, Top_127->r0000);
							fclose(dwLoc303C_709);
							close_infile();
						}
						lame_close(eax_62);
						frontend_close_console();
					}
				}
			}
		}
	}
	if ((eax_15 ^ gs->dw0014) == 0x00)
		return;
	__stack_chk_fail();
}

// 0804C6C0: void my_console_printing(Stack (ptr32 Eq_1488) dwArg04, Stack (ptr32 char) dwArg08, Stack Eq_1746 dwArg0C)
// Called from:
//      frontend_msgf
//      console_printf
//      error_printf
//      report_printf
void my_console_printing(FILE * dwArg04, char * dwArg08, Eq_1746 dwArg0C)
{
	if (dwArg04 != null)
		vfprintf(dwArg04, dwArg08, dwArg0C);
}

// 0804C6EE: void my_error_printing(Stack (ptr32 Eq_1488) dwArg04, Stack (ptr32 char) dwArg08, Stack Eq_1746 dwArg0C)
// Called from:
//      frontend_errorf
void my_error_printing(FILE * dwArg04, char * dwArg08, Eq_1746 dwArg0C)
{
	if (dwArg04 != null)
		vfprintf(dwArg04, dwArg08, dwArg0C);
}

// 0804C71C: void my_report_printing(Stack (ptr32 Eq_1488) dwArg04, Stack (ptr32 char) dwArg08, Stack Eq_1746 dwArg0C)
// Called from:
//      frontend_debugf
void my_report_printing(FILE * dwArg04, char * dwArg08, Eq_1746 dwArg0C)
{
	if (dwArg04 != null)
		vfprintf(dwArg04, dwArg08, dwArg0C);
}

// 0804C74A: void apply_termcap_settings(Register (ptr32 Eq_159) gs, Stack (ptr32 Eq_1778) dwArg04)
// Called from:
//      init_console
void apply_termcap_settings(struct Eq_159 * gs, struct Eq_1778 * dwArg04)
{
	ptr32 fp;
	word32 eax_12 = gs->dw0014;
	char * eax_16 = getenv("TERM");
	if (eax_16 != null && tgetent(fp + ~0x0819, eax_16) == 0x01)
	{
		int32 eax_30 = tgetnum(134565685);
		if (eax_30 > 0x27 && eax_30 <= 0x0200)
			dwArg04->dw0014 = eax_30;
		int32 eax_46 = tgetnum(0x08054F38);
		if (eax_46 > 0x0F && eax_46 <= 0x0100)
			dwArg04->dw0018 = eax_46;
		char * eax_68 = tgetstr(134565691, fp + ~0x0823, fp - 26, 0x00);
		if (eax_68 != null)
			strcpy(&dwArg04->dw0018 + 1, eax_68);
		char * eax_95 = tgetstr(134565694, fp + ~0x0823, fp - 26, 0x00);
		if (eax_95 != null)
			strcpy((char *) &dwArg04->dw0018 + 0x0E, eax_95);
		char * eax_122 = tgetstr(0x08054F41, fp + ~0x0823, fp - 26, 0x00);
		if (eax_122 != null)
			strcpy(&dwArg04->dw0018 + 6, eax_122);
		char * eax_149 = tgetstr(0x08054F44, fp + ~0x0823, fp - 26, 0x00);
		if (eax_149 != null)
			strcpy((char *) &dwArg04->dw0018 + 0x0022, eax_149);
	}
	if ((eax_12 ^ gs->dw0014) == 0x00)
		return;
	__stack_chk_fail();
}

// 0804C978: void init_console(Register (ptr32 Eq_159) gs, Stack (ptr32 Eq_1778) dwArg04)
// Called from:
//      frontend_open_console
void init_console(struct Eq_159 * gs, struct Eq_1778 * dwArg04)
{
	dwArg04->dw0014 = 0x50;
	dwArg04->dw0018 = 0x19;
	dwArg04->ptr0008 = stderr;
	dwArg04->ptr000C = stderr;
	dwArg04->dw0010 = 0x00;
	setvbuf(dwArg04->ptr0008, &dwArg04->dw0018 + 11, 0x00, 0x0800);
	memcpy(&dwArg04->dw0018 + 1, &g_v8054F47, 0x04);
	apply_termcap_settings(gs, dwArg04);
	dwArg04->dw0000 = 0x434F4E53;
	dwArg04->dw0844 = 0x00;
}

// 0804CA23: void deinit_console(Stack (ptr32 Eq_1965) dwArg04)
// Called from:
//      frontend_close_console
void deinit_console(struct Eq_1965 * dwArg04)
{
	if (dwArg04->ptr0010 != null)
	{
		fclose(dwArg04->ptr0010);
		dwArg04->ptr0010 = null;
	}
	fflush(dwArg04->ptr0008);
	setvbuf(dwArg04->ptr0008, null, 0x02, 0x00);
	memset((char *) &dwArg04->ptr0010 + 52, 0x55, 0x0400);
}

// 0804CA9F: void frontend_open_console(Register (ptr32 Eq_159) gs)
// Called from:
//      main
void frontend_open_console(struct Eq_159 * gs)
{
	init_console(gs, &g_t805BCE0);
}

// 0804CAB3: void frontend_close_console()
// Called from:
//      main
void frontend_close_console()
{
	deinit_console(&g_t805BCE0);
}

// 0804CAC7: void frontend_debugf(Stack (ptr32 char) dwArg04, Stack Eq_1746 dwArg08)
void frontend_debugf(char * dwArg04, Eq_1746 dwArg08)
{
	my_report_printing(g_ptr805BCF0, dwArg04, dwArg08);
}

// 0804CAEA: void frontend_msgf(Stack (ptr32 char) dwArg04, Stack Eq_1746 dwArg08)
void frontend_msgf(char * dwArg04, Eq_1746 dwArg08)
{
	my_console_printing(g_ptr805BCE8, dwArg04, dwArg08);
}

// 0804CB0D: void frontend_errorf(Stack (ptr32 char) dwArg04, Stack Eq_1746 dwArg08)
void frontend_errorf(char * dwArg04, Eq_1746 dwArg08)
{
	my_error_printing(g_ptr805BCEC, dwArg04, dwArg08);
}

// 0804CB30: void console_printf(Stack (ptr32 char) dwArg04)
// Called from:
//      lame_decoder
//      print_lame_tag_leading_info
//      print_trailing_info
//      OpenSndFile
//      lame_decode_initfile
//      genre_list_handler
//      parse_args
//      ts_time_decompose
//      timestatus
//      timestatus_finish
//      encoder_progress_begin
//      decoder_progress
//      decoder_progress_finish
//      brhist_disp_line
//      progress_line
//      stats_value
//      stats_head
//      stats_line
void console_printf(char * dwArg04)
{
	ptr32 fp;
	my_console_printing(g_ptr805BCE8, dwArg04, fp + 8);
}

// 0804CB5F: void error_printf(Stack (ptr32 char) dwArg04)
// Called from:
//      init_files
//      lame_decoder
//      print_trailing_info
//      write_xing_frame
//      lame_encoder
//      main
//      set_debug_file
//      fskip
//      read_samples_mp3
//      read_samples_pcm
//      parse_wave_header
//      aiff_check2
//      parse_aiff_header
//      parse_file_header
//      CloseSndFile
//      OpenSndFile
//      lame_decode_initfile
//      presets_set
//      resample_rate
//      set_id3_albumart
//      parse_args
//      brhist_init
void error_printf(char * dwArg04)
{
	ptr32 fp;
	my_console_printing(g_ptr805BCEC, dwArg04, fp + 8);
}

// 0804CB8E: void report_printf(Stack (ptr32 char) dwArg04)
void report_printf(char * dwArg04)
{
	ptr32 fp;
	my_console_printing(g_ptr805BCF0, dwArg04, fp + 8);
}

// 0804CBBD: void console_flush()
// Called from:
//      lame_decoder
//      console_up
//      encoder_progress
void console_flush()
{
	fflush(g_ptr805BCE8);
}

// 0804CBD2: void error_flush()
void error_flush()
{
	fflush(g_ptr805BCEC);
}

// 0804CBE7: void report_flush()
void report_flush()
{
	fflush(g_ptr805BCF0);
}

// 0804CBFC: void console_up(Stack int32 dwArg04)
// Called from:
//      brhist_jump_back
void console_up(int32 dwArg04)
{
	while (true)
	{
		--dwArg04;
		if ((int8) (dwArg04 > 0x00) == 0x00)
			break;
		fputs(&g_b805BCFC, g_ptr805BCE8);
	}
	console_flush();
}

// 0804CC31: void set_debug_file(Stack (ptr32 char) dwArg04)
void set_debug_file(char * dwArg04)
{
	if (g_ptr805BCF0 == null)
	{
		g_ptr805BCF0 = fopen64(dwArg04, "a");
		if (g_ptr805BCF0 != null)
			error_printf("writing debug info into: %s\n");
		else
			error_printf("Error: can't open for debug info: %s\n");
	}
}

// 0804CC8C: Register (ptr32 Eq_2112) min_size_t(Stack (ptr32 Eq_2112) dwArg04, Stack (ptr32 Eq_2112) dwArg08)
// Called from:
//      fskip
FILE * min_size_t(FILE * dwArg04, FILE * dwArg08)
{
	FILE * eax_11;
	if (dwArg04 < dwArg08)
		eax_11 = dwArg04;
	else
		eax_11 = dwArg08;
	return eax_11;
}

// 0804CCA1: void machine_byte_order()
void machine_byte_order()
{
}

// 0804CCBE: Register word32 fskip(Register (ptr32 Eq_159) gs, Stack (ptr32 Eq_2112) dwArg04, Stack (ptr32 Eq_2112) dwArg08, Stack int32 dwArg0C, Register out Eq_2122 edxOut)
// Called from:
//      parse_wave_header
//      parse_aiff_header
//      lame_decode_initfile
word32 fskip(struct Eq_159 * gs, FILE * dwArg04, FILE * dwArg08, int32 dwArg0C, union Eq_2122 & edxOut)
{
	ptr32 fp;
	word32 dwLoc1010;
	ui32 dwLoc1074;
	word32 eax_100;
	word32 eax_12 = gs->dw0014;
	if (fstat64(fileno(dwArg04), fp + ~0x1083) == 0x00 && (dwLoc1074 & 0xF000) == 0x1000)
	{
		if (dwArg0C == 0x01 && dwArg08 >= null)
		{
			for (; dwArg08 > null; dwArg08 -= eax_126)
			{
				Eq_82 eax_126 = fread(&dwLoc1010, 0x01, min_size_t((FILE *) 0x1000, dwArg08), dwArg04);
				if (eax_126 == 0x00)
				{
					eax_100 = ~0x00;
					goto l0804CE7A;
				}
			}
			eax_100 = 0x00;
		}
		else
			eax_100 = ~0x00;
	}
	else if (fseek(dwArg04, dwArg08, dwArg0C) == 0x00)
		eax_100 = 0x00;
	else if (dwArg0C == 0x01 && dwArg08 >= null)
	{
		for (; dwArg08 > null; dwArg08 -= eax_78)
		{
			Eq_82 eax_78 = fread(&dwLoc1010, 0x01, min_size_t((FILE *) 0x1000, dwArg08), dwArg04);
			if (eax_78 == 0x00)
			{
				eax_100 = ~0x00;
				goto l0804CE7A;
			}
		}
		eax_100 = 0x00;
	}
	else
	{
		if (silent <= 0x09)
			error_printf("fskip problem: Mostly the return status of functions is not evaluate so it is more secure to polute <stderr>.\n");
		eax_100 = ~0x00;
	}
l0804CE7A:
	Eq_2122 edx_152 = eax_12 ^ gs->dw0014;
	if (edx_152 == 0x00)
	{
		edxOut = edx_152;
		return eax_100;
	}
	else
		__stack_chk_fail();
}

// 0804CE8D: Register (ptr32 Eq_1488) init_outfile(Stack (ptr32 char) dwArg04)
// Called from:
//      init_files
FILE * init_outfile(char * dwArg04)
{
	FILE * eax_25;
	FILE * dwLoc10_45;
	if (strcmp(dwArg04, "-") == 0x00)
	{
		dwLoc10_45 = stdout;
		lame_set_stream_binary_mode();
	}
	else
	{
		FILE * eax_21 = fopen64(dwArg04, "w+b");
		dwLoc10_45 = eax_21;
		if (eax_21 == null)
		{
			eax_25 = null;
			return eax_25;
		}
	}
	eax_25 = dwLoc10_45;
	return eax_25;
}

// 0804CEE8: void init_infile(Register (ptr32 Eq_159) gs, Stack (ptr32 Eq_67) dwArg04, Stack (ptr32 Eq_161) dwArg08, Stack (ptr32 Eq_163) dwArg0C, Stack (ptr32 Eq_164) dwArg10)
// Called from:
//      init_files
void init_infile(struct Eq_159 * gs, FILE * dwArg04, union Eq_161 * dwArg08, struct Eq_163 * dwArg0C, struct Eq_164 * dwArg10)
{
	g_dw805B3CC = 0x00;
	g_dw805B3DC = 0x00;
	g_dw805B3D0 = in_bitwidth;
	g_dw805B3D4 = swapbytes;
	g_dw805B3D8 = (word32) (in_signed != 0x01);
	OpenSndFile(gs, dwArg04, dwArg08, dwArg0C, dwArg10);
	g_ptr805B3E0 = dwArg04;
}

// 0804CF50: void close_infile()
// Called from:
//      main
void close_infile()
{
	CloseSndFile(g_ptr805B3E0);
}

// 0804CF6F: void SwapBytesInWords(Stack (ptr32 Eq_2285) dwArg04, Stack int32 dwArg08)
void SwapBytesInWords(union Eq_2285 * dwArg04, int32 dwArg08)
{
	union Eq_2285 * dwLoc0C_69 = dwArg04;
	for (; dwArg08 > 0x01; dwArg08 -= 0x02)
	{
		uint32 eax_17 = dwLoc0C_69->u0;
		dwLoc0C_69->u0 = eax_17 << 0x08 & 0xFF00FF00 | eax_17 >> 0x08 & 0x00FF00FF;
		dwLoc0C_69 = (union Eq_2285 *) ((char *) dwLoc0C_69 + 4);
	}
	union Eq_2285 * dwArg04_75 = dwLoc0C_69;
	for (; dwArg08 > 0x00; --dwArg08)
	{
		Eq_2313 eax_43 = (int32) dwArg04_75->u1.t0000.u0;
		dwArg04_75->u1.t0000.u0 = (word16) (eax_43 >> 0x08) & 0xFF | (word16) eax_43 << 0x08;
		dwArg04_75 = (union Eq_2285 *) ((char *) dwArg04_75 + 2);
	}
}

// 0804CFF1: Register word32 get_audio(Register (ptr32 Eq_159) gs, Stack (ptr32 Eq_67) dwArg04, Stack (ptr32 Eq_957) dwArg08)
// Called from:
//      lame_encoder
word32 get_audio(struct Eq_159 * gs, FILE * dwArg04, struct Eq_957 * dwArg08)
{
	return get_audio_common(gs, dwArg04, dwArg08, null);
}

// 0804D013: Register word32 get_audio16(Register (ptr32 Eq_159) gs, Stack (ptr32 Eq_67) dwArg04, Stack (ptr32 Eq_462) dwArg08)
// Called from:
//      lame_decoder
word32 get_audio16(struct Eq_159 * gs, FILE * dwArg04, struct Eq_462 * dwArg08)
{
	return get_audio_common(gs, dwArg04, null, dwArg08);
}

// 0804D035: Register Eq_2347 get_audio_common(Register (ptr32 Eq_159) gs, Stack (ptr32 Eq_67) dwArg04, Stack (ptr32 Eq_957) dwArg08, Stack (ptr32 Eq_462) dwArg0C)
// Called from:
//      get_audio
//      get_audio16
Eq_2347 get_audio_common(struct Eq_159 * gs, FILE * dwArg04, struct Eq_957 * dwArg08, struct Eq_462 * dwArg0C)
{
	ptr32 fp;
	word32 dwLoc122C;
	int32 eax_12 = lame_get_num_channels(dwArg04);
	Eq_2354 eax_19 = lame_get_framesize(dwArg04, eax_12);
	up32 eax_28 = lame_get_num_samples(dwArg04, eax_19);
	Eq_2354 dwLoc1C_356 = eax_19;
	if (g_dw805B3CC != 0x00)
	{
		up32 edx_38 = g_dw805B3DC;
		up32 eax_39 = eax_28;
		if (edx_38 <= eax_28)
			eax_39 = edx_38;
		Eq_2354 ecx_48 = eax_28 - eax_39;
		if (eax_19 > ecx_48 && eax_28 != 0x00)
			dwLoc1C_356 = ecx_48;
	}
	Eq_2347 dwLoc14_373;
	Eq_2347 eax_224;
	if (is_mpeg_file_format(input_format.u0) != 0x00)
	{
		if (dwArg08 != null)
			dwLoc14_373 = read_samples_mp3(gs, dwArg04, g_ptr805B3E0, &dwLoc122C);
		else
			dwLoc14_373 = read_samples_mp3(gs, dwArg04, g_ptr805B3E0, dwArg0C);
		if (dwLoc14_373 < 0x00)
		{
			eax_224 = dwLoc14_373;
			return eax_224;
		}
	}
	else
	{
		Eq_2347 eax_82 = read_samples_pcm(g_ptr805B3E0, fp + ~0x362B, eax_12 *s dwLoc1C_356);
		if (eax_82 < 0x00)
		{
			eax_224 = eax_82;
			return eax_224;
		}
		Eq_2347 eax_104 = (int32) (SEQ(eax_82 >> 0x1F, eax_82) /32 eax_12);
		int32 * dwLoc2C_372 = fp + ~0x362B + eax_82 * 0x04;
		dwLoc14_373 = eax_104;
		if (dwArg08 != null)
		{
			if (eax_12 == 0x02)
			{
				Eq_2347 dwLoc28_405 = eax_104;
				while (true)
				{
					Eq_2347 v20_204 = dwLoc28_405 - 0x01;
					dwLoc28_405 = v20_204;
					if (v20_204 < 0x00)
						break;
					struct Eq_2499 * v22_211 = dwLoc2C_372 - 0x04;
					dwArg08->a1200[v20_204] = v22_211->dw0000;
					dwArg08[v20_204 * 0x04 / 0x00001200] = (struct Eq_957) v22_211->dwFFFFFFFC;
					dwLoc2C_372 = v22_211 - 0x04;
				}
			}
			else if (eax_12 == 0x01)
			{
				memset(dwArg08->a1200, 0x00, eax_104 * 0x04);
				Eq_2347 dwLoc28_399 = eax_104;
				while (true)
				{
					Eq_2347 v25_188 = dwLoc28_399 - 0x01;
					dwLoc28_399 = v25_188;
					if (v25_188 < 0x00)
						break;
					int32 * v31_193 = dwLoc2C_372 - 0x04;
					dwArg08[v25_188 * 0x04 / 0x00001200] = (struct Eq_957) *v31_193;
					dwLoc2C_372 = v31_193;
				}
			}
		}
		else if (eax_12 == 0x02)
		{
			Eq_2347 dwLoc28_389 = eax_104;
			while (true)
			{
				Eq_2347 v26_145 = dwLoc28_389 - 0x01;
				dwLoc28_389 = v26_145;
				if (v26_145 < 0x00)
					break;
				struct Eq_2552 * v27_152 = dwLoc2C_372 - 0x04;
				dwArg0C->a0900[v26_145] = (word16) (v27_152->dw0000 >> 0x10);
				dwArg0C[v26_145 * 0x02 / 0x0900] = (struct Eq_462) (word16) (v27_152->dwFFFFFFFC >> 0x10);
				dwLoc2C_372 = v27_152 - 0x04;
			}
		}
		else if (eax_12 == 0x01)
		{
			memset(dwArg0C->a0900, 0x00, eax_104 * 0x02);
			Eq_2347 dwLoc28_383 = eax_104;
			while (true)
			{
				Eq_2347 v30_125 = dwLoc28_383 - 0x01;
				dwLoc28_383 = v30_125;
				if (v30_125 < 0x00)
					break;
				int32 * v32_130 = dwLoc2C_372 - 0x04;
				dwArg0C[v30_125 * 0x02 / 0x0900] = (struct Eq_462) (word16) (*v32_130 >> 0x10);
				dwLoc2C_372 = v32_130;
			}
		}
	}
	if (is_mpeg_file_format(input_format.u0) != 0x00 && dwArg08 != null)
	{
		Eq_2347 dwLoc28_433 = dwLoc14_373;
		while (true)
		{
			Eq_2347 v15_285 = dwLoc28_433 - 0x01;
			dwLoc28_433 = v15_285;
			if (v15_285 < 0x00)
				break;
			dwArg08[v15_285 * 0x04 / 0x00001200] = (struct Eq_957) ((int32) (&dwLoc122C)[v15_285].u0 << 0x10);
		}
		if (eax_12 == 0x02)
		{
			Eq_2347 dwLoc28_448 = dwLoc14_373;
			while (true)
			{
				Eq_2347 v19_317 = dwLoc28_448 - 0x01;
				dwLoc28_448 = v19_317;
				if (v19_317 < 0x00)
					break;
				dwArg08->a1200[v19_317] = (int32) (&dwLoc122C)[(word32) v19_317.u0 + 1152].u0 << 0x10;
			}
		}
		else if (eax_12 == 0x01)
			memset(dwArg08->a1200, 0x00, dwLoc14_373 * 0x04);
	}
	if (eax_28 != ~0x00)
		g_dw805B3DC = (word32) dwLoc14_373.u0 + g_dw805B3DC;
	eax_224 = dwLoc14_373;
	return eax_224;
}

// 0804D384: Register int32 read_samples_mp3(Register (ptr32 Eq_159) gs, Stack (ptr32 Eq_67) dwArg04, Stack (ptr32 Eq_67) dwArg08, Stack (ptr32 Eq_462) dwArg0C)
// Called from:
//      get_audio_common
int32 read_samples_mp3(struct Eq_159 * gs, FILE * dwArg04, FILE * dwArg08, struct Eq_462 * dwArg0C)
{
	int32 eax_129;
	int32 eax_19 = lame_decode_fromfile(gs, dwArg08, dwArg0C, dwArg0C->a0900, 0x0805C560);
	int32 dwLoc10_102 = eax_19;
	if (eax_19 < 0x00)
	{
		memset(dwArg0C, 0x00, 0x1200);
		eax_129 = 0x00;
	}
	else
	{
		if (lame_get_num_channels(dwArg04) != g_dw805C564)
		{
			if (silent <= 0x09)
				error_printf("Error: number of channels has changed in %s - not supported\n");
			dwLoc10_102 = ~0x00;
		}
		if (lame_get_in_samplerate(dwArg04) != g_dw805C568)
		{
			if (silent <= 0x09)
				error_printf("Error: sample frequency has changed in %s - not supported\n");
			dwLoc10_102 = ~0x00;
		}
		eax_129 = dwLoc10_102;
	}
	return eax_129;
}

// 0804D455: void WriteWaveHeader(Stack (ptr32 Eq_211) dwArg04, Stack Eq_381 dwArg08, Stack Eq_381 dwArg0C, Stack Eq_218 dwArg10, Stack Eq_218 dwArg14)
// Called from:
//      lame_decoder
void WriteWaveHeader(union Eq_211 * dwArg04, Eq_381 dwArg08, Eq_381 dwArg0C, Eq_218 dwArg10, Eq_218 dwArg14)
{
	int32 eax_10 = (word32) dwArg14.u0 + 7;
	if (dwArg14 < ~0x06)
		eax_10 = (word32) dwArg14.u0 + 0x0E;
	fwrite(&g_v805508B, 0x01, 0x04, dwArg04);
	Write32BitsLowHigh(dwArg04, (word32) dwArg08 + 36);
	fwrite(&g_v8055090, 0x02, 0x04, dwArg04);
	Write32BitsLowHigh(dwArg04, 0x10);
	Write16BitsLowHigh(dwArg04, 0x01);
	Write16BitsLowHigh(dwArg04, dwArg10);
	Write32BitsLowHigh(dwArg04, dwArg0C);
	int32 eax_18 = eax_10 >> 0x03;
	Write32BitsLowHigh(dwArg04, dwArg0C *s dwArg10 *s eax_18);
	Write16BitsLowHigh(dwArg04, dwArg10 *s eax_18);
	Write16BitsLowHigh(dwArg04, dwArg14);
	fwrite(&g_v8055099, 0x01, 0x04, dwArg04);
	Write32BitsLowHigh(dwArg04, dwArg08);
	ferror(dwArg04) == 0x00;
}

// 0804D5A8: void unpack_read_samples(Stack Eq_82 dwArg04, Stack Eq_82 dwArg08, Stack word32 dwArg0C, Stack (ptr32 void) dwArg10, Stack (ptr32 Eq_67) dwArg14)
// Called from:
//      read_samples_pcm
void unpack_read_samples(Eq_82 dwArg04, Eq_82 dwArg08, word32 dwArg0C, void * dwArg10, FILE * dwArg14)
{
	Eq_82 eax_26 = fread(dwArg10, dwArg08, dwArg04, dwArg14);
	ui32 * dwLoc18_516 = (char *) dwArg10 + (eax_26 << 0x02);
	if (dwArg0C == 0x00)
	{
		if (dwArg08 == 0x01)
		{
			int32 dwLoc14_559 = dwArg08 *s eax_26;
			while (true)
			{
				int32 v12_271 = dwLoc14_559 - dwArg08;
				dwLoc14_559 = v12_271;
				if (v12_271 < 0x00)
					break;
				ui32 * v33_275 = dwLoc18_516 - 0x04;
				*v33_275 = (word32) *((char *) dwArg10 + v12_271) << 0x18;
				dwLoc18_516 = v33_275;
			}
		}
		if (dwArg08 == 0x02)
		{
			int32 dwLoc14_570 = dwArg08 *s eax_26;
			while (true)
			{
				int32 v15_301 = dwLoc14_570 - dwArg08;
				dwLoc14_570 = v15_301;
				if (v15_301 < 0x00)
					break;
				ui32 * v32_305 = dwLoc18_516 - 0x04;
				*v32_305 = (word32) *((char *) dwArg10 + v15_301) << 0x10 | (word32) (*((char *) dwArg10 + (v15_301 + 0x01))) << 0x18;
				dwLoc18_516 = v32_305;
			}
		}
		if (dwArg08 == 0x03)
		{
			int32 dwLoc14_581 = dwArg08 *s eax_26;
			while (true)
			{
				int32 v23_349 = dwLoc14_581 - dwArg08;
				dwLoc14_581 = v23_349;
				if (v23_349 < 0x00)
					break;
				ui32 * v30_353 = dwLoc18_516 - 0x04;
				*v30_353 = (word32) *((char *) dwArg10 + v23_349) << 0x08 | (word32) (*((char *) dwArg10 + (v23_349 + 0x01))) << 0x10 | (word32) (*((char *) dwArg10 + (v23_349 + 0x02))) << 0x18;
				dwLoc18_516 = v30_353;
			}
		}
		if (dwArg08 == 0x04)
		{
			int32 dwLoc14_592 = dwArg08 *s eax_26;
			while (true)
			{
				int32 v25_411 = dwLoc14_592 - dwArg08;
				dwLoc14_592 = v25_411;
				if (v25_411 < 0x00)
					break;
				ui32 * v28_415 = dwLoc18_516 - 0x04;
				*v28_415 = (word32) *((char *) dwArg10 + v25_411) << 0x00 | (word32) (*((char *) dwArg10 + (v25_411 + 0x01))) << 0x08 | (word32) (*((char *) dwArg10 + (v25_411 + 0x02))) << 0x10 | (word32) (*((char *) dwArg10 + (v25_411 + 0x03))) << 0x18;
				dwLoc18_516 = v28_415;
			}
		}
	}
	else
	{
		if (dwArg08 == 0x01)
		{
			int32 dwLoc14_518 = dwArg08 *s eax_26;
			while (true)
			{
				int32 v14_43 = dwLoc14_518 - dwArg08;
				dwLoc14_518 = v14_43;
				if (v14_43 < 0x00)
					break;
				ui32 * v16_47 = dwLoc18_516 - 0x04;
				*v16_47 = (word32) (*((char *) dwArg10 + v14_43) ^ 0x80) << 0x18 | 0x007F0000;
				dwLoc18_516 = v16_47;
			}
		}
		if (dwArg08 == 0x02)
		{
			int32 dwLoc14_529 = dwArg08 *s eax_26;
			while (true)
			{
				int32 v22_87 = dwLoc14_529 - dwArg08;
				dwLoc14_529 = v22_87;
				if (v22_87 < 0x00)
					break;
				ui32 * v31_91 = dwLoc18_516 - 0x04;
				*v31_91 = (word32) *((char *) dwArg10 + v22_87) << 0x18 | (word32) (*((char *) dwArg10 + (v22_87 + 0x01))) << 0x10;
				dwLoc18_516 = v31_91;
			}
		}
		if (dwArg08 == 0x03)
		{
			int32 dwLoc14_540 = dwArg08 *s eax_26;
			while (true)
			{
				int32 v24_135 = dwLoc14_540 - dwArg08;
				dwLoc14_540 = v24_135;
				if (v24_135 < 0x00)
					break;
				ui32 * v27_139 = dwLoc18_516 - 0x04;
				*v27_139 = (word32) *((char *) dwArg10 + v24_135) << 0x18 | (word32) (*((char *) dwArg10 + (v24_135 + 0x01))) << 0x10 | (word32) (*((char *) dwArg10 + (v24_135 + 0x02))) << 0x08;
				dwLoc18_516 = v27_139;
			}
		}
		if (dwArg08 == 0x04)
		{
			int32 dwLoc14_551 = dwArg08 *s eax_26;
			while (true)
			{
				int32 v26_197 = dwLoc14_551 - dwArg08;
				dwLoc14_551 = v26_197;
				if (v26_197 < 0x00)
					break;
				ui32 * v29_201 = dwLoc18_516 - 0x04;
				*v29_201 = (word32) *((char *) dwArg10 + v26_197) << 0x18 | (word32) (*((char *) dwArg10 + (v26_197 + 0x01))) << 0x10 | (word32) (*((char *) dwArg10 + (v26_197 + 0x02))) << 0x08 | (word32) (*((char *) dwArg10 + (v26_197 + 0x03))) << 0x00;
				dwLoc18_516 = v29_201;
			}
		}
	}
}

// 0804D9AB: Register Eq_82 read_samples_pcm(Stack (ptr32 Eq_67) dwArg04, Stack (ptr32 void) dwArg08, Stack Eq_82 dwArg0C)
// Called from:
//      get_audio_common
Eq_82 read_samples_pcm(FILE * dwArg04, void * dwArg08, Eq_82 dwArg0C)
{
	int32 eax_9 = g_dw805B3D0;
	if (eax_9 != 0x10)
	{
		if (eax_9 <= 0x10)
		{
			if (eax_9 != 0x08)
			{
l0804DA8B:
				if (silent <= 0x09)
					error_printf("Only 8, 16, 24 and 32 bit input files supported \n");
				exit(0x01);
			}
			unpack_read_samples(dwArg0C, 0x01, g_dw805B3D8, dwArg08, dwArg04);
l0804DAAD:
			if (ferror(dwArg04) == 0x00)
				return dwArg0C;
			if (silent <= 0x09)
				error_printf("Error reading input file\n");
			exit(0x01);
		}
		if (eax_9 != 0x18 && eax_9 != 0x20)
			goto l0804DA8B;
	}
	if (in_signed == 0x00)
	{
		error_printf("Unsigned input only supported with bitwidth 8\n");
		exit(0x01);
	}
	word32 eax_28 = (word32) (in_endian != 0x00);
	word32 dwLoc14_138 = eax_28;
	if (g_dw805B3D4 != 0x00)
		dwLoc14_138 = (word32) (eax_28 == 0x00);
	int32 eax_42 = g_dw805B3D0;
	if (eax_42 < 0x00)
		eax_42 += 7;
	unpack_read_samples(dwArg0C, eax_42 >> 0x03, dwLoc14_138, dwArg08, dwArg04);
	goto l0804DAAD;
}

// 0804DAE3: Register word32 parse_wave_header(Register (ptr32 Eq_159) gs, Stack (ptr32 Eq_67) dwArg04, Stack (ptr32 Eq_2112) dwArg08)
// Called from:
//      parse_file_header
word32 parse_wave_header(struct Eq_159 * gs, FILE * dwArg04, FILE * dwArg08)
{
	word32 eax_243;
	Read32BitsHighLow(dwArg08);
	Read32BitsHighLow(dwArg08);
	int32 dwLoc10_349 = 0x00;
	int32 dwLoc14_350 = 0x00;
	int32 dwLoc1C_352 = 0x00;
	FILE * dwLoc20_353 = null;
	word32 dwLoc28_355 = 0x00;
	FILE * dwLoc2C_356 = null;
	if (dwArg08 != WAV_ID_WAVE)
		eax_243 = ~0x00;
	else
	{
		int32 dwLoc38_363;
		for (dwLoc38_363 = 0x00; dwLoc38_363 <= 0x13; ++dwLoc38_363)
		{
			Read32BitsHighLow(dwArg08);
			if (dwArg08 == WAV_ID_FMT)
			{
				Read32Bits(dwArg08);
				if (dwArg08 <= (FILE *) 0x0F)
				{
					eax_243 = ~0x00;
					return eax_243;
				}
				int32 eax_107 = Read16BitsLowHigh(dwArg08);
				dwLoc14_350 = Read16BitsLowHigh(dwArg08);
				Read32Bits(dwArg08);
				Read32Bits(dwArg08);
				Read16BitsLowHigh(dwArg08);
				dwLoc10_349 = eax_107;
				dwLoc20_353 = dwArg08;
				dwLoc1C_352 = Read16BitsLowHigh(dwArg08);
				FILE * dwLoc34_396 = dwArg08 - 0x10;
				if (dwArg08 > (FILE *) 0x19 && (int32) g_w8055152 == eax_107)
				{
					Read16BitsLowHigh(dwArg08);
					Read16BitsLowHigh(dwArg08);
					Read32Bits(dwArg08);
					dwLoc10_349 = Read16BitsLowHigh(dwArg08);
					dwLoc34_396 = dwArg08 - 0x1A;
				}
				if (dwLoc34_396 > null)
				{
					word32 edx_526;
					if (fskip(gs, dwArg08, dwLoc34_396, 0x01, out edx_526) != 0x00)
					{
						eax_243 = ~0x00;
						return eax_243;
					}
				}
			}
			else
			{
				if (dwArg08 == WAV_ID_DATA)
				{
					Read32Bits(dwArg08);
					dwLoc2C_356 = dwArg08;
					dwLoc28_355 = 0x01;
					break;
				}
				Read32Bits(dwArg08);
				word32 edx_525;
				if (fskip(gs, dwArg08, dwArg08, 0x01, out edx_525) != 0x00)
				{
					eax_243 = ~0x00;
					return eax_243;
				}
			}
		}
		if (dwLoc28_355 != 0x00)
		{
			if ((int32) g_w8055150 != dwLoc10_349)
			{
				if (silent <= 0x09)
					error_printf("Unsupported data format: 0x%04X\n");
				eax_243 = 0x00;
			}
			else if (lame_set_num_channels(dwArg04, dwLoc14_350) == ~0x00)
			{
				if (silent <= 0x09)
					error_printf("Unsupported number of channels: %u\n");
				eax_243 = 0x00;
			}
			else
			{
				lame_set_in_samplerate(dwArg04, dwLoc20_353);
				g_dw805B3D0 = dwLoc1C_352;
				g_dw805B3D8 = 0x01;
				int32 eax_280 = dwLoc1C_352 + 0x07;
				if (dwLoc1C_352 < ~0x06)
					eax_280 = dwLoc1C_352 + 0x0E;
				int32 edx_292 = (eax_280 >> 0x03) *s dwLoc14_350;
				lame_set_num_samples(dwArg04, (int32) (SEQ(dwLoc2C_356 >> 0x1F, dwLoc2C_356) /32 edx_292), edx_292);
				eax_243 = 0x01;
			}
		}
		else
			eax_243 = ~0x00;
	}
	return eax_243;
}

// 0804DDD0: Register word32 aiff_check2(Stack (ptr32 Eq_3245) dwArg04)
// Called from:
//      parse_aiff_header
word32 aiff_check2(struct Eq_3245 * dwArg04)
{
	word32 eax_136;
	if (dwArg04->ptr0014 != IFF_ID_SSND)
	{
		if (silent <= 0x09)
			error_printf("ERROR: input sound data is not PCM\n");
		eax_136 = 0x01;
	}
	else
	{
		Eq_3253 eax_20 = (int32) dwArg04->w0008;
		if (eax_20 <= 0x20 && eax_20 >= 0x08 && (0x01 << (byte) eax_20 - 0x08 & 0x01010101) != 0x00)
		{
			if (dwArg04->w0000 == 0x01 || dwArg04->w0000 == 0x02)
			{
				if (dwArg04->dw001C != 0x00)
				{
					if (silent <= 0x09)
						error_printf("ERROR: block size of input sound data is not 0 bytes\n");
					eax_136 = 0x01;
				}
				else
					eax_136 = 0x00;
			}
			else
			{
				if (silent <= 0x09)
					error_printf("ERROR: input sound data is not mono or stereo\n");
				eax_136 = 0x01;
			}
		}
		else
		{
			if (silent <= 0x09)
				error_printf("ERROR: input sound data is not 8, 16, 24 or 32 bits\n");
			eax_136 = 0x01;
		}
	}
	return eax_136;
}

// 0804DEB2: Register (ptr32 Eq_2112) make_even_number_of_bytes_in_length(Stack (ptr32 Eq_2112) dwArg04)
// Called from:
//      parse_aiff_header
FILE * make_even_number_of_bytes_in_length(FILE * dwArg04)
{
	FILE * eax_15;
	if (((byte) dwArg04 & 0x01) != 0x00)
		eax_15 = (FILE *) ((char *) dwArg04 + 1);
	else
		eax_15 = dwArg04;
	return eax_15;
}

// 0804DECC: Register word32 parse_aiff_header(Register word32 edx, Register (ptr32 Eq_159) gs, Stack (ptr32 Eq_67) dwArg04, Stack (ptr32 Eq_2112) dwArg08, Register out Eq_3331 TopOut)
// Called from:
//      parse_file_header
word32 parse_aiff_header(word32 edx, struct Eq_159 * gs, FILE * dwArg04, FILE * dwArg08, union Eq_3331 & TopOut)
{
	Eq_3332 tLoc50;
	Eq_3331 Top_264 = 0;
	word32 eax_104;
	FILE * dwLoc1C_485 = IFF_ID_NONE;
	memset(&tLoc50, 0x00, 0x20);
	Read32BitsHighLow(dwArg08);
	Read32BitsHighLow(dwArg08);
	int32 dwLoc20_486 = 0x00;
	int32 dwLoc24_487 = 0x00;
	int32 dwLoc28_488 = ~0x00;
	FILE * dwLoc10_494 = dwArg08;
	word32 edx_171 = edx;
	if (dwArg08 != IFF_ID_AIFF)
	{
		edx_171 = edx;
		if (dwArg08 != IFF_ID_AIFC)
		{
			eax_104 = ~0x00;
			goto l0804E2E2;
		}
	}
	do
	{
		word24 edx_24_8_263 = SLICE(edx_171, word24, 8);
		if (dwLoc10_494 <= null)
		{
l0804E172:
			if (dwLoc1C_485 == IFF_ID_2CLE)
				g_dw805B3D4 = swapbytes;
			else if (dwLoc1C_485 == IFF_ID_2CBE)
				g_dw805B3D4 = (word32) (swapbytes == 0x00);
			else
			{
				if (dwLoc1C_485 != IFF_ID_NONE)
				{
					eax_104 = ~0x00;
					goto l0804E2E2;
				}
				g_dw805B3D4 = (word32) (swapbytes == 0x00);
			}
			if (dwLoc20_486 != 0x00 && (dwLoc24_487 > 0x00 || tLoc50.dw0004 == 0x00))
			{
				if (aiff_check2(&tLoc50) != 0x00)
					eax_104 = 0x00;
				else if (lame_set_num_channels(dwArg04, (int32) tLoc50.w0000) == ~0x00)
				{
					if (silent <= 0x09)
						error_printf("Unsupported number of channels: %u\n");
					eax_104 = 0x00;
				}
				else
				{
					Eq_3543 Top_387 = Top_264 - 1;
					Top_387.u2->qw0000 = tLoc50.r000C;
					Eq_559 wLoc5E_587 = __fstcw();
					__fldcw(SEQ(0x0C, (byte) wLoc5E_587));
					int32 dwLoc64_589 = (int32) Top_387.u2->qw0000;
					__fldcw(wLoc5E_587);
					lame_set_in_samplerate(dwArg04, dwLoc64_589);
					lame_set_num_samples(dwArg04, tLoc50.dw0004);
					g_dw805B3D0 = (int32) tLoc50.w0008;
					g_dw805B3D8 = 0x00;
					&Top_264.u2->qw0000 = (word32) Top_387 + 1;
					if (dwLoc28_488 >= 0x00 && fseek(dwArg08, dwLoc28_488, 0x00) != 0x00)
					{
						if (silent <= 0x09)
							error_printf("Can't rewind stream to audio data position\n");
						eax_104 = 0x00;
					}
					else
						eax_104 = 0x01;
				}
			}
			else
				eax_104 = ~0x00;
			goto l0804E2E2;
		}
		Read32BitsHighLow(dwArg08);
		int32 v9_58 = dwLoc10_494 - 0x04;
		if (dwArg08 == IFF_ID_COMM)
		{
			Read32BitsHighLow(dwArg08);
			FILE * eax_213 = make_even_number_of_bytes_in_length(dwArg08);
			tLoc50.w0000 = Read16BitsHighLow(dwArg08);
			Read32BitsHighLow(dwArg08);
			tLoc50.ptr0004 = dwArg08;
			tLoc50.w0008 = Read16BitsHighLow(dwArg08);
			real64 * Top_268 = ReadIeeeExtendedHighLow(edx_24_8_263, gs, dwArg08, Top_264.u2->qw0000, Top_264.u2[1]);
			tLoc50.r000C = *Top_268;
			dwLoc20_486 = dwLoc24_487 + 0x01;
			dwLoc10_494 = v9_58 - eax_213;
			&Top_264.u2->qw0000 = (char *) Top_268 + 1;
			FILE * dwLoc2C_546 = eax_213 - 0x12;
			if (dwArg08 == IFF_ID_AIFC)
			{
				Read32BitsHighLow(dwArg08);
				dwLoc1C_485 = dwArg08;
				dwLoc2C_546 = eax_213 - 22;
			}
			if (fskip(gs, dwArg08, dwLoc2C_546, 0x01, out edx_171) == 0x00)
				continue;
			eax_104 = ~0x00;
			goto l0804E2E2;
		}
		if (dwArg08 == IFF_ID_SSND)
		{
			Read32BitsHighLow(dwArg08);
			FILE * eax_116 = make_even_number_of_bytes_in_length(dwArg08);
			Read32BitsHighLow(dwArg08);
			tLoc50.ptr0018 = dwArg08;
			Read32BitsHighLow(dwArg08);
			tLoc50.ptr001C = dwArg08;
			tLoc50.ptr0014 = IFF_ID_SSND;
			dwLoc24_487 = 0x01;
			dwLoc10_494 = v9_58 - eax_116;
			if (dwLoc20_486 <= 0x00)
			{
				int32 eax_154 = ftell(dwArg08);
				dwLoc28_488 = eax_154;
				if (eax_154 >= 0x00)
					dwLoc28_488 = tLoc50.dw0018 + eax_154;
				if (fskip(gs, dwArg08, eax_116 - 0x08, 0x01, out edx_171) == 0x00)
					continue;
				eax_104 = ~0x00;
				goto l0804E2E2;
			}
			word32 edx_734;
			if (fskip(gs, dwArg08, tLoc50.ptr0018, 0x01, out edx_734) != 0x00)
			{
				eax_104 = ~0x00;
				goto l0804E2E2;
			}
			goto l0804E172;
		}
		Read32BitsHighLow(dwArg08);
		FILE * eax_76 = make_even_number_of_bytes_in_length(dwArg08);
		dwLoc10_494 = v9_58 - eax_76;
	} while (fskip(gs, dwArg08, eax_76, 0x01, out edx_171) == 0x00);
	eax_104 = ~0x00;
l0804E2E2:
	TopOut = Top_264;
	return eax_104;
}

// 0804E2E4: Register word32 parse_file_header(Register word32 edx, Register (ptr32 Eq_159) gs, Stack (ptr32 Eq_67) dwArg04, Stack (ptr32 Eq_2112) dwArg08, Register out Eq_3648 TopOut)
// Called from:
//      OpenSndFile
word32 parse_file_header(word32 edx, struct Eq_159 * gs, FILE * dwArg04, FILE * dwArg08, union Eq_3648 & TopOut)
{
	Eq_3648 Top_155 = 0;
	word32 eax_131;
	Read32BitsHighLow(dwArg08);
	g_dw805B3CC = 0x00;
	g_dw805B3D8 = (word32) (in_signed != 0x01);
	if (dwArg08 == WAV_ID_RIFF)
	{
		int32 eax_75 = parse_wave_header(gs, dwArg04, dwArg08);
		if (eax_75 > 0x00)
		{
			g_dw805B3CC = 0x01;
			eax_131 = 0x02;
			goto l0804E3DF;
		}
		if (eax_75 < 0x00 && silent <= 0x09)
			error_printf("Warning: corrupt or unsupported WAVE format\n");
	}
	else if (dwArg08 == IFF_ID_FORM)
	{
		int32 eax_46 = parse_aiff_header(edx, gs, dwArg04, dwArg08, out Top_155);
		if (eax_46 > 0x00)
		{
			g_dw805B3CC = 0x01;
			eax_131 = 0x03;
			goto l0804E3DF;
		}
		if (eax_46 < 0x00 && silent <= 0x09)
			error_printf("Warning: corrupt or unsupported AIFF format\n");
	}
	else if (silent <= 0x09)
		error_printf("Warning: unsupported audio format\n");
	eax_131 = 0x00;
l0804E3DF:
	TopOut = Top_155;
	return eax_131;
}

// 0804E3E1: void CloseSndFile(Stack (ptr32 Eq_67) dwArg08)
// Called from:
//      close_infile
void CloseSndFile(FILE * dwArg08)
{
	if (fclose(dwArg08) == 0x00)
		return;
	if (silent <= 0x09)
		error_printf("Could not close audio input file\n");
	exit(0x02);
}

// 0804E41A: void OpenSndFile(Register (ptr32 Eq_159) gs, Stack (ptr32 Eq_67) dwArg04, Stack (ptr32 Eq_161) dwArg08, Stack (ptr32 Eq_163) dwArg0C, Stack (ptr32 Eq_164) dwArg10)
// Called from:
//      init_infile
void OpenSndFile(struct Eq_159 * gs, FILE * dwArg04, union Eq_161 * dwArg08, struct Eq_163 * dwArg0C, struct Eq_164 * dwArg10)
{
	int8 Top_185 = 0;
	FILE * dwLoc10_369;
	word32 edx_14;
	lame_set_num_samples(dwArg04, ~0x00);
	if (strcmp(dwArg08, "-") == 0x00)
	{
		dwLoc10_369 = stdin;
		lame_set_stream_binary_mode();
	}
	else
	{
		FILE * eax_28 = fopen64(dwArg08, "rb");
		edx_14 = 0x08055332;
		dwLoc10_369 = eax_28;
		if (eax_28 == null)
		{
			if (silent <= 0x09)
				error_printf("Could not find \"%s\".\n");
			exit(0x01);
		}
	}
	if (is_mpeg_file_format(input_format.u0) != 0x00)
	{
		if (lame_decode_initfile(gs, dwLoc10_369, &g_t805C560, dwArg0C, dwArg10) == ~0x00)
		{
			if (silent <= 0x09)
				error_printf("Error reading headers in mp3 input file %s.\n");
			exit(0x01);
		}
		if (lame_set_num_channels(dwArg04, g_dw805C564) == ~0x00)
		{
			if (silent <= 0x09)
				error_printf("Unsupported number of channels: %ud\n");
			exit(0x01);
		}
		lame_set_in_samplerate(dwArg04, g_dw805C568);
		lame_set_num_samples(dwArg04, g_dw805C57C);
	}
	else
	{
		if (input_format.u0 == 0x08)
		{
			if (silent <= 0x09)
				error_printf("sorry, vorbis support in LAME is deprecated.\n");
			exit(0x01);
		}
		if (input_format.u0 == 0x01)
		{
			if (silent <= 0x09)
			{
				console_printf("Assuming raw pcm input file");
				if (swapbytes != 0x00)
					console_printf(" : Forcing byte-swapping\n");
				else
					console_printf("\n");
			}
			g_dw805B3D4 = swapbytes;
		}
		else
			input_format.u0 = (int32) parse_file_header(edx_14, gs, dwArg04, dwLoc10_369, out Top_185);
	}
	if (input_format.u0 != 0x00)
	{
		if (lame_get_num_samples(dwArg04) == ~0x00 && dwLoc10_369 != stdin)
		{
			struct Eq_3870 * Top_207 = Top_185 - 1;
			Top_207->t0000.u0 = (real64) lame_get_file_size(dwArg08);
			Eq_3877 rLoc1C_415 = Top_207->t0000.u0;
			Top_207->t0000.u0 = (real64) rLoc1C_415;
			Top_207->tFFFFFFFF.u0 = 0.0;
			Eq_3877 v14_215 = Top_207->tFFFFFFFF.u0;
			Top_207->tFFFFFFFF.u0 = Top_207->t0000.u0;
			Top_207->t0000.u0 = (real64) v14_215;
			Top_207->t0000.u0 = Top_207->t0000.u0;
			if ((int8) (Top_207->tFFFFFFFF.u0 >= (Top_207->t0000).u0) != 0x00)
			{
				if (is_mpeg_file_format(input_format.u0) != 0x00)
				{
					if (g_dw805C56C > 0x00)
					{
						Top_207->t0000.u0 = (real64) rLoc1C_415;
						Top_207->tFFFFFFFF.u0 = g_t80554C0.u0;
						Top_207->t0000.u0 = (real64) (Top_207->t0000.u0 * (Top_207->tFFFFFFFF).u0);
						int32 eax_283 = g_dw805C56C;
						Top_207->tFFFFFFFF.u0 = (real64) eax_283;
						Top_207->rFFFFFFFE = 1000.0;
						Top_207->tFFFFFFFF.u0 = (real64) (Top_207->tFFFFFFFF.u0 * Top_207->rFFFFFFFE);
						Top_207->t0000.u0 = (real64) (Top_207->t0000.u0 / (Top_207->tFFFFFFFF).u0);
						Eq_3877 rLoc24_427 = Top_207->t0000.u0;
						Top_207->t0000.u0 = (real64) lame_get_in_samplerate(dwArg04, eax_283);
						Top_207->t0000.u0 = (real64) (Top_207->t0000.u0 * rLoc24_427);
						Eq_559 wLoc32_430 = __fstcw();
						__fldcw(SEQ(0x0C, (byte) wLoc32_430));
						word32 dwLoc3C_433 = (word32) Top_207->t0000.u0;
						__fldcw(wLoc32_430);
						lame_set_num_samples(dwArg04, dwLoc3C_433, dwLoc3C_433);
						g_dw805C57C = dwLoc3C_433;
					}
				}
				else
				{
					Top_207->t0000.u0 = (real64) (lame_get_num_channels(dwArg04) * 0x02);
					Top_207->tFFFFFFFF.u0 = (real64) rLoc1C_415;
					Top_207->t0000.u0 = (real64) (Top_207->tFFFFFFFF.u0 / (Top_207->t0000).u0);
					Eq_559 wLoc32_419 = __fstcw();
					__fldcw(SEQ(0x0C, (byte) wLoc32_419));
					word32 dwLoc3C_422 = (word32) Top_207->t0000.u0;
					__fldcw(wLoc32_419);
					lame_set_num_samples(dwArg04, dwLoc3C_422);
				}
			}
		}
	}
	else
		exit(0x01);
}

// 0804E748: Register word32 check_aid(Stack (ptr32 word32) dwArg04)
// Called from:
//      lame_decode_initfile
word32 check_aid(word32 * dwArg04)
{
	return (word32) (memcmp(dwArg04, &g_v805540A, 0x04) == 0x00);
}

// 0804E773: Register word32 is_syncword_mp123(Stack (ptr32 Eq_4075) dwArg04)
// Called from:
//      lame_decode_initfile
word32 is_syncword_mp123(struct Eq_4075 * dwArg04)
{
	word32 eax_153;
	if (dwArg04->dw0000 == ~0x00)
	{
		if (((word32) dwArg04->b0001 & 0xE0) == 0xE0)
		{
			if (((word32) dwArg04->b0001 & 0x18) != 0x08)
			{
				ui32 eax_39 = (word32) dwArg04->b0001;
				if ((eax_39 & 0x06) != 0x04)
				{
					if ((eax_39 & 0x06) != 0x06)
					{
						if ((eax_39 & 0x06) != 0x02)
						{
							eax_153 = 0x00;
							return eax_153;
						}
						if (input_format.u0 != 0x06 && input_format.u0 != 0x07)
						{
							eax_153 = 0x00;
							return eax_153;
						}
						input_format.u0 = 0x06;
					}
					else
					{
						if (input_format.u0 != 0x04 && input_format.u0 != 0x07)
						{
							eax_153 = 0x00;
							return eax_153;
						}
						input_format.u0 = 0x04;
					}
				}
				else
				{
					if (input_format.u0 != 0x05 && input_format.u0 != 0x07)
					{
						eax_153 = 0x00;
						return eax_153;
					}
					input_format.u0 = 0x05;
				}
				if (((word32) dwArg04->b0001 & 0x06) == 0x00)
					eax_153 = 0x00;
				else if (((word32) dwArg04->b0002 & 0xF0) == 0xF0)
					eax_153 = 0x00;
				else if (((word32) dwArg04->b0002 & 0x0C) == 0x0C)
					eax_153 = 0x00;
				else if (((word32) dwArg04->b0001 & 0x18) == 0x18 && (((word32) dwArg04->b0001 & 0x06) == 0x04 && ((byte) ((int32) g_a80554A5[(word32) (dwArg04->b0002 >> 0x04)] >> (dwArg04->b0003 >> 0x06)) & 0x01) != 0x00))
					eax_153 = 0x00;
				else if (((word32) dwArg04->b0003 & 0x03) == 0x02)
					eax_153 = 0x00;
				else
					eax_153 = 0x01;
				return eax_153;
			}
			else
			{
				eax_153 = 0x00;
				return eax_153;
			}
		}
		else
		{
			eax_153 = 0x00;
			return eax_153;
		}
	}
	else
	{
		eax_153 = 0x00;
		return eax_153;
	}
}

// 0804E961: Register word32 lame_decode_initfile(Register (ptr32 Eq_159) gs, Stack (ptr32 Eq_2112) dwArg04, Stack (ptr32 Eq_3779) dwArg08, Stack (ptr32 Eq_163) dwArg0C, Stack (ptr32 Eq_164) dwArg10)
// Called from:
//      OpenSndFile
//      lame_decode_initfile
word32 lame_decode_initfile(struct Eq_159 * gs, FILE * dwArg04, struct Eq_3779 * dwArg08, struct Eq_163 * dwArg0C, struct Eq_164 * dwArg10)
{
	ptr32 fp;
	word32 dwLoc74;
	byte bLoc70;
	byte bLoc6F;
	word32 eax_18 = gs->dw0014;
	memset(dwArg08, 0x00, 0x28);
	word32 dwLoc84_457 = 0x00;
	if (g_dw805B3E4 != 0x00)
		hip_decode_exit(g_dw805B3E4);
	word32 eax_271;
	g_dw805B3E4 = hip_decode_init();
	if (fread(&dwLoc74, 0x01, 0x04, dwArg04) != 0x04)
	{
		eax_271 = ~0x00;
		goto l0804EE55;
	}
	if (dwLoc74 == 0x49 && (dwLoc74.b0001 == 0x44 && dwLoc74.b0002 == 0x33))
	{
		if (silent <= 0x09)
			console_printf("ID3v2 found. Be aware that the ID3 tag is currently lost when transcoding.\n");
		if (fread(&dwLoc74, 0x01, 0x06, dwArg04) != 0x06)
		{
			eax_271 = ~0x00;
			goto l0804EE55;
		}
		dwLoc74.b0002 = dwLoc74.b0002 & 0x7F;
		dwLoc74.b0003 = dwLoc74.b0003 & 0x7F;
		word32 edx_733;
		fskip(gs, dwArg04, ((((word32) dwLoc74.b0002 << 0x07) + (word32) dwLoc74.b0003 << 0x07) + (word32) (bLoc70 & 0x7F) << 0x07) + (word32) (bLoc6F & 0x7F), 0x01, out edx_733);
		if (fread(&dwLoc74, 0x01, 0x04, dwArg04) != 0x04)
		{
			eax_271 = ~0x00;
			goto l0804EE55;
		}
	}
	if (check_aid(&dwLoc74) != 0x00)
	{
		if (fread(&dwLoc74, 0x01, 0x02, dwArg04) != 0x02)
		{
			eax_271 = ~0x00;
			goto l0804EE55;
		}
		word32 eax_182 = (word32) dwLoc74 + ((word32) dwLoc74.b0001 << 0x08);
		if (silent <= 0x09)
			console_printf("Album ID found.  length=%i \n");
		word32 edx_734;
		fskip(gs, dwArg04, eax_182 - 0x06, 0x01, out edx_734);
		if (fread(&dwLoc74, 0x01, 0x04, dwArg04) != 0x04)
		{
			eax_271 = ~0x00;
			goto l0804EE55;
		}
	}
	do
	{
		if (is_syncword_mp123(&dwLoc74) != 0x00)
		{
			if (((word32) dwLoc74.b0002 & 0xF0) == 0x00)
			{
				if (silent <= 0x09)
					console_printf("Input file is freeformat.\n");
				dwLoc84_457 = 0x01;
			}
			if (hip_decode1_headersB(g_dw805B3E4, &dwLoc74, 0x04, fp + ~0x0987, fp + 4294962552, dwArg08, dwArg0C, dwArg10) == ~0x00)
				eax_271 = ~0x00;
			else
			{
				do
				{
					if (dwArg08->dw0000 != 0x00)
					{
						if (dwArg08->dw000C == 0x00 && dwLoc84_457 == 0x00)
						{
							if (silent <= 0x09)
								error_printf("fail to sync...\n");
							eax_271 = lame_decode_initfile(gs, dwArg04, dwArg08, dwArg0C, dwArg10);
						}
						else
						{
							if (dwArg08->dw0020 <= 0x00)
								dwArg08->dw001C = ~0x00;
							eax_271 = 0x00;
						}
						goto l0804EE55;
					}
					Eq_82 eax_346 = fread(&dwLoc74, 0x01, 100, dwArg04);
					if (eax_346 != 100)
					{
						eax_271 = ~0x00;
						goto l0804EE55;
					}
				} while (hip_decode1_headersB(g_dw805B3E4, &dwLoc74, eax_346, fp + ~0x0987, fp + 4294962552, dwArg08, dwArg0C, dwArg10) != ~0x00);
				eax_271 = ~0x00;
			}
			goto l0804EE55;
		}
		Eq_4437 dwLoc88_522 = 0x00;
		while (dwLoc88_522 < 0x03)
		{
			Mem254[&dwLoc74 + dwLoc88_522:byte] = Mem244[&dwLoc74 + (dwLoc88_522 + 0x01):byte];
			dwLoc88_522 = (word32) dwLoc88_522 + 1;
		}
	} while (fread((char *) &dwLoc74 + 3, 0x01, 0x01, dwArg04) == 0x01);
	eax_271 = ~0x00;
l0804EE55:
	if ((eax_18 ^ gs->dw0014) == 0x00)
		return eax_271;
	__stack_chk_fail();
}

// 0804EE68: Register int32 lame_decode_fromfile(Register (ptr32 Eq_159) gs, Stack (ptr32 Eq_67) dwArg04, Stack (ptr32 Eq_462) dwArg08, Stack word32 dwArg0C, Stack word32 dwArg10)
// Called from:
//      read_samples_mp3
int32 lame_decode_fromfile(struct Eq_159 * gs, FILE * dwArg04, struct Eq_462 * dwArg08, word32 dwArg0C, word32 dwArg10)
{
	word32 dwLoc0410;
	int32 eax_106;
	word32 eax_18 = gs->dw0014;
	int32 eax_38 = hip_decode1_headers(g_dw805B3E4, &dwLoc0410, 0x00, dwArg08, dwArg0C, dwArg10, dwArg10, dwArg0C, dwArg08, dwArg04, 0x00, 0x00, eax_18);
	if (eax_38 != 0x00)
		eax_106 = eax_38;
	else
	{
		do
		{
			int32 dwLoc0414_168;
			Eq_82 eax_53 = fread(&dwLoc0410, 0x01, 0x0400, dwArg04);
			if (eax_53 == 0x00)
			{
				int32 eax_98 = hip_decode1_headers(g_dw805B3E4, &dwLoc0410, eax_53, dwArg08, dwArg0C, dwArg10);
				dwLoc0414_168 = eax_98;
				if (eax_98 > 0x00)
					break;
				hip_decode_exit(g_dw805B3E4);
				g_dw805B3E4 = 0x00;
				eax_106 = ~0x00;
				goto l0804F03A;
			}
			int32 eax_71 = hip_decode1_headers(g_dw805B3E4, &dwLoc0410, eax_53, dwArg08, dwArg0C, dwArg10);
			dwLoc0414_168 = eax_71;
			if (eax_71 == ~0x00)
			{
				hip_decode_exit(g_dw805B3E4);
				g_dw805B3E4 = 0x00;
				eax_106 = ~0x00;
				goto l0804F03A;
			}
		} while (eax_71 <= 0x00);
		eax_106 = dwLoc0414_168;
	}
l0804F03A:
	if ((eax_18 ^ gs->dw0014) == 0x00)
		return eax_106;
	__stack_chk_fail();
}

// 0804F04D: Register word32 is_mpeg_file_format(Stack Eq_228 dwArg04)
// Called from:
//      get_audio_common
//      OpenSndFile
word32 is_mpeg_file_format(Eq_228 dwArg04)
{
	word32 eax_11;
	if (dwArg04 == 0x05)
	{
		eax_11 = 0x02;
		return eax_11;
	}
	else
	{
		if (dwArg04 <= 0x05)
		{
			if (dwArg04 == 0x04)
			{
				eax_11 = 0x01;
				return eax_11;
			}
		}
		else
		{
			if (dwArg04 == 0x06)
			{
				eax_11 = 0x03;
				return eax_11;
			}
			if (dwArg04 == 0x07)
			{
				eax_11 = ~0x00;
				return eax_11;
			}
		}
		eax_11 = 0x00;
		return eax_11;
	}
}

// 0804F094: FpuStack real64 GetCPUTime()
// Called from:
//      timestatus
real64 GetCPUTime()
{
	return (real64) clock() / 1000000.0;
}

// 0804F0AF: FpuStack real64 GetRealTime()
// Called from:
//      timestatus
//      encoder_progress
real64 GetRealTime()
{
	word32 dwLoc14;
	word32 dwLoc10;
	gettimeofday(&dwLoc14, null);
	return (real64) dwLoc14 + (real64) dwLoc10 * 1e-06;
}

// 0804F0E6: void lame_set_stream_binary_mode()
// Called from:
//      init_outfile
//      OpenSndFile
void lame_set_stream_binary_mode()
{
}

// 0804F0F0: Sequence word64 lame_get_file_size(Stack (ptr32 Eq_161) dwArg04)
// Called from:
//      OpenSndFile
word64 lame_get_file_size(union Eq_161 * dwArg04)
{
	ptr32 fp;
	word32 dwLoc40;
	word32 dwLoc3C;
	word32 edx_24;
	word32 eax_23;
	if (stat64(dwArg04, fp - 0x006C) == 0x00)
	{
		eax_23 = dwLoc40;
		edx_24 = dwLoc3C;
	}
	else
	{
		eax_23 = ~0x00;
		edx_24 = ~0x00;
	}
	return SEQ(edx_24, eax_23);
}

// 0804F120: void set_id3tag(Stack (ptr32 Eq_67) dwArg04, Stack up32 dwArg08, Stack (ptr32 char) dwArg0C)
// Called from:
//      id3_tag
void set_id3tag(FILE * dwArg04, up32 dwArg08, char * dwArg0C)
{
	if (dwArg08 <= 121 && dwArg08 >= 0x61)
	{
		switch (dwArg08)
		{
		case 0x61:
			id3tag_set_artist(dwArg04, dwArg0C);
			break;
		case 0x62:
		case 100:
		case 101:
		case 0x66:
		case 0x68:
		case 0x69:
		case 0x6A:
		case 0x6B:
		case 0x6D:
		case 111:
		case 0x70:
		case 113:
		case 114:
		case 115:
		case 117:
		case 0x77:
		case 0x78:
			goto l0804F1FD;
		case 99:
			id3tag_set_comment(dwArg04, dwArg0C);
			break;
		case 0x67:
			id3tag_set_genre(dwArg04, dwArg0C);
			break;
		case 0x6C:
			id3tag_set_album(dwArg04, dwArg0C);
			break;
		case 110:
			id3tag_set_track(dwArg04, dwArg0C);
			break;
		case 116:
			id3tag_set_title(dwArg04, dwArg0C);
			break;
		case 118:
			id3tag_set_fieldvalue(dwArg04, dwArg0C);
			break;
		case 121:
			id3tag_set_year(dwArg04, dwArg0C);
			break;
		}
	}
	else
	{
l0804F1FD:
	}
}

// 0804F204: void id3_tag(Stack (ptr32 Eq_67) dwArg04, Stack up32 dwArg08, Stack (ptr32 char) dwArg10)
// Called from:
//      parse_args
void id3_tag(FILE * dwArg04, up32 dwArg08, char * dwArg10)
{
	char * eax_13 = strdup(dwArg10);
	set_id3tag(dwArg04, dwArg08, eax_13);
	free(eax_13);
}

// 0804F24B: void lame_version_print(Stack (ptr32 Eq_1488) dwArg04)
// Called from:
//      print_license
//      usage
//      short_help
//      long_help
//      presets_set
void lame_version_print(FILE * dwArg04)
{
	Eq_4737 tLoc40;
	Eq_4738 tLoc3C;
	char * eax_10 = get_lame_os_bitness();
	char * eax_15 = get_lame_version(eax_10);
	char * eax_20 = get_lame_url(eax_15);
	Eq_82 eax_27 = strlen(eax_10);
	Eq_82 eax_31 = strlen(eax_15);
	Eq_82 eax_35 = strlen(eax_20);
	if (eax_27 + eax_31 + eax_35 >u 0x40 && eax_35 <= 0x4E)
	{
		if (eax_27 != 0x00)
			fprintf(dwArg04, "LAME %s version %s\n%*s(%s)\n\n", eax_10, eax_15, tLoc3C, 0x50 - eax_35 - 2);
		else
			fprintf(dwArg04, "LAME version %s\n%*s(%s)\n\n", eax_15, tLoc40, 0x50 - eax_35 - 2);
	}
	else if (eax_27 != 0x00)
		fprintf(dwArg04, "LAME %s version %s (%s)\n\n", eax_10, eax_15, eax_20);
	else
		fprintf(dwArg04, "LAME version %s (%s)\n\n", eax_15, eax_20);
}

// 0804F3AB: void print_license(Stack (ptr32 Eq_1488) dwArg04)
// Called from:
//      parse_args
void print_license(FILE * dwArg04)
{
	lame_version_print(dwArg04);
	fwrite(&g_v80555B0, 0x01, 0xFF, dwArg04);
	fwrite(&g_v80556B0, 0x01, 0xAF, dwArg04);
	fwrite(&g_v8055760, 0x01, 0x9D, dwArg04);
	fwrite(&g_v8055800, 0x01, 0x01E7, dwArg04);
	fwrite(&g_v80559E8, 0x01, 0x6C, dwArg04);
	fwrite(&g_v8055A58, 0x01, 0x0103, dwArg04);
}

// 0804F49B: void usage(Stack (ptr32 Eq_1488) dwArg04, Stack (ptr32 char) dwArg08)
// Called from:
//      main
//      parse_args
void usage(FILE * dwArg04, char * dwArg08)
{
	lame_version_print(dwArg04);
	fprintf(dwArg04, "usage: %s [options] <infile> [outfile]\n\n    <infile> and/or <outfile> can be \"-\", which means stdin/stdout.\n\nTry:\n     \"%s --help\"           for general usage information\n or:\n     \"%s --preset help\"    for information on suggested predefined settings\n or:\n     \"%s --longhelp\"\n  or \"%s -?\"              for a complete options list\n\n", dwArg08, dwArg08, dwArg08, dwArg08, dwArg08);
}

// 0804F4EA: void short_help(Stack (ptr32 Eq_67) dwArg04, Stack (ptr32 Eq_1488) dwArg08, Stack (ptr32 char) dwArg0C)
// Called from:
//      parse_args
void short_help(FILE * dwArg04, FILE * dwArg08, char * dwArg0C)
{
	lame_version_print(dwArg08);
	fprintf(dwArg08, "usage: %s [options] <infile> [outfile]\n\n    <infile> and/or <outfile> can be \"-\", which means stdin/stdout.\n\nRECOMMENDED:\n    lame -V2 input.wav output.mp3\n\n", dwArg0C);
	fprintf(dwArg08, "OPTIONS:\n    -b bitrate      set the bitrate, default 128 kbps\n    -h              higher quality, but a little slower.  Recommended.\n    -f              fast mode (lower quality)\n    -V n            quality setting for VBR.  default n=%i\n                    0=high quality,bigger files. 9=smaller files\n", lame_get_VBR_q(dwArg04, dwArg08, 0x08055CAC, dwArg0C));
	fwrite(&g_v8055E80, 0x01, 0x0141, dwArg08);
	fwrite(&g_v8055FC4, 0x01, 0x59, dwArg08);
}

// 0804F588: void wait_for(Stack (ptr32 Eq_1488) dwArg04, Stack word32 dwArg08)
// Called from:
//      long_help
void wait_for(FILE * dwArg04, word32 dwArg08)
{
	if (dwArg08 != 0x00)
	{
		fflush(dwArg04);
		getchar(dwArg04);
	}
	else
		fputc(0x0A, dwArg04);
	fputc(0x0A, dwArg04);
}

// 0804F5CE: void long_help(Stack (ptr32 Eq_67) dwArg04, Stack (ptr32 Eq_1488) dwArg08, Stack (ptr32 char) dwArg0C, Stack word32 dwArg10)
// Called from:
//      parse_args
void long_help(FILE * dwArg04, FILE * dwArg08, char * dwArg0C, word32 dwArg10)
{
	lame_version_print(dwArg08);
	fprintf(dwArg08, "usage: %s [options] <infile> [outfile]\n\n    <infile> and/or <outfile> can be \"-\", which means stdin/stdout.\n\nRECOMMENDED:\n    lame -V2 input.wav output.mp3\n\n", dwArg0C);
	fwrite(&g_v8056020, 0x01, 0x02A3, dwArg08);
	fwrite(&g_v80562C4, 0x01, 0x01A9, dwArg08);
	wait_for(dwArg08, dwArg10);
	fwrite(&g_v8056470, 0x01, 0x032C, dwArg08);
	fwrite(&g_v80567A0, 0x01, 0x0169, dwArg08);
	fwrite(&g_v805690C, 0x01, 226, dwArg08);
	wait_for(dwArg08, dwArg10);
	fwrite(&g_v80569F0, 0x01, 0x018A, dwArg08);
	fwrite(&g_v8056B7C, 0x01, 0x0131, dwArg08);
	wait_for(dwArg08, dwArg10);
	fwrite(&g_v8056CB0, 0x01, 0xFB, dwArg08);
	fprintf(dwArg08, "  VBR options:\n    -V n            quality setting for VBR.  default n=%i\n                    0=high quality,bigger files. 9=smaller files\n    -v              the same as -V 4\n    --vbr-old       use old variable bitrate (VBR) routine\n    --vbr-new       use new variable bitrate (VBR) routine (default)\n", lame_get_VBR_q(dwArg04, 0x08056CB0, 0x01, 0xFB, dwArg08));
	fwrite(&g_v8056EE0, 0x01, 0x0170, dwArg08);
	wait_for(dwArg08, dwArg10);
	fwrite(&g_v8057051, 0x01, 0x0F, dwArg08);
	fwrite(&g_v8057064, 0x01, 0x01CC, dwArg08);
	fwrite(&g_v8057234, 0x01, 55, dwArg08);
	wait_for(dwArg08, dwArg10);
	fwrite(&g_v805726C, 0x01, 0x5A, dwArg08);
	wait_for(dwArg08, dwArg10);
	fwrite(&g_v80572C8, 0x01, 0x019A, dwArg08);
	fprintf(dwArg08, "  Filter options:\n  --lowpass <freq>        frequency(kHz), lowpass filter cutoff above freq\n  --lowpass-width <freq>  frequency(kHz) - default 15%% of lowpass freq\n  --highpass <freq>       frequency(kHz), highpass filter cutoff below freq\n  --highpass-width <freq> frequency(kHz) - default 15%% of highpass freq\n");
	fwrite(&g_v80575A0, 0x01, 0x50, dwArg08);
	wait_for(dwArg08, dwArg10);
	fwrite(&g_v80575F4, 0x01, 886, dwArg08);
	fwrite(&g_v805796C, 0x01, 0x01DC, dwArg08);
	fwrite(&g_v8057B4C, 0x01, 0x013C, dwArg08);
	wait_for(dwArg08, dwArg10);
	fwrite(&g_v8057C8C, 0x01, 0x61, dwArg08);
	wait_for(dwArg08, dwArg10);
	display_bitrates(dwArg08);
}

// 0804F991: void display_bitrate(Stack (ptr32 Eq_1488) dwArg04, Stack (ptr32 char) dwArg08, Stack int32 dwArg0C, Stack ui32 dwArg10)
// Called from:
//      display_bitrates
void display_bitrate(FILE * dwArg04, char * dwArg08, int32 dwArg0C, ui32 dwArg10)
{
	int32 dwLoc14_111 = 0x0E;
	if (dwArg0C == 0x04)
		dwLoc14_111 = 0x08;
	fprintf(dwArg04, "\nMPEG-%-3s layer III sample frequencies (kHz):  %2d  %2d  %g\nbitrates (kbps):", dwArg08, (int32) (0x20 /32 dwArg0C), (int32) (0x30 /32 dwArg0C), 44.1 / (real64) dwArg0C);
	int32 dwLoc10_105;
	for (dwLoc10_105 = 0x01; dwLoc10_105 <= dwLoc14_111; ++dwLoc10_105)
		fprintf(dwArg04, " %2i", g_a805B2E0[((dwArg10 << 0x04) + dwLoc10_105) * 0x04]);
	fputc(0x0A, dwArg04);
}

// 0804FA50: void display_bitrates(Stack (ptr32 Eq_1488) dwArg04)
// Called from:
//      main
//      long_help
void display_bitrates(FILE * dwArg04)
{
	display_bitrate(dwArg04, "1", 0x01, 0x01);
	display_bitrate(dwArg04, "2", 0x02, 0x00);
	display_bitrate(dwArg04, "2.5", 0x04, 0x00);
	fputc(0x0A, dwArg04);
	fflush(dwArg04);
}

// 0804FAE4: void presets_longinfo_dm(Stack (ptr32 Eq_1488) dwArg04)
// Called from:
//      presets_set
void presets_longinfo_dm(FILE * dwArg04)
{
	fwrite(&g_v8057D4C, 0x01, 0x39, dwArg04);
	fwrite(&g_v8057D88, 0x01, 0x4B, dwArg04);
	fwrite(&g_v8057DD4, 0x01, 323, dwArg04);
	fwrite(&g_v8057F18, 0x01, 0xFF, dwArg04);
	fwrite(&g_v8058018, 0x01, 0x016A, dwArg04);
	fwrite(&g_v8058184, 0x01, 299, dwArg04);
	fwrite(&g_v80582B0, 0x01, 0x0136, dwArg04);
	fwrite(&g_v80583E8, 0x01, 383, dwArg04);
	fwrite(&g_v8058568, 0x01, 0x41, dwArg04);
	fwrite(&g_v80585AC, 0x01, 0x019C, dwArg04);
	fwrite(&g_v805874C, 0x01, 222, dwArg04);
	fwrite(&g_v805882C, 0x01, 0xF7, dwArg04);
}

// 0804FC9C: Register word32 presets_set(Stack (ptr32 Eq_67) dwArg04, Stack int32 dwArg08, Stack int32 dwArg0C, Stack (ptr32 char) dwArg10)
// Called from:
//      parse_args
word32 presets_set(FILE * dwArg04, int32 dwArg08, int32 dwArg0C, char * dwArg10)
{
	word32 eax_244;
	word32 dwLoc10_434 = 0x00;
	if (strcmp(dwArg10, "help") == 0x00 && (dwArg08 <= 0x00 && dwArg0C <= 0x00))
	{
		lame_version_print(stdout);
		presets_longinfo_dm(stdout);
		eax_244 = ~0x00;
	}
	else
	{
		if (strcmp(dwArg10, "phone") == 0x00)
		{
			dwArg10 = (char *) "16";
			dwLoc10_434 = 0x01;
		}
		if (strcmp(dwArg10, "phon+") == 0x00 || (strcmp(dwArg10, "lw") == 0x00 || (strcmp(dwArg10, "mw-eu") == 0x00 || strcmp(dwArg10, "sw") == 0x00)))
		{
			dwArg10 = (char *) "24";
			dwLoc10_434 = 0x01;
		}
		if (strcmp(dwArg10, "mw-us") == 0x00)
		{
			dwArg10 = (char *) "40";
			dwLoc10_434 = 0x01;
		}
		if (strcmp(dwArg10, "voice") == 0x00)
		{
			dwArg10 = (char *) "56";
			dwLoc10_434 = 0x01;
		}
		if (strcmp(dwArg10, "fm") == 0x00)
			dwArg10 = (char *) "112";
		if (strcmp(dwArg10, "radio") == 0x00 || strcmp(dwArg10, "tape") == 0x00)
			dwArg10 = (char *) "112";
		if (strcmp(dwArg10, "hifi") == 0x00)
			dwArg10 = (char *) "160";
		if (strcmp(dwArg10, "cd") == 0x00)
			dwArg10 = (char *) "192";
		if (strcmp(dwArg10, "studio") == 0x00)
			dwArg10 = (char *) "256";
		if (strcmp(dwArg10, "medium") == 0x00)
		{
			lame_set_VBR_q(dwArg04, 0x04);
			if (dwArg08 > 0x00)
				lame_set_VBR(dwArg04, 0x04);
			else
				lame_set_VBR(dwArg04, 0x02);
			eax_244 = 0x00;
		}
		else if (strcmp(dwArg10, "standard") == 0x00)
		{
			lame_set_VBR_q(dwArg04, 0x02);
			if (dwArg08 > 0x00)
				lame_set_VBR(dwArg04, 0x04);
			else
				lame_set_VBR(dwArg04, 0x02);
			eax_244 = 0x00;
		}
		else if (strcmp(dwArg10, "extreme") == 0x00)
		{
			lame_set_VBR_q(dwArg04, 0x00);
			if (dwArg08 > 0x00)
				lame_set_VBR(dwArg04, 0x04);
			else
				lame_set_VBR(dwArg04, 0x02);
			eax_244 = 0x00;
		}
		else if (strcmp(dwArg10, "insane") == 0x00 && dwArg08 <= 0x00)
		{
			lame_set_preset(dwArg04, 1003);
			eax_244 = 0x00;
		}
		else if (atoi(dwArg10) > 0x00 && dwArg08 <= 0x00)
		{
			if (atoi(dwArg10) > 0x07 && atoi(dwArg10) <= 0x0140)
			{
				lame_set_preset(dwArg04, dwArg10, atoi(dwArg10));
				if (dwArg0C == 0x01)
					lame_set_VBR(dwArg04, 0x00);
				if (dwLoc10_434 == 0x01)
					lame_set_mode(dwArg04, 0x03);
				eax_244 = 0x00;
			}
			else
			{
				lame_version_print(g_ptr805BCEC);
				error_printf("Error: The bitrate specified is out of the valid range for this preset\n\nWhen using this mode you must enter a value between \"32\" and \"320\"\n\nFor further information try: \"%s --preset help\"\n");
				eax_244 = ~0x00;
			}
		}
		else
		{
			lame_version_print(g_ptr805BCEC);
			error_printf("Error: You did not enter a valid profile and/or options with --preset\n\nAvailable profiles are:\n\n   <fast>        medium\n   <fast>        standard\n   <fast>        extreme\n                 insane\n          <cbr> (ABR Mode) - The ABR Mode is implied. To use it,\n                             simply specify a bitrate. For example:\n                             \"--preset 185\" activates this\n                             preset and uses 185 as an average kbps.\n\n");
			error_printf("    Some examples:\n\n or \"%s --preset fast standard <input file> <output file>\"\n or \"%s --preset cbr 192 <input file> <output file>\"\n or \"%s --preset 172 <input file> <output file>\"\n or \"%s --preset extreme <input file> <output file>\"\n\nFor further information try: \"%s --preset help\"\n");
			eax_244 = ~0x00;
		}
	}
	return eax_244;
}

// 080500DE: void genre_list_handler()
void genre_list_handler()
{
	console_printf("%3d %s\n");
}

// 08050100: Register Eq_5674 local_strcasecmp(Stack (ptr32 byte) dwArg04, Stack (ptr32 byte) dwArg08)
// Called from:
//      filename_to_type
//      parse_args
Eq_5674 local_strcasecmp(byte * dwArg04, byte * dwArg08)
{
	do
	{
		byte al_23 = (byte) tolower((int32) *dwArg04);
		byte al_34 = (byte) tolower((int32) *dwArg08, al_23);
		if (al_23 == 0x00)
			return al_23 - al_34;
		++dwArg04;
		++dwArg08;
	} while (al_23 == al_34);
	return al_23 - al_34;
}

// 08050158: Register word32 filename_to_type(Stack (ptr32 Eq_69) dwArg04)
// Called from:
//      parse_args
word32 filename_to_type(union Eq_69 * dwArg04)
{
	word32 eax_132;
	Eq_82 eax_11 = strlen(dwArg04);
	if (eax_11 <= 0x03)
		eax_132 = 0x00;
	else
	{
		word32 v8_17 = dwArg04 + (eax_11 - 0x04);
		if (local_strcasecmp(v8_17, &g_b8058D58) == 0x00)
			eax_132 = 0x07;
		else if (local_strcasecmp(v8_17, &g_b8058D5D) == 0x00)
			eax_132 = 0x07;
		else if (local_strcasecmp(v8_17, &g_b8058D62) == 0x00)
			eax_132 = 0x07;
		else if (local_strcasecmp(v8_17, &g_b8058D67) == 0x00)
			eax_132 = 0x07;
		else if (local_strcasecmp(v8_17, &g_b8058D6C) == 0x00)
			eax_132 = 0x02;
		else if (local_strcasecmp(v8_17, &g_b8058D71) == 0x00)
			eax_132 = 0x03;
		else if (local_strcasecmp(v8_17, &g_b8058D76) == 0x00)
			eax_132 = 0x01;
		else if (local_strcasecmp(v8_17, &g_b8058D7B) == 0x00)
			eax_132 = 0x08;
		else
			eax_132 = 0x00;
	}
	return eax_132;
}

// 08050285: Register word32 resample_rate(Stack Eq_5769 qwArg04)
// Called from:
//      parse_args
word32 resample_rate(Eq_5769 qwArg04)
{
	Eq_5769 rLoc14_101 = qwArg04;
	if ((int8) (qwArg04 >= g_t8059828.u0) != 0x00)
		rLoc14_101 = qwArg04 * g_t8059830.u0;
	word32 eax_116;
	Eq_559 wLoc16_104 = __fstcw();
	__fldcw(SEQ(0x0C, (byte) wLoc16_104));
	__fldcw(wLoc16_104);
	Eq_5789 dwLoc1C_106 = (int32) rLoc14_101;
	if (dwLoc1C_106 <= 0x30 && dwLoc1C_106 >= 0x08)
	{
		switch (dwLoc1C_106)
		{
		case 0x08:
			eax_116 = 8000;
			break;
		case 0x09:
		case 0x0A:
		case 0x0D:
		case 0x0E:
		case 0x0F:
		case 0x11:
		case 0x12:
		case 0x13:
		case 0x14:
		case 0x15:
		case 0x17:
		case 0x19:
		case 0x1A:
		case 0x1B:
		case 0x1C:
		case 0x1D:
		case 0x1E:
		case 0x1F:
		case 33:
		case 0x22:
		case 0x23:
		case 0x24:
		case 0x25:
		case 0x26:
		case 0x27:
		case 0x28:
		case 0x29:
		case 0x2A:
		case 0x2B:
		case 0x2D:
		case 0x2E:
		case 0x2F:
			goto l08050327;
		case 11:
			eax_116 = 0x2B11;
			break;
		case 0x0C:
			eax_116 = 12000;
			break;
		case 0x10:
			eax_116 = 16000;
			break;
		case 22:
			eax_116 = 22050;
			break;
		case 0x18:
			eax_116 = 24000;
			break;
		case 0x20:
			eax_116 = 0x7D00;
			break;
		case 44:
			eax_116 = 44100;
			break;
		case 0x30:
			eax_116 = 48000;
			break;
		}
	}
	else
	{
l08050327:
		error_printf("Illegal resample frequency: %.3f kHz\n");
		eax_116 = 0x00;
	}
	return eax_116;
}

// 08050341: Register int32 set_id3_albumart(Stack (ptr32 Eq_67) dwArg04, Stack (ptr32 char) dwArg08)
// Called from:
//      parse_args
int32 set_id3_albumart(FILE * dwArg04, char * dwArg08)
{
	int32 eax_130;
	if (dwArg08 == null)
		eax_130 = 0x00;
	else
	{
		int32 dwLoc10_164;
		FILE * eax_18 = fopen64(dwArg08, "rb");
		if (eax_18 == null)
			dwLoc10_164 = 0x01;
		else
		{
			fseek(eax_18, 0x00, 0x02);
			Eq_82 eax_29 = ftell(eax_18);
			fseek(eax_18, 0x00, 0x00);
			void * eax_38 = malloc(eax_29);
			if (eax_38 == null)
				dwLoc10_164 = 0x02;
			else
			{
				if (fread(eax_38, 0x01, eax_29, eax_18) != eax_29)
					dwLoc10_164 = 0x03;
				else
				{
					int32 eax_64;
					if (id3tag_set_albumart(dwArg04, eax_38, eax_29) != 0x00)
						eax_64 = 0x04;
					else
						eax_64 = 0x00;
					dwLoc10_164 = eax_64;
				}
				free(eax_38);
			}
			fclose(eax_18);
		}
		if (dwLoc10_164 != 0x02)
		{
			if (dwLoc10_164 <= 0x02)
			{
				if (dwLoc10_164 == 0x01)
					error_printf("Could not find: '%s'.\n");
			}
			else if (dwLoc10_164 != 0x03)
			{
				if (dwLoc10_164 == 0x04)
					error_printf("Unsupported image: '%s'.\nSpecify JPEG/PNG/GIF image (128KB maximum)\n");
			}
			else
				error_printf("Read error: '%s'.\n");
		}
		else
			error_printf("Insufficient memory for reading the albumart.\n");
		eax_130 = dwLoc10_164;
	}
	return eax_130;
}

// 080504D7: Register word32 parse_args(Stack (ptr32 Eq_67) dwArg04, Stack int32 dwArg08, Stack (ptr32 Eq_137) dwArg0C, Stack (ptr32 Eq_69) dwArg10, Stack (ptr32 char) dwArg14, Stack (arr (ptr32 char)) dwArg18, Stack (ptr32 int32) dwArg1C, Register out Eq_142 TopOut)
// Called from:
//      parse_args_from_string
//      main
word32 parse_args(FILE * dwArg04, int32 dwArg08, struct Eq_137 * dwArg0C, union Eq_69 * dwArg10, char * dwArg14, char * dwArg18[], int32 * dwArg1C, union Eq_142 & TopOut)
{
	int32 dwLoc80;
	int32 dwLoc78;
	Eq_142 Top_1880 = 0;
	char * eax_15 = dwArg0C->a0000[0];
	dwArg10->u0 = 0x00;
	*dwArg14 = 0x00;
	silent = 0x00;
	ignore_tag_errors = 0x00;
	brhist = 0x01;
	mp3_delay.u0 = 0x00;
	mp3_delay_set = 0x00;
	print_clipping_info = 0x00;
	disable_wav_header = 0x00;
	id3tag_init(dwArg04, eax_15);
	word32 dwLoc14_3892 = 0x00;
	word32 dwLoc1C_3893 = 0x00;
	word32 dwLoc20_3894 = 0x00;
	word32 dwLoc24_3895 = 0x00;
	int32 dwLoc2C_3898 = 0x00;
	word32 dwLoc30_3899 = 0x00;
	word32 dwLoc34_3900 = 0x00;
	int32 dwLoc18_3905 = 0x00;
	while (true)
	{
		word32 eax_131;
		int32 v7_40 = dwLoc18_3905 + 0x01;
		dwLoc18_3905 = v7_40;
		if (v7_40 >= dwArg08)
			break;
		struct Eq_5964 * eax_48 = dwArg0C[v7_40];
		char * dwLoc38_3911 = &eax_48->b0001;
		if ((int8) (eax_48->b0000 == 0x2D) != 0x00)
		{
			char * eax_154;
			int32 dwLoc44_3936 = 0x00;
			if (v7_40 + 0x01 < dwArg08)
				eax_154 = (char *) dwArg0C[v7_40 + 0x01];
			else
				eax_154 = (char *) "";
			char * dwLoc40_3937 = eax_154;
			if (eax_48->b0001 == 0x00)
			{
				dwLoc14_3892 = 0x01;
				if (dwArg10->u0 == 0x00)
					strncpy(dwArg10, dwArg0C[v7_40], 0x1001);
				else if (*dwArg14 == 0x00)
					strncpy(dwArg14, dwArg0C[v7_40], 0x1001);
			}
			if (eax_48->b0001 != 0x2D)
			{
				while (true)
				{
					char * v20_223 = dwLoc38_3911 + 1;
					byte al_218 = *dwLoc38_3911;
					dwLoc38_3911 = v20_223;
					if ((int8) (al_218 != 0x00) == 0x00)
						break;
					char * eax_236;
					if (*v20_223 != 0x00)
						eax_236 = v20_223;
					else
						eax_236 = eax_154;
					Eq_6183 eax_241 = (int32) al_218;
					if (eax_241 > 0x78 || eax_241 < 0x3F)
					{
l08052562:
						error_printf("%s: unrecognized option -%c\n");
						eax_131 = ~0x00;
						goto l08052912;
					}
					switch (eax_241)
					{
					case 0x3F:
						long_help(dwArg04, stdout, eax_15, 0x00);
						eax_131 = ~0x00;
						goto l08052912;
					case 0x40:
					case 0x41:
					case 0x43:
					case 0x44:
					case 0x45:
					case 0x47:
					case 0x48:
					case 0x49:
					case 0x4A:
					case 0x4B:
					case 0x4C:
					case 77:
					case 0x4E:
					case 0x4F:
					case 0x50:
					case 0x51:
					case 0x52:
					case 0x55:
					case 0x57:
					case 0x5B:
					case 0x5C:
					case 0x5D:
					case 0x5E:
					case 0x5F:
					case 0x60:
					case 0x67:
					case 0x69:
					case 0x6A:
					case 0x6C:
					case 110:
					case 117:
					case 0x77:
						goto l08052562;
					case 66:
						lame_set_VBR_max_bitrate_kbps(dwArg04, eax_236, atoi(eax_236));
						dwLoc44_3936 = 0x01;
						break;
					case 0x46:
						lame_set_VBR_hard_min(dwArg04, 0x01);
						break;
					case 0x53:
						silent = 0x0A;
						break;
					case 0x54:
						lame_set_bWriteVbrTag(dwArg04, 0x01);
						disable_wav_header = 0x00;
						dwLoc24_3895 = 0x01;
						break;
					case 0x56:
						dwLoc44_3936 = 0x01;
						if (lame_get_VBR(dwArg04) == 0x00)
							lame_set_VBR(dwArg04, 0x04);
						atof(eax_236);
						Eq_142 Top_612 = Top_1880.u1 + 1;
						Top_612.u1->tFFFFFFFF.u0 = Top_1880.u1->r0000;
						lame_set_VBR_quality(dwArg04, (real32) Top_612.u1->tFFFFFFFF.u0);
						Top_1880 = Top_612;
						break;
					case 88:
						if (__isoc99_sscanf(eax_236, "%d,%d", &dwLoc78, &dwLoc80) == 0x01)
							dwLoc80 = dwLoc78;
						dwLoc44_3936 = 0x01;
						break;
					case 0x59:
						lame_set_experimentalY(dwArg04, 0x01);
						break;
					case 0x5A:
						dwLoc80 = 0x01;
						dwLoc44_3936 = __isoc99_sscanf(eax_236, "%d", &dwLoc80);
						break;
					case 0x61:
						lame_set_mode(dwArg04, 0x03);
						dwLoc1C_3893 = 0x01;
						break;
					case 0x62:
						lame_set_brate(dwArg04, eax_236, atoi(eax_236));
						lame_set_VBR_min_bitrate_kbps(dwArg04, lame_get_brate(dwArg04));
						dwLoc44_3936 = 0x01;
						break;
					case 99:
						lame_set_copyright(dwArg04, 0x01);
						break;
					case 100:
					case 0x6B:
						error_printf("WARNING: -%c is obsolete.\n");
						break;
					case 101:
						dwLoc44_3936 = 0x01;
						int32 eax_461 = (int32) *eax_236;
						if (eax_461 != 99)
						{
							if (eax_461 != 110)
							{
								if (eax_461 != 0x35)
								{
									error_printf("%s: -e emp must be n/5/c not %s\n");
									eax_131 = ~0x00;
									goto l08052912;
								}
								lame_set_emphasis(dwArg04, 0x01);
							}
							else
								lame_set_emphasis(dwArg04, 0x00);
						}
						else
							lame_set_emphasis(dwArg04, 0x03);
						break;
					case 0x66:
						lame_set_quality(dwArg04, 0x07);
						break;
					case 0x68:
						lame_set_quality(dwArg04, 0x02);
						break;
					case 0x6D:
						dwLoc44_3936 = 0x01;
						Eq_6310 eax_378 = (int32) *eax_236;
						if (eax_378 > 115 || eax_378 < 0x61)
						{
l08052119:
							error_printf("%s: -m mode must be s/d/j/f/m not %s\n");
							eax_131 = ~0x00;
							goto l08052912;
						}
						switch (eax_378)
						{
						case 0x61:
							lame_set_mode(dwArg04, 0x01);
							break;
						case 0x62:
						case 99:
						case 101:
						case 0x67:
						case 0x68:
						case 0x69:
						case 0x6B:
						case 0x6C:
						case 110:
						case 111:
						case 0x70:
						case 113:
						case 114:
							goto l08052119;
						case 100:
							lame_set_mode(dwArg04, 0x02);
							break;
						case 0x66:
							lame_set_force_ms(dwArg04, 0x01);
							goto l080520DA;
						case 0x6A:
l080520DA:
							lame_set_mode(dwArg04, 0x01);
							break;
						case 0x6D:
							lame_set_mode(dwArg04, 0x03);
							break;
						case 115:
							lame_set_mode(dwArg04, 0x00);
							break;
						}
						break;
					case 111:
						lame_set_original(dwArg04, 0x00);
						break;
					case 0x70:
						lame_set_error_protection(dwArg04, 0x01);
						break;
					case 113:
						int32 eax_336 = atoi(eax_236);
						dwLoc44_3936 = 0x01;
						int32 dwLoc74_3991 = eax_336;
						if (eax_336 < 0x00)
							dwLoc74_3991 = 0x00;
						if (dwLoc74_3991 > 0x09)
							dwLoc74_3991 = 0x09;
						lame_set_quality(dwArg04, dwLoc74_3991);
						break;
					case 114:
						input_format.u0 = 0x01;
						break;
					case 115:
						atof(eax_236);
						Eq_5769 rLoc8C_3976 = Top_1880.u1->r0000;
						Eq_6346 Top_287 = Top_1880.u1 + 1;
						Top_287.u1->tFFFFFFFF.u0 = (real64) rLoc8C_3976;
						Top_287.u1->tFFFFFFFE.u0 = g_t8059860.u0;
						Top_287.u1->tFFFFFFFF.u0 = Top_287.u1->tFFFFFFFF.u0;
						dwLoc44_3936 = 0x01;
						if ((int8) (Top_287.u1->tFFFFFFFE.u0 >= ((Top_287.u1)->tFFFFFFFF).u0) != 0x00)
							Top_287.u1->tFFFFFFFF.u0 = g_t8059828.u0;
						else
							Top_287.u1->tFFFFFFFF.u0 = 1.0;
						Top_1880.u1->r0000 *= rLoc8C_3976;
						Eq_6408 Top_311 = Top_1880 - 1;
						Top_311.u1->r0000 = 0.5;
						Top_311.u1[1] = (struct Eq_10690) (Top_311.u1[1] + (Top_311.u1)->r0000);
						Eq_559 wLocB2_3978 = __fstcw();
						__fldcw(SEQ(0x0C, (byte) wLocB2_3978));
						int32 dwLocB8_3980 = (int32) Top_311.u1[1];
						__fldcw(wLocB2_3978);
						lame_set_in_samplerate(dwArg04, dwLocB8_3980);
						&Top_1880.u1->r0000 = (word32) Top_311 + 2;
						break;
					case 116:
						lame_set_bWriteVbrTag(dwArg04, 0x00);
						disable_wav_header = 0x01;
						break;
					case 118:
						if (lame_get_VBR(dwArg04) == 0x00)
							lame_set_VBR(dwArg04, 0x04);
						break;
					case 0x78:
						swapbytes = 0x01;
						break;
					}
					if (dwLoc44_3936 != 0x00)
					{
						if (eax_236 == v20_223)
							dwLoc38_3911 = (char *) "";
						else
							++dwLoc18_3905;
						dwLoc44_3936 = 0x00;
					}
				}
				continue;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8058EF1) == 0x00)
			{
				atof(eax_154);
				lame_set_out_samplerate(dwArg04, resample_rate(Top_1880.u1->r0000));
				dwLoc44_3936 = 0x01;
				&Top_1880.u1->r0000 = Top_1880.u1 + 1;
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8058EFA) == 0x00)
			{
				lame_set_VBR(dwArg04, 0x02);
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8058F02) == 0x00)
			{
				lame_set_VBR(dwArg04, 0x04);
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8058F0A) == 0x00)
			{
				lame_set_VBR(dwArg04, 0x04);
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8058F13) == 0x00)
			{
				lame_set_VBR(dwArg04, 0x00);
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8058F17) == 0x00)
			{
				lame_set_VBR(dwArg04, 0x03);
				lame_set_VBR_mean_bitrate_kbps(dwArg04, eax_154, atoi(eax_154));
				dwLoc44_3936 = 0x01;
				if (lame_get_VBR_mean_bitrate_kbps(dwArg04) > 7999)
				{
					word32 eax_3419 = lame_get_VBR_mean_bitrate_kbps(dwArg04);
					lame_set_VBR_mean_bitrate_kbps(dwArg04, (SLICE((eax_3419 + 500) *s64 274877907, word32, 32) >> 0x06) - (eax_3419 + 500 >> 0x1F));
				}
				word32 eax_3454;
				if (lame_get_VBR_mean_bitrate_kbps(dwArg04) <= 0x013F)
					eax_3454 = lame_get_VBR_mean_bitrate_kbps(dwArg04);
				else
					eax_3454 = 0x0140;
				word32 eax_3480;
				lame_set_VBR_mean_bitrate_kbps(dwArg04, eax_3454);
				if (lame_get_VBR_mean_bitrate_kbps(dwArg04) > 0x08)
					eax_3480 = lame_get_VBR_mean_bitrate_kbps(dwArg04);
				else
					eax_3480 = 0x08;
				lame_set_VBR_mean_bitrate_kbps(dwArg04, eax_3480);
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8058F1B) == 0x00)
			{
				lame_set_preset(dwArg04, 1000);
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8058F21) == 0x00)
			{
				in_bitwidth = atoi(eax_154);
				dwLoc44_3936 = 0x01;
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8058F2A) == 0x00)
			{
				in_signed = 0x01;
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8058F31) == 0x00)
			{
				in_signed = 0x00;
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8058F3A) == 0x00)
			{
				in_endian = 0x00;
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8058F48) == 0x00)
			{
				in_endian = 0x01;
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8058F53) == 0x00)
			{
				input_format.u0 = 0x04;
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8058F5C) == 0x00)
			{
				input_format.u0 = 0x05;
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8058F65) == 0x00)
			{
				input_format.u0 = 0x06;
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8058F6E) == 0x00)
			{
				error_printf("sorry, vorbis support in LAME is deprecated.\n");
				eax_131 = ~0x00;
				goto l08052912;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, g_str8058929) == 0x00)
			{
				if (presets_set(dwArg04, 0x00, 0x00, &eax_48->b0001 + 1) < 0x00)
				{
					eax_131 = ~0x00;
					goto l08052912;
				}
				error_printf("Warning: --phone is deprecated, use --preset phone instead!");
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, g_str8058950) == 0x00)
			{
				if (presets_set(dwArg04, 0x00, 0x00, &eax_48->b0001 + 1) < 0x00)
				{
					eax_131 = ~0x00;
					goto l08052912;
				}
				error_printf("Warning: --voice is deprecated, use --preset voice instead!");
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8059020) == 0x00)
			{
				lame_set_decode_only(dwArg04, 0x01);
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8059027) == 0x00)
			{
				flush_write = 0x01;
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b805902D) == 0x00)
			{
				mp3_delay.u0 = (int32) atoi(eax_154);
				mp3_delay_set = 0x01;
				dwLoc44_3936 = 0x01;
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b805903D) == 0x00)
			{
				lame_set_disable_reservoir(dwArg04, 0x01);
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8059043) == 0x00)
			{
				lame_set_strict_ISO(dwArg04, 0x01);
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8059058) == 0x00)
			{
				atof(eax_154);
				Eq_142 Top_3272 = Top_1880.u1 + 1;
				Top_3272.u1->tFFFFFFFF.u0 = Top_1880.u1->r0000;
				lame_set_scale(dwArg04, (real32) Top_3272.u1->tFFFFFFFF.u0);
				dwLoc44_3936 = 0x01;
				Top_1880 = Top_3272;
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b805905E) == 0x00)
			{
				atof(eax_154);
				Eq_142 Top_3253 = Top_1880.u1 + 1;
				Top_3253.u1->tFFFFFFFF.u0 = Top_1880.u1->r0000;
				lame_set_scale_left(dwArg04, (real32) Top_3253.u1->tFFFFFFFF.u0);
				dwLoc44_3936 = 0x01;
				Top_1880 = Top_3253;
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8059066) == 0x00)
			{
				atof(eax_154);
				Eq_142 Top_3234 = Top_1880.u1 + 1;
				Top_3234.u1->tFFFFFFFF.u0 = Top_1880.u1->r0000;
				lame_set_scale_right(dwArg04, (real32) Top_3234.u1->tFFFFFFFF.u0);
				dwLoc44_3936 = 0x01;
				Top_1880 = Top_3234;
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b805906E) == 0x00)
			{
				dwLoc44_3936 = 0x01;
				if (strcmp(eax_154, "mmx") == 0x00)
					lame_set_asm_optimizations(dwArg04, 0x01, 0x00);
				if (strcmp(eax_154, "3dnow") == 0x00)
					lame_set_asm_optimizations(dwArg04, 0x02, 0x00);
				if (strcmp(eax_154, "sse") == 0x00)
					lame_set_asm_optimizations(dwArg04, 0x03, 0x00);
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8059082) == 0x00)
			{
				lame_set_free_format(dwArg04, 0x01);
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b805908D) == 0x00)
			{
				lame_set_findReplayGain(dwArg04, 0x01);
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b805909D) == 0x00)
			{
				lame_set_decode_on_the_fly(dwArg04, 0x01);
				lame_set_findReplayGain(dwArg04, 0x01);
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b80590B1) == 0x00)
			{
				lame_set_findReplayGain(dwArg04, 0x00);
				dwLoc30_3899 = 0x01;
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b80590BE) == 0x00)
			{
				print_clipping_info = 0x01;
				lame_set_decode_on_the_fly(dwArg04, 0x01);
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b80590C9) == 0x00)
			{
				brhist = 0x00;
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b80590D0) == 0x00)
			{
				id3_tag(dwArg04, 116, eax_154);
				dwLoc44_3936 = 0x01;
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b80590D3) == 0x00)
			{
				id3_tag(dwArg04, 0x61, eax_154);
				dwLoc44_3936 = 0x01;
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b80590D6) == 0x00)
			{
				id3_tag(dwArg04, 0x6C, eax_154);
				dwLoc44_3936 = 0x01;
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b80590D9) == 0x00)
			{
				id3_tag(dwArg04, 121, eax_154);
				dwLoc44_3936 = 0x01;
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b80590DC) == 0x00)
			{
				id3_tag(dwArg04, 99, eax_154);
				dwLoc44_3936 = 0x01;
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b80590DF) == 0x00)
			{
				id3_tag(dwArg04, 110, eax_154);
				dwLoc44_3936 = 0x01;
				if (dwArg04 != null && ignore_tag_errors == 0x00)
				{
					if (dwLoc34_3900 == 0x01)
					{
						error_printf("The track number has to be between 1 and 255 for ID3v1.\n");
						eax_131 = ~0x00;
						goto l08052912;
					}
					if (dwLoc34_3900 != 0x02 && silent <= 0x09)
						error_printf("The track number has to be between 1 and 255 for ID3v1, ignored for ID3v1.\n");
				}
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b805916C) == 0x00)
			{
				id3_tag(dwArg04, 0x67, eax_154);
				dwLoc44_3936 = 0x01;
				if (dwArg04 != null && ignore_tag_errors == 0x00)
				{
					if (dwArg04 == (FILE *) ~0x00)
					{
						error_printf("Unknown ID3v1 genre number: '%s'.\n");
						eax_131 = ~0x00;
						goto l08052912;
					}
					if (dwArg04 != (FILE *) ~0x01)
					{
						error_printf("Internal error.\n");
						eax_131 = ~0x00;
						goto l08052912;
					}
					if (dwLoc34_3900 == 0x01)
					{
						error_printf("Unknown ID3v1 genre: '%s'.\n");
						eax_131 = ~0x00;
						goto l08052912;
					}
					if (dwLoc34_3900 != 0x02 && silent <= 0x09)
						error_printf("Unknown ID3v1 genre: '%s'.  Setting ID3v1 genre to 'Other'\n");
				}
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b80591FD) == 0x00)
			{
				id3_tag(dwArg04, 118, eax_154);
				dwLoc44_3936 = 0x01;
				if (dwArg04 != null && silent <= 0x09)
					error_printf("Invalid field value: '%s'. Ignored\n");
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8059224) == 0x00)
			{
				dwLoc44_3936 = 0x01;
				if (set_id3_albumart(dwArg04, eax_154) != 0x00 && ignore_tag_errors == 0x00)
				{
					eax_131 = ~0x00;
					goto l08052912;
				}
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8059227) == 0x00)
			{
				ignore_tag_errors = 0x01;
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8059239) == 0x00)
			{
				id3tag_add_v2(dwArg04);
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8059243) == 0x00)
			{
				id3tag_v1_only(dwArg04);
				dwLoc34_3900 = 0x01;
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b805924E) == 0x00)
			{
				id3tag_v2_only(dwArg04);
				dwLoc34_3900 = 0x02;
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8059259) == 0x00)
			{
				id3tag_space_v1(dwArg04);
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8059265) == 0x00)
			{
				id3tag_pad_v2(dwArg04);
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b805926F) == 0x00)
			{
				int32 eax_2859 = atoi(eax_154);
				int32 eax_2861 = 0x0001F400;
				if (eax_2859 <= 0x0001F400)
					eax_2861 = eax_2859;
				int32 eax_2868 = 0x00;
				if (eax_2861 >= 0x00)
					eax_2868 = eax_2861;
				id3tag_set_pad(dwArg04, eax_2868, eax_2868);
				dwLoc44_3936 = 0x01;
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b805927E) == 0x00)
			{
				id3tag_genre_list(0x080500DE, 0x00);
				eax_131 = ~0x01;
				goto l08052912;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8059289) == 0x00)
			{
				atof(eax_154);
				Eq_5769 rLoc8C_4634 = Top_1880.u1->r0000;
				Eq_142 Top_2744 = Top_1880.u1 + 1;
				Top_2744.u1->tFFFFFFFF.u0 = (real64) rLoc8C_4634;
				Top_2744.u1->tFFFFFFFE.u0 = 0.0;
				Top_2744.u1->tFFFFFFFF.u0 = Top_2744.u1->tFFFFFFFF.u0;
				dwLoc44_3936 = 0x01;
				Top_1880 = Top_2744;
				if ((int8) (Top_2744.u1->tFFFFFFFE.u0 > ((Top_2744.u1)->tFFFFFFFF).u0) != 0x00)
				{
					lame_set_lowpassfreq(dwArg04, ~0x00);
					goto l0805203C;
				}
				Top_2744.u1->tFFFFFFFF.u0 = (real64) rLoc8C_4634;
				Top_2744.u1->tFFFFFFFE.u0 = g_t8059830.u0;
				Top_2744.u1->tFFFFFFFF.u0 = Top_2744.u1->tFFFFFFFF.u0;
				if ((int8) (Top_2744.u1->tFFFFFFFE.u0 > ((Top_2744.u1)->tFFFFFFFF).u0) != 0x00)
				{
l08051431:
					error_printf("Must specify lowpass with --lowpass freq, freq >= 0.001 kHz\n");
					Top_1880 = Top_2744;
					eax_131 = ~0x00;
					goto l08052912;
				}
				Top_2744.u1->tFFFFFFFF.u0 = (real64) rLoc8C_4634;
				Top_2744.u1->tFFFFFFFE.u0 = g_t8059838.u0;
				Eq_5769 v36_2778 = Top_2744.u1->tFFFFFFFE.u0;
				Top_2744.u1->tFFFFFFFE.u0 = Top_2744.u1->tFFFFFFFF.u0;
				Top_2744.u1->tFFFFFFFF.u0 = (real64) v36_2778;
				Top_2744.u1->tFFFFFFFF.u0 = Top_2744.u1->tFFFFFFFF.u0;
				if ((int8) (Top_2744.u1->tFFFFFFFE.u0 > ((Top_2744.u1)->tFFFFFFFF).u0) != 0x00)
					goto l08051431;
				Top_2744.u1->tFFFFFFFF.u0 = (real64) rLoc8C_4634;
				Top_2744.u1->tFFFFFFFE.u0 = g_t8059840.u0;
				Top_2744.u1->tFFFFFFFF.u0 = Top_2744.u1->tFFFFFFFF.u0;
				if ((int8) (Top_2744.u1->tFFFFFFFE.u0 > ((Top_2744.u1)->tFFFFFFFF).u0) != 0x00)
					Top_2744.u1->tFFFFFFFF.u0 = g_t8059828.u0;
				else
					Top_2744.u1->tFFFFFFFF.u0 = 1.0;
				Top_1880.u1->r0000 *= rLoc8C_4634;
				Eq_7949 Top_2814 = Top_1880 - 1;
				Top_2814.u1->r0000 = 0.5;
				Top_2814.u1[1] = (struct Eq_10690) (Top_2814.u1[1] + (Top_2814.u1)->r0000);
				Eq_559 wLocB2_4637 = __fstcw();
				__fldcw(SEQ(0x0C, (byte) wLocB2_4637));
				int32 dwLocB8_4639 = (int32) Top_2814.u1[1];
				__fldcw(wLocB2_4637);
				lame_set_lowpassfreq(dwArg04, dwLocB8_4639);
				&Top_1880.u1->r0000 = (word32) Top_2814 + 2;
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b80592D1) == 0x00)
			{
				atof(eax_154);
				Eq_5769 rLoc8C_4618 = Top_1880.u1->r0000;
				Eq_142 Top_2652 = Top_1880.u1 + 1;
				Top_2652.u1->tFFFFFFFF.u0 = (real64) rLoc8C_4618;
				Top_2652.u1->tFFFFFFFE.u0 = g_t8059830.u0;
				Top_2652.u1->tFFFFFFFF.u0 = Top_2652.u1->tFFFFFFFF.u0;
				dwLoc44_3936 = 0x01;
				if ((int8) (Top_2652.u1->tFFFFFFFE.u0 > ((Top_2652.u1)->tFFFFFFFF).u0) != 0x00)
				{
l0805151B:
					error_printf("Must specify lowpass width with --lowpass-width freq, freq >= 0.001 kHz\n");
					Top_1880 = Top_2652;
					eax_131 = ~0x00;
					goto l08052912;
				}
				Top_2652.u1->tFFFFFFFF.u0 = (real64) rLoc8C_4618;
				Top_2652.u1->tFFFFFFFE.u0 = g_t8059838.u0;
				Eq_5769 v33_2672 = Top_2652.u1->tFFFFFFFE.u0;
				Top_2652.u1->tFFFFFFFE.u0 = Top_2652.u1->tFFFFFFFF.u0;
				Top_2652.u1->tFFFFFFFF.u0 = (real64) v33_2672;
				Top_2652.u1->tFFFFFFFF.u0 = Top_2652.u1->tFFFFFFFF.u0;
				if ((int8) (Top_2652.u1->tFFFFFFFE.u0 > ((Top_2652.u1)->tFFFFFFFF).u0) != 0x00)
					goto l0805151B;
				Top_2652.u1->tFFFFFFFF.u0 = (real64) rLoc8C_4618;
				Top_2652.u1->tFFFFFFFE.u0 = g_t8059850.u0;
				Top_2652.u1->tFFFFFFFF.u0 = Top_2652.u1->tFFFFFFFF.u0;
				if ((int8) (Top_2652.u1->tFFFFFFFE.u0 > ((Top_2652.u1)->tFFFFFFFF).u0) != 0x00)
					Top_2652.u1->tFFFFFFFF.u0 = g_t8059828.u0;
				else
					Top_2652.u1->tFFFFFFFF.u0 = 1.0;
				Top_1880.u1->r0000 *= rLoc8C_4618;
				Eq_7614 Top_2708 = Top_1880 - 1;
				Top_2708.u1->r0000 = 0.5;
				Top_2708.u1[1] = (struct Eq_10690) (Top_2708.u1[1] + (Top_2708.u1)->r0000);
				Eq_559 wLocB2_4621 = __fstcw();
				__fldcw(SEQ(0x0C, (byte) wLocB2_4621));
				int32 dwLocB8_4623 = (int32) Top_2708.u1[1];
				__fldcw(wLocB2_4621);
				lame_set_lowpasswidth(dwArg04, dwLocB8_4623);
				&Top_1880.u1->r0000 = (word32) Top_2708 + 2;
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8059329) == 0x00)
			{
				atof(eax_154);
				Eq_5769 rLoc8C_4600 = Top_1880.u1->r0000;
				Eq_142 Top_2539 = Top_1880.u1 + 1;
				Top_2539.u1->tFFFFFFFF.u0 = (real64) rLoc8C_4600;
				Top_2539.u1->tFFFFFFFE.u0 = 0.0;
				Top_2539.u1->tFFFFFFFF.u0 = Top_2539.u1->tFFFFFFFF.u0;
				dwLoc44_3936 = 0x01;
				Top_1880 = Top_2539;
				if ((int8) (Top_2539.u1->tFFFFFFFE.u0 > ((Top_2539.u1)->tFFFFFFFF).u0) != 0x00)
				{
					lame_set_highpassfreq(dwArg04, ~0x00);
					goto l0805203C;
				}
				Top_2539.u1->tFFFFFFFF.u0 = (real64) rLoc8C_4600;
				Top_2539.u1->tFFFFFFFE.u0 = g_t8059830.u0;
				Top_2539.u1->tFFFFFFFF.u0 = Top_2539.u1->tFFFFFFFF.u0;
				if ((int8) (Top_2539.u1->tFFFFFFFE.u0 > ((Top_2539.u1)->tFFFFFFFF).u0) != 0x00)
				{
l08051630:
					error_printf("Must specify highpass with --highpass freq, freq >= 0.001 kHz\n");
					Top_1880 = Top_2539;
					eax_131 = ~0x00;
					goto l08052912;
				}
				Top_2539.u1->tFFFFFFFF.u0 = (real64) rLoc8C_4600;
				Top_2539.u1->tFFFFFFFE.u0 = g_t8059838.u0;
				Eq_5769 v34_2573 = Top_2539.u1->tFFFFFFFE.u0;
				Top_2539.u1->tFFFFFFFE.u0 = Top_2539.u1->tFFFFFFFF.u0;
				Top_2539.u1->tFFFFFFFF.u0 = (real64) v34_2573;
				Top_2539.u1->tFFFFFFFF.u0 = Top_2539.u1->tFFFFFFFF.u0;
				if ((int8) (Top_2539.u1->tFFFFFFFE.u0 > ((Top_2539.u1)->tFFFFFFFF).u0) != 0x00)
					goto l08051630;
				Top_2539.u1->tFFFFFFFF.u0 = (real64) rLoc8C_4600;
				Top_2539.u1->tFFFFFFFE.u0 = g_t8059850.u0;
				Top_2539.u1->tFFFFFFFF.u0 = Top_2539.u1->tFFFFFFFF.u0;
				if ((int8) (Top_2539.u1->tFFFFFFFE.u0 > ((Top_2539.u1)->tFFFFFFFF).u0) != 0x00)
					Top_2539.u1->tFFFFFFFF.u0 = g_t8059828.u0;
				else
					Top_2539.u1->tFFFFFFFF.u0 = 1.0;
				Top_1880.u1->r0000 *= rLoc8C_4600;
				Eq_7730 Top_2609 = Top_1880 - 1;
				Top_2609.u1->r0000 = 0.5;
				Top_2609.u1[1] = (struct Eq_10690) (Top_2609.u1[1] + (Top_2609.u1)->r0000);
				Eq_559 wLocB2_4603 = __fstcw();
				__fldcw(SEQ(0x0C, (byte) wLocB2_4603));
				int32 dwLocB8_4605 = (int32) Top_2609.u1[1];
				__fldcw(wLocB2_4603);
				lame_set_highpassfreq(dwArg04, dwLocB8_4605);
				&Top_1880.u1->r0000 = (word32) Top_2609 + 2;
				goto l0805203C;
			}
			if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8059373) != 0x00)
			{
				if (local_strcasecmp(&eax_48->b0001 + 1, &g_b80593CF) == 0x00)
				{
					atof(eax_154);
					Eq_5769 rLoc8C_4585 = Top_1880.u1->r0000;
					Eq_142 Top_2430 = Top_1880.u1 + 1;
					Top_2430.u1->tFFFFFFFF.u0 = (real64) rLoc8C_4585;
					Top_2430.u1->tFFFFFFFE.u0 = 1.0;
					Top_2430.u1->tFFFFFFFF.u0 = Top_2430.u1->tFFFFFFFF.u0;
					dwLoc44_3936 = 0x01;
					Top_1880 = Top_2430;
					if ((int8) (Top_2430.u1->tFFFFFFFE.u0 > ((Top_2430.u1)->tFFFFFFFF).u0) != 0x00)
					{
						error_printf("Must specify compression ratio >= 1.0\n");
						eax_131 = ~0x00;
						goto l08052912;
					}
					Top_2430.u1->tFFFFFFFF.u0 = (real64) rLoc8C_4585;
					Top_2430.u1->tFFFFFFFF.u0 = Top_2430.u1->tFFFFFFFF.u0;
					lame_set_compression_ratio(dwArg04, (real32) Top_2430.u1->tFFFFFFFF.u0);
					Top_1880 = Top_2430;
				}
				else if (local_strcasecmp(&eax_48->b0001 + 1, &g_b80593FB) == 0x00)
					lame_set_useTemporal(dwArg04, 0x00);
				else if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8059402) == 0x00)
				{
					atof(eax_154);
					Eq_142 Top_2404 = Top_1880.u1 + 1;
					Top_2404.u1->tFFFFFFFF.u0 = Top_1880.u1->r0000;
					lame_set_interChRatio(dwArg04, (real32) Top_2404.u1->tFFFFFFFF.u0);
					dwLoc44_3936 = 0x01;
					Top_1880 = Top_2404;
				}
				else if (local_strcasecmp(&eax_48->b0001 + 1, &g_b805940A) == 0x00)
				{
					lame_set_useTemporal(dwArg04, eax_154, (word32) (atoi(eax_154) != 0x00));
					dwLoc44_3936 = 0x01;
				}
				else if (local_strcasecmp(&eax_48->b0001 + 1, &g_b805941B) != 0x00)
				{
					if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8059425) == 0x00)
						lame_set_exp_nspsytune(dwArg04, lame_get_exp_nspsytune(dwArg04) | 0x02);
					else if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8059431) == 0x00)
					{
						atof(eax_154);
						lame_set_msfix(dwArg04, Top_1880.u1->r0000);
						dwLoc44_3936 = 0x01;
						&Top_1880.u1->r0000 = Top_1880.u1 + 1;
					}
					else if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8059439) == 0x00)
					{
						atof(eax_154);
						Eq_142 Top_2290 = Top_1880.u1 + 1;
						Top_2290.u1->tFFFFFFFF.u0 = Top_1880.u1->r0000;
						Top_2290.u1->tFFFFFFFE.u0 = g_t8059858.u0;
						Top_2290.u1->tFFFFFFFF.u0 = (real64) (Top_2290.u1->tFFFFFFFF.u0 * ((Top_2290.u1)->tFFFFFFFE).u0);
						Eq_559 wLocB2_4535 = __fstcw();
						__fldcw(SEQ(0x0C, (byte) wLocB2_4535));
						int32 dwLoc54_4537 = (int32) Top_2290.u1->tFFFFFFFF.u0;
						__fldcw(wLocB2_4535);
						dwLoc44_3936 = 0x01;
						Top_1880 = Top_2290;
						if (dwLoc54_4537 < ~0x1F)
							dwLoc54_4537 = ~0x1F;
						if (dwLoc54_4537 > 0x1F)
							dwLoc54_4537 = 0x1F;
						if (dwLoc54_4537 < 0x00)
							dwLoc54_4537 += 0x40;
						lame_set_exp_nspsytune(dwArg04, lame_get_exp_nspsytune(dwArg04) | dwLoc54_4537 << 0x02);
					}
					else if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8059441) == 0x00)
					{
						atof(eax_154);
						Eq_142 Top_2225 = Top_1880.u1 + 1;
						Top_2225.u1->tFFFFFFFF.u0 = Top_1880.u1->r0000;
						Top_2225.u1->tFFFFFFFE.u0 = g_t8059858.u0;
						Top_2225.u1->tFFFFFFFF.u0 = (real64) (Top_2225.u1->tFFFFFFFF.u0 * ((Top_2225.u1)->tFFFFFFFE).u0);
						Eq_559 wLocB2_4502 = __fstcw();
						__fldcw(SEQ(0x0C, (byte) wLocB2_4502));
						int32 dwLoc58_4504 = (int32) Top_2225.u1->tFFFFFFFF.u0;
						__fldcw(wLocB2_4502);
						dwLoc44_3936 = 0x01;
						Top_1880 = Top_2225;
						if (dwLoc58_4504 < ~0x1F)
							dwLoc58_4504 = ~0x1F;
						if (dwLoc58_4504 > 0x1F)
							dwLoc58_4504 = 0x1F;
						if (dwLoc58_4504 < 0x00)
							dwLoc58_4504 += 0x40;
						lame_set_exp_nspsytune(dwArg04, lame_get_exp_nspsytune(dwArg04) | dwLoc58_4504 << 0x08);
					}
					else if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8059449) == 0x00)
					{
						atof(eax_154);
						Eq_142 Top_2160 = Top_1880.u1 + 1;
						Top_2160.u1->tFFFFFFFF.u0 = Top_1880.u1->r0000;
						Top_2160.u1->tFFFFFFFE.u0 = g_t8059858.u0;
						Top_2160.u1->tFFFFFFFF.u0 = (real64) (Top_2160.u1->tFFFFFFFF.u0 * ((Top_2160.u1)->tFFFFFFFE).u0);
						Eq_559 wLocB2_4469 = __fstcw();
						__fldcw(SEQ(0x0C, (byte) wLocB2_4469));
						int32 dwLoc5C_4471 = (int32) Top_2160.u1->tFFFFFFFF.u0;
						__fldcw(wLocB2_4469);
						dwLoc44_3936 = 0x01;
						Top_1880 = Top_2160;
						if (dwLoc5C_4471 < ~0x1F)
							dwLoc5C_4471 = ~0x1F;
						if (dwLoc5C_4471 > 0x1F)
							dwLoc5C_4471 = 0x1F;
						if (dwLoc5C_4471 < 0x00)
							dwLoc5C_4471 += 0x40;
						lame_set_exp_nspsytune(dwArg04, lame_get_exp_nspsytune(dwArg04) | dwLoc5C_4471 << 0x0E);
					}
					else if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8059453) == 0x00)
					{
						atof(eax_154);
						Eq_142 Top_2095 = Top_1880.u1 + 1;
						Top_2095.u1->tFFFFFFFF.u0 = Top_1880.u1->r0000;
						Top_2095.u1->tFFFFFFFE.u0 = g_t8059858.u0;
						Top_2095.u1->tFFFFFFFF.u0 = (real64) (Top_2095.u1->tFFFFFFFF.u0 * ((Top_2095.u1)->tFFFFFFFE).u0);
						Eq_559 wLocB2_4436 = __fstcw();
						__fldcw(SEQ(0x0C, (byte) wLocB2_4436));
						int32 dwLoc60_4438 = (int32) Top_2095.u1->tFFFFFFFF.u0;
						__fldcw(wLocB2_4436);
						dwLoc44_3936 = 0x01;
						Top_1880 = Top_2095;
						if (dwLoc60_4438 < ~0x1F)
							dwLoc60_4438 = ~0x1F;
						if (dwLoc60_4438 > 0x1F)
							dwLoc60_4438 = 0x1F;
						if (dwLoc60_4438 < 0x00)
							dwLoc60_4438 += 0x40;
						lame_set_exp_nspsytune(dwArg04, lame_get_exp_nspsytune(dwArg04) | dwLoc60_4438 << 0x14);
					}
					else if (local_strcasecmp(&eax_48->b0001 + 1, &g_b805945C) != 0x00)
					{
						if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8059467) != 0x00 && local_strcasecmp(&eax_48->b0001 + 1, &g_b805946D) != 0x00)
						{
							if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8059474) == 0x00)
								silent = ~0x04;
							else if (local_strcasecmp(&eax_48->b0001 + 1, &g_b805947A) == 0x00)
								silent = ~0x09;
							else
							{
								if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8059482) == 0x00 || local_strcasecmp(&eax_48->b0001 + 1, &g_b805948A) == 0x00)
								{
									print_license(stdout);
									eax_131 = ~0x01;
									goto l08052912;
								}
								if (local_strcasecmp(&eax_48->b0001 + 1, g_str8058924) == 0x00 || local_strcasecmp(&eax_48->b0001 + 1, &g_b8059492) == 0x00)
								{
									short_help(dwArg04, stdout, eax_15);
									eax_131 = ~0x01;
									goto l08052912;
								}
								if (local_strcasecmp(&eax_48->b0001 + 1, &g_b8059498) == 0x00)
								{
									long_help(dwArg04, stdout, eax_15, 0x00);
									eax_131 = ~0x01;
									goto l08052912;
								}
								if (local_strcasecmp(&eax_48->b0001 + 1, &g_b80594A1) == 0x00)
								{
									FILE * eax_2014 = popen(0x080594A5, 134583459);
									long_help(dwArg04, eax_2014, eax_15, 0x00);
									pclose(eax_2014);
									eax_131 = ~0x01;
									goto l08052912;
								}
								if (local_strcasecmp(&eax_48->b0001 + 1, &g_b80594AF) != 0x00 && local_strcasecmp(&eax_48->b0001 + 1, &g_b80594B6) != 0x00)
								{
									if (local_strcasecmp(&eax_48->b0001 + 1, &g_b80594C6) == 0x00)
									{
										atof(eax_154);
										Eq_142 Top_1916 = Top_1880.u1 + 1;
										Top_1916.u1->tFFFFFFFF.u0 = Top_1880.u1->r0000;
										update_interval = (real32) Top_1916.u1->tFFFFFFFF.u0;
										dwLoc44_3936 = 0x01;
										Top_1880 = Top_1916;
									}
									else if (local_strcasecmp(&eax_48->b0001 + 1, &g_b80594CF) == 0x00)
										dwLoc24_3895 = 0x01;
									else if (local_strcasecmp(&eax_48->b0001 + 1, &g_b80594D9) == 0x00)
									{
										strcpy(dwArg14, eax_154);
										dwLoc44_3936 = 0x01;
									}
									else if (local_strcasecmp(&eax_48->b0001 + 1, &g_b80594E2) == 0x00)
										dwLoc20_3894 = 0x01;
									else
									{
										if (local_strcasecmp(&eax_48->b0001 + 1, &g_b80594E8) != 0x00)
										{
											error_printf("%s: unrecognized option --%s\n");
											eax_131 = ~0x00;
											goto l08052912;
										}
										atof(eax_154);
										Eq_142 Top_1889 = Top_1880.u1 + 1;
										Top_1889.u1->tFFFFFFFF.u0 = Top_1880.u1->r0000;
										lame_set_athaa_sensitivity(dwArg04, (real32) Top_1889.u1->tFFFFFFFF.u0);
										dwLoc44_3936 = 0x01;
										Top_1880 = Top_1889;
									}
								}
								else
								{
									dwLoc44_3936 = 0x01;
									int32 dwLoc68_4360 = 0x00;
									int32 dwLoc6C_4361 = 0x00;
									while (strcmp(dwLoc40_3937, "fast") == 0x00 || strcmp(dwLoc40_3937, "cbr") == 0x00)
									{
										if (strcmp(dwLoc40_3937, "fast") == 0x00 && dwLoc68_4360 <= 0x00)
											dwLoc68_4360 = 0x01;
										if (strcmp(dwLoc40_3937, "cbr") == 0x00 && dwLoc6C_4361 <= 0x00)
											dwLoc6C_4361 = 0x01;
										char * eax_1978;
										int32 v42_1971 = dwLoc44_3936 + 0x01;
										dwLoc44_3936 = v42_1971;
										if (v7_40 + v42_1971 < dwArg08)
											eax_1978 = (char *) dwArg0C[v7_40 + v42_1971];
										else
											eax_1978 = (char *) "";
										dwLoc40_3937 = eax_1978;
									}
									if (presets_set(dwArg04, dwLoc68_4360, dwLoc6C_4361, dwLoc40_3937) < 0x00)
									{
										eax_131 = ~0x00;
										goto l08052912;
									}
								}
							}
						}
						else
							silent = 0x0A;
					}
				}
				goto l0805203C;
			}
			atof(eax_154);
			Eq_5769 rLoc8C_4591 = Top_1880.u1->r0000;
			Eq_142 Top_2473 = Top_1880.u1 + 1;
			Top_2473.u1->tFFFFFFFF.u0 = (real64) rLoc8C_4591;
			Top_2473.u1->tFFFFFFFE.u0 = g_t8059830.u0;
			Top_2473.u1->tFFFFFFFF.u0 = Top_2473.u1->tFFFFFFFF.u0;
			dwLoc44_3936 = 0x01;
			if ((int8) (Top_2473.u1->tFFFFFFFE.u0 > ((Top_2473.u1)->tFFFFFFFF).u0) == 0x00)
			{
				Top_2473.u1->tFFFFFFFF.u0 = (real64) rLoc8C_4591;
				Top_2473.u1->tFFFFFFFE.u0 = g_t8059838.u0;
				Eq_5769 v35_2493 = Top_2473.u1->tFFFFFFFE.u0;
				Top_2473.u1->tFFFFFFFE.u0 = Top_2473.u1->tFFFFFFFF.u0;
				Top_2473.u1->tFFFFFFFF.u0 = (real64) v35_2493;
				Top_2473.u1->tFFFFFFFF.u0 = Top_2473.u1->tFFFFFFFF.u0;
				if ((int8) (Top_2473.u1->tFFFFFFFE.u0 > ((Top_2473.u1)->tFFFFFFFF).u0) == 0x00)
				{
					Top_2473.u1->tFFFFFFFF.u0 = (real64) rLoc8C_4591;
					Eq_559 wLocB2_4593 = __fstcw();
					__fldcw(SEQ(0x0C, (byte) wLocB2_4593));
					int32 dwLocB8_4595 = (int32) Top_2473.u1->tFFFFFFFF.u0;
					__fldcw(wLocB2_4593);
					lame_set_highpasswidth(dwArg04, dwLocB8_4595);
					Top_1880 = Top_2473;
l0805203C:
					dwLoc18_3905 = v7_40 + dwLoc44_3936;
					continue;
				}
			}
			error_printf("Must specify highpass width with --highpass-width freq, freq >= 0.001 kHz\n");
			Top_1880 = Top_2473;
			eax_131 = ~0x00;
			goto l08052912;
		}
		if (dwLoc20_3894 == 0x00)
		{
			if (dwArg10->u0 == 0x00)
			{
				strncpy(dwArg10, dwArg0C[v7_40], 0x1001);
				dwLoc14_3892 = 0x01;
				continue;
			}
			if (*dwArg14 != 0x00)
			{
				error_printf("%s: excess arg %s\n");
				eax_131 = ~0x00;
				goto l08052912;
			}
			else
			{
				strncpy(dwArg14, dwArg0C[v7_40], 0x1001);
				continue;
			}
		}
		if (dwArg1C == null || *dwArg1C <= dwLoc2C_3898)
		{
			error_printf("Error: 'nogap option'.  Calling program does not allow nogap option, or\nyou have exceeded maximum number of input files for the nogap option\n");
			*dwArg1C = ~0x00;
			eax_131 = ~0x00;
			goto l08052912;
		}
		strncpy(dwArg18[dwLoc2C_3898], dwArg0C[v7_40], 0x1001);
		++dwLoc2C_3898;
		dwLoc14_3892 = 0x01;
	}
	if (dwLoc14_3892 == 0x00)
	{
		usage(g_ptr805BCE8, eax_15);
		eax_131 = ~0x00;
	}
	else
	{
		if (dwArg10->u0 == 0x2D)
		{
			int32 eax_3563 = silent;
			if (eax_3563 <= 0x00)
				eax_3563 = 0x01;
			silent = eax_3563;
		}
		if (*dwArg14 == 0x00 && dwLoc2C_3898 == 0x00)
		{
			if (dwArg10->u0 == 0x2D)
				memcpy(dwArg14, &g_v8059645, 0x02);
			else
			{
				strncpy(dwArg14, dwArg10, 0x0FFD);
				if (lame_get_decode_only(dwArg04, dwArg14, dwArg10, 0x0FFD) != 0x00)
					strcat(dwArg14, ".wav");
				else
					strcat(dwArg14, ".mp3");
			}
		}
		if (dwLoc30_3899 == 0x00)
			lame_set_findReplayGain(dwArg04, 0x01);
		if (dwLoc20_3894 != 0x00 && (lame_get_bWriteVbrTag(dwArg04) != 0x00 && dwLoc24_3895 == 0x00))
		{
			console_printf("Note: Disabling VBR Xing/Info tag since it interferes with --nogap\n");
			lame_set_bWriteVbrTag(dwArg04, 0x00);
		}
		if (*dwArg14 == 0x2D)
			lame_set_bWriteVbrTag(dwArg04, 0x00);
		if (input_format.u0 == 0x00)
			input_format.u0 = (int32) filename_to_type(dwArg10);
		if (input_format.u0 == 0x08)
		{
			error_printf("sorry, vorbis support in LAME is deprecated.\n");
			eax_131 = ~0x00;
		}
		else
		{
			if (dwLoc1C_3893 != 0x00)
				lame_set_num_channels(dwArg04, 0x02);
			else if (lame_get_mode(dwArg04) == 0x03)
				lame_set_num_channels(dwArg04, 0x01);
			else
				lame_set_num_channels(dwArg04, 0x02);
			if (lame_get_free_format(dwArg04) != 0x00 && (lame_get_brate(dwArg04) <= 0x07 || lame_get_brate(dwArg04) > 0x0280))
			{
				error_printf("For free format, specify a bitrate between 8 and 640 kbps\n");
				error_printf("with the -b <bitrate> option\n");
				eax_131 = ~0x00;
			}
			else
			{
				if (dwArg1C != null)
					*dwArg1C = dwLoc2C_3898;
				eax_131 = 0x00;
			}
		}
	}
l08052912:
	TopOut = Top_1880;
	return eax_131;
}

// 08052914: void ReadByte(Stack (ptr32 Eq_8656) dwArg04)
void ReadByte(FILE * dwArg04)
{
	(_IO_getc(dwArg04) & 0xFF & 0x80) == 0x00;
}

// 08052945: Register ui32 Read16BitsLowHigh(Stack (ptr32 Eq_2112) dwArg04)
// Called from:
//      parse_wave_header
//      Read32Bits
ui32 Read16BitsLowHigh(FILE * dwArg04)
{
	ui32 eax_21 = ((_IO_getc(dwArg04) & 0xFF) << 0x08) + (_IO_getc(dwArg04) & 0xFF);
	ui32 dwLoc18_44 = eax_21;
	if ((eax_21 & 0x8000) != 0x00)
		dwLoc18_44 = eax_21 - 0x00010000;
	return dwLoc18_44;
}

// 08052995: Register word16 Read16BitsHighLow(Stack (ptr32 Eq_2112) dwArg04)
// Called from:
//      parse_aiff_header
//      Read32BitsHighLow
word16 Read16BitsHighLow(FILE * dwArg04)
{
	ui32 eax_21 = ((_IO_getc(dwArg04) & 0xFF) << 0x08) + (_IO_getc(dwArg04) & 0xFF);
	ui32 dwLoc18_44 = eax_21;
	if ((eax_21 & 0x8000) != 0x00)
		dwLoc18_44 = eax_21 - 0x00010000;
	return (word16) dwLoc18_44;
}

// 080529E5: void Write8Bits(Stack (ptr32 Eq_8716) dwArg04, Stack byte bArg08)
void Write8Bits(_IO_FILE * dwArg04, byte bArg08)
{
	word32 dwArg08;
	_IO_putc((word32) (byte) dwArg08, dwArg04);
}

// 08052A02: void Write16BitsLowHigh(Stack (ptr32 Eq_211) dwArg04, Stack Eq_218 dwArg08)
// Called from:
//      lame_decoder
//      WriteWaveHeader
//      Write32Bits
//      Write32BitsLowHigh
void Write16BitsLowHigh(union Eq_211 * dwArg04, Eq_218 dwArg08)
{
	_IO_putc((word32) (byte) dwArg08, dwArg04);
	_IO_putc((word32) (byte) (dwArg08 >> 0x08), dwArg04);
}

// 08052A37: void Write16BitsHighLow(Stack (ptr32 Eq_8742) dwArg04, Stack Eq_8743 dwArg08)
// Called from:
//      Write32BitsHighLow
void Write16BitsHighLow(_IO_FILE * dwArg04, Eq_8743 dwArg08)
{
	_IO_putc((word32) (byte) (dwArg08 >> 0x08), dwArg04);
	_IO_putc((word32) (byte) dwArg08, dwArg04);
}

// 08052A6C: void Read24BitsHighLow(Stack (ptr32 Eq_8760) dwArg04)
void Read24BitsHighLow(FILE * dwArg04)
{
	(((_IO_getc(dwArg04) & 0xFF) << 0x10) + ((_IO_getc(dwArg04) & 0xFF) << 0x08) + (_IO_getc(dwArg04) & 0xFF) & 0x00800000) == 0x00;
}

// 08052ADA: void Read32Bits(Stack (ptr32 Eq_2112) dwArg04)
// Called from:
//      parse_wave_header
void Read32Bits(FILE * dwArg04)
{
	Read16BitsLowHigh(dwArg04);
	Read16BitsLowHigh(dwArg04);
}

// 08052B17: void Read32BitsHighLow(Stack (ptr32 Eq_2112) dwArg04)
// Called from:
//      parse_wave_header
//      parse_aiff_header
//      parse_file_header
void Read32BitsHighLow(FILE * dwArg04)
{
	Read16BitsHighLow(dwArg04);
	Read16BitsHighLow(dwArg04);
}

// 08052B54: void Write32Bits(Stack (ptr32 Eq_211) dwArg04, Stack uint32 dwArg08)
void Write32Bits(union Eq_211 * dwArg04, uint32 dwArg08)
{
	Write16BitsLowHigh(dwArg04, dwArg08 & 0xFFFF);
	Write16BitsLowHigh(dwArg04, dwArg08 >> 0x10);
}

// 08052B88: void Write32BitsLowHigh(Stack (ptr32 Eq_211) dwArg04, Stack Eq_381 dwArg08)
// Called from:
//      WriteWaveHeader
void Write32BitsLowHigh(union Eq_211 * dwArg04, Eq_381 dwArg08)
{
	Write16BitsLowHigh(dwArg04, dwArg08 & 0xFFFF);
	Write16BitsLowHigh(dwArg04, dwArg08 >> 0x10);
}

// 08052BBC: void Write32BitsHighLow(Stack (ptr32 Eq_8742) dwArg04, Stack uint32 dwArg08)
void Write32BitsHighLow(_IO_FILE * dwArg04, uint32 dwArg08)
{
	Write16BitsHighLow(dwArg04, dwArg08 >> 0x10);
	Write16BitsHighLow(dwArg04, dwArg08 & 0xFFFF);
}

// 08052BF0: void ReadBytes(Register word24 edx_24_8, Stack (ptr32 Eq_2112) dwArg04, Stack (ptr32 Eq_8828) dwArg08, Stack int32 dwArg0C)
// Called from:
//      ReadIeeeExtendedHighLow
void ReadBytes(word24 edx_24_8, FILE * dwArg04, union Eq_8828 * dwArg08, int32 dwArg0C)
{
	while (true)
	{
		int32 eax_15 = feof(dwArg04);
		--dwArg0C;
		if (((int8) (dwArg0C > 0x00) & (int8) (eax_15 == 0x00)) == 0x00)
			break;
		int32 eax_36 = _IO_getc(dwArg04);
		dwArg08->u0 = (byte) eax_36;
		dwArg08 = (union Eq_8828 *) ((char *) dwArg08 + 1);
	}
}

// 08052C31: void ReadBytesSwapped(Register word24 edx_24_8, Stack (ptr32 Eq_8858) dwArg04, Stack (ptr32 byte) dwArg08, Stack int32 dwArg0C)
void ReadBytesSwapped(word24 edx_24_8, FILE * dwArg04, byte * dwArg08, int32 dwArg0C)
{
	byte * ebx_13 = dwArg08;
	while (true)
	{
		int32 eax_19 = feof(dwArg04);
		--dwArg0C;
		if (((int8) (dwArg0C > 0x00) & (int8) (eax_19 == 0x00)) == 0x00)
			break;
		*ebx_13 = (byte) _IO_getc(dwArg04);
		++ebx_13;
	}
	byte * ebx_46 = ebx_13 - 0x01;
	while (dwArg08 < ebx_46)
	{
		int32 eax_56 = (int32) *dwArg08;
		*dwArg08 = *ebx_46;
		*ebx_46 = (byte) eax_56;
		++dwArg08;
		--ebx_46;
	}
}

// 08052C9E: void WriteBytes(Stack (ptr32 Eq_8911) dwArg04, Stack (ptr32 byte) dwArg08, Stack int32 dwArg0C)
void WriteBytes(_IO_FILE * dwArg04, byte * dwArg08, int32 dwArg0C)
{
	while (true)
	{
		--dwArg0C;
		if ((int8) (dwArg0C > 0x00) == 0x00)
			break;
		_IO_putc((int32) *dwArg08, dwArg04);
		++dwArg08;
	}
}

// 08052CD3: void WriteBytesSwapped(Stack (ptr32 Eq_211) dwArg04, Stack ptr32 dwArg08, Stack int32 dwArg0C)
// Called from:
//      lame_decoder
void WriteBytesSwapped(union Eq_211 * dwArg04, ptr32 dwArg08, int32 dwArg0C)
{
	byte * dwArg08_43 = dwArg08 + (dwArg0C - 0x01);
	while (true)
	{
		--dwArg0C;
		if ((int8) (dwArg0C > 0x00) == 0x00)
			break;
		_IO_putc((int32) *dwArg08_43, dwArg04);
		--dwArg08_43;
	}
}

// 08052D11: Register (ptr8 Eq_3417) ConvertFromIeeeExtended(Stack (ptr32 Eq_8955) dwArg04, FpuStack real64 rArg0, FpuStack Eq_3417 rArg1, FpuStack out Eq_3417 rArg1Out)
// Called from:
//      ReadIeeeExtendedHighLow
union Eq_3417 * ConvertFromIeeeExtended(struct Eq_8955 * dwArg04, real64 rArg0, Eq_3417 rArg1, union Eq_3417 & rArg1Out)
{
	Eq_3417 rLoc24_205;
	int8 Top_145;
	ui32 eax_22 = (int32) dwArg04->b0001 & 0xFF | ((int32) dwArg04->b0000 & 0x7F) << 0x08;
	ui32 eax_53 = (int32) dwArg04->b0005 & 0xFF | (((int32) dwArg04->b0002 << 0x18 | ((int32) dwArg04->b0003 & 0xFF) << 0x10) | (int32) dwArg04->b0004 << 0x08 & 0xFFFF);
	ui32 eax_84 = (int32) dwArg04->b0009 & 0xFF | (((int32) dwArg04->b0006 << 0x18 | ((int32) dwArg04->b0007 & 0xFF) << 0x10) | (int32) dwArg04->b0008 << 0x08 & 0xFFFF);
	if (eax_22 == 0x00 && (eax_53 == 0x00 && eax_84 == 0x00))
	{
		rLoc24_205.u0 = 0.0;
		Top_145 = 0x00;
	}
	else if (eax_22 == 0x7FFF)
	{
		rLoc24_205.u0 = g_t8059868.u0;
		Top_145 = 0x00;
	}
	else
	{
		ldexp((real64) (eax_53 - 0x80000000) + 2147483648.0, eax_22 - 16414, eax_53 - 0x80000000, eax_22 - 16414, eax_22 - 0x3FFF);
		ldexp((real64) (eax_84 - 0x80000000) + 2147483648.0, eax_22 - 16446, eax_84 - 0x80000000, rArg0, eax_22 - 16446);
		rArg1 += rArg0;
		rLoc24_205 = rArg1;
		Top_145 = 0x02;
	}
	union Eq_3417 * Top_164;
	if (dwArg04->b0000 < 0x00)
	{
		Top_164 = Top_145 - 1;
		Top_164->u0 = (real64) rLoc24_205;
		Top_164->u0 = (real64) -Top_164->u0;
	}
	else
	{
		Top_164 = Top_145 - 1;
		Top_164->u0 = (real64) rLoc24_205;
	}
	rArg1Out = rArg1;
	return Top_164;
}

// 08052E8B: Register (ptr8 Eq_9106) ReadIeeeExtendedHighLow(Register word24 edx_24_8, Register (ptr32 Eq_159) gs, Stack (ptr32 Eq_2112) dwArg04, FpuStack real64 rArg0, FpuStack Eq_3417 rArg1)
// Called from:
//      parse_aiff_header
struct Eq_9106 * ReadIeeeExtendedHighLow(word24 edx_24_8, struct Eq_159 * gs, FILE * dwArg04, real64 rArg0, Eq_3417 rArg1)
{
	Eq_9107 tLoc1A;
	word32 eax_12 = gs->dw0014;
	ReadBytes(edx_24_8, dwArg04, &tLoc1A, 0x0A);
	word64 rRet1_42;
	struct Eq_9106 * Top_36 = ConvertFromIeeeExtended(&tLoc1A, rArg0, rArg1, out rRet1_42);
	Top_36->qw0001 = rRet1_42;
	if ((eax_12 ^ gs->dw0014) == 0x00)
		return Top_36;
	Top_36->r0000 = Top_36->r0000;
	__stack_chk_fail();
}

// 08052EDC: void ts_calc_times(Stack (ptr32 Eq_9142) dwArg04, Stack int32 dwArg08, Stack int32 dwArg0C, Stack int32 dwArg10, Stack int32 dwArg14)
// Called from:
//      timestatus
void ts_calc_times(struct Eq_9142 * dwArg04, int32 dwArg08, int32 dwArg0C, int32 dwArg10, int32 dwArg14)
{
	if (dwArg0C > 0x00 && (int8) ((dwArg04->t0008).u0 > 0.0) != 0x00)
	{
		dwArg04->r0010 = dwArg04->t0008.u0 * (real64) dwArg10 / (real64) dwArg0C;
		dwArg04->r0018 = (real64) (dwArg14 *s dwArg0C) / ((real64) dwArg08 * (dwArg04->t0008).u0);
	}
	else
	{
		dwArg04->r0010 = 0.0;
		dwArg04->r0018 = 0.0;
	}
}

// 08052F47: void ts_time_decompose(Stack uint32 dwArg04)
// Called from:
//      timestatus
void ts_time_decompose(uint32 dwArg04)
{
	uint32 edx_17 = SLICE(dwArg04 *64 2443359173, word32, 32);
	if (edx_17 >> 11 == 0x00)
		console_printf("   %2u:%02u%c");
	else if (edx_17 >> 11 <= 99)
		console_printf("%2lu:%02u:%02u%c");
	else
		console_printf("%6lu h%c");
}

// 0805303F: void timestatus(Stack (ptr32 Eq_67) dwArg04)
// Called from:
//      encoder_progress
//      encoder_progress_end
void timestatus(FILE * dwArg04)
{
	int32 eax_12 = lame_get_out_samplerate(dwArg04);
	int32 eax_18 = lame_get_frameNum(dwArg04, eax_12);
	int32 eax_24 = lame_get_totalframes(dwArg04, eax_18);
	int32 dwLoc1C_441 = eax_24;
	int32 eax_30 = lame_get_framesize(dwArg04);
	if (eax_24 < eax_18)
		dwLoc1C_441 = eax_18;
	if (eax_18 == 0x00)
	{
		g_r805B420 = GetRealTime();
		g_r805B440 = GetCPUTime();
		g_r805B428 = 0.0;
		g_r805B448 = 0.0;
	}
	real64 rRet0_77 = GetRealTime();
	Eq_9232 rLoc1_455 = rRet0_77 - g_r805B420;
	Eq_9232 rLoc34_456 = rLoc1_455;
	if ((int8) (rLoc1_455 < 0.0) != 0x00)
		rLoc34_456.u0 = 0.0;
	g_r805B428 += rLoc34_456;
	g_r805B420 = rRet0_77;
	real64 rRet0_127 = GetCPUTime();
	Eq_9263 rLoc1_471 = rRet0_127 - g_r805B440;
	Eq_9263 rLoc34_472 = rLoc1_471;
	if ((int8) (rLoc1_471 < 0.0) != 0x00)
		rLoc34_472.u0 = 0.0;
	g_r805B448 += rLoc34_472;
	g_r805B440 = rRet0_127;
	if (eax_18 == 0x00 && init.3108 == 0x00)
	{
		console_printf("\r    Frame          |  CPU time/estim | REAL time/estim | play/CPU |    ETA \n     0/       ( 0%%)|    0:00/     :  |    0:00/     :  |         x|     :  \r");
		init.3108 = 0x01;
	}
	else
	{
		if (eax_18 > 0x00)
			init.3108 = 0x00;
		int32 dwLoc10_516;
		ts_calc_times(&g_r805B420, eax_12, eax_18, dwLoc1C_441, eax_30);
		ts_calc_times(&g_r805B440, eax_12, eax_18, dwLoc1C_441, eax_30);
		if (eax_18 < dwLoc1C_441)
		{
			real64 rLoc1_523 = (real64) eax_18 * 100.0 / (real64) dwLoc1C_441 + 0.5;
			Eq_559 wLoc3E_524 = __fstcw();
			__fldcw(SEQ(0x0C, (byte) wLoc3E_524));
			__fldcw(wLoc3E_524);
			dwLoc10_516 = (int32) rLoc1_523;
		}
		else
			dwLoc10_516 = 100;
		char * eax_263;
		console_printf("\r%6i/%-6i");
		if (dwLoc10_516 <= 99)
			eax_263 = (char *) " (%2d%%)|";
		else
			eax_263 = (char *) "(%3.3d%%)|";
		char * eax_379;
		console_printf(eax_263);
		real64 rLoc1_536 = g_r805B448;
		Eq_559 wLoc3E_537 = __fstcw();
		__fldcw(SEQ(0x0C, (byte) wLoc3E_537));
		__fldcw(wLoc3E_537);
		ts_time_decompose((word32) rLoc1_536);
		real64 rLoc1_544 = g_r805B450;
		Eq_559 wLoc3E_545 = __fstcw();
		__fldcw(SEQ(0x0C, (byte) wLoc3E_545));
		__fldcw(wLoc3E_545);
		ts_time_decompose((word32) rLoc1_544);
		real64 rLoc1_552 = g_r805B428;
		Eq_559 wLoc3E_553 = __fstcw();
		__fldcw(SEQ(0x0C, (byte) wLoc3E_553));
		__fldcw(wLoc3E_553);
		ts_time_decompose((word32) rLoc1_552);
		real64 rLoc1_560 = g_r805B430;
		Eq_559 wLoc3E_561 = __fstcw();
		__fldcw(SEQ(0x0C, (byte) wLoc3E_561));
		__fldcw(wLoc3E_561);
		ts_time_decompose((word32) rLoc1_560);
		if ((int8) (g_t805B458.u0 <= 1.0) != 0x00)
			eax_379 = (char *) "%9.4fx|";
		else
			eax_379 = (char *) "%#9.5gx|";
		console_printf(eax_379);
		real64 rLoc1_577 = g_r805B430 - g_r805B428;
		Eq_559 wLoc3E_578 = __fstcw();
		__fldcw(SEQ(0x0C, (byte) wLoc3E_578));
		__fldcw(wLoc3E_578);
		ts_time_decompose((word32) rLoc1_577);
	}
}

// 08053376: void timestatus_finish()
// Called from:
//      encoder_progress_end
void timestatus_finish()
{
	console_printf("\n");
}

// 0805338A: Register int8 encoder_progress_begin(Stack (ptr32 Eq_67) dwArg04, Stack (ptr32 Eq_838) dwArg08, Stack (ptr32 char) dwArg0C, FpuStack real64 rArg0, FpuStack out Eq_684 rArg0Out)
// Called from:
//      lame_encoder
int8 encoder_progress_begin(FILE * dwArg04, union Eq_838 * dwArg08, char * dwArg0C, real64 rArg0, union Eq_684 & rArg0Out)
{
	int8 Top_3 = 0;
	if (silent > 0x09)
	{
l080537B6:
		rArg0Out.u0 = <invalid>;
		return Top_3;
	}
	lame_print_config(dwArg04);
	strcmp(dwArg0C, "-") == 0x00;
	strlen(dwArg08) + strlen(dwArg0C) >u 0x41;
	strcmp(dwArg08, "-") == 0x00;
	console_printf("Encoding %s%s to %s\n");
	lame_get_out_samplerate(dwArg04);
	console_printf("Encoding as %g kHz ");
	up32 eax_110 = lame_get_VBR(dwArg04);
	if (eax_110 == 0x02)
	{
		lame_get_quality(dwArg04);
		lame_get_VBR_quality(dwArg04);
		lame_get_out_samplerate(dwArg04, rArg0) > 15999;
		lame_get_force_ms(dwArg04, 0x02 - lame_get_version(dwArg04));
		lame_get_mode(dwArg04);
		console_printf("%s MPEG-%u%s Layer III VBR(q=%g) qval=%i\n");
		goto l080537A1;
	}
	if (eax_110 <= 0x02)
	{
		if (eax_110 != 0x01)
			goto l080536B6;
	}
	else
	{
		if (eax_110 == 0x03)
		{
			lame_get_quality(dwArg04);
			lame_get_compression_ratio(dwArg04, lame_get_VBR_mean_bitrate_kbps(dwArg04));
			real64 rArg0_584 = rArg0 * 10.0 + 0.5;
			Eq_559 wLoc1E_585 = __fstcw();
			__fldcw(SEQ(0x0C, (byte) wLoc1E_585));
			__fldcw(wLoc1E_585);
			int32 dwLoc24_587 = (int32) rArg0_584;
			lame_get_out_samplerate(dwArg04, (real64) dwLoc24_587 * 0.1, dwLoc24_587) > 15999;
			lame_get_force_ms(dwArg04, 0x02 - lame_get_version(dwArg04));
			lame_get_mode(dwArg04);
			console_printf("%s MPEG-%u%s Layer III (%gx) average %d kbps qval=%i\n");
l080537A1:
			Top_3 = 1;
			if (silent < ~0x08)
				lame_print_internals(dwArg04);
			goto l080537B6;
		}
		if (eax_110 != 0x04)
		{
l080536B6:
			lame_get_quality(dwArg04);
			lame_get_compression_ratio(dwArg04, lame_get_brate(dwArg04));
			real64 rArg0_642 = rArg0 * 10.0 + 0.5;
			Eq_559 wLoc1E_643 = __fstcw();
			__fldcw(SEQ(0x0C, (byte) wLoc1E_643));
			__fldcw(wLoc1E_643);
			int32 dwLoc24_645 = (int32) rArg0_642;
			lame_get_out_samplerate(dwArg04, (real64) dwLoc24_645 * 0.1, dwLoc24_645) > 15999;
			lame_get_force_ms(dwArg04, 0x02 - lame_get_version(dwArg04));
			lame_get_mode(dwArg04);
			console_printf("%s MPEG-%u%s Layer III (%gx) %3d kbps qval=%i\n");
			goto l080537A1;
		}
	}
	lame_get_VBR_quality(dwArg04);
	lame_get_out_samplerate(dwArg04, rArg0) > 15999;
	lame_get_version(dwArg04);
	lame_get_force_ms(dwArg04);
	lame_get_mode(dwArg04);
	console_printf("%s MPEG-%u%s Layer III VBR(q=%g)\n");
	goto l080537A1;
}

// 080537BE: void encoder_progress(Register (ptr32 Eq_159) gs, Stack (ptr32 Eq_67) dwArg04)
// Called from:
//      lame_encoder
void encoder_progress(struct Eq_159 * gs, FILE * dwArg04)
{
	if (silent > 0x00)
		return;
	int32 eax_20 = lame_get_frameNum(dwArg04);
	if ((int8) ((real64) update_interval <= 0.0) != 0x00)
	{
		if (eax_20 != ((SLICE(eax_20 *s64 1374389535, word32, 32) >> 0x05) - (eax_20 >> 0x1F)) *s 100)
			return;
	}
	else
	{
		if (eax_20 != 0x00 && eax_20 != 0x09)
		{
			Eq_9691 rLoc1_201 = GetRealTime() - g_r805B408;
			if ((int8) (rLoc1_201 >= 0.0) != 0x00 && (int8) ((real64) update_interval > rLoc1_201) != 0x00)
				return;
		}
		g_r805B408 = GetRealTime();
	}
	if (brhist != 0x00)
		brhist_jump_back();
	timestatus(dwArg04);
	if (brhist != 0x00)
		brhist_disp(gs, dwArg04);
	console_flush();
}

// 080538AF: void encoder_progress_end(Register (ptr32 Eq_159) gs, Stack (ptr32 Eq_67) dwArg04)
// Called from:
//      lame_encoder
void encoder_progress_end(struct Eq_159 * gs, FILE * dwArg04)
{
	if (silent <= 0x00)
	{
		if (brhist != 0x00)
			brhist_jump_back();
		timestatus(dwArg04);
		if (brhist != 0x00)
			brhist_disp(gs, dwArg04);
		timestatus_finish();
	}
}

// 080538F2: void decoder_progress(Stack (ptr32 Eq_448) dwArg04)
// Called from:
//      lame_decoder
void decoder_progress(struct Eq_448 * dwArg04)
{
	console_printf("\rFrame#%6i/%-6i %3i kbps");
	if (dwArg04->dw0010 == 0x01)
	{
		ui32 eax_37 = dwArg04->dw0014;
		console_printf("  %s  %c");
		last.3337 = eax_37;
	}
	else
	{
		console_printf("         ");
		last.3337 = 0x00;
	}
	console_printf("        \b\b\b\b\b\b\b\b");
}

// 080539F8: void decoder_progress_finish()
// Called from:
//      lame_decoder
void decoder_progress_finish()
{
	console_printf("\n");
}

// 08053A0C: Register int32 calculate_index(Stack (arr word32) dwArg04, Stack int32 dwArg08, Stack word32 dwArg0C)
// Called from:
//      brhist_init
int32 calculate_index(word32 dwArg04[], int32 dwArg08, word32 dwArg0C)
{
	int32 dwLoc08_33 = 0x00;
	while (true)
	{
		int32 eax_25;
		if (dwLoc08_33 >= dwArg08)
			break;
		if (dwArg04[dwLoc08_33] == dwArg0C)
		{
			eax_25 = dwLoc08_33;
			return eax_25;
		}
		++dwLoc08_33;
	}
	eax_25 = ~0x00;
	return eax_25;
}

// 08053A43: Register word32 brhist_init(Stack (ptr32 Eq_67) dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C)
// Called from:
//      brhist_init_package
word32 brhist_init(FILE * dwArg04, word32 dwArg08, word32 dwArg0C)
{
	word32 eax_112;
	g_dw805B4C0 = 0x00;
	lame_bitrate_kbps(dwArg04, 0x0805B488);
	g_dw805B480 = calculate_index(g_a805B488, 0x0E, dwArg08);
	g_dw805B484 = calculate_index(g_a805B488, 0x0E, dwArg0C);
	if (g_dw805B480 <= 0x0D && g_dw805B484 <= 0x0D)
	{
		memset(&g_v805B4C4, 0x2A, 0x0200);
		memset(&g_v805B6C5, 0x25, 0x0200);
		memset(&g_v805BAC7, 0x2D, 0x0200);
		memset(&g_v805B8C6, 0x2D, 0x0200);
		eax_112 = 0x00;
	}
	else
	{
		error_printf("lame internal error: VBR min %d kbps or VBR max %d kbps not allowed.\n");
		eax_112 = ~0x00;
	}
	return eax_112;
}

// 08053B52: Register word32 digits(Stack Eq_9874 qwArg04)
// Called from:
//      brhist_disp_line
//      progress_line
word32 digits(Eq_9874 qwArg04)
{
	uint32 dwArg04;
	word32 dwLoc08_70 = 0x01;
	if (dwArg04 > 99999999)
	{
		dwLoc08_70 = 0x09;
		dwArg04 = SLICE(dwArg04 *64 1441151881, word32, 32) >> 0x19;
	}
	if (dwArg04 > 9999)
	{
		dwLoc08_70 += 0x04;
		dwArg04 = SLICE(dwArg04 *64 ~0x2E48E8A6, word32, 32) >> 0x0D;
	}
	if (dwArg04 > 99)
	{
		dwLoc08_70 += 0x02;
		dwArg04 = SLICE(dwArg04 *64 1374389535, word32, 32) >> 0x05;
	}
	if (dwArg04 > 0x09)
		++dwLoc08_70;
	return dwLoc08_70;
}

// 08053BDA: void brhist_disp_line(Register (ptr32 Eq_159) gs, Stack int32 dwArg10, Stack Eq_9874 dwArg14)
// Called from:
//      brhist_disp
void brhist_disp_line(struct Eq_159 * gs, int32 dwArg10, Eq_9874 dwArg14)
{
	char bLoc1E;
	Eq_9912 tLoc64;
	word32 eax_10 = gs->dw0014;
	digits(dwArg14);
	digits(dwArg14);
	sprintf(&bLoc1E, " [%*i]", tLoc64);
	if (g_b805BD06 != 0x00)
		console_printf("\n%3d%s %.*s%.*s%s");
	else
		console_printf("\n%3d%s %.*s%.*s%*s");
	++g_dw805B4C0;
	if ((eax_10 ^ gs->dw0014) == 0x00)
		return;
	__stack_chk_fail();
}

// 08053D7C: void progress_line(Register (ptr32 Eq_159) gs, Stack (ptr32 Eq_67) dwArg04, Stack Eq_9874 dwArg08, Stack Eq_9874 dwArg0C)
// Called from:
//      brhist_disp
void progress_line(struct Eq_159 * gs, FILE * dwArg04, Eq_9874 dwArg08, Eq_9874 dwArg0C)
{
	char bLoc24;
	Eq_9962 tLoc84;
	word32 eax_12 = gs->dw0014;
	bLoc24 = (char) g_w8059BBD;
	word32 eax_34 = lame_get_framesize(dwArg04, dwArg04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, eax_12);
	real32 dwLoc38_326 = 0.0F;
	int32 eax_41 = lame_get_out_samplerate(dwArg04, eax_34);
	if (dwArg08 < dwArg0C)
		dwArg08 = dwArg0C;
	if (eax_41 > 0x00)
		dwLoc38_326 = (real32) ((real64) eax_34 * (real64) (dwArg08 - dwArg0C) / (real64) eax_41);
	real64 rLoc1_353 = (real64) dwLoc38_326 / (real64) 3600.0F;
	Eq_559 wLoc52_354 = __fstcw();
	Eq_559 ax_96 = SEQ(0x0C, (byte) wLoc52_354);
	__fldcw(ax_96);
	__fldcw(wLoc52_354);
	Eq_9874 dwLoc5C_357 = (word32) rLoc1_353;
	real32 dwLoc38_366 = (real32) ((real64) dwLoc38_326 - (real64) ((uint64) (dwLoc5C_357 *s32 0x0E10)));
	real64 rLoc1_369 = (real64) dwLoc38_366 / (real64) 60.0F;
	__fldcw(ax_96);
	__fldcw(wLoc52_354);
	__fldcw(ax_96);
	__fldcw(wLoc52_354);
	uint32 dwLoc5C_371 = (word32) rLoc1_369;
	uint32 dwLoc5C_383 = (word32) ((real64) dwLoc38_366 - (real64) ((uint64) (dwLoc5C_371 * 0x3C)));
	if (dwArg08 != 0x00)
	{
		int32 dwLoc34_396;
		if (dwLoc5C_357 != 0x00)
		{
			sprintf(&bLoc24, "%*d:%02u:%02u", tLoc84, digits(dwLoc5C_357), dwLoc5C_357);
			dwLoc34_396 = digits(dwLoc5C_357) + 0x07;
		}
		else
		{
			sprintf(&bLoc24, "%02u:%02u", dwLoc5C_371, dwLoc5C_383);
			dwLoc34_396 = 0x06;
		}
		Eq_10080 eax_210 = (g_dw805BCF4 - dwLoc34_396 + 0x01) *s32 dwArg08;
		Eq_10087 eax_222 = (word32) dwArg08.u0 + (g_dw805BCF4 - dwLoc34_396) *s32 dwArg0C;
		if (SEQ(eax_210 - 0x01 >> 0x1F, eax_210 - 0x01) /32 dwArg08 == SEQ(eax_222 - 0x01 >> 0x1F, eax_222 - 0x01) /32 dwArg08)
			sprintf(&bLoc24, "%.*s", tLoc84);
	}
	if (g_b805BD06 != 0x00)
		console_printf("\n%.*s%s%.*s%s");
	else
		console_printf("\n%.*s%s%.*s%*s");
	++g_dw805B4C0;
	if ((eax_12 ^ gs->dw0014) == 0x00)
		return;
	__stack_chk_fail();
}

// 0805409D: void stats_value(Stack Eq_10135 qwArg04)
// Called from:
//      stats_line
void stats_value(Eq_10135 qwArg04)
{
	if ((int8) (qwArg04 > 0.0) != 0x00)
		console_printf(" %5.1f");
}

// 080540E2: void stats_head(Stack Eq_10135 qwArg04, Stack (ptr32 char) dwArg0C)
// Called from:
//      stats_line
void stats_head(Eq_10135 qwArg04, char * dwArg0C)
{
	if ((int8) (qwArg04 > 0.0) != 0x00)
		console_printf(dwArg0C);
}

// 0805411F: void stats_line(Stack (ptr32 Eq_10153) dwArg04)
// Called from:
//      brhist_disp
void stats_line(struct Eq_10153 * dwArg04)
{
	console_printf("\n   kbps     ");
	stats_head(dwArg04->t0008.u0, "  mono");
	stats_head(dwArg04->t0010.u0, "   IS ");
	stats_head(dwArg04->t0018.u0, "   LR ");
	stats_head(dwArg04->t0020.u0, "   MS ");
	console_printf(" %%    ");
	stats_head(dwArg04->t0028.u0, " long ");
	stats_head(dwArg04->t0030.u0, "switch");
	stats_head(dwArg04->t0038.u0, " short");
	stats_head(dwArg04->t0040.u0, " mixed");
	console_printf(" %%");
	if (g_b805BD06 != 0x00)
		console_printf("%s");
	else
		console_printf("%*s");
	++g_dw805B4C0;
	console_printf("\n  %5.1f     ");
	stats_value(dwArg04->t0008.u0);
	stats_value(dwArg04->t0010.u0);
	stats_value(dwArg04->t0018.u0);
	stats_value(dwArg04->t0020.u0);
	console_printf("      ");
	stats_value(dwArg04->t0028.u0);
	stats_value(dwArg04->t0030.u0);
	stats_value(dwArg04->t0038.u0);
	stats_value(dwArg04->t0040.u0);
	if (g_b805BD06 != 0x00)
		console_printf("%s");
	else
		console_printf("%*s");
	++g_dw805B4C0;
}

// 08054399: void brhist_disp(Register (ptr32 Eq_159) gs, Stack (ptr32 Eq_67) dwArg04)
// Called from:
//      encoder_progress
//      encoder_progress_end
void brhist_disp(struct Eq_159 * gs, FILE * dwArg04)
{
	ptr32 fp;
	Eq_10286 tLocD4;
	word32 dwLoc3C;
	word32 dwLoc34;
	int32 dwLoc40;
	word32 dwLoc54;
	word32 dwLoc50;
	word32 dwLoc48;
	word32 dwLoc4C;
	word32 dwLoc44;
	int32 dwLoc14_432 = 0x00;
	real64 rLoc2C_434 = 0.0;
	union Eq_10299 * edi_24 = &tLocD4;
	word32 ecx_25;
	for (ecx_25 = 0x12; ecx_25 != 0x00; --ecx_25)
	{
		edi_24->u0 = 0x00;
		edi_24 = (union Eq_10299 *) ((char *) edi_24 + 4);
	}
	g_dw805B4C0 = 0x00;
	lame_bitrate_stereo_mode_hist(dwArg04, fp - 0x01B4);
	lame_bitrate_hist(dwArg04, fp - 0x8C);
	lame_stereo_mode_hist(dwArg04, fp - 60);
	lame_block_type_hist(dwArg04, fp - 84);
	int32 dwLoc20_435 = 0x00;
	int32 dwLoc1C_446 = 0x00;
	Eq_9874 dwLoc18_447 = 0x00;
	int32 dwLoc10_448;
	for (dwLoc10_448 = 0x00; dwLoc10_448 <= 0x0D; ++dwLoc10_448)
	{
		dwLoc18_447 = (word32) dwLoc18_447.u0 + (fp - 0x8C)[dwLoc10_448];
		rLoc2C_434 = (real64) (g_a805B488[dwLoc10_448 * 0x04] *s (fp - 0x8C)[dwLoc10_448]) + rLoc2C_434;
		if ((fp - 0x8C)[dwLoc10_448] > dwLoc1C_446)
			dwLoc1C_446 = (fp - 0x8C)[dwLoc10_448];
		if ((fp - 0x8C)[dwLoc10_448] != 0x00)
			++dwLoc14_432;
	}
	int32 dwLoc10_466;
	for (dwLoc10_466 = 0x00; dwLoc10_466 <= 0x0D; ++dwLoc10_466)
	{
		word32 eax_128;
		if ((fp - 0x8C)[dwLoc10_466] != 0x00 && dwLoc14_432 > 0x01)
			eax_128 = 0x01;
		else
			eax_128 = 0x00;
		if (eax_128 != 0x00 || g_dw805B480 <= dwLoc10_466 && g_dw805B484 >= dwLoc10_466)
			brhist_disp_line(gs, dwLoc1C_446, dwLoc18_447);
	}
	int32 dwLoc10_489;
	for (dwLoc10_489 = 0x00; dwLoc10_489 <= 0x03; ++dwLoc10_489)
		dwLoc20_435 += (fp - 60)[dwLoc10_489];
	if (dwLoc18_447 > 0x00)
	{
		tLocD4.r0000 = rLoc2C_434 / (real64) dwLoc18_447;
		tLocD4.r0008 = (real64) (dwLoc18_447 - dwLoc20_435) * 100.0 / (real64) dwLoc18_447;
	}
	if (dwLoc20_435 > 0x00)
	{
		tLocD4.r0010 = 0.0;
		tLocD4.r0018 = (real64) dwLoc3C * 100.0 / (real64) dwLoc20_435;
		tLocD4.r0020 = (real64) dwLoc34 * 100.0 / (real64) dwLoc20_435;
	}
	if (dwLoc40 > 0x00)
	{
		tLocD4.r0028 = (real64) dwLoc54 * 100.0 / (real64) dwLoc40;
		tLocD4.r0030 = (real64) (dwLoc50 + dwLoc48) * 100.0 / (real64) dwLoc40;
		tLocD4.r0038 = (real64) dwLoc4C * 100.0 / (real64) dwLoc40;
		tLocD4.r0040 = (real64) dwLoc44 * 100.0 / (real64) dwLoc40;
	}
	progress_line(gs, dwArg04, lame_get_totalframes(dwArg04), dwLoc18_447);
	stats_line(&tLocD4);
}

// 080546F4: void brhist_jump_back()
// Called from:
//      encoder_progress
//      encoder_progress_end
void brhist_jump_back()
{
	console_up(g_dw805B4C0);
	g_dw805B4C0 = 0x00;
}

// 08054720: void __libc_csu_fini()
void __libc_csu_fini()
{
}

// 08054730: void __libc_csu_init(Stack word32 dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C)
void __libc_csu_init(word32 dwArg04, word32 dwArg08, word32 dwArg0C)
{
	_init();
	int32 edi_30 = &g_ptr805AEFC - &g_ptr805AEFC;
	if (edi_30 >> 0x02 != 0x00)
	{
		Eq_10536 esi_36 = 0x00;
		do
		{
			(*((char *) &g_ptr805AEFC + esi_36 * 0x04))();
			esi_36 = (word32) esi_36.u1 + 1;
		} while (esi_36 < edi_30 >> 0x02);
	}
}

// 0805478A: void __i686.get_pc_thunk.bx()
void __i686.get_pc_thunk.bx()
{
}

// 08054790: Register word32 stat64(Stack (ptr32 Eq_161) dwArg04, Stack ptr32 dwArg08)
// Called from:
//      lame_get_file_size
word32 stat64(union Eq_161 * dwArg04, ptr32 dwArg08)
{
	return __xstat64(0x03, dwArg04, dwArg08);
}

// 080547D0: Register word32 fstat64(Stack int32 dwArg04, Stack ptr32 dwArg08)
// Called from:
//      fskip
word32 fstat64(int32 dwArg04, ptr32 dwArg08)
{
	return __fxstat64(0x03, dwArg04, dwArg08);
}

// 08054810: void __do_global_ctors_aux()
// Called from:
//      _init
void __do_global_ctors_aux()
{
	<anonymous> * eax_12 = g_ptr805AEFC;
	if (eax_12 != (<anonymous> *) ~0x00)
	{
		word32 * ebx_15 = &g_ptr805AEFC;
		do
		{
			eax_12();
			ebx_15 -= 0x04;
			eax_12 = *ebx_15;
		} while (eax_12 != (<anonymous> *) ~0x00);
	}
}

