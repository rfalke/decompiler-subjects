typedef unsigned char   undefined;

typedef unsigned char    byte;
typedef unsigned char    dwfenc;
typedef unsigned int    dword;
typedef long double    longdouble;
typedef long long    longlong;
typedef unsigned char    uchar;
typedef unsigned int    uint;
typedef unsigned long    ulong;
typedef unsigned long long    ulonglong;
typedef unsigned char    undefined1;
typedef unsigned short    undefined2;
typedef unsigned int    undefined3;
typedef unsigned int    undefined4;
typedef unsigned long long    undefined5;
typedef unsigned long long    undefined6;
typedef unsigned long long    undefined7;
typedef unsigned long long    undefined8;
typedef unsigned short    ushort;
typedef unsigned short    word;
typedef struct eh_frame_hdr eh_frame_hdr, *Peh_frame_hdr;

struct eh_frame_hdr {
    byte eh_frame_hdr_version; // Exception Handler Frame Header Version
    dwfenc eh_frame_pointer_encoding; // Exception Handler Frame Pointer Encoding
    dwfenc eh_frame_desc_entry_count_encoding; // Encoding of # of Exception Handler FDEs
    dwfenc eh_frame_table_encoding; // Exception Handler Table Encoding
};

typedef struct fde_table_entry fde_table_entry, *Pfde_table_entry;

struct fde_table_entry {
    dword initial_loc; // Initial Location
    dword data_loc; // Data location
};

typedef ushort sa_family_t;

typedef struct termios termios, *Ptermios;

typedef uint tcflag_t;

typedef uchar cc_t;

typedef uint speed_t;

struct termios {
    tcflag_t c_iflag;
    tcflag_t c_oflag;
    tcflag_t c_cflag;
    tcflag_t c_lflag;
    cc_t c_line;
    cc_t c_cc[32];
    speed_t c_ispeed;
    speed_t c_ospeed;
};

typedef void _IO_lock_t;

typedef struct _IO_marker _IO_marker, *P_IO_marker;

typedef struct _IO_FILE _IO_FILE, *P_IO_FILE;

typedef long __off_t;

typedef longlong __quad_t;

typedef __quad_t __off64_t;

typedef ulong size_t;

struct _IO_FILE {
    int _flags;
    char * _IO_read_ptr;
    char * _IO_read_end;
    char * _IO_read_base;
    char * _IO_write_base;
    char * _IO_write_ptr;
    char * _IO_write_end;
    char * _IO_buf_base;
    char * _IO_buf_end;
    char * _IO_save_base;
    char * _IO_backup_base;
    char * _IO_save_end;
    struct _IO_marker * _markers;
    struct _IO_FILE * _chain;
    int _fileno;
    int _flags2;
    __off_t _old_offset;
    ushort _cur_column;
    char _vtable_offset;
    char _shortbuf[1];
    _IO_lock_t * _lock;
    __off64_t _offset;
    void * __pad1;
    void * __pad2;
    void * __pad3;
    void * __pad4;
    size_t __pad5;
    int _mode;
    char _unused2[56];
};

struct _IO_marker {
    struct _IO_marker * _next;
    struct _IO_FILE * _sbuf;
    int _pos;
};

typedef struct stat stat, *Pstat;

typedef ulonglong __u_quad_t;

typedef __u_quad_t __dev_t;

typedef ulong __ino_t;

typedef uint __mode_t;

typedef uint __nlink_t;

typedef uint __uid_t;

typedef uint __gid_t;

typedef long __blksize_t;

typedef long __blkcnt_t;

typedef struct timespec timespec, *Ptimespec;

typedef long __time_t;

struct timespec {
    __time_t tv_sec;
    long tv_nsec;
};

struct stat {
    __dev_t st_dev;
    ushort __pad1;
    __ino_t st_ino;
    __mode_t st_mode;
    __nlink_t st_nlink;
    __uid_t st_uid;
    __gid_t st_gid;
    __dev_t st_rdev;
    ushort __pad2;
    __off_t st_size;
    __blksize_t st_blksize;
    __blkcnt_t st_blocks;
    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
    ulong __unused4;
    ulong __unused5;
};

typedef struct addrinfo addrinfo, *Paddrinfo;

typedef uint __socklen_t;

typedef __socklen_t socklen_t;

typedef struct sockaddr sockaddr, *Psockaddr;

struct addrinfo {
    int ai_flags;
    int ai_family;
    int ai_socktype;
    int ai_protocol;
    socklen_t ai_addrlen;
    struct sockaddr * ai_addr;
    char * ai_canonname;
    struct addrinfo * ai_next;
};

struct sockaddr {
    sa_family_t sa_family;
    char sa_data[14];
};

typedef struct _IO_FILE FILE;

typedef int __jmp_buf[6];

typedef int __ssize_t;

typedef __ssize_t ssize_t;

typedef int __pid_t;

typedef long __suseconds_t;

typedef long __clock_t;

typedef struct hostent hostent, *Phostent;

struct hostent {
    char * h_name;
    char * * h_aliases;
    int h_addrtype;
    int h_length;
    char * * h_addr_list;
};

typedef struct passwd passwd, *Ppasswd;

struct passwd {
    char * pw_name;
    char * pw_passwd;
    __uid_t pw_uid;
    __gid_t pw_gid;
    char * pw_gecos;
    char * pw_dir;
    char * pw_shell;
};

typedef struct evp_pkey_ctx_st evp_pkey_ctx_st, *Pevp_pkey_ctx_st;

struct evp_pkey_ctx_st {
};

typedef struct evp_pkey_ctx_st EVP_PKEY_CTX;

typedef int nl_item;

typedef struct __dirstream __dirstream, *P__dirstream;

struct __dirstream {
};

typedef struct __dirstream DIR;

typedef struct dirent dirent, *Pdirent;

struct dirent {
    __ino_t d_ino;
    __off_t d_off;
    ushort d_reclen;
    uchar d_type;
    char d_name[256];
};

typedef struct utimbuf utimbuf, *Putimbuf;

struct utimbuf {
    __time_t actime;
    __time_t modtime;
};

typedef union sigval sigval, *Psigval;

typedef union sigval sigval_t;

union sigval {
    int sival_int;
    void * sival_ptr;
};

typedef struct siginfo siginfo, *Psiginfo;

typedef union _union_1028 _union_1028, *P_union_1028;

typedef struct _struct_1029 _struct_1029, *P_struct_1029;

typedef struct _struct_1030 _struct_1030, *P_struct_1030;

typedef struct _struct_1031 _struct_1031, *P_struct_1031;

typedef struct _struct_1032 _struct_1032, *P_struct_1032;

typedef struct _struct_1033 _struct_1033, *P_struct_1033;

typedef struct _struct_1034 _struct_1034, *P_struct_1034;

struct _struct_1034 {
    long si_band;
    int si_fd;
};

struct _struct_1033 {
    void * si_addr;
};

struct _struct_1032 {
    __pid_t si_pid;
    __uid_t si_uid;
    int si_status;
    __clock_t si_utime;
    __clock_t si_stime;
};

struct _struct_1031 {
    __pid_t si_pid;
    __uid_t si_uid;
    sigval_t si_sigval;
};

struct _struct_1029 {
    __pid_t si_pid;
    __uid_t si_uid;
};

struct _struct_1030 {
    int si_tid;
    int si_overrun;
    sigval_t si_sigval;
};

union _union_1028 {
    int _pad[29];
    struct _struct_1029 _kill;
    struct _struct_1030 _timer;
    struct _struct_1031 _rt;
    struct _struct_1032 _sigchld;
    struct _struct_1033 _sigfault;
    struct _struct_1034 _sigpoll;
};

struct siginfo {
    int si_signo;
    int si_errno;
    int si_code;
    union _union_1028 _sifields;
};

typedef struct siginfo siginfo_t;

typedef struct _Str _Str, *P_Str;

struct _Str {
    char * ptr;
    int length;
    int area_size;
};

typedef struct _Str * Str;

typedef struct _FTP _FTP, *P_FTP;

typedef struct _FTP * FTP;

typedef union input_stream input_stream, *Pinput_stream;

typedef union input_stream * InputStream;


// WARNING! conflicting data type names: /DWARF/stdio.h/FILE - /stdio.h/FILE

typedef struct base_stream base_stream, *Pbase_stream;

typedef struct file_stream file_stream, *Pfile_stream;

typedef struct str_stream str_stream, *Pstr_stream;

typedef struct encoded_stream encoded_stream, *Pencoded_stream;

typedef struct stream_buffer stream_buffer, *Pstream_buffer;

typedef struct file_handle file_handle, *Pfile_handle;

typedef struct ens_handle ens_handle, *Pens_handle;

struct stream_buffer {
    uchar * buf;
    int size;
    int cur;
    int next;
};

struct encoded_stream {
    struct stream_buffer stream;
    struct ens_handle * handle;
    char type;
    char iseos;
    undefined field4_0x16;
    undefined field5_0x17;
    int (* read)(...);
    void (* close)(...);
};

struct base_stream {
    struct stream_buffer stream;
    void * handle;
    char type;
    char iseos;
    undefined field4_0x16;
    undefined field5_0x17;
    int (* read)(...);
    void (* close)(...);
};

struct file_stream {
    struct stream_buffer stream;
    struct file_handle * handle;
    char type;
    char iseos;
    undefined field4_0x16;
    undefined field5_0x17;
    int (* read)(...);
    void (* close)(...);
};

struct str_stream {
    struct stream_buffer stream;
    Str handle;
    char type;
    char iseos;
    undefined field4_0x16;
    undefined field5_0x17;
    int (* read)(...);
    void (* close)(...);
};

union input_stream {
    struct base_stream base;
    struct file_stream file;
    struct str_stream str;
    struct encoded_stream ens;
};

struct ens_handle {
    union input_stream * is;
    Str s;
    int pos;
    char encoding;
    undefined field4_0xd;
    undefined field5_0xe;
    undefined field6_0xf;
};

struct file_handle {
    FILE * f;
    void (* close)(...);
};

struct _FTP {
    char * host;
    int port;
    char * user;
    char * pass;
    InputStream rf;
    FILE * wf;
    FILE * data;
};

typedef struct _FuncList _FuncList, *P_FuncList;

typedef struct _FuncList FuncList;

struct _FuncList {
    char * id;
    void (* func)(...);
};

typedef __pid_t pid_t;


// WARNING! conflicting data type names: /DWARF/dirent.h/DIR - /dirent.h/DIR


// WARNING! conflicting data type names: /DWARF/dirent.h/dirent - /dirent.h/dirent


// WARNING! conflicting data type names: /DWARF/utime.h/utimbuf - /utime.h/utimbuf

typedef struct symbol_set symbol_set, *Psymbol_set;

typedef uint uint32_t;

typedef uint32_t wc_uint32;

typedef wc_uint32 wc_ces;

struct symbol_set {
    wc_ces ces;
    char width;
    undefined field2_0x5;
    undefined field3_0x6;
    undefined field4_0x7;
    char * * item;
    char encode;
    undefined field7_0xd;
    undefined field8_0xe;
    undefined field9_0xf;
};

typedef struct charset_symbol_set charset_symbol_set, *Pcharset_symbol_set;

struct charset_symbol_set {
    wc_ces charset;
    struct symbol_set * symbol;
};


// WARNING! conflicting data type names: /DWARF/siginfo.h/sigval_t - /siginfo.h/sigval_t

typedef struct anon_struct.conflict15648 anon_struct.conflict15648, *Panon_struct.conflict15648;

struct anon_struct.conflict15648 {
    __pid_t si_pid;
    __uid_t si_uid;
};

typedef struct anon_struct.conflict15722 anon_struct.conflict15722, *Panon_struct.conflict15722;

struct anon_struct.conflict15722 {
    void * si_addr;
};


// WARNING! conflicting data type names: /DWARF/siginfo.h/sigval - /siginfo.h/sigval


// WARNING! conflicting data type names: /DWARF/siginfo.h/siginfo - /siginfo.h/siginfo


// WARNING! conflicting data type names: /DWARF/siginfo.h/siginfo_t - /siginfo.h/siginfo_t

typedef struct anon_struct.conflict1566d anon_struct.conflict1566d, *Panon_struct.conflict1566d;

struct anon_struct.conflict1566d {
    int si_tid;
    int si_overrun;
    sigval_t si_sigval;
};

typedef struct anon_struct.conflict156a0 anon_struct.conflict156a0, *Panon_struct.conflict156a0;

struct anon_struct.conflict156a0 {
    __pid_t si_pid;
    __uid_t si_uid;
    sigval_t si_sigval;
};

typedef struct anon_struct.conflict156d3 anon_struct.conflict156d3, *Panon_struct.conflict156d3;

struct anon_struct.conflict156d3 {
    __pid_t si_pid;
    __uid_t si_uid;
    int si_status;
    __clock_t si_utime;
    __clock_t si_stime;
};

typedef union anon_union.conflict1575e anon_union.conflict1575e, *Panon_union.conflict1575e;

typedef struct anon_struct.conflict15739 anon_struct.conflict15739, *Panon_struct.conflict15739;

struct anon_struct.conflict15739 {
    long si_band;
    int si_fd;
};

union anon_union.conflict1575e {
    int _pad[29];
    struct anon_struct.conflict15648 _kill;
    struct anon_struct.conflict1566d _timer;
    struct anon_struct.conflict156a0 _rt;
    struct anon_struct.conflict156d3 _sigchld;
    struct anon_struct.conflict15722 _sigfault;
    struct anon_struct.conflict15739 _sigpoll;
};

typedef union anon_union.conflict1575e_for__sifields anon_union.conflict1575e_for__sifields, *Panon_union.conflict1575e_for__sifields;

union anon_union.conflict1575e_for__sifields {
    int _pad[29];
    struct anon_struct.conflict15648 _kill;
    struct anon_struct.conflict1566d _timer;
    struct anon_struct.conflict156a0 _rt;
    struct anon_struct.conflict156d3 _sigchld;
    struct anon_struct.conflict15722 _sigfault;
    struct anon_struct.conflict15739 _sigpoll;
};

typedef char * __gnuc_va_list;

typedef struct sigaction sigaction, *Psigaction;

typedef union anon_union.conflict15831_for___sigaction_handler anon_union.conflict15831_for___sigaction_handler, *Panon_union.conflict15831_for___sigaction_handler;

typedef struct __sigset_t __sigset_t, *P__sigset_t;

struct __sigset_t {
    ulong __val[32];
};

union anon_union.conflict15831_for___sigaction_handler {
    void (* sa_handler)(int);
    void (* sa_sigaction)(int, siginfo_t *, void *);
};

struct sigaction {
    union anon_union.conflict15831_for___sigaction_handler __sigaction_handler;
    struct __sigset_t sa_mask;
    int sa_flags;
    void (* sa_restorer)(void);
};

typedef union anon_union.conflict15831 anon_union.conflict15831, *Panon_union.conflict15831;

union anon_union.conflict15831 {
    void (* sa_handler)(int);
    void (* sa_sigaction)(int, siginfo_t *, void *);
};

typedef struct _anchor _anchor, *P_anchor;

typedef struct _anchor Anchor;

typedef struct BufferPoint BufferPoint, *PBufferPoint;

typedef struct _image _image, *P_image;

typedef struct _image Image;

typedef struct _imageCache _imageCache, *P_imageCache;

typedef struct _imageCache ImageCache;

typedef struct _ParsedURL _ParsedURL, *P_ParsedURL;

typedef struct _ParsedURL ParsedURL;

struct BufferPoint {
    int line;
    int pos;
    int invalid;
};

struct _anchor {
    char * url;
    char * target;
    char * referer;
    char * title;
    uchar accesskey;
    undefined field5_0x11;
    undefined field6_0x12;
    undefined field7_0x13;
    struct BufferPoint start;
    struct BufferPoint end;
    int hseq;
    char slave;
    undefined field12_0x31;
    short y;
    short rows;
    undefined field15_0x36;
    undefined field16_0x37;
    Image * image;
};

struct _ParsedURL {
    int scheme;
    char * user;
    char * pass;
    char * host;
    int port;
    char * file;
    char * real_file;
    char * query;
    char * label;
    int is_nocache;
};

struct _imageCache {
    char * url;
    ParsedURL * current;
    char * file;
    char * touch;
    pid_t pid;
    char loaded;
    undefined field6_0x15;
    undefined field7_0x16;
    undefined field8_0x17;
    int index;
    short width;
    short height;
};

struct _image {
    char * url;
    char * ext;
    short width;
    short height;
    short xoffset;
    short yoffset;
    short y;
    short rows;
    char * map;
    char ismap;
    undefined field10_0x19;
    undefined field11_0x1a;
    undefined field12_0x1b;
    int touch;
    ImageCache * cache;
};

typedef struct _AlarmEvent _AlarmEvent, *P_AlarmEvent;

struct _AlarmEvent {
    int sec;
    short status;
    undefined field2_0x6;
    undefined field3_0x7;
    int cmd;
    void * data;
};

typedef struct _DownloadList _DownloadList, *P_DownloadList;

typedef struct _DownloadList DownloadList;

typedef longlong clen_t;

typedef __time_t time_t;

struct _DownloadList {
    pid_t pid;
    char * url;
    char * save;
    char * lock;
    clen_t size;
    time_t time;
    int ok;
    struct _DownloadList * next;
    struct _DownloadList * prev;
};

typedef struct readbuffer readbuffer, *Preadbuffer;

typedef ushort Lineprop;

typedef struct Breakpoint Breakpoint, *PBreakpoint;

typedef struct cmdtable cmdtable, *Pcmdtable;

struct Breakpoint {
    int pos;
    int len;
    int tlen;
    long flag;
    Anchor anchor;
    Str img_alt;
    char fontstat[7];
    undefined field7_0x57;
    short nobr_level;
    Lineprop prev_ctype;
    char init_flag;
    undefined field11_0x5d;
    short top_margin;
    short bottom_margin;
    undefined field14_0x62;
    undefined field15_0x63;
};

struct cmdtable {
    char * cmdname;
    int cmd;
};

struct readbuffer {
    Str line;
    Lineprop cprop;
    short pos;
    Str prevchar;
    long flag;
    long flag_stack[10];
    int flag_sp;
    int status;
    uchar end_tag;
    undefined field9_0x41;
    short table_level;
    short nobr_level;
    undefined field12_0x46;
    undefined field13_0x47;
    Anchor anchor;
    Str img_alt;
    char fontstat[7];
    char fontstat_stack[5][7];
    undefined field18_0xb2;
    undefined field19_0xb3;
    int fontstat_sp;
    Lineprop prev_ctype;
    undefined field22_0xba;
    undefined field23_0xbb;
    struct Breakpoint bp;
    struct cmdtable * tag_stack[10];
    int tag_sp;
    short top_margin;
    short bottom_margin;
};

typedef struct http_request http_request, *Phttp_request;

typedef struct http_request HRequest;

typedef struct form_list form_list, *Pform_list;

typedef struct form_list FormList;

typedef struct form_item_list form_item_list, *Pform_item_list;

typedef struct form_select_option_item form_select_option_item, *Pform_select_option_item;

typedef struct form_select_option_item FormSelectOptionItem;

struct form_select_option_item {
    Str value;
    Str label;
    int checked;
    struct form_select_option_item * next;
};

struct form_list {
    struct form_item_list * item;
    struct form_item_list * lastitem;
    int method;
    Str action;
    char * target;
    char * name;
    wc_ces charset;
    int enctype;
    struct form_list * next;
    int nitems;
    char * body;
    char * boundary;
    ulong length;
};

struct form_item_list {
    int type;
    Str name;
    Str value;
    Str init_value;
    int checked;
    int init_checked;
    int accept;
    int size;
    int rows;
    int maxlength;
    int readonly;
    FormSelectOptionItem * select_option;
    Str label;
    Str init_label;
    int selected;
    int init_selected;
    struct form_list * parent;
    struct form_item_list * next;
};

struct http_request {
    char command;
    char flag;
    undefined field2_0x2;
    undefined field3_0x3;
    char * referer;
    FormList * request;
};

typedef struct _BufferPos _BufferPos, *P_BufferPos;

struct _BufferPos {
    long top_linenumber;
    long cur_linenumber;
    int currentColumn;
    int pos;
    int bpos;
    struct _BufferPos * next;
    struct _BufferPos * prev;
};

typedef struct _AlarmEvent AlarmEvent;

typedef struct cookie cookie, *Pcookie;

typedef struct portlist portlist, *Pportlist;

struct cookie {
    ParsedURL url;
    Str name;
    Str value;
    time_t expires;
    Str path;
    Str domain;
    Str comment;
    Str commentURL;
    struct portlist * portl;
    char version;
    char flag;
    undefined field11_0x4a;
    undefined field12_0x4b;
    struct cookie * next;
};

struct portlist {
    ushort port;
    undefined field1_0x2;
    undefined field2_0x3;
    struct portlist * next;
};

typedef struct HmarkerList HmarkerList, *PHmarkerList;

struct HmarkerList {
    struct BufferPoint * marks;
    int nmark;
    int markmax;
    int prevhseq;
};

typedef struct _MouseActionMap _MouseActionMap, *P_MouseActionMap;

typedef struct _MouseActionMap MouseActionMap;

struct _MouseActionMap {
    void (* func)(...);
    char * data;
};

typedef struct html_feed_environ html_feed_environ, *Phtml_feed_environ;

typedef struct _textlinelist _textlinelist, *P_textlinelist;

typedef struct _textlinelist TextLineList;

typedef struct environment environment, *Penvironment;

typedef struct _textlinelistitem _textlinelistitem, *P_textlinelistitem;

typedef struct _textlinelistitem TextLineListItem;

typedef struct _TextLine _TextLine, *P_TextLine;

typedef struct _TextLine TextLine;

struct html_feed_environ {
    struct readbuffer * obuf;
    TextLineList * buf;
    FILE * f;
    Str tagbuf;
    int limit;
    int maxlimit;
    struct environment * envs;
    int nenv;
    int envc;
    int envc_real;
    char * title;
    int blank_lines;
};

struct _textlinelist {
    TextLineListItem * first;
    TextLineListItem * last;
    short nitem;
    undefined field3_0xa;
    undefined field4_0xb;
};

struct environment {
    uchar env;
    undefined field1_0x1;
    undefined field2_0x2;
    undefined field3_0x3;
    int type;
    int count;
    char indent;
    undefined field7_0xd;
    undefined field8_0xe;
    undefined field9_0xf;
};

struct _textlinelistitem {
    TextLine * ptr;
    struct _textlinelistitem * next;
    struct _textlinelistitem * prev;
};

struct _TextLine {
    Str line;
    short pos;
    undefined field2_0x6;
    undefined field3_0x7;
};

typedef struct _MapList _MapList, *P_MapList;

typedef struct _generallist _generallist, *P_generallist;

typedef struct _generallist GeneralList;

typedef struct _listitem _listitem, *P_listitem;

typedef struct _listitem ListItem;

struct _listitem {
    void * ptr;
    struct _listitem * next;
    struct _listitem * prev;
};

struct _MapList {
    Str name;
    GeneralList * area;
    struct _MapList * next;
};

struct _generallist {
    ListItem * first;
    ListItem * last;
    short nitem;
    undefined field3_0xa;
    undefined field4_0xb;
};

typedef uchar Linecolor;

typedef struct _Buffer _Buffer, *P_Buffer;

typedef struct _Buffer Buffer;

typedef struct _Line _Line, *P_Line;

typedef struct _Line Line;

typedef struct _anchorList _anchorList, *P_anchorList;

typedef struct _anchorList AnchorList;

typedef struct _LinkList _LinkList, *P_LinkList;

typedef struct _LinkList LinkList;

typedef struct _MapList MapList;

typedef struct frameset frameset, *Pframeset;

typedef struct frameset_queue frameset_queue, *Pframeset_queue;


// WARNING! conflicting data type names: /DWARF/stddef.h/size_t - /stddef.h/size_t

typedef uchar uint8_t;

typedef uint8_t wc_uint8;

typedef struct _textlist _textlist, *P_textlist;

typedef struct _textlist TextList;

typedef struct form_item_list FormItemList;

typedef struct mailcap mailcap, *Pmailcap;

typedef union frameset_element frameset_element, *Pframeset_element;

typedef struct _textlistitem _textlistitem, *P_textlistitem;

typedef struct _textlistitem TextListItem;

typedef struct frame_element frame_element, *Pframe_element;

typedef struct frame_body frame_body, *Pframe_body;

struct frameset_queue {
    struct frameset_queue * next;
    struct frameset_queue * back;
    struct frameset * frameset;
    long linenumber;
    long top_linenumber;
    int pos;
    int currentColumn;
    struct _anchorList * formitem;
};

struct frame_element {
    char attr;
    char dummy;
    undefined field2_0x2;
    undefined field3_0x3;
    char * name;
};

struct frameset {
    char attr;
    char dummy;
    undefined field2_0x2;
    undefined field3_0x3;
    char * name;
    ParsedURL * currentURL;
    char * * width;
    char * * height;
    int col;
    int row;
    int i;
    union frameset_element * frame;
};

struct _textlist {
    TextListItem * first;
    TextListItem * last;
    short nitem;
    undefined field3_0xa;
    undefined field4_0xb;
};

struct _anchorList {
    Anchor * anchors;
    int nanchor;
    int anchormax;
    int acache;
};

union frameset_element {
    struct frame_element * element;
    struct frame_body * body;
    struct frameset * set;
};

struct _textlistitem {
    char * ptr;
    struct _textlistitem * next;
    struct _textlistitem * prev;
};

struct mailcap {
    char * type;
    char * viewer;
    int flags;
    char * test;
    char * nametemplate;
    char * edit;
};

struct frame_body {
    char attr;
    char flags;
    undefined field2_0x2;
    undefined field3_0x3;
    char * name;
    char * url;
    ParsedURL * baseURL;
    char * source;
    char * type;
    char * referer;
    struct _anchorList * nameList;
    FormList * request;
};

struct _Line {
    char * lineBuf;
    Lineprop * propBuf;
    Linecolor * colorBuf;
    struct _Line * next;
    struct _Line * prev;
    int len;
    int width;
    long linenumber;
    long real_linenumber;
    ushort usrflags;
    undefined field10_0x26;
    undefined field11_0x27;
    int size;
    int bpos;
    int bwidth;
};

struct _LinkList {
    char * url;
    char * title;
    char * ctype;
    char type;
    undefined field4_0xd;
    undefined field5_0xe;
    undefined field6_0xf;
    struct _LinkList * next;
};

struct _Buffer {
    char * filename;
    char * buffername;
    Line * firstLine;
    Line * topLine;
    Line * currentLine;
    Line * lastLine;
    struct _Buffer * nextBuffer;
    struct _Buffer * linkBuffer[5];
    short width;
    short height;
    char * type;
    char * real_type;
    int allLine;
    short bufferprop;
    undefined field14_0x42;
    undefined field15_0x43;
    int currentColumn;
    short cursorX;
    short cursorY;
    int pos;
    int visualpos;
    short rootX;
    short rootY;
    short COLS;
    short LINES;
    InputStream pagerSource;
    AnchorList * href;
    AnchorList * name;
    AnchorList * img;
    AnchorList * formitem;
    LinkList * linklist;
    FormList * formlist;
    MapList * maplist;
    struct HmarkerList * hmarklist;
    struct HmarkerList * imarklist;
    ParsedURL currentURL;
    ParsedURL * baseURL;
    char * baseTarget;
    int real_scheme;
    char * sourcefile;
    struct frameset * frameset;
    struct frameset_queue * frameQ;
    int * clone;
    size_t trbyte;
    char check_url;
    undefined field45_0xcd;
    undefined field46_0xce;
    undefined field47_0xcf;
    wc_ces document_charset;
    wc_uint8 auto_detect;
    undefined field50_0xd5;
    undefined field51_0xd6;
    undefined field52_0xd7;
    TextList * document_header;
    FormItemList * form_submit;
    char * savecache;
    char * edit;
    struct mailcap * mailcap;
    char * mailcap_source;
    char * header_source;
    char search_header;
    char image_flag;
    char image_loaded;
    char need_reshape;
    Anchor * submit;
    struct _BufferPos * undo;
    struct _AlarmEvent * event;
};

typedef struct _BufferPos BufferPos;

typedef struct _MapArea _MapArea, *P_MapArea;

typedef struct _MapArea MapArea;

struct _MapArea {
    char * url;
    char * target;
    char * alt;
    char shape;
    undefined field4_0xd;
    undefined field5_0xe;
    undefined field6_0xf;
    short * coords;
    int ncoords;
    short center_x;
    short center_y;
};

typedef struct _MouseAction _MouseAction, *P_MouseAction;

struct _MouseAction {
    char * menu_str;
    char * lastline_str;
    int menu_width;
    int lastline_width;
    int in_action;
    int cursorX;
    int cursorY;
    MouseActionMap default_map[3];
    MouseActionMap anchor_map[3];
    MouseActionMap active_map[3];
    MouseActionMap tab_map[3];
    MouseActionMap * menu_map[3];
    MouseActionMap * lastline_map[3];
};

typedef struct _TabBuffer _TabBuffer, *P_TabBuffer;

typedef struct _TabBuffer TabBuffer;

struct _TabBuffer {
    struct _TabBuffer * nextTab;
    struct _TabBuffer * prevTab;
    Buffer * currentBuffer;
    Buffer * firstBuffer;
    short x1;
    short x2;
    short y;
    undefined field7_0x16;
    undefined field8_0x17;
};

typedef struct _MouseAction MouseAction;

typedef struct anon_struct_for_cell anon_struct_for_cell, *Panon_struct_for_cell;

struct anon_struct_for_cell {
    short * row;
    short * rowspan;
    short * indexarray;
    short maxcell;
    short size;
    short * height;
};

typedef struct base_stream * BaseStream;

typedef struct stream_buffer * StreamBuffer;

typedef struct table_linfo table_linfo, *Ptable_linfo;

struct table_linfo {
    Lineprop prev_ctype;
    char prev_spaces;
    undefined field2_0x3;
    Str prevchar;
    short length;
    undefined field5_0xa;
    undefined field6_0xb;
};

typedef ushort table_attr;

typedef struct table_mode table_mode, *Ptable_mode;

struct table_mode {
    uint pre_mode;
    char indent_level;
    char caption;
    short nobr_offset;
    char nobr_level;
    undefined field5_0x9;
    short anchor_offset;
    uchar end_tag;
    undefined field8_0xd;
    undefined field9_0xe;
    undefined field10_0xf;
};

typedef struct table_cell table_cell, *Ptable_cell;

struct table_cell {
    short col[20];
    short colspan[20];
    short index[20];
    short maxcell;
    short icell;
    short eindex[20];
    short necell;
    short width[20];
    short minimum_width[20];
    short fixed_width[20];
};

typedef struct table table, *Ptable;

typedef struct table_in table_in, *Ptable_in;

typedef struct matrix matrix, *Pmatrix;

typedef struct matrix MAT;

typedef struct vector vector, *Pvector;

typedef struct vector VEC;

struct table_in {
    struct table * ptr;
    short col;
    short row;
    short cell;
    short indent;
    TextLineList * buf;
};

struct vector {
    double * ve;
    int dim;
};

struct matrix {
    double * me;
    int dim;
};

struct table {
    int row;
    int col;
    int maxrow;
    int maxcol;
    int max_rowsize;
    int border_mode;
    int total_width;
    int total_height;
    int tabcontentssize;
    int indent;
    int cellspacing;
    int cellpadding;
    int vcellpadding;
    int vspace;
    int flag;
    Str caption;
    Str id;
    GeneralList * * * tabdata;
    table_attr * * tabattr;
    table_attr trattr;
    undefined field20_0x4e;
    undefined field21_0x4f;
    Str * * tabidvalue;
    Str * tridvalue;
    short tabwidth[50];
    short minimum_width[50];
    short fixed_width[50];
    struct table_cell cell;
    undefined field28_0x2a2;
    undefined field29_0x2a3;
    short * tabheight;
    struct table_in * tables;
    short ntable;
    short tables_size;
    TextList * suspended_data;
    struct table_linfo linfo;
    MAT * matrix;
    VEC * vector;
    int sloppy_width;
};

typedef struct regex regex, *Pregex;

typedef struct regex Regex;

typedef struct regexchar regexchar, *Pregexchar;

typedef struct longchar longchar, *Plongchar;

typedef union anon_union.conflict218b8_for_p anon_union.conflict218b8_for_p, *Panon_union.conflict218b8_for_p;

typedef struct wc_wchar_t wc_wchar_t, *Pwc_wchar_t;

typedef wc_uint32 wc_ccs;

struct wc_wchar_t {
    wc_ccs ccs;
    wc_uint32 code;
};

struct longchar {
    char type;
    undefined field1_0x1;
    undefined field2_0x2;
    undefined field3_0x3;
    struct wc_wchar_t wch;
    uchar ch;
    undefined field6_0xd;
    undefined field7_0xe;
    undefined field8_0xf;
};

union anon_union.conflict218b8_for_p {
    struct longchar * pattern;
};

struct regexchar {
    union anon_union.conflict218b8_for_p p;
    uchar mode;
    undefined field2_0x5;
    undefined field3_0x6;
    undefined field4_0x7;
};

struct regex {
    struct regexchar re[64];
    struct longchar storage[256];
    char * position;
    char * lposition;
    struct regex * alt_regex;
};

typedef union anon_union.conflict218b8 anon_union.conflict218b8, *Panon_union.conflict218b8;

union anon_union.conflict218b8 {
    struct longchar * pattern;
    struct regex * sub;
};

typedef struct Gpm_Connect Gpm_Connect, *PGpm_Connect;

struct Gpm_Connect {
    ushort eventMask;
    ushort defaultMask;
    ushort minMod;
    ushort maxMod;
    int pid;
    int vc;
};

typedef enum Gpm_Etype {
    GPM_MOVE=1,
    GPM_DRAG=2,
    GPM_DOWN=4,
    GPM_UP=8,
    GPM_SINGLE=16,
    GPM_DOUBLE=32,
    GPM_TRIPLE=64,
    GPM_MFLAG=128,
    GPM_HARD=256,
    GPM_ENTER=512,
    GPM_LEAVE=1024
} Gpm_Etype;

typedef struct Gpm_Event Gpm_Event, *PGpm_Event;

typedef enum Gpm_Margin {
    GPM_TOP=1,
    GPM_BOT=2,
    GPM_LFT=4,
    GPM_RGT=8
} Gpm_Margin;

struct Gpm_Event {
    uchar buttons;
    uchar modifiers;
    ushort vc;
    short dx;
    short dy;
    short x;
    short y;
    enum Gpm_Etype type;
    int clicks;
    enum Gpm_Margin margin;
    short wdx;
    short wdy;
};


// WARNING! conflicting data type names: /DWARF/libio.h/_IO_marker - /libio.h/_IO_marker

typedef struct auth_pass auth_pass, *Pauth_pass;

struct auth_pass {
    int bad;
    int is_proxy;
    Str host;
    int port;
    Str realm;
    Str uname;
    Str pwd;
    struct auth_pass * next;
};

typedef __gnuc_va_list va_list;


// WARNING! conflicting data type names: /DWARF/stdio.h/_IO_FILE - /stdio.h/_IO_FILE


// WARNING! conflicting data type names: /DWARF/socket.h/sockaddr - /socket.h/sockaddr

typedef struct sockaddr_storage sockaddr_storage, *Psockaddr_storage;

struct sockaddr_storage {
    sa_family_t ss_family;
    undefined field1_0x2;
    undefined field2_0x3;
    ulong __ss_align;
    char __ss_padding[120];
};

typedef struct sockaddr_in6 sockaddr_in6, *Psockaddr_in6;

typedef ushort uint16_t;

typedef uint16_t in_port_t;

typedef struct in6_addr in6_addr, *Pin6_addr;

typedef union anon_union.conflict33826_for___in6_u anon_union.conflict33826_for___in6_u, *Panon_union.conflict33826_for___in6_u;

union anon_union.conflict33826_for___in6_u {
    uint8_t __u6_addr8[16];
    uint16_t __u6_addr16[8];
    uint32_t __u6_addr32[4];
};

struct in6_addr {
    union anon_union.conflict33826_for___in6_u __in6_u;
};

struct sockaddr_in6 {
    sa_family_t sin6_family;
    in_port_t sin6_port;
    uint32_t sin6_flowinfo;
    struct in6_addr sin6_addr;
    uint32_t sin6_scope_id;
};

typedef enum __socket_type {
    SOCK_STREAM=1,
    SOCK_DGRAM=2,
    SOCK_RAW=3,
    SOCK_RDM=4,
    SOCK_SEQPACKET=5,
    SOCK_DCCP=6,
    SOCK_PACKET=10,
    SOCK_NONBLOCK=2048,
    SOCK_CLOEXEC=524288
} __socket_type;

typedef struct sockaddr_in sockaddr_in, *Psockaddr_in;

typedef struct in_addr in_addr, *Pin_addr;

typedef uint32_t in_addr_t;

struct in_addr {
    in_addr_t s_addr;
};

struct sockaddr_in {
    sa_family_t sin_family;
    in_port_t sin_port;
    struct in_addr sin_addr;
    uchar sin_zero[8];
};

typedef ListItem HistItem;

typedef struct Hist Hist, *PHist;

typedef GeneralList HistList;

typedef struct Hash_sv Hash_sv, *PHash_sv;

typedef struct HashItem_sv HashItem_sv, *PHashItem_sv;

struct Hist {
    HistList * list;
    HistItem * current;
    struct Hash_sv * hash;
};

struct Hash_sv {
    int size;
    struct HashItem_sv * * tab;
};

struct HashItem_sv {
    char * key;
    void * value;
    struct HashItem_sv * next;
};

typedef struct _Menu _Menu, *P_Menu;

typedef struct _MenuItem _MenuItem, *P_MenuItem;

typedef struct _MenuItem MenuItem;

struct _Menu {
    struct _Menu * parent;
    int cursorX;
    int cursorY;
    int x;
    int y;
    int width;
    int height;
    int nitem;
    MenuItem * item;
    int initial;
    int select;
    int offset;
    int active;
    int (* keymap[128])(char);
    int keyselect[128];
};

struct _MenuItem {
    int type;
    char * label;
    int * variable;
    int value;
    void (* func)(...);
    struct _Menu * popup;
    char * keys;
    char * data;
};

typedef struct _Menu Menu;

typedef struct _MenuList _MenuList, *P_MenuList;

struct _MenuList {
    char * id;
    Menu * menu;
    MenuItem * item;
};

typedef struct _MenuList MenuList;

typedef struct _termialImage _termialImage, *P_termialImage;

struct _termialImage {
    ImageCache * cache;
    short x;
    short y;
    short sx;
    short sy;
    short width;
    short height;
};

typedef struct _termialImage TerminalImage;

typedef struct tm tm, *Ptm;

struct tm {
    int tm_sec;
    int tm_min;
    int tm_hour;
    int tm_mday;
    int tm_mon;
    int tm_year;
    int tm_wday;
    int tm_yday;
    int tm_isdst;
    long tm_gmtoff;
    char * tm_zone;
};

typedef struct timeval timeval, *Ptimeval;

struct timeval {
    __time_t tv_sec;
    __suseconds_t tv_usec;
};


// WARNING! conflicting data type names: /DWARF/time.h/timespec - /time.h/timespec

typedef struct anon_struct.conflict3f14d anon_struct.conflict3f14d, *Panon_struct.conflict3f14d;

struct anon_struct.conflict3f14d {
    char * name;
    void (* set_func)(TextList *);
    void (* show_func)(TextList *);
};

typedef struct anon_struct.conflict3f0fa anon_struct.conflict3f0fa, *Panon_struct.conflict3f0fa;

struct anon_struct.conflict3f0fa {
    char * name;
    char * option_string;
    char * help;
    void (* func)(TextList *);
};

typedef struct _News _News, *P_News;

struct _News {
    char * host;
    int port;
    char * mode;
    InputStream rf;
    FILE * wf;
};

typedef struct _News News;

typedef struct link_stack link_stack, *Plink_stack;

struct link_stack {
    int cmd;
    short offset;
    short pos;
    struct link_stack * next;
};

typedef struct http_auth http_auth, *Phttp_auth;

typedef struct auth_param auth_param, *Pauth_param;

struct http_auth {
    int pri;
    char * scheme;
    struct auth_param * param;
    Str (* cred)(struct http_auth *, Str, Str, ParsedURL *, HRequest *, FormList *);
};

struct auth_param {
    char * name;
    Str val;
};

typedef struct compression_decoder compression_decoder, *Pcompression_decoder;

struct compression_decoder {
    int type;
    char * ext;
    char * mime_type;
    int auxbin_p;
    char * cmd;
    char * name;
    char * encoding;
    char * encodings[4];
};

typedef struct anon_struct.conflict4705b anon_struct.conflict4705b, *Panon_struct.conflict4705b;

struct anon_struct.conflict4705b {
    char * lang;
    wc_ces ces;
};


// WARNING! conflicting data type names: /DWARF/termios.h/termios - /termios.h/termios


// WARNING! conflicting data type names: /DWARF/stat.h/stat - /stat.h/stat

typedef struct HashItem_ss HashItem_ss, *PHashItem_ss;

struct HashItem_ss {
    char * key;
    char * value;
    struct HashItem_ss * next;
};

typedef struct Hash_iv Hash_iv, *PHash_iv;

typedef struct HashItem_iv HashItem_iv, *PHashItem_iv;

struct Hash_iv {
    int size;
    struct HashItem_iv * * tab;
};

struct HashItem_iv {
    int key;
    void * value;
    struct HashItem_iv * next;
};

typedef struct Hash_si Hash_si, *PHash_si;

typedef struct HashItem_si HashItem_si, *PHashItem_si;

struct Hash_si {
    int size;
    struct HashItem_si * * tab;
};

struct HashItem_si {
    char * key;
    int value;
    struct HashItem_si * next;
};

typedef struct Hash_ss Hash_ss, *PHash_ss;

struct Hash_ss {
    int size;
    struct HashItem_ss * * tab;
};

typedef struct winsize winsize, *Pwinsize;

struct winsize {
    ushort ws_row;
    ushort ws_col;
    ushort ws_xpixel;
    ushort ws_ypixel;
};

typedef struct dirent Directory;

typedef struct wc_map wc_map, *Pwc_map;

typedef uint16_t wc_uint16;

struct wc_map {
    wc_uint16 code;
    wc_uint16 code2;
};

typedef struct wc_table wc_table, *Pwc_table;

struct wc_table {
    wc_ccs ccs;
    size_t n;
    struct wc_map * map;
    wc_wchar_t (* conv)(...);
};

typedef uchar wc_uchar;

typedef struct wc_gset wc_gset, *Pwc_gset;

typedef wc_uchar wc_bool;

struct wc_gset {
    wc_ccs ccs;
    wc_uchar g;
    wc_bool init;
    undefined field3_0x6;
    undefined field4_0x7;
};

typedef struct wc_ces_info wc_ces_info, *Pwc_ces_info;

struct wc_ces_info {
    wc_ces id;
    char * name;
    char * desc;
    struct wc_gset * gset;
    wc_uchar * gset_ext;
    Str (* conv_from)(...);
    void (* push_to)(...);
    Str (* char_conv)(...);
};

typedef struct wc_map3 wc_map3, *Pwc_map3;

struct wc_map3 {
    wc_uint16 code;
    wc_uint16 code2;
    wc_uint16 code3;
};

typedef struct wc_status wc_status, *Pwc_status;

struct wc_status {
    struct wc_ces_info * ces_info;
    wc_uint8 gr;
    wc_uint8 gl;
    wc_uint8 ss;
    undefined field4_0x7;
    wc_ccs g0_ccs;
    wc_ccs g1_ccs;
    wc_ccs design[4];
    struct wc_table * * tlist;
    struct wc_table * * tlistw;
    int state;
    Str tag;
    int ntag;
    wc_uint32 base;
    int shift;
};

typedef struct wc_option wc_option, *Pwc_option;

struct wc_option {
    wc_uint8 auto_detect;
    wc_bool use_combining;
    wc_bool use_language_tag;
    wc_bool ucs_conv;
    wc_bool pre_conv;
    wc_bool fix_width_conv;
    wc_bool use_gb12345_map;
    wc_bool use_jisx0201;
    wc_bool use_jisc6226;
    wc_bool use_jisx0201k;
    wc_bool use_jisx0212;
    wc_bool use_jisx0213;
    wc_bool strict_iso2022;
    wc_bool gb18030_as_ucs;
    wc_bool no_replace;
    wc_bool use_wide;
};

typedef struct wc_ces_list wc_ces_list, *Pwc_ces_list;

struct wc_ces_list {
    wc_ces id;
    char * name;
    char * desc;
};

typedef wc_uint32 wc_locale;


// WARNING! conflicting data type names: /DWARF/pwd.h/passwd - /pwd.h/passwd

typedef struct w3m_term_info w3m_term_info, *Pw3m_term_info;

struct w3m_term_info {
    char * term;
    char * title_str;
    int mouse_flag;
};

typedef struct termios TerminalMode;

typedef struct scline scline, *Pscline;

typedef ushort l_prop;

struct scline {
    char * * lineimage;
    l_prop * lineprop;
    short isdirty;
    short eol;
};

typedef struct scline Screen;


// WARNING! conflicting data type names: /DWARF/_UNCATEGORIZED_/__dirstream - /dirent.h/__dirstream

typedef struct auth_cookie auth_cookie, *Pauth_cookie;

struct auth_cookie {
};

typedef enum anon_enum_32.conflictd1f {
    AUTHCHR_NUL=0,
    WC_CES_N_US_ASCII=0,
    _NL_CTYPE_CLASS=0,
    __LC_CTYPE=0,
    AUTHCHR_SEP=1,
    WC_CES_N_ISO_8859_1=1,
    _NL_CTYPE_TOUPPER=1,
    __LC_NUMERIC=1,
    AUTHCHR_TOKEN=2,
    WC_CES_N_ISO_8859_2=2,
    _NL_CTYPE_GAP1=2,
    __LC_TIME=2,
    WC_CES_N_ISO_8859_3=3,
    _NL_CTYPE_TOLOWER=3,
    __LC_COLLATE=3,
    WC_CES_N_ISO_8859_4=4,
    _NL_CTYPE_GAP2=4,
    __LC_MONETARY=4,
    WC_CES_N_ISO_8859_5=5,
    _NL_CTYPE_CLASS32=5,
    __LC_MESSAGES=5,
    WC_CES_N_ISO_8859_6=6,
    _NL_CTYPE_GAP3=6,
    __LC_ALL=6,
    WC_CES_N_ISO_8859_7=7,
    _NL_CTYPE_GAP4=7,
    __LC_PAPER=7,
    WC_CES_N_ISO_8859_8=8,
    _NL_CTYPE_GAP5=8,
    __LC_NAME=8,
    WC_CES_N_ISO_8859_9=9,
    _NL_CTYPE_GAP6=9,
    __LC_ADDRESS=9,
    WC_CES_N_ISO_8859_10=10,
    _NL_CTYPE_CLASS_NAMES=10,
    __LC_TELEPHONE=10,
    WC_CES_N_ISO_8859_11=11,
    _NL_CTYPE_MAP_NAMES=11,
    __LC_MEASUREMENT=11,
    WC_CES_N_ISO_8859_12=12,
    _NL_CTYPE_WIDTH=12,
    __LC_IDENTIFICATION=12,
    WC_CES_N_ISO_8859_13=13,
    _NL_CTYPE_MB_CUR_MAX=13,
    CODESET=14,
    WC_CES_N_ISO_8859_14=14,
    _NL_CTYPE_CODESET_NAME=14,
    WC_CES_N_ISO_8859_15=15,
    _NL_CTYPE_TOUPPER32=15,
    WC_CES_N_ISO_8859_16=16,
    _NL_CTYPE_TOLOWER32=16,
    WC_CES_N_ISO_2022_JP=17,
    _NL_CTYPE_CLASS_OFFSET=17,
    WC_CES_N_ISO_2022_JP_2=18,
    _NL_CTYPE_MAP_OFFSET=18,
    WC_CES_N_ISO_2022_JP_3=19,
    _NL_CTYPE_INDIGITS_MB_LEN=19,
    WC_CES_N_ISO_2022_CN=20,
    _NL_CTYPE_INDIGITS0_MB=20,
    WC_CES_N_ISO_2022_KR=21,
    _NL_CTYPE_INDIGITS1_MB=21,
    WC_CES_N_EUC_JP=22,
    _NL_CTYPE_INDIGITS2_MB=22,
    WC_CES_N_EUC_CN=23,
    _NL_CTYPE_INDIGITS3_MB=23,
    WC_CES_N_EUC_TW=24,
    _NL_CTYPE_INDIGITS4_MB=24,
    WC_CES_N_EUC_KR=25,
    _NL_CTYPE_INDIGITS5_MB=25,
    WC_CES_N_CP437=26,
    _NL_CTYPE_INDIGITS6_MB=26,
    WC_CES_N_CP737=27,
    _NL_CTYPE_INDIGITS7_MB=27,
    WC_CES_N_CP775=28,
    _NL_CTYPE_INDIGITS8_MB=28,
    WC_CES_N_CP850=29,
    _NL_CTYPE_INDIGITS9_MB=29,
    WC_CES_N_CP852=30,
    _NL_CTYPE_INDIGITS_WC_LEN=30,
    WC_CES_N_CP855=31,
    _NL_CTYPE_INDIGITS0_WC=31,
    WC_CES_N_CP856=32,
    _NL_CTYPE_INDIGITS1_WC=32,
    WC_CES_N_CP857=33,
    _NL_CTYPE_INDIGITS2_WC=33,
    WC_CES_N_CP860=34,
    _NL_CTYPE_INDIGITS3_WC=34,
    WC_CES_N_CP861=35,
    _NL_CTYPE_INDIGITS4_WC=35,
    WC_CES_N_CP862=36,
    _NL_CTYPE_INDIGITS5_WC=36,
    WC_CES_N_CP863=37,
    _NL_CTYPE_INDIGITS6_WC=37,
    WC_CES_N_CP864=38,
    _NL_CTYPE_INDIGITS7_WC=38,
    WC_CES_N_CP865=39,
    _NL_CTYPE_INDIGITS8_WC=39,
    WC_CES_N_CP866=40,
    _NL_CTYPE_INDIGITS9_WC=40,
    WC_CES_N_CP869=41,
    _NL_CTYPE_OUTDIGIT0_MB=41,
    WC_CES_N_CP874=42,
    _NL_CTYPE_OUTDIGIT1_MB=42,
    WC_CES_N_CP1006=43,
    _NL_CTYPE_OUTDIGIT2_MB=43,
    WC_CES_N_CP1250=44,
    _NL_CTYPE_OUTDIGIT3_MB=44,
    WC_CES_N_CP1251=45,
    _NL_CTYPE_OUTDIGIT4_MB=45,
    WC_CES_N_CP1252=46,
    _NL_CTYPE_OUTDIGIT5_MB=46,
    WC_CES_N_CP1253=47,
    _NL_CTYPE_OUTDIGIT6_MB=47,
    WC_CES_N_CP1254=48,
    _NL_CTYPE_OUTDIGIT7_MB=48,
    WC_CES_N_CP1255=49,
    _NL_CTYPE_OUTDIGIT8_MB=49,
    WC_CES_N_CP1256=50,
    _NL_CTYPE_OUTDIGIT9_MB=50,
    WC_CES_N_CP1257=51,
    _NL_CTYPE_OUTDIGIT0_WC=51,
    WC_CES_N_KOI8_R=52,
    _NL_CTYPE_OUTDIGIT1_WC=52,
    WC_CES_N_KOI8_U=53,
    _NL_CTYPE_OUTDIGIT2_WC=53,
    WC_CES_N_NEXTSTEP=54,
    _NL_CTYPE_OUTDIGIT3_WC=54,
    WC_CES_N_RAW=55,
    _NL_CTYPE_OUTDIGIT4_WC=55,
    WC_CES_N_SHIFT_JIS=56,
    _NL_CTYPE_OUTDIGIT5_WC=56,
    WC_CES_N_SHIFT_JISX0213=57,
    _NL_CTYPE_OUTDIGIT6_WC=57,
    WC_CES_N_GBK=58,
    _NL_CTYPE_OUTDIGIT7_WC=58,
    WC_CES_N_GB18030=59,
    _NL_CTYPE_OUTDIGIT8_WC=59,
    WC_CES_N_HZ_GB_2312=60,
    _NL_CTYPE_OUTDIGIT9_WC=60,
    WC_CES_N_BIG5=61,
    _NL_CTYPE_TRANSLIT_TAB_SIZE=61,
    WC_CES_N_HKSCS=62,
    _NL_CTYPE_TRANSLIT_FROM_IDX=62,
    WC_CES_N_UHC=63,
    _NL_CTYPE_TRANSLIT_FROM_TBL=63,
    WC_CES_N_JOHAB=64,
    _NL_CTYPE_TRANSLIT_TO_IDX=64,
    WC_CES_N_CP1258=65,
    _NL_CTYPE_TRANSLIT_TO_TBL=65,
    WC_CES_N_TCVN_5712=66,
    _NL_CTYPE_TRANSLIT_DEFAULT_MISSING_LEN=66,
    WC_CES_N_VISCII_11=67,
    _NL_CTYPE_TRANSLIT_DEFAULT_MISSING=67,
    WC_CES_N_VPS=68,
    _NL_CTYPE_TRANSLIT_IGNORE_LEN=68,
    WC_CES_N_UTF_8=69,
    _NL_CTYPE_TRANSLIT_IGNORE=69,
    WC_CES_N_UTF_7=70,
    _NL_CTYPE_MAP_TO_NONASCII=70,
    _NL_CTYPE_NONASCII_CASE=71,
    _NL_CTYPE_EXTRA_MAP_1=72,
    _NL_CTYPE_EXTRA_MAP_2=73,
    _NL_CTYPE_EXTRA_MAP_3=74,
    _NL_CTYPE_EXTRA_MAP_4=75,
    _NL_CTYPE_EXTRA_MAP_5=76,
    _NL_CTYPE_EXTRA_MAP_6=77,
    _NL_CTYPE_EXTRA_MAP_7=78,
    _NL_CTYPE_EXTRA_MAP_8=79,
    _NL_CTYPE_EXTRA_MAP_9=80,
    _NL_CTYPE_EXTRA_MAP_10=81,
    _NL_CTYPE_EXTRA_MAP_11=82,
    _NL_CTYPE_EXTRA_MAP_12=83,
    _NL_CTYPE_EXTRA_MAP_13=84,
    _NL_CTYPE_EXTRA_MAP_14=85,
    _NL_NUM_LC_CTYPE=86,
    RADIXCHAR=65536,
    __DECIMAL_POINT=65536,
    THOUSEP=65537,
    __THOUSANDS_SEP=65537,
    __GROUPING=65538,
    _NL_NUMERIC_DECIMAL_POINT_WC=65539,
    _NL_NUMERIC_THOUSANDS_SEP_WC=65540,
    _NL_NUMERIC_CODESET=65541,
    _NL_NUM_LC_NUMERIC=65542,
    ABDAY_1=131072,
    ABDAY_2=131073,
    ABDAY_3=131074,
    ABDAY_4=131075,
    ABDAY_5=131076,
    ABDAY_6=131077,
    ABDAY_7=131078,
    DAY_1=131079,
    DAY_2=131080,
    DAY_3=131081,
    DAY_4=131082,
    DAY_5=131083,
    DAY_6=131084,
    DAY_7=131085,
    ABMON_1=131086,
    ABMON_2=131087,
    ABMON_3=131088,
    ABMON_4=131089,
    ABMON_5=131090,
    ABMON_6=131091,
    ABMON_7=131092,
    ABMON_8=131093,
    ABMON_9=131094,
    ABMON_10=131095,
    ABMON_11=131096,
    ABMON_12=131097,
    MON_1=131098,
    MON_2=131099,
    MON_3=131100,
    MON_4=131101,
    MON_5=131102,
    MON_6=131103,
    MON_7=131104,
    MON_8=131105,
    MON_9=131106,
    MON_10=131107,
    MON_11=131108,
    MON_12=131109,
    AM_STR=131110,
    PM_STR=131111,
    D_T_FMT=131112,
    D_FMT=131113,
    T_FMT=131114,
    T_FMT_AMPM=131115,
    ERA=131116,
    __ERA_YEAR=131117,
    ERA_D_FMT=131118,
    ALT_DIGITS=131119,
    ERA_D_T_FMT=131120,
    ERA_T_FMT=131121,
    _NL_TIME_ERA_NUM_ENTRIES=131122,
    _NL_TIME_ERA_ENTRIES=131123,
    _NL_WABDAY_1=131124,
    _NL_WABDAY_2=131125,
    _NL_WABDAY_3=131126,
    _NL_WABDAY_4=131127,
    _NL_WABDAY_5=131128,
    _NL_WABDAY_6=131129,
    _NL_WABDAY_7=131130,
    _NL_WDAY_1=131131,
    _NL_WDAY_2=131132,
    _NL_WDAY_3=131133,
    _NL_WDAY_4=131134,
    _NL_WDAY_5=131135,
    _NL_WDAY_6=131136,
    _NL_WDAY_7=131137,
    _NL_WABMON_1=131138,
    _NL_WABMON_2=131139,
    _NL_WABMON_3=131140,
    _NL_WABMON_4=131141,
    _NL_WABMON_5=131142,
    _NL_WABMON_6=131143,
    _NL_WABMON_7=131144,
    _NL_WABMON_8=131145,
    _NL_WABMON_9=131146,
    _NL_WABMON_10=131147,
    _NL_WABMON_11=131148,
    _NL_WABMON_12=131149,
    _NL_WMON_1=131150,
    _NL_WMON_2=131151,
    _NL_WMON_3=131152,
    _NL_WMON_4=131153,
    _NL_WMON_5=131154,
    _NL_WMON_6=131155,
    _NL_WMON_7=131156,
    _NL_WMON_8=131157,
    _NL_WMON_9=131158,
    _NL_WMON_10=131159,
    _NL_WMON_11=131160,
    _NL_WMON_12=131161,
    _NL_WAM_STR=131162,
    _NL_WPM_STR=131163,
    _NL_WD_T_FMT=131164,
    _NL_WD_FMT=131165,
    _NL_WT_FMT=131166,
    _NL_WT_FMT_AMPM=131167,
    _NL_WERA_YEAR=131168,
    _NL_WERA_D_FMT=131169,
    _NL_WALT_DIGITS=131170,
    _NL_WERA_D_T_FMT=131171,
    _NL_WERA_T_FMT=131172,
    _NL_TIME_WEEK_NDAYS=131173,
    _NL_TIME_WEEK_1STDAY=131174,
    _NL_TIME_WEEK_1STWEEK=131175,
    _NL_TIME_FIRST_WEEKDAY=131176,
    _NL_TIME_FIRST_WORKDAY=131177,
    _NL_TIME_CAL_DIRECTION=131178,
    _NL_TIME_TIMEZONE=131179,
    _DATE_FMT=131180,
    _NL_W_DATE_FMT=131181,
    _NL_TIME_CODESET=131182,
    _NL_NUM_LC_TIME=131183,
    _NL_COLLATE_NRULES=196608,
    _NL_COLLATE_RULESETS=196609,
    _NL_COLLATE_TABLEMB=196610,
    _NL_COLLATE_WEIGHTMB=196611,
    _NL_COLLATE_EXTRAMB=196612,
    _NL_COLLATE_INDIRECTMB=196613,
    _NL_COLLATE_GAP1=196614,
    _NL_COLLATE_GAP2=196615,
    _NL_COLLATE_GAP3=196616,
    _NL_COLLATE_TABLEWC=196617,
    _NL_COLLATE_WEIGHTWC=196618,
    _NL_COLLATE_EXTRAWC=196619,
    _NL_COLLATE_INDIRECTWC=196620,
    _NL_COLLATE_SYMB_HASH_SIZEMB=196621,
    _NL_COLLATE_SYMB_TABLEMB=196622,
    _NL_COLLATE_SYMB_EXTRAMB=196623,
    _NL_COLLATE_COLLSEQMB=196624,
    _NL_COLLATE_COLLSEQWC=196625,
    _NL_COLLATE_CODESET=196626,
    _NL_NUM_LC_COLLATE=196627,
    __INT_CURR_SYMBOL=262144,
    __CURRENCY_SYMBOL=262145,
    __MON_DECIMAL_POINT=262146,
    __MON_THOUSANDS_SEP=262147,
    __MON_GROUPING=262148,
    __POSITIVE_SIGN=262149,
    __NEGATIVE_SIGN=262150,
    __INT_FRAC_DIGITS=262151,
    __FRAC_DIGITS=262152,
    __P_CS_PRECEDES=262153,
    __P_SEP_BY_SPACE=262154,
    __N_CS_PRECEDES=262155,
    __N_SEP_BY_SPACE=262156,
    __P_SIGN_POSN=262157,
    __N_SIGN_POSN=262158,
    _NL_MONETARY_CRNCYSTR=262159,
    __INT_P_CS_PRECEDES=262160,
    __INT_P_SEP_BY_SPACE=262161,
    __INT_N_CS_PRECEDES=262162,
    __INT_N_SEP_BY_SPACE=262163,
    __INT_P_SIGN_POSN=262164,
    __INT_N_SIGN_POSN=262165,
    _NL_MONETARY_DUO_INT_CURR_SYMBOL=262166,
    _NL_MONETARY_DUO_CURRENCY_SYMBOL=262167,
    _NL_MONETARY_DUO_INT_FRAC_DIGITS=262168,
    _NL_MONETARY_DUO_FRAC_DIGITS=262169,
    _NL_MONETARY_DUO_P_CS_PRECEDES=262170,
    _NL_MONETARY_DUO_P_SEP_BY_SPACE=262171,
    _NL_MONETARY_DUO_N_CS_PRECEDES=262172,
    _NL_MONETARY_DUO_N_SEP_BY_SPACE=262173,
    _NL_MONETARY_DUO_INT_P_CS_PRECEDES=262174,
    _NL_MONETARY_DUO_INT_P_SEP_BY_SPACE=262175,
    _NL_MONETARY_DUO_INT_N_CS_PRECEDES=262176,
    _NL_MONETARY_DUO_INT_N_SEP_BY_SPACE=262177,
    _NL_MONETARY_DUO_P_SIGN_POSN=262178,
    _NL_MONETARY_DUO_N_SIGN_POSN=262179,
    _NL_MONETARY_DUO_INT_P_SIGN_POSN=262180,
    _NL_MONETARY_DUO_INT_N_SIGN_POSN=262181,
    _NL_MONETARY_UNO_VALID_FROM=262182,
    _NL_MONETARY_UNO_VALID_TO=262183,
    _NL_MONETARY_DUO_VALID_FROM=262184,
    _NL_MONETARY_DUO_VALID_TO=262185,
    _NL_MONETARY_CONVERSION_RATE=262186,
    _NL_MONETARY_DECIMAL_POINT_WC=262187,
    _NL_MONETARY_THOUSANDS_SEP_WC=262188,
    _NL_MONETARY_CODESET=262189,
    _NL_NUM_LC_MONETARY=262190,
    __YESEXPR=327680,
    __NOEXPR=327681,
    __YESSTR=327682,
    __NOSTR=327683,
    _NL_MESSAGES_CODESET=327684,
    _NL_NUM_LC_MESSAGES=327685,
    _NL_PAPER_HEIGHT=458752,
    _NL_PAPER_WIDTH=458753,
    _NL_PAPER_CODESET=458754,
    _NL_NUM_LC_PAPER=458755,
    _NL_NAME_NAME_FMT=524288,
    _NL_NAME_NAME_GEN=524289,
    _NL_NAME_NAME_MR=524290,
    _NL_NAME_NAME_MRS=524291,
    _NL_NAME_NAME_MISS=524292,
    _NL_NAME_NAME_MS=524293,
    _NL_NAME_CODESET=524294,
    _NL_NUM_LC_NAME=524295,
    _NL_ADDRESS_POSTAL_FMT=589824,
    _NL_ADDRESS_COUNTRY_NAME=589825,
    _NL_ADDRESS_COUNTRY_POST=589826,
    _NL_ADDRESS_COUNTRY_AB2=589827,
    _NL_ADDRESS_COUNTRY_AB3=589828,
    _NL_ADDRESS_COUNTRY_CAR=589829,
    _NL_ADDRESS_COUNTRY_NUM=589830,
    _NL_ADDRESS_COUNTRY_ISBN=589831,
    _NL_ADDRESS_LANG_NAME=589832,
    _NL_ADDRESS_LANG_AB=589833,
    _NL_ADDRESS_LANG_TERM=589834,
    _NL_ADDRESS_LANG_LIB=589835,
    _NL_ADDRESS_CODESET=589836,
    _NL_NUM_LC_ADDRESS=589837,
    _NL_TELEPHONE_TEL_INT_FMT=655360,
    _NL_TELEPHONE_TEL_DOM_FMT=655361,
    _NL_TELEPHONE_INT_SELECT=655362,
    _NL_TELEPHONE_INT_PREFIX=655363,
    _NL_TELEPHONE_CODESET=655364,
    _NL_NUM_LC_TELEPHONE=655365,
    _NL_MEASUREMENT_MEASUREMENT=720896,
    _NL_MEASUREMENT_CODESET=720897,
    _NL_NUM_LC_MEASUREMENT=720898,
    _NL_IDENTIFICATION_TITLE=786432,
    _NL_IDENTIFICATION_SOURCE=786433,
    _NL_IDENTIFICATION_ADDRESS=786434,
    _NL_IDENTIFICATION_CONTACT=786435,
    _NL_IDENTIFICATION_EMAIL=786436,
    _NL_IDENTIFICATION_TEL=786437,
    _NL_IDENTIFICATION_FAX=786438,
    _NL_IDENTIFICATION_LANGUAGE=786439,
    _NL_IDENTIFICATION_TERRITORY=786440,
    _NL_IDENTIFICATION_AUDIENCE=786441,
    _NL_IDENTIFICATION_APPLICATION=786442,
    _NL_IDENTIFICATION_ABBREVIATION=786443,
    _NL_IDENTIFICATION_REVISION=786444,
    _NL_IDENTIFICATION_DATE=786445,
    _NL_IDENTIFICATION_CATEGORY=786446,
    _NL_IDENTIFICATION_CODESET=786447,
    _NL_NUM_LC_IDENTIFICATION=786448,
    _NL_NUM=786449
} anon_enum_32.conflictd1f;

typedef struct MatchingContext2 MatchingContext2, *PMatchingContext2;

typedef struct MatchingContext1 MatchingContext1, *PMatchingContext1;

struct MatchingContext2 {
    int label;
    Regex * regex;
    char * lastpos;
    struct MatchingContext1 * ctx;
    struct MatchingContext2 * ctx2;
    char * str;
    int n_any;
    int firstp;
};

struct MatchingContext1 {
    int label;
    struct regexchar * re;
    char * lastpos;
    char * str;
    int iter_limit;
    int n_any;
    int firstp;
    char * end_p;
    Regex * sub_regex;
    struct MatchingContext1 * sub_ctx;
    struct MatchingContext2 * ctx2;
};


// WARNING! conflicting data type names: /DWARF/netdb.h/addrinfo - /netdb.h/addrinfo


// WARNING! conflicting data type names: /DWARF/netdb.h/hostent - /bio.h/hostent

typedef struct __jmp_buf_tag __jmp_buf_tag, *P__jmp_buf_tag;

struct __jmp_buf_tag {
    __jmp_buf __jmpbuf;
    int __mask_was_saved;
    struct __sigset_t __saved_mask;
};

typedef struct __jmp_buf_tag sigjmp_buf[1];

typedef struct param_ptr param_ptr, *Pparam_ptr;

struct param_ptr {
    char * name;
    int type;
    int inputtype;
    void * varptr;
    char * comment;
    void * select;
};

typedef struct param_section param_section, *Pparam_section;

struct param_section {
    char * name;
    struct param_ptr * params;
};

typedef struct sel_c sel_c, *Psel_c;

struct sel_c {
    int value;
    char * cvalue;
    char * text;
};

typedef struct rc_search_table rc_search_table, *Prc_search_table;

struct rc_search_table {
    struct param_ptr * param;
    short uniq_pos;
    undefined field2_0x6;
    undefined field3_0x7;
};

typedef struct parsed_tag parsed_tag, *Pparsed_tag;

struct parsed_tag {
    uchar tagid;
    undefined field1_0x1;
    undefined field2_0x2;
    undefined field3_0x3;
    uchar * attrid;
    char * * value;
    uchar * map;
    char need_reconstruct;
    undefined field8_0x11;
    undefined field9_0x12;
    undefined field10_0x13;
};

typedef struct form_select_option form_select_option, *Pform_select_option;

struct form_select_option {
    FormSelectOptionItem * first;
    FormSelectOptionItem * last;
};

typedef struct form_select_option FormSelectOption;

typedef struct _Event _Event, *P_Event;

typedef struct _Event Event;

struct _Event {
    int cmd;
    void * data;
    struct _Event * next;
};

typedef struct anon_struct_0 anon_struct_0, *Panon_struct_0;

typedef ulong GC_word;

struct anon_struct_0 {
    char * msg;
    GC_word arg;
};

typedef struct anon_struct.conflict21997 anon_struct.conflict21997, *Panon_struct.conflict21997;

typedef struct parsed_tagarg parsed_tagarg, *Pparsed_tagarg;

struct anon_struct.conflict21997 {
    char * action;
    void (* rout)(struct parsed_tagarg *);
};

struct parsed_tagarg {
    char * arg;
    char * value;
    struct parsed_tagarg * next;
};

typedef struct pre_form_item pre_form_item, *Ppre_form_item;

struct pre_form_item {
    int type;
    char * name;
    char * value;
    int checked;
    struct pre_form_item * next;
};

typedef struct pre_form pre_form, *Ppre_form;

struct pre_form {
    char * url;
    Regex * re_url;
    char * name;
    char * action;
    struct pre_form_item * item;
    struct pre_form * next;
};

typedef struct URLFile URLFile, *PURLFile;

struct URLFile {
    uchar scheme;
    char is_cgi;
    char encoding;
    undefined field3_0x3;
    InputStream stream;
    char * ext;
    int compression;
    int content_encoding;
    char * guess_type;
    char * url;
    time_t modtime;
};

typedef struct URLOption URLOption, *PURLOption;

struct URLOption {
    char * referer;
    int flag;
};

typedef struct table2 table2, *Ptable2;

struct table2 {
    char * item1;
    char * item2;
};

typedef struct html_tag_info html_tag_info, *Phtml_tag_info;

typedef struct html_tag_info TagInfo;

struct html_tag_info {
    char * name;
    uchar * accept_attribute;
    uchar max_attribute;
    uchar flag;
    undefined field4_0xa;
    undefined field5_0xb;
};

typedef struct tag_attribute_info tag_attribute_info, *Ptag_attribute_info;

struct tag_attribute_info {
    char * name;
    uchar vtype;
    uchar flag;
    undefined field3_0x6;
    undefined field4_0x7;
};

typedef struct tag_attribute_info TagAttrInfo;

typedef union anon_union.conflict33826 anon_union.conflict33826, *Panon_union.conflict33826;

union anon_union.conflict33826 {
    uint8_t __u6_addr8[16];
    uint16_t __u6_addr16[8];
    uint32_t __u6_addr32[4];
};

typedef long __fd_mask;

typedef struct fd_set fd_set, *Pfd_set;

struct fd_set {
    __fd_mask __fds_bits[32];
};

typedef int PERM;

typedef struct matrix * Matrix;

typedef struct vector * Vector;


// WARNING! conflicting data type names: /stdarg.h/__gnuc_va_list - /DWARF/stdarg.h/__gnuc_va_list


// WARNING! conflicting data type names: /time.h/timeval - /DWARF/time.h/timeval


// WARNING! conflicting data type names: /time.h/tm - /DWARF/time.h/tm


// WARNING! conflicting data type names: /sigaction.h/sigaction - /DWARF/sigaction.h/sigaction

typedef union _union_1048 _union_1048, *P_union_1048;

typedef void (* __sighandler_t)(int);

union _union_1048 {
    __sighandler_t sa_handler;
    void (* sa_sigaction)(int, siginfo_t *, void *);
};


// WARNING! conflicting data type names: /in.h/in_addr - /DWARF/in.h/in_addr


// WARNING! conflicting data type names: /pthread.h/__jmp_buf_tag - /DWARF/setjmp.h/__jmp_buf_tag


// WARNING! conflicting data type names: /sigset.h/__sigset_t - /DWARF/sigset.h/__sigset_t

typedef struct __sigset_t sigset_t;


// WARNING! conflicting data type names: /select.h/fd_set - /DWARF/select.h/fd_set

typedef int (* __compar_fn_t)(void *, void *);

typedef struct Elf32_Shdr Elf32_Shdr, *PElf32_Shdr;

typedef enum Elf_SectionHeaderType_x86 {
    SHT_NULL=0,
    SHT_PROGBITS=1,
    SHT_SYMTAB=2,
    SHT_STRTAB=3,
    SHT_RELA=4,
    SHT_HASH=5,
    SHT_DYNAMIC=6,
    SHT_NOTE=7,
    SHT_NOBITS=8,
    SHT_REL=9,
    SHT_SHLIB=10,
    SHT_DYNSYM=11,
    SHT_INIT_ARRAY=14,
    SHT_FINI_ARRAY=15,
    SHT_PREINIT_ARRAY=16,
    SHT_GROUP=17,
    SHT_SYMTAB_SHNDX=18,
    SHT_ANDROID_REL=1610612737,
    SHT_ANDROID_RELA=1610612738,
    SHT_GNU_ATTRIBUTES=1879048181,
    SHT_GNU_HASH=1879048182,
    SHT_GNU_LIBLIST=1879048183,
    SHT_CHECKSUM=1879048184,
    SHT_SUNW_move=1879048186,
    SHT_SUNW_COMDAT=1879048187,
    SHT_SUNW_syminfo=1879048188,
    SHT_GNU_verdef=1879048189,
    SHT_GNU_verneed=1879048190,
    SHT_GNU_versym=1879048191
} Elf_SectionHeaderType_x86;

struct Elf32_Shdr {
    dword sh_name;
    enum Elf_SectionHeaderType_x86 sh_type;
    dword sh_flags;
    dword sh_addr;
    dword sh_offset;
    dword sh_size;
    dword sh_link;
    dword sh_info;
    dword sh_addralign;
    dword sh_entsize;
};

typedef struct Elf32_Dyn_x86 Elf32_Dyn_x86, *PElf32_Dyn_x86;

typedef enum Elf32_DynTag_x86 {
    DT_NULL=0,
    DT_NEEDED=1,
    DT_PLTRELSZ=2,
    DT_PLTGOT=3,
    DT_HASH=4,
    DT_STRTAB=5,
    DT_SYMTAB=6,
    DT_RELA=7,
    DT_RELASZ=8,
    DT_RELAENT=9,
    DT_STRSZ=10,
    DT_SYMENT=11,
    DT_INIT=12,
    DT_FINI=13,
    DT_SONAME=14,
    DT_RPATH=15,
    DT_SYMBOLIC=16,
    DT_REL=17,
    DT_RELSZ=18,
    DT_RELENT=19,
    DT_PLTREL=20,
    DT_DEBUG=21,
    DT_TEXTREL=22,
    DT_JMPREL=23,
    DT_BIND_NOW=24,
    DT_INIT_ARRAY=25,
    DT_FINI_ARRAY=26,
    DT_INIT_ARRAYSZ=27,
    DT_FINI_ARRAYSZ=28,
    DT_RUNPATH=29,
    DT_FLAGS=30,
    DT_PREINIT_ARRAY=32,
    DT_PREINIT_ARRAYSZ=33,
    DT_RELRSZ=35,
    DT_RELR=36,
    DT_RELRENT=37,
    DT_ANDROID_REL=1610612751,
    DT_ANDROID_RELSZ=1610612752,
    DT_ANDROID_RELA=1610612753,
    DT_ANDROID_RELASZ=1610612754,
    DT_ANDROID_RELR=1879040000,
    DT_ANDROID_RELRSZ=1879040001,
    DT_ANDROID_RELRENT=1879040003,
    DT_GNU_PRELINKED=1879047669,
    DT_GNU_CONFLICTSZ=1879047670,
    DT_GNU_LIBLISTSZ=1879047671,
    DT_CHECKSUM=1879047672,
    DT_PLTPADSZ=1879047673,
    DT_MOVEENT=1879047674,
    DT_MOVESZ=1879047675,
    DT_FEATURE_1=1879047676,
    DT_POSFLAG_1=1879047677,
    DT_SYMINSZ=1879047678,
    DT_SYMINENT=1879047679,
    DT_GNU_HASH=1879047925,
    DT_TLSDESC_PLT=1879047926,
    DT_TLSDESC_GOT=1879047927,
    DT_GNU_CONFLICT=1879047928,
    DT_GNU_LIBLIST=1879047929,
    DT_CONFIG=1879047930,
    DT_DEPAUDIT=1879047931,
    DT_AUDIT=1879047932,
    DT_PLTPAD=1879047933,
    DT_MOVETAB=1879047934,
    DT_SYMINFO=1879047935,
    DT_VERSYM=1879048176,
    DT_RELACOUNT=1879048185,
    DT_RELCOUNT=1879048186,
    DT_FLAGS_1=1879048187,
    DT_VERDEF=1879048188,
    DT_VERDEFNUM=1879048189,
    DT_VERNEED=1879048190,
    DT_VERNEEDNUM=1879048191,
    DT_AUXILIARY=2147483645,
    DT_FILTER=2147483647
} Elf32_DynTag_x86;

struct Elf32_Dyn_x86 {
    enum Elf32_DynTag_x86 d_tag;
    dword d_val;
};

typedef struct Elf32_Sym Elf32_Sym, *PElf32_Sym;

struct Elf32_Sym {
    dword st_name;
    dword st_value;
    dword st_size;
    byte st_info;
    byte st_other;
    word st_shndx;
};

typedef struct Elf32_Phdr Elf32_Phdr, *PElf32_Phdr;

typedef enum Elf_ProgramHeaderType_x86 {
    PT_NULL=0,
    PT_LOAD=1,
    PT_DYNAMIC=2,
    PT_INTERP=3,
    PT_NOTE=4,
    PT_SHLIB=5,
    PT_PHDR=6,
    PT_TLS=7,
    PT_GNU_EH_FRAME=1685382480,
    PT_GNU_STACK=1685382481,
    PT_GNU_RELRO=1685382482
} Elf_ProgramHeaderType_x86;

struct Elf32_Phdr {
    enum Elf_ProgramHeaderType_x86 p_type;
    dword p_offset;
    dword p_vaddr;
    dword p_paddr;
    dword p_filesz;
    dword p_memsz;
    dword p_flags;
    dword p_align;
};

typedef struct Elf32_Rel Elf32_Rel, *PElf32_Rel;

struct Elf32_Rel {
    dword r_offset; // location to apply the relocation action
    dword r_info; // the symbol table index and the type of relocation
};

typedef struct Gnu_BuildId Gnu_BuildId, *PGnu_BuildId;

struct Gnu_BuildId {
    dword namesz; // Length of name field
    dword descsz; // Length of description field
    dword type; // Vendor specific type
    char name[4]; // Build-id vendor name
    byte description[20]; // Build-id value
};

typedef struct Elf32_Ehdr Elf32_Ehdr, *PElf32_Ehdr;

struct Elf32_Ehdr {
    byte e_ident_magic_num;
    char e_ident_magic_str[3];
    byte e_ident_class;
    byte e_ident_data;
    byte e_ident_version;
    byte e_ident_osabi;
    byte e_ident_abiversion;
    byte e_ident_pad[7];
    word e_type;
    word e_machine;
    dword e_version;
    dword e_entry;
    dword e_phoff;
    dword e_shoff;
    dword e_flags;
    word e_ehsize;
    word e_phentsize;
    word e_phnum;
    word e_shentsize;
    word e_shnum;
    word e_shstrndx;
};




int _init(EVP_PKEY_CTX *ctx)

{
  int iStack12;
  
  __gmon_start__();
  frame_dummy();
  __do_global_ctors_aux();
  return iStack12;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int fileno(FILE *__stream)

{
  int iVar1;
  
  iVar1 = fileno(__stream);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int fputs(char *__s,FILE *__stream)

{
  int iVar1;
  
  iVar1 = fputs(__s,__stream);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void abort(void)

{
                    // WARNING: Subroutine does not return
  abort();
}



// WARNING: Unknown calling convention yet parameter storage is locked

int * __errno_location(void)

{
  int *piVar1;
  
  piVar1 = __errno_location();
  return piVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int sigemptyset(sigset_t *__set)

{
  int iVar1;
  
  iVar1 = sigemptyset(__set);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * inet_ntop(int __af,void *__cp,char *__buf,socklen_t __len)

{
  char *pcVar1;
  
  pcVar1 = inet_ntop(__af,__cp,__buf,__len);
  return pcVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int sprintf(char *__s,char *__format,...)

{
  int iVar1;
  
  iVar1 = sprintf(__s,__format);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

FILE * popen(char *__command,char *__modes)

{
  FILE *pFVar1;
  
  pFVar1 = popen(__command,__modes);
  return pFVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int open(char *__file,int __oflag,...)

{
  int iVar1;
  
  iVar1 = open(__file,__oflag);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int connect(int __fd,sockaddr *__addr,socklen_t __len)

{
  int iVar1;
  
  iVar1 = connect(__fd,__addr,__len);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

__pid_t getpid(void)

{
  __pid_t _Var1;
  
  _Var1 = getpid();
  return _Var1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int mkdir(char *__path,__mode_t __mode)

{
  int iVar1;
  
  iVar1 = mkdir(__path,__mode);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void srand48(long __seedval)

{
  srand48(__seedval);
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * strerror(int __errnum)

{
  char *pcVar1;
  
  pcVar1 = strerror(__errnum);
  return pcVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int getsockname(int __fd,sockaddr *__addr,socklen_t *__len)

{
  int iVar1;
  
  iVar1 = getsockname(__fd,__addr,__len);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int memcmp(void *__s1,void *__s2,size_t __n)

{
  int iVar1;
  
  iVar1 = memcmp(__s1,__s2,__n);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void qsort(void *__base,size_t __nmemb,size_t __size,__compar_fn_t __compar)

{
  qsort(__base,__nmemb,__size,__compar);
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * inet_ntoa(in_addr __in)

{
  char *pcVar1;
  
  pcVar1 = inet_ntoa((in_addr)__in);
  return pcVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void freeaddrinfo(addrinfo *__ai)

{
  freeaddrinfo(__ai);
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void * bsearch(void *__key,void *__base,size_t __nmemb,size_t __size,__compar_fn_t __compar)

{
  void *pvVar1;
  
  pvVar1 = bsearch(__key,__base,__nmemb,__size,__compar);
  return pvVar1;
}



void tgetflag(void)

{
  tgetflag();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int __xstat(int __ver,char *__filename,stat *__stat_buf)

{
  int iVar1;
  
  iVar1 = __xstat(__ver,__filename,__stat_buf);
  return iVar1;
}



void __gmon_start__(void)

{
  __gmon_start__();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int __lxstat(int __ver,char *__filename,stat *__stat_buf)

{
  int iVar1;
  
  iVar1 = __lxstat(__ver,__filename,__stat_buf);
  return iVar1;
}



void __isoc99_sscanf(void)

{
  __isoc99_sscanf();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int vsprintf(char *__s,char *__format,__gnuc_va_list __arg)

{
  int iVar1;
  
  iVar1 = vsprintf(__s,__format,__arg);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

tm * localtime(time_t *__timer)

{
  tm *ptVar1;
  
  ptVar1 = localtime(__timer);
  return ptVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * getpass(char *__prompt)

{
  char *pcVar1;
  
  pcVar1 = getpass(__prompt);
  return pcVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * strchr(char *__s,int __c)

{
  char *pcVar1;
  
  pcVar1 = strchr(__s,__c);
  return pcVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * getenv(char *__name)

{
  char *pcVar1;
  
  pcVar1 = getenv(__name);
  return pcVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int system(char *__command)

{
  int iVar1;
  
  iVar1 = system(__command);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * strncpy(char *__dest,char *__src,size_t __n)

{
  char *pcVar1;
  
  pcVar1 = strncpy(__dest,__src,__n);
  return pcVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int putchar(int __c)

{
  int iVar1;
  
  iVar1 = putchar(__c);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * ttyname(int __fd)

{
  char *pcVar1;
  
  pcVar1 = ttyname(__fd);
  return pcVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

ssize_t write(int __fd,void *__buf,size_t __n)

{
  ssize_t sVar1;
  
  sVar1 = write(__fd,__buf,__n);
  return sVar1;
}



void GC_realloc(void)

{
  GC_realloc();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int rename(char *__old,char *__new)

{
  int iVar1;
  
  iVar1 = rename(__old,__new);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void * memset(void *__s,int __c,size_t __n)

{
  void *pvVar1;
  
  pvVar1 = memset(__s,__c,__n);
  return pvVar1;
}



void __libc_start_main(void)

{
  __libc_start_main();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int execl(char *__path,char *__arg,...)

{
  int iVar1;
  
  iVar1 = execl(__path,__arg);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int _IO_getc(_IO_FILE *__fp)

{
  int iVar1;
  
  iVar1 = _IO_getc(__fp);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

double floor(double __x)

{
  float10 extraout_ST0;
  
  floor(__x);
  return (double)extraout_ST0;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * strrchr(char *__s,int __c)

{
  char *pcVar1;
  
  pcVar1 = strrchr(__s,__c);
  return pcVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int tcgetattr(int __fd,termios *__termios_p)

{
  int iVar1;
  
  iVar1 = tcgetattr(__fd,__termios_p);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int chmod(char *__file,__mode_t __mode)

{
  int iVar1;
  
  iVar1 = chmod(__file,__mode);
  return iVar1;
}



void GC_set_warn_proc(void)

{
  GC_set_warn_proc();
  return;
}



void bindtextdomain(void)

{
  bindtextdomain();
  return;
}



void GC_malloc(void)

{
  GC_malloc();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

ssize_t read(int __fd,void *__buf,size_t __nbytes)

{
  ssize_t sVar1;
  
  sVar1 = read(__fd,__buf,__nbytes);
  return sVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

longlong strtoll(char *__nptr,char **__endptr,int __base)

{
  undefined4 extraout_EAX;
  undefined4 extraout_EDX;
  
  strtoll(__nptr,__endptr,__base);
  return CONCAT44(extraout_EDX,extraout_EAX);
}



void gettext(void)

{
  gettext();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int ungetc(int __c,FILE *__stream)

{
  int iVar1;
  
  iVar1 = ungetc(__c,__stream);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

dirent * readdir(DIR *__dirp)

{
  dirent *pdVar1;
  
  pdVar1 = readdir(__dirp);
  return pdVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

long strtol(char *__nptr,char **__endptr,int __base)

{
  long lVar1;
  
  lVar1 = strtol(__nptr,__endptr,__base);
  return lVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

FILE * fdopen(int __fd,char *__modes)

{
  FILE *pFVar1;
  
  pFVar1 = fdopen(__fd,__modes);
  return pFVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void siglongjmp(__jmp_buf_tag *__env,int __val)

{
                    // WARNING: Subroutine does not return
  siglongjmp(__env,__val);
}



void tgetent(void)

{
  tgetent();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int sigaction(int __sig,sigaction *__act,sigaction *__oact)

{
  int iVar1;
  
  iVar1 = sigaction(__sig,__act,__oact);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int fflush(FILE *__stream)

{
  int iVar1;
  
  iVar1 = fflush(__stream);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

double sqrt(double __x)

{
  float10 extraout_ST0;
  
  sqrt(__x);
  return (double)extraout_ST0;
}



// WARNING: Unknown calling convention yet parameter storage is locked

DIR * opendir(char *__name)

{
  DIR *pDVar1;
  
  pDVar1 = opendir(__name);
  return pDVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int symlink(char *__from,char *__to)

{
  int iVar1;
  
  iVar1 = symlink(__from,__to);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int ioctl(int __fd,ulong __request,...)

{
  int iVar1;
  
  iVar1 = ioctl(__fd,__request);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int socket(int __domain,int __type,int __protocol)

{
  int iVar1;
  
  iVar1 = socket(__domain,__type,__protocol);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int dup2(int __fd,int __fd2)

{
  int iVar1;
  
  iVar1 = dup2(__fd,__fd2);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int fseek(FILE *__stream,long __off,int __whence)

{
  int iVar1;
  
  iVar1 = fseek(__stream,__off,__whence);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int execlp(char *__file,char *__arg,...)

{
  int iVar1;
  
  iVar1 = execlp(__file,__arg);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int isatty(int __fd)

{
  int iVar1;
  
  iVar1 = isatty(__fd);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int getaddrinfo(char *__name,char *__service,addrinfo *__req,addrinfo **__pai)

{
  int iVar1;
  
  iVar1 = getaddrinfo(__name,__service,__req,__pai);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int fclose(FILE *__stream)

{
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



// WARNING: Unknown calling convention yet parameter storage is locked

void bcopy(void *__src,void *__dest,size_t __n)

{
  bcopy(__src,__dest,__n);
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int dup(int __fd)

{
  int iVar1;
  
  iVar1 = dup(__fd);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

time_t mktime(tm *__tp)

{
  time_t tVar1;
  
  tVar1 = mktime(__tp);
  return tVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void * memcpy(void *__dest,void *__src,size_t __n)

{
  void *pvVar1;
  
  pvVar1 = memcpy(__dest,__src,__n);
  return pvVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int utime(char *__file,utimbuf *__file_times)

{
  int iVar1;
  
  iVar1 = utime(__file,__file_times);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

size_t strlen(char *__s)

{
  size_t sVar1;
  
  sVar1 = strlen(__s);
  return sVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

FILE * fopen(char *__filename,char *__modes)

{
  FILE *pFVar1;
  
  pFVar1 = fopen(__filename,__modes);
  return pFVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

uint alarm(uint __seconds)

{
  uint uVar1;
  
  uVar1 = alarm(__seconds);
  return uVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int unlink(char *__name)

{
  int iVar1;
  
  iVar1 = unlink(__name);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

passwd * getpwuid(__uid_t __uid)

{
  passwd *ppVar1;
  
  ppVar1 = getpwuid(__uid);
  return ppVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

FILE * freopen(char *__filename,char *__modes,FILE *__stream)

{
  FILE *pFVar1;
  
  pFVar1 = freopen(__filename,__modes,__stream);
  return pFVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * setlocale(int __category,char *__locale)

{
  char *pcVar1;
  
  pcVar1 = setlocale(__category,__locale);
  return pcVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

__pid_t waitpid(__pid_t __pid,int *__stat_loc,int __options)

{
  __pid_t _Var1;
  
  _Var1 = waitpid(__pid,__stat_loc,__options);
  return _Var1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int fgetc(FILE *__stream)

{
  int iVar1;
  
  iVar1 = fgetc(__stream);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int feof(FILE *__stream)

{
  int iVar1;
  
  iVar1 = feof(__stream);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * strcpy(char *__dest,char *__src)

{
  char *pcVar1;
  
  pcVar1 = strcpy(__dest,__src);
  return pcVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

__gid_t getegid(void)

{
  __gid_t _Var1;
  
  _Var1 = getegid();
  return _Var1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int printf(char *__format,...)

{
  int iVar1;
  
  iVar1 = printf(__format);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int chdir(char *__path)

{
  int iVar1;
  
  iVar1 = chdir(__path);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * ctime(time_t *__timer)

{
  char *pcVar1;
  
  pcVar1 = ctime(__timer);
  return pcVar1;
}



void tputs(void)

{
  tputs();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

__uid_t getuid(void)

{
  __uid_t _Var1;
  
  _Var1 = getuid();
  return _Var1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

long atol(char *__nptr)

{
  long lVar1;
  
  lVar1 = atol(__nptr);
  return lVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

long lrand48(void)

{
  long lVar1;
  
  lVar1 = lrand48();
  return lVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

hostent * gethostbyaddr(void *__addr,__socklen_t __len,int __type)

{
  hostent *phVar1;
  
  phVar1 = gethostbyaddr(__addr,__len,__type);
  return phVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int atoi(char *__nptr)

{
  int iVar1;
  
  iVar1 = atoi(__nptr);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int strcasecmp(char *__s1,char *__s2)

{
  int iVar1;
  
  iVar1 = strcasecmp(__s1,__s2);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

double atof(char *__nptr)

{
  float10 extraout_ST0;
  
  atof(__nptr);
  return (double)extraout_ST0;
}



void GC_free(void)

{
  GC_free();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int select(int __nfds,fd_set *__readfds,fd_set *__writefds,fd_set *__exceptfds,timeval *__timeout)

{
  int iVar1;
  
  iVar1 = select(__nfds,__readfds,__writefds,__exceptfds,__timeout);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int closedir(DIR *__dirp)

{
  int iVar1;
  
  iVar1 = closedir(__dirp);
  return iVar1;
}



void Gpm_Wgetch(void)

{
  Gpm_Wgetch();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int close(int __fd)

{
  int iVar1;
  
  iVar1 = close(__fd);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

size_t fwrite(void *__ptr,size_t __size,size_t __n,FILE *__s)

{
  size_t sVar1;
  
  sVar1 = fwrite(__ptr,__size,__n,__s);
  return sVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int fprintf(FILE *__stream,char *__format,...)

{
  int iVar1;
  
  iVar1 = fprintf(__stream,__format);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * strstr(char *__haystack,char *__needle)

{
  char *pcVar1;
  
  pcVar1 = strstr(__haystack,__needle);
  return pcVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

time_t time(time_t *__timer)

{
  time_t tVar1;
  
  tVar1 = time(__timer);
  return tVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * nl_langinfo(nl_item __item)

{
  char *pcVar1;
  
  pcVar1 = nl_langinfo(__item);
  return pcVar1;
}



void __stack_chk_fail(void)

{
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void Gpm_Close(void)

{
  Gpm_Close();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int gethostname(char *__name,size_t __len)

{
  int iVar1;
  
  iVar1 = gethostname(__name,__len);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

double atan2(double __y,double __x)

{
  float10 extraout_ST0;
  
  atan2(__y,__x);
  return (double)extraout_ST0;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int fputc(int __c,FILE *__stream)

{
  int iVar1;
  
  iVar1 = fputc(__c,__stream);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * strtok(char *__s,char *__delim)

{
  char *pcVar1;
  
  pcVar1 = strtok(__s,__delim);
  return pcVar1;
}



void tgoto(void)

{
  tgoto();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * strcasestr(char *__haystack,char *__needle)

{
  char *pcVar1;
  
  pcVar1 = strcasestr(__haystack,__needle);
  return pcVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

uint sleep(uint __seconds)

{
  uint uVar1;
  
  uVar1 = sleep(__seconds);
  return uVar1;
}



void tgetnum(void)

{
  tgetnum();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

ssize_t readlink(char *__path,char *__buf,size_t __len)

{
  ssize_t sVar1;
  
  sVar1 = readlink(__path,__buf,__len);
  return sVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int strncasecmp(char *__s1,char *__s2,size_t __n)

{
  int iVar1;
  
  iVar1 = strncasecmp(__s1,__s2,__n);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int getnameinfo(sockaddr *__sa,socklen_t __salen,char *__host,socklen_t __hostlen,char *__serv,
               socklen_t __servlen,uint __flags)

{
  int iVar1;
  
  iVar1 = getnameinfo(__sa,__salen,__host,__hostlen,__serv,__servlen,__flags);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * strcat(char *__dest,char *__src)

{
  char *pcVar1;
  
  pcVar1 = strcat(__dest,__src);
  return pcVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * getcwd(char *__buf,size_t __size)

{
  char *pcVar1;
  
  pcVar1 = getcwd(__buf,__size);
  return pcVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

double log(double __x)

{
  float10 extraout_ST0;
  
  log(__x);
  return (double)extraout_ST0;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int puts(char *__s)

{
  int iVar1;
  
  iVar1 = puts(__s);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

__pid_t fork(void)

{
  __pid_t _Var1;
  
  _Var1 = fork();
  return _Var1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int setpgrp(void)

{
  int iVar1;
  
  iVar1 = setpgrp();
  return iVar1;
}



void textdomain(void)

{
  textdomain();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int tcsetattr(int __fd,int __optional_actions,termios *__termios_p)

{
  int iVar1;
  
  iVar1 = tcsetattr(__fd,__optional_actions,__termios_p);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void bzero(void *__s,size_t __n)

{
  bzero(__s,__n);
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

size_t strspn(char *__s,char *__accept)

{
  size_t sVar1;
  
  sVar1 = strspn(__s,__accept);
  return sVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int sscanf(char *__s,char *__format,...)

{
  int iVar1;
  
  iVar1 = sscanf(__s,__format);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int __fxstat(int __ver,int __fildes,stat *__stat_buf)

{
  int iVar1;
  
  iVar1 = __fxstat(__ver,__fildes,__stat_buf);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

tm * gmtime(time_t *__timer)

{
  tm *ptVar1;
  
  ptVar1 = gmtime(__timer);
  return ptVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int fscanf(FILE *__stream,char *__format,...)

{
  int iVar1;
  
  iVar1 = fscanf(__stream,__format);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void * memchr(void *__s,int __c,size_t __n)

{
  void *pvVar1;
  
  pvVar1 = memchr(__s,__c,__n);
  return pvVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int strncmp(char *__s1,char *__s2,size_t __n)

{
  int iVar1;
  
  iVar1 = strncmp(__s1,__s2,__n);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int _IO_putc(int __c,_IO_FILE *__fp)

{
  int iVar1;
  
  iVar1 = _IO_putc(__c,__fp);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int pipe(int *__pipedes)

{
  int iVar1;
  
  iVar1 = pipe(__pipedes);
  return iVar1;
}



void Gpm_Open(void)

{
  Gpm_Open();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

size_t fread(void *__ptr,size_t __size,size_t __n,FILE *__stream)

{
  size_t sVar1;
  
  sVar1 = fread(__ptr,__size,__n,__stream);
  return sVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

size_t strftime(char *__s,size_t __maxsize,char *__format,tm *__tp)

{
  size_t sVar1;
  
  sVar1 = strftime(__s,__maxsize,__format,__tp);
  return sVar1;
}



void GC_malloc_atomic(void)

{
  GC_malloc_atomic();
  return;
}



void tgetstr(void)

{
  tgetstr();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int kill(__pid_t __pid,int __sig)

{
  int iVar1;
  
  iVar1 = kill(__pid,__sig);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

size_t strcspn(char *__s,char *__reject)

{
  size_t sVar1;
  
  sVar1 = strcspn(__s,__reject);
  return sVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

char * strdup(char *__s)

{
  char *pcVar1;
  
  pcVar1 = strdup(__s);
  return pcVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int getpeername(int __fd,sockaddr *__addr,socklen_t *__len)

{
  int iVar1;
  
  iVar1 = getpeername(__fd,__addr,__len);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int ferror(FILE *__stream)

{
  int iVar1;
  
  iVar1 = ferror(__stream);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

passwd * getpwnam(char *__name)

{
  passwd *ppVar1;
  
  ppVar1 = getpwnam(__name);
  return ppVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int tolower(int __c)

{
  int iVar1;
  
  iVar1 = tolower(__c);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int strcmp(char *__s1,char *__s2)

{
  int iVar1;
  
  iVar1 = strcmp(__s1,__s2);
  return iVar1;
}



void __sigsetjmp(void)

{
  __sigsetjmp();
  return;
}



// WARNING: Unknown calling convention yet parameter storage is locked

int setenv(char *__name,char *__value,int __replace)

{
  int iVar1;
  
  iVar1 = setenv(__name,__value,__replace);
  return iVar1;
}



// WARNING: Unknown calling convention yet parameter storage is locked

void exit(int __status)

{
                    // WARNING: Subroutine does not return
  exit(__status);
}



// WARNING: Unknown calling convention yet parameter storage is locked

int pclose(FILE *__stream)

{
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



// WARNING: Unknown calling convention yet parameter storage is locked

double ceil(double __x)

{
  float10 extraout_ST0;
  
  ceil(__x);
  return (double)extraout_ST0;
}



// WARNING: Unknown calling convention yet parameter storage is locked

__uid_t geteuid(void)

{
  __uid_t _Var1;
  
  _Var1 = geteuid();
  return _Var1;
}



void _start(void)

{
  __libc_start_main(main);
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



// WARNING: Removing unreachable block (ram,0x0804a67a)
// WARNING: Removing unreachable block (ram,0x0804a680)

void __do_global_dtors_aux(void)

{
  if (completed_7065 == '\0') {
    completed_7065 = '\x01';
  }
  return;
}



// WARNING: Removing unreachable block (ram,0x0804a6c8)

void frame_dummy(void)

{
  return;
}



void fversion(FILE *f)

{
  fprintf((FILE *)f,"w3m version %s, options %s\n",w3m_version,
          "lang=en,m17n,image,color,ansi-color,mouse,gpm,menu,cookie,external-uri-loader,w3mmailer,nntp,gopher,ipv6,alarm,mark,migemo"
         );
  return;
}



void fusage(FILE *f,int err)

{
  fversion(f);
  fwrite("usage: w3m [options] [URL or filename]\noptions:\n",1,0x30,(FILE *)f);
  fwrite("    -t tab           set tab width\n",1,0x23,(FILE *)f);
  fwrite("    -r               ignore backspace effect\n",1,0x2d,(FILE *)f);
  fwrite("    -l line          # of preserved line (default 10000)\n",1,0x39,(FILE *)f);
  fwrite("    -I charset       document charset\n",1,0x26,(FILE *)f);
  fwrite("    -O charset       display/output charset\n",1,0x2c,(FILE *)f);
  fwrite("    -B               load bookmark\n",1,0x23,(FILE *)f);
  fwrite("    -bookmark file   specify bookmark file\n",1,0x2b,(FILE *)f);
  fwrite("    -T type          specify content-type\n",1,0x2a,(FILE *)f);
  fwrite("    -m               internet message mode\n",1,0x2b,(FILE *)f);
  fwrite("    -v               visual startup mode\n",1,0x29,(FILE *)f);
  fwrite("    -M               monochrome display\n",1,0x28,(FILE *)f);
  fwrite("    -N               open URL of command line on each new tab\n",1,0x3e,(FILE *)f);
  fwrite("    -F               automatically render frame\n",1,0x30,(FILE *)f);
  fwrite("    -cols width      specify column width (used with -dump)\n",1,0x3c,(FILE *)f);
  fwrite("    -ppc count       specify the number of pixels per character (4.0...32.0)\n",1,0x4d,
         (FILE *)f);
  fwrite("    -ppl count       specify the number of pixels per line (4.0...64.0)\n",1,0x48,
         (FILE *)f);
  fwrite("    -dump            dump formatted page into stdout\n",1,0x35,(FILE *)f);
  fwrite("    -dump_head       dump response of HEAD request into stdout\n",1,0x3f,(FILE *)f);
  fwrite("    -dump_source     dump page source into stdout\n",1,0x32,(FILE *)f);
  fwrite("    -dump_both       dump HEAD and source into stdout\n",1,0x36,(FILE *)f);
  fwrite("    -dump_extra      dump HEAD, source, and extra information into stdout\n",1,0x4a,
         (FILE *)f);
  fwrite("    -post file       use POST method with file content\n",1,0x37,(FILE *)f);
  fwrite("    -header string   insert string as a header\n",1,0x2f,(FILE *)f);
  fwrite("    +<num>           goto <num> line\n",1,0x25,(FILE *)f);
  fwrite("    -num             show line number\n",1,0x26,(FILE *)f);
  fwrite("    -no-proxy        don\'t use proxy\n",1,0x25,(FILE *)f);
  fwrite("    -4               IPv4 only (-o dns_order=4)\n",1,0x30,(FILE *)f);
  fwrite("    -6               IPv6 only (-o dns_order=6)\n",1,0x30,(FILE *)f);
  fwrite("    -no-mouse        don\'t use mouse\n",1,0x25,(FILE *)f);
  fwrite("    -cookie          use cookie (-no-cookie: don\'t use cookie)\n",1,0x3f,(FILE *)f);
  fwrite("    -pauth user:pass proxy authentication\n",1,0x2a,(FILE *)f);
  fwrite("    -graph           use graphic character\n",1,0x2b,(FILE *)f);
  fwrite("    -no-graph        don\'t use graphic character\n",1,0x31,(FILE *)f);
  fwrite("    -s               squeeze multiple blank lines\n",1,0x32,(FILE *)f);
  fwrite("    -W               toggle wrap search mode\n",1,0x2d,(FILE *)f);
  fwrite("    -X               don\'t use termcap init/deinit\n",1,0x33,(FILE *)f);
  fwrite("    -title[=TERM]    set buffer name to terminal title string\n",1,0x3e,(FILE *)f);
  fwrite("    -o opt=value     assign value to config option\n",1,0x33,(FILE *)f);
  fwrite("    -show-option     print all config options\n",1,0x2e,(FILE *)f);
  fwrite("    -config file     specify config file\n",1,0x29,(FILE *)f);
  fwrite("    -help            print this usage message\n",1,0x2e,(FILE *)f);
  fwrite("    -version         print w3m version\n",1,0x27,(FILE *)f);
  fwrite("    -reqlog          write request logfile\n",1,0x2b,(FILE *)f);
  fwrite("    -debug           DO NOT USE\n",1,0x20,(FILE *)f);
  if (show_params_p != 0) {
    show_params(f);
  }
                    // WARNING: Subroutine does not return
  exit(err);
}



void wrap_GC_warn_proc(char *param_1,GC_word param_2)

{
  uint uVar1;
  
  if (fmInitialized == '\0') {
    if (orig_GC_warn_proc == (GC_warn_proc *)0x0) {
      fprintf(stderr,param_1,param_2);
    }
    else {
      (*orig_GC_warn_proc)(param_1,param_2);
    }
  }
  else {
    uVar1 = (wrap_GC_warn_proc::lexical_block_0::i + wrap_GC_warn_proc::lexical_block_0::n) % 0x14;
    wrap_GC_warn_proc::lexical_block_0::msg_ring[uVar1].msg = param_1;
    wrap_GC_warn_proc::lexical_block_0::msg_ring[uVar1].arg = param_2;
    if (wrap_GC_warn_proc::lexical_block_0::n < 0x14) {
      wrap_GC_warn_proc::lexical_block_0::n = wrap_GC_warn_proc::lexical_block_0::n + 1;
    }
    else {
      wrap_GC_warn_proc::lexical_block_0::i = wrap_GC_warn_proc::lexical_block_0::i + 1;
    }
    if (wrap_GC_warn_proc::lexical_block_0::lock == 0) {
      wrap_GC_warn_proc::lexical_block_0::lock = 1;
      for (; 0 < (int)wrap_GC_warn_proc::lexical_block_0::n;
          wrap_GC_warn_proc::lexical_block_0::n = wrap_GC_warn_proc::lexical_block_0::n - 1) {
        wrap_GC_warn_proc::lexical_block_0::i = wrap_GC_warn_proc::lexical_block_0::i % 0x14;
        printf(wrap_GC_warn_proc::lexical_block_0::msg_ring[wrap_GC_warn_proc::lexical_block_0::i].
               msg,wrap_GC_warn_proc::lexical_block_0::msg_ring
                   [wrap_GC_warn_proc::lexical_block_0::i].arg);
        sleep_till_anykey(1,1);
        wrap_GC_warn_proc::lexical_block_0::i = wrap_GC_warn_proc::lexical_block_0::i + 1;
      }
      wrap_GC_warn_proc::lexical_block_0::lock = 0;
    }
  }
  return;
}



void sig_chld(int signo)

{
  __pid_t _Var1;
  pid_t pid;
  int p_stat;
  
  do {
    _Var1 = waitpid(-1,&p_stat,1);
  } while (0 < _Var1);
  mySignal(0x11,sig_chld);
  return;
}



Str make_optional_header_string(char *s)

{
  char *pcVar1;
  Str x;
  size_t sVar2;
  int iVar3;
  Str hs;
  char *p;
  
  pcVar1 = strchr(s,10);
  if ((pcVar1 == (char *)0x0) && (pcVar1 = strchr(s,0xd), pcVar1 == (char *)0x0)) {
    for (p = s; (*p != '\0' && (*p != ':')); p = p + 1) {
    }
    if ((*p == ':') && (p != s)) {
      sVar2 = strlen(s);
      x = Strnew_size(sVar2 + 3);
      Strcopy_charp_n(x,s,(int)p - (int)s);
      iVar3 = strcasecmp(x->ptr,"content-type");
      if (iVar3 == 0) {
        override_content_type = 1;
      }
      Strcat_charp(x,": ");
      p = p + 1;
      if (*p != '\0') {
        while ((*p != '\0' && ((MYCTYPE_MAP[(byte)*p] & 2) != 0))) {
          p = p + 1;
        }
        Strcat_charp(x,p);
      }
      Strcat_charp(x,"\r\n");
    }
    else {
      x = (Str)0x0;
    }
  }
  else {
    x = (Str)0x0;
  }
  return x;
}



int main(int argc,char **argv,char **envp)

{
  Anchor *pAVar1;
  bool bVar2;
  bool bVar3;
  bool bVar4;
  wc_ces t_ces;
  wc_ces f_ces;
  wc_uint8 wVar5;
  char cVar6;
  int iVar7;
  int iVar8;
  char *pcVar9;
  Str p_Var10;
  FILE *f;
  InputStream stream;
  FormList *request_00;
  Str p_Var11;
  TabBuffer *pTVar12;
  Buffer *pBVar13;
  uint uVar14;
  double dVar15;
  double ppc_1;
  double ppc;
  Anchor *a;
  Str body;
  FILE *fp;
  Str s_page;
  Str hs;
  Str tmp;
  char *Locale;
  Str err_msg;
  char *post_file;
  char *default_type;
  int open_new_tab;
  int visual_start;
  int load_bookmark;
  int load_argc;
  FormList *request;
  char **load_argv;
  char *line_str;
  InputStream redin;
  int i;
  char *p;
  Buffer *newbuf;
  wc_uint8 auto_detect;
  char search_header;
  char c;
  FILE *local_70;
  char *local_60;
  char *local_58;
  char *local_54;
  int local_44;
  form_list *local_40;
  char *local_38;
  int local_30;
  char *local_2c;
  Buffer *local_28;
  char local_22;
  
  local_28 = (_Buffer *)0x0;
  local_38 = (char *)0x0;
  bVar2 = false;
  bVar3 = false;
  bVar4 = false;
  local_22 = '\0';
  local_54 = (char *)0x0;
  local_58 = (char *)0x0;
  setlocale(6,"");
  bindtextdomain(&DAT_080c7e63,"/usr/share/locale");
  textdomain(&DAT_080c7e63);
  NO_proxy_domains = (TextList *)newGeneralList();
  fileToDelete = (TextList *)newGeneralList();
  iVar7 = GC_malloc((argc + -1) * 4);
  local_44 = 0;
  CurrentDir = currentdir();
  CurrentPid = getpid();
  BookmarkFile = (char *)0x0;
  config_file = (char *)0x0;
  for (local_30 = 1; local_30 < argc; local_30 = local_30 + 1) {
    if (*argv[local_30] == '-') {
      iVar8 = strcmp("-config",argv[local_30]);
      if (iVar8 == 0) {
        argv[local_30] = "-dummy";
        local_30 = local_30 + 1;
        if (argc <= local_30) {
          fusage((FILE *)stderr,1);
        }
        config_file = argv[local_30];
        argv[local_30] = "-dummy";
      }
      else {
        iVar8 = strcmp("-h",argv[local_30]);
        if ((iVar8 == 0) || (iVar8 = strcmp("-help",argv[local_30]), iVar8 == 0)) {
          fusage(stdout,0);
        }
        else {
          iVar8 = strcmp("-V",argv[local_30]);
          if ((iVar8 == 0) || (iVar8 = strcmp("-version",argv[local_30]), iVar8 == 0)) {
            fversion(stdout);
                    // WARNING: Subroutine does not return
            exit(0);
          }
        }
      }
    }
  }
  local_60 = getenv("LC_ALL");
  iVar8 = non_null(local_60);
  if (iVar8 == 0) {
    local_60 = getenv("LC_CTYPE");
    iVar8 = non_null(local_60);
    if (iVar8 == 0) {
      local_60 = getenv("LANG");
      iVar8 = non_null(local_60);
      if (iVar8 == 0) goto LAB_0804b3a3;
    }
  }
  DisplayCharset = wc_guess_locale_charset(local_60,DisplayCharset);
  DocumentCharset = wc_guess_locale_charset(local_60,DocumentCharset);
  SystemCharset = wc_guess_locale_charset(local_60,SystemCharset);
LAB_0804b3a3:
  init_rc();
  LoadHist = newHist();
  SaveHist = newHist();
  ShellHist = newHist();
  TextHist = newHist();
  URLHist = newHist();
  if ((FollowLocale != '\0') && (local_60 != (char *)0x0)) {
    DisplayCharset = wc_guess_locale_charset(local_60,DisplayCharset);
    SystemCharset = wc_guess_locale_charset(local_60,SystemCharset);
  }
  wVar5 = WcOption.auto_detect;
  BookmarkCharset = DocumentCharset;
  iVar8 = non_null(HTTP_proxy);
  if ((iVar8 == 0) &&
     (((local_2c = getenv("HTTP_PROXY"), local_2c != (char *)0x0 ||
       (local_2c = getenv("http_proxy"), local_2c != (char *)0x0)) ||
      (local_2c = getenv("HTTP_proxy"), local_2c != (char *)0x0)))) {
    HTTP_proxy = local_2c;
  }
  iVar8 = non_null(GOPHER_proxy);
  if ((iVar8 == 0) &&
     (((local_2c = getenv("GOPHER_PROXY"), local_2c != (char *)0x0 ||
       (local_2c = getenv("gopher_proxy"), local_2c != (char *)0x0)) ||
      (local_2c = getenv("GOPHER_proxy"), local_2c != (char *)0x0)))) {
    GOPHER_proxy = local_2c;
  }
  iVar8 = non_null(FTP_proxy);
  if ((iVar8 == 0) &&
     (((local_2c = getenv("FTP_PROXY"), local_2c != (char *)0x0 ||
       (local_2c = getenv("ftp_proxy"), local_2c != (char *)0x0)) ||
      (local_2c = getenv("FTP_proxy"), local_2c != (char *)0x0)))) {
    FTP_proxy = local_2c;
  }
  iVar8 = non_null(NO_proxy);
  if ((iVar8 == 0) &&
     (((local_2c = getenv("NO_PROXY"), local_2c != (char *)0x0 ||
       (local_2c = getenv("no_proxy"), local_2c != (char *)0x0)) ||
      (local_2c = getenv("NO_proxy"), local_2c != (char *)0x0)))) {
    NO_proxy = local_2c;
  }
  iVar8 = non_null(NNTP_server);
  if ((iVar8 == 0) && (pcVar9 = getenv("NNTPSERVER"), pcVar9 != (char *)0x0)) {
    NNTP_server = pcVar9;
  }
  iVar8 = non_null(NNTP_mode);
  if ((iVar8 == 0) && (pcVar9 = getenv("NNTPMODE"), pcVar9 != (char *)0x0)) {
    NNTP_mode = pcVar9;
  }
  iVar8 = non_null(Editor);
  if ((iVar8 == 0) && (pcVar9 = getenv("EDITOR"), pcVar9 != (char *)0x0)) {
    Editor = pcVar9;
  }
  iVar8 = non_null(Mailer);
  if ((iVar8 == 0) && (pcVar9 = getenv("MAILER"), pcVar9 != (char *)0x0)) {
    Mailer = pcVar9;
  }
  for (local_30 = 1; local_30 < argc; local_30 = local_30 + 1) {
    if (*argv[local_30] == '-') {
      iVar8 = strcmp("-t",argv[local_30]);
      if (iVar8 == 0) {
        local_30 = local_30 + 1;
        if (argc <= local_30) {
          fusage((FILE *)stderr,1);
        }
        iVar8 = atoi(argv[local_30]);
        if (0 < iVar8) {
          Tabstop = atoi(argv[local_30]);
        }
      }
      else {
        iVar8 = strcmp("-r",argv[local_30]);
        if (iVar8 == 0) {
          ShowEffect = 0;
        }
        else {
          iVar8 = strcmp("-l",argv[local_30]);
          if (iVar8 == 0) {
            local_30 = local_30 + 1;
            if (argc <= local_30) {
              fusage((FILE *)stderr,1);
            }
            iVar8 = atoi(argv[local_30]);
            if (0 < iVar8) {
              PagerMax = atoi(argv[local_30]);
            }
          }
          else {
            iVar8 = strncmp("-I",argv[local_30],2);
            if (iVar8 == 0) {
              if (argv[local_30][2] == '\0') {
                local_30 = local_30 + 1;
                if (argc <= local_30) {
                  fusage((FILE *)stderr,1);
                }
                local_2c = argv[local_30];
              }
              else {
                local_2c = argv[local_30] + 2;
              }
              DocumentCharset = wc_guess_charset_short(local_2c,DocumentCharset);
              WcOption.auto_detect = '\0';
              UseContentCharset = '\0';
            }
            else {
              iVar8 = strncmp("-O",argv[local_30],2);
              if (iVar8 == 0) {
                if (argv[local_30][2] == '\0') {
                  local_30 = local_30 + 1;
                  if (argc <= local_30) {
                    fusage((FILE *)stderr,1);
                  }
                  local_2c = argv[local_30];
                }
                else {
                  local_2c = argv[local_30] + 2;
                }
                DisplayCharset = wc_guess_charset_short(local_2c,DisplayCharset);
              }
              else {
                iVar8 = strcmp("-graph",argv[local_30]);
                if (iVar8 == 0) {
                  UseGraphicChar = '\x01';
                }
                else {
                  iVar8 = strcmp("-no-graph",argv[local_30]);
                  if (iVar8 == 0) {
                    UseGraphicChar = '\0';
                  }
                  else {
                    iVar8 = strcmp("-T",argv[local_30]);
                    if (iVar8 == 0) {
                      local_30 = local_30 + 1;
                      if (argc <= local_30) {
                        fusage((FILE *)stderr,1);
                      }
                      DefaultType = argv[local_30];
                      local_54 = DefaultType;
                    }
                    else {
                      iVar8 = strcmp("-m",argv[local_30]);
                      if (iVar8 == 0) {
                        local_22 = '\x01';
                        SearchHeader = '\x01';
                      }
                      else {
                        iVar8 = strcmp("-v",argv[local_30]);
                        if (iVar8 == 0) {
                          bVar3 = true;
                        }
                        else {
                          iVar8 = strcmp("-N",argv[local_30]);
                          if (iVar8 == 0) {
                            bVar4 = true;
                          }
                          else {
                            iVar8 = strcmp("-M",argv[local_30]);
                            if (iVar8 == 0) {
                              useColor = 0;
                            }
                            else {
                              iVar8 = strcmp("-B",argv[local_30]);
                              if (iVar8 == 0) {
                                bVar2 = true;
                              }
                              else {
                                iVar8 = strcmp("-bookmark",argv[local_30]);
                                if (iVar8 == 0) {
                                  local_30 = local_30 + 1;
                                  if (argc <= local_30) {
                                    fusage((FILE *)stderr,1);
                                  }
                                  BookmarkFile = argv[local_30];
                                  if ((*BookmarkFile != '~') && (*BookmarkFile != '/')) {
                                    p_Var10 = Strnew_charp(CurrentDir);
                                    if ((p_Var10->length < 1) ||
                                       (p_Var10->ptr[p_Var10->length + -1] != '/')) {
                                      if (p_Var10->area_size <= p_Var10->length + 1) {
                                        Strgrow(p_Var10);
                                      }
                                      iVar8 = p_Var10->length;
                                      p_Var10->ptr[iVar8] = '/';
                                      p_Var10->length = iVar8 + 1;
                                      p_Var10->ptr[p_Var10->length] = '\0';
                                    }
                                    Strcat_charp(p_Var10,BookmarkFile);
                                    BookmarkFile = cleanupName(p_Var10->ptr);
                                  }
                                }
                                else {
                                  iVar8 = strcmp("-F",argv[local_30]);
                                  if (iVar8 == 0) {
                                    RenderFrame = '\x01';
                                  }
                                  else {
                                    iVar8 = strcmp("-W",argv[local_30]);
                                    if (iVar8 == 0) {
                                      if (WrapDefault == 0) {
                                        WrapDefault = 1;
                                      }
                                      else {
                                        WrapDefault = 0;
                                      }
                                    }
                                    else {
                                      iVar8 = strcmp("-dump",argv[local_30]);
                                      if (iVar8 == 0) {
                                        w3m_dump = 1;
                                      }
                                      else {
                                        iVar8 = strcmp("-dump_source",argv[local_30]);
                                        if (iVar8 == 0) {
                                          w3m_dump = 4;
                                        }
                                        else {
                                          iVar8 = strcmp("-dump_head",argv[local_30]);
                                          if (iVar8 == 0) {
                                            w3m_dump = 2;
                                          }
                                          else {
                                            iVar8 = strcmp("-dump_both",argv[local_30]);
                                            if (iVar8 == 0) {
                                              w3m_dump = 6;
                                            }
                                            else {
                                              iVar8 = strcmp("-dump_extra",argv[local_30]);
                                              if (iVar8 == 0) {
                                                w3m_dump = 0xe;
                                              }
                                              else {
                                                iVar8 = strcmp("-halfdump",argv[local_30]);
                                                if (iVar8 == 0) {
                                                  w3m_dump = 0x10;
                                                }
                                                else {
                                                  iVar8 = strcmp("-halfload",argv[local_30]);
                                                  if (iVar8 == 0) {
                                                    w3m_dump = 0;
                                                    w3m_halfload = 1;
                                                    local_54 = "text/html";
                                                    DefaultType = "text/html";
                                                  }
                                                  else {
                                                    iVar8 = strcmp("-backend",argv[local_30]);
                                                    if (iVar8 == 0) {
                                                      w3m_backend = 1;
                                                    }
                                                    else {
                                                      iVar8 = strcmp("-backend_batch",argv[local_30]
                                                                    );
                                                      if (iVar8 == 0) {
                                                        w3m_backend = 1;
                                                        local_30 = local_30 + 1;
                                                        if (argc <= local_30) {
                                                          fusage((FILE *)stderr,1);
                                                        }
                                                        if (backend_batch_commands ==
                                                            (TextList *)0x0) {
                                                          backend_batch_commands =
                                                               (TextList *)newGeneralList();
                                                        }
                                                        pcVar9 = allocStr(argv[local_30],-1);
                                                        pushValue((GeneralList *)
                                                                  backend_batch_commands,pcVar9);
                                                      }
                                                      else {
                                                        iVar8 = strcmp("-cols",argv[local_30]);
                                                        if (iVar8 == 0) {
                                                          local_30 = local_30 + 1;
                                                          if (argc <= local_30) {
                                                            fusage((FILE *)stderr,1);
                                                          }
                                                          COLS = atoi(argv[local_30]);
                                                        }
                                                        else {
                                                          iVar8 = strcmp("-ppc",argv[local_30]);
                                                          if (iVar8 == 0) {
                                                            local_30 = local_30 + 1;
                                                            if (argc <= local_30) {
                                                              fusage((FILE *)stderr,1);
                                                            }
                                                            dVar15 = atof(argv[local_30]);
                                                            if ((4.0 <= dVar15) && (dVar15 <= 32.0))
                                                            {
                                                              set_pixel_per_char = 1;
                                                              pixel_per_char = dVar15;
                                                            }
                                                          }
                                                          else {
                                                            iVar8 = strcmp("-ppl",argv[local_30]);
                                                            if (iVar8 == 0) {
                                                              local_30 = local_30 + 1;
                                                              if (argc <= local_30) {
                                                                fusage((FILE *)stderr,1);
                                                              }
                                                              dVar15 = atof(argv[local_30]);
                                                              if ((4.0 <= dVar15) &&
                                                                 (dVar15 <= 64.0)) {
                                                                set_pixel_per_line = 1;
                                                                pixel_per_line = dVar15;
                                                              }
                                                            }
                                                            else {
                                                              iVar8 = strcmp("-num",argv[local_30]);
                                                              if (iVar8 == 0) {
                                                                showLineNum = 1;
                                                              }
                                                              else {
                                                                iVar8 = strcmp("-no-proxy",
                                                                               argv[local_30]);
                                                                if (iVar8 == 0) {
                                                                  use_proxy = '\0';
                                                                }
                                                                else {
                                                                  iVar8 = strcmp("-4",argv[local_30]
                                                                                );
                                                                  if ((iVar8 == 0) ||
                                                                     (iVar8 = strcmp("-6",argv[
                                                  local_30]), iVar8 == 0)) {
                                                    p_Var10 = Sprintf("dns_order=%c",
                                                                      (int)argv[local_30][1]);
                                                    set_param_option(p_Var10->ptr);
                                                  }
                                                  else {
                                                    iVar8 = strcmp("-post",argv[local_30]);
                                                    if (iVar8 == 0) {
                                                      local_30 = local_30 + 1;
                                                      if (argc <= local_30) {
                                                        fusage((FILE *)stderr,1);
                                                      }
                                                      local_58 = argv[local_30];
                                                    }
                                                    else {
                                                      iVar8 = strcmp("-header",argv[local_30]);
                                                      if (iVar8 == 0) {
                                                        local_30 = local_30 + 1;
                                                        if (argc <= local_30) {
                                                          fusage((FILE *)stderr,1);
                                                        }
                                                        p_Var11 = make_optional_header_string
                                                                            (argv[local_30]);
                                                        p_Var10 = header_string;
                                                        if ((p_Var11 != (Str)0x0) &&
                                                           (p_Var10 = p_Var11,
                                                           header_string != (Str)0x0)) {
                                                          Strcat(header_string,p_Var11);
                                                          p_Var10 = header_string;
                                                        }
                                                        while (header_string = p_Var10,
                                                              *argv[local_30] != '\0') {
                                                          *argv[local_30] = '\0';
                                                          argv[local_30] = argv[local_30] + 1;
                                                          p_Var10 = header_string;
                                                        }
                                                      }
                                                      else {
                                                        iVar8 = strcmp("-no-mouse",argv[local_30]);
                                                        if (iVar8 == 0) {
                                                          use_mouse = 0;
                                                        }
                                                        else {
                                                          iVar8 = strcmp("-no-cookie",argv[local_30]
                                                                        );
                                                          if (iVar8 == 0) {
                                                            use_cookie = 0;
                                                            accept_cookie = 0;
                                                          }
                                                          else {
                                                            iVar8 = strcmp("-cookie",argv[local_30])
                                                            ;
                                                            if (iVar8 == 0) {
                                                              use_cookie = 1;
                                                              accept_cookie = 1;
                                                            }
                                                            else {
                                                              iVar8 = strcmp("-pauth",argv[local_30]
                                                                            );
                                                              if (iVar8 == 0) {
                                                                local_30 = local_30 + 1;
                                                                if (argc <= local_30) {
                                                                  fusage((FILE *)stderr,1);
                                                                }
                                                                p_Var10 = encodeB(argv[local_30]);
                                                                proxy_auth_cookie =
                                                                     Strnew_m_charp("Basic ",p_Var10
                                                  ->ptr,0);
                                                  while (*argv[local_30] != '\0') {
                                                    *argv[local_30] = '\0';
                                                    argv[local_30] = argv[local_30] + 1;
                                                  }
                                                  }
                                                  else {
                                                    iVar8 = strcmp("-s",argv[local_30]);
                                                    if (iVar8 == 0) {
                                                      squeezeBlankLine = 1;
                                                    }
                                                    else {
                                                      iVar8 = strcmp("-X",argv[local_30]);
                                                      if (iVar8 == 0) {
                                                        Do_not_use_ti_te = 1;
                                                      }
                                                      else {
                                                        iVar8 = strcmp("-title",argv[local_30]);
                                                        if (iVar8 == 0) {
                                                          displayTitleTerm = getenv("TERM");
                                                        }
                                                        else {
                                                          iVar8 = strncmp("-title=",argv[local_30],7
                                                                         );
                                                          if (iVar8 == 0) {
                                                            displayTitleTerm = argv[local_30] + 7;
                                                          }
                                                          else {
                                                            iVar8 = strcmp("-o",argv[local_30]);
                                                            if ((iVar8 == 0) ||
                                                               (iVar8 = strcmp("-show-option",
                                                                               argv[local_30]),
                                                               iVar8 == 0)) {
                                                              iVar8 = strcmp("-show-option",
                                                                             argv[local_30]);
                                                              if (((iVar8 == 0) ||
                                                                  (local_30 = local_30 + 1,
                                                                  argc <= local_30)) ||
                                                                 (iVar8 = strcmp(argv[local_30],"?")
                                                                 , iVar8 == 0)) {
                                                                show_params(stdout);
                    // WARNING: Subroutine does not return
                                                                exit(0);
                                                              }
                                                              iVar8 = set_param_option(argv[local_30
                                                  ]);
                                                  if (iVar8 == 0) {
                                                    fprintf(stderr,"%s: bad option\n",argv[local_30]
                                                           );
                                                    show_params_p = 1;
                                                    fusage((FILE *)stderr,1);
                                                  }
                                                  }
                                                  else {
                                                    iVar8 = strcmp("-dummy",argv[local_30]);
                                                    if (iVar8 != 0) {
                                                      iVar8 = strcmp("-debug",argv[local_30]);
                                                      if (iVar8 == 0) {
                                                        w3m_debug = 1;
                                                      }
                                                      else {
                                                        iVar8 = strcmp("-reqlog",argv[local_30]);
                                                        if (iVar8 == 0) {
                                                          w3m_reqlog = rcFile("request.log");
                                                        }
                                                        else {
                                                          fusage((FILE *)stderr,1);
                                                        }
                                                      }
                                                    }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    else if (*argv[local_30] == '+') {
      local_38 = argv[local_30] + 1;
    }
    else {
      *(char **)(local_44 * 4 + iVar7) = argv[local_30];
      local_44 = local_44 + 1;
    }
  }
  FirstTab = (TabBuffer *)0x0;
  LastTab = (TabBuffer *)0x0;
  nTab = 0;
  CurrentTab = (TabBuffer *)0x0;
  CurrentKey = -1;
  if (BookmarkFile == (char *)0x0) {
    BookmarkFile = rcFile("bookmark.html");
  }
  iVar8 = isatty(1);
  if ((iVar8 == 0) && (w3m_dump == 0)) {
    w3m_dump = 1;
  }
  if ((w3m_dump != 0) && (COLS == 0)) {
    COLS = 0x50;
  }
  if ((w3m_dump == 0) && (w3m_backend == 0)) {
    fmInit();
    mySignal(0x1c,resize_hook);
  }
  else if (((w3m_dump & 0x10U) != 0) && (displayImage != 0)) {
    activeImage = 1;
  }
  sync_with_option();
  initCookie();
  if (UseHistory != 0) {
    loadHistory(URLHist);
  }
  wtf_init(DocumentCharset,DisplayCharset);
  if (w3m_backend != 0) {
    backend();
  }
  if (w3m_dump != 0) {
    mySignal(2,(anon_subr_void_int *)0x1);
  }
  mySignal(0x11,sig_chld);
  mySignal(0xd,SigPipe);
  orig_GC_warn_proc = (GC_warn_proc *)GC_set_warn_proc(wrap_GC_warn_proc);
  p_Var10 = Strnew();
  if (local_44 == 0) {
    iVar8 = isatty(0);
    if (iVar8 == 0) {
      iVar8 = dup(0);
      f = fdopen(iVar8,"rb");
      stream = newFileStream((FILE *)f,pclose);
      local_28 = openGeneralPagerBuffer(stream);
      dup2(1,0);
    }
    else if (bVar2) {
      local_28 = loadGeneralFile(BookmarkFile,(ParsedURL *)0x0,(char *)0xffffffff,0,(FormList *)0x0)
      ;
      if (local_28 == (Buffer *)0x0) {
        Strcat_charp(p_Var10,"w3m: Can\'t load bookmark.\n");
      }
    }
    else if (bVar3) {
      p_Var11 = Strnew_charp("<title>W3M startup page</title><center><b>Welcome to ");
      Strcat_charp(p_Var11,"<a href=\'http://w3m.sourceforge.net/\'>");
      Strcat_m_charp(p_Var11,"w3m</a>!<p><p>This is w3m version ",w3m_version,
                     "<br>Written by <a href=\'mailto:aito@fw.ipsj.or.jp\'>Akinori Ito</a>",0);
      Strcat_m_charp(p_Var11,
                     "<p>Debian package is maintained by <a href=\'mailto:ukai@debian.or.jp\'>Fumitoshi UKAI</a>."
                     ,
                     "You can read <a href=\'file:///usr/share/doc/w3m/\'>w3m documents on your local system</a>."
                     ,0);
      local_28 = loadHTMLString(p_Var11);
      if (local_28 == (Buffer *)0x0) {
        Strcat_charp(p_Var10,"w3m: Can\'t load string.\n");
      }
      else if (local_28 != (Buffer *)0x1) {
        local_28->bufferprop = local_28->bufferprop | 0x18;
      }
    }
    else {
      local_2c = getenv("HTTP_HOME");
      if ((local_2c == (char *)0x0) && (local_2c = getenv("WWW_HOME"), local_2c == (char *)0x0)) {
        if (fmInitialized != '\0') {
          fmTerm();
        }
        fusage((FILE *)stderr,1);
      }
      else {
        local_28 = loadGeneralFile(local_2c,(ParsedURL *)0x0,(char *)0xffffffff,0,(FormList *)0x0);
        if (local_28 == (Buffer *)0x0) {
          p_Var11 = Sprintf("w3m: Can\'t load %s.\n",local_2c);
          Strcat(p_Var10,p_Var11);
        }
        else if (local_28 != (Buffer *)0x1) {
          p_Var11 = parsedURL2Str(&local_28->currentURL);
          pushHashHist(URLHist,p_Var11->ptr);
        }
      }
    }
    if (local_28 == (_Buffer *)0x0) {
      if (fmInitialized != '\0') {
        fmTerm();
      }
      if (p_Var10->length != 0) {
        fputs(p_Var10->ptr,stderr);
      }
      w3m_exit(2);
    }
    local_30 = -1;
  }
  else {
    local_30 = 0;
  }
  for (; local_30 < local_44; local_30 = local_30 + 1) {
    if (local_30 < 0) {
      if (local_28 != (_Buffer *)0x1) {
LAB_0804cfee:
        if ((local_28->pagerSource != (InputStream)0x0) ||
           ((((local_28->real_scheme == 4 && (local_28->header_source != (char *)0x0)) &&
             ((local_28->currentURL).file != (char *)0x0)) &&
            (iVar8 = strcmp((local_28->currentURL).file,"-"), iVar8 != 0)))) {
          local_28->search_header = local_22;
        }
        if (CurrentTab == (TabBuffer *)0x0) {
          pTVar12 = newTab();
          nTab = 1;
          FirstTab = pTVar12;
          CurrentTab = pTVar12;
          LastTab = pTVar12;
          pTVar12->currentBuffer = local_28;
          pTVar12->firstBuffer = pTVar12->currentBuffer;
        }
        else if (bVar4) {
          _newT();
          CurrentTab->currentBuffer->nextBuffer = local_28;
          delBuffer(CurrentTab->currentBuffer);
        }
        else {
          CurrentTab->currentBuffer->nextBuffer = local_28;
          CurrentTab->currentBuffer = local_28;
        }
        if (((w3m_dump == 0) || (w3m_dump == 1)) &&
           ((CurrentTab->currentBuffer->frameset != (frameset *)0x0 && (RenderFrame != '\0')))) {
          rFrame();
        }
        if (w3m_dump == 0) {
          CurrentTab->currentBuffer = local_28;
        }
        else {
          do_dump(CurrentTab->currentBuffer);
        }
      }
    }
    else {
      SearchHeader = local_22;
      DefaultType = local_54;
      if (w3m_dump == 2) {
        request_00 = (FormList *)GC_malloc(0x34);
        request_00->method = 3;
        local_28 = loadGeneralFile(*(char **)(local_30 * 4 + iVar7),(ParsedURL *)0x0,
                                   (char *)0xffffffff,0,request_00);
      }
      else {
        if ((local_58 == (char *)0x0) || (local_30 != 0)) {
          local_40 = (FormList *)0x0;
        }
        else {
          iVar8 = strcmp(local_58,"-");
          if (iVar8 == 0) {
            local_70 = stdin;
          }
          else {
            local_70 = fopen(local_58,"r");
          }
          if (local_70 == (FILE *)0x0) {
            p_Var11 = Sprintf("w3m: Can\'t open %s.\n",local_58);
            Strcat(p_Var10,p_Var11);
            goto LAB_0804d16a;
          }
          p_Var11 = Strfgetall((FILE *)local_70);
          if (local_70 != stdin) {
            fclose(local_70);
          }
          local_40 = newFormList((char *)0x0,"post",(char *)0x0,(char *)0x0,(char *)0x0,(char *)0x0,
                                 (form_list *)0x0);
          local_40->body = p_Var11->ptr;
          local_40->boundary = (char *)0x0;
          local_40->length = p_Var11->length;
        }
        local_28 = loadGeneralFile(*(char **)(local_30 * 4 + iVar7),(ParsedURL *)0x0,
                                   (char *)0xffffffff,0,local_40);
      }
      f_ces = SystemCharset;
      t_ces = InnerCharset;
      if (local_28 == (_Buffer *)0x0) {
        p_Var11 = Sprintf("w3m: Can\'t load %s.\n",*(undefined4 *)(local_30 * 4 + iVar7));
        Strcat(p_Var10,p_Var11);
      }
      else if (local_28 != (_Buffer *)0x1) {
        iVar8 = local_28->real_scheme;
        if (3 < iVar8) {
          if (iVar8 < 6) {
            p_Var11 = Strnew_charp(*(char **)(local_30 * 4 + iVar7));
            p_Var11 = wc_Str_conv(p_Var11,f_ces,t_ces);
            unshiftHist(LoadHist,p_Var11->ptr);
          }
          else if (iVar8 == 0xc) goto LAB_0804cfee;
        }
        p_Var11 = parsedURL2Str(&local_28->currentURL);
        pushHashHist(URLHist,p_Var11->ptr);
        goto LAB_0804cfee;
      }
    }
LAB_0804d16a:
  }
  if (w3m_dump != 0) {
    if (p_Var10->length != 0) {
      fputs(p_Var10->ptr,stderr);
    }
    save_cookies();
    w3m_exit(0);
  }
  if (add_download_list == 0) {
    CurrentTab = FirstTab;
  }
  else {
    add_download_list = 0;
    CurrentTab = LastTab;
    if (FirstTab == (TabBuffer *)0x0) {
      FirstTab = newTab();
      nTab = 1;
      LastTab = FirstTab;
    }
    pTVar12 = LastTab;
    CurrentTab = LastTab;
    if ((LastTab->firstBuffer == (Buffer *)0x0) || (LastTab->firstBuffer == (Buffer *)0x1)) {
      if (showLineNum == 0) {
        iVar7 = 1;
      }
      else {
        iVar7 = 6;
      }
      iVar7 = COLS - iVar7;
      if (iVar7 < 0) {
        iVar7 = 0;
      }
      pBVar13 = newBuffer(iVar7);
      pTVar12->currentBuffer = pBVar13;
      pTVar12->firstBuffer = pTVar12->currentBuffer;
      CurrentTab->currentBuffer->bufferprop = 0x18;
      CurrentTab->currentBuffer->buffername = "Download List Panel";
    }
    else {
      LastTab->currentBuffer = LastTab->firstBuffer;
    }
    ldDL();
  }
  if (((FirstTab == (TabBuffer *)0x0) || (CurrentTab->firstBuffer == (Buffer *)0x0)) ||
     (CurrentTab->firstBuffer == (Buffer *)0x1)) {
    if ((local_28 == (_Buffer *)0x1) && (fmInitialized != '\0')) {
      inputLineHistSearch("Hit any key to quit w3m:","",0x200,(Hist *)0x0,
                          (anon_subr_int_int_Str_Lineprop_ptr *)0x0);
    }
    if (fmInitialized != '\0') {
      fmTerm();
    }
    if (p_Var10->length != 0) {
      fputs(p_Var10->ptr,stderr);
    }
    if ((local_28 == (_Buffer *)0x1) && (save_cookies(), p_Var10->length == 0)) {
      w3m_exit(0);
    }
    w3m_exit(2);
  }
  if (p_Var10->length != 0) {
    disp_message_nsec(p_Var10->ptr,0,1,1,0);
  }
  SearchHeader = '\0';
  DefaultType = (char *)0x0;
  UseContentCharset = '\x01';
  WcOption.auto_detect = wVar5;
  CurrentTab->currentBuffer = CurrentTab->firstBuffer;
  displayBuffer(CurrentTab->currentBuffer,1);
  if (local_38 != (char *)0x0) {
    _goLine(local_38);
  }
  do {
    while( true ) {
      while( true ) {
        while( true ) {
          if (add_download_list != 0) {
            add_download_list = 0;
            ldDL();
          }
          if (CurrentTab->currentBuffer->submit == (Anchor *)0x0) break;
          pAVar1 = CurrentTab->currentBuffer->submit;
          CurrentTab->currentBuffer->submit = (Anchor *)0x0;
          gotoLine(CurrentTab->currentBuffer,(pAVar1->start).line);
          CurrentTab->currentBuffer->pos = (pAVar1->start).pos;
          _followForm(1);
        }
        if (CurrentEvent == (Event *)0x0) break;
        CurrentKey = -1;
        CurrentKeyData = (char *)0x0;
        CurrentCmdData = (char *)CurrentEvent->data;
        (*w3mFuncList[CurrentEvent->cmd].func)();
        CurrentCmdData = (char *)0x0;
        CurrentEvent = CurrentEvent->next;
      }
      if (CurrentTab->currentBuffer->event != (_AlarmEvent *)0x0) break;
LAB_0804d5ae:
      if (CurrentTab->currentBuffer->event == (_AlarmEvent *)0x0) {
        CurrentAlarm = &DefaultAlarm;
      }
      mouse_action.in_action = 0;
      if (use_mouse != 0) {
        mouse_active();
      }
      if (0 < CurrentAlarm->sec) {
        mySignal(0xe,SigAlarm);
        alarm(CurrentAlarm->sec);
      }
      mySignal(0x1c,resize_hook);
      if ((((activeImage == 0) || (displayImage == 0)) ||
          (CurrentTab->currentBuffer->img == (AnchorList *)0x0)) ||
         (CurrentTab->currentBuffer->image_loaded != '\0')) {
        do {
          if (need_resize_screen != 0) {
            resize_screen();
          }
          iVar7 = sleep_till_anykey(1,0);
        } while (iVar7 < 1);
      }
      else {
        do {
          if (need_resize_screen != 0) {
            resize_screen();
          }
          loadImage(CurrentTab->currentBuffer,2);
          iVar7 = sleep_till_anykey(1,0);
        } while (iVar7 < 1);
      }
      uVar14 = do_getch();
      cVar6 = (char)uVar14;
      if (0 < CurrentAlarm->sec) {
        alarm(0);
      }
      if (use_mouse != 0) {
        mouse_inactive();
      }
      if ((MYCTYPE_MAP[uVar14 & 0xff] & 0x11) != 0) {
        if (vi_prec_num == 0) {
          set_buffer_environ(CurrentTab->currentBuffer);
          save_buffer_position(CurrentTab->currentBuffer);
          keyPressEventProc((int)cVar6);
          prec_num = 0;
        }
        else if ((((prec_num == 0) || (cVar6 != '0')) && (cVar6 < '1')) || ('9' < cVar6)) {
          set_buffer_environ(CurrentTab->currentBuffer);
          save_buffer_position(CurrentTab->currentBuffer);
          keyPressEventProc((int)cVar6);
          prec_num = 0;
        }
        else {
          prec_num = prec_num * 10 + cVar6 + -0x30;
          if (10000 < prec_num) {
            prec_num = 10000;
          }
        }
      }
      prev_key = CurrentKey;
      CurrentKey = -1;
      CurrentKeyData = (char *)0x0;
    }
    if (CurrentTab->currentBuffer->event->status == 0) {
      CurrentTab->currentBuffer->event = (_AlarmEvent *)0x0;
      goto LAB_0804d5ae;
    }
    CurrentAlarm = CurrentTab->currentBuffer->event;
    if (CurrentAlarm->sec != 0) goto LAB_0804d5ae;
    CurrentTab->currentBuffer->event = (_AlarmEvent *)0x0;
    CurrentKey = -1;
    CurrentKeyData = (char *)0x0;
    CurrentCmdData = (char *)CurrentAlarm->data;
    (*w3mFuncList[CurrentAlarm->cmd].func)();
    CurrentCmdData = (char *)0x0;
  } while( true );
}



void keyPressEventProc(int c)

{
  CurrentKey = c;
  (*w3mFuncList[GlobalKeymap[c]].func)();
  return;
}



void pushEvent(int cmd,void *data)

{
  Event *pEVar1;
  Event *pEVar2;
  Event *event;
  
  pEVar2 = (Event *)GC_malloc(0xc);
  pEVar2->cmd = cmd;
  pEVar2->data = data;
  pEVar2->next = (_Event *)0x0;
  pEVar1 = pEVar2;
  if (CurrentEvent != (Event *)0x0) {
    LastEvent->next = pEVar2;
    pEVar1 = CurrentEvent;
  }
  CurrentEvent = pEVar1;
  LastEvent = pEVar2;
  return;
}



void dump_source(Buffer *buf)

{
  FILE *__stream;
  int iVar1;
  int iVar2;
  FILE *f;
  char c;
  
  if ((buf->sourcefile != (char *)0x0) &&
     (__stream = fopen(buf->sourcefile,"r"), __stream != (FILE *)0x0)) {
    while( true ) {
      iVar1 = fgetc(__stream);
      iVar2 = feof(__stream);
      if (iVar2 != 0) break;
      putchar((int)(char)iVar1);
    }
    fclose(__stream);
  }
  return;
}



void dump_head(Buffer *buf)

{
  wc_ces t_ces;
  wc_ces f_ces;
  Str p_Var1;
  TextListItem *ti;
  
  if (buf->document_header == (TextList *)0x0) {
    if ((w3m_dump & 8U) != 0) {
      putchar(10);
    }
  }
  else {
    for (ti = buf->document_header->first; f_ces = InnerCharset, ti != (TextListItem *)0x0;
        ti = ti->next) {
      t_ces = buf->document_charset;
      p_Var1 = Strnew_charp(ti->ptr);
      p_Var1 = wc_Str_conv_strict(p_Var1,f_ces,t_ces);
      printf("%s",p_Var1->ptr);
    }
    puts("");
  }
  return;
}



void dump_extra(Buffer *buf)

{
  Str p_Var1;
  char *pcVar2;
  
  p_Var1 = parsedURL2Str(&buf->currentURL);
  printf("W3m-current-url: %s\n",p_Var1->ptr);
  if (buf->baseURL != (ParsedURL *)0x0) {
    p_Var1 = parsedURL2Str(buf->baseURL);
    printf("W3m-base-url: %s\n",p_Var1->ptr);
  }
  pcVar2 = wc_ces_to_charset(buf->document_charset);
  printf("W3m-document-charset: %s\n",pcVar2);
  return;
}



void do_dump(Buffer *buf)

{
  anon_subr_void_int *action;
  int iVar1;
  anon_subr_void_int *prevtrap;
  
  action = mySignal(2,intTrap);
  iVar1 = __sigsetjmp(IntReturn,1);
  if (iVar1 == 0) {
    if ((w3m_dump & 8U) != 0) {
      dump_extra(buf);
    }
    if ((w3m_dump & 2U) != 0) {
      dump_head(buf);
    }
    if ((w3m_dump & 4U) != 0) {
      dump_source(buf);
    }
    if (w3m_dump == 1) {
      saveBuffer(buf,stdout,0);
    }
    mySignal(2,action);
  }
  else {
    mySignal(2,action);
  }
  return;
}



void nulcmd(void)

{
  return;
}



void pcmap(void)

{
  return;
}



void escKeyProc(int c,int esc,uchar *map)

{
  uchar **ppuVar1;
  uchar **mmap;
  
  if ((-1 < CurrentKey) && ((CurrentKey & 0x10000000U) != 0)) {
    ppuVar1 = (uchar **)getKeyData(CurrentKey >> 0x10 & 0x77f);
    if (ppuVar1 == (uchar **)0x0) {
      return;
    }
    if (esc == 0x200) {
      map = ppuVar1[2];
    }
    else if (esc == 0x400) {
      map = ppuVar1[3];
    }
    else if (esc == 0x100) {
      map = ppuVar1[1];
    }
    else {
      map = *ppuVar1;
    }
    esc = esc | CurrentKey & 0xffff0000U;
  }
  CurrentKey = c | esc;
  (*w3mFuncList[map[c]].func)();
  return;
}



void escmap(void)

{
  uint uVar1;
  char c;
  
  uVar1 = do_getch();
  if ((MYCTYPE_MAP[uVar1 & 0xff] & 0x11) != 0) {
    escKeyProc((int)(char)uVar1,0x100,EscKeymap);
  }
  return;
}



void escbmap(void)

{
  uint uVar1;
  char c;
  
  uVar1 = do_getch();
  if ((MYCTYPE_MAP[uVar1 & 0xff] & 8) == 0) {
    if ((MYCTYPE_MAP[uVar1 & 0xff] & 0x11) != 0) {
      escKeyProc((int)(char)uVar1,0x200,EscBKeymap);
    }
  }
  else {
    escdmap((char)uVar1);
  }
  return;
}



void escdmap(char c)

{
  uint uVar1;
  int iVar2;
  char local_20;
  int d;
  
  d = c + -0x30;
  uVar1 = do_getch();
  local_20 = (char)uVar1;
  if ((MYCTYPE_MAP[uVar1 & 0xff] & 8) != 0) {
    d = d * 10 + (int)local_20 + -0x30;
    iVar2 = do_getch();
    local_20 = (char)iVar2;
  }
  if (local_20 == '~') {
    escKeyProc(d,0x400,EscDKeymap);
  }
  return;
}



void multimap(void)

{
  uint uVar1;
  char c;
  
  uVar1 = do_getch();
  if ((MYCTYPE_MAP[uVar1 & 0xff] & 0x11) != 0) {
    CurrentKey = (int)(char)uVar1 | CurrentKey << 0x10 | 0x10000000U;
    escKeyProc((int)(char)uVar1,0,(uchar *)0x0);
  }
  return;
}



void tmpClearBuffer(Buffer *buf)

{
  int iVar1;
  
  if (buf->pagerSource == (InputStream)0x0) {
    iVar1 = writeBufferCache(buf);
    if (iVar1 == 0) {
      buf->firstLine = (Line *)0x0;
      buf->topLine = (Line *)0x0;
      buf->currentLine = (Line *)0x0;
      buf->lastLine = (Line *)0x0;
    }
  }
  return;
}



void pushBuffer(Buffer *buf)

{
  TabBuffer *pTVar1;
  Buffer *pBVar2;
  Buffer *b;
  
  deleteImage(CurrentTab->currentBuffer);
  if (clear_buffer != 0) {
    tmpClearBuffer(CurrentTab->currentBuffer);
  }
  if (CurrentTab->firstBuffer == CurrentTab->currentBuffer) {
    buf->nextBuffer = CurrentTab->firstBuffer;
    pTVar1 = CurrentTab;
    CurrentTab->currentBuffer = buf;
    pTVar1->firstBuffer = pTVar1->currentBuffer;
  }
  else {
    pBVar2 = prevBuffer(CurrentTab->firstBuffer,CurrentTab->currentBuffer);
    if (pBVar2 != (Buffer *)0x0) {
      pBVar2->nextBuffer = buf;
      buf->nextBuffer = CurrentTab->currentBuffer;
      CurrentTab->currentBuffer = buf;
    }
  }
  return;
}



void delBuffer(Buffer *buf)

{
  TabBuffer *pTVar1;
  Buffer *pBVar2;
  
  if (buf != (Buffer *)0x0) {
    if (CurrentTab->currentBuffer == buf) {
      CurrentTab->currentBuffer = buf->nextBuffer;
    }
    pTVar1 = CurrentTab;
    pBVar2 = deleteBuffer(CurrentTab->firstBuffer,buf);
    pTVar1->firstBuffer = pBVar2;
    if (CurrentTab->currentBuffer == (Buffer *)0x0) {
      CurrentTab->currentBuffer = CurrentTab->firstBuffer;
    }
  }
  return;
}



void repBuffer(Buffer *oldbuf,Buffer *buf)

{
  TabBuffer *pTVar1;
  Buffer *pBVar2;
  
  pTVar1 = CurrentTab;
  pBVar2 = replaceBuffer(CurrentTab->firstBuffer,oldbuf,buf);
  pTVar1->firstBuffer = pBVar2;
  CurrentTab->currentBuffer = buf;
  return;
}



void intTrap(int _dummy)

{
                    // WARNING: Subroutine does not return
  siglongjmp((__jmp_buf_tag *)IntReturn,0);
}



void resize_hook(void)

{
  need_resize_screen = 1;
  mySignal(0x1c,resize_hook);
  return;
}



void resize_screen(void)

{
  need_resize_screen = 0;
  setlinescols();
  setupscreen();
  if (CurrentTab != (TabBuffer *)0x0) {
    displayBuffer(CurrentTab->currentBuffer,1);
  }
  return;
}



void SigPipe(int _dummy)

{
  init_migemo();
  mySignal(0xd,SigPipe);
  return;
}



void nscroll(int n,int mode)

{
  Buffer *buf_00;
  Line *line;
  int iVar1;
  Line *pLVar2;
  int iVar3;
  int diff_n;
  int llnum;
  int tlnum;
  int lnum;
  Line *cur;
  Line *top;
  Buffer *buf;
  
  buf_00 = CurrentTab->currentBuffer;
  line = buf_00->topLine;
  if (buf_00->firstLine != (Line *)0x0) {
    lnum = buf_00->currentLine->linenumber;
    pLVar2 = lineSkip(buf_00,line,n,0);
    buf_00->topLine = pLVar2;
    if (buf_00->topLine == line) {
      lnum = lnum + n;
      if (lnum < buf_00->topLine->linenumber) {
        lnum = buf_00->topLine->linenumber;
      }
      else if (buf_00->lastLine->linenumber < lnum) {
        lnum = buf_00->lastLine->linenumber;
      }
    }
    else {
      iVar1 = buf_00->topLine->linenumber;
      iVar3 = buf_00->topLine->linenumber + (int)buf_00->LINES + -1;
      if (nextpage_topline == 0) {
        diff_n = (line->linenumber - iVar1) + n;
      }
      else {
        diff_n = 0;
      }
      if (lnum < iVar1) {
        lnum = iVar1 + diff_n;
      }
      if (iVar3 < lnum) {
        lnum = iVar3 + diff_n;
      }
    }
    gotoLine(buf_00,lnum);
    arrangeLine(buf_00);
    if (n < 1) {
      if (buf_00->currentLine->bwidth + buf_00->currentLine->width <
          buf_00->currentColumn + buf_00->visualpos) {
        cursorUp(buf_00,1);
      }
      else {
        while (((buf_00->currentLine->prev != (_Line *)0x0 && (buf_00->currentLine->bpos != 0)) &&
               (buf_00->currentColumn + buf_00->visualpos <= buf_00->currentLine->bwidth))) {
          cursorUp0(buf_00,1);
        }
      }
    }
    else if ((buf_00->currentLine->bpos == 0) ||
            (buf_00->currentLine->bwidth < buf_00->currentColumn + buf_00->visualpos)) {
      while (((buf_00->currentLine->next != (_Line *)0x0 && (buf_00->currentLine->next->bpos != 0))
             && (buf_00->currentLine->bwidth + buf_00->currentLine->width <
                 buf_00->currentColumn + buf_00->visualpos))) {
        cursorDown0(buf_00,1);
      }
    }
    else {
      cursorDown(buf_00,1);
    }
    displayBuffer(buf_00,mode);
  }
  return;
}



void pgFore(void)

{
  int iVar1;
  int iVar2;
  
  if (vi_prec_num == 0) {
    if (prec_num == 0) {
      iVar1 = 0;
      iVar2 = searchKeyNum();
      iVar2 = iVar2 * (CurrentTab->currentBuffer->LINES + -1);
    }
    else {
      iVar1 = 3;
      iVar2 = searchKeyNum();
    }
    nscroll(iVar2,iVar1);
  }
  else {
    iVar1 = searchKeyNum();
    nscroll(iVar1 * (CurrentTab->currentBuffer->LINES + -1),0);
  }
  return;
}



void pgBack(void)

{
  int iVar1;
  int iVar2;
  
  if (vi_prec_num == 0) {
    if (prec_num == 0) {
      iVar1 = 0;
      iVar2 = searchKeyNum();
      iVar2 = iVar2 * (1 - CurrentTab->currentBuffer->LINES);
    }
    else {
      iVar1 = 3;
      iVar2 = searchKeyNum();
      iVar2 = -iVar2;
    }
    nscroll(iVar2,iVar1);
  }
  else {
    iVar1 = searchKeyNum();
    nscroll(iVar1 * (1 - CurrentTab->currentBuffer->LINES),0);
  }
  return;
}



void lup1(void)

{
  int n;
  
  n = searchKeyNum();
  nscroll(n,3);
  return;
}



void ldown1(void)

{
  int iVar1;
  
  iVar1 = searchKeyNum();
  nscroll(-iVar1,3);
  return;
}



void ctrCsrV(void)

{
  Buffer *pBVar1;
  Line *pLVar2;
  int iVar3;
  int offsety;
  
  if ((CurrentTab->currentBuffer->firstLine != (Line *)0x0) &&
     (iVar3 = (int)(CurrentTab->currentBuffer->LINES / 2) - (int)CurrentTab->currentBuffer->cursorY,
     iVar3 != 0)) {
    pBVar1 = CurrentTab->currentBuffer;
    pLVar2 = lineSkip(CurrentTab->currentBuffer,CurrentTab->currentBuffer->topLine,-iVar3,0);
    pBVar1->topLine = pLVar2;
    arrangeLine(CurrentTab->currentBuffer);
    displayBuffer(CurrentTab->currentBuffer,0);
  }
  return;
}



void ctrCsrH(void)

{
  int offset;
  int offsetx;
  
  if ((CurrentTab->currentBuffer->firstLine != (Line *)0x0) &&
     (offset = (int)CurrentTab->currentBuffer->cursorX - (int)(CurrentTab->currentBuffer->COLS / 2),
     offset != 0)) {
    columnSkip(CurrentTab->currentBuffer,offset);
    arrangeCursor(CurrentTab->currentBuffer);
    displayBuffer(CurrentTab->currentBuffer,0);
  }
  return;
}



void rdrwSc(void)

{
  clear();
  arrangeCursor(CurrentTab->currentBuffer);
  displayBuffer(CurrentTab->currentBuffer,1);
  return;
}



void clear_mark(Line *l)

{
  int pos;
  
  if (l != (Line *)0x0) {
    for (pos = 0; pos < l->size; pos = pos + 1) {
      l->propBuf[pos] = l->propBuf[pos] & 0xfffe;
    }
  }
  return;
}



int srchcore(char *str,anon_subr_int_Buffer_ptr_char_ptr *func)

{
  char *pcVar1;
  anon_subr_void_int *action;
  int iVar2;
  int result;
  int i;
  anon_subr_void_varargs *prevtrap;
  
  result = 2;
  if ((str != (char *)0x0) && (str != SearchString)) {
    SearchString = str;
  }
  if ((SearchString == (char *)0x0) || (*SearchString == '\0')) {
    result = 2;
  }
  else {
    pcVar1 = conv_search_string(SearchString,DisplayCharset);
    action = mySignal(2,intTrap);
    crmode();
    iVar2 = __sigsetjmp(IntReturn,1);
    if (iVar2 == 0) {
      i = 0;
      while( true ) {
        iVar2 = prec_num;
        if (prec_num == 0) {
          iVar2 = 1;
        }
        if (iVar2 <= i) break;
        result = (*func)(CurrentTab->currentBuffer,pcVar1);
        if (prec_num == 0) {
          iVar2 = 0;
        }
        else {
          iVar2 = prec_num + -1;
        }
        if ((i < iVar2) && ((result & 1U) != 0)) {
          clear_mark(CurrentTab->currentBuffer->currentLine);
        }
        i = i + 1;
      }
    }
    mySignal(2,action);
    term_raw();
  }
  return result;
}



void disp_srchresult(int result,char *prompt,char *str)

{
  Str p_Var1;
  
  if (str == (char *)0x0) {
    str = "";
  }
  if ((result & 2U) == 0) {
    if ((result & 4U) == 0) {
      if (show_srch_str != 0) {
        p_Var1 = Sprintf("%s%s",prompt,str);
        disp_message(p_Var1->ptr,1);
      }
    }
    else {
      p_Var1 = Sprintf("Search wrapped: %s",str);
      disp_message(p_Var1->ptr,1);
    }
  }
  else {
    p_Var1 = Sprintf("Not found: %s",str);
    disp_message(p_Var1->ptr,1);
  }
  return;
}



int dispincsrch(int ch,Str buf,Lineprop *prop)

{
  char cVar1;
  bool bVar2;
  int iVar3;
  int do_next_search;
  char *str;
  
  bVar2 = false;
  if ((ch == 0) && (buf == (Str)0x0)) {
    dispincsrch::sbuf.currentLine = CurrentTab->currentBuffer->currentLine;
    dispincsrch::sbuf.pos = CurrentTab->currentBuffer->pos;
    dispincsrch::sbuf.topLine = CurrentTab->currentBuffer->topLine;
    dispincsrch::sbuf.currentColumn = CurrentTab->currentBuffer->currentColumn;
    dispincsrch::sbuf.cursorX = CurrentTab->currentBuffer->cursorX;
    dispincsrch::sbuf.cursorY = CurrentTab->currentBuffer->cursorY;
    dispincsrch::sbuf.visualpos = CurrentTab->currentBuffer->visualpos;
    dispincsrch::currentLine = dispincsrch::sbuf.currentLine;
    dispincsrch::pos = dispincsrch::sbuf.pos;
    return -1;
  }
  str = buf->ptr;
  if (ch == 0x13) {
    searchRoutine = forwardSearch;
    bVar2 = true;
  }
  else {
    if (ch == 0x1c) {
      migemo_active = -migemo_active;
      goto LAB_0804eb53;
    }
    if (ch == 0x12) {
      searchRoutine = backwardSearch;
      bVar2 = true;
    }
    else if (-1 < ch) {
      return ch;
    }
  }
  if (bVar2) {
    if (*str != '\0') {
      if (searchRoutine == forwardSearch) {
        CurrentTab->currentBuffer->pos = CurrentTab->currentBuffer->pos + 1;
      }
      dispincsrch::sbuf.topLine = CurrentTab->currentBuffer->topLine;
      dispincsrch::sbuf.currentLine = CurrentTab->currentBuffer->currentLine;
      dispincsrch::sbuf.pos = CurrentTab->currentBuffer->pos;
      dispincsrch::sbuf.cursorX = CurrentTab->currentBuffer->cursorX;
      dispincsrch::sbuf.cursorY = CurrentTab->currentBuffer->cursorY;
      dispincsrch::sbuf.visualpos = CurrentTab->currentBuffer->visualpos;
      dispincsrch::sbuf.currentColumn = CurrentTab->currentBuffer->currentColumn;
      iVar3 = srchcore(str,searchRoutine);
      if ((iVar3 == 2) && (searchRoutine == forwardSearch)) {
        CurrentTab->currentBuffer->pos = CurrentTab->currentBuffer->pos + -1;
        dispincsrch::sbuf.topLine = CurrentTab->currentBuffer->topLine;
        dispincsrch::sbuf.currentLine = CurrentTab->currentBuffer->currentLine;
        dispincsrch::sbuf.pos = CurrentTab->currentBuffer->pos;
        dispincsrch::sbuf.cursorX = CurrentTab->currentBuffer->cursorX;
        dispincsrch::sbuf.cursorY = CurrentTab->currentBuffer->cursorY;
        dispincsrch::sbuf.visualpos = CurrentTab->currentBuffer->visualpos;
        dispincsrch::sbuf.currentColumn = CurrentTab->currentBuffer->currentColumn;
      }
      arrangeCursor(CurrentTab->currentBuffer);
      displayBuffer(CurrentTab->currentBuffer,1);
      clear_mark(CurrentTab->currentBuffer->currentLine);
      return -1;
    }
    return 0x10;
  }
  if (*str != '\0') {
    CurrentTab->currentBuffer->topLine = dispincsrch::sbuf.topLine;
    CurrentTab->currentBuffer->currentLine = dispincsrch::sbuf.currentLine;
    CurrentTab->currentBuffer->pos = dispincsrch::sbuf.pos;
    CurrentTab->currentBuffer->cursorX = dispincsrch::sbuf.cursorX;
    CurrentTab->currentBuffer->cursorY = dispincsrch::sbuf.cursorY;
    CurrentTab->currentBuffer->visualpos = dispincsrch::sbuf.visualpos;
    CurrentTab->currentBuffer->currentColumn = dispincsrch::sbuf.currentColumn;
    arrangeCursor(CurrentTab->currentBuffer);
    srchcore(str,searchRoutine);
    arrangeCursor(CurrentTab->currentBuffer);
    dispincsrch::currentLine = CurrentTab->currentBuffer->currentLine;
    dispincsrch::pos = CurrentTab->currentBuffer->pos;
  }
  displayBuffer(CurrentTab->currentBuffer,1);
  clear_mark(CurrentTab->currentBuffer->currentLine);
LAB_0804eb53:
  while (cVar1 = *str, str = str + 1, cVar1 != '\0') {
    if (migemo_active < 1) {
      *prop = *prop & 0xfffd;
      prop = prop + 1;
    }
    else {
      *prop = *prop | 2;
      prop = prop + 1;
    }
  }
  return -1;
}



void isrch(anon_subr_int_Buffer_ptr_char_ptr *func,char *prompt)

{
  short sVar1;
  short sVar2;
  Line *pLVar3;
  Line *pLVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  char *pcVar8;
  Buffer sbuf;
  char *str;
  
  pLVar3 = CurrentTab->currentBuffer->topLine;
  pLVar4 = CurrentTab->currentBuffer->currentLine;
  iVar5 = CurrentTab->currentBuffer->pos;
  sVar1 = CurrentTab->currentBuffer->cursorX;
  sVar2 = CurrentTab->currentBuffer->cursorY;
  iVar6 = CurrentTab->currentBuffer->visualpos;
  iVar7 = CurrentTab->currentBuffer->currentColumn;
  dispincsrch(0,(Str)0x0,(Lineprop *)0x0);
  searchRoutine = func;
  pcVar8 = inputLineHistSearch(prompt,(char *)0x0,0x10,TextHist,dispincsrch);
  if (pcVar8 == (char *)0x0) {
    CurrentTab->currentBuffer->topLine = pLVar3;
    CurrentTab->currentBuffer->currentLine = pLVar4;
    CurrentTab->currentBuffer->pos = iVar5;
    CurrentTab->currentBuffer->cursorX = sVar1;
    CurrentTab->currentBuffer->cursorY = sVar2;
    CurrentTab->currentBuffer->visualpos = iVar6;
    CurrentTab->currentBuffer->currentColumn = iVar7;
  }
  displayBuffer(CurrentTab->currentBuffer,1);
  return;
}



void srch(anon_subr_int_Buffer_ptr_char_ptr *func,char *prompt)

{
  int iVar1;
  bool bVar2;
  uint result_00;
  int pos;
  int disp;
  int result;
  char *str;
  
  bVar2 = false;
  str = searchKeyData();
  if ((str == (char *)0x0) || (*str == '\0')) {
    str = inputLineHistSearch(prompt,(char *)0x0,0x10,TextHist,
                              (anon_subr_int_int_Str_Lineprop_ptr *)0x0);
    if ((str != (char *)0x0) && (*str == '\0')) {
      str = SearchString;
    }
    if (str == (char *)0x0) {
      displayBuffer(CurrentTab->currentBuffer,0);
      return;
    }
    bVar2 = true;
  }
  iVar1 = CurrentTab->currentBuffer->pos;
  if (func == forwardSearch) {
    CurrentTab->currentBuffer->pos = CurrentTab->currentBuffer->pos + 1;
  }
  result_00 = srchcore(str,func);
  if ((result_00 & 1) == 0) {
    CurrentTab->currentBuffer->pos = iVar1;
  }
  else {
    clear_mark(CurrentTab->currentBuffer->currentLine);
  }
  displayBuffer(CurrentTab->currentBuffer,0);
  if (bVar2) {
    disp_srchresult(result_00,prompt,str);
  }
  searchRoutine = func;
  return;
}



void srchfor(void)

{
  srch(forwardSearch,"Forward: ");
  return;
}



void isrchfor(void)

{
  isrch(forwardSearch,"I-search: ");
  return;
}



void srchbak(void)

{
  srch(backwardSearch,"Backward: ");
  return;
}



void isrchbak(void)

{
  isrch(backwardSearch,"I-search backward: ");
  return;
}



void srch_nxtprv(int reverse)

{
  uint result_00;
  char *prompt;
  int result;
  
  if (searchRoutine == (anon_subr_int_Buffer_ptr_char_ptr *)0x0) {
    disp_message("No previous regular expression",1);
  }
  else {
    if (reverse != 0) {
      reverse = 1;
    }
    if (searchRoutine == backwardSearch) {
      reverse = reverse ^ 1;
    }
    if (reverse == 0) {
      CurrentTab->currentBuffer->pos = CurrentTab->currentBuffer->pos + 1;
    }
    result_00 = srchcore(SearchString,srch_nxtprv::routine[reverse]);
    if ((result_00 & 1) != 0) {
      clear_mark(CurrentTab->currentBuffer->currentLine);
    }
    displayBuffer(CurrentTab->currentBuffer,0);
    if (reverse == 0) {
      prompt = "Forward: ";
    }
    else {
      prompt = "Backward: ";
    }
    disp_srchresult(result_00,prompt,SearchString);
  }
  return;
}



void srchnxt(void)

{
  srch_nxtprv(0);
  return;
}



void srchprv(void)

{
  srch_nxtprv(1);
  return;
}



void shiftvisualpos(Buffer *buf,int shift)

{
  Line *pLVar1;
  Line *l;
  
  pLVar1 = buf->currentLine;
  buf->visualpos = buf->visualpos - shift;
  if (buf->visualpos - pLVar1->bwidth < (int)buf->COLS) {
    if (buf->visualpos - pLVar1->bwidth < 0) {
      buf->visualpos = pLVar1->bwidth;
    }
  }
  else {
    buf->visualpos = pLVar1->bwidth + (int)buf->COLS + -1;
  }
  arrangeLine(buf);
  if ((buf->visualpos - pLVar1->bwidth == -shift) && (buf->cursorX == 0)) {
    buf->visualpos = pLVar1->bwidth;
  }
  return;
}



void shiftl(void)

{
  int iVar1;
  int iVar2;
  int column;
  
  if (CurrentTab->currentBuffer->firstLine != (Line *)0x0) {
    iVar1 = CurrentTab->currentBuffer->currentColumn;
    iVar2 = searchKeyNum();
    columnSkip(CurrentTab->currentBuffer,iVar2 * (1 - CurrentTab->currentBuffer->COLS) + 1);
    shiftvisualpos(CurrentTab->currentBuffer,CurrentTab->currentBuffer->currentColumn - iVar1);
    displayBuffer(CurrentTab->currentBuffer,0);
  }
  return;
}



void shiftr(void)

{
  int iVar1;
  int iVar2;
  int column;
  
  if (CurrentTab->currentBuffer->firstLine != (Line *)0x0) {
    iVar1 = CurrentTab->currentBuffer->currentColumn;
    iVar2 = searchKeyNum();
    columnSkip(CurrentTab->currentBuffer,iVar2 * (CurrentTab->currentBuffer->COLS + -1) + -1);
    shiftvisualpos(CurrentTab->currentBuffer,CurrentTab->currentBuffer->currentColumn - iVar1);
    displayBuffer(CurrentTab->currentBuffer,0);
  }
  return;
}



void col1R(void)

{
  Buffer *pBVar1;
  Line *pLVar2;
  int iVar3;
  int iVar4;
  int n;
  int column;
  int j;
  Line *l;
  Buffer *buf;
  
  pBVar1 = CurrentTab->currentBuffer;
  pLVar2 = pBVar1->currentLine;
  iVar4 = searchKeyNum();
  if (pLVar2 != (Line *)0x0) {
    j = 0;
    while ((j < iVar4 &&
           (iVar3 = pBVar1->currentColumn, columnSkip(CurrentTab->currentBuffer,1),
           pBVar1->currentColumn != iVar3))) {
      shiftvisualpos(CurrentTab->currentBuffer,1);
      j = j + 1;
    }
    displayBuffer(CurrentTab->currentBuffer,0);
  }
  return;
}



void col1L(void)

{
  Buffer *pBVar1;
  Line *pLVar2;
  int iVar3;
  int n;
  int j;
  Line *l;
  Buffer *buf;
  
  pBVar1 = CurrentTab->currentBuffer;
  pLVar2 = pBVar1->currentLine;
  iVar3 = searchKeyNum();
  if (pLVar2 != (Line *)0x0) {
    j = 0;
    while ((j < iVar3 && (pBVar1->currentColumn != 0))) {
      columnSkip(CurrentTab->currentBuffer,-1);
      shiftvisualpos(CurrentTab->currentBuffer,-1);
      j = j + 1;
    }
    displayBuffer(CurrentTab->currentBuffer,0);
  }
  return;
}



void setEnv(void)

{
  char *pcVar1;
  Str p_Var2;
  char *var_00;
  char *value;
  char *var;
  char *env;
  
  CurrentKeyData = (char *)0x0;
  env = searchKeyData();
  if (((env == (char *)0x0) || (*env == '\0')) || (pcVar1 = strchr(env,0x3d), pcVar1 == (char *)0x0)
     ) {
    if ((env != (char *)0x0) && (*env != '\0')) {
      p_Var2 = Sprintf("%s=",env);
      env = p_Var2->ptr;
    }
    env = inputLineHistSearch("Set environ: ",env,0x10,TextHist,
                              (anon_subr_int_int_Str_Lineprop_ptr *)0x0);
    if ((env == (char *)0x0) || (*env == '\0')) {
      displayBuffer(CurrentTab->currentBuffer,0);
      return;
    }
  }
  pcVar1 = strchr(env,0x3d);
  if ((pcVar1 != (char *)0x0) && (env < pcVar1)) {
    var_00 = allocStr(env,(int)pcVar1 - (int)env);
    set_environ(var_00,pcVar1 + 1);
  }
  displayBuffer(CurrentTab->currentBuffer,0);
  return;
}



void pipeBuf(void)

{
  wc_ces wVar1;
  wc_ces wVar2;
  Str p_Var3;
  FILE *__stream;
  char *pcVar4;
  Buffer *buf_00;
  FILE *f;
  char *tmpf;
  char *cmd;
  Buffer *buf;
  
  CurrentKeyData = (char *)0x0;
  cmd = searchKeyData();
  if ((cmd == (char *)0x0) || (*cmd == '\0')) {
    cmd = inputLineHistSearch("Pipe buffer to: ","",0x80,ShellHist,
                              (anon_subr_int_int_Str_Lineprop_ptr *)0x0);
  }
  wVar2 = SystemCharset;
  wVar1 = InnerCharset;
  if (cmd != (char *)0x0) {
    p_Var3 = Strnew_charp(cmd);
    p_Var3 = wc_Str_conv_strict(p_Var3,wVar1,wVar2);
    cmd = p_Var3->ptr;
  }
  if ((cmd == (char *)0x0) || (*cmd == '\0')) {
    displayBuffer(CurrentTab->currentBuffer,0);
  }
  else {
    p_Var3 = tmpfname(0,(char *)0x0);
    pcVar4 = p_Var3->ptr;
    __stream = fopen(pcVar4,"w");
    if (__stream == (FILE *)0x0) {
      p_Var3 = Sprintf("Can\'t save buffer to %s",cmd);
      disp_message(p_Var3->ptr,1);
    }
    else {
      saveBuffer(CurrentTab->currentBuffer,(FILE *)__stream,1);
      fclose(__stream);
      pcVar4 = shell_quote(pcVar4);
      p_Var3 = myExtCommand(cmd,pcVar4,1);
      buf_00 = getpipe(p_Var3->ptr);
      if (buf_00 == (Buffer *)0x0) {
        disp_message("Execution failed",1);
      }
      else {
        buf_00->filename = cmd;
        wVar2 = SystemCharset;
        wVar1 = InnerCharset;
        p_Var3 = Strnew_charp(cmd);
        p_Var3 = wc_Str_conv(p_Var3,wVar2,wVar1);
        p_Var3 = Sprintf("%s %s","*stream*",p_Var3->ptr);
        buf_00->buffername = p_Var3->ptr;
        buf_00->bufferprop = buf_00->bufferprop | 0x18;
        if (buf_00->type == (char *)0x0) {
          buf_00->type = "text/plain";
        }
        (buf_00->currentURL).file = "-";
        pushBuffer(buf_00);
        displayBuffer(CurrentTab->currentBuffer,1);
      }
    }
  }
  return;
}



void pipesh(void)

{
  wc_ces f_ces;
  wc_ces t_ces;
  Str p_Var1;
  Buffer *buf_00;
  char *cmd;
  Buffer *buf;
  
  CurrentKeyData = (char *)0x0;
  cmd = searchKeyData();
  if ((cmd == (char *)0x0) || (*cmd == '\0')) {
    cmd = inputLineHistSearch("(read shell[pipe])!","",0x80,ShellHist,
                              (anon_subr_int_int_Str_Lineprop_ptr *)0x0);
  }
  t_ces = SystemCharset;
  f_ces = InnerCharset;
  if (cmd != (char *)0x0) {
    p_Var1 = Strnew_charp(cmd);
    p_Var1 = wc_Str_conv_strict(p_Var1,f_ces,t_ces);
    cmd = p_Var1->ptr;
  }
  if ((cmd == (char *)0x0) || (*cmd == '\0')) {
    displayBuffer(CurrentTab->currentBuffer,0);
  }
  else {
    buf_00 = getpipe(cmd);
    if (buf_00 == (Buffer *)0x0) {
      disp_message("Execution failed",1);
    }
    else {
      buf_00->bufferprop = buf_00->bufferprop | 0x18;
      if (buf_00->type == (char *)0x0) {
        buf_00->type = "text/plain";
      }
      pushBuffer(buf_00);
      displayBuffer(CurrentTab->currentBuffer,1);
    }
  }
  return;
}



void readsh(void)

{
  wc_ces f_ces;
  wc_ces t_ces;
  Str p_Var1;
  anon_subr_void_int *action;
  Buffer *buf_00;
  char *cmd;
  anon_subr_void_varargs *prevtrap;
  Buffer *buf;
  
  CurrentKeyData = (char *)0x0;
  cmd = searchKeyData();
  if ((cmd == (char *)0x0) || (*cmd == '\0')) {
    cmd = inputLineHistSearch("(read shell)!","",0x80,ShellHist,
                              (anon_subr_int_int_Str_Lineprop_ptr *)0x0);
  }
  t_ces = SystemCharset;
  f_ces = InnerCharset;
  if (cmd != (char *)0x0) {
    p_Var1 = Strnew_charp(cmd);
    p_Var1 = wc_Str_conv_strict(p_Var1,f_ces,t_ces);
    cmd = p_Var1->ptr;
  }
  if ((cmd == (char *)0x0) || (*cmd == '\0')) {
    displayBuffer(CurrentTab->currentBuffer,0);
  }
  else {
    action = mySignal(2,intTrap);
    crmode();
    buf_00 = getshell(cmd);
    mySignal(2,action);
    term_raw();
    if (buf_00 == (Buffer *)0x0) {
      disp_message("Execution failed",1);
    }
    else {
      buf_00->bufferprop = buf_00->bufferprop | 0x18;
      if (buf_00->type == (char *)0x0) {
        buf_00->type = "text/plain";
      }
      pushBuffer(buf_00);
      displayBuffer(CurrentTab->currentBuffer,1);
    }
  }
  return;
}



void execsh(void)

{
  wc_ces f_ces;
  wc_ces t_ces;
  Str p_Var1;
  char *cmd;
  
  CurrentKeyData = (char *)0x0;
  cmd = searchKeyData();
  if ((cmd == (char *)0x0) || (*cmd == '\0')) {
    cmd = inputLineHistSearch("(exec shell)!","",0x80,ShellHist,
                              (anon_subr_int_int_Str_Lineprop_ptr *)0x0);
  }
  t_ces = SystemCharset;
  f_ces = InnerCharset;
  if (cmd != (char *)0x0) {
    p_Var1 = Strnew_charp(cmd);
    p_Var1 = wc_Str_conv_strict(p_Var1,f_ces,t_ces);
    cmd = p_Var1->ptr;
  }
  if ((cmd != (char *)0x0) && (*cmd != '\0')) {
    fmTerm();
    putchar(10);
    system(cmd);
    printf("\n[Hit any key]");
    fflush(stdout);
    fmInit();
    do_getch();
  }
  displayBuffer(CurrentTab->currentBuffer,1);
  return;
}



void ldfile(void)

{
  wc_ces f_ces;
  wc_ces t_ces;
  Str p_Var1;
  char *fn;
  
  fn = searchKeyData();
  if ((fn == (char *)0x0) || (*fn == '\0')) {
    fn = inputLineHistSearch("(Load)Filename? ",(char *)0x0,0x20,LoadHist,
                             (anon_subr_int_int_Str_Lineprop_ptr *)0x0);
  }
  t_ces = SystemCharset;
  f_ces = InnerCharset;
  if (fn != (char *)0x0) {
    p_Var1 = Strnew_charp(fn);
    p_Var1 = wc_Str_conv_strict(p_Var1,f_ces,t_ces);
    fn = p_Var1->ptr;
  }
  if ((fn == (char *)0x0) || (*fn == '\0')) {
    displayBuffer(CurrentTab->currentBuffer,0);
  }
  else {
    cmd_loadfile(fn);
  }
  return;
}



void ldhelp(void)

{
  char *pcVar1;
  size_t n_00;
  Str p_Var2;
  Str tmp;
  int n;
  char *lang;
  
  pcVar1 = AcceptLang;
  n_00 = strcspn(AcceptLang,";, \t");
  p_Var2 = Strnew_charp_n(pcVar1,n_00);
  p_Var2 = Str_form_quote(p_Var2);
  pcVar1 = p_Var2->ptr;
  p_Var2 = Strnew_charp(w3m_version);
  p_Var2 = Str_form_quote(p_Var2);
  p_Var2 = Sprintf("file:///$LIB/w3mhelp.cgi?version=%s&lang=%s",p_Var2->ptr,pcVar1);
  cmd_loadURL(p_Var2->ptr,(ParsedURL *)0x0,(char *)0xffffffff,(FormList *)0x0);
  return;
}



void cmd_loadfile(char *fn)

{
  wc_ces t_ces;
  wc_ces f_ces;
  char *path;
  Buffer *buf_00;
  Str p_Var1;
  char *emsg;
  Buffer *buf;
  
  path = file_to_url(fn);
  buf_00 = loadGeneralFile(path,(ParsedURL *)0x0,(char *)0xffffffff,0,(FormList *)0x0);
  f_ces = SystemCharset;
  t_ces = InnerCharset;
  if (buf_00 == (Buffer *)0x0) {
    p_Var1 = Strnew_charp(fn);
    p_Var1 = wc_Str_conv(p_Var1,f_ces,t_ces);
    p_Var1 = Sprintf("%s not found",p_Var1->ptr);
    disp_err_message(p_Var1->ptr,0);
  }
  else if (buf_00 != (Buffer *)0x1) {
    pushBuffer(buf_00);
    if ((RenderFrame != '\0') && (CurrentTab->currentBuffer->frameset != (frameset *)0x0)) {
      rFrame();
    }
  }
  displayBuffer(CurrentTab->currentBuffer,0);
  return;
}



void _movL(int n)

{
  int iVar1;
  int m;
  int i;
  
  iVar1 = searchKeyNum();
  if (CurrentTab->currentBuffer->firstLine != (Line *)0x0) {
    for (i = 0; i < iVar1; i = i + 1) {
      cursorLeft(CurrentTab->currentBuffer,n);
    }
    displayBuffer(CurrentTab->currentBuffer,0);
  }
  return;
}



void movL(void)

{
  _movL((int)(CurrentTab->currentBuffer->COLS / 2));
  return;
}



void movL1(void)

{
  _movL(1);
  return;
}



void _movD(int n)

{
  int iVar1;
  int m;
  int i;
  
  iVar1 = searchKeyNum();
  if (CurrentTab->currentBuffer->firstLine != (Line *)0x0) {
    for (i = 0; i < iVar1; i = i + 1) {
      cursorDown(CurrentTab->currentBuffer,n);
    }
    displayBuffer(CurrentTab->currentBuffer,0);
  }
  return;
}



void movD(void)

{
  _movD((CurrentTab->currentBuffer->LINES + 1) / 2);
  return;
}



void movD1(void)

{
  _movD(1);
  return;
}



void _movU(int n)

{
  int iVar1;
  int m;
  int i;
  
  iVar1 = searchKeyNum();
  if (CurrentTab->currentBuffer->firstLine != (Line *)0x0) {
    for (i = 0; i < iVar1; i = i + 1) {
      cursorUp(CurrentTab->currentBuffer,n);
    }
    displayBuffer(CurrentTab->currentBuffer,0);
  }
  return;
}



void movU(void)

{
  _movU((CurrentTab->currentBuffer->LINES + 1) / 2);
  return;
}



void movU1(void)

{
  _movU(1);
  return;
}



void _movR(int n)

{
  int iVar1;
  int m;
  int i;
  
  iVar1 = searchKeyNum();
  if (CurrentTab->currentBuffer->firstLine != (Line *)0x0) {
    for (i = 0; i < iVar1; i = i + 1) {
      cursorRight(CurrentTab->currentBuffer,n);
    }
    displayBuffer(CurrentTab->currentBuffer,0);
  }
  return;
}



void movR(void)

{
  _movR((int)(CurrentTab->currentBuffer->COLS / 2));
  return;
}



void movR1(void)

{
  _movR(1);
  return;
}



int prev_nonnull_line(Line *line)

{
  int iVar1;
  Line *l;
  
  for (l = line; (l != (Line *)0x0 && (l->len == 0)); l = l->prev) {
  }
  if ((l == (Line *)0x0) || (l->len == 0)) {
    iVar1 = -1;
  }
  else {
    CurrentTab->currentBuffer->currentLine = l;
    if (l != line) {
      CurrentTab->currentBuffer->pos = CurrentTab->currentBuffer->currentLine->len;
    }
    iVar1 = 0;
  }
  return iVar1;
}



void movLW(void)

{
  Line *pLVar1;
  int iVar2;
  char *pcVar3;
  Lineprop *pLVar4;
  int iVar5;
  int iVar6;
  int n;
  int i;
  int ppos;
  Line *pline;
  Lineprop *pb;
  char *lb;
  
  iVar5 = searchKeyNum();
  if (CurrentTab->currentBuffer->firstLine != (Line *)0x0) {
    for (i = 0; i < iVar5; i = i + 1) {
      pLVar1 = CurrentTab->currentBuffer->currentLine;
      iVar2 = CurrentTab->currentBuffer->pos;
      iVar6 = prev_nonnull_line(CurrentTab->currentBuffer->currentLine);
      if (iVar6 < 0) break;
      while( true ) {
        pcVar3 = CurrentTab->currentBuffer->currentLine->lineBuf;
        pLVar4 = CurrentTab->currentBuffer->currentLine->propBuf;
        while ((0 < CurrentTab->currentBuffer->pos &&
               (((MYCTYPE_MAP[(byte)pcVar3[CurrentTab->currentBuffer->pos + -1]] & 0xc) == 0 ||
                ((pLVar4[CurrentTab->currentBuffer->pos + -1] & 0x3f00) != 0))))) {
          CurrentTab->currentBuffer->pos = CurrentTab->currentBuffer->pos + -1;
        }
        if (0 < CurrentTab->currentBuffer->pos) break;
        iVar6 = prev_nonnull_line(CurrentTab->currentBuffer->currentLine->prev);
        if (iVar6 < 0) {
          CurrentTab->currentBuffer->currentLine = pLVar1;
          CurrentTab->currentBuffer->pos = iVar2;
          goto end;
        }
        CurrentTab->currentBuffer->pos = CurrentTab->currentBuffer->currentLine->len;
      }
      pcVar3 = CurrentTab->currentBuffer->currentLine->lineBuf;
      pLVar4 = CurrentTab->currentBuffer->currentLine->propBuf;
      while (((0 < CurrentTab->currentBuffer->pos &&
              ((MYCTYPE_MAP[(byte)pcVar3[CurrentTab->currentBuffer->pos + -1]] & 0xc) != 0)) &&
             ((pLVar4[CurrentTab->currentBuffer->pos + -1] & 0x3f00) == 0))) {
        CurrentTab->currentBuffer->pos = CurrentTab->currentBuffer->pos + -1;
      }
    }
end:
    arrangeCursor(CurrentTab->currentBuffer);
    displayBuffer(CurrentTab->currentBuffer,0);
  }
  return;
}



int next_nonnull_line(Line *line)

{
  int iVar1;
  Line *l;
  
  for (l = line; (l != (Line *)0x0 && (l->len == 0)); l = l->next) {
  }
  if ((l == (Line *)0x0) || (l->len == 0)) {
    iVar1 = -1;
  }
  else {
    CurrentTab->currentBuffer->currentLine = l;
    if (l != line) {
      CurrentTab->currentBuffer->pos = 0;
    }
    iVar1 = 0;
  }
  return iVar1;
}



void movRW(void)

{
  Line *pLVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int n;
  int i;
  int ppos;
  Line *pline;
  Lineprop *pb;
  char *lb;
  
  iVar3 = searchKeyNum();
  if (CurrentTab->currentBuffer->firstLine != (Line *)0x0) {
    for (i = 0; i < iVar3; i = i + 1) {
      pLVar1 = CurrentTab->currentBuffer->currentLine;
      iVar2 = CurrentTab->currentBuffer->pos;
      iVar4 = next_nonnull_line(CurrentTab->currentBuffer->currentLine);
      if (iVar4 < 0) break;
      lb = CurrentTab->currentBuffer->currentLine->lineBuf;
      pb = CurrentTab->currentBuffer->currentLine->propBuf;
      while (((lb[CurrentTab->currentBuffer->pos] != '\0' &&
              ((MYCTYPE_MAP[(byte)lb[CurrentTab->currentBuffer->pos]] & 0xc) != 0)) &&
             ((pb[CurrentTab->currentBuffer->pos] & 0x3f00) == 0))) {
        CurrentTab->currentBuffer->pos = CurrentTab->currentBuffer->pos + 1;
      }
      while( true ) {
        while ((lb[CurrentTab->currentBuffer->pos] != '\0' &&
               (((MYCTYPE_MAP[(byte)lb[CurrentTab->currentBuffer->pos]] & 0xc) == 0 ||
                ((pb[CurrentTab->currentBuffer->pos] & 0x3f00) != 0))))) {
          CurrentTab->currentBuffer->pos = CurrentTab->currentBuffer->pos + 1;
        }
        if (lb[CurrentTab->currentBuffer->pos] != '\0') break;
        iVar4 = next_nonnull_line(CurrentTab->currentBuffer->currentLine->next);
        if (iVar4 < 0) {
          CurrentTab->currentBuffer->currentLine = pLVar1;
          CurrentTab->currentBuffer->pos = iVar2;
          goto end;
        }
        CurrentTab->currentBuffer->pos = 0;
        lb = CurrentTab->currentBuffer->currentLine->lineBuf;
        pb = CurrentTab->currentBuffer->currentLine->propBuf;
      }
    }
end:
    arrangeCursor(CurrentTab->currentBuffer);
    displayBuffer(CurrentTab->currentBuffer,0);
  }
  return;
}



void _quitfm(int confirm)

{
  byte bVar1;
  int iVar2;
  char *ans;
  
  ans = "y";
  iVar2 = checkDownloadList();
  if (iVar2 == 0) {
    if (confirm != 0) {
      ans = inputLineHistSearch("Do you want to exit w3m? (y/n)","",0x200,(Hist *)0x0,
                                (anon_subr_int_int_Str_Lineprop_ptr *)0x0);
    }
  }
  else {
    ans = inputLineHistSearch("Download process retains. Do you want to exit w3m? (y/n)","",0x200,
                              (Hist *)0x0,(anon_subr_int_int_Str_Lineprop_ptr *)0x0);
  }
  if (ans != (char *)0x0) {
    if ((MYCTYPE_MAP[(byte)*ans] & 4) == 0) {
      bVar1 = *ans;
    }
    else {
      bVar1 = *ans | 0x20;
    }
    if (bVar1 == 0x79) {
      term_title("");
      if (activeImage != 0) {
        termImage();
      }
      fmTerm();
      save_cookies();
      if ((UseHistory != 0) && (SaveURLHist != 0)) {
        saveHistory(URLHist,URLHistSize);
      }
      w3m_exit(0);
      return;
    }
  }
  displayBuffer(CurrentTab->currentBuffer,0);
  return;
}



void quitfm(void)

{
  _quitfm(0);
  return;
}



void qquitfm(void)

{
  _quitfm(confirm_on_quit);
  return;
}



void selBuf(void)

{
  bool bVar1;
  TabBuffer *pTVar2;
  Buffer *pBVar3;
  int ok;
  Buffer *buf;
  char cmd;
  
  bVar1 = false;
  do {
    pBVar3 = selectBuffer(CurrentTab->firstBuffer,CurrentTab->currentBuffer,&cmd);
    if (cmd == 'D') {
      delBuffer(pBVar3);
      pTVar2 = CurrentTab;
      if (CurrentTab->firstBuffer == (Buffer *)0x0) {
        pBVar3 = nullBuffer();
        pTVar2->firstBuffer = pBVar3;
        CurrentTab->currentBuffer = CurrentTab->firstBuffer;
      }
    }
    else if (cmd < 'E') {
      if (cmd == 'B') {
        bVar1 = true;
      }
      else if ((cmd < 'C') && ((cmd == '\n' || (cmd == ' ')))) {
        CurrentTab->currentBuffer = pBVar3;
        bVar1 = true;
      }
    }
    else if (cmd == 'Q') {
      quitfm();
    }
    else if (cmd == 'q') {
      qquitfm();
    }
  } while (!bVar1);
  for (buf = CurrentTab->firstBuffer; buf != (Buffer *)0x0; buf = buf->nextBuffer) {
    if ((CurrentTab->currentBuffer != buf) && (deleteImage(buf), clear_buffer != 0)) {
      tmpClearBuffer(buf);
    }
  }
  displayBuffer(CurrentTab->currentBuffer,1);
  return;
}



void susp(void)

{
  move(LINES + -1,0);
  clrtoeolx();
  refresh();
  fmTerm();
  kill(0,0x13);
  fmInit();
  displayBuffer(CurrentTab->currentBuffer,1);
  return;
}



void _goLine(char *l)

{
  Buffer *pBVar1;
  Buffer *pBVar2;
  Line *pLVar3;
  int n;
  
  if (((l == (char *)0x0) || (*l == '\0')) ||
     (CurrentTab->currentBuffer->currentLine == (Line *)0x0)) {
    displayBuffer(CurrentTab->currentBuffer,1);
  }
  else {
    CurrentTab->currentBuffer->pos = 0;
    if (((*l == '^') || (*l == '$')) && (prec_num != 0)) {
      gotoRealLine(CurrentTab->currentBuffer,prec_num);
    }
    else if (*l == '^') {
      pBVar1 = CurrentTab->currentBuffer;
      pBVar2 = CurrentTab->currentBuffer;
      pBVar2->currentLine = CurrentTab->currentBuffer->firstLine;
      pBVar1->topLine = pBVar2->currentLine;
    }
    else if (*l == '$') {
      pBVar1 = CurrentTab->currentBuffer;
      pLVar3 = lineSkip(CurrentTab->currentBuffer,CurrentTab->currentBuffer->lastLine,
                        ~(int)CurrentTab->currentBuffer->LINES / 2,1);
      pBVar1->topLine = pLVar3;
      CurrentTab->currentBuffer->currentLine = CurrentTab->currentBuffer->lastLine;
    }
    else {
      n = atoi(l);
      gotoRealLine(CurrentTab->currentBuffer,n);
    }
    arrangeCursor(CurrentTab->currentBuffer);
    displayBuffer(CurrentTab->currentBuffer,1);
  }
  return;
}



void goLine(void)

{
  char *pcVar1;
  char *str;
  
  pcVar1 = searchKeyData();
  if (prec_num == 0) {
    if (pcVar1 == (char *)0x0) {
      pcVar1 = inputLineHistSearch("Goto line: ","",0x10,(Hist *)0x0,
                                   (anon_subr_int_int_Str_Lineprop_ptr *)0x0);
      _goLine(pcVar1);
    }
    else {
      _goLine(pcVar1);
    }
  }
  else {
    _goLine("^");
  }
  return;
}



void goLineF(void)

{
  _goLine("^");
  return;
}



void goLineL(void)

{
  _goLine("$");
  return;
}



void linbeg(void)

{
  if (CurrentTab->currentBuffer->firstLine != (Line *)0x0) {
    while ((CurrentTab->currentBuffer->currentLine->prev != (_Line *)0x0 &&
           (CurrentTab->currentBuffer->currentLine->bpos != 0))) {
      cursorUp0(CurrentTab->currentBuffer,1);
    }
    CurrentTab->currentBuffer->pos = 0;
    arrangeCursor(CurrentTab->currentBuffer);
    displayBuffer(CurrentTab->currentBuffer,0);
  }
  return;
}



void linend(void)

{
  if (CurrentTab->currentBuffer->firstLine != (Line *)0x0) {
    while ((CurrentTab->currentBuffer->currentLine->next != (_Line *)0x0 &&
           (CurrentTab->currentBuffer->currentLine->next->bpos != 0))) {
      cursorDown0(CurrentTab->currentBuffer,1);
    }
    CurrentTab->currentBuffer->pos = CurrentTab->currentBuffer->currentLine->len + -1;
    arrangeCursor(CurrentTab->currentBuffer);
    displayBuffer(CurrentTab->currentBuffer,0);
  }
  return;
}



int cur_real_linenumber(Buffer *buf)

{
  Line *pLVar1;
  int n;
  Line *cur;
  Line *l;
  
  pLVar1 = buf->currentLine;
  if (pLVar1 == (Line *)0x0) {
    n = 1;
  }
  else {
    if (pLVar1->real_linenumber == 0) {
      n = 1;
    }
    else {
      n = pLVar1->real_linenumber;
    }
    for (l = buf->firstLine; ((l != (Line *)0x0 && (l != pLVar1)) && (l->real_linenumber == 0));
        l = l->next) {
      if (l->bpos == 0) {
        n = n + 1;
      }
    }
  }
  return n;
}



void editBf(void)

{
  int iVar1;
  char *attr;
  char *pcVar2;
  Str cmd;
  char *fn;
  
  pcVar2 = CurrentTab->currentBuffer->filename;
  if ((((pcVar2 != (char *)0x0) && (CurrentTab->currentBuffer->pagerSource == (InputStream)0x0)) &&
      ((CurrentTab->currentBuffer->type != (char *)0x0 ||
       (CurrentTab->currentBuffer->edit != (char *)0x0)))) &&
     (((CurrentTab->currentBuffer->real_scheme == 4 &&
       (iVar1 = strcmp((CurrentTab->currentBuffer->currentURL).file,"-"), iVar1 != 0)) &&
      ((CurrentTab->currentBuffer->bufferprop & 2U) == 0)))) {
    if (CurrentTab->currentBuffer->edit == (char *)0x0) {
      iVar1 = cur_real_linenumber(CurrentTab->currentBuffer);
      pcVar2 = shell_quote(pcVar2);
      cmd = myEditor(Editor,pcVar2,iVar1);
    }
    else {
      attr = checkHeader(CurrentTab->currentBuffer,"Content-Type:");
      cmd = unquote_mailcap(CurrentTab->currentBuffer->edit,CurrentTab->currentBuffer->real_type,
                            pcVar2,attr,(int *)0x0);
    }
    fmTerm();
    system(cmd->ptr);
    fmInit();
    displayBuffer(CurrentTab->currentBuffer,1);
    reload();
    return;
  }
  disp_err_message("Can\'t edit other than local file",1);
  return;
}



void editScr(void)

{
  char *__filename;
  Str p_Var1;
  FILE *__stream;
  int line;
  char *file;
  FILE *f;
  char *tmpf;
  
  p_Var1 = tmpfname(0,(char *)0x0);
  __filename = p_Var1->ptr;
  __stream = fopen(__filename,"w");
  if (__stream == (FILE *)0x0) {
    p_Var1 = Sprintf("Can\'t open %s",__filename);
    disp_err_message(p_Var1->ptr,1);
  }
  else {
    saveBuffer(CurrentTab->currentBuffer,(FILE *)__stream,1);
    fclose(__stream);
    fmTerm();
    line = cur_real_linenumber(CurrentTab->currentBuffer);
    file = shell_quote(__filename);
    p_Var1 = myEditor(Editor,file,line);
    system(p_Var1->ptr);
    fmInit();
    unlink(__filename);
    displayBuffer(CurrentTab->currentBuffer,1);
  }
  return;
}



void _mark(void)

{
  Line *pLVar1;
  Line *l;
  
  if ((use_mark != 0) && (CurrentTab->currentBuffer->firstLine != (Line *)0x0)) {
    pLVar1 = CurrentTab->currentBuffer->currentLine;
    pLVar1->propBuf[CurrentTab->currentBuffer->pos] =
         pLVar1->propBuf[CurrentTab->currentBuffer->pos] ^ 1;
    displayBuffer(CurrentTab->currentBuffer,1);
  }
  return;
}



void nextMk(void)

{
  int i;
  Line *l;
  
  if ((use_mark != 0) && (CurrentTab->currentBuffer->firstLine != (Line *)0x0)) {
    i = CurrentTab->currentBuffer->pos + 1;
    l = CurrentTab->currentBuffer->currentLine;
    if (l->len <= i) {
      i = 0;
      l = l->next;
    }
    while (l != (Line *)0x0) {
      for (; i < l->len; i = i + 1) {
        if ((l->propBuf[i] & 1) != 0) {
          CurrentTab->currentBuffer->currentLine = l;
          CurrentTab->currentBuffer->pos = i;
          arrangeCursor(CurrentTab->currentBuffer);
          displayBuffer(CurrentTab->currentBuffer,0);
          return;
        }
      }
      l = l->next;
      i = 0;
    }
    disp_message("No mark exist after here",1);
  }
  return;
}



void prevMk(void)

{
  int i;
  Line *l;
  
  if ((use_mark != 0) && (CurrentTab->currentBuffer->firstLine != (Line *)0x0)) {
    i = CurrentTab->currentBuffer->pos + -1;
    l = CurrentTab->currentBuffer->currentLine;
    if ((i < 0) && (l = l->prev, l != (_Line *)0x0)) {
      i = l->len + -1;
    }
    while (l != (Line *)0x0) {
      for (; -1 < i; i = i + -1) {
        if ((l->propBuf[i] & 1) != 0) {
          CurrentTab->currentBuffer->currentLine = l;
          CurrentTab->currentBuffer->pos = i;
          arrangeCursor(CurrentTab->currentBuffer);
          displayBuffer(CurrentTab->currentBuffer,0);
          return;
        }
      }
      l = l->prev;
      if (l != (_Line *)0x0) {
        i = l->len + -1;
      }
    }
    disp_message("No mark exist before here",1);
  }
  return;
}



void reMark(void)

{
  int iVar1;
  char *p2;
  char *p1;
  char *p;
  char *str;
  Line *l;
  
  if (use_mark != 0) {
    str = searchKeyData();
    if (((str == (char *)0x0) || (*str == '\0')) &&
       ((str = inputLineHistSearch("(Mark)Regexp: ",MarkString,0x10,TextHist,
                                   (anon_subr_int_int_Str_Lineprop_ptr *)0x0), str == (char *)0x0 ||
        (*str == '\0')))) {
      displayBuffer(CurrentTab->currentBuffer,0);
      return;
    }
    str = conv_search_string(str,DisplayCharset);
    str = regexCompile(str,1);
    if (str == (char *)0x0) {
      MarkString = str;
      for (l = CurrentTab->currentBuffer->firstLine; l != (Line *)0x0; l = l->next) {
        p = l->lineBuf;
        while (iVar1 = regexMatch(p,(int)(l->lineBuf + (l->len - (int)p)),(uint)(l->lineBuf == p)),
              iVar1 == 1) {
          matchedPosition(&p1,&p2);
          l->propBuf[(int)p1 - (int)l->lineBuf] = l->propBuf[(int)p1 - (int)l->lineBuf] | 1;
          p = p2;
        }
      }
      displayBuffer(CurrentTab->currentBuffer,1);
    }
    else {
      disp_message(str,1);
    }
  }
  return;
}



Buffer * loadNormalBuf(Buffer *buf,int renderframe)

{
  pushBuffer(buf);
  if (((renderframe != 0) && (RenderFrame != '\0')) &&
     (CurrentTab->currentBuffer->frameset != (frameset *)0x0)) {
    rFrame();
  }
  return buf;
}



Buffer * loadLink(char *url,char *target,char *referer,FormList *request)

{
  _Buffer *p_Var1;
  Buffer *pBVar2;
  Str p_Var3;
  ParsedURL *current;
  ParsedURL *current_00;
  Buffer *pBVar4;
  int iVar5;
  char **f_element_00;
  frameset *fs;
  Line *pLVar6;
  ParsedURL pu;
  char *label;
  Anchor *al;
  char *emsg;
  ParsedURL *base;
  int flag;
  frameset_element *f_element;
  Buffer *nfbuf;
  Buffer *buf;
  
  p_Var3 = Sprintf("loading %s",url);
  message(p_Var3->ptr,0,0);
  refresh();
  current = baseURL(CurrentTab->currentBuffer);
  if (((current == (ParsedURL *)0x0) || (current->scheme == 4)) || (current->scheme == 5)) {
    referer = (char *)0xffffffff;
  }
  if (referer == (char *)0x0) {
    p_Var3 = parsedURL2Str(&CurrentTab->currentBuffer->currentURL);
    referer = p_Var3->ptr;
  }
  current_00 = baseURL(CurrentTab->currentBuffer);
  pBVar4 = loadGeneralFile(url,current_00,referer,0,request);
  if (pBVar4 == (Buffer *)0x0) {
    p_Var3 = Sprintf("Can\'t load %s",url);
    disp_err_message(p_Var3->ptr,0);
    pBVar4 = (Buffer *)0x0;
  }
  else {
    parseURL2(url,&pu,current);
    p_Var3 = parsedURL2Str(&pu);
    pushHashHist(URLHist,p_Var3->ptr);
    if (pBVar4 == (Buffer *)0x1) {
      pBVar4 = (Buffer *)0x0;
    }
    else if (on_target == 0) {
      pBVar4 = loadNormalBuf(pBVar4,1);
    }
    else if (do_download == 0) {
      if (((target != (char *)0x0) && (iVar5 = strcmp(target,"_top"), iVar5 != 0)) &&
         ((CurrentTab->currentBuffer->bufferprop & 2U) != 0)) {
        p_Var1 = CurrentTab->currentBuffer->linkBuffer[1];
        if (p_Var1 == (_Buffer *)0x0) {
          pBVar4 = loadNormalBuf(pBVar4,1);
          return pBVar4;
        }
        f_element_00 = (char **)search_frame(p_Var1->frameset,target);
        if (f_element_00 == (char **)0x0) {
          pBVar4 = loadNormalBuf(pBVar4,1);
          return pBVar4;
        }
        pBVar2 = CurrentTab->currentBuffer;
        fs = copyFrameSet(p_Var1->frameset);
        pushFrameTree(&p_Var1->frameQ,fs,pBVar2);
        delBuffer(CurrentTab->currentBuffer);
        CurrentTab->currentBuffer = p_Var1;
        resetFrameElement(f_element_00,pBVar4,referer,request);
        discardBuffer(pBVar4);
        rFrame();
        al = (Anchor *)0x0;
        if ((pu.label != (char *)0x0) && (**f_element_00 == '\x01')) {
          al = searchAnchor(*(AnchorList **)(*f_element_00 + 0x1c),pu.label);
        }
        if (al == (Anchor *)0x0) {
          p_Var3 = Strnew_m_charp("_",target,0);
          al = searchURLLabel(CurrentTab->currentBuffer,p_Var3->ptr);
        }
        if (al != (Anchor *)0x0) {
          gotoLine(CurrentTab->currentBuffer,(al->start).line);
          if (label_topline != 0) {
            pBVar2 = CurrentTab->currentBuffer;
            pLVar6 = lineSkip(CurrentTab->currentBuffer,CurrentTab->currentBuffer->topLine,
                              CurrentTab->currentBuffer->currentLine->linenumber -
                              CurrentTab->currentBuffer->topLine->linenumber,0);
            pBVar2->topLine = pLVar6;
          }
          CurrentTab->currentBuffer->pos = (al->start).pos;
          arrangeCursor(CurrentTab->currentBuffer);
        }
        displayBuffer(CurrentTab->currentBuffer,0);
        return pBVar4;
      }
      pBVar4 = loadNormalBuf(pBVar4,1);
    }
    else {
      pBVar4 = loadNormalBuf(pBVar4,0);
    }
  }
  return pBVar4;
}



void gotoLabel(char *label)

{
  Anchor *pAVar1;
  Str p_Var2;
  Buffer *pBVar3;
  char *pcVar4;
  Line *pLVar5;
  int i;
  Anchor *al;
  Buffer *buf;
  
  pAVar1 = searchURLLabel(CurrentTab->currentBuffer,label);
  if (pAVar1 == (Anchor *)0x0) {
    p_Var2 = Sprintf("%s is not found",label);
    disp_message(p_Var2->ptr,1);
  }
  else {
    pBVar3 = newBuffer((int)CurrentTab->currentBuffer->width);
    copyBuffer(pBVar3,CurrentTab->currentBuffer);
    for (i = 0; i < 5; i = i + 1) {
      pBVar3->linkBuffer[i] = (_Buffer *)0x0;
    }
    pcVar4 = allocStr(label,-1);
    (pBVar3->currentURL).label = pcVar4;
    p_Var2 = parsedURL2Str(&pBVar3->currentURL);
    pushHashHist(URLHist,p_Var2->ptr);
    *pBVar3->clone = *pBVar3->clone + 1;
    pushBuffer(pBVar3);
    gotoLine(CurrentTab->currentBuffer,(pAVar1->start).line);
    if (label_topline != 0) {
      pBVar3 = CurrentTab->currentBuffer;
      pLVar5 = lineSkip(CurrentTab->currentBuffer,CurrentTab->currentBuffer->topLine,
                        CurrentTab->currentBuffer->currentLine->linenumber -
                        CurrentTab->currentBuffer->topLine->linenumber,0);
      pBVar3->topLine = pLVar5;
    }
    CurrentTab->currentBuffer->pos = (pAVar1->start).pos;
    arrangeCursor(CurrentTab->currentBuffer);
    displayBuffer(CurrentTab->currentBuffer,1);
  }
  return;
}



void followA(void)

{
  Buffer *buf_00;
  bool bVar1;
  ParsedURL *current;
  Str p_Var2;
  int iVar3;
  char *pcVar4;
  ParsedURL u;
  Buffer *buf;
  Str to;
  char *url;
  int map;
  int y;
  int x;
  Anchor *a;
  Line *l;
  
  x = 0;
  y = 0;
  bVar1 = false;
  if (CurrentTab->currentBuffer->firstLine == (Line *)0x0) {
    return;
  }
  l = CurrentTab->currentBuffer->currentLine;
  a = retrieveCurrentImg(CurrentTab->currentBuffer);
  if (((a != (Anchor *)0x0) && (a->image != (Image *)0x0)) && (a->image->map != (char *)0x0)) {
    _followForm(0);
    return;
  }
  if (((a != (Anchor *)0x0) && (a->image != (Image *)0x0)) && (a->image->ismap != '\0')) {
    getMapXY(CurrentTab->currentBuffer,a,&x,&y);
    bVar1 = true;
  }
  a = retrieveCurrentAnchor(CurrentTab->currentBuffer);
  if (a == (Anchor *)0x0) {
    _followForm(0);
    return;
  }
  if (*a->url == '#') {
    gotoLabel(a->url + 1);
    return;
  }
  current = baseURL(CurrentTab->currentBuffer);
  parseURL2(a->url,&u,current);
  p_Var2 = parsedURL2Str(&CurrentTab->currentBuffer->currentURL);
  pcVar4 = p_Var2->ptr;
  p_Var2 = parsedURL2Str(&u);
  iVar3 = strcmp(p_Var2->ptr,pcVar4);
  if ((iVar3 == 0) && (u.label != (char *)0x0)) {
    gotoLabel(u.label);
    return;
  }
  iVar3 = strncasecmp(a->url,"mailto:",7);
  if (((iVar3 == 0) && (iVar3 = non_null(Mailer), iVar3 != 0)) &&
     (pcVar4 = strchr(a->url,0x3f), pcVar4 == (char *)0x0)) {
    p_Var2 = Strnew_charp(a->url + 7);
    fmTerm();
    pcVar4 = file_unquote(p_Var2->ptr);
    pcVar4 = shell_quote(pcVar4);
    p_Var2 = myExtCommand(Mailer,pcVar4,0);
    system(p_Var2->ptr);
    fmInit();
    displayBuffer(CurrentTab->currentBuffer,1);
    pushHashHist(URLHist,a->url);
    return;
  }
  url = a->url;
  if (bVar1) {
    p_Var2 = Sprintf("%s?%d,%d",a->url,x,y);
    url = p_Var2->ptr;
  }
  if (((check_target == 0) || (open_tab_blank == 0)) ||
     ((a->target == (char *)0x0 ||
      ((iVar3 = strcasecmp(a->target,"_new"), iVar3 != 0 &&
       (iVar3 = strcasecmp(a->target,"_blank"), iVar3 != 0)))))) {
    loadLink(url,a->target,a->referer,(FormList *)0x0);
    displayBuffer(CurrentTab->currentBuffer,0);
  }
  else {
    _newT();
    buf_00 = CurrentTab->currentBuffer;
    loadLink(url,a->target,a->referer,(FormList *)0x0);
    if (CurrentTab->currentBuffer == buf_00) {
      deleteTab(CurrentTab);
    }
    else {
      delBuffer(buf_00);
    }
    displayBuffer(CurrentTab->currentBuffer,1);
  }
  return;
}



void bufferA(void)

{
  on_target = 0;
  followA();
  on_target = 1;
  return;
}



void followI(void)

{
  Anchor *pAVar1;
  Str p_Var2;
  ParsedURL *current;
  Buffer *buf_00;
  char *emsg;
  Buffer *buf;
  Anchor *a;
  Line *l;
  
  if ((CurrentTab->currentBuffer->firstLine != (Line *)0x0) &&
     (pAVar1 = retrieveCurrentImg(CurrentTab->currentBuffer), pAVar1 != (Anchor *)0x0)) {
    p_Var2 = Sprintf("loading %s",pAVar1->url);
    message(p_Var2->ptr,0,0);
    refresh();
    current = baseURL(CurrentTab->currentBuffer);
    buf_00 = loadGeneralFile(pAVar1->url,current,(char *)0x0,0,(FormList *)0x0);
    if (buf_00 == (Buffer *)0x0) {
      p_Var2 = Sprintf("Can\'t load %s",pAVar1->url);
      disp_err_message(p_Var2->ptr,0);
    }
    else if (buf_00 != (Buffer *)0x1) {
      pushBuffer(buf_00);
    }
    displayBuffer(CurrentTab->currentBuffer,0);
  }
  return;
}



FormItemList * save_submit_formlist(FormItemList *src)

{
  form_list *pfVar1;
  form_list *pfVar2;
  Str p_Var3;
  FormItemList *pFVar4;
  FormSelectOptionItem *srcopt;
  FormSelectOptionItem *curopt;
  FormSelectOptionItem *opt;
  FormItemList *ret;
  FormItemList *item;
  FormItemList *srcitem;
  FormList *srclist;
  FormList *list;
  
  ret = (FormItemList *)0x0;
  if (src == (FormItemList *)0x0) {
    ret = (FormItemList *)0x0;
  }
  else {
    pfVar1 = src->parent;
    pfVar2 = (form_list *)GC_malloc(0x34);
    pfVar2->method = pfVar1->method;
    p_Var3 = Strdup(pfVar1->action);
    pfVar2->action = p_Var3;
    pfVar2->charset = pfVar1->charset;
    pfVar2->enctype = pfVar1->enctype;
    pfVar2->nitems = pfVar1->nitems;
    pfVar2->body = pfVar1->body;
    pfVar2->boundary = pfVar1->boundary;
    pfVar2->length = pfVar1->length;
    for (srcitem = pfVar1->item; srcitem != (FormItemList *)0x0; srcitem = srcitem->next) {
      pFVar4 = (FormItemList *)GC_malloc(0x48);
      pFVar4->type = srcitem->type;
      p_Var3 = Strdup(srcitem->name);
      pFVar4->name = p_Var3;
      p_Var3 = Strdup(srcitem->value);
      pFVar4->value = p_Var3;
      pFVar4->checked = srcitem->checked;
      pFVar4->accept = srcitem->accept;
      pFVar4->size = srcitem->size;
      pFVar4->rows = srcitem->rows;
      pFVar4->maxlength = srcitem->maxlength;
      pFVar4->readonly = srcitem->readonly;
      curopt = (FormSelectOptionItem *)0x0;
      opt = (FormSelectOptionItem *)0x0;
      for (srcopt = srcitem->select_option; srcopt != (FormSelectOptionItem *)0x0;
          srcopt = srcopt->next) {
        if (srcopt->checked != 0) {
          opt = (FormSelectOptionItem *)GC_malloc(0x10);
          p_Var3 = Strdup(srcopt->value);
          opt->value = p_Var3;
          p_Var3 = Strdup(srcopt->label);
          opt->label = p_Var3;
          opt->checked = srcopt->checked;
          if (pFVar4->select_option == (FormSelectOptionItem *)0x0) {
            pFVar4->select_option = opt;
            curopt = opt;
          }
          else {
            curopt->next = opt;
            curopt = curopt->next;
          }
        }
      }
      pFVar4->select_option = opt;
      if (srcitem->label != (Str)0x0) {
        p_Var3 = Strdup(srcitem->label);
        pFVar4->label = p_Var3;
      }
      pFVar4->parent = pfVar2;
      pFVar4->next = (form_item_list *)0x0;
      if (pfVar2->lastitem == (form_item_list *)0x0) {
        pfVar2->lastitem = pFVar4;
        pfVar2->item = pfVar2->lastitem;
      }
      else {
        pfVar2->lastitem->next = pFVar4;
        pfVar2->lastitem = pFVar4;
      }
      if (srcitem == src) {
        ret = pFVar4;
      }
    }
  }
  return ret;
}



Str conv_form_encoding(Str val,FormItemList *fi,Buffer *buf)

{
  Str p_Var1;
  wc_ces charset;
  
  charset = SystemCharset;
  if (fi->parent->charset == 0) {
    if ((buf->document_charset != 0) && (buf->document_charset != 0x100)) {
      charset = buf->document_charset;
    }
  }
  else {
    charset = fi->parent->charset;
  }
  p_Var1 = wc_Str_conv_strict(val,InnerCharset,charset);
  return p_Var1;
}



void query_from_followform(Str *query,FormItemList *fi,int multipart)

{
  form_list *pfVar1;
  char *pcVar2;
  char *filename;
  int iVar3;
  Str p_Var4;
  Anchor *pAVar5;
  int x;
  int y;
  FILE *body;
  FormItemList *f2;
  
  body = (FILE *)0x0;
  if (multipart != 0) {
    p_Var4 = tmpfname(0,(char *)0x0);
    *query = p_Var4;
    body = (FILE *)fopen((*query)->ptr,"w");
    if ((FILE *)body == (FILE *)0x0) {
      return;
    }
    fi->parent->body = (*query)->ptr;
    pfVar1 = fi->parent;
    p_Var4 = Sprintf("------------------------------%d%ld%ld%ld",CurrentPid,fi->parent,
                     fi->parent->body,fi->parent->boundary);
    pfVar1->boundary = p_Var4->ptr;
  }
  p_Var4 = Strnew();
  *query = p_Var4;
  f2 = fi->parent->item;
  do {
    if (f2 == (FormItemList *)0x0) {
      if (multipart == 0) {
        while ((0 < (*query)->length && ((*query)->ptr[(*query)->length + -1] == '&'))) {
          Strshrink(*query,1);
        }
      }
      else {
        fprintf((FILE *)body,"--%s--\r\n",fi->parent->boundary);
        fclose((FILE *)body);
      }
      return;
    }
    if ((f2->name != (Str)0x0) && ((f2->name->length != 0 || ((multipart == 0 && (f2->type == 0)))))
       ) {
      switch(f2->type) {
      default:
switchD_0805204e_caseD_0:
        if (multipart == 0) {
          if (f2->type == 7) {
            y = 0;
            x = 0;
            pAVar5 = retrieveCurrentImg(CurrentTab->currentBuffer);
            getMapXY(CurrentTab->currentBuffer,pAVar5,&y,&x);
            p_Var4 = conv_form_encoding(f2->name,fi,CurrentTab->currentBuffer);
            p_Var4 = Str_form_quote(p_Var4);
            Strcat(*query,p_Var4);
            p_Var4 = Sprintf(".x=%d&",y);
            Strcat(*query,p_Var4);
            p_Var4 = conv_form_encoding(f2->name,fi,CurrentTab->currentBuffer);
            p_Var4 = Str_form_quote(p_Var4);
            Strcat(*query,p_Var4);
            p_Var4 = Sprintf(".y=%d",x);
            Strcat(*query,p_Var4);
          }
          else {
            if ((f2->name != (Str)0x0) && (0 < f2->name->length)) {
              p_Var4 = conv_form_encoding(f2->name,fi,CurrentTab->currentBuffer);
              p_Var4 = Str_form_quote(p_Var4);
              Strcat(*query,p_Var4);
              if ((*query)->area_size <= (*query)->length + 1) {
                Strgrow(*query);
              }
              p_Var4 = *query;
              iVar3 = p_Var4->length;
              (*query)->ptr[iVar3] = '=';
              p_Var4->length = iVar3 + 1;
              (*query)->ptr[(*query)->length] = '\0';
            }
            if (f2->value != (Str)0x0) {
              if (fi->parent->method == 2) {
                p_Var4 = Str_form_quote(f2->value);
                Strcat(*query,p_Var4);
              }
              else {
                p_Var4 = conv_form_encoding(f2->value,fi,CurrentTab->currentBuffer);
                p_Var4 = Str_form_quote(p_Var4);
                Strcat(*query,p_Var4);
              }
            }
          }
          if (f2->next != (form_item_list *)0x0) {
            if ((*query)->area_size <= (*query)->length + 1) {
              Strgrow(*query);
            }
            p_Var4 = *query;
            iVar3 = p_Var4->length;
            (*query)->ptr[iVar3] = '&';
            p_Var4->length = iVar3 + 1;
            (*query)->ptr[(*query)->length] = '\0';
          }
        }
        else if (f2->type == 7) {
          x = 0;
          y = 0;
          pAVar5 = retrieveCurrentImg(CurrentTab->currentBuffer);
          getMapXY(CurrentTab->currentBuffer,pAVar5,&x,&y);
          p_Var4 = conv_form_encoding(f2->name,fi,CurrentTab->currentBuffer);
          p_Var4 = Strdup(p_Var4);
          *query = p_Var4;
          Strcat_charp(*query,".x");
          p_Var4 = Sprintf("%d",x);
          form_write_data(body,fi->parent->boundary,(*query)->ptr,p_Var4->ptr);
          p_Var4 = conv_form_encoding(f2->name,fi,CurrentTab->currentBuffer);
          p_Var4 = Strdup(p_Var4);
          *query = p_Var4;
          Strcat_charp(*query,".y");
          p_Var4 = Sprintf("%d",y);
          form_write_data(body,fi->parent->boundary,(*query)->ptr,p_Var4->ptr);
        }
        else if (((f2->name != (Str)0x0) && (0 < f2->name->length)) && (f2->value != (Str)0x0)) {
          p_Var4 = conv_form_encoding(f2->value,fi,CurrentTab->currentBuffer);
          *query = p_Var4;
          if (f2->type == 0xb) {
            p_Var4 = wc_Str_conv_strict(f2->value,InnerCharset,SystemCharset);
            pcVar2 = p_Var4->ptr;
            filename = (*query)->ptr;
            p_Var4 = conv_form_encoding(f2->name,fi,CurrentTab->currentBuffer);
            form_write_from_file(body,fi->parent->boundary,p_Var4->ptr,filename,pcVar2);
          }
          else {
            pcVar2 = (*query)->ptr;
            p_Var4 = conv_form_encoding(f2->name,fi,CurrentTab->currentBuffer);
            form_write_data(body,fi->parent->boundary,p_Var4->ptr,pcVar2);
          }
        }
        break;
      case 2:
      case 3:
        p_Var4 = (Str)f2->checked;
joined_r0x08052064:
        if (p_Var4 != (Str)0x0) goto switchD_0805204e_caseD_0;
        break;
      case 4:
      case 7:
        if (f2 == fi) {
          p_Var4 = f2->value;
          goto joined_r0x08052064;
        }
        break;
      case 5:
      }
    }
    f2 = f2->next;
  } while( true );
}



void submitForm(void)

{
  _followForm(1);
  return;
}



void followForm(void)

{
  _followForm(0);
  return;
}



void _followForm(int submit)

{
  char *pcVar1;
  Str p_Var2;
  int iVar3;
  int iVar4;
  Buffer *pBVar5;
  FormItemList *pFVar6;
  stat st;
  Buffer *buf;
  int i;
  int multipart;
  Str tmp2;
  Str tmp;
  FormItemList *f2;
  FormItemList *fi;
  char *p;
  Anchor *a2;
  Anchor *a;
  Line *l;
  
  if (CurrentTab->currentBuffer->firstLine == (Line *)0x0) {
    return;
  }
  l = CurrentTab->currentBuffer->currentLine;
  a = retrieveCurrentForm(CurrentTab->currentBuffer);
  if (a == (Anchor *)0x0) {
    return;
  }
  fi = (FormItemList *)a->url;
  switch(fi->type) {
  case 0:
    if (submit == 0) {
      if (fi->readonly != 0) {
        disp_message_nsec("Read only field!",0,1,1,0);
      }
      if (fi->value == (Str)0x0) {
        pcVar1 = (char *)0x0;
      }
      else {
        pcVar1 = fi->value->ptr;
      }
      p = inputLineHistSearch("TEXT:",pcVar1,0x10,TextHist,(anon_subr_int_int_Str_Lineprop_ptr *)0x0
                             );
      if ((p == (char *)0x0) || (fi->readonly != 0)) goto switchD_080526c4_caseD_6;
      p_Var2 = Strnew_charp(p);
      fi->value = p_Var2;
      formUpdateBuffer(a,CurrentTab->currentBuffer,fi);
      if (fi->accept == 0) {
        iVar3 = fi->parent->nitems;
        goto joined_r0x08052b70;
      }
    }
    break;
  case 1:
    if (submit == 0) {
      if (fi->readonly != 0) {
        disp_message_nsec("Read only field!",0,1,1,0);
        goto switchD_080526c4_caseD_6;
      }
      if (fi->value == (Str)0x0) {
        pcVar1 = (char *)0x0;
      }
      else {
        pcVar1 = fi->value->ptr;
      }
      p = inputLineHistSearch("Password:",pcVar1,0x40,(Hist *)0x0,
                              (anon_subr_int_int_Str_Lineprop_ptr *)0x0);
      if (p == (char *)0x0) goto switchD_080526c4_caseD_6;
      p_Var2 = Strnew_charp(p);
      fi->value = p_Var2;
      formUpdateBuffer(a,CurrentTab->currentBuffer,fi);
      if (fi->accept == 0) goto switchD_080526c4_caseD_6;
    }
    break;
  case 2:
    if (submit == 0) {
      if (fi->readonly == 0) {
        fi->checked = (uint)(fi->checked == 0);
        formUpdateBuffer(a,CurrentTab->currentBuffer,fi);
      }
      else {
        disp_message_nsec("Read only field!",0,1,1,0);
      }
      goto switchD_080526c4_caseD_6;
    }
    break;
  case 3:
    if (submit == 0) {
      if (fi->readonly == 0) {
        formRecheckRadio(a,CurrentTab->currentBuffer,fi);
      }
      else {
        disp_message_nsec("Read only field!",0,1,1,0);
      }
      goto switchD_080526c4_caseD_6;
    }
    break;
  case 4:
  case 7:
  case 10:
    break;
  case 5:
    for (i = 0; i < CurrentTab->currentBuffer->formitem->nanchor; i = i + 1) {
      a2 = CurrentTab->currentBuffer->formitem->anchors + i;
      f2 = (FormItemList *)a2->url;
      if (((((f2->parent == fi->parent) && (f2->name != (Str)0x0)) && (f2->value != (Str)0x0)) &&
          ((f2->type != 4 && (f2->type != 6)))) && (f2->type != 5)) {
        f2->value = f2->init_value;
        f2->checked = f2->init_checked;
        f2->label = f2->init_label;
        f2->selected = f2->init_selected;
        formUpdateBuffer(a2,CurrentTab->currentBuffer,f2);
      }
    }
  default:
    goto switchD_080526c4_caseD_6;
  case 8:
    if (submit == 0) {
      iVar3 = formChooseOptionByMenu
                        (fi,((int)CurrentTab->currentBuffer->cursorX -
                            CurrentTab->currentBuffer->pos) + (a->start).pos +
                            (int)CurrentTab->currentBuffer->rootX,
                         (int)CurrentTab->currentBuffer->cursorY +
                         (int)CurrentTab->currentBuffer->rootY);
      if (iVar3 == 0) goto switchD_080526c4_caseD_6;
      formUpdateBuffer(a,CurrentTab->currentBuffer,fi);
      iVar3 = fi->parent->nitems;
joined_r0x08052b70:
      if (iVar3 != 1) goto switchD_080526c4_caseD_6;
    }
    break;
  case 9:
    if (submit == 0) {
      if (fi->readonly != 0) {
        disp_message_nsec("Read only field!",0,1,1,0);
      }
      input_textarea(fi);
      formUpdateBuffer(a,CurrentTab->currentBuffer,fi);
      goto switchD_080526c4_caseD_6;
    }
    break;
  case 0xb:
    if (submit == 0) {
      if (fi->readonly != 0) {
        disp_message_nsec("Read only field!",0,1,1,0);
      }
      if (fi->value == (Str)0x0) {
        pcVar1 = (char *)0x0;
      }
      else {
        pcVar1 = fi->value->ptr;
      }
      p = inputLineHistSearch("Filename:",pcVar1,0x20,(Hist *)0x0,
                              (anon_subr_int_int_Str_Lineprop_ptr *)0x0);
      if ((p == (char *)0x0) || (fi->readonly != 0)) goto switchD_080526c4_caseD_6;
      p_Var2 = Strnew_charp(p);
      fi->value = p_Var2;
      formUpdateBuffer(a,CurrentTab->currentBuffer,fi);
      if (fi->accept == 0) {
        iVar3 = fi->parent->nitems;
        goto joined_r0x08052b70;
      }
    }
  }
  tmp = Strnew();
  Strnew();
  if ((fi->parent->method == 1) && (fi->parent->enctype == 1)) {
    iVar3 = 1;
  }
  else {
    iVar3 = 0;
  }
  query_from_followform(&tmp,fi,iVar3);
  tmp2 = Strdup(fi->parent->action);
  iVar4 = strcmp(tmp2->ptr,"!CURRENT_URL!");
  if (iVar4 == 0) {
    tmp2 = parsedURL2Str(&CurrentTab->currentBuffer->currentURL);
    p = strchr(tmp2->ptr,0x3f);
    if (p != (char *)0x0) {
      Strshrink(tmp2,(int)(tmp2->ptr + (tmp2->length - (int)p)));
    }
  }
  if (fi->parent->method == 0) {
    p = strchr(tmp2->ptr,0x3f);
    if (p != (char *)0x0) {
      Strshrink(tmp2,(int)(tmp2->ptr + (tmp2->length - (int)p)));
    }
    Strcat_charp(tmp2,"?");
    Strcat(tmp2,tmp);
    loadLink(tmp2->ptr,a->target,(char *)0x0,(FormList *)0x0);
  }
  else if (fi->parent->method == 1) {
    if (iVar3 == 0) {
      fi->parent->body = tmp->ptr;
      fi->parent->length = tmp->length;
    }
    else {
      stat(fi->parent->body,(stat *)&st);
      fi->parent->length = st.st_size;
    }
    pBVar5 = loadLink(tmp2->ptr,a->target,(char *)0x0,fi->parent);
    if (iVar3 != 0) {
      unlink(fi->parent->body);
    }
    if ((pBVar5 != (Buffer *)0x0) && ((pBVar5->bufferprop & 0x20U) == 0)) {
      pFVar6 = save_submit_formlist(fi);
      pBVar5->form_submit = pFVar6;
    }
  }
  else if (((fi->parent->method == 2) &&
           ((iVar3 = strcmp(fi->parent->action->ptr,"map"), iVar3 == 0 ||
            (iVar3 = strcmp(fi->parent->action->ptr,"none"), iVar3 == 0)))) ||
          ((CurrentTab->currentBuffer->bufferprop & 8U) != 0)) {
    do_internal(tmp2->ptr,tmp->ptr);
  }
  else {
    disp_err_message("Can\'t send form because of illegal method.",0);
  }
switchD_080526c4_caseD_6:
  displayBuffer(CurrentTab->currentBuffer,1);
  return;
}



void topA(void)

{
  BufferPoint *pBVar1;
  HmarkerList *pHVar2;
  int hseq;
  Anchor *an;
  BufferPoint *po;
  HmarkerList *hl;
  
  pHVar2 = CurrentTab->currentBuffer->hmarklist;
  hseq = 0;
  if (((CurrentTab->currentBuffer->firstLine != (Line *)0x0) && (pHVar2 != (HmarkerList *)0x0)) &&
     (pHVar2->nmark != 0)) {
    if (pHVar2->nmark < prec_num) {
      hseq = pHVar2->nmark + -1;
    }
    else if (0 < prec_num) {
      hseq = prec_num + -1;
    }
    do {
      if (pHVar2->nmark <= hseq) {
        return;
      }
      pBVar1 = pHVar2->marks + hseq;
      an = retrieveAnchor(CurrentTab->currentBuffer->href,pBVar1->line,pBVar1->pos);
      if (an == (Anchor *)0x0) {
        an = retrieveAnchor(CurrentTab->currentBuffer->formitem,pBVar1->line,pBVar1->pos);
      }
      hseq = hseq + 1;
    } while (an == (Anchor *)0x0);
    gotoLine(CurrentTab->currentBuffer,pBVar1->line);
    CurrentTab->currentBuffer->pos = pBVar1->pos;
    arrangeCursor(CurrentTab->currentBuffer);
    displayBuffer(CurrentTab->currentBuffer,0);
  }
  return;
}



void lastA(void)

{
  BufferPoint *pBVar1;
  HmarkerList *pHVar2;
  int hseq;
  Anchor *an;
  BufferPoint *po;
  HmarkerList *hl;
  
  pHVar2 = CurrentTab->currentBuffer->hmarklist;
  if (((CurrentTab->currentBuffer->firstLine != (Line *)0x0) && (pHVar2 != (HmarkerList *)0x0)) &&
     (pHVar2->nmark != 0)) {
    if (prec_num < pHVar2->nmark) {
      if (prec_num < 1) {
        hseq = pHVar2->nmark + -1;
      }
      else {
        hseq = pHVar2->nmark - prec_num;
      }
    }
    else {
      hseq = 0;
    }
    do {
      if (hseq < 0) {
        return;
      }
      pBVar1 = pHVar2->marks + hseq;
      an = retrieveAnchor(CurrentTab->currentBuffer->href,pBVar1->line,pBVar1->pos);
      if (an == (Anchor *)0x0) {
        an = retrieveAnchor(CurrentTab->currentBuffer->formitem,pBVar1->line,pBVar1->pos);
      }
      hseq = hseq + -1;
    } while (an == (Anchor *)0x0);
    gotoLine(CurrentTab->currentBuffer,pBVar1->line);
    CurrentTab->currentBuffer->pos = pBVar1->pos;
    arrangeCursor(CurrentTab->currentBuffer);
    displayBuffer(CurrentTab->currentBuffer,0);
  }
  return;
}



void nextA(void)

{
  _nextA(0);
  return;
}



void prevA(void)

{
  _prevA(0);
  return;
}



void nextVA(void)

{
  _nextA(1);
  return;
}



void prevVA(void)

{
  _prevA(1);
  return;
}



void _nextA(int visited)

{
  HmarkerList *pHVar1;
  BufferPoint *pBVar2;
  int iVar3;
  Anchor *pAVar4;
  ParsedURL *pPVar5;
  Str p_Var6;
  HistItem *pHVar7;
  ParsedURL url;
  int hseq;
  int n;
  int y;
  int x;
  int i;
  Anchor *pan;
  Anchor *an;
  BufferPoint *po;
  HmarkerList *hl;
  
  pHVar1 = CurrentTab->currentBuffer->hmarklist;
  n = searchKeyNum();
  if (((CurrentTab->currentBuffer->firstLine != (Line *)0x0) && (pHVar1 != (HmarkerList *)0x0)) &&
     (pHVar1->nmark != 0)) {
    an = retrieveCurrentAnchor(CurrentTab->currentBuffer);
    if ((visited != 1) && (an == (Anchor *)0x0)) {
      an = retrieveCurrentForm(CurrentTab->currentBuffer);
    }
    y = CurrentTab->currentBuffer->currentLine->linenumber;
    x = CurrentTab->currentBuffer->pos;
    if (visited == 1) {
      n = pHVar1->nmark;
    }
    for (i = 0; pAVar4 = an, i < n; i = i + 1) {
      if ((an == (Anchor *)0x0) || (an->hseq < 0)) {
        an = closest_next_anchor(CurrentTab->currentBuffer->href,(Anchor *)0x0,x,y);
        if (visited != 1) {
          an = closest_next_anchor(CurrentTab->currentBuffer->formitem,an,x,y);
        }
        if (an == (Anchor *)0x0) {
          if (visited == 1) {
            return;
          }
          break;
        }
        x = (an->start).pos;
        y = (an->start).line;
        if (visited == 1) {
          pPVar5 = baseURL(CurrentTab->currentBuffer);
          parseURL2(an->url,&url,pPVar5);
          p_Var6 = parsedURL2Str(&url);
          pHVar7 = getHashHist(URLHist,p_Var6->ptr);
          if (pHVar7 != (HistItem *)0x0) goto _end;
        }
      }
      else {
        hseq = an->hseq + 1;
        do {
          if (pHVar1->nmark <= hseq) {
            an = pAVar4;
            if (visited == 1) {
              return;
            }
            goto _end;
          }
          pBVar2 = pHVar1->marks + hseq;
          an = retrieveAnchor(CurrentTab->currentBuffer->href,pBVar2->line,pBVar2->pos);
          if ((visited != 1) && (an == (Anchor *)0x0)) {
            an = retrieveAnchor(CurrentTab->currentBuffer->formitem,pBVar2->line,pBVar2->pos);
          }
          hseq = hseq + 1;
          if ((visited == 1) && (an != (Anchor *)0x0)) {
            pPVar5 = baseURL(CurrentTab->currentBuffer);
            parseURL2(an->url,&url,pPVar5);
            p_Var6 = parsedURL2Str(&url);
            pHVar7 = getHashHist(URLHist,p_Var6->ptr);
            if (pHVar7 != (HistItem *)0x0) goto _end;
          }
        } while ((an == (Anchor *)0x0) || (an == pAVar4));
      }
    }
    an = pAVar4;
    if (visited != 1) {
_end:
      if ((an != (Anchor *)0x0) && (-1 < an->hseq)) {
        pBVar2 = pHVar1->marks;
        iVar3 = an->hseq;
        gotoLine(CurrentTab->currentBuffer,pBVar2[iVar3].line);
        CurrentTab->currentBuffer->pos = pBVar2[iVar3].pos;
        arrangeCursor(CurrentTab->currentBuffer);
        displayBuffer(CurrentTab->currentBuffer,0);
      }
    }
  }
  return;
}



void _prevA(int visited)

{
  HmarkerList *pHVar1;
  BufferPoint *pBVar2;
  int iVar3;
  Anchor *pAVar4;
  ParsedURL *pPVar5;
  Str p_Var6;
  HistItem *pHVar7;
  ParsedURL url;
  int hseq;
  int n;
  int y;
  int x;
  int i;
  Anchor *pan;
  Anchor *an;
  BufferPoint *po;
  HmarkerList *hl;
  
  pHVar1 = CurrentTab->currentBuffer->hmarklist;
  n = searchKeyNum();
  if (((CurrentTab->currentBuffer->firstLine != (Line *)0x0) && (pHVar1 != (HmarkerList *)0x0)) &&
     (pHVar1->nmark != 0)) {
    an = retrieveCurrentAnchor(CurrentTab->currentBuffer);
    if ((visited != 1) && (an == (Anchor *)0x0)) {
      an = retrieveCurrentForm(CurrentTab->currentBuffer);
    }
    y = CurrentTab->currentBuffer->currentLine->linenumber;
    x = CurrentTab->currentBuffer->pos;
    if (visited == 1) {
      n = pHVar1->nmark;
    }
    for (i = 0; pAVar4 = an, i < n; i = i + 1) {
      if ((an == (Anchor *)0x0) || (an->hseq < 0)) {
        an = closest_prev_anchor(CurrentTab->currentBuffer->href,(Anchor *)0x0,x,y);
        if (visited != 1) {
          an = closest_prev_anchor(CurrentTab->currentBuffer->formitem,an,x,y);
        }
        if (an == (Anchor *)0x0) {
          if (visited == 1) {
            return;
          }
          break;
        }
        x = (an->start).pos;
        y = (an->start).line;
        if ((visited == 1) && (an != (Anchor *)0x0)) {
          pPVar5 = baseURL(CurrentTab->currentBuffer);
          parseURL2(an->url,&url,pPVar5);
          p_Var6 = parsedURL2Str(&url);
          pHVar7 = getHashHist(URLHist,p_Var6->ptr);
          if (pHVar7 != (HistItem *)0x0) goto _end;
        }
      }
      else {
        hseq = an->hseq + -1;
        do {
          if (hseq < 0) {
            an = pAVar4;
            if (visited == 1) {
              return;
            }
            goto _end;
          }
          pBVar2 = pHVar1->marks + hseq;
          an = retrieveAnchor(CurrentTab->currentBuffer->href,pBVar2->line,pBVar2->pos);
          if ((visited != 1) && (an == (Anchor *)0x0)) {
            an = retrieveAnchor(CurrentTab->currentBuffer->formitem,pBVar2->line,pBVar2->pos);
          }
          hseq = hseq + -1;
          if ((visited == 1) && (an != (Anchor *)0x0)) {
            pPVar5 = baseURL(CurrentTab->currentBuffer);
            parseURL2(an->url,&url,pPVar5);
            p_Var6 = parsedURL2Str(&url);
            pHVar7 = getHashHist(URLHist,p_Var6->ptr);
            if (pHVar7 != (HistItem *)0x0) goto _end;
          }
        } while ((an == (Anchor *)0x0) || (an == pAVar4));
      }
    }
    an = pAVar4;
    if (visited != 1) {
_end:
      if ((an != (Anchor *)0x0) && (-1 < an->hseq)) {
        pBVar2 = pHVar1->marks;
        iVar3 = an->hseq;
        gotoLine(CurrentTab->currentBuffer,pBVar2[iVar3].line);
        CurrentTab->currentBuffer->pos = pBVar2[iVar3].pos;
        arrangeCursor(CurrentTab->currentBuffer);
        displayBuffer(CurrentTab->currentBuffer,0);
      }
    }
  }
  return;
}



void nextX(int d,int dy)

{
  HmarkerList *pHVar1;
  int iVar2;
  int n;
  int y;
  int x;
  int i;
  Line *l;
  Anchor *pan;
  Anchor *an;
  HmarkerList *hl;
  
  pHVar1 = CurrentTab->currentBuffer->hmarklist;
  iVar2 = searchKeyNum();
  if (((CurrentTab->currentBuffer->firstLine != (Line *)0x0) && (pHVar1 != (HmarkerList *)0x0)) &&
     (pHVar1->nmark != 0)) {
    an = retrieveCurrentAnchor(CurrentTab->currentBuffer);
    if (an == (Anchor *)0x0) {
      an = retrieveCurrentForm(CurrentTab->currentBuffer);
    }
    l = CurrentTab->currentBuffer->currentLine;
    x = CurrentTab->currentBuffer->pos;
    y = l->linenumber;
    pan = (Anchor *)0x0;
    i = 0;
LAB_08053b5f:
    if (i < iVar2) {
      if (an != (Anchor *)0x0) {
        if (d < 1) {
          x = (an->start).pos + -1;
        }
        else {
          x = (an->end).pos;
        }
      }
      an = (Anchor *)0x0;
      do {
        for (; (-1 < x && (x < l->len)); x = x + d) {
          an = retrieveAnchor(CurrentTab->currentBuffer->href,y,x);
          if (an == (Anchor *)0x0) {
            an = retrieveAnchor(CurrentTab->currentBuffer->formitem,y,x);
          }
          if (an != (Anchor *)0x0) {
            pan = an;
            break;
          }
        }
        if ((dy == 0) || (an != (Anchor *)0x0)) goto LAB_08053b55;
        if (dy < 1) {
          l = l->prev;
        }
        else {
          l = l->next;
        }
        if (l == (_Line *)0x0) goto LAB_08053b55;
        if (d < 1) {
          x = l->len + -1;
        }
        else {
          x = 0;
        }
        y = l->linenumber;
      } while( true );
    }
LAB_08053b6e:
    if (pan != (Anchor *)0x0) {
      gotoLine(CurrentTab->currentBuffer,y);
      CurrentTab->currentBuffer->pos = (pan->start).pos;
      arrangeCursor(CurrentTab->currentBuffer);
      displayBuffer(CurrentTab->currentBuffer,0);
    }
  }
  return;
LAB_08053b55:
  if (an == (Anchor *)0x0) goto LAB_08053b6e;
  i = i + 1;
  goto LAB_08053b5f;
}



void nextY(int d)

{
  HmarkerList *pHVar1;
  int pos;
  int iVar2;
  uint uVar3;
  int hseq;
  int n;
  int y;
  int x;
  int i;
  Anchor *pan;
  Anchor *an;
  HmarkerList *hl;
  
  pHVar1 = CurrentTab->currentBuffer->hmarklist;
  iVar2 = searchKeyNum();
  if (((CurrentTab->currentBuffer->firstLine != (Line *)0x0) && (pHVar1 != (HmarkerList *)0x0)) &&
     (pHVar1->nmark != 0)) {
    an = retrieveCurrentAnchor(CurrentTab->currentBuffer);
    if (an == (Anchor *)0x0) {
      an = retrieveCurrentForm(CurrentTab->currentBuffer);
    }
    pos = CurrentTab->currentBuffer->pos;
    y = CurrentTab->currentBuffer->currentLine->linenumber + d;
    pan = (Anchor *)0x0;
    hseq = -1;
    for (i = 0; i < iVar2; i = i + 1) {
      if (an != (Anchor *)0x0) {
        uVar3 = an->hseq >> 0x1f;
        hseq = (an->hseq ^ uVar3) - uVar3;
      }
      an = (Anchor *)0x0;
      while( true ) {
        if ((y < 0) || (CurrentTab->currentBuffer->lastLine->linenumber < y)) goto LAB_08053d36;
        an = retrieveAnchor(CurrentTab->currentBuffer->href,y,pos);
        if (an == (Anchor *)0x0) {
          an = retrieveAnchor(CurrentTab->currentBuffer->formitem,y,pos);
        }
        if ((an != (Anchor *)0x0) && (uVar3 = an->hseq >> 0x1f, (an->hseq ^ uVar3) - uVar3 != hseq))
        break;
        y = y + d;
      }
      pan = an;
LAB_08053d36:
      if (an == (Anchor *)0x0) break;
    }
    if (pan != (Anchor *)0x0) {
      gotoLine(CurrentTab->currentBuffer,(pan->start).line);
      arrangeLine(CurrentTab->currentBuffer);
      displayBuffer(CurrentTab->currentBuffer,0);
    }
  }
  return;
}



void nextL(void)

{
  nextX(-1,0);
  return;
}



void nextLU(void)

{
  nextX(-1,-1);
  return;
}



void nextR(void)

{
  nextX(1,0);
  return;
}



void nextRD(void)

{
  nextX(1,1);
  return;
}



void nextD(void)

{
  nextY(1);
  return;
}



void nextU(void)

{
  nextY(-1);
  return;
}



void nextBf(void)

{
  Buffer *pBVar1;
  int iVar2;
  int i;
  Buffer *buf;
  
  i = 0;
  while( true ) {
    iVar2 = prec_num;
    if (prec_num == 0) {
      iVar2 = 1;
    }
    if (iVar2 <= i) goto LAB_08053ea5;
    pBVar1 = prevBuffer(CurrentTab->firstBuffer,CurrentTab->currentBuffer);
    if (pBVar1 == (Buffer *)0x0) break;
    CurrentTab->currentBuffer = pBVar1;
    i = i + 1;
  }
  if (i != 0) {
LAB_08053ea5:
    displayBuffer(CurrentTab->currentBuffer,1);
  }
  return;
}



void prevBf(void)

{
  _Buffer *p_Var1;
  int iVar2;
  int i;
  Buffer *buf;
  
  i = 0;
  while( true ) {
    iVar2 = prec_num;
    if (prec_num == 0) {
      iVar2 = 1;
    }
    if (iVar2 <= i) goto LAB_08053f16;
    p_Var1 = CurrentTab->currentBuffer->nextBuffer;
    if (p_Var1 == (_Buffer *)0x0) break;
    CurrentTab->currentBuffer = p_Var1;
    i = i + 1;
  }
  if (i != 0) {
LAB_08053f16:
    displayBuffer(CurrentTab->currentBuffer,1);
  }
  return;
}



int checkBackBuffer(Buffer *buf)

{
  _Buffer *p_Var1;
  Buffer *fbuf;
  
  p_Var1 = buf->linkBuffer[1];
  if (p_Var1 != (_Buffer *)0x0) {
    if (p_Var1->frameQ != (frameset_queue *)0x0) {
      return 1;
    }
    if ((RenderFrame != '\0') && (buf->nextBuffer == p_Var1)) {
      if (p_Var1->nextBuffer != (_Buffer *)0x0) {
        return 1;
      }
      return 0;
    }
  }
  return (uint)(buf->nextBuffer != (_Buffer *)0x0);
}



void backBf(void)

{
  _Buffer *p_Var1;
  int iVar2;
  int iVar3;
  int iVar4;
  AnchorList *formitem_00;
  Buffer *pBVar5;
  int iVar6;
  frameset *pfVar7;
  Line *pLVar8;
  AnchorList *formitem;
  int currentColumn;
  int pos;
  long top;
  long linenumber;
  frameset *fs;
  Buffer *buf;
  
  p_Var1 = CurrentTab->currentBuffer->linkBuffer[1];
  iVar6 = checkBackBuffer(CurrentTab->currentBuffer);
  if (iVar6 == 0) {
    if ((close_tab_back == 0) || (nTab < 1)) {
      disp_message("Can\'t back...",1);
    }
    else {
      deleteTab(CurrentTab);
      displayBuffer(CurrentTab->currentBuffer,1);
    }
  }
  else {
    delBuffer(CurrentTab->currentBuffer);
    if (p_Var1 != (_Buffer *)0x0) {
      if (p_Var1->frameQ == (frameset_queue *)0x0) {
        if ((RenderFrame != '\0') && (CurrentTab->currentBuffer == p_Var1)) {
          delBuffer(CurrentTab->currentBuffer);
        }
      }
      else {
        iVar6 = p_Var1->frameQ->linenumber;
        iVar2 = p_Var1->frameQ->top_linenumber;
        iVar3 = p_Var1->frameQ->pos;
        iVar4 = p_Var1->frameQ->currentColumn;
        formitem_00 = p_Var1->frameQ->formitem;
        pfVar7 = popFrameTree(&p_Var1->frameQ);
        deleteFrameSet(p_Var1->frameset);
        p_Var1->frameset = pfVar7;
        if (CurrentTab->currentBuffer == p_Var1) {
          rFrame();
          pBVar5 = CurrentTab->currentBuffer;
          pLVar8 = lineSkip(CurrentTab->currentBuffer,CurrentTab->currentBuffer->firstLine,
                            iVar2 + -1,0);
          pBVar5->topLine = pLVar8;
          gotoLine(CurrentTab->currentBuffer,iVar6);
          CurrentTab->currentBuffer->pos = iVar3;
          CurrentTab->currentBuffer->currentColumn = iVar4;
          arrangeCursor(CurrentTab->currentBuffer);
          formResetBuffer(CurrentTab->currentBuffer,formitem_00);
        }
      }
    }
    displayBuffer(CurrentTab->currentBuffer,1);
  }
  return;
}



void deletePrevBuf(void)

{
  Buffer *buf_00;
  Buffer *buf;
  
  buf_00 = CurrentTab->currentBuffer->nextBuffer;
  if (buf_00 != (Buffer *)0x0) {
    delBuffer(buf_00);
  }
  return;
}



void cmd_loadURL(char *url,ParsedURL *current,char *referer,FormList *request)

{
  wc_ces t_ces;
  wc_ces f_ces;
  int iVar1;
  char *pcVar2;
  Str p_Var3;
  Buffer *buf_00;
  char *emsg;
  Str to;
  Buffer *buf;
  
  iVar1 = strncasecmp(url,"mailto:",7);
  if (((iVar1 == 0) && (iVar1 = non_null(Mailer), iVar1 != 0)) &&
     (pcVar2 = strchr(url,0x3f), pcVar2 == (char *)0x0)) {
    p_Var3 = Strnew_charp(url + 7);
    fmTerm();
    pcVar2 = file_unquote(p_Var3->ptr);
    pcVar2 = shell_quote(pcVar2);
    p_Var3 = myExtCommand(Mailer,pcVar2,0);
    system(p_Var3->ptr);
    fmInit();
    displayBuffer(CurrentTab->currentBuffer,1);
    pushHashHist(URLHist,url);
    return;
  }
  refresh();
  buf_00 = loadGeneralFile(url,current,referer,0,request);
  f_ces = SystemCharset;
  t_ces = InnerCharset;
  if (buf_00 == (Buffer *)0x0) {
    p_Var3 = Strnew_charp(url);
    p_Var3 = wc_Str_conv(p_Var3,f_ces,t_ces);
    p_Var3 = Sprintf("Can\'t load %s",p_Var3->ptr);
    disp_err_message(p_Var3->ptr,0);
  }
  else if (((buf_00 != (Buffer *)0x1) && (pushBuffer(buf_00), RenderFrame != '\0')) &&
          (CurrentTab->currentBuffer->frameset != (frameset *)0x0)) {
    rFrame();
  }
  displayBuffer(CurrentTab->currentBuffer,0);
  return;
}



void goURL0(char *prompt,int relative)

{
  Buffer *pBVar1;
  char *pcVar2;
  wc_ces wVar3;
  wc_ces f_ces;
  Hist *hist_00;
  ParsedURL *pu;
  Str p_Var4;
  Anchor *pAVar5;
  ParsedURL p_url;
  char *a_url;
  char *c_url;
  Anchor *a;
  Hist *hist;
  Buffer *cur_buf;
  ParsedURL *current;
  char *referer;
  char *url;
  
  pBVar1 = CurrentTab->currentBuffer;
  url = searchKeyData();
  if (url == (char *)0x0) {
    hist_00 = copyHist(URLHist);
    pu = baseURL(CurrentTab->currentBuffer);
    if (pu != (ParsedURL *)0x0) {
      p_Var4 = parsedURL2Str(pu);
      pcVar2 = p_Var4->ptr;
      if (DefaultURLString == 1) {
        url = pcVar2;
        if (DecodeURL != 0) {
          url = url_unquote_conv(pcVar2,0);
        }
      }
      else {
        pushHist(hist_00,pcVar2);
      }
    }
    pAVar5 = retrieveCurrentAnchor(CurrentTab->currentBuffer);
    if (pAVar5 != (Anchor *)0x0) {
      parseURL2(pAVar5->url,&p_url,pu);
      p_Var4 = parsedURL2Str(&p_url);
      pcVar2 = p_Var4->ptr;
      if (DefaultURLString == 2) {
        url = pcVar2;
        if (DecodeURL != 0) {
          url = url_unquote_conv(pcVar2,CurrentTab->currentBuffer->document_charset);
        }
      }
      else {
        pushHist(hist_00,pcVar2);
      }
    }
    url = inputLineHistSearch(prompt,url,0x100,hist_00,(anon_subr_int_int_Str_Lineprop_ptr *)0x0);
    if (url != (char *)0x0) {
      while ((*url != '\0' && ((MYCTYPE_MAP[(byte)*url] & 2) != 0))) {
        url = url + 1;
      }
    }
  }
  wVar3 = SystemCharset;
  f_ces = InnerCharset;
  if (url != (char *)0x0) {
    if (((relative == 0) && (*url != '#')) || (CurrentTab->currentBuffer->document_charset == 0)) {
      p_Var4 = Strnew_charp(url);
      p_Var4 = wc_Str_conv_strict(p_Var4,f_ces,wVar3);
      url = p_Var4->ptr;
    }
    else {
      wVar3 = CurrentTab->currentBuffer->document_charset;
      p_Var4 = Strnew_charp(url);
      p_Var4 = wc_Str_conv_strict(p_Var4,f_ces,wVar3);
      url = p_Var4->ptr;
    }
  }
  if ((url == (char *)0x0) || (*url == '\0')) {
    displayBuffer(CurrentTab->currentBuffer,1);
  }
  else if (*url == '#') {
    gotoLabel(url + 1);
  }
  else {
    if (relative == 0) {
      current = (ParsedURL *)0x0;
      referer = (char *)0x0;
    }
    else {
      current = baseURL(CurrentTab->currentBuffer);
      p_Var4 = parsedURL2Str(&CurrentTab->currentBuffer->currentURL);
      referer = p_Var4->ptr;
    }
    parseURL2(url,&p_url,current);
    p_Var4 = parsedURL2Str(&p_url);
    pushHashHist(URLHist,p_Var4->ptr);
    cmd_loadURL(url,current,referer,(FormList *)0x0);
    if (CurrentTab->currentBuffer != pBVar1) {
      p_Var4 = parsedURL2Str(&CurrentTab->currentBuffer->currentURL);
      pushHashHist(URLHist,p_Var4->ptr);
    }
  }
  return;
}



void goURL(void)

{
  goURL0("Goto URL: ",0);
  return;
}



void gorURL(void)

{
  goURL0("Goto relative URL: ",1);
  return;
}



void cmd_loadBuffer(Buffer *buf,int prop,int linkid)

{
  if (buf == (Buffer *)0x0) {
    disp_err_message("Can\'t load string",0);
  }
  else if (buf != (Buffer *)0x1) {
    buf->bufferprop = buf->bufferprop | (ushort)prop | 8;
    if ((buf->bufferprop & 0x10U) == 0) {
      copyParsedURL(&buf->currentURL,&CurrentTab->currentBuffer->currentURL);
    }
    if (linkid != -1) {
      buf->linkBuffer[REV_LB[linkid]] = CurrentTab->currentBuffer;
      CurrentTab->currentBuffer->linkBuffer[linkid] = buf;
    }
    pushBuffer(buf);
  }
  displayBuffer(CurrentTab->currentBuffer,1);
  return;
}



void ldBmark(void)

{
  cmd_loadURL(BookmarkFile,(ParsedURL *)0x0,(char *)0xffffffff,(FormList *)0x0);
  return;
}



void adBmark(void)

{
  char *pcVar1;
  char *pcVar2;
  char *pcVar3;
  wc_ces f_ces;
  wc_ces t_ces;
  char *pcVar4;
  Str p_Var5;
  form_list *request_00;
  FormList *request;
  Str tmp;
  
  pcVar4 = wc_ces_to_charset(BookmarkCharset);
  t_ces = BookmarkCharset;
  f_ces = InnerCharset;
  p_Var5 = Strnew_charp(CurrentTab->currentBuffer->buffername);
  p_Var5 = wc_Str_conv_strict(p_Var5,f_ces,t_ces);
  p_Var5 = Str_form_quote(p_Var5);
  pcVar1 = p_Var5->ptr;
  p_Var5 = parsedURL2Str(&CurrentTab->currentBuffer->currentURL);
  p_Var5 = Str_form_quote(p_Var5);
  pcVar2 = p_Var5->ptr;
  p_Var5 = Strnew_charp(BookmarkFile);
  p_Var5 = Str_form_quote(p_Var5);
  pcVar3 = p_Var5->ptr;
  p_Var5 = localCookie();
  p_Var5 = Str_form_quote(p_Var5);
  p_Var5 = Sprintf("mode=panel&cookie=%s&bmark=%s&url=%s&title=%s&charset=%s",p_Var5->ptr,pcVar3,
                   pcVar2,pcVar1,pcVar4);
  request_00 = newFormList((char *)0x0,"post",(char *)0x0,(char *)0x0,(char *)0x0,(char *)0x0,
                           (form_list *)0x0);
  request_00->body = p_Var5->ptr;
  request_00->length = p_Var5->length;
  cmd_loadURL("file:///$LIB/w3mbookmark",(ParsedURL *)0x0,(char *)0xffffffff,request_00);
  return;
}



void ldOpt(void)

{
  Buffer *buf;
  
  buf = load_option_panel();
  cmd_loadBuffer(buf,0x10,-1);
  return;
}



void setOpt(void)

{
  char *pcVar1;
  Str p_Var2;
  int iVar3;
  char *v;
  char *opt;
  
  CurrentKeyData = (char *)0x0;
  opt = searchKeyData();
  if (((opt == (char *)0x0) || (*opt == '\0')) || (pcVar1 = strchr(opt,0x3d), pcVar1 == (char *)0x0)
     ) {
    if ((opt != (char *)0x0) && (*opt != '\0')) {
      pcVar1 = get_param_option(opt);
      if (pcVar1 == (char *)0x0) {
        pcVar1 = "";
      }
      p_Var2 = Sprintf("%s=%s",opt,pcVar1);
      opt = p_Var2->ptr;
    }
    opt = inputLineHistSearch("Set option: ",opt,0x10,TextHist,
                              (anon_subr_int_int_Str_Lineprop_ptr *)0x0);
    if ((opt == (char *)0x0) || (*opt == '\0')) {
      displayBuffer(CurrentTab->currentBuffer,0);
      return;
    }
  }
  iVar3 = set_param_option(opt);
  if (iVar3 != 0) {
    sync_with_option();
  }
  displayBuffer(CurrentTab->currentBuffer,4);
  return;
}



void msgs(void)

{
  Buffer *buf;
  
  buf = message_list_panel();
  cmd_loadBuffer(buf,0x10,-1);
  return;
}



void pginfo(void)

{
  _Buffer *p_Var1;
  Buffer *pBVar2;
  Buffer *buf;
  
  p_Var1 = CurrentTab->currentBuffer->linkBuffer[3];
  if (p_Var1 == (_Buffer *)0x0) {
    pBVar2 = CurrentTab->currentBuffer->linkBuffer[2];
    if (pBVar2 != (Buffer *)0x0) {
      delBuffer(pBVar2);
    }
    pBVar2 = page_info_panel(CurrentTab->currentBuffer);
    cmd_loadBuffer(pBVar2,0,2);
  }
  else {
    CurrentTab->currentBuffer = p_Var1;
    displayBuffer(CurrentTab->currentBuffer,0);
  }
  return;
}



void follow_map(parsed_tagarg *arg)

{
  Buffer *buf_00;
  char *pcVar1;
  Anchor *a_img;
  MapArea *pMVar2;
  ParsedURL *pPVar3;
  Str p_Var4;
  int iVar5;
  ParsedURL p_url;
  Buffer *buf;
  int y;
  int x;
  MapArea *a;
  Anchor *an;
  char *name;
  
  pcVar1 = tag_get_value(arg,"link");
  a_img = retrieveCurrentImg(CurrentTab->currentBuffer);
  pMVar2 = follow_map_menu(CurrentTab->currentBuffer,pcVar1,a_img,
                           (int)CurrentTab->currentBuffer->cursorX +
                           (int)CurrentTab->currentBuffer->rootX,
                           (int)CurrentTab->currentBuffer->cursorY +
                           (int)CurrentTab->currentBuffer->rootY);
  if (((pMVar2 != (MapArea *)0x0) && (pMVar2->url != (char *)0x0)) && (*pMVar2->url != '\0')) {
    if (*pMVar2->url == '#') {
      gotoLabel(pMVar2->url + 1);
    }
    else {
      pPVar3 = baseURL(CurrentTab->currentBuffer);
      parseURL2(pMVar2->url,&p_url,pPVar3);
      p_Var4 = parsedURL2Str(&p_url);
      pushHashHist(URLHist,p_Var4->ptr);
      if (((check_target == 0) || (open_tab_blank == 0)) ||
         ((pMVar2->target == (char *)0x0 ||
          ((iVar5 = strcasecmp(pMVar2->target,"_new"), iVar5 != 0 &&
           (iVar5 = strcasecmp(pMVar2->target,"_blank"), iVar5 != 0)))))) {
        p_Var4 = parsedURL2Str(&CurrentTab->currentBuffer->currentURL);
        pcVar1 = p_Var4->ptr;
        pPVar3 = baseURL(CurrentTab->currentBuffer);
        cmd_loadURL(pMVar2->url,pPVar3,pcVar1,(FormList *)0x0);
      }
      else {
        _newT();
        buf_00 = CurrentTab->currentBuffer;
        p_Var4 = parsedURL2Str(&CurrentTab->currentBuffer->currentURL);
        pcVar1 = p_Var4->ptr;
        pPVar3 = baseURL(CurrentTab->currentBuffer);
        cmd_loadURL(pMVar2->url,pPVar3,pcVar1,(FormList *)0x0);
        if (CurrentTab->currentBuffer == buf_00) {
          deleteTab(CurrentTab);
        }
        else {
          delBuffer(buf_00);
        }
        displayBuffer(CurrentTab->currentBuffer,1);
      }
    }
  }
  return;
}



void linkMn(void)

{
  char *referer;
  LinkList *pLVar1;
  ParsedURL *pPVar2;
  Str p_Var3;
  ParsedURL p_url;
  LinkList *l;
  
  pLVar1 = link_menu(CurrentTab->currentBuffer);
  if ((pLVar1 != (LinkList *)0x0) && (pLVar1->url != (char *)0x0)) {
    if (*pLVar1->url == '#') {
      gotoLabel(pLVar1->url + 1);
    }
    else {
      pPVar2 = baseURL(CurrentTab->currentBuffer);
      parseURL2(pLVar1->url,&p_url,pPVar2);
      p_Var3 = parsedURL2Str(&p_url);
      pushHashHist(URLHist,p_Var3->ptr);
      p_Var3 = parsedURL2Str(&CurrentTab->currentBuffer->currentURL);
      referer = p_Var3->ptr;
      pPVar2 = baseURL(CurrentTab->currentBuffer);
      cmd_loadURL(pLVar1->url,pPVar2,referer,(FormList *)0x0);
    }
  }
  return;
}



void anchorMn(anon_subr_Anchor_ptr_Buffer_ptr *menu_func,int go)

{
  BufferPoint *pBVar1;
  Anchor *pAVar2;
  BufferPoint *po;
  Anchor *a;
  
  if ((((CurrentTab->currentBuffer->href != (AnchorList *)0x0) &&
       (CurrentTab->currentBuffer->hmarklist != (HmarkerList *)0x0)) &&
      (pAVar2 = (*menu_func)(CurrentTab->currentBuffer), pAVar2 != (Anchor *)0x0)) &&
     (-1 < pAVar2->hseq)) {
    pBVar1 = CurrentTab->currentBuffer->hmarklist->marks + pAVar2->hseq;
    gotoLine(CurrentTab->currentBuffer,pBVar1->line);
    CurrentTab->currentBuffer->pos = pBVar1->pos;
    arrangeCursor(CurrentTab->currentBuffer);
    displayBuffer(CurrentTab->currentBuffer,0);
    if (go != 0) {
      followA();
    }
  }
  return;
}



void accessKey(void)

{
  anchorMn(accesskey_menu,1);
  return;
}



void listMn(void)

{
  anchorMn(list_menu,1);
  return;
}



void movlistMn(void)

{
  anchorMn(list_menu,0);
  return;
}



void linkLst(void)

{
  Buffer *buf_00;
  Buffer *buf;
  
  buf_00 = link_list_panel(CurrentTab->currentBuffer);
  if (buf_00 != (Buffer *)0x0) {
    buf_00->document_charset = CurrentTab->currentBuffer->document_charset;
    cmd_loadBuffer(buf_00,0,-1);
  }
  return;
}



void cooLst(void)

{
  Buffer *buf_00;
  Buffer *buf;
  
  buf_00 = cookie_list_panel();
  if (buf_00 != (Buffer *)0x0) {
    cmd_loadBuffer(buf_00,0x10,-1);
  }
  return;
}



void ldHist(void)

{
  Buffer *buf;
  
  buf = historyBuffer(URLHist);
  cmd_loadBuffer(buf,0x10,-1);
  return;
}



void svA(void)

{
  CurrentKeyData = (char *)0x0;
  do_download = 1;
  followA();
  do_download = 0;
  return;
}



void svI(void)

{
  CurrentKeyData = (char *)0x0;
  do_download = 1;
  followI();
  do_download = 0;
  return;
}



void svBuf(void)

{
  bool bVar1;
  wc_ces wVar2;
  wc_ces wVar3;
  char *p;
  Str p_Var4;
  int iVar5;
  char *emsg;
  int is_pipe;
  FILE *f;
  char *file;
  char *qfile;
  
  qfile = (char *)0x0;
  CurrentKeyData = (char *)0x0;
  p = searchKeyData();
  if (((p == (char *)0x0) || (*p == '\0')) &&
     ((qfile = inputLineHistSearch("Save buffer to: ",(char *)0x0,0x80,SaveHist,
                                   (anon_subr_int_int_Str_Lineprop_ptr *)0x0), qfile == (char *)0x0
      || (*qfile == '\0')))) {
    displayBuffer(CurrentTab->currentBuffer,0);
  }
  else {
    wVar3 = SystemCharset;
    wVar2 = InnerCharset;
    if (qfile != (char *)0x0) {
      p = qfile;
    }
    p_Var4 = Strnew_charp(p);
    p_Var4 = wc_Str_conv_strict(p_Var4,wVar2,wVar3);
    file = p_Var4->ptr;
    if (*file == '|') {
      bVar1 = true;
      f = (FILE *)popen(file + 1,"w");
    }
    else {
      if (qfile != (char *)0x0) {
        p_Var4 = Strnew_charp(qfile);
        p_Var4 = unescape_spaces(p_Var4);
        wVar3 = SystemCharset;
        wVar2 = InnerCharset;
        p_Var4 = Strnew_charp(p_Var4->ptr);
        p_Var4 = wc_Str_conv_strict(p_Var4,wVar2,wVar3);
        file = p_Var4->ptr;
      }
      file = expandPath(file);
      iVar5 = checkOverWrite(file);
      if (iVar5 < 0) {
        displayBuffer(CurrentTab->currentBuffer,0);
        return;
      }
      f = (FILE *)fopen(file,"w");
      bVar1 = false;
    }
    wVar3 = SystemCharset;
    wVar2 = InnerCharset;
    if (f == (FILE *)0x0) {
      p_Var4 = Strnew_charp(file);
      p_Var4 = wc_Str_conv(p_Var4,wVar3,wVar2);
      p_Var4 = Sprintf("Can\'t open %s",p_Var4->ptr);
      disp_err_message(p_Var4->ptr,1);
    }
    else {
      saveBuffer(CurrentTab->currentBuffer,f,1);
      if (bVar1) {
        pclose((FILE *)f);
      }
      else {
        fclose((FILE *)f);
      }
      displayBuffer(CurrentTab->currentBuffer,0);
    }
  }
  return;
}



void svSrc(void)

{
  wc_ces t_ces;
  wc_ces f_ces;
  char *p;
  Str p_Var1;
  char *file;
  
  f_ces = SystemCharset;
  t_ces = InnerCharset;
  if (CurrentTab->currentBuffer->sourcefile != (char *)0x0) {
    CurrentKeyData = (char *)0x0;
    PermitSaveToPipe = '\x01';
    if (CurrentTab->currentBuffer->real_scheme == 4) {
      p = guess_save_name((Buffer *)0x0,(CurrentTab->currentBuffer->currentURL).real_file);
      p_Var1 = Strnew_charp(p);
      p_Var1 = wc_Str_conv(p_Var1,f_ces,t_ces);
      file = p_Var1->ptr;
    }
    else {
      file = guess_save_name(CurrentTab->currentBuffer,(CurrentTab->currentBuffer->currentURL).file)
      ;
    }
    _doFileCopy(CurrentTab->currentBuffer->sourcefile,file,0);
    PermitSaveToPipe = '\0';
    displayBuffer(CurrentTab->currentBuffer,0);
  }
  return;
}



void _peekURL(int only_img)

{
  ParsedURL *current;
  char *pcVar1;
  ParsedURL pu;
  Lineprop *pp;
  Anchor *a;
  
  if (CurrentTab->currentBuffer->firstLine != (Line *)0x0) {
    if ((CurrentKey == prev_key) && (_peekURL::s != (Str)0x0)) {
      if (_peekURL::s->length - _peekURL::offset < COLS) {
        if (_peekURL::s->length <= _peekURL::offset) {
          _peekURL::offset = 0;
        }
      }
      else {
        _peekURL::offset = _peekURL::offset + 1;
      }
    }
    else {
      _peekURL::offset = 0;
      _peekURL::s = (Str)0x0;
      if (only_img == 0) {
        a = retrieveCurrentAnchor(CurrentTab->currentBuffer);
      }
      else {
        a = (Anchor *)0x0;
      }
      if (a == (Anchor *)0x0) {
        if (only_img == 0) {
          a = retrieveCurrentForm(CurrentTab->currentBuffer);
        }
        else {
          a = (Anchor *)0x0;
        }
        if (a == (Anchor *)0x0) {
          a = retrieveCurrentImg(CurrentTab->currentBuffer);
          if (a == (Anchor *)0x0) {
            return;
          }
        }
        else {
          pcVar1 = form2str((FormItemList *)a->url);
          _peekURL::s = Strnew_charp(pcVar1);
        }
      }
      if (_peekURL::s == (Str)0x0) {
        current = baseURL(CurrentTab->currentBuffer);
        parseURL2(a->url,&pu,current);
        _peekURL::s = parsedURL2Str(&pu);
      }
      if (DecodeURL != 0) {
        pcVar1 = url_unquote_conv(_peekURL::s->ptr,CurrentTab->currentBuffer->document_charset);
        _peekURL::s = Strnew_charp(pcVar1);
      }
      _peekURL::s = checkType(_peekURL::s,&pp,(Linecolor **)0x0);
      _peekURL::p = (Lineprop *)GC_malloc_atomic(_peekURL::s->length * 2);
      bcopy(pp,_peekURL::p,_peekURL::s->length * 2);
    }
    _peekURL::n = searchKeyNum();
    if ((1 < _peekURL::n) && ((COLS + -1) * (_peekURL::n + -1) < _peekURL::s->length)) {
      _peekURL::offset = (COLS + -1) * (_peekURL::n + -1);
    }
    for (; (_peekURL::offset < _peekURL::s->length && ((_peekURL::p[_peekURL::offset] & 0x400) != 0)
           ); _peekURL::offset = _peekURL::offset + 1) {
    }
    disp_message_nomouse(_peekURL::s->ptr + _peekURL::offset,1);
  }
  return;
}



void peekURL(void)

{
  _peekURL(0);
  return;
}



void peekIMG(void)

{
  _peekURL(1);
  return;
}



Str currentURL(void)

{
  Str p_Var1;
  
  if ((CurrentTab->currentBuffer->bufferprop & 8U) == 0) {
    p_Var1 = parsedURL2Str(&CurrentTab->currentBuffer->currentURL);
  }
  else {
    p_Var1 = Strnew_size(0);
  }
  return p_Var1;
}



void curURL(void)

{
  char *p;
  Lineprop *pp;
  
  if ((CurrentTab->currentBuffer->bufferprop & 8U) == 0) {
    if ((CurrentKey == prev_key) && (curURL::s != (Str)0x0)) {
      if (curURL::s->length - curURL::offset < COLS) {
        if (curURL::s->length <= curURL::offset) {
          curURL::offset = 0;
        }
      }
      else {
        curURL::offset = curURL::offset + 1;
      }
    }
    else {
      curURL::offset = 0;
      curURL::s = currentURL();
      if (DecodeURL != 0) {
        p = url_unquote_conv(curURL::s->ptr,0);
        curURL::s = Strnew_charp(p);
      }
      curURL::s = checkType(curURL::s,&pp,(Linecolor **)0x0);
      curURL::p = (Lineprop *)GC_malloc_atomic(curURL::s->length * 2);
      bcopy(pp,curURL::p,curURL::s->length * 2);
    }
    curURL::n = searchKeyNum();
    if ((1 < curURL::n) && ((COLS + -1) * (curURL::n + -1) < curURL::s->length)) {
      curURL::offset = (COLS + -1) * (curURL::n + -1);
    }
    for (; (curURL::offset < curURL::s->length && ((curURL::p[curURL::offset] & 0x400) != 0));
        curURL::offset = curURL::offset + 1) {
    }
    disp_message_nomouse(curURL::s->ptr + curURL::offset,1);
  }
  return;
}



void vwSrc(void)

{
  Buffer *pBVar1;
  wc_ces wVar2;
  wc_bool wVar3;
  int iVar4;
  Str p_Var5;
  FILE *__stream;
  Buffer *buf_00;
  Str tmpf;
  FILE *f;
  wc_ces old_charset;
  Buffer *buf;
  wc_bool old_fix_width_conv;
  
  if ((CurrentTab->currentBuffer->type != (char *)0x0) &&
     ((CurrentTab->currentBuffer->bufferprop & 2U) == 0)) {
    buf = CurrentTab->currentBuffer->linkBuffer[4];
    if ((buf == (_Buffer *)0x0) &&
       (buf = CurrentTab->currentBuffer->linkBuffer[4], buf == (_Buffer *)0x0)) {
      if (CurrentTab->currentBuffer->sourcefile == (char *)0x0) {
        if (CurrentTab->currentBuffer->pagerSource == (InputStream)0x0) {
          return;
        }
        iVar4 = strcasecmp(CurrentTab->currentBuffer->type,"text/plain");
        if (iVar4 != 0) {
          return;
        }
        p_Var5 = tmpfname(1,(char *)0x0);
        __stream = fopen(p_Var5->ptr,"w");
        wVar3 = WcOption.fix_width_conv;
        wVar2 = DisplayCharset;
        if (__stream == (FILE *)0x0) {
          return;
        }
        if (CurrentTab->currentBuffer->document_charset == 0x100) {
          DisplayCharset = 0;
        }
        else {
          DisplayCharset = CurrentTab->currentBuffer->document_charset;
        }
        WcOption.fix_width_conv = '\0';
        saveBufferBody(CurrentTab->currentBuffer,(FILE *)__stream,1);
        DisplayCharset = wVar2;
        WcOption.fix_width_conv = wVar3;
        fclose(__stream);
        CurrentTab->currentBuffer->sourcefile = p_Var5->ptr;
      }
      if (showLineNum == 0) {
        iVar4 = 1;
      }
      else {
        iVar4 = 6;
      }
      iVar4 = COLS - iVar4;
      if (iVar4 < 0) {
        iVar4 = 0;
      }
      buf_00 = newBuffer(iVar4);
      iVar4 = is_html_type(CurrentTab->currentBuffer->type);
      if (iVar4 == 0) {
        iVar4 = strcasecmp(CurrentTab->currentBuffer->type,"text/plain");
        if (iVar4 != 0) {
          return;
        }
        buf_00->type = "text/html";
        if ((CurrentTab->currentBuffer->real_type == (char *)0x0) ||
           (iVar4 = strcasecmp(CurrentTab->currentBuffer->real_type,"text/plain"), iVar4 != 0)) {
          buf_00->real_type = CurrentTab->currentBuffer->real_type;
        }
        else {
          buf_00->real_type = "text/html";
        }
        p_Var5 = Sprintf("HTML view of %s",CurrentTab->currentBuffer->buffername);
        buf_00->buffername = p_Var5->ptr;
        buf_00->linkBuffer[4] = CurrentTab->currentBuffer;
        CurrentTab->currentBuffer->linkBuffer[4] = buf_00;
      }
      else {
        buf_00->type = "text/plain";
        if ((CurrentTab->currentBuffer->real_type == (char *)0x0) ||
           (iVar4 = is_html_type(CurrentTab->currentBuffer->real_type), iVar4 == 0)) {
          buf_00->real_type = CurrentTab->currentBuffer->real_type;
        }
        else {
          buf_00->real_type = "text/plain";
        }
        p_Var5 = Sprintf("source of %s",CurrentTab->currentBuffer->buffername);
        buf_00->buffername = p_Var5->ptr;
        buf_00->linkBuffer[4] = CurrentTab->currentBuffer;
        CurrentTab->currentBuffer->linkBuffer[4] = buf_00;
      }
      pBVar1 = CurrentTab->currentBuffer;
      (buf_00->currentURL).scheme = (pBVar1->currentURL).scheme;
      (buf_00->currentURL).user = (pBVar1->currentURL).user;
      (buf_00->currentURL).pass = (pBVar1->currentURL).pass;
      (buf_00->currentURL).host = (pBVar1->currentURL).host;
      (buf_00->currentURL).port = (pBVar1->currentURL).port;
      (buf_00->currentURL).file = (pBVar1->currentURL).file;
      (buf_00->currentURL).real_file = (pBVar1->currentURL).real_file;
      (buf_00->currentURL).query = (pBVar1->currentURL).query;
      (buf_00->currentURL).label = (pBVar1->currentURL).label;
      (buf_00->currentURL).is_nocache = (pBVar1->currentURL).is_nocache;
      buf_00->real_scheme = CurrentTab->currentBuffer->real_scheme;
      buf_00->filename = CurrentTab->currentBuffer->filename;
      buf_00->sourcefile = CurrentTab->currentBuffer->sourcefile;
      buf_00->header_source = CurrentTab->currentBuffer->header_source;
      buf_00->search_header = CurrentTab->currentBuffer->search_header;
      buf_00->document_charset = CurrentTab->currentBuffer->document_charset;
      buf_00->clone = CurrentTab->currentBuffer->clone;
      *buf_00->clone = *buf_00->clone + 1;
      buf_00->need_reshape = '\x01';
      reshapeBuffer(buf_00);
      pushBuffer(buf_00);
      displayBuffer(CurrentTab->currentBuffer,0);
    }
    else {
      CurrentTab->currentBuffer = buf;
      displayBuffer(CurrentTab->currentBuffer,0);
    }
  }
  return;
}



void reload(void)

{
  TabBuffer *pTVar1;
  int iVar2;
  Buffer *pBVar3;
  Buffer sbuf;
  stat st;
  Str query;
  int multipart;
  FormList *request;
  Str url;
  wc_ces old_charset;
  Buffer *fbuf;
  Buffer *buf;
  
  fbuf = (Buffer *)0x0;
  if ((CurrentTab->currentBuffer->bufferprop & 8U) != 0) {
    iVar2 = strcmp(CurrentTab->currentBuffer->buffername,"Download List Panel");
    if (iVar2 == 0) {
      ldDL();
      return;
    }
    disp_err_message("Can\'t reload...",1);
    return;
  }
  if (((CurrentTab->currentBuffer->currentURL).scheme == 4) &&
     (iVar2 = strcmp((CurrentTab->currentBuffer->currentURL).file,"-"), iVar2 == 0)) {
    disp_err_message("Can\'t reload stdin",1);
    return;
  }
  copyBuffer(&sbuf,CurrentTab->currentBuffer);
  if (((CurrentTab->currentBuffer->bufferprop & 2U) != 0) &&
     (fbuf = CurrentTab->currentBuffer->linkBuffer[1], fbuf != (_Buffer *)0x0)) {
    if (fmInitialized != '\0') {
      message("Rendering frame",0,0);
      refresh();
    }
    buf = renderFrame(fbuf,1);
    if (buf == (Buffer *)0x0) {
      displayBuffer(CurrentTab->currentBuffer,0);
      return;
    }
    if (fbuf->linkBuffer[0] != (_Buffer *)0x0) {
      if (((buf->sourcefile != (char *)0x0) && (fbuf->linkBuffer[0]->sourcefile != (char *)0x0)) &&
         (iVar2 = strcmp(buf->sourcefile,fbuf->linkBuffer[0]->sourcefile), iVar2 == 0)) {
        fbuf->linkBuffer[0]->sourcefile = (char *)0x0;
      }
      delBuffer(fbuf->linkBuffer[0]);
    }
    fbuf->linkBuffer[0] = buf;
    buf->linkBuffer[1] = fbuf;
    pushBuffer(buf);
    CurrentTab->currentBuffer = buf;
    if (CurrentTab->currentBuffer->firstLine != (Line *)0x0) {
      CurrentTab->currentBuffer->rootX = sbuf.rootX;
      CurrentTab->currentBuffer->rootY = sbuf.rootY;
      CurrentTab->currentBuffer->COLS = sbuf.COLS;
      CurrentTab->currentBuffer->LINES = sbuf.LINES;
      restorePosition(CurrentTab->currentBuffer,&sbuf);
    }
    displayBuffer(CurrentTab->currentBuffer,1);
    return;
  }
  if (CurrentTab->currentBuffer->frameset != (frameset *)0x0) {
    fbuf = CurrentTab->currentBuffer->linkBuffer[0];
  }
  multipart = 0;
  if (CurrentTab->currentBuffer->form_submit == (FormItemList *)0x0) {
    request = (FormList *)0x0;
  }
  else {
    request = CurrentTab->currentBuffer->form_submit->parent;
    if ((request->method == 1) && (request->enctype == 1)) {
      multipart = 1;
      query_from_followform(&query,CurrentTab->currentBuffer->form_submit,1);
      stat(request->body,(stat *)&st);
      request->length = st.st_size;
    }
  }
  url = parsedURL2Str(&CurrentTab->currentBuffer->currentURL);
  message("Reloading...",0,0);
  refresh();
  old_charset = DocumentCharset;
  if (CurrentTab->currentBuffer->document_charset != 0x100) {
    DocumentCharset = CurrentTab->currentBuffer->document_charset;
  }
  SearchHeader = CurrentTab->currentBuffer->search_header;
  DefaultType = CurrentTab->currentBuffer->real_type;
  buf = loadGeneralFile(url->ptr,(ParsedURL *)0x0,(char *)0xffffffff,1,request);
  DocumentCharset = old_charset;
  SearchHeader = '\0';
  DefaultType = (char *)0x0;
  if (multipart != 0) {
    unlink(request->body);
  }
  pTVar1 = CurrentTab;
  if (buf != (Buffer *)0x0) {
    if (buf != (Buffer *)0x1) {
      if (fbuf != (Buffer *)0x0) {
        pBVar3 = deleteBuffer(CurrentTab->firstBuffer,fbuf);
        pTVar1->firstBuffer = pBVar3;
      }
      repBuffer(CurrentTab->currentBuffer,buf);
      if ((((buf->type != (char *)0x0) && (sbuf.type != (char *)0x0)) &&
          (((iVar2 = strcasecmp(buf->type,"text/plain"), iVar2 == 0 &&
            (iVar2 = is_html_type(sbuf.type), iVar2 != 0)) ||
           ((iVar2 = is_html_type(buf->type), iVar2 != 0 &&
            (iVar2 = strcasecmp(sbuf.type,"text/plain"), iVar2 == 0)))))) &&
         (vwSrc(), pTVar1 = CurrentTab, CurrentTab->currentBuffer != buf)) {
        pBVar3 = deleteBuffer(CurrentTab->firstBuffer,buf);
        pTVar1->firstBuffer = pBVar3;
      }
      CurrentTab->currentBuffer->search_header = sbuf.search_header;
      CurrentTab->currentBuffer->form_submit = sbuf.form_submit;
      if (CurrentTab->currentBuffer->firstLine != (Line *)0x0) {
        CurrentTab->currentBuffer->rootX = sbuf.rootX;
        CurrentTab->currentBuffer->rootY = sbuf.rootY;
        CurrentTab->currentBuffer->COLS = sbuf.COLS;
        CurrentTab->currentBuffer->LINES = sbuf.LINES;
        restorePosition(CurrentTab->currentBuffer,&sbuf);
      }
      displayBuffer(CurrentTab->currentBuffer,1);
      return;
    }
    displayBuffer(CurrentTab->currentBuffer,0);
    return;
  }
  disp_err_message("Can\'t reload...",1);
  return;
}



void reshape(void)

{
  CurrentTab->currentBuffer->need_reshape = '\x01';
  reshapeBuffer(CurrentTab->currentBuffer);
  displayBuffer(CurrentTab->currentBuffer,1);
  return;
}



void _docCSet(wc_ces charset)

{
  if ((CurrentTab->currentBuffer->bufferprop & 8U) == 0) {
    if (CurrentTab->currentBuffer->sourcefile == (char *)0x0) {
      disp_message("Can\'t reload...",0);
    }
    else {
      CurrentTab->currentBuffer->document_charset = charset;
      CurrentTab->currentBuffer->need_reshape = '\x01';
      displayBuffer(CurrentTab->currentBuffer,1);
    }
  }
  return;
}



void change_charset(parsed_tagarg *arg)

{
  _Buffer *p_Var1;
  int iVar2;
  wc_ces charset;
  Buffer *buf;
  
  p_Var1 = CurrentTab->currentBuffer->linkBuffer[3];
  if (p_Var1 != (_Buffer *)0x0) {
    delBuffer(CurrentTab->currentBuffer);
    CurrentTab->currentBuffer = p_Var1;
    if ((CurrentTab->currentBuffer->bufferprop & 8U) == 0) {
      charset = CurrentTab->currentBuffer->document_charset;
      for (; arg != (parsed_tagarg *)0x0; arg = arg->next) {
        iVar2 = strcmp(arg->arg,"charset");
        if (iVar2 == 0) {
          charset = atoi(arg->value);
        }
      }
      _docCSet(charset);
    }
  }
  return;
}



void docCSet(void)

{
  char *def_str;
  wc_ces charset_00;
  wc_ces charset;
  char *cs;
  
  cs = searchKeyData();
  if ((cs == (char *)0x0) || (*cs == '\0')) {
    def_str = wc_ces_to_charset(CurrentTab->currentBuffer->document_charset);
    cs = inputLineHistSearch("Document charset: ",def_str,0x10,(Hist *)0x0,
                             (anon_subr_int_int_Str_Lineprop_ptr *)0x0);
  }
  charset_00 = wc_guess_charset_short(cs,0);
  if (charset_00 == 0) {
    displayBuffer(CurrentTab->currentBuffer,0);
  }
  else {
    _docCSet(charset_00);
  }
  return;
}



void defCSet(void)

{
  char *def_str;
  wc_ces wVar1;
  wc_ces charset;
  char *cs;
  
  cs = searchKeyData();
  if ((cs == (char *)0x0) || (*cs == '\0')) {
    def_str = wc_ces_to_charset(DocumentCharset);
    cs = inputLineHistSearch("Default document charset: ",def_str,0x10,(Hist *)0x0,
                             (anon_subr_int_int_Str_Lineprop_ptr *)0x0);
  }
  wVar1 = wc_guess_charset_short(cs,0);
  if (wVar1 != 0) {
    DocumentCharset = wVar1;
  }
  displayBuffer(CurrentTab->currentBuffer,0);
  return;
}



void chkURLBuffer(Buffer *buf)

{
  int i;
  
  for (i = 0; chkURLBuffer::url_like_pat[i] != (char *)0x0; i = i + 1) {
    reAnchor(buf,chkURLBuffer::url_like_pat[i]);
  }
  chkExternalURIBuffer(buf);
  buf->check_url = buf->check_url | 1;
  return;
}



void chkURL(void)

{
  chkURLBuffer(CurrentTab->currentBuffer);
  displayBuffer(CurrentTab->currentBuffer,1);
  return;
}



void chkWORD(void)

{
  int epos;
  int spos;
  char *p;
  
  p = getCurWord(CurrentTab->currentBuffer,&spos,&epos,":\"\'`<>()[]{}&|;*?$");
  if (p != (char *)0x0) {
    reAnchorWord(CurrentTab->currentBuffer,CurrentTab->currentBuffer->currentLine,spos,epos);
    displayBuffer(CurrentTab->currentBuffer,1);
  }
  return;
}



void chkNMIDBuffer(Buffer *buf)

{
  int i;
  
  for (i = 0; chkNMIDBuffer::url_like_pat[i] != (char *)0x0; i = i + 1) {
    reAnchorNews(buf,chkNMIDBuffer::url_like_pat[i]);
  }
  buf->check_url = buf->check_url | 2;
  return;
}



void chkNMID(void)

{
  chkNMIDBuffer(CurrentTab->currentBuffer);
  displayBuffer(CurrentTab->currentBuffer,1);
  return;
}



void rFrame(void)

{
  _Buffer *p_Var1;
  Buffer *buf_00;
  Buffer *buf;
  
  p_Var1 = CurrentTab->currentBuffer->linkBuffer[0];
  if (p_Var1 == (_Buffer *)0x0) {
    if (CurrentTab->currentBuffer->frameset == (frameset *)0x0) {
      p_Var1 = CurrentTab->currentBuffer->linkBuffer[1];
      if (p_Var1 != (_Buffer *)0x0) {
        CurrentTab->currentBuffer = p_Var1;
        displayBuffer(CurrentTab->currentBuffer,0);
      }
    }
    else {
      if (fmInitialized != '\0') {
        message("Rendering frame",0,0);
        refresh();
      }
      buf_00 = renderFrame(CurrentTab->currentBuffer,0);
      if (buf_00 == (Buffer *)0x0) {
        displayBuffer(CurrentTab->currentBuffer,0);
      }
      else {
        buf_00->linkBuffer[1] = CurrentTab->currentBuffer;
        CurrentTab->currentBuffer->linkBuffer[0] = buf_00;
        pushBuffer(buf_00);
        if ((fmInitialized != '\0') && (display_ok != 0)) {
          displayBuffer(CurrentTab->currentBuffer,1);
        }
      }
    }
  }
  else {
    CurrentTab->currentBuffer = p_Var1;
    displayBuffer(CurrentTab->currentBuffer,0);
  }
  return;
}



void invoke_browser(char *url)

{
  wc_ces wVar1;
  wc_ces wVar2;
  Str p_Var3;
  size_t sVar4;
  char *arg;
  int len;
  int bg;
  char *browser;
  Str cmd;
  
  bg = 0;
  CurrentKeyData = (char *)0x0;
  browser = searchKeyData();
  wVar2 = SystemCharset;
  wVar1 = InnerCharset;
  if ((browser == (char *)0x0) || (*browser == '\0')) {
    if (prec_num == 2) {
      browser = ExtBrowser2;
    }
    else if (prec_num < 3) {
      if (-1 < prec_num) {
        browser = ExtBrowser;
      }
    }
    else if (prec_num == 3) {
      browser = ExtBrowser3;
    }
    if (((browser == (char *)0x0) || (*browser == '\0')) &&
       (browser = inputLineHistSearch("Browse command: ",(char *)0x0,0x10,(Hist *)0x0,
                                      (anon_subr_int_int_Str_Lineprop_ptr *)0x0),
       wVar2 = SystemCharset, wVar1 = InnerCharset, browser != (char *)0x0)) {
      p_Var3 = Strnew_charp(browser);
      p_Var3 = wc_Str_conv_strict(p_Var3,wVar1,wVar2);
      browser = p_Var3->ptr;
    }
  }
  else {
    p_Var3 = Strnew_charp(browser);
    p_Var3 = wc_Str_conv_strict(p_Var3,wVar1,wVar2);
    browser = p_Var3->ptr;
  }
  if ((browser == (char *)0x0) || (*browser == '\0')) {
    displayBuffer(CurrentTab->currentBuffer,0);
  }
  else {
    sVar4 = strlen(browser);
    if (((1 < (int)sVar4) && (browser[sVar4 - 1] == '&')) && (browser[sVar4 - 2] != '\\')) {
      browser = allocStr(browser,sVar4 - 2);
      bg = 1;
    }
    arg = shell_quote(url);
    p_Var3 = myExtCommand(browser,arg,0);
    Strremovetrailingspaces(p_Var3);
    fmTerm();
    mySystem(p_Var3->ptr,bg);
    fmInit();
    displayBuffer(CurrentTab->currentBuffer,1);
  }
  return;
}



void extbrz(void)

{
  int iVar1;
  Str p_Var2;
  
  if ((CurrentTab->currentBuffer->bufferprop & 8U) == 0) {
    if (((CurrentTab->currentBuffer->currentURL).scheme == 4) &&
       (iVar1 = strcmp((CurrentTab->currentBuffer->currentURL).file,"-"), iVar1 == 0)) {
      disp_err_message("Can\'t browse stdin",1);
      return;
    }
    p_Var2 = parsedURL2Str(&CurrentTab->currentBuffer->currentURL);
    invoke_browser(p_Var2->ptr);
  }
  else {
    disp_err_message("Can\'t browse...",1);
  }
  return;
}



void linkbrz(void)

{
  Anchor *pAVar1;
  ParsedURL *current;
  Str p_Var2;
  ParsedURL pu;
  Anchor *a;
  
  if ((CurrentTab->currentBuffer->firstLine != (Line *)0x0) &&
     (pAVar1 = retrieveCurrentAnchor(CurrentTab->currentBuffer), pAVar1 != (Anchor *)0x0)) {
    current = baseURL(CurrentTab->currentBuffer);
    parseURL2(pAVar1->url,&pu,current);
    p_Var2 = parsedURL2Str(&pu);
    invoke_browser(p_Var2->ptr);
  }
  return;
}



void curlno(void)

{
  double dVar1;
  int iVar2;
  char *y;
  int len;
  int col;
  int all;
  int cur;
  Str tmp;
  Line *l;
  
  l = CurrentTab->currentBuffer->currentLine;
  cur = 0;
  all = 0;
  col = 0;
  len = 0;
  if (l != (Line *)0x0) {
    cur = l->real_linenumber;
    col = l->bwidth + CurrentTab->currentBuffer->currentColumn +
          (int)CurrentTab->currentBuffer->cursorX + 1;
    while ((l->next != (_Line *)0x0 && (l->next->bpos != 0))) {
      l = l->next;
    }
    if (l->width < 0) {
      iVar2 = calcPosition(l->lineBuf,l->propBuf,l->len,l->len,0,0);
      l->width = iVar2;
    }
    len = l->bwidth + l->width;
  }
  if (CurrentTab->currentBuffer->lastLine != (Line *)0x0) {
    all = CurrentTab->currentBuffer->lastLine->real_linenumber;
  }
  if ((CurrentTab->currentBuffer->pagerSource == (InputStream)0x0) ||
     ((CurrentTab->currentBuffer->bufferprop & 0x40U) != 0)) {
    if (all == 0) {
      dVar1 = 1.0;
    }
    else {
      dVar1 = (double)all;
    }
    tmp = Sprintf("line %d/%d (%d%%) col %d/%d",cur,all,
                  (int)ROUND(((double)cur * 100.0) / dVar1 + 0.5),col,len);
  }
  else {
    tmp = Sprintf("line %d col %d/%d",cur,col,len);
  }
  Strcat_charp(tmp,"  ");
  y = wc_ces_to_charset_desc(CurrentTab->currentBuffer->document_charset);
  Strcat_charp(tmp,y);
  disp_message(tmp->ptr,0);
  return;
}



void dispI(void)

{
  if (displayImage == 0) {
    initImage();
  }
  if (activeImage != 0) {
    displayImage = 1;
    CurrentTab->currentBuffer->image_flag = '\x02';
    CurrentTab->currentBuffer->need_reshape = '\x01';
    displayBuffer(CurrentTab->currentBuffer,4);
  }
  return;
}



void stopI(void)

{
  if (activeImage != 0) {
    CurrentTab->currentBuffer->image_flag = '\x01';
    displayBuffer(CurrentTab->currentBuffer,4);
  }
  return;
}



int mouse_scroll_line(void)

{
  int iVar1;
  
  iVar1 = fixed_wheel_scroll_count;
  if (relative_wheel_scroll != 0) {
    iVar1 = (relative_wheel_scroll_ratio * (LINES + -1) + 99) / 100;
  }
  return iVar1;
}



TabBuffer * posTab(int x,int y)

{
  TabBuffer *pTVar1;
  TabBuffer *tab;
  
  if (((mouse_action.menu_str == (char *)0x0) || (mouse_action.menu_width <= x)) || (y != 0)) {
    if (LastTab->y < y) {
      pTVar1 = (TabBuffer *)0x0;
    }
    else {
      for (tab = FirstTab; tab != (TabBuffer *)0x0; tab = tab->nextTab) {
        if (((tab->x1 <= x) && (x <= tab->x2)) && (tab->y == y)) {
          return tab;
        }
      }
      pTVar1 = (TabBuffer *)0x0;
    }
  }
  else {
    pTVar1 = (TabBuffer *)0x1;
  }
  return pTVar1;
}



void do_mouse_action(int btn,int x,int y)

{
  short sVar1;
  short sVar2;
  Anchor *pAVar3;
  int cy;
  int cx;
  int ny;
  MouseActionMap *map;
  
  map = (MouseActionMap *)0x0;
  ny = -1;
  if ((1 < nTab) || (mouse_action.menu_str != (char *)0x0)) {
    ny = LastTab->y + 1;
  }
  if (btn == 1) {
    btn = 1;
  }
  else if (btn == 2) {
    btn = 2;
  }
  else {
    if (btn != 0) {
      return;
    }
    btn = 0;
  }
  if (y < ny) {
    if (((mouse_action.menu_str == (char *)0x0) || (x < 0)) || (mouse_action.menu_width <= x)) {
      map = mouse_action.tab_map + btn;
    }
    else if (mouse_action.menu_map[btn] != (MouseActionMap *)0x0) {
      map = mouse_action.menu_map[btn] + x;
    }
  }
  else if (LINES + -1 == y) {
    if ((((mouse_action.lastline_str != (char *)0x0) && (-1 < x)) &&
        (x < mouse_action.lastline_width)) &&
       (mouse_action.lastline_map[btn] != (MouseActionMap *)0x0)) {
      map = mouse_action.lastline_map[btn] + x;
    }
  }
  else {
    if (y <= ny) {
      return;
    }
    if (((int)CurrentTab->currentBuffer->cursorY + (int)CurrentTab->currentBuffer->rootY == y) &&
       (((int)CurrentTab->currentBuffer->cursorX + (int)CurrentTab->currentBuffer->rootX == x ||
        ((((WcOption.use_wide != '\0' && (CurrentTab->currentBuffer->currentLine != (Line *)0x0)) &&
          ((CurrentTab->currentBuffer->currentLine->propBuf[CurrentTab->currentBuffer->pos] & 0x3f00
           ) == 0xa00)) &&
         ((int)CurrentTab->currentBuffer->cursorX + (int)CurrentTab->currentBuffer->rootX + 1 == x))
        )))) {
      pAVar3 = retrieveCurrentAnchor(CurrentTab->currentBuffer);
      if (((pAVar3 != (Anchor *)0x0) ||
          (pAVar3 = retrieveCurrentForm(CurrentTab->currentBuffer), pAVar3 != (Anchor *)0x0)) &&
         ((map = mouse_action.active_map + btn, map == (MouseActionMap *)0x0 ||
          (map->func == (anon_subr_void_varargs_for_func *)0x0)))) {
        map = mouse_action.anchor_map + btn;
      }
    }
    else {
      sVar1 = CurrentTab->currentBuffer->cursorX;
      sVar2 = CurrentTab->currentBuffer->cursorY;
      cursorXY(CurrentTab->currentBuffer,x - CurrentTab->currentBuffer->rootX,
               y - CurrentTab->currentBuffer->rootY);
      if (((int)CurrentTab->currentBuffer->cursorY + (int)CurrentTab->currentBuffer->rootY == y) &&
         ((((int)CurrentTab->currentBuffer->cursorX + (int)CurrentTab->currentBuffer->rootX == x ||
           (((WcOption.use_wide != '\0' && (CurrentTab->currentBuffer->currentLine != (Line *)0x0))
            && (((CurrentTab->currentBuffer->currentLine->propBuf[CurrentTab->currentBuffer->pos] &
                 0x3f00) == 0xa00 &&
                ((int)CurrentTab->currentBuffer->cursorX + (int)CurrentTab->currentBuffer->rootX + 1
                 == x)))))) &&
          ((pAVar3 = retrieveCurrentAnchor(CurrentTab->currentBuffer), pAVar3 != (Anchor *)0x0 ||
           (pAVar3 = retrieveCurrentForm(CurrentTab->currentBuffer), pAVar3 != (Anchor *)0x0)))))) {
        map = mouse_action.anchor_map + btn;
      }
      cursorXY(CurrentTab->currentBuffer,(int)sVar1,(int)sVar2);
    }
  }
  if ((map == (MouseActionMap *)0x0) || (map->func == (anon_subr_void_varargs_for_func *)0x0)) {
    map = mouse_action.default_map + btn;
  }
  if ((map != (MouseActionMap *)0x0) && (map->func != (anon_subr_void_varargs_for_func *)0x0)) {
    mouse_action.in_action = 1;
    mouse_action.cursorX = x;
    mouse_action.cursorY = y;
    CurrentKey = -1;
    CurrentKeyData = (char *)0x0;
    CurrentCmdData = map->data;
    (*map->func)();
    CurrentCmdData = (char *)0x0;
  }
  return;
}



void process_mouse(int btn,int x,int y)

{
  short sVar1;
  short sVar2;
  Buffer *pBVar3;
  bool bVar4;
  TabBuffer *t2;
  TabBuffer *t_00;
  uint uVar5;
  int iVar6;
  int cy;
  int cx;
  Buffer *buf;
  int ny;
  TabBuffer *t;
  int i;
  int delta_y;
  int delta_x;
  
  ny = -1;
  if ((1 < nTab) || (mouse_action.menu_str != (char *)0x0)) {
    ny = LastTab->y + 1;
  }
  if (btn == 3) {
    switch(process_mouse::press_btn) {
    case 0:
      if ((process_mouse::press_y == y) && (process_mouse::press_x == x)) {
        do_mouse_action(process_mouse::press_btn,x,y);
      }
      else {
        if ((0 < ny) && (y < ny)) {
          if (process_mouse::press_y < ny) {
            if (process_mouse::press_y == y) {
              bVar4 = process_mouse::press_x < x;
            }
            else {
              bVar4 = process_mouse::press_y < y;
            }
            t2 = posTab(x,y);
            t_00 = posTab(process_mouse::press_x,process_mouse::press_y);
            moveTab(t_00,t2,(uint)bVar4);
            return;
          }
          if (process_mouse::press_x < CurrentTab->currentBuffer->rootX) {
            return;
          }
          pBVar3 = CurrentTab->currentBuffer;
          sVar1 = CurrentTab->currentBuffer->cursorX;
          sVar2 = CurrentTab->currentBuffer->cursorY;
          t = posTab(x,y);
          if (t == (TabBuffer *)0x0) {
            return;
          }
          if (t == (TabBuffer *)0x1) {
            t = (TabBuffer *)0x0;
          }
          cursorXY(CurrentTab->currentBuffer,
                   process_mouse::press_x - CurrentTab->currentBuffer->rootX,
                   process_mouse::press_y - CurrentTab->currentBuffer->rootY);
          if (((int)CurrentTab->currentBuffer->cursorY ==
               process_mouse::press_y - CurrentTab->currentBuffer->rootY) &&
             (((int)CurrentTab->currentBuffer->cursorX ==
               process_mouse::press_x - CurrentTab->currentBuffer->rootX ||
              ((((WcOption.use_wide != '\0' &&
                 (CurrentTab->currentBuffer->currentLine != (Line *)0x0)) &&
                ((CurrentTab->currentBuffer->currentLine->propBuf[CurrentTab->currentBuffer->pos] &
                 0x3f00) == 0xa00)) &&
               ((int)CurrentTab->currentBuffer->cursorX ==
                (process_mouse::press_x - CurrentTab->currentBuffer->rootX) + -1)))))) {
            displayBuffer(CurrentTab->currentBuffer,0);
            followTab(t);
          }
          if (CurrentTab->currentBuffer != pBVar3) {
            return;
          }
          cursorXY(CurrentTab->currentBuffer,(int)sVar1,(int)sVar2);
          return;
        }
        delta_x = x - process_mouse::press_x;
        delta_y = y - process_mouse::press_y;
        uVar5 = delta_y >> 0x1f;
        if ((delta_x >> 0x1f ^ delta_x) - (delta_x >> 0x1f) < (int)((uVar5 ^ delta_y) - uVar5) / 3)
        {
          delta_x = 0;
        }
        if ((int)((uVar5 ^ delta_y) - uVar5) < ((delta_x >> 0x1f ^ delta_x) - (delta_x >> 0x1f)) / 3
           ) {
          delta_y = 0;
        }
        if (reverse_mouse != 0) {
          delta_y = -delta_y;
          delta_x = -delta_x;
        }
        if (delta_y < 1) {
          if (delta_y < 0) {
            prec_num = -delta_y;
            lup1();
          }
        }
        else {
          prec_num = delta_y;
          ldown1();
        }
        if (delta_x < 1) {
          if (delta_x < 0) {
            prec_num = -delta_x;
            col1R();
          }
        }
        else {
          prec_num = delta_x;
          col1L();
        }
      }
      break;
    case 1:
    case 2:
      if ((process_mouse::press_y == y) && (process_mouse::press_x == x)) {
        do_mouse_action(process_mouse::press_btn,x,y);
      }
      break;
    case 3:
      for (i = 0; iVar6 = mouse_scroll_line(), i < iVar6; i = i + 1) {
        ldown1();
      }
      break;
    case 4:
      for (i = 0; iVar6 = mouse_scroll_line(), i < iVar6; i = i + 1) {
        lup1();
      }
    }
  }
  else if (btn == 0x40) {
    for (i = 0; iVar6 = mouse_scroll_line(), i < iVar6; i = i + 1) {
      ldown1();
    }
  }
  else if (btn == 0x41) {
    for (i = 0; iVar6 = mouse_scroll_line(), i < iVar6; i = i + 1) {
      lup1();
    }
  }
  if ((btn == 3) && (process_mouse::press_btn != -1)) {
    process_mouse::press_btn = -1;
  }
  else {
    process_mouse::press_btn = btn;
    process_mouse::press_x = x;
    process_mouse::press_y = y;
  }
  return;
}



void msToggle(void)

{
  use_mouse = (int)(use_mouse == 0);
  displayBuffer(CurrentTab->currentBuffer,1);
  return;
}



void mouse(void)

{
  uint uVar1;
  uint uVar2;
  int y;
  int x;
  int btn;
  
  uVar1 = do_getch();
  uVar2 = do_getch();
  x = (uVar2 & 0xff) - 0x21;
  if (x < 0) {
    x = (uVar2 & 0xff) + 0xdf;
  }
  uVar2 = do_getch();
  y = (uVar2 & 0xff) - 0x21;
  if (y < 0) {
    y = (uVar2 & 0xff) + 0xdf;
  }
  if ((((-1 < x) && (x < COLS)) && (-1 < y)) && (y <= LINES + -1)) {
    process_mouse((uVar1 & 0xff) - 0x20,x,y);
  }
  return;
}



int gpm_process_mouse(Gpm_Event *event,void *data)

{
  short *psVar1;
  uchar uVar2;
  short *psVar3;
  int y;
  int x;
  int btn;
  
  psVar1 = _gpm_arg;
  btn = -1;
  if ((event->type & GPM_UP) == 0) {
    if ((event->type & GPM_DOWN) == 0) {
      _gpm_buf[1] = 2;
      psVar3 = _gpm_arg + 2;
      *psVar3 = event->x + (short)gpm_zerobased;
      *psVar1 = *psVar3;
      psVar1 = _gpm_arg + 1;
      psVar3 = _gpm_arg + 3;
      *psVar3 = event->y + (short)gpm_zerobased;
      *psVar1 = *psVar3;
      _gpm_arg[4] = 3;
      ioctl(gpm_consolefd,0x541c,0x817c201);
      return 0;
    }
    uVar2 = event->buttons;
    if (uVar2 == '\x02') {
      btn = 1;
    }
    else if (uVar2 == '\x04') {
      btn = 0;
    }
    else if (uVar2 == '\x01') {
      btn = 2;
    }
  }
  else {
    btn = 3;
  }
  process_mouse(btn,event->x + -1,event->y + -1);
  return 0;
}



void movMs(void)

{
  if ((mouse_action.in_action != 0) &&
     (((nTab < 2 && (mouse_action.menu_str == (char *)0x0)) ||
      (LastTab->y + 1 <= mouse_action.cursorY)))) {
    if ((CurrentTab->currentBuffer->rootX <= mouse_action.cursorX) &&
       (mouse_action.cursorY < LINES + -1)) {
      cursorXY(CurrentTab->currentBuffer,mouse_action.cursorX - CurrentTab->currentBuffer->rootX,
               mouse_action.cursorY - CurrentTab->currentBuffer->rootY);
    }
    displayBuffer(CurrentTab->currentBuffer,0);
  }
  return;
}



void menuMs(void)

{
  if (mouse_action.in_action != 0) {
    if (((nTab < 2) && (mouse_action.menu_str == (char *)0x0)) ||
       (LastTab->y + 1 <= mouse_action.cursorY)) {
      if ((CurrentTab->currentBuffer->rootX <= mouse_action.cursorX) &&
         (mouse_action.cursorY < LINES + -1)) {
        cursorXY(CurrentTab->currentBuffer,mouse_action.cursorX - CurrentTab->currentBuffer->rootX,
                 mouse_action.cursorY - CurrentTab->currentBuffer->rootY);
        displayBuffer(CurrentTab->currentBuffer,0);
      }
    }
    else {
      mouse_action.cursorX = mouse_action.cursorX + -2;
    }
    mainMn();
  }
  return;
}



void tabMs(void)

{
  TabBuffer *pTVar1;
  TabBuffer *tab;
  
  if (((mouse_action.in_action != 0) &&
      (pTVar1 = posTab(mouse_action.cursorX,mouse_action.cursorY), pTVar1 != (TabBuffer *)0x0)) &&
     (pTVar1 != (TabBuffer *)0x1)) {
    CurrentTab = pTVar1;
    displayBuffer(pTVar1->currentBuffer,1);
  }
  return;
}



void closeTMs(void)

{
  TabBuffer *tab_00;
  TabBuffer *tab;
  
  if (((mouse_action.in_action != 0) &&
      (tab_00 = posTab(mouse_action.cursorX,mouse_action.cursorY), tab_00 != (TabBuffer *)0x0)) &&
     (tab_00 != (TabBuffer *)0x1)) {
    deleteTab(tab_00);
    displayBuffer(CurrentTab->currentBuffer,1);
  }
  return;
}



void dispVer(void)

{
  Str p_Var1;
  
  p_Var1 = Sprintf("w3m version %s",w3m_version);
  disp_message(p_Var1->ptr,1);
  return;
}



void wrapToggle(void)

{
  if (WrapSearch == 0) {
    WrapSearch = 1;
    disp_message("Wrap search on",1);
  }
  else {
    WrapSearch = 0;
    disp_message("Wrap search off",1);
  }
  return;
}



int is_wordchar(int c,char *badchars)

{
  char *pcVar1;
  uint uVar2;
  
  if (badchars == (char *)0x0) {
    uVar2 = MYCTYPE_MAP[c & 0xff] & 4;
  }
  else if (((MYCTYPE_MAP[c & 0xff] & 2) == 0) &&
          (pcVar1 = strchr(badchars,c), pcVar1 == (char *)0x0)) {
    uVar2 = 1;
  }
  else {
    uVar2 = 0;
  }
  return uVar2;
}



char * getCurWord(Buffer *buf,int *spos,int *epos,char *badchars)

{
  Line *pLVar1;
  char *pcVar2;
  int iVar3;
  int e;
  int b;
  Line *l;
  char *p;
  
  pLVar1 = buf->currentLine;
  *spos = 0;
  *epos = 0;
  if (pLVar1 == (Line *)0x0) {
    pcVar2 = (char *)0x0;
  }
  else {
    pcVar2 = pLVar1->lineBuf;
    e = buf->pos;
    while ((0 < e && (iVar3 = is_wordchar((int)pcVar2[e],badchars), iVar3 == 0))) {
      e = e + -1;
    }
    iVar3 = is_wordchar((int)pcVar2[e],badchars);
    if (iVar3 == 0) {
      pcVar2 = (char *)0x0;
    }
    else {
      b = e;
      while ((0 < b && (iVar3 = is_wordchar((int)pcVar2[b + -1],badchars), iVar3 != 0))) {
        b = b + -1;
      }
      while ((e < pLVar1->len && (iVar3 = is_wordchar((int)pcVar2[e],badchars), iVar3 != 0))) {
        e = e + 1;
      }
      *spos = b;
      *epos = e;
      pcVar2 = pcVar2 + b;
    }
  }
  return pcVar2;
}



char * GetWord(Buffer *buf)

{
  char *pcVar1;
  Str p_Var2;
  char *p;
  int e;
  int b;
  
  pcVar1 = getCurWord(buf,&b,&e,(char *)0x0);
  if (pcVar1 == (char *)0x0) {
    pcVar1 = (char *)0x0;
  }
  else {
    p_Var2 = Strnew_charp_n(pcVar1,e - b);
    pcVar1 = p_Var2->ptr;
  }
  return pcVar1;
}



void execdict(char *word)

{
  char *p;
  wc_ces f_ces;
  wc_ces t_ces;
  Str p_Var1;
  Buffer *buf_00;
  Buffer *buf;
  char *dictcmd;
  char *w;
  
  t_ces = SystemCharset;
  f_ces = InnerCharset;
  if (((UseDictCommand == 0) || (word == (char *)0x0)) || (*word == '\0')) {
    displayBuffer(CurrentTab->currentBuffer,0);
  }
  else {
    p_Var1 = Strnew_charp(word);
    p_Var1 = wc_Str_conv_strict(p_Var1,f_ces,t_ces);
    p = p_Var1->ptr;
    if (*p == '\0') {
      displayBuffer(CurrentTab->currentBuffer,0);
    }
    else {
      p_Var1 = Strnew_charp(p);
      p_Var1 = Str_form_quote(p_Var1);
      p_Var1 = Sprintf("%s?%s",DictCommand,p_Var1->ptr);
      buf_00 = loadGeneralFile(p_Var1->ptr,(ParsedURL *)0x0,(char *)0xffffffff,0,(FormList *)0x0);
      if (buf_00 == (Buffer *)0x0) {
        disp_message("Execution failed",1);
      }
      else {
        buf_00->filename = p;
        p_Var1 = Sprintf("%s %s","*dictionary*",word);
        buf_00->buffername = p_Var1->ptr;
        if (buf_00->type == (char *)0x0) {
          buf_00->type = "text/plain";
        }
        pushBuffer(buf_00);
        displayBuffer(CurrentTab->currentBuffer,1);
      }
    }
  }
  return;
}



void dictword(void)

{
  char *word;
  
  word = inputLineHistSearch("(dictionary)!","",0x10,(Hist *)0x0,
                             (anon_subr_int_int_Str_Lineprop_ptr *)0x0);
  execdict(word);
  return;
}



void dictwordat(void)

{
  char *word;
  
  word = GetWord(CurrentTab->currentBuffer);
  execdict(word);
  return;
}



void set_buffer_environ(Buffer *buf)

{
  Line *pLVar1;
  Str p_Var2;
  char *pcVar3;
  Anchor *pAVar4;
  ParsedURL *pPVar5;
  ParsedURL pu;
  char *s;
  Anchor *a;
  Line *l;
  
  if (buf != (Buffer *)0x0) {
    if (buf != set_buffer_environ::prev_buf) {
      set_environ("W3M_SOURCEFILE",buf->sourcefile);
      set_environ("W3M_FILENAME",buf->filename);
      set_environ("W3M_TITLE",buf->buffername);
      p_Var2 = parsedURL2Str(&buf->currentURL);
      set_environ("W3M_URL",p_Var2->ptr);
      if (buf->real_type == (char *)0x0) {
        pcVar3 = "unknown";
      }
      else {
        pcVar3 = buf->real_type;
      }
      set_environ("W3M_TYPE",pcVar3);
      pcVar3 = wc_ces_to_charset(buf->document_charset);
      set_environ("W3M_CHARSET",pcVar3);
    }
    pLVar1 = buf->currentLine;
    if ((pLVar1 == (Line *)0x0) ||
       (((buf == set_buffer_environ::prev_buf && (pLVar1 == set_buffer_environ::prev_line)) &&
        (buf->pos == set_buffer_environ::prev_pos)))) {
      if (pLVar1 == (Line *)0x0) {
        set_environ("W3M_CURRENT_WORD","");
        set_environ("W3M_CURRENT_LINK","");
        set_environ("W3M_CURRENT_IMG","");
        set_environ("W3M_CURRENT_FORM","");
        set_environ("W3M_CURRENT_LINE","0");
        set_environ("W3M_CURRENT_COLUMN","0");
      }
    }
    else {
      pcVar3 = GetWord(buf);
      if (pcVar3 == (char *)0x0) {
        pcVar3 = "";
      }
      set_environ("W3M_CURRENT_WORD",pcVar3);
      pAVar4 = retrieveCurrentAnchor(buf);
      if (pAVar4 == (Anchor *)0x0) {
        set_environ("W3M_CURRENT_LINK","");
      }
      else {
        pPVar5 = baseURL(buf);
        parseURL2(pAVar4->url,&pu,pPVar5);
        p_Var2 = parsedURL2Str(&pu);
        set_environ("W3M_CURRENT_LINK",p_Var2->ptr);
      }
      pAVar4 = retrieveCurrentImg(buf);
      if (pAVar4 == (Anchor *)0x0) {
        set_environ("W3M_CURRENT_IMG","");
      }
      else {
        pPVar5 = baseURL(buf);
        parseURL2(pAVar4->url,&pu,pPVar5);
        p_Var2 = parsedURL2Str(&pu);
        set_environ("W3M_CURRENT_IMG",p_Var2->ptr);
      }
      pAVar4 = retrieveCurrentForm(buf);
      if (pAVar4 == (Anchor *)0x0) {
        set_environ("W3M_CURRENT_FORM","");
      }
      else {
        pcVar3 = form2str((FormItemList *)pAVar4->url);
        set_environ("W3M_CURRENT_FORM",pcVar3);
      }
      p_Var2 = Sprintf("%d",pLVar1->real_linenumber);
      set_environ("W3M_CURRENT_LINE",p_Var2->ptr);
      p_Var2 = Sprintf("%d",buf->currentColumn + (int)buf->cursorX + 1);
      set_environ("W3M_CURRENT_COLUMN",p_Var2->ptr);
    }
    set_buffer_environ::prev_buf = buf;
    set_buffer_environ::prev_pos = buf->pos;
    set_buffer_environ::prev_line = pLVar1;
  }
  return;
}



char * searchKeyData(void)

{
  char *pcVar1;
  char *data;
  
  data = (char *)0x0;
  if ((CurrentKeyData == (char *)0x0) || (*CurrentKeyData == '\0')) {
    if ((CurrentCmdData == (char *)0x0) || (*CurrentCmdData == '\0')) {
      if (-1 < CurrentKey) {
        data = getKeyData(CurrentKey);
      }
    }
    else {
      data = CurrentCmdData;
    }
  }
  else {
    data = CurrentKeyData;
  }
  CurrentKeyData = (char *)0x0;
  CurrentCmdData = (char *)0x0;
  if ((data == (char *)0x0) || (*data == '\0')) {
    pcVar1 = (char *)0x0;
  }
  else {
    pcVar1 = allocStr(data,-1);
  }
  return pcVar1;
}



int searchKeyNum(void)

{
  char *__nptr;
  int iVar1;
  int n;
  char *d;
  
  n = 1;
  __nptr = searchKeyData();
  if (__nptr != (char *)0x0) {
    n = atoi(__nptr);
  }
  iVar1 = prec_num;
  if (prec_num == 0) {
    iVar1 = 1;
  }
  return iVar1 * n;
}



void deleteFiles(void)

{
  Buffer *pBVar1;
  char *__name;
  char *f;
  Buffer *buf;
  
  for (CurrentTab = FirstTab; CurrentTab != (TabBuffer *)0x0; CurrentTab = CurrentTab->nextTab) {
    while ((CurrentTab->firstBuffer != (Buffer *)0x0 && (CurrentTab->firstBuffer != (Buffer *)0x1)))
    {
      pBVar1 = CurrentTab->firstBuffer->nextBuffer;
      discardBuffer(CurrentTab->firstBuffer);
      CurrentTab->firstBuffer = pBVar1;
    }
  }
  while (__name = (char *)popValue((GeneralList *)fileToDelete), __name != (char *)0x0) {
    unlink(__name);
  }
  return;
}



void w3m_exit(int i)

{
  init_migemo();
  stopDownload();
  deleteFiles();
  disconnectFTP();
  disconnectNews();
                    // WARNING: Subroutine does not return
  exit(i);
}



void execCmd(void)

{
  char *id;
  int iVar1;
  int cmd;
  char *p;
  char *data;
  
  CurrentKeyData = (char *)0x0;
  data = searchKeyData();
  if (((data == (char *)0x0) || (*data == '\0')) &&
     (data = inputLineHistSearch("command [; ...]: ","",0x10,TextHist,
                                 (anon_subr_int_int_Str_Lineprop_ptr *)0x0), data == (char *)0x0)) {
    displayBuffer(CurrentTab->currentBuffer,0);
  }
  else {
    while (*data != '\0') {
      while ((*data != '\0' && ((MYCTYPE_MAP[(byte)*data] & 2) != 0))) {
        data = data + 1;
      }
      if (*data == ';') {
        data = data + 1;
      }
      else {
        id = getWord(&data);
        iVar1 = getFuncList(id);
        if (iVar1 < 0) break;
        CurrentCmdData = getQWord(&data);
        CurrentKey = -1;
        CurrentKeyData = (char *)0x0;
        if (*CurrentCmdData == '\0') {
          CurrentCmdData = (char *)0x0;
        }
        if (use_mouse != 0) {
          mouse_inactive();
        }
        (*w3mFuncList[iVar1].func)();
        if (use_mouse != 0) {
          mouse_active();
        }
        CurrentCmdData = (char *)0x0;
      }
    }
    displayBuffer(CurrentTab->currentBuffer,0);
  }
  return;
}



void SigAlarm(int _dummy)

{
  char *data;
  
  if (0 < CurrentAlarm->sec) {
    CurrentKey = -1;
    CurrentKeyData = (char *)0x0;
    CurrentCmdData = (char *)CurrentAlarm->data;
    if (use_mouse != 0) {
      mouse_inactive();
    }
    (*w3mFuncList[CurrentAlarm->cmd].func)();
    if (use_mouse != 0) {
      mouse_active();
    }
    CurrentCmdData = (char *)0x0;
    if (CurrentAlarm->status == 3) {
      CurrentAlarm->sec = 0;
      CurrentAlarm->status = 0;
    }
    if (CurrentTab->currentBuffer->event != (_AlarmEvent *)0x0) {
      if (CurrentTab->currentBuffer->event->status == 0) {
        CurrentTab->currentBuffer->event = (_AlarmEvent *)0x0;
      }
      else {
        CurrentAlarm = CurrentTab->currentBuffer->event;
      }
    }
    if (CurrentTab->currentBuffer->event == (_AlarmEvent *)0x0) {
      CurrentAlarm = &DefaultAlarm;
    }
    if (0 < CurrentAlarm->sec) {
      mySignal(0xe,SigAlarm);
      alarm(CurrentAlarm->sec);
    }
  }
  return;
}



void setAlarm(void)

{
  char *pcVar1;
  Str p_Var2;
  int cmd;
  int sec;
  char *data;
  
  sec = 0;
  cmd = -1;
  CurrentKeyData = (char *)0x0;
  data = searchKeyData();
  if (((data == (char *)0x0) || (*data == '\0')) &&
     (data = inputLineHistSearch("(Alarm)sec command: ","",0x10,TextHist,
                                 (anon_subr_int_int_Str_Lineprop_ptr *)0x0), data == (char *)0x0)) {
    displayBuffer(CurrentTab->currentBuffer,0);
    return;
  }
  if (*data != '\0') {
    pcVar1 = getWord(&data);
    sec = atoi(pcVar1);
    if (0 < sec) {
      pcVar1 = getWord(&data);
      cmd = getFuncList(pcVar1);
    }
  }
  if (cmd < 0) {
    setAlarmEvent(&DefaultAlarm,0,0,0,(void *)0x0);
  }
  else {
    data = getQWord(&data);
    setAlarmEvent(&DefaultAlarm,sec,1,cmd,data);
    p_Var2 = Sprintf("%dsec %s %s",sec,w3mFuncList[cmd].id,data);
    disp_message_nsec(p_Var2->ptr,0,1,0,1);
  }
  displayBuffer(CurrentTab->currentBuffer,0);
  return;
}



AlarmEvent * setAlarmEvent(AlarmEvent *event,int sec,short status,int cmd,void *data)

{
  if (event == (AlarmEvent *)0x0) {
    event = (AlarmEvent *)GC_malloc(0x10);
  }
  event->sec = sec;
  event->status = status;
  event->cmd = cmd;
  event->data = data;
  return event;
}



void reinit(void)

{
  char *__s1;
  int iVar1;
  Str p_Var2;
  char *resource;
  
  __s1 = searchKeyData();
  if (__s1 == (char *)0x0) {
    init_rc();
    sync_with_option();
    initCookie();
    displayBuffer(CurrentTab->currentBuffer,4);
  }
  else {
    iVar1 = strcasecmp(__s1,"CONFIG");
    if ((iVar1 != 0) && (iVar1 = strcasecmp(__s1,"RC"), iVar1 != 0)) {
      iVar1 = strcasecmp(__s1,"COOKIE");
      if (iVar1 == 0) {
        initCookie();
        return;
      }
      iVar1 = strcasecmp(__s1,"KEYMAP");
      if (iVar1 == 0) {
        initKeymap(1);
        return;
      }
      iVar1 = strcasecmp(__s1,"MAILCAP");
      if (iVar1 == 0) {
        initMailcap();
        return;
      }
      iVar1 = strcasecmp(__s1,"MOUSE");
      if (iVar1 == 0) {
        initMouseAction();
        displayBuffer(CurrentTab->currentBuffer,4);
        return;
      }
      iVar1 = strcasecmp(__s1,"MENU");
      if (iVar1 == 0) {
        initMenu();
        return;
      }
      iVar1 = strcasecmp(__s1,"MIMETYPES");
      if (iVar1 == 0) {
        initMimeTypes();
        return;
      }
      iVar1 = strcasecmp(__s1,"URIMETHODS");
      if (iVar1 == 0) {
        initURIMethods();
        return;
      }
      p_Var2 = Sprintf("Don\'t know how to reinitialize \'%s\'",__s1);
      disp_err_message(p_Var2->ptr,0);
      return;
    }
    init_rc();
    sync_with_option();
    displayBuffer(CurrentTab->currentBuffer,4);
  }
  return;
}



void defKey(void)

{
  char *p;
  char *data;
  
  CurrentKeyData = (char *)0x0;
  data = searchKeyData();
  if (((data == (char *)0x0) || (*data == '\0')) &&
     ((data = inputLineHistSearch("Key definition: ","",0x10,TextHist,
                                  (anon_subr_int_int_Str_Lineprop_ptr *)0x0), data == (char *)0x0 ||
      (*data == '\0')))) {
    displayBuffer(CurrentTab->currentBuffer,0);
    return;
  }
  p = allocStr(data,-1);
  setKeymap(p,-1,1);
  displayBuffer(CurrentTab->currentBuffer,0);
  return;
}



TabBuffer * newTab(void)

{
  TabBuffer *pTVar1;
  TabBuffer *n;
  
  pTVar1 = (TabBuffer *)GC_malloc(0x18);
  if (pTVar1 == (TabBuffer *)0x0) {
    pTVar1 = (TabBuffer *)0x0;
  }
  else {
    pTVar1->nextTab = (_TabBuffer *)0x0;
    pTVar1->currentBuffer = (Buffer *)0x0;
    pTVar1->firstBuffer = (Buffer *)0x0;
  }
  return pTVar1;
}



void _newT(void)

{
  TabBuffer *pTVar1;
  TabBuffer *pTVar2;
  Buffer *a;
  int i;
  Buffer *buf;
  TabBuffer *tag;
  
  pTVar2 = newTab();
  if (pTVar2 != (TabBuffer *)0x0) {
    a = newBuffer((int)CurrentTab->currentBuffer->width);
    copyBuffer(a,CurrentTab->currentBuffer);
    a->nextBuffer = (_Buffer *)0x0;
    for (i = 0; i < 5; i = i + 1) {
      a->linkBuffer[i] = (_Buffer *)0x0;
    }
    *a->clone = *a->clone + 1;
    pTVar2->currentBuffer = a;
    pTVar2->firstBuffer = pTVar2->currentBuffer;
    pTVar2->nextTab = CurrentTab->nextTab;
    pTVar2->prevTab = CurrentTab;
    pTVar1 = pTVar2;
    if (CurrentTab->nextTab != (_TabBuffer *)0x0) {
      CurrentTab->nextTab->prevTab = pTVar2;
      pTVar1 = LastTab;
    }
    LastTab = pTVar1;
    CurrentTab->nextTab = pTVar2;
    nTab = nTab + 1;
    CurrentTab = pTVar2;
  }
  return;
}



void newT(void)

{
  _newT();
  displayBuffer(CurrentTab->currentBuffer,4);
  return;
}



TabBuffer * numTab(int n)

{
  int i;
  TabBuffer *tab;
  
  tab = CurrentTab;
  if ((n != 0) && (tab = FirstTab, n != 1)) {
    if (nTab < 2) {
      tab = (TabBuffer *)0x0;
    }
    else {
      for (i = 1; (tab != (TabBuffer *)0x0 && (i < n)); i = i + 1) {
        tab = tab->nextTab;
      }
    }
  }
  return tab;
}



void calcTabPos(void)

{
  int iVar1;
  int iy;
  int ix;
  int ny;
  int nx;
  int na;
  int n2;
  int n1;
  int col;
  int rcol;
  int lcol;
  TabBuffer *tab;
  
  iVar1 = mouse_action.menu_width;
  if (mouse_action.menu_str == (char *)0x0) {
    iVar1 = 0;
  }
  if (0 < nTab) {
    n1 = (COLS - iVar1) / TabCols;
    if (n1 < nTab) {
      if (n1 < 0) {
        n1 = 0;
      }
      n2 = COLS / TabCols;
      if (n2 == 0) {
        n2 = 1;
      }
      ny = ((nTab - n1) + -1) / n2 + 2;
    }
    else {
      n2 = 1;
      ny = 1;
    }
    n1 = n1 - (((ny + -1) * n2 + n1) - nTab) / ny;
    if (n1 < 0) {
      n1 = 0;
    }
    tab = FirstTab;
    iy = 0;
    while ((iy < ny && (tab != (TabBuffer *)0x0))) {
      if (iy == 0) {
        nx = n1;
        col = COLS - iVar1;
      }
      else {
        nx = n2 - ((((ny + -1) * n2 + n1) - nTab) + iy + -1) / (ny + -1);
        col = COLS;
      }
      ix = 0;
      for (; (ix < nx && (tab != (TabBuffer *)0x0)); tab = tab->nextTab) {
        tab->x1 = (short)((col * ix) / nx);
        tab->x2 = (short)(((ix + 1) * col) / nx) + -1;
        tab->y = (short)iy;
        if (iy == 0) {
          tab->x1 = tab->x1 + (short)iVar1;
          tab->x2 = tab->x2 + (short)iVar1;
        }
        ix = ix + 1;
      }
      iy = iy + 1;
    }
  }
  return;
}



TabBuffer * deleteTab(TabBuffer *tab)

{
  _Buffer *p_Var1;
  Buffer *next;
  Buffer *buf;
  
  if (1 < nTab) {
    if (tab->prevTab == (_TabBuffer *)0x0) {
      tab->nextTab->prevTab = (_TabBuffer *)0x0;
      FirstTab = tab->nextTab;
      if (tab == CurrentTab) {
        CurrentTab = tab->nextTab;
      }
    }
    else {
      if (tab->nextTab == (_TabBuffer *)0x0) {
        LastTab = tab->prevTab;
      }
      else {
        tab->nextTab->prevTab = tab->prevTab;
      }
      tab->prevTab->nextTab = tab->nextTab;
      if (tab == CurrentTab) {
        CurrentTab = tab->prevTab;
      }
    }
    nTab = nTab + -1;
    buf = tab->firstBuffer;
    while ((buf != (Buffer *)0x0 && (buf != (Buffer *)0x1))) {
      p_Var1 = buf->nextBuffer;
      discardBuffer(buf);
      buf = p_Var1;
    }
  }
  return FirstTab;
}



void closeT(void)

{
  int n;
  TabBuffer *tab;
  
  if (1 < nTab) {
    if (prec_num == 0) {
      tab = CurrentTab;
    }
    else {
      n = prec_num;
      if (prec_num == 0) {
        n = 1;
      }
      tab = numTab(n);
    }
    if (tab != (TabBuffer *)0x0) {
      deleteTab(tab);
    }
    displayBuffer(CurrentTab->currentBuffer,4);
  }
  return;
}



void nextT(void)

{
  int iVar1;
  int i;
  
  if (1 < nTab) {
    i = 0;
    while( true ) {
      iVar1 = prec_num;
      if (prec_num == 0) {
        iVar1 = 1;
      }
      if (iVar1 <= i) break;
      if (CurrentTab->nextTab == (_TabBuffer *)0x0) {
        CurrentTab = FirstTab;
      }
      else {
        CurrentTab = CurrentTab->nextTab;
      }
      i = i + 1;
    }
    displayBuffer(CurrentTab->currentBuffer,4);
  }
  return;
}



void prevT(void)

{
  int iVar1;
  int i;
  
  if (1 < nTab) {
    i = 0;
    while( true ) {
      iVar1 = prec_num;
      if (prec_num == 0) {
        iVar1 = 1;
      }
      if (iVar1 <= i) break;
      if (CurrentTab->prevTab == (_TabBuffer *)0x0) {
        CurrentTab = LastTab;
      }
      else {
        CurrentTab = CurrentTab->prevTab;
      }
      i = i + 1;
    }
    displayBuffer(CurrentTab->currentBuffer,4);
  }
  return;
}



void followTab(TabBuffer *tab)

{
  Buffer *first;
  Buffer *pBVar1;
  Buffer *p;
  Buffer *c;
  Anchor *a;
  Buffer *buf;
  
  a = retrieveCurrentImg(CurrentTab->currentBuffer);
  if (((a == (Anchor *)0x0) || (a->image == (Image *)0x0)) || (a->image->map == (char *)0x0)) {
    a = retrieveCurrentAnchor(CurrentTab->currentBuffer);
  }
  if (a != (Anchor *)0x0) {
    if (tab == CurrentTab) {
      check_target = 0;
      followA();
      check_target = 1;
    }
    else {
      _newT();
      pBVar1 = CurrentTab->currentBuffer;
      check_target = 0;
      followA();
      check_target = 1;
      if (tab == (TabBuffer *)0x0) {
        if (CurrentTab->currentBuffer == pBVar1) {
          deleteTab(CurrentTab);
        }
        else {
          delBuffer(pBVar1);
        }
      }
      else if (CurrentTab->currentBuffer != pBVar1) {
        first = CurrentTab->currentBuffer;
        buf = prevBuffer(first,pBVar1);
        buf->nextBuffer = (_Buffer *)0x0;
        CurrentTab->firstBuffer = pBVar1;
        deleteTab(CurrentTab);
        CurrentTab = tab;
        while (buf != (Buffer *)0x0) {
          pBVar1 = prevBuffer(first,buf);
          pushBuffer(buf);
          buf = pBVar1;
        }
      }
      displayBuffer(CurrentTab->currentBuffer,1);
    }
  }
  return;
}



void tabA(void)

{
  int n;
  TabBuffer *tab;
  
  if (prec_num == 0) {
    tab = (TabBuffer *)0x0;
  }
  else {
    n = prec_num;
    if (prec_num == 0) {
      n = 1;
    }
    tab = numTab(n);
  }
  followTab(tab);
  return;
}



void tabURL0(TabBuffer *tab,char *prompt,int relative)

{
  Buffer *first;
  Buffer *pBVar1;
  Buffer *p;
  Buffer *c;
  Buffer *buf;
  
  if (tab == CurrentTab) {
    goURL0(prompt,relative);
  }
  else {
    _newT();
    pBVar1 = CurrentTab->currentBuffer;
    goURL0(prompt,relative);
    if (tab == (TabBuffer *)0x0) {
      if (CurrentTab->currentBuffer == pBVar1) {
        deleteTab(CurrentTab);
      }
      else {
        delBuffer(pBVar1);
      }
    }
    else if (CurrentTab->currentBuffer != pBVar1) {
      first = CurrentTab->currentBuffer;
      buf = prevBuffer(first,pBVar1);
      buf->nextBuffer = (_Buffer *)0x0;
      CurrentTab->firstBuffer = pBVar1;
      deleteTab(CurrentTab);
      CurrentTab = tab;
      while (buf != (Buffer *)0x0) {
        pBVar1 = prevBuffer(first,buf);
        pushBuffer(buf);
        buf = pBVar1;
      }
    }
    displayBuffer(CurrentTab->currentBuffer,1);
  }
  return;
}



void tabURL(void)

{
  int n;
  TabBuffer *tab;
  
  if (prec_num == 0) {
    tab = (TabBuffer *)0x0;
  }
  else {
    n = prec_num;
    if (prec_num == 0) {
      n = 1;
    }
    tab = numTab(n);
  }
  tabURL0(tab,"Goto URL on new tab: ",0);
  return;
}



void tabrURL(void)

{
  int n;
  TabBuffer *tab;
  
  if (prec_num == 0) {
    tab = (TabBuffer *)0x0;
  }
  else {
    n = prec_num;
    if (prec_num == 0) {
      n = 1;
    }
    tab = numTab(n);
  }
  tabURL0(tab,"Goto relative URL on new tab: ",1);
  return;
}



void moveTab(TabBuffer *t,TabBuffer *t2,int right)

{
  if (t2 == (TabBuffer *)0x1) {
    t2 = FirstTab;
  }
  if ((((t != (TabBuffer *)0x0) && (t2 != (TabBuffer *)0x0)) && (t != t2)) &&
     (t != (TabBuffer *)0x1)) {
    if (t->prevTab == (_TabBuffer *)0x0) {
      t->nextTab->prevTab = (_TabBuffer *)0x0;
      FirstTab = t->nextTab;
    }
    else {
      if (t->nextTab == (_TabBuffer *)0x0) {
        LastTab = t->prevTab;
      }
      else {
        t->nextTab->prevTab = t->prevTab;
      }
      t->prevTab->nextTab = t->nextTab;
    }
    if (right == 0) {
      t->prevTab = t2->prevTab;
      t->nextTab = t2;
      if (t2->prevTab == (_TabBuffer *)0x0) {
        FirstTab = t;
      }
      else {
        t2->prevTab->nextTab = t;
      }
      t2->prevTab = t;
    }
    else {
      t->nextTab = t2->nextTab;
      t->prevTab = t2;
      if (t2->nextTab == (_TabBuffer *)0x0) {
        LastTab = t;
      }
      else {
        t2->nextTab->prevTab = t;
      }
      t2->nextTab = t;
    }
    displayBuffer(CurrentTab->currentBuffer,1);
  }
  return;
}



void tabR(void)

{
  int iVar1;
  TabBuffer *t2;
  int i;
  TabBuffer *tab;
  
  i = 0;
  for (tab = CurrentTab; tab != (TabBuffer *)0x0; tab = tab->nextTab) {
    iVar1 = prec_num;
    if (prec_num == 0) {
      iVar1 = 1;
    }
    if (iVar1 <= i) break;
    i = i + 1;
  }
  t2 = LastTab;
  if (tab != (TabBuffer *)0x0) {
    t2 = tab;
  }
  moveTab(CurrentTab,t2,1);
  return;
}



void tabL(void)

{
  int iVar1;
  TabBuffer *t2;
  int i;
  TabBuffer *tab;
  
  i = 0;
  for (tab = CurrentTab; tab != (TabBuffer *)0x0; tab = tab->prevTab) {
    iVar1 = prec_num;
    if (prec_num == 0) {
      iVar1 = 1;
    }
    if (iVar1 <= i) break;
    i = i + 1;
  }
  t2 = FirstTab;
  if (tab != (TabBuffer *)0x0) {
    t2 = tab;
  }
  moveTab(CurrentTab,t2,0);
  return;
}



void addDownloadList(pid_t pid,char *url,char *save,char *lock,clen_t size)

{
  DownloadList *pDVar1;
  DownloadList *pDVar2;
  Str p_Var3;
  char *pcVar4;
  time_t tVar5;
  DownloadList *d;
  
  pDVar2 = (DownloadList *)GC_malloc(0x28);
  pDVar2->pid = pid;
  pDVar2->url = url;
  if ((*save != '/') && (*save != '~')) {
    p_Var3 = Strnew_m_charp(CurrentDir,&DAT_080c8aa3,save,0);
    save = p_Var3->ptr;
  }
  pcVar4 = expandPath(save);
  pDVar2->save = pcVar4;
  pDVar2->lock = lock;
  *(undefined4 *)&pDVar2->size = (undefined4)size;
  *(undefined4 *)((int)&pDVar2->size + 4) = size._4_4_;
  tVar5 = time((time_t *)0x0);
  pDVar2->time = tVar5;
  pDVar2->ok = 0;
  pDVar2->next = (_DownloadList *)0x0;
  pDVar2->prev = LastDL;
  pDVar1 = pDVar2;
  if (LastDL != (DownloadList *)0x0) {
    LastDL->next = pDVar2;
    pDVar1 = FirstDL;
  }
  FirstDL = pDVar1;
  LastDL = pDVar2;
  add_download_list = 1;
  return;
}



int checkDownloadList(void)

{
  int iVar1;
  stat st;
  DownloadList *d;
  
  if (FirstDL != (DownloadList *)0x0) {
    for (d = FirstDL; d != (DownloadList *)0x0; d = d->next) {
      if ((d->ok == 0) && (iVar1 = lstat(d->lock,(stat *)&st), iVar1 == 0)) {
        return 1;
      }
    }
  }
  return 0;
}



char * convert_size3(clen_t size)

{
  undefined4 uVar1;
  char *fmt;
  int n;
  Str tmp;
  
  tmp = Strnew();
  do {
    uVar1 = __moddi3(size,1000,0);
    size = __divdi3(size,1000,0);
    if (size == 0) {
      fmt = "%d%s";
    }
    else {
      fmt = ",%.3d%s";
    }
    tmp = Sprintf(fmt,uVar1,tmp->ptr);
  } while (size != 0);
  return tmp->ptr;
}



Buffer * DownloadListBuffer(void)

{
  bool bVar1;
  longlong lVar2;
  wc_ces t_ces;
  wc_ces f_ces;
  Buffer *pBVar3;
  time_t tVar4;
  Str x;
  int iVar5;
  Str p_Var6;
  char *pcVar7;
  char *pcVar8;
  int iVar9;
  uint uVar10;
  stat st;
  int l;
  int i;
  size_t size;
  int eta;
  int rate;
  int duration;
  time_t cur_time;
  Str src;
  DownloadList *d;
  
  if (FirstDL == (DownloadList *)0x0) {
    pBVar3 = (Buffer *)0x0;
  }
  else {
    tVar4 = time((time_t *)0x0);
    x = Strnew_charp(
                    "<html><head><title>Download List Panel</title></head>\n<body><h1 align=center>Download List Panel</h1>\n<form method=internal action=download><hr>\n"
                    );
    for (d = LastDL; d != (DownloadList *)0x0; d = d->prev) {
      iVar5 = lstat(d->lock,(stat *)&st);
      if (iVar5 != 0) {
        d->ok = 1;
      }
      Strcat_charp(x,"<pre>\n");
      f_ces = SystemCharset;
      t_ces = InnerCharset;
      p_Var6 = Strnew_charp(d->save);
      p_Var6 = wc_Str_conv(p_Var6,f_ces,t_ces);
      pcVar7 = html_quote(p_Var6->ptr);
      pcVar8 = html_quote(d->url);
      p_Var6 = Sprintf("%s\n  --&gt; %s\n  ",pcVar8,pcVar7);
      Strcat(x,p_Var6);
      duration = tVar4 - d->time;
      iVar5 = stat(d->save,(stat *)&st);
      if (iVar5 == 0) {
        size = st.st_size;
        if (d->ok != 0) {
          *(__off_t *)&d->size = st.st_size;
          *(undefined4 *)((int)&d->size + 4) = 0;
          duration = st.st_mtim.tv_sec - d->time;
        }
      }
      else {
        size = 0;
      }
      if ((*(uint *)&d->size | *(uint *)((int)&d->size + 4)) != 0) {
        iVar9 = COLS + -6;
        iVar5 = *(int *)((int)&d->size + 4);
        i = iVar9;
        if ((-1 < iVar5) && ((0 < iVar5 || (size < *(uint *)&d->size)))) {
          i = (int)ROUND(((float10)(ulonglong)size * (float10)iVar9) / (float10)d->size);
        }
        l = iVar9 - i;
        while (bVar1 = 0 < i, i = i + -1, bVar1) {
          if (x->area_size <= x->length + 1) {
            Strgrow(x);
          }
          iVar5 = x->length;
          x->ptr[iVar5] = '#';
          x->length = iVar5 + 1;
          x->ptr[x->length] = '\0';
        }
        while (bVar1 = 0 < l, l = l + -1, bVar1) {
          if (x->area_size <= x->length + 1) {
            Strgrow(x);
          }
          iVar5 = x->length;
          x->ptr[iVar5] = '_';
          x->length = iVar5 + 1;
          x->ptr[x->length] = '\0';
        }
        if (x->area_size <= x->length + 1) {
          Strgrow(x);
        }
        iVar5 = x->length;
        x->ptr[iVar5] = '\n';
        x->length = iVar5 + 1;
        x->ptr[x->length] = '\0';
      }
      if (d->ok == 0) {
        iVar5 = *(int *)((int)&d->size + 4);
        if ((iVar5 < 0) || ((iVar5 < 1 && (*(uint *)&d->size <= size)))) goto LAB_08059fc1;
        lVar2 = d->size;
        pcVar7 = convert_size3(d->size);
        pcVar8 = convert_size3((ulonglong)size);
        p_Var6 = Sprintf("  %s / %s bytes (%d%%)",pcVar8,pcVar7,
                         (int)ROUND(((double)(ulonglong)size * 100.0) / (double)lVar2));
        Strcat(x,p_Var6);
      }
      else {
LAB_08059fc1:
        pcVar8 = convert_size3((ulonglong)size);
        p_Var6 = Sprintf("  %s bytes loaded",pcVar8);
        Strcat(x,p_Var6);
      }
      if (0 < duration) {
        uVar10 = size / (uint)duration;
        pcVar8 = convert_size((longlong)(int)uVar10,1);
        pcVar7 = (char *)((duration / 0x3c) % 0x3c);
        p_Var6 = Sprintf("  %02d:%02d:%02d  rate %s/sec",duration / 0xe10,pcVar7,duration % 0x3c,
                         pcVar8);
        Strcat(x,p_Var6);
        if (d->ok == 0) {
          iVar5 = *(int *)((int)&d->size + 4);
          if ((-1 < iVar5) && (((0 < iVar5 || (size < *(uint *)&d->size)) && (uVar10 != 0)))) {
            iVar5 = __divdi3(*(uint *)&d->size - size,
                             *(int *)((int)&d->size + 4) - (uint)(*(uint *)&d->size < size),uVar10,
                             (int)uVar10 >> 0x1f);
            pcVar7 = (char *)((iVar5 / 0x3c) % 0x3c);
            p_Var6 = Sprintf("  eta %02d:%02d:%02d",iVar5 / 0xe10,pcVar7,iVar5 % 0x3c,pcVar8);
            Strcat(x,p_Var6);
          }
        }
      }
      if (x->area_size <= x->length + 1) {
        Strgrow(x);
      }
      iVar5 = x->length;
      x->ptr[iVar5] = '\n';
      x->length = iVar5 + 1;
      x->ptr[x->length] = '\0';
      if (d->ok == 0) {
        p_Var6 = Sprintf("<input type=submit name=stop%d value=STOP>",d->pid,pcVar7);
        Strcat(x,p_Var6);
      }
      else {
        p_Var6 = Sprintf("<input type=submit name=ok%d value=OK>",d->pid,pcVar7);
        Strcat(x,p_Var6);
        iVar5 = *(int *)((int)&d->size + 4);
        if ((iVar5 < 0) || ((iVar5 < 1 && (*(uint *)&d->size <= size)))) {
          Strcat_charp(x," Download completed");
        }
        else {
          Strcat_charp(x," Download incompleted");
        }
      }
      Strcat_charp(x,"\n</pre><hr>\n");
    }
    Strcat_charp(x,"</form></body></html>");
    pBVar3 = loadHTMLString(x);
  }
  return pBVar3;
}



void download_action(parsed_tagarg *arg)

{
  int iVar1;
  pid_t pid;
  DownloadList *d;
  
  do {
    if (arg == (parsed_tagarg *)0x0) {
      ldDL();
      return;
    }
    iVar1 = strncmp(arg->arg,"stop",4);
    if (iVar1 == 0) {
      pid = atoi(arg->arg + 4);
      kill(pid,9);
LAB_0805a3de:
      for (d = FirstDL; d != (DownloadList *)0x0; d = d->next) {
        if (d->pid == pid) {
          unlink(d->lock);
          if (d->prev == (_DownloadList *)0x0) {
            FirstDL = d->next;
          }
          else {
            d->prev->next = d->next;
          }
          if (d->next == (_DownloadList *)0x0) {
            LastDL = d->prev;
          }
          else {
            d->next->prev = d->prev;
          }
          break;
        }
      }
    }
    else {
      iVar1 = strncmp(arg->arg,"ok",2);
      if (iVar1 == 0) {
        pid = atoi(arg->arg + 2);
        goto LAB_0805a3de;
      }
    }
    arg = arg->next;
  } while( true );
}



void stopDownload(void)

{
  DownloadList *d;
  
  if (FirstDL != (DownloadList *)0x0) {
    for (d = FirstDL; d != (DownloadList *)0x0; d = d->next) {
      if (d->ok == 0) {
        kill(d->pid,9);
        unlink(d->lock);
      }
    }
  }
  return;
}



void ldDL(void)

{
  bool bVar1;
  bool bVar2;
  int iVar3;
  Buffer *pBVar4;
  AlarmEvent *pAVar5;
  int reload;
  int new_tab;
  int replace;
  Buffer *buf;
  
  bVar1 = false;
  bVar2 = false;
  if (((CurrentTab->currentBuffer->bufferprop & 8U) != 0) &&
     (iVar3 = strcmp(CurrentTab->currentBuffer->buffername,"Download List Panel"), iVar3 == 0)) {
    bVar1 = true;
  }
  if (FirstDL == (DownloadList *)0x0) {
    if (bVar1) {
      if ((CurrentTab->currentBuffer == CurrentTab->firstBuffer) &&
         (CurrentTab->currentBuffer->nextBuffer == (_Buffer *)0x0)) {
        if (1 < nTab) {
          deleteTab(CurrentTab);
        }
      }
      else {
        delBuffer(CurrentTab->currentBuffer);
      }
      displayBuffer(CurrentTab->currentBuffer,1);
    }
  }
  else {
    iVar3 = checkDownloadList();
    pBVar4 = DownloadListBuffer();
    if (pBVar4 == (Buffer *)0x0) {
      displayBuffer(CurrentTab->currentBuffer,0);
    }
    else {
      pBVar4->bufferprop = pBVar4->bufferprop | 0x18;
      if (bVar1) {
        pBVar4->rootX = CurrentTab->currentBuffer->rootX;
        pBVar4->rootY = CurrentTab->currentBuffer->rootY;
        pBVar4->COLS = CurrentTab->currentBuffer->COLS;
        pBVar4->LINES = CurrentTab->currentBuffer->LINES;
        restorePosition(pBVar4,CurrentTab->currentBuffer);
      }
      else if (open_tab_dl_list != 0) {
        _newT();
        bVar2 = true;
      }
      pushBuffer(pBVar4);
      if ((bVar1) || (bVar2)) {
        deletePrevBuf();
      }
      if (iVar3 != 0) {
        pBVar4 = CurrentTab->currentBuffer;
        pAVar5 = setAlarmEvent(CurrentTab->currentBuffer->event,1,2,0x70,(void *)0x0);
        pBVar4->event = pAVar5;
      }
      displayBuffer(CurrentTab->currentBuffer,1);
    }
  }
  return;
}



void save_buffer_position(Buffer *buf)

{
  _BufferPos *p_Var1;
  long lVar2;
  int iVar3;
  BufferPos *b;
  
  p_Var1 = buf->undo;
  if (buf->firstLine != (Line *)0x0) {
    if (p_Var1 != (_BufferPos *)0x0) {
      if (buf->topLine == (Line *)0x0) {
        iVar3 = 1;
      }
      else {
        iVar3 = buf->topLine->linenumber;
      }
      if (p_Var1->top_linenumber == iVar3) {
        if (buf->currentLine == (Line *)0x0) {
          iVar3 = 1;
        }
        else {
          iVar3 = buf->currentLine->linenumber;
        }
        if (((p_Var1->cur_linenumber == iVar3) && (p_Var1->currentColumn == buf->currentColumn)) &&
           (p_Var1->pos == buf->pos)) {
          return;
        }
      }
    }
    p_Var1 = (_BufferPos *)GC_malloc(0x1c);
    if (buf->topLine == (Line *)0x0) {
      lVar2 = 1;
    }
    else {
      lVar2 = buf->topLine->linenumber;
    }
    p_Var1->top_linenumber = lVar2;
    if (buf->currentLine == (Line *)0x0) {
      lVar2 = 1;
    }
    else {
      lVar2 = buf->currentLine->linenumber;
    }
    p_Var1->cur_linenumber = lVar2;
    p_Var1->currentColumn = buf->currentColumn;
    p_Var1->pos = buf->pos;
    if (buf->currentLine == (Line *)0x0) {
      iVar3 = 0;
    }
    else {
      iVar3 = buf->currentLine->bpos;
    }
    p_Var1->bpos = iVar3;
    p_Var1->next = (_BufferPos *)0x0;
    p_Var1->prev = buf->undo;
    if (buf->undo != (_BufferPos *)0x0) {
      buf->undo->next = p_Var1;
    }
    buf->undo = p_Var1;
  }
  return;
}



void resetPos(BufferPos *b)

{
  Buffer buf;
  Line cur;
  Line top;
  
  top.linenumber = b->top_linenumber;
  cur.linenumber = b->cur_linenumber;
  cur.bpos = b->bpos;
  buf.topLine = &top;
  buf.currentLine = &cur;
  buf.pos = b->pos;
  buf.currentColumn = b->currentColumn;
  restorePosition(CurrentTab->currentBuffer,&buf);
  CurrentTab->currentBuffer->undo = b;
  displayBuffer(CurrentTab->currentBuffer,1);
  return;
}



void undoPos(void)

{
  int iVar1;
  int i;
  BufferPos *b;
  
  b = CurrentTab->currentBuffer->undo;
  if (((CurrentTab->currentBuffer->firstLine != (Line *)0x0) && (b != (_BufferPos *)0x0)) &&
     (b->prev != (_BufferPos *)0x0)) {
    i = 0;
    while( true ) {
      iVar1 = prec_num;
      if (prec_num == 0) {
        iVar1 = 1;
      }
      if ((iVar1 <= i) || (b->prev == (_BufferPos *)0x0)) break;
      i = i + 1;
      b = b->prev;
    }
    resetPos(b);
  }
  return;
}



void redoPos(void)

{
  int iVar1;
  int i;
  BufferPos *b;
  
  b = CurrentTab->currentBuffer->undo;
  if (((CurrentTab->currentBuffer->firstLine != (Line *)0x0) && (b != (_BufferPos *)0x0)) &&
     (b->next != (_BufferPos *)0x0)) {
    i = 0;
    while( true ) {
      iVar1 = prec_num;
      if (prec_num == 0) {
        iVar1 = 1;
      }
      if ((iVar1 <= i) || (b->next == (_BufferPos *)0x0)) break;
      i = i + 1;
      b = b->next;
    }
    resetPos(b);
  }
  return;
}



void KeyAbort(int _dummy)

{
                    // WARNING: Subroutine does not return
  siglongjmp((__jmp_buf_tag *)AbortLoading,1);
}



void UFhalfclose(URLFile *f)

{
  uchar uVar1;
  int iVar2;
  
  uVar1 = f->scheme;
  if ((uVar1 == '\a') || (uVar1 == '\t')) {
    closeNews();
  }
  else if (uVar1 == '\x02') {
    closeFTP();
  }
  else {
    iVar2 = ISclose(f->stream);
    if (iVar2 == 0) {
      f->stream = (InputStream)0x0;
    }
  }
  return;
}



int currentLn(Buffer *buf)

{
  int iVar1;
  
  if (buf->currentLine == (Line *)0x0) {
    iVar1 = 1;
  }
  else {
    iVar1 = buf->currentLine->linenumber + 1;
  }
  return iVar1;
}



Buffer * loadSomething(URLFile *f,char *path,anon_subr_Buffer_ptr_URLFile_ptr_Buffer_ptr *loadproc,
                      Buffer *defaultbuf)

{
  wc_ces t_ces;
  wc_ces f_ces;
  Buffer *buf_00;
  char *pcVar1;
  Str p_Var2;
  Buffer *buf;
  
  buf_00 = (*loadproc)(f,defaultbuf);
  if (buf_00 == (Buffer *)0x0) {
    buf_00 = (Buffer *)0x0;
  }
  else {
    buf_00->filename = path;
    if ((buf_00->buffername == (char *)0x0) || (*buf_00->buffername == '\0')) {
      pcVar1 = checkHeader(buf_00,"Subject:");
      buf_00->buffername = pcVar1;
      f_ces = SystemCharset;
      t_ces = InnerCharset;
      if (buf_00->buffername == (char *)0x0) {
        pcVar1 = lastFileName(path);
        p_Var2 = Strnew_charp(pcVar1);
        p_Var2 = wc_Str_conv(p_Var2,f_ces,t_ces);
        buf_00->buffername = p_Var2->ptr;
      }
    }
    if ((buf_00->currentURL).scheme == 0xff) {
      (buf_00->currentURL).scheme = (uint)f->scheme;
    }
    buf_00->real_scheme = (uint)f->scheme;
    if ((f->scheme == '\x04') && (buf_00->sourcefile == (char *)0x0)) {
      buf_00->sourcefile = path;
    }
  }
  return buf_00;
}



int dir_exist(char *path)

{
  uint uVar1;
  int iVar2;
  stat stbuf;
  
  if ((path == (char *)0x0) || (*path == '\0')) {
    uVar1 = 0;
  }
  else {
    iVar2 = stat(path,(stat *)&stbuf);
    if (iVar2 == -1) {
      uVar1 = 0;
    }
    else {
      uVar1 = (uint)((stbuf.st_mode & 0xf000) == 0x4000);
    }
  }
  return uVar1;
}



int is_dump_text_type(char *type)

{
  mailcap *pmVar1;
  mailcap *mcap;
  
  if (((type != (char *)0x0) && (pmVar1 = searchExtViewer(type), pmVar1 != (mailcap *)0x0)) &&
     ((pmVar1->flags & 6U) != 0)) {
    return 1;
  }
  return 0;
}



int is_text_type(char *type)

{
  int iVar1;
  
  if ((((type != (char *)0x0) && (*type != '\0')) &&
      (iVar1 = strncasecmp(type,"text/",5), iVar1 != 0)) &&
     (iVar1 = strncasecmp(type,"message/",8), iVar1 != 0)) {
    return 0;
  }
  return 1;
}



int is_plain_text_type(char *type)

{
  int iVar1;
  
  if (type == (char *)0x0) {
LAB_0805ac99:
    iVar1 = is_text_type(type);
    if (iVar1 != 0) {
      iVar1 = is_dump_text_type(type);
      if (iVar1 == 0) goto LAB_0805acb7;
    }
    iVar1 = 0;
  }
  else {
    iVar1 = strcasecmp(type,"text/plain");
    if (iVar1 != 0) goto LAB_0805ac99;
LAB_0805acb7:
    iVar1 = 1;
  }
  return iVar1;
}



int is_html_type(char *type)

{
  int iVar1;
  
  if (type == (char *)0x0) {
LAB_0805ad06:
    iVar1 = 0;
  }
  else {
    iVar1 = strcasecmp(type,"text/html");
    if (iVar1 != 0) {
      iVar1 = strcasecmp(type,"application/xhtml+xml");
      if (iVar1 != 0) goto LAB_0805ad06;
    }
    iVar1 = 1;
  }
  return iVar1;
}



void check_compression(char *path,URLFile *uf)

{
  size_t sVar1;
  size_t sVar2;
  int iVar3;
  int elen;
  compression_decoder *d;
  int len;
  
  if (path != (char *)0x0) {
    sVar1 = strlen(path);
    uf->compression = 0;
    for (d = compression_decoders; d->type != 0; d = d + 1) {
      if (((d->ext != (char *)0x0) && (sVar2 = strlen(d->ext), (int)sVar2 < (int)sVar1)) &&
         (iVar3 = strcasecmp(path + (sVar1 - sVar2),d->ext), iVar3 == 0)) {
        uf->compression = d->type;
        uf->guess_type = d->mime_type;
        return;
      }
    }
  }
  return;
}



char * compress_application_type(int compression)

{
  compression_decoder *d;
  
  d = compression_decoders;
  while( true ) {
    if (d->type == 0) {
      return (char *)0x0;
    }
    if (d->type == compression) break;
    d = d + 1;
  }
  return d->mime_type;
}



char * uncompressed_file_type(char *path,char **ext)

{
  size_t sVar1;
  int iVar2;
  Str s;
  char *pcVar3;
  compression_decoder *d;
  char *t0;
  Str fn;
  int slen;
  int len;
  
  if (path == (char *)0x0) {
    t0 = (char *)0x0;
  }
  else {
    slen = 0;
    sVar1 = strlen(path);
    d = compression_decoders;
    while ((d->type != 0 &&
           (((d->ext == (char *)0x0 || (slen = strlen(d->ext), (int)sVar1 <= slen)) ||
            (iVar2 = strcasecmp(path + (sVar1 - slen),d->ext), iVar2 != 0))))) {
      d = d + 1;
    }
    if (d->type == 0) {
      t0 = (char *)0x0;
    }
    else {
      s = Strnew_charp(path);
      Strshrink(s,slen);
      if (ext != (char **)0x0) {
        pcVar3 = filename_extension(s->ptr,0);
        *ext = pcVar3;
      }
      t0 = guessContentType(s->ptr);
      if (t0 == (char *)0x0) {
        t0 = "text/plain";
      }
    }
  }
  return t0;
}



int setModtime(char *path,time_t modtime)

{
  int iVar1;
  stat st;
  utimbuf t;
  
  iVar1 = stat(path,(stat *)&st);
  if (iVar1 == 0) {
    t.actime = st.st_atim.tv_sec;
  }
  else {
    t.actime = time((time_t *)0x0);
  }
  t.modtime = modtime;
  iVar1 = utime(path,(utimbuf *)&t);
  return iVar1;
}



void examineFile(char *path,URLFile *uf)

{
  int iVar1;
  InputStream piVar2;
  char *pcVar3;
  stat stbuf;
  char *t0;
  char *ext;
  FILE *fp;
  
  uf->guess_type = (char *)0x0;
  if ((((path == (char *)0x0) || (*path == '\0')) ||
      (iVar1 = stat(path,(stat *)&stbuf), iVar1 == -1)) || ((stbuf.st_mode & 0xf000) != 0x8000)) {
    uf->stream = (InputStream)0x0;
    return;
  }
  iVar1 = open(path,0);
  piVar2 = newInputStream(iVar1);
  uf->stream = piVar2;
  if (do_download != 0) {
    return;
  }
  if ((use_lessopen != 0) && (pcVar3 = getenv("LESSOPEN"), pcVar3 != (char *)0x0)) {
    pcVar3 = guessContentType(path);
    uf->guess_type = pcVar3;
    if (uf->guess_type == (char *)0x0) {
      uf->guess_type = "text/plain";
    }
    iVar1 = is_html_type(uf->guess_type);
    if (iVar1 != 0) {
      return;
    }
    fp = lessopen_stream(path);
    if (fp != (FILE *)0x0) {
      iVar1 = ISclose(uf->stream);
      if (iVar1 == 0) {
        uf->stream = (InputStream)0x0;
      }
      piVar2 = newFileStream(fp,pclose);
      uf->stream = piVar2;
      uf->guess_type = "text/plain";
      return;
    }
  }
  check_compression(path,uf);
  if (uf->compression == 0) {
    return;
  }
  ext = uf->ext;
  pcVar3 = uncompressed_file_type(path,&ext);
  uf->guess_type = pcVar3;
  uf->ext = ext;
  uncompress_stream(uf,(char **)0x0);
  return;
}



int check_command(char *cmd,int auxbin_p)

{
  char *p_00;
  Str x;
  int iVar1;
  stat st;
  Str pathname;
  char *np;
  char *p;
  Str dirs;
  
  if (check_command::path == (char *)0x0) {
    check_command::path = getenv("PATH");
  }
  if (auxbin_p == 0) {
    dirs = Strnew_charp(check_command::path);
  }
  else {
    p_00 = w3m_auxbin_dir();
    dirs = Strnew_charp(p_00);
  }
  p = dirs->ptr;
  while( true ) {
    if (p == (char *)0x0) {
      return 0;
    }
    np = strchr(p,0x3a);
    if (np != (char *)0x0) {
      *np = '\0';
      np = np + 1;
    }
    x = Strnew();
    Strcat_charp(x,p);
    if (x->area_size <= x->length + 1) {
      Strgrow(x);
    }
    iVar1 = x->length;
    x->ptr[iVar1] = '/';
    x->length = iVar1 + 1;
    x->ptr[x->length] = '\0';
    Strcat_charp(x,cmd);
    iVar1 = stat(x->ptr,(stat *)&st);
    if (((iVar1 == 0) && ((st.st_mode & 0xf000) == 0x8000)) && ((st.st_mode & 0x49) != 0)) break;
    p = np;
  }
  return 1;
}



char * acceptableEncoding(void)

{
  GeneralList *tl;
  int iVar1;
  char *pcVar2;
  char *p;
  TextList *l;
  compression_decoder *d;
  
  if (acceptableEncoding::encodings == (Str)0x0) {
    tl = newGeneralList();
    for (d = compression_decoders; d->type != 0; d = d + 1) {
      iVar1 = check_command(d->cmd,d->auxbin_p);
      if (iVar1 != 0) {
        pcVar2 = allocStr(d->encoding,-1);
        pushValue(tl,pcVar2);
      }
    }
    acceptableEncoding::encodings = Strnew();
    while( true ) {
      pcVar2 = (char *)popValue(tl);
      if (pcVar2 == (char *)0x0) break;
      if (acceptableEncoding::encodings->length != 0) {
        Strcat_charp(acceptableEncoding::encodings,", ");
      }
      Strcat_charp(acceptableEncoding::encodings,pcVar2);
    }
    pcVar2 = acceptableEncoding::encodings->ptr;
  }
  else {
    pcVar2 = acceptableEncoding::encodings->ptr;
  }
  return pcVar2;
}



Str convertLine(URLFile *uf,Str line,int mode,wc_ces *charset,wc_ces doc_charset)

{
  Str s;
  
  s = wc_Str_conv_with_detect(line,charset,doc_charset,InnerCharset);
  if (mode != 0) {
    cleanup_line(s,mode);
  }
  if ((uf != (URLFile *)0x0) && (uf->scheme == '\t')) {
    Strchop(s);
  }
  return s;
}



Buffer * loadFile(char *path)

{
  Buffer *pBVar1;
  int iVar2;
  URLFile uf;
  Buffer *buf;
  
  init_stream(&uf,4,(InputStream)0x0);
  examineFile(path,&uf);
  if (uf.stream == (InputStream)0x0) {
    pBVar1 = (Buffer *)0x0;
  }
  else {
    if (showLineNum == 0) {
      iVar2 = 1;
    }
    else {
      iVar2 = 6;
    }
    iVar2 = COLS - iVar2;
    if (iVar2 < 0) {
      iVar2 = 0;
    }
    pBVar1 = newBuffer(iVar2);
    current_content_length._0_4_ = 0;
    current_content_length._4_4_ = 0;
    content_charset = 0;
    pBVar1 = loadSomething(&uf,path,loadBuffer,pBVar1);
    ISclose(uf.stream);
  }
  return pBVar1;
}



int matchattr(char *p,char *attr,int len,Str *value)

{
  bool bVar1;
  int iVar2;
  Str p_Var3;
  char *q;
  int quoted;
  
  q = (char *)0x0;
  iVar2 = strncasecmp(p,attr,len);
  if (iVar2 == 0) {
    p = p + len;
    while ((*p != '\0' && ((MYCTYPE_MAP[(byte)*p] & 2) != 0))) {
      p = p + 1;
    }
    if (value != (Str *)0x0) {
      p_Var3 = Strnew();
      *value = p_Var3;
      if (*p == '=') {
        do {
          p = p + 1;
          if (*p == '\0') break;
        } while ((MYCTYPE_MAP[(byte)*p] & 2) != 0);
        bVar1 = false;
        for (; (((*p != '\0' && (*p != '\r')) && (*p != '\n')) && ((bVar1 || (*p != ';'))));
            p = p + 1) {
          if ((MYCTYPE_MAP[(byte)*p] & 2) == 0) {
            q = p;
          }
          if (*p == '\"') {
            bVar1 = !bVar1;
          }
          else {
            if ((*value)->area_size <= (*value)->length + 1) {
              Strgrow(*value);
            }
            p_Var3 = *value;
            iVar2 = p_Var3->length;
            (*value)->ptr[iVar2] = *p;
            p_Var3->length = iVar2 + 1;
            (*value)->ptr[(*value)->length] = '\0';
          }
        }
        if (q != (char *)0x0) {
          Strshrink(*value,(int)(p + (-1 - (int)q)));
        }
      }
      return 1;
    }
    if (((*p == '\0') || (*p == '\r')) || ((*p == '\n' || (*p == ';')))) {
      return 1;
    }
  }
  return 0;
}



char * xface2xpm(char *xface)

{
  ImageCache *pIVar1;
  int iVar2;
  char *pcVar3;
  char *pcVar4;
  Str p_Var5;
  FILE *__stream;
  stat st;
  Image image;
  FILE *f;
  ImageCache *cache;
  
  while ((*xface != '\0' && ((MYCTYPE_MAP[(byte)*xface] & 2) != 0))) {
    xface = xface + 1;
  }
  image.url = xface;
  image.ext = ".xpm";
  image.width = 0x30;
  image.height = 0x30;
  image.cache = (ImageCache *)0x0;
  pIVar1 = getImage(&image,(ParsedURL *)0x0,2);
  if (((pIVar1->loaded & 1U) != 0) && (iVar2 = stat(pIVar1->file,(stat *)&st), iVar2 == 0)) {
    return pIVar1->file;
  }
  pIVar1->loaded = '\x02';
  pcVar3 = shell_quote(pIVar1->file);
  pcVar4 = auxbinFile("xface2xpm");
  pcVar4 = shell_quote(pcVar4);
  p_Var5 = Sprintf("%s > %s",pcVar4,pcVar3);
  __stream = popen(p_Var5->ptr,"w");
  if (__stream == (FILE *)0x0) {
    pcVar3 = (char *)0x0;
  }
  else {
    fputs(xface,__stream);
    pclose(__stream);
    iVar2 = stat(pIVar1->file,(stat *)&st);
    if ((iVar2 == 0) && (st.st_size != 0)) {
      pIVar1->loaded = '\x05';
      pIVar1->index = 0;
      pcVar3 = pIVar1->file;
    }
    else {
      pcVar3 = (char *)0x0;
    }
  }
  return pcVar3;
}



void readHeader(URLFile *uf,Buffer *newBuf,int thru,ParsedURL *pu)

{
  wc_ces doc_charset;
  bool bVar1;
  byte bVar2;
  TextList *pTVar3;
  Str p_Var4;
  wc_ces *charset_00;
  InputStream stream;
  int iVar5;
  size_t __n;
  time_t tVar6;
  long lVar7;
  char *pcVar8;
  URLFile f;
  int f_1;
  Str funcname;
  Str msg;
  char *ans;
  int err;
  time_t expires;
  int flag;
  int quoted;
  int version;
  Str tmp2;
  Str port;
  Str commentURL;
  Str comment;
  Str path;
  Str domain;
  Str value;
  Str name;
  char **e;
  compression_decoder *d;
  wc_ces old_charset;
  Line *l;
  Str src_1;
  FILE *ff;
  Lineprop *propBuffer;
  FILE *src;
  char *tmpf;
  wc_ces mime_charset;
  wc_ces charset;
  TextList *headerlist;
  Str tmp;
  Str lineBuf2;
  char *emsg;
  char *q;
  char *p;
  char c;
  
  lineBuf2 = (Str)0x0;
  charset = 0x100;
  src = (FILE *)0x0;
  pTVar3 = (TextList *)newGeneralList();
  newBuf->document_header = pTVar3;
  headerlist = newBuf->document_header;
  if (uf->scheme == '\0') {
    http_response_code = -1;
  }
  else {
    http_response_code = 0;
  }
  if (((thru != 0) && (newBuf->header_source == (char *)0x0)) && (image_source == (char *)0x0)) {
    p_Var4 = tmpfname(0,(char *)0x0);
    tmpf = p_Var4->ptr;
    src = (FILE *)fopen(tmpf,"w");
    if ((FILE *)src != (FILE *)0x0) {
      newBuf->header_source = tmpf;
    }
  }
LAB_0805cae0:
  do {
    tmp = StrmyISgets(uf->stream);
    if (tmp->length == 0) {
LAB_0805caff:
      if (thru != 0) {
        addnewline(newBuf,"",propBuffer,(Linecolor *)0x0,0,-1,-1);
      }
      if (src != (FILE *)0x0) {
        fclose((FILE *)src);
      }
      return;
    }
    if ((uf->scheme == '\t') && (*tmp->ptr == '.')) {
      Strdelete(tmp,0,1);
    }
    if (w3m_reqlog != (char *)0x0) {
      ff = (FILE *)fopen(w3m_reqlog,"a");
      fwrite(tmp->ptr,1,tmp->length,(FILE *)ff);
      fclose((FILE *)ff);
    }
    if (src != (FILE *)0x0) {
      fwrite(tmp->ptr,1,tmp->length,(FILE *)src);
    }
    cleanup_line(tmp,3);
    if (((*tmp->ptr == '\n') || (*tmp->ptr == '\r')) || (*tmp->ptr == '\0')) {
      if (lineBuf2 != (Str)0x0) goto LAB_0805bd3a;
      goto LAB_0805caff;
    }
    if ((w3m_dump & 2U) != 0) {
      lineBuf2 = tmp;
      goto LAB_0805bd3a;
    }
    if (lineBuf2 == (Str)0x0) {
      lineBuf2 = tmp;
    }
    else {
      Strcat(lineBuf2,tmp);
    }
    iVar5 = ISgetc(uf->stream);
    c = (char)iVar5;
    ISundogetc(uf->stream);
  } while ((c == ' ') || (c == '\t'));
  lineBuf2 = decodeMIME(lineBuf2,&mime_charset);
  if (mime_charset == 0) {
    charset_00 = &charset;
    doc_charset = DocumentCharset;
  }
  else {
    charset_00 = &mime_charset;
    doc_charset = mime_charset;
  }
  lineBuf2 = convertLine((URLFile *)0x0,lineBuf2,0,charset_00,doc_charset);
  tmp = Strnew_size(lineBuf2->length);
  p = lineBuf2->ptr;
  while (*p != '\0') {
    for (q = p; ((*q != '\0' && (*q != '\r')) && (*q != '\n')); q = q + 1) {
    }
    p_Var4 = Strnew_charp_n(p,(int)q - (int)p);
    lineBuf2 = checkType(p_Var4,&propBuffer,(Linecolor **)0x0);
    Strcat(tmp,lineBuf2);
    if (thru != 0) {
      if (FoldLine == 0) {
        iVar5 = -1;
      }
      else {
        if (showLineNum == 0) {
          iVar5 = 1;
        }
        else {
          iVar5 = 6;
        }
        iVar5 = COLS - iVar5;
        if (iVar5 < 0) {
          iVar5 = 0;
        }
        iVar5 = iVar5 + 1;
      }
      addnewline(newBuf,lineBuf2->ptr,propBuffer,(Linecolor *)0x0,lineBuf2->length,iVar5,-1);
    }
    for (; (*q != '\0' && ((*q == '\r' || (*q == '\n')))); q = q + 1) {
    }
    p = q;
  }
  if (((thru != 0) && (activeImage != 0)) && (displayImage != 0)) {
    src_1 = (Str)0x0;
    iVar5 = strncasecmp(tmp->ptr,"X-Image-URL:",0xc);
    if (iVar5 == 0) {
      tmpf = tmp->ptr + 0xc;
      while ((*tmpf != '\0' && ((MYCTYPE_MAP[(byte)*tmpf] & 2) != 0))) {
        tmpf = tmpf + 1;
      }
      pcVar8 = html_quote(tmpf);
      src_1 = Strnew_m_charp("<img src=\"",pcVar8,"\" alt=\"X-Image-URL\">",0);
    }
    else {
      iVar5 = strncasecmp(tmp->ptr,"X-Face:",7);
      if ((iVar5 == 0) && (tmpf = xface2xpm(tmp->ptr + 7), tmpf != (char *)0x0)) {
        pcVar8 = html_quote(tmpf);
        src_1 = Strnew_m_charp("<img src=\"file:",pcVar8,"\" alt=\"X-Face\""," width=48 height=48>",
                               0);
      }
    }
    if (src_1 != (Str)0x0) {
      old_charset = newBuf->document_charset;
      stream = newStrStream(src_1);
      init_stream(&f,4,stream);
      loadHTMLstream(&f,newBuf,(FILE *)0x0,1);
      for (l = newBuf->lastLine; (l != (Line *)0x0 && (l->real_linenumber != 0)); l = l->prev) {
        l->real_linenumber = 0;
      }
      newBuf->document_charset = old_charset;
    }
  }
  lineBuf2 = tmp;
LAB_0805bd3a:
  if ((uf->scheme == '\0') && (http_response_code == -1)) {
    p = lineBuf2->ptr;
    while ((*p != '\0' && ((MYCTYPE_MAP[(byte)*p] & 2) == 0))) {
      p = p + 1;
    }
    while ((*p != '\0' && ((MYCTYPE_MAP[(byte)*p] & 2) != 0))) {
      p = p + 1;
    }
    http_response_code = atoi(p);
    if (fmInitialized != '\0') {
      message(lineBuf2->ptr,0,0);
      refresh();
    }
  }
  iVar5 = strncasecmp(lineBuf2->ptr,"content-transfer-encoding:",0x1a);
  if (iVar5 == 0) {
    p = lineBuf2->ptr + 0x1a;
    while ((MYCTYPE_MAP[(byte)*p] & 2) != 0) {
      p = p + 1;
    }
    iVar5 = strncasecmp(p,"base64",6);
    if (iVar5 == 0) {
      uf->encoding = '\x01';
    }
    else {
      iVar5 = strncasecmp(p,"quoted-printable",0x10);
      if (iVar5 == 0) {
        uf->encoding = '\x02';
      }
      else {
        iVar5 = strncasecmp(p,"uuencode",8);
        if ((iVar5 == 0) || (iVar5 = strncasecmp(p,"x-uuencode",10), iVar5 == 0)) {
          uf->encoding = '\x03';
        }
        else {
          uf->encoding = '\0';
        }
      }
    }
  }
  else {
    iVar5 = strncasecmp(lineBuf2->ptr,"content-encoding:",0x11);
    if (iVar5 == 0) {
      p = lineBuf2->ptr + 0x11;
      while ((MYCTYPE_MAP[(byte)*p] & 2) != 0) {
        p = p + 1;
      }
      uf->compression = 0;
      for (d = compression_decoders; d->type != 0; d = d + 1) {
        for (e = d->encodings; *e != (char *)0x0; e = e + 1) {
          __n = strlen(*e);
          iVar5 = strncasecmp(p,*e,__n);
          if (iVar5 == 0) {
            uf->compression = d->type;
            break;
          }
        }
        if (uf->compression != 0) break;
      }
      uf->content_encoding = uf->compression;
    }
    else if (((((use_cookie == 0) || (accept_cookie == 0)) || (pu == (ParsedURL *)0x0)) ||
             (iVar5 = check_cookie_accept_domain(pu->host), iVar5 == 0)) ||
            ((iVar5 = strncasecmp(lineBuf2->ptr,"Set-Cookie:",0xb), iVar5 != 0 &&
             (iVar5 = strncasecmp(lineBuf2->ptr,"Set-Cookie2:",0xc), iVar5 != 0)))) {
      iVar5 = strncasecmp(lineBuf2->ptr,"w3m-control:",0xc);
      if ((iVar5 == 0) && (uf->scheme == '\x05')) {
        p_Var4 = Strnew();
        p = lineBuf2->ptr + 0xc;
        while ((*p != '\0' && ((MYCTYPE_MAP[(byte)*p] & 2) != 0))) {
          p = p + 1;
        }
        while ((*p != '\0' && ((MYCTYPE_MAP[(byte)*p] & 2) == 0))) {
          if (p_Var4->area_size <= p_Var4->length + 1) {
            Strgrow(p_Var4);
          }
          iVar5 = p_Var4->length;
          p_Var4->ptr[iVar5] = *p;
          p_Var4->length = iVar5 + 1;
          p = p + 1;
          p_Var4->ptr[p_Var4->length] = '\0';
        }
        while ((*p != '\0' && ((MYCTYPE_MAP[(byte)*p] & 2) != 0))) {
          p = p + 1;
        }
        iVar5 = getFuncList(p_Var4->ptr);
        if (-1 < iVar5) {
          tmp = Strnew_charp(p);
          Strchop(tmp);
          pushEvent(iVar5,tmp->ptr);
        }
      }
    }
    else {
      name = Strnew();
      value = Strnew();
      domain = (Str)0x0;
      path = (Str)0x0;
      comment = (Str)0x0;
      commentURL = (Str)0x0;
      port = (Str)0x0;
      flag = 0;
      expires = -1;
      q = (char *)0x0;
      if (lineBuf2->ptr[10] == '2') {
        p = lineBuf2->ptr + 0xc;
        version = 1;
      }
      else {
        p = lineBuf2->ptr + 0xb;
        version = 0;
      }
      while ((*p != '\0' && ((MYCTYPE_MAP[(byte)*p] & 2) != 0))) {
        p = p + 1;
      }
      while ((((*p != '=' && (*p != '\0')) && (*p != '\r')) && ((*p != '\n' && (*p != ';'))))) {
        if (name->area_size <= name->length + 1) {
          Strgrow(name);
        }
        iVar5 = name->length;
        name->ptr[iVar5] = *p;
        name->length = iVar5 + 1;
        p = p + 1;
        name->ptr[name->length] = '\0';
      }
      Strremovetrailingspaces(name);
      if (*p == '=') {
        do {
          p = p + 1;
          if (*p == '\0') break;
        } while ((MYCTYPE_MAP[(byte)*p] & 2) != 0);
        bVar1 = false;
        while (((*p != '\0' && (*p != '\r')) && ((*p != '\n' && ((bVar1 || (*p != ';'))))))) {
          if ((MYCTYPE_MAP[(byte)*p] & 2) == 0) {
            q = p;
          }
          if (*p == '\"') {
            bVar1 = !bVar1;
          }
          if (value->area_size <= value->length + 1) {
            Strgrow(value);
          }
          iVar5 = value->length;
          value->ptr[iVar5] = *p;
          value->length = iVar5 + 1;
          p = p + 1;
          value->ptr[value->length] = '\0';
        }
        if (q != (char *)0x0) {
          Strshrink(value,(int)(p + (-1 - (int)q)));
        }
      }
      while (*p == ';') {
        do {
          p = p + 1;
          if (*p == '\0') break;
        } while ((MYCTYPE_MAP[(byte)*p] & 2) != 0);
        iVar5 = matchattr(p,"expires",7,&tmp2);
        if (iVar5 == 0) {
          iVar5 = matchattr(p,"max-age",7,&tmp2);
          if (iVar5 == 0) {
            iVar5 = matchattr(p,"domain",6,&tmp2);
            if (iVar5 == 0) {
              iVar5 = matchattr(p,"path",4,&tmp2);
              if (iVar5 == 0) {
                iVar5 = matchattr(p,"secure",6,(Str *)0x0);
                if (iVar5 == 0) {
                  iVar5 = matchattr(p,"comment",7,&tmp2);
                  if (iVar5 == 0) {
                    iVar5 = matchattr(p,"version",7,&tmp2);
                    if (iVar5 == 0) {
                      iVar5 = matchattr(p,"port",4,&tmp2);
                      if (iVar5 == 0) {
                        iVar5 = matchattr(p,"commentURL",10,&tmp2);
                        if (iVar5 == 0) {
                          iVar5 = matchattr(p,"discard",7,(Str *)0x0);
                          if (iVar5 != 0) {
                            flag = flag | 0x10;
                          }
                        }
                        else {
                          commentURL = tmp2;
                        }
                      }
                      else {
                        port = tmp2;
                      }
                    }
                    else {
                      version = atoi(tmp2->ptr);
                    }
                  }
                  else {
                    comment = tmp2;
                  }
                }
                else {
                  flag = flag | 2;
                }
              }
              else {
                path = tmp2;
              }
            }
            else {
              domain = tmp2;
            }
          }
          else {
            tVar6 = time((time_t *)0x0);
            lVar7 = atol(tmp2->ptr);
            expires = tVar6 + lVar7;
          }
        }
        else {
          expires = mymktime(tmp2->ptr);
        }
        bVar1 = false;
        for (; (((*p != '\0' && (*p != '\r')) && (*p != '\n')) && ((bVar1 || (*p != ';'))));
            p = p + 1) {
          if (*p == '\"') {
            bVar1 = !bVar1;
          }
        }
      }
      if ((pu != (ParsedURL *)0x0) && (0 < name->length)) {
        if (show_cookie != 0) {
          if ((flag & 2U) == 0) {
            p_Var4 = Sprintf("Received cookie: %s=%s",name->ptr,value->ptr);
            disp_message_nsec(p_Var4->ptr,0,1,1,0);
          }
          else {
            disp_message_nsec("Received a secured cookie",0,1,1,0);
          }
        }
        err = add_cookie(pu,name,value,expires,domain,path,flag,comment,version,port,commentURL);
        if (err != 0) {
          if (accept_bad_cookie == 1) {
            ans = "y";
          }
          else {
            ans = (char *)0x0;
          }
          if (((fmInitialized != '\0') && ((err & 0x20U) != 0)) && (accept_bad_cookie == 2)) {
            if ((domain == (Str)0x0) || (domain->ptr == (char *)0x0)) {
              pcVar8 = "<localdomain>";
            }
            else {
              pcVar8 = domain->ptr;
            }
            p_Var4 = Sprintf("Accept bad cookie from %s for %s?",pu->host,pcVar8);
            if (COLS + -10 < p_Var4->length) {
              Strshrink(p_Var4,p_Var4->length + (10 - COLS));
            }
            Strcat_charp(p_Var4," (y/n)");
            ans = inputAnswer(p_Var4->ptr);
          }
          if (ans != (char *)0x0) {
            if ((MYCTYPE_MAP[(byte)*ans] & 4) == 0) {
              bVar2 = *ans;
            }
            else {
              bVar2 = *ans | 0x20;
            }
            if ((bVar2 == 0x79) &&
               (err = add_cookie(pu,name,value,expires,domain,path,flag | 0x20,comment,version,port,
                                 commentURL), err == 0)) {
              if (show_cookie != 0) {
                p_Var4 = Sprintf("Accepting invalid cookie: %s=%s",name->ptr,value->ptr);
                disp_message_nsec(p_Var4->ptr,0,1,1,0);
              }
              goto LAB_0805ca92;
            }
          }
          iVar5 = (err & 0xffffffdfU) - 1;
          if ((iVar5 < 0) || (8 < iVar5)) {
            emsg = "This cookie was rejected to prevent security violation.";
          }
          else {
            p_Var4 = Sprintf("This cookie was rejected to prevent security violation. [%s]",
                             violations[iVar5]);
            emsg = p_Var4->ptr;
          }
          record_err_message(emsg);
          if (show_cookie != 0) {
            disp_message_nsec(emsg,0,1,1,0);
          }
        }
      }
    }
  }
LAB_0805ca92:
  if (headerlist != (TextList *)0x0) {
    pcVar8 = allocStr(lineBuf2->ptr,-1);
    pushValue((GeneralList *)headerlist,pcVar8);
  }
  Strfree(lineBuf2);
  lineBuf2 = (Str)0x0;
  goto LAB_0805cae0;
}



char * checkHeader(Buffer *buf,char *field)

{
  size_t __n;
  int iVar1;
  char *pcVar2;
  char *p;
  TextListItem *i;
  int len;
  
  if (((buf != (Buffer *)0x0) && (field != (char *)0x0)) &&
     (buf->document_header != (TextList *)0x0)) {
    __n = strlen(field);
    for (i = buf->document_header->first; i != (TextListItem *)0x0; i = i->next) {
      iVar1 = strncasecmp(i->ptr,field,__n);
      if (iVar1 == 0) {
        pcVar2 = remove_space(i->ptr + __n);
        return pcVar2;
      }
    }
  }
  return (char *)0x0;
}



char * checkContentType(Buffer *buf)

{
  int iVar1;
  char *pcVar2;
  Str x;
  Str r;
  char *p;
  
  p = checkHeader(buf,"Content-Type:");
  if (p == (char *)0x0) {
    pcVar2 = (char *)0x0;
  }
  else {
    x = Strnew();
    while (((*p != '\0' && (*p != ';')) && ((MYCTYPE_MAP[(byte)*p] & 2) == 0))) {
      if (x->area_size <= x->length + 1) {
        Strgrow(x);
      }
      iVar1 = x->length;
      x->ptr[iVar1] = *p;
      x->length = iVar1 + 1;
      p = p + 1;
      x->ptr[x->length] = '\0';
    }
    pcVar2 = strcasestr(p,"charset");
    if (pcVar2 != (char *)0x0) {
      p = pcVar2 + 7;
      while ((*p != '\0' && ((MYCTYPE_MAP[(byte)*p] & 2) != 0))) {
        p = p + 1;
      }
      if (*p == '=') {
        do {
          pcVar2 = p;
          p = pcVar2 + 1;
          if (*p == '\0') break;
        } while ((MYCTYPE_MAP[(byte)*p] & 2) != 0);
        if (*p == '\"') {
          p = pcVar2 + 2;
        }
        content_charset = wc_guess_charset(p,0);
      }
    }
    pcVar2 = x->ptr;
  }
  return pcVar2;
}



int skip_auth_token(char **pp)

{
  int typ;
  int first;
  char *p;
  
  first = 0;
  p = *pp;
  do {
    switch(*p) {
    case '\0':
endoftoken:
      *pp = p;
      return first;
    default:
      if ((byte)*p < 0x20) goto switchD_0805cd85_caseD_9;
      typ = 2;
      break;
    case '\t':
    case ' ':
    case '\"':
    case '(':
    case ')':
    case ',':
    case '/':
    case ':':
    case ';':
    case '<':
    case '=':
    case '>':
    case '?':
    case '@':
    case '[':
    case '\\':
    case ']':
    case '\x7f':
switchD_0805cd85_caseD_9:
      typ = 1;
    }
    if (first == 0) {
      first = typ;
    }
    else if (first != typ) goto endoftoken;
    p = p + 1;
  } while( true );
}



Str extract_auth_val(char **q)

{
  int iVar1;
  bool bVar2;
  Str x;
  Str val;
  int quoted;
  uchar *qq;
  
  qq = (uchar *)*q;
  bVar2 = false;
  x = Strnew();
  while ((*qq != '\0' && ((MYCTYPE_MAP[*qq] & 2) != 0))) {
    qq = qq + 1;
  }
  if (*qq == '\"') {
    bVar2 = true;
    if (x->area_size <= x->length + 1) {
      Strgrow(x);
    }
    iVar1 = x->length;
    x->ptr[iVar1] = *qq;
    x->length = iVar1 + 1;
    qq = qq + 1;
    x->ptr[x->length] = '\0';
  }
  do {
    if (*qq == '\0') {
end_token:
      *q = (char *)qq;
      return x;
    }
    if ((bVar2) && (*qq == '\"')) {
      if (x->area_size <= x->length + 1) {
        Strgrow(x);
      }
      iVar1 = x->length;
      x->ptr[iVar1] = *qq;
      x->length = iVar1 + 1;
      qq = qq + 1;
      x->ptr[x->length] = '\0';
      goto end_token;
    }
    if (bVar2) {
      if ((bVar2) && (*qq == '\\')) {
        if (x->area_size <= x->length + 1) {
          Strgrow(x);
        }
        iVar1 = x->length;
        x->ptr[iVar1] = *qq;
        x->length = iVar1 + 1;
        qq = qq + 1;
        x->ptr[x->length] = '\0';
      }
    }
    else {
      switch(*qq) {
      case '\t':
      case ' ':
      case '\"':
      case '(':
      case ')':
      case '/':
      case ':':
      case ';':
      case '<':
      case '=':
      case '>':
      case '?':
      case '@':
      case '[':
      case '\\':
      case ']':
        qq = qq + 1;
        goto end_token;
      default:
        if ((*qq < 0x20) || (*qq == '\x7f')) {
          qq = qq + 1;
        }
        break;
      case ',':
        goto end_token;
      }
    }
    if (x->area_size <= x->length + 1) {
      Strgrow(x);
    }
    iVar1 = x->length;
    x->ptr[iVar1] = *qq;
    x->length = iVar1 + 1;
    qq = qq + 1;
    x->ptr[x->length] = '\0';
  } while( true );
}



Str qstr_unquote(Str s)

{
  char *pcVar1;
  int iVar2;
  Str tmp;
  char *p;
  
  if (s == (Str)0x0) {
    s = (Str)0x0;
  }
  else {
    pcVar1 = s->ptr;
    if (*pcVar1 == '\"') {
      s = Strnew();
      while (p = pcVar1 + 1, *p != '\0') {
        if (*p == '\\') {
          p = pcVar1 + 2;
        }
        if (s->area_size <= s->length + 1) {
          Strgrow(s);
        }
        iVar2 = s->length;
        s->ptr[iVar2] = *p;
        s->length = iVar2 + 1;
        s->ptr[s->length] = '\0';
        pcVar1 = p;
      }
      if ((0 < s->length) && (s->ptr[s->length + -1] == '\"')) {
        Strshrink(s,1);
      }
    }
  }
  return s;
}



char * extract_auth_param(char *q,auth_param *auth)

{
  char *pcVar1;
  size_t __n;
  Str p_Var2;
  int iVar3;
  int token_type;
  size_t len;
  char *p;
  auth_param *ap;
  
  for (ap = auth; ap->name != (char *)0x0; ap = ap + 1) {
    ap->val = (Str)0x0;
  }
  do {
    if (*q == '\0') {
      return q;
    }
    while ((*q != '\0' && ((MYCTYPE_MAP[(byte)*q] & 2) != 0))) {
      q = q + 1;
    }
    ap = auth;
    while( true ) {
      if (ap->name == (char *)0x0) goto LAB_0805d21c;
      __n = strlen(ap->name);
      iVar3 = strncasecmp(q,ap->name,__n);
      if ((iVar3 == 0) && (((MYCTYPE_MAP[(byte)q[__n]] & 2) != 0 || (q[__n] == '=')))) break;
      ap = ap + 1;
    }
    p = q + __n;
    while ((*p != '\0' && ((MYCTYPE_MAP[(byte)*p] & 2) != 0))) {
      p = p + 1;
    }
    if (*p != '=') {
      return q;
    }
    q = p + 1;
    p_Var2 = extract_auth_val(&q);
    ap->val = p_Var2;
LAB_0805d21c:
    pcVar1 = q;
    if (ap->name == (char *)0x0) {
      iVar3 = skip_auth_token(&q);
      if (iVar3 != 2) {
        return pcVar1;
      }
      if (((MYCTYPE_MAP[(byte)*q] & 2) == 0) && (*q != '=')) {
        return pcVar1;
      }
      while ((*q != '\0' && ((MYCTYPE_MAP[(byte)*q] & 2) != 0))) {
        q = q + 1;
      }
      if (*q != '=') {
        return pcVar1;
      }
      q = q + 1;
      extract_auth_val(&q);
    }
    if (*q != '\0') {
      while ((*q != '\0' && ((MYCTYPE_MAP[(byte)*q] & 2) != 0))) {
        q = q + 1;
      }
      if (*q != ',') {
        return q;
      }
      q = q + 1;
    }
  } while( true );
}



Str get_auth_param(auth_param *auth,char *name)

{
  int iVar1;
  auth_param *ap;
  
  ap = auth;
  while( true ) {
    if (ap->name == (char *)0x0) {
      return (Str)0x0;
    }
    iVar1 = strcasecmp(name,ap->name);
    if (iVar1 == 0) break;
    ap = ap + 1;
  }
  return ap->val;
}



Str AuthBasicCred(http_auth *ha,Str uname,Str pw,ParsedURL *pu,HRequest *hr,FormList *request)

{
  int iVar1;
  Str p_Var2;
  Str s;
  
  p_Var2 = Strdup(uname);
  if (p_Var2->area_size <= p_Var2->length + 1) {
    Strgrow(p_Var2);
  }
  iVar1 = p_Var2->length;
  p_Var2->ptr[iVar1] = ':';
  p_Var2->length = iVar1 + 1;
  p_Var2->ptr[p_Var2->length] = '\0';
  Strcat(p_Var2,pw);
  p_Var2 = encodeB(p_Var2->ptr);
  p_Var2 = Strnew_m_charp("Basic ",p_Var2->ptr,0);
  return p_Var2;
}



http_auth * findAuthentication(http_auth *hauth,Buffer *buf,char *auth_field)

{
  int iVar1;
  int token_type;
  char *p;
  char *p0;
  TextListItem *i;
  int slen;
  int len;
  http_auth *ha;
  
  len = strlen(auth_field);
  bzero(hauth,0x10);
  i = buf->document_header->first;
  do {
    if (i == (TextListItem *)0x0) {
      if (hauth->scheme == (char *)0x0) {
        hauth = (http_auth *)0x0;
      }
      return hauth;
    }
    iVar1 = strncasecmp(i->ptr,auth_field,len);
    if (iVar1 == 0) {
      p = i->ptr + len;
      while ((p != (char *)0x0 && (*p != '\0'))) {
        while ((*p != '\0' && ((MYCTYPE_MAP[(byte)*p] & 2) != 0))) {
          p = p + 1;
        }
        p0 = p;
        for (ha = www_auth; ha->scheme != (char *)0x0; ha = ha + 1) {
          slen = strlen(ha->scheme);
          iVar1 = strncasecmp(p,ha->scheme,slen);
          if (iVar1 == 0) {
            p = p + slen;
            while ((*p != '\0' && ((MYCTYPE_MAP[(byte)*p] & 2) != 0))) {
              p = p + 1;
            }
            if (hauth->pri < ha->pri) {
              hauth->pri = ha->pri;
              hauth->scheme = ha->scheme;
              hauth->param = ha->param;
              hauth->cred = ha->cred;
              p = extract_auth_param(p,hauth->param);
              break;
            }
            p = extract_auth_param(p,none_auth_param);
          }
        }
        if (p0 == p) {
          iVar1 = skip_auth_token(&p);
          if ((iVar1 != 2) || ((MYCTYPE_MAP[(byte)*p] & 2) == 0)) break;
          while ((*p != '\0' && ((MYCTYPE_MAP[(byte)*p] & 2) != 0))) {
            p = p + 1;
          }
          p = extract_auth_param(p,none_auth_param);
        }
      }
    }
    i = i->next;
  } while( true );
}



void getAuthCookie(http_auth *hauth,char *auth_header,TextList *extra_header,ParsedURL *pu,
                  HRequest *hr,FormList *request,Str *uname,Str *pwd)

{
  bool bVar1;
  wc_ces wVar2;
  wc_ces wVar3;
  size_t __n;
  Str p_Var4;
  int iVar5;
  uint is_proxy;
  char *pcVar6;
  Str x;
  char *pp;
  int proxy;
  char *realm;
  int auth_header_len;
  int a_found;
  TextListItem *i;
  Str tmp;
  Str ss;
  
  __n = strlen(auth_header);
  realm = (char *)0x0;
  if (hauth != (http_auth *)0x0) {
    p_Var4 = get_auth_param(hauth->param,"realm");
    p_Var4 = qstr_unquote(p_Var4);
    realm = p_Var4->ptr;
  }
  if (realm == (char *)0x0) {
    return;
  }
  bVar1 = false;
  i = extra_header->first;
  do {
    if (i == (TextListItem *)0x0) {
LAB_0805d6e1:
      iVar5 = strncasecmp("Proxy-Authorization:",auth_header,__n);
      is_proxy = (uint)(iVar5 == 0);
      if (bVar1) {
        if (fmInitialized == '\0') {
          fwrite("Wrong username or password\n",1,0x1b,stderr);
        }
        else {
          message("Wrong username or password",0,0);
          refresh();
        }
        sleep(1);
        delValue((GeneralList *)extra_header,(ListItem *)i);
        invalidate_auth_user_passwd(pu,realm,*uname,*pwd,is_proxy);
      }
      *uname = (Str)0x0;
      *pwd = (Str)0x0;
      if ((bVar1) || (iVar5 = find_auth_user_passwd(pu,realm,uname,pwd,is_proxy), iVar5 == 0)) {
        if (QuietMessage != '\0') {
          return;
        }
        sleep(2);
        if (fmInitialized == '\0') {
          iVar5 = feof(stdin);
          if ((iVar5 != 0) || (iVar5 = ferror(stdin), iVar5 != 0)) {
            fprintf(stderr,"w3m: Authorization required for %s\n",realm);
                    // WARNING: Subroutine does not return
            exit(1);
          }
          if (is_proxy == 0) {
            pcVar6 = "Username for %s: ";
          }
          else {
            pcVar6 = "Proxy Username for %s: ";
          }
          printf(pcVar6,realm);
          fflush(stdout);
          p_Var4 = Strfgets((FILE *)stdin);
          *uname = p_Var4;
          Strchop(*uname);
          if (is_proxy == 0) {
            pcVar6 = "Password: ";
          }
          else {
            pcVar6 = "Proxy Password: ";
          }
          pcVar6 = getpass(pcVar6);
          p_Var4 = Strnew_charp(pcVar6);
          *pwd = p_Var4;
        }
        else {
          term_raw();
          p_Var4 = Sprintf("Username for %s: ",realm);
          pcVar6 = inputLineHistSearch(p_Var4->ptr,(char *)0x0,0x10,(Hist *)0x0,
                                       (anon_subr_int_int_Str_Lineprop_ptr *)0x0);
          wVar3 = SystemCharset;
          wVar2 = InnerCharset;
          if (pcVar6 == (char *)0x0) {
            return;
          }
          p_Var4 = Strnew_charp(pcVar6);
          p_Var4 = wc_Str_conv_strict(p_Var4,wVar2,wVar3);
          *uname = p_Var4;
          p_Var4 = Sprintf("Password for %s: ",realm);
          pcVar6 = inputLineHistSearch(p_Var4->ptr,(char *)0x0,0x40,(Hist *)0x0,
                                       (anon_subr_int_int_Str_Lineprop_ptr *)0x0);
          wVar3 = SystemCharset;
          wVar2 = InnerCharset;
          if (pcVar6 == (char *)0x0) {
            *uname = (Str)0x0;
            return;
          }
          p_Var4 = Strnew_charp(pcVar6);
          p_Var4 = wc_Str_conv_strict(p_Var4,wVar2,wVar3);
          *pwd = p_Var4;
          term_cbreak();
        }
      }
      p_Var4 = (*hauth->cred)(hauth,*uname,*pwd,pu,hr,request);
      if (p_Var4 == (Str)0x0) {
        *uname = (Str)0x0;
        *pwd = (Str)0x0;
      }
      else {
        x = Strnew_charp(auth_header);
        Strcat_m_charp(x,&DAT_080c96f3,p_Var4->ptr,&DAT_080c96f0,0);
        pcVar6 = allocStr(x->ptr,-1);
        pushValue((GeneralList *)extra_header,pcVar6);
      }
      return;
    }
    iVar5 = strncasecmp(i->ptr,auth_header,__n);
    if (iVar5 == 0) {
      bVar1 = true;
      goto LAB_0805d6e1;
    }
    i = i->next;
  } while( true );
}



int same_url_p(ParsedURL *pu1,ParsedURL *pu2)

{
  int iVar1;
  
  if ((((pu1->scheme == pu2->scheme) && (pu1->port == pu2->port)) &&
      ((pu1->host == (char *)0x0 ||
       ((pu2->host != (char *)0x0 && (iVar1 = strcasecmp(pu1->host,pu2->host), iVar1 == 0)))))) &&
     ((pu1->file == (char *)0x0 ||
      ((pu2->file != (char *)0x0 && (iVar1 = strcmp(pu1->file,pu2->file), iVar1 == 0)))))) {
    return 1;
  }
  return 0;
}



int checkRedirection(ParsedURL *pu)

{
  Str p_Var1;
  int iVar2;
  Str tmp;
  
  if (pu == (ParsedURL *)0x0) {
    checkRedirection::nredir = 0;
    checkRedirection::nredir_size = 0;
    checkRedirection::puv = (ParsedURL *)0x0;
    return 1;
  }
  if (checkRedirection::nredir < FollowRedirection) {
    if ((0 < checkRedirection::nredir_size) &&
       ((iVar2 = same_url_p(pu,checkRedirection::puv +
                               (checkRedirection::nredir + -1) % checkRedirection::nredir_size),
        iVar2 != 0 ||
        (((checkRedirection::nredir & 1U) == 0 &&
         (iVar2 = same_url_p(pu,checkRedirection::puv +
                                (checkRedirection::nredir / 2) % checkRedirection::nredir_size),
         iVar2 != 0)))))) {
      p_Var1 = parsedURL2Str(pu);
      p_Var1 = Sprintf("Redirection loop detected (%s)",p_Var1->ptr);
      disp_err_message(p_Var1->ptr,0);
      return 0;
    }
    if (checkRedirection::puv == (ParsedURL *)0x0) {
      checkRedirection::nredir_size = FollowRedirection / 2 + 1;
      checkRedirection::puv = (ParsedURL *)GC_malloc(checkRedirection::nredir_size * 0x28);
      memset(checkRedirection::puv,0,checkRedirection::nredir_size * 0x28);
    }
    copyParsedURL(checkRedirection::puv + checkRedirection::nredir % checkRedirection::nredir_size,
                  pu);
    checkRedirection::nredir = checkRedirection::nredir + 1;
    return 1;
  }
  p_Var1 = parsedURL2Str(pu);
  p_Var1 = Sprintf("Number of redirections exceeded %d at %s",FollowRedirection,p_Var1->ptr);
  disp_err_message(p_Var1->ptr,0);
  return 0;
}



// WARNING: Could not reconcile some variable overlaps

Buffer * loadGeneralFile(char *path,ParsedURL *current,char *referer,int flag,FormList *request)

{
  char cVar1;
  wc_ces wVar2;
  wc_ces wVar3;
  Str uname_00;
  Str p_Var4;
  http_auth *phVar5;
  ParsedURL *pu_00;
  FILE *__s;
  Str p_Var6;
  int iVar7;
  char *pcVar8;
  mailcap *pmVar9;
  Anchor *pAVar10;
  Line *pLVar11;
  Buffer *pBVar12;
  uint local_16c;
  InputStream local_168;
  char *local_164;
  int local_160;
  int local_15c;
  char *local_158;
  char *local_154;
  time_t local_150;
  stat st;
  ParsedURL pu;
  URLFile f;
  HRequest hr;
  URLOption url_option;
  int l;
  Anchor *a;
  Str s_1;
  Buffer *b_1;
  char *file_1;
  char *file;
  Str s;
  FILE *src;
  char *t1;
  Str cmd;
  ParsedURL *auth_pu;
  wc_ces charset;
  Str page;
  Str tmp;
  int add_auth_cookie_flag;
  Str realm;
  Str pwd;
  Str uname;
  TextList *extra_header;
  anon_subr_void_int *prevtrap;
  int searchHeader_through;
  int searchHeader;
  Buffer *t_buf;
  char *real_type;
  char *p;
  char *t;
  char *tpath;
  anon_subr_Buffer_ptr_varargs *proc;
  Buffer *b;
  URLFile *of;
  uchar status;
  
  of = (URLFile *)0x0;
  b = (Buffer *)0x0;
  proc = loadBuffer;
  t = "text/plain";
  real_type = (char *)0x0;
  t_buf = (Buffer *)0x0;
  searchHeader = (int)SearchHeader;
  searchHeader_through = 1;
  prevtrap = (anon_subr_void_int *)0x0;
  extra_header = (TextList *)newGeneralList();
  uname = (Str)0x0;
  pwd = (Str)0x0;
  realm = (Str)0x0;
  status = '\0';
  page = (Str)0x0;
  charset = 0x100;
  tpath = path;
  prevtrap = (anon_subr_void_int *)0x0;
  add_auth_cookie_flag = 0;
  checkRedirection((ParsedURL *)0x0);
  while( true ) {
    while( true ) {
      while( true ) {
        while( true ) {
          while( true ) {
            if (TrapSignal != '\0') {
              if (fmInitialized != '\0') {
                term_raw();
              }
              if (prevtrap != (anon_subr_void_int *)0x0) {
                mySignal(2,prevtrap);
              }
            }
            url_option.referer = referer;
            url_option.flag = flag;
            openURL((URLFile *)&local_16c,tpath,&pu,current,&url_option,request,extra_header,of,&hr,
                    &status);
            f._0_4_ = local_16c;
            f.stream = local_168;
            f.ext = local_164;
            f.compression = local_160;
            f.content_encoding = local_15c;
            f.guess_type = local_158;
            f.url = local_154;
            f.modtime = local_150;
            of = (URLFile *)0x0;
            content_charset = 0;
            if (local_168 == (InputStream)0x0) {
              local_16c = local_16c & 0xff;
              if (local_16c == 4) {
                iVar7 = stat(pu.real_file,(stat *)&st);
                if (iVar7 < 0) {
                  pBVar12 = (Buffer *)0x0;
                  goto LAB_0805fa43;
                }
                if ((st.st_mode & 0xf000) == 0x4000) {
                  if (UseExternalDirBuffer != 0) {
                    p_Var6 = Sprintf("%s?dir=%s#current",DirBufferCommand,pu.file);
                    b = loadGeneralFile(p_Var6->ptr,(ParsedURL *)0x0,(char *)0xffffffff,0,
                                        (FormList *)0x0);
                    if ((b != (Buffer *)0x0) && (b != (Buffer *)0x1)) {
                      copyParsedURL(&b->currentURL,&pu);
                      b->filename = (b->currentURL).real_file;
                    }
                    pBVar12 = b;
                    goto LAB_0805fa43;
                  }
                  page = loadLocalDir(pu.real_file);
                  t = "local:directory";
                  charset = SystemCharset;
                }
              }
              else if (local_16c < 5) {
                if (local_16c == 3) {
                  page = loadFTPDir(&pu,&charset);
                  t = "ftp:directory";
                }
              }
              else if (local_16c == 10) {
                page = loadNewsgroup(&pu,&charset);
                t = "news:group";
              }
              else if (local_16c == 0xff) {
                tmp = searchURIMethods(&pu);
                if (tmp != (Str)0x0) {
                  b = loadGeneralFile(tmp->ptr,current,referer,flag,request);
                  if ((b != (Buffer *)0x0) && (b != (Buffer *)0x1)) {
                    copyParsedURL(&b->currentURL,&pu);
                  }
                  pBVar12 = b;
                  goto LAB_0805fa43;
                }
                p_Var6 = parsedURL2Str(&pu);
                p_Var6 = Sprintf("Unknown URI: %s",p_Var6->ptr);
                disp_err_message(p_Var6->ptr,0);
              }
              if ((page != (Str)0x0) && (0 < page->length)) goto page_loaded;
              pBVar12 = (Buffer *)0x0;
              goto LAB_0805fa43;
            }
            if (status == 0xfe) {
              if (TrapSignal != '\0') {
                if (fmInitialized != '\0') {
                  term_raw();
                }
                if (prevtrap != (anon_subr_void_int *)0x0) {
                  mySignal(2,prevtrap);
                }
              }
              ISclose(f.stream);
              pBVar12 = (Buffer *)0x0;
              goto LAB_0805fa43;
            }
            iVar7 = __sigsetjmp(AbortLoading,1);
            if (iVar7 != 0) {
              if (TrapSignal != '\0') {
                if (fmInitialized != '\0') {
                  term_raw();
                }
                if (prevtrap != (anon_subr_void_int *)0x0) {
                  mySignal(2,prevtrap);
                }
              }
              if (b != (Buffer *)0x0) {
                discardBuffer(b);
              }
              ISclose(f.stream);
              pBVar12 = (Buffer *)0x0;
              goto LAB_0805fa43;
            }
            b = (Buffer *)0x0;
            if (f.is_cgi != '\0') {
              searchHeader = 1;
              searchHeader_through = 0;
            }
            if (header_string != (Str)0x0) {
              header_string = (Str)0x0;
            }
            if ((TrapSignal != '\0') && (prevtrap = mySignal(2,KeyAbort), fmInitialized != '\0')) {
              term_cbreak();
            }
            if ((pu.scheme == 0) ||
               ((((pu.scheme == 1 && (iVar7 = non_null(GOPHER_proxy), iVar7 != 0)) ||
                 ((pu.scheme == 2 && (iVar7 = non_null(FTP_proxy), iVar7 != 0)))) &&
                ((use_proxy != '\0' && (iVar7 = check_no_proxy(pu.host), iVar7 == 0)))))) break;
            if ((pu.scheme == 9) || (pu.scheme == 7)) {
              if (t_buf == (Buffer *)0x0) {
                if (showLineNum == 0) {
                  iVar7 = 1;
                }
                else {
                  iVar7 = 6;
                }
                iVar7 = COLS - iVar7;
                if (iVar7 < 0) {
                  iVar7 = 0;
                }
                t_buf = newBuffer(iVar7);
              }
              readHeader(&f,t_buf,1,&pu);
              t = checkContentType(t_buf);
              if (t == (char *)0x0) {
                t = "text/plain";
              }
              goto LAB_0805ecf5;
            }
            if (pu.scheme == 1) {
              cVar1 = *pu.file;
              if (cVar1 == 'g') {
                t = "image/gif";
                goto LAB_0805ecf5;
              }
              if (cVar1 < 'h') {
                if (cVar1 == '0') {
                  t = "text/plain";
                  goto LAB_0805ecf5;
                }
                if (cVar1 != '1') goto LAB_0805ecf5;
              }
              else if (cVar1 != 'm') {
                if (cVar1 == 's') {
                  t = "audio/basic";
                }
                else if (cVar1 == 'h') {
                  t = "text/html";
                }
                goto LAB_0805ecf5;
              }
              page = loadGopherDir(&f,&pu,&charset);
              t = "gopher:directory";
              if (TrapSignal != '\0') {
                if (fmInitialized != '\0') {
                  term_raw();
                }
                if (prevtrap != (anon_subr_void_int *)0x0) {
                  mySignal(2,prevtrap);
                }
              }
              goto page_loaded;
            }
            if (pu.scheme == 2) {
              check_compression(path,&f);
              if (f.compression == 0) {
                real_type = guessContentType(pu.file);
                if (real_type == (char *)0x0) {
                  real_type = "text/plain";
                }
                t = real_type;
              }
              else {
                t = uncompressed_file_type(pu.file,(char **)0x0);
                real_type = f.guess_type;
                if (t == (char *)0x0) {
                  t = f.guess_type;
                }
              }
              goto LAB_0805ecf5;
            }
            if (pu.scheme == 0xb) {
              t = f.guess_type;
              goto LAB_0805ecf5;
            }
            if (searchHeader == 0) {
              if (DefaultType == (char *)0x0) {
                t = guessContentType(pu.file);
                if (t == (char *)0x0) {
                  t = "text/plain";
                }
                real_type = t;
                if (f.guess_type != (char *)0x0) {
                  t = f.guess_type;
                }
              }
              else {
                t = DefaultType;
                DefaultType = (char *)0x0;
              }
              goto LAB_0805ecf5;
            }
            SearchHeader = '\0';
            searchHeader = 0;
            if (t_buf == (Buffer *)0x0) {
              if (showLineNum == 0) {
                iVar7 = 1;
              }
              else {
                iVar7 = 6;
              }
              iVar7 = COLS - iVar7;
              if (iVar7 < 0) {
                iVar7 = 0;
              }
              t_buf = newBuffer(iVar7);
            }
            readHeader(&f,t_buf,searchHeader_through,&pu);
            if (((f.is_cgi == '\0') || (p = checkHeader(t_buf,"Location:"), p == (char *)0x0)) ||
               (iVar7 = checkRedirection(&pu), wVar3 = DocumentCharset, wVar2 = InnerCharset,
               iVar7 == 0)) {
              t = checkContentType(t_buf);
              if (t == (char *)0x0) {
                t = "text/plain";
              }
              goto LAB_0805ecf5;
            }
            pcVar8 = remove_space(p);
            p_Var6 = Strnew_charp(pcVar8);
            p_Var6 = wc_Str_conv_strict(p_Var6,wVar2,wVar3);
            tpath = url_quote(p_Var6->ptr);
            request = (FormList *)0x0;
            iVar7 = ISclose(f.stream);
            if (iVar7 == 0) {
              f.stream = (InputStream)0x0;
            }
            add_auth_cookie_flag = 0;
            current = (ParsedURL *)GC_malloc(0x28);
            copyParsedURL(current,&pu);
            if (showLineNum == 0) {
              iVar7 = 1;
            }
            else {
              iVar7 = 6;
            }
            iVar7 = COLS - iVar7;
            if (iVar7 < 0) {
              iVar7 = 0;
            }
            t_buf = newBuffer(iVar7);
            t_buf->bufferprop = t_buf->bufferprop | 0x20;
            status = '\0';
          }
          if (fmInitialized != '\0') {
            term_cbreak();
            p_Var6 = Sprintf("%s contacted. Waiting for reply...",pu.host);
            message(p_Var6->ptr,0,0);
            refresh();
          }
          if (t_buf == (Buffer *)0x0) {
            if (showLineNum == 0) {
              iVar7 = 1;
            }
            else {
              iVar7 = 6;
            }
            iVar7 = COLS - iVar7;
            if (iVar7 < 0) {
              iVar7 = 0;
            }
            t_buf = newBuffer(iVar7);
          }
          readHeader(&f,t_buf,0,&pu);
          if ((((http_response_code < 0x12d) || (0x12f < http_response_code)) &&
              (http_response_code != 0x133)) ||
             ((p = checkHeader(t_buf,"Location:"), p == (char *)0x0 ||
              (iVar7 = checkRedirection(&pu), wVar3 = DocumentCharset, wVar2 = InnerCharset,
              iVar7 == 0)))) break;
          p_Var6 = Strnew_charp(p);
          p_Var6 = wc_Str_conv_strict(p_Var6,wVar2,wVar3);
          tpath = url_quote(p_Var6->ptr);
          request = (FormList *)0x0;
          iVar7 = ISclose(f.stream);
          if (iVar7 == 0) {
            f.stream = (InputStream)0x0;
          }
          current = (ParsedURL *)GC_malloc(0x28);
          copyParsedURL(current,&pu);
          if (showLineNum == 0) {
            iVar7 = 1;
          }
          else {
            iVar7 = 6;
          }
          iVar7 = COLS - iVar7;
          if (iVar7 < 0) {
            iVar7 = 0;
          }
          t_buf = newBuffer(iVar7);
          t_buf->bufferprop = t_buf->bufferprop | 0x20;
          status = '\0';
        }
        t = checkContentType(t_buf);
        if ((((t == (char *)0x0) && (pu.file != (char *)0x0)) &&
            ((http_response_code < 400 || (0x197 < http_response_code)))) &&
           ((http_response_code < 500 || (0x1f9 < http_response_code)))) {
          t = guessContentType(pu.file);
        }
        uname_00 = uname;
        p_Var6 = pwd;
        if (t == (char *)0x0) {
          t = "text/plain";
        }
        if ((((add_auth_cookie_flag != 0) && (realm != (Str)0x0)) && (uname != (Str)0x0)) &&
           (pwd != (Str)0x0)) {
          p_Var4 = qstr_unquote(realm);
          add_auth_user_passwd(&pu,p_Var4->ptr,uname_00,p_Var6,0);
          add_auth_cookie_flag = 0;
        }
        p = checkHeader(t_buf,"WWW-Authenticate:");
        if (((p == (char *)0x0) || (http_response_code != 0x191)) ||
           ((phVar5 = findAuthentication((http_auth *)&st,t_buf,"WWW-Authenticate:"),
            phVar5 == (http_auth *)0x0 ||
            (realm = get_auth_param(st._8_4_,"realm"), realm == (Str)0x0)))) break;
        getAuthCookie((http_auth *)&st,"Authorization:",extra_header,&pu,&hr,request,&uname,&pwd);
        if (uname == (Str)0x0) {
          if (TrapSignal != '\0') {
            if (fmInitialized != '\0') {
              term_raw();
            }
            if (prevtrap != (anon_subr_void_int *)0x0) {
              mySignal(2,prevtrap);
            }
          }
          goto page_loaded;
        }
        iVar7 = ISclose(f.stream);
        if (iVar7 == 0) {
          f.stream = (InputStream)0x0;
        }
        add_auth_cookie_flag = 1;
        status = '\0';
      }
      p = checkHeader(t_buf,"Proxy-Authenticate:");
      if (((p == (char *)0x0) || (http_response_code != 0x197)) ||
         ((phVar5 = findAuthentication((http_auth *)&st,t_buf,"Proxy-Authenticate:"),
          phVar5 == (http_auth *)0x0 ||
          (realm = get_auth_param(st._8_4_,"realm"), realm == (Str)0x0)))) break;
      pu_00 = schemeToProxy(pu.scheme);
      getAuthCookie((http_auth *)&st,"Proxy-Authorization:",extra_header,pu_00,&hr,request,&uname,
                    &pwd);
      if (uname == (Str)0x0) {
        if (TrapSignal != '\0') {
          if (fmInitialized != '\0') {
            term_raw();
          }
          if (prevtrap != (anon_subr_void_int *)0x0) {
            mySignal(2,prevtrap);
          }
        }
        goto page_loaded;
      }
      iVar7 = ISclose(f.stream);
      if (iVar7 == 0) {
        f.stream = (InputStream)0x0;
      }
      add_auth_cookie_flag = 1;
      status = '\0';
    }
    if (status != '\x01') break;
    of = &f;
  }
  pcVar8 = checkHeader(t_buf,"Last-Modified:");
  f.modtime = mymktime(pcVar8);
LAB_0805ecf5:
  f.guess_type = t;
page_loaded:
  if (page != (Str)0x0) {
    if (image_source == (char *)0x0) {
      tmp = tmpfname(1,".html");
      __s = fopen(tmp->ptr,"w");
      if (__s != (FILE *)0x0) {
        p_Var6 = wc_Str_conv_strict(page,InnerCharset,charset);
        fwrite(p_Var6->ptr,1,p_Var6->length,__s);
        fclose(__s);
      }
      if (do_download == 0) {
        b = loadHTMLString(page);
        if (b != (Buffer *)0x0) {
          copyParsedURL(&b->currentURL,&pu);
          b->real_scheme = pu.scheme;
          b->real_type = t;
          if (__s != (FILE *)0x0) {
            b->sourcefile = tmp->ptr;
          }
          b->document_charset = charset;
        }
        pBVar12 = b;
      }
      else if (__s == (FILE *)0x0) {
        pBVar12 = (Buffer *)0x0;
      }
      else {
        file = guess_filename(pu.file);
        if (f.scheme == '\x01') {
          p_Var6 = Sprintf("%s.html",file);
          file = p_Var6->ptr;
        }
        if (f.scheme == '\n') {
          p_Var6 = Sprintf("%s.html",file);
          file = p_Var6->ptr;
        }
        doFileMove(tmp->ptr,file);
        pBVar12 = (Buffer *)0x1;
      }
    }
    else {
      pBVar12 = (Buffer *)0x0;
    }
    goto LAB_0805fa43;
  }
  if (real_type == (char *)0x0) {
    real_type = t;
  }
  proc = loadBuffer;
  cur_baseURL = (ParsedURL *)GC_malloc(0x28);
  copyParsedURL(cur_baseURL,&pu);
  current_content_length._0_4_ = 0;
  current_content_length._4_4_ = 0;
  p = checkHeader(t_buf,"Content-Length:");
  if (p != (char *)0x0) {
    current_content_length = strtoclen(p);
  }
  if (do_download != 0) {
    if (TrapSignal != '\0') {
      if (fmInitialized != '\0') {
        term_raw();
      }
      if (prevtrap != (anon_subr_void_int *)0x0) {
        mySignal(2,prevtrap);
      }
    }
    if ((DecodeCTE != '\0') && ((f.stream)->field_0x14 != '\x04')) {
      f.stream = newEncodedStream(f.stream,f.encoding);
    }
    if (pu.scheme == 4) {
      if (PreserveTimestamp != '\0') {
        iVar7 = stat(pu.real_file,(stat *)&st);
        if (iVar7 == 0) {
          f.modtime = st.st_mtim.tv_sec;
        }
      }
      wVar3 = SystemCharset;
      wVar2 = InnerCharset;
      pcVar8 = guess_save_name((Buffer *)0x0,pu.real_file);
      p_Var6 = Strnew_charp(pcVar8);
      p_Var6 = wc_Str_conv(p_Var6,wVar3,wVar2);
      file_1 = p_Var6->ptr;
    }
    else {
      file_1 = guess_save_name(t_buf,pu.file);
    }
    iVar7 = doFileSave((URLFile)CONCAT428(f.modtime,
                                          CONCAT424(f.url,CONCAT420(f.guess_type,
                                                                    CONCAT416(f.content_encoding,
                                                                              CONCAT412(f.
                                                  compression,
                                                  CONCAT48(f.ext,CONCAT44(f.stream,f._0_4_))))))),
                       file_1);
    if (iVar7 == 0) {
      UFhalfclose(&f);
    }
    else {
      ISclose(f.stream);
    }
    pBVar12 = (Buffer *)0x1;
    goto LAB_0805fa43;
  }
  if (((f.content_encoding == 0) || (AutoUncompress == '\0')) || ((w3m_dump & 8U) != 0)) {
    if (f.compression != 0) {
      if ((w3m_dump & 4U) == 0) {
        if ((w3m_dump & 0xffffffdfU) == 0) {
          iVar7 = is_text_type(t);
          if (iVar7 == 0) {
            pmVar9 = searchExtViewer(t);
            if (pmVar9 == (mailcap *)0x0) goto LAB_0805f1f5;
          }
        }
        if (t_buf == (Buffer *)0x0) {
          if (showLineNum == 0) {
            iVar7 = 1;
          }
          else {
            iVar7 = 6;
          }
          iVar7 = COLS - iVar7;
          if (iVar7 < 0) {
            iVar7 = 0;
          }
          t_buf = newBuffer(iVar7);
        }
        uncompress_stream(&f,&t_buf->sourcefile);
        uncompressed_file_type(pu.file,&f.ext);
      }
      else {
LAB_0805f1f5:
        t = compress_application_type(f.compression);
        f.compression = 0;
      }
    }
  }
  else {
    uncompress_stream(&f,&pu.real_file);
  }
  if (image_source != (char *)0x0) {
    b_1 = (Buffer *)0x0;
    if ((f.stream)->field_0x14 != '\x04') {
      f.stream = newEncodedStream(f.stream,f.encoding);
    }
    iVar7 = save2tmp((URLFile)CONCAT428(f.modtime,
                                        CONCAT424(f.url,CONCAT420(f.guess_type,
                                                                  CONCAT416(f.content_encoding,
                                                                            CONCAT412(f.compression,
                                                                                      CONCAT48(f.ext
                                                  ,CONCAT44(f.stream,f._0_4_))))))),image_source);
    if (iVar7 == 0) {
      if (showLineNum == 0) {
        iVar7 = 1;
      }
      else {
        iVar7 = 6;
      }
      iVar7 = COLS - iVar7;
      if (iVar7 < 0) {
        iVar7 = 0;
      }
      b_1 = newBuffer(iVar7);
      b_1->sourcefile = image_source;
      b_1->real_type = t;
    }
    iVar7 = ISclose(f.stream);
    if (iVar7 == 0) {
      f.stream = (InputStream)0x0;
    }
    pBVar12 = b_1;
    if (TrapSignal != '\0') {
      if (fmInitialized != '\0') {
        term_raw();
      }
      pBVar12 = b_1;
      if (prevtrap != (anon_subr_void_int *)0x0) {
        mySignal(2,prevtrap);
        pBVar12 = b_1;
      }
    }
    goto LAB_0805fa43;
  }
  iVar7 = is_html_type(t);
  if (iVar7 == 0) {
    iVar7 = is_plain_text_type(t);
    if (iVar7 == 0) {
      if ((((activeImage != 0) && (displayImage != 0)) && (useExtImageViewer == 0)) &&
         ((w3m_dump & 0xffffffdfU) == 0)) {
        iVar7 = strncasecmp(t,"image/",6);
        if (iVar7 == 0) {
          proc = loadImageBuffer;
          goto LAB_0805f744;
        }
      }
      if (w3m_backend == 0) {
        if ((w3m_dump & 0xffffffdfU) != 0) {
          iVar7 = is_dump_text_type(t);
          if (iVar7 == 0) {
            if ((w3m_dump & 0x20U) != 0) {
              pBVar12 = (Buffer *)0x0;
              goto LAB_0805fa43;
            }
            goto LAB_0805f744;
          }
        }
        if (do_download == 0) {
          pcVar8 = pu.file;
          if (pu.real_file != (char *)0x0) {
            pcVar8 = pu.real_file;
          }
          iVar7 = doExternal((URLFile)CONCAT428(f.modtime,
                                                CONCAT424(f.url,CONCAT420(f.guess_type,
                                                                          CONCAT416(f.
                                                  content_encoding,
                                                  CONCAT412(f.compression,
                                                            CONCAT48(f.ext,CONCAT44(f.stream,f._0_4_
                                                                                   ))))))),pcVar8,t,
                             &b,t_buf);
          if (iVar7 != 0) {
            if ((b != (Buffer *)0x0) && (b != (Buffer *)0x1)) {
              b->real_scheme = f._0_4_ & 0xff;
              b->real_type = real_type;
              if (((b->currentURL).host == (char *)0x0) && ((b->currentURL).file == (char *)0x0)) {
                copyParsedURL(&b->currentURL,&pu);
              }
            }
            iVar7 = ISclose(f.stream);
            if (iVar7 == 0) {
              f.stream = (InputStream)0x0;
            }
            pBVar12 = b;
            if (TrapSignal != '\0') {
              if (fmInitialized != '\0') {
                term_raw();
              }
              pBVar12 = b;
              if (prevtrap != (anon_subr_void_int *)0x0) {
                mySignal(2,prevtrap);
                pBVar12 = b;
              }
            }
            goto LAB_0805fa43;
          }
        }
        if (TrapSignal != '\0') {
          if (fmInitialized != '\0') {
            term_raw();
          }
          if (prevtrap != (anon_subr_void_int *)0x0) {
            mySignal(2,prevtrap);
          }
        }
        if (pu.scheme == 4) {
          iVar7 = ISclose(f.stream);
          wVar3 = SystemCharset;
          wVar2 = InnerCharset;
          if (iVar7 == 0) {
            f.stream = (InputStream)0x0;
          }
          pcVar8 = guess_save_name((Buffer *)0x0,pu.real_file);
          p_Var6 = Strnew_charp(pcVar8);
          p_Var6 = wc_Str_conv(p_Var6,wVar3,wVar2);
          _doFileCopy(pu.real_file,p_Var6->ptr,1);
        }
        else {
          if ((DecodeCTE != '\0') && ((f.stream)->field_0x14 != '\x04')) {
            f.stream = newEncodedStream(f.stream,f.encoding);
          }
          pcVar8 = guess_save_name(t_buf,pu.file);
          iVar7 = doFileSave((URLFile)CONCAT428(f.modtime,
                                                CONCAT424(f.url,CONCAT420(f.guess_type,
                                                                          CONCAT416(f.
                                                  content_encoding,
                                                  CONCAT412(f.compression,
                                                            CONCAT48(f.ext,CONCAT44(f.stream,f._0_4_
                                                                                   ))))))),pcVar8);
          if (iVar7 == 0) {
            UFhalfclose(&f);
          }
          else {
            ISclose(f.stream);
          }
        }
        pBVar12 = (Buffer *)0x1;
        goto LAB_0805fa43;
      }
    }
    else {
      proc = loadBuffer;
    }
  }
  else {
    proc = loadHTMLBuffer;
  }
LAB_0805f744:
  if ((flag & 2U) != 0) {
    if (t_buf == (Buffer *)0x0) {
      if (showLineNum == 0) {
        iVar7 = 1;
      }
      else {
        iVar7 = 6;
      }
      iVar7 = COLS - iVar7;
      if (iVar7 < 0) {
        iVar7 = 0;
      }
      t_buf = newBuffer(iVar7);
    }
    t_buf->bufferprop = t_buf->bufferprop | 2;
  }
  frame_source = flag & 4;
  if (pu.real_file != (char *)0x0) {
    pu.file = pu.real_file;
  }
  b = loadSomething(&f,pu.file,(anon_subr_Buffer_ptr_URLFile_ptr_Buffer_ptr *)proc,t_buf);
  iVar7 = ISclose(f.stream);
  if (iVar7 == 0) {
    f.stream = (InputStream)0x0;
  }
  frame_source = 0;
  if (b != (Buffer *)0x0) {
    b->real_scheme = f._0_4_ & 0xff;
    b->real_type = real_type;
    if (((b->currentURL).host == (char *)0x0) && ((b->currentURL).file == (char *)0x0)) {
      copyParsedURL(&b->currentURL,&pu);
    }
    iVar7 = is_html_type(t);
    if (iVar7 == 0) {
      if (w3m_backend == 0) {
        if (proc == loadImageBuffer) {
          b->type = "text/html";
        }
        else {
          b->type = "text/plain";
        }
      }
      else {
        p_Var6 = Strnew_charp(t);
        b->type = p_Var6->ptr;
      }
    }
    else {
      b->type = "text/html";
    }
    if (pu.label != (char *)0x0) {
      if (proc == loadHTMLBuffer) {
        pAVar10 = searchURLLabel(b,pu.label);
        if (pAVar10 != (Anchor *)0x0) {
          gotoLine(b,(pAVar10->start).line);
          pBVar12 = b;
          if (label_topline != 0) {
            pLVar11 = lineSkip(b,b->topLine,b->currentLine->linenumber - b->topLine->linenumber,0);
            pBVar12->topLine = pLVar11;
          }
          b->pos = (pAVar10->start).pos;
          arrangeCursor(b);
        }
      }
      else {
        iVar7 = atoi(pu.label);
        gotoRealLine(b,iVar7);
        b->pos = 0;
        arrangeCursor(b);
      }
    }
  }
  if (header_string != (Str)0x0) {
    header_string = (Str)0x0;
  }
  if ((f.scheme == '\a') || (f.scheme == '\t')) {
    reAnchorNewsheader(b);
  }
  preFormUpdateBuffer(b);
  pBVar12 = b;
  if (TrapSignal != '\0') {
    if (fmInitialized != '\0') {
      term_raw();
    }
    pBVar12 = b;
    if (prevtrap != (anon_subr_void_int *)0x0) {
      mySignal(2,prevtrap);
      pBVar12 = b;
    }
  }
LAB_0805fa43:
  current_content_length._4_4_ = (undefined4)((ulonglong)current_content_length >> 0x20);
  return pBVar12;
}



char * has_hidden_link(readbuffer *obuf,int cmd)

{
  Str p_Var1;
  char *pcVar2;
  link_stack *p;
  Str line;
  
  p_Var1 = obuf->line;
  if ((p_Var1->length < 1) || (p_Var1->ptr[p_Var1->length + -1] != '>')) {
    pcVar2 = (char *)0x0;
  }
  else {
    for (p = link_stack; (p != (link_stack *)0x0 && (p->cmd != cmd)); p = p->next) {
    }
    if (p == (link_stack *)0x0) {
      pcVar2 = (char *)0x0;
    }
    else if (obuf->pos == p->pos) {
      pcVar2 = p_Var1->ptr + p->offset;
    }
    else {
      pcVar2 = (char *)0x0;
    }
  }
  return pcVar2;
}



void push_link(int cmd,int offset,int pos)

{
  link_stack *plVar1;
  link_stack *p;
  
  plVar1 = (link_stack *)GC_malloc(0xc);
  plVar1->cmd = cmd;
  plVar1->offset = (short)offset;
  plVar1->pos = (short)pos;
  plVar1->next = link_stack;
  link_stack = plVar1;
  return;
}



int is_period_char(uchar *ch)

{
  int iVar1;
  
  switch(*ch) {
  case '!':
  case ')':
  case ',':
  case '.':
  case ':':
  case ';':
  case '>':
  case '?':
  case ']':
  case '}':
    iVar1 = 1;
    break;
  default:
    iVar1 = 0;
  }
  return iVar1;
}



int is_beginning_char(uchar *ch)

{
  byte bVar1;
  int iVar2;
  
  bVar1 = *ch;
  if (bVar1 == 0x5b) {
LAB_0805fb86:
    iVar2 = 1;
  }
  else {
    if (bVar1 < 0x5c) {
      if ((bVar1 == 0x28) || (bVar1 == 0x3c)) goto LAB_0805fb86;
    }
    else if ((bVar1 == 0x60) || (bVar1 == 0x7b)) goto LAB_0805fb86;
    iVar2 = 0;
  }
  return iVar2;
}



int is_word_char(uchar *ch)

{
  int iVar1;
  Lineprop ctype;
  
  if ((WTF_TYPE_MAP[*ch] & 0x19) == 0) {
    if ((WTF_TYPE_MAP[*ch] & 6) == 0) {
      if ((MYCTYPE_MAP[*ch] & 0xc) == 0) {
        switch(*ch) {
        case '\"':
        case '$':
        case '%':
        case '\'':
        case '*':
        case '+':
        case ',':
        case '-':
        case '.':
        case ':':
        case '@':
        case '_':
        case '~':
          iVar1 = 1;
          break;
        default:
          if (*ch == 0xa0) {
            iVar1 = 1;
          }
          else {
            iVar1 = 0;
          }
        }
      }
      else {
        iVar1 = 1;
      }
    }
    else {
      iVar1 = 1;
    }
  }
  else {
    iVar1 = 0;
  }
  return iVar1;
}



int is_combining_char(uchar *ch)

{
  Lineprop ctype;
  
  return (uint)((WTF_TYPE_MAP[*ch] & 4) != 0);
}



int is_boundary(uchar *ch1,uchar *ch2)

{
  int iVar1;
  
  if ((*ch1 == '\0') || (*ch2 == '\0')) {
    iVar1 = 1;
  }
  else if ((*ch1 == ' ') && (*ch2 == ' ')) {
    iVar1 = 0;
  }
  else {
    if ((*ch1 != ' ') && (iVar1 = is_period_char(ch2), iVar1 != 0)) {
      return 0;
    }
    if ((*ch2 != ' ') && (iVar1 = is_beginning_char(ch1), iVar1 != 0)) {
      return 0;
    }
    iVar1 = is_combining_char(ch2);
    if (iVar1 == 0) {
      iVar1 = is_word_char(ch1);
      if ((iVar1 != 0) && (iVar1 = is_word_char(ch2), iVar1 != 0)) {
        return 0;
      }
      iVar1 = 1;
    }
    else {
      iVar1 = 0;
    }
  }
  return iVar1;
}



void set_breakpoint(readbuffer *obuf,int tag_length)

{
  (obuf->bp).len = obuf->line->length;
  (obuf->bp).pos = (int)obuf->pos;
  (obuf->bp).tlen = tag_length;
  (obuf->bp).flag = obuf->flag;
  (obuf->bp).top_margin = obuf->top_margin;
  (obuf->bp).bottom_margin = obuf->bottom_margin;
  if ((obuf->bp).init_flag != '\0') {
    bcopy(&obuf->anchor,&(obuf->bp).anchor,0x3c);
    (obuf->bp).img_alt = obuf->img_alt;
    (obuf->bp).fontstat[0] = obuf->fontstat[0];
    (obuf->bp).fontstat[2] = obuf->fontstat[2];
    (obuf->bp).fontstat[1] = obuf->fontstat[1];
    (obuf->bp).fontstat[3] = obuf->fontstat[3];
    (obuf->bp).fontstat[4] = obuf->fontstat[4];
    (obuf->bp).nobr_level = obuf->nobr_level;
    (obuf->bp).prev_ctype = obuf->prev_ctype;
    (obuf->bp).init_flag = '\0';
  }
  return;
}



void back_to_breakpoint(readbuffer *obuf)

{
  obuf->flag = (obuf->bp).flag;
  bcopy(&(obuf->bp).anchor,&obuf->anchor,0x3c);
  obuf->img_alt = (obuf->bp).img_alt;
  obuf->fontstat[0] = (obuf->bp).fontstat[0];
  obuf->fontstat[2] = (obuf->bp).fontstat[2];
  obuf->fontstat[1] = (obuf->bp).fontstat[1];
  obuf->fontstat[3] = (obuf->bp).fontstat[3];
  obuf->fontstat[4] = (obuf->bp).fontstat[4];
  obuf->prev_ctype = (obuf->bp).prev_ctype;
  obuf->pos = (short)(obuf->bp).pos;
  obuf->top_margin = (obuf->bp).top_margin;
  obuf->bottom_margin = (obuf->bp).bottom_margin;
  if ((obuf->flag & 0x80U) != 0) {
    obuf->nobr_level = (obuf->bp).nobr_level;
  }
  return;
}



void append_tags(readbuffer *obuf)

{
  int iVar1;
  int iVar2;
  bool bVar3;
  int set_bp;
  int len;
  int i;
  
  iVar1 = obuf->line->length;
  bVar3 = false;
  i = 0;
  do {
    if (obuf->tag_sp <= i) {
      obuf->tag_sp = 0;
      if (bVar3) {
        set_breakpoint(obuf,obuf->line->length - iVar1);
      }
      return;
    }
    iVar2 = obuf->tag_stack[i]->cmd;
    if (iVar2 == 0x41) {
LAB_0805ffef:
      push_link(obuf->tag_stack[i]->cmd,obuf->line->length,(int)obuf->pos);
    }
    else if (iVar2 < 0x42) {
      if ((iVar2 == 1) || (iVar2 == 7)) goto LAB_0805ffef;
    }
    else if (((iVar2 == 0x6d) || (iVar2 == 0x88)) || (iVar2 == 0x69)) goto LAB_0805ffef;
    Strcat_charp(obuf->line,obuf->tag_stack[i]->cmdname);
    iVar2 = obuf->tag_stack[i]->cmd;
    if (iVar2 == 0x32) {
      if (obuf->nobr_level < 2) goto LAB_08060067;
    }
    else if (iVar2 == 0x45) {
LAB_08060067:
      bVar3 = true;
    }
    i = i + 1;
  } while( true );
}



void push_tag(readbuffer *obuf,char *cmdname,int cmd)

{
  int iVar1;
  cmdtable *pcVar2;
  char *pcVar3;
  
  iVar1 = obuf->tag_sp;
  pcVar2 = (cmdtable *)GC_malloc(8);
  obuf->tag_stack[iVar1] = pcVar2;
  pcVar2 = obuf->tag_stack[obuf->tag_sp];
  pcVar3 = allocStr(cmdname,-1);
  pcVar2->cmdname = pcVar3;
  obuf->tag_stack[obuf->tag_sp]->cmd = cmd;
  obuf->tag_sp = obuf->tag_sp + 1;
  if ((9 < obuf->tag_sp) || ((obuf->flag & 0x20fU) != 0)) {
    append_tags(obuf);
  }
  return;
}



void push_nchars(readbuffer *obuf,int width,char *str,int len,Lineprop mode)

{
  append_tags(obuf);
  Strcat_charp_n(obuf->line,str,len);
  obuf->pos = obuf->pos + (short)width;
  if (0 < width) {
    Strcopy_charp_n(obuf->prevchar,str,len);
    obuf->prev_ctype = mode;
  }
  obuf->flag = obuf->flag | 0x8000;
  return;
}



void check_breakpoint(readbuffer *obuf,int pre_mode,char *ch)

{
  int iVar1;
  int iVar2;
  int len;
  int tlen;
  
  iVar1 = obuf->line->length;
  append_tags(obuf);
  if (pre_mode == 0) {
    iVar1 = obuf->line->length - iVar1;
    if ((iVar1 < 1) && (iVar2 = is_boundary((uchar *)obuf->prevchar->ptr,(uchar *)ch), iVar2 == 0))
    {
      return;
    }
    set_breakpoint(obuf,iVar1);
  }
  return;
}



void push_char(readbuffer *obuf,int pre_mode,char ch)

{
  Str p_Var1;
  int iVar2;
  char local_10 [8];
  
  local_10[0] = ch;
  check_breakpoint(obuf,pre_mode,local_10);
  if (obuf->line->area_size <= obuf->line->length + 1) {
    Strgrow(obuf->line);
  }
  p_Var1 = obuf->line;
  iVar2 = p_Var1->length;
  obuf->line->ptr[iVar2] = local_10[0];
  p_Var1->length = iVar2 + 1;
  obuf->line->ptr[obuf->line->length] = '\0';
  obuf->pos = obuf->pos + 1;
  Strcopy_charp_n(obuf->prevchar,local_10,1);
  if (local_10[0] != ' ') {
    obuf->prev_ctype = 0;
  }
  obuf->flag = obuf->flag | 0x8000;
  return;
}



void push_spaces(readbuffer *obuf,int pre_mode,int width)

{
  Str p_Var1;
  int iVar2;
  int i;
  
  if (0 < width) {
    check_breakpoint(obuf,pre_mode," ");
    for (i = 0; i < width; i = i + 1) {
      if (obuf->line->area_size <= obuf->line->length + 1) {
        Strgrow(obuf->line);
      }
      p_Var1 = obuf->line;
      iVar2 = p_Var1->length;
      obuf->line->ptr[iVar2] = ' ';
      p_Var1->length = iVar2 + 1;
      obuf->line->ptr[obuf->line->length] = '\0';
    }
    obuf->pos = obuf->pos + (short)width;
    Strcopy_charp_n(obuf->prevchar," ",1);
    obuf->flag = obuf->flag | 0x8000;
  }
  return;
}



void proc_mchar(readbuffer *obuf,int pre_mode,int width,char **str,Lineprop mode)

{
  check_breakpoint(obuf,pre_mode,*str);
  obuf->pos = obuf->pos + (short)width;
  Strcat_charp_n(obuf->line,*str,(uint)WTF_LEN_MAP[(byte)**str]);
  if (0 < width) {
    Strcopy_charp_n(obuf->prevchar,*str,1);
    if (**str != ' ') {
      obuf->prev_ctype = mode;
    }
  }
  *str = *str + WTF_LEN_MAP[(byte)**str];
  obuf->flag = obuf->flag | 0x8000;
  return;
}



void push_render_image(Str str,int width,int limit,html_feed_environ *h_env)

{
  char cVar1;
  readbuffer *obuf_00;
  int indent;
  readbuffer *obuf;
  
  obuf_00 = h_env->obuf;
  cVar1 = h_env->envs[h_env->envc].indent;
  push_spaces(obuf_00,1,(limit - width) / 2);
  push_nchars(obuf_00,width,str->ptr,str->length,0);
  push_spaces(obuf_00,1,((limit - width) + 1) / 2);
  if (0 < width) {
    flushline(h_env,obuf_00,(int)cVar1,0,h_env->limit);
  }
  return;
}



int sloppy_parse_line(char **str)

{
  int iVar1;
  
  if (**str == '<') {
    while ((**str != '\0' && (**str != '>'))) {
      *str = *str + 1;
    }
    if (**str == '>') {
      *str = *str + 1;
    }
    iVar1 = 1;
  }
  else {
    while ((**str != '\0' && (**str != '<'))) {
      *str = *str + 1;
    }
    iVar1 = 0;
  }
  return iVar1;
}



void passthrough(readbuffer *obuf,char *str,int back)

{
  int iVar1;
  link_stack *p;
  char *q;
  Str str_save;
  char *str_bak;
  Str tok;
  int cmd;
  
  tok = Strnew();
  if (back != 0) {
    str_save = Strnew_charp(str);
    Strshrink(obuf->line,(int)(obuf->line->ptr + (obuf->line->length - (int)str)));
    str = str_save->ptr;
  }
  do {
    while( true ) {
      while( true ) {
        if (*str == '\0') {
          return;
        }
        str_bak = str;
        iVar1 = sloppy_parse_line(&str);
        if (iVar1 != 0) break;
        push_nchars(obuf,0,str_bak,(int)str - (int)str_bak,obuf->prev_ctype);
      }
      q = str_bak;
      cmd = gethtmlcmd(&q);
      if (back != 0) break;
      Strcat_charp_n(tok,str_bak,(int)str - (int)str_bak);
      push_tag(obuf,tok->ptr,cmd);
      Strclear(tok);
    }
    for (p = link_stack; p != (link_stack *)0x0; p = p->next) {
      if (p->cmd == cmd) {
        link_stack = p->next;
        break;
      }
    }
    back = 0;
  } while( true );
}



void fillline(readbuffer *obuf,int indent)

{
  push_spaces(obuf,1,indent - obuf->pos);
  obuf->flag = obuf->flag & 0xffff7fff;
  return;
}



void flushline(html_feed_environ *h_env,readbuffer *obuf,int indent,int force,int width)

{
  size_t __n;
  Str x;
  int iVar1;
  Str p_Var2;
  char *pcVar3;
  readbuffer o;
  html_feed_environ h;
  environment e [1];
  Str tmp_2;
  char *c;
  Str tmp_1;
  int i_1;
  Str tmp2;
  Str tmp;
  char *q;
  char *p;
  TextLine *lbuf;
  int i;
  char *ep;
  char *tp;
  char *hidden;
  char *hidden_ins;
  char *hidden_strike;
  char *hidden_italic;
  char *hidden_under;
  char *hidden_bold;
  char *hidden_img;
  char *hidden_anchor;
  Str pass;
  Str line;
  FILE *f;
  TextLineList *buf;
  
  buf = h_env->buf;
  f = h_env->f;
  line = obuf->line;
  pass = (Str)0x0;
  hidden_anchor = (char *)0x0;
  hidden_img = (char *)0x0;
  hidden_bold = (char *)0x0;
  hidden_under = (char *)0x0;
  hidden_italic = (char *)0x0;
  hidden_strike = (char *)0x0;
  hidden_ins = (char *)0x0;
  hidden = (char *)0x0;
  if ((((obuf->flag & 0x20fU) == 0) && (0 < line->length)) && (line->ptr[line->length + -1] == ' '))
  {
    Strshrink(line,1);
    obuf->pos = obuf->pos + -1;
  }
  append_tags(obuf);
  if ((obuf->anchor).url != (char *)0x0) {
    hidden = has_hidden_link(obuf,1);
    hidden_anchor = hidden;
  }
  if (((obuf->img_alt != (Str)0x0) &&
      (hidden_img = has_hidden_link(obuf,0x88), hidden_img != (char *)0x0)) &&
     ((hidden == (char *)0x0 || (hidden_img < hidden)))) {
    hidden = hidden_img;
  }
  if (((obuf->fontstat[0] != '\0') &&
      (hidden_bold = has_hidden_link(obuf,7), hidden_bold != (char *)0x0)) &&
     ((hidden == (char *)0x0 || (hidden_bold < hidden)))) {
    hidden = hidden_bold;
  }
  if (((obuf->fontstat[2] != '\0') &&
      (hidden_italic = has_hidden_link(obuf,0x6d), hidden_italic != (char *)0x0)) &&
     ((hidden == (char *)0x0 || (hidden_italic < hidden)))) {
    hidden = hidden_italic;
  }
  if (((obuf->fontstat[1] != '\0') &&
      (hidden_under = has_hidden_link(obuf,0x41), hidden_under != (char *)0x0)) &&
     ((hidden == (char *)0x0 || (hidden_under < hidden)))) {
    hidden = hidden_under;
  }
  if (((obuf->fontstat[3] != '\0') &&
      (hidden_strike = has_hidden_link(obuf,0x69), hidden_strike != (char *)0x0)) &&
     ((hidden == (char *)0x0 || (hidden_strike < hidden)))) {
    hidden = hidden_strike;
  }
  if (((obuf->fontstat[4] != '\0') &&
      (hidden_ins = has_hidden_link(obuf,0x3f), hidden_ins != (char *)0x0)) &&
     ((hidden == (char *)0x0 || (hidden_ins < hidden)))) {
    hidden = hidden_ins;
  }
  if (hidden != (char *)0x0) {
    pass = Strnew_charp(hidden);
    Strshrink(line,(int)(line->ptr + (line->length - (int)hidden)));
  }
  if (((obuf->flag & 0x20fU) == 0) && (width < obuf->pos)) {
    tp = line->ptr + ((obuf->bp).len - (obuf->bp).tlen);
    ep = line->ptr + line->length;
    if (((obuf->bp).pos == (int)obuf->pos) && (((tp <= ep && (line->ptr < tp)) && (tp[-1] == ' '))))
    {
      bcopy(tp,tp + -1,(size_t)(ep + (1 - (int)tp)));
      line->length = line->length + -1;
      obuf->pos = obuf->pos + -1;
    }
  }
  if (((obuf->anchor).url != (char *)0x0) && (hidden_anchor == (char *)0x0)) {
    Strcat_charp(line,"</a>");
  }
  if ((obuf->img_alt != (Str)0x0) && (hidden_img == (char *)0x0)) {
    Strcat_charp(line,"</img_alt>");
  }
  if ((obuf->fontstat[0] != '\0') && (hidden_bold == (char *)0x0)) {
    Strcat_charp(line,"</b>");
  }
  if ((obuf->fontstat[2] != '\0') && (hidden_italic == (char *)0x0)) {
    Strcat_charp(line,"</i>");
  }
  if ((obuf->fontstat[1] != '\0') && (hidden_under == (char *)0x0)) {
    Strcat_charp(line,"</u>");
  }
  if ((obuf->fontstat[3] != '\0') && (hidden_strike == (char *)0x0)) {
    Strcat_charp(line,"</s>");
  }
  if ((obuf->fontstat[4] != '\0') && (hidden_ins == (char *)0x0)) {
    Strcat_charp(line,"</ins>");
  }
  if (0 < obuf->top_margin) {
    init_henv(&h,&o,e,1,(TextLineList *)0x0,width,indent);
    o.line = Strnew_size(width + 0x14);
    o.pos = obuf->pos;
    o.flag = obuf->flag;
    o.top_margin = -1;
    o.bottom_margin = -1;
    Strcat_charp(o.line,"<pre_int>");
    for (i = 0; i < o.pos; i = i + 1) {
      if ((o.line)->area_size <= (o.line)->length + 1) {
        Strgrow(o.line);
      }
      iVar1 = (o.line)->length;
      (o.line)->ptr[iVar1] = ' ';
      (o.line)->length = iVar1 + 1;
      (o.line)->ptr[(o.line)->length] = '\0';
    }
    Strcat_charp(o.line,"</pre_int>");
    for (i = 0; i < obuf->top_margin; i = i + 1) {
      flushline(h_env,&o,indent,force,width);
    }
  }
  if ((force == 1) || ((obuf->flag & 0x8000U) != 0)) {
    lbuf = newTextLine(line,(int)obuf->pos);
    if ((obuf->flag & 0x70U) == 0x20) {
      align(lbuf,width,0);
    }
    else if ((obuf->flag & 0x70U) == 0x40) {
      align(lbuf,width,2);
    }
    else if (((obuf->flag & 0x70U) == 0x10) && ((obuf->flag & 0x20000U) != 0)) {
      align(lbuf,width,1);
    }
    if (h_env->maxlimit < (int)lbuf->pos) {
      h_env->maxlimit = (int)lbuf->pos;
    }
    if (buf == (TextLineList *)0x0) {
      if (f != (FILE *)0x0) {
        if (ExtHalfdump == '\0') {
          p_Var2 = lbuf->line;
        }
        else {
          p_Var2 = wc_Str_conv(lbuf->line,InnerCharset,DisplayCharset);
        }
        __n = p_Var2->length;
        if (ExtHalfdump == '\0') {
          p_Var2 = lbuf->line;
        }
        else {
          p_Var2 = wc_Str_conv(lbuf->line,InnerCharset,DisplayCharset);
        }
        fwrite(p_Var2->ptr,1,__n,(FILE *)f);
        fputc(10,(FILE *)f);
      }
    }
    else {
      pushValue((GeneralList *)buf,lbuf);
    }
    p_Var2 = pass;
    if (((obuf->flag & 0x28fU) == 0) && ((obuf->flag & 0x8000U) == 0)) {
      h_env->blank_lines = h_env->blank_lines + 1;
    }
    else {
      h_env->blank_lines = 0;
    }
  }
  else {
    p = line->ptr;
    x = Strnew();
    p_Var2 = Strnew();
    while (pcVar3 = p, *p != '\0') {
      iVar1 = sloppy_parse_line(&p);
      if (iVar1 != 0) {
        Strcat_charp_n(x,pcVar3,(int)p - (int)pcVar3);
        if (force == 2) {
          if (buf == (TextLineList *)0x0) {
            if (f != (FILE *)0x0) {
              fwrite(x->ptr,1,x->length,(FILE *)f);
            }
          }
          else {
            appendTextLine(buf,x,0);
          }
        }
        else {
          Strcat(p_Var2,x);
        }
        Strclear(x);
      }
    }
    if (force == 2) {
      if (pass != (Str)0x0) {
        if (buf == (TextLineList *)0x0) {
          if (f != (FILE *)0x0) {
            fwrite(pass->ptr,1,pass->length,(FILE *)f);
          }
        }
        else {
          appendTextLine(buf,pass,0);
        }
      }
      pass = (Str)0x0;
      p_Var2 = pass;
    }
    else if (pass != (Str)0x0) {
      Strcat(p_Var2,pass);
    }
  }
  pass = p_Var2;
  if (0 < obuf->bottom_margin) {
    init_henv(&h,&o,e,1,(TextLineList *)0x0,width,indent);
    o.line = Strnew_size(width + 0x14);
    o.pos = obuf->pos;
    o.flag = obuf->flag;
    o.top_margin = -1;
    o.bottom_margin = -1;
    Strcat_charp(o.line,"<pre_int>");
    for (i_1 = 0; i_1 < o.pos; i_1 = i_1 + 1) {
      if ((o.line)->area_size <= (o.line)->length + 1) {
        Strgrow(o.line);
      }
      iVar1 = (o.line)->length;
      (o.line)->ptr[iVar1] = ' ';
      (o.line)->length = iVar1 + 1;
      (o.line)->ptr[(o.line)->length] = '\0';
    }
    Strcat_charp(o.line,"</pre_int>");
    for (i_1 = 0; i_1 < obuf->bottom_margin; i_1 = i_1 + 1) {
      flushline(h_env,&o,indent,force,width);
    }
  }
  if ((-1 < obuf->top_margin) && (-1 < obuf->bottom_margin)) {
    p_Var2 = Strnew_size(0x100);
    obuf->line = p_Var2;
    obuf->pos = 0;
    obuf->top_margin = 0;
    obuf->bottom_margin = 0;
    Strcopy_charp_n(obuf->prevchar," ",1);
    (obuf->bp).init_flag = '\x01';
    obuf->flag = obuf->flag & 0xffff7fff;
    set_breakpoint(obuf,0);
    obuf->prev_ctype = 0;
    link_stack = (link_stack *)0x0;
    fillline(obuf,indent);
    if (pass != (Str)0x0) {
      passthrough(obuf,pass->ptr,0);
    }
    if ((hidden_anchor == (char *)0x0) && ((obuf->anchor).url != (char *)0x0)) {
      if (0 < (obuf->anchor).hseq) {
        (obuf->anchor).hseq = -(obuf->anchor).hseq;
      }
      p_Var2 = Sprintf("<A HSEQ=\"%d\" HREF=\"",(obuf->anchor).hseq);
      pcVar3 = html_quote((obuf->anchor).url);
      Strcat_charp(p_Var2,pcVar3);
      if ((obuf->anchor).target != (char *)0x0) {
        Strcat_charp(p_Var2,"\" TARGET=\"");
        pcVar3 = html_quote((obuf->anchor).target);
        Strcat_charp(p_Var2,pcVar3);
      }
      if ((obuf->anchor).referer != (char *)0x0) {
        Strcat_charp(p_Var2,"\" REFERER=\"");
        pcVar3 = html_quote((obuf->anchor).referer);
        Strcat_charp(p_Var2,pcVar3);
      }
      if ((obuf->anchor).title != (char *)0x0) {
        Strcat_charp(p_Var2,"\" TITLE=\"");
        pcVar3 = html_quote((obuf->anchor).title);
        Strcat_charp(p_Var2,pcVar3);
      }
      if ((obuf->anchor).accesskey != '\0') {
        pcVar3 = HTML_QUOTE_MAP[QUOTE_MAP[(obuf->anchor).accesskey] & 7];
        Strcat_charp(p_Var2,"\" ACCESSKEY=\"");
        if (pcVar3 == (char *)0x0) {
          if (p_Var2->area_size <= p_Var2->length + 1) {
            Strgrow(p_Var2);
          }
          iVar1 = p_Var2->length;
          p_Var2->ptr[iVar1] = (obuf->anchor).accesskey;
          p_Var2->length = iVar1 + 1;
          p_Var2->ptr[p_Var2->length] = '\0';
        }
        else {
          Strcat_charp(p_Var2,pcVar3);
        }
      }
      Strcat_charp(p_Var2,"\">");
      push_tag(obuf,p_Var2->ptr,1);
    }
    if ((hidden_img == (char *)0x0) && (obuf->img_alt != (Str)0x0)) {
      p_Var2 = Strnew_charp("<IMG_ALT SRC=\"");
      pcVar3 = html_quote(obuf->img_alt->ptr);
      Strcat_charp(p_Var2,pcVar3);
      Strcat_charp(p_Var2,"\">");
      push_tag(obuf,p_Var2->ptr,0x88);
    }
    if ((hidden_bold == (char *)0x0) && (obuf->fontstat[0] != '\0')) {
      push_tag(obuf,"<B>",7);
    }
    if ((hidden_italic == (char *)0x0) && (obuf->fontstat[2] != '\0')) {
      push_tag(obuf,"<I>",0x6d);
    }
    if ((hidden_under == (char *)0x0) && (obuf->fontstat[1] != '\0')) {
      push_tag(obuf,"<U>",0x41);
    }
    if ((hidden_strike == (char *)0x0) && (obuf->fontstat[3] != '\0')) {
      push_tag(obuf,"<S>",0x69);
    }
    if ((hidden_ins == (char *)0x0) && (obuf->fontstat[4] != '\0')) {
      push_tag(obuf,"<INS>",0x3f);
    }
  }
  return;
}



void do_blankline(html_feed_environ *h_env,readbuffer *obuf,int indent,int indent_incr,int width)

{
  if (h_env->blank_lines == 0) {
    flushline(h_env,obuf,indent,1,width);
  }
  return;
}



void purgeline(html_feed_environ *h_env)

{
  char *y;
  undefined4 *puVar1;
  Str x;
  int iVar2;
  Str tmp;
  char *q;
  char *p;
  
  if ((h_env->buf != (TextLineList *)0x0) && (h_env->blank_lines != 0)) {
    puVar1 = (undefined4 *)rpopValue((GeneralList *)h_env->buf);
    p = *(char **)*puVar1;
    x = Strnew();
    while (y = p, *p != '\0') {
      iVar2 = sloppy_parse_line(&p);
      if (iVar2 != 0) {
        Strcat_charp_n(x,y,(int)p - (int)y);
      }
    }
    appendTextLine(h_env->buf,x,0);
    h_env->blank_lines = h_env->blank_lines + -1;
  }
  return;
}



int close_effect0(readbuffer *obuf,int cmd)

{
  int iVar1;
  char *str;
  char *p;
  int i;
  
  i = obuf->tag_sp;
  do {
    iVar1 = i;
    i = iVar1 + -1;
    if (i < 0) break;
  } while (*(int *)(*(int *)((obuf->bp).fontstat + iVar1 * 4 + 0x10) + 4) != cmd);
  if (i < 0) {
    str = has_hidden_link(obuf,cmd);
    if (str == (char *)0x0) {
      iVar1 = 0;
    }
    else {
      passthrough(obuf,str,1);
      iVar1 = 1;
    }
  }
  else {
    obuf->tag_sp = obuf->tag_sp + -1;
    bcopy(obuf->tag_stack + iVar1,(obuf->bp).fontstat + iVar1 * 4 + 0x10,(obuf->tag_sp - i) * 4);
    iVar1 = 1;
  }
  return iVar1;
}



void close_anchor(html_feed_environ *h_env,readbuffer *obuf)

{
  Str p_Var1;
  int iVar2;
  bool bVar3;
  int is_erased;
  char *p;
  int i;
  
  if ((obuf->anchor).url != (char *)0x0) {
    p = (char *)0x0;
    bVar3 = false;
    i = obuf->tag_sp;
    do {
      iVar2 = i;
      i = iVar2 + -1;
      if (i < 0) break;
    } while (*(int *)(*(int *)((obuf->bp).fontstat + iVar2 * 4 + 0x10) + 4) != 1);
    if ((((i < 0) && (0 < (obuf->anchor).hseq)) && (0 < obuf->line->length)) &&
       (obuf->line->ptr[obuf->line->length + -1] == ' ')) {
      Strshrink(obuf->line,1);
      obuf->pos = obuf->pos + -1;
      bVar3 = true;
    }
    if ((-1 < i) || (p = has_hidden_link(obuf,1), p != (char *)0x0)) {
      if ((obuf->anchor).hseq < 1) {
        if (i < 0) {
          passthrough(obuf,p,1);
        }
        else {
          obuf->tag_sp = obuf->tag_sp + -1;
          bcopy(obuf->tag_stack + iVar2,(obuf->bp).fontstat + iVar2 * 4 + 0x10,
                (obuf->tag_sp - i) * 4);
        }
        bzero(&obuf->anchor,0x3c);
        return;
      }
      HTMLlineproc0(&DAT_080c9be3,h_env,1);
      Strcopy_charp_n(obuf->prevchar," ",1);
      bVar3 = false;
    }
    if (bVar3) {
      if (obuf->line->area_size <= obuf->line->length + 1) {
        Strgrow(obuf->line);
      }
      p_Var1 = obuf->line;
      iVar2 = p_Var1->length;
      obuf->line->ptr[iVar2] = ' ';
      p_Var1->length = iVar2 + 1;
      obuf->line->ptr[obuf->line->length] = '\0';
      obuf->pos = obuf->pos + 1;
    }
    push_tag(obuf,"</a>",2);
  }
  bzero(&obuf->anchor,0x3c);
  return;
}



void save_fonteffect(html_feed_environ *h_env,readbuffer *obuf)

{
  if (obuf->fontstat_sp < 5) {
    bcopy(obuf->fontstat,obuf->fontstat_stack[obuf->fontstat_sp],7);
  }
  obuf->fontstat_sp = obuf->fontstat_sp + 1;
  if (obuf->fontstat[0] != '\0') {
    push_tag(obuf,"</b>",8);
  }
  if (obuf->fontstat[2] != '\0') {
    push_tag(obuf,"</i>",0x6e);
  }
  if (obuf->fontstat[1] != '\0') {
    push_tag(obuf,"</u>",0x42);
  }
  if (obuf->fontstat[3] != '\0') {
    push_tag(obuf,"</s>",0x6a);
  }
  if (obuf->fontstat[4] != '\0') {
    push_tag(obuf,"</ins>",0x40);
  }
  bzero(obuf->fontstat,7);
  return;
}



void restore_fonteffect(html_feed_environ *h_env,readbuffer *obuf)

{
  if (0 < obuf->fontstat_sp) {
    obuf->fontstat_sp = obuf->fontstat_sp + -1;
  }
  if (obuf->fontstat_sp < 5) {
    bcopy(obuf->fontstat_stack[obuf->fontstat_sp],obuf->fontstat,7);
  }
  if (obuf->fontstat[0] != '\0') {
    push_tag(obuf,"<b>",7);
  }
  if (obuf->fontstat[2] != '\0') {
    push_tag(obuf,"<i>",0x6d);
  }
  if (obuf->fontstat[1] != '\0') {
    push_tag(obuf,"<u>",0x41);
  }
  if (obuf->fontstat[3] != '\0') {
    push_tag(obuf,"<s>",0x69);
  }
  if (obuf->fontstat[4] != '\0') {
    push_tag(obuf,"<ins>",0x3f);
  }
  return;
}



Str process_title(parsed_tag *tag)

{
  cur_title = Strnew();
  return (Str)0x0;
}



Str process_n_title(parsed_tag *tag)

{
  Str p_Var1;
  char *pcVar2;
  Str tmp;
  
  if (cur_title == (Str)0x0) {
    p_Var1 = (Str)0x0;
  }
  else {
    Strremovefirstspaces(cur_title);
    Strremovetrailingspaces(cur_title);
    pcVar2 = html_quote(cur_title->ptr);
    p_Var1 = Strnew_m_charp("<title_alt title=\"",pcVar2,&DAT_080c9bbb,0);
    cur_title = (Str)0x0;
  }
  return p_Var1;
}



void feed_title(char *str)

{
  int iVar1;
  Str p_Var2;
  char *y;
  
  if (cur_title != (Str)0x0) {
    while (*str != '\0') {
      if (*str == '&') {
        y = getescapecmd(&str);
        Strcat_charp(cur_title,y);
      }
      else if ((*str == '\n') || (*str == '\r')) {
        if (cur_title->area_size <= cur_title->length + 1) {
          Strgrow(cur_title);
        }
        p_Var2 = cur_title;
        iVar1 = cur_title->length;
        cur_title->ptr[iVar1] = ' ';
        p_Var2->length = iVar1 + 1;
        cur_title->ptr[cur_title->length] = '\0';
        str = str + 1;
      }
      else {
        if (cur_title->area_size <= cur_title->length + 1) {
          Strgrow(cur_title);
        }
        p_Var2 = cur_title;
        iVar1 = cur_title->length;
        cur_title->ptr[iVar1] = *str;
        p_Var2->length = iVar1 + 1;
        str = str + 1;
        cur_title->ptr[cur_title->length] = '\0';
      }
    }
  }
  return;
}



Str process_img(parsed_tag *tag,int width)

{
  bool bVar1;
  bool bVar2;
  bool bVar3;
  wc_ces f_ces;
  ParsedURL *current;
  Str p_Var4;
  int iVar5;
  parsed_tag *tag_00;
  Str p_Var6;
  char *pcVar7;
  int iVar8;
  wc_ces t_ces;
  bool bVar9;
  byte bVar10;
  char **value;
  ParsedURL u;
  Image image;
  char *r_1;
  Str tmp2;
  Str tmp;
  int ext_pre_int;
  int pre_int;
  int use_image;
  int ismap;
  int bottom;
  int top;
  int yoffset;
  int xoffset;
  int align;
  int i0;
  int w0;
  int n;
  int ni;
  int nw;
  int i;
  int w;
  char *t;
  char *s;
  char *r2;
  char *r;
  char *q;
  char *p;
  
  r2 = (char *)0x0;
  ni = 1;
  w0 = -1;
  i0 = -1;
  bVar2 = false;
  if ((activeImage == 0) || (displayImage == 0)) {
    bVar1 = false;
  }
  else {
    bVar1 = true;
  }
  bVar3 = false;
  p_Var4 = Strnew();
  iVar5 = parsedtag_get_value(tag,0x1f,&p);
  if (iVar5 == 0) {
    return p_Var4;
  }
  p = remove_space(p);
  q = (char *)0x0;
  parsedtag_get_value(tag,5,&q);
  t = q;
  parsedtag_get_value(tag,0x31,&t);
  w = -1;
  iVar5 = parsedtag_get_value(tag,0x26,&w);
  if (iVar5 != 0) {
    if (w < 0) {
      if (width < 1) {
        w = -1;
      }
      else {
        w = (int)ROUND(((double)w * pixel_per_char * (double)-width) / 100.0 + 0.5);
      }
    }
    if ((bVar1) && (0 < w)) {
      w = (int)ROUND((image_scale * (double)w) / 100.0 + 0.5);
      if (w == 0) {
        w = 1;
      }
      else if (0x800 < w) {
        w = 0x800;
      }
    }
  }
  if (bVar1) {
    i = -1;
    iVar5 = parsedtag_get_value(tag,0x11,&i);
    if (iVar5 != 0) {
      if (i < 1) {
        i = -1;
      }
      else {
        i = (int)ROUND((image_scale * (double)i) / 100.0 + 0.5);
        if (i == 0) {
          i = 1;
        }
        else if (0x800 < i) {
          i = 0x800;
        }
      }
    }
    align = -1;
    parsedtag_get_value(tag,4,&align);
    bVar2 = false;
    if (((tag->map != (uchar *)0x0) && (tag->map[0x2e] != 'K')) &&
       (tag->attrid[tag->map[0x2e]] != '\0')) {
      bVar2 = true;
    }
  }
  else {
    parsedtag_get_value(tag,0x11,&i);
  }
  r = (char *)0x0;
  value = &r;
  parsedtag_get_value(tag,0x22,value);
  if (((tag->map != (uchar *)0x0) && (tag->map[0x4a] != 'K')) &&
     (tag->attrid[tag->map[0x4a]] != '\0')) {
    bVar3 = true;
  }
  p_Var4 = Strnew_size(0x80);
  if (bVar1) {
    if (align == 1) {
      Strcat_charp(p_Var4,"<div_int align=left>");
    }
    else if (align == 2) {
      Strcat_charp(p_Var4,"<div_int align=right>");
    }
    else if (align == 0) {
      Strcat_charp(p_Var4,"<div_int align=center>");
    }
  }
  if (r != (char *)0x0) {
    r2 = strchr(r,0x23);
    s = "<form_int method=internal action=map>";
    tag_00 = parse_tag(&s,1);
    p_Var6 = process_form(tag_00);
    if (p_Var6 != (Str)0x0) {
      Strcat(p_Var4,p_Var6);
    }
    if (form_sp < 0) {
      iVar5 = -1;
    }
    else {
      iVar5 = form_stack[form_sp];
    }
    p_Var6 = Sprintf("<input_alt fid=\"%d\" type=hidden name=link value=\"",iVar5);
    Strcat(p_Var4,p_Var6);
    pcVar7 = r;
    if (r2 != (char *)0x0) {
      pcVar7 = r2 + 1;
    }
    pcVar7 = html_quote(pcVar7);
    Strcat_charp(p_Var4,pcVar7);
    iVar5 = cur_hseq;
    if (form_sp < 0) {
      value = (char **)0xffffffff;
    }
    else {
      value = (char **)form_stack[form_sp];
    }
    cur_hseq = cur_hseq + 1;
    p_Var6 = Sprintf("\"><input_alt hseq=\"%d\" fid=\"%d\" type=submit no_effect=true>",iVar5,value)
    ;
    Strcat(p_Var4,p_Var6);
  }
  current = cur_baseURL;
  f_ces = InnerCharset;
  if (bVar1) {
    w0 = w;
    i0 = i;
    if ((w < 0) || (i < 0)) {
      t_ces = (wc_ces)cur_document_charset;
      p_Var6 = Strnew_charp(p);
      p_Var6 = wc_Str_conv(p_Var6,f_ces,t_ces);
      parseURL2(p_Var6->ptr,&u,current);
      p_Var6 = parsedURL2Str(&u);
      image.url = p_Var6->ptr;
      pcVar7 = uncompressed_file_type(u.file,&image.ext);
      if (pcVar7 == (char *)0x0) {
        image.ext = filename_extension(u.file,1);
      }
      image.cache = (ImageCache *)0x0;
      image.width = (short)w;
      image.height = (short)i;
      value = (char **)0x1;
      image.cache = getImage(&image,cur_baseURL,1);
      if (((image.cache != (ImageCache *)0x0) && (0 < (image.cache)->width)) &&
         (0 < (image.cache)->height)) {
        w0 = (int)(image.cache)->width;
        i0 = (int)(image.cache)->height;
        i = i0;
        w = w0;
      }
      if (w < 0) {
        w = (int)ROUND(pixel_per_char * 8.0);
      }
      if (i < 0) {
        i = (int)ROUND(pixel_per_line);
      }
    }
    iVar5 = cur_iseq;
    if (w < 4) {
      nw = 1;
    }
    else {
      nw = (int)ROUND((double)(w + -3) / pixel_per_char + 1.0);
    }
    if (i < 4) {
      ni = 1;
    }
    else {
      ni = (int)ROUND((double)(i + -3) / pixel_per_line + 1.0);
    }
    cur_iseq = cur_iseq + 1;
    p_Var6 = Sprintf("<pre_int><img_alt hseq=\"%d\" src=\"",iVar5,value);
    Strcat(p_Var4,p_Var6);
    bVar9 = true;
  }
  else {
    if (w < 0) {
      w = (int)ROUND(pixel_per_char * 12.0);
    }
    if (w == 0) {
      nw = 1;
    }
    else {
      nw = (int)ROUND((double)(w + -1) / pixel_per_char + 1.0);
    }
    bVar9 = r != (char *)0x0;
    if (bVar9) {
      Strcat_charp(p_Var4,"<pre_int>");
    }
    Strcat_charp(p_Var4,"<img_alt src=\"");
  }
  pcVar7 = html_quote(p);
  Strcat_charp(p_Var4,pcVar7);
  Strcat_charp(p_Var4,"\"");
  if (t != (char *)0x0) {
    Strcat_charp(p_Var4," title=\"");
    pcVar7 = html_quote(t);
    Strcat_charp(p_Var4,pcVar7);
    Strcat_charp(p_Var4,"\"");
  }
  if (bVar1) {
    if (-1 < w0) {
      p_Var6 = Sprintf(" width=%d",w0);
      Strcat(p_Var4,p_Var6);
    }
    if (-1 < i0) {
      p_Var6 = Sprintf(" height=%d",i0);
      Strcat(p_Var4,p_Var6);
    }
    if (align == 5) {
      top = 0;
      bottom = ni + -1;
      yoffset = 0;
    }
    else if (align == 6) {
      top = ni + -1;
      bottom = 0;
      yoffset = (int)ROUND(pixel_per_line * (double)ni - (double)i);
    }
    else if (align == 4) {
      bottom = ni / 2;
      top = bottom;
      if (bottom * 2 == ni) {
        yoffset = (int)ROUND((pixel_per_line * (double)(ni + 1) - (double)i) / 2.0);
      }
      else {
        yoffset = (int)ROUND((pixel_per_line * (double)ni - (double)i) / 2.0);
      }
    }
    else {
      top = ni + -1;
      bottom = 0;
      if ((ni != 1) || (pixel_per_line * 1.0 <= (double)i)) {
        yoffset = (int)ROUND(pixel_per_line * (double)ni - (double)i);
        if (yoffset < -1) {
          yoffset = yoffset + 1;
        }
      }
      else {
        yoffset = 0;
      }
    }
    iVar5 = (int)ROUND((pixel_per_char * (double)nw - (double)w) / 2.0);
    if (iVar5 != 0) {
      p_Var6 = Sprintf(" xoffset=%d",iVar5);
      Strcat(p_Var4,p_Var6);
    }
    if (yoffset != 0) {
      p_Var6 = Sprintf(" yoffset=%d",yoffset);
      Strcat(p_Var4,p_Var6);
    }
    if (top != 0) {
      p_Var6 = Sprintf(" top_margin=%d",top);
      Strcat(p_Var4,p_Var6);
    }
    if (bottom != 0) {
      p_Var6 = Sprintf(" bottom_margin=%d",bottom);
      Strcat(p_Var4,p_Var6);
    }
    if (r != (char *)0x0) {
      Strcat_charp(p_Var4," usemap=\"");
      pcVar7 = r;
      if (r2 != (char *)0x0) {
        pcVar7 = r2 + 1;
      }
      pcVar7 = html_quote(pcVar7);
      Strcat_charp(p_Var4,pcVar7);
      Strcat_charp(p_Var4,"\"");
    }
    if (bVar2) {
      Strcat_charp(p_Var4," ismap");
    }
  }
  Strcat_charp(p_Var4,">");
  if (((q != (char *)0x0) && (*q == '\0')) && (ignore_null_img_alt != 0)) {
    q = (char *)0x0;
  }
  if (q != (char *)0x0) {
    n = wtf_strwidth((wc_uchar *)q);
    if (bVar1) {
      if (nw < n) {
        r_1 = q;
        n = 0;
        while (r_1 != (char *)0x0) {
          if (WcOption.use_wide == '\0') {
            bVar10 = WTF_WIDTH_MAP[(byte)*r_1] != '\0';
          }
          else {
            bVar10 = WTF_WIDTH_MAP[(byte)*r_1];
          }
          if (nw < (int)((uint)bVar10 + n)) break;
          r_1 = r_1 + WTF_LEN_MAP[(byte)*r_1];
          if (WcOption.use_wide == '\0') {
            bVar10 = WTF_WIDTH_MAP[(byte)*r_1] != '\0';
          }
          else {
            bVar10 = WTF_WIDTH_MAP[(byte)*r_1];
          }
          n = n + (uint)bVar10;
        }
        p_Var6 = Strnew_charp_n(q,(int)r_1 - (int)q);
        pcVar7 = html_quote(p_Var6->ptr);
        Strcat_charp(p_Var4,pcVar7);
      }
      else {
        pcVar7 = html_quote(q);
        Strcat_charp(p_Var4,pcVar7);
      }
    }
    else {
      pcVar7 = html_quote(q);
      Strcat_charp(p_Var4,pcVar7);
    }
    goto img_end;
  }
  if ((0 < w) && (0 < i)) {
    if ((w < 0x20) && (i < 0x30)) {
      n = 1;
      pcVar7 = strcasestr(p,"space");
      if ((pcVar7 == (char *)0x0) && (pcVar7 = strcasestr(p,"blank"), pcVar7 == (char *)0x0)) {
        if (i * w < 0x80) {
          Strcat_charp(p_Var4,"*");
        }
        else {
          if (!bVar9) {
            Strcat_charp(p_Var4,"<pre_int>");
            bVar9 = true;
          }
          push_symbol(p_Var4,',',symbol_width,1);
          n = symbol_width;
        }
      }
      else {
        Strcat_charp(p_Var4,"_");
      }
      goto img_end;
    }
    if ((200 < w) && (i < 0xd)) {
      if (!bVar9) {
        Strcat_charp(p_Var4,"<pre_int>");
        bVar9 = true;
      }
      w = (int)ROUND(((double)w / pixel_per_char) / (double)symbol_width);
      if (w < 1) {
        w = 1;
      }
      push_symbol(p_Var4,'\x1a',symbol_width,w);
      n = symbol_width * w;
      goto img_end;
    }
  }
  for (q = p; *q != '\0'; q = q + 1) {
  }
  for (; (p < q && (*q != '/')); q = q + -1) {
  }
  if (*q == '/') {
    q = q + 1;
  }
  if (p_Var4->area_size <= p_Var4->length + 1) {
    Strgrow(p_Var4);
  }
  iVar5 = p_Var4->length;
  p_Var4->ptr[iVar5] = '[';
  p_Var4->length = iVar5 + 1;
  p_Var4->ptr[p_Var4->length] = '\0';
  n = 1;
  p = q;
  for (; (*q != '\0' && ((((MYCTYPE_MAP[(byte)*q] & 0xc) != 0 || (*q == '_')) || (*q == '-'))));
      q = q + 1) {
    if (p_Var4->area_size <= p_Var4->length + 1) {
      Strgrow(p_Var4);
    }
    iVar5 = p_Var4->length;
    p_Var4->ptr[iVar5] = *q;
    p_Var4->length = iVar5 + 1;
    p_Var4->ptr[p_Var4->length] = '\0';
    iVar5 = n + 1;
    iVar8 = n + 2;
    n = iVar5;
    if (nw <= iVar8) break;
  }
  if (p_Var4->area_size <= p_Var4->length + 1) {
    Strgrow(p_Var4);
  }
  iVar5 = p_Var4->length;
  p_Var4->ptr[iVar5] = ']';
  p_Var4->length = iVar5 + 1;
  p_Var4->ptr[p_Var4->length] = '\0';
  n = n + 1;
img_end:
  if (bVar1) {
    for (; n < nw; n = n + 1) {
      if (p_Var4->area_size <= p_Var4->length + 1) {
        Strgrow(p_Var4);
      }
      iVar5 = p_Var4->length;
      p_Var4->ptr[iVar5] = ' ';
      p_Var4->length = iVar5 + 1;
      p_Var4->ptr[p_Var4->length] = '\0';
    }
  }
  Strcat_charp(p_Var4,"</img_alt>");
  if ((bVar9) && (!bVar3)) {
    Strcat_charp(p_Var4,"</pre_int>");
  }
  if (r != (char *)0x0) {
    Strcat_charp(p_Var4,"</input_alt>");
    process_n_form();
  }
  if ((bVar1) && ((uint)align < 3)) {
    Strcat_charp(p_Var4,"</div_int>");
  }
  return p_Var4;
}



Str process_anchor(parsed_tag *tag,char *tagbuf)

{
  int iVar1;
  Str p_Var2;
  Str tmp;
  
  iVar1 = cur_hseq;
  if (tag->need_reconstruct == '\0') {
    cur_hseq = cur_hseq + 1;
    p_Var2 = Sprintf("<a hseq=\"%d\"",iVar1);
    Strcat_charp(p_Var2,tagbuf + 2);
  }
  else {
    cur_hseq = cur_hseq + 1;
    p_Var2 = Sprintf("%d",iVar1);
    parsedtag_set_value(tag,0x45,p_Var2->ptr);
    p_Var2 = parsedtag2str(tag);
  }
  return p_Var2;
}



Str process_input(parsed_tag *tag)

{
  int iVar1;
  int iVar2;
  parsed_tag *tag_00;
  char *pcVar3;
  Str p_Var4;
  int iVar5;
  int iVar6;
  uint uVar7;
  char *s_1;
  int qlen;
  char *qq;
  Str tmp;
  char *s;
  char *p2;
  char *r;
  char *p;
  char *q;
  int ih;
  int iw;
  int z;
  int y;
  int x;
  int v;
  int w;
  int i;
  
  tmp = (Str)0x0;
  qq = "";
  qlen = 0;
  if ((form_sp < 0) || (form_stack[form_sp] < 0)) {
    s_1 = "<form_int method=internal action=none>";
    tag_00 = parse_tag(&s_1,1);
    tmp = process_form(tag_00);
  }
  if (tmp == (Str)0x0) {
    tmp = Strnew();
  }
  p = "text";
  parsedtag_get_value(tag,0x21,&p);
  q = (char *)0x0;
  parsedtag_get_value(tag,0x24,&q);
  r = "";
  parsedtag_get_value(tag,0x19,&r);
  w = 0x14;
  parsedtag_get_value(tag,0x1e,&w);
  i = 0x14;
  parsedtag_get_value(tag,0x16,&i);
  p2 = (char *)0x0;
  parsedtag_get_value(tag,5,&p2);
  if (((tag->map == (uchar *)0x0) || (tag->map[0xc] == 'K')) || (tag->attrid[tag->map[0xc]] == '\0')
     ) {
    x = 0;
  }
  else {
    x = 1;
  }
  if (((tag->map == (uchar *)0x0) || (tag->map[1] == 'K')) || (tag->attrid[tag->map[1]] == '\0')) {
    y = 0;
  }
  else {
    y = 1;
  }
  if (((tag->map == (uchar *)0x0) || (tag->map[0x2b] == 'K')) ||
     (tag->attrid[tag->map[0x2b]] == '\0')) {
    z = 0;
  }
  else {
    z = 1;
  }
  v = formtype(p);
  if (v == -1) {
    return (Str)0x0;
  }
  if (q == (char *)0x0) {
    switch(v) {
    case 2:
      q = "on";
      break;
    case 4:
    case 7:
    case 10:
      q = "SUBMIT";
      break;
    case 5:
      q = "RESET";
    }
  }
  if (v == 0xb) {
    q = (char *)0x0;
  }
  if (q != (char *)0x0) {
    qq = html_quote(q);
    qlen = wtf_strwidth((wc_uchar *)q);
  }
  Strcat_charp(tmp,"<pre_int>");
  if (v == 3) {
    if (tmp->area_size <= tmp->length + 1) {
      Strgrow(tmp);
    }
    iVar5 = tmp->length;
    tmp->ptr[iVar5] = '(';
    tmp->length = iVar5 + 1;
    tmp->ptr[tmp->length] = '\0';
  }
  else if (v < 4) {
    if (-1 < v) {
LAB_080635bc:
      if (tmp->area_size <= tmp->length + 1) {
        Strgrow(tmp);
      }
      iVar5 = tmp->length;
      tmp->ptr[iVar5] = '[';
      tmp->length = iVar5 + 1;
      tmp->ptr[tmp->length] = '\0';
    }
  }
  else if (v == 0xb) goto LAB_080635bc;
  iVar2 = i;
  iVar1 = w;
  pcVar3 = html_quote(r);
  iVar5 = cur_hseq;
  if (form_sp < 0) {
    iVar6 = -1;
  }
  else {
    iVar6 = form_stack[form_sp];
  }
  cur_hseq = cur_hseq + 1;
  p_Var4 = Sprintf("<input_alt hseq=\"%d\" fid=\"%d\" type=%s name=\"%s\" width=%d maxlength=%d value=\"%s\""
                   ,iVar5,iVar6,p,pcVar3,iVar1,iVar2,qq);
  Strcat(tmp,p_Var4);
  if (x != 0) {
    Strcat_charp(tmp," checked");
  }
  if (y != 0) {
    Strcat_charp(tmp," accept");
  }
  if (z != 0) {
    Strcat_charp(tmp," readonly");
  }
  if (tmp->area_size <= tmp->length + 1) {
    Strgrow(tmp);
  }
  iVar5 = tmp->length;
  tmp->ptr[iVar5] = '>';
  tmp->length = iVar5 + 1;
  tmp->ptr[tmp->length] = '\0';
  if (v == 6) {
    Strcat_charp(tmp,"</input_alt></pre_int>");
    return tmp;
  }
  if ((uint)v < 0xc) {
    uVar7 = 1 << ((byte)v & 0x1f);
    if ((uVar7 & 0x430) == 0) {
      if ((uVar7 & 0x803) == 0) {
        if ((uVar7 & 0x80) != 0) {
          s = (char *)0x0;
          parsedtag_get_value(tag,0x1f,&s);
          if (s != (char *)0x0) {
            pcVar3 = html_quote(s);
            p_Var4 = Sprintf("<img src=\"%s\"",pcVar3);
            Strcat(tmp,p_Var4);
            if (p2 != (char *)0x0) {
              pcVar3 = html_quote(p2);
              p_Var4 = Sprintf(" alt=\"%s\"",pcVar3);
              Strcat(tmp,p_Var4);
            }
            iVar5 = parsedtag_get_value(tag,0x26,&iw);
            if (iVar5 != 0) {
              p_Var4 = Sprintf(" width=\"%d\"",iw);
              Strcat(tmp,p_Var4);
            }
            iVar5 = parsedtag_get_value(tag,0x11,&ih);
            if (iVar5 != 0) {
              p_Var4 = Sprintf(" height=\"%d\"",ih);
              Strcat(tmp,p_Var4);
            }
            Strcat_charp(tmp," pre_int>");
            Strcat_charp(tmp,"</input_alt></pre_int>");
            return tmp;
          }
          goto LAB_08063920;
        }
      }
      else {
        Strcat_charp(tmp,"<u>");
      }
    }
    else {
LAB_08063920:
      Strcat_charp(tmp,"[");
    }
  }
  iVar5 = w;
  switch(v) {
  case 0:
  case 0xb:
    if (q == (char *)0x0) {
      for (i = 0; i < w; i = i + 1) {
        if (tmp->area_size <= tmp->length + 1) {
          Strgrow(tmp);
        }
        iVar5 = tmp->length;
        tmp->ptr[iVar5] = ' ';
        tmp->length = iVar5 + 1;
        tmp->ptr[tmp->length] = '\0';
      }
    }
    else {
      p_Var4 = Strnew_charp(q);
      p_Var4 = textfieldrep(p_Var4,iVar5);
      Strcat(tmp,p_Var4);
    }
    break;
  case 1:
    i = 0;
    if (q != (char *)0x0) {
      for (; (i < qlen && (i < w)); i = i + 1) {
        if (tmp->area_size <= tmp->length + 1) {
          Strgrow(tmp);
        }
        iVar5 = tmp->length;
        tmp->ptr[iVar5] = '*';
        tmp->length = iVar5 + 1;
        tmp->ptr[tmp->length] = '\0';
      }
    }
    for (; i < w; i = i + 1) {
      if (tmp->area_size <= tmp->length + 1) {
        Strgrow(tmp);
      }
      iVar5 = tmp->length;
      tmp->ptr[iVar5] = ' ';
      tmp->length = iVar5 + 1;
      tmp->ptr[tmp->length] = '\0';
    }
    break;
  case 2:
  case 3:
    if (x == 0) {
      if (tmp->area_size <= tmp->length + 1) {
        Strgrow(tmp);
      }
      iVar5 = tmp->length;
      tmp->ptr[iVar5] = ' ';
      tmp->length = iVar5 + 1;
      tmp->ptr[tmp->length] = '\0';
    }
    else {
      if (tmp->area_size <= tmp->length + 1) {
        Strgrow(tmp);
      }
      iVar5 = tmp->length;
      tmp->ptr[iVar5] = '*';
      tmp->length = iVar5 + 1;
      tmp->ptr[tmp->length] = '\0';
    }
    break;
  case 4:
  case 10:
    if (p2 == (char *)0x0) {
      Strcat_charp(tmp,qq);
    }
    else {
      pcVar3 = html_quote(p2);
      Strcat_charp(tmp,pcVar3);
    }
    break;
  case 5:
    Strcat_charp(tmp,qq);
  }
  if ((uint)v < 0xc) {
    uVar7 = 1 << ((byte)v & 0x1f);
    if ((uVar7 & 0x4b0) == 0) {
      if ((uVar7 & 0x803) != 0) {
        Strcat_charp(tmp,"</u>");
      }
    }
    else {
      Strcat_charp(tmp,"]");
    }
  }
  Strcat_charp(tmp,"</input_alt>");
  if (v == 3) {
    if (tmp->area_size <= tmp->length + 1) {
      Strgrow(tmp);
    }
    iVar5 = tmp->length;
    tmp->ptr[iVar5] = ')';
    tmp->length = iVar5 + 1;
    tmp->ptr[tmp->length] = '\0';
  }
  else {
    if (v < 4) {
      if (v < 0) goto LAB_08063ce1;
    }
    else if (v != 0xb) goto LAB_08063ce1;
    if (tmp->area_size <= tmp->length + 1) {
      Strgrow(tmp);
    }
    iVar5 = tmp->length;
    tmp->ptr[iVar5] = ']';
    tmp->length = iVar5 + 1;
    tmp->ptr[tmp->length] = '\0';
  }
LAB_08063ce1:
  Strcat_charp(tmp,"</pre_int>");
  return tmp;
}



Str process_select(parsed_tag *tag)

{
  int iVar1;
  int iVar2;
  parsed_tag *tag_00;
  char *pcVar3;
  int iVar4;
  char *s;
  char *p;
  Str tmp;
  
  tmp = (Str)0x0;
  if ((form_sp < 0) || (form_stack[form_sp] < 0)) {
    s = "<form_int method=internal action=none>";
    tag_00 = parse_tag(&s,1);
    tmp = process_form(tag_00);
  }
  p = "";
  parsedtag_get_value(tag,0x19,&p);
  cur_select = Strnew_charp(p);
  iVar1 = n_select;
  if (((tag->map == (uchar *)0x0) || (tag->map[0x18] == 'K')) ||
     (tag->attrid[tag->map[0x18]] == '\0')) {
    select_is_multiple = 0;
  }
  else {
    select_is_multiple = 1;
  }
  if (select_is_multiple == 0) {
    pcVar3 = html_quote(p);
    iVar2 = cur_hseq;
    if (form_sp < 0) {
      iVar4 = -1;
    }
    else {
      iVar4 = form_stack[form_sp];
    }
    cur_hseq = cur_hseq + 1;
    select_str = Sprintf("<pre_int>[<input_alt hseq=\"%d\" fid=\"%d\" type=select name=\"%s\" selectnumber=%d"
                         ,iVar2,iVar4,pcVar3,iVar1);
    Strcat_charp(select_str,">");
    if (n_select == max_select) {
      iVar1 = max_select << 4;
      max_select = max_select * 2;
      select_option = (FormSelectOption *)GC_realloc(select_option,iVar1);
    }
    select_option[n_select].first = (FormSelectOptionItem *)0x0;
    select_option[n_select].last = (FormSelectOptionItem *)0x0;
    cur_option_maxwidth = 0;
  }
  else {
    select_str = Strnew();
  }
  n_selectitem = 0;
  cur_option = (Str)0x0;
  cur_status = 0;
  return tmp;
}



Str process_n_select(void)

{
  Str p_Var1;
  FormItemList sitem;
  
  if (cur_select == (Str)0x0) {
    p_Var1 = (Str)0x0;
  }
  else {
    process_option();
    if (select_is_multiple == 0) {
      if (select_option[n_select].first != (FormSelectOptionItem *)0x0) {
        chooseSelectOption(&sitem,select_option[n_select].first);
        p_Var1 = textfieldrep(sitem.label,cur_option_maxwidth);
        Strcat(select_str,p_Var1);
      }
      Strcat_charp(select_str,"</input_alt>]</pre_int>");
      n_select = n_select + 1;
    }
    else {
      Strcat_charp(select_str,"<br>");
    }
    cur_select = (Str)0x0;
    n_selectitem = 0;
    p_Var1 = select_str;
  }
  return p_Var1;
}



void feed_select(char *str)

{
  Str p_Var1;
  char *y;
  int iVar2;
  char *q;
  parsed_tag *tag;
  char *p;
  int prev_status;
  Str tmp;
  
  tmp = Strnew();
  prev_status = cur_status;
  if (cur_select != (Str)0x0) {
    while (iVar2 = read_token(tmp,&str,&cur_status,0,0), iVar2 != 0) {
      if ((cur_status == 0) && (prev_status == 0)) {
        p = tmp->ptr;
        if ((*tmp->ptr == '<') && ((0 < tmp->length && (tmp->ptr[tmp->length + -1] == '>')))) {
          tag = parse_tag(&p,0);
          if ((tag != (parsed_tag *)0x0) && (tag->tagid == '1')) {
            process_option();
            cur_option = Strnew();
            iVar2 = parsedtag_get_value(tag,0x24,&q);
            if (iVar2 == 0) {
              cur_option_value = (Str)0x0;
            }
            else {
              cur_option_value = Strnew_charp(q);
            }
            iVar2 = parsedtag_get_value(tag,0x2a,&q);
            if (iVar2 == 0) {
              cur_option_label = (Str)0x0;
            }
            else {
              cur_option_label = Strnew_charp(q);
            }
            if (((tag->map == (uchar *)0x0) || (tag->map[0x29] == 'K')) ||
               (tag->attrid[tag->map[0x29]] == '\0')) {
              cur_option_selected = 0;
            }
            else {
              cur_option_selected = 1;
            }
            feed_select::prev_spaces = -1;
          }
        }
        else if (cur_option != (Str)0x0) {
          while (*p != '\0') {
            if (((MYCTYPE_MAP[(byte)*p] & 2) == 0) || (feed_select::prev_spaces == 0)) {
              feed_select::prev_spaces = (int)((MYCTYPE_MAP[(byte)*p] & 2) != 0);
              if (*p == '&') {
                y = getescapecmd(&p);
                Strcat_charp(cur_option,y);
              }
              else {
                if (cur_option->area_size <= cur_option->length + 1) {
                  Strgrow(cur_option);
                }
                p_Var1 = cur_option;
                iVar2 = cur_option->length;
                cur_option->ptr[iVar2] = *p;
                p_Var1->length = iVar2 + 1;
                p = p + 1;
                cur_option->ptr[cur_option->length] = '\0';
              }
            }
            else {
              p = p + 1;
              if (0 < feed_select::prev_spaces) {
                feed_select::prev_spaces = feed_select::prev_spaces + 1;
              }
            }
          }
        }
      }
    }
  }
  return;
}



void process_option(void)

{
  uint uVar1;
  int iVar2;
  char *pcVar3;
  char *pcVar4;
  int iVar5;
  Str p_Var6;
  char *pcVar7;
  int len;
  char end_char;
  char begin_char;
  
  begin_char = '[';
  end_char = ']';
  if ((cur_select != (Str)0x0) && (cur_option != (Str)0x0)) {
    while (0 < cur_option->length) {
      if (cur_option->length < 1) {
        uVar1 = 0;
      }
      else {
        uVar1 = (uint)(byte)cur_option->ptr[cur_option->length + -1];
      }
      if ((MYCTYPE_MAP[uVar1] & 2) == 0) break;
      Strshrink(cur_option,1);
    }
    if (cur_option_value == (Str)0x0) {
      cur_option_value = cur_option;
    }
    if (cur_option_label == (Str)0x0) {
      cur_option_label = cur_option;
    }
    if (select_is_multiple == 0) {
      iVar2 = wtf_strwidth((wc_uchar *)cur_option_label->ptr);
      if (cur_option_maxwidth < iVar2) {
        cur_option_maxwidth = iVar2;
      }
      addSelectOption(select_option + n_select,cur_option_value,cur_option_label,cur_option_selected
                     );
    }
    else {
      if (select_is_multiple == 0) {
        begin_char = '(';
        end_char = ')';
      }
      pcVar3 = html_quote(cur_option_value->ptr);
      pcVar4 = html_quote(cur_select->ptr);
      iVar2 = cur_hseq;
      if (select_is_multiple == 0) {
        pcVar7 = "radio";
      }
      else {
        pcVar7 = "checkbox";
      }
      if (form_sp < 0) {
        iVar5 = -1;
      }
      else {
        iVar5 = form_stack[form_sp];
      }
      cur_hseq = cur_hseq + 1;
      p_Var6 = Sprintf("<br><pre_int>%c<input_alt hseq=\"%d\" fid=\"%d\" type=%s name=\"%s\" value=\"%s\""
                       ,(int)begin_char,iVar2,iVar5,pcVar7,pcVar4,pcVar3);
      Strcat(select_str,p_Var6);
      if (cur_option_selected == 0) {
        Strcat_charp(select_str,"> </input_alt>");
      }
      else {
        Strcat_charp(select_str," checked>*</input_alt>");
      }
      if (select_str->area_size <= select_str->length + 1) {
        Strgrow(select_str);
      }
      p_Var6 = select_str;
      iVar2 = select_str->length;
      select_str->ptr[iVar2] = end_char;
      p_Var6->length = iVar2 + 1;
      select_str->ptr[select_str->length] = '\0';
      pcVar3 = html_quote(cur_option_label->ptr);
      Strcat_charp(select_str,pcVar3);
      Strcat_charp(select_str,"</pre_int>");
      n_selectitem = n_selectitem + 1;
    }
  }
  return;
}



Str process_textarea(parsed_tag *tag,int width)

{
  Str *pp_Var1;
  char *pcVar2;
  parsed_tag *tag_00;
  int iVar3;
  size_t sVar4;
  Str p_Var5;
  char *s;
  char *p;
  Str tmp;
  
  tmp = (Str)0x0;
  if ((form_sp < 0) || (form_stack[form_sp] < 0)) {
    s = "<form_int method=internal action=none>";
    tag_00 = parse_tag(&s,1);
    tmp = process_form(tag_00);
  }
  p = "";
  parsedtag_get_value(tag,0x19,&p);
  cur_textarea = Strnew_charp(p);
  cur_textarea_size = 0x14;
  iVar3 = parsedtag_get_value(tag,0xd,&p);
  if (iVar3 != 0) {
    cur_textarea_size = atoi(p);
    pcVar2 = p;
    sVar4 = strlen(p);
    if (pcVar2[sVar4 - 1] == '%') {
      cur_textarea_size = (cur_textarea_size * width) / 100 + -2;
    }
    if (cur_textarea_size < 1) {
      cur_textarea_size = 0x14;
    }
  }
  cur_textarea_rows = 1;
  iVar3 = parsedtag_get_value(tag,0x1c,&p);
  if (iVar3 != 0) {
    cur_textarea_rows = atoi(p);
    if (cur_textarea_rows < 1) {
      cur_textarea_rows = 1;
    }
  }
  if (((tag->map == (uchar *)0x0) || (tag->map[0x2b] == 'K')) ||
     (tag->attrid[tag->map[0x2b]] == '\0')) {
    cur_textarea_readonly = 0;
  }
  else {
    cur_textarea_readonly = 1;
  }
  if (max_textarea <= n_textarea) {
    iVar3 = max_textarea << 3;
    max_textarea = max_textarea * 2;
    textarea_str = (Str *)GC_realloc(textarea_str,iVar3);
  }
  pp_Var1 = textarea_str + n_textarea;
  p_Var5 = Strnew();
  *pp_Var1 = p_Var5;
  ignore_nl_textarea = 1;
  return tmp;
}



Str process_n_textarea(void)

{
  int iVar1;
  int iVar2;
  int iVar3;
  Str x;
  int iVar4;
  char *pcVar5;
  int iVar6;
  Str y;
  int i;
  Str tmp;
  
  if (cur_textarea == (Str)0x0) {
    x = (Str)0x0;
  }
  else {
    x = Strnew();
    iVar3 = n_textarea;
    iVar2 = cur_textarea_rows;
    iVar1 = cur_textarea_size;
    iVar4 = cur_textarea_rows + -1;
    pcVar5 = html_quote(cur_textarea->ptr);
    if (form_sp < 0) {
      iVar6 = -1;
    }
    else {
      iVar6 = form_stack[form_sp];
    }
    y = Sprintf("<pre_int>[<input_alt hseq=\"%d\" fid=\"%d\" type=textarea name=\"%s\" size=%d rows=%d top_margin=%d textareanumber=%d"
                ,cur_hseq,iVar6,pcVar5,iVar1,iVar2,iVar4,iVar3);
    Strcat(x,y);
    if (cur_textarea_readonly != 0) {
      Strcat_charp(x," readonly");
    }
    Strcat_charp(x,"><u>");
    for (i = 0; i < cur_textarea_size; i = i + 1) {
      if (x->area_size <= x->length + 1) {
        Strgrow(x);
      }
      iVar1 = x->length;
      x->ptr[iVar1] = ' ';
      x->length = iVar1 + 1;
      x->ptr[x->length] = '\0';
    }
    Strcat_charp(x,"</u></input_alt>]</pre_int>\n");
    cur_hseq = cur_hseq + 1;
    n_textarea = n_textarea + 1;
    cur_textarea = (Str)0x0;
  }
  return x;
}



void feed_textarea(char *str)

{
  Str p_Var1;
  int iVar2;
  char *y;
  
  if (cur_textarea != (Str)0x0) {
    if (ignore_nl_textarea != 0) {
      if (*str == '\r') {
        str = str + 1;
      }
      if (*str == '\n') {
        str = str + 1;
      }
    }
    ignore_nl_textarea = 0;
    while (*str != '\0') {
      if (*str == '&') {
        y = getescapecmd(&str);
        Strcat_charp(textarea_str[n_textarea],y);
      }
      else if (*str == '\n') {
        Strcat_charp(textarea_str[n_textarea],"\r\n");
        str = str + 1;
      }
      else if (*str != '\r') {
        if (textarea_str[n_textarea]->area_size <= textarea_str[n_textarea]->length + 1) {
          Strgrow(textarea_str[n_textarea]);
        }
        p_Var1 = textarea_str[n_textarea];
        iVar2 = p_Var1->length;
        textarea_str[n_textarea]->ptr[iVar2] = *str;
        p_Var1->length = iVar2 + 1;
        str = str + 1;
        textarea_str[n_textarea]->ptr[textarea_str[n_textarea]->length] = '\0';
      }
    }
  }
  return;
}



Str process_hr(parsed_tag *tag,int width,int indent_width)

{
  int iVar1;
  int x;
  int w;
  Str tmp;
  
  tmp = Strnew_charp("<nobr>");
  w = 0;
  x = 0;
  if (indent_width < width) {
    width = width - indent_width;
  }
  iVar1 = parsedtag_get_value(tag,0x26,&w);
  if (iVar1 == 0) {
    w = width;
  }
  else if (w < 0) {
    w = (-w * width) / 100;
  }
  else {
    w = (int)ROUND((double)w / pixel_per_char);
  }
  parsedtag_get_value(tag,4,&x);
  if (x == 1) {
    Strcat_charp(tmp,"<div_int align=left>");
  }
  else if (x == 2) {
    Strcat_charp(tmp,"<div_int align=right>");
  }
  else if (x == 0) {
    Strcat_charp(tmp,"<div_int align=center>");
  }
  w = w / symbol_width;
  if (w < 1) {
    w = 1;
  }
  push_symbol(tmp,'\x1a',symbol_width,w);
  Strcat_charp(tmp,"</div_int></nobr>");
  return tmp;
}



char * check_charset(char *p)

{
  wc_ces wVar1;
  
  wVar1 = wc_guess_charset(p,0);
  if (wVar1 == 0) {
    p = (char *)0x0;
  }
  return p;
}



char * check_accept_charset(char *ac)

{
  Str p_Var1;
  wc_ces wVar2;
  char *e;
  char *s;
  
  s = ac;
  while( true ) {
    if (*s == '\0') {
      return (char *)0x0;
    }
    for (; (*s != '\0' && (((MYCTYPE_MAP[(byte)*s] & 2) != 0 || (*s == ',')))); s = s + 1) {
    }
    if (*s == '\0') break;
    for (e = s; ((*e != '\0' && ((MYCTYPE_MAP[(byte)*e] & 2) == 0)) && (*e != ',')); e = e + 1) {
    }
    p_Var1 = Strnew_charp_n(s,(int)e - (int)s);
    wVar2 = wc_guess_charset(p_Var1->ptr,0);
    if (wVar2 != 0) {
      return ac;
    }
    s = e;
  }
  return (char *)0x0;
}



Str process_form_int(parsed_tag *tag,int fid)

{
  int iVar1;
  char *pcVar2;
  char *pcVar3;
  Str x;
  char *pcVar4;
  Str p_Var5;
  FormList **ppFVar6;
  form_list *pfVar7;
  Str tmp;
  char *n;
  char *tg;
  char *s;
  char *r;
  char *q;
  char *p;
  
  p = "get";
  parsedtag_get_value(tag,0x17,&p);
  q = "!CURRENT_URL!";
  parsedtag_get_value(tag,3,&q);
  r = (char *)0x0;
  iVar1 = parsedtag_get_value(tag,2,&r);
  if (iVar1 != 0) {
    r = check_accept_charset(r);
  }
  if (r == (char *)0x0) {
    iVar1 = parsedtag_get_value(tag,0xb,&r);
    if (iVar1 != 0) {
      r = check_charset(r);
    }
  }
  s = (char *)0x0;
  parsedtag_get_value(tag,0x10,&s);
  tg = (char *)0x0;
  parsedtag_get_value(tag,0x20,&tg);
  n = (char *)0x0;
  parsedtag_get_value(tag,0x19,&n);
  if (fid < 0) {
    form_max = form_max + 1;
    form_sp = form_sp + 1;
    fid = form_max;
  }
  else {
    if (form_max < fid) {
      form_max = fid;
    }
    form_sp = fid;
  }
  if (forms_size == 0) {
    forms_size = 10;
    forms = (FormList **)GC_malloc(0x28);
    form_stack = (int *)GC_malloc_atomic(forms_size << 2);
  }
  else if (forms_size <= form_max) {
    forms_size = forms_size + form_max;
    forms = (FormList **)GC_realloc(forms,forms_size * 4);
    form_stack = (int *)GC_realloc(form_stack,forms_size * 4);
  }
  form_stack[form_sp] = fid;
  if ((w3m_dump & 0x10U) == 0) {
    ppFVar6 = forms + fid;
    pfVar7 = newFormList(q,p,r,s,tg,n,(form_list *)0x0);
    *ppFVar6 = pfVar7;
    x = (Str)0x0;
  }
  else {
    pcVar2 = html_quote(p);
    pcVar3 = html_quote(q);
    x = Sprintf("<form_int fid=\"%d\" action=\"%s\" method=\"%s\"",fid,pcVar3,pcVar2);
    if (s != (char *)0x0) {
      pcVar4 = html_quote(s);
      p_Var5 = Sprintf(" enctype=\"%s\"",pcVar4,pcVar3,pcVar2);
      Strcat(x,p_Var5);
    }
    if (tg != (char *)0x0) {
      pcVar4 = html_quote(tg);
      p_Var5 = Sprintf(" target=\"%s\"",pcVar4,pcVar3,pcVar2);
      Strcat(x,p_Var5);
    }
    if (n != (char *)0x0) {
      pcVar4 = html_quote(n);
      p_Var5 = Sprintf(" name=\"%s\"",pcVar4,pcVar3,pcVar2);
      Strcat(x,p_Var5);
    }
    if (r != (char *)0x0) {
      pcVar2 = html_quote(r);
      p_Var5 = Sprintf(" accept-charset=\"%s\"",pcVar2);
      Strcat(x,p_Var5);
    }
    Strcat_charp(x,">");
  }
  return x;
}



Str process_form(parsed_tag *tag)

{
  Str p_Var1;
  
  p_Var1 = process_form_int(tag,-1);
  return p_Var1;
}



Str process_n_form(void)

{
  if (-1 < form_sp) {
    form_sp = form_sp + -1;
  }
  return (Str)0x0;
}



void clear_ignore_p_flag(int cmd,readbuffer *obuf)

{
  int i;
  
  i = 0;
  while( true ) {
    if (clear_ignore_p_flag::clear_flag_cmd[i] == 0) {
      return;
    }
    if (clear_ignore_p_flag::clear_flag_cmd[i] == cmd) break;
    i = i + 1;
  }
  obuf->flag = obuf->flag & 0xffffdfff;
  return;
}



void set_alignment(readbuffer *obuf,parsed_tag *tag)

{
  int iVar1;
  int align;
  long flag;
  
  flag = -1;
  iVar1 = parsedtag_get_value(tag,4,&align);
  if (iVar1 != 0) {
    if (align == 1) {
      flag = 0x10;
    }
    else if (align == 2) {
      flag = 0x40;
    }
    else if (align == 0) {
      flag = 0x20;
    }
  }
  if (obuf->flag_sp < 10) {
    iVar1 = obuf->flag_sp;
    obuf->flag_stack[iVar1] = obuf->flag & 0x70;
    obuf->flag_sp = iVar1 + 1;
  }
  if (flag != -1) {
    obuf->flag = obuf->flag & 0xffffff8f;
    obuf->flag = obuf->flag | flag;
  }
  return;
}



void process_idattr(readbuffer *obuf,int cmd,parsed_tag *tag)

{
  char *pcVar1;
  char *pcVar2;
  Str idtag;
  char *framename;
  char *id;
  
  id = (char *)0x0;
  framename = (char *)0x0;
  if (cmd != 0x1f) {
    parsedtag_get_value(tag,0x14,&id);
    parsedtag_get_value(tag,0x43,&framename);
    if (id != (char *)0x0) {
      if (framename == (char *)0x0) {
        pcVar1 = html_quote(id);
        idtag = Sprintf("<_id id=\"%s\">",pcVar1);
      }
      else {
        pcVar1 = html_quote(framename);
        pcVar2 = html_quote(id);
        idtag = Sprintf("<_id id=\"%s\" framename=\"%s\">",pcVar2,pcVar1);
      }
      push_tag(obuf,idtag->ptr,0x8a);
    }
  }
  return;
}



int ul_type(parsed_tag *tag,int default_type)

{
  int iVar1;
  char *p;
  
  iVar1 = parsedtag_get_value(tag,0x21,&p);
  if (iVar1 != 0) {
    iVar1 = strcasecmp(p,"disc");
    if (iVar1 == 0) {
      default_type = 100;
    }
    else {
      iVar1 = strcasecmp(p,"circle");
      if (iVar1 == 0) {
        default_type = 99;
      }
      else {
        iVar1 = strcasecmp(p,"square");
        if (iVar1 == 0) {
          default_type = 0x73;
        }
      }
    }
  }
  return default_type;
}



int getMetaRefreshParam(char *q,Str *refresh_uri)

{
  char *pcVar1;
  int iVar2;
  int iVar3;
  Str s_tmp;
  char *r;
  int refresh_interval;
  
  s_tmp = (Str)0x0;
  if ((q == (char *)0x0) || (refresh_uri == (Str *)0x0)) {
    iVar2 = 0;
  }
  else {
    iVar2 = atoi(q);
    if (iVar2 < 0) {
      iVar2 = 0;
    }
    else {
      while (*q != '\0') {
        iVar3 = strncasecmp(q,"url=",4);
        if (iVar3 == 0) {
          pcVar1 = q + 4;
          if (q[4] == '\"') {
            pcVar1 = q + 5;
          }
          q = pcVar1;
          for (r = q; ((*r != '\0' && ((MYCTYPE_MAP[(byte)*r] & 2) == 0)) && (*r != ';')); r = r + 1
              ) {
          }
          s_tmp = Strnew_charp_n(q,(int)r - (int)q);
          if (s_tmp->ptr[s_tmp->length + -1] == '\"') {
            s_tmp->length = s_tmp->length + -1;
            s_tmp->ptr[s_tmp->length] = '\0';
          }
          q = r;
        }
        for (; (*q != '\0' && (*q != ';')); q = q + 1) {
        }
        if (*q == ';') {
          q = q + 1;
        }
        for (; (*q != '\0' && (*q == ' ')); q = q + 1) {
        }
      }
      *refresh_uri = s_tmp;
    }
  }
  return iVar2;
}



int HTMLtagproc1(parsed_tag *tag,html_feed_environ *h_env)

{
  byte bVar1;
  short sVar2;
  environment *peVar3;
  int iVar4;
  char *pcVar5;
  size_t len;
  Str p_Var6;
  table *ptVar7;
  char *pcVar8;
  int iVar9;
  Str s_3;
  Str s_2;
  Str s_1;
  Str s;
  int refresh_interval;
  Str num;
  char *id;
  int cmd;
  int hseq;
  Str tmp;
  environment *envs;
  readbuffer *obuf;
  int width;
  int count;
  int z;
  int y;
  int x;
  int w;
  int i;
  char *r;
  char *q;
  char *p;
  
  obuf = h_env->obuf;
  envs = h_env->envs;
  id = (char *)0x0;
  bVar1 = tag->tagid;
  cmd = (int)bVar1;
  if ((((obuf->flag & 1U) != 0) && (0x31 < (uint)cmd)) && (((uint)cmd < 0x34 || (cmd - 0x80U < 2))))
  {
    return 1;
  }
  switch(cmd) {
  default:
    iVar9 = 0;
    break;
  case 1:
    if ((obuf->anchor).url != (char *)0x0) {
      close_anchor(h_env,obuf);
    }
    hseq = 0;
    iVar9 = parsedtag_get_value(tag,0x12,&p);
    if (iVar9 != 0) {
      p_Var6 = Strnew_charp(p);
      (obuf->anchor).url = p_Var6->ptr;
    }
    iVar9 = parsedtag_get_value(tag,0x20,&p);
    if (iVar9 != 0) {
      p_Var6 = Strnew_charp(p);
      (obuf->anchor).target = p_Var6->ptr;
    }
    iVar9 = parsedtag_get_value(tag,0x47,&p);
    if (iVar9 != 0) {
      p_Var6 = Strnew_charp(p);
      (obuf->anchor).referer = p_Var6->ptr;
    }
    iVar9 = parsedtag_get_value(tag,0x31,&p);
    if (iVar9 != 0) {
      p_Var6 = Strnew_charp(p);
      (obuf->anchor).title = p_Var6->ptr;
    }
    iVar9 = parsedtag_get_value(tag,0x32,&p);
    if (iVar9 != 0) {
      (obuf->anchor).accesskey = *p;
    }
    iVar9 = parsedtag_get_value(tag,0x45,&hseq);
    if (iVar9 != 0) {
      (obuf->anchor).hseq = hseq;
    }
    if ((hseq == 0) && ((obuf->anchor).url != (char *)0x0)) {
      (obuf->anchor).hseq = cur_hseq;
      tmp = process_anchor(tag,h_env->tagbuf->ptr);
      push_tag(obuf,tmp->ptr,1);
      iVar9 = 1;
    }
    else {
      iVar9 = 0;
    }
    break;
  case 2:
    close_anchor(h_env,obuf);
    iVar9 = 1;
    break;
  case 3:
    if ((obuf->flag & 0x2a0fU) == 0) {
      flushline(h_env,obuf,(int)envs[h_env->envc].indent,0,h_env->limit);
      do_blankline(h_env,obuf,(int)envs[h_env->envc].indent,0,h_env->limit);
    }
    HTMLlineproc0("<b>",h_env,1);
    set_alignment(obuf,tag);
    iVar9 = 1;
    break;
  case 4:
    HTMLlineproc0("</b>",h_env,1);
    if ((obuf->flag & 0xa0fU) == 0) {
      flushline(h_env,obuf,(int)envs[h_env->envc].indent,0,h_env->limit);
    }
    do_blankline(h_env,obuf,(int)envs[h_env->envc].indent,0,h_env->limit);
    if (0 < obuf->flag_sp) {
      obuf->flag = obuf->flag & 0xffffff8f;
      obuf->flag_sp = obuf->flag_sp + -1;
      obuf->flag = obuf->flag | obuf->flag_stack[obuf->flag_sp];
    }
    close_anchor(h_env,obuf);
    obuf->flag = obuf->flag | 0x2000;
    iVar9 = 1;
    break;
  case 5:
  case 0x22:
    if ((obuf->flag & 0x100U) != 0) {
      flushline(h_env,obuf,(int)envs[h_env->envc].indent,0,h_env->limit);
      if (0 < obuf->flag_sp) {
        obuf->flag = obuf->flag & 0xffffff8f;
        obuf->flag_sp = obuf->flag_sp + -1;
        obuf->flag = obuf->flag | obuf->flag_stack[obuf->flag_sp];
      }
      obuf->flag = obuf->flag & 0xfffffeff;
    }
    close_anchor(h_env,obuf);
    if ((obuf->flag & 0x2000U) == 0) {
      flushline(h_env,obuf,(int)envs[h_env->envc].indent,1,h_env->limit);
      do_blankline(h_env,obuf,(int)envs[h_env->envc].indent,0,h_env->limit);
    }
    obuf->flag = obuf->flag | 0x2000;
    if (cmd == 5) {
      set_alignment(obuf,tag);
      obuf->flag = obuf->flag | 0x100;
    }
    iVar9 = 1;
    break;
  case 6:
    flushline(h_env,obuf,(int)envs[h_env->envc].indent,1,h_env->limit);
    h_env->blank_lines = 0;
    iVar9 = 1;
    break;
  case 7:
    obuf->fontstat[0] = obuf->fontstat[0] + '\x01';
    if (obuf->fontstat[0] < '\x02') {
      iVar9 = 0;
    }
    else {
      iVar9 = 1;
    }
    break;
  case 8:
    if ((obuf->fontstat[0] == '\x01') && (iVar9 = close_effect0(obuf,7), iVar9 != 0)) {
      obuf->fontstat[0] = '\0';
    }
    if ((obuf->fontstat[0] < '\x01') ||
       (obuf->fontstat[0] = obuf->fontstat[0] + -1, obuf->fontstat[0] != '\0')) {
      iVar9 = 1;
    }
    else {
      iVar9 = 0;
    }
    break;
  case 9:
  case 0xc:
  case 0x17:
    if ((obuf->flag & 0x100U) != 0) {
      flushline(h_env,obuf,(int)envs[h_env->envc].indent,0,h_env->limit);
      if (0 < obuf->flag_sp) {
        obuf->flag = obuf->flag & 0xffffff8f;
        obuf->flag_sp = obuf->flag_sp + -1;
        obuf->flag = obuf->flag | obuf->flag_stack[obuf->flag_sp];
      }
      obuf->flag = obuf->flag & 0xfffffeff;
    }
    close_anchor(h_env,obuf);
    if ((((obuf->flag & 0x2000U) == 0) &&
        (flushline(h_env,obuf,(int)envs[h_env->envc].indent,0,h_env->limit),
        (obuf->flag & 0xa0fU) == 0)) && ((h_env->envc == 0 || (cmd == 0x17)))) {
      do_blankline(h_env,obuf,(int)envs[h_env->envc].indent,0,h_env->limit);
    }
    h_env->envc_real = h_env->envc_real + 1;
    if (h_env->envc_real < h_env->nenv) {
      h_env->envc = h_env->envc + 1;
      envs[h_env->envc].env = (uchar)cmd;
      envs[h_env->envc].count = 0;
      if (h_env->envc < 0xb) {
        envs[h_env->envc].indent = envs[h_env->envc + -1].indent + (char)IndentIncr;
      }
      else {
        envs[h_env->envc].indent = envs[h_env->envc + -1].indent;
      }
    }
    if (((cmd == 9) || (cmd == 0xc)) && (iVar9 = parsedtag_get_value(tag,0x28,&count), iVar9 != 0))
    {
      envs[h_env->envc].count = count + -1;
    }
    if (cmd == 0xc) {
      envs[h_env->envc].type = 0x31;
      iVar9 = parsedtag_get_value(tag,0x21,&p);
      if (iVar9 != 0) {
        envs[h_env->envc].type = (int)*p;
      }
    }
    peVar3 = envs;
    if (cmd == 9) {
      iVar9 = h_env->envc;
      iVar4 = ul_type(tag,0);
      peVar3[iVar9].type = iVar4;
    }
    flushline(h_env,obuf,(int)envs[h_env->envc].indent,0,h_env->limit);
    iVar9 = 1;
    break;
  case 10:
  case 0xd:
  case 0x12:
  case 0x18:
    if ((obuf->flag & 0x400U) != 0) {
      obuf->flag = obuf->flag & 0xfffffbff;
      HTMLlineproc0("</b>",h_env,1);
    }
    if ((obuf->flag & 0x100U) != 0) {
      flushline(h_env,obuf,(int)envs[h_env->envc].indent,0,h_env->limit);
      if (0 < obuf->flag_sp) {
        obuf->flag = obuf->flag & 0xffffff8f;
        obuf->flag_sp = obuf->flag_sp + -1;
        obuf->flag = obuf->flag | obuf->flag_stack[obuf->flag_sp];
      }
      obuf->flag = obuf->flag & 0xfffffeff;
    }
    close_anchor(h_env,obuf);
    if (0 < h_env->envc) {
      flushline(h_env,obuf,(int)envs[h_env->envc + -1].indent,0,h_env->limit);
      iVar9 = h_env->envc_real;
      h_env->envc_real = iVar9 + -1;
      if (iVar9 < h_env->nenv) {
        h_env->envc = h_env->envc + -1;
      }
      if (((obuf->flag & 0xa0fU) == 0) && (((h_env->envc == 0 || (cmd == 0x12)) || (cmd == 0x18))))
      {
        do_blankline(h_env,obuf,(int)envs[h_env->envc].indent,IndentIncr,h_env->limit);
        obuf->flag = obuf->flag | 0x2000;
      }
    }
    close_anchor(h_env,obuf);
    iVar9 = 1;
    break;
  case 0xb:
    if ((obuf->flag & 0x100U) != 0) {
      flushline(h_env,obuf,(int)envs[h_env->envc].indent,0,h_env->limit);
      if (0 < obuf->flag_sp) {
        obuf->flag = obuf->flag & 0xffffff8f;
        obuf->flag_sp = obuf->flag_sp + -1;
        obuf->flag = obuf->flag | obuf->flag_stack[obuf->flag_sp];
      }
      obuf->flag = obuf->flag & 0xfffffeff;
    }
    close_anchor(h_env,obuf);
    if ((obuf->flag & 0x400U) != 0) {
      obuf->flag = obuf->flag & 0xfffffbff;
      HTMLlineproc0("</b>",h_env,1);
    }
    if (h_env->envc < 1) {
      flushline(h_env,obuf,0,0,h_env->limit);
    }
    else {
      flushline(h_env,obuf,(int)envs[h_env->envc + -1].indent,0,h_env->limit);
      envs[h_env->envc].count = envs[h_env->envc].count + 1;
      iVar9 = parsedtag_get_value(tag,0x24,&p);
      if (iVar9 != 0) {
        count = atoi(p);
        if (count < 1) {
          envs[h_env->envc].count = 0;
        }
        else {
          envs[h_env->envc].count = count;
        }
      }
      peVar3 = envs;
      if (envs[h_env->envc].env == '\t') {
        iVar9 = h_env->envc;
        iVar4 = ul_type(tag,envs[h_env->envc].type);
        peVar3[iVar9].type = iVar4;
        for (i = 0; i < IndentIncr + -3; i = i + 1) {
          push_nchars(obuf,1,&DAT_080ca175,1,0);
        }
        tmp = Strnew();
        iVar9 = envs[h_env->envc].type;
        if (iVar9 == 100) {
          push_symbol(tmp,')',symbol_width,1);
        }
        else if (iVar9 == 0x73) {
          push_symbol(tmp,'+',symbol_width,1);
        }
        else if (iVar9 == 99) {
          push_symbol(tmp,'*',symbol_width,1);
        }
        else {
          iVar9 = h_env->envc_real + -1;
          push_symbol(tmp,(char)iVar9 + (char)(iVar9 / 9) * -9 + ' ',symbol_width,1);
        }
        if (symbol_width == 1) {
          push_nchars(obuf,1,&DAT_080ca175,1,0);
        }
        push_nchars(obuf,symbol_width,tmp->ptr,tmp->length,0);
        push_nchars(obuf,1,&DAT_080ca175,1,0);
        Strcopy_charp_n(obuf->prevchar," ",1);
      }
      else if (envs[h_env->envc].env == '\f') {
        iVar9 = parsedtag_get_value(tag,0x21,&p);
        if (iVar9 != 0) {
          envs[h_env->envc].type = (int)*p;
        }
        if (envs[h_env->envc].count < 1) {
          iVar9 = 0x31;
        }
        else {
          iVar9 = envs[h_env->envc].type;
        }
        if (iVar9 == 0x49) {
          num = romanNumeral(envs[h_env->envc].count);
          Strupper(num);
        }
        else if (iVar9 < 0x4a) {
          if (iVar9 == 0x41) {
            num = romanAlphabet(envs[h_env->envc].count);
            Strupper(num);
          }
          else {
LAB_08066848:
            num = Sprintf("%d",envs[h_env->envc].count);
          }
        }
        else if (iVar9 == 0x61) {
          num = romanAlphabet(envs[h_env->envc].count);
        }
        else {
          if (iVar9 != 0x69) goto LAB_08066848;
          num = romanNumeral(envs[h_env->envc].count);
        }
        if (IndentIncr < 4) {
          if (num->area_size <= num->length + 1) {
            Strgrow(num);
          }
          iVar9 = num->length;
          num->ptr[iVar9] = '.';
          num->length = iVar9 + 1;
          num->ptr[num->length] = '\0';
        }
        else {
          Strcat_charp(num,". ");
        }
        push_spaces(obuf,1,IndentIncr - num->length);
        push_nchars(obuf,num->length,num->ptr,num->length,0);
        if (3 < IndentIncr) {
          Strcopy_charp_n(obuf->prevchar," ",1);
        }
      }
      else {
        push_spaces(obuf,1,IndentIncr);
      }
    }
    obuf->flag = obuf->flag | 0x2000;
    iVar9 = 1;
    break;
  case 0xe:
    close_anchor(h_env,obuf);
    process_title(tag);
    obuf->flag = obuf->flag | 0x4000;
    obuf->end_tag = '\x0f';
    iVar9 = 1;
    break;
  case 0xf:
    if ((obuf->flag & 0x4000U) == 0) {
      iVar9 = 1;
    }
    else {
      obuf->flag = obuf->flag & 0xffffbfff;
      obuf->end_tag = '\0';
      tmp = process_n_title(tag);
      if (tmp != (Str)0x0) {
        HTMLlineproc0(tmp->ptr,h_env,1);
      }
      iVar9 = 1;
    }
    break;
  case 0x10:
    close_anchor(h_env,obuf);
    tmp = process_hr(tag,h_env->limit,(int)envs[h_env->envc].indent);
    HTMLlineproc0(tmp->ptr,h_env,1);
    Strcopy_charp_n(obuf->prevchar," ",1);
    iVar9 = 1;
    break;
  case 0x11:
    if ((obuf->flag & 0x100U) != 0) {
      flushline(h_env,obuf,(int)envs[h_env->envc].indent,0,h_env->limit);
      if (0 < obuf->flag_sp) {
        obuf->flag = obuf->flag & 0xffffff8f;
        obuf->flag_sp = obuf->flag_sp + -1;
        obuf->flag = obuf->flag | obuf->flag_stack[obuf->flag_sp];
      }
      obuf->flag = obuf->flag & 0xfffffeff;
    }
    close_anchor(h_env,obuf);
    if (((obuf->flag & 0x2000U) == 0) &&
       (flushline(h_env,obuf,(int)envs[h_env->envc].indent,0,h_env->limit),
       (obuf->flag & 0xa0fU) == 0)) {
      do_blankline(h_env,obuf,(int)envs[h_env->envc].indent,0,h_env->limit);
    }
    h_env->envc_real = h_env->envc_real + 1;
    if (h_env->envc_real < h_env->nenv) {
      h_env->envc = h_env->envc + 1;
      envs[h_env->envc].env = (uchar)cmd;
      envs[h_env->envc].count = 0;
      if (h_env->envc < 0xb) {
        envs[h_env->envc].indent = envs[h_env->envc + -1].indent + (char)IndentIncr;
      }
      else {
        envs[h_env->envc].indent = envs[h_env->envc + -1].indent;
      }
    }
    if (((tag->map != (uchar *)0x0) && (tag->map[0x27] != 'K')) &&
       (tag->attrid[tag->map[0x27]] != '\0')) {
      envs[h_env->envc].env = 0x85;
    }
    obuf->flag = obuf->flag | 0x2000;
    iVar9 = 1;
    break;
  case 0x13:
    if ((obuf->flag & 0x100U) != 0) {
      flushline(h_env,obuf,(int)envs[h_env->envc].indent,0,h_env->limit);
      if (0 < obuf->flag_sp) {
        obuf->flag = obuf->flag & 0xffffff8f;
        obuf->flag_sp = obuf->flag_sp + -1;
        obuf->flag = obuf->flag | obuf->flag_stack[obuf->flag_sp];
      }
      obuf->flag = obuf->flag & 0xfffffeff;
    }
    close_anchor(h_env,obuf);
    if (((h_env->envc == 0) ||
        (((h_env->envc_real < h_env->nenv && (envs[h_env->envc].env != '\x11')) &&
         (envs[h_env->envc].env != 0x85)))) &&
       (h_env->envc_real = h_env->envc_real + 1, h_env->envc_real < h_env->nenv)) {
      h_env->envc = h_env->envc + 1;
      envs[h_env->envc].env = '\x11';
      envs[h_env->envc].count = 0;
      if (h_env->envc < 0xb) {
        envs[h_env->envc].indent = envs[h_env->envc + -1].indent + (char)IndentIncr;
      }
      else {
        envs[h_env->envc].indent = envs[h_env->envc + -1].indent;
      }
    }
    if (0 < h_env->envc) {
      flushline(h_env,obuf,(int)envs[h_env->envc + -1].indent,0,h_env->limit);
    }
    if ((obuf->flag & 0x400U) == 0) {
      HTMLlineproc0("<b>",h_env,1);
      obuf->flag = obuf->flag | 0x400;
    }
    obuf->flag = obuf->flag | 0x2000;
    iVar9 = 1;
    break;
  case 0x14:
    if ((obuf->flag & 0x100U) != 0) {
      flushline(h_env,obuf,(int)envs[h_env->envc].indent,0,h_env->limit);
      if (0 < obuf->flag_sp) {
        obuf->flag = obuf->flag & 0xffffff8f;
        obuf->flag_sp = obuf->flag_sp + -1;
        obuf->flag = obuf->flag | obuf->flag_stack[obuf->flag_sp];
      }
      obuf->flag = obuf->flag & 0xfffffeff;
    }
    close_anchor(h_env,obuf);
    if ((obuf->flag & 0x400U) != 0) {
      obuf->flag = obuf->flag & 0xfffffbff;
      HTMLlineproc0("</b>",h_env,1);
    }
    if (envs[h_env->envc].env == 0x85) {
      if ((short)envs[h_env->envc].indent < obuf->pos) {
        flushline(h_env,obuf,(int)envs[h_env->envc].indent,0,h_env->limit);
      }
      else {
        push_spaces(obuf,1,(int)envs[h_env->envc].indent - (int)obuf->pos);
      }
    }
    else {
      flushline(h_env,obuf,(int)envs[h_env->envc].indent,0,h_env->limit);
    }
    iVar9 = 1;
    break;
  case 0x15:
    if (((tag->map == (uchar *)0x0) || (tag->map[0x42] == 'K')) ||
       (tag->attrid[tag->map[0x42]] == '\0')) {
      x = 0;
    }
    else {
      x = 1;
    }
    if ((obuf->flag & 0x100U) != 0) {
      flushline(h_env,obuf,(int)envs[h_env->envc].indent,0,h_env->limit);
      if (0 < obuf->flag_sp) {
        obuf->flag = obuf->flag & 0xffffff8f;
        obuf->flag_sp = obuf->flag_sp + -1;
        obuf->flag = obuf->flag | obuf->flag_stack[obuf->flag_sp];
      }
      obuf->flag = obuf->flag & 0xfffffeff;
    }
    close_anchor(h_env,obuf);
    if ((obuf->flag & 0x2000U) == 0) {
      flushline(h_env,obuf,(int)envs[h_env->envc].indent,0,h_env->limit);
      if (x == 0) {
        do_blankline(h_env,obuf,(int)envs[h_env->envc].indent,0,h_env->limit);
      }
    }
    else {
      fillline(obuf,(int)envs[h_env->envc].indent);
    }
    obuf->flag = obuf->flag | 0x2001;
    iVar9 = 1;
    break;
  case 0x16:
    flushline(h_env,obuf,(int)envs[h_env->envc].indent,0,h_env->limit);
    if ((obuf->flag & 0x2000U) == 0) {
      do_blankline(h_env,obuf,(int)envs[h_env->envc].indent,0,h_env->limit);
      obuf->flag = obuf->flag | 0x2000;
      h_env->blank_lines = h_env->blank_lines + 1;
    }
    obuf->flag = obuf->flag & 0xfffffffe;
    close_anchor(h_env,obuf);
    iVar9 = 1;
    break;
  case 0x19:
    tmp = process_img(tag,h_env->limit);
    HTMLlineproc0(tmp->ptr,h_env,1);
    iVar9 = 1;
    break;
  case 0x1a:
  case 0x1c:
  case 0x1e:
    if ((obuf->flag & 0x100U) != 0) {
      flushline(h_env,obuf,(int)envs[h_env->envc].indent,0,h_env->limit);
      if (0 < obuf->flag_sp) {
        obuf->flag = obuf->flag & 0xffffff8f;
        obuf->flag_sp = obuf->flag_sp + -1;
        obuf->flag = obuf->flag | obuf->flag_stack[obuf->flag_sp];
      }
      obuf->flag = obuf->flag & 0xfffffeff;
    }
    close_anchor(h_env,obuf);
    if ((obuf->flag & 0x2000U) == 0) {
      flushline(h_env,obuf,(int)envs[h_env->envc].indent,0,h_env->limit);
      do_blankline(h_env,obuf,(int)envs[h_env->envc].indent,0,h_env->limit);
    }
    obuf->flag = obuf->flag | 0x2008;
    if (cmd == 0x1c) {
      obuf->end_tag = '\x1d';
    }
    else if (cmd == 0x1e) {
      obuf->end_tag = 0x91;
    }
    else if (cmd == 0x1a) {
      obuf->end_tag = '\x1b';
    }
    iVar9 = 1;
    break;
  case 0x1b:
  case 0x1d:
    if ((obuf->flag & 0x100U) != 0) {
      flushline(h_env,obuf,(int)envs[h_env->envc].indent,0,h_env->limit);
      if (0 < obuf->flag_sp) {
        obuf->flag = obuf->flag & 0xffffff8f;
        obuf->flag_sp = obuf->flag_sp + -1;
        obuf->flag = obuf->flag | obuf->flag_stack[obuf->flag_sp];
      }
      obuf->flag = obuf->flag & 0xfffffeff;
    }
    close_anchor(h_env,obuf);
    if ((obuf->flag & 0x2000U) == 0) {
      flushline(h_env,obuf,(int)envs[h_env->envc].indent,0,h_env->limit);
      do_blankline(h_env,obuf,(int)envs[h_env->envc].indent,0,h_env->limit);
      obuf->flag = obuf->flag | 0x2000;
    }
    obuf->flag = obuf->flag & 0xfffffff7;
    obuf->end_tag = '\0';
    iVar9 = 1;
    break;
  case 0x1f:
    close_anchor(h_env,obuf);
    obuf->table_level = obuf->table_level + 1;
    if (obuf->table_level < 0x14) {
      w = 0;
      x = 2;
      y = 1;
      z = 0;
      width = 0;
      if (((tag->map != (uchar *)0x0) && (tag->map[8] != 'K')) && (tag->attrid[tag->map[8]] != '\0')
         ) {
        iVar9 = parsedtag_get_value(tag,8,&w);
        if (iVar9 == 0) {
          w = 1;
        }
        else if (w < 3) {
          if (w < 0) {
            w = 1;
          }
        }
        else {
          w = 2;
        }
      }
      iVar9 = parsedtag_get_value(tag,0x26,&i);
      if (iVar9 != 0) {
        if (obuf->table_level == 0) {
          if (i < 0) {
            width = (((int)envs[h_env->envc].indent - h_env->limit) * i) / 100;
          }
          else {
            width = (int)ROUND((double)i / pixel_per_char);
          }
        }
        else {
          width = i;
          if (-1 < i) {
            width = (int)ROUND((double)i / pixel_per_char);
          }
        }
      }
      if (((tag->map != (uchar *)0x0) && (tag->map[0x44] != 'K')) &&
         (tag->attrid[tag->map[0x44]] != '\0')) {
        w = 3;
      }
      parsedtag_get_value(tag,10,&x);
      parsedtag_get_value(tag,9,&y);
      parsedtag_get_value(tag,0x25,&z);
      parsedtag_get_value(tag,0x14,&id);
      sVar2 = obuf->table_level;
      ptVar7 = begin_table(w,x,y,z);
      tables[sVar2] = ptVar7;
      if (id != (char *)0x0) {
        ptVar7 = tables[obuf->table_level];
        p_Var6 = Strnew_charp(id);
        ptVar7->id = p_Var6;
      }
      table_mode[obuf->table_level].pre_mode = 0;
      table_mode[obuf->table_level].indent_level = '\0';
      table_mode[obuf->table_level].nobr_level = '\0';
      table_mode[obuf->table_level].caption = '\0';
      table_mode[obuf->table_level].end_tag = '\0';
      tables[obuf->table_level]->total_width = width;
      iVar9 = 1;
    }
    else {
      iVar9 = 0;
    }
    break;
  case 0x20:
    iVar9 = 1;
    break;
  case 0x21:
    q = (char *)0x0;
    p = (char *)0x0;
    parsedtag_get_value(tag,0x13,&p);
    parsedtag_get_value(tag,0xf,&q);
    if ((((p == (char *)0x0) || (q == (char *)0x0)) ||
        (iVar9 = strcasecmp(p,"Content-Type"), iVar9 != 0)) ||
       (q = strcasestr(q,"charset"), q == (char *)0x0)) {
      if (((p != (char *)0x0) && (q != (char *)0x0)) &&
         (iVar9 = strcasecmp(p,"refresh"), iVar9 == 0)) {
        tmp = (Str)0x0;
        iVar9 = getMetaRefreshParam(q,&tmp);
        if (tmp == (Str)0x0) {
          if (0 < iVar9) {
            tmp = Sprintf("Refresh (%d sec)",iVar9);
          }
        }
        else {
          q = html_quote(tmp->ptr);
          tmp = Sprintf("Refresh (%d sec) <a href=\"%s\">%s</a>",iVar9,q,q);
        }
        if (tmp != (Str)0x0) {
          HTMLlineproc0(tmp->ptr,h_env,1);
          do_blankline(h_env,obuf,(int)envs[h_env->envc].indent,0,h_env->limit);
          if ((is_redisplay == 0) && (((obuf->flag & 0x10000U) == 0 || (RenderFrame == '\0')))) {
            tag->need_reconstruct = '\x01';
            return 0;
          }
        }
      }
    }
    else {
      q = q + 7;
      while ((*q != '\0' && ((MYCTYPE_MAP[(byte)*q] & 2) != 0))) {
        q = q + 1;
      }
      if (*q == '=') {
        do {
          q = q + 1;
          if (*q == '\0') break;
        } while ((MYCTYPE_MAP[(byte)*q] & 2) != 0);
        meta_charset = wc_guess_charset(q,0);
      }
    }
    iVar9 = 1;
    break;
  case 0x23:
    r = (char *)0x0;
    q = (char *)0x0;
    parsedtag_get_value(tag,0x1f,&q);
    parsedtag_get_value(tag,0x19,&r);
    if (q != (char *)0x0) {
      q = html_quote(q);
      iVar9 = cur_hseq;
      cur_hseq = cur_hseq + 1;
      p_Var6 = Sprintf("<a hseq=\"%d\" href=\"%s\">",iVar9,q);
      push_tag(obuf,p_Var6->ptr,1);
      if (r != (char *)0x0) {
        q = html_quote(r);
      }
      len = strlen(q);
      pcVar5 = q;
      iVar9 = wtf_strwidth((wc_uchar *)q);
      push_nchars(obuf,iVar9,pcVar5,len,0);
      push_tag(obuf,"</a>",2);
    }
    flushline(h_env,obuf,(int)envs[h_env->envc].indent,0,h_env->limit);
    iVar9 = 0;
    break;
  case 0x24:
    h_env->envc_real = h_env->envc_real + 1;
    if (h_env->envc_real < h_env->nenv) {
      h_env->envc = h_env->envc + 1;
      envs[h_env->envc].env = bVar1;
      envs[h_env->envc].count = 0;
      if (h_env->envc < 0xb) {
        envs[h_env->envc].indent = envs[h_env->envc + -1].indent + (char)IndentIncr;
      }
      else {
        envs[h_env->envc].indent = envs[h_env->envc + -1].indent;
      }
    }
    push_nchars(obuf,9,"--FRAME--",9,0);
    flushline(h_env,obuf,(int)envs[h_env->envc].indent,0,h_env->limit);
    iVar9 = 0;
    break;
  case 0x25:
    if (0 < h_env->envc) {
      iVar9 = h_env->envc_real;
      h_env->envc_real = iVar9 + -1;
      if (iVar9 < h_env->nenv) {
        h_env->envc = h_env->envc + -1;
      }
      flushline(h_env,obuf,(int)envs[h_env->envc].indent,0,h_env->limit);
    }
    iVar9 = 0;
    break;
  case 0x26:
    if ((obuf->flag & 0x100U) != 0) {
      flushline(h_env,obuf,(int)envs[h_env->envc].indent,0,h_env->limit);
      if (0 < obuf->flag_sp) {
        obuf->flag = obuf->flag & 0xffffff8f;
        obuf->flag_sp = obuf->flag_sp + -1;
        obuf->flag = obuf->flag | obuf->flag_stack[obuf->flag_sp];
      }
      obuf->flag = obuf->flag & 0xfffffeff;
    }
    close_anchor(h_env,obuf);
    if ((obuf->flag & 0x2a0fU) == 0) {
      flushline(h_env,obuf,(int)envs[h_env->envc].indent,0,h_env->limit);
    }
    if (obuf->flag_sp < 10) {
      iVar9 = obuf->flag_sp;
      obuf->flag_stack[iVar9] = obuf->flag & 0x70;
      obuf->flag_sp = iVar9 + 1;
    }
    obuf->flag = obuf->flag & 0xffffff8f;
    obuf->flag = obuf->flag | 0x20;
    iVar9 = 1;
    break;
  case 0x27:
    if ((obuf->flag & 0x100U) != 0) {
      flushline(h_env,obuf,(int)envs[h_env->envc].indent,0,h_env->limit);
      if (0 < obuf->flag_sp) {
        obuf->flag = obuf->flag & 0xffffff8f;
        obuf->flag_sp = obuf->flag_sp + -1;
        obuf->flag = obuf->flag | obuf->flag_stack[obuf->flag_sp];
      }
      obuf->flag = obuf->flag & 0xfffffeff;
    }
    close_anchor(h_env,obuf);
    if ((obuf->flag & 0xa0fU) == 0) {
      flushline(h_env,obuf,(int)envs[h_env->envc].indent,0,h_env->limit);
    }
    if (0 < obuf->flag_sp) {
      obuf->flag = obuf->flag & 0xffffff8f;
      obuf->flag_sp = obuf->flag_sp + -1;
      obuf->flag = obuf->flag | obuf->flag_stack[obuf->flag_sp];
    }
    iVar9 = 1;
    break;
  case 0x28:
  case 0x29:
  case 0x8a:
    iVar9 = 1;
    break;
  case 0x2a:
    if ((obuf->flag & 0x100U) != 0) {
      flushline(h_env,obuf,(int)envs[h_env->envc].indent,0,h_env->limit);
      if (0 < obuf->flag_sp) {
        obuf->flag = obuf->flag & 0xffffff8f;
        obuf->flag_sp = obuf->flag_sp + -1;
        obuf->flag = obuf->flag | obuf->flag_stack[obuf->flag_sp];
      }
      obuf->flag = obuf->flag & 0xfffffeff;
    }
    close_anchor(h_env,obuf);
    if ((obuf->flag & 0x2000U) == 0) {
      flushline(h_env,obuf,(int)envs[h_env->envc].indent,0,h_env->limit);
    }
    tmp = process_form(tag);
    if (tmp != (Str)0x0) {
      HTMLlineproc0(tmp->ptr,h_env,1);
    }
    iVar9 = 1;
    break;
  case 0x2b:
    if ((obuf->flag & 0x100U) != 0) {
      flushline(h_env,obuf,(int)envs[h_env->envc].indent,0,h_env->limit);
      if (0 < obuf->flag_sp) {
        obuf->flag = obuf->flag & 0xffffff8f;
        obuf->flag_sp = obuf->flag_sp + -1;
        obuf->flag = obuf->flag | obuf->flag_stack[obuf->flag_sp];
      }
      obuf->flag = obuf->flag & 0xfffffeff;
    }
    close_anchor(h_env,obuf);
    flushline(h_env,obuf,(int)envs[h_env->envc].indent,0,h_env->limit);
    obuf->flag = obuf->flag | 0x2000;
    process_n_form();
    iVar9 = 1;
    break;
  case 0x2c:
    close_anchor(h_env,obuf);
    tmp = process_input(tag);
    if (tmp != (Str)0x0) {
      HTMLlineproc0(tmp->ptr,h_env,1);
    }
    iVar9 = 1;
    break;
  case 0x2d:
    close_anchor(h_env,obuf);
    tmp = process_textarea(tag,h_env->limit);
    if (tmp != (Str)0x0) {
      HTMLlineproc0(tmp->ptr,h_env,1);
    }
    obuf->flag = obuf->flag | 0x800;
    obuf->end_tag = '.';
    iVar9 = 1;
    break;
  case 0x2e:
    obuf->flag = obuf->flag & 0xfffff7ff;
    obuf->end_tag = '\0';
    tmp = process_n_textarea();
    if (tmp != (Str)0x0) {
      HTMLlineproc0(tmp->ptr,h_env,1);
    }
    iVar9 = 1;
    break;
  case 0x2f:
    close_anchor(h_env,obuf);
    tmp = process_select(tag);
    if (tmp != (Str)0x0) {
      HTMLlineproc0(tmp->ptr,h_env,1);
    }
    obuf->flag = obuf->flag | 0x1000;
    obuf->end_tag = '0';
    iVar9 = 1;
    break;
  case 0x30:
    obuf->flag = obuf->flag & 0xffffefff;
    obuf->end_tag = '\0';
    tmp = process_n_select();
    if (tmp != (Str)0x0) {
      HTMLlineproc0(tmp->ptr,h_env,1);
    }
    iVar9 = 1;
    break;
  case 0x31:
    iVar9 = 1;
    break;
  case 0x32:
    obuf->flag = obuf->flag | 0x80;
    obuf->nobr_level = obuf->nobr_level + 1;
    iVar9 = 0;
    break;
  case 0x33:
    if (0 < obuf->nobr_level) {
      obuf->nobr_level = obuf->nobr_level + -1;
    }
    if (obuf->nobr_level == 0) {
      obuf->flag = obuf->flag & 0xffffff7f;
    }
    iVar9 = 0;
    break;
  case 0x34:
    if ((obuf->flag & 0x100U) != 0) {
      flushline(h_env,obuf,(int)envs[h_env->envc].indent,0,h_env->limit);
      if (0 < obuf->flag_sp) {
        obuf->flag = obuf->flag & 0xffffff8f;
        obuf->flag_sp = obuf->flag_sp + -1;
        obuf->flag = obuf->flag | obuf->flag_stack[obuf->flag_sp];
      }
      obuf->flag = obuf->flag & 0xfffffeff;
    }
    close_anchor(h_env,obuf);
    if ((obuf->flag & 0x2000U) == 0) {
      flushline(h_env,obuf,(int)envs[h_env->envc].indent,0,h_env->limit);
    }
    set_alignment(obuf,tag);
    iVar9 = 1;
    break;
  case 0x35:
    if ((obuf->flag & 0x100U) != 0) {
      flushline(h_env,obuf,(int)envs[h_env->envc].indent,0,h_env->limit);
      if (0 < obuf->flag_sp) {
        obuf->flag = obuf->flag & 0xffffff8f;
        obuf->flag_sp = obuf->flag_sp + -1;
        obuf->flag = obuf->flag | obuf->flag_stack[obuf->flag_sp];
      }
      obuf->flag = obuf->flag & 0xfffffeff;
    }
    close_anchor(h_env,obuf);
    flushline(h_env,obuf,(int)envs[h_env->envc].indent,0,h_env->limit);
    if (0 < obuf->flag_sp) {
      obuf->flag = obuf->flag & 0xffffff8f;
      obuf->flag_sp = obuf->flag_sp + -1;
      obuf->flag = obuf->flag | obuf->flag_stack[obuf->flag_sp];
    }
    iVar9 = 1;
    break;
  case 0x36:
    p = "";
    q = "!CURRENT_URL!";
    parsedtag_get_value(tag,0x1b,&p);
    parsedtag_get_value(tag,3,&q);
    pcVar5 = html_quote(p);
    pcVar8 = html_quote(q);
    tmp = Strnew_m_charp("<form method=get action=\"",pcVar8,&DAT_080c9bbb,pcVar5,
                         "<input type=text name=\"\" accept></form>",0);
    HTMLlineproc0(tmp->ptr,h_env,1);
    iVar9 = 1;
    break;
  case 0x3a:
    obuf->flag = obuf->flag | 2;
    obuf->end_tag = ';';
    iVar9 = 1;
    break;
  case 0x3b:
    obuf->flag = obuf->flag & 0xfffffffd;
    obuf->end_tag = '\0';
    iVar9 = 1;
    break;
  case 0x3c:
    p = (char *)0x0;
    iVar9 = parsedtag_get_value(tag,0x12,&p);
    if (iVar9 != 0) {
      if (cur_baseURL == (ParsedURL *)0x0) {
        cur_baseURL = (ParsedURL *)GC_malloc(0x28);
      }
      parseURL(p,cur_baseURL,(ParsedURL *)0x0);
    }
  case 0x37:
  case 0x38:
  case 0x39:
    iVar9 = 0;
    break;
  case 0x3d:
    if (displayInsDel == 1) {
      HTMLlineproc0("<U>[DEL:</U>",h_env,1);
    }
    else if (displayInsDel == 2) {
      obuf->fontstat[3] = obuf->fontstat[3] + '\x01';
      if (obuf->fontstat[3] == '\x01') {
        push_tag(obuf,"<s>",0x69);
      }
    }
    else if (displayInsDel == 0) {
      obuf->flag = obuf->flag | 0x100000;
    }
    iVar9 = 1;
    break;
  case 0x3e:
    if (displayInsDel == 1) {
      HTMLlineproc0("<U>:DEL]</U>",h_env,1);
LAB_0806955d:
      if (obuf->fontstat[3] == '\0') {
        return 1;
      }
      if ((obuf->fontstat[3] == '\x01') && (iVar9 = close_effect0(obuf,0x69), iVar9 != 0)) {
        obuf->fontstat[3] = '\0';
      }
      if (('\0' < obuf->fontstat[3]) &&
         (obuf->fontstat[3] = obuf->fontstat[3] + -1, obuf->fontstat[3] == '\0')) {
        push_tag(obuf,"</s>",0x6a);
      }
    }
    else {
      if (displayInsDel == 2) goto LAB_0806955d;
      if (displayInsDel == 0) {
        obuf->flag = obuf->flag & 0xffefffff;
      }
    }
    iVar9 = 1;
    break;
  case 0x3f:
    if (displayInsDel == 1) {
      HTMLlineproc0("<U>[INS:</U>",h_env,1);
    }
    else if ((displayInsDel == 2) &&
            (obuf->fontstat[4] = obuf->fontstat[4] + '\x01', obuf->fontstat[4] == '\x01')) {
      push_tag(obuf,"<ins>",0x3f);
    }
    iVar9 = 1;
    break;
  case 0x40:
    if (displayInsDel == 1) {
      HTMLlineproc0("<U>:INS]</U>",h_env,1);
    }
    else if (displayInsDel == 2) {
      if (obuf->fontstat[4] == '\0') {
        return 1;
      }
      if ((obuf->fontstat[4] == '\x01') && (iVar9 = close_effect0(obuf,0x3f), iVar9 != 0)) {
        obuf->fontstat[4] = '\0';
      }
      if (('\0' < obuf->fontstat[4]) &&
         (obuf->fontstat[4] = obuf->fontstat[4] + -1, obuf->fontstat[4] == '\0')) {
        push_tag(obuf,"</ins>",0x40);
      }
    }
    iVar9 = 1;
    break;
  case 0x41:
    obuf->fontstat[1] = obuf->fontstat[1] + '\x01';
    if (obuf->fontstat[1] < '\x02') {
      iVar9 = 0;
    }
    else {
      iVar9 = 1;
    }
    break;
  case 0x42:
    if ((obuf->fontstat[1] == '\x01') && (iVar9 = close_effect0(obuf,0x41), iVar9 != 0)) {
      obuf->fontstat[1] = '\0';
    }
    if ((obuf->fontstat[1] < '\x01') ||
       (obuf->fontstat[1] = obuf->fontstat[1] + -1, obuf->fontstat[1] != '\0')) {
      iVar9 = 1;
    }
    else {
      iVar9 = 0;
    }
    break;
  case 0x43:
    obuf->flag = obuf->flag | 4;
    obuf->end_tag = 'D';
    iVar9 = 1;
    break;
  case 0x44:
    obuf->flag = obuf->flag & 0xfffffffb;
    obuf->end_tag = '\0';
    iVar9 = 1;
    break;
  case 0x46:
    HTMLlineproc0("<i>",h_env,1);
    iVar9 = 1;
    break;
  case 0x47:
    HTMLlineproc0("</i>",h_env,1);
    iVar9 = 1;
    break;
  case 0x48:
    if ((view_unseenobject != 0) && (iVar9 = parsedtag_get_value(tag,7,&p), iVar9 != 0)) {
      q = html_quote(p);
      p_Var6 = Sprintf("<IMG SRC=\"%s\" ALT=\"bg image(%s)\"><BR>",q,q);
      HTMLlineproc0(p_Var6->ptr,h_env,1);
    }
  case 0x60:
    if ((obuf->flag & 0x4000U) != 0) {
      HTMLlineproc0("</title>",h_env,1);
    }
  case 0x49:
  case 0x5f:
    iVar9 = 1;
    break;
  case 0x5b:
    if ((view_unseenobject != 0) && (iVar9 = parsedtag_get_value(tag,0x1f,&p), iVar9 != 0)) {
      q = html_quote(p);
      p_Var6 = Sprintf("<A HREF=\"%s\">bgsound(%s)</A>",q,q);
      HTMLlineproc0(p_Var6->ptr,h_env,1);
    }
    iVar9 = 1;
    break;
  case 0x5c:
    if ((view_unseenobject != 0) && (iVar9 = parsedtag_get_value(tag,6,&p), iVar9 != 0)) {
      q = html_quote(p);
      p_Var6 = Sprintf("<A HREF=\"%s\">applet archive(%s)</A>",q,q);
      HTMLlineproc0(p_Var6->ptr,h_env,1);
    }
    iVar9 = 1;
    break;
  case 0x5d:
    if ((view_unseenobject != 0) && (iVar9 = parsedtag_get_value(tag,0x1f,&p), iVar9 != 0)) {
      q = html_quote(p);
      p_Var6 = Sprintf("<A HREF=\"%s\">embed(%s)</A>",q,q);
      HTMLlineproc0(p_Var6->ptr,h_env,1);
    }
    iVar9 = 1;
    break;
  case 0x62:
    if ((obuf->flag & 0x100U) != 0) {
      flushline(h_env,obuf,(int)envs[h_env->envc].indent,0,h_env->limit);
      if (0 < obuf->flag_sp) {
        obuf->flag = obuf->flag & 0xffffff8f;
        obuf->flag_sp = obuf->flag_sp + -1;
        obuf->flag = obuf->flag | obuf->flag_stack[obuf->flag_sp];
      }
      obuf->flag = obuf->flag & 0xfffffeff;
    }
    close_anchor(h_env,obuf);
    flushline(h_env,obuf,(int)envs[h_env->envc].indent,0,h_env->limit);
    obuf->flag = obuf->flag | 0x12000;
    iVar9 = 1;
    break;
  case 99:
    if ((obuf->flag & 0x100U) != 0) {
      flushline(h_env,obuf,(int)envs[h_env->envc].indent,0,h_env->limit);
      if (0 < obuf->flag_sp) {
        obuf->flag = obuf->flag & 0xffffff8f;
        obuf->flag_sp = obuf->flag_sp + -1;
        obuf->flag = obuf->flag | obuf->flag_stack[obuf->flag_sp];
      }
      obuf->flag = obuf->flag & 0xfffffeff;
    }
    close_anchor(h_env,obuf);
    flushline(h_env,obuf,(int)envs[h_env->envc].indent,0,h_env->limit);
    obuf->flag = obuf->flag & 0xfffeffff;
    iVar9 = 1;
    break;
  case 100:
    if ((obuf->flag & 0x300000U) == 0) {
      HTMLlineproc0("^",h_env,1);
    }
    iVar9 = 1;
    break;
  case 0x65:
    iVar9 = 1;
    break;
  case 0x66:
    if ((obuf->flag & 0x300000U) == 0) {
      HTMLlineproc0("[",h_env,1);
    }
    iVar9 = 1;
    break;
  case 0x67:
    if ((obuf->flag & 0x300000U) == 0) {
      HTMLlineproc0("]",h_env,1);
    }
    iVar9 = 1;
    break;
  case 0x69:
    if (displayInsDel == 1) {
      HTMLlineproc0("<U>[S:</U>",h_env,1);
    }
    else if (displayInsDel == 2) {
      obuf->fontstat[3] = obuf->fontstat[3] + '\x01';
      if (obuf->fontstat[3] == '\x01') {
        push_tag(obuf,"<s>",0x69);
      }
    }
    else if (displayInsDel == 0) {
      obuf->flag = obuf->flag | 0x200000;
    }
    iVar9 = 1;
    break;
  case 0x6a:
    if (displayInsDel == 1) {
      HTMLlineproc0("<U>:S]</U>",h_env,1);
    }
    else if (displayInsDel == 2) {
      if (obuf->fontstat[3] == '\0') {
        return 1;
      }
      if ((obuf->fontstat[3] == '\x01') && (iVar9 = close_effect0(obuf,0x69), iVar9 != 0)) {
        obuf->fontstat[3] = '\0';
      }
      if (('\0' < obuf->fontstat[3]) &&
         (obuf->fontstat[3] = obuf->fontstat[3] + -1, obuf->fontstat[3] == '\0')) {
        push_tag(obuf,"</s>",0x6a);
      }
    }
    else if (displayInsDel == 0) {
      obuf->flag = obuf->flag & 0xffdfffff;
    }
    iVar9 = 1;
    break;
  case 0x6b:
    HTMLlineproc0("`",h_env,1);
    iVar9 = 1;
    break;
  case 0x6c:
    HTMLlineproc0("\'",h_env,1);
    iVar9 = 1;
    break;
  case 0x6d:
    obuf->fontstat[2] = obuf->fontstat[2] + '\x01';
    if (obuf->fontstat[2] < '\x02') {
      iVar9 = 0;
    }
    else {
      iVar9 = 1;
    }
    break;
  case 0x6e:
    if ((obuf->fontstat[2] == '\x01') && (iVar9 = close_effect0(obuf,0x6d), iVar9 != 0)) {
      obuf->fontstat[2] = '\0';
    }
    if ((obuf->fontstat[2] < '\x01') ||
       (obuf->fontstat[2] = obuf->fontstat[2] + -1, obuf->fontstat[2] != '\0')) {
      iVar9 = 1;
    }
    else {
      iVar9 = 0;
    }
    break;
  case 0x6f:
    HTMLlineproc0("<b>",h_env,1);
    iVar9 = 1;
    break;
  case 0x70:
    HTMLlineproc0("</b>",h_env,1);
    iVar9 = 1;
    break;
  case 0x80:
    i = obuf->line->length;
    append_tags(obuf);
    if ((obuf->flag & 0x28fU) == 0) {
      set_breakpoint(obuf,obuf->line->length - i);
    }
    obuf->flag = obuf->flag | 0x200;
    iVar9 = 0;
    break;
  case 0x81:
    push_tag(obuf,"</pre_int>",0x81);
    obuf->flag = obuf->flag & 0xfffffdff;
    if (((obuf->flag & 0x28fU) == 0) && ((obuf->bp).pos < (int)obuf->pos)) {
      Strcopy_charp_n(obuf->prevchar,"",0);
      obuf->prev_ctype = 0x100;
    }
    iVar9 = 1;
    break;
  case 0x82:
    iVar9 = parsedtag_get_value(tag,0x31,&p);
    if (iVar9 != 0) {
      pcVar5 = html_unquote(p);
      h_env->title = pcVar5;
    }
    iVar9 = 0;
    break;
  case 0x86:
    i = 0;
    iVar9 = parsedtag_get_value(tag,0x3e,&i);
    if ((iVar9 != 0) && (obuf->top_margin < i)) {
      obuf->top_margin = (short)i;
    }
    i = 0;
    iVar9 = parsedtag_get_value(tag,0x3f,&i);
    if ((iVar9 != 0) && (obuf->bottom_margin < i)) {
      obuf->bottom_margin = (short)i;
    }
    iVar9 = 0;
    break;
  case 0x88:
    iVar9 = parsedtag_get_value(tag,0x1f,&p);
    if (iVar9 != 0) {
      p_Var6 = Strnew_charp(p);
      obuf->img_alt = p_Var6;
    }
    i = 0;
    iVar9 = parsedtag_get_value(tag,0x3e,&i);
    if ((iVar9 != 0) && (obuf->top_margin < i)) {
      obuf->top_margin = (short)i;
    }
    i = 0;
    iVar9 = parsedtag_get_value(tag,0x3f,&i);
    if ((iVar9 != 0) && (obuf->bottom_margin < i)) {
      obuf->bottom_margin = (short)i;
    }
    iVar9 = 0;
    break;
  case 0x89:
    if (obuf->img_alt != (Str)0x0) {
      iVar9 = close_effect0(obuf,0x88);
      if (iVar9 == 0) {
        push_tag(obuf,"</img_alt>",0x89);
      }
      obuf->img_alt = (Str)0x0;
    }
    iVar9 = 1;
    break;
  case 0x8b:
    if ((obuf->flag & 0x100U) != 0) {
      flushline(h_env,obuf,(int)envs[h_env->envc].indent,0,h_env->limit);
      if (0 < obuf->flag_sp) {
        obuf->flag = obuf->flag & 0xffffff8f;
        obuf->flag_sp = obuf->flag_sp + -1;
        obuf->flag = obuf->flag | obuf->flag_stack[obuf->flag_sp];
      }
      obuf->flag = obuf->flag & 0xfffffeff;
    }
    close_anchor(h_env,obuf);
    if ((obuf->flag & 0x2000U) == 0) {
      flushline(h_env,obuf,(int)envs[h_env->envc].indent,0,h_env->limit);
      do_blankline(h_env,obuf,(int)envs[h_env->envc].indent,0,h_env->limit);
    }
    obuf->flag = obuf->flag | 0x2001;
    iVar9 = 1;
    break;
  case 0x8c:
    if ((obuf->flag & 0x100U) != 0) {
      flushline(h_env,obuf,(int)envs[h_env->envc].indent,0,h_env->limit);
      if (0 < obuf->flag_sp) {
        obuf->flag = obuf->flag & 0xffffff8f;
        obuf->flag_sp = obuf->flag_sp + -1;
        obuf->flag = obuf->flag | obuf->flag_stack[obuf->flag_sp];
      }
      obuf->flag = obuf->flag & 0xfffffeff;
    }
    close_anchor(h_env,obuf);
    if ((obuf->flag & 0x2000U) == 0) {
      flushline(h_env,obuf,(int)envs[h_env->envc].indent,0,h_env->limit);
      do_blankline(h_env,obuf,(int)envs[h_env->envc].indent,0,h_env->limit);
      obuf->flag = obuf->flag | 0x2000;
    }
    obuf->flag = obuf->flag & 0xfffffffe;
    iVar9 = 1;
    break;
  case 0x8f:
    if ((obuf->flag & 0x100U) != 0) {
      flushline(h_env,obuf,(int)envs[h_env->envc].indent,0,h_env->limit);
      if (0 < obuf->flag_sp) {
        obuf->flag = obuf->flag & 0xffffff8f;
        obuf->flag_sp = obuf->flag_sp + -1;
        obuf->flag = obuf->flag | obuf->flag_stack[obuf->flag_sp];
      }
      obuf->flag = obuf->flag & 0xfffffeff;
    }
    if ((obuf->flag & 0x2000U) == 0) {
      flushline(h_env,obuf,(int)envs[h_env->envc].indent,0,h_env->limit);
    }
    set_alignment(obuf,tag);
    iVar9 = 1;
    break;
  case 0x90:
    if ((obuf->flag & 0x100U) != 0) {
      flushline(h_env,obuf,(int)envs[h_env->envc].indent,0,h_env->limit);
      if (0 < obuf->flag_sp) {
        obuf->flag = obuf->flag & 0xffffff8f;
        obuf->flag_sp = obuf->flag_sp + -1;
        obuf->flag = obuf->flag | obuf->flag_stack[obuf->flag_sp];
      }
      obuf->flag = obuf->flag & 0xfffffeff;
    }
    flushline(h_env,obuf,(int)envs[h_env->envc].indent,0,h_env->limit);
    if (0 < obuf->flag_sp) {
      obuf->flag = obuf->flag & 0xffffff8f;
      obuf->flag_sp = obuf->flag_sp + -1;
      obuf->flag = obuf->flag | obuf->flag_stack[obuf->flag_sp];
    }
    iVar9 = 1;
  }
  return iVar9;
}



Str textlist_feed(void)

{
  TextLine **ppTVar1;
  Str p_Var2;
  TextLine *p;
  
  if (_tl_lp2 == (TextLineListItem *)0x0) {
    p_Var2 = (Str)0x0;
  }
  else {
    ppTVar1 = &_tl_lp2->ptr;
    _tl_lp2 = _tl_lp2->next;
    p_Var2 = (*ppTVar1)->line;
  }
  return p_Var2;
}



int ex_efct(int ex)

{
  int effect;
  
  effect = 0;
  if (ex == 0) {
    effect = 0;
  }
  else {
    if ((ex & 1U) != 0) {
      effect = 2;
    }
    if ((ex & 2U) != 0) {
      effect = 2;
    }
    if ((ex & 4U) != 0) {
      effect = effect | 4;
    }
  }
  return effect;
}



void HTMLlineproc2body(Buffer *buf_1,anon_subr_Str_varargs *feed,int llimit)

{
  Lineprop *pLVar1;
  BufferPoint *pBVar2;
  Str *pp_Var3;
  byte bVar4;
  wc_ces wVar5;
  FormItemList *fi;
  wc_ces wVar6;
  ushort uVar7;
  uint uVar8;
  int iVar9;
  HmarkerList *pHVar10;
  char *pcVar11;
  ImageCache *pIVar12;
  GeneralList *pGVar13;
  frameset *pfVar14;
  ParsedURL *pPVar15;
  AlarmEvent *pAVar16;
  Str value;
  Str p_Var17;
  int iVar18;
  AnchorList *pAVar19;
  FormList *pFVar20;
  uint uVar21;
  bool bVar22;
  ParsedURL u;
  frameset *frameset_s [10];
  int selected;
  FormItemList *item;
  FormItemList *item_1;
  int refresh_interval;
  Str tmp;
  frame_body *element;
  MapArea *a;
  MapList *m;
  int hpos;
  int textareanumber;
  int bottom;
  int top;
  FormList *form;
  Anchor *a_1;
  BufferPoint *po;
  Image *image;
  int ismap;
  int iseq;
  int h;
  int w;
  int h_1;
  parsed_tag *tag;
  int len_2;
  int len_1;
  int len;
  char **buf;
  Anchor **a_select;
  Anchor **a_textarea;
  int internal;
  char *endp;
  Str line;
  int form_id;
  int hseq;
  char *id;
  frameset_element *idFrame;
  int frameset_sp;
  int nlines;
  int pos;
  char *str;
  char *t;
  char *s;
  char *r;
  char *q;
  char *p;
  Anchor *a_form;
  Anchor *a_img;
  Anchor *a_href;
  Lineprop ex_effect;
  Lineprop effect;
  Lineprop mode;
  char symbol;
  
  a_href = (Anchor *)0x0;
  a_img = (Anchor *)0x0;
  a_form = (Anchor *)0x0;
  frameset_sp = -1;
  idFrame = (frameset_element *)0x0;
  id = (char *)0x0;
  symbol = '\0';
  internal = 0;
  a_textarea = (Anchor **)0x0;
  a_select = (Anchor **)0x0;
  if (HTMLlineproc2body::out_size == 0) {
    HTMLlineproc2body::out_size = 0x100;
    HTMLlineproc2body::outc = (char *)GC_malloc_atomic(0x100);
    HTMLlineproc2body::outp = (Lineprop *)GC_malloc_atomic(HTMLlineproc2body::out_size * 2);
  }
  n_textarea = -1;
  if (max_textarea == 0) {
    max_textarea = 10;
    textarea_str = (Str *)GC_malloc(0x28);
    a_textarea = (Anchor **)GC_malloc(max_textarea << 2);
  }
  n_select = -1;
  if (max_select == 0) {
    max_select = 10;
    select_option = (FormSelectOption *)GC_malloc(0x50);
    a_select = (Anchor **)GC_malloc(max_select << 2);
  }
  effect = 0;
  ex_effect = 0;
  nlines = 0;
LAB_0806bfe6:
  do {
    line = (*feed)();
    if (line == (Str)0x0) {
LAB_0806bffb:
      for (form_id = 1; form_id <= form_max; form_id = form_id + 1) {
        forms[form_id]->next = forms[form_id + -1];
      }
      if (form_max < 0) {
        pFVar20 = (FormList *)0x0;
      }
      else {
        pFVar20 = forms[form_max];
      }
      buf_1->formlist = pFVar20;
      if (n_textarea != 0) {
        addMultirowsForm(buf_1,buf_1->formitem);
      }
      addMultirowsImg(buf_1,buf_1->img);
      return;
    }
    if ((n_textarea < 0) || (*line->ptr == '<')) {
      do {
        nlines = nlines + 1;
        if (nlines == llimit) goto LAB_0806bffb;
        pos = 0;
        Strremovetrailingspaces(line);
        str = line->ptr;
        endp = str + line->length;
        while (str < endp) {
          if (HTMLlineproc2body::out_size <= pos + 1) {
            HTMLlineproc2body::out_size = (pos * 3) / 2;
            HTMLlineproc2body::outc =
                 (char *)GC_realloc(HTMLlineproc2body::outc,HTMLlineproc2body::out_size);
            HTMLlineproc2body::outp =
                 (Lineprop *)GC_realloc(HTMLlineproc2body::outp,HTMLlineproc2body::out_size * 2);
          }
          mode = (ushort)WTF_TYPE_MAP[(byte)*str] << 8;
          uVar21 = (uint)effect;
          uVar8 = ex_efct((uint)ex_effect);
          if ((((uVar8 | uVar21) & 0x8000) == 0) || (*str == '<')) {
            if ((mode == 0x100) || (mode == 0x2000)) {
              pLVar1 = HTMLlineproc2body::outp + pos;
              iVar9 = ex_efct((uint)ex_effect);
              *pLVar1 = effect | (ushort)iVar9;
              HTMLlineproc2body::outc[pos] = ' ';
              pos = pos + 1;
              str = str + 1;
            }
            else if ((mode & 0x1000) == 0) {
              if ((*str == '<') || (*str == '&')) {
                if (*str == '&') {
                  p = getescapecmd(&str);
                  while (*p != '\0') {
                    if (HTMLlineproc2body::out_size <= pos + 1) {
                      HTMLlineproc2body::out_size = (pos * 3) / 2;
                      HTMLlineproc2body::outc =
                           (char *)GC_realloc(HTMLlineproc2body::outc,HTMLlineproc2body::out_size);
                      HTMLlineproc2body::outp =
                           (Lineprop *)
                           GC_realloc(HTMLlineproc2body::outp,HTMLlineproc2body::out_size * 2);
                    }
                    bVar4 = WTF_TYPE_MAP[(byte)*p];
                    mode = (ushort)bVar4 << 8;
                    if ((bVar4 == 1) || (bVar4 == 0x20)) {
                      pLVar1 = HTMLlineproc2body::outp + pos;
                      iVar9 = ex_efct((uint)ex_effect);
                      *pLVar1 = effect | (ushort)iVar9;
                      HTMLlineproc2body::outc[pos] = ' ';
                      pos = pos + 1;
                      p = p + 1;
                    }
                    else if ((mode & 0x1000) == 0) {
                      len_2 = (int)WTF_LEN_MAP[(byte)*p];
                      pLVar1 = HTMLlineproc2body::outp + pos;
                      uVar7 = effect | mode;
                      iVar9 = ex_efct((uint)ex_effect);
                      *pLVar1 = (ushort)iVar9 | uVar7;
                      HTMLlineproc2body::outc[pos] = *p;
                      p = p + 1;
                      pos = pos + 1;
                      len_2 = len_2 + -1;
                      if (len_2 != 0) {
                        mode = mode & 0xff | (ushort)((byte)((uint)mode >> 8) & 0xf9) << 8 | 0x400;
                        while (bVar22 = len_2 != 0, len_2 = len_2 + -1, bVar22) {
                          if (HTMLlineproc2body::out_size <= pos + 1) {
                            HTMLlineproc2body::out_size = (pos * 3) / 2;
                            HTMLlineproc2body::outc =
                                 (char *)GC_realloc(HTMLlineproc2body::outc,
                                                    HTMLlineproc2body::out_size);
                            HTMLlineproc2body::outp =
                                 (Lineprop *)
                                 GC_realloc(HTMLlineproc2body::outp,HTMLlineproc2body::out_size * 2)
                            ;
                          }
                          pLVar1 = HTMLlineproc2body::outp + pos;
                          uVar7 = effect | mode;
                          iVar9 = ex_efct((uint)ex_effect);
                          *pLVar1 = (ushort)iVar9 | uVar7;
                          HTMLlineproc2body::outc[pos] = *p;
                          p = p + 1;
                          pos = pos + 1;
                        }
                      }
                    }
                    else {
                      pLVar1 = HTMLlineproc2body::outp + pos;
                      iVar9 = ex_efct((uint)ex_effect);
                      *pLVar1 = effect | (ushort)iVar9;
                      HTMLlineproc2body::outc[pos] = ' ';
                      pos = pos + 1;
                      p = p + WTF_LEN_MAP[(byte)*p];
                    }
                  }
                }
                else {
                  tag = parse_tag(&str,1);
                  if (tag != (parsed_tag *)0x0) {
                    switch(tag->tagid) {
                    case '\x01':
                      if ((renderFrameSet != (frameset *)0x0) &&
                         (iVar9 = parsedtag_get_value(tag,0x43,&p), wVar5 = InnerCharset, iVar9 != 0
                         )) {
                        wVar6 = buf_1->document_charset;
                        p_Var17 = Strnew_charp(p);
                        p_Var17 = wc_Str_conv_strict(p_Var17,wVar5,wVar6);
                        p = url_quote(p_Var17->ptr);
                        if (((idFrame == (frameset_element *)0x0) ||
                            (iVar9 = strcmp(*(char **)(*idFrame + 4),p), iVar9 != 0)) &&
                           ((idFrame = search_frame(renderFrameSet,p),
                            (char **)idFrame != (char **)0x0 && (*(char *)*idFrame != '\x01')))) {
                          idFrame = (frameset_element *)0x0;
                        }
                      }
                      s = (char *)0x0;
                      r = (char *)0x0;
                      p = (char *)0x0;
                      q = buf_1->baseTarget;
                      t = "";
                      hseq = 0;
                      id = (char *)0x0;
                      iVar9 = parsedtag_get_value(tag,0x19,&id);
                      wVar5 = InnerCharset;
                      if (iVar9 != 0) {
                        wVar6 = buf_1->document_charset;
                        p_Var17 = Strnew_charp(id);
                        p_Var17 = wc_Str_conv_strict(p_Var17,wVar5,wVar6);
                        id = url_quote(p_Var17->ptr);
                        iVar9 = currentLn(buf_1);
                        registerName(buf_1,id,iVar9,pos);
                      }
                      iVar9 = parsedtag_get_value(tag,0x12,&p);
                      wVar5 = InnerCharset;
                      if (iVar9 != 0) {
                        wVar6 = buf_1->document_charset;
                        pcVar11 = remove_space(p);
                        p_Var17 = Strnew_charp(pcVar11);
                        p_Var17 = wc_Str_conv_strict(p_Var17,wVar5,wVar6);
                        p = url_quote(p_Var17->ptr);
                      }
                      iVar9 = parsedtag_get_value(tag,0x20,&q);
                      wVar5 = InnerCharset;
                      if (iVar9 != 0) {
                        wVar6 = buf_1->document_charset;
                        p_Var17 = Strnew_charp(q);
                        p_Var17 = wc_Str_conv_strict(p_Var17,wVar5,wVar6);
                        q = url_quote(p_Var17->ptr);
                      }
                      iVar9 = parsedtag_get_value(tag,0x47,&r);
                      wVar5 = InnerCharset;
                      if (iVar9 != 0) {
                        wVar6 = buf_1->document_charset;
                        p_Var17 = Strnew_charp(r);
                        p_Var17 = wc_Str_conv_strict(p_Var17,wVar5,wVar6);
                        r = url_quote(p_Var17->ptr);
                      }
                      parsedtag_get_value(tag,0x31,&s);
                      parsedtag_get_value(tag,0x32,&t);
                      parsedtag_get_value(tag,0x45,&hseq);
                      if (hseq < 1) {
                        if ((((hseq < 0) && (h_1 = ~hseq, buf_1->hmarklist != (HmarkerList *)0x0))
                            && (h_1 < buf_1->hmarklist->nmark)) &&
                           (buf_1->hmarklist->marks[h_1].invalid != 0)) {
                          buf_1->hmarklist->marks[h_1].pos = pos;
                          pBVar2 = buf_1->hmarklist->marks + h_1;
                          iVar9 = currentLn(buf_1);
                          pBVar2->line = iVar9;
                          buf_1->hmarklist->marks[h_1].invalid = 0;
                          hseq = -hseq;
                        }
                      }
                      else {
                        iVar9 = hseq + -1;
                        iVar18 = currentLn(buf_1);
                        pHVar10 = putHmarker(buf_1->hmarklist,iVar18,pos,iVar9);
                        buf_1->hmarklist = pHVar10;
                      }
                      if ((id != (char *)0x0) && (idFrame != (frameset_element *)0x0)) {
                        iVar9 = *idFrame;
                        iVar18 = currentLn(buf_1);
                        pAVar19 = putAnchor(*(AnchorList **)(*idFrame + 0x1c),id,(char *)0x0,
                                            (Anchor **)0x0,(char *)0x0,(char *)0x0,'\0',iVar18,pos);
                        *(AnchorList **)(iVar9 + 0x1c) = pAVar19;
                      }
                      if (p != (char *)0x0) {
                        effect = effect | 0x10;
                        iVar9 = currentLn(buf_1);
                        a_href = registerHref(buf_1,p,q,r,s,*t,iVar9,pos);
                        a_href->hseq = ((hseq ^ hseq >> 0x1f) - (hseq >> 0x1f)) + -1;
                        a_href->slave = hseq < 1;
                      }
                      break;
                    case '\x02':
                      effect = effect & 0xffef;
                      if (a_href != (Anchor *)0x0) {
                        iVar9 = currentLn(buf_1);
                        (a_href->end).line = iVar9;
                        (a_href->end).pos = pos;
                        if (((a_href->start).line == (a_href->end).line) &&
                           ((a_href->start).pos == (a_href->end).pos)) {
                          if ((buf_1->hmarklist != (HmarkerList *)0x0) &&
                             (a_href->hseq < buf_1->hmarklist->nmark)) {
                            buf_1->hmarklist->marks[a_href->hseq].invalid = 1;
                          }
                          a_href->hseq = -1;
                        }
                        a_href = (Anchor *)0x0;
                      }
                      break;
                    case '\a':
                      effect = effect | 8;
                      break;
                    case '\b':
                      effect = effect & 0xfff7;
                      break;
                    case '!':
                      q = (char *)0x0;
                      p = (char *)0x0;
                      parsedtag_get_value(tag,0x13,&p);
                      parsedtag_get_value(tag,0xf,&q);
                      if ((((p != (char *)0x0) && (q != (char *)0x0)) &&
                          (iVar9 = strcasecmp(p,"refresh"), iVar9 == 0)) && (MetaRefresh != '\0')) {
                        tmp = (Str)0x0;
                        iVar9 = getMetaRefreshParam(q,&tmp);
                        wVar5 = InnerCharset;
                        if (tmp == (Str)0x0) {
                          if (0 < iVar9) {
                            pAVar16 = setAlarmEvent(buf_1->event,iVar9,2,0x70,(void *)0x0);
                            buf_1->event = pAVar16;
                          }
                        }
                        else {
                          wVar6 = buf_1->document_charset;
                          pcVar11 = remove_space(tmp->ptr);
                          p_Var17 = Strnew_charp(pcVar11);
                          p_Var17 = wc_Str_conv_strict(p_Var17,wVar5,wVar6);
                          p = url_quote(p_Var17->ptr);
                          pAVar16 = setAlarmEvent(buf_1->event,iVar9,3,0x25,p);
                          buf_1->event = pAVar16;
                        }
                      }
                      break;
                    case '#':
                      if ((-1 < frameset_sp) && (frameset_sp < 10)) {
                        element = newFrame(tag,buf_1);
                        addFrameSetElement(frameset_s[frameset_sp],element);
                      }
                      break;
                    case '$':
                      iVar9 = frameset_sp + 1;
                      frameset_sp = iVar9;
                      if (iVar9 < 10) {
                        pfVar14 = newFrameSet(tag);
                        frameset_s[iVar9] = pfVar14;
                        if (frameset_s[frameset_sp] != (frameset *)0x0) {
                          if (frameset_sp == 0) {
                            if (buf_1->frameset == (frameset *)0x0) {
                              buf_1->frameset = frameset_s[0];
                            }
                            else {
                              pushFrameTree(&buf_1->frameQ,frameset_s[0],(Buffer *)0x0);
                            }
                          }
                          else {
                            addFrameSetElement(frameset_s[frameset_sp + -1],frameset_s[frameset_sp])
                            ;
                          }
                        }
                      }
                      break;
                    case '%':
                      if (-1 < frameset_sp) {
                        frameset_sp = frameset_sp + -1;
                      }
                      break;
                    case '7':
                      iVar9 = parsedtag_get_value(tag,0x19,&p);
                      if (iVar9 != 0) {
                        m = (MapList *)GC_malloc(0xc);
                        p_Var17 = Strnew_charp(p);
                        m->name = p_Var17;
                        pGVar13 = newGeneralList();
                        m->area = pGVar13;
                        m->next = buf_1->maplist;
                        buf_1->maplist = m;
                      }
                      break;
                    case '9':
                      if ((buf_1->maplist != (MapList *)0x0) &&
                         (iVar9 = parsedtag_get_value(tag,0x12,&p), wVar5 = InnerCharset, iVar9 != 0
                         )) {
                        wVar6 = buf_1->document_charset;
                        pcVar11 = remove_space(p);
                        p_Var17 = Strnew_charp(pcVar11);
                        p_Var17 = wc_Str_conv_strict(p_Var17,wVar5,wVar6);
                        p = url_quote(p_Var17->ptr);
                        t = (char *)0x0;
                        parsedtag_get_value(tag,0x20,&t);
                        q = "";
                        parsedtag_get_value(tag,5,&q);
                        r = (char *)0x0;
                        s = (char *)0x0;
                        parsedtag_get_value(tag,0x2c,&r);
                        parsedtag_get_value(tag,0x2d,&s);
                        a = newMapArea(p,t,q,r,s);
                        pushValue(buf_1->maplist->area,a);
                      }
                      break;
                    case '<':
                      iVar9 = parsedtag_get_value(tag,0x12,&p);
                      wVar5 = InnerCharset;
                      if (iVar9 != 0) {
                        wVar6 = buf_1->document_charset;
                        pcVar11 = remove_space(p);
                        p_Var17 = Strnew_charp(pcVar11);
                        p_Var17 = wc_Str_conv_strict(p_Var17,wVar5,wVar6);
                        p = url_quote(p_Var17->ptr);
                        if (buf_1->baseURL == (ParsedURL *)0x0) {
                          pPVar15 = (ParsedURL *)GC_malloc(0x28);
                          buf_1->baseURL = pPVar15;
                        }
                        parseURL(p,buf_1->baseURL,(ParsedURL *)0x0);
                      }
                      iVar9 = parsedtag_get_value(tag,0x20,&p);
                      wVar5 = InnerCharset;
                      if (iVar9 != 0) {
                        wVar6 = buf_1->document_charset;
                        p_Var17 = Strnew_charp(p);
                        p_Var17 = wc_Str_conv_strict(p_Var17,wVar5,wVar6);
                        pcVar11 = url_quote(p_Var17->ptr);
                        buf_1->baseTarget = pcVar11;
                      }
                      break;
                    case '?':
                      ex_effect = ex_effect | 2;
                      break;
                    case '@':
                      ex_effect = ex_effect & 0xfffd;
                      break;
                    case 'A':
                      effect = effect | 2;
                      break;
                    case 'B':
                      effect = effect & 0xfffd;
                      break;
                    case 'h':
                      addLink(buf_1,tag);
                      break;
                    case 'i':
                      ex_effect = ex_effect | 4;
                      break;
                    case 'j':
                      ex_effect = ex_effect & 0xfffb;
                      break;
                    case 'm':
                      ex_effect = ex_effect | 1;
                      break;
                    case 'n':
                      ex_effect = ex_effect & 0xfffe;
                      break;
                    case 'x':
                      iVar9 = parsedtag_get_value(tag,0x48,&n_select);
                      if ((iVar9 == 0) || (max_select <= n_select)) {
                        n_select = -1;
                      }
                      else {
                        select_option[n_select].first = (FormSelectOptionItem *)0x0;
                        select_option[n_select].last = (FormSelectOptionItem *)0x0;
                      }
                      break;
                    case 'y':
                      if (-1 < n_select) {
                        fi = (FormItemList *)a_select[n_select]->url;
                        fi->select_option = select_option[n_select].first;
                        chooseSelectOption(fi,fi->select_option);
                        fi->init_selected = fi->selected;
                        fi->init_value = fi->value;
                        fi->init_label = fi->label;
                      }
                      break;
                    case 'z':
                      if (-1 < n_select) {
                        q = "";
                        parsedtag_get_value(tag,0x2a,&q);
                        p = q;
                        parsedtag_get_value(tag,0x24,&p);
                        if (((tag->map == (uchar *)0x0) || (tag->map[0x29] == 'K')) ||
                           (tag->attrid[tag->map[0x29]] == '\0')) {
                          iVar9 = 0;
                        }
                        else {
                          iVar9 = 1;
                        }
                        p_Var17 = Strnew_charp(q);
                        value = Strnew_charp(p);
                        addSelectOption(select_option + n_select,value,p_Var17,iVar9);
                      }
                      break;
                    case '{':
                      iVar9 = parsedtag_get_value(tag,0x49,&n_textarea);
                      if ((iVar9 == 0) || (max_textarea <= n_textarea)) {
                        n_textarea = -1;
                      }
                      else {
                        pp_Var3 = textarea_str + n_textarea;
                        p_Var17 = Strnew();
                        *pp_Var3 = p_Var17;
                      }
                      break;
                    case '|':
                      if (-1 < n_textarea) {
                        pcVar11 = a_textarea[n_textarea]->url;
                        *(Str *)(pcVar11 + 8) = textarea_str[n_textarea];
                        *(undefined4 *)(pcVar11 + 0xc) = *(undefined4 *)(pcVar11 + 8);
                      }
                      break;
                    case '~':
                      effect = effect | 0x8000;
                      iVar9 = parsedtag_get_value(tag,0x21,&p);
                      if (iVar9 != 0) {
                        iVar9 = atoi(p);
                        symbol = (char)iVar9;
                      }
                      break;
                    case '\x7f':
                      effect = effect & 0x7fff;
                      break;
                    case 0x82:
                      iVar9 = parsedtag_get_value(tag,0x31,&p);
                      if (iVar9 != 0) {
                        pcVar11 = html_unquote(p);
                        buf_1->buffername = pcVar11;
                      }
                      break;
                    case 0x83:
                      iVar9 = parsedtag_get_value(tag,0x41,&form_id);
                      if (iVar9 != 0) {
                        process_form_int(tag,form_id);
                      }
                      break;
                    case 0x86:
                      top = 0;
                      bottom = 0;
                      textareanumber = -1;
                      tmp = (Str)0xffffffff;
                      hseq = 0;
                      form_id = -1;
                      parsedtag_get_value(tag,0x45,&hseq);
                      parsedtag_get_value(tag,0x41,&form_id);
                      parsedtag_get_value(tag,0x3e,&top);
                      parsedtag_get_value(tag,0x3f,&bottom);
                      if (((-1 < form_id) && (form_id <= form_max)) && (forms != (FormList **)0x0))
                      {
                        form = forms[form_id];
                        if (0 < hseq) {
                          hpos = pos;
                          if (*str == '[') {
                            hpos = pos + 1;
                          }
                          iVar9 = hseq + -1;
                          iVar18 = currentLn(buf_1);
                          pHVar10 = putHmarker(buf_1->hmarklist,iVar18,hpos,iVar9);
                          buf_1->hmarklist = pHVar10;
                        }
                        if (form->target == (char *)0x0) {
                          form->target = buf_1->baseTarget;
                        }
                        if (((a_textarea != (Anchor **)0x0) &&
                            (iVar9 = parsedtag_get_value(tag,0x49,&textareanumber), iVar9 != 0)) &&
                           (max_textarea <= textareanumber)) {
                          max_textarea = textareanumber * 2;
                          textarea_str = (Str *)GC_realloc(textarea_str,textareanumber << 3);
                          a_textarea = (Anchor **)GC_realloc(a_textarea,max_textarea << 2);
                        }
                        if (((a_select != (Anchor **)0x0) &&
                            (iVar9 = parsedtag_get_value(tag,0x48,&tmp), iVar9 != 0)) &&
                           (max_select <= (int)tmp)) {
                          max_select = (int)tmp * 2;
                          select_option =
                               (FormSelectOption *)GC_realloc(select_option,(int)tmp << 4);
                          a_select = (Anchor **)GC_realloc(a_select,max_select << 2);
                        }
                        iVar9 = currentLn(buf_1);
                        a_form = registerForm(buf_1,form,tag,iVar9,pos);
                        if ((a_textarea != (Anchor **)0x0) && (-1 < textareanumber)) {
                          a_textarea[textareanumber] = a_form;
                        }
                        if ((a_select != (Anchor **)0x0) && (-1 < (int)tmp)) {
                          a_select[(int)tmp] = a_form;
                        }
                        if (a_form == (Anchor *)0x0) goto switchD_0806a4ec_caseD_87;
                        a_form->hseq = hseq + -1;
                        iVar9 = currentLn(buf_1);
                        a_form->y = (short)iVar9 - (short)top;
                        a_form->rows = (short)top + (short)bottom + 1;
                        if (((tag->map == (uchar *)0x0) || (tag->map[0x46] == 'K')) ||
                           (tag->attrid[tag->map[0x46]] == '\0')) {
                          effect = effect | 0x40;
                        }
                      }
                      break;
                    case 0x87:
switchD_0806a4ec_caseD_87:
                      effect = effect & 0xffbf;
                      if (a_form != (Anchor *)0x0) {
                        iVar9 = currentLn(buf_1);
                        (a_form->end).line = iVar9;
                        (a_form->end).pos = pos;
                        if (((a_form->start).line == (a_form->end).line) &&
                           ((a_form->start).pos == (a_form->end).pos)) {
                          a_form->hseq = -1;
                        }
                      }
                      a_form = (Anchor *)0x0;
                      break;
                    case 0x88:
                      iVar9 = parsedtag_get_value(tag,0x1f,&p);
                      if (iVar9 != 0) {
                        w = -1;
                        h = -1;
                        iseq = 0;
                        ismap = 0;
                        tmp = (Str)0x0;
                        textareanumber = 0;
                        bottom = 0;
                        top = 0;
                        parsedtag_get_value(tag,0x45,&iseq);
                        parsedtag_get_value(tag,0x26,&w);
                        parsedtag_get_value(tag,0x11,&h);
                        parsedtag_get_value(tag,0x3c,&tmp);
                        parsedtag_get_value(tag,0x3d,&textareanumber);
                        parsedtag_get_value(tag,0x3e,&bottom);
                        parsedtag_get_value(tag,0x3f,&top);
                        if (((tag->map != (uchar *)0x0) && (tag->map[0x2e] != 'K')) &&
                           (tag->attrid[tag->map[0x2e]] != '\0')) {
                          ismap = 1;
                        }
                        q = (char *)0x0;
                        parsedtag_get_value(tag,0x22,&q);
                        if (0 < iseq) {
                          iVar9 = iseq + -1;
                          iVar18 = currentLn(buf_1);
                          pHVar10 = putHmarker(buf_1->imarklist,iVar18,pos,iVar9);
                          buf_1->imarklist = pHVar10;
                        }
                        s = (char *)0x0;
                        parsedtag_get_value(tag,0x31,&s);
                        wVar6 = InnerCharset;
                        wVar5 = buf_1->document_charset;
                        pcVar11 = remove_space(p);
                        p_Var17 = Strnew_charp(pcVar11);
                        p_Var17 = wc_Str_conv_strict(p_Var17,wVar6,wVar5);
                        p = url_quote(p_Var17->ptr);
                        iVar9 = currentLn(buf_1);
                        a_img = registerImg(buf_1,p,s,iVar9,pos);
                        a_img->hseq = iseq;
                        a_img->image = (Image *)0x0;
                        if (iseq < 1) {
                          if (iseq < 0) {
                            po = buf_1->imarklist->marks + (-1 - iseq);
                            a_1 = retrieveAnchor(buf_1->img,po->line,po->pos);
                            if (a_1 != (Anchor *)0x0) {
                              a_img->url = a_1->url;
                              a_img->image = a_1->image;
                            }
                          }
                        }
                        else {
                          parseURL2(a_img->url,&u,cur_baseURL);
                          image = (Image *)GC_malloc(0x24);
                          a_img->image = image;
                          p_Var17 = parsedURL2Str(&u);
                          image->url = p_Var17->ptr;
                          pcVar11 = uncompressed_file_type(u.file,&image->ext);
                          if (pcVar11 == (char *)0x0) {
                            pcVar11 = filename_extension(u.file,1);
                            image->ext = pcVar11;
                          }
                          image->cache = (ImageCache *)0x0;
                          iVar9 = w;
                          if (0x800 < w) {
                            iVar9 = 0x800;
                          }
                          image->width = (short)iVar9;
                          iVar9 = h;
                          if (0x800 < h) {
                            iVar9 = 0x800;
                          }
                          image->height = (short)iVar9;
                          image->xoffset = (short)tmp;
                          image->yoffset = (short)textareanumber;
                          iVar9 = currentLn(buf_1);
                          image->y = (short)iVar9 - (short)bottom;
                          if ((image->xoffset < 0) && (pos == 0)) {
                            image->xoffset = 0;
                          }
                          if ((image->yoffset < 0) && (image->y == 1)) {
                            image->yoffset = 0;
                          }
                          image->rows = (short)bottom + (short)top + 1;
                          image->map = q;
                          image->ismap = (char)ismap;
                          image->touch = 0;
                          pIVar12 = getImage(image,cur_baseURL,1);
                          image->cache = pIVar12;
                        }
                      }
                      effect = effect | 0x20;
                      break;
                    case 0x89:
                      effect = effect & 0xffdf;
                      if (a_img != (Anchor *)0x0) {
                        iVar9 = currentLn(buf_1);
                        (a_img->end).line = iVar9;
                        (a_img->end).pos = pos;
                      }
                      a_img = (Anchor *)0x0;
                      break;
                    case 0x8d:
                      internal = 0x8d;
                      break;
                    case 0x8e:
                      internal = 0x8e;
                    }
                    id = (char *)0x0;
                    iVar9 = parsedtag_get_value(tag,0x14,&id);
                    wVar5 = InnerCharset;
                    if (iVar9 != 0) {
                      wVar6 = buf_1->document_charset;
                      p_Var17 = Strnew_charp(id);
                      p_Var17 = wc_Str_conv_strict(p_Var17,wVar5,wVar6);
                      id = url_quote(p_Var17->ptr);
                      iVar9 = currentLn(buf_1);
                      registerName(buf_1,id,iVar9,pos);
                    }
                    if ((renderFrameSet != (frameset *)0x0) &&
                       (iVar9 = parsedtag_get_value(tag,0x43,&p), wVar5 = InnerCharset, iVar9 != 0))
                    {
                      wVar6 = buf_1->document_charset;
                      p_Var17 = Strnew_charp(p);
                      p_Var17 = wc_Str_conv_strict(p_Var17,wVar5,wVar6);
                      p = url_quote(p_Var17->ptr);
                      if (((idFrame == (frameset_element *)0x0) ||
                          (iVar9 = strcmp(*(char **)(*idFrame + 4),p), iVar9 != 0)) &&
                         ((idFrame = search_frame(renderFrameSet,p),
                          (char **)idFrame != (char **)0x0 && (*(char *)*idFrame != '\x01')))) {
                        idFrame = (frameset_element *)0x0;
                      }
                    }
                    if ((id != (char *)0x0) && (idFrame != (frameset_element *)0x0)) {
                      iVar9 = *idFrame;
                      iVar18 = currentLn(buf_1);
                      pAVar19 = putAnchor(*(AnchorList **)(*idFrame + 0x1c),id,(char *)0x0,
                                          (Anchor **)0x0,(char *)0x0,(char *)0x0,'\0',iVar18,pos);
                      *(AnchorList **)(iVar9 + 0x1c) = pAVar19;
                    }
                  }
                }
              }
              else {
                len_1 = (int)WTF_LEN_MAP[(byte)*str];
                pLVar1 = HTMLlineproc2body::outp + pos;
                uVar7 = effect | mode;
                iVar9 = ex_efct((uint)ex_effect);
                *pLVar1 = (ushort)iVar9 | uVar7;
                HTMLlineproc2body::outc[pos] = *str;
                str = str + 1;
                pos = pos + 1;
                len_1 = len_1 + -1;
                if (len_1 != 0) {
                  mode = mode & 0xff | (ushort)((byte)((uint)mode >> 8) & 0xf9) << 8 | 0x400;
                  while (bVar22 = len_1 != 0, len_1 = len_1 + -1, bVar22) {
                    if (HTMLlineproc2body::out_size <= pos + 1) {
                      HTMLlineproc2body::out_size = (pos * 3) / 2;
                      HTMLlineproc2body::outc =
                           (char *)GC_realloc(HTMLlineproc2body::outc,HTMLlineproc2body::out_size);
                      HTMLlineproc2body::outp =
                           (Lineprop *)
                           GC_realloc(HTMLlineproc2body::outp,HTMLlineproc2body::out_size * 2);
                    }
                    pLVar1 = HTMLlineproc2body::outp + pos;
                    uVar7 = effect | mode;
                    iVar9 = ex_efct((uint)ex_effect);
                    *pLVar1 = (ushort)iVar9 | uVar7;
                    HTMLlineproc2body::outc[pos] = *str;
                    str = str + 1;
                    pos = pos + 1;
                  }
                }
              }
            }
            else {
              pLVar1 = HTMLlineproc2body::outp + pos;
              iVar9 = ex_efct((uint)ex_effect);
              *pLVar1 = effect | (ushort)iVar9;
              HTMLlineproc2body::outc[pos] = ' ';
              pos = pos + 1;
              str = str + WTF_LEN_MAP[(byte)*str];
            }
          }
          else {
            buf = set_symbol(symbol_width0);
            p = buf[symbol];
            len = (int)WTF_LEN_MAP[(byte)*p];
            mode = (ushort)WTF_TYPE_MAP[(byte)*p] << 8;
            pLVar1 = HTMLlineproc2body::outp + pos;
            uVar7 = effect | mode;
            iVar9 = ex_efct((uint)ex_effect);
            *pLVar1 = (ushort)iVar9 | uVar7;
            HTMLlineproc2body::outc[pos] = *p;
            p = p + 1;
            pos = pos + 1;
            len = len + -1;
            if (len != 0) {
              mode = mode & 0xff | (ushort)((byte)((uint)mode >> 8) & 0xf9) << 8 | 0x400;
              while (bVar22 = len != 0, len = len + -1, bVar22) {
                if (HTMLlineproc2body::out_size <= pos + 1) {
                  HTMLlineproc2body::out_size = (pos * 3) / 2;
                  HTMLlineproc2body::outc =
                       (char *)GC_realloc(HTMLlineproc2body::outc,HTMLlineproc2body::out_size);
                  HTMLlineproc2body::outp =
                       (Lineprop *)
                       GC_realloc(HTMLlineproc2body::outp,HTMLlineproc2body::out_size * 2);
                }
                pLVar1 = HTMLlineproc2body::outp + pos;
                uVar7 = effect | mode;
                iVar9 = ex_efct((uint)ex_effect);
                *pLVar1 = (ushort)iVar9 | uVar7;
                HTMLlineproc2body::outc[pos] = *p;
                p = p + 1;
                pos = pos + 1;
              }
            }
            str = str + symbol_width;
          }
        }
        if (internal == 0) {
          addnewline(buf_1,HTMLlineproc2body::outc,HTMLlineproc2body::outp,(Linecolor *)0x0,pos,-1,
                     nlines);
        }
        if (internal == 0x8e) {
          internal = 0;
        }
        if (str == endp) goto LAB_0806bfe6;
        line = Strsubstr(line,(int)str - (int)line->ptr,(int)endp - (int)str);
      } while( true );
    }
    Strcat(textarea_str[n_textarea],line);
  } while( true );
}



void addLink(Buffer *buf,parsed_tag *tag)

{
  wc_ces t_ces;
  wc_ces f_ces;
  char *p;
  Str p_Var1;
  LinkList *pLVar2;
  LinkList *i;
  LinkList *l;
  char *rev;
  char *rel;
  char *ctype;
  char *title;
  char *href;
  char type;
  
  href = (char *)0x0;
  title = (char *)0x0;
  ctype = (char *)0x0;
  rel = (char *)0x0;
  rev = (char *)0x0;
  type = '\0';
  parsedtag_get_value(tag,0x12,&href);
  f_ces = InnerCharset;
  if (href != (char *)0x0) {
    t_ces = buf->document_charset;
    p = remove_space(href);
    p_Var1 = Strnew_charp(p);
    p_Var1 = wc_Str_conv_strict(p_Var1,f_ces,t_ces);
    href = url_quote(p_Var1->ptr);
  }
  parsedtag_get_value(tag,0x31,&title);
  parsedtag_get_value(tag,0x21,&ctype);
  parsedtag_get_value(tag,0x2f,&rel);
  if ((rel != (char *)0x0) && (type = '\x01', title == (char *)0x0)) {
    title = rel;
  }
  parsedtag_get_value(tag,0x30,&rev);
  if ((rev != (char *)0x0) && (type = '\x02', title == (char *)0x0)) {
    title = rev;
  }
  pLVar2 = (LinkList *)GC_malloc(0x14);
  pLVar2->url = href;
  pLVar2->title = title;
  pLVar2->ctype = ctype;
  pLVar2->type = type;
  pLVar2->next = (_LinkList *)0x0;
  if (buf->linklist == (LinkList *)0x0) {
    buf->linklist = pLVar2;
  }
  else {
    for (i = buf->linklist; i->next != (_LinkList *)0x0; i = i->next) {
    }
    i->next = pLVar2;
  }
  return;
}



void HTMLlineproc2(Buffer *buf,TextLineList *tl)

{
  _tl_lp2 = tl->first;
  HTMLlineproc2body(buf,textlist_feed,-1);
  return;
}



Str file_feed(void)

{
  Str p_Var1;
  Str s;
  
  p_Var1 = StrISgets(_file_lp2);
  if (p_Var1->length == 0) {
    ISclose(_file_lp2);
    p_Var1 = (Str)0x0;
  }
  return p_Var1;
}



void HTMLlineproc3(Buffer *buf,InputStream stream)

{
  _file_lp2 = stream;
  HTMLlineproc2body(buf,file_feed,-1);
  return;
}



void proc_escape(readbuffer *obuf,char **str_return)

{
  char *str_00;
  char *pcVar1;
  uint c;
  byte *p;
  int width_00;
  size_t sVar2;
  int n_add;
  int width;
  int ech;
  char *estr;
  char *str;
  Lineprop mode;
  
  str_00 = *str_return;
  c = getescapechar(str_return);
  pcVar1 = *str_return;
  if ((int)c < 0) {
    *str_return = str_00;
    proc_mchar(obuf,obuf->flag & 0x28f,1,str_return,0);
  }
  else {
    if ((MYCTYPE_MAP[c & 0xff] & 1) == 0) {
      mode = 0;
    }
    else {
      mode = 0x100;
    }
    p = (byte *)conv_entity(c);
    check_breakpoint(obuf,obuf->flag & 0x28f,(char *)p);
    width_00 = wtf_strwidth(p);
    if ((((width_00 == 1) && (*p == c)) && (c != 0x26)) && ((c != 0x3c && (c != 0x3e)))) {
      if ((MYCTYPE_MAP[c & 0xff] & 1) != 0) {
        mode = 0x100;
      }
      sVar2 = strlen((char *)p);
      push_nchars(obuf,1,(char *)p,sVar2,mode);
    }
    else {
      push_nchars(obuf,width_00,str_00,(int)pcVar1 - (int)str_00,mode);
    }
    sVar2 = strlen((char *)p);
    Strcopy_charp_n(obuf->prevchar,(char *)p,sVar2);
    obuf->prev_ctype = mode;
  }
  return;
}



int need_flushline(html_feed_environ *h_env,readbuffer *obuf,Lineprop mode)

{
  char cVar1;
  int iVar2;
  char ch;
  
  if ((obuf->flag & 0x200U) == 0) {
    if (obuf->line->length < 1) {
      cVar1 = '\0';
    }
    else {
      cVar1 = obuf->line->ptr[obuf->line->length + -1];
    }
    if (cVar1 == ' ') {
      iVar2 = 0;
    }
    else if (h_env->limit < (int)obuf->pos) {
      iVar2 = 1;
    }
    else {
      iVar2 = 0;
    }
  }
  else if (h_env->limit < (int)obuf->pos) {
    iVar2 = 1;
  }
  else {
    iVar2 = 0;
  }
  return iVar2;
}



int table_width(html_feed_environ *h_env,int table_level)

{
  int iVar1;
  int width;
  
  if (table_level < 0) {
    iVar1 = 0;
  }
  else {
    iVar1 = tables[table_level]->total_width;
    if ((table_level < 1) && (iVar1 < 1)) {
      iVar1 = h_env->limit - (int)h_env->envs[h_env->envc].indent;
    }
  }
  return iVar1;
}



void HTMLlineproc0(char *line_1,html_feed_environ *h_env,int internal)

{
  char *pcVar1;
  byte bVar2;
  short sVar3;
  int iVar4;
  Str p_Var5;
  size_t len;
  byte bVar6;
  int i_1;
  char *tp_1;
  Str line;
  int i;
  char *tp;
  char *bp;
  char *p_2;
  int ech;
  char *p_1;
  int indent_2;
  int indent_1;
  table *tbl0;
  int end_tag;
  int pre_mode;
  int is_tag;
  char *p;
  char *str;
  int level;
  int prev_is_hangul;
  int is_hangul;
  int tbl_width;
  table_mode *tbl_mode;
  table *tbl;
  Str tokbuf;
  parsed_tag *tag;
  int delta;
  int indent;
  readbuffer *obuf;
  int cmd;
  Lineprop mode;
  char ch;
  
  obuf = h_env->obuf;
  tbl = (table *)0x0;
  tbl_mode = (table_mode *)0x0;
  tbl_width = 0;
  prev_is_hangul = 0;
  tokbuf = Strnew();
  do {
    if (-1 < obuf->table_level) {
      sVar3 = obuf->table_level;
      if (0x13 < sVar3) {
        sVar3 = 0x13;
      }
      level = (int)sVar3;
      tbl = tables[level];
      tbl_mode = table_mode + level;
      tbl_width = table_width(h_env,level);
    }
LAB_0806d451:
    if (*line_1 == '\0') {
      if ((obuf->flag & 0x1a8fU) == 0) {
        i_1 = 0;
        if ((obuf->bp).pos == (int)obuf->pos) {
          tp_1 = obuf->line->ptr + ((obuf->bp).len - (obuf->bp).tlen);
        }
        else {
          tp_1 = obuf->line->ptr + obuf->line->length;
        }
        if ((obuf->line->ptr < tp_1) && (tp_1[-1] == ' ')) {
          i_1 = 1;
        }
        indent = (int)h_env->envs[h_env->envc].indent;
        if (h_env->limit < obuf->pos - i_1) {
          flushline(h_env,obuf,indent,0,h_env->limit);
        }
      }
      return;
    }
    is_tag = 0;
    if (obuf->table_level < 0) {
      pre_mode = obuf->flag;
    }
    else {
      pre_mode = tbl_mode->pre_mode;
    }
    if (obuf->table_level < 0) {
      bVar2 = obuf->end_tag;
    }
    else {
      bVar2 = tbl_mode->end_tag;
    }
    end_tag = (int)bVar2;
    if ((*line_1 == '<') || (obuf->status != 0)) {
      if (obuf->status == 7) {
        obuf->status = 0;
      }
      else {
        read_token(h_env->tagbuf,&line_1,&obuf->status,pre_mode & 0xa0f,(uint)(obuf->status != 0));
        if (obuf->status != 0) {
          return;
        }
      }
      if (h_env->tagbuf->length == 0) goto LAB_0806d451;
      str = h_env->tagbuf->ptr;
      if (*str == '<') {
        if ((str[1] == '\0') ||
           ((((((MYCTYPE_MAP[(byte)str[1]] & 4) == 0 && (str[1] != '/')) && (str[1] != '!')) &&
             ((str[1] != '?' && (str[1] != '\0')))) && (str[1] != '_')))) {
          if ((pre_mode & 0x580eU) == 0) {
            p_Var5 = Strnew_m_charp(str + 1,line_1,0);
            line_1 = p_Var5->ptr;
            str = "&lt;";
          }
        }
        else {
          is_tag = 1;
        }
      }
    }
    else {
      read_token(tokbuf,&line_1,&obuf->status,pre_mode & 0xa0f,0);
      if (obuf->status != 0) {
        obuf->status = 0;
      }
      str = tokbuf->ptr;
    }
    if ((pre_mode & 0x580eU) != 0) {
      if (is_tag != 0) {
        p = str;
        tag = parse_tag(&p,internal);
        if ((tag != (parsed_tag *)0x0) &&
           ((((uint)tag->tagid == end_tag || (((pre_mode & 0x1000U) != 0 && (tag->tagid == '+'))))
            || (((pre_mode & 0x4000U) != 0 && ((tag->tagid == '`' || (tag->tagid == 'H'))))))))
        goto proc_normal;
      }
      if ((pre_mode & 0x4000U) != 0) {
        feed_title(str);
        goto LAB_0806d451;
      }
      if ((pre_mode & 0x1000U) == 0) {
        if (is_tag != 0) {
          iVar4 = strncmp(str,"<!--",4);
          if ((iVar4 != 0) && (p = strchr(str + 1,0x3c), p != (char *)0x0)) {
            p_Var5 = Strnew_charp_n(str,(int)p - (int)str);
            str = p_Var5->ptr;
            p_Var5 = Strnew_m_charp(p,line_1,0);
            line_1 = p_Var5->ptr;
          }
          is_tag = 0;
        }
        if (obuf->table_level < 0) {
          if ((pre_mode & 0x800U) != 0) {
            feed_textarea(str);
            goto LAB_0806d451;
          }
          if (((pre_mode & 2U) != 0) || ((pre_mode & 4U) != 0)) goto LAB_0806d451;
        }
      }
      else if (obuf->table_level < 0) {
        feed_select(str);
        goto LAB_0806d451;
      }
    }
proc_normal:
    if (-1 < obuf->table_level) {
      iVar4 = feed_table(tbl,str,tbl_mode,tbl_width,internal);
      if (iVar4 == 0) {
        obuf->table_level = obuf->table_level + -1;
        if (obuf->table_level < 0x13) {
          end_table(tbl);
          if (obuf->table_level < 0) {
            if ((obuf->flag & 0x100000U) == 0) {
              if ((0 < tbl->vspace) && ((obuf->flag & 0x2000U) == 0)) {
                indent_1 = (int)h_env->envs[h_env->envc].indent;
                flushline(h_env,obuf,indent_1,0,h_env->limit);
                do_blankline(h_env,obuf,indent_1,0,h_env->limit);
              }
              save_fonteffect(h_env,obuf);
              renderTable(tbl,tbl_width,h_env);
              restore_fonteffect(h_env,obuf);
              obuf->flag = obuf->flag & 0xffffdfff;
              if (0 < tbl->vspace) {
                indent_2 = (int)h_env->envs[h_env->envc].indent;
                do_blankline(h_env,obuf,indent_2,0,h_env->limit);
                obuf->flag = obuf->flag | 0x2000;
              }
              Strcopy_charp_n(obuf->prevchar," ",1);
            }
          }
          else {
            tbl0 = tables[obuf->table_level];
            p_Var5 = Sprintf("<table_alt tid=%d>",(int)tbl0->ntable);
            str = p_Var5->ptr;
            pushTable(tbl0,tbl);
            tbl = tbl0;
            tbl_mode = table_mode + obuf->table_level;
            tbl_width = table_width(h_env,(int)obuf->table_level);
            feed_table(tbl,str,tbl_mode,tbl_width,1);
          }
        }
        goto LAB_0806d451;
      }
      if (iVar4 != 1) goto LAB_0806d451;
    }
    if (is_tag == 0) {
      if ((obuf->flag & 0x300000U) == 0) {
        while (*str != '\0') {
          bVar2 = WTF_TYPE_MAP[(byte)*str];
          mode = (ushort)bVar2 << 8;
          if (WcOption.use_wide == '\0') {
            bVar6 = WTF_WIDTH_MAP[(byte)*str] != '\0';
          }
          else {
            bVar6 = WTF_WIDTH_MAP[(byte)*str];
          }
          delta = (int)bVar6;
          if ((obuf->flag & 0x20fU) == 0) {
            if ((MYCTYPE_MAP[(byte)*str] & 2) == 0) {
              obuf->flag = obuf->flag & 0xffffdfff;
            }
            if (((bVar2 == 0) || (bVar2 == 1)) && ((MYCTYPE_MAP[(byte)*str] & 2) != 0)) {
              if (*obuf->prevchar->ptr != ' ') {
                push_char(obuf,obuf->flag & 0x28f,' ');
              }
              str = str + 1;
            }
            else {
              if (bVar2 == 10) {
                bVar2 = wtf_is_hangul((wc_uchar *)str);
                is_hangul = (int)bVar2;
              }
              else {
                is_hangul = 0;
              }
              if (((((SimplePreserveSpace == '\0') && (mode == 0xa00)) &&
                   ((is_hangul == 0 &&
                    ((prev_is_hangul == 0 && ((short)h_env->envs[h_env->envc].indent < obuf->pos))))
                   )) && (0 < obuf->line->length)) &&
                 (obuf->line->ptr[obuf->line->length + -1] == ' ')) {
                while (((1 < obuf->line->length &&
                        (iVar4 = strncmp(obuf->line->ptr + obuf->line->length + -2,"  ",2),
                        iVar4 == 0)) && ((short)h_env->envs[h_env->envc].indent <= obuf->pos))) {
                  Strshrink(obuf->line,1);
                  obuf->pos = obuf->pos + -1;
                }
                if (((2 < obuf->line->length) && (obuf->prev_ctype == 0xa00)) &&
                   ((0 < obuf->line->length &&
                    ((obuf->line->ptr[obuf->line->length + -1] == ' ' &&
                     ((short)h_env->envs[h_env->envc].indent <= obuf->pos)))))) {
                  Strshrink(obuf->line,1);
                  obuf->pos = obuf->pos + -1;
                }
              }
              prev_is_hangul = is_hangul;
              if (*str == '&') {
                proc_escape(obuf,&str);
              }
              else {
                proc_mchar(obuf,obuf->flag & 0x28f,delta,&str,mode);
              }
            }
            goto LAB_0806d2f8;
          }
          ch = *str;
          if (((obuf->flag & 8U) == 0) && (*str == '&')) {
            p_1 = str;
            iVar4 = getescapechar(&p_1);
            if ((iVar4 == 10) || (iVar4 == 0xd)) {
              ch = '\n';
              str = p_1 + -1;
            }
            else if (iVar4 == 9) {
              ch = '\t';
              str = p_1 + -1;
            }
          }
          if (ch == '\n') {
            str = str + 1;
            if ((obuf->flag & 0x2000U) == 0) {
              if ((obuf->flag & 0x200U) == 0) {
                flushline(h_env,obuf,(int)h_env->envs[h_env->envc].indent,1,h_env->limit);
              }
              else {
                push_char(obuf,obuf->flag & 0x28f,' ');
              }
              goto LAB_0806d02e;
            }
            obuf->flag = obuf->flag & 0xffffdfff;
          }
          else {
            obuf->flag = obuf->flag & 0xffffdfff;
            if (ch == '\t') {
              do {
                push_char(obuf,obuf->flag & 0x28f,' ');
              } while (((int)h_env->envs[h_env->envc].indent + (int)obuf->pos) % Tabstop != 0);
              str = str + 1;
            }
            else if ((obuf->flag & 8U) == 0) {
              if (*str == '&') {
                proc_escape(obuf,&str);
              }
              else {
                proc_mchar(obuf,1,delta,&str,mode);
              }
            }
            else {
              pcVar1 = HTML_QUOTE_MAP[QUOTE_MAP[(byte)*str] & 7];
              if (pcVar1 == (char *)0x0) {
                proc_mchar(obuf,1,delta,&str,mode);
              }
              else {
                len = strlen(pcVar1);
                push_nchars(obuf,1,pcVar1,len,0);
                str = str + 1;
              }
            }
LAB_0806d02e:
            if ((obuf->flag & 0x8fU) == 0) {
LAB_0806d2f8:
              iVar4 = need_flushline(h_env,obuf,mode);
              if (iVar4 != 0) {
                pcVar1 = obuf->line->ptr + (obuf->bp).len;
                i = 0;
                if ((obuf->line->ptr < pcVar1 + -(obuf->bp).tlen) &&
                   ((pcVar1 + -(obuf->bp).tlen)[-1] == ' ')) {
                  i = 1;
                }
                indent = (int)h_env->envs[h_env->envc].indent;
                if (indent < (obuf->bp).pos - i) {
                  append_tags(obuf);
                  p_Var5 = Strnew_charp(pcVar1);
                  Strshrink(obuf->line,obuf->line->length - (obuf->bp).len);
                  back_to_breakpoint(obuf);
                  flushline(h_env,obuf,indent,0,h_env->limit);
                  HTMLlineproc0(p_Var5->ptr,h_env,1);
                }
              }
            }
          }
        }
      }
      goto LAB_0806d451;
    }
    tag = parse_tag(&str,internal);
    if (tag == (parsed_tag *)0x0) goto LAB_0806d451;
    cmd = (int)tag->tagid;
    iVar4 = HTMLtagproc1(tag,h_env);
    if (iVar4 == 0) {
      if (tag->need_reconstruct != '\0') {
        p_Var5 = parsedtag2str(tag);
        h_env->tagbuf = p_Var5;
      }
      push_tag(obuf,h_env->tagbuf->ptr,cmd);
    }
    else {
      process_idattr(obuf,cmd,tag);
    }
    (obuf->bp).init_flag = '\x01';
    clear_ignore_p_flag(cmd,obuf);
    if (cmd != 0x1f) goto LAB_0806d451;
  } while( true );
}



void addnewline2(Buffer *buf,char *line,Lineprop *prop,Linecolor *color,int pos,int nlines)

{
  _Line *p_Var1;
  Line *l;
  
  p_Var1 = (_Line *)GC_malloc(0x34);
  p_Var1->next = (_Line *)0x0;
  p_Var1->lineBuf = line;
  p_Var1->propBuf = prop;
  p_Var1->colorBuf = color;
  p_Var1->len = pos;
  p_Var1->width = -1;
  p_Var1->size = pos;
  p_Var1->bpos = 0;
  p_Var1->bwidth = 0;
  p_Var1->prev = buf->currentLine;
  if (buf->currentLine == (Line *)0x0) {
    p_Var1->next = (_Line *)0x0;
  }
  else {
    p_Var1->next = buf->currentLine->next;
    buf->currentLine->next = p_Var1;
  }
  if ((buf->lastLine == (Line *)0x0) || (buf->lastLine == buf->currentLine)) {
    buf->lastLine = p_Var1;
  }
  buf->currentLine = p_Var1;
  if (buf->firstLine == (Line *)0x0) {
    buf->firstLine = p_Var1;
  }
  buf->allLine = buf->allLine + 1;
  p_Var1->linenumber = buf->allLine;
  if (nlines < 0) {
    p_Var1->real_linenumber = 0;
  }
  else {
    p_Var1->real_linenumber = nlines;
  }
  return;
}



void addnewline(Buffer *buf,char *line,Lineprop *prop,Linecolor *color,int pos,int width,int nlines)

{
  Line *line_00;
  int iVar1;
  int bwidth;
  int bpos;
  int i;
  Line *l;
  Linecolor *c;
  Lineprop *p;
  char *s;
  
  if (pos < 1) {
    p = NullProp;
    s = NullLine;
  }
  else {
    s = allocStr(line,pos);
    p = (Lineprop *)GC_malloc_atomic(pos * 2);
    bcopy(prop,p,pos * 2);
    if (color != (Linecolor *)0x0) {
      c = (Linecolor *)GC_malloc_atomic(pos);
      bcopy(color,c,pos);
      goto LAB_0806d712;
    }
  }
  c = (Linecolor *)0x0;
LAB_0806d712:
  addnewline2(buf,s,p,c,pos,nlines);
  if ((pos < 1) || (width < 1)) {
    return;
  }
  bpos = 0;
  bwidth = 0;
  do {
    line_00 = buf->currentLine;
    line_00->bpos = bpos;
    line_00->bwidth = bwidth;
    i = columnLen(line_00,width);
    if (i == 0) {
      do {
        i = i + 1;
        if (line_00->len <= i) break;
      } while ((p[i] & 0x400) != 0);
    }
    line_00->len = i;
    iVar1 = calcPosition(line_00->lineBuf,line_00->propBuf,line_00->len,line_00->len,0,0);
    line_00->width = iVar1;
    if (pos <= i) {
      return;
    }
    bpos = bpos + line_00->len;
    bwidth = bwidth + line_00->width;
    s = s + i;
    p = p + i;
    if (c != (Linecolor *)0x0) {
      c = c + i;
    }
    pos = pos - i;
    addnewline2(buf,s,p,c,pos,nlines);
  } while( true );
}



Buffer * loadHTMLBuffer(URLFile *f,Buffer *newBuf)

{
  int iVar1;
  Str p_Var2;
  Str tmp;
  FILE *src;
  
  src = (FILE *)0x0;
  if (newBuf == (Buffer *)0x0) {
    if (showLineNum == 0) {
      iVar1 = 1;
    }
    else {
      iVar1 = 6;
    }
    iVar1 = COLS - iVar1;
    if (iVar1 < 0) {
      iVar1 = 0;
    }
    newBuf = newBuffer(iVar1);
  }
  if ((newBuf->sourcefile == (char *)0x0) &&
     ((f->scheme != '\x04' || (newBuf->mailcap != (mailcap *)0x0)))) {
    p_Var2 = tmpfname(1,".html");
    src = (FILE *)fopen(p_Var2->ptr,"w");
    if ((FILE *)src != (FILE *)0x0) {
      newBuf->sourcefile = p_Var2->ptr;
    }
  }
  loadHTMLstream(f,newBuf,src,(int)newBuf->bufferprop & 2);
  newBuf->topLine = newBuf->firstLine;
  newBuf->lastLine = newBuf->currentLine;
  newBuf->currentLine = newBuf->firstLine;
  if (n_textarea != 0) {
    formResetBuffer(newBuf,newBuf->formitem);
  }
  if (src != (FILE *)0x0) {
    fclose((FILE *)src);
  }
  return newBuf;
}



char * convert_size(clen_t size,int usefloat)

{
  char *pcVar1;
  char *fmt;
  Str p_Var2;
  double dVar3;
  char **sizes;
  int sizepos;
  float csize;
  
  csize = (float)size;
  for (sizepos = 0; (999.495 <= csize && (_size_unit[sizepos + 1] != (char *)0x0));
      sizepos = sizepos + 1) {
    csize = csize / 1024.0;
  }
  pcVar1 = _size_unit[sizepos];
  dVar3 = floor((double)(csize * 100.0 + 0.5));
  if (usefloat == 0) {
    fmt = "%.0f%s";
  }
  else {
    fmt = "%.3g%s";
  }
  p_Var2 = Sprintf(fmt,SUB84(dVar3 / 100.0,0),(int)((ulonglong)(dVar3 / 100.0) >> 0x20),pcVar1);
  return p_Var2->ptr;
}



// WARNING: Removing unreachable block (ram,0x0806dabd)

char * convert_size2(clen_t size1,clen_t size2,int usefloat)

{
  char *pcVar1;
  longlong lVar2;
  char *fmt;
  Str p_Var3;
  double dVar4;
  double dVar5;
  int sizepos;
  float factor;
  float csize;
  char **sizes;
  
  factor = 1.0;
  sizepos = 0;
  lVar2 = size2;
  if (size2 < size1) {
    lVar2 = size1;
  }
  for (; (999.495 <= (float)lVar2 / factor && (_size_unit[sizepos + 1] != (char *)0x0));
      sizepos = sizepos + 1) {
    factor = factor * 1024.0;
  }
  pcVar1 = _size_unit[sizepos];
  dVar4 = floor((double)(((float)size2 / factor) * 100.0 + 0.5));
  dVar5 = floor((double)(((float)size1 / factor) * 100.0 + 0.5));
  if (usefloat == 0) {
    fmt = "%.0f/%.0f%s";
  }
  else {
    fmt = "%.3g/%.3g%s";
  }
  p_Var3 = Sprintf(fmt,SUB84(dVar5 / 100.0,0),(int)((ulonglong)(dVar5 / 100.0) >> 0x20),
                   dVar4 / 100.0,pcVar1);
  return p_Var3->ptr;
}



void showProgress(clen_t *linelen,clen_t *trbyte)

{
  uint uVar1;
  longlong lVar2;
  double dVar3;
  clen_t size;
  time_t tVar4;
  char *pcVar5;
  int iVar6;
  char *pcVar7;
  uint uVar8;
  double ratio;
  char *fmrate;
  char *fmtrbyte;
  Str messages;
  time_t cur_time;
  int pos;
  int eta;
  int duration;
  int rate;
  int j;
  int i;
  
  if (fmInitialized != '\0') {
    if ((0 < *(int *)((int)linelen + 4)) ||
       ((-1 < *(int *)((int)linelen + 4) && (0x3ff < *(uint *)linelen)))) {
      if ((current_content_length._4_4_ < 0) ||
         ((current_content_length._4_4_ < 1 && ((uint)current_content_length == 0)))) {
        tVar4 = time((time_t *)0x0);
        if ((*(uint *)trbyte | *(uint *)((int)trbyte + 4)) == 0) {
          move(LINES + -1,0);
          clrtoeolx();
          showProgress::start_time = tVar4;
        }
        uVar8 = *(uint *)trbyte;
        iVar6 = *(int *)((int)linelen + 4);
        uVar1 = *(uint *)linelen;
        *(uint *)trbyte = uVar1 + uVar8;
        *(uint *)((int)trbyte + 4) = iVar6 + *(int *)((int)trbyte + 4) + (uint)CARRY4(uVar1,uVar8);
        *(undefined4 *)linelen = 0;
        *(undefined4 *)((int)linelen + 4) = 0;
        if (tVar4 != showProgress::last_time) {
          showProgress::last_time = tVar4;
          move(LINES + -1,0);
          pcVar5 = convert_size(*trbyte,1);
          if (tVar4 == showProgress::start_time) {
            messages = Sprintf("%7s loaded",pcVar5);
          }
          else {
            size = __divdi3(*(undefined4 *)trbyte,*(undefined4 *)((int)trbyte + 4));
            convert_size(size,1);
            messages = Sprintf("%7s loaded %7s/s",pcVar5);
          }
          message(messages->ptr,0,0);
          refresh();
        }
      }
      else {
        tVar4 = time((time_t *)0x0);
        if ((*(uint *)trbyte | *(uint *)((int)trbyte + 4)) == 0) {
          move(LINES + -1,0);
          clrtoeolx();
          showProgress::start_time = tVar4;
        }
        uVar8 = *(uint *)trbyte;
        iVar6 = *(int *)((int)linelen + 4);
        uVar1 = *(uint *)linelen;
        *(uint *)trbyte = uVar1 + uVar8;
        *(uint *)((int)trbyte + 4) = iVar6 + *(int *)((int)trbyte + 4) + (uint)CARRY4(uVar1,uVar8);
        *(undefined4 *)linelen = 0;
        *(undefined4 *)((int)linelen + 4) = 0;
        if (tVar4 != showProgress::last_time) {
          showProgress::last_time = tVar4;
          move(LINES + -1,0);
          dVar3 = ((double)*trbyte * 100.0) /
                  (double)CONCAT44(current_content_length._4_4_,(uint)current_content_length);
          pcVar5 = convert_size2(*trbyte,CONCAT44(current_content_length._4_4_,
                                                  (uint)current_content_length),1);
          if (tVar4 == showProgress::start_time) {
            messages = Sprintf("%11s %3.0f%%                          ",pcVar5,dVar3);
          }
          else {
            iVar6 = __divdi3(*(undefined4 *)trbyte,*(undefined4 *)((int)trbyte + 4));
            pcVar7 = convert_size((longlong)iVar6,1);
            if (iVar6 == 0) {
              iVar6 = -1;
            }
            else {
              iVar6 = __divdi3((uint)current_content_length - *(uint *)trbyte,
                               (current_content_length._4_4_ - *(int *)((int)trbyte + 4)) -
                               (uint)((uint)current_content_length < *(uint *)trbyte),iVar6,
                               iVar6 >> 0x1f);
            }
            messages = Sprintf("%11s %3.0f%% %7s/s eta %02d:%02d:%02d     ",pcVar5,dVar3,pcVar7,
                               iVar6 / 0xe10,(iVar6 / 0x3c) % 0x3c,iVar6 % 0x3c);
          }
          addstr(messages->ptr);
          uVar8 = COLS - 0x2b;
          lVar2 = (ulonglong)*(uint *)trbyte * (ulonglong)uVar8;
          iVar6 = __divdi3((int)lVar2,
                           ((int)uVar8 >> 0x1f) * *(uint *)trbyte +
                           *(int *)((int)trbyte + 4) * uVar8 + (int)((ulonglong)lVar2 >> 0x20),
                           (uint)current_content_length,current_content_length._4_4_);
          move(LINES + -1,0x2a);
          standout();
          addch(' ');
          for (j = 0x2b; j <= iVar6 + 0x2a; j = j + 1) {
            addch('|');
          }
          standend();
          refresh();
        }
      }
    }
  }
  return;
}



void init_henv(html_feed_environ *h_env,readbuffer *obuf,environment *envs,int nenv,
              TextLineList *buf,int limit,int indent)

{
  Str p_Var1;
  
  envs->indent = (char)indent;
  p_Var1 = Strnew();
  obuf->line = p_Var1;
  obuf->cprop = 0;
  obuf->pos = 0;
  p_Var1 = Strnew_size(8);
  obuf->prevchar = p_Var1;
  Strcopy_charp_n(obuf->prevchar," ",1);
  obuf->flag = 0x2000;
  obuf->flag_sp = 0;
  obuf->status = 0;
  obuf->table_level = -1;
  obuf->nobr_level = 0;
  bzero(&obuf->anchor,0x3c);
  obuf->img_alt = (Str)0x0;
  obuf->fontstat[0] = '\0';
  obuf->fontstat[2] = '\0';
  obuf->fontstat[1] = '\0';
  obuf->fontstat[3] = '\0';
  obuf->fontstat[4] = '\0';
  obuf->prev_ctype = 0;
  obuf->tag_sp = 0;
  obuf->fontstat_sp = 0;
  obuf->top_margin = 0;
  obuf->bottom_margin = 0;
  (obuf->bp).init_flag = '\x01';
  set_breakpoint(obuf,0);
  h_env->buf = buf;
  h_env->f = (FILE *)0x0;
  h_env->obuf = obuf;
  p_Var1 = Strnew();
  h_env->tagbuf = p_Var1;
  h_env->limit = limit;
  h_env->maxlimit = 0;
  h_env->envs = envs;
  h_env->nenv = nenv;
  h_env->envc = 0;
  h_env->envc_real = 0;
  h_env->title = (char *)0x0;
  h_env->blank_lines = 0;
  return;
}



void completeHTMLstream(html_feed_environ *h_env,readbuffer *obuf)

{
  close_anchor(h_env,obuf);
  if (obuf->img_alt != (Str)0x0) {
    push_tag(obuf,"</img_alt>",0x89);
    obuf->img_alt = (Str)0x0;
  }
  if (obuf->fontstat[0] != '\0') {
    push_tag(obuf,"</b>",8);
    obuf->fontstat[0] = '\0';
  }
  if (obuf->fontstat[2] != '\0') {
    push_tag(obuf,"</i>",0x6e);
    obuf->fontstat[2] = '\0';
  }
  if (obuf->fontstat[1] != '\0') {
    push_tag(obuf,"</u>",0x42);
    obuf->fontstat[1] = '\0';
  }
  if (obuf->fontstat[3] != '\0') {
    push_tag(obuf,"</s>",0x6a);
    obuf->fontstat[3] = '\0';
  }
  if (obuf->fontstat[4] != '\0') {
    push_tag(obuf,"</ins>",0x40);
    obuf->fontstat[4] = '\0';
  }
  if ((obuf->flag & 0x800U) != 0) {
    HTMLlineproc0("</textarea>",h_env,1);
  }
  if ((obuf->flag & 0x1000U) != 0) {
    HTMLlineproc0("</select>",h_env,1);
  }
  if ((obuf->flag & 0x4000U) != 0) {
    HTMLlineproc0("</title>",h_env,1);
  }
  if (0x13 < obuf->table_level) {
    obuf->table_level = 0x13;
  }
  while (-1 < obuf->table_level) {
    table_mode[obuf->table_level].pre_mode = table_mode[obuf->table_level].pre_mode & 0xfffffff1;
    HTMLlineproc0("</table>",h_env,1);
  }
  return;
}



void print_internal_information(html_feed_environ *henv)

{
  GeneralList *tl_00;
  Str p_Var1;
  TextLine *pTVar2;
  char *pcVar3;
  char *pcVar4;
  char *pcVar5;
  TextLineListItem *p;
  FormSelectOptionItem *ip;
  TextLineList *tl;
  Str s;
  int i;
  
  tl_00 = newGeneralList();
  p_Var1 = Strnew_charp("<internal>");
  pTVar2 = newTextLine(p_Var1,0);
  pushValue(tl_00,pTVar2);
  if (henv->title != (char *)0x0) {
    pcVar3 = html_quote(henv->title);
    p_Var1 = Strnew_m_charp("<title_alt title=\"",pcVar3,&DAT_080c9bbb,0);
    pTVar2 = newTextLine(p_Var1,0);
    pushValue(tl_00,pTVar2);
  }
  if (0 < n_select) {
    for (i = 0; i < n_select; i = i + 1) {
      p_Var1 = Sprintf("<select_int selectnumber=%d>",i);
      pTVar2 = newTextLine(p_Var1,0);
      pushValue(tl_00,pTVar2);
      for (ip = select_option[i].first; ip != (FormSelectOptionItem *)0x0; ip = ip->next) {
        if (ip->checked == 0) {
          pcVar3 = "";
        }
        else {
          pcVar3 = " selected";
        }
        pcVar4 = html_quote(ip->label->ptr);
        if (ip->value == (Str)0x0) {
          pcVar5 = ip->label->ptr;
        }
        else {
          pcVar5 = ip->value->ptr;
        }
        pcVar5 = html_quote(pcVar5);
        p_Var1 = Sprintf("<option_int value=\"%s\" label=\"%s\"%s>",pcVar5,pcVar4,pcVar3);
        pTVar2 = newTextLine(p_Var1,0);
        pushValue(tl_00,pTVar2);
      }
      p_Var1 = Strnew_charp("</select_int>");
      pTVar2 = newTextLine(p_Var1,0);
      pushValue(tl_00,pTVar2);
    }
  }
  if (0 < n_textarea) {
    for (i = 0; i < n_textarea; i = i + 1) {
      p_Var1 = Sprintf("<textarea_int textareanumber=%d>",i);
      pTVar2 = newTextLine(p_Var1,0);
      pushValue(tl_00,pTVar2);
      pcVar3 = html_quote(textarea_str[i]->ptr);
      p_Var1 = Strnew_charp(pcVar3);
      Strcat_charp(p_Var1,"</textarea_int>");
      pTVar2 = newTextLine(p_Var1,0);
      pushValue(tl_00,pTVar2);
    }
  }
  p_Var1 = Strnew_charp("</internal>");
  pTVar2 = newTextLine(p_Var1,0);
  pushValue(tl_00,pTVar2);
  if (henv->buf == (TextLineList *)0x0) {
    if (henv->f != (FILE *)0x0) {
      for (p = (TextLineListItem *)tl_00->first; p != (TextLineListItem *)0x0; p = p->next) {
        if (ExtHalfdump == '\0') {
          p_Var1 = p->ptr->line;
        }
        else {
          p_Var1 = wc_Str_conv(p->ptr->line,InnerCharset,DisplayCharset);
        }
        fprintf((FILE *)henv->f,"%s\n",p_Var1->ptr);
      }
    }
  }
  else {
    appendGeneralList((GeneralList *)henv->buf,tl_00);
  }
  return;
}



// WARNING: Could not reconcile some variable overlaps

void loadHTMLstream(URLFile *f,Buffer *newBuf,FILE *src,int internal)

{
  uint uVar1;
  int iVar2;
  InputStream piVar3;
  char *pcVar4;
  bool bVar5;
  readbuffer obuf;
  environment envs [20];
  html_feed_environ htmlenv1;
  clen_t trbyte;
  clen_t linelen;
  anon_subr_void_int *prevtrap;
  int image_flag;
  wc_ces doc_charset;
  wc_ces charset;
  Str lineBuf2;
  
  linelen._0_4_ = 0;
  linelen._4_4_ = 0;
  trbyte._0_4_ = 0;
  trbyte._4_4_ = 0;
  lineBuf2 = Strnew();
  charset = 0x100;
  doc_charset = DocumentCharset;
  prevtrap = (anon_subr_void_int *)0x0;
  if ((fmInitialized == '\0') || (iVar2 = graph_ok(), iVar2 == 0)) {
    symbol_width0 = 0;
    get_symbol(DisplayCharset,&symbol_width0);
    symbol_width = symbol_width0;
    if (WcOption.use_wide == '\0') {
      symbol_width = 1;
    }
  }
  else {
    symbol_width0 = 1;
    symbol_width = 1;
  }
  cur_title = (Str)0x0;
  n_textarea = 0;
  cur_textarea = (Str)0x0;
  max_textarea = 10;
  textarea_str = (Str *)GC_malloc(0x28);
  n_select = 0;
  max_select = 10;
  select_option = (FormSelectOption *)GC_malloc(0x50);
  cur_select = (Str)0x0;
  form_sp = -1;
  form_max = -1;
  forms_size = 0;
  forms = (FormList **)0x0;
  cur_hseq = 1;
  cur_iseq = 1;
  if (newBuf->image_flag == '\0') {
    if (((activeImage == 0) || (displayImage == 0)) || (autoImage == 0)) {
      image_flag = 1;
    }
    else {
      image_flag = 2;
    }
  }
  else {
    image_flag = (int)newBuf->image_flag;
  }
  if ((newBuf->currentURL).file != (char *)0x0) {
    cur_baseURL = baseURL(newBuf);
  }
  if (w3m_halfload != 0) {
    newBuf->buffername = "---";
    newBuf->document_charset = InnerCharset;
    max_textarea = 0;
    max_select = 0;
    HTMLlineproc3(newBuf,f->stream);
    w3m_halfload = 0;
    return;
  }
  init_henv(&htmlenv1,&obuf,envs,0x14,(TextLineList *)0x0,(int)newBuf->width,0);
  if ((w3m_dump & 0x10U) == 0) {
    htmlenv1.buf = (TextLineList *)newGeneralList();
  }
  else {
    htmlenv1.f = stdout;
  }
  iVar2 = __sigsetjmp(AbortLoading,1);
  if (iVar2 == 0) {
    if ((TrapSignal != '\0') && (prevtrap = mySignal(2,KeyAbort), fmInitialized != '\0')) {
      term_cbreak();
    }
    if (newBuf != (Buffer *)0x0) {
      if ((newBuf->bufferprop & 2U) == 0) {
        if (newBuf->document_charset != 0) {
          doc_charset = newBuf->document_charset;
          charset = doc_charset;
        }
      }
      else {
        charset = InnerCharset;
      }
    }
    if ((content_charset == 0) || (UseContentCharset == '\0')) {
      if ((f->guess_type != (char *)0x0) &&
         (iVar2 = strcasecmp(f->guess_type,"application/xhtml+xml"), iVar2 == 0)) {
        doc_charset = 0x308045;
      }
    }
    else {
      doc_charset = content_charset;
    }
    meta_charset = 0;
    if (f->stream->field_0x14 != '\x04') {
      piVar3 = newEncodedStream(f->stream,f->encoding);
      f->stream = piVar3;
    }
    while ((lineBuf2 = StrmyISgets(f->stream), lineBuf2->length != 0 &&
           (((f->scheme != '\t' || (*lineBuf2->ptr != '.')) ||
            ((Strdelete(lineBuf2,0,1), *lineBuf2->ptr != '\n' &&
             ((*lineBuf2->ptr != '\r' && (*lineBuf2->ptr != '\0'))))))))) {
      if (src != (FILE *)0x0) {
        fwrite(lineBuf2->ptr,1,lineBuf2->length,(FILE *)src);
      }
      uVar1 = lineBuf2->length;
      bVar5 = CARRY4((uint)linelen,uVar1);
      linelen._0_4_ = (uint)linelen + uVar1;
      linelen._4_4_ = linelen._4_4_ + ((int)uVar1 >> 0x1f) + (uint)bVar5;
      if ((w3m_dump & 8U) != 0) {
        pcVar4 = convert_size2(CONCAT44(linelen._4_4_,(uint)linelen),
                               CONCAT44(current_content_length._4_4_,
                                        (undefined4)current_content_length),1);
        printf("W3m-in-progress: %s\n",pcVar4);
      }
      if ((w3m_dump & 4U) == 0) {
        showProgress(&linelen,&trbyte);
        if (meta_charset != 0) {
          if ((content_charset == 0) && (UseContentCharset != '\0')) {
            doc_charset = meta_charset;
            charset = 0x100;
          }
          meta_charset = 0;
        }
        lineBuf2 = convertLine(f,lineBuf2,2,&charset,doc_charset);
        cur_document_charset = (char)charset;
        HTMLlineproc0(lineBuf2->ptr,&htmlenv1,internal);
      }
    }
    if (obuf.status != 0) {
      obuf.status = 7;
      HTMLlineproc0("\n",&htmlenv1,internal);
    }
    obuf.status = 0;
    completeHTMLstream(&htmlenv1,&obuf);
    flushline(&htmlenv1,&obuf,0,2,htmlenv1.limit);
    if (htmlenv1.title != (char *)0x0) {
      newBuf->buffername = htmlenv1.title;
    }
    if ((w3m_dump & 0x10U) != 0) {
      if (TrapSignal != '\0') {
        if (fmInitialized != '\0') {
          term_raw();
        }
        if (prevtrap != (anon_subr_void_int *)0x0) {
          mySignal(2,prevtrap);
        }
      }
      print_internal_information(&htmlenv1);
      return;
    }
    if (w3m_backend != 0) {
      if (TrapSignal != '\0') {
        if (fmInitialized != '\0') {
          term_raw();
        }
        if (prevtrap != (anon_subr_void_int *)0x0) {
          mySignal(2,prevtrap);
        }
      }
      print_internal_information(&htmlenv1);
      backend_halfdump_buf = htmlenv1.buf;
      return;
    }
  }
  else {
    HTMLlineproc0("<br>Transfer Interrupted!<br>",&htmlenv1,1);
  }
  newBuf->trbyte = (int)trbyte + (uint)linelen;
  if (TrapSignal != '\0') {
    if (fmInitialized != '\0') {
      term_raw();
    }
    if (prevtrap != (anon_subr_void_int *)0x0) {
      mySignal(2,prevtrap);
    }
  }
  if ((newBuf->bufferprop & 2U) == 0) {
    newBuf->document_charset = charset;
  }
  newBuf->image_flag = (char)image_flag;
  HTMLlineproc2(newBuf,htmlenv1.buf);
  return;
}



// WARNING: Removing unreachable block (ram,0x0806efc1)

Buffer * loadHTMLString(Str page)

{
  int iVar1;
  Buffer *newBuf_00;
  InputStream stream;
  URLFile f;
  Buffer *newBuf;
  anon_subr_void_int *prevtrap;
  
  prevtrap = (anon_subr_void_int *)0x0;
  if (showLineNum == 0) {
    iVar1 = 1;
  }
  else {
    iVar1 = 6;
  }
  iVar1 = COLS - iVar1;
  if (iVar1 < 0) {
    iVar1 = 0;
  }
  newBuf_00 = newBuffer(iVar1);
  iVar1 = __sigsetjmp(AbortLoading,1);
  if (iVar1 == 0) {
    if ((TrapSignal != '\0') && (prevtrap = mySignal(2,KeyAbort), fmInitialized != '\0')) {
      term_cbreak();
    }
    stream = newStrStream(page);
    init_stream(&f,4,stream);
    newBuf_00->document_charset = InnerCharset;
    loadHTMLstream(&f,newBuf_00,(FILE *)0x0,1);
    newBuf_00->document_charset = 0x100;
    if (TrapSignal != '\0') {
      if (fmInitialized != '\0') {
        term_raw();
      }
      if (prevtrap != (anon_subr_void_int *)0x0) {
        mySignal(2,prevtrap);
      }
    }
    newBuf_00->topLine = newBuf_00->firstLine;
    newBuf_00->lastLine = newBuf_00->currentLine;
    newBuf_00->currentLine = newBuf_00->firstLine;
    newBuf_00->type = "text/html";
    newBuf_00->real_type = newBuf_00->type;
    if (n_textarea != 0) {
      formResetBuffer(newBuf_00,newBuf_00->formitem);
    }
  }
  else {
    if ((TrapSignal != '\0') && (fmInitialized != '\0')) {
      term_raw();
    }
    discardBuffer(newBuf_00);
    newBuf_00 = (Buffer *)0x0;
  }
  return newBuf_00;
}



Str loadGopherDir(URLFile *uf,ParsedURL *pu,wc_ces *charset)

{
  char cVar1;
  wc_ces t_ces;
  wc_ces f_ces;
  wc_ces doc_charset_00;
  Str p_Var2;
  char *pcVar3;
  char *pcVar4;
  int iVar5;
  Str p_Var6;
  Str p_Var7;
  Str p_Var8;
  Str p_Var9;
  wc_ces doc_charset;
  anon_subr_void_int *prevtrap;
  char *q;
  char *p;
  Str port;
  Str host;
  Str file;
  Str name;
  Str lbuf;
  Str tmp;
  
  doc_charset_00 = DocumentCharset;
  prevtrap = (anon_subr_void_int *)0x0;
  p_Var2 = parsedURL2Str(pu);
  pcVar3 = html_quote(p_Var2->ptr);
  pcVar4 = file_unquote(p_Var2->ptr);
  p_Var2 = Strnew_charp(pcVar4);
  p_Var2 = convertLine((URLFile *)0x0,p_Var2,0,charset,doc_charset_00);
  pcVar4 = html_quote(p_Var2->ptr);
  p_Var2 = Strnew_m_charp("<html>\n<head>\n<base href=\"",pcVar3,"\">\n<title>",pcVar4,
                          "</title>\n</head>\n<body>\n<h1>Index of ",pcVar4,"</h1>\n<table>\n",0);
  iVar5 = __sigsetjmp(AbortLoading,1);
  if (iVar5 == 0) {
    if ((TrapSignal != '\0') && (prevtrap = mySignal(2,KeyAbort), fmInitialized != '\0')) {
      term_cbreak();
    }
    while ((p_Var6 = StrISgets(uf->stream), p_Var6->length != 0 &&
           ((*p_Var6->ptr != '.' || ((p_Var6->ptr[1] != '\n' && (p_Var6->ptr[1] != '\r'))))))) {
      p_Var6 = convertLine(uf,p_Var6,2,charset,doc_charset_00);
      pcVar3 = p_Var6->ptr;
      for (q = pcVar3; (*q != '\0' && (*q != '\t')); q = q + 1) {
      }
      p_Var6 = Strnew_charp_n(pcVar3,(int)q - (int)pcVar3);
      if (*q != '\0') {
        pcVar3 = q + 1;
        for (q = pcVar3; (*q != '\0' && (*q != '\t')); q = q + 1) {
        }
        p_Var7 = Strnew_charp_n(pcVar3,(int)q - (int)pcVar3);
        if (*q != '\0') {
          pcVar3 = q + 1;
          for (q = pcVar3; (*q != '\0' && (*q != '\t')); q = q + 1) {
          }
          p_Var8 = Strnew_charp_n(pcVar3,(int)q - (int)pcVar3);
          if (*q != '\0') {
            pcVar3 = q + 1;
            for (q = pcVar3; (((*q != '\0' && (*q != '\t')) && (*q != '\r')) && (*q != '\n'));
                q = q + 1) {
            }
            p_Var9 = Strnew_charp_n(pcVar3,(int)q - (int)pcVar3);
            cVar1 = *p_Var6->ptr;
            if (cVar1 == 'g') {
              p = "[gif]";
            }
            else if (cVar1 < 'h') {
              if (cVar1 == '0') {
                p = "[text file]";
              }
              else if (cVar1 == '1') {
                p = "[directory]";
              }
              else {
LAB_0806f46f:
                p = "[unsupported]";
              }
            }
            else if (cVar1 == 'm') {
              p = "[message]";
            }
            else if (cVar1 == 's') {
              p = "[sound]";
            }
            else {
              if (cVar1 != 'h') goto LAB_0806f46f;
              p = "[HTML]";
            }
            p_Var7 = Strnew_m_charp("gopher://",p_Var8->ptr,&DAT_080ca9fb,p_Var9->ptr,&DAT_080ca9f9,
                                    p_Var7->ptr,0);
            pcVar3 = p_Var7->ptr;
            pcVar4 = html_quote(p_Var6->ptr + 1);
            f_ces = InnerCharset;
            t_ces = *charset;
            p_Var6 = Strnew_charp(pcVar3);
            p_Var6 = wc_Str_conv_strict(p_Var6,f_ces,t_ces);
            pcVar3 = url_quote(p_Var6->ptr);
            pcVar3 = html_quote(pcVar3);
            Strcat_m_charp(p_Var2,"<a href=\"",pcVar3,&DAT_080c9bbb,p,pcVar4,"</a>\n",0);
          }
        }
      }
    }
  }
  if (TrapSignal != '\0') {
    if (fmInitialized != '\0') {
      term_raw();
    }
    if (prevtrap != (anon_subr_void_int *)0x0) {
      mySignal(2,prevtrap);
    }
  }
  Strcat_charp(p_Var2,"</table>\n</body>\n</html>\n");
  return p_Var2;
}



// WARNING: Could not reconcile some variable overlaps

Buffer * loadBuffer(URLFile *uf,Buffer *newBuf)

{
  uint uVar1;
  int iVar2;
  InputStream piVar3;
  char *pcVar4;
  bool bVar5;
  clen_t trbyte;
  clen_t linelen;
  anon_subr_void_int *prevtrap;
  Linecolor *colorBuffer;
  Lineprop *propBuffer;
  Str tmpf;
  int nlines;
  Str lineBuf2;
  wc_ces doc_charset;
  wc_ces charset;
  FILE *src;
  char pre_lbuf;
  
  src = (FILE *)0x0;
  charset = 0x100;
  doc_charset = DocumentCharset;
  pre_lbuf = '\0';
  linelen._0_4_ = 0;
  linelen._4_4_ = 0;
  trbyte._0_4_ = 0;
  trbyte._4_4_ = 0;
  propBuffer = (Lineprop *)0x0;
  colorBuffer = (Linecolor *)0x0;
  prevtrap = (anon_subr_void_int *)0x0;
  if (newBuf == (Buffer *)0x0) {
    if (showLineNum == 0) {
      iVar2 = 1;
    }
    else {
      iVar2 = 6;
    }
    iVar2 = COLS - iVar2;
    if (iVar2 < 0) {
      iVar2 = 0;
    }
    newBuf = newBuffer(iVar2);
  }
  lineBuf2 = Strnew();
  iVar2 = __sigsetjmp(AbortLoading,1);
  if (iVar2 != 0) {
_end:
    if (TrapSignal != '\0') {
      if (fmInitialized != '\0') {
        term_raw();
      }
      if (prevtrap != (anon_subr_void_int *)0x0) {
        mySignal(2,prevtrap);
      }
    }
    newBuf->topLine = newBuf->firstLine;
    newBuf->lastLine = newBuf->currentLine;
    newBuf->currentLine = newBuf->firstLine;
    newBuf->trbyte = (int)trbyte + (uint)linelen;
    newBuf->document_charset = charset;
    if (src != (FILE *)0x0) {
      fclose((FILE *)src);
    }
    return newBuf;
  }
  if ((TrapSignal != '\0') && (prevtrap = mySignal(2,KeyAbort), fmInitialized != '\0')) {
    term_cbreak();
  }
  if ((newBuf->sourcefile == (char *)0x0) &&
     ((uf->scheme != '\x04' || (newBuf->mailcap != (mailcap *)0x0)))) {
    tmpf = tmpfname(1,(char *)0x0);
    src = (FILE *)fopen(tmpf->ptr,"w");
    if ((FILE *)src != (FILE *)0x0) {
      newBuf->sourcefile = tmpf->ptr;
    }
  }
  if (newBuf->document_charset != 0) {
    doc_charset = newBuf->document_charset;
    charset = doc_charset;
  }
  if ((content_charset != 0) && (UseContentCharset != '\0')) {
    doc_charset = content_charset;
  }
  nlines = 0;
  if (uf->stream->field_0x14 != '\x04') {
    piVar3 = newEncodedStream(uf->stream,uf->encoding);
    uf->stream = piVar3;
  }
LAB_0806f99d:
  do {
    lineBuf2 = StrmyISgets(uf->stream);
    if ((lineBuf2->length == 0) ||
       (((uf->scheme == '\t' && (*lineBuf2->ptr == '.')) &&
        ((Strdelete(lineBuf2,0,1), *lineBuf2->ptr == '\n' ||
         ((*lineBuf2->ptr == '\r' || (*lineBuf2->ptr == '\0')))))))) goto _end;
    if (src != (FILE *)0x0) {
      fwrite(lineBuf2->ptr,1,lineBuf2->length,(FILE *)src);
    }
    uVar1 = lineBuf2->length;
    bVar5 = CARRY4((uint)linelen,uVar1);
    linelen._0_4_ = (uint)linelen + uVar1;
    linelen._4_4_ = linelen._4_4_ + ((int)uVar1 >> 0x1f) + (uint)bVar5;
    if ((w3m_dump & 8U) != 0) {
      pcVar4 = convert_size2(CONCAT44(linelen._4_4_,(uint)linelen),
                             CONCAT44(current_content_length._4_4_,
                                      (undefined4)current_content_length),1);
      printf("W3m-in-progress: %s\n",pcVar4);
    }
  } while (((w3m_dump & 4U) != 0) || (showProgress(&linelen,&trbyte), frame_source != 0));
  lineBuf2 = convertLine(uf,lineBuf2,1,&charset,doc_charset);
  if (squeezeBlankLine != 0) {
    if ((*lineBuf2->ptr == '\n') && (pre_lbuf == '\n')) {
      nlines = nlines + 1;
      goto LAB_0806f99d;
    }
    pre_lbuf = *lineBuf2->ptr;
  }
  nlines = nlines + 1;
  Strchop(lineBuf2);
  lineBuf2 = checkType(lineBuf2,&propBuffer,(Linecolor **)0x0);
  if (FoldLine == 0) {
    iVar2 = -1;
  }
  else {
    if (showLineNum == 0) {
      iVar2 = 1;
    }
    else {
      iVar2 = 6;
    }
    iVar2 = COLS - iVar2;
    if (iVar2 < 0) {
      iVar2 = 0;
    }
    iVar2 = iVar2 + 1;
  }
  addnewline(newBuf,lineBuf2->ptr,propBuffer,colorBuffer,lineBuf2->length,iVar2,nlines);
  goto LAB_0806f99d;
}



Buffer * loadImageBuffer(URLFile *uf,Buffer *newBuf)

{
  ImageCache *pIVar1;
  int iVar2;
  InputStream piVar3;
  char *pcVar4;
  Str s;
  Str p_Var5;
  FILE *__stream;
  stat st;
  Image image;
  URLFile f;
  anon_subr_void_int *prevtrap;
  FILE *src;
  Str tmpf;
  Str tmp;
  ImageCache *cache;
  
  prevtrap = (anon_subr_void_int *)0x0;
  loadImage(newBuf,1);
  image.url = uf->url;
  image.ext = uf->ext;
  image.width = -1;
  image.height = -1;
  image.cache = (ImageCache *)0x0;
  pIVar1 = getImage(&image,cur_baseURL,2);
  if (((cur_baseURL->is_nocache != 0) || ((pIVar1->loaded & 1U) == 0)) ||
     (iVar2 = stat(pIVar1->file,(stat *)&st), iVar2 != 0)) {
    if ((TrapSignal != '\0') && (prevtrap = mySignal(2,KeyAbort), fmInitialized != '\0')) {
      term_cbreak();
    }
    if (uf->stream->field_0x14 != '\x04') {
      piVar3 = newEncodedStream(uf->stream,uf->encoding);
      uf->stream = piVar3;
    }
    iVar2 = save2tmp(*uf,pIVar1->file);
    if (iVar2 < 0) {
      iVar2 = ISclose(uf->stream);
      if (iVar2 == 0) {
        uf->stream = (InputStream)0x0;
      }
      if (TrapSignal != '\0') {
        if (fmInitialized != '\0') {
          term_raw();
        }
        if (prevtrap != (anon_subr_void_int *)0x0) {
          mySignal(2,prevtrap);
        }
      }
      return (Buffer *)0x0;
    }
    iVar2 = ISclose(uf->stream);
    if (iVar2 == 0) {
      uf->stream = (InputStream)0x0;
    }
    if (TrapSignal != '\0') {
      if (fmInitialized != '\0') {
        term_raw();
      }
      if (prevtrap != (anon_subr_void_int *)0x0) {
        mySignal(2,prevtrap);
      }
    }
    pIVar1->loaded = '\x01';
    pIVar1->index = 0;
  }
  if (newBuf == (Buffer *)0x0) {
    if (showLineNum == 0) {
      iVar2 = 1;
    }
    else {
      iVar2 = 6;
    }
    iVar2 = COLS - iVar2;
    if (iVar2 < 0) {
      iVar2 = 0;
    }
    newBuf = newBuffer(iVar2);
  }
  pIVar1->loaded = pIVar1->loaded | 4;
  if ((newBuf->sourcefile == (char *)0x0) && (uf->scheme != '\x04')) {
    newBuf->sourcefile = pIVar1->file;
  }
  pcVar4 = html_quote(image.url);
  s = Sprintf("<img src=\"%s\"><br><br>",pcVar4);
  p_Var5 = tmpfname(1,".html");
  __stream = fopen(p_Var5->ptr,"w");
  newBuf->mailcap_source = p_Var5->ptr;
  piVar3 = newStrStream(s);
  init_stream(&f,4,piVar3);
  loadHTMLstream(&f,newBuf,(FILE *)__stream,1);
  if (__stream != (FILE *)0x0) {
    fclose(__stream);
  }
  newBuf->topLine = newBuf->firstLine;
  newBuf->lastLine = newBuf->currentLine;
  newBuf->currentLine = newBuf->firstLine;
  newBuf->image_flag = '\x02';
  return newBuf;
}



Str conv_symbol(Line *l)

{
  byte bVar1;
  int iVar2;
  wc_uint32 wVar3;
  int len;
  char **symbol;
  int w;
  Lineprop *pr;
  char *ep;
  char *p;
  Str tmp;
  char c;
  
  tmp = (Str)0x0;
  p = l->lineBuf;
  ep = p + l->len;
  pr = l->propBuf;
  symbol = (char **)0x0;
  for (; p < ep; p = p + 1) {
    if ((short)*pr < 0) {
      wVar3 = wtf_get_code((wc_uchar *)p);
      c = ((byte)wVar3 & 0x7f) - 0x20;
      bVar1 = WTF_LEN_MAP[(byte)*p];
      if (tmp == (Str)0x0) {
        tmp = Strnew_size(l->len);
        Strcopy_charp_n(tmp,l->lineBuf,(int)p - (int)l->lineBuf);
        if ((*pr & 0x800) == 0) {
          w = 1;
        }
        else {
          w = 2;
        }
        symbol = get_symbol(DisplayCharset,&w);
      }
      Strcat_charp(tmp,symbol[c]);
      p = p + (bVar1 - 1);
      pr = pr + (bVar1 - 1);
    }
    else if (tmp != (Str)0x0) {
      if (tmp->area_size <= tmp->length + 1) {
        Strgrow(tmp);
      }
      iVar2 = tmp->length;
      tmp->ptr[iVar2] = *p;
      tmp->length = iVar2 + 1;
      tmp->ptr[tmp->length] = '\0';
    }
    pr = pr + 1;
  }
  if (tmp == (Str)0x0) {
    tmp = Strnew_charp_n(l->lineBuf,l->len);
  }
  return tmp;
}



void _saveBuffer(Buffer *buf,Line *l,FILE *f,int cont)

{
  int iVar1;
  Str p_Var2;
  bool bVar3;
  wc_ces charset;
  int set_charset;
  int is_html;
  Str tmp;
  
  bVar3 = DisplayCharset == 0;
  charset = DisplayCharset;
  if (DisplayCharset == 0) {
    charset = 0x100;
  }
  iVar1 = is_html_type(buf->type);
  while( true ) {
    for (; l != (Line *)0x0; l = l->next) {
      if (iVar1 == 0) {
        tmp = Strnew_charp_n(l->lineBuf,l->len);
      }
      else {
        tmp = conv_symbol(l);
      }
      p_Var2 = wc_Str_conv(tmp,InnerCharset,charset);
      fwrite(p_Var2->ptr,1,p_Var2->length,(FILE *)f);
      if (((p_Var2->length < 1) || (p_Var2->ptr[p_Var2->length + -1] != '\n')) &&
         ((cont == 0 || ((l->next == (_Line *)0x0 || (l->next->bpos == 0)))))) {
        _IO_putc(10,(_IO_FILE *)f);
      }
    }
    if ((buf->pagerSource == (InputStream)0x0) || ((buf->bufferprop & 0x40U) != 0)) break;
    l = getNextPage(buf,PagerMax);
    if (bVar3) {
      charset = buf->document_charset;
    }
  }
  return;
}



void saveBuffer(Buffer *buf,FILE *f,int cont)

{
  _saveBuffer(buf,buf->firstLine,f,cont);
  return;
}



void saveBufferBody(Buffer *buf,FILE *f,int cont)

{
  Line *l;
  
  for (l = buf->firstLine; (l != (Line *)0x0 && (l->real_linenumber == 0)); l = l->next) {
  }
  _saveBuffer(buf,l,f,cont);
  return;
}



Buffer * loadcmdout(char *cmd,anon_subr_Buffer_ptr_URLFile_ptr_Buffer_ptr *loadproc,
                   Buffer *defaultbuf)

{
  Buffer *pBVar1;
  FILE *f_00;
  InputStream stream;
  URLFile uf;
  Buffer *buf;
  FILE *f;
  
  if ((cmd == (char *)0x0) || (*cmd == '\0')) {
    pBVar1 = (Buffer *)0x0;
  }
  else {
    f_00 = popen(cmd,"r");
    if (f_00 == (FILE *)0x0) {
      pBVar1 = (Buffer *)0x0;
    }
    else {
      stream = newFileStream((FILE *)f_00,pclose);
      init_stream(&uf,0xff,stream);
      pBVar1 = (*loadproc)(&uf,defaultbuf);
      ISclose(uf.stream);
    }
  }
  return pBVar1;
}



Buffer * getshell(char *cmd)

{
  wc_ces t_ces;
  wc_ces f_ces;
  Buffer *pBVar1;
  Str p_Var2;
  Buffer *buf;
  
  pBVar1 = loadcmdout(cmd,loadBuffer,(Buffer *)0x0);
  if (pBVar1 == (Buffer *)0x0) {
    pBVar1 = (Buffer *)0x0;
  }
  else {
    pBVar1->filename = cmd;
    f_ces = SystemCharset;
    t_ces = InnerCharset;
    p_Var2 = Strnew_charp(cmd);
    p_Var2 = wc_Str_conv(p_Var2,f_ces,t_ces);
    p_Var2 = Sprintf("%s %s","*Shellout*",p_Var2->ptr);
    pBVar1->buffername = p_Var2->ptr;
  }
  return pBVar1;
}



Buffer * getpipe(char *cmd)

{
  wc_ces t_ces;
  wc_ces f_ces;
  Buffer *pBVar1;
  FILE *f_00;
  int iVar2;
  InputStream piVar3;
  Str p_Var4;
  Buffer *buf;
  FILE *f;
  
  if ((cmd == (char *)0x0) || (*cmd == '\0')) {
    pBVar1 = (Buffer *)0x0;
  }
  else {
    f_00 = popen(cmd,"r");
    if (f_00 == (FILE *)0x0) {
      pBVar1 = (Buffer *)0x0;
    }
    else {
      if (showLineNum == 0) {
        iVar2 = 1;
      }
      else {
        iVar2 = 6;
      }
      iVar2 = COLS - iVar2;
      if (iVar2 < 0) {
        iVar2 = 0;
      }
      pBVar1 = newBuffer(iVar2);
      piVar3 = newFileStream((FILE *)f_00,pclose);
      pBVar1->pagerSource = piVar3;
      pBVar1->filename = cmd;
      f_ces = SystemCharset;
      t_ces = InnerCharset;
      p_Var4 = Strnew_charp(cmd);
      p_Var4 = wc_Str_conv(p_Var4,f_ces,t_ces);
      p_Var4 = Sprintf("%s %s","*stream*",p_Var4->ptr);
      pBVar1->buffername = p_Var4->ptr;
      pBVar1->bufferprop = pBVar1->bufferprop | 1;
      pBVar1->document_charset = 0x100;
    }
  }
  return pBVar1;
}



Buffer * openPagerBuffer(InputStream stream,Buffer *buf)

{
  wc_ces t_ces;
  wc_ces f_ces;
  int iVar1;
  char *pcVar2;
  Str p_Var3;
  
  if (buf == (Buffer *)0x0) {
    if (showLineNum == 0) {
      iVar1 = 1;
    }
    else {
      iVar1 = 6;
    }
    iVar1 = COLS - iVar1;
    if (iVar1 < 0) {
      iVar1 = 0;
    }
    buf = newBuffer(iVar1);
  }
  buf->pagerSource = stream;
  pcVar2 = getenv("MAN_PN");
  buf->buffername = pcVar2;
  f_ces = SystemCharset;
  t_ces = InnerCharset;
  if (buf->buffername == (char *)0x0) {
    buf->buffername = "*stream*";
  }
  else {
    p_Var3 = Strnew_charp(buf->buffername);
    p_Var3 = wc_Str_conv(p_Var3,f_ces,t_ces);
    buf->buffername = p_Var3->ptr;
  }
  buf->bufferprop = buf->bufferprop | 1;
  if ((content_charset == 0) || (UseContentCharset == '\0')) {
    buf->document_charset = 0x100;
  }
  else {
    buf->document_charset = content_charset;
  }
  buf->currentLine = buf->firstLine;
  return buf;
}



// WARNING: Could not reconcile some variable overlaps

Buffer * openGeneralPagerBuffer(InputStream stream)

{
  int iVar1;
  URLFile uf;
  Buffer *t_buf;
  char *t;
  Buffer *buf;
  
  t = "text/plain";
  t_buf = (Buffer *)0x0;
  init_stream(&uf,0xff,stream);
  content_charset = 0;
  if (SearchHeader == '\0') {
    if (DefaultType != (char *)0x0) {
      t = DefaultType;
      DefaultType = (char *)0x0;
    }
  }
  else {
    if (showLineNum == 0) {
      iVar1 = 1;
    }
    else {
      iVar1 = 6;
    }
    iVar1 = COLS - iVar1;
    if (iVar1 < 0) {
      iVar1 = 0;
    }
    t_buf = newBuffer(iVar1);
    readHeader(&uf,t_buf,1,(ParsedURL *)0x0);
    t = checkContentType(t_buf);
    if (t == (char *)0x0) {
      t = "text/plain";
    }
    if (t_buf != (Buffer *)0x0) {
      t_buf->topLine = t_buf->firstLine;
      t_buf->currentLine = t_buf->lastLine;
    }
    SearchHeader = '\0';
  }
  iVar1 = is_html_type(t);
  if (iVar1 == 0) {
    iVar1 = is_plain_text_type(t);
    if (iVar1 == 0) {
      if ((((activeImage == 0) || (displayImage == 0)) || (useExtImageViewer != 0)) ||
         (((w3m_dump & 0xffffffdfU) != 0 || (iVar1 = strncasecmp(t,"image/",6), iVar1 != 0)))) {
        iVar1 = doExternal((URLFile)CONCAT428(uf.modtime,
                                              CONCAT424(uf.url,CONCAT420(uf.guess_type,
                                                                         CONCAT416(uf.
                                                  content_encoding,
                                                  CONCAT412(uf.compression,
                                                            CONCAT48(uf.ext,CONCAT44(uf.stream,
                                                                                     uf._0_4_)))))))
                           ,"-",t,&buf,t_buf);
        if (iVar1 == 0) {
          if (stream->field_0x14 != '\x04') {
            stream = newEncodedStream(stream,uf.encoding);
          }
          buf = openPagerBuffer(stream,t_buf);
          buf->type = "text/plain";
        }
        else {
          ISclose(uf.stream);
          if (buf == (Buffer *)0x0) {
            return (Buffer *)0x0;
          }
          if (buf == (Buffer *)0x1) {
            return (Buffer *)0x1;
          }
        }
      }
      else {
        cur_baseURL = (ParsedURL *)GC_malloc(0x28);
        parseURL("-",cur_baseURL,(ParsedURL *)0x0);
        buf = loadImageBuffer(&uf,t_buf);
        buf->type = "text/html";
      }
    }
    else {
      if (stream->field_0x14 != '\x04') {
        stream = newEncodedStream(stream,uf.encoding);
      }
      buf = openPagerBuffer(stream,t_buf);
      buf->type = "text/plain";
    }
  }
  else {
    buf = loadHTMLBuffer(&uf,t_buf);
    buf->type = "text/html";
  }
  buf->real_type = t;
  (buf->currentURL).scheme = 4;
  (buf->currentURL).file = "-";
  return buf;
}



// WARNING: Could not reconcile some variable overlaps

Line * getNextPage(Buffer *buf,int plen)

{
  uint uVar1;
  wc_ces t_ces;
  wc_ces f_ces;
  int iVar2;
  Str p_Var3;
  char *pcVar4;
  bool bVar5;
  URLFile uf;
  clen_t trbyte;
  clen_t linelen;
  Line *l;
  anon_subr_void_int *prevtrap;
  Linecolor *colorBuffer;
  Lineprop *propBuffer;
  int squeeze_flag;
  wc_ces doc_charset;
  wc_ces charset;
  Str lineBuf2;
  int nlines;
  int i;
  Line *cur;
  Line *last;
  Line *top;
  wc_uint8 old_auto_detect;
  char pre_lbuf;
  
  top = buf->topLine;
  last = buf->lastLine;
  cur = buf->currentLine;
  nlines = 0;
  linelen._0_4_ = 0;
  linelen._4_4_ = 0;
  trbyte._0_4_ = buf->trbyte;
  trbyte._4_4_ = 0;
  pre_lbuf = '\0';
  doc_charset = DocumentCharset;
  old_auto_detect = WcOption.auto_detect;
  squeeze_flag = 0;
  propBuffer = (Lineprop *)0x0;
  colorBuffer = (Linecolor *)0x0;
  prevtrap = (anon_subr_void_int *)0x0;
  if (buf->pagerSource == (InputStream)0x0) {
    last = (Line *)0x0;
  }
  else {
    if (last != (Line *)0x0) {
      nlines = last->real_linenumber;
      pre_lbuf = *last->lineBuf;
      if (pre_lbuf == '\0') {
        pre_lbuf = '\n';
      }
      buf->currentLine = last;
    }
    charset = buf->document_charset;
    if (buf->document_charset == 0x100) {
      if (UseContentCharset != '\0') {
        content_charset = 0;
        checkContentType(buf);
        if (content_charset != 0) {
          doc_charset = content_charset;
        }
      }
    }
    else {
      doc_charset = buf->document_charset;
    }
    WcOption.auto_detect = buf->auto_detect;
    iVar2 = __sigsetjmp(AbortLoading,1);
    if (iVar2 == 0) {
      if ((TrapSignal != '\0') && (prevtrap = mySignal(2,KeyAbort), fmInitialized != '\0')) {
        term_cbreak();
      }
      init_stream(&uf,0xff,(InputStream)0x0);
      for (i = 0; i < plen; i = i + 1) {
        lineBuf2 = StrmyISgets(buf->pagerSource);
        f_ces = SystemCharset;
        t_ces = InnerCharset;
        if (lineBuf2->length == 0) {
          if (buf->filename == (char *)0x0) {
            pcVar4 = getenv("MAN_PN");
            if (pcVar4 == (char *)0x0) {
              buf->buffername = "*stream(closed)*";
            }
          }
          else {
            p_Var3 = Strnew_charp(buf->filename);
            p_Var3 = wc_Str_conv(p_Var3,f_ces,t_ces);
            p_Var3 = Sprintf("%s %s","*stream(closed)*",p_Var3->ptr);
            buf->buffername = p_Var3->ptr;
          }
          buf->bufferprop = buf->bufferprop | 0x40;
          break;
        }
        uVar1 = lineBuf2->length;
        bVar5 = CARRY4((uint)linelen,uVar1);
        linelen._0_4_ = (uint)linelen + uVar1;
        linelen._4_4_ = linelen._4_4_ + ((int)uVar1 >> 0x1f) + (uint)bVar5;
        showProgress(&linelen,&trbyte);
        lineBuf2 = convertLine(&uf,lineBuf2,1,&charset,doc_charset);
        if (squeezeBlankLine == 0) {
LAB_08070aaf:
          nlines = nlines + 1;
          Strchop(lineBuf2);
          lineBuf2 = checkType(lineBuf2,&propBuffer,&colorBuffer);
          if (FoldLine == 0) {
            iVar2 = -1;
          }
          else {
            if (showLineNum == 0) {
              iVar2 = 1;
            }
            else {
              iVar2 = 6;
            }
            iVar2 = COLS - iVar2;
            if (iVar2 < 0) {
              iVar2 = 0;
            }
            iVar2 = iVar2 + 1;
          }
          addnewline(buf,lineBuf2->ptr,propBuffer,colorBuffer,lineBuf2->length,iVar2,nlines);
          if (top == (Line *)0x0) {
            cur = buf->firstLine;
            top = cur;
          }
          if (PagerMax <= buf->lastLine->real_linenumber - buf->firstLine->real_linenumber) {
            l = buf->firstLine;
            do {
              if (top == l) {
                top = l->next;
              }
              if (cur == l) {
                cur = l->next;
              }
              if (last == l) {
                last = (Line *)0x0;
              }
              l = l->next;
            } while ((l != (Line *)0x0) && (l->bpos != 0));
            buf->firstLine = l;
            buf->firstLine->prev = (_Line *)0x0;
          }
        }
        else {
          squeeze_flag = 0;
          if ((*lineBuf2->ptr != '\n') || (pre_lbuf != '\n')) {
            pre_lbuf = *lineBuf2->ptr;
            goto LAB_08070aaf;
          }
          nlines = nlines + 1;
          i = i + -1;
          squeeze_flag = 1;
        }
      }
    }
    if (TrapSignal != '\0') {
      if (fmInitialized != '\0') {
        term_raw();
      }
      if (prevtrap != (anon_subr_void_int *)0x0) {
        mySignal(2,prevtrap);
      }
    }
    buf->trbyte = (size_t)trbyte + (uint)linelen;
    buf->document_charset = charset;
    WcOption.auto_detect = old_auto_detect;
    buf->topLine = top;
    buf->currentLine = cur;
    if (last == (Line *)0x0) {
      last = buf->firstLine;
    }
    else if ((last != (Line *)0x0) && ((last->next != (_Line *)0x0 || (squeeze_flag == 0)))) {
      last = last->next;
    }
  }
  return last;
}



// WARNING: Could not reconcile some variable overlaps

int save2tmp(URLFile uf,char *tmpf)

{
  uint uVar1;
  int iVar2;
  bool bVar3;
  clen_t trbyte;
  clen_t linelen;
  Str buf;
  anon_subr_void_int *prevtrap;
  int check;
  FILE *ff;
  char c;
  
  linelen._0_4_ = 0;
  linelen._4_4_ = 0;
  trbyte._0_4_ = 0;
  trbyte._4_4_ = 0;
  prevtrap = (anon_subr_void_int *)0x0;
  ff = (FILE *)fopen(tmpf,"wb");
  if ((FILE *)ff == (FILE *)0x0) {
    iVar2 = -1;
  }
  else {
    bcopy(AbortLoading,save2tmp::env_bak,0x9c);
    iVar2 = __sigsetjmp(AbortLoading,1);
    if (iVar2 == 0) {
      if ((TrapSignal != '\0') && (prevtrap = mySignal(2,KeyAbort), fmInitialized != '\0')) {
        term_cbreak();
      }
      check = 0;
      if (uf.scheme == '\t') {
        while( true ) {
          iVar2 = ISgetc(uf.stream);
          c = (char)iVar2;
          if ((uf.stream)->field_0x15 != '\0') break;
          if (c == '\n') {
            if (check == 0) {
              check = 1;
            }
            else if (check == 3) break;
          }
          else if ((c == '.') && (check == 1)) {
            check = 2;
          }
          else if ((c == '\r') && (check == 2)) {
            check = 3;
          }
          else {
            check = 0;
          }
          _IO_putc((int)c,(_IO_FILE *)ff);
          bVar3 = 0xfffffffe < (uint)linelen;
          linelen._0_4_ = (uint)linelen + 1;
          linelen._4_4_ = linelen._4_4_ + (uint)bVar3;
          showProgress(&linelen,&trbyte);
        }
      }
      else {
        buf = Strnew_size(0x600);
        while (iVar2 = ISread(uf.stream,buf,0x600), iVar2 != 0) {
          fwrite(buf->ptr,1,buf->length,(FILE *)ff);
          uVar1 = buf->length;
          bVar3 = CARRY4((uint)linelen,uVar1);
          linelen._0_4_ = (uint)linelen + uVar1;
          linelen._4_4_ = linelen._4_4_ + ((int)uVar1 >> 0x1f) + (uint)bVar3;
          showProgress(&linelen,&trbyte);
        }
      }
    }
    bcopy(save2tmp::env_bak,AbortLoading,0x9c);
    if (TrapSignal != '\0') {
      if (fmInitialized != '\0') {
        term_raw();
      }
      if (prevtrap != (anon_subr_void_int *)0x0) {
        mySignal(2,prevtrap);
      }
    }
    fclose((FILE *)ff);
    current_content_length._0_4_ = 0;
    current_content_length._4_4_ = 0;
    iVar2 = 0;
  }
  return iVar2;
}



int doExternal(URLFile uf,char *path,char *type,Buffer **bufp,Buffer *defaultbuf)

{
  wc_ces wVar1;
  wc_ces wVar2;
  int iVar3;
  Str p_Var4;
  char *pcVar5;
  __pid_t _Var6;
  Str tmp;
  char *ext;
  char *src;
  char *header;
  Buffer *buf;
  int mc_stat;
  mailcap *mcap;
  Str command;
  Str tmpf;
  
  src = (char *)0x0;
  ext = uf.ext;
  mcap = searchExtViewer(type);
  if (mcap == (mailcap *)0x0) {
    iVar3 = 0;
  }
  else {
    if ((mcap->nametemplate != (char *)0x0) &&
       (tmpf = unquote_mailcap(mcap->nametemplate,(char *)0x0,"",(char *)0x0,(int *)0x0),
       *tmpf->ptr == '.')) {
      ext = tmpf->ptr;
    }
    if ((ext == (char *)0x0) || (*ext == '\0')) {
      ext = (char *)0x0;
    }
    tmpf = tmpfname(0,ext);
    if ((uf.stream)->field_0x14 != '\x04') {
      uf.stream = newEncodedStream(uf.stream,uf.encoding);
    }
    header = checkHeader(defaultbuf,"Content-Type:");
    wVar2 = SystemCharset;
    wVar1 = InnerCharset;
    if (header != (char *)0x0) {
      p_Var4 = Strnew_charp(header);
      p_Var4 = wc_Str_conv_strict(p_Var4,wVar1,wVar2);
      header = p_Var4->ptr;
    }
    command = unquote_mailcap(mcap->viewer,type,tmpf->ptr,header,&mc_stat);
    if ((mc_stat & 1U) == 0) {
      pcVar5 = shell_quote(tmpf->ptr);
      command = Sprintf("(%s) < %s",command->ptr,pcVar5);
    }
    if ((((mcap->flags & 6U) == 0) && ((mcap->flags & 1U) == 0)) && (BackgroundExtViewer != 0)) {
      flush_tty();
      _Var6 = fork();
      if (_Var6 == 0) {
        iVar3 = ISfileno(uf.stream);
        setup_child(0,0,iVar3);
        iVar3 = save2tmp((URLFile)CONCAT428(uf.modtime,
                                            CONCAT424(uf.url,CONCAT420(uf.guess_type,
                                                                       CONCAT416(uf.content_encoding
                                                                                 ,CONCAT412(uf.
                                                  compression,
                                                  CONCAT48(uf.ext,CONCAT44(uf.stream,uf._0_4_)))))))
                         ,tmpf->ptr);
        if (iVar3 < 0) {
                    // WARNING: Subroutine does not return
          exit(1);
        }
        ISclose(uf.stream);
        myExec(command->ptr);
      }
      *bufp = (Buffer *)0x1;
      iVar3 = 1;
    }
    else {
      iVar3 = save2tmp((URLFile)CONCAT428(uf.modtime,
                                          CONCAT424(uf.url,CONCAT420(uf.guess_type,
                                                                     CONCAT416(uf.content_encoding,
                                                                               CONCAT412(uf.
                                                  compression,
                                                  CONCAT48(uf.ext,CONCAT44(uf.stream,uf._0_4_)))))))
                       ,tmpf->ptr);
      if (iVar3 < 0) {
        *bufp = (Buffer *)0x0;
        iVar3 = 1;
      }
      else {
        if ((mcap->flags & 6U) != 0) {
          if (defaultbuf == (Buffer *)0x0) {
            if (showLineNum == 0) {
              iVar3 = 1;
            }
            else {
              iVar3 = 6;
            }
            iVar3 = COLS - iVar3;
            if (iVar3 < 0) {
              iVar3 = 0;
            }
            defaultbuf = newBuffer(iVar3);
          }
          if (defaultbuf->sourcefile == (char *)0x0) {
            src = tmpf->ptr;
          }
          else {
            src = defaultbuf->sourcefile;
          }
          defaultbuf->sourcefile = (char *)0x0;
          defaultbuf->mailcap = mcap;
        }
        if ((mcap->flags & 4U) == 0) {
          if ((mcap->flags & 2U) == 0) {
            if (((mcap->flags & 1U) == 0) && (BackgroundExtViewer != 0)) {
              mySystem(command->ptr,1);
            }
            else {
              fmTerm();
              mySystem(command->ptr,0);
              fmInit();
              if ((CurrentTab != (TabBuffer *)0x0) && (CurrentTab->currentBuffer != (Buffer *)0x0))
              {
                displayBuffer(CurrentTab->currentBuffer,1);
              }
            }
            buf = (Buffer *)0x1;
          }
          else {
            buf = loadcmdout(command->ptr,loadBuffer,defaultbuf);
            if ((buf != (Buffer *)0x0) && (buf != (Buffer *)0x1)) {
              buf->type = "text/plain";
              buf->mailcap_source = buf->sourcefile;
              buf->sourcefile = src;
            }
          }
        }
        else {
          buf = loadcmdout(command->ptr,loadHTMLBuffer,defaultbuf);
          if ((buf != (Buffer *)0x0) && (buf != (Buffer *)0x1)) {
            buf->type = "text/html";
            buf->mailcap_source = buf->sourcefile;
            buf->sourcefile = src;
          }
        }
        if ((buf != (Buffer *)0x0) && (buf != (Buffer *)0x1)) {
          buf->filename = path;
          wVar2 = SystemCharset;
          wVar1 = InnerCharset;
          if ((buf->buffername == (char *)0x0) || (*buf->buffername == '\0')) {
            pcVar5 = lastFileName(path);
            p_Var4 = Strnew_charp(pcVar5);
            p_Var4 = wc_Str_conv(p_Var4,wVar2,wVar1);
            buf->buffername = p_Var4->ptr;
          }
          buf->edit = mcap->edit;
          buf->mailcap = mcap;
        }
        *bufp = buf;
        iVar3 = 1;
      }
    }
  }
  return iVar3;
}



// WARNING: Could not reconcile some variable overlaps

int _MoveFile(char *path1,char *path2)

{
  uint uVar1;
  int iVar2;
  bool bVar3;
  clen_t trbyte;
  clen_t linelen;
  Str buf;
  int is_pipe;
  FILE *f2;
  InputStream f1;
  
  linelen._0_4_ = 0;
  linelen._4_4_ = 0;
  trbyte._0_4_ = 0;
  trbyte._4_4_ = 0;
  iVar2 = open(path1,0);
  f1 = newInputStream(iVar2);
  if (f1 == (InputStream)0x0) {
    iVar2 = -1;
  }
  else {
    if ((*path2 == '|') && (PermitSaveToPipe != '\0')) {
      is_pipe = 1;
      f2 = (FILE *)popen(path2 + 1,"w");
    }
    else {
      is_pipe = 0;
      f2 = (FILE *)fopen(path2,"wb");
    }
    if (f2 == (FILE *)0x0) {
      ISclose(f1);
      iVar2 = -1;
    }
    else {
      current_content_length._0_4_ = 0;
      current_content_length._4_4_ = 0;
      buf = Strnew_size(0x600);
      while( true ) {
        iVar2 = ISread(f1,buf,0x600);
        if (iVar2 == 0) break;
        fwrite(buf->ptr,1,buf->length,(FILE *)f2);
        uVar1 = buf->length;
        bVar3 = CARRY4((uint)linelen,uVar1);
        linelen._0_4_ = (uint)linelen + uVar1;
        linelen._4_4_ = linelen._4_4_ + ((int)uVar1 >> 0x1f) + (uint)bVar3;
        showProgress(&linelen,&trbyte);
      }
      ISclose(f1);
      if (is_pipe == 0) {
        fclose((FILE *)f2);
      }
      else {
        pclose((FILE *)f2);
      }
      iVar2 = 0;
    }
  }
  return iVar2;
}



// WARNING: Could not reconcile some variable overlaps

int _doFileCopy(char *tmpf,char *defstr,int download)

{
  char *pcVar1;
  bool bVar2;
  wc_ces wVar3;
  wc_ces wVar4;
  Str p_Var5;
  int iVar6;
  __pid_t pid_00;
  size_t sVar7;
  stat st;
  clen_t size;
  int is_pipe;
  char *lock;
  pid_t pid;
  char *q;
  char *p;
  Str filen;
  Str msg;
  
  q = (char *)0x0;
  size._0_4_ = 0;
  size._4_4_ = 0;
  bVar2 = false;
  if (fmInitialized == '\0') {
    q = searchKeyData();
    if ((q == (char *)0x0) || (*q == '\0')) {
      printf("(Download)Save file to: ");
      fflush(stdout);
      p_Var5 = Strfgets(stdin);
      if (p_Var5->length == 0) {
        return -1;
      }
      q = p_Var5->ptr;
    }
    sVar7 = strlen(q);
    p = q + (sVar7 - 1);
    while ((MYCTYPE_MAP[(byte)*p] & 2) != 0) {
      p = p + -1;
    }
    p[1] = '\0';
    if (*q == '\0') {
      return -1;
    }
    p = q;
    if ((*q == '|') && (PermitSaveToPipe != '\0')) {
      bVar2 = true;
    }
    else {
      p = expandPath(q);
      iVar6 = checkOverWrite(p);
      if (iVar6 < 0) {
        return -1;
      }
    }
    iVar6 = checkCopyFile(tmpf,p);
    if (iVar6 < 0) {
      printf("Can\'t copy. %s and %s are identical.",tmpf,p);
      return -1;
    }
    iVar6 = _MoveFile(tmpf,p);
    if (iVar6 < 0) {
      printf("Can\'t save to %s\n",p);
      return -1;
    }
    if (((PreserveTimestamp != '\0') && (!bVar2)) && (iVar6 = stat(tmpf,(stat *)&st), iVar6 == 0)) {
      setModtime(p,st.st_mtim.tv_sec);
    }
  }
  else {
    p = searchKeyData();
    if ((p == (char *)0x0) || (*p == '\0')) {
      q = inputLineHistSearch("(Download)Save file to: ",defstr,0x80,SaveHist,
                              (anon_subr_int_int_Str_Lineprop_ptr *)0x0);
      wVar4 = SystemCharset;
      wVar3 = InnerCharset;
      if ((q == (char *)0x0) || (*q == '\0')) {
        return 0;
      }
      p_Var5 = Strnew_charp(q);
      p_Var5 = wc_Str_conv_strict(p_Var5,wVar3,wVar4);
      p = p_Var5->ptr;
    }
    if ((*p == '|') && (PermitSaveToPipe != '\0')) {
      bVar2 = true;
    }
    else {
      if (q != (char *)0x0) {
        p_Var5 = Strnew_charp(q);
        unescape_spaces(p_Var5);
        wVar4 = SystemCharset;
        wVar3 = InnerCharset;
        p_Var5 = Strnew_charp(q);
        p_Var5 = wc_Str_conv_strict(p_Var5,wVar3,wVar4);
        p = p_Var5->ptr;
      }
      p = expandPath(p);
      iVar6 = checkOverWrite(p);
      if (iVar6 < 0) {
        return -1;
      }
    }
    iVar6 = checkCopyFile(tmpf,p);
    wVar4 = SystemCharset;
    wVar3 = InnerCharset;
    if (iVar6 < 0) {
      p_Var5 = Strnew_charp(p);
      p_Var5 = wc_Str_conv(p_Var5,wVar4,wVar3);
      wVar4 = SystemCharset;
      wVar3 = InnerCharset;
      pcVar1 = p_Var5->ptr;
      p_Var5 = Strnew_charp(tmpf);
      p_Var5 = wc_Str_conv(p_Var5,wVar4,wVar3);
      p_Var5 = Sprintf("Can\'t copy. %s and %s are identical.",p_Var5->ptr,pcVar1);
      disp_err_message(p_Var5->ptr,0);
      return -1;
    }
    if (download == 0) {
      iVar6 = _MoveFile(tmpf,p);
      wVar4 = SystemCharset;
      wVar3 = InnerCharset;
      if (iVar6 < 0) {
        p_Var5 = Strnew_charp(p);
        p_Var5 = wc_Str_conv(p_Var5,wVar4,wVar3);
        p_Var5 = Sprintf("Can\'t save to %s",p_Var5->ptr);
        disp_err_message(p_Var5->ptr,0);
      }
      return -1;
    }
    p_Var5 = tmpfname(0,".lock");
    pcVar1 = p_Var5->ptr;
    symlink(p,pcVar1);
    flush_tty();
    pid_00 = fork();
    if (pid_00 == 0) {
      setup_child(0,0,-1);
      iVar6 = _MoveFile(tmpf,p);
      if ((((iVar6 == 0) && (PreserveTimestamp != '\0')) && (!bVar2)) &&
         (iVar6 = stat(tmpf,(stat *)&st), iVar6 == 0)) {
        setModtime(p,st.st_mtim.tv_sec);
      }
      unlink(pcVar1);
                    // WARNING: Subroutine does not return
      exit(0);
    }
    iVar6 = stat(tmpf,(stat *)&st);
    wVar4 = SystemCharset;
    wVar3 = InnerCharset;
    if (iVar6 == 0) {
      size._4_4_ = st.st_size >> 0x1f;
      size._0_4_ = st.st_size;
    }
    p_Var5 = Strnew_charp(tmpf);
    p_Var5 = wc_Str_conv(p_Var5,wVar4,wVar3);
    addDownloadList(pid_00,p_Var5->ptr,p,pcVar1,CONCAT44(size._4_4_,(__off_t)size));
  }
  return 0;
}



int doFileMove(char *tmpf,char *defstr)

{
  int iVar1;
  int ret;
  
  iVar1 = _doFileCopy(tmpf,defstr,0);
  unlink(tmpf);
  return iVar1;
}



int doFileSave(URLFile uf,char *defstr)

{
  wc_ces wVar1;
  wc_ces wVar2;
  Str p_Var3;
  int iVar4;
  size_t sVar5;
  char *tmpf;
  char *lock;
  pid_t pid;
  char *q;
  char *p;
  Str filen;
  Str msg;
  
  tmpf = (char *)0x0;
  if (fmInitialized == '\0') {
    q = searchKeyData();
    if ((q == (char *)0x0) || (*q == '\0')) {
      printf("(Download)Save file to: ");
      fflush(stdout);
      filen = Strfgets(stdin);
      if (filen->length == 0) {
        return -1;
      }
      q = filen->ptr;
    }
    sVar5 = strlen(q);
    p = q + (sVar5 - 1);
    while ((MYCTYPE_MAP[(byte)*p] & 2) != 0) {
      p = p + -1;
    }
    p[1] = '\0';
    if (*q == '\0') {
      return -1;
    }
    p = expandPath(q);
    iVar4 = checkOverWrite(p);
    if (iVar4 < 0) {
      return -1;
    }
    iVar4 = checkSaveFile(uf.stream,p);
    if (iVar4 < 0) {
      printf("Can\'t save. Load file and %s are identical.",p);
      return -1;
    }
    if (((uf.content_encoding != 0) && (AutoUncompress != '\0')) &&
       (uncompress_stream(&uf,&tmpf), tmpf != (char *)0x0)) {
      unlink(tmpf);
    }
    iVar4 = save2tmp((URLFile)CONCAT428(uf.modtime,
                                        CONCAT424(uf.url,CONCAT420(uf.guess_type,
                                                                   CONCAT416(uf.content_encoding,
                                                                             CONCAT412(uf.
                                                  compression,
                                                  CONCAT48(uf.ext,CONCAT44(uf.stream,uf._0_4_)))))))
                     ,p);
    if (iVar4 < 0) {
      printf("Can\'t save to %s\n",p);
      return -1;
    }
    if ((PreserveTimestamp != '\0') && (uf.modtime != -1)) {
      setModtime(p,uf.modtime);
    }
  }
  else {
    p = searchKeyData();
    if ((p == (char *)0x0) || (*p == '\0')) {
      p = inputLineHistSearch("(Download)Save file to: ",defstr,0x20,SaveHist,
                              (anon_subr_int_int_Str_Lineprop_ptr *)0x0);
      wVar2 = SystemCharset;
      wVar1 = InnerCharset;
      if ((p == (char *)0x0) || (*p == '\0')) {
        return -1;
      }
      p_Var3 = Strnew_charp(p);
      p_Var3 = wc_Str_conv_strict(p_Var3,wVar1,wVar2);
      p = p_Var3->ptr;
    }
    iVar4 = checkOverWrite(p);
    if (iVar4 < 0) {
      return -1;
    }
    iVar4 = checkSaveFile(uf.stream,p);
    wVar2 = SystemCharset;
    wVar1 = InnerCharset;
    if (iVar4 < 0) {
      p_Var3 = Strnew_charp(p);
      p_Var3 = wc_Str_conv(p_Var3,wVar2,wVar1);
      msg = Sprintf("Can\'t save. Load file and %s are identical.",p_Var3->ptr);
      disp_err_message(msg->ptr,0);
      return -1;
    }
    p_Var3 = tmpfname(0,".lock");
    lock = p_Var3->ptr;
    symlink(p,lock);
    flush_tty();
    pid = fork();
    if (pid == 0) {
      if (((uf.content_encoding != 0) && (AutoUncompress != '\0')) &&
         (uncompress_stream(&uf,&tmpf), tmpf != (char *)0x0)) {
        unlink(tmpf);
      }
      iVar4 = ISfileno(uf.stream);
      setup_child(0,0,iVar4);
      iVar4 = save2tmp((URLFile)CONCAT428(uf.modtime,
                                          CONCAT424(uf.url,CONCAT420(uf.guess_type,
                                                                     CONCAT416(uf.content_encoding,
                                                                               CONCAT412(uf.
                                                  compression,
                                                  CONCAT48(uf.ext,CONCAT44(uf.stream,uf._0_4_)))))))
                       ,p);
      if (((iVar4 == 0) && (PreserveTimestamp != '\0')) && (uf.modtime != -1)) {
        setModtime(p,uf.modtime);
      }
      iVar4 = ISclose(uf.stream);
      if (iVar4 == 0) {
        uf.stream = (InputStream)0x0;
      }
      unlink(lock);
                    // WARNING: Subroutine does not return
      exit(0);
    }
    addDownloadList(pid,uf.url,p,lock,
                    CONCAT44(current_content_length._4_4_,(undefined4)current_content_length));
  }
  return 0;
}



int checkCopyFile(char *path1,char *path2)

{
  int iVar1;
  stat st2;
  stat st1;
  
  if ((((*path2 != '|') || (PermitSaveToPipe == '\0')) &&
      (iVar1 = stat(path1,(stat *)&st1), iVar1 == 0)) &&
     ((iVar1 = stat(path2,(stat *)&st2), iVar1 == 0 && (st1.st_ino == st2.st_ino)))) {
    return -1;
  }
  return 0;
}



int checkSaveFile(InputStream stream,char *path2)

{
  int iVar1;
  stat st2;
  stat st1;
  int des;
  
  iVar1 = ISfileno(stream);
  if (((-1 < iVar1) &&
      (((*path2 != '|' || (PermitSaveToPipe == '\0')) &&
       (iVar1 = fstat(iVar1,(stat *)&st1), iVar1 == 0)))) &&
     ((iVar1 = stat(path2,(stat *)&st2), iVar1 == 0 && (st1.st_ino == st2.st_ino)))) {
    return -1;
  }
  return 0;
}



int checkOverWrite(char *path)

{
  byte bVar1;
  int iVar2;
  byte *pbVar3;
  stat st;
  char *ans;
  
  iVar2 = stat(path,(stat *)&st);
  if (iVar2 < 0) {
    iVar2 = 0;
  }
  else {
    pbVar3 = (byte *)inputAnswer("File exists. Overwrite? (y/n)");
    if (pbVar3 != (byte *)0x0) {
      if ((MYCTYPE_MAP[*pbVar3] & 4) == 0) {
        bVar1 = *pbVar3;
      }
      else {
        bVar1 = *pbVar3 | 0x20;
      }
      if (bVar1 == 0x79) {
        return 0;
      }
    }
    iVar2 = -1;
  }
  return iVar2;
}



char * inputAnswer(char *prompt)

{
  char *pcVar1;
  Str p_Var2;
  char *ans;
  
  if (QuietMessage == '\0') {
    if (fmInitialized == '\0') {
      printf("%s",prompt);
      fflush(stdout);
      p_Var2 = Strfgets(stdin);
      pcVar1 = p_Var2->ptr;
    }
    else {
      term_raw();
      pcVar1 = inputLineHistSearch(prompt,"",0x200,(Hist *)0x0,
                                   (anon_subr_int_int_Str_Lineprop_ptr *)0x0);
    }
  }
  else {
    pcVar1 = "n";
  }
  return pcVar1;
}



void uncompress_stream(URLFile *uf,char **src)

{
  InputStream piVar1;
  Str p_Var2;
  int iVar3;
  FILE *f;
  Str buf;
  FILE *f2;
  pid_t pid2;
  compression_decoder *d;
  char *ext;
  char *tmpf;
  char *expand_name;
  char *expand_cmd;
  FILE *f1;
  pid_t pid1;
  
  expand_cmd = "gunzip";
  expand_name = "gunzip";
  tmpf = (char *)0x0;
  ext = (char *)0x0;
  if (uf->stream->field_0x14 != '\x04') {
    piVar1 = newEncodedStream(uf->stream,uf->encoding);
    uf->stream = piVar1;
    uf->encoding = '\0';
  }
  d = compression_decoders;
  do {
    if (d->type == 0) {
LAB_080722d7:
      uf->compression = 0;
      if ((uf->scheme != '\x04') && (image_source == (char *)0x0)) {
        p_Var2 = tmpfname(0,ext);
        tmpf = p_Var2->ptr;
      }
      pid1 = open_pipe_rw(&f1,(FILE **)0x0);
      if (pid1 < 0) {
        iVar3 = ISclose(uf->stream);
        if (iVar3 == 0) {
          uf->stream = (InputStream)0x0;
        }
      }
      else {
        if (pid1 == 0) {
          f2 = stdin;
          pid2 = open_pipe_rw(&f2,(FILE **)0x0);
          if (pid2 < 0) {
            iVar3 = ISclose(uf->stream);
            if (iVar3 == 0) {
              uf->stream = (InputStream)0x0;
            }
                    // WARNING: Subroutine does not return
            exit(1);
          }
          if (pid2 == 0) {
            p_Var2 = Strnew_size(0x600);
            f = (FILE *)0x0;
            iVar3 = ISfileno(uf->stream);
            setup_child(1,2,iVar3);
            if (tmpf != (char *)0x0) {
              f = (FILE *)fopen(tmpf,"wb");
            }
            while( true ) {
              iVar3 = ISread(uf->stream,p_Var2,0x600);
              if (iVar3 == 0) break;
              fwrite(p_Var2->ptr,1,p_Var2->length,stdout);
              if (f != (FILE *)0x0) {
                fwrite(p_Var2->ptr,1,p_Var2->length,(FILE *)f);
              }
            }
            iVar3 = ISclose(uf->stream);
            if (iVar3 == 0) {
              uf->stream = (InputStream)0x0;
            }
            if (f != (FILE *)0x0) {
              fclose((FILE *)f);
            }
                    // WARNING: Subroutine does not return
            exit(0);
          }
          dup2(1,2);
          setup_child(1,-1,-1);
          execlp(expand_cmd,expand_name,0);
                    // WARNING: Subroutine does not return
          exit(1);
        }
        if (tmpf != (char *)0x0) {
          if (src == (char **)0x0) {
            uf->scheme = '\x04';
          }
          else {
            *src = tmpf;
          }
        }
        UFhalfclose(uf);
        piVar1 = newFileStream(f1,fclose);
        uf->stream = piVar1;
      }
      return;
    }
    if (uf->compression == d->type) {
      if (d->auxbin_p == 0) {
        expand_cmd = d->cmd;
      }
      else {
        expand_cmd = auxbinFile(d->cmd);
      }
      expand_name = d->name;
      ext = d->ext;
      goto LAB_080722d7;
    }
    d = d + 1;
  } while( true );
}



FILE * lessopen_stream(char *path)

{
  char *pcVar1;
  char *pcVar2;
  Str p_Var3;
  int __c;
  int c;
  Str tmpf;
  FILE *fp;
  char *lessopen;
  
  pcVar1 = getenv("LESSOPEN");
  if (pcVar1 == (char *)0x0) {
    fp = (FILE *)0x0;
  }
  else if (*pcVar1 == '\0') {
    fp = (FILE *)0x0;
  }
  else if (*pcVar1 == '|') {
    pcVar2 = shell_quote(path);
    p_Var3 = Sprintf(pcVar1 + 1,pcVar2);
    fp = (FILE *)popen(p_Var3->ptr,"r");
    if ((FILE *)fp == (FILE *)0x0) {
      fp = (FILE *)0x0;
    }
    else {
      __c = _IO_getc((_IO_FILE *)fp);
      if (__c == -1) {
        fclose((FILE *)fp);
        fp = (FILE *)0x0;
      }
      else {
        ungetc(__c,(FILE *)fp);
      }
    }
  }
  else {
    fp = (FILE *)0x0;
  }
  return fp;
}



char * guess_filename(char *file)

{
  char *pcVar1;
  char *s;
  char *p;
  
  p = (char *)0x0;
  if (file != (char *)0x0) {
    p = mybasename(file);
  }
  pcVar1 = p;
  if ((p == (char *)0x0) || (*p == '\0')) {
    pcVar1 = "index.html";
  }
  else {
    if (*p == '#') {
      p = p + 1;
    }
    for (; *p != '\0'; p = p + 1) {
      if (((*p == '#') && (p[1] != '\0')) || (*p == '?')) {
        *p = '\0';
        return pcVar1;
      }
    }
  }
  return pcVar1;
}



char * guess_save_name(Buffer *buf,char *path)

{
  char *pcVar1;
  char *pcVar2;
  int iVar3;
  char *q;
  char *p;
  Str name;
  
  if ((buf != (Buffer *)0x0) && (buf->document_header != (TextList *)0x0)) {
    name = (Str)0x0;
    pcVar1 = checkHeader(buf,"Content-Disposition:");
    if (pcVar1 != (char *)0x0) {
      pcVar2 = strcasestr(pcVar1,"filename");
      if ((pcVar2 != (char *)0x0) &&
         (((pcVar2 == pcVar1 || ((MYCTYPE_MAP[(byte)pcVar2[-1]] & 2) != 0)) || (pcVar2[-1] == ';')))
         ) {
        iVar3 = matchattr(pcVar2,"filename",8,&name);
        if (iVar3 != 0) {
          path = name->ptr;
          goto LAB_08072834;
        }
      }
    }
    pcVar1 = checkHeader(buf,"Content-Type:");
    if (pcVar1 != (char *)0x0) {
      pcVar2 = strcasestr(pcVar1,"name");
      if ((pcVar2 != (char *)0x0) &&
         (((pcVar2 == pcVar1 || ((MYCTYPE_MAP[(byte)pcVar2[-1]] & 2) != 0)) || (pcVar2[-1] == ';')))
         ) {
        iVar3 = matchattr(pcVar2,"name",4,&name);
        if (iVar3 != 0) {
          path = name->ptr;
        }
      }
    }
  }
LAB_08072834:
  pcVar1 = guess_filename(path);
  return pcVar1;
}



Buffer * newBuffer(int width)

{
  Buffer *__s;
  int *piVar1;
  Buffer *n;
  
  __s = (Buffer *)GC_malloc(0x104);
  if (__s == (Buffer *)0x0) {
    __s = (Buffer *)0x0;
  }
  else {
    bzero(__s,0x104);
    __s->width = (short)width;
    __s->COLS = (short)COLS;
    __s->LINES = (short)LINES + -1;
    (__s->currentURL).scheme = 0xff;
    __s->baseURL = (ParsedURL *)0x0;
    __s->baseTarget = (char *)0x0;
    __s->buffername = "";
    __s->bufferprop = 0;
    piVar1 = (int *)GC_malloc(4);
    __s->clone = piVar1;
    *__s->clone = 1;
    __s->trbyte = 0;
    __s->auto_detect = WcOption.auto_detect;
  }
  return __s;
}



Buffer * nullBuffer(void)

{
  Buffer *pBVar1;
  Buffer *b;
  
  pBVar1 = newBuffer(COLS);
  pBVar1->buffername = "*Null*";
  return pBVar1;
}



void clearBuffer(Buffer *buf)

{
  buf->lastLine = (Line *)0x0;
  buf->currentLine = buf->lastLine;
  buf->topLine = buf->currentLine;
  buf->firstLine = buf->topLine;
  buf->allLine = 0;
  return;
}



void discardBuffer(Buffer *buf)

{
  int *piVar1;
  int iVar2;
  frameset *pfVar3;
  Buffer *b;
  int i;
  
  deleteImage(buf);
  clearBuffer(buf);
  for (i = 0; i < 5; i = i + 1) {
    if (buf->linkBuffer[i] != (_Buffer *)0x0) {
      buf->linkBuffer[i]->linkBuffer[REV_LB[i]] = (_Buffer *)0x0;
    }
  }
  if (buf->savecache != (char *)0x0) {
    unlink(buf->savecache);
  }
  piVar1 = buf->clone;
  *piVar1 = *piVar1 + -1;
  if (*piVar1 == 0) {
    if (buf->pagerSource != (InputStream)0x0) {
      ISclose(buf->pagerSource);
    }
    if (((buf->sourcefile != (char *)0x0) &&
        ((buf->real_type == (char *)0x0 ||
         (iVar2 = strncasecmp(buf->real_type,"image/",6), iVar2 != 0)))) &&
       ((buf->real_scheme != 4 || ((buf->bufferprop & 2U) != 0)))) {
      unlink(buf->sourcefile);
    }
    if (buf->header_source != (char *)0x0) {
      unlink(buf->header_source);
    }
    if (buf->mailcap_source != (char *)0x0) {
      unlink(buf->mailcap_source);
    }
    while (buf->frameset != (frameset *)0x0) {
      deleteFrameSet(buf->frameset);
      pfVar3 = popFrameTree(&buf->frameQ);
      buf->frameset = pfVar3;
    }
  }
  return;
}



Buffer * namedBuffer(Buffer *first,char *name)

{
  int iVar1;
  Buffer *buf;
  
  iVar1 = strcmp(first->buffername,name);
  if (iVar1 != 0) {
    for (buf = first; buf->nextBuffer != (_Buffer *)0x0; buf = buf->nextBuffer) {
      iVar1 = strcmp(buf->nextBuffer->buffername,name);
      if (iVar1 == 0) {
        return buf->nextBuffer;
      }
    }
    first = (Buffer *)0x0;
  }
  return first;
}



Buffer * deleteBuffer(Buffer *first,Buffer *delbuf)

{
  Buffer *buf_00;
  Buffer *pBVar1;
  Buffer *b;
  Buffer *buf;
  
  if ((first == delbuf) && (first->nextBuffer != (_Buffer *)0x0)) {
    pBVar1 = first->nextBuffer;
    discardBuffer(first);
    first = pBVar1;
  }
  else {
    pBVar1 = prevBuffer(first,delbuf);
    if (pBVar1 != (Buffer *)0x0) {
      buf_00 = pBVar1->nextBuffer;
      pBVar1->nextBuffer = buf_00->nextBuffer;
      discardBuffer(buf_00);
    }
  }
  return first;
}



Buffer * replaceBuffer(Buffer *first,Buffer *delbuf,Buffer *newbuf)

{
  Buffer *pBVar1;
  Buffer *buf;
  
  if (delbuf == (Buffer *)0x0) {
    newbuf->nextBuffer = first;
  }
  else if (first == delbuf) {
    newbuf->nextBuffer = delbuf->nextBuffer;
    discardBuffer(delbuf);
  }
  else {
    if ((delbuf != (Buffer *)0x0) && (pBVar1 = prevBuffer(first,delbuf), pBVar1 != (Buffer *)0x0)) {
      pBVar1->nextBuffer = newbuf;
      newbuf->nextBuffer = delbuf->nextBuffer;
      discardBuffer(delbuf);
      return first;
    }
    newbuf->nextBuffer = first;
  }
  return newbuf;
}



Buffer * nthBuffer(Buffer *firstbuf,int n)

{
  Buffer *buf;
  int i;
  
  buf = firstbuf;
  if (-1 < n) {
    for (i = 0; i < n; i = i + 1) {
      if (buf == (Buffer *)0x0) {
        return (Buffer *)0x0;
      }
      buf = buf->nextBuffer;
    }
  }
  return buf;
}



void writeBufferName(Buffer *buf,int n)

{
  wc_ces t_ces;
  wc_ces f_ces;
  Str x;
  int iVar1;
  Str p_Var2;
  int all;
  Str msg;
  
  all = buf->allLine;
  if ((all == 0) && (buf->lastLine != (Line *)0x0)) {
    all = buf->lastLine->linenumber;
  }
  move(n,0);
  x = Sprintf("<%s> [%d lines]",buf->buffername,all);
  if (buf->filename == (char *)0x0) goto LAB_08072e83;
  iVar1 = (buf->currentURL).scheme;
  if (3 < iVar1) {
    if (iVar1 < 6) {
      iVar1 = strcmp((buf->currentURL).file,"-");
      if (iVar1 != 0) {
        if (x->area_size <= x->length + 1) {
          Strgrow(x);
        }
        iVar1 = x->length;
        x->ptr[iVar1] = ' ';
        x->length = iVar1 + 1;
        x->ptr[x->length] = '\0';
        f_ces = SystemCharset;
        t_ces = InnerCharset;
        p_Var2 = Strnew_charp((buf->currentURL).real_file);
        p_Var2 = wc_Str_conv(p_Var2,f_ces,t_ces);
        Strcat_charp(x,p_Var2->ptr);
      }
      goto LAB_08072e83;
    }
    if (iVar1 - 0xfeU < 2) goto LAB_08072e83;
  }
  if (x->area_size <= x->length + 1) {
    Strgrow(x);
  }
  iVar1 = x->length;
  x->ptr[iVar1] = ' ';
  x->length = iVar1 + 1;
  x->ptr[x->length] = '\0';
  p_Var2 = parsedURL2Str(&buf->currentURL);
  Strcat(x,p_Var2);
LAB_08072e83:
  addnstr_sup(x->ptr,COLS + -1);
  return;
}



void gotoLine(Buffer *buf,int n)

{
  int iVar1;
  Line *pLVar2;
  int in_GS_OFFSET;
  Line *l;
  char msg [32];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  l = buf->firstLine;
  if (l != (Line *)0x0) {
    if ((buf->pagerSource != (InputStream)0x0) && ((buf->bufferprop & 0x40U) == 0)) {
      if (buf->lastLine->linenumber < n) {
        getNextPage(buf,n - buf->lastLine->linenumber);
      }
      do {
        if (n <= buf->lastLine->linenumber) break;
        pLVar2 = getNextPage(buf,1);
      } while (pLVar2 != (Line *)0x0);
    }
    if (n < l->linenumber) {
      sprintf(msg,"First line is #%ld",l->linenumber);
      set_delayed_message(msg);
      buf->currentLine = l;
      buf->topLine = buf->currentLine;
    }
    else if (buf->lastLine->linenumber < n) {
      pLVar2 = buf->lastLine;
      sprintf(msg,"Last line is #%ld",buf->lastLine->linenumber);
      set_delayed_message(msg);
      buf->currentLine = pLVar2;
      pLVar2 = lineSkip(buf,buf->currentLine,1 - buf->LINES,0);
      buf->topLine = pLVar2;
    }
    else {
      for (; l != (Line *)0x0; l = l->next) {
        if (n <= l->linenumber) {
          buf->currentLine = l;
          if ((n < buf->topLine->linenumber) || (buf->topLine->linenumber + (int)buf->LINES <= n)) {
            pLVar2 = lineSkip(buf,l,~(int)buf->LINES / 2,0);
            buf->topLine = pLVar2;
          }
          break;
        }
      }
    }
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void gotoRealLine(Buffer *buf,int n)

{
  int iVar1;
  Line *pLVar2;
  int in_GS_OFFSET;
  Line *l;
  char msg [32];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  l = buf->firstLine;
  if (l != (Line *)0x0) {
    if ((buf->pagerSource != (InputStream)0x0) && ((buf->bufferprop & 0x40U) == 0)) {
      if (buf->lastLine->real_linenumber < n) {
        getNextPage(buf,n - buf->lastLine->real_linenumber);
      }
      do {
        if (n <= buf->lastLine->real_linenumber) break;
        pLVar2 = getNextPage(buf,1);
      } while (pLVar2 != (Line *)0x0);
    }
    if (n < l->real_linenumber) {
      sprintf(msg,"First line is #%ld",l->real_linenumber);
      set_delayed_message(msg);
      buf->currentLine = l;
      buf->topLine = buf->currentLine;
    }
    else if (buf->lastLine->real_linenumber < n) {
      pLVar2 = buf->lastLine;
      sprintf(msg,"Last line is #%ld",buf->lastLine->real_linenumber);
      set_delayed_message(msg);
      buf->currentLine = pLVar2;
      pLVar2 = lineSkip(buf,buf->currentLine,1 - buf->LINES,0);
      buf->topLine = pLVar2;
    }
    else {
      for (; l != (Line *)0x0; l = l->next) {
        if (n <= l->real_linenumber) {
          buf->currentLine = l;
          if ((n < buf->topLine->real_linenumber) ||
             (buf->topLine->real_linenumber + (int)buf->LINES <= n)) {
            pLVar2 = lineSkip(buf,l,~(int)buf->LINES / 2,0);
            buf->topLine = pLVar2;
          }
          break;
        }
      }
    }
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



Buffer * listBuffer(Buffer *top,Buffer *current)

{
  Buffer *buf;
  int c;
  int i;
  
  c = 0;
  buf = top;
  move(0,0);
  if (useColor != 0) {
    setfcolor(basic_color);
    setbcolor(bg_color);
  }
  clrtobotx();
  i = 0;
  do {
    if (LINES + -1 <= i) {
LAB_080733bb:
      standout();
      message("Buffer selection mode: SPC for select / D for delete buffer",0,0);
      standend();
      move(c,0);
      refresh();
      return buf->nextBuffer;
    }
    if (buf == current) {
      c = i;
      standout();
    }
    writeBufferName(buf,i);
    if (buf == current) {
      standend();
      clrtoeolx();
      move(i,0);
      toggle_stand();
    }
    else {
      clrtoeolx();
    }
    if (buf->nextBuffer == (_Buffer *)0x0) {
      move(i + 1,0);
      clrtobotx();
      goto LAB_080733bb;
    }
    buf = buf->nextBuffer;
    i = i + 1;
  } while( true );
}



Buffer * selectBuffer(Buffer *firstbuf,Buffer *currentbuf,char *selectchar)

{
  Buffer *current;
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  Buffer *topbuf;
  Buffer *buf;
  int sclimit;
  int maxbuf;
  int spoint;
  int cpoint;
  int i;
  char c;
  
  iVar1 = LINES;
  iVar3 = LINES + -1;
  cpoint = 0;
  i = 0;
  for (buf = firstbuf; iVar2 = i, buf != (Buffer *)0x0; buf = buf->nextBuffer) {
    if (buf == currentbuf) {
      cpoint = i;
    }
    i = i + 1;
  }
  if (cpoint < iVar3) {
    topbuf = firstbuf;
    spoint = cpoint;
  }
  else {
    spoint = iVar3 / 2;
    topbuf = nthBuffer(firstbuf,cpoint - spoint);
  }
  listBuffer(topbuf,currentbuf);
  do {
    iVar4 = do_getch();
    c = (char)iVar4;
    if (c == '\x1b') {
      iVar4 = do_getch();
      c = (char)iVar4;
      if ((c == '[') || (c == 'O')) {
        iVar4 = do_getch();
        c = (char)iVar4;
        if (c == 'B') {
          c = 'j';
        }
        else if (c < 'C') {
          if (c == 'A') {
            c = 'k';
          }
        }
        else if (c == 'C') {
          c = ' ';
        }
        else if (c == 'D') {
          c = 'B';
        }
      }
    }
    if (c == '\x10') {
LAB_080735eb:
      if (spoint < 1) {
        if (0 < cpoint) {
          i = cpoint - iVar3;
          if (i < 0) {
            i = 0;
          }
          cpoint = cpoint + -1;
          spoint = cpoint - i;
          currentbuf = nthBuffer(firstbuf,cpoint);
          topbuf = nthBuffer(firstbuf,i);
          listBuffer(topbuf,currentbuf);
        }
      }
      else {
        writeBufferName(currentbuf,spoint);
        spoint = spoint + -1;
        currentbuf = nthBuffer(topbuf,spoint);
        cpoint = cpoint + -1;
        standout();
        writeBufferName(currentbuf,spoint);
        standend();
        move(spoint,0);
        toggle_stand();
      }
      goto LAB_080736de;
    }
    if (c < '\x11') {
      if (c != '\x0e') goto LAB_080736cc;
    }
    else if (c != 'j') {
      if (c == 'k') goto LAB_080735eb;
LAB_080736cc:
      *selectchar = c;
      return currentbuf;
    }
    if (iVar1 + -2 <= spoint) {
      if (cpoint < iVar2 + -1) {
        topbuf = currentbuf;
        current = currentbuf->nextBuffer;
        cpoint = cpoint + 1;
        spoint = 1;
        listBuffer(currentbuf,current);
        currentbuf = current;
      }
      goto LAB_080736de;
    }
    if (currentbuf->nextBuffer != (_Buffer *)0x0) {
      writeBufferName(currentbuf,spoint);
      currentbuf = currentbuf->nextBuffer;
      cpoint = cpoint + 1;
      spoint = spoint + 1;
      standout();
      writeBufferName(currentbuf,spoint);
      standend();
      move(spoint,0);
      toggle_stand();
LAB_080736de:
      move(spoint,0);
      refresh();
    }
  } while( true );
}



void reshapeBuffer(Buffer *buf)

{
  wc_uint8 wVar1;
  int iVar2;
  char *path;
  frameset *pfVar3;
  Line *pLVar4;
  Buffer sbuf;
  URLFile h;
  URLFile f;
  int n;
  Line *cur;
  wc_uint8 old_auto_detect;
  
  wVar1 = WcOption.auto_detect;
  if (buf->need_reshape != '\0') {
    buf->need_reshape = '\0';
    if (showLineNum == 0) {
      iVar2 = 1;
    }
    else {
      iVar2 = 6;
    }
    iVar2 = COLS - iVar2;
    if (iVar2 < 0) {
      iVar2 = 0;
    }
    buf->width = (short)iVar2;
    if (buf->sourcefile != (char *)0x0) {
      init_stream(&f,4,(InputStream)0x0);
      if (buf->mailcap_source == (char *)0x0) {
        path = buf->sourcefile;
      }
      else {
        path = buf->mailcap_source;
      }
      examineFile(path,&f);
      if (f.stream != (InputStream)0x0) {
        copyBuffer(&sbuf,buf);
        clearBuffer(buf);
        while (buf->frameset != (frameset *)0x0) {
          deleteFrameSet(buf->frameset);
          pfVar3 = popFrameTree(&buf->frameQ);
          buf->frameset = pfVar3;
        }
        buf->href = (AnchorList *)0x0;
        buf->name = (AnchorList *)0x0;
        buf->img = (AnchorList *)0x0;
        buf->formitem = (AnchorList *)0x0;
        buf->formlist = (FormList *)0x0;
        buf->linklist = (LinkList *)0x0;
        buf->maplist = (MapList *)0x0;
        if (buf->hmarklist != (HmarkerList *)0x0) {
          buf->hmarklist->nmark = 0;
        }
        if (buf->imarklist != (HmarkerList *)0x0) {
          buf->imarklist->nmark = 0;
        }
        if (buf->header_source != (char *)0x0) {
          if ((((buf->currentURL).scheme == 4) && (buf->mailcap_source == (char *)0x0)) &&
             (iVar2 = strcmp((buf->currentURL).file,"-"), iVar2 != 0)) {
            if (buf->search_header != '\0') {
              readHeader(&f,buf,1,(ParsedURL *)0x0);
            }
          }
          else {
            init_stream(&h,4,(InputStream)0x0);
            examineFile(buf->header_source,&h);
            if (h.stream != (InputStream)0x0) {
              readHeader(&h,buf,1,(ParsedURL *)0x0);
              iVar2 = ISclose(h.stream);
              if (iVar2 == 0) {
                h.stream = (InputStream)0x0;
              }
            }
          }
        }
        WcOption.auto_detect = '\0';
        UseContentCharset = '\0';
        iVar2 = is_html_type(buf->type);
        if (iVar2 == 0) {
          loadBuffer(&f,buf);
        }
        else {
          loadHTMLBuffer(&f,buf);
        }
        iVar2 = ISclose(f.stream);
        if (iVar2 == 0) {
          f.stream = (InputStream)0x0;
        }
        UseContentCharset = '\x01';
        WcOption.auto_detect = wVar1;
        buf->height = (short)LINES;
        if ((buf->firstLine != (Line *)0x0) && (sbuf.firstLine != (Line *)0x0)) {
          cur = sbuf.currentLine;
          buf->pos = sbuf.pos + (sbuf.currentLine)->bpos;
          for (; (cur->bpos != 0 && (cur->prev != (_Line *)0x0)); cur = cur->prev) {
          }
          if (cur->real_linenumber < 1) {
            gotoLine(buf,cur->linenumber);
          }
          else {
            gotoRealLine(buf,cur->real_linenumber);
          }
          iVar2 = (buf->currentLine->linenumber - buf->topLine->linenumber) +
                  ((sbuf.topLine)->linenumber - cur->linenumber);
          if (iVar2 != 0) {
            pLVar4 = lineSkip(buf,buf->topLine,iVar2,0);
            buf->topLine = pLVar4;
            if (cur->real_linenumber < 1) {
              gotoLine(buf,cur->linenumber);
            }
            else {
              gotoRealLine(buf,cur->real_linenumber);
            }
          }
          buf->pos = buf->pos - buf->currentLine->bpos;
          if ((FoldLine == 0) || (iVar2 = is_html_type(buf->type), iVar2 != 0)) {
            buf->currentColumn = sbuf.currentColumn;
          }
          else {
            buf->currentColumn = 0;
          }
          arrangeCursor(buf);
        }
        if ((buf->check_url & 1U) != 0) {
          chkURLBuffer(buf);
        }
        if ((buf->check_url & 2U) != 0) {
          chkNMIDBuffer(buf);
        }
        if ((buf->real_scheme == 7) || (buf->real_scheme == 9)) {
          reAnchorNewsheader(buf);
        }
        formResetBuffer(buf,sbuf.formitem);
      }
    }
  }
  return;
}



void copyBuffer(Buffer *a,Buffer *b)

{
  readBufferCache(b);
  bcopy(b,a,0x104);
  return;
}



Buffer * prevBuffer(Buffer *first,Buffer *buf)

{
  Buffer *b;
  
  for (b = first; (b != (Buffer *)0x0 && (b->nextBuffer != buf)); b = b->nextBuffer) {
  }
  return b;
}



int writeBufferCache(Buffer *buf)

{
  size_t sVar1;
  int colorflag;
  Line *l;
  FILE *cache;
  Str tmp;
  
  cache = (FILE *)0x0;
  if (buf->savecache == (char *)0x0) {
    if (buf->firstLine != (Line *)0x0) {
      tmp = tmpfname(3,(char *)0x0);
      buf->savecache = tmp->ptr;
      cache = (FILE *)fopen(buf->savecache,"w");
      if ((FILE *)cache != (FILE *)0x0) {
        sVar1 = fwrite(&buf->currentLine->linenumber,4,1,(FILE *)cache);
        if ((sVar1 != 0) &&
           (sVar1 = fwrite(&buf->topLine->linenumber,4,1,(FILE *)cache), sVar1 != 0)) {
          l = buf->firstLine;
          while( true ) {
            if (l == (Line *)0x0) {
              fclose((FILE *)cache);
              return 0;
            }
            sVar1 = fwrite(&l->real_linenumber,4,1,(FILE *)cache);
            if (((((sVar1 == 0) || (sVar1 = fwrite(&l->usrflags,2,1,(FILE *)cache), sVar1 == 0)) ||
                 (sVar1 = fwrite(&l->width,4,1,(FILE *)cache), sVar1 == 0)) ||
                (((sVar1 = fwrite(&l->len,4,1,(FILE *)cache), sVar1 == 0 ||
                  (sVar1 = fwrite(&l->size,4,1,(FILE *)cache), sVar1 == 0)) ||
                 ((sVar1 = fwrite(&l->bpos,4,1,(FILE *)cache), sVar1 == 0 ||
                  (sVar1 = fwrite(&l->bwidth,4,1,(FILE *)cache), sVar1 == 0)))))) ||
               ((l->bpos == 0 &&
                ((sVar1 = fwrite(l->lineBuf,1,l->size,(FILE *)cache), sVar1 < (uint)l->size ||
                 (sVar1 = fwrite(l->propBuf,2,l->size,(FILE *)cache), sVar1 < (uint)l->size))))))
            break;
            colorflag = (int)(l->colorBuf != (Linecolor *)0x0);
            sVar1 = fwrite(&colorflag,4,1,(FILE *)cache);
            if ((sVar1 == 0) ||
               (((colorflag != 0 && (l->bpos == 0)) &&
                (sVar1 = fwrite(l->colorBuf,1,l->size,(FILE *)cache), sVar1 < (uint)l->size))))
            break;
            l = l->next;
          }
        }
        fclose((FILE *)cache);
        unlink(buf->savecache);
      }
    }
    buf->savecache = (char *)0x0;
  }
  return -1;
}



int readBufferCache(Buffer *buf)

{
  int iVar1;
  size_t sVar2;
  char *pcVar3;
  Lineprop *pLVar4;
  Linecolor *pLVar5;
  int colorflag;
  long tlnum;
  long clnum;
  long lnum;
  Line *basel;
  Line *prevl;
  Line *l;
  FILE *cache;
  
  l = (Line *)0x0;
  prevl = (Line *)0x0;
  basel = (Line *)0x0;
  lnum = 0;
  if (buf->savecache == (char *)0x0) {
    iVar1 = -1;
  }
  else {
    cache = (FILE *)fopen(buf->savecache,"r");
    if ((((FILE *)cache == (FILE *)0x0) || (sVar2 = fread(&clnum,4,1,(FILE *)cache), sVar2 == 0)) ||
       (sVar2 = fread(&tlnum,4,1,(FILE *)cache), sVar2 == 0)) {
      buf->savecache = (char *)0x0;
      iVar1 = -1;
    }
    else {
      while (iVar1 = feof((FILE *)cache), iVar1 == 0) {
        lnum = lnum + 1;
        prevl = l;
        l = (Line *)GC_malloc(0x34);
        l->prev = prevl;
        if (prevl == (Line *)0x0) {
          buf->firstLine = l;
        }
        else {
          prevl->next = l;
        }
        l->linenumber = lnum;
        if (lnum == clnum) {
          buf->currentLine = l;
        }
        if (lnum == tlnum) {
          buf->topLine = l;
        }
        sVar2 = fread(&l->real_linenumber,4,1,(FILE *)cache);
        if (((((sVar2 == 0) || (sVar2 = fread(&l->usrflags,2,1,(FILE *)cache), sVar2 == 0)) ||
             ((sVar2 = fread(&l->width,4,1,(FILE *)cache), sVar2 == 0 ||
              ((sVar2 = fread(&l->len,4,1,(FILE *)cache), sVar2 == 0 ||
               (sVar2 = fread(&l->size,4,1,(FILE *)cache), sVar2 == 0)))))) ||
            (sVar2 = fread(&l->bpos,4,1,(FILE *)cache), sVar2 == 0)) ||
           (sVar2 = fread(&l->bwidth,4,1,(FILE *)cache), sVar2 == 0)) break;
        if (l->bpos == 0) {
          basel = l;
          pcVar3 = (char *)GC_malloc_atomic(l->size + 1);
          l->lineBuf = pcVar3;
          fread(l->lineBuf,1,l->size,(FILE *)cache);
          l->lineBuf[l->size] = '\0';
          pLVar4 = (Lineprop *)GC_malloc_atomic(l->size * 2);
          l->propBuf = pLVar4;
          fread(l->propBuf,2,l->size,(FILE *)cache);
        }
        else {
          if (basel == (Line *)0x0) break;
          l->lineBuf = basel->lineBuf + l->bpos;
          l->propBuf = basel->propBuf + l->bpos;
        }
        sVar2 = fread(&colorflag,4,1,(FILE *)cache);
        if (sVar2 == 0) break;
        if (colorflag == 0) {
          l->colorBuf = (Linecolor *)0x0;
        }
        else if (l->bpos == 0) {
          pLVar5 = (Linecolor *)GC_malloc_atomic(l->size);
          l->colorBuf = pLVar5;
          fread(l->colorBuf,1,l->size,(FILE *)cache);
        }
        else {
          l->colorBuf = basel->colorBuf + l->bpos;
        }
      }
      buf->lastLine = prevl;
      buf->lastLine->next = (_Line *)0x0;
      fclose((FILE *)cache);
      unlink(buf->savecache);
      buf->savecache = (char *)0x0;
      iVar1 = 0;
    }
  }
  return iVar1;
}



void effect_anchor_start(void)

{
  if (useColor == 0) {
    underline();
  }
  else {
    setfcolor(anchor_color);
  }
  return;
}



void effect_anchor_end(void)

{
  if (useColor == 0) {
    underlineend();
  }
  else {
    setfcolor(basic_color);
  }
  return;
}



void effect_image_start(void)

{
  if (useColor == 0) {
    standout();
  }
  else {
    setfcolor(image_color);
  }
  return;
}



void effect_image_end(void)

{
  if (useColor == 0) {
    standend();
  }
  else {
    setfcolor(basic_color);
  }
  return;
}



void effect_form_start(void)

{
  if (useColor == 0) {
    standout();
  }
  else {
    setfcolor(form_color);
  }
  return;
}



void effect_form_end(void)

{
  if (useColor == 0) {
    standend();
  }
  else {
    setfcolor(basic_color);
  }
  return;
}



void effect_mark_start(void)

{
  if (useColor == 0) {
    standout();
  }
  else {
    setbcolor(mark_color);
  }
  return;
}



void effect_mark_end(void)

{
  if (useColor == 0) {
    standend();
  }
  else {
    setbcolor(bg_color);
  }
  return;
}



void effect_active_start(void)

{
  if (useColor == 0) {
    bold();
  }
  else if (useActiveColor == 0) {
    underline();
  }
  else {
    setfcolor(active_color);
    underline();
  }
  return;
}



void effect_active_end(void)

{
  if (useColor == 0) {
    boldend();
  }
  else if (useActiveColor == 0) {
    underlineend();
  }
  else {
    setfcolor(basic_color);
    underlineend();
  }
  return;
}



void effect_visited_start(void)

{
  if ((useVisitedColor != 0) && (useColor != 0)) {
    setfcolor(visited_color);
  }
  return;
}



void effect_visited_end(void)

{
  if ((useVisitedColor != 0) && (useColor != 0)) {
    setfcolor(basic_color);
  }
  return;
}



void fmTerm(void)

{
  if (fmInitialized != '\0') {
    move(LINES + -1,0);
    clrtoeolx();
    refresh();
    if (activeImage != 0) {
      loadImage((Buffer *)0x0,1);
    }
    if (use_mouse != 0) {
      mouse_end();
    }
    reset_tty();
    fmInitialized = '\0';
  }
  return;
}



void fmInit(void)

{
  if (fmInitialized == '\0') {
    initscr();
    term_raw();
    term_noecho();
    if (displayImage != 0) {
      initImage();
    }
  }
  fmInitialized = '\x01';
  return;
}



Str make_lastline_link(Buffer *buf,char *title,char *url)

{
  int iVar1;
  ParsedURL *current;
  char *p_00;
  int iVar2;
  Str p_Var3;
  ParsedURL pu;
  int i;
  int l;
  char *p;
  Lineprop *pr;
  Str u;
  Str s;
  
  s = (Str)0x0;
  l = COLS + -1;
  if ((title != (char *)0x0) && (*title != '\0')) {
    s = Strnew_m_charp("[",title,&DAT_080cac38,0);
    for (p = s->ptr; *p != '\0'; p = p + 1) {
      if (((MYCTYPE_MAP[(byte)*p] & 1) != 0) || ((MYCTYPE_MAP[(byte)*p] & 2) != 0)) {
        *p = ' ';
      }
    }
    if (url != (char *)0x0) {
      Strcat_charp(s," ");
    }
    iVar1 = wtf_strwidth((wc_uchar *)s->ptr);
    l = l - iVar1;
    if (l < 1) {
      return s;
    }
  }
  p_Var3 = s;
  if (url != (char *)0x0) {
    current = baseURL(buf);
    parseURL2(url,&pu,current);
    u = parsedURL2Str(&pu);
    if (DecodeURL != 0) {
      p_00 = url_unquote_conv(u->ptr,buf->document_charset);
      u = Strnew_charp(p_00);
    }
    u = checkType(u,&pr,(Linecolor **)0x0);
    if ((l < 5) || (iVar1 = wtf_strwidth((wc_uchar *)u->ptr), iVar1 <= l)) {
      p_Var3 = u;
      if (s != (Str)0x0) {
        Strcat(s,u);
        p_Var3 = s;
      }
    }
    else {
      if (s == (Str)0x0) {
        s = Strnew_size(COLS);
      }
      for (i = (l + -2) / 2; (i != 0 && ((pr[i] & 0x400) != 0)); i = i + -1) {
      }
      Strcat_charp_n(s,u->ptr,i);
      Strcat_charp(s,"..");
      iVar1 = wtf_strwidth((wc_uchar *)u->ptr);
      iVar2 = wtf_strwidth((wc_uchar *)s->ptr);
      for (i = iVar1 + iVar2 + (1 - COLS); (i < u->length && ((pr[i] & 0x400) != 0)); i = i + 1) {
      }
      Strcat_charp(s,u->ptr + i);
      p_Var3 = s;
    }
  }
  return p_Var3;
}



Str make_lastline_message(Buffer *buf)

{
  int iVar1;
  double dVar2;
  MapArea *pMVar3;
  Anchor *pAVar4;
  Anchor *pAVar5;
  char *url;
  Str y;
  int iVar6;
  byte bVar7;
  char *p_1;
  int l;
  int r;
  int ll;
  int cl;
  Anchor *a_img;
  char *p;
  Anchor *a_1;
  MapArea *a;
  int sl;
  Str s;
  Str msg;
  
  s = (Str)0x0;
  sl = 0;
  if (displayLink != 0) {
    pMVar3 = retrieveCurrentMapArea(buf);
    if (pMVar3 == (MapArea *)0x0) {
      pAVar4 = retrieveCurrentAnchor(buf);
      p = (char *)0x0;
      if (((pAVar4 == (Anchor *)0x0) || (pAVar4->title == (char *)0x0)) || (*pAVar4->title == '\0'))
      {
        pAVar5 = retrieveCurrentImg(buf);
        if (((pAVar5 != (Anchor *)0x0) && (pAVar5->title != (char *)0x0)) &&
           (*pAVar5->title != '\0')) {
          p = pAVar5->title;
        }
      }
      else {
        p = pAVar4->title;
      }
      if ((p != (char *)0x0) || (pAVar4 != (Anchor *)0x0)) {
        if (pAVar4 == (Anchor *)0x0) {
          url = (char *)0x0;
        }
        else {
          url = pAVar4->url;
        }
        s = make_lastline_link(buf,p,url);
      }
    }
    else {
      s = make_lastline_link(buf,pMVar3->alt,pMVar3->url);
    }
    if ((s != (Str)0x0) && (sl = wtf_strwidth((wc_uchar *)s->ptr), COLS + -3 <= sl)) {
      return s;
    }
  }
  if ((use_mouse == 0) || (mouse_action.lastline_str == (char *)0x0)) {
    msg = Strnew();
  }
  else {
    msg = Strnew_charp(mouse_action.lastline_str);
  }
  if (((displayLineInfo == 0) || (buf->currentLine == (Line *)0x0)) ||
     (buf->lastLine == (Line *)0x0)) {
    Strcat_charp(msg,"Viewing");
  }
  else {
    iVar6 = buf->currentLine->real_linenumber;
    iVar1 = buf->lastLine->real_linenumber;
    if (iVar1 == 0) {
      dVar2 = 1.0;
    }
    else {
      dVar2 = (double)iVar1;
    }
    y = Sprintf("%d/%d (%d%%)",iVar6,iVar1,(int)ROUND(((double)iVar6 * 100.0) / dVar2 + 0.5));
    Strcat(msg,y);
  }
  Strcat_charp(msg," <");
  Strcat_charp(msg,buf->buffername);
  if (s == (Str)0x0) {
    Strcat_charp(msg,">");
  }
  else {
    l = (COLS + -3) - sl;
    iVar6 = wtf_strwidth((wc_uchar *)msg->ptr);
    if (l < iVar6) {
      for (p_1 = msg->ptr; *p_1 != '\0'; p_1 = p_1 + WTF_LEN_MAP[(byte)*p_1]) {
        if (WcOption.use_wide == '\0') {
          bVar7 = WTF_WIDTH_MAP[(byte)*p_1] != '\0';
        }
        else {
          bVar7 = WTF_WIDTH_MAP[(byte)*p_1];
        }
        l = l - (uint)bVar7;
        if (l < 0) break;
      }
      Strtruncate(msg,(int)p_1 - (int)msg->ptr);
    }
    Strcat_charp(msg,"> ");
    Strcat(msg,s);
  }
  return msg;
}



void displayBuffer(Buffer *buf,int mode)

{
  wc_ces f_ces;
  wc_ces t_ces;
  int iVar1;
  Str p_Var2;
  double dVar3;
  int ny;
  Str msg;
  
  ny = 0;
  if (buf != (Buffer *)0x0) {
    if ((buf->topLine == (Line *)0x0) && (iVar1 = readBufferCache(buf), iVar1 == 0)) {
      mode = 1;
    }
    if (buf->width == 0) {
      if (showLineNum == 0) {
        iVar1 = 1;
      }
      else {
        iVar1 = 6;
      }
      iVar1 = COLS - iVar1;
      if (iVar1 < 0) {
        iVar1 = 0;
      }
      buf->width = (short)iVar1;
    }
    if (buf->height == 0) {
      buf->height = (short)LINES;
    }
    if (showLineNum == 0) {
      iVar1 = 1;
    }
    else {
      iVar1 = 6;
    }
    iVar1 = COLS - iVar1;
    if (iVar1 < 0) {
      iVar1 = 0;
    }
    if (((buf->width != iVar1) && ((iVar1 = is_html_type(buf->type), iVar1 != 0 || (FoldLine != 0)))
        ) || (buf->need_reshape != '\0')) {
      buf->need_reshape = '\x01';
      reshapeBuffer(buf);
    }
    if (showLineNum == 0) {
      buf->rootX = 0;
    }
    else {
      if ((buf->lastLine != (Line *)0x0) && (0 < buf->lastLine->real_linenumber)) {
        dVar3 = log((double)buf->lastLine->real_linenumber + 0.1);
        buf->rootX = (short)(int)ROUND(dVar3 / 2.302585092994046) + 2;
      }
      if (buf->rootX < 5) {
        buf->rootX = 5;
      }
      if (COLS < buf->rootX) {
        buf->rootX = (short)COLS;
      }
    }
    buf->COLS = (short)COLS - buf->rootX;
    if ((1 < nTab) || (mouse_action.menu_str != (char *)0x0)) {
      if ((mode == 1) || (mode == 4)) {
        calcTabPos();
      }
      ny = LastTab->y + 2;
      if (LINES + -1 < ny) {
        ny = LINES + -1;
      }
    }
    if ((buf->rootY != ny) || ((int)buf->LINES != (LINES + -1) - ny)) {
      buf->rootY = (short)ny;
      buf->LINES = ((short)LINES - (short)ny) + -1;
      arrangeCursor(buf);
      mode = 4;
    }
    if ((((mode == 1) || (mode == 3)) || (mode == 4)) ||
       ((buf->topLine != cline || (buf->currentColumn != ccolumn)))) {
      if ((activeImage != 0) &&
         (((mode == 4 || (buf->topLine != cline)) || (buf->currentColumn != ccolumn)))) {
        if (draw_image_flag != 0) {
          clear();
        }
        clearImage();
        loadImage(buf,1);
        image_touch = image_touch + 1;
        draw_image_flag = 0;
      }
      redrawNLine(buf,LINES + -1);
      cline = buf->topLine;
      ccolumn = buf->currentColumn;
    }
    if (buf->topLine == (Line *)0x0) {
      buf->topLine = buf->firstLine;
    }
    if (buf->need_reshape == '\0') {
      drawAnchorCursor(buf);
      p_Var2 = make_lastline_message(buf);
      if (buf->firstLine == (Line *)0x0) {
        Strcat_charp(p_Var2,"\tNo Line");
      }
      if (delayed_msg != (char *)0x0) {
        disp_message(delayed_msg,0);
        delayed_msg = (char *)0x0;
        refresh();
      }
      standout();
      message(p_Var2->ptr,(int)buf->cursorX + (int)buf->rootX,(int)buf->cursorY + (int)buf->rootY);
      standend();
      t_ces = SystemCharset;
      f_ces = InnerCharset;
      p_Var2 = Strnew_charp(buf->buffername);
      p_Var2 = wc_Str_conv_strict(p_Var2,f_ces,t_ces);
      term_title(p_Var2->ptr);
      refresh();
      if (((activeImage != 0) && (displayImage != 0)) && (buf->img != (AnchorList *)0x0)) {
        drawImage();
      }
    }
    else {
      displayBuffer(buf,1);
    }
    return;
  }
  return;
}



void drawAnchorCursor0(Buffer *buf,AnchorList *al,int hseq,int prevhseq,int tline,int eline,
                      int active)

{
  Anchor *pAVar1;
  Anchor *an;
  Line *l;
  int j;
  int i;
  
  l = buf->topLine;
  j = 0;
  do {
    if (al->nanchor <= j) {
      return;
    }
    pAVar1 = al->anchors;
    if (tline <= pAVar1[j].start.line) {
      if (eline <= pAVar1[j].start.line) {
        return;
      }
      while( true ) {
        if (l == (Line *)0x0) {
          return;
        }
        if (l->linenumber == pAVar1[j].start.line) break;
        l = l->next;
      }
      if ((hseq < 0) || (pAVar1[j].hseq != hseq)) {
        if ((-1 < prevhseq) && ((pAVar1[j].hseq == prevhseq && (active != 0)))) {
          redrawLineRegion(buf,l,(l->linenumber - tline) + (int)buf->rootY,pAVar1[j].start.pos,
                           pAVar1[j].end.pos);
        }
      }
      else {
        for (i = pAVar1[j].start.pos; i < pAVar1[j].end.pos; i = i + 1) {
          if ((l->propBuf[i] & 0x70) != 0) {
            if (active == 0) {
              l->propBuf[i] = l->propBuf[i] & 0xff7f;
            }
            else {
              l->propBuf[i] = l->propBuf[i] | 0x80;
            }
          }
        }
        if (active != 0) {
          redrawLineRegion(buf,l,(l->linenumber - tline) + (int)buf->rootY,pAVar1[j].start.pos,
                           pAVar1[j].end.pos);
        }
      }
    }
    j = j + 1;
  } while( true );
}



void drawAnchorCursor(Buffer *buf)

{
  int tline_00;
  int prevhseq_00;
  int eline_00;
  int eline;
  int tline;
  int prevhseq;
  int hseq;
  Anchor *an;
  
  if (((buf->firstLine != (Line *)0x0) && (buf->hmarklist != (HmarkerList *)0x0)) &&
     ((buf->href != (AnchorList *)0x0 || (buf->formitem != (AnchorList *)0x0)))) {
    an = retrieveCurrentAnchor(buf);
    if (an == (Anchor *)0x0) {
      an = retrieveCurrentMap(buf);
    }
    if (an == (Anchor *)0x0) {
      hseq = -1;
    }
    else {
      hseq = an->hseq;
    }
    tline_00 = buf->topLine->linenumber;
    eline_00 = buf->LINES + tline_00;
    prevhseq_00 = buf->hmarklist->prevhseq;
    if (buf->href != (AnchorList *)0x0) {
      drawAnchorCursor0(buf,buf->href,hseq,prevhseq_00,tline_00,eline_00,1);
      drawAnchorCursor0(buf,buf->href,hseq,-1,tline_00,eline_00,0);
    }
    if (buf->formitem != (AnchorList *)0x0) {
      drawAnchorCursor0(buf,buf->formitem,hseq,prevhseq_00,tline_00,eline_00,1);
      drawAnchorCursor0(buf,buf->formitem,hseq,-1,tline_00,eline_00,0);
    }
    buf->hmarklist->prevhseq = hseq;
  }
  return;
}



void redrawNLine(Buffer *buf,int n)

{
  short sVar1;
  short sVar2;
  int iVar3;
  int l_1;
  TabBuffer *t;
  int i;
  Line *l;
  
  if (useColor != 0) {
    setfcolor(basic_color);
    setbcolor(bg_color);
  }
  if ((1 < nTab) || (mouse_action.menu_str != (char *)0x0)) {
    move(0,0);
    if (mouse_action.menu_str != (char *)0x0) {
      addstr(mouse_action.menu_str);
    }
    clrtoeolx();
    for (t = FirstTab; t != (TabBuffer *)0x0; t = t->nextTab) {
      move((int)t->y,(int)t->x1);
      if (t == CurrentTab) {
        bold();
      }
      addch('[');
      sVar1 = t->x2;
      sVar2 = t->x1;
      iVar3 = wtf_strwidth((wc_uchar *)t->currentBuffer->buffername);
      l_1 = (((int)sVar1 - (int)sVar2) + -1) - iVar3;
      if (l_1 < 0) {
        l_1 = 0;
      }
      if (1 < l_1) {
        addnstr_sup(" ",l_1 / 2);
      }
      if (t == CurrentTab) {
        effect_active_start();
      }
      addnstr(t->currentBuffer->buffername,((int)t->x2 - (int)t->x1) - l_1);
      if (t == CurrentTab) {
        effect_active_end();
      }
      if (1 < l_1 + 1) {
        addnstr_sup(" ",(l_1 + 1) / 2);
      }
      move((int)t->y,(int)t->x2);
      addch(']');
      if (t == CurrentTab) {
        boldend();
      }
    }
    move(LastTab->y + 1,0);
    for (i = 0; i < COLS; i = i + 1) {
      addch('~');
    }
  }
  i = 0;
  l = buf->topLine;
  for (; i < buf->LINES; i = i + 1) {
    if ((buf->LINES - n <= i) || (-i != n && i <= -n)) {
      l = redrawLine(buf,l,buf->rootY + i);
    }
    if (l == (Line *)0x0) break;
    l = l->next;
  }
  if (0 < n) {
    move(buf->rootY + i,0);
    clrtobotx();
  }
  if (((activeImage != 0) && (displayImage != 0)) && (buf->img != (AnchorList *)0x0)) {
    move((int)buf->cursorY + (int)buf->rootY,(int)buf->cursorX + (int)buf->rootX);
    i = 0;
    for (l = buf->topLine; (i < buf->LINES && (l != (Line *)0x0)); l = l->next) {
      if ((buf->LINES - n <= i) || (-i != n && i <= -n)) {
        redrawLineImage(buf,l,buf->rootY + i);
      }
      i = i + 1;
    }
    getAllImage(buf);
  }
  return;
}



Line * redrawLine(Buffer *buf,Line *l,int i)

{
  int iVar1;
  int column_00;
  char *pcVar2;
  Lineprop *pLVar3;
  int iVar4;
  int iVar5;
  Anchor *pAVar6;
  ParsedURL *current;
  Str p_Var7;
  HistItem *pHVar8;
  size_t len;
  int iVar9;
  int in_GS_OFFSET;
  double dVar10;
  Line *local_84;
  ParsedURL url;
  int vpos;
  int k;
  Anchor *a;
  Linecolor *pc;
  Lineprop *pr;
  char *p;
  int column;
  int delta;
  int ncol;
  int rcol;
  int pos;
  int j;
  char tmp [16];
  
  local_84 = l;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  column_00 = buf->currentColumn;
  vpos = -1;
  if (l == (Line *)0x0) {
    if (buf->pagerSource == (InputStream)0x0) {
      local_84 = (Line *)0x0;
      goto LAB_08075f17;
    }
    local_84 = getNextPage(buf,((int)buf->LINES + (int)buf->rootY) - i);
    if (local_84 == (Line *)0x0) {
      local_84 = (Line *)0x0;
      goto LAB_08075f17;
    }
  }
  move(i,0);
  if (showLineNum != 0) {
    if (buf->rootX == 0) {
      if (0 < buf->lastLine->real_linenumber) {
        dVar10 = log((double)buf->lastLine->real_linenumber + 0.1);
        buf->rootX = (short)(int)ROUND(dVar10 / 2.302585092994046) + 2;
      }
      if (buf->rootX < 5) {
        buf->rootX = 5;
      }
      if (COLS < buf->rootX) {
        buf->rootX = (short)COLS;
      }
      buf->COLS = (short)COLS - buf->rootX;
    }
    if ((local_84->real_linenumber == 0) || (local_84->bpos != 0)) {
      sprintf(tmp,"%*s ",buf->rootX + -1,&DAT_080cac72);
    }
    else {
      sprintf(tmp,"%*ld:",buf->rootX + -1,local_84->real_linenumber);
    }
    addstr(tmp);
  }
  move(i,(int)buf->rootX);
  if (local_84->width < 0) {
    iVar5 = calcPosition(local_84->lineBuf,local_84->propBuf,local_84->len,local_84->len,0,0);
    local_84->width = iVar5;
  }
  if ((local_84->len == 0) || (local_84->width + -1 < column_00)) {
    clrtoeolx();
  }
  else {
    iVar5 = columnPos(local_84,column_00);
    pcVar2 = local_84->lineBuf;
    pLVar3 = local_84->propBuf;
    if ((useColor == 0) || (local_84->colorBuf == (Linecolor *)0x0)) {
      pc = (Linecolor *)0x0;
    }
    else {
      pc = local_84->colorBuf + iVar5;
    }
    rcol = calcPosition(local_84->lineBuf,local_84->propBuf,local_84->len,iVar5,0,0);
    for (j = 0; (rcol - column_00 < (int)buf->COLS && (iVar5 + j < local_84->len)); j = j + len) {
      if ((useVisitedColor != 0) &&
         (((vpos <= iVar5 + j && ((pLVar3[iVar5 + j] & 0x4000) == 0)) &&
          (pAVar6 = retrieveAnchor(buf->href,local_84->linenumber,iVar5 + j),
          pAVar6 != (Anchor *)0x0)))) {
        current = baseURL(buf);
        parseURL2(pAVar6->url,&url,current);
        p_Var7 = parsedURL2Str(&url);
        pHVar8 = getHashHist(URLHist,p_Var7->ptr);
        if (pHVar8 != (HistItem *)0x0) {
          for (k = (pAVar6->start).pos; k < (pAVar6->end).pos; k = k + 1) {
            pLVar3[k] = pLVar3[k] & 0xff | (ushort)(byte)((uint)pLVar3[k] >> 8) << 8 | 0x4000;
          }
        }
        vpos = (pAVar6->end).pos;
      }
      len = wtf_len((wc_uchar *)(pcVar2 + j + iVar5));
      iVar9 = calcPosition(local_84->lineBuf,local_84->propBuf,local_84->len,iVar5 + j + len,0,0);
      if ((int)buf->COLS < iVar9 - column_00) break;
      if (pc != (Linecolor *)0x0) {
        do_color(pc[j]);
      }
      iVar4 = column_00;
      if (rcol < column_00) {
        while (rcol = iVar4, iVar4 = rcol, rcol < iVar9) {
          addChar(' ',0);
          iVar4 = rcol + 1;
        }
      }
      else {
        iVar4 = iVar9;
        if (pcVar2[j + iVar5] == '\t') {
          for (; rcol < iVar9; rcol = rcol + 1) {
            addChar(' ',0);
          }
        }
        else {
          addMChar(pcVar2 + j + iVar5,pLVar3[iVar5 + j],len);
        }
      }
      rcol = iVar4;
    }
    if (somode != 0) {
      somode = 0;
      standend();
    }
    if (ulmode != 0) {
      ulmode = 0;
      underlineend();
    }
    if (bomode != 0) {
      bomode = 0;
      boldend();
    }
    if (emph_mode != 0) {
      emph_mode = 0;
      boldend();
    }
    if (anch_mode != 0) {
      anch_mode = 0;
      effect_anchor_end();
    }
    if (imag_mode != 0) {
      imag_mode = 0;
      effect_image_end();
    }
    if (form_mode != 0) {
      form_mode = 0;
      effect_form_end();
    }
    if (visited_mode != 0) {
      visited_mode = 0;
      effect_visited_end();
    }
    if (active_mode != 0) {
      active_mode = 0;
      effect_active_end();
    }
    if (mark_mode != 0) {
      mark_mode = 0;
      effect_mark_end();
    }
    if (graph_mode != 0) {
      graph_mode = 0;
      graphend();
    }
    if (color_mode != '\0') {
      do_color('\0');
    }
    if (rcol - column_00 < (int)buf->COLS) {
      clrtoeolx();
    }
  }
LAB_08075f17:
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return local_84;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



Line * redrawLineImage(Buffer *buf,Line *l,int i)

{
  char cVar1;
  int column_00;
  Image *image_00;
  int iVar2;
  Anchor *pAVar3;
  ParsedURL *current;
  ImageCache *pIVar4;
  int iVar5;
  ImageCache *cache;
  Image *image;
  int h;
  int w;
  int sy;
  int sx;
  int y;
  int x;
  Anchor *a;
  int column;
  int rcol;
  int pos;
  int j;
  
  column_00 = buf->currentColumn;
  if (l == (Line *)0x0) {
    l = (Line *)0x0;
  }
  else {
    if (l->width < 0) {
      iVar2 = calcPosition(l->lineBuf,l->propBuf,l->len,l->len,0,0);
      l->width = iVar2;
    }
    if ((l->len != 0) && (column_00 <= l->width + -1)) {
      iVar2 = columnPos(l,column_00);
      rcol = calcPosition(l->lineBuf,l->propBuf,l->len,iVar2,0,0);
      for (j = 0; (rcol - column_00 < (int)buf->COLS && (iVar2 + j < l->len)); j = j + 1) {
        if (rcol - column_00 < 0) {
          rcol = calcPosition(l->lineBuf,l->propBuf,l->len,iVar2 + j + 1,0,0);
        }
        else {
          pAVar3 = retrieveAnchor(buf->img,l->linenumber,iVar2 + j);
          if (((pAVar3 != (Anchor *)0x0) && (pAVar3->image != (Image *)0x0)) &&
             (pAVar3->image->touch < image_touch)) {
            image_00 = pAVar3->image;
            cVar1 = buf->image_flag;
            current = baseURL(buf);
            pIVar4 = getImage(image_00,current,(int)cVar1);
            image_00->cache = pIVar4;
            pIVar4 = image_00->cache;
            if (pIVar4 != (ImageCache *)0x0) {
              if (((image_00->width < 0) && (0 < pIVar4->width)) ||
                 ((image_00->height < 0 && (0 < pIVar4->height)))) {
                image_00->width = pIVar4->width;
                image_00->height = pIVar4->height;
                buf->need_reshape = '\x01';
              }
              x = (int)ROUND(pixel_per_char * (double)((rcol - column_00) + (int)buf->rootX));
              y = (int)ROUND(pixel_per_line * (double)i);
              iVar5 = calcPosition(l->lineBuf,l->propBuf,l->len,(pAVar3->start).pos,0,0);
              sx = (int)ROUND(pixel_per_char * (double)(rcol - iVar5));
              sy = (int)ROUND(pixel_per_line * (double)(l->linenumber - (int)image_00->y));
              if ((sx == 0) && (-1 < image_00->xoffset + x)) {
                x = x + image_00->xoffset;
              }
              else {
                sx = sx - image_00->xoffset;
              }
              if ((sy == 0) && (-1 < image_00->yoffset + y)) {
                y = y + image_00->yoffset;
              }
              else {
                sy = sy - image_00->yoffset;
              }
              if (image_00->width < 1) {
                w = (int)ROUND(pixel_per_char * 8.0 - (double)sx);
              }
              else {
                w = image_00->width - sx;
              }
              if (image_00->height < 1) {
                h = (int)ROUND(pixel_per_line - (double)sy);
              }
              else {
                h = image_00->height - sy;
              }
              if ((int)ROUND(pixel_per_char * (double)((int)buf->rootX + (int)buf->COLS) - (double)x
                            ) < w) {
                w = (int)ROUND(pixel_per_char * (double)((int)buf->rootX + (int)buf->COLS) -
                               (double)x);
              }
              if ((int)ROUND(pixel_per_line * (double)(LINES + -1) - (double)y) < h) {
                h = (int)ROUND(pixel_per_line * (double)(LINES + -1) - (double)y);
              }
              addImage(pIVar4,x,y,sx,sy,w,h);
              image_00->touch = image_touch;
              draw_image_flag = 1;
            }
          }
          rcol = calcPosition(l->lineBuf,l->propBuf,l->len,iVar2 + j + 1,0,0);
        }
      }
    }
  }
  return l;
}



int redrawLineRegion(Buffer *buf,Line *l,int i,int bpos,int epos)

{
  char *pcVar1;
  Lineprop *pLVar2;
  int iVar3;
  int iVar4;
  int pos_00;
  Anchor *pAVar5;
  ParsedURL *current;
  Str p_Var6;
  HistItem *pHVar7;
  size_t len;
  int iVar8;
  ParsedURL url;
  int vpos;
  int k;
  Anchor *a;
  int ecol;
  int bcol;
  Linecolor *pc;
  Lineprop *pr;
  char *p;
  int column;
  int delta;
  int ncol;
  int rcol;
  int pos;
  int j;
  
  iVar4 = buf->currentColumn;
  vpos = -1;
  if (l == (Line *)0x0) {
    iVar4 = 0;
  }
  else {
    pos_00 = columnPos(l,iVar4);
    pcVar1 = l->lineBuf;
    pLVar2 = l->propBuf;
    if ((useColor == 0) || (l->colorBuf == (Linecolor *)0x0)) {
      pc = (Linecolor *)0x0;
    }
    else {
      pc = l->colorBuf + pos_00;
    }
    rcol = calcPosition(l->lineBuf,l->propBuf,l->len,pos_00,0,0);
    for (j = 0; (rcol - iVar4 < (int)buf->COLS && (pos_00 + j < l->len)); j = j + len) {
      if ((useVisitedColor != 0) &&
         (((vpos <= pos_00 + j && ((pLVar2[pos_00 + j] & 0x4000) == 0)) &&
          (pAVar5 = retrieveAnchor(buf->href,l->linenumber,pos_00 + j), pAVar5 != (Anchor *)0x0))))
      {
        current = baseURL(buf);
        parseURL2(pAVar5->url,&url,current);
        p_Var6 = parsedURL2Str(&url);
        pHVar7 = getHashHist(URLHist,p_Var6->ptr);
        if (pHVar7 != (HistItem *)0x0) {
          for (k = (pAVar5->start).pos; k < (pAVar5->end).pos; k = k + 1) {
            pLVar2[k] = pLVar2[k] & 0xff | (ushort)(byte)((uint)pLVar2[k] >> 8) << 8 | 0x4000;
          }
        }
        vpos = (pAVar5->end).pos;
      }
      len = wtf_len((wc_uchar *)(pcVar1 + j + pos_00));
      iVar8 = calcPosition(l->lineBuf,l->propBuf,l->len,pos_00 + j + len,0,0);
      if ((int)buf->COLS < iVar8 - iVar4) break;
      if (pc != (Linecolor *)0x0) {
        do_color(pc[j]);
      }
      iVar3 = iVar8;
      if ((bpos - pos_00 <= j) && (j < epos - pos_00)) {
        if (rcol < iVar4) {
          move(i,(int)buf->rootX);
          for (rcol = iVar4; iVar3 = rcol, rcol < iVar8; rcol = rcol + 1) {
            addChar(' ',0);
          }
        }
        else {
          move(i,(rcol - iVar4) + (int)buf->rootX);
          if (pcVar1[j + pos_00] == '\t') {
            for (; rcol < iVar8; rcol = rcol + 1) {
              addChar(' ',0);
            }
          }
          else {
            addMChar(pcVar1 + j + pos_00,pLVar2[pos_00 + j],len);
          }
        }
      }
      rcol = iVar3;
    }
    if (somode != 0) {
      somode = 0;
      standend();
    }
    if (ulmode != 0) {
      ulmode = 0;
      underlineend();
    }
    if (bomode != 0) {
      bomode = 0;
      boldend();
    }
    if (emph_mode != 0) {
      emph_mode = 0;
      boldend();
    }
    if (anch_mode != 0) {
      anch_mode = 0;
      effect_anchor_end();
    }
    if (imag_mode != 0) {
      imag_mode = 0;
      effect_image_end();
    }
    if (form_mode != 0) {
      form_mode = 0;
      effect_form_end();
    }
    if (visited_mode != 0) {
      visited_mode = 0;
      effect_visited_end();
    }
    if (active_mode != 0) {
      active_mode = 0;
      effect_active_end();
    }
    if (mark_mode != 0) {
      mark_mode = 0;
      effect_mark_end();
    }
    if (graph_mode != 0) {
      graph_mode = 0;
      graphend();
    }
    if (color_mode != '\0') {
      do_color('\0');
    }
    iVar4 = rcol - iVar4;
  }
  return iVar4;
}



void do_effects(Lineprop m)

{
  if (ulmode != 0) {
    underlineend();
    ulmode = 0;
  }
  if (somode != 0) {
    standend();
    somode = 0;
  }
  if (bomode != 0) {
    boldend();
    bomode = 0;
  }
  if (emph_mode != 0) {
    boldend();
    emph_mode = 0;
  }
  if (anch_mode != 0) {
    effect_anchor_end();
    anch_mode = 0;
  }
  if (imag_mode != 0) {
    effect_image_end();
    imag_mode = 0;
  }
  if (form_mode != 0) {
    effect_form_end();
    form_mode = 0;
  }
  if (visited_mode != 0) {
    effect_visited_end();
    visited_mode = 0;
  }
  if (active_mode != 0) {
    effect_active_end();
    active_mode = 0;
  }
  if (mark_mode != 0) {
    effect_mark_end();
    mark_mode = 0;
  }
  if (graph_mode != 0) {
    graphend();
    graph_mode = 0;
  }
  if (((m & 2) != 0) && (ulmode == 0)) {
    underline();
    ulmode = 1;
  }
  if (((m & 4) != 0) && (somode == 0)) {
    standout();
    somode = 1;
  }
  if (((m & 8) != 0) && (bomode == 0)) {
    bold();
    bomode = 1;
  }
  if (((m & 8) != 0) && (emph_mode == 0)) {
    bold();
    emph_mode = 1;
  }
  if (((m & 0x10) != 0) && (anch_mode == 0)) {
    effect_anchor_start();
    anch_mode = 1;
  }
  if (((m & 0x20) != 0) && (imag_mode == 0)) {
    effect_image_start();
    imag_mode = 1;
  }
  if (((m & 0x40) != 0) && (form_mode == 0)) {
    effect_form_start();
    form_mode = 1;
  }
  if (((m & 0x4000) != 0) && (visited_mode == 0)) {
    effect_visited_start();
    visited_mode = 1;
  }
  if (((m & 0x80) != 0) && (active_mode == 0)) {
    effect_active_start();
    active_mode = 1;
  }
  if (((m & 1) != 0) && (mark_mode == 0)) {
    effect_mark_start();
    mark_mode = 1;
  }
  return;
}



void do_color(Linecolor c)

{
  if ((c & 8) == 0) {
    if ((color_mode & 8) != 0) {
      setfcolor(basic_color);
    }
  }
  else {
    setfcolor(c & 7);
  }
  if ((char)c < '\0') {
    setbcolor(c >> 4 & 7);
  }
  else if ((char)color_mode < '\0') {
    setbcolor(bg_color);
  }
  color_mode = c;
  return;
}



void addChar(char c,Lineprop mode)

{
  char local_10 [12];
  
  local_10[0] = c;
  addMChar(local_10,mode,1);
  return;
}



void addMChar(char *p,Lineprop mode,size_t len)

{
  wc_uint32 wVar1;
  int iVar2;
  char buf [5];
  int w;
  char **symbol;
  Lineprop m;
  char c;
  
  m = mode & 0xff | ((byte)((uint)mode >> 8) & 0xc0) << 8;
  c = *p;
  if ((mode & 0x400) == 0) {
    do_effects(m);
    if ((short)mode < 0) {
      if ((mode & 0x800) == 0) {
        w = 1;
      }
      else {
        w = 2;
      }
      wVar1 = wtf_get_code((wc_uchar *)p);
      c = ((byte)wVar1 & 0x7f) - 0x20;
      iVar2 = graph_ok();
      if ((iVar2 == 0) || ('\x1f' < c)) {
        symbol = get_symbol(DisplayCharset,&w);
        addstr(symbol[c]);
      }
      else {
        if (graph_mode == 0) {
          graphstart();
          graph_mode = 1;
        }
        if ((w == 2) && (WcOption.use_wide != '\0')) {
          addstr(graph2_symbol[c]);
        }
        else {
          addch(*graph_symbol[c]);
        }
      }
    }
    else if ((mode & 0x100) == 0) {
      if ((mode & 0x1000) == 0) {
        addmch(p,len);
      }
      else {
        wVar1 = wtf_get_code((wc_uchar *)p);
        sprintf(buf,"[%.2X]",(wVar1 | 0xffffff80) & 0xff);
        addstr(buf);
      }
    }
    else if (c == '\n') {
      addch(' ');
    }
    else {
      if (c < '\v') {
        if (c == '\t') {
          addch('\t');
          return;
        }
      }
      else {
        if (c == '\r') {
          return;
        }
        if (c == '\x7f') {
          addstr("^?");
          return;
        }
      }
      addch('^');
      addch(c + '@');
    }
  }
  return;
}



void record_err_message(char *s)

{
  char *s_00;
  
  if (fmInitialized != '\0') {
    if (message_list == (GeneralList *)0x0) {
      message_list = newGeneralList();
    }
    if (LINES <= message_list->nitem) {
      popValue(message_list);
    }
    s_00 = allocStr(s,-1);
    pushValue(message_list,s_00);
  }
  return;
}



Buffer * message_list_panel(void)

{
  Str x;
  char *pcVar1;
  Buffer *pBVar2;
  ListItem *p;
  Str tmp;
  
  x = Strnew_size(COLS * LINES);
  Strcat_charp(x,
               "<html><head><title>List of error messages</title></head><body><h1>List of error messages</h1><table cellpadding=0>\n"
              );
  if (message_list == (GeneralList *)0x0) {
    Strcat_charp(x,"<tr><td>(no message recorded)</td></tr>\n");
  }
  else {
    for (p = message_list->last; p != (ListItem *)0x0; p = p->prev) {
      pcVar1 = html_quote((char *)p->ptr);
      Strcat_m_charp(x,"<tr><td><pre>",pcVar1,"</pre></td></tr>\n",0);
    }
  }
  Strcat_charp(x,"</table></body></html>");
  pBVar2 = loadHTMLString(x);
  return pBVar2;
}



void message(char *s,int return_x,int return_y)

{
  if (fmInitialized != '\0') {
    move(LINES + -1,0);
    addnstr(s,COLS + -1);
    clrtoeolx();
    move(return_y,return_x);
  }
  return;
}



void disp_err_message(char *s,int redraw_current)

{
  record_err_message(s);
  disp_message(s,redraw_current);
  return;
}



void disp_message_nsec(char *s,int redraw_current,int sec,int purge,int mouse)

{
  wc_ces f_ces;
  wc_ces t_ces;
  Str p_Var1;
  
  t_ces = SystemCharset;
  f_ces = InnerCharset;
  if (QuietMessage == '\0') {
    if (fmInitialized == '\0') {
      p_Var1 = Strnew_charp(s);
      p_Var1 = wc_Str_conv_strict(p_Var1,f_ces,t_ces);
      fprintf(stderr,"%s\n",p_Var1->ptr);
    }
    else {
      if ((CurrentTab == (TabBuffer *)0x0) || (CurrentTab->currentBuffer == (Buffer *)0x0)) {
        message(s,LINES + -1,0);
      }
      else {
        message(s,(int)CurrentTab->currentBuffer->cursorX + (int)CurrentTab->currentBuffer->rootX,
                (int)CurrentTab->currentBuffer->cursorY + (int)CurrentTab->currentBuffer->rootY);
      }
      refresh();
      if ((mouse != 0) && (use_mouse != 0)) {
        mouse_active();
      }
      sleep_till_anykey(sec,purge);
      if ((mouse != 0) && (use_mouse != 0)) {
        mouse_inactive();
      }
      if (((CurrentTab != (TabBuffer *)0x0) && (CurrentTab->currentBuffer != (Buffer *)0x0)) &&
         (redraw_current != 0)) {
        displayBuffer(CurrentTab->currentBuffer,0);
      }
    }
  }
  return;
}



void disp_message(char *s,int redraw_current)

{
  disp_message_nsec(s,redraw_current,10,0,1);
  return;
}



void disp_message_nomouse(char *s,int redraw_current)

{
  disp_message_nsec(s,redraw_current,10,0,0);
  return;
}



void set_delayed_message(char *s)

{
  delayed_msg = allocStr(s,-1);
  return;
}



void cursorUp0(Buffer *buf,int n)

{
  Line *pLVar1;
  
  if (buf->cursorY < 1) {
    pLVar1 = lineSkip(buf,buf->topLine,-n,0);
    buf->topLine = pLVar1;
    if (buf->currentLine->prev != (_Line *)0x0) {
      buf->currentLine = buf->currentLine->prev;
    }
    arrangeLine(buf);
  }
  else {
    cursorUpDown(buf,-1);
  }
  return;
}



void cursorUp(Buffer *buf,int n)

{
  Line *pLVar1;
  Line *l;
  
  pLVar1 = buf->currentLine;
  if (buf->firstLine != (Line *)0x0) {
    while ((buf->currentLine->prev != (_Line *)0x0 && (buf->currentLine->bpos != 0))) {
      cursorUp0(buf,n);
    }
    if (buf->currentLine == buf->firstLine) {
      gotoLine(buf,pLVar1->linenumber);
      arrangeLine(buf);
    }
    else {
      cursorUp0(buf,n);
      while (((buf->currentLine->prev != (_Line *)0x0 && (buf->currentLine->bpos != 0)) &&
             (buf->currentColumn + buf->visualpos <= buf->currentLine->bwidth))) {
        cursorUp0(buf,n);
      }
    }
  }
  return;
}



void cursorDown0(Buffer *buf,int n)

{
  Line *pLVar1;
  
  if ((int)buf->cursorY < buf->LINES + -1) {
    cursorUpDown(buf,1);
  }
  else {
    pLVar1 = lineSkip(buf,buf->topLine,n,0);
    buf->topLine = pLVar1;
    if (buf->currentLine->next != (_Line *)0x0) {
      buf->currentLine = buf->currentLine->next;
    }
    arrangeLine(buf);
  }
  return;
}



void cursorDown(Buffer *buf,int n)

{
  Line *pLVar1;
  Line *l;
  
  pLVar1 = buf->currentLine;
  if (buf->firstLine != (Line *)0x0) {
    while ((buf->currentLine->next != (_Line *)0x0 && (buf->currentLine->next->bpos != 0))) {
      cursorDown0(buf,n);
    }
    if (buf->currentLine == buf->lastLine) {
      gotoLine(buf,pLVar1->linenumber);
      arrangeLine(buf);
    }
    else {
      cursorDown0(buf,n);
      while (((buf->currentLine->next != (_Line *)0x0 && (buf->currentLine->next->bpos != 0)) &&
             (buf->currentLine->bwidth + buf->currentLine->width <
              buf->currentColumn + buf->visualpos))) {
        cursorDown0(buf,n);
      }
    }
  }
  return;
}



void cursorUpDown(Buffer *buf,int n)

{
  Line *line;
  Line *pLVar1;
  Line *cl;
  
  line = buf->currentLine;
  if (buf->firstLine != (Line *)0x0) {
    pLVar1 = currentLineSkip(buf,line,n,0);
    buf->currentLine = pLVar1;
    if (buf->currentLine != line) {
      arrangeLine(buf);
    }
  }
  return;
}



void cursorRight(Buffer *buf,int n)

{
  Line *pLVar1;
  Lineprop *pLVar2;
  int iVar3;
  int iVar4;
  Lineprop *p;
  Line *l;
  int vpos2;
  int cpos;
  int delta;
  int i;
  
  delta = 1;
  pLVar1 = buf->currentLine;
  if ((buf->firstLine != (Line *)0x0) &&
     ((buf->pos != pLVar1->len || ((pLVar1->next != (_Line *)0x0 && (pLVar1->next->bpos != 0)))))) {
    iVar3 = buf->pos;
    pLVar2 = pLVar1->propBuf;
    while ((iVar3 + delta < pLVar1->len && ((pLVar2[iVar3 + delta] & 0x400) != 0))) {
      delta = delta + 1;
    }
    if (iVar3 + delta < pLVar1->len) {
      buf->pos = iVar3 + delta;
    }
    else if (pLVar1->len == 0) {
      buf->pos = 0;
    }
    else {
      if ((pLVar1->next != (_Line *)0x0) && (pLVar1->next->bpos != 0)) {
        cursorDown0(buf,1);
        buf->pos = 0;
        arrangeCursor(buf);
        return;
      }
      buf->pos = pLVar1->len + -1;
      while ((buf->pos != 0 && ((pLVar2[buf->pos] & 0x400) != 0))) {
        buf->pos = buf->pos + -1;
      }
    }
    iVar3 = calcPosition(pLVar1->lineBuf,pLVar1->propBuf,pLVar1->len,buf->pos,0,0);
    buf->visualpos = pLVar1->bwidth + (iVar3 - buf->currentColumn);
    delta = 1;
    while ((buf->pos + delta < pLVar1->len && ((pLVar2[buf->pos + delta] & 0x400) != 0))) {
      delta = delta + 1;
    }
    iVar4 = calcPosition(pLVar1->lineBuf,pLVar1->propBuf,pLVar1->len,buf->pos + delta,0,0);
    iVar4 = (iVar4 - buf->currentColumn) + -1;
    if ((buf->COLS <= iVar4) && (n != 0)) {
      columnSkip(buf,((iVar4 - buf->COLS) + n) - (iVar4 - buf->COLS) % n);
      buf->visualpos = pLVar1->bwidth + (iVar3 - buf->currentColumn);
    }
    buf->cursorX = (short)buf->visualpos - (short)pLVar1->bwidth;
  }
  return;
}



void cursorLeft(Buffer *buf,int n)

{
  Line *pLVar1;
  int iVar2;
  Lineprop *p;
  Line *l;
  int cpos;
  int delta;
  int i;
  
  delta = 1;
  pLVar1 = buf->currentLine;
  if (buf->firstLine != (Line *)0x0) {
    iVar2 = buf->pos;
    while ((iVar2 != delta && -1 < iVar2 - delta && ((pLVar1->propBuf[iVar2 - delta] & 0x400) != 0))
          ) {
      delta = delta + 1;
    }
    if (iVar2 < delta) {
      if ((pLVar1->prev != (_Line *)0x0) && (pLVar1->bpos != 0)) {
        cursorUp0(buf,-1);
        buf->pos = buf->currentLine->len + -1;
        arrangeCursor(buf);
        return;
      }
      buf->pos = 0;
    }
    else {
      buf->pos = iVar2 - delta;
    }
    iVar2 = calcPosition(pLVar1->lineBuf,pLVar1->propBuf,pLVar1->len,buf->pos,0,0);
    buf->visualpos = pLVar1->bwidth + (iVar2 - buf->currentColumn);
    if ((buf->visualpos - pLVar1->bwidth < 0) && (n != 0)) {
      columnSkip(buf,((buf->visualpos - n) - pLVar1->bwidth) - (buf->visualpos - pLVar1->bwidth) % n
                );
      buf->visualpos = pLVar1->bwidth + (iVar2 - buf->currentColumn);
    }
    buf->cursorX = (short)buf->visualpos - (short)pLVar1->bwidth;
  }
  return;
}



void cursorHome(Buffer *buf)

{
  buf->visualpos = 0;
  buf->cursorY = 0;
  buf->cursorX = buf->cursorY;
  return;
}



void arrangeCursor(Buffer *buf)

{
  Line *pLVar1;
  int iVar2;
  int iVar3;
  int delta;
  int pos;
  int col2;
  int col;
  
  delta = 1;
  if ((buf != (Buffer *)0x0) && (buf->currentLine != (Line *)0x0)) {
    if (((int)buf->LINES <= buf->currentLine->linenumber - buf->topLine->linenumber) ||
       (buf->currentLine->linenumber < buf->topLine->linenumber)) {
      pLVar1 = lineSkip(buf,buf->currentLine,0,0);
      buf->topLine = pLVar1;
    }
    while (((buf->pos < 0 && (buf->currentLine->prev != (_Line *)0x0)) &&
           (buf->currentLine->bpos != 0))) {
      iVar2 = buf->pos;
      iVar3 = buf->currentLine->prev->len;
      cursorUp0(buf,1);
      buf->pos = iVar2 + iVar3;
    }
    while (((buf->currentLine->len <= buf->pos && (buf->currentLine->next != (_Line *)0x0)) &&
           (buf->currentLine->next->bpos != 0))) {
      iVar2 = buf->pos;
      iVar3 = buf->currentLine->len;
      cursorDown0(buf,1);
      buf->pos = iVar2 - iVar3;
    }
    if ((buf->currentLine->len == 0) || (buf->pos < 0)) {
      buf->pos = 0;
    }
    else if (buf->currentLine->len <= buf->pos) {
      buf->pos = buf->currentLine->len + -1;
    }
    while ((0 < buf->pos && ((buf->currentLine->propBuf[buf->pos] & 0x400) != 0))) {
      buf->pos = buf->pos + -1;
    }
    iVar2 = calcPosition(buf->currentLine->lineBuf,buf->currentLine->propBuf,buf->currentLine->len,
                         buf->pos,0,0);
    while ((buf->pos + delta < buf->currentLine->len &&
           ((buf->currentLine->propBuf[buf->pos + delta] & 0x400) != 0))) {
      delta = delta + 1;
    }
    iVar3 = calcPosition(buf->currentLine->lineBuf,buf->currentLine->propBuf,buf->currentLine->len,
                         buf->pos + delta,0,0);
    if (((iVar2 < buf->currentColumn) || ((int)buf->COLS + buf->currentColumn < iVar3)) &&
       (buf->currentColumn = 0, buf->COLS < iVar3)) {
      columnSkip(buf,iVar2);
    }
    buf->cursorY = (short)buf->currentLine->linenumber - (short)buf->topLine->linenumber;
    iVar2 = buf->currentLine->bwidth;
    iVar3 = calcPosition(buf->currentLine->lineBuf,buf->currentLine->propBuf,buf->currentLine->len,
                         buf->pos,0,0);
    buf->visualpos = (iVar2 + iVar3) - buf->currentColumn;
    buf->cursorX = (short)buf->visualpos - (short)buf->currentLine->bwidth;
  }
  return;
}



void arrangeLine(Buffer *buf)

{
  int pos;
  int iVar1;
  int cpos;
  int i;
  
  if (buf->firstLine != (Line *)0x0) {
    buf->cursorY = (short)buf->currentLine->linenumber - (short)buf->topLine->linenumber;
    pos = columnPos(buf->currentLine,
                    (buf->currentColumn + buf->visualpos) - buf->currentLine->bwidth);
    iVar1 = calcPosition(buf->currentLine->lineBuf,buf->currentLine->propBuf,buf->currentLine->len,
                         pos,0,0);
    iVar1 = iVar1 - buf->currentColumn;
    if (iVar1 < 0) {
      if (pos < buf->currentLine->len) {
        buf->cursorX = 0;
        buf->pos = pos + 1;
      }
      else {
        buf->cursorX = 0;
        buf->pos = 0;
      }
    }
    else {
      buf->cursorX = (short)iVar1;
      buf->pos = pos;
    }
  }
  return;
}



void cursorXY(Buffer *buf,int x,int y)

{
  short sVar1;
  int oldX;
  
  cursorUpDown(buf,y - buf->cursorY);
  if (x < buf->cursorX) {
    while (x < buf->cursorX) {
      cursorLeft(buf,(int)(buf->COLS / 2));
    }
  }
  else if (buf->cursorX < x) {
    do {
      if (x <= buf->cursorX) break;
      sVar1 = buf->cursorX;
      cursorRight(buf,(int)(buf->COLS / 2));
    } while (buf->cursorX != sVar1);
    if (x < buf->cursorX) {
      cursorLeft(buf,(int)(buf->COLS / 2));
    }
  }
  return;
}



void restorePosition(Buffer *buf,Buffer *orig)

{
  int iVar1;
  Line *pLVar2;
  
  if (orig->topLine == (Line *)0x0) {
    iVar1 = 0;
  }
  else {
    iVar1 = orig->topLine->linenumber + -1;
  }
  pLVar2 = lineSkip(buf,buf->firstLine,iVar1,0);
  buf->topLine = pLVar2;
  if (orig->currentLine == (Line *)0x0) {
    iVar1 = 1;
  }
  else {
    iVar1 = orig->currentLine->linenumber;
  }
  gotoLine(buf,iVar1);
  buf->pos = orig->pos;
  if ((buf->currentLine != (Line *)0x0) && (orig->currentLine != (Line *)0x0)) {
    buf->pos = buf->pos + (orig->currentLine->bpos - buf->currentLine->bpos);
  }
  buf->currentColumn = orig->currentColumn;
  arrangeCursor(buf);
  return;
}



int columnSkip(Buffer *buf,int offset)

{
  short sVar1;
  int iVar2;
  int iVar3;
  bool bVar4;
  Line *l;
  int nlines;
  int column;
  int maxColumn;
  int i;
  
  iVar2 = buf->currentColumn + offset;
  sVar1 = buf->LINES;
  maxColumn = 0;
  i = 0;
  for (l = buf->topLine; (i < sVar1 + 1 && (l != (Line *)0x0)); l = l->next) {
    if (l->width < 0) {
      iVar3 = calcPosition(l->lineBuf,l->propBuf,l->len,l->len,0,0);
      l->width = iVar3;
    }
    if (maxColumn < l->width + -1) {
      maxColumn = l->width + -1;
    }
    i = i + 1;
  }
  maxColumn = maxColumn + (1 - buf->COLS);
  if (iVar2 < maxColumn) {
    maxColumn = iVar2;
  }
  if (maxColumn < 0) {
    maxColumn = 0;
  }
  bVar4 = buf->currentColumn != maxColumn;
  if (bVar4) {
    buf->currentColumn = maxColumn;
  }
  return (uint)bVar4;
}



int columnPos(Line *line,int column)

{
  int iVar1;
  int i;
  
  i = 1;
  while ((i < line->len &&
         (iVar1 = calcPosition(line->lineBuf,line->propBuf,line->len,i,0,0), iVar1 <= column))) {
    i = i + 1;
  }
  do {
    i = i + -1;
    if (i < 1) {
      return i;
    }
  } while ((line->propBuf[i] & 0x400) != 0);
  return i;
}



Line * lineSkip(Buffer *buf,Line *line,int offset,int last)

{
  Line *l;
  int i;
  
  l = currentLineSkip(buf,line,offset,last);
  if (nextpage_topline == 0) {
    i = buf->LINES + -1 + (l->linenumber - buf->lastLine->linenumber);
    for (; (0 < i && (l->prev != (_Line *)0x0)); l = l->prev) {
      i = i + -1;
    }
  }
  return l;
}



Line * currentLineSkip(Buffer *buf,Line *line,int offset,int last)

{
  int iVar1;
  Line *pLVar2;
  Line *l;
  int n;
  int i;
  
  l = line;
  if ((buf->pagerSource != (InputStream)0x0) && ((buf->bufferprop & 0x40U) == 0)) {
    iVar1 = line->linenumber + offset + (int)buf->LINES;
    if (buf->lastLine->linenumber < iVar1) {
      getNextPage(buf,iVar1 - buf->lastLine->linenumber);
    }
    do {
      if ((last == 0) && (iVar1 <= buf->lastLine->linenumber)) break;
      pLVar2 = getNextPage(buf,1);
    } while (pLVar2 != (Line *)0x0);
    if (last != 0) {
      l = buf->lastLine;
    }
  }
  if (offset != 0) {
    if (offset < 1) {
      i = 0;
      for (; (-i != offset && i <= -offset && (l->prev != (_Line *)0x0)); l = l->prev) {
        i = i + 1;
      }
    }
    else {
      i = 0;
      for (; (i < offset && (l->next != (_Line *)0x0)); l = l->next) {
        i = i + 1;
      }
    }
  }
  return l;
}



// WARNING: Heritage AFTER dead removal. Example location: s0xffffff70 : 0x080784e3
// WARNING: Restarted to delay deadcode elimination for space: stack

int gethtmlcmd(char **s)

{
  char *pcVar1;
  byte bVar2;
  byte bVar3;
  int iVar4;
  int in_GS_OFFSET;
  int cmd;
  char *save;
  char *p;
  char cmdstr [128];
  int local_10;
  
  local_10 = *(int *)(in_GS_OFFSET + 0x14);
  pcVar1 = *s;
  *s = *s + 1;
  if ((((MYCTYPE_MAP[(byte)**s] & 0xc) == 0) && (**s != '_')) && (**s != '/')) {
    iVar4 = 0;
  }
  else {
    if ((MYCTYPE_MAP[(byte)**s] & 4) == 0) {
      bVar2 = **s;
    }
    else {
      bVar2 = **s | 0x20;
    }
    p = cmdstr + 1;
    *s = *s + 1;
    if (cmdstr[0] == '/') {
      while ((**s != '\0' && ((MYCTYPE_MAP[(byte)**s] & 2) != 0))) {
        *s = *s + 1;
      }
    }
    while ((((MYCTYPE_MAP[(byte)**s] & 0xc) != 0 || (**s == '_')) && ((int)p - (int)cmdstr < 0x80)))
    {
      if ((MYCTYPE_MAP[(byte)**s] & 4) == 0) {
        bVar3 = **s;
      }
      else {
        bVar3 = **s | 0x20;
      }
      *p = bVar3;
      p = p + 1;
      *s = *s + 1;
    }
    cmdstr[0] = bVar2;
    if ((int)p - (int)cmdstr == 0x80) {
      *s = pcVar1 + 1;
      iVar4 = 0;
    }
    else {
      *p = '\0';
      iVar4 = getHash_si(&tagtable,cmdstr,0);
      while ((**s != '\0' && (**s != '>'))) {
        *s = *s + 1;
      }
      if (**s == '>') {
        *s = *s + 1;
      }
    }
  }
  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {
    return iVar4;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int parse_ansi_color(char **str,Lineprop *effect,Linecolor *color)

{
  char *pcVar1;
  int iVar2;
  char *pcVar3;
  int i;
  char *q;
  char *p;
  Lineprop e;
  Linecolor c;
  
  pcVar3 = *str;
  e = *effect;
  c = *color;
  if ((*pcVar3 == '\x1b') && (pcVar3[1] == '[')) {
    p = pcVar3 + 2;
    for (q = p; ((MYCTYPE_MAP[(byte)*q] & 8) != 0 || (*q == ';')); q = q + 1) {
    }
    if (*q == 'm') {
      *str = q + 1;
      while (pcVar3 = p, *p != 'm') {
        if ((MYCTYPE_MAP[(byte)*p] & 8) == 0) {
          e = 0;
          c = '\0';
          goto LAB_080788ab;
        }
        do {
          pcVar1 = p;
          p = pcVar1 + 1;
        } while ((MYCTYPE_MAP[(byte)*p] & 8) != 0);
        pcVar3 = allocStr(pcVar3,(int)p - (int)pcVar3);
        iVar2 = atoi(pcVar3);
        if (iVar2 == 5) {
LAB_08078815:
          e = 8;
        }
        else if (iVar2 < 6) {
          if (iVar2 == 1) goto LAB_08078815;
          if (iVar2 == 4) {
            e = 2;
          }
          else {
            if (iVar2 != 0) goto LAB_0807883f;
            e = 0;
            c = '\0';
          }
        }
        else if (iVar2 == 0x27) {
          c = c & 0xf0;
        }
        else if (iVar2 < 0x28) {
          if (iVar2 == 7) {
            e = 4;
          }
          else {
LAB_0807883f:
            if ((iVar2 < 0x1e) || (0x25 < iVar2)) {
              if ((0x27 < iVar2) && (iVar2 < 0x30)) {
                c = ((char)iVar2 + -0x28) * '\x10' | c & 0xf | 0x80;
              }
            }
            else {
              c = (char)iVar2 - 0x1eU | c & 0xf0 | 8;
            }
          }
        }
        else if (iVar2 == 0x31) {
          c = c & 0xf;
        }
        else {
          if (iVar2 != 100) goto LAB_0807883f;
          c = '\0';
        }
        if (*p == 'm') goto LAB_080788ab;
        p = pcVar1 + 2;
      }
      e = 0;
      c = '\0';
LAB_080788ab:
      *effect = e;
      *color = c;
      iVar2 = 1;
    }
    else {
      iVar2 = 0;
    }
  }
  else {
    iVar2 = 0;
  }
  return iVar2;
}



Str checkType(Str s,Lineprop **oprop,Linecolor **ocolor)

{
  char *pcVar1;
  byte bVar2;
  bool bVar3;
  bool bVar4;
  char *y;
  Lineprop LVar5;
  int iVar6;
  Linecolor *pLVar7;
  int ok;
  char *ep;
  char *sp;
  int clen;
  int plen;
  int i;
  int do_copy;
  char *es;
  Linecolor *color;
  int check_color;
  char *bs;
  char *endp;
  char *str;
  Lineprop *prop;
  Lineprop ceffect;
  Lineprop effect;
  Lineprop mode;
  Linecolor cmode;
  
  effect = 0;
  str = s->ptr;
  pcVar1 = s->ptr + s->length;
  bs = (char *)0x0;
  ceffect = 0;
  cmode = '\0';
  bVar4 = false;
  color = (Linecolor *)0x0;
  es = (char *)0x0;
  bVar3 = false;
  plen = 0;
  if (checkType::prop_size < s->length) {
    checkType::prop_size = s->length;
    if (checkType::prop_size < 0x100) {
      checkType::prop_size = 0x100;
    }
    checkType::prop_buffer = (Lineprop *)GC_realloc(checkType::prop_buffer,checkType::prop_size * 2)
    ;
  }
  prop = checkType::prop_buffer;
  if (ShowEffect != 0) {
    bs = (char *)memchr(str,8,s->length);
    if ((ocolor != (Linecolor **)0x0) &&
       (es = (char *)memchr(str,0x1b,s->length), es != (char *)0x0)) {
      if (checkType::color_size < s->length) {
        checkType::color_size = s->length;
        if (checkType::color_size < 0x100) {
          checkType::color_size = 0x100;
        }
        checkType::color_buffer =
             (Linecolor *)GC_realloc(checkType::color_buffer,checkType::color_size);
      }
      color = checkType::color_buffer;
    }
    y = str;
    if ((bs != (char *)0x0) || (es != (char *)0x0)) {
      s = Strnew_size(s->length);
      bVar3 = true;
      ep = pcVar1;
      if (bs != (char *)0x0) {
        ep = bs + -2;
      }
      if ((es != (char *)0x0) && (es + -2 < ep)) {
        ep = es + -2;
      }
      while ((str < ep && ((MYCTYPE_MAP[(byte)*str] & 0x11) != 0))) {
        if ((MYCTYPE_MAP[(byte)*str] & 1) == 0) {
          LVar5 = 0;
        }
        else {
          LVar5 = 0x100;
        }
        *prop = LVar5;
        prop = prop + 1;
        if (color != (Linecolor *)0x0) {
          *color = '\0';
          color = color + 1;
        }
        str = str + 1;
      }
      Strcat_charp_n(s,y,(int)str - (int)y);
    }
  }
  if (!bVar3) {
    while ((str < pcVar1 && ((MYCTYPE_MAP[(byte)*str] & 0x11) != 0))) {
      if ((MYCTYPE_MAP[(byte)*str] & 1) == 0) {
        LVar5 = 0;
      }
      else {
        LVar5 = 0x100;
      }
      *prop = LVar5;
      prop = prop + 1;
      str = str + 1;
    }
  }
LAB_08079182:
  while( true ) {
    if ((pcVar1 <= str) || (checkType::prop_size <= (int)prop - (int)checkType::prop_buffer >> 1)) {
      *oprop = checkType::prop_buffer;
      if (ocolor != (Linecolor **)0x0) {
        pLVar7 = checkType::color_buffer;
        if (!bVar4) {
          pLVar7 = (Linecolor *)0x0;
        }
        *ocolor = pLVar7;
      }
      return s;
    }
    if (bs == (char *)0x0) break;
    if ((bs + -2 == str) && (iVar6 = strncmp(str,"__\b\b",4), iVar6 == 0)) {
      str = str + 4;
      effect = 2;
      if (str < pcVar1) {
        bs = (char *)memchr(str,8,(int)pcVar1 - (int)str);
      }
    }
    else if ((bs + -1 == str) && (*str == '_')) {
      str = str + 2;
      effect = 2;
      if (str < pcVar1) {
        bs = (char *)memchr(str,8,(int)pcVar1 - (int)str);
      }
    }
    else {
      if (str != bs) {
        if (bs < str) {
          bs = (char *)memchr(str,8,(int)pcVar1 - (int)str);
        }
        break;
      }
      if (str[1] == '_') {
        if (s->length == 0) {
          str = str + 1;
        }
        else {
          str = str + 2;
          for (i = 1; i <= plen; i = i + 1) {
            prop[-i] = prop[-i] | 2;
          }
        }
      }
      else {
        iVar6 = strncmp(str + 1,"\b__",3);
        if (iVar6 == 0) {
          if (s->length == 0) {
            str = str + 2;
          }
          else {
            if (plen == 1) {
              iVar6 = 3;
            }
            else {
              iVar6 = 4;
            }
            str = str + iVar6;
            for (i = 1; i <= plen; i = i + 1) {
              prop[-i] = prop[-i] | 2;
            }
          }
        }
        else if (str[1] == '\b') {
          if (s->length == 0) {
            str = str + 2;
          }
          else {
            bVar2 = WTF_LEN_MAP[(byte)str[2]];
            if ((plen == (uint)bVar2) && (iVar6 = strncmp(str + -plen,str + 2,plen), iVar6 == 0)) {
              for (i = 1; i <= plen; i = i + 1) {
                prop[-i] = prop[-i] | 8;
              }
              str = str + bVar2 + 2;
            }
            else {
              Strshrink(s,plen);
              prop = prop + -plen;
              str = str + 2;
            }
          }
        }
        else if (s->length == 0) {
          str = str + 1;
        }
        else {
          bVar2 = WTF_LEN_MAP[(byte)str[1]];
          if ((plen == (uint)bVar2) && (iVar6 = strncmp(str + -plen,str + 1,plen), iVar6 == 0)) {
            for (i = 1; i <= plen; i = i + 1) {
              prop[-i] = prop[-i] | 8;
            }
            str = str + bVar2 + 1;
          }
          else {
            Strshrink(s,plen);
            prop = prop + -plen;
            str = str + 1;
          }
        }
      }
      if (str < pcVar1) {
        bs = (char *)memchr(str,8,(int)pcVar1 - (int)str);
      }
    }
  }
  if (es != (char *)0x0) {
    if (str == es) {
      iVar6 = parse_ansi_color(&str,&ceffect,&cmode);
      if (str < pcVar1) {
        es = (char *)memchr(str,0x1b,(int)pcVar1 - (int)str);
      }
      if (iVar6 != 0) {
        if (cmode != '\0') {
          bVar4 = true;
        }
        goto LAB_08079182;
      }
    }
    else if (es < str) {
      es = (char *)memchr(str,0x1b,(int)pcVar1 - (int)str);
    }
  }
  plen = (int)WTF_LEN_MAP[(byte)*str];
  mode = effect | (ushort)WTF_TYPE_MAP[(byte)*str] << 8;
  if (color != (Linecolor *)0x0) {
    *color = cmode;
    color = color + 1;
    mode = mode | ceffect;
  }
  *prop = mode;
  prop = prop + 1;
  if ((uint)plen < 2) {
    if (bVar3) {
      if (s->area_size <= s->length + 1) {
        Strgrow(s);
      }
      iVar6 = s->length;
      s->ptr[iVar6] = *str;
      s->length = iVar6 + 1;
      s->ptr[s->length] = '\0';
    }
    str = str + 1;
  }
  else {
    mode = mode & 0xff | (ushort)((byte)((uint)mode >> 8) & 0xf9) << 8 | 0x400;
    for (i = 1; i < plen; i = i + 1) {
      *prop = mode;
      prop = prop + 1;
      if (color != (Linecolor *)0x0) {
        *color = cmode;
        color = color + 1;
      }
    }
    if (bVar3) {
      Strcat_charp_n(s,str,plen);
    }
    str = str + plen;
  }
  effect = 0;
  goto LAB_08079182;
}



int nextColumn(int n,char *p,Lineprop *pr)

{
  byte bVar1;
  
  if ((*pr & 0x100) == 0) {
    if ((*pr & 0x1000) == 0) {
      if (WcOption.use_wide == '\0') {
        bVar1 = WTF_WIDTH_MAP[(byte)*p] != '\0';
      }
      else {
        bVar1 = WTF_WIDTH_MAP[(byte)*p];
      }
      n = (uint)bVar1 + n;
    }
    else {
      n = n + 4;
    }
  }
  else if (*p == '\t') {
    n = Tabstop * ((Tabstop + n) / Tabstop);
  }
  else if (*p == '\n') {
    n = n + 1;
  }
  else if (*p != '\r') {
    n = n + 2;
  }
  return n;
}



int calcPosition(char *l,Lineprop *pr,int len,int pos,int bpos,int mode)

{
  int iVar1;
  int j;
  int i;
  
  if ((l != (char *)0x0) && (len != 0)) {
    if ((l == calcPosition::prevl) && ((mode == 0 && (pos <= len)))) {
      bpos = calcPosition::realColumn[pos];
    }
    else {
      if (calcPosition::size < len + 1) {
        calcPosition::size = len + 1;
        if (calcPosition::size < 0x100) {
          calcPosition::size = 0x100;
        }
        calcPosition::realColumn = (int *)GC_malloc(calcPosition::size << 2);
      }
      calcPosition::prevl = l;
      i = 0;
      j = bpos;
      if ((*pr & 0x400) != 0) {
        for (; (i < len && ((pr[i] & 0x400) != 0)); i = i + 1) {
          calcPosition::realColumn[i] = bpos;
        }
        if (((0 < i) && ((pr[i + -1] & 0x800) != 0)) && (WcOption.use_wide != '\0')) {
          j = bpos + 1;
        }
      }
      while (calcPosition::realColumn[i] = j, i != len) {
        j = nextColumn(j,l + i,pr + i);
        iVar1 = i;
        while ((i = iVar1 + 1, i < len && ((pr[i] & 0x400) != 0))) {
          calcPosition::realColumn[i] = calcPosition::realColumn[iVar1];
          iVar1 = i;
        }
      }
      bpos = j;
      if (pos < i) {
        bpos = calcPosition::realColumn[pos];
      }
    }
  }
  return bpos;
}



int columnLen(Line *line,int column)

{
  int j;
  int i;
  
  i = 0;
  j = 0;
  do {
    if (line->len <= i) {
      return line->len;
    }
    j = nextColumn(j,line->lineBuf + i,line->propBuf + i);
    if (column < j) {
      return i;
    }
    do {
      i = i + 1;
      if (line->len <= i) break;
    } while ((line->propBuf[i] & 0x400) != 0);
  } while( true );
}



char * lastFileName(char *path)

{
  char *pcVar1;
  char *q;
  char *p;
  
  q = path;
  for (p = path; *p != '\0'; p = p + 1) {
    if (*p == '/') {
      q = p + 1;
    }
  }
  pcVar1 = allocStr(q,-1);
  return pcVar1;
}



char * mybasename(char *s)

{
  char *pcVar1;
  char *p;
  
  for (p = s; *p != '\0'; p = p + 1) {
  }
  for (; (s <= p && (*p != '/')); p = p + -1) {
  }
  if (*p == '/') {
    p = p + 1;
  }
  else {
    p = s;
  }
  pcVar1 = allocStr(p,-1);
  return pcVar1;
}



char * mydirname(char *s)

{
  char *pcVar1;
  size_t sVar2;
  size_t sVar3;
  char *p;
  
  for (p = s; *p != '\0'; p = p + 1) {
  }
  if (s != p) {
    p = p + -1;
  }
  for (; (s != p && (*p == '/')); p = p + -1) {
  }
  for (; (s != p && (*p != '/')); p = p + -1) {
  }
  if (*p == '/') {
    for (; (s != p && (*p == '/')); p = p + -1) {
    }
    sVar2 = strlen(s);
    sVar3 = strlen(p);
    pcVar1 = allocStr(s,(sVar2 - sVar3) + 1);
  }
  else {
    pcVar1 = ".";
  }
  return pcVar1;
}



int next_status(char c,int *status)

{
  int iVar1;
  
  switch(*status) {
  case 0:
    if (c == '<') {
      *status = 1;
      iVar1 = 0;
    }
    else if (c == '&') {
      *status = 6;
      iVar1 = 1;
    }
    else {
      iVar1 = 1;
    }
    break;
  case 1:
    if (c == '!') {
      *status = 8;
      return 0;
    }
    *status = 2;
  case 2:
    if (c == '>') {
      *status = 0;
    }
    else if (c == '=') {
      *status = 5;
    }
    iVar1 = 0;
    break;
  case 3:
    if (c == '\'') {
      *status = 2;
    }
    iVar1 = 0;
    break;
  case 4:
    if (c == '\"') {
      *status = 2;
    }
    iVar1 = 0;
    break;
  case 5:
    if (c == '\"') {
      *status = 4;
    }
    else if (c == '\'') {
      *status = 3;
    }
    else if ((MYCTYPE_MAP[(byte)c] & 2) == 0) {
      if (c == '>') {
        *status = 0;
      }
      else {
        *status = 0xf;
      }
    }
    else {
      *status = 5;
    }
    iVar1 = 0;
    break;
  case 6:
    if (c == ';') {
      *status = 0;
      iVar1 = 0;
    }
    else if (((c == '#') || ((MYCTYPE_MAP[(byte)c] & 0xc) != 0)) || (c == '_')) {
      iVar1 = 0;
    }
    else {
      *status = 0;
      iVar1 = 0;
    }
    break;
  case 8:
    if (c == '-') {
      *status = 9;
    }
    else if (c == '>') {
      *status = 0;
    }
    else {
      *status = 0xe;
    }
    iVar1 = 0;
    break;
  case 9:
    if (c == '-') {
      *status = 10;
    }
    else if (c == '>') {
      *status = 0;
    }
    else {
      *status = 0xe;
    }
    iVar1 = 0;
    break;
  case 10:
    if (c == '-') {
      *status = 0xb;
    }
    iVar1 = 0;
    break;
  case 0xb:
    if (c == '-') {
      *status = 0xc;
    }
    else {
      *status = 10;
    }
    iVar1 = 0;
    break;
  case 0xc:
    if (c == '-') {
      *status = 0xc;
    }
    else if (c == '>') {
      *status = 0;
    }
    else if ((MYCTYPE_MAP[(byte)c] & 2) == 0) {
      *status = 10;
    }
    else {
      *status = 0xd;
    }
  default:
    iVar1 = 0;
    break;
  case 0xd:
    if (c == '-') {
      *status = 0xb;
    }
    else if (c == '>') {
      *status = 0;
    }
    else if ((MYCTYPE_MAP[(byte)c] & 2) == 0) {
      *status = 10;
    }
    else {
      *status = 0xd;
    }
    iVar1 = 0;
    break;
  case 0xe:
    if (c == '>') {
      *status = 0;
    }
    iVar1 = 0;
    break;
  case 0xf:
    if (c == '>') {
      *status = 0;
    }
    else if ((MYCTYPE_MAP[(byte)c] & 2) != 0) {
      *status = 2;
    }
    iVar1 = 0;
  }
  return iVar1;
}



int read_token(Str buf,char **instr,int *status,int pre,int append)

{
  int iVar1;
  char cVar2;
  int iVar3;
  int prev_status;
  char *p;
  
  if (append == 0) {
    Strclear(buf);
  }
  if (**instr == '\0') {
    iVar3 = 0;
  }
  else {
    for (p = *instr; *p != '\0'; p = p + 1) {
      iVar3 = *status;
      next_status(*p,status);
      switch(*status) {
      case 0:
        if ((iVar3 == 6) && (*p != ';')) {
          p = p + -1;
        }
        else {
          if ((iVar3 == 0xc) || (((iVar3 == 0xd || (iVar3 == 0xe)) || (iVar3 == 8)))) {
            if (((iVar3 == 8) && (append == 0)) && (pre == 0)) {
              Strclear(buf);
            }
            if (pre != 0) {
              if (buf->area_size <= buf->length + 1) {
                Strgrow(buf);
              }
              iVar3 = buf->length;
              buf->ptr[iVar3] = *p;
              buf->length = iVar3 + 1;
              buf->ptr[buf->length] = '\0';
            }
            p = p + 1;
            goto proc_end;
          }
          if (buf->area_size <= buf->length + 1) {
            Strgrow(buf);
          }
          iVar1 = buf->length;
          if ((pre == 0) && ((MYCTYPE_MAP[(byte)*p] & 2) != 0)) {
            cVar2 = ' ';
          }
          else {
            cVar2 = *p;
          }
          buf->ptr[iVar1] = cVar2;
          buf->length = iVar1 + 1;
          buf->ptr[buf->length] = '\0';
          if ((((iVar3 == 2) || (iVar3 == 1)) || (iVar3 == 5)) || (iVar3 == 0xf)) {
            *instr = p + 1;
            if (((buf->length < 2) || (buf->ptr[buf->length + -2] != '<')) ||
               (buf->ptr[buf->length + -1] != '>')) {
              return 1;
            }
            Strshrink(buf,2);
          }
        }
        break;
      case 1:
      case 2:
        if ((iVar3 == 0) && (*instr != p)) {
          *instr = p;
          *status = 0;
          return 1;
        }
        if ((((*status == 1) && ((MYCTYPE_MAP[(byte)p[1]] & 4) == 0)) && (p[1] != '/')) &&
           (((p[1] != '!' && (p[1] != '?')) && ((p[1] != '\0' && (p[1] != '_')))))) {
          if (buf->area_size <= buf->length + 1) {
            Strgrow(buf);
          }
          iVar3 = buf->length;
          buf->ptr[iVar3] = '<';
          buf->length = iVar3 + 1;
          buf->ptr[buf->length] = '\0';
          *status = 0;
        }
        else {
          if (buf->area_size <= buf->length + 1) {
            Strgrow(buf);
          }
          iVar3 = buf->length;
          buf->ptr[iVar3] = *p;
          buf->length = iVar3 + 1;
          buf->ptr[buf->length] = '\0';
        }
        break;
      case 3:
      case 4:
      case 5:
      case 6:
      case 0xf:
        if (buf->area_size <= buf->length + 1) {
          Strgrow(buf);
        }
        iVar3 = buf->length;
        buf->ptr[iVar3] = *p;
        buf->length = iVar3 + 1;
        buf->ptr[buf->length] = '\0';
        break;
      case 8:
      case 9:
      case 0xb:
      case 0xc:
      case 0xd:
        if (pre != 0) {
          if (buf->area_size <= buf->length + 1) {
            Strgrow(buf);
          }
          iVar3 = buf->length;
          buf->ptr[iVar3] = *p;
          buf->length = iVar3 + 1;
          buf->ptr[buf->length] = '\0';
        }
        break;
      case 10:
      case 0xe:
        if (pre == 0) {
          if (append == 0) {
            Strclear(buf);
          }
        }
        else {
          if (buf->area_size <= buf->length + 1) {
            Strgrow(buf);
          }
          iVar3 = buf->length;
          buf->ptr[iVar3] = *p;
          buf->length = iVar3 + 1;
          buf->ptr[buf->length] = '\0';
        }
      }
    }
proc_end:
    *instr = p;
    iVar3 = 1;
  }
  return iVar3;
}



Str correct_irrtag(int status)

{
  int iVar1;
  Str x;
  Str tmp;
  char c;
  
  x = Strnew();
  do {
    switch(status) {
    case 1:
    case 2:
    case 5:
    case 8:
    case 9:
    case 0xc:
    case 0xd:
    case 0xe:
    case 0xf:
      c = '>';
      break;
    case 3:
      c = '\'';
      break;
    case 4:
      c = '\"';
      break;
    case 6:
      c = ';';
      break;
    default:
      return x;
    case 10:
    case 0xb:
      c = '-';
    }
    next_status(c,&status);
    if (x->area_size <= x->length + 1) {
      Strgrow(x);
    }
    iVar1 = x->length;
    x->ptr[iVar1] = c;
    x->length = iVar1 + 1;
    x->ptr[x->length] = '\0';
  } while( true );
}



void add_auth_pass_entry(auth_pass *ent,int netrc,int override)

{
  auth_pass *paVar1;
  auth_pass *ep;
  auth_pass *newent;
  
  paVar1 = passwords;
  if ((((ent->host != (Str)0x0) || (netrc != 0)) &&
      ((ent->is_proxy != 0 || ((ent->realm != (Str)0x0 || (netrc != 0)))))) &&
     ((ent->uname != (Str)0x0 && (ent->pwd != (Str)0x0)))) {
    paVar1 = (auth_pass *)GC_malloc(0x20);
    memcpy(paVar1,ent,0x20);
    if (override == 0) {
      if (passwords != (auth_pass *)0x0) {
        if (passwords->next == (auth_pass *)0x0) {
          passwords->next = paVar1;
          paVar1 = passwords;
        }
        else {
          for (ep = passwords; ep->next != (auth_pass *)0x0; ep = ep->next) {
          }
          ep->next = paVar1;
          paVar1 = passwords;
        }
      }
    }
    else {
      paVar1->next = passwords;
    }
  }
  passwords = paVar1;
  return;
}



auth_pass * find_auth_pass_entry(char *host,int port,char *realm,char *uname,int is_proxy)

{
  int iVar1;
  auth_pass *ent;
  
  ent = passwords;
  do {
    if (ent == (auth_pass *)0x0) {
      return (auth_pass *)0x0;
    }
    if (((((ent->is_proxy == is_proxy) && (ent->bad != 1)) &&
         ((ent->host == (Str)0x0 || (iVar1 = strcasecmp(ent->host->ptr,host), iVar1 == 0)))) &&
        ((ent->port == 0 || (ent->port == port)))) &&
       ((ent->uname == (Str)0x0 ||
        ((uname == (char *)0x0 || (iVar1 = strcmp(ent->uname->ptr,uname), iVar1 == 0)))))) {
      if (ent->realm == (Str)0x0) {
        return ent;
      }
      if (realm == (char *)0x0) {
        return ent;
      }
      iVar1 = strcmp(ent->realm->ptr,realm);
      if (iVar1 == 0) {
        return ent;
      }
    }
    ent = ent->next;
  } while( true );
}



int find_auth_user_passwd(ParsedURL *pu,char *realm,Str *uname,Str *pwd,int is_proxy)

{
  Str p_Var1;
  int iVar2;
  auth_pass *paVar3;
  auth_pass *ent;
  
  if ((pu->user == (char *)0x0) || (pu->pass == (char *)0x0)) {
    paVar3 = find_auth_pass_entry(pu->host,pu->port,realm,pu->user,is_proxy);
    if (paVar3 == (auth_pass *)0x0) {
      iVar2 = 0;
    }
    else {
      *uname = paVar3->uname;
      *pwd = paVar3->pwd;
      iVar2 = 1;
    }
  }
  else {
    p_Var1 = Strnew_charp(pu->user);
    *uname = p_Var1;
    p_Var1 = Strnew_charp(pu->pass);
    *pwd = p_Var1;
    iVar2 = 1;
  }
  return iVar2;
}



void add_auth_user_passwd(ParsedURL *pu,char *realm,Str uname,Str pwd,int is_proxy)

{
  auth_pass ent;
  
  memset(&ent,0,0x20);
  ent.is_proxy = is_proxy;
  ent.host = Strnew_charp(pu->host);
  ent.port = pu->port;
  ent.realm = Strnew_charp(realm);
  ent.uname = uname;
  ent.pwd = pwd;
  add_auth_pass_entry(&ent,0,1);
  return;
}



void invalidate_auth_user_passwd(ParsedURL *pu,char *realm,Str uname,Str pwd,int is_proxy)

{
  auth_pass *paVar1;
  auth_pass *ent;
  
  paVar1 = find_auth_pass_entry(pu->host,pu->port,realm,(char *)0x0,is_proxy);
  if (paVar1 != (auth_pass *)0x0) {
    paVar1->bad = 1;
  }
  return;
}



Str next_token(Str arg)

{
  char *q;
  char *p;
  Str narg;
  
  narg = (Str)0x0;
  if ((arg == (Str)0x0) || (arg->length == 0)) {
    narg = (Str)0x0;
  }
  else {
    q = arg->ptr;
    while ((*q != '\0' && ((MYCTYPE_MAP[(byte)*q] & 2) == 0))) {
      q = q + 1;
    }
    if (*q != '\0') {
      *q = '\0';
      do {
        q = q + 1;
        if (*q == '\0') break;
      } while ((MYCTYPE_MAP[(byte)*q] & 2) != 0);
      if (*q != '\0') {
        narg = Strnew_charp(q);
      }
    }
  }
  return narg;
}



void parsePasswd(FILE *fp,int netrc)

{
  char *__s1;
  Str p_Var1;
  int iVar2;
  auth_pass ent;
  char *p;
  Str arg;
  Str line;
  
  line = (Str)0x0;
  bzero(&ent,0x20);
  do {
    while( true ) {
      while( true ) {
        while( true ) {
          while( true ) {
            while( true ) {
              while( true ) {
                while( true ) {
                  while( true ) {
                    while( true ) {
                      if ((line == (Str)0x0) || (line->length == 0)) {
                        line = Strfgets(fp);
                      }
                      if (line->length == 0) {
                        add_auth_pass_entry(&ent,netrc,0);
                        return;
                      }
                      Strchop(line);
                      Strremovefirstspaces(line);
                      __s1 = line->ptr;
                      if ((*__s1 != '#') && (*__s1 != '\0')) break;
                      line = (Str)0x0;
                    }
                    p_Var1 = next_token(line);
                    iVar2 = strcmp(__s1,"machine");
                    line = p_Var1;
                    if (((iVar2 != 0) && (iVar2 = strcmp(__s1,"host"), iVar2 != 0)) &&
                       ((netrc == 0 || (iVar2 = strcmp(__s1,"default"), iVar2 != 0)))) break;
                    add_auth_pass_entry(&ent,netrc,0);
                    bzero(&ent,0x20);
                    if (netrc != 0) {
                      ent.port = 0x15;
                    }
                    iVar2 = strcmp(__s1,"default");
                    if (iVar2 != 0) {
                      line = next_token(p_Var1);
                      ent.host = p_Var1;
                    }
                  }
                  if (((netrc != 0) || (iVar2 = strcmp(__s1,"port"), iVar2 != 0)) ||
                     (p_Var1 == (Str)0x0)) break;
                  line = next_token(p_Var1);
                  ent.port = atoi(p_Var1->ptr);
                }
                if ((netrc != 0) || (iVar2 = strcmp(__s1,"proxy"), iVar2 != 0)) break;
                ent.is_proxy = 1;
              }
              if ((netrc != 0) || (iVar2 = strcmp(__s1,"path"), iVar2 != 0)) break;
              line = next_token(p_Var1);
            }
            if ((netrc != 0) || (iVar2 = strcmp(__s1,"realm"), iVar2 != 0)) break;
            line = (Str)0x0;
            ent.realm = p_Var1;
          }
          iVar2 = strcmp(__s1,"login");
          if (iVar2 != 0) break;
          line = next_token(p_Var1);
          ent.uname = p_Var1;
        }
        iVar2 = strcmp(__s1,"password");
        if ((iVar2 != 0) && (iVar2 = strcmp(__s1,"passwd"), iVar2 != 0)) break;
        line = next_token(p_Var1);
        ent.pwd = p_Var1;
      }
      if ((netrc != 0) && (iVar2 = strcmp(__s1,"machdef"), iVar2 == 0)) break;
      if ((netrc == 0) || (iVar2 = strcmp(__s1,"account"), iVar2 != 0)) {
        line = (Str)0x0;
      }
      else {
        line = next_token(p_Var1);
      }
    }
    do {
      p_Var1 = Strfgets(fp);
      if (p_Var1->length == 0) break;
    } while (*p_Var1->ptr != '\n');
    line = (Str)0x0;
  } while( true );
}



FILE * openSecretFile(char *fname)

{
  FILE *pFVar1;
  char *__file;
  int iVar2;
  Str p_Var3;
  stat st;
  char *efname;
  
  if (fname == (char *)0x0) {
    pFVar1 = (FILE *)0x0;
  }
  else {
    __file = expandPath(fname);
    iVar2 = stat(__file,(stat *)&st);
    pFVar1 = stderr;
    if (iVar2 < 0) {
      pFVar1 = (FILE *)0x0;
    }
    else if ((disable_secret_security_check == 0) && ((st.st_mode & 0x3f) != 0)) {
      if (fmInitialized == '\0') {
        p_Var3 = Sprintf("SECURITY NOTE: file %s must not be accessible by others",fname);
        fputs(p_Var3->ptr,pFVar1);
        fputc(10,stderr);
      }
      else {
        p_Var3 = Sprintf("SECURITY NOTE: file %s must not be accessible by others",fname);
        message(p_Var3->ptr,0,0);
        refresh();
      }
      sleep(2);
      pFVar1 = (FILE *)0x0;
    }
    else {
      pFVar1 = fopen(__file,"r");
    }
  }
  return (FILE *)pFVar1;
}



void loadPasswd(void)

{
  FILE *pFVar1;
  FILE *fp;
  
  passwords = (auth_pass *)0x0;
  pFVar1 = (FILE *)openSecretFile(passwd_file);
  if (pFVar1 != (FILE *)0x0) {
    parsePasswd((FILE *)pFVar1,0);
    fclose(pFVar1);
  }
  pFVar1 = (FILE *)openSecretFile("~/.netrc");
  if (pFVar1 != (FILE *)0x0) {
    parsePasswd((FILE *)pFVar1,1);
    fclose(pFVar1);
  }
  return;
}



char * last_modified(Buffer *buf)

{
  int iVar1;
  char *pcVar2;
  stat st;
  TextListItem *ti;
  
  if (buf->document_header == (TextList *)0x0) {
    if ((buf->currentURL).scheme == 4) {
      iVar1 = stat((buf->currentURL).file,(stat *)&st);
      if (iVar1 < 0) {
        pcVar2 = "unknown";
      }
      else {
        pcVar2 = ctime(&st.st_mtim.tv_sec);
      }
    }
    else {
      pcVar2 = "unknown";
    }
  }
  else {
    for (ti = buf->document_header->first; ti != (TextListItem *)0x0; ti = ti->next) {
      iVar1 = strncasecmp(ti->ptr,"Last-modified: ",0xf);
      if (iVar1 == 0) {
        return ti->ptr + 0xf;
      }
    }
    pcVar2 = "unknown";
  }
  return pcVar2;
}



Str romanNum2(int l,int n)

{
  int iVar1;
  Str x;
  Str s;
  
  x = Strnew();
  switch(n) {
  case 1:
  case 2:
  case 3:
    for (; 0 < n; n = n + -1) {
      if (x->area_size <= x->length + 1) {
        Strgrow(x);
      }
      iVar1 = x->length;
      x->ptr[iVar1] = roman_num1[l];
      x->length = iVar1 + 1;
      x->ptr[x->length] = '\0';
    }
    break;
  case 4:
    if (x->area_size <= x->length + 1) {
      Strgrow(x);
    }
    iVar1 = x->length;
    x->ptr[iVar1] = roman_num1[l];
    x->length = iVar1 + 1;
    x->ptr[x->length] = '\0';
    if (x->area_size <= x->length + 1) {
      Strgrow(x);
    }
    iVar1 = x->length;
    x->ptr[iVar1] = roman_num5[l];
    x->length = iVar1 + 1;
    x->ptr[x->length] = '\0';
    break;
  case 5:
  case 6:
  case 7:
  case 8:
    if (x->area_size <= x->length + 1) {
      Strgrow(x);
    }
    iVar1 = x->length;
    x->ptr[iVar1] = roman_num5[l];
    x->length = iVar1 + 1;
    x->ptr[x->length] = '\0';
    for (n = n + -5; 0 < n; n = n + -1) {
      if (x->area_size <= x->length + 1) {
        Strgrow(x);
      }
      iVar1 = x->length;
      x->ptr[iVar1] = roman_num1[l];
      x->length = iVar1 + 1;
      x->ptr[x->length] = '\0';
    }
    break;
  case 9:
    if (x->area_size <= x->length + 1) {
      Strgrow(x);
    }
    iVar1 = x->length;
    x->ptr[iVar1] = roman_num1[l];
    x->length = iVar1 + 1;
    x->ptr[x->length] = '\0';
    if (x->area_size <= x->length + 1) {
      Strgrow(x);
    }
    iVar1 = x->length;
    x->ptr[iVar1] = roman_num1[l + 1];
    x->length = iVar1 + 1;
    x->ptr[x->length] = '\0';
  }
  return x;
}



Str romanNumeral(int n)

{
  Str x;
  Str p_Var1;
  Str r;
  
  x = Strnew();
  if (0 < n) {
    if (n < 4000) {
      p_Var1 = romanNum2(3,n / 1000);
      Strcat(x,p_Var1);
      p_Var1 = romanNum2(2,(n % 1000) / 100);
      Strcat(x,p_Var1);
      p_Var1 = romanNum2(1,(n % 100) / 10);
      Strcat(x,p_Var1);
      p_Var1 = romanNum2(0,n % 10);
      Strcat(x,p_Var1);
    }
    else {
      Strcat_charp(x,"**");
    }
  }
  return x;
}



Str romanAlphabet(int n)

{
  int iVar1;
  int iVar2;
  Str x;
  int in_GS_OFFSET;
  int l;
  Str r;
  char cStack31;
  char buf [14];
  int local_10;
  
  local_10 = *(int *)(in_GS_OFFSET + 0x14);
  x = Strnew();
  if (0 < n) {
    l = 0;
    for (; iVar2 = l, n != 0; n = (n + -1) / 0x1a) {
      buf[l] = (char)(n + -1) + (char)((n + -1) / 0x1a) * -0x1a + 'a';
      l = l + 1;
    }
    while (l = iVar2 + -1, -1 < l) {
      if (x->area_size <= x->length + 1) {
        Strgrow(x);
      }
      iVar1 = x->length;
      x->ptr[iVar1] = buf[iVar2 + -1];
      x->length = iVar1 + 1;
      x->ptr[x->length] = '\0';
      iVar2 = l;
    }
  }
  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {
    return x;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void reset_signals(void)

{
  mySignal(1,(anon_subr_void_int *)0x0);
  mySignal(2,(anon_subr_void_int *)0x0);
  mySignal(3,(anon_subr_void_int *)0x0);
  mySignal(0xf,(anon_subr_void_int *)0x0);
  mySignal(4,(anon_subr_void_int *)0x0);
  mySignal(6,(anon_subr_void_int *)0x0);
  mySignal(8,(anon_subr_void_int *)0x0);
  mySignal(7,(anon_subr_void_int *)0x0);
  mySignal(0x11,(anon_subr_void_int *)0x1);
  mySignal(0xd,(anon_subr_void_int *)0x1);
  return;
}



void close_all_fds_except(int i,int f)

{
  int iVar1;
  
  if (i == 1) {
LAB_0807ae80:
    iVar1 = open("/dev/null",1);
    dup2(iVar1,1);
  }
  else if (i != 2) {
    if (i != 0) goto LAB_0807aec8;
    iVar1 = open("/dev/null",0);
    dup2(iVar1,0);
    goto LAB_0807ae80;
  }
  iVar1 = open("/dev/null",1);
  dup2(iVar1,2);
LAB_0807aec8:
  for (i = 3; i < 0x10; i = i + 1) {
    if (i != f) {
      close(i);
    }
  }
  return;
}



void setup_child(int child,int i,int f)

{
  reset_signals();
  mySignal(2,(anon_subr_void_int *)0x1);
  if (child == 0) {
    setpgrp();
  }
  close_tty();
  close_all_fds_except(i,f);
  TrapSignal = '\0';
  fmInitialized = '\0';
  QuietMessage = '\x01';
  return;
}



pid_t open_pipe_rw(FILE **fr,FILE **fw)

{
  int iVar1;
  __pid_t _Var2;
  FILE *pFVar3;
  int fdw [2];
  int fdr [2];
  pid_t pid;
  
  if ((fr == (FILE **)0x0) || (iVar1 = pipe(fdr), -1 < iVar1)) {
    if ((fw == (FILE **)0x0) || (iVar1 = pipe(fdw), -1 < iVar1)) {
      flush_tty();
      _Var2 = fork();
      if (-1 < _Var2) {
        if (_Var2 == 0) {
          if (fr != (FILE **)0x0) {
            close(fdr[0]);
            dup2(fdr[1],1);
          }
          if (fw == (FILE **)0x0) {
            return 0;
          }
          close(fdw[1]);
          dup2(fdw[0],0);
          return 0;
        }
        if (fr != (FILE **)0x0) {
          close(fdr[1]);
          if (*fr == stdin) {
            dup2(fdr[0],0);
          }
          else {
            pFVar3 = fdopen(fdr[0],"r");
            *fr = (FILE *)pFVar3;
          }
        }
        if (fw == (FILE **)0x0) {
          return _Var2;
        }
        close(fdw[0]);
        if (*fw == stdout) {
          dup2(fdw[1],1);
          return _Var2;
        }
        pFVar3 = fdopen(fdw[1],"w");
        *fw = (FILE *)pFVar3;
        return _Var2;
      }
      if (fw != (FILE **)0x0) {
        close(fdw[0]);
        close(fdw[1]);
      }
    }
    if (fr != (FILE **)0x0) {
      close(fdr[0]);
      close(fdr[1]);
    }
  }
  return -1;
}



void myExec(char *command)

{
  mySignal(2,(anon_subr_void_int *)0x0);
  execl("/bin/sh","sh",&DAT_080caf33,command,0);
                    // WARNING: Subroutine does not return
  exit(0x7f);
}



void mySystem(char *command,int background)

{
  __pid_t _Var1;
  
  if (background == 0) {
    system(command);
  }
  else {
    flush_tty();
    _Var1 = fork();
    if (_Var1 == 0) {
      setup_child(0,0,-1);
      myExec(command);
    }
  }
  return;
}



Str myExtCommand(char *cmd,char *arg,int redirect)

{
  int iVar1;
  bool bVar2;
  int set_arg;
  char *p;
  Str tmp;
  
  tmp = (Str)0x0;
  bVar2 = false;
  for (p = cmd; *p != '\0'; p = p + 1) {
    if (((*p != '%') || (p[1] != 's')) || (bVar2)) {
      if (tmp != (Str)0x0) {
        if (tmp->area_size <= tmp->length + 1) {
          Strgrow(tmp);
        }
        iVar1 = tmp->length;
        tmp->ptr[iVar1] = *p;
        tmp->length = iVar1 + 1;
        tmp->ptr[tmp->length] = '\0';
      }
    }
    else {
      if (tmp == (Str)0x0) {
        tmp = Strnew_charp_n(cmd,(int)p - (int)cmd);
      }
      Strcat_charp(tmp,arg);
      bVar2 = true;
      p = p + 1;
    }
  }
  if (!bVar2) {
    if (redirect == 0) {
      tmp = Strnew_m_charp(cmd,&DAT_080caf48,arg,0);
    }
    else {
      tmp = Strnew_m_charp("(",cmd,&DAT_080caf41,arg,0);
    }
  }
  return tmp;
}



Str myEditor(char *cmd,char *file,int line)

{
  int iVar1;
  bool bVar2;
  bool bVar3;
  char *pcVar4;
  Str p_Var5;
  int set_line;
  int set_file;
  char *p;
  Str tmp;
  
  tmp = (Str)0x0;
  bVar2 = false;
  bVar3 = false;
  for (p = cmd; *p != '\0'; p = p + 1) {
    if (((*p != '%') || (p[1] != 's')) || (bVar2)) {
      if (((*p != '%') || (p[1] != 'd')) || ((bVar3 || (line < 1)))) {
        if (tmp != (Str)0x0) {
          if (tmp->area_size <= tmp->length + 1) {
            Strgrow(tmp);
          }
          iVar1 = tmp->length;
          tmp->ptr[iVar1] = *p;
          tmp->length = iVar1 + 1;
          tmp->ptr[tmp->length] = '\0';
        }
      }
      else {
        if (tmp == (Str)0x0) {
          tmp = Strnew_charp_n(cmd,(int)p - (int)cmd);
        }
        p_Var5 = Sprintf("%d",line);
        Strcat(tmp,p_Var5);
        bVar3 = true;
        p = p + 1;
      }
    }
    else {
      if (tmp == (Str)0x0) {
        tmp = Strnew_charp_n(cmd,(int)p - (int)cmd);
      }
      Strcat_charp(tmp,file);
      bVar2 = true;
      p = p + 1;
    }
  }
  if (!bVar2) {
    if (tmp == (Str)0x0) {
      tmp = Strnew_charp(cmd);
    }
    if ((!bVar3) && (1 < line)) {
      pcVar4 = strcasestr(cmd,"vi");
      if (pcVar4 != (char *)0x0) {
        p_Var5 = Sprintf(" +%d",line);
        Strcat(tmp,p_Var5);
      }
    }
    Strcat_m_charp(tmp,&DAT_080caf48,file,0);
  }
  return tmp;
}



// WARNING: Variable defined which should be unmapped: q
// WARNING: Variable defined which should be unmapped: extpath

char * expandName(char *name)

{
  char *pcVar1;
  char *pcVar2;
  Str x;
  int iVar3;
  char *q;
  Str extpath;
  passwd *passent;
  char *p;
  
  if (name == (char *)0x0) {
    name = (char *)0x0;
  }
  else if (*name == '/') {
    if (((name[1] == '~') && ((MYCTYPE_MAP[(byte)name[2]] & 4) != 0)) &&
       (personal_document_root != (char *)0x0)) {
      pcVar2 = name + 2;
      pcVar1 = strchr(pcVar2,0x2f);
      if (pcVar1 == (char *)0x0) {
        passent = (passwd *)getpwnam(pcVar2);
        p = "";
      }
      else {
        pcVar2 = allocStr(pcVar2,(int)pcVar1 - (int)pcVar2);
        passent = (passwd *)getpwnam(pcVar2);
        p = pcVar1;
      }
      if (passent != (passwd *)0x0) {
        x = Strnew_m_charp(passent->pw_dir,&DAT_080caf56,personal_document_root,0,pcVar1,0);
        if ((*personal_document_root == '\0') && (*p == '/')) {
          p = p + 1;
        }
        iVar3 = strcmp(x->ptr,"/");
        if ((iVar3 == 0) && (*p == '/')) {
          p = p + 1;
        }
        Strcat_charp(x,p);
        name = x->ptr;
      }
    }
  }
  else {
    name = expandPath(name);
  }
  return name;
}



char * file_to_url(char *file)

{
  int iVar1;
  Str p_Var2;
  char *pcVar3;
  Str tmp;
  
  file = expandPath(file);
  if (*file != '/') {
    p_Var2 = Strnew_charp(CurrentDir);
    if ((p_Var2->length < 1) || (p_Var2->ptr[p_Var2->length + -1] != '/')) {
      if (p_Var2->area_size <= p_Var2->length + 1) {
        Strgrow(p_Var2);
      }
      iVar1 = p_Var2->length;
      p_Var2->ptr[iVar1] = '/';
      p_Var2->length = iVar1 + 1;
      p_Var2->ptr[p_Var2->length] = '\0';
    }
    Strcat_charp(p_Var2,file);
    file = p_Var2->ptr;
  }
  p_Var2 = Strnew_charp("file://");
  pcVar3 = cleanupName(file);
  pcVar3 = file_quote(pcVar3);
  Strcat_charp(p_Var2,pcVar3);
  return p_Var2->ptr;
}



char * url_unquote_conv(char *url,wc_ces charset)

{
  wc_uint8 wVar1;
  Str p_Var2;
  Str tmp;
  wc_uint8 old_auto_detect;
  
  wVar1 = WcOption.auto_detect;
  p_Var2 = Strnew_charp(url);
  p_Var2 = Str_url_unquote(p_Var2,0,1);
  if ((charset == 0) || (charset == 0x100)) {
    charset = SystemCharset;
  }
  WcOption.auto_detect = '\x02';
  p_Var2 = convertLine((URLFile *)0x0,p_Var2,0,&charset,charset);
  WcOption.auto_detect = wVar1;
  return p_Var2->ptr;
}



Str tmpfname(int type,char *ext)

{
  uint uVar1;
  Str p_Var2;
  char *s;
  Str tmpf;
  
  if (ext == (char *)0x0) {
    ext = "";
  }
  uVar1 = tmpf_seq[type];
  tmpf_seq[type] = uVar1 + 1;
  p_Var2 = Sprintf("%s/w3m%s%d-%d%s",tmp_dir,tmpf_base[type],CurrentPid,uVar1,ext);
  s = allocStr(p_Var2->ptr,-1);
  pushValue((GeneralList *)fileToDelete,s);
  return p_Var2;
}



int get_day(char **s)

{
  char *pcVar1;
  char *pcVar2;
  Str x;
  int iVar3;
  char *ss;
  int day;
  Str tmp;
  
  x = Strnew();
  pcVar1 = *s;
  if (**s == '\0') {
    iVar3 = -1;
  }
  else {
    while ((**s != '\0' && ((MYCTYPE_MAP[(byte)**s] & 8) != 0))) {
      if (x->area_size <= x->length + 1) {
        Strgrow(x);
      }
      iVar3 = x->length;
      pcVar2 = *s;
      x->ptr[iVar3] = *pcVar2;
      x->length = iVar3 + 1;
      *s = pcVar2 + 1;
      x->ptr[x->length] = '\0';
    }
    iVar3 = atoi(x->ptr);
    if ((iVar3 < 1) || (0x1f < iVar3)) {
      *s = pcVar1;
      iVar3 = -1;
    }
  }
  return iVar3;
}



int get_month(char **s)

{
  char *pcVar1;
  char *pcVar2;
  Str x;
  int iVar3;
  char *ss;
  int mon;
  Str tmp;
  
  x = Strnew();
  pcVar1 = *s;
  if (**s == '\0') {
    mon = -1;
  }
  else {
    while ((**s != '\0' && ((MYCTYPE_MAP[(byte)**s] & 8) != 0))) {
      if (x->area_size <= x->length + 1) {
        Strgrow(x);
      }
      iVar3 = x->length;
      pcVar2 = *s;
      x->ptr[iVar3] = *pcVar2;
      x->length = iVar3 + 1;
      *s = pcVar2 + 1;
      x->ptr[x->length] = '\0';
    }
    if (x->length < 1) {
      while ((**s != '\0' && ((MYCTYPE_MAP[(byte)**s] & 4) != 0))) {
        if (x->area_size <= x->length + 1) {
          Strgrow(x);
        }
        iVar3 = x->length;
        pcVar2 = *s;
        x->ptr[iVar3] = *pcVar2;
        x->length = iVar3 + 1;
        *s = pcVar2 + 1;
        x->ptr[x->length] = '\0';
      }
      mon = 1;
      while ((mon < 0xd && (iVar3 = strncmp(x->ptr,monthtbl[mon + -1],3), iVar3 != 0))) {
        mon = mon + 1;
      }
    }
    else {
      mon = atoi(x->ptr);
    }
    if ((mon < 1) || (0xc < mon)) {
      *s = pcVar1;
      mon = -1;
    }
  }
  return mon;
}



int get_year(char **s)

{
  char *pcVar1;
  char *pcVar2;
  Str x;
  int iVar3;
  char *ss;
  int year;
  Str tmp;
  
  x = Strnew();
  pcVar1 = *s;
  if (**s == '\0') {
    iVar3 = -1;
  }
  else {
    while ((**s != '\0' && ((MYCTYPE_MAP[(byte)**s] & 8) != 0))) {
      if (x->area_size <= x->length + 1) {
        Strgrow(x);
      }
      iVar3 = x->length;
      pcVar2 = *s;
      x->ptr[iVar3] = *pcVar2;
      x->length = iVar3 + 1;
      *s = pcVar2 + 1;
      x->ptr[x->length] = '\0';
    }
    if ((x->length == 2) || (x->length == 4)) {
      iVar3 = atoi(x->ptr);
      if (x->length == 2) {
        if (iVar3 < 0x46) {
          iVar3 = iVar3 + 2000;
        }
        else {
          iVar3 = iVar3 + 0x76c;
        }
      }
    }
    else {
      *s = pcVar1;
      iVar3 = -1;
    }
  }
  return iVar3;
}



int get_time(char **s,int *hour,int *min,int *sec)

{
  char *pcVar1;
  char *pcVar2;
  Str x;
  int iVar3;
  char *ss;
  Str tmp;
  
  x = Strnew();
  pcVar1 = *s;
  if (**s == '\0') {
    iVar3 = -1;
  }
  else {
    while ((**s != '\0' && ((MYCTYPE_MAP[(byte)**s] & 8) != 0))) {
      if (x->area_size <= x->length + 1) {
        Strgrow(x);
      }
      iVar3 = x->length;
      pcVar2 = *s;
      x->ptr[iVar3] = *pcVar2;
      x->length = iVar3 + 1;
      *s = pcVar2 + 1;
      x->ptr[x->length] = '\0';
    }
    if (**s == ':') {
      iVar3 = atoi(x->ptr);
      *hour = iVar3;
      *s = *s + 1;
      Strclear(x);
      while ((**s != '\0' && ((MYCTYPE_MAP[(byte)**s] & 8) != 0))) {
        if (x->area_size <= x->length + 1) {
          Strgrow(x);
        }
        iVar3 = x->length;
        pcVar2 = *s;
        x->ptr[iVar3] = *pcVar2;
        x->length = iVar3 + 1;
        *s = pcVar2 + 1;
        x->ptr[x->length] = '\0';
      }
      if (**s == ':') {
        iVar3 = atoi(x->ptr);
        *min = iVar3;
        *s = *s + 1;
        Strclear(x);
        while ((**s != '\0' && ((MYCTYPE_MAP[(byte)**s] & 8) != 0))) {
          if (x->area_size <= x->length + 1) {
            Strgrow(x);
          }
          iVar3 = x->length;
          pcVar2 = *s;
          x->ptr[iVar3] = *pcVar2;
          x->length = iVar3 + 1;
          *s = pcVar2 + 1;
          x->ptr[x->length] = '\0';
        }
        iVar3 = atoi(x->ptr);
        *sec = iVar3;
        if ((((*hour < 0) || (0x17 < *hour)) || (*min < 0)) ||
           (((0x3b < *min || (*sec < 0)) || (0x3b < *sec)))) {
          *s = pcVar1;
          iVar3 = -1;
        }
        else {
          iVar3 = 0;
        }
      }
      else {
        *s = pcVar1;
        iVar3 = -1;
      }
    }
    else {
      *s = pcVar1;
      iVar3 = -1;
    }
  }
  return iVar3;
}



int get_zone(char **s,int *z_hour,int *z_min)

{
  byte *pbVar1;
  char *pcVar2;
  Str x;
  int iVar3;
  char *ss;
  int zone;
  Str tmp;
  
  x = Strnew();
  pbVar1 = (byte *)*s;
  if (**s == '\0') {
    iVar3 = -1;
  }
  else {
    if ((**s == '+') || (**s == '-')) {
      if (x->area_size <= x->length + 1) {
        Strgrow(x);
      }
      iVar3 = x->length;
      pcVar2 = *s;
      x->ptr[iVar3] = *pcVar2;
      x->length = iVar3 + 1;
      *s = pcVar2 + 1;
      x->ptr[x->length] = '\0';
    }
    while ((**s != '\0' && ((MYCTYPE_MAP[(byte)**s] & 8) != 0))) {
      if (x->area_size <= x->length + 1) {
        Strgrow(x);
      }
      iVar3 = x->length;
      pcVar2 = *s;
      x->ptr[iVar3] = *pcVar2;
      x->length = iVar3 + 1;
      *s = pcVar2 + 1;
      x->ptr[x->length] = '\0';
    }
    if (((x->length == 4) && ((MYCTYPE_MAP[*pbVar1] & 8) != 0)) ||
       ((x->length == 5 && ((*pbVar1 == 0x2b || (*pbVar1 == 0x2d)))))) {
      iVar3 = atoi(x->ptr);
      *z_hour = iVar3 / 100;
      *z_min = iVar3 % 100;
      iVar3 = 0;
    }
    else {
      *s = (char *)pbVar1;
      iVar3 = -1;
    }
  }
  return iVar3;
}



time_t mymktime(char *timestr)

{
  int iVar1;
  int z_min;
  int z_hour;
  int sec;
  int min;
  int hour;
  int year;
  int mon;
  int day;
  char *s;
  
  z_hour = 0;
  z_min = 0;
  if ((timestr == (char *)0x0) || (*timestr == '\0')) {
    return -1;
  }
  s = timestr;
  while ((*s != '\0' && ((MYCTYPE_MAP[(byte)*s] & 4) != 0))) {
    s = s + 1;
  }
  while ((*s != '\0' && ((MYCTYPE_MAP[(byte)*s] & 0xc) == 0))) {
    s = s + 1;
  }
  if ((MYCTYPE_MAP[(byte)*s] & 8) == 0) {
    while ((*s != '\0' && ((MYCTYPE_MAP[(byte)*s] & 0xc) == 0))) {
      s = s + 1;
    }
    mon = get_month(&s);
    if (mon == -1) {
      return -1;
    }
    while ((*s != '\0' && ((MYCTYPE_MAP[(byte)*s] & 8) == 0))) {
      s = s + 1;
    }
    day = get_day(&s);
    if (day == -1) {
      return -1;
    }
    while ((*s != '\0' && ((MYCTYPE_MAP[(byte)*s] & 8) == 0))) {
      s = s + 1;
    }
    iVar1 = get_time(&s,&hour,&min,&sec);
    if (iVar1 == -1) {
      return -1;
    }
    while ((*s != '\0' && ((MYCTYPE_MAP[(byte)*s] & 8) == 0))) {
      s = s + 1;
    }
    year = get_year(&s);
    if (year == -1) {
      return -1;
    }
  }
  else {
    day = get_day(&s);
    if (day == -1) {
      return -1;
    }
    while ((*s != '\0' && ((MYCTYPE_MAP[(byte)*s] & 0xc) == 0))) {
      s = s + 1;
    }
    mon = get_month(&s);
    if (mon == -1) {
      return -1;
    }
    while ((*s != '\0' && ((MYCTYPE_MAP[(byte)*s] & 8) == 0))) {
      s = s + 1;
    }
    year = get_year(&s);
    if (year == -1) {
      return -1;
    }
    while ((*s != '\0' && ((MYCTYPE_MAP[(byte)*s] & 8) == 0))) {
      s = s + 1;
    }
    if (*s == '\0') {
      hour = 0;
      min = 0;
      sec = 0;
    }
    else {
      iVar1 = get_time(&s,&hour,&min,&sec);
      if (iVar1 == -1) {
        return -1;
      }
      for (; (((*s != '\0' && ((MYCTYPE_MAP[(byte)*s] & 8) == 0)) && (*s != '+')) && (*s != '-'));
          s = s + 1) {
      }
      get_zone(&s,&z_hour,&z_min);
    }
  }
  iVar1 = mon + -3;
  if (mon + -3 < 0) {
    year = year + -1;
    iVar1 = mon + 9;
  }
  mon = iVar1;
  iVar1 = year * 0x5b5 + -0x2bdf70;
  if (iVar1 < 0) {
    iVar1 = year * 0x5b5 + -0x2bdf6d;
  }
  return (day + (iVar1 >> 2) + (mon * 0x99 + 2) / 5 + -0x2a0) * 0x15180 + (hour - z_hour) * 0xe10 +
         (min - z_min) * 0x3c + sec;
}



char * FQDN(char *host)

{
  int iVar1;
  char *pcVar2;
  addrinfo hints;
  char *namebuf;
  addrinfo *res0;
  addrinfo *res;
  int error;
  int *af;
  char *p;
  
  if (host == (char *)0x0) {
    host = (char *)0x0;
  }
  else {
    iVar1 = strcasecmp(host,"localhost");
    if (iVar1 != 0) {
      for (p = host; (*p != '\0' && (*p != '.')); p = p + 1) {
      }
      if (*p != '.') {
        af = (int *)ai_family_order_table[DNS_order];
        while( true ) {
          memset(&hints,0,0x20);
          hints.ai_flags = 2;
          hints.ai_family = *af;
          hints.ai_socktype = 1;
          error = getaddrinfo(host,(char *)0x0,(addrinfo *)&hints,(addrinfo **)&res0);
          if (error == 0) {
            for (res = res0; res != (addrinfo *)0x0; res = res->ai_next) {
              if (res->ai_canonname != (char *)0x0) {
                pcVar2 = strdup(res->ai_canonname);
                freeaddrinfo((addrinfo *)res0);
                return pcVar2;
              }
            }
            freeaddrinfo((addrinfo *)res0);
            iVar1 = *af;
          }
          else {
            iVar1 = *af;
          }
          if (iVar1 == 0) break;
          af = af + 1;
        }
        host = (char *)0x0;
      }
    }
  }
  return host;
}



anon_subr_void_int * mySignal(int signal_number,anon_subr_void_int *action)

{
  sigaction old_action;
  sigaction new_action;
  
  sigemptyset((sigset_t *)&new_action.sa_mask);
  new_action.__sigaction_handler = action;
  if (signal_number == 0xe) {
    new_action.sa_flags = 0x20000000;
  }
  else {
    new_action.sa_flags = 0x10000000;
  }
  sigaction(signal_number,(sigaction *)&new_action,(sigaction *)&old_action);
  return old_action.__sigaction_handler;
}



void set_mark(Line *l,int pos,int epos)

{
  for (; (pos < epos && (pos < l->size)); pos = pos + 1) {
    l->propBuf[pos] = l->propBuf[pos] | 1;
  }
  return;
}



void init_migemo(void)

{
  migemo_running = use_migemo;
  migemo_active = use_migemo;
  if (migemor != (FILE *)0x0) {
    fclose((FILE *)migemor);
  }
  if (migemow != (FILE *)0x0) {
    fclose((FILE *)migemow);
  }
  migemow = (FILE *)0x0;
  migemor = (FILE *)0x0;
  if (migemo_pid != 0) {
    kill(migemo_pid,9);
  }
  migemo_pid = 0;
  return;
}



int open_migemo(char *migemo_command)

{
  int iVar1;
  
  migemo_pid = open_pipe_rw(&migemor,&migemow);
  if (migemo_pid < 0) {
    migemo_pid = 0;
    migemo_running = 0;
    migemo_active = 0;
    iVar1 = 0;
  }
  else {
    if (migemo_pid == 0) {
      setup_child(0,2,-1);
      myExec(migemo_command);
    }
    iVar1 = 1;
  }
  return iVar1;
}



char * migemostr(char *str)

{
  wc_ces wVar1;
  wc_ces wVar2;
  int iVar3;
  Str p_Var4;
  int *piVar5;
  char *pcVar6;
  Str tmp;
  
  if (((migemor != (FILE *)0x0) && (migemow != (FILE *)0x0)) ||
     (iVar3 = open_migemo(migemo_command), iVar3 != 0)) {
    wVar2 = SystemCharset;
    wVar1 = InnerCharset;
    p_Var4 = Strnew_charp(str);
    p_Var4 = wc_Str_conv_strict(p_Var4,wVar1,wVar2);
    fprintf((FILE *)migemow,"%s\n",p_Var4->ptr);
    do {
      iVar3 = fflush((FILE *)migemow);
      wVar2 = SystemCharset;
      wVar1 = InnerCharset;
      if (iVar3 == 0) {
        p_Var4 = Strfgets(migemor);
        p_Var4 = wc_Str_conv(p_Var4,wVar2,wVar1);
        Strchop(p_Var4);
        if (p_Var4->length != 0) {
          pcVar6 = conv_search_string(p_Var4->ptr,SystemCharset);
          return pcVar6;
        }
        break;
      }
      piVar5 = __errno_location();
    } while (*piVar5 == 4);
    init_migemo();
    migemo_running = 0;
    migemo_active = 0;
  }
  return str;
}



char * conv_search_string(char *str,wc_ces f_ces)

{
  if (((SearchConv != '\0') && (WcOption.pre_conv == '\0')) &&
     (CurrentTab->currentBuffer->document_charset != f_ces)) {
    str = wtf_conv_fit(str,CurrentTab->currentBuffer->document_charset);
  }
  return str;
}



int forwardSearch(Buffer *buf,char *str)

{
  bool bVar1;
  Line *pLVar2;
  char *ex;
  int iVar3;
  int pos;
  int wrapped;
  Line *begin;
  Line *l;
  char *last;
  char *first;
  char *p;
  
  iVar3 = IgnoreCase;
  bVar1 = false;
  if (migemo_active < 1) {
    p = regexCompile(str,IgnoreCase);
    if (p != (char *)0x0) {
      message(p,0,0);
      return 2;
    }
  }
  else {
    ex = migemostr(str);
    p = regexCompile(ex,iVar3);
    if ((p != (char *)0x0) && (p = regexCompile(str,IgnoreCase), p != (char *)0x0)) {
      message(p,0,0);
      return 2;
    }
  }
  l = buf->currentLine;
  if (l == (Line *)0x0) {
    return 2;
  }
  pos = buf->pos;
  if (l->bpos != 0) {
    pos = pos + l->bpos;
    for (; (l->bpos != 0 && (l->prev != (_Line *)0x0)); l = l->prev) {
    }
  }
  for (; (pLVar2 = l, pos < l->size && ((l->propBuf[pos] & 0x400) != 0)); pos = pos + 1) {
  }
  if ((pos < l->size) && (iVar3 = regexMatch(l->lineBuf + pos,l->size - pos,0), iVar3 == 1)) {
    matchedPosition(&first,&last);
    pos = (int)first - (int)l->lineBuf;
    while (((l->len <= pos && (l->next != (_Line *)0x0)) && (l->next->bpos != 0))) {
      pos = pos - l->len;
      l = l->next;
    }
    buf->pos = pos;
    if (buf->currentLine != l) {
      gotoLine(buf,l->linenumber);
    }
    arrangeCursor(buf);
    set_mark(l,pos,(int)(last + (pos - (int)first)));
    return 1;
  }
  l = l->next;
  do {
    if (l == (Line *)0x0) {
      if (buf->pagerSource == (InputStream)0x0) {
        if (WrapSearch == 0) {
          return 2;
        }
        l = buf->firstLine;
        bVar1 = true;
      }
      else {
        l = getNextPage(buf,1);
        if (l == (Line *)0x0) {
          if (WrapSearch == 0) {
            return 2;
          }
          if (bVar1) {
            return 2;
          }
          l = buf->firstLine;
          bVar1 = true;
        }
      }
    }
    if (l->bpos == 0) {
      iVar3 = regexMatch(l->lineBuf,l->size,1);
      if (iVar3 == 1) {
        matchedPosition(&first,&last);
        pos = (int)first - (int)l->lineBuf;
        while (((l->len <= pos && (l->next != (_Line *)0x0)) && (l->next->bpos != 0))) {
          pos = pos - l->len;
          l = l->next;
        }
        buf->pos = pos;
        buf->currentLine = l;
        gotoLine(buf,l->linenumber);
        arrangeCursor(buf);
        set_mark(l,pos,(int)(last + (pos - (int)first)));
        if (!bVar1) {
          return 1;
        }
        return 5;
      }
      if ((bVar1) && (l == pLVar2)) {
        return 2;
      }
    }
    l = l->next;
  } while( true );
}



// WARNING: Type propagation algorithm not settling

int backwardSearch(Buffer *buf,char *str)

{
  bool bVar1;
  Line *pLVar2;
  char *ex;
  int iVar3;
  int pos;
  int wrapped;
  Line *begin;
  Line *l;
  char *last;
  char *first;
  char *found_last;
  char *found;
  char *q;
  char *p;
  
  iVar3 = IgnoreCase;
  bVar1 = false;
  if (migemo_active < 1) {
    p = regexCompile(str,IgnoreCase);
    if (p != (char *)0x0) {
      message(p,0,0);
      return 2;
    }
  }
  else {
    ex = migemostr(str);
    p = regexCompile(ex,iVar3);
    if ((p != (char *)0x0) && (p = regexCompile(str,IgnoreCase), p != (char *)0x0)) {
      message(p,0,0);
      return 2;
    }
  }
  l = buf->currentLine;
  if (l == (Line *)0x0) {
    return 2;
  }
  pos = buf->pos;
  if (l->bpos != 0) {
    pos = pos + l->bpos;
    for (; (l->bpos != 0 && (l->prev != (_Line *)0x0)); l = l->prev) {
    }
  }
  pLVar2 = l;
  if (0 < pos) {
    do {
      pos = pos + -1;
      if (pos < 1) break;
    } while ((l->propBuf[pos] & 0x400) != 0);
    p = l->lineBuf + pos;
    found = (char *)0x0;
    found_last = (char *)0x0;
    q = l->lineBuf;
    do {
      iVar3 = regexMatch(q,(int)(l->lineBuf + (l->size - (int)q)),(uint)(l->lineBuf == q));
      if (iVar3 != 1) break;
      matchedPosition(&first,&last);
      if (first <= p) {
        found = first;
        found_last = last;
      }
      if (l->size <= (int)q - (int)l->lineBuf) break;
      do {
        q = q + 1;
        if (l->size <= (int)q - (int)l->lineBuf) break;
      } while ((l->propBuf[(int)q - (int)l->lineBuf] & 0x400) != 0);
    } while (q <= p);
    if (found != (char *)0x0) {
      pos = (int)found - (int)l->lineBuf;
      while (((l->len <= pos && (l->next != (_Line *)0x0)) && (l->next->bpos != 0))) {
        pos = pos - l->len;
        l = l->next;
      }
      buf->pos = pos;
      if (buf->currentLine != l) {
        gotoLine(buf,l->linenumber);
      }
      arrangeCursor(buf);
      set_mark(l,pos,(int)(found_last + (pos - (int)found)));
      return 1;
    }
  }
  l = l->prev;
  do {
    if (l == (Line *)0x0) {
      if (WrapSearch == 0) {
        return 2;
      }
      l = buf->lastLine;
      bVar1 = true;
    }
    found = (char *)0x0;
    found_last = (char *)0x0;
    q = l->lineBuf;
LAB_0807d10a:
    iVar3 = regexMatch(q,(int)(l->lineBuf + (l->size - (int)q)),(uint)(l->lineBuf == q));
    if (iVar3 == 1) {
      matchedPosition(&first,&last);
      found = first;
      found_last = last;
      if (l->size <= (int)q - (int)l->lineBuf) goto LAB_0807d150;
      do {
        q = q + 1;
        if (l->size <= (int)q - (int)l->lineBuf) break;
      } while ((l->propBuf[(int)q - (int)l->lineBuf] & 0x400) != 0);
      goto LAB_0807d10a;
    }
LAB_0807d150:
    if (found != (char *)0x0) {
      pos = (int)found - (int)l->lineBuf;
      while (((l->len <= pos && (l->next != (_Line *)0x0)) && (l->next->bpos != 0))) {
        pos = pos - l->len;
        l = l->next;
      }
      buf->pos = pos;
      gotoLine(buf,l->linenumber);
      arrangeCursor(buf);
      set_mark(l,pos,(int)(found_last + (pos - (int)found)));
      if (!bVar1) {
        return 1;
      }
      return 5;
    }
    if ((bVar1) && (l == pLVar2)) {
      return 2;
    }
    l = l->prev;
  } while( true );
}



char * inputLineHistSearch(char *prompt,char *def_str,int flag,Hist *hist,
                          anon_subr_int_int_Str_Lineprop_ptr *incrfunc)

{
  int iVar1;
  int iVar2;
  wc_ces t_ces;
  int iVar3;
  wc_ces f_ces;
  int iVar4;
  int iVar5;
  uint uVar6;
  Str str;
  char *pcVar7;
  char *q;
  Str tmp;
  char *p;
  int epos;
  int rpos;
  int lpos;
  int y;
  int x;
  int opos;
  uchar c;
  
  is_passwd = 0;
  move_word = 1;
  CurrentHist = hist;
  if (hist != (Hist *)0x0) {
    strCurrentBuf = (Str)0x0;
  }
  use_hist = (int)(hist != (Hist *)0x0);
  if ((flag & 0x100U) == 0) {
    if ((flag & 0x20U) == 0) {
      if ((flag & 0x40U) == 0) {
        if ((flag & 0x80U) == 0) {
          cm_mode = 1;
        }
        else {
          cm_mode = 2;
        }
      }
      else {
        cm_mode = 0;
        is_passwd = 1;
        move_word = 0;
      }
    }
    else {
      cm_mode = 4;
    }
  }
  else {
    cm_mode = 0xc;
  }
  iVar3 = wtf_strwidth((wc_uchar *)prompt);
  epos = (COLS + -2) - iVar3;
  if (epos < 0) {
    epos = 0;
  }
  iVar1 = epos / 3;
  iVar2 = (epos * 2) / 3;
  offset = 0;
  if (def_str == (char *)0x0) {
    strBuf = Strnew();
    CLen = 0;
  }
  else {
    strBuf = Strnew_charp(def_str);
    CLen = setStrType(strBuf,strProp);
  }
  t_ces = InnerCharset;
  i_cont = 1;
  i_broken = 0;
  i_quote = 0;
  cm_next = 0;
  cm_disp_next = -1;
  need_redraw = 0;
  CPos = CLen;
  f_ces = wc_guess_8bit_charset(DisplayCharset);
  wc_char_conv_init(f_ces,t_ces);
  do {
    iVar4 = calcPosition(strBuf->ptr,strProp,CLen,CPos,0,1);
    if (offset < iVar4 - iVar2) {
      iVar5 = calcPosition(strBuf->ptr,strProp,CLen,CLen,0,0);
      if (iVar4 - iVar2 < iVar5 - epos) {
        offset = iVar4 - iVar2;
      }
      else if (iVar5 != epos && -1 < iVar5 - epos) {
        offset = iVar5 - epos;
      }
    }
    else if (iVar4 - iVar1 < offset) {
      if (iVar4 == iVar1 || iVar4 - iVar1 < 0) {
        offset = 0;
      }
      else {
        offset = iVar4 - iVar1;
      }
    }
    move(LINES + -1,0);
    addstr(prompt);
    if (is_passwd == 0) {
      addStr(strBuf->ptr,strProp,CLen,offset,COLS - iVar3);
    }
    else {
      addPasswd(strBuf->ptr,strProp,CLen,offset,COLS - iVar3);
    }
    clrtoeolx();
    move(LINES + -1,(iVar3 + iVar4) - offset);
    refresh();
next_char:
    do {
      uVar6 = do_getch();
      c = (uchar)uVar6;
      cm_clear = 1;
      cm_disp_clear = 1;
      if ((i_quote == 0) &&
         ((((cm_mode & 4U) != 0 && ((c == 9 || (c == 0x20)))) || (((cm_mode & 2U) != 0 && (c == 9)))
          ))) {
        if ((emacs_like_lineedit == 0) || (cm_next == 0)) {
          _compl();
          cm_disp_next = -1;
        }
        else {
          _dcompl();
          need_redraw = 1;
        }
        goto LAB_0807d862;
      }
      if ((((i_quote == 0) && (CLen == CPos)) && (((cm_mode & 4U) != 0 || ((cm_mode & 2U) != 0))))
         && (c == 4)) {
        if (emacs_like_lineedit == 0) {
          _dcompl();
          need_redraw = 1;
        }
        goto LAB_0807d862;
      }
      if ((i_quote == 0) && (c == 0x7f)) {
        _bs();
        cm_next = 0;
        cm_disp_next = -1;
        goto LAB_0807d862;
      }
      if ((i_quote == 0) && (c < 0x20)) {
        if (incrfunc == (anon_subr_int_int_Str_Lineprop_ptr *)0x0) {
LAB_0807d750:
          (*InputKeymap[c])((uint)c);
        }
        else {
          iVar4 = (*incrfunc)(uVar6 & 0xff,strBuf,strProp);
          c = (uchar)iVar4;
          if (c < 0x20) goto LAB_0807d750;
        }
        if (((incrfunc != (anon_subr_int_int_Str_Lineprop_ptr *)0x0) && (c != 0xff)) && (c != '\n'))
        {
          (*incrfunc)(-1,strBuf,strProp);
        }
        if (cm_clear != 0) {
          cm_next = 0;
        }
        if (cm_disp_clear != 0) {
          cm_disp_next = -1;
        }
        goto LAB_0807d862;
      }
      str = wc_char_conv(c);
      if (str == (Str)0x0) {
        i_quote = 1;
        goto next_char;
      }
      i_quote = 0;
      cm_next = 0;
      cm_disp_next = -1;
    } while ((0x400 < str->length + CLen) || (str->length == 0));
    ins_char(str);
    if (incrfunc != (anon_subr_int_int_Str_Lineprop_ptr *)0x0) {
      (*incrfunc)(-1,strBuf,strProp);
    }
LAB_0807d862:
    if (((CLen != 0) && ((flag & 0x200U) != 0)) || (i_cont == 0)) {
      if ((CurrentTab != (TabBuffer *)0x0) && (need_redraw != 0)) {
        displayBuffer(CurrentTab->currentBuffer,1);
      }
      if (i_broken == 0) {
        move(LINES + -1,0);
        refresh();
        p = strBuf->ptr;
        if ((flag & 0xa0U) != 0) {
          while ((*p != '\0' && ((MYCTYPE_MAP[(byte)*p] & 2) != 0))) {
            p = p + 1;
          }
        }
        if ((((use_hist != 0) && ((flag & 0x100U) == 0)) && (*p != '\0')) &&
           ((pcVar7 = lastHist(hist), pcVar7 == (char *)0x0 ||
            (iVar3 = strcmp(pcVar7,p), iVar3 != 0)))) {
          pushHist(hist,p);
        }
        if ((flag & 0x20U) == 0) {
          pcVar7 = allocStr(p,-1);
        }
        else {
          pcVar7 = expandPath(p);
        }
      }
      else {
        pcVar7 = (char *)0x0;
      }
      return pcVar7;
    }
  } while( true );
}



void addPasswd(char *p,Lineprop *pr,int len,int offset,int limit)

{
  int ncol;
  int rcol;
  
  rcol = 0;
  ncol = calcPosition(p,pr,len,len,0,0);
  if (offset + limit < ncol) {
    ncol = offset + limit;
  }
  if (offset != 0) {
    addChar('{',0);
    rcol = offset + 1;
  }
  for (; rcol < ncol; rcol = rcol + 1) {
    addChar('*',0);
  }
  return;
}



void addStr(char *p,Lineprop *pr,int len,int offset,int limit)

{
  int iVar1;
  size_t len_00;
  int delta;
  int ncol;
  int rcol;
  int i;
  
  i = 0;
  rcol = 0;
  if (offset != 0) {
    i = 0;
    while ((i < len && (iVar1 = calcPosition(p,pr,len,i,0,0), iVar1 <= offset))) {
      i = i + 1;
    }
    if (len <= i) {
      return;
    }
    for (; (pr[i] & 0x400) != 0; i = i + 1) {
    }
    addChar('{',0);
    rcol = offset + 1;
    iVar1 = calcPosition(p,pr,len,i,0,0);
    for (; rcol < iVar1; rcol = rcol + 1) {
      addChar(' ',0);
    }
  }
  while( true ) {
    if (len <= i) {
      return;
    }
    len_00 = wtf_len((wc_uchar *)(p + i));
    iVar1 = calcPosition(p,pr,len,i + len_00,0,0);
    if (limit < iVar1 - offset) break;
    if (p[i] == '\t') {
      for (; rcol < iVar1; rcol = rcol + 1) {
        addChar(' ',0);
      }
    }
    else {
      addMChar(p + i,pr[i],len_00);
      rcol = iVar1;
    }
    i = i + len_00;
  }
  return;
}



void ins_char(Str str)

{
  byte bVar1;
  char *pcVar2;
  bool bVar3;
  int len;
  char *ep;
  char *p;
  Lineprop ctype;
  
  p = str->ptr;
  pcVar2 = p + str->length;
  if (str->length + CLen < 0x400) {
    while (p < pcVar2) {
      bVar1 = WTF_LEN_MAP[(byte)*p];
      ctype = (ushort)WTF_TYPE_MAP[(byte)*p] << 8;
      if (is_passwd != 0) {
        if ((ctype & 0x100) != 0) {
          ctype = 0;
        }
        if ((ctype & 0x1000) != 0) {
          ctype = 0x200;
        }
      }
      insC();
      strBuf->ptr[CPos] = *p;
      p = p + 1;
      strProp[CPos] = ctype;
      CPos = CPos + 1;
      len = bVar1 - 1;
      if (len != 0) {
        while (bVar3 = len != 0, len = len + -1, bVar3) {
          insC();
          strBuf->ptr[CPos] = *p;
          p = p + 1;
          strProp[CPos] = (ushort)((byte)((uint)ctype >> 8) & 0xf9) << 8 | 0x400;
          CPos = CPos + 1;
        }
      }
    }
  }
  return;
}



void _esc(void)

{
  char cVar1;
  int iVar2;
  Str p_Var3;
  char c;
  
  iVar2 = do_getch();
  cVar1 = (char)iVar2;
  if (cVar1 != ' ') {
    if (' ' < cVar1) {
      if (cVar1 == '[') {
LAB_0807dde7:
        iVar2 = do_getch();
        cVar1 = (char)iVar2;
        if (cVar1 == 'B') {
          _next();
          return;
        }
        if (cVar1 < 'C') {
          if (cVar1 != 'A') {
            return;
          }
          _prev();
          return;
        }
        if (cVar1 == 'C') {
          _mvR();
          return;
        }
        if (cVar1 != 'D') {
          return;
        }
        _mvL();
        return;
      }
      if (cVar1 < '\\') {
        if (cVar1 == 'O') goto LAB_0807dde7;
      }
      else {
        if (cVar1 == 'b') {
          if (emacs_like_lineedit == 0) {
            return;
          }
          _mvLw();
          return;
        }
        if (cVar1 == 'f') {
          if (emacs_like_lineedit == 0) {
            return;
          }
          _mvRw();
          return;
        }
      }
LAB_0807deb2:
      p_Var3 = wc_char_conv('\x1b');
      if (p_Var3 != (Str)0x0) {
        return;
      }
      p_Var3 = wc_char_conv(cVar1);
      if (p_Var3 != (Str)0x0) {
        return;
      }
      i_quote = 1;
      return;
    }
    if (cVar1 == '\b') {
      if (emacs_like_lineedit == 0) {
        return;
      }
      _bsw();
      return;
    }
    if (cVar1 != '\t') {
      if (cVar1 == '\x04') {
        if (emacs_like_lineedit == 0) {
          _rdcompl();
        }
        need_redraw = 1;
        return;
      }
      goto LAB_0807deb2;
    }
  }
  if (emacs_like_lineedit == 0) {
    _rcompl();
  }
  else {
    _rdcompl();
    cm_clear = 0;
    need_redraw = 1;
  }
  return;
}



void insC(void)

{
  int i;
  
  Strinsert_char(strBuf,CPos,' ');
  CLen = strBuf->length;
  for (i = CLen; CPos < i; i = i + -1) {
    strProp[i] = *(Lineprop *)(i * 2 + 0x817ca5e);
  }
  return;
}



void delC(void)

{
  int delta;
  int i;
  
  delta = 1;
  if (CLen != CPos) {
    while ((CPos + delta < CLen && ((strProp[CPos + delta] & 0x400) != 0))) {
      delta = delta + 1;
    }
    for (i = CPos; i < CLen; i = i + 1) {
      strProp[i] = strProp[i + delta];
    }
    Strdelete(strBuf,CPos,delta);
    CLen = CLen - delta;
  }
  return;
}



void _mvL(void)

{
  if (0 < CPos) {
    CPos = CPos + -1;
  }
  for (; (0 < CPos && ((strProp[CPos] & 0x400) != 0)); CPos = CPos + -1) {
  }
  return;
}



void _mvLw(void)

{
  bool bVar1;
  int iVar2;
  int first;
  
  bVar1 = true;
  while( true ) {
    if (CPos < 1) {
      return;
    }
    if ((!bVar1) && (iVar2 = terminated(strBuf->ptr[CPos + -1]), iVar2 != 0)) break;
    iVar2 = CPos + -1;
    bVar1 = false;
    if ((0 < iVar2) && ((strProp[iVar2] & 0x400) != 0)) {
      iVar2 = CPos + -2;
    }
    CPos = iVar2;
    if (move_word == 0) {
      return;
    }
  }
  return;
}



void _mvRw(void)

{
  bool bVar1;
  int iVar2;
  int first;
  
  bVar1 = true;
  while( true ) {
    if (CLen <= CPos) {
      return;
    }
    if ((!bVar1) && (iVar2 = terminated(strBuf->ptr[CPos + -1]), iVar2 != 0)) break;
    iVar2 = CPos + 1;
    bVar1 = false;
    if ((iVar2 < CLen) && ((strProp[iVar2] & 0x400) != 0)) {
      iVar2 = CPos + 2;
    }
    CPos = iVar2;
    if (move_word == 0) {
      return;
    }
  }
  return;
}



void _mvR(void)

{
  if (CPos < CLen) {
    CPos = CPos + 1;
  }
  for (; (CPos < CLen && ((strProp[CPos] & 0x400) != 0)); CPos = CPos + 1) {
  }
  return;
}



void _bs(void)

{
  if (0 < CPos) {
    _mvL();
    delC();
  }
  return;
}



void _bsw(void)

{
  bool bVar1;
  int iVar2;
  int t;
  
  bVar1 = false;
  do {
    if ((CPos < 1) || (bVar1)) {
      return;
    }
    _mvL();
    if (move_word == 0) {
LAB_0807e24e:
      bVar1 = false;
    }
    else {
      iVar2 = terminated(strBuf->ptr[CPos + -1]);
      if (iVar2 == 0) goto LAB_0807e24e;
      bVar1 = true;
    }
    delC();
  } while( true );
}



void _enter(void)

{
  i_cont = 0;
  return;
}



void insertself(char c)

{
  Lineprop LVar1;
  
  if (CLen < 0x400) {
    insC();
    strBuf->ptr[CPos] = c;
    if (is_passwd == 0) {
      LVar1 = 0x100;
    }
    else {
      LVar1 = 0;
    }
    strProp[CPos] = LVar1;
    CPos = CPos + 1;
  }
  return;
}



void _quo(void)

{
  i_quote = 1;
  return;
}



void _mvB(void)

{
  CPos = 0;
  return;
}



void _mvE(void)

{
  CPos = CLen;
  return;
}



void killn(void)

{
  CLen = CPos;
  Strtruncate(strBuf,CPos);
  return;
}



void killb(void)

{
  while (0 < CPos) {
    _bs();
  }
  return;
}



void _inbrk(void)

{
  i_cont = 0;
  i_broken = 1;
  return;
}



void _compl(void)

{
  next_compl(1);
  return;
}



void _rcompl(void)

{
  next_compl(-1);
  return;
}



void _tcompl(void)

{
  if ((cm_mode & 1U) == 0) {
    if ((cm_mode & 2U) != 0) {
      cm_mode = 1;
    }
  }
  else {
    cm_mode = 2;
  }
  return;
}



void next_compl(int next)

{
  int beg;
  Str ifn;
  Str s;
  Str buf;
  int a;
  int b;
  int status;
  
  beg = CPos;
  if ((cm_mode != 0) && ((cm_mode & 1U) == 0)) {
    cm_clear = 0;
    if (cm_next == 0) {
      if ((cm_mode & 4U) == 0) {
        for (b = CPos + -1;
            (-1 < b &&
            (((strBuf->ptr[b] != ' ' && (strBuf->ptr[b] != '\t')) ||
             ((0 < b && (strBuf->ptr[b + -1] == '\\')))))); b = b + -1) {
        }
        b = b + 1;
      }
      else {
        b = 0;
      }
      CBeforeBuf = Strsubstr(strBuf,0,b);
      ifn = Strsubstr(strBuf,b,beg - b);
      CAfterBuf = Strsubstr(strBuf,beg,strBuf->length - beg);
      s = doComplete(ifn,&status,next);
    }
    else {
      s = doComplete(strBuf,&status,next);
    }
    if (next != 0) {
      if ((status != 0) && (status != 3)) {
        bell();
      }
      if (status != 2) {
        strBuf = Strnew_m_charp(CBeforeBuf->ptr,s->ptr,CAfterBuf->ptr,0);
        CLen = setStrType(strBuf,strProp);
        CPos = CBeforeBuf->length + s->length;
        if (CLen < CPos) {
          CPos = CLen;
        }
      }
    }
  }
  return;
}



void _dcompl(void)

{
  next_dcompl(1);
  return;
}



void _rdcompl(void)

{
  next_dcompl(-1);
  return;
}



void next_dcompl(int next)

{
  bool bVar1;
  wc_ces wVar2;
  wc_ces wVar3;
  size_t sVar4;
  int iVar5;
  Str p_Var6;
  Str p_Var7;
  char *__file;
  stat st;
  int nline;
  int comment;
  char *p;
  Str f;
  int y;
  int n;
  int j;
  int i;
  
  if ((cm_mode != 0) && ((cm_mode & 1U) == 0)) {
    cm_disp_clear = 0;
    if (CurrentTab != (TabBuffer *)0x0) {
      displayBuffer(CurrentTab->currentBuffer,1);
    }
    if (LINES + -1 < 3) {
      if (LINES == 1) {
        return;
      }
      bVar1 = false;
      nline = LINES + -1;
    }
    else {
      bVar1 = true;
      nline = LINES + -3;
    }
    if (cm_disp_next < 0) {
      cm_next = 0;
      next_compl(0);
      wVar3 = SystemCharset;
      wVar2 = InnerCharset;
      if (NCFileBuf == 0) {
        return;
      }
      cm_disp_next = 0;
      p_Var6 = Strdup(CDirBuf);
      next_dcompl::d = wc_Str_conv_strict(p_Var6,wVar2,wVar3);
      if ((0 < next_dcompl::d->length) &&
         ((next_dcompl::d->length < 1 || (next_dcompl::d->ptr[next_dcompl::d->length + -1] != '/')))
         ) {
        if (next_dcompl::d->area_size <= next_dcompl::d->length + 1) {
          Strgrow(next_dcompl::d);
        }
        p_Var6 = next_dcompl::d;
        iVar5 = next_dcompl::d->length;
        next_dcompl::d->ptr[iVar5] = '/';
        p_Var6->length = iVar5 + 1;
        next_dcompl::d->ptr[next_dcompl::d->length] = '\0';
      }
      if (((cm_mode & 8U) != 0) && (*next_dcompl::d->ptr == 'f')) {
        p = next_dcompl::d->ptr;
        iVar5 = strncmp(p,"file://localhost/",0x11);
        if (iVar5 == 0) {
          p = p + 0x10;
        }
        else {
          iVar5 = strncmp(p,"file:///",8);
          if (iVar5 == 0) {
            p = p + 7;
          }
          else {
            iVar5 = strncmp(p,"file:/",6);
            if ((iVar5 == 0) && (p[6] != '/')) {
              p = p + 5;
            }
          }
        }
        next_dcompl::d = Strnew_charp(p);
      }
      next_dcompl::len = 0;
      for (i = 0; i < NCFileBuf; i = i + 1) {
        sVar4 = strlen(CFileBuf[i]);
        if (next_dcompl::len < (int)(sVar4 + 3)) {
          next_dcompl::len = sVar4 + 3;
        }
      }
      next_dcompl::col = COLS / next_dcompl::len;
      if (next_dcompl::col == 0) {
        next_dcompl::col = 1;
      }
      next_dcompl::row = (NCFileBuf + next_dcompl::col + -1) / next_dcompl::col;
    }
    else {
      if (next == 1) {
        cm_disp_next = next_dcompl::col * nline + cm_disp_next;
        if (NCFileBuf <= cm_disp_next) {
          cm_disp_next = 0;
        }
      }
      else if ((next == -1) &&
              (cm_disp_next = cm_disp_next - next_dcompl::col * nline, cm_disp_next < 0)) {
        cm_disp_next = 0;
      }
      next_dcompl::row = ((NCFileBuf - cm_disp_next) + next_dcompl::col + -1) / next_dcompl::col;
    }
    if (bVar1) {
      if (nline < next_dcompl::row) {
        next_dcompl::row = nline;
        y = 0;
      }
      else {
        y = (nline - next_dcompl::row) + 1;
      }
    }
    else if (next_dcompl::row < nline) {
      y = (nline - next_dcompl::row) + -1;
    }
    else {
      next_dcompl::row = nline;
      y = 0;
    }
    if (y != 0) {
      move(y + -1,0);
      clrtoeolx();
    }
    if (bVar1) {
      move(y,0);
      clrtoeolx();
      bold();
      addstr("----- Completion list -----");
      boldend();
      y = y + 1;
    }
    for (i = 0; i < next_dcompl::row; i = i + 1) {
      for (j = 0; (j < next_dcompl::col &&
                  (iVar5 = next_dcompl::row * j + cm_disp_next + i, iVar5 < NCFileBuf)); j = j + 1)
      {
        move(y,next_dcompl::len * j);
        clrtoeolx();
        p_Var6 = Strdup(next_dcompl::d);
        Strcat_charp(p_Var6,CFileBuf[iVar5]);
        wVar3 = SystemCharset;
        wVar2 = InnerCharset;
        p_Var7 = Strnew_charp(CFileBuf[iVar5]);
        p_Var7 = wc_Str_conv(p_Var7,wVar3,wVar2);
        addstr(p_Var7->ptr);
        __file = expandPath(p_Var6->ptr);
        iVar5 = stat(__file,(stat *)&st);
        if ((iVar5 != -1) && ((st.st_mode & 0xf000) == 0x4000)) {
          addstr("/");
        }
      }
      y = y + 1;
    }
    if ((bVar1) && (LINES + -2 == y)) {
      move(y,0);
      clrtoeolx();
      bold();
      if (emacs_like_lineedit == 0) {
        addstr("----- Press CTRL-D to continue -----");
      }
      else {
        addstr("----- Press TAB to continue -----");
      }
      boldend();
    }
  }
  return;
}



Str escape_spaces(Str s)

{
  int iVar1;
  char *p;
  Str tmp;
  
  tmp = (Str)0x0;
  if (s != (Str)0x0) {
    for (p = s->ptr; *p != '\0'; p = p + 1) {
      if ((*p == ' ') || (*p == '\t')) {
        if (tmp == (Str)0x0) {
          tmp = Strnew_charp_n(s->ptr,(int)p - (int)s->ptr);
        }
        if (tmp->area_size <= tmp->length + 1) {
          Strgrow(tmp);
        }
        iVar1 = tmp->length;
        tmp->ptr[iVar1] = '\\';
        tmp->length = iVar1 + 1;
        tmp->ptr[tmp->length] = '\0';
      }
      if (tmp != (Str)0x0) {
        if (tmp->area_size <= tmp->length + 1) {
          Strgrow(tmp);
        }
        iVar1 = tmp->length;
        tmp->ptr[iVar1] = *p;
        tmp->length = iVar1 + 1;
        tmp->ptr[tmp->length] = '\0';
      }
    }
    if (tmp != (Str)0x0) {
      s = tmp;
    }
  }
  return s;
}



Str unescape_spaces(Str s)

{
  int iVar1;
  char *p;
  Str tmp;
  
  tmp = (Str)0x0;
  if (s != (Str)0x0) {
    for (p = s->ptr; *p != '\0'; p = p + 1) {
      if ((*p == '\\') && ((p[1] == ' ' || (p[1] == '\t')))) {
        if (tmp == (Str)0x0) {
          tmp = Strnew_charp_n(s->ptr,(int)p - (int)s->ptr);
        }
      }
      else if (tmp != (Str)0x0) {
        if (tmp->area_size <= tmp->length + 1) {
          Strgrow(tmp);
        }
        iVar1 = tmp->length;
        tmp->ptr[iVar1] = *p;
        tmp->length = iVar1 + 1;
        tmp->ptr[tmp->length] = '\0';
      }
    }
    if (tmp != (Str)0x0) {
      s = tmp;
    }
  }
  return s;
}



Str doComplete(Str ifn,int *status,int next)

{
  char **ppcVar1;
  int iVar2;
  char *pcVar3;
  DIR *__dirp;
  size_t __n;
  dirent *pdVar4;
  size_t sVar5;
  char *pcVar6;
  Str p_Var7;
  stat st;
  Directory *dir;
  DIR *d;
  char *p;
  char *fn;
  int i;
  int fl;
  
  if (cm_next == 0) {
    NCFileBuf = 0;
    ifn = wc_Str_conv_strict(ifn,InnerCharset,SystemCharset);
    if ((cm_mode & 2U) != 0) {
      ifn = unescape_spaces(ifn);
    }
    CompleteBuf = Strdup(ifn);
    while (((CompleteBuf->length < 1 || (CompleteBuf->ptr[CompleteBuf->length + -1] != '/')) &&
           (0 < CompleteBuf->length))) {
      Strshrink(CompleteBuf,1);
    }
    CDirBuf = Strdup(CompleteBuf);
    if ((cm_mode & 8U) != 0) {
      iVar2 = strncmp(CompleteBuf->ptr,"file://localhost/",0x11);
      if (iVar2 == 0) {
        Strdelete(CompleteBuf,0,0x10);
      }
      else {
        iVar2 = strncmp(CompleteBuf->ptr,"file:///",8);
        if (iVar2 == 0) {
          Strdelete(CompleteBuf,0,7);
        }
        else {
          iVar2 = strncmp(CompleteBuf->ptr,"file:/",6);
          if ((iVar2 != 0) || (CompleteBuf->ptr[6] == '/')) {
            CompleteBuf = Strdup(ifn);
            *status = 2;
            p_Var7 = wc_Str_conv_strict(CompleteBuf,InnerCharset,SystemCharset);
            return p_Var7;
          }
          Strdelete(CompleteBuf,0,5);
        }
      }
    }
    if (CompleteBuf->length == 0) {
      if (CompleteBuf->area_size <= CompleteBuf->length + 1) {
        Strgrow(CompleteBuf);
      }
      p_Var7 = CompleteBuf;
      iVar2 = CompleteBuf->length;
      CompleteBuf->ptr[iVar2] = '.';
      p_Var7->length = iVar2 + 1;
      CompleteBuf->ptr[CompleteBuf->length] = '\0';
    }
    if (((0 < CompleteBuf->length) && (CompleteBuf->ptr[CompleteBuf->length + -1] == '/')) &&
       (1 < CompleteBuf->length)) {
      Strshrink(CompleteBuf,1);
    }
    pcVar3 = expandPath(CompleteBuf->ptr);
    __dirp = opendir(pcVar3);
    if (__dirp == (DIR *)0x0) {
      CompleteBuf = Strdup(ifn);
      *status = 2;
      if ((cm_mode & 2U) == 0) {
        return CompleteBuf;
      }
      CompleteBuf = escape_spaces(CompleteBuf);
      return CompleteBuf;
    }
    pcVar3 = lastFileName(ifn->ptr);
    __n = strlen(pcVar3);
    CFileName = Strnew();
    while (pdVar4 = readdir(__dirp), pdVar4 != (dirent *)0x0) {
      if (((__n != 0) ||
          ((iVar2 = strcmp(pdVar4->d_name,"."), iVar2 != 0 &&
           (iVar2 = strcmp(pdVar4->d_name,".."), iVar2 != 0)))) &&
         (iVar2 = strncmp(pdVar4->d_name,pcVar3,__n), iVar2 == 0)) {
        NCFileBuf = NCFileBuf + 1;
        CFileBuf = (char **)GC_realloc(CFileBuf,NCFileBuf * 4);
        ppcVar1 = CFileBuf + NCFileBuf + -1;
        sVar5 = strlen(pdVar4->d_name);
        pcVar6 = (char *)GC_malloc_atomic(sVar5 + 1);
        *ppcVar1 = pcVar6;
        strcpy(CFileBuf[NCFileBuf + -1],pdVar4->d_name);
        if (NCFileBuf == 1) {
          CFileName = Strnew_charp(pdVar4->d_name);
        }
        else {
          for (i = 0; CFileName->ptr[i] == pdVar4->d_name[i]; i = i + 1) {
          }
          Strtruncate(CFileName,i);
        }
      }
    }
    closedir(__dirp);
    if (NCFileBuf == 0) {
      CompleteBuf = Strdup(ifn);
      *status = 2;
      if ((cm_mode & 2U) == 0) {
        return CompleteBuf;
      }
      CompleteBuf = escape_spaces(CompleteBuf);
      return CompleteBuf;
    }
    qsort(CFileBuf,NCFileBuf,4,strCmp);
    NCFileOffset = 0;
    if (NCFileBuf < 2) {
      *status = 0;
    }
    else {
      cm_next = 1;
      *status = 1;
    }
  }
  else {
    CFileName = Strnew_charp(CFileBuf[NCFileOffset]);
    NCFileOffset = (NCFileOffset + next + NCFileBuf) % NCFileBuf;
    *status = 3;
  }
  CompleteBuf = Strdup(CDirBuf);
  if ((CompleteBuf->length != 0) &&
     ((CompleteBuf->length < 1 || (CompleteBuf->ptr[CompleteBuf->length + -1] != '/')))) {
    if (CompleteBuf->area_size <= CompleteBuf->length + 1) {
      Strgrow(CompleteBuf);
    }
    p_Var7 = CompleteBuf;
    iVar2 = CompleteBuf->length;
    CompleteBuf->ptr[iVar2] = '/';
    p_Var7->length = iVar2 + 1;
    CompleteBuf->ptr[CompleteBuf->length] = '\0';
  }
  Strcat(CompleteBuf,CFileName);
  if (*status != 1) {
    p = CompleteBuf->ptr;
    if ((cm_mode & 8U) != 0) {
      iVar2 = strncmp(p,"file://localhost/",0x11);
      if (iVar2 == 0) {
        p = p + 0x10;
      }
      else {
        iVar2 = strncmp(p,"file:///",8);
        if (iVar2 == 0) {
          p = p + 7;
        }
        else {
          iVar2 = strncmp(p,"file:/",6);
          if ((iVar2 == 0) && (p[6] != '/')) {
            p = p + 5;
          }
        }
      }
    }
    pcVar3 = expandPath(p);
    iVar2 = stat(pcVar3,(stat *)&st);
    if ((iVar2 != -1) && ((st.st_mode & 0xf000) == 0x4000)) {
      if (CompleteBuf->area_size <= CompleteBuf->length + 1) {
        Strgrow(CompleteBuf);
      }
      p_Var7 = CompleteBuf;
      iVar2 = CompleteBuf->length;
      CompleteBuf->ptr[iVar2] = '/';
      p_Var7->length = iVar2 + 1;
      CompleteBuf->ptr[CompleteBuf->length] = '\0';
    }
  }
  if ((cm_mode & 2U) != 0) {
    CompleteBuf = escape_spaces(CompleteBuf);
  }
  p_Var7 = wc_Str_conv(CompleteBuf,SystemCharset,InnerCharset);
  return p_Var7;
}



void _prev(void)

{
  char *p;
  Hist *hist;
  
  if (use_hist != 0) {
    if (strCurrentBuf == (Str)0x0) {
      p = lastHist(CurrentHist);
      if (p == (char *)0x0) {
        return;
      }
      strCurrentBuf = strBuf;
    }
    else {
      p = prevHist(CurrentHist);
      if (p == (char *)0x0) {
        return;
      }
    }
    if ((DecodeURL != 0) && ((cm_mode & 8U) != 0)) {
      p = url_unquote_conv(p,0);
    }
    strBuf = Strnew_charp(p);
    CPos = setStrType(strBuf,strProp);
    offset = 0;
    CLen = CPos;
  }
  return;
}



void _next(void)

{
  char *p;
  Hist *hist;
  
  if ((use_hist != 0) && (strCurrentBuf != (Str)0x0)) {
    p = nextHist(CurrentHist);
    if (p == (char *)0x0) {
      strBuf = strCurrentBuf;
      strCurrentBuf = (Str)0x0;
    }
    else {
      if ((DecodeURL != 0) && ((cm_mode & 8U) != 0)) {
        p = url_unquote_conv(p,0);
      }
      strBuf = Strnew_charp(p);
    }
    CPos = setStrType(strBuf,strProp);
    offset = 0;
    CLen = CPos;
  }
  return;
}



int setStrType(Str str,Lineprop *prop)

{
  char *pcVar1;
  uint uVar2;
  bool bVar3;
  int len;
  int i;
  char *ep;
  char *p;
  Lineprop ctype;
  
  p = str->ptr;
  pcVar1 = p + str->length;
  i = 0;
  while ((p < pcVar1 && (uVar2 = (uint)WTF_LEN_MAP[(byte)*p], (int)(i + uVar2) < 0x401))) {
    ctype = (ushort)WTF_TYPE_MAP[(byte)*p] << 8;
    if (is_passwd != 0) {
      if ((ctype & 0x100) != 0) {
        ctype = 0;
      }
      if ((ctype & 0x1000) != 0) {
        ctype = 0x200;
      }
    }
    prop[i] = ctype;
    i = i + 1;
    p = p + uVar2;
    len = uVar2 - 1;
    if (len != 0) {
      while (bVar3 = len != 0, len = len + -1, bVar3) {
        prop[i] = (ushort)((byte)((uint)ctype >> 8) & 0xf9) << 8 | 0x400;
        i = i + 1;
      }
    }
  }
  return i;
}



int terminated(uchar c)

{
  int termchar [5];
  int *tp;
  
  tp = termchar;
  while( true ) {
    if (*tp < 1) {
      return 0;
    }
    if ((uint)c == *tp) break;
    tp = tp + 1;
  }
  return 1;
}



void _editor(void)

{
  int iVar1;
  Str p_Var2;
  FormItemList fi;
  char *p;
  
  if (is_passwd == 0) {
    fi.readonly = 0;
    fi.value = Strdup(strBuf);
    if ((fi.value)->area_size <= (fi.value)->length + 1) {
      Strgrow(fi.value);
    }
    iVar1 = (fi.value)->length;
    (fi.value)->ptr[iVar1] = '\n';
    (fi.value)->length = iVar1 + 1;
    (fi.value)->ptr[(fi.value)->length] = '\0';
    input_textarea(&fi);
    strBuf = Strnew();
    for (p = (fi.value)->ptr; *p != '\0'; p = p + 1) {
      if ((*p != '\r') && (*p != '\n')) {
        if (strBuf->area_size <= strBuf->length + 1) {
          Strgrow(strBuf);
        }
        p_Var2 = strBuf;
        iVar1 = strBuf->length;
        strBuf->ptr[iVar1] = *p;
        p_Var2->length = iVar1 + 1;
        strBuf->ptr[strBuf->length] = '\0';
      }
    }
    CPos = setStrType(strBuf,strProp);
    CLen = CPos;
    if (CurrentTab != (TabBuffer *)0x0) {
      displayBuffer(CurrentTab->currentBuffer,1);
    }
  }
  return;
}



int LUfactor(Matrix A,int *indexarray)

{
  double dVar1;
  int n;
  int iVar2;
  double *pdVar3;
  Vector pvVar4;
  double tmp_2;
  double tmp;
  double mx;
  int tmp_1;
  Vector scale;
  int k_max;
  int i_max;
  int k;
  int j;
  int i;
  int dim;
  
  n = A->dim;
  pvVar4 = new_vector(n);
  for (i = 0; i < n; i = i + 1) {
    indexarray[i] = i;
  }
  for (i = 0; i < n; i = i + 1) {
    mx = 0.0;
    for (j = 0; j < n; j = j + 1) {
      if (mx < ABS(A->me[A->dim * i + j])) {
        mx = ABS(A->me[A->dim * i + j]);
      }
    }
    pvVar4->ve[i] = mx;
  }
  for (k = 0; k < n + -1; k = k + 1) {
    mx = 0.0;
    i_max = -1;
    for (i = k; i < n; i = i + 1) {
      if ((Tiny * ABS(A->me[A->dim * i + k]) <= ABS(pvVar4->ve[i])) &&
         (dVar1 = ABS(A->me[A->dim * i + k]) / pvVar4->ve[i], mx < dVar1)) {
        i_max = i;
        mx = dVar1;
      }
    }
    if (i_max == -1) {
      *(double *)((int)A->me + (A->dim + 1) * 8 * k) = 0.0;
    }
    else {
      i = k;
      if (i_max != k) {
        iVar2 = indexarray[i_max];
        indexarray[i_max] = indexarray[k];
        indexarray[k] = iVar2;
        for (j = 0; j < n; j = j + 1) {
          dVar1 = A->me[A->dim * i_max + j];
          A->me[A->dim * i_max + j] = A->me[A->dim * k + j];
          A->me[A->dim * k + j] = dVar1;
        }
      }
      while (i = i + 1, i < n) {
        pdVar3 = A->me;
        iVar2 = A->dim;
        pdVar3[iVar2 * i + k] =
             A->me[A->dim * i + k] / *(double *)((int)A->me + (A->dim + 1) * 8 * k);
        dVar1 = pdVar3[iVar2 * i + k];
        j = k;
        while (j = j + 1, j < n) {
          A->me[A->dim * i + j] = A->me[A->dim * i + j] - A->me[A->dim * k + j] * dVar1;
        }
      }
    }
  }
  return 0;
}



int LUsolve(Matrix A,int *indexarray,Vector b,Vector x)

{
  int iVar1;
  int dim;
  int i;
  
  iVar1 = A->dim;
  for (i = 0; i < iVar1; i = i + 1) {
    x->ve[i] = b->ve[indexarray[i]];
  }
  iVar1 = Lsolve(A,x,x,1.0);
  if ((iVar1 != -1) && (iVar1 = Usolve(A,x,x,0.0), iVar1 != -1)) {
    return 0;
  }
  return -1;
}



Matrix LUinverse(Matrix A,int *indexarray,Matrix out)

{
  int n;
  Vector b;
  Vector x;
  int iVar1;
  Vector tmp2;
  Vector tmp;
  int dim;
  int j;
  int i;
  
  n = A->dim;
  if (out == (Matrix)0x0) {
    out = new_matrix(n);
  }
  b = new_vector(n);
  x = new_vector(n);
  i = 0;
  while( true ) {
    if (n <= i) {
      return out;
    }
    for (j = 0; j < n; j = j + 1) {
      b->ve[j] = 0.0;
    }
    b->ve[i] = 1.0;
    iVar1 = LUsolve(A,indexarray,b,x);
    if (iVar1 == -1) break;
    for (j = 0; j < n; j = j + 1) {
      out->me[out->dim * j + i] = x->ve[j];
    }
    i = i + 1;
  }
  return (Matrix)0x0;
}



int Usolve(Matrix mat,Vector b,Vector out,double diag)

{
  int iVar1;
  double sum;
  int dim;
  int i_lim;
  int j;
  int i;
  
  i = mat->dim;
  while ((i = i + -1, iVar1 = i, -1 < i && (b->ve[i] == 0.0))) {
    out->ve[i] = 0.0;
  }
  do {
    if (i < 0) {
      return 0;
    }
    sum = b->ve[i];
    j = i;
    while (j = j + 1, j <= iVar1) {
      sum = sum - out->ve[j] * mat->me[mat->dim * i + j];
    }
    if (diag == 0.0) {
      if (ABS(*(double *)((int)mat->me + (mat->dim + 1) * 8 * i)) <= Tiny * ABS(sum)) {
        return -1;
      }
      out->ve[i] = sum / *(double *)((int)mat->me + (mat->dim + 1) * 8 * i);
    }
    else {
      out->ve[i] = sum / diag;
    }
    i = i + -1;
  } while( true );
}



int Lsolve(Matrix mat,Vector b,Vector out,double diag)

{
  int iVar1;
  int iVar2;
  double sum;
  int dim;
  int i_lim;
  int j;
  int i;
  
  iVar1 = mat->dim;
  for (i = 0; (iVar2 = i, i < iVar1 && (b->ve[i] == 0.0)); i = i + 1) {
    out->ve[i] = 0.0;
  }
  do {
    if (iVar1 <= i) {
      return 0;
    }
    sum = b->ve[i];
    for (j = iVar2; j < i; j = j + 1) {
      sum = sum - out->ve[j] * mat->me[mat->dim * i + j];
    }
    if (diag == 0.0) {
      if (ABS(*(double *)((int)mat->me + (mat->dim + 1) * 8 * i)) <= Tiny * ABS(sum)) {
        return -1;
      }
      out->ve[i] = sum / *(double *)((int)mat->me + (mat->dim + 1) * 8 * i);
    }
    else {
      out->ve[i] = sum / diag;
    }
    i = i + 1;
  } while( true );
}



Matrix new_matrix(int n)

{
  Matrix pmVar1;
  double *pdVar2;
  Matrix mat;
  
  pmVar1 = (Matrix)GC_malloc(8);
  pmVar1->dim = n;
  pdVar2 = (double *)GC_malloc_atomic(n * n * 8);
  pmVar1->me = pdVar2;
  return pmVar1;
}



Vector new_vector(int n)

{
  Vector pvVar1;
  double *pdVar2;
  Vector vec;
  
  pvVar1 = (Vector)GC_malloc(8);
  pvVar1->dim = n;
  pdVar2 = (double *)GC_malloc_atomic(n << 3);
  pvVar1->ve = pdVar2;
  return pvVar1;
}



double weight(int x)

{
  double dVar1;
  double dVar2;
  
  if (x < COLS) {
    dVar1 = (double)x;
  }
  else {
    dVar1 = (double)COLS;
    dVar2 = log((double)x / (double)COLS);
    dVar1 = (dVar2 + 1.0) * dVar1;
  }
  return dVar1;
}



double weight2(int a)

{
  return ((double)a / (double)COLS) * 4.0 + 1.0;
}



int bsearch_2short(short e1,short *ent1,short e2,short *ent2,int base,short *indexarray,int nent)

{
  int iVar1;
  int iVar2;
  uint uVar3;
  int ne;
  int idx;
  int nn;
  int e;
  int k;
  int n;
  
  n = nent;
  k = 0;
  iVar1 = e1 * base + (int)e2;
  uVar3 = n;
  while( true ) {
    n = uVar3;
    if (n < 1) {
      return k;
    }
    uVar3 = n / 2;
    iVar2 = ent1[indexarray[k + uVar3]] * base + (int)ent2[indexarray[k + uVar3]];
    if (iVar2 == iVar1) break;
    if (iVar2 < iVar1) {
      k = k + uVar3 + 1;
      uVar3 = n + ~uVar3;
    }
  }
  return k + uVar3;
}



int bsearch_double(double e,double *ent,short *indexarray,int nent)

{
  uint uVar1;
  double ne;
  int idx;
  int nn;
  int k;
  int n;
  
  n = nent;
  k = 0;
  uVar1 = n;
  while( true ) {
    n = uVar1;
    if (n < 1) {
      return k;
    }
    uVar1 = n / 2;
    if (ent[indexarray[k + uVar1]] == e) break;
    if (e < ent[indexarray[k + uVar1]]) {
      k = k + uVar1 + 1;
      uVar1 = n + ~uVar1;
    }
  }
  return k + uVar1;
}



int ceil_at_intervals(int x,int step)

{
  int iVar1;
  int mo;
  
  iVar1 = x % step;
  if (iVar1 < 1) {
    if (iVar1 < 0) {
      x = x - iVar1;
    }
  }
  else {
    x = x + (step - iVar1);
  }
  return x;
}



int floor_at_intervals(int x,int step)

{
  int iVar1;
  int mo;
  
  iVar1 = x % step;
  if (iVar1 < 1) {
    if (iVar1 < 0) {
      x = x + (step - iVar1);
    }
  }
  else {
    x = x - iVar1;
  }
  return x;
}



int table_colspan(table *t,int row,int col)

{
  int i;
  
  for (i = col + 1; (i <= t->maxcol && ((t->tabattr[row][i] & 1) != 0)); i = i + 1) {
  }
  return i - col;
}



int table_rowspan(table *t,int row,int col)

{
  int iVar1;
  int i;
  
  if (t->tabattr[row] == (table_attr *)0x0) {
    iVar1 = 0;
  }
  else {
    i = row + 1;
    while (((i <= t->maxrow && (t->tabattr[i] != (table_attr *)0x0)) &&
           ((t->tabattr[i][col] & 2) != 0))) {
      i = i + 1;
    }
    iVar1 = i - row;
  }
  return iVar1;
}



int minimum_cellspacing(int border_mode)

{
  int iVar1;
  
  if (border_mode == 0) {
    iVar1 = 1;
  }
  else if ((border_mode < 0) || (iVar1 = symbol_width, 3 < border_mode)) {
    iVar1 = 0;
  }
  return iVar1;
}



int table_border_width(table *t)

{
  int iVar1;
  
  iVar1 = t->border_mode;
  if (iVar1 < 3) {
    if (0 < iVar1) {
      return t->maxcol * t->cellspacing + (t->cellpadding + symbol_width) * 2;
    }
    if (iVar1 == 0) {
LAB_080805d1:
      return t->cellspacing * t->maxcol;
    }
  }
  else if (iVar1 == 3) goto LAB_080805d1;
  return 0;
}



table * newTable(void)

{
  table *ptVar1;
  GeneralList ***pppGVar2;
  table_attr **pptVar3;
  short *psVar4;
  Str **ppp_Var5;
  Str *pp_Var6;
  Str p_Var7;
  int j;
  int i;
  table *t;
  
  ptVar1 = (table *)GC_malloc(0x2cc);
  ptVar1->max_rowsize = 0x32;
  pppGVar2 = (GeneralList ***)GC_malloc(200);
  ptVar1->tabdata = pppGVar2;
  pptVar3 = (table_attr **)GC_malloc(200);
  ptVar1->tabattr = pptVar3;
  psVar4 = (short *)GC_malloc_atomic(100);
  ptVar1->tabheight = psVar4;
  ppp_Var5 = (Str **)GC_malloc(200);
  ptVar1->tabidvalue = ppp_Var5;
  pp_Var6 = (Str *)GC_malloc(200);
  ptVar1->tridvalue = pp_Var6;
  for (i = 0; i < 0x32; i = i + 1) {
    ptVar1->tabdata[i] = (GeneralList **)0x0;
    ptVar1->tabattr[i] = (table_attr *)0x0;
    ptVar1->tabheight[i] = 0;
    ptVar1->tabidvalue[i] = (Str *)0x0;
    ptVar1->tridvalue[i] = (Str)0x0;
  }
  for (j = 0; j < 0x32; j = j + 1) {
    ptVar1->tabwidth[j] = 0;
    ptVar1->minimum_width[j] = 0;
    ptVar1->fixed_width[j] = 0;
  }
  (ptVar1->cell).maxcell = -1;
  (ptVar1->cell).icell = -1;
  ptVar1->ntable = 0;
  ptVar1->tables_size = 0;
  ptVar1->tables = (table_in *)0x0;
  ptVar1->matrix = (MAT *)0x0;
  ptVar1->vector = (VEC *)0x0;
  p_Var7 = Strnew_size(8);
  (ptVar1->linfo).prevchar = p_Var7;
  Strcopy_charp_n((ptVar1->linfo).prevchar,"",0);
  ptVar1->trattr = 0;
  p_Var7 = Strnew();
  ptVar1->caption = p_Var7;
  ptVar1->suspended_data = (TextList *)0x0;
  ptVar1->id = (Str)0x0;
  return ptVar1;
}



void check_row(table *t,int row)

{
  int iVar1;
  int iVar2;
  GeneralList ***pppGVar3;
  table_attr **pptVar4;
  short *psVar5;
  Str **ppp_Var6;
  Str *pp_Var7;
  GeneralList **ppGVar8;
  table_attr *ptVar9;
  Str *tridvalue;
  Str **tabidvalue;
  short *tabheight;
  table_attr **tabattr;
  GeneralList ***tabdata;
  int r;
  int i;
  
  if (t->max_rowsize <= row) {
    iVar1 = row + 1;
    iVar2 = t->max_rowsize * 2;
    if (SBORROW4(iVar1,iVar2) == iVar1 + t->max_rowsize * -2 < 0) {
      iVar2 = iVar1;
    }
    pppGVar3 = (GeneralList ***)GC_malloc(iVar2 << 2);
    pptVar4 = (table_attr **)GC_malloc(iVar2 << 2);
    psVar5 = (short *)GC_malloc_atomic(iVar2 * 2);
    ppp_Var6 = (Str **)GC_malloc(iVar2 << 2);
    pp_Var7 = (Str *)GC_malloc(iVar2 << 2);
    for (i = 0; i < t->max_rowsize; i = i + 1) {
      pppGVar3[i] = t->tabdata[i];
      pptVar4[i] = t->tabattr[i];
      psVar5[i] = t->tabheight[i];
      ppp_Var6[i] = t->tabidvalue[i];
      pp_Var7[i] = t->tridvalue[i];
    }
    for (; i < iVar2; i = i + 1) {
      pppGVar3[i] = (GeneralList **)0x0;
      pptVar4[i] = (table_attr *)0x0;
      psVar5[i] = 0;
      ppp_Var6[i] = (Str *)0x0;
      pp_Var7[i] = (Str)0x0;
    }
    t->tabdata = pppGVar3;
    t->tabattr = pptVar4;
    t->tabheight = psVar5;
    t->tabidvalue = ppp_Var6;
    t->tridvalue = pp_Var7;
    t->max_rowsize = iVar2;
  }
  if (t->tabdata[row] == (GeneralList **)0x0) {
    pppGVar3 = t->tabdata;
    ppGVar8 = (GeneralList **)GC_malloc(200);
    pppGVar3[row] = ppGVar8;
    pptVar4 = t->tabattr;
    ptVar9 = (table_attr *)GC_malloc_atomic(100);
    pptVar4[row] = ptVar9;
    ppp_Var6 = t->tabidvalue;
    pp_Var7 = (Str *)GC_malloc(200);
    ppp_Var6[row] = pp_Var7;
    for (i = 0; i < 0x32; i = i + 1) {
      t->tabdata[row][i] = (GeneralList *)0x0;
      t->tabattr[row][i] = 0;
      t->tabidvalue[row][i] = (Str)0x0;
    }
  }
  return;
}



void pushdata(table *t,int row,int col,char *data)

{
  GeneralList **ppGVar1;
  GeneralList *pGVar2;
  char *s;
  
  check_row(t,row);
  if (t->tabdata[row][col] == (GeneralList *)0x0) {
    ppGVar1 = t->tabdata[row];
    pGVar2 = newGeneralList();
    ppGVar1[col] = pGVar2;
  }
  if (data == (char *)0x0) {
    data = "";
  }
  s = allocStr(data,-1);
  pushValue(t->tabdata[row][col],s);
  return;
}



void suspend_or_pushdata(table *tbl,char *line)

{
  TextList *pTVar1;
  char *s;
  
  if ((tbl->flag & 4U) == 0) {
    if (tbl->suspended_data == (TextList *)0x0) {
      pTVar1 = (TextList *)newGeneralList();
      tbl->suspended_data = pTVar1;
    }
    if (line == (char *)0x0) {
      line = "";
    }
    s = allocStr(line,-1);
    pushValue((GeneralList *)tbl->suspended_data,s);
  }
  else {
    pushdata(tbl,tbl->row,tbl->col,line);
  }
  return;
}



int visible_length(char *str)

{
  int iVar1;
  int iVar2;
  byte bVar3;
  int amp_len;
  char *r2;
  char *t;
  Str tagbuf;
  int prev_status;
  int status;
  int max_len;
  int n;
  int len;
  
  len = 0;
  max_len = 0;
  status = 0;
  prev_status = 0;
  tagbuf = Strnew();
  t = str;
  for (; *str != '\0'; str = str + n) {
    prev_status = status;
    iVar1 = next_status(*str,&status);
    if (iVar1 == 0) {
      n = 1;
    }
    else {
      if (WcOption.use_wide == '\0') {
        bVar3 = WTF_WIDTH_MAP[(byte)*str] != '\0';
      }
      else {
        bVar3 = WTF_WIDTH_MAP[(byte)*str];
      }
      len = len + (uint)bVar3;
      n = (int)WTF_LEN_MAP[(byte)*str];
    }
    if (status == 1) {
      Strclear(tagbuf);
      Strcat_charp_n(tagbuf,str,n);
    }
    else if ((((status == 2) || (status == 4)) || (status == 3)) ||
            ((status == 5 || (status == 0xf)))) {
      Strcat_charp_n(tagbuf,str,n);
    }
    else if (status == 6) {
      if (prev_status == 0) {
        Strclear(tagbuf);
        len = len + -1;
      }
      else {
        Strcat_charp_n(tagbuf,str,n);
      }
    }
    else if ((status == 0) && (prev_status == 6)) {
      Strcat_charp_n(tagbuf,str,n);
      r2 = tagbuf->ptr;
      t = getescapecmd(&r2);
      if ((*r2 == '\0') && ((*t == '\r' || (*t == '\n')))) {
        if (max_len < len) {
          max_len = len;
        }
        len = 0;
      }
      else {
        iVar1 = wtf_strwidth((wc_uchar *)t);
        iVar2 = wtf_strwidth((wc_uchar *)r2);
        len = len + iVar1 + iVar2;
      }
    }
    else if ((status != 0) ||
            ((((prev_status != 2 && (prev_status != 1)) && (prev_status != 5)) &&
             (prev_status != 0xf)))) {
      if (*str == '\t') {
        len = len + -1;
        do {
          len = len + 1;
        } while ((visible_length_offset + len) % Tabstop != 0);
      }
      else if ((*str == '\r') || (*str == '\n')) {
        if (max_len < len + -1) {
          max_len = len + -1;
        }
        len = 0;
      }
    }
  }
  if (status == 6) {
    r2 = tagbuf->ptr;
    t = getescapecmd(&r2);
    if ((*t != '\r') && (*t != '\n')) {
      iVar1 = wtf_strwidth((wc_uchar *)t);
      iVar2 = wtf_strwidth((wc_uchar *)r2);
      len = len + iVar1 + iVar2;
    }
  }
  if (len <= max_len) {
    len = max_len;
  }
  return len;
}



int visible_length_plain(char *str)

{
  byte bVar1;
  int max_len;
  int len;
  
  len = 0;
  max_len = 0;
  while (*str != '\0') {
    if (*str == '\t') {
      do {
        len = len + 1;
      } while ((visible_length_offset + len) % Tabstop != 0);
      str = str + 1;
    }
    else if ((*str == '\r') || (*str == '\n')) {
      if (max_len < len) {
        max_len = len;
      }
      len = 0;
      str = str + 1;
    }
    else {
      if (WcOption.use_wide == '\0') {
        bVar1 = WTF_WIDTH_MAP[(byte)*str] != '\0';
      }
      else {
        bVar1 = WTF_WIDTH_MAP[(byte)*str];
      }
      len = len + (uint)bVar1;
      str = str + WTF_LEN_MAP[(byte)*str];
    }
  }
  if (len <= max_len) {
    len = max_len;
  }
  return len;
}



int maximum_visible_length(char *str,int offset)

{
  int iVar1;
  
  visible_length_offset = offset;
  iVar1 = visible_length(str);
  return iVar1;
}



int maximum_visible_length_plain(char *str,int offset)

{
  int iVar1;
  
  visible_length_offset = offset;
  iVar1 = visible_length_plain(str);
  return iVar1;
}



void align(TextLine *lbuf,int width,int mode)

{
  Str y;
  int iVar1;
  Str x;
  int iVar2;
  Str line;
  Str buf;
  int l2;
  int l1;
  int l;
  int i;
  
  y = lbuf->line;
  if (y->length == 0) {
    for (i = 0; i < width; i = i + 1) {
      if (y->area_size <= y->length + 1) {
        Strgrow(y);
      }
      iVar2 = y->length;
      y->ptr[iVar2] = ' ';
      y->length = iVar2 + 1;
      y->ptr[y->length] = '\0';
    }
    lbuf->pos = (short)width;
  }
  else {
    x = Strnew();
    iVar2 = width - lbuf->pos;
    if (mode == 1) {
      Strcat(x,y);
      for (i = 0; i < iVar2; i = i + 1) {
        if (x->area_size <= x->length + 1) {
          Strgrow(x);
        }
        iVar1 = x->length;
        x->ptr[iVar1] = ' ';
        x->length = iVar1 + 1;
        x->ptr[x->length] = '\0';
      }
    }
    else if (mode == 2) {
      for (i = 0; i < iVar2; i = i + 1) {
        if (x->area_size <= x->length + 1) {
          Strgrow(x);
        }
        iVar1 = x->length;
        x->ptr[iVar1] = ' ';
        x->length = iVar1 + 1;
        x->ptr[x->length] = '\0';
      }
      Strcat(x,y);
    }
    else {
      if (mode != 0) {
        return;
      }
      for (i = 0; i < iVar2 / 2; i = i + 1) {
        if (x->area_size <= x->length + 1) {
          Strgrow(x);
        }
        iVar1 = x->length;
        x->ptr[iVar1] = ' ';
        x->length = iVar1 + 1;
        x->ptr[x->length] = '\0';
      }
      Strcat(x,y);
      for (i = 0; i < iVar2 - iVar2 / 2; i = i + 1) {
        if (x->area_size <= x->length + 1) {
          Strgrow(x);
        }
        iVar1 = x->length;
        x->ptr[iVar1] = ' ';
        x->length = iVar1 + 1;
        x->ptr[x->length] = '\0';
      }
    }
    lbuf->line = x;
    if (lbuf->pos < width) {
      lbuf->pos = (short)width;
    }
  }
  return;
}



void print_item(table *t,int row,int col,int width,Str buf)

{
  TextLine *lbuf_00;
  TextLine *lbuf;
  int alignment;
  
  if (t->tabdata[row] == (GeneralList **)0x0) {
    lbuf = (TextLine *)0x0;
  }
  else {
    lbuf = (TextLine *)popValue(t->tabdata[row][col]);
  }
  if (lbuf == (TextLine *)0x0) {
    lbuf_00 = newTextLine((Str)0x0,0);
    align(lbuf_00,width,0);
    Strcat(buf,lbuf_00->line);
  }
  else {
    check_row(t,row);
    alignment = 0;
    if ((t->tabattr[row][col] & 0x30) == 0) {
      alignment = 1;
    }
    else if ((t->tabattr[row][col] & 0x30) == 0x20) {
      alignment = 2;
    }
    else if ((t->tabattr[row][col] & 0x30) == 0x10) {
      alignment = 0;
    }
    align(lbuf,width,alignment);
    Strcat(buf,lbuf->line);
  }
  return;
}



// WARNING: Could not reconcile some variable overlaps

void print_sep(table *t,int row,int type,int maxcol,Str buf)

{
  int iVar1;
  char cVar2;
  int w;
  int m;
  int l;
  int k;
  int i;
  int rule_mode;
  int forbid;
  
  if (-1 < row) {
    check_row(t,row);
  }
  check_row(t,row + 1);
  if (((type == 0) || (type == 2)) && (t->border_mode == 2)) {
    rule_mode = 2;
  }
  else {
    rule_mode = 1;
  }
  forbid._0_1_ = '\x01';
  if (type == 0) {
    forbid._0_1_ = '\x03';
  }
  else if (type == 2) {
    forbid._0_1_ = '\t';
  }
  else if ((*t->tabattr[row + 1] & 2) != 0) {
    forbid._0_1_ = '\x05';
  }
  if (t->border_mode != 3) {
    if (t->border_mode == 2) {
      forbid._0_1_ = (byte)forbid + '\x10';
    }
    push_symbol(buf,(byte)forbid,symbol_width,1);
  }
  for (i = 0; i <= maxcol; i = i + 1) {
    if ((type == 2) || ((t->tabattr[row + 1][i] & 2) == 0)) {
      w = (int)t->tabwidth[i] + t->cellpadding * 2;
      if (symbol_width == 2) {
        w = (w + 1) / 2;
      }
      if (rule_mode == 2) {
        cVar2 = '\x1a';
      }
      else {
        cVar2 = '\n';
      }
      push_symbol(buf,cVar2,symbol_width,w);
    }
    else if ((t->tabattr[row + 1][i] & 1) == 0) {
      k = row;
      while (((-1 < k && (t->tabattr[k] != (table_attr *)0x0)) && ((t->tabattr[k][i] & 2) != 0))) {
        k = k + -1;
      }
      m = (int)t->tabwidth[i] + t->cellpadding * 2;
      iVar1 = i;
      while ((l = iVar1 + 1, l <= t->maxcol && ((t->tabattr[row][l] & 1) != 0))) {
        m = m + (int)t->tabwidth[iVar1 + 1] + t->cellspacing;
        iVar1 = l;
      }
      print_item(t,k,i,m,buf);
    }
    if (i < maxcol) {
      forbid = 0;
      if (type == 0) {
        forbid = 2;
      }
      else if ((t->tabattr[row][i + 1] & 1) != 0) {
        forbid = 2;
      }
      if (type == 2) {
        forbid = forbid | 8;
      }
      else {
        if ((t->tabattr[row + 1][i + 1] & 1) != 0) {
          forbid = forbid | 8;
        }
        if ((t->tabattr[row + 1][i + 1] & 2) != 0) {
          forbid = forbid | 4;
        }
        if ((t->tabattr[row + 1][i] & 2) != 0) {
          forbid = forbid | 1;
        }
      }
      if (forbid != 0xf) {
        cVar2 = (char)forbid;
        if (rule_mode == 2) {
          cVar2 = cVar2 + '\x10';
        }
        push_symbol(buf,cVar2,symbol_width,1);
      }
    }
  }
  forbid._0_1_ = 4;
  if (type == 0) {
    forbid._0_1_ = 6;
  }
  if (type == 2) {
    forbid._0_1_ = (byte)forbid | 8;
  }
  if ((t->tabattr[row + 1][maxcol] & 2) != 0) {
    forbid._0_1_ = (byte)forbid | 1;
  }
  if (t->border_mode != 3) {
    if (t->border_mode == 2) {
      forbid._0_1_ = (byte)forbid + 0x10;
    }
    push_symbol(buf,(byte)forbid,symbol_width,1);
  }
  return;
}



int get_spec_cell_width(table *tbl,int row,int col)

{
  int w;
  int i;
  
  w = (int)tbl->tabwidth[col];
  for (i = col + 1; (i <= tbl->maxcol && (check_row(tbl,row), (tbl->tabattr[row][i] & 1) != 0));
      i = i + 1) {
    w = w + (int)tbl->tabwidth[i] + tbl->cellspacing;
  }
  return w;
}



void do_refill(table *tbl,int row,int col,int maxlimit)

{
  short sVar1;
  GeneralList **ppGVar2;
  table *ptVar3;
  GeneralList *pGVar4;
  int iVar5;
  parsed_tag *tag_00;
  readbuffer obuf;
  environment envs [20];
  html_feed_environ h_env;
  int k;
  table_cell *cell;
  int rowspan;
  int limit;
  table *t;
  TextLineListItem *ti;
  int alignment;
  parsed_tag *tag;
  char *p;
  int id;
  int icell;
  int colspan;
  TextListItem *l;
  TextList *orgdata;
  
  if ((tbl->tabdata[row] != (GeneralList **)0x0) && (tbl->tabdata[row][col] != (GeneralList *)0x0))
  {
    orgdata = (TextList *)tbl->tabdata[row][col];
    ppGVar2 = tbl->tabdata[row];
    pGVar4 = newGeneralList();
    ppGVar2[col] = pGVar4;
    iVar5 = get_spec_cell_width(tbl,row,col);
    init_henv(&h_env,&obuf,envs,0x14,(TextLineList *)tbl->tabdata[row][col],iVar5,0);
    obuf.flag = obuf.flag | 0x20000;
    if (maxlimit < h_env.limit) {
      h_env.limit = maxlimit;
    }
    if ((tbl->border_mode != 0) && (0 < tbl->vcellpadding)) {
      do_blankline(&h_env,&obuf,0,0,h_env.limit);
    }
    for (l = orgdata->first; l != (TextListItem *)0x0; l = l->next) {
      iVar5 = strncasecmp(l->ptr,"<table_alt",10);
      if ((iVar5 == 0) && ((l->ptr[10] == '>' || ((MYCTYPE_MAP[(byte)l->ptr[10]] & 2) != 0)))) {
        id = -1;
        p = l->ptr;
        tag_00 = parse_tag(&p,1);
        if (tag_00 != (parsed_tag *)0x0) {
          parsedtag_get_value(tag_00,0x40,&id);
        }
        if ((-1 < id) && (id < tbl->ntable)) {
          ptVar3 = tbl->tables[id].ptr;
          iVar5 = (int)tbl->tables[id].indent + ptVar3->total_width;
          tbl->tables[id].ptr = (table *)0x0;
          save_fonteffect(&h_env,h_env.obuf);
          flushline(&h_env,&obuf,0,2,h_env.limit);
          if ((0 < ptVar3->vspace) && ((obuf.flag & 0x2000U) == 0)) {
            do_blankline(&h_env,&obuf,0,0,h_env.limit);
          }
          if (((h_env.obuf)->flag & 0x70U) == 0x20) {
            alignment = 0;
          }
          else if (((h_env.obuf)->flag & 0x70U) == 0x40) {
            alignment = 2;
          }
          else {
            alignment = 1;
          }
          if (alignment != 1) {
            for (ti = (tbl->tables[id].buf)->first; ti != (TextLineListItem *)0x0; ti = ti->next) {
              align(ti->ptr,h_env.limit,alignment);
            }
          }
          appendGeneralList((GeneralList *)h_env.buf,(GeneralList *)tbl->tables[id].buf);
          if (h_env.maxlimit < iVar5) {
            h_env.maxlimit = iVar5;
          }
          restore_fonteffect(&h_env,h_env.obuf);
          obuf.flag = obuf.flag & 0xffffdfff;
          h_env.blank_lines = 0;
          if (0 < ptVar3->vspace) {
            do_blankline(&h_env,&obuf,0,0,h_env.limit);
            obuf.flag = obuf.flag | 0x2000;
          }
        }
      }
      else {
        HTMLlineproc0(l->ptr,&h_env,1);
      }
    }
    if (obuf.status != 0) {
      obuf.status = 7;
      HTMLlineproc0("\n",&h_env,1);
    }
    completeHTMLstream(&h_env,&obuf);
    flushline(&h_env,&obuf,0,2,h_env.limit);
    if (tbl->border_mode == 0) {
      iVar5 = table_rowspan(tbl,row,col);
      if (tbl->maxrow < row + iVar5) {
        if (0 < tbl->vspace) {
          purgeline(&h_env);
        }
      }
      else if ((0 < tbl->vcellpadding) && ((obuf.flag & 0x2000U) == 0)) {
        do_blankline(&h_env,&obuf,0,0,h_env.limit);
      }
    }
    else if (tbl->vcellpadding < 1) {
      purgeline(&h_env);
    }
    else if ((obuf.flag & 0x2000U) == 0) {
      do_blankline(&h_env,&obuf,0,0,h_env.limit);
    }
    colspan = table_colspan(tbl,row,col);
    if (colspan < 2) {
      if (tbl->minimum_width[col] < h_env.maxlimit) {
        tbl->minimum_width[col] = (short)h_env.maxlimit;
      }
    }
    else {
      iVar5 = bsearch_2short((short)colspan,(tbl->cell).colspan,(short)col,(tbl->cell).col,0x32,
                             (tbl->cell).index,(tbl->cell).maxcell + 1);
      sVar1 = (tbl->cell).index[iVar5];
      if ((tbl->cell).minimum_width[sVar1] < h_env.maxlimit) {
        (tbl->cell).minimum_width[sVar1] = (short)h_env.maxlimit;
      }
    }
  }
  return;
}



int table_rule_width(table *t)

{
  int iVar1;
  
  iVar1 = symbol_width;
  if (t->border_mode == 0) {
    iVar1 = 1;
  }
  return iVar1;
}



void check_cell_width(short *tabwidth,short *cellwidth,short *col,short *colspan,short maxcell,
                     short *indexarray,int space,int dir)

{
  int iVar1;
  short sVar2;
  short sVar3;
  int iVar4;
  int iVar5;
  int r;
  int w;
  int width;
  int swidth;
  int ecol;
  int bcol;
  int k;
  int j;
  int i;
  
  for (k = 0; k <= maxcell; k = k + 1) {
    sVar2 = indexarray[k];
    if (0 < cellwidth[sVar2]) {
      iVar4 = (int)col[sVar2];
      iVar5 = colspan[sVar2] + iVar4;
      swidth = 0;
      for (i = iVar4; i < iVar5; i = i + 1) {
        swidth = swidth + tabwidth[i];
      }
      iVar1 = (int)cellwidth[sVar2] + (1 - colspan[sVar2]) * space;
      if (swidth < iVar1) {
        sVar3 = colspan[sVar2];
        r = (iVar1 - swidth) % (int)colspan[sVar2];
        for (i = iVar4; i < iVar5; i = i + 1) {
          tabwidth[i] = tabwidth[i] + (short)((iVar1 - swidth) / (int)sVar3);
        }
        if ((dir == 1) && (0 < r)) {
          r = (int)colspan[sVar2];
        }
        for (i = 1; i <= r; i = i + 1) {
          tabwidth[iVar5 - i] = tabwidth[iVar5 - i] + 1;
        }
      }
    }
  }
  return;
}



void check_minimum_width(table *t,short *tabwidth)

{
  table_cell *cell;
  int i;
  
  for (i = 0; i <= t->maxcol; i = i + 1) {
    if (tabwidth[i] < t->minimum_width[i]) {
      tabwidth[i] = t->minimum_width[i];
    }
  }
  check_cell_width(tabwidth,(t->cell).minimum_width,(t->cell).col,(t->cell).colspan,
                   (t->cell).maxcell,(t->cell).index,t->cellspacing,0);
  return;
}



void check_maximum_width(table *t)

{
  int iVar1;
  int width;
  int swidth;
  int ecol;
  int bcol;
  int j;
  int i;
  table_cell *cell;
  
  (t->cell).necell = 0;
  for (j = 0; j <= (t->cell).maxcell; j = j + 1) {
    i = (int)(t->cell).col[j];
    iVar1 = (t->cell).colspan[j] + i;
    swidth = 0;
    for (; i < iVar1; i = i + 1) {
      swidth = swidth + t->tabwidth[i];
    }
    if (swidth < (int)(t->cell).width[j] + t->cellspacing * (1 - (t->cell).colspan[j])) {
      (t->cell).eindex[(t->cell).necell] = (short)j;
      (t->cell).necell = (t->cell).necell + 1;
    }
  }
  return;
}



void set_integered_width(table *t,double *dwidth,short *iwidth)

{
  short sVar1;
  short sVar2;
  ulonglong uVar3;
  int step_00;
  short *indexarray_00;
  double *ent;
  void *__s;
  size_t __n;
  int iVar4;
  int iVar5;
  int iVar6;
  double dVar7;
  ulonglong uVar8;
  double nsum;
  double x;
  double sum;
  int ii_1;
  int ii_2;
  int ii_3;
  int m;
  int width;
  int w;
  int kk;
  int ii_4;
  int ii_5;
  char *idx;
  int nn;
  int ii;
  int rulewidth;
  table_cell *cell;
  double *mod;
  char *fixed;
  short *indexarray;
  int step;
  int ecol;
  int bcol;
  int n;
  int k;
  int j;
  int i;
  
  x = 0.0;
  step_00 = table_rule_width(t);
  indexarray_00 = (short *)GC_malloc_atomic();
  ent = (double *)GC_malloc_atomic();
  for (i = 0; i <= t->maxcol; i = i + 1) {
    dVar7 = ceil(dwidth[i]);
    iVar4 = ceil_at_intervals((int)ROUND(dVar7),step_00);
    iwidth[i] = (short)iVar4;
    ent[i] = (double)iwidth[i] - dwidth[i];
  }
  sum = 0.0;
  for (k = 0; k <= t->maxcol; k = k + 1) {
    x = ent[k];
    sum = sum + x;
    iVar4 = bsearch_double(x,ent,indexarray_00,k);
    if (iVar4 < k) {
      for (ii = k; iVar4 < ii; ii = ii + -1) {
        indexarray_00[ii] = indexarray_00[ii + -1];
      }
    }
    indexarray_00[iVar4] = (short)k;
  }
  __s = (void *)GC_malloc_atomic();
  __n = t->maxcol + 1;
  uVar8 = CONCAT44(__n,__s);
  bzero(__s,__n);
  step = 0;
  do {
    if (1 < step) {
      return;
    }
    for (i = 0; i <= t->maxcol; i = i + n) {
      if (sum < 0.5) {
        return;
      }
      for (n = 0; i + n <= t->maxcol; n = n + 1) {
        if (n == 0) {
          x = ent[indexarray_00[i + n]];
        }
        else if (1e-06 < ABS(ent[indexarray_00[i + n]] - x)) break;
      }
      for (k = 0; k < n; k = k + 1) {
        iVar4 = (int)indexarray_00[i + k];
        if ((*(char *)(iVar4 + (int)__s) < '\x02') &&
           (iwidth[iVar4] - step_00 < (int)t->minimum_width[iVar4])) {
          *(undefined *)(iVar4 + (int)__s) = 2;
        }
        if (((*(char *)(iVar4 + (int)__s) < '\x01') &&
            (iwidth[iVar4] - step_00 < (int)t->tabwidth[iVar4])) &&
           (0.5 < (double)step_00 - ent[iVar4])) {
          *(undefined *)(iVar4 + (int)__s) = 1;
        }
      }
      uVar3 = uVar8 >> 0x20;
      uVar8 = uVar8 & 0xffffffff00000000;
      iVar4 = GC_malloc_atomic(n,(int)uVar3);
      for (k = 0; k < (t->cell).maxcell; k = k + 1) {
        sVar1 = (t->cell).index[k];
        iVar5 = (int)(t->cell).col[sVar1];
        iVar6 = (t->cell).colspan[sVar1] + iVar5;
        m = 0;
        for (kk = 0; kk < n; kk = kk + 1) {
          sVar2 = indexarray_00[i + kk];
          if ((iVar5 <= sVar2) && (sVar2 < iVar6)) {
            *(char *)(m + iVar4) = (char)sVar2;
            m = m + 1;
          }
        }
        if (m != 0) {
          width = t->cellspacing * ((t->cell).colspan[sVar1] + -1);
          for (kk = iVar5; kk < iVar6; kk = kk + 1) {
            width = width + iwidth[kk];
          }
          w = 0;
          for (kk = 0; kk < m; kk = kk + 1) {
            if (*(char *)((int)*(char *)(kk + iVar4) + (int)__s) < '\x02') {
              w = w + step_00;
            }
          }
          if (width - w < (int)(t->cell).minimum_width[sVar1]) {
            for (kk = 0; kk < m; kk = kk + 1) {
              if (*(char *)((int)*(char *)(kk + iVar4) + (int)__s) < '\x02') {
                *(undefined *)((int)*(char *)(kk + iVar4) + (int)__s) = 2;
              }
            }
          }
          w = 0;
          for (kk = 0; kk < m; kk = kk + 1) {
            if ((*(char *)((int)*(char *)(kk + iVar4) + (int)__s) < '\x01') &&
               (0.5 < (double)step_00 - ent[*(char *)(kk + iVar4)])) {
              w = w + step_00;
            }
          }
          if (width - w < (int)(t->cell).width[sVar1]) {
            for (kk = 0; kk < m; kk = kk + 1) {
              if ((*(char *)((int)*(char *)(kk + iVar4) + (int)__s) < '\x01') &&
                 (0.5 < (double)step_00 - ent[*(char *)(kk + iVar4)])) {
                *(undefined *)((int)*(char *)(kk + iVar4) + (int)__s) = 1;
              }
            }
          }
        }
      }
      nn = 0;
      for (k = 0; k < n; k = k + 1) {
        if (*(char *)((int)indexarray_00[i + k] + (int)__s) <= step) {
          nn = nn + 1;
        }
      }
      dVar7 = sum - (double)(nn * step_00);
      if ((dVar7 < 0.0) && (ABS(sum) <= ABS(dVar7))) {
        return;
      }
      for (k = 0; k < n; k = k + 1) {
        iVar4 = (int)indexarray_00[i + k];
        if (*(char *)(iVar4 + (int)__s) <= step) {
          iwidth[iVar4] = iwidth[iVar4] - (short)step_00;
          *(undefined *)(iVar4 + (int)__s) = 3;
        }
      }
      sum = dVar7;
    }
    step = step + 1;
  } while( true );
}



// WARNING: Removing unreachable block (ram,0x08082a67)
// WARNING: Removing unreachable block (ram,0x08082a6b)
// WARNING: Removing unreachable block (ram,0x08082a6d)

double correlation_coefficient(double sxx,double syy,double sxy)

{
  double dVar1;
  double tmp;
  double coe;
  
  tmp = sxx * syy;
  if (tmp < Tiny) {
    tmp = Tiny;
  }
  dVar1 = sxy / SQRT(tmp);
  if (dVar1 <= 1.0) {
    if (dVar1 < -1.0) {
      dVar1 = -1.0;
    }
  }
  else {
    dVar1 = 1.0;
  }
  return dVar1;
}



double correlation_coefficient2(double sxx,double syy,double sxy)

{
  double dVar1;
  double tmp;
  double coe;
  
  tmp = (sxy * -2.0 + syy + sxx) * sxx;
  if (tmp < Tiny) {
    tmp = Tiny;
  }
  dVar1 = sqrt(tmp);
  dVar1 = (sxx - sxy) / dVar1;
  if (dVar1 <= 1.0) {
    if (dVar1 < -1.0) {
      dVar1 = -1.0;
    }
  }
  else {
    dVar1 = 1.0;
  }
  return dVar1;
}



double recalc_width(double old,double swidth,int cwidth,double sxx,double syy,double sxy,
                   int is_inclusive)

{
  double dVar1;
  double dVar2;
  double dVar3;
  double local_54;
  double wmin_1;
  double coe1;
  double wmin;
  double ww;
  double w;
  double coe;
  double rat;
  double delta;
  
  local_54 = old;
  ww = swidth - (double)cwidth;
  dVar1 = sxy / sxx;
  dVar2 = correlation_coefficient(sxx,syy,sxy);
  if (old < 0.0) {
    local_54 = 0.0;
  }
  if (1e-05 <= ABS(dVar2)) {
    if (dVar1 * local_54 <= 0.0) {
      dVar3 = sqrt(syy);
      wmin_1 = ABS(dVar2) * dVar3 * 0.005;
      if (-0.001 < dVar1) {
        return local_54;
      }
      if (0.01 < wmin_1) {
        wmin_1 = 0.01;
      }
      if (0.0 < ww) {
        ww = 0.0;
      }
      ww = ww - wmin_1;
    }
    else {
      dVar3 = sqrt((1.0 - dVar2 * dVar2) * syy);
      wmin = dVar3 * 0.005;
      if ((((swidth < 0.2) && (0 < cwidth)) && (is_inclusive != 0)) &&
         ((dVar3 = correlation_coefficient2(sxx,syy,sxy), 0.9 < dVar2 || (0.9 < dVar3)))) {
        return 0.0;
      }
      if (0.05 < wmin) {
        wmin = 0.05;
      }
      if (ww < 0.0) {
        ww = 0.0;
      }
      ww = ww + wmin;
    }
    if (ww < dVar1 * local_54) {
      local_54 = ww / dVar1;
    }
  }
  return local_54;
}



int check_compressible_cell
              (table *t,MAT *minv,double *newwidth,double *swidth,short *cwidth,double totalwidth,
              double *Sxx,int icol,int icell,double sxx,int corr)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  double dVar5;
  double sxy;
  double dmin;
  double dmax;
  double owidth;
  double delta;
  int nwidth;
  int is_inclusive_1;
  int is_inclusive;
  int ecol1;
  int bcol1;
  int rulewidth;
  int span;
  int ecol;
  int bcol;
  int m;
  int k;
  int j;
  int i;
  table_cell *cell;
  
  iVar1 = table_rule_width(t);
  if (10.0 <= sxx) {
    if (icol < 0) {
      if (icell < 0) {
        owidth = totalwidth;
        delta = totalwidth;
        bcol = 0;
        ecol = t->maxcol + 1;
      }
      else {
        owidth = swidth[icell];
        delta = swidth[icell] - (double)cwidth[icell];
        bcol = (int)(t->cell).col[icell];
        ecol = (t->cell).colspan[icell] + bcol;
      }
    }
    else {
      owidth = newwidth[icol];
      delta = newwidth[icol] - (double)t->tabwidth[icol];
      bcol = icol;
      ecol = icol + 1;
    }
    dmin = delta;
    dmax = -1.0;
    for (k = 0; k <= (t->cell).maxcell; k = k + 1) {
      is_inclusive = 0;
      if (dmin <= 0.0) goto _end;
      iVar2 = (int)(t->cell).index[k];
      if (iVar2 != icell) {
        iVar3 = (int)(t->cell).col[iVar2];
        iVar4 = (t->cell).colspan[iVar2] + iVar3;
        sxy = 0.0;
        for (m = iVar3; m < iVar4; m = m + 1) {
          for (i = bcol; i < ecol; i = i + 1) {
            sxy = sxy + minv->me[minv->dim * i + m];
          }
        }
        if ((bcol <= iVar3) && (iVar4 <= ecol)) {
          is_inclusive = 1;
        }
        if (sxy <= 0.0) {
          dmax = recalc_width(dmax,swidth[iVar2],(int)cwidth[iVar2],sxx,Sxx[iVar2],sxy,is_inclusive)
          ;
        }
        else {
          dmin = recalc_width(dmin,swidth[iVar2],(int)cwidth[iVar2],sxx,Sxx[iVar2],sxy,is_inclusive)
          ;
        }
      }
    }
    m = 0;
    while ((m <= t->maxcol && (is_inclusive_1 = 0, 0.0 < dmin))) {
      if (m != icol) {
        sxy = 0.0;
        for (i = bcol; i < ecol; i = i + 1) {
          sxy = sxy + minv->me[minv->dim * i + m];
        }
        if ((bcol <= m) && (m < ecol)) {
          is_inclusive_1 = 1;
        }
        if (sxy <= 0.0) {
          dmax = recalc_width(dmax,newwidth[m],(int)t->tabwidth[m],sxx,
                              *(double *)((int)minv->me + (minv->dim + 1) * 8 * m),sxy,
                              is_inclusive_1);
        }
        else {
          dmin = recalc_width(dmin,newwidth[m],(int)t->tabwidth[m],sxx,
                              *(double *)((int)minv->me + (minv->dim + 1) * 8 * m),sxy,
                              is_inclusive_1);
        }
      }
      m = m + 1;
    }
_end:
    if ((0.0 < dmax) && (dmax < dmin)) {
      dmin = dmax;
    }
    if (((t->maxcol + 1 == ecol - bcol) && (0.0 <= dmin)) ||
       ((t->maxcol + 1 != ecol - bcol && ((double)iVar1 * 0.5 < dmin)))) {
      dVar5 = floor((owidth - dmin) + 0.5);
      iVar1 = ceil_at_intervals((int)ROUND(dVar5),iVar1);
      correct_table_matrix(t,bcol,ecol - bcol,iVar1,1.0);
      corr = corr + 1;
    }
  }
  return corr;
}



int check_table_width(table *t,double *newwidth,MAT *minv,int itr)

{
  short sVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  double_0_ *pdVar6;
  short_0_ *psVar7;
  int iVar8;
  int in_GS_OFFSET;
  undefined2 in_FPUControlWord;
  double dVar9;
  table *ptStack384;
  undefined8 uStack380;
  double *apdStack372 [2];
  undefined auStack364 [12];
  double *pdStack352;
  int aiStack348 [2];
  double dStack340;
  int aiStack332 [3];
  short_0_ asStack320 [4];
  int local_13c;
  uint local_138;
  uint local_134;
  undefined4 local_130;
  int local_12c;
  uint local_128;
  uint local_124;
  undefined4 local_120;
  int local_11c;
  uint local_118;
  uint local_114;
  undefined4 local_110;
  int local_10c;
  uint local_108;
  uint local_104;
  undefined4 local_100;
  int local_fc;
  uint local_f8;
  uint local_f4;
  undefined4 local_f0;
  int local_ec;
  uint local_e8;
  uint local_e4;
  undefined4 local_e0;
  int local_dc;
  uint local_d8;
  uint local_d4;
  undefined4 local_d0;
  int local_cc;
  uint local_c8;
  int local_c0;
  undefined2 local_bc;
  undefined2 local_ba;
  MAT *local_b8;
  double *local_b4;
  table *local_b0;
  double w_1;
  double sx_1;
  double w;
  double sx;
  double stotal;
  double sxy;
  double twidth;
  double_0_ *swidth;
  int local_68;
  short_0_ *cwidth;
  int local_60;
  short_0_ *corwidth;
  int local_58;
  short_0_ *orgwidth;
  int local_50;
  int mwidth;
  int nwidth;
  double *Sxx;
  table_cell *cell;
  int corr;
  int ecol;
  int bcol;
  int m;
  int k;
  int j;
  int i;
  int local_20;
  
  local_b0 = t;
  local_b4 = newwidth;
  local_b8 = minv;
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  corr = 0;
  cell = &t->cell;
  local_d4 = t->maxcol + 1;
  local_50 = t->maxcol;
  local_cc = local_d4 * 0x10;
  local_c8 = local_d4 >> 0x1c;
  local_d0 = 0;
  local_dc = local_d4 * 0x10;
  local_d8 = local_d4 >> 0x1c;
  iVar2 = -(local_d4 * 2 + 0x1e & 0xfffffff0);
  orgwidth = asStack320 + iVar2;
  local_e4 = t->maxcol + 1;
  local_58 = t->maxcol;
  local_e0 = 0;
  local_ec = local_e4 * 0x10;
  local_e8 = local_e4 >> 0x1c;
  local_f4 = local_e4;
  local_f0 = 0;
  local_fc = local_e4 * 0x10;
  local_f8 = local_e4 >> 0x1c;
  iVar3 = -(local_e4 * 2 + 0x1e & 0xfffffff0);
  corwidth = asStack320 + iVar3 + iVar2;
  local_60 = (int)(t->cell).maxcell;
  local_104 = local_60 + 1;
  local_100 = 0;
  local_10c = local_104 * 0x10;
  local_108 = local_104 >> 0x1c;
  local_114 = local_104;
  local_110 = 0;
  local_11c = local_104 * 0x10;
  local_118 = local_104 >> 0x1c;
  iVar4 = -(local_104 * 2 + 0x1e & 0xfffffff0);
  cwidth = asStack320 + iVar4 + iVar3 + iVar2;
  local_68 = (int)(t->cell).maxcell;
  local_124 = local_68 + 1;
  local_120 = 0;
  local_12c = local_124 * 0x40;
  local_128 = local_124 >> 0x1a & 0xf;
  local_134 = local_124;
  local_130 = 0;
  local_13c = local_124 * 0x40;
  local_138 = local_124 >> 0x1a & 0xf;
  iVar5 = -(local_124 * 8 + 0x1e & 0xfffffff0);
  swidth = asStack320 + iVar5 + iVar4 + iVar3 + iVar2;
  twidth = 0.0;
  stotal = 0.0;
  for (i = 0; i <= t->maxcol; i = i + 1) {
    twidth = twidth + newwidth[i];
    stotal = stotal + *(double *)((int)minv->me + (minv->dim + 1) * 8 * i);
    for (m = 0; m < i; m = m + 1) {
      stotal = stotal + minv->me[minv->dim * i + m] + minv->me[minv->dim * i + m];
    }
  }
  *(int *)((int)&uStack380 + iVar5 + iVar4 + iVar3 + iVar2) = ((t->cell).maxcell + 1) * 8;
  *(undefined4 *)((int)&uStack380 + iVar5 + iVar4 + iVar3 + iVar2 + -4) = 0x8083737;
  Sxx = (double *)GC_malloc_atomic();
  psVar7 = cwidth;
  pdVar6 = swidth;
  for (k = 0; k <= cell->maxcell; k = k + 1) {
    j = (int)cell->index[k];
    bcol = (int)cell->col[j];
    ecol = cell->colspan[j] + bcol;
    *(undefined8 *)(swidth + j * 8) = 0;
    for (i = bcol; i < ecol; i = i + 1) {
      *(double *)(swidth + j * 8) = local_b4[i] + *(double *)(swidth + j * 8);
    }
    *(short *)(cwidth + j * 2) =
         cell->width[j] + (short)local_b0->cellspacing * (1 - cell->colspan[j]);
    Sxx[j] = 0.0;
    for (i = bcol; i < ecol; i = i + 1) {
      Sxx[j] = *(double *)((int)local_b8->me + (local_b8->dim + 1) * 8 * i) + Sxx[j];
      for (m = bcol; m <= ecol; m = m + 1) {
        if (m < i) {
          Sxx[j] = local_b8->me[local_b8->dim * i + m] + local_b8->me[local_b8->dim * i + m] +
                   Sxx[j];
        }
      }
    }
  }
  *(int *)((int)aiStack332 + iVar5 + iVar4 + iVar3 + iVar2) = corr;
  *(double *)((int)&dStack340 + iVar5 + iVar4 + iVar3 + iVar2) = stotal;
  *(undefined4 *)((int)aiStack348 + iVar5 + iVar4 + iVar3 + iVar2 + 4) = 0xffffffff;
  *(undefined4 *)((int)aiStack348 + iVar5 + iVar4 + iVar3 + iVar2) = 0xffffffff;
  *(double **)((int)&pdStack352 + iVar5 + iVar4 + iVar3 + iVar2) = Sxx;
  *(double *)(auStack364 + iVar5 + iVar4 + iVar3 + iVar2 + 4) = twidth;
  *(short_0_ **)(auStack364 + iVar5 + iVar4 + iVar3 + iVar2) = psVar7;
  *(double_0_ **)((int)apdStack372 + iVar5 + iVar4 + iVar3 + iVar2 + 4) = pdVar6;
  *(double **)((int)apdStack372 + iVar5 + iVar4 + iVar3 + iVar2) = local_b4;
  *(MAT **)((int)apdStack372 + iVar5 + iVar4 + iVar3 + iVar2 + -4) = local_b8;
  *(table **)((int)&uStack380 + iVar5 + iVar4 + iVar3 + iVar2) = local_b0;
  *(undefined4 *)((int)&uStack380 + iVar5 + iVar4 + iVar3 + iVar2 + -4) = 0x8083929;
  iVar8 = check_compressible_cell
                    (*(table **)((int)&uStack380 + iVar5 + iVar4 + iVar3 + iVar2),
                     *(MAT **)((int)apdStack372 + iVar5 + iVar4 + iVar3 + iVar2 + -4),
                     *(double **)((int)apdStack372 + iVar5 + iVar4 + iVar3 + iVar2),
                     *(double **)((int)apdStack372 + iVar5 + iVar4 + iVar3 + iVar2 + 4),
                     *(short **)(auStack364 + iVar5 + iVar4 + iVar3 + iVar2),
                     *(double *)(auStack364 + iVar5 + iVar4 + iVar3 + iVar2 + 4),
                     *(double **)((int)&pdStack352 + iVar5 + iVar4 + iVar3 + iVar2),
                     *(int *)((int)aiStack348 + iVar5 + iVar4 + iVar3 + iVar2),
                     *(int *)((int)aiStack348 + iVar5 + iVar4 + iVar3 + iVar2 + 4),
                     *(double *)((int)&dStack340 + iVar5 + iVar4 + iVar3 + iVar2),
                     *(int *)((int)aiStack332 + iVar5 + iVar4 + iVar3 + iVar2));
  corr = iVar8;
  if ((9 < itr) || (iVar8 < 1)) {
    for (k = (int)cell->maxcell; psVar7 = cwidth, pdVar6 = swidth, -1 < k; k = k + -1) {
      j = (int)cell->index[k];
      dVar9 = Sxx[cell->index[k]];
      *(int *)((int)aiStack332 + iVar5 + iVar4 + iVar3 + iVar2) = corr;
      *(double *)((int)&dStack340 + iVar5 + iVar4 + iVar3 + iVar2) = dVar9;
      *(int *)((int)aiStack348 + iVar5 + iVar4 + iVar3 + iVar2 + 4) = j;
      *(undefined4 *)((int)aiStack348 + iVar5 + iVar4 + iVar3 + iVar2) = 0xffffffff;
      *(double **)((int)&pdStack352 + iVar5 + iVar4 + iVar3 + iVar2) = Sxx;
      *(double *)(auStack364 + iVar5 + iVar4 + iVar3 + iVar2 + 4) = twidth;
      *(short_0_ **)(auStack364 + iVar5 + iVar4 + iVar3 + iVar2) = psVar7;
      *(double_0_ **)((int)apdStack372 + iVar5 + iVar4 + iVar3 + iVar2 + 4) = pdVar6;
      *(double **)((int)apdStack372 + iVar5 + iVar4 + iVar3 + iVar2) = local_b4;
      *(MAT **)((int)apdStack372 + iVar5 + iVar4 + iVar3 + iVar2 + -4) = local_b8;
      *(table **)((int)&uStack380 + iVar5 + iVar4 + iVar3 + iVar2) = local_b0;
      *(undefined4 *)((int)&uStack380 + iVar5 + iVar4 + iVar3 + iVar2 + -4) = 0x80839c4;
      corr = check_compressible_cell
                       (*(table **)((int)&uStack380 + iVar5 + iVar4 + iVar3 + iVar2),
                        *(MAT **)((int)apdStack372 + iVar5 + iVar4 + iVar3 + iVar2 + -4),
                        *(double **)((int)apdStack372 + iVar5 + iVar4 + iVar3 + iVar2),
                        *(double **)((int)apdStack372 + iVar5 + iVar4 + iVar3 + iVar2 + 4),
                        *(short **)(auStack364 + iVar5 + iVar4 + iVar3 + iVar2),
                        *(double *)(auStack364 + iVar5 + iVar4 + iVar3 + iVar2 + 4),
                        *(double **)((int)&pdStack352 + iVar5 + iVar4 + iVar3 + iVar2),
                        *(int *)((int)aiStack348 + iVar5 + iVar4 + iVar3 + iVar2),
                        *(int *)((int)aiStack348 + iVar5 + iVar4 + iVar3 + iVar2 + 4),
                        *(double *)((int)&dStack340 + iVar5 + iVar4 + iVar3 + iVar2),
                        *(int *)((int)aiStack332 + iVar5 + iVar4 + iVar3 + iVar2));
      if ((itr < 10) && (iVar8 = corr, 0 < corr)) goto LAB_08083eda;
    }
    for (i = 0; psVar7 = cwidth, pdVar6 = swidth, i <= local_b0->maxcol; i = i + 1) {
      dVar9 = *(double *)((int)local_b8->me + (local_b8->dim + 1) * 8 * i);
      *(int *)((int)aiStack332 + iVar5 + iVar4 + iVar3 + iVar2) = corr;
      *(double *)((int)&dStack340 + iVar5 + iVar4 + iVar3 + iVar2) = dVar9;
      *(undefined4 *)((int)aiStack348 + iVar5 + iVar4 + iVar3 + iVar2 + 4) = 0xffffffff;
      *(int *)((int)aiStack348 + iVar5 + iVar4 + iVar3 + iVar2) = i;
      *(double **)((int)&pdStack352 + iVar5 + iVar4 + iVar3 + iVar2) = Sxx;
      *(double *)(auStack364 + iVar5 + iVar4 + iVar3 + iVar2 + 4) = twidth;
      *(short_0_ **)(auStack364 + iVar5 + iVar4 + iVar3 + iVar2) = psVar7;
      *(double_0_ **)((int)apdStack372 + iVar5 + iVar4 + iVar3 + iVar2 + 4) = pdVar6;
      *(double **)((int)apdStack372 + iVar5 + iVar4 + iVar3 + iVar2) = local_b4;
      *(MAT **)((int)apdStack372 + iVar5 + iVar4 + iVar3 + iVar2 + -4) = local_b8;
      *(table **)((int)&uStack380 + iVar5 + iVar4 + iVar3 + iVar2) = local_b0;
      *(undefined4 *)((int)&uStack380 + iVar5 + iVar4 + iVar3 + iVar2 + -4) = 0x8083a6d;
      corr = check_compressible_cell
                       (*(table **)((int)&uStack380 + iVar5 + iVar4 + iVar3 + iVar2),
                        *(MAT **)((int)apdStack372 + iVar5 + iVar4 + iVar3 + iVar2 + -4),
                        *(double **)((int)apdStack372 + iVar5 + iVar4 + iVar3 + iVar2),
                        *(double **)((int)apdStack372 + iVar5 + iVar4 + iVar3 + iVar2 + 4),
                        *(short **)(auStack364 + iVar5 + iVar4 + iVar3 + iVar2),
                        *(double *)(auStack364 + iVar5 + iVar4 + iVar3 + iVar2 + 4),
                        *(double **)((int)&pdStack352 + iVar5 + iVar4 + iVar3 + iVar2),
                        *(int *)((int)aiStack348 + iVar5 + iVar4 + iVar3 + iVar2),
                        *(int *)((int)aiStack348 + iVar5 + iVar4 + iVar3 + iVar2 + 4),
                        *(double *)((int)&dStack340 + iVar5 + iVar4 + iVar3 + iVar2),
                        *(int *)((int)aiStack332 + iVar5 + iVar4 + iVar3 + iVar2));
      if ((itr < 10) && (iVar8 = corr, 0 < corr)) goto LAB_08083eda;
    }
    for (i = 0; iVar8 = i, i <= local_b0->maxcol; i = i + 1) {
      *(double *)((int)&uStack380 + iVar5 + iVar4 + iVar3 + iVar2) = local_b4[i] + 0.5;
      *(undefined4 *)((int)&uStack380 + iVar5 + iVar4 + iVar3 + iVar2 + -4) = 0x8083ac7;
      dVar9 = floor(*(double *)((int)&uStack380 + iVar5 + iVar4 + iVar3 + iVar2));
      local_ba = in_FPUControlWord;
      local_bc = CONCAT11(0xc,(char)in_FPUControlWord);
      local_c0 = (int)ROUND(dVar9);
      *(short *)(orgwidth + iVar8 * 2) = (short)(int)ROUND(dVar9);
      *(undefined2 *)(corwidth + iVar8 * 2) = *(undefined2 *)(orgwidth + iVar8 * 2);
    }
    *(short_0_ **)((int)apdStack372 + iVar5 + iVar4 + iVar3 + iVar2 + -4) = corwidth;
    *(table **)((int)&uStack380 + iVar5 + iVar4 + iVar3 + iVar2) = local_b0;
    *(undefined4 *)((int)&uStack380 + iVar5 + iVar4 + iVar3 + iVar2 + -4) = 0x8083b33;
    check_minimum_width(*(table **)((int)&uStack380 + iVar5 + iVar4 + iVar3 + iVar2),
                        *(short **)((int)apdStack372 + iVar5 + iVar4 + iVar3 + iVar2 + -4));
    for (i = 0; i <= local_b0->maxcol; i = i + 1) {
      *(double *)((int)&uStack380 + iVar5 + iVar4 + iVar3 + iVar2) =
           *(double *)((int)local_b8->me + (local_b8->dim + 1) * 8 * i);
      *(undefined4 *)((int)&uStack380 + iVar5 + iVar4 + iVar3 + iVar2 + -4) = 0x8083b67;
      sx = sqrt(*(double *)((int)&uStack380 + iVar5 + iVar4 + iVar3 + iVar2));
      if (((0.1 <= sx) && (*(short *)(orgwidth + i * 2) < local_b0->minimum_width[i])) &&
         (*(short *)(corwidth + i * 2) == local_b0->minimum_width[i])) {
        if (sx <= 0.5) {
          w = sx * 0.2;
        }
        else {
          w = 0.5;
        }
        sxy = 0.0;
        for (m = 0; m <= local_b0->maxcol; m = m + 1) {
          if (m != i) {
            sxy = sxy + local_b8->me[local_b8->dim * i + m];
          }
        }
        if (sxy <= 0.0) {
          sVar1 = local_b0->minimum_width[i];
          *(double *)(auStack364 + iVar5 + iVar4 + iVar3 + iVar2) = w;
          *(int *)((int)apdStack372 + iVar5 + iVar4 + iVar3 + iVar2 + 4) = (int)sVar1;
          *(undefined4 *)((int)apdStack372 + iVar5 + iVar4 + iVar3 + iVar2) = 1;
          *(int *)((int)apdStack372 + iVar5 + iVar4 + iVar3 + iVar2 + -4) = i;
          *(table **)((int)&uStack380 + iVar5 + iVar4 + iVar3 + iVar2) = local_b0;
          *(undefined4 *)((int)&uStack380 + iVar5 + iVar4 + iVar3 + iVar2 + -4) = 0x8083ca5;
          correct_table_matrix
                    (*(table **)((int)&uStack380 + iVar5 + iVar4 + iVar3 + iVar2),
                     *(int *)((int)apdStack372 + iVar5 + iVar4 + iVar3 + iVar2 + -4),
                     *(int *)((int)apdStack372 + iVar5 + iVar4 + iVar3 + iVar2),
                     *(int *)((int)apdStack372 + iVar5 + iVar4 + iVar3 + iVar2 + 4),
                     *(double *)(auStack364 + iVar5 + iVar4 + iVar3 + iVar2));
          corr = corr + 1;
        }
      }
    }
    for (k = 0; k <= cell->maxcell; k = k + 1) {
      nwidth = 0;
      j = (int)cell->index[k];
      *(double *)((int)&uStack380 + iVar5 + iVar4 + iVar3 + iVar2) = Sxx[cell->index[k]];
      *(undefined4 *)((int)&uStack380 + iVar5 + iVar4 + iVar3 + iVar2 + -4) = 0x8083cf9;
      sx_1 = sqrt(*(double *)((int)&uStack380 + iVar5 + iVar4 + iVar3 + iVar2));
      if (0.1 <= sx_1) {
        bcol = (int)cell->col[j];
        ecol = cell->colspan[j] + bcol;
        for (i = bcol; i < ecol; i = i + 1) {
          nwidth = nwidth + *(short *)(corwidth + i * 2);
        }
        mwidth = (int)cell->minimum_width[j] + local_b0->cellspacing * (1 - cell->colspan[j]);
        if ((*(double *)(swidth + j * 8) < (double)mwidth) && (mwidth == nwidth)) {
          if (sx_1 <= 0.5) {
            w_1 = sx_1 * 0.2;
          }
          else {
            w_1 = 0.5;
          }
          sxy = 0.0;
          for (i = bcol; i < ecol; i = i + 1) {
            for (m = 0; m <= local_b0->maxcol; m = m + 1) {
              if ((m < bcol) || (ecol <= m)) {
                sxy = sxy + local_b8->me[local_b8->dim * i + m];
              }
            }
          }
          if (sxy <= 0.0) {
            sVar1 = cell->colspan[j];
            *(double *)(auStack364 + iVar5 + iVar4 + iVar3 + iVar2) = w_1;
            *(int *)((int)apdStack372 + iVar5 + iVar4 + iVar3 + iVar2 + 4) = mwidth;
            *(int *)((int)apdStack372 + iVar5 + iVar4 + iVar3 + iVar2) = (int)sVar1;
            *(int *)((int)apdStack372 + iVar5 + iVar4 + iVar3 + iVar2 + -4) = bcol;
            *(table **)((int)&uStack380 + iVar5 + iVar4 + iVar3 + iVar2) = local_b0;
            *(undefined4 *)((int)&uStack380 + iVar5 + iVar4 + iVar3 + iVar2 + -4) = 0x8083eae;
            correct_table_matrix
                      (*(table **)((int)&uStack380 + iVar5 + iVar4 + iVar3 + iVar2),
                       *(int *)((int)apdStack372 + iVar5 + iVar4 + iVar3 + iVar2 + -4),
                       *(int *)((int)apdStack372 + iVar5 + iVar4 + iVar3 + iVar2),
                       *(int *)((int)apdStack372 + iVar5 + iVar4 + iVar3 + iVar2 + 4),
                       *(double *)(auStack364 + iVar5 + iVar4 + iVar3 + iVar2));
            corr = corr + 1;
          }
        }
      }
    }
    iVar8 = corr;
    if (9 < itr) {
      iVar8 = 0;
    }
  }
LAB_08083eda:
  if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {
    return iVar8;
  }
                    // WARNING: Subroutine does not return
  ptStack384 = (table *)0x8083eed;
  __stack_chk_fail();
}



void check_table_height(table *t)

{
  int iVar1;
  int iVar2;
  int iVar3;
  anon_struct_for_cell cell;
  int ii;
  int idx;
  int c;
  int rowspan;
  int t_dep;
  int space;
  int k;
  int j;
  int i;
  
  space = 0;
  cell.size = 0;
  cell.maxcell = -1;
  for (j = 0; j <= t->maxrow; j = j + 1) {
    if (t->tabattr[j] != (table_attr *)0x0) {
      for (i = 0; i <= t->maxcol; i = i + 1) {
        if ((t->tabattr[j][i] & 3) == 0) {
          if (t->tabdata[j][i] == (GeneralList *)0x0) {
            t_dep = 0;
          }
          else {
            t_dep = (int)t->tabdata[j][i]->nitem;
          }
          iVar1 = table_rowspan(t,j,i);
          if (iVar1 < 2) {
            if (t->tabheight[j] < t_dep) {
              t->tabheight[j] = (short)t_dep;
            }
          }
          else {
            c = cell.maxcell + 1;
            iVar2 = bsearch_2short((short)iVar1,cell.rowspan,(short)j,cell.row,t->maxrow + 1,
                                   cell.indexarray,c);
            if (((iVar2 <= cell.maxcell) &&
                (iVar3 = (int)cell.indexarray[iVar2], cell.row[iVar3] == j)) &&
               (cell.rowspan[iVar3] == iVar1)) {
              c = iVar3;
            }
            if (c < 1000) {
              if (cell.size <= c) {
                if (cell.size == 0) {
                  iVar3 = c + 1;
                  if (iVar3 < 0x14) {
                    iVar3 = 0x14;
                  }
                  cell.size = (short)iVar3;
                  cell.row = (short *)GC_malloc_atomic(cell.size * 2);
                  cell.rowspan = (short *)GC_malloc_atomic(cell.size * 2);
                  cell.indexarray = (short *)GC_malloc_atomic(cell.size * 2);
                  cell.height = (short *)GC_malloc_atomic(cell.size * 2);
                }
                else {
                  iVar3 = cell.size + 0x14;
                  if (cell.size + 0x14 <= c + 1) {
                    iVar3 = c + 1;
                  }
                  cell.size = (short)iVar3;
                  cell.row = (short *)GC_realloc(cell.row,cell.size * 2);
                  cell.rowspan = (short *)GC_realloc(cell.rowspan,cell.size * 2);
                  cell.indexarray = (short *)GC_realloc(cell.indexarray,cell.size * 2);
                  cell.height = (short *)GC_realloc(cell.height,cell.size * 2);
                }
              }
              if (cell.maxcell < c) {
                cell.maxcell = cell.maxcell + 1;
                cell.row[cell.maxcell] = (short)j;
                cell.rowspan[cell.maxcell] = (short)iVar1;
                cell.height[cell.maxcell] = 0;
                if (iVar2 < cell.maxcell) {
                  for (ii = (int)cell.maxcell; iVar2 < ii; ii = ii + -1) {
                    cell.indexarray[ii] = cell.indexarray[ii + -1];
                  }
                }
                cell.indexarray[iVar2] = cell.maxcell;
              }
              if (cell.height[c] < t_dep) {
                cell.height[c] = (short)t_dep;
              }
            }
          }
        }
      }
    }
  }
  iVar1 = t->border_mode;
  if (iVar1 == 0) {
    space = 0;
  }
  else if ((-1 < iVar1) && (iVar1 < 4)) {
    space = 1;
  }
  check_cell_width(t->tabheight,cell.height,cell.row,cell.rowspan,cell.maxcell,cell.indexarray,space
                   ,1);
  return;
}



int get_table_width(table *t,short *orgwidth,short *cellwidth,int flag)

{
  short *psVar1;
  short *psVar2;
  int iVar3;
  int iVar4;
  short_0_ *psVar5;
  table_cell *ptVar6;
  short_0_ *psVar7;
  int iVar8;
  short sVar9;
  table **pptVar10;
  int in_GS_OFFSET;
  undefined4 uStack192;
  table *ptStack188;
  short *psStack184;
  table_cell *ptStack180;
  short *psStack176;
  int iStack172;
  short *psStack168;
  int aiStack164 [5];
  undefined4 local_90;
  int local_8c;
  uint local_88;
  uint local_84;
  undefined4 local_80;
  int local_7c;
  uint local_78;
  uint local_74;
  undefined4 local_70;
  int local_6c;
  uint local_68;
  short *local_64;
  undefined *local_60;
  undefined *local_5c;
  short *local_58;
  short *local_54;
  table *local_50;
  short_0_ *ccellwidth;
  int local_3c;
  short_0_ *newwidth;
  int local_34;
  int rulewidth;
  table_cell *cell;
  int swidth;
  int i;
  int local_20;
  
  local_50 = t;
  local_54 = orgwidth;
  local_58 = cellwidth;
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  local_5c = (undefined *)&ptStack188;
  local_74 = t->maxcol + 1;
  local_34 = t->maxcol;
  local_6c = local_74 * 0x10;
  local_68 = local_74 >> 0x1c;
  local_70 = 0;
  local_7c = local_74 * 0x10;
  local_78 = local_74 >> 0x1c;
  iVar8 = -(local_74 * 2 + 0x1e & 0xfffffff0);
  pptVar10 = (table **)((int)&ptStack188 + iVar8);
  newwidth = (short_0_ *)((int)&local_90 + iVar8);
  cell = &t->cell;
  *(table **)((int)&ptStack188 + iVar8) = t;
  *(undefined4 *)((int)&uStack192 + iVar8) = 0x808440a;
  rulewidth = table_rule_width(*(table **)((int)&ptStack188 + iVar8));
  ptVar6 = cell;
  psVar5 = newwidth;
  for (i = 0; i <= local_50->maxcol; i = i + 1) {
    sVar9 = 0;
    if (-1 < local_54[i]) {
      sVar9 = local_54[i];
    }
    *(short *)(newwidth + i * 2) = sVar9;
  }
  if ((flag & 2U) == 0) {
    iVar4 = local_50->cellspacing;
    psVar1 = cell->index;
    sVar9 = cell->maxcell;
    psVar2 = cell->colspan;
    *(undefined4 *)((int)aiStack164 + iVar8 + 4) = 0;
    *(int *)((int)aiStack164 + iVar8) = iVar4;
    *(short **)((int)&psStack168 + iVar8) = psVar1;
    *(int *)((int)&iStack172 + iVar8) = (int)sVar9;
    *(short **)((int)&psStack176 + iVar8) = psVar2;
    *(table_cell **)((int)&ptStack180 + iVar8) = ptVar6;
    *(short **)((int)&psStack184 + iVar8) = local_58;
    *(short_0_ **)((int)&ptStack188 + iVar8) = psVar5;
    *(undefined4 *)((int)&uStack192 + iVar8) = 0x808467d;
    check_cell_width(*(short **)((int)&ptStack188 + iVar8),*(short **)((int)&psStack184 + iVar8),
                     *(short **)((int)&ptStack180 + iVar8),*(short **)((int)&psStack176 + iVar8),
                     *(short *)((int)&iStack172 + iVar8),*(short **)((int)&psStack168 + iVar8),
                     *(int *)((int)aiStack164 + iVar8),*(int *)((int)aiStack164 + iVar8 + 4));
  }
  else {
    local_60 = (undefined *)((int)&ptStack188 + iVar8);
    local_84 = (int)cell->maxcell + 1;
    local_3c = (int)cell->maxcell;
    local_80 = 0;
    local_8c = local_84 * 0x10;
    local_88 = local_84 >> 0x1c;
    aiStack164[4] = local_84;
    local_90 = 0;
    aiStack164[2] = local_84 * 0x10;
    aiStack164[3] = local_84 >> 0x1c;
    iVar4 = -(local_84 * 2 + 0x1e & 0xfffffff0);
    psVar7 = (short_0_ *)((int)&local_90 + iVar4 + iVar8);
    ccellwidth = psVar7;
    for (i = 0; i <= local_50->maxcol; i = i + 1) {
      if (*(short *)(newwidth + i * 2) < local_50->fixed_width[i]) {
        *(short *)(newwidth + i * 2) = local_50->fixed_width[i];
      }
    }
    for (i = 0; i <= cell->maxcell; i = i + 1) {
      *(short *)(psVar7 + i * 2) = local_58[i];
      if (*(short *)(psVar7 + i * 2) < cell->fixed_width[i]) {
        *(short *)(psVar7 + i * 2) = cell->fixed_width[i];
      }
    }
    iVar3 = local_50->cellspacing;
    psVar1 = cell->index;
    sVar9 = cell->maxcell;
    local_64 = cell->colspan;
    *(undefined4 *)((int)aiStack164 + iVar4 + iVar8 + 4) = 0;
    *(int *)((int)aiStack164 + iVar4 + iVar8) = iVar3;
    *(short **)((int)aiStack164 + iVar4 + iVar8 + -4) = psVar1;
    *(int *)((int)&iStack172 + iVar4 + iVar8) = (int)sVar9;
    *(short **)((int)&psStack176 + iVar4 + iVar8) = local_64;
    *(table_cell **)((int)&ptStack180 + iVar4 + iVar8) = ptVar6;
    *(short_0_ **)((int)&psStack184 + iVar4 + iVar8) = psVar7;
    *(short_0_ **)((int)&ptStack188 + iVar4 + iVar8) = psVar5;
    *(undefined4 *)((int)&uStack192 + iVar4 + iVar8) = 0x808462b;
    check_cell_width(*(short **)((int)&ptStack188 + iVar4 + iVar8),
                     *(short **)((int)&psStack184 + iVar4 + iVar8),
                     *(short **)((int)&ptStack180 + iVar4 + iVar8),
                     *(short **)((int)&psStack176 + iVar4 + iVar8),
                     *(short *)((int)&iStack172 + iVar4 + iVar8),
                     *(short **)((int)aiStack164 + iVar4 + iVar8 + -4),
                     *(int *)((int)aiStack164 + iVar4 + iVar8),
                     *(int *)((int)aiStack164 + iVar4 + iVar8 + 4));
    pptVar10 = (table **)local_60;
  }
  if ((flag & 1U) != 0) {
    pptVar10[1] = (table *)newwidth;
    *pptVar10 = local_50;
    pptVar10[-1] = (table *)0x8084699;
    check_minimum_width(*pptVar10,(short *)pptVar10[1]);
  }
  swidth = 0;
  for (i = 0; i <= local_50->maxcol; i = i + 1) {
    sVar9 = *(short *)(newwidth + i * 2);
    pptVar10[1] = (table *)rulewidth;
    *pptVar10 = (table *)(int)sVar9;
    pptVar10[-1] = (table *)0x80846c3;
    iVar8 = ceil_at_intervals((int)*pptVar10,(int)pptVar10[1]);
    swidth = swidth + iVar8;
  }
  *pptVar10 = local_50;
  pptVar10[-1] = (table *)0x80846e0;
  iVar8 = table_border_width(*pptVar10);
  swidth = swidth + iVar8;
  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    *(undefined4 *)(local_5c + -4) = 0x80846fa;
    __stack_chk_fail();
  }
  return swidth;
}



void renderCoTable(table *tbl,int maxlimit)

{
  table *t_00;
  int row_00;
  int indent_00;
  int limit;
  readbuffer obuf;
  environment envs [20];
  html_feed_environ h_env;
  int maxwidth;
  int indent;
  int row;
  int col;
  int i;
  table *t;
  
  for (i = 0; i < tbl->ntable; i = i + 1) {
    t_00 = tbl->tables[i].ptr;
    row_00 = (int)tbl->tables[i].row;
    indent_00 = (int)tbl->tables[i].indent;
    limit = get_spec_cell_width(tbl,row_00,(int)tbl->tables[i].col);
    init_henv(&h_env,&obuf,envs,0x14,tbl->tables[i].buf,limit,indent_00);
    check_row(tbl,row_00);
    if (maxlimit < h_env.limit) {
      h_env.limit = maxlimit;
    }
    if (t_00->total_width == 0) {
      maxwidth = h_env.limit - indent_00;
    }
    else if (t_00->total_width < 1) {
      t_00->total_width = (-t_00->total_width * h_env.limit) / 100;
      maxwidth = t_00->total_width;
    }
    else {
      maxwidth = t_00->total_width;
    }
    renderTable(t_00,maxwidth,&h_env);
  }
  return;
}



void make_caption(table *t,html_feed_environ *h_env)

{
  char cVar1;
  int iVar2;
  TextLineList *buf;
  readbuffer obuf;
  environment envs [20];
  html_feed_environ henv;
  int limit;
  
  if (0 < t->caption->length) {
    if (t->total_width < 1) {
      limit = h_env->limit;
    }
    else {
      limit = t->total_width;
    }
    cVar1 = h_env->envs[h_env->envc].indent;
    buf = (TextLineList *)newGeneralList();
    init_henv(&henv,&obuf,envs,0x14,buf,limit,(int)cVar1);
    HTMLlineproc0("<center>",&henv,1);
    HTMLlineproc0(t->caption->ptr,&henv,0);
    HTMLlineproc0("</center>",&henv,1);
    if (t->total_width < henv.maxlimit) {
      t->total_width = henv.maxlimit;
    }
    iVar2 = h_env->limit;
    h_env->limit = t->total_width;
    HTMLlineproc0("<center>",h_env,1);
    HTMLlineproc0(t->caption->ptr,h_env,0);
    HTMLlineproc0("</center>",h_env,1);
    h_env->limit = iVar2;
  }
  return;
}



void renderTable(table *t,int max_width,html_feed_environ *h_env)

{
  GeneralList **ppGVar1;
  char cVar2;
  int iVar3;
  int iVar4;
  Matrix A;
  int *indexarray;
  Vector x;
  Matrix out;
  GeneralList *pGVar5;
  TextLine *s;
  char *pcVar6;
  Str p_Var7;
  Str p_Var8;
  Str p_Var9;
  short new_tabwidth [50];
  int k;
  TextLineList *l;
  Str idtag;
  Str vrulec;
  Str vruleb;
  Str vrulea;
  int rulewidth;
  int width;
  PERM *pivot;
  MAT *minv;
  MAT *mat;
  VEC *newwidth;
  int itr;
  Str renderbuf;
  int h;
  int r;
  int w;
  int j;
  int i;
  
  vrulea = (Str)0x0;
  vrulec = (Str)0x0;
  t->total_height = 0;
  if (t->maxcol < 0) {
    make_caption(t,h_env);
    return;
  }
  if (max_width < t->sloppy_width) {
    max_width = t->sloppy_width;
  }
  iVar3 = table_rule_width(t);
  iVar4 = table_border_width(t);
  max_width = max_width - iVar4;
  if (1 < iVar3) {
    max_width = floor_at_intervals(max_width,iVar3);
  }
  if (max_width < iVar3) {
    max_width = iVar3;
  }
  check_maximum_width(t);
  if (t->maxcol == 0) {
    if (max_width < t->tabwidth[0]) {
      t->tabwidth[0] = (short)max_width;
    }
    if (t->total_width < 1) {
      if (0 < t->fixed_width[0]) {
        t->tabwidth[0] = t->fixed_width[0];
      }
    }
    else {
      t->tabwidth[0] = (short)max_width;
    }
    if (t->tabwidth[0] < t->minimum_width[0]) {
      t->tabwidth[0] = t->minimum_width[0];
    }
  }
  else {
    set_table_matrix(t,max_width);
    itr = 0;
    A = new_matrix(t->maxcol + 1);
    indexarray = (int *)GC_malloc((t->maxcol + 1) * 4);
    x = new_vector(t->maxcol + 1);
    out = new_matrix(t->maxcol + 1);
    do {
      bcopy(t->matrix->me,A->me,t->matrix->dim * t->matrix->dim * 8);
      LUfactor(A,indexarray);
      LUsolve(A,indexarray,t->vector,x);
      LUinverse(A,indexarray,out);
      itr = itr + 1;
      iVar4 = check_table_width(t,x->ve,out,itr);
    } while (iVar4 != 0);
    set_integered_width(t,x->ve,new_tabwidth);
    check_minimum_width(t,new_tabwidth);
    t->matrix = (MAT *)0x0;
    t->vector = (VEC *)0x0;
    for (i = 0; i <= t->maxcol; i = i + 1) {
      t->tabwidth[i] = new_tabwidth[i];
    }
  }
  check_minimum_width(t,t->tabwidth);
  for (i = 0; i <= t->maxcol; i = i + 1) {
    iVar4 = ceil_at_intervals((int)t->tabwidth[i],iVar3);
    t->tabwidth[i] = (short)iVar4;
  }
  renderCoTable(t,h_env->limit);
  for (i = 0; i <= t->maxcol; i = i + 1) {
    for (j = 0; j <= t->maxrow; j = j + 1) {
      check_row(t,j);
      if ((t->tabattr[j][i] & 2) == 0) {
        do_refill(t,j,i,h_env->limit);
      }
    }
  }
  check_minimum_width(t,t->tabwidth);
  t->total_width = 0;
  for (i = 0; i <= t->maxcol; i = i + 1) {
    iVar4 = ceil_at_intervals((int)t->tabwidth[i],iVar3);
    t->tabwidth[i] = (short)iVar4;
    t->total_width = t->total_width + (int)t->tabwidth[i];
  }
  iVar3 = t->total_width;
  iVar4 = table_border_width(t);
  t->total_width = iVar3 + iVar4;
  check_table_height(t);
  for (i = 0; i <= t->maxcol; i = i + 1) {
    for (j = 0; j <= t->maxrow; j = j + 1) {
      if ((((t->tabattr[j][i] & 2) == 0) && ((t->tabattr[j][i] & 0x100) == 0)) &&
         (t->tabdata[j][i] != (GeneralList *)0x0)) {
        h = (int)t->tabheight[j];
        k = j;
        while ((k = k + 1, k <= t->maxrow && ((t->tabattr[k][i] & 2) != 0))) {
          h = h + t->tabheight[k];
          if (t->border_mode - 1U < 3) {
            h = h + 1;
          }
        }
        h = h - t->tabdata[j][i]->nitem;
        if ((t->tabattr[j][i] & 0x200) != 0) {
          h = h / 2;
        }
        if (0 < h) {
          pGVar5 = newGeneralList();
          for (k = 0; k < h; k = k + 1) {
            s = newTextLine((Str)0x0,0);
            pushValue(pGVar5,s);
          }
          ppGVar1 = t->tabdata[j];
          pGVar5 = appendGeneralList(pGVar5,t->tabdata[j][i]);
          ppGVar1[i] = pGVar5;
        }
      }
    }
  }
  iVar3 = t->total_width;
  make_caption(t,h_env);
  HTMLlineproc0("<pre for_table>",h_env,1);
  if (t->id != (Str)0x0) {
    pcVar6 = html_quote(t->id->ptr);
    p_Var7 = Sprintf("<_id id=\"%s\">",pcVar6);
    HTMLlineproc0(p_Var7->ptr,h_env,1);
  }
  if (t->border_mode - 1U < 2) {
    p_Var7 = Strnew();
    print_sep(t,-1,0,t->maxcol,p_Var7);
    push_render_image(p_Var7,iVar3,t->total_width,h_env);
    t->total_height = t->total_height + 1;
  }
  p_Var7 = Strnew();
  iVar4 = t->border_mode;
  if (iVar4 < 3) {
    if (iVar4 < 1) {
      if (iVar4 == 0) {
        for (i = 0; i < t->cellspacing; i = i + 1) {
          if (p_Var7->area_size <= p_Var7->length + 1) {
            Strgrow(p_Var7);
          }
          iVar4 = p_Var7->length;
          p_Var7->ptr[iVar4] = ' ';
          p_Var7->length = iVar4 + 1;
          p_Var7->ptr[p_Var7->length] = '\0';
        }
      }
      goto LAB_0808546e;
    }
    vrulea = Strnew();
    vrulec = Strnew();
    if (t->border_mode == 2) {
      cVar2 = '\x15';
    }
    else {
      cVar2 = '\x05';
    }
    push_symbol(vrulea,cVar2,symbol_width,1);
    for (i = 0; i < t->cellpadding; i = i + 1) {
      if (vrulea->area_size <= vrulea->length + 1) {
        Strgrow(vrulea);
      }
      iVar4 = vrulea->length;
      vrulea->ptr[iVar4] = ' ';
      vrulea->length = iVar4 + 1;
      vrulea->ptr[vrulea->length] = '\0';
      if (p_Var7->area_size <= p_Var7->length + 1) {
        Strgrow(p_Var7);
      }
      iVar4 = p_Var7->length;
      p_Var7->ptr[iVar4] = ' ';
      p_Var7->length = iVar4 + 1;
      p_Var7->ptr[p_Var7->length] = '\0';
      if (vrulec->area_size <= vrulec->length + 1) {
        Strgrow(vrulec);
      }
      iVar4 = vrulec->length;
      vrulec->ptr[iVar4] = ' ';
      vrulec->length = iVar4 + 1;
      vrulec->ptr[vrulec->length] = '\0';
    }
    if (t->border_mode == 2) {
      cVar2 = '\x15';
    }
    else {
      cVar2 = '\x05';
    }
    push_symbol(vrulec,cVar2,symbol_width,1);
  }
  else if (iVar4 != 3) goto LAB_0808546e;
  push_symbol(p_Var7,'\x05',symbol_width,1);
  for (i = 0; i < t->cellpadding; i = i + 1) {
    if (p_Var7->area_size <= p_Var7->length + 1) {
      Strgrow(p_Var7);
    }
    iVar4 = p_Var7->length;
    p_Var7->ptr[iVar4] = ' ';
    p_Var7->length = iVar4 + 1;
    p_Var7->ptr[p_Var7->length] = '\0';
  }
LAB_0808546e:
  r = 0;
  do {
    if (t->maxrow < r) {
      if (t->border_mode - 1U < 2) {
        p_Var7 = Strnew();
        print_sep(t,t->maxrow,2,t->maxcol,p_Var7);
        push_render_image(p_Var7,iVar3,t->total_width,h_env);
        t->total_height = t->total_height + 1;
      }
      if (t->total_height == 0) {
        p_Var7 = Strnew_charp(" ");
        t->total_height = t->total_height + 1;
        t->total_width = 1;
        push_render_image(p_Var7,1,t->total_width,h_env);
      }
      HTMLlineproc0("</pre>",h_env,1);
      return;
    }
    for (h = 0; h < t->tabheight[r]; h = h + 1) {
      p_Var9 = Strnew();
      if ((t->border_mode == 1) || (t->border_mode == 2)) {
        Strcat(p_Var9,vrulea);
      }
      if ((t->tridvalue[r] != (Str)0x0) && (h == 0)) {
        pcVar6 = html_quote(t->tridvalue[r]->ptr);
        p_Var8 = Sprintf("<_id id=\"%s\">",pcVar6);
        Strcat(p_Var9,p_Var8);
      }
      for (i = 0; i <= t->maxcol; i = i + 1) {
        check_row(t,r);
        if ((t->tabidvalue[r][i] != (Str)0x0) && (h == 0)) {
          pcVar6 = html_quote(t->tabidvalue[r][i]->ptr);
          p_Var8 = Sprintf("<_id id=\"%s\">",pcVar6);
          Strcat(p_Var9,p_Var8);
        }
        if ((t->tabattr[r][i] & 1) == 0) {
          w = (int)t->tabwidth[i];
          iVar4 = i;
          while ((j = iVar4 + 1, j <= t->maxcol && ((t->tabattr[r][j] & 1) != 0))) {
            w = w + (int)t->tabwidth[iVar4 + 1] + t->cellspacing;
            iVar4 = j;
          }
          j = r;
          if ((t->tabattr[r][i] & 2) == 0) {
            print_item(t,r,i,w,p_Var9);
          }
          else {
            do {
              j = j + -1;
              if ((j < 0) || (t->tabattr[j] == (table_attr *)0x0)) break;
            } while ((t->tabattr[j][i] & 2) != 0);
            print_item(t,j,i,w,p_Var9);
          }
        }
        if ((i < t->maxcol) && ((t->tabattr[r][i + 1] & 1) == 0)) {
          Strcat(p_Var9,p_Var7);
        }
      }
      if (t->border_mode - 1U < 2) {
        Strcat(p_Var9,vrulec);
        t->total_height = t->total_height + 1;
      }
      push_render_image(p_Var9,iVar3,t->total_width,h_env);
    }
    if ((r < t->maxrow) && (t->border_mode != 0)) {
      p_Var9 = Strnew();
      print_sep(t,r,1,t->maxcol,p_Var9);
      push_render_image(p_Var9,iVar3,t->total_width,h_env);
    }
    t->total_height = t->total_height + (int)t->tabheight[r];
    r = r + 1;
  } while( true );
}



table * begin_table(int border,int spacing,int padding,int vspace)

{
  int iVar1;
  int iVar2;
  table *ptVar3;
  int iVar4;
  double dVar5;
  double dVar6;
  int ppc;
  int mincell_pixels;
  int rcellspacing;
  int mincell;
  table *t;
  
  iVar2 = minimum_cellspacing(border);
  dVar5 = floor(pixel_per_char * (double)iVar2 + 0.5);
  dVar6 = floor(pixel_per_char + 0.5);
  iVar1 = (int)ROUND(dVar6);
  ptVar3 = newTable();
  ptVar3->col = -1;
  ptVar3->row = ptVar3->col;
  ptVar3->maxcol = -1;
  ptVar3->maxrow = -1;
  ptVar3->border_mode = border;
  ptVar3->flag = 0;
  if (border == 3) {
    ptVar3->flag = ptVar3->flag | 2;
  }
  iVar4 = padding * 2 + spacing;
  if (border == 0) {
    ptVar3->cellpadding = iVar4 - (int)ROUND(dVar5);
  }
  else if ((-1 < border) && (border < 4)) {
    ptVar3->cellpadding = padding - ((int)ROUND(dVar5) + -4) / 2;
  }
  if (ptVar3->cellpadding < iVar1) {
    if (ptVar3->cellpadding < 1) {
      ptVar3->cellpadding = 0;
    }
    else {
      ptVar3->cellpadding = 1;
    }
  }
  else {
    ptVar3->cellpadding = ptVar3->cellpadding / iVar1;
  }
  if (border == 0) {
    ptVar3->cellspacing = ptVar3->cellpadding + iVar2;
  }
  else if ((-1 < border) && (border < 4)) {
    ptVar3->cellspacing = ptVar3->cellpadding * 2 + iVar2;
  }
  if (border == 0) {
    if (iVar4 / 2 + vspace < 2) {
      ptVar3->vspace = 0;
    }
    else {
      ptVar3->vspace = 1;
    }
  }
  else if (vspace < iVar1) {
    ptVar3->vspace = 0;
  }
  else {
    ptVar3->vspace = 1;
  }
  if (border == 0) {
    if (iVar4 < 5) {
      ptVar3->vcellpadding = 0;
    }
    else {
      ptVar3->vcellpadding = 1;
    }
  }
  else if (padding < (iVar1 + -1) * 2) {
    ptVar3->vcellpadding = 0;
  }
  else {
    ptVar3->vcellpadding = 1;
  }
  return ptVar3;
}



void end_table(table *tbl)

{
  int iVar1;
  int iVar2;
  int rulewidth;
  int i;
  table_cell *cell;
  
  iVar1 = table_rule_width(tbl);
  if (1 < iVar1) {
    if (0 < tbl->total_width) {
      iVar2 = ceil_at_intervals(tbl->total_width,iVar1);
      tbl->total_width = iVar2;
    }
    for (i = 0; i <= tbl->maxcol; i = i + 1) {
      iVar2 = ceil_at_intervals((int)tbl->minimum_width[i],iVar1);
      tbl->minimum_width[i] = (short)iVar2;
      iVar2 = ceil_at_intervals((int)tbl->tabwidth[i],iVar1);
      tbl->tabwidth[i] = (short)iVar2;
      if (0 < tbl->fixed_width[i]) {
        iVar2 = ceil_at_intervals((int)tbl->fixed_width[i],iVar1);
        tbl->fixed_width[i] = (short)iVar2;
      }
    }
    for (i = 0; i <= (tbl->cell).maxcell; i = i + 1) {
      iVar2 = ceil_at_intervals((int)(tbl->cell).minimum_width[i],iVar1);
      (tbl->cell).minimum_width[i] = (short)iVar2;
      iVar2 = ceil_at_intervals((int)(tbl->cell).width[i],iVar1);
      (tbl->cell).width[i] = (short)iVar2;
      if (0 < (tbl->cell).fixed_width[i]) {
        iVar2 = ceil_at_intervals((int)(tbl->cell).fixed_width[i],iVar1);
        (tbl->cell).fixed_width[i] = (short)iVar2;
      }
    }
  }
  iVar1 = get_table_width(tbl,tbl->fixed_width,(tbl->cell).fixed_width,1);
  tbl->sloppy_width = iVar1;
  if (tbl->sloppy_width < tbl->total_width) {
    tbl->sloppy_width = tbl->total_width;
  }
  return;
}



void check_minimum0(table *t,int min)

{
  int iVar1;
  int iVar2;
  table_cell *cell;
  int ww;
  int w;
  int i;
  
  if ((-1 < t->col) && (-1 < t->tabwidth[t->col])) {
    check_row(t,t->row);
    iVar2 = table_colspan(t,t->row,t->col);
    iVar1 = min + t->indent;
    ww = iVar1;
    if ((iVar2 != 1) &&
       ((ww = 0, -1 < (t->cell).icell && ((t->cell).minimum_width[(t->cell).icell] < iVar1)))) {
      (t->cell).minimum_width[(t->cell).icell] = (short)iVar1;
    }
    for (i = t->col; (i <= t->maxcol && ((t->col == i || ((t->tabattr[t->row][i] & 1) != 0))));
        i = i + 1) {
      if (t->minimum_width[i] < ww) {
        t->minimum_width[i] = (short)ww;
      }
    }
  }
  return;
}



int setwidth0(table *t,table_mode *mode)

{
  int iVar1;
  table_cell *cell;
  int width;
  int w;
  
  width = t->tabcontentssize;
  if (t->col < 0) {
    width = -1;
  }
  else if (t->tabwidth[t->col] < 0) {
    width = -1;
  }
  else {
    check_row(t,t->row);
    if ('\0' < (t->linfo).prev_spaces) {
      width = width - (t->linfo).prev_spaces;
    }
    iVar1 = table_colspan(t,t->row,t->col);
    if (iVar1 == 1) {
      if (t->tabwidth[t->col] < width) {
        t->tabwidth[t->col] = (short)width;
      }
    }
    else if ((-1 < (t->cell).icell) && ((t->cell).width[(t->cell).icell] < width)) {
      (t->cell).width[(t->cell).icell] = (short)width;
    }
  }
  return width;
}



void setwidth(table *t,table_mode *mode)

{
  int min;
  int width;
  
  min = setwidth0(t,mode);
  if (-1 < min) {
    if ((t->tabattr[t->row][t->col] & 4) != 0) {
      check_minimum0(t,min);
    }
    if (((mode->pre_mode & 0x281) != 0) && (-1 < mode->nobr_offset)) {
      check_minimum0(t,min - mode->nobr_offset);
    }
  }
  return;
}



void addcontentssize(table *t,int width)

{
  if ((-1 < t->col) && (-1 < t->tabwidth[t->col])) {
    check_row(t,t->row);
    t->tabcontentssize = t->tabcontentssize + width;
  }
  return;
}



void clearcontentssize(table *t,table_mode *mode)

{
  table_close_anchor0(t,mode);
  mode->nobr_offset = 0;
  (t->linfo).prev_spaces = -1;
  Strcopy_charp_n((t->linfo).prevchar," ",1);
  (t->linfo).prev_ctype = 0;
  (t->linfo).length = 0;
  t->tabcontentssize = 0;
  return;
}



void begin_cell(table *t,table_mode *mode)

{
  GeneralList **ppGVar1;
  int iVar2;
  GeneralList *pGVar3;
  
  clearcontentssize(t,mode);
  mode->indent_level = '\0';
  mode->nobr_level = '\0';
  mode->pre_mode = 0;
  t->indent = 0;
  t->flag = t->flag | 4;
  if (t->suspended_data != (TextList *)0x0) {
    check_row(t,t->row);
    if (t->tabdata[t->row][t->col] == (GeneralList *)0x0) {
      ppGVar1 = t->tabdata[t->row];
      iVar2 = t->col;
      pGVar3 = newGeneralList();
      ppGVar1[iVar2] = pGVar3;
    }
    appendGeneralList(t->tabdata[t->row][t->col],(GeneralList *)t->suspended_data);
    t->suspended_data = (TextList *)0x0;
  }
  return;
}



void check_rowcol(table *tbl,table_mode *mode)

{
  int iVar1;
  int iVar2;
  int col;
  int row;
  
  iVar1 = tbl->row;
  iVar2 = tbl->col;
  if ((tbl->flag & 1U) == 0) {
    tbl->flag = tbl->flag | 1;
    tbl->row = tbl->row + 1;
    if (tbl->maxrow < tbl->row) {
      tbl->maxrow = tbl->row;
    }
    tbl->col = -1;
  }
  if (tbl->row == -1) {
    tbl->row = 0;
  }
  if (tbl->col == -1) {
    tbl->col = 0;
  }
  while( true ) {
    check_row(tbl,tbl->row);
    while ((tbl->col < 0x32 && ((tbl->tabattr[tbl->row][tbl->col] & 3) != 0))) {
      tbl->col = tbl->col + 1;
    }
    if (tbl->col < 0x32) break;
    tbl->col = 0;
    tbl->row = tbl->row + 1;
  }
  if (tbl->maxrow < tbl->row) {
    tbl->maxrow = tbl->row;
  }
  if (tbl->maxcol < tbl->col) {
    tbl->maxcol = tbl->col;
  }
  if ((tbl->row != iVar1) || (tbl->col != iVar2)) {
    begin_cell(tbl,mode);
  }
  tbl->flag = tbl->flag | 4;
  return;
}



int skip_space(table *t,char *line,table_linfo *linfo,int checkminimum)

{
  Str x;
  char *pcVar1;
  size_t sVar2;
  int iVar3;
  uint c_00;
  byte bVar4;
  int plen;
  int wlen;
  int len;
  int ec;
  char *c;
  char *save;
  int min;
  int w;
  Str prevchar;
  int s;
  int skip;
  Lineprop prev_ctype;
  Lineprop ctype;
  
  pcVar1 = line;
  skip = 0;
  s = (int)linfo->prev_spaces;
  prev_ctype = linfo->prev_ctype;
  x = linfo->prevchar;
  w = (int)linfo->length;
  min = 1;
  if ((*line == '<') && (sVar2 = strlen(line), pcVar1[sVar2 - 1] == '>')) {
    if (checkminimum != 0) {
      iVar3 = visible_length(line);
      check_minimum0(t,iVar3);
    }
    skip = 0;
  }
  else {
    while (pcVar1 = line, *line != '\0') {
      c = line;
      ctype = (ushort)WTF_TYPE_MAP[(byte)*line] << 8;
      if (WcOption.use_wide == '\0') {
        bVar4 = WTF_WIDTH_MAP[(byte)*line] != '\0';
      }
      else {
        bVar4 = WTF_WIDTH_MAP[(byte)*line];
      }
      len = (int)bVar4;
      plen = (int)WTF_LEN_MAP[(byte)*line];
      if (min < w) {
        min = w;
      }
      wlen = plen;
      if ((WTF_TYPE_MAP[(byte)*line] == 0) && ((MYCTYPE_MAP[(byte)*line] & 2) != 0)) {
        w = 0;
        s = s + 1;
      }
      else {
        if ((*line == '&') && (c_00 = getescapechar(&line), -1 < (int)c_00)) {
          c = conv_entity(c_00);
          ctype = (ushort)WTF_TYPE_MAP[(byte)*c] << 8;
          len = wtf_strwidth((wc_uchar *)c);
          wlen = (int)line - (int)pcVar1;
          plen = (int)WTF_LEN_MAP[(byte)*c];
        }
        if ((x->length == 0) || (iVar3 = is_boundary((uchar *)x->ptr,(uchar *)c), iVar3 == 0)) {
          w = w + len;
        }
        else {
          w = len;
        }
        if (0 < s) {
          if ((ctype == 0xa00) && (prev_ctype == 0xa00)) {
            skip = skip + s;
          }
          else {
            skip = skip + s + -1;
          }
        }
        s = 0;
        prev_ctype = ctype;
      }
      Strcopy_charp_n(x,c,plen);
      line = pcVar1 + wlen;
    }
    if (s < 2) {
      linfo->prev_spaces = (char)s;
    }
    else {
      skip = skip + s + -1;
      linfo->prev_spaces = '\x01';
    }
    linfo->prev_ctype = prev_ctype;
    linfo->prevchar = x;
    if (checkminimum != 0) {
      if (min < w) {
        min = w;
      }
      linfo->length = (short)w;
      check_minimum0(t,min);
    }
  }
  return skip;
}



void feed_table_inline_tag(table *tbl,char *line,table_mode *mode,int width)

{
  check_rowcol(tbl,mode);
  pushdata(tbl,tbl->row,tbl->col,line);
  if (-1 < width) {
    check_minimum0(tbl,width);
    addcontentssize(tbl,width);
    setwidth(tbl,mode);
  }
  return;
}



void feed_table_block_tag(table *tbl,char *line,table_mode *mode,int indent,int cmd)

{
  int offset;
  
  if (('\0' < mode->indent_level) || (indent != -1)) {
    setwidth(tbl,mode);
    feed_table_inline_tag(tbl,line,mode,-1);
    clearcontentssize(tbl,mode);
    if (indent == 1) {
      mode->indent_level = mode->indent_level + '\x01';
      if (mode->indent_level < '\v') {
        tbl->indent = tbl->indent + IndentIncr;
      }
    }
    else if ((indent == -1) &&
            (mode->indent_level = mode->indent_level + -1, mode->indent_level < '\n')) {
      tbl->indent = tbl->indent - IndentIncr;
    }
    offset = tbl->indent;
    if (((cmd == 0x13) && ('\0' < mode->indent_level)) && (mode->indent_level < '\v')) {
      offset = offset - IndentIncr;
    }
    if (0 < tbl->indent) {
      check_minimum0(tbl,0);
      addcontentssize(tbl,offset);
    }
  }
  return;
}



void table_close_select(table *tbl,table_mode *mode,int width)

{
  Str tok;
  Str tmp;
  
  tok = process_n_select();
  mode->pre_mode = mode->pre_mode & 0xffffefff;
  mode->end_tag = '\0';
  feed_table1(tbl,tok,mode,width);
  return;
}



void table_close_textarea(table *tbl,table_mode *mode,int width)

{
  Str tok;
  Str tmp;
  
  tok = process_n_textarea();
  mode->pre_mode = mode->pre_mode & 0xfffff7ff;
  mode->end_tag = '\0';
  feed_table1(tbl,tok,mode,width);
  return;
}



void table_close_anchor0(table *tbl,table_mode *mode)

{
  if ((mode->pre_mode & 0x1000000) != 0) {
    mode->pre_mode = mode->pre_mode & 0xfeffffff;
    if (tbl->tabcontentssize == (int)mode->anchor_offset) {
      check_minimum0(tbl,1);
      addcontentssize(tbl,1);
      setwidth(tbl,mode);
    }
    else if ((('\0' < (tbl->linfo).prev_spaces) &&
             (tbl->tabcontentssize + -1 == (int)mode->anchor_offset)) &&
            ('\0' < (tbl->linfo).prev_spaces)) {
      (tbl->linfo).prev_spaces = -1;
    }
  }
  return;
}



int feed_table_tag(table *tbl,char *line,table_mode *mode,int width,parsed_tag *tag)

{
  short sVar1;
  Str *pp_Var2;
  table *t;
  ushort uVar3;
  Str p_Var4;
  int iVar5;
  table *tbl1;
  Str tmp_1;
  int ii;
  Str anchor;
  Str tmp;
  Str tok;
  int id;
  int w;
  int v0;
  int v;
  int k;
  int j;
  int i;
  int prev_col;
  int col;
  int rowspan;
  int colspan;
  table_cell *cell;
  char *p;
  int cmd;
  table_attr valign;
  table_attr align;
  
  cell = &tbl->cell;
  cmd = (int)tag->tagid;
  if ((mode->pre_mode & 8) != 0) {
    if ((uint)mode->end_tag != cmd) {
      return 4;
    }
    mode->pre_mode = mode->pre_mode & 0xfffffff7;
    mode->end_tag = '\0';
    feed_table_block_tag(tbl,line,mode,0,cmd);
    return 0;
  }
  if ((mode->pre_mode & 0x800) != 0) {
    switch(cmd) {
    case 0x1f:
    case 0x20:
    case 0x2e:
    case 0x4a:
    case 0x4b:
    case 0x4c:
    case 0x4d:
    case 0x50:
    case 0x51:
    case 0x52:
    case 0x53:
    case 0x54:
    case 0x55:
    case 0x56:
    case 0x57:
    case 0x58:
    case 0x59:
    case 0x5a:
      goto switchD_08086a5d_caseD_1f;
    default:
      return 1;
    }
  }
LAB_08086a93:
  if ((mode->pre_mode & 2) != 0) {
    if ((uint)mode->end_tag != cmd) {
      return 4;
    }
    mode->pre_mode = mode->pre_mode & 0xfffffffd;
    mode->end_tag = '\0';
    return 0;
  }
  if ((mode->pre_mode & 4) != 0) {
    if ((uint)mode->end_tag != cmd) {
      return 4;
    }
    mode->pre_mode = mode->pre_mode & 0xfffffffb;
    mode->end_tag = '\0';
    return 0;
  }
  if ((mode->pre_mode & 0x1000) != 0) {
    switch(cmd) {
    case 0x1f:
    case 0x20:
    case 0x2b:
    case 0x30:
    case 0x4a:
    case 0x4b:
    case 0x4c:
    case 0x4d:
    case 0x50:
    case 0x51:
    case 0x52:
    case 0x53:
    case 0x54:
    case 0x55:
    case 0x56:
    case 0x57:
    case 0x58:
    case 0x59:
    case 0x5a:
      goto switchD_08086b3d_caseD_1f;
    default:
      return 1;
    }
  }
LAB_08086b73:
  if (mode->caption != '\0') {
    switch(cmd) {
    case 0x1f:
    case 0x20:
    case 0x4a:
    case 0x4b:
    case 0x4c:
    case 0x4d:
    case 0x4f:
    case 0x50:
    case 0x51:
    case 0x52:
    case 0x53:
    case 0x54:
    case 0x55:
    case 0x56:
    case 0x57:
    case 0x58:
    case 0x59:
    case 0x5a:
      goto switchD_08086b90_caseD_1f;
    default:
      return 1;
    }
  }
LAB_08086bb4:
  if ((((mode->pre_mode & 1) != 0) && (0x31 < cmd)) && ((cmd < 0x34 || (cmd - 0x80U < 2)))) {
    return 0;
  }
  switch(cmd) {
  default:
    return 1;
  case 1:
    table_close_anchor0(tbl,mode);
    anchor = (Str)0x0;
    i = 0;
    parsedtag_get_value(tag,0x12,&anchor);
    parsedtag_get_value(tag,0x45,&i);
    if (anchor == (Str)0x0) {
      suspend_or_pushdata(tbl,line);
    }
    else {
      check_rowcol(tbl,mode);
      if (i == 0) {
        p_Var4 = process_anchor(tag,line);
        pushdata(tbl,tbl->row,tbl->col,p_Var4->ptr);
      }
      else {
        pushdata(tbl,tbl->row,tbl->col,line);
      }
      if (-1 < i) {
        mode->pre_mode = mode->pre_mode | 0x1000000;
        mode->anchor_offset = (short)tbl->tabcontentssize;
      }
    }
    break;
  case 2:
    table_close_anchor0(tbl,mode);
  case 0x28:
  case 0x29:
  case 0x8a:
    suspend_or_pushdata(tbl,line);
    break;
  case 3:
  case 4:
  case 0xb:
  case 0x10:
  case 0x13:
  case 0x14:
  case 0x15:
  case 0x16:
  case 0x1a:
  case 0x1c:
  case 0x1e:
  case 0x8b:
  case 0x8c:
    goto switchD_08086bf8_caseD_3;
  case 5:
  case 6:
  case 0x26:
  case 0x27:
  case 0x34:
  case 0x35:
    if ((tbl->flag & 1U) == 0) {
      return 0;
    }
switchD_08086bf8_caseD_3:
    feed_table_block_tag(tbl,line,mode,0,cmd);
    if (cmd == 0x1c) {
      mode->pre_mode = mode->pre_mode | 8;
      mode->end_tag = '\x1d';
      return 0;
    }
    if (cmd < 0x1d) {
      if (cmd == 0x16) {
LAB_0808774b:
        mode->pre_mode = mode->pre_mode & 0xfffffffe;
        return 0;
      }
      if (cmd == 0x1a) {
        mode->pre_mode = mode->pre_mode | 8;
        mode->end_tag = '\x1b';
        return 0;
      }
      if (cmd != 0x15) {
        return 0;
      }
    }
    else if (cmd != 0x8b) {
      if (cmd != 0x8c) {
        if (cmd != 0x1e) {
          return 0;
        }
        mode->pre_mode = mode->pre_mode | 8;
        mode->end_tag = 0x91;
        return 0;
      }
      goto LAB_0808774b;
    }
    mode->pre_mode = mode->pre_mode | 1;
    break;
  case 9:
  case 0xc:
  case 0x11:
  case 0x17:
    feed_table_block_tag(tbl,line,mode,1,cmd);
    break;
  case 10:
  case 0xd:
  case 0x12:
  case 0x18:
    feed_table_block_tag(tbl,line,mode,-1,cmd);
    break;
  case 0x19:
    check_rowcol(tbl,mode);
    w = (int)tbl->fixed_width[tbl->col];
    if (w < 0) {
      if (tbl->total_width < 1) {
        if (width < 1) {
          w = 0;
        }
        else {
          w = (-width * w) / 100;
        }
      }
      else {
        w = (-tbl->total_width * w) / 100;
      }
    }
    else if (w == 0) {
      if (tbl->total_width < 1) {
        if (0 < width) {
          w = width;
        }
      }
      else {
        w = tbl->total_width;
      }
    }
    tok = process_img(tag,w);
    feed_table1(tbl,tok,mode,width);
    break;
  case 0x1f:
    check_rowcol(tbl,mode);
    return 2;
  case 0x20:
    if (tbl->suspended_data != (TextList *)0x0) {
      check_rowcol(tbl,mode);
    }
    return 3;
  case 0x2a:
    feed_table_block_tag(tbl,"",mode,0,cmd);
    tmp = process_form(tag);
    if (tmp != (Str)0x0) {
      feed_table1(tbl,tmp,mode,width);
    }
    break;
  case 0x2b:
    feed_table_block_tag(tbl,"",mode,0,cmd);
    process_n_form();
    break;
  case 0x2c:
    tmp = process_input(tag);
    feed_table1(tbl,tmp,mode,width);
    break;
  case 0x2d:
    w = 0;
    check_rowcol(tbl,mode);
    if ((tbl->maxcol < tbl->col + 1) || ((tbl->tabattr[tbl->row][tbl->col + 1] & 1) == 0)) {
      if (0 < tbl->fixed_width[tbl->col]) {
        w = (int)tbl->fixed_width[tbl->col];
      }
    }
    else if ((-1 < cell->icell) && (0 < cell->fixed_width[cell->icell])) {
      w = (int)cell->fixed_width[cell->icell];
    }
    tmp = process_textarea(tag,w);
    if (tmp != (Str)0x0) {
      feed_table1(tbl,tmp,mode,width);
    }
    mode->pre_mode = mode->pre_mode | 0x800;
    mode->end_tag = '.';
    break;
  case 0x2f:
    tmp = process_select(tag);
    if (tmp != (Str)0x0) {
      feed_table1(tbl,tmp,mode,width);
    }
    mode->pre_mode = mode->pre_mode | 0x1000;
    mode->end_tag = '0';
    break;
  case 0x30:
  case 0x31:
  case 0x4f:
  case 0x52:
  case 0x53:
  case 0x54:
  case 0x55:
  case 0x56:
  case 0x57:
  case 0x58:
  case 0x59:
  case 0x5a:
  case 0x65:
    break;
  case 0x32:
  case 0x45:
    if ((tbl->flag & 1U) == 0) {
      return 0;
    }
  case 0x80:
    feed_table_inline_tag(tbl,line,mode,-1);
    if (cmd == 0x32) {
      mode->nobr_level = mode->nobr_level + '\x01';
      if ((mode->pre_mode & 0x80) != 0) {
        return 0;
      }
      mode->pre_mode = mode->pre_mode | 0x80;
    }
    else if (cmd == 0x80) {
      if ((mode->pre_mode & 0x200) != 0) {
        return 0;
      }
      mode->pre_mode = mode->pre_mode | 0x200;
      (tbl->linfo).prev_spaces = '\0';
    }
    mode->nobr_offset = -1;
    if (0 < (tbl->linfo).length) {
      check_minimum0(tbl,(int)(tbl->linfo).length);
      (tbl->linfo).length = 0;
    }
    break;
  case 0x33:
    if ((tbl->flag & 1U) != 0) {
      feed_table_inline_tag(tbl,line,mode,-1);
      if ('\0' < mode->nobr_level) {
        mode->nobr_level = mode->nobr_level + -1;
      }
      if (mode->nobr_level == '\0') {
        mode->pre_mode = mode->pre_mode & 0xffffff7f;
      }
    }
    break;
  case 0x3a:
    mode->pre_mode = mode->pre_mode | 2;
    mode->end_tag = ';';
    break;
  case 0x3d:
    if (displayInsDel == 1) {
      feed_table_inline_tag(tbl,line,mode,5);
    }
    else if (displayInsDel == 2) {
      feed_table_inline_tag(tbl,line,mode,-1);
    }
    else if (displayInsDel == 0) {
      mode->pre_mode = mode->pre_mode | 0x100000;
    }
    break;
  case 0x3e:
    if (displayInsDel == 1) {
      feed_table_inline_tag(tbl,line,mode,5);
    }
    else if (displayInsDel == 2) {
      feed_table_inline_tag(tbl,line,mode,-1);
    }
    else if (displayInsDel == 0) {
      mode->pre_mode = mode->pre_mode & 0xffefffff;
    }
    break;
  case 0x3f:
  case 0x40:
    if (displayInsDel == 1) {
      feed_table_inline_tag(tbl,line,mode,5);
    }
    else if (displayInsDel == 2) {
      feed_table_inline_tag(tbl,line,mode,-1);
    }
    break;
  case 0x43:
    mode->pre_mode = mode->pre_mode | 4;
    mode->end_tag = 'D';
    break;
  case 0x4a:
    if ((-1 < tbl->col) && (0 < tbl->tabcontentssize)) {
      setwidth(tbl,mode);
    }
    tbl->col = -1;
    tbl->row = tbl->row + 1;
    tbl->flag = tbl->flag | 1;
    tbl->flag = tbl->flag & 0xfffffffb;
    align = 0;
    valign = 0;
    iVar5 = parsedtag_get_value(tag,4,&i);
    if (iVar5 != 0) {
      if (i == 1) {
        align = 0x40;
      }
      else if (i == 2) {
        align = 0x60;
      }
      else if (i == 0) {
        align = 0x50;
      }
    }
    iVar5 = parsedtag_get_value(tag,0x23,&i);
    if (iVar5 != 0) {
      if (i == 1) {
        valign = 0x900;
      }
      else if (i == 2) {
        valign = 0xc00;
      }
      else if (i == 0) {
        valign = 0xa00;
      }
    }
    iVar5 = parsedtag_get_value(tag,0x14,&p);
    if (iVar5 != 0) {
      pp_Var2 = tbl->tridvalue;
      iVar5 = tbl->row;
      p_Var4 = Strnew_charp(p);
      pp_Var2[iVar5] = p_Var4;
    }
    tbl->trattr = align | valign;
    break;
  case 0x4b:
    setwidth(tbl,mode);
    tbl->col = -1;
    tbl->flag = tbl->flag & 0xfffffffa;
    return 0;
  case 0x4c:
  case 0x50:
    prev_col = tbl->col;
    if ((-1 < tbl->col) && (0 < tbl->tabcontentssize)) {
      setwidth(tbl,mode);
    }
    if (tbl->row == -1) {
      tbl->row = -1;
      tbl->col = -1;
      tbl->maxrow = tbl->row;
    }
    if (tbl->col == -1) {
      if ((tbl->flag & 1U) == 0) {
        tbl->row = tbl->row + 1;
        tbl->flag = tbl->flag | 1;
      }
      if (tbl->maxrow < tbl->row) {
        tbl->maxrow = tbl->row;
      }
    }
    tbl->col = tbl->col + 1;
    check_row(tbl,tbl->row);
    while (tbl->tabattr[tbl->row][tbl->col] != 0) {
      tbl->col = tbl->col + 1;
    }
    if (0x31 < tbl->col) {
      tbl->col = prev_col;
      return 0;
    }
    if (tbl->maxcol < tbl->col) {
      tbl->maxcol = tbl->col;
    }
    rowspan = 1;
    colspan = 1;
    if ((tbl->trattr & 0x40) == 0) {
      if (cmd == 0x50) {
        align = 0x10;
      }
      else {
        align = 0;
      }
    }
    else {
      align = tbl->trattr & 0x30;
    }
    if ((tbl->trattr & 0x800) == 0) {
      valign = 0x200;
    }
    else {
      valign = tbl->trattr & 0x700;
    }
    iVar5 = parsedtag_get_value(tag,0x1d,&rowspan);
    if ((iVar5 != 0) && (tbl->max_rowsize <= tbl->row + rowspan)) {
      check_row(tbl,tbl->row + rowspan);
    }
    iVar5 = parsedtag_get_value(tag,0xe,&colspan);
    if ((iVar5 != 0) && (0x31 < tbl->col + colspan)) {
      colspan = 0x32 - tbl->col;
    }
    iVar5 = parsedtag_get_value(tag,4,&i);
    if (iVar5 != 0) {
      if (i == 1) {
        align = 0;
      }
      else if (i == 2) {
        align = 0x20;
      }
      else if (i == 0) {
        align = 0x10;
      }
    }
    iVar5 = parsedtag_get_value(tag,0x23,&i);
    if (iVar5 != 0) {
      if (i == 1) {
        valign = 0x100;
      }
      else if (i == 2) {
        valign = 0x400;
      }
      else if (i == 0) {
        valign = 0x200;
      }
    }
    if (((tag->map != (uchar *)0x0) && (tag->map[0x1a] != 'K')) &&
       (tag->attrid[tag->map[0x1a]] != '\0')) {
      tbl->tabattr[tbl->row][tbl->col] = tbl->tabattr[tbl->row][tbl->col] | 4;
    }
    v = 0;
    iVar5 = parsedtag_get_value(tag,0x26,&v);
    if ((iVar5 != 0) && (-1 < v)) {
      v = (int)ROUND((double)v / pixel_per_char);
    }
    iVar5 = parsedtag_get_value(tag,0x14,&p);
    if (iVar5 != 0) {
      pp_Var2 = tbl->tabidvalue[tbl->row];
      iVar5 = tbl->col;
      p_Var4 = Strnew_charp(p);
      pp_Var2[iVar5] = p_Var4;
    }
    if (v != 0) {
      tbl->tabattr[tbl->row][tbl->col] = tbl->tabattr[tbl->row][tbl->col] & 0xfffb;
    }
    tbl->tabattr[tbl->row][tbl->col] = tbl->tabattr[tbl->row][tbl->col] & 0xf8cf;
    tbl->tabattr[tbl->row][tbl->col] = valign | align | tbl->tabattr[tbl->row][tbl->col];
    if (1 < colspan) {
      col = tbl->col;
      cell->icell = cell->maxcell + 1;
      k = bsearch_2short((short)colspan,cell->colspan,(short)col,cell->col,0x32,cell->index,
                         (int)cell->icell);
      if (k <= cell->maxcell) {
        sVar1 = cell->index[k];
        if ((cell->col[sVar1] == col) && (cell->colspan[sVar1] == colspan)) {
          cell->icell = sVar1;
        }
      }
      if ((cell->maxcell < cell->icell) && (cell->icell < 0x14)) {
        cell->maxcell = cell->maxcell + 1;
        cell->col[cell->maxcell] = (short)col;
        cell->colspan[cell->maxcell] = (short)colspan;
        cell->width[cell->maxcell] = 0;
        cell->minimum_width[cell->maxcell] = 0;
        cell->fixed_width[cell->maxcell] = 0;
        if (k < cell->maxcell) {
          for (ii = (int)cell->maxcell; k < ii; ii = ii + -1) {
            cell->index[ii] = cell->colspan[ii + 0x13];
          }
        }
        cell->index[k] = cell->maxcell;
      }
      if (cell->maxcell < cell->icell) {
        cell->icell = -1;
      }
    }
    if (v != 0) {
      if (colspan == 1) {
        v0 = (int)tbl->fixed_width[tbl->col];
        if (((v0 == 0) || ((0 < v0 && (v0 < v)))) || ((v0 < 0 && (v < v0)))) {
          tbl->fixed_width[tbl->col] = (short)v;
        }
      }
      else if ((-1 < cell->icell) &&
              (((v0 = (int)cell->fixed_width[cell->icell], v0 == 0 || ((0 < v0 && (v0 < v)))) ||
               ((v0 < 0 && (v < v0)))))) {
        cell->fixed_width[cell->icell] = (short)v;
      }
    }
    for (i = 0; i < rowspan; i = i + 1) {
      check_row(tbl,tbl->row + i);
      for (j = 0; j < colspan; j = j + 1) {
        if ((tbl->tabattr[tbl->row + i][tbl->col + j] & 3) == 0) {
          if (i < 1) {
            uVar3 = 0;
          }
          else {
            uVar3 = 2;
          }
          tbl->tabattr[tbl->row + i][tbl->col + j] =
               uVar3 | 0 < j | tbl->tabattr[tbl->row + i][tbl->col + j];
        }
        if (tbl->maxcol < tbl->col + j) {
          tbl->maxcol = tbl->col + j;
        }
      }
      if (tbl->maxrow < tbl->row + i) {
        tbl->maxrow = tbl->row + i;
      }
    }
    begin_cell(tbl,mode);
    break;
  case 0x4d:
  case 0x51:
    setwidth(tbl,mode);
    tbl->flag = tbl->flag & 0xfffffffb;
    return 0;
  case 0x4e:
    mode->caption = '\x01';
    break;
  case 100:
  case 0x66:
  case 0x67:
    if ((mode->pre_mode & 0x300000) == 0) {
      feed_table_inline_tag(tbl,line,mode,1);
    }
    break;
  case 0x69:
    if (displayInsDel == 1) {
      feed_table_inline_tag(tbl,line,mode,3);
    }
    else if (displayInsDel == 2) {
      feed_table_inline_tag(tbl,line,mode,-1);
    }
    else if (displayInsDel == 0) {
      mode->pre_mode = mode->pre_mode | 0x200000;
    }
    break;
  case 0x6a:
    if (displayInsDel == 1) {
      feed_table_inline_tag(tbl,line,mode,3);
    }
    else if (displayInsDel == 2) {
      feed_table_inline_tag(tbl,line,mode,-1);
    }
    else if (displayInsDel == 0) {
      mode->pre_mode = mode->pre_mode & 0xffdfffff;
    }
    break;
  case 0x7d:
    id = -1;
    w = 0;
    parsedtag_get_value(tag,0x40,&id);
    if ((-1 < id) && (id < tbl->ntable)) {
      t = tbl->tables[id].ptr;
      feed_table_block_tag(tbl,line,mode,0,cmd);
      iVar5 = get_table_width(t,t->tabwidth,(t->cell).width,2);
      addcontentssize(tbl,iVar5);
      check_minimum0(tbl,t->sloppy_width);
      setwidth0(tbl,mode);
      clearcontentssize(tbl,mode);
    }
    break;
  case 0x81:
    feed_table_inline_tag(tbl,line,mode,-1);
    mode->pre_mode = mode->pre_mode & 0xfffffdff;
  }
  return 0;
switchD_08086a5d_caseD_1f:
  table_close_textarea(tbl,mode,width);
  if (cmd == 0x2e) {
    return 0;
  }
  goto LAB_08086a93;
switchD_08086b3d_caseD_1f:
  table_close_select(tbl,mode,width);
  if (cmd == 0x30) {
    return 0;
  }
  goto LAB_08086b73;
switchD_08086b90_caseD_1f:
  mode->caption = '\0';
  if (cmd == 0x4f) {
    return 0;
  }
  goto LAB_08086bb4;
}



int feed_table(table *tbl,char *line,table_mode *mode,int width,int internal)

{
  bool bVar1;
  parsed_tag *tag_00;
  int iVar2;
  Str p_Var3;
  size_t sVar4;
  char *pcVar5;
  uint c;
  byte *__s;
  int nl;
  int ec;
  char *r;
  char *q;
  parsed_tag *tag;
  table_linfo *linfo;
  Str tmp;
  char *p;
  int i;
  
  if (((*line == '<') && (line[1] != '\0')) &&
     (((MYCTYPE_MAP[(byte)line[1]] & 4) != 0 ||
      ((((line[1] == '/' || (line[1] == '!')) || (line[1] == '?')) ||
       ((line[1] == '\0' || (line[1] == '_')))))))) {
    p = line;
    tag_00 = parse_tag(&p,internal);
    if (tag_00 == (parsed_tag *)0x0) {
      if ((mode->pre_mode & 0x180e) == 0) {
        return -1;
      }
    }
    else {
      iVar2 = feed_table_tag(tbl,line,mode,width,tag_00);
      if (iVar2 == 2) {
        return 1;
      }
      if (iVar2 < 3) {
        if (iVar2 == 0) {
          return -1;
        }
      }
      else {
        if (iVar2 == 3) {
          return 0;
        }
        if (iVar2 == 4) goto LAB_08088396;
      }
      if (tag_00->need_reconstruct != '\0') {
        p_Var3 = parsedtag2str(tag_00);
        line = p_Var3->ptr;
      }
    }
  }
  else if ((mode->pre_mode & 0x300000) != 0) {
    return -1;
  }
LAB_08088396:
  if (mode->caption == '\0') {
    if (((mode->pre_mode & 2) == 0) && ((mode->pre_mode & 4) == 0)) {
      if ((mode->pre_mode & 0x800) == 0) {
        if ((mode->pre_mode & 0x1000) == 0) {
          if (((mode->pre_mode & 8) == 0) &&
             (((*line != '<' || (sVar4 = strlen(line), line[sVar4 - 1] != '>')) &&
              (pcVar5 = strchr(line,0x26), pcVar5 != (char *)0x0)))) {
            p_Var3 = Strnew();
            p = line;
LAB_08088772:
            if (*p != '\0') {
              if (*p == '&') {
                iVar2 = strncasecmp(p,"&amp;",5);
                if (((iVar2 != 0) && (iVar2 = strncasecmp(p,"&gt;",4), iVar2 != 0)) &&
                   (iVar2 = strncasecmp(p,"&lt;",4), pcVar5 = p, iVar2 != 0)) {
                  c = getescapechar(&p);
                  if (c == 0x26) {
                    Strcat_charp(p_Var3,"&amp;");
                    goto LAB_08088772;
                  }
                  if ((int)c < 0x27) {
                    if (c != 0xffffffff) {
                      if (c != 0xd) goto LAB_08088639;
                      if (p_Var3->area_size <= p_Var3->length + 1) {
                        Strgrow(p_Var3);
                      }
                      iVar2 = p_Var3->length;
                      p_Var3->ptr[iVar2] = '\n';
                      p_Var3->length = iVar2 + 1;
                      p_Var3->ptr[p_Var3->length] = '\0';
                      goto LAB_08088772;
                    }
                  }
                  else {
                    if (c == 0x3c) {
                      Strcat_charp(p_Var3,"&lt;");
                      goto LAB_08088772;
                    }
                    if (c == 0x3e) {
                      Strcat_charp(p_Var3,"&gt;");
                      goto LAB_08088772;
                    }
LAB_08088639:
                    __s = (byte *)conv_entity(c);
                    if (((__s != (byte *)0x0) && (sVar4 = strlen((char *)__s), sVar4 == 1)) &&
                       (*__s == c)) {
                      if (p_Var3->area_size <= p_Var3->length + 1) {
                        Strgrow(p_Var3);
                      }
                      iVar2 = p_Var3->length;
                      p_Var3->ptr[iVar2] = *__s;
                      p_Var3->length = iVar2 + 1;
                      p_Var3->ptr[p_Var3->length] = '\0';
                      goto LAB_08088772;
                    }
                  }
                  if (p_Var3->area_size <= p_Var3->length + 1) {
                    Strgrow(p_Var3);
                  }
                  iVar2 = p_Var3->length;
                  p_Var3->ptr[iVar2] = *pcVar5;
                  p_Var3->length = iVar2 + 1;
                  p_Var3->ptr[p_Var3->length] = '\0';
                  p = pcVar5 + 1;
                  goto LAB_08088772;
                }
                if (p_Var3->area_size <= p_Var3->length + 1) {
                  Strgrow(p_Var3);
                }
                iVar2 = p_Var3->length;
                p_Var3->ptr[iVar2] = *p;
                p_Var3->length = iVar2 + 1;
                p_Var3->ptr[p_Var3->length] = '\0';
                p = p + 1;
              }
              else {
                if (p_Var3->area_size <= p_Var3->length + 1) {
                  Strgrow(p_Var3);
                }
                iVar2 = p_Var3->length;
                p_Var3->ptr[iVar2] = *p;
                p_Var3->length = iVar2 + 1;
                p_Var3->ptr[p_Var3->length] = '\0';
                p = p + 1;
              }
              goto LAB_08088772;
            }
            line = p_Var3->ptr;
          }
          if ((mode->pre_mode & 0x20f) == 0) {
            if (((tbl->flag & 4U) == 0) || ((tbl->linfo).prev_spaces != '\0')) {
              while ((MYCTYPE_MAP[(byte)*line] & 2) != 0) {
                line = line + 1;
              }
            }
            if (*line == '\0') {
              return -1;
            }
            check_rowcol(tbl,mode);
            if (((mode->pre_mode & 0x80) != 0) && (mode->nobr_offset < 0)) {
              mode->nobr_offset = (short)tbl->tabcontentssize;
            }
            i = skip_space(tbl,line,&tbl->linfo,(uint)((mode->pre_mode & 0x80) == 0));
            iVar2 = visible_length(line);
            addcontentssize(tbl,iVar2 - i);
            setwidth(tbl,mode);
            pushdata(tbl,tbl->row,tbl->col,line);
          }
          else if ((mode->pre_mode & 0x200) == 0) {
            check_rowcol(tbl,mode);
            while (*line != '\0') {
              bVar1 = false;
              p = strchr(line,0xd);
              if ((p == (char *)0x0) && (p = strchr(line,10), p == (char *)0x0)) {
                p = line;
                line = "";
              }
              else {
                if ((*p == '\r') && (p[1] == '\n')) {
                  p = p + 1;
                }
                if (p[1] == '\0') {
                  p = line;
                  line = "";
                }
                else {
                  p = p + 1;
                  p_Var3 = Strnew_charp_n(line,(int)p - (int)line);
                  line = p;
                  p = p_Var3->ptr;
                }
                bVar1 = true;
              }
              if ((mode->pre_mode & 8) == 0) {
                i = maximum_visible_length(p,tbl->tabcontentssize);
              }
              else {
                i = maximum_visible_length_plain(p,tbl->tabcontentssize);
              }
              addcontentssize(tbl,i);
              setwidth(tbl,mode);
              if (bVar1) {
                clearcontentssize(tbl,mode);
              }
              pushdata(tbl,tbl->row,tbl->col,p);
            }
          }
          else {
            check_rowcol(tbl,mode);
            if (mode->nobr_offset < 0) {
              mode->nobr_offset = (short)tbl->tabcontentssize;
            }
            iVar2 = maximum_visible_length(line,tbl->tabcontentssize);
            addcontentssize(tbl,iVar2);
            setwidth(tbl,mode);
            pushdata(tbl,tbl->row,tbl->col,line);
          }
        }
        else {
          feed_select(line);
        }
      }
      else {
        feed_textarea(line);
      }
    }
  }
  else {
    Strcat_charp(tbl->caption,line);
  }
  return -1;
}



void feed_table1(table *tbl,Str tok,table_mode *mode,int width)

{
  int iVar1;
  char *line;
  int status;
  Str tokbuf;
  
  if (tok != (Str)0x0) {
    tokbuf = Strnew();
    status = 0;
    line = tok->ptr;
    while (iVar1 = read_token(tokbuf,&line,&status,mode->pre_mode & 0xa0f,0), iVar1 != 0) {
      feed_table(tbl,tokbuf->ptr,mode,width,1);
    }
  }
  return;
}



void pushTable(table *tbl,table *tbl1)

{
  short sVar1;
  int iVar2;
  int row_00;
  table_in *ptVar3;
  TextLineList *pTVar4;
  table_in *tmp;
  int row;
  int col;
  
  iVar2 = tbl->col;
  row_00 = tbl->row;
  if (tbl->tables_size <= tbl->ntable) {
    tbl->tables_size = tbl->tables_size + 0x14;
    ptVar3 = (table_in *)GC_malloc((int)tbl->tables_size << 4);
    if (tbl->tables != (table_in *)0x0) {
      bcopy(tbl->tables,ptVar3,(int)tbl->ntable << 4);
    }
    tbl->tables = ptVar3;
  }
  tbl->tables[tbl->ntable].ptr = tbl1;
  tbl->tables[tbl->ntable].col = (short)iVar2;
  tbl->tables[tbl->ntable].row = (short)row_00;
  tbl->tables[tbl->ntable].indent = (short)tbl->indent;
  ptVar3 = tbl->tables;
  sVar1 = tbl->ntable;
  pTVar4 = (TextLineList *)newGeneralList();
  ptVar3[sVar1].buf = pTVar4;
  check_row(tbl,row_00);
  if ((tbl->maxcol < iVar2 + 1) || ((tbl->tabattr[row_00][iVar2 + 1] & 1) == 0)) {
    tbl->tables[tbl->ntable].cell = -1;
  }
  else {
    tbl->tables[tbl->ntable].cell = (tbl->cell).icell;
  }
  tbl->ntable = tbl->ntable + 1;
  return;
}



int correct_table_matrix(table *t,int col,int cspan,int a,double b)

{
  double dVar1;
  double w;
  int ecol;
  int j;
  int i;
  
  dVar1 = 1.0 / (b * b);
  for (i = col; i < col + cspan; i = i + 1) {
    t->vector->ve[i] = (double)a * dVar1 + t->vector->ve[i];
    for (j = i; j < col + cspan; j = j + 1) {
      t->matrix->me[t->matrix->dim * i + j] = t->matrix->me[t->matrix->dim * i + j] + dVar1;
      t->matrix->me[t->matrix->dim * j + i] = t->matrix->me[t->matrix->dim * i + j];
    }
  }
  return i;
}



void correct_table_matrix2(table *t,int col,int cspan,double s,double b)

{
  int iVar1;
  int iVar2;
  double ss;
  double w;
  int size;
  int ecol;
  int j;
  int i;
  
  iVar1 = col + cspan;
  iVar2 = t->maxcol + 1;
  for (i = 0; i < iVar2; i = i + 1) {
    for (j = i; j < iVar2; j = j + 1) {
      if ((((i < col) || (iVar1 <= i)) || (j < col)) || (iVar1 <= j)) {
        if (((i < col) || (iVar1 <= i)) && ((j < col || (iVar1 <= j)))) {
          ss = s * s;
        }
        else {
          ss = -(1.0 - s) * s;
        }
      }
      else {
        ss = (1.0 - s) * (1.0 - s);
      }
      t->matrix->me[t->matrix->dim * i + j] =
           (1.0 / (b * b)) * ss + t->matrix->me[t->matrix->dim * i + j];
    }
  }
  return;
}



void correct_table_matrix3(table *t,int col,char *flags,double s,double b)

{
  int iVar1;
  bool bVar2;
  double w;
  double ss;
  int flg;
  int size;
  int j;
  int i;
  
  iVar1 = t->maxcol + 1;
  bVar2 = flags[col] == '\0';
  for (i = 0; i < iVar1; i = i + 1) {
    if (((bVar2) && (flags[i] == '\0')) || ((!bVar2 && (flags[i] != '\0')))) {
      for (j = i; j < iVar1; j = j + 1) {
        if (((bVar2) && (flags[j] == '\0')) || ((!bVar2 && (flags[j] != '\0')))) {
          if ((i == col) && (j == col)) {
            ss = (1.0 - s) * (1.0 - s);
          }
          else if ((i == col) || (j == col)) {
            ss = -(1.0 - s) * s;
          }
          else {
            ss = s * s;
          }
          t->matrix->me[t->matrix->dim * i + j] =
               (1.0 / (b * b)) * ss + t->matrix->me[t->matrix->dim * i + j];
        }
      }
    }
  }
  return;
}



void correct_table_matrix4(table *t,int col,int cspan,char *flags,double s,double b)

{
  int iVar1;
  int iVar2;
  double w;
  double ss;
  int size;
  int ecol;
  int j;
  int i;
  
  iVar1 = col + cspan;
  iVar2 = t->maxcol + 1;
  for (i = 0; i < iVar2; i = i + 1) {
    if ((flags[i] == '\0') || ((col <= i && (i < iVar1)))) {
      for (j = i; j < iVar2; j = j + 1) {
        if ((flags[j] == '\0') || ((col <= j && (j < iVar1)))) {
          if ((i < col) || (((iVar1 <= i || (j < col)) || (iVar1 <= j)))) {
            if (((i < col) || (iVar1 <= i)) && ((j < col || (iVar1 <= j)))) {
              ss = s * s;
            }
            else {
              ss = -(1.0 - s) * s;
            }
          }
          else {
            ss = (1.0 - s) * (1.0 - s);
          }
          t->matrix->me[t->matrix->dim * i + j] =
               (1.0 / (b * b)) * ss + t->matrix->me[t->matrix->dim * i + j];
        }
      }
    }
  }
  return;
}



void set_table_matrix0(table *t,int maxwidth)

{
  short sVar1;
  int iVar2;
  int iVar3;
  char_0_ *pcVar4;
  int iVar5;
  int in_GS_OFFSET;
  undefined2 in_FPUControlWord;
  double dVar6;
  undefined4 uStack240;
  table *ptStack236;
  size_t sStack232;
  char *pcStack228;
  undefined auStack224 [8];
  undefined auStack216 [20];
  int local_c4;
  uint local_c0;
  uint local_bc;
  undefined4 local_b8;
  int local_b4;
  uint local_b0;
  uint local_ac;
  undefined4 local_a8;
  int local_a4;
  uint local_a0;
  uint local_9c;
  undefined4 local_98;
  uint local_94;
  undefined *local_90;
  short local_8a;
  int local_88;
  undefined2 local_84;
  undefined2 local_82;
  table *local_80;
  double b;
  double s;
  double w;
  double w1;
  double w0;
  char_0_ *expand;
  int local_4c;
  double_0_ *we;
  int local_44;
  table_cell *cell;
  int width;
  int ecol;
  int bcol;
  int k;
  int j;
  int i;
  int size;
  int local_20;
  
  local_80 = t;
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  local_90 = (undefined *)&ptStack236;
  local_44 = t->maxcol;
  size = local_44 + 1;
  local_94 = size;
  local_9c = size;
  local_98 = 0;
  local_a4 = size * 0x40;
  local_a0 = (uint)size >> 0x1a & 0xf;
  iVar2 = -(size * 8 + 0x1eU & 0xfffffff0);
  we = (double_0_ *)((int)&local_c0 + iVar2);
  local_4c = local_44;
  local_ac = size;
  local_a8 = 0;
  local_b4 = size * 8;
  local_b0 = (uint)size >> 0x1d;
  local_bc = size;
  local_b8 = 0;
  local_c4 = size * 8;
  local_c0 = (uint)size >> 0x1d;
  iVar3 = -(local_44 + 0x1fU & 0xfffffff0);
  expand = (char_0_ *)((int)&local_c0 + iVar3 + iVar2);
  cell = &t->cell;
  w0 = 0.0;
  for (i = 0; iVar5 = i, pcVar4 = expand, i < size; i = i + 1) {
    *(int *)((int)&ptStack236 + iVar3 + iVar2) = (int)local_80->tabwidth[i];
    *(undefined4 *)((int)&uStack240 + iVar3 + iVar2) = 0x80894d5;
    dVar6 = weight(*(int *)((int)&ptStack236 + iVar3 + iVar2));
    *(double *)(we + iVar5 * 8) = dVar6;
    w0 = w0 + *(double *)(we + i * 8);
  }
  if (w0 <= 0.0) {
    w0 = 1.0;
  }
  if (cell->necell == 0) {
    for (i = 0; i < size; i = i + 1) {
      s = *(double *)(we + i * 8) / w0;
      local_82 = in_FPUControlWord;
      local_84 = CONCAT11(0xc,(char)in_FPUControlWord);
      local_88 = (int)ROUND((double)maxwidth * (*(double *)(we + i * 8) / w0));
      *(int *)((int)&ptStack236 + iVar3 + iVar2) = local_88;
      *(undefined4 *)((int)&uStack240 + iVar3 + iVar2) = 0x8089565;
      dVar6 = weight2(*(int *)((int)&ptStack236 + iVar3 + iVar2));
      b = dVar6 * 32.0;
      *(double *)(auStack216 + iVar3 + iVar2) = dVar6 * 32.0;
      *(double *)(auStack224 + iVar3 + iVar2) = s;
      *(undefined4 *)((int)&pcStack228 + iVar3 + iVar2) = 1;
      *(int *)((int)&sStack232 + iVar3 + iVar2) = i;
      *(table **)((int)&ptStack236 + iVar3 + iVar2) = local_80;
      *(undefined4 *)((int)&uStack240 + iVar3 + iVar2) = 0x8089598;
      correct_table_matrix2
                (*(table **)((int)&ptStack236 + iVar3 + iVar2),
                 *(int *)((int)&sStack232 + iVar3 + iVar2),
                 *(int *)((int)&pcStack228 + iVar3 + iVar2),*(double *)(auStack224 + iVar3 + iVar2),
                 *(double *)(auStack216 + iVar3 + iVar2));
    }
  }
  else {
    *(int *)((int)&sStack232 + iVar3 + iVar2) = size;
    *(char_0_ **)((int)&ptStack236 + iVar3 + iVar2) = pcVar4;
    *(undefined4 *)((int)&uStack240 + iVar3 + iVar2) = 0x80895bb;
    bzero(*(void **)((int)&ptStack236 + iVar3 + iVar2),*(size_t *)((int)&sStack232 + iVar3 + iVar2))
    ;
    for (k = 0; k < cell->necell; k = k + 1) {
      j = (int)cell->eindex[k];
      bcol = (int)cell->col[j];
      ecol = cell->colspan[j] + bcol;
      width = (int)cell->width[j] + local_80->cellspacing * (1 - cell->colspan[j]);
      w1 = 0.0;
      for (i = bcol; i < ecol; i = i + 1) {
        local_8a = local_80->tabwidth[i];
        w1 = w1 + (double)local_80->tabwidth[i] + 0.1;
        expand[i] = expand[i] + '\x01';
      }
      for (i = bcol; i < ecol; i = i + 1) {
        local_8a = local_80->tabwidth[i];
        local_82 = in_FPUControlWord;
        local_84 = CONCAT11(0xc,(char)in_FPUControlWord);
        local_88 = (int)ROUND((((double)local_80->tabwidth[i] + 0.1) * (double)width) / w1);
        *(int *)((int)&ptStack236 + iVar3 + iVar2) = local_88;
        *(undefined4 *)((int)&uStack240 + iVar3 + iVar2) = 0x80896e3;
        w = weight(*(int *)((int)&ptStack236 + iVar3 + iVar2));
        if (*(double *)(we + i * 8) < w) {
          *(double *)(we + i * 8) = w;
        }
      }
    }
    w0 = 0.0;
    w1 = 0.0;
    for (i = 0; i < size; i = i + 1) {
      w0 = w0 + *(double *)(we + i * 8);
      if (expand[i] == '\0') {
        w1 = w1 + *(double *)(we + i * 8);
      }
    }
    if (w0 <= 0.0) {
      w0 = 1.0;
    }
    for (k = 0; k < cell->necell; k = k + 1) {
      j = (int)cell->eindex[k];
      bcol = (int)cell->col[j];
      width = (int)cell->width[j] + local_80->cellspacing * (1 - cell->colspan[j]);
      *(int *)((int)&ptStack236 + iVar3 + iVar2) = width;
      *(undefined4 *)((int)&uStack240 + iVar3 + iVar2) = 0x8089802;
      w = weight(*(int *)((int)&ptStack236 + iVar3 + iVar2));
      s = w / (w1 + w);
      local_82 = in_FPUControlWord;
      local_84 = CONCAT11(0xc,(char)in_FPUControlWord);
      local_88 = (int)ROUND((double)maxwidth * s);
      *(int *)((int)&ptStack236 + iVar3 + iVar2) = local_88;
      *(undefined4 *)((int)&uStack240 + iVar3 + iVar2) = 0x8089840;
      dVar6 = weight2(*(int *)((int)&ptStack236 + iVar3 + iVar2));
      pcVar4 = expand;
      b = dVar6 * 32.0;
      sVar1 = cell->colspan[j];
      *(double *)(auStack216 + iVar3 + iVar2 + 4) = dVar6 * 32.0;
      *(double *)(auStack224 + iVar3 + iVar2 + 4) = s;
      *(char_0_ **)(auStack224 + iVar3 + iVar2) = pcVar4;
      *(int *)((int)&pcStack228 + iVar3 + iVar2) = (int)sVar1;
      *(int *)((int)&sStack232 + iVar3 + iVar2) = bcol;
      *(table **)((int)&ptStack236 + iVar3 + iVar2) = local_80;
      *(undefined4 *)((int)&uStack240 + iVar3 + iVar2) = 0x8089885;
      correct_table_matrix4
                (*(table **)((int)&ptStack236 + iVar3 + iVar2),
                 *(int *)((int)&sStack232 + iVar3 + iVar2),
                 *(int *)((int)&pcStack228 + iVar3 + iVar2),*(char **)(auStack224 + iVar3 + iVar2),
                 *(double *)(auStack224 + iVar3 + iVar2 + 4),
                 *(double *)(auStack216 + iVar3 + iVar2 + 4));
    }
    for (i = 0; i < size; i = i + 1) {
      if (expand[i] == '\0') {
        dVar6 = w1;
        if (w1 <= 1.0) {
          dVar6 = 1.0;
        }
        s = *(double *)(we + i * 8) / dVar6;
        local_82 = in_FPUControlWord;
        local_84 = CONCAT11(0xc,(char)in_FPUControlWord);
        local_88 = (int)ROUND((double)maxwidth * (*(double *)(we + i * 8) / dVar6));
        *(int *)((int)&ptStack236 + iVar3 + iVar2) = local_88;
        *(undefined4 *)((int)&uStack240 + iVar3 + iVar2) = 0x808990b;
        dVar6 = weight2(*(int *)((int)&ptStack236 + iVar3 + iVar2));
        b = dVar6 * 32.0;
      }
      else {
        if (w0 - w1 <= 1.0) {
          dVar6 = 1.0;
        }
        else {
          dVar6 = w0 - w1;
        }
        s = *(double *)(we + i * 8) / dVar6;
        *(int *)((int)&ptStack236 + iVar3 + iVar2) = maxwidth;
        *(undefined4 *)((int)&uStack240 + iVar3 + iVar2) = 0x8089950;
        dVar6 = weight2(*(int *)((int)&ptStack236 + iVar3 + iVar2));
        b = dVar6 * 32.0;
      }
      pcVar4 = expand;
      *(double *)(auStack216 + iVar3 + iVar2) = b;
      *(double *)(auStack224 + iVar3 + iVar2) = s;
      *(char_0_ **)((int)&pcStack228 + iVar3 + iVar2) = pcVar4;
      *(int *)((int)&sStack232 + iVar3 + iVar2) = i;
      *(table **)((int)&ptStack236 + iVar3 + iVar2) = local_80;
      *(undefined4 *)((int)&uStack240 + iVar3 + iVar2) = 0x8089982;
      correct_table_matrix3
                (*(table **)((int)&ptStack236 + iVar3 + iVar2),
                 *(int *)((int)&sStack232 + iVar3 + iVar2),
                 *(char **)((int)&pcStack228 + iVar3 + iVar2),
                 *(double *)(auStack224 + iVar3 + iVar2),*(double *)(auStack216 + iVar3 + iVar2));
    }
  }
  if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  *(undefined4 *)(local_90 + -4) = 0x80899a9;
  __stack_chk_fail();
}



void check_relative_width(table *t,int maxwidth)

{
  int iVar1;
  int iVar2;
  int iVar3;
  double r_1;
  double r;
  double w;
  double rel_total;
  int k_1;
  int j_1;
  int n_leftcell;
  int k;
  int j;
  int n_leftcol;
  table_cell *cell;
  double *rcolwidth;
  int size;
  int i;
  
  rel_total = 0.0;
  iVar1 = t->maxcol + 1;
  iVar2 = GC_malloc(iVar1 * 8);
  n_leftcol = 0;
  for (i = 0; i < iVar1; i = i + 1) {
    *(undefined8 *)(i * 8 + iVar2) = 0;
  }
  for (i = 0; i < iVar1; i = i + 1) {
    if (t->fixed_width[i] < 0) {
      *(double *)(i * 8 + iVar2) = (double)t->fixed_width[i] / -100.0;
    }
    else if (t->fixed_width[i] < 1) {
      n_leftcol = n_leftcol + 1;
    }
    else {
      *(double *)(i * 8 + iVar2) = (double)t->fixed_width[i] / (double)maxwidth;
    }
  }
  for (i = 0; i <= (t->cell).maxcell; i = i + 1) {
    if ((t->cell).fixed_width[i] < 0) {
      w = (double)(t->cell).fixed_width[i] / -100.0;
      n_leftcell = 0;
      iVar3 = (int)(t->cell).col[i];
      r = 0.0;
      for (j = 0; j < (t->cell).colspan[i]; j = j + 1) {
        if (*(double *)((j + iVar3) * 8 + iVar2) <= 0.0) {
          n_leftcell = n_leftcell + 1;
        }
        else {
          r = r + *(double *)((j + iVar3) * 8 + iVar2);
        }
      }
      if (n_leftcell == 0) {
        if (w != r) {
          (t->cell).fixed_width[i] = (short)ROUND(r * -100.0);
        }
      }
      else {
        if (w <= r) {
          w = ((double)(t->cell).colspan[i] * r) / (double)((t->cell).colspan[i] - n_leftcell);
          (t->cell).fixed_width[i] = (short)ROUND(w * -100.0);
        }
        for (j = 0; j < (t->cell).colspan[i]; j = j + 1) {
          if (*(double *)((j + iVar3) * 8 + iVar2) == 0.0) {
            *(double *)((j + iVar3) * 8 + iVar2) = (w - r) / (double)n_leftcell;
          }
        }
      }
    }
  }
  for (i = 0; i < iVar1; i = i + 1) {
    rel_total = rel_total + *(double *)(i * 8 + iVar2);
  }
  if (((n_leftcol == 0) && (rel_total < 0.9)) || (1.1 < rel_total)) {
    for (i = 0; i < iVar1; i = i + 1) {
      *(double *)(i * 8 + iVar2) = *(double *)(i * 8 + iVar2) / rel_total;
    }
    for (i = 0; i < iVar1; i = i + 1) {
      if (t->fixed_width[i] < 0) {
        t->fixed_width[i] = (short)ROUND(*(double *)(i * 8 + iVar2) * -100.0);
      }
    }
    for (i = 0; i <= (t->cell).maxcell; i = i + 1) {
      if ((t->cell).fixed_width[i] < 0) {
        r_1 = 0.0;
        for (j_1 = 0; j_1 < (t->cell).colspan[i]; j_1 = j_1 + 1) {
          r_1 = r_1 + *(double *)((j_1 + (t->cell).col[i]) * 8 + iVar2);
        }
        (t->cell).fixed_width[i] = (short)ROUND(r_1 * -100.0);
      }
    }
  }
  return;
}



void set_table_matrix(table *t,int width)

{
  short sVar1;
  short sVar2;
  int n;
  Matrix pmVar3;
  Vector pvVar4;
  double dVar5;
  double dVar6;
  double s;
  double b;
  table_cell *cell;
  int a;
  int j;
  int i;
  int size;
  
  n = t->maxcol + 1;
  if (0 < n) {
    pmVar3 = new_matrix(n);
    t->matrix = pmVar3;
    pvVar4 = new_vector(n);
    t->vector = pvVar4;
    for (i = 0; i < n; i = i + 1) {
      for (j = i; j < n; j = j + 1) {
        t->matrix->me[t->matrix->dim * i + j] = 0.0;
      }
      t->vector->ve[i] = 0.0;
    }
    check_relative_width(t,width);
    for (i = 0; i < n; i = i + 1) {
      if (t->fixed_width[i] < 1) {
        if (t->fixed_width[i] < 0) {
          dVar6 = (double)t->fixed_width[i] / -100.0;
          dVar5 = weight2((int)ROUND((double)width * dVar6));
          correct_table_matrix2(t,i,1,dVar6,dVar5 * 0.5);
        }
      }
      else {
        sVar1 = t->fixed_width[i];
        if (t->fixed_width[i] <= t->minimum_width[i]) {
          sVar1 = t->minimum_width[i];
        }
        dVar6 = weight2((int)sVar1);
        correct_table_matrix(t,i,1,(int)sVar1,dVar6 * 0.5);
      }
    }
    for (j = 0; j <= (t->cell).maxcell; j = j + 1) {
      if ((t->cell).fixed_width[j] < 1) {
        if ((t->cell).fixed_width[j] < 0) {
          dVar6 = (double)(t->cell).fixed_width[j] / -100.0;
          dVar5 = weight2((int)ROUND((double)width * dVar6));
          correct_table_matrix2(t,(int)(t->cell).col[j],(int)(t->cell).colspan[j],dVar6,dVar5 * 0.5)
          ;
        }
      }
      else {
        sVar1 = (t->cell).minimum_width[j];
        sVar2 = (t->cell).fixed_width[j];
        if (sVar2 <= sVar1) {
          sVar2 = sVar1;
        }
        dVar6 = weight2((int)sVar2);
        correct_table_matrix
                  (t,(int)(t->cell).col[j],(int)(t->cell).colspan[j],(int)sVar2,dVar6 * 0.5);
      }
    }
    set_table_matrix0(t,width);
    if (t->total_width < 1) {
      dVar6 = weight2(width);
      b = dVar6 + dVar6;
    }
    else {
      dVar6 = weight2(width);
      b = dVar6 * 0.25;
    }
    correct_table_matrix(t,0,n,width,b);
  }
  return;
}



void writeLocalCookie(void)

{
  Str p_Var1;
  FILE *__s;
  FILE *f;
  
  if ((no_rc_dir == 0) && (Local_cookie_file == (char *)0x0)) {
    p_Var1 = tmpfname(4,(char *)0x0);
    Local_cookie_file = p_Var1->ptr;
    set_environ("LOCAL_COOKIE_FILE",Local_cookie_file);
    __s = fopen(Local_cookie_file,"wb");
    if (__s != (FILE *)0x0) {
      localCookie();
      fwrite(Local_cookie->ptr,1,Local_cookie->length,__s);
      fclose(__s);
      chmod(Local_cookie_file,0x180);
    }
  }
  return;
}



Str localCookie(void)

{
  int iVar1;
  int iVar2;
  time_t tVar3;
  long lVar4;
  int in_GS_OFFSET;
  char hostname [256];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if (Local_cookie == (Str)0x0) {
    gethostname(hostname,0x100);
    iVar2 = GC_malloc(1);
    tVar3 = time((time_t *)0x0);
    srand48(iVar2 + tVar3);
    lVar4 = lrand48();
    Local_cookie = Sprintf("%ld@%s",lVar4,hostname);
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return Local_cookie;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



Str loadLocalDir(char *dname)

{
  wc_ces wVar1;
  wc_ces wVar2;
  Str x;
  DIR *__dirp;
  Str p_Var3;
  Str x_00;
  char *pcVar4;
  char *pcVar5;
  size_t sVar6;
  dirent *pdVar7;
  int iVar8;
  Str p_Var9;
  ssize_t sVar10;
  int in_GS_OFFSET;
  bool bVar11;
  stat lst;
  stat st;
  Str dirname;
  int nfile_max;
  int nfile;
  int maxlen;
  int n;
  int nrow;
  int l;
  int i;
  Str fbuf;
  char *qdir;
  char *p;
  char **flist;
  Directory *dir;
  DIR *d;
  Str tmp;
  char lbuf [1024];
  int local_10;
  
  local_10 = *(int *)(in_GS_OFFSET + 0x14);
  x = Strnew();
  nrow = 0;
  n = 0;
  maxlen = 0;
  nfile_max = 100;
  __dirp = opendir(dname);
  if (__dirp == (DIR *)0x0) {
    p_Var3 = (Str)0x0;
  }
  else {
    x_00 = Strnew_charp(dname);
    if ((x_00->length < 1) || (x_00->ptr[x_00->length + -1] != '/')) {
      if (x_00->area_size <= x_00->length + 1) {
        Strgrow(x_00);
      }
      iVar8 = x_00->length;
      x_00->ptr[iVar8] = '/';
      x_00->length = iVar8 + 1;
      x_00->ptr[x_00->length] = '\0';
    }
    p_Var3 = wc_Str_conv(x_00,SystemCharset,InnerCharset);
    pcVar4 = html_quote(p_Var3->ptr);
    pcVar5 = file_quote(x_00->ptr);
    pcVar5 = html_quote(pcVar5);
    p_Var3 = Strnew_m_charp("<HTML>\n<HEAD>\n<BASE HREF=\"file://",pcVar5,
                            "\">\n<TITLE>Directory list of ",pcVar4,
                            "</TITLE>\n</HEAD>\n<BODY>\n<H1>Directory list of ",pcVar4,"</H1>\n",0);
    flist = (char **)GC_malloc(400);
    nfile = 0;
    while (pdVar7 = readdir(__dirp), pdVar7 != (dirent *)0x0) {
      pcVar4 = allocStr(pdVar7->d_name,-1);
      flist[nfile] = pcVar4;
      nfile = nfile + 1;
      if (nfile == nfile_max) {
        flist = (char **)GC_realloc(flist,nfile_max << 3);
        nfile_max = nfile_max << 1;
      }
      if (multicolList != 0) {
        sVar6 = strlen(pdVar7->d_name);
        if (maxlen < (int)sVar6) {
          maxlen = sVar6;
        }
        n = n + 1;
      }
    }
    if (multicolList != 0) {
      l = COLS / (maxlen + 2);
      if (l == 0) {
        l = 1;
      }
      nrow = (n + l + -1) / l;
      n = 1;
      Strcat_charp(p_Var3,"<TABLE CELLPADDING=0>\n<TR VALIGN=TOP>\n");
    }
    qsort(flist,nfile,4,strCmp);
    for (i = 0; i < nfile; i = i + 1) {
      pcVar4 = flist[i];
      iVar8 = strcmp(pcVar4,".");
      if (iVar8 != 0) {
        Strcopy(x,x_00);
        if ((x->length < 1) || (x->ptr[x->length + -1] != '/')) {
          if (x->area_size <= x->length + 1) {
            Strgrow(x);
          }
          iVar8 = x->length;
          x->ptr[iVar8] = '/';
          x->length = iVar8 + 1;
          x->ptr[x->length] = '\0';
        }
        Strcat_charp(x,pcVar4);
        iVar8 = lstat(x->ptr,(stat *)&lst);
        if ((-1 < iVar8) && (iVar8 = stat(x->ptr,(stat *)&st), -1 < iVar8)) {
          if (multicolList == 0) {
            if ((lst.st_mode & 0xf000) == 0xa000) {
              Strcat_charp(p_Var3,"[LINK] ");
            }
            else if ((st.st_mode & 0xf000) == 0x4000) {
              Strcat_charp(p_Var3,"[DIR]&nbsp; ");
            }
            else {
              Strcat_charp(p_Var3,"[FILE] ");
            }
          }
          else if (n == 1) {
            Strcat_charp(p_Var3,"<TD><NOBR>");
          }
          pcVar5 = file_quote(pcVar4);
          pcVar5 = html_quote(pcVar5);
          Strcat_m_charp(p_Var3,"<A HREF=\"",pcVar5,0);
          if ((st.st_mode & 0xf000) == 0x4000) {
            if (p_Var3->area_size <= p_Var3->length + 1) {
              Strgrow(p_Var3);
            }
            iVar8 = p_Var3->length;
            p_Var3->ptr[iVar8] = '/';
            p_Var3->length = iVar8 + 1;
            p_Var3->ptr[p_Var3->length] = '\0';
          }
          wVar2 = SystemCharset;
          wVar1 = InnerCharset;
          p_Var9 = Strnew_charp(pcVar4);
          p_Var9 = wc_Str_conv(p_Var9,wVar2,wVar1);
          pcVar4 = html_quote(p_Var9->ptr);
          Strcat_m_charp(p_Var3,&DAT_080cb737,pcVar4,0);
          if ((st.st_mode & 0xf000) == 0x4000) {
            if (p_Var3->area_size <= p_Var3->length + 1) {
              Strgrow(p_Var3);
            }
            iVar8 = p_Var3->length;
            p_Var3->ptr[iVar8] = '/';
            p_Var3->length = iVar8 + 1;
            p_Var3->ptr[p_Var3->length] = '\0';
          }
          Strcat_charp(p_Var3,"</A>");
          if (multicolList == 0) {
            if (((lst.st_mode & 0xf000) == 0xa000) &&
               (sVar10 = readlink(x->ptr,lbuf,0x400), wVar2 = SystemCharset, wVar1 = InnerCharset,
               0 < sVar10)) {
              lbuf[sVar10] = '\0';
              p_Var9 = Strnew_charp(lbuf);
              p_Var9 = wc_Str_conv(p_Var9,wVar2,wVar1);
              pcVar4 = html_quote(p_Var9->ptr);
              Strcat_m_charp(p_Var3,&DAT_080cb753,pcVar4,0);
              if ((st.st_mode & 0xf000) == 0x4000) {
                if (p_Var3->area_size <= p_Var3->length + 1) {
                  Strgrow(p_Var3);
                }
                iVar8 = p_Var3->length;
                p_Var3->ptr[iVar8] = '/';
                p_Var3->length = iVar8 + 1;
                p_Var3->ptr[p_Var3->length] = '\0';
              }
            }
            Strcat_charp(p_Var3,"<br>\n");
          }
          else {
            bVar11 = n == nrow;
            n = n + 1;
            if (bVar11) {
              Strcat_charp(p_Var3,"</NOBR></TD>\n");
              n = 1;
            }
            else {
              Strcat_charp(p_Var3,"<BR>\n");
            }
          }
        }
      }
    }
    if (multicolList != 0) {
      Strcat_charp(p_Var3,"</TR>\n</TABLE>\n");
    }
    Strcat_charp(p_Var3,"</BODY>\n</HTML>\n");
  }
  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {
    return p_Var3;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int check_local_cgi(char *file,int status)

{
  int iVar1;
  __uid_t _Var2;
  __gid_t _Var3;
  stat st;
  
  if ((status == 1) || (status == 2)) {
    iVar1 = stat(file,(stat *)&st);
    if (iVar1 < 0) {
      iVar1 = -1;
    }
    else if ((st.st_mode & 0xf000) == 0x4000) {
      iVar1 = -1;
    }
    else {
      _Var2 = geteuid();
      if ((((st.st_uid != _Var2) || ((st.st_mode & 0x40) == 0)) &&
          ((_Var3 = getegid(), st.st_gid != _Var3 || ((st.st_mode & 8) == 0)))) &&
         ((st.st_mode & 1) == 0)) {
        return -1;
      }
      iVar1 = 0;
    }
  }
  else {
    iVar1 = -1;
  }
  return iVar1;
}



void set_environ(char *var,char *value)

{
  if ((var != (char *)0x0) && (value != (char *)0x0)) {
    setenv(var,value,1);
  }
  return;
}



void set_cgi_environ(char *name,char *fn,char *req_uri)

{
  set_environ("SERVER_SOFTWARE",w3m_version);
  set_environ("SERVER_PROTOCOL","HTTP/1.0");
  set_environ("SERVER_NAME","localhost");
  set_environ("SERVER_PORT","80");
  set_environ("REMOTE_HOST","localhost");
  set_environ("REMOTE_ADDR","127.0.0.1");
  set_environ("GATEWAY_INTERFACE","CGI/1.1");
  set_environ("SCRIPT_NAME",name);
  set_environ("SCRIPT_FILENAME",fn);
  set_environ("REQUEST_URI",req_uri);
  return;
}



Str checkPath(char *fn,char *path)

{
  char *pcVar1;
  char *p_00;
  Str x;
  int iVar2;
  stat st;
  Str tmp;
  char *p;
  
  while( true ) {
    if (*path == '\0') {
      return (Str)0x0;
    }
    pcVar1 = strchr(path,0x3a);
    if (pcVar1 != (char *)0x0) {
      path = allocStr(path,(int)pcVar1 - (int)path);
    }
    p_00 = expandPath(path);
    x = Strnew_charp(p_00);
    if ((x->length < 1) || (x->ptr[x->length + -1] != '/')) {
      if (x->area_size <= x->length + 1) {
        Strgrow(x);
      }
      iVar2 = x->length;
      x->ptr[iVar2] = '/';
      x->length = iVar2 + 1;
      x->ptr[x->length] = '\0';
    }
    Strcat_charp(x,fn);
    iVar2 = stat(x->ptr,(stat *)&st);
    if (iVar2 == 0) break;
    path = pcVar1;
    if (pcVar1 == (char *)0x0) {
      return (Str)0x0;
    }
    do {
      path = path + 1;
    } while (*path == ':');
  }
  return x;
}



int cgi_filename(char *uri,char **fn,char **name,char **path_info)

{
  int iVar1;
  char *pcVar2;
  Str p_Var3;
  Str x;
  Str tmp2;
  int offset;
  Str tmp;
  
  *fn = uri;
  *name = uri;
  *path_info = (char *)0x0;
  if ((cgi_bin != (char *)0x0) && (iVar1 = strncmp(uri,"/cgi-bin/",9), iVar1 == 0)) {
    pcVar2 = strchr(uri + 9,0x2f);
    *path_info = pcVar2;
    if (*path_info != (char *)0x0) {
      pcVar2 = allocStr(uri,(int)*path_info - (int)uri);
      *name = pcVar2;
    }
    p_Var3 = checkPath(*name + 9,cgi_bin);
    if (p_Var3 == (Str)0x0) {
      return 0;
    }
    *fn = p_Var3->ptr;
    return 2;
  }
  pcVar2 = w3m_lib_dir();
  p_Var3 = Strnew_charp(pcVar2);
  if ((p_Var3->length < 1) || (p_Var3->ptr[p_Var3->length + -1] != '/')) {
    if (p_Var3->area_size <= p_Var3->length + 1) {
      Strgrow(p_Var3);
    }
    iVar1 = p_Var3->length;
    p_Var3->ptr[iVar1] = '/';
    p_Var3->length = iVar1 + 1;
    p_Var3->ptr[p_Var3->length] = '\0';
  }
  iVar1 = strncmp(uri,"/$LIB/",6);
  if (iVar1 == 0) {
    offset = 6;
  }
  else {
    iVar1 = strncmp(uri,p_Var3->ptr,p_Var3->length);
    if (iVar1 == 0) {
      offset = p_Var3->length;
    }
    else {
      if ((*uri != '/') || (document_root == (char *)0x0)) {
        return 0;
      }
      x = Strnew_charp(document_root);
      if ((x->length < 1) || (x->ptr[x->length + -1] != '/')) {
        if (x->area_size <= x->length + 1) {
          Strgrow(x);
        }
        iVar1 = x->length;
        x->ptr[iVar1] = '/';
        x->length = iVar1 + 1;
        x->ptr[x->length] = '\0';
      }
      Strcat_charp(x,uri + 1);
      iVar1 = strncmp(x->ptr,p_Var3->ptr,p_Var3->length);
      if (iVar1 != 0) {
        return 0;
      }
      uri = x->ptr;
      *name = uri;
      offset = p_Var3->length;
    }
  }
  pcVar2 = strchr(uri + offset,0x2f);
  *path_info = pcVar2;
  if (*path_info != (char *)0x0) {
    pcVar2 = allocStr(uri,(int)*path_info - (int)uri);
    *name = pcVar2;
  }
  Strcat_charp(p_Var3,*name + offset);
  *fn = p_Var3->ptr;
  return 1;
}



FILE * localcgi_post(char *uri,char *qstr,FormList *request,char *referer)

{
  int iVar1;
  Str p_Var2;
  char *pcVar3;
  int *piVar4;
  char *pcVar5;
  char *tmpf;
  char *path_info;
  char *name;
  char *file;
  pid_t pid;
  int status;
  FILE *fw;
  FILE *fr;
  
  fr = (FILE *)0x0;
  fw = (FILE *)0x0;
  file = uri;
  name = uri;
  path_info = (char *)0x0;
  tmpf = (char *)0x0;
  status = cgi_filename(uri,&file,&name,&path_info);
  iVar1 = check_local_cgi(file,status);
  if (iVar1 < 0) {
    fr = (FILE *)0x0;
  }
  else {
    writeLocalCookie();
    if ((request != (FormList *)0x0) && (request->enctype != 1)) {
      p_Var2 = tmpfname(0,(char *)0x0);
      tmpf = p_Var2->ptr;
      fw = (FILE *)fopen(tmpf,"w");
      if ((FILE *)fw == (FILE *)0x0) {
        return (FILE *)0x0;
      }
    }
    pid = open_pipe_rw(&fr,(FILE **)0x0);
    if (pid < 0) {
      fr = (FILE *)0x0;
    }
    else {
      if (pid == 0) {
        if (fw == (FILE *)0x0) {
          iVar1 = -1;
        }
        else {
          iVar1 = fileno((FILE *)fw);
        }
        setup_child(1,2,iVar1);
        if (qstr != (char *)0x0) {
          p_Var2 = Strnew_m_charp(uri,&DAT_080cb844,qstr,0);
          uri = p_Var2->ptr;
        }
        set_cgi_environ(name,file,uri);
        if (path_info != (char *)0x0) {
          set_environ("PATH_INFO",path_info);
        }
        if ((referer != (char *)0x0) && (referer != (char *)0xffffffff)) {
          set_environ("HTTP_REFERER",referer);
        }
        if (request == (FormList *)0x0) {
          set_environ("REQUEST_METHOD","GET");
          if (qstr == (char *)0x0) {
            qstr = "";
          }
          set_environ("QUERY_STRING",qstr);
          freopen("/dev/null","r",stdin);
        }
        else {
          set_environ("REQUEST_METHOD","POST");
          if (qstr != (char *)0x0) {
            set_environ("QUERY_STRING",qstr);
          }
          p_Var2 = Sprintf("%d",request->length);
          set_environ("CONTENT_LENGTH",p_Var2->ptr);
          if (request->enctype == 1) {
            p_Var2 = Sprintf("multipart/form-data; boundary=%s",request->boundary);
            set_environ("CONTENT_TYPE",p_Var2->ptr);
            freopen(request->body,"r",stdin);
          }
          else {
            set_environ("CONTENT_TYPE","application/x-www-form-urlencoded");
            fwrite(request->body,1,request->length,(FILE *)fw);
            fclose((FILE *)fw);
            freopen(tmpf,"r",stdin);
          }
        }
        pcVar3 = mydirname(file);
        chdir(pcVar3);
        pcVar3 = mybasename(file);
        execl(file,pcVar3,0);
        piVar4 = __errno_location();
        pcVar3 = strerror(*piVar4);
        pcVar5 = mybasename(file);
        fprintf(stderr,"execl(\"%s\", \"%s\", NULL): %s\n",file,pcVar5,pcVar3);
                    // WARNING: Subroutine does not return
        exit(1);
      }
      if (fw != (FILE *)0x0) {
        fclose((FILE *)fw);
      }
    }
  }
  return fr;
}



form_list *
newFormList(char *action,char *method,char *charset,char *enctype,char *target,char *name,
           form_list *_next)

{
  Str p_Var1;
  int iVar2;
  form_list *pfVar3;
  wc_ces c;
  int e;
  int m;
  Str a;
  form_list *l;
  
  p_Var1 = Strnew_charp(action);
  m = 0;
  e = 0;
  c = 0;
  if (method != (char *)0x0) {
    iVar2 = strcasecmp(method,"get");
    if (iVar2 != 0) {
      iVar2 = strcasecmp(method,"post");
      if (iVar2 == 0) {
        m = 1;
      }
      else {
        iVar2 = strcasecmp(method,"internal");
        if (iVar2 == 0) {
          m = 2;
        }
      }
      goto LAB_0808b67d;
    }
  }
  m = 0;
LAB_0808b67d:
  if (enctype != (char *)0x0) {
    iVar2 = strcasecmp(enctype,"multipart/form-data");
    if ((iVar2 == 0) && (e = 1, m == 0)) {
      m = 1;
    }
  }
  if (charset != (char *)0x0) {
    c = wc_guess_charset(charset,0);
  }
  pfVar3 = (form_list *)GC_malloc(0x34);
  pfVar3->lastitem = (form_item_list *)0x0;
  pfVar3->item = pfVar3->lastitem;
  pfVar3->action = p_Var1;
  pfVar3->method = m;
  pfVar3->charset = c;
  pfVar3->enctype = e;
  pfVar3->target = target;
  pfVar3->name = name;
  pfVar3->next = _next;
  pfVar3->nitems = 0;
  pfVar3->body = (char *)0x0;
  pfVar3->length = 0;
  return pfVar3;
}



form_item_list * formList_addInput(form_list *fl,parsed_tag *tag)

{
  int iVar1;
  Str p_Var2;
  int i;
  char *p;
  form_item_list *item;
  
  if (fl == (form_list *)0x0) {
    item = (form_item_list *)0x0;
  }
  else {
    item = (form_item_list *)GC_malloc(0x48);
    item->type = -1;
    item->size = -1;
    item->rows = 0;
    item->init_checked = 0;
    item->checked = item->init_checked;
    item->accept = 0;
    item->name = (Str)0x0;
    item->init_value = (Str)0x0;
    item->value = item->init_value;
    item->readonly = 0;
    iVar1 = parsedtag_get_value(tag,0x21,&p);
    if (iVar1 != 0) {
      iVar1 = formtype(p);
      item->type = iVar1;
      if ((item->size < 0) && (((item->type == 0 || (item->type == 0xb)) || (item->type == 1)))) {
        item->size = 0x28;
      }
    }
    iVar1 = parsedtag_get_value(tag,0x19,&p);
    if (iVar1 != 0) {
      p_Var2 = Strnew_charp(p);
      item->name = p_Var2;
    }
    iVar1 = parsedtag_get_value(tag,0x24,&p);
    if (iVar1 != 0) {
      p_Var2 = Strnew_charp(p);
      item->init_value = p_Var2;
      item->value = item->init_value;
    }
    if (((tag->map == (uchar *)0x0) || (tag->map[0xc] == 'K')) ||
       (tag->attrid[tag->map[0xc]] == '\0')) {
      iVar1 = 0;
    }
    else {
      iVar1 = 1;
    }
    item->init_checked = iVar1;
    item->checked = item->init_checked;
    if (((tag->map == (uchar *)0x0) || (tag->map[1] == 'K')) || (tag->attrid[tag->map[1]] == '\0'))
    {
      iVar1 = 0;
    }
    else {
      iVar1 = 1;
    }
    item->accept = iVar1;
    parsedtag_get_value(tag,0x1e,&item->size);
    parsedtag_get_value(tag,0x16,&item->maxlength);
    if (((tag->map == (uchar *)0x0) || (tag->map[0x2b] == 'K')) ||
       (tag->attrid[tag->map[0x2b]] == '\0')) {
      iVar1 = 0;
    }
    else {
      iVar1 = 1;
    }
    item->readonly = iVar1;
    iVar1 = parsedtag_get_value(tag,0x49,&i);
    if (iVar1 != 0) {
      item->init_value = textarea_str[i];
      item->value = item->init_value;
    }
    iVar1 = parsedtag_get_value(tag,0x48,&i);
    if (iVar1 != 0) {
      item->select_option = select_option[i].first;
    }
    iVar1 = parsedtag_get_value(tag,0x1c,&p);
    if (iVar1 != 0) {
      iVar1 = atoi(p);
      item->rows = iVar1;
    }
    if (item->type == -1) {
      item = (form_item_list *)0x0;
    }
    else {
      if (item->type == 8) {
        chooseSelectOption(item,item->select_option);
        item->init_selected = item->selected;
        item->init_value = item->value;
        item->init_label = item->label;
      }
      if (((item->type == 0xb) && (item->value != (Str)0x0)) && (item->value->length != 0)) {
        item = (form_item_list *)0x0;
      }
      else {
        item->parent = fl;
        item->next = (form_item_list *)0x0;
        if (fl->item == (form_item_list *)0x0) {
          fl->lastitem = item;
          fl->item = fl->lastitem;
        }
        else {
          fl->lastitem->next = item;
          fl->lastitem = item;
        }
        if (item->type == 6) {
          item = (form_item_list *)0x0;
        }
        else {
          fl->nitems = fl->nitems + 1;
        }
      }
    }
  }
  return item;
}



char * form2str(FormItemList *fi)

{
  Str x;
  Str tmp;
  
  x = Strnew();
  if ((fi->type != 8) && (fi->type != 9)) {
    Strcat_charp(x,"input type=");
  }
  Strcat_charp(x,_formtypetbl[fi->type]);
  if ((fi->name != (Str)0x0) && (fi->name->length != 0)) {
    Strcat_m_charp(x," name=\"",fi->name->ptr,&DAT_080cb9d4,0);
  }
  if ((((fi->type == 3) || (fi->type == 2)) || (fi->type == 8)) && (fi->value != (Str)0x0)) {
    Strcat_m_charp(x," value=\"",fi->value->ptr,&DAT_080cb9d4,0);
  }
  Strcat_m_charp(x,&DAT_080cb9eb,_formmethodtbl[fi->parent->method],&DAT_080cb9e9,
                 fi->parent->action->ptr,&DAT_080cb9e7,0);
  return x->ptr;
}



int formtype(char *typestr)

{
  int iVar1;
  int i;
  
  i = 0;
  while( true ) {
    if (_formtypetbl[i] == (char *)0x0) {
      return -1;
    }
    iVar1 = strcasecmp(typestr,_formtypetbl[i]);
    if (iVar1 == 0) break;
    i = i + 1;
  }
  return i;
}



void formRecheckRadio(Anchor *a,Buffer *buf,FormItemList *fi)

{
  Anchor *a_00;
  FormItemList *form;
  int iVar1;
  FormItemList *f2;
  Anchor *a2;
  int i;
  
  for (i = 0; i < buf->formitem->nanchor; i = i + 1) {
    a_00 = buf->formitem->anchors + i;
    form = (FormItemList *)a_00->url;
    if (((form->parent == fi->parent) && (form != fi)) && (form->type == 3)) {
      iVar1 = strcmp(form->name->ptr,fi->name->ptr);
      if (iVar1 == 0) {
        form->checked = 0;
        formUpdateBuffer(a_00,buf,form);
      }
    }
  }
  fi->checked = 1;
  formUpdateBuffer(a,buf,fi);
  return;
}



void formResetBuffer(Buffer *buf,AnchorList *formitem)

{
  Anchor *a_00;
  FormItemList *form;
  int *piVar1;
  char *__s1;
  int iVar2;
  char *__s2;
  uint uVar3;
  FormItemList *f2;
  FormItemList *f1;
  Anchor *a;
  int i;
  
  if (((buf == (Buffer *)0x0) || (buf->formitem == (AnchorList *)0x0)) ||
     (formitem == (AnchorList *)0x0)) {
    return;
  }
  i = 0;
  do {
    if (buf->formitem->nanchor <= i) {
      return;
    }
    if (formitem->nanchor <= i) {
      return;
    }
    a_00 = buf->formitem->anchors + i;
    if ((int)a_00->y == (a_00->start).line) {
      form = (FormItemList *)a_00->url;
      piVar1 = (int *)formitem->anchors[i].url;
      if (form->type != *piVar1) {
        return;
      }
      if (piVar1[1] == 0) {
        __s2 = "";
      }
      else {
        __s2 = *(char **)piVar1[1];
      }
      if (form->name == (Str)0x0) {
        __s1 = "";
      }
      else {
        __s1 = form->name->ptr;
      }
      iVar2 = strcmp(__s1,__s2);
      if (iVar2 != 0) {
        return;
      }
      if ((uint)form->type < 0xc) {
        uVar3 = 1 << ((byte)form->type & 0x1f);
        if ((uVar3 & 0xa03) == 0) {
          if ((uVar3 & 0x100) == 0) {
            if ((uVar3 & 0xc) == 0) goto LAB_0808bf93;
            form->checked = piVar1[4];
            form->init_checked = piVar1[5];
          }
          else {
            form->select_option = (FormSelectOptionItem *)piVar1[0xb];
            form->value = (Str)piVar1[2];
            form->label = (Str)piVar1[0xc];
            form->selected = piVar1[0xe];
            form->init_value = (Str)piVar1[3];
            form->init_label = (Str)piVar1[0xd];
            form->init_selected = piVar1[0xf];
          }
        }
        else {
          form->value = (Str)piVar1[2];
          form->init_value = (Str)piVar1[3];
        }
        formUpdateBuffer(a_00,buf,form);
      }
    }
LAB_0808bf93:
    i = i + 1;
  } while( true );
}



int form_update_line(Line *line,char **str,int spos,int epos,int width,int newline,int password)

{
  byte bVar1;
  char cVar2;
  ushort uVar3;
  int iVar4;
  char *__dest;
  Lineprop *__dest_00;
  uint uVar5;
  byte bVar6;
  byte bVar7;
  Lineprop *prop;
  char *buf;
  char *p;
  int pos;
  int len;
  int i;
  int w;
  int c_width;
  int c_len;
  Lineprop effect;
  Lineprop c_type;
  
  p = *str;
  w = 0;
  pos = 0;
  while ((*p != '\0' && (w < width))) {
    if (WcOption.use_wide == '\0') {
      bVar6 = WTF_WIDTH_MAP[(byte)*p] != '\0';
    }
    else {
      bVar6 = WTF_WIDTH_MAP[(byte)*p];
    }
    uVar5 = (uint)bVar6;
    if (WTF_TYPE_MAP[(byte)*p] == 1) {
      if ((newline != 0) && (*p == '\n')) break;
      if (*p != '\r') {
        w = w + 1;
        pos = pos + 1;
      }
    }
    else if (password == 0) {
      if ((WTF_TYPE_MAP[(byte)*p] & 0x10) == 0) {
        if (width < (int)(w + uVar5)) break;
        w = w + uVar5;
        pos = pos + (uint)WTF_LEN_MAP[(byte)*p];
      }
      else {
        w = w + 1;
        pos = pos + 1;
      }
    }
    else {
      if (width < (int)(w + uVar5)) break;
      w = w + uVar5;
      pos = pos + uVar5;
    }
    p = p + WTF_LEN_MAP[(byte)*p];
  }
  iVar4 = (line->len + pos + (width - w) + spos) - epos;
  __dest = (char *)GC_malloc(iVar4);
  __dest_00 = (Lineprop *)GC_malloc(iVar4 * 2);
  bcopy(line->lineBuf,__dest,spos);
  bcopy(line->propBuf,__dest_00,spos * 2);
  uVar3 = line->propBuf[spos] & 0xff | ((byte)((uint)line->propBuf[spos] >> 8) & 0xc0) << 8;
  p = *str;
  w = 0;
  pos = spos;
  while ((*p != '\0' && (w < width))) {
    bVar6 = WTF_TYPE_MAP[(byte)*p];
    bVar1 = WTF_LEN_MAP[(byte)*p];
    if (WcOption.use_wide == '\0') {
      bVar7 = WTF_WIDTH_MAP[(byte)*p] != '\0';
    }
    else {
      bVar7 = WTF_WIDTH_MAP[(byte)*p];
    }
    uVar5 = (uint)bVar7;
    if (bVar6 == 1) {
      if ((newline != 0) && (*p == '\n')) break;
      if (*p != '\r') {
        if (password == 0) {
          cVar2 = ' ';
        }
        else {
          cVar2 = '*';
        }
        __dest[pos] = cVar2;
        __dest_00[pos] = uVar3;
        pos = pos + 1;
        w = w + 1;
      }
    }
    else if (password == 0) {
      if (((ushort)bVar6 << 8 & 0x1000) == 0) {
        if (width < (int)(w + uVar5)) break;
        __dest[pos] = *p;
        __dest_00[pos] = (ushort)bVar6 << 8 | uVar3;
        for (i = 1; pos = pos + 1, i < (int)(uint)bVar1; i = i + 1) {
          __dest[pos] = p[i];
          __dest_00[pos] = (ushort)(bVar6 & 0xf9) << 8 | 0x400 | uVar3;
        }
        w = w + uVar5;
      }
      else {
        __dest[pos] = ' ';
        __dest_00[pos] = uVar3;
        pos = pos + 1;
        w = w + 1;
      }
    }
    else {
      if (width < (int)(w + uVar5)) break;
      for (i = 0; i < (int)uVar5; i = i + 1) {
        __dest[pos] = '*';
        __dest_00[pos] = uVar3;
        pos = pos + 1;
        w = w + 1;
      }
    }
    p = p + bVar1;
  }
  for (; w < width; w = w + 1) {
    __dest[pos] = ' ';
    __dest_00[pos] = uVar3;
    pos = pos + 1;
  }
  if (newline != 0) {
    if (FoldTextarea == 0) {
      for (; ((*p != '\0' && (*p != '\r')) && (*p != '\n')); p = p + 1) {
      }
    }
    if (*p == '\r') {
      p = p + 1;
    }
    if (*p == '\n') {
      p = p + 1;
    }
  }
  *str = p;
  bcopy(line->lineBuf + epos,__dest + pos,line->len - epos);
  bcopy(line->propBuf + epos,__dest_00 + pos,(line->len - epos) * 2);
  line->lineBuf = __dest;
  line->propBuf = __dest_00;
  line->len = iVar4;
  line->size = iVar4;
  return pos;
}



void formUpdateBuffer(Anchor *a,Buffer *buf,FormItemList *form)

{
  int iVar1;
  int column;
  int iVar2;
  int iVar3;
  uint uVar4;
  Buffer save;
  int n;
  Line *l;
  int col;
  int pos;
  int c_rows;
  int rows;
  int epos;
  int spos;
  char *p;
  
  copyBuffer(&save,buf);
  gotoLine(buf,(a->start).line);
  if (((uint)form->type < 0xc) && ((1 << ((byte)form->type & 0x1f) & 0xb0fU) != 0)) {
    spos = (a->start).pos;
    epos = (a->end).pos;
  }
  else {
    spos = (a->start).pos + 1;
    epos = (a->end).pos + -1;
  }
  if ((uint)form->type < 0xc) {
    uVar4 = 1 << ((byte)form->type & 0x1f);
    if ((uVar4 & 0xb03) == 0) {
      if ((uVar4 & 0xc) != 0) {
        if (form->checked == 0) {
          buf->currentLine->lineBuf[spos] = ' ';
        }
        else {
          buf->currentLine->lineBuf[spos] = '*';
        }
      }
    }
    else {
      if (form->type == 8) {
        p = form->label->ptr;
        updateSelectOption(form,form->select_option);
      }
      else {
        p = form->value->ptr;
      }
      l = buf->currentLine;
      if (form->type == 9) {
        n = (int)a->y - buf->currentLine->linenumber;
        if (n < 1) {
          if (n < 0) {
            for (; (l != (Line *)0x0 && (n != 0)); n = n + 1) {
              l = l->prev;
            }
          }
        }
        else {
          for (; (l != (Line *)0x0 && (n != 0)); n = n + -1) {
            l = l->prev;
          }
        }
        if (l == (Line *)0x0) goto LAB_0808c8a3;
      }
      if (form->rows == 0) {
        iVar1 = 1;
      }
      else {
        iVar1 = form->rows;
      }
      column = calcPosition(l->lineBuf,l->propBuf,l->len,(a->start).pos,0,0);
      for (c_rows = 0; c_rows < iVar1; c_rows = c_rows + 1) {
        if (1 < iVar1) {
          iVar2 = columnPos(l,column);
          a = retrieveAnchor(buf->formitem,l->linenumber,iVar2);
          if (a == (Anchor *)0x0) break;
          spos = (a->start).pos;
          epos = (a->end).pos;
        }
        iVar2 = form->type;
        iVar3 = calcPosition(l->lineBuf,l->propBuf,l->len,epos,0,0);
        iVar2 = form_update_line(l,&p,spos,epos,iVar3 - column,(uint)(1 < iVar1),(uint)(iVar2 == 1))
        ;
        if (iVar2 != epos) {
          shiftAnchorPosition(buf->href,buf->hmarklist,(a->start).line,spos,iVar2 - epos);
          shiftAnchorPosition(buf->name,buf->hmarklist,(a->start).line,spos,iVar2 - epos);
          shiftAnchorPosition(buf->img,buf->hmarklist,(a->start).line,spos,iVar2 - epos);
          shiftAnchorPosition(buf->formitem,buf->hmarklist,(a->start).line,spos,iVar2 - epos);
        }
        l = l->next;
      }
    }
  }
LAB_0808c8a3:
  copyBuffer(buf,&save);
  arrangeLine(buf);
  return;
}



Str textfieldrep(Str s,int width)

{
  byte bVar1;
  Str x;
  int iVar2;
  byte bVar3;
  int c_len;
  int k;
  int j;
  int i;
  Str n;
  Lineprop c_type;
  
  x = Strnew_size(width + 2);
  j = 0;
  for (i = 0; i < s->length; i = i + (uint)bVar1) {
    bVar1 = WTF_LEN_MAP[(byte)s->ptr[i]];
    if (s->ptr[i] != '\r') {
      if (WcOption.use_wide == '\0') {
        bVar3 = WTF_WIDTH_MAP[(byte)s->ptr[i]] != '\0';
      }
      else {
        bVar3 = WTF_WIDTH_MAP[(byte)s->ptr[i]];
      }
      iVar2 = (uint)bVar3 + j;
      if (width < iVar2) break;
      j = iVar2;
      if (WTF_TYPE_MAP[(byte)s->ptr[i]] == 1) {
        if (x->area_size <= x->length + 1) {
          Strgrow(x);
        }
        iVar2 = x->length;
        x->ptr[iVar2] = ' ';
        x->length = iVar2 + 1;
        x->ptr[x->length] = '\0';
      }
      else if ((WTF_TYPE_MAP[(byte)s->ptr[i]] & 0x10) == 0) {
        if (s->ptr[i] == '&') {
          Strcat_charp(x,"&amp;");
        }
        else if (s->ptr[i] == '<') {
          Strcat_charp(x,"&lt;");
        }
        else if (s->ptr[i] == '>') {
          Strcat_charp(x,"&gt;");
        }
        else {
          Strcat_charp_n(x,s->ptr + i,(uint)bVar1);
        }
      }
      else {
        if (x->area_size <= x->length + 1) {
          Strgrow(x);
        }
        iVar2 = x->length;
        x->ptr[iVar2] = ' ';
        x->length = iVar2 + 1;
        x->ptr[x->length] = '\0';
      }
    }
  }
  for (; j < width; j = j + 1) {
    if (x->area_size <= x->length + 1) {
      Strgrow(x);
    }
    iVar2 = x->length;
    x->ptr[iVar2] = ' ';
    x->length = iVar2 + 1;
    x->ptr[x->length] = '\0';
  }
  return x;
}



void form_fputs_decode(Str s,FILE *f)

{
  int iVar1;
  Str p_Var2;
  Str z;
  char *p;
  
  p_Var2 = Strnew();
  for (p = s->ptr; *p != '\0'; p = p + 1) {
    if ((*p == '\r') && (p[1] == '\n')) {
      p = p + 1;
    }
    if (p_Var2->area_size <= p_Var2->length + 1) {
      Strgrow(p_Var2);
    }
    iVar1 = p_Var2->length;
    p_Var2->ptr[iVar1] = *p;
    p_Var2->length = iVar1 + 1;
    p_Var2->ptr[p_Var2->length] = '\0';
  }
  p_Var2 = wc_Str_conv_strict(p_Var2,InnerCharset,DisplayCharset);
  fwrite(p_Var2->ptr,1,p_Var2->length,(FILE *)f);
  return;
}



void input_textarea(FormItemList *fi)

{
  Str p_Var1;
  wc_ces charset;
  FILE *f;
  Str tmp;
  char *tmpf;
  wc_uint8 auto_detect;
  
  p_Var1 = tmpfname(0,(char *)0x0);
  tmpf = p_Var1->ptr;
  charset = DisplayCharset;
  f = (FILE *)fopen(tmpf,"w");
  if ((FILE *)f == (FILE *)0x0) {
    disp_err_message("Can\'t open temporary file",0);
  }
  else {
    if (fi->value != (Str)0x0) {
      form_fputs_decode(fi->value,f);
    }
    fclose((FILE *)f);
    fmTerm();
    p_Var1 = myEditor(Editor,tmpf,1);
    system(p_Var1->ptr);
    fmInit();
    if (fi->readonly == 0) {
      f = (FILE *)fopen(tmpf,"r");
      if ((FILE *)f == (FILE *)0x0) {
        disp_err_message("Can\'t open temporary file",0);
      }
      else {
        p_Var1 = Strnew();
        fi->value = p_Var1;
        auto_detect = WcOption.auto_detect;
        WcOption.auto_detect = '\x02';
        while( true ) {
          tmp = Strfgets(f);
          if (tmp->length < 1) break;
          if ((tmp->length == 1) && (tmp->ptr[tmp->length + -1] == '\n')) {
            tmp = Strnew_charp("\r\n");
          }
          else if ((1 < tmp->length) &&
                  ((tmp->ptr[tmp->length + -1] == '\n' && (tmp->ptr[tmp->length + -2] != '\r')))) {
            Strshrink(tmp,1);
            Strcat_charp(tmp,"\r\n");
          }
          tmp = convertLine((URLFile *)0x0,tmp,0,&charset,DisplayCharset);
          Strcat(fi->value,tmp);
        }
        WcOption.auto_detect = auto_detect;
        fclose((FILE *)f);
      }
    }
    unlink(tmpf);
  }
  return;
}



void do_internal(char *action,char *data)

{
  anon_subr_void_parsed_tagarg_ptr_for_rout *paVar1;
  int iVar2;
  parsed_tagarg *ppVar3;
  int i;
  
  i = 0;
  while( true ) {
    if (internal_action[i].action == (char *)0x0) {
      return;
    }
    iVar2 = strcasecmp(internal_action[i].action,action);
    if (iVar2 == 0) break;
    i = i + 1;
  }
  if (internal_action[i].rout == (anon_subr_void_parsed_tagarg_ptr_for_rout *)0x0) {
    return;
  }
  paVar1 = internal_action[i].rout;
  ppVar3 = cgistr2tagarg(data);
  (*paVar1)(ppVar3);
  return;
}



void addSelectOption(FormSelectOption *fso,Str value,Str label,int chk)

{
  FormSelectOptionItem *pFVar1;
  FormSelectOptionItem *o;
  
  pFVar1 = (FormSelectOptionItem *)GC_malloc(0x10);
  if (value == (Str)0x0) {
    value = label;
  }
  pFVar1->value = value;
  Strremovefirstspaces(label);
  Strremovetrailingspaces(label);
  pFVar1->label = label;
  pFVar1->checked = chk;
  pFVar1->next = (form_select_option_item *)0x0;
  if (fso->first == (FormSelectOptionItem *)0x0) {
    fso->last = pFVar1;
    fso->first = fso->last;
  }
  else {
    fso->last->next = pFVar1;
    fso->last = pFVar1;
  }
  return;
}



void chooseSelectOption(FormItemList *fi,FormSelectOptionItem *item)

{
  Str p_Var1;
  int i;
  FormSelectOptionItem *opt;
  
  fi->selected = 0;
  if (item == (FormSelectOptionItem *)0x0) {
    p_Var1 = Strnew_size(0);
    fi->value = p_Var1;
    p_Var1 = Strnew_size(0);
    fi->label = p_Var1;
  }
  else {
    fi->value = item->value;
    fi->label = item->label;
    i = 0;
    for (opt = item; opt != (FormSelectOptionItem *)0x0; opt = opt->next) {
      if (opt->checked != 0) {
        fi->value = opt->value;
        fi->label = opt->label;
        fi->selected = i;
        break;
      }
      i = i + 1;
    }
    updateSelectOption(fi,item);
  }
  return;
}



void updateSelectOption(FormItemList *fi,FormSelectOptionItem *item)

{
  int i;
  
  if ((fi != (FormItemList *)0x0) && (item != (FormSelectOptionItem *)0x0)) {
    i = 0;
    for (; item != (FormSelectOptionItem *)0x0; item = item->next) {
      if (fi->selected == i) {
        item->checked = 1;
      }
      else {
        item->checked = 0;
      }
      i = i + 1;
    }
  }
  return;
}



int formChooseOptionByMenu(form_item_list *fi,int x,int y)

{
  char **label_00;
  int iVar1;
  char **label;
  FormSelectOptionItem *opt;
  int init_select;
  int selected;
  int n;
  int i;
  
  selected = -1;
  iVar1 = fi->selected;
  n = 0;
  for (opt = fi->select_option; opt != (FormSelectOptionItem *)0x0; opt = opt->next) {
    n = n + 1;
  }
  label_00 = (char **)GC_malloc((n + 1) * 4);
  i = 0;
  for (opt = fi->select_option; opt != (FormSelectOptionItem *)0x0; opt = opt->next) {
    label_00[i] = opt->label->ptr;
    i = i + 1;
  }
  label_00[n] = (char *)0x0;
  optionMenu(x,y,label_00,&selected,iVar1,(anon_subr_void_varargs *)0x0);
  if (selected < 0) {
    iVar1 = 0;
  }
  else {
    i = 0;
    for (opt = fi->select_option; opt != (FormSelectOptionItem *)0x0; opt = opt->next) {
      if (i == selected) {
        fi->selected = selected;
        fi->value = opt->value;
        fi->label = opt->label;
        break;
      }
      i = i + 1;
    }
    updateSelectOption(fi,fi->select_option);
    iVar1 = 1;
  }
  return iVar1;
}



void form_write_data(FILE *f,char *boundary,char *name,char *value)

{
  fprintf((FILE *)f,"--%s\r\n",boundary);
  fprintf((FILE *)f,"Content-Disposition: form-data; name=\"%s\"\r\n\r\n",name);
  fprintf((FILE *)f,"%s\r\n",value);
  return;
}



void form_write_from_file(FILE *f,char *boundary,char *name,char *filename,char *file)

{
  char *pcVar1;
  char *pcVar2;
  int iVar3;
  FILE *__stream;
  stat st;
  char *type;
  int c;
  FILE *fd;
  
  fprintf((FILE *)f,"--%s\r\n",boundary);
  pcVar1 = mybasename(filename);
  fprintf((FILE *)f,"Content-Disposition: form-data; name=\"%s\"; filename=\"%s\"\r\n",name,pcVar1);
  pcVar2 = guessContentType(file);
  if (pcVar2 == (char *)0x0) {
    pcVar2 = "application/octet-stream";
  }
  fprintf((FILE *)f,"Content-Type: %s\r\n\r\n",pcVar2,pcVar1);
  iVar3 = lstat(file,(stat *)&st);
  if (((-1 < iVar3) && ((st.st_mode & 0xf000) != 0x4000)) &&
     (__stream = fopen(file,"r"), __stream != (FILE *)0x0)) {
    while (iVar3 = fgetc(__stream), iVar3 != -1) {
      fputc(iVar3,(FILE *)f);
    }
    fclose(__stream);
  }
  fwrite(&DAT_080cba1d,1,2,(FILE *)f);
  return;
}



pre_form * add_pre_form(pre_form *prev,char *url,char *name,char *action)

{
  pre_form *ppVar1;
  size_t sVar2;
  char *pcVar3;
  Regex *pRVar4;
  Str p_Var5;
  ParsedURL pu;
  int l;
  pre_form *new;
  
  if (prev == (pre_form *)0x0) {
    PreForm = (pre_form *)GC_malloc(0x18);
    new = PreForm;
  }
  else {
    ppVar1 = (pre_form *)GC_malloc(0x18);
    prev->next = ppVar1;
    new = prev->next;
  }
  if ((url == (char *)0x0) || (*url != '/')) {
    if (url != (char *)0x0) {
      parseURL2(url,&pu,(ParsedURL *)0x0);
      p_Var5 = parsedURL2Str(&pu);
      new->url = p_Var5->ptr;
      new->re_url = (Regex *)0x0;
    }
  }
  else {
    sVar2 = strlen(url);
    if (((int)sVar2 < 2) || (url[sVar2 - 1] != '/')) {
      new->url = url + 1;
    }
    else {
      pcVar3 = allocStr(url + 1,sVar2 - 2);
      new->url = pcVar3;
    }
    pRVar4 = newRegex(new->url,0,(Regex *)0x0,(char **)0x0);
    new->re_url = pRVar4;
    if (new->re_url == (Regex *)0x0) {
      new->url = (char *)0x0;
    }
  }
  if ((name == (char *)0x0) || (*name == '\0')) {
    name = (char *)0x0;
  }
  new->name = name;
  if ((action == (char *)0x0) || (*action == '\0')) {
    action = (char *)0x0;
  }
  new->action = action;
  new->item = (pre_form_item *)0x0;
  new->next = (pre_form *)0x0;
  return new;
}



pre_form_item *
add_pre_form_item(pre_form *pf,pre_form_item *prev,int type,char *name,char *value,char *checked)

{
  pre_form_item *ppVar1;
  int iVar2;
  pre_form_item *new;
  
  if (pf != (pre_form *)0x0) {
    if (prev == (pre_form_item *)0x0) {
      ppVar1 = (pre_form_item *)GC_malloc(0x14);
      pf->item = ppVar1;
      new = pf->item;
    }
    else {
      ppVar1 = (pre_form_item *)GC_malloc(0x14);
      prev->next = ppVar1;
      new = prev->next;
    }
    new->type = type;
    new->name = name;
    new->value = value;
    if (((checked == (char *)0x0) || (*checked == '\0')) ||
       ((iVar2 = strcmp(checked,"0"), iVar2 != 0 &&
        ((iVar2 = strcasecmp(checked,"off"), iVar2 == 0 &&
         (iVar2 = strcasecmp(checked,"no"), iVar2 != 0)))))) {
      new->checked = 1;
    }
    else {
      new->checked = 0;
    }
    new->next = (pre_form_item *)0x0;
    return new;
  }
  return (pre_form_item *)0x0;
}



void loadPreForm(void)

{
  pre_form *ppVar1;
  int iVar2;
  char *pcVar3;
  char *p_00;
  Str p_Var4;
  char *checked;
  pre_form *prev;
  char *arg;
  char *s;
  char *p;
  char *name;
  int type;
  pre_form_item *pi;
  pre_form *pf;
  Str textarea;
  Str line;
  FILE *fp;
  
  line = (Str)0x0;
  textarea = (Str)0x0;
  pf = (pre_form *)0x0;
  pi = (pre_form_item *)0x0;
  type = -1;
  name = (char *)0x0;
  PreForm = (pre_form *)0x0;
  fp = openSecretFile(pre_form_file);
  if (fp != (FILE *)0x0) {
LAB_0808d618:
    line = Strfgets(fp);
    if (line->length != 0) {
      if ((textarea != (Str)0x0) &&
         ((iVar2 = strncmp(line->ptr,"/textarea",9), iVar2 != 0 ||
          ((MYCTYPE_MAP[(byte)line->ptr[9]] & 2) == 0)))) {
        Strcat(textarea,line);
        goto LAB_0808d618;
      }
      Strchop(line);
      Strremovefirstspaces(line);
      p = line->ptr;
      if ((*p != '#') && (*p != '\0')) {
        pcVar3 = getWord(&p);
        p_00 = getWord(&p);
        iVar2 = strcmp(pcVar3,"url");
        if (iVar2 == 0) {
          if ((p_00 != (char *)0x0) && (*p_00 != '\0')) {
            p = getQWord(&p);
            pf = add_pre_form(pf,p_00,(char *)0x0,p);
            pi = pf->item;
          }
        }
        else if (pf != (pre_form *)0x0) {
          iVar2 = strcmp(pcVar3,"form");
          if (iVar2 != 0) {
            iVar2 = strcmp(pcVar3,"text");
            if (iVar2 == 0) {
              type = 0;
            }
            else {
              iVar2 = strcmp(pcVar3,"file");
              if (iVar2 == 0) {
                type = 0xb;
              }
              else {
                iVar2 = strcmp(pcVar3,"passwd");
                if ((iVar2 == 0) || (iVar2 = strcmp(pcVar3,"password"), iVar2 == 0)) {
                  type = 1;
                }
                else {
                  iVar2 = strcmp(pcVar3,"checkbox");
                  if (iVar2 == 0) {
                    type = 2;
                  }
                  else {
                    iVar2 = strcmp(pcVar3,"radio");
                    if (iVar2 == 0) {
                      type = 3;
                    }
                    else {
                      iVar2 = strcmp(pcVar3,"submit");
                      if (iVar2 == 0) {
                        type = 4;
                      }
                      else {
                        iVar2 = strcmp(pcVar3,"image");
                        if (iVar2 == 0) {
                          type = 7;
                        }
                        else {
                          iVar2 = strcmp(pcVar3,"select");
                          if (iVar2 != 0) {
                            iVar2 = strcmp(pcVar3,"textarea");
                            if (iVar2 == 0) {
                              type = 9;
                              p_Var4 = Strnew_charp(p_00);
                              name = p_Var4->ptr;
                              textarea = Strnew();
                            }
                            else if (((textarea != (Str)0x0) && (name != (char *)0x0)) &&
                                    (iVar2 = strcmp(pcVar3,"/textarea"), iVar2 == 0)) {
                              pi = add_pre_form_item(pf,pi,type,name,textarea->ptr,(char *)0x0);
                              textarea = (Str)0x0;
                              name = (char *)0x0;
                            }
                            goto LAB_0808d618;
                          }
                          type = 8;
                        }
                      }
                    }
                  }
                }
              }
            }
            pcVar3 = getQWord(&p);
            checked = getQWord(&p);
            pi = add_pre_form_item(pf,pi,type,p_00,pcVar3,checked);
            goto LAB_0808d618;
          }
          if ((p_00 != (char *)0x0) && (*p_00 != '\0')) {
            pcVar3 = getQWord(&p);
            p = getQWord(&p);
            ppVar1 = pf;
            if ((p == (char *)0x0) || (s = pcVar3, *p == '\0')) {
              s = (char *)0x0;
              p = pcVar3;
            }
            if (pf->item == (pre_form_item *)0x0) {
              pf->name = s;
              if ((p == (char *)0x0) || (pcVar3 = p, *p == '\0')) {
                pcVar3 = (char *)0x0;
              }
              pf->action = pcVar3;
            }
            else {
              pf = add_pre_form(pf,"",s,p);
              pf->url = ppVar1->url;
              pf->re_url = ppVar1->re_url;
            }
            pi = pf->item;
          }
        }
      }
      goto LAB_0808d618;
    }
    fclose((FILE *)fp);
  }
  return;
}



void preFormUpdateBuffer(Buffer *buf)

{
  Anchor *a_00;
  char *__s2;
  FormItemList *fi_00;
  form_list *pfVar1;
  Str p_Var2;
  int iVar3;
  Str url;
  int j;
  FormSelectOptionItem *opt;
  FormItemList *fi;
  FormList *fl;
  Anchor *a;
  int i;
  pre_form_item *pi;
  pre_form *pf;
  
  if (((buf != (Buffer *)0x0) && (buf->formitem != (AnchorList *)0x0)) &&
     (PreForm != (pre_form *)0x0)) {
    for (pf = PreForm; pf != (pre_form *)0x0; pf = pf->next) {
      if (pf->re_url == (Regex *)0x0) {
        if (pf->url != (char *)0x0) {
          __s2 = pf->url;
          p_Var2 = parsedURL2Str(&buf->currentURL);
          iVar3 = strcmp(p_Var2->ptr,__s2);
          if (iVar3 == 0) goto LAB_0808db3c;
        }
      }
      else {
        p_Var2 = parsedURL2Str(&buf->currentURL);
        iVar3 = RegexMatch(pf->re_url,p_Var2->ptr,p_Var2->length,1);
        if (iVar3 != 0) {
LAB_0808db3c:
          for (i = 0; i < buf->formitem->nanchor; i = i + 1) {
            a_00 = buf->formitem->anchors + i;
            fi_00 = (FormItemList *)a_00->url;
            pfVar1 = fi_00->parent;
            if (((pf->name == (char *)0x0) ||
                ((pfVar1->name != (char *)0x0 && (iVar3 = strcmp(pfVar1->name,pf->name), iVar3 == 0)
                 ))) && ((pf->action == (char *)0x0 ||
                         ((pfVar1->action != (Str)0x0 &&
                          (iVar3 = strcmp(pfVar1->action->ptr,pf->action), iVar3 == 0)))))) {
              for (pi = pf->item; pi != (pre_form_item *)0x0; pi = pi->next) {
                if (pi->type == fi_00->type) {
                  if ((pi->type == 4) || (pi->type == 7)) {
                    if ((((pi->name == (char *)0x0) || (*pi->name == '\0')) ||
                        ((fi_00->name != (Str)0x0 &&
                         (iVar3 = strcmp(fi_00->name->ptr,pi->name), iVar3 == 0)))) &&
                       ((pi->value == (char *)0x0 ||
                        ((*pi->value == '\0' ||
                         ((fi_00->value != (Str)0x0 &&
                          (iVar3 = strcmp(fi_00->value->ptr,pi->value), iVar3 == 0)))))))) {
                      buf->submit = a_00;
                    }
                  }
                  else if (((pi->name != (char *)0x0) && (fi_00->name != (Str)0x0)) &&
                          (iVar3 = strcmp(fi_00->name->ptr,pi->name), iVar3 == 0)) {
                    switch(pi->type) {
                    case 0:
                    case 1:
                    case 9:
                    case 0xb:
                      p_Var2 = Strnew_charp(pi->value);
                      fi_00->value = p_Var2;
                      formUpdateBuffer(a_00,buf,fi_00);
                      break;
                    case 2:
                      if (((pi->value != (char *)0x0) && (fi_00->value != (Str)0x0)) &&
                         (iVar3 = strcmp(fi_00->value->ptr,pi->value), iVar3 == 0)) {
                        fi_00->checked = pi->checked;
                        formUpdateBuffer(a_00,buf,fi_00);
                      }
                      break;
                    case 3:
                      if (((pi->value != (char *)0x0) && (fi_00->value != (Str)0x0)) &&
                         (iVar3 = strcmp(fi_00->value->ptr,pi->value), iVar3 == 0)) {
                        formRecheckRadio(a_00,buf,fi_00);
                      }
                      break;
                    case 8:
                      j = 0;
                      for (opt = fi_00->select_option; opt != (FormSelectOptionItem *)0x0;
                          opt = opt->next) {
                        if (((pi->value != (char *)0x0) && (opt->value != (Str)0x0)) &&
                           (iVar3 = strcmp(opt->value->ptr,pi->value), iVar3 == 0)) {
                          fi_00->selected = j;
                          fi_00->value = opt->value;
                          fi_00->label = opt->label;
                          updateSelectOption(fi_00,fi_00->select_option);
                          formUpdateBuffer(a_00,buf,fi_00);
                          break;
                        }
                        j = j + 1;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return;
}



MapList * searchMapList(Buffer *buf,char *name)

{
  int iVar1;
  MapList *ml;
  
  if (name == (char *)0x0) {
    ml = (MapList *)0x0;
  }
  else {
    ml = buf->maplist;
    while ((ml != (MapList *)0x0 && (iVar1 = strcmp(ml->name->ptr,name), iVar1 != 0))) {
      ml = ml->next;
    }
  }
  return ml;
}



// WARNING: Removing unreachable block (ram,0x0808e170)
// WARNING: Removing unreachable block (ram,0x0808e16c)
// WARNING: Removing unreachable block (ram,0x0808e172)

int inMapArea(MapArea *a,int x,int y)

{
  char cVar1;
  double dVar2;
  double dVar3;
  double t;
  double c;
  double s;
  double r2;
  double r1;
  int i;
  
  if (a != (MapArea *)0x0) {
    cVar1 = a->shape;
    if (cVar1 == '\x02') {
      if ((((*a->coords <= x) && (a->coords[1] <= y)) && (x <= a->coords[2])) && (y <= a->coords[3])
         ) {
        return 1;
      }
    }
    else if (cVar1 < '\x03') {
      if (cVar1 == '\x01') {
        return 1;
      }
    }
    else if (cVar1 == '\x03') {
      if ((x - *a->coords) * (x - *a->coords) + (y - a->coords[1]) * (y - a->coords[1]) <=
          (int)a->coords[2] * (int)a->coords[2]) {
        return 1;
      }
    }
    else if (cVar1 == '\x04') {
      t = 0.0;
      for (i = 0; i < a->ncoords; i = i + 2) {
        dVar3 = SQRT((double)(y - a->coords[i + 1]) * (double)(y - a->coords[i + 1]) +
                     (double)(x - a->coords[i]) * (double)(x - a->coords[i]));
        dVar2 = sqrt((double)(y - a->coords[i + 3]) * (double)(y - a->coords[i + 3]) +
                     (double)(x - a->coords[i + 2]) * (double)(x - a->coords[i + 2]));
        if ((dVar3 == 0.0) || (dVar2 == 0.0)) {
          return 1;
        }
        dVar3 = atan2((((double)(y - a->coords[i + 3]) * (double)(x - a->coords[i]) -
                       (double)(y - a->coords[i + 1]) * (double)(x - a->coords[i + 2])) / dVar3) /
                      dVar2,(((double)(y - a->coords[i + 3]) * (double)(y - a->coords[i + 1]) +
                             (double)(x - a->coords[i + 2]) * (double)(x - a->coords[i])) / dVar3) /
                            dVar2);
        t = t + dVar3;
      }
      if (6.28 < ABS(t)) {
        return 1;
      }
    }
  }
  return 0;
}



int nearestMapArea(MapList *ml,int x,int y)

{
  int iVar1;
  void *pvVar2;
  int limit;
  int min;
  int n;
  int l;
  int i;
  MapArea *a;
  ListItem *al;
  
  n = -1;
  min = -1;
  if ((ml == (MapList *)0x0) || (ml->area == (GeneralList *)0x0)) {
    n = -1;
  }
  else {
    i = 0;
    for (al = ml->area->first; al != (ListItem *)0x0; al = al->next) {
      pvVar2 = al->ptr;
      if ((pvVar2 != (void *)0x0) &&
         (((iVar1 = (*(short *)((int)pvVar2 + 0x18) - x) * (*(short *)((int)pvVar2 + 0x18) - x) +
                    (*(short *)((int)pvVar2 + 0x1a) - y) * (*(short *)((int)pvVar2 + 0x1a) - y),
           min < 0 || (iVar1 < min)) &&
          (iVar1 < (int)ROUND(pixel_per_line * pixel_per_line + pixel_per_char * pixel_per_char)))))
      {
        n = i;
        min = iVar1;
      }
      i = i + 1;
    }
  }
  return n;
}



int searchMapArea(Buffer *buf,MapList *ml,Anchor *a_img)

{
  int iVar1;
  int py;
  int px;
  int n;
  int i;
  MapArea *a;
  ListItem *al;
  
  if (((ml == (MapList *)0x0) || (ml->area == (GeneralList *)0x0)) || (ml->area->nitem == 0)) {
    n = -1;
  }
  else {
    iVar1 = getMapXY(buf,a_img,&px,&py);
    if (iVar1 == 0) {
      n = -1;
    }
    else {
      n = -(int)ml->area->nitem;
      i = 0;
      for (al = ml->area->first; al != (ListItem *)0x0; al = al->next) {
        a = (MapArea *)al->ptr;
        if (((a != (MapArea *)0x0) && (n < 0)) && (iVar1 = inMapArea(a,px,py), iVar1 != 0)) {
          if (a->shape == '\x01') {
            if (-n == (int)ml->area->nitem) {
              n = -i;
            }
          }
          else {
            n = i;
          }
        }
        i = i + 1;
      }
      if (-n == (int)ml->area->nitem) {
        n = nearestMapArea(ml,px,py);
      }
      else if (n < 0) {
        n = -n;
      }
    }
  }
  return n;
}



MapArea * retrieveCurrentMapArea(Buffer *buf)

{
  Anchor *a_img_00;
  Anchor *pAVar1;
  char *pcVar2;
  MapList *ml_00;
  int iVar3;
  int n;
  int i;
  MapArea *a;
  ListItem *al;
  MapList *ml;
  FormItemList *fi;
  Anchor *a_form;
  Anchor *a_img;
  
  a_img_00 = retrieveCurrentImg(buf);
  if (((((a_img_00 != (Anchor *)0x0) && (a_img_00->image != (Image *)0x0)) &&
       (a_img_00->image->map != (char *)0x0)) &&
      ((pAVar1 = retrieveCurrentForm(buf), pAVar1 != (Anchor *)0x0 && (pAVar1->url != (char *)0x0)))
      ) && ((pcVar2 = pAVar1->url, pcVar2 != (char *)0x0 &&
            ((*(int *)(pcVar2 + 0x40) != 0 && (**(int **)(pcVar2 + 0x40) != 0)))))) {
    if (*(int *)(**(int **)(pcVar2 + 0x40) + 8) == 0) {
      pcVar2 = (char *)0x0;
    }
    else {
      pcVar2 = **(char ***)(**(int **)(pcVar2 + 0x40) + 8);
    }
    ml_00 = searchMapList(buf,pcVar2);
    if ((ml_00 != (MapList *)0x0) && (iVar3 = searchMapArea(buf,ml_00,a_img_00), -1 < iVar3)) {
      i = 0;
      for (al = ml_00->area->first; al != (ListItem *)0x0; al = al->next) {
        if (((MapArea *)al->ptr != (MapArea *)0x0) && (i == iVar3)) {
          return (MapArea *)al->ptr;
        }
        i = i + 1;
      }
    }
  }
  return (MapArea *)0x0;
}



int getMapXY(Buffer *buf,Anchor *a,int *x,int *y)

{
  short sVar1;
  int iVar2;
  int iVar3;
  
  if ((((buf == (Buffer *)0x0) || (a == (Anchor *)0x0)) || (a->image == (Image *)0x0)) ||
     ((x == (int *)0x0 || (y == (int *)0x0)))) {
    iVar2 = 0;
  }
  else {
    iVar2 = buf->currentColumn;
    sVar1 = buf->cursorX;
    iVar3 = calcPosition(buf->currentLine->lineBuf,buf->currentLine->propBuf,buf->currentLine->len,
                         (a->start).pos,0,0);
    *x = (int)ROUND(pixel_per_char * ((double)((iVar2 + sVar1) - iVar3) + 0.5)) -
         (int)a->image->xoffset;
    *y = (int)ROUND(pixel_per_line *
                    ((double)(buf->currentLine->linenumber - (int)a->image->y) + 0.5)) -
         (int)a->image->yoffset;
    if (*x < 1) {
      *x = 1;
    }
    if (*y < 1) {
      *y = 1;
    }
    iVar2 = 1;
  }
  return iVar2;
}



Anchor * retrieveCurrentMap(Buffer *buf)

{
  Anchor *pAVar1;
  int iVar2;
  FormItemList *fi;
  Anchor *a;
  
  pAVar1 = retrieveCurrentForm(buf);
  if ((pAVar1 == (Anchor *)0x0) || (pAVar1->url == (char *)0x0)) {
    pAVar1 = (Anchor *)0x0;
  }
  else if ((*(int *)(*(int *)(pAVar1->url + 0x40) + 8) != 2) ||
          (iVar2 = strcmp(**(char ***)(*(int *)(pAVar1->url + 0x40) + 0xc),"map"), iVar2 != 0)) {
    pAVar1 = (Anchor *)0x0;
  }
  return pAVar1;
}



MapArea * follow_map_menu(Buffer *buf,char *name,Anchor *a_img,int x,int y)

{
  char **ppcVar1;
  int iVar2;
  char **label_00;
  char *pcVar3;
  char **label;
  MapArea *a;
  int initial;
  int selected;
  int i;
  ListItem *al;
  MapList *ml;
  
  selected = -1;
  ml = searchMapList(buf,name);
  if (((ml == (MapList *)0x0) || (ml->area == (GeneralList *)0x0)) || (ml->area->nitem == 0)) {
    return (MapArea *)0x0;
  }
  initial = searchMapArea(buf,ml,a_img);
  if (initial < 0) {
    initial = 0;
  }
  else {
    iVar2 = initial;
    if (image_map_list == 0) goto map_end;
  }
  label_00 = (char **)GC_malloc((ml->area->nitem + 1) * 4);
  i = 0;
  for (al = ml->area->first; al != (ListItem *)0x0; al = al->next) {
    ppcVar1 = (char **)al->ptr;
    if (ppcVar1 == (char **)0x0) {
      label_00[i] = "";
    }
    else {
      if (*ppcVar1[2] == '\0') {
        pcVar3 = *ppcVar1;
      }
      else {
        pcVar3 = ppcVar1[2];
      }
      label_00[i] = pcVar3;
    }
    i = i + 1;
  }
  label_00[ml->area->nitem] = (char *)0x0;
  optionMenu(x,y,label_00,&selected,initial,(anon_subr_void_varargs *)0x0);
  iVar2 = selected;
map_end:
  selected = iVar2;
  if (-1 < selected) {
    i = 0;
    for (al = ml->area->first; al != (ListItem *)0x0; al = al->next) {
      if ((al->ptr != (void *)0x0) && (i == selected)) {
        return (MapArea *)al->ptr;
      }
      i = i + 1;
    }
  }
  return (MapArea *)0x0;
}



MapArea * newMapArea(char *url,char *target,char *alt,char *shape,char *coords)

{
  MapArea *pMVar1;
  int iVar2;
  short *psVar3;
  int max;
  int i;
  char *p;
  MapArea *a;
  
  pMVar1 = (MapArea *)GC_malloc(0x1c);
  pMVar1->url = url;
  pMVar1->target = target;
  if (alt == (char *)0x0) {
    alt = "";
  }
  pMVar1->alt = alt;
  pMVar1->shape = '\x02';
  if (shape != (char *)0x0) {
    iVar2 = strcasecmp(shape,"default");
    if (iVar2 == 0) {
      pMVar1->shape = '\x01';
    }
    else {
      iVar2 = strncasecmp(shape,"rect",4);
      if (iVar2 == 0) {
        pMVar1->shape = '\x02';
      }
      else {
        iVar2 = strncasecmp(shape,"circ",4);
        if (iVar2 == 0) {
          pMVar1->shape = '\x03';
        }
        else {
          iVar2 = strncasecmp(shape,"poly",4);
          if (iVar2 == 0) {
            pMVar1->shape = '\x04';
          }
          else {
            pMVar1->shape = '\0';
          }
        }
      }
    }
  }
  pMVar1->coords = (short *)0x0;
  pMVar1->ncoords = 0;
  pMVar1->center_x = 0;
  pMVar1->center_y = 0;
  if ((pMVar1->shape != '\0') && (pMVar1->shape != '\x01')) {
    if (coords == (char *)0x0) {
      pMVar1->shape = '\0';
    }
    else {
      if (pMVar1->shape == '\x02') {
        psVar3 = (short *)GC_malloc(8);
        pMVar1->coords = psVar3;
        pMVar1->ncoords = 4;
      }
      else if (pMVar1->shape == '\x03') {
        psVar3 = (short *)GC_malloc(6);
        pMVar1->coords = psVar3;
        pMVar1->ncoords = 3;
      }
      max = pMVar1->ncoords;
      i = 0;
      p = coords;
      while (((pMVar1->shape == '\x04' || (i < pMVar1->ncoords)) && (*p != '\0'))) {
        while ((MYCTYPE_MAP[(byte)*p] & 2) != 0) {
          p = p + 1;
        }
        if ((((MYCTYPE_MAP[(byte)*p] & 8) == 0) && (*p != '-')) && (*p != '+')) break;
        if (pMVar1->shape == '\x04') {
          if (max <= i) {
            if (i == 0) {
              max = 6;
            }
            else {
              max = i * 2;
            }
            psVar3 = (short *)GC_realloc(pMVar1->coords,(max + 2) * 2);
            pMVar1->coords = psVar3;
          }
          pMVar1->ncoords = pMVar1->ncoords + 1;
        }
        psVar3 = pMVar1->coords;
        iVar2 = atoi(p);
        psVar3[i] = (short)iVar2;
        i = i + 1;
        if ((*p == '-') || (*p == '+')) {
          p = p + 1;
        }
        while ((MYCTYPE_MAP[(byte)*p] & 8) != 0) {
          p = p + 1;
        }
        if ((*p != ',') && ((MYCTYPE_MAP[(byte)*p] & 2) == 0)) break;
        while ((MYCTYPE_MAP[(byte)*p] & 2) != 0) {
          p = p + 1;
        }
        if (*p == ',') {
          p = p + 1;
        }
      }
      if ((pMVar1->ncoords == i) && ((pMVar1->shape != '\x04' || (5 < pMVar1->ncoords)))) {
        if (pMVar1->shape == '\x04') {
          pMVar1->ncoords = (pMVar1->ncoords / 2) * 2;
          pMVar1->coords[pMVar1->ncoords] = *pMVar1->coords;
          pMVar1->coords[pMVar1->ncoords + 1] = pMVar1->coords[1];
        }
        if (pMVar1->shape == '\x03') {
          pMVar1->center_x = *pMVar1->coords;
          pMVar1->center_y = pMVar1->coords[1];
        }
        else {
          for (i = 0; i < pMVar1->ncoords / 2; i = i + 1) {
            pMVar1->center_x = pMVar1->center_x + pMVar1->coords[i * 2];
            pMVar1->center_y = pMVar1->center_y + pMVar1->coords[i * 2 + 1];
          }
          pMVar1->center_x = (short)((int)pMVar1->center_x / (pMVar1->ncoords / 2));
          pMVar1->center_y = (short)((int)pMVar1->center_y / (pMVar1->ncoords / 2));
        }
      }
      else {
        pMVar1->shape = '\0';
        pMVar1->coords = (short *)0x0;
        pMVar1->ncoords = 0;
      }
    }
  }
  return pMVar1;
}



void append_map_info(Buffer *buf,Str tmp,FormItemList *fi)

{
  char **ppcVar1;
  MapList *pMVar2;
  ParsedURL *current;
  Str p_Var3;
  char *pcVar4;
  char *pcVar5;
  ParsedURL pu;
  char *q;
  char *p;
  MapArea *a;
  ListItem *al;
  MapList *ml;
  
  if (fi->value == (Str)0x0) {
    pcVar4 = (char *)0x0;
  }
  else {
    pcVar4 = fi->value->ptr;
  }
  pMVar2 = searchMapList(buf,pcVar4);
  if (pMVar2 != (MapList *)0x0) {
    Strcat_m_charp(tmp,"<tr valign=top><td colspan=2>Links of current image map",
                   "<tr valign=top><td colspan=2><table>",0);
    for (al = pMVar2->area->first; al != (ListItem *)0x0; al = al->next) {
      ppcVar1 = (char **)al->ptr;
      if (ppcVar1 != (char **)0x0) {
        current = baseURL(buf);
        parseURL2(*ppcVar1,&pu,current);
        p_Var3 = parsedURL2Str(&pu);
        pcVar4 = html_quote(p_Var3->ptr);
        if (DecodeURL == 0) {
          p = html_quote(*ppcVar1);
        }
        else {
          pcVar5 = url_unquote_conv(*ppcVar1,buf->document_charset);
          p = html_quote(pcVar5);
        }
        if (*ppcVar1[2] == '\0') {
          pcVar5 = mybasename(*ppcVar1);
        }
        else {
          pcVar5 = ppcVar1[2];
        }
        pcVar5 = html_quote(pcVar5);
        Strcat_m_charp(tmp,"<tr valign=top><td>&nbsp;&nbsp;<td><a href=\"",pcVar4,&DAT_080cbb9f,
                       pcVar5,"</a><td>",p,&DAT_080cbb94,0);
      }
    }
    Strcat_charp(tmp,"</table>");
  }
  return;
}



void append_link_info(Buffer *buf,Str html,LinkList *link)

{
  ParsedURL *current;
  Str p_Var1;
  char *pcVar2;
  char *str;
  char *pcVar3;
  undefined4 uVar4;
  ParsedURL pu;
  char *url;
  LinkList *l;
  
  if (link != (LinkList *)0x0) {
    Strcat_charp(html,"<hr width=50%><h1>Link information</h1><table>\n");
    for (l = link; l != (LinkList *)0x0; l = l->next) {
      if (l->url == (char *)0x0) {
        url = "(empty)";
      }
      else {
        current = baseURL(buf);
        parseURL2(l->url,&pu,current);
        p_Var1 = parsedURL2Str(&pu);
        url = html_quote(p_Var1->ptr);
      }
      if (l->title == (char *)0x0) {
        pcVar2 = "(empty)";
      }
      else {
        pcVar2 = html_quote(l->title);
      }
      uVar4 = 0;
      pcVar3 = "</a><td>";
      Strcat_m_charp(html,"<tr valign=top><td><a href=\"",url,&DAT_080cbb9f,pcVar2,"</a><td>",0);
      if (l->type == '\x01') {
        Strcat_charp(html,"[Rel]");
      }
      else if (l->type == '\x02') {
        Strcat_charp(html,"[Rev]");
      }
      if (l->url == (char *)0x0) {
        url = "(empty)";
      }
      else if (DecodeURL == 0) {
        url = html_quote(l->url);
      }
      else {
        str = url_unquote_conv(l->url,buf->document_charset);
        url = html_quote(str);
      }
      Strcat_m_charp(html,&DAT_080cbc3d,url,0,pcVar2,pcVar3,uVar4);
      if (l->ctype != (char *)0x0) {
        pcVar2 = html_quote(l->ctype);
        Strcat_m_charp(html,&DAT_080cbc44,pcVar2,&DAT_080cbc42,0);
      }
      Strcat_charp(html,"\n");
    }
    Strcat_charp(html,"</table>\n");
  }
  return;
}



void append_frame_info(Buffer *buf,Str html,frameset *set,int level)

{
  char cVar1;
  frameset *set_00;
  char *pcVar2;
  int iVar3;
  frameset_element frame;
  int j;
  int i;
  char *q;
  char *p;
  
  if (set != (frameset *)0x0) {
    for (i = 0; iVar3 = set->row * set->col, iVar3 - i != 0 && i <= iVar3; i = i + 1) {
      set_00 = (frameset *)set->frame[i];
      if ((set_00 != (frameset *)0x0) && (cVar1 = set_00->attr, -1 < cVar1)) {
        if (cVar1 < '\x02') {
          if (set_00->currentURL != (ParsedURL *)0x0) {
            Strcat_charp(html,"<pre_int>");
            for (j = 0; j < level; j = j + 1) {
              Strcat_charp(html,"   ");
            }
            p = html_quote((char *)set_00->currentURL);
            Strcat_m_charp(html,"<a href=\"",p,&DAT_080cbb9f,0);
            if (set_00->name != (char *)0x0) {
              pcVar2 = url_unquote_conv(set_00->name,buf->document_charset);
              pcVar2 = html_quote(pcVar2);
              Strcat_charp(html,pcVar2);
            }
            if (DecodeURL != 0) {
              pcVar2 = url_unquote_conv((char *)set_00->currentURL,buf->document_charset);
              p = html_quote(pcVar2);
            }
            Strcat_m_charp(html,&DAT_080cbc7d,p,"</a></pre_int><br>\n",0);
          }
        }
        else if (cVar1 == '\x02') {
          append_frame_info(buf,html,set_00,level + 1);
        }
      }
    }
  }
  return;
}



Buffer * page_info_panel(Buffer *buf)

{
  int iVar1;
  FormItemList *fi_00;
  Str x;
  Str p_Var2;
  char *pcVar3;
  char *pcVar4;
  char *pcVar5;
  char *pcVar6;
  Anchor *pAVar7;
  ParsedURL *pPVar8;
  int iVar9;
  Buffer *pBVar10;
  int in_GS_OFFSET;
  char *pcVar11;
  char *pcVar12;
  undefined4 uVar13;
  ParsedURL pu;
  FormItemList *fi;
  Buffer *newbuf;
  wc_ces_list *list;
  char *q;
  char *p;
  int all;
  frameset *f_set;
  TextListItem *ti;
  Anchor *a;
  Str tmp;
  char charset [16];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  x = Strnew_size(0x400);
  f_set = (frameset *)0x0;
  Strcat_charp(x,
               "<html><head><title>Information about current page</title></head><body><h1>Information about current page</h1>\n"
              );
  if (buf != (Buffer *)0x0) {
    all = buf->allLine;
    if ((all == 0) && (buf->lastLine != (Line *)0x0)) {
      all = buf->lastLine->linenumber;
    }
    Strcat_charp(x,"<form method=internal action=charset>");
    p_Var2 = parsedURL2Str(&buf->currentURL);
    p = p_Var2->ptr;
    if (DecodeURL != 0) {
      p = url_unquote_conv(p,0);
    }
    pcVar3 = last_modified(buf);
    pcVar3 = html_quote(pcVar3);
    if (buf->real_type == (char *)0x0) {
      pcVar4 = "unknown";
    }
    else {
      pcVar4 = html_quote(buf->real_type);
    }
    pcVar5 = html_quote(p);
    pcVar6 = html_quote(buf->buffername);
    uVar13 = 0;
    pcVar12 = "<tr valign=top><td nowrap>Last Modified<td>";
    pcVar11 = "<tr valign=top><td nowrap>Document Type<td>";
    Strcat_m_charp(x,"<table cellpadding=0>","<tr valign=top><td nowrap>Title<td>",pcVar6,
                   "<tr valign=top><td nowrap>Current URL<td>",pcVar5,
                   "<tr valign=top><td nowrap>Document Type<td>",pcVar4,
                   "<tr valign=top><td nowrap>Last Modified<td>",pcVar3,0);
    if (buf->document_charset != InnerCharset) {
      list = wc_get_ces_list();
      Strcat_charp(x,"<tr><td nowrap>Document Charset<td><select name=charset>");
      for (; list->name != (char *)0x0; list = list + 1) {
        sprintf(charset,"%d",list->id);
        if (buf->document_charset == list->id) {
          pcVar5 = " selected>";
        }
        else {
          pcVar5 = ">";
        }
        Strcat_m_charp(x,"<option value=",charset,pcVar5,list->desc,0);
      }
      Strcat_charp(x,"</select>");
      Strcat_charp(x,"<tr><td><td><input type=submit value=Change>");
    }
    p_Var2 = Sprintf("%d",buf->trbyte);
    pcVar5 = p_Var2->ptr;
    p_Var2 = Sprintf("%d",all);
    Strcat_m_charp(x,"<tr valign=top><td nowrap>Number of lines<td>",p_Var2->ptr,
                   "<tr valign=top><td nowrap>Transferred bytes<td>",pcVar5,0,pcVar11,pcVar4,pcVar12
                   ,pcVar3,uVar13);
    pAVar7 = retrieveCurrentAnchor(buf);
    if (pAVar7 != (Anchor *)0x0) {
      pPVar8 = baseURL(buf);
      parseURL2(pAVar7->url,&pu,pPVar8);
      p_Var2 = parsedURL2Str(&pu);
      pcVar3 = p_Var2->ptr;
      pcVar4 = html_quote(pcVar3);
      p = pcVar4;
      if (DecodeURL != 0) {
        pcVar3 = url_unquote_conv(pcVar3,buf->document_charset);
        p = html_quote(pcVar3);
      }
      Strcat_m_charp(x,"<tr valign=top><td nowrap>URL of current anchor<td><a href=\"",pcVar4,
                     &DAT_080cbb9f,p,&DAT_080cbed2,0);
    }
    pAVar7 = retrieveCurrentImg(buf);
    if (pAVar7 != (Anchor *)0x0) {
      pPVar8 = baseURL(buf);
      parseURL2(pAVar7->url,&pu,pPVar8);
      p_Var2 = parsedURL2Str(&pu);
      pcVar3 = p_Var2->ptr;
      pcVar4 = html_quote(pcVar3);
      p = pcVar4;
      if (DecodeURL != 0) {
        pcVar3 = url_unquote_conv(pcVar3,buf->document_charset);
        p = html_quote(pcVar3);
      }
      Strcat_m_charp(x,"<tr valign=top><td nowrap>URL of current image<td><a href=\"",pcVar4,
                     &DAT_080cbb9f,p,&DAT_080cbed2,0);
    }
    pAVar7 = retrieveCurrentForm(buf);
    if (pAVar7 != (Anchor *)0x0) {
      fi_00 = (FormItemList *)pAVar7->url;
      pcVar3 = form2str(fi_00);
      if (DecodeURL == 0) {
        p = html_quote(pcVar3);
      }
      else {
        pcVar3 = url_unquote_conv(pcVar3,buf->document_charset);
        p = html_quote(pcVar3);
      }
      Strcat_m_charp(x,"<tr valign=top><td nowrap>Method/type of current form&nbsp;<td>",p,0);
      if ((fi_00->parent->method == 2) &&
         (iVar9 = strcmp(fi_00->parent->action->ptr,"map"), iVar9 == 0)) {
        append_map_info(buf,x,fi_00->parent->item);
      }
    }
    Strcat_charp(x,"</table>\n");
    Strcat_charp(x,"</form>");
    append_link_info(buf,x,buf->linklist);
    if (buf->document_header != (TextList *)0x0) {
      Strcat_charp(x,"<hr width=50%><h1>Header information</h1><pre>\n");
      for (ti = buf->document_header->first; ti != (TextListItem *)0x0; ti = ti->next) {
        pcVar3 = html_quote(ti->ptr);
        Strcat_m_charp(x,"<pre_int>",pcVar3,"</pre_int>\n",0);
      }
      Strcat_charp(x,"</pre>\n");
    }
    if (buf->frameset == (frameset *)0x0) {
      if ((((buf->bufferprop & 2U) != 0) && (buf->nextBuffer != (_Buffer *)0x0)) &&
         (buf->nextBuffer->frameset != (frameset *)0x0)) {
        f_set = buf->nextBuffer->frameset;
      }
    }
    else {
      f_set = buf->frameset;
    }
    if (f_set != (frameset *)0x0) {
      Strcat_charp(x,"<hr width=50%><h1>Frame information</h1>\n");
      append_frame_info(buf,x,f_set,0);
    }
  }
  Strcat_charp(x,"</body></html>");
  pBVar10 = loadHTMLString(x);
  if (pBVar10 != (Buffer *)0x0) {
    pBVar10->document_charset = buf->document_charset;
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return pBVar10;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void KeyAbort(int _dummy)

{
                    // WARNING: Subroutine does not return
  siglongjmp((__jmp_buf_tag *)AbortLoading,1);
}



int parseFrameSetLength(char *s,char ***ret)

{
  char **ppcVar1;
  Str p_Var2;
  char *pcVar3;
  char **ppcVar4;
  char **lv;
  char *q;
  char *p;
  int len;
  int i;
  
  i = 1;
  if (s == (char *)0x0) {
    s = "*";
  }
  else {
    p = s;
    while (p = strchr(p,0x2c), p != (char *)0x0) {
      i = i + 1;
      p = p + 1;
    }
  }
  ppcVar1 = (char **)GC_malloc(i << 2);
  i = 0;
  p = s;
  while( true ) {
    while ((*p != '\0' && ((MYCTYPE_MAP[(byte)*p] & 2) != 0))) {
      p = p + 1;
    }
    len = strtol(p,&q,10);
    if (*q == '%') {
      ppcVar4 = ppcVar1 + i;
      p_Var2 = Sprintf("%d%%",len);
      *ppcVar4 = p_Var2->ptr;
      i = i + 1;
    }
    else if (*q == '*') {
      ppcVar1[i] = "*";
      i = i + 1;
    }
    else {
      ppcVar4 = ppcVar1 + i;
      p_Var2 = Sprintf("%d",len);
      *ppcVar4 = p_Var2->ptr;
      i = i + 1;
    }
    pcVar3 = strchr(q,0x2c);
    if (pcVar3 == (char *)0x0) break;
    p = pcVar3 + 1;
  }
  *ret = ppcVar1;
  return i;
}



frameset * newFrameSet(parsed_tag *tag)

{
  int iVar1;
  frameset_element *pfVar2;
  char *rows;
  char *cols;
  int i;
  frameset *f;
  
  cols = (char *)0x0;
  rows = (char *)0x0;
  f = (frameset *)GC_malloc(0x24);
  f->attr = '\x02';
  f->name = (char *)0x0;
  f->currentURL = (ParsedURL *)0x0;
  parsedtag_get_value(tag,0xd,&cols);
  parsedtag_get_value(tag,0x1c,&rows);
  iVar1 = parseFrameSetLength(cols,&f->width);
  f->col = iVar1;
  iVar1 = parseFrameSetLength(rows,&f->height);
  f->row = iVar1;
  f->i = 0;
  i = f->col * f->row;
  pfVar2 = (frameset_element *)GC_malloc(i * 4);
  f->frame = pfVar2;
  do {
    i = i + -1;
    f->frame[i] = 0;
  } while (i != 0);
  return f;
}



frame_body * newFrame(parsed_tag *tag,Buffer *buf)

{
  wc_ces wVar1;
  wc_ces wVar2;
  ParsedURL *pPVar3;
  int iVar4;
  char *pcVar5;
  Str p_Var6;
  char *p;
  frame_body *body;
  
  body = (frame_body *)GC_malloc(0x24);
  bzero(body,0x24);
  body->attr = '\0';
  body->flags = '\0';
  pPVar3 = baseURL(buf);
  body->baseURL = pPVar3;
  if (tag != (parsed_tag *)0x0) {
    iVar4 = parsedtag_get_value(tag,0x1f,&p);
    wVar2 = InnerCharset;
    if (iVar4 != 0) {
      wVar1 = buf->document_charset;
      pcVar5 = remove_space(p);
      p_Var6 = Strnew_charp(pcVar5);
      p_Var6 = wc_Str_conv_strict(p_Var6,wVar2,wVar1);
      pcVar5 = url_quote(p_Var6->ptr);
      body->url = pcVar5;
    }
    iVar4 = parsedtag_get_value(tag,0x19,&p);
    wVar2 = InnerCharset;
    if ((iVar4 != 0) && (*p != '_')) {
      wVar1 = buf->document_charset;
      p_Var6 = Strnew_charp(p);
      p_Var6 = wc_Str_conv_strict(p_Var6,wVar2,wVar1);
      pcVar5 = url_quote(p_Var6->ptr);
      body->name = pcVar5;
    }
  }
  return body;
}



void unloadFrame(frame_body *b)

{
  b->attr = '\0';
  return;
}



void deleteFrame(frame_body *b)

{
  if (b != (frame_body *)0x0) {
    unloadFrame(b);
    bzero(b,0x24);
  }
  return;
}



void addFrameSetElement(frameset *f,undefined4 element)

{
  int iVar1;
  int iVar2;
  int i;
  
  if ((f != (frameset *)0x0) &&
     (iVar1 = f->i, iVar2 = f->row * f->col, iVar2 - iVar1 != 0 && iVar1 <= iVar2)) {
    f->frame[iVar1] = element;
    f->i = f->i + 1;
  }
  return;
}



void deleteFrameSet(frameset *f)

{
  int iVar1;
  int i;
  
  if (f != (frameset *)0x0) {
    for (i = 0; iVar1 = f->row * f->col, iVar1 - i != 0 && i <= iVar1; i = i + 1) {
      deleteFrameSetElement(f->frame[i]);
    }
    f->name = (char *)0x0;
    f->currentURL = (ParsedURL *)0x0;
  }
  return;
}



void deleteFrameSetElement(frameset *e)

{
  if (e != (frameset *)0x0) {
    if (e->attr == '\x01') {
      deleteFrame((frame_body *)e);
    }
    else if (e->attr == '\x02') {
      deleteFrameSet(e);
    }
  }
  return;
}



frame_body * copyFrame(frame_body *ob)

{
  frame_body *__dest;
  frame_body *rb;
  
  __dest = (frame_body *)GC_malloc(0x24);
  bcopy(ob,__dest,0x24);
  return __dest;
}



frameset * copyFrameSet(frameset *of)

{
  char cVar1;
  frameset *__dest;
  char **ppcVar2;
  frameset_element *pfVar3;
  frame_body *pfVar4;
  frameset *pfVar5;
  int n;
  frameset *rf;
  
  __dest = (frameset *)GC_malloc(0x24);
  n = of->row * of->col;
  bcopy(of,__dest,0x24);
  ppcVar2 = (char **)GC_malloc(__dest->col << 2);
  __dest->width = ppcVar2;
  bcopy(of->width,__dest->width,__dest->col * 4);
  ppcVar2 = (char **)GC_malloc(__dest->row << 2);
  __dest->height = ppcVar2;
  bcopy(of->height,__dest->height,__dest->row * 4);
  pfVar3 = (frameset_element *)GC_malloc(n * 4);
  __dest->frame = pfVar3;
  do {
    while( true ) {
      if (n == 0) {
        return __dest;
      }
      n = n + -1;
      if ((of->frame[n] != 0) && (cVar1 = *(char *)of->frame[n], -1 < cVar1)) break;
attr_default:
      __dest->frame[n] = 0;
    }
    if (cVar1 < '\x02') {
      pfVar3 = __dest->frame;
      pfVar4 = copyFrame((frame_body *)of->frame[n]);
      pfVar3[n] = pfVar4;
    }
    else {
      if (cVar1 != '\x02') goto attr_default;
      pfVar3 = __dest->frame;
      pfVar5 = copyFrameSet((frameset *)of->frame[n]);
      pfVar3[n] = pfVar5;
    }
  } while( true );
}



void flushFrameSet(frameset *fs)

{
  char cVar1;
  int n;
  
  n = fs->i;
  while (n != 0) {
    n = n + -1;
    if ((fs->frame[n] != 0) && (cVar1 = *(char *)fs->frame[n], -1 < cVar1)) {
      if (cVar1 < '\x02') {
        *(undefined4 *)(fs->frame[n] + 0x1c) = 0;
      }
      else if (cVar1 == '\x02') {
        flushFrameSet((frameset *)fs->frame[n]);
      }
    }
  }
  return;
}



void pushFrameTree(frameset_queue **fqpp,frameset *fs,Buffer *buf)

{
  frameset_queue *pfVar1;
  frameset_queue *pfVar2;
  long lVar3;
  int iVar4;
  _anchorList *p_Var5;
  frameset_queue *cfq;
  frameset_queue *rfq;
  
  pfVar1 = *fqpp;
  if (fs != (frameset *)0x0) {
    pfVar2 = (frameset_queue *)GC_malloc(0x20);
    if ((buf == (Buffer *)0x0) || (buf->currentLine == (Line *)0x0)) {
      lVar3 = 1;
    }
    else {
      lVar3 = buf->currentLine->linenumber;
    }
    pfVar2->linenumber = lVar3;
    if ((buf == (Buffer *)0x0) || (buf->topLine == (Line *)0x0)) {
      lVar3 = 1;
    }
    else {
      lVar3 = buf->topLine->linenumber;
    }
    pfVar2->top_linenumber = lVar3;
    if (buf == (Buffer *)0x0) {
      iVar4 = 0;
    }
    else {
      iVar4 = buf->pos;
    }
    pfVar2->pos = iVar4;
    if (buf == (Buffer *)0x0) {
      iVar4 = 0;
    }
    else {
      iVar4 = buf->currentColumn;
    }
    pfVar2->currentColumn = iVar4;
    if (buf == (Buffer *)0x0) {
      p_Var5 = (_anchorList *)0x0;
    }
    else {
      p_Var5 = buf->formitem;
    }
    pfVar2->formitem = p_Var5;
    pfVar2->back = pfVar1;
    if (pfVar1 == (frameset_queue *)0x0) {
      pfVar2->next = (frameset_queue *)0x0;
    }
    else {
      pfVar2->next = pfVar1->next;
      if (pfVar1->next != (frameset_queue *)0x0) {
        pfVar1->next->back = pfVar2;
      }
      pfVar1->next = pfVar2;
    }
    pfVar2->frameset = fs;
    *fqpp = pfVar2;
  }
  return;
}



frameset * popFrameTree(frameset_queue **fqpp)

{
  frameset_queue *__s;
  frameset *pfVar1;
  frameset *rfs;
  frameset_queue *cfq;
  frameset_queue *rfq;
  
  rfq = (frameset_queue *)0x0;
  __s = *fqpp;
  if (__s == (frameset_queue *)0x0) {
    pfVar1 = (frameset *)0x0;
  }
  else {
    pfVar1 = __s->frameset;
    if (__s->next != (frameset_queue *)0x0) {
      rfq = __s->next;
      rfq->back = __s->back;
    }
    if (__s->back != (frameset_queue *)0x0) {
      rfq = __s->back;
      rfq->next = __s->next;
    }
    *fqpp = rfq;
    bzero(__s,0x20);
  }
  return pfVar1;
}



void resetFrameElement(frameset_element *f_element,Buffer *buf,char *referer,FormList *request)

{
  char *pcVar1;
  int iVar2;
  undefined4 uVar3;
  frameset *pfVar4;
  frame_body *pfVar5;
  Str p_Var6;
  frame_body *f_body;
  char *f_name;
  
  pcVar1 = *(char **)(*f_element + 4);
  if (buf->frameset == (frameset *)0x0) {
    pfVar5 = newFrame((parsed_tag *)0x0,buf);
    pfVar5->attr = '\x01';
    pfVar5->name = pcVar1;
    p_Var6 = parsedURL2Str(&buf->currentURL);
    pfVar5->url = p_Var6->ptr;
    pfVar5->source = buf->sourcefile;
    buf->sourcefile = (char *)0x0;
    if (buf->mailcap_source != (char *)0x0) {
      pfVar5->source = buf->mailcap_source;
      buf->mailcap_source = (char *)0x0;
    }
    pfVar5->type = buf->type;
    pfVar5->referer = referer;
    pfVar5->request = request;
    deleteFrameSetElement(*f_element);
    *f_element = pfVar5;
  }
  else {
    deleteFrameSetElement(*f_element);
    *f_element = buf->frameset;
    iVar2 = *f_element;
    uVar3 = GC_malloc(0x28);
    *(undefined4 *)(iVar2 + 8) = uVar3;
    copyParsedURL(*(ParsedURL **)(*f_element + 8),&buf->currentURL);
    pfVar4 = popFrameTree(&buf->frameQ);
    buf->frameset = pfVar4;
    *(char **)(*f_element + 4) = pcVar1;
  }
  return;
}



frameset * frame_download_source(frame_body *b,ParsedURL *currentURL,ParsedURL *baseURL,int flag)

{
  Buffer *buf_00;
  Str p_Var1;
  ParsedURL *pPVar2;
  frameset *pfVar3;
  ParsedURL url;
  frameset *ret_frameset;
  Buffer *buf;
  
  ret_frameset = (frameset *)0x0;
  if (((b == (frame_body *)0x0) || (b->url == (char *)0x0)) || (*b->url == '\0')) {
    ret_frameset = (frameset *)0x0;
  }
  else {
    if (b->baseURL != (ParsedURL *)0x0) {
      baseURL = b->baseURL;
    }
    parseURL2(b->url,&url,currentURL);
    if (url.scheme == 4) {
      b->flags = '\0';
    }
    is_redisplay = 1;
    w3m_dump = w3m_dump | 0x20;
    if (baseURL != (ParsedURL *)0x0) {
      currentURL = baseURL;
    }
    buf_00 = loadGeneralFile(b->url,currentURL,b->referer,flag | 4,b->request);
    w3m_dump = w3m_dump & 0xffffffdf;
    is_redisplay = 0;
    if ((buf_00 == (Buffer *)0x0) || (buf_00 == (Buffer *)0x1)) {
      b->source = (char *)0x0;
      b->flags = buf_00 == (Buffer *)0x1;
      ret_frameset = (frameset *)0x0;
    }
    else {
      p_Var1 = parsedURL2Str(&buf_00->currentURL);
      b->url = p_Var1->ptr;
      b->type = buf_00->type;
      b->source = buf_00->sourcefile;
      buf_00->sourcefile = (char *)0x0;
      if (buf_00->mailcap_source != (char *)0x0) {
        b->source = buf_00->mailcap_source;
        buf_00->mailcap_source = (char *)0x0;
      }
      b->attr = '\x01';
      if (buf_00->frameset != (frameset *)0x0) {
        ret_frameset = buf_00->frameset;
        ret_frameset->name = b->name;
        pPVar2 = (ParsedURL *)GC_malloc(0x28);
        ret_frameset->currentURL = pPVar2;
        copyParsedURL(ret_frameset->currentURL,&buf_00->currentURL);
        pfVar3 = popFrameTree(&buf_00->frameQ);
        buf_00->frameset = pfVar3;
      }
      discardBuffer(buf_00);
    }
  }
  return ret_frameset;
}



int createFrameFile(frameset *f,FILE *f1,Buffer *current,int level,int force_reload)

{
  char **ppcVar1;
  char cVar2;
  frameset *pfVar3;
  wc_ces wVar4;
  int iVar5;
  char *pcVar6;
  Str p_Var7;
  wc_ces wVar8;
  uint uVar9;
  bool bVar10;
  ParsedURL url;
  ParsedURL base;
  URLFile f2;
  wc_ces c_1;
  int refresh_interval;
  Str s_tmp;
  int a_target;
  int j;
  char *q_1;
  Str tmp_1;
  parsed_tag *tag;
  char *q;
  int is_tag;
  Str tmp;
  int end_tag;
  int pre_mode;
  Str tok;
  int status;
  char *p;
  int i;
  frameset *f_frameset;
  frameset *frame;
  int flag;
  anon_subr_void_int *prevtrap;
  ParsedURL *currentURL;
  char *t_target;
  char *s_target;
  char *p_target;
  char *d_target;
  wc_ces doc_charset;
  wc_ces charset;
  int t_stack;
  int c;
  int r;
  
  prevtrap = (anon_subr_void_int *)0x0;
  if (f == (frameset *)0x0) {
    iVar5 = -1;
  }
  else {
    if (level == 0) {
      iVar5 = __sigsetjmp(AbortLoading,1);
      if (iVar5 != 0) {
        if (TrapSignal != '\0') {
          if (fmInitialized != '\0') {
            term_raw();
          }
          if (prevtrap != (anon_subr_void_int *)0x0) {
            mySignal(2,prevtrap);
          }
        }
        return -1;
      }
      if ((TrapSignal != '\0') && (prevtrap = mySignal(2,KeyAbort), fmInitialized != '\0')) {
        term_cbreak();
      }
      f->name = "_top";
    }
    if (level < 8) {
      if (level == 0) {
        pcVar6 = html_quote(current->buffername);
        fprintf((FILE *)f1,"<html><head><title>%s</title></head><body>\n",pcVar6);
        fwrite("<table hborder width=\"100%\">\n",1,0x1d,(FILE *)f1);
      }
      else {
        fwrite("<table hborder>\n",1,0x10,(FILE *)f1);
      }
      if (f->currentURL == (ParsedURL *)0x0) {
        currentURL = &current->currentURL;
      }
      else {
        currentURL = f->currentURL;
      }
      for (r = 0; r < f->row; r = r + 1) {
        fwrite("<tr valign=top>\n",1,0x10,(FILE *)f1);
        for (c = 0; c < f->col; c = c + 1) {
          i = f->col * r + c;
          p = "";
          status = 0;
          tok = Strnew();
          pre_mode = 0;
          end_tag = 0;
          frame = (frameset *)f->frame[i];
          if (frame == (frameset *)0x0) {
            fwrite("<td>\n</td>\n",1,0xb,(FILE *)f1);
          }
          else {
            fwrite(&DAT_080cc0d5,1,3,(FILE *)f1);
            if (frame->name != (char *)0x0) {
              pcVar6 = html_quote(frame->name);
              fprintf((FILE *)f1," id=\"_%s\"",pcVar6);
            }
            if (r == 0) {
              fprintf((FILE *)f1," width=\"%s\"",f->width[c]);
            }
            fwrite(&DAT_080cc0ef,1,2,(FILE *)f1);
            flag = 0;
            if ((force_reload != 0) && (flag = 1, frame->attr == '\x01')) {
              unloadFrame((frame_body *)frame);
            }
            pfVar3 = frame;
            cVar2 = frame->attr;
            if (cVar2 == '\x01') {
LAB_08090c14:
              init_stream(&f2,4,(InputStream)0x0);
              if (frame->height != (char **)0x0) {
                fflush((FILE *)f1);
                examineFile((char *)frame->height,&f2);
              }
              if (f2.stream == (InputStream)0x0) {
                frame->attr = '\0';
                if ((frame->dummy & 1U) == 0) {
                  if (frame->currentURL == (ParsedURL *)0x0) {
                    if (frame->name == (char *)0x0) {
                      pcVar6 = "(no name)";
                    }
                    else {
                      pcVar6 = html_quote(frame->name);
                    }
                    fprintf((FILE *)f1,"This frame (%s) contains no src attribute",pcVar6);
                  }
                  else {
                    pcVar6 = html_quote((char *)frame->currentURL);
                    fprintf((FILE *)f1,"Can\'t open %s",pcVar6);
                  }
                }
                else {
                  pcVar6 = html_quote((char *)frame->currentURL);
                  fprintf((FILE *)f1,"Open %s with other method",pcVar6);
                }
              }
              else {
                parseURL2((char *)frame->currentURL,&base,currentURL);
                p_target = f->name;
                s_target = frame->name;
                t_target = "_blank";
                d_target = s_target;
                if (TargetSelf == '\0') {
                  d_target = "_blank";
                }
                charset = 0x100;
                if (current->document_charset == 0x100) {
                  doc_charset = DocumentCharset;
                }
                else {
                  doc_charset = current->document_charset;
                }
                t_stack = 0;
                if ((frame->col == 0) ||
                   (iVar5 = strcasecmp((char *)frame->col,"text/plain"), iVar5 != 0)) {
                  do {
                    is_tag = 0;
                    do {
                      if (*p == '\0') {
                        tmp_1 = StrmyISgets(f2.stream);
                        if (tmp_1->length == 0) break;
                        tmp_1 = convertLine((URLFile *)0x0,tmp_1,2,&charset,doc_charset);
                        p = tmp_1->ptr;
                      }
                      read_token(tok,&p,&status,1,(uint)(status != 0));
                    } while (status != 0);
                    if (tok->length == 0) goto LAB_08091c5a;
                    if (*tok->ptr == '<') {
                      if ((tok->ptr[1] == '\0') ||
                         ((((((MYCTYPE_MAP[(byte)tok->ptr[1]] & 4) == 0 && (tok->ptr[1] != '/')) &&
                            (tok->ptr[1] != '!')) && ((tok->ptr[1] != '?' && (tok->ptr[1] != '\0')))
                           ) && (tok->ptr[1] != '_')))) {
                        if ((pre_mode & 0x80eU) == 0) {
                          p_Var7 = Strnew_m_charp(tok->ptr + 1,p,0);
                          p = p_Var7->ptr;
                          tok = Strnew_charp("&lt;");
                        }
                      }
                      else {
                        is_tag = 1;
                      }
                    }
                    if (is_tag != 0) {
                      if ((pre_mode & 0x80eU) == 0) {
                        if ((pre_mode & 0x1000U) != 0) {
                          q = tok->ptr;
                          tag = parse_tag(&q,0);
                          if (tag != (parsed_tag *)0x0) {
                            if (((uint)tag->tagid == end_tag) || (tag->tagid == '+')) {
                              if (tag->tagid == '+') {
                                fwrite("</SELECT>",1,9,(FILE *)f1);
                              }
                              pre_mode = 0;
                              end_tag = 0;
                            }
                            else if (t_stack != 0) {
                              switch(tag->tagid) {
                              case '\x1f':
                              case ' ':
                              case 'J':
                              case 'K':
                              case 'L':
                              case 'M':
                              case 'P':
                              case 'Q':
                              case 'R':
                              case 'S':
                              case 'T':
                              case 'U':
                              case 'V':
                              case 'W':
                              case 'X':
                              case 'Y':
                              case 'Z':
                                fwrite("</SELECT>",1,9,(FILE *)f1);
                                pre_mode = 0;
                                end_tag = 0;
                              }
                            }
                          }
                        }
                        goto proc_normal;
                      }
                      q = tok->ptr;
                      tag = parse_tag(&q,0);
                      if ((tag == (parsed_tag *)0x0) || ((uint)tag->tagid != end_tag)) {
                        iVar5 = strncmp(tok->ptr,"<!--",4);
                        if ((iVar5 != 0) && (q = strchr(tok->ptr + 1,0x3c), q != (char *)0x0)) {
                          tok = Strnew_charp_n(tok->ptr,(int)q - (int)tok->ptr);
                          p_Var7 = Strnew_m_charp(q,p,0);
                          p = p_Var7->ptr;
                          status = 0;
                        }
                        is_tag = 0;
                        goto proc_normal;
                      }
                      if ((pre_mode & 8U) == 0) {
                        pre_mode = 0;
                        end_tag = 0;
                        goto proc_normal;
                      }
                      fwrite("</PRE_PLAIN>",1,0xc,(FILE *)f1);
                      pre_mode = 0;
                      end_tag = 0;
                      goto token_end;
                    }
proc_normal:
                    if (is_tag == 0) {
                      if ((pre_mode & 8U) == 0) {
                        if ((pre_mode & 0x800U) == 0) {
                          fwrite(tok->ptr,1,tok->length,(FILE *)f1);
                        }
                        else {
                          pcVar6 = html_unquote(tok->ptr);
                          pcVar6 = html_quote(pcVar6);
                          fputs(pcVar6,(FILE *)f1);
                        }
                      }
                      else {
                        pcVar6 = html_quote(tok->ptr);
                        fputs(pcVar6,(FILE *)f1);
                      }
                      goto token_end;
                    }
                    q_1 = tok->ptr;
                    a_target = 0;
                    tag = parse_tag(&q_1,0);
                    if (tag == (parsed_tag *)0x0) goto token_end;
                    switch(tag->tagid) {
                    case '\x0e':
                      fwrite("<!-- title:",1,0xb,(FILE *)f1);
                      break;
                    case '\x0f':
                      fwrite(&DAT_080cc1d0,1,3,(FILE *)f1);
                      break;
                    default:
                      goto switchD_08091292_caseD_10;
                    case '\x1a':
                      pre_mode = 8;
                      end_tag = 0x1b;
                      fwrite("<PRE_PLAIN>",1,0xb,(FILE *)f1);
                      break;
                    case '\x1c':
                      pre_mode = 8;
                      end_tag = 0x1d;
                      fwrite("<PRE_PLAIN>",1,0xb,(FILE *)f1);
                      break;
                    case '\x1e':
                      pre_mode = 8;
                      end_tag = 0x91;
                      fwrite("<PRE_PLAIN>",1,0xb,(FILE *)f1);
                      break;
                    case '\x1f':
                      t_stack = t_stack + 1;
                      goto switchD_08091292_caseD_10;
                    case ' ':
                      t_stack = t_stack + -1;
                      if (-1 < t_stack) goto switchD_08091292_caseD_10;
                      t_stack = 0;
                      Strdelete(tok,0,1);
                      Strshrink(tok,1);
                      pcVar6 = html_quote(tok->ptr);
                      fprintf((FILE *)f1,"<!-- table stack underflow: %s -->",pcVar6);
                      break;
                    case '!':
                      iVar5 = parsedtag_get_value(tag,0x13,&q_1);
                      if (((iVar5 != 0) && (iVar5 = strcasecmp(q_1,"refresh"), iVar5 == 0)) &&
                         (iVar5 = parsedtag_get_value(tag,0xf,&q_1), iVar5 != 0)) {
                        s_tmp = (Str)0x0;
                        iVar5 = getMetaRefreshParam(q_1,&s_tmp);
                        if (s_tmp != (Str)0x0) {
                          q_1 = html_quote(s_tmp->ptr);
                          fprintf((FILE *)f1,"Refresh (%d sec) <a href=\"%s\">%s</a>\n",iVar5,q_1,
                                  q_1);
                        }
                      }
                      if (((UseContentCharset != '\0') &&
                          (iVar5 = parsedtag_get_value(tag,0x13,&q_1), iVar5 != 0)) &&
                         ((iVar5 = strcasecmp(q_1,"Content-Type"), iVar5 == 0 &&
                          ((iVar5 = parsedtag_get_value(tag,0xf,&q_1), iVar5 != 0 &&
                           (q_1 = strcasestr(q_1,"charset"), q_1 != (char *)0x0)))))) {
                        q_1 = q_1 + 7;
                        while ((*q_1 != '\0' && ((MYCTYPE_MAP[(byte)*q_1] & 2) != 0))) {
                          q_1 = q_1 + 1;
                        }
                        if (*q_1 == '=') {
                          do {
                            q_1 = q_1 + 1;
                            if (*q_1 == '\0') break;
                          } while ((MYCTYPE_MAP[(byte)*q_1] & 2) != 0);
                          wVar8 = wc_guess_charset(q_1,0);
                          if (wVar8 != 0) {
                            charset = 0x100;
                            doc_charset = wVar8;
                          }
                        }
                      }
                    case 'H':
                    case 'I':
                    case '_':
                    case '`':
                    case 'a':
                      Strdelete(tok,0,1);
                      Strshrink(tok,1);
                      pcVar6 = html_quote(tok->ptr);
                      fprintf((FILE *)f1,"<!-- %s -->",pcVar6);
                      break;
                    case '-':
                      pre_mode = 0x800;
                      end_tag = 0x2e;
                      goto switchD_08091292_caseD_10;
                    case '/':
                      pre_mode = 0x1000;
                      end_tag = 0x30;
                      goto switchD_08091292_caseD_10;
                    case ':':
                      pre_mode = 2;
                      end_tag = 0x3b;
                      goto switchD_08091292_caseD_10;
                    case '<':
                      iVar5 = parsedtag_get_value(tag,0x12,&q_1);
                      wVar4 = charset;
                      wVar8 = InnerCharset;
                      if (iVar5 != 0) {
                        pcVar6 = remove_space(q_1);
                        p_Var7 = Strnew_charp(pcVar6);
                        p_Var7 = wc_Str_conv_strict(p_Var7,wVar8,wVar4);
                        q_1 = url_quote(p_Var7->ptr);
                        parseURL(q_1,&base,(ParsedURL *)0x0);
                      }
                      iVar5 = parsedtag_get_value(tag,0x20,&q_1);
                      if (iVar5 != 0) {
                        iVar5 = strcasecmp(q_1,"_self");
                        if (iVar5 == 0) {
                          d_target = s_target;
                        }
                        else {
                          iVar5 = strcasecmp(q_1,"_parent");
                          wVar4 = charset;
                          wVar8 = InnerCharset;
                          if (iVar5 == 0) {
                            d_target = p_target;
                          }
                          else {
                            p_Var7 = Strnew_charp(q_1);
                            p_Var7 = wc_Str_conv_strict(p_Var7,wVar8,wVar4);
                            d_target = url_quote(p_Var7->ptr);
                          }
                        }
                      }
                      Strdelete(tok,0,1);
                      Strshrink(tok,1);
                      pcVar6 = html_quote(tok->ptr);
                      fprintf((FILE *)f1,"<!-- %s -->",pcVar6);
                      break;
                    case 'C':
                      pre_mode = 4;
                      end_tag = 0x44;
switchD_08091292_caseD_10:
                      for (j = 0; wVar4 = charset, wVar8 = InnerCharset,
                          j < (int)(uint)TagMAP[tag->tagid].max_attribute; j = j + 1) {
                        uVar9 = tag->attrid[j] - 3;
                        if (uVar9 < 0x1e) {
                          uVar9 = 1 << ((byte)uVar9 & 0x1f);
                          if ((uVar9 & 0x10008001) == 0) {
                            if ((uVar9 & 0x420000) == 0) {
                              if (((uVar9 & 0x20000000) != 0) && (tag->value[j] != (char *)0x0)) {
                                a_target = a_target | 2;
                                iVar5 = strcasecmp(tag->value[j],"_self");
                                if (iVar5 == 0) {
                                  parsedtag_set_value(tag,0x20,s_target);
                                }
                                else {
                                  iVar5 = strcasecmp(tag->value[j],"_parent");
                                  if (iVar5 == 0) {
                                    parsedtag_set_value(tag,0x20,p_target);
                                  }
                                }
                              }
                            }
                            else if (tag->value[j] != (char *)0x0) {
                              parsedtag_set_value(tag,0x43,s_target);
                            }
                          }
                          else if (tag->value[j] != (char *)0x0) {
                            ppcVar1 = tag->value + j;
                            pcVar6 = remove_space(tag->value[j]);
                            p_Var7 = Strnew_charp(pcVar6);
                            p_Var7 = wc_Str_conv_strict(p_Var7,wVar8,wVar4);
                            pcVar6 = url_quote(p_Var7->ptr);
                            *ppcVar1 = pcVar6;
                            tag->need_reconstruct = '\x01';
                            parseURL2(tag->value[j],&url,&base);
                            if ((url.scheme != 0xff) && (url.scheme != 0xfe)) {
                              a_target = a_target | 1;
                              ppcVar1 = tag->value + j;
                              p_Var7 = parsedURL2Str(&url);
                              *ppcVar1 = p_Var7->ptr;
                              p_Var7 = parsedURL2Str(&base);
                              parsedtag_set_value(tag,0x47,p_Var7->ptr);
                              if ((tag->attrid[j] == '\x03') && (charset != 0x100)) {
                                pcVar6 = wc_ces_to_charset(charset);
                                parsedtag_set_value(tag,0xb,pcVar6);
                              }
                            }
                          }
                        }
                      }
                      if (a_target == 1) {
                        parsedtag_set_value(tag,0x20,d_target);
                      }
                      if (tag->need_reconstruct != '\0') {
                        tok = parsedtag2str(tag);
                      }
                      fwrite(tok->ptr,1,tok->length,(FILE *)f1);
                      break;
                    case 'J':
                    case 'K':
                    case 'L':
                    case 'M':
                    case 'P':
                    case 'Q':
                    case 'R':
                    case 'S':
                    case 'T':
                    case 'U':
                    case 'V':
                    case 'W':
                    case 'X':
                    case 'Y':
                    case 'Z':
                      if (t_stack != 0) goto switchD_08091292_caseD_10;
                      Strdelete(tok,0,1);
                      Strshrink(tok,1);
                      pcVar6 = html_quote(tok->ptr);
                      fprintf((FILE *)f1,"<!-- %s -->",pcVar6);
                    }
token_end:
                    Strclear(tok);
LAB_08091c5a:
                  } while ((*p != '\0') || ((f2.stream)->field_0x15 == '\0'));
                  if ((pre_mode & 8U) == 0) {
                    if ((pre_mode & 0x800U) == 0) {
                      if ((pre_mode & 0x1000U) == 0) {
                        if ((pre_mode & 6U) != 0) {
                          if (status != 0) {
                            p_Var7 = correct_irrtag(status);
                            fputs(p_Var7->ptr,(FILE *)f1);
                          }
                          if ((pre_mode & 2U) == 0) {
                            if ((pre_mode & 4U) != 0) {
                              fwrite("</STYLE>\n",1,9,(FILE *)f1);
                            }
                          }
                          else {
                            fwrite("</SCRIPT>\n",1,10,(FILE *)f1);
                          }
                        }
                      }
                      else {
                        fwrite("</SELECT></FORM>\n",1,0x11,(FILE *)f1);
                      }
                    }
                    else {
                      fwrite("</TEXTAREA></FORM>\n",1,0x13,(FILE *)f1);
                    }
                  }
                  else {
                    fwrite("</PRE_PLAIN>\n",1,0xd,(FILE *)f1);
                  }
                  while (bVar10 = t_stack != 0, t_stack = t_stack + -1, bVar10) {
                    fwrite("</TABLE>\n",1,9,(FILE *)f1);
                  }
                  iVar5 = ISclose(f2.stream);
                  if (iVar5 == 0) {
                    f2.stream = (InputStream)0x0;
                  }
                }
                else {
                  fwrite("<pre>\n",1,6,(FILE *)f1);
                  while (tmp = StrmyISgets(f2.stream), tmp->length != 0) {
                    tmp = convertLine((URLFile *)0x0,tmp,2,&charset,doc_charset);
                    pcVar6 = html_quote(tmp->ptr);
                    fputs(pcVar6,(FILE *)f1);
                  }
                  fwrite("</pre>\n",1,7,(FILE *)f1);
                  iVar5 = ISclose(f2.stream);
                  if (iVar5 == 0) {
                    f2.stream = (InputStream)0x0;
                  }
                }
              }
            }
            else {
              if (cVar2 != '\x02') {
                if (cVar2 != '\0') {
                  iVar5 = i + 1;
                  pcVar6 = html_quote(f->name);
                  fprintf((FILE *)f1,"Frameset \"%s\" frame %d: type unrecognized",pcVar6,iVar5);
                  goto LAB_08091e70;
                }
                if ((frame->name == (char *)0x0) && (f->name != (char *)0x0)) {
                  p_Var7 = Sprintf("%s_%d",f->name,i);
                  pfVar3->name = p_Var7->ptr;
                }
                fflush((FILE *)f1);
                f_frameset = frame_download_source
                                       ((frame_body *)frame,currentURL,current->baseURL,flag);
                if (f_frameset == (frameset *)0x0) goto LAB_08090c14;
                deleteFrame((frame_body *)frame);
                frame = f_frameset;
                f->frame[i] = f_frameset;
              }
              pfVar3 = frame;
              if ((frame->name == (char *)0x0) && (f->name != (char *)0x0)) {
                p_Var7 = Sprintf("%s_%d",f->name,i);
                pfVar3->name = p_Var7->ptr;
              }
              createFrameFile(frame,f1,current,level + 1,force_reload);
            }
LAB_08091e70:
            fwrite("</td>\n",1,6,(FILE *)f1);
          }
        }
        fwrite("</tr>\n",1,6,(FILE *)f1);
      }
      fwrite("</table>\n",1,9,(FILE *)f1);
      if ((level == 0) && (fwrite("</body></html>\n",1,0xf,(FILE *)f1), TrapSignal != '\0')) {
        if (fmInitialized != '\0') {
          term_raw();
        }
        if (prevtrap != (anon_subr_void_int *)0x0) {
          mySignal(2,prevtrap);
        }
      }
      iVar5 = 0;
    }
    else {
      fwrite("Too many frameset tasked.\n",1,0x1a,(FILE *)f1);
      iVar5 = -1;
    }
  }
  return iVar5;
}



Buffer * renderFrame(Buffer *Cbuf,int force_reload)

{
  wc_ces wVar1;
  Str p_Var2;
  FILE *__stream;
  int iVar3;
  Buffer *buf_00;
  wc_ces doc_charset;
  frameset *fset;
  int flag;
  Buffer *buf;
  FILE *f;
  Str tmp;
  
  wVar1 = DocumentCharset;
  p_Var2 = tmpfname(2,".html");
  __stream = fopen(p_Var2->ptr,"w");
  if (((__stream == (FILE *)0x0) || (Cbuf->frameset == (frameset *)0x0)) ||
     (iVar3 = createFrameFile(Cbuf->frameset,(FILE *)__stream,Cbuf,0,force_reload), iVar3 < 0)) {
    return (Buffer *)0x0;
  }
  fclose(__stream);
  flag = 2;
  if ((Cbuf->currentURL).is_nocache != 0) {
    flag = 3;
  }
  renderFrameSet = Cbuf->frameset;
  flushFrameSet(renderFrameSet);
  DocumentCharset = InnerCharset;
  buf_00 = loadGeneralFile(p_Var2->ptr,(ParsedURL *)0x0,(char *)0x0,flag,(FormList *)0x0);
  renderFrameSet = (frameset *)0x0;
  if ((buf_00 != (Buffer *)0x0) && (buf_00 != (Buffer *)0x1)) {
    DocumentCharset = wVar1;
    buf_00->sourcefile = p_Var2->ptr;
    buf_00->document_charset = Cbuf->document_charset;
    copyParsedURL(&buf_00->currentURL,&Cbuf->currentURL);
    preFormUpdateBuffer(buf_00);
    return buf_00;
  }
  DocumentCharset = wVar1;
  renderFrameSet = (frameset *)0x0;
  return (Buffer *)0x0;
}



frameset_element * search_frame(frameset *fset,char *name)

{
  frameset **ppfVar1;
  frameset_element *pfVar2;
  int iVar3;
  frameset_element *e;
  int i;
  
  i = 0;
  do {
    iVar3 = fset->row * fset->col;
    if (iVar3 - i == 0 || iVar3 < i) {
      return (frameset_element *)0x0;
    }
    ppfVar1 = (frameset **)(fset->frame + i);
    if (*ppfVar1 != (frameset *)0x0) {
      if (((*ppfVar1)->name != (char *)0x0) && (iVar3 = strcmp((*ppfVar1)->name,name), iVar3 == 0))
      {
        return ppfVar1;
      }
      if (((*ppfVar1)->attr == '\x02') &&
         (pfVar2 = search_frame(*ppfVar1,name), pfVar2 != (frameset_element *)0x0)) {
        return pfVar2;
      }
    }
    i = i + 1;
  } while( true );
}



int compare_table(rc_search_table *a,rc_search_table *b)

{
  int iVar1;
  
  iVar1 = strcmp(a->param->name,b->param->name);
  return iVar1;
}



void create_option_search_table(void)

{
  char *pcVar1;
  char *pcVar2;
  char *q;
  char *p;
  int diff2;
  int diff1;
  int k;
  int j;
  int i;
  
  RC_table_size = 0;
  for (j = 0; sections[j].name != (char *)0x0; j = j + 1) {
    for (i = 0; sections[j].params[i].name != (char *)0x0; i = i + 1) {
      RC_table_size = RC_table_size + 1;
    }
  }
  RC_search_table = (rc_search_table *)GC_malloc(RC_table_size << 3);
  k = 0;
  for (j = 0; sections[j].name != (char *)0x0; j = j + 1) {
    for (i = 0; sections[j].params[i].name != (char *)0x0; i = i + 1) {
      RC_search_table[k].param = sections[j].params + i;
      k = k + 1;
    }
  }
  qsort(RC_search_table,RC_table_size,8,compare_table);
  diff2 = 0;
  for (i = 0; i < RC_table_size + -1; i = i + 1) {
    pcVar1 = (RC_search_table[i].param)->name;
    pcVar2 = (RC_search_table[i + 1].param)->name;
    for (j = 0; ((pcVar1[j] != '\0' && (pcVar2[j] != '\0')) && (pcVar1[j] == pcVar2[j])); j = j + 1)
    {
    }
    if (diff2 < j) {
      RC_search_table[i].uniq_pos = (short)j + 1;
    }
    else {
      RC_search_table[i].uniq_pos = (short)diff2 + 1;
    }
    diff2 = j;
  }
  return;
}



param_ptr * search_param(char *name)

{
  size_t __n;
  int iVar1;
  int len;
  int cmp;
  size_t i;
  size_t e;
  size_t b;
  
  __n = strlen(name);
  b = 0;
  e = RC_table_size - 1;
  while( true ) {
    if (e < b) {
      return (param_ptr *)0x0;
    }
    i = b + e >> 1;
    iVar1 = strncmp(name,(RC_search_table[i].param)->name,__n);
    if (iVar1 == 0) break;
    if (iVar1 < 0) {
      if (i == 0) {
        return (param_ptr *)0x0;
      }
      e = i - 1;
    }
    else {
      b = i + 1;
    }
  }
  if ((int)RC_search_table[i].uniq_pos <= (int)__n) {
    return RC_search_table[i].param;
  }
  while( true ) {
    iVar1 = strcmp(name,(RC_search_table[i].param)->name);
    if (0 < iVar1) {
      return (param_ptr *)0x0;
    }
    if (iVar1 == 0) break;
    if (i == 0) {
      return (param_ptr *)0x0;
    }
    i = i - 1;
  }
  return RC_search_table[i].param;
}



void show_params(FILE *fp)

{
  wc_ces wVar1;
  wc_ces wVar2;
  char *pcVar3;
  Str p_Var4;
  size_t sVar5;
  size_t sVar6;
  char *cmt;
  char *t;
  int l;
  int j;
  int i;
  
  t = (char *)0x0;
  OptionCharset = SystemCharset;
  fwrite("\nconfiguration parameters\n",1,0x1a,(FILE *)fp);
  for (j = 0; wVar2 = OptionCharset, wVar1 = InnerCharset, sections[j].name != (char *)0x0;
      j = j + 1) {
    if (OptionEncode == 0) {
      pcVar3 = (char *)gettext(sections[j].name);
      p_Var4 = Strnew_charp(pcVar3);
      p_Var4 = wc_Str_conv(p_Var4,wVar2,wVar1);
      cmt = p_Var4->ptr;
    }
    else {
      cmt = sections[j].name;
    }
    wVar2 = SystemCharset;
    wVar1 = InnerCharset;
    p_Var4 = Strnew_charp(cmt);
    p_Var4 = wc_Str_conv_strict(p_Var4,wVar1,wVar2);
    fprintf((FILE *)fp,"  section[%d]: %s\n",j,p_Var4->ptr);
    for (i = 0; wVar2 = OptionCharset, wVar1 = InnerCharset,
        sections[j].params[i].name != (char *)0x0; i = i + 1) {
      switch(sections[j].params[i].type) {
      case 0:
      case 1:
      case 2:
      case 9:
        if (sections[j].params[i].inputtype == 1) {
          t = "bool";
        }
        else {
          t = "number";
        }
        break;
      case 3:
        t = "char";
        break;
      case 4:
        t = "string";
        break;
      case 6:
        t = "color";
        break;
      case 7:
        t = "charset";
        break;
      case 8:
        t = "number";
        break;
      case 10:
        t = "percent";
      }
      if (OptionEncode == 0) {
        pcVar3 = (char *)gettext(sections[j].params[i].comment);
        p_Var4 = Strnew_charp(pcVar3);
        p_Var4 = wc_Str_conv(p_Var4,wVar2,wVar1);
        cmt = p_Var4->ptr;
      }
      else {
        cmt = sections[j].params[i].comment;
      }
      sVar5 = strlen(sections[j].params[i].name);
      sVar6 = strlen(t);
      wVar2 = SystemCharset;
      wVar1 = InnerCharset;
      l = 0x1e - (sVar5 + sVar6);
      if (l < 0) {
        l = 1;
      }
      p_Var4 = Strnew_charp(cmt);
      p_Var4 = wc_Str_conv_strict(p_Var4,wVar1,wVar2);
      fprintf((FILE *)fp,"    -o %s=<%s>%*s%s\n",sections[j].params[i].name,t,l,&DAT_080cde7a,
              p_Var4->ptr);
    }
  }
  return;
}



int str_to_bool(char *value,int old)

{
  byte bVar1;
  uint uVar2;
  
  if (value == (char *)0x0) {
    uVar2 = 1;
  }
  else {
    if ((MYCTYPE_MAP[(byte)*value] & 4) == 0) {
      bVar1 = *value;
    }
    else {
      bVar1 = *value | 0x20;
    }
    switch(bVar1) {
    case 0x21:
    case 0x72:
    case 0x78:
      uVar2 = (uint)(old == 0);
      break;
    default:
      uVar2 = 1;
      break;
    case 0x30:
    case 0x66:
    case 0x6e:
    case 0x75:
      uVar2 = 0;
      break;
    case 0x6f:
      if ((MYCTYPE_MAP[(byte)value[1]] & 4) == 0) {
        bVar1 = value[1];
      }
      else {
        bVar1 = value[1] | 0x20;
      }
      if (bVar1 == 0x66) {
        uVar2 = 0;
      }
      else {
        uVar2 = 1;
      }
      break;
    case 0x74:
      if ((MYCTYPE_MAP[(byte)value[1]] & 4) == 0) {
        bVar1 = value[1];
      }
      else {
        bVar1 = value[1] | 0x20;
      }
      if (bVar1 == 0x6f) {
        uVar2 = (uint)(old == 0);
      }
      else {
        uVar2 = 1;
      }
    }
  }
  return uVar2;
}



int str_to_color(char *value)

{
  byte bVar1;
  int iVar2;
  
  if (value == (char *)0x0) {
    iVar2 = 8;
  }
  else {
    if ((MYCTYPE_MAP[(byte)*value] & 4) == 0) {
      bVar1 = *value;
    }
    else {
      bVar1 = *value | 0x20;
    }
    switch(bVar1) {
    case 0x30:
      iVar2 = 0;
      break;
    case 0x31:
    case 0x72:
      iVar2 = 1;
      break;
    case 0x32:
    case 0x67:
      iVar2 = 2;
      break;
    case 0x33:
    case 0x79:
      iVar2 = 3;
      break;
    case 0x34:
      iVar2 = 4;
      break;
    case 0x35:
    case 0x6d:
      iVar2 = 5;
      break;
    case 0x36:
    case 99:
      iVar2 = 6;
      break;
    case 0x37:
    case 0x77:
      iVar2 = 7;
      break;
    case 0x38:
    case 0x74:
      iVar2 = 8;
      break;
    default:
      iVar2 = 8;
      break;
    case 0x62:
      iVar2 = strncasecmp(value,"blu",3);
      if (iVar2 == 0) {
        iVar2 = 4;
      }
      else {
        iVar2 = 0;
      }
    }
  }
  return iVar2;
}



int set_param(char *name,char *value)

{
  int *piVar1;
  undefined2 *puVar2;
  undefined *puVar3;
  wc_ces *pwVar4;
  undefined uVar5;
  undefined2 uVar6;
  int iVar7;
  param_ptr *ppVar8;
  wc_ces wVar9;
  double dVar10;
  double ppc;
  param_ptr *p;
  
  if (value == (char *)0x0) {
    iVar7 = 0;
  }
  else {
    ppVar8 = search_param(name);
    if (ppVar8 == (param_ptr *)0x0) {
      iVar7 = 0;
    }
    else {
      switch(ppVar8->type) {
      case 0:
        iVar7 = atoi(value);
        if (-1 < iVar7) {
          piVar1 = (int *)ppVar8->varptr;
          if (ppVar8->inputtype == 1) {
                    // WARNING: Load size is inaccurate
            iVar7 = str_to_bool(value,*ppVar8->varptr);
          }
          else {
            iVar7 = atoi(value);
          }
          *piVar1 = iVar7;
        }
        break;
      case 1:
        puVar2 = (undefined2 *)ppVar8->varptr;
        if (ppVar8->inputtype == 1) {
                    // WARNING: Load size is inaccurate
          iVar7 = str_to_bool(value,(int)*ppVar8->varptr);
          uVar6 = (undefined2)iVar7;
        }
        else {
          iVar7 = atoi(value);
          uVar6 = (undefined2)iVar7;
        }
        *puVar2 = uVar6;
        break;
      case 2:
        puVar3 = (undefined *)ppVar8->varptr;
        if (ppVar8->inputtype == 1) {
                    // WARNING: Load size is inaccurate
          iVar7 = str_to_bool(value,(int)*ppVar8->varptr);
          uVar5 = (undefined)iVar7;
        }
        else {
          iVar7 = atoi(value);
          uVar5 = (undefined)iVar7;
        }
        *puVar3 = uVar5;
        break;
      case 3:
        *(char *)ppVar8->varptr = *value;
        break;
      case 4:
        *(char **)ppVar8->varptr = value;
        break;
      case 6:
        piVar1 = (int *)ppVar8->varptr;
        iVar7 = str_to_color(value);
        *piVar1 = iVar7;
        break;
      case 7:
        pwVar4 = (wc_ces *)ppVar8->varptr;
                    // WARNING: Load size is inaccurate
        wVar9 = wc_guess_charset_short(value,*ppVar8->varptr);
        *pwVar4 = wVar9;
        break;
      case 8:
        dVar10 = atof(value);
        if ((4.0 <= dVar10) && (dVar10 <= 64.0)) {
          *(double *)ppVar8->varptr = dVar10;
        }
        break;
      case 9:
        iVar7 = atoi(value);
        if (0 < iVar7) {
          piVar1 = (int *)ppVar8->varptr;
          iVar7 = atoi(value);
          *piVar1 = iVar7;
        }
        break;
      case 10:
        dVar10 = atof(value);
        if ((10.0 <= dVar10) && (dVar10 <= 1000.0)) {
          *(double *)ppVar8->varptr = dVar10;
        }
      }
      iVar7 = 1;
    }
  }
  return iVar7;
}



int set_param_option(char *option)

{
  char *__s1;
  Str x;
  int iVar1;
  char *q;
  char *p;
  Str tmp;
  
  x = Strnew();
  p = option;
  while (((*p != '\0' && ((MYCTYPE_MAP[(byte)*p] & 2) == 0)) && (*p != '='))) {
    if (x->area_size <= x->length + 1) {
      Strgrow(x);
    }
    iVar1 = x->length;
    x->ptr[iVar1] = *p;
    x->length = iVar1 + 1;
    p = p + 1;
    x->ptr[x->length] = '\0';
  }
  while ((*p != '\0' && ((MYCTYPE_MAP[(byte)*p] & 2) != 0))) {
    p = p + 1;
  }
  if (*p == '=') {
    do {
      p = p + 1;
      if (*p == '\0') break;
    } while ((MYCTYPE_MAP[(byte)*p] & 2) != 0);
  }
  Strlower(x);
  iVar1 = set_param(x->ptr,p);
  if (iVar1 == 0) {
    __s1 = x->ptr;
    iVar1 = strncmp(__s1,"no",2);
    if (iVar1 == 0) {
      q = __s1 + 2;
      if ((*q == '-') || (*q == '_')) {
        q = __s1 + 3;
      }
    }
    else {
      if (*x->ptr != '-') {
        return 0;
      }
      q = __s1 + 1;
    }
    iVar1 = set_param(q,"0");
    if (iVar1 == 0) {
      return 0;
    }
  }
  return 1;
}



char * get_param_option(char *name)

{
  param_ptr *p_00;
  Str p_Var1;
  char *pcVar2;
  param_ptr *p;
  
  p_00 = search_param(name);
  if (p_00 == (param_ptr *)0x0) {
    pcVar2 = (char *)0x0;
  }
  else {
    p_Var1 = to_str(p_00);
    pcVar2 = p_Var1->ptr;
  }
  return pcVar2;
}



void interpret_rc(FILE *f)

{
  int iVar1;
  Str s;
  Str x;
  char *p;
  Str tmp;
  Str line;
  
  while( true ) {
    s = Strfgets(f);
    Strchop(s);
    if (s->length == 0) break;
    Strremovefirstspaces(s);
    if (*s->ptr != '#') {
      x = Strnew();
      p = s->ptr;
      while ((*p != '\0' && ((MYCTYPE_MAP[(byte)*p] & 2) == 0))) {
        if (x->area_size <= x->length + 1) {
          Strgrow(x);
        }
        iVar1 = x->length;
        x->ptr[iVar1] = *p;
        x->length = iVar1 + 1;
        p = p + 1;
        x->ptr[x->length] = '\0';
      }
      while ((*p != '\0' && ((MYCTYPE_MAP[(byte)*p] & 2) != 0))) {
        p = p + 1;
      }
      Strlower(x);
      set_param(x->ptr,p);
    }
  }
  return;
}



void parse_proxy(void)

{
  int iVar1;
  
  iVar1 = non_null(HTTP_proxy);
  if (iVar1 != 0) {
    parseURL(HTTP_proxy,&HTTP_proxy_parsed,(ParsedURL *)0x0);
  }
  iVar1 = non_null(GOPHER_proxy);
  if (iVar1 != 0) {
    parseURL(GOPHER_proxy,&GOPHER_proxy_parsed,(ParsedURL *)0x0);
  }
  iVar1 = non_null(FTP_proxy);
  if (iVar1 != 0) {
    parseURL(FTP_proxy,&FTP_proxy_parsed,(ParsedURL *)0x0);
  }
  iVar1 = non_null(NO_proxy);
  if (iVar1 != 0) {
    NO_proxy_domains = make_domain_list(NO_proxy);
  }
  return;
}



void parse_cookie(void)

{
  int iVar1;
  
  iVar1 = non_null(cookie_reject_domains);
  if (iVar1 != 0) {
    Cookie_reject_domains = make_domain_list(cookie_reject_domains);
  }
  iVar1 = non_null(cookie_accept_domains);
  if (iVar1 != 0) {
    Cookie_accept_domains = make_domain_list(cookie_accept_domains);
  }
  return;
}



void sync_with_option(void)

{
  if (PagerMax < LINES) {
    PagerMax = LINES;
  }
  WrapSearch = WrapDefault;
  parse_proxy();
  parse_cookie();
  initMailcap();
  initMimeTypes();
  initURIMethods();
  init_migemo();
  if ((fmInitialized != '\0') && (displayImage != 0)) {
    initImage();
  }
  loadPasswd();
  loadPreForm();
  if ((AcceptLang == (char *)0x0) || (*AcceptLang == '\0')) {
    AcceptLang = (char *)gettext("en;q=1.0");
  }
  if ((AcceptEncoding == (char *)0x0) || (*AcceptEncoding == '\0')) {
    AcceptEncoding = acceptableEncoding();
  }
  if ((AcceptMedia == (char *)0x0) || (*AcceptMedia == '\0')) {
    AcceptMedia = acceptableMimeTypes();
  }
  if (fmInitialized != '\0') {
    initKeymap(0);
    initMouseAction();
    initMenu();
  }
  return;
}



void init_rc(void)

{
  size_t sVar1;
  int iVar2;
  int *piVar3;
  char *pcVar4;
  FILE *pFVar5;
  stat st;
  FILE *f;
  int i;
  
  if (rc_dir == (char *)0x0) {
    rc_dir = expandPath("~/.w3m");
    sVar1 = strlen(rc_dir);
    if ((1 < (int)sVar1) && (rc_dir[sVar1 - 1] == '/')) {
      rc_dir[sVar1 - 1] = '\0';
    }
    display_charset_str = wc_get_ces_list();
    document_charset_str = display_charset_str;
    system_charset_str = display_charset_str;
    iVar2 = stat(rc_dir,(stat *)&st);
    if (iVar2 < 0) {
      piVar3 = __errno_location();
      if (*piVar3 == 2) {
        iVar2 = mkdir(rc_dir,0x1c0);
        if (-1 < iVar2) {
          stat(rc_dir,(stat *)&st);
          goto LAB_08093233;
        }
        fprintf(stderr,"Can\'t create config directory (%s)!",rc_dir);
      }
      else {
        fprintf(stderr,"Can\'t open config directory (%s)!",rc_dir);
      }
    }
    else {
LAB_08093233:
      if ((st.st_mode & 0xf000) == 0x4000) {
        if ((st.st_mode & 0x80) != 0) {
          no_rc_dir = 0;
          tmp_dir = rc_dir;
          if (config_file == (char *)0x0) {
            config_file = rcFile("config");
          }
          create_option_search_table();
          goto open_rc;
        }
        fprintf(stderr,"%s is not writable!",rc_dir);
      }
      else {
        fprintf(stderr,"%s is not a directory!",rc_dir);
      }
    }
    no_rc_dir = 1;
    tmp_dir = getenv("TMPDIR");
    if ((tmp_dir == (char *)0x0) || (*tmp_dir == '\0')) {
      tmp_dir = getenv("TMP");
      if ((tmp_dir == (char *)0x0) || (*tmp_dir == '\0')) {
        tmp_dir = getenv("TEMP");
        if ((tmp_dir == (char *)0x0) || (*tmp_dir == '\0')) {
          tmp_dir = "/tmp";
        }
      }
    }
  }
  else {
open_rc:
    pcVar4 = etcFile("w3mconfig");
    pFVar5 = fopen(pcVar4,"rt");
    if (pFVar5 != (FILE *)0x0) {
      interpret_rc((FILE *)pFVar5);
      fclose(pFVar5);
    }
    pcVar4 = confFile("config");
    pFVar5 = fopen(pcVar4,"rt");
    if (pFVar5 != (FILE *)0x0) {
      interpret_rc((FILE *)pFVar5);
      fclose(pFVar5);
    }
    pFVar5 = fopen(config_file,"rt");
    if (pFVar5 != (FILE *)0x0) {
      interpret_rc((FILE *)pFVar5);
      fclose(pFVar5);
    }
  }
  return;
}



Str to_str(param_ptr *p)

{
  wc_ces t_ces;
  wc_ces f_ces;
  Str p_Var1;
  
  f_ces = SystemCharset;
  t_ces = InnerCharset;
  switch(p->type) {
  case 0:
  case 6:
  case 7:
                    // WARNING: Load size is inaccurate
    p_Var1 = Sprintf("%d",*p->varptr);
    break;
  case 1:
                    // WARNING: Load size is inaccurate
    p_Var1 = Sprintf("%d",(int)*p->varptr);
    break;
  case 2:
                    // WARNING: Load size is inaccurate
    p_Var1 = Sprintf("%d",(int)*p->varptr);
    break;
  case 3:
                    // WARNING: Load size is inaccurate
    p_Var1 = Sprintf("%c",(int)*p->varptr);
    break;
  case 4:
                    // WARNING: Load size is inaccurate
    p_Var1 = Strnew_charp(*p->varptr);
    p_Var1 = wc_Str_conv(p_Var1,f_ces,t_ces);
    p_Var1 = Strnew_charp(p_Var1->ptr);
    break;
  default:
    p_Var1 = (Str)0x0;
    break;
  case 8:
  case 10:
                    // WARNING: Load size is inaccurate
    p_Var1 = Sprintf("%g",*p->varptr);
    break;
  case 9:
                    // WARNING: Load size is inaccurate
    p_Var1 = Sprintf("%d",*p->varptr);
  }
  return p_Var1;
}



Buffer * load_option_panel(void)

{
  wc_ces wVar1;
  undefined4 uVar2;
  Str p_Var3;
  char *pcVar4;
  Str p_Var5;
  int iVar6;
  int iVar7;
  Str p_Var8;
  wc_ces wVar9;
  Buffer *pBVar10;
  char *pcVar11;
  Buffer *buf;
  Str tmp;
  int i;
  int x;
  wc_ces_list *c;
  sel_c *s;
  param_ptr *p;
  Str src;
  
  if (optionpanel_str == (Str)0x0) {
    uVar2 = gettext("External Viewer Setup");
    p_Var3 = localCookie();
    pcVar4 = html_quote(p_Var3->ptr);
    optionpanel_str = Sprintf(optionpanel_src1,w3m_version,pcVar4,uVar2);
  }
  OptionCharset = SystemCharset;
  if (OptionEncode == 0) {
    optionpanel_str = wc_Str_conv(optionpanel_str,SystemCharset,InnerCharset);
    for (i = 0; wVar9 = OptionCharset, wVar1 = InnerCharset, sections[i].name != (char *)0x0;
        i = i + 1) {
      pcVar4 = (char *)gettext(sections[i].name);
      p_Var3 = Strnew_charp(pcVar4);
      p_Var3 = wc_Str_conv(p_Var3,wVar9,wVar1);
      sections[i].name = p_Var3->ptr;
      for (p = sections[i].params; wVar9 = OptionCharset, wVar1 = InnerCharset,
          p->name != (char *)0x0; p = p + 1) {
        pcVar4 = (char *)gettext(p->comment);
        p_Var3 = Strnew_charp(pcVar4);
        p_Var3 = wc_Str_conv(p_Var3,wVar9,wVar1);
        p->comment = p_Var3->ptr;
        if ((p->inputtype == 2) && ((sel_c *)p->select != colorstr)) {
          for (s = (sel_c *)p->select; wVar9 = OptionCharset, wVar1 = InnerCharset,
              s->text != (char *)0x0; s = s + 1) {
            pcVar4 = (char *)gettext(s->text);
            p_Var3 = Strnew_charp(pcVar4);
            p_Var3 = wc_Str_conv(p_Var3,wVar9,wVar1);
            s->text = p_Var3->ptr;
          }
        }
      }
    }
    for (s = colorstr; wVar9 = OptionCharset, wVar1 = InnerCharset, s->text != (char *)0x0;
        s = s + 1) {
      pcVar4 = (char *)gettext(s->text);
      p_Var3 = Strnew_charp(pcVar4);
      p_Var3 = wc_Str_conv(p_Var3,wVar9,wVar1);
      s->text = p_Var3->ptr;
    }
    OptionEncode = 1;
  }
  p_Var3 = Strdup(optionpanel_str);
  Strcat_charp(p_Var3,"<table><tr><td>");
  for (i = 0; sections[i].name != (char *)0x0; i = i + 1) {
    pcVar4 = (char *)0x0;
    Strcat_m_charp(p_Var3,&DAT_080ce270,sections[i].name,"</h1>",0);
    p = sections[i].params;
    Strcat_charp(p_Var3,"<table width=100% cellpadding=0>");
    for (; p->name != (char *)0x0; p = p + 1) {
      Strcat_m_charp(p_Var3,"<tr><td>",p->comment,0,pcVar4);
      p_Var5 = Sprintf("</td><td width=%d>",(int)ROUND(pixel_per_char * 28.0));
      Strcat(p_Var3,p_Var5);
      iVar6 = p->inputtype;
      if (iVar6 == 1) {
        p_Var5 = to_str(p);
        iVar6 = atoi(p_Var5->ptr);
        if (iVar6 == 0) {
          pcVar11 = " checked";
        }
        else {
          pcVar11 = "";
        }
        if (iVar6 == 0) {
          pcVar4 = "";
        }
        else {
          pcVar4 = " checked";
        }
        Strcat_m_charp(p_Var3,"<input type=radio name=",p->name," value=1",pcVar4,
                       ">YES&nbsp;&nbsp;<input type=radio name=",p->name," value=0",pcVar11,
                       &DAT_080ce2e2,0);
      }
      else if (iVar6 < 2) {
        if (iVar6 == 0) {
          p_Var5 = to_str(p);
          pcVar4 = html_quote(p_Var5->ptr);
          Strcat_m_charp(p_Var3,"<input type=text name=",p->name," value=\"",pcVar4,&DAT_080ce2b5,0)
          ;
        }
      }
      else if (iVar6 == 2) {
        p_Var5 = to_str(p);
        pcVar4 = (char *)0x0;
        Strcat_m_charp(p_Var3,"<select name=",p->name,&DAT_080ce339,0);
        for (s = (sel_c *)p->select; s->text != (char *)0x0; s = s + 1) {
          Strcat_charp(p_Var3,"<option value=");
          p_Var8 = Sprintf("%s\n",s->cvalue);
          Strcat(p_Var3,p_Var8);
          if (((p->type != 3) && (iVar6 = s->value, iVar7 = atoi(p_Var5->ptr), iVar6 == iVar7)) ||
             ((p->type == 3 && ((char)s->value == *p_Var5->ptr)))) {
            Strcat_charp(p_Var3," selected");
          }
          if (p_Var3->area_size <= p_Var3->length + 1) {
            Strgrow(p_Var3);
          }
          iVar6 = p_Var3->length;
          p_Var3->ptr[iVar6] = '>';
          p_Var3->length = iVar6 + 1;
          p_Var3->ptr[p_Var3->length] = '\0';
          Strcat_charp(p_Var3,s->text);
        }
        Strcat_charp(p_Var3,"</select>");
      }
      else if (iVar6 == 3) {
        p_Var5 = to_str(p);
        pcVar4 = (char *)0x0;
        Strcat_m_charp(p_Var3,"<select name=",p->name,&DAT_080ce339,0);
                    // WARNING: Load size is inaccurate
        for (c = *p->select; c->desc != (char *)0x0; c = c + 1) {
          Strcat_charp(p_Var3,"<option value=");
          p_Var8 = Sprintf("%s\n",c->name);
          Strcat(p_Var3,p_Var8);
          wVar1 = c->id;
          wVar9 = atoi(p_Var5->ptr);
          if (wVar1 == wVar9) {
            Strcat_charp(p_Var3," selected");
          }
          if (p_Var3->area_size <= p_Var3->length + 1) {
            Strgrow(p_Var3);
          }
          iVar6 = p_Var3->length;
          p_Var3->ptr[iVar6] = '>';
          p_Var3->length = iVar6 + 1;
          p_Var3->ptr[p_Var3->length] = '\0';
          Strcat_charp(p_Var3,c->desc);
        }
        Strcat_charp(p_Var3,"</select>");
      }
      Strcat_charp(p_Var3,"</td></tr>\n");
    }
    Strcat_charp(p_Var3,"<tr><td></td><td><p><input type=submit value=\"OK\"></td></tr>");
    Strcat_charp(p_Var3,"</table><hr width=50%>");
  }
  Strcat_charp(p_Var3,"</table></form></body></html>");
  pBVar10 = loadHTMLString(p_Var3);
  if (pBVar10 != (Buffer *)0x0) {
    pBVar10->document_charset = OptionCharset;
  }
  return pBVar10;
}



void panel_set_option(parsed_tagarg *arg)

{
  char *value;
  wc_ces f_ces;
  wc_ces t_ces;
  Str p_Var1;
  int iVar2;
  char *p;
  FILE *f;
  
  f = (FILE *)0x0;
  if (no_rc_dir == 0) {
    f = (FILE *)fopen(config_file,"wt");
    if ((FILE *)f == (FILE *)0x0) {
      disp_message("Can\'t write option!",0);
    }
  }
  else {
    disp_message("There\'s no ~/.w3m directory... config not saved",0);
  }
  for (; t_ces = SystemCharset, f_ces = InnerCharset, arg != (parsed_tagarg *)0x0; arg = arg->next)
  {
    if (arg->value != (char *)0x0) {
      p_Var1 = Strnew_charp(arg->value);
      p_Var1 = wc_Str_conv_strict(p_Var1,f_ces,t_ces);
      value = p_Var1->ptr;
      iVar2 = set_param(arg->arg,value);
      if ((iVar2 != 0) && (f != (FILE *)0x0)) {
        fprintf((FILE *)f,"%s %s\n",arg->arg,value);
      }
    }
  }
  if (f != (FILE *)0x0) {
    fclose((FILE *)f);
  }
  sync_with_option();
  backBf();
  return;
}



char * rcFile(char *base)

{
  char *pcVar1;
  Str p_Var2;
  
  if ((base == (char *)0x0) ||
     (((*base != '/' &&
       ((*base != '.' || ((base[1] != '/' && ((base[1] != '.' || (base[2] != '/')))))))) &&
      ((*base != '~' || (base[1] != '/')))))) {
    p_Var2 = Strnew_m_charp(rc_dir,&DAT_080ce43e,base,0);
    pcVar1 = expandPath(p_Var2->ptr);
  }
  else {
    pcVar1 = expandPath(base);
  }
  return pcVar1;
}



char * auxbinFile(char *base)

{
  char *pcVar1;
  Str p_Var2;
  
  pcVar1 = w3m_auxbin_dir();
  p_Var2 = Strnew_m_charp(pcVar1,&DAT_080ce43e,base,0);
  pcVar1 = expandPath(p_Var2->ptr);
  return pcVar1;
}



char * etcFile(char *base)

{
  char *pcVar1;
  Str p_Var2;
  
  pcVar1 = w3m_etc_dir();
  p_Var2 = Strnew_m_charp(pcVar1,&DAT_080ce43e,base,0);
  pcVar1 = expandPath(p_Var2->ptr);
  return pcVar1;
}



char * confFile(char *base)

{
  char *pcVar1;
  Str p_Var2;
  
  pcVar1 = w3m_conf_dir();
  p_Var2 = Strnew_m_charp(pcVar1,&DAT_080ce43e,base,0);
  pcVar1 = expandPath(p_Var2->ptr);
  return pcVar1;
}



void new_menu(Menu *menu,MenuItem *item)

{
  int iVar1;
  char *p;
  int l;
  int i;
  
  menu->cursorX = 0;
  menu->cursorY = 0;
  menu->x = 0;
  menu->y = 0;
  menu->nitem = 0;
  menu->item = item;
  menu->initial = 0;
  menu->select = 0;
  menu->offset = 0;
  menu->active = 0;
  if (item != (MenuItem *)0x0) {
    for (i = 0; item[i].type != 0; i = i + 1) {
    }
    menu->nitem = i;
    menu->height = menu->nitem;
    for (i = 0; i < 0x80; i = i + 1) {
      menu->keymap[i] = MenuKeymap[i];
    }
    menu->width = 0;
    for (i = 0; i < menu->nitem; i = i + 1) {
      p = item[i].keys;
      if (p != (char *)0x0) {
        for (; *p != '\0'; p = p + 1) {
          if ((MYCTYPE_MAP[(byte)*p] & 0x11) != 0) {
            menu->keymap[*p] = mSelect;
            menu->keyselect[*p] = i;
          }
        }
      }
      iVar1 = wtf_strwidth((wc_uchar *)item[i].label);
      if (menu->width < iVar1) {
        menu->width = iVar1;
      }
    }
  }
  return;
}



void geom_menu(Menu *menu,int x,int y,int mselect)

{
  int iVar1;
  int win_h;
  int win_w;
  int win_y;
  int win_x;
  
  menu->select = mselect;
  if (menu->width % FRAME_WIDTH != 0) {
    menu->width = (menu->width / FRAME_WIDTH + 1) * FRAME_WIDTH;
  }
  win_x = menu->x - FRAME_WIDTH;
  iVar1 = menu->width + FRAME_WIDTH * 2;
  if (COLS < win_x + iVar1) {
    win_x = COLS - iVar1;
  }
  if ((win_x < 0) && (win_x = 0, COLS < iVar1)) {
    menu->width = FRAME_WIDTH * -2 + COLS;
    menu->width = menu->width - menu->width % FRAME_WIDTH;
  }
  menu->x = FRAME_WIDTH + win_x;
  win_y = (menu->y - mselect) + -1;
  iVar1 = menu->height + 2;
  if (LINES + -1 < win_y + iVar1) {
    win_y = (LINES + -1) - iVar1;
  }
  if ((win_y < 0) && (win_y = 0, LINES + -1 < iVar1)) {
    menu->height = LINES + -3;
    if (menu->height <= mselect) {
      menu->offset = (mselect - menu->height) + 1;
    }
  }
  menu->y = win_y + 1;
  return;
}



void draw_all_menu(Menu *menu)

{
  if (menu->parent != (_Menu *)0x0) {
    draw_all_menu(menu->parent);
  }
  draw_menu(menu);
  return;
}



void draw_menu(Menu *menu)

{
  int line;
  int iVar1;
  int column;
  int j;
  int i;
  int w;
  int y;
  int x;
  
  column = menu->x - FRAME_WIDTH;
  iVar1 = menu->width + FRAME_WIDTH * 2;
  y = menu->y + -1;
  if (menu->offset == 0) {
    if (graph_mode != 0) {
      graphstart();
    }
    move(y,column);
    addstr(FRAME[3]);
    for (i = FRAME_WIDTH; i < iVar1 - FRAME_WIDTH; i = i + FRAME_WIDTH) {
      move(y,column + i);
      addstr(FRAME[10]);
    }
    move(y,column + i);
    addstr(FRAME[6]);
    if (graph_mode != 0) {
      graphend();
    }
  }
  else {
    if (graph_mode != 0) {
      graphstart();
    }
    move(y,column);
    addstr(FRAME[5]);
    if (graph_mode != 0) {
      graphend();
    }
    for (i = FRAME_WIDTH; i < iVar1 - FRAME_WIDTH; i = i + 1) {
      move(y,column + i);
      addstr(" ");
    }
    if (graph_mode != 0) {
      graphstart();
    }
    move(y,column + i);
    addstr(FRAME[5]);
    if (graph_mode != 0) {
      graphend();
    }
    move(y,column + FRAME_WIDTH * ((iVar1 / 2 + -1) / FRAME_WIDTH));
    addstr(":");
  }
  for (j = 0; j < menu->height; j = j + 1) {
    y = y + 1;
    if (graph_mode != 0) {
      graphstart();
    }
    move(y,column);
    addstr(FRAME[5]);
    if (graph_mode != 0) {
      graphend();
    }
    draw_menu_item(menu,menu->offset + j);
    if (graph_mode != 0) {
      graphstart();
    }
    move(y,(column + iVar1) - FRAME_WIDTH);
    addstr(FRAME[5]);
    if (graph_mode != 0) {
      graphend();
    }
  }
  line = y + 1;
  if (menu->offset + menu->height == menu->nitem) {
    if (graph_mode != 0) {
      graphstart();
    }
    move(line,column);
    addstr(FRAME[9]);
    for (i = FRAME_WIDTH; i < iVar1 - FRAME_WIDTH; i = i + FRAME_WIDTH) {
      move(line,column + i);
      addstr(FRAME[10]);
    }
    move(line,column + i);
    addstr(FRAME[0xc]);
    if (graph_mode != 0) {
      graphend();
    }
  }
  else {
    if (graph_mode != 0) {
      graphstart();
    }
    move(line,column);
    addstr(FRAME[5]);
    if (graph_mode != 0) {
      graphend();
    }
    for (i = FRAME_WIDTH; i < iVar1 - FRAME_WIDTH; i = i + 1) {
      move(line,column + i);
      addstr(" ");
    }
    if (graph_mode != 0) {
      graphstart();
    }
    move(line,column + i);
    addstr(FRAME[5]);
    if (graph_mode != 0) {
      graphend();
    }
    move(line,column + FRAME_WIDTH * ((iVar1 / 2 + -1) / FRAME_WIDTH));
    addstr(":");
  }
  return;
}



void draw_menu_item(Menu *menu,int mselect)

{
  move((menu->y + mselect) - menu->offset,menu->x);
  addnstr_sup(menu->item[mselect].label,menu->width);
  return;
}



int select_menu(Menu *menu,int mselect)

{
  int iVar1;
  
  if ((mselect < 0) || (menu->nitem <= mselect)) {
    iVar1 = -1;
  }
  else {
    if (mselect < menu->offset) {
      up_menu(menu,menu->offset - mselect);
    }
    else if (menu->offset + menu->height <= mselect) {
      down_menu(menu,((mselect - menu->offset) - menu->height) + 1);
    }
    if ((menu->offset <= menu->select) && (menu->select < menu->offset + menu->height)) {
      draw_menu_item(menu,menu->select);
    }
    menu->select = mselect;
    standout();
    draw_menu_item(menu,menu->select);
    standend();
    move((menu->y + mselect) - menu->offset,menu->x);
    toggle_stand();
    refresh();
    iVar1 = menu->select;
  }
  return iVar1;
}



void goto_menu(Menu *menu,int mselect,int down)

{
  int iVar1;
  int select_in;
  
  if (mselect < menu->nitem) {
    iVar1 = mselect;
    if (mselect < 0) {
      mselect = 0;
      iVar1 = mselect;
    }
  }
  else {
    mselect = menu->nitem + -1;
    iVar1 = mselect;
  }
  do {
    while( true ) {
      if (menu->item[mselect].type != 1) goto LAB_0809497b;
      if (down < 1) break;
      mselect = mselect + 1;
      if (menu->nitem <= mselect) {
        down_menu(menu,iVar1 - menu->select);
        mselect = menu->select;
        goto LAB_0809497b;
      }
    }
    if (-1 < down) {
      return;
    }
    mselect = mselect + -1;
  } while (-1 < mselect);
  up_menu(menu,menu->select - iVar1);
  mselect = menu->select;
LAB_0809497b:
  select_menu(menu,mselect);
  return;
}



void up_menu(Menu *menu,int n)

{
  if ((-1 < n) && (menu->offset != 0)) {
    menu->offset = menu->offset - n;
    if (menu->offset < 0) {
      menu->offset = 0;
    }
    draw_menu(menu);
  }
  return;
}



void down_menu(Menu *menu,int n)

{
  if ((-1 < n) && (menu->offset + menu->height != menu->nitem)) {
    menu->offset = menu->offset + n;
    if (menu->nitem < menu->offset + menu->height) {
      menu->offset = menu->nitem - menu->height;
    }
    draw_menu(menu);
  }
  return;
}



int action_menu(Menu *menu)

{
  int *piVar1;
  int iVar2;
  anon_subr_void_varargs_for_func *paVar3;
  char *pcVar4;
  char cVar5;
  uint uVar6;
  MenuItem *pMVar7;
  MenuItem item;
  int mselect;
  char c;
  
  if (menu->active == 0) {
    if (menu->parent != (_Menu *)0x0) {
      menu->parent->active = 0;
    }
  }
  else {
    draw_all_menu(menu);
    select_menu(menu,menu->select);
    do {
      if (use_mouse != 0) {
        mouse_active();
      }
      uVar6 = do_getch();
      cVar5 = (char)uVar6;
      if (use_mouse != 0) {
        mouse_inactive();
      }
    } while (((cVar5 != -1) || (mselect = X_Mouse_Selection, X_Mouse_Selection == -1)) &&
            (((MYCTYPE_MAP[uVar6 & 0xff] & 0x11) == 0 ||
             (mselect = (*menu->keymap[cVar5])(cVar5), mselect == -1))));
    if ((mselect < 0) || (menu->nitem <= mselect)) {
      if ((mselect == -3) && (menu->parent != (_Menu *)0x0)) {
        menu->parent->active = 0;
      }
    }
    else {
      pMVar7 = menu->item + mselect;
      uVar6 = pMVar7->type;
      piVar1 = pMVar7->variable;
      iVar2 = pMVar7->value;
      paVar3 = pMVar7->func;
      pcVar4 = pMVar7->data;
      if ((uVar6 & 8) != 0) {
        popup_menu(menu,pMVar7->popup);
        return 1;
      }
      if (menu->parent != (_Menu *)0x0) {
        menu->parent->active = 0;
      }
      if ((uVar6 & 2) != 0) {
        *piVar1 = iVar2;
      }
      if ((uVar6 & 4) != 0) {
        CurrentKey = -1;
        CurrentKeyData = (char *)0x0;
        CurrentCmdData = pcVar4;
        (*paVar3)();
        CurrentCmdData = (char *)0x0;
      }
    }
  }
  return 0;
}



void popup_menu(Menu *parent,Menu *menu)

{
  int active;
  
  active = 1;
  if (((menu->item != (MenuItem *)0x0) && (menu->nitem != 0)) && (menu->active == 0)) {
    gpm_handler = gpm_process_menu_mouse;
    menu->parent = parent;
    menu->select = menu->initial;
    menu->offset = 0;
    menu->active = 1;
    if (parent != (Menu *)0x0) {
      menu->cursorX = parent->cursorX;
      menu->cursorY = parent->cursorY;
      guess_menu_xy(parent,menu->width,&menu->x,&menu->y);
    }
    geom_menu(menu,menu->x,menu->y,menu->select);
    CurrentMenu = menu;
    while (active != 0) {
      active = action_menu(CurrentMenu);
      displayBuffer(CurrentTab->currentBuffer,1);
    }
    menu->active = 0;
    CurrentMenu = parent;
    if (parent == (Menu *)0x0) {
      gpm_handler = gpm_process_mouse;
    }
  }
  return;
}



void guess_menu_xy(Menu *parent,int width,int *x,int *y)

{
  *x = parent->x + parent->width + FRAME_WIDTH + -1;
  if (((COLS < *x + width + FRAME_WIDTH) &&
      (*x = (COLS - width) - FRAME_WIDTH, *x < parent->x + parent->width / 2)) &&
     (COLS / 2 < parent->x + parent->width / 2)) {
    *x = ((parent->x - width) - FRAME_WIDTH) + 1;
  }
  *y = (parent->y + parent->select) - parent->offset;
  return;
}



void new_option_menu(Menu *menu,char **label,int *variable,anon_subr_void_varargs *func)

{
  int iVar1;
  MenuItem *item_00;
  MenuItem *item;
  char **p;
  int nitem;
  int i;
  
  if ((label != (char **)0x0) && (*label != (char *)0x0)) {
    i = 0;
    for (p = label; iVar1 = i, *p != (char *)0x0; p = p + 1) {
      i = i + 1;
    }
    item_00 = (MenuItem *)GC_malloc((i + 1) * 0x20);
    p = label;
    for (i = 0; i < iVar1; i = i + 1) {
      if (func == (anon_subr_void_varargs *)0x0) {
        item_00[i].type = 2;
      }
      else {
        item_00[i].type = 6;
      }
      item_00[i].label = *p;
      item_00[i].variable = variable;
      item_00[i].value = i;
      item_00[i].func = (anon_subr_void_varargs_for_func *)func;
      item_00[i].popup = (_Menu *)0x0;
      item_00[i].keys = "";
      p = p + 1;
    }
    item_00[iVar1].type = 0;
    new_menu(menu,item_00);
  }
  return;
}



void set_menu_frame(void)

{
  int iVar1;
  
  iVar1 = graph_ok();
  if (iVar1 == 0) {
    graph_mode = 0;
    FRAME_WIDTH = 0;
    FRAME = get_symbol(DisplayCharset,&FRAME_WIDTH);
    if (WcOption.use_wide == '\0') {
      FRAME_WIDTH = 1;
    }
  }
  else {
    graph_mode = 1;
    FRAME_WIDTH = 1;
    FRAME = graph_symbol;
  }
  return;
}



int mEsc(char c)

{
  int iVar1;
  
  iVar1 = do_getch();
  iVar1 = (*MenuEscKeymap[(char)iVar1])((char)iVar1);
  return iVar1;
}



int mEscB(char c)

{
  char c_00;
  uint uVar1;
  int iVar2;
  
  uVar1 = do_getch();
  c_00 = (char)uVar1;
  if ((MYCTYPE_MAP[uVar1 & 0xff] & 8) == 0) {
    iVar2 = (*MenuEscBKeymap[c_00])(c_00);
  }
  else {
    iVar2 = mEscD(c_00);
  }
  return iVar2;
}



int mEscD(char c)

{
  uint uVar1;
  int iVar2;
  char local_20;
  int d;
  
  d = c + -0x30;
  uVar1 = do_getch();
  local_20 = (char)uVar1;
  if ((MYCTYPE_MAP[uVar1 & 0xff] & 8) != 0) {
    d = d * 10 + (int)local_20 + -0x30;
    iVar2 = do_getch();
    local_20 = (char)iVar2;
  }
  if (local_20 == '~') {
    iVar2 = (*MenuEscDKeymap[d])('~');
  }
  else {
    iVar2 = -1;
  }
  return iVar2;
}



int mNull(char c)

{
  return -1;
}



int mSelect(char c)

{
  int iVar1;
  
  if ((MYCTYPE_MAP[(byte)c] & 0x11) == 0) {
    iVar1 = -1;
  }
  else {
    iVar1 = select_menu(CurrentMenu,CurrentMenu->keyselect[c]);
  }
  return iVar1;
}



int mDown(char c)

{
  if (CurrentMenu->select < CurrentMenu->nitem + -1) {
    goto_menu(CurrentMenu,CurrentMenu->select + 1,1);
  }
  return -1;
}



int mUp(char c)

{
  if (0 < CurrentMenu->select) {
    goto_menu(CurrentMenu,CurrentMenu->select + -1,-1);
  }
  return -1;
}



int mLast(char c)

{
  goto_menu(CurrentMenu,CurrentMenu->nitem + -1,-1);
  return -1;
}



int mTop(char c)

{
  goto_menu(CurrentMenu,0,1);
  return -1;
}



int mNext(char c)

{
  int iVar1;
  int mselect;
  
  iVar1 = CurrentMenu->select + CurrentMenu->height;
  if (iVar1 < CurrentMenu->nitem) {
    down_menu(CurrentMenu,CurrentMenu->height);
    goto_menu(CurrentMenu,iVar1,-1);
    iVar1 = -1;
  }
  else {
    iVar1 = mLast(c);
  }
  return iVar1;
}



int mPrev(char c)

{
  int iVar1;
  int mselect;
  
  iVar1 = CurrentMenu->select - CurrentMenu->height;
  if (iVar1 < 0) {
    iVar1 = mTop(c);
  }
  else {
    up_menu(CurrentMenu,CurrentMenu->height);
    goto_menu(CurrentMenu,iVar1,1);
    iVar1 = -1;
  }
  return iVar1;
}



int mFore(char c)

{
  if (CurrentMenu->select < CurrentMenu->nitem + -1) {
    goto_menu(CurrentMenu,CurrentMenu->select + CurrentMenu->height + -1,CurrentMenu->height + 1);
  }
  return -1;
}



int mBack(char c)

{
  if (0 < CurrentMenu->select) {
    goto_menu(CurrentMenu,(CurrentMenu->select - CurrentMenu->height) + 1,~CurrentMenu->height);
  }
  return -1;
}



int mLineU(char c)

{
  int iVar1;
  int mselect;
  
  mselect = CurrentMenu->select;
  if (mselect < CurrentMenu->nitem) {
    if (CurrentMenu->offset + CurrentMenu->height < CurrentMenu->nitem) {
      down_menu(CurrentMenu,1);
      if (mselect < CurrentMenu->offset) {
        mselect = mselect + 1;
      }
    }
    else {
      mselect = mselect + 1;
    }
    goto_menu(CurrentMenu,mselect,1);
    iVar1 = -1;
  }
  else {
    iVar1 = mLast(c);
  }
  return iVar1;
}



int mLineD(char c)

{
  int iVar1;
  int mselect;
  
  mselect = CurrentMenu->select;
  if (mselect < 1) {
    iVar1 = mTop(c);
  }
  else {
    if (CurrentMenu->offset < 1) {
      mselect = mselect + -1;
    }
    else {
      up_menu(CurrentMenu,1);
      if (CurrentMenu->offset + CurrentMenu->height <= mselect) {
        mselect = mselect + -1;
      }
    }
    goto_menu(CurrentMenu,mselect,-1);
    iVar1 = -1;
  }
  return iVar1;
}



int mOk(char c)

{
  int iVar1;
  int mselect;
  
  iVar1 = CurrentMenu->select;
  if (CurrentMenu->item[iVar1].type == 1) {
    iVar1 = -1;
  }
  return iVar1;
}



int mCancel(char c)

{
  return -2;
}



int mClose(char c)

{
  return -3;
}



int mSusp(char c)

{
  susp();
  draw_all_menu(CurrentMenu);
  select_menu(CurrentMenu,CurrentMenu->select);
  return -1;
}



int menuForwardSearch(Menu *menu,char *str,int from)

{
  char *s;
  int iVar1;
  char *p;
  int i;
  
  s = regexCompile(str,IgnoreCase);
  if (s == (char *)0x0) {
    if (from < 0) {
      from = 0;
    }
    for (i = from; i < menu->nitem; i = i + 1) {
      if ((menu->item[i].type != 1) && (iVar1 = regexMatch(menu->item[i].label,-1,1), iVar1 == 1)) {
        return i;
      }
    }
  }
  else {
    message(s,0,0);
  }
  return -1;
}



int menu_search_forward(Menu *menu,int from)

{
  char *str_00;
  int found;
  char *str;
  
  str = inputLineHistSearch("Forward: ",(char *)0x0,0x10,TextHist,
                            (anon_subr_int_int_Str_Lineprop_ptr *)0x0);
  if ((str != (char *)0x0) && (*str == '\0')) {
    str = SearchString;
  }
  if ((str == (char *)0x0) || (*str == '\0')) {
    found = -1;
  }
  else {
    SearchString = str;
    str_00 = conv_search_string(str,DisplayCharset);
    menuSearchRoutine = menuForwardSearch;
    found = menuForwardSearch(menu,str_00,from + 1);
    if ((WrapSearch != 0) && (found == -1)) {
      found = menuForwardSearch(menu,str_00,0);
    }
    if (found < 0) {
      disp_message("Not found",1);
      found = -1;
    }
  }
  return found;
}



int mSrchF(char c)

{
  int mselect_00;
  int mselect;
  
  mselect_00 = menu_search_forward(CurrentMenu,CurrentMenu->select);
  if (-1 < mselect_00) {
    goto_menu(CurrentMenu,mselect_00,1);
  }
  return -1;
}



int menuBackwardSearch(Menu *menu,char *str,int from)

{
  char *s;
  int iVar1;
  char *p;
  int i;
  
  s = regexCompile(str,IgnoreCase);
  if (s == (char *)0x0) {
    if (menu->nitem <= from) {
      from = menu->nitem + -1;
    }
    for (i = from; -1 < i; i = i + -1) {
      if ((menu->item[i].type != 1) && (iVar1 = regexMatch(menu->item[i].label,-1,1), iVar1 == 1)) {
        return i;
      }
    }
  }
  else {
    message(s,0,0);
  }
  return -1;
}



int menu_search_backward(Menu *menu,int from)

{
  char *str_00;
  int found;
  char *str;
  
  str = inputLineHistSearch("Backward: ",(char *)0x0,0x10,TextHist,
                            (anon_subr_int_int_Str_Lineprop_ptr *)0x0);
  if ((str != (char *)0x0) && (*str == '\0')) {
    str = SearchString;
  }
  if ((str == (char *)0x0) || (*str == '\0')) {
    found = -1;
  }
  else {
    SearchString = str;
    str_00 = conv_search_string(str,DisplayCharset);
    menuSearchRoutine = menuBackwardSearch;
    found = menuBackwardSearch(menu,str_00,from + -1);
    if ((WrapSearch != 0) && (found == -1)) {
      found = menuBackwardSearch(menu,str_00,menu->nitem);
    }
    if (found < 0) {
      disp_message("Not found",1);
      found = -1;
    }
  }
  return found;
}



int mSrchB(char c)

{
  int mselect_00;
  int mselect;
  
  mselect_00 = menu_search_backward(CurrentMenu,CurrentMenu->select);
  if (-1 < mselect_00) {
    goto_menu(CurrentMenu,mselect_00,-1);
  }
  return -1;
}



int menu_search_next_previous(Menu *menu,int from,int reverse)

{
  char *pcVar1;
  int iVar2;
  char *str;
  int found;
  
  if (menuSearchRoutine == (anon_subr_int_Menu_ptr_char_ptr_int *)0x0) {
    disp_message("No previous regular expression",1);
    found = -1;
  }
  else {
    pcVar1 = conv_search_string(SearchString,DisplayCharset);
    if (reverse != 0) {
      reverse = 1;
    }
    if (menuSearchRoutine == menuBackwardSearch) {
      reverse = reverse ^ 1;
    }
    if (reverse == 0) {
      iVar2 = 1;
    }
    else {
      iVar2 = -1;
    }
    found = (*menu_search_next_previous::routine[reverse])(menu,pcVar1,from + iVar2);
    if ((WrapSearch != 0) && (found == -1)) {
      found = (*menu_search_next_previous::routine[reverse])(menu,pcVar1,menu->nitem * reverse);
    }
    if (found < 0) {
      disp_message("Not found",1);
      found = -1;
    }
  }
  return found;
}



int mSrchN(char c)

{
  int mselect_00;
  int mselect;
  
  mselect_00 = menu_search_next_previous(CurrentMenu,CurrentMenu->select,0);
  if (-1 < mselect_00) {
    goto_menu(CurrentMenu,mselect_00,1);
  }
  return -1;
}



int mSrchP(char c)

{
  int mselect_00;
  int mselect;
  
  mselect_00 = menu_search_next_previous(CurrentMenu,CurrentMenu->select,1);
  if (-1 < mselect_00) {
    goto_menu(CurrentMenu,mselect_00,-1);
  }
  return -1;
}



int mMouse_scroll_line(void)

{
  int i;
  
  if (relative_wheel_scroll == 0) {
    i = fixed_wheel_scroll_count;
  }
  else {
    i = (relative_wheel_scroll_ratio * CurrentMenu->height + 99) / 100;
  }
  if (i == 0) {
    i = 1;
  }
  return i;
}



int process_mMouse(int btn,int x,int y)

{
  int iVar1;
  int i;
  int mselect;
  Menu *menu;
  char c;
  
  if ((((x < 0) || (COLS <= x)) || (y < 0)) || (LINES + -1 < y)) {
    return -1;
  }
  if (btn == 3) {
    if (process_mMouse::press_btn == 2) {
LAB_08095c5e:
      if (((x < CurrentMenu->x - FRAME_WIDTH) ||
          (CurrentMenu->x + CurrentMenu->width + FRAME_WIDTH <= x)) ||
         ((y < CurrentMenu->y + -1 || (CurrentMenu->y + CurrentMenu->height + 1 <= y)))) {
        return -2;
      }
      if (((CurrentMenu->x - FRAME_WIDTH <= x) && (x < CurrentMenu->x)) ||
         ((CurrentMenu->x + CurrentMenu->width <= x &&
          (x < CurrentMenu->x + CurrentMenu->width + FRAME_WIDTH)))) {
        return -1;
      }
      if (y < process_mMouse::press_y) {
        for (i = 0; i < process_mMouse::press_y - y; i = i + 1) {
          mLineU(' ');
        }
        return -1;
      }
      if (process_mMouse::press_y < y) {
        for (i = 0; i < y - process_mMouse::press_y; i = i + 1) {
          mLineD(' ');
        }
        return -1;
      }
      if (CurrentMenu->y + -1 == y) {
        mPrev(' ');
        return -1;
      }
      if (CurrentMenu->y + CurrentMenu->height == y) {
        mNext(' ');
        return -1;
      }
      iVar1 = (y - CurrentMenu->y) + CurrentMenu->offset;
      if (CurrentMenu->item[iVar1].type == 1) {
        return -1;
      }
      iVar1 = select_menu(CurrentMenu,iVar1);
      return iVar1;
    }
    if (process_mMouse::press_btn < 3) {
      if (process_mMouse::press_btn == 0) goto LAB_08095c5e;
    }
    else if (process_mMouse::press_btn == 3) {
      for (i = 0; iVar1 = mMouse_scroll_line(), i < iVar1; i = i + 1) {
        mLineD(' ');
      }
    }
    else if (process_mMouse::press_btn == 4) {
      for (i = 0; iVar1 = mMouse_scroll_line(), i < iVar1; i = i + 1) {
        mLineU(' ');
      }
    }
  }
  else if (btn == 0x40) {
    for (i = 0; iVar1 = mMouse_scroll_line(), i < iVar1; i = i + 1) {
      mLineD(' ');
    }
  }
  else if (btn == 0x41) {
    for (i = 0; iVar1 = mMouse_scroll_line(), i < iVar1; i = i + 1) {
      mLineU(' ');
    }
  }
  if ((btn == 3) && (process_mMouse::press_btn != -1)) {
    process_mMouse::press_btn = -1;
  }
  else {
    process_mMouse::press_btn = btn;
    process_mMouse::press_x = x;
    process_mMouse::press_y = y;
  }
  return -1;
}



int mMouse(char c)

{
  uint uVar1;
  uint uVar2;
  int iVar3;
  int y;
  int x;
  int btn;
  
  uVar1 = do_getch();
  uVar2 = do_getch();
  x = (uVar2 & 0xff) - 0x21;
  if (x < 0) {
    x = (uVar2 & 0xff) + 0xdf;
  }
  uVar2 = do_getch();
  y = (uVar2 & 0xff) - 0x21;
  if (y < 0) {
    y = (uVar2 & 0xff) + 0xdf;
  }
  iVar3 = process_mMouse((uVar1 & 0xff) - 0x20,x,y);
  return iVar3;
}



int gpm_process_menu_mouse(Gpm_Event *event,void *data)

{
  short *psVar1;
  uchar uVar2;
  short *psVar3;
  int y;
  int x;
  int btn;
  
  psVar1 = _gpm_arg;
  btn = -1;
  if ((event->type & GPM_UP) == 0) {
    if ((event->type & GPM_DOWN) == 0) {
      _gpm_buf[1] = 2;
      psVar3 = _gpm_arg + 2;
      *psVar3 = event->x + (short)gpm_zerobased;
      *psVar1 = *psVar3;
      psVar1 = _gpm_arg + 1;
      psVar3 = _gpm_arg + 3;
      *psVar3 = event->y + (short)gpm_zerobased;
      *psVar1 = *psVar3;
      _gpm_arg[4] = 3;
      ioctl(gpm_consolefd,0x541c,0x817c201);
      return 0;
    }
    uVar2 = event->buttons;
    if (uVar2 == '\x02') {
      btn = 1;
    }
    else if (uVar2 == '\x04') {
      btn = 0;
    }
    else if (uVar2 == '\x01') {
      btn = 2;
    }
  }
  else {
    btn = 3;
  }
  X_Mouse_Selection = process_mMouse(btn,event->x + -1,event->y + -1);
  return -1;
}



void popupMenu(int x,int y,Menu *menu)

{
  set_menu_frame();
  initSelectMenu();
  initSelTabMenu();
  menu->cursorX = (int)CurrentTab->currentBuffer->cursorX + (int)CurrentTab->currentBuffer->rootX;
  menu->cursorY = (int)CurrentTab->currentBuffer->cursorY + (int)CurrentTab->currentBuffer->rootY;
  menu->x = FRAME_WIDTH + x + 1;
  menu->y = y + 2;
  popup_menu((Menu *)0x0,menu);
  return;
}



void mainMenu(int x,int y)

{
  popupMenu(x,y,&MainMenu);
  return;
}



void mainMn(void)

{
  char *id;
  int iVar1;
  int y;
  int x;
  int n;
  char *data;
  Menu *menu;
  
  menu = &MainMenu;
  x = (int)CurrentTab->currentBuffer->cursorX + (int)CurrentTab->currentBuffer->rootX;
  y = (int)CurrentTab->currentBuffer->cursorY + (int)CurrentTab->currentBuffer->rootY;
  id = searchKeyData();
  if (id != (char *)0x0) {
    iVar1 = getMenuN(w3mMenuList,id);
    if (iVar1 < 0) {
      return;
    }
    menu = w3mMenuList[iVar1].menu;
  }
  if (mouse_action.in_action != 0) {
    x = mouse_action.cursorX;
    y = mouse_action.cursorY;
  }
  popupMenu(x,y,menu);
  return;
}



void selMn(void)

{
  int y;
  int x;
  
  x = (int)CurrentTab->currentBuffer->cursorX + (int)CurrentTab->currentBuffer->rootX;
  y = (int)CurrentTab->currentBuffer->cursorY + (int)CurrentTab->currentBuffer->rootY;
  if (mouse_action.in_action != 0) {
    x = mouse_action.cursorX;
    y = mouse_action.cursorY;
  }
  popupMenu(x,y,&SelectMenu);
  return;
}



void initSelectMenu(void)

{
  int iVar1;
  wc_ces t_ces;
  wc_ces f_ces;
  int iVar2;
  char **label_00;
  Str p_Var3;
  int iVar4;
  Str p_Var5;
  char *p;
  char **label;
  Str str;
  Buffer *buf;
  int l;
  int len;
  int nitem;
  int i;
  
  len = 0;
  SelectV = -1;
  i = 0;
  for (buf = CurrentTab->firstBuffer; iVar2 = i, buf != (Buffer *)0x0; buf = buf->nextBuffer) {
    if (CurrentTab->currentBuffer == buf) {
      SelectV = i;
    }
    i = i + 1;
  }
  label_00 = (char **)GC_malloc((i + 2) * 4);
  i = 0;
  buf = CurrentTab->firstBuffer;
  for (; i < iVar2; i = i + 1) {
    p_Var5 = Sprintf("<%s>",buf->buffername);
    if (buf->filename != (char *)0x0) {
      iVar4 = (buf->currentURL).scheme;
      if (iVar4 == 4) {
        iVar4 = strcmp((buf->currentURL).file,"-");
        if (iVar4 != 0) {
          if (p_Var5->area_size <= p_Var5->length + 1) {
            Strgrow(p_Var5);
          }
          iVar4 = p_Var5->length;
          p_Var5->ptr[iVar4] = ' ';
          p_Var5->length = iVar4 + 1;
          p_Var5->ptr[p_Var5->length] = '\0';
          f_ces = SystemCharset;
          t_ces = InnerCharset;
          p_Var3 = Strnew_charp((buf->currentURL).real_file);
          p_Var3 = wc_Str_conv(p_Var3,f_ces,t_ces);
          Strcat_charp(p_Var5,p_Var3->ptr);
        }
      }
      else if (iVar4 != 0xfe) {
        if (p_Var5->area_size <= p_Var5->length + 1) {
          Strgrow(p_Var5);
        }
        iVar4 = p_Var5->length;
        p_Var5->ptr[iVar4] = ' ';
        p_Var5->length = iVar4 + 1;
        p_Var5->ptr[p_Var5->length] = '\0';
        p_Var3 = parsedURL2Str(&buf->currentURL);
        p = p_Var3->ptr;
        if (DecodeURL != 0) {
          p = url_unquote_conv(p,0);
        }
        Strcat_charp(p_Var5,p);
      }
    }
    label_00[i] = p_Var5->ptr;
    if (len < p_Var5->length) {
      len = p_Var5->length;
    }
    buf = buf->nextBuffer;
  }
  iVar4 = wtf_strwidth((wc_uchar *)initSelectMenu::comment);
  if (len < iVar4 + 4) {
    len = iVar4 + 4;
  }
  if (FRAME_WIDTH * -2 + COLS < len) {
    len = FRAME_WIDTH * -2 + COLS;
  }
  if (len < 2) {
    iVar4 = 0;
  }
  else {
    iVar4 = ((len - iVar4) + 1) / 2;
  }
  p_Var5 = Strnew();
  for (i = 0; i < iVar4; i = i + 1) {
    if (p_Var5->area_size <= p_Var5->length + 1) {
      Strgrow(p_Var5);
    }
    iVar1 = p_Var5->length;
    p_Var5->ptr[iVar1] = '-';
    p_Var5->length = iVar1 + 1;
    p_Var5->ptr[p_Var5->length] = '\0';
  }
  Strcat_charp(p_Var5,initSelectMenu::comment);
  for (i = 0; i < iVar4; i = i + 1) {
    if (p_Var5->area_size <= p_Var5->length + 1) {
      Strgrow(p_Var5);
    }
    iVar1 = p_Var5->length;
    p_Var5->ptr[iVar1] = '-';
    p_Var5->length = iVar1 + 1;
    p_Var5->ptr[p_Var5->length] = '\0';
  }
  label_00[iVar2] = p_Var5->ptr;
  label_00[iVar2 + 1] = (char *)0x0;
  new_option_menu(&SelectMenu,label_00,&SelectV,smChBuf);
  SelectMenu.initial = SelectV;
  SelectMenu.cursorX =
       (int)CurrentTab->currentBuffer->cursorX + (int)CurrentTab->currentBuffer->rootX;
  SelectMenu.cursorY =
       (int)CurrentTab->currentBuffer->cursorY + (int)CurrentTab->currentBuffer->rootY;
  SelectMenu.keymap[68] = smDelBuf;
  SelectMenu.item[iVar2].type = 1;
  return;
}



void smChBuf(void)

{
  Buffer *buf;
  int i;
  
  if ((-1 < SelectV) && (SelectV < SelectMenu.nitem)) {
    i = 0;
    buf = CurrentTab->firstBuffer;
    for (; i < SelectV; i = i + 1) {
      buf = buf->nextBuffer;
    }
    CurrentTab->currentBuffer = buf;
    for (buf = CurrentTab->firstBuffer; buf != (Buffer *)0x0; buf = buf->nextBuffer) {
      if ((CurrentTab->currentBuffer != buf) && (deleteImage(buf), clear_buffer != 0)) {
        tmpClearBuffer(buf);
      }
    }
  }
  return;
}



int smDelBuf(char c)

{
  int iVar1;
  int y_00;
  TabBuffer *pTVar2;
  Buffer *pBVar3;
  int iVar4;
  Buffer *buf;
  int mselect;
  int y;
  int x;
  int i;
  
  if ((-1 < CurrentMenu->select) && (CurrentMenu->select < SelectMenu.nitem)) {
    i = 0;
    buf = CurrentTab->firstBuffer;
    for (; i < CurrentMenu->select; i = i + 1) {
      buf = buf->nextBuffer;
    }
    if (CurrentTab->currentBuffer == buf) {
      CurrentTab->currentBuffer = buf->nextBuffer;
    }
    pTVar2 = CurrentTab;
    pBVar3 = deleteBuffer(CurrentTab->firstBuffer,buf);
    pTVar2->firstBuffer = pBVar3;
    pTVar2 = CurrentTab;
    if (CurrentTab->currentBuffer == (Buffer *)0x0) {
      pBVar3 = nthBuffer(CurrentTab->firstBuffer,i + -1);
      pTVar2->currentBuffer = pBVar3;
    }
    pTVar2 = CurrentTab;
    if (CurrentTab->firstBuffer == (Buffer *)0x0) {
      pBVar3 = nullBuffer();
      pTVar2->firstBuffer = pBVar3;
      CurrentTab->currentBuffer = CurrentTab->firstBuffer;
    }
    iVar1 = CurrentMenu->x;
    y_00 = CurrentMenu->y;
    iVar4 = CurrentMenu->select;
    initSelectMenu();
    CurrentMenu->x = iVar1;
    CurrentMenu->y = y_00;
    geom_menu(CurrentMenu,iVar1,y_00,0);
    iVar1 = CurrentMenu->nitem + -2;
    if (iVar1 <= iVar4) {
      iVar4 = iVar1;
    }
    CurrentMenu->select = iVar4;
    displayBuffer(CurrentTab->currentBuffer,1);
    draw_all_menu(CurrentMenu);
    select_menu(CurrentMenu,CurrentMenu->select);
  }
  return -1;
}



void tabMn(void)

{
  int y;
  int x;
  
  x = (int)CurrentTab->currentBuffer->cursorX + (int)CurrentTab->currentBuffer->rootX;
  y = (int)CurrentTab->currentBuffer->cursorY + (int)CurrentTab->currentBuffer->rootY;
  if (mouse_action.in_action != 0) {
    x = mouse_action.cursorX;
    y = mouse_action.cursorY;
  }
  popupMenu(x,y,&SelTabMenu);
  return;
}



void initSelTabMenu(void)

{
  Buffer *pBVar1;
  int iVar2;
  wc_ces t_ces;
  wc_ces f_ces;
  int iVar3;
  char **label_00;
  Str p_Var4;
  size_t sVar5;
  int iVar6;
  Str p_Var7;
  char *p;
  char **label;
  Str str;
  Buffer *buf;
  TabBuffer *tab;
  int l;
  int len;
  int nitem;
  int i;
  
  len = 0;
  SelTabV = -1;
  i = 0;
  for (tab = LastTab; iVar3 = i, tab != (TabBuffer *)0x0; tab = tab->prevTab) {
    if (tab == CurrentTab) {
      SelTabV = i;
    }
    i = i + 1;
  }
  label_00 = (char **)GC_malloc((i + 2) * 4);
  tab = LastTab;
  for (i = 0; i < iVar3; i = i + 1) {
    pBVar1 = tab->currentBuffer;
    p_Var7 = Sprintf("<%s>",pBVar1->buffername);
    if (pBVar1->filename != (char *)0x0) {
      iVar6 = (pBVar1->currentURL).scheme;
      if (iVar6 == 4) {
        iVar6 = strcmp((pBVar1->currentURL).file,"-");
        if (iVar6 != 0) {
          if (p_Var7->area_size <= p_Var7->length + 1) {
            Strgrow(p_Var7);
          }
          iVar6 = p_Var7->length;
          p_Var7->ptr[iVar6] = ' ';
          p_Var7->length = iVar6 + 1;
          p_Var7->ptr[p_Var7->length] = '\0';
          f_ces = SystemCharset;
          t_ces = InnerCharset;
          p_Var4 = Strnew_charp((pBVar1->currentURL).real_file);
          p_Var4 = wc_Str_conv(p_Var4,f_ces,t_ces);
          Strcat_charp(p_Var7,p_Var4->ptr);
        }
      }
      else if (iVar6 != 0xfe) {
        p_Var4 = parsedURL2Str(&pBVar1->currentURL);
        p = p_Var4->ptr;
        if (DecodeURL != 0) {
          p = url_unquote_conv(p,0);
        }
        Strcat_charp(p_Var7,p);
      }
    }
    label_00[i] = p_Var7->ptr;
    if (len < p_Var7->length) {
      len = p_Var7->length;
    }
    tab = tab->prevTab;
  }
  sVar5 = strlen(initSelTabMenu::comment);
  if (len < (int)(sVar5 + 4)) {
    len = sVar5 + 4;
  }
  if (FRAME_WIDTH * -2 + COLS < len) {
    len = FRAME_WIDTH * -2 + COLS;
  }
  if (len < 2) {
    iVar6 = 0;
  }
  else {
    iVar6 = (int)((len - sVar5) + 1) / 2;
  }
  p_Var7 = Strnew();
  for (i = 0; i < iVar6; i = i + 1) {
    if (p_Var7->area_size <= p_Var7->length + 1) {
      Strgrow(p_Var7);
    }
    iVar2 = p_Var7->length;
    p_Var7->ptr[iVar2] = '-';
    p_Var7->length = iVar2 + 1;
    p_Var7->ptr[p_Var7->length] = '\0';
  }
  Strcat_charp(p_Var7,initSelTabMenu::comment);
  for (i = 0; i < iVar6; i = i + 1) {
    if (p_Var7->area_size <= p_Var7->length + 1) {
      Strgrow(p_Var7);
    }
    iVar2 = p_Var7->length;
    p_Var7->ptr[iVar2] = '-';
    p_Var7->length = iVar2 + 1;
    p_Var7->ptr[p_Var7->length] = '\0';
  }
  label_00[iVar3] = p_Var7->ptr;
  label_00[iVar3 + 1] = (char *)0x0;
  new_option_menu(&SelTabMenu,label_00,&SelTabV,smChTab);
  SelTabMenu.initial = SelTabV;
  SelTabMenu.cursorX =
       (int)CurrentTab->currentBuffer->cursorX + (int)CurrentTab->currentBuffer->rootX;
  SelTabMenu.cursorY =
       (int)CurrentTab->currentBuffer->cursorY + (int)CurrentTab->currentBuffer->rootY;
  SelTabMenu.keymap[68] = smDelTab;
  SelTabMenu.item[iVar3].type = 1;
  return;
}



void smChTab(void)

{
  Buffer *buf_00;
  Buffer *buf;
  TabBuffer *tab;
  int i;
  
  if ((-1 < SelTabV) && (SelTabV < SelTabMenu.nitem)) {
    i = 0;
    for (tab = LastTab; (i < SelTabV && (tab != (TabBuffer *)0x0)); tab = tab->prevTab) {
      i = i + 1;
    }
    CurrentTab = tab;
    for (tab = LastTab; tab != (TabBuffer *)0x0; tab = tab->prevTab) {
      if (tab != CurrentTab) {
        buf_00 = tab->currentBuffer;
        deleteImage(buf_00);
        if (clear_buffer != 0) {
          tmpClearBuffer(buf_00);
        }
      }
    }
  }
  return;
}



int smDelTab(char c)

{
  int iVar1;
  int y_00;
  int iVar2;
  TabBuffer *tab;
  int mselect;
  int y;
  int x;
  int i;
  
  if ((-1 < CurrentMenu->select) && (CurrentMenu->select < SelTabMenu.nitem)) {
    i = 0;
    for (tab = LastTab; (i < CurrentMenu->select && (tab != (TabBuffer *)0x0)); tab = tab->prevTab)
    {
      i = i + 1;
    }
    deleteTab(tab);
    iVar1 = CurrentMenu->x;
    y_00 = CurrentMenu->y;
    iVar2 = CurrentMenu->select;
    initSelTabMenu();
    CurrentMenu->x = iVar1;
    CurrentMenu->y = y_00;
    geom_menu(CurrentMenu,iVar1,y_00,0);
    iVar1 = CurrentMenu->nitem + -2;
    if (iVar1 <= iVar2) {
      iVar2 = iVar1;
    }
    CurrentMenu->select = iVar2;
    displayBuffer(CurrentTab->currentBuffer,1);
    draw_all_menu(CurrentMenu);
    select_menu(CurrentMenu,CurrentMenu->select);
  }
  return -1;
}



void optionMenu(int x,int y,char **label,int *variable,int initial,anon_subr_void_varargs *func)

{
  Menu menu;
  
  set_menu_frame();
  new_option_menu(&menu,label,variable,func);
  menu.cursorX = COLS + -1;
  menu.cursorY = LINES + -1;
  menu.x = x;
  menu.y = y;
  menu.initial = initial;
  popup_menu((Menu *)0x0,&menu);
  return;
}



void interpret_menu(FILE *mf)

{
  bool bVar1;
  MenuList *pMVar2;
  char *pcVar3;
  MenuItem *pMVar4;
  int iVar5;
  wc_ces charset;
  MenuItem *item;
  int type;
  int nitem;
  int nmenu;
  int in_menu;
  char *s;
  char *p;
  Str line;
  
  bVar1 = false;
  nmenu = 0;
  nitem = 0;
  item = (MenuItem *)0x0;
  charset = SystemCharset;
  while (iVar5 = feof((FILE *)mf), iVar5 == 0) {
    line = Strfgets(mf);
    Strchop(line);
    Strremovefirstspaces(line);
    if (line->length != 0) {
      line = wc_Str_conv(line,charset,InnerCharset);
      p = line->ptr;
      pcVar3 = getWord(&p);
      if (*pcVar3 != '#') {
        if (bVar1) {
          iVar5 = setMenuItem(item + nitem,pcVar3,p);
          if (iVar5 != -1) {
            if (iVar5 == 0) {
              bVar1 = false;
            }
            else {
              item = (MenuItem *)GC_realloc(item,(nitem + 2) * 0x20);
              w3mMenuList[nmenu].item = item;
              item[nitem + 1].type = 0;
              nitem = nitem + 1;
            }
          }
        }
        else {
          iVar5 = strcmp(pcVar3,"menu");
          if (iVar5 == 0) {
            pcVar3 = getQWord(&p);
            if (*pcVar3 != '\0') {
              bVar1 = true;
              nmenu = getMenuN(w3mMenuList,pcVar3);
              pMVar2 = w3mMenuList;
              if (nmenu == -1) {
                nmenu = addMenuList(&w3mMenuList,pcVar3);
              }
              else {
                pMVar4 = (MenuItem *)GC_malloc(0x20);
                pMVar2[nmenu].item = pMVar4;
              }
              item = w3mMenuList[nmenu].item;
              nitem = 0;
              item->type = 0;
            }
          }
          else {
            iVar5 = strcmp(pcVar3,"charset");
            if (((iVar5 == 0) || (iVar5 = strcmp(pcVar3,"encoding"), iVar5 == 0)) &&
               (pcVar3 = getQWord(&p), *pcVar3 != '\0')) {
              charset = wc_guess_charset(pcVar3,charset);
            }
          }
        }
      }
    }
  }
  return;
}



void initMenu(void)

{
  wc_ces t_ces;
  wc_ces f_ces;
  Str p_Var1;
  char *pcVar2;
  FILE *pFVar3;
  MenuItem *item;
  MenuList *list;
  FILE *mf;
  
  w3mMenuList = (MenuList *)GC_malloc(0x24);
  w3mMenuList->id = "Main";
  w3mMenuList->menu = &MainMenu;
  w3mMenuList->item = MainMenuItem;
  w3mMenuList[1].id = "Select";
  w3mMenuList[1].menu = &SelectMenu;
  w3mMenuList[1].item = (MenuItem *)0x0;
  w3mMenuList[2].id = "SelectTab";
  w3mMenuList[2].menu = &SelTabMenu;
  w3mMenuList[2].item = (MenuItem *)0x0;
  w3mMenuList[3].id = (char *)0x0;
  if (MainMenuEncode == 0) {
    MainMenuCharset = SystemCharset;
    for (item = MainMenuItem; f_ces = MainMenuCharset, t_ces = InnerCharset, item->type != 0;
        item = item + 1) {
      pcVar2 = (char *)gettext(item->label);
      p_Var1 = Strnew_charp(pcVar2);
      p_Var1 = wc_Str_conv(p_Var1,f_ces,t_ces);
      item->label = p_Var1->ptr;
    }
    MainMenuEncode = 1;
  }
  pcVar2 = confFile("menu");
  pFVar3 = fopen(pcVar2,"rt");
  if (pFVar3 != (FILE *)0x0) {
    interpret_menu((FILE *)pFVar3);
    fclose(pFVar3);
  }
  pcVar2 = rcFile("menu");
  pFVar3 = fopen(pcVar2,"rt");
  if (pFVar3 != (FILE *)0x0) {
    interpret_menu((FILE *)pFVar3);
    fclose(pFVar3);
  }
  for (list = w3mMenuList; list->id != (char *)0x0; list = list + 1) {
    if (list->item != (MenuItem *)0x0) {
      new_menu(list->menu,list->item);
    }
  }
  return;
}



int setMenuItem(MenuItem *item,char *type,char *line)

{
  int iVar1;
  char *pcVar2;
  char *pcVar3;
  char *pcVar4;
  char *pcVar5;
  int iVar6;
  int n;
  int f;
  char *data;
  char *keys;
  char *popup;
  char *func;
  char *label;
  
  if ((type == (char *)0x0) || (*type == '\0')) {
    iVar1 = -1;
  }
  else {
    iVar1 = strcmp(type,"end");
    if (iVar1 == 0) {
      item->type = 0;
      iVar1 = 0;
    }
    else {
      iVar1 = strcmp(type,"nop");
      if (iVar1 == 0) {
        item->type = 1;
        pcVar2 = getQWord(&line);
        item->label = pcVar2;
        iVar1 = 1;
      }
      else {
        iVar1 = strcmp(type,"func");
        if (iVar1 == 0) {
          pcVar2 = getQWord(&line);
          pcVar3 = getWord(&line);
          pcVar4 = getQWord(&line);
          pcVar5 = getQWord(&line);
          if (*pcVar3 == '\0') {
            iVar1 = -1;
          }
          else {
            item->type = 4;
            item->label = pcVar2;
            iVar6 = getFuncList(pcVar3);
            iVar1 = 0;
            if (-1 < iVar6) {
              iVar1 = iVar6;
            }
            item->func = (anon_subr_void_varargs_for_func *)w3mFuncList[iVar1].func;
            item->keys = pcVar4;
            item->data = pcVar5;
            iVar1 = 4;
          }
        }
        else {
          iVar1 = strcmp(type,"popup");
          if (iVar1 == 0) {
            pcVar2 = getQWord(&line);
            pcVar3 = getQWord(&line);
            pcVar4 = getQWord(&line);
            if (*pcVar3 == '\0') {
              iVar1 = -1;
            }
            else {
              item->type = 8;
              item->label = pcVar2;
              n = getMenuN(w3mMenuList,pcVar3);
              if (n == -1) {
                n = addMenuList(&w3mMenuList,pcVar3);
              }
              item->popup = w3mMenuList[n].menu;
              item->keys = pcVar4;
              iVar1 = 8;
            }
          }
          else {
            iVar1 = -1;
          }
        }
      }
    }
  }
  return iVar1;
}



int addMenuList(MenuList **mlist,char *id)

{
  MenuList *pMVar1;
  Menu *pMVar2;
  MenuItem *pMVar3;
  MenuList *list;
  int n;
  
  list = *mlist;
  n = 0;
  for (; list->id != (char *)0x0; list = list + 1) {
    n = n + 1;
  }
  pMVar1 = (MenuList *)GC_realloc(*mlist,n * 0xc + 0x18);
  *mlist = pMVar1;
  pMVar1 = *mlist + n;
  pMVar1->id = id;
  pMVar2 = (Menu *)GC_malloc(0x434);
  pMVar1->menu = pMVar2;
  pMVar3 = (MenuItem *)GC_malloc(0x20);
  pMVar1->item = pMVar3;
  pMVar1[1].id = (char *)0x0;
  return n;
}



int getMenuN(MenuList *list,char *id)

{
  int iVar1;
  int n;
  
  n = 0;
  while( true ) {
    if (list->id == (char *)0x0) {
      return -1;
    }
    iVar1 = strcmp(id,list->id);
    if (iVar1 == 0) break;
    list = list + 1;
    n = n + 1;
  }
  return n;
}



LinkList * link_menu(Buffer *buf)

{
  char **label_00;
  char *p_00;
  Str x;
  Menu menu;
  char *p;
  Str str;
  char **label;
  int linkV;
  int len;
  int nitem;
  int i;
  LinkList *l;
  
  len = 0;
  linkV = -1;
  if (buf->linklist != (LinkList *)0x0) {
    i = 0;
    for (l = buf->linklist; l != (LinkList *)0x0; l = l->next) {
      i = i + 1;
    }
    nitem = i;
    label_00 = (char **)GC_malloc((i + 1) * 4);
    i = 0;
    for (l = buf->linklist; l != (LinkList *)0x0; l = l->next) {
      if (l->title == (char *)0x0) {
        p_00 = "(empty)";
      }
      else {
        p_00 = l->title;
      }
      x = Strnew_charp(p_00);
      if (l->type == '\x01') {
        Strcat_charp(x," [Rel] ");
      }
      else if (l->type == '\x02') {
        Strcat_charp(x," [Rev] ");
      }
      else {
        Strcat_charp(x," ");
      }
      if (l->url == (char *)0x0) {
        p = "";
      }
      else if (DecodeURL == 0) {
        p = l->url;
      }
      else {
        p = url_unquote_conv(l->url,buf->document_charset);
      }
      Strcat_charp(x,p);
      label_00[i] = x->ptr;
      if (len < x->length) {
        len = x->length;
      }
      i = i + 1;
    }
    label_00[nitem] = (char *)0x0;
    set_menu_frame();
    new_option_menu(&menu,label_00,&linkV,(anon_subr_void_varargs *)0x0);
    menu.initial = 0;
    menu.cursorX = (int)buf->cursorX + (int)buf->rootX;
    menu.cursorY = (int)buf->cursorY + (int)buf->rootY;
    menu.x = menu.cursorX + FRAME_WIDTH + 1;
    menu.y = menu.cursorY + 2;
    popup_menu((Menu *)0x0,&menu);
    if (-1 < linkV) {
      i = 0;
      for (l = buf->linklist; l != (LinkList *)0x0; l = l->next) {
        if (i == linkV) {
          return l;
        }
        i = i + 1;
      }
    }
  }
  return (LinkList *)0x0;
}



Anchor * accesskey_menu(Buffer *buf)

{
  Anchor *pAVar1;
  char **label_00;
  char *pcVar2;
  Str p_Var3;
  char **ppcVar4;
  Menu menu;
  char *t;
  char **label;
  int key;
  int nitem;
  int n;
  int i;
  Anchor **ap;
  Anchor *a;
  AnchorList *al;
  uchar c;
  
  al = buf->href;
  nitem = 0;
  key = -1;
  if (al == (AnchorList *)0x0) {
    pAVar1 = (Anchor *)0x0;
  }
  else {
    for (i = 0; i < al->nanchor; i = i + 1) {
      a = al->anchors + i;
      if (((a->slave == '\0') && (a->accesskey != '\0')) &&
         ((MYCTYPE_MAP[a->accesskey] & 0x11) != 0)) {
        nitem = nitem + 1;
      }
    }
    if (nitem == 0) {
      pAVar1 = (Anchor *)0x0;
    }
    else {
      label_00 = (char **)GC_malloc((nitem + 1) * 4);
      ap = (Anchor **)GC_malloc(nitem << 2);
      n = 0;
      for (i = 0; i < al->nanchor; i = i + 1) {
        a = al->anchors + i;
        if (((a->slave == '\0') && (a->accesskey != '\0')) &&
           ((MYCTYPE_MAP[a->accesskey] & 0x11) != 0)) {
          pcVar2 = getAnchorText(buf,al,a);
          ppcVar4 = label_00 + n;
          if (pcVar2 == (char *)0x0) {
            pcVar2 = "";
          }
          p_Var3 = Sprintf("%c: %s",(uint)a->accesskey,pcVar2);
          *ppcVar4 = p_Var3->ptr;
          ap[n] = a;
          n = n + 1;
        }
      }
      label_00[nitem] = (char *)0x0;
      new_option_menu(&menu,label_00,&key,(anon_subr_void_varargs *)0x0);
      menu.initial = 0;
      menu.cursorX = (int)buf->cursorX + (int)buf->rootX;
      menu.cursorY = (int)buf->cursorY + (int)buf->rootY;
      menu.x = menu.cursorX + FRAME_WIDTH + 1;
      menu.y = menu.cursorY + 2;
      for (i = 0; i < 0x80; i = i + 1) {
        menu.keyselect[i] = -1;
      }
      for (i = 0; i < nitem; i = i + 1) {
        c = ap[i]->accesskey;
        menu.keymap[c] = mSelect;
        menu.keyselect[c] = i;
      }
      for (i = 0; i < nitem; i = i + 1) {
        c = ap[i]->accesskey;
        if (((MYCTYPE_MAP[c] & 4) != 0) && (menu.keyselect[n] < 0)) {
          if ((MYCTYPE_MAP[c] & 4) != 0) {
            c = c | 0x20;
          }
          menu.keymap[c] = mSelect;
          menu.keyselect[c] = i;
          if ((MYCTYPE_MAP[c] & 4) != 0) {
            c = c & 0xdf;
          }
          menu.keymap[c] = mSelect;
          menu.keyselect[c] = i;
        }
      }
      a = retrieveCurrentAnchor(buf);
      if (((a != (Anchor *)0x0) && (a->accesskey != '\0')) &&
         ((MYCTYPE_MAP[a->accesskey] & 0x11) != 0)) {
        for (i = 0; i < nitem; i = i + 1) {
          if (a->hseq == ap[i]->hseq) {
            menu.initial = i;
            break;
          }
        }
      }
      popup_menu((Menu *)0x0,&menu);
      if (key < 0) {
        pAVar1 = (Anchor *)0x0;
      }
      else {
        pAVar1 = ap[key];
      }
    }
  }
  return pAVar1;
}



int lmGoto(char c)

{
  if (((MYCTYPE_MAP[(byte)c] & 0x11) != 0) && (-1 < CurrentMenu->keyselect[c])) {
    goto_menu(CurrentMenu,CurrentMenu->nitem + -1,-1);
    goto_menu(CurrentMenu,CurrentMenu->keyselect[c] * 0x15,1);
  }
  return -1;
}



int lmSelect(char c)

{
  int iVar1;
  
  if ((MYCTYPE_MAP[(byte)c] & 0x11) == 0) {
    iVar1 = -1;
  }
  else {
    iVar1 = select_menu(CurrentMenu,
                        ((uint)CurrentMenu->select / 0x15) * 0x15 + CurrentMenu->keyselect[c]);
  }
  return iVar1;
}



Anchor * list_menu(Buffer *buf)

{
  bool bVar1;
  Anchor *pAVar2;
  char **label_00;
  Str p_Var3;
  char **ppcVar4;
  Menu menu;
  char *t;
  char **label;
  int two;
  int key;
  int nitem;
  int n;
  int i;
  Anchor **ap;
  Anchor *a;
  AnchorList *al;
  uchar c;
  
  al = buf->href;
  nitem = 0;
  key = -1;
  if (al == (AnchorList *)0x0) {
    pAVar2 = (Anchor *)0x0;
  }
  else {
    for (i = 0; i < al->nanchor; i = i + 1) {
      a = al->anchors + i;
      if (a->slave == '\0') {
        nitem = nitem + 1;
      }
    }
    if (nitem == 0) {
      pAVar2 = (Anchor *)0x0;
    }
    else {
      bVar1 = (uint)nitem < 0x15;
      label_00 = (char **)GC_malloc((nitem + 1) * 4);
      ap = (Anchor **)GC_malloc(nitem << 2);
      n = 0;
      for (i = 0; i < al->nanchor; i = i + 1) {
        a = al->anchors + i;
        if (a->slave == '\0') {
          t = getAnchorText(buf,al,a);
          if (t == (char *)0x0) {
            t = "";
          }
          if ((bVar1) || ((uint)n < 0x2b5)) {
            if (bVar1) {
              ppcVar4 = label_00 + n;
              p_Var3 = Sprintf("%c: %s",(int)lmKeys[n],t);
              *ppcVar4 = p_Var3->ptr;
            }
            else {
              ppcVar4 = label_00 + n;
              p_Var3 = Sprintf("%c%c: %s",(int)lmKeys2[(uint)n / 0x15],(int)lmKeys[(uint)n % 0x15],t
                              );
              *ppcVar4 = p_Var3->ptr;
            }
          }
          else {
            ppcVar4 = label_00 + n;
            p_Var3 = Sprintf("  : %s",t);
            *ppcVar4 = p_Var3->ptr;
          }
          ap[n] = a;
          n = n + 1;
        }
      }
      label_00[nitem] = (char *)0x0;
      set_menu_frame();
      set_menu_frame();
      new_option_menu(&menu,label_00,&key,(anon_subr_void_varargs *)0x0);
      menu.initial = 0;
      menu.cursorX = (int)buf->cursorX + (int)buf->rootX;
      menu.cursorY = (int)buf->cursorY + (int)buf->rootY;
      menu.x = menu.cursorX + FRAME_WIDTH + 1;
      menu.y = menu.cursorY + 2;
      for (i = 0; i < 0x80; i = i + 1) {
        menu.keyselect[i] = -1;
      }
      if (bVar1) {
        for (i = 0; i < nitem; i = i + 1) {
          c = lmKeys[i];
          menu.keymap[c] = mSelect;
          menu.keyselect[c] = i;
        }
      }
      else {
        for (i = 0; (uint)i < 0x21; i = i + 1) {
          c = lmKeys2[i];
          menu.keymap[c] = lmGoto;
          menu.keyselect[c] = i;
        }
        for (i = 0; (uint)i < 0x15; i = i + 1) {
          c = lmKeys[i];
          menu.keymap[c] = lmSelect;
          menu.keyselect[c] = i;
        }
      }
      a = retrieveCurrentAnchor(buf);
      if (a != (Anchor *)0x0) {
        for (i = 0; i < nitem; i = i + 1) {
          if (a->hseq == ap[i]->hseq) {
            menu.initial = i;
            break;
          }
        }
      }
      popup_menu((Menu *)0x0,&menu);
      if (key < 0) {
        pAVar2 = (Anchor *)0x0;
      }
      else {
        pAVar2 = ap[key];
      }
    }
  }
  return pAVar2;
}



int mailcapMatch(mailcap *mcap,char *type)

{
  byte bVar1;
  byte bVar2;
  int iVar3;
  int level;
  char *p;
  char *cap;
  
  p = mcap->type;
  while( true ) {
    if (*p == '/') {
      if (*type == '/') {
        p = p + 1;
        level = (int)((mcap->flags & 4U) != 0);
        if (*p == '*') {
          iVar3 = level + 10;
        }
        else {
          for (; type = type + 1, *p != '\0'; p = p + 1) {
            if ((MYCTYPE_MAP[(byte)*p] & 4) == 0) {
              bVar1 = *p;
            }
            else {
              bVar1 = *p | 0x20;
            }
            if ((MYCTYPE_MAP[(byte)*type] & 4) == 0) {
              bVar2 = *type;
            }
            else {
              bVar2 = *type | 0x20;
            }
            if (bVar1 != bVar2) {
              return 0;
            }
          }
          if (*type == '\0') {
            iVar3 = level + 0x14;
          }
          else {
            iVar3 = 0;
          }
        }
      }
      else {
        iVar3 = 0;
      }
      return iVar3;
    }
    if ((MYCTYPE_MAP[(byte)*p] & 4) == 0) {
      bVar1 = *p;
    }
    else {
      bVar1 = *p | 0x20;
    }
    if ((MYCTYPE_MAP[(byte)*type] & 4) == 0) {
      bVar2 = *type;
    }
    else {
      bVar2 = *type | 0x20;
    }
    if (bVar1 != bVar2) break;
    type = type + 1;
    p = p + 1;
  }
  return 0;
}



mailcap * searchMailcap(mailcap *table,char *type)

{
  int iVar1;
  Str p_Var2;
  int iVar3;
  Str command;
  int i;
  mailcap *mcap;
  int level;
  
  level = 0;
  mcap = (mailcap *)0x0;
  if (table == (mailcap *)0x0) {
    mcap = (mailcap *)0x0;
  }
  else {
    for (; table->type != (char *)0x0; table = table + 1) {
      iVar1 = mailcapMatch(table,type);
      if (level < iVar1) {
        if (table->test != (char *)0x0) {
          p_Var2 = unquote_mailcap(table->test,type,(char *)0x0,(char *)0x0,(int *)0x0);
          iVar3 = system(p_Var2->ptr);
          if (iVar3 != 0) goto LAB_08098684;
        }
        mcap = table;
        level = iVar1;
      }
LAB_08098684:
    }
  }
  return mcap;
}



int matchMailcapAttr(char *p,char *attr,int len,Str *value)

{
  bool bVar1;
  int iVar2;
  Str p_Var3;
  char *q;
  int quoted;
  
  q = (char *)0x0;
  iVar2 = strncasecmp(p,attr,len);
  if (iVar2 == 0) {
    p = p + len;
    while ((*p != '\0' && ((MYCTYPE_MAP[(byte)*p] & 2) != 0))) {
      p = p + 1;
    }
    if (value != (Str *)0x0) {
      p_Var3 = Strnew();
      *value = p_Var3;
      if (*p == '=') {
        do {
          p = p + 1;
          if (*p == '\0') break;
        } while ((MYCTYPE_MAP[(byte)*p] & 2) != 0);
        bVar1 = false;
        for (; (*p != '\0' && ((bVar1 || (*p != ';')))); p = p + 1) {
          if ((bVar1) || ((MYCTYPE_MAP[(byte)*p] & 2) == 0)) {
            q = p;
          }
          if (bVar1) {
            bVar1 = false;
          }
          else if (*p == '\\') {
            bVar1 = true;
          }
          if ((*value)->area_size <= (*value)->length + 1) {
            Strgrow(*value);
          }
          p_Var3 = *value;
          iVar2 = p_Var3->length;
          (*value)->ptr[iVar2] = *p;
          p_Var3->length = iVar2 + 1;
          (*value)->ptr[(*value)->length] = '\0';
        }
        if (q != (char *)0x0) {
          Strshrink(*value,(int)(p + (-1 - (int)q)));
        }
      }
      return 1;
    }
    if ((*p == '\0') || (*p == ';')) {
      return 1;
    }
  }
  return 0;
}



int extractMailcapEntry(char *mcap_entry,mailcap *mcap)

{
  char *pcVar1;
  int iVar2;
  Str tmp;
  int quoted;
  char *p;
  int k;
  int j;
  
  bzero(mcap,0x18);
  p = mcap_entry;
  while ((*p != '\0' && ((MYCTYPE_MAP[(byte)*p] & 2) != 0))) {
    p = p + 1;
  }
  k = -1;
  for (j = 0; (p[j] != '\0' && (p[j] != ';')); j = j + 1) {
    if ((MYCTYPE_MAP[(byte)p[j]] & 2) == 0) {
      k = j;
    }
  }
  iVar2 = j;
  if (-1 < k) {
    iVar2 = k + 1;
  }
  pcVar1 = allocStr(p,iVar2);
  mcap->type = pcVar1;
  if (p[j] == '\0') {
    iVar2 = 0;
  }
  else {
    p = p + j + 1;
    while ((*p != '\0' && ((MYCTYPE_MAP[(byte)*p] & 2) != 0))) {
      p = p + 1;
    }
    k = -1;
    quoted = 0;
    for (j = 0; (p[j] != '\0' && ((quoted != 0 || (p[j] != ';')))); j = j + 1) {
      if ((quoted != 0) || ((MYCTYPE_MAP[(byte)p[j]] & 2) == 0)) {
        k = j;
      }
      if (quoted == 0) {
        if (p[j] == '\\') {
          quoted = 1;
        }
      }
      else {
        quoted = 0;
      }
    }
    iVar2 = j;
    if (-1 < k) {
      iVar2 = k + 1;
    }
    pcVar1 = allocStr(p,iVar2);
    mcap->viewer = pcVar1;
    p = p + j;
    while (*p == ';') {
      do {
        p = p + 1;
        if (*p == '\0') break;
      } while ((MYCTYPE_MAP[(byte)*p] & 2) != 0);
      iVar2 = matchMailcapAttr(p,"needsterminal",0xd,(Str *)0x0);
      if (iVar2 == 0) {
        iVar2 = matchMailcapAttr(p,"copiousoutput",0xd,(Str *)0x0);
        if (iVar2 == 0) {
          iVar2 = matchMailcapAttr(p,"x-htmloutput",0xc,(Str *)0x0);
          if ((iVar2 == 0) && (iVar2 = matchMailcapAttr(p,"htmloutput",10,(Str *)0x0), iVar2 == 0))
          {
            iVar2 = matchMailcapAttr(p,"test",4,&tmp);
            if (iVar2 == 0) {
              iVar2 = matchMailcapAttr(p,"nametemplate",0xc,&tmp);
              if (iVar2 == 0) {
                iVar2 = matchMailcapAttr(p,"edit",4,&tmp);
                if (iVar2 != 0) {
                  pcVar1 = allocStr(tmp->ptr,tmp->length);
                  mcap->edit = pcVar1;
                }
              }
              else {
                pcVar1 = allocStr(tmp->ptr,tmp->length);
                mcap->nametemplate = pcVar1;
              }
            }
            else {
              pcVar1 = allocStr(tmp->ptr,tmp->length);
              mcap->test = pcVar1;
            }
          }
          else {
            mcap->flags = mcap->flags | 4;
          }
        }
        else {
          mcap->flags = mcap->flags | 2;
        }
      }
      else {
        mcap->flags = mcap->flags | 1;
      }
      quoted = 0;
      for (; (*p != '\0' && ((quoted != 0 || (*p != ';')))); p = p + 1) {
        if (quoted == 0) {
          if (*p == '\\') {
            quoted = 1;
          }
        }
        else {
          quoted = 0;
        }
      }
    }
    iVar2 = 1;
  }
  return iVar2;
}



mailcap * loadMailcap(char *filename)

{
  char *__filename;
  FILE *__stream;
  mailcap *pmVar1;
  Str p_Var2;
  uint uVar3;
  Str y;
  int iVar4;
  mailcap *mcap;
  Str tmp;
  int n;
  int i;
  FILE *f;
  
  __filename = expandPath(filename);
  __stream = fopen(__filename,"r");
  if (__stream == (FILE *)0x0) {
    pmVar1 = (mailcap *)0x0;
  }
  else {
    i = 0;
    while (p_Var2 = Strfgets((FILE *)__stream), 0 < p_Var2->length) {
      if (*p_Var2->ptr != '#') {
        i = i + 1;
      }
    }
    fseek(__stream,0,0);
    pmVar1 = (mailcap *)GC_malloc((i + 1) * 0x18);
    i = 0;
    while (p_Var2 = Strfgets((FILE *)__stream), 0 < p_Var2->length) {
      if (*p_Var2->ptr != '#') {
        while( true ) {
          while( true ) {
            if (p_Var2->length < 1) {
              uVar3 = 0;
            }
            else {
              uVar3 = (uint)(byte)p_Var2->ptr[p_Var2->length + -1];
            }
            if ((MYCTYPE_MAP[uVar3] & 2) == 0) break;
            Strshrink(p_Var2,1);
          }
          if ((p_Var2->length < 1) || (p_Var2->ptr[p_Var2->length + -1] != '\\')) break;
          Strshrink(p_Var2,1);
          y = Strfgets((FILE *)__stream);
          Strcat(p_Var2,y);
        }
        iVar4 = extractMailcapEntry(p_Var2->ptr,pmVar1 + i);
        if (iVar4 != 0) {
          i = i + 1;
        }
      }
    }
    bzero(pmVar1 + i,0x18);
    fclose(__stream);
  }
  return pmVar1;
}



void initMailcap(void)

{
  mailcap **ppmVar1;
  int iVar2;
  mailcap *pmVar3;
  int i;
  TextListItem *tl;
  
  iVar2 = non_null(mailcap_files);
  if (iVar2 == 0) {
    mailcap_list = (TextList *)0x0;
  }
  else {
    mailcap_list = make_domain_list(mailcap_files);
  }
  if (mailcap_list != (TextList *)0x0) {
    UserMailcap = (mailcap **)GC_malloc((int)mailcap_list->nitem << 2);
    i = 0;
    for (tl = mailcap_list->first; tl != (TextListItem *)0x0; tl = tl->next) {
      ppmVar1 = UserMailcap + i;
      pmVar3 = loadMailcap(tl->ptr);
      *ppmVar1 = pmVar3;
      i = i + 1;
    }
  }
  return;
}



char * acceptableMimeTypes(void)

{
  GeneralList *tl;
  Hash_si *t;
  char *pcVar1;
  int iVar2;
  char *s;
  char *mt;
  mailcap *mp;
  int i;
  char *p;
  Hash_si *mhash;
  TextList *l;
  
  if (acceptableMimeTypes::types == (Str)0x0) {
    tl = newGeneralList();
    t = newHash_si(0x10);
    putHash_si(t,"text",1);
    pcVar1 = allocStr("image",-1);
    pushValue(tl,pcVar1);
    putHash_si(t,"image",1);
    for (i = 0; i < mailcap_list->nitem; i = i + 1) {
      mp = UserMailcap[i];
      if (mp != (mailcap *)0x0) {
        for (; mp->type != (char *)0x0; mp = mp + 1) {
          pcVar1 = strchr(mp->type,0x2f);
          if (pcVar1 != (char *)0x0) {
            pcVar1 = allocStr(mp->type,(int)pcVar1 - (int)mp->type);
            iVar2 = getHash_si(t,pcVar1,0);
            if (iVar2 == 0) {
              s = allocStr(pcVar1,-1);
              pushValue(tl,s);
              putHash_si(t,pcVar1,1);
            }
          }
        }
      }
    }
    acceptableMimeTypes::types = Strnew();
    Strcat_charp(acceptableMimeTypes::types,"text/html, text/*;q=0.5");
    while (pcVar1 = (char *)popValue(tl), pcVar1 != (char *)0x0) {
      Strcat_charp(acceptableMimeTypes::types,", ");
      Strcat_charp(acceptableMimeTypes::types,pcVar1);
      Strcat_charp(acceptableMimeTypes::types,"/*");
    }
    pcVar1 = acceptableMimeTypes::types->ptr;
  }
  else {
    pcVar1 = acceptableMimeTypes::types->ptr;
  }
  return pcVar1;
}



mailcap * searchExtViewer(char *type)

{
  mailcap *pmVar1;
  int i;
  mailcap *p;
  
  if (mailcap_list != (TextList *)0x0) {
    for (i = 0; i < mailcap_list->nitem; i = i + 1) {
      pmVar1 = searchMailcap(UserMailcap[i],type);
      if (pmVar1 != (mailcap *)0x0) {
        return pmVar1;
      }
    }
  }
  pmVar1 = searchMailcap(DefaultMailcap,type);
  return pmVar1;
}



Str quote_mailcap(char *s,int flag)

{
  int iVar1;
  Str x;
  Str d;
  
  x = Strnew();
  do {
    switch(*s) {
    case '\0':
      return x;
    default:
switchD_08099179_caseD_1:
      if ((flag == 0) && ((MYCTYPE_MAP[(byte)*s] & 0xc) == 0)) {
        if (x->area_size <= x->length + 1) {
          Strgrow(x);
        }
        iVar1 = x->length;
        x->ptr[iVar1] = '\\';
        x->length = iVar1 + 1;
        x->ptr[x->length] = '\0';
      }
    case '.':
    case '/':
    case ':':
    case '_':
      if (x->area_size <= x->length + 1) {
        Strgrow(x);
      }
      iVar1 = x->length;
      x->ptr[iVar1] = *s;
      x->length = iVar1 + 1;
      x->ptr[x->length] = '\0';
      break;
    case '\"':
    case '$':
    case '\\':
    case '`':
      if ((flag & 1U) == 0) {
        if (x->area_size <= x->length + 1) {
          Strgrow(x);
        }
        iVar1 = x->length;
        x->ptr[iVar1] = '\\';
        x->length = iVar1 + 1;
        x->ptr[x->length] = '\0';
      }
      if (x->area_size <= x->length + 1) {
        Strgrow(x);
      }
      iVar1 = x->length;
      x->ptr[iVar1] = *s;
      x->length = iVar1 + 1;
      x->ptr[x->length] = '\0';
      break;
    case '\'':
      if ((flag & 1U) == 0) goto switchD_08099179_caseD_1;
      Strcat_charp(x,"\'\\\'\'");
    }
    s = s + 1;
  } while( true );
}



Str unquote_mailcap_loop(char *qstr,char *type,char *name,char *attr,int *mc_stat,int flag0)

{
  char *p_00;
  int iVar1;
  Str p_Var2;
  char *q;
  int flag;
  int sp;
  int prev_status;
  int status;
  char *p;
  Str then;
  Str test;
  Str tmp;
  Str str;
  
  status = 0;
  prev_status = 0;
  sp = 0;
  if (mc_stat != (int *)0x0) {
    *mc_stat = 0;
  }
  if (qstr == (char *)0x0) {
    str = (Str)0x0;
  }
  else {
    str = Strnew();
    tmp = (Str)0x0;
    flag = flag0;
    for (p = qstr; *p != '\0'; p = p + 1) {
      if (status == 3) {
        if (prev_status == 2) {
          if (tmp->area_size <= tmp->length + 1) {
            Strgrow(tmp);
          }
          iVar1 = tmp->length;
          tmp->ptr[iVar1] = *p;
          tmp->length = iVar1 + 1;
          tmp->ptr[tmp->length] = '\0';
        }
        else {
          if (str->area_size <= str->length + 1) {
            Strgrow(str);
          }
          iVar1 = str->length;
          str->ptr[iVar1] = *p;
          str->length = iVar1 + 1;
          str->ptr[str->length] = '\0';
        }
        status = prev_status;
      }
      else if (*p == '\\') {
        prev_status = status;
        status = 3;
      }
      else if (status == 1) {
        if ((MYCTYPE_MAP[(byte)*p] & 4) == 0) {
          if (*p == '{') {
            status = 2;
            tmp = Strnew();
          }
          else if (*p == '%') {
            if (str->area_size <= str->length + 1) {
              Strgrow(str);
            }
            iVar1 = str->length;
            str->ptr[iVar1] = *p;
            str->length = iVar1 + 1;
            str->ptr[str->length] = '\0';
          }
        }
        else {
          if (*p == 's') {
            if (name != (char *)0x0) {
              p_Var2 = quote_mailcap(name,flag);
              Strcat_charp(str,p_Var2->ptr);
              if (mc_stat != (int *)0x0) {
                *mc_stat = *mc_stat | 1;
              }
            }
          }
          else if ((*p == 't') && (type != (char *)0x0)) {
            p_Var2 = quote_mailcap(type,flag);
            Strcat_charp(str,p_Var2->ptr);
            if (mc_stat != (int *)0x0) {
              *mc_stat = *mc_stat | 2;
            }
          }
          status = 0;
        }
      }
      else if (status == 2) {
        if ((sp < 1) && (*p != '{')) {
          if (*p == '}') {
            if ((((attr != (char *)0x0) && (p_00 = strcasestr(attr,tmp->ptr), p_00 != (char *)0x0))
                && ((p_00 == attr || (((MYCTYPE_MAP[(byte)p_00[-1]] & 2) != 0 || (p_00[-1] == ';')))
                    ))) && (iVar1 = matchattr(p_00,tmp->ptr,tmp->length,&tmp), iVar1 != 0)) {
              p_Var2 = quote_mailcap(tmp->ptr,flag);
              Strcat_charp(str,p_Var2->ptr);
              if (mc_stat != (int *)0x0) {
                *mc_stat = *mc_stat | 4;
              }
            }
            status = 0;
          }
          else {
            if (tmp->area_size <= tmp->length + 1) {
              Strgrow(tmp);
            }
            iVar1 = tmp->length;
            tmp->ptr[iVar1] = *p;
            tmp->length = iVar1 + 1;
            tmp->ptr[tmp->length] = '\0';
          }
        }
        else {
          if (tmp->area_size <= tmp->length + 1) {
            Strgrow(tmp);
          }
          iVar1 = tmp->length;
          tmp->ptr[iVar1] = *p;
          tmp->length = iVar1 + 1;
          tmp->ptr[tmp->length] = '\0';
          if (*p == '{') {
            sp = sp + 1;
          }
          else if (*p == '}') {
            sp = sp + -1;
          }
        }
      }
      else if (status == 0) {
        if (*p == '%') {
          status = 1;
        }
        else {
          if (*p == '\'') {
            if ((flag0 == 0) && ((flag & 1U) != 0)) {
              flag = flag & 0xfffffffe;
            }
            else if (flag == 0) {
              flag = 1;
            }
          }
          else if (*p == '\"') {
            if ((flag0 == 0) && ((flag & 2U) != 0)) {
              flag = flag & 0xfffffffd;
            }
            else if (flag == 0) {
              flag = 2;
            }
          }
          if (str->area_size <= str->length + 1) {
            Strgrow(str);
          }
          iVar1 = str->length;
          str->ptr[iVar1] = *p;
          str->length = iVar1 + 1;
          str->ptr[str->length] = '\0';
        }
      }
    }
  }
  return str;
}



Str unquote_mailcap(char *qstr,char *type,char *name,char *attr,int *mc_stat)

{
  Str p_Var1;
  
  p_Var1 = unquote_mailcap_loop(qstr,type,name,attr,mc_stat,0);
  return p_Var1;
}



void initImage(void)

{
  int iVar1;
  
  if (activeImage == 0) {
    iVar1 = getCharSize();
    if (iVar1 != 0) {
      activeImage = 1;
    }
  }
  return;
}



int getCharSize(void)

{
  char *pcVar1;
  int iVar2;
  int h;
  int w;
  Str tmp;
  FILE *f;
  
  w = 0;
  h = 0;
  pcVar1 = ttyname_tty();
  set_environ("W3M_TTY",pcVar1);
  tmp = Strnew();
  pcVar1 = strchr(Imgdisplay,0x2f);
  if (pcVar1 == (char *)0x0) {
    pcVar1 = w3m_auxbin_dir();
    Strcat_m_charp(tmp,pcVar1,&DAT_080ce928,0);
  }
  Strcat_m_charp(tmp,Imgdisplay," -test 2>/dev/null",0);
  f = (FILE *)popen(tmp->ptr,"r");
  if ((FILE *)f == (FILE *)0x0) {
    iVar2 = 0;
  }
  else {
    do {
      iVar2 = fscanf((FILE *)f,"%d %d",&w,&h);
      if (-1 < iVar2) break;
      iVar2 = feof((FILE *)f);
    } while (iVar2 == 0);
    pclose((FILE *)f);
    if ((w < 1) || (h < 1)) {
      iVar2 = 0;
    }
    else {
      if (set_pixel_per_char == 0) {
        pixel_per_char = (double)(int)ROUND((double)w / (double)COLS + 0.5);
      }
      if (set_pixel_per_line == 0) {
        pixel_per_line = (double)(int)ROUND((double)h / (double)LINES + 0.5);
      }
      iVar2 = 1;
    }
  }
  return iVar2;
}



void termImage(void)

{
  if (activeImage != 0) {
    clearImage();
    if (Imgdisplay_wf != (FILE *)0x0) {
      fwrite(&DAT_080ce945,1,3,(FILE *)Imgdisplay_wf);
      fflush((FILE *)Imgdisplay_wf);
    }
    closeImgdisplay();
  }
  return;
}



int openImgdisplay(void)

{
  char *pcVar1;
  char *pcVar2;
  Str p_Var3;
  int iVar4;
  char *cmd;
  
  Imgdisplay_pid = open_pipe_rw(&Imgdisplay_rf,&Imgdisplay_wf);
  if (Imgdisplay_pid < 0) {
    Imgdisplay_pid = 0;
    activeImage = 0;
    iVar4 = 0;
  }
  else {
    if (Imgdisplay_pid == 0) {
      setup_child(0,2,-1);
      pcVar2 = strchr(Imgdisplay,0x2f);
      pcVar1 = Imgdisplay;
      if (pcVar2 == (char *)0x0) {
        pcVar2 = w3m_auxbin_dir();
        p_Var3 = Strnew_m_charp(pcVar2,&DAT_080ce928,pcVar1,0);
        cmd = p_Var3->ptr;
      }
      else {
        cmd = Imgdisplay;
      }
      myExec(cmd);
    }
    activeImage = 1;
    iVar4 = 1;
  }
  return iVar4;
}



void closeImgdisplay(void)

{
  if (Imgdisplay_rf != (FILE *)0x0) {
    fclose((FILE *)Imgdisplay_rf);
  }
  if (Imgdisplay_wf != (FILE *)0x0) {
    fclose((FILE *)Imgdisplay_wf);
  }
  if (Imgdisplay_pid != 0) {
    kill(Imgdisplay_pid,9);
  }
  Imgdisplay_rf = (FILE *)0x0;
  Imgdisplay_wf = (FILE *)0x0;
  Imgdisplay_pid = 0;
  return;
}



void addImage(ImageCache *cache,int x,int y,int sx,int sy,int w,int h)

{
  TerminalImage *pTVar1;
  TerminalImage *i;
  
  if (activeImage != 0) {
    if (max_terminal_image <= n_terminal_image) {
      if (max_terminal_image == 0) {
        max_terminal_image = 8;
      }
      else {
        max_terminal_image = max_terminal_image * 2;
      }
      terminal_image = (TerminalImage *)GC_realloc(terminal_image,max_terminal_image << 4);
    }
    pTVar1 = terminal_image + n_terminal_image;
    pTVar1->cache = cache;
    pTVar1->x = (short)x;
    pTVar1->y = (short)y;
    pTVar1->sx = (short)sx;
    pTVar1->sy = (short)sy;
    pTVar1->width = (short)w;
    pTVar1->height = (short)h;
    n_terminal_image = n_terminal_image + 1;
  }
  return;
}



void syncImage(void)

{
  int iVar1;
  
  fwrite(&DAT_080ce949,1,3,(FILE *)Imgdisplay_wf);
  fwrite(&DAT_080ce94d,1,3,(FILE *)Imgdisplay_wf);
  do {
    iVar1 = fflush((FILE *)Imgdisplay_wf);
    if (iVar1 == 0) {
      iVar1 = fgetc((FILE *)Imgdisplay_rf);
      if (iVar1 != 0) {
        return;
      }
      break;
    }
    iVar1 = ferror((FILE *)Imgdisplay_wf);
  } while (iVar1 == 0);
  closeImgdisplay();
  image_index = image_index + 1000;
  n_terminal_image = 0;
  return;
}



void drawImage(void)

{
  bool bVar1;
  short sVar2;
  short sVar3;
  TerminalImage *pTVar4;
  int iVar5;
  TerminalImage *i;
  int draw;
  int j;
  
  bVar1 = false;
  if ((activeImage != 0) && (n_terminal_image != 0)) {
    for (j = 0; j < n_terminal_image; j = j + 1) {
      pTVar4 = terminal_image + j;
      if ((((pTVar4->cache->loaded & 1U) != 0) && (0 < pTVar4->width)) && (0 < pTVar4->height)) {
        if (((Imgdisplay_rf == (FILE *)0x0) || (Imgdisplay_wf == (FILE *)0x0)) &&
           (iVar5 = openImgdisplay(), iVar5 == 0)) {
          return;
        }
        if (pTVar4->cache->index < 1) {
          fwrite(&DAT_080ce954,1,2,(FILE *)Imgdisplay_wf);
        }
        else {
          pTVar4->cache->index = -pTVar4->cache->index;
          fwrite(&DAT_080ce951,1,2,(FILE *)Imgdisplay_wf);
        }
        sVar2 = pTVar4->cache->height;
        if (sVar2 < 0) {
          sVar2 = 0;
        }
        sVar3 = pTVar4->cache->width;
        if (sVar3 < 0) {
          sVar3 = 0;
        }
        sprintf(drawImage::buf,"%d;%d;%d;%d;%d;%d;%d;%d;%d;",~pTVar4->cache->index % 1000 + 1,
                (int)pTVar4->x,(int)pTVar4->y,(int)sVar3,(int)sVar2,(int)pTVar4->sx,(int)pTVar4->sy,
                (int)pTVar4->width,(int)pTVar4->height);
        fputs(drawImage::buf,(FILE *)Imgdisplay_wf);
        fputs(pTVar4->cache->file,(FILE *)Imgdisplay_wf);
        fputc(10,(FILE *)Imgdisplay_wf);
        bVar1 = true;
      }
    }
    if (bVar1) {
      syncImage();
      touch_cursor();
      refresh();
    }
  }
  return;
}



void clearImage(void)

{
  TerminalImage *pTVar1;
  TerminalImage *i;
  int j;
  
  if ((activeImage != 0) && (n_terminal_image != 0)) {
    if (Imgdisplay_wf == (FILE *)0x0) {
      n_terminal_image = 0;
    }
    else {
      for (j = 0; j < n_terminal_image; j = j + 1) {
        pTVar1 = terminal_image + j;
        if ((((pTVar1->cache->loaded & 1U) != 0) && (0 < pTVar1->width)) && (0 < pTVar1->height)) {
          sprintf(clearImage::buf,"6;%d;%d;%d;%d\n",(int)pTVar1->x,(int)pTVar1->y,(int)pTVar1->width
                  ,(int)pTVar1->height);
          fputs(clearImage::buf,(FILE *)Imgdisplay_wf);
        }
      }
      syncImage();
      n_terminal_image = 0;
    }
  }
  return;
}



void deleteImage(Buffer *buf)

{
  AnchorList *pAVar1;
  int i;
  Anchor *a;
  AnchorList *al;
  
  if ((buf != (Buffer *)0x0) && (pAVar1 = buf->img, pAVar1 != (AnchorList *)0x0)) {
    i = 0;
    a = pAVar1->anchors;
    for (; i < pAVar1->nanchor; i = i + 1) {
      if ((((a->image != (Image *)0x0) && (a->image->cache != (ImageCache *)0x0)) &&
          (a->image->cache->loaded != '\0')) &&
         (((a->image->cache->loaded & 4U) == 0 && (a->image->cache->index < 0)))) {
        unlink(a->image->cache->file);
      }
      a = a + 1;
    }
    loadImage((Buffer *)0x0,1);
  }
  return;
}



void getAllImage(Buffer *buf)

{
  AnchorList *pAVar1;
  Image *pIVar2;
  ParsedURL *current_00;
  ImageCache *pIVar3;
  int i;
  ParsedURL *current;
  Anchor *a;
  AnchorList *al;
  
  image_buffer = buf;
  if (buf != (Buffer *)0x0) {
    buf->image_loaded = '\x01';
    pAVar1 = buf->img;
    if (pAVar1 != (AnchorList *)0x0) {
      current_00 = baseURL(buf);
      i = 0;
      a = pAVar1->anchors;
      for (; i < pAVar1->nanchor; i = i + 1) {
        if (a->image != (Image *)0x0) {
          pIVar2 = a->image;
          pIVar3 = getImage(a->image,current_00,(int)buf->image_flag);
          pIVar2->cache = pIVar3;
          if ((a->image->cache != (ImageCache *)0x0) && (a->image->cache->loaded == '\0')) {
            buf->image_loaded = '\0';
          }
        }
        a = a + 1;
      }
    }
  }
  return;
}



void showImageProgress(Buffer *buf)

{
  short sVar1;
  short sVar2;
  short sVar3;
  short sVar4;
  AnchorList *pAVar5;
  Str p_Var6;
  int n;
  int l;
  int i;
  Anchor *a;
  AnchorList *al;
  
  if ((buf != (Buffer *)0x0) && (pAVar5 = buf->img, pAVar5 != (AnchorList *)0x0)) {
    i = 0;
    l = 0;
    n = 0;
    a = pAVar5->anchors;
    for (; i < pAVar5->nanchor; i = i + 1) {
      if ((((a->image != (Image *)0x0) && (-1 < a->hseq)) &&
          (n = n + 1, a->image->cache != (ImageCache *)0x0)) &&
         ((a->image->cache->loaded & 1U) != 0)) {
        l = l + 1;
      }
      a = a + 1;
    }
    if (n != 0) {
      sVar1 = buf->cursorY;
      sVar2 = buf->rootY;
      sVar3 = buf->cursorX;
      sVar4 = buf->rootX;
      p_Var6 = Sprintf("%d/%d images loaded",l,n);
      message(p_Var6->ptr,(int)sVar3 + (int)sVar4,(int)sVar1 + (int)sVar2);
      refresh();
    }
  }
  return;
}



void loadImage(Buffer *buf,int flag)

{
  bool bVar1;
  ImageCache *pIVar2;
  __pid_t _Var3;
  Buffer *pBVar4;
  int iVar5;
  stat st;
  Buffer *b;
  int draw;
  int i;
  ImageCache *cache;
  
  bVar1 = false;
  if (maxLoadImage < 9) {
    if (maxLoadImage < 1) {
      maxLoadImage = 1;
    }
  }
  else {
    maxLoadImage = 8;
  }
  if (n_load_image == 0) {
    n_load_image = maxLoadImage;
  }
  if (image_cache == (ImageCache **)0x0) {
    image_cache = (ImageCache **)GC_malloc(0x20);
    bzero(image_cache,0x20);
  }
  for (i = 0; i < n_load_image; i = i + 1) {
    pIVar2 = image_cache[i];
    if ((pIVar2 != (ImageCache *)0x0) && (iVar5 = lstat(pIVar2->touch,(stat *)&st), iVar5 == 0)) {
      if (pIVar2->pid != 0) {
        kill(pIVar2->pid,9);
        pIVar2->pid = 0;
      }
      iVar5 = stat(pIVar2->file,(stat *)&st);
      if (iVar5 == 0) {
        pIVar2->loaded = '\x01';
        iVar5 = getImageSize(pIVar2);
        if ((iVar5 != 0) && (image_buffer != (Buffer *)0x0)) {
          image_buffer->need_reshape = '\x01';
        }
        bVar1 = true;
      }
      else {
        pIVar2->loaded = '\x02';
      }
      unlink(pIVar2->touch);
      image_cache[i] = (ImageCache *)0x0;
    }
  }
  i = maxLoadImage;
  if (buf != image_buffer) {
    i = 0;
  }
  for (; i < n_load_image; i = i + 1) {
    pIVar2 = image_cache[i];
    if (pIVar2 != (ImageCache *)0x0) {
      if (pIVar2->pid != 0) {
        kill(pIVar2->pid,9);
        pIVar2->pid = 0;
      }
      unlink(pIVar2->touch);
      image_cache[i] = (ImageCache *)0x0;
    }
  }
  if (flag == 1) {
    image_list = (GeneralList *)0x0;
    image_file = (Hash_sv *)0x0;
    n_load_image = maxLoadImage;
    image_buffer = (Buffer *)0x0;
  }
  else {
    if ((bVar1) && (image_buffer != (Buffer *)0x0)) {
      drawImage();
      showImageProgress(image_buffer);
    }
    image_buffer = buf;
    if (image_list != (GeneralList *)0x0) {
      for (i = 0; i < n_load_image; i = i + 1) {
        if (image_cache[i] == (ImageCache *)0x0) {
          do {
            pIVar2 = (ImageCache *)popValue(image_list);
            if (pIVar2 == (ImageCache *)0x0) {
              i = 0;
              while( true ) {
                if (n_load_image <= i) {
                  image_list = (GeneralList *)0x0;
                  image_file = (Hash_sv *)0x0;
                  if (image_buffer == (Buffer *)0x0) {
                    image_file = (Hash_sv *)0x0;
                    image_list = (GeneralList *)0x0;
                    return;
                  }
                  displayBuffer(image_buffer,0);
                  return;
                }
                if (image_cache[i] != (ImageCache *)0x0) break;
                i = i + 1;
              }
              return;
            }
          } while (pIVar2->loaded != '\0');
          image_cache[i] = pIVar2;
          flush_tty();
          _Var3 = fork();
          pIVar2->pid = _Var3;
          if (pIVar2->pid == 0) {
            setup_child(0,0,-1);
            image_source = pIVar2->file;
            pBVar4 = loadGeneralFile(pIVar2->url,pIVar2->current,(char *)0x0,0,(FormList *)0x0);
            if (((pBVar4 == (Buffer *)0x0) || (pBVar4->real_type == (char *)0x0)) ||
               (iVar5 = strncasecmp(pBVar4->real_type,"image/",6), iVar5 != 0)) {
              unlink(pIVar2->file);
            }
            symlink(pIVar2->file,pIVar2->touch);
                    // WARNING: Subroutine does not return
            exit(0);
          }
          if (pIVar2->pid < 0) {
            pIVar2->pid = 0;
            return;
          }
        }
      }
    }
  }
  return;
}



ImageCache * getImage(Image *image,ParsedURL *current,int flag)

{
  int iVar1;
  Str p_Var2;
  void *pvVar3;
  uint uVar4;
  stat st;
  ImageCache *cache;
  Str key;
  
  key = (Str)0x0;
  if (activeImage == 0) {
    cache = (ImageCache *)0x0;
  }
  else {
    if (image_hash == (Hash_sv *)0x0) {
      image_hash = newHash_sv(100);
    }
    if (image->cache == (ImageCache *)0x0) {
      key = Sprintf("%d;%d;%s",(int)image->width,(int)image->height,image->url);
      cache = (ImageCache *)getHash_sv(image_hash,key->ptr,(void *)0x0);
    }
    else {
      cache = image->cache;
    }
    if (((cache != (ImageCache *)0x0) && (cache->index != 0)) &&
       (uVar4 = cache->index >> 0x1f, (int)((cache->index ^ uVar4) - uVar4) <= image_index + -1000))
    {
      iVar1 = stat(cache->file,(stat *)&st);
      if (iVar1 != 0) {
        cache->loaded = '\0';
      }
      cache->index = 0;
    }
    if (cache == (ImageCache *)0x0) {
      if (flag == 1) {
        return (ImageCache *)0x0;
      }
      cache = (ImageCache *)GC_malloc(0x20);
      cache->url = image->url;
      cache->current = current;
      p_Var2 = tmpfname(0,image->ext);
      cache->file = p_Var2->ptr;
      p_Var2 = tmpfname(0,(char *)0x0);
      cache->touch = p_Var2->ptr;
      cache->pid = 0;
      cache->index = 0;
      cache->loaded = '\0';
      cache->width = image->width;
      cache->height = image->height;
      putHash_sv(image_hash,key->ptr,cache);
    }
    if (flag != 1) {
      if (cache->loaded == '\0') {
        if (image_file == (Hash_sv *)0x0) {
          image_file = newHash_sv(100);
        }
        pvVar3 = getHash_sv(image_file,cache->file,(void *)0x0);
        if (pvVar3 == (void *)0x0) {
          putHash_sv(image_file,cache->file,cache);
          if (image_list == (GeneralList *)0x0) {
            image_list = newGeneralList();
          }
          pushValue(image_list,cache);
        }
      }
      if (cache->index == 0) {
        image_index = image_index + 1;
        cache->index = image_index;
      }
    }
    if ((cache->loaded & 1U) != 0) {
      getImageSize(cache);
    }
  }
  return cache;
}



int getImageSize(ImageCache *cache)

{
  short sVar1;
  int iVar2;
  char *pcVar3;
  int tmp_2;
  int tmp_1;
  int h;
  int w;
  FILE *f;
  Str tmp;
  
  w = 0;
  h = 0;
  if (activeImage == 0) {
    iVar2 = 0;
  }
  else if (((cache == (ImageCache *)0x0) || ((cache->loaded & 1U) == 0)) ||
          ((0 < cache->width && (0 < cache->height)))) {
    iVar2 = 0;
  }
  else {
    tmp = Strnew();
    pcVar3 = strchr(Imgdisplay,0x2f);
    if (pcVar3 == (char *)0x0) {
      pcVar3 = w3m_auxbin_dir();
      Strcat_m_charp(tmp,pcVar3,&DAT_080ce928,0);
    }
    pcVar3 = shell_quote(cache->file);
    Strcat_m_charp(tmp,Imgdisplay," -size ",pcVar3,0);
    f = (FILE *)popen(tmp->ptr,"r");
    if ((FILE *)f == (FILE *)0x0) {
      iVar2 = 0;
    }
    else {
      do {
        iVar2 = fscanf((FILE *)f,"%d %d",&w,&h);
        if (-1 < iVar2) break;
        iVar2 = feof((FILE *)f);
      } while (iVar2 == 0);
      pclose((FILE *)f);
      if ((w < 1) || (h < 1)) {
        iVar2 = 0;
      }
      else {
        w = (int)ROUND((image_scale * (double)w) / 100.0 + 0.5);
        if (w == 0) {
          w = 1;
        }
        h = (int)ROUND((image_scale * (double)h) / 100.0 + 0.5);
        if (h == 0) {
          h = 1;
        }
        if ((cache->width < 0) && (cache->height < 0)) {
          iVar2 = w;
          if (0x800 < w) {
            iVar2 = 0x800;
          }
          cache->width = (short)iVar2;
          iVar2 = h;
          if (0x800 < h) {
            iVar2 = 0x800;
          }
          cache->height = (short)iVar2;
        }
        else if (cache->width < 0) {
          iVar2 = (int)ROUND(((double)w * (double)cache->height) / (double)h + 0.5);
          sVar1 = 0x800;
          if (iVar2 < 0x801) {
            sVar1 = (short)iVar2;
          }
          cache->width = sVar1;
        }
        else if (cache->height < 0) {
          iVar2 = (int)ROUND(((double)h * (double)cache->width) / (double)w + 0.5);
          sVar1 = 0x800;
          if (iVar2 < 0x801) {
            sVar1 = (short)iVar2;
          }
          cache->height = sVar1;
        }
        if (cache->width == 0) {
          cache->width = 1;
        }
        if (cache->height == 0) {
          cache->height = 1;
        }
        tmp = Sprintf("%d;%d;%s",(int)cache->width,(int)cache->height,cache->url);
        putHash_sv(image_hash,tmp->ptr,cache);
        iVar2 = 1;
      }
    }
  }
  return iVar2;
}



void encode_symbol(symbol_set *s)

{
  char **ppcVar1;
  wc_ces f_ces;
  wc_ces t_ces;
  Str p_Var2;
  int i;
  
  for (i = 0; t_ces = InnerCharset, s->item[i] != (char *)0x0; i = i + 1) {
    if (*s->item[i] != '\0') {
      ppcVar1 = s->item;
      f_ces = s->ces;
      p_Var2 = Strnew_charp(s->item[i]);
      p_Var2 = wc_Str_conv(p_Var2,f_ces,t_ces);
      ppcVar1[i] = p_Var2->ptr;
    }
  }
  s->encode = '\x01';
  return;
}



char ** get_symbol(wc_ces charset,int *width)

{
  char **ppcVar1;
  symbol_set *s;
  charset_symbol_set *p;
  
  s = (symbol_set *)0x0;
  if (((charset == save_charset) && (save_symbol != (symbol_set *)0x0)) &&
     (*width == (int)save_symbol->width)) {
    *width = (int)save_symbol->width;
    ppcVar1 = save_symbol->item;
  }
  else {
    save_charset = charset;
    for (p = charset_symbol_list; p->charset != 0; p = p + 1) {
      if ((p->charset == charset) && ((*width == 0 || (*width == (int)p->symbol->width)))) {
        s = p->symbol;
        break;
      }
    }
    if (s == (symbol_set *)0x0) {
      if (*width == 2) {
        s = &alt2_symbol_set;
      }
      else {
        s = &alt_symbol_set;
      }
    }
    if (s != save_symbol) {
      if (s->encode == '\0') {
        encode_symbol(s);
      }
      save_symbol = s;
    }
    *width = (int)s->width;
    ppcVar1 = s->item;
  }
  return ppcVar1;
}



char ** set_symbol(int width)

{
  Str os;
  Str tmp;
  int i;
  symbol_set *s;
  
  if (width != set_symbol::save_width) {
    if (set_symbol::symbol_buf == (char **)0x0) {
      for (i = 0; alt_symbol_set.item[i] != (char *)0x0; i = i + 1) {
      }
      set_symbol::symbol_buf = (char **)GC_malloc(i << 2);
    }
    for (i = 0; alt_symbol_set.item[i] != (char *)0x0; i = i + 1) {
      os = Strnew_size(4);
      if (width == 2) {
        wtf_push(os,0x8800,i + 0x20);
      }
      else {
        wtf_push(os,0x800,i + 0x20);
      }
      set_symbol::symbol_buf[i] = os->ptr;
    }
    set_symbol::save_width = width;
  }
  return set_symbol::symbol_buf;
}



void push_symbol(Str str,char symbol,int width,int n)

{
  char cVar1;
  Str y;
  int i;
  char *p;
  char buf [2];
  
  if (width == 2) {
    p = alt2_symbol[symbol];
  }
  else {
    p = alt_symbol[symbol];
  }
  i = 0;
  for (; (i < 2 && (*p != '\0')); p = p + 1) {
    if (*p == ' ') {
      cVar1 = -0x60;
    }
    else {
      cVar1 = *p;
    }
    buf[i] = cVar1;
    i = i + 1;
  }
  y = Sprintf("<_SYMBOL TYPE=%d>",(int)symbol);
  Strcat(str,y);
  for (; 0 < n; n = n + -1) {
    Strcat_charp_n(str,buf,i);
  }
  Strcat_charp(str,"</_SYMBOL>");
  return;
}



char * conv_entity(uint c)

{
  wc_ces wVar1;
  char *pcVar2;
  Str p_Var3;
  wc_uchar utf8 [7];
  char b;
  
  wVar1 = InnerCharset;
  b = (char)c;
  if (c < 0x20) {
    pcVar2 = " ";
  }
  else if (c < 0x7f) {
    p_Var3 = Strnew_charp_n(&b,1);
    pcVar2 = p_Var3->ptr;
  }
  else if (c < 0xa0) {
    pcVar2 = " ";
  }
  else if (c == 0xa0) {
    pcVar2 = &DAT_080ceca0;
  }
  else if (c < 0x100) {
    if (UseAltEntity == '\0') {
      p_Var3 = Strnew_charp_n(&b,1);
      p_Var3 = wc_Str_conv(p_Var3,0x100201,wVar1);
      pcVar2 = p_Var3->ptr;
    }
    else {
      pcVar2 = alt_latin1[c - 0xa0];
    }
  }
  else if ((int)c < 0) {
    pcVar2 = "?";
  }
  else {
    wc_ucs_to_utf8(c,utf8);
    wVar1 = InnerCharset;
    p_Var3 = Strnew_charp((char *)utf8);
    p_Var3 = wc_Str_conv(p_Var3,0x308045,wVar1);
    pcVar2 = p_Var3->ptr;
  }
  return pcVar2;
}



void writestr(char *s)

{
  tputs(s,1,write1);
  return;
}



int set_tty(void)

{
  int iVar1;
  char *__s1;
  size_t sVar2;
  w3m_term_info *p_1;
  char *term;
  w3m_term_info *p;
  char *ttyn;
  
  iVar1 = isatty(0);
  if (iVar1 == 0) {
    ttyn = "/dev/tty";
  }
  else {
    ttyn = ttyname(0);
  }
  tty = open(ttyn,2);
  if (tty < 0) {
    tty = 2;
  }
  ttyf = (FILE *)fdopen(tty,"w");
  tcgetattr(tty,(termios *)&d_ioval);
  if (displayTitleTerm != (char *)0x0) {
    for (p = w3m_term_info_list; p->term != (char *)0x0; p = p + 1) {
      sVar2 = strlen(p->term);
      iVar1 = strncmp(displayTitleTerm,p->term,sVar2);
      if (iVar1 == 0) {
        title_str = p->title_str;
        break;
      }
    }
  }
  __s1 = getenv("TERM");
  if (__s1 != (char *)0x0) {
    for (p_1 = w3m_term_info_list; p_1->term != (char *)0x0; p_1 = p_1 + 1) {
      sVar2 = strlen(p_1->term);
      iVar1 = strncmp(__s1,p_1->term,sVar2);
      if (iVar1 == 0) {
        is_xterm = p_1->mouse_flag;
        return 0;
      }
    }
  }
  return 0;
}



void ttymode_set(int mode,int imode)

{
  int iVar1;
  int *piVar2;
  int iVar3;
  int in_GS_OFFSET;
  TerminalMode ioval;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  tcgetattr(tty,(termios *)&ioval);
  ioval.c_lflag = mode | ioval.c_lflag;
  ioval.c_iflag = imode | ioval.c_iflag;
  while (iVar3 = tcsetattr(tty,0,(termios *)&ioval), iVar3 == -1) {
    piVar2 = __errno_location();
    if ((*piVar2 != 4) && (piVar2 = __errno_location(), *piVar2 != 0xb)) {
      piVar2 = __errno_location();
      printf("Error occured while set %x: errno=%d\n",mode,*piVar2);
      reset_exit(0);
    }
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void ttymode_reset(int mode,int imode)

{
  int iVar1;
  int *piVar2;
  int iVar3;
  int in_GS_OFFSET;
  TerminalMode ioval;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  tcgetattr(tty,(termios *)&ioval);
  ioval.c_lflag = ~mode & ioval.c_lflag;
  ioval.c_iflag = ~imode & ioval.c_iflag;
  while (iVar3 = tcsetattr(tty,0,(termios *)&ioval), iVar3 == -1) {
    piVar2 = __errno_location();
    if ((*piVar2 != 4) && (piVar2 = __errno_location(), *piVar2 != 0xb)) {
      piVar2 = __errno_location();
      printf("Error occured while reset %x: errno=%d\n",mode,*piVar2);
      reset_exit(0);
    }
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void set_cc(int spec,int val)

{
  int *piVar1;
  int iVar2;
  int in_GS_OFFSET;
  TerminalMode ioval;
  int local_10;
  
  local_10 = *(int *)(in_GS_OFFSET + 0x14);
  tcgetattr(tty,(termios *)&ioval);
  ioval.c_cc[spec] = (cc_t)val;
  while (iVar2 = tcsetattr(tty,0,(termios *)&ioval), iVar2 == -1) {
    piVar1 = __errno_location();
    if ((*piVar1 != 4) && (piVar1 = __errno_location(), *piVar1 != 0xb)) {
      piVar1 = __errno_location();
      printf("Error occured: errno=%d\n",*piVar1);
      reset_exit(0);
    }
  }
  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void close_tty(void)

{
  if (2 < tty) {
    close(tty);
  }
  return;
}



char * ttyname_tty(void)

{
  char *pcVar1;
  
  pcVar1 = ttyname(tty);
  return pcVar1;
}



void reset_tty(void)

{
  writestr(T_op);
  writestr(T_me);
  if (Do_not_use_ti_te == 0) {
    if ((T_te == (char *)0x0) || (*T_te == '\0')) {
      writestr(T_cl);
    }
    else {
      writestr(T_te);
    }
  }
  writestr(T_se);
  flush_tty();
  tcsetattr(tty,0,(termios *)&d_ioval);
  close_tty();
  return;
}



void reset_exit(int _dummy)

{
  if (mouseActive != 0) {
    mouse_end();
  }
  reset_tty();
  w3m_exit(0);
  return;
}



void error_dump(int _dummy)

{
  mySignal(6,(anon_subr_void_int *)0x0);
  reset_tty();
                    // WARNING: Subroutine does not return
  abort();
}



void set_int(void)

{
  mySignal(1,reset_exit);
  mySignal(2,reset_exit);
  mySignal(3,reset_exit);
  mySignal(0xf,reset_exit);
  mySignal(4,error_dump);
  mySignal(6,error_dump);
  mySignal(8,error_dump);
  mySignal(7,error_dump);
  return;
}



void setgraphchar(void)

{
  size_t sVar1;
  int iVar2;
  int n;
  int i;
  int c;
  
  for (c = 0; c < 0x60; c = c + 1) {
    gcmap[c] = (char)c + ' ';
  }
  if (T_ac != (char *)0x0) {
    sVar1 = strlen(T_ac);
    for (i = 0; i < (int)(sVar1 - 1); i = i + 2) {
      iVar2 = T_ac[i] + -0x20;
      if ((-1 < iVar2) && (iVar2 < 0x60)) {
        *(char *)((int)&max_LINES + (int)T_ac[i]) = T_ac[i + 1];
      }
    }
  }
  return;
}



void getTCstr(void)

{
  char *pcVar1;
  int iVar2;
  int r;
  char *pt;
  char *suc;
  char *ent;
  
  pt = funcstr;
  pcVar1 = getenv("TERM");
  if (pcVar1 == (char *)0x0) {
    ent = (char *)0x0;
  }
  else {
    ent = getenv("TERM");
  }
  if (ent == (char *)0x0) {
    fwrite("TERM is not set\n",1,0x10,stderr);
    reset_exit(0);
  }
  iVar2 = tgetent(bp,ent);
  if (iVar2 != 1) {
    fprintf(stderr,"Can\'t find termcap entry %s\n",ent);
    reset_exit(0);
  }
  T_ce = pt;
  suc = (char *)tgetstr(&DAT_080cee8f,&pt);
  if (suc == (char *)0x0) {
    T_ce = "";
  }
  else {
    T_ce = allocStr(suc,-1);
  }
  T_cd = pt;
  suc = (char *)tgetstr(&DAT_080cee93,&pt);
  if (suc == (char *)0x0) {
    T_cd = "";
  }
  else {
    T_cd = allocStr(suc,-1);
  }
  T_kr = pt;
  suc = (char *)tgetstr(&DAT_080cee96,&pt);
  if (suc == (char *)0x0) {
    T_kr = "";
  }
  else {
    T_kr = allocStr(suc,-1);
  }
  if (suc == (char *)0x0) {
    T_kr = pt;
    suc = (char *)tgetstr(&DAT_080cee99,&pt);
    if (suc == (char *)0x0) {
      T_kr = "";
    }
    else {
      T_kr = allocStr(suc,-1);
    }
  }
  iVar2 = tgetflag(&DAT_080cee9c);
  if (iVar2 == 0) {
    T_kl = pt;
    suc = (char *)tgetstr(&DAT_080ceea1,&pt);
    if (suc == (char *)0x0) {
      T_kl = "";
    }
    else {
      T_kl = allocStr(suc,-1);
    }
    if (suc == (char *)0x0) {
      T_kl = pt;
      suc = (char *)tgetstr(&DAT_080ceea4,&pt);
      if (suc == (char *)0x0) {
        T_kl = "";
      }
      else {
        T_kl = allocStr(suc,-1);
      }
    }
    if (suc == (char *)0x0) {
      T_kl = pt;
      suc = (char *)tgetstr(&DAT_080ceea7,&pt);
      if (suc == (char *)0x0) {
        T_kl = "";
      }
      else {
        T_kl = allocStr(suc,-1);
      }
    }
  }
  else {
    T_kl = "\b";
  }
  T_cr = pt;
  suc = (char *)tgetstr(&DAT_080ceeaa,&pt);
  if (suc == (char *)0x0) {
    T_cr = "";
  }
  else {
    T_cr = allocStr(suc,-1);
  }
  T_ta = pt;
  suc = (char *)tgetstr(&DAT_080ceead,&pt);
  if (suc == (char *)0x0) {
    T_ta = "";
  }
  else {
    T_ta = allocStr(suc,-1);
  }
  T_sc = pt;
  suc = (char *)tgetstr(&DAT_080ceeb0,&pt);
  if (suc == (char *)0x0) {
    T_sc = "";
  }
  else {
    T_sc = allocStr(suc,-1);
  }
  T_rc = pt;
  suc = (char *)tgetstr(&DAT_080ceeb3,&pt);
  if (suc == (char *)0x0) {
    T_rc = "";
  }
  else {
    T_rc = allocStr(suc,-1);
  }
  T_so = pt;
  suc = (char *)tgetstr(&DAT_080ceeb6,&pt);
  if (suc == (char *)0x0) {
    T_so = "";
  }
  else {
    T_so = allocStr(suc,-1);
  }
  T_se = pt;
  suc = (char *)tgetstr(&DAT_080ceeb9,&pt);
  if (suc == (char *)0x0) {
    T_se = "";
  }
  else {
    T_se = allocStr(suc,-1);
  }
  T_us = pt;
  suc = (char *)tgetstr(&DAT_080ceebc,&pt);
  if (suc == (char *)0x0) {
    T_us = "";
  }
  else {
    T_us = allocStr(suc,-1);
  }
  T_ue = pt;
  suc = (char *)tgetstr(&DAT_080ceebf,&pt);
  if (suc == (char *)0x0) {
    T_ue = "";
  }
  else {
    T_ue = allocStr(suc,-1);
  }
  T_md = pt;
  suc = (char *)tgetstr(&DAT_080ceec2,&pt);
  if (suc == (char *)0x0) {
    T_md = "";
  }
  else {
    T_md = allocStr(suc,-1);
  }
  T_me = pt;
  suc = (char *)tgetstr(&DAT_080ceec5,&pt);
  if (suc == (char *)0x0) {
    T_me = "";
  }
  else {
    T_me = allocStr(suc,-1);
  }
  T_cl = pt;
  suc = (char *)tgetstr(&DAT_080ceec8,&pt);
  if (suc == (char *)0x0) {
    T_cl = "";
  }
  else {
    T_cl = allocStr(suc,-1);
  }
  T_cm = pt;
  suc = (char *)tgetstr(&DAT_080ceecb,&pt);
  if (suc == (char *)0x0) {
    T_cm = "";
  }
  else {
    T_cm = allocStr(suc,-1);
  }
  T_al = pt;
  suc = (char *)tgetstr(&DAT_080ceece,&pt);
  if (suc == (char *)0x0) {
    T_al = "";
  }
  else {
    T_al = allocStr(suc,-1);
  }
  T_sr = pt;
  suc = (char *)tgetstr(&DAT_080ceed1,&pt);
  if (suc == (char *)0x0) {
    T_sr = "";
  }
  else {
    T_sr = allocStr(suc,-1);
  }
  T_ti = pt;
  suc = (char *)tgetstr(&DAT_080ceed4,&pt);
  if (suc == (char *)0x0) {
    T_ti = "";
  }
  else {
    T_ti = allocStr(suc,-1);
  }
  T_te = pt;
  suc = (char *)tgetstr(&DAT_080ceed7,&pt);
  if (suc == (char *)0x0) {
    T_te = "";
  }
  else {
    T_te = allocStr(suc,-1);
  }
  T_nd = pt;
  suc = (char *)tgetstr(&DAT_080cee96,&pt);
  if (suc == (char *)0x0) {
    T_nd = "";
  }
  else {
    T_nd = allocStr(suc,-1);
  }
  T_eA = pt;
  suc = (char *)tgetstr(&DAT_080ceeda,&pt);
  if (suc == (char *)0x0) {
    T_eA = "";
  }
  else {
    T_eA = allocStr(suc,-1);
  }
  T_as = pt;
  suc = (char *)tgetstr(&DAT_080ceedd,&pt);
  if (suc == (char *)0x0) {
    T_as = "";
  }
  else {
    T_as = allocStr(suc,-1);
  }
  T_ae = pt;
  suc = (char *)tgetstr(&DAT_080ceee0,&pt);
  if (suc == (char *)0x0) {
    T_ae = "";
  }
  else {
    T_ae = allocStr(suc,-1);
  }
  T_ac = pt;
  suc = (char *)tgetstr(&DAT_080ceee3,&pt);
  if (suc == (char *)0x0) {
    T_ac = "";
  }
  else {
    T_ac = allocStr(suc,-1);
  }
  T_op = pt;
  suc = (char *)tgetstr(&DAT_080ceee6,&pt);
  if (suc == (char *)0x0) {
    T_op = "";
  }
  else {
    T_op = allocStr(suc,-1);
  }
  COLS = 0;
  LINES = 0;
  setlinescols();
  setgraphchar();
  return;
}



void setlinescols(void)

{
  int iVar1;
  char *pcVar2;
  winsize wins;
  int i;
  char *p;
  
  iVar1 = ioctl(tty,0x5413,&wins);
  if (((-1 < iVar1) && (wins.ws_row != 0)) && (wins.ws_col != 0)) {
    LINES = (int)wins.ws_row;
    COLS = (int)wins.ws_col;
  }
  if (LINES < 1) {
    pcVar2 = getenv("LINES");
    if (pcVar2 != (char *)0x0) {
      iVar1 = atoi(pcVar2);
      if (-1 < iVar1) {
        LINES = iVar1;
      }
    }
  }
  if (COLS < 1) {
    pcVar2 = getenv("COLUMNS");
    if (pcVar2 != (char *)0x0) {
      iVar1 = atoi(pcVar2);
      if (-1 < iVar1) {
        COLS = iVar1;
      }
    }
  }
  if (LINES < 1) {
    LINES = tgetnum(&DAT_080ceef7);
  }
  if (COLS < 1) {
    COLS = tgetnum(&DAT_080ceefa);
  }
  if (400 < COLS) {
    COLS = 400;
  }
  if (200 < LINES) {
    LINES = 200;
  }
  return;
}



void setupscreen(void)

{
  Screen *pSVar1;
  char **ppcVar2;
  l_prop *plVar3;
  int i;
  
  if (max_LINES < LINES + 1) {
    max_LINES = LINES + 1;
    max_COLS = 0;
    ScreenElem = (Screen *)GC_malloc(max_LINES * 0xc);
    ScreenImage = (Screen **)GC_malloc(max_LINES << 2);
  }
  if (max_COLS < COLS + 1) {
    max_COLS = COLS + 1;
    for (i = 0; i < max_LINES; i = i + 1) {
      pSVar1 = ScreenElem + i;
      ppcVar2 = (char **)GC_malloc(max_COLS << 2);
      pSVar1->lineimage = ppcVar2;
      bzero(ScreenElem[i].lineimage,max_COLS * 4);
      pSVar1 = ScreenElem;
      plVar3 = (l_prop *)GC_malloc(max_COLS * 2);
      pSVar1[i].lineprop = plVar3;
    }
  }
  for (i = 0; i < LINES; i = i + 1) {
    ScreenImage[i] = ScreenElem + i;
    *ScreenImage[i]->lineprop = 8;
    ScreenImage[i]->isdirty = 0;
  }
  for (; i < max_LINES; i = i + 1) {
    ScreenElem[i].isdirty = 2;
  }
  clear();
  return;
}



int initscr(void)

{
  int iVar1;
  
  iVar1 = set_tty();
  if (iVar1 < 0) {
    iVar1 = -1;
  }
  else {
    set_int();
    getTCstr();
    if ((T_ti != (char *)0x0) && (Do_not_use_ti_te == 0)) {
      writestr(T_ti);
    }
    setupscreen();
    iVar1 = 0;
  }
  return iVar1;
}



int write1(char c)

{
  _IO_putc((int)c,(_IO_FILE *)ttyf);
  return 0;
}



void move(int line,int column)

{
  if ((-1 < line) && (line < LINES)) {
    CurLine = line;
  }
  if ((-1 < column) && (column < COLS)) {
    CurColumn = column;
  }
  return;
}



int need_redraw(char *c1,l_prop pr1,char *c2,l_prop pr2)

{
  int iVar1;
  
  if (((c1 == (char *)0x0) || (c2 == (char *)0x0)) || (iVar1 = strcmp(c1,c2), iVar1 != 0)) {
    return 1;
  }
  if (*c1 == ' ') {
    return (pr2 ^ pr1) & 0xff1f;
  }
  if (((pr2 ^ pr1) & 0xffdf) != 0) {
    return 1;
  }
  return 0;
}



void addch(char c)

{
  char local_10 [12];
  
  local_10[0] = c;
  addmch(local_10,1);
  return;
}



void addmch(char *pc,size_t len)

{
  byte bVar1;
  ushort uVar2;
  uint uVar3;
  int iVar4;
  int iVar5;
  char *pcVar6;
  char *pcVar7;
  char **ppcVar8;
  byte bVar9;
  int width;
  char **p;
  short *dirty;
  int i;
  int dest;
  l_prop *pr;
  l_prop l;
  char c;
  
  bVar1 = *pc;
  if (WcOption.use_wide == '\0') {
    bVar9 = WTF_WIDTH_MAP[(byte)*pc] != '\0';
  }
  else {
    bVar9 = WTF_WIDTH_MAP[(byte)*pc];
  }
  uVar3 = (uint)bVar9;
  if (addmch::tmp == (Str)0x0) {
    addmch::tmp = Strnew();
  }
  Strcopy_charp_n(addmch::tmp,pc,len);
  pcVar7 = addmch::tmp->ptr;
  if (CurColumn == COLS) {
    wrap();
  }
  if (CurColumn < COLS) {
    p = ScreenImage[CurLine]->lineimage;
    pr = ScreenImage[CurLine]->lineprop;
    if ((pr[CurColumn] & 8) != 0) {
      if ((bVar1 == 0x20) && ((CurrentMode & 0xff1f) == 0)) {
        CurColumn = CurColumn + 1;
        return;
      }
      for (i = CurColumn; (-1 < i && ((pr[i] & 8) != 0)); i = i + -1) {
        pcVar6 = (char *)GC_realloc(p[i],2);
        p[i] = pcVar6;
        memcpy(p[i],&DAT_080ceefd,1);
        p[i][1] = '\0';
        pr[i] = pr[i] & 0x20;
      }
    }
    if ((((bVar1 == 9) || (bVar1 == 10)) || (bVar1 == 0xd)) || (bVar1 == 8)) {
      CurrentMode = CurrentMode | 0xc0;
    }
    else if (len < 2) {
      if ((MYCTYPE_MAP[bVar1] & 1) != 0) {
        return;
      }
      CurrentMode = CurrentMode & 0xff3f;
    }
    else {
      CurrentMode = CurrentMode & 0xff3f | 0x40;
    }
    i = CurColumn + uVar3;
    iVar4 = i + -1;
    if ((iVar4 < COLS) &&
       (((((pr[iVar4] & 4) != 0 &&
          (iVar5 = need_redraw(p[iVar4],pr[iVar4],pcVar7,CurrentMode), iVar5 != 0)) ||
         (((pr[iVar4] & 2) != 0 && ((CurrentMode & 2) == 0)))) && (touch_line(), i < COLS)))) {
      touch_column(i);
      if ((pr[i] & 8) == 0) {
        while ((i = i + 1, i < COLS && ((pr[i] & 0xc0) == 0x80))) {
          touch_column(i);
        }
      }
      else {
        pcVar6 = (char *)GC_realloc(p[i],2);
        p[i] = pcVar6;
        memcpy(p[i],&DAT_080ceefd,1);
        p[i][1] = '\0';
        pr[i] = pr[i] & 0x20;
      }
    }
    if (COLS < (int)(CurColumn + uVar3)) {
      touch_line();
      for (i = CurColumn; i < COLS; i = i + 1) {
        pcVar6 = (char *)GC_realloc(p[i],2);
        p[i] = pcVar6;
        memcpy(p[i],&DAT_080ceefd,1);
        p[i][1] = '\0';
        pr[i] = pr[i] & 0xff3f;
        touch_column(i);
      }
      wrap();
      if (COLS < (int)(CurColumn + uVar3)) {
        return;
      }
      p = ScreenImage[CurLine]->lineimage;
      pr = ScreenImage[CurLine]->lineprop;
    }
    if ((pr[CurColumn] & 0xc0) == 0x80) {
      touch_line();
      i = CurColumn;
      do {
        i = i + -1;
        if (i < 0) break;
        uVar2 = pr[i];
        pcVar6 = (char *)GC_realloc(p[i],2);
        p[i] = pcVar6;
        memcpy(p[i],&DAT_080ceefd,1);
        p[i][1] = '\0';
        pr[i] = pr[i] & 0xff3f;
        touch_column(i);
      } while ((uVar2 & 0xc0) == 0x80);
    }
    if ((CurrentMode & 0xc0) == 0xc0) {
      if (bVar1 == 9) {
        dest = tab_step * ((CurColumn + tab_step) / tab_step);
        if (COLS <= dest) {
          wrap();
          touch_line();
          dest = tab_step;
          p = ScreenImage[CurLine]->lineimage;
          pr = ScreenImage[CurLine]->lineprop;
        }
        for (i = CurColumn; i < dest; i = i + 1) {
          iVar4 = need_redraw(p[i],pr[i]," ",CurrentMode);
          if (iVar4 != 0) {
            pcVar7 = (char *)GC_realloc(p[i],2);
            p[i] = pcVar7;
            memcpy(p[i],&DAT_080ceefd,1);
            p[i][1] = '\0';
            pr[i] = CurrentMode | pr[i] & 0x20;
            touch_line();
            touch_column(i);
          }
        }
        CurColumn = i;
      }
      else if (bVar1 == 10) {
        wrap();
      }
      else if (bVar1 == 0xd) {
        CurColumn = 0;
      }
      else if ((bVar1 == 8) && (0 < CurColumn)) {
        do {
          CurColumn = CurColumn + -1;
          if (CurColumn < 1) {
            return;
          }
        } while ((pr[CurColumn] & 0xc0) == 0x80);
      }
    }
    else {
      iVar4 = need_redraw(p[CurColumn],pr[CurColumn],pcVar7,CurrentMode);
      if (iVar4 != 0) {
        ppcVar8 = p + CurColumn;
        pcVar6 = (char *)GC_realloc(p[CurColumn],len + 1);
        *ppcVar8 = pcVar6;
        strncpy(p[CurColumn],pcVar7,len);
        p[CurColumn][len] = '\0';
        pr[CurColumn] = CurrentMode | pr[CurColumn] & 0x20;
        touch_line();
        touch_column(CurColumn);
        CurrentMode = CurrentMode & 0xff3f | 0x80;
        i = CurColumn;
        while (i = i + 1, i < (int)(CurColumn + uVar3)) {
          pcVar7 = (char *)GC_realloc(p[i],2);
          p[i] = pcVar7;
          memcpy(p[i],&DAT_080ceefd,1);
          p[i][1] = '\0';
          pr[i] = pr[CurColumn] & 0xff00 | pr[CurColumn] & 0x3f | pr[i] & 0x20 | 0x80;
          touch_column(i);
        }
        for (; (i < COLS && ((pr[i] & 0xc0) == 0x80)); i = i + 1) {
          pcVar7 = (char *)GC_realloc(p[i],2);
          p[i] = pcVar7;
          memcpy(p[i],&DAT_080ceefd,1);
          p[i][1] = '\0';
          pr[i] = pr[i] & 0xff3f;
          touch_column(i);
        }
      }
      CurColumn = CurColumn + uVar3;
    }
  }
  return;
}



void wrap(void)

{
  if (LINES + -1 != CurLine) {
    CurLine = CurLine + 1;
    CurColumn = 0;
  }
  return;
}



void touch_column(int col)

{
  if ((-1 < col) && (col < COLS)) {
    ScreenImage[CurLine]->lineprop[col] = ScreenImage[CurLine]->lineprop[col] | 0x20;
  }
  return;
}



void touch_line(void)

{
  int i;
  
  if ((ScreenImage[CurLine]->isdirty & 1U) == 0) {
    for (i = 0; i < COLS; i = i + 1) {
      ScreenImage[CurLine]->lineprop[i] = ScreenImage[CurLine]->lineprop[i] & 0xffdf;
    }
    ScreenImage[CurLine]->isdirty = ScreenImage[CurLine]->isdirty | 1;
  }
  return;
}



void standout(void)

{
  CurrentMode = CurrentMode | 1;
  return;
}



void standend(void)

{
  CurrentMode = CurrentMode & 0xfffe;
  return;
}



void toggle_stand(void)

{
  l_prop *plVar1;
  l_prop *pr;
  int i;
  
  plVar1 = ScreenImage[CurLine]->lineprop;
  plVar1[CurColumn] = plVar1[CurColumn] ^ 1;
  i = CurColumn;
  if ((plVar1[CurColumn] & 0xc0) != 0x80) {
    while (i = i + 1, (plVar1[i] & 0xc0) == 0x80) {
      plVar1[i] = plVar1[i] ^ 1;
    }
  }
  return;
}



void bold(void)

{
  CurrentMode = CurrentMode | 4;
  return;
}



void boldend(void)

{
  CurrentMode = CurrentMode & 0xfffb;
  return;
}



void underline(void)

{
  CurrentMode = CurrentMode | 2;
  return;
}



void underlineend(void)

{
  CurrentMode = CurrentMode & 0xfffd;
  return;
}



void graphstart(void)

{
  CurrentMode = CurrentMode | 0x10;
  return;
}



void graphend(void)

{
  CurrentMode = CurrentMode & 0xffef;
  return;
}



int graph_ok(void)

{
  int iVar1;
  
  if (UseGraphicChar == '\0') {
    iVar1 = 0;
  }
  else if (((*T_as == '\0') || (*T_ae == '\0')) || (*T_ac == '\0')) {
    iVar1 = 0;
  }
  else {
    iVar1 = 1;
  }
  return iVar1;
}



void setfcolor(int color)

{
  CurrentMode = CurrentMode & 0xf0ff;
  if ((color & 0xfU) < 8) {
    CurrentMode = CurrentMode | (ushort)((color & 7U | 8) << 8);
  }
  return;
}



char * color_seq(int colmode)

{
  sprintf(color_seq::seqbuf,"\x1b[%dm",(colmode >> 8 & 7U) + 0x1e);
  return color_seq::seqbuf;
}



void setbcolor(int color)

{
  CurrentMode = CurrentMode & 0xfff;
  if ((color & 0xfU) < 8) {
    CurrentMode = CurrentMode | (ushort)((color & 7U | 8) << 0xc);
  }
  return;
}



char * bcolor_seq(int colmode)

{
  sprintf(bcolor_seq::seqbuf,"\x1b[%dm",(colmode >> 0xc & 7U) + 0x28);
  return bcolor_seq::seqbuf;
}



void refresh(void)

{
  char **ppcVar1;
  l_prop *plVar2;
  char c;
  short *psVar3;
  int iVar4;
  char *pcVar5;
  bool bVar6;
  short *dirty;
  l_prop *pr;
  char **pc;
  int moved;
  int pline;
  int pcol;
  int col;
  int line;
  l_prop bcolor;
  l_prop color;
  l_prop mode;
  
  pline = CurLine;
  moved = 0;
  mode = 0;
  wc_putc_init(InnerCharset,DisplayCharset);
  line = 0;
  do {
    if (LINES + -1 < line) {
      wc_putc_end(ttyf);
      pcVar5 = (char *)tgoto(T_cm,CurColumn,CurLine);
      writestr(pcVar5);
      flush_tty();
      return;
    }
    psVar3 = &ScreenImage[line]->isdirty;
    if ((*psVar3 & 1U) != 0) {
      *psVar3 = *psVar3 & 0xfffe;
      ppcVar1 = ScreenImage[line]->lineimage;
      plVar2 = ScreenImage[line]->lineprop;
      for (col = 0; (col < COLS && ((plVar2[col] & 8) == 0)); col = col + 1) {
        if (((*psVar3 & 4U) == 0) || (col < ScreenImage[line]->eol)) {
          if ((plVar2[col] & 0x20) != 0) break;
        }
        else {
          iVar4 = need_redraw(ppcVar1[col],plVar2[col]," ",0);
          if (iVar4 != 0) break;
        }
      }
      if ((*psVar3 & 0xcU) == 0) {
        pcol = col;
      }
      else {
        pcol = (int)ScreenImage[line]->eol;
        if (COLS <= pcol) {
          *psVar3 = *psVar3 & 0xfff3;
          pcol = col;
        }
      }
      if (((line < LINES + -2) && (line + -1 == pline)) && (pcol == 0)) {
        if (moved == 1) {
          write1('\n');
          write1('\r');
        }
        else if (moved == 2) {
          moved = 1;
        }
        else if (moved == 0) {
          pcVar5 = (char *)tgoto(T_cm,0,line);
          writestr(pcVar5);
          moved = 1;
        }
      }
      else {
        pcVar5 = (char *)tgoto(T_cm,pcol,line);
        writestr(pcVar5);
        moved = 1;
      }
      if (((*psVar3 & 0xcU) != 0) && (writestr(T_ce), col != pcol)) {
        pcVar5 = (char *)tgoto(T_cm,col,line);
        writestr(pcVar5);
      }
      pline = line;
      pcol = col;
      for (; (col < COLS && ((plVar2[col] & 8) == 0)); col = col + 1) {
        if ((((((plVar2[col] & 1) == 0) && ((mode & 1) != 0)) ||
             (((plVar2[col] & 2) == 0 && ((mode & 2) != 0)))) ||
            (((plVar2[col] & 4) == 0 && ((mode & 4) != 0)))) ||
           (((((plVar2[col] & 0xf00) == 0 && ((mode & 0xf00) != 0)) ||
             (((plVar2[col] & 0xf000) == 0 && ((mode & 0xf000) != 0)))) ||
            (((plVar2[col] & 0x10) == 0 && ((mode & 0x10) != 0)))))) {
          if (((mode & 0xf00) != 0) || ((mode & 0xf000) != 0)) {
            writestr(T_op);
          }
          if ((mode & 0x10) != 0) {
            writestr(T_ae);
          }
          writestr(T_me);
          mode = 0;
        }
        if (((*psVar3 & 4U) == 0) || (col < ScreenImage[line]->eol)) {
          bVar6 = (plVar2[col] & 0x20) != 0;
        }
        else {
          iVar4 = need_redraw(ppcVar1[col],plVar2[col]," ",0);
          bVar6 = iVar4 != 0;
        }
        if (bVar6) {
          if (col + -1 == pcol) {
            writestr(T_nd);
          }
          else if (pcol != col) {
            pcVar5 = (char *)tgoto(T_cm,col,line);
            writestr(pcVar5);
          }
          if (((plVar2[col] & 1) != 0) && ((mode & 1) == 0)) {
            writestr(T_so);
            mode = mode | 1;
          }
          if (((plVar2[col] & 2) != 0) && ((mode & 2) == 0)) {
            writestr(T_us);
            mode = mode | 2;
          }
          if (((plVar2[col] & 4) != 0) && ((mode & 4) == 0)) {
            writestr(T_md);
            mode = mode | 4;
          }
          if (((plVar2[col] & 0xf00) != 0) && (((plVar2[col] ^ mode) & 0xf00) != 0)) {
            mode = plVar2[col] & 0xf00 | mode & 0xff | ((byte)((uint)mode >> 8) & 0xf0) << 8;
            pcVar5 = color_seq((uint)(plVar2[col] & 0xf00));
            writestr(pcVar5);
          }
          if (((plVar2[col] & 0xf000) != 0) && (((plVar2[col] ^ mode) & 0xf000) != 0)) {
            mode = plVar2[col] & 0xf000 | mode & 0xfff;
            pcVar5 = bcolor_seq((uint)(plVar2[col] & 0xf000));
            writestr(pcVar5);
          }
          if (((plVar2[col] & 0x10) != 0) && ((mode & 0x10) == 0)) {
            wc_putc_end(ttyf);
            if (graph_enabled == 0) {
              graph_enabled = 1;
              writestr(T_eA);
            }
            writestr(T_as);
            mode = mode | 0x10;
          }
          if ((plVar2[col] & 0x10) == 0) {
            if ((plVar2[col] & 0xc0) != 0x80) {
              wc_putc(ppcVar1[col],ttyf);
            }
          }
          else {
            if (((byte)*ppcVar1[col] < 0x20) || (*ppcVar1[col] < '\0')) {
              c = *ppcVar1[col];
            }
            else {
              c = *(char *)((int)&max_LINES + (int)*ppcVar1[col]);
            }
            write1(c);
          }
          pcol = col + 1;
        }
      }
      if (col == COLS) {
        moved = 0;
      }
      for (; (col < COLS && ((plVar2[col] & 8) == 0)); col = col + 1) {
        plVar2[col] = plVar2[col] | 8;
      }
    }
    *psVar3 = *psVar3 & 0xfff3;
    if (mode != 0) {
      if ((mode & 0xff00) != 0) {
        writestr(T_op);
      }
      if ((mode & 0x10) != 0) {
        writestr(T_ae);
        wc_putc_clear_status();
      }
      writestr(T_me);
      mode = 0;
    }
    line = line + 1;
  } while( true );
}



void clear(void)

{
  l_prop *plVar1;
  l_prop *p;
  int j;
  int i;
  
  writestr(T_cl);
  move(0,0);
  for (i = 0; i < LINES; i = i + 1) {
    ScreenImage[i]->isdirty = 0;
    plVar1 = ScreenImage[i]->lineprop;
    for (j = 0; j < COLS; j = j + 1) {
      plVar1[j] = 8;
    }
  }
  CurrentMode = 0;
  return;
}



void clrtoeol(void)

{
  l_prop *plVar1;
  l_prop *lprop;
  int i;
  
  plVar1 = ScreenImage[CurLine]->lineprop;
  if ((plVar1[CurColumn] & 8) == 0) {
    if (((ScreenImage[CurLine]->isdirty & 0xcU) == 0) || (CurColumn < ScreenImage[CurLine]->eol)) {
      ScreenImage[CurLine]->eol = (short)CurColumn;
    }
    ScreenImage[CurLine]->isdirty = ScreenImage[CurLine]->isdirty | 8;
    touch_line();
    for (i = CurColumn; (i < COLS && ((plVar1[i] & 8) == 0)); i = i + 1) {
      plVar1[i] = 0x28;
    }
  }
  return;
}



void clrtoeol_with_bcolor(void)

{
  int line;
  int column;
  l_prop lVar1;
  int cco;
  int cli;
  int i;
  l_prop pr;
  
  lVar1 = CurrentMode;
  column = CurColumn;
  line = CurLine;
  if ((CurrentMode & 0xf000) == 0) {
    clrtoeol();
  }
  else {
    CurrentMode = CurrentMode & 0xf020;
    for (i = CurColumn; i < COLS; i = i + 1) {
      addch(' ');
    }
    move(line,column);
    CurrentMode = lVar1;
  }
  return;
}



void clrtoeolx(void)

{
  clrtoeol_with_bcolor();
  return;
}



void clrtobot_eol(anon_subr_void_varargs *clrtoeol)

{
  int iVar1;
  int iVar2;
  int c;
  int l;
  
  iVar2 = CurColumn;
  iVar1 = CurLine;
  (*clrtoeol)();
  CurColumn = 0;
  while (CurLine = CurLine + 1, CurLine < LINES) {
    (*clrtoeol)();
  }
  CurLine = iVar1;
  CurColumn = iVar2;
  return;
}



void clrtobot(void)

{
  clrtobot_eol(clrtoeol);
  return;
}



void clrtobotx(void)

{
  clrtobot_eol(clrtoeolx);
  return;
}



void addstr(char *s)

{
  size_t len_00;
  int len;
  
  for (; *s != '\0'; s = s + len_00) {
    len_00 = wtf_len((wc_uchar *)s);
    addmch(s,len_00);
  }
  return;
}



void addnstr(char *s,int n)

{
  size_t len_00;
  byte bVar1;
  int width;
  int len;
  int i;
  
  i = 0;
  while( true ) {
    if (*s == '\0') {
      return;
    }
    if (WcOption.use_wide == '\0') {
      bVar1 = WTF_WIDTH_MAP[(byte)*s] != '\0';
    }
    else {
      bVar1 = WTF_WIDTH_MAP[(byte)*s];
    }
    if (n < (int)(i + (uint)bVar1)) break;
    len_00 = wtf_len((wc_uchar *)s);
    addmch(s,len_00);
    s = s + len_00;
    i = i + (uint)bVar1;
  }
  return;
}



void addnstr_sup(char *s,int n)

{
  size_t len_00;
  byte bVar1;
  int width;
  int len;
  int i;
  
  i = 0;
  for (; *s != '\0'; s = s + len_00) {
    if (WcOption.use_wide == '\0') {
      bVar1 = WTF_WIDTH_MAP[(byte)*s] != '\0';
    }
    else {
      bVar1 = WTF_WIDTH_MAP[(byte)*s];
    }
    if (n < (int)(i + (uint)bVar1)) break;
    len_00 = wtf_len((wc_uchar *)s);
    addmch(s,len_00);
    i = i + (uint)bVar1;
  }
  for (; i < n; i = i + 1) {
    addch(' ');
  }
  return;
}



void crmode(void)

{
  ttymode_reset(2,0x400);
  ttymode_set(1,0);
  set_cc(6,1);
  return;
}



void nocrmode(void)

{
  ttymode_set(2,0);
  set_cc(6,4);
  return;
}



void term_echo(void)

{
  ttymode_set(8,0);
  return;
}



void term_noecho(void)

{
  ttymode_reset(8,0);
  return;
}



void term_raw(void)

{
  ttymode_reset(0x800b,0x1400);
  set_cc(6,1);
  return;
}



void term_cooked(void)

{
  ttymode_set(0x800b,0);
  set_cc(6,4);
  return;
}



void term_cbreak(void)

{
  term_cooked();
  term_noecho();
  return;
}



void term_title(char *s)

{
  if ((fmInitialized != '\0') && (title_str != (char *)0x0)) {
    fprintf((FILE *)ttyf,title_str,s);
  }
  return;
}



char getch(void)

{
  int *piVar1;
  ssize_t sVar2;
  char c;
  
  do {
    sVar2 = read(tty,&c,1);
    if (0 < sVar2) {
      return c;
    }
    piVar1 = __errno_location();
  } while ((*piVar1 == 4) || (piVar1 = __errno_location(), *piVar1 == 0xb));
  quitfm();
  return c;
}



char wgetch(void *p)

{
  int *piVar1;
  ssize_t sVar2;
  char c;
  
  do {
    sVar2 = read(tty,&c,1);
    if (0 < sVar2) {
      return c;
    }
    piVar1 = __errno_location();
  } while ((*piVar1 == 4) || (piVar1 = __errno_location(), *piVar1 == 0xb));
  quitfm();
  return c;
}



int do_getch(void)

{
  char cVar1;
  int iVar2;
  
  if (is_xterm == 0) {
    iVar2 = Gpm_Wgetch(0);
  }
  else {
    cVar1 = getch();
    iVar2 = (int)cVar1;
  }
  return iVar2;
}



void bell(void)

{
  write1('\a');
  return;
}



void skip_escseq(void)

{
  char cVar1;
  int c;
  
  cVar1 = getch();
  if ((cVar1 == '[') || (cVar1 == 'O')) {
    cVar1 = getch();
    c = (int)cVar1;
    if ((is_xterm == 0) || (c != 0x4d)) {
      while ((MYCTYPE_MAP[c & 0xff] & 8) != 0) {
        cVar1 = getch();
        c = (int)cVar1;
      }
    }
    else {
      getch();
      getch();
      getch();
    }
  }
  return;
}



int sleep_till_anykey(int sec,int purge)

{
  byte bVar1;
  char cVar2;
  int iVar3;
  int *piVar4;
  int iVar5;
  __fd_mask *p_Var6;
  int in_GS_OFFSET;
  fd_set rfd;
  timeval tim;
  int __d1;
  int __d0;
  int ret;
  int c;
  int er;
  TerminalMode ioval;
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  tcgetattr(tty,(termios *)&ioval);
  term_raw();
  tim.tv_sec = sec;
  tim.tv_usec = 0;
  iVar5 = 0x20;
  p_Var6 = rfd.__fds_bits;
  for (; iVar5 != 0; iVar5 = iVar5 + -1) {
    *p_Var6 = 0;
    p_Var6 = p_Var6 + 1;
  }
  iVar5 = tty;
  if (tty < 0) {
    iVar5 = tty + 0x1f;
  }
  bVar1 = (byte)(tty >> 0x37);
  rfd.__fds_bits[iVar5 >> 5] =
       1 << (((char)tty + (bVar1 >> 3) & 0x1f) - (bVar1 >> 3) & 0x1f) | rfd.__fds_bits[iVar5 >> 5];
  iVar5 = select(tty + 1,(fd_set *)&rfd,(fd_set *)0x0,(fd_set *)0x0,(timeval *)&tim);
  if ((0 < iVar5) && (purge != 0)) {
    cVar2 = getch();
    if (cVar2 == '\x1b') {
      skip_escseq();
    }
  }
  iVar3 = tcsetattr(tty,0,(termios *)&ioval);
  if (iVar3 == -1) {
    piVar4 = __errno_location();
    printf("Error occured: errno=%d\n",*piVar4);
    reset_exit(0);
  }
  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar5;
}



void mouse_init(void)

{
  int iVar1;
  Gpm_Connect conn;
  int r;
  
  if (mouseActive == 0) {
    conn.eventMask = 0xffff;
    conn.defaultMask = 0;
    conn.maxMod = 0;
    conn.minMod = 0;
    iVar1 = Gpm_Open(&conn,0);
    if (iVar1 == -2) {
      Gpm_Close();
      is_xterm = 3;
    }
    else if (-1 < iVar1) {
      gpm_handler = gpm_process_mouse;
      is_xterm = 0;
    }
    if (is_xterm != 0) {
      fwrite(&DAT_080cef05,1,0x10,(FILE *)ttyf);
      flush_tty();
    }
    mouseActive = 1;
  }
  return;
}



void mouse_end(void)

{
  if (mouseActive != 0) {
    if (is_xterm == 0) {
      Gpm_Close();
    }
    else {
      fwrite(&DAT_080cef16,1,0x10,(FILE *)ttyf);
      flush_tty();
    }
    mouseActive = 0;
  }
  return;
}



void mouse_active(void)

{
  if (mouseActive == 0) {
    mouse_init();
  }
  return;
}



void mouse_inactive(void)

{
  if ((mouseActive != 0) && (is_xterm != 0)) {
    mouse_end();
  }
  return;
}



void flush_tty(void)

{
  if (ttyf != (FILE *)0x0) {
    fflush((FILE *)ttyf);
  }
  return;
}



void touch_cursor(void)

{
  int iVar1;
  int i;
  
  touch_line();
  for (i = CurColumn;
      (iVar1 = CurColumn, -1 < i &&
      (touch_column(i), iVar1 = CurColumn, (ScreenImage[CurLine]->lineprop[i] & 0xc0) == 0x80));
      i = i + -1) {
  }
  while ((i = iVar1 + 1, i < COLS && ((ScreenImage[CurLine]->lineprop[i] & 0xc0) == 0x80))) {
    touch_column(i);
    iVar1 = i;
  }
  return;
}



table2 * loadMimeTypes(char *filename)

{
  char *pcVar1;
  FILE *__stream;
  table2 *ptVar2;
  Str p_Var3;
  char *p;
  table2 *mtypes;
  Str tmp;
  int n;
  int i;
  char *type;
  char *d;
  FILE *f;
  
  pcVar1 = expandPath(filename);
  __stream = fopen(pcVar1,"r");
  if (__stream == (FILE *)0x0) {
    ptVar2 = (table2 *)0x0;
  }
  else {
    n = 0;
    while (p_Var3 = Strfgets((FILE *)__stream), 0 < p_Var3->length) {
      if ((*p_Var3->ptr != '#') && (pcVar1 = strtok(p_Var3->ptr," \t\n\r"), pcVar1 != (char *)0x0))
      {
        d = strtok((char *)0x0," \t\n\r");
        i = 0;
        while (d != (char *)0x0) {
          d = strtok((char *)0x0," \t\n\r");
          i = i + 1;
        }
        n = n + i;
      }
    }
    fseek(__stream,0,0);
    ptVar2 = (table2 *)GC_malloc((n + 1) * 8);
    i = 0;
    while (p_Var3 = Strfgets((FILE *)__stream), 0 < p_Var3->length) {
      if ((*p_Var3->ptr != '#') && (pcVar1 = strtok(p_Var3->ptr," \t\n\r"), pcVar1 != (char *)0x0))
      {
        while (p = strtok((char *)0x0," \t\n\r"), p != (char *)0x0) {
          p_Var3 = Strnew_charp(p);
          ptVar2[i].item1 = p_Var3->ptr;
          p_Var3 = Strnew_charp(pcVar1);
          ptVar2[i].item2 = p_Var3->ptr;
          i = i + 1;
        }
      }
    }
    ptVar2[i].item1 = (char *)0x0;
    ptVar2[i].item2 = (char *)0x0;
    fclose(__stream);
  }
  return ptVar2;
}



void initMimeTypes(void)

{
  table2 **pptVar1;
  int iVar2;
  table2 *ptVar3;
  TextListItem *tl;
  int i;
  
  iVar2 = non_null(mimetypes_files);
  if (iVar2 == 0) {
    mimetypes_list = (TextList *)0x0;
  }
  else {
    mimetypes_list = make_domain_list(mimetypes_files);
  }
  if (mimetypes_list != (TextList *)0x0) {
    UserMimeTypes = (table2 **)GC_malloc((int)mimetypes_list->nitem << 2);
    i = 0;
    for (tl = mimetypes_list->first; tl != (TextListItem *)0x0; tl = tl->next) {
      pptVar1 = UserMimeTypes + i;
      ptVar3 = loadMimeTypes(tl->ptr);
      *pptVar1 = ptVar3;
      i = i + 1;
    }
  }
  return;
}



char * DefaultFile(int scheme)

{
  char *pcVar1;
  
  if (scheme == 1) {
    pcVar1 = allocStr("1",-1);
  }
  else {
    if (scheme < 2) {
      if (scheme == 0) {
        pcVar1 = allocStr("/",-1);
        return pcVar1;
      }
    }
    else if (scheme < 6) {
      pcVar1 = allocStr("/",-1);
      return pcVar1;
    }
    pcVar1 = (char *)0x0;
  }
  return pcVar1;
}



void KeyAbort(int _dummy)

{
                    // WARNING: Subroutine does not return
  siglongjmp((__jmp_buf_tag *)AbortLoading,1);
}



void write_from_file(int param_1,char *param_2)

{
  FILE *__stream;
  int iVar1;
  undefined local_d [9];
  
  __stream = fopen(param_2,"r");
  if (__stream != (FILE *)0x0) {
    while (iVar1 = fgetc(__stream), iVar1 != -1) {
      local_d[0] = (undefined)iVar1;
      write(param_1,local_d,1);
    }
    fclose(__stream);
  }
  return;
}



ParsedURL * baseURL(Buffer *buf)

{
  ParsedURL *pPVar1;
  
  if ((buf->bufferprop & 0x10U) == 0) {
    if (buf->baseURL == (ParsedURL *)0x0) {
      pPVar1 = &buf->currentURL;
    }
    else {
      pPVar1 = buf->baseURL;
    }
  }
  else {
    pPVar1 = (ParsedURL *)0x0;
  }
  return pPVar1;
}



int openSocket(char *hostname,char *remoteport_name,ushort remoteport_num)

{
  Str p_Var1;
  int iVar2;
  size_t sVar3;
  size_t sVar4;
  addrinfo hints;
  Str portbuf;
  anon_subr_void_int *prevtrap;
  char *hname;
  int error;
  addrinfo *res;
  addrinfo *res0;
  int *af;
  int sock;
  
  sock = -1;
  prevtrap = (anon_subr_void_int *)0x0;
  if (fmInitialized != '\0') {
    p_Var1 = Sprintf("Opening socket...");
    message(p_Var1->ptr,0,0);
    refresh();
  }
  iVar2 = __sigsetjmp(AbortLoading,1);
  if (iVar2 == 0) {
    if ((TrapSignal != '\0') && (prevtrap = mySignal(2,KeyAbort), fmInitialized != '\0')) {
      term_cbreak();
    }
    if (hostname != (char *)0x0) {
      hname = hostname;
      if (((hostname != (char *)0x0) && (*hostname == '[')) &&
         (sVar3 = strlen(hostname), hostname[sVar3 - 1] == ']')) {
        hname = allocStr(hostname + 1,-1);
        sVar3 = strlen(hname);
        hname[sVar3 - 1] = '\0';
        sVar3 = strspn(hname,"0123456789abcdefABCDEF:.");
        sVar4 = strlen(hname);
        if (sVar3 != sVar4) goto error;
      }
      af = (int *)ai_family_order_table[DNS_order];
      do {
        memset(&hints,0,0x20);
        hints.ai_family = *af;
        hints.ai_socktype = 1;
        if (remoteport_num == 0) {
          error = -1;
        }
        else {
          p_Var1 = Sprintf("%d",(uint)remoteport_num);
          error = getaddrinfo(hname,p_Var1->ptr,(addrinfo *)&hints,(addrinfo **)&res0);
        }
        if (((error != 0) && (remoteport_name != (char *)0x0)) && (*remoteport_name != '\0')) {
          error = getaddrinfo(hname,remoteport_name,(addrinfo *)&hints,(addrinfo **)&res0);
        }
        if (error == 0) {
          sock = -1;
          for (res = res0; res != (addrinfo *)0x0; res = res->ai_next) {
            sock = socket(res->ai_family,res->ai_socktype,res->ai_protocol);
            if (-1 < sock) {
              iVar2 = connect(sock,(sockaddr *)res->ai_addr,res->ai_addrlen);
              if (-1 < iVar2) break;
              close(sock);
              sock = -1;
            }
          }
          if (-1 < sock) {
            freeaddrinfo((addrinfo *)res0);
            if (TrapSignal == '\0') {
              return sock;
            }
            if (fmInitialized != '\0') {
              term_raw();
            }
            if (prevtrap == (anon_subr_void_int *)0x0) {
              return sock;
            }
            mySignal(2,prevtrap);
            return sock;
          }
          freeaddrinfo((addrinfo *)res0);
          iVar2 = *af;
        }
        else {
          iVar2 = *af;
        }
        if (iVar2 == 0) break;
        af = af + 1;
      } while( true );
    }
  }
  else if (-1 < sock) {
    close(sock);
  }
error:
  if (TrapSignal != '\0') {
    if (fmInitialized != '\0') {
      term_raw();
    }
    if (prevtrap != (anon_subr_void_int *)0x0) {
      mySignal(2,prevtrap);
    }
  }
  return -1;
}



char * copyPath(char *orgpath,int length,int option)

{
  int iVar1;
  Str x;
  Str tmp;
  
  x = Strnew();
  for (; (*orgpath != '\0' && (length != 0)); length = length + -1) {
    if ((MYCTYPE_MAP[(byte)*orgpath] & 2) == 0) {
      if (x->area_size <= x->length + 1) {
        Strgrow(x);
      }
      iVar1 = x->length;
      x->ptr[iVar1] = *orgpath;
      x->length = iVar1 + 1;
      x->ptr[x->length] = '\0';
    }
    else if (option != 1) {
      if (option == 2) {
        Strcat_charp(x,"%20");
      }
      else if (option == 0) {
        if (x->area_size <= x->length + 1) {
          Strgrow(x);
        }
        iVar1 = x->length;
        x->ptr[iVar1] = *orgpath;
        x->length = iVar1 + 1;
        x->ptr[x->length] = '\0';
      }
    }
    orgpath = orgpath + 1;
  }
  return x->ptr;
}



void parseURL(char *url,ParsedURL *p_url,ParsedURL *current)

{
  char cVar1;
  char *pcVar2;
  int iVar3;
  char *pcVar4;
  Str p_Var5;
  char *cgi;
  Str tmp;
  char *q;
  char *p;
  
  pcVar2 = url_quote(url);
  p_url->scheme = 0xfe;
  p_url->port = 0;
  p_url->user = (char *)0x0;
  p_url->pass = (char *)0x0;
  p_url->host = (char *)0x0;
  p_url->is_nocache = 0;
  p_url->file = (char *)0x0;
  p_url->real_file = (char *)0x0;
  p_url->query = (char *)0x0;
  p_url->label = (char *)0x0;
  p = pcVar2;
  if ((*pcVar2 == '\0') || (*pcVar2 == '#')) {
    if (current != (ParsedURL *)0x0) {
      copyParsedURL(p_url,current);
    }
    goto do_label;
  }
  iVar3 = getURLScheme(&p);
  p_url->scheme = iVar3;
  if (p_url->scheme == 0xfe) {
    if (current == (ParsedURL *)0x0) {
      p_url->scheme = 4;
    }
    else {
      switch(current->scheme) {
      default:
        p_url->scheme = current->scheme;
        break;
      case 2:
      case 3:
        p_url->scheme = 2;
        break;
      case 4:
      case 5:
        p_url->scheme = 4;
        break;
      case 7:
      case 8:
        p_url->scheme = 7;
        break;
      case 9:
      case 10:
        p_url->scheme = 9;
      }
    }
    p = pcVar2;
    iVar3 = strncmp(pcVar2,"//",2);
    if (iVar3 == 0) {
      p = p + 2;
analyze_url:
      while( true ) {
        while( true ) {
          pcVar2 = p;
          p = pcVar2;
          if (*p == '[') {
            do {
              do {
                pcVar4 = p;
                p = pcVar4 + 1;
              } while ((MYCTYPE_MAP[(byte)*p] & 0x28) != 0);
            } while ((*p == ':') || (*p == '.'));
            if ((*p != ']') ||
               ((pcVar4[2] != '\0' &&
                (pcVar4 = strchr(":/?#",(int)pcVar4[2]), pcVar4 == (char *)0x0)))) {
              p = pcVar2;
            }
          }
          while ((*p != '\0' && (pcVar4 = strchr(":/@?#",(int)*p), pcVar4 == (char *)0x0))) {
            p = p + 1;
          }
          cVar1 = *p;
          if (cVar1 != ':') break;
          pcVar2 = copyPath(pcVar2,(int)p - (int)pcVar2,1);
          p_url->host = pcVar2;
          pcVar2 = p + 1;
          p = pcVar2;
          while ((*p != '\0' && (pcVar4 = strchr("@/?#",(int)*p), pcVar4 == (char *)0x0))) {
            p = p + 1;
          }
          if (*p != '@') {
            p_Var5 = Strnew_charp_n(pcVar2,(int)p - (int)pcVar2);
            iVar3 = atoi(p_Var5->ptr);
            p_url->port = iVar3;
            goto analyze_file;
          }
          pcVar2 = copyPath(pcVar2,(int)p - (int)pcVar2,0);
          p_url->pass = pcVar2;
          p = p + 1;
          p_url->user = p_url->host;
          p_url->host = (char *)0x0;
        }
        if (cVar1 < ';') break;
        if (cVar1 == '?') goto LAB_0809f322;
        if (cVar1 != '@') goto analyze_file;
        pcVar2 = copyPath(pcVar2,(int)p - (int)pcVar2,1);
        p_url->user = pcVar2;
        p = p + 1;
      }
      if (((cVar1 == '#') || (cVar1 == '/')) || (cVar1 == '\0')) {
LAB_0809f322:
        pcVar2 = copyPath(pcVar2,(int)p - (int)pcVar2,1);
        p_url->host = pcVar2;
        p_url->port = DefaultPort[p_url->scheme];
      }
    }
  }
  else {
    if (p_url->scheme == 0xff) {
      pcVar2 = allocStr(pcVar2,-1);
      p_url->file = pcVar2;
      return;
    }
    if ((*p == '/') && (p[1] == '/')) {
      if ((p_url->scheme != 4) || ((p[2] != '/' && (p[2] != '~')))) {
        p = p + 2;
        goto analyze_url;
      }
      p = p + 2;
    }
    else {
      p_url->host = (char *)0x0;
      if (p_url->scheme == 0xff) {
        p_url->port = 0;
      }
      else {
        p_url->port = DefaultPort[p_url->scheme];
      }
    }
  }
analyze_file:
  if (((p_url->scheme == 4) && (p_url->user == (char *)0x0)) &&
     ((p_url->host != (char *)0x0 &&
      (((*p_url->host != '\0' && (iVar3 = strcmp(p_url->host,"localhost"), iVar3 != 0)) &&
       (p_url->scheme = 2, p_url->port == 0)))))) {
    p_url->port = DefaultPort[2];
  }
  if ((((*p == '\0') || (*p == '#')) || (*p == '?')) && (p_url->host == (char *)0x0)) {
    p_url->file = "";
  }
  else {
    q = p;
    if (p_url->scheme == 1) {
      if (*p == '/') {
        q = p + 1;
      }
      if (((*q != '\0') && (*q != '/')) && ((q[1] != '/' && (q[2] == '/')))) {
        q = q + 1;
      }
    }
    if (*p == '/') {
      p = p + 1;
    }
    if (((*p == '\0') || (*p == '#')) || (*p == '?')) {
      pcVar2 = DefaultFile(p_url->scheme);
      p_url->file = pcVar2;
    }
    else if ((p_url->scheme == 1) && (*p == 'R')) {
      p = p + 1;
      p_Var5 = Strnew();
      if (p_Var5->area_size <= p_Var5->length + 1) {
        Strgrow(p_Var5);
      }
      iVar3 = p_Var5->length;
      p_Var5->ptr[iVar3] = *p;
      p_Var5->length = iVar3 + 1;
      p_Var5->ptr[p_Var5->length] = '\0';
      do {
        p = p + 1;
        if (*p == '\0') break;
      } while (*p != '/');
      Strcat_charp(p_Var5,p);
      for (; *p != '\0'; p = p + 1) {
      }
      pcVar2 = copyPath(p_Var5->ptr,-1,1);
      p_url->file = pcVar2;
    }
    else {
      pcVar2 = strchr(p,0x3f);
      while( true ) {
        for (; ((*p != '\0' && (*p != '#')) && (p != pcVar2)); p = p + 1) {
        }
        if ((*p != '#') || (p_url->scheme != 4)) goto LAB_0809f61d;
        if (((p <= q) || (p[-1] != '/')) || ((pcVar2 != (char *)0x0 && (pcVar2 <= p)))) break;
        p = p + 1;
      }
      if (p[1] == '\0') {
        p = p + 1;
      }
LAB_0809f61d:
      if ((p_url->scheme == 4) || (p_url->scheme == 0xfe)) {
        pcVar2 = copyPath(q,(int)p - (int)q,0);
        p_url->file = pcVar2;
      }
      else {
        pcVar2 = copyPath(q,(int)p - (int)q,1);
        p_url->file = pcVar2;
      }
    }
  }
  if (*p == '?') {
    pcVar2 = p + 1;
    for (p = pcVar2; (*p != '\0' && (*p != '#')); p = p + 1) {
    }
    pcVar2 = copyPath(pcVar2,(int)p - (int)pcVar2,0);
    p_url->query = pcVar2;
  }
do_label:
  if (p_url->scheme == 0xfe) {
    p_url->scheme = 4;
    pcVar2 = allocStr(p,-1);
    p_url->file = pcVar2;
    p_url->label = (char *)0x0;
  }
  else if (*p == '#') {
    pcVar2 = allocStr(p + 1,-1);
    p_url->label = pcVar2;
  }
  else {
    p_url->label = (char *)0x0;
  }
  return;
}



void copyParsedURL(ParsedURL *p,ParsedURL *q)

{
  char *pcVar1;
  
  p->scheme = q->scheme;
  p->port = q->port;
  p->is_nocache = q->is_nocache;
  if (q->user == (char *)0x0) {
    pcVar1 = (char *)0x0;
  }
  else {
    pcVar1 = allocStr(q->user,-1);
  }
  p->user = pcVar1;
  if (q->pass == (char *)0x0) {
    pcVar1 = (char *)0x0;
  }
  else {
    pcVar1 = allocStr(q->pass,-1);
  }
  p->pass = pcVar1;
  if (q->host == (char *)0x0) {
    pcVar1 = (char *)0x0;
  }
  else {
    pcVar1 = allocStr(q->host,-1);
  }
  p->host = pcVar1;
  if (q->file == (char *)0x0) {
    pcVar1 = (char *)0x0;
  }
  else {
    pcVar1 = allocStr(q->file,-1);
  }
  p->file = pcVar1;
  if (q->real_file == (char *)0x0) {
    pcVar1 = (char *)0x0;
  }
  else {
    pcVar1 = allocStr(q->real_file,-1);
  }
  p->real_file = pcVar1;
  if (q->label == (char *)0x0) {
    pcVar1 = (char *)0x0;
  }
  else {
    pcVar1 = allocStr(q->label,-1);
  }
  p->label = pcVar1;
  if (q->query == (char *)0x0) {
    pcVar1 = (char *)0x0;
  }
  else {
    pcVar1 = allocStr(q->query,-1);
  }
  p->query = pcVar1;
  return;
}



void parseURL2(char *url,ParsedURL *pu,ParsedURL *current)

{
  bool bVar1;
  char *pcVar2;
  char *pcVar3;
  Str p_Var4;
  int iVar5;
  char *q;
  int relative_uri;
  Str tmp;
  char *p;
  
  bVar1 = false;
  parseURL(url,pu,current);
  if (pu->scheme != 0xb) {
    if ((pu->scheme == 9) || (pu->scheme == 10)) {
      if (((pu->file == (char *)0x0) || (pcVar2 = strchr(pu->file,0x40), pcVar2 != (char *)0x0)) ||
         (((pcVar2 = strchr(pu->file,0x2f), pcVar2 != (char *)0x0 &&
           (pcVar3 = strchr(pcVar2 + 1,0x2d), pcVar3 == (char *)0x0)) && (pcVar2[1] != '\0')))) {
        pu->scheme = 9;
      }
      else {
        pu->scheme = 10;
      }
    }
    else if ((pu->scheme == 7) || (pu->scheme == 8)) {
      if ((pu->file != (char *)0x0) && (*pu->file == '/')) {
        pcVar2 = allocStr(pu->file + 1,-1);
        pu->file = pcVar2;
      }
      if (((pu->file == (char *)0x0) || (pcVar2 = strchr(pu->file,0x40), pcVar2 != (char *)0x0)) ||
         ((pcVar2 = strchr(pu->file,0x2f), pcVar2 != (char *)0x0 &&
          ((pcVar3 = strchr(pcVar2 + 1,0x2d), pcVar3 == (char *)0x0 && (pcVar2[1] != '\0')))))) {
        pu->scheme = 7;
      }
      else {
        pu->scheme = 8;
      }
      if ((current != (ParsedURL *)0x0) &&
         (((current->scheme == 7 || (current->scheme == 8)) && (pu->host == (char *)0x0)))) {
        pu->host = current->host;
        pu->port = current->port;
      }
    }
    else {
      if (pu->scheme == 4) {
        pcVar2 = file_unquote(pu->file);
        pcVar2 = expandName(pcVar2);
        pcVar2 = file_quote(pcVar2);
        pu->file = pcVar2;
      }
      if ((current != (ParsedURL *)0x0) &&
         ((((pu->scheme == current->scheme || ((pu->scheme == 2 && (current->scheme == 3)))) ||
           ((pu->scheme == 4 && (current->scheme == 5)))) && (pu->host == (char *)0x0)))) {
        pu->user = current->user;
        pu->pass = current->pass;
        pu->host = current->host;
        pu->port = current->port;
        if ((pu->file == (char *)0x0) || (*pu->file == '\0')) {
          pu->file = current->file;
          if (pu->query == (char *)0x0) {
            pu->query = current->query;
          }
        }
        else if ((((pu->scheme == 0xff) && (pcVar2 = strchr(pu->file,0x3a), pcVar2 == (char *)0x0))
                 && (current != (ParsedURL *)0x0)) &&
                (pcVar2 = strchr(current->file,0x3a), pcVar2 != (char *)0x0)) {
          pcVar3 = pu->file;
          pcVar2 = allocStr(current->file,(int)pcVar2 - (int)current->file);
          p_Var4 = Sprintf("%s:%s",pcVar2,pcVar3);
          pu->file = p_Var4->ptr;
        }
        else if ((pu->scheme == 1) || (*pu->file == '/')) {
          if ((pu->scheme == 1) && (*pu->file == '/')) {
            pcVar2 = allocStr(pu->file + 1,-1);
            pu->file = pcVar2;
          }
        }
        else {
          pcVar2 = pu->file;
          if (current->file != (char *)0x0) {
            p_Var4 = Strnew_charp(current->file);
            while ((0 < p_Var4->length &&
                   ((p_Var4->length < 1 || (p_Var4->ptr[p_Var4->length + -1] != '/'))))) {
              Strshrink(p_Var4,1);
            }
            Strcat_charp(p_Var4,pcVar2);
            pu->file = p_Var4->ptr;
            bVar1 = true;
          }
        }
      }
      if (pu->file != (char *)0x0) {
        if (((pu->scheme == 4) && (*pu->file != '/')) && (iVar5 = strcmp(pu->file,"-"), iVar5 != 0))
        {
          p_Var4 = Strnew_charp(CurrentDir);
          if ((p_Var4->length < 1) || (p_Var4->ptr[p_Var4->length + -1] != '/')) {
            if (p_Var4->area_size <= p_Var4->length + 1) {
              Strgrow(p_Var4);
            }
            iVar5 = p_Var4->length;
            p_Var4->ptr[iVar5] = '/';
            p_Var4->length = iVar5 + 1;
            p_Var4->ptr[p_Var4->length] = '\0';
          }
          pcVar2 = file_unquote(pu->file);
          Strcat_charp(p_Var4,pcVar2);
          pcVar2 = cleanupName(p_Var4->ptr);
          pcVar2 = file_quote(pcVar2);
          pu->file = pcVar2;
        }
        else if (pu->scheme == 0) {
          if (bVar1) {
            pcVar2 = cleanupName(pu->file);
            pu->file = pcVar2;
          }
        }
        else if ((pu->scheme != 1) && (*pu->file == '/')) {
          pcVar2 = cleanupName(pu->file);
          pu->file = pcVar2;
        }
        if (pu->scheme == 4) {
          pcVar2 = file_unquote(pu->file);
          pcVar2 = cleanupName(pcVar2);
          pu->real_file = pcVar2;
        }
      }
    }
  }
  return;
}



Str _parsedURL2Str(ParsedURL *pu,int pass)

{
  Str x;
  int iVar1;
  Str y;
  Str tmp;
  
  if (pu->scheme == 0xfe) {
    x = Strnew_charp("???");
  }
  else if (pu->scheme == 0xff) {
    x = Strnew_charp(pu->file);
  }
  else if (((pu->host == (char *)0x0) && (pu->file == (char *)0x0)) && (pu->label != (char *)0x0)) {
    x = Sprintf("#%s",pu->label);
  }
  else if ((pu->scheme == 4) && (iVar1 = strcmp(pu->file,"-"), iVar1 == 0)) {
    x = Strnew_charp("-");
    if (pu->label != (char *)0x0) {
      if (x->area_size <= x->length + 1) {
        Strgrow(x);
      }
      iVar1 = x->length;
      x->ptr[iVar1] = '#';
      x->length = iVar1 + 1;
      x->ptr[x->length] = '\0';
      Strcat_charp(x,pu->label);
    }
  }
  else {
    x = Strnew_charp(_parsedURL2Str::scheme_str[pu->scheme]);
    if (x->area_size <= x->length + 1) {
      Strgrow(x);
    }
    iVar1 = x->length;
    x->ptr[iVar1] = ':';
    x->length = iVar1 + 1;
    x->ptr[x->length] = '\0';
    if (pu->scheme == 0xb) {
      Strcat_charp(x,pu->file);
    }
    else {
      if ((pu->scheme != 9) && (pu->scheme != 10)) {
        Strcat_charp(x,"//");
      }
      if (pu->user != (char *)0x0) {
        Strcat_charp(x,pu->user);
        if ((pass != 0) && (pu->pass != (char *)0x0)) {
          if (x->area_size <= x->length + 1) {
            Strgrow(x);
          }
          iVar1 = x->length;
          x->ptr[iVar1] = ':';
          x->length = iVar1 + 1;
          x->ptr[x->length] = '\0';
          Strcat_charp(x,pu->pass);
        }
        if (x->area_size <= x->length + 1) {
          Strgrow(x);
        }
        iVar1 = x->length;
        x->ptr[iVar1] = '@';
        x->length = iVar1 + 1;
        x->ptr[x->length] = '\0';
      }
      if ((pu->host != (char *)0x0) &&
         (Strcat_charp(x,pu->host), pu->port != DefaultPort[pu->scheme])) {
        if (x->area_size <= x->length + 1) {
          Strgrow(x);
        }
        iVar1 = x->length;
        x->ptr[iVar1] = ':';
        x->length = iVar1 + 1;
        x->ptr[x->length] = '\0';
        y = Sprintf("%d",pu->port);
        Strcat(x,y);
      }
      if (((pu->scheme != 9) && (pu->scheme != 10)) &&
         ((pu->file == (char *)0x0 || (*pu->file != '/')))) {
        if (x->area_size <= x->length + 1) {
          Strgrow(x);
        }
        iVar1 = x->length;
        x->ptr[iVar1] = '/';
        x->length = iVar1 + 1;
        x->ptr[x->length] = '\0';
      }
      Strcat_charp(x,pu->file);
      if ((pu->scheme == 3) && ((x->length < 1 || (x->ptr[x->length + -1] != '/')))) {
        if (x->area_size <= x->length + 1) {
          Strgrow(x);
        }
        iVar1 = x->length;
        x->ptr[iVar1] = '/';
        x->length = iVar1 + 1;
        x->ptr[x->length] = '\0';
      }
      if (pu->query != (char *)0x0) {
        if (x->area_size <= x->length + 1) {
          Strgrow(x);
        }
        iVar1 = x->length;
        x->ptr[iVar1] = '?';
        x->length = iVar1 + 1;
        x->ptr[x->length] = '\0';
        Strcat_charp(x,pu->query);
      }
      if (pu->label != (char *)0x0) {
        if (x->area_size <= x->length + 1) {
          Strgrow(x);
        }
        iVar1 = x->length;
        x->ptr[iVar1] = '#';
        x->length = iVar1 + 1;
        x->ptr[x->length] = '\0';
        Strcat_charp(x,pu->label);
      }
    }
  }
  return x;
}



Str parsedURL2Str(ParsedURL *pu)

{
  Str p_Var1;
  
  p_Var1 = _parsedURL2Str(pu,0);
  return p_Var1;
}



int getURLScheme(char **url)

{
  char *__s;
  size_t __n;
  int iVar1;
  int len;
  int scheme;
  int i;
  char *q;
  char *p;
  
  p = *url;
  scheme = 0xfe;
  for (; (*p != '\0' &&
         (((((MYCTYPE_MAP[(byte)*p] & 0xc) != 0 || (*p == '.')) || (*p == '+')) || (*p == '-'))));
      p = p + 1) {
  }
  if (*p == ':') {
    scheme = 0xff;
    for (i = 0; __s = schemetable[i].cmdname, __s != (char *)0x0; i = i + 1) {
      __n = strlen(__s);
      iVar1 = strncasecmp(__s,*url,__n);
      if ((iVar1 == 0) && ((*url)[__n] == ':')) {
        iVar1 = schemetable[i].cmd;
        *url = p + 1;
        return iVar1;
      }
    }
  }
  return scheme;
}



char * otherinfo(ParsedURL *target,ParsedURL *current,char *referer)

{
  Str x;
  Str p_Var1;
  char *pcVar2;
  char *p_1;
  char *p;
  Str s;
  
  x = Strnew();
  Strcat_charp(x,"User-Agent: ");
  if ((UserAgent == (char *)0x0) || (*UserAgent == '\0')) {
    Strcat_charp(x,w3m_version);
  }
  else {
    Strcat_charp(x,UserAgent);
  }
  Strcat_charp(x,"\r\n");
  Strcat_m_charp(x,"Accept: ",AcceptMedia,&DAT_080cf135,0);
  Strcat_m_charp(x,"Accept-Encoding: ",AcceptEncoding,&DAT_080cf135,0);
  Strcat_m_charp(x,"Accept-Language: ",AcceptLang,&DAT_080cf135,0);
  if (target->host != (char *)0x0) {
    Strcat_charp(x,"Host: ");
    Strcat_charp(x,target->host);
    if (target->port != DefaultPort[target->scheme]) {
      p_Var1 = Sprintf(":%d",target->port);
      Strcat(x,p_Var1);
    }
    Strcat_charp(x,"\r\n");
  }
  if ((target->is_nocache != 0) || (NoCache != '\0')) {
    Strcat_charp(x,"Pragma: no-cache\r\n");
    Strcat_charp(x,"Cache-control: no-cache\r\n");
  }
  if (NoSendReferer == 0) {
    if ((((referer == (char *)0x0) && (current != (ParsedURL *)0x0)) && (current->scheme != 4)) &&
       ((current->scheme != 2 || ((current->user == (char *)0x0 && (current->pass == (char *)0x0))))
       )) {
      pcVar2 = current->label;
      Strcat_charp(x,"Referer: ");
      current->label = (char *)0x0;
      p_Var1 = parsedURL2Str(current);
      Strcat(x,p_Var1);
      current->label = pcVar2;
      Strcat_charp(x,"\r\n");
    }
    else if ((referer != (char *)0x0) && (referer != (char *)0xffffffff)) {
      pcVar2 = strchr(referer,0x23);
      Strcat_charp(x,"Referer: ");
      if (pcVar2 == (char *)0x0) {
        Strcat_charp(x,referer);
      }
      else {
        Strcat_charp_n(x,referer,(int)pcVar2 - (int)referer);
      }
      Strcat_charp(x,"\r\n");
    }
  }
  return x->ptr;
}



Str HTTPrequestMethod(HRequest *hr)

{
  char cVar1;
  Str p_Var2;
  
  cVar1 = hr->command;
  if (cVar1 == '\x02') {
    p_Var2 = Strnew_charp("CONNECT");
  }
  else if (cVar1 == '\x03') {
    p_Var2 = Strnew_charp("HEAD");
  }
  else if (cVar1 == '\x01') {
    p_Var2 = Strnew_charp("POST");
  }
  else {
    p_Var2 = Strnew_charp("GET");
  }
  return p_Var2;
}



Str HTTPrequestURI(ParsedURL *pu,HRequest *hr)

{
  int iVar1;
  char *pcVar2;
  Str x;
  Str p_Var3;
  char *save_label;
  Str tmp;
  
  x = Strnew();
  if (hr->command == '\x02') {
    Strcat_charp(x,pu->host);
    p_Var3 = Sprintf(":%d",pu->port);
    Strcat(x,p_Var3);
  }
  else if ((hr->flag & 1U) == 0) {
    pcVar2 = pu->label;
    pu->label = (char *)0x0;
    p_Var3 = _parsedURL2Str(pu,1);
    Strcat(x,p_Var3);
    pu->label = pcVar2;
  }
  else {
    Strcat_charp(x,pu->file);
    if (pu->query != (char *)0x0) {
      if (x->area_size <= x->length + 1) {
        Strgrow(x);
      }
      iVar1 = x->length;
      x->ptr[iVar1] = '?';
      x->length = iVar1 + 1;
      x->ptr[x->length] = '\0';
      Strcat_charp(x,pu->query);
    }
  }
  return x;
}



Str HTTPrequest(ParsedURL *pu,ParsedURL *current,HRequest *hr,TextList *extra)

{
  Str x;
  Str p_Var1;
  char *pcVar2;
  Str cookie;
  int seen_proxy_auth;
  int seen_www_auth;
  TextListItem *i;
  Str tmp;
  
  x = HTTPrequestMethod(hr);
  Strcat_charp(x," ");
  p_Var1 = HTTPrequestURI(pu,hr);
  Strcat_charp(x,p_Var1->ptr);
  Strcat_charp(x," HTTP/1.0\r\n");
  if (hr->referer == (char *)0xffffffff) {
    pcVar2 = otherinfo(pu,(ParsedURL *)0x0,(char *)0x0);
    Strcat_charp(x,pcVar2);
  }
  else {
    pcVar2 = otherinfo(pu,current,hr->referer);
    Strcat_charp(x,pcVar2);
  }
  if (extra != (TextList *)0x0) {
    for (i = extra->first; i != (TextListItem *)0x0; i = i->next) {
      strncasecmp(i->ptr,"Authorization:",0xe);
      strncasecmp(i->ptr,"Proxy-Authorization:",0x14);
      Strcat_charp(x,i->ptr);
    }
  }
  if (((hr->command != '\x02') && (use_cookie != 0)) &&
     (p_Var1 = find_cookie(pu), p_Var1 != (Str)0x0)) {
    Strcat_charp(x,"Cookie: ");
    Strcat(x,p_Var1);
    Strcat_charp(x,"\r\n");
    if (*p_Var1->ptr != '$') {
      Strcat_charp(x,"Cookie2: $Version=\"1\"\r\n");
    }
  }
  if (hr->command == '\x01') {
    if (hr->request->enctype == 1) {
      Strcat_charp(x,"Content-type: multipart/form-data; boundary=");
      Strcat_charp(x,hr->request->boundary);
      Strcat_charp(x,"\r\n");
      p_Var1 = Sprintf("Content-length: %ld\r\n",hr->request->length);
      Strcat(x,p_Var1);
      Strcat_charp(x,"\r\n");
    }
    else {
      if (override_content_type == 0) {
        Strcat_charp(x,"Content-type: application/x-www-form-urlencoded\r\n");
      }
      p_Var1 = Sprintf("Content-length: %ld\r\n",hr->request->length);
      Strcat(x,p_Var1);
      if (header_string != (Str)0x0) {
        Strcat(x,header_string);
      }
      Strcat_charp(x,"\r\n");
      Strcat_charp_n(x,hr->request->body,hr->request->length);
      Strcat_charp(x,"\r\n");
    }
  }
  else {
    if (header_string != (Str)0x0) {
      Strcat(x,header_string);
    }
    Strcat_charp(x,"\r\n");
  }
  return x;
}



void init_stream(URLFile *uf,int scheme,InputStream stream)

{
  memset(uf,0,0x20);
  uf->stream = stream;
  uf->scheme = (uchar)scheme;
  uf->encoding = '\0';
  uf->is_cgi = '\0';
  uf->compression = 0;
  uf->content_encoding = 0;
  uf->guess_type = (char *)0x0;
  uf->ext = (char *)0x0;
  uf->modtime = -1;
  return;
}



// WARNING: Could not reconcile some variable overlaps

URLFile * openURL(URLFile *__return_storage_ptr__,char *url,ParsedURL *pu,ParsedURL *current,
                 URLOption *option,FormList *request,TextList *extra_header,URLFile *ouf,
                 HRequest *hr,uchar *status)

{
  Str p_Var1;
  char *pcVar2;
  FILE *pFVar3;
  FILE *__s;
  int iVar4;
  InputStream piVar5;
  URLFile uf;
  HRequest hr0;
  FILE *ff;
  Str tmp2;
  char *u;
  char *q;
  char *p;
  int scheme;
  int sock;
  Str tmp;
  
  if (hr == (HRequest *)0x0) {
    hr = &hr0;
  }
  if (ouf == (URLFile *)0x0) {
    init_stream(&uf,0xfe,(InputStream)0x0);
  }
  else {
    uf._0_4_ = *(uint *)ouf;
    uf.stream = ouf->stream;
    uf.ext = ouf->ext;
    uf.compression = ouf->compression;
    uf.content_encoding = ouf->content_encoding;
    uf.guess_type = ouf->guess_type;
    uf.url = ouf->url;
    uf.modtime = ouf->modtime;
  }
  u = url;
  scheme = getURLScheme(&u);
  if (((current == (ParsedURL *)0x0) && (scheme == 0xfe)) && (ArgvIsURL == '\0')) {
    u = file_to_url(url);
  }
  else {
    u = url;
  }
retry:
  parseURL2(u,pu,current);
  if ((pu->scheme == 4) && (pu->file == (char *)0x0)) {
    if (pu->label == (char *)0x0) {
      *(uint *)__return_storage_ptr__ = uf._0_4_;
      __return_storage_ptr__->stream = uf.stream;
      __return_storage_ptr__->ext = uf.ext;
      __return_storage_ptr__->compression = uf.compression;
      __return_storage_ptr__->content_encoding = uf.content_encoding;
      __return_storage_ptr__->guess_type = uf.guess_type;
      __return_storage_ptr__->url = uf.url;
      __return_storage_ptr__->modtime = uf.modtime;
      return __return_storage_ptr__;
    }
    p_Var1 = Strnew_charp("#");
    Strcat_charp(p_Var1,pu->label);
    pu->file = p_Var1->ptr;
    pcVar2 = file_unquote(pu->file);
    pcVar2 = cleanupName(pcVar2);
    pu->real_file = pcVar2;
    pu->label = (char *)0x0;
  }
  uf._0_4_ = uf._0_4_ & 0xffffff00 | pu->scheme & 0xffU;
  p_Var1 = parsedURL2Str(pu);
  uf.url = p_Var1->ptr;
  pu->is_nocache = option->flag & 1;
  uf.ext = filename_extension(pu->file,1);
  hr->command = '\0';
  hr->flag = '\0';
  hr->referer = option->referer;
  hr->request = request;
  switch(pu->scheme) {
  case 0:
    if (pu->file == (char *)0x0) {
      pcVar2 = allocStr("/",-1);
      pu->file = pcVar2;
    }
    if (((request != (FormList *)0x0) && (request->method == 1)) && (request->body != (char *)0x0))
    {
      hr->command = '\x01';
    }
    if ((request != (FormList *)0x0) && (request->method == 3)) {
      hr->command = '\x03';
    }
    iVar4 = non_null(HTTP_proxy);
    if ((((iVar4 == 0) || (use_proxy == '\0')) || (pu->host == (char *)0x0)) ||
       (iVar4 = check_no_proxy(pu->host), iVar4 != 0)) {
      sock = openSocket(pu->host,schemetable[pu->scheme].cmdname,(ushort)pu->port);
      if (sock < 0) {
        *status = 0xfe;
        *(uint *)__return_storage_ptr__ = uf._0_4_;
        __return_storage_ptr__->stream = uf.stream;
        __return_storage_ptr__->ext = uf.ext;
        __return_storage_ptr__->compression = uf.compression;
        __return_storage_ptr__->content_encoding = uf.content_encoding;
        __return_storage_ptr__->guess_type = uf.guess_type;
        __return_storage_ptr__->url = uf.url;
        __return_storage_ptr__->modtime = uf.modtime;
        return __return_storage_ptr__;
      }
      hr->flag = hr->flag | 1;
      tmp = HTTPrequest(pu,current,hr,extra_header);
      *status = '\0';
    }
    else {
      hr->flag = hr->flag | 2;
      sock = openSocket(HTTP_proxy_parsed.host,schemetable[HTTP_proxy_parsed.scheme].cmdname,
                        (ushort)HTTP_proxy_parsed.port);
      if (sock < 0) {
        *(uint *)__return_storage_ptr__ = uf._0_4_;
        __return_storage_ptr__->stream = uf.stream;
        __return_storage_ptr__->ext = uf.ext;
        __return_storage_ptr__->compression = uf.compression;
        __return_storage_ptr__->content_encoding = uf.content_encoding;
        __return_storage_ptr__->guess_type = uf.guess_type;
        __return_storage_ptr__->url = uf.url;
        __return_storage_ptr__->modtime = uf.modtime;
        return __return_storage_ptr__;
      }
      tmp = HTTPrequest(pu,current,hr,extra_header);
      *status = '\0';
    }
    write(sock,tmp->ptr,tmp->length);
    if (w3m_reqlog != (char *)0x0) {
      __s = fopen(w3m_reqlog,"a");
      fwrite(tmp->ptr,1,tmp->length,__s);
      fclose(__s);
    }
    if ((hr->command == '\x01') && (request->enctype == 1)) {
      write_from_file(sock,request->body);
    }
    break;
  case 1:
    iVar4 = non_null(GOPHER_proxy);
    if (((iVar4 == 0) || (use_proxy == '\0')) ||
       ((pu->host == (char *)0x0 || (iVar4 = check_no_proxy(pu->host), iVar4 != 0)))) {
      sock = openSocket(pu->host,schemetable[pu->scheme].cmdname,(ushort)pu->port);
      if (sock < 0) {
        *(uint *)__return_storage_ptr__ = uf._0_4_;
        __return_storage_ptr__->stream = uf.stream;
        __return_storage_ptr__->ext = uf.ext;
        __return_storage_ptr__->compression = uf.compression;
        __return_storage_ptr__->content_encoding = uf.content_encoding;
        __return_storage_ptr__->guess_type = uf.guess_type;
        __return_storage_ptr__->url = uf.url;
        __return_storage_ptr__->modtime = uf.modtime;
        return __return_storage_ptr__;
      }
      if (pu->file == (char *)0x0) {
        pu->file = "1";
      }
      pcVar2 = file_unquote(pu->file);
      tmp = Strnew_charp(pcVar2);
      if (tmp->area_size <= tmp->length + 1) {
        Strgrow(tmp);
      }
      iVar4 = tmp->length;
      tmp->ptr[iVar4] = '\n';
      tmp->length = iVar4 + 1;
      tmp->ptr[tmp->length] = '\0';
    }
    else {
      hr->flag = hr->flag | 2;
      sock = openSocket(GOPHER_proxy_parsed.host,schemetable[GOPHER_proxy_parsed.scheme].cmdname,
                        (ushort)GOPHER_proxy_parsed.port);
      if (sock < 0) {
        *(uint *)__return_storage_ptr__ = uf._0_4_;
        __return_storage_ptr__->stream = uf.stream;
        __return_storage_ptr__->ext = uf.ext;
        __return_storage_ptr__->compression = uf.compression;
        __return_storage_ptr__->content_encoding = uf.content_encoding;
        __return_storage_ptr__->guess_type = uf.guess_type;
        __return_storage_ptr__->url = uf.url;
        __return_storage_ptr__->modtime = uf.modtime;
        return __return_storage_ptr__;
      }
      uf._0_4_ = uf._0_4_ & 0xffffff00;
      tmp = HTTPrequest(pu,current,hr,extra_header);
    }
    write(sock,tmp->ptr,tmp->length);
    break;
  case 2:
  case 3:
    if (pu->file == (char *)0x0) {
      pcVar2 = allocStr("/",-1);
      pu->file = pcVar2;
    }
    iVar4 = non_null(FTP_proxy);
    if ((((iVar4 == 0) || (use_proxy == '\0')) || (pu->host == (char *)0x0)) ||
       (iVar4 = check_no_proxy(pu->host), iVar4 != 0)) {
      piVar5 = openFTPStream(pu,&uf);
      uf._0_4_ = uf._0_4_ & 0xffffff00 | pu->scheme & 0xffU;
      *(uint *)__return_storage_ptr__ = uf._0_4_;
      __return_storage_ptr__->stream = piVar5;
      __return_storage_ptr__->ext = uf.ext;
      __return_storage_ptr__->compression = uf.compression;
      __return_storage_ptr__->content_encoding = uf.content_encoding;
      __return_storage_ptr__->guess_type = uf.guess_type;
      __return_storage_ptr__->url = uf.url;
      __return_storage_ptr__->modtime = uf.modtime;
      return __return_storage_ptr__;
    }
    hr->flag = hr->flag | 2;
    sock = openSocket(FTP_proxy_parsed.host,schemetable[FTP_proxy_parsed.scheme].cmdname,
                      (ushort)FTP_proxy_parsed.port);
    if (sock < 0) {
      *(uint *)__return_storage_ptr__ = uf._0_4_;
      __return_storage_ptr__->stream = uf.stream;
      __return_storage_ptr__->ext = uf.ext;
      __return_storage_ptr__->compression = uf.compression;
      __return_storage_ptr__->content_encoding = uf.content_encoding;
      __return_storage_ptr__->guess_type = uf.guess_type;
      __return_storage_ptr__->url = uf.url;
      __return_storage_ptr__->modtime = uf.modtime;
      return __return_storage_ptr__;
    }
    uf._0_4_ = uf._0_4_ & 0xffffff00;
    tmp = HTTPrequest(pu,current,hr,extra_header);
    write(sock,tmp->ptr,tmp->length);
    break;
  case 4:
  case 5:
    goto switchD_080a0f2d_caseD_4;
  default:
    *(uint *)__return_storage_ptr__ = uf._0_4_;
    __return_storage_ptr__->stream = uf.stream;
    __return_storage_ptr__->ext = uf.ext;
    __return_storage_ptr__->compression = uf.compression;
    __return_storage_ptr__->content_encoding = uf.content_encoding;
    __return_storage_ptr__->guess_type = uf.guess_type;
    __return_storage_ptr__->url = uf.url;
    __return_storage_ptr__->modtime = uf.modtime;
    return __return_storage_ptr__;
  case 7:
  case 8:
  case 9:
  case 10:
    if ((pu->scheme == 7) || (pu->scheme == 9)) {
      uf._0_4_ = CONCAT31(uf._1_3_,9);
    }
    else {
      uf._0_4_ = CONCAT31(uf._1_3_,10);
    }
    piVar5 = openNewsStream(pu);
    *(uint *)__return_storage_ptr__ = uf._0_4_;
    __return_storage_ptr__->stream = piVar5;
    __return_storage_ptr__->ext = uf.ext;
    __return_storage_ptr__->compression = uf.compression;
    __return_storage_ptr__->content_encoding = uf.content_encoding;
    __return_storage_ptr__->guess_type = uf.guess_type;
    __return_storage_ptr__->url = uf.url;
    __return_storage_ptr__->modtime = uf.modtime;
    return __return_storage_ptr__;
  case 0xb:
    if (pu->file == (char *)0x0) {
      *(uint *)__return_storage_ptr__ = uf._0_4_;
      __return_storage_ptr__->stream = uf.stream;
      __return_storage_ptr__->ext = uf.ext;
      __return_storage_ptr__->compression = uf.compression;
      __return_storage_ptr__->content_encoding = uf.content_encoding;
      __return_storage_ptr__->guess_type = uf.guess_type;
      __return_storage_ptr__->url = uf.url;
      __return_storage_ptr__->modtime = uf.modtime;
      return __return_storage_ptr__;
    }
    p_Var1 = Strnew_charp(pu->file);
    p = p_Var1->ptr;
    pcVar2 = strchr(p,0x2c);
    if (pcVar2 == (char *)0x0) {
      *(uint *)__return_storage_ptr__ = uf._0_4_;
      __return_storage_ptr__->stream = uf.stream;
      __return_storage_ptr__->ext = uf.ext;
      __return_storage_ptr__->compression = uf.compression;
      __return_storage_ptr__->content_encoding = uf.content_encoding;
      __return_storage_ptr__->guess_type = uf.guess_type;
      __return_storage_ptr__->url = uf.url;
      __return_storage_ptr__->modtime = uf.modtime;
      return __return_storage_ptr__;
    }
    *pcVar2 = '\0';
    q = pcVar2 + 1;
    tmp = Strnew_charp(q);
    q = strrchr(p,0x3b);
    if ((q == (char *)0x0) || (iVar4 = strcmp(q,";base64"), iVar4 != 0)) {
      tmp = Str_url_unquote(tmp,0,0);
    }
    else {
      *q = '\0';
      uf._0_3_ = CONCAT12(1,uf._0_2_);
      uf._0_4_ = uf._0_4_ & 0xff000000 | (uint)uf._0_3_;
    }
    piVar5 = newStrStream(tmp);
    if (*p == '\0') {
      p = "text/plain";
    }
    *(uint *)__return_storage_ptr__ = uf._0_4_;
    __return_storage_ptr__->stream = piVar5;
    __return_storage_ptr__->ext = uf.ext;
    __return_storage_ptr__->compression = uf.compression;
    __return_storage_ptr__->content_encoding = uf.content_encoding;
    __return_storage_ptr__->guess_type = p;
    __return_storage_ptr__->url = uf.url;
    __return_storage_ptr__->modtime = uf.modtime;
    return __return_storage_ptr__;
  }
  piVar5 = newInputStream(sock);
  *(uint *)__return_storage_ptr__ = uf._0_4_;
  __return_storage_ptr__->stream = piVar5;
  __return_storage_ptr__->ext = uf.ext;
  __return_storage_ptr__->compression = uf.compression;
  __return_storage_ptr__->content_encoding = uf.content_encoding;
  __return_storage_ptr__->guess_type = uf.guess_type;
  __return_storage_ptr__->url = uf.url;
  __return_storage_ptr__->modtime = uf.modtime;
  return __return_storage_ptr__;
switchD_080a0f2d_caseD_4:
  if ((request == (FormList *)0x0) || (request->body == (char *)0x0)) {
    pFVar3 = localcgi_post(pu->real_file,pu->query,(FormList *)0x0,option->referer);
    uf.stream = newFileStream(pFVar3,fclose);
  }
  else {
    pFVar3 = localcgi_post(pu->real_file,pu->query,request,option->referer);
    uf.stream = newFileStream(pFVar3,fclose);
  }
  if (uf.stream != (InputStream)0x0) {
    uf._1_3_ = (uint3)(uf._0_4_ >> 8) & 0xffff00 | 1;
    pu->scheme = 5;
    uf._0_4_ = CONCAT31(uf._1_3_,5);
    *(uint *)__return_storage_ptr__ = uf._0_4_;
    __return_storage_ptr__->stream = uf.stream;
    __return_storage_ptr__->ext = uf.ext;
    __return_storage_ptr__->compression = uf.compression;
    __return_storage_ptr__->content_encoding = uf.content_encoding;
    __return_storage_ptr__->guess_type = uf.guess_type;
    __return_storage_ptr__->url = uf.url;
    __return_storage_ptr__->modtime = uf.modtime;
    return __return_storage_ptr__;
  }
  examineFile(pu->real_file,&uf);
  if (uf.stream == (InputStream)0x0) {
    iVar4 = dir_exist(pu->real_file);
    if (iVar4 == 0) {
      if (document_root != (char *)0x0) {
        tmp = Strnew_charp(document_root);
        if (((tmp->length < 1) || (tmp->ptr[tmp->length + -1] != '/')) && (*pu->file != '/')) {
          if (tmp->area_size <= tmp->length + 1) {
            Strgrow(tmp);
          }
          iVar4 = tmp->length;
          tmp->ptr[iVar4] = '/';
          tmp->length = iVar4 + 1;
          tmp->ptr[tmp->length] = '\0';
        }
        Strcat_charp(tmp,pu->file);
        p = cleanupName(tmp->ptr);
        pcVar2 = file_unquote(p);
        q = cleanupName(pcVar2);
        iVar4 = dir_exist(q);
        if (iVar4 == 0) {
          examineFile(q,&uf);
          if (uf.stream != (InputStream)0x0) {
            pu->file = p;
            pu->real_file = q;
          }
        }
        else {
          pu->file = p;
          pu->real_file = q;
          add_index_file(pu,&uf);
          if (uf.stream == (InputStream)0x0) {
            *(uint *)__return_storage_ptr__ = uf._0_4_;
            __return_storage_ptr__->stream = (InputStream)0x0;
            __return_storage_ptr__->ext = uf.ext;
            __return_storage_ptr__->compression = uf.compression;
            __return_storage_ptr__->content_encoding = uf.content_encoding;
            __return_storage_ptr__->guess_type = uf.guess_type;
            __return_storage_ptr__->url = uf.url;
            __return_storage_ptr__->modtime = uf.modtime;
            return __return_storage_ptr__;
          }
        }
      }
    }
    else {
      add_index_file(pu,&uf);
      if (uf.stream == (InputStream)0x0) {
        *(uint *)__return_storage_ptr__ = uf._0_4_;
        __return_storage_ptr__->stream = (InputStream)0x0;
        __return_storage_ptr__->ext = uf.ext;
        __return_storage_ptr__->compression = uf.compression;
        __return_storage_ptr__->content_encoding = uf.content_encoding;
        __return_storage_ptr__->guess_type = uf.guess_type;
        __return_storage_ptr__->url = uf.url;
        __return_storage_ptr__->modtime = uf.modtime;
        return __return_storage_ptr__;
      }
    }
  }
  if (((uf.stream != (InputStream)0x0) || (retryAsHttp == 0)) ||
     ((*url == '/' || ((scheme != 0xfe && (scheme != 0xff)))))) {
    *(uint *)__return_storage_ptr__ = uf._0_4_;
    __return_storage_ptr__->stream = uf.stream;
    __return_storage_ptr__->ext = uf.ext;
    __return_storage_ptr__->compression = uf.compression;
    __return_storage_ptr__->content_encoding = uf.content_encoding;
    __return_storage_ptr__->guess_type = uf.guess_type;
    __return_storage_ptr__->url = uf.url;
    __return_storage_ptr__->modtime = uf.modtime;
    return __return_storage_ptr__;
  }
  p_Var1 = Strnew_m_charp("http://",url,0);
  u = p_Var1->ptr;
  goto retry;
}



void add_index_file(ParsedURL *pu,URLFile *uf)

{
  char *pcVar1;
  Str p_Var2;
  char *pcVar3;
  char *q;
  char *p;
  
  if ((index_file == (char *)0x0) || (*index_file == '\0')) {
    uf->stream = (InputStream)0x0;
  }
  else {
    pcVar1 = file_quote(index_file);
    p_Var2 = Strnew_m_charp(pu->file,&DAT_080cf095,pcVar1,0);
    pcVar1 = cleanupName(p_Var2->ptr);
    pcVar3 = file_unquote(pcVar1);
    pcVar3 = cleanupName(pcVar3);
    examineFile(pcVar3,uf);
    if (uf->stream != (InputStream)0x0) {
      pu->file = pcVar1;
      pu->real_file = pcVar3;
    }
  }
  return;
}



char * guessContentTypeFromTable(table2 *table,char *filename)

{
  size_t sVar1;
  int iVar2;
  char *p;
  table2 *t;
  
  if (table != (table2 *)0x0) {
    sVar1 = strlen(filename);
    for (p = filename + (sVar1 - 1); (filename < p && (*p != '.')); p = p + -1) {
    }
    if (p != filename) {
      for (t = table; t->item1 != (char *)0x0; t = t + 1) {
        iVar2 = strcmp(p + 1,t->item1);
        if (iVar2 == 0) {
          return t->item2;
        }
      }
      for (t = table; t->item1 != (char *)0x0; t = t + 1) {
        iVar2 = strcasecmp(p + 1,t->item1);
        if (iVar2 == 0) {
          return t->item2;
        }
      }
    }
  }
  return (char *)0x0;
}



char * guessContentType(char *filename)

{
  char *pcVar1;
  int i;
  char *ret;
  
  if (filename == (char *)0x0) {
    pcVar1 = (char *)0x0;
  }
  else {
    if (mimetypes_list != (TextList *)0x0) {
      for (i = 0; i < mimetypes_list->nitem; i = i + 1) {
        pcVar1 = guessContentTypeFromTable(UserMimeTypes[i],filename);
        if (pcVar1 != (char *)0x0) {
          return pcVar1;
        }
      }
    }
    pcVar1 = guessContentTypeFromTable(DefaultGuess,filename);
  }
  return pcVar1;
}



TextList * make_domain_list(char *domain_list)

{
  int iVar1;
  Str s;
  char *s_00;
  TextList *domains;
  Str tmp;
  char *p;
  
  domains = (TextList *)0x0;
  p = domain_list;
  s = Strnew_size(0x40);
  while (*p != '\0') {
    while ((*p != '\0' && ((MYCTYPE_MAP[(byte)*p] & 2) != 0))) {
      p = p + 1;
    }
    Strclear(s);
    while (((*p != '\0' && ((MYCTYPE_MAP[(byte)*p] & 2) == 0)) && (*p != ','))) {
      if (s->area_size <= s->length + 1) {
        Strgrow(s);
      }
      iVar1 = s->length;
      s->ptr[iVar1] = *p;
      s->length = iVar1 + 1;
      p = p + 1;
      s->ptr[s->length] = '\0';
    }
    if (0 < s->length) {
      if (domains == (TextList *)0x0) {
        domains = (TextList *)newGeneralList();
      }
      s_00 = allocStr(s->ptr,-1);
      pushValue((GeneralList *)domains,s_00);
    }
    while ((*p != '\0' && ((MYCTYPE_MAP[(byte)*p] & 2) != 0))) {
      p = p + 1;
    }
    if (*p == ',') {
      p = p + 1;
    }
  }
  return domains;
}



int domain_match(char *pat,char *domain)

{
  int iVar1;
  char *pcVar2;
  
  if (domain == (char *)0x0) {
    iVar1 = 0;
  }
  else {
    if (*pat == '.') {
      pat = pat + 1;
    }
    while (iVar1 = strcasecmp(pat,domain), iVar1 != 0) {
      pcVar2 = strchr(domain,0x2e);
      if (pcVar2 == (char *)0x0) {
        return 0;
      }
      domain = pcVar2 + 1;
    }
    iVar1 = 1;
  }
  return iVar1;
}



int check_no_proxy(char *domain)

{
  int iVar1;
  int iVar2;
  size_t __n;
  int in_GS_OFFSET;
  addrinfo hints;
  int *af;
  addrinfo *res0;
  addrinfo *res;
  int error;
  anon_subr_void_int *prevtrap;
  int ret;
  TextListItem *tl;
  char addr [64];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  ret = 0;
  prevtrap = (anon_subr_void_int *)0x0;
  if (((NO_proxy_domains == (TextList *)0x0) || (NO_proxy_domains->nitem == 0)) ||
     (domain == (char *)0x0)) {
    iVar2 = 0;
  }
  else {
    for (tl = NO_proxy_domains->first; tl != (TextListItem *)0x0; tl = tl->next) {
      iVar2 = domain_match(tl->ptr,domain);
      if (iVar2 != 0) {
        iVar2 = 1;
        goto LAB_080a215d;
      }
    }
    if (NOproxy_netaddr == 0) {
      iVar2 = 0;
    }
    else {
      iVar2 = __sigsetjmp(AbortLoading,1);
      if (iVar2 == 0) {
        if ((TrapSignal != '\0') && (prevtrap = mySignal(2,KeyAbort), fmInitialized != '\0')) {
          term_cbreak();
        }
        af = (int *)ai_family_order_table[DNS_order];
        do {
          memset(&hints,0,0x20);
          hints.ai_family = *af;
          error = getaddrinfo(domain,(char *)0x0,(addrinfo *)&hints,(addrinfo **)&res0);
          if (error == 0) {
            for (res = res0; res != (addrinfo *)0x0; res = res->ai_next) {
              if (res->ai_family == 2) {
                inet_ntop(2,res->ai_addr->sa_data + 2,addr,0x40);
LAB_080a2099:
                for (tl = NO_proxy_domains->first; tl != (TextListItem *)0x0; tl = tl->next) {
                  __n = strlen(tl->ptr);
                  iVar2 = strncmp(tl->ptr,addr,__n);
                  if (iVar2 == 0) {
                    freeaddrinfo((addrinfo *)res0);
                    ret = 1;
                    goto end;
                  }
                }
              }
              else if (res->ai_family == 10) {
                inet_ntop(10,res->ai_addr->sa_data + 6,addr,0x40);
                goto LAB_080a2099;
              }
            }
            freeaddrinfo((addrinfo *)res0);
            iVar2 = *af;
          }
          else {
            iVar2 = *af;
          }
          if (iVar2 == 0) goto end;
          af = af + 1;
        } while( true );
      }
      ret = 0;
end:
      iVar2 = ret;
      if (TrapSignal != '\0') {
        if (fmInitialized != '\0') {
          term_raw();
        }
        iVar2 = ret;
        if (prevtrap != (anon_subr_void_int *)0x0) {
          mySignal(2,prevtrap);
          iVar2 = ret;
        }
      }
    }
  }
LAB_080a215d:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar2;
}



char * filename_extension(char *path,int is_url)

{
  int i;
  char *p;
  char *last_dot;
  
  last_dot = "";
  p = path;
  if (path == (char *)0x0) {
    last_dot = "";
  }
  else {
    if (*path == '.') {
      p = path + 1;
    }
    for (; *p != '\0'; p = p + 1) {
      if (*p == '.') {
        last_dot = p;
      }
      else if ((is_url != 0) && (*p == '?')) break;
    }
    if (*last_dot == '.') {
      i = 1;
      while (((last_dot[i] != '\0' && (i < 8)) &&
             ((is_url == 0 || ((MYCTYPE_MAP[(byte)last_dot[i]] & 0xc) != 0))))) {
        i = i + 1;
      }
      last_dot = allocStr(last_dot,i);
    }
  }
  return last_dot;
}



table2 * loadURIMethods(char *filename)

{
  char *pcVar1;
  FILE *__stream;
  table2 *ptVar2;
  Str p_Var3;
  uint uVar4;
  char *p;
  char *up;
  table2 *um;
  Str tmp;
  int n;
  int i;
  FILE *f;
  
  pcVar1 = expandPath(filename);
  __stream = fopen(pcVar1,"r");
  if (__stream == (FILE *)0x0) {
    ptVar2 = (table2 *)0x0;
  }
  else {
    i = 0;
    while (p_Var3 = Strfgets((FILE *)__stream), 0 < p_Var3->length) {
      if (*p_Var3->ptr != '#') {
        i = i + 1;
      }
    }
    fseek(__stream,0,0);
    ptVar2 = (table2 *)GC_malloc((i + 1) * 8);
    i = 0;
    while (p_Var3 = Strfgets((FILE *)__stream), 0 < p_Var3->length) {
      if (*p_Var3->ptr != '#') {
        while( true ) {
          if (p_Var3->length < 1) {
            uVar4 = 0;
          }
          else {
            uVar4 = (uint)(byte)p_Var3->ptr[p_Var3->length + -1];
          }
          if ((MYCTYPE_MAP[uVar4] & 2) == 0) break;
          Strshrink(p_Var3,1);
        }
        pcVar1 = p_Var3->ptr;
        for (p = pcVar1; *p != '\0'; p = p + 1) {
          if (*p == ':') {
            p_Var3 = Strnew_charp_n(pcVar1,(int)p - (int)pcVar1);
            ptVar2[i].item1 = p_Var3->ptr;
            p = p + 1;
            break;
          }
        }
        if (*p != '\0') {
          while ((*p != '\0' && ((MYCTYPE_MAP[(byte)*p] & 2) != 0))) {
            p = p + 1;
          }
          p_Var3 = Strnew_charp(p);
          ptVar2[i].item2 = p_Var3->ptr;
          i = i + 1;
        }
      }
    }
    ptVar2[i].item1 = (char *)0x0;
    ptVar2[i].item2 = (char *)0x0;
    fclose(__stream);
  }
  return ptVar2;
}



void initURIMethods(void)

{
  table2 **pptVar1;
  int iVar2;
  table2 *ptVar3;
  int i;
  TextListItem *tl;
  TextList *methodmap_list;
  
  methodmap_list = (TextList *)0x0;
  iVar2 = non_null(urimethodmap_files);
  if (iVar2 != 0) {
    methodmap_list = make_domain_list(urimethodmap_files);
  }
  if (methodmap_list != (TextList *)0x0) {
    urimethods = (table2 **)GC_malloc((methodmap_list->nitem + 1) * 4);
    i = 0;
    for (tl = methodmap_list->first; tl != (TextListItem *)0x0; tl = tl->next) {
      pptVar1 = urimethods + i;
      ptVar3 = loadURIMethods(tl->ptr);
      *pptVar1 = ptVar3;
      if (urimethods[i] != (table2 *)0x0) {
        i = i + 1;
      }
    }
    urimethods[i] = (table2 *)0x0;
  }
  return;
}



Str searchURIMethods(ParsedURL *pu)

{
  Str p_Var1;
  int iVar2;
  char *pcVar3;
  char *p;
  Str url;
  Str scheme;
  int i;
  table2 *ump;
  
  scheme = (Str)0x0;
  if ((pu->scheme == 0xff) && (urimethods != (table2 **)0x0)) {
    p_Var1 = parsedURL2Str(pu);
    for (p = p_Var1->ptr; *p != '\0'; p = p + 1) {
      if (*p == ':') {
        scheme = Strnew_charp_n(p_Var1->ptr,(int)p - (int)p_Var1->ptr);
        break;
      }
    }
    if (scheme != (Str)0x0) {
      for (i = 0; ump = urimethods[i], ump != (table2 *)0x0; i = i + 1) {
        for (; ump->item1 != (char *)0x0; ump = ump + 1) {
          iVar2 = strcasecmp(ump->item1,scheme->ptr);
          if (iVar2 == 0) {
            pcVar3 = url_quote(p_Var1->ptr);
            p_Var1 = Sprintf(ump->item2,pcVar3);
            return p_Var1;
          }
        }
      }
      for (ump = default_urimethods; ump->item1 != (char *)0x0; ump = ump + 1) {
        iVar2 = strcasecmp(ump->item1,scheme->ptr);
        if (iVar2 == 0) {
          pcVar3 = url_quote(p_Var1->ptr);
          p_Var1 = Sprintf(ump->item2,pcVar3);
          return p_Var1;
        }
      }
    }
  }
  return (Str)0x0;
}



void chkExternalURIBuffer(Buffer *buf)

{
  Str p_Var1;
  table2 *ump;
  int i;
  
  for (i = 0; ump = urimethods[i], ump != (table2 *)0x0; i = i + 1) {
    for (; ump->item1 != (char *)0x0; ump = ump + 1) {
      p_Var1 = Sprintf("%s:%s",ump->item1,
                       "([-;/?:@&=+$,a-zA-Z0-9_.!~*\'()]|%[0-9A-Fa-f][0-9A-Fa-f])*");
      reAnchor(buf,p_Var1->ptr);
    }
  }
  for (ump = default_urimethods; ump->item1 != (char *)0x0; ump = ump + 1) {
    p_Var1 = Sprintf("%s:%s",ump->item1,"([-;/?:@&=+$,a-zA-Z0-9_.!~*\'()]|%[0-9A-Fa-f][0-9A-Fa-f])*"
                    );
    reAnchor(buf,p_Var1->ptr);
  }
  return;
}



ParsedURL * schemeToProxy(int scheme)

{
  ParsedURL *pu;
  
  pu = (ParsedURL *)0x0;
  if (scheme == 1) {
    pu = &GOPHER_proxy_parsed;
  }
  else if (scheme == 2) {
    pu = &FTP_proxy_parsed;
  }
  else if (scheme == 0) {
    pu = &HTTP_proxy_parsed;
  }
  return pu;
}



void KeyAbort(int _dummy)

{
                    // WARNING: Subroutine does not return
  siglongjmp((__jmp_buf_tag *)AbortLoading,1);
}



Str ftp_command(FTP ftp,char *cmd,char *arg,int *status)

{
  Str p_Var1;
  Str tmp;
  
  if (ftp->host == (char *)0x0) {
    p_Var1 = (Str)0x0;
  }
  else {
    if (cmd != (char *)0x0) {
      if (arg == (char *)0x0) {
        tmp = Sprintf("%s\r\n",cmd);
      }
      else {
        tmp = Sprintf("%s %s\r\n",cmd,arg);
      }
      fwrite(tmp->ptr,1,tmp->length,(FILE *)ftp->wf);
      fflush((FILE *)ftp->wf);
    }
    if (status == (int *)0x0) {
      p_Var1 = (Str)0x0;
    }
    else {
      *status = -1;
      p_Var1 = StrISgets(ftp->rf);
      if (((((MYCTYPE_MAP[(byte)*p_Var1->ptr] & 8) != 0) &&
           ((MYCTYPE_MAP[(byte)p_Var1->ptr[1]] & 8) != 0)) &&
          ((MYCTYPE_MAP[(byte)p_Var1->ptr[2]] & 8) != 0)) && (p_Var1->ptr[3] == ' ')) {
        __isoc99_sscanf(p_Var1->ptr,&DAT_080cf34d,status);
      }
      if (p_Var1->ptr[3] == '-') {
        do {
          do {
            p_Var1 = StrISgets(ftp->rf);
          } while ((MYCTYPE_MAP[(byte)*p_Var1->ptr] & 8) == 0);
        } while ((((MYCTYPE_MAP[(byte)p_Var1->ptr[1]] & 8) == 0) ||
                 ((MYCTYPE_MAP[(byte)p_Var1->ptr[2]] & 8) == 0)) || (p_Var1->ptr[3] != ' '));
        __isoc99_sscanf(p_Var1->ptr,&DAT_080cf34d,status);
      }
    }
  }
  return p_Var1;
}



void ftp_close(FTP ftp)

{
  if (ftp->host != (char *)0x0) {
    if (ftp->rf != (InputStream)0x0) {
      ftp->rf->field_0x14 = ftp->rf->field_0x14 & 0xef;
      ISclose(ftp->rf);
      ftp->rf = (InputStream)0x0;
    }
    if (ftp->wf != (FILE *)0x0) {
      fclose((FILE *)ftp->wf);
      ftp->wf = (FILE *)0x0;
    }
    if (ftp->data != (FILE *)0x0) {
      fclose((FILE *)ftp->data);
      ftp->data = (FILE *)0x0;
    }
    ftp->host = (char *)0x0;
  }
  return;
}



int ftp_login(FTP ftp)

{
  int iVar1;
  int iVar2;
  Str p_Var3;
  hostent *phVar4;
  char *pcVar5;
  InputStream piVar6;
  FILE *pFVar7;
  int in_GS_OFFSET;
  Str tmp;
  hostent *sockent;
  int socknamelen;
  size_t n;
  int status;
  int sock;
  sockaddr_in sockname;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  sock = openSocket(ftp->host,"ftp",0x15);
  if (-1 < sock) {
    if ((((ftppass_hostnamegen != 0) && (iVar2 = strcmp(ftp->user,"anonymous"), iVar2 == 0)) &&
        (n = strlen(ftp->pass), n != 0)) && (ftp->pass[n - 1] == '@')) {
      socknamelen = 0x10;
      iVar2 = getsockname(sock,(sockaddr *)&sockname,(socklen_t *)&socknamelen);
      if (iVar2 == 0) {
        p_Var3 = Strnew_charp(ftp->pass);
        phVar4 = gethostbyaddr(&sockname.sin_addr,4,(uint)sockname.sin_family);
        if (phVar4 == (hostent *)0x0) {
          pcVar5 = inet_ntoa((in_addr)sockname.sin_addr);
          Strcat_m_charp(p_Var3,&DAT_080cf360,pcVar5,&DAT_080cf35e,0);
        }
        else {
          Strcat_charp(p_Var3,phVar4->h_name);
        }
        ftp->pass = p_Var3->ptr;
      }
    }
    piVar6 = newInputStream(sock);
    ftp->rf = piVar6;
    iVar2 = dup(sock);
    pFVar7 = fdopen(iVar2,"wb");
    ftp->wf = (FILE *)pFVar7;
    if ((ftp->rf != (InputStream)0x0) && (ftp->wf != (FILE *)0x0)) {
      ftp->rf->field_0x14 = ftp->rf->field_0x14 | 0x10;
      ftp_command(ftp,(char *)0x0,(char *)0x0,&status);
      if (status == 0xdc) {
        if (fmInitialized != '\0') {
          p_Var3 = Sprintf("Sending FTP username (%s) to remote server.",ftp->user);
          message(p_Var3->ptr,0,0);
          refresh();
        }
        ftp_command(ftp,"USER",ftp->user,&status);
        if (status == 0xe6) {
succeed:
          iVar2 = 1;
          goto LAB_080a2cf0;
        }
        if (status == 0x14b) {
          if (fmInitialized != '\0') {
            message("Sending FTP password to remote server.",0,0);
            refresh();
          }
          ftp_command(ftp,"PASS",ftp->pass,&status);
          if (status == 0xe6) goto succeed;
        }
      }
    }
  }
  ftp_close(ftp);
  iVar2 = 0;
LAB_080a2cf0:
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return iVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Could not reconcile some variable overlaps

int ftp_pasv(FTP ftp)

{
  int iVar1;
  int iVar2;
  FILE *pFVar3;
  int in_GS_OFFSET;
  int port;
  int sockaddrlen;
  int family;
  Str tmp;
  char *p;
  int data;
  int p2;
  int p1;
  int n4;
  int n3;
  int n2;
  int n1;
  int status;
  uchar d4;
  uchar d3;
  uchar d2;
  uchar d1;
  sockaddr_storage sockaddr;
  char abuf [46];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  sockaddrlen = 0x80;
  iVar2 = fileno((FILE *)ftp->wf);
  iVar2 = getpeername(iVar2,(sockaddr *)&sockaddr,(socklen_t *)&sockaddrlen);
  if (iVar2 < 0) {
    iVar2 = -1;
    goto LAB_080a30d1;
  }
  family = (int)sockaddr.ss_family;
  if (family == 2) {
    tmp = ftp_command(ftp,"PASV",(char *)0x0,&status);
    if (status != 0xe3) {
      iVar2 = -1;
      goto LAB_080a30d1;
    }
    p = tmp->ptr + 4;
    while ((*p != '\0' && ((MYCTYPE_MAP[(byte)*p] & 8) == 0))) {
      p = p + 1;
    }
    if (*p == '\0') {
      iVar2 = -1;
      goto LAB_080a30d1;
    }
    __isoc99_sscanf(p,"%d,%d,%d,%d,%d,%d",&n1,&n2,&n3,&n4,&p1,&p2);
    tmp = Sprintf("%d.%d.%d.%d",n1,n2,n3,n4);
    data = openSocket(tmp->ptr,"",(short)p1 * 0x100 + (short)p2);
  }
  else {
    if (family != 10) {
      iVar2 = -1;
      goto LAB_080a30d1;
    }
    tmp = ftp_command(ftp,"EPSV",(char *)0x0,&status);
    if (status != 0xe5) {
      iVar2 = -1;
      goto LAB_080a30d1;
    }
    for (p = tmp->ptr + 4; (*p != '\0' && (*p != '(')); p = p + 1) {
    }
    if (*p == '\0') {
      iVar2 = -1;
      goto LAB_080a30d1;
    }
    p = p + 1;
    iVar2 = __isoc99_sscanf(p,"%c%c%c%d%c",&d1,&d2,&d3,&port,&d4);
    if ((((iVar2 != 5) || (d1 != d2)) || (d1 != d3)) || (d1 != d4)) {
      iVar2 = -1;
      goto LAB_080a30d1;
    }
    iVar2 = getnameinfo((sockaddr *)&sockaddr,sockaddrlen,abuf,0x2e,(char *)0x0,0,1);
    if (iVar2 != 0) {
      iVar2 = -1;
      goto LAB_080a30d1;
    }
    data = openSocket(abuf,"",(ushort)port);
  }
  if (data < 0) {
    iVar2 = -1;
  }
  else {
    pFVar3 = fdopen(data,"rb");
    ftp->data = (FILE *)pFVar3;
    iVar2 = 0;
  }
LAB_080a30d1:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar2;
}



time_t ftp_modtime(FTP ftp,char *path)

{
  int iVar1;
  tm *ptVar2;
  time_t tVar3;
  time_t tVar4;
  tm tm;
  time_t gt;
  time_t lt;
  time_t t;
  char *p;
  Str tmp;
  int status;
  
  tmp = ftp_command(ftp,"MDTM",path,&status);
  if (status == 0xd5) {
    for (p = tmp->ptr + 4; (*p != '\0' && (*p == ' ')); p = p + 1) {
    }
    memset(&tm,0,0x2c);
    iVar1 = __isoc99_sscanf(p,"%04d%02d%02d%02d%02d%02d",&tm.tm_year,&tm.tm_mon,&tm.tm_mday,
                            &tm.tm_hour,&tm.tm_min,&tm);
    if (iVar1 < 6) {
      iVar1 = -1;
    }
    else {
      tm.tm_year = tm.tm_year + -0x76c;
      tm.tm_mon = tm.tm_mon + -1;
      t = mktime((tm *)&tm);
      ptVar2 = localtime(&t);
      tVar3 = mktime(ptVar2);
      ptVar2 = gmtime(&t);
      tVar4 = mktime(ptVar2);
      iVar1 = (tVar3 - tVar4) + t;
    }
  }
  else {
    iVar1 = -1;
  }
  return iVar1;
}



int ftp_quit(FTP ftp)

{
  ftp_command(ftp,"QUIT",(char *)0x0,(int *)0x0);
  ftp_close(ftp);
  return 0;
}



void closeFTPdata(FILE *f)

{
  int status;
  
  if (f != (FILE *)0x0) {
    fclose((FILE *)f);
    if (current_ftp.data == f) {
      current_ftp.data = (FILE *)0x0;
    }
  }
  ftp_command(&current_ftp,(char *)0x0,(char *)0x0,&status);
  return;
}



void closeFTP(void)

{
  ftp_close(&current_ftp);
  return;
}



InputStream openFTPStream(ParsedURL *pu,URLFile *uf)

{
  bool bVar1;
  int iVar2;
  char *pcVar3;
  __uid_t __uid;
  passwd *ppVar4;
  size_t sVar5;
  time_t tVar6;
  InputStream piVar7;
  passwd *mypw;
  char *realpathname;
  int add_auth_cookie_flag;
  Str pwd;
  Str uname;
  char *pass;
  char *user;
  int status;
  Str tmp;
  
  user = (char *)0x0;
  pass = (char *)0x0;
  uname = (Str)0x0;
  pwd = (Str)0x0;
  bVar1 = false;
  if (pu->host == (char *)0x0) {
    return (InputStream)0x0;
  }
  if (((pu->user == (char *)0x0) && (pu->pass == (char *)0x0)) &&
     (iVar2 = find_auth_user_passwd(pu,(char *)0x0,&uname,&pwd,0), iVar2 != 0)) {
    if (uname != (Str)0x0) {
      user = uname->ptr;
    }
    if (pwd != (Str)0x0) {
      pass = pwd->ptr;
    }
  }
  if (user == (char *)0x0) {
    if (pu->user == (char *)0x0) {
      user = "anonymous";
    }
    else {
      user = pu->user;
    }
  }
  if (current_ftp.host != (char *)0x0) {
    iVar2 = strcmp(current_ftp.host,pu->host);
    if (((iVar2 == 0) && (current_ftp.port == pu->port)) &&
       (iVar2 = strcmp(current_ftp.user,user), iVar2 == 0)) {
      ftp_command(&current_ftp,"NOOP",(char *)0x0,&status);
      if (status == 200) goto ftp_read;
      ftp_close(&current_ftp);
    }
    else {
      ftp_quit(&current_ftp);
    }
  }
  if (pass == (char *)0x0) {
    if (pu->pass == (char *)0x0) {
      if (pu->user == (char *)0x0) {
        if ((ftppasswd == (char *)0x0) || (*ftppasswd == '\0')) {
          __uid = getuid();
          ppVar4 = getpwuid(__uid);
          if (ppVar4 == (passwd *)0x0) {
            pcVar3 = "anonymous";
          }
          else {
            pcVar3 = ppVar4->pw_name;
          }
          tmp = Strnew_charp(pcVar3);
          if (tmp->area_size <= tmp->length + 1) {
            Strgrow(tmp);
          }
          iVar2 = tmp->length;
          tmp->ptr[iVar2] = '@';
          tmp->length = iVar2 + 1;
          tmp->ptr[tmp->length] = '\0';
          pass = tmp->ptr;
        }
        else {
          pass = ftppasswd;
        }
      }
      else {
        pwd = (Str)0x0;
        find_auth_user_passwd(pu,(char *)0x0,&uname,&pwd,0);
        if (pwd == (Str)0x0) {
          if (fmInitialized == '\0') {
            pcVar3 = getpass("Password: ");
            pwd = Strnew_charp(pcVar3);
          }
          else {
            term_raw();
            pcVar3 = inputLineHistSearch("Password: ",(char *)0x0,0x40,(Hist *)0x0,
                                         (anon_subr_int_int_Str_Lineprop_ptr *)0x0);
            pwd = Strnew_charp(pcVar3);
            pwd = wc_Str_conv_strict(pwd,InnerCharset,SystemCharset);
            term_cbreak();
          }
          bVar1 = true;
        }
        pass = pwd->ptr;
      }
    }
    else {
      pass = pu->pass;
    }
  }
  if (current_ftp.host == (char *)0x0) {
    current_ftp.host = allocStr(pu->host,-1);
    current_ftp.port = pu->port;
    current_ftp.user = allocStr(user,-1);
    current_ftp.pass = allocStr(pass,-1);
    iVar2 = ftp_login(&current_ftp);
    if (iVar2 == 0) {
      return (InputStream)0x0;
    }
  }
  if (bVar1) {
    add_auth_user_passwd(pu,(char *)0x0,uname,pwd,0);
  }
ftp_read:
  ftp_command(&current_ftp,"TYPE","I",&status);
  iVar2 = ftp_pasv(&current_ftp);
  if (iVar2 < 0) {
    ftp_quit(&current_ftp);
  }
  else {
    if (((pu->file != (char *)0x0) && (*pu->file != '\0')) &&
       (pcVar3 = pu->file, sVar5 = strlen(pu->file), pcVar3[sVar5 - 1] != '/')) {
      realpathname = file_unquote(pu->file);
      if ((*realpathname == '/') && (realpathname[1] == '~')) {
        realpathname = realpathname + 1;
      }
      tVar6 = ftp_modtime(&current_ftp,realpathname);
      uf->modtime = tVar6;
      ftp_command(&current_ftp,"RETR",realpathname,&status);
      if ((status == 0x7d) || (status == 0x96)) {
        piVar7 = newFileStream(current_ftp.data,closeFTPdata);
        return piVar7;
      }
    }
    pu->scheme = 3;
  }
  return (InputStream)0x0;
}



Str loadFTPDir(ParsedURL *pu,wc_ces *charset)

{
  char cVar1;
  char *pcVar2;
  int iVar3;
  Str p_Var4;
  int iVar5;
  char *pcVar6;
  char **ppcVar7;
  int j;
  int len;
  int max_len;
  int ftype;
  char *type_str;
  char *size;
  char *date;
  char *link;
  char *name;
  wc_ces doc_charset;
  anon_subr_void_int *prevtrap;
  int nfile_max;
  int nfile;
  int i;
  char **flist;
  char *q;
  char *fn;
  char *realpathname;
  int sv_type;
  int status;
  Str tmp;
  Str FTPDIRtmp;
  
  prevtrap = (anon_subr_void_int *)0x0;
  doc_charset = DocumentCharset;
  *charset = 0x100;
  if (current_ftp.data == (FILE *)0x0) {
    FTPDIRtmp = (Str)0x0;
  }
  else {
    tmp = ftp_command(&current_ftp,"SYST",(char *)0x0,&status);
    pcVar2 = strstr(tmp->ptr,"UNIX");
    if ((pcVar2 == (char *)0x0) && (iVar3 = strncmp(tmp->ptr + 4,"Windows_NT",10), iVar3 != 0)) {
      sv_type = 0;
    }
    else {
      sv_type = 1;
    }
    if ((pu->file == (char *)0x0) || (*pu->file == '\0')) {
      if (sv_type == 1) {
        ftp_command(&current_ftp,"LIST",(char *)0x0,&status);
      }
      else {
        ftp_command(&current_ftp,"NLST",(char *)0x0,&status);
      }
      pu->file = "/";
    }
    else {
      realpathname = file_unquote(pu->file);
      if ((*realpathname == '/') && (realpathname[1] == '~')) {
        realpathname = realpathname + 1;
      }
      if (sv_type == 1) {
        ftp_command(&current_ftp,"CWD",realpathname,&status);
        if (status == 0xfa) {
          ftp_command(&current_ftp,"LIST",(char *)0x0,&status);
        }
      }
      else {
        ftp_command(&current_ftp,"NLST",realpathname,&status);
      }
    }
    if ((status == 0x7d) || (status == 0x96)) {
      tmp = parsedURL2Str(pu);
      if ((tmp->length < 1) || (tmp->ptr[tmp->length + -1] != '/')) {
        if (tmp->area_size <= tmp->length + 1) {
          Strgrow(tmp);
        }
        iVar3 = tmp->length;
        tmp->ptr[iVar3] = '/';
        tmp->length = iVar3 + 1;
        tmp->ptr[tmp->length] = '\0';
      }
      fn = html_quote(tmp->ptr);
      pcVar2 = file_unquote(tmp->ptr);
      p_Var4 = Strnew_charp(pcVar2);
      tmp = convertLine((URLFile *)0x0,p_Var4,0,charset,doc_charset);
      q = html_quote(tmp->ptr);
      FTPDIRtmp = Strnew_m_charp("<html>\n<head>\n<base href=\"",fn,"\">\n<title>",q,
                                 "</title>\n</head>\n<body>\n<h1>Index of ",q,"</h1>\n",0);
      iVar3 = __sigsetjmp(AbortLoading,1);
      if (iVar3 == 0) {
        if ((TrapSignal != '\0') && (prevtrap = mySignal(2,KeyAbort), fmInitialized != '\0')) {
          term_cbreak();
        }
        if (sv_type == 1) {
          Strcat_charp(FTPDIRtmp,"<pre>\n");
        }
        else {
          Strcat_charp(FTPDIRtmp,"<ul>\n<li>");
        }
        Strcat_charp(FTPDIRtmp,"<a href=\"..\">[Upper Directory]</a>\n");
        nfile_max = 100;
        flist = (char **)GC_malloc(400);
        nfile = 0;
        if (sv_type == 1) {
          max_len = 0x14;
          while (tmp = Strfgets(current_ftp.data), 0 < tmp->length) {
            Strchop(tmp);
            iVar3 = ex_ftpdir_name_size_date(tmp->ptr,&name,&link,&date,&size);
            if ((((iVar3 != 0) && (iVar5 = strcmp(".",name), iVar5 != 0)) &&
                (iVar5 = strcmp("..",name), iVar5 != 0)) && (len = strlen(name), len != 0)) {
              if (iVar3 == 1) {
                len = len + 1;
                type_str = "/";
              }
              else if (iVar3 == 2) {
                len = len + 1;
                type_str = "@";
              }
              else {
                type_str = " ";
              }
              if (max_len < len) {
                max_len = len;
              }
              ppcVar7 = flist + nfile;
              p_Var4 = Sprintf("%s%s\n%s  %5s%s",name,type_str,date,size,link);
              *ppcVar7 = p_Var4->ptr;
              nfile = nfile + 1;
              if (nfile == nfile_max) {
                iVar3 = nfile_max << 3;
                nfile_max = nfile_max << 1;
                flist = (char **)GC_realloc(flist,iVar3);
              }
            }
          }
          qsort(flist,nfile,4,strCmp);
          for (j = 0; j < nfile; j = j + 1) {
            fn = flist[j];
            pcVar2 = strchr(fn,10);
            if (pcVar2[-1] == '/') {
              ftype = 1;
              *pcVar2 = '\0';
            }
            else if (pcVar2[-1] == '@') {
              ftype = 2;
              pcVar2[-1] = '\0';
            }
            else {
              ftype = 3;
              pcVar2[-1] = '\0';
            }
            date = pcVar2 + 1;
            p_Var4 = Strnew_charp(fn);
            tmp = convertLine((URLFile *)0x0,p_Var4,0,charset,doc_charset);
            if (ftype == 2) {
              if (tmp->area_size <= tmp->length + 1) {
                Strgrow(tmp);
              }
              iVar3 = tmp->length;
              tmp->ptr[iVar3] = '@';
              tmp->length = iVar3 + 1;
              tmp->ptr[tmp->length] = '\0';
            }
            pcVar2 = html_quote(tmp->ptr);
            pcVar6 = file_quote(fn);
            pcVar6 = html_quote(pcVar6);
            Strcat_m_charp(FTPDIRtmp,"<a href=\"",pcVar6,&DAT_080cf53d,pcVar2,&DAT_080cf538,0);
            for (i = wtf_strwidth((wc_uchar *)tmp->ptr); i <= max_len; i = i + 1) {
              cVar1 = (char)(max_len >> 0x1f);
              if ((((char)max_len - cVar1 & 1U) + cVar1 + (char)i & 1) == 0) {
                if (FTPDIRtmp->area_size <= FTPDIRtmp->length + 1) {
                  Strgrow(FTPDIRtmp);
                }
                iVar3 = FTPDIRtmp->length;
                FTPDIRtmp->ptr[iVar3] = ' ';
                FTPDIRtmp->length = iVar3 + 1;
                FTPDIRtmp->ptr[FTPDIRtmp->length] = '\0';
              }
              else {
                if (FTPDIRtmp->area_size <= FTPDIRtmp->length + 1) {
                  Strgrow(FTPDIRtmp);
                }
                iVar3 = FTPDIRtmp->length;
                FTPDIRtmp->ptr[iVar3] = '.';
                FTPDIRtmp->length = iVar3 + 1;
                FTPDIRtmp->ptr[FTPDIRtmp->length] = '\0';
              }
            }
            p_Var4 = Strnew_charp(date);
            tmp = convertLine((URLFile *)0x0,p_Var4,0,charset,doc_charset);
            pcVar2 = html_quote(tmp->ptr);
            Strcat_m_charp(FTPDIRtmp,pcVar2,&DAT_080cf54a,0);
          }
          Strcat_charp(FTPDIRtmp,"</pre>\n");
        }
        else {
          while (tmp = Strfgets(current_ftp.data), 0 < tmp->length) {
            Strchop(tmp);
            ppcVar7 = flist + nfile;
            pcVar2 = mybasename(tmp->ptr);
            *ppcVar7 = pcVar2;
            nfile = nfile + 1;
            if (nfile == nfile_max) {
              iVar3 = nfile_max << 3;
              nfile_max = nfile_max << 1;
              flist = (char **)GC_realloc(flist,iVar3);
            }
          }
          qsort(flist,nfile,4,strCmp);
          for (i = 0; i < nfile; i = i + 1) {
            fn = flist[i];
            p_Var4 = Strnew_charp(fn);
            tmp = convertLine((URLFile *)0x0,p_Var4,0,charset,doc_charset);
            pcVar2 = html_quote(tmp->ptr);
            pcVar6 = file_quote(fn);
            pcVar6 = html_quote(pcVar6);
            Strcat_m_charp(FTPDIRtmp,"<li><a href=\"",pcVar6,&DAT_080cf53d,pcVar2,"</a>\n",0);
          }
          Strcat_charp(FTPDIRtmp,"</ul>\n");
        }
      }
      else {
        if (sv_type == 1) {
          Strcat_charp(FTPDIRtmp,"</a></pre>\n");
        }
        else {
          Strcat_charp(FTPDIRtmp,"</a></ul>\n");
        }
        Strcat_charp(FTPDIRtmp,"<p>Transfer Interrupted!\n");
      }
      Strcat_charp(FTPDIRtmp,"</body>\n</html>\n");
      if (TrapSignal != '\0') {
        if (fmInitialized != '\0') {
          term_raw();
        }
        if (prevtrap != (anon_subr_void_int *)0x0) {
          mySignal(2,prevtrap);
        }
      }
      closeFTPdata(current_ftp.data);
    }
    else {
      fclose((FILE *)current_ftp.data);
      current_ftp.data = (FILE *)0x0;
      FTPDIRtmp = (Str)0x0;
    }
  }
  return FTPDIRtmp;
}



void disconnectFTP(void)

{
  ftp_quit(&current_ftp);
  return;
}



// WARNING: Could not reconcile some variable overlaps

int ex_ftpdir_name_size_date(char *line,char **name,char **link,char **date,char **sizep)

{
  ulonglong uVar1;
  size_t sVar2;
  uint uVar3;
  uint uVar4;
  char *pcVar5;
  Str p_Var6;
  char *pcVar7;
  uint uVar8;
  clen_t size;
  char *p;
  char *cp;
  int ftype;
  
  ftype = 0;
  sVar2 = strlen(line);
  if ((10 < sVar2) && ((MYCTYPE_MAP[(byte)line[10]] & 2) != 0)) {
    for (cp = line + 0xb; ((MYCTYPE_MAP[(byte)*cp] & 2) != 0 && (*cp != '\0')); cp = cp + 1) {
    }
    if (*cp != '\0') {
      while ((*cp != '\0' && ((MYCTYPE_MAP[(byte)*cp] & 8) != 0))) {
        cp = cp + 1;
      }
      if (*cp != '\0') {
        do {
          cp = cp + 1;
          if ((MYCTYPE_MAP[(byte)*cp] & 2) == 0) break;
        } while (*cp != '\0');
        if (*cp != '\0') {
          for (; ((MYCTYPE_MAP[(byte)*cp] & 2) == 0 && (*cp != '\0')); cp = cp + 1) {
          }
          if (*cp != '\0') {
            do {
              cp = cp + 1;
              if ((MYCTYPE_MAP[(byte)*cp] & 2) == 0) break;
            } while (*cp != '\0');
            if (*cp != '\0') {
              for (; ((MYCTYPE_MAP[(byte)*cp] & 2) == 0 && (*cp != '\0')); cp = cp + 1) {
              }
              if (*cp != '\0') {
                do {
                  cp = cp + 1;
                  pcVar5 = cp;
                  if ((MYCTYPE_MAP[(byte)*cp] & 2) == 0) break;
                } while (*cp != '\0');
                if (*cp != '\0') {
                  size._0_4_ = 0;
                  size._4_4_ = 0;
                  while ((*cp != '\0' && ((MYCTYPE_MAP[(byte)*cp] & 8) != 0))) {
                    uVar1 = (ulonglong)(uint)size;
                    uVar3 = (uint)(uVar1 * 10);
                    uVar8 = (uint)*cp;
                    uVar4 = uVar3 + uVar8;
                    size._0_4_ = uVar4 - 0x30;
                    size._4_4_ = size._4_4_ * 10 + (int)(uVar1 * 10 >> 0x20) + ((int)uVar8 >> 0x1f)
                                 + (uint)CARRY4(uVar3,uVar8) + -1 + (uint)(0x2f < uVar4);
                    cp = cp + 1;
                  }
                  if (*cp != '\0') {
                    if (*cp == ',') {
                      do {
                        cp = cp + 1;
                        if ((MYCTYPE_MAP[(byte)*cp] & 2) == 0) break;
                      } while (*cp != '\0');
                      if (*cp == '\0') {
                        return 0;
                      }
                      for (; ((MYCTYPE_MAP[(byte)*cp] & 2) == 0 && (*cp != '\0')); cp = cp + 1) {
                      }
                      if (*cp == '\0') {
                        return 0;
                      }
                      pcVar5 = allocStr(pcVar5,(int)cp - (int)pcVar5);
                      *sizep = pcVar5;
                    }
                    else {
                      p_Var6 = size_int2str(CONCAT44(size._4_4_,(uint)size));
                      *sizep = p_Var6->ptr;
                    }
                    pcVar5 = cp + 1;
                    for (cp = pcVar5; ((MYCTYPE_MAP[(byte)*cp] & 2) != 0 && (*cp != '\0'));
                        cp = cp + 1) {
                    }
                    if (*cp != '\0') {
                      for (; ((MYCTYPE_MAP[(byte)*cp] & 2) == 0 && (*cp != '\0')); cp = cp + 1) {
                      }
                      if (*cp != '\0') {
                        for (; ((MYCTYPE_MAP[(byte)*cp] & 2) != 0 && (*cp != '\0')); cp = cp + 1) {
                        }
                        if (*cp != '\0') {
                          for (; ((MYCTYPE_MAP[(byte)*cp] & 2) == 0 && (*cp != '\0')); cp = cp + 1)
                          {
                          }
                          if (*cp != '\0') {
                            for (; ((MYCTYPE_MAP[(byte)*cp] & 2) != 0 && (*cp != '\0')); cp = cp + 1
                                ) {
                            }
                            if (*cp != '\0') {
                              for (; ((MYCTYPE_MAP[(byte)*cp] & 2) == 0 && (*cp != '\0'));
                                  cp = cp + 1) {
                              }
                              if (*cp != '\0') {
                                pcVar5 = allocStr(pcVar5,(int)cp - (int)pcVar5);
                                *date = pcVar5;
                                do {
                                  cp = cp + 1;
                                  if ((MYCTYPE_MAP[(byte)*cp] & 2) == 0) break;
                                } while (*cp != '\0');
                                if (*cp != '\0') {
                                  if (*line == 'd') {
                                    ftype = 1;
                                    pcVar5 = allocStr(cp,-1);
                                    *name = pcVar5;
                                    *link = "";
                                    *sizep = "";
                                  }
                                  else if (*line == 'l') {
                                    ftype = 2;
                                    pcVar5 = strstr(cp," -> ");
                                    if (pcVar5 != (char *)0x0) {
                                      pcVar7 = allocStr(cp,(int)pcVar5 - (int)cp);
                                      *name = pcVar7;
                                      pcVar5 = allocStr(pcVar5,-1);
                                      *link = pcVar5;
                                      *sizep = "";
                                    }
                                  }
                                  else {
                                    ftype = 3;
                                    pcVar5 = allocStr(cp,-1);
                                    *name = pcVar5;
                                    *link = "";
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return ftype;
}



Str size_int2str(clen_t size)

{
  Str p_Var1;
  double dtmp;
  char *unit_str;
  char *size_format;
  int unit;
  Str size_str;
  
  unit = 0;
  for (dtmp = (double)size; (unit < 3 && (1024.0 <= dtmp)); dtmp = dtmp / 1024.0) {
    unit = unit + 1;
  }
  if ((unit == 0) || (100.0 < dtmp)) {
    size_format = "%.0f%s";
  }
  else if (dtmp <= 10.0) {
    size_format = "%.2f%s";
  }
  else {
    size_format = "%.1f%s";
  }
  if (unit == 2) {
    unit_str = "M";
  }
  else if (unit == 3) {
    unit_str = "G";
  }
  else if (unit == 1) {
    unit_str = "K";
  }
  else {
    unit_str = "";
  }
  p_Var1 = Sprintf(size_format,dtmp,unit_str);
  return p_Var1;
}



uchar c2e(char x)

{
  uchar uVar1;
  
  if ((x < 'A') || ('Z' < x)) {
    if ((x < 'a') || ('z' < x)) {
      if ((x < '0') || ('9' < x)) {
        if (x == '+') {
          uVar1 = '>';
        }
        else if (x == '/') {
          uVar1 = '?';
        }
        else {
          uVar1 = 0xff;
        }
      }
      else {
        uVar1 = x + '\x04';
      }
    }
    else {
      uVar1 = x + 0xb9;
    }
  }
  else {
    uVar1 = x + 0xbf;
  }
  return uVar1;
}



int ha2d(char x,char y)

{
  int r;
  
  r = 0;
  if ((x < '0') || ('9' < x)) {
    if ((x < 'A') || ('F' < x)) {
      if (('`' < x) && (x < 'g')) {
        r = x + -0x57;
      }
    }
    else {
      r = x + -0x37;
    }
  }
  else {
    r = x + -0x30;
  }
  r = r * 0x10;
  if ((y < '0') || ('9' < y)) {
    if ((y < 'A') || ('F' < y)) {
      if (('`' < y) && (y < 'g')) {
        r = r + y + -0x57;
      }
    }
    else {
      r = r + y + -0x37;
    }
  }
  else {
    r = r + y + -0x30;
  }
  return r;
}



Str decodeB(char **ww)

{
  int iVar1;
  uchar uVar2;
  size_t n;
  Str x;
  Str ap;
  int n_pad;
  int i;
  char *wp;
  uchar c [4];
  char d [3];
  
  wp = *ww;
  n = strlen(wp);
  x = Strnew_size(n);
  n_pad = 0;
LAB_080a4a11:
  for (i = 0; i < 4; i = i + 1) {
    c[i] = *wp;
    wp = wp + 1;
    iVar1 = i;
    if ((*wp == '\0') || (*wp == '?')) goto LAB_080a4a51;
  }
  goto LAB_080a4a63;
LAB_080a4a51:
  while (i = iVar1 + 1, i < 4) {
    c[iVar1 + 1] = '=';
    iVar1 = i;
  }
LAB_080a4a63:
  iVar1 = n_pad;
  if (c[3] == '=') {
    c[3] = 'A';
    iVar1 = n_pad + 1;
    if (c[2] == '=') {
      c[2] = 'A';
      iVar1 = n_pad + 2;
    }
  }
  n_pad = iVar1;
  for (i = 0; i < 4; i = i + 1) {
    uVar2 = c2e(c[i]);
    c[i] = uVar2;
    if (c[i] == 0xff) {
      *ww = wp;
      return x;
    }
  }
  d[0] = c[1] >> 4 | c[0] << 2;
  d[1] = c[2] >> 2 | c[1] << 4;
  d[2] = c[3] | c[2] << 6;
  for (i = 0; i < 3 - n_pad; i = i + 1) {
    if (x->area_size <= x->length + 1) {
      Strgrow(x);
    }
    iVar1 = x->length;
    x->ptr[iVar1] = d[i];
    x->length = iVar1 + 1;
    x->ptr[x->length] = '\0';
  }
  if (((n_pad != 0) || (*wp == '\0')) || (*wp == '?')) {
    *ww = wp;
    return x;
  }
  goto LAB_080a4a11;
}



Str decodeU(char **ww)

{
  char cVar1;
  char cVar2;
  char *pcVar3;
  int iVar4;
  byte bVar5;
  byte bVar6;
  Str x;
  Str a;
  int i;
  int n;
  char *w;
  uchar c2;
  uchar c1;
  
  pcVar3 = *ww;
  if ((*pcVar3 < '!') || ('_' < *pcVar3)) {
    x = Strnew_size(0);
  }
  else {
    n = *pcVar3 + -0x20;
    x = Strnew_size(n);
    w = pcVar3 + 1;
    i = 2;
    for (; (*w != '\0' && (n != 0)); n = n + -1) {
      cVar1 = *w;
      bVar5 = (byte)(cVar1 + -0x20 >> 0x37);
      cVar2 = w[1];
      bVar6 = (byte)(cVar2 + -0x20 >> 0x37);
      if (x->area_size <= x->length + 1) {
        Strgrow(x);
      }
      iVar4 = x->length;
      x->ptr[iVar4] =
           (byte)((int)(uint)(byte)(((char)(cVar2 + -0x20) + (bVar6 >> 2) & 0x3f) - (bVar6 >> 2)) >>
                 (6 - (byte)i & 0x1f)) |
           ((char)(cVar1 + -0x20) + (bVar5 >> 2) & 0x3f) - (bVar5 >> 2) << ((byte)i & 0x1f);
      x->length = iVar4 + 1;
      x->ptr[x->length] = '\0';
      if (i == 6) {
        w = w + 2;
        i = 2;
      }
      else {
        w = w + 1;
        i = i + 2;
      }
    }
  }
  return x;
}



Str decodeQ(char **ww)

{
  char *pcVar1;
  int iVar2;
  size_t n;
  Str x;
  int iVar3;
  Str a;
  char *w;
  
  w = *ww;
  n = strlen(w);
  x = Strnew_size(n);
  for (; (*w != '\0' && (*w != '?')); w = w + 1) {
    if (*w == '=') {
      if (x->area_size <= x->length + 1) {
        Strgrow(x);
      }
      pcVar1 = x->ptr;
      iVar2 = x->length;
      iVar3 = ha2d(w[1],w[2]);
      pcVar1[iVar2] = (char)iVar3;
      x->length = iVar2 + 1;
      x->ptr[x->length] = '\0';
      w = w + 2;
    }
    else if (*w == '_') {
      if (x->area_size <= x->length + 1) {
        Strgrow(x);
      }
      iVar2 = x->length;
      x->ptr[iVar2] = ' ';
      x->length = iVar2 + 1;
      x->ptr[x->length] = '\0';
    }
    else {
      if (x->area_size <= x->length + 1) {
        Strgrow(x);
      }
      iVar2 = x->length;
      x->ptr[iVar2] = *w;
      x->length = iVar2 + 1;
      x->ptr[x->length] = '\0';
    }
  }
  *ww = w;
  return x;
}



Str decodeQP(char **ww)

{
  char *pcVar1;
  int iVar2;
  char *pcVar3;
  size_t n;
  Str x;
  int iVar4;
  Str a;
  char *w;
  
  w = *ww;
  n = strlen(w);
  x = Strnew_size(n);
  for (; pcVar3 = w, *w != '\0'; w = w + 1) {
    if (*w == '=') {
      pcVar3 = w + 1;
      if ((((*pcVar3 == '\n') || (*pcVar3 == '\r')) || (*pcVar3 == ' ')) || (*pcVar3 == '\t')) {
        while ((w = pcVar3, *w != '\n' && (*w != '\0'))) {
          pcVar3 = w + 1;
        }
        pcVar3 = w;
        if (*w == '\0') break;
      }
      else {
        if ((*pcVar3 == '\0') || (w[2] == '\0')) break;
        if (x->area_size <= x->length + 1) {
          Strgrow(x);
        }
        pcVar1 = x->ptr;
        iVar2 = x->length;
        iVar4 = ha2d(*pcVar3,w[2]);
        pcVar1[iVar2] = (char)iVar4;
        x->length = iVar2 + 1;
        x->ptr[x->length] = '\0';
        w = w + 2;
      }
    }
    else {
      if (x->area_size <= x->length + 1) {
        Strgrow(x);
      }
      iVar2 = x->length;
      x->ptr[iVar2] = *w;
      x->length = iVar2 + 1;
      x->ptr[x->length] = '\0';
    }
  }
  w = pcVar3;
  *ww = w;
  return x;
}



Str decodeWord(char **ow,wc_ces *charset)

{
  int iVar1;
  byte bVar2;
  char *pcVar3;
  Str p_Var4;
  Str tmp;
  Str a;
  char *w;
  char *p;
  wc_ces c;
  char method;
  
  w = *ow;
  Strnew();
  p_Var4 = Strnew();
  pcVar3 = w;
  if ((*w == '=') && (w[1] == '?')) {
    for (w = w + 2; *w != '?'; w = w + 1) {
      pcVar3 = w;
      if (*w == '\0') goto convert_fail;
      if (p_Var4->area_size <= p_Var4->length + 1) {
        Strgrow(p_Var4);
      }
      iVar1 = p_Var4->length;
      p_Var4->ptr[iVar1] = *w;
      p_Var4->length = iVar1 + 1;
      p_Var4->ptr[p_Var4->length] = '\0';
    }
    c = wc_guess_charset(p_Var4->ptr,0);
    pcVar3 = w;
    if (c != 0) {
      method = w[1];
      pcVar3 = w + 2;
      if (w[2] == '?') {
        w = w + 3;
        bVar2 = method;
        if ((MYCTYPE_MAP[(byte)method] & 4) != 0) {
          bVar2 = method & 0xdf;
        }
        p = w;
        if (bVar2 == 0x42) {
          a = decodeB(&w);
        }
        else {
          pcVar3 = w;
          if (bVar2 != 0x51) goto convert_fail;
          a = decodeQ(&w);
        }
        pcVar3 = w;
        if (p != w) {
          if ((*w == '?') && (pcVar3 = w + 1, w[1] == '=')) {
            pcVar3 = w + 2;
          }
          w = pcVar3;
          *ow = w;
          *charset = c;
          return a;
        }
      }
    }
  }
convert_fail:
  w = pcVar3;
  p_Var4 = Strnew();
  return p_Var4;
}



Str decodeMIME(Str orgstr,wc_ces *charset)

{
  char *pcVar1;
  char *pcVar2;
  Str y;
  int iVar3;
  Str cnv;
  char *p;
  char *org0;
  char *endp;
  char *org;
  
  org = orgstr->ptr;
  pcVar1 = org + orgstr->length;
  cnv = (Str)0x0;
  *charset = 0;
LAB_080a536d:
  while( true ) {
    if (pcVar1 <= org) {
      if (cnv == (Str)0x0) {
        cnv = orgstr;
      }
      return cnv;
    }
    if ((*org == '=') && (org[1] == '?')) break;
    if (cnv != (Str)0x0) {
      if (cnv->area_size <= cnv->length + 1) {
        Strgrow(cnv);
      }
      iVar3 = cnv->length;
      cnv->ptr[iVar3] = *org;
      cnv->length = iVar3 + 1;
      cnv->ptr[cnv->length] = '\0';
    }
    org = org + 1;
  }
  if (cnv == (Str)0x0) {
    cnv = Strnew_size(orgstr->length);
    Strcat_charp_n(cnv,orgstr->ptr,(int)org - (int)orgstr->ptr);
  }
nextEncodeWord:
  pcVar2 = org;
  y = decodeWord(&org,charset);
  Strcat(cnv,y);
  if (org == pcVar2) {
    Strcat_charp(cnv,org);
    return cnv;
  }
  org0 = org;
  do {
    iVar3 = (int)*org0;
    if (iVar3 != 0xd) {
      if (iVar3 < 0xe) {
        if (1 < iVar3 - 9U) goto LAB_080a536d;
      }
      else if (iVar3 != 0x20) break;
    }
    org0 = org0 + 1;
  } while( true );
  if ((iVar3 != 0x3d) || (org0[1] != '?')) goto LAB_080a536d;
  org = org0;
  goto nextEncodeWord;
}



Str encodeB(char *a)

{
  int iVar1;
  byte bVar2;
  byte bVar3;
  byte bVar4;
  Str x;
  Str w;
  int n_pad;
  int i;
  uchar d [3];
  uchar c4;
  uchar c3;
  uchar c2;
  uchar c1;
  
  x = Strnew();
  do {
    if (*a == '\0') {
      return x;
    }
    n_pad = 0;
    d[2] = '\0';
    d[1] = '\0';
    for (i = 0; i < 3; i = i + 1) {
      d[i] = a[i];
      if (a[i] == '\0') {
        n_pad = 3 - i;
        break;
      }
    }
    bVar3 = d[0] >> 2;
    bVar4 = d[1] >> 4;
    bVar2 = d[0] & 3;
    if (n_pad == 2) {
      c4 = '@';
      c3 = '@';
    }
    else if (n_pad == 1) {
      c3 = (uchar)((d[1] & 0xf) << 2);
      c4 = '@';
    }
    else {
      c3 = d[2] >> 6 | (d[1] & 0xf) << 2;
      c4 = d[2] & 0x3f;
    }
    if (x->area_size <= x->length + 1) {
      Strgrow(x);
    }
    iVar1 = x->length;
    x->ptr[iVar1] = Base64Table[bVar3];
    x->length = iVar1 + 1;
    x->ptr[x->length] = '\0';
    if (x->area_size <= x->length + 1) {
      Strgrow(x);
    }
    iVar1 = x->length;
    x->ptr[iVar1] = Base64Table[(byte)(bVar4 | bVar2 << 4)];
    x->length = iVar1 + 1;
    x->ptr[x->length] = '\0';
    if (x->area_size <= x->length + 1) {
      Strgrow(x);
    }
    iVar1 = x->length;
    x->ptr[iVar1] = Base64Table[c3];
    x->length = iVar1 + 1;
    x->ptr[x->length] = '\0';
    if (x->area_size <= x->length + 1) {
      Strgrow(x);
    }
    iVar1 = x->length;
    x->ptr[iVar1] = Base64Table[c4];
    x->length = iVar1 + 1;
    x->ptr[x->length] = '\0';
    if (n_pad != 0) {
      return x;
    }
    a = a + 3;
  } while( true );
}



// WARNING: Could not reconcile some variable overlaps

longchar * set_longchar(longchar *__return_storage_ptr__,char *str)

{
  wc_uchar *local_34;
  uint local_30;
  longchar r;
  uchar *p;
  
  if (*str < '\0') {
    wtf_parse1(&local_34);
    r.wch.code = local_30;
    if ((local_34 == (wc_uchar *)0x800) || (local_34 == (wc_uchar *)0x8800)) {
      r._0_4_ = CONCAT31(r._1_3_,4);
      *(undefined4 *)__return_storage_ptr__ = r._0_4_;
      (__return_storage_ptr__->wch).ccs = (wc_ccs)local_34;
      (__return_storage_ptr__->wch).code = local_30;
      *(uint *)&__return_storage_ptr__->ch = r._12_4_;
    }
    else {
      if ((((uint)local_34 & 0xffff) == 0x1000) ||
         ((((uint)local_34 & 0xffff) == 0x2000 || (((uint)local_34 & 0xffff) == 0x2001)))) {
        if (((uint)local_34 & 0xffff) == 0x2001) {
          r.wch.code = local_30 & 0x1fffff;
        }
        r.wch.ccs = 0x2000;
      }
      else {
        r.wch.ccs = (uint)local_34 & 0xffff;
      }
      r._0_4_ = CONCAT31(r._1_3_,2);
      *(undefined4 *)__return_storage_ptr__ = r._0_4_;
      (__return_storage_ptr__->wch).ccs = r.wch.ccs;
      (__return_storage_ptr__->wch).code = r.wch.code;
      *(uint *)&__return_storage_ptr__->ch = r._12_4_;
    }
  }
  else {
    r._12_4_ = r._12_4_ & 0xffffff00 | (uint)(byte)*str;
    r._0_4_ = CONCAT31(r._1_3_,1);
    *(undefined4 *)__return_storage_ptr__ = r._0_4_;
    (__return_storage_ptr__->wch).ccs = r.wch.ccs;
    (__return_storage_ptr__->wch).code = r.wch.code;
    *(uint *)&__return_storage_ptr__->ch = r._12_4_;
  }
  return __return_storage_ptr__;
}



char * regexCompile(char *ex,int igncase)

{
  char *msg;
  
  newRegex(ex,igncase,&DefaultRegex,&msg);
  return msg;
}



Regex * newRegex0(char **ex,int igncase,Regex *regex,char **msg,int level)

{
  undefined4 uVar1;
  longchar *plVar2;
  Regex *pRVar3;
  undefined4 local_3c;
  wc_ccs local_38;
  wc_uint32 local_34;
  undefined4 local_30;
  longchar *st_ptr;
  int m;
  regexchar *re;
  longchar *r;
  char *p;
  
  if (regex == (Regex *)0x0) {
    regex = (Regex *)GC_malloc(0x120c);
  }
  regex->alt_regex = (regex *)0x0;
  re = regex->re;
  st_ptr = regex->storage;
  p = *ex;
  do {
    plVar2 = st_ptr;
    if (*p == '\0') {
      re->mode = re->mode | 7;
      if (msg != (char **)0x0) {
        *msg = (char *)0x0;
      }
      *ex = p;
      return regex;
    }
    re->mode = '\0';
    switch(*p) {
    case '$':
      re->p = 0;
      re->mode = re->mode & 0xf8 | 6;
      re = re + 1;
      break;
    case '(':
      re->mode = re->mode & 0xf8 | 4;
      p = p + 1;
      pRVar3 = newRegex0(&p,igncase,(Regex *)0x0,msg,level + 1);
      re->p = pRVar3;
      if (re->p == 0) {
        return (Regex *)0x0;
      }
      re = re + 1;
      break;
    case ')':
      if (level == 0) {
        if (msg != (char **)0x0) {
          *msg = "Too many \')\'";
        }
        return (Regex *)0x0;
      }
      re->mode = re->mode | 7;
      *ex = p;
      return regex;
    case '*':
      if ((regex == (Regex *)re) || (((re[-1].mode & 7) != 1 && (re[-1].p == 0)))) {
        if (msg != (char **)0x0) {
          *msg = "Invalid regular expression";
        }
        return (Regex *)0x0;
      }
      re[-1].mode = re[-1].mode | 0x10;
      break;
    case '+':
      if ((regex == (Regex *)re) || (((re[-1].mode & 7) != 1 && (re[-1].p == 0)))) {
        if (msg != (char **)0x0) {
          *msg = "Invalid regular expression";
        }
        return (Regex *)0x0;
      }
      uVar1 = *(undefined4 *)&re[-1].mode;
      re->p = re[-1].p;
      *(undefined4 *)&re->mode = uVar1;
      re->mode = re->mode | 0x10;
      re = re + 1;
      break;
    case '.':
      re->p = 0;
      re->mode = re->mode & 0xf8 | 1;
      re = re + 1;
      break;
    case '?':
      if ((regex == (Regex *)re) || (((re[-1].mode & 7) != 1 && (re[-1].p == 0)))) {
        if (msg != (char **)0x0) {
          *msg = "Invalid regular expression";
        }
        return (Regex *)0x0;
      }
      re[-1].mode = re[-1].mode | 8;
      break;
    case '[':
      r = st_ptr;
      if (p[1] == '^') {
        m = 3;
        p = p + 2;
      }
      else {
        m = 2;
        p = p + 1;
      }
      if ((*p == '-') || (*p == ']')) {
        set_longchar((longchar *)&local_3c,p);
        *(undefined4 *)plVar2 = local_3c;
        (plVar2->wch).ccs = local_38;
        (plVar2->wch).code = local_34;
        *(undefined4 *)&plVar2->ch = local_30;
        st_ptr = st_ptr + 1;
      }
      while (plVar2 = st_ptr, *p != ']') {
        if (*p == '\\') {
          p = p + 1;
          set_longchar((longchar *)&local_3c,p);
          *(undefined4 *)plVar2 = local_3c;
          (plVar2->wch).ccs = local_38;
          (plVar2->wch).code = local_34;
          *(undefined4 *)&plVar2->ch = local_30;
          st_ptr = st_ptr + 1;
          p = p + WTF_LEN_MAP[(byte)*p];
        }
        else if ((*p == '-') && (p[1] != ']')) {
          st_ptr->type = '\x03';
          st_ptr = st_ptr + 1;
          p = p + 1;
        }
        else {
          if (*p == '\0') {
            if (msg != (char **)0x0) {
              *msg = "Missing ]";
            }
            return (Regex *)0x0;
          }
          set_longchar((longchar *)&local_3c,p);
          *(undefined4 *)plVar2 = local_3c;
          (plVar2->wch).ccs = local_38;
          (plVar2->wch).code = local_34;
          *(undefined4 *)&plVar2->ch = local_30;
          st_ptr = st_ptr + 1;
          p = p + WTF_LEN_MAP[(byte)*p];
        }
        if (&regex->position <= st_ptr) {
          if (msg != (char **)0x0) {
            *msg = "Regular expression too long";
          }
          return (Regex *)0x0;
        }
      }
      st_ptr->type = '\0';
      st_ptr = st_ptr + 1;
      re->p = r;
      re->mode = (byte)m & 7 | re->mode & 0xf8;
      if (igncase != 0) {
        re->mode = re->mode | 0x40;
      }
      re = re + 1;
      break;
    case '\\':
      p = p + 1;
    default:
      set_longchar((longchar *)&local_3c,p);
      *(undefined4 *)plVar2 = local_3c;
      (plVar2->wch).ccs = local_38;
      (plVar2->wch).code = local_34;
      *(undefined4 *)&plVar2->ch = local_30;
      p = p + (WTF_LEN_MAP[(byte)*p] - 1);
      re->p = st_ptr;
      st_ptr = st_ptr + 1;
      re->mode = re->mode & 0xf8;
      if (igncase != 0) {
        re->mode = re->mode | 0x40;
      }
      re = re + 1;
      break;
    case '^':
      re->p = 0;
      re->mode = re->mode & 0xf8 | 5;
      re = re + 1;
      break;
    case '|':
      re->mode = re->mode | 7;
      re = re + 1;
      p = p + 1;
      pRVar3 = newRegex0(&p,igncase,(Regex *)0x0,msg,level);
      regex->alt_regex = pRVar3;
      if (regex->alt_regex == (regex *)0x0) {
        return (Regex *)0x0;
      }
      *ex = p;
      return regex;
    }
    if ((&regex->position <= st_ptr) || (regex->storage <= re)) {
      if (msg != (char **)0x0) {
        *msg = "Regular expression too long";
      }
      return (Regex *)0x0;
    }
    p = p + 1;
  } while( true );
}



Regex * newRegex(char *ex,int igncase,Regex *regex,char **msg)

{
  Regex *pRVar1;
  
  pRVar1 = newRegex0(&ex,igncase,regex,msg,0);
  return pRVar1;
}



int regexMatch(char *str,int len,int firstp)

{
  int iVar1;
  
  iVar1 = RegexMatch(&DefaultRegex,str,len,firstp);
  return iVar1;
}



int RegexMatch(Regex *re,char *str,int len,int firstp)

{
  int iVar1;
  Regex *r;
  char *lpos;
  char *ep;
  char *p;
  
  if (str != (char *)0x0) {
    if (len < 0) {
      len = strlen(str);
    }
    re->position = (char *)0x0;
    ep = str + len;
    for (p = str; p <= ep; p = p + WTF_LEN_MAP[(byte)*p]) {
      lpos = (char *)0x0;
      re->lposition = (char *)0x0;
      for (r = re; r != (Regex *)0x0; r = r->alt_regex) {
        if ((firstp == 0) || (p != str)) {
          iVar1 = 0;
        }
        else {
          iVar1 = 1;
        }
        iVar1 = regmatch(r->re,p,ep,iVar1,&lpos);
        if (iVar1 == -1) {
          re->position = (char *)0x0;
          return -1;
        }
        if ((iVar1 == 1) &&
           ((re->position = p, re->lposition == (char *)0x0 || (re->lposition < lpos)))) {
          re->lposition = lpos;
        }
      }
      if (re->lposition != (char *)0x0) {
        return 1;
      }
    }
  }
  return 0;
}



void MatchedPosition(Regex *re,char **first,char **last)

{
  *first = re->position;
  *last = re->lposition;
  return;
}



void matchedPosition(char **first,char **last)

{
  *first = DefaultRegex.position;
  *last = DefaultRegex.lposition;
  return;
}



int regmatch_sub_anytime
              (MatchingContext2 *c,Regex *regex,regexchar *pat2,char *str,char *end_p,int iter_limit
              ,int firstp)

{
  MatchingContext1 *pMVar1;
  MatchingContext2 *pMVar2;
  int iVar3;
  
  iVar3 = c->label;
  if (iVar3 != 2) {
    if (iVar3 == 3) goto label3;
    if (iVar3 != 1) {
      pMVar1 = (MatchingContext1 *)GC_malloc(0x2c);
      c->ctx = pMVar1;
      pMVar2 = (MatchingContext2 *)GC_malloc(0x20);
      c->ctx2 = pMVar2;
      c->ctx->label = 0;
      c->regex = regex;
      c->n_any = 0;
      c->str = str;
      c->firstp = firstp;
      goto LAB_080a5fda;
    }
  }
  while( true ) {
    if (iter_limit != 1) {
      c->ctx2->label = 0;
label3:
      iVar3 = regmatch_sub_anytime
                        (c->ctx2,regex,pat2,c->str + c->n_any,end_p,iter_limit + -1,c->firstp);
      if (iVar3 != 0) {
        c->lastpos = c->ctx2->lastpos;
        c->label = 3;
        return 1;
      }
    }
    do {
      while (iVar3 = regmatch_iter(c->ctx,c->regex->re,c->str,end_p,c->firstp), iVar3 == 0) {
        if (c->regex->alt_regex == (regex *)0x0) {
          return 0;
        }
        c->regex = c->regex->alt_regex;
LAB_080a5fda:
        c->ctx->label = 0;
      }
      c->n_any = (int)c->ctx->lastpos - (int)c->str;
    } while (c->n_any < 1);
    c->firstp = 0;
    if ((pat2->mode & 7) == 7) break;
    iVar3 = regmatch(pat2,c->str + c->n_any,end_p,c->firstp,&c->lastpos);
    if (iVar3 == 1) {
      c->label = 2;
      return 1;
    }
  }
  c->lastpos = c->str + c->n_any;
  c->label = 1;
  return 1;
}



// WARNING: Could not reconcile some variable overlaps

int regmatch_iter(MatchingContext1 *c,regexchar *re,char *str,char *end_p,int firstp)

{
  byte bVar1;
  int iVar2;
  MatchingContext2 *pMVar3;
  MatchingContext1 *pMVar4;
  undefined4 local_3c;
  wc_ccs local_38;
  wc_uint32 local_34;
  undefined4 local_30;
  longchar k;
  
  switch(c->label) {
  default:
    if ((re->mode & 7) == 7) {
      iVar2 = 0;
    }
    else {
      c->re = re;
      c->firstp = firstp;
      c->str = str;
      c->end_p = end_p;
      c->sub_ctx = (MatchingContext1 *)0x0;
      c->lastpos = (char *)0x0;
      do {
        if ((c->re->mode & 7) == 7) {
          c->lastpos = c->str;
          c->label = 7;
          return 1;
        }
        if ((c->re->mode & 0x18) != 0) {
          if ((c->re->mode & 0x10) == 0) {
            c->iter_limit = 1;
          }
          else {
            c->iter_limit = 0xffff;
          }
          c->n_any = -1;
          goto label3;
        }
        bVar1 = c->re->mode & 7;
        if (bVar1 == 5) {
          if (c->firstp == 0) {
            return 0;
          }
          c->re = c->re + 1;
        }
        else {
          if (bVar1 == 6) {
            if (c->end_p <= c->str) {
              c->lastpos = c->str;
              c->re = c->re + 1;
              c->label = 4;
              return 1;
            }
            c->lastpos = (char *)0x0;
            return 0;
          }
          if (bVar1 == 4) {
            if (c->sub_ctx == (MatchingContext1 *)0x0) {
              pMVar4 = (MatchingContext1 *)GC_malloc(0x2c);
              c->sub_ctx = pMVar4;
            }
            c->sub_regex = (Regex *)c->re->p;
            do {
              c->sub_ctx->label = 0;
label6:
              while (iVar2 = regmatch_iter(c->sub_ctx,c->sub_regex->re,c->str,c->end_p,c->firstp),
                    iVar2 != 0) {
                if (c->sub_ctx->lastpos != c->str) {
                  c->firstp = 0;
                }
                if ((c->re[1].mode & 7) == 7) {
                  c->lastpos = c->sub_ctx->lastpos;
                  c->label = 5;
                  return 1;
                }
                iVar2 = regmatch(c->re + 1,c->sub_ctx->lastpos,c->end_p,c->firstp,&c->lastpos);
                if (iVar2 == 1) {
                  c->label = 6;
                  return 1;
                }
              }
              if (c->sub_regex->alt_regex == (regex *)0x0) {
                return 0;
              }
              c->sub_regex = c->sub_regex->alt_regex;
            } while( true );
          }
          set_longchar((longchar *)&local_3c,c->str);
          k._0_4_ = local_3c;
          k.wch.ccs = local_38;
          k.wch.code = local_34;
          k._12_4_ = local_30;
          c->str = c->str + WTF_LEN_MAP[(byte)*c->str];
          iVar2 = regmatch1(c->re,&k);
          if (iVar2 == 0) {
            return 0;
          }
          c->re = c->re + 1;
          c->firstp = 0;
        }
LAB_080a6775:
      } while (c->str <= c->end_p);
      iVar2 = 0;
    }
    break;
  case 1:
label1:
    iVar2 = regmatch_sub_anytime
                      (c->ctx2,(Regex *)c->re->p,c->re + 1,c->str + c->n_any,c->end_p,c->iter_limit,
                       c->firstp);
    if (iVar2 == 0) {
      iVar2 = 0;
    }
    else {
      c->n_any = (int)c->ctx2->lastpos - (int)c->str;
      c->lastpos = c->ctx2->lastpos;
      c->label = 1;
      iVar2 = 1;
    }
    break;
  case 2:
  case 3:
label3:
    do {
      if (c->iter_limit <= c->n_any) {
        return 0;
      }
      if (c->end_p <= c->str + c->n_any) {
        return 0;
      }
      if (c->n_any < 0) {
        c->n_any = c->n_any + 1;
      }
      else {
        if ((c->re->mode & 7) == 4) {
          pMVar3 = (MatchingContext2 *)GC_malloc(0x20);
          c->ctx2 = pMVar3;
          c->ctx2->label = 0;
          goto label1;
        }
        set_longchar((longchar *)&local_3c,c->str + c->n_any);
        k._0_4_ = local_3c;
        k.wch.ccs = local_38;
        k.wch.code = local_34;
        k._12_4_ = local_30;
        iVar2 = regmatch1(c->re,&k);
        if (iVar2 == 0) {
          return 0;
        }
        c->n_any = c->n_any + (uint)WTF_LEN_MAP[(byte)c->str[c->n_any]];
        c->firstp = 0;
      }
      if ((c->re[1].mode & 7) == 7) {
        c->lastpos = c->str + c->n_any;
        c->label = 2;
        return 1;
      }
      iVar2 = regmatch(c->re + 1,c->str + c->n_any,c->end_p,c->firstp,&c->lastpos);
    } while (iVar2 != 1);
    c->label = 3;
    iVar2 = 1;
    break;
  case 4:
    goto LAB_080a6775;
  case 5:
  case 6:
    goto label6;
  case 7:
    iVar2 = 0;
  }
  return iVar2;
}



int regmatch(regexchar *re,char *str,char *end_p,int firstp,char **lastpos)

{
  int iVar1;
  MatchingContext1 contx;
  
  *lastpos = (char *)0x0;
  contx.label = 0;
  while (iVar1 = regmatch_iter(&contx,re,str,end_p,firstp), iVar1 != 0) {
    if ((*lastpos == (char *)0x0) || (*lastpos < contx.lastpos)) {
      *lastpos = contx.lastpos;
    }
  }
  return (uint)(*lastpos != (char *)0x0);
}



int regmatch1(regexchar *re,longchar *c)

{
  byte bVar1;
  int iVar2;
  int ans;
  
  if (c->type == '\x04') {
    iVar2 = 0;
  }
  else {
    bVar1 = re->mode & 7;
    if (bVar1 == 1) {
      iVar2 = 1;
    }
    else {
      if (bVar1 < 2) {
        if ((re->mode & 7) == 0) {
          iVar2 = match_longchar((longchar *)re->p,c,re->mode & 0x40);
          return iVar2;
        }
      }
      else {
        if (bVar1 == 2) {
          iVar2 = matchWhich((longchar *)re->p,c,re->mode & 0x40);
          return iVar2;
        }
        if (bVar1 == 3) {
          iVar2 = matchWhich((longchar *)re->p,c,re->mode & 0x40);
          return (uint)(iVar2 == 0);
        }
      }
      iVar2 = 0;
    }
  }
  return iVar2;
}



int matchWhich(longchar *pattern,longchar *c,int igncase)

{
  int iVar1;
  int ans;
  longchar *p;
  
  p = pattern;
  while( true ) {
    while( true ) {
      if (p->type == '\0') {
        return 0;
      }
      if ((p[1].type != '\x03') || (p[2].type == '\0')) break;
      iVar1 = match_range_longchar(p,p + 2,c,igncase);
      if (iVar1 != 0) {
        return 1;
      }
      p = p + 3;
    }
    iVar1 = match_longchar(p,c,igncase);
    if (iVar1 != 0) break;
    p = p + 1;
  }
  return 1;
}



int match_longchar(longchar *a,longchar *b,int ignore)

{
  byte bVar1;
  uint uVar2;
  
  if (a->type == b->type) {
    if (a->type == '\x02') {
      if (((a->wch).ccs == (b->wch).ccs) && ((a->wch).code == (b->wch).code)) {
        uVar2 = 1;
      }
      else {
        uVar2 = 0;
      }
    }
    else if ((ignore == 0) || ((MYCTYPE_MAP[b->ch] & 4) == 0)) {
      uVar2 = (uint)(a->ch == b->ch);
    }
    else {
      if ((MYCTYPE_MAP[b->ch] & 4) == 0) {
        bVar1 = b->ch;
      }
      else {
        bVar1 = b->ch | 0x20;
      }
      if (a->ch != bVar1) {
        if ((MYCTYPE_MAP[b->ch] & 4) == 0) {
          bVar1 = b->ch;
        }
        else {
          bVar1 = b->ch & 0xdf;
        }
        if (a->ch != bVar1) {
          return 0;
        }
      }
      uVar2 = 1;
    }
  }
  else {
    uVar2 = 0;
  }
  return uVar2;
}



int match_range_longchar(longchar *a,longchar *b,longchar *c,int ignore)

{
  byte bVar1;
  int iVar2;
  
  if ((a->type != b->type) || (a->type != c->type)) {
    return 0;
  }
  if (a->type == '\x02') {
    if (((((a->wch).ccs == (c->wch).ccs) && ((c->wch).ccs == (b->wch).ccs)) &&
        ((a->wch).code <= (c->wch).code)) && ((c->wch).code <= (b->wch).code)) {
      return 1;
    }
    return 0;
  }
  if ((ignore == 0) || ((MYCTYPE_MAP[c->ch] & 4) == 0)) {
    if ((a->ch <= c->ch) && (c->ch <= b->ch)) {
      return 1;
    }
    return 0;
  }
  if ((MYCTYPE_MAP[c->ch] & 4) == 0) {
    bVar1 = c->ch;
  }
  else {
    bVar1 = c->ch | 0x20;
  }
  if (bVar1 < a->ch) {
LAB_080a6c32:
    if ((MYCTYPE_MAP[c->ch] & 4) == 0) {
      bVar1 = c->ch;
    }
    else {
      bVar1 = c->ch & 0xdf;
    }
    if (a->ch <= bVar1) {
      if ((MYCTYPE_MAP[c->ch] & 4) == 0) {
        bVar1 = c->ch;
      }
      else {
        bVar1 = c->ch & 0xdf;
      }
      if (bVar1 <= b->ch) goto LAB_080a6cb6;
    }
    iVar2 = 0;
  }
  else {
    if ((MYCTYPE_MAP[c->ch] & 4) == 0) {
      bVar1 = c->ch;
    }
    else {
      bVar1 = c->ch | 0x20;
    }
    if (b->ch < bVar1) goto LAB_080a6c32;
LAB_080a6cb6:
    iVar2 = 1;
  }
  return iVar2;
}



void KeyAbort(int _dummy)

{
                    // WARNING: Subroutine does not return
  siglongjmp((__jmp_buf_tag *)AbortLoading,1);
}



Str news_command(News *news,char *cmd,char *arg,int *status)

{
  Str p_Var1;
  Str tmp;
  
  if (news->host == (char *)0x0) {
    p_Var1 = (Str)0x0;
  }
  else {
    if (cmd != (char *)0x0) {
      if (arg == (char *)0x0) {
        tmp = Sprintf("%s\r\n",cmd);
      }
      else {
        tmp = Sprintf("%s %s\r\n",cmd,arg);
      }
      fwrite(tmp->ptr,1,tmp->length,(FILE *)news->wf);
      fflush((FILE *)news->wf);
    }
    if (status == (int *)0x0) {
      p_Var1 = (Str)0x0;
    }
    else {
      *status = -1;
      p_Var1 = StrISgets(news->rf);
      if (p_Var1->length != 0) {
        sscanf(p_Var1->ptr,"%d",status);
      }
    }
  }
  return p_Var1;
}



void news_close(News *news)

{
  if (news->host != (char *)0x0) {
    if (news->rf != (InputStream)0x0) {
      news->rf->field_0x14 = news->rf->field_0x14 & 0xef;
      ISclose(news->rf);
      news->rf = (InputStream)0x0;
    }
    if (news->wf != (FILE *)0x0) {
      fclose((FILE *)news->wf);
      news->wf = (FILE *)0x0;
    }
    news->host = (char *)0x0;
  }
  return;
}



int news_open(News *news)

{
  InputStream piVar1;
  int __fd;
  FILE *pFVar2;
  int status;
  int sock;
  
  sock = openSocket(news->host,"nntp",(ushort)news->port);
  if (-1 < sock) {
    piVar1 = newInputStream(sock);
    news->rf = piVar1;
    __fd = dup(sock);
    pFVar2 = fdopen(__fd,"wb");
    news->wf = (FILE *)pFVar2;
    if ((news->rf != (InputStream)0x0) && (news->wf != (FILE *)0x0)) {
      news->rf->field_0x14 = news->rf->field_0x14 | 0x10;
      news_command(news,(char *)0x0,(char *)0x0,&status);
      if (((status == 200) || (status == 0xc9)) &&
         (((news->mode == (char *)0x0 ||
           (news_command(news,"MODE",news->mode,&status), status == 200)) || (status == 0xc9)))) {
        return 1;
      }
    }
  }
  news_close(news);
  return 0;
}



void news_quit(News *news)

{
  news_command(news,"QUIT",(char *)0x0,(int *)0x0);
  news_close(news);
  return;
}



char * name_from_address(char *str,int n)

{
  bool bVar1;
  char *pcVar2;
  byte bVar3;
  int space;
  int l;
  char *p;
  char *s;
  
  bVar1 = true;
  s = allocStr(str,-1);
  while ((*s != '\0' && ((MYCTYPE_MAP[(byte)*s] & 2) != 0))) {
    s = s + 1;
  }
  if ((*s == '<') && (p = strchr(s,0x3e), p != (char *)0x0)) {
    *p = '\0';
    do {
      p = p + 1;
      if (*p == '\0') break;
    } while ((MYCTYPE_MAP[(byte)*p] & 2) != 0);
    if (*p == '\0') {
      s = s + 1;
    }
    else {
      s = p;
    }
  }
  else {
    pcVar2 = strchr(s,0x3c);
    if (pcVar2 == (char *)0x0) {
      pcVar2 = strchr(s,0x28);
      if (pcVar2 != (char *)0x0) {
        s = pcVar2;
      }
    }
    else {
      *pcVar2 = '\0';
    }
  }
  if ((*s == '\"') && (pcVar2 = strchr(s + 1,0x22), pcVar2 != (char *)0x0)) {
    *pcVar2 = '\0';
    s = s + 1;
  }
  else if ((*s == '(') && (pcVar2 = strchr(s + 1,0x29), pcVar2 != (char *)0x0)) {
    *pcVar2 = '\0';
    s = s + 1;
  }
  l = 0;
  for (p = s; *p != '\0'; p = p + WTF_LEN_MAP[(byte)*p]) {
    if ((MYCTYPE_MAP[(byte)*p] & 2) == 0) {
      bVar1 = false;
LAB_080a7185:
      if (WcOption.use_wide == '\0') {
        bVar3 = WTF_WIDTH_MAP[(byte)*p] != '\0';
      }
      else {
        bVar3 = WTF_WIDTH_MAP[(byte)*p];
      }
      l = l + (uint)bVar3;
      if (n < l) break;
    }
    else if (!bVar1) {
      bVar1 = true;
      goto LAB_080a7185;
    }
  }
  *p = '\0';
  return s;
}



char * html_quote_s(char *str)

{
  int iVar1;
  bool bVar2;
  int space;
  char *q;
  char *p;
  Str tmp;
  
  tmp = (Str)0x0;
  bVar2 = true;
  p = str;
  do {
    if (*p == '\0') {
      if (tmp != (Str)0x0) {
        str = tmp->ptr;
      }
      return str;
    }
    if ((MYCTYPE_MAP[(byte)*p] & 2) == 0) {
      q = HTML_QUOTE_MAP[QUOTE_MAP[(byte)*p] & 7];
      bVar2 = false;
LAB_080a7277:
      if (q == (char *)0x0) {
        if (tmp != (Str)0x0) {
          if (tmp->area_size <= tmp->length + 1) {
            Strgrow(tmp);
          }
          iVar1 = tmp->length;
          tmp->ptr[iVar1] = *p;
          tmp->length = iVar1 + 1;
          tmp->ptr[tmp->length] = '\0';
        }
      }
      else {
        if (tmp == (Str)0x0) {
          tmp = Strnew_charp_n(str,(int)p - (int)str);
        }
        Strcat_charp(tmp,q);
      }
    }
    else if (!bVar2) {
      q = "&nbsp;";
      bVar2 = true;
      goto LAB_080a7277;
    }
    p = p + 1;
  } while( true );
}



void add_news_message(Str str,int index,char *date,char *name,char *subject,char *mid,char *scheme,
                     char *group)

{
  char *pcVar1;
  tm *ptVar2;
  Str p_Var3;
  char *pcVar4;
  tm *tm;
  time_t t;
  
  pcVar1 = name_from_address(name,0x10);
  t = mymktime(date);
  ptVar2 = localtime(&t);
  pcVar1 = html_quote_s(pcVar1);
  p_Var3 = Sprintf("<tr valign=top><td>%d<td nowrap>(%02d/%02d)<td nowrap>%s",index,
                   ptVar2->tm_mon + 1,ptVar2->tm_mday,pcVar1);
  Strcat(str,p_Var3);
  if (group == (char *)0x0) {
    pcVar1 = html_quote(subject);
    pcVar4 = file_quote(mid);
    pcVar4 = html_quote(pcVar4);
    p_Var3 = Sprintf("<td><a href=\"%s%s\">%s</a>\n",scheme,pcVar4,pcVar1);
    Strcat(str,p_Var3);
  }
  else {
    pcVar1 = html_quote(subject);
    p_Var3 = Sprintf("<td><a href=\"%s%s/%d\">%s</a>\n",scheme,group,index,pcVar1);
    Strcat(str,p_Var3);
  }
  return;
}



InputStream openNewsStream(ParsedURL *pu)

{
  int iVar1;
  char *pcVar2;
  Str p_Var3;
  InputStream piVar4;
  int status;
  int port;
  Str tmp;
  char *p;
  char *group;
  char *mode;
  char *host;
  
  if ((pu->file == (char *)0x0) || (*pu->file == '\0')) {
    piVar4 = (InputStream)0x0;
  }
  else {
    if ((pu->scheme == 7) || (pu->scheme == 8)) {
      host = pu->host;
    }
    else {
      host = NNTP_server;
    }
    if ((host == (char *)0x0) || (*host == '\0')) {
      if (current_news.host != (char *)0x0) {
        news_quit(&current_news);
      }
      piVar4 = (InputStream)0x0;
    }
    else {
      if (((pu->scheme == 7) || (pu->scheme == 8)) || (p = strchr(host,0x3a), p == (char *)0x0)) {
        port = pu->port;
      }
      else {
        host = allocStr(host,(int)p - (int)host);
        port = atoi(p + 1);
      }
      if ((NNTP_mode == (char *)0x0) || (*NNTP_mode == '\0')) {
        mode = (char *)0x0;
      }
      else {
        mode = NNTP_mode;
      }
      if (current_news.host != (char *)0x0) {
        iVar1 = strcmp(current_news.host,host);
        if ((iVar1 == 0) && (current_news.port == port)) {
          pcVar2 = mode;
          if (mode == (char *)0x0) {
            pcVar2 = "READER";
          }
          tmp = news_command(&current_news,"MODE",pcVar2,&status);
          if ((status != 200) && (status != 0xc9)) {
            news_close(&current_news);
          }
        }
        else {
          news_quit(&current_news);
        }
      }
      if (current_news.host == (char *)0x0) {
        current_news.host = allocStr(host,-1);
        current_news.port = port;
        if (mode == (char *)0x0) {
          current_news.mode = (char *)0x0;
        }
        else {
          current_news.mode = allocStr(mode,-1);
        }
        iVar1 = news_open(&current_news);
        if (iVar1 == 0) {
          return (InputStream)0x0;
        }
      }
      if ((pu->scheme == 7) || (pu->scheme == 9)) {
        pcVar2 = allocStr(pu->file,-1);
        group = file_unquote(pcVar2);
        p = strchr(group,0x2f);
        if (p == (char *)0x0) {
          pcVar2 = strchr(group,0x40);
          if (pcVar2 == (char *)0x0) {
            return (InputStream)0x0;
          }
          p = group;
        }
        else {
          *p = '\0';
          p = p + 1;
          news_command(&current_news,"GROUP",group,&status);
          if (status != 0xd3) {
            return (InputStream)0x0;
          }
        }
        pcVar2 = strchr(p,0x40);
        if (pcVar2 == (char *)0x0) {
          news_command(&current_news,"ARTICLE",p,&status);
        }
        else {
          p_Var3 = Sprintf("<%s>",p);
          news_command(&current_news,"ARTICLE",p_Var3->ptr,&status);
        }
        piVar4 = current_news.rf;
        if (status != 0xdc) {
          piVar4 = (InputStream)0x0;
        }
      }
      else {
        piVar4 = (InputStream)0x0;
      }
    }
  }
  return piVar4;
}



Str loadNewsgroup(ParsedURL *pu,wc_ces *charset)

{
  wc_ces wVar1;
  Str p_Var2;
  int iVar3;
  wc_ces *pwVar4;
  char *pcVar5;
  InputStream date;
  InputStream arg;
  int *status_00;
  char *pcVar6;
  int *piVar7;
  char *pcVar8;
  int iVar9;
  URLFile f;
  wc_ces mime_charset;
  wc_ces doc_charset;
  anon_subr_void_int *prevtrap;
  int end;
  int start;
  int flag;
  int last;
  int first;
  int i;
  int status;
  char *list;
  char *group;
  char *scheme;
  char *n;
  char *t;
  char *s;
  char *q;
  char *p;
  char *qgroup;
  Buffer *buf;
  Str tmp;
  Str page;
  
  flag = 0;
  start = 0;
  end = 0;
  prevtrap = (anon_subr_void_int *)0x0;
  doc_charset = DocumentCharset;
  *charset = 0x100;
  if (((current_news.host == (char *)0x0) || (pu->file == (char *)0x0)) || (*pu->file == '\0')) {
    page = (Str)0x0;
  }
  else {
    group = allocStr(pu->file,-1);
    if (pu->scheme == 8) {
      scheme = "/";
    }
    else {
      scheme = "news:";
    }
    list = strchr(group,0x2f);
    if (list != (char *)0x0) {
      *list = '\0';
      list = list + 1;
    }
    if (fmInitialized != '\0') {
      p_Var2 = Sprintf("Reading newsgroup %s...",group);
      message(p_Var2->ptr,0,0);
      refresh();
    }
    qgroup = html_quote(group);
    group = file_unquote(group);
    p_Var2 = parsedURL2Str(pu);
    pcVar8 = "</h1>\n<hr>\n";
    pcVar6 = "</title>\n</head>\n<body>\n<h1>Newsgroup: ";
    piVar7 = (int *)qgroup;
    page = Strnew_m_charp("<html>\n<head>\n<base href=\"",p_Var2->ptr,"\">\n<title>Newsgroup: ",
                          qgroup,"</title>\n</head>\n<body>\n<h1>Newsgroup: ",qgroup,"</h1>\n<hr>\n"
                          ,0);
    iVar3 = __sigsetjmp(AbortLoading,1);
    if (iVar3 == 0) {
      if ((TrapSignal != '\0') && (prevtrap = mySignal(2,KeyAbort), fmInitialized != '\0')) {
        term_cbreak();
      }
      status_00 = &status;
      arg = (InputStream)group;
      tmp = news_command(&current_news,"GROUP",group,status_00);
      if (status == 0xd3) {
        piVar7 = &last;
        pcVar6 = (char *)&first;
        status_00 = &i;
        arg = (InputStream)&status;
        iVar3 = sscanf(tmp->ptr,"%d %d %d %d",arg,status_00,pcVar6,piVar7);
        if (iVar3 == 4) {
          if ((list != (char *)0x0) && (*list != '\0')) {
            p = strchr(list,0x2d);
            if (p != (char *)0x0) {
              *p = '\0';
              p = p + 1;
              end = atoi(p);
            }
            start = atoi(list);
            if (0 < start) {
              if (start < first) {
                start = first;
              }
              if (end < 1) {
                end = start + MaxNewsMessage + -1;
              }
            }
          }
          if (start < 1) {
            start = first;
            end = last;
            if (MaxNewsMessage + -1 < last - first) {
              start = (last - MaxNewsMessage) + 1;
            }
          }
          iVar3 = start;
          pcVar6 = (char *)end;
          p_Var2 = parsedURL2Str(pu);
          piVar7 = (int *)qgroup;
          pcVar8 = (char *)iVar3;
          iVar9 = (int)pcVar6;
          page = Sprintf("<html>\n<head>\n<base href=\"%s\">\n<title>Newsgroup: %s %d-%d</title>\n</head>\n<body>\n<h1>Newsgroup: %s %d-%d</h1>\n<hr>\n"
                         ,p_Var2->ptr,qgroup,iVar3,pcVar6,qgroup,iVar3,pcVar6);
          if (first < start) {
            i = start - MaxNewsMessage;
            if (i < first) {
              i = first;
            }
            pcVar8 = (char *)(start + -1);
            pcVar6 = (char *)(start + -1);
            iVar3 = i;
            piVar7 = (int *)i;
            p_Var2 = Sprintf("<a href=\"%s%s/%d-%d\">[%d-%d]</a>\n",scheme,qgroup,i,pcVar6,i,pcVar8,
                             iVar9);
            Strcat(page,p_Var2);
          }
          Strcat_charp(page,"<table>\n");
          p_Var2 = Sprintf("%d-%d",start,end,iVar3,pcVar6,piVar7,pcVar8,iVar9);
          arg = (InputStream)p_Var2->ptr;
          status_00 = &status;
          news_command(&current_news,"XOVER",(char *)arg,status_00);
          if (status == 0xe0) {
            f.scheme = '\t';
            while (((tmp = StrISgets(current_news.rf), *tmp->ptr != '.' ||
                    (((tmp->ptr[1] != '\n' && (tmp->ptr[1] != '\r')) && (tmp->ptr[1] != '\0')))) &&
                   (((*tmp->ptr != '\n' && (*tmp->ptr != '\r')) && (*tmp->ptr != '\0'))))) {
              arg = (InputStream)&i;
              iVar3 = sscanf(tmp->ptr,"%d");
              if ((iVar3 == 1) && (s = strchr(tmp->ptr,9), s != (char *)0x0)) {
                s = s + 1;
                n = strchr(s,9);
                if (n != (char *)0x0) {
                  *n = '\0';
                  n = n + 1;
                  t = strchr(n,9);
                  if (t != (char *)0x0) {
                    *t = '\0';
                    t = t + 1;
                    p = strchr(t,9);
                    if (p != (char *)0x0) {
                      *p = '\0';
                      pcVar5 = p + 1;
                      if (p[1] == '<') {
                        pcVar5 = p + 2;
                      }
                      p = pcVar5;
                      q = strchr(p,0x3e);
                      if ((q != (char *)0x0) || (q = strchr(p,9), q != (char *)0x0)) {
                        *q = '\0';
                        p_Var2 = Strnew_charp(s);
                        tmp = decodeMIME(p_Var2,&mime_charset);
                        pwVar4 = charset;
                        wVar1 = doc_charset;
                        if (mime_charset != 0) {
                          pwVar4 = &mime_charset;
                          wVar1 = mime_charset;
                        }
                        p_Var2 = convertLine(&f,tmp,3,pwVar4,wVar1);
                        s = p_Var2->ptr;
                        p_Var2 = Strnew_charp(n);
                        tmp = decodeMIME(p_Var2,&mime_charset);
                        pwVar4 = charset;
                        wVar1 = doc_charset;
                        if (mime_charset != 0) {
                          pwVar4 = &mime_charset;
                          wVar1 = mime_charset;
                        }
                        p_Var2 = convertLine(&f,tmp,3,pwVar4,wVar1);
                        status_00 = (int *)p_Var2->ptr;
                        pcVar5 = qgroup;
                        if (pu->scheme != 8) {
                          pcVar5 = (char *)0x0;
                        }
                        arg = (InputStream)t;
                        pcVar6 = s;
                        piVar7 = (int *)p;
                        pcVar8 = scheme;
                        n = (char *)status_00;
                        add_news_message(page,i,t,(char *)status_00,s,p,scheme,pcVar5);
                      }
                    }
                  }
                }
              }
            }
          }
          else {
            arg = current_news.rf;
            init_stream(&f,9,current_news.rf);
            if (showLineNum == 0) {
              iVar3 = 1;
            }
            else {
              iVar3 = 6;
            }
            iVar3 = COLS - iVar3;
            if (iVar3 < 0) {
              iVar3 = 0;
            }
            buf = newBuffer(iVar3);
            for (i = start; (i <= end && (i <= last)); i = i + 1) {
              p_Var2 = Sprintf("%d",i);
              arg = (InputStream)p_Var2->ptr;
              status_00 = &status;
              news_command(&current_news,"HEAD",(char *)arg,status_00);
              if (status == 0xdd) {
                status_00 = (int *)0x0;
                arg = (InputStream)0x0;
                readHeader(&f,buf,0,(ParsedURL *)0x0);
                p = checkHeader(buf,"Message-ID:");
                if (p != (char *)0x0) {
                  if (*p == '<') {
                    p = p + 1;
                  }
                  q = strchr(p,0x3e);
                  if ((q == (char *)0x0) && (q = strchr(p,9), q == (char *)0x0)) {
                    uRam00000000 = 0;
                  }
                  s = checkHeader(buf,"Subject:");
                  if (((s != (char *)0x0) && (n = checkHeader(buf,"From:"), n != (char *)0x0)) &&
                     (date = (InputStream)checkHeader(buf,"Date:"), t = (char *)date,
                     date != (InputStream)0x0)) {
                    pcVar5 = qgroup;
                    if (pu->scheme != 8) {
                      pcVar5 = (char *)0x0;
                    }
                    status_00 = (int *)n;
                    pcVar6 = s;
                    piVar7 = (int *)p;
                    pcVar8 = scheme;
                    add_news_message(page,i,(char *)date,n,s,p,scheme,pcVar5);
                    arg = date;
                  }
                }
              }
            }
          }
          Strcat_charp(page,"</table>\n");
          if (end < last) {
            i = end + MaxNewsMessage;
            if (last < i) {
              i = last;
            }
            piVar7 = (int *)(end + 1);
            status_00 = (int *)(end + 1);
            arg = (InputStream)qgroup;
            pcVar6 = (char *)i;
            pcVar8 = (char *)i;
            p_Var2 = Sprintf("<a href=\"%s%s/%d-%d\">[%d-%d]</a>\n",scheme,qgroup,status_00,i,piVar7
                             ,i);
            Strcat(page,p_Var2);
          }
          flag = 1;
        }
      }
      tmp = Sprintf("ACTIVE %s",group,arg,status_00,pcVar6,piVar7,pcVar8);
      pcVar6 = strchr(group,0x2a);
      if (pcVar6 == (char *)0x0) {
        Strcat_charp(tmp,".*");
      }
      news_command(&current_news,"LIST",tmp->ptr,&status);
      if (status == 0xd7) {
        while (((tmp = StrISgets(current_news.rf), *tmp->ptr != '.' ||
                (((tmp->ptr[1] != '\n' && (tmp->ptr[1] != '\r')) && (tmp->ptr[1] != '\0')))) &&
               (((*tmp->ptr != '\n' && (*tmp->ptr != '\r')) && (*tmp->ptr != '\0'))))) {
          if (flag < 2) {
            if (flag == 1) {
              Strcat_charp(page,"<hr>\n");
            }
            Strcat_charp(page,"<table>\n");
            flag = 2;
          }
          p = tmp->ptr;
          q = p;
          while ((*q != '\0' && ((MYCTYPE_MAP[(byte)*q] & 2) == 0))) {
            q = q + 1;
          }
          *q = '\0';
          q = q + 1;
          iVar3 = sscanf(q,"%d %d",&last,&first);
          if ((iVar3 == 2) && (first <= last)) {
            i = (last - first) + 1;
          }
          else {
            i = 0;
          }
          pcVar6 = html_quote(p);
          pcVar8 = file_quote(p);
          pcVar8 = html_quote(pcVar8);
          p_Var2 = Sprintf("<tr><td align=right>%d<td><a href=\"%s%s\">%s</a>\n",i,scheme,pcVar8,
                           pcVar6);
          Strcat(page,p_Var2);
        }
        if (flag == 2) {
          Strcat_charp(page,"</table>\n");
        }
      }
    }
    else {
      news_close(&current_news);
      Strcat_charp(page,"</table>\n<p>Transfer Interrupted!\n");
    }
    Strcat_charp(page,"</body>\n</html>\n");
    if (TrapSignal != '\0') {
      if (fmInitialized != '\0') {
        term_raw();
      }
      if (prevtrap != (anon_subr_void_int *)0x0) {
        mySignal(2,prevtrap);
      }
    }
  }
  return page;
}



void closeNews(void)

{
  news_close(&current_news);
  return;
}



void disconnectNews(void)

{
  news_quit(&current_news);
  return;
}



void setKeymap(char *p,int lineno,int verbose)

{
  char *pcVar1;
  uint key;
  Str p_Var2;
  int iVar3;
  uint uVar4;
  uchar *puVar5;
  int m;
  int j;
  int i;
  uchar **mmap;
  int f;
  int c;
  char *emsg;
  char *s;
  uchar *map;
  
  pcVar1 = getQWord(&p);
  key = getKey(pcVar1);
  if ((int)key < 0) {
    if (lineno < 1) {
      p_Var2 = Sprintf("defkey: unknown key \'%s\'",pcVar1);
      emsg = p_Var2->ptr;
    }
    else {
      p_Var2 = Sprintf("line %d: unknown key \'%s\'",lineno,pcVar1);
      emsg = p_Var2->ptr;
    }
    record_err_message(emsg);
    if (verbose != 0) {
      disp_message_nsec(emsg,0,1,1,0);
    }
  }
  else {
    pcVar1 = getWord(&p);
    iVar3 = getFuncList(pcVar1);
    if (iVar3 < 0) {
      if (lineno < 1) {
        p_Var2 = Sprintf("defkey: invalid command \'%s\'",pcVar1);
        emsg = p_Var2->ptr;
      }
      else {
        p_Var2 = Sprintf("line %d: invalid command \'%s\'",lineno,pcVar1);
        emsg = p_Var2->ptr;
      }
      record_err_message(emsg);
      if (verbose != 0) {
        disp_message_nsec(emsg,0,1,1,0);
      }
    }
    else {
      if ((key & 0x10000000) == 0) {
        if ((key & 0x400) == 0) {
          if ((key & 0x200) == 0) {
            if ((key & 0x100) == 0) {
              map = GlobalKeymap;
            }
            else {
              map = EscKeymap;
            }
          }
          else {
            map = EscBKeymap;
          }
        }
        else {
          map = EscDKeymap;
        }
      }
      else {
        mmap = (uchar **)0x0;
        uVar4 = (int)key >> 0x10;
        if ((uVar4 & 0x400) == 0) {
          if ((uVar4 & 0x200) == 0) {
            if ((uVar4 & 0x100) == 0) {
              map = GlobalKeymap;
            }
            else {
              map = EscKeymap;
            }
          }
          else {
            map = EscBKeymap;
          }
        }
        else {
          map = EscDKeymap;
        }
        if (map[uVar4 & 0x7f] == 'J') {
          mmap = (uchar **)getKeyData(uVar4 & 0x77f);
        }
        else {
          map[uVar4 & 0x7f] = 'J';
        }
        if (mmap == (uchar **)0x0) {
          mmap = (uchar **)GC_malloc(0x10);
          for (i = 0; i < 4; i = i + 1) {
            puVar5 = (uchar *)GC_malloc(0x80);
            mmap[i] = puVar5;
            for (j = 0; j < 0x80; j = j + 1) {
              mmap[i][j] = '\0';
            }
          }
          (*mmap)[0x1b] = '\x1c';
          mmap[1][0x5b] = '\x1b';
          mmap[1][0x4f] = '\x1b';
        }
        if (keyData == (Hash_iv *)0x0) {
          keyData = newHash_iv(0x10);
        }
        putHash_iv(keyData,uVar4 & 0x77f,mmap);
        if ((key & 0x400) == 0) {
          if ((key & 0x200) == 0) {
            if ((key & 0x100) == 0) {
              map = *mmap;
            }
            else {
              map = mmap[1];
            }
          }
          else {
            map = mmap[2];
          }
        }
        else {
          map = mmap[3];
        }
      }
      map[key & 0x7f] = (uchar)iVar3;
      pcVar1 = getQWord(&p);
      if (*pcVar1 == '\0') {
        pcVar1 = getKeyData(key);
        if (pcVar1 != (char *)0x0) {
          putHash_iv(keyData,key,(void *)0x0);
        }
      }
      else {
        if (keyData == (Hash_iv *)0x0) {
          keyData = newHash_iv(0x10);
        }
        putHash_iv(keyData,key,pcVar1);
      }
    }
  }
  return;
}



// WARNING: Could not reconcile some variable overlaps

void interpret_keymap(FILE *kf,stat *current,int force)

{
  int iVar1;
  char *pcVar2;
  Str p_Var3;
  stat *psVar4;
  byte bVar5;
  stat kstat;
  int verbose;
  wc_ces charset;
  int lineno;
  char *emsg;
  char *s;
  char *p;
  Str line;
  int fd;
  
  bVar5 = 0;
  charset = SystemCharset;
  verbose = 1;
  fd = fileno((FILE *)kf);
  if (((-1 < fd) && (iVar1 = fstat(fd,(stat *)&kstat), iVar1 == 0)) &&
     (((force != 0 ||
       (((kstat.st_mtim.tv_sec != (current->st_mtim).tv_sec ||
         ((*(uint *)&current->st_dev ^ (uint)kstat.st_dev |
          kstat.st_dev._4_4_ ^ *(uint *)((int)&current->st_dev + 4)) != 0)) ||
        (kstat.st_ino != current->st_ino)))) || (kstat.st_size != current->st_size)))) {
    psVar4 = &kstat;
    for (iVar1 = 0x16; iVar1 != 0; iVar1 = iVar1 + -1) {
      *(undefined4 *)&current->st_dev = *(undefined4 *)&psVar4->st_dev;
      psVar4 = (stat *)((int)psVar4 + (uint)bVar5 * -8 + 4);
      current = (stat *)((int)current + (uint)bVar5 * -8 + 4);
    }
    lineno = 0;
    while (iVar1 = feof((FILE *)kf), iVar1 == 0) {
      line = Strfgets(kf);
      lineno = lineno + 1;
      Strchop(line);
      Strremovefirstspaces(line);
      if (line->length != 0) {
        line = wc_Str_conv(line,charset,InnerCharset);
        p = line->ptr;
        pcVar2 = getWord(&p);
        if (*pcVar2 != '#') {
          iVar1 = strcmp(pcVar2,"keymap");
          if (iVar1 == 0) {
            setKeymap(p,lineno,verbose);
          }
          else {
            iVar1 = strcmp(pcVar2,"charset");
            if ((iVar1 == 0) || (iVar1 = strcmp(pcVar2,"encoding"), iVar1 == 0)) {
              pcVar2 = getQWord(&p);
              if (*pcVar2 != '\0') {
                charset = wc_guess_charset(pcVar2,charset);
              }
            }
            else {
              iVar1 = strcmp(pcVar2,"verbose");
              if (iVar1 == 0) {
                pcVar2 = getWord(&p);
                if (*pcVar2 != '\0') {
                  verbose = str_to_bool(pcVar2,verbose);
                }
              }
              else {
                p_Var3 = Sprintf("line %d: syntax error \'%s\'",lineno,pcVar2);
                pcVar2 = p_Var3->ptr;
                record_err_message(pcVar2);
                if (verbose != 0) {
                  disp_message_nsec(pcVar2,0,1,1,0);
                }
              }
            }
          }
        }
      }
    }
  }
  return;
}



void initKeymap(int force)

{
  char *pcVar1;
  FILE *pFVar2;
  int iVar3;
  FILE *kf;
  
  pcVar1 = confFile("keymap");
  pFVar2 = fopen(pcVar1,"rt");
  if (pFVar2 != (FILE *)0x0) {
    if ((force == 0) && (keymap_initialized != '\0')) {
      iVar3 = 0;
    }
    else {
      iVar3 = 1;
    }
    interpret_keymap((FILE *)pFVar2,&sys_current_keymap_file,iVar3);
    fclose(pFVar2);
  }
  pcVar1 = rcFile(keymap_file);
  pFVar2 = fopen(pcVar1,"rt");
  if (pFVar2 != (FILE *)0x0) {
    if ((force == 0) && (keymap_initialized != '\0')) {
      iVar3 = 0;
    }
    else {
      iVar3 = 1;
    }
    interpret_keymap((FILE *)pFVar2,&current_keymap_file,iVar3);
    fclose(pFVar2);
  }
  keymap_initialized = '\x01';
  return;
}



int getFuncList(char *id)

{
  int iVar1;
  
  iVar1 = getHash_si(&functable,id,-1);
  return iVar1;
}



char * getKeyData(int key)

{
  char *pcVar1;
  
  if (keyData == (Hash_iv *)0x0) {
    pcVar1 = (char *)0x0;
  }
  else {
    pcVar1 = (char *)getHash_iv(keyData,key,(void *)0x0);
  }
  return pcVar1;
}



int getKey2(char **str)

{
  byte *pbVar1;
  bool bVar2;
  uint uVar3;
  int iVar4;
  int ctrl;
  int esc;
  int c;
  char *s;
  
  s = *str;
  esc = 0;
  bVar2 = false;
  if ((s == (char *)0x0) || (*s == '\0')) {
    uVar3 = 0xffffffff;
  }
  else {
    iVar4 = strcasecmp(s,"UP");
    if (iVar4 == 0) {
      *str = s + 2;
      uVar3 = 0x241;
    }
    else {
      iVar4 = strcasecmp(s,"DOWN");
      if (iVar4 == 0) {
        *str = s + 4;
        uVar3 = 0x242;
      }
      else {
        iVar4 = strcasecmp(s,"RIGHT");
        if (iVar4 == 0) {
          *str = s + 5;
          uVar3 = 0x243;
        }
        else {
          iVar4 = strcasecmp(s,"LEFT");
          if (iVar4 == 0) {
            *str = s + 4;
            uVar3 = 0x244;
          }
          else {
            iVar4 = strncasecmp(s,"ESC-",4);
            if ((iVar4 == 0) || (iVar4 = strncasecmp(s,"ESC ",4), iVar4 == 0)) {
              s = s + 4;
              esc = 0x100;
            }
            else {
              iVar4 = strncasecmp(s,"M-",2);
              if ((iVar4 == 0) || (iVar4 = strncasecmp(s,"\\E",2), iVar4 == 0)) {
                s = s + 2;
                esc = 0x100;
              }
              else if (*s == '\x1b') {
                s = s + 1;
                esc = 0x100;
              }
            }
            iVar4 = strncasecmp(s,"C-",2);
            if (iVar4 == 0) {
              s = s + 2;
              bVar2 = true;
            }
            else if ((*s == '^') && (s[1] != '\0')) {
              s = s + 1;
              bVar2 = true;
            }
            if (((esc == 0) && (bVar2)) && (*s == '[')) {
              s = s + 1;
              bVar2 = false;
              esc = 0x100;
            }
            if ((esc != 0) && (!bVar2)) {
              if ((*s == '[') || (*s == 'O')) {
                s = s + 1;
                esc = 0x200;
              }
              iVar4 = strncasecmp(s,"C-",2);
              if (iVar4 == 0) {
                s = s + 2;
                bVar2 = true;
              }
              else if ((*s == '^') && (s[1] != '\0')) {
                s = s + 1;
                bVar2 = true;
              }
            }
            if (bVar2) {
              *str = s + 1;
              if ((*s < '@') || ('_' < *s)) {
                if ((*s < 'a') || ('z' < *s)) {
                  if (*s == '?') {
                    uVar3 = esc | 0x7f;
                  }
                  else {
                    uVar3 = 0xffffffff;
                  }
                }
                else {
                  uVar3 = (int)*s - 0x60U | esc;
                }
              }
              else {
                uVar3 = (int)*s - 0x40U | esc;
              }
            }
            else if ((esc == 0x200) && ((MYCTYPE_MAP[(byte)*s] & 8) != 0)) {
              c = *s + -0x30;
              pbVar1 = (byte *)(s + 1);
              if ((MYCTYPE_MAP[*pbVar1] & 8) != 0) {
                c = c * 10 + (char)*pbVar1 + -0x30;
                pbVar1 = (byte *)(s + 2);
              }
              s = (char *)pbVar1;
              *str = s + 1;
              if (*s == '~') {
                uVar3 = c | 0x400;
              }
              else {
                uVar3 = 0xffffffff;
              }
            }
            else {
              iVar4 = strncasecmp(s,"SPC",3);
              if (iVar4 == 0) {
                *str = s + 3;
                uVar3 = esc | 0x20;
              }
              else {
                iVar4 = strncasecmp(s,"TAB",3);
                if (iVar4 == 0) {
                  *str = s + 3;
                  uVar3 = esc | 9;
                }
                else {
                  iVar4 = strncasecmp(s,"DEL",3);
                  if (iVar4 == 0) {
                    *str = s + 3;
                    uVar3 = esc | 0x7f;
                  }
                  else if ((*s == '\\') && (s[1] != '\0')) {
                    *str = s + 2;
                    switch(s[1]) {
                    case '\\':
                      uVar3 = esc | 0x5c;
                      break;
                    default:
                      uVar3 = 0xffffffff;
                      break;
                    case '^':
                      uVar3 = esc | 0x5e;
                      break;
                    case 'a':
                      uVar3 = esc | 7;
                      break;
                    case 'b':
                      uVar3 = esc | 8;
                      break;
                    case 'e':
                      uVar3 = esc | 0x1b;
                      break;
                    case 'n':
                      uVar3 = esc | 10;
                      break;
                    case 'r':
                      uVar3 = esc | 0xd;
                      break;
                    case 't':
                      uVar3 = esc | 9;
                    }
                  }
                  else {
                    *str = s + 1;
                    if ((MYCTYPE_MAP[(byte)*s] & 0x11) == 0) {
                      uVar3 = 0xffffffff;
                    }
                    else {
                      uVar3 = *s | esc;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return uVar3;
}



int getKey(char *s)

{
  uint uVar1;
  uint uVar2;
  int c2;
  int c;
  
  uVar1 = getKey2(&s);
  if ((int)uVar1 < 0) {
    uVar1 = 0xffffffff;
  }
  else {
    if ((*s == ' ') || (*s == '-')) {
      s = s + 1;
    }
    if (*s != '\0') {
      uVar2 = getKey2(&s);
      if ((int)uVar2 < 0) {
        uVar1 = 0xffffffff;
      }
      else {
        uVar1 = uVar1 << 0x10 | 0x10000000 | uVar2;
      }
    }
  }
  return uVar1;
}



char * getWord(char **str)

{
  char *p_00;
  Str p_Var1;
  char *s;
  char *p;
  
  p = *str;
  while ((p_00 = p, *p != '\0' && ((MYCTYPE_MAP[(byte)*p] & 2) != 0))) {
    p = p + 1;
  }
  for (; ((*p != '\0' && ((MYCTYPE_MAP[(byte)*p] & 2) == 0)) && (*p != ';')); p = p + 1) {
  }
  *str = p;
  p_Var1 = Strnew_charp_n(p_00,(int)p - (int)p_00);
  return p_Var1->ptr;
}



char * getQWord(char **str)

{
  int iVar1;
  bool bVar2;
  bool bVar3;
  bool bVar4;
  Str x;
  int esc;
  int in_dq;
  int in_q;
  char *p;
  Str tmp;
  
  x = Strnew();
  bVar3 = false;
  bVar4 = false;
  bVar2 = false;
  p = *str;
  while ((*p != '\0' && ((MYCTYPE_MAP[(byte)*p] & 2) != 0))) {
    p = p + 1;
  }
  for (; *p != '\0'; p = p + 1) {
    if (bVar2) {
      if (bVar3) {
        if ((*p != '\\') && (*p != '\'')) {
          if (x->area_size <= x->length + 1) {
            Strgrow(x);
          }
          iVar1 = x->length;
          x->ptr[iVar1] = '\\';
          x->length = iVar1 + 1;
          x->ptr[x->length] = '\0';
        }
      }
      else if (bVar4) {
        if ((*p != '\\') && (*p != '\"')) {
          if (x->area_size <= x->length + 1) {
            Strgrow(x);
          }
          iVar1 = x->length;
          x->ptr[iVar1] = '\\';
          x->length = iVar1 + 1;
          x->ptr[x->length] = '\0';
        }
      }
      else if ((((*p != '\\') && (*p != '\'')) && (*p != '\"')) &&
              ((MYCTYPE_MAP[(byte)*p] & 2) == 0)) {
        if (x->area_size <= x->length + 1) {
          Strgrow(x);
        }
        iVar1 = x->length;
        x->ptr[iVar1] = '\\';
        x->length = iVar1 + 1;
        x->ptr[x->length] = '\0';
      }
      if (x->area_size <= x->length + 1) {
        Strgrow(x);
      }
      iVar1 = x->length;
      x->ptr[iVar1] = *p;
      x->length = iVar1 + 1;
      x->ptr[x->length] = '\0';
      bVar2 = false;
    }
    else if (*p == '\\') {
      bVar2 = true;
    }
    else if (bVar3) {
      if (*p == '\'') {
        bVar3 = false;
      }
      else {
        if (x->area_size <= x->length + 1) {
          Strgrow(x);
        }
        iVar1 = x->length;
        x->ptr[iVar1] = *p;
        x->length = iVar1 + 1;
        x->ptr[x->length] = '\0';
      }
    }
    else if (bVar4) {
      if (*p == '\"') {
        bVar4 = false;
      }
      else {
        if (x->area_size <= x->length + 1) {
          Strgrow(x);
        }
        iVar1 = x->length;
        x->ptr[iVar1] = *p;
        x->length = iVar1 + 1;
        x->ptr[x->length] = '\0';
      }
    }
    else if (*p == '\'') {
      bVar3 = true;
    }
    else if (*p == '\"') {
      bVar4 = true;
    }
    else {
      if (((MYCTYPE_MAP[(byte)*p] & 2) != 0) || (*p == ';')) break;
      if (x->area_size <= x->length + 1) {
        Strgrow(x);
      }
      iVar1 = x->length;
      x->ptr[iVar1] = *p;
      x->length = iVar1 + 1;
      x->ptr[x->length] = '\0';
    }
  }
  *str = p;
  return x->ptr;
}



void setMouseAction0(char **str,int *width,MouseActionMap **map,char *p)

{
  int iVar1;
  wc_uchar *p_00;
  int iVar2;
  MouseActionMap *pMVar3;
  int x;
  int w;
  int b;
  char *s;
  
  p_00 = (wc_uchar *)getQWord(&p);
  if (*p_00 == '\0') {
    *str = (char *)0x0;
    for (b = 0; b < 3; b = b + 1) {
      map[b] = (MouseActionMap *)0x0;
    }
  }
  else {
    iVar1 = *width;
    *str = (char *)p_00;
    iVar2 = wtf_strwidth(p_00);
    *width = iVar2;
    if (99 < *width) {
      *width = 100;
    }
    if (iVar1 < *width) {
      for (b = 0; b < 3; b = b + 1) {
        if (map[b] != (MouseActionMap *)0x0) {
          pMVar3 = (MouseActionMap *)GC_realloc(map[b],*width * 8);
          map[b] = pMVar3;
          x = iVar1;
          while (x = x + 1, x < *width) {
            map[b][x].func = (anon_subr_void_varargs_for_func *)0x0;
            map[b][x].data = (char *)0x0;
          }
        }
      }
    }
  }
  return;
}



void setMouseAction1(MouseActionMap **map,int width,char *p)

{
  MouseActionMap *pMVar1;
  byte *pbVar2;
  int iVar3;
  char *id;
  int iVar4;
  anon_subr_void_varargs_for_func *paVar5;
  int f;
  int x2;
  int x;
  char *s;
  
  if (*map == (MouseActionMap *)0x0) {
    pMVar1 = (MouseActionMap *)GC_malloc(width << 3);
    *map = pMVar1;
    for (x = 0; x < width; x = x + 1) {
      (*map)[x].func = (anon_subr_void_varargs_for_func *)0x0;
      (*map)[x].data = (char *)0x0;
    }
  }
  pbVar2 = (byte *)getWord(&p);
  x = atoi((char *)pbVar2);
  if ((((MYCTYPE_MAP[*pbVar2] & 8) != 0) && (-1 < x)) && (x < width)) {
    pbVar2 = (byte *)getWord(&p);
    iVar3 = atoi((char *)pbVar2);
    if ((((MYCTYPE_MAP[*pbVar2] & 8) != 0) && (-1 < iVar3)) && (iVar3 < width)) {
      id = getWord(&p);
      iVar4 = getFuncList(id);
      s = getQWord(&p);
      if (*s == '\0') {
        s = (char *)0x0;
      }
      for (; x <= iVar3; x = x + 1) {
        if (iVar4 < 0) {
          paVar5 = (anon_subr_void_varargs_for_func *)0x0;
        }
        else {
          paVar5 = w3mFuncList[iVar4].func;
        }
        (*map)[x].func = (anon_subr_void_varargs_for_func *)paVar5;
        (*map)[x].data = s;
      }
    }
  }
  return;
}



void setMouseAction2(MouseActionMap *map,char *p)

{
  char *id;
  int iVar1;
  anon_subr_void_varargs_for_func *paVar2;
  int f;
  char *s;
  
  id = getWord(&p);
  iVar1 = getFuncList(id);
  s = getQWord(&p);
  if (*s == '\0') {
    s = (char *)0x0;
  }
  if (iVar1 < 0) {
    paVar2 = (anon_subr_void_varargs_for_func *)0x0;
  }
  else {
    paVar2 = w3mFuncList[iVar1].func;
  }
  map->func = (anon_subr_void_varargs_for_func *)paVar2;
  map->data = s;
  return;
}



void interpret_mouse_action(FILE *mf)

{
  wc_ces t_ces;
  wc_ces f_ces;
  Str p_Var1;
  char *pcVar2;
  int iVar3;
  int iVar4;
  int b;
  char *s;
  char *p;
  Str line;
  
  while (iVar4 = feof((FILE *)mf), iVar4 == 0) {
    line = Strfgets(mf);
    Strchop(line);
    Strremovefirstspaces(line);
    f_ces = SystemCharset;
    t_ces = InnerCharset;
    if (line->length != 0) {
      p_Var1 = Strnew_charp(line->ptr);
      p_Var1 = wc_Str_conv(p_Var1,f_ces,t_ces);
      p = p_Var1->ptr;
      pcVar2 = getWord(&p);
      if (*pcVar2 != '#') {
        iVar4 = strcmp(pcVar2,"menu");
        if (iVar4 == 0) {
          setMouseAction0(&mouse_action.menu_str,&mouse_action.menu_width,mouse_action.menu_map,p);
        }
        else {
          iVar4 = strcmp(pcVar2,"lastline");
          if (iVar4 == 0) {
            setMouseAction0(&mouse_action.lastline_str,&mouse_action.lastline_width,
                            mouse_action.lastline_map,p);
          }
          else {
            iVar4 = strcmp(pcVar2,"button");
            if (iVar4 == 0) {
              pcVar2 = getWord(&p);
              iVar4 = atoi(pcVar2);
              if ((-1 < iVar4 + -1) && (iVar4 + -1 < 3)) {
                while ((*p != '\0' && ((MYCTYPE_MAP[(byte)*p] & 2) != 0))) {
                  p = p + 1;
                }
                if ((MYCTYPE_MAP[(byte)*p] & 8) == 0) {
                  s = getWord(&p);
                }
                else {
                  s = "menu";
                }
                iVar3 = strcasecmp(s,"menu");
                if (iVar3 == 0) {
                  if (mouse_action.menu_str != (char *)0x0) {
                    setMouseAction1((MouseActionMap **)(&mouse_action.tab_map[2].data + iVar4),
                                    mouse_action.menu_width,p);
                  }
                }
                else {
                  iVar3 = strcasecmp(s,"lastline");
                  if (iVar3 == 0) {
                    if (mouse_action.lastline_str != (char *)0x0) {
                      setMouseAction1(mouse_action.menu_map + iVar4 + 2,mouse_action.lastline_width,
                                      p);
                    }
                  }
                  else {
                    iVar3 = strcasecmp(s,"default");
                    if (iVar3 == 0) {
                      setMouseAction2(mouse_action.default_map + iVar4 + -1,p);
                    }
                    else {
                      iVar3 = strcasecmp(s,"anchor");
                      if (iVar3 == 0) {
                        setMouseAction2(mouse_action.default_map + iVar4 + 2,p);
                      }
                      else {
                        iVar3 = strcasecmp(s,"active");
                        if (iVar3 == 0) {
                          setMouseAction2(mouse_action.anchor_map + iVar4 + 2,p);
                        }
                        else {
                          iVar3 = strcasecmp(s,"tab");
                          if (iVar3 == 0) {
                            setMouseAction2(mouse_action.active_map + iVar4 + 2,p);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return;
}



void initMouseAction(void)

{
  char **ppcVar1;
  Str p_Var2;
  char *pcVar3;
  char **symbol;
  int w;
  FILE *mf;
  
  bcopy(&default_mouse_action,&mouse_action,0x94);
  mouse_action.lastline_map[0] = (MouseActionMap *)GC_malloc(0x30);
  bcopy(default_lastline_action,mouse_action.lastline_map[0],0x30);
  w = 0;
  ppcVar1 = get_symbol(DisplayCharset,&w);
  p_Var2 = Strnew_charp(ppcVar1[0x2d]);
  mouse_action.lastline_str = p_Var2->ptr;
  pcVar3 = confFile("mouse");
  mf = (FILE *)fopen(pcVar3,"rt");
  if ((FILE *)mf != (FILE *)0x0) {
    interpret_mouse_action(mf);
    fclose((FILE *)mf);
  }
  pcVar3 = rcFile("mouse");
  mf = (FILE *)fopen(pcVar3,"rt");
  if ((FILE *)mf != (FILE *)0x0) {
    interpret_mouse_action(mf);
    fclose((FILE *)mf);
  }
  return;
}



int total_dot_number(char *p,char *ep,int max_count)

{
  size_t sVar1;
  int count;
  
  count = 0;
  if (ep == (char *)0x0) {
    sVar1 = strlen(p);
    ep = p + sVar1;
  }
  while ((p < ep && (count < max_count))) {
    if (*p == '.') {
      count = count + 1;
    }
    p = p + 1;
  }
  return count;
}



char * domain_match(char *host,char *domain)

{
  int iVar1;
  int iVar2;
  size_t sVar3;
  char *ep;
  size_t sVar4;
  char *domain_p;
  int offset;
  int m1;
  int m0;
  
  regexCompile("[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+",0);
  iVar1 = regexMatch(host,-1,1);
  iVar2 = regexMatch(domain,-1,1);
  if ((iVar1 == 0) || (iVar2 == 0)) {
    if (iVar1 != 0) {
      return (char *)0x0;
    }
    if (iVar2 != 0) {
      return (char *)0x0;
    }
    iVar1 = strcasecmp(domain,".");
    if ((iVar1 == 0) || (iVar1 = strcasecmp(domain,".local"), iVar1 == 0)) {
      sVar3 = strlen(host);
      ep = host + sVar3;
      if (domain[1] == '\0') {
        return ep;
      }
      iVar1 = total_dot_number(host,ep,1);
      host = ep;
    }
    else {
      if ((*domain == '.') && (iVar1 = strcasecmp(host,domain + 1), iVar1 == 0)) {
        return host;
      }
      if (*domain == '.') {
        sVar3 = strlen(host);
        sVar4 = strlen(domain);
        iVar1 = sVar3 - sVar4;
      }
      else {
        iVar1 = 0;
      }
      host = host + iVar1;
      if (iVar1 < 0) {
        return (char *)0x0;
      }
      iVar1 = strcasecmp(host,domain);
    }
  }
  else {
    iVar1 = strcasecmp(host,domain);
  }
  if (iVar1 != 0) {
    return (char *)0x0;
  }
  return host;
}



portlist * make_portlist(Str port)

{
  Str s;
  portlist *ppVar1;
  int iVar2;
  Str tmp;
  char *p;
  portlist *pl;
  portlist *first;
  
  first = (portlist *)0x0;
  s = Strnew();
  p = port->ptr;
  while( true ) {
    if (*p == '\0') {
      return first;
    }
    while ((*p != '\0' && ((MYCTYPE_MAP[(byte)*p] & 8) == 0))) {
      p = p + 1;
    }
    Strclear(s);
    while ((*p != '\0' && ((MYCTYPE_MAP[(byte)*p] & 8) != 0))) {
      if (s->area_size <= s->length + 1) {
        Strgrow(s);
      }
      iVar2 = s->length;
      s->ptr[iVar2] = *p;
      s->length = iVar2 + 1;
      p = p + 1;
      s->ptr[s->length] = '\0';
    }
    if (s->length == 0) break;
    ppVar1 = (portlist *)GC_malloc(8);
    iVar2 = atoi(s->ptr);
    ppVar1->port = (ushort)iVar2;
    ppVar1->next = first;
    first = ppVar1;
  }
  return first;
}



Str portlist2str(portlist *first)

{
  Str x;
  Str y;
  Str tmp;
  portlist *pl;
  
  x = Sprintf("%d",(uint)first->port);
  for (pl = first->next; pl != (portlist *)0x0; pl = pl->next) {
    y = Sprintf(", %d",(uint)pl->port);
    Strcat(x,y);
  }
  return x;
}



int port_match(portlist *first,int port)

{
  portlist *pl;
  
  pl = first;
  while( true ) {
    if (pl == (portlist *)0x0) {
      return 0;
    }
    if ((uint)pl->port == port) break;
    pl = pl->next;
  }
  return 1;
}



void check_expired_cookies(void)

{
  time_t tVar1;
  time_t now;
  cookie *p1;
  cookie *p;
  
  tVar1 = time((time_t *)0x0);
  if (First_cookie != (cookie *)0x0) {
    if ((First_cookie->expires != -1) && (First_cookie->expires < tVar1)) {
      if ((First_cookie->flag & 0x10U) == 0) {
        is_saved = 0;
      }
      First_cookie = First_cookie->next;
    }
    p = First_cookie;
    while ((p != (cookie *)0x0 && (p->next != (cookie *)0x0))) {
      p1 = p->next;
      if ((p1->expires != -1) && (p1->expires < tVar1)) {
        if ((p1->flag & 0x10U) == 0) {
          is_saved = 0;
        }
        p->next = p1->next;
        p1 = p;
      }
      p = p1;
    }
  }
  return;
}



Str make_cookie(cookie *cookie)

{
  int iVar1;
  Str x;
  Str tmp;
  
  x = Strdup(cookie->name);
  if (x->area_size <= x->length + 1) {
    Strgrow(x);
  }
  iVar1 = x->length;
  x->ptr[iVar1] = '=';
  x->length = iVar1 + 1;
  x->ptr[x->length] = '\0';
  Strcat(x,cookie->value);
  return x;
}



int match_cookie(ParsedURL *pu,cookie *cookie,char *domainname)

{
  int iVar1;
  char *pcVar2;
  
  if (domainname == (char *)0x0) {
    iVar1 = 0;
  }
  else {
    pcVar2 = domain_match(domainname,cookie->domain->ptr);
    if (pcVar2 == (char *)0x0) {
      iVar1 = 0;
    }
    else {
      iVar1 = strncmp(cookie->path->ptr,pu->file,cookie->path->length);
      if (iVar1 == 0) {
        if ((cookie->flag & 2U) == 0) {
          if ((cookie->portl != (portlist *)0x0) &&
             (iVar1 = port_match(cookie->portl,pu->port), iVar1 == 0)) {
            return 0;
          }
          iVar1 = 1;
        }
        else {
          iVar1 = 0;
        }
      }
      else {
        iVar1 = 0;
      }
    }
  }
  return iVar1;
}



cookie * get_cookie_info(Str domain,Str path,Str name)

{
  int iVar1;
  cookie *p;
  
  p = First_cookie;
  while( true ) {
    if (p == (cookie *)0x0) {
      return (cookie *)0x0;
    }
    iVar1 = strcasecmp(p->domain->ptr,domain->ptr);
    if (((iVar1 == 0) && (iVar1 = strcmp(p->path->ptr,path->ptr), iVar1 == 0)) &&
       (iVar1 = strcasecmp(p->name->ptr,name->ptr), iVar1 == 0)) break;
    p = p->next;
  }
  return p;
}



Str find_cookie(ParsedURL *pu)

{
  char *pcVar1;
  char *domainname_00;
  int iVar2;
  cookie *__dest;
  Str x;
  Str p_Var3;
  char *domainname;
  char *fq_domainname;
  int version;
  cookie *fco;
  cookie *p1;
  cookie *p;
  Str tmp;
  
  fco = (cookie *)0x0;
  version = 0;
  pcVar1 = FQDN(pu->host);
  check_expired_cookies();
  for (p = First_cookie; p != (cookie *)0x0; p = p->next) {
    domainname_00 = pcVar1;
    if (p->version != '\0') {
      domainname_00 = pu->host;
    }
    if (((p->flag & 1U) != 0) && (iVar2 = match_cookie(pu,p,domainname_00), iVar2 != 0)) {
      p1 = fco;
      while ((p1 != (cookie *)0x0 && (iVar2 = strcasecmp(p1->name->ptr,p->name->ptr), iVar2 != 0)))
      {
        p1 = p1->next;
      }
      if (p1 == (cookie *)0x0) {
        __dest = (cookie *)GC_malloc(0x50);
        bcopy(p,__dest,0x50);
        __dest->next = fco;
        fco = __dest;
        if (version < __dest->version) {
          version = (int)__dest->version;
        }
      }
    }
  }
  if (fco == (cookie *)0x0) {
    x = (Str)0x0;
  }
  else {
    x = Strnew();
    if (0 < version) {
      p_Var3 = Sprintf("$Version=\"%d\"; ",version);
      Strcat(x,p_Var3);
    }
    p_Var3 = make_cookie(fco);
    Strcat(x,p_Var3);
    for (p1 = fco->next; p1 != (cookie *)0x0; p1 = p1->next) {
      Strcat_charp(x,"; ");
      p_Var3 = make_cookie(p1);
      Strcat(x,p_Var3);
      if (0 < version) {
        if ((p1->flag & 8U) != 0) {
          p_Var3 = Sprintf("; $Path=\"%s\"",p1->path->ptr);
          Strcat(x,p_Var3);
        }
        if ((p1->flag & 4U) != 0) {
          p_Var3 = Sprintf("; $Domain=\"%s\"",p1->domain->ptr);
          Strcat(x,p_Var3);
        }
        if (p1->portl != (portlist *)0x0) {
          p_Var3 = portlist2str(p1->portl);
          p_Var3 = Sprintf("; $Port=\"%s\"",p_Var3);
          Strcat(x,p_Var3);
        }
      }
    }
  }
  return x;
}



int add_cookie(ParsedURL *pu,Str name,Str value,time_t expires,Str domain,Str path,int flag,
              Str comment,int version,Str port,Str commentURL)

{
  bool bVar1;
  Str p_Var2;
  Str p_Var3;
  char *__s1;
  int iVar4;
  size_t sVar5;
  char *ep;
  bool bVar6;
  int offset;
  int ok;
  char **sdomain;
  int n;
  char *dp;
  int use_security;
  portlist *portlist;
  Str opath;
  Str odomain;
  char *domainname;
  cookie *p;
  
  p_Var3 = path;
  p_Var2 = domain;
  if (version == 0) {
    __s1 = FQDN(pu->host);
  }
  else {
    __s1 = pu->host;
  }
  portlist = (portlist *)0x0;
  bVar6 = (flag & 0x20U) == 0;
  if (__s1 == (char *)0x0) {
    return 0x25;
  }
  if (domain != (Str)0x0) {
    if ((*domain->ptr != '.') &&
       ((0 < version || (iVar4 = strcasecmp(__s1,domain->ptr), iVar4 != 0)))) {
      domain = Sprintf(".%s",domain->ptr);
    }
    if (version == 0) {
      iVar4 = total_dot_number(domain->ptr,domain->ptr + domain->length,3);
      if (iVar4 < 2) {
        return 3;
      }
      if (iVar4 == 2) {
        bVar1 = false;
        for (sdomain = special_domain; (!bVar1 && (*sdomain != (char *)0x0)); sdomain = sdomain + 1)
        {
          iVar4 = domain->length;
          sVar5 = strlen(*sdomain);
          iVar4 = iVar4 - sVar5;
          if ((-1 < iVar4) && (iVar4 = strcasecmp(*sdomain,domain->ptr + iVar4), iVar4 == 0)) {
            bVar1 = true;
          }
        }
        if (!bVar1) {
          return 3;
        }
      }
    }
    else {
      iVar4 = strcasecmp(domain->ptr,".local");
      if (((iVar4 != 0) &&
          (iVar4 = total_dot_number(domain->ptr + 1,domain->ptr + domain->length,1), iVar4 == 0)) &&
         (bVar6)) {
        return 0x25;
      }
    }
    ep = domain_match(__s1,domain->ptr);
    if ((ep == (char *)0x0) && (bVar6)) {
      return 0x27;
    }
    if (((0 < version) && (iVar4 = total_dot_number(__s1,ep,1), iVar4 != 0)) && (bVar6)) {
      return 0x28;
    }
  }
  if (((path != (Str)0x0) && (0 < version)) &&
     (iVar4 = strncmp(path->ptr,pu->file,path->length), iVar4 != 0)) {
    return 4;
  }
  if (((port != (Str)0x0) && (portlist = make_portlist(port), portlist != (portlist *)0x0)) &&
     (iVar4 = port_match(portlist,pu->port), iVar4 == 0)) {
    return 9;
  }
  if (domain == (Str)0x0) {
    domain = Strnew_charp(__s1);
  }
  if (path == (Str)0x0) {
    path = Strnew_charp(pu->file);
    while ((0 < path->length && ((path->length < 1 || (path->ptr[path->length + -1] != '/'))))) {
      Strshrink(path,1);
    }
    if ((0 < path->length) && (path->ptr[path->length + -1] == '/')) {
      Strshrink(path,1);
    }
  }
  p = get_cookie_info(domain,path,name);
  if (p == (cookie *)0x0) {
    p = (cookie *)GC_malloc(0x50);
    p->flag = '\0';
    if (default_use_cookie != 0) {
      p->flag = p->flag | 1;
    }
    p->next = First_cookie;
    First_cookie = p;
  }
  copyParsedURL(&p->url,pu);
  p->name = name;
  p->value = value;
  p->expires = expires;
  p->domain = domain;
  p->path = path;
  p->comment = comment;
  p->version = (char)version;
  p->portl = portlist;
  p->commentURL = commentURL;
  if ((flag & 2U) == 0) {
    p->flag = p->flag & 0xfd;
  }
  else {
    p->flag = p->flag | 2;
  }
  if (p_Var2 == (Str)0x0) {
    p->flag = p->flag & 0xfb;
  }
  else {
    p->flag = p->flag | 4;
  }
  if (p_Var3 == (Str)0x0) {
    p->flag = p->flag & 0xf7;
  }
  else {
    p->flag = p->flag | 8;
  }
  if (((flag & 0x10U) == 0) && (p->expires != -1)) {
    p->flag = p->flag & 0xef;
    is_saved = 0;
  }
  else {
    p->flag = p->flag | 0x10;
  }
  check_expired_cookies();
  return 0;
}



cookie * nth_cookie(int n)

{
  int i;
  cookie *p;
  
  p = First_cookie;
  i = 0;
  while( true ) {
    if (p == (cookie *)0x0) {
      return (cookie *)0x0;
    }
    if (i == n) break;
    p = p->next;
    i = i + 1;
  }
  return p;
}



void save_cookies(void)

{
  char cVar1;
  char cVar2;
  char *pcVar3;
  char *pcVar4;
  time_t tVar5;
  char *pcVar6;
  char *pcVar7;
  char *__filename;
  FILE *__stream;
  Str p_Var8;
  char *pcVar9;
  char *pcVar10;
  char *local_48;
  FILE *fp;
  char *cookie_file;
  cookie *p;
  
  check_expired_cookies();
  if (((First_cookie != (cookie *)0x0) && (is_saved == 0)) && (no_rc_dir == 0)) {
    __filename = rcFile("cookie");
    __stream = fopen(__filename,"w");
    if (__stream != (FILE *)0x0) {
      for (p = First_cookie; p != (cookie *)0x0; p = p->next) {
        if (((p->flag & 1U) != 0) && ((p->flag & 0x10U) == 0)) {
          if (p->commentURL == (Str)0x0) {
            pcVar9 = "";
          }
          else {
            pcVar9 = p->commentURL->ptr;
          }
          if (p->portl == (portlist *)0x0) {
            pcVar10 = "";
          }
          else {
            p_Var8 = portlist2str(p->portl);
            pcVar10 = p_Var8->ptr;
          }
          if (p->comment == (Str)0x0) {
            local_48 = "";
          }
          else {
            local_48 = p->comment->ptr;
          }
          cVar1 = p->version;
          cVar2 = p->flag;
          pcVar3 = p->path->ptr;
          pcVar4 = p->domain->ptr;
          tVar5 = p->expires;
          pcVar6 = p->value->ptr;
          pcVar7 = p->name->ptr;
          p_Var8 = parsedURL2Str(&p->url);
          fprintf(__stream,"%s\t%s\t%s\t%ld\t%s\t%s\t%d\t%d\t%s\t%s\t%s\n",p_Var8->ptr,pcVar7,pcVar6
                  ,tVar5,pcVar4,pcVar3,(int)cVar2,(int)cVar1,local_48,pcVar10,pcVar9);
        }
      }
      fclose(__stream);
      chmod(__filename,0x180);
    }
  }
  return;
}



Str readcol(char **p)

{
  int iVar1;
  char *pcVar2;
  Str x;
  Str tmp;
  
  x = Strnew();
  while ((((**p != '\0' && (**p != '\n')) && (**p != '\r')) && (**p != '\t'))) {
    if (x->area_size <= x->length + 1) {
      Strgrow(x);
    }
    iVar1 = x->length;
    pcVar2 = *p;
    x->ptr[iVar1] = *pcVar2;
    x->length = iVar1 + 1;
    *p = pcVar2 + 1;
    x->ptr[x->length] = '\0';
  }
  if (**p == '\t') {
    *p = *p + 1;
  }
  return x;
}



void load_cookies(void)

{
  char *__filename;
  cookie *p_url;
  Str p_Var1;
  long lVar2;
  int iVar3;
  portlist *ppVar4;
  char *str;
  Str line;
  FILE *fp;
  cookie *p;
  cookie *cookie;
  
  __filename = rcFile("cookie");
  fp = (FILE *)fopen(__filename,"r");
  if ((FILE *)fp != (FILE *)0x0) {
    if (First_cookie == (cookie *)0x0) {
      p = (cookie *)0x0;
    }
    else {
      for (p = First_cookie; p->next != (cookie *)0x0; p = p->next) {
      }
    }
    while (line = Strfgets(fp), line->length != 0) {
      str = line->ptr;
      p_url = (cookie *)GC_malloc(0x50);
      p_url->next = (cookie *)0x0;
      p_url->flag = '\0';
      p_url->version = '\0';
      p_url->expires = -1;
      p_url->comment = (Str)0x0;
      p_url->portl = (portlist *)0x0;
      p_url->commentURL = (Str)0x0;
      cookie = p_url;
      p_Var1 = readcol(&str);
      parseURL(p_Var1->ptr,(ParsedURL *)p_url,(ParsedURL *)0x0);
      if (*str == '\0') {
        return;
      }
      p_Var1 = readcol(&str);
      cookie->name = p_Var1;
      if (*str == '\0') {
        return;
      }
      p_Var1 = readcol(&str);
      cookie->value = p_Var1;
      if (*str == '\0') {
        return;
      }
      p_Var1 = readcol(&str);
      lVar2 = atol(p_Var1->ptr);
      cookie->expires = lVar2;
      if (*str == '\0') {
        return;
      }
      p_Var1 = readcol(&str);
      cookie->domain = p_Var1;
      if (*str == '\0') {
        return;
      }
      p_Var1 = readcol(&str);
      cookie->path = p_Var1;
      if (*str == '\0') {
        return;
      }
      p_Var1 = readcol(&str);
      iVar3 = atoi(p_Var1->ptr);
      cookie->flag = (char)iVar3;
      if (*str == '\0') {
        return;
      }
      p_Var1 = readcol(&str);
      iVar3 = atoi(p_Var1->ptr);
      cookie->version = (char)iVar3;
      if (*str == '\0') {
        return;
      }
      p_Var1 = readcol(&str);
      cookie->comment = p_Var1;
      if (cookie->comment->length == 0) {
        cookie->comment = (Str)0x0;
      }
      if (*str == '\0') {
        return;
      }
      p_Var1 = readcol(&str);
      ppVar4 = make_portlist(p_Var1);
      cookie->portl = ppVar4;
      if (*str == '\0') {
        return;
      }
      p_Var1 = readcol(&str);
      cookie->commentURL = p_Var1;
      if (cookie->commentURL->length == 0) {
        cookie->commentURL = (Str)0x0;
      }
      if (p == (cookie *)0x0) {
        First_cookie = cookie;
      }
      else {
        p->next = cookie;
      }
      p = cookie;
    }
    fclose((FILE *)fp);
  }
  return;
}



void initCookie(void)

{
  load_cookies();
  check_expired_cookies();
  return;
}



Buffer * cookie_list_panel(void)

{
  int iVar1;
  Str x;
  Buffer *pBVar2;
  Str p_Var3;
  char *pcVar4;
  tm *__tp;
  char *pcVar5;
  int in_GS_OFFSET;
  char *tmp;
  int i;
  cookie *p;
  Str src;
  char tmp2 [80];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  x = Strnew_charp(
                  "<html><head><title>Cookies</title></head><body><center><b>Cookies</b></center><p><form method=internal action=cookie>"
                  );
  if ((use_cookie == 0) || (First_cookie == (cookie *)0x0)) {
    pBVar2 = (Buffer *)0x0;
  }
  else {
    Strcat_charp(x,"<ol>");
    i = 0;
    for (p = First_cookie; p != (cookie *)0x0; p = p->next) {
      p_Var3 = parsedURL2Str(&p->url);
      pcVar4 = html_quote(p_Var3->ptr);
      if (p->expires == -1) {
        tmp2[0] = '\0';
      }
      else {
        __tp = gmtime(&p->expires);
        strftime(tmp2,0x50,"%a, %d %b %Y %H:%M:%S GMT",__tp);
      }
      Strcat_charp(x,"<li>");
      Strcat_charp(x,"<h1><a href=\"");
      Strcat_charp(x,pcVar4);
      Strcat_charp(x,"\">");
      Strcat_charp(x,pcVar4);
      Strcat_charp(x,"</a></h1>");
      Strcat_charp(x,"<table cellpadding=0>");
      if ((p->flag & 2U) == 0) {
        Strcat_charp(x,"<tr><td width=\"80\"><b>Cookie:</b></td><td>");
        p_Var3 = make_cookie(p);
        pcVar4 = html_quote(p_Var3->ptr);
        Strcat_charp(x,pcVar4);
        Strcat_charp(x,"</td></tr>");
      }
      if (p->comment != (Str)0x0) {
        Strcat_charp(x,"<tr><td width=\"80\"><b>Comment:</b></td><td>");
        pcVar4 = html_quote(p->comment->ptr);
        Strcat_charp(x,pcVar4);
        Strcat_charp(x,"</td></tr>");
      }
      if (p->commentURL != (Str)0x0) {
        Strcat_charp(x,"<tr><td width=\"80\"><b>CommentURL:</b></td><td>");
        Strcat_charp(x,"<a href=\"");
        pcVar4 = html_quote(p->commentURL->ptr);
        Strcat_charp(x,pcVar4);
        Strcat_charp(x,"\">");
        pcVar4 = html_quote(p->commentURL->ptr);
        Strcat_charp(x,pcVar4);
        Strcat_charp(x,"</a>");
        Strcat_charp(x,"</td></tr>");
      }
      if (tmp2[0] != '\0') {
        Strcat_charp(x,"<tr><td width=\"80\"><b>Expires:</b></td><td>");
        Strcat_charp(x,tmp2);
        if ((p->flag & 0x10U) != 0) {
          Strcat_charp(x," (Discard)");
        }
        Strcat_charp(x,"</td></tr>");
      }
      Strcat_charp(x,"<tr><td width=\"80\"><b>Version:</b></td><td>");
      p_Var3 = Sprintf("%d",(int)p->version);
      Strcat_charp(x,p_Var3->ptr);
      Strcat_charp(x,"</td></tr><tr><td>");
      if (p->domain != (Str)0x0) {
        Strcat_charp(x,"<tr><td width=\"80\"><b>Domain:</b></td><td>");
        pcVar4 = html_quote(p->domain->ptr);
        Strcat_charp(x,pcVar4);
        Strcat_charp(x,"</td></tr>");
      }
      if (p->path != (Str)0x0) {
        Strcat_charp(x,"<tr><td width=\"80\"><b>Path:</b></td><td>");
        pcVar4 = html_quote(p->path->ptr);
        Strcat_charp(x,pcVar4);
        Strcat_charp(x,"</td></tr>");
      }
      if (p->portl != (portlist *)0x0) {
        Strcat_charp(x,"<tr><td width=\"80\"><b>Port:</b></td><td>");
        p_Var3 = portlist2str(p->portl);
        pcVar4 = html_quote(p_Var3->ptr);
        Strcat_charp(x,pcVar4);
        Strcat_charp(x,"</td></tr>");
      }
      Strcat_charp(x,"<tr><td width=\"80\"><b>Secure:</b></td><td>");
      if ((p->flag & 2U) == 0) {
        pcVar4 = "No";
      }
      else {
        pcVar4 = "Yes";
      }
      Strcat_charp(x,pcVar4);
      Strcat_charp(x,"</td></tr><tr><td>");
      if ((p->flag & 1U) == 0) {
        pcVar4 = " checked";
      }
      else {
        pcVar4 = "";
      }
      if ((p->flag & 1U) == 0) {
        pcVar5 = "";
      }
      else {
        pcVar5 = " checked";
      }
      p_Var3 = Sprintf("<tr><td width=\"80\"><b>Use:</b></td><td><input type=radio name=\"%d\" value=1%s>Yes&nbsp;&nbsp;<input type=radio name=\"%d\" value=0%s>No"
                       ,i,pcVar5,i,pcVar4);
      Strcat(x,p_Var3);
      Strcat_charp(x,"</td></tr><tr><td><input type=submit value=\"OK\"></table><p>");
      i = i + 1;
    }
    Strcat_charp(x,"</ol></form></body></html>");
    pBVar2 = loadHTMLString(x);
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return pBVar2;
}



void set_cookie_flag(parsed_tagarg *arg)

{
  int n_00;
  int iVar1;
  cookie *pcVar2;
  cookie *p;
  int v;
  int n;
  
  for (; arg != (parsed_tagarg *)0x0; arg = arg->next) {
    if ((((arg->arg != (char *)0x0) && (*arg->arg != '\0')) && (arg->value != (char *)0x0)) &&
       (*arg->value != '\0')) {
      n_00 = atoi(arg->arg);
      iVar1 = atoi(arg->value);
      pcVar2 = nth_cookie(n_00);
      if (pcVar2 != (cookie *)0x0) {
        if ((iVar1 == 0) || ((pcVar2->flag & 1U) != 0)) {
          if ((iVar1 == 0) && ((pcVar2->flag & 1U) != 0)) {
            pcVar2->flag = pcVar2->flag & 0xfe;
          }
        }
        else {
          pcVar2->flag = pcVar2->flag | 1;
        }
        if ((pcVar2->flag & 0x10U) == 0) {
          is_saved = 0;
        }
      }
    }
  }
  backBf();
  return;
}



int check_cookie_accept_domain(char *domain)

{
  int iVar1;
  char *pcVar2;
  TextListItem *tl;
  
  if (domain == (char *)0x0) {
    iVar1 = 0;
  }
  else {
    if ((Cookie_accept_domains != (TextList *)0x0) && (0 < Cookie_accept_domains->nitem)) {
      for (tl = Cookie_accept_domains->first; tl != (TextListItem *)0x0; tl = tl->next) {
        pcVar2 = domain_match(domain,tl->ptr);
        if (pcVar2 != (char *)0x0) {
          return 1;
        }
      }
    }
    if ((Cookie_reject_domains != (TextList *)0x0) && (0 < Cookie_reject_domains->nitem)) {
      for (tl = Cookie_reject_domains->first; tl != (TextListItem *)0x0; tl = tl->next) {
        pcVar2 = domain_match(domain,tl->ptr);
        if (pcVar2 != (char *)0x0) {
          return 0;
        }
      }
    }
    iVar1 = 1;
  }
  return iVar1;
}



Buffer * historyBuffer(Hist *hist)

{
  Str x;
  char *y;
  char *str;
  Buffer *pBVar1;
  char *q;
  char *p;
  HistItem *item;
  Str src;
  
  x = Strnew();
  Strcat_charp(x,"<html>\n<head><title>History Page</title></head>\n");
  Strcat_charp(x,"<body>\n<h1>History Page</h1>\n<hr>\n");
  Strcat_charp(x,"<ol>\n");
  if ((hist != (Hist *)0x0) && (hist->list != (HistList *)0x0)) {
    for (item = hist->list->last; item != (HistItem *)0x0; item = item->prev) {
      y = html_quote((char *)item->ptr);
      p = y;
      if (DecodeURL != 0) {
        str = url_unquote_conv((char *)item->ptr,0);
        p = html_quote(str);
      }
      Strcat_charp(x,"<li><a href=\"");
      Strcat_charp(x,y);
      Strcat_charp(x,"\">");
      Strcat_charp(x,p);
      Strcat_charp(x,"</a>\n");
    }
  }
  Strcat_charp(x,"</ol>\n</body>\n</html>");
  pBVar1 = loadHTMLString(x);
  return pBVar1;
}



void loadHistory(Hist *hist)

{
  char *pcVar1;
  FILE *__stream;
  Str s;
  int iVar2;
  Str line;
  FILE *f;
  
  if (hist != (Hist *)0x0) {
    pcVar1 = rcFile("history");
    __stream = fopen(pcVar1,"rt");
    if (__stream != (FILE *)0x0) {
      while (iVar2 = feof(__stream), iVar2 == 0) {
        s = Strfgets((FILE *)__stream);
        Strchop(s);
        Strremovefirstspaces(s);
        Strremovetrailingspaces(s);
        if (s->length != 0) {
          pcVar1 = url_quote(s->ptr);
          pushHist(hist,pcVar1);
        }
      }
      fclose(__stream);
    }
  }
  return;
}



void saveHistory(Hist *hist,size_t size)

{
  char *__filename;
  Str p_Var1;
  FILE *__stream;
  int iVar2;
  char *__new;
  char *tmpf;
  HistItem *item;
  FILE *f;
  
  if ((hist != (Hist *)0x0) && (hist->list != (HistList *)0x0)) {
    p_Var1 = tmpfname(0,(char *)0x0);
    __filename = p_Var1->ptr;
    __stream = fopen(__filename,"w");
    if (__stream == (FILE *)0x0) {
      disp_err_message("Can\'t open history",0);
    }
    else {
      item = hist->list->first;
      for (; (item != (HistItem *)0x0 && (size < (uint)(int)hist->list->nitem)); size = size + 1) {
        item = item->next;
      }
      for (; item != (HistItem *)0x0; item = item->next) {
        fprintf(__stream,"%s\n",item->ptr);
      }
      iVar2 = fclose(__stream);
      if (iVar2 == -1) {
        disp_err_message("Can\'t save history",0);
      }
      else {
        __new = rcFile("history");
        rename(__filename,__new);
      }
    }
  }
  return;
}



Hist * newHist(void)

{
  Hist *pHVar1;
  GeneralList *pGVar2;
  Hist *hist;
  
  pHVar1 = (Hist *)GC_malloc(0xc);
  pGVar2 = newGeneralList();
  pHVar1->list = pGVar2;
  pHVar1->current = (HistItem *)0x0;
  pHVar1->hash = (Hash_sv *)0x0;
  return pHVar1;
}



Hist * copyHist(Hist *hist)

{
  Hist *hist_00;
  HistItem *item;
  Hist *new;
  
  if (hist == (Hist *)0x0) {
    hist_00 = (Hist *)0x0;
  }
  else {
    hist_00 = newHist();
    for (item = hist->list->first; item != (HistItem *)0x0; item = item->next) {
      pushHist(hist_00,(char *)item->ptr);
    }
  }
  return hist_00;
}



HistItem * unshiftHist(Hist *hist,char *ptr)

{
  ListItem *n;
  HistItem *pHVar1;
  char *s;
  HistItem *item;
  
  if ((hist == (Hist *)0x0) || (hist->list == (HistList *)0x0)) {
    pHVar1 = (HistItem *)0x0;
  }
  else {
    n = hist->list->first;
    s = allocStr(ptr,-1);
    pHVar1 = newListItem(s,n,(ListItem *)0x0);
    if (hist->list->first == (ListItem *)0x0) {
      hist->list->last = pHVar1;
    }
    else {
      hist->list->first->prev = pHVar1;
    }
    hist->list->first = pHVar1;
    hist->list->nitem = hist->list->nitem + 1;
  }
  return pHVar1;
}



HistItem * pushHist(Hist *hist,char *ptr)

{
  ListItem *p;
  HistItem *pHVar1;
  char *s;
  HistItem *item;
  
  if ((hist == (Hist *)0x0) || (hist->list == (HistList *)0x0)) {
    pHVar1 = (HistItem *)0x0;
  }
  else {
    p = hist->list->last;
    s = allocStr(ptr,-1);
    pHVar1 = newListItem(s,(ListItem *)0x0,p);
    if (hist->list->last == (ListItem *)0x0) {
      hist->list->first = pHVar1;
    }
    else {
      hist->list->last->next = pHVar1;
    }
    hist->list->last = pHVar1;
    hist->list->nitem = hist->list->nitem + 1;
  }
  return pHVar1;
}



HistItem * pushHashHist(Hist *hist,char *ptr)

{
  HistItem *pHVar1;
  HistItem *item;
  
  if ((hist == (Hist *)0x0) || (hist->list == (HistList *)0x0)) {
    pHVar1 = (HistItem *)0x0;
  }
  else {
    pHVar1 = getHashHist(hist,ptr);
    if (pHVar1 != (HistItem *)0x0) {
      if (pHVar1->next == (_listitem *)0x0) {
        hist->list->last = pHVar1->prev;
      }
      else {
        pHVar1->next->prev = pHVar1->prev;
      }
      if (pHVar1->prev == (_listitem *)0x0) {
        hist->list->first = pHVar1->next;
      }
      else {
        pHVar1->prev->next = pHVar1->next;
      }
      hist->list->nitem = hist->list->nitem + -1;
    }
    pHVar1 = pushHist(hist,ptr);
    putHash_sv(hist->hash,ptr,pHVar1);
  }
  return pHVar1;
}



HistItem * getHashHist(Hist *hist,char *ptr)

{
  HistItem *pHVar1;
  Hash_sv *pHVar2;
  HistItem *item;
  
  if ((hist == (Hist *)0x0) || (hist->list == (HistList *)0x0)) {
    pHVar1 = (HistItem *)0x0;
  }
  else {
    if (hist->hash == (Hash_sv *)0x0) {
      pHVar2 = newHash_sv(0x7f);
      hist->hash = pHVar2;
      for (item = hist->list->first; item != (HistItem *)0x0; item = item->next) {
        putHash_sv(hist->hash,(char *)item->ptr,item);
      }
    }
    pHVar1 = (HistItem *)getHash_sv(hist->hash,ptr,(void *)0x0);
  }
  return pHVar1;
}



char * lastHist(Hist *hist)

{
  char *pcVar1;
  
  if ((hist == (Hist *)0x0) || (hist->list == (HistList *)0x0)) {
    pcVar1 = (char *)0x0;
  }
  else if (hist->list->last == (ListItem *)0x0) {
    pcVar1 = (char *)0x0;
  }
  else {
    hist->current = hist->list->last;
    pcVar1 = (char *)hist->current->ptr;
  }
  return pcVar1;
}



char * nextHist(Hist *hist)

{
  char *pcVar1;
  
  if ((hist == (Hist *)0x0) || (hist->list == (HistList *)0x0)) {
    pcVar1 = (char *)0x0;
  }
  else if ((hist->current == (HistItem *)0x0) || (hist->current->next == (_listitem *)0x0)) {
    pcVar1 = (char *)0x0;
  }
  else {
    hist->current = hist->current->next;
    pcVar1 = (char *)hist->current->ptr;
  }
  return pcVar1;
}



char * prevHist(Hist *hist)

{
  char *pcVar1;
  
  if ((hist == (Hist *)0x0) || (hist->list == (HistList *)0x0)) {
    pcVar1 = (char *)0x0;
  }
  else if ((hist->current == (HistItem *)0x0) || (hist->current->prev == (_listitem *)0x0)) {
    pcVar1 = (char *)0x0;
  }
  else {
    hist->current = hist->current->prev;
    pcVar1 = (char *)hist->current->ptr;
  }
  return pcVar1;
}



void print_headers(Buffer *buf,int len)

{
  Str p_Var1;
  char *pcVar2;
  TextListItem *tp;
  
  if (buf->document_header != (TextList *)0x0) {
    for (tp = buf->document_header->first; tp != (TextListItem *)0x0; tp = tp->next) {
      puts(tp->ptr);
    }
  }
  p_Var1 = parsedURL2Str(&buf->currentURL);
  printf("w3m-current-url: %s\n",p_Var1->ptr);
  if (buf->baseURL != (ParsedURL *)0x0) {
    p_Var1 = parsedURL2Str(buf->baseURL);
    printf("w3m-base-url: %s\n",p_Var1->ptr);
  }
  printf("w3m-content-type: %s\n",buf->type);
  if (buf->document_charset != 0) {
    pcVar2 = wc_ces_to_charset(buf->document_charset);
    printf("w3m-content-charset: %s\n",pcVar2);
  }
  if (0 < len) {
    printf("w3m-content-length: %d\n",len);
  }
  return;
}



void internal_get(char *url,int flag,FormList *request)

{
  TextLine *pTVar1;
  Buffer *buf_00;
  int iVar2;
  Str p_Var3;
  char *pcVar4;
  Str p_Var5;
  int len_1;
  Line *lp;
  int len;
  Str last;
  Str first;
  TextLineListItem *p;
  Buffer *buf;
  
  backend_halfdump_buf = (TextLineList *)0x0;
  do_download = flag;
  buf_00 = loadGeneralFile(url,(ParsedURL *)0x0,(char *)0xffffffff,0,request);
  do_download = 0;
  if ((buf_00 != (Buffer *)0x0) && (buf_00 != (Buffer *)0x1)) {
    iVar2 = is_html_type(buf_00->type);
    if ((iVar2 == 0) || (backend_halfdump_buf == (TextLineList *)0x0)) {
      iVar2 = strcasecmp(buf_00->type,"text/plain");
      if (iVar2 == 0) {
        len_1 = 0;
        for (lp = buf_00->firstLine; lp != (Line *)0x0; lp = lp->next) {
          len_1 = len_1 + lp->len;
          if (lp->lineBuf[lp->len + -1] != '\n') {
            len_1 = len_1 + 1;
          }
        }
        print_headers(buf_00,len_1);
        putchar(10);
        saveBuffer(buf_00,stdout,1);
      }
      else {
        print_headers(buf_00,0);
      }
    }
    else {
      len = 0;
      for (p = backend_halfdump_buf->first; p != (TextLineListItem *)0x0; p = p->next) {
        pTVar1 = p->ptr;
        if (ExtHalfdump == '\0') {
          p_Var3 = p->ptr->line;
        }
        else {
          p_Var3 = wc_Str_conv(p->ptr->line,InnerCharset,DisplayCharset);
        }
        pTVar1->line = p_Var3;
        len = len + p->ptr->line->length + 1;
      }
      p_Var3 = Strnew_charp("<pre>\n");
      pcVar4 = html_quote(buf_00->buffername);
      p_Var5 = Strnew_m_charp("</pre><title>",pcVar4,"</title>\n",0);
      print_headers(buf_00,p_Var3->length + len + p_Var5->length);
      putchar(10);
      printf("%s",p_Var3->ptr);
      for (p = backend_halfdump_buf->first; p != (TextLineListItem *)0x0; p = p->next) {
        puts(p->ptr->line->ptr);
      }
      printf("%s",p_Var5->ptr);
    }
  }
  return;
}



void get(TextList *argv)

{
  int iVar1;
  char *__s1;
  int flag;
  char *url;
  char *p;
  
  url = (char *)0x0;
  flag = 0;
  __s1 = url;
  while (url = __s1, __s1 = (char *)popValue((GeneralList *)argv), __s1 != (char *)0x0) {
    iVar1 = strcasecmp(__s1,"-download_only");
    if (iVar1 == 0) {
      flag = 1;
      __s1 = url;
    }
  }
  if (url != (char *)0x0) {
    internal_get(url,flag,(FormList *)0x0);
  }
  return;
}



void post(TextList *argv)

{
  int iVar1;
  char *pcVar2;
  form_list *request_00;
  int length;
  int flag;
  char *url;
  char *boundary;
  char *body;
  char *enctype;
  char *charset;
  char *target;
  char *p;
  FormList *request;
  
  target = (char *)0x0;
  charset = (char *)0x0;
  enctype = (char *)0x0;
  body = (char *)0x0;
  boundary = (char *)0x0;
  url = (char *)0x0;
  flag = 0;
  length = 0;
  pcVar2 = url;
  while (url = pcVar2, pcVar2 = (char *)popValue((GeneralList *)argv), pcVar2 != (char *)0x0) {
    iVar1 = strcasecmp(pcVar2,"-download_only");
    if (iVar1 == 0) {
      flag = 1;
      pcVar2 = url;
    }
    else {
      iVar1 = strcasecmp(pcVar2,"-target");
      if (iVar1 == 0) {
        target = (char *)popValue((GeneralList *)argv);
        pcVar2 = url;
      }
      else {
        iVar1 = strcasecmp(pcVar2,"-charset");
        if (iVar1 == 0) {
          charset = (char *)popValue((GeneralList *)argv);
          pcVar2 = url;
        }
        else {
          iVar1 = strcasecmp(pcVar2,"-enctype");
          if (iVar1 == 0) {
            enctype = (char *)popValue((GeneralList *)argv);
            pcVar2 = url;
          }
          else {
            iVar1 = strcasecmp(pcVar2,"-body");
            if (iVar1 == 0) {
              body = (char *)popValue((GeneralList *)argv);
              pcVar2 = url;
            }
            else {
              iVar1 = strcasecmp(pcVar2,"-boundary");
              if (iVar1 == 0) {
                boundary = (char *)popValue((GeneralList *)argv);
                pcVar2 = url;
              }
              else {
                iVar1 = strcasecmp(pcVar2,"-length");
                if (iVar1 == 0) {
                  pcVar2 = (char *)popValue((GeneralList *)argv);
                  length = atol(pcVar2);
                  pcVar2 = url;
                }
              }
            }
          }
        }
      }
    }
  }
  if (url != (char *)0x0) {
    request_00 = newFormList((char *)0x0,"post",charset,enctype,target,(char *)0x0,(form_list *)0x0)
    ;
    request_00->body = body;
    request_00->boundary = boundary;
    if (length < 1) {
      if (body == (char *)0x0) {
        length = 0;
      }
      else {
        length = strlen(body);
      }
    }
    request_00->length = length;
    internal_get(url,flag,request_00);
  }
  return;
}



void set(TextList *argv)

{
  int iVar1;
  int i;
  
  if (1 < argv->nitem) {
    for (i = 0; variable_table[i].name != (char *)0x0; i = i + 1) {
      iVar1 = strcasecmp(variable_table[i].name,argv->first->ptr);
      if (iVar1 == 0) {
        popValue((GeneralList *)argv);
        if (variable_table[i].set_func == (anon_subr_void_TextList_ptr_for_set_func *)0x0) {
          return;
        }
        (*variable_table[i].set_func)(argv);
        return;
      }
    }
  }
  return;
}



void show(TextList *argv)

{
  int iVar1;
  int i;
  
  if (0 < argv->nitem) {
    for (i = 0; variable_table[i].name != (char *)0x0; i = i + 1) {
      iVar1 = strcasecmp(variable_table[i].name,argv->first->ptr);
      if (iVar1 == 0) {
        popValue((GeneralList *)argv);
        if (variable_table[i].show_func == (anon_subr_void_TextList_ptr_for_show_func *)0x0) {
          return;
        }
        (*variable_table[i].show_func)(argv);
        return;
      }
    }
  }
  return;
}



void quit(TextList *argv)

{
  save_cookies();
  w3m_exit(0);
  return;
}



void help(TextList *argv)

{
  int i;
  
  for (i = 0; command_table[i].name != (char *)0x0; i = i + 1) {
    printf("%s %s\n    %s\n",command_table[i].name,command_table[i].option_string,
           command_table[i].help);
  }
  return;
}



void set_column(TextList *argv)

{
  if (argv->nitem == 1) {
    COLS = atol(argv->first->ptr);
  }
  return;
}



void show_column(TextList *argv)

{
  fprintf(stdout,"column=%d\n",COLS);
  return;
}



void call_command_function(char *str)

{
  TextList *tl;
  int iVar1;
  TextList *argv;
  int i;
  
  tl = split(str);
  if (0 < tl->nitem) {
    for (i = 0; command_table[i].name != (char *)0x0; i = i + 1) {
      iVar1 = strcasecmp(command_table[i].name,tl->first->ptr);
      if (iVar1 == 0) {
        popValue((GeneralList *)tl);
        if (command_table[i].func == (anon_subr_void_TextList_ptr_for_func *)0x0) {
          return;
        }
        (*command_table[i].func)(tl);
        return;
      }
    }
  }
  return;
}



int backend(void)

{
  char *pcVar1;
  char *str;
  
  w3m_dump = 0;
  if (COLS == 0) {
    COLS = 0x50;
  }
  use_mouse = 0;
  if (backend_batch_commands == (TextList *)0x0) {
    while (pcVar1 = readline("w3m> "), pcVar1 != (char *)0x0) {
      call_command_function(pcVar1);
    }
  }
  else {
    while (pcVar1 = (char *)popValue((GeneralList *)backend_batch_commands), pcVar1 != (char *)0x0)
    {
      call_command_function(pcVar1);
    }
  }
  quit((TextList *)0x0);
  return 0;
}



char * readline(char *prompt)

{
  Str p_Var1;
  int iVar2;
  char *pcVar3;
  Str s;
  
  fputs(prompt,stdout);
  fflush(stdout);
  p_Var1 = Strfgets((FILE *)stdin);
  iVar2 = feof(stdin);
  if ((iVar2 == 0) || (*p_Var1->ptr != '\0')) {
    pcVar3 = p_Var1->ptr;
  }
  else {
    pcVar3 = (char *)0x0;
  }
  return pcVar3;
}



TextList * split(char *p)

{
  char cVar1;
  bool bVar2;
  bool bVar3;
  TextList *tl;
  int iVar4;
  char *pcVar5;
  TextList *tp;
  Str s;
  int in_single_quote;
  int in_double_quote;
  
  bVar3 = false;
  bVar2 = false;
  s = Strnew();
  tl = (TextList *)newGeneralList();
  for (; *p != '\0'; p = p + 1) {
    iVar4 = (int)*p;
    if (iVar4 < 0xe) {
      if ((iVar4 < 0xc) && (1 < iVar4 - 9U)) goto LAB_080acccb;
LAB_080acc32:
      if ((bVar3) || (bVar2)) {
        if (s->area_size <= s->length + 1) {
          Strgrow(s);
        }
        iVar4 = s->length;
        s->ptr[iVar4] = *p;
        s->length = iVar4 + 1;
        s->ptr[s->length] = '\0';
      }
      else if (0 < s->length) {
        pcVar5 = allocStr(s->ptr,-1);
        pushValue((GeneralList *)tl,pcVar5);
        s = Strnew();
      }
    }
    else if (iVar4 == 0x22) {
      if (bVar2) {
        if (s->area_size <= s->length + 1) {
          Strgrow(s);
        }
        iVar4 = s->length;
        s->ptr[iVar4] = '\"';
        s->length = iVar4 + 1;
        s->ptr[s->length] = '\0';
      }
      else {
        bVar3 = !bVar3;
      }
    }
    else if (iVar4 < 0x23) {
      if (iVar4 == 0x20) goto LAB_080acc32;
LAB_080acccb:
      if (s->area_size <= s->length + 1) {
        Strgrow(s);
      }
      iVar4 = s->length;
      s->ptr[iVar4] = *p;
      s->length = iVar4 + 1;
      s->ptr[s->length] = '\0';
    }
    else if (iVar4 == 0x27) {
      if (bVar3) {
        if (s->area_size <= s->length + 1) {
          Strgrow(s);
        }
        iVar4 = s->length;
        s->ptr[iVar4] = '\'';
        s->length = iVar4 + 1;
        s->ptr[s->length] = '\0';
      }
      else {
        bVar2 = !bVar2;
      }
    }
    else {
      if (iVar4 != 0x5c) goto LAB_080acccb;
      if (bVar2) {
        if (s->area_size <= s->length + 1) {
          Strgrow(s);
        }
        iVar4 = s->length;
        s->ptr[iVar4] = *p;
        s->length = iVar4 + 1;
        s->ptr[s->length] = '\0';
      }
      else {
        p = p + 1;
        cVar1 = *p;
        if (cVar1 == 'n') {
          if (s->area_size <= s->length + 1) {
            Strgrow(s);
          }
          iVar4 = s->length;
          s->ptr[iVar4] = '\n';
          s->length = iVar4 + 1;
          s->ptr[s->length] = '\0';
        }
        else if (cVar1 < 'o') {
          if (cVar1 == '\0') break;
          if (cVar1 == 'f') {
            if (s->area_size <= s->length + 1) {
              Strgrow(s);
            }
            iVar4 = s->length;
            s->ptr[iVar4] = '\f';
            s->length = iVar4 + 1;
            s->ptr[s->length] = '\0';
          }
          else {
LAB_080acb85:
            if (s->area_size <= s->length + 1) {
              Strgrow(s);
            }
            iVar4 = s->length;
            s->ptr[iVar4] = *p;
            s->length = iVar4 + 1;
            s->ptr[s->length] = '\0';
          }
        }
        else if (cVar1 == 'r') {
          if (s->area_size <= s->length + 1) {
            Strgrow(s);
          }
          iVar4 = s->length;
          s->ptr[iVar4] = '\r';
          s->length = iVar4 + 1;
          s->ptr[s->length] = '\0';
        }
        else {
          if (cVar1 != 't') goto LAB_080acb85;
          if (s->area_size <= s->length + 1) {
            Strgrow(s);
          }
          iVar4 = s->length;
          s->ptr[iVar4] = '\t';
          s->length = iVar4 + 1;
          s->ptr[s->length] = '\0';
        }
      }
    }
  }
  if (0 < s->length) {
    pcVar5 = allocStr(s->ptr,-1);
    pushValue((GeneralList *)tl,pcVar5);
  }
  return tl;
}



AnchorList *
putAnchor(AnchorList *al,char *url,char *target,Anchor **anchor_return,char *referer,char *title,
         uchar key,int line,int pos)

{
  Anchor *pAVar1;
  char cVar2;
  Anchor *pAVar3;
  int iVar4;
  BufferPoint bp;
  Anchor *a;
  int j;
  int i;
  int n;
  
  if (al == (AnchorList *)0x0) {
    al = (AnchorList *)GC_malloc(0x10);
    al->anchors = (Anchor *)0x0;
    al->anchormax = 0;
    al->nanchor = al->anchormax;
    al->acache = -1;
  }
  if (al->anchormax == 0) {
    pAVar3 = (Anchor *)GC_malloc(0x708);
    al->anchors = pAVar3;
    al->anchormax = 0x1e;
  }
  if (al->nanchor == al->anchormax) {
    al->anchormax = al->anchormax * 2;
    pAVar3 = (Anchor *)GC_realloc(al->anchors,al->anchormax * 0x3c);
    al->anchors = pAVar3;
  }
  j = al->nanchor;
  i = j;
  if (j != 0) {
    if (al->anchors[j + -1].start.line == line) {
      iVar4 = al->anchors[j + -1].start.pos - pos;
    }
    else {
      iVar4 = al->anchors[j + -1].start.line - line;
    }
    if (-1 < iVar4) {
      for (i = 0; i < j; i = i + 1) {
        if (al->anchors[i].start.line == line) {
          cVar2 = (char)((uint)(al->anchors[i].start.pos - pos) >> 0x18);
        }
        else {
          cVar2 = (char)((uint)(al->anchors[i].start.line - line) >> 0x18);
        }
        if (-1 < cVar2) goto LAB_080acff5;
      }
    }
  }
LAB_080ad013:
  pAVar3 = al->anchors + i;
  pAVar3->url = url;
  pAVar3->target = target;
  pAVar3->referer = referer;
  pAVar3->title = title;
  pAVar3->accesskey = key;
  pAVar3->slave = '\0';
  (pAVar3->start).line = line;
  (pAVar3->start).pos = pos;
  (pAVar3->start).invalid = bp.invalid;
  (pAVar3->end).line = line;
  (pAVar3->end).pos = pos;
  (pAVar3->end).invalid = bp.invalid;
  al->nanchor = al->nanchor + 1;
  if (anchor_return != (Anchor **)0x0) {
    *anchor_return = pAVar3;
  }
  return al;
LAB_080acff5:
  for (; i < j; j = j + -1) {
    pAVar3 = al->anchors + j;
    pAVar1 = al->anchors + j + -1;
    pAVar3->url = pAVar1->url;
    pAVar3->target = pAVar1->target;
    pAVar3->referer = pAVar1->referer;
    pAVar3->title = pAVar1->title;
    *(undefined4 *)&pAVar3->accesskey = *(undefined4 *)&pAVar1->accesskey;
    (pAVar3->start).line = (pAVar1->start).line;
    (pAVar3->start).pos = (pAVar1->start).pos;
    (pAVar3->start).invalid = (pAVar1->start).invalid;
    (pAVar3->end).line = (pAVar1->end).line;
    (pAVar3->end).pos = (pAVar1->end).pos;
    (pAVar3->end).invalid = (pAVar1->end).invalid;
    pAVar3->hseq = pAVar1->hseq;
    *(undefined4 *)&pAVar3->slave = *(undefined4 *)&pAVar1->slave;
    *(undefined4 *)&pAVar3->rows = *(undefined4 *)&pAVar1->rows;
    pAVar3->image = pAVar1->image;
  }
  goto LAB_080ad013;
}



Anchor * registerHref(Buffer *buf,char *url,char *target,char *referer,char *title,uchar key,
                     int line,int pos)

{
  AnchorList *pAVar1;
  Anchor *a;
  
  pAVar1 = putAnchor(buf->href,url,target,&a,referer,title,key,line,pos);
  buf->href = pAVar1;
  return a;
}



Anchor * registerName(Buffer *buf,char *url,int line,int pos)

{
  AnchorList *pAVar1;
  Anchor *a;
  
  pAVar1 = putAnchor(buf->name,url,(char *)0x0,&a,(char *)0x0,(char *)0x0,'\0',line,pos);
  buf->name = pAVar1;
  return a;
}



Anchor * registerImg(Buffer *buf,char *url,char *title,int line,int pos)

{
  AnchorList *pAVar1;
  Anchor *a;
  
  pAVar1 = putAnchor(buf->img,url,(char *)0x0,&a,(char *)0x0,title,'\0',line,pos);
  buf->img = pAVar1;
  return a;
}



Anchor * registerForm(Buffer *buf,FormList *flist,parsed_tag *tag,int line,int pos)

{
  form_item_list *url;
  AnchorList *pAVar1;
  FormItemList *fi;
  Anchor *a;
  
  url = formList_addInput(flist,tag);
  if (url == (form_item_list *)0x0) {
    a = (Anchor *)0x0;
  }
  else {
    pAVar1 = putAnchor(buf->formitem,(char *)url,flist->target,&a,(char *)0x0,(char *)0x0,'\0',line,
                       pos);
    buf->formitem = pAVar1;
  }
  return a;
}



int onAnchor(Anchor *a,int line,int pos)

{
  bool bVar1;
  char cVar2;
  int iVar3;
  BufferPoint bp;
  
  if (line == (a->start).line) {
    cVar2 = (char)((uint)(pos - (a->start).pos) >> 0x18);
  }
  else {
    cVar2 = (char)((uint)(line - (a->start).line) >> 0x18);
  }
  if (cVar2 < '\0') {
    iVar3 = -1;
  }
  else {
    if ((a->end).line == line) {
      iVar3 = (a->end).pos;
      bVar1 = iVar3 == pos || iVar3 - pos < 0;
    }
    else {
      iVar3 = (a->end).line;
      bVar1 = iVar3 == line || iVar3 - line < 0;
    }
    if (bVar1) {
      iVar3 = 1;
    }
    else {
      iVar3 = 0;
    }
  }
  return iVar3;
}



Anchor * retrieveAnchor(AnchorList *al,int line,int pos)

{
  Anchor *pAVar1;
  int iVar2;
  int iVar3;
  int cmp;
  size_t e;
  size_t b;
  Anchor *a;
  
  if ((al != (AnchorList *)0x0) && (al->nanchor != 0)) {
    if ((al->acache < 0) || (al->nanchor <= al->acache)) {
      al->acache = 0;
    }
    b = 0;
    e = al->nanchor - 1;
    while (b <= e) {
      pAVar1 = al->anchors;
      iVar2 = al->acache;
      iVar3 = onAnchor(pAVar1 + iVar2,line,pos);
      if (iVar3 == 0) {
        return pAVar1 + iVar2;
      }
      if (iVar3 < 1) {
        if (al->acache == 0) {
          return (Anchor *)0x0;
        }
        e = al->acache - 1;
      }
      else {
        b = al->acache + 1;
      }
      al->acache = b + e >> 1;
    }
  }
  return (Anchor *)0x0;
}



Anchor * retrieveCurrentAnchor(Buffer *buf)

{
  Anchor *pAVar1;
  
  if (buf->currentLine == (Line *)0x0) {
    pAVar1 = (Anchor *)0x0;
  }
  else {
    pAVar1 = retrieveAnchor(buf->href,buf->currentLine->linenumber,buf->pos);
  }
  return pAVar1;
}



Anchor * retrieveCurrentImg(Buffer *buf)

{
  Anchor *pAVar1;
  
  if (buf->currentLine == (Line *)0x0) {
    pAVar1 = (Anchor *)0x0;
  }
  else {
    pAVar1 = retrieveAnchor(buf->img,buf->currentLine->linenumber,buf->pos);
  }
  return pAVar1;
}



Anchor * retrieveCurrentForm(Buffer *buf)

{
  Anchor *pAVar1;
  
  if (buf->currentLine == (Line *)0x0) {
    pAVar1 = (Anchor *)0x0;
  }
  else {
    pAVar1 = retrieveAnchor(buf->formitem,buf->currentLine->linenumber,buf->pos);
  }
  return pAVar1;
}



Anchor * searchAnchor(AnchorList *al,char *str)

{
  Anchor *pAVar1;
  int iVar2;
  Anchor *a;
  int i;
  
  if (al != (AnchorList *)0x0) {
    for (i = 0; i < al->nanchor; i = i + 1) {
      pAVar1 = al->anchors + i;
      if ((-1 < pAVar1->hseq) && (iVar2 = strcmp(pAVar1->url,str), iVar2 == 0)) {
        return pAVar1;
      }
    }
  }
  return (Anchor *)0x0;
}



Anchor * searchURLLabel(Buffer *buf,char *url)

{
  Anchor *pAVar1;
  
  pAVar1 = searchAnchor(buf->name,url);
  return pAVar1;
}



Anchor * _put_anchor_news(Buffer *buf,char *p1,char *p2,int line,int pos)

{
  wc_ces t_ces;
  wc_ces f_ces;
  Str p_Var1;
  char *pcVar2;
  Anchor *pAVar3;
  Str tmp;
  
  f_ces = InnerCharset;
  if ((*p1 == '<') && (p1 = p1 + 1, p2[-1] == '>')) {
    p2 = p2 + -1;
  }
  t_ces = buf->document_charset;
  p_Var1 = Strnew_charp_n(p1,(int)p2 - (int)p1);
  p_Var1 = wc_Str_conv_strict(p_Var1,f_ces,t_ces);
  pcVar2 = file_quote(p_Var1->ptr);
  p_Var1 = Sprintf("news:%s",pcVar2);
  pAVar3 = registerHref(buf,p_Var1->ptr,(char *)0x0,(char *)0xffffffff,(char *)0x0,'\0',line,pos);
  return pAVar3;
}



Anchor * _put_anchor_all(Buffer *buf,char *p1,char *p2,int line,int pos)

{
  wc_ces t_ces;
  wc_ces f_ces;
  Str p_Var1;
  char *url;
  Anchor *pAVar2;
  Str tmp;
  
  f_ces = InnerCharset;
  t_ces = buf->document_charset;
  p_Var1 = Strnew_charp_n(p1,(int)p2 - (int)p1);
  p_Var1 = wc_Str_conv_strict(p_Var1,f_ces,t_ces);
  url = url_quote(p_Var1->ptr);
  pAVar2 = registerHref(buf,url,(char *)0x0,(char *)0xffffffff,(char *)0x0,'\0',line,pos);
  return pAVar2;
}



void reseq_anchor0(AnchorList *al,short *seqmap)

{
  Anchor *pAVar1;
  Anchor *a;
  int i;
  
  if (al != (AnchorList *)0x0) {
    for (i = 0; i < al->nanchor; i = i + 1) {
      pAVar1 = al->anchors;
      if (-1 < pAVar1[i].hseq) {
        pAVar1[i].hseq = (int)seqmap[pAVar1[i].hseq];
      }
    }
  }
  return;
}



void reseq_anchor(Buffer *buf)

{
  Anchor *pAVar1;
  int iVar2;
  short *seqmap_00;
  Anchor *pAVar3;
  HmarkerList *ml;
  Anchor *a1;
  Anchor *a;
  short *seqmap;
  int nmark;
  int n;
  int j;
  int i;
  
  if (buf->hmarklist == (HmarkerList *)0x0) {
    iVar2 = 0;
  }
  else {
    iVar2 = buf->hmarklist->nmark;
  }
  ml = (HmarkerList *)0x0;
  if (buf->href != (AnchorList *)0x0) {
    n = iVar2;
    for (i = 0; i < buf->href->nanchor; i = i + 1) {
      if (buf->href->anchors[i].hseq == -2) {
        n = n + 1;
      }
    }
    if (n != iVar2) {
      seqmap_00 = (short *)GC_malloc_atomic(n * 2);
      for (i = 0; i < n; i = i + 1) {
        seqmap_00[i] = (short)i;
      }
      n = iVar2;
      for (i = 0; i < buf->href->nanchor; i = i + 1) {
        pAVar1 = buf->href->anchors;
        if (pAVar1[i].hseq == -2) {
          pAVar1[i].hseq = n;
          pAVar3 = closest_next_anchor(buf->href,(Anchor *)0x0,pAVar1[i].start.pos,
                                       pAVar1[i].start.line);
          pAVar3 = closest_next_anchor(buf->formitem,pAVar3,pAVar1[i].start.pos,pAVar1[i].start.line
                                      );
          if ((pAVar3 != (Anchor *)0x0) && (-1 < pAVar3->hseq)) {
            seqmap_00[n] = seqmap_00[pAVar3->hseq];
            for (j = pAVar3->hseq; j < iVar2; j = j + 1) {
              seqmap_00[j] = seqmap_00[j] + 1;
            }
          }
          ml = putHmarker(ml,pAVar1[i].start.line,pAVar1[i].start.pos,(int)seqmap_00[n]);
          n = n + 1;
        }
      }
      for (i = 0; i < iVar2; i = i + 1) {
        ml = putHmarker(ml,buf->hmarklist->marks[i].line,buf->hmarklist->marks[i].pos,
                        (int)seqmap_00[i]);
      }
      buf->hmarklist = ml;
      reseq_anchor0(buf->href,seqmap_00);
      reseq_anchor0(buf->formitem,seqmap_00);
    }
  }
  return;
}



char * reAnchorPos(Buffer *buf,Line *l,char *p1,char *p2,
                  anon_subr_Anchor_ptr_Buffer_ptr_char_ptr_char_ptr_int_int *anchorproc)

{
  int iVar1;
  Anchor *pAVar2;
  int hseq;
  int i;
  int epos;
  int spos;
  Anchor *a;
  
  hseq = -2;
  spos = (int)p1 - (int)l->lineBuf;
  epos = (int)p2 - (int)l->lineBuf;
  i = spos;
  while( true ) {
    iVar1 = spos;
    if (epos <= i) {
      while (i = iVar1, i < epos) {
        l->propBuf[i] = l->propBuf[i] | 0x10;
        iVar1 = i + 1;
      }
      while (((l->len < spos && (l->next != (_Line *)0x0)) && (l->next->bpos != 0))) {
        spos = spos - l->len;
        epos = epos - l->len;
        l = l->next;
      }
      while( true ) {
        pAVar2 = (*anchorproc)(buf,p1,p2,l->linenumber,spos);
        pAVar2->hseq = hseq;
        if (hseq == -2) {
          reseq_anchor(buf);
          hseq = pAVar2->hseq;
        }
        (pAVar2->end).line = l->linenumber;
        if (((epos <= l->len) || (l->next == (_Line *)0x0)) || (l->next->bpos == 0)) break;
        (pAVar2->end).pos = l->len;
        spos = 0;
        epos = epos - l->len;
        l = l->next;
      }
      (pAVar2->end).pos = epos;
      return p2;
    }
    if ((l->propBuf[i] & 0x50) != 0) break;
    i = i + 1;
  }
  return p2;
}



void reAnchorWord(Buffer *buf,Line *l,int spos,int epos)

{
  reAnchorPos(buf,l,l->lineBuf + spos,l->lineBuf + epos,_put_anchor_all);
  return;
}



char * reAnchorAny(Buffer *buf,char *re,
                  anon_subr_Anchor_ptr_Buffer_ptr_char_ptr_char_ptr_int_int *anchorproc)

{
  char *pcVar1;
  int iVar2;
  char *p2;
  char *p1;
  char *p;
  Line *l;
  
  p = (char *)0x0;
  if ((re == (char *)0x0) || (*re == '\0')) {
    pcVar1 = (char *)0x0;
  }
  else {
    pcVar1 = regexCompile(re,1);
    if (pcVar1 == (char *)0x0) {
      if (MarkAllPages == 0) {
        l = buf->topLine;
      }
      else {
        l = buf->firstLine;
      }
      for (; (l != (Line *)0x0 &&
             ((MarkAllPages != 0 || (l->linenumber < buf->topLine->linenumber + LINES + -1))));
          l = l->next) {
        if ((p == (char *)0x0) || (l->bpos == 0)) {
          p = l->lineBuf;
          while (iVar2 = regexMatch(p,(int)(l->lineBuf + (l->size - (int)p)),(uint)(l->lineBuf == p)
                                   ), iVar2 == 1) {
            matchedPosition(&p1,&p2);
            p = reAnchorPos(buf,l,p1,p2,anchorproc);
          }
        }
        if ((((MarkAllPages != 0) && (l->next == (_Line *)0x0)) &&
            (buf->pagerSource != (InputStream)0x0)) && ((buf->bufferprop & 0x40U) == 0)) {
          getNextPage(buf,PagerMax);
        }
      }
      pcVar1 = (char *)0x0;
    }
  }
  return pcVar1;
}



char * reAnchor(Buffer *buf,char *re)

{
  char *pcVar1;
  
  pcVar1 = reAnchorAny(buf,re,_put_anchor_all);
  return pcVar1;
}



char * reAnchorNews(Buffer *buf,char *re)

{
  char *pcVar1;
  
  pcVar1 = reAnchorAny(buf,re,_put_anchor_news);
  return pcVar1;
}



char * reAnchorNewsheader(Buffer *buf)

{
  bool bVar1;
  size_t __n;
  char *pcVar2;
  int iVar3;
  int search;
  int i;
  char **q;
  char **header;
  char *p2;
  char *p1;
  char *p;
  Line *l;
  
  bVar1 = false;
  if ((buf != (Buffer *)0x0) && (buf->firstLine != (Line *)0x0)) {
    for (i = 0; i < 2; i = i + 1) {
      if (i == 0) {
        regexCompile("<[!-;=?-~]+@[a-zA-Z0-9\\.\\-_]+>",1);
        header = reAnchorNewsheader::header_mid;
      }
      else {
        regexCompile("[a-zA-Z0-9\\.\\-_]+",1);
        header = reAnchorNewsheader::header_group;
      }
      for (l = buf->firstLine; (l != (Line *)0x0 && (l->real_linenumber == 0)); l = l->next) {
        if (l->bpos == 0) {
          p = l->lineBuf;
          if ((MYCTYPE_MAP[(byte)*p] & 2) == 0) {
            bVar1 = false;
            for (q = header; *q != (char *)0x0; q = q + 1) {
              __n = strlen(*q);
              iVar3 = strncasecmp(p,*q,__n);
              if (iVar3 == 0) {
                bVar1 = true;
                pcVar2 = strchr(p,0x3a);
                p = pcVar2 + 1;
                break;
              }
            }
          }
          if (bVar1) {
            while (iVar3 = regexMatch(p,(int)(l->lineBuf + (l->size - (int)p)),
                                      (uint)(l->lineBuf == p)), iVar3 == 1) {
              matchedPosition(&p1,&p2);
              p = reAnchorPos(buf,l,p1,p2,_put_anchor_news);
            }
          }
        }
      }
    }
    reseq_anchor(buf);
  }
  return (char *)0x0;
}



HmarkerList * putHmarker(HmarkerList *ml,int line,int pos,int seq)

{
  BufferPoint *pBVar1;
  
  if (ml == (HmarkerList *)0x0) {
    ml = (HmarkerList *)GC_malloc(0x10);
    ml->marks = (BufferPoint *)0x0;
    ml->nmark = 0;
    ml->markmax = 0;
    ml->prevhseq = -1;
  }
  if (ml->markmax == 0) {
    ml->markmax = 0x1e;
    pBVar1 = (BufferPoint *)GC_malloc_atomic(ml->markmax * 0xc);
    ml->marks = pBVar1;
    bzero(ml->marks,ml->markmax * 0xc);
  }
  if (ml->nmark < seq + 1) {
    ml->nmark = seq + 1;
  }
  if (ml->markmax <= ml->nmark) {
    ml->markmax = ml->nmark * 2;
    pBVar1 = (BufferPoint *)GC_realloc(ml->marks,ml->markmax * 0xc);
    ml->marks = pBVar1;
  }
  ml->marks[seq].line = line;
  ml->marks[seq].pos = pos;
  ml->marks[seq].invalid = 0;
  return ml;
}



Anchor * closest_next_anchor(AnchorList *a,Anchor *an,int x,int y)

{
  int i;
  
  if ((a != (AnchorList *)0x0) && (a->nanchor != 0)) {
    for (i = 0; i < a->nanchor; i = i + 1) {
      if (((-1 < a->anchors[i].hseq) &&
          ((y < a->anchors[i].start.line ||
           ((a->anchors[i].start.line == y && (x < a->anchors[i].start.pos)))))) &&
         ((an == (Anchor *)0x0 ||
          ((a->anchors[i].start.line < (an->start).line ||
           (((an->start).line == a->anchors[i].start.line &&
            (a->anchors[i].start.pos < (an->start).pos)))))))) {
        an = a->anchors + i;
      }
    }
  }
  return an;
}



Anchor * closest_prev_anchor(AnchorList *a,Anchor *an,int x,int y)

{
  int i;
  
  if ((a != (AnchorList *)0x0) && (a->nanchor != 0)) {
    for (i = 0; i < a->nanchor; i = i + 1) {
      if (((-1 < a->anchors[i].hseq) &&
          ((a->anchors[i].end.line < y ||
           ((a->anchors[i].end.line == y && (a->anchors[i].end.pos <= x)))))) &&
         ((an == (Anchor *)0x0 ||
          (((an->end).line < a->anchors[i].end.line ||
           (((an->end).line == a->anchors[i].end.line && ((an->end).pos < a->anchors[i].end.pos)))))
          ))) {
        an = a->anchors + i;
      }
    }
  }
  return an;
}



void shiftAnchorPosition(AnchorList *al,HmarkerList *hl,int line,int pos,int shift)

{
  Anchor *pAVar1;
  int iVar2;
  int cmp;
  size_t s;
  size_t e;
  size_t b;
  Anchor *a;
  
  if ((al != (AnchorList *)0x0) && (al->nanchor != 0)) {
    s = al->nanchor / 2;
    b = 0;
    e = al->nanchor - 1;
    while ((b <= e && (iVar2 = onAnchor(al->anchors + s,line,pos), iVar2 != 0))) {
      if (iVar2 < 1) {
        if (s == 0) break;
        e = s - 1;
      }
      else {
        b = s + 1;
      }
      s = b + e + 1 >> 1;
    }
    while ((s < (uint)al->nanchor && (pAVar1 = al->anchors, pAVar1[s].start.line <= line))) {
      if ((pos < pAVar1[s].start.pos) &&
         (pAVar1[s].start.pos = pAVar1[s].start.pos + shift, hl->marks[pAVar1[s].hseq].line == line)
         ) {
        hl->marks[pAVar1[s].hseq].pos = pAVar1[s].start.pos;
      }
      if (pos <= pAVar1[s].end.pos) {
        pAVar1[s].end.pos = pAVar1[s].end.pos + shift;
      }
      s = s + 1;
    }
  }
  return;
}



// WARNING: Could not reconcile some variable overlaps

void addMultirowsImg(Buffer *buf,AnchorList *al)

{
  Anchor *pAVar1;
  char *url;
  char *title;
  int line;
  int pos_00;
  int pos_01;
  int iVar2;
  AnchorList *pAVar3;
  Anchor a_form;
  Anchor a_href;
  Anchor a_img;
  Line *ls;
  Line *l;
  Anchor *a;
  Image *img;
  int pos;
  int ecol;
  int col;
  int k;
  int j;
  int i;
  
  if ((al != (AnchorList *)0x0) && (al->nanchor != 0)) {
    for (i = 0; i < al->nanchor; i = i + 1) {
      pAVar1 = al->anchors + i;
      url = pAVar1->url;
      title = pAVar1->title;
      line = (pAVar1->start).line;
      pos_00 = (pAVar1->start).pos;
      pos_01 = (pAVar1->end).pos;
      iVar2 = pAVar1->hseq;
      img = pAVar1->image;
      if (((-1 < iVar2) && (img != (Image *)0x0)) && (1 < img->rows)) {
        for (l = buf->firstLine; (l != (Line *)0x0 && (l->linenumber != (int)img->y)); l = l->next)
        {
        }
        if (l != (Line *)0x0) {
          a_img.y = (short)((uint)*(undefined4 *)&pAVar1->slave >> 0x10);
          if (a_img.y == line) {
            ls = l;
          }
          else {
            ls = l;
            while ((ls != (Line *)0x0 && (ls->linenumber != line))) {
              if (a_img.y < line) {
                ls = ls->next;
              }
              else {
                ls = ls->prev;
              }
            }
            if (ls == (Line *)0x0) goto LAB_080aeacb;
          }
          a = retrieveAnchor(buf->href,line,pos_00);
          if (a == (Anchor *)0x0) {
            a_href.url = (char *)0x0;
          }
          else {
            a_href.url = a->url;
            a_href.target = a->target;
            a_href.referer = a->referer;
            a_href.title = a->title;
            a_href._16_4_ = *(undefined4 *)&a->accesskey;
            a_href.hseq = a->hseq;
          }
          a = retrieveAnchor(buf->formitem,line,pos_00);
          if (a == (Anchor *)0x0) {
            a_form.url = (char *)0x0;
          }
          else {
            a_form.url = a->url;
            a_form.target = a->target;
            a_form.hseq = a->hseq;
          }
          col = calcPosition(ls->lineBuf,ls->propBuf,ls->len,pos_00,0,0);
          ecol = calcPosition(ls->lineBuf,ls->propBuf,ls->len,pos_01,0,0);
          for (j = 0; (l != (Line *)0x0 && (j < img->rows)); j = j + 1) {
            if (line != l->linenumber) {
              pos = columnPos(l,col);
              a = registerImg(buf,url,title,l->linenumber,pos);
              a->hseq = -iVar2;
              a->slave = '\x01';
              a->image = img;
              (a->end).pos = (pos + ecol) - col;
              for (k = pos; k < (a->end).pos; k = k + 1) {
                l->propBuf[k] = l->propBuf[k] | 0x20;
              }
              if (a_href.url != (char *)0x0) {
                a = registerHref(buf,a_href.url,a_href.target,a_href.referer,a_href.title,
                                 (uchar)a_href._16_4_,l->linenumber,pos);
                a->hseq = a_href.hseq;
                a->slave = '\x01';
                (a->end).pos = (pos + ecol) - col;
                for (k = pos; k < (a->end).pos; k = k + 1) {
                  l->propBuf[k] = l->propBuf[k] | 0x10;
                }
              }
              if (a_form.url != (char *)0x0) {
                pAVar3 = putAnchor(buf->formitem,a_form.url,a_form.target,&a,(char *)0x0,(char *)0x0
                                   ,'\0',l->linenumber,pos);
                buf->formitem = pAVar3;
                a->hseq = a_form.hseq;
                (a->end).pos = (pos + ecol) - col;
              }
            }
            l = l->next;
          }
          img->rows = 0;
        }
      }
LAB_080aeacb:
    }
  }
  return;
}



void addMultirowsForm(Buffer *buf,AnchorList *al)

{
  Anchor *pAVar1;
  char *url;
  char *target;
  int iVar2;
  int pos_00;
  int pos_01;
  int iVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  AnchorList *pAVar6;
  Anchor a_form;
  Line *ls;
  Line *l;
  FormItemList *fi;
  Anchor *a;
  int pos;
  int ecol;
  int col;
  int k;
  int j;
  int i;
  
  if ((al != (AnchorList *)0x0) && (al->nanchor != 0)) {
    for (i = 0; i < al->nanchor; i = i + 1) {
      pAVar1 = al->anchors + i;
      url = pAVar1->url;
      target = pAVar1->target;
      iVar2 = (pAVar1->start).line;
      pos_00 = (pAVar1->start).pos;
      pos_01 = (pAVar1->end).pos;
      iVar3 = pAVar1->hseq;
      uVar4 = *(undefined4 *)&pAVar1->slave;
      uVar5 = *(undefined4 *)&pAVar1->rows;
      al->anchors[i].rows = 1;
      if ((-1 < iVar3) && (a_form.rows = (short)uVar5, 1 < a_form.rows)) {
        for (l = buf->firstLine;
            (a_form.y = (short)((uint)uVar4 >> 0x10), l != (Line *)0x0 &&
            (l->linenumber != (int)a_form.y)); l = l->next) {
        }
        if (l != (Line *)0x0) {
          if (a_form.y == iVar2) {
            ls = l;
          }
          else {
            ls = l;
            while ((ls != (Line *)0x0 && (ls->linenumber != iVar2))) {
              if (a_form.y < iVar2) {
                ls = ls->next;
              }
              else {
                ls = ls->prev;
              }
            }
            if (ls == (Line *)0x0) goto LAB_080aee53;
          }
          col = calcPosition(ls->lineBuf,ls->propBuf,ls->len,pos_00,0,0);
          ecol = calcPosition(ls->lineBuf,ls->propBuf,ls->len,pos_01,0,0);
          for (j = 0; (l != (Line *)0x0 && (j < a_form.rows)); j = j + 1) {
            pos = columnPos(l,col);
            if (j == 0) {
              buf->hmarklist->marks[iVar3].line = l->linenumber;
              buf->hmarklist->marks[iVar3].pos = pos;
            }
            if (iVar2 != l->linenumber) {
              pAVar6 = putAnchor(buf->formitem,url,target,&a,(char *)0x0,(char *)0x0,'\0',
                                 l->linenumber,pos);
              buf->formitem = pAVar6;
              a->hseq = iVar3;
              a->y = a_form.y;
              (a->end).pos = (pos + ecol) - col;
              l->lineBuf[pos + -1] = '[';
              l->lineBuf[(a->end).pos] = ']';
              for (k = pos; k < (a->end).pos; k = k + 1) {
                l->propBuf[k] = l->propBuf[k] | 0x40;
              }
            }
            l = l->next;
          }
        }
      }
LAB_080aee53:
    }
  }
  return;
}



char * getAnchorText(Buffer *buf,AnchorList *al,Anchor *a)

{
  int iVar1;
  Anchor *pAVar2;
  int iVar3;
  char *pcVar4;
  char *ep;
  char *p;
  Str tmp;
  Line *l;
  int i;
  int hseq;
  
  tmp = (Str)0x0;
  if ((a == (Anchor *)0x0) || (a->hseq < 0)) {
    pcVar4 = (char *)0x0;
  }
  else {
    iVar1 = a->hseq;
    l = buf->firstLine;
    for (i = 0; i < al->nanchor; i = i + 1) {
      pAVar2 = al->anchors;
      if (pAVar2[i].hseq == iVar1) {
        for (; (l != (Line *)0x0 && (l->linenumber != pAVar2[i].start.line)); l = l->next) {
        }
        if (l == (Line *)0x0) break;
        p = l->lineBuf + pAVar2[i].start.pos;
        pcVar4 = l->lineBuf + pAVar2[i].end.pos;
        while ((p < pcVar4 && ((MYCTYPE_MAP[(byte)*p] & 2) != 0))) {
          p = p + 1;
        }
        if (p != pcVar4) {
          if (tmp == (Str)0x0) {
            tmp = Strnew_size((int)pcVar4 - (int)p);
          }
          else {
            if (tmp->area_size <= tmp->length + 1) {
              Strgrow(tmp);
            }
            iVar3 = tmp->length;
            tmp->ptr[iVar3] = ' ';
            tmp->length = iVar3 + 1;
            tmp->ptr[tmp->length] = '\0';
          }
          Strcat_charp_n(tmp,p,(int)pcVar4 - (int)p);
        }
      }
    }
    if (tmp == (Str)0x0) {
      pcVar4 = (char *)0x0;
    }
    else {
      pcVar4 = tmp->ptr;
    }
  }
  return pcVar4;
}



Buffer * link_list_panel(Buffer *buf)

{
  AnchorList *pAVar1;
  int iVar2;
  char **ppcVar3;
  Str x;
  Buffer *pBVar4;
  ParsedURL *pPVar5;
  Str p_Var6;
  char *pcVar7;
  char *pcVar8;
  Anchor *pAVar9;
  int iVar10;
  MapList *pMVar11;
  ParsedURL pu;
  MapArea *m;
  ListItem *mi;
  MapList *ml;
  Str tmp;
  char *p;
  char *u;
  char *t;
  int i;
  FormItemList *fi;
  Anchor *a;
  AnchorList *al;
  LinkList *l;
  
  x = Strnew_charp("<title>Link List</title><h1 align=center>Link List</h1>\n");
  if (((buf->bufferprop & 8U) == 0) &&
     (((buf->linklist != (LinkList *)0x0 || (buf->href != (AnchorList *)0x0)) ||
      (buf->img != (AnchorList *)0x0)))) {
    if (buf->linklist != (LinkList *)0x0) {
      Strcat_charp(x,"<hr><h2>Links</h2>\n<ol>\n");
      for (l = buf->linklist; l != (LinkList *)0x0; l = l->next) {
        if (l->url == (char *)0x0) {
          p = "";
          u = "";
        }
        else {
          pPVar5 = baseURL(buf);
          parseURL2(l->url,&pu,pPVar5);
          p_Var6 = parsedURL2Str(&pu);
          pcVar8 = p_Var6->ptr;
          u = html_quote(pcVar8);
          p = u;
          if (DecodeURL != 0) {
            pcVar8 = url_unquote_conv(pcVar8,buf->document_charset);
            p = html_quote(pcVar8);
          }
        }
        if (l->type == '\x01') {
          t = " [Rel]";
        }
        else if (l->type == '\x02') {
          t = " [Rev]";
        }
        else {
          t = "";
        }
        if (l->title == (char *)0x0) {
          pcVar8 = "";
        }
        else {
          pcVar8 = l->title;
        }
        p_Var6 = Sprintf("%s%s\n",pcVar8,t);
        pcVar8 = html_quote(p_Var6->ptr);
        Strcat_m_charp(x,"<li><a href=\"",u,&DAT_080d08ee,pcVar8,"</a><br>",p,&DAT_080d08e3,0);
      }
      Strcat_charp(x,"</ol>\n");
    }
    if (buf->href != (AnchorList *)0x0) {
      Strcat_charp(x,"<hr><h2>Anchors</h2>\n<ol>\n");
      pAVar1 = buf->href;
      for (i = 0; i < pAVar1->nanchor; i = i + 1) {
        pAVar9 = pAVar1->anchors + i;
        if ((-1 < pAVar9->hseq) && (pAVar9->slave == '\0')) {
          pPVar5 = baseURL(buf);
          parseURL2(pAVar9->url,&pu,pPVar5);
          p_Var6 = parsedURL2Str(&pu);
          pcVar8 = p_Var6->ptr;
          pcVar7 = html_quote(pcVar8);
          p = pcVar7;
          if (DecodeURL != 0) {
            pcVar8 = url_unquote_conv(pcVar8,buf->document_charset);
            p = html_quote(pcVar8);
          }
          pcVar8 = getAnchorText(buf,pAVar1,pAVar9);
          if (pcVar8 == (char *)0x0) {
            pcVar8 = "";
          }
          else {
            pcVar8 = html_quote(pcVar8);
          }
          Strcat_m_charp(x,"<li><a href=\"",pcVar7,&DAT_080d08ee,pcVar8,"</a><br>",p,&DAT_080d08e3,0
                        );
        }
      }
      Strcat_charp(x,"</ol>\n");
    }
    if (buf->img != (AnchorList *)0x0) {
      Strcat_charp(x,"<hr><h2>Images</h2>\n<ol>\n");
      pAVar1 = buf->img;
      for (i = 0; i < pAVar1->nanchor; i = i + 1) {
        pAVar9 = pAVar1->anchors + i;
        if (pAVar9->slave == '\0') {
          pPVar5 = baseURL(buf);
          parseURL2(pAVar9->url,&pu,pPVar5);
          p_Var6 = parsedURL2Str(&pu);
          pcVar8 = p_Var6->ptr;
          pcVar7 = html_quote(pcVar8);
          p = pcVar7;
          if (DecodeURL != 0) {
            pcVar8 = url_unquote_conv(pcVar8,buf->document_charset);
            p = html_quote(pcVar8);
          }
          if ((pAVar9->title == (char *)0x0) || (*pAVar9->title == '\0')) {
            if (DecodeURL == 0) {
              t = html_quote(pAVar9->url);
            }
            else {
              pcVar8 = url_unquote_conv(pAVar9->url,buf->document_charset);
              t = html_quote(pcVar8);
            }
          }
          else {
            t = html_quote(pAVar9->title);
          }
          Strcat_m_charp(x,"<li><a href=\"",pcVar7,&DAT_080d08ee,t,"</a><br>",p,&DAT_080d08e3,0);
          pAVar9 = retrieveAnchor(buf->formitem,(pAVar9->start).line,(pAVar9->start).pos);
          if ((((pAVar9 != (Anchor *)0x0) &&
               (iVar2 = **(int **)(pAVar9->url + 0x40), *(int *)(*(int *)(iVar2 + 0x40) + 8) == 2))
              && (iVar10 = strcmp(**(char ***)(*(int *)(iVar2 + 0x40) + 0xc),"map"), iVar10 == 0))
             && ((*(int *)(iVar2 + 8) != 0 &&
                 (pMVar11 = searchMapList(buf,**(char ***)(iVar2 + 8)), pMVar11 != (MapList *)0x0)))
             ) {
            Strcat_charp(x,"<br>\n<b>Image map</b>\n<ol>\n");
            for (mi = pMVar11->area->first; mi != (ListItem *)0x0; mi = mi->next) {
              ppcVar3 = (char **)mi->ptr;
              if (ppcVar3 != (char **)0x0) {
                pPVar5 = baseURL(buf);
                parseURL2(*ppcVar3,&pu,pPVar5);
                p_Var6 = parsedURL2Str(&pu);
                pcVar8 = p_Var6->ptr;
                pcVar7 = html_quote(pcVar8);
                p = pcVar7;
                if (DecodeURL != 0) {
                  pcVar8 = url_unquote_conv(pcVar8,buf->document_charset);
                  p = html_quote(pcVar8);
                }
                if ((ppcVar3[2] == (char *)0x0) || (*ppcVar3[2] == '\0')) {
                  if (DecodeURL == 0) {
                    t = html_quote(*ppcVar3);
                  }
                  else {
                    pcVar8 = url_unquote_conv(*ppcVar3,buf->document_charset);
                    t = html_quote(pcVar8);
                  }
                }
                else {
                  t = html_quote(ppcVar3[2]);
                }
                Strcat_m_charp(x,"<li><a href=\"",pcVar7,&DAT_080d08ee,t,"</a><br>",p,&DAT_080d08e3,
                               0);
              }
            }
            Strcat_charp(x,"</ol>\n");
          }
        }
      }
      Strcat_charp(x,"</ol>\n");
    }
    pBVar4 = loadHTMLString(x);
  }
  else {
    pBVar4 = (Buffer *)0x0;
  }
  return pBVar4;
}



int noConv(char *oval,char **str)

{
  *str = oval;
  return 1;
}



int toNumber(char *oval,int *num)

{
  long lVar1;
  int x;
  char *ep;
  
  lVar1 = strtol(oval,&ep,10);
  if (oval < ep) {
    *num = lVar1;
  }
  return (uint)(oval < ep);
}



int toLength(char *oval,int *len)

{
  int iVar1;
  size_t sVar2;
  int w;
  
  if ((MYCTYPE_MAP[(byte)*oval] & 8) == 0) {
    iVar1 = 0;
  }
  else {
    w = atoi(oval);
    if (w < 0) {
      iVar1 = 0;
    }
    else {
      if (w == 0) {
        w = 1;
      }
      sVar2 = strlen(oval);
      if (oval[sVar2 - 1] == '%') {
        *len = -w;
      }
      else {
        *len = w;
      }
      iVar1 = 1;
    }
  }
  return iVar1;
}



int toAlign(char *oval,int *align)

{
  int iVar1;
  
  iVar1 = strcasecmp(oval,"left");
  if (iVar1 == 0) {
    *align = 1;
  }
  else {
    iVar1 = strcasecmp(oval,"right");
    if (iVar1 == 0) {
      *align = 2;
    }
    else {
      iVar1 = strcasecmp(oval,"center");
      if (iVar1 == 0) {
        *align = 0;
      }
      else {
        iVar1 = strcasecmp(oval,"top");
        if (iVar1 == 0) {
          *align = 5;
        }
        else {
          iVar1 = strcasecmp(oval,"bottom");
          if (iVar1 == 0) {
            *align = 6;
          }
          else {
            iVar1 = strcasecmp(oval,"middle");
            if (iVar1 != 0) {
              return 0;
            }
            *align = 4;
          }
        }
      }
    }
  }
  return 1;
}



int toVAlign(char *oval,int *valign)

{
  int iVar1;
  
  iVar1 = strcasecmp(oval,"top");
  if ((iVar1 == 0) || (iVar1 = strcasecmp(oval,"baseline"), iVar1 == 0)) {
    *valign = 1;
  }
  else {
    iVar1 = strcasecmp(oval,"bottom");
    if (iVar1 == 0) {
      *valign = 2;
    }
    else {
      iVar1 = strcasecmp(oval,"middle");
      if (iVar1 != 0) {
        return 0;
      }
      *valign = 0;
    }
  }
  return 1;
}



parsed_tag * parse_tag(char **s,int internal)

{
  bool bVar1;
  byte bVar2;
  int iVar3;
  uint __n;
  uchar *puVar4;
  char **ppcVar5;
  int iVar6;
  char *pcVar7;
  int in_GS_OFFSET;
  char *x;
  int hidden;
  int j;
  Str value_tmp;
  Str value;
  int nattr;
  int attr_id;
  int i;
  char *q;
  char *p;
  int tag_id;
  parsed_tag *tag;
  char attrname [64];
  char tagname [64];
  int local_10;
  
  local_10 = *(int *)(in_GS_OFFSET + 0x14);
  tag = (parsed_tag *)0x0;
  attr_id = 0;
  q = *s + 1;
  p = tagname;
  if (*q == '/') {
    tagname[0] = *q;
    p = tagname + 1;
    do {
      q = q + 1;
      if (*q == '\0') break;
    } while ((MYCTYPE_MAP[(byte)*q] & 2) != 0);
  }
  for (; (((*q != '\0' && ((MYCTYPE_MAP[(byte)*q] & 2) == 0)) &&
          ((tagname[0] == '/' || (*q != '/')))) && ((*q != '>' && ((int)p - (int)tagname < 0x3f))));
      p = p + 1) {
    if ((MYCTYPE_MAP[(byte)*q] & 4) == 0) {
      bVar2 = *q;
    }
    else {
      bVar2 = *q | 0x20;
    }
    *p = bVar2;
    q = q + 1;
  }
  *p = '\0';
  for (; (((*q != '\0' && ((MYCTYPE_MAP[(byte)*q] & 2) == 0)) &&
          ((tagname[0] == '/' || (*q != '/')))) && (*q != '>')); q = q + 1) {
  }
  iVar3 = getHash_si(&tagtable,tagname,0);
  if ((iVar3 == 0) || ((internal == 0 && ((TagMAP[iVar3].flag & 2) != 0)))) {
    for (; (*q != '>' && (*q != '\0')); q = q + 1) {
    }
  }
  else {
    tag = (parsed_tag *)GC_malloc(0x14);
    bzero(tag,0x14);
    tag->tagid = (uchar)iVar3;
    __n = (uint)TagMAP[iVar3].max_attribute;
    if (__n != 0) {
      puVar4 = (uchar *)GC_malloc_atomic(__n);
      tag->attrid = puVar4;
      ppcVar5 = (char **)GC_malloc(__n << 2);
      tag->value = ppcVar5;
      puVar4 = (uchar *)GC_malloc_atomic(0x4b);
      tag->map = puVar4;
      memset(tag->map,0x4b,0x4b);
      memset(tag->attrid,0,__n);
      for (i = 0; i < (int)__n; i = i + 1) {
        tag->map[TagMAP[iVar3].accept_attribute[i]] = (uchar)i;
      }
    }
    while ((*q != '\0' && ((MYCTYPE_MAP[(byte)*q] & 2) != 0))) {
      q = q + 1;
    }
    while( true ) {
      value = (Str)0x0;
      value_tmp = (Str)0x0;
      if ((*q == '>') || (*q == '\0')) break;
      for (p = attrname;
          (((*q != '\0' && (*q != '=')) && ((MYCTYPE_MAP[(byte)*q] & 2) == 0)) &&
          ((*q != '>' && ((int)p - (int)attrname < 0x3f)))); p = p + 1) {
        if ((MYCTYPE_MAP[(byte)*q] & 4) == 0) {
          bVar2 = *q;
        }
        else {
          bVar2 = *q | 0x20;
        }
        *p = bVar2;
        q = q + 1;
      }
      *p = '\0';
      for (; ((*q != '\0' && (*q != '=')) && (((MYCTYPE_MAP[(byte)*q] & 2) == 0 && (*q != '>'))));
          q = q + 1) {
      }
      while ((*q != '\0' && ((MYCTYPE_MAP[(byte)*q] & 2) != 0))) {
        q = q + 1;
      }
      if (*q == '=') {
        value_tmp = Strnew();
        do {
          pcVar7 = q;
          q = pcVar7 + 1;
          if (*q == '\0') break;
        } while ((MYCTYPE_MAP[(byte)*q] & 2) != 0);
        if (*q == '\"') {
          for (q = pcVar7 + 2; (*q != '\0' && (*q != '\"')); q = q + 1) {
            if (value_tmp->area_size <= value_tmp->length + 1) {
              Strgrow(value_tmp);
            }
            iVar6 = value_tmp->length;
            value_tmp->ptr[iVar6] = *q;
            value_tmp->length = iVar6 + 1;
            value_tmp->ptr[value_tmp->length] = '\0';
            if ((tag->need_reconstruct == '\0') && ((QUOTE_MAP[(byte)*q] & 7) != 0)) {
              tag->need_reconstruct = '\x01';
            }
          }
          if (*q == '\"') {
            q = q + 1;
          }
        }
        else if (*q == '\'') {
          for (q = pcVar7 + 2; (*q != '\0' && (*q != '\'')); q = q + 1) {
            if (value_tmp->area_size <= value_tmp->length + 1) {
              Strgrow(value_tmp);
            }
            iVar6 = value_tmp->length;
            value_tmp->ptr[iVar6] = *q;
            value_tmp->length = iVar6 + 1;
            value_tmp->ptr[value_tmp->length] = '\0';
            if ((tag->need_reconstruct == '\0') && ((QUOTE_MAP[(byte)*q] & 7) != 0)) {
              tag->need_reconstruct = '\x01';
            }
          }
          if (*q == '\'') {
            q = q + 1;
          }
        }
        else if (*q != '\0') {
          for (; ((*q != '\0' && ((MYCTYPE_MAP[(byte)*q] & 2) == 0)) && (*q != '>')); q = q + 1) {
            if (value_tmp->area_size <= value_tmp->length + 1) {
              Strgrow(value_tmp);
            }
            iVar6 = value_tmp->length;
            value_tmp->ptr[iVar6] = *q;
            value_tmp->length = iVar6 + 1;
            value_tmp->ptr[value_tmp->length] = '\0';
            if ((tag->need_reconstruct == '\0') && ((QUOTE_MAP[(byte)*q] & 7) != 0)) {
              tag->need_reconstruct = '\x01';
            }
          }
        }
      }
      for (i = 0; i < (int)__n; i = i + 1) {
        if ((tag->attrid[i] == '\0') &&
           (iVar6 = strcmp(AttrMAP[TagMAP[iVar3].accept_attribute[i]].name,attrname), iVar6 == 0)) {
          attr_id = (int)TagMAP[iVar3].accept_attribute[i];
          break;
        }
      }
      if (value_tmp != (Str)0x0) {
        bVar1 = false;
        for (j = 0; j < i; j = j + 1) {
          if ((tag->attrid[j] == '!') && (iVar6 = strcmp("hidden",tag->value[j]), iVar6 == 0)) {
            bVar1 = true;
            break;
          }
        }
        if ((((iVar3 == 0x2c) || (iVar3 == 0x86)) && (attr_id == 0x24)) && (bVar1)) {
          value = value_tmp;
        }
        else {
          value = Strnew();
          for (x = value_tmp->ptr; *x != '\0'; x = x + 1) {
            if (*x != '\n') {
              if (value->area_size <= value->length + 1) {
                Strgrow(value);
              }
              iVar6 = value->length;
              value->ptr[iVar6] = *x;
              value->length = iVar6 + 1;
              value->ptr[value->length] = '\0';
            }
          }
        }
      }
      if (i == __n) {
        tag->need_reconstruct = '\x01';
      }
      else if ((internal == 0) &&
              (((AttrMAP[attr_id].flag & 1) != 0 ||
               (((value != (Str)0x0 && (AttrMAP[attr_id].vtype == '\b')) &&
                (iVar6 = strcasecmp(value->ptr,"internal"), iVar6 == 0)))))) {
        tag->need_reconstruct = '\x01';
      }
      else {
        tag->attrid[i] = (uchar)attr_id;
        if (value == (Str)0x0) {
          tag->value[i] = (char *)0x0;
        }
        else {
          ppcVar5 = tag->value;
          pcVar7 = html_unquote(value->ptr);
          ppcVar5[i] = pcVar7;
        }
      }
    }
  }
  if (*q == '>') {
    q = q + 1;
  }
  *s = q;
  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {
    return tag;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



int parsedtag_set_value(parsed_tag *tag,int id,char *value)

{
  byte bVar1;
  char **ppcVar2;
  int iVar3;
  char *pcVar4;
  int i;
  
  if ((tag->map == (uchar *)0x0) || (tag->map[id] == 'K')) {
    iVar3 = 0;
  }
  else {
    bVar1 = tag->map[id];
    tag->attrid[bVar1] = (uchar)id;
    if (value == (char *)0x0) {
      tag->value[bVar1] = (char *)0x0;
    }
    else {
      ppcVar2 = tag->value;
      pcVar4 = allocStr(value,-1);
      ppcVar2[bVar1] = pcVar4;
    }
    tag->need_reconstruct = '\x01';
    iVar3 = 1;
  }
  return iVar3;
}



int parsedtag_get_value(parsed_tag *tag,int id,void *value)

{
  int iVar1;
  int i;
  
  if ((((tag->map == (uchar *)0x0) || (tag->map[id] == 'K')) || (tag->attrid[tag->map[id]] == '\0'))
     || (tag->value[tag->map[id]] == (char *)0x0)) {
    iVar1 = 0;
  }
  else {
    iVar1 = (*toValFunc[AttrMAP[id].vtype])(tag->value[tag->map[id]],value);
  }
  return iVar1;
}



Str parsedtag2str(parsed_tag *tag)

{
  byte bVar1;
  byte bVar2;
  int iVar3;
  Str x;
  char *pcVar4;
  Str y;
  Str tagstr;
  int nattr;
  int tag_id;
  int i;
  
  bVar1 = tag->tagid;
  bVar2 = TagMAP[bVar1].max_attribute;
  x = Strnew();
  if (x->area_size <= x->length + 1) {
    Strgrow(x);
  }
  iVar3 = x->length;
  x->ptr[iVar3] = '<';
  x->length = iVar3 + 1;
  x->ptr[x->length] = '\0';
  Strcat_charp(x,TagMAP[bVar1].name);
  for (i = 0; i < (int)(uint)bVar2; i = i + 1) {
    if (tag->attrid[i] != '\0') {
      if (x->area_size <= x->length + 1) {
        Strgrow(x);
      }
      iVar3 = x->length;
      x->ptr[iVar3] = ' ';
      x->length = iVar3 + 1;
      x->ptr[x->length] = '\0';
      Strcat_charp(x,AttrMAP[tag->attrid[i]].name);
      if (tag->value[i] != (char *)0x0) {
        pcVar4 = html_quote(tag->value[i]);
        y = Sprintf("=\"%s\"",pcVar4);
        Strcat(x,y);
      }
    }
  }
  if (x->area_size <= x->length + 1) {
    Strgrow(x);
  }
  iVar3 = x->length;
  x->ptr[iVar3] = '>';
  x->length = iVar3 + 1;
  x->ptr[x->length] = '\0';
  return x;
}



void do_update(BaseStream base)

{
  int iVar1;
  int len;
  
  (base->stream).next = 0;
  (base->stream).cur = (base->stream).next;
  iVar1 = (*base->read)(base->handle,(base->stream).buf,(base->stream).size);
  if (iVar1 < 1) {
    base->iseos = '\x01';
  }
  else {
    (base->stream).next = (base->stream).next + iVar1;
  }
  return;
}



int buffer_read(StreamBuffer sb,char *obuf,int count)

{
  int len;
  
  len = sb->next - sb->cur;
  if (0 < len) {
    if (count < len) {
      len = count;
    }
    bcopy(sb->buf + sb->cur,obuf,len);
    sb->cur = sb->cur + len;
  }
  return len;
}



void init_buffer(BaseStream base,char *buf,int bufsize)

{
  uchar *puVar1;
  StreamBuffer sb;
  
  (base->stream).size = bufsize;
  (base->stream).cur = 0;
  if (buf == (char *)0x0) {
    puVar1 = (uchar *)GC_malloc_atomic(bufsize);
    (base->stream).buf = puVar1;
    (base->stream).next = 0;
  }
  else {
    (base->stream).buf = (uchar *)buf;
    (base->stream).next = bufsize;
  }
  base->iseos = '\0';
  return;
}



void init_base_stream(BaseStream base,int bufsize)

{
  init_buffer(base,(char *)0x0,bufsize);
  return;
}



void init_str_stream(BaseStream base,Str s)

{
  init_buffer(base,s->ptr,s->length);
  return;
}



InputStream newInputStream(int des)

{
  BaseStream base;
  void *pvVar1;
  InputStream stream;
  
  if (des < 0) {
    base = (BaseStream)0x0;
  }
  else {
    base = (BaseStream)GC_malloc(0x20);
    init_base_stream(base,0x2000);
    base->type = '\0';
    pvVar1 = (void *)GC_malloc(4);
    base->handle = pvVar1;
    *(int *)base->handle = des;
    base->read = basic_read;
    base->close = basic_close;
  }
  return (InputStream)base;
}



InputStream newFileStream(FILE *f,anon_subr_void_varargs *closep)

{
  BaseStream base;
  void *pvVar1;
  InputStream stream;
  
  if (f == (FILE *)0x0) {
    base = (BaseStream)0x0;
  }
  else {
    base = (BaseStream)GC_malloc(0x20);
    init_base_stream(base,0x2000);
    base->type = '\x01';
    pvVar1 = (void *)GC_malloc(8);
    base->handle = pvVar1;
    *(FILE **)base->handle = f;
    if (closep == (anon_subr_void_varargs *)0x0) {
      *(code **)((int)base->handle + 4) = fclose;
    }
    else {
      *(anon_subr_void_varargs **)((int)base->handle + 4) = closep;
    }
    base->read = file_read;
    base->close = file_close;
  }
  return (InputStream)base;
}



InputStream newStrStream(Str s)

{
  BaseStream base;
  InputStream stream;
  
  if (s == (Str)0x0) {
    base = (BaseStream)0x0;
  }
  else {
    base = (BaseStream)GC_malloc(0x20);
    init_str_stream(base,s);
    base->type = '\x02';
    base->handle = s;
    base->read = str_read;
    base->close = (anon_subr_void_varargs_for_close *)0x0;
  }
  return (InputStream)base;
}



InputStream newEncodedStream(InputStream is,char encoding)

{
  BaseStream base;
  void *pvVar1;
  InputStream stream;
  
  if ((is != (InputStream)0x0) &&
     (((encoding == '\x02' || (encoding == '\x01')) || (encoding == '\x03')))) {
    base = (BaseStream)GC_malloc(0x20);
    init_base_stream(base,0x2000);
    base->type = '\x04';
    pvVar1 = (void *)GC_malloc(0x10);
    base->handle = pvVar1;
    *(InputStream *)base->handle = is;
    *(undefined4 *)((int)base->handle + 8) = 0;
    *(char *)((int)base->handle + 0xc) = encoding;
    *(undefined4 *)((int)base->handle + 4) = 0;
    base->read = ens_read;
    base->close = ens_close;
    is = (InputStream)base;
  }
  return is;
}



int ISclose(InputStream stream)

{
  int iVar1;
  anon_subr_void_int *action;
  anon_subr_void_varargs *prevtrap;
  
  if (((stream == (InputStream)0x0) || (*(int *)&stream->field_0x1c == 0)) ||
     ((stream->field_0x14 & 0x10) != 0)) {
    iVar1 = -1;
  }
  else {
    action = mySignal(2,(anon_subr_void_int *)0x1);
    (**(code **)&stream->field_0x1c)(*(undefined4 *)&stream->field_0x10);
    mySignal(2,action);
    iVar1 = 0;
  }
  return iVar1;
}



int ISgetc(InputStream stream)

{
  uint uVar1;
  BaseStream base;
  
  if (stream == (InputStream)0x0) {
    uVar1 = 0;
  }
  else {
    if ((stream->field_0x15 == '\0') && (*(int *)&stream->field_0x8 == *(int *)&stream->field_0xc))
    {
      do_update((BaseStream)stream);
    }
    if (stream->field_0x15 == '\0') {
      uVar1 = (uint)*(byte *)(*(int *)stream + *(int *)&stream->field_0x8);
      *(int *)&stream->field_0x8 = *(int *)&stream->field_0x8 + 1;
    }
    else {
      uVar1 = 0;
    }
  }
  return uVar1;
}



int ISundogetc(InputStream stream)

{
  int iVar1;
  StreamBuffer sb;
  
  if (stream == (InputStream)0x0) {
    iVar1 = -1;
  }
  else if (*(int *)&stream->field_0x8 < 1) {
    iVar1 = -1;
  }
  else {
    *(int *)&stream->field_0x8 = *(int *)&stream->field_0x8 + -1;
    iVar1 = 0;
  }
  return iVar1;
}



Str StrISgets(InputStream stream)

{
  void *pvVar1;
  int n;
  int len;
  uchar *p;
  Str s;
  StreamBuffer sb;
  BaseStream base;
  
  s = (Str)0x0;
  if (stream == (InputStream)0x0) {
    s = (Str)0x0;
  }
  else {
    while (stream->field_0x15 == '\0') {
      if (*(int *)&stream->field_0x8 == *(int *)&stream->field_0xc) {
        do_update((BaseStream)stream);
      }
      else {
        pvVar1 = memchr((void *)(*(int *)stream + *(int *)&stream->field_0x8),10,
                        *(int *)&stream->field_0xc - *(int *)&stream->field_0x8);
        if (pvVar1 != (void *)0x0) {
          n = (int)pvVar1 + (1 - (*(int *)stream + *(int *)&stream->field_0x8));
          if (s == (Str)0x0) {
            s = Strnew_size(n);
          }
          Strcat_charp_n(s,(char *)(*(int *)stream + *(int *)&stream->field_0x8),n);
          *(int *)&stream->field_0x8 = *(int *)&stream->field_0x8 + n;
          return s;
        }
        if (s == (Str)0x0) {
          s = Strnew_size((*(int *)&stream->field_0xc - *(int *)&stream->field_0x8) + 10);
        }
        Strcat_charp_n(s,(char *)(*(int *)stream + *(int *)&stream->field_0x8),
                       *(int *)&stream->field_0xc - *(int *)&stream->field_0x8);
        *(undefined4 *)&stream->field_0x8 = *(undefined4 *)&stream->field_0xc;
      }
    }
    if (s == (Str)0x0) {
      s = Strnew();
    }
  }
  return s;
}



Str StrmyISgets(InputStream stream)

{
  int iVar1;
  Str p_Var2;
  int iVar3;
  int len;
  int i;
  Str s;
  StreamBuffer sb;
  BaseStream base;
  
  s = (Str)0x0;
  if (stream == (InputStream)0x0) {
    s = (Str)0x0;
  }
  else {
    do {
      while( true ) {
        while( true ) {
          if (stream->field_0x15 != '\0') {
            if (s != (Str)0x0) {
              return s;
            }
            p_Var2 = Strnew();
            return p_Var2;
          }
          if (*(int *)&stream->field_0x8 != *(int *)&stream->field_0xc) break;
          do_update((BaseStream)stream);
        }
        if (((s != (Str)0x0) && (0 < s->length)) && (s->ptr[s->length + -1] == '\r')) {
          if (*(char *)(*(int *)stream + *(int *)&stream->field_0x8) != '\n') {
            return s;
          }
          if (s->area_size <= s->length + 1) {
            Strgrow(s);
          }
          iVar3 = s->length;
          iVar1 = *(int *)&stream->field_0x8;
          s->ptr[iVar3] = *(char *)(*(int *)stream + iVar1);
          s->length = iVar3 + 1;
          *(int *)&stream->field_0x8 = iVar1 + 1;
          s->ptr[s->length] = '\0';
          return s;
        }
        for (i = *(int *)&stream->field_0x8;
            ((i < *(int *)&stream->field_0xc && (*(char *)(*(int *)stream + i) != '\n')) &&
            (*(char *)(*(int *)stream + i) != '\r')); i = i + 1) {
        }
        if (i < *(int *)&stream->field_0xc) break;
        if (s == (Str)0x0) {
          s = Strnew_size((*(int *)&stream->field_0xc - *(int *)&stream->field_0x8) + 10);
        }
        Strcat_charp_n(s,(char *)(*(int *)stream + *(int *)&stream->field_0x8),
                       *(int *)&stream->field_0xc - *(int *)&stream->field_0x8);
        *(undefined4 *)&stream->field_0x8 = *(undefined4 *)&stream->field_0xc;
      }
      iVar3 = i - *(int *)&stream->field_0x8;
      if (s == (Str)0x0) {
        s = Strnew_size(iVar3 + 0xb);
      }
      Strcat_charp_n(s,(char *)(*(int *)stream + *(int *)&stream->field_0x8),iVar3 + 1);
      *(int *)&stream->field_0x8 = i + 1;
    } while (*(char *)(*(int *)stream + i) != '\n');
  }
  return s;
}



int ISread(InputStream stream,Str buf,int count)

{
  int iVar1;
  BaseStream base;
  int len;
  int rest;
  
  if ((stream == (InputStream)0x0) || (stream->field_0x15 != '\0')) {
    iVar1 = 0;
  }
  else {
    iVar1 = buffer_read((StreamBuffer)stream,buf->ptr,count);
    rest = count - iVar1;
    if (*(int *)&stream->field_0x8 == *(int *)&stream->field_0xc) {
      len = (**(code **)&stream->field_0x18)
                      (*(undefined4 *)&stream->field_0x10,buf->ptr + iVar1,rest);
      if (len < 1) {
        stream->field_0x15 = 1;
        len = 0;
      }
      rest = rest - len;
    }
    Strtruncate(buf,count - rest);
    if (buf->length < 1) {
      iVar1 = 0;
    }
    else {
      iVar1 = 1;
    }
  }
  return iVar1;
}



int ISfileno(InputStream stream)

{
  byte bVar1;
  int iVar2;
  
  if (stream == (InputStream)0x0) {
    iVar2 = -1;
  }
  else {
    bVar1 = stream->field_0x14 & 0xef;
    if (bVar1 == 1) {
      iVar2 = fileno(**(FILE ***)&stream->field_0x10);
    }
    else if (bVar1 == 4) {
      iVar2 = ISfileno(**(InputStream **)&stream->field_0x10);
    }
    else if (bVar1 == 0) {
      iVar2 = **(int **)&stream->field_0x10;
    }
    else {
      iVar2 = -1;
    }
  }
  return iVar2;
}



int ISeos(InputStream stream)

{
  BaseStream base;
  
  if ((stream->field_0x15 == '\0') && (*(int *)&stream->field_0x8 == *(int *)&stream->field_0xc)) {
    do_update((BaseStream)stream);
  }
  return (int)(char)stream->field_0x15;
}



void basic_close(int *handle)

{
  close(*handle);
  return;
}



int basic_read(int *handle,char *buf,int len)

{
  ssize_t sVar1;
  
  sVar1 = read(*handle,buf,len);
  return sVar1;
}



void file_close(file_handle *handle)

{
  (*handle->close)(handle->f);
  return;
}



int file_read(file_handle *handle,char *buf,int len)

{
  size_t sVar1;
  
  sVar1 = fread(buf,1,len,(FILE *)handle->f);
  return sVar1;
}



int str_read(Str handle,char *buf,int len)

{
  return 0;
}



void ens_close(ens_handle *handle)

{
  ISclose(handle->is);
  return;
}



int ens_read(ens_handle *handle,char *buf,int len)

{
  Str p_Var1;
  int iVar2;
  char *p;
  
  if ((handle->s == (Str)0x0) || (handle->pos == handle->s->length)) {
    p_Var1 = StrmyISgets(handle->is);
    handle->s = p_Var1;
    if (handle->s->length == 0) {
      return 0;
    }
    cleanup_line(handle->s,1);
    if (handle->encoding == '\x01') {
      Strchop(handle->s);
    }
    else if (handle->encoding == '\x03') {
      iVar2 = strncmp(handle->s->ptr,"begin",5);
      if (iVar2 == 0) {
        p_Var1 = StrmyISgets(handle->is);
        handle->s = p_Var1;
      }
      Strchop(handle->s);
    }
    p = handle->s->ptr;
    if (handle->encoding == '\x02') {
      p_Var1 = decodeQP(&p);
      handle->s = p_Var1;
    }
    else if (handle->encoding == '\x01') {
      p_Var1 = decodeB(&p);
      handle->s = p_Var1;
    }
    else if (handle->encoding == '\x03') {
      p_Var1 = decodeU(&p);
      handle->s = p_Var1;
    }
    handle->pos = 0;
  }
  if (handle->s->length - handle->pos < len) {
    len = handle->s->length - handle->pos;
  }
  bcopy(handle->s->ptr + handle->pos,buf,len);
  handle->pos = handle->pos + len;
  return len;
}



Str Strnew(void)

{
  Str p_Var1;
  char *pcVar2;
  Str x;
  
  p_Var1 = (Str)GC_malloc(0xc);
  pcVar2 = (char *)GC_malloc_atomic(0x20);
  p_Var1->ptr = pcVar2;
  *p_Var1->ptr = '\0';
  p_Var1->area_size = 0x20;
  p_Var1->length = 0;
  return p_Var1;
}



Str Strnew_size(int n)

{
  Str p_Var1;
  char *pcVar2;
  Str x;
  
  p_Var1 = (Str)GC_malloc(0xc);
  pcVar2 = (char *)GC_malloc_atomic(n + 1);
  p_Var1->ptr = pcVar2;
  *p_Var1->ptr = '\0';
  p_Var1->area_size = n + 1;
  p_Var1->length = 0;
  return p_Var1;
}



Str Strnew_charp(char *p)

{
  Str p_Var1;
  size_t sVar2;
  size_t __n;
  char *pcVar3;
  int n;
  Str x;
  
  if (p == (char *)0x0) {
    p_Var1 = Strnew();
  }
  else {
    p_Var1 = (Str)GC_malloc(0xc);
    sVar2 = strlen(p);
    __n = sVar2 + 1;
    pcVar3 = (char *)GC_malloc_atomic(__n);
    p_Var1->ptr = pcVar3;
    p_Var1->area_size = __n;
    p_Var1->length = sVar2;
    bcopy(p,p_Var1->ptr,__n);
  }
  return p_Var1;
}



Str Strnew_m_charp(char *p,...)

{
  Str x;
  Str r;
  va_list ap;
  
  x = Strnew();
  ap = &stack0x00000008;
  while (p != (char *)0x0) {
    Strcat_charp(x,p);
    p = *(char **)ap;
    ap = ap + 4;
  }
  return x;
}



Str Strnew_charp_n(char *p,int n)

{
  Str p_Var1;
  char *pcVar2;
  Str x;
  
  if (p == (char *)0x0) {
    p_Var1 = Strnew_size(n);
  }
  else {
    p_Var1 = (Str)GC_malloc(0xc);
    pcVar2 = (char *)GC_malloc_atomic(n + 1);
    p_Var1->ptr = pcVar2;
    p_Var1->area_size = n + 1;
    p_Var1->length = n;
    bcopy(p,p_Var1->ptr,n);
    p_Var1->ptr[n] = '\0';
  }
  return p_Var1;
}



Str Strdup(Str s)

{
  Str x;
  Str n;
  
  x = Strnew_size(s->length);
  Strcopy(x,s);
  return x;
}



void Strclear(Str s)

{
  s->length = 0;
  *s->ptr = '\0';
  return;
}



void Strfree(Str x)

{
  GC_free(x->ptr);
  GC_free(x);
  return;
}



void Strcopy(Str x,Str y)

{
  char *pcVar1;
  
  if (x->area_size < y->length + 1) {
    GC_free(x->ptr);
    pcVar1 = (char *)GC_malloc_atomic(y->length + 1);
    x->ptr = pcVar1;
    x->area_size = y->length + 1;
  }
  bcopy(y->ptr,x->ptr,y->length + 1);
  x->length = y->length;
  return;
}



void Strcopy_charp(Str x,char *y)

{
  size_t sVar1;
  char *pcVar2;
  int len;
  
  if (y == (char *)0x0) {
    x->length = 0;
  }
  else {
    sVar1 = strlen(y);
    if (x->area_size < (int)(sVar1 + 1)) {
      GC_free(x->ptr);
      pcVar2 = (char *)GC_malloc_atomic(sVar1 + 1);
      x->ptr = pcVar2;
      x->area_size = sVar1 + 1;
    }
    bcopy(y,x->ptr,sVar1 + 1);
    x->length = sVar1;
  }
  return;
}



void Strcopy_charp_n(Str x,char *y,int n)

{
  char *pcVar1;
  int len;
  
  if (y == (char *)0x0) {
    x->length = 0;
  }
  else {
    if (x->area_size < n + 1) {
      GC_free(x->ptr);
      pcVar1 = (char *)GC_malloc_atomic(n + 1);
      x->ptr = pcVar1;
      x->area_size = n + 1;
    }
    bcopy(y,x->ptr,n);
    x->ptr[n] = '\0';
    x->length = n;
  }
  return;
}



void Strcat_charp_n(Str x,char *y,int n)

{
  char *__src;
  int iVar1;
  char *pcVar2;
  char *old;
  int newlen;
  
  if (y != (char *)0x0) {
    iVar1 = x->length + n + 1;
    if (x->area_size < iVar1) {
      __src = x->ptr;
      iVar1 = (iVar1 * 3) / 2;
      pcVar2 = (char *)GC_malloc_atomic(iVar1);
      x->ptr = pcVar2;
      x->area_size = iVar1;
      bcopy(__src,x->ptr,x->length);
      GC_free(__src);
    }
    bcopy(y,x->ptr + x->length,n);
    x->length = x->length + n;
    x->ptr[x->length] = '\0';
  }
  return;
}



void Strcat(Str x,Str y)

{
  Strcat_charp_n(x,y->ptr,y->length);
  return;
}



void Strcat_charp(Str x,char *y)

{
  size_t n;
  
  if (y != (char *)0x0) {
    n = strlen(y);
    Strcat_charp_n(x,y,n);
  }
  return;
}



void Strcat_m_charp(Str x,...)

{
  char *__s;
  size_t n;
  char *p;
  va_list ap;
  
  ap = &stack0x00000008;
  while( true ) {
    __s = *(char **)ap;
    if (__s == (char *)0x0) break;
    n = strlen(__s);
    Strcat_charp_n(x,__s,n);
    ap = ap + 4;
  }
  return;
}



void Strgrow(Str x)

{
  char *__src;
  char *pcVar1;
  int newlen;
  char *old;
  
  __src = x->ptr;
  newlen = (x->length * 6) / 5;
  if (x->length == newlen) {
    newlen = newlen + 2;
  }
  pcVar1 = (char *)GC_malloc_atomic(newlen);
  x->ptr = pcVar1;
  x->area_size = newlen;
  bcopy(__src,x->ptr,x->length);
  GC_free(__src);
  return;
}



Str Strsubstr(Str s,int beg,int len)

{
  int iVar1;
  Str x;
  int i;
  Str new_s;
  
  x = Strnew();
  if (beg < s->length) {
    for (i = 0; (i < len && (beg + i < s->length)); i = i + 1) {
      if (x->area_size <= x->length + 1) {
        Strgrow(x);
      }
      iVar1 = x->length;
      x->ptr[iVar1] = s->ptr[beg + i];
      x->length = iVar1 + 1;
      x->ptr[x->length] = '\0';
    }
  }
  return x;
}



void Strlower(Str s)

{
  byte bVar1;
  int i;
  
  for (i = 0; i < s->length; i = i + 1) {
    if ((MYCTYPE_MAP[(byte)s->ptr[i]] & 4) == 0) {
      bVar1 = s->ptr[i];
    }
    else {
      bVar1 = s->ptr[i] | 0x20;
    }
    s->ptr[i] = bVar1;
  }
  return;
}



void Strupper(Str s)

{
  byte bVar1;
  int i;
  
  for (i = 0; i < s->length; i = i + 1) {
    if ((MYCTYPE_MAP[(byte)s->ptr[i]] & 4) == 0) {
      bVar1 = s->ptr[i];
    }
    else {
      bVar1 = s->ptr[i] & 0xdf;
    }
    s->ptr[i] = bVar1;
  }
  return;
}



void Strchop(Str s)

{
  while (((s->ptr[s->length + -1] == '\n' || (s->ptr[s->length + -1] == '\r')) && (0 < s->length)))
  {
    s->length = s->length + -1;
  }
  s->ptr[s->length] = '\0';
  return;
}



void Strinsert_char(Str s,int pos,char c)

{
  int i;
  
  if ((-1 < pos) && (pos <= s->length)) {
    if (s->area_size < s->length + 2) {
      Strgrow(s);
    }
    for (i = s->length; pos < i; i = i + -1) {
      s->ptr[i] = s->ptr[i + -1];
    }
    s->length = s->length + 1;
    s->ptr[s->length] = '\0';
    s->ptr[pos] = c;
  }
  return;
}



void Strinsert_charp(Str s,int pos,char *p)

{
  char c;
  
  while (*p != '\0') {
    c = *p;
    p = p + 1;
    Strinsert_char(s,pos,c);
    pos = pos + 1;
  }
  return;
}



void Strdelete(Str s,int pos,int n)

{
  int i;
  
  if (pos + n < s->length) {
    for (i = pos; i < s->length - n; i = i + 1) {
      s->ptr[i] = s->ptr[i + n];
    }
    s->ptr[i] = '\0';
    s->length = i;
  }
  else {
    s->ptr[pos] = '\0';
    s->length = pos;
  }
  return;
}



void Strtruncate(Str s,int pos)

{
  s->ptr[pos] = '\0';
  s->length = pos;
  return;
}



void Strshrink(Str s,int n)

{
  if (n < s->length) {
    s->length = s->length - n;
    s->ptr[s->length] = '\0';
  }
  else {
    s->length = 0;
    *s->ptr = '\0';
  }
  return;
}



void Strremovefirstspaces(Str s)

{
  int i;
  
  i = 0;
  while ((i < s->length && ((MYCTYPE_MAP[(byte)s->ptr[i]] & 2) != 0))) {
    i = i + 1;
  }
  if (i != 0) {
    Strdelete(s,0,i);
  }
  return;
}



void Strremovetrailingspaces(Str s)

{
  int iVar1;
  int i;
  
  i = s->length;
  do {
    iVar1 = i;
    i = iVar1 + -1;
    if (i < 0) break;
  } while ((MYCTYPE_MAP[(byte)s->ptr[i]] & 2) != 0);
  s->length = iVar1;
  s->ptr[iVar1] = '\0';
  return;
}



Str Stralign_left(Str s,int width)

{
  int iVar1;
  Str x;
  int i;
  Str n;
  
  if (s->length < width) {
    x = Strnew_size(width);
    Strcopy(x,s);
    for (i = s->length; i < width; i = i + 1) {
      if (x->area_size <= x->length + 1) {
        Strgrow(x);
      }
      iVar1 = x->length;
      x->ptr[iVar1] = ' ';
      x->length = iVar1 + 1;
      x->ptr[x->length] = '\0';
    }
  }
  else {
    x = Strdup(s);
  }
  return x;
}



Str Stralign_right(Str s,int width)

{
  int iVar1;
  Str x;
  int i;
  Str n;
  
  if (s->length < width) {
    x = Strnew_size(width);
    for (i = s->length; i < width; i = i + 1) {
      if (x->area_size <= x->length + 1) {
        Strgrow(x);
      }
      iVar1 = x->length;
      x->ptr[iVar1] = ' ';
      x->length = iVar1 + 1;
      x->ptr[x->length] = '\0';
    }
    Strcat(x,s);
  }
  else {
    x = Strdup(s);
  }
  return x;
}



Str Stralign_center(Str s,int width)

{
  int iVar1;
  Str x;
  int iVar2;
  int w;
  int i;
  Str n;
  
  if (s->length < width) {
    x = Strnew_size(width);
    iVar2 = (width - s->length) / 2;
    for (i = 0; i < iVar2; i = i + 1) {
      if (x->area_size <= x->length + 1) {
        Strgrow(x);
      }
      iVar1 = x->length;
      x->ptr[iVar1] = ' ';
      x->length = iVar1 + 1;
      x->ptr[x->length] = '\0';
    }
    Strcat(x,s);
    for (i = s->length + iVar2; i < width; i = i + 1) {
      if (x->area_size <= x->length + 1) {
        Strgrow(x);
      }
      iVar2 = x->length;
      x->ptr[iVar2] = ' ';
      x->length = iVar2 + 1;
      x->ptr[x->length] = '\0';
    }
  }
  else {
    x = Strdup(s);
  }
  return x;
}



Str Sprintf(char *fmt,...)

{
  int iVar1;
  size_t sVar2;
  Str p_Var3;
  size_t sVar4;
  double vd;
  void *vp;
  char *vs;
  int vi;
  va_list ap;
  Str s;
  char *f;
  int p;
  int status;
  int len;
  
  len = 0;
  status = 0;
  p = 0;
  ap = &stack0x00000008;
  f = fmt;
  do {
    if (*f == '\0') {
      p_Var3 = Strnew_size(len * 2);
      vsprintf(p_Var3->ptr,fmt,&stack0x00000008);
      sVar4 = strlen(p_Var3->ptr);
      p_Var3->length = sVar4;
      iVar1 = p_Var3->length;
      if (iVar1 != len * 2 && SBORROW4(iVar1,len * 2) == iVar1 + len * -2 < 0) {
        fwrite("Sprintf: string too long\n",1,0x19,stderr);
                    // WARNING: Subroutine does not return
        exit(1);
      }
      return p_Var3;
    }
    while (status != 1) {
      if (status != 2) {
        if (status == 0) {
          if (*f == '%') {
            status = 1;
            p = 0;
          }
          else {
            len = len + 1;
          }
        }
        goto LAB_080b23fd;
      }
      if ((MYCTYPE_MAP[(byte)*f] & 4) == 0) goto LAB_080b23fd;
      status = 1;
    }
    if ((MYCTYPE_MAP[(byte)*f] & 4) == 0) {
      if ((MYCTYPE_MAP[(byte)*f] & 8) == 0) {
        if (*f == '.') {
          status = 2;
        }
        else if (*f == '%') {
          status = 0;
          len = len + 1;
        }
      }
      else {
        p = p * 10 + (int)*f + -0x30;
      }
    }
    else {
      switch(*f) {
      case 'E':
      case 'G':
      case 'e':
      case 'f':
      case 'g':
        ap = ap + 8;
        iVar1 = p;
        if (p < 1) {
          iVar1 = 0xf;
        }
        len = len + iVar1;
        break;
      case 'L':
      case 'h':
      case 'l':
      case 'w':
        goto LAB_080b23fd;
      case 'X':
      case 'd':
      case 'i':
      case 'o':
      case 'u':
      case 'x':
        iVar1 = p;
        if (p < 1) {
          iVar1 = 10;
        }
        len = len + iVar1;
        ap = ap + 4;
        break;
      case 'c':
        len = len + 1;
        ap = ap + 4;
        break;
      case 'n':
        ap = ap + 4;
        break;
      case 'p':
        ap = ap + 4;
        len = len + 10;
        break;
      case 's':
        sVar2 = strlen(*(char **)ap);
        sVar4 = p;
        if (p <= (int)sVar2) {
          sVar4 = sVar2;
        }
        len = len + sVar4;
        ap = ap + 4;
      }
      status = 0;
    }
LAB_080b23fd:
    f = f + 1;
  } while( true );
}



Str Strfgets(FILE *f)

{
  Str x;
  int iVar1;
  int iVar2;
  Str s;
  char c;
  
  x = Strnew();
  while( true ) {
    iVar1 = fgetc((FILE *)f);
    iVar2 = feof((FILE *)f);
    if (iVar2 != 0) {
      return x;
    }
    iVar2 = ferror((FILE *)f);
    if (iVar2 != 0) break;
    if (x->area_size <= x->length + 1) {
      Strgrow(x);
    }
    iVar2 = x->length;
    x->ptr[iVar2] = (char)iVar1;
    x->length = iVar2 + 1;
    x->ptr[x->length] = '\0';
    if ((char)iVar1 == '\n') {
      return x;
    }
  }
  return x;
}



Str Strfgetall(FILE *f)

{
  Str x;
  int iVar1;
  int iVar2;
  Str s;
  char c;
  
  x = Strnew();
  while( true ) {
    iVar1 = fgetc((FILE *)f);
    iVar2 = feof((FILE *)f);
    if (iVar2 != 0) {
      return x;
    }
    iVar2 = ferror((FILE *)f);
    if (iVar2 != 0) break;
    if (x->area_size <= x->length + 1) {
      Strgrow(x);
    }
    iVar2 = x->length;
    x->ptr[iVar2] = (char)iVar1;
    x->length = iVar2 + 1;
    x->ptr[x->length] = '\0';
  }
  return x;
}



clen_t strtoclen(char *s)

{
  longlong lVar1;
  
  lVar1 = strtoll(s,(char **)0x0,10);
  return lVar1;
}



char * allocStr(char *s,int len)

{
  char *__dest;
  char *ptr;
  
  if (s == (char *)0x0) {
    __dest = (char *)0x0;
  }
  else {
    if (len < 0) {
      len = strlen(s);
    }
    __dest = (char *)GC_malloc_atomic(len + 1);
    if (__dest == (char *)0x0) {
      fwrite("fm: Can\'t allocate string. Give me more memory!\n",1,0x30,stderr);
                    // WARNING: Subroutine does not return
      exit(-1);
    }
    bcopy(s,__dest,len);
    __dest[len] = '\0';
  }
  return __dest;
}



int strCmp(void *s1,void *s2)

{
  int iVar1;
  
                    // WARNING: Load size is inaccurate
                    // WARNING: Load size is inaccurate
  iVar1 = strcmp(*s1,*s2);
  return iVar1;
}



char * currentdir(void)

{
  char *__buf;
  char *path;
  
  __buf = (char *)GC_malloc_atomic(0x1000);
  getcwd(__buf,0x1000);
  return __buf;
}



char * cleanupName(char *name)

{
  char *__dest;
  int iVar1;
  char *q;
  char *p;
  char *buf;
  
  __dest = allocStr(name,-1);
  q = name;
  p = __dest;
  do {
    while( true ) {
      if (*q == '\0') {
        return __dest;
      }
      iVar1 = strncmp(p,"/../",4);
      if (iVar1 != 0) break;
      if ((p + -2 == __dest) && (iVar1 = strncmp(p + -2,"..",2), iVar1 == 0)) {
        p = p + 3;
        q = q + 3;
      }
      else if ((p + -3 < __dest) || (iVar1 = strncmp(p + -3,"/..",3), iVar1 != 0)) {
        do {
          if (p == __dest) break;
          p = p + -1;
        } while (*p != '/');
        *p = '\0';
        q = q + 3;
        strcat(__dest,q);
      }
      else {
        p = p + 3;
        q = q + 3;
      }
    }
    iVar1 = strcmp(p,"/..");
    if (iVar1 == 0) {
      if ((p + -2 == __dest) && (iVar1 = strncmp(p + -2,"..",2), iVar1 == 0)) {
        return __dest;
      }
      if ((__dest <= p + -3) && (iVar1 = strncmp(p + -3,"/..",3), iVar1 == 0)) {
        return __dest;
      }
      break;
    }
    iVar1 = strncmp(p,"/./",3);
    if (iVar1 == 0) {
      *p = '\0';
      q = q + 2;
      strcat(__dest,q);
    }
    else {
      iVar1 = strcmp(p,"/.");
      if (iVar1 == 0) {
        p[1] = '\0';
        return __dest;
      }
      iVar1 = strncmp(p,"//",2);
      if (iVar1 == 0) {
        *p = '\0';
        q = q + 1;
        strcat(__dest,q);
      }
      else {
        p = p + 1;
        q = q + 1;
      }
    }
  } while( true );
  while (p = p + -1, *p != '/') {
    if (p == __dest) break;
  }
  p[1] = '\0';
  return __dest;
}



char * expandPath(char *name)

{
  char *pcVar1;
  char *__name;
  int iVar2;
  char *q;
  Str extpath;
  passwd *passent;
  char *p;
  
  if (name == (char *)0x0) {
    name = (char *)0x0;
  }
  else if (*name == '~') {
    p = name + 1;
    if ((MYCTYPE_MAP[(byte)*p] & 4) == 0) {
      if ((*p != 0x2f) && (*p != 0)) {
        return name;
      }
      pcVar1 = getenv("HOME");
      extpath = Strnew_charp(pcVar1);
    }
    else {
      pcVar1 = strchr(p,0x2f);
      if (pcVar1 == (char *)0x0) {
        passent = (passwd *)getpwnam(p);
        p = "";
      }
      else {
        __name = allocStr(p,(int)pcVar1 - (int)p);
        passent = (passwd *)getpwnam(__name);
        p = pcVar1;
      }
      if (passent == (passwd *)0x0) {
        return name;
      }
      extpath = Strnew_charp(passent->pw_dir);
    }
    iVar2 = strcmp(extpath->ptr,"/");
    if ((iVar2 == 0) && (*p == '/')) {
      p = p + 1;
    }
    Strcat_charp(extpath,p);
    name = extpath->ptr;
  }
  return name;
}



int strcasematch(char *s1,char *s2)

{
  byte bVar1;
  byte bVar2;
  int x;
  
  for (; *s1 != '\0'; s1 = s1 + 1) {
    if (*s2 == '\0') {
      return 1;
    }
    if ((MYCTYPE_MAP[(byte)*s1] & 4) == 0) {
      bVar1 = *s1;
    }
    else {
      bVar1 = *s1 | 0x20;
    }
    if ((MYCTYPE_MAP[(byte)*s2] & 4) == 0) {
      bVar2 = *s2;
    }
    else {
      bVar2 = *s2 | 0x20;
    }
    if (bVar1 != bVar2) break;
    s2 = s2 + 1;
  }
  return (uint)(*s2 == '\0');
}



int strcasemstr(char *str,char **srch,char **ret_ptr)

{
  int iVar1;
  int i;
  
  do {
    if (*str == '\0') {
      return -1;
    }
    for (i = 0; srch[i] != (char *)0x0; i = i + 1) {
      iVar1 = strcasematch(str,srch[i]);
      if (iVar1 != 0) {
        if (ret_ptr == (char **)0x0) {
          return i;
        }
        *ret_ptr = str;
        return i;
      }
    }
    str = str + 1;
  } while( true );
}



char * remove_space(char *str)

{
  Str p_Var1;
  char *q;
  char *p;
  
  p = str;
  while ((*p != '\0' && ((MYCTYPE_MAP[(byte)*p] & 2) != 0))) {
    p = p + 1;
  }
  for (q = p; *q != '\0'; q = q + 1) {
  }
  while ((p < q && ((MYCTYPE_MAP[(byte)q[-1]] & 2) != 0))) {
    q = q + -1;
  }
  if (*q != '\0') {
    p_Var1 = Strnew_charp_n(p,(int)q - (int)p);
    p = p_Var1->ptr;
  }
  return p;
}



int non_null(char *s)

{
  if (s != (char *)0x0) {
    for (; *s != '\0'; s = s + 1) {
      if ((MYCTYPE_MAP[(byte)*s] & 2) == 0) {
        return 1;
      }
    }
  }
  return 0;
}



void cleanup_line(Str s,int mode)

{
  int iVar1;
  int i;
  
  if (((s->length < 2) || (s->ptr[s->length + -2] != '\r')) || (s->ptr[s->length + -1] != '\n')) {
    if ((s->length < 1) || (s->ptr[s->length + -1] != '\r')) {
      if ((s->length < 1) || (s->ptr[s->length + -1] != '\n')) {
        if (s->area_size <= s->length + 1) {
          Strgrow(s);
        }
        iVar1 = s->length;
        s->ptr[iVar1] = '\n';
        s->length = iVar1 + 1;
        s->ptr[s->length] = '\0';
      }
    }
    else {
      s->ptr[s->length + -1] = '\n';
    }
  }
  else {
    Strshrink(s,2);
    if (s->area_size <= s->length + 1) {
      Strgrow(s);
    }
    iVar1 = s->length;
    s->ptr[iVar1] = '\n';
    s->length = iVar1 + 1;
    s->ptr[s->length] = '\0';
  }
  if (mode != 1) {
    for (i = 0; i < s->length; i = i + 1) {
      if (s->ptr[i] == '\0') {
        s->ptr[i] = ' ';
      }
    }
  }
  return;
}



int getescapechar(char **str)

{
  byte *pbVar1;
  char *pcVar2;
  bool bVar3;
  char *pcVar4;
  char *pcVar5;
  int strict_entity;
  char *q;
  char *p;
  int dummy;
  
  p = *str;
  bVar3 = true;
  if (*p == '&') {
    p = p + 1;
  }
  pcVar4 = p;
  if (*p == '#') {
    pbVar1 = (byte *)(p + 1);
    if ((*pbVar1 == 0x78) || (*pbVar1 == 0x58)) {
      pbVar1 = (byte *)(p + 2);
      if ((MYCTYPE_MAP[*pbVar1] & 0x28) == 0) {
        *str = (char *)pbVar1;
        dummy = -1;
      }
      else {
        dummy = (int)MYCTYPE_DIGITMAP[*pbVar1];
        p = p + 3;
        while ((MYCTYPE_MAP[(byte)*p] & 0x28) != 0) {
          dummy = dummy * 0x10 + (uint)MYCTYPE_DIGITMAP[(byte)*p];
          p = p + 1;
        }
        if (*p == ';') {
          p = p + 1;
        }
        *str = p;
      }
    }
    else if ((MYCTYPE_MAP[*pbVar1] & 8) == 0) {
      *str = (char *)pbVar1;
      dummy = -1;
    }
    else {
      dummy = (int)MYCTYPE_DIGITMAP[*pbVar1];
      p = p + 2;
      while ((MYCTYPE_MAP[(byte)*p] & 8) != 0) {
        dummy = dummy * 10 + (uint)MYCTYPE_DIGITMAP[(byte)*p];
        p = p + 1;
      }
      if (*p == ';') {
        p = p + 1;
      }
      *str = p;
    }
  }
  else if ((MYCTYPE_MAP[(byte)*p] & 4) == 0) {
    *str = p;
    dummy = -1;
  }
  else {
    do {
      pcVar2 = p;
      p = pcVar2 + 1;
    } while ((MYCTYPE_MAP[(byte)*p] & 0xc) != 0);
    pcVar4 = allocStr(pcVar4,(int)p - (int)pcVar4);
    pcVar5 = strcasestr("lt gt amp quot nbsp",pcVar4);
    if ((pcVar5 != (char *)0x0) && (*p != '=')) {
      bVar3 = false;
    }
    if (*p == ';') {
      p = pcVar2 + 2;
    }
    else if (bVar3) {
      *str = p;
      return -1;
    }
    *str = p;
    dummy = getHash_si(&entity,pcVar4,-1);
  }
  return dummy;
}



char * getescapecmd(char **s)

{
  uint c;
  char *pcVar1;
  int ch;
  Str tmp;
  char *save;
  
  pcVar1 = *s;
  c = getescapechar(s);
  if ((int)c < 0) {
    if (*pcVar1 == '&') {
      tmp = Strnew();
    }
    else {
      tmp = Strnew_charp("&");
    }
    Strcat_charp_n(tmp,pcVar1,(int)*s - (int)pcVar1);
    pcVar1 = tmp->ptr;
  }
  else {
    pcVar1 = conv_entity(c);
  }
  return pcVar1;
}



char * html_quote(char *str)

{
  char *y;
  int iVar1;
  char *q;
  char *p;
  Str tmp;
  
  tmp = (Str)0x0;
  for (p = str; *p != '\0'; p = p + 1) {
    y = HTML_QUOTE_MAP[QUOTE_MAP[(byte)*p] & 7];
    if (y == (char *)0x0) {
      if (tmp != (Str)0x0) {
        if (tmp->area_size <= tmp->length + 1) {
          Strgrow(tmp);
        }
        iVar1 = tmp->length;
        tmp->ptr[iVar1] = *p;
        tmp->length = iVar1 + 1;
        tmp->ptr[tmp->length] = '\0';
      }
    }
    else {
      if (tmp == (Str)0x0) {
        tmp = Strnew_charp_n(str,(int)p - (int)str);
      }
      Strcat_charp(tmp,y);
    }
  }
  if (tmp != (Str)0x0) {
    str = tmp->ptr;
  }
  return str;
}



char * html_unquote(char *str)

{
  int iVar1;
  char *y;
  char *q;
  char *p;
  Str tmp;
  
  tmp = (Str)0x0;
  p = str;
  while (*p != '\0') {
    if (*p == '&') {
      if (tmp == (Str)0x0) {
        tmp = Strnew_charp_n(str,(int)p - (int)str);
      }
      y = getescapecmd(&p);
      Strcat_charp(tmp,y);
    }
    else {
      if (tmp != (Str)0x0) {
        if (tmp->area_size <= tmp->length + 1) {
          Strgrow(tmp);
        }
        iVar1 = tmp->length;
        tmp->ptr[iVar1] = *p;
        tmp->length = iVar1 + 1;
        tmp->ptr[tmp->length] = '\0';
      }
      p = p + 1;
    }
  }
  if (tmp != (Str)0x0) {
    str = tmp->ptr;
  }
  return str;
}



char * url_quote(char *str)

{
  int iVar1;
  char *p;
  Str tmp;
  
  tmp = (Str)0x0;
  for (p = str; *p != '\0'; p = p + 1) {
    if ((QUOTE_MAP[(byte)*p] & 0x10) == 0) {
      if (tmp != (Str)0x0) {
        if (tmp->area_size <= tmp->length + 1) {
          Strgrow(tmp);
        }
        iVar1 = tmp->length;
        tmp->ptr[iVar1] = *p;
        tmp->length = iVar1 + 1;
        tmp->ptr[tmp->length] = '\0';
      }
    }
    else {
      if (tmp == (Str)0x0) {
        tmp = Strnew_charp_n(str,(int)p - (int)str);
      }
      if (tmp->area_size <= tmp->length + 1) {
        Strgrow(tmp);
      }
      iVar1 = tmp->length;
      tmp->ptr[iVar1] = '%';
      tmp->length = iVar1 + 1;
      tmp->ptr[tmp->length] = '\0';
      if (tmp->area_size <= tmp->length + 1) {
        Strgrow(tmp);
      }
      iVar1 = tmp->length;
      tmp->ptr[iVar1] = xdigit[(byte)*p >> 4];
      tmp->length = iVar1 + 1;
      tmp->ptr[tmp->length] = '\0';
      if (tmp->area_size <= tmp->length + 1) {
        Strgrow(tmp);
      }
      iVar1 = tmp->length;
      tmp->ptr[iVar1] = xdigit[(byte)*p & 0xf];
      tmp->length = iVar1 + 1;
      tmp->ptr[tmp->length] = '\0';
    }
  }
  if (tmp != (Str)0x0) {
    str = tmp->ptr;
  }
  return str;
}



char * file_quote(char *str)

{
  int iVar1;
  char buf [4];
  char *p;
  Str tmp;
  
  tmp = (Str)0x0;
  for (p = str; *p != '\0'; p = p + 1) {
    if ((QUOTE_MAP[(byte)*p] & 0x30) == 0) {
      if (tmp != (Str)0x0) {
        if (tmp->area_size <= tmp->length + 1) {
          Strgrow(tmp);
        }
        iVar1 = tmp->length;
        tmp->ptr[iVar1] = *p;
        tmp->length = iVar1 + 1;
        tmp->ptr[tmp->length] = '\0';
      }
    }
    else {
      if (tmp == (Str)0x0) {
        tmp = Strnew_charp_n(str,(int)p - (int)str);
      }
      sprintf(buf,"%%%02X",(uint)(byte)*p);
      Strcat_charp(tmp,buf);
    }
  }
  if (tmp != (Str)0x0) {
    str = tmp->ptr;
  }
  return str;
}



char * file_unquote(char *str)

{
  int iVar1;
  uint uVar2;
  int c;
  char *q;
  char *p;
  Str tmp;
  
  tmp = (Str)0x0;
  p = str;
  do {
    while( true ) {
      if (*p == '\0') {
        if (tmp != (Str)0x0) {
          str = tmp->ptr;
        }
        return str;
      }
      if (*p == '%') break;
LAB_080b36fb:
      if (tmp != (Str)0x0) {
        if (tmp->area_size <= tmp->length + 1) {
          Strgrow(tmp);
        }
        iVar1 = tmp->length;
        tmp->ptr[iVar1] = *p;
        tmp->length = iVar1 + 1;
        tmp->ptr[tmp->length] = '\0';
      }
      p = p + 1;
    }
    q = p;
    if (((MYCTYPE_MAP[(byte)p[1]] & 0x28) == 0) || ((MYCTYPE_MAP[(byte)p[2]] & 0x28) == 0)) {
      uVar2 = 0xffffffff;
    }
    else {
      q = p + 3;
      uVar2 = (uint)MYCTYPE_DIGITMAP[(byte)p[2]] | (uint)MYCTYPE_DIGITMAP[(byte)p[1]] << 4;
    }
    if ((int)uVar2 < 0) goto LAB_080b36fb;
    if (tmp == (Str)0x0) {
      tmp = Strnew_charp_n(str,(int)p - (int)str);
    }
    if (((uVar2 != 0) && (uVar2 != 10)) && (uVar2 != 0xd)) {
      if (tmp->area_size <= tmp->length + 1) {
        Strgrow(tmp);
      }
      iVar1 = tmp->length;
      tmp->ptr[iVar1] = (char)uVar2;
      tmp->length = iVar1 + 1;
      tmp->ptr[tmp->length] = '\0';
    }
    p = q;
  } while( true );
}



Str Str_form_quote(Str x)

{
  char *pcVar1;
  int iVar2;
  int iVar3;
  char buf [4];
  char *ep;
  char *p;
  Str tmp;
  
  tmp = (Str)0x0;
  pcVar1 = x->ptr;
  iVar2 = x->length;
  for (p = x->ptr; p < pcVar1 + iVar2; p = p + 1) {
    if (*p == ' ') {
      if (tmp == (Str)0x0) {
        tmp = Strnew_charp_n(x->ptr,(int)p - (int)x->ptr);
      }
      if (tmp->area_size <= tmp->length + 1) {
        Strgrow(tmp);
      }
      iVar3 = tmp->length;
      tmp->ptr[iVar3] = '+';
      tmp->length = iVar3 + 1;
      tmp->ptr[tmp->length] = '\0';
    }
    else if ((QUOTE_MAP[(byte)*p] & 0x70) == 0) {
      if (tmp != (Str)0x0) {
        if (tmp->area_size <= tmp->length + 1) {
          Strgrow(tmp);
        }
        iVar3 = tmp->length;
        tmp->ptr[iVar3] = *p;
        tmp->length = iVar3 + 1;
        tmp->ptr[tmp->length] = '\0';
      }
    }
    else {
      if (tmp == (Str)0x0) {
        tmp = Strnew_charp_n(x->ptr,(int)p - (int)x->ptr);
      }
      sprintf(buf,"%%%02X",(uint)(byte)*p);
      Strcat_charp(tmp,buf);
    }
  }
  if (tmp != (Str)0x0) {
    x = tmp;
  }
  return x;
}



Str Str_url_unquote(Str x,int is_form,int safe)

{
  char *pcVar1;
  int iVar2;
  int iVar3;
  uint uVar4;
  int c;
  char *q;
  char *ep;
  char *p;
  Str tmp;
  
  tmp = (Str)0x0;
  p = x->ptr;
  pcVar1 = x->ptr;
  iVar2 = x->length;
  do {
    while( true ) {
      while( true ) {
        if (pcVar1 + iVar2 <= p) {
          if (tmp != (Str)0x0) {
            x = tmp;
          }
          return x;
        }
        if ((is_form == 0) || (*p != '+')) break;
        if (tmp == (Str)0x0) {
          tmp = Strnew_charp_n(x->ptr,(int)p - (int)x->ptr);
        }
        if (tmp->area_size <= tmp->length + 1) {
          Strgrow(tmp);
        }
        iVar3 = tmp->length;
        tmp->ptr[iVar3] = ' ';
        tmp->length = iVar3 + 1;
        tmp->ptr[tmp->length] = '\0';
        p = p + 1;
      }
      if (*p == '%') break;
LAB_080b3b06:
      if (tmp != (Str)0x0) {
        if (tmp->area_size <= tmp->length + 1) {
          Strgrow(tmp);
        }
        iVar3 = tmp->length;
        tmp->ptr[iVar3] = *p;
        tmp->length = iVar3 + 1;
        tmp->ptr[tmp->length] = '\0';
      }
      p = p + 1;
    }
    q = p;
    if (((MYCTYPE_MAP[(byte)p[1]] & 0x28) == 0) || ((MYCTYPE_MAP[(byte)p[2]] & 0x28) == 0)) {
      uVar4 = 0xffffffff;
    }
    else {
      q = p + 3;
      uVar4 = (uint)MYCTYPE_DIGITMAP[(byte)p[2]] | (uint)MYCTYPE_DIGITMAP[(byte)p[1]] << 4;
    }
    if (((int)uVar4 < 0) ||
       (((safe != 0 && ((MYCTYPE_MAP[uVar4 & 0xff] & 0x11) != 0)) &&
        ((QUOTE_MAP[uVar4 & 0xff] & 0x30) != 0)))) goto LAB_080b3b06;
    if (tmp == (Str)0x0) {
      tmp = Strnew_charp_n(x->ptr,(int)p - (int)x->ptr);
    }
    if (tmp->area_size <= tmp->length + 1) {
      Strgrow(tmp);
    }
    iVar3 = tmp->length;
    tmp->ptr[iVar3] = (char)uVar4;
    tmp->length = iVar3 + 1;
    tmp->ptr[tmp->length] = '\0';
    p = q;
  } while( true );
}



char * shell_quote(char *str)

{
  int iVar1;
  char *p;
  Str tmp;
  
  tmp = (Str)0x0;
  for (p = str; *p != '\0'; p = p + 1) {
    if ((QUOTE_MAP[(byte)*p] & 8) == 0) {
      if (tmp != (Str)0x0) {
        if (tmp->area_size <= tmp->length + 1) {
          Strgrow(tmp);
        }
        iVar1 = tmp->length;
        tmp->ptr[iVar1] = *p;
        tmp->length = iVar1 + 1;
        tmp->ptr[tmp->length] = '\0';
      }
    }
    else {
      if (tmp == (Str)0x0) {
        tmp = Strnew_charp_n(str,(int)p - (int)str);
      }
      if (tmp->area_size <= tmp->length + 1) {
        Strgrow(tmp);
      }
      iVar1 = tmp->length;
      tmp->ptr[iVar1] = '\\';
      tmp->length = iVar1 + 1;
      tmp->ptr[tmp->length] = '\0';
      if (tmp->area_size <= tmp->length + 1) {
        Strgrow(tmp);
      }
      iVar1 = tmp->length;
      tmp->ptr[iVar1] = *p;
      tmp->length = iVar1 + 1;
      tmp->ptr[tmp->length] = '\0';
    }
  }
  if (tmp != (Str)0x0) {
    str = tmp->ptr;
  }
  return str;
}



char * w3m_dir(char *name,char *dft)

{
  return dft;
}



char * w3m_auxbin_dir(void)

{
  char *pcVar1;
  
  pcVar1 = w3m_dir("W3M_AUXBIN_DIR","/usr/lib/w3m");
  return pcVar1;
}



char * w3m_lib_dir(void)

{
  char *pcVar1;
  
  pcVar1 = w3m_dir("W3M_LIB_DIR","/usr/lib/w3m/cgi-bin");
  return pcVar1;
}



char * w3m_etc_dir(void)

{
  char *pcVar1;
  
  pcVar1 = w3m_dir("W3M_ETC_DIR","/etc");
  return pcVar1;
}



char * w3m_conf_dir(void)

{
  char *pcVar1;
  
  pcVar1 = w3m_dir("W3M_CONF_DIR","/etc/w3m");
  return pcVar1;
}



char * w3m_help_dir(void)

{
  char *pcVar1;
  
  pcVar1 = w3m_dir("W3M_HELP_DIR","/usr/share/w3m");
  return pcVar1;
}



ListItem * newListItem(void *s,ListItem *n,ListItem *p)

{
  ListItem *pLVar1;
  ListItem *it;
  
  pLVar1 = (ListItem *)GC_malloc(0xc);
  pLVar1->ptr = s;
  pLVar1->next = n;
  pLVar1->prev = p;
  return pLVar1;
}



GeneralList * newGeneralList(void)

{
  GeneralList *pGVar1;
  GeneralList *tl;
  
  pGVar1 = (GeneralList *)GC_malloc(0xc);
  pGVar1->last = (ListItem *)0x0;
  pGVar1->first = pGVar1->last;
  pGVar1->nitem = 0;
  return pGVar1;
}



void pushValue(GeneralList *tl,void *s)

{
  ListItem *pLVar1;
  ListItem *it;
  
  if (s != (void *)0x0) {
    pLVar1 = newListItem(s,(ListItem *)0x0,tl->last);
    if (tl->first == (ListItem *)0x0) {
      tl->first = pLVar1;
      tl->last = pLVar1;
      tl->nitem = 1;
    }
    else {
      tl->last->next = pLVar1;
      tl->last = pLVar1;
      tl->nitem = tl->nitem + 1;
    }
  }
  return;
}



void * popValue(GeneralList *tl)

{
  ListItem *pLVar1;
  void *pvVar2;
  ListItem *f;
  
  if ((tl == (GeneralList *)0x0) || (tl->first == (ListItem *)0x0)) {
    pvVar2 = (void *)0x0;
  }
  else {
    pLVar1 = tl->first;
    tl->first = pLVar1->next;
    if (tl->first == (ListItem *)0x0) {
      tl->last = (ListItem *)0x0;
    }
    else {
      tl->first->prev = (_listitem *)0x0;
    }
    tl->nitem = tl->nitem + -1;
    pvVar2 = pLVar1->ptr;
  }
  return pvVar2;
}



void * rpopValue(GeneralList *tl)

{
  ListItem *pLVar1;
  void *pvVar2;
  ListItem *f;
  
  if ((tl == (GeneralList *)0x0) || (tl->last == (ListItem *)0x0)) {
    pvVar2 = (void *)0x0;
  }
  else {
    pLVar1 = tl->last;
    tl->last = pLVar1->prev;
    if (tl->last == (ListItem *)0x0) {
      tl->first = (ListItem *)0x0;
    }
    else {
      tl->last->next = (_listitem *)0x0;
    }
    tl->nitem = tl->nitem + -1;
    pvVar2 = pLVar1->ptr;
  }
  return pvVar2;
}



void delValue(GeneralList *tl,ListItem *it)

{
  if (it->prev == (_listitem *)0x0) {
    tl->first = it->next;
  }
  else {
    it->prev->next = it->next;
  }
  if (it->next == (_listitem *)0x0) {
    tl->last = it->prev;
  }
  else {
    it->next->prev = it->prev;
  }
  tl->nitem = tl->nitem + -1;
  return;
}



GeneralList * appendGeneralList(GeneralList *tl,GeneralList *tl2)

{
  if ((tl != (GeneralList *)0x0) && (tl2 != (GeneralList *)0x0)) {
    if (tl2->first != (ListItem *)0x0) {
      if (tl->last == (ListItem *)0x0) {
        tl->first = tl2->first;
        tl->last = tl2->last;
        tl->nitem = tl2->nitem;
      }
      else {
        tl->last->next = tl2->first;
        tl2->first->prev = tl->last;
        tl->last = tl2->last;
        tl->nitem = tl->nitem + tl2->nitem;
      }
    }
    tl2->last = (ListItem *)0x0;
    tl2->first = tl2->last;
    tl2->nitem = 0;
  }
  return tl;
}



TextLine * newTextLine(Str line,int pos)

{
  TextLine *pTVar1;
  Str p_Var2;
  TextLine *lbuf;
  
  pTVar1 = (TextLine *)GC_malloc(8);
  if (line == (Str)0x0) {
    p_Var2 = Strnew();
    pTVar1->line = p_Var2;
  }
  else {
    pTVar1->line = line;
  }
  pTVar1->pos = (short)pos;
  return pTVar1;
}



void appendTextLine(TextLineList *tl,Str line,int pos)

{
  Str line_00;
  TextLine *pTVar1;
  TextLine *lbuf;
  
  if (tl->last == (TextLineListItem *)0x0) {
    line_00 = Strdup(line);
    pTVar1 = newTextLine(line_00,pos);
    pushValue((GeneralList *)tl,pTVar1);
  }
  else {
    pTVar1 = tl->last->ptr;
    if (pTVar1->line == (Str)0x0) {
      pTVar1->line = line;
    }
    else {
      Strcat(pTVar1->line,line);
    }
    pTVar1->pos = pTVar1->pos + (short)pos;
  }
  return;
}



char * tag_get_value(parsed_tagarg *t,char *arg)

{
  int iVar1;
  
  while( true ) {
    if (t == (parsed_tagarg *)0x0) {
      return (char *)0x0;
    }
    iVar1 = strcasecmp(t->arg,arg);
    if (iVar1 == 0) break;
    t = t->next;
  }
  return t->value;
}



int tag_exists(parsed_tagarg *t,char *arg)

{
  int iVar1;
  
  while( true ) {
    if (t == (parsed_tagarg *)0x0) {
      return 0;
    }
    iVar1 = strcasecmp(t->arg,arg);
    if (iVar1 == 0) break;
    t = t->next;
  }
  return 1;
}



parsed_tagarg * cgistr2tagarg(char *cgistr)

{
  int iVar1;
  parsed_tagarg *ppVar2;
  Str p_Var3;
  parsed_tagarg *t;
  parsed_tagarg *t0;
  Str value;
  Str tag;
  
  t0 = (parsed_tagarg *)0x0;
  do {
    ppVar2 = (parsed_tagarg *)GC_malloc(0xc);
    ppVar2->next = t0;
    p_Var3 = Strnew();
    while (((*cgistr != '\0' && (*cgistr != '=')) && (*cgistr != '&'))) {
      if (p_Var3->area_size <= p_Var3->length + 1) {
        Strgrow(p_Var3);
      }
      iVar1 = p_Var3->length;
      p_Var3->ptr[iVar1] = *cgistr;
      p_Var3->length = iVar1 + 1;
      cgistr = cgistr + 1;
      p_Var3->ptr[p_Var3->length] = '\0';
    }
    p_Var3 = Str_url_unquote(p_Var3,1,0);
    ppVar2->arg = p_Var3->ptr;
    ppVar2->value = (char *)0x0;
    if (*cgistr == '\0') {
      return ppVar2;
    }
    if (*cgistr == '=') {
      p_Var3 = Strnew();
      while ((cgistr = cgistr + 1, *cgistr != '\0' && (*cgistr != '&'))) {
        if (p_Var3->area_size <= p_Var3->length + 1) {
          Strgrow(p_Var3);
        }
        iVar1 = p_Var3->length;
        p_Var3->ptr[iVar1] = *cgistr;
        p_Var3->length = iVar1 + 1;
        p_Var3->ptr[p_Var3->length] = '\0';
      }
      p_Var3 = Str_url_unquote(p_Var3,1,0);
      ppVar2->value = p_Var3->ptr;
    }
    else if (*cgistr == '&') {
      cgistr = cgistr + 1;
    }
    t0 = ppVar2;
  } while (*cgistr != '\0');
  return ppVar2;
}



uint hashfunc(char *s)

{
  uint h;
  
  h = 0;
  for (; *s != '\0'; s = s + 1) {
    if ((int)h < 0) {
      h = h << 1 | 1;
    }
    else {
      h = h << 1;
    }
    h = h + (int)*s;
  }
  return h;
}



Hash_si * newHash_si(int size)

{
  Hash_si *pHVar1;
  HashItem_si **ppHVar2;
  int i;
  Hash_si *hash;
  
  pHVar1 = (Hash_si *)GC_malloc(8);
  pHVar1->size = size;
  ppHVar2 = (HashItem_si **)GC_malloc(size << 2);
  pHVar1->tab = ppHVar2;
  for (i = 0; i < size; i = i + 1) {
    pHVar1->tab[i] = (HashItem_si *)0x0;
  }
  return pHVar1;
}



HashItem_si * lookupHash_si(Hash_si *t,char *key,int *hashval_return)

{
  uint uVar1;
  int iVar2;
  HashItem_si *hi;
  
  uVar1 = hashfunc(key);
  *hashval_return = uVar1 % (uint)t->size;
  hi = t->tab[*hashval_return];
  while( true ) {
    if (hi == (HashItem_si *)0x0) {
      return (HashItem_si *)0x0;
    }
    iVar2 = strcmp(hi->key,key);
    if (iVar2 == 0) break;
    hi = hi->next;
  }
  return hi;
}



void putHash_si(Hash_si *t,char *key,int value)

{
  HashItem_si *pHVar1;
  HashItem_si *hi;
  int h;
  
  pHVar1 = lookupHash_si(t,key,&h);
  if (pHVar1 == (HashItem_si *)0x0) {
    pHVar1 = (HashItem_si *)GC_malloc(0xc);
    pHVar1->key = key;
    pHVar1->value = value;
    pHVar1->next = t->tab[h];
    t->tab[h] = pHVar1;
  }
  else {
    pHVar1->value = value;
  }
  return;
}



int getHash_si(Hash_si *t,char *key,int failval)

{
  HashItem_si *pHVar1;
  HashItem_si *hi;
  int h;
  
  pHVar1 = lookupHash_si(t,key,&h);
  if (pHVar1 != (HashItem_si *)0x0) {
    failval = pHVar1->value;
  }
  return failval;
}



Hash_ss * newHash_ss(int size)

{
  Hash_ss *pHVar1;
  HashItem_ss **ppHVar2;
  int i;
  Hash_ss *hash;
  
  pHVar1 = (Hash_ss *)GC_malloc(8);
  pHVar1->size = size;
  ppHVar2 = (HashItem_ss **)GC_malloc(size << 2);
  pHVar1->tab = ppHVar2;
  for (i = 0; i < size; i = i + 1) {
    pHVar1->tab[i] = (HashItem_ss *)0x0;
  }
  return pHVar1;
}



HashItem_ss * lookupHash_ss(Hash_ss *t,char *key,int *hashval_return)

{
  uint uVar1;
  int iVar2;
  HashItem_ss *hi;
  
  uVar1 = hashfunc(key);
  *hashval_return = uVar1 % (uint)t->size;
  hi = t->tab[*hashval_return];
  while( true ) {
    if (hi == (HashItem_ss *)0x0) {
      return (HashItem_ss *)0x0;
    }
    iVar2 = strcmp(hi->key,key);
    if (iVar2 == 0) break;
    hi = hi->next;
  }
  return hi;
}



void putHash_ss(Hash_ss *t,char *key,char *value)

{
  HashItem_ss *pHVar1;
  HashItem_ss *hi;
  int h;
  
  pHVar1 = lookupHash_ss(t,key,&h);
  if (pHVar1 == (HashItem_ss *)0x0) {
    pHVar1 = (HashItem_ss *)GC_malloc(0xc);
    pHVar1->key = key;
    pHVar1->value = value;
    pHVar1->next = t->tab[h];
    t->tab[h] = pHVar1;
  }
  else {
    pHVar1->value = value;
  }
  return;
}



char * getHash_ss(Hash_ss *t,char *key,char *failval)

{
  HashItem_ss *pHVar1;
  HashItem_ss *hi;
  int h;
  
  pHVar1 = lookupHash_ss(t,key,&h);
  if (pHVar1 != (HashItem_ss *)0x0) {
    failval = pHVar1->value;
  }
  return failval;
}



Hash_sv * newHash_sv(int size)

{
  Hash_sv *pHVar1;
  HashItem_sv **ppHVar2;
  int i;
  Hash_sv *hash;
  
  pHVar1 = (Hash_sv *)GC_malloc(8);
  pHVar1->size = size;
  ppHVar2 = (HashItem_sv **)GC_malloc(size << 2);
  pHVar1->tab = ppHVar2;
  for (i = 0; i < size; i = i + 1) {
    pHVar1->tab[i] = (HashItem_sv *)0x0;
  }
  return pHVar1;
}



HashItem_sv * lookupHash_sv(Hash_sv *t,char *key,int *hashval_return)

{
  uint uVar1;
  int iVar2;
  HashItem_sv *hi;
  
  uVar1 = hashfunc(key);
  *hashval_return = uVar1 % (uint)t->size;
  hi = t->tab[*hashval_return];
  while( true ) {
    if (hi == (HashItem_sv *)0x0) {
      return (HashItem_sv *)0x0;
    }
    iVar2 = strcmp(hi->key,key);
    if (iVar2 == 0) break;
    hi = hi->next;
  }
  return hi;
}



void putHash_sv(Hash_sv *t,char *key,void *value)

{
  HashItem_sv *pHVar1;
  HashItem_sv *hi;
  int h;
  
  pHVar1 = lookupHash_sv(t,key,&h);
  if (pHVar1 == (HashItem_sv *)0x0) {
    pHVar1 = (HashItem_sv *)GC_malloc(0xc);
    pHVar1->key = key;
    pHVar1->value = value;
    pHVar1->next = t->tab[h];
    t->tab[h] = pHVar1;
  }
  else {
    pHVar1->value = value;
  }
  return;
}



void * getHash_sv(Hash_sv *t,char *key,void *failval)

{
  HashItem_sv *pHVar1;
  HashItem_sv *hi;
  int h;
  
  pHVar1 = lookupHash_sv(t,key,&h);
  if (pHVar1 != (HashItem_sv *)0x0) {
    failval = pHVar1->value;
  }
  return failval;
}



Hash_iv * newHash_iv(int size)

{
  Hash_iv *pHVar1;
  HashItem_iv **ppHVar2;
  int i;
  Hash_iv *hash;
  
  pHVar1 = (Hash_iv *)GC_malloc(8);
  pHVar1->size = size;
  ppHVar2 = (HashItem_iv **)GC_malloc(size << 2);
  pHVar1->tab = ppHVar2;
  for (i = 0; i < size; i = i + 1) {
    pHVar1->tab[i] = (HashItem_iv *)0x0;
  }
  return pHVar1;
}



HashItem_iv * lookupHash_iv(Hash_iv *t,int key,int *hashval_return)

{
  HashItem_iv *hi;
  
  *hashval_return = key % t->size;
  hi = t->tab[*hashval_return];
  while( true ) {
    if (hi == (HashItem_iv *)0x0) {
      return (HashItem_iv *)0x0;
    }
    if (hi->key == key) break;
    hi = hi->next;
  }
  return hi;
}



void putHash_iv(Hash_iv *t,int key,void *value)

{
  HashItem_iv *pHVar1;
  HashItem_iv *hi;
  int h;
  
  pHVar1 = lookupHash_iv(t,key,&h);
  if (pHVar1 == (HashItem_iv *)0x0) {
    pHVar1 = (HashItem_iv *)GC_malloc(0xc);
    pHVar1->key = key;
    pHVar1->value = value;
    pHVar1->next = t->tab[h];
    t->tab[h] = pHVar1;
  }
  else {
    pHVar1->value = value;
  }
  return;
}



void * getHash_iv(Hash_iv *t,int key,void *failval)

{
  HashItem_iv *pHVar1;
  HashItem_iv *hi;
  int h;
  
  pHVar1 = lookupHash_iv(t,key,&h);
  if (pHVar1 != (HashItem_iv *)0x0) {
    failval = pHVar1->value;
  }
  return failval;
}



void wc_char_conv_init(wc_ces f_ces,wc_ces t_ces)

{
  wc_input_init(f_ces,&char_conv_st);
  char_conv_t_ces = t_ces;
  char_conv_f_ces = f_ces;
  char_conv_st.state = -1;
  return;
}



Str wc_char_conv(char c)

{
  wc_ces t_ces;
  Str p_Var1;
  
  t_ces = char_conv_t_ces;
  p_Var1 = (*(char_conv_st.ces_info)->char_conv)((uint)(byte)c,&char_conv_st);
  p_Var1 = wc_Str_conv(p_Var1,0x310000,t_ces);
  return p_Var1;
}



wc_ces wc_guess_charset(char *charset,wc_ces orig)

{
  wc_ces wVar1;
  wc_ces guess;
  
  if (((charset != (char *)0x0) && (*charset != '\0')) &&
     (wVar1 = wc_charset_to_ces(charset), wVar1 != 0)) {
    orig = wVar1;
  }
  return orig;
}



wc_ces wc_guess_charset_short(char *charset,wc_ces orig)

{
  wc_ces wVar1;
  wc_ces guess;
  
  if (((charset != (char *)0x0) && (*charset != '\0')) &&
     (wVar1 = wc_charset_short_to_ces(charset), wVar1 != 0)) {
    orig = wVar1;
  }
  return orig;
}



wc_ces wc_guess_locale_charset(char *locale,wc_ces orig)

{
  wc_ces wVar1;
  wc_ces guess;
  
  if (((locale != (char *)0x0) && (*locale != '\0')) &&
     (wVar1 = wc_locale_to_ces(locale), wVar1 != 0)) {
    orig = wVar1;
  }
  return orig;
}



wc_ces wc_charset_to_ces(char *charset)

{
  int iVar1;
  uint uVar2;
  wc_ces wVar3;
  int in_GS_OFFSET;
  int n;
  char *p;
  char buf [16];
  int local_10;
  
  local_10 = *(int *)(in_GS_OFFSET + 0x14);
  p = charset;
  iVar1 = tolower((int)*charset);
  if ((iVar1 == 0x78) && (charset[1] == '-')) {
    p = charset + 2;
  }
  n = 0;
  while ((*p != '\0' && (n < 0xf))) {
    if ((0x20 < (byte)*p) && ((*p != '_' && (*p != '-')))) {
      iVar1 = tolower((int)*p);
      buf[n] = (char)iVar1;
      n = n + 1;
    }
    p = p + 1;
  }
  buf[n] = '\0';
  p = buf;
  switch(buf[0]) {
  case 'a':
    iVar1 = strncmp(p,"ascii",5);
    if (iVar1 == 0) {
      wVar3 = 0x100;
      goto LAB_080b5673;
    }
    break;
  case 'b':
    iVar1 = strncmp(p,"big5hkscs",9);
    if (iVar1 == 0) {
      wVar3 = 0x30203e;
      goto LAB_080b5673;
    }
    iVar1 = strncmp(p,"big5",4);
    if (iVar1 == 0) {
      wVar3 = 0x30203d;
      goto LAB_080b5673;
    }
    break;
  case 'c':
    iVar1 = strncmp(p,"cngb",4);
    if (iVar1 == 0) {
      wVar3 = 0x301017;
      goto LAB_080b5673;
    }
    if (buf[1] == 'p') {
      iVar1 = atoi(buf + 2);
      if (iVar1 == 0x365) {
        wVar3 = 0x100429;
        goto LAB_080b5673;
      }
      if (iVar1 < 0x366) {
        if (iVar1 == 0x359) {
          wVar3 = 0x100421;
          goto LAB_080b5673;
        }
        if (iVar1 < 0x35a) {
          if (iVar1 == 0x352) {
            wVar3 = 0x10041d;
            goto LAB_080b5673;
          }
          if (iVar1 < 0x353) {
            if (iVar1 == 0x2e1) {
              wVar3 = 0x10041b;
              goto LAB_080b5673;
            }
            if (iVar1 == 0x307) {
              wVar3 = 0x10041c;
              goto LAB_080b5673;
            }
            if (iVar1 == 0x1b5) {
              wVar3 = 0x10041a;
              goto LAB_080b5673;
            }
          }
          else {
            if (iVar1 == 0x357) {
              wVar3 = 0x10041f;
              goto LAB_080b5673;
            }
            if (0x357 < iVar1) {
              wVar3 = 0x100420;
              goto LAB_080b5673;
            }
            if (iVar1 == 0x354) {
              wVar3 = 0x10041e;
              goto LAB_080b5673;
            }
          }
        }
        else {
          if (iVar1 == 0x35f) {
            wVar3 = 0x100425;
            goto LAB_080b5673;
          }
          if (iVar1 < 0x360) {
            if (iVar1 == 0x35d) {
              wVar3 = 0x100423;
              goto LAB_080b5673;
            }
            if (0x35d < iVar1) {
              wVar3 = 0x100424;
              goto LAB_080b5673;
            }
            if (iVar1 == 0x35c) {
              wVar3 = 0x100422;
              goto LAB_080b5673;
            }
          }
          else {
            if (iVar1 == 0x361) {
              wVar3 = 0x100427;
              goto LAB_080b5673;
            }
            if (iVar1 < 0x361) {
              wVar3 = 0x100426;
              goto LAB_080b5673;
            }
            if (iVar1 == 0x362) {
              wVar3 = 0x100428;
              goto LAB_080b5673;
            }
          }
        }
      }
      else {
        if (iVar1 == 0x4e3) {
          wVar3 = 0x10042d;
          goto LAB_080b5673;
        }
        if (iVar1 < 0x4e4) {
          if (iVar1 == 0x3b5) {
            wVar3 = 0x30203f;
            goto LAB_080b5673;
          }
          if (iVar1 < 0x3b6) {
            if (iVar1 == 0x3a4) {
              wVar3 = 0x302038;
              goto LAB_080b5673;
            }
            if (iVar1 == 0x3a8) {
              wVar3 = 0x30203a;
              goto LAB_080b5673;
            }
            if (iVar1 == 0x36a) {
              wVar3 = 0x10042a;
              goto LAB_080b5673;
            }
          }
          else {
            if (iVar1 == 0x3ee) {
              wVar3 = 0x10042b;
              goto LAB_080b5673;
            }
            if (iVar1 == 0x4e2) {
              wVar3 = 0x10042c;
              goto LAB_080b5673;
            }
            if (iVar1 == 0x3b6) {
              wVar3 = 0x30203d;
              goto LAB_080b5673;
            }
          }
        }
        else {
          if (iVar1 == 0x4e7) {
            wVar3 = 0x100431;
            goto LAB_080b5673;
          }
          if (iVar1 < 0x4e8) {
            if (iVar1 == 0x4e5) {
              wVar3 = 0x10042f;
            }
            else if (iVar1 < 0x4e6) {
              wVar3 = 0x10042e;
            }
            else {
              wVar3 = 0x100430;
            }
            goto LAB_080b5673;
          }
          if (iVar1 == 0x4e9) {
            wVar3 = 0x100433;
            goto LAB_080b5673;
          }
          if (iVar1 < 0x4e9) {
            wVar3 = 0x100432;
            goto LAB_080b5673;
          }
          if (iVar1 == 0x4ea) {
            wVar3 = 0x100441;
            goto LAB_080b5673;
          }
        }
      }
    }
    break;
  case 'e':
    iVar1 = strncmp(p,"euc",3);
    if (iVar1 == 0) {
      if (buf[3] == 'j') {
        wVar3 = 0x301016;
        goto LAB_080b5673;
      }
      if (buf[3] < 'k') {
        if (buf[3] == 'c') {
          wVar3 = 0x301017;
          goto LAB_080b5673;
        }
      }
      else {
        if (buf[3] == 'k') {
          wVar3 = 0x301019;
          goto LAB_080b5673;
        }
        if (buf[3] == 't') {
          wVar3 = 0x301018;
          goto LAB_080b5673;
        }
      }
      switch(WcLocale) {
      default:
        wVar3 = 0x301016;
        break;
      case 1:
        wVar3 = 0x301016;
        break;
      case 2:
        wVar3 = 0x301017;
        break;
      case 3:
        wVar3 = 0x301018;
        break;
      case 4:
        wVar3 = 0x301017;
        break;
      case 5:
        wVar3 = 0x301019;
      }
      goto LAB_080b5673;
    }
    break;
  case 'g':
    iVar1 = strncmp(p,"gb18030",7);
    if ((iVar1 == 0) || (iVar1 = strncmp(p,"gbk2k",5), iVar1 == 0)) {
      wVar3 = 0x30203b;
      goto LAB_080b5673;
    }
    iVar1 = strncmp(p,"gbk",3);
    if (iVar1 == 0) {
      wVar3 = 0x30203a;
      goto LAB_080b5673;
    }
    iVar1 = strncmp(p,"gb2312",6);
    if (iVar1 == 0) {
      wVar3 = 0x301017;
      goto LAB_080b5673;
    }
    break;
  case 'h':
    iVar1 = strncmp(p,"hz",2);
    if (iVar1 == 0) {
      wVar3 = 0x20203c;
      goto LAB_080b5673;
    }
    iVar1 = strncmp(p,"hkscs",5);
    if (iVar1 == 0) {
      wVar3 = 0x30203e;
      goto LAB_080b5673;
    }
    break;
  case 'i':
    iVar1 = strncmp(p,"iso2022",7);
    if (iVar1 == 0) {
      if (buf[7] == 'j') {
        iVar1 = strncmp(buf + 7,"jp2",3);
        if (iVar1 == 0) {
          wVar3 = 0x200812;
        }
        else {
          iVar1 = strncmp(buf + 7,"jp3",3);
          if (iVar1 == 0) {
            wVar3 = 0x200813;
          }
          else {
            wVar3 = 0x200811;
          }
        }
      }
      else if (buf[7] == 'k') {
        wVar3 = 0x200815;
      }
      else if (buf[7] == 'c') {
        wVar3 = 0x200814;
      }
      else {
        wVar3 = 0x200811;
      }
      goto LAB_080b5673;
    }
    iVar1 = strncmp(p,"iso8859",7);
    if (iVar1 == 0) {
      uVar2 = atoi(buf + 7);
      if ((((int)uVar2 < 1) || (0x10 < (int)uVar2)) || (uVar2 == 0xc)) {
        wVar3 = 0x100201;
      }
      else {
        wVar3 = uVar2 | 0x100200;
      }
      goto LAB_080b5673;
    }
    break;
  case 'j':
    iVar1 = strncmp(p,"johab",5);
    if (iVar1 == 0) {
      wVar3 = 0x302040;
      goto LAB_080b5673;
    }
    iVar1 = strncmp(p,"jis",3);
    if (iVar1 == 0) {
      wVar3 = 0x200811;
      goto LAB_080b5673;
    }
    break;
  case 'k':
    iVar1 = strncmp(p,"koi8r",5);
    if (iVar1 == 0) {
      wVar3 = 0x100434;
      goto LAB_080b5673;
    }
    iVar1 = strncmp(p,"koi8u",5);
    if (iVar1 == 0) {
      wVar3 = 0x100435;
      goto LAB_080b5673;
    }
    iVar1 = strncmp(p,"ksx1001",7);
    if (iVar1 == 0) {
      wVar3 = 0x301019;
      goto LAB_080b5673;
    }
    iVar1 = strncmp(p,"ksc5601",7);
    if (iVar1 == 0) {
      wVar3 = 0x301019;
      goto LAB_080b5673;
    }
    break;
  case 'n':
    iVar1 = strncmp(p,"next",4);
    if (iVar1 == 0) {
      wVar3 = 0x100436;
      goto LAB_080b5673;
    }
    break;
  case 's':
    iVar1 = strncmp(p,"shiftjisx0213",0xd);
    if ((iVar1 == 0) || (iVar1 = strncmp(p,"sjisx0213",9), iVar1 == 0)) {
      wVar3 = 0x302039;
      goto LAB_080b5673;
    }
    iVar1 = strncmp(p,"shiftjis",8);
    if ((iVar1 == 0) || (iVar1 = strncmp(p,"sjis",4), iVar1 == 0)) {
      wVar3 = 0x302038;
      goto LAB_080b5673;
    }
    break;
  case 't':
    iVar1 = strncmp(p,"tis620",6);
    if (iVar1 == 0) {
      wVar3 = 0x10020b;
      goto LAB_080b5673;
    }
    iVar1 = strncmp(p,"tcvn",4);
    if (iVar1 == 0) {
      wVar3 = 0x104442;
      goto LAB_080b5673;
    }
    break;
  case 'u':
    iVar1 = strncmp(p,"utf8",4);
    if (iVar1 == 0) {
      wVar3 = 0x308045;
      goto LAB_080b5673;
    }
    iVar1 = strncmp(p,"utf7",4);
    if (iVar1 == 0) {
      wVar3 = 0x208046;
      goto LAB_080b5673;
    }
    iVar1 = strncmp(p,"uhc",3);
    if (iVar1 == 0) {
      wVar3 = 0x30203f;
      goto LAB_080b5673;
    }
    iVar1 = strncmp(p,"ujis",4);
    if (iVar1 == 0) {
      wVar3 = 0x301016;
      goto LAB_080b5673;
    }
    iVar1 = strncmp(p,"usascii",7);
    if (iVar1 == 0) {
      wVar3 = 0x100;
      goto LAB_080b5673;
    }
    break;
  case 'v':
    iVar1 = strncmp(p,"viet",4);
    if (iVar1 == 0) {
      p = buf + 4;
      iVar1 = strncmp(p,"tcvn",4);
      if (iVar1 == 0) {
        wVar3 = 0x104442;
        goto LAB_080b5673;
      }
    }
    iVar1 = strncmp(p,"viscii",6);
    if (iVar1 == 0) {
      wVar3 = 0x104443;
      goto LAB_080b5673;
    }
    iVar1 = strncmp(p,"vps",3);
    if (iVar1 == 0) {
      wVar3 = 0x104444;
      goto LAB_080b5673;
    }
    break;
  case 'w':
    iVar1 = strncmp(p,"windows",7);
    if (iVar1 == 0) {
      iVar1 = strncmp(p,"31j",3);
      if (iVar1 == 0) {
        wVar3 = 0x302038;
        goto LAB_080b5673;
      }
      iVar1 = atoi(buf + 7);
      switch(iVar1) {
      case 0x4e2:
        wVar3 = 0x10042c;
        break;
      case 0x4e3:
        wVar3 = 0x10042d;
        break;
      case 0x4e4:
        wVar3 = 0x10042e;
        break;
      case 0x4e5:
        wVar3 = 0x10042f;
        break;
      case 0x4e6:
        wVar3 = 0x100430;
        break;
      case 0x4e7:
        wVar3 = 0x100431;
        break;
      case 0x4e8:
        wVar3 = 0x100432;
        break;
      case 0x4e9:
        wVar3 = 0x100433;
        break;
      case 0x4ea:
        wVar3 = 0x100441;
        break;
      default:
        goto switchD_080b4b89_caseD_64;
      }
      goto LAB_080b5673;
    }
  }
switchD_080b4b89_caseD_64:
  wVar3 = 0;
LAB_080b5673:
  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {
    return wVar3;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



wc_ces wc_charset_short_to_ces(char *charset)

{
  wc_ces wVar1;
  int iVar2;
  uint uVar3;
  int in_GS_OFFSET;
  int n;
  wc_ces ces;
  char *p;
  char buf [16];
  int local_10;
  
  local_10 = *(int *)(in_GS_OFFSET + 0x14);
  p = charset;
  wVar1 = wc_charset_to_ces(charset);
  if (wVar1 != 0) goto LAB_080b5982;
  n = 0;
  while ((*p != '\0' && (n < 0xf))) {
    if ((0x20 < (byte)*p) && ((*p != '_' && (*p != '-')))) {
      iVar2 = tolower((int)*p);
      buf[n] = (char)iVar2;
      n = n + 1;
    }
    p = p + 1;
  }
  buf[n] = '\0';
  switch(buf[0]) {
  case 'a':
    wVar1 = 0x100;
    break;
  case 'b':
    wVar1 = 0x30203d;
    break;
  case 'c':
    wVar1 = 0x200814;
    break;
  default:
switchD_080b5745_caseD_64:
    wVar1 = 0;
    break;
  case 'e':
    if (buf[1] == 'j') {
      wVar1 = 0x301016;
    }
    else {
      if (buf[1] < 'k') {
        if (buf[1] == 'c') {
          wVar1 = 0x301017;
          break;
        }
      }
      else {
        if (buf[1] == 'k') {
          wVar1 = 0x301019;
          break;
        }
        if (buf[1] == 't') {
          wVar1 = 0x301018;
          break;
        }
      }
      wVar1 = 0x301016;
    }
    break;
  case 'g':
    wVar1 = 0x301017;
    break;
  case 'h':
    if (buf[1] == 'k') {
      wVar1 = 0x30203e;
    }
    else {
      wVar1 = 0x20203c;
    }
    break;
  case 'j':
    p = buf + 1;
    if (buf[1] == 'o') {
      wVar1 = 0x302040;
    }
    else {
      if (buf[1] == 'p') {
        p = buf + 2;
      }
      if (*p == '2') {
        wVar1 = 0x200812;
      }
      else if (*p == '3') {
        wVar1 = 0x200813;
      }
      else {
        wVar1 = 0x200811;
      }
    }
    break;
  case 'k':
    if (buf[1] == 'o') {
      wVar1 = 0x100434;
    }
    else {
      wVar1 = 0x200815;
    }
    break;
  case 'l':
    uVar3 = atoi(buf + 1);
    if ((((int)uVar3 < 1) || (0x10 < (int)uVar3)) || (uVar3 == 0xc)) {
      wVar1 = 0x100201;
    }
    else {
      wVar1 = uVar3 | 0x100200;
    }
    break;
  case 'n':
    wVar1 = 0x100436;
    break;
  case 'r':
    wVar1 = 0x100437;
    break;
  case 's':
    wVar1 = 0x302038;
    break;
  case 't':
    if (buf[1] == 'c') {
      wVar1 = 0x104442;
    }
    else {
      wVar1 = 0x10020b;
    }
    break;
  case 'u':
    if (buf[1] == '7') {
      wVar1 = 0x208046;
    }
    else {
      wVar1 = 0x308045;
    }
    break;
  case 'v':
    if (buf[1] == 'p') {
      wVar1 = 0x104444;
    }
    else {
      wVar1 = 0x104443;
    }
    break;
  case 'w':
    iVar2 = atoi(buf + 1);
    switch(iVar2) {
    case 0x4e2:
      wVar1 = 0x10042c;
      break;
    case 0x4e3:
      wVar1 = 0x10042d;
      break;
    case 0x4e4:
      wVar1 = 0x10042e;
      break;
    case 0x4e5:
      wVar1 = 0x10042f;
      break;
    case 0x4e6:
      wVar1 = 0x100430;
      break;
    case 0x4e7:
      wVar1 = 0x100431;
      break;
    case 0x4e8:
      wVar1 = 0x100432;
      break;
    case 0x4e9:
      wVar1 = 0x100433;
      break;
    case 0x4ea:
      wVar1 = 0x100441;
      break;
    default:
      goto switchD_080b5745_caseD_64;
    }
  }
LAB_080b5982:
  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {
    return wVar1;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



wc_ces wc_locale_to_ces(char *locale)

{
  wc_ces wVar1;
  char *__s1;
  int iVar2;
  char buf [6];
  char *cs;
  int n;
  char *p;
  
  p = locale;
  if ((*locale == 'C') && (locale[1] == '\0')) {
    wVar1 = 0x100;
  }
  else {
    __s1 = nl_langinfo(0xe);
    if ((__s1 != (char *)0x0) && (iVar2 = strcmp(__s1,"US-ASCII"), iVar2 != 0)) {
      wVar1 = wc_charset_to_ces(__s1);
      return wVar1;
    }
    n = 0;
    while (((*p != '\0' && (*p != '.')) && (n < 5))) {
      if (0x20 < (byte)*p) {
        iVar2 = tolower((int)*p);
        buf[n] = (char)iVar2;
        n = n + 1;
      }
      p = p + 1;
    }
    buf[n] = '\0';
    if (*p == '.') {
      iVar2 = strcasecmp(p + 1,"euc");
      if (iVar2 == 0) {
        if (buf[0] == 'k') {
          WcLocale = 5;
        }
        else if (buf[0] == 'z') {
          iVar2 = strcmp(buf,"zh_tw");
          if (iVar2 == 0) {
            WcLocale = 3;
          }
          else {
            iVar2 = strcmp(buf,"zh_hk");
            if (iVar2 == 0) {
              WcLocale = 4;
            }
            else {
              WcLocale = 2;
            }
          }
        }
        else if (buf[0] == 'j') {
          WcLocale = 1;
        }
        else {
          WcLocale = 0;
        }
      }
      wVar1 = wc_charset_to_ces(p + 1);
    }
    else {
      iVar2 = strcmp(buf,"japanese");
      if (iVar2 == 0) {
        wVar1 = 0x302038;
      }
      else {
        iVar2 = strcmp(buf,"zh_tw");
        if ((iVar2 != 0) && (iVar2 = strcmp(buf,"zh_hk"), iVar2 != 0)) {
          n = 0;
          while( true ) {
            if (lang_ces_table[n].lang == (char *)0x0) {
              return 0x100201;
            }
            iVar2 = strncmp(buf,lang_ces_table[n].lang,2);
            if (iVar2 == 0) break;
            n = n + 1;
          }
          return lang_ces_table[n].ces;
        }
        wVar1 = 0x30203d;
      }
    }
  }
  return wVar1;
}



char * wc_ces_to_charset(wc_ces ces)

{
  char *pcVar1;
  
  if (ces == 0x310000) {
    pcVar1 = "WTF";
  }
  else {
    pcVar1 = WcCesInfo[ces & 0xff].name;
  }
  return pcVar1;
}



char * wc_ces_to_charset_desc(wc_ces ces)

{
  char *pcVar1;
  
  if (ces == 0x310000) {
    pcVar1 = "W3M Transfer Format";
  }
  else {
    pcVar1 = WcCesInfo[ces & 0xff].desc;
  }
  return pcVar1;
}



wc_ces wc_guess_8bit_charset(wc_ces orig)

{
  if (orig < 0x200814) {
    if (orig < 0x200811) {
      if (orig == 0x100) {
        orig = 0x100201;
      }
    }
    else {
      orig = 0x301016;
    }
  }
  else if (orig == 0x200815) {
    orig = 0x301019;
  }
  else if ((orig < 0x200815) || (orig == 0x20203c)) {
    orig = 0x301017;
  }
  return orig;
}



wc_bool wc_check_ces(wc_ces ces)

{
  wc_bool wVar1;
  size_t i;
  
  if (((ces & 0xff) < 0x47) && (WcCesInfo[ces & 0xff].id == ces)) {
    wVar1 = '\x01';
  }
  else {
    wVar1 = '\0';
  }
  return wVar1;
}



int wc_ces_list_cmp(void *a,void *b)

{
  int iVar1;
  
  iVar1 = strcasecmp(*(char **)((int)a + 8),*(char **)((int)b + 8));
  return iVar1;
}



wc_ces_list * wc_get_ces_list(void)

{
  size_t n;
  wc_ces_info *info;
  
  if (list == (wc_ces_list *)0x0) {
    n = 0;
    for (info = WcCesInfo; info->id != 0; info = info + 1) {
      if (info->name != (char *)0x0) {
        n = n + 1;
      }
    }
    list = (wc_ces_list *)GC_malloc((n + 1) * 0xc);
    n = 0;
    for (info = WcCesInfo; info->id != 0; info = info + 1) {
      if (info->name != (char *)0x0) {
        list[n].id = info->id;
        list[n].name = info->name;
        list[n].desc = info->desc;
        n = n + 1;
      }
    }
    list[n].id = 0;
    list[n].name = (char *)0x0;
    list[n].desc = (char *)0x0;
    qsort(list,n,0xc,wc_ces_list_cmp);
  }
  return list;
}



Str wc_Str_conv(Str is,wc_ces f_ces,wc_ces t_ces)

{
  if (f_ces != 0x310000) {
    is = (*WcCesInfo[f_ces & 0xff].conv_from)(is,f_ces);
  }
  if (t_ces != 0x310000) {
    is = wc_conv_to_ces(is,t_ces);
  }
  return is;
}



Str wc_Str_conv_strict(Str is,wc_ces f_ces,wc_ces t_ces)

{
  undefined4 uVar1;
  uint uVar2;
  undefined4 uVar3;
  uint uVar4;
  Str p_Var5;
  wc_option opt;
  Str os;
  
  uVar4 = WcOption._12_4_;
  uVar3 = WcOption._8_4_;
  uVar2 = WcOption._4_4_;
  uVar1 = WcOption._0_4_;
  WcOption._12_4_ = CONCAT31(WcOption._13_3_,1);
  WcOption._12_3_ = CONCAT12(1,WcOption._12_2_);
  WcOption._12_4_ = uVar4 & 0xff000000 | (uint)WcOption._12_3_;
  WcOption._4_4_ = WcOption._4_4_ & 0xffff00ff;
  p_Var5 = wc_Str_conv(is,f_ces,t_ces);
  WcOption._0_4_ = uVar1;
  WcOption._4_4_ = uVar2;
  WcOption._8_4_ = uVar3;
  WcOption._12_4_ = uVar4;
  return p_Var5;
}



Str wc_conv_to_ces(Str is,wc_ces ces)

{
  anon_subr_void_varargs_for_push_to *paVar1;
  int iVar2;
  wc_status st;
  wc_uchar *local_2c;
  undefined4 local_28;
  wc_uchar *local_24;
  undefined4 local_20;
  wc_uchar *p;
  wc_uchar *ep;
  wc_uchar *sp;
  Str os;
  
  sp = (wc_uchar *)is->ptr;
  ep = sp + is->length;
  p = sp;
  if (ces < 0x104442) {
LAB_080b5f9b:
    for (; (p < ep && (-1 < (char)*p)); p = p + 1) {
    }
  }
  else if (ces < 0x104445) {
    for (; ((p < ep && (0x1f < *p)) && (-1 < (char)*p)); p = p + 1) {
    }
  }
  else {
    if (ces != 0x20203c) goto LAB_080b5f9b;
    for (; ((p < ep && (*p != '~')) && (-1 < (char)*p)); p = p + 1) {
    }
  }
  if (p == ep) {
    return is;
  }
  os = Strnew_size(is->length);
  if (sp < p) {
    p = p + -1;
  }
  if (sp < p) {
    Strcat_charp_n(os,is->ptr,(int)p - (int)sp);
  }
  wc_output_init(ces,&st);
  if (ces < 0x200816) {
    if ((ces < 0x200811) && (2 < ces - 0x104442)) {
LAB_080b6169:
      while (p < ep) {
        if (((char)*p < '\0') || (WTF_WIDTH_MAP[p[1]] == '\0')) {
          paVar1 = (st.ces_info)->push_to;
          wtf_parse(&local_2c);
          (*paVar1)(os,local_2c,local_28,&st);
        }
        else {
          if (os->area_size <= os->length + 1) {
            Strgrow(os);
          }
          iVar2 = os->length;
          os->ptr[iVar2] = *p;
          os->length = iVar2 + 1;
          os->ptr[os->length] = '\0';
          p = p + 1;
        }
      }
      goto LAB_080b6175;
    }
  }
  else if (((ces != 0x208046) && (ces != 0x308045)) && (ces != 0x20203c)) goto LAB_080b6169;
  while (p < ep) {
    paVar1 = (st.ces_info)->push_to;
    wtf_parse(&local_24);
    (*paVar1)(os,local_24,local_20,&st);
  }
LAB_080b6175:
  wc_push_end(os,&st);
  return os;
}



Str wc_Str_conv_with_detect(Str is,wc_ces *f_ces,wc_ces hint,wc_ces t_ces)

{
  Str p_Var1;
  wc_ces detect;
  
  if ((*f_ces == 0x310000) || (hint == 0x310000)) {
    *f_ces = 0x310000;
    detect = 0x310000;
  }
  else if (WcOption.auto_detect == '\0') {
    *f_ces = hint;
    detect = hint;
  }
  else {
    if ((*f_ces & 0x100000) != 0) {
      hint = *f_ces;
    }
    detect = wc_auto_detect(is->ptr,is->length,hint);
    if (WcOption.auto_detect == '\x02') {
      if (((detect & 0x100000) != 0) || (((detect & 0x1fe00) != 0 && ((*f_ces & 0x100000) == 0)))) {
        *f_ces = detect;
      }
    }
    else if (((detect & 0x800) != 0) && ((*f_ces & 0x100000) == 0)) {
      *f_ces = detect;
    }
  }
  p_Var1 = wc_Str_conv(is,detect,t_ces);
  return p_Var1;
}



void wc_push_end(Str os,wc_status *st)

{
  if ((st->ces_info->id & 0x800) == 0) {
    if (st->ces_info->id == 0x20203c) {
      wc_push_to_hz_end(os,st);
    }
    else if (st->ces_info->id == 0x308045) {
      wc_push_to_utf8_end(os,st);
    }
    else if (st->ces_info->id == 0x208046) {
      wc_push_to_utf7_end(os,st);
    }
  }
  else {
    wc_push_to_iso2022_end(os,st);
  }
  return;
}



void wc_create_detect_map(wc_ces ces,wc_bool esc)

{
  wc_uint8 *map;
  int i;
  
  if (ces != wc_create_detect_map::detect_ces) {
    if ((ces & 0x4000) == 0) {
      for (i = 0; i < 0x20; i = i + 1) {
        WC_DETECT_MAP[i] = '\0';
      }
      WC_DETECT_MAP[126] = ces == 0x20203c;
      WC_DETECT_MAP[43] = ces == 0x208046;
    }
    else {
      map = (wc_uint8 *)0x0;
      if (ces == 0x104443) {
        map = wc_c0_viscii112_map;
      }
      else if (ces == 0x104444) {
        map = wc_c0_vps2_map;
      }
      else if (ces == 0x104442) {
        map = wc_c0_tcvn57122_map;
      }
      for (i = 0; i < 0x20; i = i + 1) {
        WC_DETECT_MAP[i] = map[i] != '\0';
      }
    }
    wc_create_detect_map::detect_ces = ces;
  }
  if ((esc == '\0') && ((ces & 0x800) == 0)) {
    WC_DETECT_MAP[27] = '\0';
  }
  else {
    WC_DETECT_MAP[27] = '\x01';
  }
  return;
}



wc_ces wc_auto_detect(char *is,size_t len,wc_ces hint)

{
  bool bVar1;
  bool bVar2;
  byte bVar3;
  int iVar4;
  wc_status st;
  int utf8_next;
  int utf8_detect;
  int utf8_state;
  int possible;
  int priv_detect;
  int latin_detect;
  int hz_detect;
  int big5_detect;
  int sjis_detect;
  int euc_detect;
  int iso_detect;
  int hz_state;
  int big5_state;
  int sjis_state;
  int euc_state;
  wc_ces priv;
  wc_ces euc;
  wc_uchar *q;
  wc_uchar *ep;
  wc_uchar *p;
  wc_bool ok;
  wc_bool iso2022kr;
  wc_bool iso2022cn;
  wc_bool iso2022jp3;
  wc_bool iso2022jp2;
  
  p = (wc_uchar *)is;
  ep = (wc_uchar *)(is + len);
  euc = 0;
  priv = 0;
  euc_detect = 8;
  sjis_detect = 8;
  big5_detect = 8;
  hz_detect = 8;
  latin_detect = 8;
  priv_detect = 8;
  iso2022jp2 = '\0';
  iso2022jp3 = '\0';
  iso2022cn = '\0';
  iso2022kr = '\0';
  ok = '\0';
  bVar2 = false;
  utf8_detect = 8;
  utf8_next = 0;
  wc_create_detect_map(hint,'\x01');
  while ((p < ep && (WC_DETECT_MAP[*p] == '\0'))) {
    p = p + 1;
  }
  if (p == ep) {
    return hint;
  }
  if (hint == 0x301016) {
LAB_080b659d:
    euc = 0x301016;
    sjis_detect = 0;
    euc_detect = 0;
    possible = 3;
  }
  else if (hint < 0x301017) {
    if (hint < 0x200814) {
      if (0x200810 < hint) goto LAB_080b659d;
      if (hint != 0x100) goto LAB_080b66bd;
      latin_detect = 0;
      possible = 2;
    }
    else if (hint == 0x200815) {
LAB_080b6673:
      euc = 0x301019;
      euc_detect = 0;
      possible = 3;
    }
    else if (hint < 0x200815) {
LAB_080b65d1:
      euc = 0x301017;
      big5_detect = 0;
      euc_detect = 0;
      possible = 3;
    }
    else {
      if (hint != 0x20203c) goto LAB_080b66bd;
      euc = 0x301017;
      hz_detect = 0;
      big5_detect = 0;
      euc_detect = 0;
      possible = 4;
    }
  }
  else if (hint < 0x30203a) {
    if (0x302037 < hint) goto LAB_080b659d;
    if (hint == 0x301018) goto LAB_080b6605;
    if (hint < 0x301018) goto LAB_080b65d1;
    if (hint == 0x301019) goto LAB_080b6673;
LAB_080b66bd:
    if ((hint & 0x200) == 0) {
      priv_detect = 0;
      priv = hint;
      possible = 2;
    }
    else {
      latin_detect = 0;
      possible = 2;
    }
  }
  else if (hint == 0x30203d) {
LAB_080b6605:
    euc = 0x301018;
    big5_detect = 0;
    euc_detect = 0;
    possible = 3;
  }
  else {
    if (hint != 0x308045) goto LAB_080b66bd;
    possible = 1;
  }
  euc_state = 0;
  sjis_state = 0;
  bVar1 = false;
  hz_state = 0;
  iso_detect = 0;
  if (priv_detect == 8) {
    utf8_detect = 0;
    possible = possible + 1;
  }
  wc_input_init(0x100,&st);
  while (((p < ep && (possible != 0)) && ((possible != 1 || (ok == '\0'))))) {
    if (iso_detect == 8) {
LAB_080b6924:
      if (euc_detect != 8) {
        if (euc_state == 2) {
          if (WC_ISO_MAP[*p] == '@') {
            euc_detect = euc_detect | 2;
            ok = '\x01';
          }
          else if ((euc_detect & 4U) == 0) {
            euc_detect = euc_detect | 4;
          }
          else {
            euc_detect = 8;
          }
          euc_state = 0;
        }
        else if (euc_state == 3) {
          if (((*p < 0xa0) || (0xb0 < *p)) || (WC_ISO_MAP[p[1]] != '@')) {
            euc_detect = 8;
          }
          euc_state = 0;
        }
        else if (euc_state == 0) {
          switch(WC_ISO_MAP[*p]) {
          case '@':
            euc_state = 2;
            break;
          case 'P':
          case '`':
            euc_detect = 8;
            break;
          case 'T':
            if (euc == 0x301016) {
              euc_state = 2;
            }
            else if (euc == 0x301018) {
              euc_state = 3;
            }
            else {
              euc_detect = 8;
            }
            break;
          case 'U':
            if ((euc != 0x301016) || (WC_ISO_MAP[p[1]] != '@')) {
              euc_detect = 8;
            }
          }
        }
        if (euc_detect == 8) {
          possible = possible + -1;
        }
      }
      if (sjis_detect != 8) {
        if (sjis_state == 1) {
          if ((WC_SJIS_MAP[*p] & 0x10) == 0) {
            if ((sjis_detect & 4U) == 0) {
              sjis_detect = sjis_detect | 4;
            }
            else {
              sjis_detect = 8;
            }
          }
          else {
            sjis_detect = sjis_detect | 2;
            ok = '\x01';
          }
          sjis_state = 0;
        }
        else if (sjis_state == 3) {
          if ((WC_SJIS_MAP[*p] & 0x10) == 0) {
            sjis_detect = 8;
          }
          else {
            sjis_detect = sjis_detect | 1;
          }
          sjis_state = 0;
        }
        else if (sjis_state == 0) {
          switch(WC_SJIS_MAP[*p]) {
          case '\x12':
          case '\x17':
          case '@':
switchD_080b6ab8_caseD_12:
            sjis_detect = 8;
            break;
          case '\x13':
            sjis_detect = sjis_detect | 1;
            break;
          case '4':
          case '5':
            sjis_state = 1;
            break;
          case '6':
            if (WcOption.use_jisx0213 == '\0') goto switchD_080b6ab8_caseD_12;
            sjis_state = 3;
          }
        }
        if (sjis_detect == 8) {
          possible = possible + -1;
        }
      }
      if (big5_detect != 8) {
        if (bVar1) {
          if (bVar1) {
            if ((WC_BIG5_MAP[*p] & 4) == 0) {
              if ((big5_detect & 4U) == 0) {
                big5_detect = big5_detect | 4;
              }
              else {
                big5_detect = 8;
              }
            }
            else {
              big5_detect = big5_detect | 2;
              ok = '\x01';
            }
            bVar1 = false;
          }
        }
        else if (WC_BIG5_MAP[*p] == '\x02') {
          big5_detect = 8;
        }
        else if (WC_BIG5_MAP[*p] == '\a') {
          bVar1 = true;
        }
        if (big5_detect == 8) {
          possible = possible + -1;
        }
      }
      if (hz_detect != 8) {
        if ((char)*p < '\0') {
          hz_detect = 8;
          possible = possible + -1;
        }
        else {
          switch(hz_state) {
          case 0:
            if (*p == '~') {
              hz_state = 1;
            }
            break;
          case 1:
            if (*p == '{') {
              hz_state = 3;
            }
            else {
              hz_state = 0;
            }
            break;
          case 2:
            if (*p == '}') {
              hz_state = 0;
            }
            else {
              hz_state = 3;
            }
            break;
          case 3:
            if (*p == '~') {
              hz_state = 2;
            }
            else {
              hz_state = 4;
            }
            break;
          case 4:
            hz_detect = 2;
            ok = '\x01';
            hz_state = 0;
          }
        }
      }
      if (latin_detect != 8) {
        bVar3 = WC_ISO_MAP[*p] & 0xf0;
        if (bVar3 == 0x50) {
          latin_detect = 8;
        }
        else if ((bVar3 == 0x60) || (bVar3 == 0x40)) {
          latin_detect = latin_detect | 2;
          ok = '\x01';
        }
        if (latin_detect == 8) {
          possible = possible + -1;
        }
      }
      if (((priv_detect != 8) && (*p != '\x1b')) && (WC_DETECT_MAP[*p] != '\0')) {
        priv_detect = priv_detect | 2;
        ok = '\x01';
      }
      if (utf8_detect != 8) {
        if (bVar2) {
          if (bVar2) {
            if (WC_UTF8_MAP[*p] == '\0') {
              utf8_next = utf8_next + -1;
              if (utf8_next == 0) {
                utf8_detect = utf8_detect | 2;
                ok = '\x01';
                bVar2 = false;
              }
            }
            else {
              utf8_detect = 8;
              bVar2 = false;
            }
          }
        }
        else {
          utf8_next = (int)WC_UTF8_MAP[*p];
          if (utf8_next != 1) {
            if ((uint)utf8_next < 2) {
              if (utf8_next == 0) {
LAB_080b6d83:
                utf8_detect = 8;
              }
              else {
LAB_080b6d8c:
                utf8_next = utf8_next - 1;
                bVar2 = true;
              }
            }
            else {
              if (utf8_next == 7) goto LAB_080b6d83;
              if (utf8_next != 8) goto LAB_080b6d8c;
            }
          }
        }
        if (utf8_detect == 8) {
          possible = possible + -1;
        }
      }
    }
    else {
      bVar3 = *p;
      if (bVar3 < 0xe) {
LAB_080b6906:
        if ((char)*p < '\0') {
          iso_detect = 8;
          possible = possible + -1;
        }
        goto LAB_080b6924;
      }
      if (bVar3 < 0x10) {
        iso_detect = 2;
        ok = '\x01';
        iso2022cn = '\x01';
        iso2022kr = '\x01';
        goto LAB_080b6924;
      }
      if (bVar3 != 0x1b) goto LAB_080b6906;
      if (p[1] == '$') {
        q = p;
        iVar4 = wc_parse_iso2022_esc(&q,&st);
        if (iVar4 == 0) goto LAB_080b6924;
        if ((st.design[0] != 0x8140) && (st.design[0] != 0x8142)) {
          if ((st.design[0] == 0x814f) || (st.design[0] == 0x8150)) {
            iso2022jp3 = '\x01';
          }
          else if ((st.design[0] & 0xff00) == 0x8100) {
            iso2022jp2 = '\x01';
          }
        }
        if (st.design[1] == 0x8143) {
          iso2022kr = '\x01';
        }
        else if (((st.design[1] == 0x8141) || (st.design[1] == 0x8145)) || (st.design[1] == 0x8147))
        {
          iso2022cn = '\x01';
        }
        if (((st.design[2] & 0xff00) == 0x8100) || ((st.design[3] & 0xff00) == 0x8100)) {
          iso2022cn = '\x01';
        }
LAB_080b68e4:
        iso_detect = 2;
        ok = '\x01';
        goto LAB_080b6924;
      }
      if (p[1] == '.') {
        q = p;
        iVar4 = wc_parse_iso2022_esc(&q,&st);
        if (iVar4 == 0) goto LAB_080b6924;
        if ((st.design[2] & 0xff00) == 0x200) {
          iso2022jp2 = '\x01';
        }
        goto LAB_080b68e4;
      }
      if (p[1] != '%') goto LAB_080b68e4;
      q = p;
      iVar4 = wc_parse_iso2022_esc(&q,&st);
      if (iVar4 == 0) goto LAB_080b6924;
      possible = 0;
      iso_detect = 4;
    }
    p = p + 1;
  }
  if (iso_detect != 8) {
    if (iso_detect == 0) {
      if (hz_detect == 2) {
        return 0x20203c;
      }
      if (priv_detect == 2) {
        return priv;
      }
      return 0x100;
    }
    if (0x301016 < euc) {
      if (euc < 0x301019) {
        if (iso2022cn != '\0') {
          return 0x200814;
        }
      }
      else if ((euc == 0x301019) && (iso2022kr != '\0')) {
        return 0x200815;
      }
    }
    if (iso2022jp3 != '\0') {
      return 0x200813;
    }
    if (iso2022jp2 != '\0') {
      return 0x200812;
    }
    if (iso2022cn != '\0') {
      return 0x200814;
    }
    if (iso2022kr != '\0') {
      return 0x200815;
    }
    return 0x200811;
  }
  if (hint < 0x30101a) {
    iVar4 = euc_detect;
    if (hint < 0x301016) {
      if (hint == 0x100) {
        if (utf8_detect != 8) {
          return 0x100;
        }
        if (latin_detect == 8) {
          return 0x100;
        }
        return 0x100201;
      }
      if ((hint < 0x100) || (4 < hint - 0x200811)) goto LAB_080b6f64;
      goto LAB_080b6f9c;
    }
  }
  else {
    iVar4 = big5_detect;
    if (hint != 0x30203d) {
      if (0x30203d < hint) {
        if (hint == 0x308045) {
          return 0x308045;
        }
LAB_080b6f64:
        if (latin_detect != 8) {
          return hint;
        }
        if (priv_detect != 8) {
          return hint;
        }
        if (utf8_detect == 8) {
          return hint;
        }
        return 0x308045;
      }
      iVar4 = sjis_detect;
      if (1 < hint - 0x302038) goto LAB_080b6f64;
    }
  }
  if (iVar4 != 8) {
    return hint;
  }
LAB_080b6f9c:
  if (euc_detect != 2) {
    if (sjis_detect == 2) {
      euc = 0x302038;
    }
    else if (big5_detect == 2) {
      euc = 0x30203d;
    }
    else if (utf8_detect == 2) {
      euc = 0x308045;
    }
    else if ((sjis_detect & 1U) == 0) {
      if (euc_detect == 8) {
        if (sjis_detect == 8) {
          if (big5_detect == 8) {
            euc = hint;
            if (utf8_detect != 8) {
              euc = 0x308045;
            }
          }
          else {
            euc = 0x30203d;
          }
        }
        else {
          euc = 0x302038;
        }
      }
    }
    else {
      euc = 0x302038;
    }
  }
  return euc;
}



Str wc_conv_from_hz(Str is,wc_ces ces)

{
  wc_uchar *pwVar1;
  int iVar2;
  wc_uchar *pwVar3;
  Str x;
  int state;
  wc_uchar *p;
  wc_uchar *ep;
  wc_uchar *sp;
  Str os;
  
  pwVar1 = (wc_uchar *)is->ptr;
  pwVar3 = pwVar1 + is->length;
  state = 0;
  for (p = pwVar1; ((p < pwVar3 && (-1 < (char)*p)) && (*p != '~')); p = p + 1) {
  }
  if (p != pwVar3) {
    x = Strnew_size(is->length);
    if (pwVar1 < p) {
      Strcat_charp_n(x,is->ptr,(int)p - (int)pwVar1);
    }
    for (; p < pwVar3; p = p + 1) {
      switch(state) {
      case 0:
        if (*p == '~') {
          state = 1;
        }
        else if (WC_ISO_MAP[*p] == '@') {
          state = 5;
        }
        else if ((char)*p < '\0') {
          wtf_push_unknown(x,p,1);
        }
        else {
          if (x->area_size <= x->length + 1) {
            Strgrow(x);
          }
          iVar2 = x->length;
          x->ptr[iVar2] = *p;
          x->length = iVar2 + 1;
          x->ptr[x->length] = '\0';
        }
        break;
      case 1:
        if (*p == '{') {
          state = 3;
        }
        else {
          if (*p == '~') {
            if (x->area_size <= x->length + 1) {
              Strgrow(x);
            }
            iVar2 = x->length;
            x->ptr[iVar2] = *p;
            x->length = iVar2 + 1;
            x->ptr[x->length] = '\0';
          }
          else {
            if (*p == '\n') break;
            wtf_push_unknown(x,p + -1,2);
          }
          state = 0;
        }
        break;
      case 2:
        if ((*p == '}') || (*p == '\n')) {
          state = 0;
        }
        else {
          if (WC_ISO_MAP[*p & 0x7f] == '\0') {
            wtf_push(x,0x8141,(uint)CONCAT11(p[-1],*p));
          }
          else {
            wtf_push_unknown(x,p + -1,2);
          }
          state = 3;
        }
        break;
      case 3:
        if (*p == '~') {
          state = 2;
        }
        else if (WC_ISO_MAP[*p & 0x7f] == '\0') {
          state = 4;
        }
        else {
          wtf_push_unknown(x,p,1);
        }
        break;
      case 4:
        if (WC_ISO_MAP[*p & 0x7f] == '\0') {
          wtf_push(x,0x8141,(uint)CONCAT11(p[-1],*p));
        }
        else {
          wtf_push_unknown(x,p + -1,2);
        }
        state = 3;
        break;
      case 5:
        if (WC_ISO_MAP[*p] == '@') {
          wtf_push(x,0x8141,(uint)CONCAT11(p[-1],*p));
        }
        else {
          wtf_push_unknown(x,p + -1,2);
        }
        state = 0;
      }
    }
    is = x;
    if (((uint)state < 6) && ((1 << (sbyte)state & 0x36U) != 0)) {
      wtf_push_unknown(x,p + -1,1);
    }
  }
  return is;
}



void wc_push_to_hz(Str os,wc_wchar_t cc,wc_status *st)

{
  int iVar1;
  
  do {
    if (cc.ccs == 0x4000) {
      if (WcOption.no_replace == '\0') {
        if (st->gl != '\0') {
          if (os->area_size <= os->length + 1) {
            Strgrow(os);
          }
          iVar1 = os->length;
          os->ptr[iVar1] = '~';
          os->length = iVar1 + 1;
          os->ptr[os->length] = '\0';
          if (os->area_size <= os->length + 1) {
            Strgrow(os);
          }
          iVar1 = os->length;
          os->ptr[iVar1] = '}';
          os->length = iVar1 + 1;
          os->ptr[os->length] = '\0';
          st->gl = '\0';
        }
        Strcat_charp(os,WcReplace);
      }
      return;
    }
    if (cc.ccs < 0x4001) {
      if (cc.ccs == 0x142) {
        if (st->gl != '\0') {
          if (os->area_size <= os->length + 1) {
            Strgrow(os);
          }
          iVar1 = os->length;
          os->ptr[iVar1] = '~';
          os->length = iVar1 + 1;
          os->ptr[os->length] = '\0';
          if (os->area_size <= os->length + 1) {
            Strgrow(os);
          }
          iVar1 = os->length;
          os->ptr[iVar1] = '}';
          os->length = iVar1 + 1;
          os->ptr[os->length] = '\0';
          st->gl = '\0';
        }
        if ((char)cc.code == '~') {
          if (os->area_size <= os->length + 1) {
            Strgrow(os);
          }
          iVar1 = os->length;
          os->ptr[iVar1] = '~';
          os->length = iVar1 + 1;
          os->ptr[os->length] = '\0';
        }
        if (os->area_size <= os->length + 1) {
          Strgrow(os);
        }
        iVar1 = os->length;
        os->ptr[iVar1] = (char)cc.code;
        os->length = iVar1 + 1;
        os->ptr[os->length] = '\0';
        return;
      }
    }
    else {
      if (cc.ccs == 0x8141) {
        if (st->gl == '\0') {
          if (os->area_size <= os->length + 1) {
            Strgrow(os);
          }
          iVar1 = os->length;
          os->ptr[iVar1] = '~';
          os->length = iVar1 + 1;
          os->ptr[os->length] = '\0';
          if (os->area_size <= os->length + 1) {
            Strgrow(os);
          }
          iVar1 = os->length;
          os->ptr[iVar1] = '{';
          os->length = iVar1 + 1;
          os->ptr[os->length] = '\0';
          st->gl = '\x01';
        }
        if (os->area_size <= os->length + 1) {
          Strgrow(os);
        }
        iVar1 = os->length;
        os->ptr[iVar1] = (byte)(cc.code >> 8) & 0x7f;
        os->length = iVar1 + 1;
        os->ptr[os->length] = '\0';
        if (os->area_size <= os->length + 1) {
          Strgrow(os);
        }
        iVar1 = os->length;
        os->ptr[iVar1] = (byte)cc.code & 0x7f;
        os->length = iVar1 + 1;
        os->ptr[os->length] = '\0';
        return;
      }
      if (cc.ccs == 0xc000) {
        if (WcOption.no_replace != '\0') {
          return;
        }
        if (st->gl != '\0') {
          if (os->area_size <= os->length + 1) {
            Strgrow(os);
          }
          iVar1 = os->length;
          os->ptr[iVar1] = '~';
          os->length = iVar1 + 1;
          os->ptr[os->length] = '\0';
          if (os->area_size <= os->length + 1) {
            Strgrow(os);
          }
          iVar1 = os->length;
          os->ptr[iVar1] = '}';
          os->length = iVar1 + 1;
          os->ptr[os->length] = '\0';
          st->gl = '\0';
        }
        Strcat_charp(os,WcReplaceW);
        return;
      }
    }
    if (WcOption.ucs_conv == '\0') {
      if ((cc.ccs & 0x18000) == 0) {
        cc.ccs = 0x4000;
      }
      else {
        cc.ccs = 0xc000;
      }
    }
    else {
      wc_any_to_any_ces((wc_wchar_t)CONCAT44(cc.ccs,&cc),(wc_status *)cc.code);
    }
  } while( true );
}



void wc_push_to_hz_end(Str os,wc_status *st)

{
  int iVar1;
  
  if (st->gl != '\0') {
    if (os->area_size <= os->length + 1) {
      Strgrow(os);
    }
    iVar1 = os->length;
    os->ptr[iVar1] = '~';
    os->length = iVar1 + 1;
    os->ptr[os->length] = '\0';
    if (os->area_size <= os->length + 1) {
      Strgrow(os);
    }
    iVar1 = os->length;
    os->ptr[iVar1] = '}';
    os->length = iVar1 + 1;
    os->ptr[os->length] = '\0';
    st->gl = '\0';
  }
  return;
}



void wtf_push_iso2022(Str os,wc_ccs ccs,wc_uint32 code)

{
  if (ccs != 0x8142) {
    if (ccs < 0x8143) {
      if (ccs != 0x154) {
        if (ccs == 0x8140) goto LAB_080b7a29;
        if (ccs != 0x14a) goto LAB_080b7a56;
      }
      ccs = 0x142;
      goto LAB_080b7a56;
    }
    if (ccs != 0x814f) {
      if ((ccs == 0x8150) || (ccs == 0x8144)) {
        ccs = wc_jisx0212_or_jisx02132((wc_uint16)code);
      }
      goto LAB_080b7a56;
    }
  }
LAB_080b7a29:
  ccs = wc_jisx0208_or_jisx02131((wc_uint16)code);
LAB_080b7a56:
  wtf_push(os,ccs,code);
  return;
}



Str wc_conv_from_iso2022(Str is,wc_ces ces)

{
  int iVar1;
  wc_status st;
  wc_ccs gr_ccs;
  wc_ccs gl_ccs;
  int state;
  wc_uchar *q;
  wc_uchar *p;
  wc_uchar *ep;
  wc_uchar *sp;
  Str os;
  
  sp = (wc_uchar *)is->ptr;
  ep = sp + is->length;
  q = (wc_uchar *)0x0;
  state = 0;
  p = sp;
  while ((p < ep && ((WC_ISO_MAP[*p] & 0x4f) == 0))) {
    p = p + 1;
  }
  os = is;
  if (p != ep) {
    os = Strnew_size(is->length);
    if (sp < p) {
      Strcat_charp_n(os,is->ptr,(int)p - (int)sp);
    }
    wc_input_init(ces,&st);
    gl_ccs = st.design[st.gl];
    gr_ccs = st.design[st.gr];
LAB_080b8290:
    if (p < ep) {
      switch(state) {
      case 0:
        goto switchD_080b7b66_caseD_0;
      case 1:
        if (WC_ISO_MAP[*p] == '\0') {
LAB_080b7feb:
          wtf_push_iso2022(os,gl_ccs,(uint)CONCAT11(*q,*p));
        }
        else if (WC_ISO_MAP[*p] == ' ') {
          if ((gl_ccs & 0x200) != 0) goto LAB_080b7feb;
          if (os->area_size <= os->length + 1) {
            Strgrow(os);
          }
          iVar1 = os->length;
          os->ptr[iVar1] = *q;
          os->length = iVar1 + 1;
          os->ptr[os->length] = '\0';
          if (os->area_size <= os->length + 1) {
            Strgrow(os);
          }
          iVar1 = os->length;
          os->ptr[iVar1] = *p;
          os->length = iVar1 + 1;
          os->ptr[os->length] = '\0';
        }
        else {
          wtf_push_unknown(os,q,2);
        }
        goto switchD_080b7b66_caseD_3;
      case 2:
        if (WC_ISO_MAP[*p] == '@') {
LAB_080b8085:
          if (gr_ccs == 0x880d) {
            state = 5;
            goto LAB_080b8287;
          }
          wtf_push_iso2022(os,gr_ccs,(uint)CONCAT11(*q,*p));
        }
        else if (WC_ISO_MAP[*p] == '`') {
          if ((gr_ccs & 0x200) != 0) goto LAB_080b8085;
          wtf_push_unknown(os,q,2);
        }
        else {
          wtf_push_unknown(os,q,2);
        }
      default:
        goto switchD_080b7b66_caseD_3;
      case 5:
        if (WC_ISO_MAP[*p] == '@') {
          if ((*q < 0xa1) || (0xa7 < *q)) {
            if ((*q < 0xa8) || (0xb0 < *q)) goto LAB_080b81b3;
            wtf_push_iso2022(os,*q + 0x875c,(uint)CONCAT11(q[1],*p));
          }
          else {
            wtf_push_iso2022(os,*q + 0x80a6,(uint)CONCAT11(q[1],*p));
          }
        }
        else {
LAB_080b81b3:
          wtf_push_unknown(os,q,3);
        }
        goto switchD_080b7b66_caseD_3;
      case 0x10:
        if ((*p == '\x1b') && (p[1] == '%')) {
          if (p[2] == '@') {
            st.state = 0;
            state = 0;
            p = p + 2;
          }
          else {
            if ((p[2] < 0x41) || (0x7e < p[2])) goto LAB_080b8233;
            p = p + 2;
          }
        }
        else {
LAB_080b8233:
          wtf_push_unknown(os,p,1);
        }
        goto LAB_080b8287;
      case 0x20:
        wtf_push_unknown(os,p,(int)ep - (int)p);
        return os;
      }
    }
    if (0 < state) {
      if (state < 3) {
        wtf_push_unknown(os,p + -1,1);
      }
      else if (state == 4) {
        wtf_push_unknown(os,p + -2,2);
      }
    }
  }
  return os;
switchD_080b7b66_caseD_0:
  switch(WC_ISO_MAP[*p]) {
  case '\0':
switchD_080b7b8b_caseD_0:
    if (st.ss == '\0') {
      gl_ccs = st.design[st.gl];
    }
    else {
      gl_ccs = st.design[st.ss];
    }
    if ((gl_ccs & 0x18000) == 0) {
      if (gl_ccs == 0x100) {
        if (os->area_size <= os->length + 1) {
          Strgrow(os);
        }
        iVar1 = os->length;
        os->ptr[iVar1] = *p;
        os->length = iVar1 + 1;
        os->ptr[os->length] = '\0';
      }
      else {
        wtf_push_iso2022(os,gl_ccs,(uint)*p);
      }
      break;
    }
    q = p;
    state = 1;
    goto LAB_080b8287;
  case '\x10':
    if (os->area_size <= os->length + 1) {
      Strgrow(os);
    }
    iVar1 = os->length;
    os->ptr[iVar1] = *p;
    os->length = iVar1 + 1;
    os->ptr[os->length] = '\0';
    break;
  case '\x11':
    st.gl = '\x01';
    break;
  case '\x12':
    st.gl = '\0';
    break;
  case '\x13':
    st.ss = '\0';
    iVar1 = wc_parse_iso2022_esc(&p,&st);
    if (iVar1 == 0) {
      if (os->area_size <= os->length + 1) {
        Strgrow(os);
      }
      iVar1 = os->length;
      os->ptr[iVar1] = *p;
      os->length = iVar1 + 1;
      os->ptr[os->length] = '\0';
    }
    else {
      state = st.state;
    }
    goto LAB_080b8287;
  case ' ':
    if (st.ss == '\0') {
      gl_ccs = st.design[st.gl];
    }
    else {
      gl_ccs = st.design[st.ss];
    }
    if ((gl_ccs & 0x200) != 0) goto switchD_080b7b8b_caseD_0;
    if (os->area_size <= os->length + 1) {
      Strgrow(os);
    }
    iVar1 = os->length;
    os->ptr[iVar1] = *p;
    os->length = iVar1 + 1;
    os->ptr[os->length] = '\0';
    break;
  case '@':
switchD_080b7b8b_caseD_40:
    if (st.ss == '\0') {
      gr_ccs = st.design[st.gr];
    }
    else {
      gr_ccs = st.design[st.ss];
    }
    if ((gr_ccs & 0x18000) == 0) {
      if (gr_ccs == 0) {
        wtf_push_unknown(os,p,1);
      }
      else {
        wtf_push_iso2022(os,gr_ccs,(uint)*p);
      }
      break;
    }
    q = p;
    state = 2;
    goto LAB_080b8287;
  case 'P':
    wtf_push(os,0x4001,(uint)*p);
    break;
  case 'T':
    if (st.design[2] == 0) {
      wtf_push_unknown(os,p,1);
      break;
    }
    st.ss = '\x02';
    goto LAB_080b8287;
  case 'U':
    if (st.design[3] == 0) {
      wtf_push_unknown(os,p,1);
      break;
    }
    st.ss = '\x03';
    goto LAB_080b8287;
  case '`':
    if (st.ss == '\0') {
      gr_ccs = st.design[st.gr];
    }
    else {
      gr_ccs = st.design[st.ss];
    }
    if ((gr_ccs & 0x200) != 0) goto switchD_080b7b8b_caseD_40;
    wtf_push_unknown(os,p,1);
  }
switchD_080b7b66_caseD_3:
  st.ss = '\0';
  state = 0;
LAB_080b8287:
  p = p + 1;
  goto LAB_080b8290;
}



int wc_parse_iso2022_esc(wc_uchar **ptr,wc_status *st)

{
  wc_uchar *pwVar1;
  uint uVar2;
  wc_uchar *p;
  wc_uchar cs;
  wc_uchar g;
  wc_uchar f;
  wc_uchar state;
  
  pwVar1 = *ptr;
  f = '\0';
  g = '\0';
  cs = '\0';
  if (*pwVar1 != '\x1b') {
    return 0;
  }
  state = *pwVar1;
LAB_080b85f4:
  do {
    while( true ) {
      p = pwVar1 + 1;
      if ((*p == '\0') || (state == '\0')) {
        if ((0x3f < f) && (f < 0x7f)) {
          if (cs == '/') {
            st->state = 0x20;
          }
          else if (cs < 0x30) {
            if (cs == '(') {
              st->design[g] = (uint)CONCAT11(1,f);
            }
            else if (cs == ',') {
              st->design[g] = (uint)CONCAT11(2,f);
            }
            else if (cs == '%') {
              if (f == '@') {
                st->state = 0;
              }
              else {
                st->state = 0x10;
              }
            }
          }
          else if (cs == 0xa8) {
            st->design[g] = (uint)CONCAT11(0x81,f);
          }
          else if (cs == 0xac) {
            st->design[g] = (uint)CONCAT11(0x82,f);
          }
          else if (cs == 0xa1) {
            st->design[g] = (uint)CONCAT11(4,f);
          }
          *ptr = pwVar1;
          return 1;
        }
        return 0;
      }
      pwVar1 = p;
      if (state != '(') break;
      if (*p == '!') {
        cs = 0xa1;
        state = 0xa1;
        g = *p & 3;
      }
      else {
LAB_080b85b1:
        state = '\0';
        f = *p;
      }
    }
    if (0x28 < state) {
      if (state != 0xa5) {
        if (state < 0xa6) {
          if ((state != ',') && (state != 0xa1)) {
            return 0;
          }
        }
        else if ((state != 0xa8) && (state != 0xac)) {
          return 0;
        }
      }
      goto LAB_080b85b1;
    }
    if (state == '!') goto LAB_080b85b1;
    if (0x21 < state) {
      if (state != '$') {
        if (state != '%') {
          return 0;
        }
        if (*p == '/') {
          cs = 0xa5;
          state = 0xa5;
        }
        else {
          state = '\0';
          f = *p;
        }
        goto LAB_080b85f4;
      }
      if (*p - 0x28 < 0x1b) {
        uVar2 = 1 << ((byte)(*p - 0x28) & 0x1f);
        if ((uVar2 & 0x7000000) != 0) {
          state = '\0';
          cs = 0xa8;
          g = '\0';
          f = *p;
          goto LAB_080b85f4;
        }
        if ((uVar2 & 0xf0) != 0) {
          cs = 0xac;
          state = 0xac;
          g = *p & 3;
          goto LAB_080b85f4;
        }
        if ((uVar2 & 0xf) != 0) {
          cs = 0xa8;
          state = 0xa8;
          g = *p & 3;
          goto LAB_080b85f4;
        }
      }
      return 0;
    }
    if (state != '\x1b') {
      return 0;
    }
    switch(*p) {
    case '!':
    case '\"':
    case '&':
      cs = '!';
      state = '!';
      break;
    default:
      return 0;
    case '$':
      state = *p;
      break;
    case '%':
      cs = '%';
      state = '%';
      break;
    case '(':
    case ')':
    case '*':
    case '+':
      cs = '(';
      state = '(';
      g = *p & 3;
      break;
    case ',':
    case '-':
    case '.':
    case '/':
      cs = ',';
      state = ',';
      g = *p & 3;
      break;
    case 'N':
      st->ss = '\x02';
      *ptr = p;
      return 1;
    case 'O':
      st->ss = '\x03';
      *ptr = p;
      return 1;
    case 'n':
      st->gl = '\x02';
      *ptr = p;
      return 1;
    case 'o':
      st->gl = '\x03';
      *ptr = p;
      return 1;
    case '|':
      st->gr = '\x03';
      *ptr = p;
      return 1;
    case '}':
      st->gr = '\x02';
      *ptr = p;
      return 1;
    case '~':
      st->gr = '\x01';
      *ptr = p;
      return 1;
    }
  } while( true );
}



void wc_push_to_iso2022(Str os,wc_wchar_t cc,wc_status *st)

{
  int iVar1;
  bool bVar2;
  bool bVar3;
  uint uVar4;
  wc_ccs local_34;
  wc_uint32 local_30;
  wc_wchar_t cc2_1;
  wc_wchar_t cc2;
  wc_bool retry;
  wc_bool is_wide;
  wc_uchar g;
  
  bVar3 = false;
  bVar2 = false;
LAB_080b872d:
  do {
    while (uVar4 = cc.ccs & 0xff00, uVar4 == 0x4000) {
      if (WcOption.no_replace != '\0') {
        return;
      }
      cc.ccs = 0x142;
      g = cs94_gmap[2];
      cc.code = (wc_uint32)*WcReplace;
LAB_080b8a50:
      if (g != '\0') {
        wc_push_iso2022_esc(os,cc.ccs,g,'\x01',st);
        if (bVar3) {
          if (os->area_size <= os->length + 1) {
            Strgrow(os);
          }
          iVar1 = os->length;
          os->ptr[iVar1] = (byte)(cc.code >> 8) & 0x7f;
          os->length = iVar1 + 1;
          os->ptr[os->length] = '\0';
        }
        if (os->area_size <= os->length + 1) {
          Strgrow(os);
        }
        iVar1 = os->length;
        os->ptr[iVar1] = (byte)cc.code & 0x7f;
        os->length = iVar1 + 1;
        os->ptr[os->length] = '\0';
        return;
      }
      if ((WcOption.ucs_conv == '\0') || (bVar2)) {
        if ((cc.ccs & 0x18000) == 0) {
          cc.ccs = 0x4000;
        }
        else {
          cc.ccs = 0xc000;
        }
      }
      else {
        wc_any_to_any_ces((wc_wchar_t)CONCAT44(cc.ccs,&local_34),(wc_status *)cc.code);
        cc.ccs = local_34;
        cc.code = local_30;
      }
      bVar2 = true;
    }
    if (uVar4 < 0x4001) {
      if (uVar4 == 0x200) {
        g = cs94w_gmap[cc.ccs & 0xff];
      }
      else if (uVar4 == 0x400) {
        g = cs96w_gmap[cc.ccs & 0xff];
      }
      else {
        if (uVar4 != 0x100) goto LAB_080b89be;
        if (cc.ccs == 0x142) {
          cc.ccs = st->g0_ccs;
        }
        g = *(wc_uchar *)((int)char_conv_st.design + (cc.ccs & 0xff) + 0x10);
      }
      goto LAB_080b8a50;
    }
    if (uVar4 == 0x8200) {
      bVar3 = true;
      g = cs96_gmap[cc.ccs & 0xff];
      goto LAB_080b8a50;
    }
    if (uVar4 == 0xc000) {
      if (WcOption.no_replace != '\0') {
        return;
      }
      bVar3 = true;
      cc.ccs = 0x142;
      g = cs94_gmap[2];
      cc.code = (int)WcReplaceW[1] | (int)*WcReplaceW << 8;
      goto LAB_080b8a50;
    }
    if (uVar4 != 0x8100) {
LAB_080b89be:
      if ((cs94w_gmap[3] == '\0') ||
         (wc_johab_to_ksx1001((wc_wchar_t)CONCAT44(cc.ccs,&cc2_1)), cc2_1.ccs != 0x8143)) {
        if (WcOption.ucs_conv == '\0') {
          if ((cc.ccs & 0x18000) == 0) {
            cc.ccs = 0x4000;
          }
          else {
            cc.ccs = 0xc000;
          }
        }
        else {
          wc_any_to_iso2022((wc_wchar_t)CONCAT44(cc.ccs,&cc),(wc_status *)cc.code);
        }
      }
      else {
        cc.ccs = cc2_1.ccs;
        cc.code = cc2_1.code;
      }
      goto LAB_080b872d;
    }
    bVar3 = true;
    if (cc.ccs != 0x8144) {
      if (((0x8143 < cc.ccs) && (cc.ccs - 0x814f < 2)) &&
         ((WcOption.use_jisx0213 == '\0' &&
          ((WcOption.use_jisx0212 != '\0' && (WcOption.ucs_conv != '\0')))))) {
        wc_jisx0213_to_jisx0212((wc_wchar_t)CONCAT44(cc.ccs,&local_34));
        cc2.ccs = local_34;
        cc2.code = local_30;
        if (local_34 == 0x8144) {
          cc.ccs = local_34;
          cc.code = local_30;
          goto LAB_080b872d;
        }
      }
LAB_080b88bd:
      g = cs94_gmap[cc.ccs & 0xff];
      goto LAB_080b8a50;
    }
    if ((((WcOption.use_jisx0212 != '\0') || (WcOption.use_jisx0213 == '\0')) ||
        (WcOption.ucs_conv == '\0')) ||
       ((wc_jisx0212_to_jisx0213((wc_wchar_t)CONCAT44(0x8144,&cc2)), cc2.ccs != 0x814f &&
        (cc2.ccs != 0x8150)))) goto LAB_080b88bd;
    cc.ccs = cc2.ccs;
    cc.code = cc2.code;
  } while( true );
}



void wc_push_to_iso2022_end(Str os,wc_status *st)

{
  if ((st->design[1] != 0) && (st->design[1] != st->g1_ccs)) {
    wc_push_iso2022_esc(os,st->g1_ccs,')','\0',st);
  }
  wc_push_iso2022_esc(os,st->g0_ccs,'(','\x01',st);
  return;
}



void wc_push_iso2022_esc(Str os,wc_ccs ccs,wc_uchar g,wc_uint8 invoke,wc_status *st)

{
  int iVar1;
  byte bVar2;
  wc_uint8 g_invoke;
  
  bVar2 = g & 3;
  if (st->design[bVar2] != ccs) {
    if (os->area_size <= os->length + 1) {
      Strgrow(os);
    }
    iVar1 = os->length;
    os->ptr[iVar1] = '\x1b';
    os->length = iVar1 + 1;
    os->ptr[os->length] = '\0';
    if ((ccs & 0x18000) == 0) {
      if (os->area_size <= os->length + 1) {
        Strgrow(os);
      }
      iVar1 = os->length;
      os->ptr[iVar1] = g;
      os->length = iVar1 + 1;
      os->ptr[os->length] = '\0';
      if ((ccs & 0x700) == 0x400) {
        if (os->area_size <= os->length + 1) {
          Strgrow(os);
        }
        iVar1 = os->length;
        os->ptr[iVar1] = '!';
        os->length = iVar1 + 1;
        os->ptr[os->length] = '\0';
      }
    }
    else {
      if (os->area_size <= os->length + 1) {
        Strgrow(os);
      }
      iVar1 = os->length;
      os->ptr[iVar1] = '$';
      os->length = iVar1 + 1;
      os->ptr[os->length] = '\0';
      if ((bVar2 != 0) || (((ccs != 0x8140 && (ccs != 0x8142)) && (ccs != 0x8141)))) {
        if (os->area_size <= os->length + 1) {
          Strgrow(os);
        }
        iVar1 = os->length;
        os->ptr[iVar1] = g;
        os->length = iVar1 + 1;
        os->ptr[os->length] = '\0';
      }
    }
    if (os->area_size <= os->length + 1) {
      Strgrow(os);
    }
    iVar1 = os->length;
    os->ptr[iVar1] = (char)ccs;
    os->length = iVar1 + 1;
    os->ptr[os->length] = '\0';
    st->design[bVar2] = ccs;
  }
  if (invoke != '\0') {
    if (bVar2 == 1) {
      if (st->gl != '\x01') {
        if (os->area_size <= os->length + 1) {
          Strgrow(os);
        }
        iVar1 = os->length;
        os->ptr[iVar1] = '\x0e';
        os->length = iVar1 + 1;
        os->ptr[os->length] = '\0';
        st->gl = '\x01';
      }
    }
    else if (bVar2 < 2) {
      if ((bVar2 == 0) && (st->gl != '\0')) {
        if (os->area_size <= os->length + 1) {
          Strgrow(os);
        }
        iVar1 = os->length;
        os->ptr[iVar1] = '\x0f';
        os->length = iVar1 + 1;
        os->ptr[os->length] = '\0';
        st->gl = '\0';
      }
    }
    else if (bVar2 == 2) {
      if (os->area_size <= os->length + 1) {
        Strgrow(os);
      }
      iVar1 = os->length;
      os->ptr[iVar1] = '\x1b';
      os->length = iVar1 + 1;
      os->ptr[os->length] = '\0';
      if (os->area_size <= os->length + 1) {
        Strgrow(os);
      }
      iVar1 = os->length;
      os->ptr[iVar1] = 'N';
      os->length = iVar1 + 1;
      os->ptr[os->length] = '\0';
    }
    else if (bVar2 == 3) {
      if (os->area_size <= os->length + 1) {
        Strgrow(os);
      }
      iVar1 = os->length;
      os->ptr[iVar1] = '\x1b';
      os->length = iVar1 + 1;
      os->ptr[os->length] = '\0';
      if (os->area_size <= os->length + 1) {
        Strgrow(os);
      }
      iVar1 = os->length;
      os->ptr[iVar1] = 'O';
      os->length = iVar1 + 1;
      os->ptr[os->length] = '\0';
    }
  }
  return;
}



void wc_push_to_euc(Str os,wc_wchar_t cc,wc_status *st)

{
  int iVar1;
  wc_ccs local_24;
  wc_uint32 local_20;
  wc_ccs g1_ccs;
  
  g1_ccs = st->ces_info->gset[1].ccs;
  do {
    while( true ) {
      if (cc.ccs == g1_ccs) {
        if (os->area_size <= os->length + 1) {
          Strgrow(os);
        }
        iVar1 = os->length;
        os->ptr[iVar1] = (byte)(cc.code >> 8) | 0x80;
        os->length = iVar1 + 1;
        os->ptr[os->length] = '\0';
        if (os->area_size <= os->length + 1) {
          Strgrow(os);
        }
        iVar1 = os->length;
        os->ptr[iVar1] = (byte)cc.code | 0x80;
        os->length = iVar1 + 1;
        os->ptr[os->length] = '\0';
        return;
      }
      if (cc.ccs == 0x4001) {
        if (os->area_size <= os->length + 1) {
          Strgrow(os);
        }
        iVar1 = os->length;
        os->ptr[iVar1] = (byte)cc.code | 0x80;
        os->length = iVar1 + 1;
        os->ptr[os->length] = '\0';
        return;
      }
      if (0x4001 < cc.ccs) break;
      if (cc.ccs == 0x142) {
        if (os->area_size <= os->length + 1) {
          Strgrow(os);
        }
        iVar1 = os->length;
        os->ptr[iVar1] = (char)cc.code;
        os->length = iVar1 + 1;
        os->ptr[os->length] = '\0';
        return;
      }
      if (cc.ccs == 0x4000) {
        if (WcOption.no_replace != '\0') {
          return;
        }
        Strcat_charp(os,WcReplace);
        return;
      }
LAB_080b92f3:
      if (WcOption.ucs_conv == '\0') {
        if ((cc.ccs & 0x18000) == 0) {
          cc.ccs = 0x4000;
        }
        else {
          cc.ccs = 0xc000;
        }
      }
      else {
        wc_any_to_any_ces((wc_wchar_t)CONCAT44(cc.ccs,&local_24),(wc_status *)cc.code);
        cc.ccs = local_24;
        cc.code = local_20;
      }
    }
    if (cc.ccs < 0x880f) goto LAB_080b92f3;
    if (0x8812 < cc.ccs) {
      if (cc.ccs == 0xc000) {
        if (WcOption.no_replace != '\0') {
          return;
        }
        Strcat_charp(os,WcReplaceW);
        return;
      }
      goto LAB_080b92f3;
    }
    if (st->ces_info->id != 0x301019) goto LAB_080b92f3;
    wc_johab_to_ksx1001((wc_wchar_t)CONCAT44(cc.ccs,&cc));
  } while( true );
}



void wc_push_to_eucjp(Str os,wc_wchar_t cc,wc_status *st)

{
  int iVar1;
  wc_ccs local_14;
  wc_uint32 local_10;
  
LAB_080b935e:
  if (cc.ccs == 0x8142) {
LAB_080b97ca:
    if (os->area_size <= os->length + 1) {
      Strgrow(os);
    }
    iVar1 = os->length;
    os->ptr[iVar1] = (byte)(cc.code >> 8) | 0x80;
    os->length = iVar1 + 1;
    os->ptr[os->length] = '\0';
    if (os->area_size <= os->length + 1) {
      Strgrow(os);
    }
    iVar1 = os->length;
    os->ptr[iVar1] = (byte)cc.code | 0x80;
    os->length = iVar1 + 1;
    os->ptr[os->length] = '\0';
    return;
  }
  if (cc.ccs < 0x8143) {
    if (cc.ccs == 0x149) {
      if (WcOption.use_jisx0201k != '\0') {
        if (os->area_size <= os->length + 1) {
          Strgrow(os);
        }
        iVar1 = os->length;
        os->ptr[iVar1] = -0x72;
        os->length = iVar1 + 1;
        os->ptr[os->length] = '\0';
        if (os->area_size <= os->length + 1) {
          Strgrow(os);
        }
        iVar1 = os->length;
        os->ptr[iVar1] = (byte)cc.code | 0x80;
        os->length = iVar1 + 1;
        os->ptr[os->length] = '\0';
        return;
      }
      if (WcOption.fix_width_conv == '\0') {
        wc_jisx0201k_to_jisx0208((wc_wchar_t)CONCAT44(0x149,&cc));
      }
      else {
        cc.ccs = 0x4000;
      }
      goto LAB_080b935e;
    }
    if (cc.ccs < 0x14a) {
      if (cc.ccs == 0x142) {
        if (os->area_size <= os->length + 1) {
          Strgrow(os);
        }
        iVar1 = os->length;
        os->ptr[iVar1] = (char)cc.code;
        os->length = iVar1 + 1;
        os->ptr[os->length] = '\0';
        return;
      }
    }
    else {
      if (cc.ccs == 0x4000) {
        if (WcOption.no_replace != '\0') {
          return;
        }
        Strcat_charp(os,WcReplace);
        return;
      }
      if (cc.ccs == 0x4001) {
        if (os->area_size <= os->length + 1) {
          Strgrow(os);
        }
        iVar1 = os->length;
        os->ptr[iVar1] = (byte)cc.code | 0x80;
        os->length = iVar1 + 1;
        os->ptr[os->length] = '\0';
        return;
      }
    }
  }
  else {
    if (cc.ccs == 0x814f) {
      if (WcOption.use_jisx0213 != '\0') goto LAB_080b97ca;
      if ((WcOption.ucs_conv == '\0') || (WcOption.use_jisx0212 == '\0')) {
        cc.ccs = 0xc000;
      }
      else {
        wc_jisx0213_to_jisx0212((wc_wchar_t)CONCAT44(0x814f,&local_14));
        cc.ccs = local_14;
        cc.code = local_10;
      }
      goto LAB_080b935e;
    }
    if (0x814f < cc.ccs) {
      if (cc.ccs != 0x8150) {
        if (cc.ccs == 0xc000) {
          if (WcOption.no_replace != '\0') {
            return;
          }
          Strcat_charp(os,WcReplaceW);
          return;
        }
        goto LAB_080b976a;
      }
      if (WcOption.use_jisx0213 != '\0') {
        if (os->area_size <= os->length + 1) {
          Strgrow(os);
        }
        iVar1 = os->length;
        os->ptr[iVar1] = -0x71;
        os->length = iVar1 + 1;
        os->ptr[os->length] = '\0';
        goto LAB_080b97ca;
      }
      if ((WcOption.ucs_conv == '\0') || (WcOption.use_jisx0212 == '\0')) {
        cc.ccs = 0xc000;
      }
      else {
        wc_jisx0213_to_jisx0212((wc_wchar_t)CONCAT44(0x8150,&local_14));
        cc.ccs = local_14;
        cc.code = local_10;
      }
      goto LAB_080b935e;
    }
    if (cc.ccs == 0x8144) {
      if (WcOption.use_jisx0212 != '\0') {
        if (os->area_size <= os->length + 1) {
          Strgrow(os);
        }
        iVar1 = os->length;
        os->ptr[iVar1] = -0x71;
        os->length = iVar1 + 1;
        os->ptr[os->length] = '\0';
        goto LAB_080b97ca;
      }
      if ((WcOption.ucs_conv == '\0') || (WcOption.use_jisx0213 == '\0')) {
        cc.ccs = 0xc000;
      }
      else {
        wc_jisx0212_to_jisx0213((wc_wchar_t)CONCAT44(0x8144,&local_14));
        cc.ccs = local_14;
        cc.code = local_10;
      }
      goto LAB_080b935e;
    }
  }
LAB_080b976a:
  if (WcOption.ucs_conv == '\0') {
    if ((cc.ccs & 0x18000) == 0) {
      cc.ccs = 0x4000;
    }
    else {
      cc.ccs = 0xc000;
    }
  }
  else {
    wc_any_to_any_ces((wc_wchar_t)CONCAT44(cc.ccs,&local_14),(wc_status *)cc.code);
    cc.ccs = local_14;
    cc.code = local_10;
  }
  goto LAB_080b935e;
}



void wc_push_to_euctw(Str os,wc_wchar_t cc,wc_status *st)

{
  int iVar1;
  
  do {
    if (cc.ccs < 0x814e) {
      if (0x8147 < cc.ccs) {
        if (os->area_size <= os->length + 1) {
          Strgrow(os);
        }
        iVar1 = os->length;
        os->ptr[iVar1] = -0x72;
        os->length = iVar1 + 1;
        os->ptr[os->length] = '\0';
        if (os->area_size <= os->length + 1) {
          Strgrow(os);
        }
        iVar1 = os->length;
        os->ptr[iVar1] = (char)cc.ccs + 'Z';
        os->length = iVar1 + 1;
        os->ptr[os->length] = '\0';
LAB_080b9b7a:
        if (os->area_size <= os->length + 1) {
          Strgrow(os);
        }
        iVar1 = os->length;
        os->ptr[iVar1] = (byte)(cc.code >> 8) | 0x80;
        os->length = iVar1 + 1;
        os->ptr[os->length] = '\0';
        if (os->area_size <= os->length + 1) {
          Strgrow(os);
        }
        iVar1 = os->length;
        os->ptr[iVar1] = (byte)cc.code | 0x80;
        os->length = iVar1 + 1;
        os->ptr[os->length] = '\0';
        return;
      }
      if (cc.ccs == 0x4000) {
        if (WcOption.no_replace != '\0') {
          return;
        }
        Strcat_charp(os,WcReplace);
        return;
      }
      if (cc.ccs < 0x4001) {
        if (cc.ccs == 0x142) {
          if (os->area_size <= os->length + 1) {
            Strgrow(os);
          }
          iVar1 = os->length;
          os->ptr[iVar1] = (char)cc.code;
          os->length = iVar1 + 1;
          os->ptr[os->length] = '\0';
          return;
        }
      }
      else {
        if (cc.ccs == 0x4001) {
          if (os->area_size <= os->length + 1) {
            Strgrow(os);
          }
          iVar1 = os->length;
          os->ptr[iVar1] = (byte)cc.code | 0x80;
          os->length = iVar1 + 1;
          os->ptr[os->length] = '\0';
          return;
        }
        if (cc.ccs == 0x8147) goto LAB_080b9b7a;
      }
    }
    else if (0x8803 < cc.ccs) {
      if (cc.ccs < 0x880d) {
        if (os->area_size <= os->length + 1) {
          Strgrow(os);
        }
        iVar1 = os->length;
        os->ptr[iVar1] = -0x72;
        os->length = iVar1 + 1;
        os->ptr[os->length] = '\0';
        if (os->area_size <= os->length + 1) {
          Strgrow(os);
        }
        iVar1 = os->length;
        os->ptr[iVar1] = (char)cc.ccs + -0x5c;
        os->length = iVar1 + 1;
        os->ptr[os->length] = '\0';
        goto LAB_080b9b7a;
      }
      if (cc.ccs == 0xc000) {
        if (WcOption.no_replace == '\0') {
          Strcat_charp(os,WcReplaceW);
        }
        return;
      }
    }
    if (WcOption.ucs_conv == '\0') {
      if ((cc.ccs & 0x18000) == 0) {
        cc.ccs = 0x4000;
      }
      else {
        cc.ccs = 0xc000;
      }
    }
    else {
      wc_any_to_any_ces((wc_wchar_t)CONCAT44(cc.ccs,&cc),(wc_status *)cc.code);
    }
  } while( true );
}



void wc_push_to_iso8859(Str os,wc_wchar_t cc,wc_status *st)

{
  wc_ccs wVar1;
  int iVar2;
  wc_ccs g1_ccs;
  
  wVar1 = st->ces_info->gset[1].ccs;
  do {
    if (cc.ccs == wVar1) {
      if (os->area_size <= os->length + 1) {
        Strgrow(os);
      }
      iVar2 = os->length;
      os->ptr[iVar2] = (byte)cc.code | 0x80;
      os->length = iVar2 + 1;
      os->ptr[os->length] = '\0';
      return;
    }
    if (cc.ccs == 0x4000) {
      if (WcOption.no_replace != '\0') {
        return;
      }
      Strcat_charp(os,WcReplace);
      return;
    }
    if (cc.ccs < 0x4001) {
      if (cc.ccs == 0x142) {
        if (os->area_size <= os->length + 1) {
          Strgrow(os);
        }
        iVar2 = os->length;
        os->ptr[iVar2] = (char)cc.code;
        os->length = iVar2 + 1;
        os->ptr[os->length] = '\0';
        return;
      }
    }
    else {
      if (cc.ccs == 0x4001) {
        if (os->area_size <= os->length + 1) {
          Strgrow(os);
        }
        iVar2 = os->length;
        os->ptr[iVar2] = (byte)cc.code | 0x80;
        os->length = iVar2 + 1;
        os->ptr[os->length] = '\0';
        return;
      }
      if (cc.ccs == 0xc000) {
        if (WcOption.no_replace != '\0') {
          return;
        }
        Strcat_charp(os,WcReplaceW);
        return;
      }
    }
    if (WcOption.ucs_conv == '\0') {
      if ((cc.ccs & 0x18000) == 0) {
        cc.ccs = 0x4000;
      }
      else {
        cc.ccs = 0xc000;
      }
    }
    else {
      wc_any_to_any_ces((wc_wchar_t)CONCAT44(cc.ccs,&cc),(wc_status *)cc.code);
    }
  } while( true );
}



void wc_create_gmap(wc_status *st)

{
  wc_gset *pwVar1;
  wc_uchar *pwVar2;
  wc_bool wVar3;
  uint uVar4;
  uint uVar5;
  int f;
  int i;
  wc_uchar *gset_ext;
  wc_gset *gset;
  
  pwVar1 = st->ces_info->gset;
  pwVar2 = st->ces_info->gset_ext;
  if (WcOption.strict_iso2022 == '\0') {
    for (i = 0; i < 0x40; i = i + 1) {
      cs94_gmap[i] = *pwVar2;
      cs96_gmap[i] = pwVar2[1];
      cs94w_gmap[i] = pwVar2[2];
      cs96w_gmap[i] = pwVar2[3];
      cs942_gmap[i] = *pwVar2;
    }
  }
  else {
    for (i = 0; i < 0x40; i = i + 1) {
      cs94_gmap[i] = '\0';
      cs96_gmap[i] = '\0';
      cs94w_gmap[i] = '\0';
      cs96w_gmap[i] = '\0';
      cs942_gmap[i] = '\0';
    }
  }
  for (i = 0; pwVar1[i].ccs != 0; i = i + 1) {
    uVar4 = pwVar1[i].ccs & 0xff;
    uVar5 = pwVar1[i].ccs & 0xff00;
    if (uVar5 == 0x400) {
      cs96w_gmap[uVar4] = pwVar1[i].g;
    }
    else if (uVar5 < 0x401) {
      if (uVar5 == 0x100) {
        if ((pwVar1[i].ccs != 0x149) || (WcOption.use_jisx0201k != '\0')) {
          *(wc_uchar *)((int)char_conv_st.design + uVar4 + 0x10) = pwVar1[i].g;
        }
      }
      else if (uVar5 == 0x200) {
        cs94w_gmap[uVar4] = pwVar1[i].g;
      }
    }
    else if (uVar5 == 0x8100) {
      uVar5 = pwVar1[i].ccs;
      wVar3 = WcOption.use_jisx0212;
      if (((uVar5 != 0x8144) &&
          ((uVar5 < 0x8144 || (wVar3 = WcOption.use_jisx0213, 1 < uVar5 - 0x814f)))) ||
         (wVar3 != '\0')) {
        cs94_gmap[uVar4] = pwVar1[i].g;
      }
    }
    else if (uVar5 == 0x8200) {
      cs96_gmap[uVar4] = pwVar1[i].g;
    }
  }
  return;
}



Str wc_char_conv_from_iso2022(wc_uchar c,wc_status *st)

{
  int iVar1;
  Str p_Var2;
  uint ccs;
  uint uVar3;
  wc_ccs gr_ccs;
  wc_ccs gl_ccs;
  wc_uchar *p;
  
  if (st->state == -1) {
    st->state = 0;
    wc_char_conv_from_iso2022::os = Strnew_size(8);
    wc_char_conv_from_iso2022::nbuf = 0;
  }
  if (st->ss == '\0') {
    uVar3 = st->design[st->gl];
  }
  else {
    uVar3 = st->design[st->ss];
  }
  if (st->ss == '\0') {
    ccs = st->design[st->gr];
  }
  else {
    ccs = st->design[st->ss];
  }
  switch(st->state) {
  case 0:
    switch(WC_ISO_MAP[c]) {
    case '\x01':
    case '\x02':
    case '\x03':
    case '\x04':
    case '\x05':
    case '\x06':
    case '\a':
    case '\b':
    case '\t':
    case '\n':
    case '\v':
    case '\f':
    case '\r':
    case '\x0e':
    case '\x0f':
    case '\x14':
    case '\x15':
    case '\x16':
    case '\x17':
    case '\x18':
    case '\x19':
    case '\x1a':
    case '\x1b':
    case '\x1c':
    case '\x1d':
    case '\x1e':
    case '\x1f':
    case '!':
    case '\"':
    case '#':
    case '$':
    case '%':
    case '&':
    case '\'':
    case '(':
    case ')':
    case '*':
    case '+':
    case ',':
    case '-':
    case '.':
    case '/':
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
    case ':':
    case ';':
    case '<':
    case '=':
    case '>':
    case '?':
    case 'A':
    case 'B':
    case 'C':
    case 'D':
    case 'E':
    case 'F':
    case 'G':
    case 'H':
    case 'I':
    case 'J':
    case 'K':
    case 'L':
    case 'M':
    case 'N':
    case 'O':
    case 'Q':
    case 'R':
    case 'S':
    case 'V':
    case 'W':
    case 'X':
    case 'Y':
    case 'Z':
    case '[':
    case '\\':
    case ']':
    case '^':
    case '_':
      break;
    case '\x10':
      if (wc_char_conv_from_iso2022::os->area_size <= wc_char_conv_from_iso2022::os->length + 1) {
        Strgrow(wc_char_conv_from_iso2022::os);
      }
      p_Var2 = wc_char_conv_from_iso2022::os;
      iVar1 = wc_char_conv_from_iso2022::os->length;
      wc_char_conv_from_iso2022::os->ptr[iVar1] = c;
      p_Var2->length = iVar1 + 1;
      wc_char_conv_from_iso2022::os->ptr[wc_char_conv_from_iso2022::os->length] = '\0';
      break;
    case '\x11':
      st->gl = '\x01';
      break;
    case '\x12':
      st->gl = '\0';
      break;
    case '\x13':
      wc_char_conv_from_iso2022::buf[wc_char_conv_from_iso2022::nbuf] = c;
      wc_char_conv_from_iso2022::nbuf = wc_char_conv_from_iso2022::nbuf + 1;
      st->state = 0x1b;
      return (Str)0x0;
    case ' ':
      if ((uVar3 & 0x200) == 0) {
        if (wc_char_conv_from_iso2022::os->area_size <= wc_char_conv_from_iso2022::os->length + 1) {
          Strgrow(wc_char_conv_from_iso2022::os);
        }
        p_Var2 = wc_char_conv_from_iso2022::os;
        iVar1 = wc_char_conv_from_iso2022::os->length;
        wc_char_conv_from_iso2022::os->ptr[iVar1] = c;
        p_Var2->length = iVar1 + 1;
        wc_char_conv_from_iso2022::os->ptr[wc_char_conv_from_iso2022::os->length] = '\0';
        break;
      }
    case '\0':
      if ((uVar3 & 0x18000) != 0) {
        wc_char_conv_from_iso2022::buf[wc_char_conv_from_iso2022::nbuf] = c;
        wc_char_conv_from_iso2022::nbuf = wc_char_conv_from_iso2022::nbuf + 1;
        st->state = 1;
        return (Str)0x0;
      }
      if (uVar3 == 0x100) {
        if (wc_char_conv_from_iso2022::os->area_size <= wc_char_conv_from_iso2022::os->length + 1) {
          Strgrow(wc_char_conv_from_iso2022::os);
        }
        p_Var2 = wc_char_conv_from_iso2022::os;
        iVar1 = wc_char_conv_from_iso2022::os->length;
        wc_char_conv_from_iso2022::os->ptr[iVar1] = c;
        p_Var2->length = iVar1 + 1;
        wc_char_conv_from_iso2022::os->ptr[wc_char_conv_from_iso2022::os->length] = '\0';
      }
      else {
        wtf_push_iso2022(wc_char_conv_from_iso2022::os,uVar3,(uint)c);
      }
      break;
    case 'P':
      break;
    case 'T':
      if (st->design[2] == 0) {
        return wc_char_conv_from_iso2022::os;
      }
      st->ss = '\x02';
      return (Str)0x0;
    case 'U':
      if (st->design[3] == 0) {
        return wc_char_conv_from_iso2022::os;
      }
      st->ss = '\x03';
      return (Str)0x0;
    case '`':
      if ((ccs & 0x200) == 0) break;
    case '@':
      if ((ccs & 0x18000) != 0) {
        wc_char_conv_from_iso2022::buf[wc_char_conv_from_iso2022::nbuf] = c;
        wc_char_conv_from_iso2022::nbuf = wc_char_conv_from_iso2022::nbuf + 1;
        st->state = 2;
        return (Str)0x0;
      }
      if (ccs != 0) {
        wtf_push_iso2022(wc_char_conv_from_iso2022::os,ccs,(uint)c);
      }
    }
    break;
  case 1:
    if ((WC_ISO_MAP[c] == '\0') || ((WC_ISO_MAP[c] == ' ' && ((uVar3 & 0x200) != 0)))) {
      wc_char_conv_from_iso2022::buf[wc_char_conv_from_iso2022::nbuf] = c;
      wc_char_conv_from_iso2022::nbuf = wc_char_conv_from_iso2022::nbuf + 1;
      wtf_push_iso2022(wc_char_conv_from_iso2022::os,uVar3,
                       (uint)CONCAT11(wc_char_conv_from_iso2022::buf[0],
                                      wc_char_conv_from_iso2022::buf[1]));
    }
    st->state = 0;
    break;
  case 2:
    if ((WC_ISO_MAP[c] == '@') || ((WC_ISO_MAP[c] == '`' && ((ccs & 0x200) != 0)))) {
      if (ccs == 0x880d) {
        wc_char_conv_from_iso2022::buf[wc_char_conv_from_iso2022::nbuf] = c;
        wc_char_conv_from_iso2022::nbuf = wc_char_conv_from_iso2022::nbuf + 1;
        st->state = 5;
        return (Str)0x0;
      }
      wc_char_conv_from_iso2022::buf[wc_char_conv_from_iso2022::nbuf] = c;
      wc_char_conv_from_iso2022::nbuf = wc_char_conv_from_iso2022::nbuf + 1;
      wtf_push_iso2022(wc_char_conv_from_iso2022::os,ccs,
                       (uint)CONCAT11(wc_char_conv_from_iso2022::buf[0],
                                      wc_char_conv_from_iso2022::buf[1]));
    }
    st->state = 0;
    break;
  case 5:
    if (WC_ISO_MAP[c] == '@') {
      wc_char_conv_from_iso2022::buf[wc_char_conv_from_iso2022::nbuf] = c;
      wc_char_conv_from_iso2022::nbuf = wc_char_conv_from_iso2022::nbuf + 1;
      if ((0xa0 < wc_char_conv_from_iso2022::buf[0]) && (wc_char_conv_from_iso2022::buf[0] < 0xa8))
      {
        wtf_push_iso2022(wc_char_conv_from_iso2022::os,wc_char_conv_from_iso2022::buf[0] + 0x80a6,
                         (uint)CONCAT11(wc_char_conv_from_iso2022::buf[1],
                                        wc_char_conv_from_iso2022::buf[2]));
        break;
      }
      if ((0xa7 < wc_char_conv_from_iso2022::buf[0]) && (wc_char_conv_from_iso2022::buf[0] < 0xb1))
      {
        wtf_push_iso2022(wc_char_conv_from_iso2022::os,wc_char_conv_from_iso2022::buf[0] + 0x875c,
                         (uint)CONCAT11(wc_char_conv_from_iso2022::buf[1],
                                        wc_char_conv_from_iso2022::buf[2]));
        break;
      }
    }
    st->state = 0;
    break;
  case 0x1b:
    switch(c) {
    case '!':
    case '\"':
    case '&':
    case ',':
    case '-':
    case '.':
    case '/':
      wc_char_conv_from_iso2022::buf[wc_char_conv_from_iso2022::nbuf] = c;
      wc_char_conv_from_iso2022::nbuf = wc_char_conv_from_iso2022::nbuf + 1;
      st->state = 0x2c;
      return (Str)0x0;
    case '#':
    case '\'':
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
    case ':':
    case ';':
    case '<':
    case '=':
    case '>':
    case '?':
    case '@':
    case 'A':
    case 'B':
    case 'C':
    case 'D':
    case 'E':
    case 'F':
    case 'G':
    case 'H':
    case 'I':
    case 'J':
    case 'K':
    case 'L':
    case 'M':
    case 'P':
    case 'Q':
    case 'R':
    case 'S':
    case 'T':
    case 'U':
    case 'V':
    case 'W':
    case 'X':
    case 'Y':
    case 'Z':
    case '[':
    case '\\':
    case ']':
    case '^':
    case '_':
    case '`':
    case 'a':
    case 'b':
    case 'c':
    case 'd':
    case 'e':
    case 'f':
    case 'g':
    case 'h':
    case 'i':
    case 'j':
    case 'k':
    case 'l':
    case 'm':
    case 'p':
    case 'q':
    case 'r':
    case 's':
    case 't':
    case 'u':
    case 'v':
    case 'w':
    case 'x':
    case 'y':
    case 'z':
    case '{':
      break;
    case '$':
    case '%':
      wc_char_conv_from_iso2022::buf[wc_char_conv_from_iso2022::nbuf] = c;
      wc_char_conv_from_iso2022::nbuf = wc_char_conv_from_iso2022::nbuf + 1;
      st->state = (uint)c;
      return (Str)0x0;
    case '(':
    case ')':
    case '*':
    case '+':
      wc_char_conv_from_iso2022::buf[wc_char_conv_from_iso2022::nbuf] = c;
      wc_char_conv_from_iso2022::nbuf = wc_char_conv_from_iso2022::nbuf + 1;
      st->state = 0x28;
      return (Str)0x0;
    case 'N':
      st->ss = '\x02';
      st->state = 0;
      return (Str)0x0;
    case 'O':
      st->ss = '\x03';
      st->state = 0;
      return (Str)0x0;
    case 'n':
      st->gl = '\x02';
      break;
    case 'o':
      st->gl = '\x03';
      break;
    case '|':
      st->gr = '\x03';
      break;
    case '}':
      st->gr = '\x02';
    }
    break;
  case 0x24:
    uVar3 = (uint)c;
    if (0x27 < uVar3) {
      if (uVar3 < 0x30) {
        wc_char_conv_from_iso2022::buf[wc_char_conv_from_iso2022::nbuf] = c;
        wc_char_conv_from_iso2022::nbuf = wc_char_conv_from_iso2022::nbuf + 1;
        st->state = 0x2c;
        return (Str)0x0;
      }
      if (uVar3 - 0x40 < 3) {
        wc_char_conv_from_iso2022::buf[wc_char_conv_from_iso2022::nbuf] = c;
        wc_char_conv_from_iso2022::nbuf = wc_char_conv_from_iso2022::nbuf + 1;
        p = wc_char_conv_from_iso2022::buf;
        wc_parse_iso2022_esc(&p,st);
      }
    }
    break;
  case 0x25:
    if (c == '/') {
      wc_char_conv_from_iso2022::buf[wc_char_conv_from_iso2022::nbuf] = '/';
      wc_char_conv_from_iso2022::nbuf = wc_char_conv_from_iso2022::nbuf + 1;
      st->state = 0x29;
      return (Str)0x0;
    }
    wc_char_conv_from_iso2022::buf[wc_char_conv_from_iso2022::nbuf] = c;
    wc_char_conv_from_iso2022::nbuf = wc_char_conv_from_iso2022::nbuf + 1;
    p = wc_char_conv_from_iso2022::buf;
    wc_parse_iso2022_esc(&p,st);
    break;
  case 0x28:
    if (c == '!') {
      wc_char_conv_from_iso2022::buf[wc_char_conv_from_iso2022::nbuf] = '!';
      wc_char_conv_from_iso2022::nbuf = wc_char_conv_from_iso2022::nbuf + 1;
      st->state = 0x2c;
      return (Str)0x0;
    }
  case 0x2c:
    wc_char_conv_from_iso2022::buf[wc_char_conv_from_iso2022::nbuf] = c;
    wc_char_conv_from_iso2022::nbuf = wc_char_conv_from_iso2022::nbuf + 1;
    p = wc_char_conv_from_iso2022::buf;
    wc_parse_iso2022_esc(&p,st);
  }
  st->ss = '\0';
  st->state = -1;
  return wc_char_conv_from_iso2022::os;
}



wc_wchar_t wc_jisx0201k_to_jisx0208(wc_wchar_t cc)

{
  ushort uVar1;
  undefined4 uVar2;
  uint in_stack_0000000c;
  
  uVar1 = jisx0201k_jisx0208_map[in_stack_0000000c & 0x7f];
  if (uVar1 == 0) {
    uVar2 = 0xc000;
  }
  else {
    uVar2 = 0x8142;
  }
  *(undefined4 *)cc.ccs = uVar2;
  *(uint *)(cc.ccs + 4) = (uint)uVar1;
  return (wc_wchar_t)(ulonglong)CONCAT24(uVar1,cc.ccs);
}



wc_wchar_t wc_jisx0212_to_jisx0213(wc_wchar_t cc)

{
  wc_wchar_t wVar1;
  wc_table *in_stack_0000000c;
  wc_wchar_t cc2;
  
  if (wc_jisx0212_to_jisx0213::t1 == (wc_table *)0x0) {
    wc_jisx0212_to_jisx0213::t1 = wc_get_ucs_table(0x814f);
    wc_jisx0212_to_jisx0213::t2 = wc_get_ucs_table(0x8150);
  }
  wc_any_to_any((wc_wchar_t)((ulonglong)cc & 0xffffffff00000000 | ZEXT48(&cc2)),in_stack_0000000c);
  if (cc2.ccs == 0x8144) {
    *(undefined4 *)cc.ccs = 0x8144;
    *(wc_uint32 *)(cc.ccs + 4) = cc2.code;
  }
  else {
    wVar1 = wc_any_to_any(cc,in_stack_0000000c);
    cc2.code = (wc_uint32)((ulonglong)wVar1 >> 0x20);
  }
  return (wc_wchar_t)((ulonglong)cc & 0xffffffff | (ulonglong)cc2.code << 0x20);
}



wc_wchar_t wc_jisx0213_to_jisx0212(wc_wchar_t cc)

{
  wc_wchar_t wVar1;
  wc_table *in_stack_0000000c;
  
  if (wc_jisx0213_to_jisx0212::t == (wc_table *)0x0) {
    wc_jisx0213_to_jisx0212::t = wc_get_ucs_table(0x8144);
  }
  wVar1 = wc_any_to_any(cc,in_stack_0000000c);
  return (wc_wchar_t)((ulonglong)wVar1 & 0xffffffff00000000 | (ulonglong)cc & 0xffffffff);
}



wc_ccs wc_jisx0208_or_jisx02131(wc_uint16 code)

{
  wc_map *pwVar1;
  wc_ccs wVar2;
  
  pwVar1 = wc_map_range_search(code & 0x7f7f,jisx0208_jisx02131_map,0x12);
  if (pwVar1 == (wc_map *)0x0) {
    wVar2 = 0x8142;
  }
  else {
    wVar2 = 0x814f;
  }
  return wVar2;
}



wc_ccs wc_jisx0212_or_jisx02132(wc_uint16 code)

{
  wc_ccs wVar1;
  
  if (wc_jisx0212_jisx02132_map[code >> 8 & 0x7f] == '\0') {
    wVar1 = 0x8144;
  }
  else {
    wVar1 = 0x8150;
  }
  return wVar1;
}



wc_wchar_t wc_johab_to_ksx1001(wc_wchar_t cc)

{
  wc_ccs wVar1;
  wc_wchar_t wVar2;
  wc_table *in_stack_0000000c;
  uint local_14 [3];
  
  wVar1 = cc.ccs;
  if (cc.code < 0x8812) {
    if (cc.code < 0x8810) {
      if (cc.code == 0x880f) {
        wc_johab_to_cs128w((wc_wchar_t)(cc & 0xffffffff00000000 | ZEXT48(local_14)));
        wVar2 = wc_johab_to_ksx1001((wc_wchar_t)(cc & 0xffffffff | (ulonglong)local_14[0] << 0x20));
        in_stack_0000000c = (wc_table *)((ulonglong)wVar2 >> 0x20);
        goto LAB_080baacc;
      }
    }
    else if (WcOption.ucs_conv == '\0') {
      cc.code = 0xc000;
    }
    else {
      if (wc_johab_to_ksx1001::t == (wc_table *)0x0) {
        wc_johab_to_ksx1001::t = wc_get_ucs_table(0x8143);
      }
      wc_any_to_any((wc_wchar_t)CONCAT44(cc.code,(int)&cc + 4),in_stack_0000000c);
    }
  }
  else if (cc.code == 0x8812) {
    if (in_stack_0000000c < (wc_table *)0x2121) {
      cc.code = 0xc000;
    }
    else {
      cc.code = 0x8143;
    }
  }
  *(wc_uint32 *)wVar1 = cc.code;
  *(wc_table **)(wVar1 + 4) = in_stack_0000000c;
LAB_080baacc:
  return (wc_wchar_t)(cc & 0xffffffff | ZEXT48(in_stack_0000000c) << 0x20);
}



wc_wchar_t wc_ksx1001_to_johab(wc_wchar_t cc)

{
  wc_ccs wVar1;
  uint uVar2;
  uint in_stack_0000000c;
  
  wVar1 = cc.ccs;
  uVar2 = in_stack_0000000c & 0x7f7f;
  if ((((uVar2 < 0x2121) || (0x2420 < uVar2)) && ((uVar2 < 0x2454 || (0x2c7e < uVar2)))) &&
     ((uVar2 < 0x4a21 || (0x7d7e < uVar2)))) {
    if (WcOption.ucs_conv == '\0') {
      cc.code = 0xc000;
    }
    else {
      wc_any_to_ucs((wc_wchar_t)(CONCAT44(in_stack_0000000c,cc.code) & 0x7f7fffffffff));
      wc_ucs_to_johab((int)&cc + 4);
    }
    *(wc_uint32 *)wVar1 = cc.code;
    *(uint *)(wVar1 + 4) = uVar2;
  }
  else {
    *(undefined4 *)cc.ccs = 0x8812;
    *(uint *)(cc.ccs + 4) = uVar2;
  }
  return (wc_wchar_t)(cc & 0xffffffff | ((ulonglong)in_stack_0000000c & 0x7f7f) << 0x20);
}



wc_wchar_t wc_ucs_to_johab(wc_uint32 ucs)

{
  wc_table *in_stack_00000008;
  wc_ccs local_24;
  wc_uint32 local_20;
  wc_wchar_t cc;
  wc_table *t;
  
  if ((in_stack_00000008 < (wc_table *)0xac00) || ((wc_table *)0xd7a3 < in_stack_00000008)) {
    if ((in_stack_00000008 < (wc_table *)0x3131) || ((wc_table *)0x3163 < in_stack_00000008)) {
      wc_get_ucs_table(0x8812);
      wc_ucs_to_any((wc_uint32)&local_24,in_stack_00000008);
      cc.ccs = local_24;
      cc.code = local_20;
    }
    else {
      wc_get_ucs_table(0x8811);
      wc_ucs_to_any((wc_uint32)&cc,in_stack_00000008);
    }
  }
  else {
    cc.code = wc_N_to_johab1((wc_uint32)(in_stack_00000008 + -0xac0));
    cc.ccs = 0x880f;
  }
  *(wc_ccs *)ucs = cc.ccs;
  *(wc_uint32 *)(ucs + 4) = cc.code;
  return (wc_wchar_t)CONCAT44(cc.code,ucs);
}



wc_uint32 wc_johab1_to_N(wc_uint32 code)

{
  wc_uint32 wVar1;
  wc_uint32 c;
  wc_uint32 b;
  wc_uint32 a;
  
  if (((johab1_N_map[code >> 10 & 0x1f] == 0) || (johab1_N_map[1][code >> 5 & 0x1f] == 0)) ||
     (johab1_N_map[2][code & 0x1f] == 0)) {
    wVar1 = 0xffffffff;
  }
  else {
    wVar1 = (((uint)johab1_N_map[code >> 10 & 0x1f] * 0x15 + (uint)johab1_N_map[1][code >> 5 & 0x1f]
             ) * 0x1c + (uint)johab1_N_map[2][code & 0x1f]) - 0x269;
  }
  return wVar1;
}



wc_uint32 wc_N_to_johab1(wc_uint32 code)

{
  wc_uint32 c;
  wc_uint32 b;
  wc_uint32 a;
  
  return (uint)N_johab1_map[1][((code >> 2) / 7) % 0x15] << 5 |
         (uint)N_johab1_map[code / 0x24c] << 10 |
         (uint)*(byte *)((int)N_johab1_map + code + ((code >> 2) / 7) * -0x1c + 0x40) | 0x8000;
}



// WARNING: Could not reconcile some variable overlaps

wc_wchar_t wc_johab_to_cs128w(wc_wchar_t cc)

{
  byte bVar1;
  byte bVar2;
  char cVar3;
  char cVar4;
  wc_uint32 wVar5;
  int iVar6;
  uint uVar7;
  uint in_stack_0000000c;
  wc_uint32 n;
  wc_uchar lb;
  wc_uchar ub;
  
  if (in_stack_0000000c < 0xd800) {
    wVar5 = wc_johab1_to_N(in_stack_0000000c);
    if (wVar5 == 0xffffffff) {
      if ((in_stack_0000000c & 0xff) < 0x81) {
        iVar6 = 0x41;
      }
      else {
        iVar6 = 0x43;
      }
      uVar7 = (((in_stack_0000000c >> 8 & 0xff) * 0xbc + (in_stack_0000000c & 0xff)) - iVar6) -
              0x60f0;
      in_stack_0000000c = (uVar7 >> 7) * 0x100 + (uVar7 & 0x7f);
      cc.code = 0x8811;
    }
    else {
      in_stack_0000000c = ((wVar5 >> 7) + 0x21) * 0x100 + (wVar5 & 0x7f);
      cc.code = 0x8810;
    }
  }
  else {
    bVar1 = (byte)(in_stack_0000000c >> 8);
    bVar2 = (byte)in_stack_0000000c;
    if (bVar1 < 0xe0) {
      cVar3 = (bVar1 + 0x28) * '\x02' + '\x1f';
    }
    else {
      cVar3 = (bVar1 + 0x20) * '\x02' + 'J';
    }
    if (bVar2 < 0xa1) {
      if (bVar2 < 0x91) {
        cVar4 = '\x10';
      }
      else {
        cVar4 = '\"';
      }
      _lb = CONCAT11(cVar3,bVar2 - cVar4);
    }
    else {
      _lb = CONCAT11(cVar3 + '\x01',bVar2 + 0x80);
    }
    in_stack_0000000c = (uint)_lb;
    cc.code = 0x8812;
  }
  *(wc_uint32 *)cc.ccs = cc.code;
  *(uint *)(cc.ccs + 4) = in_stack_0000000c;
  return (wc_wchar_t)CONCAT44(in_stack_0000000c,cc.ccs);
}



// WARNING: Could not reconcile some variable overlaps

wc_wchar_t wc_cs128w_to_johab(wc_wchar_t cc)

{
  uint uVar1;
  char cVar2;
  int iVar3;
  uint in_stack_0000000c;
  wc_uint32 n;
  wc_uchar lb;
  wc_uchar ub;
  
  if (cc.code == 0x8811) {
    uVar1 = (in_stack_0000000c >> 8 & 0x7f) * 0x80 + (in_stack_0000000c & 0x7f);
    if (uVar1 % 0xbc < 0x3e) {
      iVar3 = 0x41;
    }
    else {
      iVar3 = 0x43;
    }
    in_stack_0000000c = (uVar1 / 0xbc + 0x84) * 0x100 + uVar1 % 0xbc + iVar3;
  }
  else if (cc.code == 0x8812) {
    ub = (byte)(in_stack_0000000c >> 8) & 0x7f;
    if (ub < 0x4a) {
      lb = (byte)in_stack_0000000c & 0x7f;
      if ((ub - 0x1f & 1) == 0) {
        if (lb < 0x6f) {
          cVar2 = '\x10';
        }
        else {
          cVar2 = '\"';
        }
      }
      else {
        cVar2 = -0x80;
      }
      _lb = CONCAT11(((byte)(ub - 0x1f) >> 1) - 0x28,lb + cVar2);
    }
    else {
      lb = (byte)in_stack_0000000c & 0x7f;
      if ((ub + 0xb6 & 1) == 0) {
        if (lb < 0x6f) {
          cVar2 = '\x10';
        }
        else {
          cVar2 = '\"';
        }
      }
      else {
        cVar2 = -0x80;
      }
      _lb = CONCAT11(((byte)(ub + 0xb6) >> 1) - 0x20,lb + cVar2);
    }
    in_stack_0000000c = (uint)_lb;
  }
  else if (cc.code == 0x8810) {
    in_stack_0000000c =
         wc_N_to_johab1(((in_stack_0000000c >> 8 & 0x7f) + 0x1ffffdf) * 0x80 +
                        (in_stack_0000000c & 0x7f));
  }
  *(undefined4 *)cc.ccs = 0x880f;
  *(uint *)(cc.ccs + 4) = in_stack_0000000c;
  return (wc_wchar_t)(cc & 0xffffffff | (ulonglong)in_stack_0000000c << 0x20);
}



Str wc_conv_from_johab(Str is,wc_ces ces)

{
  wc_uchar *pwVar1;
  int iVar2;
  byte bVar3;
  wc_uchar *pwVar4;
  Str x;
  int state;
  wc_uchar *p;
  wc_uchar *ep;
  wc_uchar *sp;
  Str os;
  
  pwVar1 = (wc_uchar *)is->ptr;
  pwVar4 = pwVar1 + is->length;
  state = 0;
  for (p = pwVar1; (p < pwVar4 && (-1 < (char)*p)); p = p + 1) {
  }
  if (p != pwVar4) {
    x = Strnew_size(is->length);
    if (pwVar1 < p) {
      Strcat_charp_n(x,is->ptr,(int)p - (int)pwVar1);
    }
    for (; p < pwVar4; p = p + 1) {
      if (state == 1) {
        if ((WC_JOHAB_MAP[*p] & 0x10) == 0) {
          wtf_push_unknown(x,p + -1,2);
        }
        else {
          wtf_push(x,0x880f,(uint)CONCAT11(p[-1],*p));
        }
        state = 0;
      }
      else if (state == 2) {
        if ((WC_JOHAB_MAP[*p] & 0x20) == 0) {
          wtf_push_unknown(x,p + -1,2);
        }
        else {
          wtf_push(x,0x880f,(uint)CONCAT11(p[-1],*p));
        }
        state = 0;
      }
      else if (state == 0) {
        bVar3 = WC_JOHAB_MAP[*p] & 0xf;
        if (bVar3 == 4) {
          state = 2;
        }
        else if (bVar3 == 8) {
          wtf_push_unknown(x,p,1);
        }
        else if (bVar3 == 2) {
          state = 1;
        }
        else {
          if (x->area_size <= x->length + 1) {
            Strgrow(x);
          }
          iVar2 = x->length;
          x->ptr[iVar2] = *p;
          x->length = iVar2 + 1;
          x->ptr[x->length] = '\0';
        }
      }
    }
    is = x;
    if (state - 1U < 2) {
      wtf_push_unknown(x,p + -1,1);
    }
  }
  return is;
}



void wc_push_to_johab(Str os,wc_wchar_t cc,wc_status *st)

{
  int iVar1;
  wc_ccs local_14;
  wc_uint32 local_10;
  
LAB_080bb301:
  do {
    if (cc.ccs == 0x880f) {
LAB_080bb3bc:
      if (os->area_size <= os->length + 1) {
        Strgrow(os);
      }
      iVar1 = os->length;
      os->ptr[iVar1] = (char)(cc.code >> 8);
      os->length = iVar1 + 1;
      os->ptr[os->length] = '\0';
      if (os->area_size <= os->length + 1) {
        Strgrow(os);
      }
      iVar1 = os->length;
      os->ptr[iVar1] = (char)cc.code;
      os->length = iVar1 + 1;
      os->ptr[os->length] = '\0';
      return;
    }
    if (0x880f < cc.ccs) {
      if (cc.ccs < 0x8813) {
        wc_cs128w_to_johab((wc_wchar_t)CONCAT44(cc.ccs,&cc));
        goto LAB_080bb3bc;
      }
      if (cc.ccs == 0xc000) {
        if (WcOption.no_replace != '\0') {
          return;
        }
        Strcat_charp(os,WcReplaceW);
        return;
      }
LAB_080bb4d3:
      if (WcOption.ucs_conv == '\0') {
        if ((cc.ccs & 0x18000) == 0) {
          cc.ccs = 0x4000;
        }
        else {
          cc.ccs = 0xc000;
        }
      }
      else {
        wc_any_to_any_ces((wc_wchar_t)CONCAT44(cc.ccs,&local_14),(wc_status *)cc.code);
        cc.ccs = local_14;
        cc.code = local_10;
      }
      goto LAB_080bb301;
    }
    if (cc.ccs == 0x4000) {
      if (WcOption.no_replace != '\0') {
        return;
      }
      Strcat_charp(os,WcReplace);
      return;
    }
    if (cc.ccs != 0x8143) {
      if (cc.ccs == 0x142) {
        if (os->area_size <= os->length + 1) {
          Strgrow(os);
        }
        iVar1 = os->length;
        os->ptr[iVar1] = (char)cc.code;
        os->length = iVar1 + 1;
        os->ptr[os->length] = '\0';
        return;
      }
      goto LAB_080bb4d3;
    }
    wc_ksx1001_to_johab((wc_wchar_t)CONCAT44(0x8143,&local_14));
    cc.ccs = local_14;
    cc.code = local_10;
  } while( true );
}



Str wc_char_conv_from_johab(wc_uchar c,wc_status *st)

{
  int iVar1;
  Str p_Var2;
  byte bVar3;
  
  if (st->state == -1) {
    st->state = 0;
    wc_char_conv_from_johab::os = Strnew_size(8);
  }
  iVar1 = st->state;
  if (iVar1 == 1) {
    if ((WC_JOHAB_MAP[c] & 0x10) != 0) {
      wtf_push(wc_char_conv_from_johab::os,0x880f,(uint)CONCAT11(wc_char_conv_from_johab::johabu,c))
      ;
    }
  }
  else if (iVar1 == 2) {
    if ((WC_JOHAB_MAP[c] & 0x20) != 0) {
      wtf_push(wc_char_conv_from_johab::os,0x880f,(uint)CONCAT11(wc_char_conv_from_johab::johabu,c))
      ;
    }
  }
  else if (iVar1 == 0) {
    bVar3 = WC_JOHAB_MAP[c] & 0xf;
    if (bVar3 == 4) {
      wc_char_conv_from_johab::johabu = c;
      st->state = 2;
      return (Str)0x0;
    }
    if (bVar3 != 8) {
      if (bVar3 == 2) {
        wc_char_conv_from_johab::johabu = c;
        st->state = 1;
        return (Str)0x0;
      }
      if (wc_char_conv_from_johab::os->area_size <= wc_char_conv_from_johab::os->length + 1) {
        Strgrow(wc_char_conv_from_johab::os);
      }
      p_Var2 = wc_char_conv_from_johab::os;
      iVar1 = wc_char_conv_from_johab::os->length;
      wc_char_conv_from_johab::os->ptr[iVar1] = c;
      p_Var2->length = iVar1 + 1;
      wc_char_conv_from_johab::os->ptr[wc_char_conv_from_johab::os->length] = '\0';
    }
  }
  st->state = -1;
  return wc_char_conv_from_johab::os;
}



void wc_putc_init(wc_ces f_ces,wc_ces t_ces)

{
  wc_output_init(t_ces,&putc_st);
  putc_str = Strnew_size(8);
  putc_f_ces = f_ces;
  putc_t_ces = t_ces;
  return;
}



void wc_putc(char *c,FILE *f)

{
  anon_subr_void_varargs_for_push_to *paVar1;
  wc_ces f_ces;
  Str p_Var2;
  wc_uchar *local_18;
  undefined4 local_14;
  wc_uchar *p;
  
  f_ces = putc_f_ces;
  if (putc_f_ces == 0x310000) {
    p = (wc_uchar *)c;
  }
  else {
    p_Var2 = Strnew_charp(c);
    p_Var2 = wc_Str_conv(p_Var2,f_ces,0x310000);
    p = (wc_uchar *)p_Var2->ptr;
  }
  Strclear(putc_str);
  while (*p != '\0') {
    paVar1 = (putc_st.ces_info)->push_to;
    wtf_parse(&local_18);
    (*paVar1)(putc_str,local_18,local_14,&putc_st);
  }
  fwrite(putc_str->ptr,1,putc_str->length,(FILE *)f);
  return;
}



void wc_putc_end(FILE *f)

{
  Strclear(putc_str);
  wc_push_end(putc_str,&putc_st);
  if (putc_str->length != 0) {
    fwrite(putc_str->ptr,1,putc_str->length,(FILE *)f);
  }
  return;
}



void wc_putc_clear_status(void)

{
  if (((putc_st.ces_info)->id & 0x800) != 0) {
    putc_st.gl = '\0';
    putc_st.gr = '\0';
    putc_st.ss = '\0';
    putc_st.design[0] = 0;
    putc_st.design[1] = 0;
    putc_st.design[2] = 0;
    putc_st.design[3] = 0;
  }
  return;
}



int map_cmp(void *a,void *b)

{
                    // WARNING: Load size is inaccurate
                    // WARNING: Load size is inaccurate
  return (uint)*a - (uint)*b;
}



int map3_cmp(void *a,void *b)

{
                    // WARNING: Load size is inaccurate
                    // WARNING: Load size is inaccurate
  return *a - CONCAT22(*b,*(undefined2 *)((int)b + 2));
}



int map_range_cmp(void *a,void *b)

{
  uint uVar1;
  
                    // WARNING: Load size is inaccurate
                    // WARNING: Load size is inaccurate
  if (*a < *b) {
    uVar1 = 0xffffffff;
  }
  else {
                    // WARNING: Load size is inaccurate
    uVar1 = (uint)(*(ushort *)((int)b + 2) < *a);
  }
  return uVar1;
}



int map2_range_cmp(void *a,void *b)

{
  uint uVar1;
  
                    // WARNING: Load size is inaccurate
                    // WARNING: Load size is inaccurate
  if (*a < *b) {
    uVar1 = 0xffffffff;
  }
  else {
                    // WARNING: Load size is inaccurate
    uVar1 = (uint)(*(ushort *)((int)b + 4) <= *a);
  }
  return uVar1;
}



int map3_range_cmp(void *a,void *b)

{
  uint uVar1;
  
                    // WARNING: Load size is inaccurate
                    // WARNING: Load size is inaccurate
  if (*a < *b) {
    uVar1 = 0xffffffff;
  }
  else {
                    // WARNING: Load size is inaccurate
    uVar1 = (uint)(*(ushort *)((int)b + 2) < *a);
  }
  return uVar1;
}



wc_map * wc_map_search(wc_uint16 code,wc_map *map,size_t n)

{
  wc_map *pwVar1;
  wc_uint16 local_10 [6];
  
  local_10[0] = code;
  pwVar1 = (wc_map *)bsearch(local_10,map,n,4,map_cmp);
  return pwVar1;
}



wc_map3 * wc_map3_search(wc_uint16 c1,wc_uint16 c2,wc_map3 *map,size_t n)

{
  wc_map3 *pwVar1;
  wc_uint32 code;
  
  code = CONCAT22(c1,c2);
  pwVar1 = (wc_map3 *)bsearch(&code,map,n,6,map3_cmp);
  return pwVar1;
}



wc_map * wc_map_range_search(wc_uint16 code,wc_map *map,int n)

{
  wc_map *pwVar1;
  wc_uint16 local_10 [6];
  
  local_10[0] = code;
  pwVar1 = (wc_map *)bsearch(local_10,map,n,4,map_range_cmp);
  return pwVar1;
}



wc_map * wc_map2_range_search(wc_uint16 code,wc_map *map,size_t n)

{
  wc_map *pwVar1;
  wc_uint16 local_10 [6];
  
  local_10[0] = code;
  pwVar1 = (wc_map *)bsearch(local_10,map,n,4,map2_range_cmp);
  return pwVar1;
}



wc_map3 * wc_map3_range_search(wc_uint16 code,wc_map3 *map,size_t n)

{
  wc_map3 *pwVar1;
  wc_uint16 local_10 [6];
  
  local_10[0] = code;
  pwVar1 = (wc_map3 *)bsearch(local_10,map,n,6,map3_range_cmp);
  return pwVar1;
}



// WARNING: Could not reconcile some variable overlaps

wc_wchar_t wc_sjis_to_jis(wc_wchar_t cc)

{
  byte bVar1;
  byte bVar2;
  char cVar3;
  char cVar4;
  undefined4 in_stack_0000000c;
  wc_uchar lb;
  wc_uchar ub;
  
  bVar1 = (byte)((uint)in_stack_0000000c >> 8);
  bVar2 = (byte)in_stack_0000000c;
  if (bVar1 < 0xf0) {
    if (bVar1 < 0xa0) {
      cVar3 = -0x7f;
    }
    else {
      cVar3 = -0x3f;
    }
    cVar3 = (bVar1 - cVar3) * '\x02';
    if (bVar2 < 0x9f) {
      if (bVar2 < 0x7f) {
        cVar4 = '\x1f';
      }
      else {
        cVar4 = ' ';
      }
      _lb = CONCAT11(cVar3 + '!',bVar2 - cVar4);
    }
    else {
      _lb = CONCAT11(cVar3 + '\"',bVar2 + 0x82);
    }
    cc.code = 0x8142;
  }
  else {
    if (bVar2 < 0x9f) {
      if (bVar2 < 0x7f) {
        cVar3 = '\x1f';
      }
      else {
        cVar3 = ' ';
      }
      _lb = CONCAT11(johab1_N_map[2][bVar1 + 0x10],bVar2 - cVar3);
    }
    else {
      _lb = CONCAT11(N_johab1_map[bVar1],bVar2 + 0x82);
    }
    cc.code = 0x8150;
  }
  *(wc_uint32 *)cc.ccs = cc.code;
  *(uint *)(cc.ccs + 4) = (uint)_lb;
  return (wc_wchar_t)(ulonglong)CONCAT24(_lb,cc.ccs);
}



// WARNING: Could not reconcile some variable overlaps

wc_wchar_t wc_jis_to_sjis(wc_wchar_t cc)

{
  char cVar1;
  byte bVar2;
  uint in_stack_0000000c;
  wc_uchar lb;
  wc_uchar ub;
  
  bVar2 = (byte)(in_stack_0000000c >> 8);
  lb = (byte)in_stack_0000000c & 0x7f;
  if (cc.code == 0x8150) {
    if ((in_stack_0000000c & 0x100) == 0) {
      cVar1 = '}';
    }
    else {
      cVar1 = '\x1f';
    }
    _lb = CONCAT11(bVar2,lb + cVar1) & 0x7fff;
    if (0x7e < lb) {
      _lb = (bVar2 & 0x7f) << 8 | (ushort)(byte)(lb + 1);
    }
    _lb = _lb & 0xff | (ushort)jisx02132_sjis_map[ub] << 8;
    if (jisx02132_sjis_map[ub] == 0) {
      *(undefined4 *)cc.ccs = 0xc000;
      *(uint *)(cc.ccs + 4) = in_stack_0000000c;
      goto LAB_080bbc70;
    }
  }
  else {
    if ((in_stack_0000000c & 0x100) == 0) {
      cVar1 = '}';
    }
    else {
      cVar1 = '\x1f';
    }
    _lb = CONCAT11(bVar2,lb + cVar1) & 0x7fff;
    if (0x7e < lb) {
      _lb = (bVar2 & 0x7f) << 8 | (ushort)(byte)(lb + 1);
    }
    bVar2 = (byte)((int)(ub - 0x21) >> 1);
    if (bVar2 < 0x1f) {
      cVar1 = -0x7f;
    }
    else {
      cVar1 = -0x3f;
    }
    _lb = _lb & 0xff | (ushort)(byte)(bVar2 + cVar1) << 8;
  }
  in_stack_0000000c = (uint)_lb;
  *(wc_uint32 *)cc.ccs = cc.code;
  *(uint *)(cc.ccs + 4) = in_stack_0000000c;
LAB_080bbc70:
  return (wc_wchar_t)(cc & 0xffffffff | (ulonglong)in_stack_0000000c << 0x20);
}



// WARNING: Could not reconcile some variable overlaps

wc_wchar_t wc_sjis_ext_to_cs94w(wc_wchar_t cc)

{
  byte bVar1;
  byte bVar2;
  char cVar3;
  char cVar4;
  undefined4 in_stack_0000000c;
  wc_uchar lb;
  wc_uchar ub;
  
  bVar1 = (byte)((uint)in_stack_0000000c >> 8);
  bVar2 = (byte)in_stack_0000000c;
  if (bVar1 < 0xa0) {
    cVar3 = -0x7f;
  }
  else {
    cVar3 = -0x3f;
  }
  cVar3 = (bVar1 - cVar3) * '\x02';
  if (bVar2 < 0x9f) {
    if (bVar2 < 0x7f) {
      cVar4 = '\x1f';
    }
    else {
      cVar4 = ' ';
    }
    _lb = CONCAT11(cVar3 + '!',bVar2 - cVar4);
  }
  else {
    _lb = CONCAT11(cVar3 + '\"',bVar2 + 0x82);
  }
  if (ub < 0x7f) {
    cc.code = 0x8814;
  }
  else {
    _lb = _lb & 0xff | (ushort)(byte)(ub + 0xa2) << 8;
    cc.code = 0x8815;
  }
  *(wc_uint32 *)cc.ccs = cc.code;
  *(uint *)(cc.ccs + 4) = (uint)_lb;
  return (wc_wchar_t)(ulonglong)CONCAT24(_lb,cc.ccs);
}



// WARNING: Could not reconcile some variable overlaps

wc_wchar_t wc_cs94w_to_sjis_ext(wc_wchar_t cc)

{
  byte bVar1;
  char cVar2;
  byte bVar3;
  ushort in_stack_0000000c;
  wc_uchar lb;
  wc_uchar ub;
  
  _lb = in_stack_0000000c & 0x7f7f;
  if (cc.code == 0x8815) {
    _lb = in_stack_0000000c & 0x7f | (ushort)(byte)(ub + 0x5e) << 8;
  }
  if ((_lb & 0x100) == 0) {
    cVar2 = '}';
  }
  else {
    cVar2 = '\x1f';
  }
  bVar1 = lb + cVar2;
  if (0x7e < bVar1) {
    bVar1 = bVar1 + 1;
  }
  bVar3 = (byte)((int)((byte)(_lb >> 8) - 0x21) >> 1);
  if (bVar3 < 0x1f) {
    cVar2 = -0x7f;
  }
  else {
    cVar2 = -0x3f;
  }
  _lb = CONCAT11(bVar3 + cVar2,bVar1);
  *(undefined4 *)cc.ccs = 0x8813;
  *(uint *)(cc.ccs + 4) = (uint)_lb;
  return (wc_wchar_t)(ulonglong)CONCAT24(_lb,cc.ccs);
}



wc_uint32 wc_sjis_ext1_to_N(wc_uint32 c)

{
  byte bVar1;
  uint uVar2;
  wc_uchar ub;
  
  bVar1 = (byte)(c >> 8) & 0x7f;
  uVar2 = (uint)bVar1;
  if (uVar2 == 0x2d) {
    ub = '\0';
  }
  else {
    if ((uVar2 < 0x2d) || (3 < uVar2 - 0x79)) {
      return 0xffffffff;
    }
    ub = bVar1 + 0x88;
  }
  return ((uint)ub * 0x5e + (c & 0x7f)) - 0x21;
}



wc_uint32 wc_sjis_ext2_to_N(wc_uint32 c)

{
  byte bVar1;
  wc_uint32 wVar2;
  wc_uchar ub;
  
  bVar1 = (byte)(c >> 8) & 0x7f;
  if (bVar1 - 0x35 < 5) {
    wVar2 = ((uint)(byte)(bVar1 - 0x30) * 0x5e + (c & 0x7f)) - 0x21;
  }
  else {
    wVar2 = 0xffffffff;
  }
  return wVar2;
}



// WARNING: Removing unreachable block (ram,0x080bbee0)

Str wc_conv_from_sjis(Str is,wc_ces ces)

{
  byte bVar1;
  wc_uchar *pwVar2;
  int iVar3;
  char cVar4;
  wc_uchar *pwVar5;
  Str x;
  wc_ccs wVar6;
  wc_wchar_t cc;
  int state;
  wc_uchar *p;
  wc_uchar *ep;
  wc_uchar *sp;
  Str os;
  wc_uchar jis [2];
  
  pwVar2 = (wc_uchar *)is->ptr;
  pwVar5 = pwVar2 + is->length;
  state = 0;
  for (p = pwVar2; (p < pwVar5 && (-1 < (char)*p)); p = p + 1) {
  }
  if (p != pwVar5) {
    x = Strnew_size(is->length);
    if (pwVar2 < p) {
      Strcat_charp_n(x,is->ptr,(int)p - (int)pwVar2);
    }
    for (; p < pwVar5; p = p + 1) {
      if ((uint)state < 3) {
        if (state == 0) {
          switch(WC_SJIS_MAP[*p]) {
          case '\x12':
          case '\x17':
          case '@':
            wtf_push_unknown(x,p,1);
            break;
          case '\x13':
            wtf_push(x,0x149,(uint)*p);
            break;
          default:
            if (x->area_size <= x->length + 1) {
              Strgrow(x);
            }
            iVar3 = x->length;
            x->ptr[iVar3] = *p;
            x->length = iVar3 + 1;
            x->ptr[x->length] = '\0';
            break;
          case '4':
            state = 1;
            break;
          case '5':
            state = 2;
            break;
          case '6':
            state = 3;
          }
        }
        else {
          if ((WC_SJIS_MAP[*p] & 0x10) == 0) {
            wtf_push_unknown(x,p + -1,2);
          }
          else {
            bVar1 = *p;
            if (p[-1] < 0xa0) {
              cVar4 = -0x7f;
            }
            else {
              cVar4 = -0x3f;
            }
            cVar4 = (p[-1] - cVar4) * '\x02';
            jis[0] = cVar4 + '!';
            if (bVar1 < 0x9f) {
              if (bVar1 < 0x7f) {
                cVar4 = '\x1f';
              }
              else {
                cVar4 = ' ';
              }
              jis[1] = bVar1 - cVar4;
            }
            else {
              jis[0] = cVar4 + '\"';
              jis[1] = bVar1 + 0x82;
            }
            wVar6 = wc_jisx0208_or_jisx02131(CONCAT11(jis[0],jis[1]));
            if (wVar6 == 0x8142) {
              wtf_push(x,0x8142,(uint)CONCAT11(jis[0],jis[1]));
            }
            else {
              wtf_push(x,0x8813,(uint)CONCAT11(p[-1],*p));
            }
          }
          state = 0;
        }
      }
      else if (state == 3) {
        if ((WC_SJIS_MAP[*p] & 0x10) == 0) {
          wtf_push_unknown(x,p + -1,2);
        }
        else {
          wtf_push(x,0x8813,(uint)CONCAT11(p[-1],*p));
        }
        state = 0;
      }
    }
    is = x;
    if (state - 1U < 3) {
      wtf_push_unknown(x,p + -1,1);
    }
  }
  return is;
}



// WARNING: Removing unreachable block (ram,0x080bc270)

Str wc_conv_from_sjisx0213(Str is,wc_ces ces)

{
  byte bVar1;
  wc_uchar *pwVar2;
  int iVar3;
  char cVar4;
  wc_uchar *pwVar5;
  Str x;
  wc_ccs ccs;
  wc_wchar_t cc;
  int state;
  wc_uchar *p;
  wc_uchar *ep;
  wc_uchar *sp;
  Str os;
  wc_uchar jis [2];
  
  pwVar2 = (wc_uchar *)is->ptr;
  pwVar5 = pwVar2 + is->length;
  state = 0;
  for (p = pwVar2; (p < pwVar5 && (-1 < (char)*p)); p = p + 1) {
  }
  if (p != pwVar5) {
    x = Strnew_size(is->length);
    if (pwVar2 < p) {
      Strcat_charp_n(x,is->ptr,(int)p - (int)pwVar2);
    }
    for (; p < pwVar5; p = p + 1) {
      if ((uint)state < 3) {
        if (state == 0) {
          switch(WC_SJIS_MAP[*p]) {
          case '\x12':
          case '\x17':
          case '@':
            wtf_push_unknown(x,p,1);
            break;
          case '\x13':
            wtf_push(x,0x149,(uint)*p);
            break;
          default:
            if (x->area_size <= x->length + 1) {
              Strgrow(x);
            }
            iVar3 = x->length;
            x->ptr[iVar3] = *p;
            x->length = iVar3 + 1;
            x->ptr[x->length] = '\0';
            break;
          case '4':
            state = 1;
            break;
          case '5':
            state = 2;
            break;
          case '6':
            state = 3;
          }
        }
        else {
          if ((WC_SJIS_MAP[*p] & 0x10) == 0) {
            wtf_push_unknown(x,p + -1,2);
          }
          else {
            bVar1 = *p;
            if (p[-1] < 0xa0) {
              cVar4 = -0x7f;
            }
            else {
              cVar4 = -0x3f;
            }
            cVar4 = (p[-1] - cVar4) * '\x02';
            jis[0] = cVar4 + '!';
            if (bVar1 < 0x9f) {
              if (bVar1 < 0x7f) {
                cVar4 = '\x1f';
              }
              else {
                cVar4 = ' ';
              }
              jis[1] = bVar1 - cVar4;
            }
            else {
              jis[0] = cVar4 + '\"';
              jis[1] = bVar1 + 0x82;
            }
            ccs = wc_jisx0208_or_jisx02131(CONCAT11(jis[0],jis[1]));
            wtf_push(x,ccs,(uint)CONCAT11(jis[0],jis[1]));
          }
          state = 0;
        }
      }
      else if (state == 3) {
        if ((WC_SJIS_MAP[*p] & 0x10) == 0) {
          wtf_push_unknown(x,p + -1,2);
        }
        else {
          bVar1 = *p;
          if (bVar1 < 0x9f) {
            jis[0] = johab1_N_map[2][p[-1] + 0x10];
            if (bVar1 < 0x7f) {
              cVar4 = '\x1f';
            }
            else {
              cVar4 = ' ';
            }
            jis[1] = bVar1 - cVar4;
          }
          else {
            jis[0] = N_johab1_map[p[-1]];
            jis[1] = bVar1 + 0x82;
          }
          wtf_push(x,0x8150,(uint)CONCAT11(jis[0],jis[1]));
        }
        state = 0;
      }
    }
    is = x;
    if (state - 1U < 3) {
      wtf_push_unknown(x,p + -1,1);
    }
  }
  return is;
}



void wc_push_to_sjis(Str os,wc_wchar_t cc,wc_status *st)

{
  int iVar1;
  char cVar2;
  byte bVar3;
  wc_ccs local_24;
  wc_uint32 local_20;
  wc_uchar lb;
  wc_uchar ub;
  
  do {
    while( true ) {
      if (cc.ccs == 0x8142) {
        if ((cc.code & 0x100) == 0) {
          cVar2 = '}';
        }
        else {
          cVar2 = '\x1f';
        }
        lb = ((byte)cc.code & 0x7f) + cVar2;
        if (0x7e < lb) {
          lb = lb + 1;
        }
        bVar3 = (byte)((int)(((byte)(cc.code >> 8) & 0x7f) - 0x21) >> 1);
        if (bVar3 < 0x1f) {
          cVar2 = -0x7f;
        }
        else {
          cVar2 = -0x3f;
        }
        ub = bVar3 + cVar2;
        if (os->area_size <= os->length + 1) {
          Strgrow(os);
        }
        iVar1 = os->length;
        os->ptr[iVar1] = ub;
        os->length = iVar1 + 1;
        os->ptr[os->length] = '\0';
        if (os->area_size <= os->length + 1) {
          Strgrow(os);
        }
        iVar1 = os->length;
        os->ptr[iVar1] = lb;
        os->length = iVar1 + 1;
        os->ptr[os->length] = '\0';
        return;
      }
      if (cc.ccs < 0x8143) break;
      if (cc.ccs < 0x8816) {
        if (0x8813 < cc.ccs) {
          wc_cs94w_to_sjis_ext((wc_wchar_t)CONCAT44(cc.ccs,&local_24));
          cc.ccs = local_24;
          cc.code = local_20;
LAB_080bc807:
          if (os->area_size <= os->length + 1) {
            Strgrow(os);
          }
          iVar1 = os->length;
          os->ptr[iVar1] = (char)(cc.code >> 8);
          os->length = iVar1 + 1;
          os->ptr[os->length] = '\0';
          if (os->area_size <= os->length + 1) {
            Strgrow(os);
          }
          iVar1 = os->length;
          os->ptr[iVar1] = (char)cc.code;
          os->length = iVar1 + 1;
          os->ptr[os->length] = '\0';
          return;
        }
        if (cc.ccs == 0x8813) goto LAB_080bc807;
      }
      else if (cc.ccs == 0xc000) {
        if (WcOption.no_replace != '\0') {
          return;
        }
        Strcat_charp(os,WcReplaceW);
        return;
      }
LAB_080bc8f0:
      if (WcOption.ucs_conv == '\0') {
        if ((cc.ccs & 0x18000) == 0) {
          cc.ccs = 0x4000;
        }
        else {
          cc.ccs = 0xc000;
        }
      }
      else {
        wc_any_to_any_ces((wc_wchar_t)CONCAT44(cc.ccs,&local_24),(wc_status *)cc.code);
        cc.ccs = local_24;
        cc.code = local_20;
      }
    }
    if (cc.ccs != 0x149) {
      if (cc.ccs == 0x4000) {
        if (WcOption.no_replace != '\0') {
          return;
        }
        Strcat_charp(os,WcReplace);
        return;
      }
      if (cc.ccs == 0x142) {
        if (os->area_size <= os->length + 1) {
          Strgrow(os);
        }
        iVar1 = os->length;
        os->ptr[iVar1] = (char)cc.code;
        os->length = iVar1 + 1;
        os->ptr[os->length] = '\0';
        return;
      }
      goto LAB_080bc8f0;
    }
    if (WcOption.use_jisx0201k != '\0') {
      if (os->area_size <= os->length + 1) {
        Strgrow(os);
      }
      iVar1 = os->length;
      os->ptr[iVar1] = (byte)cc.code | 0x80;
      os->length = iVar1 + 1;
      os->ptr[os->length] = '\0';
      return;
    }
    if (WcOption.fix_width_conv == '\0') {
      wc_jisx0201k_to_jisx0208((wc_wchar_t)CONCAT44(0x149,&cc));
    }
    else {
      cc.ccs = 0x4000;
    }
  } while( true );
}



void wc_push_to_sjisx0213(Str os,wc_wchar_t cc,wc_status *st)

{
  int iVar1;
  char cVar2;
  byte bVar3;
  wc_ccs local_24;
  wc_uint32 local_20;
  wc_uchar lb;
  wc_uchar ub;
  
  while( true ) {
    bVar3 = (byte)(cc.code >> 8);
    if (cc.ccs == 0x8142) break;
    if (cc.ccs < 0x8143) {
      if (cc.ccs == 0x149) {
        if (WcOption.use_jisx0201k != '\0') {
          if (os->area_size <= os->length + 1) {
            Strgrow(os);
          }
          iVar1 = os->length;
          os->ptr[iVar1] = (byte)cc.code | 0x80;
          os->length = iVar1 + 1;
          os->ptr[os->length] = '\0';
          return;
        }
        if (WcOption.fix_width_conv == '\0') {
          wc_jisx0201k_to_jisx0208((wc_wchar_t)CONCAT44(0x149,&cc));
        }
        else {
          cc.ccs = 0x4000;
        }
      }
      else {
        if (cc.ccs == 0x4000) {
          if (WcOption.no_replace != '\0') {
            return;
          }
          Strcat_charp(os,WcReplace);
          return;
        }
        if (cc.ccs == 0x142) {
          if (os->area_size <= os->length + 1) {
            Strgrow(os);
          }
          iVar1 = os->length;
          os->ptr[iVar1] = (char)cc.code;
          os->length = iVar1 + 1;
          os->ptr[os->length] = '\0';
          return;
        }
LAB_080bccfd:
        if (WcOption.ucs_conv == '\0') {
          if ((cc.ccs & 0x18000) == 0) {
            cc.ccs = 0x4000;
          }
          else {
            cc.ccs = 0xc000;
          }
        }
        else {
          wc_any_to_any_ces((wc_wchar_t)CONCAT44(cc.ccs,&local_24),(wc_status *)cc.code);
          cc.ccs = local_24;
          cc.code = local_20;
        }
      }
    }
    else if (cc.ccs == 0x8150) {
      if (WcOption.use_jisx0213 != '\0') {
        if ((cc.code & 0x100) == 0) {
          cVar2 = '}';
        }
        else {
          cVar2 = '\x1f';
        }
        lb = ((byte)cc.code & 0x7f) + cVar2;
        if (0x7e < lb) {
          lb = lb + 1;
        }
        ub = jisx02132_sjis_map[bVar3 & 0x7f];
        if (ub != '\0') {
          if (os->area_size <= os->length + 1) {
            Strgrow(os);
          }
          iVar1 = os->length;
          os->ptr[iVar1] = ub;
          os->length = iVar1 + 1;
          os->ptr[os->length] = '\0';
          if (os->area_size <= os->length + 1) {
            Strgrow(os);
          }
          iVar1 = os->length;
          os->ptr[iVar1] = lb;
          os->length = iVar1 + 1;
          os->ptr[os->length] = '\0';
          return;
        }
        goto LAB_080bccb4;
      }
      cc.ccs = 0xc000;
    }
    else {
      if (cc.ccs == 0xc000) {
LAB_080bccb4:
        if (WcOption.no_replace != '\0') {
          return;
        }
        Strcat_charp(os,WcReplaceW);
        return;
      }
      if (cc.ccs != 0x814f) goto LAB_080bccfd;
      if (WcOption.use_jisx0213 != '\0') break;
      cc.ccs = 0xc000;
    }
  }
  if ((cc.code & 0x100) == 0) {
    cVar2 = '}';
  }
  else {
    cVar2 = '\x1f';
  }
  lb = ((byte)cc.code & 0x7f) + cVar2;
  if (0x7e < lb) {
    lb = lb + 1;
  }
  bVar3 = (byte)((int)((bVar3 & 0x7f) - 0x21) >> 1);
  if (bVar3 < 0x1f) {
    cVar2 = -0x7f;
  }
  else {
    cVar2 = -0x3f;
  }
  ub = bVar3 + cVar2;
  if (os->area_size <= os->length + 1) {
    Strgrow(os);
  }
  iVar1 = os->length;
  os->ptr[iVar1] = ub;
  os->length = iVar1 + 1;
  os->ptr[os->length] = '\0';
  if (os->area_size <= os->length + 1) {
    Strgrow(os);
  }
  iVar1 = os->length;
  os->ptr[iVar1] = lb;
  os->length = iVar1 + 1;
  os->ptr[os->length] = '\0';
  return;
}



Str wc_char_conv_from_sjis(wc_uchar c,wc_status *st)

{
  int iVar1;
  ushort code;
  Str p_Var2;
  char cVar3;
  wc_ccs wVar4;
  wc_wchar_t cc;
  
  if (st->state == -1) {
    st->state = 0;
    wc_char_conv_from_sjis::os = Strnew_size(8);
  }
  iVar1 = st->state;
  if (iVar1 < 3) {
    if (iVar1 < 1) {
      if (iVar1 == 0) {
        switch(WC_SJIS_MAP[c]) {
        case '\x12':
        case '\x17':
        case '@':
          break;
        case '\x13':
          wtf_push(wc_char_conv_from_sjis::os,0x149,(uint)c);
          break;
        default:
          if (wc_char_conv_from_sjis::os->area_size <= wc_char_conv_from_sjis::os->length + 1) {
            Strgrow(wc_char_conv_from_sjis::os);
          }
          p_Var2 = wc_char_conv_from_sjis::os;
          iVar1 = wc_char_conv_from_sjis::os->length;
          wc_char_conv_from_sjis::os->ptr[iVar1] = c;
          p_Var2->length = iVar1 + 1;
          wc_char_conv_from_sjis::os->ptr[wc_char_conv_from_sjis::os->length] = '\0';
          break;
        case '4':
          wc_char_conv_from_sjis::jis[0] = c;
          st->state = 1;
          return (Str)0x0;
        case '5':
          wc_char_conv_from_sjis::jis[0] = c;
          st->state = 2;
          return (Str)0x0;
        case '6':
          wc_char_conv_from_sjis::jis[0] = c;
          st->state = 3;
          return (Str)0x0;
        }
      }
    }
    else {
      if ((WC_SJIS_MAP[c] & 0x10) != 0) {
        if (wc_char_conv_from_sjis::jis[0] < 0xa0) {
          cVar3 = -0x7f;
        }
        else {
          cVar3 = -0x3f;
        }
        cVar3 = (wc_char_conv_from_sjis::jis[0] - cVar3) * '\x02';
        wc_char_conv_from_sjis::jis[0] = cVar3 + '!';
        if (c < 0x9f) {
          if (c < 0x7f) {
            cVar3 = '\x1f';
          }
          else {
            cVar3 = ' ';
          }
          wc_char_conv_from_sjis::jis[1] = c - cVar3;
        }
        else {
          wc_char_conv_from_sjis::jis[0] = cVar3 + '\"';
          wc_char_conv_from_sjis::jis[1] = c + 0x82;
        }
        code = CONCAT11(wc_char_conv_from_sjis::jis[0],wc_char_conv_from_sjis::jis[1]);
        wVar4 = wc_jisx0208_or_jisx02131(code);
        if (wVar4 == 0x8142) {
          wtf_push(wc_char_conv_from_sjis::os,0x8142,(uint)code);
        }
        else {
          wtf_push(wc_char_conv_from_sjis::os,0x8813,
                   (uint)CONCAT11(wc_char_conv_from_sjis::jis[0],wc_char_conv_from_sjis::jis[1]));
        }
      }
      st->state = 0;
    }
  }
  else if (iVar1 == 3) {
    if ((WC_SJIS_MAP[c] & 0x10) != 0) {
      wc_char_conv_from_sjis::jis[1] = c;
      wtf_push(wc_char_conv_from_sjis::os,0x8813,(uint)CONCAT11(wc_char_conv_from_sjis::jis[0],c));
    }
    st->state = 0;
  }
  st->state = -1;
  return wc_char_conv_from_sjis::os;
}



Str wc_char_conv_from_sjisx0213(wc_uchar c,wc_status *st)

{
  int iVar1;
  ushort code;
  Str p_Var2;
  char cVar3;
  wc_ccs ccs;
  wc_wchar_t cc;
  
  if (st->state == -1) {
    st->state = 0;
    wc_char_conv_from_sjisx0213::os = Strnew_size(8);
  }
  iVar1 = st->state;
  if (iVar1 < 3) {
    if (iVar1 < 1) {
      if (iVar1 == 0) {
        switch(WC_SJIS_MAP[c]) {
        case '\x12':
        case '\x17':
        case '@':
          break;
        case '\x13':
          wtf_push(wc_char_conv_from_sjisx0213::os,0x149,(uint)c);
          break;
        default:
          if (wc_char_conv_from_sjisx0213::os->area_size <=
              wc_char_conv_from_sjisx0213::os->length + 1) {
            Strgrow(wc_char_conv_from_sjisx0213::os);
          }
          p_Var2 = wc_char_conv_from_sjisx0213::os;
          iVar1 = wc_char_conv_from_sjisx0213::os->length;
          wc_char_conv_from_sjisx0213::os->ptr[iVar1] = c;
          p_Var2->length = iVar1 + 1;
          wc_char_conv_from_sjisx0213::os->ptr[wc_char_conv_from_sjisx0213::os->length] = '\0';
          break;
        case '4':
          wc_char_conv_from_sjisx0213::jis[0] = c;
          st->state = 1;
          return (Str)0x0;
        case '5':
          wc_char_conv_from_sjisx0213::jis[0] = c;
          st->state = 2;
          return (Str)0x0;
        case '6':
          wc_char_conv_from_sjisx0213::jis[0] = c;
          st->state = 3;
          return (Str)0x0;
        }
      }
    }
    else {
      if ((WC_SJIS_MAP[c] & 0x10) != 0) {
        if (wc_char_conv_from_sjisx0213::jis[0] < 0xa0) {
          cVar3 = -0x7f;
        }
        else {
          cVar3 = -0x3f;
        }
        cVar3 = (wc_char_conv_from_sjisx0213::jis[0] - cVar3) * '\x02';
        wc_char_conv_from_sjisx0213::jis[0] = cVar3 + '!';
        if (c < 0x9f) {
          if (c < 0x7f) {
            cVar3 = '\x1f';
          }
          else {
            cVar3 = ' ';
          }
          wc_char_conv_from_sjisx0213::jis[1] = c - cVar3;
        }
        else {
          wc_char_conv_from_sjisx0213::jis[0] = cVar3 + '\"';
          wc_char_conv_from_sjisx0213::jis[1] = c + 0x82;
        }
        code = CONCAT11(wc_char_conv_from_sjisx0213::jis[0],wc_char_conv_from_sjisx0213::jis[1]);
        ccs = wc_jisx0208_or_jisx02131(code);
        wtf_push(wc_char_conv_from_sjisx0213::os,ccs,(uint)code);
      }
      st->state = 0;
    }
  }
  else if (iVar1 == 3) {
    if ((WC_SJIS_MAP[c] & 0x10) != 0) {
      if (c < 0x9f) {
        wc_char_conv_from_sjisx0213::jis[0] =
             johab1_N_map[2][wc_char_conv_from_sjisx0213::jis[0] + 0x10];
        if (c < 0x7f) {
          cVar3 = '\x1f';
        }
        else {
          cVar3 = ' ';
        }
        wc_char_conv_from_sjisx0213::jis[1] = c - cVar3;
      }
      else {
        wc_char_conv_from_sjisx0213::jis[0] = N_johab1_map[wc_char_conv_from_sjisx0213::jis[0]];
        wc_char_conv_from_sjisx0213::jis[1] = c + 0x82;
      }
      wtf_push(wc_char_conv_from_sjisx0213::os,0x8150,
               (uint)CONCAT11(wc_char_conv_from_sjisx0213::jis[0],
                              wc_char_conv_from_sjisx0213::jis[1]));
    }
    st->state = 0;
  }
  st->state = -1;
  return wc_char_conv_from_sjisx0213::os;
}



void wc_input_init(wc_ces ces,wc_status *st)

{
  wc_gset *pwVar1;
  uint uVar2;
  int g;
  int i;
  wc_gset *gset;
  
  st->ces_info = WcCesInfo + (ces & 0xff);
  pwVar1 = st->ces_info->gset;
  st->state = 0;
  st->g0_ccs = 0;
  st->g1_ccs = 0;
  st->design[0] = pwVar1->ccs;
  st->design[1] = pwVar1[1].ccs;
  st->design[2] = 0;
  st->design[3] = 0;
  st->gl = '\0';
  st->gr = '\x01';
  st->ss = '\0';
  for (i = 0; pwVar1[i].ccs != 0; i = i + 1) {
    if ((pwVar1[i].init != '\0') && (uVar2 = pwVar1[i].g & 3, st->design[uVar2] == 0)) {
      st->design[uVar2] = pwVar1[i].ccs;
    }
  }
  st->tag = (Str)0x0;
  st->ntag = 0;
  return;
}



void wc_output_init(wc_ces ces,wc_status *st)

{
  wc_gset *pwVar1;
  uint uVar2;
  char cVar3;
  int iVar4;
  wc_ccs wVar5;
  wc_table **ppwVar6;
  wc_table *pwVar7;
  size_t nw;
  size_t n;
  size_t i;
  wc_gset *gset;
  
  if (((output_set == '\0') || ((output_st.ces_info)->id != ces)) ||
     (iVar4 = memcmp(&WcOption,&output_option,0x10), iVar4 != 0)) {
    st->state = 0;
    st->ces_info = WcCesInfo + (ces & 0xff);
    pwVar1 = st->ces_info->gset;
    if ((((ces == 0x200811) || (ces == 0x200812)) || (ces == 0x200813)) &&
       ((char)((uint)WcOption._4_4_ >> 0x18) != '\0')) {
      wVar5 = 0x14a;
    }
    else {
      wVar5 = pwVar1->ccs;
    }
    st->g0_ccs = wVar5;
    if ((((ces == 0x200811) || (ces == 0x200812)) || (ces == 0x200813)) &&
       ((char)WcOption._8_4_ != '\0')) {
      wVar5 = 0x8140;
    }
    else {
      wVar5 = pwVar1[1].ccs;
    }
    st->g1_ccs = wVar5;
    st->design[0] = st->g0_ccs;
    st->design[1] = 0;
    st->design[2] = 0;
    st->design[3] = 0;
    st->gl = '\0';
    st->gr = '\0';
    st->ss = '\0';
    if ((ces & 0x800) != 0) {
      wc_create_gmap(st);
    }
    st->tag = (Str)0x0;
    st->ntag = 0;
    if ((char)((uint)WcOption._0_4_ >> 0x18) == '\0') {
      st->tlist = (wc_table **)0x0;
      st->tlistw = (wc_table **)0x0;
    }
    else {
      nw = 0;
      n = 0;
      for (i = 0; pwVar1[i].ccs != 0; i = i + 1) {
        if ((pwVar1[i].ccs & 0x18000) == 0) {
          n = n + 1;
        }
        else {
          nw = nw + 1;
        }
      }
      ppwVar6 = (wc_table **)GC_malloc((n + 1) * 4);
      st->tlist = ppwVar6;
      ppwVar6 = (wc_table **)GC_malloc((nw + 1) * 4);
      st->tlistw = ppwVar6;
      nw = 0;
      n = 0;
      for (i = 0; pwVar1[i].ccs != 0; i = i + 1) {
        if ((pwVar1[i].ccs & 0x18000) == 0) {
          if ((pwVar1[i].ccs != 0x149) || ((char)((uint)WcOption._8_4_ >> 8) != '\0')) {
            ppwVar6 = st->tlist;
            pwVar7 = wc_get_ucs_table(pwVar1[i].ccs);
            ppwVar6[n] = pwVar7;
            n = n + 1;
          }
        }
        else {
          uVar2 = pwVar1[i].ccs;
          if (uVar2 == 0x8144) {
            cVar3 = (char)((uint)WcOption._8_4_ >> 0x10);
joined_r0x080bd7ba:
            if (cVar3 == '\0') goto LAB_080bd887;
          }
          else if (uVar2 < 0x8145) {
            if ((((uVar2 == 0x8141) && ((char)((uint)WcOption._4_4_ >> 0x10) != '\0')) &&
                (ces != 0x30203a)) && (ces != 0x30203b)) {
              ppwVar6 = st->tlistw;
              pwVar7 = wc_get_ucs_table(0x880e);
              ppwVar6[nw] = pwVar7;
              nw = nw + 1;
              goto LAB_080bd887;
            }
          }
          else if (uVar2 - 0x814f < 2) {
            cVar3 = (char)((uint)WcOption._8_4_ >> 0x18);
            goto joined_r0x080bd7ba;
          }
          ppwVar6 = st->tlistw;
          pwVar7 = wc_get_ucs_table(pwVar1[i].ccs);
          ppwVar6[nw] = pwVar7;
          nw = nw + 1;
        }
LAB_080bd887:
      }
      st->tlist[n] = (wc_table *)0x0;
      st->tlistw[nw] = (wc_table *)0x0;
    }
    output_st.ces_info = st->ces_info;
    output_st._4_4_ = *(undefined4 *)&st->gr;
    output_st.g0_ccs = st->g0_ccs;
    output_st.g1_ccs = st->g1_ccs;
    output_st.design[0] = st->design[0];
    output_st.design[1] = st->design[1];
    output_st.design[2] = st->design[2];
    output_st.design[3] = st->design[3];
    output_st.tlist = st->tlist;
    output_st.tlistw = st->tlistw;
    output_st.state = st->state;
    output_st.tag = st->tag;
    output_st.ntag = st->ntag;
    output_st.base = st->base;
    output_st.shift = st->shift;
    output_set = '\x01';
    output_option._0_4_ = WcOption._0_4_;
    output_option._4_4_ = WcOption._4_4_;
    output_option._8_4_ = WcOption._8_4_;
    output_option._12_4_ = WcOption._12_4_;
  }
  else {
    st->ces_info = output_st.ces_info;
    *(undefined4 *)&st->gr = output_st._4_4_;
    st->g0_ccs = output_st.g0_ccs;
    st->g1_ccs = output_st.g1_ccs;
    st->design[0] = output_st.design[0];
    st->design[1] = output_st.design[1];
    st->design[2] = output_st.design[2];
    st->design[3] = output_st.design[3];
    st->tlist = output_st.tlist;
    st->tlistw = output_st.tlistw;
    st->state = output_st.state;
    st->tag = output_st.tag;
    st->ntag = output_st.ntag;
    st->base = output_st.base;
    st->shift = output_st.shift;
  }
  return;
}



wc_bool wc_ces_has_ccs(wc_ccs ccs,wc_status *st)

{
  wc_gset *pwVar1;
  int i;
  wc_gset *gset;
  
  pwVar1 = st->ces_info->gset;
  i = 0;
  while( true ) {
    if (pwVar1[i].ccs == 0) {
      return '\0';
    }
    if (pwVar1[i].ccs == ccs) break;
    i = i + 1;
  }
  return '\x01';
}



wc_wchar_t ucs_cs94_conv(wc_ccs ccs,wc_uint16 c)

{
  undefined2 in_stack_0000000a;
  ushort in_stack_0000000c;
  wc_wchar_t cc;
  
  *(undefined4 *)ccs = _c;
  *(uint *)(ccs + 4) = (uint)in_stack_0000000c;
  return (wc_wchar_t)(ulonglong)CONCAT24(in_stack_0000000c,ccs);
}



wc_wchar_t ucs_viet_conv(wc_ccs ccs,wc_uint16 c)

{
  undefined2 in_stack_0000000a;
  ushort in_stack_0000000c;
  wc_wchar_t cc;
  
  if ((in_stack_0000000c & 0x80) == 0) {
    cc.ccs = _c;
    if (_c == 0x820) {
      cc.ccs = 0x821;
    }
    else if (_c == 0x822) {
      cc.ccs = 0x823;
    }
    else if (_c == 0x81d) {
      cc.ccs = 0x81e;
    }
  }
  else {
    cc.ccs = _c;
    if (_c == 0x821) {
      cc.ccs = 0x820;
    }
    else if (_c == 0x823) {
      cc.ccs = 0x822;
    }
    else if (_c == 0x81e) {
      cc.ccs = 0x81d;
    }
  }
  *(wc_ccs *)ccs = cc.ccs;
  *(uint *)(ccs + 4) = in_stack_0000000c & 0xff;
  return (wc_wchar_t)((ulonglong)CONCAT24(in_stack_0000000c,ccs) & 0xffffffffff);
}



wc_wchar_t ucs_cp1258_conv(wc_ccs ccs,wc_uint16 c)

{
  undefined4 uVar1;
  ushort in_stack_0000000c;
  wc_wchar_t cc;
  
  if (in_stack_0000000c < 0x100) {
    uVar1 = 0x81b;
  }
  else {
    uVar1 = 0x81c;
  }
  *(undefined4 *)ccs = uVar1;
  *(uint *)(ccs + 4) = (uint)in_stack_0000000c;
  return (wc_wchar_t)(ulonglong)CONCAT24(in_stack_0000000c,ccs);
}



wc_wchar_t ucs_cns11643_conv(wc_ccs cs,wc_uint16 c)

{
  undefined4 uVar1;
  ushort in_stack_0000000c;
  wc_wchar_t cc;
  
  if ((short)in_stack_0000000c < 0) {
    uVar1 = 0x8148;
  }
  else {
    uVar1 = 0x8147;
  }
  *(undefined4 *)cs = uVar1;
  *(uint *)(cs + 4) = in_stack_0000000c & 0x7f7f;
  return (wc_wchar_t)((ulonglong)CONCAT24(in_stack_0000000c,cs) & 0x7f7fffffffff);
}



wc_wchar_t ucs_big5_conv(wc_ccs cs,wc_uint16 c)

{
  wc_wchar_t wVar1;
  undefined2 in_stack_0000000a;
  wc_wchar_t cc;
  
  wVar1 = wc_big5_to_cs94w((wc_wchar_t)CONCAT44(_c,cs));
  return (wc_wchar_t)((ulonglong)wVar1 & 0xffffffff00000000 | (ulonglong)cs);
}



wc_wchar_t ucs_johab2_conv(wc_ccs cs,wc_uint16 c)

{
  wc_wchar_t wVar1;
  undefined2 in_stack_0000000a;
  wc_wchar_t cc;
  
  wVar1 = wc_johab_to_cs128w((wc_wchar_t)CONCAT44(_c,cs));
  return (wc_wchar_t)((ulonglong)wVar1 & 0xffffffff00000000 | (ulonglong)cs);
}



wc_wchar_t ucs_johab3_conv(wc_ccs cs,wc_uint16 c)

{
  undefined2 in_stack_0000000a;
  ushort in_stack_0000000c;
  wc_wchar_t cc;
  
  if ((((in_stack_0000000c < 0x2121) || (0x2420 < in_stack_0000000c)) &&
      ((in_stack_0000000c < 0x2454 || (0x2c7e < in_stack_0000000c)))) &&
     ((in_stack_0000000c < 0x4a21 || (0x7d7e < in_stack_0000000c)))) {
    cc.ccs = 0xc000;
  }
  else {
    cc.ccs = _c;
  }
  *(wc_ccs *)cs = cc.ccs;
  *(uint *)(cs + 4) = (uint)in_stack_0000000c;
  return (wc_wchar_t)(ulonglong)CONCAT24(in_stack_0000000c,cs);
}



wc_wchar_t ucs_sjis_ext_conv(wc_ccs cs,wc_uint16 c)

{
  wc_wchar_t wVar1;
  undefined2 in_stack_0000000a;
  wc_wchar_t cc;
  
  wVar1 = wc_sjis_ext_to_cs94w((wc_wchar_t)CONCAT44(_c,cs));
  return (wc_wchar_t)((ulonglong)wVar1 & 0xffffffff00000000 | (ulonglong)cs);
}



wc_wchar_t ucs_gbk_conv(wc_ccs cs,wc_uint16 c)

{
  wc_wchar_t wVar1;
  undefined2 in_stack_0000000a;
  wc_wchar_t cc;
  
  wVar1 = wc_gbk_to_cs128w((wc_wchar_t)CONCAT44(_c,cs));
  return (wc_wchar_t)((ulonglong)wVar1 & 0xffffffff00000000 | (ulonglong)cs);
}



wc_wchar_t ucs_uhc_conv(wc_ccs cs,wc_uint16 c)

{
  wc_wchar_t wVar1;
  undefined2 in_stack_0000000a;
  wc_wchar_t cc;
  
  wVar1 = wc_uhc_to_cs128w((wc_wchar_t)CONCAT44(_c,cs));
  return (wc_wchar_t)((ulonglong)wVar1 & 0xffffffff00000000 | (ulonglong)cs);
}



wc_wchar_t ucs_hkscs_conv(wc_ccs cs,wc_uint16 c)

{
  wc_wchar_t wVar1;
  undefined2 in_stack_0000000a;
  wc_wchar_t cc;
  
  wVar1 = wc_hkscs_to_cs128w((wc_wchar_t)CONCAT44(_c,cs));
  return (wc_wchar_t)((ulonglong)wVar1 & 0xffffffff00000000 | (ulonglong)cs);
}



wc_table * wc_get_ucs_table(wc_ccs ccs)

{
  uint uVar1;
  uint uVar2;
  int f;
  
  uVar1 = ccs & 0xff;
  uVar2 = ccs & 0xff00;
  if (uVar2 == 0x800) {
    if ((uVar1 != 0) && (uVar1 < 0x29)) {
      return ucs_pcs_table + (uVar1 - 1);
    }
    return (wc_table *)0x0;
  }
  if (uVar2 < 0x801) {
    if (uVar2 == 0x200) {
      if ((0x3f < uVar1) && (uVar1 < 0x67)) {
        return ucs_cs96_table + (uVar1 - 0x40);
      }
      return (wc_table *)0x0;
    }
    if (uVar2 == 0x400) {
      if ((0x3f < uVar1) && (uVar1 == 0)) {
        return ucs_cs942_table + -0x40;
      }
      return (wc_table *)0x0;
    }
    if (uVar2 == 0x100) {
      if ((0x3f < uVar1) && (uVar1 < 0x55)) {
        return ucs_cs94_table + (uVar1 - 0x40);
      }
      return (wc_table *)0x0;
    }
  }
  else {
    if (uVar2 == 0x8200) {
      if ((0x3f < uVar1) && (uVar1 == 0)) {
        return ucs_cs96w_table + -0x40;
      }
      return (wc_table *)0x0;
    }
    if (uVar2 == 0x8800) {
      if ((uVar1 != 0) && (uVar1 < 0x22)) {
        return ucs_pcsw_table + (uVar1 - 1);
      }
      return (wc_table *)0x0;
    }
    if (uVar2 == 0x8100) {
      if ((0x3f < uVar1) && (uVar1 < 0x51)) {
        return ucs_cs94w_table + (uVar1 - 0x40);
      }
      return (wc_table *)0x0;
    }
  }
  return (wc_table *)0x0;
}



wc_wchar_t wc_ucs_to_any(wc_uint32 ucs,wc_table *t)

{
  wc_uint16 code;
  wc_map *pwVar1;
  wc_uint32 extraout_EDX;
  wc_uint32 extraout_EDX_00;
  int *in_stack_0000000c;
  wc_wchar_t cc;
  wc_map *map;
  
  code = (wc_uint16)t;
  if ((((in_stack_0000000c != (int *)0x0) && (in_stack_0000000c[2] != 0)) && (t != (wc_table *)0x0))
     && (t < (wc_table *)0x10000)) {
    pwVar1 = wc_map_search(code,(wc_map *)in_stack_0000000c[2],in_stack_0000000c[1]);
    if (pwVar1 != (wc_map *)0x0) {
      (*(code *)in_stack_0000000c[3])(ucs,*in_stack_0000000c,pwVar1->code2);
      cc.code = extraout_EDX;
      goto LAB_080be020;
    }
  }
  if ((in_stack_0000000c != (int *)0x0) && ((uint)t >> 0x10 == 2)) {
    if (*in_stack_0000000c == 0x814f) {
      map = wc_map_search(code,ucs_p2_jisx02131_map,0x19);
    }
    else if (*in_stack_0000000c == 0x8150) {
      map = wc_map_search(code,ucs_p2_jisx02132_map,0x115);
    }
    else if (((*in_stack_0000000c == 0x881f) || (*in_stack_0000000c == 0x8820)) ||
            (*in_stack_0000000c == 0x8821)) {
      map = wc_map_search(code,ucs_p2_hkscs_map,0x439);
    }
    else {
      map = (wc_map *)0x0;
    }
    if (map != (wc_map *)0x0) {
      (*(code *)in_stack_0000000c[3])(ucs,*in_stack_0000000c,map->code2);
      cc.code = extraout_EDX_00;
      goto LAB_080be020;
    }
  }
  *(undefined4 *)ucs = 0x4000;
  *(wc_uint32 *)(ucs + 4) = cc.code;
LAB_080be020:
  return (wc_wchar_t)CONCAT44(cc.code,ucs);
}



wc_uint32 wc_any_to_ucs(wc_wchar_t cc)

{
  ushort code;
  uint uVar1;
  wc_map *pwVar2;
  int iVar3;
  wc_uint32 wVar4;
  wc_ccs local_44;
  wc_uint32 local_40;
  undefined4 local_30;
  undefined4 local_2c;
  undefined4 local_28;
  undefined4 local_24;
  undefined4 local_20;
  undefined4 local_1c;
  wc_map *map2;
  wc_uint16 *map;
  int f;
  
  map = (wc_uint16 *)0x0;
  f = cc.ccs & 0xff;
  uVar1 = cc.ccs & 0xff00;
  if (uVar1 == 0x1000) {
    if ((cc.ccs & 0xffff) != 0x1000) {
      return 0xffffffff;
    }
    return cc.code;
  }
  code = (ushort)((ulonglong)cc >> 0x20);
  if (uVar1 < 0x1001) {
    if (uVar1 == 0x200) {
      if (((uint)f < 0x40) || (0x66 < (uint)f)) {
        return 0xffffffff;
      }
      map = cs96_ucs_map[f - 0x40];
      cc.code = cc.code & 0x7f;
    }
    else if (uVar1 < 0x201) {
      if (uVar1 != 0x100) {
        return 0xffffffff;
      }
      if (((uint)f < 0x40) || (0x54 < (uint)f)) {
        return 0xffffffff;
      }
      map = cs94_ucs_map[f - 0x40];
      cc.code = cc.code & 0x7f;
    }
    else if (uVar1 == 0x400) {
      if (((uint)f < 0x40) || (((ulonglong)cc & 0xff) != 0)) {
        return 0xffffffff;
      }
      map = cs942_ucs_map[f - 0x40];
      cc.code = cc.code & 0x7f;
    }
    else {
      if (uVar1 != 0x800) {
        return 0xffffffff;
      }
      if ((((ulonglong)cc & 0xff) == 0) || (0x28 < (uint)f)) {
        return 0xffffffff;
      }
      if (cc.ccs == 0x81f) {
        wc_tcvn57123_to_tcvn5712((wc_wchar_t)CONCAT44(0x81f,&local_20));
        wVar4 = wc_any_to_ucs((wc_wchar_t)CONCAT44(local_1c,local_20));
        return wVar4;
      }
      if (cc.ccs == 0x827) {
        return 0x20ac;
      }
      if (cc.ccs == 0x81c) {
        pwVar2 = wc_map_search(code,cp12582_ucs_map,0x78);
        if (pwVar2 == (wc_map *)0x0) {
          return 0xffffffff;
        }
        return (uint)pwVar2->code2;
      }
      map = pcs_ucs_map[f - 1];
      cc.code = cc.code & 0x7f;
    }
  }
  else if (uVar1 == 0x8100) {
    if ((cc.ccs == 0x8141) && (WcOption.use_gb12345_map != '\0')) {
      cc.ccs = 0x880e;
      wVar4 = wc_any_to_ucs((wc_wchar_t)((ulonglong)cc & 0xffffffff00000000 | 0x880e));
      return wVar4;
    }
    if (cc.ccs == 0x814f) {
      pwVar2 = wc_map_search(code & 0x7f7f,jisx02131_ucs_p2_map,0x19);
      if (pwVar2 != (wc_map *)0x0) {
        return pwVar2->code2 | 0x20000;
      }
    }
    else if ((cc.ccs == 0x8150) &&
            (pwVar2 = wc_map_search(code & 0x7f7f,jisx02132_ucs_p2_map,0x115),
            pwVar2 != (wc_map *)0x0)) {
      return pwVar2->code2 | 0x20000;
    }
    if ((f < 0x40) || (0x50 < f)) {
      return 0;
    }
    map = cs94w_ucs_map[f + -0x40];
    cc.code = ((cc.code >> 8 & 0x7f) * 0x5e + (cc.code & 0x7f)) - 0xc3f;
  }
  else {
    if (uVar1 < 0x8101) {
      if (uVar1 != 0x2000) {
        if ((uVar1 == 0x4000) && (cc.ccs == 0x4001)) {
          return cc.code | 0x80;
        }
        return 0xffffffff;
      }
      uVar1 = cc.ccs & 0xffff;
      if (uVar1 == 0x2001) {
        return cc.code & 0x1fffff;
      }
      if (uVar1 == 0x2002) {
        wVar4 = wc_gb18030_to_ucs(cc);
        return wVar4;
      }
      if (uVar1 != 0x2000) {
        return 0xffffffff;
      }
      return cc.code;
    }
    if (uVar1 == 0x8200) {
      if (((uint)f < 0x40) || (((ulonglong)cc & 0xff) != 0)) {
        return 0xffffffff;
      }
      map = cs96w_ucs_map[f - 0x40];
      cc.code = ((cc.code >> 8 & 0x7f) * 0x60 + (cc.code & 0x7f)) - 0xc20;
    }
    else {
      if (uVar1 != 0x8800) {
        return 0xffffffff;
      }
      if ((((ulonglong)cc & 0xff) == 0) || (0x21 < (uint)f)) {
        return 0xffffffff;
      }
      map = pcsw_ucs_map[f - 1];
      switch(cc.ccs) {
      case 0x8801:
        if ((cc.code & 0xff) < 0xa1) {
          iVar3 = 0x40;
        }
        else {
          iVar3 = 0x62;
        }
        cc.code = (((cc.code >> 8 & 0xff) * 0x9d + (cc.code & 0xff)) - iVar3) - 0x62bd;
        break;
      default:
        cc.code = ((cc.code >> 8 & 0x7f) * 0x5e + (cc.code & 0x7f)) - 0xc3f;
        break;
      case 0x8803:
        cc.code = (cc.code >> 8 & 0x7f) * 0x5e + (cc.code & 0x7f) + 0xc49;
        break;
      case 0x880f:
        wc_johab_to_cs128w((wc_wchar_t)CONCAT44(cc.ccs,&local_28));
        wVar4 = wc_any_to_ucs((wc_wchar_t)CONCAT44(local_24,local_28));
        return wVar4;
      case 0x8810:
        return ((cc.code >> 8 & 0x7f) + 0x1ffffdf) * 0x80 + (cc.code & 0x7f) + 0xac00;
      case 0x8811:
        uVar1 = (cc.code >> 8 & 0x7f) * 0x80 + (cc.code & 0x7f);
        if (uVar1 % 0xbc < 0x3e) {
          iVar3 = 0x41;
        }
        else {
          iVar3 = 0x43;
        }
        cc.code = (uVar1 / 0xbc + 0x84) * 0x100 + uVar1 % 0xbc + iVar3;
        pwVar2 = wc_map_search((wc_uint16)cc.code,johab2_ucs_map,0x33);
        if (pwVar2 == (wc_map *)0x0) {
          return 0xffffffff;
        }
        return (uint)pwVar2->code2;
      case 0x8812:
        if ((cc.code & 0x7f7f) < 0x2121) {
          return 0xffffffff;
        }
      case 0x8813:
        wc_sjis_ext_to_cs94w((wc_wchar_t)CONCAT44(cc.ccs,&local_30));
        wVar4 = wc_any_to_ucs((wc_wchar_t)CONCAT44(local_2c,local_30));
        return wVar4;
      case 0x8814:
        cc.code = wc_sjis_ext1_to_N(cc.code);
        if (cc.code == 0xffffffff) {
          return 0xffffffff;
        }
        break;
      case 0x8815:
        cc.code = wc_sjis_ext2_to_N(cc.code);
        if (cc.code == 0xffffffff) {
          return 0xffffffff;
        }
        break;
      case 0x8817:
      case 0x8818:
        wc_cs128w_to_gbk((wc_wchar_t)CONCAT44(cc.ccs,&local_44));
        cc.ccs = local_44;
        cc.code = local_40;
      case 0x8816:
        cc.code = wc_gbk_to_N(cc.code);
        break;
      case 0x8819:
      case 0x881a:
      case 0x881b:
        wVar4 = wc_gb18030_to_ucs(cc);
        return wVar4;
      case 0x881d:
      case 0x881e:
        wc_cs128w_to_uhc((wc_wchar_t)CONCAT44(cc.ccs,&local_44));
        cc.ccs = local_44;
        cc.code = local_40;
      case 0x881c:
        if (0xc6fe < cc.code) {
          return 0xffffffff;
        }
        cc.code = wc_uhc_to_N(cc.code);
        break;
      case 0x8820:
      case 0x8821:
        wc_cs128w_to_hkscs((wc_wchar_t)CONCAT44(cc.ccs,&cc));
      case 0x881f:
        map2 = wc_map_search((wc_uint16)cc.code,hkscs_ucs_p2_map,0x439);
        if (map2 != (wc_map *)0x0) {
          return map2->code2 | 0x20000;
        }
        cc.code = wc_hkscs_to_N(cc.code);
      }
    }
  }
  if (map == (wc_uint16 *)0x0) {
    wVar4 = 0xffffffff;
  }
  else {
    wVar4 = (wc_uint32)map[cc.code];
    if (wVar4 == 0) {
      wVar4 = 0xffffffff;
    }
  }
  return wVar4;
}



wc_wchar_t wc_any_to_any(wc_wchar_t cc,wc_table *t)

{
  wc_ccs wVar1;
  undefined4 uVar2;
  uint local_24;
  wc_table *local_20;
  wc_uint32 ucs;
  wc_ccs is_wide;
  
  wVar1 = cc.ccs;
  is_wide = cc.code & 0x18000;
  ucs = wc_any_to_ucs((wc_wchar_t)CONCAT44(t,cc.code));
  if ((wc_table *)ucs != (wc_table *)0xffffffff) {
    wc_ucs_to_any((wc_uint32)&cc.code,(wc_table *)ucs);
    if ((cc.code & 0x4000) == 0) {
      *(wc_uint32 *)wVar1 = cc.code;
      *(wc_table **)(wVar1 + 4) = t;
      goto LAB_080be8d1;
    }
    ucs = wc_ucs_to_fullwidth(ucs);
    if ((wc_table *)ucs != (wc_table *)0xffffffff) {
      wc_ucs_to_any((wc_uint32)&local_24,(wc_table *)ucs);
      t = local_20;
      if ((local_24 & 0x4000) == 0) {
        *(uint *)wVar1 = local_24;
        *(wc_table **)(wVar1 + 4) = local_20;
        goto LAB_080be8d1;
      }
    }
  }
  if (is_wide == 0) {
    uVar2 = 0x4000;
  }
  else {
    uVar2 = 0xc000;
  }
  *(undefined4 *)wVar1 = uVar2;
  *(wc_table **)(wVar1 + 4) = t;
LAB_080be8d1:
  return (wc_wchar_t)(cc & 0xffffffff | ZEXT48(t) << 0x20);
}



wc_wchar_t wc_ucs_to_any_list(wc_uint32 ucs,wc_table **tlist)

{
  wc_table **in_stack_0000000c;
  wc_wchar_t cc;
  wc_table **t;
  
  if (in_stack_0000000c != (wc_table **)0x0) {
    for (t = in_stack_0000000c; *t != (wc_table *)0x0; t = t + 1) {
      if ((*t)->map != (wc_map *)0x0) {
        wc_ucs_to_any((wc_uint32)&cc,(wc_table *)tlist);
        if ((cc.ccs & 0x4000) == 0) {
          *(wc_ccs *)ucs = cc.ccs;
          *(wc_uint32 *)(ucs + 4) = cc.code;
          goto LAB_080be955;
        }
      }
    }
  }
  *(undefined4 *)ucs = 0x4000;
  *(wc_uint32 *)(ucs + 4) = cc.code;
LAB_080be955:
  return (wc_wchar_t)CONCAT44(cc.code,ucs);
}



wc_wchar_t wc_any_to_any_ces(wc_wchar_t cc,wc_status *st)

{
  wc_ccs wVar1;
  wc_ccs wVar2;
  undefined4 uVar3;
  uint **in_stack_00000010;
  uint local_24;
  wc_status *local_20;
  wc_ccs is_wide;
  wc_uint32 ucs;
  
  wVar1 = cc.ccs;
  ucs = wc_any_to_ucs((wc_wchar_t)CONCAT44(st,cc.code));
  is_wide = cc.code & 0x18000;
  if (ucs < (wc_status *)0x80) {
    *(undefined4 *)wVar1 = 0x142;
    *(wc_uint32 *)(wVar1 + 4) = ucs;
    goto LAB_080bec9c;
  }
  if ((wc_status *)ucs != (wc_status *)0xffffffff) {
    if ((**in_stack_00000010 & 0x8000) != 0) {
      wVar2 = wc_ucs_to_ccs(ucs);
      *(wc_ccs *)wVar1 = wVar2;
      *(wc_uint32 *)(wVar1 + 4) = ucs;
      goto LAB_080bec9c;
    }
    if (**in_stack_00000010 == 0x302040) {
      wc_ucs_to_johab((wc_uint32)&cc.code);
      if ((cc.code & 0x4000) != 0) {
        if (is_wide == 0) {
          cc.code = 0x4000;
        }
        else {
          cc.code = 0xc000;
        }
      }
      *(wc_uint32 *)wVar1 = cc.code;
      *(wc_status **)(wVar1 + 4) = st;
      ucs = (wc_uint32)st;
      goto LAB_080bec9c;
    }
    wc_ucs_to_any_list((wc_uint32)&local_24,(wc_table **)ucs);
    cc.code = local_24;
    if ((local_24 & 0x4000) == 0) {
      *(uint *)wVar1 = local_24;
      *(wc_status **)(wVar1 + 4) = local_20;
      ucs = (wc_uint32)local_20;
      goto LAB_080bec9c;
    }
    if ((WcOption.fix_width_conv == '\0') &&
       (wc_ucs_to_any_list((wc_uint32)&local_24,(wc_table **)ucs), (local_24 & 0x4000) == 0)) {
      *(uint *)wVar1 = local_24;
      *(wc_status **)(wVar1 + 4) = local_20;
      ucs = (wc_uint32)local_20;
      goto LAB_080bec9c;
    }
    st = local_20;
    if (**in_stack_00000010 == 0x30203b) {
      wc_ucs_to_gb18030((wc_uint32)&local_24);
      cc.code = local_24;
      if ((local_24 & 0x4000) != 0) {
        if (is_wide == 0) {
          cc.code = 0x4000;
        }
        else {
          cc.code = 0xc000;
        }
      }
      *(wc_uint32 *)wVar1 = cc.code;
      *(wc_status **)(wVar1 + 4) = local_20;
      ucs = (wc_uint32)local_20;
      goto LAB_080bec9c;
    }
    if (ucs == 0xa0) {
      ucs = (wc_uint32)&DAT_00000020;
      *(undefined4 *)wVar1 = 0x142;
      *(undefined4 *)(wVar1 + 4) = 0x20;
      goto LAB_080bec9c;
    }
    if ((((**in_stack_00000010 & 0x1200) != 0) && (0x7f < ucs)) && (ucs < 0xa0)) {
      *(undefined4 *)wVar1 = 0x4001;
      *(wc_uint32 *)(wVar1 + 4) = ucs;
      goto LAB_080bec9c;
    }
    ucs = wc_ucs_to_fullwidth(ucs);
    if ((wc_table **)ucs != (wc_table **)0xffffffff) {
      wc_ucs_to_any_list((wc_uint32)&local_24,(wc_table **)ucs);
      cc.code = local_24;
      st = local_20;
      if ((local_24 & 0x4000) == 0) {
        *(uint *)wVar1 = local_24;
        *(wc_status **)(wVar1 + 4) = local_20;
        ucs = (wc_uint32)local_20;
        goto LAB_080bec9c;
      }
      if (WcOption.fix_width_conv == '\0') {
        wc_ucs_to_any_list((wc_uint32)&local_24,(wc_table **)ucs);
        st = local_20;
        if ((local_24 & 0x4000) == 0) {
          *(uint *)wVar1 = local_24;
          *(wc_status **)(wVar1 + 4) = local_20;
          ucs = (wc_uint32)local_20;
          goto LAB_080bec9c;
        }
      }
    }
  }
  if (is_wide == 0) {
    uVar3 = 0x4000;
  }
  else {
    uVar3 = 0xc000;
  }
  *(undefined4 *)wVar1 = uVar3;
  *(wc_status **)(wVar1 + 4) = st;
  ucs = (wc_uint32)st;
LAB_080bec9c:
  return (wc_wchar_t)(cc & 0xffffffff | (ulonglong)ucs << 0x20);
}



wc_wchar_t wc_any_to_iso2022(wc_wchar_t cc,wc_status *st)

{
  wc_ccs wVar1;
  undefined4 uVar2;
  uint local_24;
  wc_status *local_20;
  wc_ccs is_wide;
  wc_uint32 ucs;
  
  wVar1 = cc.ccs;
  ucs = wc_any_to_ucs((wc_wchar_t)CONCAT44(st,cc.code));
  is_wide = cc.code & 0x18000;
  if (ucs < (wc_status *)0x80) {
    *(undefined4 *)wVar1 = 0x142;
    *(wc_uint32 *)(wVar1 + 4) = ucs;
    st = (wc_status *)ucs;
    goto LAB_080bf0a6;
  }
  if ((wc_status *)ucs != (wc_status *)0xffffffff) {
    wc_ucs_to_any_list((wc_uint32)&cc.code,(wc_table **)ucs);
    if ((cc.code & 0x4000) == 0) {
      *(wc_uint32 *)wVar1 = cc.code;
      *(wc_status **)(wVar1 + 4) = st;
      goto LAB_080bf0a6;
    }
    if (WcOption.strict_iso2022 == '\0') {
      if (is_wide == 0) {
        wc_ucs_to_iso2022((wc_uint32)&local_24);
      }
      else {
        wc_ucs_to_iso2022w((wc_uint32)&local_24);
      }
      cc.code = local_24;
      st = local_20;
      if ((local_24 & 0x4000) == 0) {
        *(uint *)wVar1 = local_24;
        *(wc_status **)(wVar1 + 4) = local_20;
        goto LAB_080bf0a6;
      }
    }
    if (WcOption.fix_width_conv == '\0') {
      wc_ucs_to_any_list((wc_uint32)&local_24,(wc_table **)ucs);
      cc.code = local_24;
      st = local_20;
      if ((local_24 & 0x4000) == 0) {
        *(uint *)wVar1 = local_24;
        *(wc_status **)(wVar1 + 4) = local_20;
        goto LAB_080bf0a6;
      }
      if (WcOption.strict_iso2022 == '\0') {
        if (is_wide == 0) {
          wc_ucs_to_iso2022w((wc_uint32)&local_24);
        }
        else {
          wc_ucs_to_iso2022((wc_uint32)&local_24);
        }
        cc.code = local_24;
        st = local_20;
        if ((local_24 & 0x4000) == 0) {
          *(uint *)wVar1 = local_24;
          *(wc_status **)(wVar1 + 4) = local_20;
          goto LAB_080bf0a6;
        }
      }
    }
    if (ucs == 0xa0) {
      st = (wc_status *)&DAT_00000020;
      *(undefined4 *)wVar1 = 0x142;
      *(undefined4 *)(wVar1 + 4) = 0x20;
      goto LAB_080bf0a6;
    }
    ucs = wc_ucs_to_fullwidth(ucs);
    if ((wc_table **)ucs != (wc_table **)0xffffffff) {
      wc_ucs_to_any_list((wc_uint32)&local_24,(wc_table **)ucs);
      cc.code = local_24;
      if ((local_24 & 0x4000) == 0) {
        *(uint *)wVar1 = local_24;
        *(wc_status **)(wVar1 + 4) = local_20;
        st = local_20;
        goto LAB_080bf0a6;
      }
      if (WcOption.strict_iso2022 == '\0') {
        if (is_wide == 0) {
          wc_ucs_to_iso2022((wc_uint32)&local_24);
        }
        else {
          wc_ucs_to_iso2022w((wc_uint32)&local_24);
        }
        if ((local_24 & 0x4000) == 0) {
          *(uint *)wVar1 = local_24;
          *(wc_status **)(wVar1 + 4) = local_20;
          st = local_20;
          goto LAB_080bf0a6;
        }
      }
      st = local_20;
      if (WcOption.fix_width_conv == '\0') {
        wc_ucs_to_any_list((wc_uint32)&local_24,(wc_table **)ucs);
        cc.code = local_24;
        st = local_20;
        if ((local_24 & 0x4000) == 0) {
          *(uint *)wVar1 = local_24;
          *(wc_status **)(wVar1 + 4) = local_20;
          goto LAB_080bf0a6;
        }
        if (WcOption.strict_iso2022 == '\0') {
          if (is_wide == 0) {
            wc_ucs_to_iso2022w((wc_uint32)&local_24);
            cc.code = local_24;
            st = local_20;
          }
          else {
            wc_ucs_to_iso2022((wc_uint32)&local_24);
            cc.code = local_24;
            st = local_20;
          }
          if ((cc.code & 0x4000) == 0) {
            *(wc_uint32 *)wVar1 = cc.code;
            *(wc_status **)(wVar1 + 4) = st;
            goto LAB_080bf0a6;
          }
        }
      }
    }
    if (ucs == 0xa0) {
      st = (wc_status *)&DAT_00000020;
      *(undefined4 *)wVar1 = 0x142;
      *(undefined4 *)(wVar1 + 4) = 0x20;
      goto LAB_080bf0a6;
    }
  }
  if (is_wide == 0) {
    uVar2 = 0x4000;
  }
  else {
    uVar2 = 0xc000;
  }
  *(undefined4 *)wVar1 = uVar2;
  *(wc_status **)(wVar1 + 4) = st;
LAB_080bf0a6:
  return (wc_wchar_t)(cc & 0xffffffff | ZEXT48(st) << 0x20);
}



wc_wchar_t wc_ucs_to_iso2022(wc_uint32 ucs)

{
  uint in_stack_00000008;
  uint local_24;
  wc_uint32 local_20;
  wc_wchar_t cc;
  int f;
  wc_table *t;
  
  if (in_stack_00000008 < 0x10000) {
    for (f = 0; f < 0x27; f = f + 1) {
      if (ucs_cs96_table[f].map != (wc_map *)0x0) {
        wc_ucs_to_any((wc_uint32)&cc,(wc_table *)(in_stack_00000008 & 0xffff));
        if ((cc.ccs & 0x4000) == 0) {
          *(wc_ccs *)ucs = cc.ccs;
          *(wc_uint32 *)(ucs + 4) = cc.code;
          goto LAB_080bf224;
        }
      }
    }
    for (f = 0; f < 0x15; f = f + 1) {
      if (ucs_cs94_table[f].map != (wc_map *)0x0) {
        wc_ucs_to_any((wc_uint32)&local_24,(wc_table *)(in_stack_00000008 & 0xffff));
        cc.ccs = local_24;
        cc.code = local_20;
        if ((local_24 & 0x4000) == 0) {
          *(uint *)ucs = local_24;
          *(wc_uint32 *)(ucs + 4) = local_20;
          goto LAB_080bf224;
        }
      }
    }
    for (f = 0; f < -0x3f; f = f + 1) {
      if (ucs_cs942_table[f].map != (wc_map *)0x0) {
        wc_ucs_to_any((wc_uint32)&local_24,(wc_table *)(in_stack_00000008 & 0xffff));
        cc.ccs = local_24;
        cc.code = local_20;
        if ((local_24 & 0x4000) == 0) {
          *(uint *)ucs = local_24;
          *(wc_uint32 *)(ucs + 4) = local_20;
          goto LAB_080bf224;
        }
      }
    }
  }
  *(undefined4 *)ucs = 0x4000;
  *(wc_uint32 *)(ucs + 4) = cc.code;
LAB_080bf224:
  return (wc_wchar_t)CONCAT44(cc.code,ucs);
}



wc_wchar_t wc_ucs_to_iso2022w(wc_uint32 ucs)

{
  uint in_stack_00000008;
  uint local_24;
  wc_uint32 local_20;
  wc_wchar_t cc;
  int f;
  wc_table *t;
  
  if (in_stack_00000008 < 0x10000) {
    for (f = 0; f < 0x11; f = f + 1) {
      if (ucs_cs94w_table[f].map != (wc_map *)0x0) {
        wc_ucs_to_any((wc_uint32)&cc,(wc_table *)(in_stack_00000008 & 0xffff));
        if ((cc.ccs & 0x4000) == 0) {
          *(wc_ccs *)ucs = cc.ccs;
          *(wc_uint32 *)(ucs + 4) = cc.code;
          goto LAB_080bf32f;
        }
      }
    }
    for (f = 0; f < -0x3f; f = f + 1) {
      if (ucs_cs96w_table[f].map != (wc_map *)0x0) {
        wc_ucs_to_any((wc_uint32)&local_24,(wc_table *)(in_stack_00000008 & 0xffff));
        cc.ccs = local_24;
        cc.code = local_20;
        if ((local_24 & 0x4000) == 0) {
          *(uint *)ucs = local_24;
          *(wc_uint32 *)(ucs + 4) = local_20;
          goto LAB_080bf32f;
        }
      }
    }
  }
  *(undefined4 *)ucs = 0xc000;
  *(wc_uint32 *)(ucs + 4) = cc.code;
LAB_080bf32f:
  return (wc_wchar_t)CONCAT44(cc.code,ucs);
}



wc_ccs wc_ucs_to_ccs(wc_uint32 ucs)

{
  wc_bool wVar1;
  wc_ccs wVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  
  if ((ucs < 0x80) || (0x9f < ucs)) {
    if (ucs < 0x10000) {
      uVar5 = 0x1000;
    }
    else {
      uVar5 = 0x2000;
    }
    wVar1 = wc_is_ucs_wide(ucs);
    if (wVar1 == '\0') {
      uVar3 = 0;
    }
    else {
      uVar3 = 0x10000;
    }
    wVar1 = wc_is_ucs_combining(ucs);
    if (wVar1 == '\0') {
      uVar4 = 0;
    }
    else {
      uVar4 = 0x20000;
    }
    wVar2 = uVar4 | uVar5 | uVar3;
  }
  else {
    wVar2 = 0x4001;
  }
  return wVar2;
}



wc_bool wc_is_ucs_wide(wc_uint32 ucs)

{
  wc_map *pwVar1;
  bool bVar2;
  
  if (ucs < 0x10000) {
    pwVar1 = wc_map_range_search((wc_uint16)ucs,ucs_wide_map,0xb);
    bVar2 = pwVar1 != (wc_map *)0x0;
  }
  else if ((ucs >> 0x10 == 2) || (ucs >> 0x10 == 3)) {
    bVar2 = true;
  }
  else {
    bVar2 = false;
  }
  return bVar2;
}



wc_bool wc_is_ucs_combining(wc_uint32 ucs)

{
  wc_map *pwVar1;
  
  if (((WcOption.use_combining != '\0') && (ucs < 0x10000)) &&
     (pwVar1 = wc_map_range_search((wc_uint16)ucs,ucs_combining_map,99), pwVar1 != (wc_map *)0x0)) {
    return '\x01';
  }
  return '\0';
}



wc_bool wc_is_ucs_hangul(wc_uint32 ucs)

{
  wc_map *pwVar1;
  
  if ((ucs < 0x10000) &&
     (pwVar1 = wc_map_range_search((wc_uint16)ucs,ucs_hangul_map,6), pwVar1 != (wc_map *)0x0)) {
    return '\x01';
  }
  return '\0';
}



wc_uint32 wc_ucs_precompose(wc_uint32 ucs1,wc_uint32 ucs2)

{
  wc_map3 *pwVar1;
  wc_map3 *map;
  
  if ((((WcOption.use_combining != '\0') && (ucs1 < 0x10000)) && (ucs2 < 0x10000)) &&
     (pwVar1 = wc_map3_search((wc_uint16)ucs1,(wc_uint16)ucs2,ucs_precompose_map,0x3dc),
     pwVar1 != (wc_map3 *)0x0)) {
    return (uint)pwVar1->code3;
  }
  return 0xffffffff;
}



wc_uint32 wc_ucs_to_fullwidth(wc_uint32 ucs)

{
  wc_map *pwVar1;
  wc_map *map;
  
  if ((ucs < 0x10000) &&
     (pwVar1 = wc_map_search((wc_uint16)ucs,ucs_fullwidth_map,0xe), pwVar1 != (wc_map *)0x0)) {
    return (uint)pwVar1->code2;
  }
  return 0xffffffff;
}



int wc_ucs_put_tag(char *p)

{
  int iVar1;
  int i;
  
  if ((p == (char *)0x0) || (*p == '\0')) {
    iVar1 = 0;
  }
  else {
    for (i = 1; i <= n_tag_map; i = i + 1) {
      iVar1 = strcasecmp(p,tag_map[i]);
      if (iVar1 == 0) {
        return i;
      }
    }
    n_tag_map = n_tag_map + 1;
    if (n_tag_map == 0x100) {
      iVar1 = 0;
    }
    else {
      tag_map[n_tag_map] = p;
      iVar1 = n_tag_map;
    }
  }
  return iVar1;
}



char * wc_ucs_get_tag(int ntag)

{
  char *pcVar1;
  
  if ((ntag == 0) || (n_tag_map < ntag)) {
    pcVar1 = (char *)0x0;
  }
  else {
    pcVar1 = tag_map[ntag];
  }
  return pcVar1;
}



void wtf_push_ucs(Str os,wc_uint32 ucs,wc_status *st)

{
  Str p_Var1;
  int iVar2;
  wc_ccs ccs;
  
  if ((ucs < 0xe0000) || (0xe007f < ucs)) {
    if (st->tag != (Str)0x0) {
      iVar2 = wc_ucs_put_tag(st->tag->ptr);
      st->ntag = iVar2;
      st->tag = (Str)0x0;
    }
    if (ucs < 0x80) {
      if (st->ntag == 0) {
        if (os->area_size <= os->length + 1) {
          Strgrow(os);
        }
        iVar2 = os->length;
        os->ptr[iVar2] = (byte)ucs;
        os->length = iVar2 + 1;
        os->ptr[os->length] = '\0';
      }
      else {
        wtf_push(os,0x2001,st->ntag << 0x18 | ucs);
      }
    }
    else {
      ccs = wc_ucs_to_ccs(ucs);
      if ((st->ntag != 0) && (ucs < 0x110000)) {
        ccs = ccs & 0xffff0000 | 0x2001;
        ucs = ucs | st->ntag << 0x18;
      }
      wtf_push(os,ccs,ucs);
    }
  }
  else if (WcOption.use_language_tag != '\0') {
    if (ucs == 0xe0001) {
      p_Var1 = Strnew_size(4);
      st->tag = p_Var1;
    }
    else if (ucs == 0xe007f) {
      st->tag = (Str)0x0;
      st->ntag = 0;
    }
    else if ((st->tag != (Str)0x0) && (0xe001f < ucs)) {
      if (st->tag->area_size <= st->tag->length + 1) {
        Strgrow(st->tag);
      }
      p_Var1 = st->tag;
      iVar2 = p_Var1->length;
      st->tag->ptr[iVar2] = (byte)ucs & 0x7f;
      p_Var1->length = iVar2 + 1;
      st->tag->ptr[st->tag->length] = '\0';
    }
  }
  return;
}



wc_wchar_t wc_uhc_to_cs128w(wc_wchar_t cc)

{
  wc_uint32 wVar1;
  int iVar2;
  uint in_stack_0000000c;
  
  if ((in_stack_0000000c & 0xff) < 0x61) {
    iVar2 = 0x41;
  }
  else if ((in_stack_0000000c & 0xff) < 0x81) {
    iVar2 = 0x47;
  }
  else {
    iVar2 = 0x4d;
  }
  iVar2 = ((in_stack_0000000c >> 8 & 0xff) * 0xb2 + (in_stack_0000000c & 0xff)) - iVar2;
  in_stack_0000000c = iVar2 - 0x59b2;
  if (in_stack_0000000c < 0x4000) {
    cc.code = 0x881d;
  }
  else {
    cc.code = 0x881e;
    in_stack_0000000c = iVar2 - 0x99b2;
  }
  wVar1 = (in_stack_0000000c >> 7) * 0x100 + (in_stack_0000000c & 0x7f);
  *(wc_uint32 *)cc.ccs = cc.code;
  *(wc_uint32 *)(cc.ccs + 4) = wVar1;
  return (wc_wchar_t)CONCAT44(wVar1,cc.ccs);
}



wc_wchar_t wc_cs128w_to_uhc(wc_wchar_t cc)

{
  uint uVar1;
  int iVar2;
  uint in_stack_0000000c;
  
  in_stack_0000000c = (in_stack_0000000c >> 8 & 0x7f) * 0x80 + (in_stack_0000000c & 0x7f);
  if (cc.code == 0x881e) {
    in_stack_0000000c = in_stack_0000000c + 0x4000;
  }
  if (in_stack_0000000c % 0xb2 < 0x1a) {
    iVar2 = 0x41;
  }
  else if (in_stack_0000000c % 0xb2 < 0x34) {
    iVar2 = 0x47;
  }
  else {
    iVar2 = 0x4d;
  }
  uVar1 = (in_stack_0000000c / 0xb2 + 0x81) * 0x100 + in_stack_0000000c % 0xb2 + iVar2;
  *(undefined4 *)cc.ccs = 0x881c;
  *(uint *)(cc.ccs + 4) = uVar1;
  return (wc_wchar_t)(cc & 0xffffffff | (ulonglong)uVar1 << 0x20);
}



wc_uint32 wc_uhc_to_N(wc_uint32 c)

{
  int iVar1;
  wc_uint32 wVar2;
  
  if (c < 0xa1a1) {
    if ((c & 0xff) < 0x61) {
      iVar1 = 0x41;
    }
    else if ((c & 0xff) < 0x81) {
      iVar1 = 0x47;
    }
    else {
      iVar1 = 0x4d;
    }
    wVar2 = (((c >> 8 & 0xff) * 0xb2 + (c & 0xff)) - iVar1) - 0x59b2;
  }
  else if (c < 0xa2a1) {
    if ((c & 0xff) < 0x61) {
      iVar1 = 0x41;
    }
    else if ((c & 0xff) < 0x81) {
      iVar1 = 0x47;
    }
    else {
      iVar1 = 0x4d;
    }
    wVar2 = (((c >> 8 & 0xff) * 0xb2 + (c & 0xff)) - iVar1) - 0x5a10;
  }
  else if (c < 0xa2e8) {
    wVar2 = c - 0x8bfe;
  }
  else {
    if ((c & 0xff) < 0x61) {
      iVar1 = 0x41;
    }
    else if ((c & 0xff) < 0x81) {
      iVar1 = 0x47;
    }
    else {
      iVar1 = 0x4d;
    }
    wVar2 = ((((c >> 8 & 0xff) * 0xb2 + (c & 0xff)) - iVar1) + (c >> 8) * -0x5e) - 0x1e92;
  }
  return wVar2;
}



Str wc_conv_from_uhc(Str is,wc_ces ces)

{
  wc_uchar *pwVar1;
  int iVar2;
  bool bVar3;
  wc_uchar *pwVar4;
  Str x;
  uint code;
  wc_uint32 uhc;
  int state;
  wc_uchar *p;
  wc_uchar *ep;
  wc_uchar *sp;
  Str os;
  
  pwVar1 = (wc_uchar *)is->ptr;
  pwVar4 = pwVar1 + is->length;
  bVar3 = false;
  for (p = pwVar1; (p < pwVar4 && (-1 < (char)*p)); p = p + 1) {
  }
  if (p != pwVar4) {
    x = Strnew_size(is->length);
    if (pwVar1 < p) {
      Strcat_charp_n(x,is->ptr,(int)p - (int)pwVar1);
    }
    for (; p < pwVar4; p = p + 1) {
      if (bVar3) {
        if (bVar3) {
          if ((WC_UHC_MAP[*p] & 4) == 0) {
            wtf_push_unknown(x,p + -1,2);
          }
          else {
            code = (uint)CONCAT11(p[-1],*p);
            if ((((p[-1] < 0xa1) || (*p < 0xa1)) || (code == 0xa2e6)) || (code == 0xa2e7)) {
              wtf_push(x,0x881c,code);
            }
            else {
              wtf_push(x,0x8143,code);
            }
          }
          bVar3 = false;
        }
      }
      else if (WC_UHC_MAP[*p] == '\x02') {
        wtf_push_unknown(x,p,1);
      }
      else if (WC_UHC_MAP[*p] == '\f') {
        bVar3 = true;
      }
      else {
        if (x->area_size <= x->length + 1) {
          Strgrow(x);
        }
        iVar2 = x->length;
        x->ptr[iVar2] = *p;
        x->length = iVar2 + 1;
        x->ptr[x->length] = '\0';
      }
    }
    is = x;
    if (bVar3) {
      wtf_push_unknown(x,p + -1,1);
    }
  }
  return is;
}



void wc_push_to_uhc(Str os,wc_wchar_t cc,wc_status *st)

{
  int iVar1;
  wc_ccs local_14;
  wc_uint32 local_10;
  
  do {
    if (cc.ccs == 0x881c) {
LAB_080bfe88:
      if (os->area_size <= os->length + 1) {
        Strgrow(os);
      }
      iVar1 = os->length;
      os->ptr[iVar1] = (char)(cc.code >> 8);
      os->length = iVar1 + 1;
      os->ptr[os->length] = '\0';
      if (os->area_size <= os->length + 1) {
        Strgrow(os);
      }
      iVar1 = os->length;
      os->ptr[iVar1] = (char)cc.code;
      os->length = iVar1 + 1;
      os->ptr[os->length] = '\0';
      return;
    }
    if (cc.ccs < 0x881d) {
      if (cc.ccs == 0x4000) {
        if (WcOption.no_replace != '\0') {
          return;
        }
        Strcat_charp(os,WcReplace);
        return;
      }
      if (cc.ccs == 0x8143) {
        if (os->area_size <= os->length + 1) {
          Strgrow(os);
        }
        iVar1 = os->length;
        os->ptr[iVar1] = (byte)(cc.code >> 8) | 0x80;
        os->length = iVar1 + 1;
        os->ptr[os->length] = '\0';
        if (os->area_size <= os->length + 1) {
          Strgrow(os);
        }
        iVar1 = os->length;
        os->ptr[iVar1] = (byte)cc.code | 0x80;
        os->length = iVar1 + 1;
        os->ptr[os->length] = '\0';
        return;
      }
      if (cc.ccs == 0x142) {
        if (os->area_size <= os->length + 1) {
          Strgrow(os);
        }
        iVar1 = os->length;
        os->ptr[iVar1] = (char)cc.code;
        os->length = iVar1 + 1;
        os->ptr[os->length] = '\0';
        return;
      }
    }
    else {
      if (cc.ccs < 0x881f) {
        wc_cs128w_to_uhc((wc_wchar_t)CONCAT44(cc.ccs,&cc));
        goto LAB_080bfe88;
      }
      if (cc.ccs == 0xc000) {
        if (WcOption.no_replace != '\0') {
          return;
        }
        Strcat_charp(os,WcReplaceW);
        return;
      }
    }
    if (WcOption.ucs_conv == '\0') {
      if ((cc.ccs & 0x18000) == 0) {
        cc.ccs = 0x4000;
      }
      else {
        cc.ccs = 0xc000;
      }
    }
    else {
      wc_any_to_any_ces((wc_wchar_t)CONCAT44(cc.ccs,&local_14),(wc_status *)cc.code);
      cc.ccs = local_14;
      cc.code = local_10;
    }
  } while( true );
}



Str wc_char_conv_from_uhc(wc_uchar c,wc_status *st)

{
  int iVar1;
  Str p_Var2;
  uint code;
  wc_uint32 uhc;
  
  if (st->state == -1) {
    st->state = 0;
    wc_char_conv_from_uhc::os = Strnew_size(8);
  }
  if (st->state == 0) {
    if (WC_UHC_MAP[c] != '\x02') {
      if (WC_UHC_MAP[c] == '\f') {
        wc_char_conv_from_uhc::uhcu = c;
        st->state = 1;
        return (Str)0x0;
      }
      if (wc_char_conv_from_uhc::os->area_size <= wc_char_conv_from_uhc::os->length + 1) {
        Strgrow(wc_char_conv_from_uhc::os);
      }
      p_Var2 = wc_char_conv_from_uhc::os;
      iVar1 = wc_char_conv_from_uhc::os->length;
      wc_char_conv_from_uhc::os->ptr[iVar1] = c;
      p_Var2->length = iVar1 + 1;
      wc_char_conv_from_uhc::os->ptr[wc_char_conv_from_uhc::os->length] = '\0';
    }
  }
  else if ((st->state == 1) && ((WC_UHC_MAP[c] & 4) != 0)) {
    code = (uint)CONCAT11(wc_char_conv_from_uhc::uhcu,c);
    if ((wc_char_conv_from_uhc::uhcu < 0xa1) ||
       (((c < 0xa1 || (code == 0xa2e6)) || (code == 0xa2e7)))) {
      wtf_push(wc_char_conv_from_uhc::os,0x881c,code);
    }
    else {
      wtf_push(wc_char_conv_from_uhc::os,0x8143,code);
    }
  }
  st->state = -1;
  return wc_char_conv_from_uhc::os;
}



Str wc_conv_from_utf7(Str is,wc_ces ces)

{
  wc_uint8 wVar1;
  wc_uchar *pwVar2;
  int iVar3;
  wc_uchar *pwVar4;
  Str x;
  bool bVar5;
  wc_status st;
  wc_uint32 high;
  wc_uint32 b;
  int state;
  wc_uchar *p;
  wc_uchar *ep;
  wc_uchar *sp;
  Str os;
  
  pwVar2 = (wc_uchar *)is->ptr;
  pwVar4 = pwVar2 + is->length;
  state = 0;
  high = 0;
  for (p = pwVar2; ((p < pwVar4 && (-1 < (char)*p)) && (*p != '+')); p = p + 1) {
  }
  if (p != pwVar4) {
    x = Strnew_size((is->length * 4) / 3);
    if (pwVar2 < p) {
      Strcat_charp_n(x,is->ptr,(int)p - (int)pwVar2);
    }
    st.tag = (Str)0x0;
    st.ntag = 0;
    for (; is = x, p < pwVar4; p = p + 1) {
      if (state == 1) {
        if (*p == '-') {
          wtf_push_ucs(x,0x2b,&st);
        }
LAB_080c0289:
        wVar1 = WC_UTF7_MAP[*p];
        if (wVar1 != ' ') {
          if (wVar1 == '@') {
            state = 0;
            goto LAB_080c0491;
          }
          if (wVar1 != '\x10') goto LAB_080c03e3;
        }
        wVar1 = WC_UTF7_MAP[*p + 0xe0];
        st.shift = st.shift + -6;
        if (st.shift < 1) {
          st.base = st.base | (uint)(int)(char)wVar1 >> (-(char)st.shift & 0x1fU);
          if ((st.base < 0xd800) || (0xdbff < st.base)) {
            if ((st.base < 0xdc00) || (0xdfff < st.base)) {
              if (st.base != 0xfeff) {
                wtf_push_ucs(x,st.base,&st);
              }
            }
            else {
              if (high != 0) {
                wtf_push_ucs(x,(st.base & 0x3ff | (high & 0x3ff) << 10) + 0x10000,&st);
              }
              high = 0;
            }
          }
          else {
            bVar5 = high != 0;
            high = st.base;
            if (bVar5) {
              high = 0;
            }
          }
          st.shift = st.shift + 0x10;
          st.base = 0;
        }
        st.base = (int)(char)wVar1 << ((byte)st.shift & 0x1f) & 0xffffU | st.base;
        state = 2;
      }
      else {
        if (state == 2) goto LAB_080c0289;
        if ((state == 0) && (*p == '+')) {
          state = 1;
          st.shift = 0x10;
          st.base = 0;
          high = 0;
        }
        else {
LAB_080c03e3:
          wVar1 = WC_UTF7_MAP[*p];
          if (wVar1 == '\x06') {
LAB_080c0405:
            if (x->area_size <= x->length + 1) {
              Strgrow(x);
            }
            iVar3 = x->length;
            x->ptr[iVar3] = *p;
            x->length = iVar3 + 1;
            x->ptr[x->length] = '\0';
          }
          else if (wVar1 == '\b') {
            wtf_push_unknown(x,p,1);
          }
          else {
            if (wVar1 == '\x04') goto LAB_080c0405;
            wtf_push_ucs(x,(uint)*p,&st);
          }
        }
      }
LAB_080c0491:
    }
  }
  return is;
}



void wc_push_ucs_to_utf7(Str os,wc_uint32 ucs,wc_status *st)

{
  byte bVar1;
  int iVar2;
  
  if (0x10ffff < ucs) {
    return;
  }
  if (0xffff < ucs) {
    wc_push_ucs_to_utf7(os,ucs - 0x10000 >> 10 & 0xffff | 0xd800,st);
    wc_push_ucs_to_utf7(os,ucs - 0x10000 & 0x3ff | 0xdc00,st);
    return;
  }
  if (0x7f < ucs) goto LAB_080c07d2;
  bVar1 = WC_UTF7_MAP[ucs];
  if (bVar1 != 0x10) {
    if (bVar1 < 0x11) {
      if ((bVar1 == 0) || (bVar1 == 4)) goto LAB_080c0572;
    }
    else {
      if (bVar1 == 0x20) {
        if (st->state == 2) {
          if (os->area_size <= os->length + 1) {
            Strgrow(os);
          }
          iVar2 = os->length;
          os->ptr[iVar2] = base64_c_map[st->base];
          os->length = iVar2 + 1;
          os->ptr[os->length] = '\0';
          if (os->area_size <= os->length + 1) {
            Strgrow(os);
          }
          iVar2 = os->length;
          os->ptr[iVar2] = '-';
          os->length = iVar2 + 1;
          os->ptr[os->length] = '\0';
          st->state = 0;
        }
        if (os->area_size <= os->length + 1) {
          Strgrow(os);
        }
        iVar2 = os->length;
        os->ptr[iVar2] = '+';
        os->length = iVar2 + 1;
        os->ptr[os->length] = '\0';
        if (os->area_size <= os->length + 1) {
          Strgrow(os);
        }
        iVar2 = os->length;
        os->ptr[iVar2] = '-';
        os->length = iVar2 + 1;
        os->ptr[os->length] = '\0';
        return;
      }
      if (bVar1 == 0x40) goto LAB_080c0572;
    }
LAB_080c07d2:
    if ((st->state == 2) && (st->shift != 0)) {
      st->shift = st->shift + 0x10;
      st->base = st->base | ucs >> ((byte)st->shift & 0x1f);
      if (os->area_size <= os->length + 1) {
        Strgrow(os);
      }
      iVar2 = os->length;
      os->ptr[iVar2] = base64_c_map[st->base];
      os->length = iVar2 + 1;
      os->ptr[os->length] = '\0';
    }
    else {
      if (st->state != 2) {
        if (os->area_size <= os->length + 1) {
          Strgrow(os);
        }
        iVar2 = os->length;
        os->ptr[iVar2] = '+';
        os->length = iVar2 + 1;
        os->ptr[os->length] = '\0';
        st->state = 2;
      }
      st->shift = 0x10;
      st->base = 0;
    }
    st->shift = st->shift + -6;
    if (os->area_size <= os->length + 1) {
      Strgrow(os);
    }
    iVar2 = os->length;
    os->ptr[iVar2] = base64_c_map[ucs >> ((byte)st->shift & 0x1f) & 0x3f];
    os->length = iVar2 + 1;
    os->ptr[os->length] = '\0';
    st->shift = st->shift + -6;
    if (os->area_size <= os->length + 1) {
      Strgrow(os);
    }
    iVar2 = os->length;
    os->ptr[iVar2] = base64_c_map[ucs >> ((byte)st->shift & 0x1f) & 0x3f];
    os->length = iVar2 + 1;
    os->ptr[os->length] = '\0';
    if (st->shift != 0) {
      st->shift = st->shift + -6;
      st->base = ucs << (-(char)st->shift & 0x1fU) & 0x3f;
    }
    return;
  }
LAB_080c0572:
  if (st->state == 2) {
    if (os->area_size <= os->length + 1) {
      Strgrow(os);
    }
    iVar2 = os->length;
    os->ptr[iVar2] = base64_c_map[st->base];
    os->length = iVar2 + 1;
    os->ptr[os->length] = '\0';
    if (os->area_size <= os->length + 1) {
      Strgrow(os);
    }
    iVar2 = os->length;
    os->ptr[iVar2] = '-';
    os->length = iVar2 + 1;
    os->ptr[os->length] = '\0';
    st->state = 0;
  }
  if (os->area_size <= os->length + 1) {
    Strgrow(os);
  }
  iVar2 = os->length;
  os->ptr[iVar2] = (char)ucs;
  os->length = iVar2 + 1;
  os->ptr[os->length] = '\0';
  return;
}



int wc_push_tag_to_utf7(Str os,int ntag,wc_status *st)

{
  char *p;
  
  if ((ntag != 0) && (p = wc_ucs_get_tag(ntag), p == (char *)0x0)) {
    ntag = 0;
  }
  if (ntag == 0) {
    wc_push_ucs_to_utf7(os,0xe007f,st);
  }
  else {
    wc_push_ucs_to_utf7(os,0xe0001,st);
    for (; *p != '\0'; p = p + 1) {
      wc_push_ucs_to_utf7(os,(int)*p | 0xe0000,st);
    }
  }
  return ntag;
}



void wc_push_to_utf7(Str os,wc_wchar_t cc,wc_status *st)

{
  uint uVar1;
  int iVar2;
  char *p;
  
  do {
    while (uVar1 = cc.ccs & 0xffff, uVar1 == 0x2000) {
      if (cc.code < 0x110000) goto LAB_080c0b36;
      if ((cc.ccs & 0x18000) == 0) {
        cc.ccs = 0x4000;
      }
      else {
        cc.ccs = 0xc000;
      }
    }
    if (uVar1 < 0x2001) {
      if (uVar1 == 0x241) {
        if (st->ntag != 0) {
          iVar2 = wc_push_tag_to_utf7(os,0,st);
          st->ntag = iVar2;
        }
        wc_push_ucs_to_utf7(os,cc.code | 0x80,st);
        return;
      }
      if ((uVar1 == 0x1000) || (uVar1 == 0x142)) {
LAB_080c0b36:
        if (st->ntag != 0) {
          iVar2 = wc_push_tag_to_utf7(os,0,st);
          st->ntag = iVar2;
        }
        wc_push_ucs_to_utf7(os,cc.code,st);
        return;
      }
    }
    else {
      if (uVar1 == 0x4000) {
        if (WcOption.no_replace != '\0') {
          return;
        }
        if (st->ntag != 0) {
          iVar2 = wc_push_tag_to_utf7(os,0,st);
          st->ntag = iVar2;
        }
        for (p = WcReplace; *p != '\0'; p = p + 1) {
          wc_push_ucs_to_utf7(os,(int)*p,st);
        }
        return;
      }
      if (uVar1 == 0xc000) {
        if (WcOption.no_replace != '\0') {
          return;
        }
        if (st->ntag != 0) {
          iVar2 = wc_push_tag_to_utf7(os,0,st);
          st->ntag = iVar2;
        }
        for (p = WcReplaceW; *p != '\0'; p = p + 1) {
          wc_push_ucs_to_utf7(os,(int)*p,st);
        }
        return;
      }
      if (uVar1 == 0x2001) {
        if ((WcOption.use_language_tag != '\0') && (cc.code >> 0x18 != st->ntag)) {
          iVar2 = wc_push_tag_to_utf7(os,cc.code >> 0x18,st);
          st->ntag = iVar2;
        }
        wc_push_ucs_to_utf7(os,cc.code & 0x1fffff,st);
        return;
      }
    }
    if ((WcOption.ucs_conv == '\0') ||
       (cc.code = wc_any_to_ucs((wc_wchar_t)CONCAT44(cc.code,cc.ccs)), cc.code == 0xffffffff)) {
      if ((cc.ccs & 0x18000) == 0) {
        cc.ccs = 0x4000;
      }
      else {
        cc.ccs = 0xc000;
      }
    }
    else {
      cc.ccs = 0x1000;
    }
  } while( true );
}



void wc_push_to_utf7_end(Str os,wc_status *st)

{
  int iVar1;
  
  if (st->ntag != 0) {
    iVar1 = wc_push_tag_to_utf7(os,0,st);
    st->ntag = iVar1;
  }
  if (st->state == 2) {
    if (st->shift != 0) {
      if (os->area_size <= os->length + 1) {
        Strgrow(os);
      }
      iVar1 = os->length;
      os->ptr[iVar1] = base64_c_map[st->base];
      os->length = iVar1 + 1;
      os->ptr[os->length] = '\0';
    }
    if (os->area_size <= os->length + 1) {
      Strgrow(os);
    }
    iVar1 = os->length;
    os->ptr[iVar1] = '-';
    os->length = iVar1 + 1;
    os->ptr[os->length] = '\0';
  }
  return;
}



Str wc_char_conv_from_utf7(wc_uchar c,wc_status *st)

{
  wc_uint8 wVar1;
  int iVar2;
  Str p_Var3;
  wc_uint32 b;
  
  if (st->state == -1) {
    st->state = 0;
    wc_char_conv_from_utf7::os = Strnew_size(8);
  }
  iVar2 = st->state;
  if (iVar2 == 1) {
    if (c == '-') {
      wtf_push_ucs(wc_char_conv_from_utf7::os,0x2b,st);
      st->state = -1;
      return wc_char_conv_from_utf7::os;
    }
LAB_080c0f1c:
    wVar1 = WC_UTF7_MAP[c];
    if (wVar1 == ' ') {
LAB_080c0f41:
      wVar1 = WC_UTF7_MAP[c + 0xe0];
      st->shift = st->shift + -6;
      if (st->shift < 1) {
        st->base = st->base | (uint)(int)(char)wVar1 >> (-(char)st->shift & 0x1fU);
        if ((st->base < 0xd800) || (0xdbff < st->base)) {
          if ((st->base < 0xdc00) || (0xdfff < st->base)) {
            if (st->base != 0xfeff) {
              wtf_push_ucs(wc_char_conv_from_utf7::os,st->base,st);
            }
          }
          else {
            if (wc_char_conv_from_utf7::high != 0) {
              wtf_push_ucs(wc_char_conv_from_utf7::os,
                           (st->base & 0x3ff | (wc_char_conv_from_utf7::high & 0x3ff) << 10) +
                           0x10000,st);
            }
            wc_char_conv_from_utf7::high = 0;
          }
        }
        else if (wc_char_conv_from_utf7::high == 0) {
          wc_char_conv_from_utf7::high = st->base;
        }
        else {
          wc_char_conv_from_utf7::high = 0;
        }
        st->shift = st->shift + 0x10;
        st->base = 0;
      }
      st->base = st->base | (int)(char)wVar1 << ((byte)st->shift & 0x1f) & 0xffffU;
      st->state = 2;
      return wc_char_conv_from_utf7::os;
    }
    if (wVar1 == '@') {
      st->state = -1;
      return (Str)0x0;
    }
    if (wVar1 == '\x10') goto LAB_080c0f41;
  }
  else {
    if (iVar2 == 2) goto LAB_080c0f1c;
    if ((iVar2 == 0) && (c == '+')) {
      st->state = 1;
      st->shift = 0x10;
      st->base = 0;
      wc_char_conv_from_utf7::high = 0;
      return (Str)0x0;
    }
  }
  wVar1 = WC_UTF7_MAP[c];
  if (wVar1 != '\x06') {
    if (wVar1 == '\b') goto LAB_080c1165;
    if (wVar1 != '\x04') {
      wtf_push_ucs(wc_char_conv_from_utf7::os,(uint)c,st);
      goto LAB_080c1165;
    }
  }
  if (wc_char_conv_from_utf7::os->area_size <= wc_char_conv_from_utf7::os->length + 1) {
    Strgrow(wc_char_conv_from_utf7::os);
  }
  p_Var3 = wc_char_conv_from_utf7::os;
  iVar2 = wc_char_conv_from_utf7::os->length;
  wc_char_conv_from_utf7::os->ptr[iVar2] = c;
  p_Var3->length = iVar2 + 1;
  wc_char_conv_from_utf7::os->ptr[wc_char_conv_from_utf7::os->length] = '\0';
LAB_080c1165:
  st->state = -1;
  return wc_char_conv_from_utf7::os;
}



size_t wc_ucs_to_utf8(wc_uint32 ucs,wc_uchar *utf8)

{
  byte bVar1;
  size_t sVar2;
  byte bVar3;
  
  bVar3 = (byte)ucs;
  if (ucs < 0x80) {
    *utf8 = bVar3;
    utf8[1] = '\0';
    sVar2 = 1;
  }
  else if (ucs < 0x800) {
    *utf8 = (byte)(ucs >> 6) | 0xc0;
    utf8[1] = bVar3 & 0x3f | 0x80;
    utf8[2] = '\0';
    sVar2 = 2;
  }
  else if (ucs < 0x10000) {
    *utf8 = (byte)(ucs >> 0xc) | 0xe0;
    utf8[1] = (byte)(ucs >> 6) & 0x3f | 0x80;
    utf8[2] = bVar3 & 0x3f | 0x80;
    utf8[3] = '\0';
    sVar2 = 3;
  }
  else if (ucs < 0x200000) {
    *utf8 = (byte)(ucs >> 0x12) | 0xf0;
    utf8[1] = (byte)(ucs >> 0xc) & 0x3f | 0x80;
    utf8[2] = (byte)(ucs >> 6) & 0x3f | 0x80;
    utf8[3] = bVar3 & 0x3f | 0x80;
    utf8[4] = '\0';
    sVar2 = 4;
  }
  else {
    bVar1 = (byte)(ucs >> 0x18);
    if (ucs < 0x4000000) {
      *utf8 = bVar1 | 0xf8;
      utf8[1] = (byte)(ucs >> 0x12) & 0x3f | 0x80;
      utf8[2] = (byte)(ucs >> 0xc) & 0x3f | 0x80;
      utf8[3] = (byte)(ucs >> 6) & 0x3f | 0x80;
      utf8[4] = bVar3 & 0x3f | 0x80;
      utf8[5] = '\0';
      sVar2 = 5;
    }
    else if ((int)ucs < 0) {
      *utf8 = '\0';
      sVar2 = 0;
    }
    else {
      *utf8 = bVar1 >> 6 | 0xfc;
      utf8[1] = bVar1 & 0x3f | 0x80;
      utf8[2] = (byte)(ucs >> 0x12) & 0x3f | 0x80;
      utf8[3] = (byte)(ucs >> 0xc) & 0x3f | 0x80;
      utf8[4] = (byte)(ucs >> 6) & 0x3f | 0x80;
      utf8[5] = bVar3 & 0x3f | 0x80;
      utf8[6] = '\0';
      sVar2 = 6;
    }
  }
  return sVar2;
}



wc_uint32 wc_utf8_to_ucs(wc_uchar *utf8)

{
  uint uVar1;
  wc_uint32 ucs;
  
  switch(WC_UTF8_MAP[*utf8]) {
  case '\x01':
    if (*utf8 < 0x80) {
      return (uint)*utf8;
    }
    break;
  case '\x02':
    uVar1 = utf8[1] & 0x3f | (*utf8 & 0x1f) << 6;
    if (0x7f < uVar1) {
      return uVar1;
    }
    break;
  case '\x03':
    uVar1 = utf8[2] & 0x3f | (*utf8 & 0xf) << 0xc | (utf8[1] & 0x3f) << 6;
    if (0x7ff < uVar1) {
      return uVar1;
    }
    break;
  case '\x04':
    uVar1 = utf8[3] & 0x3f | (*utf8 & 7) << 0x12 | (utf8[1] & 0x3f) << 0xc | (utf8[2] & 0x3f) << 6;
    if (0xffff < uVar1) {
      return uVar1;
    }
    break;
  case '\x05':
    uVar1 = utf8[4] & 0x3f |
            (*utf8 & 3) << 0x18 | (utf8[1] & 0x3f) << 0x12 | (utf8[2] & 0x3f) << 0xc |
            (utf8[3] & 0x3f) << 6;
    if (0x1fffff < uVar1) {
      return uVar1;
    }
    break;
  case '\x06':
    uVar1 = utf8[5] & 0x3f |
            (*utf8 & 1) << 0x1e | (utf8[1] & 0x3f) << 0x18 | (utf8[2] & 0x3f) << 0x12 |
            (utf8[3] & 0x3f) << 0xc | (utf8[4] & 0x3f) << 6;
    if (0x3ffffff < uVar1) {
      return uVar1;
    }
  }
  return 0xffffffff;
}



Str wc_conv_from_utf8(Str is,wc_ces ces)

{
  wc_uchar *pwVar1;
  int iVar2;
  bool bVar3;
  wc_uchar *pwVar4;
  Str x;
  wc_uint32 ucs_00;
  wc_status st;
  wc_uint32 ucs;
  size_t next;
  int state;
  wc_uchar *q;
  wc_uchar *p;
  wc_uchar *ep;
  wc_uchar *sp;
  Str os;
  
  pwVar1 = (wc_uchar *)is->ptr;
  pwVar4 = pwVar1 + is->length;
  q = (wc_uchar *)0x0;
  bVar3 = false;
  next = 0;
  for (p = pwVar1; (p < pwVar4 && (-1 < (char)*p)); p = p + 1) {
  }
  if (p != pwVar4) {
    x = Strnew_size((is->length * 4) / 3);
    if (pwVar1 < p) {
      Strcat_charp_n(x,is->ptr,(int)p - (int)pwVar1);
    }
    st.tag = (Str)0x0;
    st.ntag = 0;
    for (; p < pwVar4; p = p + 1) {
      if (bVar3) {
        if (bVar3) {
          if (WC_UTF8_MAP[*p] == '\0') {
            next = next - 1;
            if (next == 0) {
              bVar3 = false;
              ucs_00 = wc_utf8_to_ucs(q);
              if ((ucs_00 == 0xffffffff) || ((0xd7ff < ucs_00 && (ucs_00 < 0xe000)))) {
                wtf_push_unknown(x,q,(size_t)(p + (1 - (int)q)));
              }
              else if (ucs_00 != 0xfeff) {
                wtf_push_ucs(x,ucs_00,&st);
              }
            }
          }
          else {
            wtf_push_unknown(x,q,(size_t)(p + (1 - (int)q)));
            bVar3 = false;
          }
        }
      }
      else {
        next = (size_t)WC_UTF8_MAP[*p];
        if (next == 1) {
          wtf_push_ucs(x,(uint)*p,&st);
        }
        else if ((next == 0) || (next == 7)) {
          wtf_push_unknown(x,p,1);
        }
        else if (next == 8) {
          if (x->area_size <= x->length + 1) {
            Strgrow(x);
          }
          iVar2 = x->length;
          x->ptr[iVar2] = *p;
          x->length = iVar2 + 1;
          x->ptr[x->length] = '\0';
        }
        else {
          q = p;
          next = next - 1;
          bVar3 = true;
        }
      }
    }
    is = x;
    if (bVar3) {
      wtf_push_unknown(x,q,(int)p - (int)q);
    }
  }
  return is;
}



int wc_push_tag_to_utf8(Str os,int ntag)

{
  char *p;
  
  if ((ntag != 0) && (p = wc_ucs_get_tag(ntag), p == (char *)0x0)) {
    ntag = 0;
  }
  if (ntag == 0) {
    wc_ucs_to_utf8(0xe007f,utf8_buf);
    Strcat_charp(os,(char *)utf8_buf);
  }
  else {
    wc_ucs_to_utf8(0xe0001,utf8_buf);
    Strcat_charp(os,(char *)utf8_buf);
    for (; *p != '\0'; p = p + 1) {
      wc_ucs_to_utf8((int)*p | 0xe0000,utf8_buf);
      Strcat_charp(os,(char *)utf8_buf);
    }
  }
  return ntag;
}



void wc_push_to_utf8(Str os,wc_wchar_t cc,wc_status *st)

{
  uint uVar1;
  int iVar2;
  
  while (uVar1 = cc.ccs & 0xffff, uVar1 != 0x2000) {
    if (uVar1 < 0x2001) {
      if (uVar1 == 0x241) {
        if (st->ntag != 0) {
          iVar2 = wc_push_tag_to_utf8(os,0);
          st->ntag = iVar2;
        }
        wc_ucs_to_utf8(cc.code | 0x80,utf8_buf);
        Strcat_charp(os,(char *)utf8_buf);
        return;
      }
      if (uVar1 == 0x1000) break;
      if (uVar1 == 0x142) {
        if (st->ntag != 0) {
          iVar2 = wc_push_tag_to_utf8(os,0);
          st->ntag = iVar2;
        }
        if (os->area_size <= os->length + 1) {
          Strgrow(os);
        }
        iVar2 = os->length;
        os->ptr[iVar2] = (byte)cc.code & 0x7f;
        os->length = iVar2 + 1;
        os->ptr[os->length] = '\0';
        return;
      }
    }
    else {
      if (uVar1 == 0x4000) {
        if (WcOption.no_replace != '\0') {
          return;
        }
        if (st->ntag != 0) {
          iVar2 = wc_push_tag_to_utf8(os,0);
          st->ntag = iVar2;
        }
        Strcat_charp(os,WcReplace);
        return;
      }
      if (uVar1 == 0xc000) {
        if (WcOption.no_replace != '\0') {
          return;
        }
        if (st->ntag != 0) {
          iVar2 = wc_push_tag_to_utf8(os,0);
          st->ntag = iVar2;
        }
        Strcat_charp(os,WcReplaceW);
        return;
      }
      if (uVar1 == 0x2001) {
        if ((WcOption.use_language_tag != '\0') && (cc.code >> 0x18 != st->ntag)) {
          iVar2 = wc_push_tag_to_utf8(os,cc.code >> 0x18);
          st->ntag = iVar2;
        }
        wc_ucs_to_utf8(cc.code & 0x1fffff,utf8_buf);
        Strcat_charp(os,(char *)utf8_buf);
        return;
      }
    }
    if ((WcOption.ucs_conv == '\0') ||
       (cc.code = wc_any_to_ucs((wc_wchar_t)CONCAT44(cc.code,cc.ccs)), cc.code == 0xffffffff)) {
      if ((cc.ccs & 0x18000) == 0) {
        cc.ccs = 0x4000;
      }
      else {
        cc.ccs = 0xc000;
      }
    }
    else {
      cc.ccs = 0x1000;
    }
  }
  if (st->ntag != 0) {
    iVar2 = wc_push_tag_to_utf8(os,0);
    st->ntag = iVar2;
  }
  wc_ucs_to_utf8(cc.code,utf8_buf);
  Strcat_charp(os,(char *)utf8_buf);
  return;
}



void wc_push_to_utf8_end(Str os,wc_status *st)

{
  int iVar1;
  
  if (st->ntag != 0) {
    iVar1 = wc_push_tag_to_utf8(os,0);
    st->ntag = iVar1;
  }
  return;
}



Str wc_char_conv_from_utf8(wc_uchar c,wc_status *st)

{
  int iVar1;
  Str p_Var2;
  wc_uint32 ucs_00;
  wc_uint32 ucs;
  
  if (st->state == -1) {
    st->state = 0;
    wc_char_conv_from_utf8::os = Strnew_size(8);
    st->tag = (Str)0x0;
    st->ntag = 0;
    wc_char_conv_from_utf8::nbuf = 0;
  }
  if (st->state == 0) {
    wc_char_conv_from_utf8::next = (size_t)WC_UTF8_MAP[c];
    if (wc_char_conv_from_utf8::next == 1) {
      wtf_push_ucs(wc_char_conv_from_utf8::os,(uint)c,st);
    }
    else if ((wc_char_conv_from_utf8::next != 0) && (wc_char_conv_from_utf8::next != 7)) {
      if (wc_char_conv_from_utf8::next != 8) {
        wc_char_conv_from_utf8::buf[wc_char_conv_from_utf8::nbuf] = c;
        wc_char_conv_from_utf8::nbuf = wc_char_conv_from_utf8::nbuf + 1;
        wc_char_conv_from_utf8::next = wc_char_conv_from_utf8::next - 1;
        st->state = 1;
        return (Str)0x0;
      }
      if (wc_char_conv_from_utf8::os->area_size <= wc_char_conv_from_utf8::os->length + 1) {
        Strgrow(wc_char_conv_from_utf8::os);
      }
      p_Var2 = wc_char_conv_from_utf8::os;
      iVar1 = wc_char_conv_from_utf8::os->length;
      wc_char_conv_from_utf8::os->ptr[iVar1] = c;
      p_Var2->length = iVar1 + 1;
      wc_char_conv_from_utf8::os->ptr[wc_char_conv_from_utf8::os->length] = '\0';
    }
  }
  else if ((st->state == 1) && (WC_UTF8_MAP[c] == '\0')) {
    wc_char_conv_from_utf8::buf[wc_char_conv_from_utf8::nbuf] = c;
    wc_char_conv_from_utf8::nbuf = wc_char_conv_from_utf8::nbuf + 1;
    wc_char_conv_from_utf8::next = wc_char_conv_from_utf8::next - 1;
    if (wc_char_conv_from_utf8::next != 0) {
      return (Str)0x0;
    }
    ucs_00 = wc_utf8_to_ucs(wc_char_conv_from_utf8::buf);
    if ((ucs_00 != 0xffffffff) && (((ucs_00 < 0xd800 || (0xdfff < ucs_00)) && (ucs_00 != 0xfeff))))
    {
      wtf_push_ucs(wc_char_conv_from_utf8::os,ucs_00,st);
    }
  }
  st->state = -1;
  return wc_char_conv_from_utf8::os;
}



wc_uint32 wc_tcvn5712_precompose(wc_uchar c1,wc_uchar c2)

{
  wc_uint32 wVar1;
  
  if ((tcvn5712_precompose_map[c1] == '\x01') && (tcvn5712_precompose_map[c2] == '\x02')) {
    wVar1 = (wc_uint32)CONCAT11(c1,c2);
  }
  else {
    wVar1 = 0;
  }
  return wVar1;
}



wc_wchar_t wc_tcvn57123_to_tcvn5712(wc_wchar_t cc)

{
  wc_map *pwVar1;
  uint in_stack_0000000c;
  wc_map *map;
  
  pwVar1 = wc_map_search((ushort)in_stack_0000000c & 0x7f7f,tcvn57123_tcvn5712_map,0x78);
  if (pwVar1 == (wc_map *)0x0) {
    cc.code = 0x4000;
  }
  else {
    if (pwVar1->code2 < 0x20) {
      cc.code = 0x81e;
    }
    else {
      cc.code = 0x81d;
    }
    in_stack_0000000c = pwVar1->code2 | 0x80;
  }
  *(wc_uint32 *)cc.ccs = cc.code;
  *(uint *)(cc.ccs + 4) = in_stack_0000000c;
  return (wc_wchar_t)CONCAT44(in_stack_0000000c,cc.ccs);
}



wc_uint32 wc_cp1258_precompose(wc_uchar c1,wc_uchar c2)

{
  wc_uint32 wVar1;
  
  if ((cp1258_precompose_map[c1] == '\x01') && (cp1258_precompose_map[c2] == '\x02')) {
    wVar1 = (wc_uint32)CONCAT11(c1,c2);
  }
  else {
    wVar1 = 0;
  }
  return wVar1;
}



Str wc_conv_from_viet(Str is,wc_ces ces)

{
  wc_uchar *pwVar1;
  wc_ccs ccs;
  wc_ccs ccs_00;
  int iVar2;
  wc_uchar *pwVar3;
  Str x;
  wc_uint8 *map;
  wc_ccs ccs2;
  wc_ccs ccs1;
  wc_uchar *p;
  wc_uchar *ep;
  wc_uchar *sp;
  Str os;
  
  pwVar1 = (wc_uchar *)is->ptr;
  pwVar3 = pwVar1 + is->length;
  ccs = WcCesInfo[ces & 0xff].gset[1].ccs;
  ccs_00 = WcCesInfo[ces & 0xff].gset[2].ccs;
  map = (wc_uint8 *)0x0;
  if (ces == 0x104443) {
    map = wc_c0_viscii112_map;
  }
  else if (ces == 0x104444) {
    map = wc_c0_vps2_map;
  }
  else if (ces == 0x104442) {
    map = wc_c0_tcvn57122_map;
  }
  wc_create_detect_map(ces,'\0');
  p = pwVar1;
  while ((p < pwVar3 && (WC_DETECT_MAP[*p] == '\0'))) {
    p = p + 1;
  }
  if (p != pwVar3) {
    x = Strnew_size(is->length);
    if (pwVar1 < p) {
      Strcat_charp_n(x,is->ptr,(int)p - (int)pwVar1);
    }
    for (; is = x, p < pwVar3; p = p + 1) {
      if ((char)*p < '\0') {
        wtf_push(x,ccs,(uint)*p);
      }
      else if ((*p < 0x20) && (map[*p] != '\0')) {
        wtf_push(x,ccs_00,(uint)*p);
      }
      else {
        if (x->area_size <= x->length + 1) {
          Strgrow(x);
        }
        iVar2 = x->length;
        x->ptr[iVar2] = *p;
        x->length = iVar2 + 1;
        x->ptr[x->length] = '\0';
      }
    }
  }
  return is;
}



void wc_push_to_viet(Str os,wc_wchar_t cc,wc_status *st)

{
  wc_ccs wVar1;
  uint uVar2;
  int iVar3;
  wc_uint8 *map;
  wc_ccs ccs3;
  wc_ccs ccs2;
  wc_ccs ccs1;
  
  wVar1 = st->ces_info->gset[1].ccs;
  ccs2 = 0;
  ccs3 = 0;
  map = (wc_uint8 *)0x0;
  uVar2 = st->ces_info->id;
  if (uVar2 == 0x104442) {
    map = wc_c0_tcvn57122_map;
    ccs2 = st->ces_info->gset[2].ccs;
    ccs3 = st->ces_info->gset[3].ccs;
  }
  else if (uVar2 < 0x104443) {
    if (uVar2 == 0x100441) {
      ccs3 = st->ces_info->gset[2].ccs;
    }
  }
  else if (uVar2 == 0x104443) {
    map = wc_c0_viscii112_map;
    ccs2 = st->ces_info->gset[2].ccs;
  }
  else if (uVar2 == 0x104444) {
    map = wc_c0_vps2_map;
    ccs2 = st->ces_info->gset[2].ccs;
  }
  while( true ) {
    if (cc.ccs == wVar1) {
      if (os->area_size <= os->length + 1) {
        Strgrow(os);
      }
      iVar3 = os->length;
      os->ptr[iVar3] = (byte)cc.code | 0x80;
      os->length = iVar3 + 1;
      os->ptr[os->length] = '\0';
      return;
    }
    if (cc.ccs == ccs2) {
      if (os->area_size <= os->length + 1) {
        Strgrow(os);
      }
      iVar3 = os->length;
      os->ptr[iVar3] = (byte)cc.code & 0x7f;
      os->length = iVar3 + 1;
      os->ptr[os->length] = '\0';
      return;
    }
    if (cc.ccs == ccs3) {
      if (os->area_size <= os->length + 1) {
        Strgrow(os);
      }
      iVar3 = os->length;
      os->ptr[iVar3] = (char)(cc.code >> 8);
      os->length = iVar3 + 1;
      os->ptr[os->length] = '\0';
      if (os->area_size <= os->length + 1) {
        Strgrow(os);
      }
      iVar3 = os->length;
      os->ptr[iVar3] = (char)cc.code;
      os->length = iVar3 + 1;
      os->ptr[os->length] = '\0';
      return;
    }
    if (cc.ccs == 0x4000) break;
    if (cc.ccs == 0xc000) {
      if (WcOption.no_replace != '\0') {
        return;
      }
      Strcat_charp(os,WcReplaceW);
      return;
    }
    if (cc.ccs == 0x142) {
      if (((cc.code < 0x20) && (map != (wc_uint8 *)0x0)) && (map[cc.code] != '\0')) {
        if (os->area_size <= os->length + 1) {
          Strgrow(os);
        }
        iVar3 = os->length;
        os->ptr[iVar3] = ' ';
        os->length = iVar3 + 1;
        os->ptr[os->length] = '\0';
        return;
      }
      if (os->area_size <= os->length + 1) {
        Strgrow(os);
      }
      iVar3 = os->length;
      os->ptr[iVar3] = (char)cc.code;
      os->length = iVar3 + 1;
      os->ptr[os->length] = '\0';
      return;
    }
    if (WcOption.ucs_conv == '\0') {
      if ((cc.ccs & 0x18000) == 0) {
        cc.ccs = 0x4000;
      }
      else {
        cc.ccs = 0xc000;
      }
    }
    else {
      wc_any_to_any_ces((wc_wchar_t)CONCAT44(cc.ccs,&cc),(wc_status *)cc.code);
    }
  }
  if (WcOption.no_replace != '\0') {
    return;
  }
  Strcat_charp(os,WcReplace);
  return;
}



Str wc_char_conv_from_viet(wc_uchar c,wc_status *st)

{
  wc_ces wVar1;
  int iVar2;
  Str x;
  wc_uint8 *map;
  Str os;
  
  x = Strnew_size(1);
  map = (wc_uint8 *)0x0;
  wVar1 = st->ces_info->id;
  if (wVar1 == 0x104443) {
    map = wc_c0_viscii112_map;
  }
  else if (wVar1 == 0x104444) {
    map = wc_c0_vps2_map;
  }
  else if (wVar1 == 0x104442) {
    map = wc_c0_tcvn57122_map;
  }
  if ((char)c < '\0') {
    wtf_push(x,st->ces_info->gset[1].ccs,(uint)c);
  }
  else if ((c < 0x20) && (map[c] != '\0')) {
    wtf_push(x,st->ces_info->gset[2].ccs,(uint)c);
  }
  else {
    if (x->area_size <= x->length + 1) {
      Strgrow(x);
    }
    iVar2 = x->length;
    x->ptr[iVar2] = c;
    x->length = iVar2 + 1;
    x->ptr[x->length] = '\0';
  }
  return x;
}



void wtf_init(wc_ces ces1,wc_ces ces2)

{
  wc_gset *pwVar1;
  wc_bool wVar2;
  wc_gset *gset;
  int i;
  
  wVar2 = wc_check_ces(ces2);
  if (wVar2 != '\0') {
    wtf_major_ces = ces2;
  }
  wVar2 = wc_check_ces(ces1);
  if ((((wVar2 != '\0') && (pwVar1 = WcCesInfo[ces1 & 0xff].gset, pwVar1 != (wc_gset *)0x0)) &&
      (pwVar1[1].ccs != 0)) && ((pwVar1[1].ccs & 0x3000) == 0)) {
    wtf_gr_ccs = pwVar1[1].ccs;
    if ((wtf_gr_ccs & 0x18000) == 0) {
      for (i = 0xa1; i < 0x100; i = i + 1) {
        WTF_WIDTH_MAP[i] = '\x01';
        WTF_LEN_MAP[i] = '\x01';
        WTF_TYPE_MAP[i] = '\x02';
      }
    }
    else {
      for (i = 0xa1; i < 0x100; i = i + 1) {
        WTF_WIDTH_MAP[i] = '\x02';
        WTF_LEN_MAP[i] = '\x02';
        WTF_TYPE_MAP[i] = '\n';
      }
    }
  }
  return;
}



int wtf_strwidth(wc_uchar *p)

{
  byte bVar1;
  int w;
  
  w = 0;
  for (; *p != '\0'; p = p + WTF_LEN_MAP[*p]) {
    if (WcOption.use_wide == '\0') {
      bVar1 = WTF_WIDTH_MAP[*p] != '\0';
    }
    else {
      bVar1 = WTF_WIDTH_MAP[*p];
    }
    w = w + (uint)bVar1;
  }
  return w;
}



size_t wtf_len(wc_uchar *p)

{
  wc_uchar *q;
  
  q = p + WTF_LEN_MAP[*p];
  while ((*q != '\0' && (WTF_WIDTH_MAP[*q] == '\0'))) {
    q = q + WTF_LEN_MAP[*q];
  }
  return (int)q - (int)p;
}



void wtf_push(Str os,wc_ccs ccs,wc_uint32 code)

{
  int iVar1;
  int iVar2;
  byte bVar3;
  wc_bool wVar4;
  wc_bool wVar5;
  byte bVar6;
  uint uVar7;
  byte bVar8;
  int in_GS_OFFSET;
  uint local_4c;
  wc_uint32 local_48;
  Str local_40;
  wc_wchar_t cc2;
  wc_wchar_t cc;
  size_t n;
  wc_bool fix_width_conv;
  wc_uchar s [8];
  
  wVar5 = WcOption.fix_width_conv;
  local_40 = os;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if (ccs == 0x142) {
    if (os->area_size <= os->length + 1) {
      Strgrow(os);
    }
    iVar2 = local_40->length;
    local_40->ptr[iVar2] = (byte)code & 0x7f;
    local_40->length = iVar2 + 1;
    local_40->ptr[local_40->length] = '\0';
    goto LAB_080c30bc;
  }
  cc.ccs = ccs;
  cc.code = code;
  if ((WcOption.pre_conv != '\0') && ((ccs & 0x4000) == 0)) {
    if (((ccs == 0x880f) || (((ccs == 0x8810 || (ccs == 0x8811)) || (ccs == 0x8812)))) &&
       ((wtf_major_ces == 0x301019 || (wtf_major_ces == 0x200815)))) {
      wc_johab_to_ksx1001((wc_wchar_t)CONCAT44(ccs,&cc2));
      wVar5 = WcOption.fix_width_conv;
      if ((cc2.ccs & 0x4000) == 0) {
        cc.ccs = cc2.ccs;
        cc.code = cc2.code;
      }
    }
    else if ((ccs == 0x8143) && (wtf_major_ces == 0x302040)) {
      wc_ksx1001_to_johab((wc_wchar_t)CONCAT44(0x8143,&local_4c));
      cc2.ccs = local_4c;
      cc2.code = local_48;
      wVar5 = WcOption.fix_width_conv;
      if ((local_4c & 0x4000) == 0) {
        cc.ccs = local_4c;
        cc.code = local_48;
      }
    }
    else if (WcOption.ucs_conv != '\0') {
      WcOption.fix_width_conv = '\0';
      wc_output_init(wtf_major_ces,&wtf_major_st);
      wVar4 = wc_ces_has_ccs(ccs & 0xffff,&wtf_major_st);
      if (wVar4 == '\0') {
        wc_any_to_any_ces((wc_wchar_t)CONCAT44(cc.ccs,&local_4c),(wc_status *)cc.code);
        cc2.ccs = local_4c;
        cc2.code = local_48;
        if (local_4c == 0x142) {
          if (local_40->area_size <= local_40->length + 1) {
            Strgrow(local_40);
          }
          iVar2 = local_40->length;
          local_40->ptr[iVar2] = (byte)cc2.code & 0x7f;
          local_40->length = iVar2 + 1;
          local_40->ptr[local_40->length] = '\0';
          goto LAB_080c30bc;
        }
        if ((((local_4c & 0x4000) == 0) && (local_4c != 0x81c)) && (local_4c != 0x81f)) {
          cc.ccs = local_4c;
          cc.code = local_48;
        }
      }
    }
  }
  WcOption.fix_width_conv = wVar5;
  uVar7 = cc.ccs & 0xff00;
  bVar3 = (byte)cc.code;
  if (uVar7 == 0x1000) {
    if ((cc.ccs & 0x18000) == 0) {
      bVar8 = 0x88;
    }
    else {
      bVar8 = 0x89;
    }
    if ((cc.ccs & 0x20000) == 0) {
      bVar6 = 0;
    }
    else {
      bVar6 = 0x10;
    }
    s[0] = bVar6 | bVar8;
    s[2] = (byte)(cc.code >> 7) | 0x80;
    s[3] = bVar3 | 0x80;
    s[1] = (byte)(cc.code >> 0xe) & 3 | 0x80 | (byte)(cc.ccs << 2);
    n = 4;
  }
  else {
    bVar8 = (byte)cc.ccs;
    if (uVar7 < 0x1001) {
      if (uVar7 == 0x200) {
        if ((WcOption.use_combining == '\0') ||
           (wVar5 = wc_is_combining((wc_wchar_t)CONCAT44(cc.code,cc.ccs)), wVar5 == '\0')) {
          if ((cc.ccs == wtf_gr_ccs) && (0x20 < (cc.code & 0x7f))) {
            s[0] = (byte)cc.code | 0x80;
            n = 1;
            goto LAB_080c30a3;
          }
          s[0] = 0x82;
        }
        else {
          s[0] = 0x92;
        }
        s[1] = (byte)cc.ccs | 0x80;
        s[2] = (byte)cc.code | 0x80;
        n = 3;
      }
      else if (uVar7 < 0x201) {
        if (uVar7 == 0x100) {
          if (cc.ccs == wtf_gr_ccs) {
            s[0] = bVar3 | 0x80;
            n = 1;
          }
          else {
            if ((cc.ccs == 0x149) && (WcOption.use_jisx0201k == '\0')) {
              wc_jisx0201k_to_jisx0208((wc_wchar_t)CONCAT44(0x149,&local_4c));
              cc2.ccs = local_4c;
              cc2.code = local_48;
              if ((local_4c & 0x4000) == 0) {
                wtf_push(local_40,local_4c,local_48);
                goto LAB_080c30bc;
              }
            }
            s[0] = 0x80;
            s[1] = (byte)cc.ccs | 0x80;
            s[2] = (byte)cc.code | 0x80;
            n = 3;
          }
        }
        else {
LAB_080c3086:
          s[0] = 0x85;
          s[1] = bVar8 | 0x80;
          s[2] = bVar3 | 0x80;
          n = 3;
        }
      }
      else if (uVar7 == 0x400) {
        if (cc.ccs == wtf_gr_ccs) {
          s[0] = bVar3 | 0x80;
          n = 1;
        }
        else {
          s[0] = 0x84;
          s[1] = bVar8 | 0x80;
          s[2] = bVar3 | 0x80;
          n = 3;
        }
      }
      else {
        if (uVar7 != 0x800) goto LAB_080c3086;
        if ((WcOption.use_combining == '\0') ||
           (wVar5 = wc_is_combining((wc_wchar_t)CONCAT44(cc.code,cc.ccs)), wVar5 == '\0')) {
          if ((cc.ccs == wtf_gr_ccs) && (0x20 < (cc.code & 0x7f))) {
            s[0] = (byte)cc.code | 0x80;
            n = 1;
            goto LAB_080c30a3;
          }
          s[0] = 0x86;
        }
        else {
          s[0] = 0x96;
        }
        s[1] = (byte)cc.ccs | 0x80;
        s[2] = (byte)cc.code | 0x80;
        n = 3;
      }
    }
    else {
      bVar6 = (byte)(cc.code >> 8);
      if (uVar7 == 0x8100) {
        if (cc.ccs == wtf_gr_ccs) {
          s[0] = bVar6 | 0x80;
          s[1] = bVar3 | 0x80;
          n = 2;
        }
        else {
          s[0] = 0x81;
          s[1] = bVar8 | 0x80;
          s[2] = bVar6 | 0x80;
          s[3] = bVar3 | 0x80;
          n = 4;
        }
      }
      else if (uVar7 < 0x8101) {
        if (uVar7 != 0x2000) goto LAB_080c3086;
        if ((cc.ccs & 0x18000) == 0) {
          bVar8 = 0x8a;
        }
        else {
          bVar8 = 0x8b;
        }
        if ((cc.ccs & 0x20000) == 0) {
          bVar6 = 0;
        }
        else {
          bVar6 = 0x10;
        }
        s[0] = bVar6 | bVar8;
        s[2] = (byte)(cc.code >> 0x15) | 0x80;
        s[3] = (byte)(cc.code >> 0xe) | 0x80;
        s[4] = (byte)(cc.code >> 7) | 0x80;
        s[5] = bVar3 | 0x80;
        s[1] = (byte)(cc.code >> 0x1c) | 0x80 | (byte)(cc.ccs << 4);
        n = 6;
      }
      else if (uVar7 == 0x8200) {
        if ((cc.ccs == wtf_gr_ccs) && (0x20 < (cc.code >> 8 & 0x7f))) {
          s[0] = bVar6 | 0x80;
          s[1] = bVar3 | 0x80;
          n = 2;
        }
        else {
          s[0] = 0x83;
          s[1] = bVar8 | 0x80;
          s[2] = bVar6 | 0x80;
          s[3] = bVar3 | 0x80;
          n = 4;
        }
      }
      else {
        if (uVar7 != 0x8800) goto LAB_080c3086;
        switch(cc.ccs) {
        case 0x8801:
          wc_big5_to_cs94w((wc_wchar_t)CONCAT44(cc.ccs,&local_4c));
          cc.ccs = local_4c;
          cc.code = local_48;
          break;
        case 0x880f:
          wc_johab_to_cs128w((wc_wchar_t)CONCAT44(cc.ccs,&local_4c));
          cc.ccs = local_4c;
          cc.code = local_48;
          break;
        case 0x8813:
          wc_sjis_ext_to_cs94w((wc_wchar_t)CONCAT44(cc.ccs,&cc));
          break;
        case 0x8816:
          wc_gbk_to_cs128w((wc_wchar_t)CONCAT44(cc.ccs,&local_4c));
          cc.ccs = local_4c;
          cc.code = local_48;
          break;
        case 0x8819:
          wc_gbk_ext_to_cs128w((wc_wchar_t)CONCAT44(cc.ccs,&local_4c));
          cc.ccs = local_4c;
          cc.code = local_48;
          break;
        case 0x881c:
          wc_uhc_to_cs128w((wc_wchar_t)CONCAT44(cc.ccs,&local_4c));
          cc.ccs = local_4c;
          cc.code = local_48;
          break;
        case 0x881f:
          wc_hkscs_to_cs128w((wc_wchar_t)CONCAT44(cc.ccs,&local_4c));
          cc.ccs = local_4c;
          cc.code = local_48;
        }
        bVar3 = (byte)(cc.code >> 8);
        if ((cc.ccs == wtf_gr_ccs) && (0x20 < (cc.code >> 8 & 0x7f))) {
          s[0] = bVar3 | 0x80;
          s[1] = (byte)cc.code | 0x80;
          n = 2;
        }
        else {
          s[0] = 0x87;
          s[1] = (byte)cc.ccs | 0x80;
          s[2] = bVar3 | 0x80;
          s[3] = (byte)cc.code | 0x80;
          n = 4;
        }
      }
    }
  }
LAB_080c30a3:
  Strcat_charp_n(local_40,(char *)s,n);
LAB_080c30bc:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



void wtf_push_unknown(Str os,wc_uchar *p,size_t len)

{
  int iVar1;
  bool bVar2;
  
  while (bVar2 = len != 0, len = len - 1, bVar2) {
    if ((char)*p < '\0') {
      wtf_push(os,0x4000,(uint)*p);
    }
    else {
      if (os->area_size <= os->length + 1) {
        Strgrow(os);
      }
      iVar1 = os->length;
      os->ptr[iVar1] = *p;
      os->length = iVar1 + 1;
      os->ptr[os->length] = '\0';
    }
    p = p + 1;
  }
  return;
}



wc_wchar_t wtf_parse1(wc_uchar **p)

{
  byte *pbVar1;
  uint uVar2;
  uint uVar3;
  wc_wchar_t wVar4;
  byte **in_stack_00000008;
  wc_wchar_t cc;
  wc_uchar *q;
  
  pbVar1 = *in_stack_00000008;
  if (-1 < (char)*pbVar1) {
    cc.ccs = 0x142;
    cc.code = (wc_uint32)*pbVar1;
    q = pbVar1 + 1;
    goto LAB_080c3401;
  }
  if (0xa0 < *pbVar1) {
    cc.ccs = wtf_gr_ccs;
    if ((wtf_gr_ccs & 0x18000) == 0) {
      cc.code = (wc_uint32)*pbVar1;
      q = pbVar1 + 1;
    }
    else {
      cc.code = (wc_uint32)CONCAT11(*pbVar1,pbVar1[1]);
      q = pbVar1 + 2;
    }
    goto LAB_080c3401;
  }
  uVar2 = (uint)*(ushort *)(WTF_TYPE_MAP + (uint)*pbVar1 * 2) << 8;
  q = pbVar1 + 1;
  uVar3 = uVar2 & 0xff00;
  if (uVar3 == 0x2000) {
LAB_080c3378:
    cc.ccs = (int)(*q & 0x70) >> 4 | uVar2;
    cc.code = pbVar1[5] & 0x7f |
              (uint)*q << 0x1c | (pbVar1[2] & 0x7f) << 0x15 | (pbVar1[3] & 0x7f) << 0xe |
              (pbVar1[4] & 0x7f) << 7;
    q = pbVar1 + 6;
    goto LAB_080c3401;
  }
  if (0x2000 < uVar3) {
    if (uVar3 != 0x8200) {
      if (uVar3 < 0x8201) {
        if (uVar3 == 0x4000) goto LAB_080c32b4;
        if (uVar3 != 0x8100) goto LAB_080c33f3;
      }
      else {
        if (uVar3 == 0x11000) {
LAB_080c3321:
          cc.ccs = (int)(*q & 0x7c) >> 2 | uVar2;
          cc.code = pbVar1[3] & 0x7f | (*q & 3) << 0xe | (pbVar1[2] & 0x7f) << 7;
          q = pbVar1 + 4;
          goto LAB_080c3401;
        }
        if (uVar3 == 0x12000) goto LAB_080c3378;
        if (uVar3 != 0x8800) goto LAB_080c33f3;
      }
    }
    cc.ccs = *q & 0x7f | uVar2;
    cc.code = (wc_uint32)CONCAT11(pbVar1[2],pbVar1[3]);
    q = pbVar1 + 4;
    goto LAB_080c3401;
  }
  if (uVar3 == 0x400) {
LAB_080c32b4:
    cc.ccs = *q & 0x7f | uVar2;
    cc.code = (wc_uint32)pbVar1[2];
    q = pbVar1 + 3;
  }
  else {
    if (uVar3 < 0x401) {
      if ((uVar3 == 0x100) || (uVar3 == 0x200)) goto LAB_080c32b4;
    }
    else {
      if (uVar3 == 0x800) goto LAB_080c32b4;
      if (uVar3 == 0x1000) goto LAB_080c3321;
    }
LAB_080c33f3:
    cc.ccs = 0x142;
    cc.code = 0x20;
  }
LAB_080c3401:
  *in_stack_00000008 = q;
  switch(cc.ccs) {
  case 0x8802:
  case 0x8803:
    wVar4 = wc_cs94w_to_big5((wc_wchar_t)CONCAT44(cc.ccs,p));
    cc.code = (wc_uint32)((ulonglong)wVar4 >> 0x20);
    break;
  default:
    *p = (wc_uchar *)cc.ccs;
    p[1] = (wc_uchar *)cc.code;
    break;
  case 0x8810:
  case 0x8811:
  case 0x8812:
    wVar4 = wc_cs128w_to_johab((wc_wchar_t)CONCAT44(cc.ccs,p));
    cc.code = (wc_uint32)((ulonglong)wVar4 >> 0x20);
    break;
  case 0x8814:
  case 0x8815:
    wVar4 = wc_cs94w_to_sjis_ext((wc_wchar_t)CONCAT44(cc.ccs,p));
    cc.code = (wc_uint32)((ulonglong)wVar4 >> 0x20);
    break;
  case 0x8817:
  case 0x8818:
    wVar4 = wc_cs128w_to_gbk((wc_wchar_t)CONCAT44(cc.ccs,p));
    cc.code = (wc_uint32)((ulonglong)wVar4 >> 0x20);
    break;
  case 0x881a:
  case 0x881b:
    wVar4 = wc_cs128w_to_gbk_ext((wc_wchar_t)CONCAT44(cc.ccs,p));
    cc.code = (wc_uint32)((ulonglong)wVar4 >> 0x20);
    break;
  case 0x881d:
  case 0x881e:
    wVar4 = wc_cs128w_to_uhc((wc_wchar_t)CONCAT44(cc.ccs,p));
    cc.code = (wc_uint32)((ulonglong)wVar4 >> 0x20);
    break;
  case 0x8820:
  case 0x8821:
    wVar4 = wc_cs128w_to_hkscs((wc_wchar_t)CONCAT44(cc.ccs,p));
    cc.code = (wc_uint32)((ulonglong)wVar4 >> 0x20);
  }
  return (wc_wchar_t)CONCAT44(cc.code,p);
}



// WARNING: Type propagation algorithm not settling

wc_wchar_t wtf_parse(wc_uchar **p)

{
  byte *pbVar1;
  wc_uchar *pwVar2;
  uint ucs1;
  wc_uint32 ucs_00;
  byte **in_stack_00000008;
  wc_uchar *local_34;
  wc_uint32 local_30;
  wc_wchar_t cc2;
  wc_wchar_t cc;
  wc_uint32 ucs2;
  wc_uint32 ucs;
  wc_uchar *q;
  
  if ((char)**in_stack_00000008 < '\0') {
    wtf_parse1((wc_uchar **)&cc);
  }
  else {
    cc.ccs = 0x142;
    cc.code = (wc_uint32)**in_stack_00000008;
    *in_stack_00000008 = *in_stack_00000008 + 1;
  }
  if ((WcOption.use_combining == '\0') || (WTF_WIDTH_MAP[**in_stack_00000008] != '\0')) {
    *p = (wc_uchar *)cc.ccs;
    p[1] = (wc_uchar *)cc.code;
    pwVar2 = (wc_uchar *)cc.code;
  }
  else {
    pbVar1 = *in_stack_00000008;
    wtf_parse1((wc_uchar **)&cc2);
    if (((cc.ccs == 0x142) || (cc.ccs == 0x81b)) && ((cc2.ccs & 0xffff) == 0x81b)) {
      pwVar2 = (wc_uchar *)wc_cp1258_precompose((wc_uchar)cc.code,(wc_uchar)cc2.code);
      if (pwVar2 != (wc_uchar *)0x0) {
        *in_stack_00000008 = pbVar1;
        *p = (wc_uchar *)0x81c;
        p[1] = pwVar2;
        goto LAB_080c37fe;
      }
    }
    else if (((cc.ccs == 0x142) || (cc.ccs == 0x81d)) && ((cc2.ccs & 0xffff) == 0x81d)) {
      pwVar2 = (wc_uchar *)wc_tcvn5712_precompose((wc_uchar)cc.code,(wc_uchar)cc2.code);
      if (pwVar2 != (wc_uchar *)0x0) {
        *in_stack_00000008 = pbVar1;
        *p = (wc_uchar *)0x81f;
        p[1] = pwVar2;
        goto LAB_080c37fe;
      }
    }
    else if (((cc.ccs == 0x142) || (cc.ccs == 0x241)) ||
            (((cc.ccs & 0xffff) == 0x1000 ||
             (((cc.ccs & 0xffff) == 0x2000 || ((cc.ccs & 0xffff) == 0x2001)))))) {
      while (((cc2.ccs & 0xffff) == 0x1000 ||
             (((cc2.ccs & 0xffff) == 0x2000 || ((cc2.ccs & 0xffff) == 0x2001))))) {
        ucs1 = cc.code;
        if ((cc.ccs & 0xffff) == 0x2001) {
          ucs1 = cc.code & 0x1fffff;
        }
        if ((cc2.ccs & 0xffff) == 0x2001) {
          cc2.code = cc2.code & 0x1fffff;
        }
        ucs_00 = wc_ucs_precompose(ucs1,cc2.code);
        if (ucs_00 == 0xffffffff) break;
        if ((cc.ccs & 0xffff) == 0x2001) {
          cc.code = cc.code & 0xff000000 | ucs_00;
        }
        else {
          cc.ccs = wc_ucs_to_ccs(ucs_00);
          cc.code = ucs_00;
        }
        *in_stack_00000008 = pbVar1;
        if (WTF_WIDTH_MAP[*pbVar1] == '\0') break;
        wtf_parse1(&local_34);
        cc2.ccs = (wc_ccs)local_34;
        cc2.code = local_30;
      }
    }
    *p = (wc_uchar *)cc.ccs;
    p[1] = (wc_uchar *)cc.code;
    pwVar2 = (wc_uchar *)cc.code;
  }
LAB_080c37fe:
  return (wc_wchar_t)CONCAT44(pwVar2,p);
}



wc_ccs wtf_get_ccs(wc_uchar *p)

{
  wc_uchar *local_14 [4];
  
  wtf_parse1(local_14);
  return (wc_ccs)local_14[0];
}



wc_uint32 wtf_get_code(wc_uchar *p)

{
  wc_uchar *local_14;
  wc_uint32 local_10;
  
  wtf_parse1(&local_14);
  return local_10;
}



wc_bool wtf_is_hangul(wc_uchar *p)

{
  byte bVar1;
  wc_bool wVar2;
  bool bVar3;
  wc_uchar f_2;
  wc_uchar f_1;
  wc_uchar f;
  
  if (*p < 0xa1) {
    if (*p == 0x81) {
      bVar3 = (p[1] & 0x7f) == 0x43;
    }
    else if (*p == 0x87) {
      bVar1 = p[1] & 0x7f;
      if ((((bVar1 == 0x10) || (bVar1 == 0x11)) || (bVar1 == 0x12)) ||
         ((bVar1 == 0x1d || (bVar1 == 0x1e)))) {
        bVar3 = true;
      }
      else {
        bVar3 = false;
      }
    }
    else {
      if (*p == 0x89) {
        if ((char)((int)(p[1] & 0x7f) >> 2) == '\0') {
          wVar2 = wc_is_ucs_hangul(p[3] & 0x7f | (p[1] & 3) << 0xe | (p[2] & 0x7f) << 7);
          return wVar2;
        }
      }
      else if ((*p == 0x8b) && ((char)((int)(p[1] & 0x7f) >> 4) == '\x01')) {
        wVar2 = wc_is_ucs_hangul(p[5] & 0x7f | (p[3] & 0x7f) << 0xe | (p[4] & 0x7f) << 7);
        return wVar2;
      }
      bVar3 = false;
    }
  }
  else if ((wtf_gr_ccs == 0x8143) || (wtf_gr_ccs == 0x8810)) {
    bVar3 = true;
  }
  else {
    bVar3 = false;
  }
  return bVar3;
}



char * wtf_conv_fit(char *s,wc_ces ces)

{
  wc_bool wVar1;
  wc_bool wVar2;
  wc_ces wVar3;
  size_t n;
  Str x;
  wc_wchar_t cc;
  wc_ces major_ces;
  Str os;
  wc_uchar *p;
  wc_bool ucs_conv;
  wc_bool pre_conv;
  
  if ((ces != 0x310000) && (ces != 0x100)) {
    for (p = (wc_uchar *)s; (*p != '\0' && (-1 < (char)*p)); p = p + 1) {
    }
    if (*p != '\0') {
      n = strlen(s);
      x = Strnew_size(n);
      if (s < p) {
        Strcopy_charp_n(x,s,(int)p - (int)s);
      }
      wVar3 = wtf_major_ces;
      wVar2 = WcOption.pre_conv;
      wVar1 = WcOption.ucs_conv;
      wtf_major_ces = ces;
      WcOption.pre_conv = '\x01';
      WcOption.ucs_conv = '\x01';
      while (*p != '\0') {
        wtf_parse1((wc_uchar **)&cc);
        wtf_push(x,cc.ccs,cc.code);
      }
      s = x->ptr;
      WcOption.ucs_conv = wVar1;
      WcOption.pre_conv = wVar2;
      wtf_major_ces = wVar3;
    }
  }
  return s;
}



wc_wchar_t wc_big5_to_cs94w(wc_wchar_t cc)

{
  int iVar1;
  wc_uint32 wVar2;
  uint in_stack_0000000c;
  
  if ((in_stack_0000000c & 0xff) < 0xa1) {
    iVar1 = 0x40;
  }
  else {
    iVar1 = 0x62;
  }
  iVar1 = ((in_stack_0000000c >> 8 & 0xff) * 0x9d + (in_stack_0000000c & 0xff)) - iVar1;
  in_stack_0000000c = iVar1 - 0x62bd;
  if (in_stack_0000000c < 0x1888) {
    cc.code = 0x8802;
  }
  else {
    cc.code = 0x8803;
    in_stack_0000000c = iVar1 - 0x7b45;
  }
  wVar2 = (in_stack_0000000c / 0x5e + 0x21) * 0x100 + in_stack_0000000c % 0x5e + 0x21;
  *(wc_uint32 *)cc.ccs = cc.code;
  *(wc_uint32 *)(cc.ccs + 4) = wVar2;
  return (wc_wchar_t)CONCAT44(wVar2,cc.ccs);
}



wc_wchar_t wc_cs94w_to_big5(wc_wchar_t cc)

{
  uint uVar1;
  int iVar2;
  uint in_stack_0000000c;
  
  iVar2 = (in_stack_0000000c >> 8 & 0x7f) * 0x5e + (in_stack_0000000c & 0x7f);
  in_stack_0000000c = iVar2 - 0xc3f;
  if (cc.code == 0x8803) {
    in_stack_0000000c = iVar2 + 0xc49;
  }
  if (in_stack_0000000c % 0x9d < 0x3f) {
    iVar2 = 0x40;
  }
  else {
    iVar2 = 0x62;
  }
  uVar1 = (in_stack_0000000c / 0x9d + 0xa1) * 0x100 + in_stack_0000000c % 0x9d + iVar2;
  *(undefined4 *)cc.ccs = 0x8801;
  *(uint *)(cc.ccs + 4) = uVar1;
  return (wc_wchar_t)(cc & 0xffffffff | (ulonglong)uVar1 << 0x20);
}



Str wc_conv_from_big5(Str is,wc_ces ces)

{
  wc_uchar *pwVar1;
  int iVar2;
  bool bVar3;
  wc_uchar *pwVar4;
  Str x;
  int state;
  wc_uchar *p;
  wc_uchar *ep;
  wc_uchar *sp;
  Str os;
  
  pwVar1 = (wc_uchar *)is->ptr;
  pwVar4 = pwVar1 + is->length;
  bVar3 = false;
  for (p = pwVar1; (p < pwVar4 && (-1 < (char)*p)); p = p + 1) {
  }
  if (p != pwVar4) {
    x = Strnew_size(is->length);
    if (pwVar1 < p) {
      Strcat_charp_n(x,is->ptr,(int)p - (int)pwVar1);
    }
    for (; p < pwVar4; p = p + 1) {
      if (bVar3) {
        if (bVar3) {
          if ((WC_BIG5_MAP[*p] & 4) == 0) {
            wtf_push_unknown(x,p + -1,2);
          }
          else {
            wtf_push(x,0x8801,(uint)CONCAT11(p[-1],*p));
          }
          bVar3 = false;
        }
      }
      else if (WC_BIG5_MAP[*p] == '\x02') {
        wtf_push_unknown(x,p,1);
      }
      else if (WC_BIG5_MAP[*p] == '\a') {
        bVar3 = true;
      }
      else {
        if (x->area_size <= x->length + 1) {
          Strgrow(x);
        }
        iVar2 = x->length;
        x->ptr[iVar2] = *p;
        x->length = iVar2 + 1;
        x->ptr[x->length] = '\0';
      }
    }
    is = x;
    if (bVar3) {
      wtf_push_unknown(x,p + -1,1);
    }
  }
  return is;
}



void wc_push_to_big5(Str os,wc_wchar_t cc,wc_status *st)

{
  int iVar1;
  wc_ccs local_14;
  wc_uint32 local_10;
  
  do {
    if (cc.ccs == 0x8801) {
LAB_080c3f52:
      if (os->area_size <= os->length + 1) {
        Strgrow(os);
      }
      iVar1 = os->length;
      os->ptr[iVar1] = (char)(cc.code >> 8);
      os->length = iVar1 + 1;
      os->ptr[os->length] = '\0';
      if (os->area_size <= os->length + 1) {
        Strgrow(os);
      }
      iVar1 = os->length;
      os->ptr[iVar1] = (char)cc.code;
      os->length = iVar1 + 1;
      os->ptr[os->length] = '\0';
      return;
    }
    if (cc.ccs < 0x8802) {
      if (cc.ccs == 0x142) {
        if (os->area_size <= os->length + 1) {
          Strgrow(os);
        }
        iVar1 = os->length;
        os->ptr[iVar1] = (char)cc.code;
        os->length = iVar1 + 1;
        os->ptr[os->length] = '\0';
        return;
      }
      if (cc.ccs == 0x4000) {
        if (WcOption.no_replace != '\0') {
          return;
        }
        Strcat_charp(os,WcReplace);
        return;
      }
    }
    else {
      if (cc.ccs < 0x8804) {
        wc_cs94w_to_big5((wc_wchar_t)CONCAT44(cc.ccs,&cc));
        goto LAB_080c3f52;
      }
      if (cc.ccs == 0xc000) {
        if (WcOption.no_replace != '\0') {
          return;
        }
        Strcat_charp(os,WcReplaceW);
        return;
      }
    }
    if (WcOption.ucs_conv == '\0') {
      if ((cc.ccs & 0x18000) == 0) {
        cc.ccs = 0x4000;
      }
      else {
        cc.ccs = 0xc000;
      }
    }
    else {
      wc_any_to_any_ces((wc_wchar_t)CONCAT44(cc.ccs,&local_14),(wc_status *)cc.code);
      cc.ccs = local_14;
      cc.code = local_10;
    }
  } while( true );
}



Str wc_char_conv_from_big5(wc_uchar c,wc_status *st)

{
  int iVar1;
  Str p_Var2;
  
  if (st->state == -1) {
    st->state = 0;
    wc_char_conv_from_big5::os = Strnew_size(8);
  }
  if (st->state == 0) {
    if (WC_BIG5_MAP[c] != '\x02') {
      if (WC_BIG5_MAP[c] == '\a') {
        wc_char_conv_from_big5::big5u = c;
        st->state = 1;
        return (Str)0x0;
      }
      if (wc_char_conv_from_big5::os->area_size <= wc_char_conv_from_big5::os->length + 1) {
        Strgrow(wc_char_conv_from_big5::os);
      }
      p_Var2 = wc_char_conv_from_big5::os;
      iVar1 = wc_char_conv_from_big5::os->length;
      wc_char_conv_from_big5::os->ptr[iVar1] = c;
      p_Var2->length = iVar1 + 1;
      wc_char_conv_from_big5::os->ptr[wc_char_conv_from_big5::os->length] = '\0';
    }
  }
  else if ((st->state == 1) && ((WC_BIG5_MAP[c] & 4) != 0)) {
    wtf_push(wc_char_conv_from_big5::os,0x8801,(uint)CONCAT11(wc_char_conv_from_big5::big5u,c));
  }
  st->state = -1;
  return wc_char_conv_from_big5::os;
}



wc_bool wc_is_combining(wc_wchar_t cc)

{
  wc_bool wVar1;
  uint uVar2;
  
  uVar2 = cc.ccs & 0xffff;
  if (uVar2 == 0x819) {
    return cp1256_combining_map[cc.code & 0x7f];
  }
  if (uVar2 < 0x81a) {
    if (uVar2 == 0x80d) {
      return cp864_combining_map[cc.code & 0x7f];
    }
    if (uVar2 < 0x80e) {
      if (uVar2 == 0x247) {
        return iso88596_combining_map[cc.code & 0x7f];
      }
      if (uVar2 == 0x254) {
        return iso885911_combining_map[cc.code & 0x7f];
      }
    }
    else {
      if (uVar2 == 0x811) {
        return cp874_combining_map[cc.code & 0x7f];
      }
      if (uVar2 == 0x818) {
        return cp1255_combining_map[cc.code & 0x7f];
      }
    }
  }
  else {
    if (uVar2 == 0x1000) {
LAB_080c42dd:
      wVar1 = wc_is_ucs_combining(cc.code);
      return wVar1;
    }
    if (uVar2 < 0x1001) {
      if (uVar2 == 0x81b) {
        return cp1258_combining_map[cc.code & 0x7f];
      }
      if (uVar2 == 0x81d) {
        return tcvn5712_combining_map[cc.code & 0x7f];
      }
    }
    else if (uVar2 - 0x2000 < 2) goto LAB_080c42dd;
  }
  return '\0';
}



wc_wchar_t wc_gbk_ext_to_cs128w(wc_wchar_t cc)

{
  wc_uint32 wVar1;
  int iVar2;
  uint in_stack_0000000c;
  
  if ((in_stack_0000000c & 0xff) < 0x80) {
    iVar2 = 0x40;
  }
  else {
    iVar2 = 0x41;
  }
  iVar2 = ((in_stack_0000000c >> 8 & 0xff) * 0xbe + (in_stack_0000000c & 0xff)) - iVar2;
  in_stack_0000000c = iVar2 - 0x5fbe;
  if (in_stack_0000000c < 0x4000) {
    cc.code = 0x881a;
  }
  else {
    cc.code = 0x881b;
    in_stack_0000000c = iVar2 - 0x9fbe;
  }
  wVar1 = (in_stack_0000000c >> 7) * 0x100 + (in_stack_0000000c & 0x7f);
  *(wc_uint32 *)cc.ccs = cc.code;
  *(wc_uint32 *)(cc.ccs + 4) = wVar1;
  return (wc_wchar_t)CONCAT44(wVar1,cc.ccs);
}



wc_wchar_t wc_cs128w_to_gbk_ext(wc_wchar_t cc)

{
  uint uVar1;
  int iVar2;
  uint in_stack_0000000c;
  
  in_stack_0000000c = (in_stack_0000000c >> 8 & 0x7f) * 0x80 + (in_stack_0000000c & 0x7f);
  if (cc.code == 0x881b) {
    in_stack_0000000c = in_stack_0000000c + 0x4000;
  }
  if (in_stack_0000000c + ((in_stack_0000000c >> 1) / 0x5f) * -0xbe < 0x3f) {
    iVar2 = 0x40;
  }
  else {
    iVar2 = 0x41;
  }
  uVar1 = ((in_stack_0000000c >> 1) / 0x5f + 0x81) * 0x100 +
          in_stack_0000000c + ((in_stack_0000000c >> 1) / 0x5f) * -0xbe + iVar2;
  *(undefined4 *)cc.ccs = 0x8819;
  *(uint *)(cc.ccs + 4) = uVar1;
  return (wc_wchar_t)(cc & 0xffffffff | (ulonglong)uVar1 << 0x20);
}



wc_ccs wc_gbk_or_gbk_ext(wc_uint16 code)

{
  wc_map3 *pwVar1;
  wc_ccs wVar2;
  
  pwVar1 = wc_map3_range_search(code,gbk_ext_ucs_map,0x6e);
  if (pwVar1 == (wc_map3 *)0x0) {
    wVar2 = 0x8816;
  }
  else {
    wVar2 = 0x8819;
  }
  return wVar2;
}



wc_uint32 wc_gb18030_to_ucs(wc_wchar_t cc)

{
  uint uVar1;
  wc_map3 *pwVar2;
  int iVar3;
  int iVar4;
  wc_uint32 wVar5;
  int max;
  int min;
  int i;
  wc_map3 *map;
  
  uVar1 = cc.ccs & 0xffff;
  if (uVar1 == 0x8819) {
LAB_080c44fb:
    pwVar2 = wc_map3_range_search((wc_uint16)cc.code,gbk_ext_ucs_map,0x6e);
    if (pwVar2 == (wc_map3 *)0x0) {
      wVar5 = 0xffffffff;
    }
    else {
      if ((cc.code & 0xff) < 0x80) {
        iVar3 = 0x40;
      }
      else {
        iVar3 = 0x41;
      }
      if ((pwVar2->code2 & 0xff) < 0x80) {
        iVar4 = 0x40;
      }
      else {
        iVar4 = 0x41;
      }
      wVar5 = (uint)pwVar2->code3 + (((cc.code >> 8 & 0xff) * 0xbe + (cc.code & 0xff)) - iVar3) +
              iVar4 + ((uint)(pwVar2->code2 >> 8) * -0xbe - (pwVar2->code2 & 0xff));
    }
  }
  else {
    if (uVar1 < 0x881a) {
      if (uVar1 == 0x2002) {
        if ((cc.code < 0x81308130) || (0x8431a439 < cc.code)) {
          if ((0x9030812f < cc.code) && (cc.code < 0xe3329a36)) {
            return ((((cc.code >> 0x18) * 10 + (cc.code >> 0x10 & 0xff)) * 0x7e +
                    (cc.code >> 8 & 0xff)) * 10 + (cc.code & 0xff)) - 0x1ba0fa;
          }
          return 0xffffffff;
        }
        min = 0;
        max = 0xcd;
        uVar1 = ((((cc.code >> 0x18) * 10 + (cc.code >> 0x10 & 0xff)) * 0x7e + (cc.code >> 8 & 0xff)
                 ) * 10 + (cc.code & 0xff)) - 0x19beb2;
        if (uVar1 < ucs_gb18030_map[205].code3) {
          while (i = (min + max) / 2, min != max) {
            if (uVar1 < ucs_gb18030_map[i].code3) {
              max = i + -1;
            }
            else {
              if (uVar1 < ucs_gb18030_map[i + 1].code3) break;
              min = i + 1;
            }
          }
        }
        else {
          i = 0xcd;
        }
        return (ucs_gb18030_map[i].code + uVar1) - (uint)ucs_gb18030_map[i].code3;
      }
    }
    else if (uVar1 < 0x881c) {
      wc_cs128w_to_gbk_ext((wc_wchar_t)CONCAT44(cc.ccs,&cc));
      goto LAB_080c44fb;
    }
    wVar5 = wc_any_to_ucs(cc);
  }
  return wVar5;
}



wc_wchar_t wc_ucs_to_gb18030(wc_uint32 ucs)

{
  wc_map3 *pwVar1;
  int iVar2;
  wc_ccs wVar3;
  uint uVar4;
  uint in_stack_00000008;
  wc_wchar_t cc;
  wc_map3 *map;
  
  if (in_stack_00000008 < 0x10000) {
    pwVar1 = wc_map3_range_search((wc_uint16)in_stack_00000008,ucs_gbk_ext_map,0x6e);
    if (pwVar1 != (wc_map3 *)0x0) {
      if ((pwVar1->code3 & 0xff) < 0x80) {
        iVar2 = 0x40;
      }
      else {
        iVar2 = 0x41;
      }
      uVar4 = ((((uint)(pwVar1->code3 >> 8) * 0xbe + -0x5fbe + (pwVar1->code3 & 0xff)) - iVar2) +
              in_stack_00000008) - (uint)pwVar1->code;
      if (uVar4 + ((uVar4 >> 1) / 0x5f) * -0xbe < 0x3f) {
        iVar2 = 0x40;
      }
      else {
        iVar2 = 0x41;
      }
      cc.code = ((uVar4 >> 1) / 0x5f + 0x81) * 0x100 + uVar4 + ((uVar4 >> 1) / 0x5f) * -0xbe + iVar2
      ;
      *(undefined4 *)ucs = 0x8819;
      *(wc_uint32 *)(ucs + 4) = cc.code;
      goto LAB_080c4b6a;
    }
    pwVar1 = wc_map3_range_search((wc_uint16)in_stack_00000008,ucs_gb18030_map,0xce);
    if (pwVar1 != (wc_map3 *)0x0) {
      uVar4 = (pwVar1->code3 + in_stack_00000008) - (uint)pwVar1->code;
      cc.code = ((uVar4 >> 3) / 0x627 + 0x81) * 0x1000000 +
                (((uVar4 >> 2) / 0x13b) % 10 + 0x30) * 0x10000 +
                (uVar4 / 10 + ((uVar4 / 10 >> 1) / 0x3f) * -0x7e + 0x81) * 0x100 + uVar4 % 10 + 0x30
      ;
      if (WcOption.gb18030_as_ucs == '\0') {
        cc.ccs = 0x12002;
      }
      else {
        wVar3 = wc_ucs_to_ccs(in_stack_00000008);
        cc.ccs = wVar3 & 0xffff0000 | 0x2002;
      }
      *(wc_ccs *)ucs = cc.ccs;
      *(wc_uint32 *)(ucs + 4) = cc.code;
      goto LAB_080c4b6a;
    }
  }
  else if (in_stack_00000008 < 0x110000) {
    uVar4 = in_stack_00000008 + 0x1e248;
    cc.code = ((uVar4 >> 3) / 0x627 + 0x81) * 0x1000000 +
              (((uVar4 >> 2) / 0x13b) % 10 + 0x30) * 0x10000 +
              (uVar4 / 10 + ((uVar4 / 10 >> 1) / 0x3f) * -0x7e + 0x81) * 0x100 + uVar4 % 10 + 0x30;
    if (WcOption.gb18030_as_ucs == '\0') {
      cc.ccs = 0x12002;
    }
    else {
      wVar3 = wc_ucs_to_ccs(in_stack_00000008);
      cc.ccs = wVar3 & 0xffff0000 | 0x2002;
    }
    *(wc_ccs *)ucs = cc.ccs;
    *(wc_uint32 *)(ucs + 4) = cc.code;
    goto LAB_080c4b6a;
  }
  *(undefined4 *)ucs = 0x4000;
  *(wc_uint32 *)(ucs + 4) = cc.code;
LAB_080c4b6a:
  return (wc_wchar_t)CONCAT44(cc.code,ucs);
}



Str wc_conv_from_gb18030(Str is,wc_ces ces)

{
  wc_uchar *pwVar1;
  int iVar2;
  ushort code;
  wc_uchar *pwVar3;
  Str x;
  uint uVar4;
  wc_uint32 ucs_00;
  wc_ccs wVar5;
  wc_wchar_t cc;
  wc_uint32 ucs;
  wc_uint32 gbk;
  int state;
  wc_uchar *p;
  wc_uchar *ep;
  wc_uchar *sp;
  Str os;
  
  pwVar1 = (wc_uchar *)is->ptr;
  pwVar3 = pwVar1 + is->length;
  state = 0;
  for (p = pwVar1; (p < pwVar3 && (-1 < (char)*p)); p = p + 1) {
  }
  if (p != pwVar3) {
    x = Strnew_size(is->length);
    if (pwVar1 < p) {
      Strcat_charp_n(x,is->ptr,(int)p - (int)pwVar1);
    }
    for (; p < pwVar3; p = p + 1) {
      if (state == 1) {
        if ((WC_GB18030_MAP[*p] & 4) == 0) {
          if (WC_GB18030_MAP[*p] == '\x10') {
            state = 2;
            goto LAB_080c4f23;
          }
          wtf_push_unknown(x,p + -1,2);
        }
        else {
          code = CONCAT11(p[-1],*p);
          uVar4 = (uint)code;
          wVar5 = wc_gbk_or_gbk_ext(code);
          if (wVar5 == 0x8819) {
            wtf_push(x,0x8819,uVar4);
          }
          else if ((p[-1] < 0xa1) || (*p < 0xa1)) {
            wtf_push(x,0x8816,uVar4);
          }
          else {
            wVar5 = wc_gb2312_or_gbk(code);
            wtf_push(x,wVar5,uVar4);
          }
        }
        state = 0;
      }
      else if ((uint)state < 2) {
        if (state == 0) {
          if (WC_GB18030_MAP[*p] == '\x02') {
            wtf_push_unknown(x,p,1);
          }
          else if (WC_GB18030_MAP[*p] == '\f') {
            state = 1;
          }
          else {
            if (x->area_size <= x->length + 1) {
              Strgrow(x);
            }
            iVar2 = x->length;
            x->ptr[iVar2] = *p;
            x->length = iVar2 + 1;
            x->ptr[x->length] = '\0';
          }
        }
      }
      else if (state == 2) {
        if (WC_GB18030_MAP[*p] == '\f') {
          state = 3;
        }
        else {
          wtf_push_unknown(x,p + -2,3);
          state = 0;
        }
      }
      else if (state == 3) {
        if (WC_GB18030_MAP[*p] == '\x10') {
          uVar4 = (uint)*p | (uint)p[-3] << 0x18 | (uint)p[-2] << 0x10 | (uint)p[-1] << 8;
          if ((WcOption.gb18030_as_ucs == '\0') ||
             (ucs_00 = wc_gb18030_to_ucs((wc_wchar_t)CONCAT44(uVar4,0x12002)), ucs_00 == 0xffffffff)
             ) {
            wtf_push(x,0x12002,uVar4);
          }
          else {
            wVar5 = wc_ucs_to_ccs(ucs_00);
            wtf_push(x,wVar5 & 0xffff0000 | 0x2002,uVar4);
          }
        }
        else {
          wtf_push_unknown(x,p + -3,4);
        }
        state = 0;
      }
LAB_080c4f23:
    }
    is = x;
    if (state == 2) {
      wtf_push_unknown(x,p + -2,2);
    }
    else if (state == 3) {
      wtf_push_unknown(x,p + -3,3);
    }
    else if (state == 1) {
      wtf_push_unknown(x,p + -1,1);
    }
  }
  return is;
}



void wc_push_to_gb18030(Str os,wc_wchar_t cc,wc_status *st)

{
  int iVar1;
  uint uVar2;
  wc_ccs local_14;
  wc_uint32 local_10;
  
  do {
    uVar2 = cc.ccs & 0xffff;
    if (uVar2 < 0x8819) {
      if (0x8816 < uVar2) {
        wc_cs128w_to_gbk((wc_wchar_t)CONCAT44(cc.ccs,&cc));
LAB_080c5147:
        if (os->area_size <= os->length + 1) {
          Strgrow(os);
        }
        iVar1 = os->length;
        os->ptr[iVar1] = (char)(cc.code >> 8);
        os->length = iVar1 + 1;
        os->ptr[os->length] = '\0';
        if (os->area_size <= os->length + 1) {
          Strgrow(os);
        }
        iVar1 = os->length;
        os->ptr[iVar1] = (char)cc.code;
        os->length = iVar1 + 1;
        os->ptr[os->length] = '\0';
        return;
      }
      if (uVar2 == 0x4000) {
        if (WcOption.no_replace != '\0') {
          return;
        }
        Strcat_charp(os,WcReplace);
        return;
      }
      if (uVar2 < 0x4001) {
        if (uVar2 == 0x142) {
          if (os->area_size <= os->length + 1) {
            Strgrow(os);
          }
          iVar1 = os->length;
          os->ptr[iVar1] = (char)cc.code;
          os->length = iVar1 + 1;
          os->ptr[os->length] = '\0';
          return;
        }
        if (uVar2 == 0x2002) {
          if (os->area_size <= os->length + 1) {
            Strgrow(os);
          }
          iVar1 = os->length;
          os->ptr[iVar1] = (char)(cc.code >> 0x18);
          os->length = iVar1 + 1;
          os->ptr[os->length] = '\0';
          if (os->area_size <= os->length + 1) {
            Strgrow(os);
          }
          iVar1 = os->length;
          os->ptr[iVar1] = (char)(cc.code >> 0x10);
          os->length = iVar1 + 1;
          os->ptr[os->length] = '\0';
          if (os->area_size <= os->length + 1) {
            Strgrow(os);
          }
          iVar1 = os->length;
          os->ptr[iVar1] = (char)(cc.code >> 8);
          os->length = iVar1 + 1;
          os->ptr[os->length] = '\0';
          if (os->area_size <= os->length + 1) {
            Strgrow(os);
          }
          iVar1 = os->length;
          os->ptr[iVar1] = (char)cc.code;
          os->length = iVar1 + 1;
          os->ptr[os->length] = '\0';
          return;
        }
      }
      else {
        if (uVar2 == 0x8141) {
          if (os->area_size <= os->length + 1) {
            Strgrow(os);
          }
          iVar1 = os->length;
          os->ptr[iVar1] = (byte)(cc.code >> 8) | 0x80;
          os->length = iVar1 + 1;
          os->ptr[os->length] = '\0';
          if (os->area_size <= os->length + 1) {
            Strgrow(os);
          }
          iVar1 = os->length;
          os->ptr[iVar1] = (byte)cc.code | 0x80;
          os->length = iVar1 + 1;
          os->ptr[os->length] = '\0';
          return;
        }
        if (uVar2 == 0x8816) goto LAB_080c5147;
      }
    }
    else {
      if (uVar2 < 0x881c) {
        if (0x8819 < uVar2) {
          wc_cs128w_to_gbk((wc_wchar_t)CONCAT44(cc.ccs,&local_14));
          cc.ccs = local_14;
          cc.code = local_10;
        }
        if (os->area_size <= os->length + 1) {
          Strgrow(os);
        }
        iVar1 = os->length;
        os->ptr[iVar1] = (char)(cc.code >> 8);
        os->length = iVar1 + 1;
        os->ptr[os->length] = '\0';
        if (os->area_size <= os->length + 1) {
          Strgrow(os);
        }
        iVar1 = os->length;
        os->ptr[iVar1] = (char)cc.code;
        os->length = iVar1 + 1;
        os->ptr[os->length] = '\0';
        return;
      }
      if (uVar2 == 0xc000) {
        if (WcOption.no_replace == '\0') {
          Strcat_charp(os,WcReplaceW);
        }
        return;
      }
    }
    if (WcOption.ucs_conv == '\0') {
      if ((cc.ccs & 0x18000) == 0) {
        cc.ccs = 0x4000;
      }
      else {
        cc.ccs = 0xc000;
      }
    }
    else {
      wc_any_to_any_ces((wc_wchar_t)CONCAT44(cc.ccs,&local_14),(wc_status *)cc.code);
      cc.ccs = local_14;
      cc.code = local_10;
    }
  } while( true );
}



Str wc_char_conv_from_gb18030(wc_uchar c,wc_status *st)

{
  int iVar1;
  ushort code;
  Str p_Var2;
  uint uVar3;
  wc_uint32 ucs_00;
  wc_ccs wVar4;
  wc_wchar_t cc;
  wc_uint32 ucs;
  wc_uint32 gbk;
  
  if (st->state == -1) {
    st->state = 0;
    wc_char_conv_from_gb18030::os = Strnew_size(8);
  }
  iVar1 = st->state;
  if (iVar1 == 1) {
    if ((WC_GB18030_MAP[c] & 4) == 0) {
      if (WC_GB18030_MAP[c] == '\x10') {
        wc_char_conv_from_gb18030::gb[1] = c;
        st->state = 2;
        return (Str)0x0;
      }
    }
    else {
      code = CONCAT11(wc_char_conv_from_gb18030::gb[0],c);
      uVar3 = (uint)code;
      wVar4 = wc_gbk_or_gbk_ext(code);
      if (wVar4 == 0x8819) {
        wtf_push(wc_char_conv_from_gb18030::os,0x8819,uVar3);
      }
      else if ((wc_char_conv_from_gb18030::gb[0] < 0xa1) || (c < 0xa1)) {
        wtf_push(wc_char_conv_from_gb18030::os,0x8816,uVar3);
      }
      else {
        wVar4 = wc_gb2312_or_gbk(code);
        wtf_push(wc_char_conv_from_gb18030::os,wVar4,uVar3);
      }
    }
  }
  else if (iVar1 < 2) {
    if ((iVar1 == 0) && (WC_GB18030_MAP[c] != '\x02')) {
      if (WC_GB18030_MAP[c] == '\f') {
        wc_char_conv_from_gb18030::gb[0] = c;
        st->state = 1;
        return (Str)0x0;
      }
      if (wc_char_conv_from_gb18030::os->area_size <= wc_char_conv_from_gb18030::os->length + 1) {
        Strgrow(wc_char_conv_from_gb18030::os);
      }
      p_Var2 = wc_char_conv_from_gb18030::os;
      iVar1 = wc_char_conv_from_gb18030::os->length;
      wc_char_conv_from_gb18030::os->ptr[iVar1] = c;
      p_Var2->length = iVar1 + 1;
      wc_char_conv_from_gb18030::os->ptr[wc_char_conv_from_gb18030::os->length] = '\0';
    }
  }
  else if (iVar1 == 2) {
    if (WC_GB18030_MAP[c] == '\f') {
      wc_char_conv_from_gb18030::gb[2] = c;
      st->state = 3;
      return (Str)0x0;
    }
  }
  else if ((iVar1 == 3) && (WC_GB18030_MAP[c] == '\x10')) {
    uVar3 = (uint)c | (uint)wc_char_conv_from_gb18030::gb[0] << 0x18 |
                      (uint)wc_char_conv_from_gb18030::gb[1] << 0x10 |
                      (uint)wc_char_conv_from_gb18030::gb[2] << 8;
    if ((WcOption.gb18030_as_ucs == '\0') ||
       (ucs_00 = wc_gb18030_to_ucs((wc_wchar_t)CONCAT44(uVar3,0x12002)), ucs_00 == 0xffffffff)) {
      wtf_push(wc_char_conv_from_gb18030::os,0x12002,uVar3);
    }
    else {
      wVar4 = wc_ucs_to_ccs(ucs_00);
      wtf_push(wc_char_conv_from_gb18030::os,wVar4 & 0xffff0000 | 0x2002,uVar3);
    }
  }
  st->state = -1;
  return wc_char_conv_from_gb18030::os;
}



wc_ccs wc_gb2312_or_gbk(wc_uint16 code)

{
  wc_map *pwVar1;
  wc_ccs wVar2;
  
  pwVar1 = wc_map_range_search(code,gb2312_gbk_map,7);
  if (pwVar1 == (wc_map *)0x0) {
    wVar2 = 0x8141;
  }
  else {
    wVar2 = 0x8816;
  }
  return wVar2;
}



wc_wchar_t wc_gbk_to_cs128w(wc_wchar_t cc)

{
  wc_uint32 wVar1;
  int iVar2;
  uint in_stack_0000000c;
  
  if ((in_stack_0000000c & 0xff) < 0x80) {
    iVar2 = 0x40;
  }
  else {
    iVar2 = 0x41;
  }
  iVar2 = ((in_stack_0000000c >> 8 & 0xff) * 0xbe + (in_stack_0000000c & 0xff)) - iVar2;
  in_stack_0000000c = iVar2 - 0x5fbe;
  if (in_stack_0000000c < 0x4000) {
    cc.code = 0x8817;
  }
  else {
    cc.code = 0x8818;
    in_stack_0000000c = iVar2 - 0x9fbe;
  }
  wVar1 = (in_stack_0000000c >> 7) * 0x100 + (in_stack_0000000c & 0x7f);
  *(wc_uint32 *)cc.ccs = cc.code;
  *(wc_uint32 *)(cc.ccs + 4) = wVar1;
  return (wc_wchar_t)CONCAT44(wVar1,cc.ccs);
}



wc_wchar_t wc_cs128w_to_gbk(wc_wchar_t cc)

{
  uint uVar1;
  int iVar2;
  uint in_stack_0000000c;
  
  in_stack_0000000c = (in_stack_0000000c >> 8 & 0x7f) * 0x80 + (in_stack_0000000c & 0x7f);
  if (cc.code == 0x8818) {
    in_stack_0000000c = in_stack_0000000c + 0x4000;
  }
  if (in_stack_0000000c + ((in_stack_0000000c >> 1) / 0x5f) * -0xbe < 0x3f) {
    iVar2 = 0x40;
  }
  else {
    iVar2 = 0x41;
  }
  uVar1 = ((in_stack_0000000c >> 1) / 0x5f + 0x81) * 0x100 +
          in_stack_0000000c + ((in_stack_0000000c >> 1) / 0x5f) * -0xbe + iVar2;
  *(undefined4 *)cc.ccs = 0x8816;
  *(uint *)(cc.ccs + 4) = uVar1;
  return (wc_wchar_t)(cc & 0xffffffff | (ulonglong)uVar1 << 0x20);
}



wc_uint32 wc_gbk_to_N(wc_uint32 c)

{
  int iVar1;
  wc_uint32 wVar2;
  
  if (c < 0xa1a1) {
    if ((c & 0xff) < 0x80) {
      iVar1 = 0x40;
    }
    else {
      iVar1 = 0x41;
    }
    wVar2 = (((c >> 8 & 0xff) * 0xbe + (c & 0xff)) - iVar1) - 0x5fbe;
  }
  else if (c < 0xa2ab) {
    if ((c & 0xff) < 0x80) {
      iVar1 = 0x40;
    }
    else {
      iVar1 = 0x41;
    }
    wVar2 = ((((c >> 8 & 0xff) * 0xbe + (c & 0xff)) - iVar1) + (c >> 8) * -0x5e) - 0x24a0;
  }
  else if (c < 0xa6a1) {
    if ((c & 0xff) < 0x80) {
      iVar1 = 0x40;
    }
    else {
      iVar1 = 0x41;
    }
    wVar2 = ((((c >> 8 & 0xff) * 0xbe + (c & 0xff)) - iVar1) + (c >> 8) * -0x5e) - 0x2496;
  }
  else if (c < 0xa6f6) {
    if ((c & 0xff) < 0x80) {
      iVar1 = 0x40;
    }
    else {
      iVar1 = 0x41;
    }
    wVar2 = ((((c >> 8 & 0xff) * 0xbe + (c & 0xff)) - iVar1) + (c >> 8) * -0x5e) - 0x24d5;
  }
  else if (c < 0xa8a1) {
    if ((c & 0xff) < 0x80) {
      iVar1 = 0x40;
    }
    else {
      iVar1 = 0x41;
    }
    wVar2 = ((((c >> 8 & 0xff) * 0xbe + (c & 0xff)) - iVar1) + (c >> 8) * -0x5e) - 0x2480;
  }
  else if (c < 0xa8c1) {
    if ((c & 0xff) < 0x80) {
      iVar1 = 0x40;
    }
    else {
      iVar1 = 0x41;
    }
    wVar2 = ((((c >> 8 & 0xff) * 0xbe + (c & 0xff)) - iVar1) + (c >> 8) * -0x5e) - 0x249a;
  }
  else {
    if ((c & 0xff) < 0x80) {
      iVar1 = 0x40;
    }
    else {
      iVar1 = 0x41;
    }
    wVar2 = ((((c >> 8 & 0xff) * 0xbe + (c & 0xff)) - iVar1) + (c >> 8) * -0x5e) - 0x247a;
  }
  return wVar2;
}



Str wc_conv_from_gbk(Str is,wc_ces ces)

{
  wc_uint8 wVar1;
  wc_uchar *pwVar2;
  int iVar3;
  ushort code;
  bool bVar4;
  wc_uchar *pwVar5;
  Str x;
  wc_ccs ccs;
  wc_uint32 gbk;
  int state;
  wc_uchar *p;
  wc_uchar *ep;
  wc_uchar *sp;
  Str os;
  
  pwVar2 = (wc_uchar *)is->ptr;
  pwVar5 = pwVar2 + is->length;
  bVar4 = false;
  for (p = pwVar2; (p < pwVar5 && (-1 < (char)*p)); p = p + 1) {
  }
  if (p != pwVar5) {
    x = Strnew_size(is->length);
    if (pwVar2 < p) {
      Strcat_charp_n(x,is->ptr,(int)p - (int)pwVar2);
    }
    for (; p < pwVar5; p = p + 1) {
      if (bVar4) {
        if (bVar4) {
          if ((WC_GBK_MAP[*p] & 4) == 0) {
            wtf_push_unknown(x,p + -1,2);
          }
          else {
            code = CONCAT11(p[-1],*p);
            if ((p[-1] < 0xa1) || (*p < 0xa1)) {
              wtf_push(x,0x8816,(uint)code);
            }
            else {
              ccs = wc_gb2312_or_gbk(code);
              wtf_push(x,ccs,(uint)code);
            }
          }
          bVar4 = false;
        }
      }
      else {
        wVar1 = WC_GBK_MAP[*p];
        if (wVar1 == '\f') {
          bVar4 = true;
        }
        else if (wVar1 == '\x14') {
          wtf_push(x,0x827,(uint)*p);
        }
        else if (wVar1 == '\x02') {
          wtf_push_unknown(x,p,1);
        }
        else {
          if (x->area_size <= x->length + 1) {
            Strgrow(x);
          }
          iVar3 = x->length;
          x->ptr[iVar3] = *p;
          x->length = iVar3 + 1;
          x->ptr[x->length] = '\0';
        }
      }
    }
    is = x;
    if (bVar4) {
      wtf_push_unknown(x,p + -1,1);
    }
  }
  return is;
}



void wc_push_to_gbk(Str os,wc_wchar_t cc,wc_status *st)

{
  int iVar1;
  wc_ccs local_14;
  wc_uint32 local_10;
  
  do {
    if (cc.ccs == 0x8141) {
      if (os->area_size <= os->length + 1) {
        Strgrow(os);
      }
      iVar1 = os->length;
      os->ptr[iVar1] = (byte)(cc.code >> 8) | 0x80;
      os->length = iVar1 + 1;
      os->ptr[os->length] = '\0';
      if (os->area_size <= os->length + 1) {
        Strgrow(os);
      }
      iVar1 = os->length;
      os->ptr[iVar1] = (byte)cc.code | 0x80;
      os->length = iVar1 + 1;
      os->ptr[os->length] = '\0';
      return;
    }
    if (cc.ccs < 0x8142) {
      if (cc.ccs == 0x827) {
        if (os->area_size <= os->length + 1) {
          Strgrow(os);
        }
        iVar1 = os->length;
        os->ptr[iVar1] = (byte)cc.code | 0x80;
        os->length = iVar1 + 1;
        os->ptr[os->length] = '\0';
        return;
      }
      if (cc.ccs == 0x4000) {
        if (WcOption.no_replace != '\0') {
          return;
        }
        Strcat_charp(os,WcReplace);
        return;
      }
      if (cc.ccs == 0x142) {
        if (os->area_size <= os->length + 1) {
          Strgrow(os);
        }
        iVar1 = os->length;
        os->ptr[iVar1] = (char)cc.code;
        os->length = iVar1 + 1;
        os->ptr[os->length] = '\0';
        return;
      }
    }
    else if (cc.ccs < 0x8819) {
      if (0x8816 < cc.ccs) {
        wc_cs128w_to_gbk((wc_wchar_t)CONCAT44(cc.ccs,&cc));
LAB_080c5fe5:
        if (os->area_size <= os->length + 1) {
          Strgrow(os);
        }
        iVar1 = os->length;
        os->ptr[iVar1] = (char)(cc.code >> 8);
        os->length = iVar1 + 1;
        os->ptr[os->length] = '\0';
        if (os->area_size <= os->length + 1) {
          Strgrow(os);
        }
        iVar1 = os->length;
        os->ptr[iVar1] = (char)cc.code;
        os->length = iVar1 + 1;
        os->ptr[os->length] = '\0';
        return;
      }
      if (cc.ccs == 0x8816) goto LAB_080c5fe5;
    }
    else if (cc.ccs == 0xc000) {
      if (WcOption.no_replace != '\0') {
        return;
      }
      Strcat_charp(os,WcReplaceW);
      return;
    }
    if (WcOption.ucs_conv == '\0') {
      if ((cc.ccs & 0x18000) == 0) {
        cc.ccs = 0x4000;
      }
      else {
        cc.ccs = 0xc000;
      }
    }
    else {
      wc_any_to_any_ces((wc_wchar_t)CONCAT44(cc.ccs,&local_14),(wc_status *)cc.code);
      cc.ccs = local_14;
      cc.code = local_10;
    }
  } while( true );
}



Str wc_char_conv_from_gbk(wc_uchar c,wc_status *st)

{
  wc_uint8 wVar1;
  int iVar2;
  ushort code;
  Str p_Var3;
  wc_ccs ccs;
  wc_uint32 gbk;
  
  if (st->state == -1) {
    st->state = 0;
    wc_char_conv_from_gbk::os = Strnew_size(8);
  }
  if (st->state == 0) {
    wVar1 = WC_GBK_MAP[c];
    if (wVar1 == '\f') {
      wc_char_conv_from_gbk::gbku = c;
      st->state = 1;
      return (Str)0x0;
    }
    if (wVar1 == '\x14') {
      wtf_push(wc_char_conv_from_gbk::os,0x827,(uint)c);
    }
    else if (wVar1 != '\x02') {
      if (wc_char_conv_from_gbk::os->area_size <= wc_char_conv_from_gbk::os->length + 1) {
        Strgrow(wc_char_conv_from_gbk::os);
      }
      p_Var3 = wc_char_conv_from_gbk::os;
      iVar2 = wc_char_conv_from_gbk::os->length;
      wc_char_conv_from_gbk::os->ptr[iVar2] = c;
      p_Var3->length = iVar2 + 1;
      wc_char_conv_from_gbk::os->ptr[wc_char_conv_from_gbk::os->length] = '\0';
    }
  }
  else if ((st->state == 1) && ((WC_GBK_MAP[c] & 4) != 0)) {
    code = CONCAT11(wc_char_conv_from_gbk::gbku,c);
    if ((wc_char_conv_from_gbk::gbku < 0xa1) || (c < 0xa1)) {
      wtf_push(wc_char_conv_from_gbk::os,0x8816,(uint)code);
    }
    else {
      ccs = wc_gb2312_or_gbk(code);
      wtf_push(wc_char_conv_from_gbk::os,ccs,(uint)code);
    }
  }
  st->state = -1;
  return wc_char_conv_from_gbk::os;
}



wc_wchar_t wc_hkscs_to_cs128w(wc_wchar_t cc)

{
  wc_uint32 wVar1;
  int iVar2;
  uint in_stack_0000000c;
  
  if ((in_stack_0000000c & 0xff) < 0xa1) {
    iVar2 = 0x40;
  }
  else {
    iVar2 = 0x62;
  }
  iVar2 = ((in_stack_0000000c >> 8 & 0xff) * 0x9d + (in_stack_0000000c & 0xff)) - iVar2;
  in_stack_0000000c = iVar2 - 0x5368;
  if (in_stack_0000000c < 0x4000) {
    cc.code = 0x8820;
  }
  else {
    cc.code = 0x8821;
    in_stack_0000000c = iVar2 - 0x9368;
  }
  wVar1 = (in_stack_0000000c >> 7) * 0x100 + (in_stack_0000000c & 0x7f);
  *(wc_uint32 *)cc.ccs = cc.code;
  *(wc_uint32 *)(cc.ccs + 4) = wVar1;
  return (wc_wchar_t)CONCAT44(wVar1,cc.ccs);
}



wc_wchar_t wc_cs128w_to_hkscs(wc_wchar_t cc)

{
  uint uVar1;
  int iVar2;
  uint in_stack_0000000c;
  
  in_stack_0000000c = (in_stack_0000000c >> 8 & 0x7f) * 0x80 + (in_stack_0000000c & 0x7f);
  if (cc.code == 0x8821) {
    in_stack_0000000c = in_stack_0000000c + 0x4000;
  }
  if (in_stack_0000000c % 0x9d < 0x3f) {
    iVar2 = 0x40;
  }
  else {
    iVar2 = 0x62;
  }
  uVar1 = (in_stack_0000000c / 0x9d + 0x88) * 0x100 + in_stack_0000000c % 0x9d + iVar2;
  *(undefined4 *)cc.ccs = 0x881f;
  *(uint *)(cc.ccs + 4) = uVar1;
  return (wc_wchar_t)(cc & 0xffffffff | (ulonglong)uVar1 << 0x20);
}



wc_uint32 wc_hkscs_to_N(wc_uint32 c)

{
  int iVar1;
  wc_uint32 wVar2;
  
  if (c < 0xa140) {
    if ((c & 0xff) < 0xa1) {
      iVar1 = 0x40;
    }
    else {
      iVar1 = 0x62;
    }
    wVar2 = (((c >> 8 & 0xff) * 0x9d + (c & 0xff)) - iVar1) - 0x5368;
  }
  else {
    if ((c & 0xff) < 0xa1) {
      iVar1 = 0x40;
    }
    else {
      iVar1 = 0x62;
    }
    wVar2 = (((c >> 8 & 0xff) * 0x9d + (c & 0xff)) - iVar1) - 0x89fd;
  }
  return wVar2;
}



Str wc_conv_from_hkscs(Str is,wc_ces ces)

{
  wc_uint8 wVar1;
  wc_uchar *pwVar2;
  int iVar3;
  bool bVar4;
  wc_uchar *pwVar5;
  Str x;
  wc_uint32 hkscs;
  int state;
  wc_uchar *p;
  wc_uchar *ep;
  wc_uchar *sp;
  Str os;
  
  pwVar2 = (wc_uchar *)is->ptr;
  pwVar5 = pwVar2 + is->length;
  bVar4 = false;
  for (p = pwVar2; (p < pwVar5 && (-1 < (char)*p)); p = p + 1) {
  }
  if (p != pwVar5) {
    x = Strnew_size(is->length);
    if (pwVar2 < p) {
      Strcat_charp_n(x,is->ptr,(int)p - (int)pwVar2);
    }
    for (; p < pwVar5; p = p + 1) {
      if (bVar4) {
        if (bVar4) {
          if ((WC_HKSCS_MAP[*p] & 4) == 0) {
            wtf_push_unknown(x,p + -1,2);
          }
          else if ((p[-1] < 0xa1) || (0xf9 < p[-1])) {
            wtf_push(x,0x881f,(uint)CONCAT11(p[-1],*p));
          }
          else {
            wtf_push(x,0x8801,(uint)CONCAT11(p[-1],*p));
          }
          bVar4 = false;
        }
      }
      else {
        wVar1 = WC_HKSCS_MAP[*p];
        if ((wVar1 == '\f') || (wVar1 == '\x10')) {
          bVar4 = true;
        }
        else if (wVar1 == '\x02') {
          wtf_push_unknown(x,p,1);
        }
        else {
          if (x->area_size <= x->length + 1) {
            Strgrow(x);
          }
          iVar3 = x->length;
          x->ptr[iVar3] = *p;
          x->length = iVar3 + 1;
          x->ptr[x->length] = '\0';
        }
      }
    }
    is = x;
    if (bVar4) {
      wtf_push_unknown(x,p + -1,1);
    }
  }
  return is;
}



void wc_push_to_hkscs(Str os,wc_wchar_t cc,wc_status *st)

{
  int iVar1;
  wc_ccs local_14;
  wc_uint32 local_10;
  
  do {
    if (cc.ccs < 0x8804) {
      if (0x8801 < cc.ccs) {
        wc_cs94w_to_big5((wc_wchar_t)CONCAT44(cc.ccs,&cc));
LAB_080c67e1:
        if (os->area_size <= os->length + 1) {
          Strgrow(os);
        }
        iVar1 = os->length;
        os->ptr[iVar1] = (char)(cc.code >> 8);
        os->length = iVar1 + 1;
        os->ptr[os->length] = '\0';
        if (os->area_size <= os->length + 1) {
          Strgrow(os);
        }
        iVar1 = os->length;
        os->ptr[iVar1] = (char)cc.code;
        os->length = iVar1 + 1;
        os->ptr[os->length] = '\0';
        return;
      }
      if (cc.ccs == 0x4000) {
        if (WcOption.no_replace != '\0') {
          return;
        }
        Strcat_charp(os,WcReplace);
        return;
      }
      if (cc.ccs == 0x8801) goto LAB_080c67e1;
      if (cc.ccs == 0x142) {
        if (os->area_size <= os->length + 1) {
          Strgrow(os);
        }
        iVar1 = os->length;
        os->ptr[iVar1] = (char)cc.code;
        os->length = iVar1 + 1;
        os->ptr[os->length] = '\0';
        return;
      }
    }
    else if (cc.ccs < 0x8822) {
      if (0x881f < cc.ccs) {
        wc_cs128w_to_hkscs((wc_wchar_t)CONCAT44(cc.ccs,&local_14));
        cc.ccs = local_14;
        cc.code = local_10;
LAB_080c68a9:
        if (os->area_size <= os->length + 1) {
          Strgrow(os);
        }
        iVar1 = os->length;
        os->ptr[iVar1] = (char)(cc.code >> 8);
        os->length = iVar1 + 1;
        os->ptr[os->length] = '\0';
        if (os->area_size <= os->length + 1) {
          Strgrow(os);
        }
        iVar1 = os->length;
        os->ptr[iVar1] = (char)cc.code;
        os->length = iVar1 + 1;
        os->ptr[os->length] = '\0';
        return;
      }
      if (cc.ccs == 0x881f) goto LAB_080c68a9;
    }
    else if (cc.ccs == 0xc000) {
      if (WcOption.no_replace != '\0') {
        return;
      }
      Strcat_charp(os,WcReplaceW);
      return;
    }
    if (WcOption.ucs_conv == '\0') {
      if ((cc.ccs & 0x18000) == 0) {
        cc.ccs = 0x4000;
      }
      else {
        cc.ccs = 0xc000;
      }
    }
    else {
      wc_any_to_any_ces((wc_wchar_t)CONCAT44(cc.ccs,&local_14),(wc_status *)cc.code);
      cc.ccs = local_14;
      cc.code = local_10;
    }
  } while( true );
}



Str wc_char_conv_from_hkscs(wc_uchar c,wc_status *st)

{
  wc_uint8 wVar1;
  int iVar2;
  Str p_Var3;
  wc_uint32 hkscs;
  
  if (st->state == -1) {
    st->state = 0;
    wc_char_conv_from_hkscs::os = Strnew_size(8);
  }
  if (st->state == 0) {
    wVar1 = WC_HKSCS_MAP[c];
    if ((wVar1 == '\f') || (wVar1 == '\x10')) {
      wc_char_conv_from_hkscs::hkscsu = c;
      st->state = 1;
      return (Str)0x0;
    }
    if (wVar1 != '\x02') {
      if (wc_char_conv_from_hkscs::os->area_size <= wc_char_conv_from_hkscs::os->length + 1) {
        Strgrow(wc_char_conv_from_hkscs::os);
      }
      p_Var3 = wc_char_conv_from_hkscs::os;
      iVar2 = wc_char_conv_from_hkscs::os->length;
      wc_char_conv_from_hkscs::os->ptr[iVar2] = c;
      p_Var3->length = iVar2 + 1;
      wc_char_conv_from_hkscs::os->ptr[wc_char_conv_from_hkscs::os->length] = '\0';
    }
  }
  else if ((st->state == 1) && ((WC_HKSCS_MAP[c] & 4) != 0)) {
    if ((wc_char_conv_from_hkscs::hkscsu < 0xa1) ||
       ((0xf9 < wc_char_conv_from_hkscs::hkscsu || (c < 0xa1)))) {
      wtf_push(wc_char_conv_from_hkscs::os,0x881f,(uint)CONCAT11(wc_char_conv_from_hkscs::hkscsu,c))
      ;
    }
    else {
      wtf_push(wc_char_conv_from_hkscs::os,0x8801,(uint)CONCAT11(wc_char_conv_from_hkscs::hkscsu,c))
      ;
    }
  }
  st->state = -1;
  return wc_char_conv_from_hkscs::os;
}



Str wc_conv_from_priv1(Str is,wc_ces ces)

{
  wc_uchar *pwVar1;
  wc_ccs ccs_00;
  int iVar2;
  wc_uchar *pwVar3;
  Str x;
  wc_ccs ccs;
  wc_uchar *p;
  wc_uchar *ep;
  wc_uchar *sp;
  Str os;
  
  pwVar1 = (wc_uchar *)is->ptr;
  pwVar3 = pwVar1 + is->length;
  ccs_00 = WcCesInfo[ces & 0xff].gset[1].ccs;
  for (p = pwVar1; (p < pwVar3 && (-1 < (char)*p)); p = p + 1) {
  }
  if (p != pwVar3) {
    x = Strnew_size(is->length);
    if (pwVar1 < p) {
      Strcat_charp_n(x,is->ptr,(int)p - (int)pwVar1);
    }
    for (; is = x, p < pwVar3; p = p + 1) {
      if ((char)*p < '\0') {
        wtf_push(x,ccs_00,(uint)*p);
      }
      else {
        if (x->area_size <= x->length + 1) {
          Strgrow(x);
        }
        iVar2 = x->length;
        x->ptr[iVar2] = *p;
        x->length = iVar2 + 1;
        x->ptr[x->length] = '\0';
      }
    }
  }
  return is;
}



Str wc_char_conv_from_priv1(wc_uchar c,wc_status *st)

{
  int iVar1;
  Str x;
  Str os;
  
  x = Strnew_size(1);
  if ((char)c < '\0') {
    wtf_push(x,st->ces_info->gset[1].ccs,(uint)c);
  }
  else {
    if (x->area_size <= x->length + 1) {
      Strgrow(x);
    }
    iVar1 = x->length;
    x->ptr[iVar1] = c;
    x->length = iVar1 + 1;
    x->ptr[x->length] = '\0';
  }
  return x;
}



Str wc_conv_from_ascii(Str is,wc_ces ces)

{
  wc_uchar *pwVar1;
  int iVar2;
  wc_uchar *pwVar3;
  Str x;
  wc_uchar *p;
  wc_uchar *ep;
  wc_uchar *sp;
  Str os;
  
  pwVar1 = (wc_uchar *)is->ptr;
  pwVar3 = pwVar1 + is->length;
  for (p = pwVar1; (p < pwVar3 && (-1 < (char)*p)); p = p + 1) {
  }
  if (p != pwVar3) {
    x = Strnew_size(is->length);
    if (pwVar1 < p) {
      Strcat_charp_n(x,is->ptr,(int)p - (int)pwVar1);
    }
    for (; is = x, p < pwVar3; p = p + 1) {
      if ((char)*p < '\0') {
        wtf_push_unknown(x,p,1);
      }
      else {
        if (x->area_size <= x->length + 1) {
          Strgrow(x);
        }
        iVar2 = x->length;
        x->ptr[iVar2] = *p;
        x->length = iVar2 + 1;
        x->ptr[x->length] = '\0';
      }
    }
  }
  return is;
}



void wc_push_to_raw(Str os,wc_wchar_t cc,wc_status *st)

{
  int iVar1;
  
  if ((cc.ccs == 0x142) || (cc.ccs == 0x828)) {
    if (os->area_size <= os->length + 1) {
      Strgrow(os);
    }
    iVar1 = os->length;
    os->ptr[iVar1] = (char)((ulonglong)cc >> 0x20);
    os->length = iVar1 + 1;
    os->ptr[os->length] = '\0';
  }
  return;
}



undefined8 __divdi3(uint param_1,uint param_2,uint param_3,uint param_4)

{
  ulonglong uVar1;
  ulonglong uVar2;
  ulonglong uVar3;
  longlong lVar4;
  int iVar5;
  byte bVar6;
  uint uVar7;
  uint uVar8;
  bool bVar9;
  byte bStack28;
  uint local_18;
  uint local_14;
  uint local_10;
  
  local_14 = param_3;
  local_10 = param_4;
  local_18 = 0;
  if ((int)param_2 < 0) {
    bVar9 = param_1 != 0;
    param_1 = -param_1;
    param_2 = -(param_2 + bVar9);
    local_18 = 0xffffffff;
  }
  if ((int)param_4 < 0) {
    local_14 = -param_3;
    local_18 = ~local_18;
    local_10 = -(param_4 + (param_3 != 0));
  }
  if (local_10 == 0) {
    if (param_2 < local_14) {
      uVar8 = 0;
      iVar5 = (int)(CONCAT44(param_2,param_1) / (ulonglong)local_14);
    }
    else {
      if (local_14 == 0) {
        local_14 = (uint)(1 / 0);
      }
      uVar8 = param_2 / local_14;
      iVar5 = (int)(((ulonglong)param_2 % (ulonglong)local_14 << 0x20 | (ulonglong)param_1) /
                   (ulonglong)local_14);
    }
    goto LAB_080c6f20;
  }
  if (local_10 <= param_2) {
    uVar8 = 0x1f;
    if (local_10 != 0) {
      for (; local_10 >> uVar8 == 0; uVar8 = uVar8 - 1) {
      }
    }
    if ((uVar8 ^ 0x1f) != 0) {
      bStack28 = (byte)(uVar8 ^ 0x1f);
      bVar6 = 0x20 - bStack28;
      uVar1 = (ulonglong)(local_14 >> (bVar6 & 0x1f) | local_10 << (bStack28 & 0x1f));
      uVar2 = CONCAT44(param_2 >> (bVar6 & 0x1f),
                       param_2 << (bStack28 & 0x1f) | param_1 >> (bVar6 & 0x1f));
      uVar3 = uVar2 / uVar1;
      iVar5 = (int)uVar3;
      uVar8 = (uint)(uVar2 % uVar1);
      lVar4 = (uVar3 & 0xffffffff) * (ulonglong)(local_14 << (bStack28 & 0x1f));
      uVar7 = (uint)((ulonglong)lVar4 >> 0x20);
      if ((uVar8 < uVar7) || ((param_1 << (bStack28 & 0x1f) < (uint)lVar4 && (uVar8 == uVar7)))) {
        iVar5 = iVar5 + -1;
        uVar8 = 0;
      }
      else {
        uVar8 = 0;
      }
      goto LAB_080c6f20;
    }
    if ((local_14 <= param_1) || (local_10 < param_2)) {
      uVar8 = 0;
      iVar5 = 1;
      goto LAB_080c6f20;
    }
  }
  uVar8 = 0;
  iVar5 = 0;
LAB_080c6f20:
  if (local_18 != 0) {
    bVar9 = iVar5 != 0;
    iVar5 = -iVar5;
    uVar8 = -(uVar8 + bVar9);
  }
  return CONCAT44(uVar8,iVar5);
}



// WARNING: Could not reconcile some variable overlaps

undefined8 __moddi3(uint param_1,uint param_2,uint param_3,uint param_4)

{
  ulonglong uVar1;
  longlong lVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  bool bVar7;
  int local_30;
  byte local_2c;
  uint local_28;
  uint local_24;
  uint local_20;
  uint local_10;
  
  local_24 = param_3;
  local_20 = param_4;
  local_30 = 0;
  if ((int)param_2 < 0) {
    bVar7 = param_1 != 0;
    param_1 = -param_1;
    param_2 = -(param_2 + bVar7);
    local_30 = -1;
  }
  if ((int)param_4 < 0) {
    local_24 = -param_3;
    local_20 = -(param_4 + (param_3 != 0));
  }
  local_28 = local_24;
  if (local_20 == 0) {
    if (param_2 < local_24) {
      param_1 = (uint)(CONCAT44(param_2,param_1) % (ulonglong)local_24);
    }
    else {
      if (local_24 == 0) {
        local_28 = (uint)(1 / 0);
      }
      param_1 = (uint)(((ulonglong)param_2 % (ulonglong)local_28 << 0x20 | (ulonglong)param_1) %
                      (ulonglong)local_28);
    }
    local_10 = 0;
  }
  else {
    local_10 = param_2;
    if (local_20 <= param_2) {
      uVar3 = 0x1f;
      if (local_20 != 0) {
        for (; local_20 >> uVar3 == 0; uVar3 = uVar3 - 1) {
        }
      }
      if ((uVar3 ^ 0x1f) == 0) {
        if ((local_24 <= param_1) || (local_20 < param_2)) {
          bVar7 = param_1 < local_24;
          param_1 = param_1 - local_24;
          local_10 = (param_2 - local_20) - (uint)bVar7;
        }
      }
      else {
        local_24._0_1_ = (byte)(uVar3 ^ 0x1f);
        local_2c = 0x20 - (byte)local_24;
        uVar3 = local_24 >> (local_2c & 0x1f) | local_20 << ((byte)local_24 & 0x1f);
        local_24 = local_24 << ((byte)local_24 & 0x1f);
        uVar1 = CONCAT44(param_2 >> (local_2c & 0x1f),
                         param_1 >> (local_2c & 0x1f) | param_2 << ((byte)local_24 & 0x1f));
        uVar5 = (uint)(uVar1 % (ulonglong)uVar3);
        param_1 = param_1 << ((byte)local_24 & 0x1f);
        lVar2 = (uVar1 / uVar3 & 0xffffffff) * (ulonglong)local_24;
        uVar6 = (uint)((ulonglong)lVar2 >> 0x20);
        uVar4 = (uint)lVar2;
        if ((uVar5 < uVar6) || ((param_1 < uVar4 && (uVar5 == uVar6)))) {
          bVar7 = uVar4 < local_24;
          uVar4 = uVar4 - local_24;
          uVar6 = (uVar6 - uVar3) - (uint)bVar7;
        }
        local_10 = (uVar5 - uVar6) - (uint)(param_1 < uVar4);
        param_1 = local_10 << (local_2c & 0x1f) | param_1 - uVar4 >> ((byte)local_24 & 0x1f);
        local_10 = local_10 >> ((byte)local_24 & 0x1f);
      }
    }
  }
  if (local_30 == 0) {
    return CONCAT44(local_10,param_1);
  }
  return CONCAT44(-(local_10 + (param_1 != 0)),-param_1);
}



void __libc_csu_fini(void)

{
  return;
}



// WARNING: Function: __i686.get_pc_thunk.bx replaced with injection: get_pc_thunk_bx
// WARNING: Removing unreachable block (ram,0x080c724e)
// WARNING: Removing unreachable block (ram,0x080c7250)

void __libc_csu_init(void)

{
  EVP_PKEY_CTX *in_stack_ffffffd4;
  
  _init(in_stack_ffffffd4);
  return;
}



// WARNING: This is an inlined function

void __i686_get_pc_thunk_bx(void)

{
  return;
}



// WARNING: Function: __i686.get_pc_thunk.bx replaced with injection: get_pc_thunk_bx

int stat(char *__file,stat *__buf)

{
  int iVar1;
  
  iVar1 = __xstat(3,__file,__buf);
  return iVar1;
}



// WARNING: Function: __i686.get_pc_thunk.bx replaced with injection: get_pc_thunk_bx

int fstat(int __fd,stat *__buf)

{
  int iVar1;
  
  iVar1 = __fxstat(3,__fd,__buf);
  return iVar1;
}



// WARNING: Function: __i686.get_pc_thunk.bx replaced with injection: get_pc_thunk_bx

int lstat(char *__file,stat *__buf)

{
  int iVar1;
  
  iVar1 = __lxstat(3,__file,__buf);
  return iVar1;
}



void __do_global_ctors_aux(void)

{
  code *pcVar1;
  code **ppcVar2;
  
  if (__CTOR_LIST__ != (code *)0xffffffff) {
    ppcVar2 = &__CTOR_LIST__;
    pcVar1 = __CTOR_LIST__;
    do {
      ppcVar2 = ppcVar2 + -1;
      (*pcVar1)();
      pcVar1 = *ppcVar2;
    } while (pcVar1 != (code *)0xffffffff);
  }
  return;
}



void _fini(void)

{
  __do_global_dtors_aux();
  return;
}


