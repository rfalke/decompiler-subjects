/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <math.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

int init_proc();
int sub_8049C2C();
// int fileno(FILE *stream);
// int fputs(const char *s, FILE *stream);
// void abort(void);
// int *__errno_location(void);
// int sigemptyset(sigset_t *set);
// const char *inet_ntop(int af, const void *cp, char *buf, socklen_t len);
// int sprintf(char *s, const char *format, ...);
// FILE *popen(const char *command, const char *modes);
// int open(const char *file, int oflag, ...);
// int connect(int fd, const struct sockaddr *addr, socklen_t len);
// __pid_t getpid(void);
// int mkdir(const char *path, __mode_t mode);
// void srand48(int seedval);
// char *strerror(int errnum);
// int getsockname(int fd, struct sockaddr *addr, socklen_t *len);
// int memcmp(const void *s1, const void *s2, size_t n);
// void qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar);
// char *inet_ntoa(struct in_addr in);
// void freeaddrinfo(struct addrinfo *ai);
// void *bsearch(const void *key, const void *base, size_t nmemb, size_t size, __compar_fn_t compar);
// int tgetflag(const char *);
// int __xstat(int ver, const char *filename, struct stat *stat_buf);
// int __gmon_start__(void); weak
// int __lxstat(int ver, const char *filename, struct stat *stat_buf);
// int __isoc99_sscanf(_DWORD, const char *, ...); weak
// int vsprintf(char *s, const char *format, __gnuc_va_list arg);
// struct tm *localtime(const time_t *timer);
// char *getpass(const char *prompt);
// char *strchr(const char *s, int c);
// char *getenv(const char *name);
// int system(const char *command);
// char *strncpy(char *dest, const char *src, size_t n);
// int putchar(int c);
// char *ttyname(int fd);
// ssize_t write(int fd, const void *buf, size_t n);
// int __cdecl GC_realloc(_DWORD, _DWORD); weak
// int rename(const char *old, const char *new);
// void *memset(void *s, int c, size_t n);
// int __cdecl __libc_start_main(int (__cdecl *main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end);
// int execl(const char *path, const char *arg, ...);
// int _IO_getc(_IO_FILE *fp);
// double floor(double x);
// char *strrchr(const char *s, int c);
// int tcgetattr(int fd, struct termios *termios_p);
// int chmod(const char *file, __mode_t mode);
// int __cdecl GC_set_warn_proc(_DWORD); weak
// char *bindtextdomain(const char *domainname, const char *dirname);
// int __cdecl GC_malloc(_DWORD); weak
// ssize_t read(int fd, void *buf, size_t nbytes);
// __int64 strtoll(const char *nptr, char **endptr, int base);
// char *gettext(const char *msgid);
// int ungetc(int c, FILE *stream);
// struct dirent *readdir(DIR *dirp);
// int strtol(const char *nptr, char **endptr, int base);
// FILE *fdopen(int fd, const char *modes);
// void siglongjmp(sigjmp_buf env, int val);
// int tgetent(char *, const char *);
// int sigaction(int sig, const struct sigaction *act, struct sigaction *oact);
// int fflush(FILE *stream);
// double sqrt(double x);
// DIR *opendir(const char *name);
// int symlink(const char *from, const char *to);
// int ioctl(int fd, unsigned int request, ...);
// int socket(int domain, int type, int protocol);
// int dup2(int fd, int fd2);
// int fseek(FILE *stream, int off, int whence);
// int execlp(const char *file, const char *arg, ...);
// int isatty(int fd);
// int getaddrinfo(const char *name, const char *service, const struct addrinfo *req, struct addrinfo **pai);
// int fclose(FILE *stream);
// void bcopy(const void *src, void *dest, size_t n);
// int dup(int fd);
// time_t mktime(struct tm *tp);
// void *memcpy(void *dest, const void *src, size_t n);
// int utime(const char *file, const struct utimbuf *file_times);
// size_t strlen(const char *s);
// FILE *fopen(const char *filename, const char *modes);
// unsigned int alarm(unsigned int seconds);
// int unlink(const char *name);
// struct passwd *getpwuid(__uid_t uid);
// FILE *freopen(const char *filename, const char *modes, FILE *stream);
// char *setlocale(int category, const char *locale);
// __pid_t waitpid(__pid_t pid, int *stat_loc, int options);
// int fgetc(FILE *stream);
// int feof(FILE *stream);
// char *strcpy(char *dest, const char *src);
// __gid_t getegid(void);
// int printf(const char *format, ...);
// int chdir(const char *path);
// char *ctime(const time_t *timer);
// int tputs(const char *, int, int (*)(int));
// __uid_t getuid(void);
// int atol(const char *nptr);
// int lrand48(void);
// struct hostent *gethostbyaddr(const void *addr, __socklen_t len, int type);
// int atoi(const char *nptr);
// int strcasecmp(const char *s1, const char *s2);
// double atof(const char *nptr);
// int __cdecl GC_free(_DWORD); weak
// int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
// int closedir(DIR *dirp);
// int Gpm_Wgetch();
// int close(int fd);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// int fprintf(FILE *stream, const char *format, ...);
// char *strstr(const char *haystack, const char *needle);
// time_t time(time_t *timer);
// char *nl_langinfo(nl_item item);
// int Gpm_Close(void);
// int gethostname(char *name, size_t len);
// double atan2(double y, double x);
// int fputc(int c, FILE *stream);
// char *strtok(char *s, const char *delim);
// char *tgoto(const char *, int, int);
// int __cdecl strcasestr(_DWORD, _DWORD); weak
// unsigned int sleep(unsigned int seconds);
// int tgetnum(const char *);
// ssize_t readlink(const char *path, char *buf, size_t len);
// int strncasecmp(const char *s1, const char *s2, size_t n);
// int getnameinfo(const struct sockaddr *sa, socklen_t salen, char *host, socklen_t hostlen, char *serv, socklen_t servlen, unsigned int flags);
// char *strcat(char *dest, const char *src);
// char *getcwd(char *buf, size_t size);
// double log(double x);
// int puts(const char *s);
// __pid_t fork(void);
// int setpgrp(void);
// char *textdomain(const char *domainname);
// int tcsetattr(int fd, int optional_actions, const struct termios *termios_p);
// void bzero(void *s, size_t n);
// size_t strspn(const char *s, const char *accept);
// int sscanf(const char *s, const char *format, ...);
// int __fxstat(int ver, int fildes, struct stat *stat_buf);
// struct tm *gmtime(const time_t *timer);
// int fscanf(FILE *stream, const char *format, ...);
// void *memchr(const void *s, int c, size_t n);
// int strncmp(const char *s1, const char *s2, size_t n);
// int _IO_putc(int c, _IO_FILE *fp);
// int pipe(int pipedes[2]);
// int Gpm_Open(Gpm_Connect *, int);
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
// size_t strftime(char *s, size_t maxsize, const char *format, const struct tm *tp);
// int __cdecl GC_malloc_atomic(_DWORD); weak
// char *tgetstr(const char *, char **);
// int kill(__pid_t pid, int sig);
// size_t strcspn(const char *s, const char *reject);
// char *strdup(const char *s);
// int getpeername(int fd, struct sockaddr *addr, socklen_t *len);
// int ferror(FILE *stream);
// struct passwd *getpwnam(const char *name);
// int tolower(int c);
// int strcmp(const char *s1, const char *s2);
// int __sigsetjmp(struct __jmp_buf_tag *env, int savemask);
// int setenv(const char *name, const char *value, int replace);
// void exit(int status);
// int pclose(FILE *stream);
// double ceil(double x);
// __uid_t geteuid(void);
// void __usercall __noreturn start(int a1@<eax>, void (*a2)(void)@<edx>);
void _do_global_dtors_aux();
int frame_dummy();
void __cdecl fversion(FILE *f);
void __cdecl fusage(FILE *f, int err);
void __cdecl wrap_GC_warn_proc(char *msg, GC_word arg);
void __cdecl sig_chld(int signo);
Str __cdecl make_optional_header_string(char *s);
int __cdecl main(int argc, const char **argv, const char **envp);
void __cdecl keyPressEventProc(int c);
void __cdecl pushEvent(int cmd, void *data);
void __cdecl dump_source(Buffer *buf);
void __cdecl dump_head(Buffer *buf);
void __cdecl dump_extra(Buffer *buf);
void __cdecl do_dump(Buffer *buf);
void nulcmd(); // idb
void pcmap(); // idb
void __cdecl escKeyProc(int c, int esc, unsigned __int8 *map);
void escmap(); // idb
void escbmap(); // idb
void __cdecl escdmap(char c);
void multimap(); // idb
void __cdecl tmpClearBuffer(Buffer *buf);
void __cdecl pushBuffer(Buffer *buf);
void __cdecl delBuffer(Buffer *buf);
void __cdecl repBuffer(Buffer *oldbuf, Buffer *buf);
void __cdecl intTrap(int _dummy);
void __cdecl resize_hook(int _dummy);
void resize_screen(); // idb
void __cdecl SigPipe(int _dummy);
void __cdecl nscroll(int n, int mode);
void pgFore(); // idb
void pgBack(); // idb
void lup1(); // idb
void ldown1(); // idb
void ctrCsrV(); // idb
void ctrCsrH(); // idb
void rdrwSc(); // idb
void __cdecl clear_mark(Line *l);
int __cdecl srchcore(char *volatile str, int (*func)(Buffer *, char *));
void __cdecl disp_srchresult(int result, char *prompt, char *str);
int __cdecl dispincsrch(int ch_0, Str buf, Lineprop *prop);
void __cdecl isrch(int (*func)(Buffer *, char *), char *prompt);
void __cdecl srch(int (*func)(Buffer *, char *), char *prompt);
void srchfor(); // idb
void isrchfor(); // idb
void srchbak(); // idb
void isrchbak(); // idb
void __cdecl srch_nxtprv(int reverse);
void srchnxt(); // idb
void srchprv(); // idb
void __cdecl shiftvisualpos(Buffer *buf, int shift);
void shiftl(); // idb
void shiftr(); // idb
void col1R(); // idb
void col1L(); // idb
void setEnv(); // idb
void pipeBuf(); // idb
void pipesh(); // idb
void readsh(); // idb
void execsh(); // idb
void ldfile(); // idb
void ldhelp(); // idb
void __cdecl cmd_loadfile(char *fn);
void __cdecl movL(int n);
void movL(); // idb
void movL1(); // idb
void __cdecl movD(int n);
void movD(); // idb
void movD1(); // idb
void __cdecl movU(int n);
void movU(); // idb
void movU1(); // idb
void __cdecl movR(int n);
void movR(); // idb
void movR1(); // idb
int __cdecl prev_nonnull_line(Line *line);
void movLW(); // idb
int __cdecl next_nonnull_line(Line *line);
void movRW(); // idb
void __cdecl quitfm(int confirm);
void quitfm(); // idb
void qquitfm(); // idb
void selBuf(); // idb
void susp(); // idb
void __cdecl goLine(char *l);
void goLine(); // idb
void goLineF(); // idb
void goLineL(); // idb
void linbeg(); // idb
void linend(); // idb
int __cdecl cur_real_linenumber(Buffer *buf);
void editBf(); // idb
void editScr(); // idb
void mark(); // idb
void nextMk(); // idb
void prevMk(); // idb
void reMark(); // idb
Buffer *__cdecl loadNormalBuf(Buffer *buf, int renderframe);
Buffer *__cdecl loadLink(char *url, char *target, char *referer, FormList *request);
void __cdecl gotoLabel(char *label);
void followA(); // idb
void bufferA(); // idb
void followI(); // idb
FormItemList *__cdecl save_submit_formlist(FormItemList *src);
Str __cdecl conv_form_encoding(Str val, FormItemList *fi, Buffer *buf);
void __cdecl query_from_followform(Str *query, FormItemList *fi, int multipart);
void submitForm(); // idb
void followForm(); // idb
void __cdecl followForm(int submit);
void topA(); // idb
void lastA(); // idb
void nextA(); // idb
void prevA(); // idb
void nextVA(); // idb
void prevVA(); // idb
void __cdecl nextA(int visited);
void __cdecl prevA(int visited);
void __cdecl nextX(int d, int dy);
void __cdecl nextY(int d);
void nextL(); // idb
void nextLU(); // idb
void nextR(); // idb
void nextRD(); // idb
void nextD(); // idb
void nextU(); // idb
void nextBf(); // idb
void prevBf(); // idb
int __cdecl checkBackBuffer(Buffer *buf);
void backBf(); // idb
void deletePrevBuf(); // idb
void __cdecl cmd_loadURL(char *url, ParsedURL *current, char *referer, FormList *request);
void __cdecl goURL0(char *prompt, int relative);
void goURL(); // idb
void gorURL(); // idb
void __cdecl cmd_loadBuffer(Buffer *buf, int prop, int linkid);
void ldBmark(); // idb
void adBmark(); // idb
void ldOpt(); // idb
void setOpt(); // idb
void msgs(); // idb
void pginfo(); // idb
void __cdecl follow_map(parsed_tagarg *arg);
void linkMn(); // idb
void __cdecl anchorMn(Anchor *(*menu_func)(Buffer *), int go);
void accessKey(); // idb
void listMn(); // idb
void movlistMn(); // idb
void linkLst(); // idb
void cooLst(); // idb
void ldHist(); // idb
void svA(); // idb
void svI(); // idb
void svBuf(); // idb
void svSrc(); // idb
void __cdecl peekURL(int only_img);
void peekURL(); // idb
void peekIMG(); // idb
Str currentURL(); // idb
void curURL(); // idb
void vwSrc(); // idb
void reload(); // idb
void reshape(); // idb
void __cdecl docCSet(wc_ces charset);
void __cdecl change_charset(parsed_tagarg *arg);
void docCSet(); // idb
void defCSet(); // idb
void __cdecl chkURLBuffer(Buffer *buf);
void chkURL(); // idb
void chkWORD(); // idb
void __cdecl chkNMIDBuffer(Buffer *buf);
void chkNMID(); // idb
void rFrame(); // idb
void __cdecl invoke_browser(char *url);
void extbrz(); // idb
void linkbrz(); // idb
void curlno(); // idb
void dispI(); // idb
void stopI(); // idb
int mouse_scroll_line(); // idb
TabBuffer *__cdecl posTab(int x, int y);
void __cdecl do_mouse_action(int btn, int x, int y);
void __cdecl process_mouse(int btn, int x, int y);
void msToggle(); // idb
void mouse(); // idb
int __cdecl gpm_process_mouse(Gpm_Event_0 *event, void *data);
void movMs(); // idb
void menuMs(); // idb
void tabMs(); // idb
void closeTMs(); // idb
void dispVer(); // idb
void wrapToggle(); // idb
int __cdecl is_wordchar(int c, const char *badchars);
char *__cdecl getCurWord(Buffer *buf, int *spos, int *epos, const char *badchars);
char *__cdecl GetWord(Buffer *buf);
void __cdecl execdict(char *word);
void dictword(); // idb
void dictwordat(); // idb
void __cdecl set_buffer_environ(Buffer *buf);
char *searchKeyData(); // idb
int searchKeyNum(); // idb
void deleteFiles(); // idb
void __cdecl w3m_exit(int i);
void execCmd(); // idb
void __cdecl SigAlarm(int _dummy);
void setAlarm(); // idb
AlarmEvent *__cdecl setAlarmEvent(AlarmEvent *event, int sec, __int16 status, int cmd, void *data);
void reinit(); // idb
void defKey(); // idb
TabBuffer *newTab(); // idb
void newT(); // idb
void newT(); // idb
TabBuffer *__cdecl numTab(int n);
void calcTabPos(); // idb
TabBuffer *__cdecl deleteTab(TabBuffer *tab);
void closeT(); // idb
void nextT(); // idb
void prevT(); // idb
void __cdecl followTab(TabBuffer *tab);
void tabA(); // idb
void __cdecl tabURL0(TabBuffer *tab, char *prompt, int relative);
void tabURL(); // idb
void tabrURL(); // idb
void __cdecl moveTab(TabBuffer *t, TabBuffer *t2, int right);
void tabR(); // idb
void tabL(); // idb
void __cdecl addDownloadList(pid_t pid, char *url, char *save, char *lock, clen_t size);
int checkDownloadList(); // idb
char *__cdecl convert_size3(clen_t size);
Buffer *DownloadListBuffer(); // idb
void __cdecl download_action(parsed_tagarg *arg);
void stopDownload(); // idb
void ldDL(); // idb
void __cdecl save_buffer_position(Buffer *buf);
void __cdecl resetPos(BufferPos *b);
void undoPos(); // idb
void redoPos(); // idb
void __cdecl KeyAbort(int _dummy);
void __cdecl UFhalfclose(URLFile *f);
int __cdecl currentLn(Buffer *buf);
Buffer *__cdecl loadSomething(URLFile *f, char *path, Buffer *(*loadproc)(URLFile *, Buffer *), Buffer *defaultbuf);
int __cdecl dir_exist(char *path);
int __cdecl is_dump_text_type(char *type);
int __cdecl is_text_type(char *type);
int __cdecl is_plain_text_type(char *type);
int __cdecl is_html_type(char *type);
void __cdecl check_compression(char *path, URLFile *uf);
char *__cdecl compress_application_type(int compression);
char *__cdecl uncompressed_file_type(char *path, char **ext);
int __cdecl setModtime(char *path, time_t modtime);
void __cdecl examineFile(char *path, URLFile *uf);
int __cdecl check_command(char *cmd, int auxbin_p);
char *acceptableEncoding(); // idb
Str __cdecl convertLine(URLFile *uf, Str line, int mode, wc_ces *charset, wc_ces doc_charset);
Buffer *__cdecl loadFile(char *path);
int __cdecl matchattr(char *p, char *attr, int len, Str *value);
char *__cdecl xface2xpm(char *xface);
void __cdecl readHeader(URLFile *uf, Buffer *newBuf, int thru, ParsedURL *pu);
char *__cdecl checkHeader(Buffer *buf, char *field);
char *__cdecl checkContentType(Buffer *buf);
int __cdecl skip_auth_token(char **pp);
Str __cdecl extract_auth_val(char **q);
Str __cdecl qstr_unquote(Str s);
char *__cdecl extract_auth_param(char *q, auth_param *auth);
Str __cdecl get_auth_param(auth_param *auth, char *name);
Str __cdecl AuthBasicCred(http_auth *ha, Str uname, Str pw, ParsedURL *pu, HRequest *hr, FormList *request);
http_auth *__cdecl findAuthentication(http_auth *hauth, Buffer *buf, char *auth_field);
void __cdecl getAuthCookie(http_auth *hauth, char *auth_header, TextList *extra_header, ParsedURL *pu, HRequest *hr, FormList *request, volatile Str *uname, volatile Str *pwd);
int __cdecl same_url_p(ParsedURL *pu1, ParsedURL *pu2);
int __cdecl checkRedirection(ParsedURL *pu);
Buffer *__cdecl loadGeneralFile(char *path, ParsedURL *volatile current, char *referer, int flag, FormList *volatile request);
char *__cdecl has_hidden_link(readbuffer *obuf, int cmd);
void __cdecl push_link(int cmd, int offset, int pos);
int __cdecl is_period_char(unsigned __int8 *ch_0);
int __cdecl is_beginning_char(unsigned __int8 *ch_0);
int __cdecl is_word_char(unsigned __int8 *ch_0);
int __cdecl is_combining_char(unsigned __int8 *ch_0);
int __cdecl is_boundary(unsigned __int8 *ch1, unsigned __int8 *ch2);
void __cdecl set_breakpoint(readbuffer *obuf, int tag_length);
void __cdecl back_to_breakpoint(readbuffer *obuf);
void __cdecl append_tags(readbuffer *obuf);
void __cdecl push_tag(readbuffer *obuf, char *cmdname, int cmd);
void __cdecl push_nchars(readbuffer *obuf, int width, char *str, int len, Lineprop mode);
void __cdecl check_breakpoint(readbuffer *obuf, int pre_mode, char *ch_0);
void __cdecl push_char(readbuffer *obuf, int pre_mode, char ch_0);
void __cdecl push_spaces(readbuffer *obuf, int pre_mode, int width);
void __cdecl proc_mchar(readbuffer *obuf, int pre_mode, int width, char **str, Lineprop mode);
void __cdecl push_render_image(Str str, int width, int limit, html_feed_environ *h_env);
int __cdecl sloppy_parse_line(char **str);
void __cdecl passthrough(readbuffer *obuf, char *str, int back);
void __cdecl fillline(readbuffer *obuf, int indent);
void __cdecl flushline(html_feed_environ *h_env, readbuffer *obuf, int indent, int force, int width);
void __cdecl do_blankline(html_feed_environ *h_env, readbuffer *obuf, int indent, int indent_incr, int width);
void __cdecl purgeline(html_feed_environ *h_env);
int __cdecl close_effect0(readbuffer *obuf, int cmd);
void __cdecl close_anchor(html_feed_environ *h_env, readbuffer *obuf);
void __cdecl save_fonteffect(html_feed_environ *h_env, readbuffer *obuf);
void __cdecl restore_fonteffect(html_feed_environ *h_env, readbuffer *obuf);
Str __cdecl process_title(parsed_tag *tag);
Str __cdecl process_n_title(parsed_tag *tag);
void __cdecl feed_title(char *str);
Str __cdecl process_img(parsed_tag *tag, int width);
Str __cdecl process_anchor(parsed_tag *tag, char *tagbuf);
Str __cdecl process_input(parsed_tag *tag);
Str __cdecl process_select(parsed_tag *tag);
Str process_n_select(); // idb
void __cdecl feed_select(char *str);
void process_option(); // idb
Str __cdecl process_textarea(parsed_tag *tag, int width);
Str process_n_textarea(); // idb
void __cdecl feed_textarea(char *str);
Str __cdecl process_hr(parsed_tag *tag, int width, int indent_width);
char *__cdecl check_charset(char *p);
char *__cdecl check_accept_charset(char *ac);
Str __cdecl process_form_int(parsed_tag *tag, int fid);
Str __cdecl process_form(parsed_tag *tag);
Str process_n_form(); // idb
void __cdecl clear_ignore_p_flag(int cmd, readbuffer *obuf);
void __cdecl set_alignment(readbuffer *obuf, parsed_tag *tag);
void __cdecl process_idattr(readbuffer *obuf, int cmd, parsed_tag *tag);
int __cdecl ul_type(parsed_tag *tag, int default_type);
int __cdecl getMetaRefreshParam(char *q, Str *refresh_uri);
int __cdecl HTMLtagproc1(parsed_tag *tag, html_feed_environ *h_env);
Str textlist_feed(); // idb
int __cdecl ex_efct(int ex);
void __cdecl HTMLlineproc2body(Buffer *buf, Str (*feed)(...), int llimit);
void __cdecl addLink(Buffer *buf, parsed_tag *tag);
void __cdecl HTMLlineproc2(Buffer *buf, TextLineList *tl);
Str file_feed(); // idb
void __cdecl HTMLlineproc3(Buffer *buf, InputStream stream);
void __cdecl proc_escape(readbuffer *obuf, char **str_return);
int __cdecl need_flushline(html_feed_environ *h_env, readbuffer *obuf, Lineprop mode);
int __cdecl table_width(html_feed_environ *h_env, int table_level);
void __cdecl HTMLlineproc0(char *line, html_feed_environ *h_env, int internal);
void __cdecl addnewline2(Buffer *buf, char *line, Lineprop *prop, Linecolor *color, int pos, int nlines);
void __cdecl addnewline(Buffer *buf, char *line, Lineprop *prop, Linecolor *color, int pos, int width, int nlines);
Buffer *__cdecl loadHTMLBuffer(URLFile *f, Buffer *newBuf);
char *__cdecl convert_size(clen_t size, int usefloat);
char *__cdecl convert_size2(clen_t size1, clen_t size2, int usefloat);
void __cdecl showProgress(clen_t *linelen, clen_t *trbyte);
void __cdecl init_henv(html_feed_environ *h_env, readbuffer *obuf, environment *envs, int nenv, TextLineList *buf, int limit, int indent);
void __cdecl completeHTMLstream(html_feed_environ *h_env, readbuffer *obuf);
void __cdecl print_internal_information(html_feed_environ *henv);
void __cdecl loadHTMLstream(URLFile *f, Buffer *newBuf, FILE *src, int internal);
Buffer *__cdecl loadHTMLString(Str page);
Str __cdecl loadGopherDir(URLFile *uf, ParsedURL *pu, wc_ces *charset);
Buffer *__cdecl loadBuffer(URLFile *uf, Buffer *volatile newBuf);
Buffer *__cdecl loadImageBuffer(URLFile *uf, Buffer *newBuf);
Str __cdecl conv_symbol(Line *l);
void __cdecl saveBuffer(Buffer *buf, Line *l, FILE *f, int cont);
void __cdecl saveBuffer(Buffer *buf, FILE *f, int cont);
void __cdecl saveBufferBody(Buffer *buf, FILE *f, int cont);
Buffer *__cdecl loadcmdout(char *cmd, Buffer *(*loadproc)(URLFile *, Buffer *), Buffer *defaultbuf);
Buffer *__cdecl getshell(char *cmd);
Buffer *__cdecl getpipe(char *cmd);
Buffer *__cdecl openPagerBuffer(InputStream stream, Buffer *buf);
Buffer *__cdecl openGeneralPagerBuffer(InputStream stream);
Line *__cdecl getNextPage(Buffer *buf, int plen);
int __cdecl save2tmp(URLFile uf, char *tmpf);
int __cdecl doExternal(URLFile uf, char *path, char *type, Buffer **bufp, Buffer *defaultbuf);
int __cdecl MoveFile(char *path1, char *path2);
int __cdecl doFileCopy(char *tmpf, char *defstr, int download);
int __cdecl doFileMove(char *tmpf, char *defstr);
int __cdecl doFileSave(URLFile uf, char *defstr);
int __cdecl checkCopyFile(char *path1, char *path2);
int __cdecl checkSaveFile(InputStream stream, char *path2);
int __cdecl checkOverWrite(char *path);
char *__cdecl inputAnswer(char *prompt);
void __cdecl uncompress_stream(URLFile *uf, char **src);
FILE *__cdecl lessopen_stream(char *path);
char *__cdecl guess_filename(char *file);
char *__cdecl guess_save_name(Buffer *buf, char *path);
Buffer *__cdecl newBuffer(int width);
Buffer *nullBuffer(); // idb
void __cdecl clearBuffer(Buffer *buf);
void __cdecl discardBuffer(Buffer *buf);
Buffer *__cdecl namedBuffer(Buffer *first, char *name);
Buffer *__cdecl deleteBuffer(Buffer *first, Buffer *delbuf);
Buffer *__cdecl replaceBuffer(Buffer *first, Buffer *delbuf, Buffer *newbuf);
Buffer *__cdecl nthBuffer(Buffer *firstbuf, int n);
void __cdecl writeBufferName(Buffer *buf, int n);
void __cdecl gotoLine(Buffer *buf, int n);
void __cdecl gotoRealLine(Buffer *buf, int n);
Buffer *__cdecl listBuffer(Buffer *top, Buffer *current);
Buffer *__cdecl selectBuffer(Buffer *firstbuf, Buffer *currentbuf, char *selectchar);
void __cdecl reshapeBuffer(Buffer *buf);
void __cdecl copyBuffer(Buffer *a, Buffer *b);
Buffer *__cdecl prevBuffer(Buffer *first, Buffer *buf);
int __cdecl writeBufferCache(Buffer *buf);
int __cdecl readBufferCache(Buffer *buf);
void effect_anchor_start(); // idb
void effect_anchor_end(); // idb
void effect_image_start(); // idb
void effect_image_end(); // idb
void effect_form_start(); // idb
void effect_form_end(); // idb
void effect_mark_start(); // idb
void effect_mark_end(); // idb
void effect_active_start(); // idb
void effect_active_end(); // idb
void effect_visited_start(); // idb
void effect_visited_end(); // idb
void fmTerm(); // idb
void fmInit(); // idb
Str __cdecl make_lastline_link(Buffer *buf, char *title, char *url);
Str __cdecl make_lastline_message(Buffer *buf);
void __cdecl displayBuffer(Buffer *buf, int mode);
void __cdecl drawAnchorCursor0(Buffer *buf, AnchorList *al_0, int hseq, int prevhseq, int tline, int eline, int active);
void __cdecl drawAnchorCursor(Buffer *buf);
void __cdecl redrawNLine(Buffer *buf, int n);
Line *__cdecl redrawLine(Buffer *buf, Line *l, int i);
Line *__cdecl redrawLineImage(Buffer *buf, Line *l, int i);
int __cdecl redrawLineRegion(Buffer *buf, Line *l, int i, int bpos, int epos);
void __cdecl do_effects(Lineprop m);
void __cdecl do_color(Linecolor c);
void __cdecl addChar(char c, Lineprop mode);
void __cdecl addMChar(char *p, Lineprop mode, size_t len);
void __cdecl record_err_message(char *s);
Buffer *message_list_panel(); // idb
void __cdecl message(char *s, int return_x, int return_y);
void __cdecl _ZN10bdInetAddrC2Ej(char *s, int redraw_current);
void __cdecl disp_message_nsec(char *s, int redraw_current, int sec, int purge, int mouse);
void __cdecl disp_message(char *s, int redraw_current);
void __cdecl disp_message_nomouse(char *s, int redraw_current);
void __cdecl set_delayed_message(char *s);
void __cdecl cursorUp0(Buffer *buf, int n);
void __cdecl cursorUp(Buffer *buf, int n);
void __cdecl cursorDown0(Buffer *buf, int n);
void __cdecl cursorDown(Buffer *buf, int n);
void __cdecl cursorUpDown(Buffer *buf, int n);
void __cdecl cursorRight(Buffer *buf, int n);
void __cdecl cursorLeft(Buffer *buf, int n);
void __cdecl cursorHome(Buffer *buf);
void __cdecl arrangeCursor(Buffer *buf);
void __cdecl arrangeLine(Buffer *buf);
void __cdecl cursorXY(Buffer *buf, int x, int y);
void __cdecl restorePosition(Buffer *buf, Buffer *orig);
int __cdecl columnSkip(Buffer *buf, int offset);
int __cdecl columnPos(Line *line, int column);
Line *__cdecl lineSkip(Buffer *buf, Line *line, int offset, int last);
Line *__cdecl currentLineSkip(Buffer *buf, Line *line, int offset, int last);
int __cdecl gethtmlcmd(char **s);
int __cdecl parse_ansi_color(char **str, Lineprop *effect, Linecolor *color);
Str __cdecl checkType(Str s, Lineprop **oprop, Linecolor **ocolor);
int __cdecl nextColumn(int n, char *p, Lineprop *pr);
int __cdecl calcPosition(char *l, Lineprop *pr, int len, int pos, int bpos, int mode);
int __cdecl columnLen(Line *line, int column);
char *__cdecl lastFileName(char *path);
char *__cdecl mybasename(char *s);
char *__cdecl mydirname(char *s);
int __cdecl next_status(char c, int *status);
int __cdecl read_token(Str buf, char **instr, int *status, int pre, int append);
Str __cdecl correct_irrtag(int status);
void __cdecl add_auth_pass_entry(const auth_pass *ent, int netrc, int override);
auth_pass *__cdecl find_auth_pass_entry(char *host, int port, char *realm, char *uname, int is_proxy);
int __cdecl find_auth_user_passwd(ParsedURL *pu, char *realm, Str *uname, Str *pwd, int is_proxy);
void __cdecl add_auth_user_passwd(ParsedURL *pu, char *realm, Str uname, Str pwd, int is_proxy);
void __cdecl invalidate_auth_user_passwd(ParsedURL *pu, char *realm, Str uname, Str pwd, int is_proxy);
Str __cdecl next_token(Str arg);
void __cdecl parsePasswd(FILE *fp, int netrc);
FILE *__cdecl openSecretFile(char *fname);
void loadPasswd(); // idb
char *__cdecl last_modified(Buffer *buf);
Str __cdecl romanNum2(int l, int n);
Str __cdecl romanNumeral(int n);
Str __cdecl romanAlphabet(int n);
void reset_signals(); // idb
void __cdecl close_all_fds_except(int i, int f);
void __cdecl setup_child(int child, int i, int f);
pid_t __cdecl open_pipe_rw(FILE **fr, FILE **fw);
void __cdecl __noreturn myExec(char *command);
void __cdecl mySystem(char *command, int background);
Str __cdecl myExtCommand(char *cmd, char *arg, int redirect);
Str __cdecl myEditor(char *cmd, char *file, int line);
char *__cdecl expandName(char *name);
char *__cdecl file_to_url(char *file);
char *__cdecl url_unquote_conv(char *url, wc_ces charset);
Str __cdecl tmpfname(int type, char *ext);
int __cdecl get_day(char **s);
int __cdecl get_month(char **s);
int __cdecl get_year(char **s);
int __cdecl get_time(char **s, int *hour, int *min, int *sec);
int __cdecl get_zone(char **s, int *z_hour, int *z_min);
time_t __cdecl mymktime(char *timestr);
char *__cdecl FQDN(char *host);
void (*__cdecl mySignal(int signal_number, void (*action)(int)))(int);
void __cdecl set_mark(Line *l, int pos, int epos);
void init_migemo(); // idb
int __cdecl open_migemo(char *migemo_command);
char *__cdecl migemostr(char *str);
char *__cdecl conv_search_string(char *str, wc_ces f_ces);
int __cdecl forwardSearch(Buffer *buf, char *str);
int __cdecl backwardSearch(Buffer *buf, char *str);
char *__cdecl inputLineHistSearch(char *prompt, char *def_str, int flag, Hist *hist, int (*incrfunc)(int, Str, Lineprop *));
void __cdecl addPasswd(char *p, Lineprop *pr, int len, int offset, int limit);
void __cdecl addStr(char *p, Lineprop *pr, int len, int offset, int limit);
void __cdecl ins_char(Str str);
void esc(); // idb
void insC(); // idb
void delC(); // idb
void mvL(); // idb
void mvLw(); // idb
void mvRw(); // idb
void mvR(); // idb
void bs(); // idb
void bsw(); // idb
void enter(); // idb
void __cdecl insertself(char c);
void quo(); // idb
void mvB(); // idb
void mvE(); // idb
void killn(); // idb
void killb(); // idb
void inbrk(); // idb
void compl(); // idb
void rcompl(); // idb
void tcompl(); // idb
void __cdecl next_compl(int next);
void dcompl(); // idb
void rdcompl(); // idb
void __cdecl next_dcompl(int next);
Str __cdecl escape_spaces(Str s);
Str __cdecl unescape_spaces(Str s);
Str __cdecl doComplete(Str ifn, int *status, int next);
void prev(); // idb
void next(); // idb
int __cdecl setStrType(Str str, Lineprop *prop);
int __cdecl terminated(unsigned __int8 c);
void editor(); // idb
int __cdecl LUfactor(Matrix A, int *indexarray);
int __cdecl LUsolve(Matrix A, int *indexarray, Vector b, Vector x);
Matrix __cdecl LUinverse(Matrix A, int *indexarray, Matrix out);
int __cdecl Usolve(Matrix mat, Vector b, Vector out, double diag);
int __cdecl Lsolve(Matrix mat, Vector b, Vector out, double diag);
Matrix __cdecl new_matrix(int n);
Vector __cdecl new_vector(int n);
double __cdecl weight(int x);
double __cdecl weight2(int a);
int __cdecl bsearch_2short(__int16 e1, __int16 *ent1, __int16 e2, __int16 *ent2, int base, __int16 *indexarray, int nent);
int __cdecl bsearch_double(double e, double *ent, __int16 *indexarray, int nent);
int __cdecl ceil_at_intervals(int x, int step);
int __cdecl floor_at_intervals(int x, int step);
int __cdecl table_colspan(table *t, int row, int col);
int __cdecl table_rowspan(table *t, int row, int col);
int __cdecl minimum_cellspacing(int border_mode);
int __cdecl table_border_width(table *t);
table *newTable(); // idb
void __cdecl check_row(table *t, int row);
void __cdecl pushdata(table *t, int row, int col, char *data);
void __cdecl suspend_or_pushdata(table *tbl, char *line);
int __cdecl visible_length(char *str);
int __cdecl visible_length_plain(char *str);
int __cdecl maximum_visible_length(char *str, int offset);
int __cdecl maximum_visible_length_plain(char *str, int offset);
void __cdecl align(TextLine *lbuf, int width, int mode);
void __cdecl print_item(table *t, int row, int col, int width, Str buf);
void __cdecl print_sep(table *t, int row, int type, int maxcol, Str buf);
int __cdecl get_spec_cell_width(table *tbl, int row, int col);
void __cdecl do_refill(table *tbl, int row, int col, int maxlimit);
int __cdecl table_rule_width(table *t);
void __cdecl check_cell_width(__int16 *tabwidth, __int16 *cellwidth, __int16 *col, __int16 *colspan, __int16 maxcell, __int16 *indexarray, int space, int dir);
void __cdecl check_minimum_width(table *t, __int16 *tabwidth);
void __cdecl check_maximum_width(table *t);
void __cdecl set_integered_width(table *t, double *dwidth, __int16 *iwidth);
double __cdecl correlation_coefficient(double sxx, double syy, double sxy);
double __cdecl correlation_coefficient2(double sxx, double syy, double sxy);
double __cdecl recalc_width(double old, double swidth, int cwidth, double sxx, double syy, double sxy, int is_inclusive);
int __cdecl check_compressible_cell(table *t, MAT *minv, double *newwidth, double *swidth, __int16 *cwidth, double totalwidth, double *Sxx, int icol, int icell, double sxx, int corr);
int __cdecl check_table_width(table *t, double *newwidth, MAT *minv, int itr);
void __cdecl check_table_height(table *t);
int __cdecl get_table_width(table *t, __int16 *orgwidth, __int16 *cellwidth, int flag);
void __cdecl renderCoTable(table *tbl, int maxlimit);
void __cdecl make_caption(table *t, html_feed_environ *h_env);
void __cdecl renderTable(table *t, int max_width, html_feed_environ *h_env);
table *__cdecl begin_table(int border, int spacing, int padding, int vspace);
void __cdecl end_table(table *tbl);
void __cdecl check_minimum0(table *t, int min);
int __cdecl setwidth0(table *t, table_mode *mode);
void __cdecl setwidth(table *t, table_mode *mode);
void __cdecl addcontentssize(table *t, int width);
void __cdecl clearcontentssize(table *t, table_mode *mode);
void __cdecl begin_cell(table *t, table_mode *mode);
void __cdecl check_rowcol(table *tbl, table_mode *mode);
int __cdecl skip_space(table *t, char *line, table_linfo *linfo, int checkminimum);
void __cdecl feed_table_inline_tag(table *tbl, char *line, table_mode *mode, int width);
void __cdecl feed_table_block_tag(table *tbl, char *line, table_mode *mode, int indent, int cmd);
void __cdecl table_close_select(table *tbl, table_mode *mode, int width);
void __cdecl table_close_textarea(table *tbl, table_mode *mode, int width);
void __cdecl table_close_anchor0(table *tbl, table_mode *mode);
int __cdecl feed_table_tag(table *tbl, char *line, table_mode *mode, int width, parsed_tag *tag);
int __cdecl feed_table(table *tbl, char *line, table_mode *mode, int width, int internal);
void __cdecl feed_table1(table *tbl, Str tok, table_mode *mode, int width);
void __cdecl pushTable(table *tbl, table *tbl1);
int __cdecl correct_table_matrix(table *t, int col, int cspan, int a, double b);
void __cdecl correct_table_matrix2(table *t, int col, int cspan, double s, double b);
void __cdecl correct_table_matrix3(table *t, int col, char *flags, double s, double b);
void __cdecl correct_table_matrix4(table *t, int col, int cspan, char *flags, double s, double b);
void __cdecl set_table_matrix0(table *t, int maxwidth);
void __cdecl check_relative_width(table *t, int maxwidth);
void __cdecl set_table_matrix(table *t, int width);
void writeLocalCookie(); // idb
Str localCookie(); // idb
Str __cdecl loadLocalDir(char *dname);
int __cdecl check_local_cgi(char *file, int status);
void __cdecl set_environ(char *var, char *value);
void __cdecl set_cgi_environ(char *name, char *fn, char *req_uri);
Str __cdecl checkPath(char *fn, char *path);
int __cdecl cgi_filename(char *uri, char **fn, char **name, char **path_info);
FILE *__cdecl localcgi_post(char *uri, char *qstr, FormList *request, char *referer);
form_list *__cdecl newFormList(char *action, char *method, char *charset, char *enctype, char *target, char *name, form_list *_next);
form_item_list *__cdecl formList_addInput(form_list *fl, parsed_tag *tag);
char *__cdecl form2str(FormItemList *fi);
int __cdecl formtype(char *typestr);
void __cdecl formRecheckRadio(Anchor *a, Buffer *buf, FormItemList *fi);
void __cdecl formResetBuffer(Buffer *buf, AnchorList *formitem);
int __cdecl form_update_line(Line *line, char **str, int spos, int epos, int width, int newline, int password);
void __cdecl formUpdateBuffer(Anchor *a, Buffer *buf, FormItemList *form);
Str __cdecl textfieldrep(Str s, int width);
void __cdecl form_fputs_decode(Str s, FILE *f);
void __cdecl input_textarea(FormItemList *fi);
void __cdecl do_internal(char *action, char *data);
void __cdecl addSelectOption(FormSelectOption *fso, Str value, Str label, int chk);
void __cdecl chooseSelectOption(FormItemList *fi, FormSelectOptionItem *item);
void __cdecl updateSelectOption(FormItemList *fi, FormSelectOptionItem *item);
int __cdecl formChooseOptionByMenu(form_item_list *fi, int x, int y);
void __cdecl form_write_data(FILE *f, char *boundary, char *name, char *value);
void __cdecl form_write_from_file(FILE *f, char *boundary, char *name, char *filename, char *file);
pre_form *__cdecl add_pre_form(pre_form *prev, char *url, char *name, char *action);
pre_form_item *__cdecl add_pre_form_item(pre_form *pf_0, pre_form_item *prev, int type, char *name, char *value, char *checked);
void loadPreForm(); // idb
void __cdecl preFormUpdateBuffer(Buffer *buf);
MapList *__cdecl searchMapList(Buffer *buf, char *name);
int __cdecl inMapArea(MapArea *a, int x, int y);
int __cdecl nearestMapArea(MapList *ml, int x, int y);
int __cdecl searchMapArea(Buffer *buf, MapList *ml, Anchor *a_img);
MapArea *__cdecl retrieveCurrentMapArea(Buffer *buf);
int __cdecl getMapXY(Buffer *buf, Anchor *a, int *x, int *y);
Anchor *__cdecl retrieveCurrentMap(Buffer *buf);
MapArea *__cdecl follow_map_menu(Buffer *buf, char *name, Anchor *a_img, int x, int y);
MapArea *__cdecl newMapArea(char *url, char *target, char *alt, char *shape, char *coords);
void __cdecl append_map_info(Buffer *buf, Str tmp, FormItemList *fi);
void __cdecl append_link_info(Buffer *buf, Str html, LinkList *link);
void __cdecl append_frame_info(Buffer *buf, Str html, frameset *set, int level);
Buffer *__cdecl page_info_panel(Buffer *buf);
void __cdecl KeyAbort_0(int _dummy);
int __cdecl parseFrameSetLength(char *s, char ***ret);
frameset *__cdecl newFrameSet(parsed_tag *tag);
frame_body *__cdecl newFrame(parsed_tag *tag, Buffer *buf);
void __cdecl unloadFrame(frame_body *b);
void __cdecl deleteFrame(frame_body *b);
void __cdecl addFrameSetElement(frameset *f, frameset_element element);
void __cdecl deleteFrameSet(frameset *f);
void __cdecl deleteFrameSetElement(frameset_element e);
frame_body *__cdecl copyFrame(frame_body *ob);
frameset *__cdecl copyFrameSet(frameset *of_0);
void __cdecl flushFrameSet(frameset *fs_0);
void __cdecl pushFrameTree(frameset_queue **fqpp, frameset *fs_0, Buffer *buf);
frameset *__cdecl popFrameTree(frameset_queue **fqpp);
void __cdecl resetFrameElement(frameset_element *f_element, Buffer *buf, char *referer, FormList *request);
frameset *__cdecl frame_download_source(frame_body *b, ParsedURL *currentURL, ParsedURL *baseURL, int flag);
int __cdecl createFrameFile(frameset *f, FILE *f1, Buffer *current, int level, int force_reload);
Buffer *__cdecl renderFrame(Buffer *Cbuf, int force_reload);
frameset_element *__cdecl search_frame(frameset *fset, char *name);
int __cdecl compare_table(rc_search_table *a, rc_search_table *b);
void create_option_search_table(); // idb
param_ptr *__cdecl search_param(char *name);
void __cdecl show_params(FILE *fp);
int __cdecl str_to_bool(char *value, int old);
int __cdecl str_to_color(char *value);
int __cdecl set_param(char *name, char *value);
int __cdecl set_param_option(char *option);
char *__cdecl get_param_option(char *name);
void __cdecl interpret_rc(FILE *f);
void parse_proxy(); // idb
void parse_cookie(); // idb
void sync_with_option(); // idb
void init_rc(); // idb
Str __cdecl to_str(param_ptr *p);
Buffer *load_option_panel(); // idb
void __cdecl panel_set_option(parsed_tagarg *arg);
char *__cdecl rcFile(char *base);
char *__cdecl auxbinFile(char *base);
char *__cdecl etcFile(char *base);
char *__cdecl confFile(char *base);
void __cdecl new_menu(Menu *menu, MenuItem *item);
void __cdecl geom_menu(Menu *menu, int x, int y, int mselect);
void __cdecl draw_all_menu(Menu *menu);
void __cdecl draw_menu(Menu *menu);
void __cdecl draw_menu_item(Menu *menu, int mselect);
int __cdecl select_menu(Menu *menu, int mselect);
void __cdecl goto_menu(Menu *menu, int mselect, int down);
void __cdecl up_menu(Menu *menu, int n);
void __cdecl down_menu(Menu *menu, int n);
int __cdecl action_menu(Menu *menu);
void __cdecl popup_menu(Menu *parent, Menu *menu);
void __cdecl guess_menu_xy(Menu *parent, int width, int *x, int *y);
void __cdecl new_option_menu(Menu *menu, char **label, int *variable, void (*func)(...));
void set_menu_frame(); // idb
int __cdecl mEsc(char c);
int __cdecl mEscB(char c);
int __cdecl mEscD(char c);
int __cdecl mNull(char c);
int __cdecl mSelect(char c);
int __cdecl mDown(char c);
int __cdecl mUp(char c);
int __cdecl mLast(char c);
int __cdecl mTop(char c);
int __cdecl mNext(char c);
int __cdecl mPrev(char c);
int __cdecl mFore(char c);
int __cdecl mBack(char c);
int __cdecl mLineU(char c);
int __cdecl mLineD(char c);
int __cdecl mOk(char c);
int __cdecl mCancel(char c);
int __cdecl mClose(char c);
int __cdecl mSusp(char c);
int __cdecl menuForwardSearch(Menu *menu, char *str, int from);
int __cdecl menu_search_forward(Menu *menu, int from);
int __cdecl mSrchF(char c);
int __cdecl menuBackwardSearch(Menu *menu, char *str, int from);
int __cdecl menu_search_backward(Menu *menu, int from);
int __cdecl mSrchB(char c);
int __cdecl menu_search_next_previous(Menu *menu, int from, int reverse);
int __cdecl mSrchN(char c);
int __cdecl mSrchP(char c);
int mMouse_scroll_line(); // idb
int __cdecl process_mMouse(int btn, int x, int y);
int __cdecl mMouse(char c);
int __cdecl gpm_process_menu_mouse(Gpm_Event_0 *event, void *data);
void __cdecl popupMenu(int x, int y, Menu *menu);
void __cdecl find_nvp_node(int x, int y);
void mainMn(); // idb
void selMn(); // idb
void initSelectMenu(); // idb
void smChBuf(); // idb
int __cdecl smDelBuf(char c);
void tabMn(); // idb
void initSelTabMenu(); // idb
void smChTab(); // idb
int __cdecl smDelTab(char c);
void __cdecl optionMenu(int x, int y, char **label, int *variable, int initial, void (*func)(...));
void __cdecl interpret_menu(FILE *mf);
void initMenu(); // idb
int __cdecl setMenuItem(MenuItem *item, char *type, char *line);
int __cdecl addMenuList(MenuList **mlist, char *id);
int __cdecl getMenuN(MenuList *list, char *id);
LinkList *__cdecl link_menu(Buffer *buf);
Anchor *__cdecl accesskey_menu(Buffer *buf);
int __cdecl lmGoto(char c);
int __cdecl lmSelect(char c);
Anchor *__cdecl list_menu(Buffer *buf);
int __cdecl mailcapMatch(mailcap *mcap, char *type);
mailcap *__cdecl searchMailcap(mailcap *table, char *type);
int __cdecl matchMailcapAttr(char *p, char *attr, int len, Str *value);
int __cdecl extractMailcapEntry(char *mcap_entry, mailcap *mcap);
mailcap *__cdecl loadMailcap(char *filename);
void initMailcap(); // idb
char *acceptableMimeTypes(); // idb
mailcap *__cdecl searchExtViewer(char *type);
Str __cdecl quote_mailcap(char *s, int flag);
Str __cdecl unquote_mailcap_loop(char *qstr, char *type, char *name, char *attr, int *mc_stat, int flag0);
Str __cdecl cptifil(char *qstr, char *type, char *name, char *attr, int *mc_stat);
void initImage(); // idb
int getCharSize(); // idb
void termImage(); // idb
int openImgdisplay(); // idb
void closeImgdisplay(); // idb
void __cdecl addImage(ImageCache *cache, int x, int y, int sx, int sy, int w, int h);
void syncImage(); // idb
void drawImage(); // idb
void clearImage(); // idb
void __cdecl deleteImage(Buffer *buf);
void __cdecl getAllImage(Buffer *buf);
void __cdecl showImageProgress(Buffer *buf);
void __cdecl loadImage(Buffer *buf, int flag);
ImageCache *__cdecl getImage(Image *image, ParsedURL *current, int flag);
int __cdecl getImageSize(ImageCache *cache);
void __cdecl encode_symbol(symbol_set *s);
char **__cdecl get_symbol(wc_ces charset, int *width);
char **__cdecl set_symbol(int width);
void __cdecl push_symbol(Str str, char symbol, int width, int n);
char *__cdecl conv_entity(unsigned int c);
void __cdecl writestr(char *s);
int set_tty(); // idb
void __cdecl ttymode_set(int mode, int imode);
void __cdecl ttymode_reset(int mode, int imode);
void __cdecl set_cc(int spec, int val);
void close_tty(); // idb
char *ttyname_tty(); // idb
void reset_tty(); // idb
void __cdecl reset_exit(int _dummy);
void __cdecl error_dump(int _dummy);
void set_int(); // idb
void setgraphchar(); // idb
void getTCstr(); // idb
void setlinescols(); // idb
void setupscreen(); // idb
int initscr(); // idb
int __cdecl write1(char c);
void __cdecl move(int line, int column);
int __cdecl need_redraw_0(char *c1, l_prop pr1, char *c2, l_prop pr2);
void __cdecl addch(char c);
void __cdecl addmch(char *pc, size_t len);
void wrap(); // idb
void __cdecl touch_column(int col);
void touch_line(); // idb
void standout(); // idb
void standend(); // idb
void toggle_stand(); // idb
void bold(); // idb
void boldend(); // idb
void underline(); // idb
void underlineend(); // idb
void graphstart(); // idb
void graphend(); // idb
_BOOL4 graph_ok();
void __cdecl setfcolor(int color);
char *__cdecl color_seq(int colmode);
void __cdecl setbcolor(int color);
char *__cdecl bcolor_seq(int colmode);
void refresh(); // idb
void clear(); // idb
void clrtoeol(); // idb
void clrtoeol_with_bcolor(); // idb
void clrtoeolx(); // idb
void __cdecl clrtobot_eol(void (*clrtoeol)(...));
void clrtobot(); // idb
void clrtobotx(); // idb
void __cdecl addstr(char *s);
void __cdecl addnstr(char *s, int n);
void __cdecl addnstr_sup(char *s, int n);
void crmode(); // idb
void nocrmode(); // idb
void term_echo(); // idb
void term_noecho(); // idb
void term_raw(); // idb
void term_cooked(); // idb
void term_cbreak(); // idb
void __cdecl term_title(char *s);
int getch();
char __cdecl wgetch(void *p);
int do_getch(); // idb
void bell(); // idb
void skip_escseq(); // idb
int __cdecl sleep_till_anykey(int sec, int purge);
void mouse_init(); // idb
void mouse_end(); // idb
void mouse_active(); // idb
void mouse_inactive(); // idb
void flush_tty(); // idb
void touch_cursor(); // idb
table2 *__cdecl loadMimeTypes(char *filename);
void initMimeTypes(); // idb
char *__cdecl DefaultFile(int scheme);
void __cdecl KeyAbort_1(int _dummy);
void __cdecl write_from_file(int sock, char *file);
ParsedURL *__cdecl baseURL(Buffer *buf);
int __cdecl openSocket(char *const hostname, char *remoteport_name, unsigned __int16 remoteport_num);
char *__cdecl copyPath(char *orgpath, int length, int option);
void __cdecl parseURL(char *url, ParsedURL *p_url, ParsedURL *current);
void __cdecl copyParsedURL(ParsedURL *p, ParsedURL *q);
void __cdecl parseURL2(char *url, ParsedURL *pu, ParsedURL *current);
Str __cdecl parsedURL2Str(ParsedURL *pu, int pass);
Str __cdecl parsedURL2Str(ParsedURL *pu);
int __cdecl getURLScheme(char **url);
char *__cdecl otherinfo(ParsedURL *target, ParsedURL *current, char *referer);
Str __cdecl HTTPrequestMethod(HRequest *hr);
Str __cdecl HTTPrequestURI(ParsedURL *pu, HRequest *hr);
Str __cdecl HTTPrequest(ParsedURL *pu, ParsedURL *current, HRequest *hr, TextList *extra);
void __cdecl init_stream(URLFile *uf, int scheme, InputStream stream);
// URLFile *__userpurge openURL@<eax>(URLFile *retstr, char *url, ParsedURL *pu, ParsedURL *current, URLOption *option, FormList *request, TextList *extra_header, URLFile *ouf, HRequest *hr, unsigned __int8 *status);
void __cdecl add_index_file(ParsedURL *pu, URLFile *uf);
char *__cdecl guessContentTypeFromTable(table2 *table, char *filename);
char *__cdecl guessContentType(char *filename);
TextList *__cdecl make_domain_list(char *domain_list);
int __cdecl domain_match(char *pat, char *domain);
int __cdecl check_no_proxy(char *domain);
char *__cdecl filename_extension(char *path, int is_url);
table2 *__cdecl loadURIMethods(char *filename);
void initURIMethods(); // idb
Str __cdecl searchURIMethods(ParsedURL *pu);
void __cdecl chkExternalURIBuffer(Buffer *buf);
ParsedURL *__cdecl schemeToProxy(int scheme);
void __cdecl KeyAbort_2(int _dummy);
Str __cdecl ftp_command(FTP ftp, char *cmd, char *arg, int *status);
void __cdecl ftp_close(FTP ftp);
int __cdecl ftp_login(FTP ftp);
int __cdecl ftp_pasv(FTP ftp);
time_t __cdecl ftp_modtime(FTP ftp, char *path);
int __cdecl ftp_quit(FTP ftp);
void __cdecl closeFTPdata(FILE *f);
void closeFTP(); // idb
InputStream __cdecl openFTPStream(ParsedURL *pu, URLFile *uf);
Str __cdecl loadFTPDir(ParsedURL *pu, wc_ces *charset);
void disconnectFTP(); // idb
int __cdecl ex_ftpdir_name_size_date(char *line, char **name, char **link, char **date, char **sizep);
Str __cdecl size_int2str(clen_t size);
unsigned __int8 __cdecl c2e(char x);
int __cdecl ha2d(char x, char y);
Str __cdecl decodeB(char **ww);
Str __cdecl decodeU(char **ww);
Str __cdecl decodeQ(char **ww);
Str __cdecl decodeQP(char **ww);
Str __cdecl decodeWord(char **ow, wc_ces *charset);
Str __cdecl decodeMIME(Str orgstr, wc_ces *charset);
Str __cdecl encodeB(char *a);
longchar *set_longchar(longchar *__return_ptr __struct_ptr retstr, char *str);
char *__cdecl regexCompile(char *ex, int igncase);
Regex *__cdecl newRegex0(char **ex, int igncase, Regex *regex, char **msg, int level);
Regex *__cdecl newRegex(char *ex, int igncase, Regex *regex, char **msg);
int __cdecl __gmp_vfprintf(char *str, int len, int firstp);
int __cdecl RegexMatch(Regex *re, char *str, int len, int firstp);
void __cdecl MatchedPosition(Regex *re, char **first, char **last);
void __cdecl matchedPosition(char **first, char **last);
int __cdecl regmatch_sub_anytime(MatchingContext2 *c, Regex *regex, regexchar_0 *pat2, char *str, char *end_p, int iter_limit, int firstp);
int __cdecl regmatch_iter(MatchingContext1 *c, regexchar_0 *re, char *str, char *end_p, int firstp);
int __cdecl regmatch(regexchar_0 *re, char *str, char *end_p, int firstp, char **lastpos);
int __cdecl regmatch1(regexchar_0 *re, longchar *c);
int __cdecl matchWhich(longchar *pattern, longchar *c, int igncase);
int __cdecl match_longchar(longchar *a, longchar *b, int ignore);
int __cdecl match_range_longchar(longchar *a, longchar *b, longchar *c, int ignore);
void __cdecl KeyAbort_3(int _dummy);
Str __cdecl news_command(News *news, char *cmd, char *arg, int *status);
void __cdecl news_close(News *news);
int __cdecl news_open(News *news);
void __cdecl news_quit(News *news);
char *__cdecl name_from_address(char *str, int n);
char *__cdecl html_quote_s(char *str);
void __cdecl add_news_message(Str str, int index, char *date, char *name, char *subject, char *mid, char *scheme, char *group);
InputStream __cdecl openNewsStream(ParsedURL *pu);
Str __cdecl loadNewsgroup(ParsedURL *pu, wc_ces *charset);
void closeNews(); // idb
void disconnectNews(); // idb
void __cdecl setKeymap(char *p, int lineno, int verbose);
void __cdecl interpret_keymap(FILE *kf, stat *current, int force);
void __cdecl initKeymap(int force);
int __cdecl getFuncList(char *id);
char *__cdecl getKeyData(int key);
int __cdecl getKey2(char **str);
int __cdecl getKey(char *s);
char *__cdecl getWord(char **str);
char *__cdecl getQWord(char **str);
void __cdecl setMouseAction0(char **str, int *width, MouseActionMap **map, char *p);
void __cdecl setMouseAction1(MouseActionMap **map, int width, char *p);
void __cdecl setMouseAction2(MouseActionMap *map, char *p);
void __cdecl interpret_mouse_action(FILE *mf);
void initMouseAction(); // idb
int __cdecl total_dot_number(char *p, char *ep, int max_count);
char *__cdecl domain_match_0(char *host, char *domain);
portlist *__cdecl make_portlist(Str port);
Str __cdecl portlist2str(portlist *first);
int __cdecl port_match(portlist *first, int port);
void check_expired_cookies(); // idb
Str __cdecl make_cookie(cookie *cookie);
int __cdecl match_cookie(ParsedURL *pu, cookie *cookie, char *domainname);
cookie *__cdecl get_cookie_info(Str domain, Str path, Str name);
Str __cdecl find_cookie(ParsedURL *pu);
int __cdecl add_cookie(ParsedURL *pu, Str name, Str value, time_t expires, Str domain, Str path, int flag, Str comment, int version, Str port, Str commentURL);
cookie *__cdecl nth_cookie(int n);
void save_cookies(); // idb
Str __cdecl readcol(char **p);
void load_cookies(); // idb
void initCookie(); // idb
Buffer *cookie_list_panel(); // idb
void __cdecl set_cookie_flag(parsed_tagarg *arg);
int __cdecl check_cookie_accept_domain(char *domain);
Buffer *__cdecl historyBuffer(Hist *hist);
void __cdecl loadHistory(Hist *hist);
void __cdecl saveHistory(Hist *hist, size_t size);
Hist *newHist(); // idb
Hist *__cdecl copyHist(Hist *hist);
HistItem *__cdecl unshiftHist(Hist *hist, char *ptr);
HistItem *__cdecl pushHist(Hist *hist, char *ptr);
HistItem *__cdecl pushHashHist(Hist *hist, char *ptr);
HistItem *__cdecl getHashHist(Hist *hist, char *ptr);
char *__cdecl lastHist(Hist *hist);
char *__cdecl nextHist(Hist *hist);
char *__cdecl prevHist(Hist *hist);
void __cdecl print_headers(Buffer *buf, int len);
void __cdecl internal_get(char *url, int flag, FormList *request);
void __cdecl get(TextList *argv);
void __cdecl post(TextList *argv);
void __cdecl set(TextList *argv);
void __cdecl show(TextList *argv);
void __cdecl quit(TextList *argv);
void __cdecl help(TextList *argv);
void __cdecl set_column(TextList *argv);
void __cdecl show_column(TextList *argv);
void __cdecl call_command_function(char *str);
void __noreturn backend();
char *__cdecl readline(char *prompt);
TextList *__cdecl split(char *p);
AnchorList *__cdecl putAnchor(AnchorList *al_0, char *url, char *target, Anchor **anchor_return, char *referer, char *title, unsigned __int8 key, int line, int pos);
Anchor *__cdecl registerHref(Buffer *buf, char *url, char *target, char *referer, char *title, unsigned __int8 key, int line, int pos);
Anchor *__cdecl registerName(Buffer *buf, char *url, int line, int pos);
Anchor *__cdecl registerImg(Buffer *buf, char *url, char *title, int line, int pos);
Anchor *__cdecl registerForm(Buffer *buf, FormList *flist, parsed_tag *tag, int line, int pos);
int __cdecl onAnchor(Anchor *a, int line, int pos);
Anchor *__cdecl retrieveAnchor(AnchorList *al_0, int line, int pos);
Anchor *__cdecl retrieveCurrentAnchor(Buffer *buf);
Anchor *__cdecl retrieveCurrentImg(Buffer *buf);
Anchor *__cdecl retrieveCurrentForm(Buffer *buf);
Anchor *__cdecl searchAnchor(AnchorList *al_0, char *str);
Anchor *__cdecl searchURLLabel(Buffer *buf, char *url);
Anchor *__cdecl put_anchor_news(Buffer *buf, char *p1, char *p2, int line, int pos);
Anchor *__cdecl put_anchor_all(Buffer *buf, char *p1, char *p2, int line, int pos);
void __cdecl reseq_anchor0(AnchorList *al_0, __int16 *seqmap);
void __cdecl reseq_anchor(Buffer *buf);
char *__cdecl reAnchorPos(Buffer *buf, Line *l, char *p1, char *p2, Anchor *(*anchorproc)(Buffer *, char *, char *, int, int));
void __cdecl reAnchorWord(Buffer *buf, Line *l, int spos, int epos);
char *__cdecl reAnchorAny(Buffer *buf, char *re, Anchor *(*anchorproc)(Buffer *, char *, char *, int, int));
char *__cdecl find_nvp_node_0(Buffer *buf, char *re);
char *__cdecl find_nvp_node_1(Buffer *buf, char *re);
char *__cdecl reAnchorNewsheader(Buffer *buf);
HmarkerList *__cdecl putHmarker(HmarkerList *ml, int line, int pos, int seq);
Anchor *__cdecl closest_next_anchor(AnchorList *a, Anchor *an, int x, int y);
Anchor *__cdecl closest_prev_anchor(AnchorList *a, Anchor *an, int x, int y);
void __cdecl shiftAnchorPosition(AnchorList *al_0, HmarkerList *hl, int line, int pos, int shift);
void __cdecl addMultirowsImg(Buffer *buf, AnchorList *al_0);
void __cdecl addMultirowsForm(Buffer *buf, AnchorList *al_0);
char *__cdecl getAnchorText(Buffer *buf, AnchorList *al_0, Anchor *a);
Buffer *__cdecl link_list_panel(Buffer *buf);
int __cdecl noConv(char *oval, char **str);
int __cdecl toNumber(char *oval, int *num);
int __cdecl toLength(char *oval, int *len);
int __cdecl toAlign(char *oval, int *align);
int __cdecl toVAlign(char *oval, int *valign);
parsed_tag *__cdecl parse_tag(char **s, int internal);
int __cdecl parsedtag_set_value(parsed_tag *tag, int id, char *value);
int __cdecl parsedtag_get_value(parsed_tag *tag, int id, void *value);
Str __cdecl parsedtag2str(parsed_tag *tag);
void __cdecl do_update(BaseStream base);
int __cdecl buffer_read(StreamBuffer sb, char *obuf, int count);
void __cdecl init_buffer(BaseStream base, char *buf, int bufsize);
void __cdecl jzero_far(BaseStream base, int bufsize);
void __cdecl savexmlstr(BaseStream base, Str s);
InputStream __cdecl newInputStream(int des);
InputStream __cdecl newFileStream(FILE *f, void (*closep)(...));
InputStream __cdecl newStrStream(Str s);
InputStream __cdecl newEncodedStream(InputStream is, char encoding);
int __cdecl ISclose(InputStream stream);
int __cdecl ISgetc(InputStream stream);
int __cdecl ISundogetc(InputStream stream);
Str __cdecl StrISgets(InputStream stream);
Str __cdecl StrmyISgets(InputStream stream);
int __cdecl ISread(InputStream stream, Str buf, int count);
int __cdecl ISfileno(InputStream stream);
int __cdecl ISeos(InputStream stream);
void __cdecl basic_close(int *handle);
int __cdecl basic_read(int *handle, char *buf, int len);
void __cdecl file_close(file_handle *handle);
int __cdecl file_read(file_handle *handle, char *buf, int len);
int __cdecl str_read(Str handle, char *buf, int len);
void __cdecl ens_close(ens_handle *handle);
int __cdecl ens_read(ens_handle *handle, char *buf, int len);
Str Strnew(); // idb
Str __cdecl Strnew_size(int n);
Str __cdecl Strnew_charp(char *p);
Str Strnew_m_charp(char *p, ...);
Str __cdecl Strnew_charp_n(char *p, int n);
Str __cdecl Strdup(Str s);
void __cdecl Strclear(Str s);
void __cdecl Strfree(Str x);
void __cdecl Strcopy(Str x, Str y);
void __cdecl Strcopy_charp(Str x, char *y);
void __cdecl Strcopy_charp_n(Str x, char *y, int n);
void __cdecl Strcat_charp_n(Str x, char *y, int n);
void __cdecl savexmlstr_0(Str x, Str y);
void __cdecl Strcat_charp(Str x, char *y);
void Strcat_m_charp(Str x, ...);
void __cdecl Strgrow(Str x);
Str __cdecl Strsubstr(Str s, int beg, int len);
void __cdecl Strlower(Str s);
void __cdecl Strupper(Str s);
void __cdecl Strchop(Str s);
void __cdecl Strinsert_char(Str s, int pos, char c);
void __cdecl Strinsert_charp(Str s, int pos, char *p);
void __cdecl Strdelete(Str s, int pos, int n);
void __cdecl Strtruncate(Str s, int pos);
void __cdecl Strshrink(Str s, int n);
void __cdecl Strremovefirstspaces(Str s);
void __cdecl Strremovetrailingspaces(Str s);
Str __cdecl Stralign_left(Str s, int width);
Str __cdecl Stralign_right(Str s, int width);
Str __cdecl Stralign_center(Str s, int width);
Str Sprintf(char *fmt, ...);
Str __cdecl Strfgets(FILE *f);
Str __cdecl Strfgetall(FILE *f);
clen_t __cdecl strtoclen(const char *s);
char *__cdecl allocStr(const char *s, int len);
int __cdecl strCmp(const void *s1, const void *s2);
char *currentdir(); // idb
char *__cdecl cleanupName(char *name);
char *__cdecl expandPath(char *name);
int __cdecl strcasematch(char *s1, char *s2);
int __cdecl strcasemstr(char *str, char **srch, char **ret_ptr);
char *__cdecl remove_space(char *str);
int __cdecl non_null(char *s);
void __cdecl cleanup_line(Str s, int mode);
int __cdecl getescapechar(char **str);
char *__cdecl getescapecmd(char **s);
char *__cdecl html_quote(char *str);
char *__cdecl html_unquote(char *str);
char *__cdecl url_quote(char *str);
char *__cdecl file_quote(char *str);
char *__cdecl file_unquote(char *str);
Str __cdecl Str_form_quote(Str x);
Str __cdecl Str_url_unquote(Str x, int is_form, int safe);
char *__cdecl shell_quote(char *str);
char *__cdecl w3m_dir(const char *name, char *dft);
char *w3m_auxbin_dir(); // idb
char *w3m_lib_dir(); // idb
char *w3m_etc_dir(); // idb
char *w3m_conf_dir(); // idb
char *w3m_help_dir(); // idb
ListItem *__cdecl newListItem(void *s, ListItem *n, ListItem *p);
GeneralList *newGeneralList(); // idb
void __cdecl pushValue(GeneralList *tl, void *s);
void *__cdecl popValue(GeneralList *tl);
void *__cdecl rpopValue(GeneralList *tl);
void __cdecl delValue(GeneralList *tl, ListItem *it);
GeneralList *__cdecl appendGeneralList(GeneralList *tl, GeneralList *tl2);
TextLine *__cdecl newTextLine(Str line, int pos);
void __cdecl appendTextLine(TextLineList *tl, Str line, int pos);
char *__cdecl tag_get_value(parsed_tagarg *t, char *arg);
int __cdecl tag_exists(parsed_tagarg *t, char *arg);
parsed_tagarg *__cdecl cgistr2tagarg(char *cgistr);
unsigned int __cdecl hashfunc(char *s);
Hash_si_0 *__cdecl newHash_si(int size);
HashItem_si_0 *__cdecl lookupHash_si(Hash_si_0 *t, char *key, int *hashval_return);
void __cdecl putHash_si(Hash_si_0 *t, char *key, int value);
int __cdecl getHash_si(Hash_si_0 *t, char *key, int failval);
Hash_ss_0 *__cdecl newHash_ss(int size);
HashItem_ss_0 *__cdecl lookupHash_ss(Hash_ss_0 *t, char *key, int *hashval_return);
void __cdecl putHash_ss(Hash_ss_0 *t, char *key, char *value);
char *__cdecl getHash_ss(Hash_ss_0 *t, char *key, char *failval);
Hash_sv_0 *__cdecl newHash_sv(int size);
HashItem_sv_0 *__cdecl lookupHash_sv(Hash_sv_0 *t, char *key, int *hashval_return);
void __cdecl putHash_sv(Hash_sv_0 *t, char *key, void *value);
void *__cdecl getHash_sv(Hash_sv_0 *t, char *key, void *failval);
Hash_iv_0 *__cdecl newHash_iv(int size);
HashItem_iv_0 *__cdecl lookupHash_iv(Hash_iv_0 *t, int key, int *hashval_return);
void __cdecl putHash_iv(Hash_iv_0 *t, int key, void *value);
void *__cdecl getHash_iv(Hash_iv_0 *t, int key, void *failval);
void __cdecl wc_char_conv_init(wc_ces f_ces, wc_ces t_ces);
Str __cdecl wc_char_conv(char c);
wc_ces __cdecl wc_guess_charset(char *charset, wc_ces orig);
wc_ces __cdecl wc_guess_charset_short(char *charset, wc_ces orig);
wc_ces __cdecl wc_guess_locale_charset(char *locale, wc_ces orig);
wc_ces __cdecl wc_charset_to_ces(char *charset);
wc_ces __cdecl wc_charset_short_to_ces(char *charset);
wc_ces __cdecl wc_locale_to_ces(char *locale);
char *__cdecl wc_ces_to_charset(wc_ces ces);
char *__cdecl wc_ces_to_charset_desc(wc_ces ces);
wc_ces __cdecl wc_guess_8bit_charset(wc_ces orig);
wc_bool __cdecl wc_check_ces(wc_ces ces);
int __cdecl wc_ces_list_cmp(const void *a, const void *b);
wc_ces_list *wc_get_ces_list(); // idb
Str __cdecl wc_Str_conv(Str is, wc_ces f_ces, wc_ces t_ces);
Str __cdecl wc_Str_conv_strict(Str is, wc_ces f_ces, wc_ces t_ces);
Str __cdecl wc_conv_to_ces(Str is, wc_ces ces);
Str __cdecl wc_Str_conv_with_detect(Str is, wc_ces *f_ces, wc_ces hint, wc_ces t_ces);
void __cdecl wc_push_end(Str os, wc_status *st);
void __cdecl wc_create_detect_map(wc_ces ces, wc_bool esc);
wc_ces __cdecl wc_auto_detect(char *is, size_t len, wc_ces hint);
Str __cdecl wc_conv_from_hz(Str is, wc_ces ces);
void __cdecl wc_push_to_hz(Str os, wc_wchar_t cc, wc_status *st);
void __cdecl wc_push_to_hz_end(Str os, wc_status *st);
void __cdecl wtf_push_iso2022(Str os, wc_ccs ccs, wc_uint32 code);
Str __cdecl wc_conv_from_iso2022(Str is, wc_ces ces);
int __cdecl wc_parse_iso2022_esc(wc_uchar **ptr, wc_status *st);
void __cdecl wc_push_to_iso2022(Str os, wc_wchar_t cc, wc_status *st);
void __cdecl wc_push_to_iso2022_end(Str os, wc_status *st);
void __cdecl wc_push_iso2022_esc(Str os, wc_ccs ccs, wc_uchar g, wc_uint8 invoke, wc_status *st);
void __cdecl wc_push_to_euc(Str os, wc_wchar_t cc, wc_status *st);
void __cdecl wc_push_to_eucjp(Str os, wc_wchar_t cc, wc_status *st);
void __cdecl wc_push_to_euctw(Str os, wc_wchar_t cc, wc_status *st);
void __cdecl wc_push_to_iso8859(Str os, wc_wchar_t cc, wc_status *st);
void __cdecl wc_create_gmap(wc_status *st);
Str __cdecl wc_char_conv_from_iso2022(wc_uchar c, wc_status *st);
// wc_wchar_t *__userpurge wc_jisx0201k_to_jisx0208@<eax>(wc_wchar_t *retstr, wc_wchar_t cc);
// wc_wchar_t *__userpurge wc_jisx0212_to_jisx0213@<eax>(wc_wchar_t *retstr, wc_wchar_t cc);
// wc_wchar_t *__userpurge wc_jisx0213_to_jisx0212@<eax>(wc_wchar_t *retstr, wc_wchar_t cc);
wc_ccs __cdecl wc_jisx0208_or_jisx02131(wc_uint16 code);
wc_ccs __cdecl wc_jisx0212_or_jisx02132(wc_uint16 code);
// wc_wchar_t *__userpurge wc_johab_to_ksx1001@<eax>(wc_wchar_t *retstr, wc_wchar_t cc);
// wc_wchar_t *__userpurge wc_ksx1001_to_johab@<eax>(wc_wchar_t *retstr, wc_wchar_t cc);
wc_wchar_t *wc_ucs_to_johab(wc_wchar_t *__return_ptr __struct_ptr retstr, wc_uint32 ucs);
wc_uint32 __cdecl wc_johab1_to_N(wc_uint32 code);
wc_uint32 __cdecl wc_N_to_johab1(wc_uint32 code);
// wc_wchar_t *__userpurge wc_johab_to_cs128w@<eax>(wc_wchar_t *retstr, wc_wchar_t cc);
// wc_wchar_t *__userpurge wc_cs128w_to_johab@<eax>(wc_wchar_t *retstr, wc_wchar_t cc);
Str __cdecl wc_conv_from_johab(Str is, wc_ces ces);
void __cdecl wc_push_to_johab(Str os, wc_wchar_t cc, wc_status *st);
Str __cdecl wc_char_conv_from_johab(wc_uchar c, wc_status *st);
void __cdecl wc_putc_init(wc_ces f_ces, wc_ces t_ces);
void __cdecl wc_putc(char *c, FILE *f);
void __cdecl wc_putc_end(FILE *f);
void wc_putc_clear_status(); // idb
int __cdecl map_cmp(const void *a, const void *b);
int __cdecl map3_cmp(const void *a, const void *b);
int __cdecl map_range_cmp(const void *a, const void *b);
int __cdecl map2_range_cmp(const void *a, const void *b);
int __cdecl map3_range_cmp(const void *a, const void *b);
wc_map *__cdecl wc_map_search(wc_uint16 code, wc_map *map, size_t n);
wc_map3 *__cdecl wc_map3_search(wc_uint16 c1, wc_uint16 c2, wc_map3 *map, size_t n);
wc_map *__cdecl wc_map_range_search(wc_uint16 code, wc_map *map, int n);
wc_map *__cdecl wc_map2_range_search(wc_uint16 code, wc_map *map, size_t n);
wc_map3 *__cdecl wc_map3_range_search(wc_uint16 code, wc_map3 *map, size_t n);
// wc_wchar_t *__userpurge wc_sjis_to_jis@<eax>(wc_wchar_t *retstr, wc_wchar_t cc);
// wc_wchar_t *__userpurge wc_jis_to_sjis@<eax>(wc_wchar_t *retstr, wc_wchar_t cc);
// wc_wchar_t *__userpurge wc_sjis_ext_to_cs94w@<eax>(wc_wchar_t *retstr, wc_wchar_t cc);
// wc_wchar_t *__userpurge wc_cs94w_to_sjis_ext@<eax>(wc_wchar_t *retstr, wc_wchar_t cc);
wc_uint32 __cdecl wc_sjis_ext1_to_N(wc_uint32 c);
wc_uint32 __cdecl wc_sjis_ext2_to_N(wc_uint32 c);
Str __cdecl wc_conv_from_sjis(Str is, wc_ces ces);
Str __cdecl wc_conv_from_sjisx0213(Str is, wc_ces ces);
void __cdecl wc_push_to_sjis(Str os, wc_wchar_t cc, wc_status *st);
void __cdecl wc_push_to_sjisx0213(Str os, wc_wchar_t cc, wc_status *st);
Str __cdecl wc_char_conv_from_sjis(wc_uchar c, wc_status *st);
Str __cdecl wc_char_conv_from_sjisx0213(wc_uchar c, wc_status *st);
void __cdecl wc_input_init(wc_ces ces, wc_status *st);
void __cdecl wc_output_init(wc_ces ces, wc_status *st);
wc_bool __cdecl wc_ces_has_ccs(wc_ccs ccs, wc_status *st);
// wc_wchar_t *__userpurge ucs_cs94_conv@<eax>(wc_wchar_t *retstr, wc_ccs ccs, wc_uint16 c);
// wc_wchar_t *__userpurge ucs_viet_conv@<eax>(wc_wchar_t *retstr, wc_ccs ccs, wc_uint16 c);
// wc_wchar_t *__userpurge ucs_cp1258_conv@<eax>(wc_wchar_t *retstr, wc_ccs ccs, wc_uint16 c);
// wc_wchar_t *__userpurge ucs_cns11643_conv@<eax>(wc_wchar_t *retstr, wc_ccs cs_0, wc_uint16 c);
// wc_wchar_t *__userpurge ucs_big5_conv@<eax>(wc_wchar_t *retstr, wc_ccs cs_0, wc_uint16 c);
// wc_wchar_t *__userpurge ucs_johab2_conv@<eax>(wc_wchar_t *retstr, wc_ccs cs_0, wc_uint16 c);
// wc_wchar_t *__userpurge ucs_johab3_conv@<eax>(wc_wchar_t *retstr, wc_ccs cs_0, wc_uint16 c);
// wc_wchar_t *__userpurge ucs_sjis_ext_conv@<eax>(wc_wchar_t *retstr, wc_ccs cs_0, wc_uint16 c);
// wc_wchar_t *__userpurge ucs_gbk_conv@<eax>(wc_wchar_t *retstr, wc_ccs cs_0, wc_uint16 c);
// wc_wchar_t *__userpurge ucs_uhc_conv@<eax>(wc_wchar_t *retstr, wc_ccs cs_0, wc_uint16 c);
// wc_wchar_t *__userpurge ucs_hkscs_conv@<eax>(wc_wchar_t *retstr, wc_ccs cs_0, wc_uint16 c);
wc_table *__cdecl wc_get_ucs_table(wc_ccs ccs);
// wc_wchar_t *__userpurge wc_ucs_to_any@<eax>(wc_wchar_t *retstr, wc_uint32 ucs, wc_table *t);
wc_uint32 __cdecl wc_any_to_ucs(wc_wchar_t cc);
// wc_wchar_t *__userpurge wc_any_to_any@<eax>(wc_wchar_t *retstr, wc_wchar_t cc, wc_table *t);
// wc_wchar_t *__userpurge wc_ucs_to_any_list@<eax>(wc_wchar_t *retstr, wc_uint32 ucs, wc_table **tlist);
// wc_wchar_t *__userpurge wc_any_to_any_ces@<eax>(wc_wchar_t *retstr, wc_wchar_t cc, wc_status *st);
// wc_wchar_t *__userpurge wc_any_to_iso2022@<eax>(wc_wchar_t *retstr, wc_wchar_t cc, wc_status *st);
wc_wchar_t *wc_ucs_to_iso2022(wc_wchar_t *__return_ptr __struct_ptr retstr, wc_uint32 ucs);
wc_wchar_t *wc_ucs_to_iso2022w(wc_wchar_t *__return_ptr __struct_ptr retstr, wc_uint32 ucs);
wc_ccs __cdecl wc_ucs_to_ccs(wc_uint32 ucs);
wc_bool __cdecl wc_is_ucs_wide(wc_uint32 ucs);
wc_bool __cdecl wc_is_ucs_combining(wc_uint32 ucs);
wc_bool __cdecl wc_is_ucs_hangul(wc_uint32 ucs);
wc_uint32 __cdecl wc_ucs_precompose(wc_uint32 ucs1, wc_uint32 ucs2);
wc_uint32 __cdecl wc_ucs_to_fullwidth(wc_uint32 ucs);
int __cdecl wc_ucs_put_tag(char *p);
char *__cdecl wc_ucs_get_tag(int ntag);
void __cdecl wtf_push_ucs(Str os, wc_uint32 ucs, wc_status *st);
// wc_wchar_t *__userpurge wc_uhc_to_cs128w@<eax>(wc_wchar_t *retstr, wc_wchar_t cc);
// wc_wchar_t *__userpurge wc_cs128w_to_uhc@<eax>(wc_wchar_t *retstr, wc_wchar_t cc);
wc_uint32 __cdecl wc_uhc_to_N(wc_uint32 c);
Str __cdecl wc_conv_from_uhc(Str is, wc_ces ces);
void __cdecl wc_push_to_uhc(Str os, wc_wchar_t cc, wc_status *st);
Str __cdecl wc_char_conv_from_uhc(wc_uchar c, wc_status *st);
Str __cdecl wc_conv_from_utf7(Str is, wc_ces ces);
void __cdecl wc_push_ucs_to_utf7(Str os, wc_uint32 ucs, wc_status *st);
int __cdecl wc_push_tag_to_utf7(Str os, int ntag, wc_status *st);
void __cdecl wc_push_to_utf7(Str os, wc_wchar_t cc, wc_status *st);
void __cdecl wc_push_to_utf7_end(Str os, wc_status *st);
Str __cdecl wc_char_conv_from_utf7(wc_uchar c, wc_status *st);
size_t __cdecl wc_ucs_to_utf8(wc_uint32 ucs, wc_uchar *utf8);
wc_uint32 __cdecl wc_utf8_to_ucs(wc_uchar *utf8);
Str __cdecl wc_conv_from_utf8(Str is, wc_ces ces);
int __cdecl wc_push_tag_to_utf8(Str os, int ntag);
void __cdecl wc_push_to_utf8(Str os, wc_wchar_t cc, wc_status *st);
void __cdecl wc_push_to_utf8_end(Str os, wc_status *st);
Str __cdecl wc_char_conv_from_utf8(wc_uchar c, wc_status *st);
wc_uint32 __cdecl wc_tcvn5712_precompose(wc_uchar c1, wc_uchar c2);
// wc_wchar_t *__userpurge wc_tcvn57123_to_tcvn5712@<eax>(wc_wchar_t *retstr, wc_wchar_t cc);
wc_uint32 __cdecl wc_cp1258_precompose(wc_uchar c1, wc_uchar c2);
Str __cdecl wc_conv_from_viet(Str is, wc_ces ces);
void __cdecl wc_push_to_viet(Str os, wc_wchar_t cc, wc_status *st);
Str __cdecl wc_char_conv_from_viet(wc_uchar c, wc_status *st);
void __cdecl wtf_init(wc_ces ces1, wc_ces ces2);
int __cdecl wtf_strwidth(wc_uchar *p);
size_t __cdecl wtf_len(wc_uchar *p);
void __cdecl wtf_push(Str os, wc_ccs ccs, wc_uint32 code);
void __cdecl wtf_push_unknown(Str os, wc_uchar *p, size_t len);
wc_wchar_t *wtf_parse1(wc_wchar_t *__return_ptr __struct_ptr retstr, wc_uchar **p);
wc_wchar_t *wtf_parse(wc_wchar_t *__return_ptr __struct_ptr retstr, wc_uchar **p);
wc_ccs __cdecl wtf_get_ccs(wc_uchar *p);
wc_uint32 __cdecl wtf_get_code(wc_uchar *p);
wc_bool __cdecl wtf_is_hangul(wc_uchar *p);
char *__cdecl wtf_conv_fit(char *s, wc_ces ces);
// wc_wchar_t *__userpurge wc_big5_to_cs94w@<eax>(wc_wchar_t *retstr, wc_wchar_t cc);
// wc_wchar_t *__userpurge wc_cs94w_to_big5@<eax>(wc_wchar_t *retstr, wc_wchar_t cc);
Str __cdecl wc_conv_from_big5(Str is, wc_ces ces);
void __cdecl wc_push_to_big5(Str os, wc_wchar_t cc, wc_status *st);
Str __cdecl wc_char_conv_from_big5(wc_uchar c, wc_status *st);
wc_bool __cdecl wc_is_combining(wc_wchar_t cc);
// wc_wchar_t *__userpurge wc_gbk_ext_to_cs128w@<eax>(wc_wchar_t *retstr, wc_wchar_t cc);
// wc_wchar_t *__userpurge wc_cs128w_to_gbk_ext@<eax>(wc_wchar_t *retstr, wc_wchar_t cc);
wc_ccs __cdecl wc_gbk_or_gbk_ext(wc_uint16 code);
wc_uint32 __cdecl wc_gb18030_to_ucs(wc_wchar_t cc);
wc_wchar_t *wc_ucs_to_gb18030(wc_wchar_t *__return_ptr __struct_ptr retstr, wc_uint32 ucs);
Str __cdecl wc_conv_from_gb18030(Str is, wc_ces ces);
void __cdecl wc_push_to_gb18030(Str os, wc_wchar_t cc, wc_status *st);
Str __cdecl wc_char_conv_from_gb18030(wc_uchar c, wc_status *st);
wc_ccs __cdecl wc_gb2312_or_gbk(wc_uint16 code);
// wc_wchar_t *__userpurge wc_gbk_to_cs128w@<eax>(wc_wchar_t *retstr, wc_wchar_t cc);
// wc_wchar_t *__userpurge wc_cs128w_to_gbk@<eax>(wc_wchar_t *retstr, wc_wchar_t cc);
wc_uint32 __cdecl wc_gbk_to_N(wc_uint32 c);
Str __cdecl wc_conv_from_gbk(Str is, wc_ces ces);
void __cdecl wc_push_to_gbk(Str os, wc_wchar_t cc, wc_status *st);
Str __cdecl wc_char_conv_from_gbk(wc_uchar c, wc_status *st);
// wc_wchar_t *__userpurge wc_hkscs_to_cs128w@<eax>(wc_wchar_t *retstr, wc_wchar_t cc);
// wc_wchar_t *__userpurge wc_cs128w_to_hkscs@<eax>(wc_wchar_t *retstr, wc_wchar_t cc);
wc_uint32 __cdecl wc_hkscs_to_N(wc_uint32 c);
Str __cdecl wc_conv_from_hkscs(Str is, wc_ces ces);
void __cdecl wc_push_to_hkscs(Str os, wc_wchar_t cc, wc_status *st);
Str __cdecl wc_char_conv_from_hkscs(wc_uchar c, wc_status *st);
Str __cdecl wc_conv_from_priv1(Str is, wc_ces ces);
Str __cdecl wc_char_conv_from_priv1(wc_uchar c, wc_status *st);
Str __cdecl wc_conv_from_ascii(Str is, wc_ces ces);
void __cdecl wc_push_to_raw(Str os, wc_wchar_t cc, wc_status *st);
void _libc_csu_fini(void); // idb
void _libc_csu_init(void); // idb
int __cdecl stat_0(char *filename, int); // idb
int __cdecl fstat(int fildes, int); // idb
int __cdecl lstat(char *filename, int); // idb
void (*_do_global_ctors_aux())(void);
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

const char def_str = '\0'; // idb
const char line = '\0'; // idb
const char byte_80C9BE3 = '\x9E'; // idb
const char str = '\xA0'; // idb
_UNKNOWN unk_80CABB0; // weak
const char aWr[] = "w\x00r\x00]\x00[\x00 "; // idb
_UNKNOWN unk_80CAC72; // weak
_UNKNOWN unk_80CAF55; // weak
const char byte_80CB060 = '\0'; // idb
_UNKNOWN unk_80CB8E6; // weak
const char byte_80CB9EE = '\0'; // idb
_UNKNOWN unk_80CBB1C; // weak
_UNKNOWN unk_80CC030; // weak
_UNKNOWN unk_80CC0C8; // weak
_UNKNOWN unk_80CE2D8; // weak
_UNKNOWN unk_80CE512; // weak
_UNKNOWN unk_80CECA0; // weak
_UNKNOWN unk_80CECFC; // weak
_UNKNOWN unk_80CEDBD; // weak
_UNKNOWN unk_80CEE92; // weak
_UNKNOWN unk_80CF0E8; // weak
const char byte_80CF3D8 = '\0'; // idb
_UNKNOWN unk_80D019C; // weak
_UNKNOWN unk_80D08CE; // weak
_UNKNOWN unk_80D19D7; // weak
int _CTOR_LIST__ = -1; // weak
int _DTOR_LIST__[] = { -1 }; // weak
int _DTOR_END__ = 0; // weak
int _JCR_LIST__ = 0; // weak
int (*dword_80D4FFC)(void) = NULL; // weak
int REV_LB[5] = { 1, 0, 3, 2, 4 }; // idb
int Tabstop = 8; // idb
int IndentIncr = 4; // idb
int ShowEffect = 1; // idb
int PagerMax = 10000; // idb
char PreserveTimestamp = '\x01'; // idb
char TrapSignal = '\x01'; // idb
int NOproxy_netaddr = 1; // idb
char use_proxy = '\x01'; // idb
int MaxNewsMessage = 50; // idb
int TabCols = 10; // idb
int useColor = 1; // idb
int basic_color = 8; // idb
int anchor_color = 4; // idb
int image_color = 2; // idb
int form_color = 1; // idb
int bg_color = 8; // idb
int mark_color = 6; // idb
int active_color = 6; // idb
int visited_color = 5; // idb
int confirm_on_quit = 1; // idb
int retryAsHttp = 1; // idb
int show_srch_str = 1; // idb
char *Imgdisplay = "w3mimgdisplay"; // idb
int displayImage = 1; // idb
int autoImage = 1; // idb
int useExtImageViewer = 1; // idb
int maxLoadImage = 4; // idb
int image_map_list = 1; // idb
char *Editor = "/usr/bin/sensible-editor"; // idb
char *ExtBrowser = "/usr/bin/mozilla"; // idb
int BackgroundExtViewer = 1; // idb
char *passwd_file = "~/.w3m/passwd"; // idb
char *pre_form_file = "~/.w3m/pre_form"; // idb
int ftppass_hostnamegen = 1; // idb
int IgnoreCase = 1; // idb
int UseExternalDirBuffer = 1; // idb
char *DirBufferCommand = "file:///$LIB/dirlist.cgi"; // idb
char *DictCommand = "file:///$LIB/w3mdict.cgi"; // idb
int ignore_null_img_alt = 1; // idb
int displayInsDel = 1; // idb
char *migemo_command = "migemo -t egrep /usr/share/migemo/migemo-dict"; // idb
char *mailcap_files = "~/.w3m/mailcap, /etc/w3m/mailcap"; // idb
char *mimetypes_files = "~/.mime.types, /etc/mime.types"; // idb
char *urimethodmap_files = "~/.w3m/urimethodmap, /etc/w3m/urimethodmap"; // idb
int UseHistory = 1; // idb
size_t URLHistSize = 100u; // idb
int SaveURLHist = 1; // idb
wc_ces InnerCharset = 3211264u; // idb
wc_ces DisplayCharset = 3178565u; // idb
wc_ces DocumentCharset = 3178565u; // idb
wc_ces SystemCharset = 3178565u; // idb
wc_ces BookmarkCharset = 3178565u; // idb
char FollowLocale = '\x01'; // idb
char UseContentCharset = '\x01'; // idb
char SearchConv = '\x01'; // idb
char UseAltEntity = '\x01'; // idb
int use_mouse = 1; // idb
int fixed_wheel_scroll_count = 5; // idb
int relative_wheel_scroll_ratio = 30; // idb
int default_use_cookie = 1; // idb
int show_cookie = 1; // idb
int clear_buffer = 1; // idb
double pixel_per_char =  7.0; // idb
double pixel_per_line =  14.0; // idb
double image_scale =  100.0; // idb
char *keymap_file = "keymap"; // idb
int FollowRedirection = 10; // idb
AlarmEvent *CurrentAlarm = &DefaultAlarm; // idb
int prev_key = -1; // idb
int on_target = 1; // idb
int check_target = 1; // idb
int prev_pos_17143 = -1; // idb
int press_btn_16573 = -1; // idb
char *url_like_pat_16013[2] = { "<[!-;=?-~]+@[a-zA-Z0-9\\.\\-_]+>", NULL }; // idb
char *url_like_pat_15972[9] =
{
  "https?://[a-zA-Z0-9][a-zA-Z0-9:%\\-\\./?=~_\\&+@#,\\$;]*[a-zA-Z0-9_/=\\-]",
  "file:/[a-zA-Z0-9:%\\-\\./=_\\+@#,\\$;]*",
  "gopher://[a-zA-Z0-9][a-zA-Z0-9:%\\-\\./_]*",
  "ftp://[a-zA-Z0-9][a-zA-Z0-9:%\\-\\./=_+@#,\\$]*[a-zA-Z0-9_/]",
  "news:[^<> \t][^<> \t]*",
  "nntp://[a-zA-Z0-9][a-zA-Z0-9:%\\-\\./_]*",
  "https?://[a-zA-Z0-9:%\\-\\./_@]*\\[[a-fA-F0-9:][a-fA-F0-9:\\.]*\\][a-zA-Z0-9:%\\-\\./?=~_\\&+@#,\\$;]*",
  "ftp://[a-zA-Z0-9:%\\-\\./_@]*\\[[a-fA-F0-9:][a-fA-F0-9:\\.]*\\][a-zA-Z0-9:%\\-\\./=_+@#,\\$]*",
  NULL
}; // idb
int (*routine_11359[2])(Buffer *, char *) = { &forwardSearch, &backwardSearch }; // idb
int max_select = 10; // idb
int max_textarea = 10; // idb
int form_max = -1; // idb
char *violations[9] =
{
  "internal error",
  "tail match failed",
  "wrong number of dots",
  "RFC 2109 4.3.2 rule 1",
  "RFC 2109 4.3.2 rule 2.1",
  "RFC 2109 4.3.2 rule 2.2",
  "RFC 2109 4.3.2 rule 3",
  "RFC 2109 4.3.2 rule 4",
  "RFC XXXX 4.3.2 rule 5"
}; // idb
compression_decoder compression_decoders[5] =
{
  {
    1,
    ".gz",
    "application/x-gzip",
    0,
    "gunzip",
    "gunzip",
    "gzip",
    { "gzip", "x-gzip", NULL, NULL }
  },
  {
    1,
    ".Z",
    "application/x-compress",
    0,
    "gunzip",
    "gunzip",
    "compress",
    { "compress", "x-compress", NULL, NULL }
  },
  {
    3,
    ".bz2",
    "application/x-bzip",
    0,
    "bunzip2",
    "bunzip2",
    "bzip, bzip2",
    { "x-bzip", "bzip", "bzip2", NULL }
  },
  {
    4,
    ".deflate",
    "application/x-deflate",
    1,
    "inflate",
    "inflate",
    "deflate",
    { "deflate", "x-deflate", NULL, NULL }
  },
  { 0, NULL, NULL, 0, NULL, NULL, NULL, { NULL, NULL, NULL, NULL } }
}; // idb
http_auth www_auth[2] = { { 1, "Basic ", &basic_auth_param, &AuthBasicCred }, { 0, NULL, NULL, NULL } }; // idb
char *size_unit[11] = { "b", "kb", "Mb", "Gb", "Tb", "Pb", "Eb", "Zb", "Bb", "Yb", NULL }; // idb
int clear_flag_cmd_15359[2] = { 16, 0 }; // idb
int prev_spaces_14599 = -1; // idb
char *NullLine = &unk_80CABB0; // idb
int ccolumn = -1; // idb
char roman_num1[5] = { 'i', 'x', 'c', 'm', '*' }; // idb
char roman_num5[5] = "vld*"; // idb
char *tmpf_base[5] = { "tmp", "src", "frame", "cache", "cookie" }; // idb
char *monthtbl[12] =
{
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
}; // idb
void (*InputKeymap[32])(...) =
{
  &compl,
  &mvB,
  &mvL,
  &inbrk,
  &delC,
  &mvE,
  &mvR,
  &inbrk,
  &bs,
  &insertself,
  &enter,
  &killn,
  &insertself,
  &enter,
  &next,
  &editor,
  &prev,
  &quo,
  &bsw,
  &insertself,
  &mvLw,
  &killb,
  &quo,
  &bsw,
  &tcompl,
  &mvRw,
  &insertself,
  &esc,
  &insertself,
  &insertself,
  &insertself,
  &insertself
}; // idb
double Tiny =  5.562684646268004e-308; // idb
$5B4474C97B2465C9E4B84D4DB8AF7C3E internal_action[7] =
{
  { "map", &follow_map },
  { "option", &panel_set_option },
  { "cookie", &set_cookie_flag },
  { "download", &download_action },
  { "charset", &change_charset },
  { "none", NULL },
  { NULL, NULL }
}; // idb
char *formtypetbl[13] =
{
  "text",
  "password",
  "checkbox",
  "radio",
  "submit",
  "reset",
  "hidden",
  "image",
  "select",
  "textarea",
  "button",
  "file",
  NULL
}; // idb
char *formmethodtbl[4] = { "GET", "POST", "INTERNAL", "HEAD" }; // idb
wc_ces OptionCharset = 256u; // idb
sel_c colorstr[10] =
{
  { 0, "black", "black" },
  { 1, "red", "red" },
  { 2, "green", "green" },
  { 3, "yellow", "yellow" },
  { 4, "blue", "blue" },
  { 5, "magenta", "magenta" },
  { 6, "cyan", "cyan" },
  { 7, "white", "white" },
  { 8, "terminal", "terminal" },
  { 0, NULL, NULL }
}; // idb
param_section sections[10] =
{
  { "Display Settings", &params1 },
  { "Color Settings", &params2 },
  { "Miscellaneous Settings", &params3 },
  { "Directory Settings", &params5 },
  { "External Program Settings", &params6 },
  { "Network Settings", &params9 },
  { "Proxy Settings", &params4 },
  { "Cookie Settings", &params8 },
  { "Charset Settings", &params10 },
  { NULL, NULL }
}; // idb
int (*MenuKeymap[128])(char) =
{
  &mNull,
  &mTop,
  &mPrev,
  &mClose,
  &mNull,
  &mLast,
  &mNext,
  &mNull,
  &mCancel,
  &mNull,
  &mOk,
  &mNull,
  &mNull,
  &mOk,
  &mDown,
  &mNull,
  &mUp,
  &mNull,
  &mSrchB,
  &mSrchF,
  &mNull,
  &mNull,
  &mNext,
  &mNull,
  &mNull,
  &mNull,
  &mSusp,
  &mEsc,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mOk,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mSrchF,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mSrchB,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mLineU,
  &mLineD,
  &mNull,
  &mNull,
  &mSrchP,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mCancel,
  &mNull,
  &mDown,
  &mUp,
  &mOk,
  &mNull,
  &mSrchN,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mCancel
}; // idb
int (*MenuEscKeymap[128])(char) =
{
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mEscB,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mEscB,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mPrev,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull
}; // idb
int (*MenuEscBKeymap[128])(char) =
{
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mUp,
  &mDown,
  &mOk,
  &mCancel,
  &mClose,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mClose,
  &mMouse,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull
}; // idb
int (*MenuEscDKeymap[128])(char) =
{
  &mNull,
  &mNull,
  &mClose,
  &mNull,
  &mNull,
  &mBack,
  &mFore,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mClose,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull,
  &mNull
}; // idb
wc_ces MainMenuCharset = 256u; // idb
MenuItem MainMenuItem[21] =
{
  { 4, " Back         (b) ", NULL, 0, &backBf, NULL, "b", NULL },
  { 8, " Select Buffer(s) ", NULL, 0, NULL, &SelectMenu, "s", NULL },
  { 8, " Select Tab   (t) ", NULL, 0, NULL, &SelTabMenu, "tT", NULL },
  { 4, " View Source  (v) ", NULL, 0, &vwSrc, NULL, "vV", NULL },
  { 4, " Edit Source  (e) ", NULL, 0, &editBf, NULL, "eE", NULL },
  { 4, " Save Source  (S) ", NULL, 0, &svSrc, NULL, "S", NULL },
  { 4, " Reload       (r) ", NULL, 0, &reload, NULL, "rR", NULL },
  { 1, " ---------------- ", NULL, 0, &nulcmd, NULL, &unk_80CE512, NULL },
  { 4, " Go Link      (a) ", NULL, 0, &followA, NULL, "a", NULL },
  { 4, "   on New Tab (n) ", NULL, 0, &tabA, NULL, "nN", NULL },
  { 4, " Save Link    (A) ", NULL, 0, &svA, NULL, "A", NULL },
  { 4, " View Image   (i) ", NULL, 0, &followI, NULL, "i", NULL },
  { 4, " Save Image   (I) ", NULL, 0, &svI, NULL, "I", NULL },
  { 4, " View Frame   (f) ", NULL, 0, &rFrame, NULL, "fF", NULL },
  { 1, " ---------------- ", NULL, 0, &nulcmd, NULL, &unk_80CE512, NULL },
  { 4, " Bookmark     (B) ", NULL, 0, &ldBmark, NULL, "B", NULL },
  { 4, " Help         (h) ", NULL, 0, &ldhelp, NULL, "hH", NULL },
  { 4, " Option       (o) ", NULL, 0, &ldOpt, NULL, "oO", NULL },
  { 1, " ---------------- ", NULL, 0, &nulcmd, NULL, &unk_80CE512, NULL },
  { 4, " Quit         (q) ", NULL, 0, &qquitfm, NULL, "qQ", NULL },
  { 0, &unk_80CE512, NULL, 0, &nulcmd, NULL, &unk_80CE512, NULL }
}; // idb
char lmKeys[22] = "abcdefgimopqrstuvwxyz"; // idb
char lmKeys2[34] = "1234567890ABCDEFGHILMOPQRSTUVWXYZ"; // idb
char *comment_9583 = " SPC for select / D for delete tab "; // idb
wc_uchar *comment_9275 = &aSpcForSelectDF_0; // idb
int press_btn_8969 = -1; // idb
int (*routine_8886[2])(Menu *, char *, int) = { &menuForwardSearch, &menuBackwardSearch }; // idb
mailcap DefaultMailcap[3] =
{
  { "image/*", "display %s", 0, NULL, NULL, NULL },
  { "audio/basic", "showaudio %s", 0, NULL, NULL, NULL },
  { NULL, NULL, 0, NULL, NULL, NULL }
}; // idb
char *alt_symbol[47] =
{
  "+\x00|\x00-",
  (char *)0x80CE9C2,
  (char *)0x80CE9C4,
  "+\x00|\x00-",
  (char *)0x80CE9C2,
  (char *)0x80CE9C2,
  "+\x00|\x00-",
  &unk_80CE9C6,
  (char *)0x80CE9C4,
  "+\x00|\x00-",
  (char *)0x80CE9C4,
  &unk_80CE9C6,
  "+\x00|\x00-",
  &unk_80CE9C6,
  &unk_80CE9C6,
  &unk_80CE9C6,
  "+\x00|\x00-",
  (char *)0x80CE9C2,
  (char *)0x80CE9C4,
  "+\x00|\x00-",
  (char *)0x80CE9C2,
  (char *)0x80CE9C2,
  "+\x00|\x00-",
  &unk_80CE9C6,
  (char *)0x80CE9C4,
  "+\x00|\x00-",
  (char *)0x80CE9C4,
  &unk_80CE9C6,
  "+\x00|\x00-",
  &unk_80CE9C6,
  &unk_80CE9C6,
  &unk_80CE9C6,
  "*",
  "+\x00|\x00-",
  "o",
  "#",
  "@",
  (char *)0x80CE9C4,
  "=",
  "x",
  "%",
  "*",
  "o",
  "#",
  "#",
  "<=UpDn ",
  NULL
}; // idb
char *alt2_symbol[47] =
{
  "-+",
  " |",
  "--",
  " +",
  "-|",
  " |",
  "-+",
  &unk_80CE9C6,
  "--",
  " +",
  "--",
  &unk_80CE9C6,
  "-+",
  &unk_80CE9C6,
  &unk_80CE9C6,
  &unk_80CE9C6,
  "-+",
  " |",
  "--",
  " +",
  "-|",
  " |",
  "-+",
  &unk_80CE9C6,
  "--",
  " +",
  "--",
  &unk_80CE9C6,
  "-+",
  &unk_80CE9C6,
  &unk_80CE9C6,
  &unk_80CE9C6,
  " *",
  " +",
  " o",
  " #",
  " @",
  " -",
  " =",
  " x",
  " %",
  " *",
  " o",
  " #",
  " #",
  "<=UpDn ",
  NULL
}; // idb
char *graph_symbol[32] =
{
  "n\x00t\x00w\x00l\x00u\x00k\x00v\x00m\x00q\x00j",
  (char *)0x80CEA06,
  (char *)0x80CEA08,
  (char *)0x80CEA0A,
  (char *)0x80CEA0C,
  "x",
  (char *)0x80CEA0E,
  &unk_80CE9C6,
  (char *)0x80CEA10,
  (char *)0x80CEA12,
  (char *)0x80CEA14,
  &unk_80CE9C6,
  (char *)0x80CEA16,
  &unk_80CE9C6,
  &unk_80CE9C6,
  &unk_80CE9C6,
  "n\x00t\x00w\x00l\x00u\x00k\x00v\x00m\x00q\x00j",
  (char *)0x80CEA06,
  (char *)0x80CEA08,
  (char *)0x80CEA0A,
  (char *)0x80CEA0C,
  "x",
  (char *)0x80CEA0E,
  &unk_80CE9C6,
  (char *)0x80CEA10,
  (char *)0x80CEA12,
  (char *)0x80CEA14,
  &unk_80CE9C6,
  (char *)0x80CEA16,
  &unk_80CE9C6,
  &unk_80CE9C6,
  &unk_80CE9C6
}; // idb
char *graph2_symbol[32] =
{
  "qn",
  " t",
  "qw",
  " l",
  "qu",
  " x",
  "qk",
  &unk_80CE9C6,
  "qv",
  " m",
  "qq",
  &unk_80CE9C6,
  "qj",
  &unk_80CE9C6,
  &unk_80CE9C6,
  &unk_80CE9C6,
  "qn",
  " t",
  "qw",
  " l",
  "qu",
  " x",
  "qk",
  &unk_80CE9C6,
  "qv",
  " m",
  "qq",
  &unk_80CE9C6,
  "qj",
  &unk_80CE9C6,
  &unk_80CE9C6,
  &unk_80CE9C6
}; // idb
symbol_set alt_symbol_set = { 256u, '\x01', &alt_symbol, '\x01' }; // idb
symbol_set alt2_symbol_set = { 256u, '\x02', &alt2_symbol, '\x01' }; // idb
charset_symbol_set charset_symbol_list[20] =
{
  { 3149846u, &eucjp_symbol_set },
  { 3153976u, &eucjp_symbol_set },
  { 2099217u, &eucjp_symbol_set },
  { 2099218u, &eucjp_symbol_set },
  { 2099219u, &eucjp_symbol_set },
  { 3149849u, &euckr_symbol_set },
  { 2099221u, &euckr_symbol_set },
  { 3153984u, &euckr_symbol_set },
  { 3153983u, &euckr_symbol_set },
  { 3149847u, &euccn_symbol_set },
  { 3153978u, &euccn_symbol_set },
  { 3153979u, &euccn_symbol_set },
  { 2105404u, &euccn_symbol_set },
  { 2099220u, &euccn_symbol_set },
  { 3149848u, &euctw_symbol_set },
  { 3153981u, &big5_symbol_set },
  { 3153982u, &big5_symbol_set },
  { 3178565u, &utf8_symbol_set },
  { 1049629u, &cp850_symbol_set },
  { 0u, NULL }
}; // idb
int save_width_8078 = -1; // idb
char *alt_latin1[96] =
{
  &unk_80CECA0,
  &unk_80CECA2,
  &unk_80CECA4,
  &unk_80CECA8,
  &unk_80CECAC,
  &unk_80CECB0,
  &unk_80CECB4,
  &unk_80CECB6,
  &unk_80CECB9,
  &unk_80CECBB,
  &unk_80CECBF,
  &unk_80CECC2,
  &unk_80CECC5,
  &unk_80CECC9,
  &unk_80CECCB,
  &unk_80CECC9,
  &unk_80CECCF,
  &unk_80CECD3,
  &unk_80CECD6,
  &unk_80CECD9,
  &unk_80CECDC,
  &unk_80CECDE,
  &unk_80CECE0,
  &unk_80CECE3,
  &unk_80CECE5,
  &unk_80CECE7,
  &unk_80CECEA,
  &unk_80CECED,
  &unk_80CECF0,
  &unk_80CECF4,
  &unk_80CECF8,
  &unk_80CECFC,
  &unk_80CECFE,
  &unk_80CED01,
  &unk_80CED04,
  &unk_80CED07,
  &unk_80CED0A,
  &unk_80CED0D,
  &unk_80CED10,
  &unk_80CED13,
  &unk_80CED16,
  &unk_80CED19,
  &unk_80CED1C,
  &unk_80CED1F,
  &unk_80CED22,
  &unk_80CED25,
  &unk_80CED28,
  &unk_80CED2B,
  &unk_80CED2E,
  &unk_80CED31,
  &unk_80CED34,
  &unk_80CED37,
  &unk_80CED3A,
  &unk_80CED3D,
  &unk_80CED40,
  &unk_80CED43,
  &unk_80CED45,
  &unk_80CED48,
  &unk_80CED4B,
  &unk_80CED4E,
  &unk_80CED51,
  &unk_80CED54,
  &unk_80CED57,
  &unk_80CED5A,
  &unk_80CED5D,
  &unk_80CED60,
  &unk_80CED63,
  &unk_80CED66,
  &unk_80CED69,
  &unk_80CED6C,
  &unk_80CED6F,
  &unk_80CED72,
  &unk_80CED75,
  &unk_80CED78,
  &unk_80CED7B,
  &unk_80CED7E,
  &unk_80CED81,
  &unk_80CED84,
  &unk_80CED87,
  &unk_80CED8A,
  &unk_80CED8D,
  &unk_80CED90,
  &unk_80CED93,
  &unk_80CED96,
  &unk_80CED99,
  &unk_80CED9C,
  &unk_80CED9F,
  &unk_80CEDA2,
  &unk_80CEDA5,
  &unk_80CEDA8,
  &unk_80CEDAB,
  &unk_80CEDAE,
  &unk_80CEDB1,
  &unk_80CEDB4,
  &unk_80CEDB7,
  &unk_80CEDBA
}; // idb
int tty = -1; // idb
int tab_step = 8; // idb
w3m_term_info w3m_term_info_list[7] =
{
  { "xterm", "\x1B]0;w3m: %s\a", 3 },
  { "kterm", "\x1B]0;w3m: %s\a", 3 },
  { "rxvt", "\x1B]0;w3m: %s\a", 3 },
  { "Eterm", "\x1B]0;w3m: %s\a", 3 },
  { "mlterm", "\x1B]0;w3m: %s\a", 3 },
  { "screen", "\x1Bk%s\x1B\\", 0 },
  { NULL, NULL, 0 }
}; // idb
int ai_family_order_table[7][3] =
{
  { 0, 0, 0 },
  { 2, 10, 0 },
  { 10, 2, 0 },
  { 0, 0, 0 },
  { 2, 0, 0 },
  { 0, 0, 0 },
  { 10, 0, 0 }
}; // idb
int DefaultPort[13] = { 80, 70, 21, 21, 0, 0, 0, 119, 119, 119, 119, 0, 0 }; // idb
cmdtable schemetable[9] =
{
  { "http", 0 },
  { "gopher", 1 },
  { "ftp", 2 },
  { "local", 4 },
  { "file", 4 },
  { "nntp", 7 },
  { "news", 9 },
  { "data", 11 },
  { NULL, 255 }
}; // idb
table2 DefaultGuess[20] =
{
  { "html", "text/html" },
  { "htm", "text/html" },
  { "shtml", "text/html" },
  { "xhtml", "application/xhtml+xml" },
  { "gif", "image/gif" },
  { "jpeg", "image/jpeg" },
  { "jpg", "image/jpeg" },
  { "png", "image/png" },
  { "xbm", "image/xbm" },
  { "au", "audio/basic" },
  { "gz", "application/x-gzip" },
  { "Z", "application/x-compress" },
  { "bz2", "application/x-bzip" },
  { "tar", "application/x-tar" },
  { "zip", "application/x-zip" },
  { "lha", "application/x-lha" },
  { "lzh", "application/x-lha" },
  { "ps", "application/postscript" },
  { "pdf", "application/pdf" },
  { NULL, NULL }
}; // idb
table2 default_urimethods[2] = { { "mailto", "file:///$LIB/w3mmail.cgi?%s" }, { NULL, NULL } }; // idb
char *scheme_str_10358[13] =
{
  "http",
  "gopher",
  "ftp",
  "ftp",
  "file",
  "file",
  "exec",
  "nntp",
  "nntp",
  "news",
  "news",
  "data",
  "mailto"
}; // idb
char Base64Table[66] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="; // idb
FuncList w3mFuncList[151] =
{
  { "@@@", &nulcmd },
  { "ABORT", &quitfm },
  { "ACCESSKEY", &accessKey },
  { "ADD_BOOKMARK", &adBmark },
  { "ALARM", &setAlarm },
  { "BACK", &backBf },
  { "BEGIN", &goLineF },
  { "BOOKMARK", &ldBmark },
  { "CENTER_H", &ctrCsrH },
  { "CENTER_V", &ctrCsrV },
  { "CHARSET", &docCSet },
  { "CLOSE_TAB", &closeT },
  { "CLOSE_TAB_MOUSE", &closeTMs },
  { "COMMAND", &execCmd },
  { "COOKIE", &cooLst },
  { "DEFAULT_CHARSET", &defCSet },
  { "DEFINE_KEY", &defKey },
  { "DELETE_PREVBUF", &deletePrevBuf },
  { "DICT_WORD", &dictword },
  { "DICT_WORD_AT", &dictwordat },
  { "DISPLAY_IMAGE", &dispI },
  { "DOWN", &ldown1 },
  { "DOWNLOAD", &svSrc },
  { "DOWNLOAD_LIST", &ldDL },
  { "EDIT", &editBf },
  { "EDIT_SCREEN", &editScr },
  { "END", &goLineL },
  { "ESCBMAP", &escbmap },
  { "ESCMAP", &escmap },
  { "EXEC_SHELL", &execsh },
  { "EXIT", &quitfm },
  { "EXTERN", &extbrz },
  { "EXTERN_LINK", &linkbrz },
  { "FRAME", &rFrame },
  { "GOTO", &goURL },
  { "GOTO_LINE", &goLine },
  { "GOTO_LINK", &followA },
  { "GOTO_RELATIVE", &gorURL },
  { "HELP", &ldhelp },
  { "HISTORY", &ldHist },
  { "INFO", &pginfo },
  { "INTERRUPT", &susp },
  { "ISEARCH", &isrchfor },
  { "ISEARCH_BACK", &isrchbak },
  { "LEFT", &col1L },
  { "LINE_BEGIN", &linbeg },
  { "LINE_END", &linend },
  { "LINE_INFO", &curlno },
  { "LINK_BEGIN", &topA },
  { "LINK_END", &lastA },
  { "LINK_MENU", &linkMn },
  { "LIST", &linkLst },
  { "LIST_MENU", &listMn },
  { "LOAD", &ldfile },
  { "MAIN_MENU", &mainMn },
  { "MARK", &mark },
  { "MARK_MID", &chkNMID },
  { "MARK_URL", &chkURL },
  { "MARK_WORD", &chkWORD },
  { "MENU", &mainMn },
  { "MENU_MOUSE", &menuMs },
  { "MOUSE", &mouse },
  { "MOUSE_TOGGLE", &msToggle },
  { "MOVE_DOWN", &movD },
  { "MOVE_DOWN1", &movD1 },
  { "MOVE_LEFT", &movL },
  { "MOVE_LEFT1", &movL1 },
  { "MOVE_LIST_MENU", &movlistMn },
  { "MOVE_MOUSE", &movMs },
  { "MOVE_RIGHT", &movR },
  { "MOVE_RIGHT1", &movR1 },
  { "MOVE_UP", &movU },
  { "MOVE_UP1", &movU1 },
  { "MSGS", &msgs },
  { "MULTIMAP", &multimap },
  { "NEW_TAB", &newT },
  { "NEXT", &nextBf },
  { "NEXT_DOWN", &nextD },
  { "NEXT_LEFT", &nextL },
  { "NEXT_LEFT_UP", &nextLU },
  { "NEXT_LINK", &nextA },
  { "NEXT_MARK", &nextMk },
  { "NEXT_PAGE", &pgFore },
  { "NEXT_RIGHT", &nextR },
  { "NEXT_RIGHT_DOWN", &nextRD },
  { "NEXT_TAB", &nextT },
  { "NEXT_UP", &nextU },
  { "NEXT_VISITED", &nextVA },
  { "NEXT_WORD", &movRW },
  { "NOTHING", &nulcmd },
  { "NULL", &nulcmd },
  { "OPTIONS", &ldOpt },
  { "PCMAP", &pcmap },
  { "PEEK", &curURL },
  { "PEEK_IMG", &peekIMG },
  { "PEEK_LINK", &peekURL },
  { "PIPE_BUF", &pipeBuf },
  { "PIPE_SHELL", &pipesh },
  { "PREV", &prevBf },
  { "PREV_LINK", &prevA },
  { "PREV_MARK", &prevMk },
  { "PREV_PAGE", &pgBack },
  { "PREV_TAB", &prevT },
  { "PREV_VISITED", &prevVA },
  { "PREV_WORD", &movLW },
  { "PRINT", &svBuf },
  { "QUIT", &qquitfm },
  { "READ_SHELL", &readsh },
  { "REDO", &redoPos },
  { "REDRAW", &rdrwSc },
  { "REG_MARK", &reMark },
  { "REINIT", &reinit },
  { "RELOAD", &reload },
  { "RESHAPE", &reshape },
  { "RIGHT", &col1R },
  { "SAVE", &svSrc },
  { "SAVE_IMAGE", &svI },
  { "SAVE_LINK", &svA },
  { "SAVE_SCREEN", &svBuf },
  { "SEARCH", &srchfor },
  { "SEARCH_BACK", &srchbak },
  { "SEARCH_FORE", &srchfor },
  { "SEARCH_NEXT", &srchnxt },
  { "SEARCH_PREV", &srchprv },
  { "SELECT", &selBuf },
  { "SELECT_MENU", &selMn },
  { "SETENV", &setEnv },
  { "SET_OPTION", &setOpt },
  { "SHELL", &execsh },
  { "SHIFT_LEFT", &shiftl },
  { "SHIFT_RIGHT", &shiftr },
  { "SOURCE", &vwSrc },
  { "STOP_IMAGE", &stopI },
  { "SUBMIT", &submitForm },
  { "SUSPEND", &susp },
  { "TAB_GOTO", &tabURL },
  { "TAB_GOTO_RELATIVE", &tabrURL },
  { "TAB_LEFT", &tabL },
  { "TAB_LINK", &tabA },
  { "TAB_MENU", &tabMn },
  { "TAB_MOUSE", &tabMs },
  { "TAB_RIGHT", &tabR },
  { "UNDO", &undoPos },
  { "UP", &lup1 },
  { "VERSION", &dispVer },
  { "VIEW", &vwSrc },
  { "VIEW_BOOKMARK", &ldBmark },
  { "VIEW_IMAGE", &followI },
  { "WHEREIS", &srchfor },
  { "WRAP_TOGGLE", &wrapToggle },
  { NULL, NULL }
}; // idb
Hash_si_0 functable = { 100, &MyHashItemTbl }; // idb
MouseAction default_mouse_action =
{
  NULL,
  "<=UpDn",
  0,
  6,
  0,
  0,
  0,
  { { &movMs, NULL }, { &backBf, NULL }, { &menuMs, NULL } },
  { { NULL, NULL }, { NULL, NULL }, { NULL, NULL } },
  { { &followA, NULL }, { NULL, NULL }, { NULL, NULL } },
  { { &tabMs, NULL }, { &closeTMs, NULL }, { NULL, NULL } },
  { NULL, NULL, NULL },
  { NULL, NULL, NULL }
}; // idb
MouseActionMap default_lastline_action[6] =
{
  { &backBf, NULL },
  { &backBf, NULL },
  { &pgBack, NULL },
  { &pgBack, NULL },
  { &pgFore, NULL },
  { &pgFore, NULL }
}; // idb
int is_saved = 1; // idb
char *special_domain[8] = { ".com", ".edu", ".gov", ".mil", ".net", ".org", ".int", NULL }; // idb
$8D98219F3DFF54E1CD9CF58339F0F3EF command_table[7] =
{
  { "get", "[-download_only] URL", "Retrieve URL.", &get },
  {
    "post",
    "[-download_only] [-target TARGET] [-charset CHARSET] [-enctype ENCTYPE] [-body BODY] [-boundary BOUNDARY] [-length LEN] URL",
    "Retrieve URL.",
    &post
  },
  { "set", "VARIABLE VALUE", "Set VALUE to VARIABLE.", &set },
  { "show", "VARIABLE", "Show value of VARIABLE.", &show },
  { "quit", &unk_80D0711, "Quit program.", &quit },
  { "help", &unk_80D0711, "Display help messages.", &help },
  { NULL, NULL, NULL, NULL }
}; // idb
$25E7514D4F0FA2D376C68AB961B2FE06 variable_table[2] = { { "column", &set_column, &show_column }, { NULL, NULL, NULL } }; // idb
unsigned __int8 GlobalKeymap[128] =
{
  55u,
  45u,
  65u,
  0u,
  0u,
  46u,
  69u,
  47u,
  39u,
  80u,
  36u,
  14u,
  109u,
  36u,
  63u,
  0u,
  71u,
  11u,
  43u,
  42u,
  138u,
  99u,
  82u,
  149u,
  0u,
  0u,
  41u,
  28u,
  0u,
  0u,
  0u,
  0u,
  82u,
  29u,
  110u,
  97u,
  46u,
  0u,
  0u,
  0u,
  142u,
  108u,
  0u,
  82u,
  44u,
  101u,
  114u,
  119u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  57u,
  58u,
  129u,
  40u,
  130u,
  120u,
  107u,
  0u,
  5u,
  0u,
  23u,
  24u,
  33u,
  26u,
  38u,
  147u,
  143u,
  21u,
  51u,
  31u,
  123u,
  0u,
  0u,
  1u,
  112u,
  105u,
  75u,
  34u,
  53u,
  104u,
  0u,
  0u,
  8u,
  48u,
  0u,
  49u,
  45u,
  0u,
  0u,
  117u,
  101u,
  93u,
  0u,
  0u,
  0u,
  6u,
  65u,
  94u,
  63u,
  71u,
  69u,
  62u,
  122u,
  91u,
  0u,
  106u,
  144u,
  125u,
  0u,
  95u,
  131u,
  88u,
  0u,
  0u,
  9u,
  102u,
  96u,
  85u,
  0u,
  0u
}; // idb
unsigned __int8 EscKeymap[128] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  99u,
  117u,
  0u,
  0u,
  117u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  56u,
  0u,
  6u,
  0u,
  26u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  116u,
  0u,
  0u,
  0u,
  32u,
  0u,
  27u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  19u,
  0u,
  0u,
  0u,
  27u,
  0u,
  0u,
  0u,
  0u,
  0u,
  3u,
  7u,
  13u,
  0u,
  25u,
  0u,
  35u,
  0u,
  0u,
  0u,
  16u,
  52u,
  67u,
  81u,
  127u,
  100u,
  0u,
  0u,
  22u,
  139u,
  37u,
  101u,
  18u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // idb
unsigned __int8 EscBKeymap[128] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  71u,
  63u,
  69u,
  65u,
  0u,
  26u,
  82u,
  6u,
  101u,
  0u,
  0u,
  0u,
  61u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  99u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // idb
unsigned __int8 EscDKeymap[128] =
{
  0u,
  6u,
  54u,
  0u,
  26u,
  101u,
  82u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  54u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // idb
char *header_mid_8685[4] = { "Message-Id:", "References:", "In-Reply-To:", NULL }; // idb
char *header_group_8686[2] = { "Newsgroups:", NULL }; // idb
TagInfo TagMAP[145] =
{
  { NULL, NULL, 0u, 0u },
  { "a", &ALST_A, 11u, 0u },
  { "/a", NULL, 0u, 1u },
  { "h", &ALST_P, 2u, 0u },
  { "/h", NULL, 0u, 1u },
  { "p", &ALST_P, 2u, 0u },
  { "br", NULL, 0u, 0u },
  { "b", NULL, 0u, 0u },
  { "/b", NULL, 0u, 1u },
  { "ul", &ALST_UL, 3u, 0u },
  { "/ul", NULL, 0u, 1u },
  { "li", &ALST_LI, 3u, 0u },
  { "ol", &ALST_UL, 3u, 0u },
  { "/ol", NULL, 0u, 1u },
  { "title", NULL, 0u, 0u },
  { "/title", NULL, 0u, 1u },
  { "hr", &ALST_HR, 3u, 0u },
  { "dl", &ALST_DL, 2u, 0u },
  { "/dl", NULL, 0u, 1u },
  { "dt", &ALST_NOP, 1u, 0u },
  { "dd", &ALST_NOP, 1u, 0u },
  { "pre", &ALST_PRE, 2u, 0u },
  { "/pre", NULL, 0u, 1u },
  { "blockquote", &ALST_NOP, 1u, 0u },
  { "/blockquote", NULL, 0u, 1u },
  { "img", &ALST_IMG, 10u, 0u },
  { "listing", NULL, 0u, 0u },
  { "/listing", NULL, 0u, 1u },
  { "xmp", NULL, 0u, 0u },
  { "/xmp", NULL, 0u, 1u },
  { "plaintext", NULL, 0u, 0u },
  { "table", &ALST_TABLE, 7u, 0u },
  { "/table", NULL, 0u, 1u },
  { "meta", &ALST_META, 3u, 0u },
  { "/p", NULL, 0u, 1u },
  { "frame", &ALST_FRAME, 3u, 0u },
  { "frameset", &ALST_FRAMESET, 3u, 0u },
  { "/frameset", NULL, 0u, 1u },
  { "center", NULL, 0u, 0u },
  { "/center", NULL, 0u, 1u },
  { "font", NULL, 0u, 0u },
  { "/font", NULL, 0u, 1u },
  { "form", &ALST_FORM, 8u, 0u },
  { "/form", NULL, 0u, 1u },
  { "input", &ALST_INPUT, 13u, 0u },
  { "textarea", &ALST_TEXTAREA, 5u, 0u },
  { "/textarea", NULL, 0u, 1u },
  { "select", &ALST_SELECT, 3u, 0u },
  { "/select", NULL, 0u, 1u },
  { "option", &ALST_OPTION, 4u, 0u },
  { "nobr", NULL, 0u, 0u },
  { "/nobr", NULL, 0u, 1u },
  { "div", &ALST_P, 2u, 0u },
  { "/div", NULL, 0u, 1u },
  { "isindex", &ALST_ISINDEX, 3u, 0u },
  { "map", &ALST_MAP, 2u, 0u },
  { "/map", NULL, 0u, 1u },
  { "area", &ALST_AREA, 6u, 0u },
  { "script", NULL, 0u, 0u },
  { "/script", NULL, 0u, 1u },
  { "base", &ALST_BASE, 3u, 0u },
  { "del", NULL, 0u, 0u },
  { "/del", NULL, 0u, 1u },
  { "ins", NULL, 0u, 0u },
  { "/ins", NULL, 0u, 1u },
  { "u", NULL, 0u, 0u },
  { "/u", NULL, 0u, 1u },
  { "style", NULL, 0u, 0u },
  { "/style", NULL, 0u, 1u },
  { "wbr", NULL, 0u, 0u },
  { "em", NULL, 0u, 0u },
  { "/em", NULL, 0u, 1u },
  { "body", &ALST_BODY, 2u, 0u },
  { "/body", NULL, 0u, 1u },
  { "tr", &ALST_TR, 3u, 0u },
  { "/tr", NULL, 0u, 1u },
  { "td", &ALST_TD, 7u, 0u },
  { "/td", NULL, 0u, 1u },
  { "caption", &ALST_NOP, 1u, 0u },
  { "/caption", NULL, 0u, 1u },
  { "th", &ALST_TD, 7u, 0u },
  { "/th", NULL, 0u, 1u },
  { "thead", NULL, 0u, 0u },
  { "/thead", NULL, 0u, 1u },
  { "tbody", NULL, 0u, 0u },
  { "/tbody", NULL, 0u, 1u },
  { "tfoot", NULL, 0u, 0u },
  { "/tfoot", NULL, 0u, 1u },
  { "colgroup", NULL, 0u, 0u },
  { "/colgroup", NULL, 0u, 1u },
  { "col", NULL, 0u, 0u },
  { "bgsound", &ALST_BGSOUND, 2u, 0u },
  { "applet", &ALST_APPLET, 2u, 0u },
  { "embed", &ALST_EMBED, 2u, 0u },
  { "/option", NULL, 0u, 1u },
  { "head", NULL, 0u, 0u },
  { "/head", NULL, 0u, 1u },
  { "doctype", NULL, 0u, 0u },
  { "noframes", &ALST_NOFRAMES, 1u, 0u },
  { "/noframes", NULL, 0u, 1u },
  { "sup", NULL, 0u, 0u },
  { "/sup", NULL, 0u, 0u },
  { "sub", NULL, 0u, 0u },
  { "/sub", NULL, 0u, 0u },
  { "link", &ALST_LINK, 7u, 0u },
  { "s", NULL, 0u, 0u },
  { "/s", NULL, 0u, 1u },
  { "q", NULL, 0u, 0u },
  { "/q", NULL, 0u, 1u },
  { "i", NULL, 0u, 0u },
  { "/i", NULL, 0u, 1u },
  { "strong", NULL, 0u, 0u },
  { "/strong", NULL, 0u, 1u },
  { NULL, NULL, 0u, 0u },
  { NULL, NULL, 0u, 0u },
  { NULL, NULL, 0u, 0u },
  { NULL, NULL, 0u, 0u },
  { NULL, NULL, 0u, 0u },
  { NULL, NULL, 0u, 0u },
  { NULL, NULL, 0u, 0u },
  { "select_int", &ALST_SELECT_INT, 1u, 2u },
  { "/select_int", NULL, 0u, 3u },
  { "option_int", &ALST_OPTION, 4u, 2u },
  { "textarea_int", &ALST_TEXTAREA_INT, 1u, 2u },
  { "/textarea_int", NULL, 0u, 3u },
  { "table_alt", &ALST_TABLE_ALT, 1u, 2u },
  { "symbol", &ALST_SYMBOL, 1u, 2u },
  { "/symbol", NULL, 0u, 3u },
  { "pre_int", NULL, 0u, 2u },
  { "/pre_int", NULL, 0u, 3u },
  { "title_alt", &ALST_TITLE_ALT, 1u, 2u },
  { "form_int", &ALST_FORM_INT, 8u, 2u },
  { "/form_int", NULL, 0u, 3u },
  { "dl_compact", NULL, 0u, 2u },
  { "input_alt", &ALST_INPUT_ALT, 16u, 2u },
  { "/input_alt", NULL, 0u, 3u },
  { "img_alt", &ALST_IMG_ALT, 11u, 2u },
  { "/img_alt", NULL, 0u, 3u },
  { " ", &ALST_NOP, 1u, 2u },
  { "pre_plain", NULL, 0u, 2u },
  { "/pre_plain", NULL, 0u, 3u },
  { "internal", NULL, 0u, 2u },
  { "/internal", NULL, 0u, 3u },
  { "div_int", &ALST_P, 2u, 2u },
  { "/div_int", NULL, 0u, 3u }
}; // idb
TagAttrInfo AttrMAP[75] =
{
  { NULL, 0u, 0u },
  { "accept", 0u, 0u },
  { "accept-charset", 1u, 0u },
  { "action", 6u, 0u },
  { "align", 4u, 0u },
  { "alt", 1u, 0u },
  { "archive", 1u, 0u },
  { "background", 1u, 0u },
  { "border", 2u, 0u },
  { "cellpadding", 2u, 0u },
  { "cellspacing", 2u, 0u },
  { "charset", 1u, 0u },
  { "checked", 0u, 0u },
  { "cols", 9u, 0u },
  { "colspan", 2u, 0u },
  { "content", 1u, 0u },
  { "enctype", 7u, 0u },
  { "height", 3u, 0u },
  { "href", 1u, 0u },
  { "http-equiv", 1u, 0u },
  { "id", 1u, 0u },
  { "link", 1u, 0u },
  { "maxlength", 2u, 0u },
  { "method", 8u, 0u },
  { "multiple", 0u, 0u },
  { "name", 1u, 0u },
  { "nowrap", 0u, 0u },
  { "prompt", 1u, 0u },
  { "rows", 9u, 0u },
  { "rowspan", 2u, 0u },
  { "size", 2u, 0u },
  { "src", 1u, 0u },
  { "target", 1u, 0u },
  { "type", 10u, 0u },
  { "usemap", 1u, 0u },
  { "valign", 5u, 0u },
  { "value", 1u, 0u },
  { "vspace", 2u, 0u },
  { "width", 3u, 0u },
  { "compact", 0u, 0u },
  { "start", 2u, 0u },
  { "selected", 0u, 0u },
  { "label", 1u, 0u },
  { "readonly", 0u, 0u },
  { "shape", 1u, 0u },
  { "coords", 1u, 0u },
  { "ismap", 0u, 0u },
  { "rel", 1u, 0u },
  { "rev", 1u, 0u },
  { "title", 1u, 0u },
  { "accesskey", 1u, 0u },
  { NULL, 0u, 0u },
  { NULL, 0u, 0u },
  { NULL, 0u, 0u },
  { NULL, 0u, 0u },
  { NULL, 0u, 0u },
  { NULL, 0u, 0u },
  { NULL, 0u, 0u },
  { NULL, 0u, 0u },
  { NULL, 0u, 0u },
  { "xoffset", 2u, 1u },
  { "yoffset", 2u, 1u },
  { "top_margin", 2u, 1u },
  { "bottom_margin", 2u, 1u },
  { "tid", 2u, 1u },
  { "fid", 2u, 1u },
  { "for_table", 0u, 1u },
  { "framename", 1u, 1u },
  { "hborder", 0u, 0u },
  { "hseq", 2u, 1u },
  { "no_effect", 0u, 1u },
  { "referer", 1u, 1u },
  { "selectnumber", 2u, 1u },
  { "textareanumber", 2u, 1u },
  { "pre_int", 0u, 1u }
}; // idb
int (*toValFunc[11])(...) =
{
  &noConv,
  &noConv,
  &toNumber,
  &toLength,
  &toAlign,
  &toVAlign,
  &noConv,
  &noConv,
  &noConv,
  &noConv,
  &noConv
}; // idb
Hash_si_0 tagtable = { 100, &MyHashItemTbl_0 }; // idb
char *w3m_version = "w3m/0.5.2"; // idb
Hash_si_0 entity = { 100, &MyHashItemTbl_1 }; // idb
unsigned __int8 QUOTE_MAP[256] =
{
  24u,
  24u,
  24u,
  24u,
  24u,
  24u,
  24u,
  24u,
  24u,
  24u,
  24u,
  24u,
  24u,
  24u,
  24u,
  24u,
  24u,
  24u,
  24u,
  24u,
  24u,
  24u,
  24u,
  24u,
  24u,
  24u,
  24u,
  24u,
  24u,
  24u,
  24u,
  24u,
  24u,
  72u,
  76u,
  40u,
  8u,
  40u,
  41u,
  72u,
  72u,
  72u,
  72u,
  40u,
  72u,
  8u,
  0u,
  64u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  32u,
  72u,
  74u,
  72u,
  75u,
  40u,
  72u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  72u,
  72u,
  72u,
  72u,
  0u,
  72u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  72u,
  72u,
  72u,
  72u,
  24u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u
}; // idb
char *HTML_QUOTE_MAP[8] = { NULL, "&amp;", "&lt;", "&gt;", "&quot;", NULL, NULL, NULL }; // idb
char xdigit[17] = "0123456789ABCDEF"; // idb
unsigned __int8 MYCTYPE_MAP[256] =
{
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  3u,
  3u,
  3u,
  3u,
  3u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  18u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  24u,
  24u,
  24u,
  24u,
  24u,
  24u,
  24u,
  24u,
  24u,
  24u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  52u,
  52u,
  52u,
  52u,
  52u,
  52u,
  20u,
  20u,
  20u,
  20u,
  20u,
  20u,
  20u,
  20u,
  20u,
  20u,
  20u,
  20u,
  20u,
  20u,
  20u,
  20u,
  20u,
  20u,
  20u,
  20u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  52u,
  52u,
  52u,
  52u,
  52u,
  52u,
  20u,
  20u,
  20u,
  20u,
  20u,
  20u,
  20u,
  20u,
  20u,
  20u,
  20u,
  20u,
  20u,
  20u,
  20u,
  20u,
  20u,
  20u,
  20u,
  20u,
  16u,
  16u,
  16u,
  16u,
  1u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // idb
unsigned __int8 MYCTYPE_DIGITMAP[256] =
{
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  0u,
  1u,
  2u,
  3u,
  4u,
  5u,
  6u,
  7u,
  8u,
  9u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  10u,
  11u,
  12u,
  13u,
  14u,
  15u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  10u,
  11u,
  12u,
  13u,
  14u,
  15u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u,
  255u
}; // idb
wc_ces char_conv_t_ces = 3211264u; // idb
$81A9C281C370E3D80FBB77EE82830491 lang_ces_table[14] =
{
  { "cs", 1049090u },
  { "el", 1049095u },
  { "iw", 1049096u },
  { "ja", 3149846u },
  { "ko", 3149849u },
  { "hu", 1049090u },
  { "pl", 1049090u },
  { "ro", 1049090u },
  { "ru", 1049093u },
  { "sk", 1049090u },
  { "sl", 1049090u },
  { "tr", 1049097u },
  { "zh", 3149847u },
  { NULL, 0u }
}; // idb
char *WcReplace = "?"; // idb
char *WcReplaceW = "??"; // idb
wc_uint8 WC_DETECT_MAP[256] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u
}; // idb
wc_ces detect_ces_2403 = 256u; // idb
wc_uint8 WC_ISO_MAP[256] =
{
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  17u,
  18u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  19u,
  16u,
  16u,
  16u,
  16u,
  32u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  32u,
  80u,
  80u,
  80u,
  80u,
  80u,
  80u,
  80u,
  80u,
  80u,
  80u,
  80u,
  80u,
  80u,
  80u,
  84u,
  85u,
  80u,
  80u,
  80u,
  80u,
  80u,
  80u,
  80u,
  80u,
  80u,
  80u,
  80u,
  80u,
  80u,
  80u,
  80u,
  80u,
  96u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  96u
}; // idb
wc_uint16 jisx0201k_jisx0208_map[128] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  8481u,
  8483u,
  8534u,
  8535u,
  8482u,
  8486u,
  9586u,
  9505u,
  9507u,
  9509u,
  9511u,
  9513u,
  9571u,
  9573u,
  9575u,
  9539u,
  8508u,
  9506u,
  9508u,
  9510u,
  9512u,
  9514u,
  9515u,
  9517u,
  9519u,
  9521u,
  9523u,
  9525u,
  9527u,
  9529u,
  9531u,
  9533u,
  9535u,
  9537u,
  9540u,
  9542u,
  9544u,
  9546u,
  9547u,
  9548u,
  9549u,
  9550u,
  9551u,
  9554u,
  9557u,
  9560u,
  9563u,
  9566u,
  9567u,
  9568u,
  9569u,
  9570u,
  9572u,
  9574u,
  9576u,
  9577u,
  9578u,
  9579u,
  9580u,
  9581u,
  9583u,
  9587u,
  8491u,
  8492u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // idb
wc_map jisx0208_jisx02131_map[18] =
{
  { 8751u, 8761u },
  { 8770u, 8777u },
  { 8785u, 8795u },
  { 8811u, 8817u },
  { 8826u, 8829u },
  { 8993u, 9007u },
  { 9018u, 9024u },
  { 9051u, 9056u },
  { 9083u, 9086u },
  { 9332u, 9342u },
  { 9591u, 9598u },
  { 9785u, 9792u },
  { 9817u, 9854u },
  { 10050u, 10064u },
  { 10098u, 10110u },
  { 10305u, 12158u },
  { 20308u, 20350u },
  { 29733u, 32382u }
}; // idb
wc_uint8 WC_JOHAB_MAP[256] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  33u,
  33u,
  33u,
  33u,
  33u,
  33u,
  33u,
  33u,
  33u,
  33u,
  33u,
  33u,
  33u,
  33u,
  33u,
  33u,
  49u,
  49u,
  49u,
  49u,
  49u,
  49u,
  49u,
  49u,
  49u,
  49u,
  49u,
  49u,
  49u,
  49u,
  49u,
  49u,
  49u,
  49u,
  49u,
  49u,
  49u,
  49u,
  49u,
  49u,
  49u,
  49u,
  49u,
  49u,
  49u,
  49u,
  49u,
  49u,
  49u,
  49u,
  49u,
  49u,
  49u,
  49u,
  49u,
  49u,
  49u,
  49u,
  49u,
  49u,
  49u,
  49u,
  49u,
  49u,
  49u,
  49u,
  49u,
  49u,
  49u,
  49u,
  49u,
  49u,
  49u,
  49u,
  49u,
  49u,
  49u,
  49u,
  0u,
  8u,
  24u,
  24u,
  24u,
  18u,
  18u,
  18u,
  18u,
  18u,
  18u,
  18u,
  18u,
  18u,
  18u,
  18u,
  18u,
  18u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  56u,
  56u,
  56u,
  56u,
  52u,
  52u,
  52u,
  52u,
  52u,
  52u,
  52u,
  56u,
  52u,
  52u,
  52u,
  52u,
  52u,
  52u,
  52u,
  52u,
  52u,
  52u,
  52u,
  52u,
  52u,
  52u,
  52u,
  52u,
  52u,
  52u,
  52u,
  52u,
  52u,
  52u,
  52u,
  52u,
  52u,
  52u,
  56u,
  56u,
  56u,
  56u,
  56u,
  8u
}; // idb
wc_uint8 johab1_N_map[3][32] =
{
  {
    0u,
    0u,
    1u,
    2u,
    3u,
    4u,
    5u,
    6u,
    7u,
    8u,
    9u,
    10u,
    11u,
    12u,
    13u,
    14u,
    15u,
    16u,
    17u,
    18u,
    19u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u
  },
  {
    0u,
    0u,
    0u,
    1u,
    2u,
    3u,
    4u,
    5u,
    0u,
    0u,
    6u,
    7u,
    8u,
    9u,
    10u,
    11u,
    0u,
    0u,
    12u,
    13u,
    14u,
    15u,
    16u,
    17u,
    0u,
    0u,
    18u,
    19u,
    20u,
    21u,
    0u,
    0u
  },
  {
    0u,
    1u,
    2u,
    3u,
    4u,
    5u,
    6u,
    7u,
    8u,
    9u,
    10u,
    11u,
    12u,
    13u,
    14u,
    15u,
    16u,
    17u,
    0u,
    18u,
    19u,
    20u,
    21u,
    22u,
    23u,
    24u,
    25u,
    26u,
    27u,
    28u,
    0u,
    0u
  }
}; // idb
wc_uint8 N_johab1_map[3][32] =
{
  {
    2u,
    3u,
    4u,
    5u,
    6u,
    7u,
    8u,
    9u,
    10u,
    11u,
    12u,
    13u,
    14u,
    15u,
    16u,
    17u,
    18u,
    19u,
    20u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u
  },
  {
    3u,
    4u,
    5u,
    6u,
    7u,
    10u,
    11u,
    12u,
    13u,
    14u,
    15u,
    18u,
    19u,
    20u,
    21u,
    22u,
    23u,
    26u,
    27u,
    28u,
    29u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u
  },
  {
    1u,
    2u,
    3u,
    4u,
    5u,
    6u,
    7u,
    8u,
    9u,
    10u,
    11u,
    12u,
    13u,
    14u,
    15u,
    16u,
    17u,
    19u,
    20u,
    21u,
    22u,
    23u,
    24u,
    25u,
    26u,
    27u,
    28u,
    29u,
    0u,
    0u,
    0u,
    0u
  }
}; // idb
wc_uchar jisx02132_sjis_map[128] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  240u,
  0u,
  241u,
  241u,
  242u,
  0u,
  0u,
  240u,
  0u,
  0u,
  0u,
  242u,
  243u,
  243u,
  244u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  244u,
  245u,
  245u,
  246u,
  246u,
  247u,
  247u,
  248u,
  248u,
  249u,
  249u,
  250u,
  250u,
  251u,
  251u,
  252u,
  252u,
  0u
}; // idb
wc_uchar sjis1_jisx02132_map[16] =
{
  33u,
  35u,
  37u,
  45u,
  47u,
  111u,
  113u,
  115u,
  117u,
  119u,
  121u,
  123u,
  125u,
  0u,
  0u,
  0u
}; // idb
wc_uchar sjis2_jisx02132_map[16] =
{
  40u,
  36u,
  44u,
  46u,
  110u,
  112u,
  114u,
  116u,
  118u,
  120u,
  122u,
  124u,
  126u,
  0u,
  0u,
  0u
}; // idb
wc_uchar *wc_jisx0212_jisx02132_map = &jisx02132_sjis_map; // idb
wc_uint8 WC_SJIS_MAP[256] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  0u,
  18u,
  52u,
  52u,
  52u,
  52u,
  52u,
  52u,
  52u,
  52u,
  52u,
  52u,
  52u,
  52u,
  52u,
  52u,
  52u,
  52u,
  52u,
  52u,
  52u,
  52u,
  52u,
  52u,
  52u,
  52u,
  52u,
  52u,
  52u,
  52u,
  52u,
  52u,
  52u,
  23u,
  19u,
  19u,
  19u,
  19u,
  19u,
  19u,
  19u,
  19u,
  19u,
  19u,
  19u,
  19u,
  19u,
  19u,
  19u,
  19u,
  19u,
  19u,
  19u,
  19u,
  19u,
  19u,
  19u,
  19u,
  19u,
  19u,
  19u,
  19u,
  19u,
  19u,
  19u,
  19u,
  19u,
  19u,
  19u,
  19u,
  19u,
  19u,
  19u,
  19u,
  19u,
  19u,
  19u,
  19u,
  19u,
  19u,
  19u,
  19u,
  19u,
  19u,
  19u,
  19u,
  19u,
  19u,
  19u,
  19u,
  19u,
  19u,
  19u,
  19u,
  19u,
  19u,
  19u,
  53u,
  53u,
  53u,
  53u,
  53u,
  53u,
  53u,
  53u,
  53u,
  53u,
  53u,
  53u,
  53u,
  53u,
  53u,
  53u,
  54u,
  54u,
  54u,
  54u,
  54u,
  54u,
  54u,
  54u,
  54u,
  54u,
  54u,
  54u,
  54u,
  64u,
  64u,
  64u
}; // idb
wc_option WcOption = { 2u, 1u, 1u, 1u, 0u, 1u, 0u, 0u, 0u, 0u, 0u, 0u, 1u, 0u, 0u, 1u }; // idb
wc_map cp12582_ucs_map[120] =
{
  { 16844u, 192u },
  { 16850u, 7842u },
  { 16862u, 195u },
  { 16876u, 193u },
  { 16882u, 7840u },
  { 17868u, 200u },
  { 17874u, 7866u },
  { 17886u, 7868u },
  { 17900u, 201u },
  { 17906u, 7864u },
  { 18892u, 204u },
  { 18898u, 7880u },
  { 18910u, 296u },
  { 18924u, 205u },
  { 18930u, 7882u },
  { 20428u, 210u },
  { 20434u, 7886u },
  { 20446u, 213u },
  { 20460u, 211u },
  { 20466u, 7884u },
  { 21964u, 217u },
  { 21970u, 7910u },
  { 21982u, 360u },
  { 21996u, 218u },
  { 22002u, 7908u },
  { 22988u, 7922u },
  { 22994u, 7926u },
  { 23006u, 7928u },
  { 23020u, 221u },
  { 23026u, 7924u },
  { 25036u, 224u },
  { 25042u, 7843u },
  { 25054u, 227u },
  { 25068u, 225u },
  { 25074u, 7841u },
  { 26060u, 232u },
  { 26066u, 7867u },
  { 26078u, 7869u },
  { 26092u, 233u },
  { 26098u, 7865u },
  { 27084u, 236u },
  { 27090u, 7881u },
  { 27102u, 297u },
  { 27116u, 237u },
  { 27122u, 7883u },
  { 28620u, 242u },
  { 28626u, 7887u },
  { 28638u, 245u },
  { 28652u, 243u },
  { 28658u, 7885u },
  { 30156u, 249u },
  { 30162u, 7911u },
  { 30174u, 361u },
  { 30188u, 250u },
  { 30194u, 7909u },
  { 31180u, 7923u },
  { 31186u, 7927u },
  { 31198u, 7929u },
  { 31212u, 253u },
  { 31218u, 7925u },
  { 49868u, 7846u },
  { 49874u, 7848u },
  { 49886u, 7850u },
  { 49900u, 7844u },
  { 49906u, 7852u },
  { 50124u, 7856u },
  { 50130u, 7858u },
  { 50142u, 7860u },
  { 50156u, 7854u },
  { 50162u, 7862u },
  { 51916u, 7872u },
  { 51922u, 7874u },
  { 51934u, 7876u },
  { 51948u, 7870u },
  { 51954u, 7878u },
  { 54476u, 7890u },
  { 54482u, 7892u },
  { 54494u, 7894u },
  { 54508u, 7888u },
  { 54514u, 7896u },
  { 54732u, 7900u },
  { 54738u, 7902u },
  { 54750u, 7904u },
  { 54764u, 7898u },
  { 54770u, 7906u },
  { 56780u, 7914u },
  { 56786u, 7916u },
  { 56798u, 7918u },
  { 56812u, 7912u },
  { 56818u, 7920u },
  { 58060u, 7847u },
  { 58066u, 7849u },
  { 58078u, 7851u },
  { 58092u, 7845u },
  { 58098u, 7853u },
  { 58316u, 7857u },
  { 58322u, 7859u },
  { 58334u, 7861u },
  { 58348u, 7855u },
  { 58354u, 7863u },
  { 60108u, 7873u },
  { 60114u, 7875u },
  { 60126u, 7877u },
  { 60140u, 7871u },
  { 60146u, 7879u },
  { 62668u, 7891u },
  { 62674u, 7893u },
  { 62686u, 7895u },
  { 62700u, 7889u },
  { 62706u, 7897u },
  { 62924u, 7901u },
  { 62930u, 7903u },
  { 62942u, 7905u },
  { 62956u, 7899u },
  { 62962u, 7907u },
  { 64972u, 7915u },
  { 64978u, 7917u },
  { 64990u, 7919u },
  { 65004u, 7913u },
  { 65010u, 7921u }
}; // idb
wc_map jisx02131_ucs_p2_map[25] =
{
  { 11810u, 11u },
  { 12098u, 4669u },
  { 12108u, 4891u },
  { 12128u, 5230u },
  { 12155u, 6333u },
  { 20323u, 5812u },
  { 20334u, 7732u },
  { 30010u, 12740u },
  { 30066u, 13764u },
  { 30249u, 14143u },
  { 30258u, 14179u },
  { 30304u, 15614u },
  { 30572u, 18417u },
  { 30846u, 21646u },
  { 31017u, 21774u },
  { 31047u, 22385u },
  { 31060u, 22980u },
  { 31086u, 23969u },
  { 31325u, 27391u },
  { 31539u, 28224u },
  { 31561u, 28916u },
  { 31596u, 30340u },
  { 31817u, 33399u },
  { 31825u, 33741u },
  { 32358u, 41360u }
}; // idb
wc_map ucs_p2_jisx02131_map[25] =
{
  { 11u, 11810u },
  { 4669u, 12098u },
  { 4891u, 12108u },
  { 5230u, 12128u },
  { 5812u, 20323u },
  { 6333u, 12155u },
  { 7732u, 20334u },
  { 12740u, 30010u },
  { 13764u, 30066u },
  { 14143u, 30249u },
  { 14179u, 30258u },
  { 15614u, 30304u },
  { 18417u, 30572u },
  { 21646u, 30846u },
  { 21774u, 31017u },
  { 22385u, 31047u },
  { 22980u, 31060u },
  { 23969u, 31086u },
  { 27391u, 31325u },
  { 28224u, 31539u },
  { 28916u, 31561u },
  { 30340u, 31596u },
  { 33399u, 31817u },
  { 33741u, 31825u },
  { 41360u, 32358u }
}; // idb
wc_map jisx02132_ucs_p2_map[277] =
{
  { 8481u, 137u },
  { 8491u, 162u },
  { 8494u, 164u },
  { 8502u, 418u },
  { 8518u, 531u },
  { 8560u, 811u },
  { 8567u, 897u },
  { 8569u, 881u },
  { 8994u, 1017u },
  { 8997u, 1098u },
  { 8999u, 1289u },
  { 9009u, 1494u },
  { 9010u, 1576u },
  { 9016u, 1871u },
  { 9023u, 2055u },
  { 9025u, 2106u },
  { 9034u, 2233u },
  { 9042u, 2428u },
  { 9043u, 2461u },
  { 9049u, 2771u },
  { 9052u, 2845u },
  { 9079u, 3397u },
  { 9258u, 3553u },
  { 9265u, 3733u },
  { 9266u, 3693u },
  { 9274u, 3684u },
  { 9277u, 3935u },
  { 9305u, 4609u },
  { 9308u, 4693u },
  { 9310u, 4731u },
  { 9315u, 4724u },
  { 9322u, 4836u },
  { 9323u, 4823u },
  { 9330u, 4861u },
  { 9332u, 4918u },
  { 9333u, 4932u },
  { 9509u, 5060u },
  { 9522u, 5229u },
  { 9534u, 5591u },
  { 9540u, 27689u },
  { 9543u, 5703u },
  { 9557u, 5894u },
  { 9558u, 5954u },
  { 9598u, 6595u },
  { 10288u, 7254u },
  { 10295u, 7469u },
  { 10296u, 7493u },
  { 10298u, 7544u },
  { 10299u, 7522u },
  { 10303u, 7585u },
  { 10304u, 7580u },
  { 10309u, 7570u },
  { 10312u, 7607u },
  { 10314u, 7648u },
  { 10315u, 7731u },
  { 10331u, 7966u },
  { 10342u, 8054u },
  { 10348u, 8186u },
  { 11298u, 8571u },
  { 11307u, 8990u },
  { 11312u, 9133u },
  { 11344u, 9971u },
  { 11365u, 10331u },
  { 11373u, 10411u },
  { 11378u, 10639u },
  { 11556u, 10936u },
  { 11561u, 11087u },
  { 11562u, 11088u },
  { 11570u, 11078u },
  { 11572u, 11293u },
  { 11573u, 11174u },
  { 11577u, 11300u },
  { 11606u, 11745u },
  { 11645u, 12739u },
  { 11811u, 12789u },
  { 11812u, 12726u },
  { 11834u, 13170u },
  { 11836u, 13267u },
  { 11837u, 13266u },
  { 11842u, 13264u },
  { 11843u, 13284u },
  { 11844u, 13269u },
  { 11847u, 13274u },
  { 11849u, 13279u },
  { 11861u, 13386u },
  { 11862u, 13393u },
  { 11863u, 13387u },
  { 11867u, 13413u },
  { 11895u, 13540u },
  { 11896u, 13658u },
  { 12074u, 13716u },
  { 12095u, 13881u },
  { 12096u, 13895u },
  { 12098u, 13880u },
  { 12099u, 13882u },
  { 12110u, 14108u },
  { 12121u, 14092u },
  { 12129u, 14180u },
  { 12137u, 14335u },
  { 12138u, 14311u },
  { 12144u, 14372u },
  { 12149u, 14397u },
  { 28195u, 15000u },
  { 28212u, 15487u },
  { 28233u, 15616u },
  { 28252u, 15680u },
  { 28254u, 15866u },
  { 28255u, 15865u },
  { 28256u, 15827u },
  { 28466u, 16254u },
  { 28487u, 16534u },
  { 28493u, 16643u },
  { 28513u, 16838u },
  { 28516u, 16894u },
  { 28706u, 17340u },
  { 28723u, 17961u },
  { 28729u, 18085u },
  { 28755u, 18582u },
  { 28795u, 19021u },
  { 28974u, 19286u },
  { 28976u, 19311u },
  { 28981u, 19478u },
  { 28996u, 19732u },
  { 29021u, 19982u },
  { 29025u, 20023u },
  { 29030u, 20074u },
  { 29033u, 20107u },
  { 29045u, 20554u },
  { 29047u, 20565u },
  { 29050u, 20770u },
  { 29217u, 20905u },
  { 29219u, 20965u },
  { 29220u, 20941u },
  { 29224u, 21022u },
  { 29228u, 21068u },
  { 29245u, 21550u },
  { 29256u, 21721u },
  { 29275u, 21927u },
  { 29301u, 22441u },
  { 29302u, 22452u },
  { 29490u, 22996u },
  { 29501u, 23268u },
  { 29502u, 23267u },
  { 29504u, 23281u },
  { 29522u, 23474u },
  { 29533u, 23627u },
  { 29534u, 23652u },
  { 29555u, 24110u },
  { 29556u, 24150u },
  { 29557u, 24165u },
  { 29559u, 24162u },
  { 29563u, 24280u },
  { 29565u, 24258u },
  { 29730u, 24296u },
  { 29732u, 24355u },
  { 29735u, 24412u },
  { 29742u, 24544u },
  { 29743u, 24532u },
  { 29748u, 24588u },
  { 29749u, 24571u },
  { 29757u, 24599u },
  { 29762u, 24672u },
  { 29775u, 24813u },
  { 29801u, 25200u },
  { 29803u, 25222u },
  { 29810u, 25420u },
  { 29813u, 15630u },
  { 29817u, 25602u },
  { 30005u, 26238u },
  { 30010u, 26288u },
  { 30022u, 26397u },
  { 30038u, 26845u },
  { 30040u, 26858u },
  { 30042u, 26961u },
  { 30045u, 26991u },
  { 30047u, 27101u },
  { 30051u, 27166u },
  { 30058u, 27224u },
  { 30064u, 27276u },
  { 30067u, 27319u },
  { 30276u, 27763u },
  { 30286u, 27869u },
  { 30301u, 28261u },
  { 30325u, 28564u },
  { 30334u, 28664u },
  { 30497u, 28662u },
  { 30498u, 28663u },
  { 30515u, 28941u },
  { 30518u, 28985u },
  { 30564u, 29659u },
  { 30565u, 29658u },
  { 30571u, 29694u },
  { 30574u, 29712u },
  { 30579u, 29769u },
  { 30761u, 30229u },
  { 30762u, 30228u },
  { 30764u, 30257u },
  { 30772u, 30355u },
  { 30780u, 30478u },
  { 30782u, 30499u },
  { 30786u, 30546u },
  { 30806u, 31109u },
  { 30819u, 31364u },
  { 30839u, 31667u },
  { 30841u, 31678u },
  { 30842u, 31687u },
  { 31013u, 31928u },
  { 31023u, 32160u },
  { 31026u, 32272u },
  { 31033u, 32695u },
  { 31042u, 32906u },
  { 31048u, 32955u },
  { 31065u, 33410u },
  { 31070u, 33523u },
  { 31078u, 33804u },
  { 31083u, 33877u },
  { 31098u, 34155u },
  { 31102u, 34248u },
  { 31265u, 34249u },
  { 31276u, 34519u },
  { 31279u, 34554u },
  { 31311u, 35145u },
  { 31312u, 35142u },
  { 31319u, 35179u },
  { 31333u, 35207u },
  { 31334u, 35208u },
  { 31345u, 35258u },
  { 31346u, 35259u },
  { 31358u, 35358u },
  { 31521u, 35369u },
  { 31532u, 35441u },
  { 31533u, 35395u },
  { 31542u, 35481u },
  { 31543u, 35533u },
  { 31549u, 35556u },
  { 31550u, 35549u },
  { 31566u, 35777u },
  { 31567u, 35823u },
  { 31575u, 36112u },
  { 31578u, 36209u },
  { 31580u, 36347u },
  { 31581u, 36383u },
  { 31585u, 36406u },
  { 31589u, 36489u },
  { 31591u, 36587u },
  { 31593u, 36658u },
  { 31601u, 36856u },
  { 31778u, 37536u },
  { 31779u, 37553u },
  { 31800u, 38032u },
  { 31810u, 38351u },
  { 31820u, 38527u },
  { 31830u, 38640u },
  { 31833u, 38681u },
  { 31837u, 38736u },
  { 31862u, 39110u },
  { 32044u, 39538u },
  { 32075u, 40411u },
  { 32076u, 40509u },
  { 32089u, 40469u },
  { 32091u, 40586u },
  { 32093u, 40521u },
  { 32103u, 40644u },
  { 32109u, 40681u },
  { 32112u, 40667u },
  { 32293u, 40910u },
  { 32297u, 41007u },
  { 32299u, 40986u },
  { 32306u, 41209u },
  { 32309u, 41090u },
  { 32339u, 8728u },
  { 32344u, 41868u },
  { 32346u, 42039u },
  { 32366u, 42481u },
  { 32368u, 42498u },
  { 32370u, 42522u },
  { 32374u, 42674u }
}; // idb
wc_map ucs_p2_jisx02132_map[277] =
{
  { 137u, 8481u },
  { 162u, 8491u },
  { 164u, 8494u },
  { 418u, 8502u },
  { 531u, 8518u },
  { 811u, 8560u },
  { 881u, 8569u },
  { 897u, 8567u },
  { 1017u, 8994u },
  { 1098u, 8997u },
  { 1289u, 8999u },
  { 1494u, 9009u },
  { 1576u, 9010u },
  { 1871u, 9016u },
  { 2055u, 9023u },
  { 2106u, 9025u },
  { 2233u, 9034u },
  { 2428u, 9042u },
  { 2461u, 9043u },
  { 2771u, 9049u },
  { 2845u, 9052u },
  { 3397u, 9079u },
  { 3553u, 9258u },
  { 3684u, 9274u },
  { 3693u, 9266u },
  { 3733u, 9265u },
  { 3935u, 9277u },
  { 4609u, 9305u },
  { 4693u, 9308u },
  { 4724u, 9315u },
  { 4731u, 9310u },
  { 4823u, 9323u },
  { 4836u, 9322u },
  { 4861u, 9330u },
  { 4918u, 9332u },
  { 4932u, 9333u },
  { 5060u, 9509u },
  { 5229u, 9522u },
  { 5591u, 9534u },
  { 5703u, 9543u },
  { 5894u, 9557u },
  { 5954u, 9558u },
  { 6595u, 9598u },
  { 7254u, 10288u },
  { 7469u, 10295u },
  { 7493u, 10296u },
  { 7522u, 10299u },
  { 7544u, 10298u },
  { 7570u, 10309u },
  { 7580u, 10304u },
  { 7585u, 10303u },
  { 7607u, 10312u },
  { 7648u, 10314u },
  { 7731u, 10315u },
  { 7966u, 10331u },
  { 8054u, 10342u },
  { 8186u, 10348u },
  { 8571u, 11298u },
  { 8728u, 32339u },
  { 8990u, 11307u },
  { 9133u, 11312u },
  { 9971u, 11344u },
  { 10331u, 11365u },
  { 10411u, 11373u },
  { 10639u, 11378u },
  { 10936u, 11556u },
  { 11078u, 11570u },
  { 11087u, 11561u },
  { 11088u, 11562u },
  { 11174u, 11573u },
  { 11293u, 11572u },
  { 11300u, 11577u },
  { 11745u, 11606u },
  { 12726u, 11812u },
  { 12739u, 11645u },
  { 12789u, 11811u },
  { 13170u, 11834u },
  { 13264u, 11842u },
  { 13266u, 11837u },
  { 13267u, 11836u },
  { 13269u, 11844u },
  { 13274u, 11847u },
  { 13279u, 11849u },
  { 13284u, 11843u },
  { 13386u, 11861u },
  { 13387u, 11863u },
  { 13393u, 11862u },
  { 13413u, 11867u },
  { 13540u, 11895u },
  { 13658u, 11896u },
  { 13716u, 12074u },
  { 13880u, 12098u },
  { 13881u, 12095u },
  { 13882u, 12099u },
  { 13895u, 12096u },
  { 14092u, 12121u },
  { 14108u, 12110u },
  { 14180u, 12129u },
  { 14311u, 12138u },
  { 14335u, 12137u },
  { 14372u, 12144u },
  { 14397u, 12149u },
  { 15000u, 28195u },
  { 15487u, 28212u },
  { 15616u, 28233u },
  { 15630u, 29813u },
  { 15680u, 28252u },
  { 15827u, 28256u },
  { 15865u, 28255u },
  { 15866u, 28254u },
  { 16254u, 28466u },
  { 16534u, 28487u },
  { 16643u, 28493u },
  { 16838u, 28513u },
  { 16894u, 28516u },
  { 17340u, 28706u },
  { 17961u, 28723u },
  { 18085u, 28729u },
  { 18582u, 28755u },
  { 19021u, 28795u },
  { 19286u, 28974u },
  { 19311u, 28976u },
  { 19478u, 28981u },
  { 19732u, 28996u },
  { 19982u, 29021u },
  { 20023u, 29025u },
  { 20074u, 29030u },
  { 20107u, 29033u },
  { 20554u, 29045u },
  { 20565u, 29047u },
  { 20770u, 29050u },
  { 20905u, 29217u },
  { 20941u, 29220u },
  { 20965u, 29219u },
  { 21022u, 29224u },
  { 21068u, 29228u },
  { 21550u, 29245u },
  { 21721u, 29256u },
  { 21927u, 29275u },
  { 22441u, 29301u },
  { 22452u, 29302u },
  { 22996u, 29490u },
  { 23267u, 29502u },
  { 23268u, 29501u },
  { 23281u, 29504u },
  { 23474u, 29522u },
  { 23627u, 29533u },
  { 23652u, 29534u },
  { 24110u, 29555u },
  { 24150u, 29556u },
  { 24162u, 29559u },
  { 24165u, 29557u },
  { 24258u, 29565u },
  { 24280u, 29563u },
  { 24296u, 29730u },
  { 24355u, 29732u },
  { 24412u, 29735u },
  { 24532u, 29743u },
  { 24544u, 29742u },
  { 24571u, 29749u },
  { 24588u, 29748u },
  { 24599u, 29757u },
  { 24672u, 29762u },
  { 24813u, 29775u },
  { 25200u, 29801u },
  { 25222u, 29803u },
  { 25420u, 29810u },
  { 25602u, 29817u },
  { 26238u, 30005u },
  { 26288u, 30010u },
  { 26397u, 30022u },
  { 26845u, 30038u },
  { 26858u, 30040u },
  { 26961u, 30042u },
  { 26991u, 30045u },
  { 27101u, 30047u },
  { 27166u, 30051u },
  { 27224u, 30058u },
  { 27276u, 30064u },
  { 27319u, 30067u },
  { 27689u, 9540u },
  { 27763u, 30276u },
  { 27869u, 30286u },
  { 28261u, 30301u },
  { 28564u, 30325u },
  { 28662u, 30497u },
  { 28663u, 30498u },
  { 28664u, 30334u },
  { 28941u, 30515u },
  { 28985u, 30518u },
  { 29658u, 30565u },
  { 29659u, 30564u },
  { 29694u, 30571u },
  { 29712u, 30574u },
  { 29769u, 30579u },
  { 30228u, 30762u },
  { 30229u, 30761u },
  { 30257u, 30764u },
  { 30355u, 30772u },
  { 30478u, 30780u },
  { 30499u, 30782u },
  { 30546u, 30786u },
  { 31109u, 30806u },
  { 31364u, 30819u },
  { 31667u, 30839u },
  { 31678u, 30841u },
  { 31687u, 30842u },
  { 31928u, 31013u },
  { 32160u, 31023u },
  { 32272u, 31026u },
  { 32695u, 31033u },
  { 32906u, 31042u },
  { 32955u, 31048u },
  { 33410u, 31065u },
  { 33523u, 31070u },
  { 33804u, 31078u },
  { 33877u, 31083u },
  { 34155u, 31098u },
  { 34248u, 31102u },
  { 34249u, 31265u },
  { 34519u, 31276u },
  { 34554u, 31279u },
  { 35142u, 31312u },
  { 35145u, 31311u },
  { 35179u, 31319u },
  { 35207u, 31333u },
  { 35208u, 31334u },
  { 35258u, 31345u },
  { 35259u, 31346u },
  { 35358u, 31358u },
  { 35369u, 31521u },
  { 35395u, 31533u },
  { 35441u, 31532u },
  { 35481u, 31542u },
  { 35533u, 31543u },
  { 35549u, 31550u },
  { 35556u, 31549u },
  { 35777u, 31566u },
  { 35823u, 31567u },
  { 36112u, 31575u },
  { 36209u, 31578u },
  { 36347u, 31580u },
  { 36383u, 31581u },
  { 36406u, 31585u },
  { 36489u, 31589u },
  { 36587u, 31591u },
  { 36658u, 31593u },
  { 36856u, 31601u },
  { 37536u, 31778u },
  { 37553u, 31779u },
  { 38032u, 31800u },
  { 38351u, 31810u },
  { 38527u, 31820u },
  { 38640u, 31830u },
  { 38681u, 31833u },
  { 38736u, 31837u },
  { 39110u, 31862u },
  { 39538u, 32044u },
  { 40411u, 32075u },
  { 40469u, 32089u },
  { 40509u, 32076u },
  { 40521u, 32093u },
  { 40586u, 32091u },
  { 40644u, 32103u },
  { 40667u, 32112u },
  { 40681u, 32109u },
  { 40910u, 32293u },
  { 40986u, 32299u },
  { 41007u, 32297u },
  { 41090u, 32309u },
  { 41209u, 32306u },
  { 41868u, 32344u },
  { 42039u, 32346u },
  { 42481u, 32366u },
  { 42498u, 32368u },
  { 42522u, 32370u },
  { 42674u, 32374u }
}; // idb
wc_map hkscs_ucs_p2_map[1081] =
{
  { 35136u, 41897u },
  { 35148u, 30517u },
  { 35260u, 28686u },
  { 35275u, 7626u },
  { 35276u, 1488u },
  { 35395u, 3138u },
  { 35399u, 11462u },
  { 35401u, 833u },
  { 35403u, 19896u },
  { 35406u, 32958u },
  { 35412u, 27122u },
  { 35413u, 19946u },
  { 35416u, 4020u },
  { 35417u, 3285u },
  { 35418u, 4340u },
  { 35425u, 33366u },
  { 35426u, 17619u },
  { 35428u, 3398u },
  { 35430u, 33001u },
  { 35439u, 21191u },
  { 35447u, 24741u },
  { 35452u, 4215u },
  { 35454u, 4207u },
  { 35494u, 3139u },
  { 35496u, 8609u },
  { 35497u, 35660u },
  { 35507u, 1276u },
  { 35523u, 10101u },
  { 35530u, 3593u },
  { 35531u, 10959u },
  { 35534u, 4296u },
  { 35541u, 8391u },
  { 35543u, 3889u },
  { 35555u, 36045u },
  { 35556u, 3706u },
  { 35561u, 10243u },
  { 35562u, 10553u },
  { 35564u, 20963u },
  { 35566u, 3981u },
  { 35567u, 3754u },
  { 35569u, 3888u },
  { 35570u, 3399u },
  { 35574u, 3755u },
  { 35576u, 3400u },
  { 35577u, 4288u },
  { 35578u, 4413u },
  { 35580u, 9878u },
  { 35582u, 4013u },
  { 35648u, 13300u },
  { 35649u, 30265u },
  { 35650u, 11214u },
  { 35651u, 3454u },
  { 35652u, 3455u },
  { 35653u, 11345u },
  { 35654u, 11349u },
  { 35657u, 4295u },
  { 35658u, 3886u },
  { 35660u, 27472u },
  { 35669u, 40643u },
  { 35672u, 30558u },
  { 35678u, 25970u },
  { 35682u, 32957u },
  { 35684u, 3834u },
  { 35685u, 3599u },
  { 35686u, 3703u },
  { 35687u, 3835u },
  { 35689u, 19947u },
  { 35691u, 3286u },
  { 35693u, 10165u },
  { 35694u, 4297u },
  { 35695u, 3600u },
  { 35696u, 3704u },
  { 35697u, 4216u },
  { 35698u, 4424u },
  { 35699u, 33287u },
  { 35700u, 5205u },
  { 35701u, 3705u },
  { 35702u, 20048u },
  { 35703u, 11684u },
  { 35705u, 4125u },
  { 35706u, 4126u },
  { 35707u, 4341u },
  { 35708u, 4342u },
  { 35710u, 3601u },
  { 35745u, 30356u },
  { 35746u, 33485u },
  { 35747u, 4021u },
  { 35748u, 3707u },
  { 35749u, 20862u },
  { 35751u, 4022u },
  { 35752u, 4480u },
  { 35753u, 21208u },
  { 35756u, 6202u },
  { 35771u, 23412u },
  { 35772u, 12605u },
  { 36322u, 35264u },
  { 36332u, 16193u },
  { 36347u, 805u },
  { 36418u, 28371u },
  { 36420u, 22496u },
  { 36423u, 35817u },
  { 36426u, 22753u },
  { 36427u, 38105u },
  { 36430u, 22956u },
  { 36443u, 23553u },
  { 36448u, 23806u },
  { 36452u, 23476u },
  { 36453u, 27775u },
  { 36458u, 16368u },
  { 36460u, 23653u },
  { 36465u, 23745u },
  { 36471u, 17784u },
  { 36515u, 28228u },
  { 36517u, 28374u },
  { 36524u, 16471u },
  { 36525u, 24617u },
  { 36529u, 6137u },
  { 36533u, 24865u },
  { 36534u, 24922u },
  { 36544u, 25296u },
  { 36547u, 25425u },
  { 36549u, 5729u },
  { 36550u, 104u },
  { 36552u, 14182u },
  { 36554u, 33594u },
  { 36556u, 25737u },
  { 36569u, 26150u },
  { 36571u, 26344u },
  { 36574u, 35400u },
  { 36578u, 9974u },
  { 36580u, 25752u },
  { 36585u, 6238u },
  { 36587u, 19045u },
  { 36588u, 19093u },
  { 36592u, 27218u },
  { 36595u, 5373u },
  { 36598u, 27402u },
  { 36599u, 18855u },
  { 36600u, 13616u },
  { 36601u, 6003u },
  { 36602u, 15864u },
  { 36675u, 3606u },
  { 36676u, 6068u },
  { 36679u, 13658u },
  { 36683u, 16011u },
  { 36684u, 28067u },
  { 36686u, 27543u },
  { 36687u, 13774u },
  { 36693u, 28069u },
  { 36698u, 28372u },
  { 36702u, 28226u },
  { 36714u, 27542u },
  { 36715u, 28279u },
  { 36716u, 28227u },
  { 36725u, 23744u },
  { 36769u, 34341u },
  { 36770u, 34363u },
  { 36775u, 28877u },
  { 36780u, 6306u },
  { 36782u, 29594u },
  { 36785u, 41208u },
  { 36787u, 11303u },
  { 36797u, 30176u },
  { 36798u, 15801u },
  { 36799u, 30180u },
  { 36808u, 30479u },
  { 36815u, 35365u },
  { 36817u, 31012u },
  { 36818u, 31421u },
  { 36823u, 31321u },
  { 36825u, 31546u },
  { 36828u, 31544u },
  { 36832u, 21552u },
  { 36833u, 21861u },
  { 36838u, 19066u },
  { 36846u, 32084u },
  { 36847u, 32143u },
  { 36850u, 32083u },
  { 36852u, 32152u },
  { 36853u, 32189u },
  { 36856u, 6416u },
  { 36929u, 32770u },
  { 36931u, 18826u },
  { 36934u, 28940u },
  { 36942u, 33637u },
  { 36943u, 33810u },
  { 36946u, 41631u },
  { 36947u, 2640u },
  { 36950u, 35294u },
  { 36951u, 34109u },
  { 36952u, 15803u },
  { 36954u, 12898u },
  { 36959u, 8997u },
  { 36961u, 28375u },
  { 36963u, 34108u },
  { 36964u, 31422u },
  { 36966u, 34156u },
  { 36967u, 34315u },
  { 36971u, 34534u },
  { 36979u, 35123u },
  { 36980u, 7817u },
  { 36985u, 21945u },
  { 36987u, 35526u },
  { 36988u, 15515u },
  { 36989u, 35596u },
  { 36990u, 21979u },
  { 37028u, 35553u },
  { 37029u, 35819u },
  { 37032u, 35554u },
  { 37033u, 35557u },
  { 37036u, 35820u },
  { 37037u, 35897u },
  { 37038u, 35839u },
  { 37049u, 34520u },
  { 37050u, 4732u },
  { 37051u, 15918u },
  { 37058u, 28373u },
  { 37062u, 35552u },
  { 37066u, 27832u },
  { 37067u, 628u },
  { 37068u, 25616u },
  { 37069u, 37039u },
  { 37070u, 37093u },
  { 37071u, 19153u },
  { 37072u, 6421u },
  { 37073u, 13066u },
  { 37088u, 37355u },
  { 37092u, 12471u },
  { 37093u, 12476u },
  { 37101u, 21612u },
  { 37104u, 37939u },
  { 37107u, 37917u },
  { 37115u, 29045u },
  { 37117u, 1584u },
  { 37118u, 16732u },
  { 37184u, 22278u },
  { 37190u, 27943u },
  { 37191u, 5843u },
  { 37198u, 18985u },
  { 37200u, 38999u },
  { 37201u, 39173u },
  { 37207u, 22309u },
  { 37209u, 37041u },
  { 37210u, 39893u },
  { 37213u, 39685u },
  { 37218u, 34304u },
  { 37221u, 27048u },
  { 37223u, 12413u },
  { 37226u, 40254u },
  { 37228u, 6243u },
  { 37230u, 16971u },
  { 37234u, 40552u },
  { 37236u, 40887u },
  { 37237u, 41362u },
  { 37239u, 41185u },
  { 37240u, 41251u },
  { 37241u, 41439u },
  { 37283u, 41363u },
  { 37284u, 41504u },
  { 37285u, 6459u },
  { 37286u, 41523u },
  { 37297u, 17252u },
  { 37304u, 35883u },
  { 37309u, 28066u },
  { 37317u, 37003u },
  { 37326u, 18805u },
  { 37327u, 18875u },
  { 37329u, 18936u },
  { 37330u, 17224u },
  { 37331u, 19025u },
  { 37333u, 35802u },
  { 37334u, 6394u },
  { 37336u, 35198u },
  { 37337u, 36406u },
  { 37340u, 35396u },
  { 37344u, 35180u },
  { 37345u, 17593u },
  { 37352u, 17400u },
  { 37356u, 6334u },
  { 37357u, 13721u },
  { 37359u, 6277u },
  { 37360u, 21551u },
  { 37361u, 6136u },
  { 37363u, 5883u },
  { 37366u, 6004u },
  { 37368u, 24395u },
  { 37370u, 5824u },
  { 37372u, 18981u },
  { 37373u, 5118u },
  { 37440u, 5062u },
  { 37441u, 5302u },
  { 37443u, 13990u },
  { 37447u, 29029u },
  { 37448u, 15921u },
  { 37449u, 21852u },
  { 37450u, 16123u },
  { 37451u, 28754u },
  { 37453u, 14062u },
  { 37454u, 39325u },
  { 37455u, 28454u },
  { 37464u, 14143u },
  { 37466u, 16523u },
  { 37468u, 27681u },
  { 37471u, 26289u },
  { 37474u, 2984u },
  { 37475u, 3597u },
  { 37482u, 17462u },
  { 37484u, 1125u },
  { 37485u, 895u },
  { 37488u, 22097u },
  { 37490u, 427u },
  { 37491u, 971u },
  { 37493u, 778u },
  { 37494u, 1044u },
  { 37497u, 704u },
  { 37498u, 36531u },
  { 37499u, 629u },
  { 37542u, 16010u },
  { 37556u, 13717u },
  { 37558u, 16063u },
  { 37560u, 6276u },
  { 37561u, 16009u },
  { 37564u, 1504u },
  { 37566u, 1187u },
  { 37567u, 1170u },
  { 37568u, 1169u },
  { 37570u, 35484u },
  { 37571u, 1806u },
  { 37574u, 2163u },
  { 37579u, 17292u },
  { 37580u, 3104u },
  { 37581u, 18860u },
  { 37584u, 3613u },
  { 37592u, 19132u },
  { 37593u, 16525u },
  { 37597u, 16585u },
  { 37599u, 837u },
  { 37601u, 3014u },
  { 37612u, 35398u },
  { 37613u, 5882u },
  { 37614u, 5999u },
  { 37615u, 5904u },
  { 37623u, 6643u },
  { 37624u, 6241u },
  { 37630u, 24195u },
  { 37697u, 35799u },
  { 37698u, 1043u },
  { 37701u, 4867u },
  { 37705u, 35323u },
  { 37712u, 6550u },
  { 37713u, 6524u },
  { 37714u, 15086u },
  { 37717u, 6403u },
  { 37718u, 6404u },
  { 37720u, 6304u },
  { 37722u, 5886u },
  { 37725u, 35399u },
  { 37726u, 7610u },
  { 37727u, 13426u },
  { 37728u, 35240u },
  { 37731u, 6439u },
  { 37734u, 5947u },
  { 37737u, 30205u },
  { 37740u, 10336u },
  { 37741u, 9771u },
  { 37744u, 9647u },
  { 37745u, 9662u },
  { 37747u, 28531u },
  { 37749u, 62u },
  { 37750u, 70u },
  { 37751u, 9755u },
  { 37755u, 11419u },
  { 37756u, 11527u },
  { 37757u, 18132u },
  { 37794u, 18021u },
  { 37795u, 11114u },
  { 37797u, 11042u },
  { 37798u, 13392u },
  { 37799u, 39146u },
  { 37800u, 11896u },
  { 37806u, 18915u },
  { 37807u, 11623u },
  { 37809u, 11425u },
  { 37814u, 12430u },
  { 37815u, 12973u },
  { 37816u, 18825u },
  { 37817u, 12971u },
  { 37819u, 13024u },
  { 37820u, 6361u },
  { 37823u, 12937u },
  { 37827u, 21892u },
  { 37828u, 35618u },
  { 37829u, 21903u },
  { 37830u, 5884u },
  { 37831u, 21851u },
  { 37832u, 21541u },
  { 37834u, 12547u },
  { 37835u, 6186u },
  { 37836u, 12852u },
  { 37839u, 12674u },
  { 37840u, 17097u },
  { 37842u, 27940u },
  { 37846u, 30832u },
  { 37849u, 13010u },
  { 37850u, 13025u },
  { 37852u, 22642u },
  { 37855u, 14268u },
  { 37857u, 14242u },
  { 37858u, 13310u },
  { 37862u, 17962u },
  { 37868u, 14293u },
  { 37869u, 17543u },
  { 37874u, 6418u },
  { 37881u, 16320u },
  { 37882u, 15514u },
  { 37885u, 35818u },
  { 37886u, 35531u },
  { 37954u, 35292u },
  { 37960u, 16255u },
  { 37963u, 16444u },
  { 37970u, 17178u },
  { 37971u, 17014u },
  { 37976u, 18319u },
  { 37977u, 18213u },
  { 37979u, 19108u },
  { 37980u, 1515u },
  { 37982u, 16120u },
  { 37985u, 18711u },
  { 37986u, 24545u },
  { 37989u, 19167u },
  { 37990u, 35875u },
  { 37991u, 16181u },
  { 37999u, 28138u },
  { 38003u, 19673u },
  { 38004u, 19718u },
  { 38008u, 42438u },
  { 38011u, 35532u },
  { 38012u, 18859u },
  { 38013u, 18830u },
  { 38050u, 19022u },
  { 38053u, 18675u },
  { 38057u, 35555u },
  { 38058u, 6244u },
  { 38060u, 21025u },
  { 38061u, 20967u },
  { 38063u, 12850u },
  { 38067u, 18071u },
  { 38068u, 14209u },
  { 38074u, 19130u },
  { 38075u, 19143u },
  { 38077u, 19094u },
  { 38078u, 25006u },
  { 38080u, 21889u },
  { 38087u, 30529u },
  { 38094u, 16122u },
  { 38098u, 5862u },
  { 38102u, 3404u },
  { 38103u, 18828u },
  { 38104u, 665u },
  { 38105u, 15802u },
  { 38106u, 5998u },
  { 38111u, 468u },
  { 38115u, 9973u },
  { 38117u, 23196u },
  { 38119u, 603u },
  { 38122u, 23494u },
  { 38128u, 23475u },
  { 38129u, 24252u },
  { 38130u, 24230u },
  { 38132u, 18937u },
  { 38142u, 25185u },
  { 38208u, 24924u },
  { 38211u, 24194u },
  { 38214u, 2326u },
  { 38216u, 78u },
  { 38217u, 13775u },
  { 38219u, 25618u },
  { 38221u, 18786u },
  { 38224u, 2092u },
  { 38225u, 23273u },
  { 38226u, 23875u },
  { 38228u, 24078u },
  { 38235u, 18935u },
  { 38236u, 26029u },
  { 38240u, 28967u },
  { 38248u, 26548u },
  { 38250u, 27202u },
  { 38253u, 27217u },
  { 38255u, 28071u },
  { 38257u, 29211u },
  { 38262u, 6305u },
  { 38264u, 6360u },
  { 38269u, 29730u },
  { 38312u, 22147u },
  { 38314u, 30597u },
  { 38315u, 30596u },
  { 38317u, 35801u },
  { 38318u, 35740u },
  { 38319u, 35321u },
  { 38327u, 37960u },
  { 38334u, 6213u },
  { 38338u, 32220u },
  { 38346u, 19465u },
  { 38352u, 8993u },
  { 38356u, 6106u },
  { 38359u, 18735u },
  { 38366u, 35403u },
  { 38370u, 35869u },
  { 38378u, 36148u },
  { 38381u, 18687u },
  { 38385u, 12837u },
  { 38388u, 36454u },
  { 38389u, 36453u },
  { 38392u, 19064u },
  { 38393u, 16366u },
  { 38398u, 37040u },
  { 38470u, 35209u },
  { 38472u, 35631u },
  { 38473u, 25534u },
  { 38479u, 16923u },
  { 38485u, 35781u },
  { 38486u, 19122u },
  { 38488u, 38106u },
  { 38493u, 35664u },
  { 38494u, 19047u },
  { 38495u, 35684u },
  { 38497u, 35397u },
  { 38510u, 35685u },
  { 38524u, 4866u },
  { 38526u, 18872u },
  { 38561u, 5352u },
  { 38563u, 10015u },
  { 38564u, 15800u },
  { 38570u, 10113u },
  { 38571u, 10603u },
  { 38580u, 40493u },
  { 38583u, 41214u },
  { 38586u, 16644u },
  { 38592u, 41203u },
  { 38593u, 39215u },
  { 38597u, 28639u },
  { 38601u, 28068u },
  { 38602u, 28292u },
  { 38603u, 28144u },
  { 38607u, 14295u },
  { 38608u, 24676u },
  { 38610u, 13724u },
  { 38611u, 13888u },
  { 38613u, 18910u },
  { 38618u, 703u },
  { 38625u, 21853u },
  { 38630u, 5975u },
  { 38631u, 12745u },
  { 38632u, 18753u },
  { 38651u, 20375u },
  { 38653u, 6069u },
  { 38654u, 35401u },
  { 38724u, 17544u },
  { 38727u, 35324u },
  { 38730u, 6358u },
  { 38733u, 27840u },
  { 38735u, 17146u },
  { 38736u, 11302u },
  { 38737u, 17345u },
  { 38739u, 15799u },
  { 38740u, 26433u },
  { 38742u, 24923u },
  { 38743u, 24740u },
  { 38744u, 18873u },
  { 38745u, 18827u },
  { 38746u, 35322u },
  { 38751u, 35683u },
  { 38752u, 6303u },
  { 38754u, 19123u },
  { 38759u, 19006u },
  { 38760u, 19092u },
  { 38761u, 6105u },
  { 38762u, 19046u },
  { 38763u, 935u },
  { 38767u, 18710u },
  { 38769u, 18806u },
  { 38773u, 1278u },
  { 38776u, 35350u },
  { 38778u, 35815u },
  { 38779u, 21973u },
  { 38781u, 35458u },
  { 38820u, 1562u },
  { 38825u, 6138u },
  { 38827u, 5826u },
  { 38828u, 19024u },
  { 38834u, 18861u },
  { 38836u, 6335u },
  { 38837u, 6275u },
  { 38838u, 29828u },
  { 38841u, 15707u },
  { 38845u, 35457u },
  { 38846u, 6242u },
  { 38849u, 2740u },
  { 38855u, 5020u },
  { 38860u, 37092u },
  { 38863u, 32335u },
  { 38867u, 16365u },
  { 38868u, 15917u },
  { 38872u, 1013u },
  { 38888u, 5202u },
  { 38890u, 17250u },
  { 38892u, 12259u },
  { 38893u, 4784u },
  { 38894u, 9149u },
  { 38898u, 13541u },
  { 38899u, 31732u },
  { 38900u, 14047u },
  { 38901u, 35459u },
  { 38902u, 14294u },
  { 38904u, 19615u },
  { 38906u, 13997u },
  { 38907u, 27831u },
  { 38976u, 27942u },
  { 38978u, 27778u },
  { 38979u, 28638u },
  { 38981u, 28937u },
  { 38983u, 5946u },
  { 38985u, 27776u },
  { 38986u, 28755u },
  { 38987u, 6107u },
  { 38990u, 6067u },
  { 38993u, 6405u },
  { 38994u, 16892u },
  { 38997u, 5948u },
  { 39002u, 17061u },
  { 39007u, 16121u },
  { 39008u, 30518u },
  { 39009u, 17499u },
  { 39010u, 17098u },
  { 39012u, 16985u },
  { 39013u, 35297u },
  { 39015u, 27944u },
  { 39017u, 17614u },
  { 39018u, 32333u },
  { 39019u, 17341u },
  { 39021u, 16982u },
  { 39022u, 4868u },
  { 39025u, 17385u },
  { 39029u, 19023u },
  { 39075u, 13056u },
  { 39076u, 532u },
  { 39079u, 1561u },
  { 39088u, 35417u },
  { 39094u, 31476u },
  { 39097u, 22262u },
  { 39101u, 31512u },
  { 39135u, 20316u },
  { 39263u, 3279u },
  { 39381u, 31079u },
  { 39629u, 3155u },
  { 39645u, 3598u },
  { 39648u, 3885u },
  { 39655u, 4214u },
  { 39657u, 4219u },
  { 39667u, 4835u },
  { 39751u, 7893u },
  { 39758u, 8828u },
  { 39767u, 10965u },
  { 39781u, 11528u },
  { 39799u, 18874u },
  { 39804u, 838u },
  { 39843u, 30295u },
  { 39844u, 24546u },
  { 39847u, 30206u },
  { 39848u, 8346u },
  { 39852u, 35482u },
  { 39855u, 16443u },
  { 39857u, 17302u },
  { 39861u, 1553u },
  { 39863u, 7848u },
  { 39865u, 15615u },
  { 39875u, 8643u },
  { 39877u, 35662u },
  { 39884u, 3192u },
  { 39888u, 1913u },
  { 39897u, 19111u },
  { 39900u, 21614u },
  { 39901u, 27474u },
  { 39905u, 30258u },
  { 39909u, 21862u },
  { 39910u, 22471u },
  { 39911u, 18751u },
  { 39919u, 35144u },
  { 39920u, 23214u },
  { 39922u, 23558u },
  { 39928u, 31762u },
  { 39931u, 20378u },
  { 40001u, 27639u },
  { 40006u, 18934u },
  { 40008u, 16367u },
  { 40009u, 25874u },
  { 40013u, 10011u },
  { 40015u, 22497u },
  { 40021u, 17697u },
  { 40027u, 27837u },
  { 40031u, 26734u },
  { 40032u, 25617u },
  { 40033u, 26718u },
  { 40038u, 2577u },
  { 40044u, 27130u },
  { 40098u, 9613u },
  { 40105u, 8570u },
  { 40108u, 29414u },
  { 40113u, 3832u },
  { 40118u, 6065u },
  { 40120u, 18986u },
  { 40128u, 40109u },
  { 40129u, 39076u },
  { 40135u, 5642u },
  { 40137u, 14127u },
  { 40139u, 5061u },
  { 40143u, 37288u },
  { 40146u, 28847u },
  { 40147u, 35243u },
  { 40152u, 16762u },
  { 40155u, 32777u },
  { 40157u, 41695u },
  { 40165u, 33135u },
  { 40167u, 27061u },
  { 40168u, 5101u },
  { 40169u, 12847u },
  { 40172u, 35888u },
  { 40176u, 35145u },
  { 40178u, 18824u },
  { 40182u, 19109u },
  { 40183u, 16257u },
  { 40187u, 33012u },
  { 40188u, 33070u },
  { 40189u, 8097u },
  { 40264u, 34474u },
  { 40283u, 37136u },
  { 40292u, 38377u },
  { 40298u, 39274u },
  { 40301u, 39694u },
  { 40306u, 40739u },
  { 40316u, 3228u },
  { 40356u, 19091u },
  { 40363u, 35628u },
  { 40367u, 6133u },
  { 40369u, 35692u },
  { 40370u, 35737u },
  { 40372u, 26287u },
  { 40374u, 30293u },
  { 40375u, 15543u },
  { 40376u, 22069u },
  { 40377u, 22870u },
  { 40379u, 24193u },
  { 40380u, 25176u },
  { 40382u, 3693u },
  { 40385u, 16008u },
  { 40386u, 19614u },
  { 40389u, 6134u },
  { 40390u, 6267u },
  { 40393u, 23626u },
  { 40395u, 21265u },
  { 40402u, 24280u },
  { 40407u, 4074u },
  { 40408u, 3401u },
  { 40409u, 14010u },
  { 40434u, 33506u },
  { 40441u, 3137u },
  { 40444u, 20808u },
  { 40445u, 3702u },
  { 40516u, 4213u },
  { 40532u, 3495u },
  { 40547u, 4289u },
  { 40550u, 18182u },
  { 40553u, 26771u },
  { 40555u, 9972u },
  { 40556u, 32047u },
  { 40557u, 16803u },
  { 40558u, 32115u },
  { 40559u, 28368u },
  { 40562u, 4569u },
  { 40564u, 15612u },
  { 40565u, 42665u },
  { 40566u, 3756u },
  { 40567u, 3833u },
  { 40569u, 7330u },
  { 40571u, 20418u },
  { 40573u, 4075u },
  { 40611u, 11680u },
  { 40614u, 40316u },
  { 40615u, 4076u },
  { 40616u, 3594u },
  { 40619u, 4077u },
  { 40622u, 4487u },
  { 40638u, 19310u },
  { 40643u, 2425u },
  { 40646u, 9317u },
  { 40648u, 40620u },
  { 40651u, 15614u },
  { 40652u, 40752u },
  { 40654u, 20393u },
  { 40655u, 38302u },
  { 40658u, 15798u },
  { 40660u, 26547u },
  { 40661u, 14112u },
  { 40664u, 16119u },
  { 40665u, 15916u },
  { 40675u, 3766u },
  { 40690u, 12506u },
  { 40691u, 17394u },
  { 40694u, 4777u },
  { 40696u, 18787u },
  { 40699u, 28846u },
  { 40771u, 5996u },
  { 40776u, 29028u },
  { 40779u, 27938u },
  { 40780u, 19170u },
  { 40787u, 7633u },
  { 40808u, 18750u },
  { 40874u, 5997u },
  { 40885u, 27939u },
  { 40891u, 1020u },
  { 40895u, 15613u },
  { 40897u, 18713u },
  { 40901u, 3284u },
  { 40949u, 33661u },
  { 40953u, 19063u },
  { 41024u, 35418u },
  { 41029u, 41650u },
  { 41039u, 19131u },
  { 41045u, 6203u },
  { 41046u, 28165u },
  { 41049u, 9499u },
  { 41069u, 24921u },
  { 41083u, 13301u },
  { 41122u, 35778u },
  { 41127u, 7494u },
  { 41131u, 3899u },
  { 41149u, 29830u },
  { 41155u, 26572u },
  { 41157u, 28369u },
  { 41176u, 16401u },
  { 41187u, 35629u },
  { 41193u, 15559u },
  { 41194u, 24279u },
  { 41195u, 30294u },
  { 41197u, 6468u },
  { 41198u, 4862u },
  { 41199u, 39171u },
  { 41200u, 28124u },
  { 41201u, 28845u },
  { 41203u, 25005u },
  { 41204u, 35343u },
  { 41205u, 13943u },
  { 41206u, 238u },
  { 41208u, 20238u },
  { 64064u, 1351u },
  { 64066u, 1503u },
  { 64073u, 18754u },
  { 64074u, 35300u },
  { 64076u, 6619u },
  { 64078u, 15560u },
  { 64082u, 18739u },
  { 64083u, 35242u },
  { 64084u, 672u },
  { 64085u, 27571u },
  { 64086u, 4869u },
  { 64090u, 27945u },
  { 64092u, 13824u },
  { 64093u, 19121u },
  { 64094u, 9491u },
  { 64096u, 894u },
  { 64098u, 896u },
  { 64099u, 839u },
  { 64101u, 1055u },
  { 64110u, 1159u },
  { 64112u, 13236u },
  { 64114u, 3071u },
  { 64115u, 8444u },
  { 64116u, 741u },
  { 64117u, 9520u },
  { 64118u, 1422u },
  { 64119u, 12851u },
  { 64123u, 1459u },
  { 64124u, 15513u },
  { 64167u, 19110u },
  { 64190u, 35550u },
  { 64193u, 16256u },
  { 64194u, 2388u },
  { 64195u, 16364u },
  { 64198u, 3042u },
  { 64200u, 5926u },
  { 64206u, 5864u },
  { 64211u, 34475u },
  { 64214u, 5526u },
  { 64215u, 5651u },
  { 64218u, 35483u },
  { 64223u, 22386u },
  { 64233u, 2959u },
  { 64235u, 16363u },
  { 64236u, 11683u },
  { 64238u, 3191u },
  { 64245u, 27475u },
  { 64254u, 3405u },
  { 64320u, 35260u },
  { 64321u, 9880u },
  { 64329u, 6359u },
  { 64330u, 16442u },
  { 64332u, 17461u },
  { 64334u, 4276u },
  { 64337u, 12938u },
  { 64349u, 35686u },
  { 64351u, 4687u },
  { 64353u, 16805u },
  { 64358u, 27774u },
  { 64362u, 5204u },
  { 64363u, 17251u },
  { 64365u, 19445u },
  { 64375u, 41296u },
  { 64376u, 17016u },
  { 64417u, 5694u },
  { 64420u, 5778u },
  { 64423u, 3406u },
  { 64424u, 27777u },
  { 64425u, 27946u },
  { 64426u, 6108u },
  { 64428u, 6139u },
  { 64429u, 6066u },
  { 64430u, 28070u },
  { 64432u, 6184u },
  { 64433u, 5845u },
  { 64435u, 28229u },
  { 64445u, 28577u },
  { 64448u, 6417u },
  { 64456u, 31246u },
  { 64464u, 1445u },
  { 64469u, 6980u },
  { 64473u, 7333u },
  { 64474u, 27432u },
  { 64481u, 7673u },
  { 64482u, 7735u },
  { 64486u, 7844u },
  { 64491u, 18689u },
  { 64492u, 8265u },
  { 64493u, 8563u },
  { 64502u, 3283u },
  { 64507u, 6001u },
  { 64510u, 33922u },
  { 64583u, 449u },
  { 64587u, 4922u },
  { 64589u, 26760u },
  { 64590u, 9168u },
  { 64592u, 9329u },
  { 64595u, 28270u },
  { 64603u, 8042u },
  { 64604u, 28920u },
  { 64605u, 9832u },
  { 64607u, 670u },
  { 64608u, 35369u },
  { 64616u, 10164u },
  { 64623u, 18831u },
  { 64632u, 28370u },
  { 64638u, 16311u },
  { 64673u, 10335u },
  { 64675u, 35741u },
  { 64676u, 39261u },
  { 64679u, 10624u },
  { 64680u, 10433u },
  { 64685u, 280u },
  { 64687u, 6000u },
  { 64689u, 11789u },
  { 64691u, 18911u },
  { 64696u, 6140u },
  { 64699u, 11830u },
  { 64701u, 16524u },
  { 64702u, 22301u },
  { 64711u, 18984u },
  { 64712u, 18979u },
  { 64716u, 12414u },
  { 64718u, 18752u },
  { 64722u, 6185u },
  { 64726u, 13312u },
  { 64728u, 12791u },
  { 64729u, 12792u },
  { 64731u, 12708u },
  { 64732u, 12709u },
  { 64734u, 3701u },
  { 64736u, 20966u },
  { 64740u, 12849u },
  { 64741u, 34292u },
  { 64742u, 12744u },
  { 64743u, 21267u },
  { 64745u, 10487u },
  { 64748u, 17308u },
  { 64749u, 18977u },
  { 64752u, 14274u },
  { 64764u, 13286u },
  { 64765u, 28064u },
  { 64835u, 35551u },
  { 64838u, 13773u },
  { 64843u, 13884u },
  { 64847u, 35402u },
  { 64852u, 969u },
  { 64857u, 8490u },
  { 64864u, 37276u },
  { 64873u, 15067u },
  { 64874u, 949u },
  { 64878u, 15194u },
  { 64880u, 16124u },
  { 64883u, 9355u },
  { 64885u, 27473u },
  { 64889u, 15804u },
  { 64891u, 15805u },
  { 64892u, 16804u },
  { 64893u, 18700u },
  { 64894u, 18688u },
  { 64929u, 15561u },
  { 64934u, 12793u },
  { 64938u, 27941u },
  { 64939u, 28065u },
  { 64940u, 28139u },
  { 64945u, 18815u },
  { 64947u, 28274u },
  { 64949u, 28532u },
  { 64954u, 35617u },
  { 64956u, 15919u },
  { 64958u, 16258u },
  { 64962u, 12363u },
  { 64966u, 15920u },
  { 64968u, 5271u },
  { 64969u, 16445u },
  { 64979u, 16708u },
  { 64982u, 16725u },
  { 64983u, 16441u },
  { 64984u, 23840u },
  { 64986u, 16703u },
  { 64988u, 16726u },
  { 64989u, 16727u },
  { 64990u, 16704u },
  { 64991u, 25053u },
  { 65004u, 17015u },
  { 65011u, 17253u },
  { 65016u, 17498u },
  { 65017u, 18983u },
  { 65018u, 18978u },
  { 65020u, 35816u },
  { 65097u, 18804u },
  { 65108u, 18467u },
  { 65109u, 34859u },
  { 65111u, 34820u },
  { 65117u, 27182u },
  { 65120u, 16866u },
  { 65121u, 5863u },
  { 65122u, 18980u },
  { 65125u, 18871u },
  { 65126u, 18829u },
  { 65131u, 18982u },
  { 65136u, 10413u },
  { 65138u, 36530u },
  { 65185u, 16735u },
  { 65186u, 19065u },
  { 65187u, 35727u },
  { 65190u, 6302u },
  { 65192u, 6536u },
  { 65196u, 36569u },
  { 65197u, 6731u },
  { 65205u, 20354u },
  { 65222u, 26897u },
  { 65223u, 26894u },
  { 65228u, 28575u },
  { 65230u, 20637u },
  { 65231u, 20861u },
  { 65237u, 21024u },
  { 65239u, 12972u },
  { 65243u, 5825u },
  { 65254u, 21984u },
  { 65258u, 30220u },
  { 65261u, 35627u },
  { 65263u, 9756u },
  { 65268u, 22615u },
  { 65270u, 31545u },
  { 65274u, 28966u },
  { 65277u, 37133u }
}; // idb
wc_map ucs_p2_hkscs_map[1081] =
{
  { 62u, 37749u },
  { 70u, 37750u },
  { 78u, 38216u },
  { 104u, 36550u },
  { 238u, 41206u },
  { 280u, 64685u },
  { 427u, 37490u },
  { 449u, 64583u },
  { 468u, 38111u },
  { 532u, 39076u },
  { 603u, 38119u },
  { 628u, 37067u },
  { 629u, 37499u },
  { 665u, 38104u },
  { 670u, 64607u },
  { 672u, 64084u },
  { 703u, 38618u },
  { 704u, 37497u },
  { 741u, 64116u },
  { 778u, 37493u },
  { 805u, 36347u },
  { 833u, 35401u },
  { 837u, 37599u },
  { 838u, 39804u },
  { 839u, 64099u },
  { 894u, 64096u },
  { 895u, 37485u },
  { 896u, 64098u },
  { 935u, 38763u },
  { 949u, 64874u },
  { 969u, 64852u },
  { 971u, 37491u },
  { 1013u, 38872u },
  { 1020u, 40891u },
  { 1043u, 37698u },
  { 1044u, 37494u },
  { 1055u, 64101u },
  { 1125u, 37484u },
  { 1159u, 64110u },
  { 1169u, 37568u },
  { 1170u, 37567u },
  { 1187u, 37566u },
  { 1276u, 35507u },
  { 1278u, 38773u },
  { 1351u, 64064u },
  { 1422u, 64118u },
  { 1445u, 64464u },
  { 1459u, 64123u },
  { 1488u, 35276u },
  { 1503u, 64066u },
  { 1504u, 37564u },
  { 1515u, 37980u },
  { 1553u, 39861u },
  { 1561u, 39079u },
  { 1562u, 38820u },
  { 1584u, 37117u },
  { 1806u, 37571u },
  { 1913u, 39888u },
  { 2092u, 38224u },
  { 2163u, 37574u },
  { 2326u, 38214u },
  { 2388u, 64194u },
  { 2425u, 40643u },
  { 2577u, 40038u },
  { 2640u, 36947u },
  { 2740u, 38849u },
  { 2959u, 64233u },
  { 2984u, 37474u },
  { 3014u, 37601u },
  { 3042u, 64198u },
  { 3071u, 64114u },
  { 3104u, 37580u },
  { 3137u, 40441u },
  { 3138u, 35395u },
  { 3139u, 35494u },
  { 3155u, 39629u },
  { 3191u, 64238u },
  { 3192u, 39884u },
  { 3228u, 40316u },
  { 3279u, 39263u },
  { 3283u, 64502u },
  { 3284u, 40901u },
  { 3285u, 35417u },
  { 3286u, 35691u },
  { 3398u, 35428u },
  { 3399u, 35570u },
  { 3400u, 35576u },
  { 3401u, 40408u },
  { 3404u, 38102u },
  { 3405u, 64254u },
  { 3406u, 64423u },
  { 3454u, 35651u },
  { 3455u, 35652u },
  { 3495u, 40532u },
  { 3593u, 35530u },
  { 3594u, 40616u },
  { 3597u, 37475u },
  { 3598u, 39645u },
  { 3599u, 35685u },
  { 3600u, 35695u },
  { 3601u, 35710u },
  { 3606u, 36675u },
  { 3613u, 37584u },
  { 3693u, 40382u },
  { 3701u, 64734u },
  { 3702u, 40445u },
  { 3703u, 35686u },
  { 3704u, 35696u },
  { 3705u, 35701u },
  { 3706u, 35556u },
  { 3707u, 35748u },
  { 3754u, 35567u },
  { 3755u, 35574u },
  { 3756u, 40566u },
  { 3766u, 40675u },
  { 3832u, 40113u },
  { 3833u, 40567u },
  { 3834u, 35684u },
  { 3835u, 35687u },
  { 3885u, 39648u },
  { 3886u, 35658u },
  { 3888u, 35569u },
  { 3889u, 35543u },
  { 3899u, 41131u },
  { 3981u, 35566u },
  { 4013u, 35582u },
  { 4020u, 35416u },
  { 4021u, 35747u },
  { 4022u, 35751u },
  { 4074u, 40407u },
  { 4075u, 40573u },
  { 4076u, 40615u },
  { 4077u, 40619u },
  { 4125u, 35705u },
  { 4126u, 35706u },
  { 4207u, 35454u },
  { 4213u, 40516u },
  { 4214u, 39655u },
  { 4215u, 35452u },
  { 4216u, 35697u },
  { 4219u, 39657u },
  { 4276u, 64334u },
  { 4288u, 35577u },
  { 4289u, 40547u },
  { 4295u, 35657u },
  { 4296u, 35534u },
  { 4297u, 35694u },
  { 4340u, 35418u },
  { 4341u, 35707u },
  { 4342u, 35708u },
  { 4413u, 35578u },
  { 4424u, 35698u },
  { 4480u, 35752u },
  { 4487u, 40622u },
  { 4569u, 40562u },
  { 4687u, 64351u },
  { 4732u, 37050u },
  { 4777u, 40694u },
  { 4784u, 38893u },
  { 4835u, 39667u },
  { 4862u, 41198u },
  { 4866u, 38524u },
  { 4867u, 37701u },
  { 4868u, 39022u },
  { 4869u, 64086u },
  { 4922u, 64587u },
  { 5020u, 38855u },
  { 5061u, 40139u },
  { 5062u, 37440u },
  { 5101u, 40168u },
  { 5118u, 37373u },
  { 5202u, 38888u },
  { 5204u, 64362u },
  { 5205u, 35700u },
  { 5271u, 64968u },
  { 5302u, 37441u },
  { 5352u, 38561u },
  { 5373u, 36595u },
  { 5526u, 64214u },
  { 5642u, 40135u },
  { 5651u, 64215u },
  { 5694u, 64417u },
  { 5729u, 36549u },
  { 5778u, 64420u },
  { 5824u, 37370u },
  { 5825u, 65243u },
  { 5826u, 38827u },
  { 5843u, 37191u },
  { 5845u, 64433u },
  { 5862u, 38098u },
  { 5863u, 65121u },
  { 5864u, 64206u },
  { 5882u, 37613u },
  { 5883u, 37363u },
  { 5884u, 37830u },
  { 5886u, 37722u },
  { 5904u, 37615u },
  { 5926u, 64200u },
  { 5946u, 38983u },
  { 5947u, 37734u },
  { 5948u, 38997u },
  { 5975u, 38630u },
  { 5996u, 40771u },
  { 5997u, 40874u },
  { 5998u, 38106u },
  { 5999u, 37614u },
  { 6000u, 64687u },
  { 6001u, 64507u },
  { 6003u, 36601u },
  { 6004u, 37366u },
  { 6065u, 40118u },
  { 6066u, 64429u },
  { 6067u, 38990u },
  { 6068u, 36676u },
  { 6069u, 38653u },
  { 6105u, 38761u },
  { 6106u, 38356u },
  { 6107u, 38987u },
  { 6108u, 64426u },
  { 6133u, 40367u },
  { 6134u, 40389u },
  { 6136u, 37361u },
  { 6137u, 36529u },
  { 6138u, 38825u },
  { 6139u, 64428u },
  { 6140u, 64696u },
  { 6184u, 64432u },
  { 6185u, 64722u },
  { 6186u, 37835u },
  { 6202u, 35756u },
  { 6203u, 41045u },
  { 6213u, 38334u },
  { 6238u, 36585u },
  { 6241u, 37624u },
  { 6242u, 38846u },
  { 6243u, 37228u },
  { 6244u, 38058u },
  { 6267u, 40390u },
  { 6275u, 38837u },
  { 6276u, 37560u },
  { 6277u, 37359u },
  { 6302u, 65190u },
  { 6303u, 38752u },
  { 6304u, 37720u },
  { 6305u, 38262u },
  { 6306u, 36780u },
  { 6334u, 37356u },
  { 6335u, 38836u },
  { 6358u, 38730u },
  { 6359u, 64329u },
  { 6360u, 38264u },
  { 6361u, 37820u },
  { 6394u, 37334u },
  { 6403u, 37717u },
  { 6404u, 37718u },
  { 6405u, 38993u },
  { 6416u, 36856u },
  { 6417u, 64448u },
  { 6418u, 37874u },
  { 6421u, 37072u },
  { 6439u, 37731u },
  { 6459u, 37285u },
  { 6468u, 41197u },
  { 6524u, 37713u },
  { 6536u, 65192u },
  { 6550u, 37712u },
  { 6619u, 64076u },
  { 6643u, 37623u },
  { 6731u, 65197u },
  { 6980u, 64469u },
  { 7330u, 40569u },
  { 7333u, 64473u },
  { 7494u, 41127u },
  { 7610u, 37726u },
  { 7626u, 35275u },
  { 7633u, 40787u },
  { 7673u, 64481u },
  { 7735u, 64482u },
  { 7817u, 36980u },
  { 7844u, 64486u },
  { 7848u, 39863u },
  { 7893u, 39751u },
  { 8042u, 64603u },
  { 8097u, 40189u },
  { 8265u, 64492u },
  { 8346u, 39848u },
  { 8391u, 35541u },
  { 8444u, 64115u },
  { 8490u, 64857u },
  { 8563u, 64493u },
  { 8570u, 40105u },
  { 8609u, 35496u },
  { 8643u, 39875u },
  { 8828u, 39758u },
  { 8993u, 38352u },
  { 8997u, 36959u },
  { 9149u, 38894u },
  { 9168u, 64590u },
  { 9317u, 40646u },
  { 9329u, 64592u },
  { 9355u, 64883u },
  { 9491u, 64094u },
  { 9499u, 41049u },
  { 9520u, 64117u },
  { 9613u, 40098u },
  { 9647u, 37744u },
  { 9662u, 37745u },
  { 9755u, 37751u },
  { 9756u, 65263u },
  { 9771u, 37741u },
  { 9832u, 64605u },
  { 9878u, 35580u },
  { 9880u, 64321u },
  { 9972u, 40555u },
  { 9973u, 38115u },
  { 9974u, 36578u },
  { 10011u, 40013u },
  { 10015u, 38563u },
  { 10101u, 35523u },
  { 10113u, 38570u },
  { 10164u, 64616u },
  { 10165u, 35693u },
  { 10243u, 35561u },
  { 10335u, 64673u },
  { 10336u, 37740u },
  { 10413u, 65136u },
  { 10433u, 64680u },
  { 10487u, 64745u },
  { 10553u, 35562u },
  { 10603u, 38571u },
  { 10624u, 64679u },
  { 10959u, 35531u },
  { 10965u, 39767u },
  { 11042u, 37797u },
  { 11114u, 37795u },
  { 11214u, 35650u },
  { 11302u, 38736u },
  { 11303u, 36787u },
  { 11345u, 35653u },
  { 11349u, 35654u },
  { 11419u, 37755u },
  { 11425u, 37809u },
  { 11462u, 35399u },
  { 11527u, 37756u },
  { 11528u, 39781u },
  { 11623u, 37807u },
  { 11680u, 40611u },
  { 11683u, 64236u },
  { 11684u, 35703u },
  { 11789u, 64689u },
  { 11830u, 64699u },
  { 11896u, 37800u },
  { 12259u, 38892u },
  { 12363u, 64962u },
  { 12413u, 37223u },
  { 12414u, 64716u },
  { 12430u, 37814u },
  { 12471u, 37092u },
  { 12476u, 37093u },
  { 12506u, 40690u },
  { 12547u, 37834u },
  { 12605u, 35772u },
  { 12674u, 37839u },
  { 12708u, 64731u },
  { 12709u, 64732u },
  { 12744u, 64742u },
  { 12745u, 38631u },
  { 12791u, 64728u },
  { 12792u, 64729u },
  { 12793u, 64934u },
  { 12837u, 38385u },
  { 12847u, 40169u },
  { 12849u, 64740u },
  { 12850u, 38063u },
  { 12851u, 64119u },
  { 12852u, 37836u },
  { 12898u, 36954u },
  { 12937u, 37823u },
  { 12938u, 64337u },
  { 12971u, 37817u },
  { 12972u, 65239u },
  { 12973u, 37815u },
  { 13010u, 37849u },
  { 13024u, 37819u },
  { 13025u, 37850u },
  { 13056u, 39075u },
  { 13066u, 37073u },
  { 13236u, 64112u },
  { 13286u, 64764u },
  { 13300u, 35648u },
  { 13301u, 41083u },
  { 13310u, 37858u },
  { 13312u, 64726u },
  { 13392u, 37798u },
  { 13426u, 37727u },
  { 13541u, 38898u },
  { 13616u, 36600u },
  { 13658u, 36679u },
  { 13717u, 37556u },
  { 13721u, 37357u },
  { 13724u, 38610u },
  { 13773u, 64838u },
  { 13774u, 36687u },
  { 13775u, 38217u },
  { 13824u, 64092u },
  { 13884u, 64843u },
  { 13888u, 38611u },
  { 13943u, 41205u },
  { 13990u, 37443u },
  { 13997u, 38906u },
  { 14010u, 40409u },
  { 14047u, 38900u },
  { 14062u, 37453u },
  { 14112u, 40661u },
  { 14127u, 40137u },
  { 14143u, 37464u },
  { 14182u, 36552u },
  { 14209u, 38068u },
  { 14242u, 37857u },
  { 14268u, 37855u },
  { 14274u, 64752u },
  { 14293u, 37868u },
  { 14294u, 38902u },
  { 14295u, 38607u },
  { 15067u, 64873u },
  { 15086u, 37714u },
  { 15194u, 64878u },
  { 15513u, 64124u },
  { 15514u, 37882u },
  { 15515u, 36988u },
  { 15543u, 40375u },
  { 15559u, 41193u },
  { 15560u, 64078u },
  { 15561u, 64929u },
  { 15612u, 40564u },
  { 15613u, 40895u },
  { 15614u, 40651u },
  { 15615u, 39865u },
  { 15707u, 38841u },
  { 15798u, 40658u },
  { 15799u, 38739u },
  { 15800u, 38564u },
  { 15801u, 36798u },
  { 15802u, 38105u },
  { 15803u, 36952u },
  { 15804u, 64889u },
  { 15805u, 64891u },
  { 15864u, 36602u },
  { 15916u, 40665u },
  { 15917u, 38868u },
  { 15918u, 37051u },
  { 15919u, 64956u },
  { 15920u, 64966u },
  { 15921u, 37448u },
  { 16008u, 40385u },
  { 16009u, 37561u },
  { 16010u, 37542u },
  { 16011u, 36683u },
  { 16063u, 37558u },
  { 16119u, 40664u },
  { 16120u, 37982u },
  { 16121u, 39007u },
  { 16122u, 38094u },
  { 16123u, 37450u },
  { 16124u, 64880u },
  { 16181u, 37991u },
  { 16193u, 36332u },
  { 16255u, 37960u },
  { 16256u, 64193u },
  { 16257u, 40183u },
  { 16258u, 64958u },
  { 16311u, 64638u },
  { 16320u, 37881u },
  { 16363u, 64235u },
  { 16364u, 64195u },
  { 16365u, 38867u },
  { 16366u, 38393u },
  { 16367u, 40008u },
  { 16368u, 36458u },
  { 16401u, 41176u },
  { 16441u, 64983u },
  { 16442u, 64330u },
  { 16443u, 39855u },
  { 16444u, 37963u },
  { 16445u, 64969u },
  { 16471u, 36524u },
  { 16523u, 37466u },
  { 16524u, 64701u },
  { 16525u, 37593u },
  { 16585u, 37597u },
  { 16644u, 38586u },
  { 16703u, 64986u },
  { 16704u, 64990u },
  { 16708u, 64979u },
  { 16725u, 64982u },
  { 16726u, 64988u },
  { 16727u, 64989u },
  { 16732u, 37118u },
  { 16735u, 65185u },
  { 16762u, 40152u },
  { 16803u, 40557u },
  { 16804u, 64892u },
  { 16805u, 64353u },
  { 16866u, 65120u },
  { 16892u, 38994u },
  { 16923u, 38479u },
  { 16971u, 37230u },
  { 16982u, 39021u },
  { 16985u, 39012u },
  { 17014u, 37971u },
  { 17015u, 65004u },
  { 17016u, 64376u },
  { 17061u, 39002u },
  { 17097u, 37840u },
  { 17098u, 39010u },
  { 17146u, 38735u },
  { 17178u, 37970u },
  { 17224u, 37330u },
  { 17250u, 38890u },
  { 17251u, 64363u },
  { 17252u, 37297u },
  { 17253u, 65011u },
  { 17292u, 37579u },
  { 17302u, 39857u },
  { 17308u, 64748u },
  { 17341u, 39019u },
  { 17345u, 38737u },
  { 17385u, 39025u },
  { 17394u, 40691u },
  { 17400u, 37352u },
  { 17461u, 64332u },
  { 17462u, 37482u },
  { 17498u, 65016u },
  { 17499u, 39009u },
  { 17543u, 37869u },
  { 17544u, 38724u },
  { 17593u, 37345u },
  { 17614u, 39017u },
  { 17619u, 35426u },
  { 17697u, 40021u },
  { 17784u, 36471u },
  { 17962u, 37862u },
  { 18021u, 37794u },
  { 18071u, 38067u },
  { 18132u, 37757u },
  { 18182u, 40550u },
  { 18213u, 37977u },
  { 18319u, 37976u },
  { 18467u, 65108u },
  { 18675u, 38053u },
  { 18687u, 38381u },
  { 18688u, 64894u },
  { 18689u, 64491u },
  { 18700u, 64893u },
  { 18710u, 38767u },
  { 18711u, 37985u },
  { 18713u, 40897u },
  { 18735u, 38359u },
  { 18739u, 64082u },
  { 18750u, 40808u },
  { 18751u, 39911u },
  { 18752u, 64718u },
  { 18753u, 38632u },
  { 18754u, 64073u },
  { 18786u, 38221u },
  { 18787u, 40696u },
  { 18804u, 65097u },
  { 18805u, 37326u },
  { 18806u, 38769u },
  { 18815u, 64945u },
  { 18824u, 40178u },
  { 18825u, 37816u },
  { 18826u, 36931u },
  { 18827u, 38745u },
  { 18828u, 38103u },
  { 18829u, 65126u },
  { 18830u, 38013u },
  { 18831u, 64623u },
  { 18855u, 36599u },
  { 18859u, 38012u },
  { 18860u, 37581u },
  { 18861u, 38834u },
  { 18871u, 65125u },
  { 18872u, 38526u },
  { 18873u, 38744u },
  { 18874u, 39799u },
  { 18875u, 37327u },
  { 18910u, 38613u },
  { 18911u, 64691u },
  { 18915u, 37806u },
  { 18934u, 40006u },
  { 18935u, 38235u },
  { 18936u, 37329u },
  { 18937u, 38132u },
  { 18977u, 64749u },
  { 18978u, 65018u },
  { 18979u, 64712u },
  { 18980u, 65122u },
  { 18981u, 37372u },
  { 18982u, 65131u },
  { 18983u, 65017u },
  { 18984u, 64711u },
  { 18985u, 37198u },
  { 18986u, 40120u },
  { 19006u, 38759u },
  { 19022u, 38050u },
  { 19023u, 39029u },
  { 19024u, 38828u },
  { 19025u, 37331u },
  { 19045u, 36587u },
  { 19046u, 38762u },
  { 19047u, 38494u },
  { 19063u, 40953u },
  { 19064u, 38392u },
  { 19065u, 65186u },
  { 19066u, 36838u },
  { 19091u, 40356u },
  { 19092u, 38760u },
  { 19093u, 36588u },
  { 19094u, 38077u },
  { 19108u, 37979u },
  { 19109u, 40182u },
  { 19110u, 64167u },
  { 19111u, 39897u },
  { 19121u, 64093u },
  { 19122u, 38486u },
  { 19123u, 38754u },
  { 19130u, 38074u },
  { 19131u, 41039u },
  { 19132u, 37592u },
  { 19143u, 38075u },
  { 19153u, 37071u },
  { 19167u, 37989u },
  { 19170u, 40780u },
  { 19310u, 40638u },
  { 19445u, 64365u },
  { 19465u, 38346u },
  { 19614u, 40386u },
  { 19615u, 38904u },
  { 19673u, 38003u },
  { 19718u, 38004u },
  { 19896u, 35403u },
  { 19946u, 35413u },
  { 19947u, 35689u },
  { 20048u, 35702u },
  { 20238u, 41208u },
  { 20316u, 39135u },
  { 20354u, 65205u },
  { 20375u, 38651u },
  { 20378u, 39931u },
  { 20393u, 40654u },
  { 20418u, 40571u },
  { 20637u, 65230u },
  { 20808u, 40444u },
  { 20861u, 65231u },
  { 20862u, 35749u },
  { 20963u, 35564u },
  { 20966u, 64736u },
  { 20967u, 38061u },
  { 21024u, 65237u },
  { 21025u, 38060u },
  { 21191u, 35439u },
  { 21208u, 35753u },
  { 21265u, 40395u },
  { 21267u, 64743u },
  { 21541u, 37832u },
  { 21551u, 37360u },
  { 21552u, 36832u },
  { 21612u, 37101u },
  { 21614u, 39900u },
  { 21851u, 37831u },
  { 21852u, 37449u },
  { 21853u, 38625u },
  { 21861u, 36833u },
  { 21862u, 39909u },
  { 21889u, 38080u },
  { 21892u, 37827u },
  { 21903u, 37829u },
  { 21945u, 36985u },
  { 21973u, 38779u },
  { 21979u, 36990u },
  { 21984u, 65254u },
  { 22069u, 40376u },
  { 22097u, 37488u },
  { 22147u, 38312u },
  { 22262u, 39097u },
  { 22278u, 37184u },
  { 22301u, 64702u },
  { 22309u, 37207u },
  { 22386u, 64223u },
  { 22471u, 39910u },
  { 22496u, 36420u },
  { 22497u, 40015u },
  { 22615u, 65268u },
  { 22642u, 37852u },
  { 22753u, 36426u },
  { 22870u, 40377u },
  { 22956u, 36430u },
  { 23196u, 38117u },
  { 23214u, 39920u },
  { 23273u, 38225u },
  { 23412u, 35771u },
  { 23475u, 38128u },
  { 23476u, 36452u },
  { 23494u, 38122u },
  { 23553u, 36443u },
  { 23558u, 39922u },
  { 23626u, 40393u },
  { 23653u, 36460u },
  { 23744u, 36725u },
  { 23745u, 36465u },
  { 23806u, 36448u },
  { 23840u, 64984u },
  { 23875u, 38226u },
  { 24078u, 38228u },
  { 24193u, 40379u },
  { 24194u, 38211u },
  { 24195u, 37630u },
  { 24230u, 38130u },
  { 24252u, 38129u },
  { 24279u, 41194u },
  { 24280u, 40402u },
  { 24395u, 37368u },
  { 24545u, 37986u },
  { 24546u, 39844u },
  { 24617u, 36525u },
  { 24676u, 38608u },
  { 24740u, 38743u },
  { 24741u, 35447u },
  { 24865u, 36533u },
  { 24921u, 41069u },
  { 24922u, 36534u },
  { 24923u, 38742u },
  { 24924u, 38208u },
  { 25005u, 41203u },
  { 25006u, 38078u },
  { 25053u, 64991u },
  { 25176u, 40380u },
  { 25185u, 38142u },
  { 25296u, 36544u },
  { 25425u, 36547u },
  { 25534u, 38473u },
  { 25616u, 37068u },
  { 25617u, 40032u },
  { 25618u, 38219u },
  { 25737u, 36556u },
  { 25752u, 36580u },
  { 25874u, 40009u },
  { 25970u, 35678u },
  { 26029u, 38236u },
  { 26150u, 36569u },
  { 26287u, 40372u },
  { 26289u, 37471u },
  { 26344u, 36571u },
  { 26433u, 38740u },
  { 26547u, 40660u },
  { 26548u, 38248u },
  { 26572u, 41155u },
  { 26718u, 40033u },
  { 26734u, 40031u },
  { 26760u, 64589u },
  { 26771u, 40553u },
  { 26894u, 65223u },
  { 26897u, 65222u },
  { 27048u, 37221u },
  { 27061u, 40167u },
  { 27122u, 35412u },
  { 27130u, 40044u },
  { 27182u, 65117u },
  { 27202u, 38250u },
  { 27217u, 38253u },
  { 27218u, 36592u },
  { 27402u, 36598u },
  { 27432u, 64474u },
  { 27472u, 35660u },
  { 27473u, 64885u },
  { 27474u, 39901u },
  { 27475u, 64245u },
  { 27542u, 36714u },
  { 27543u, 36686u },
  { 27571u, 64085u },
  { 27639u, 40001u },
  { 27681u, 37468u },
  { 27774u, 64358u },
  { 27775u, 36453u },
  { 27776u, 38985u },
  { 27777u, 64424u },
  { 27778u, 38978u },
  { 27831u, 38907u },
  { 27832u, 37066u },
  { 27837u, 40027u },
  { 27840u, 38733u },
  { 27938u, 40779u },
  { 27939u, 40885u },
  { 27940u, 37842u },
  { 27941u, 64938u },
  { 27942u, 38976u },
  { 27943u, 37190u },
  { 27944u, 39015u },
  { 27945u, 64090u },
  { 27946u, 64425u },
  { 28064u, 64765u },
  { 28065u, 64939u },
  { 28066u, 37309u },
  { 28067u, 36684u },
  { 28068u, 38601u },
  { 28069u, 36693u },
  { 28070u, 64430u },
  { 28071u, 38255u },
  { 28124u, 41200u },
  { 28138u, 37999u },
  { 28139u, 64940u },
  { 28144u, 38603u },
  { 28165u, 41046u },
  { 28226u, 36702u },
  { 28227u, 36716u },
  { 28228u, 36515u },
  { 28229u, 64435u },
  { 28270u, 64595u },
  { 28274u, 64947u },
  { 28279u, 36715u },
  { 28292u, 38602u },
  { 28368u, 40559u },
  { 28369u, 41157u },
  { 28370u, 64632u },
  { 28371u, 36418u },
  { 28372u, 36698u },
  { 28373u, 37058u },
  { 28374u, 36517u },
  { 28375u, 36961u },
  { 28454u, 37455u },
  { 28531u, 37747u },
  { 28532u, 64949u },
  { 28575u, 65228u },
  { 28577u, 64445u },
  { 28638u, 38979u },
  { 28639u, 38597u },
  { 28686u, 35260u },
  { 28754u, 37451u },
  { 28755u, 38986u },
  { 28845u, 41201u },
  { 28846u, 40699u },
  { 28847u, 40146u },
  { 28877u, 36775u },
  { 28920u, 64604u },
  { 28937u, 38981u },
  { 28940u, 36934u },
  { 28966u, 65274u },
  { 28967u, 38240u },
  { 29028u, 40776u },
  { 29029u, 37447u },
  { 29045u, 37115u },
  { 29211u, 38257u },
  { 29414u, 40108u },
  { 29594u, 36782u },
  { 29730u, 38269u },
  { 29828u, 38838u },
  { 29830u, 41149u },
  { 30176u, 36797u },
  { 30180u, 36799u },
  { 30205u, 37737u },
  { 30206u, 39847u },
  { 30220u, 65258u },
  { 30258u, 39905u },
  { 30265u, 35649u },
  { 30293u, 40374u },
  { 30294u, 41195u },
  { 30295u, 39843u },
  { 30356u, 35745u },
  { 30479u, 36808u },
  { 30517u, 35148u },
  { 30518u, 39008u },
  { 30529u, 38087u },
  { 30558u, 35672u },
  { 30596u, 38315u },
  { 30597u, 38314u },
  { 30832u, 37846u },
  { 31012u, 36817u },
  { 31079u, 39381u },
  { 31246u, 64456u },
  { 31321u, 36823u },
  { 31421u, 36818u },
  { 31422u, 36964u },
  { 31476u, 39094u },
  { 31512u, 39101u },
  { 31544u, 36828u },
  { 31545u, 65270u },
  { 31546u, 36825u },
  { 31732u, 38899u },
  { 31762u, 39928u },
  { 32047u, 40556u },
  { 32083u, 36850u },
  { 32084u, 36846u },
  { 32115u, 40558u },
  { 32143u, 36847u },
  { 32152u, 36852u },
  { 32189u, 36853u },
  { 32220u, 38338u },
  { 32333u, 39018u },
  { 32335u, 38863u },
  { 32770u, 36929u },
  { 32777u, 40155u },
  { 32957u, 35682u },
  { 32958u, 35406u },
  { 33001u, 35430u },
  { 33012u, 40187u },
  { 33070u, 40188u },
  { 33135u, 40165u },
  { 33287u, 35699u },
  { 33366u, 35425u },
  { 33485u, 35746u },
  { 33506u, 40434u },
  { 33594u, 36554u },
  { 33637u, 36942u },
  { 33661u, 40949u },
  { 33810u, 36943u },
  { 33922u, 64510u },
  { 34108u, 36963u },
  { 34109u, 36951u },
  { 34156u, 36966u },
  { 34292u, 64741u },
  { 34304u, 37218u },
  { 34315u, 36967u },
  { 34341u, 36769u },
  { 34363u, 36770u },
  { 34474u, 40264u },
  { 34475u, 64211u },
  { 34520u, 37049u },
  { 34534u, 36971u },
  { 34820u, 65111u },
  { 34859u, 65109u },
  { 35123u, 36979u },
  { 35144u, 39919u },
  { 35145u, 40176u },
  { 35180u, 37344u },
  { 35198u, 37336u },
  { 35209u, 38470u },
  { 35240u, 37728u },
  { 35242u, 64083u },
  { 35243u, 40147u },
  { 35260u, 64320u },
  { 35264u, 36322u },
  { 35292u, 37954u },
  { 35294u, 36950u },
  { 35297u, 39013u },
  { 35300u, 64074u },
  { 35321u, 38319u },
  { 35322u, 38746u },
  { 35323u, 37705u },
  { 35324u, 38727u },
  { 35343u, 41204u },
  { 35350u, 38776u },
  { 35365u, 36815u },
  { 35369u, 64608u },
  { 35396u, 37340u },
  { 35397u, 38497u },
  { 35398u, 37612u },
  { 35399u, 37725u },
  { 35400u, 36574u },
  { 35401u, 38654u },
  { 35402u, 64847u },
  { 35403u, 38366u },
  { 35417u, 39088u },
  { 35418u, 41024u },
  { 35457u, 38845u },
  { 35458u, 38781u },
  { 35459u, 38901u },
  { 35482u, 39852u },
  { 35483u, 64218u },
  { 35484u, 37570u },
  { 35526u, 36987u },
  { 35531u, 37886u },
  { 35532u, 38011u },
  { 35550u, 64190u },
  { 35551u, 64835u },
  { 35552u, 37062u },
  { 35553u, 37028u },
  { 35554u, 37032u },
  { 35555u, 38057u },
  { 35557u, 37033u },
  { 35596u, 36989u },
  { 35617u, 64954u },
  { 35618u, 37828u },
  { 35627u, 65261u },
  { 35628u, 40363u },
  { 35629u, 41187u },
  { 35631u, 38472u },
  { 35660u, 35497u },
  { 35662u, 39877u },
  { 35664u, 38493u },
  { 35683u, 38751u },
  { 35684u, 38495u },
  { 35685u, 38510u },
  { 35686u, 64349u },
  { 35692u, 40369u },
  { 35727u, 65187u },
  { 35737u, 40370u },
  { 35740u, 38318u },
  { 35741u, 64675u },
  { 35778u, 41122u },
  { 35781u, 38485u },
  { 35799u, 37697u },
  { 35801u, 38317u },
  { 35802u, 37333u },
  { 35815u, 38778u },
  { 35816u, 65020u },
  { 35817u, 36423u },
  { 35818u, 37885u },
  { 35819u, 37029u },
  { 35820u, 37036u },
  { 35839u, 37038u },
  { 35869u, 38370u },
  { 35875u, 37990u },
  { 35883u, 37304u },
  { 35888u, 40172u },
  { 35897u, 37037u },
  { 36045u, 35555u },
  { 36148u, 38378u },
  { 36406u, 37337u },
  { 36453u, 38389u },
  { 36454u, 38388u },
  { 36530u, 65138u },
  { 36531u, 37498u },
  { 36569u, 65196u },
  { 37003u, 37317u },
  { 37039u, 37069u },
  { 37040u, 38398u },
  { 37041u, 37209u },
  { 37092u, 38860u },
  { 37093u, 37070u },
  { 37133u, 65277u },
  { 37136u, 40283u },
  { 37276u, 64864u },
  { 37288u, 40143u },
  { 37355u, 37088u },
  { 37917u, 37107u },
  { 37939u, 37104u },
  { 37960u, 38327u },
  { 38105u, 36427u },
  { 38106u, 38488u },
  { 38302u, 40655u },
  { 38377u, 40292u },
  { 38999u, 37200u },
  { 39076u, 40129u },
  { 39146u, 37799u },
  { 39171u, 41199u },
  { 39173u, 37201u },
  { 39215u, 38593u },
  { 39261u, 64676u },
  { 39274u, 40298u },
  { 39325u, 37454u },
  { 39685u, 37213u },
  { 39694u, 40301u },
  { 39893u, 37210u },
  { 40109u, 40128u },
  { 40254u, 37226u },
  { 40316u, 40614u },
  { 40493u, 38580u },
  { 40552u, 37234u },
  { 40620u, 40648u },
  { 40643u, 35669u },
  { 40739u, 40306u },
  { 40752u, 40652u },
  { 40887u, 37236u },
  { 41185u, 37239u },
  { 41203u, 38592u },
  { 41208u, 36785u },
  { 41214u, 38583u },
  { 41251u, 37240u },
  { 41296u, 64375u },
  { 41362u, 37237u },
  { 41363u, 37283u },
  { 41439u, 37241u },
  { 41504u, 37284u },
  { 41523u, 37286u },
  { 41631u, 36946u },
  { 41650u, 41029u },
  { 41695u, 40157u },
  { 41897u, 35136u },
  { 42438u, 38008u },
  { 42665u, 40565u }
}; // idb
wc_map johab2_ucs_map[51] =
{
  { 33860u, 12595u },
  { 33862u, 12597u },
  { 33863u, 12598u },
  { 33866u, 12602u },
  { 33867u, 12603u },
  { 33868u, 12604u },
  { 33869u, 12605u },
  { 33870u, 12606u },
  { 33871u, 12607u },
  { 33872u, 12608u },
  { 33876u, 12612u },
  { 33889u, 12623u },
  { 33921u, 12624u },
  { 33953u, 12625u },
  { 33985u, 12626u },
  { 34017u, 12627u },
  { 34113u, 12628u },
  { 34145u, 12629u },
  { 34177u, 12630u },
  { 34209u, 12631u },
  { 34241u, 12632u },
  { 34273u, 12633u },
  { 34369u, 12634u },
  { 34401u, 12635u },
  { 34433u, 12636u },
  { 34465u, 12637u },
  { 34497u, 12638u },
  { 34529u, 12639u },
  { 34625u, 12640u },
  { 34657u, 12641u },
  { 34689u, 12642u },
  { 34721u, 12643u },
  { 34881u, 12593u },
  { 35905u, 12594u },
  { 36929u, 12596u },
  { 37953u, 12599u },
  { 38977u, 12600u },
  { 40001u, 12601u },
  { 41025u, 12609u },
  { 42049u, 12610u },
  { 43073u, 12611u },
  { 44097u, 12613u },
  { 45121u, 12614u },
  { 46145u, 12615u },
  { 47169u, 12616u },
  { 48193u, 12617u },
  { 49217u, 12618u },
  { 50241u, 12619u },
  { 51265u, 12620u },
  { 52289u, 12621u },
  { 53313u, 12622u }
}; // idb
wc_uint16 *cs94_ucs_map[21] =
{
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  &jisx0201k_ucs_map,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL
}; // idb
wc_uint16 *cs96_ucs_map[39] =
{
  NULL,
  &iso88591_ucs_map,
  &iso88592_ucs_map,
  &iso88593_ucs_map,
  &iso88594_ucs_map,
  NULL,
  &iso88597_ucs_map,
  &iso88596_ucs_map,
  &iso88598_ucs_map,
  NULL,
  NULL,
  NULL,
  &iso88595_ucs_map,
  &iso88599_ucs_map,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  &iso885911_ucs_map,
  NULL,
  &iso885910_ucs_map,
  NULL,
  NULL,
  &iso885913_ucs_map,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  &iso885914_ucs_map,
  NULL,
  NULL,
  &iso885915_ucs_map,
  NULL,
  NULL,
  NULL,
  &iso885916_ucs_map
}; // idb
wc_uint16 *pcs_ucs_map[40] =
{
  &cp437_ucs_map,
  &cp737_ucs_map,
  &cp775_ucs_map,
  &cp850_ucs_map,
  &cp852_ucs_map,
  &cp855_ucs_map,
  &cp856_ucs_map,
  &cp857_ucs_map,
  &cp860_ucs_map,
  &cp861_ucs_map,
  &cp862_ucs_map,
  &cp863_ucs_map,
  &cp864_ucs_map,
  &cp865_ucs_map,
  &cp866_ucs_map,
  &cp869_ucs_map,
  &cp874_ucs_map,
  &cp1006_ucs_map,
  &cp1250_ucs_map,
  &cp1251_ucs_map,
  &cp1252_ucs_map,
  &cp1253_ucs_map,
  &cp1254_ucs_map,
  &cp1255_ucs_map,
  &cp1256_ucs_map,
  &cp1257_ucs_map,
  &cp1258_ucs_map,
  NULL,
  &tcvn57121_ucs_map,
  &tcvn57122_ucs_map,
  NULL,
  &viscii111_ucs_map,
  &viscii112_ucs_map,
  &vps1_ucs_map,
  &vps2_ucs_map,
  &koi8r_ucs_map,
  &koi8u_ucs_map,
  &nextstep_ucs_map,
  NULL,
  NULL
}; // idb
wc_uint16 *cs94w_ucs_map[17] =
{
  &jisx0208x02131_ucs_map,
  &gb2312_ucs_map,
  &jisx0208x02131_ucs_map,
  &ksx1001_ucs_map,
  &jisx0212x02132_ucs_map,
  NULL,
  NULL,
  &cns116431_ucs_map,
  &cns116432_ucs_map,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  &jisx0208x02131_ucs_map,
  &jisx0212x02132_ucs_map
}; // idb
wc_uint16 *pcsw_ucs_map[33] =
{
  &big5_ucs_map,
  &big5_ucs_map,
  &big5_ucs_map,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  &gb12345_ucs_map,
  NULL,
  NULL,
  NULL,
  &ksx1001_ucs_map,
  &sjis_ext_ucs_map,
  &sjis_ext_ucs_map,
  &sjis_ext_ucs_map,
  &gbk_ucs_map,
  &gbk_ucs_map,
  &gbk_ucs_map,
  NULL,
  NULL,
  NULL,
  &uhc_ucs_map,
  &uhc_ucs_map,
  &uhc_ucs_map,
  &hkscs_ucs_map,
  &hkscs_ucs_map,
  &hkscs_ucs_map
}; // idb
wc_table ucs_cs94_table[21] =
{
  { 0u, 0u, NULL, &ucs_cs94_conv },
  { 0u, 0u, NULL, &ucs_cs94_conv },
  { 0u, 0u, NULL, &ucs_cs94_conv },
  { 0u, 0u, NULL, &ucs_cs94_conv },
  { 0u, 0u, NULL, &ucs_cs94_conv },
  { 0u, 0u, NULL, &ucs_cs94_conv },
  { 0u, 0u, NULL, &ucs_cs94_conv },
  { 0u, 0u, NULL, &ucs_cs94_conv },
  { 0u, 0u, NULL, &ucs_cs94_conv },
  { 329u, 63u, &ucs_jisx0201k_map, &ucs_cs94_conv },
  { 0u, 0u, NULL, &ucs_cs94_conv },
  { 0u, 0u, NULL, &ucs_cs94_conv },
  { 0u, 0u, NULL, &ucs_cs94_conv },
  { 0u, 0u, NULL, &ucs_cs94_conv },
  { 0u, 0u, NULL, &ucs_cs94_conv },
  { 0u, 0u, NULL, &ucs_cs94_conv },
  { 0u, 0u, NULL, &ucs_cs94_conv },
  { 0u, 0u, NULL, &ucs_cs94_conv },
  { 0u, 0u, NULL, &ucs_cs94_conv },
  { 0u, 0u, NULL, &ucs_cs94_conv },
  { 0u, 0u, NULL, &ucs_cs94_conv }
}; // idb
wc_table ucs_cs96_table[39] =
{
  { 0u, 0u, NULL, &ucs_cs94_conv },
  { 577u, 96u, &ucs_iso88591_map, &ucs_cs94_conv },
  { 578u, 96u, &ucs_iso88592_map, &ucs_cs94_conv },
  { 579u, 89u, &ucs_iso88593_map, &ucs_cs94_conv },
  { 580u, 96u, &ucs_iso88594_map, &ucs_cs94_conv },
  { 0u, 0u, NULL, &ucs_cs94_conv },
  { 582u, 90u, &ucs_iso88597_map, &ucs_cs94_conv },
  { 583u, 51u, &ucs_iso88596_map, &ucs_cs94_conv },
  { 584u, 60u, &ucs_iso88598_map, &ucs_cs94_conv },
  { 0u, 0u, NULL, &ucs_cs94_conv },
  { 0u, 0u, NULL, &ucs_cs94_conv },
  { 0u, 0u, NULL, &ucs_cs94_conv },
  { 588u, 96u, &ucs_iso88595_map, &ucs_cs94_conv },
  { 589u, 96u, &ucs_iso88599_map, &ucs_cs94_conv },
  { 0u, 0u, NULL, &ucs_cs94_conv },
  { 0u, 0u, NULL, &ucs_cs94_conv },
  { 0u, 0u, NULL, &ucs_cs94_conv },
  { 0u, 0u, NULL, &ucs_cs94_conv },
  { 0u, 0u, NULL, &ucs_cs94_conv },
  { 0u, 0u, NULL, &ucs_cs94_conv },
  { 596u, 88u, &ucs_iso885911_map, &ucs_cs94_conv },
  { 0u, 0u, NULL, &ucs_cs94_conv },
  { 598u, 96u, &ucs_iso885910_map, &ucs_cs94_conv },
  { 0u, 0u, NULL, &ucs_cs94_conv },
  { 0u, 0u, NULL, &ucs_cs94_conv },
  { 601u, 96u, &ucs_iso885913_map, &ucs_cs94_conv },
  { 0u, 0u, NULL, &ucs_cs94_conv },
  { 0u, 0u, NULL, &ucs_cs94_conv },
  { 0u, 0u, NULL, &ucs_cs94_conv },
  { 0u, 0u, NULL, &ucs_cs94_conv },
  { 0u, 0u, NULL, &ucs_cs94_conv },
  { 607u, 96u, &ucs_iso885914_map, &ucs_cs94_conv },
  { 0u, 0u, NULL, &ucs_cs94_conv },
  { 0u, 0u, NULL, &ucs_cs94_conv },
  { 610u, 96u, &ucs_iso885915_map, &ucs_cs94_conv },
  { 0u, 0u, NULL, &ucs_cs94_conv },
  { 0u, 0u, NULL, &ucs_cs94_conv },
  { 0u, 0u, NULL, &ucs_cs94_conv },
  { 614u, 96u, &ucs_iso885916_map, &ucs_cs94_conv }
}; // idb
wc_table ucs_cs94w_table[17] =
{
  { 0u, 0u, NULL, &ucs_cs94_conv },
  { 33089u, 7445u, &ucs_gb2312_map, &ucs_cs94_conv },
  { 33090u, 6887u, &ucs_jisx0208_map, &ucs_cs94_conv },
  { 33091u, 8224u, &ucs_ksx1001_map, &ucs_cs94_conv },
  { 33092u, 6067u, &ucs_jisx0212_map, &ucs_cs94_conv },
  { 0u, 0u, NULL, &ucs_cs94_conv },
  { 0u, 0u, NULL, &ucs_cs94_conv },
  { 33095u, 13514u, &ucs_cns11643_map, &ucs_cns11643_conv },
  { 33096u, 13514u, &ucs_cns11643_map, &ucs_cns11643_conv },
  { 0u, 0u, NULL, &ucs_cs94_conv },
  { 0u, 0u, NULL, &ucs_cs94_conv },
  { 0u, 0u, NULL, &ucs_cs94_conv },
  { 0u, 0u, NULL, &ucs_cs94_conv },
  { 0u, 0u, NULL, &ucs_cs94_conv },
  { 0u, 0u, NULL, &ucs_cs94_conv },
  { 33103u, 1700u, &ucs_jisx02131_map, &ucs_cs94_conv },
  { 33104u, 2155u, &ucs_jisx02132_map, &ucs_cs94_conv }
}; // idb
wc_map ucs_wide_map[11] =
{
  { 4352u, 4447u },
  { 9001u, 9002u },
  { 11904u, 12350u },
  { 12352u, 19903u },
  { 19968u, 42191u },
  { 44032u, 55203u },
  { 63744u, 64255u },
  { 65040u, 65049u },
  { 65072u, 65135u },
  { 65280u, 65375u },
  { 65504u, 65510u }
}; // idb
wc_map ucs_combining_map[99] =
{
  { 768u, 846u },
  { 864u, 866u },
  { 1155u, 1158u },
  { 1160u, 1161u },
  { 1425u, 1441u },
  { 1443u, 1465u },
  { 1467u, 1469u },
  { 1471u, 1471u },
  { 1473u, 1474u },
  { 1476u, 1476u },
  { 1611u, 1621u },
  { 1648u, 1648u },
  { 1750u, 1764u },
  { 1767u, 1768u },
  { 1770u, 1773u },
  { 1809u, 1809u },
  { 1840u, 1866u },
  { 1958u, 1968u },
  { 2305u, 2307u },
  { 2364u, 2364u },
  { 2366u, 2381u },
  { 2385u, 2388u },
  { 2402u, 2403u },
  { 2433u, 2435u },
  { 2492u, 2492u },
  { 2494u, 2500u },
  { 2503u, 2504u },
  { 2507u, 2509u },
  { 2519u, 2519u },
  { 2530u, 2531u },
  { 2562u, 2562u },
  { 2620u, 2620u },
  { 2622u, 2626u },
  { 2631u, 2632u },
  { 2635u, 2637u },
  { 2672u, 2673u },
  { 2689u, 2691u },
  { 2748u, 2748u },
  { 2750u, 2757u },
  { 2759u, 2761u },
  { 2763u, 2765u },
  { 2817u, 2819u },
  { 2876u, 2876u },
  { 2878u, 2883u },
  { 2887u, 2888u },
  { 2891u, 2893u },
  { 2902u, 2903u },
  { 2946u, 2947u },
  { 3006u, 3010u },
  { 3014u, 3016u },
  { 3018u, 3021u },
  { 3031u, 3031u },
  { 3073u, 3075u },
  { 3134u, 3140u },
  { 3142u, 3144u },
  { 3146u, 3149u },
  { 3157u, 3158u },
  { 3202u, 3203u },
  { 3262u, 3268u },
  { 3270u, 3272u },
  { 3274u, 3277u },
  { 3285u, 3286u },
  { 3330u, 3331u },
  { 3390u, 3395u },
  { 3398u, 3400u },
  { 3402u, 3405u },
  { 3415u, 3415u },
  { 3458u, 3459u },
  { 3530u, 3530u },
  { 3535u, 3540u },
  { 3542u, 3542u },
  { 3544u, 3551u },
  { 3570u, 3571u },
  { 3633u, 3633u },
  { 3636u, 3642u },
  { 3655u, 3662u },
  { 3761u, 3761u },
  { 3764u, 3769u },
  { 3771u, 3772u },
  { 3784u, 3789u },
  { 3864u, 3865u },
  { 3893u, 3893u },
  { 3895u, 3895u },
  { 3897u, 3897u },
  { 3902u, 3903u },
  { 3953u, 3972u },
  { 3974u, 3975u },
  { 3984u, 3991u },
  { 3993u, 4028u },
  { 4038u, 4038u },
  { 4140u, 4146u },
  { 4150u, 4153u },
  { 4182u, 4185u },
  { 6068u, 6099u },
  { 6313u, 6313u },
  { 8400u, 8419u },
  { 12330u, 12335u },
  { 12441u, 12442u },
  { 64286u, 64286u }
}; // idb
wc_map3 ucs_precompose_map[988] =
{
  { 60u, 824u, 8814u },
  { 61u, 824u, 8800u },
  { 62u, 824u, 8815u },
  { 65u, 768u, 192u },
  { 65u, 769u, 193u },
  { 65u, 770u, 194u },
  { 65u, 771u, 195u },
  { 65u, 772u, 256u },
  { 65u, 774u, 258u },
  { 65u, 775u, 550u },
  { 65u, 776u, 196u },
  { 65u, 777u, 7842u },
  { 65u, 778u, 197u },
  { 65u, 780u, 461u },
  { 65u, 783u, 512u },
  { 65u, 785u, 514u },
  { 65u, 803u, 7840u },
  { 65u, 805u, 7680u },
  { 65u, 808u, 260u },
  { 66u, 775u, 7682u },
  { 66u, 803u, 7684u },
  { 66u, 817u, 7686u },
  { 67u, 769u, 262u },
  { 67u, 770u, 264u },
  { 67u, 775u, 266u },
  { 67u, 780u, 268u },
  { 67u, 807u, 199u },
  { 68u, 775u, 7690u },
  { 68u, 780u, 270u },
  { 68u, 803u, 7692u },
  { 68u, 807u, 7696u },
  { 68u, 813u, 7698u },
  { 68u, 817u, 7694u },
  { 69u, 768u, 200u },
  { 69u, 769u, 201u },
  { 69u, 770u, 202u },
  { 69u, 771u, 7868u },
  { 69u, 772u, 274u },
  { 69u, 774u, 276u },
  { 69u, 775u, 278u },
  { 69u, 776u, 203u },
  { 69u, 777u, 7866u },
  { 69u, 780u, 282u },
  { 69u, 783u, 516u },
  { 69u, 785u, 518u },
  { 69u, 803u, 7864u },
  { 69u, 807u, 552u },
  { 69u, 808u, 280u },
  { 69u, 813u, 7704u },
  { 69u, 816u, 7706u },
  { 70u, 775u, 7710u },
  { 71u, 769u, 500u },
  { 71u, 770u, 284u },
  { 71u, 772u, 7712u },
  { 71u, 774u, 286u },
  { 71u, 775u, 288u },
  { 71u, 780u, 486u },
  { 71u, 807u, 290u },
  { 72u, 770u, 292u },
  { 72u, 775u, 7714u },
  { 72u, 776u, 7718u },
  { 72u, 780u, 542u },
  { 72u, 803u, 7716u },
  { 72u, 807u, 7720u },
  { 72u, 814u, 7722u },
  { 73u, 768u, 204u },
  { 73u, 769u, 205u },
  { 73u, 770u, 206u },
  { 73u, 771u, 296u },
  { 73u, 772u, 298u },
  { 73u, 774u, 300u },
  { 73u, 775u, 304u },
  { 73u, 776u, 207u },
  { 73u, 777u, 7880u },
  { 73u, 780u, 463u },
  { 73u, 783u, 520u },
  { 73u, 785u, 522u },
  { 73u, 803u, 7882u },
  { 73u, 808u, 302u },
  { 73u, 816u, 7724u },
  { 74u, 770u, 308u },
  { 75u, 769u, 7728u },
  { 75u, 780u, 488u },
  { 75u, 803u, 7730u },
  { 75u, 807u, 310u },
  { 75u, 817u, 7732u },
  { 76u, 769u, 313u },
  { 76u, 780u, 317u },
  { 76u, 803u, 7734u },
  { 76u, 807u, 315u },
  { 76u, 813u, 7740u },
  { 76u, 817u, 7738u },
  { 77u, 769u, 7742u },
  { 77u, 775u, 7744u },
  { 77u, 803u, 7746u },
  { 78u, 768u, 504u },
  { 78u, 769u, 323u },
  { 78u, 771u, 209u },
  { 78u, 775u, 7748u },
  { 78u, 780u, 327u },
  { 78u, 803u, 7750u },
  { 78u, 807u, 325u },
  { 78u, 813u, 7754u },
  { 78u, 817u, 7752u },
  { 79u, 768u, 210u },
  { 79u, 769u, 211u },
  { 79u, 770u, 212u },
  { 79u, 771u, 213u },
  { 79u, 772u, 332u },
  { 79u, 774u, 334u },
  { 79u, 775u, 558u },
  { 79u, 776u, 214u },
  { 79u, 777u, 7886u },
  { 79u, 779u, 336u },
  { 79u, 780u, 465u },
  { 79u, 783u, 524u },
  { 79u, 785u, 526u },
  { 79u, 795u, 416u },
  { 79u, 803u, 7884u },
  { 79u, 808u, 490u },
  { 80u, 769u, 7764u },
  { 80u, 775u, 7766u },
  { 82u, 769u, 340u },
  { 82u, 775u, 7768u },
  { 82u, 780u, 344u },
  { 82u, 783u, 528u },
  { 82u, 785u, 530u },
  { 82u, 803u, 7770u },
  { 82u, 807u, 342u },
  { 82u, 817u, 7774u },
  { 83u, 769u, 346u },
  { 83u, 770u, 348u },
  { 83u, 775u, 7776u },
  { 83u, 780u, 352u },
  { 83u, 803u, 7778u },
  { 83u, 806u, 536u },
  { 83u, 807u, 350u },
  { 84u, 775u, 7786u },
  { 84u, 780u, 356u },
  { 84u, 803u, 7788u },
  { 84u, 806u, 538u },
  { 84u, 807u, 354u },
  { 84u, 813u, 7792u },
  { 84u, 817u, 7790u },
  { 85u, 768u, 217u },
  { 85u, 769u, 218u },
  { 85u, 770u, 219u },
  { 85u, 771u, 360u },
  { 85u, 772u, 362u },
  { 85u, 774u, 364u },
  { 85u, 776u, 220u },
  { 85u, 777u, 7910u },
  { 85u, 778u, 366u },
  { 85u, 779u, 368u },
  { 85u, 780u, 467u },
  { 85u, 783u, 532u },
  { 85u, 785u, 534u },
  { 85u, 795u, 431u },
  { 85u, 803u, 7908u },
  { 85u, 804u, 7794u },
  { 85u, 808u, 370u },
  { 85u, 813u, 7798u },
  { 85u, 816u, 7796u },
  { 86u, 771u, 7804u },
  { 86u, 803u, 7806u },
  { 87u, 768u, 7808u },
  { 87u, 769u, 7810u },
  { 87u, 770u, 372u },
  { 87u, 775u, 7814u },
  { 87u, 776u, 7812u },
  { 87u, 803u, 7816u },
  { 88u, 775u, 7818u },
  { 88u, 776u, 7820u },
  { 89u, 768u, 7922u },
  { 89u, 769u, 221u },
  { 89u, 770u, 374u },
  { 89u, 771u, 7928u },
  { 89u, 772u, 562u },
  { 89u, 775u, 7822u },
  { 89u, 776u, 376u },
  { 89u, 777u, 7926u },
  { 89u, 803u, 7924u },
  { 90u, 769u, 377u },
  { 90u, 770u, 7824u },
  { 90u, 775u, 379u },
  { 90u, 780u, 381u },
  { 90u, 803u, 7826u },
  { 90u, 817u, 7828u },
  { 97u, 768u, 224u },
  { 97u, 769u, 225u },
  { 97u, 770u, 226u },
  { 97u, 771u, 227u },
  { 97u, 772u, 257u },
  { 97u, 774u, 259u },
  { 97u, 775u, 551u },
  { 97u, 776u, 228u },
  { 97u, 777u, 7843u },
  { 97u, 778u, 229u },
  { 97u, 780u, 462u },
  { 97u, 783u, 513u },
  { 97u, 785u, 515u },
  { 97u, 803u, 7841u },
  { 97u, 805u, 7681u },
  { 97u, 808u, 261u },
  { 98u, 775u, 7683u },
  { 98u, 803u, 7685u },
  { 98u, 817u, 7687u },
  { 99u, 769u, 263u },
  { 99u, 770u, 265u },
  { 99u, 775u, 267u },
  { 99u, 780u, 269u },
  { 99u, 807u, 231u },
  { 100u, 775u, 7691u },
  { 100u, 780u, 271u },
  { 100u, 803u, 7693u },
  { 100u, 807u, 7697u },
  { 100u, 813u, 7699u },
  { 100u, 817u, 7695u },
  { 101u, 768u, 232u },
  { 101u, 769u, 233u },
  { 101u, 770u, 234u },
  { 101u, 771u, 7869u },
  { 101u, 772u, 275u },
  { 101u, 774u, 277u },
  { 101u, 775u, 279u },
  { 101u, 776u, 235u },
  { 101u, 777u, 7867u },
  { 101u, 780u, 283u },
  { 101u, 783u, 517u },
  { 101u, 785u, 519u },
  { 101u, 803u, 7865u },
  { 101u, 807u, 553u },
  { 101u, 808u, 281u },
  { 101u, 813u, 7705u },
  { 101u, 816u, 7707u },
  { 102u, 775u, 7711u },
  { 103u, 769u, 501u },
  { 103u, 770u, 285u },
  { 103u, 772u, 7713u },
  { 103u, 774u, 287u },
  { 103u, 775u, 289u },
  { 103u, 780u, 487u },
  { 103u, 807u, 291u },
  { 104u, 770u, 293u },
  { 104u, 775u, 7715u },
  { 104u, 776u, 7719u },
  { 104u, 780u, 543u },
  { 104u, 803u, 7717u },
  { 104u, 807u, 7721u },
  { 104u, 814u, 7723u },
  { 104u, 817u, 7830u },
  { 105u, 768u, 236u },
  { 105u, 769u, 237u },
  { 105u, 770u, 238u },
  { 105u, 771u, 297u },
  { 105u, 772u, 299u },
  { 105u, 774u, 301u },
  { 105u, 776u, 239u },
  { 105u, 777u, 7881u },
  { 105u, 780u, 464u },
  { 105u, 783u, 521u },
  { 105u, 785u, 523u },
  { 105u, 803u, 7883u },
  { 105u, 808u, 303u },
  { 105u, 816u, 7725u },
  { 106u, 770u, 309u },
  { 106u, 780u, 496u },
  { 107u, 769u, 7729u },
  { 107u, 780u, 489u },
  { 107u, 803u, 7731u },
  { 107u, 807u, 311u },
  { 107u, 817u, 7733u },
  { 108u, 769u, 314u },
  { 108u, 780u, 318u },
  { 108u, 803u, 7735u },
  { 108u, 807u, 316u },
  { 108u, 813u, 7741u },
  { 108u, 817u, 7739u },
  { 109u, 769u, 7743u },
  { 109u, 775u, 7745u },
  { 109u, 803u, 7747u },
  { 110u, 768u, 505u },
  { 110u, 769u, 324u },
  { 110u, 771u, 241u },
  { 110u, 775u, 7749u },
  { 110u, 780u, 328u },
  { 110u, 803u, 7751u },
  { 110u, 807u, 326u },
  { 110u, 813u, 7755u },
  { 110u, 817u, 7753u },
  { 111u, 768u, 242u },
  { 111u, 769u, 243u },
  { 111u, 770u, 244u },
  { 111u, 771u, 245u },
  { 111u, 772u, 333u },
  { 111u, 774u, 335u },
  { 111u, 775u, 559u },
  { 111u, 776u, 246u },
  { 111u, 777u, 7887u },
  { 111u, 779u, 337u },
  { 111u, 780u, 466u },
  { 111u, 783u, 525u },
  { 111u, 785u, 527u },
  { 111u, 795u, 417u },
  { 111u, 803u, 7885u },
  { 111u, 808u, 491u },
  { 112u, 769u, 7765u },
  { 112u, 775u, 7767u },
  { 114u, 769u, 341u },
  { 114u, 775u, 7769u },
  { 114u, 780u, 345u },
  { 114u, 783u, 529u },
  { 114u, 785u, 531u },
  { 114u, 803u, 7771u },
  { 114u, 807u, 343u },
  { 114u, 817u, 7775u },
  { 115u, 769u, 347u },
  { 115u, 770u, 349u },
  { 115u, 775u, 7777u },
  { 115u, 780u, 353u },
  { 115u, 803u, 7779u },
  { 115u, 806u, 537u },
  { 115u, 807u, 351u },
  { 116u, 775u, 7787u },
  { 116u, 776u, 7831u },
  { 116u, 780u, 357u },
  { 116u, 803u, 7789u },
  { 116u, 806u, 539u },
  { 116u, 807u, 355u },
  { 116u, 813u, 7793u },
  { 116u, 817u, 7791u },
  { 117u, 768u, 249u },
  { 117u, 769u, 250u },
  { 117u, 770u, 251u },
  { 117u, 771u, 361u },
  { 117u, 772u, 363u },
  { 117u, 774u, 365u },
  { 117u, 776u, 252u },
  { 117u, 777u, 7911u },
  { 117u, 778u, 367u },
  { 117u, 779u, 369u },
  { 117u, 780u, 468u },
  { 117u, 783u, 533u },
  { 117u, 785u, 535u },
  { 117u, 795u, 432u },
  { 117u, 803u, 7909u },
  { 117u, 804u, 7795u },
  { 117u, 808u, 371u },
  { 117u, 813u, 7799u },
  { 117u, 816u, 7797u },
  { 118u, 771u, 7805u },
  { 118u, 803u, 7807u },
  { 119u, 768u, 7809u },
  { 119u, 769u, 7811u },
  { 119u, 770u, 373u },
  { 119u, 775u, 7815u },
  { 119u, 776u, 7813u },
  { 119u, 778u, 7832u },
  { 119u, 803u, 7817u },
  { 120u, 775u, 7819u },
  { 120u, 776u, 7821u },
  { 121u, 768u, 7923u },
  { 121u, 769u, 253u },
  { 121u, 770u, 375u },
  { 121u, 771u, 7929u },
  { 121u, 772u, 563u },
  { 121u, 775u, 7823u },
  { 121u, 776u, 255u },
  { 121u, 777u, 7927u },
  { 121u, 778u, 7833u },
  { 121u, 803u, 7925u },
  { 122u, 769u, 378u },
  { 122u, 770u, 7825u },
  { 122u, 775u, 380u },
  { 122u, 780u, 382u },
  { 122u, 803u, 7827u },
  { 122u, 817u, 7829u },
  { 168u, 768u, 8173u },
  { 168u, 769u, 901u },
  { 168u, 834u, 8129u },
  { 194u, 768u, 7846u },
  { 194u, 769u, 7844u },
  { 194u, 771u, 7850u },
  { 194u, 777u, 7848u },
  { 196u, 772u, 478u },
  { 197u, 769u, 506u },
  { 198u, 769u, 508u },
  { 198u, 772u, 482u },
  { 199u, 769u, 7688u },
  { 202u, 768u, 7872u },
  { 202u, 769u, 7870u },
  { 202u, 771u, 7876u },
  { 202u, 777u, 7874u },
  { 207u, 769u, 7726u },
  { 212u, 768u, 7890u },
  { 212u, 769u, 7888u },
  { 212u, 771u, 7894u },
  { 212u, 777u, 7892u },
  { 213u, 769u, 7756u },
  { 213u, 772u, 556u },
  { 213u, 776u, 7758u },
  { 214u, 772u, 554u },
  { 216u, 769u, 510u },
  { 220u, 768u, 475u },
  { 220u, 769u, 471u },
  { 220u, 772u, 469u },
  { 220u, 780u, 473u },
  { 226u, 768u, 7847u },
  { 226u, 769u, 7845u },
  { 226u, 771u, 7851u },
  { 226u, 777u, 7849u },
  { 228u, 772u, 479u },
  { 229u, 769u, 507u },
  { 230u, 769u, 509u },
  { 230u, 772u, 483u },
  { 231u, 769u, 7689u },
  { 234u, 768u, 7873u },
  { 234u, 769u, 7871u },
  { 234u, 771u, 7877u },
  { 234u, 777u, 7875u },
  { 239u, 769u, 7727u },
  { 244u, 768u, 7891u },
  { 244u, 769u, 7889u },
  { 244u, 771u, 7895u },
  { 244u, 777u, 7893u },
  { 245u, 769u, 7757u },
  { 245u, 772u, 557u },
  { 245u, 776u, 7759u },
  { 246u, 772u, 555u },
  { 248u, 769u, 511u },
  { 252u, 768u, 476u },
  { 252u, 769u, 472u },
  { 252u, 772u, 470u },
  { 252u, 780u, 474u },
  { 258u, 768u, 7856u },
  { 258u, 769u, 7854u },
  { 258u, 771u, 7860u },
  { 258u, 777u, 7858u },
  { 259u, 768u, 7857u },
  { 259u, 769u, 7855u },
  { 259u, 771u, 7861u },
  { 259u, 777u, 7859u },
  { 274u, 768u, 7700u },
  { 274u, 769u, 7702u },
  { 275u, 768u, 7701u },
  { 275u, 769u, 7703u },
  { 332u, 768u, 7760u },
  { 332u, 769u, 7762u },
  { 333u, 768u, 7761u },
  { 333u, 769u, 7763u },
  { 346u, 775u, 7780u },
  { 347u, 775u, 7781u },
  { 352u, 775u, 7782u },
  { 353u, 775u, 7783u },
  { 360u, 769u, 7800u },
  { 361u, 769u, 7801u },
  { 362u, 776u, 7802u },
  { 363u, 776u, 7803u },
  { 383u, 775u, 7835u },
  { 416u, 768u, 7900u },
  { 416u, 769u, 7898u },
  { 416u, 771u, 7904u },
  { 416u, 777u, 7902u },
  { 416u, 803u, 7906u },
  { 417u, 768u, 7901u },
  { 417u, 769u, 7899u },
  { 417u, 771u, 7905u },
  { 417u, 777u, 7903u },
  { 417u, 803u, 7907u },
  { 431u, 768u, 7914u },
  { 431u, 769u, 7912u },
  { 431u, 771u, 7918u },
  { 431u, 777u, 7916u },
  { 431u, 803u, 7920u },
  { 432u, 768u, 7915u },
  { 432u, 769u, 7913u },
  { 432u, 771u, 7919u },
  { 432u, 777u, 7917u },
  { 432u, 803u, 7921u },
  { 439u, 780u, 494u },
  { 490u, 772u, 492u },
  { 491u, 772u, 493u },
  { 550u, 772u, 480u },
  { 551u, 772u, 481u },
  { 552u, 774u, 7708u },
  { 553u, 774u, 7709u },
  { 558u, 772u, 560u },
  { 559u, 772u, 561u },
  { 658u, 780u, 495u },
  { 776u, 769u, 836u },
  { 913u, 768u, 8122u },
  { 913u, 769u, 902u },
  { 913u, 772u, 8121u },
  { 913u, 774u, 8120u },
  { 913u, 787u, 7944u },
  { 913u, 788u, 7945u },
  { 913u, 837u, 8124u },
  { 917u, 768u, 8136u },
  { 917u, 769u, 904u },
  { 917u, 787u, 7960u },
  { 917u, 788u, 7961u },
  { 919u, 768u, 8138u },
  { 919u, 769u, 905u },
  { 919u, 787u, 7976u },
  { 919u, 788u, 7977u },
  { 919u, 837u, 8140u },
  { 921u, 768u, 8154u },
  { 921u, 769u, 906u },
  { 921u, 772u, 8153u },
  { 921u, 774u, 8152u },
  { 921u, 776u, 938u },
  { 921u, 787u, 7992u },
  { 921u, 788u, 7993u },
  { 927u, 768u, 8184u },
  { 927u, 769u, 908u },
  { 927u, 787u, 8008u },
  { 927u, 788u, 8009u },
  { 929u, 788u, 8172u },
  { 933u, 768u, 8170u },
  { 933u, 769u, 910u },
  { 933u, 772u, 8169u },
  { 933u, 774u, 8168u },
  { 933u, 776u, 939u },
  { 933u, 788u, 8025u },
  { 937u, 768u, 8186u },
  { 937u, 769u, 911u },
  { 937u, 787u, 8040u },
  { 937u, 788u, 8041u },
  { 937u, 837u, 8188u },
  { 940u, 837u, 8116u },
  { 942u, 837u, 8132u },
  { 945u, 768u, 8048u },
  { 945u, 769u, 940u },
  { 945u, 772u, 8113u },
  { 945u, 774u, 8112u },
  { 945u, 787u, 7936u },
  { 945u, 788u, 7937u },
  { 945u, 834u, 8118u },
  { 945u, 837u, 8115u },
  { 949u, 768u, 8050u },
  { 949u, 769u, 941u },
  { 949u, 787u, 7952u },
  { 949u, 788u, 7953u },
  { 951u, 768u, 8052u },
  { 951u, 769u, 942u },
  { 951u, 787u, 7968u },
  { 951u, 788u, 7969u },
  { 951u, 834u, 8134u },
  { 951u, 837u, 8131u },
  { 953u, 768u, 8054u },
  { 953u, 769u, 943u },
  { 953u, 772u, 8145u },
  { 953u, 774u, 8144u },
  { 953u, 776u, 970u },
  { 953u, 787u, 7984u },
  { 953u, 788u, 7985u },
  { 953u, 834u, 8150u },
  { 959u, 768u, 8056u },
  { 959u, 769u, 972u },
  { 959u, 787u, 8000u },
  { 959u, 788u, 8001u },
  { 961u, 787u, 8164u },
  { 961u, 788u, 8165u },
  { 965u, 768u, 8058u },
  { 965u, 769u, 973u },
  { 965u, 772u, 8161u },
  { 965u, 774u, 8160u },
  { 965u, 776u, 971u },
  { 965u, 787u, 8016u },
  { 965u, 788u, 8017u },
  { 965u, 834u, 8166u },
  { 969u, 768u, 8060u },
  { 969u, 769u, 974u },
  { 969u, 787u, 8032u },
  { 969u, 788u, 8033u },
  { 969u, 834u, 8182u },
  { 969u, 837u, 8179u },
  { 970u, 768u, 8146u },
  { 970u, 769u, 912u },
  { 970u, 834u, 8151u },
  { 971u, 768u, 8162u },
  { 971u, 769u, 944u },
  { 971u, 834u, 8167u },
  { 974u, 837u, 8180u },
  { 978u, 769u, 979u },
  { 978u, 776u, 980u },
  { 1030u, 776u, 1031u },
  { 1040u, 774u, 1232u },
  { 1040u, 776u, 1234u },
  { 1043u, 769u, 1027u },
  { 1045u, 768u, 1024u },
  { 1045u, 774u, 1238u },
  { 1045u, 776u, 1025u },
  { 1046u, 774u, 1217u },
  { 1046u, 776u, 1244u },
  { 1047u, 776u, 1246u },
  { 1048u, 768u, 1037u },
  { 1048u, 772u, 1250u },
  { 1048u, 774u, 1049u },
  { 1048u, 776u, 1252u },
  { 1050u, 769u, 1036u },
  { 1054u, 776u, 1254u },
  { 1059u, 772u, 1262u },
  { 1059u, 774u, 1038u },
  { 1059u, 776u, 1264u },
  { 1059u, 779u, 1266u },
  { 1063u, 776u, 1268u },
  { 1067u, 776u, 1272u },
  { 1069u, 776u, 1260u },
  { 1072u, 774u, 1233u },
  { 1072u, 776u, 1235u },
  { 1075u, 769u, 1107u },
  { 1077u, 768u, 1104u },
  { 1077u, 774u, 1239u },
  { 1077u, 776u, 1105u },
  { 1078u, 774u, 1218u },
  { 1078u, 776u, 1245u },
  { 1079u, 776u, 1247u },
  { 1080u, 768u, 1117u },
  { 1080u, 772u, 1251u },
  { 1080u, 774u, 1081u },
  { 1080u, 776u, 1253u },
  { 1082u, 769u, 1116u },
  { 1086u, 776u, 1255u },
  { 1091u, 772u, 1263u },
  { 1091u, 774u, 1118u },
  { 1091u, 776u, 1265u },
  { 1091u, 779u, 1267u },
  { 1095u, 776u, 1269u },
  { 1099u, 776u, 1273u },
  { 1101u, 776u, 1261u },
  { 1110u, 776u, 1111u },
  { 1140u, 783u, 1142u },
  { 1141u, 783u, 1143u },
  { 1240u, 776u, 1242u },
  { 1241u, 776u, 1243u },
  { 1256u, 776u, 1258u },
  { 1257u, 776u, 1259u },
  { 1488u, 1463u, 64302u },
  { 1488u, 1464u, 64303u },
  { 1488u, 1468u, 64304u },
  { 1489u, 1468u, 64305u },
  { 1489u, 1471u, 64332u },
  { 1490u, 1468u, 64306u },
  { 1491u, 1468u, 64307u },
  { 1492u, 1468u, 64308u },
  { 1493u, 1465u, 64331u },
  { 1493u, 1468u, 64309u },
  { 1494u, 1468u, 64310u },
  { 1496u, 1468u, 64312u },
  { 1497u, 1460u, 64285u },
  { 1497u, 1468u, 64313u },
  { 1498u, 1468u, 64314u },
  { 1499u, 1468u, 64315u },
  { 1499u, 1471u, 64333u },
  { 1500u, 1468u, 64316u },
  { 1502u, 1468u, 64318u },
  { 1504u, 1468u, 64320u },
  { 1505u, 1468u, 64321u },
  { 1507u, 1468u, 64323u },
  { 1508u, 1468u, 64324u },
  { 1508u, 1471u, 64334u },
  { 1510u, 1468u, 64326u },
  { 1511u, 1468u, 64327u },
  { 1512u, 1468u, 64328u },
  { 1513u, 1468u, 64329u },
  { 1513u, 1473u, 64298u },
  { 1513u, 1474u, 64299u },
  { 1514u, 1468u, 64330u },
  { 1522u, 1463u, 64287u },
  { 1575u, 1619u, 1570u },
  { 1575u, 1620u, 1571u },
  { 1575u, 1621u, 1573u },
  { 1608u, 1620u, 1572u },
  { 1610u, 1620u, 1574u },
  { 1729u, 1620u, 1730u },
  { 1746u, 1620u, 1747u },
  { 1749u, 1620u, 1728u },
  { 2325u, 2364u, 2392u },
  { 2326u, 2364u, 2393u },
  { 2327u, 2364u, 2394u },
  { 2332u, 2364u, 2395u },
  { 2337u, 2364u, 2396u },
  { 2338u, 2364u, 2397u },
  { 2344u, 2364u, 2345u },
  { 2347u, 2364u, 2398u },
  { 2351u, 2364u, 2399u },
  { 2352u, 2364u, 2353u },
  { 2355u, 2364u, 2356u },
  { 2465u, 2492u, 2524u },
  { 2466u, 2492u, 2525u },
  { 2479u, 2492u, 2527u },
  { 2503u, 2494u, 2507u },
  { 2503u, 2519u, 2508u },
  { 2582u, 2620u, 2649u },
  { 2583u, 2620u, 2650u },
  { 2588u, 2620u, 2651u },
  { 2603u, 2620u, 2654u },
  { 2610u, 2620u, 2611u },
  { 2616u, 2620u, 2614u },
  { 2849u, 2876u, 2908u },
  { 2850u, 2876u, 2909u },
  { 2887u, 2878u, 2891u },
  { 2887u, 2902u, 2888u },
  { 2887u, 2903u, 2892u },
  { 2962u, 3031u, 2964u },
  { 3014u, 3006u, 3018u },
  { 3014u, 3031u, 3020u },
  { 3015u, 3006u, 3019u },
  { 3142u, 3158u, 3144u },
  { 3263u, 3285u, 3264u },
  { 3270u, 3266u, 3274u },
  { 3270u, 3285u, 3271u },
  { 3270u, 3286u, 3272u },
  { 3274u, 3285u, 3275u },
  { 3398u, 3390u, 3402u },
  { 3398u, 3415u, 3404u },
  { 3399u, 3390u, 3403u },
  { 3545u, 3530u, 3546u },
  { 3545u, 3535u, 3548u },
  { 3545u, 3551u, 3550u },
  { 3548u, 3530u, 3549u },
  { 3904u, 4021u, 3945u },
  { 3906u, 4023u, 3907u },
  { 3916u, 4023u, 3917u },
  { 3921u, 4023u, 3922u },
  { 3926u, 4023u, 3927u },
  { 3931u, 4023u, 3932u },
  { 3953u, 3954u, 3955u },
  { 3953u, 3956u, 3957u },
  { 3953u, 3968u, 3969u },
  { 3984u, 4021u, 4025u },
  { 3986u, 4023u, 3987u },
  { 3996u, 4023u, 3997u },
  { 4001u, 4023u, 4002u },
  { 4006u, 4023u, 4007u },
  { 4011u, 4023u, 4012u },
  { 4018u, 3968u, 3958u },
  { 4019u, 3968u, 3960u },
  { 4133u, 4142u, 4134u },
  { 7734u, 772u, 7736u },
  { 7735u, 772u, 7737u },
  { 7770u, 772u, 7772u },
  { 7771u, 772u, 7773u },
  { 7778u, 775u, 7784u },
  { 7779u, 775u, 7785u },
  { 7840u, 770u, 7852u },
  { 7840u, 774u, 7862u },
  { 7841u, 770u, 7853u },
  { 7841u, 774u, 7863u },
  { 7864u, 770u, 7878u },
  { 7865u, 770u, 7879u },
  { 7884u, 770u, 7896u },
  { 7885u, 770u, 7897u },
  { 7936u, 768u, 7938u },
  { 7936u, 769u, 7940u },
  { 7936u, 834u, 7942u },
  { 7936u, 837u, 8064u },
  { 7937u, 768u, 7939u },
  { 7937u, 769u, 7941u },
  { 7937u, 834u, 7943u },
  { 7937u, 837u, 8065u },
  { 7938u, 837u, 8066u },
  { 7939u, 837u, 8067u },
  { 7940u, 837u, 8068u },
  { 7941u, 837u, 8069u },
  { 7942u, 837u, 8070u },
  { 7943u, 837u, 8071u },
  { 7944u, 768u, 7946u },
  { 7944u, 769u, 7948u },
  { 7944u, 834u, 7950u },
  { 7944u, 837u, 8072u },
  { 7945u, 768u, 7947u },
  { 7945u, 769u, 7949u },
  { 7945u, 834u, 7951u },
  { 7945u, 837u, 8073u },
  { 7946u, 837u, 8074u },
  { 7947u, 837u, 8075u },
  { 7948u, 837u, 8076u },
  { 7949u, 837u, 8077u },
  { 7950u, 837u, 8078u },
  { 7951u, 837u, 8079u },
  { 7952u, 768u, 7954u },
  { 7952u, 769u, 7956u },
  { 7953u, 768u, 7955u },
  { 7953u, 769u, 7957u },
  { 7960u, 768u, 7962u },
  { 7960u, 769u, 7964u },
  { 7961u, 768u, 7963u },
  { 7961u, 769u, 7965u },
  { 7968u, 768u, 7970u },
  { 7968u, 769u, 7972u },
  { 7968u, 834u, 7974u },
  { 7968u, 837u, 8080u },
  { 7969u, 768u, 7971u },
  { 7969u, 769u, 7973u },
  { 7969u, 834u, 7975u },
  { 7969u, 837u, 8081u },
  { 7970u, 837u, 8082u },
  { 7971u, 837u, 8083u },
  { 7972u, 837u, 8084u },
  { 7973u, 837u, 8085u },
  { 7974u, 837u, 8086u },
  { 7975u, 837u, 8087u },
  { 7976u, 768u, 7978u },
  { 7976u, 769u, 7980u },
  { 7976u, 834u, 7982u },
  { 7976u, 837u, 8088u },
  { 7977u, 768u, 7979u },
  { 7977u, 769u, 7981u },
  { 7977u, 834u, 7983u },
  { 7977u, 837u, 8089u },
  { 7978u, 837u, 8090u },
  { 7979u, 837u, 8091u },
  { 7980u, 837u, 8092u },
  { 7981u, 837u, 8093u },
  { 7982u, 837u, 8094u },
  { 7983u, 837u, 8095u },
  { 7984u, 768u, 7986u },
  { 7984u, 769u, 7988u },
  { 7984u, 834u, 7990u },
  { 7985u, 768u, 7987u },
  { 7985u, 769u, 7989u },
  { 7985u, 834u, 7991u },
  { 7992u, 768u, 7994u },
  { 7992u, 769u, 7996u },
  { 7992u, 834u, 7998u },
  { 7993u, 768u, 7995u },
  { 7993u, 769u, 7997u },
  { 7993u, 834u, 7999u },
  { 8000u, 768u, 8002u },
  { 8000u, 769u, 8004u },
  { 8001u, 768u, 8003u },
  { 8001u, 769u, 8005u },
  { 8008u, 768u, 8010u },
  { 8008u, 769u, 8012u },
  { 8009u, 768u, 8011u },
  { 8009u, 769u, 8013u },
  { 8016u, 768u, 8018u },
  { 8016u, 769u, 8020u },
  { 8016u, 834u, 8022u },
  { 8017u, 768u, 8019u },
  { 8017u, 769u, 8021u },
  { 8017u, 834u, 8023u },
  { 8025u, 768u, 8027u },
  { 8025u, 769u, 8029u },
  { 8025u, 834u, 8031u },
  { 8032u, 768u, 8034u },
  { 8032u, 769u, 8036u },
  { 8032u, 834u, 8038u },
  { 8032u, 837u, 8096u },
  { 8033u, 768u, 8035u },
  { 8033u, 769u, 8037u },
  { 8033u, 834u, 8039u },
  { 8033u, 837u, 8097u },
  { 8034u, 837u, 8098u },
  { 8035u, 837u, 8099u },
  { 8036u, 837u, 8100u },
  { 8037u, 837u, 8101u },
  { 8038u, 837u, 8102u },
  { 8039u, 837u, 8103u },
  { 8040u, 768u, 8042u },
  { 8040u, 769u, 8044u },
  { 8040u, 834u, 8046u },
  { 8040u, 837u, 8104u },
  { 8041u, 768u, 8043u },
  { 8041u, 769u, 8045u },
  { 8041u, 834u, 8047u },
  { 8041u, 837u, 8105u },
  { 8042u, 837u, 8106u },
  { 8043u, 837u, 8107u },
  { 8044u, 837u, 8108u },
  { 8045u, 837u, 8109u },
  { 8046u, 837u, 8110u },
  { 8047u, 837u, 8111u },
  { 8048u, 837u, 8114u },
  { 8052u, 837u, 8130u },
  { 8060u, 837u, 8178u },
  { 8118u, 837u, 8119u },
  { 8127u, 768u, 8141u },
  { 8127u, 769u, 8142u },
  { 8127u, 834u, 8143u },
  { 8134u, 837u, 8135u },
  { 8182u, 837u, 8183u },
  { 8190u, 768u, 8157u },
  { 8190u, 769u, 8158u },
  { 8190u, 834u, 8159u },
  { 8592u, 824u, 8602u },
  { 8594u, 824u, 8603u },
  { 8596u, 824u, 8622u },
  { 8656u, 824u, 8653u },
  { 8658u, 824u, 8655u },
  { 8660u, 824u, 8654u },
  { 8707u, 824u, 8708u },
  { 8712u, 824u, 8713u },
  { 8715u, 824u, 8716u },
  { 8739u, 824u, 8740u },
  { 8741u, 824u, 8742u },
  { 8764u, 824u, 8769u },
  { 8771u, 824u, 8772u },
  { 8773u, 824u, 8775u },
  { 8776u, 824u, 8777u },
  { 8781u, 824u, 8813u },
  { 8801u, 824u, 8802u },
  { 8804u, 824u, 8816u },
  { 8805u, 824u, 8817u },
  { 8818u, 824u, 8820u },
  { 8819u, 824u, 8821u },
  { 8822u, 824u, 8824u },
  { 8823u, 824u, 8825u },
  { 8826u, 824u, 8832u },
  { 8827u, 824u, 8833u },
  { 8828u, 824u, 8928u },
  { 8829u, 824u, 8929u },
  { 8834u, 824u, 8836u },
  { 8835u, 824u, 8837u },
  { 8838u, 824u, 8840u },
  { 8839u, 824u, 8841u },
  { 8849u, 824u, 8930u },
  { 8850u, 824u, 8931u },
  { 8866u, 824u, 8876u },
  { 8872u, 824u, 8877u },
  { 8873u, 824u, 8878u },
  { 8875u, 824u, 8879u },
  { 8882u, 824u, 8938u },
  { 8883u, 824u, 8939u },
  { 8884u, 824u, 8940u },
  { 8885u, 824u, 8941u },
  { 12358u, 12441u, 12436u },
  { 12363u, 12441u, 12364u },
  { 12365u, 12441u, 12366u },
  { 12367u, 12441u, 12368u },
  { 12369u, 12441u, 12370u },
  { 12371u, 12441u, 12372u },
  { 12373u, 12441u, 12374u },
  { 12375u, 12441u, 12376u },
  { 12377u, 12441u, 12378u },
  { 12379u, 12441u, 12380u },
  { 12381u, 12441u, 12382u },
  { 12383u, 12441u, 12384u },
  { 12385u, 12441u, 12386u },
  { 12388u, 12441u, 12389u },
  { 12390u, 12441u, 12391u },
  { 12392u, 12441u, 12393u },
  { 12399u, 12441u, 12400u },
  { 12399u, 12442u, 12401u },
  { 12402u, 12441u, 12403u },
  { 12402u, 12442u, 12404u },
  { 12405u, 12441u, 12406u },
  { 12405u, 12442u, 12407u },
  { 12408u, 12441u, 12409u },
  { 12408u, 12442u, 12410u },
  { 12411u, 12441u, 12412u },
  { 12411u, 12442u, 12413u },
  { 12445u, 12441u, 12446u },
  { 12454u, 12441u, 12532u },
  { 12459u, 12441u, 12460u },
  { 12461u, 12441u, 12462u },
  { 12463u, 12441u, 12464u },
  { 12465u, 12441u, 12466u },
  { 12467u, 12441u, 12468u },
  { 12469u, 12441u, 12470u },
  { 12471u, 12441u, 12472u },
  { 12473u, 12441u, 12474u },
  { 12475u, 12441u, 12476u },
  { 12477u, 12441u, 12478u },
  { 12479u, 12441u, 12480u },
  { 12481u, 12441u, 12482u },
  { 12484u, 12441u, 12485u },
  { 12486u, 12441u, 12487u },
  { 12488u, 12441u, 12489u },
  { 12495u, 12441u, 12496u },
  { 12495u, 12442u, 12497u },
  { 12498u, 12441u, 12499u },
  { 12498u, 12442u, 12500u },
  { 12501u, 12441u, 12502u },
  { 12501u, 12442u, 12503u },
  { 12504u, 12441u, 12505u },
  { 12504u, 12442u, 12506u },
  { 12507u, 12441u, 12508u },
  { 12507u, 12442u, 12509u },
  { 12527u, 12441u, 12535u },
  { 12528u, 12441u, 12536u },
  { 12529u, 12441u, 12537u },
  { 12530u, 12441u, 12538u },
  { 12541u, 12441u, 12542u },
  { 64329u, 1473u, 64300u },
  { 64329u, 1474u, 64301u }
}; // idb
wc_map ucs_hangul_map[6] =
{
  { 4352u, 4601u },
  { 12593u, 12686u },
  { 12800u, 12828u },
  { 12896u, 12923u },
  { 44032u, 55203u },
  { 65440u, 65500u }
}; // idb
wc_map ucs_fullwidth_map[14] =
{
  { 162u, 65504u },
  { 163u, 65505u },
  { 165u, 65509u },
  { 166u, 65508u },
  { 172u, 65506u },
  { 175u, 65507u },
  { 8361u, 65510u },
  { 65504u, 162u },
  { 65505u, 163u },
  { 65506u, 172u },
  { 65507u, 175u },
  { 65508u, 166u },
  { 65509u, 165u },
  { 65510u, 8361u }
}; // idb
wc_uint8 WC_UHC_MAP[256] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  1u,
  1u,
  1u,
  1u,
  0u,
  2u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  2u
}; // idb
wc_uint8 WC_UTF7_MAP[256] =
{
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  4u,
  4u,
  6u,
  6u,
  4u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  6u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  0u,
  0u,
  1u,
  32u,
  0u,
  64u,
  0u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  0u,
  1u,
  1u,
  1u,
  1u,
  0u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  1u,
  2u,
  1u,
  1u,
  1u,
  1u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  1u,
  1u,
  1u,
  2u,
  6u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u
}; // idb
char c_base64_map[96] =
{
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '>',
  '\xFF',
  '\xFF',
  '\xFF',
  '?',
  '4',
  '5',
  '6',
  '7',
  '8',
  '9',
  ':',
  ';',
  '<',
  '=',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\0',
  '\x01',
  '\x02',
  '\x03',
  '\x04',
  '\x05',
  '\x06',
  '\a',
  '\b',
  '\t',
  '\n',
  '\v',
  '\f',
  '\r',
  '\x0E',
  '\x0F',
  '\x10',
  '\x11',
  '\x12',
  '\x13',
  '\x14',
  '\x15',
  '\x16',
  '\x17',
  '\x18',
  '\x19',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\x1A',
  '\x1B',
  '\x1C',
  '\x1D',
  '\x1E',
  '\x1F',
  ' ',
  '!',
  '\"',
  '#',
  '$',
  '%',
  '&',
  '\'',
  '(',
  ')',
  '*',
  '+',
  ',',
  '-',
  '.',
  '/',
  '0',
  '1',
  '2',
  '3',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF'
}; // idb
char base64_c_map[65] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"; // idb
wc_uint8 WC_UTF8_MAP[256] =
{
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  8u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  5u,
  5u,
  5u,
  5u,
  6u,
  6u,
  7u,
  7u
}; // idb
wc_map tcvn57123_tcvn5712_map[120] =
{
  { 16816u, 128u },
  { 16817u, 129u },
  { 16818u, 130u },
  { 16819u, 131u },
  { 16820u, 132u },
  { 17840u, 135u },
  { 17841u, 136u },
  { 17842u, 137u },
  { 17843u, 138u },
  { 17844u, 139u },
  { 18864u, 141u },
  { 18865u, 142u },
  { 18866u, 143u },
  { 18867u, 144u },
  { 18868u, 145u },
  { 20400u, 146u },
  { 20401u, 147u },
  { 20402u, 148u },
  { 20403u, 149u },
  { 20404u, 150u },
  { 21936u, 157u },
  { 21937u, 158u },
  { 21938u, 159u },
  { 21939u, 1u },
  { 21940u, 2u },
  { 22960u, 19u },
  { 22961u, 20u },
  { 22962u, 21u },
  { 22963u, 22u },
  { 22964u, 23u },
  { 25008u, 181u },
  { 25009u, 182u },
  { 25010u, 183u },
  { 25011u, 184u },
  { 25012u, 185u },
  { 26032u, 204u },
  { 26033u, 206u },
  { 26034u, 207u },
  { 26035u, 208u },
  { 26036u, 209u },
  { 27056u, 215u },
  { 27057u, 216u },
  { 27058u, 220u },
  { 27059u, 221u },
  { 27060u, 222u },
  { 28592u, 223u },
  { 28593u, 225u },
  { 28594u, 226u },
  { 28595u, 227u },
  { 28596u, 228u },
  { 30128u, 239u },
  { 30129u, 241u },
  { 30130u, 242u },
  { 30131u, 243u },
  { 30132u, 244u },
  { 31152u, 250u },
  { 31153u, 251u },
  { 31154u, 252u },
  { 31155u, 253u },
  { 31156u, 254u },
  { 41392u, 175u },
  { 41393u, 186u },
  { 41394u, 191u },
  { 41395u, 192u },
  { 41396u, 133u },
  { 41648u, 193u },
  { 41649u, 194u },
  { 41650u, 195u },
  { 41651u, 196u },
  { 41652u, 134u },
  { 41904u, 197u },
  { 41905u, 205u },
  { 41906u, 217u },
  { 41907u, 218u },
  { 41908u, 140u },
  { 42160u, 219u },
  { 42161u, 224u },
  { 42162u, 240u },
  { 42163u, 255u },
  { 42164u, 151u },
  { 42416u, 152u },
  { 42417u, 153u },
  { 42418u, 154u },
  { 42419u, 155u },
  { 42420u, 156u },
  { 42672u, 4u },
  { 42673u, 5u },
  { 42674u, 6u },
  { 42675u, 17u },
  { 42676u, 18u },
  { 43184u, 187u },
  { 43185u, 188u },
  { 43186u, 189u },
  { 43187u, 190u },
  { 43188u, 198u },
  { 43440u, 199u },
  { 43441u, 200u },
  { 43442u, 201u },
  { 43443u, 202u },
  { 43444u, 203u },
  { 43696u, 210u },
  { 43697u, 211u },
  { 43698u, 212u },
  { 43699u, 213u },
  { 43700u, 214u },
  { 43952u, 229u },
  { 43953u, 230u },
  { 43954u, 231u },
  { 43955u, 232u },
  { 43956u, 233u },
  { 44208u, 234u },
  { 44209u, 235u },
  { 44210u, 236u },
  { 44211u, 237u },
  { 44212u, 238u },
  { 44464u, 245u },
  { 44465u, 246u },
  { 44466u, 247u },
  { 44467u, 248u },
  { 44468u, 249u }
}; // idb
wc_uint8 wc_c0_tcvn57122_map[32] =
{
  0u,
  1u,
  1u,
  0u,
  1u,
  1u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // idb
wc_uint8 wc_c0_viscii112_map[32] =
{
  0u,
  0u,
  1u,
  0u,
  0u,
  1u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  0u,
  0u,
  0u,
  0u,
  1u,
  0u,
  0u,
  0u,
  0u,
  1u,
  0u
}; // idb
wc_uint8 wc_c0_vps2_map[32] =
{
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  0u,
  0u,
  1u,
  0u,
  0u,
  1u,
  1u,
  0u,
  0u
}; // idb
wc_uint8 tcvn5712_precompose_map[256] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  0u,
  0u,
  0u,
  1u,
  0u,
  0u,
  0u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  0u,
  0u,
  0u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  0u,
  0u,
  0u,
  1u,
  0u,
  0u,
  0u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  0u,
  0u,
  0u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  0u,
  0u,
  2u,
  2u,
  2u,
  2u,
  2u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // idb
wc_uint8 cp1258_precompose_map[256] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  0u,
  0u,
  0u,
  1u,
  0u,
  0u,
  0u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  0u,
  0u,
  0u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  0u,
  0u,
  0u,
  1u,
  0u,
  0u,
  0u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  0u,
  0u,
  0u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  0u,
  2u,
  0u,
  0u,
  0u,
  0u,
  0u,
  2u,
  0u,
  1u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  2u,
  0u,
  0u,
  0u,
  1u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  0u,
  2u,
  0u,
  0u,
  0u,
  0u,
  0u,
  2u,
  0u,
  1u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  0u,
  0u
}; // idb
wc_uint8 WTF_WIDTH_MAP[256] =
{
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  2u,
  1u,
  1u,
  1u,
  2u,
  1u,
  2u,
  1u,
  2u,
  1u,
  1u,
  1u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u
}; // idb
wc_uint8 WTF_LEN_MAP[256] =
{
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  3u,
  4u,
  3u,
  4u,
  3u,
  3u,
  3u,
  4u,
  4u,
  4u,
  6u,
  6u,
  1u,
  1u,
  1u,
  1u,
  3u,
  4u,
  3u,
  4u,
  3u,
  3u,
  3u,
  4u,
  4u,
  4u,
  6u,
  6u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u
}; // idb
wc_uint8 WTF_TYPE_MAP[256] =
{
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  2u,
  10u,
  2u,
  10u,
  2u,
  18u,
  2u,
  10u,
  2u,
  10u,
  2u,
  10u,
  32u,
  32u,
  32u,
  32u,
  4u,
  12u,
  4u,
  12u,
  4u,
  32u,
  4u,
  12u,
  4u,
  12u,
  4u,
  12u,
  32u,
  32u,
  32u,
  32u,
  32u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u
}; // idb
wc_uint16 CCS_MAP[33] =
{
  1u,
  129u,
  2u,
  130u,
  4u,
  64u,
  8u,
  136u,
  16u,
  272u,
  32u,
  288u,
  0u,
  0u,
  0u,
  0u,
  513u,
  641u,
  514u,
  642u,
  516u,
  0u,
  520u,
  648u,
  528u,
  784u,
  544u,
  800u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // idb
wc_ces wtf_major_ces = 256u; // idb
wc_uint8 WC_BIG5_MAP[256] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  0u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  2u
}; // idb
wc_ces_info WcCesInfo[72] =
{
  {
    256u,
    "US-ASCII",
    "Latin (US-ASCII)",
    &gset_usascii,
    NULL,
    &wc_conv_from_ascii,
    &wc_push_to_iso8859,
    &wc_char_conv_from_iso2022
  },
  {
    1049089u,
    "ISO-8859-1",
    "Latin 1 (ISO-8859-1)",
    &gset_iso88591,
    NULL,
    &wc_conv_from_iso2022,
    &wc_push_to_iso8859,
    &wc_char_conv_from_iso2022
  },
  {
    1049090u,
    "ISO-8859-2",
    "Latin 2 (ISO-8859-2)",
    &gset_iso88592,
    NULL,
    &wc_conv_from_iso2022,
    &wc_push_to_iso8859,
    &wc_char_conv_from_iso2022
  },
  {
    1049091u,
    "ISO-8859-3",
    "Latin 3 (ISO-8859-3)",
    &gset_iso88593,
    NULL,
    &wc_conv_from_iso2022,
    &wc_push_to_iso8859,
    &wc_char_conv_from_iso2022
  },
  {
    1049092u,
    "ISO-8859-4",
    "Latin 4 (ISO-8859-4)",
    &gset_iso88594,
    NULL,
    &wc_conv_from_iso2022,
    &wc_push_to_iso8859,
    &wc_char_conv_from_iso2022
  },
  {
    1049093u,
    "ISO-8859-5",
    "Cyrillic (ISO-8859-5)",
    &gset_iso88595,
    NULL,
    &wc_conv_from_iso2022,
    &wc_push_to_iso8859,
    &wc_char_conv_from_iso2022
  },
  {
    1049094u,
    "ISO-8859-6",
    "Arabic (ISO-8859-6)",
    &gset_iso88596,
    NULL,
    &wc_conv_from_iso2022,
    &wc_push_to_iso8859,
    &wc_char_conv_from_iso2022
  },
  {
    1049095u,
    "ISO-8859-7",
    "Greek (ISO-8859-7)",
    &gset_iso88597,
    NULL,
    &wc_conv_from_iso2022,
    &wc_push_to_iso8859,
    &wc_char_conv_from_iso2022
  },
  {
    1049096u,
    "ISO-8859-8",
    "Hebrew (ISO-8859-8)",
    &gset_iso88598,
    NULL,
    &wc_conv_from_iso2022,
    &wc_push_to_iso8859,
    &wc_char_conv_from_iso2022
  },
  {
    1049097u,
    "ISO-8859-9",
    "Turkish (ISO-8859-9)",
    &gset_iso88599,
    NULL,
    &wc_conv_from_iso2022,
    &wc_push_to_iso8859,
    &wc_char_conv_from_iso2022
  },
  {
    1049098u,
    "ISO-8859-10",
    "Nordic (ISO-8859-10)",
    &gset_iso885910,
    NULL,
    &wc_conv_from_iso2022,
    &wc_push_to_iso8859,
    &wc_char_conv_from_iso2022
  },
  {
    1049099u,
    "ISO-8859-11",
    "Thai (ISO-8859-11, TIS-620)",
    &gset_iso885911,
    NULL,
    &wc_conv_from_iso2022,
    &wc_push_to_iso8859,
    &wc_char_conv_from_iso2022
  },
  { 1049100u, NULL, NULL, NULL, NULL, NULL, NULL, NULL },
  {
    1049101u,
    "ISO-8859-13",
    "Baltic Rim (ISO-8859-13)",
    &gset_iso885913,
    NULL,
    &wc_conv_from_iso2022,
    &wc_push_to_iso8859,
    &wc_char_conv_from_iso2022
  },
  {
    1049102u,
    "ISO-8859-14",
    "Celtic (ISO-8859-14)",
    &gset_iso885914,
    NULL,
    &wc_conv_from_iso2022,
    &wc_push_to_iso8859,
    &wc_char_conv_from_iso2022
  },
  {
    1049103u,
    "ISO-8859-15",
    "Latin 9 (ISO-8859-15)",
    &gset_iso885915,
    NULL,
    &wc_conv_from_iso2022,
    &wc_push_to_iso8859,
    &wc_char_conv_from_iso2022
  },
  {
    1049104u,
    "ISO-8859-16",
    "Romanian (ISO-8859-16)",
    &gset_iso885916,
    NULL,
    &wc_conv_from_iso2022,
    &wc_push_to_iso8859,
    &wc_char_conv_from_iso2022
  },
  {
    2099217u,
    "ISO-2022-JP",
    "Japanese (ISO-2022-JP)",
    &gset_iso2022jp,
    &gset_ext_iso2022jp,
    &wc_conv_from_iso2022,
    &wc_push_to_iso2022,
    &wc_char_conv_from_iso2022
  },
  {
    2099218u,
    "ISO-2022-JP-2",
    "Japanese (ISO-2022-JP-2)",
    &gset_iso2022jp2,
    &gset_ext_iso2022jp,
    &wc_conv_from_iso2022,
    &wc_push_to_iso2022,
    &wc_char_conv_from_iso2022
  },
  {
    2099219u,
    "ISO-2022-JP-3",
    "Japanese (ISO-2022-JP-3)",
    &gset_iso2022jp3,
    &gset_ext_iso2022jp,
    &wc_conv_from_iso2022,
    &wc_push_to_iso2022,
    &wc_char_conv_from_iso2022
  },
  {
    2099220u,
    "ISO-2022-CN",
    "Chinese (ISO-2022-CN)",
    &gset_iso2022cn,
    &gset_ext_iso2022cn,
    &wc_conv_from_iso2022,
    &wc_push_to_iso2022,
    &wc_char_conv_from_iso2022
  },
  {
    2099221u,
    "ISO-2022-KR",
    "Korean (ISO-2022-KR)",
    &gset_iso2022kr,
    &gset_ext_iso2022kr,
    &wc_conv_from_iso2022,
    &wc_push_to_iso2022,
    &wc_char_conv_from_iso2022
  },
  {
    3149846u,
    "EUC-JP",
    "Japanese (EUC-JP)",
    &gset_eucjp,
    NULL,
    &wc_conv_from_iso2022,
    &wc_push_to_eucjp,
    &wc_char_conv_from_iso2022
  },
  {
    3149847u,
    "EUC-CN",
    "Chinese (EUC-CN, GB2312)",
    &gset_euccn,
    NULL,
    &wc_conv_from_iso2022,
    &wc_push_to_euc,
    &wc_char_conv_from_iso2022
  },
  {
    3149848u,
    "EUC-TW",
    "Chinese Taiwan (EUC-TW)",
    &gset_euctw,
    NULL,
    &wc_conv_from_iso2022,
    &wc_push_to_euctw,
    &wc_char_conv_from_iso2022
  },
  {
    3149849u,
    "EUC-KR",
    "Korean (EUC-KR)",
    &gset_euckr,
    NULL,
    &wc_conv_from_iso2022,
    &wc_push_to_euc,
    &wc_char_conv_from_iso2022
  },
  {
    1049626u,
    "CP437",
    "Latin (CP437)",
    &gset_cp437,
    NULL,
    &wc_conv_from_priv1,
    &wc_push_to_iso8859,
    &wc_char_conv_from_priv1
  },
  {
    1049627u,
    "CP737",
    "Greek (CP737)",
    &gset_cp737,
    NULL,
    &wc_conv_from_priv1,
    &wc_push_to_iso8859,
    &wc_char_conv_from_priv1
  },
  {
    1049628u,
    "CP775",
    "Baltic Rim (CP775)",
    &gset_cp775,
    NULL,
    &wc_conv_from_priv1,
    &wc_push_to_iso8859,
    &wc_char_conv_from_priv1
  },
  {
    1049629u,
    "CP850",
    "Latin 1 (CP850)",
    &gset_cp850,
    NULL,
    &wc_conv_from_priv1,
    &wc_push_to_iso8859,
    &wc_char_conv_from_priv1
  },
  {
    1049630u,
    "CP852",
    "Latin 2 (CP852)",
    &gset_cp852,
    NULL,
    &wc_conv_from_priv1,
    &wc_push_to_iso8859,
    &wc_char_conv_from_priv1
  },
  {
    1049631u,
    "CP855",
    "Cyrillic (CP855)",
    &gset_cp855,
    NULL,
    &wc_conv_from_priv1,
    &wc_push_to_iso8859,
    &wc_char_conv_from_priv1
  },
  {
    1049632u,
    "CP856",
    "Hebrew (CP856)",
    &gset_cp856,
    NULL,
    &wc_conv_from_priv1,
    &wc_push_to_iso8859,
    &wc_char_conv_from_priv1
  },
  {
    1049633u,
    "CP857",
    "Turkish (CP857)",
    &gset_cp857,
    NULL,
    &wc_conv_from_priv1,
    &wc_push_to_iso8859,
    &wc_char_conv_from_priv1
  },
  {
    1049634u,
    "CP860",
    "Portuguese (CP860)",
    &gset_cp860,
    NULL,
    &wc_conv_from_priv1,
    &wc_push_to_iso8859,
    &wc_char_conv_from_priv1
  },
  {
    1049635u,
    "CP861",
    "Icelandic (CP861)",
    &gset_cp861,
    NULL,
    &wc_conv_from_priv1,
    &wc_push_to_iso8859,
    &wc_char_conv_from_priv1
  },
  {
    1049636u,
    "CP862",
    "Hebrew (CP862)",
    &gset_cp862,
    NULL,
    &wc_conv_from_priv1,
    &wc_push_to_iso8859,
    &wc_char_conv_from_priv1
  },
  {
    1049637u,
    "CP863",
    "Canada French (CP863)",
    &gset_cp863,
    NULL,
    &wc_conv_from_priv1,
    &wc_push_to_iso8859,
    &wc_char_conv_from_priv1
  },
  {
    1049638u,
    "CP864",
    "Arabic (CP864)",
    &gset_cp864,
    NULL,
    &wc_conv_from_priv1,
    &wc_push_to_iso8859,
    &wc_char_conv_from_priv1
  },
  {
    1049639u,
    "CP865",
    "Nordic (CP865)",
    &gset_cp865,
    NULL,
    &wc_conv_from_priv1,
    &wc_push_to_iso8859,
    &wc_char_conv_from_priv1
  },
  {
    1049640u,
    "CP866",
    "Cyrillic (CP866)",
    &gset_cp866,
    NULL,
    &wc_conv_from_priv1,
    &wc_push_to_iso8859,
    &wc_char_conv_from_priv1
  },
  {
    1049641u,
    "CP869",
    "Greek 2 (CP869)",
    &gset_cp869,
    NULL,
    &wc_conv_from_priv1,
    &wc_push_to_iso8859,
    &wc_char_conv_from_priv1
  },
  {
    1049642u,
    "CP874",
    "Thai (CP874)",
    &gset_cp874,
    NULL,
    &wc_conv_from_priv1,
    &wc_push_to_iso8859,
    &wc_char_conv_from_priv1
  },
  {
    1049643u,
    "CP1006",
    "Arabic (CP1006)",
    &gset_cp1006,
    NULL,
    &wc_conv_from_priv1,
    &wc_push_to_iso8859,
    &wc_char_conv_from_priv1
  },
  {
    1049644u,
    "CP1250",
    "Latin 2 (CP1250)",
    &gset_cp1250,
    NULL,
    &wc_conv_from_priv1,
    &wc_push_to_iso8859,
    &wc_char_conv_from_priv1
  },
  {
    1049645u,
    "CP1251",
    "Cyrillic (CP1251)",
    &gset_cp1251,
    NULL,
    &wc_conv_from_priv1,
    &wc_push_to_iso8859,
    &wc_char_conv_from_priv1
  },
  {
    1049646u,
    "CP1252",
    "Latin 1 (CP1252)",
    &gset_cp1252,
    NULL,
    &wc_conv_from_priv1,
    &wc_push_to_iso8859,
    &wc_char_conv_from_priv1
  },
  {
    1049647u,
    "CP1253",
    "Greek (CP1253)",
    &gset_cp1253,
    NULL,
    &wc_conv_from_priv1,
    &wc_push_to_iso8859,
    &wc_char_conv_from_priv1
  },
  {
    1049648u,
    "CP1254",
    "Turkish (CP1254)",
    &gset_cp1254,
    NULL,
    &wc_conv_from_priv1,
    &wc_push_to_iso8859,
    &wc_char_conv_from_priv1
  },
  {
    1049649u,
    "CP1255",
    "Hebrew (CP1255)",
    &gset_cp1255,
    NULL,
    &wc_conv_from_priv1,
    &wc_push_to_iso8859,
    &wc_char_conv_from_priv1
  },
  {
    1049650u,
    "CP1256",
    "Arabic (CP1256)",
    &gset_cp1256,
    NULL,
    &wc_conv_from_priv1,
    &wc_push_to_iso8859,
    &wc_char_conv_from_priv1
  },
  {
    1049651u,
    "CP1257",
    "Baltic Rim (CP1257)",
    &gset_cp1257,
    NULL,
    &wc_conv_from_priv1,
    &wc_push_to_iso8859,
    &wc_char_conv_from_priv1
  },
  {
    1049652u,
    "KOI8-R",
    "Cyrillic (KOI8-R)",
    &gset_koi8r,
    NULL,
    &wc_conv_from_priv1,
    &wc_push_to_iso8859,
    &wc_char_conv_from_priv1
  },
  {
    1049653u,
    "KOI8-U",
    "Ukrainian (KOI8-U)",
    &gset_koi8u,
    NULL,
    &wc_conv_from_priv1,
    &wc_push_to_iso8859,
    &wc_char_conv_from_priv1
  },
  {
    1049654u,
    "NeXTSTEP",
    "NeXTSTEP",
    &gset_nextstep,
    NULL,
    &wc_conv_from_priv1,
    &wc_push_to_iso8859,
    &wc_char_conv_from_priv1
  },
  {
    1049655u,
    "Raw",
    "8bit Raw",
    &gset_raw,
    NULL,
    &wc_conv_from_priv1,
    &wc_push_to_raw,
    &wc_char_conv_from_priv1
  },
  {
    3153976u,
    "Shift_JIS",
    "Japanese (Shift_JIS, CP932)",
    &gset_sjis,
    NULL,
    &wc_conv_from_sjis,
    &wc_push_to_sjis,
    &wc_char_conv_from_sjis
  },
  {
    3153977u,
    "Shift_JISX0213",
    "Japanese (Shift_JISX0213)",
    &gset_sjisx0213,
    NULL,
    &wc_conv_from_sjisx0213,
    &wc_push_to_sjisx0213,
    &wc_char_conv_from_sjisx0213
  },
  {
    3153978u,
    "GBK",
    "Chinese (GBK, CP936)",
    &gset_gbk,
    NULL,
    &wc_conv_from_gbk,
    &wc_push_to_gbk,
    &wc_char_conv_from_gbk
  },
  {
    3153979u,
    "GB18030",
    "Chinese (GB18030)",
    &gset_gb18030,
    NULL,
    &wc_conv_from_gb18030,
    &wc_push_to_gb18030,
    &wc_char_conv_from_gb18030
  },
  {
    2105404u,
    "HZ-GB-2312",
    "Chinese (HZ-GB-2312)",
    &gset_hz,
    NULL,
    &wc_conv_from_hz,
    &wc_push_to_hz,
    &wc_char_conv_from_iso2022
  },
  {
    3153981u,
    "Big5",
    "Chinese Taiwan (Big5, CP950)",
    &gset_big5,
    NULL,
    &wc_conv_from_big5,
    &wc_push_to_big5,
    &wc_char_conv_from_big5
  },
  {
    3153982u,
    "HKSCS",
    "Chinese Hong Kong (HKSCS)",
    &gset_hkscs,
    NULL,
    &wc_conv_from_hkscs,
    &wc_push_to_hkscs,
    &wc_char_conv_from_hkscs
  },
  {
    3153983u,
    "UHC",
    "Korean (UHC, CP949)",
    &gset_uhc,
    NULL,
    &wc_conv_from_uhc,
    &wc_push_to_uhc,
    &wc_char_conv_from_uhc
  },
  {
    3153984u,
    "Johab",
    "Korean (Johab)",
    &gset_johab,
    NULL,
    &wc_conv_from_johab,
    &wc_push_to_johab,
    &wc_char_conv_from_johab
  },
  {
    1049665u,
    "CP1258",
    "Vietnamese (CP1258)",
    &gset_cp1258,
    NULL,
    &wc_conv_from_priv1,
    &wc_push_to_viet,
    &wc_char_conv_from_priv1
  },
  {
    1066050u,
    "TCVN-5712",
    "Vietnamese (TCVN-5712)",
    &gset_tcvn5712,
    NULL,
    &wc_conv_from_viet,
    &wc_push_to_viet,
    &wc_char_conv_from_viet
  },
  {
    1066051u,
    "VISCII-1.1",
    "Vietnamese (VISCII 1.1)",
    &gset_viscii11,
    NULL,
    &wc_conv_from_viet,
    &wc_push_to_viet,
    &wc_char_conv_from_viet
  },
  {
    1066052u,
    "VPS",
    "Vietnamese (VPS)",
    &gset_vps,
    NULL,
    &wc_conv_from_viet,
    &wc_push_to_viet,
    &wc_char_conv_from_viet
  },
  {
    3178565u,
    "UTF-8",
    "Unicode (UTF-8)",
    &gset_utf8,
    NULL,
    &wc_conv_from_utf8,
    &wc_push_to_utf8,
    &wc_char_conv_from_utf8
  },
  {
    2129990u,
    "UTF-7",
    "Unicode (UTF-7)",
    &gset_utf7,
    NULL,
    &wc_conv_from_utf7,
    &wc_push_to_utf7,
    &wc_char_conv_from_utf7
  },
  { 0u, NULL, NULL, NULL, NULL, NULL, NULL, NULL }
}; // idb
wc_uint8 iso88596_combining_map[128] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // idb
wc_uint8 iso885911_combining_map[128] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // idb
wc_uint8 cp864_combining_map[128] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // idb
wc_uint8 cp874_combining_map[128] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // idb
wc_uint8 cp1255_combining_map[128] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  1u,
  1u,
  1u,
  0u,
  1u,
  0u,
  1u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // idb
wc_uint8 cp1256_combining_map[128] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  0u,
  1u,
  1u,
  0u,
  1u,
  0u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // idb
wc_uint8 cp1258_combining_map[128] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // idb
wc_uint8 tcvn5712_combining_map[128] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // idb
wc_map3 gbk_ext_ucs_map[110] =
{
  { 41280u, 41376u, 58566u },
  { 41536u, 41632u, 58662u },
  { 41643u, 41648u, 59238u },
  { 41700u, 41700u, 59245u },
  { 41711u, 41712u, 59246u },
  { 41725u, 41726u, 59248u },
  { 41792u, 41888u, 58758u },
  { 42048u, 42144u, 58854u },
  { 42228u, 42238u, 59250u },
  { 42304u, 42400u, 58950u },
  { 42487u, 42494u, 59261u },
  { 42560u, 42656u, 59046u },
  { 42681u, 42688u, 59269u },
  { 42713u, 42719u, 59277u },
  { 42732u, 42733u, 59284u },
  { 42739u, 42739u, 59286u },
  { 42742u, 42750u, 59287u },
  { 42816u, 42912u, 59142u },
  { 42946u, 42960u, 59296u },
  { 42994u, 43006u, 59311u },
  { 43158u, 43168u, 59324u },
  { 43196u, 43196u, 59335u },
  { 43199u, 43199u, 505u },
  { 43201u, 43204u, 59337u },
  { 43242u, 43262u, 59341u },
  { 43352u, 43352u, 59362u },
  { 43355u, 43355u, 59363u },
  { 43357u, 43359u, 59364u },
  { 43401u, 43401u, 12350u },
  { 43402u, 43413u, 12272u },
  { 43415u, 43427u, 59380u },
  { 43504u, 43518u, 59393u },
  { 43681u, 43774u, 57344u },
  { 43937u, 44030u, 57438u },
  { 44193u, 44286u, 57532u },
  { 44449u, 44542u, 57626u },
  { 44705u, 44798u, 57720u },
  { 44961u, 45054u, 57814u },
  { 55290u, 55294u, 59408u },
  { 63649u, 63742u, 57908u },
  { 63905u, 63998u, 58002u },
  { 64161u, 64254u, 58096u },
  { 64417u, 64510u, 58190u },
  { 64673u, 64766u, 58284u },
  { 64929u, 65022u, 58378u },
  { 65104u, 65104u, 11905u },
  { 65105u, 65107u, 59414u },
  { 65108u, 65108u, 11908u },
  { 65109u, 65109u, 13427u },
  { 65110u, 65110u, 13383u },
  { 65111u, 65111u, 11912u },
  { 65112u, 65112u, 11915u },
  { 65113u, 65113u, 59422u },
  { 65114u, 65114u, 13726u },
  { 65115u, 65115u, 13850u },
  { 65116u, 65116u, 13838u },
  { 65117u, 65117u, 11916u },
  { 65118u, 65118u, 11927u },
  { 65119u, 65119u, 14702u },
  { 65120u, 65120u, 14616u },
  { 65121u, 65121u, 59430u },
  { 65122u, 65122u, 14799u },
  { 65123u, 65123u, 14815u },
  { 65124u, 65124u, 14963u },
  { 65125u, 65125u, 14800u },
  { 65126u, 65127u, 59435u },
  { 65128u, 65128u, 15182u },
  { 65129u, 65129u, 15470u },
  { 65130u, 65130u, 15584u },
  { 65131u, 65131u, 11943u },
  { 65132u, 65133u, 59441u },
  { 65134u, 65134u, 11946u },
  { 65135u, 65135u, 16470u },
  { 65136u, 65136u, 16735u },
  { 65137u, 65137u, 11950u },
  { 65138u, 65138u, 17207u },
  { 65139u, 65139u, 11955u },
  { 65140u, 65141u, 11958u },
  { 65142u, 65142u, 59451u },
  { 65143u, 65143u, 17329u },
  { 65144u, 65144u, 17324u },
  { 65145u, 65145u, 11963u },
  { 65146u, 65146u, 17373u },
  { 65147u, 65147u, 17622u },
  { 65148u, 65148u, 18017u },
  { 65149u, 65149u, 17996u },
  { 65150u, 65150u, 59459u },
  { 65152u, 65152u, 18211u },
  { 65153u, 65153u, 18217u },
  { 65154u, 65154u, 18300u },
  { 65155u, 65155u, 18317u },
  { 65156u, 65156u, 11978u },
  { 65157u, 65157u, 18759u },
  { 65158u, 65158u, 18810u },
  { 65159u, 65159u, 18813u },
  { 65160u, 65161u, 18818u },
  { 65162u, 65163u, 18821u },
  { 65164u, 65164u, 18847u },
  { 65165u, 65165u, 18843u },
  { 65166u, 65166u, 18871u },
  { 65167u, 65167u, 18870u },
  { 65168u, 65169u, 59476u },
  { 65170u, 65170u, 19619u },
  { 65171u, 65173u, 19615u },
  { 65174u, 65174u, 19575u },
  { 65175u, 65175u, 19618u },
  { 65176u, 65182u, 19731u },
  { 65183u, 65183u, 19886u },
  { 65184u, 65184u, 59492u },
  { 65185u, 65278u, 58472u }
}; // idb
wc_map3 ucs_gbk_ext_map[110] =
{
  { 505u, 505u, 43199u },
  { 11905u, 11905u, 65104u },
  { 11908u, 11908u, 65108u },
  { 11912u, 11912u, 65111u },
  { 11915u, 11915u, 65112u },
  { 11916u, 11916u, 65117u },
  { 11927u, 11927u, 65118u },
  { 11943u, 11943u, 65131u },
  { 11946u, 11946u, 65134u },
  { 11950u, 11950u, 65137u },
  { 11955u, 11955u, 65139u },
  { 11958u, 11959u, 65140u },
  { 11963u, 11963u, 65145u },
  { 11978u, 11978u, 65156u },
  { 12272u, 12283u, 43402u },
  { 12350u, 12350u, 43401u },
  { 13383u, 13383u, 65110u },
  { 13427u, 13427u, 65109u },
  { 13726u, 13726u, 65114u },
  { 13838u, 13838u, 65116u },
  { 13850u, 13850u, 65115u },
  { 14616u, 14616u, 65120u },
  { 14702u, 14702u, 65119u },
  { 14799u, 14799u, 65122u },
  { 14800u, 14800u, 65125u },
  { 14815u, 14815u, 65123u },
  { 14963u, 14963u, 65124u },
  { 15182u, 15182u, 65128u },
  { 15470u, 15470u, 65129u },
  { 15584u, 15584u, 65130u },
  { 16470u, 16470u, 65135u },
  { 16735u, 16735u, 65136u },
  { 17207u, 17207u, 65138u },
  { 17324u, 17324u, 65144u },
  { 17329u, 17329u, 65143u },
  { 17373u, 17373u, 65146u },
  { 17622u, 17622u, 65147u },
  { 17996u, 17996u, 65149u },
  { 18017u, 18017u, 65148u },
  { 18211u, 18211u, 65152u },
  { 18217u, 18217u, 65153u },
  { 18300u, 18300u, 65154u },
  { 18317u, 18317u, 65155u },
  { 18759u, 18759u, 65157u },
  { 18810u, 18810u, 65158u },
  { 18813u, 18813u, 65159u },
  { 18818u, 18819u, 65160u },
  { 18821u, 18822u, 65162u },
  { 18843u, 18843u, 65165u },
  { 18847u, 18847u, 65164u },
  { 18870u, 18870u, 65167u },
  { 18871u, 18871u, 65166u },
  { 19575u, 19575u, 65174u },
  { 19615u, 19617u, 65171u },
  { 19618u, 19618u, 65175u },
  { 19619u, 19619u, 65170u },
  { 19731u, 19737u, 65176u },
  { 19886u, 19886u, 65183u },
  { 57344u, 57437u, 43681u },
  { 57438u, 57531u, 43937u },
  { 57532u, 57625u, 44193u },
  { 57626u, 57719u, 44449u },
  { 57720u, 57813u, 44705u },
  { 57814u, 57907u, 44961u },
  { 57908u, 58001u, 63649u },
  { 58002u, 58095u, 63905u },
  { 58096u, 58189u, 64161u },
  { 58190u, 58283u, 64417u },
  { 58284u, 58377u, 64673u },
  { 58378u, 58471u, 64929u },
  { 58472u, 58565u, 65185u },
  { 58566u, 58661u, 41280u },
  { 58662u, 58757u, 41536u },
  { 58758u, 58853u, 41792u },
  { 58854u, 58949u, 42048u },
  { 58950u, 59045u, 42304u },
  { 59046u, 59141u, 42560u },
  { 59142u, 59237u, 42816u },
  { 59238u, 59243u, 41643u },
  { 59245u, 59245u, 41700u },
  { 59246u, 59247u, 41711u },
  { 59248u, 59249u, 41725u },
  { 59250u, 59260u, 42228u },
  { 59261u, 59268u, 42487u },
  { 59269u, 59276u, 42681u },
  { 59277u, 59283u, 42713u },
  { 59284u, 59285u, 42732u },
  { 59286u, 59286u, 42739u },
  { 59287u, 59295u, 42742u },
  { 59296u, 59310u, 42946u },
  { 59311u, 59323u, 42994u },
  { 59324u, 59334u, 43158u },
  { 59335u, 59335u, 43196u },
  { 59337u, 59340u, 43201u },
  { 59341u, 59361u, 43242u },
  { 59362u, 59362u, 43352u },
  { 59363u, 59363u, 43355u },
  { 59364u, 59366u, 43357u },
  { 59380u, 59392u, 43415u },
  { 59393u, 59407u, 43504u },
  { 59408u, 59412u, 55290u },
  { 59414u, 59416u, 65105u },
  { 59422u, 59422u, 65113u },
  { 59430u, 59430u, 65121u },
  { 59435u, 59436u, 65126u },
  { 59441u, 59442u, 65132u },
  { 59451u, 59451u, 65142u },
  { 59459u, 59459u, 65150u },
  { 59476u, 59477u, 65168u },
  { 59492u, 59492u, 65184u }
}; // idb
wc_map3 ucs_gb18030_map[206] =
{
  { 128u, 163u, 0u },
  { 165u, 166u, 36u },
  { 169u, 175u, 38u },
  { 178u, 182u, 45u },
  { 184u, 214u, 50u },
  { 216u, 223u, 81u },
  { 226u, 231u, 89u },
  { 235u, 235u, 95u },
  { 238u, 241u, 96u },
  { 244u, 246u, 100u },
  { 248u, 248u, 103u },
  { 251u, 251u, 104u },
  { 253u, 256u, 105u },
  { 258u, 274u, 109u },
  { 276u, 282u, 126u },
  { 284u, 298u, 133u },
  { 300u, 323u, 148u },
  { 325u, 327u, 172u },
  { 329u, 332u, 175u },
  { 334u, 362u, 179u },
  { 364u, 461u, 208u },
  { 463u, 463u, 306u },
  { 465u, 465u, 307u },
  { 467u, 467u, 308u },
  { 469u, 469u, 309u },
  { 471u, 471u, 310u },
  { 473u, 473u, 311u },
  { 475u, 475u, 312u },
  { 477u, 504u, 313u },
  { 506u, 592u, 341u },
  { 594u, 608u, 428u },
  { 610u, 710u, 443u },
  { 712u, 712u, 544u },
  { 716u, 728u, 545u },
  { 730u, 912u, 558u },
  { 930u, 930u, 741u },
  { 938u, 944u, 742u },
  { 962u, 962u, 749u },
  { 970u, 1024u, 750u },
  { 1026u, 1039u, 805u },
  { 1104u, 1104u, 819u },
  { 1106u, 8207u, 820u },
  { 8209u, 8210u, 7922u },
  { 8215u, 8215u, 7924u },
  { 8218u, 8219u, 7925u },
  { 8222u, 8228u, 7927u },
  { 8231u, 8239u, 7934u },
  { 8241u, 8241u, 7943u },
  { 8244u, 8244u, 7944u },
  { 8246u, 8250u, 7945u },
  { 8252u, 8363u, 7950u },
  { 8365u, 8450u, 8062u },
  { 8452u, 8452u, 8148u },
  { 8454u, 8456u, 8149u },
  { 8458u, 8469u, 8152u },
  { 8471u, 8480u, 8164u },
  { 8482u, 8543u, 8174u },
  { 8556u, 8559u, 8236u },
  { 8570u, 8591u, 8240u },
  { 8596u, 8597u, 8262u },
  { 8602u, 8711u, 8264u },
  { 8713u, 8718u, 8374u },
  { 8720u, 8720u, 8380u },
  { 8722u, 8724u, 8381u },
  { 8726u, 8729u, 8384u },
  { 8731u, 8732u, 8388u },
  { 8737u, 8738u, 8390u },
  { 8740u, 8740u, 8392u },
  { 8742u, 8742u, 8393u },
  { 8748u, 8749u, 8394u },
  { 8751u, 8755u, 8396u },
  { 8760u, 8764u, 8401u },
  { 8766u, 8775u, 8406u },
  { 8777u, 8779u, 8416u },
  { 8781u, 8785u, 8419u },
  { 8787u, 8799u, 8424u },
  { 8802u, 8803u, 8437u },
  { 8808u, 8813u, 8439u },
  { 8816u, 8852u, 8445u },
  { 8854u, 8856u, 8482u },
  { 8858u, 8868u, 8485u },
  { 8870u, 8894u, 8496u },
  { 8896u, 8977u, 8521u },
  { 8979u, 9311u, 8603u },
  { 9322u, 9331u, 8936u },
  { 9372u, 9471u, 8946u },
  { 9548u, 9551u, 9046u },
  { 9588u, 9600u, 9050u },
  { 9616u, 9618u, 9063u },
  { 9622u, 9631u, 9066u },
  { 9634u, 9649u, 9076u },
  { 9652u, 9659u, 9092u },
  { 9662u, 9669u, 9100u },
  { 9672u, 9674u, 9108u },
  { 9676u, 9677u, 9111u },
  { 9680u, 9697u, 9113u },
  { 9702u, 9732u, 9131u },
  { 9735u, 9736u, 9162u },
  { 9738u, 9791u, 9164u },
  { 9793u, 9793u, 9218u },
  { 9795u, 11904u, 9219u },
  { 11906u, 11907u, 11329u },
  { 11909u, 11911u, 11331u },
  { 11913u, 11914u, 11334u },
  { 11917u, 11926u, 11336u },
  { 11928u, 11942u, 11346u },
  { 11944u, 11945u, 11361u },
  { 11947u, 11949u, 11363u },
  { 11951u, 11954u, 11366u },
  { 11956u, 11957u, 11370u },
  { 11960u, 11962u, 11372u },
  { 11964u, 11977u, 11375u },
  { 11979u, 12271u, 11389u },
  { 12284u, 12287u, 11682u },
  { 12292u, 12292u, 11686u },
  { 12312u, 12316u, 11687u },
  { 12319u, 12320u, 11692u },
  { 12330u, 12349u, 11694u },
  { 12351u, 12352u, 11714u },
  { 12436u, 12442u, 11716u },
  { 12447u, 12448u, 11723u },
  { 12535u, 12539u, 11725u },
  { 12543u, 12548u, 11730u },
  { 12586u, 12831u, 11736u },
  { 12842u, 12848u, 11982u },
  { 12850u, 12962u, 11989u },
  { 12964u, 13197u, 12102u },
  { 13200u, 13211u, 12336u },
  { 13215u, 13216u, 12348u },
  { 13218u, 13251u, 12350u },
  { 13253u, 13261u, 12384u },
  { 13263u, 13264u, 12393u },
  { 13267u, 13268u, 12395u },
  { 13270u, 13382u, 12397u },
  { 13384u, 13426u, 12510u },
  { 13428u, 13725u, 12553u },
  { 13727u, 13837u, 12851u },
  { 13839u, 13849u, 12962u },
  { 13851u, 14615u, 12973u },
  { 14617u, 14701u, 13738u },
  { 14703u, 14798u, 13823u },
  { 14801u, 14814u, 13919u },
  { 14816u, 14962u, 13933u },
  { 14964u, 15181u, 14080u },
  { 15183u, 15469u, 14298u },
  { 15471u, 15583u, 14585u },
  { 15585u, 16469u, 14698u },
  { 16471u, 16734u, 15583u },
  { 16736u, 17206u, 15847u },
  { 17208u, 17323u, 16318u },
  { 17325u, 17328u, 16434u },
  { 17330u, 17372u, 16438u },
  { 17374u, 17621u, 16481u },
  { 17623u, 17995u, 16729u },
  { 17997u, 18016u, 17102u },
  { 18018u, 18210u, 17122u },
  { 18212u, 18216u, 17315u },
  { 18218u, 18299u, 17320u },
  { 18301u, 18316u, 17402u },
  { 18318u, 18758u, 17418u },
  { 18760u, 18809u, 17859u },
  { 18811u, 18812u, 17909u },
  { 18814u, 18817u, 17911u },
  { 18820u, 18820u, 17915u },
  { 18823u, 18842u, 17916u },
  { 18844u, 18846u, 17936u },
  { 18848u, 18869u, 17939u },
  { 18872u, 19574u, 17961u },
  { 19576u, 19614u, 18664u },
  { 19620u, 19730u, 18703u },
  { 19738u, 19885u, 18814u },
  { 19887u, 19967u, 18962u },
  { 40870u, 55294u, 19043u },
  { 59244u, 59244u, 33469u },
  { 59336u, 59336u, 33470u },
  { 59367u, 59379u, 33471u },
  { 59413u, 59413u, 33484u },
  { 59417u, 59421u, 33485u },
  { 59423u, 59429u, 33490u },
  { 59431u, 59434u, 33497u },
  { 59437u, 59440u, 33501u },
  { 59443u, 59450u, 33505u },
  { 59452u, 59458u, 33513u },
  { 59460u, 59475u, 33520u },
  { 59478u, 59491u, 33536u },
  { 59493u, 63787u, 33550u },
  { 63789u, 63864u, 37845u },
  { 63866u, 63892u, 37921u },
  { 63894u, 63974u, 37948u },
  { 63976u, 63984u, 38029u },
  { 63986u, 64011u, 38038u },
  { 64016u, 64016u, 38064u },
  { 64018u, 64018u, 38065u },
  { 64021u, 64023u, 38066u },
  { 64025u, 64030u, 38069u },
  { 64034u, 64034u, 38075u },
  { 64037u, 64038u, 38076u },
  { 64042u, 65071u, 38078u },
  { 65074u, 65074u, 39108u },
  { 65093u, 65096u, 39109u },
  { 65107u, 65107u, 39113u },
  { 65112u, 65112u, 39114u },
  { 65127u, 65127u, 39115u },
  { 65132u, 65280u, 39116u },
  { 65375u, 65503u, 39265u },
  { 65510u, 65535u, 39394u }
}; // idb
wc_uint8 WC_GB18030_MAP[256] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  0u,
  4u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  2u
}; // idb
wc_map gb2312_gbk_map[7] =
{
  { 41633u, 41642u },
  { 42720u, 42731u },
  { 42734u, 42738u },
  { 42740u, 42741u },
  { 43195u, 43195u },
  { 43197u, 43198u },
  { 43200u, 43200u }
}; // idb
wc_uint8 WC_GBK_MAP[256] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  0u,
  20u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  2u
}; // idb
wc_uint8 WC_HKSCS_MAP[256] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  4u,
  0u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  16u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  12u,
  2u
}; // idb
int gpm_handler; // weak
FILE *stderr; // idb
int gpm_zerobased; // weak
char byte_817C201; // weak
int gpm_arg; // weak
int gpm_consolefd; // idb
FILE *stdin; // idb
FILE *stdout; // idb
char completed_7065; // weak
int dtor_idx_7067; // weak
char SearchHeader[4]; // idb
char *DefaultType; // idb
char RenderFrame; // idb
char TargetSelf; // idb
char PermitSaveToPipe; // idb
char DecodeCTE; // idb
char AutoUncompress; // idb
char ArgvIsURL; // idb
char MetaRefresh; // idb
char fmInitialized; // idb
char QuietMessage[4]; // idb
char *HTTP_proxy; // idb
char *GOPHER_proxy; // idb
char *FTP_proxy; // idb
char *NO_proxy; // idb
int DNS_order; // idb
char NoCache[4]; // idb
int Do_not_use_ti_te; // idb
char *NNTP_server; // idb
char *NNTP_mode; // idb
char *document_root; // idb
char *personal_document_root; // idb
char *cgi_bin; // idb
char *index_file; // idb
int open_tab_blank; // idb
int open_tab_dl_list; // idb
int close_tab_back; // idb
DownloadList *FirstDL; // idb
DownloadList *LastDL; // idb
int w3m_dump; // idb
int w3m_halfload; // idb
Str header_string; // idb
int override_content_type; // idb
int useActiveColor; // idb
int useVisitedColor; // idb
int use_mark; // idb
int emacs_like_lineedit; // idb
int vi_prec_num; // idb
int label_topline; // idb
int nextpage_topline; // idb
char *displayTitleTerm; // idb
int displayLink; // idb
int displayLineInfo; // idb
int DecodeURL; // idb
int showLineNum; // idb
int activeImage; // idb
char *Mailer; // idb
char *ExtBrowser2; // idb
char *ExtBrowser3; // idb
int disable_secret_security_check; // idb
char *ftppasswd; // idb
int do_download; // idb
char *image_source; // idb
char *UserAgent; // idb
int NoSendReferer; // idb
char *AcceptLang; // idb
char *AcceptEncoding; // idb
char *AcceptMedia; // idb
int WrapDefault; // idb
int WrapSearch; // idb
int squeezeBlankLine; // idb
char *BookmarkFile; // idb
Str proxy_auth_cookie; // idb
int UseDictCommand; // idb
int FoldTextarea; // idb
int FoldLine; // idb
int DefaultURLString; // idb
int MarkAllPages; // idb
int use_migemo; // idb
int migemo_active; // idb
cookie *First_cookie; // idb
int multicolList; // idb
char ExtHalfdump; // idb
char SimplePreserveSpace; // idb
char UseGraphicChar[2]; // idb
int no_rc_dir; // idb
char *rc_dir; // idb
char *config_file; // idb
int reverse_mouse; // idb
int relative_wheel_scroll; // idb
int use_cookie; // idb
int accept_cookie; // idb
int accept_bad_cookie; // idb
char *cookie_reject_domains; // idb
char *cookie_accept_domains; // idb
int view_unseenobject; // idb
int is_redisplay; // idb
int set_pixel_per_char; // idb
int set_pixel_per_line; // idb
int use_lessopen; // idb
int w3m_backend; // idb
TextList *backend_batch_commands; // idb
int show_params_p; // idb
int prec_num; // idb
Event *CurrentEvent; // idb
Event *LastEvent; // idb
AlarmEvent DefaultAlarm; // idb
int need_resize_screen; // idb
char *MarkString; // idb
char *SearchString; // idb
int display_ok; // idb
int add_download_list; // idb
GC_warn_proc orig_GC_warn_proc; // idb
Buffer *prev_buf_17141; // idb
Line *prev_line_17142; // idb
int press_y_16575; // idb
int press_x_16574; // idb
Str s_15396; // idb
int offset_15399; // idb
Lineprop *p_15397; // idb
int n_15400; // idb
Str s_15239; // idb
int offset_15242; // idb
Lineprop *p_15240; // idb
int n_15243; // idb
Buffer sbuf_11060; // idb
Line *currentLine_11061; // idb
int pos_11062; // idb
int i_8929; // idb
int n_8930; // idb
wrap_GC_warn_proc::$DC0EE1D9CEAA20A895DBDA750A9BF6F1 msg_ring_8928[20]; // idb
int dword_817C524[39]; // idb
int lock_8931; // idb
auth_param none_auth_param[1]; // idb
int frame_source; // idb
sigjmp_buf AbortLoading; // idb
table *tables[20]; // idb
table_mode table_mode_0[20]; // idb
ParsedURL *cur_baseURL; // idb
char cur_document_charset[4]; // idb
Str cur_title; // idb
Str cur_select; // idb
Str select_str; // idb
int select_is_multiple; // idb
int n_selectitem; // idb
Str cur_option; // idb
Str cur_option_value; // idb
Str cur_option_label; // idb
int cur_option_selected; // idb
int cur_status; // idb
int n_select; // idb
int cur_option_maxwidth; // idb
Str cur_textarea; // idb
int cur_textarea_size; // idb
int cur_textarea_rows; // idb
int cur_textarea_readonly; // idb
int n_textarea; // idb
int ignore_nl_textarea; // idb
int http_response_code; // idb
wc_ces content_charset; // idb
wc_ces meta_charset; // idb
link_stack *link_stack_0; // idb
FormList **forms; // idb
int *form_stack; // idb
int forms_size; // idb
int form_sp; // idb
clen_t current_content_length; // idb
int cur_hseq; // idb
int cur_iseq; // idb
TextLineListItem *tl_lp2; // idb
InputStream file_lp2; // idb
sigjmp_buf env_bak_22032; // idb
time_t start_time_20349; // idb
time_t last_time_20348; // idb
int out_size_17965; // idb
char *outc_17963; // idb
Lineprop *outp_17964; // idb
int nredir_10889; // idb
int nredir_size_10890; // idb
ParsedURL *puv_10888; // idb
Str encodings_9174; // idb
char *path_9119; // idb
Lineprop NullProp[1]; // idb
Line *cline; // idb
int ulmode; // idb
int somode; // idb
int bomode; // idb
int anch_mode; // idb
int emph_mode; // idb
int imag_mode; // idb
int form_mode; // idb
int active_mode; // idb
int visited_mode; // idb
int mark_mode; // idb
int graph_mode; // idb
Linecolor color_mode; // idb
char *delayed_msg; // idb
int image_touch; // idb
int draw_image_flag; // idb
GeneralList *message_list; // idb
auth_pass *passwords; // idb
unsigned int tmpf_seq[5]; // idb
char *prevl_9601; // idb
int *realColumn_9599; // idb
int size_9600; // idb
int prop_size_9084; // idb
Lineprop *prop_buffer_9083; // idb
int color_size_9093; // idb
Linecolor *color_buffer_9092; // idb
FILE *migemor; // idb
FILE *migemow; // idb
int migemo_running; // idb
__pid_t migemo_pid; // idb
Str strBuf; // idb
Lineprop strProp[1024]; // idb
Str CompleteBuf; // idb
Str CFileName; // idb
Str CBeforeBuf; // idb
Str CAfterBuf; // idb
Str CDirBuf; // idb
char **CFileBuf; // idb
size_t NCFileBuf; // idb
int NCFileOffset; // idb
int CPos; // idb
int CLen; // idb
int offset; // idb
int i_cont; // idb
int i_broken; // idb
int i_quote; // idb
int cm_mode; // idb
int cm_next; // idb
int cm_clear; // idb
int cm_disp_next; // idb
int cm_disp_clear; // idb
int need_redraw; // idb
int is_passwd; // idb
int move_word; // idb
Hist *CurrentHist; // idb
Str strCurrentBuf; // idb
int use_hist; // idb
int col_9101; // idb
int row_9102; // idb
Str d_9104; // idb
int len_9103; // idb
int symbol_width; // idb
int symbol_width0; // idb
int visible_length_offset; // idb
Str Local_cookie; // idb
char *Local_cookie_file; // idb
pre_form *PreForm; // idb
frameset *renderFrameSet; // idb
sigjmp_buf AbortLoading_0; // idb
rc_search_table *RC_search_table; // idb
size_t RC_table_size; // idb
int OptionEncode; // idb
wc_ces_list *display_charset_str; // idb
wc_ces_list *document_charset_str; // idb
wc_ces_list *system_charset_str; // idb
Str optionpanel_str; // idb
int X_Mouse_Selection; // idb
char **FRAME; // idb
int FRAME_WIDTH; // idb
int graph_mode_0; // idb
Menu SelectMenu; // idb
int SelectV; // idb
Menu SelTabMenu; // idb
int SelTabV; // idb
Menu MainMenu; // idb
int MainMenuEncode; // idb
MenuList *w3mMenuList; // idb
Menu *CurrentMenu; // idb
char *SearchString_0; // idb
int press_y_8971; // idb
int press_x_8970; // idb
TextList *mailcap_list; // idb
mailcap **UserMailcap; // idb
Str types_8551; // idb
int image_index; // idb
TerminalImage *terminal_image; // idb
int n_terminal_image; // idb
int max_terminal_image; // idb
FILE *Imgdisplay_rf; // idb
FILE *Imgdisplay_wf; // idb
pid_t Imgdisplay_pid; // idb
int n_load_image; // idb
Hash_sv_0 *image_hash; // idb
Hash_sv_0 *image_file; // idb
GeneralList *image_list; // idb
ImageCache **image_cache; // idb
Buffer *image_buffer; // idb
char buf_8728[64]; // idb
char buf_8642[64]; // idb
wc_ces save_charset; // idb
symbol_set *save_symbol; // idb
char **symbol_buf_8077; // idb
int mouseActive; // idb
int is_xterm; // idb
char *title_str; // idb
TerminalMode d_ioval; // idb
FILE *ttyf; // idb
char byte_817E220[1024]; // idb
char funcstr[256]; // idb
int max_LINES; // idb
int max_COLS; // idb
int CurLine; // idb
int CurColumn; // idb
Screen *ScreenElem; // idb
Screen **ScreenImage; // idb
l_prop CurrentMode; // idb
int graph_enabled; // idb
char gcmap[96]; // idb
char seqbuf_9632[32]; // idb
char seqbuf_9607[32]; // idb
Str tmp_8815; // idb
sigjmp_buf AbortLoading_1; // idb
TextList *mimetypes_list; // idb
table2 **UserMimeTypes; // idb
table2 **urimethods; // idb
_FTP current_ftp; // idb
sigjmp_buf AbortLoading_2; // idb
Regex DefaultRegex; // idb
News current_news; // idb
sigjmp_buf AbortLoading_3; // idb
Hash_iv_0 *keyData; // idb
char keymap_initialized[28]; // idb
stat sys_current_keymap_file; // idb
stat current_keymap_file; // idb
wc_ces char_conv_f_ces; // idb
wc_status char_conv_st; // idb
wc_locale WcLocale; // idb
wc_ces_list *list; // idb
wc_uchar cs94_gmap[64]; // idb
wc_uchar cs94w_gmap[64]; // idb
wc_uchar cs96_gmap[64]; // idb
wc_uchar cs96w_gmap[64]; // idb
wc_uchar cs942_gmap[64]; // idb
Str os_4122; // idb
size_t nbuf_4124; // idb
wc_uchar buf_4123[4]; // idb
char byte_817FF09; // weak
char byte_817FF0A; // weak
wc_table *t_2393; // idb
wc_table *t1_2377; // idb
wc_table *t2_2378; // idb
Str os_2826; // idb
wc_uchar johabu_2827; // idb
wc_table *t_2389; // idb
wc_status putc_st; // idb
wc_ces putc_f_ces; // idb
wc_ces putc_t_ces; // idb
Str putc_str; // idb
Str os_3413; // idb
wc_uchar jis_3414[2]; // idb
Str os_3288; // idb
wc_uchar jis_3289[2]; // idb
wc_status output_st; // idb
wc_option output_option; // idb
wc_bool output_set; // idb
int n_tag_map; // idb
char *tag_map[256]; // idb
Str os_2735; // idb
wc_uchar uhcu_2736; // idb
Str os_2932; // idb
wc_uint32 high_2933; // idb
wc_uchar utf8_buf[7]; // idb
Str os_2857; // idb
size_t nbuf_2859; // idb
size_t next_2860; // idb
wc_uchar buf_2858[6]; // idb
wc_ccs wtf_gr_ccs; // idb
wc_status wtf_major_st; // idb
Str os_2633; // idb
wc_uchar big5u_2634; // idb
Str os_3152; // idb
wc_uchar gb_3153[4]; // idb
char byte_81804C9; // weak
char byte_81804CA; // weak
Str os_2832; // idb
wc_uchar gbku_2833; // idb
Str os_2724; // idb
wc_uchar hkscsu_2725; // idb
char *CurrentCmdData; // idb
TextList *Cookie_accept_domains; // idb
TabBuffer *FirstTab; // idb
ParsedURL GOPHER_proxy_parsed; // idb
Hist *LoadHist; // idb
TextLineList *backend_halfdump_buf; // idb
Hist *TextHist; // idb
char *w3m_reqlog; // idb
TextList *NO_proxy_domains; // idb
int (*searchRoutine)(Buffer *, char *); // idb
Hist *SaveHist; // idb
char *CurrentDir; // idb
ParsedURL FTP_proxy_parsed; // idb
sigjmp_buf IntReturn; // idb
Hist *ShellHist; // idb
ParsedURL HTTP_proxy_parsed; // idb
Hist *URLHist; // idb
char *tmp_dir; // idb
char *CurrentKeyData; // idb
MouseAction mouse_action; // idb
TextList *Cookie_reject_domains; // idb
TabBuffer *CurrentTab; // idb
TextList *fileToDelete; // idb
int nTab; // idb
int w3m_debug; // idb
int CurrentKey; // idb
int CurrentPid; // idb
TabBuffer *LastTab; // idb
Str *textarea_str; // idb
FormSelectOption *select_option; // idb
int (*menuSearchRoutine)(Menu *, char *, int); // idb
char *T_me; // idb
char *T_cd; // idb
char *T_cl; // idb
char *T_kr; // idb
char *T_ac; // idb
char *T_ce; // idb
char *T_op; // idb
char *T_as; // idb
char *T_cm; // idb
char *T_eA; // idb
char *T_se; // idb
char *T_al; // idb
char *T_ue; // idb
int LINES; // idb
char *T_rc; // idb
char *T_nd; // idb
char *T_sr; // idb
char *T_kl; // idb
int COLS; // idb
char *T_ta; // idb
char *T_ti; // idb
char *T_cr; // idb
char *T_ae; // idb
char *T_te; // idb
char *T_md; // idb
char *T_so; // idb
char *T_sc; // idb
char *T_us; // idb
// extern _UNKNOWN _gmon_start__; weak


//----- (08049BFC) --------------------------------------------------------
int init_proc()
{
  int v1; // [esp+0h] [ebp-8h]

  if ( &_gmon_start__ )
    __gmon_start__();
  frame_dummy();
  _do_global_ctors_aux();
  return v1;
}
// 8049C28: variable 'v1' is possibly undefined
// 8049D9C: using guessed type int __gmon_start__(void);

//----- (08049C2C) --------------------------------------------------------
int sub_8049C2C()
{
  return dword_80D4FFC();
}
// 80D4FFC: using guessed type int (*dword_80D4FFC)(void);

//----- (0804A620) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall __noreturn start(int a1@<eax>, void (*a2)(void)@<edx>)
{
  int v2; // esi
  int v3; // [esp-4h] [ebp-4h] BYREF
  char *retaddr; // [esp+0h] [ebp+0h] BYREF

  v2 = v3;
  v3 = a1;
  __libc_start_main((int (__cdecl *)(int, char **, char **))main, v2, &retaddr, _libc_csu_init, _libc_csu_fini, a2, &v3);
  __halt();
}
// 804A623: positive sp value 4 has been found

//----- (0804A650) --------------------------------------------------------
void _do_global_dtors_aux()
{
  int v0; // eax
  unsigned int i; // ebx

  if ( !completed_7065 )
  {
    v0 = dtor_idx_7067;
    for ( i = &_DTOR_END__ - _DTOR_LIST__ - 1; dtor_idx_7067 < i; v0 = dtor_idx_7067 )
    {
      dtor_idx_7067 = v0 + 1;
      ((void (*)(void))_DTOR_LIST__[v0 + 1])();
    }
    completed_7065 = 1;
  }
}
// 80D4EEC: using guessed type int _DTOR_LIST__[];
// 80D4EF0: using guessed type int _DTOR_END__;
// 817C224: using guessed type char completed_7065;
// 817C228: using guessed type int dtor_idx_7067;

//----- (0804A6B0) --------------------------------------------------------
int frame_dummy()
{
  int result; // eax

  result = _JCR_LIST__;
  if ( _JCR_LIST__ )
    result = 0;
  return result;
}
// 80D4EF4: using guessed type int _JCR_LIST__;

//----- (0804A6D4) --------------------------------------------------------
void __cdecl fversion(FILE *f)
{
  fprintf(
    f,
    "w3m version %s, options %s\n",
    w3m_version,
    "lang=en,m17n,image,color,ansi-color,mouse,gpm,menu,cookie,external-uri-loader,w3mmailer,nntp,gopher,ipv6,alarm,mark,migemo");
}

//----- (0804A702) --------------------------------------------------------
void __cdecl __noreturn fusage(FILE *f, int err)
{
  fversion(f);
  fwrite("usage: w3m [options] [URL or filename]\noptions:\n", 1u, 0x30u, f);
  fwrite("    -t tab           set tab width\n", 1u, 0x23u, f);
  fwrite("    -r               ignore backspace effect\n", 1u, 0x2Du, f);
  fwrite("    -l line          # of preserved line (default 10000)\n", 1u, 0x39u, f);
  fwrite("    -I charset       document charset\n", 1u, 0x26u, f);
  fwrite("    -O charset       display/output charset\n", 1u, 0x2Cu, f);
  fwrite("    -B               load bookmark\n", 1u, 0x23u, f);
  fwrite("    -bookmark file   specify bookmark file\n", 1u, 0x2Bu, f);
  fwrite("    -T type          specify content-type\n", 1u, 0x2Au, f);
  fwrite("    -m               internet message mode\n", 1u, 0x2Bu, f);
  fwrite("    -v               visual startup mode\n", 1u, 0x29u, f);
  fwrite("    -M               monochrome display\n", 1u, 0x28u, f);
  fwrite("    -N               open URL of command line on each new tab\n", 1u, 0x3Eu, f);
  fwrite("    -F               automatically render frame\n", 1u, 0x30u, f);
  fwrite("    -cols width      specify column width (used with -dump)\n", 1u, 0x3Cu, f);
  fwrite("    -ppc count       specify the number of pixels per character (4.0...32.0)\n", 1u, 0x4Du, f);
  fwrite("    -ppl count       specify the number of pixels per line (4.0...64.0)\n", 1u, 0x48u, f);
  fwrite("    -dump            dump formatted page into stdout\n", 1u, 0x35u, f);
  fwrite("    -dump_head       dump response of HEAD request into stdout\n", 1u, 0x3Fu, f);
  fwrite("    -dump_source     dump page source into stdout\n", 1u, 0x32u, f);
  fwrite("    -dump_both       dump HEAD and source into stdout\n", 1u, 0x36u, f);
  fwrite("    -dump_extra      dump HEAD, source, and extra information into stdout\n", 1u, 0x4Au, f);
  fwrite("    -post file       use POST method with file content\n", 1u, 0x37u, f);
  fwrite("    -header string   insert string as a header\n", 1u, 0x2Fu, f);
  fwrite("    +<num>           goto <num> line\n", 1u, 0x25u, f);
  fwrite("    -num             show line number\n", 1u, 0x26u, f);
  fwrite("    -no-proxy        don't use proxy\n", 1u, 0x25u, f);
  fwrite("    -4               IPv4 only (-o dns_order=4)\n", 1u, 0x30u, f);
  fwrite("    -6               IPv6 only (-o dns_order=6)\n", 1u, 0x30u, f);
  fwrite("    -no-mouse        don't use mouse\n", 1u, 0x25u, f);
  fwrite("    -cookie          use cookie (-no-cookie: don't use cookie)\n", 1u, 0x3Fu, f);
  fwrite("    -pauth user:pass proxy authentication\n", 1u, 0x2Au, f);
  fwrite("    -graph           use graphic character\n", 1u, 0x2Bu, f);
  fwrite("    -no-graph        don't use graphic character\n", 1u, 0x31u, f);
  fwrite("    -s               squeeze multiple blank lines\n", 1u, 0x32u, f);
  fwrite("    -W               toggle wrap search mode\n", 1u, 0x2Du, f);
  fwrite("    -X               don't use termcap init/deinit\n", 1u, 0x33u, f);
  fwrite("    -title[=TERM]    set buffer name to terminal title string\n", 1u, 0x3Eu, f);
  fwrite("    -o opt=value     assign value to config option\n", 1u, 0x33u, f);
  fwrite("    -show-option     print all config options\n", 1u, 0x2Eu, f);
  fwrite("    -config file     specify config file\n", 1u, 0x29u, f);
  fwrite("    -help            print this usage message\n", 1u, 0x2Eu, f);
  fwrite("    -version         print w3m version\n", 1u, 0x27u, f);
  fwrite("    -reqlog          write request logfile\n", 1u, 0x2Bu, f);
  fwrite("    -debug           DO NOT USE\n", 1u, 0x20u, f);
  if ( show_params_p )
    show_params(f);
  exit(err);
}

//----- (0804AD86) --------------------------------------------------------
void __cdecl wrap_GC_warn_proc(char *msg, GC_word arg)
{
  int j; // [esp+1Ch] [ebp-Ch]

  if ( fmInitialized )
  {
    j = (i_8929 + n_8930) % 0x14u;
    msg_ring_8928[j].msg = msg;
    dword_817C524[2 * j] = arg;
    if ( (unsigned int)n_8930 > 0x13 )
      ++i_8929;
    else
      ++n_8930;
    if ( !lock_8931 )
    {
      lock_8931 = 1;
      while ( n_8930 > 0 )
      {
        i_8929 %= 0x14u;
        printf(msg_ring_8928[i_8929].msg, dword_817C524[2 * i_8929]);
        sleep_till_anykey(1, 1);
        --n_8930;
        ++i_8929;
      }
      lock_8931 = 0;
    }
  }
  else if ( orig_GC_warn_proc )
  {
    orig_GC_warn_proc(msg, arg);
  }
  else
  {
    fprintf(stderr, msg, arg);
  }
}

//----- (0804AEF1) --------------------------------------------------------
void __cdecl sig_chld(int signo)
{
  int p_stat[3]; // [esp+1Ch] [ebp-Ch] BYREF

  while ( waitpid(-1, p_stat, 1) > 0 )
    ;
  mySignal(17, sig_chld);
}

//----- (0804AF31) --------------------------------------------------------
Str __cdecl make_optional_header_string(char *s)
{
  size_t v2; // eax
  _Str *hs; // [esp+18h] [ebp-10h]
  char *p; // [esp+1Ch] [ebp-Ch]
  char *pa; // [esp+1Ch] [ebp-Ch]

  if ( strchr(s, 10) || strchr(s, 13) )
    return 0;
  for ( p = s; *p && *p != 58; ++p )
    ;
  if ( *p != 58 || p == s )
    return 0;
  v2 = strlen(s);
  hs = Strnew_size(v2 + 3);
  Strcopy_charp_n(hs, s, p - s);
  if ( !strcasecmp(hs->ptr, "content-type") )
    override_content_type = 1;
  Strcat_charp(hs, ": ");
  pa = p + 1;
  if ( *pa )
  {
    while ( *pa && (MYCTYPE_MAP[(unsigned __int8)*pa] & 2) != 0 )
      ++pa;
    Strcat_charp(hs, pa);
  }
  Strcat_charp(hs, "\r\n");
  return hs;
}

//----- (0804B07E) --------------------------------------------------------
int __cdecl __noreturn main(int argc, const char **argv, const char **envp)
{
  int v3; // eax
  char *v4; // eax
  Str v5; // eax
  Str v6; // eax
  int v7; // eax
  FILE *v8; // eax
  Str v9; // eax
  int v10; // eax
  wc_ces v11; // esi
  wc_ces v12; // ebx
  _Str *v13; // eax
  Str v14; // eax
  Str v15; // eax
  TabBuffer *v16; // edx
  TabBuffer *v17; // eax
  TabBuffer *v18; // esi
  TabBuffer *v19; // ebx
  int v20; // eax
  int v21; // eax
  _Str *v22; // [esp+4h] [ebp-9Ch]
  _Str *v23; // [esp+4h] [ebp-9Ch]
  _Str *v24; // [esp+4h] [ebp-9Ch]
  double v25; // [esp+28h] [ebp-78h]
  double v26; // [esp+30h] [ebp-70h]
  Anchor *v27; // [esp+38h] [ebp-68h]
  Str v28; // [esp+3Ch] [ebp-64h]
  FILE *v29; // [esp+40h] [ebp-60h]
  _Str *v30; // [esp+44h] [ebp-5Ch]
  _Str *v31; // [esp+48h] [ebp-58h]
  Str v32; // [esp+4Ch] [ebp-54h]
  char *v33; // [esp+50h] [ebp-50h]
  Str v34; // [esp+54h] [ebp-4Ch]
  const char *v35; // [esp+58h] [ebp-48h]
  char *v36; // [esp+5Ch] [ebp-44h]
  int v37; // [esp+60h] [ebp-40h]
  int v38; // [esp+64h] [ebp-3Ch]
  int v39; // [esp+68h] [ebp-38h]
  int v40; // [esp+6Ch] [ebp-34h]
  FormList *v41; // [esp+70h] [ebp-30h]
  form_list *v42; // [esp+70h] [ebp-30h]
  int v43; // [esp+74h] [ebp-2Ch]
  char *v44; // [esp+78h] [ebp-28h]
  input_stream *v45; // [esp+7Ch] [ebp-24h]
  int i; // [esp+80h] [ebp-20h]
  int j; // [esp+80h] [ebp-20h]
  int v48; // [esp+80h] [ebp-20h]
  char *v49; // [esp+84h] [ebp-1Ch]
  char *v50; // [esp+84h] [ebp-1Ch]
  char *v51; // [esp+84h] [ebp-1Ch]
  char *v52; // [esp+84h] [ebp-1Ch]
  char *v53; // [esp+84h] [ebp-1Ch]
  char *v54; // [esp+84h] [ebp-1Ch]
  char *v55; // [esp+84h] [ebp-1Ch]
  char *v56; // [esp+84h] [ebp-1Ch]
  char *v57; // [esp+84h] [ebp-1Ch]
  char *v58; // [esp+84h] [ebp-1Ch]
  char *v59; // [esp+84h] [ebp-1Ch]
  Buffer *v60; // [esp+88h] [ebp-18h]
  wc_uint8 v61; // [esp+8Dh] [ebp-13h]
  char v62; // [esp+8Eh] [ebp-12h]
  char v63; // [esp+8Fh] [ebp-11h]

  v60 = 0;
  v44 = 0;
  v39 = 0;
  v38 = 0;
  v37 = 0;
  v62 = 0;
  v36 = 0;
  v35 = 0;
  setlocale(6, &def_str);
  bindtextdomain("w3m", "/usr/share/locale");
  textdomain("w3m");
  NO_proxy_domains = (TextList *)newGeneralList();
  fileToDelete = (TextList *)newGeneralList();
  v43 = GC_malloc(4 * (argc - 1));
  v40 = 0;
  CurrentDir = currentdir();
  CurrentPid = getpid();
  BookmarkFile = 0;
  config_file = 0;
  for ( i = 1; i < argc; ++i )
  {
    if ( *argv[i] == 45 )
    {
      if ( !strcmp("-config", argv[i]) )
      {
        argv[i++] = "-dummy";
        if ( i >= argc )
          fusage(stderr, 1);
        config_file = (char *)argv[i];
        argv[i] = "-dummy";
      }
      else
      {
        if ( !strcmp("-h", argv[i]) || !strcmp("-help", argv[i]) )
          fusage(stdout, 0);
        if ( !strcmp("-V", argv[i]) || !strcmp("-version", argv[i]) )
        {
          fversion(stdout);
          exit(0);
        }
      }
    }
  }
  v33 = getenv("LC_ALL");
  if ( non_null(v33) || (v33 = getenv("LC_CTYPE"), non_null(v33)) || (v33 = getenv("LANG"), non_null(v33)) )
  {
    DisplayCharset = wc_guess_locale_charset(v33, DisplayCharset);
    DocumentCharset = wc_guess_locale_charset(v33, DocumentCharset);
    SystemCharset = wc_guess_locale_charset(v33, SystemCharset);
  }
  init_rc();
  LoadHist = newHist();
  SaveHist = newHist();
  ShellHist = newHist();
  TextHist = newHist();
  URLHist = newHist();
  if ( FollowLocale && v33 )
  {
    DisplayCharset = wc_guess_locale_charset(v33, DisplayCharset);
    SystemCharset = wc_guess_locale_charset(v33, SystemCharset);
  }
  v61 = WcOption.auto_detect;
  BookmarkCharset = DocumentCharset;
  if ( !non_null(HTTP_proxy) )
  {
    v49 = getenv("HTTP_PROXY");
    if ( v49 || (v49 = getenv("http_proxy")) != 0 || (v49 = getenv("HTTP_proxy")) != 0 )
      HTTP_proxy = v49;
  }
  if ( !non_null(GOPHER_proxy) )
  {
    v50 = getenv("GOPHER_PROXY");
    if ( v50 || (v50 = getenv("gopher_proxy")) != 0 || (v50 = getenv("GOPHER_proxy")) != 0 )
      GOPHER_proxy = v50;
  }
  if ( !non_null(FTP_proxy) )
  {
    v51 = getenv("FTP_PROXY");
    if ( v51 || (v51 = getenv("ftp_proxy")) != 0 || (v51 = getenv("FTP_proxy")) != 0 )
      FTP_proxy = v51;
  }
  if ( !non_null(NO_proxy) )
  {
    v52 = getenv("NO_PROXY");
    if ( v52 || (v52 = getenv("no_proxy")) != 0 || (v52 = getenv("NO_proxy")) != 0 )
      NO_proxy = v52;
  }
  if ( !non_null(NNTP_server) )
  {
    v53 = getenv("NNTPSERVER");
    if ( v53 )
      NNTP_server = v53;
  }
  if ( !non_null(NNTP_mode) )
  {
    v54 = getenv("NNTPMODE");
    if ( v54 )
      NNTP_mode = v54;
  }
  if ( !non_null(Editor) )
  {
    v55 = getenv("EDITOR");
    if ( v55 )
      Editor = v55;
  }
  if ( !non_null(Mailer) )
  {
    v56 = getenv("MAILER");
    if ( v56 )
      Mailer = v56;
  }
  for ( j = 1; j < argc; ++j )
  {
    if ( *argv[j] == 45 )
    {
      if ( !strcmp("-t", argv[j]) )
      {
        if ( ++j >= argc )
          fusage(stderr, 1);
        if ( atoi(argv[j]) > 0 )
          Tabstop = atoi(argv[j]);
      }
      else if ( !strcmp("-r", argv[j]) )
      {
        ShowEffect = 0;
      }
      else if ( !strcmp("-l", argv[j]) )
      {
        if ( ++j >= argc )
          fusage(stderr, 1);
        if ( atoi(argv[j]) > 0 )
          PagerMax = atoi(argv[j]);
      }
      else if ( !strncmp("-I", argv[j], 2u) )
      {
        if ( argv[j][2] )
        {
          v57 = (char *)(argv[j] + 2);
        }
        else
        {
          if ( ++j >= argc )
            fusage(stderr, 1);
          v57 = (char *)argv[j];
        }
        DocumentCharset = wc_guess_charset_short(v57, DocumentCharset);
        WcOption.auto_detect = 0;
        UseContentCharset = 0;
      }
      else if ( !strncmp("-O", argv[j], 2u) )
      {
        if ( argv[j][2] )
        {
          v58 = (char *)(argv[j] + 2);
        }
        else
        {
          if ( ++j >= argc )
            fusage(stderr, 1);
          v58 = (char *)argv[j];
        }
        DisplayCharset = wc_guess_charset_short(v58, DisplayCharset);
      }
      else if ( !strcmp("-graph", argv[j]) )
      {
        UseGraphicChar[0] = 1;
      }
      else if ( !strcmp("-no-graph", argv[j]) )
      {
        UseGraphicChar[0] = 0;
      }
      else if ( !strcmp("-T", argv[j]) )
      {
        if ( ++j >= argc )
          fusage(stderr, 1);
        v36 = (char *)argv[j];
        DefaultType = v36;
      }
      else if ( !strcmp("-m", argv[j]) )
      {
        v62 = 1;
        SearchHeader[0] = 1;
      }
      else if ( !strcmp("-v", argv[j]) )
      {
        v38 = 1;
      }
      else if ( !strcmp("-N", argv[j]) )
      {
        v37 = 1;
      }
      else if ( !strcmp("-M", argv[j]) )
      {
        useColor = 0;
      }
      else if ( !strcmp("-B", argv[j]) )
      {
        v39 = 1;
      }
      else if ( !strcmp("-bookmark", argv[j]) )
      {
        if ( ++j >= argc )
          fusage(stderr, 1);
        BookmarkFile = (char *)argv[j];
        if ( *BookmarkFile != 126 && *BookmarkFile != 47 )
        {
          v32 = Strnew_charp(CurrentDir);
          if ( v32->length <= 0 || v32->ptr[v32->length - 1] != 47 )
          {
            if ( v32->length + 1 >= v32->area_size )
              Strgrow(v32);
            v3 = v32->length;
            v32->ptr[v3] = 47;
            v32->length = v3 + 1;
            v32->ptr[v32->length] = 0;
          }
          Strcat_charp(v32, BookmarkFile);
          BookmarkFile = cleanupName(v32->ptr);
        }
      }
      else if ( !strcmp("-F", argv[j]) )
      {
        RenderFrame = 1;
      }
      else if ( !strcmp("-W", argv[j]) )
      {
        WrapDefault = WrapDefault == 0;
      }
      else if ( !strcmp("-dump", argv[j]) )
      {
        w3m_dump = 1;
      }
      else if ( !strcmp("-dump_source", argv[j]) )
      {
        w3m_dump = 4;
      }
      else if ( !strcmp("-dump_head", argv[j]) )
      {
        w3m_dump = 2;
      }
      else if ( !strcmp("-dump_both", argv[j]) )
      {
        w3m_dump = 6;
      }
      else if ( !strcmp("-dump_extra", argv[j]) )
      {
        w3m_dump = 14;
      }
      else if ( !strcmp("-halfdump", argv[j]) )
      {
        w3m_dump = 16;
      }
      else if ( !strcmp("-halfload", argv[j]) )
      {
        w3m_dump = 0;
        w3m_halfload = 1;
        v36 = "text/html";
        DefaultType = "text/html";
      }
      else if ( !strcmp("-backend", argv[j]) )
      {
        w3m_backend = 1;
      }
      else if ( !strcmp("-backend_batch", argv[j]) )
      {
        w3m_backend = 1;
        if ( ++j >= argc )
          fusage(stderr, 1);
        if ( !backend_batch_commands )
          backend_batch_commands = (TextList *)newGeneralList();
        v4 = allocStr(argv[j], -1);
        pushValue((GeneralList *)backend_batch_commands, v4);
      }
      else if ( !strcmp("-cols", argv[j]) )
      {
        if ( ++j >= argc )
          fusage(stderr, 1);
        COLS = atoi(argv[j]);
      }
      else if ( !strcmp("-ppc", argv[j]) )
      {
        if ( ++j >= argc )
          fusage(stderr, 1);
        v26 = atof(argv[j]);
        if ( v26 >= 4.0 && v26 <= 32.0 )
        {
          pixel_per_char = v26;
          set_pixel_per_char = 1;
        }
      }
      else if ( !strcmp("-ppl", argv[j]) )
      {
        if ( ++j >= argc )
          fusage(stderr, 1);
        v25 = atof(argv[j]);
        if ( v25 >= 4.0 && v25 <= 64.0 )
        {
          pixel_per_line = v25;
          set_pixel_per_line = 1;
        }
      }
      else if ( !strcmp("-num", argv[j]) )
      {
        showLineNum = 1;
      }
      else if ( !strcmp("-no-proxy", argv[j]) )
      {
        use_proxy = 0;
      }
      else if ( !strcmp("-4", argv[j]) || !strcmp("-6", argv[j]) )
      {
        v5 = Sprintf("dns_order=%c", argv[j][1]);
        set_param_option(v5->ptr);
      }
      else if ( !strcmp("-post", argv[j]) )
      {
        if ( ++j >= argc )
          fusage(stderr, 1);
        v35 = argv[j];
      }
      else if ( !strcmp("-header", argv[j]) )
      {
        if ( ++j >= argc )
          fusage(stderr, 1);
        v31 = make_optional_header_string((char *)argv[j]);
        if ( v31 )
        {
          if ( header_string )
            savexmlstr_0(header_string, v31);
          else
            header_string = v31;
        }
        while ( *argv[j] )
          *argv[j]++ = 0;
      }
      else if ( !strcmp("-no-mouse", argv[j]) )
      {
        use_mouse = 0;
      }
      else if ( !strcmp("-no-cookie", argv[j]) )
      {
        use_cookie = 0;
        accept_cookie = 0;
      }
      else if ( !strcmp("-cookie", argv[j]) )
      {
        use_cookie = 1;
        accept_cookie = 1;
      }
      else if ( !strcmp("-pauth", argv[j]) )
      {
        if ( ++j >= argc )
          fusage(stderr, 1);
        v6 = encodeB((char *)argv[j]);
        proxy_auth_cookie = Strnew_m_charp("Basic ", v6->ptr, 0);
        while ( *argv[j] )
          *argv[j]++ = 0;
      }
      else if ( !strcmp("-s", argv[j]) )
      {
        squeezeBlankLine = 1;
      }
      else if ( !strcmp("-X", argv[j]) )
      {
        Do_not_use_ti_te = 1;
      }
      else if ( !strcmp("-title", argv[j]) )
      {
        displayTitleTerm = getenv("TERM");
      }
      else if ( !strncmp("-title=", argv[j], 7u) )
      {
        displayTitleTerm = (char *)(argv[j] + 7);
      }
      else if ( !strcmp("-o", argv[j]) || !strcmp("-show-option", argv[j]) )
      {
        if ( !strcmp("-show-option", argv[j]) || (++j, j >= argc) || !strcmp(argv[j], "?") )
        {
          show_params(stdout);
          exit(0);
        }
        if ( !set_param_option((char *)argv[j]) )
        {
          fprintf(stderr, "%s: bad option\n", argv[j]);
          show_params_p = 1;
          fusage(stderr, 1);
        }
      }
      else if ( strcmp("-dummy", argv[j]) )
      {
        if ( !strcmp("-debug", argv[j]) )
        {
          w3m_debug = 1;
        }
        else
        {
          if ( strcmp("-reqlog", argv[j]) )
            fusage(stderr, 1);
          w3m_reqlog = rcFile("request.log");
        }
      }
    }
    else if ( *argv[j] == 43 )
    {
      v44 = (char *)(argv[j] + 1);
    }
    else
    {
      *(_DWORD *)(v43 + 4 * v40++) = argv[j];
    }
  }
  FirstTab = 0;
  LastTab = 0;
  nTab = 0;
  CurrentTab = 0;
  CurrentKey = -1;
  if ( !BookmarkFile )
    BookmarkFile = rcFile("bookmark.html");
  if ( !isatty(1) && !w3m_dump )
    w3m_dump = 1;
  if ( w3m_dump && !COLS )
    COLS = 80;
  if ( w3m_dump || w3m_backend )
  {
    if ( (w3m_dump & 0x10) != 0 && displayImage )
      activeImage = 1;
  }
  else
  {
    fmInit();
    mySignal(28, resize_hook);
  }
  sync_with_option();
  initCookie();
  if ( UseHistory )
    loadHistory(URLHist);
  wtf_init(DocumentCharset, DisplayCharset);
  if ( w3m_backend )
    backend();
  if ( w3m_dump )
    mySignal(2, (void (*)(int))1);
  mySignal(17, sig_chld);
  mySignal(13, SigPipe);
  orig_GC_warn_proc = (GC_warn_proc)GC_set_warn_proc(wrap_GC_warn_proc);
  v34 = Strnew();
  if ( v40 )
  {
    v48 = 0;
  }
  else
  {
    if ( isatty(0) )
    {
      if ( v39 )
      {
        v60 = loadGeneralFile(BookmarkFile, 0, (char *)0xFFFFFFFF, 0, 0);
        if ( !v60 )
          Strcat_charp(v34, "w3m: Can't load bookmark.\n");
      }
      else if ( v38 )
      {
        v30 = Strnew_charp("<title>W3M startup page</title><center><b>Welcome to ");
        Strcat_charp(v30, "<a href='http://w3m.sourceforge.net/'>");
        Strcat_m_charp(
          v30,
          "w3m</a>!<p><p>This is w3m version ",
          w3m_version,
          "<br>Written by <a href='mailto:aito@fw.ipsj.or.jp'>Akinori Ito</a>",
          0);
        Strcat_m_charp(
          v30,
          "<p>Debian package is maintained by <a href='mailto:ukai@debian.or.jp'>Fumitoshi UKAI</a>.",
          "You can read <a href='file:///usr/share/doc/w3m/'>w3m documents on your local system</a>.",
          0);
        v60 = loadHTMLString(v30);
        if ( v60 )
        {
          if ( v60 != (Buffer *)1 )
            v60->bufferprop |= 0x18u;
        }
        else
        {
          Strcat_charp(v34, "w3m: Can't load string.\n");
        }
      }
      else
      {
        v59 = getenv("HTTP_HOME");
        if ( !v59 )
        {
          v59 = getenv("WWW_HOME");
          if ( !v59 )
          {
            if ( fmInitialized )
              fmTerm();
            fusage(stderr, 1);
          }
        }
        v60 = loadGeneralFile(v59, 0, (char *)0xFFFFFFFF, 0, 0);
        if ( v60 )
        {
          if ( v60 != (Buffer *)1 )
          {
            v9 = parsedURL2Str(&v60->currentURL);
            pushHashHist(URLHist, v9->ptr);
          }
        }
        else
        {
          v22 = Sprintf("w3m: Can't load %s.\n", v59);
          savexmlstr_0(v34, v22);
        }
      }
    }
    else
    {
      v7 = dup(0);
      v8 = fdopen(v7, "rb");
      v45 = newFileStream(v8, (void (*)(...))pclose);
      v60 = openGeneralPagerBuffer(v45);
      dup2(1, 0);
    }
    if ( !v60 )
    {
      if ( fmInitialized )
        fmTerm();
      if ( v34->length )
        fputs(v34->ptr, stderr);
      w3m_exit(2);
    }
    v48 = -1;
  }
  while ( 1 )
  {
    if ( v48 >= v40 )
    {
      if ( w3m_dump )
      {
        if ( v34->length )
          fputs(v34->ptr, stderr);
        save_cookies();
        w3m_exit(0);
      }
      if ( add_download_list )
      {
        add_download_list = 0;
        CurrentTab = LastTab;
        if ( !FirstTab )
        {
          CurrentTab = newTab();
          LastTab = CurrentTab;
          FirstTab = CurrentTab;
          nTab = 1;
        }
        if ( CurrentTab->firstBuffer && CurrentTab->firstBuffer != (Buffer *)1 )
        {
          CurrentTab->currentBuffer = CurrentTab->firstBuffer;
        }
        else
        {
          v18 = CurrentTab;
          v19 = CurrentTab;
          if ( showLineNum )
            v20 = 6;
          else
            v20 = 1;
          v21 = COLS - v20;
          if ( v21 < 0 )
            v21 = 0;
          v19->currentBuffer = newBuffer(v21);
          v18->firstBuffer = v19->currentBuffer;
          CurrentTab->currentBuffer->bufferprop = 24;
          CurrentTab->currentBuffer->buffername = "Download List Panel";
        }
        ldDL();
      }
      else
      {
        CurrentTab = FirstTab;
      }
      if ( !FirstTab || !CurrentTab->firstBuffer || CurrentTab->firstBuffer == (Buffer *)1 )
      {
        if ( v60 == (Buffer *)1 && fmInitialized )
          inputLineHistSearch("Hit any key to quit w3m:", (char *)&def_str, 512, 0, 0);
        if ( fmInitialized )
          fmTerm();
        if ( v34->length )
          fputs(v34->ptr, stderr);
        if ( v60 == (Buffer *)1 )
        {
          save_cookies();
          if ( !v34->length )
            w3m_exit(0);
        }
        w3m_exit(2);
      }
      if ( v34->length )
        disp_message_nsec(v34->ptr, 0, 1, 1, 0);
      SearchHeader[0] = 0;
      DefaultType = 0;
      UseContentCharset = 1;
      WcOption.auto_detect = v61;
      CurrentTab->currentBuffer = CurrentTab->firstBuffer;
      displayBuffer(CurrentTab->currentBuffer, 1);
      if ( v44 )
        goLine(v44);
      while ( 1 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
LABEL_344:
            if ( add_download_list )
            {
              add_download_list = 0;
              ldDL();
            }
            if ( !CurrentTab->currentBuffer->submit )
              break;
            v27 = CurrentTab->currentBuffer->submit;
            CurrentTab->currentBuffer->submit = 0;
            gotoLine(CurrentTab->currentBuffer, v27->start.line);
            CurrentTab->currentBuffer->pos = v27->start.pos;
            followForm(1);
          }
          if ( !CurrentEvent )
            break;
          CurrentKey = -1;
          CurrentKeyData = 0;
          CurrentCmdData = (char *)CurrentEvent->data;
          w3mFuncList[CurrentEvent->cmd].func();
          CurrentCmdData = 0;
          CurrentEvent = CurrentEvent->next;
        }
        if ( CurrentTab->currentBuffer->event )
        {
          if ( CurrentTab->currentBuffer->event->status )
          {
            CurrentAlarm = CurrentTab->currentBuffer->event;
            if ( !CurrentAlarm->sec )
            {
              CurrentTab->currentBuffer->event = 0;
              CurrentKey = -1;
              CurrentKeyData = 0;
              CurrentCmdData = (char *)CurrentAlarm->data;
              w3mFuncList[CurrentAlarm->cmd].func();
              CurrentCmdData = 0;
              goto LABEL_344;
            }
          }
          else
          {
            CurrentTab->currentBuffer->event = 0;
          }
        }
        if ( !CurrentTab->currentBuffer->event )
          CurrentAlarm = &DefaultAlarm;
        mouse_action.in_action = 0;
        if ( use_mouse )
          mouse_active();
        if ( CurrentAlarm->sec > 0 )
        {
          mySignal(14, SigAlarm);
          alarm(CurrentAlarm->sec);
        }
        mySignal(28, resize_hook);
        if ( activeImage && displayImage && CurrentTab->currentBuffer->img && !CurrentTab->currentBuffer->image_loaded )
        {
          do
          {
            if ( need_resize_screen )
              resize_screen();
            loadImage(CurrentTab->currentBuffer, 2);
          }
          while ( sleep_till_anykey(1, 0) <= 0 );
        }
        else
        {
          do
          {
            if ( need_resize_screen )
              resize_screen();
          }
          while ( sleep_till_anykey(1, 0) <= 0 );
        }
        v63 = do_getch();
        if ( CurrentAlarm->sec > 0 )
          alarm(0);
        if ( use_mouse )
          mouse_inactive();
        if ( (MYCTYPE_MAP[(unsigned __int8)v63] & 0x11) != 0 )
        {
          if ( vi_prec_num && (prec_num && v63 == 48 || v63 > 48) && v63 <= 57 )
          {
            prec_num = v63 - 48 + 10 * prec_num;
            if ( prec_num > 10000 )
              prec_num = 10000;
          }
          else
          {
            set_buffer_environ(CurrentTab->currentBuffer);
            save_buffer_position(CurrentTab->currentBuffer);
            keyPressEventProc(v63);
            prec_num = 0;
          }
        }
        prev_key = CurrentKey;
        CurrentKey = -1;
        CurrentKeyData = 0;
      }
    }
    if ( v48 < 0 )
      break;
    SearchHeader[0] = v62;
    DefaultType = v36;
    if ( w3m_dump == 2 )
    {
      v41 = (FormList *)GC_malloc(52);
      v41->method = 3;
      v60 = loadGeneralFile(*(char **)(v43 + 4 * v48), 0, (char *)0xFFFFFFFF, 0, v41);
    }
    else
    {
      if ( !v35 || v48 )
      {
        v42 = 0;
      }
      else
      {
        if ( !strcmp(v35, "-") )
          v29 = stdin;
        else
          v29 = fopen(v35, "r");
        if ( !v29 )
        {
          v23 = Sprintf("w3m: Can't open %s.\n", v35);
          savexmlstr_0(v34, v23);
          goto LABEL_306;
        }
        v28 = Strfgetall(v29);
        if ( v29 != stdin )
          fclose(v29);
        v42 = newFormList(0, "post", 0, 0, 0, 0, 0);
        v42->body = v28->ptr;
        v42->boundary = 0;
        v42->length = v28->length;
      }
      v60 = loadGeneralFile(*(char **)(v43 + 4 * v48), 0, (char *)0xFFFFFFFF, 0, v42);
    }
    if ( !v60 )
    {
      v24 = Sprintf("w3m: Can't load %s.\n", *(const char **)(v43 + 4 * v48));
      savexmlstr_0(v34, v24);
      goto LABEL_306;
    }
    if ( v60 != (Buffer *)1 )
    {
      v10 = v60->real_scheme;
      if ( v10 < 4 )
        goto LABEL_285;
      if ( v10 <= 5 )
      {
        v11 = InnerCharset;
        v12 = SystemCharset;
        v13 = Strnew_charp(*(char **)(v43 + 4 * v48));
        v14 = wc_Str_conv(v13, v12, v11);
        unshiftHist(LoadHist, v14->ptr);
        goto LABEL_285;
      }
      if ( v10 != 12 )
      {
LABEL_285:
        v15 = parsedURL2Str(&v60->currentURL);
        pushHashHist(URLHist, v15->ptr);
      }
LABEL_287:
      if ( v60->pagerSource
        || v60->real_scheme == 4 && v60->header_source && v60->currentURL.file && strcmp(v60->currentURL.file, "-") )
      {
        v60->search_header = v62;
      }
      if ( CurrentTab )
      {
        if ( v37 )
        {
          newT();
          CurrentTab->currentBuffer->nextBuffer = v60;
          delBuffer(CurrentTab->currentBuffer);
        }
        else
        {
          CurrentTab->currentBuffer->nextBuffer = v60;
          CurrentTab->currentBuffer = v60;
        }
      }
      else
      {
        CurrentTab = newTab();
        LastTab = CurrentTab;
        FirstTab = CurrentTab;
        nTab = 1;
        v16 = CurrentTab;
        v17 = CurrentTab;
        CurrentTab->currentBuffer = v60;
        v16->firstBuffer = v17->currentBuffer;
      }
      if ( (!w3m_dump || w3m_dump == 1) && CurrentTab->currentBuffer->frameset && RenderFrame )
        rFrame();
      if ( w3m_dump )
        do_dump(CurrentTab->currentBuffer);
      else
        CurrentTab->currentBuffer = v60;
    }
LABEL_306:
    ++v48;
  }
  if ( v60 == (Buffer *)1 )
    goto LABEL_306;
  goto LABEL_287;
}
// 8049F0C: using guessed type int __cdecl GC_set_warn_proc(_DWORD);
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (0804D821) --------------------------------------------------------
void __cdecl keyPressEventProc(int c)
{
  CurrentKey = c;
  w3mFuncList[GlobalKeymap[c]].func();
}

//----- (0804D847) --------------------------------------------------------
void __cdecl pushEvent(int cmd, void *data)
{
  Event *event; // [esp+1Ch] [ebp-Ch]

  event = (Event *)GC_malloc(12);
  event->cmd = cmd;
  event->data = data;
  event->next = 0;
  if ( CurrentEvent )
    LastEvent->next = event;
  else
    CurrentEvent = event;
  LastEvent = event;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (0804D89F) --------------------------------------------------------
void __cdecl dump_source(Buffer *buf)
{
  FILE *f; // [esp+18h] [ebp-10h]
  char c; // [esp+1Fh] [ebp-9h]

  if ( buf->sourcefile )
  {
    f = fopen(buf->sourcefile, "r");
    if ( f )
    {
      while ( 1 )
      {
        c = fgetc(f);
        if ( feof(f) )
          break;
        putchar(c);
      }
      fclose(f);
    }
  }
}

//----- (0804D913) --------------------------------------------------------
void __cdecl dump_head(Buffer *buf)
{
  wc_ces v1; // esi
  wc_ces v2; // ebx
  _Str *v3; // eax
  Str v4; // eax
  TextListItem *ti; // [esp+1Ch] [ebp-Ch]

  if ( buf->document_header )
  {
    for ( ti = buf->document_header->first; ti; ti = ti->next )
    {
      v1 = buf->document_charset;
      v2 = InnerCharset;
      v3 = Strnew_charp(ti->ptr);
      v4 = wc_Str_conv_strict(v3, v2, v1);
      printf("%s", v4->ptr);
    }
    puts(&def_str);
  }
  else if ( (w3m_dump & 8) != 0 )
  {
    putchar(10);
  }
}

//----- (0804D9B6) --------------------------------------------------------
void __cdecl dump_extra(Buffer *buf)
{
  Str v1; // eax
  Str v2; // eax
  char *v3; // eax

  v1 = parsedURL2Str(&buf->currentURL);
  printf("W3m-current-url: %s\n", v1->ptr);
  if ( buf->baseURL )
  {
    v2 = parsedURL2Str(buf->baseURL);
    printf("W3m-base-url: %s\n", v2->ptr);
  }
  v3 = wc_ces_to_charset(buf->document_charset);
  printf("W3m-document-charset: %s\n", v3);
}

//----- (0804DA34) --------------------------------------------------------
void __cdecl do_dump(Buffer *buf)
{
  void (*prevtrap)(int); // [esp+1Ch] [ebp-Ch]

  prevtrap = mySignal(2, intTrap);
  if ( !__sigsetjmp(IntReturn, 1) )
  {
    if ( (w3m_dump & 8) != 0 )
      dump_extra(buf);
    if ( (w3m_dump & 2) != 0 )
      dump_head(buf);
    if ( (w3m_dump & 4) != 0 )
      dump_source(buf);
    if ( w3m_dump == 1 )
      saveBuffer(buf, stdout, 0);
  }
  mySignal(2, prevtrap);
}

//----- (0804DB05) --------------------------------------------------------
void nulcmd()
{
  ;
}

//----- (0804DB0A) --------------------------------------------------------
void pcmap()
{
  ;
}

//----- (0804DB0F) --------------------------------------------------------
void __cdecl escKeyProc(int c, int esc, unsigned __int8 *map)
{
  int v3; // eax
  unsigned __int8 **mmap; // [esp+1Ch] [ebp-Ch]

  if ( CurrentKey >= 0 && (CurrentKey & 0x10000000) != 0 )
  {
    mmap = (unsigned __int8 **)getKeyData((CurrentKey >> 16) & 0x77F);
    if ( !mmap )
      return;
    switch ( esc )
    {
      case 512:
        map = mmap[2];
        break;
      case 1024:
        map = mmap[3];
        break;
      case 256:
        map = mmap[1];
        break;
      default:
        map = *mmap;
        break;
    }
    HIWORD(v3) = HIWORD(CurrentKey);
    LOWORD(v3) = 0;
    esc |= v3;
  }
  CurrentKey = esc | c;
  w3mFuncList[map[c]].func();
}

//----- (0804DBCA) --------------------------------------------------------
void escmap()
{
  char c; // [esp+1Fh] [ebp-9h]

  c = do_getch();
  if ( (MYCTYPE_MAP[(unsigned __int8)c] & 0x11) != 0 )
    escKeyProc(c, 256, EscKeymap);
}

//----- (0804DC0E) --------------------------------------------------------
void escbmap()
{
  unsigned __int8 c; // [esp+1Fh] [ebp-9h]

  c = do_getch();
  if ( (MYCTYPE_MAP[c] & 8) != 0 )
  {
    escdmap(c);
  }
  else if ( (MYCTYPE_MAP[c] & 0x11) != 0 )
  {
    escKeyProc((char)c, 512, EscBKeymap);
  }
}

//----- (0804DC78) --------------------------------------------------------
void __cdecl escdmap(char c)
{
  char ca; // [esp+1Ch] [ebp-1Ch]
  int d; // [esp+2Ch] [ebp-Ch]

  d = c - 48;
  ca = do_getch();
  if ( (MYCTYPE_MAP[(unsigned __int8)ca] & 8) != 0 )
  {
    d = 10 * d + ca - 48;
    ca = do_getch();
  }
  if ( ca == 126 )
    escKeyProc(d, 1024, EscDKeymap);
}

//----- (0804DCF4) --------------------------------------------------------
void multimap()
{
  char c; // [esp+1Fh] [ebp-9h]

  c = do_getch();
  if ( (MYCTYPE_MAP[(unsigned __int8)c] & 0x11) != 0 )
  {
    CurrentKey = (CurrentKey << 16) | 0x10000000 | c;
    escKeyProc(c, 0, 0);
  }
}

//----- (0804DD53) --------------------------------------------------------
void __cdecl tmpClearBuffer(Buffer *buf)
{
  if ( !buf->pagerSource && !writeBufferCache(buf) )
  {
    buf->firstLine = 0;
    buf->topLine = 0;
    buf->currentLine = 0;
    buf->lastLine = 0;
  }
}

//----- (0804DD9C) --------------------------------------------------------
void __cdecl pushBuffer(Buffer *buf)
{
  TabBuffer *v1; // edx
  TabBuffer *v2; // eax
  Buffer *b; // [esp+1Ch] [ebp-Ch]

  deleteImage(CurrentTab->currentBuffer);
  if ( clear_buffer )
    tmpClearBuffer(CurrentTab->currentBuffer);
  if ( CurrentTab->firstBuffer == CurrentTab->currentBuffer )
  {
    buf->nextBuffer = CurrentTab->firstBuffer;
    v1 = CurrentTab;
    v2 = CurrentTab;
    CurrentTab->currentBuffer = buf;
    v1->firstBuffer = v2->currentBuffer;
  }
  else
  {
    b = prevBuffer(CurrentTab->firstBuffer, CurrentTab->currentBuffer);
    if ( b )
    {
      b->nextBuffer = buf;
      buf->nextBuffer = CurrentTab->currentBuffer;
      CurrentTab->currentBuffer = buf;
    }
  }
}

//----- (0804DE4F) --------------------------------------------------------
void __cdecl delBuffer(Buffer *buf)
{
  TabBuffer *v1; // ebx

  if ( buf )
  {
    if ( CurrentTab->currentBuffer == buf )
      CurrentTab->currentBuffer = buf->nextBuffer;
    v1 = CurrentTab;
    v1->firstBuffer = deleteBuffer(CurrentTab->firstBuffer, buf);
    if ( !CurrentTab->currentBuffer )
      CurrentTab->currentBuffer = CurrentTab->firstBuffer;
  }
}

//----- (0804DEBD) --------------------------------------------------------
void __cdecl repBuffer(Buffer *oldbuf, Buffer *buf)
{
  TabBuffer *v2; // ebx

  v2 = CurrentTab;
  v2->firstBuffer = replaceBuffer(CurrentTab->firstBuffer, oldbuf, buf);
  CurrentTab->currentBuffer = buf;
}

//----- (0804DEFC) --------------------------------------------------------
void __cdecl __noreturn intTrap(int _dummy)
{
  siglongjmp(IntReturn, 0);
}

//----- (0804DF16) --------------------------------------------------------
void __cdecl resize_hook(int _dummy)
{
  need_resize_screen = 1;
  mySignal(28, resize_hook);
}

//----- (0804DF3C) --------------------------------------------------------
void resize_screen()
{
  need_resize_screen = 0;
  setlinescols();
  setupscreen();
  if ( CurrentTab )
    displayBuffer(CurrentTab->currentBuffer, 1);
}

//----- (0804DF79) --------------------------------------------------------
void __cdecl SigPipe(int _dummy)
{
  init_migemo();
  mySignal(13, SigPipe);
}

//----- (0804DF9A) --------------------------------------------------------
void __cdecl nscroll(int n, int mode)
{
  int diff_n; // [esp+14h] [ebp-24h]
  int llnum; // [esp+18h] [ebp-20h]
  int tlnum; // [esp+1Ch] [ebp-1Ch]
  int lnum; // [esp+20h] [ebp-18h]
  Line *top; // [esp+28h] [ebp-10h]
  Buffer *buf; // [esp+2Ch] [ebp-Ch]

  buf = CurrentTab->currentBuffer;
  top = buf->topLine;
  if ( buf->firstLine )
  {
    lnum = buf->currentLine->linenumber;
    buf->topLine = lineSkip(buf, top, n, 0);
    if ( buf->topLine == top )
    {
      lnum += n;
      if ( buf->topLine->linenumber <= lnum )
      {
        if ( buf->lastLine->linenumber < lnum )
          lnum = buf->lastLine->linenumber;
      }
      else
      {
        lnum = buf->topLine->linenumber;
      }
    }
    else
    {
      tlnum = buf->topLine->linenumber;
      llnum = tlnum + buf->LINES - 1;
      if ( nextpage_topline )
        diff_n = 0;
      else
        diff_n = n + top->linenumber - tlnum;
      if ( lnum < tlnum )
        lnum = tlnum + diff_n;
      if ( lnum > llnum )
        lnum = llnum + diff_n;
    }
    gotoLine(buf, lnum);
    arrangeLine(buf);
    if ( n <= 0 )
    {
      if ( buf->currentLine->bwidth + buf->currentLine->width >= buf->currentColumn + buf->visualpos )
      {
        while ( buf->currentLine->prev
             && buf->currentLine->bpos
             && buf->currentLine->bwidth >= buf->currentColumn + buf->visualpos )
          cursorUp0(buf, 1);
      }
      else
      {
        cursorUp(buf, 1);
      }
    }
    else if ( buf->currentLine->bpos && buf->currentLine->bwidth >= buf->currentColumn + buf->visualpos )
    {
      cursorDown(buf, 1);
    }
    else
    {
      while ( buf->currentLine->next
           && buf->currentLine->next->bpos
           && buf->currentLine->bwidth + buf->currentLine->width < buf->currentColumn + buf->visualpos )
        cursorDown0(buf, 1);
    }
    displayBuffer(buf, mode);
  }
}

//----- (0804E22A) --------------------------------------------------------
void pgFore()
{
  int v0; // eax
  int v1; // ebx
  int v2; // eax

  if ( vi_prec_num )
  {
    v0 = searchKeyNum();
    nscroll((CurrentTab->currentBuffer->LINES - 1) * v0, 0);
  }
  else
  {
    if ( prec_num )
      v1 = 3;
    else
      v1 = 0;
    if ( prec_num )
      v2 = searchKeyNum();
    else
      v2 = (CurrentTab->currentBuffer->LINES - 1) * searchKeyNum();
    nscroll(v2, v1);
  }
}

//----- (0804E2B9) --------------------------------------------------------
void pgBack()
{
  int v0; // eax
  int v1; // ebx
  int v2; // eax

  if ( vi_prec_num )
  {
    v0 = searchKeyNum();
    nscroll((1 - CurrentTab->currentBuffer->LINES) * v0, 0);
  }
  else
  {
    if ( prec_num )
      v1 = 3;
    else
      v1 = 0;
    if ( prec_num )
      v2 = -searchKeyNum();
    else
      v2 = (1 - CurrentTab->currentBuffer->LINES) * searchKeyNum();
    nscroll(v2, v1);
  }
}

//----- (0804E35C) --------------------------------------------------------
void lup1()
{
  int v0; // eax

  v0 = searchKeyNum();
  nscroll(v0, 3);
}

//----- (0804E379) --------------------------------------------------------
void ldown1()
{
  int v0; // eax

  v0 = searchKeyNum();
  nscroll(-v0, 3);
}

//----- (0804E398) --------------------------------------------------------
void ctrCsrV()
{
  Buffer *v0; // ebx

  if ( CurrentTab->currentBuffer->firstLine )
  {
    if ( (__int16)(CurrentTab->currentBuffer->LINES / 2) != CurrentTab->currentBuffer->cursorY )
    {
      v0 = CurrentTab->currentBuffer;
      v0->topLine = lineSkip(v0, v0->topLine, v0->cursorY - v0->LINES / 2, 0);
      arrangeLine(CurrentTab->currentBuffer);
      displayBuffer(CurrentTab->currentBuffer, 0);
    }
  }
}

//----- (0804E457) --------------------------------------------------------
void ctrCsrH()
{
  int offsetx; // [esp+1Ch] [ebp-Ch]

  if ( CurrentTab->currentBuffer->firstLine )
  {
    offsetx = CurrentTab->currentBuffer->cursorX - CurrentTab->currentBuffer->COLS / 2;
    if ( offsetx )
    {
      columnSkip(CurrentTab->currentBuffer, offsetx);
      arrangeCursor(CurrentTab->currentBuffer);
      displayBuffer(CurrentTab->currentBuffer, 0);
    }
  }
}

//----- (0804E4E7) --------------------------------------------------------
void rdrwSc()
{
  clear();
  arrangeCursor(CurrentTab->currentBuffer);
  displayBuffer(CurrentTab->currentBuffer, 1);
}

//----- (0804E51C) --------------------------------------------------------
void __cdecl clear_mark(Line *l)
{
  int pos; // [esp+Ch] [ebp-4h]

  if ( l )
  {
    for ( pos = 0; l->size > pos; ++pos )
      l->propBuf[pos] &= 0xFFFE;
  }
}

//----- (0804E569) --------------------------------------------------------
int __cdecl srchcore(char *volatile str, int (*func)(Buffer *, char *))
{
  int v3; // eax
  int v4; // eax
  int result; // [esp+14h] [ebp-14h]
  volatile int i; // [esp+18h] [ebp-10h]
  void (*prevtrap)(int); // [esp+1Ch] [ebp-Ch]
  char *volatile stra; // [esp+30h] [ebp+8h]

  result = 2;
  if ( str && str != SearchString )
    SearchString = str;
  if ( !SearchString || !*SearchString )
    return 2;
  stra = conv_search_string(SearchString, DisplayCharset);
  prevtrap = mySignal(2, intTrap);
  crmode();
  if ( !__sigsetjmp(IntReturn, 1) )
  {
    for ( i = 0; ; ++i )
    {
      v4 = prec_num ? prec_num : 1;
      if ( v4 <= i )
        break;
      result = func(CurrentTab->currentBuffer, stra);
      if ( prec_num )
        v3 = prec_num - 1;
      else
        v3 = 0;
      if ( v3 > i && (result & 1) != 0 )
        clear_mark(CurrentTab->currentBuffer->currentLine);
    }
  }
  mySignal(2, prevtrap);
  term_raw();
  return result;
}

//----- (0804E6A3) --------------------------------------------------------
void __cdecl disp_srchresult(int result, char *prompt, char *str)
{
  Str v3; // eax
  Str v4; // eax
  Str v5; // eax

  if ( !str )
    str = (char *)&def_str;
  if ( (result & 2) != 0 )
  {
    v3 = Sprintf("Not found: %s", str);
    disp_message(v3->ptr, 1);
  }
  else if ( (result & 4) != 0 )
  {
    v4 = Sprintf("Search wrapped: %s", str);
    disp_message(v4->ptr, 1);
  }
  else if ( show_srch_str )
  {
    v5 = Sprintf("%s%s", prompt, str);
    disp_message(v5->ptr, 1);
  }
}

//----- (0804E74F) --------------------------------------------------------
int __cdecl dispincsrch(int ch_0, Str buf, Lineprop *prop)
{
  Lineprop v4; // dx
  int do_next_search; // [esp+18h] [ebp-10h]
  char *str; // [esp+1Ch] [ebp-Ch]

  do_next_search = 0;
  if ( !ch_0 && !buf )
  {
    sbuf_11060.topLine = CurrentTab->currentBuffer->topLine;
    sbuf_11060.currentLine = CurrentTab->currentBuffer->currentLine;
    sbuf_11060.pos = CurrentTab->currentBuffer->pos;
    sbuf_11060.cursorX = CurrentTab->currentBuffer->cursorX;
    sbuf_11060.cursorY = CurrentTab->currentBuffer->cursorY;
    sbuf_11060.visualpos = CurrentTab->currentBuffer->visualpos;
    sbuf_11060.currentColumn = CurrentTab->currentBuffer->currentColumn;
    currentLine_11061 = sbuf_11060.currentLine;
    pos_11062 = sbuf_11060.pos;
    return -1;
  }
  str = buf->ptr;
  switch ( ch_0 )
  {
    case 19:
      searchRoutine = forwardSearch;
      do_next_search = 1;
      break;
    case 28:
      migemo_active = -migemo_active;
LABEL_28:
      while ( *str++ != 0 )
      {
        if ( migemo_active <= 0 )
          v4 = *prop & 0xFFFD;
        else
          v4 = *prop | 2;
        *prop++ = v4;
      }
      return -1;
    case 18:
      searchRoutine = backwardSearch;
      do_next_search = 1;
      break;
    default:
      if ( ch_0 >= 0 )
        return ch_0;
      break;
  }
  if ( !do_next_search )
  {
    if ( *str )
    {
      CurrentTab->currentBuffer->topLine = sbuf_11060.topLine;
      CurrentTab->currentBuffer->currentLine = sbuf_11060.currentLine;
      CurrentTab->currentBuffer->pos = sbuf_11060.pos;
      CurrentTab->currentBuffer->cursorX = sbuf_11060.cursorX;
      CurrentTab->currentBuffer->cursorY = sbuf_11060.cursorY;
      CurrentTab->currentBuffer->visualpos = sbuf_11060.visualpos;
      CurrentTab->currentBuffer->currentColumn = sbuf_11060.currentColumn;
      arrangeCursor(CurrentTab->currentBuffer);
      srchcore(str, searchRoutine);
      arrangeCursor(CurrentTab->currentBuffer);
      currentLine_11061 = CurrentTab->currentBuffer->currentLine;
      pos_11062 = CurrentTab->currentBuffer->pos;
    }
    displayBuffer(CurrentTab->currentBuffer, 1);
    clear_mark(CurrentTab->currentBuffer->currentLine);
    goto LABEL_28;
  }
  if ( !*str )
    return 16;
  if ( searchRoutine == forwardSearch )
    ++CurrentTab->currentBuffer->pos;
  sbuf_11060.topLine = CurrentTab->currentBuffer->topLine;
  sbuf_11060.currentLine = CurrentTab->currentBuffer->currentLine;
  sbuf_11060.pos = CurrentTab->currentBuffer->pos;
  sbuf_11060.cursorX = CurrentTab->currentBuffer->cursorX;
  sbuf_11060.cursorY = CurrentTab->currentBuffer->cursorY;
  sbuf_11060.visualpos = CurrentTab->currentBuffer->visualpos;
  sbuf_11060.currentColumn = CurrentTab->currentBuffer->currentColumn;
  if ( srchcore(str, searchRoutine) == 2 && searchRoutine == forwardSearch )
  {
    --CurrentTab->currentBuffer->pos;
    sbuf_11060.topLine = CurrentTab->currentBuffer->topLine;
    sbuf_11060.currentLine = CurrentTab->currentBuffer->currentLine;
    sbuf_11060.pos = CurrentTab->currentBuffer->pos;
    sbuf_11060.cursorX = CurrentTab->currentBuffer->cursorX;
    sbuf_11060.cursorY = CurrentTab->currentBuffer->cursorY;
    sbuf_11060.visualpos = CurrentTab->currentBuffer->visualpos;
    sbuf_11060.currentColumn = CurrentTab->currentBuffer->currentColumn;
  }
  arrangeCursor(CurrentTab->currentBuffer);
  displayBuffer(CurrentTab->currentBuffer, 1);
  clear_mark(CurrentTab->currentBuffer->currentLine);
  return -1;
}

//----- (0804EB6D) --------------------------------------------------------
void __cdecl isrch(int (*func)(Buffer *, char *), char *prompt)
{
  Line *sbuf_12; // [esp+34h] [ebp-104h]
  Line *sbuf_16; // [esp+38h] [ebp-100h]
  int sbuf_68; // [esp+6Ch] [ebp-CCh]
  __int16 sbuf_72; // [esp+70h] [ebp-C8h]
  __int16 sbuf_74; // [esp+72h] [ebp-C6h]
  int sbuf_76; // [esp+74h] [ebp-C4h]
  int sbuf_80; // [esp+78h] [ebp-C0h]

  sbuf_12 = CurrentTab->currentBuffer->topLine;
  sbuf_16 = CurrentTab->currentBuffer->currentLine;
  sbuf_76 = CurrentTab->currentBuffer->pos;
  sbuf_72 = CurrentTab->currentBuffer->cursorX;
  sbuf_74 = CurrentTab->currentBuffer->cursorY;
  sbuf_80 = CurrentTab->currentBuffer->visualpos;
  sbuf_68 = CurrentTab->currentBuffer->currentColumn;
  dispincsrch(0, 0, 0);
  searchRoutine = func;
  if ( !inputLineHistSearch(prompt, 0, 16, TextHist, dispincsrch) )
  {
    CurrentTab->currentBuffer->topLine = sbuf_12;
    CurrentTab->currentBuffer->currentLine = sbuf_16;
    CurrentTab->currentBuffer->pos = sbuf_76;
    CurrentTab->currentBuffer->cursorX = sbuf_72;
    CurrentTab->currentBuffer->cursorY = sbuf_74;
    CurrentTab->currentBuffer->visualpos = sbuf_80;
    CurrentTab->currentBuffer->currentColumn = sbuf_68;
  }
  displayBuffer(CurrentTab->currentBuffer, 1);
}

//----- (0804ECDF) --------------------------------------------------------
void __cdecl srch(int (*func)(Buffer *, char *), char *prompt)
{
  int pos; // [esp+20h] [ebp-18h]
  int disp; // [esp+24h] [ebp-14h]
  int result; // [esp+28h] [ebp-10h]
  char *str; // [esp+2Ch] [ebp-Ch]

  disp = 0;
  str = searchKeyData();
  if ( !str || !*str )
  {
    str = inputLineHistSearch(prompt, 0, 16, TextHist, 0);
    if ( str && !*str )
      str = SearchString;
    if ( !str )
    {
      displayBuffer(CurrentTab->currentBuffer, 0);
      return;
    }
    disp = 1;
  }
  pos = CurrentTab->currentBuffer->pos;
  if ( func == forwardSearch )
    ++CurrentTab->currentBuffer->pos;
  result = srchcore(str, func);
  if ( (result & 1) != 0 )
    clear_mark(CurrentTab->currentBuffer->currentLine);
  else
    CurrentTab->currentBuffer->pos = pos;
  displayBuffer(CurrentTab->currentBuffer, 0);
  if ( disp )
    disp_srchresult(result, prompt, str);
  searchRoutine = func;
}

//----- (0804EE29) --------------------------------------------------------
void srchfor()
{
  srch(forwardSearch, "Forward: ");
}

//----- (0804EE45) --------------------------------------------------------
void isrchfor()
{
  isrch(forwardSearch, "I-search: ");
}

//----- (0804EE61) --------------------------------------------------------
void srchbak()
{
  srch(backwardSearch, "Backward: ");
}

//----- (0804EE7D) --------------------------------------------------------
void isrchbak()
{
  isrch(backwardSearch, "I-search backward: ");
}

//----- (0804EE99) --------------------------------------------------------
void __cdecl srch_nxtprv(int reverse)
{
  char *v1; // eax
  int result; // [esp+1Ch] [ebp-Ch]
  int reversea; // [esp+30h] [ebp+8h]

  if ( searchRoutine )
  {
    reversea = reverse != 0;
    if ( searchRoutine == backwardSearch )
      reversea ^= 1u;
    if ( !reversea )
      ++CurrentTab->currentBuffer->pos;
    result = srchcore(SearchString, routine_11359[reversea]);
    if ( (result & 1) != 0 )
      clear_mark(CurrentTab->currentBuffer->currentLine);
    displayBuffer(CurrentTab->currentBuffer, 0);
    if ( reversea )
      v1 = "Backward: ";
    else
      v1 = "Forward: ";
    disp_srchresult(result, v1, SearchString);
  }
  else
  {
    disp_message("No previous regular expression", 1);
  }
}

//----- (0804EF7E) --------------------------------------------------------
void srchnxt()
{
  srch_nxtprv(0);
}

//----- (0804EF92) --------------------------------------------------------
void srchprv()
{
  srch_nxtprv(1);
}

//----- (0804EFA6) --------------------------------------------------------
void __cdecl shiftvisualpos(Buffer *buf, int shift)
{
  Line *l; // [esp+1Ch] [ebp-Ch]

  l = buf->currentLine;
  buf->visualpos -= shift;
  if ( buf->visualpos - l->bwidth < buf->COLS )
  {
    if ( buf->visualpos - l->bwidth < 0 )
      buf->visualpos = l->bwidth;
  }
  else
  {
    buf->visualpos = l->bwidth + buf->COLS - 1;
  }
  arrangeLine(buf);
  if ( buf->visualpos - l->bwidth == -shift && !buf->cursorX )
    buf->visualpos = l->bwidth;
}

//----- (0804F05A) --------------------------------------------------------
void shiftl()
{
  int v0; // eax
  int column; // [esp+1Ch] [ebp-Ch]

  if ( CurrentTab->currentBuffer->firstLine )
  {
    column = CurrentTab->currentBuffer->currentColumn;
    v0 = searchKeyNum();
    columnSkip(CurrentTab->currentBuffer, (1 - CurrentTab->currentBuffer->COLS) * v0 + 1);
    shiftvisualpos(CurrentTab->currentBuffer, CurrentTab->currentBuffer->currentColumn - column);
    displayBuffer(CurrentTab->currentBuffer, 0);
  }
}

//----- (0804F101) --------------------------------------------------------
void shiftr()
{
  int v0; // eax
  int column; // [esp+1Ch] [ebp-Ch]

  if ( CurrentTab->currentBuffer->firstLine )
  {
    column = CurrentTab->currentBuffer->currentColumn;
    v0 = searchKeyNum();
    columnSkip(CurrentTab->currentBuffer, (CurrentTab->currentBuffer->COLS - 1) * v0 - 1);
    shiftvisualpos(CurrentTab->currentBuffer, CurrentTab->currentBuffer->currentColumn - column);
    displayBuffer(CurrentTab->currentBuffer, 0);
  }
}

//----- (0804F197) --------------------------------------------------------
void col1R()
{
  int n; // [esp+1Ch] [ebp-1Ch]
  int column; // [esp+20h] [ebp-18h]
  int j; // [esp+24h] [ebp-14h]
  Line *l; // [esp+28h] [ebp-10h]
  Buffer *buf; // [esp+2Ch] [ebp-Ch]

  buf = CurrentTab->currentBuffer;
  l = buf->currentLine;
  n = searchKeyNum();
  if ( l )
  {
    for ( j = 0; j < n; ++j )
    {
      column = buf->currentColumn;
      columnSkip(CurrentTab->currentBuffer, 1);
      if ( buf->currentColumn == column )
        break;
      shiftvisualpos(CurrentTab->currentBuffer, 1);
    }
    displayBuffer(CurrentTab->currentBuffer, 0);
  }
}

//----- (0804F238) --------------------------------------------------------
void col1L()
{
  int n; // [esp+10h] [ebp-18h]
  int j; // [esp+14h] [ebp-14h]
  Line *l; // [esp+18h] [ebp-10h]
  Buffer *buf; // [esp+1Ch] [ebp-Ch]

  buf = CurrentTab->currentBuffer;
  l = buf->currentLine;
  n = searchKeyNum();
  if ( l )
  {
    for ( j = 0; j < n && buf->currentColumn; ++j )
    {
      columnSkip(CurrentTab->currentBuffer, -1);
      shiftvisualpos(CurrentTab->currentBuffer, -1);
    }
    displayBuffer(CurrentTab->currentBuffer, 0);
  }
}

//----- (0804F2CF) --------------------------------------------------------
void setEnv()
{
  char *value; // [esp+24h] [ebp-14h]
  char *var; // [esp+28h] [ebp-10h]
  char *env; // [esp+2Ch] [ebp-Ch]

  CurrentKeyData = 0;
  env = searchKeyData();
  if ( env && *env && strchr(env, 61) )
    goto LABEL_10;
  if ( env && *env )
    env = Sprintf("%s=", env)->ptr;
  env = inputLineHistSearch("Set environ: ", env, 16, TextHist, 0);
  if ( env )
  {
    if ( *env )
    {
LABEL_10:
      value = strchr(env, 61);
      if ( value && value > env )
      {
        var = allocStr(env, value - env);
        set_environ(var, value + 1);
      }
    }
  }
  displayBuffer(CurrentTab->currentBuffer, 0);
}

//----- (0804F405) --------------------------------------------------------
void pipeBuf()
{
  wc_ces v0; // esi
  wc_ces v1; // ebx
  _Str *v2; // eax
  Str v3; // eax
  char *v4; // eax
  Str v5; // eax
  wc_ces v6; // esi
  wc_ces v7; // ebx
  _Str *v8; // eax
  Str v9; // eax
  FILE *f; // [esp+20h] [ebp-18h]
  char *tmpf; // [esp+24h] [ebp-14h]
  char *cmd; // [esp+28h] [ebp-10h]
  Buffer *buf; // [esp+2Ch] [ebp-Ch]

  CurrentKeyData = 0;
  cmd = searchKeyData();
  if ( !cmd || !*cmd )
    cmd = inputLineHistSearch("Pipe buffer to: ", (char *)&def_str, 128, ShellHist, 0);
  if ( cmd )
  {
    v0 = SystemCharset;
    v1 = InnerCharset;
    v2 = Strnew_charp(cmd);
    cmd = wc_Str_conv_strict(v2, v1, v0)->ptr;
  }
  if ( cmd && *cmd )
  {
    tmpf = tmpfname(0, 0)->ptr;
    f = fopen(tmpf, "w");
    if ( f )
    {
      saveBuffer(CurrentTab->currentBuffer, f, 1);
      fclose(f);
      v4 = shell_quote(tmpf);
      v5 = myExtCommand(cmd, v4, 1);
      buf = getpipe(v5->ptr);
      if ( buf )
      {
        buf->filename = cmd;
        v6 = InnerCharset;
        v7 = SystemCharset;
        v8 = Strnew_charp(cmd);
        v9 = wc_Str_conv(v8, v7, v6);
        buf->buffername = Sprintf("%s %s", "*stream*", v9->ptr)->ptr;
        buf->bufferprop |= 0x18u;
        if ( !buf->type )
          buf->type = "text/plain";
        buf->currentURL.file = "-";
        pushBuffer(buf);
        displayBuffer(CurrentTab->currentBuffer, 1);
      }
      else
      {
        disp_message("Execution failed", 1);
      }
    }
    else
    {
      v3 = Sprintf("Can't save buffer to %s", cmd);
      disp_message(v3->ptr, 1);
    }
  }
  else
  {
    displayBuffer(CurrentTab->currentBuffer, 0);
  }
}

//----- (0804F645) --------------------------------------------------------
void pipesh()
{
  wc_ces v0; // esi
  wc_ces v1; // ebx
  _Str *v2; // eax
  char *cmd; // [esp+28h] [ebp-10h]
  Buffer *buf; // [esp+2Ch] [ebp-Ch]

  CurrentKeyData = 0;
  cmd = searchKeyData();
  if ( !cmd || !*cmd )
    cmd = inputLineHistSearch("(read shell[pipe])!", (char *)&def_str, 128, ShellHist, 0);
  if ( cmd )
  {
    v0 = SystemCharset;
    v1 = InnerCharset;
    v2 = Strnew_charp(cmd);
    cmd = wc_Str_conv_strict(v2, v1, v0)->ptr;
  }
  if ( cmd && *cmd )
  {
    buf = getpipe(cmd);
    if ( buf )
    {
      buf->bufferprop |= 0x18u;
      if ( !buf->type )
        buf->type = "text/plain";
      pushBuffer(buf);
      displayBuffer(CurrentTab->currentBuffer, 1);
    }
    else
    {
      disp_message("Execution failed", 1);
    }
  }
  else
  {
    displayBuffer(CurrentTab->currentBuffer, 0);
  }
}

//----- (0804F776) --------------------------------------------------------
void readsh()
{
  wc_ces v0; // esi
  wc_ces v1; // ebx
  _Str *v2; // eax
  char *cmd; // [esp+24h] [ebp-14h]
  void (*prevtrap)(int); // [esp+28h] [ebp-10h]
  Buffer *buf; // [esp+2Ch] [ebp-Ch]

  CurrentKeyData = 0;
  cmd = searchKeyData();
  if ( !cmd || !*cmd )
    cmd = inputLineHistSearch("(read shell)!", (char *)&def_str, 128, ShellHist, 0);
  if ( cmd )
  {
    v0 = SystemCharset;
    v1 = InnerCharset;
    v2 = Strnew_charp(cmd);
    cmd = wc_Str_conv_strict(v2, v1, v0)->ptr;
  }
  if ( cmd && *cmd )
  {
    prevtrap = mySignal(2, intTrap);
    crmode();
    buf = getshell(cmd);
    mySignal(2, prevtrap);
    term_raw();
    if ( buf )
    {
      buf->bufferprop |= 0x18u;
      if ( !buf->type )
        buf->type = "text/plain";
      pushBuffer(buf);
      displayBuffer(CurrentTab->currentBuffer, 1);
    }
    else
    {
      disp_message("Execution failed", 1);
    }
  }
  else
  {
    displayBuffer(CurrentTab->currentBuffer, 0);
  }
}

//----- (0804F8DE) --------------------------------------------------------
void execsh()
{
  wc_ces v0; // esi
  wc_ces v1; // ebx
  _Str *v2; // eax
  char *cmd; // [esp+2Ch] [ebp-Ch]

  CurrentKeyData = 0;
  cmd = searchKeyData();
  if ( !cmd || !*cmd )
    cmd = inputLineHistSearch("(exec shell)!", (char *)&def_str, 128, ShellHist, 0);
  if ( cmd )
  {
    v0 = SystemCharset;
    v1 = InnerCharset;
    v2 = Strnew_charp(cmd);
    cmd = wc_Str_conv_strict(v2, v1, v0)->ptr;
  }
  if ( cmd && *cmd )
  {
    fmTerm();
    putchar(10);
    system(cmd);
    printf("\n[Hit any key]");
    fflush(stdout);
    fmInit();
    do_getch();
  }
  displayBuffer(CurrentTab->currentBuffer, 1);
}

//----- (0804F9D9) --------------------------------------------------------
void ldfile()
{
  wc_ces v0; // esi
  wc_ces v1; // ebx
  _Str *v2; // eax
  char *fn; // [esp+2Ch] [ebp-Ch]

  fn = searchKeyData();
  if ( !fn || !*fn )
    fn = inputLineHistSearch("(Load)Filename? ", 0, 32, LoadHist, 0);
  if ( fn )
  {
    v0 = SystemCharset;
    v1 = InnerCharset;
    v2 = Strnew_charp(fn);
    fn = wc_Str_conv_strict(v2, v1, v0)->ptr;
  }
  if ( fn && *fn )
    cmd_loadfile(fn);
  else
    displayBuffer(CurrentTab->currentBuffer, 0);
}

//----- (0804FA97) --------------------------------------------------------
void ldhelp()
{
  _Str *v0; // eax
  char *v1; // ebx
  _Str *v2; // eax
  Str v3; // eax
  Str tmp; // [esp+14h] [ebp-14h]
  size_t n; // [esp+18h] [ebp-10h]
  char *lang; // [esp+1Ch] [ebp-Ch]

  lang = AcceptLang;
  n = strcspn(AcceptLang, ";, \t");
  v0 = Strnew_charp_n(lang, n);
  v1 = Str_form_quote(v0)->ptr;
  v2 = Strnew_charp(w3m_version);
  v3 = Str_form_quote(v2);
  tmp = Sprintf("file:///$LIB/w3mhelp.cgi?version=%s&lang=%s", v3->ptr, v1);
  cmd_loadURL(tmp->ptr, 0, (char *)0xFFFFFFFF, 0);
}

//----- (0804FB31) --------------------------------------------------------
void __cdecl cmd_loadfile(char *fn)
{
  char *v1; // eax
  wc_ces v2; // esi
  wc_ces v3; // ebx
  _Str *v4; // eax
  Str v5; // eax
  Str v6; // eax
  Buffer *buf; // [esp+2Ch] [ebp-Ch]

  v1 = file_to_url(fn);
  buf = loadGeneralFile(v1, 0, (char *)0xFFFFFFFF, 0, 0);
  if ( buf )
  {
    if ( buf != (Buffer *)1 )
    {
      pushBuffer(buf);
      if ( RenderFrame )
      {
        if ( CurrentTab->currentBuffer->frameset )
          rFrame();
      }
    }
  }
  else
  {
    v2 = InnerCharset;
    v3 = SystemCharset;
    v4 = Strnew_charp(fn);
    v5 = wc_Str_conv(v4, v3, v2);
    v6 = Sprintf("%s not found", v5->ptr);
    _ZN10bdInetAddrC2Ej(v6->ptr, 0);
  }
  displayBuffer(CurrentTab->currentBuffer, 0);
}

//----- (0804FC1A) --------------------------------------------------------
void __cdecl movL(int n)
{
  int m; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]

  m = searchKeyNum();
  if ( CurrentTab->currentBuffer->firstLine )
  {
    for ( i = 0; i < m; ++i )
      cursorLeft(CurrentTab->currentBuffer, n);
    displayBuffer(CurrentTab->currentBuffer, 0);
  }
}

//----- (0804FC80) --------------------------------------------------------
void movL()
{
  movL(CurrentTab->currentBuffer->COLS / 2);
}

//----- (0804FCA9) --------------------------------------------------------
void movL1()
{
  movL(1);
}

//----- (0804FCBD) --------------------------------------------------------
void __cdecl movD(int n)
{
  int m; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]

  m = searchKeyNum();
  if ( CurrentTab->currentBuffer->firstLine )
  {
    for ( i = 0; i < m; ++i )
      cursorDown(CurrentTab->currentBuffer, n);
    displayBuffer(CurrentTab->currentBuffer, 0);
  }
}

//----- (0804FD23) --------------------------------------------------------
void movD()
{
  movD((CurrentTab->currentBuffer->LINES + 1) / 2);
}

//----- (0804FD4D) --------------------------------------------------------
void movD1()
{
  movD(1);
}

//----- (0804FD61) --------------------------------------------------------
void __cdecl movU(int n)
{
  int m; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]

  m = searchKeyNum();
  if ( CurrentTab->currentBuffer->firstLine )
  {
    for ( i = 0; i < m; ++i )
      cursorUp(CurrentTab->currentBuffer, n);
    displayBuffer(CurrentTab->currentBuffer, 0);
  }
}

//----- (0804FDC7) --------------------------------------------------------
void movU()
{
  movU((CurrentTab->currentBuffer->LINES + 1) / 2);
}

//----- (0804FDF1) --------------------------------------------------------
void movU1()
{
  movU(1);
}

//----- (0804FE05) --------------------------------------------------------
void __cdecl movR(int n)
{
  int m; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]

  m = searchKeyNum();
  if ( CurrentTab->currentBuffer->firstLine )
  {
    for ( i = 0; i < m; ++i )
      cursorRight(CurrentTab->currentBuffer, n);
    displayBuffer(CurrentTab->currentBuffer, 0);
  }
}

//----- (0804FE6B) --------------------------------------------------------
void movR()
{
  movR(CurrentTab->currentBuffer->COLS / 2);
}

//----- (0804FE94) --------------------------------------------------------
void movR1()
{
  movR(1);
}

//----- (0804FEA8) --------------------------------------------------------
int __cdecl prev_nonnull_line(Line *line)
{
  Line *l; // [esp+Ch] [ebp-4h]

  for ( l = line; l && !l->len; l = l->prev )
    ;
  if ( !l || !l->len )
    return -1;
  CurrentTab->currentBuffer->currentLine = l;
  if ( l != line )
    CurrentTab->currentBuffer->pos = CurrentTab->currentBuffer->currentLine->len;
  return 0;
}

//----- (0804FF1D) --------------------------------------------------------
void movLW()
{
  int n; // [esp+18h] [ebp-20h]
  int i; // [esp+1Ch] [ebp-1Ch]
  int ppos; // [esp+20h] [ebp-18h]
  Line *pline; // [esp+24h] [ebp-14h]
  Lineprop *pb; // [esp+28h] [ebp-10h]
  Lineprop *pba; // [esp+28h] [ebp-10h]
  char *lb; // [esp+2Ch] [ebp-Ch]
  char *lba; // [esp+2Ch] [ebp-Ch]

  n = searchKeyNum();
  if ( CurrentTab->currentBuffer->firstLine )
  {
    for ( i = 0; i < n; ++i )
    {
      pline = CurrentTab->currentBuffer->currentLine;
      ppos = CurrentTab->currentBuffer->pos;
      if ( prev_nonnull_line(pline) < 0 )
        break;
      while ( 1 )
      {
        lb = CurrentTab->currentBuffer->currentLine->lineBuf;
        pb = CurrentTab->currentBuffer->currentLine->propBuf;
        while ( CurrentTab->currentBuffer->pos > 0
             && ((MYCTYPE_MAP[(unsigned __int8)lb[CurrentTab->currentBuffer->pos - 1]] & 0xC) == 0
              || (pb[CurrentTab->currentBuffer->pos - 1] & 0x3F00) != 0) )
          --CurrentTab->currentBuffer->pos;
        if ( CurrentTab->currentBuffer->pos > 0 )
          break;
        if ( prev_nonnull_line(CurrentTab->currentBuffer->currentLine->prev) < 0 )
        {
          CurrentTab->currentBuffer->currentLine = pline;
          CurrentTab->currentBuffer->pos = ppos;
          goto end;
        }
        CurrentTab->currentBuffer->pos = CurrentTab->currentBuffer->currentLine->len;
      }
      lba = CurrentTab->currentBuffer->currentLine->lineBuf;
      pba = CurrentTab->currentBuffer->currentLine->propBuf;
      while ( CurrentTab->currentBuffer->pos > 0
           && (MYCTYPE_MAP[(unsigned __int8)lba[CurrentTab->currentBuffer->pos - 1]] & 0xC) != 0
           && (pba[CurrentTab->currentBuffer->pos - 1] & 0x3F00) == 0 )
        --CurrentTab->currentBuffer->pos;
    }
end:
    arrangeCursor(CurrentTab->currentBuffer);
    displayBuffer(CurrentTab->currentBuffer, 0);
  }
}

//----- (08050144) --------------------------------------------------------
int __cdecl next_nonnull_line(Line *line)
{
  Line *l; // [esp+Ch] [ebp-4h]

  for ( l = line; l && !l->len; l = l->next )
    ;
  if ( !l || !l->len )
    return -1;
  CurrentTab->currentBuffer->currentLine = l;
  if ( l != line )
    CurrentTab->currentBuffer->pos = 0;
  return 0;
}

//----- (080501AE) --------------------------------------------------------
void movRW()
{
  int n; // [esp+18h] [ebp-20h]
  int i; // [esp+1Ch] [ebp-1Ch]
  int ppos; // [esp+20h] [ebp-18h]
  Line *pline; // [esp+24h] [ebp-14h]
  Lineprop *pb; // [esp+28h] [ebp-10h]
  char *lb; // [esp+2Ch] [ebp-Ch]

  n = searchKeyNum();
  if ( CurrentTab->currentBuffer->firstLine )
  {
    i = 0;
LABEL_19:
    if ( i < n )
    {
      pline = CurrentTab->currentBuffer->currentLine;
      ppos = CurrentTab->currentBuffer->pos;
      if ( next_nonnull_line(pline) >= 0 )
      {
        lb = CurrentTab->currentBuffer->currentLine->lineBuf;
        pb = CurrentTab->currentBuffer->currentLine->propBuf;
        while ( lb[CurrentTab->currentBuffer->pos]
             && (MYCTYPE_MAP[(unsigned __int8)lb[CurrentTab->currentBuffer->pos]] & 0xC) != 0
             && (pb[CurrentTab->currentBuffer->pos] & 0x3F00) == 0 )
          ++CurrentTab->currentBuffer->pos;
        while ( 1 )
        {
          while ( lb[CurrentTab->currentBuffer->pos]
               && ((MYCTYPE_MAP[(unsigned __int8)lb[CurrentTab->currentBuffer->pos]] & 0xC) == 0
                || (pb[CurrentTab->currentBuffer->pos] & 0x3F00) != 0) )
            ++CurrentTab->currentBuffer->pos;
          if ( lb[CurrentTab->currentBuffer->pos] )
          {
            ++i;
            goto LABEL_19;
          }
          if ( next_nonnull_line(CurrentTab->currentBuffer->currentLine->next) < 0 )
            break;
          CurrentTab->currentBuffer->pos = 0;
          lb = CurrentTab->currentBuffer->currentLine->lineBuf;
          pb = CurrentTab->currentBuffer->currentLine->propBuf;
        }
        CurrentTab->currentBuffer->currentLine = pline;
        CurrentTab->currentBuffer->pos = ppos;
      }
    }
    arrangeCursor(CurrentTab->currentBuffer);
    displayBuffer(CurrentTab->currentBuffer, 0);
  }
}

//----- (080503D6) --------------------------------------------------------
void __cdecl quitfm(int confirm)
{
  const char *ans; // [esp+2Ch] [ebp-Ch]

  ans = "y";
  if ( checkDownloadList() )
  {
    ans = inputLineHistSearch("Download process retains. Do you want to exit w3m? (y/n)", (char *)&def_str, 512, 0, 0);
  }
  else if ( confirm )
  {
    ans = inputLineHistSearch("Do you want to exit w3m? (y/n)", (char *)&def_str, 512, 0, 0);
  }
  if ( ans )
  {
    if ( (MYCTYPE_MAP[*(unsigned __int8 *)ans] & 4) != 0 )
    {
      if ( (*ans | 0x20) == 121 )
      {
LABEL_11:
        term_title((char *)&def_str);
        if ( activeImage )
          termImage();
        fmTerm();
        save_cookies();
        if ( UseHistory )
        {
          if ( SaveURLHist )
            saveHistory(URLHist, URLHistSize);
        }
        w3m_exit(0);
      }
    }
    else if ( *ans == 121 )
    {
      goto LABEL_11;
    }
  }
  displayBuffer(CurrentTab->currentBuffer, 0);
}

//----- (08050501) --------------------------------------------------------
void quitfm()
{
  quitfm(0);
}

//----- (08050515) --------------------------------------------------------
void qquitfm()
{
  quitfm(confirm_on_quit);
}

//----- (0805052A) --------------------------------------------------------
void selBuf()
{
  TabBuffer *v0; // ebx
  int ok; // [esp+14h] [ebp-14h]
  Buffer *buf; // [esp+18h] [ebp-10h]
  Buffer *bufa; // [esp+18h] [ebp-10h]
  char cmd[9]; // [esp+1Fh] [ebp-9h] BYREF

  ok = 0;
  do
  {
    buf = selectBuffer(CurrentTab->firstBuffer, CurrentTab->currentBuffer, cmd);
    if ( cmd[0] == 68 )
    {
      delBuffer(buf);
      if ( !CurrentTab->firstBuffer )
      {
        v0 = CurrentTab;
        v0->firstBuffer = nullBuffer();
        CurrentTab->currentBuffer = CurrentTab->firstBuffer;
      }
    }
    else if ( cmd[0] > 68 )
    {
      if ( cmd[0] == 81 )
      {
        quitfm();
      }
      else if ( cmd[0] == 113 )
      {
        qquitfm();
      }
    }
    else if ( cmd[0] == 66 )
    {
      ok = 1;
    }
    else if ( cmd[0] <= 66 && (cmd[0] == 10 || cmd[0] == 32) )
    {
      CurrentTab->currentBuffer = buf;
      ok = 1;
    }
  }
  while ( !ok );
  for ( bufa = CurrentTab->firstBuffer; bufa; bufa = bufa->nextBuffer )
  {
    if ( CurrentTab->currentBuffer != bufa )
    {
      deleteImage(bufa);
      if ( clear_buffer )
        tmpClearBuffer(bufa);
    }
  }
  displayBuffer(CurrentTab->currentBuffer, 1);
}

//----- (08050668) --------------------------------------------------------
void susp()
{
  move(LINES - 1, 0);
  clrtoeolx();
  refresh();
  fmTerm();
  kill(0, 19);
  fmInit();
  displayBuffer(CurrentTab->currentBuffer, 1);
}

//----- (080506C8) --------------------------------------------------------
void __cdecl goLine(char *l)
{
  Buffer *v1; // edx
  Buffer *v2; // ebx
  int v3; // eax

  if ( l && *l && CurrentTab->currentBuffer->currentLine )
  {
    CurrentTab->currentBuffer->pos = 0;
    if ( (*l == 94 || *l == 36) && prec_num )
    {
      gotoRealLine(CurrentTab->currentBuffer, prec_num);
    }
    else if ( *l == 94 )
    {
      v1 = CurrentTab->currentBuffer;
      v1->currentLine = v1->firstLine;
      v1->topLine = v1->currentLine;
    }
    else if ( *l == 36 )
    {
      v2 = CurrentTab->currentBuffer;
      v2->topLine = lineSkip(v2, v2->lastLine, ((v2->LINES >= 0) + ~v2->LINES) >> 1, 1);
      CurrentTab->currentBuffer->currentLine = CurrentTab->currentBuffer->lastLine;
    }
    else
    {
      v3 = atoi(l);
      gotoRealLine(CurrentTab->currentBuffer, v3);
    }
    arrangeCursor(CurrentTab->currentBuffer);
    displayBuffer(CurrentTab->currentBuffer, 1);
  }
  else
  {
    displayBuffer(CurrentTab->currentBuffer, 1);
  }
}

//----- (0805084C) --------------------------------------------------------
void goLine()
{
  char *v0; // eax
  char *str; // [esp+2Ch] [ebp-Ch]

  str = searchKeyData();
  if ( prec_num )
  {
    goLine("^");
  }
  else if ( str )
  {
    goLine(str);
  }
  else
  {
    v0 = inputLineHistSearch("Goto line: ", (char *)&def_str, 16, 0, 0);
    goLine(v0);
  }
}

//----- (080508BA) --------------------------------------------------------
void goLineF()
{
  goLine("^");
}

//----- (080508CE) --------------------------------------------------------
void goLineL()
{
  goLine("$");
}

//----- (080508E2) --------------------------------------------------------
void linbeg()
{
  if ( CurrentTab->currentBuffer->firstLine )
  {
    while ( CurrentTab->currentBuffer->currentLine->prev && CurrentTab->currentBuffer->currentLine->bpos )
      cursorUp0(CurrentTab->currentBuffer, 1);
    CurrentTab->currentBuffer->pos = 0;
    arrangeCursor(CurrentTab->currentBuffer);
    displayBuffer(CurrentTab->currentBuffer, 0);
  }
}

//----- (08050971) --------------------------------------------------------
void linend()
{
  if ( CurrentTab->currentBuffer->firstLine )
  {
    while ( CurrentTab->currentBuffer->currentLine->next && CurrentTab->currentBuffer->currentLine->next->bpos )
      cursorDown0(CurrentTab->currentBuffer, 1);
    CurrentTab->currentBuffer->pos = CurrentTab->currentBuffer->currentLine->len - 1;
    arrangeCursor(CurrentTab->currentBuffer);
    displayBuffer(CurrentTab->currentBuffer, 0);
  }
}

//----- (08050A14) --------------------------------------------------------
int __cdecl cur_real_linenumber(Buffer *buf)
{
  int v2; // eax
  int n; // [esp+4h] [ebp-Ch]
  Line *cur; // [esp+8h] [ebp-8h]
  Line *l; // [esp+Ch] [ebp-4h]

  cur = buf->currentLine;
  if ( !cur )
    return 1;
  if ( cur->real_linenumber )
    v2 = cur->real_linenumber;
  else
    v2 = 1;
  n = v2;
  for ( l = buf->firstLine; l && l != cur && !l->real_linenumber; l = l->next )
  {
    if ( !l->bpos )
      ++n;
  }
  return n;
}

//----- (08050A89) --------------------------------------------------------
void editBf()
{
  char *v0; // eax
  int v1; // ebx
  char *v2; // eax
  Str cmd; // [esp+28h] [ebp-10h]
  char *fn; // [esp+2Ch] [ebp-Ch]

  fn = CurrentTab->currentBuffer->filename;
  if ( fn
    && !CurrentTab->currentBuffer->pagerSource
    && (CurrentTab->currentBuffer->type || CurrentTab->currentBuffer->edit)
    && CurrentTab->currentBuffer->real_scheme == 4
    && strcmp(CurrentTab->currentBuffer->currentURL.file, "-")
    && (CurrentTab->currentBuffer->bufferprop & 2) == 0 )
  {
    if ( CurrentTab->currentBuffer->edit )
    {
      v0 = checkHeader(CurrentTab->currentBuffer, "Content-Type:");
      cmd = cptifil(CurrentTab->currentBuffer->edit, CurrentTab->currentBuffer->real_type, fn, v0, 0);
    }
    else
    {
      v1 = cur_real_linenumber(CurrentTab->currentBuffer);
      v2 = shell_quote(fn);
      cmd = myEditor(Editor, v2, v1);
    }
    fmTerm();
    system(cmd->ptr);
    fmInit();
    displayBuffer(CurrentTab->currentBuffer, 1);
    reload();
  }
  else
  {
    _ZN10bdInetAddrC2Ej("Can't edit other than local file", 1);
  }
}

//----- (08050C0E) --------------------------------------------------------
void editScr()
{
  Str v0; // eax
  int v1; // ebx
  char *v2; // eax
  Str v3; // eax
  FILE *f; // [esp+18h] [ebp-10h]
  char *tmpf; // [esp+1Ch] [ebp-Ch]

  tmpf = tmpfname(0, 0)->ptr;
  f = fopen(tmpf, "w");
  if ( f )
  {
    saveBuffer(CurrentTab->currentBuffer, f, 1);
    fclose(f);
    fmTerm();
    v1 = cur_real_linenumber(CurrentTab->currentBuffer);
    v2 = shell_quote(tmpf);
    v3 = myEditor(Editor, v2, v1);
    system(v3->ptr);
    fmInit();
    unlink(tmpf);
    displayBuffer(CurrentTab->currentBuffer, 1);
  }
  else
  {
    v0 = Sprintf("Can't open %s", tmpf);
    _ZN10bdInetAddrC2Ej(v0->ptr, 1);
  }
}

//----- (08050D0F) --------------------------------------------------------
void mark()
{
  if ( use_mark )
  {
    if ( CurrentTab->currentBuffer->firstLine )
    {
      CurrentTab->currentBuffer->currentLine->propBuf[CurrentTab->currentBuffer->pos] ^= 1;
      displayBuffer(CurrentTab->currentBuffer, 1);
    }
  }
}

//----- (08050D8F) --------------------------------------------------------
void nextMk()
{
  int i; // [esp+18h] [ebp-10h]
  Line *l; // [esp+1Ch] [ebp-Ch]

  if ( use_mark && CurrentTab->currentBuffer->firstLine )
  {
    i = CurrentTab->currentBuffer->pos + 1;
    l = CurrentTab->currentBuffer->currentLine;
    if ( l->len <= i )
    {
      i = 0;
      l = l->next;
    }
    while ( l )
    {
      while ( l->len > i )
      {
        if ( (l->propBuf[i] & 1) != 0 )
        {
          CurrentTab->currentBuffer->currentLine = l;
          CurrentTab->currentBuffer->pos = i;
          arrangeCursor(CurrentTab->currentBuffer);
          displayBuffer(CurrentTab->currentBuffer, 0);
          return;
        }
        ++i;
      }
      l = l->next;
      i = 0;
    }
    disp_message("No mark exist after here", 1);
  }
}

//----- (08050E9C) --------------------------------------------------------
void prevMk()
{
  int i; // [esp+18h] [ebp-10h]
  Line *l; // [esp+1Ch] [ebp-Ch]

  if ( use_mark && CurrentTab->currentBuffer->firstLine )
  {
    i = CurrentTab->currentBuffer->pos - 1;
    l = CurrentTab->currentBuffer->currentLine;
    if ( i < 0 )
    {
      l = l->prev;
      if ( l )
        i = l->len - 1;
    }
    while ( l )
    {
      while ( i >= 0 )
      {
        if ( (l->propBuf[i] & 1) != 0 )
        {
          CurrentTab->currentBuffer->currentLine = l;
          CurrentTab->currentBuffer->pos = i;
          arrangeCursor(CurrentTab->currentBuffer);
          displayBuffer(CurrentTab->currentBuffer, 0);
          return;
        }
        --i;
      }
      l = l->prev;
      if ( l )
        i = l->len - 1;
    }
    disp_message("No mark exist before here", 1);
  }
}

//----- (08050FB6) --------------------------------------------------------
void reMark()
{
  char *v0; // eax
  char *p2; // [esp+2Ch] [ebp-1Ch] BYREF
  char *p1; // [esp+30h] [ebp-18h] BYREF
  char *p; // [esp+34h] [ebp-14h]
  char *str; // [esp+38h] [ebp-10h]
  Line *l; // [esp+3Ch] [ebp-Ch]

  if ( use_mark )
  {
    str = searchKeyData();
    if ( str && *str || (str = inputLineHistSearch("(Mark)Regexp: ", MarkString, 16, TextHist, 0)) != 0 && *str )
    {
      v0 = conv_search_string(str, DisplayCharset);
      str = regexCompile(v0, 1);
      if ( str )
      {
        disp_message(str, 1);
      }
      else
      {
        MarkString = 0;
        for ( l = CurrentTab->currentBuffer->firstLine; l; l = l->next )
        {
          for ( p = l->lineBuf; __gmp_vfprintf(p, &l->lineBuf[l->len] - p, l->lineBuf == p) == 1; p = p2 )
          {
            matchedPosition(&p1, &p2);
            l->propBuf[p1 - l->lineBuf] |= 1;
          }
        }
        displayBuffer(CurrentTab->currentBuffer, 1);
      }
    }
    else
    {
      displayBuffer(CurrentTab->currentBuffer, 0);
    }
  }
}

//----- (0805117F) --------------------------------------------------------
Buffer *__cdecl loadNormalBuf(Buffer *buf, int renderframe)
{
  pushBuffer(buf);
  if ( renderframe && RenderFrame && CurrentTab->currentBuffer->frameset )
    rFrame();
  return buf;
}

//----- (080511BD) --------------------------------------------------------
Buffer *__cdecl loadLink(char *url, char *target, char *referer, FormList *request)
{
  Str v4; // eax
  Str v5; // eax
  Str v7; // eax
  Buffer *v8; // ebx
  frameset *v9; // eax
  Buffer *v10; // ebx
  ParsedURL *v11; // [esp+4h] [ebp-74h]
  ParsedURL pu; // [esp+28h] [ebp-50h] BYREF
  char *label; // [esp+50h] [ebp-28h]
  Anchor *al_0; // [esp+54h] [ebp-24h]
  ParsedURL *base; // [esp+5Ch] [ebp-1Ch]
  int flag; // [esp+60h] [ebp-18h]
  frameset_element *f_element; // [esp+64h] [ebp-14h]
  Buffer *nfbuf; // [esp+68h] [ebp-10h]
  Buffer *buf; // [esp+6Ch] [ebp-Ch]

  f_element = 0;
  flag = 0;
  v4 = Sprintf("loading %s", url);
  message(v4->ptr, 0, 0);
  refresh();
  base = baseURL(CurrentTab->currentBuffer);
  if ( !base || base->scheme == 4 || base->scheme == 5 )
    referer = (char *)-1;
  if ( !referer )
    referer = parsedURL2Str(&CurrentTab->currentBuffer->currentURL)->ptr;
  v11 = baseURL(CurrentTab->currentBuffer);
  buf = loadGeneralFile(url, v11, referer, flag, request);
  if ( !buf )
  {
    v5 = Sprintf("Can't load %s", url);
    _ZN10bdInetAddrC2Ej(v5->ptr, 0);
    return 0;
  }
  parseURL2(url, &pu, base);
  v7 = parsedURL2Str(&pu);
  pushHashHist(URLHist, v7->ptr);
  if ( buf == (Buffer *)1 )
    return 0;
  if ( !on_target )
    return loadNormalBuf(buf, 1);
  if ( do_download )
    return loadNormalBuf(buf, 0);
  if ( !target )
    return loadNormalBuf(buf, 1);
  if ( !strcmp(target, "_top") )
    return loadNormalBuf(buf, 1);
  if ( (CurrentTab->currentBuffer->bufferprop & 2) == 0 )
    return loadNormalBuf(buf, 1);
  nfbuf = CurrentTab->currentBuffer->linkBuffer[1];
  if ( !nfbuf )
    return loadNormalBuf(buf, 1);
  f_element = search_frame(nfbuf->frameset, target);
  if ( !f_element )
    return loadNormalBuf(buf, 1);
  v8 = CurrentTab->currentBuffer;
  v9 = copyFrameSet(nfbuf->frameset);
  pushFrameTree(&nfbuf->frameQ, v9, v8);
  delBuffer(CurrentTab->currentBuffer);
  CurrentTab->currentBuffer = nfbuf;
  resetFrameElement(f_element, buf, referer, request);
  discardBuffer(buf);
  rFrame();
  al_0 = 0;
  label = pu.label;
  if ( pu.label && f_element->element->attr == 1 )
    al_0 = searchAnchor((AnchorList *)f_element->element[3].name, label);
  if ( !al_0 )
  {
    label = Strnew_m_charp("_", target, 0)->ptr;
    al_0 = searchURLLabel(CurrentTab->currentBuffer, label);
  }
  if ( al_0 )
  {
    gotoLine(CurrentTab->currentBuffer, al_0->start.line);
    if ( label_topline )
    {
      v10 = CurrentTab->currentBuffer;
      v10->topLine = lineSkip(v10, v10->topLine, v10->currentLine->linenumber - v10->topLine->linenumber, 0);
    }
    CurrentTab->currentBuffer->pos = al_0->start.pos;
    arrangeCursor(CurrentTab->currentBuffer);
  }
  displayBuffer(CurrentTab->currentBuffer, 0);
  return buf;
}

//----- (080515BC) --------------------------------------------------------
void __cdecl gotoLabel(char *label)
{
  Str v1; // eax
  Str v2; // eax
  Buffer *v3; // ebx
  int i; // [esp+14h] [ebp-14h]
  Anchor *al_0; // [esp+18h] [ebp-10h]
  Buffer *buf; // [esp+1Ch] [ebp-Ch]

  al_0 = searchURLLabel(CurrentTab->currentBuffer, label);
  if ( al_0 )
  {
    buf = newBuffer(CurrentTab->currentBuffer->width);
    copyBuffer(buf, CurrentTab->currentBuffer);
    for ( i = 0; i <= 4; ++i )
      buf->linkBuffer[i] = 0;
    buf->currentURL.label = allocStr(label, -1);
    v2 = parsedURL2Str(&buf->currentURL);
    pushHashHist(URLHist, v2->ptr);
    ++*buf->clone;
    pushBuffer(buf);
    gotoLine(CurrentTab->currentBuffer, al_0->start.line);
    if ( label_topline )
    {
      v3 = CurrentTab->currentBuffer;
      v3->topLine = lineSkip(v3, v3->topLine, v3->currentLine->linenumber - v3->topLine->linenumber, 0);
    }
    CurrentTab->currentBuffer->pos = al_0->start.pos;
    arrangeCursor(CurrentTab->currentBuffer);
    displayBuffer(CurrentTab->currentBuffer, 1);
  }
  else
  {
    v1 = Sprintf("%s is not found", label);
    disp_message(v1->ptr, 1);
  }
}

//----- (08051773) --------------------------------------------------------
void followA()
{
  ParsedURL *v0; // eax
  char *v1; // ebx
  Str v2; // eax
  char *v3; // eax
  char *v4; // eax
  Str v5; // eax
  ParsedURL u; // [esp+18h] [ebp-50h] BYREF
  Buffer *buf; // [esp+40h] [ebp-28h]
  Str to; // [esp+44h] [ebp-24h]
  char *url; // [esp+48h] [ebp-20h]
  int map; // [esp+4Ch] [ebp-1Ch]
  int y; // [esp+50h] [ebp-18h] BYREF
  int x; // [esp+54h] [ebp-14h] BYREF
  Anchor *a; // [esp+58h] [ebp-10h]
  Line *l; // [esp+5Ch] [ebp-Ch]

  x = 0;
  y = 0;
  map = 0;
  if ( CurrentTab->currentBuffer->firstLine )
  {
    l = CurrentTab->currentBuffer->currentLine;
    a = retrieveCurrentImg(CurrentTab->currentBuffer);
    if ( a && a->image && a->image->map )
    {
      followForm(0);
    }
    else
    {
      if ( a && a->image && a->image->ismap )
      {
        getMapXY(CurrentTab->currentBuffer, a, &x, &y);
        map = 1;
      }
      a = retrieveCurrentAnchor(CurrentTab->currentBuffer);
      if ( a )
      {
        if ( *a->url == 35 )
        {
          gotoLabel(a->url + 1);
        }
        else
        {
          v0 = baseURL(CurrentTab->currentBuffer);
          parseURL2(a->url, &u, v0);
          v1 = parsedURL2Str(&CurrentTab->currentBuffer->currentURL)->ptr;
          v2 = parsedURL2Str(&u);
          if ( !strcmp(v2->ptr, v1) && u.label )
          {
            gotoLabel(u.label);
          }
          else if ( !strncasecmp(a->url, "mailto:", 7u) && non_null(Mailer) && !strchr(a->url, 63) )
          {
            to = Strnew_charp(a->url + 7);
            fmTerm();
            v3 = file_unquote(to->ptr);
            v4 = shell_quote(v3);
            v5 = myExtCommand(Mailer, v4, 0);
            system(v5->ptr);
            fmInit();
            displayBuffer(CurrentTab->currentBuffer, 1);
            pushHashHist(URLHist, a->url);
          }
          else
          {
            url = a->url;
            if ( map )
              url = Sprintf("%s?%d,%d", a->url, x, y)->ptr;
            if ( check_target
              && open_tab_blank
              && a->target
              && (!strcasecmp(a->target, "_new") || !strcasecmp(a->target, "_blank")) )
            {
              newT();
              buf = CurrentTab->currentBuffer;
              loadLink(url, a->target, a->referer, 0);
              if ( CurrentTab->currentBuffer == buf )
                deleteTab(CurrentTab);
              else
                delBuffer(buf);
              displayBuffer(CurrentTab->currentBuffer, 1);
            }
            else
            {
              loadLink(url, a->target, a->referer, 0);
              displayBuffer(CurrentTab->currentBuffer, 0);
            }
          }
        }
      }
      else
      {
        followForm(0);
      }
    }
  }
}

//----- (08051B2B) --------------------------------------------------------
void bufferA()
{
  on_target = 0;
  followA();
  on_target = 1;
}

//----- (08051B4C) --------------------------------------------------------
void followI()
{
  Str v0; // eax
  ParsedURL *v1; // eax
  Str v2; // eax
  Buffer *buf; // [esp+24h] [ebp-14h]
  Anchor *a; // [esp+28h] [ebp-10h]

  if ( CurrentTab->currentBuffer->firstLine )
  {
    a = retrieveCurrentImg(CurrentTab->currentBuffer);
    if ( a )
    {
      v0 = Sprintf("loading %s", a->url);
      message(v0->ptr, 0, 0);
      refresh();
      v1 = baseURL(CurrentTab->currentBuffer);
      buf = loadGeneralFile(a->url, v1, 0, 0, 0);
      if ( buf )
      {
        if ( buf != (Buffer *)1 )
          pushBuffer(buf);
      }
      else
      {
        v2 = Sprintf("Can't load %s", a->url);
        _ZN10bdInetAddrC2Ej(v2->ptr, 0);
      }
      displayBuffer(CurrentTab->currentBuffer, 0);
    }
  }
}

//----- (08051C66) --------------------------------------------------------
FormItemList *__cdecl save_submit_formlist(FormItemList *src)
{
  FormSelectOptionItem *srcopt; // [esp+10h] [ebp-28h]
  FormSelectOptionItem *curopt; // [esp+14h] [ebp-24h]
  FormSelectOptionItem *opt; // [esp+18h] [ebp-20h]
  FormItemList *ret; // [esp+1Ch] [ebp-1Ch]
  FormItemList *item; // [esp+20h] [ebp-18h]
  FormItemList *srcitem; // [esp+24h] [ebp-14h]
  form_list *srclist; // [esp+28h] [ebp-10h]
  FormList *list; // [esp+2Ch] [ebp-Ch]

  ret = 0;
  if ( !src )
    return 0;
  srclist = src->parent;
  list = (FormList *)GC_malloc(52);
  list->method = srclist->method;
  list->action = Strdup(srclist->action);
  list->charset = srclist->charset;
  list->enctype = srclist->enctype;
  list->nitems = srclist->nitems;
  list->body = srclist->body;
  list->boundary = srclist->boundary;
  list->length = srclist->length;
  for ( srcitem = srclist->item; srcitem; srcitem = srcitem->next )
  {
    item = (FormItemList *)GC_malloc(72);
    item->type = srcitem->type;
    item->name = Strdup(srcitem->name);
    item->value = Strdup(srcitem->value);
    item->checked = srcitem->checked;
    item->accept = srcitem->accept;
    item->size = srcitem->size;
    item->rows = srcitem->rows;
    item->maxlength = srcitem->maxlength;
    item->readonly = srcitem->readonly;
    curopt = 0;
    opt = 0;
    for ( srcopt = srcitem->select_option; srcopt; srcopt = srcopt->next )
    {
      if ( srcopt->checked )
      {
        opt = (FormSelectOptionItem *)GC_malloc(16);
        opt->value = Strdup(srcopt->value);
        opt->label = Strdup(srcopt->label);
        opt->checked = srcopt->checked;
        if ( item->select_option )
        {
          curopt->next = opt;
          curopt = curopt->next;
        }
        else
        {
          curopt = opt;
          item->select_option = opt;
        }
      }
    }
    item->select_option = opt;
    if ( srcitem->label )
      item->label = Strdup(srcitem->label);
    item->parent = list;
    item->next = 0;
    if ( list->lastitem )
    {
      list->lastitem->next = item;
      list->lastitem = item;
    }
    else
    {
      list->lastitem = item;
      list->item = list->lastitem;
    }
    if ( srcitem == src )
      ret = item;
  }
  return ret;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (08051ED7) --------------------------------------------------------
Str __cdecl conv_form_encoding(Str val, FormItemList *fi, Buffer *buf)
{
  wc_ces charset; // [esp+1Ch] [ebp-Ch]

  charset = SystemCharset;
  if ( fi->parent->charset )
  {
    charset = fi->parent->charset;
  }
  else if ( buf->document_charset && buf->document_charset != 256 )
  {
    charset = buf->document_charset;
  }
  return wc_Str_conv_strict(val, InnerCharset, charset);
}

//----- (08051F46) --------------------------------------------------------
void __cdecl query_from_followform(Str *query, FormItemList *fi, int multipart)
{
  form_list *v3; // ebx
  Anchor *v4; // eax
  _Str *v5; // eax
  Str v6; // eax
  _Str *v7; // eax
  Str v8; // eax
  char *v9; // esi
  char *v10; // ebx
  Str v11; // eax
  char *v12; // ebx
  Str v13; // eax
  Anchor *v14; // eax
  _Str *v15; // eax
  _Str *v16; // eax
  _Str *v17; // eax
  _Str *v18; // eax
  _Str *v19; // eax
  _Str *v20; // eax
  _Str *v21; // eax
  _Str *v22; // eax
  Str v23; // eax
  int v24; // edx
  _Str *v25; // eax
  _Str *v26; // eax
  Str v27; // eax
  int v28; // edx
  int y; // [esp+20h] [ebp-18h] BYREF
  int x_0; // [esp+24h] [ebp-14h] BYREF
  FILE *body; // [esp+28h] [ebp-10h]
  FormItemList *f2; // [esp+2Ch] [ebp-Ch]

  body = 0;
  if ( multipart )
  {
    *query = tmpfname(0, 0);
    body = fopen((*query)->ptr, "w");
    if ( !body )
      return;
    fi->parent->body = (*query)->ptr;
    v3 = fi->parent;
    v3->boundary = Sprintf("------------------------------%d%ld%ld%ld", CurrentPid, v3, v3->body, v3->boundary)->ptr;
  }
  *query = Strnew();
  for ( f2 = fi->parent->item; f2; f2 = f2->next )
  {
    if ( f2->name && (f2->name->length || !multipart && !f2->type) )
    {
      switch ( f2->type )
      {
        case 2:
        case 3:
          if ( f2->checked )
            goto LABEL_14;
          break;
        case 4:
        case 7:
          if ( f2 == fi && f2->value )
            goto LABEL_14;
          break;
        case 5:
          continue;
        default:
LABEL_14:
          if ( multipart )
          {
            if ( f2->type == 7 )
            {
              y = 0;
              x_0 = 0;
              v4 = retrieveCurrentImg(CurrentTab->currentBuffer);
              getMapXY(CurrentTab->currentBuffer, v4, &y, &x_0);
              v5 = conv_form_encoding(f2->name, fi, CurrentTab->currentBuffer);
              *query = Strdup(v5);
              Strcat_charp(*query, ".x");
              v6 = Sprintf("%d", y);
              form_write_data(body, fi->parent->boundary, (*query)->ptr, v6->ptr);
              v7 = conv_form_encoding(f2->name, fi, CurrentTab->currentBuffer);
              *query = Strdup(v7);
              Strcat_charp(*query, ".y");
              v8 = Sprintf("%d", x_0);
              form_write_data(body, fi->parent->boundary, (*query)->ptr, v8->ptr);
            }
            else if ( f2->name && f2->name->length > 0 && f2->value )
            {
              *query = conv_form_encoding(f2->value, fi, CurrentTab->currentBuffer);
              if ( f2->type == 11 )
              {
                v9 = wc_Str_conv_strict(f2->value, InnerCharset, SystemCharset)->ptr;
                v10 = (*query)->ptr;
                v11 = conv_form_encoding(f2->name, fi, CurrentTab->currentBuffer);
                form_write_from_file(body, fi->parent->boundary, v11->ptr, v10, v9);
              }
              else
              {
                v12 = (*query)->ptr;
                v13 = conv_form_encoding(f2->name, fi, CurrentTab->currentBuffer);
                form_write_data(body, fi->parent->boundary, v13->ptr, v12);
              }
            }
          }
          else
          {
            if ( f2->type == 7 )
            {
              x_0 = 0;
              y = 0;
              v14 = retrieveCurrentImg(CurrentTab->currentBuffer);
              getMapXY(CurrentTab->currentBuffer, v14, &x_0, &y);
              v15 = conv_form_encoding(f2->name, fi, CurrentTab->currentBuffer);
              v16 = Str_form_quote(v15);
              savexmlstr_0(*query, v16);
              v17 = Sprintf(".x=%d&", x_0);
              savexmlstr_0(*query, v17);
              v18 = conv_form_encoding(f2->name, fi, CurrentTab->currentBuffer);
              v19 = Str_form_quote(v18);
              savexmlstr_0(*query, v19);
              v20 = Sprintf(".y=%d", y);
              savexmlstr_0(*query, v20);
            }
            else
            {
              if ( f2->name && f2->name->length > 0 )
              {
                v21 = conv_form_encoding(f2->name, fi, CurrentTab->currentBuffer);
                v22 = Str_form_quote(v21);
                savexmlstr_0(*query, v22);
                if ( (*query)->length + 1 >= (*query)->area_size )
                  Strgrow(*query);
                v23 = *query;
                v24 = (*query)->length;
                (*query)->ptr[v24] = 61;
                v23->length = v24 + 1;
                (*query)->ptr[(*query)->length] = 0;
              }
              if ( f2->value )
              {
                if ( fi->parent->method == 2 )
                {
                  v25 = Str_form_quote(f2->value);
                }
                else
                {
                  v26 = conv_form_encoding(f2->value, fi, CurrentTab->currentBuffer);
                  v25 = Str_form_quote(v26);
                }
                savexmlstr_0(*query, v25);
              }
            }
            if ( f2->next )
            {
              if ( (*query)->length + 1 >= (*query)->area_size )
                Strgrow(*query);
              v27 = *query;
              v28 = (*query)->length;
              (*query)->ptr[v28] = 38;
              v27->length = v28 + 1;
              (*query)->ptr[(*query)->length] = 0;
            }
          }
          break;
      }
    }
  }
  if ( multipart )
  {
    fprintf(body, "--%s--\r\n", fi->parent->boundary);
    fclose(body);
  }
  else
  {
    while ( (*query)->length > 0 && (*query)->ptr[(*query)->length - 1] == 38 )
      Strshrink(*query, 1);
  }
}

//----- (08052630) --------------------------------------------------------
void submitForm()
{
  followForm(1);
}

//----- (08052644) --------------------------------------------------------
void followForm()
{
  followForm(0);
}

//----- (08052658) --------------------------------------------------------
void __cdecl followForm(int submit)
{
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  int v4; // eax
  FormItemList *v5; // eax
  stat st; // [esp+2Ch] [ebp-8Ch] BYREF
  Buffer *buf; // [esp+84h] [ebp-34h]
  int i; // [esp+88h] [ebp-30h]
  int multipart; // [esp+8Ch] [ebp-2Ch]
  Str tmp2; // [esp+90h] [ebp-28h]
  Str tmp; // [esp+94h] [ebp-24h] BYREF
  FormItemList *f2; // [esp+98h] [ebp-20h]
  FormItemList *fi; // [esp+9Ch] [ebp-1Ch]
  char *p; // [esp+A0h] [ebp-18h]
  Anchor *a2; // [esp+A4h] [ebp-14h]
  Anchor *a; // [esp+A8h] [ebp-10h]
  Line *l; // [esp+ACh] [ebp-Ch]

  multipart = 0;
  if ( CurrentTab->currentBuffer->firstLine )
  {
    l = CurrentTab->currentBuffer->currentLine;
    a = retrieveCurrentForm(CurrentTab->currentBuffer);
    if ( a )
    {
      fi = (FormItemList *)a->url;
      switch ( fi->type )
      {
        case 0:
          if ( submit )
            goto do_submit;
          if ( fi->readonly )
            disp_message_nsec("Read only field!", 0, 1, 1, 0);
          v1 = fi->value ? fi->value->ptr : 0;
          p = inputLineHistSearch("TEXT:", v1, 16, TextHist, 0);
          if ( p )
          {
            if ( !fi->readonly )
            {
              fi->value = Strnew_charp(p);
              formUpdateBuffer(a, CurrentTab->currentBuffer, fi);
              if ( fi->accept || fi->parent->nitems == 1 )
                goto do_submit;
            }
          }
          break;
        case 1:
          if ( submit )
            goto do_submit;
          if ( fi->readonly )
            goto LABEL_44;
          if ( fi->value )
            v3 = fi->value->ptr;
          else
            v3 = 0;
          p = inputLineHistSearch("Password:", v3, 64, 0, 0);
          if ( p )
          {
            fi->value = Strnew_charp(p);
            formUpdateBuffer(a, CurrentTab->currentBuffer, fi);
            if ( fi->accept )
              goto do_submit;
          }
          break;
        case 2:
          if ( submit )
            goto do_submit;
          if ( fi->readonly )
            goto LABEL_44;
          fi->checked = fi->checked == 0;
          formUpdateBuffer(a, CurrentTab->currentBuffer, fi);
          break;
        case 3:
          if ( submit )
            goto do_submit;
          if ( fi->readonly )
LABEL_44:
            disp_message_nsec("Read only field!", 0, 1, 1, 0);
          else
            formRecheckRadio(a, CurrentTab->currentBuffer, fi);
          break;
        case 4:
        case 7:
        case 0xA:
          goto do_submit;
        case 5:
          for ( i = 0; CurrentTab->currentBuffer->formitem->nanchor > i; ++i )
          {
            a2 = &CurrentTab->currentBuffer->formitem->anchors[i];
            f2 = (FormItemList *)a2->url;
            if ( f2->parent == fi->parent && f2->name && f2->value && f2->type != 4 && f2->type != 6 && f2->type != 5 )
            {
              f2->value = f2->init_value;
              f2->checked = f2->init_checked;
              f2->label = f2->init_label;
              f2->selected = f2->init_selected;
              formUpdateBuffer(a2, CurrentTab->currentBuffer, f2);
            }
          }
          break;
        case 8:
          if ( submit )
            goto do_submit;
          if ( formChooseOptionByMenu(
                 fi,
                 a->start.pos
               + CurrentTab->currentBuffer->cursorX
               - CurrentTab->currentBuffer->pos
               + CurrentTab->currentBuffer->rootX,
                 CurrentTab->currentBuffer->rootY + CurrentTab->currentBuffer->cursorY) )
          {
            formUpdateBuffer(a, CurrentTab->currentBuffer, fi);
            if ( fi->parent->nitems == 1 )
              goto do_submit;
          }
          break;
        case 9:
          if ( submit )
            goto do_submit;
          if ( fi->readonly )
            disp_message_nsec("Read only field!", 0, 1, 1, 0);
          input_textarea(fi);
          formUpdateBuffer(a, CurrentTab->currentBuffer, fi);
          break;
        case 0xB:
          if ( !submit )
          {
            if ( fi->readonly )
              disp_message_nsec("Read only field!", 0, 1, 1, 0);
            v2 = fi->value ? fi->value->ptr : 0;
            p = inputLineHistSearch("Filename:", v2, 32, 0, 0);
            if ( !p )
              break;
            if ( fi->readonly )
              break;
            fi->value = Strnew_charp(p);
            formUpdateBuffer(a, CurrentTab->currentBuffer, fi);
            if ( !fi->accept && fi->parent->nitems != 1 )
              break;
          }
do_submit:
          tmp = Strnew();
          tmp2 = Strnew();
          v4 = fi->parent->method == 1 && fi->parent->enctype == 1;
          multipart = v4;
          query_from_followform(&tmp, fi, v4);
          tmp2 = Strdup(fi->parent->action);
          if ( !strcmp(tmp2->ptr, "!CURRENT_URL!") )
          {
            tmp2 = parsedURL2Str(&CurrentTab->currentBuffer->currentURL);
            p = strchr(tmp2->ptr, 63);
            if ( p )
              Strshrink(tmp2, &tmp2->ptr[tmp2->length] - p);
          }
          if ( fi->parent->method )
          {
            if ( fi->parent->method == 1 )
            {
              if ( multipart )
              {
                stat_0(fi->parent->body, (int)&st);
                fi->parent->length = st.st_size;
              }
              else
              {
                fi->parent->body = tmp->ptr;
                fi->parent->length = tmp->length;
              }
              buf = loadLink(tmp2->ptr, a->target, 0, fi->parent);
              if ( multipart )
                unlink(fi->parent->body);
              if ( buf && (buf->bufferprop & 0x20) == 0 )
              {
                v5 = save_submit_formlist(fi);
                buf->form_submit = v5;
              }
            }
            else if ( fi->parent->method == 2
                   && (!strcmp(fi->parent->action->ptr, "map") || !strcmp(fi->parent->action->ptr, "none"))
                   || (CurrentTab->currentBuffer->bufferprop & 8) != 0 )
            {
              do_internal(tmp2->ptr, tmp->ptr);
            }
            else
            {
              _ZN10bdInetAddrC2Ej("Can't send form because of illegal method.", 0);
            }
          }
          else
          {
            p = strchr(tmp2->ptr, 63);
            if ( p )
              Strshrink(tmp2, &tmp2->ptr[tmp2->length] - p);
            Strcat_charp(tmp2, "?");
            savexmlstr_0(tmp2, tmp);
            loadLink(tmp2->ptr, a->target, 0, 0);
          }
          break;
        default:
          break;
      }
      displayBuffer(CurrentTab->currentBuffer, 1);
    }
  }
}

//----- (08052F9E) --------------------------------------------------------
void topA()
{
  int hseq; // [esp+10h] [ebp-18h]
  Anchor *an; // [esp+14h] [ebp-14h]
  BufferPoint *po; // [esp+18h] [ebp-10h]
  HmarkerList *hl; // [esp+1Ch] [ebp-Ch]

  hl = CurrentTab->currentBuffer->hmarklist;
  hseq = 0;
  if ( CurrentTab->currentBuffer->firstLine && hl && hl->nmark )
  {
    if ( hl->nmark >= prec_num )
    {
      if ( prec_num > 0 )
        hseq = prec_num - 1;
    }
    else
    {
      hseq = hl->nmark - 1;
    }
    while ( hl->nmark > hseq )
    {
      po = &hl->marks[hseq];
      an = retrieveAnchor(CurrentTab->currentBuffer->href, po->line, po->pos);
      if ( !an )
        an = retrieveAnchor(CurrentTab->currentBuffer->formitem, po->line, po->pos);
      ++hseq;
      if ( an )
      {
        gotoLine(CurrentTab->currentBuffer, po->line);
        CurrentTab->currentBuffer->pos = po->pos;
        arrangeCursor(CurrentTab->currentBuffer);
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
      }
    }
  }
}

//----- (08053101) --------------------------------------------------------
void lastA()
{
  int hseq; // [esp+10h] [ebp-18h]
  Anchor *an; // [esp+14h] [ebp-14h]
  BufferPoint *po; // [esp+18h] [ebp-10h]
  HmarkerList *hl; // [esp+1Ch] [ebp-Ch]

  hl = CurrentTab->currentBuffer->hmarklist;
  if ( CurrentTab->currentBuffer->firstLine && hl && hl->nmark )
  {
    if ( hl->nmark > prec_num )
    {
      if ( prec_num <= 0 )
        hseq = hl->nmark - 1;
      else
        hseq = hl->nmark - prec_num;
    }
    else
    {
      hseq = 0;
    }
    while ( hseq >= 0 )
    {
      po = &hl->marks[hseq];
      an = retrieveAnchor(CurrentTab->currentBuffer->href, po->line, po->pos);
      if ( !an )
        an = retrieveAnchor(CurrentTab->currentBuffer->formitem, po->line, po->pos);
      --hseq;
      if ( an )
      {
        gotoLine(CurrentTab->currentBuffer, po->line);
        CurrentTab->currentBuffer->pos = po->pos;
        arrangeCursor(CurrentTab->currentBuffer);
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
      }
    }
  }
}

//----- (0805326A) --------------------------------------------------------
void nextA()
{
  nextA(0);
}

//----- (0805327E) --------------------------------------------------------
void prevA()
{
  prevA(0);
}

//----- (08053292) --------------------------------------------------------
void nextVA()
{
  nextA(1);
}

//----- (080532A6) --------------------------------------------------------
void prevVA()
{
  prevA(1);
}

//----- (080532BA) --------------------------------------------------------
void __cdecl nextA(int visited)
{
  ParsedURL *v1; // eax
  Str v2; // eax
  ParsedURL *v3; // eax
  Str v4; // eax
  ParsedURL url; // [esp+14h] [ebp-54h] BYREF
  int hseq; // [esp+3Ch] [ebp-2Ch]
  int n; // [esp+40h] [ebp-28h]
  int y; // [esp+44h] [ebp-24h]
  int x; // [esp+48h] [ebp-20h]
  int i; // [esp+4Ch] [ebp-1Ch]
  Anchor *pan; // [esp+50h] [ebp-18h]
  Anchor *an; // [esp+54h] [ebp-14h]
  BufferPoint *po; // [esp+58h] [ebp-10h]
  HmarkerList *hl; // [esp+5Ch] [ebp-Ch]

  hl = CurrentTab->currentBuffer->hmarklist;
  n = searchKeyNum();
  if ( CurrentTab->currentBuffer->firstLine && hl && hl->nmark )
  {
    an = retrieveCurrentAnchor(CurrentTab->currentBuffer);
    if ( visited != 1 && !an )
      an = retrieveCurrentForm(CurrentTab->currentBuffer);
    y = CurrentTab->currentBuffer->currentLine->linenumber;
    x = CurrentTab->currentBuffer->pos;
    if ( visited == 1 )
      n = hl->nmark;
    for ( i = 0; ; ++i )
    {
      if ( i >= n )
        goto LABEL_34;
      pan = an;
      if ( an )
      {
        if ( an->hseq >= 0 )
          break;
      }
      an = closest_next_anchor(CurrentTab->currentBuffer->href, 0, x, y);
      if ( visited != 1 )
        an = closest_next_anchor(CurrentTab->currentBuffer->formitem, an, x, y);
      if ( !an )
      {
        if ( visited == 1 )
          return;
        an = pan;
LABEL_34:
        if ( visited == 1 )
          return;
_end:
        if ( an )
        {
          if ( an->hseq >= 0 )
          {
            po = &hl->marks[an->hseq];
            gotoLine(CurrentTab->currentBuffer, po->line);
            CurrentTab->currentBuffer->pos = po->pos;
            arrangeCursor(CurrentTab->currentBuffer);
            displayBuffer(CurrentTab->currentBuffer, 0);
          }
        }
        return;
      }
      x = an->start.pos;
      y = an->start.line;
      if ( visited == 1 )
      {
        v3 = baseURL(CurrentTab->currentBuffer);
        parseURL2(an->url, &url, v3);
        v4 = parsedURL2Str(&url);
        if ( getHashHist(URLHist, v4->ptr) )
          goto _end;
      }
LABEL_32:
      ;
    }
    hseq = an->hseq + 1;
    while ( hl->nmark > hseq )
    {
      po = &hl->marks[hseq];
      an = retrieveAnchor(CurrentTab->currentBuffer->href, po->line, po->pos);
      if ( visited != 1 && !an )
        an = retrieveAnchor(CurrentTab->currentBuffer->formitem, po->line, po->pos);
      ++hseq;
      if ( visited == 1 )
      {
        if ( an )
        {
          v1 = baseURL(CurrentTab->currentBuffer);
          parseURL2(an->url, &url, v1);
          v2 = parsedURL2Str(&url);
          if ( getHashHist(URLHist, v2->ptr) )
            goto _end;
        }
      }
      if ( an && an != pan )
        goto LABEL_32;
    }
    if ( visited != 1 )
    {
      an = pan;
      goto _end;
    }
  }
}

//----- (0805363C) --------------------------------------------------------
void __cdecl prevA(int visited)
{
  ParsedURL *v1; // eax
  Str v2; // eax
  ParsedURL *v3; // eax
  Str v4; // eax
  ParsedURL url; // [esp+14h] [ebp-54h] BYREF
  int hseq; // [esp+3Ch] [ebp-2Ch]
  int n; // [esp+40h] [ebp-28h]
  int y; // [esp+44h] [ebp-24h]
  int x; // [esp+48h] [ebp-20h]
  int i; // [esp+4Ch] [ebp-1Ch]
  Anchor *pan; // [esp+50h] [ebp-18h]
  Anchor *an; // [esp+54h] [ebp-14h]
  BufferPoint *po; // [esp+58h] [ebp-10h]
  HmarkerList *hl; // [esp+5Ch] [ebp-Ch]

  hl = CurrentTab->currentBuffer->hmarklist;
  n = searchKeyNum();
  if ( CurrentTab->currentBuffer->firstLine && hl && hl->nmark )
  {
    an = retrieveCurrentAnchor(CurrentTab->currentBuffer);
    if ( visited != 1 && !an )
      an = retrieveCurrentForm(CurrentTab->currentBuffer);
    y = CurrentTab->currentBuffer->currentLine->linenumber;
    x = CurrentTab->currentBuffer->pos;
    if ( visited == 1 )
      n = hl->nmark;
    for ( i = 0; ; ++i )
    {
      if ( i >= n )
        goto LABEL_34;
      pan = an;
      if ( an )
      {
        if ( an->hseq >= 0 )
          break;
      }
      an = closest_prev_anchor(CurrentTab->currentBuffer->href, 0, x, y);
      if ( visited != 1 )
        an = closest_prev_anchor(CurrentTab->currentBuffer->formitem, an, x, y);
      if ( !an )
      {
        if ( visited == 1 )
          return;
        an = pan;
LABEL_34:
        if ( visited == 1 )
          return;
_end:
        if ( an )
        {
          if ( an->hseq >= 0 )
          {
            po = &hl->marks[an->hseq];
            gotoLine(CurrentTab->currentBuffer, po->line);
            CurrentTab->currentBuffer->pos = po->pos;
            arrangeCursor(CurrentTab->currentBuffer);
            displayBuffer(CurrentTab->currentBuffer, 0);
          }
        }
        return;
      }
      x = an->start.pos;
      y = an->start.line;
      if ( visited == 1 )
      {
        v3 = baseURL(CurrentTab->currentBuffer);
        parseURL2(an->url, &url, v3);
        v4 = parsedURL2Str(&url);
        if ( getHashHist(URLHist, v4->ptr) )
          goto _end;
      }
LABEL_32:
      ;
    }
    hseq = an->hseq - 1;
    while ( hseq >= 0 )
    {
      po = &hl->marks[hseq];
      an = retrieveAnchor(CurrentTab->currentBuffer->href, po->line, po->pos);
      if ( visited != 1 && !an )
        an = retrieveAnchor(CurrentTab->currentBuffer->formitem, po->line, po->pos);
      --hseq;
      if ( visited == 1 )
      {
        if ( an )
        {
          v1 = baseURL(CurrentTab->currentBuffer);
          parseURL2(an->url, &url, v1);
          v2 = parsedURL2Str(&url);
          if ( getHashHist(URLHist, v2->ptr) )
            goto _end;
        }
      }
      if ( an && an != pan )
        goto LABEL_32;
    }
    if ( visited != 1 )
    {
      an = pan;
      goto _end;
    }
  }
}
// 80538B3: conditional instruction was optimized away because of '%an.4!=0'

//----- (080539BF) --------------------------------------------------------
void __cdecl nextX(int d, int dy)
{
  int v2; // eax
  _Line *v3; // eax
  int v4; // eax
  int n; // [esp+10h] [ebp-28h]
  int y; // [esp+14h] [ebp-24h]
  int x; // [esp+18h] [ebp-20h]
  int i; // [esp+1Ch] [ebp-1Ch]
  Line *l; // [esp+20h] [ebp-18h]
  Anchor *pan; // [esp+24h] [ebp-14h]
  Anchor *an; // [esp+28h] [ebp-10h]
  HmarkerList *hl; // [esp+2Ch] [ebp-Ch]

  hl = CurrentTab->currentBuffer->hmarklist;
  n = searchKeyNum();
  if ( CurrentTab->currentBuffer->firstLine && hl && hl->nmark )
  {
    an = retrieveCurrentAnchor(CurrentTab->currentBuffer);
    if ( !an )
      an = retrieveCurrentForm(CurrentTab->currentBuffer);
    l = CurrentTab->currentBuffer->currentLine;
    x = CurrentTab->currentBuffer->pos;
    y = l->linenumber;
    pan = 0;
    i = 0;
LABEL_32:
    if ( i >= n )
    {
LABEL_33:
      if ( pan )
      {
        gotoLine(CurrentTab->currentBuffer, y);
        CurrentTab->currentBuffer->pos = pan->start.pos;
        arrangeCursor(CurrentTab->currentBuffer);
        displayBuffer(CurrentTab->currentBuffer, 0);
      }
      return;
    }
    if ( an )
    {
      if ( d <= 0 )
        v2 = an->start.pos - 1;
      else
        v2 = an->end.pos;
      x = v2;
    }
    an = 0;
    while ( 1 )
    {
      if ( x < 0 || l->len <= x )
        goto LABEL_20;
      an = retrieveAnchor(CurrentTab->currentBuffer->href, y, x);
      if ( !an )
        an = retrieveAnchor(CurrentTab->currentBuffer->formitem, y, x);
      if ( an )
      {
        pan = an;
LABEL_20:
        if ( !dy || an || (dy <= 0 ? (v3 = l->prev) : (v3 = l->next), (l = v3) == 0) )
        {
          if ( an )
          {
            ++i;
            goto LABEL_32;
          }
          goto LABEL_33;
        }
        if ( d > 0 )
          v4 = 0;
        else
          v4 = v3->len - 1;
        x = v4;
        y = l->linenumber;
      }
      else
      {
        x += d;
      }
    }
  }
}

//----- (08053BD2) --------------------------------------------------------
void __cdecl nextY(int d)
{
  int hseq; // [esp+10h] [ebp-28h]
  int n; // [esp+14h] [ebp-24h]
  int y; // [esp+18h] [ebp-20h]
  int x; // [esp+1Ch] [ebp-1Ch]
  int i; // [esp+20h] [ebp-18h]
  Anchor *pan; // [esp+24h] [ebp-14h]
  Anchor *an; // [esp+28h] [ebp-10h]
  HmarkerList *hl; // [esp+2Ch] [ebp-Ch]

  hl = CurrentTab->currentBuffer->hmarklist;
  n = searchKeyNum();
  if ( CurrentTab->currentBuffer->firstLine && hl && hl->nmark )
  {
    an = retrieveCurrentAnchor(CurrentTab->currentBuffer);
    if ( !an )
      an = retrieveCurrentForm(CurrentTab->currentBuffer);
    x = CurrentTab->currentBuffer->pos;
    y = d + CurrentTab->currentBuffer->currentLine->linenumber;
    pan = 0;
    hseq = -1;
    for ( i = 0; i < n; ++i )
    {
      if ( an )
        hseq = abs32(an->hseq);
      an = 0;
      while ( y >= 0 && CurrentTab->currentBuffer->lastLine->linenumber >= y )
      {
        an = retrieveAnchor(CurrentTab->currentBuffer->href, y, x);
        if ( !an )
          an = retrieveAnchor(CurrentTab->currentBuffer->formitem, y, x);
        if ( an && abs32(an->hseq) != hseq )
        {
          pan = an;
          break;
        }
        y += d;
      }
      if ( !an )
        break;
    }
    if ( pan )
    {
      gotoLine(CurrentTab->currentBuffer, pan->start.line);
      arrangeLine(CurrentTab->currentBuffer);
      displayBuffer(CurrentTab->currentBuffer, 0);
    }
  }
}

//----- (08053DA5) --------------------------------------------------------
void nextL()
{
  nextX(-1, 0);
}

//----- (08053DC1) --------------------------------------------------------
void nextLU()
{
  nextX(-1, -1);
}

//----- (08053DDD) --------------------------------------------------------
void nextR()
{
  nextX(1, 0);
}

//----- (08053DF9) --------------------------------------------------------
void nextRD()
{
  nextX(1, 1);
}

//----- (08053E15) --------------------------------------------------------
void nextD()
{
  nextY(1);
}

//----- (08053E29) --------------------------------------------------------
void nextU()
{
  nextY(-1);
}

//----- (08053E3D) --------------------------------------------------------
void nextBf()
{
  int v0; // eax
  int i; // [esp+18h] [ebp-10h]
  Buffer *buf; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; ; ++i )
  {
    v0 = prec_num ? prec_num : 1;
    if ( v0 <= i )
      break;
    buf = prevBuffer(CurrentTab->firstBuffer, CurrentTab->currentBuffer);
    if ( !buf )
    {
      if ( !i )
        return;
      break;
    }
    CurrentTab->currentBuffer = buf;
  }
  displayBuffer(CurrentTab->currentBuffer, 1);
}

//----- (08053EBF) --------------------------------------------------------
void prevBf()
{
  int v0; // eax
  int i; // [esp+18h] [ebp-10h]
  _Buffer *buf; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; ; ++i )
  {
    v0 = prec_num ? prec_num : 1;
    if ( v0 <= i )
      break;
    buf = CurrentTab->currentBuffer->nextBuffer;
    if ( !buf )
    {
      if ( !i )
        return;
      break;
    }
    CurrentTab->currentBuffer = buf;
  }
  displayBuffer(CurrentTab->currentBuffer, 1);
}

//----- (08053F30) --------------------------------------------------------
int __cdecl checkBackBuffer(Buffer *buf)
{
  int result; // eax
  Buffer *fbuf; // [esp+Ch] [ebp-4h]

  fbuf = buf->linkBuffer[1];
  if ( !fbuf )
    goto LABEL_7;
  if ( fbuf->frameQ )
    return 1;
  if ( RenderFrame && buf->nextBuffer == fbuf )
    result = fbuf->nextBuffer != 0;
  else
LABEL_7:
    result = buf->nextBuffer != 0;
  return result;
}

//----- (08053F9F) --------------------------------------------------------
void backBf()
{
  Buffer *v0; // ebx
  AnchorList *formitem; // [esp+14h] [ebp-24h]
  int currentColumn; // [esp+18h] [ebp-20h]
  int pos; // [esp+1Ch] [ebp-1Ch]
  int top; // [esp+20h] [ebp-18h]
  int linenumber; // [esp+24h] [ebp-14h]
  frameset *fs_0; // [esp+28h] [ebp-10h]
  Buffer *buf; // [esp+2Ch] [ebp-Ch]

  buf = CurrentTab->currentBuffer->linkBuffer[1];
  if ( checkBackBuffer(CurrentTab->currentBuffer) )
  {
    delBuffer(CurrentTab->currentBuffer);
    if ( buf )
    {
      if ( buf->frameQ )
      {
        linenumber = buf->frameQ->linenumber;
        top = buf->frameQ->top_linenumber;
        pos = buf->frameQ->pos;
        currentColumn = buf->frameQ->currentColumn;
        formitem = buf->frameQ->formitem;
        fs_0 = popFrameTree(&buf->frameQ);
        deleteFrameSet(buf->frameset);
        buf->frameset = fs_0;
        if ( CurrentTab->currentBuffer == buf )
        {
          rFrame();
          v0 = CurrentTab->currentBuffer;
          v0->topLine = lineSkip(v0, v0->firstLine, top - 1, 0);
          gotoLine(CurrentTab->currentBuffer, linenumber);
          CurrentTab->currentBuffer->pos = pos;
          CurrentTab->currentBuffer->currentColumn = currentColumn;
          arrangeCursor(CurrentTab->currentBuffer);
          formResetBuffer(CurrentTab->currentBuffer, formitem);
        }
      }
      else if ( RenderFrame && CurrentTab->currentBuffer == buf )
      {
        delBuffer(CurrentTab->currentBuffer);
      }
    }
    displayBuffer(CurrentTab->currentBuffer, 1);
  }
  else if ( close_tab_back && nTab > 0 )
  {
    deleteTab(CurrentTab);
    displayBuffer(CurrentTab->currentBuffer, 1);
  }
  else
  {
    disp_message("Can't back...", 1);
  }
}

//----- (080541B8) --------------------------------------------------------
void deletePrevBuf()
{
  _Buffer *buf; // [esp+1Ch] [ebp-Ch]

  buf = CurrentTab->currentBuffer->nextBuffer;
  if ( buf )
    delBuffer(buf);
}

//----- (080541DF) --------------------------------------------------------
void __cdecl cmd_loadURL(char *url, ParsedURL *current, char *referer, FormList *request)
{
  char *v4; // eax
  char *v5; // eax
  Str v6; // eax
  wc_ces v7; // esi
  wc_ces v8; // ebx
  _Str *v9; // eax
  Str v10; // eax
  Str v11; // eax
  Str to; // [esp+28h] [ebp-10h]
  Buffer *buf; // [esp+2Ch] [ebp-Ch]

  if ( !strncasecmp(url, "mailto:", 7u) && non_null(Mailer) && !strchr(url, 63) )
  {
    to = Strnew_charp(url + 7);
    fmTerm();
    v4 = file_unquote(to->ptr);
    v5 = shell_quote(v4);
    v6 = myExtCommand(Mailer, v5, 0);
    system(v6->ptr);
    fmInit();
    displayBuffer(CurrentTab->currentBuffer, 1);
    pushHashHist(URLHist, url);
  }
  else
  {
    refresh();
    buf = loadGeneralFile(url, current, referer, 0, request);
    if ( buf )
    {
      if ( buf != (Buffer *)1 )
      {
        pushBuffer(buf);
        if ( RenderFrame )
        {
          if ( CurrentTab->currentBuffer->frameset )
            rFrame();
        }
      }
    }
    else
    {
      v7 = InnerCharset;
      v8 = SystemCharset;
      v9 = Strnew_charp(url);
      v10 = wc_Str_conv(v9, v8, v7);
      v11 = Sprintf("Can't load %s", v10->ptr);
      _ZN10bdInetAddrC2Ej(v11->ptr, 0);
    }
    displayBuffer(CurrentTab->currentBuffer, 0);
  }
}

//----- (0805439A) --------------------------------------------------------
void __cdecl goURL0(char *prompt, int relative)
{
  wc_ces v2; // esi
  wc_ces v3; // ebx
  _Str *v4; // eax
  wc_ces v5; // esi
  wc_ces v6; // ebx
  _Str *v7; // eax
  Str v8; // eax
  Str v9; // eax
  ParsedURL p_url; // [esp+28h] [ebp-50h] BYREF
  char *a_url; // [esp+50h] [ebp-28h]
  char *c_url; // [esp+54h] [ebp-24h]
  Anchor *a; // [esp+58h] [ebp-20h]
  Hist *hist; // [esp+5Ch] [ebp-1Ch]
  Buffer *cur_buf; // [esp+60h] [ebp-18h]
  ParsedURL *current; // [esp+64h] [ebp-14h]
  char *referer; // [esp+68h] [ebp-10h]
  char *url; // [esp+6Ch] [ebp-Ch]

  cur_buf = CurrentTab->currentBuffer;
  url = searchKeyData();
  if ( !url )
  {
    hist = copyHist(URLHist);
    current = baseURL(CurrentTab->currentBuffer);
    if ( current )
    {
      c_url = parsedURL2Str(current)->ptr;
      if ( DefaultURLString == 1 )
      {
        url = c_url;
        if ( DecodeURL )
          url = url_unquote_conv(url, 0);
      }
      else
      {
        pushHist(hist, c_url);
      }
    }
    a = retrieveCurrentAnchor(CurrentTab->currentBuffer);
    if ( a )
    {
      parseURL2(a->url, &p_url, current);
      a_url = parsedURL2Str(&p_url)->ptr;
      if ( DefaultURLString == 2 )
      {
        url = a_url;
        if ( DecodeURL )
          url = url_unquote_conv(url, CurrentTab->currentBuffer->document_charset);
      }
      else
      {
        pushHist(hist, a_url);
      }
    }
    url = inputLineHistSearch(prompt, url, 256, hist, 0);
    if ( url )
    {
      while ( *url && (MYCTYPE_MAP[(unsigned __int8)*url] & 2) != 0 )
        ++url;
    }
  }
  if ( url )
  {
    if ( (relative || *url == 35) && CurrentTab->currentBuffer->document_charset )
    {
      v2 = CurrentTab->currentBuffer->document_charset;
      v3 = InnerCharset;
      v4 = Strnew_charp(url);
      url = wc_Str_conv_strict(v4, v3, v2)->ptr;
    }
    else
    {
      v5 = SystemCharset;
      v6 = InnerCharset;
      v7 = Strnew_charp(url);
      url = wc_Str_conv_strict(v7, v6, v5)->ptr;
    }
  }
  if ( url && *url )
  {
    if ( *url == 35 )
    {
      gotoLabel(url + 1);
    }
    else
    {
      if ( relative )
      {
        current = baseURL(CurrentTab->currentBuffer);
        referer = parsedURL2Str(&CurrentTab->currentBuffer->currentURL)->ptr;
      }
      else
      {
        current = 0;
        referer = 0;
      }
      parseURL2(url, &p_url, current);
      v8 = parsedURL2Str(&p_url);
      pushHashHist(URLHist, v8->ptr);
      cmd_loadURL(url, current, referer, 0);
      if ( CurrentTab->currentBuffer != cur_buf )
      {
        v9 = parsedURL2Str(&CurrentTab->currentBuffer->currentURL);
        pushHashHist(URLHist, v9->ptr);
      }
    }
  }
  else
  {
    displayBuffer(CurrentTab->currentBuffer, 1);
  }
}

//----- (080546D7) --------------------------------------------------------
void goURL()
{
  goURL0("Goto URL: ", 0);
}

//----- (080546F3) --------------------------------------------------------
void gorURL()
{
  goURL0("Goto relative URL: ", 1);
}

//----- (0805470F) --------------------------------------------------------
void __cdecl cmd_loadBuffer(Buffer *buf, int prop, int linkid)
{
  if ( buf )
  {
    if ( buf != (Buffer *)1 )
    {
      buf->bufferprop |= (unsigned __int16)prop | 8;
      if ( (buf->bufferprop & 0x10) == 0 )
        copyParsedURL(&buf->currentURL, &CurrentTab->currentBuffer->currentURL);
      if ( linkid != -1 )
      {
        buf->linkBuffer[REV_LB[linkid]] = CurrentTab->currentBuffer;
        CurrentTab->currentBuffer->linkBuffer[linkid] = buf;
      }
      pushBuffer(buf);
    }
  }
  else
  {
    _ZN10bdInetAddrC2Ej("Can't load string", 0);
  }
  displayBuffer(CurrentTab->currentBuffer, 1);
}

//----- (080547E1) --------------------------------------------------------
void ldBmark()
{
  cmd_loadURL(BookmarkFile, 0, (char *)0xFFFFFFFF, 0);
}

//----- (0805480E) --------------------------------------------------------
void adBmark()
{
  char *v0; // ebx
  wc_ces v1; // edi
  wc_ces v2; // esi
  _Str *v3; // eax
  _Str *v4; // eax
  _Str *v5; // eax
  char *v6; // edi
  _Str *v7; // eax
  char *v8; // esi
  _Str *v9; // eax
  Str v10; // eax
  char *v11; // [esp+2Ch] [ebp-2Ch]
  form_list *request; // [esp+38h] [ebp-20h]
  Str tmp; // [esp+3Ch] [ebp-1Ch]

  v0 = wc_ces_to_charset(BookmarkCharset);
  v1 = BookmarkCharset;
  v2 = InnerCharset;
  v3 = Strnew_charp(CurrentTab->currentBuffer->buffername);
  v4 = wc_Str_conv_strict(v3, v2, v1);
  v11 = Str_form_quote(v4)->ptr;
  v5 = parsedURL2Str(&CurrentTab->currentBuffer->currentURL);
  v6 = Str_form_quote(v5)->ptr;
  v7 = Strnew_charp(BookmarkFile);
  v8 = Str_form_quote(v7)->ptr;
  v9 = localCookie();
  v10 = Str_form_quote(v9);
  tmp = Sprintf("mode=panel&cookie=%s&bmark=%s&url=%s&title=%s&charset=%s", v10->ptr, v8, v6, v11, v0);
  request = newFormList(0, "post", 0, 0, 0, 0, 0);
  request->body = tmp->ptr;
  request->length = tmp->length;
  cmd_loadURL("file:///$LIB/w3mbookmark", 0, (char *)0xFFFFFFFF, request);
}

//----- (08054950) --------------------------------------------------------
void ldOpt()
{
  Buffer *v0; // eax

  v0 = load_option_panel();
  cmd_loadBuffer(v0, 16, -1);
}

//----- (08054975) --------------------------------------------------------
void setOpt()
{
  const char *v0; // eax
  char *v; // [esp+28h] [ebp-10h]
  char *opt; // [esp+2Ch] [ebp-Ch]

  CurrentKeyData = 0;
  opt = searchKeyData();
  if ( opt && *opt && strchr(opt, 61) )
    goto LABEL_18;
  if ( opt && *opt )
  {
    v = get_param_option(opt);
    if ( v )
      v0 = v;
    else
      v0 = &def_str;
    opt = Sprintf("%s=%s", opt, v0)->ptr;
  }
  opt = inputLineHistSearch("Set option: ", opt, 16, TextHist, 0);
  if ( opt && *opt )
  {
LABEL_18:
    if ( set_param_option(opt) )
      sync_with_option();
    displayBuffer(CurrentTab->currentBuffer, 4);
  }
  else
  {
    displayBuffer(CurrentTab->currentBuffer, 0);
  }
}

//----- (08054A89) --------------------------------------------------------
void msgs()
{
  Buffer *v0; // eax

  v0 = message_list_panel();
  cmd_loadBuffer(v0, 16, -1);
}

//----- (08054AAE) --------------------------------------------------------
void pginfo()
{
  _Buffer *buf; // [esp+1Ch] [ebp-Ch]
  _Buffer *bufa; // [esp+1Ch] [ebp-Ch]
  Buffer *bufb; // [esp+1Ch] [ebp-Ch]

  buf = CurrentTab->currentBuffer->linkBuffer[3];
  if ( buf )
  {
    CurrentTab->currentBuffer = buf;
    displayBuffer(CurrentTab->currentBuffer, 0);
  }
  else
  {
    bufa = CurrentTab->currentBuffer->linkBuffer[2];
    if ( bufa )
      delBuffer(bufa);
    bufb = page_info_panel(CurrentTab->currentBuffer);
    cmd_loadBuffer(bufb, 0, 2);
  }
}

//----- (08054B3C) --------------------------------------------------------
void __cdecl follow_map(parsed_tagarg *arg)
{
  ParsedURL *v1; // eax
  Str v2; // eax
  char *v3; // ebx
  ParsedURL *v4; // eax
  char *v5; // ebx
  ParsedURL *v6; // eax
  ParsedURL p_url; // [esp+20h] [ebp-48h] BYREF
  Buffer *buf; // [esp+48h] [ebp-20h]
  int y; // [esp+4Ch] [ebp-1Ch]
  int x; // [esp+50h] [ebp-18h]
  MapArea *a; // [esp+54h] [ebp-14h]
  Anchor *an; // [esp+58h] [ebp-10h]
  char *name; // [esp+5Ch] [ebp-Ch]

  name = tag_get_value(arg, "link");
  an = retrieveCurrentImg(CurrentTab->currentBuffer);
  x = CurrentTab->currentBuffer->cursorX + CurrentTab->currentBuffer->rootX;
  y = CurrentTab->currentBuffer->cursorY + CurrentTab->currentBuffer->rootY;
  a = follow_map_menu(CurrentTab->currentBuffer, name, an, x, y);
  if ( a && a->url && *a->url )
  {
    if ( *a->url == 35 )
    {
      gotoLabel(a->url + 1);
    }
    else
    {
      v1 = baseURL(CurrentTab->currentBuffer);
      parseURL2(a->url, &p_url, v1);
      v2 = parsedURL2Str(&p_url);
      pushHashHist(URLHist, v2->ptr);
      if ( check_target
        && open_tab_blank
        && a->target
        && (!strcasecmp(a->target, "_new") || !strcasecmp(a->target, "_blank")) )
      {
        newT();
        buf = CurrentTab->currentBuffer;
        v3 = parsedURL2Str(&CurrentTab->currentBuffer->currentURL)->ptr;
        v4 = baseURL(CurrentTab->currentBuffer);
        cmd_loadURL(a->url, v4, v3, 0);
        if ( CurrentTab->currentBuffer == buf )
          deleteTab(CurrentTab);
        else
          delBuffer(buf);
        displayBuffer(CurrentTab->currentBuffer, 1);
      }
      else
      {
        v5 = parsedURL2Str(&CurrentTab->currentBuffer->currentURL)->ptr;
        v6 = baseURL(CurrentTab->currentBuffer);
        cmd_loadURL(a->url, v6, v5, 0);
      }
    }
  }
}

//----- (08054DB5) --------------------------------------------------------
void linkMn()
{
  ParsedURL *v0; // eax
  Str v1; // eax
  char *v2; // ebx
  ParsedURL *v3; // eax
  ParsedURL p_url; // [esp+14h] [ebp-34h] BYREF
  LinkList *l; // [esp+3Ch] [ebp-Ch]

  l = link_menu(CurrentTab->currentBuffer);
  if ( l && l->url )
  {
    if ( *l->url == 35 )
    {
      gotoLabel(l->url + 1);
    }
    else
    {
      v0 = baseURL(CurrentTab->currentBuffer);
      parseURL2(l->url, &p_url, v0);
      v1 = parsedURL2Str(&p_url);
      pushHashHist(URLHist, v1->ptr);
      v2 = parsedURL2Str(&CurrentTab->currentBuffer->currentURL)->ptr;
      v3 = baseURL(CurrentTab->currentBuffer);
      cmd_loadURL(l->url, v3, v2, 0);
    }
  }
}

//----- (08054E9D) --------------------------------------------------------
void __cdecl anchorMn(Anchor *(*menu_func)(Buffer *), int go)
{
  BufferPoint *po; // [esp+18h] [ebp-10h]
  Anchor *a; // [esp+1Ch] [ebp-Ch]

  if ( CurrentTab->currentBuffer->href )
  {
    if ( CurrentTab->currentBuffer->hmarklist )
    {
      a = menu_func(CurrentTab->currentBuffer);
      if ( a )
      {
        if ( a->hseq >= 0 )
        {
          po = &CurrentTab->currentBuffer->hmarklist->marks[a->hseq];
          gotoLine(CurrentTab->currentBuffer, po->line);
          CurrentTab->currentBuffer->pos = po->pos;
          arrangeCursor(CurrentTab->currentBuffer);
          displayBuffer(CurrentTab->currentBuffer, 0);
          if ( go )
            followA();
        }
      }
    }
  }
}

//----- (08054F83) --------------------------------------------------------
void accessKey()
{
  anchorMn(accesskey_menu, 1);
}

//----- (08054F9F) --------------------------------------------------------
void listMn()
{
  anchorMn(list_menu, 1);
}

//----- (08054FBB) --------------------------------------------------------
void movlistMn()
{
  anchorMn(list_menu, 0);
}

//----- (08054FD7) --------------------------------------------------------
void linkLst()
{
  Buffer *buf; // [esp+1Ch] [ebp-Ch]

  buf = link_list_panel(CurrentTab->currentBuffer);
  if ( buf )
  {
    buf->document_charset = CurrentTab->currentBuffer->document_charset;
    cmd_loadBuffer(buf, 0, -1);
  }
}

//----- (0805502A) --------------------------------------------------------
void cooLst()
{
  Buffer *buf; // [esp+1Ch] [ebp-Ch]

  buf = cookie_list_panel();
  if ( buf )
    cmd_loadBuffer(buf, 16, -1);
}

//----- (0805505B) --------------------------------------------------------
void ldHist()
{
  Buffer *v0; // eax

  v0 = historyBuffer(URLHist);
  cmd_loadBuffer(v0, 16, -1);
}

//----- (08055088) --------------------------------------------------------
void svA()
{
  CurrentKeyData = 0;
  do_download = 1;
  followA();
  do_download = 0;
}

//----- (080550B3) --------------------------------------------------------
void svI()
{
  CurrentKeyData = 0;
  do_download = 1;
  followI();
  do_download = 0;
}

//----- (080550DE) --------------------------------------------------------
void svBuf()
{
  wc_ces v0; // esi
  wc_ces v1; // ebx
  char *v2; // eax
  _Str *v3; // eax
  Str v4; // eax
  _Str *v5; // eax
  Str v6; // eax
  wc_ces v7; // esi
  wc_ces v8; // ebx
  _Str *v9; // eax
  wc_ces v10; // esi
  wc_ces v11; // ebx
  _Str *v12; // eax
  Str v13; // eax
  Str v14; // eax
  int is_pipe; // [esp+30h] [ebp-18h]
  FILE *f; // [esp+34h] [ebp-14h]
  char *file; // [esp+38h] [ebp-10h]
  char *filea; // [esp+38h] [ebp-10h]
  char *qfile; // [esp+3Ch] [ebp-Ch]

  qfile = 0;
  CurrentKeyData = 0;
  file = searchKeyData();
  if ( file && *file || (qfile = inputLineHistSearch("Save buffer to: ", 0, 128, SaveHist, 0)) != 0 && *qfile )
  {
    v0 = SystemCharset;
    v1 = InnerCharset;
    if ( qfile )
      v2 = qfile;
    else
      v2 = file;
    v3 = Strnew_charp(v2);
    v4 = wc_Str_conv_strict(v3, v1, v0);
    filea = v4->ptr;
    if ( *v4->ptr == 124 )
    {
      is_pipe = 1;
      f = popen(filea + 1, "w");
    }
    else
    {
      if ( qfile )
      {
        v5 = Strnew_charp(qfile);
        v6 = unescape_spaces(v5);
        v7 = SystemCharset;
        v8 = InnerCharset;
        v9 = Strnew_charp(v6->ptr);
        filea = wc_Str_conv_strict(v9, v8, v7)->ptr;
      }
      filea = expandPath(filea);
      if ( checkOverWrite(filea) < 0 )
        goto LABEL_20;
      f = fopen(filea, "w");
      is_pipe = 0;
    }
    if ( !f )
    {
      v10 = InnerCharset;
      v11 = SystemCharset;
      v12 = Strnew_charp(filea);
      v13 = wc_Str_conv(v12, v11, v10);
      v14 = Sprintf("Can't open %s", v13->ptr);
      _ZN10bdInetAddrC2Ej(v14->ptr, 1);
      return;
    }
    saveBuffer(CurrentTab->currentBuffer, f, 1);
    if ( is_pipe )
      pclose(f);
    else
      fclose(f);
  }
LABEL_20:
  displayBuffer(CurrentTab->currentBuffer, 0);
}

//----- (08055329) --------------------------------------------------------
void svSrc()
{
  wc_ces v0; // esi
  wc_ces v1; // ebx
  char *v2; // eax
  _Str *v3; // eax
  char *file; // [esp+1Ch] [ebp-Ch]

  if ( CurrentTab->currentBuffer->sourcefile )
  {
    CurrentKeyData = 0;
    PermitSaveToPipe = 1;
    if ( CurrentTab->currentBuffer->real_scheme == 4 )
    {
      v0 = InnerCharset;
      v1 = SystemCharset;
      v2 = guess_save_name(0, CurrentTab->currentBuffer->currentURL.real_file);
      v3 = Strnew_charp(v2);
      file = wc_Str_conv(v3, v1, v0)->ptr;
    }
    else
    {
      file = guess_save_name(CurrentTab->currentBuffer, CurrentTab->currentBuffer->currentURL.file);
    }
    doFileCopy(CurrentTab->currentBuffer->sourcefile, file, 0);
    PermitSaveToPipe = 0;
    displayBuffer(CurrentTab->currentBuffer, 0);
  }
}

//----- (08055427) --------------------------------------------------------
void __cdecl peekURL(int only_img)
{
  Anchor *v1; // eax
  Anchor *v2; // eax
  char *v3; // eax
  ParsedURL *v4; // eax
  char *v5; // eax
  ParsedURL pu; // [esp+10h] [ebp-38h] BYREF
  Lineprop *pp; // [esp+38h] [ebp-10h] BYREF
  Anchor *a; // [esp+3Ch] [ebp-Ch]

  if ( CurrentTab->currentBuffer->firstLine )
  {
    if ( CurrentKey == prev_key && s_15239 )
    {
      if ( s_15239->length - offset_15242 < COLS )
      {
        if ( s_15239->length <= offset_15242 )
          offset_15242 = 0;
      }
      else
      {
        ++offset_15242;
      }
    }
    else
    {
      offset_15242 = 0;
      s_15239 = 0;
      if ( only_img )
        v1 = 0;
      else
        v1 = retrieveCurrentAnchor(CurrentTab->currentBuffer);
      a = v1;
      if ( !v1 )
      {
        if ( only_img )
          v2 = 0;
        else
          v2 = retrieveCurrentForm(CurrentTab->currentBuffer);
        a = v2;
        if ( v2 )
        {
          v3 = form2str((FormItemList *)a->url);
          s_15239 = Strnew_charp(v3);
        }
        else
        {
          a = retrieveCurrentImg(CurrentTab->currentBuffer);
          if ( !a )
            return;
        }
      }
      if ( !s_15239 )
      {
        v4 = baseURL(CurrentTab->currentBuffer);
        parseURL2(a->url, &pu, v4);
        s_15239 = parsedURL2Str(&pu);
      }
      if ( DecodeURL )
      {
        v5 = url_unquote_conv(s_15239->ptr, CurrentTab->currentBuffer->document_charset);
        s_15239 = Strnew_charp(v5);
      }
      s_15239 = checkType(s_15239, &pp, 0);
      p_15240 = (Lineprop *)GC_malloc_atomic(2 * s_15239->length);
      bcopy(pp, p_15240, 2 * s_15239->length);
    }
    n_15243 = searchKeyNum();
    if ( n_15243 > 1 && s_15239->length > (n_15243 - 1) * (COLS - 1) )
      offset_15242 = (n_15243 - 1) * (COLS - 1);
    while ( s_15239->length > offset_15242 && (p_15240[offset_15242] & 0x400) != 0 )
      ++offset_15242;
    disp_message_nomouse(&s_15239->ptr[offset_15242], 1);
  }
}
// 804A51C: using guessed type int __cdecl GC_malloc_atomic(_DWORD);

//----- (080556C8) --------------------------------------------------------
void peekURL()
{
  peekURL(0);
}

//----- (080556DC) --------------------------------------------------------
void peekIMG()
{
  peekURL(1);
}

//----- (080556F0) --------------------------------------------------------
Str currentURL()
{
  Str result; // eax

  if ( (CurrentTab->currentBuffer->bufferprop & 8) != 0 )
    result = Strnew_size(0);
  else
    result = parsedURL2Str(&CurrentTab->currentBuffer->currentURL);
  return result;
}

//----- (0805572F) --------------------------------------------------------
void curURL()
{
  char *v0; // eax
  Lineprop *pp; // [esp+1Ch] [ebp-Ch] BYREF

  if ( (CurrentTab->currentBuffer->bufferprop & 8) == 0 )
  {
    if ( CurrentKey == prev_key && s_15396 )
    {
      if ( s_15396->length - offset_15399 < COLS )
      {
        if ( s_15396->length <= offset_15399 )
          offset_15399 = 0;
      }
      else
      {
        ++offset_15399;
      }
    }
    else
    {
      offset_15399 = 0;
      s_15396 = currentURL();
      if ( DecodeURL )
      {
        v0 = url_unquote_conv(s_15396->ptr, 0);
        s_15396 = Strnew_charp(v0);
      }
      s_15396 = checkType(s_15396, &pp, 0);
      p_15397 = (Lineprop *)GC_malloc_atomic(2 * s_15396->length);
      bcopy(pp, p_15397, 2 * s_15396->length);
    }
    n_15400 = searchKeyNum();
    if ( n_15400 > 1 && s_15396->length > (n_15400 - 1) * (COLS - 1) )
      offset_15399 = (n_15400 - 1) * (COLS - 1);
    while ( s_15396->length > offset_15399 && (p_15397[offset_15399] & 0x400) != 0 )
      ++offset_15399;
    disp_message_nomouse(&s_15396->ptr[offset_15399], 1);
  }
}
// 804A51C: using guessed type int __cdecl GC_malloc_atomic(_DWORD);

//----- (08055906) --------------------------------------------------------
void vwSrc()
{
  wc_ces v0; // eax
  int v1; // eax
  int v2; // eax
  Str tmpf; // [esp+1Ch] [ebp-1Ch]
  FILE *f; // [esp+20h] [ebp-18h]
  wc_ces old_charset; // [esp+24h] [ebp-14h]
  _Buffer *buf; // [esp+28h] [ebp-10h]
  Buffer *bufa; // [esp+28h] [ebp-10h]
  wc_bool old_fix_width_conv; // [esp+2Fh] [ebp-9h]

  if ( CurrentTab->currentBuffer->type && (CurrentTab->currentBuffer->bufferprop & 2) == 0 )
  {
    buf = CurrentTab->currentBuffer->linkBuffer[4];
    if ( buf || (buf = CurrentTab->currentBuffer->linkBuffer[4]) != 0 )
    {
      CurrentTab->currentBuffer = buf;
      displayBuffer(CurrentTab->currentBuffer, 0);
      return;
    }
    if ( !CurrentTab->currentBuffer->sourcefile )
    {
      if ( !CurrentTab->currentBuffer->pagerSource )
        return;
      if ( strcasecmp(CurrentTab->currentBuffer->type, "text/plain") )
        return;
      tmpf = tmpfname(1, 0);
      f = fopen(tmpf->ptr, "w");
      if ( !f )
        return;
      old_charset = DisplayCharset;
      old_fix_width_conv = WcOption.fix_width_conv;
      if ( CurrentTab->currentBuffer->document_charset == 256 )
        v0 = 0;
      else
        v0 = CurrentTab->currentBuffer->document_charset;
      DisplayCharset = v0;
      WcOption.fix_width_conv = 0;
      saveBufferBody(CurrentTab->currentBuffer, f, 1);
      DisplayCharset = old_charset;
      WcOption.fix_width_conv = old_fix_width_conv;
      fclose(f);
      CurrentTab->currentBuffer->sourcefile = tmpf->ptr;
    }
    if ( showLineNum )
      v1 = 6;
    else
      v1 = 1;
    v2 = COLS - v1;
    if ( v2 < 0 )
      v2 = 0;
    bufa = newBuffer(v2);
    if ( is_html_type(CurrentTab->currentBuffer->type) )
    {
      bufa->type = "text/plain";
      if ( CurrentTab->currentBuffer->real_type && is_html_type(CurrentTab->currentBuffer->real_type) )
        bufa->real_type = "text/plain";
      else
        bufa->real_type = CurrentTab->currentBuffer->real_type;
      bufa->buffername = Sprintf("source of %s", CurrentTab->currentBuffer->buffername)->ptr;
      bufa->linkBuffer[4] = CurrentTab->currentBuffer;
      CurrentTab->currentBuffer->linkBuffer[4] = bufa;
    }
    else
    {
      if ( strcasecmp(CurrentTab->currentBuffer->type, "text/plain") )
        return;
      bufa->type = "text/html";
      if ( CurrentTab->currentBuffer->real_type && !strcasecmp(CurrentTab->currentBuffer->real_type, "text/plain") )
        bufa->real_type = "text/html";
      else
        bufa->real_type = CurrentTab->currentBuffer->real_type;
      bufa->buffername = Sprintf("HTML view of %s", CurrentTab->currentBuffer->buffername)->ptr;
      bufa->linkBuffer[4] = CurrentTab->currentBuffer;
      CurrentTab->currentBuffer->linkBuffer[4] = bufa;
    }
    bufa->currentURL = CurrentTab->currentBuffer->currentURL;
    bufa->real_scheme = CurrentTab->currentBuffer->real_scheme;
    bufa->filename = CurrentTab->currentBuffer->filename;
    bufa->sourcefile = CurrentTab->currentBuffer->sourcefile;
    bufa->header_source = CurrentTab->currentBuffer->header_source;
    bufa->search_header = CurrentTab->currentBuffer->search_header;
    bufa->document_charset = CurrentTab->currentBuffer->document_charset;
    bufa->clone = CurrentTab->currentBuffer->clone;
    ++*bufa->clone;
    bufa->need_reshape = 1;
    reshapeBuffer(bufa);
    pushBuffer(bufa);
    displayBuffer(CurrentTab->currentBuffer, 0);
  }
}

//----- (08055DB6) --------------------------------------------------------
void reload()
{
  TabBuffer *v0; // ebx
  TabBuffer *v1; // ebx
  Buffer sbuf; // [esp+28h] [ebp-180h] BYREF
  stat st; // [esp+12Ch] [ebp-7Ch] BYREF
  Str query; // [esp+184h] [ebp-24h] BYREF
  int multipart; // [esp+188h] [ebp-20h]
  FormList *request; // [esp+18Ch] [ebp-1Ch]
  Str url; // [esp+190h] [ebp-18h]
  wc_ces old_charset; // [esp+194h] [ebp-14h]
  Buffer *fbuf; // [esp+198h] [ebp-10h]
  Buffer *buf; // [esp+19Ch] [ebp-Ch]

  fbuf = 0;
  if ( (CurrentTab->currentBuffer->bufferprop & 8) == 0 )
  {
    if ( CurrentTab->currentBuffer->currentURL.scheme == 4 && !strcmp(CurrentTab->currentBuffer->currentURL.file, "-") )
    {
      _ZN10bdInetAddrC2Ej("Can't reload stdin", 1);
      return;
    }
    copyBuffer(&sbuf, CurrentTab->currentBuffer);
    if ( (CurrentTab->currentBuffer->bufferprop & 2) != 0 && (fbuf = CurrentTab->currentBuffer->linkBuffer[1]) != 0 )
    {
      if ( fmInitialized )
      {
        message("Rendering frame", 0, 0);
        refresh();
      }
      buf = renderFrame(fbuf, 1);
      if ( !buf )
        goto LABEL_13;
      if ( fbuf->linkBuffer[0] )
      {
        if ( buf->sourcefile
          && fbuf->linkBuffer[0]->sourcefile
          && !strcmp(buf->sourcefile, fbuf->linkBuffer[0]->sourcefile) )
        {
          fbuf->linkBuffer[0]->sourcefile = 0;
        }
        delBuffer(fbuf->linkBuffer[0]);
      }
      fbuf->linkBuffer[0] = buf;
      buf->linkBuffer[1] = fbuf;
      pushBuffer(buf);
      CurrentTab->currentBuffer = buf;
      if ( CurrentTab->currentBuffer->firstLine )
      {
        CurrentTab->currentBuffer->rootX = sbuf.rootX;
        CurrentTab->currentBuffer->rootY = sbuf.rootY;
        CurrentTab->currentBuffer->COLS = sbuf.COLS;
        CurrentTab->currentBuffer->LINES = sbuf.LINES;
        restorePosition(CurrentTab->currentBuffer, &sbuf);
      }
    }
    else
    {
      if ( CurrentTab->currentBuffer->frameset )
        fbuf = CurrentTab->currentBuffer->linkBuffer[0];
      multipart = 0;
      if ( CurrentTab->currentBuffer->form_submit )
      {
        request = CurrentTab->currentBuffer->form_submit->parent;
        if ( request->method == 1 && request->enctype == 1 )
        {
          multipart = 1;
          query_from_followform(&query, CurrentTab->currentBuffer->form_submit, 1);
          stat_0(request->body, (int)&st);
          request->length = st.st_size;
        }
      }
      else
      {
        request = 0;
      }
      url = parsedURL2Str(&CurrentTab->currentBuffer->currentURL);
      message("Reloading...", 0, 0);
      refresh();
      old_charset = DocumentCharset;
      if ( CurrentTab->currentBuffer->document_charset != 256 )
        DocumentCharset = CurrentTab->currentBuffer->document_charset;
      SearchHeader[0] = CurrentTab->currentBuffer->search_header;
      DefaultType = CurrentTab->currentBuffer->real_type;
      buf = loadGeneralFile(url->ptr, 0, (char *)0xFFFFFFFF, 1, request);
      DocumentCharset = old_charset;
      SearchHeader[0] = 0;
      DefaultType = 0;
      if ( multipart )
        unlink(request->body);
      if ( !buf )
      {
        _ZN10bdInetAddrC2Ej("Can't reload...", 1);
        return;
      }
      if ( buf == (Buffer *)1 )
      {
LABEL_13:
        displayBuffer(CurrentTab->currentBuffer, 0);
        return;
      }
      if ( fbuf )
      {
        v0 = CurrentTab;
        v0->firstBuffer = deleteBuffer(CurrentTab->firstBuffer, fbuf);
      }
      repBuffer(CurrentTab->currentBuffer, buf);
      if ( buf->type
        && sbuf.type
        && (!strcasecmp(buf->type, "text/plain") && is_html_type(sbuf.type)
         || is_html_type(buf->type) && !strcasecmp(sbuf.type, "text/plain")) )
      {
        vwSrc();
        if ( CurrentTab->currentBuffer != buf )
        {
          v1 = CurrentTab;
          v1->firstBuffer = deleteBuffer(CurrentTab->firstBuffer, buf);
        }
      }
      CurrentTab->currentBuffer->search_header = sbuf.search_header;
      CurrentTab->currentBuffer->form_submit = sbuf.form_submit;
      if ( CurrentTab->currentBuffer->firstLine )
      {
        CurrentTab->currentBuffer->rootX = sbuf.rootX;
        CurrentTab->currentBuffer->rootY = sbuf.rootY;
        CurrentTab->currentBuffer->COLS = sbuf.COLS;
        CurrentTab->currentBuffer->LINES = sbuf.LINES;
        restorePosition(CurrentTab->currentBuffer, &sbuf);
      }
    }
    displayBuffer(CurrentTab->currentBuffer, 1);
    return;
  }
  if ( !strcmp(CurrentTab->currentBuffer->buffername, "Download List Panel") )
    ldDL();
  else
    _ZN10bdInetAddrC2Ej("Can't reload...", 1);
}

//----- (080563C2) --------------------------------------------------------
void reshape()
{
  CurrentTab->currentBuffer->need_reshape = 1;
  reshapeBuffer(CurrentTab->currentBuffer);
  displayBuffer(CurrentTab->currentBuffer, 1);
}

//----- (08056401) --------------------------------------------------------
void __cdecl docCSet(wc_ces charset)
{
  if ( (CurrentTab->currentBuffer->bufferprop & 8) == 0 )
  {
    if ( CurrentTab->currentBuffer->sourcefile )
    {
      CurrentTab->currentBuffer->document_charset = charset;
      CurrentTab->currentBuffer->need_reshape = 1;
      displayBuffer(CurrentTab->currentBuffer, 1);
    }
    else
    {
      disp_message("Can't reload...", 0);
    }
  }
}

//----- (08056480) --------------------------------------------------------
void __cdecl change_charset(parsed_tagarg *arg)
{
  wc_ces charset; // [esp+18h] [ebp-10h]
  _Buffer *buf; // [esp+1Ch] [ebp-Ch]

  buf = CurrentTab->currentBuffer->linkBuffer[3];
  if ( buf )
  {
    delBuffer(CurrentTab->currentBuffer);
    CurrentTab->currentBuffer = buf;
    if ( (CurrentTab->currentBuffer->bufferprop & 8) == 0 )
    {
      charset = CurrentTab->currentBuffer->document_charset;
      while ( arg )
      {
        if ( !strcmp(arg->arg, "charset") )
          charset = atoi(arg->value);
        arg = arg->next;
      }
      docCSet(charset);
    }
  }
}

//----- (0805652C) --------------------------------------------------------
void docCSet()
{
  char *v0; // eax
  wc_ces charset; // [esp+28h] [ebp-10h]
  char *cs_0; // [esp+2Ch] [ebp-Ch]

  cs_0 = searchKeyData();
  if ( !cs_0 || !*cs_0 )
  {
    v0 = wc_ces_to_charset(CurrentTab->currentBuffer->document_charset);
    cs_0 = inputLineHistSearch("Document charset: ", v0, 16, 0, 0);
  }
  charset = wc_guess_charset_short(cs_0, 0);
  if ( charset )
    docCSet(charset);
  else
    displayBuffer(CurrentTab->currentBuffer, 0);
}

//----- (080565CE) --------------------------------------------------------
void defCSet()
{
  char *v0; // eax
  wc_ces charset; // [esp+28h] [ebp-10h]
  char *cs_0; // [esp+2Ch] [ebp-Ch]

  cs_0 = searchKeyData();
  if ( !cs_0 || !*cs_0 )
  {
    v0 = wc_ces_to_charset(DocumentCharset);
    cs_0 = inputLineHistSearch("Default document charset: ", v0, 16, 0, 0);
  }
  charset = wc_guess_charset_short(cs_0, 0);
  if ( charset )
    DocumentCharset = charset;
  displayBuffer(CurrentTab->currentBuffer, 0);
}

//----- (08056662) --------------------------------------------------------
void __cdecl chkURLBuffer(Buffer *buf)
{
  int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; url_like_pat_15972[i]; ++i )
    find_nvp_node_0(buf, url_like_pat_15972[i]);
  chkExternalURIBuffer(buf);
  buf->check_url |= 1u;
}

//----- (080566C1) --------------------------------------------------------
void chkURL()
{
  chkURLBuffer(CurrentTab->currentBuffer);
  displayBuffer(CurrentTab->currentBuffer, 1);
}

//----- (080566F1) --------------------------------------------------------
void chkWORD()
{
  int epos; // [esp+14h] [ebp-14h] BYREF
  int spos; // [esp+18h] [ebp-10h] BYREF

  if ( getCurWord(CurrentTab->currentBuffer, &spos, &epos, ":\"'`<>()[]{}&|;*?$") )
  {
    reAnchorWord(CurrentTab->currentBuffer, CurrentTab->currentBuffer->currentLine, spos, epos);
    displayBuffer(CurrentTab->currentBuffer, 1);
  }
}

//----- (08056775) --------------------------------------------------------
void __cdecl chkNMIDBuffer(Buffer *buf)
{
  int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; url_like_pat_16013[i]; ++i )
    find_nvp_node_1(buf, url_like_pat_16013[i]);
  buf->check_url |= 2u;
}

//----- (080567C9) --------------------------------------------------------
void chkNMID()
{
  chkNMIDBuffer(CurrentTab->currentBuffer);
  displayBuffer(CurrentTab->currentBuffer, 1);
}

//----- (080567F9) --------------------------------------------------------
void rFrame()
{
  _Buffer *buf; // [esp+1Ch] [ebp-Ch]
  Buffer *bufa; // [esp+1Ch] [ebp-Ch]

  buf = CurrentTab->currentBuffer->linkBuffer[0];
  if ( buf )
    goto LABEL_2;
  if ( CurrentTab->currentBuffer->frameset )
  {
    if ( fmInitialized )
    {
      message("Rendering frame", 0, 0);
      refresh();
    }
    bufa = renderFrame(CurrentTab->currentBuffer, 0);
    if ( bufa )
    {
      bufa->linkBuffer[1] = CurrentTab->currentBuffer;
      CurrentTab->currentBuffer->linkBuffer[0] = bufa;
      pushBuffer(bufa);
      if ( fmInitialized )
      {
        if ( display_ok )
          displayBuffer(CurrentTab->currentBuffer, 1);
      }
    }
    else
    {
      displayBuffer(CurrentTab->currentBuffer, 0);
    }
  }
  else
  {
    buf = CurrentTab->currentBuffer->linkBuffer[1];
    if ( buf )
    {
LABEL_2:
      CurrentTab->currentBuffer = buf;
      displayBuffer(CurrentTab->currentBuffer, 0);
      return;
    }
  }
}

//----- (0805694C) --------------------------------------------------------
void __cdecl invoke_browser(char *url)
{
  wc_ces v1; // esi
  wc_ces v2; // ebx
  _Str *v3; // eax
  char *v4; // [esp+4h] [ebp-34h]
  int len; // [esp+20h] [ebp-18h]
  int bg; // [esp+24h] [ebp-14h]
  char *browser; // [esp+28h] [ebp-10h]
  _Str *cmd; // [esp+2Ch] [ebp-Ch]

  bg = 0;
  CurrentKeyData = 0;
  browser = searchKeyData();
  if ( browser && *browser )
    goto LABEL_14;
  if ( prec_num == 2 )
  {
    browser = ExtBrowser2;
  }
  else if ( prec_num > 2 )
  {
    if ( prec_num == 3 )
      browser = ExtBrowser3;
  }
  else if ( prec_num >= 0 )
  {
    browser = ExtBrowser;
  }
  if ( !browser || !*browser )
  {
    browser = inputLineHistSearch("Browse command: ", 0, 16, 0, 0);
    if ( browser )
    {
LABEL_14:
      v1 = SystemCharset;
      v2 = InnerCharset;
      v3 = Strnew_charp(browser);
      browser = wc_Str_conv_strict(v3, v2, v1)->ptr;
    }
  }
  if ( browser && *browser )
  {
    len = strlen(browser);
    if ( len > 1 && browser[len - 1] == 38 && browser[len - 2] != 92 )
    {
      browser = allocStr(browser, len - 2);
      bg = 1;
    }
    v4 = shell_quote(url);
    cmd = myExtCommand(browser, v4, 0);
    Strremovetrailingspaces(cmd);
    fmTerm();
    mySystem(cmd->ptr, bg);
    fmInit();
    displayBuffer(CurrentTab->currentBuffer, 1);
  }
  else
  {
    displayBuffer(CurrentTab->currentBuffer, 0);
  }
}

//----- (08056B56) --------------------------------------------------------
void extbrz()
{
  Str v0; // eax

  if ( (CurrentTab->currentBuffer->bufferprop & 8) != 0 )
  {
    _ZN10bdInetAddrC2Ej("Can't browse...", 1);
  }
  else if ( CurrentTab->currentBuffer->currentURL.scheme == 4
         && !strcmp(CurrentTab->currentBuffer->currentURL.file, "-") )
  {
    _ZN10bdInetAddrC2Ej("Can't browse stdin", 1);
  }
  else
  {
    v0 = parsedURL2Str(&CurrentTab->currentBuffer->currentURL);
    invoke_browser(v0->ptr);
  }
}

//----- (08056BF2) --------------------------------------------------------
void linkbrz()
{
  ParsedURL *v0; // eax
  Str v1; // eax
  ParsedURL pu; // [esp+14h] [ebp-34h] BYREF
  Anchor *a; // [esp+3Ch] [ebp-Ch]

  if ( CurrentTab->currentBuffer->firstLine )
  {
    a = retrieveCurrentAnchor(CurrentTab->currentBuffer);
    if ( a )
    {
      v0 = baseURL(CurrentTab->currentBuffer);
      parseURL2(a->url, &pu, v0);
      v1 = parsedURL2Str(&pu);
      invoke_browser(v1->ptr);
    }
  }
}

//----- (08056C65) --------------------------------------------------------
void curlno()
{
  long double v0; // fst6
  char *v1; // eax
  int len; // [esp+38h] [ebp-20h]
  int col; // [esp+3Ch] [ebp-1Ch]
  int all; // [esp+40h] [ebp-18h]
  int cur; // [esp+44h] [ebp-14h]
  _Str *tmp; // [esp+48h] [ebp-10h]
  Line *l; // [esp+4Ch] [ebp-Ch]

  l = CurrentTab->currentBuffer->currentLine;
  cur = 0;
  all = 0;
  col = 0;
  len = 0;
  if ( l )
  {
    cur = l->real_linenumber;
    col = CurrentTab->currentBuffer->currentColumn + l->bwidth + CurrentTab->currentBuffer->cursorX + 1;
    while ( l->next && l->next->bpos )
      l = l->next;
    if ( l->width < 0 )
      l->width = calcPosition(l->lineBuf, l->propBuf, l->len, l->len, 0, 0);
    len = l->bwidth + l->width;
  }
  if ( CurrentTab->currentBuffer->lastLine )
    all = CurrentTab->currentBuffer->lastLine->real_linenumber;
  if ( !CurrentTab->currentBuffer->pagerSource || (CurrentTab->currentBuffer->bufferprop & 0x40) != 0 )
  {
    if ( all )
      v0 = (long double)all;
    else
      v0 = 1.0;
    tmp = Sprintf("line %d/%d (%d%%) col %d/%d", cur, all, (int)((long double)cur * 100.0 / v0 + 0.5), col, len);
    Strcat_charp(tmp, "  ");
  }
  else
  {
    tmp = Sprintf("line %d col %d/%d", cur, col, len);
    Strcat_charp(tmp, "  ");
  }
  v1 = wc_ces_to_charset_desc(CurrentTab->currentBuffer->document_charset);
  Strcat_charp(tmp, v1);
  disp_message(tmp->ptr, 0);
}

//----- (08056E77) --------------------------------------------------------
void dispI()
{
  if ( !displayImage )
    initImage();
  if ( activeImage )
  {
    displayImage = 1;
    CurrentTab->currentBuffer->image_flag = 2;
    CurrentTab->currentBuffer->need_reshape = 1;
    displayBuffer(CurrentTab->currentBuffer, 4);
  }
}

//----- (08056ED9) --------------------------------------------------------
void stopI()
{
  if ( activeImage )
  {
    CurrentTab->currentBuffer->image_flag = 1;
    displayBuffer(CurrentTab->currentBuffer, 4);
  }
}

//----- (08056F14) --------------------------------------------------------
int mouse_scroll_line()
{
  int result; // eax

  if ( relative_wheel_scroll )
    result = ((LINES - 1) * relative_wheel_scroll_ratio + 99) / 100;
  else
    result = fixed_wheel_scroll_count;
  return result;
}

//----- (08056F53) --------------------------------------------------------
TabBuffer *__cdecl posTab(int x, int y)
{
  TabBuffer *tab; // [esp+Ch] [ebp-4h]

  if ( mouse_action.menu_str && mouse_action.menu_width > x && !y )
    return (TabBuffer *)1;
  if ( LastTab->y < y )
    return 0;
  for ( tab = FirstTab; tab; tab = tab->nextTab )
  {
    if ( tab->x1 <= x && tab->x2 >= x && tab->y == y )
      return tab;
  }
  return 0;
}

//----- (08056FDA) --------------------------------------------------------
void __cdecl do_mouse_action(int btn, int x, int y)
{
  int cy; // [esp+10h] [ebp-18h]
  int cx_0; // [esp+14h] [ebp-14h]
  int ny; // [esp+18h] [ebp-10h]
  MouseActionMap *map; // [esp+1Ch] [ebp-Ch]
  int btna; // [esp+30h] [ebp+8h]

  map = 0;
  ny = -1;
  if ( nTab > 1 || mouse_action.menu_str )
    ny = LastTab->y + 1;
  if ( btn == 1 )
  {
    btna = 1;
  }
  else if ( btn == 2 )
  {
    btna = 2;
  }
  else
  {
    if ( btn )
      return;
    btna = 0;
  }
  if ( y >= ny )
  {
    if ( LINES - 1 == y )
    {
      if ( mouse_action.lastline_str && x >= 0 && mouse_action.lastline_width > x && mouse_action.lastline_map[btna] )
        map = &mouse_action.lastline_map[btna][x];
    }
    else
    {
      if ( y <= ny )
        return;
      if ( CurrentTab->currentBuffer->cursorY + CurrentTab->currentBuffer->rootY == y
        && (CurrentTab->currentBuffer->cursorX + CurrentTab->currentBuffer->rootX == x
         || WcOption.use_wide
         && CurrentTab->currentBuffer->currentLine
         && (CurrentTab->currentBuffer->currentLine->propBuf[CurrentTab->currentBuffer->pos] & 0x3F00) == 2560
         && CurrentTab->currentBuffer->cursorX + CurrentTab->currentBuffer->rootX + 1 == x) )
      {
        if ( retrieveCurrentAnchor(CurrentTab->currentBuffer) || retrieveCurrentForm(CurrentTab->currentBuffer) )
        {
          map = (MouseActionMap *)(8 * btna + 135792332);
          if ( 8 * btna == -135792332 || !mouse_action.active_map[btna].func )
            map = (MouseActionMap *)(8 * btna + 135792308);
        }
      }
      else
      {
        cx_0 = CurrentTab->currentBuffer->cursorX;
        cy = CurrentTab->currentBuffer->cursorY;
        cursorXY(CurrentTab->currentBuffer, x - CurrentTab->currentBuffer->rootX, y - CurrentTab->currentBuffer->rootY);
        if ( CurrentTab->currentBuffer->cursorY + CurrentTab->currentBuffer->rootY == y
          && (CurrentTab->currentBuffer->cursorX + CurrentTab->currentBuffer->rootX == x
           || WcOption.use_wide
           && CurrentTab->currentBuffer->currentLine
           && (CurrentTab->currentBuffer->currentLine->propBuf[CurrentTab->currentBuffer->pos] & 0x3F00) == 2560
           && CurrentTab->currentBuffer->cursorX + CurrentTab->currentBuffer->rootX + 1 == x)
          && (retrieveCurrentAnchor(CurrentTab->currentBuffer) || retrieveCurrentForm(CurrentTab->currentBuffer)) )
        {
          map = (MouseActionMap *)(8 * btna + 135792308);
        }
        cursorXY(CurrentTab->currentBuffer, cx_0, cy);
      }
    }
  }
  else if ( mouse_action.menu_str && x >= 0 && mouse_action.menu_width > x )
  {
    if ( mouse_action.menu_map[btna] )
      map = &mouse_action.menu_map[btna][x];
  }
  else
  {
    map = (MouseActionMap *)(8 * btna + 135792356);
  }
  if ( !map || !map->func )
    map = (MouseActionMap *)(8 * btna + 135792284);
  if ( map )
  {
    if ( map->func )
    {
      mouse_action.in_action = 1;
      mouse_action.cursorX = x;
      mouse_action.cursorY = y;
      CurrentKey = -1;
      CurrentKeyData = 0;
      CurrentCmdData = map->data;
      map->func();
      CurrentCmdData = 0;
    }
  }
}

//----- (0805743D) --------------------------------------------------------
void __cdecl process_mouse(int btn, int x, int y)
{
  int v3; // ebx
  TabBuffer *v4; // esi
  TabBuffer *v5; // eax
  int cy; // [esp+10h] [ebp-28h]
  int cx_0; // [esp+14h] [ebp-24h]
  Buffer *buf; // [esp+18h] [ebp-20h]
  int ny; // [esp+1Ch] [ebp-1Ch]
  TabBuffer *t; // [esp+20h] [ebp-18h]
  int i; // [esp+24h] [ebp-14h]
  int ia; // [esp+24h] [ebp-14h]
  int ib; // [esp+24h] [ebp-14h]
  int ic; // [esp+24h] [ebp-14h]
  int delta_y; // [esp+28h] [ebp-10h]
  int delta_x; // [esp+2Ch] [ebp-Ch]

  ny = -1;
  if ( nTab > 1 || mouse_action.menu_str )
    ny = LastTab->y + 1;
  switch ( btn )
  {
    case 3:
      switch ( press_btn_16573 )
      {
        case 0:
          if ( press_y_16575 == y && press_x_16574 == x )
            goto LABEL_8;
          if ( ny > 0 && y < ny )
          {
            if ( press_y_16575 >= ny )
            {
              if ( CurrentTab->currentBuffer->rootX <= press_x_16574 )
              {
                buf = CurrentTab->currentBuffer;
                cx_0 = buf->cursorX;
                cy = buf->cursorY;
                t = posTab(x, y);
                if ( t )
                {
                  if ( t == (TabBuffer *)1 )
                    t = 0;
                  cursorXY(
                    CurrentTab->currentBuffer,
                    press_x_16574 - CurrentTab->currentBuffer->rootX,
                    press_y_16575 - CurrentTab->currentBuffer->rootY);
                  if ( CurrentTab->currentBuffer->cursorY == press_y_16575 - CurrentTab->currentBuffer->rootY
                    && (CurrentTab->currentBuffer->cursorX == press_x_16574 - CurrentTab->currentBuffer->rootX
                     || WcOption.use_wide
                     && CurrentTab->currentBuffer->currentLine
                     && (CurrentTab->currentBuffer->currentLine->propBuf[CurrentTab->currentBuffer->pos] & 0x3F00) == 2560
                     && CurrentTab->currentBuffer->cursorX == press_x_16574 - CurrentTab->currentBuffer->rootX - 1) )
                  {
                    displayBuffer(CurrentTab->currentBuffer, 0);
                    followTab(t);
                  }
                  if ( CurrentTab->currentBuffer == buf )
                    cursorXY(CurrentTab->currentBuffer, cx_0, cy);
                }
              }
            }
            else
            {
              if ( press_y_16575 == y )
                v3 = press_x_16574 < x;
              else
                v3 = press_y_16575 < y;
              v4 = posTab(x, y);
              v5 = posTab(press_x_16574, press_y_16575);
              moveTab(v5, v4, v3);
            }
            return;
          }
          delta_x = x - press_x_16574;
          delta_y = y - press_y_16575;
          if ( (int)abs32(x - press_x_16574) < (int)abs32(y - press_y_16575) / 3 )
            delta_x = 0;
          if ( (int)abs32(delta_y) < (int)abs32(delta_x) / 3 )
            delta_y = 0;
          if ( reverse_mouse )
          {
            delta_y = -delta_y;
            delta_x = -delta_x;
          }
          if ( delta_y <= 0 )
          {
            if ( delta_y < 0 )
            {
              prec_num = -delta_y;
              lup1();
            }
          }
          else
          {
            prec_num = delta_y;
            ldown1();
          }
          if ( delta_x <= 0 )
          {
            if ( delta_x < 0 )
            {
              prec_num = -delta_x;
              col1R();
            }
          }
          else
          {
            prec_num = delta_x;
            col1L();
          }
          break;
        case 1:
        case 2:
          if ( press_y_16575 != y || press_x_16574 != x )
            goto LABEL_63;
LABEL_8:
          do_mouse_action(press_btn_16573, x, y);
          goto LABEL_63;
        case 3:
          for ( i = 0; mouse_scroll_line() > i; ++i )
            ldown1();
          goto LABEL_63;
        case 4:
          for ( ia = 0; mouse_scroll_line() > ia; ++ia )
            lup1();
          goto LABEL_63;
        default:
          goto LABEL_63;
      }
      break;
    case 64:
      for ( ib = 0; mouse_scroll_line() > ib; ++ib )
        ldown1();
      break;
    case 65:
      for ( ic = 0; mouse_scroll_line() > ic; ++ic )
        lup1();
      break;
  }
LABEL_63:
  if ( btn == 3 && press_btn_16573 != -1 )
  {
    press_btn_16573 = -1;
  }
  else
  {
    press_btn_16573 = btn;
    press_x_16574 = x;
    press_y_16575 = y;
  }
}

//----- (0805794D) --------------------------------------------------------
void msToggle()
{
  use_mouse = use_mouse == 0;
  displayBuffer(CurrentTab->currentBuffer, 1);
}

//----- (0805798C) --------------------------------------------------------
void mouse()
{
  int ya; // [esp+14h] [ebp-14h]
  int y; // [esp+14h] [ebp-14h]
  int xa; // [esp+18h] [ebp-10h]
  int x; // [esp+18h] [ebp-10h]
  int btn; // [esp+1Ch] [ebp-Ch]

  btn = (unsigned __int8)do_getch() - 32;
  xa = (unsigned __int8)do_getch() - 33;
  x = xa + (xa < 0 ? 0x100 : 0);
  ya = (unsigned __int8)do_getch() - 33;
  y = ya + (ya < 0 ? 0x100 : 0);
  if ( x >= 0 && x < COLS && y >= 0 && LINES - 1 >= y )
    process_mouse(btn, x, y);
}

//----- (08057A20) --------------------------------------------------------
int __cdecl gpm_process_mouse(Gpm_Event_0 *event, void *data)
{
  int v2; // eax
  _WORD *v3; // edx
  _WORD *v4; // eax
  _WORD *v5; // ecx
  _WORD *v6; // eax
  int btn; // [esp+1Ch] [ebp-Ch]

  btn = -1;
  if ( (event->type & 8) != 0 )
  {
    btn = 3;
  }
  else
  {
    if ( (event->type & 4) == 0 )
    {
      byte_817C201 = 2;
      v3 = (_WORD *)gpm_arg;
      v4 = (_WORD *)(gpm_arg + 4);
      *(_WORD *)(gpm_arg + 4) = event->x + gpm_zerobased;
      *v3 = *v4;
      v5 = (_WORD *)(gpm_arg + 2);
      v6 = (_WORD *)(gpm_arg + 6);
      *(_WORD *)(gpm_arg + 6) = event->y + gpm_zerobased;
      *v5 = *v6;
      *(_WORD *)(gpm_arg + 8) = 3;
      ioctl(gpm_consolefd, 0x541Cu, &byte_817C201);
      return 0;
    }
    v2 = event->buttons;
    switch ( v2 )
    {
      case 2:
        btn = 1;
        break;
      case 4:
        btn = 0;
        break;
      case 1:
        btn = 2;
        break;
    }
  }
  process_mouse(btn, event->x - 1, event->y - 1);
  return 0;
}
// 817C1E8: using guessed type int gpm_zerobased;
// 817C201: using guessed type char byte_817C201;
// 817C20C: using guessed type int gpm_arg;

//----- (08057B62) --------------------------------------------------------
void movMs()
{
  if ( mouse_action.in_action && (nTab <= 1 && !mouse_action.menu_str || mouse_action.cursorY >= LastTab->y + 1) )
  {
    if ( mouse_action.cursorX >= CurrentTab->currentBuffer->rootX && mouse_action.cursorY < LINES - 1 )
      cursorXY(
        CurrentTab->currentBuffer,
        mouse_action.cursorX - CurrentTab->currentBuffer->rootX,
        mouse_action.cursorY - CurrentTab->currentBuffer->rootY);
    displayBuffer(CurrentTab->currentBuffer, 0);
  }
}

//----- (08057C30) --------------------------------------------------------
void menuMs()
{
  if ( mouse_action.in_action )
  {
    if ( (nTab > 1 || mouse_action.menu_str) && mouse_action.cursorY < LastTab->y + 1 )
    {
      mouse_action.cursorX -= 2;
    }
    else if ( mouse_action.cursorX >= CurrentTab->currentBuffer->rootX && mouse_action.cursorY < LINES - 1 )
    {
      cursorXY(
        CurrentTab->currentBuffer,
        mouse_action.cursorX - CurrentTab->currentBuffer->rootX,
        mouse_action.cursorY - CurrentTab->currentBuffer->rootY);
      displayBuffer(CurrentTab->currentBuffer, 0);
    }
    mainMn();
  }
}

//----- (08057D0E) --------------------------------------------------------
void tabMs()
{
  TabBuffer *tab; // [esp+1Ch] [ebp-Ch]

  if ( mouse_action.in_action )
  {
    tab = posTab(mouse_action.cursorX, mouse_action.cursorY);
    if ( tab )
    {
      if ( tab != (TabBuffer *)1 )
      {
        CurrentTab = tab;
        displayBuffer(tab->currentBuffer, 1);
      }
    }
  }
}

//----- (08057D6E) --------------------------------------------------------
void closeTMs()
{
  TabBuffer *tab; // [esp+1Ch] [ebp-Ch]

  if ( mouse_action.in_action )
  {
    tab = posTab(mouse_action.cursorX, mouse_action.cursorY);
    if ( tab )
    {
      if ( tab != (TabBuffer *)1 )
      {
        deleteTab(tab);
        displayBuffer(CurrentTab->currentBuffer, 1);
      }
    }
  }
}

//----- (08057DD1) --------------------------------------------------------
void dispVer()
{
  Str v0; // eax

  v0 = Sprintf("w3m version %s", w3m_version);
  disp_message(v0->ptr, 1);
}

//----- (08057E00) --------------------------------------------------------
void wrapToggle()
{
  if ( WrapSearch )
  {
    WrapSearch = 0;
    disp_message("Wrap search off", 1);
  }
  else
  {
    WrapSearch = 1;
    disp_message("Wrap search on", 1);
  }
}

//----- (08057E4F) --------------------------------------------------------
int __cdecl is_wordchar(int c, const char *badchars)
{
  if ( !badchars )
    return MYCTYPE_MAP[(unsigned __int8)c] & 4;
  return (MYCTYPE_MAP[(unsigned __int8)c] & 2) == 0 && !strchr(badchars, c);
}

//----- (08057EAB) --------------------------------------------------------
char *__cdecl getCurWord(Buffer *buf, int *spos, int *epos, const char *badchars)
{
  int e; // [esp+10h] [ebp-18h]
  int b; // [esp+14h] [ebp-14h]
  Line *l; // [esp+18h] [ebp-10h]
  char *p; // [esp+1Ch] [ebp-Ch]

  l = buf->currentLine;
  *spos = 0;
  *epos = 0;
  if ( !l )
    return 0;
  p = l->lineBuf;
  for ( e = buf->pos; e > 0 && !is_wordchar(p[e], badchars); --e )
    ;
  if ( !is_wordchar(p[e], badchars) )
    return 0;
  for ( b = e; b > 0 && is_wordchar(p[b - 1], badchars); --b )
    ;
  while ( l->len > e && is_wordchar(p[e], badchars) )
    ++e;
  *spos = b;
  *epos = e;
  return &p[b];
}

//----- (08057FBD) --------------------------------------------------------
char *__cdecl GetWord(Buffer *buf)
{
  char *result; // eax
  char *p; // [esp+14h] [ebp-14h]
  int e; // [esp+18h] [ebp-10h] BYREF
  int b[3]; // [esp+1Ch] [ebp-Ch] BYREF

  p = getCurWord(buf, b, &e, 0);
  if ( p )
    result = Strnew_charp_n(p, e - b[0])->ptr;
  else
    result = 0;
  return result;
}

//----- (08058013) --------------------------------------------------------
void __cdecl execdict(char *word)
{
  wc_ces v1; // esi
  wc_ces v2; // ebx
  _Str *v3; // eax
  Str v4; // eax
  _Str *v5; // eax
  Str v6; // eax
  Buffer *buf; // [esp+24h] [ebp-14h]
  char *dictcmd; // [esp+28h] [ebp-10h]
  char *w; // [esp+2Ch] [ebp-Ch]

  if ( UseDictCommand
    && word
    && *word
    && (v1 = SystemCharset,
        v2 = InnerCharset,
        v3 = Strnew_charp(word),
        v4 = wc_Str_conv_strict(v3, v2, v1),
        w = v4->ptr,
        *v4->ptr) )
  {
    v5 = Strnew_charp(w);
    v6 = Str_form_quote(v5);
    dictcmd = Sprintf("%s?%s", DictCommand, v6->ptr)->ptr;
    buf = loadGeneralFile(dictcmd, 0, (char *)0xFFFFFFFF, 0, 0);
    if ( buf )
    {
      buf->filename = w;
      buf->buffername = Sprintf("%s %s", "*dictionary*", word)->ptr;
      if ( !buf->type )
        buf->type = "text/plain";
      pushBuffer(buf);
      displayBuffer(CurrentTab->currentBuffer, 1);
    }
    else
    {
      disp_message("Execution failed", 1);
    }
  }
  else
  {
    displayBuffer(CurrentTab->currentBuffer, 0);
  }
}

//----- (0805818A) --------------------------------------------------------
void dictword()
{
  char *v0; // eax

  v0 = inputLineHistSearch("(dictionary)!", (char *)&def_str, 16, 0, 0);
  execdict(v0);
}

//----- (080581C6) --------------------------------------------------------
void dictwordat()
{
  char *v0; // eax

  v0 = GetWord(CurrentTab->currentBuffer);
  execdict(v0);
}

//----- (080581E6) --------------------------------------------------------
void __cdecl set_buffer_environ(Buffer *buf)
{
  Str v1; // eax
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  ParsedURL *v5; // eax
  Str v6; // eax
  ParsedURL *v7; // eax
  Str v8; // eax
  char *v9; // eax
  Str v10; // eax
  Str v11; // eax
  ParsedURL pu; // [esp+1Ch] [ebp-3Ch] BYREF
  char *s; // [esp+44h] [ebp-14h]
  Anchor *a; // [esp+48h] [ebp-10h]
  Line *l; // [esp+4Ch] [ebp-Ch]

  if ( buf )
  {
    if ( buf != prev_buf_17141 )
    {
      set_environ("W3M_SOURCEFILE", buf->sourcefile);
      set_environ("W3M_FILENAME", buf->filename);
      set_environ("W3M_TITLE", buf->buffername);
      v1 = parsedURL2Str(&buf->currentURL);
      set_environ("W3M_URL", v1->ptr);
      if ( buf->real_type )
        v2 = buf->real_type;
      else
        v2 = "unknown";
      set_environ("W3M_TYPE", v2);
      v3 = wc_ces_to_charset(buf->document_charset);
      set_environ("W3M_CHARSET", v3);
    }
    l = buf->currentLine;
    if ( !l || buf == prev_buf_17141 && l == prev_line_17142 && buf->pos == prev_pos_17143 )
    {
      if ( !l )
      {
        set_environ("W3M_CURRENT_WORD", (char *)&def_str);
        set_environ("W3M_CURRENT_LINK", (char *)&def_str);
        set_environ("W3M_CURRENT_IMG", (char *)&def_str);
        set_environ("W3M_CURRENT_FORM", (char *)&def_str);
        set_environ("W3M_CURRENT_LINE", "0");
        set_environ("W3M_CURRENT_COLUMN", "0");
      }
    }
    else
    {
      s = GetWord(buf);
      if ( s )
        v4 = s;
      else
        v4 = (char *)&def_str;
      set_environ("W3M_CURRENT_WORD", v4);
      a = retrieveCurrentAnchor(buf);
      if ( a )
      {
        v5 = baseURL(buf);
        parseURL2(a->url, &pu, v5);
        v6 = parsedURL2Str(&pu);
        set_environ("W3M_CURRENT_LINK", v6->ptr);
      }
      else
      {
        set_environ("W3M_CURRENT_LINK", (char *)&def_str);
      }
      a = retrieveCurrentImg(buf);
      if ( a )
      {
        v7 = baseURL(buf);
        parseURL2(a->url, &pu, v7);
        v8 = parsedURL2Str(&pu);
        set_environ("W3M_CURRENT_IMG", v8->ptr);
      }
      else
      {
        set_environ("W3M_CURRENT_IMG", (char *)&def_str);
      }
      a = retrieveCurrentForm(buf);
      if ( a )
      {
        v9 = form2str((FormItemList *)a->url);
        set_environ("W3M_CURRENT_FORM", v9);
      }
      else
      {
        set_environ("W3M_CURRENT_FORM", (char *)&def_str);
      }
      v10 = Sprintf("%d", l->real_linenumber);
      set_environ("W3M_CURRENT_LINE", v10->ptr);
      v11 = Sprintf("%d", buf->currentColumn + buf->cursorX + 1);
      set_environ("W3M_CURRENT_COLUMN", v11->ptr);
    }
    prev_buf_17141 = buf;
    prev_line_17142 = l;
    prev_pos_17143 = buf->pos;
  }
}

//----- (08058533) --------------------------------------------------------
char *searchKeyData()
{
  char *result; // eax
  const char *data; // [esp+1Ch] [ebp-Ch]

  data = 0;
  if ( CurrentKeyData && *CurrentKeyData )
  {
    data = CurrentKeyData;
  }
  else if ( CurrentCmdData && *CurrentCmdData )
  {
    data = CurrentCmdData;
  }
  else if ( CurrentKey >= 0 )
  {
    data = getKeyData(CurrentKey);
  }
  CurrentKeyData = 0;
  CurrentCmdData = 0;
  if ( data && *data )
    result = allocStr(data, -1);
  else
    result = 0;
  return result;
}

//----- (080585D7) --------------------------------------------------------
int searchKeyNum()
{
  int v0; // eax
  int n; // [esp+18h] [ebp-10h]
  char *d; // [esp+1Ch] [ebp-Ch]

  n = 1;
  d = searchKeyData();
  if ( d )
    n = atoi(d);
  if ( prec_num )
    v0 = prec_num;
  else
    v0 = 1;
  return n * v0;
}

//----- (0805861B) --------------------------------------------------------
void deleteFiles()
{
  char *f; // [esp+18h] [ebp-10h]
  _Buffer *buf; // [esp+1Ch] [ebp-Ch]

  for ( CurrentTab = FirstTab; CurrentTab; CurrentTab = CurrentTab->nextTab )
  {
    while ( CurrentTab->firstBuffer && CurrentTab->firstBuffer != (Buffer *)1 )
    {
      buf = CurrentTab->firstBuffer->nextBuffer;
      discardBuffer(CurrentTab->firstBuffer);
      CurrentTab->firstBuffer = buf;
    }
  }
  while ( 1 )
  {
    f = (char *)popValue((GeneralList *)fileToDelete);
    if ( !f )
      break;
    unlink(f);
  }
}

//----- (080586AC) --------------------------------------------------------
void __cdecl __noreturn w3m_exit(int i)
{
  init_migemo();
  stopDownload();
  deleteFiles();
  disconnectFTP();
  disconnectNews();
  exit(i);
}

//----- (080586D6) --------------------------------------------------------
void execCmd()
{
  char *v0; // eax
  int cmd; // [esp+24h] [ebp-14h]
  char *pa; // [esp+28h] [ebp-10h]
  char *p; // [esp+28h] [ebp-10h]
  char *data[3]; // [esp+2Ch] [ebp-Ch] BYREF

  CurrentKeyData = 0;
  data[0] = searchKeyData();
  if ( data[0] && *data[0]
    || (data[0] = inputLineHistSearch("command [; ...]: ", (char *)&def_str, 16, TextHist, 0)) != 0 )
  {
    while ( *data[0] )
    {
      while ( *data[0] && (MYCTYPE_MAP[(unsigned __int8)*data[0]] & 2) != 0 )
        ++data[0];
      if ( *data[0] == 59 )
      {
        ++data[0];
      }
      else
      {
        pa = getWord(data);
        cmd = getFuncList(pa);
        if ( cmd < 0 )
          break;
        p = getQWord(data);
        CurrentKey = -1;
        CurrentKeyData = 0;
        if ( *p )
          v0 = p;
        else
          v0 = 0;
        CurrentCmdData = v0;
        if ( use_mouse )
          mouse_inactive();
        w3mFuncList[cmd].func();
        if ( use_mouse )
          mouse_active();
        CurrentCmdData = 0;
      }
    }
    displayBuffer(CurrentTab->currentBuffer, 0);
  }
  else
  {
    displayBuffer(CurrentTab->currentBuffer, 0);
  }
}

//----- (08058864) --------------------------------------------------------
void __cdecl SigAlarm(int _dummy)
{
  if ( CurrentAlarm->sec > 0 )
  {
    CurrentKey = -1;
    CurrentKeyData = 0;
    CurrentCmdData = (char *)CurrentAlarm->data;
    if ( use_mouse )
      mouse_inactive();
    w3mFuncList[CurrentAlarm->cmd].func();
    if ( use_mouse )
      mouse_active();
    CurrentCmdData = 0;
    if ( CurrentAlarm->status == 3 )
    {
      CurrentAlarm->sec = 0;
      CurrentAlarm->status = 0;
    }
    if ( CurrentTab->currentBuffer->event )
    {
      if ( CurrentTab->currentBuffer->event->status )
        CurrentAlarm = CurrentTab->currentBuffer->event;
      else
        CurrentTab->currentBuffer->event = 0;
    }
    if ( !CurrentTab->currentBuffer->event )
      CurrentAlarm = &DefaultAlarm;
    if ( CurrentAlarm->sec > 0 )
    {
      mySignal(14, SigAlarm);
      alarm(CurrentAlarm->sec);
    }
  }
}

//----- (08058998) --------------------------------------------------------
void setAlarm()
{
  char *v0; // eax
  char *v1; // eax
  Str v2; // eax
  int cmd; // [esp+24h] [ebp-14h]
  int sec; // [esp+28h] [ebp-10h]
  char *data[3]; // [esp+2Ch] [ebp-Ch] BYREF

  sec = 0;
  cmd = -1;
  CurrentKeyData = 0;
  data[0] = searchKeyData();
  if ( data[0] && *data[0]
    || (data[0] = inputLineHistSearch("(Alarm)sec command: ", (char *)&def_str, 16, TextHist, 0)) != 0 )
  {
    if ( *data[0] )
    {
      v0 = getWord(data);
      sec = atoi(v0);
      if ( sec > 0 )
      {
        v1 = getWord(data);
        cmd = getFuncList(v1);
      }
    }
    if ( cmd < 0 )
    {
      setAlarmEvent(&DefaultAlarm, 0, 0, 0, 0);
    }
    else
    {
      data[0] = getQWord(data);
      setAlarmEvent(&DefaultAlarm, sec, 1, cmd, data[0]);
      v2 = Sprintf("%dsec %s %s", sec, w3mFuncList[cmd].id, data[0]);
      disp_message_nsec(v2->ptr, 0, 1, 0, 1);
    }
    displayBuffer(CurrentTab->currentBuffer, 0);
  }
  else
  {
    displayBuffer(CurrentTab->currentBuffer, 0);
  }
}

//----- (08058B3A) --------------------------------------------------------
AlarmEvent *__cdecl setAlarmEvent(AlarmEvent *event, int sec, __int16 status, int cmd, void *data)
{
  if ( !event )
    event = (AlarmEvent *)GC_malloc(16);
  event->sec = sec;
  event->status = status;
  event->cmd = cmd;
  event->data = data;
  return event;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (08058B86) --------------------------------------------------------
void reinit()
{
  Str v0; // eax
  char *resource; // [esp+1Ch] [ebp-Ch]

  resource = searchKeyData();
  if ( resource )
  {
    if ( !strcasecmp(resource, "CONFIG") || !strcasecmp(resource, "RC") )
    {
      init_rc();
      sync_with_option();
      displayBuffer(CurrentTab->currentBuffer, 4);
    }
    else if ( !strcasecmp(resource, "COOKIE") )
    {
      initCookie();
    }
    else if ( !strcasecmp(resource, "KEYMAP") )
    {
      initKeymap(1);
    }
    else if ( !strcasecmp(resource, "MAILCAP") )
    {
      initMailcap();
    }
    else if ( !strcasecmp(resource, "MOUSE") )
    {
      initMouseAction();
      displayBuffer(CurrentTab->currentBuffer, 4);
    }
    else if ( !strcasecmp(resource, "MENU") )
    {
      initMenu();
    }
    else if ( !strcasecmp(resource, "MIMETYPES") )
    {
      initMimeTypes();
    }
    else if ( !strcasecmp(resource, "URIMETHODS") )
    {
      initURIMethods();
    }
    else
    {
      v0 = Sprintf("Don't know how to reinitialize '%s'", resource);
      _ZN10bdInetAddrC2Ej(v0->ptr, 0);
    }
  }
  else
  {
    init_rc();
    sync_with_option();
    initCookie();
    displayBuffer(CurrentTab->currentBuffer, 4);
  }
}

//----- (08058D3C) --------------------------------------------------------
void defKey()
{
  char *v0; // eax
  const char *data; // [esp+2Ch] [ebp-Ch]

  CurrentKeyData = 0;
  data = searchKeyData();
  if ( data && *data
    || (data = inputLineHistSearch("Key definition: ", (char *)&def_str, 16, TextHist, 0)) != 0 && *data )
  {
    v0 = allocStr(data, -1);
    setKeymap(v0, -1, 1);
    displayBuffer(CurrentTab->currentBuffer, 0);
  }
  else
  {
    displayBuffer(CurrentTab->currentBuffer, 0);
  }
}

//----- (08058E03) --------------------------------------------------------
TabBuffer *newTab()
{
  TabBuffer *n; // [esp+1Ch] [ebp-Ch]

  n = (TabBuffer *)GC_malloc(24);
  if ( !n )
    return 0;
  n->nextTab = 0;
  n->currentBuffer = 0;
  n->firstBuffer = 0;
  return n;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (08058E47) --------------------------------------------------------
void newT()
{
  int i; // [esp+14h] [ebp-14h]
  Buffer *buf; // [esp+18h] [ebp-10h]
  TabBuffer *tag; // [esp+1Ch] [ebp-Ch]

  tag = newTab();
  if ( tag )
  {
    buf = newBuffer(CurrentTab->currentBuffer->width);
    copyBuffer(buf, CurrentTab->currentBuffer);
    buf->nextBuffer = 0;
    for ( i = 0; i <= 4; ++i )
      buf->linkBuffer[i] = 0;
    ++*buf->clone;
    tag->currentBuffer = buf;
    tag->firstBuffer = tag->currentBuffer;
    tag->nextTab = CurrentTab->nextTab;
    tag->prevTab = CurrentTab;
    if ( CurrentTab->nextTab )
      CurrentTab->nextTab->prevTab = tag;
    else
      LastTab = tag;
    CurrentTab->nextTab = tag;
    CurrentTab = tag;
    ++nTab;
  }
}

//----- (08058F3F) --------------------------------------------------------
void newT()
{
  newT();
  displayBuffer(CurrentTab->currentBuffer, 4);
}

//----- (08058F64) --------------------------------------------------------
TabBuffer *__cdecl numTab(int n)
{
  int i; // [esp+8h] [ebp-8h]
  TabBuffer *tab; // [esp+Ch] [ebp-4h]

  if ( !n )
    return CurrentTab;
  if ( n == 1 )
    return FirstTab;
  if ( nTab <= 1 )
    return 0;
  tab = FirstTab;
  for ( i = 1; tab && i < n; ++i )
    tab = tab->nextTab;
  return tab;
}

//----- (08058FC5) --------------------------------------------------------
void calcTabPos()
{
  int v0; // eax
  int iy; // [esp+8h] [ebp-2Ch]
  int ix; // [esp+Ch] [ebp-28h]
  int ny; // [esp+10h] [ebp-24h]
  int nx; // [esp+14h] [ebp-20h]
  int n2; // [esp+1Ch] [ebp-18h]
  int n1; // [esp+20h] [ebp-14h]
  int n1a; // [esp+20h] [ebp-14h]
  int col; // [esp+24h] [ebp-10h]
  TabBuffer *tab; // [esp+30h] [ebp-4h]

  if ( mouse_action.menu_str )
    v0 = mouse_action.menu_width;
  else
    v0 = 0;
  if ( nTab > 0 )
  {
    n1 = (COLS - v0) / TabCols;
    if ( n1 < nTab )
    {
      if ( n1 < 0 )
        n1 = 0;
      n2 = COLS / TabCols;
      if ( !(COLS / TabCols) )
        n2 = 1;
      ny = (nTab - n1 - 1) / n2 + 2;
    }
    else
    {
      n2 = 1;
      ny = 1;
    }
    n1a = n1 - (n1 + n2 * (ny - 1) - nTab) / ny;
    if ( n1a < 0 )
      n1a = 0;
    tab = FirstTab;
    for ( iy = 0; iy < ny && tab; ++iy )
    {
      if ( iy )
      {
        nx = n2 - (n1a + n2 * (ny - 1) - nTab + iy - 1) / (ny - 1);
        col = COLS;
      }
      else
      {
        nx = n1a;
        col = COLS - v0;
      }
      for ( ix = 0; ix < nx && tab; ++ix )
      {
        tab->x1 = ix * col / nx;
        tab->x2 = col * (ix + 1) / nx - 1;
        tab->y = iy;
        if ( !iy )
        {
          tab->x1 += v0;
          tab->x2 += v0;
        }
        tab = tab->nextTab;
      }
    }
  }
}

//----- (080591EE) --------------------------------------------------------
TabBuffer *__cdecl deleteTab(TabBuffer *tab)
{
  Buffer *next; // [esp+18h] [ebp-10h]
  Buffer *buf; // [esp+1Ch] [ebp-Ch]

  if ( nTab <= 1 )
    return FirstTab;
  if ( tab->prevTab )
  {
    if ( tab->nextTab )
      tab->nextTab->prevTab = tab->prevTab;
    else
      LastTab = tab->prevTab;
    tab->prevTab->nextTab = tab->nextTab;
    if ( tab == CurrentTab )
      CurrentTab = tab->prevTab;
  }
  else
  {
    tab->nextTab->prevTab = 0;
    FirstTab = tab->nextTab;
    if ( tab == CurrentTab )
      CurrentTab = tab->nextTab;
  }
  --nTab;
  for ( buf = tab->firstBuffer; buf && buf != (Buffer *)1; buf = next )
  {
    next = buf->nextBuffer;
    discardBuffer(buf);
  }
  return FirstTab;
}

//----- (080592C9) --------------------------------------------------------
void closeT()
{
  TabBuffer *tab; // [esp+1Ch] [ebp-Ch]

  if ( nTab > 1 )
  {
    if ( prec_num )
      tab = numTab(prec_num);
    else
      tab = CurrentTab;
    if ( tab )
      deleteTab(tab);
    displayBuffer(CurrentTab->currentBuffer, 4);
  }
}

//----- (0805933A) --------------------------------------------------------
void nextT()
{
  int v0; // eax
  int i; // [esp+1Ch] [ebp-Ch]

  if ( nTab > 1 )
  {
    for ( i = 0; ; ++i )
    {
      v0 = prec_num ? prec_num : 1;
      if ( v0 <= i )
        break;
      if ( CurrentTab->nextTab )
        CurrentTab = CurrentTab->nextTab;
      else
        CurrentTab = FirstTab;
    }
    displayBuffer(CurrentTab->currentBuffer, 4);
  }
}

//----- (080593B1) --------------------------------------------------------
void prevT()
{
  int v0; // eax
  int i; // [esp+1Ch] [ebp-Ch]

  if ( nTab > 1 )
  {
    for ( i = 0; ; ++i )
    {
      v0 = prec_num ? prec_num : 1;
      if ( v0 <= i )
        break;
      if ( CurrentTab->prevTab )
        CurrentTab = CurrentTab->prevTab;
      else
        CurrentTab = LastTab;
    }
    displayBuffer(CurrentTab->currentBuffer, 4);
  }
}

//----- (0805942A) --------------------------------------------------------
void __cdecl followTab(TabBuffer *tab)
{
  Buffer *p; // [esp+10h] [ebp-18h]
  Buffer *pa; // [esp+10h] [ebp-18h]
  Buffer *c; // [esp+14h] [ebp-14h]
  Anchor *a; // [esp+18h] [ebp-10h]
  Buffer *buf; // [esp+1Ch] [ebp-Ch]
  Buffer *bufa; // [esp+1Ch] [ebp-Ch]

  a = retrieveCurrentImg(CurrentTab->currentBuffer);
  if ( !a || !a->image || !a->image->map )
    a = retrieveCurrentAnchor(CurrentTab->currentBuffer);
  if ( a )
  {
    if ( tab == CurrentTab )
    {
      check_target = 0;
      followA();
      check_target = 1;
    }
    else
    {
      newT();
      buf = CurrentTab->currentBuffer;
      check_target = 0;
      followA();
      check_target = 1;
      if ( tab )
      {
        if ( CurrentTab->currentBuffer != buf )
        {
          c = CurrentTab->currentBuffer;
          p = prevBuffer(c, buf);
          p->nextBuffer = 0;
          CurrentTab->firstBuffer = buf;
          deleteTab(CurrentTab);
          CurrentTab = tab;
          for ( bufa = p; bufa; bufa = pa )
          {
            pa = prevBuffer(c, bufa);
            pushBuffer(bufa);
          }
        }
      }
      else if ( CurrentTab->currentBuffer == buf )
      {
        deleteTab(CurrentTab);
      }
      else
      {
        delBuffer(buf);
      }
      displayBuffer(CurrentTab->currentBuffer, 1);
    }
  }
}

//----- (080595AB) --------------------------------------------------------
void tabA()
{
  TabBuffer *v0; // eax

  if ( prec_num )
    v0 = numTab(prec_num);
  else
    v0 = 0;
  followTab(v0);
}

//----- (080595E8) --------------------------------------------------------
void __cdecl tabURL0(TabBuffer *tab, char *prompt, int relative)
{
  Buffer *p; // [esp+14h] [ebp-14h]
  Buffer *pa; // [esp+14h] [ebp-14h]
  Buffer *c; // [esp+18h] [ebp-10h]
  Buffer *buf; // [esp+1Ch] [ebp-Ch]
  Buffer *bufa; // [esp+1Ch] [ebp-Ch]

  if ( tab == CurrentTab )
  {
    goURL0(prompt, relative);
  }
  else
  {
    newT();
    buf = CurrentTab->currentBuffer;
    goURL0(prompt, relative);
    if ( tab )
    {
      if ( CurrentTab->currentBuffer != buf )
      {
        c = CurrentTab->currentBuffer;
        p = prevBuffer(c, buf);
        p->nextBuffer = 0;
        CurrentTab->firstBuffer = buf;
        deleteTab(CurrentTab);
        CurrentTab = tab;
        for ( bufa = p; bufa; bufa = pa )
        {
          pa = prevBuffer(c, bufa);
          pushBuffer(bufa);
        }
      }
    }
    else if ( CurrentTab->currentBuffer == buf )
    {
      deleteTab(CurrentTab);
    }
    else
    {
      delBuffer(buf);
    }
    displayBuffer(CurrentTab->currentBuffer, 1);
  }
}

//----- (0805970B) --------------------------------------------------------
void tabURL()
{
  TabBuffer *v0; // eax

  if ( prec_num )
    v0 = numTab(prec_num);
  else
    v0 = 0;
  tabURL0(v0, "Goto URL on new tab: ", 0);
}

//----- (08059758) --------------------------------------------------------
void tabrURL()
{
  TabBuffer *v0; // eax

  if ( prec_num )
    v0 = numTab(prec_num);
  else
    v0 = 0;
  tabURL0(v0, "Goto relative URL on new tab: ", 1);
}

//----- (080597A5) --------------------------------------------------------
void __cdecl moveTab(TabBuffer *t, TabBuffer *t2, int right)
{
  if ( t2 == (TabBuffer *)1 )
    t2 = FirstTab;
  if ( t && t2 && t != t2 && t != (TabBuffer *)1 )
  {
    if ( t->prevTab )
    {
      if ( t->nextTab )
        t->nextTab->prevTab = t->prevTab;
      else
        LastTab = t->prevTab;
      t->prevTab->nextTab = t->nextTab;
    }
    else
    {
      t->nextTab->prevTab = 0;
      FirstTab = t->nextTab;
    }
    if ( right )
    {
      t->nextTab = t2->nextTab;
      t->prevTab = t2;
      if ( t2->nextTab )
        t2->nextTab->prevTab = t;
      else
        LastTab = t;
      t2->nextTab = t;
    }
    else
    {
      t->prevTab = t2->prevTab;
      t->nextTab = t2;
      if ( t2->prevTab )
        t2->prevTab->nextTab = t;
      else
        FirstTab = t;
      t2->prevTab = t;
    }
    displayBuffer(CurrentTab->currentBuffer, 1);
  }
}

//----- (080598D9) --------------------------------------------------------
void tabR()
{
  int v0; // eax
  TabBuffer *v1; // eax
  int i; // [esp+18h] [ebp-10h]
  TabBuffer *tab; // [esp+1Ch] [ebp-Ch]

  tab = CurrentTab;
  for ( i = 0; tab; ++i )
  {
    v0 = prec_num ? prec_num : 1;
    if ( v0 <= i )
      break;
    tab = tab->nextTab;
  }
  if ( tab )
    v1 = tab;
  else
    v1 = LastTab;
  moveTab(CurrentTab, v1, 1);
}

//----- (08059948) --------------------------------------------------------
void tabL()
{
  int v0; // eax
  TabBuffer *v1; // eax
  int i; // [esp+18h] [ebp-10h]
  TabBuffer *tab; // [esp+1Ch] [ebp-Ch]

  tab = CurrentTab;
  for ( i = 0; tab; ++i )
  {
    v0 = prec_num ? prec_num : 1;
    if ( v0 <= i )
      break;
    tab = tab->prevTab;
  }
  if ( tab )
    v1 = tab;
  else
    v1 = FirstTab;
  moveTab(CurrentTab, v1, 0);
}

//----- (080599B8) --------------------------------------------------------
void __cdecl addDownloadList(pid_t pid, char *url, char *save, char *lock, clen_t size)
{
  DownloadList *d; // [esp+2Ch] [ebp-Ch]

  d = (DownloadList *)GC_malloc(40);
  d->pid = pid;
  d->url = url;
  if ( *save != 47 && *save != 126 )
    save = Strnew_m_charp(CurrentDir, "/", save, 0)->ptr;
  d->save = expandPath(save);
  d->lock = lock;
  d->size = size;
  d->time = time(0);
  d->ok = 0;
  d->next = 0;
  d->prev = LastDL;
  if ( LastDL )
    LastDL->next = d;
  else
    FirstDL = d;
  LastDL = d;
  add_download_list = 1;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (08059AB4) --------------------------------------------------------
int checkDownloadList()
{
  stat st; // [esp+14h] [ebp-64h] BYREF
  DownloadList *d; // [esp+6Ch] [ebp-Ch]

  if ( !FirstDL )
    return 0;
  for ( d = FirstDL; d; d = d->next )
  {
    if ( !d->ok && !lstat(d->lock, (int)&st) )
      return 1;
  }
  return 0;
}

//----- (08059B14) --------------------------------------------------------
char *__cdecl convert_size3(clen_t size)
{
  char *v1; // eax
  int n; // [esp+28h] [ebp-10h]
  Str tmp; // [esp+2Ch] [ebp-Ch]

  tmp = Strnew();
  do
  {
    n = size % 1000;
    size /= 1000LL;
    if ( size )
      v1 = ",%.3d%s";
    else
      v1 = "%d%s";
    tmp = Sprintf(v1, n, tmp->ptr);
  }
  while ( size );
  return tmp->ptr;
}

//----- (08059BC5) --------------------------------------------------------
Buffer *DownloadListBuffer()
{
  wc_ces v1; // esi
  wc_ces v2; // ebx
  _Str *v3; // eax
  Str v4; // eax
  char *v5; // ebx
  char *v6; // eax
  _Str *v7; // eax
  DownloadList *v8; // ecx
  int v9; // eax
  int v11; // eax
  int v13; // eax
  int v14; // esi
  char *v15; // ebx
  char *v16; // eax
  _Str *v17; // eax
  char *v18; // eax
  _Str *v19; // eax
  char *v20; // eax
  _Str *v21; // eax
  _Str *v22; // eax
  int v23; // eax
  _Str *v24; // eax
  _Str *v25; // eax
  stat st; // [esp+44h] [ebp-94h] BYREF
  int l; // [esp+9Ch] [ebp-3Ch]
  int i; // [esp+A0h] [ebp-38h]
  size_t size; // [esp+A4h] [ebp-34h]
  int eta; // [esp+A8h] [ebp-30h]
  int rate; // [esp+ACh] [ebp-2Ch]
  int duration; // [esp+B0h] [ebp-28h]
  time_t cur_time; // [esp+B4h] [ebp-24h]
  Str src; // [esp+B8h] [ebp-20h]
  DownloadList *d; // [esp+BCh] [ebp-1Ch]

  src = 0;
  if ( !FirstDL )
    return 0;
  cur_time = time(0);
  src = Strnew_charp("<html><head><title>Download List Panel</title></head>\n"
                     "<body><h1 align=center>Download List Panel</h1>\n"
                     "<form method=internal action=download><hr>\n");
  for ( d = LastDL; d; d = d->prev )
  {
    if ( lstat(d->lock, (int)&st) )
      d->ok = 1;
    Strcat_charp(src, "<pre>\n");
    v1 = InnerCharset;
    v2 = SystemCharset;
    v3 = Strnew_charp(d->save);
    v4 = wc_Str_conv(v3, v2, v1);
    v5 = html_quote(v4->ptr);
    v6 = html_quote(d->url);
    v7 = Sprintf("%s\n  --&gt; %s\n  ", v6, v5);
    savexmlstr_0(src, v7);
    duration = cur_time - d->time;
    if ( stat_0(d->save, (int)&st) )
    {
      size = 0;
    }
    else
    {
      size = st.st_size;
      if ( d->ok )
      {
        v8 = d;
        LODWORD(d->size) = size;
        HIDWORD(v8->size) = 0;
        duration = st.st_mtim.tv_sec - d->time;
      }
    }
    if ( d->size )
    {
      l = COLS - 6;
      if ( size >= d->size )
        i = l;
      else
        i = (int)((long double)l * (long double)size / (long double)d->size);
      l -= i;
      while ( i-- > 0 )
      {
        if ( src->length + 1 >= src->area_size )
          Strgrow(src);
        v9 = src->length;
        src->ptr[v9] = 35;
        src->length = v9 + 1;
        src->ptr[src->length] = 0;
      }
      while ( l-- > 0 )
      {
        if ( src->length + 1 >= src->area_size )
          Strgrow(src);
        v11 = src->length;
        src->ptr[v11] = 95;
        src->length = v11 + 1;
        src->ptr[src->length] = 0;
      }
      if ( src->length + 1 >= src->area_size )
        Strgrow(src);
      v13 = src->length;
      src->ptr[v13] = 10;
      src->length = v13 + 1;
      src->ptr[src->length] = 0;
    }
    if ( d->ok || size >= d->size )
    {
      v18 = convert_size3(size);
      v19 = Sprintf("  %s bytes loaded", v18);
      savexmlstr_0(src, v19);
    }
    else
    {
      v14 = (int)((long double)size * 100.0 / (long double)d->size);
      v15 = convert_size3(d->size);
      v16 = convert_size3(size);
      v17 = Sprintf("  %s / %s bytes (%d%%)", v16, v15, v14);
      savexmlstr_0(src, v17);
    }
    if ( duration > 0 )
    {
      rate = size / duration;
      v20 = convert_size((int)(size / duration), 1);
      v21 = Sprintf("  %02d:%02d:%02d  rate %s/sec", duration / 3600, duration / 60 % 60, duration % 60, v20);
      savexmlstr_0(src, v21);
      if ( !d->ok && size < d->size && rate )
      {
        eta = (d->size - size) / rate;
        v22 = Sprintf("  eta %02d:%02d:%02d", eta / 3600, eta / 60 % 60, eta % 60);
        savexmlstr_0(src, v22);
      }
    }
    if ( src->length + 1 >= src->area_size )
      Strgrow(src);
    v23 = src->length;
    src->ptr[v23] = 10;
    src->length = v23 + 1;
    src->ptr[src->length] = 0;
    if ( d->ok )
    {
      v24 = Sprintf("<input type=submit name=ok%d value=OK>", d->pid);
      savexmlstr_0(src, v24);
      if ( size >= d->size )
        Strcat_charp(src, " Download completed");
      else
        Strcat_charp(src, " Download incompleted");
    }
    else
    {
      v25 = Sprintf("<input type=submit name=stop%d value=STOP>", d->pid);
      savexmlstr_0(src, v25);
    }
    Strcat_charp(src, "\n</pre><hr>\n");
  }
  Strcat_charp(src, "</form></body></html>");
  return loadHTMLString(src);
}

//----- (0805A352) --------------------------------------------------------
void __cdecl download_action(parsed_tagarg *arg)
{
  int pid; // [esp+18h] [ebp-10h]
  DownloadList *d; // [esp+1Ch] [ebp-Ch]

  while ( arg )
  {
    if ( !strncmp(arg->arg, "stop", 4u) )
    {
      pid = atoi((const char *)arg->arg + 4);
      kill(pid, 9);
    }
    else
    {
      if ( strncmp(arg->arg, "ok", 2u) )
        goto LABEL_16;
      pid = atoi((const char *)arg->arg + 2);
    }
    for ( d = FirstDL; d; d = d->next )
    {
      if ( d->pid == pid )
      {
        unlink(d->lock);
        if ( d->prev )
          d->prev->next = d->next;
        else
          FirstDL = d->next;
        if ( d->next )
          d->next->prev = d->prev;
        else
          LastDL = d->prev;
        break;
      }
    }
LABEL_16:
    arg = arg->next;
  }
  ldDL();
}

//----- (0805A47A) --------------------------------------------------------
void stopDownload()
{
  DownloadList *d; // [esp+1Ch] [ebp-Ch]

  if ( FirstDL )
  {
    for ( d = FirstDL; d; d = d->next )
    {
      if ( !d->ok )
      {
        kill(d->pid, 9);
        unlink(d->lock);
      }
    }
  }
}

//----- (0805A4D7) --------------------------------------------------------
void ldDL()
{
  Buffer *v0; // ebx
  int reload; // [esp+20h] [ebp-18h]
  int new_tab; // [esp+24h] [ebp-14h]
  int replace; // [esp+28h] [ebp-10h]
  Buffer *buf; // [esp+2Ch] [ebp-Ch]

  replace = 0;
  new_tab = 0;
  if ( (CurrentTab->currentBuffer->bufferprop & 8) != 0
    && !strcmp(CurrentTab->currentBuffer->buffername, "Download List Panel") )
  {
    replace = 1;
  }
  if ( FirstDL )
  {
    reload = checkDownloadList();
    buf = DownloadListBuffer();
    if ( !buf )
    {
      displayBuffer(CurrentTab->currentBuffer, 0);
      return;
    }
    buf->bufferprop |= 0x18u;
    if ( replace )
    {
      buf->rootX = CurrentTab->currentBuffer->rootX;
      buf->rootY = CurrentTab->currentBuffer->rootY;
      buf->COLS = CurrentTab->currentBuffer->COLS;
      buf->LINES = CurrentTab->currentBuffer->LINES;
      restorePosition(buf, CurrentTab->currentBuffer);
    }
    if ( !replace && open_tab_dl_list )
    {
      newT();
      new_tab = 1;
    }
    pushBuffer(buf);
    if ( replace || new_tab )
      deletePrevBuf();
    if ( reload )
    {
      v0 = CurrentTab->currentBuffer;
      v0->event = setAlarmEvent(v0->event, 1, 2, 112, 0);
    }
  }
  else
  {
    if ( !replace )
      return;
    if ( CurrentTab->currentBuffer != CurrentTab->firstBuffer || CurrentTab->currentBuffer->nextBuffer )
    {
      delBuffer(CurrentTab->currentBuffer);
    }
    else if ( nTab > 1 )
    {
      deleteTab(CurrentTab);
    }
  }
  displayBuffer(CurrentTab->currentBuffer, 1);
}

//----- (0805A6F6) --------------------------------------------------------
void __cdecl save_buffer_position(Buffer *buf)
{
  int v1; // eax
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v5; // eax
  _BufferPos *b; // [esp+1Ch] [ebp-Ch]
  BufferPos *ba; // [esp+1Ch] [ebp-Ch]

  b = buf->undo;
  if ( buf->firstLine )
  {
    if ( !b
      || (!buf->topLine ? (v1 = 1) : (v1 = buf->topLine->linenumber),
          b->top_linenumber != v1
       || (!buf->currentLine ? (v2 = 1) : (v2 = buf->currentLine->linenumber),
           b->cur_linenumber != v2 || b->currentColumn != buf->currentColumn || b->pos != buf->pos)) )
    {
      ba = (BufferPos *)GC_malloc(28);
      if ( buf->topLine )
        v3 = buf->topLine->linenumber;
      else
        v3 = 1;
      ba->top_linenumber = v3;
      if ( buf->currentLine )
        v4 = buf->currentLine->linenumber;
      else
        v4 = 1;
      ba->cur_linenumber = v4;
      ba->currentColumn = buf->currentColumn;
      ba->pos = buf->pos;
      if ( buf->currentLine )
        v5 = buf->currentLine->bpos;
      else
        v5 = 0;
      ba->bpos = v5;
      ba->next = 0;
      ba->prev = buf->undo;
      if ( buf->undo )
        buf->undo->next = ba;
      buf->undo = ba;
    }
  }
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (0805A856) --------------------------------------------------------
void __cdecl resetPos(BufferPos *b)
{
  Buffer buf; // [esp+14h] [ebp-174h] BYREF
  Line cur; // [esp+118h] [ebp-70h] BYREF
  Line top; // [esp+14Ch] [ebp-3Ch] BYREF

  top.linenumber = b->top_linenumber;
  cur.linenumber = b->cur_linenumber;
  cur.bpos = b->bpos;
  buf.topLine = &top;
  buf.currentLine = &cur;
  buf.pos = b->pos;
  buf.currentColumn = b->currentColumn;
  restorePosition(CurrentTab->currentBuffer, &buf);
  CurrentTab->currentBuffer->undo = b;
  displayBuffer(CurrentTab->currentBuffer, 1);
}

//----- (0805A8E8) --------------------------------------------------------
void undoPos()
{
  int v0; // eax
  int i; // [esp+18h] [ebp-10h]
  _BufferPos *b; // [esp+1Ch] [ebp-Ch]

  b = CurrentTab->currentBuffer->undo;
  if ( CurrentTab->currentBuffer->firstLine && b && b->prev )
  {
    for ( i = 0; ; ++i )
    {
      v0 = prec_num ? prec_num : 1;
      if ( v0 <= i || !b->prev )
        break;
      b = b->prev;
    }
    resetPos(b);
  }
}

//----- (0805A96E) --------------------------------------------------------
void redoPos()
{
  int v0; // eax
  int i; // [esp+18h] [ebp-10h]
  _BufferPos *b; // [esp+1Ch] [ebp-Ch]

  b = CurrentTab->currentBuffer->undo;
  if ( CurrentTab->currentBuffer->firstLine && b && b->next )
  {
    for ( i = 0; ; ++i )
    {
      v0 = prec_num ? prec_num : 1;
      if ( v0 <= i || !b->next )
        break;
      b = b->next;
    }
    resetPos(b);
  }
}

//----- (0805A9F4) --------------------------------------------------------
void __cdecl __noreturn KeyAbort(int _dummy)
{
  siglongjmp(AbortLoading, 1);
}

//----- (0805AA0E) --------------------------------------------------------
void __cdecl UFhalfclose(URLFile *f)
{
  int v1; // eax

  v1 = f->scheme;
  if ( v1 == 7 || v1 == 9 )
  {
    closeNews();
  }
  else if ( v1 == 2 )
  {
    closeFTP();
  }
  else if ( !ISclose(f->stream) )
  {
    f->stream = 0;
  }
}

//----- (0805AA60) --------------------------------------------------------
int __cdecl currentLn(Buffer *buf)
{
  int result; // eax

  if ( buf->currentLine )
    result = buf->currentLine->linenumber + 1;
  else
    result = 1;
  return result;
}

//----- (0805AA82) --------------------------------------------------------
Buffer *__cdecl loadSomething(URLFile *f, char *path, Buffer *(*loadproc)(URLFile *, Buffer *), Buffer *defaultbuf)
{
  wc_ces v5; // esi
  wc_ces v6; // ebx
  char *v7; // eax
  _Str *v8; // eax
  Buffer *buf; // [esp+1Ch] [ebp-Ch]

  buf = loadproc(f, defaultbuf);
  if ( !buf )
    return 0;
  buf->filename = path;
  if ( !buf->buffername || !*buf->buffername )
  {
    buf->buffername = checkHeader(buf, "Subject:");
    if ( !buf->buffername )
    {
      v5 = InnerCharset;
      v6 = SystemCharset;
      v7 = lastFileName(path);
      v8 = Strnew_charp(v7);
      buf->buffername = wc_Str_conv(v8, v6, v5)->ptr;
    }
  }
  if ( buf->currentURL.scheme == 255 )
    buf->currentURL.scheme = f->scheme;
  buf->real_scheme = f->scheme;
  if ( f->scheme == 4 && !buf->sourcefile )
    buf->sourcefile = path;
  return buf;
}

//----- (0805AB89) --------------------------------------------------------
int __cdecl dir_exist(char *path)
{
  stat stbuf; // [esp+18h] [ebp-60h] BYREF

  if ( !path || !*path )
    return 0;
  if ( stat_0(path, (int)&stbuf) == -1 )
    return 0;
  return (stbuf.st_mode & 0xF000) == 0x4000;
}

//----- (0805ABD9) --------------------------------------------------------
int __cdecl is_dump_text_type(char *type)
{
  int result; // eax
  mailcap *mcap; // [esp+1Ch] [ebp-Ch]

  result = 0;
  if ( type )
  {
    mcap = searchExtViewer(type);
    if ( mcap )
    {
      if ( (mcap->flags & 6) != 0 )
        result = 1;
    }
  }
  return result;
}

//----- (0805AC14) --------------------------------------------------------
int __cdecl is_text_type(char *type)
{
  return !type || !*type || !strncasecmp(type, "text/", 5u) || !strncasecmp(type, "message/", 8u);
}

//----- (0805AC76) --------------------------------------------------------
int __cdecl is_plain_text_type(char *type)
{
  return type && !strcasecmp(type, "text/plain") || is_text_type(type) && !is_dump_text_type(type);
}

//----- (0805ACC5) --------------------------------------------------------
int __cdecl is_html_type(char *type)
{
  return type && (!strcasecmp(type, "text/html") || !strcasecmp(type, "application/xhtml+xml"));
}

//----- (0805AD0D) --------------------------------------------------------
void __cdecl check_compression(char *path, URLFile *uf)
{
  int elen; // [esp+14h] [ebp-14h]
  compression_decoder *d; // [esp+18h] [ebp-10h]
  int len; // [esp+1Ch] [ebp-Ch]

  if ( path )
  {
    len = strlen(path);
    uf->compression = 0;
    for ( d = compression_decoders; d->type; ++d )
    {
      if ( d->ext )
      {
        elen = strlen(d->ext);
        if ( len > elen && !strcasecmp(&path[len - elen], d->ext) )
        {
          uf->compression = d->type;
          uf->guess_type = d->mime_type;
          return;
        }
      }
    }
  }
}

//----- (0805ADB7) --------------------------------------------------------
char *__cdecl compress_application_type(int compression)
{
  compression_decoder *d; // [esp+Ch] [ebp-4h]

  for ( d = compression_decoders; d->type; ++d )
  {
    if ( d->type == compression )
      return d->mime_type;
  }
  return 0;
}

//----- (0805ADEC) --------------------------------------------------------
char *__cdecl uncompressed_file_type(char *path, char **ext)
{
  compression_decoder *d; // [esp+1Ch] [ebp-1Ch]
  const char *t0; // [esp+20h] [ebp-18h]
  _Str *fn; // [esp+24h] [ebp-14h]
  signed int slen; // [esp+28h] [ebp-10h]
  int len; // [esp+2Ch] [ebp-Ch]

  if ( !path )
    return 0;
  slen = 0;
  len = strlen(path);
  for ( d = compression_decoders; d->type; ++d )
  {
    if ( d->ext )
    {
      slen = strlen(d->ext);
      if ( len > slen && !strcasecmp(&path[len - slen], d->ext) )
        break;
    }
  }
  if ( !d->type )
    return 0;
  fn = Strnew_charp(path);
  Strshrink(fn, slen);
  if ( ext )
    *ext = filename_extension(fn->ptr, 0);
  t0 = guessContentType(fn->ptr);
  if ( !t0 )
    t0 = "text/plain";
  return (char *)t0;
}

//----- (0805AEF2) --------------------------------------------------------
int __cdecl setModtime(char *path, time_t modtime)
{
  stat st; // [esp+10h] [ebp-68h] BYREF
  utimbuf t; // [esp+68h] [ebp-10h] BYREF

  if ( stat_0(path, (int)&st) )
    t.actime = time(0);
  else
    t.actime = st.st_atim.tv_sec;
  t.modtime = modtime;
  return utime(path, &t);
}

//----- (0805AF3F) --------------------------------------------------------
void __cdecl examineFile(char *path, URLFile *uf)
{
  int v2; // eax
  stat stbuf; // [esp+1Ch] [ebp-6Ch] BYREF
  char *t0; // [esp+74h] [ebp-14h]
  char *ext; // [esp+78h] [ebp-10h] BYREF
  FILE *fp; // [esp+7Ch] [ebp-Ch]

  uf->guess_type = 0;
  if ( !path || !*path || stat_0(path, (int)&stbuf) == -1 || (stbuf.st_mode & 0xF000) != 0x8000 )
  {
    uf->stream = 0;
    return;
  }
  v2 = open(path, 0);
  uf->stream = newInputStream(v2);
  if ( !do_download )
  {
    if ( !use_lessopen || !getenv("LESSOPEN") )
    {
LABEL_16:
      check_compression(path, uf);
      if ( uf->compression )
      {
        ext = uf->ext;
        t0 = uncompressed_file_type(path, &ext);
        uf->guess_type = t0;
        uf->ext = ext;
        uncompress_stream(uf, 0);
      }
      return;
    }
    uf->guess_type = guessContentType(path);
    if ( !uf->guess_type )
      uf->guess_type = "text/plain";
    if ( !is_html_type(uf->guess_type) )
    {
      fp = lessopen_stream(path);
      if ( fp )
      {
        if ( !ISclose(uf->stream) )
          uf->stream = 0;
        uf->stream = newFileStream(fp, (void (*)(...))pclose);
        uf->guess_type = "text/plain";
        return;
      }
      goto LABEL_16;
    }
  }
}

//----- (0805B0E4) --------------------------------------------------------
int __cdecl check_command(char *cmd, int auxbin_p)
{
  char *v2; // eax
  int v3; // eax
  stat st; // [esp+18h] [ebp-70h] BYREF
  Str pathname; // [esp+70h] [ebp-18h]
  char *np; // [esp+74h] [ebp-14h]
  char *p; // [esp+78h] [ebp-10h]
  Str dirs; // [esp+7Ch] [ebp-Ch]

  if ( !path_9119 )
    path_9119 = getenv("PATH");
  if ( auxbin_p )
  {
    v2 = w3m_auxbin_dir();
    dirs = Strnew_charp(v2);
  }
  else
  {
    dirs = Strnew_charp(path_9119);
  }
  for ( p = dirs->ptr; p; p = np )
  {
    np = strchr(p, 58);
    if ( np )
      *np++ = 0;
    pathname = Strnew();
    Strcat_charp(pathname, p);
    if ( pathname->length + 1 >= pathname->area_size )
      Strgrow(pathname);
    v3 = pathname->length;
    pathname->ptr[v3] = 47;
    pathname->length = v3 + 1;
    pathname->ptr[pathname->length] = 0;
    Strcat_charp(pathname, cmd);
    if ( !stat_0(pathname->ptr, (int)&st) && (st.st_mode & 0xF000) == 0x8000 && (st.st_mode & 0x49) != 0 )
      return 1;
  }
  return 0;
}

//----- (0805B228) --------------------------------------------------------
char *acceptableEncoding()
{
  char *v1; // eax
  char *p; // [esp+14h] [ebp-14h]
  GeneralList *l; // [esp+18h] [ebp-10h]
  compression_decoder *d; // [esp+1Ch] [ebp-Ch]

  if ( encodings_9174 )
    return encodings_9174->ptr;
  l = newGeneralList();
  for ( d = compression_decoders; d->type; ++d )
  {
    if ( check_command(d->cmd, d->auxbin_p) )
    {
      v1 = allocStr(d->encoding, -1);
      pushValue(l, v1);
    }
  }
  for ( encodings_9174 = Strnew(); ; Strcat_charp(encodings_9174, p) )
  {
    p = (char *)popValue(l);
    if ( !p )
      break;
    if ( encodings_9174->length )
      Strcat_charp(encodings_9174, ", ");
  }
  return encodings_9174->ptr;
}

//----- (0805B300) --------------------------------------------------------
Str __cdecl convertLine(URLFile *uf, Str line, int mode, wc_ces *charset, wc_ces doc_charset)
{
  _Str *linea; // [esp+24h] [ebp+Ch]

  linea = wc_Str_conv_with_detect(line, charset, doc_charset, InnerCharset);
  if ( mode )
    cleanup_line(linea, mode);
  if ( uf && uf->scheme == 9 )
    Strchop(linea);
  return linea;
}

//----- (0805B363) --------------------------------------------------------
Buffer *__cdecl loadFile(char *path)
{
  int v2; // eax
  int v3; // eax
  URLFile uf; // [esp+1Ch] [ebp-2Ch] BYREF
  Buffer *buf; // [esp+3Ch] [ebp-Ch]

  init_stream(&uf, 4, 0);
  examineFile(path, &uf);
  if ( !uf.stream )
    return 0;
  if ( showLineNum )
    v2 = 6;
  else
    v2 = 1;
  v3 = COLS - v2;
  if ( v3 < 0 )
    v3 = 0;
  buf = newBuffer(v3);
  current_content_length = 0LL;
  content_charset = 0;
  buf = loadSomething(&uf, path, (Buffer *(*)(URLFile *, Buffer *))loadBuffer, buf);
  if ( !ISclose(uf.stream) )
    uf.stream = 0;
  return buf;
}

//----- (0805B43F) --------------------------------------------------------
int __cdecl matchattr(char *p, char *attr, int len, Str *value)
{
  Str v4; // eax
  int v5; // edx
  char *q; // [esp+18h] [ebp-10h]
  int quoted; // [esp+1Ch] [ebp-Ch]
  char *pa; // [esp+30h] [ebp+8h]
  char *pb; // [esp+30h] [ebp+8h]

  q = 0;
  if ( strncasecmp(p, attr, len) )
    return 0;
  for ( pa = &p[len]; *pa && (MYCTYPE_MAP[(unsigned __int8)*pa] & 2) != 0; ++pa )
    ;
  if ( !value )
    return !*pa || *pa == 13 || *pa == 10 || *pa == 59;
  *value = Strnew();
  if ( *pa == 61 )
  {
    for ( pb = pa + 1; *pb && (MYCTYPE_MAP[(unsigned __int8)*pb] & 2) != 0; ++pb )
      ;
    quoted = 0;
    while ( *pb && *pb != 13 && *pb != 10 && (quoted || *pb != 59) )
    {
      if ( (MYCTYPE_MAP[(unsigned __int8)*pb] & 2) == 0 )
        q = pb;
      if ( *pb == 34 )
      {
        quoted = quoted == 0;
      }
      else
      {
        if ( (*value)->length + 1 >= (*value)->area_size )
          Strgrow(*value);
        v4 = *value;
        v5 = (*value)->length;
        (*value)->ptr[v5] = *pb;
        v4->length = v5 + 1;
        (*value)->ptr[(*value)->length] = 0;
      }
      ++pb;
    }
    if ( q )
      Strshrink(*value, pb - q - 1);
  }
  return 1;
}

//----- (0805B62E) --------------------------------------------------------
char *__cdecl xface2xpm(char *xface)
{
  char *v2; // ebx
  char *v3; // eax
  char *v4; // eax
  Str v5; // eax
  stat st; // [esp+1Ch] [ebp-8Ch] BYREF
  Image image; // [esp+74h] [ebp-34h] BYREF
  FILE *f; // [esp+98h] [ebp-10h]
  ImageCache *cache; // [esp+9Ch] [ebp-Ch]

  while ( *xface && (MYCTYPE_MAP[(unsigned __int8)*xface] & 2) != 0 )
    ++xface;
  image.url = xface;
  image.ext = ".xpm";
  image.width = 48;
  image.height = 48;
  image.cache = 0;
  cache = getImage(&image, 0, 2);
  if ( (cache->loaded & 1) != 0 && !stat_0(cache->file, (int)&st) )
    return cache->file;
  cache->loaded = 2;
  v2 = shell_quote(cache->file);
  v3 = auxbinFile("xface2xpm");
  v4 = shell_quote(v3);
  v5 = Sprintf("%s > %s", v4, v2);
  f = popen(v5->ptr, "w");
  if ( !f )
    return 0;
  fputs(xface, f);
  pclose(f);
  if ( stat_0(cache->file, (int)&st) || !st.st_size )
    return 0;
  cache->loaded = 5;
  cache->index = 0;
  return cache->file;
}

//----- (0805B7A0) --------------------------------------------------------
void __cdecl readHeader(URLFile *uf, Buffer *newBuf, int thru, ParsedURL *pu)
{
  wc_ces v4; // edx
  wc_ces *v5; // eax
  _Str *v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  char *v10; // eax
  char *v11; // eax
  input_stream *v12; // eax
  size_t v13; // eax
  int v14; // eax
  int v15; // eax
  time_t v16; // ebx
  Str v17; // eax
  char *v18; // eax
  char *v19; // eax
  Str v20; // eax
  int v21; // eax
  char *v22; // eax
  URLFile f; // [esp+34h] [ebp-B4h] BYREF
  int f_0; // [esp+54h] [ebp-94h]
  Str funcname; // [esp+58h] [ebp-90h]
  Str msg; // [esp+5Ch] [ebp-8Ch]
  char *ans; // [esp+60h] [ebp-88h]
  int err; // [esp+64h] [ebp-84h]
  time_t expires; // [esp+68h] [ebp-80h]
  int flag; // [esp+6Ch] [ebp-7Ch]
  int quoted; // [esp+70h] [ebp-78h]
  int version; // [esp+74h] [ebp-74h]
  Str tmp2; // [esp+78h] [ebp-70h] BYREF
  Str port; // [esp+7Ch] [ebp-6Ch]
  Str commentURL; // [esp+80h] [ebp-68h]
  Str comment; // [esp+84h] [ebp-64h]
  Str path; // [esp+88h] [ebp-60h]
  Str domain; // [esp+8Ch] [ebp-5Ch]
  Str value; // [esp+90h] [ebp-58h]
  Str name; // [esp+94h] [ebp-54h]
  char **e; // [esp+98h] [ebp-50h]
  compression_decoder *d; // [esp+9Ch] [ebp-4Ch]
  wc_ces old_charset; // [esp+A0h] [ebp-48h]
  Line *l; // [esp+A4h] [ebp-44h]
  Str src_0; // [esp+A8h] [ebp-40h]
  FILE *ff; // [esp+ACh] [ebp-3Ch]
  Lineprop *propBuffer; // [esp+B0h] [ebp-38h] BYREF
  FILE *src; // [esp+B4h] [ebp-34h]
  char *tmpf; // [esp+B8h] [ebp-30h]
  wc_ces mime_charset; // [esp+BCh] [ebp-2Ch] BYREF
  wc_ces charset; // [esp+C0h] [ebp-28h] BYREF
  TextList *headerlist; // [esp+C4h] [ebp-24h]
  Str tmp; // [esp+C8h] [ebp-20h]
  Str lineBuf2; // [esp+CCh] [ebp-1Ch]
  char *emsg; // [esp+D0h] [ebp-18h]
  char *q; // [esp+D4h] [ebp-14h]
  char *p; // [esp+D8h] [ebp-10h]
  char c; // [esp+DFh] [ebp-9h]

  lineBuf2 = 0;
  charset = 256;
  src = 0;
  newBuf->document_header = (TextList *)newGeneralList();
  headerlist = newBuf->document_header;
  if ( uf->scheme )
    http_response_code = 0;
  else
    http_response_code = -1;
  if ( thru )
  {
    if ( !newBuf->header_source && !image_source )
    {
      tmpf = tmpfname(0, 0)->ptr;
      src = fopen(tmpf, "w");
      if ( src )
        newBuf->header_source = tmpf;
    }
  }
  while ( 1 )
  {
    tmp = StrmyISgets(uf->stream);
    if ( !tmp->length )
      break;
    if ( uf->scheme == 9 && *tmp->ptr == 46 )
      Strdelete(tmp, 0, 1);
    if ( w3m_reqlog )
    {
      ff = fopen(w3m_reqlog, "a");
      fwrite(tmp->ptr, 1u, tmp->length, ff);
      fclose(ff);
    }
    if ( src )
      fwrite(tmp->ptr, 1u, tmp->length, src);
    cleanup_line(tmp, 3);
    if ( *tmp->ptr == 10 || *tmp->ptr == 13 || !*tmp->ptr )
    {
      if ( !lineBuf2 )
        break;
LABEL_75:
      if ( !uf->scheme && http_response_code == -1 )
      {
        for ( p = lineBuf2->ptr; *p && (MYCTYPE_MAP[(unsigned __int8)*p] & 2) == 0; ++p )
          ;
        while ( *p && (MYCTYPE_MAP[(unsigned __int8)*p] & 2) != 0 )
          ++p;
        http_response_code = atoi(p);
        if ( fmInitialized )
        {
          message(lineBuf2->ptr, 0, 0);
          refresh();
        }
      }
      if ( !strncasecmp(lineBuf2->ptr, "content-transfer-encoding:", 0x1Au) )
      {
        for ( p = lineBuf2->ptr + 26; (MYCTYPE_MAP[(unsigned __int8)*p] & 2) != 0; ++p )
          ;
        if ( !strncasecmp(p, "base64", 6u) )
        {
          uf->encoding = 1;
        }
        else if ( !strncasecmp(p, "quoted-printable", 0x10u) )
        {
          uf->encoding = 2;
        }
        else if ( !strncasecmp(p, "uuencode", 8u) || !strncasecmp(p, "x-uuencode", 0xAu) )
        {
          uf->encoding = 3;
        }
        else
        {
          uf->encoding = 0;
        }
        goto LABEL_240;
      }
      if ( !strncasecmp(lineBuf2->ptr, "content-encoding:", 0x11u) )
      {
        for ( p = lineBuf2->ptr + 17; (MYCTYPE_MAP[(unsigned __int8)*p] & 2) != 0; ++p )
          ;
        uf->compression = 0;
        for ( d = compression_decoders; d->type; ++d )
        {
          for ( e = d->encodings; *e; ++e )
          {
            v13 = strlen(*e);
            if ( !strncasecmp(p, *e, v13) )
            {
              uf->compression = d->type;
              break;
            }
          }
          if ( uf->compression )
            break;
        }
        uf->content_encoding = uf->compression;
      }
      else if ( use_cookie
             && accept_cookie
             && pu
             && check_cookie_accept_domain(pu->host)
             && (!strncasecmp(lineBuf2->ptr, "Set-Cookie:", 0xBu) || !strncasecmp(lineBuf2->ptr, "Set-Cookie2:", 0xCu)) )
      {
        name = Strnew();
        value = Strnew();
        domain = 0;
        path = 0;
        comment = 0;
        commentURL = 0;
        port = 0;
        flag = 0;
        expires = -1;
        q = 0;
        if ( lineBuf2->ptr[10] == 50 )
        {
          p = lineBuf2->ptr + 12;
          version = 1;
        }
        else
        {
          p = lineBuf2->ptr + 11;
          version = 0;
        }
        while ( *p && (MYCTYPE_MAP[(unsigned __int8)*p] & 2) != 0 )
          ++p;
        while ( *p != 61 && *p && *p != 13 && *p != 10 && *p != 59 )
        {
          if ( name->length + 1 >= name->area_size )
            Strgrow(name);
          v14 = name->length;
          name->ptr[v14] = *p;
          name->length = v14 + 1;
          ++p;
          name->ptr[name->length] = 0;
        }
        Strremovetrailingspaces(name);
        if ( *p == 61 )
        {
          ++p;
          while ( *p && (MYCTYPE_MAP[(unsigned __int8)*p] & 2) != 0 )
            ++p;
          quoted = 0;
          while ( *p && *p != 13 && *p != 10 && (quoted || *p != 59) )
          {
            if ( (MYCTYPE_MAP[(unsigned __int8)*p] & 2) == 0 )
              q = p;
            if ( *p == 34 )
              quoted = quoted == 0;
            if ( value->length + 1 >= value->area_size )
              Strgrow(value);
            v15 = value->length;
            value->ptr[v15] = *p;
            value->length = v15 + 1;
            ++p;
            value->ptr[value->length] = 0;
          }
          if ( q )
            Strshrink(value, p - q - 1);
        }
        while ( *p == 59 )
        {
          ++p;
          while ( *p && (MYCTYPE_MAP[(unsigned __int8)*p] & 2) != 0 )
            ++p;
          if ( matchattr(p, "expires", 7, &tmp2) )
          {
            expires = mymktime(tmp2->ptr);
          }
          else if ( matchattr(p, "max-age", 7, &tmp2) )
          {
            v16 = time(0);
            expires = v16 + atol(tmp2->ptr);
          }
          else if ( matchattr(p, "domain", 6, &tmp2) )
          {
            domain = tmp2;
          }
          else if ( matchattr(p, "path", 4, &tmp2) )
          {
            path = tmp2;
          }
          else if ( matchattr(p, "secure", 6, 0) )
          {
            flag |= 2u;
          }
          else if ( matchattr(p, "comment", 7, &tmp2) )
          {
            comment = tmp2;
          }
          else if ( matchattr(p, "version", 7, &tmp2) )
          {
            version = atoi(tmp2->ptr);
          }
          else if ( matchattr(p, "port", 4, &tmp2) )
          {
            port = tmp2;
          }
          else if ( matchattr(p, "commentURL", 10, &tmp2) )
          {
            commentURL = tmp2;
          }
          else if ( matchattr(p, "discard", 7, 0) )
          {
            flag |= 0x10u;
          }
          quoted = 0;
          while ( *p && *p != 13 && *p != 10 && (quoted || *p != 59) )
          {
            if ( *p == 34 )
              quoted = quoted == 0;
            ++p;
          }
        }
        if ( name->length > 0 )
        {
          if ( show_cookie )
          {
            if ( (flag & 2) != 0 )
            {
              disp_message_nsec("Received a secured cookie", 0, 1, 1, 0);
            }
            else
            {
              v17 = Sprintf("Received cookie: %s=%s", name->ptr, value->ptr);
              disp_message_nsec(v17->ptr, 0, 1, 1, 0);
            }
          }
          err = add_cookie(pu, name, value, expires, domain, path, flag, comment, version, port, commentURL);
          if ( err )
          {
            if ( accept_bad_cookie == 1 )
              v18 = "y";
            else
              v18 = 0;
            ans = v18;
            if ( fmInitialized && (err & 0x20) != 0 && accept_bad_cookie == 2 )
            {
              if ( domain && domain->ptr )
                v19 = domain->ptr;
              else
                v19 = "<localdomain>";
              msg = Sprintf("Accept bad cookie from %s for %s?", pu->host, v19);
              if ( msg->length > COLS - 10 )
                Strshrink(msg, 10 - COLS + msg->length);
              Strcat_charp(msg, " (y/n)");
              ans = inputAnswer(msg->ptr);
            }
            if ( !ans )
              goto LABEL_213;
            if ( (MYCTYPE_MAP[(unsigned __int8)*ans] & 4) != 0 )
            {
              if ( ((unsigned __int8)*ans | 0x20) != 121 )
                goto LABEL_213;
            }
            else if ( *ans != 121 )
            {
              goto LABEL_213;
            }
            err = add_cookie(pu, name, value, expires, domain, path, flag | 0x20, comment, version, port, commentURL);
            if ( err )
            {
LABEL_213:
              err = (err & 0xFFFFFFDF) - 1;
              if ( err < 0 || err > 8 )
                emsg = "This cookie was rejected to prevent security violation.";
              else
                emsg = Sprintf("This cookie was rejected to prevent security violation. [%s]", violations[err])->ptr;
              record_err_message(emsg);
              if ( show_cookie )
                disp_message_nsec(emsg, 0, 1, 1, 0);
              goto LABEL_240;
            }
            if ( show_cookie )
            {
              v20 = Sprintf("Accepting invalid cookie: %s=%s", name->ptr, value->ptr);
              disp_message_nsec(v20->ptr, 0, 1, 1, 0);
            }
          }
        }
      }
      else if ( !strncasecmp(lineBuf2->ptr, "w3m-control:", 0xCu) && uf->scheme == 5 )
      {
        funcname = Strnew();
        for ( p = lineBuf2->ptr + 12; *p && (MYCTYPE_MAP[(unsigned __int8)*p] & 2) != 0; ++p )
          ;
        while ( *p && (MYCTYPE_MAP[(unsigned __int8)*p] & 2) == 0 )
        {
          if ( funcname->length + 1 >= funcname->area_size )
            Strgrow(funcname);
          v21 = funcname->length;
          funcname->ptr[v21] = *p;
          funcname->length = v21 + 1;
          ++p;
          funcname->ptr[funcname->length] = 0;
        }
        while ( *p && (MYCTYPE_MAP[(unsigned __int8)*p] & 2) != 0 )
          ++p;
        f_0 = getFuncList(funcname->ptr);
        if ( f_0 >= 0 )
        {
          tmp = Strnew_charp(p);
          Strchop(tmp);
          pushEvent(f_0, tmp->ptr);
        }
      }
LABEL_240:
      if ( headerlist )
      {
        v22 = allocStr(lineBuf2->ptr, -1);
        pushValue((GeneralList *)headerlist, v22);
      }
      Strfree(lineBuf2);
      lineBuf2 = 0;
    }
    else
    {
      if ( (w3m_dump & 2) != 0 )
      {
        lineBuf2 = tmp;
        goto LABEL_75;
      }
      if ( lineBuf2 )
        savexmlstr_0(lineBuf2, tmp);
      else
        lineBuf2 = tmp;
      c = ISgetc(uf->stream);
      ISundogetc(uf->stream);
      if ( c != 32 && c != 9 )
      {
        lineBuf2 = decodeMIME(lineBuf2, &mime_charset);
        if ( mime_charset )
          v4 = mime_charset;
        else
          v4 = DocumentCharset;
        if ( mime_charset )
          v5 = &mime_charset;
        else
          v5 = &charset;
        lineBuf2 = convertLine(0, lineBuf2, 0, v5, v4);
        tmp = Strnew_size(lineBuf2->length);
        for ( p = lineBuf2->ptr; *p; p = q )
        {
          for ( q = p; *q && *q != 13 && *q != 10; ++q )
            ;
          v6 = Strnew_charp_n(p, q - p);
          lineBuf2 = checkType(v6, &propBuffer, 0);
          savexmlstr_0(tmp, lineBuf2);
          if ( thru )
          {
            if ( FoldLine )
            {
              if ( showLineNum )
                v7 = 6;
              else
                v7 = 1;
              v8 = COLS - v7;
              if ( v8 < 0 )
                v8 = 0;
              v9 = v8 + 1;
            }
            else
            {
              v9 = -1;
            }
            addnewline(newBuf, lineBuf2->ptr, propBuffer, 0, lineBuf2->length, v9, -1);
          }
          while ( *q && (*q == 13 || *q == 10) )
            ++q;
        }
        if ( thru && activeImage && displayImage )
        {
          src_0 = 0;
          if ( !strncasecmp(tmp->ptr, "X-Image-URL:", 0xCu) )
          {
            for ( tmpf = tmp->ptr + 12; *tmpf && (MYCTYPE_MAP[(unsigned __int8)*tmpf] & 2) != 0; ++tmpf )
              ;
            v10 = html_quote(tmpf);
            src_0 = Strnew_m_charp("<img src=\"", v10, "\" alt=\"X-Image-URL\">", 0);
          }
          else if ( !strncasecmp(tmp->ptr, "X-Face:", 7u) )
          {
            tmpf = xface2xpm(tmp->ptr + 7);
            if ( tmpf )
            {
              v11 = html_quote(tmpf);
              src_0 = Strnew_m_charp("<img src=\"file:", v11, "\" alt=\"X-Face\"", " width=48 height=48>", 0);
            }
          }
          if ( src_0 )
          {
            old_charset = newBuf->document_charset;
            v12 = newStrStream(src_0);
            init_stream(&f, 4, v12);
            loadHTMLstream(&f, newBuf, 0, 1);
            for ( l = newBuf->lastLine; l && l->real_linenumber; l = l->prev )
              l->real_linenumber = 0;
            newBuf->document_charset = old_charset;
          }
        }
        lineBuf2 = tmp;
        goto LABEL_75;
      }
    }
  }
  if ( thru )
    addnewline(newBuf, (char *)&line, propBuffer, 0, 0, -1, -1);
  if ( src )
    fclose(src);
}
// 805C564: conditional instruction was optimized away because of '%pu.4!=0'

//----- (0805CB59) --------------------------------------------------------
char *__cdecl checkHeader(Buffer *buf, char *field)
{
  TextListItem *i; // [esp+18h] [ebp-10h]
  int len; // [esp+1Ch] [ebp-Ch]

  if ( !buf || !field || !buf->document_header )
    return 0;
  len = strlen(field);
  for ( i = buf->document_header->first; i; i = i->next )
  {
    if ( !strncasecmp(i->ptr, field, len) )
      return remove_space(&i->ptr[len]);
  }
  return 0;
}

//----- (0805CBED) --------------------------------------------------------
char *__cdecl checkContentType(Buffer *buf)
{
  int v2; // eax
  Str r; // [esp+18h] [ebp-10h]
  char *p; // [esp+1Ch] [ebp-Ch]
  char *pa; // [esp+1Ch] [ebp-Ch]
  char *pb; // [esp+1Ch] [ebp-Ch]
  char *pc; // [esp+1Ch] [ebp-Ch]

  p = checkHeader(buf, "Content-Type:");
  if ( !p )
    return 0;
  r = Strnew();
  while ( *p && *p != 59 && (MYCTYPE_MAP[(unsigned __int8)*p] & 2) == 0 )
  {
    if ( r->length + 1 >= r->area_size )
      Strgrow(r);
    v2 = r->length;
    r->ptr[v2] = *p;
    r->length = v2 + 1;
    ++p;
    r->ptr[r->length] = 0;
  }
  pa = (char *)strcasestr(p, "charset");
  if ( pa )
  {
    for ( pb = pa + 7; *pb && (MYCTYPE_MAP[(unsigned __int8)*pb] & 2) != 0; ++pb )
      ;
    if ( *pb == 61 )
    {
      for ( pc = pb + 1; *pc && (MYCTYPE_MAP[(unsigned __int8)*pc] & 2) != 0; ++pc )
        ;
      if ( *pc == 34 )
        ++pc;
      content_charset = wc_guess_charset(pc, 0);
    }
  }
  return r->ptr;
}
// 804A36C: using guessed type int __cdecl strcasestr(_DWORD, _DWORD);

//----- (0805CD5B) --------------------------------------------------------
int __cdecl skip_auth_token(char **pp)
{
  int typ; // [esp+4h] [ebp-Ch]
  int first; // [esp+8h] [ebp-8h]
  char *p; // [esp+Ch] [ebp-4h]

  first = 0;
  p = *pp;
  while ( 2 )
  {
    switch ( *p )
    {
      case 0:
        goto endoftoken;
      case 9:
      case 32:
      case 34:
      case 40:
      case 41:
      case 44:
      case 47:
      case 58:
      case 59:
      case 60:
      case 61:
      case 62:
      case 63:
      case 64:
      case 91:
      case 92:
      case 93:
      case 127:
        goto LABEL_5;
      default:
        if ( (unsigned __int8)*p <= 0x1Fu )
LABEL_5:
          typ = 1;
        else
          typ = 2;
        if ( !first )
        {
          first = typ;
          goto LABEL_9;
        }
        if ( first == typ )
        {
LABEL_9:
          ++p;
          continue;
        }
endoftoken:
        *pp = p;
        return first;
    }
  }
}

//----- (0805CDCE) --------------------------------------------------------
Str __cdecl extract_auth_val(char **q)
{
  int v1; // eax
  int v2; // eax
  int v3; // eax
  int v4; // eax
  Str val; // [esp+14h] [ebp-14h]
  int quoted; // [esp+18h] [ebp-10h]
  char *qq; // [esp+1Ch] [ebp-Ch]

  qq = *q;
  quoted = 0;
  val = Strnew();
  while ( *qq && (MYCTYPE_MAP[(unsigned __int8)*qq] & 2) != 0 )
    ++qq;
  if ( *qq == 34 )
  {
    quoted = 1;
    if ( val->length + 1 >= val->area_size )
      Strgrow(val);
    v1 = val->length;
    val->ptr[v1] = *qq;
    val->length = v1 + 1;
    ++qq;
    val->ptr[val->length] = 0;
  }
  while ( *qq )
  {
    if ( quoted && *qq == 34 )
    {
      if ( val->length + 1 >= val->area_size )
        Strgrow(val);
      v2 = val->length;
      val->ptr[v2] = *qq;
      val->length = v2 + 1;
      ++qq;
      val->ptr[val->length] = 0;
      break;
    }
    if ( !quoted )
    {
      switch ( *qq )
      {
        case 9:
        case 32:
        case 34:
        case 40:
        case 41:
        case 47:
        case 58:
        case 59:
        case 60:
        case 61:
        case 62:
        case 63:
        case 64:
        case 91:
        case 92:
        case 93:
          ++qq;
          break;
        case 44:
          goto end_token;
        default:
          if ( (unsigned __int8)*qq > 0x1Fu && *qq != 127 )
            goto LABEL_24;
          ++qq;
          break;
      }
      break;
    }
    if ( *qq == 92 )
    {
      if ( val->length + 1 >= val->area_size )
        Strgrow(val);
      v3 = val->length;
      val->ptr[v3] = *qq;
      val->length = v3 + 1;
      ++qq;
      val->ptr[val->length] = 0;
    }
LABEL_24:
    if ( val->length + 1 >= val->area_size )
      Strgrow(val);
    v4 = val->length;
    val->ptr[v4] = *qq;
    val->length = v4 + 1;
    ++qq;
    val->ptr[val->length] = 0;
  }
end_token:
  *q = qq;
  return val;
}
// 805CF34: conditional instruction was optimized away because of '%quoted.4==1'

//----- (0805D007) --------------------------------------------------------
Str __cdecl qstr_unquote(Str s)
{
  int v2; // eax
  Str tmp; // [esp+18h] [ebp-10h]
  char *p; // [esp+1Ch] [ebp-Ch]
  char *pa; // [esp+1Ch] [ebp-Ch]

  if ( !s )
    return 0;
  p = s->ptr;
  if ( *s->ptr != 34 )
    return s;
  tmp = Strnew();
  for ( pa = p + 1; *pa; ++pa )
  {
    if ( *pa == 92 )
      ++pa;
    if ( tmp->length + 1 >= tmp->area_size )
      Strgrow(tmp);
    v2 = tmp->length;
    tmp->ptr[v2] = *pa;
    tmp->length = v2 + 1;
    tmp->ptr[tmp->length] = 0;
  }
  if ( tmp->length > 0 && tmp->ptr[tmp->length - 1] == 34 )
    Strshrink(tmp, 1);
  return tmp;
}

//----- (0805D0EB) --------------------------------------------------------
char *__cdecl extract_auth_param(char *q, auth_param *auth)
{
  size_t len; // [esp+14h] [ebp-14h]
  char *p; // [esp+18h] [ebp-10h]
  char *pa; // [esp+18h] [ebp-10h]
  auth_param *ap; // [esp+1Ch] [ebp-Ch]
  auth_param *apa; // [esp+1Ch] [ebp-Ch]

  for ( ap = auth; ap->name; ++ap )
    ap->val = 0;
  while ( *q )
  {
    while ( *q && (MYCTYPE_MAP[(unsigned __int8)*q] & 2) != 0 )
      ++q;
    for ( apa = auth; apa->name; ++apa )
    {
      len = strlen(apa->name);
      if ( !strncasecmp(q, apa->name, len) && ((MYCTYPE_MAP[(unsigned __int8)q[len]] & 2) != 0 || q[len] == 61) )
      {
        for ( p = &q[len]; *p && (MYCTYPE_MAP[(unsigned __int8)*p] & 2) != 0; ++p )
          ;
        if ( *p != 61 )
          return q;
        q = p + 1;
        apa->val = extract_auth_val(&q);
        break;
      }
    }
    if ( !apa->name )
    {
      pa = q;
      if ( skip_auth_token(&q) != 2 || (MYCTYPE_MAP[(unsigned __int8)*q] & 2) == 0 && *q != 61 )
        return pa;
      while ( *q && (MYCTYPE_MAP[(unsigned __int8)*q] & 2) != 0 )
        ++q;
      if ( *q != 61 )
        return pa;
      ++q;
      extract_auth_val(&q);
    }
    if ( *q )
    {
      while ( *q && (MYCTYPE_MAP[(unsigned __int8)*q] & 2) != 0 )
        ++q;
      if ( *q != 44 )
        return q;
      ++q;
    }
  }
  return q;
}

//----- (0805D322) --------------------------------------------------------
Str __cdecl get_auth_param(auth_param *auth, char *name)
{
  while ( auth->name )
  {
    if ( !strcasecmp(name, auth->name) )
      return auth->val;
    ++auth;
  }
  return 0;
}

//----- (0805D364) --------------------------------------------------------
Str __cdecl AuthBasicCred(http_auth *ha, Str uname, Str pw, ParsedURL *pu, HRequest *hr, FormList *request)
{
  int v6; // eax
  Str v7; // eax
  Str s; // [esp+1Ch] [ebp-Ch]

  s = Strdup(uname);
  if ( s->length + 1 >= s->area_size )
    Strgrow(s);
  v6 = s->length;
  s->ptr[v6] = 58;
  s->length = v6 + 1;
  s->ptr[s->length] = 0;
  savexmlstr_0(s, pw);
  v7 = encodeB(s->ptr);
  return Strnew_m_charp("Basic ", v7->ptr, 0);
}

//----- (0805D3FE) --------------------------------------------------------
http_auth *__cdecl findAuthentication(http_auth *hauth, Buffer *buf, char *auth_field)
{
  http_auth *result; // eax
  char *p; // [esp+18h] [ebp-20h] BYREF
  char *p0; // [esp+1Ch] [ebp-1Ch]
  TextListItem *i; // [esp+20h] [ebp-18h]
  int slen; // [esp+24h] [ebp-14h]
  int len; // [esp+28h] [ebp-10h]
  http_auth *ha; // [esp+2Ch] [ebp-Ch]

  len = strlen(auth_field);
  bzero(hauth, 0x10u);
  for ( i = buf->document_header->first; i; i = i->next )
  {
    if ( !strncasecmp(i->ptr, auth_field, len) )
    {
      p = &i->ptr[len];
      while ( p && *p )
      {
        while ( *p && (MYCTYPE_MAP[(unsigned __int8)*p] & 2) != 0 )
          ++p;
        p0 = p;
        for ( ha = www_auth; ha->scheme; ++ha )
        {
          slen = strlen(ha->scheme);
          if ( !strncasecmp(p, ha->scheme, slen) )
          {
            for ( p += slen; *p && (MYCTYPE_MAP[(unsigned __int8)*p] & 2) != 0; ++p )
              ;
            if ( hauth->pri < ha->pri )
            {
              *hauth = *ha;
              p = extract_auth_param(p, hauth->param);
              break;
            }
            p = extract_auth_param(p, none_auth_param);
          }
        }
        if ( p0 == p )
        {
          if ( skip_auth_token(&p) != 2 || (MYCTYPE_MAP[(unsigned __int8)*p] & 2) == 0 )
            break;
          while ( *p && (MYCTYPE_MAP[(unsigned __int8)*p] & 2) != 0 )
            ++p;
          p = extract_auth_param(p, none_auth_param);
        }
      }
    }
  }
  if ( hauth->scheme )
    result = hauth;
  else
    result = 0;
  return result;
}

//----- (0805D642) --------------------------------------------------------
void __cdecl getAuthCookie(http_auth *hauth, char *auth_header, TextList *extra_header, ParsedURL *pu, HRequest *hr, FormList *request, volatile Str *uname, volatile Str *pwd)
{
  _Str *v8; // eax
  Str v9; // eax
  wc_ces v10; // esi
  wc_ces v11; // ebx
  _Str *v12; // eax
  Str v13; // eax
  wc_ces v14; // esi
  wc_ces v15; // ebx
  _Str *v16; // eax
  const char *v17; // eax
  const char *v18; // eax
  char *v19; // eax
  char *v20; // eax
  char *pp; // [esp+20h] [ebp-28h]
  char *ppa; // [esp+20h] [ebp-28h]
  _BOOL4 proxy; // [esp+24h] [ebp-24h]
  char *realm; // [esp+28h] [ebp-20h]
  int auth_header_len; // [esp+2Ch] [ebp-1Ch]
  int a_found; // [esp+30h] [ebp-18h]
  TextListItem *i; // [esp+34h] [ebp-14h]
  _Str *tmp; // [esp+38h] [ebp-10h]
  Str ss_0; // [esp+3Ch] [ebp-Ch]

  auth_header_len = strlen(auth_header);
  realm = 0;
  if ( hauth )
  {
    v8 = get_auth_param(hauth->param, "realm");
    realm = qstr_unquote(v8)->ptr;
  }
  if ( realm )
  {
    a_found = 0;
    for ( i = extra_header->first; i; i = i->next )
    {
      if ( !strncasecmp(i->ptr, auth_header, auth_header_len) )
      {
        a_found = 1;
        break;
      }
    }
    proxy = strncasecmp("Proxy-Authorization:", auth_header, auth_header_len) == 0;
    if ( a_found )
    {
      if ( fmInitialized )
      {
        message("Wrong username or password", 0, 0);
        refresh();
      }
      else
      {
        fwrite("Wrong username or password\n", 1u, 0x1Bu, stderr);
      }
      sleep(1u);
      delValue((GeneralList *)extra_header, (ListItem *)i);
      invalidate_auth_user_passwd(pu, realm, *(Str *)uname, *(Str *)pwd, proxy);
    }
    *uname = 0;
    *pwd = 0;
    if ( a_found || !find_auth_user_passwd(pu, realm, (Str *)uname, (Str *)pwd, proxy) )
    {
      if ( QuietMessage[0] )
        return;
      sleep(2u);
      if ( fmInitialized )
      {
        term_raw();
        v9 = Sprintf("Username for %s: ", realm);
        pp = inputLineHistSearch(v9->ptr, 0, 16, 0, 0);
        if ( !pp )
          return;
        v10 = SystemCharset;
        v11 = InnerCharset;
        v12 = Strnew_charp(pp);
        *uname = wc_Str_conv_strict(v12, v11, v10);
        v13 = Sprintf("Password for %s: ", realm);
        ppa = inputLineHistSearch(v13->ptr, 0, 64, 0, 0);
        if ( !ppa )
        {
          *uname = 0;
          return;
        }
        v14 = SystemCharset;
        v15 = InnerCharset;
        v16 = Strnew_charp(ppa);
        *pwd = wc_Str_conv_strict(v16, v15, v14);
        term_cbreak();
      }
      else
      {
        if ( feof(stdin) || ferror(stdin) )
        {
          fprintf(stderr, "w3m: Authorization required for %s\n", realm);
          exit(1);
        }
        if ( proxy )
          v17 = "Proxy Username for %s: ";
        else
          v17 = "Username for %s: ";
        printf(v17, realm);
        fflush(stdout);
        *uname = Strfgets(stdin);
        Strchop(*(Str *)uname);
        if ( proxy )
          v18 = "Proxy Password: ";
        else
          v18 = "Password: ";
        v19 = getpass(v18);
        *pwd = Strnew_charp(v19);
      }
    }
    ss_0 = hauth->cred(hauth, *uname, *pwd, pu, hr, request);
    if ( ss_0 )
    {
      tmp = Strnew_charp(auth_header);
      Strcat_m_charp(tmp, " ", ss_0->ptr, "\r\n", 0);
      v20 = allocStr(tmp->ptr, -1);
      pushValue((GeneralList *)extra_header, v20);
    }
    else
    {
      *uname = 0;
      *pwd = 0;
    }
  }
}

//----- (0805DAA4) --------------------------------------------------------
int __cdecl same_url_p(ParsedURL *pu1, ParsedURL *pu2)
{
  return pu1->scheme == pu2->scheme
      && pu1->port == pu2->port
      && (!pu1->host || pu2->host && !strcasecmp(pu1->host, pu2->host))
      && (!pu1->file || pu2->file && !strcmp(pu1->file, pu2->file));
}

//----- (0805DB36) --------------------------------------------------------
int __cdecl checkRedirection(ParsedURL *pu)
{
  int result; // eax
  Str v2; // eax
  Str v3; // eax
  Str tmp; // [esp+2Ch] [ebp-Ch]
  Str tmpa; // [esp+2Ch] [ebp-Ch]

  if ( pu )
  {
    if ( nredir_10889 < FollowRedirection )
    {
      if ( nredir_size_10890 > 0
        && (same_url_p(pu, &puv_10888[(nredir_10889 - 1) % nredir_size_10890])
         || (nredir_10889 & 1) == 0 && same_url_p(pu, &puv_10888[nredir_10889 / 2 % nredir_size_10890])) )
      {
        v3 = parsedURL2Str(pu);
        tmpa = Sprintf("Redirection loop detected (%s)", v3->ptr);
        _ZN10bdInetAddrC2Ej(tmpa->ptr, 0);
        result = 0;
      }
      else
      {
        if ( !puv_10888 )
        {
          nredir_size_10890 = FollowRedirection / 2 + 1;
          puv_10888 = (ParsedURL *)GC_malloc(40 * (FollowRedirection / 2 + 1));
          memset(puv_10888, 0, 40 * nredir_size_10890);
        }
        copyParsedURL(&puv_10888[nredir_10889 % nredir_size_10890], pu);
        ++nredir_10889;
        result = 1;
      }
    }
    else
    {
      v2 = parsedURL2Str(pu);
      tmp = Sprintf("Number of redirections exceeded %d at %s", FollowRedirection, v2->ptr);
      _ZN10bdInetAddrC2Ej(tmp->ptr, 0);
      result = 0;
    }
  }
  else
  {
    nredir_10889 = 0;
    nredir_size_10890 = 0;
    puv_10888 = 0;
    result = 1;
  }
  return result;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (0805DD60) --------------------------------------------------------
Buffer *__cdecl loadGeneralFile(char *path, ParsedURL *volatile current, char *referer, int flag, FormList *volatile request)
{
  Buffer *result; // eax
  Str v6; // eax
  Str v7; // eax
  Str v8; // eax
  int v9; // eax
  int v10; // eax
  wc_ces v11; // esi
  wc_ces v12; // ebx
  _Str *v13; // eax
  Str v14; // eax
  int v15; // eax
  int v16; // eax
  _Str *v17; // esi
  _Str *v18; // ebx
  Str v19; // eax
  char *v20; // eax
  int v21; // eax
  int v22; // eax
  int v23; // eax
  int v24; // eax
  int v25; // eax
  wc_ces v26; // esi
  wc_ces v27; // ebx
  char *v28; // eax
  _Str *v29; // eax
  Str v30; // eax
  int v31; // eax
  wc_ces v32; // esi
  wc_ces v33; // ebx
  char *v34; // eax
  _Str *v35; // eax
  int v36; // eax
  int v37; // eax
  int v38; // eax
  int v39; // eax
  char *v40; // eax
  wc_ces v41; // esi
  wc_ces v42; // ebx
  char *v43; // eax
  _Str *v44; // eax
  Str v45; // eax
  char *v46; // eax
  int v47; // eax
  int v48; // eax
  char *v49; // eax
  Buffer *v50; // ebx
  URLFile v51; // [esp+30h] [ebp-168h] BYREF
  stat st; // [esp+50h] [ebp-148h] BYREF
  ParsedURL pu; // [esp+A8h] [ebp-F0h] BYREF
  URLFile f; // [esp+D0h] [ebp-C8h] BYREF
  HRequest hr; // [esp+F0h] [ebp-A8h] BYREF
  URLOption url_option; // [esp+FCh] [ebp-9Ch] BYREF
  int l; // [esp+104h] [ebp-94h]
  Anchor *a; // [esp+108h] [ebp-90h]
  Str s_0; // [esp+10Ch] [ebp-8Ch]
  Buffer *b_0; // [esp+110h] [ebp-88h]
  char *file_0; // [esp+114h] [ebp-84h]
  char *file; // [esp+118h] [ebp-80h]
  Str s; // [esp+11Ch] [ebp-7Ch]
  FILE *src; // [esp+120h] [ebp-78h]
  char *t1; // [esp+124h] [ebp-74h]
  Str cmd; // [esp+128h] [ebp-70h]
  ParsedURL *auth_pu; // [esp+12Ch] [ebp-6Ch]
  wc_ces charset; // [esp+130h] [ebp-68h] BYREF
  Str page; // [esp+134h] [ebp-64h]
  Str tmp; // [esp+138h] [ebp-60h]
  int add_auth_cookie_flag; // [esp+13Ch] [ebp-5Ch]
  Str realm; // [esp+140h] [ebp-58h]
  Str pwd; // [esp+144h] [ebp-54h] BYREF
  Str uname; // [esp+148h] [ebp-50h] BYREF
  TextList *extra_header; // [esp+14Ch] [ebp-4Ch]
  void (*prevtrap)(int); // [esp+150h] [ebp-48h]
  int searchHeader_through; // [esp+154h] [ebp-44h]
  int searchHeader; // [esp+158h] [ebp-40h]
  Buffer *t_buf; // [esp+15Ch] [ebp-3Ch]
  char *real_type; // [esp+160h] [ebp-38h]
  char *p; // [esp+164h] [ebp-34h]
  char *t; // [esp+168h] [ebp-30h]
  char *tpath; // [esp+16Ch] [ebp-2Ch]
  Buffer *(*proc)(...); // [esp+170h] [ebp-28h]
  Buffer *b; // [esp+174h] [ebp-24h] BYREF
  URLFile *of_0; // [esp+178h] [ebp-20h]
  unsigned __int8 status[25]; // [esp+17Fh] [ebp-19h] BYREF

  of_0 = 0;
  b = 0;
  proc = (Buffer *(*)(...))loadBuffer;
  t = "text/plain";
  real_type = 0;
  t_buf = 0;
  searchHeader = SearchHeader[0];
  searchHeader_through = 1;
  extra_header = (TextList *)newGeneralList();
  uname = 0;
  pwd = 0;
  realm = 0;
  status[0] = 0;
  page = 0;
  charset = 256;
  tpath = path;
  prevtrap = 0;
  add_auth_cookie_flag = 0;
  checkRedirection(0);
  while ( 1 )
  {
    while ( 1 )
    {
      if ( TrapSignal )
      {
        if ( fmInitialized )
          term_raw();
        if ( prevtrap )
          mySignal(2, prevtrap);
      }
      url_option.referer = referer;
      url_option.flag = flag;
      openURL(&v51, tpath, &pu, current, &url_option, request, extra_header, of_0, &hr, status);
      f = v51;
      of_0 = 0;
      content_charset = 0;
      if ( !v51.stream )
      {
        if ( f.scheme == 4 )
        {
          if ( stat_0(pu.real_file, (int)&st) < 0 )
            return 0;
          if ( (st.st_mode & 0xF000) == 0x4000 )
          {
            if ( UseExternalDirBuffer )
            {
              cmd = Sprintf("%s?dir=%s#current", DirBufferCommand, pu.file);
              b = loadGeneralFile(cmd->ptr, 0, (char *)0xFFFFFFFF, 0, 0);
              if ( b && b != (Buffer *)1 )
              {
                copyParsedURL(&b->currentURL, &pu);
                b->filename = b->currentURL.real_file;
              }
              return b;
            }
            page = loadLocalDir(pu.real_file);
            t = "local:directory";
            charset = SystemCharset;
          }
        }
        else if ( f.scheme > 4u )
        {
          if ( f.scheme == 10 )
          {
            page = loadNewsgroup(&pu, &charset);
            t = "news:group";
          }
          else if ( f.scheme == 255 )
          {
            tmp = searchURIMethods(&pu);
            if ( tmp )
            {
              b = loadGeneralFile(tmp->ptr, current, referer, flag, request);
              if ( b && b != (Buffer *)1 )
                copyParsedURL(&b->currentURL, &pu);
              return b;
            }
            v6 = parsedURL2Str(&pu);
            v7 = Sprintf("Unknown URI: %s", v6->ptr);
            _ZN10bdInetAddrC2Ej(v7->ptr, 0);
          }
        }
        else if ( f.scheme == 3 )
        {
          page = loadFTPDir(&pu, &charset);
          t = "ftp:directory";
        }
        if ( !page || page->length <= 0 )
          return 0;
        goto page_loaded;
      }
      if ( status[0] == 0xFE )
      {
        if ( TrapSignal )
        {
          if ( fmInitialized )
            term_raw();
          if ( prevtrap )
            mySignal(2, prevtrap);
        }
        if ( !ISclose(f.stream) )
          f.stream = 0;
        return 0;
      }
      if ( __sigsetjmp(AbortLoading, 1) )
      {
        if ( TrapSignal )
        {
          if ( fmInitialized )
            term_raw();
          if ( prevtrap )
            mySignal(2, prevtrap);
        }
        if ( b )
          discardBuffer(b);
        if ( !ISclose(f.stream) )
          f.stream = 0;
        return 0;
      }
      b = 0;
      if ( f.is_cgi )
      {
        searchHeader = 1;
        searchHeader_through = 0;
      }
      if ( header_string )
        header_string = 0;
      if ( TrapSignal )
      {
        prevtrap = mySignal(2, KeyAbort);
        if ( fmInitialized )
          term_cbreak();
      }
      if ( pu.scheme
        && ((pu.scheme != 1 || !non_null(GOPHER_proxy)) && (pu.scheme != 2 || !non_null(FTP_proxy))
         || !use_proxy
         || check_no_proxy(pu.host)) )
      {
        break;
      }
      if ( fmInitialized )
      {
        term_cbreak();
        v8 = Sprintf("%s contacted. Waiting for reply...", pu.host);
        message(v8->ptr, 0, 0);
        refresh();
      }
      if ( !t_buf )
      {
        if ( showLineNum )
          v9 = 6;
        else
          v9 = 1;
        v10 = COLS - v9;
        if ( v10 < 0 )
          v10 = 0;
        t_buf = newBuffer(v10);
      }
      readHeader(&f, t_buf, 0, &pu);
      if ( http_response_code > 300 && http_response_code <= 303 || http_response_code == 307 )
      {
        p = checkHeader(t_buf, "Location:");
        if ( p )
        {
          if ( checkRedirection(&pu) )
          {
            v11 = DocumentCharset;
            v12 = InnerCharset;
            v13 = Strnew_charp(p);
            v14 = wc_Str_conv_strict(v13, v12, v11);
            tpath = url_quote(v14->ptr);
            request = 0;
            if ( !ISclose(f.stream) )
              f.stream = 0;
            current = (ParsedURL *volatile)GC_malloc(40);
            copyParsedURL(current, &pu);
            if ( showLineNum )
              v15 = 6;
            else
              v15 = 1;
            v16 = COLS - v15;
            if ( v16 < 0 )
              v16 = 0;
            goto LABEL_90;
          }
        }
      }
      t = checkContentType(t_buf);
      if ( !t
        && pu.file
        && (http_response_code <= 399 || http_response_code > 407)
        && (http_response_code <= 499 || http_response_code > 505) )
      {
        t = guessContentType(pu.file);
      }
      if ( !t )
        t = "text/plain";
      if ( add_auth_cookie_flag && realm && uname && pwd )
      {
        v17 = pwd;
        v18 = uname;
        v19 = qstr_unquote(realm);
        add_auth_user_passwd(&pu, v19->ptr, v18, v17, 0);
        add_auth_cookie_flag = 0;
      }
      p = checkHeader(t_buf, "WWW-Authenticate:");
      if ( p
        && http_response_code == 401
        && findAuthentication((http_auth *)&st, t_buf, "WWW-Authenticate:")
        && (realm = get_auth_param(*(auth_param **)&st.__pad1, "realm")) != 0 )
      {
        auth_pu = &pu;
        getAuthCookie((http_auth *)&st, "Authorization:", extra_header, &pu, &hr, request, &uname, &pwd);
        if ( !uname )
        {
          if ( TrapSignal )
          {
            if ( fmInitialized )
              term_raw();
            if ( prevtrap )
              goto LABEL_160;
          }
          goto page_loaded;
        }
        if ( !ISclose(f.stream) )
          f.stream = 0;
        add_auth_cookie_flag = 1;
        status[0] = 0;
      }
      else
      {
        p = checkHeader(t_buf, "Proxy-Authenticate:");
        if ( p
          && http_response_code == 407
          && findAuthentication((http_auth *)&st, t_buf, "Proxy-Authenticate:")
          && (realm = get_auth_param(*(auth_param **)&st.__pad1, "realm")) != 0 )
        {
          auth_pu = schemeToProxy(pu.scheme);
          getAuthCookie((http_auth *)&st, "Proxy-Authorization:", extra_header, auth_pu, &hr, request, &uname, &pwd);
          if ( !uname )
          {
            if ( TrapSignal )
            {
              if ( fmInitialized )
                term_raw();
              if ( prevtrap )
                goto LABEL_160;
            }
            goto page_loaded;
          }
          if ( !ISclose(f.stream) )
            f.stream = 0;
          add_auth_cookie_flag = 1;
          status[0] = 0;
        }
        else
        {
          if ( status[0] != 1 )
          {
            v20 = checkHeader(t_buf, "Last-Modified:");
            f.modtime = mymktime(v20);
            goto LABEL_201;
          }
          of_0 = &f;
        }
      }
    }
    if ( pu.scheme == 9 || pu.scheme == 7 )
    {
      if ( !t_buf )
      {
        if ( showLineNum )
          v21 = 6;
        else
          v21 = 1;
        v22 = COLS - v21;
        if ( v22 < 0 )
          v22 = 0;
        t_buf = newBuffer(v22);
      }
      readHeader(&f, t_buf, 1, &pu);
      t = checkContentType(t_buf);
      if ( !t )
        t = "text/plain";
      goto LABEL_201;
    }
    if ( pu.scheme == 1 )
      break;
    if ( pu.scheme == 2 )
    {
      check_compression(path, &f);
      if ( f.compression )
      {
        t1 = uncompressed_file_type(pu.file, 0);
        real_type = f.guess_type;
        if ( t1 )
          t = t1;
        else
          t = real_type;
      }
      else
      {
        real_type = guessContentType(pu.file);
        if ( !real_type )
          real_type = "text/plain";
        t = real_type;
      }
      goto LABEL_201;
    }
    if ( pu.scheme == 11 )
    {
      t = f.guess_type;
      goto LABEL_201;
    }
    if ( !searchHeader )
    {
      if ( DefaultType )
      {
        t = DefaultType;
        DefaultType = 0;
      }
      else
      {
        t = guessContentType(pu.file);
        if ( !t )
          t = "text/plain";
        real_type = t;
        if ( f.guess_type )
          t = f.guess_type;
      }
      goto LABEL_201;
    }
    SearchHeader[0] = 0;
    searchHeader = 0;
    if ( !t_buf )
    {
      if ( showLineNum )
        v24 = 6;
      else
        v24 = 1;
      v25 = COLS - v24;
      if ( v25 < 0 )
        v25 = 0;
      t_buf = newBuffer(v25);
    }
    readHeader(&f, t_buf, searchHeader_through, &pu);
    if ( !f.is_cgi || (p = checkHeader(t_buf, "Location:")) == 0 || !checkRedirection(&pu) )
    {
      t = checkContentType(t_buf);
      if ( !t )
        t = "text/plain";
      goto LABEL_201;
    }
    v26 = DocumentCharset;
    v27 = InnerCharset;
    v28 = remove_space(p);
    v29 = Strnew_charp(v28);
    v30 = wc_Str_conv_strict(v29, v27, v26);
    tpath = url_quote(v30->ptr);
    request = 0;
    if ( !ISclose(f.stream) )
      f.stream = 0;
    add_auth_cookie_flag = 0;
    current = (ParsedURL *volatile)GC_malloc(40);
    copyParsedURL(current, &pu);
    if ( showLineNum )
      v31 = 6;
    else
      v31 = 1;
    v16 = COLS - v31;
    if ( v16 < 0 )
      v16 = 0;
LABEL_90:
    t_buf = newBuffer(v16);
    t_buf->bufferprop |= 0x20u;
    status[0] = 0;
  }
  v23 = *pu.file;
  if ( v23 == 103 )
  {
    t = "image/gif";
    goto LABEL_201;
  }
  if ( v23 > 103 )
  {
    if ( v23 != 109 )
    {
      if ( v23 == 115 )
      {
        t = "audio/basic";
      }
      else if ( v23 == 104 )
      {
        t = "text/html";
      }
      goto LABEL_201;
    }
  }
  else
  {
    if ( v23 == 48 )
    {
      t = "text/plain";
      goto LABEL_201;
    }
    if ( v23 != 49 )
    {
LABEL_201:
      f.guess_type = t;
      goto page_loaded;
    }
  }
  page = loadGopherDir(&f, &pu, &charset);
  t = "gopher:directory";
  if ( TrapSignal )
  {
    if ( fmInitialized )
      term_raw();
    if ( prevtrap )
    {
LABEL_160:
      mySignal(2, prevtrap);
      goto page_loaded;
    }
  }
page_loaded:
  if ( page )
  {
    if ( image_source )
      return 0;
    tmp = tmpfname(1, ".html");
    src = fopen(tmp->ptr, "w");
    if ( src )
    {
      s = wc_Str_conv_strict(page, InnerCharset, charset);
      fwrite(s->ptr, 1u, s->length, src);
      fclose(src);
    }
    if ( do_download )
    {
      if ( src )
      {
        file = guess_filename(pu.file);
        if ( f.scheme == 1 )
          file = Sprintf("%s.html", file)->ptr;
        if ( f.scheme == 10 )
          file = Sprintf("%s.html", file)->ptr;
        doFileMove(tmp->ptr, file);
        result = (Buffer *)1;
      }
      else
      {
        result = 0;
      }
    }
    else
    {
      b = loadHTMLString(page);
      if ( b )
      {
        copyParsedURL(&b->currentURL, &pu);
        b->real_scheme = pu.scheme;
        b->real_type = t;
        if ( src )
          b->sourcefile = tmp->ptr;
        b->document_charset = charset;
      }
      result = b;
    }
    return result;
  }
  if ( !real_type )
    real_type = t;
  proc = (Buffer *(*)(...))loadBuffer;
  cur_baseURL = (ParsedURL *)GC_malloc(40);
  copyParsedURL(cur_baseURL, &pu);
  current_content_length = 0LL;
  p = checkHeader(t_buf, "Content-Length:");
  if ( p )
    current_content_length = strtoclen(p);
  if ( do_download )
  {
    if ( TrapSignal )
    {
      if ( fmInitialized )
        term_raw();
      if ( prevtrap )
        mySignal(2, prevtrap);
    }
    if ( DecodeCTE && f.stream->base.type != 4 )
      f.stream = newEncodedStream(f.stream, f.encoding);
    if ( pu.scheme == 4 )
    {
      if ( PreserveTimestamp && !stat_0(pu.real_file, (int)&st) )
        f.modtime = st.st_mtim.tv_sec;
      v32 = InnerCharset;
      v33 = SystemCharset;
      v34 = guess_save_name(0, pu.real_file);
      v35 = Strnew_charp(v34);
      file_0 = wc_Str_conv(v35, v33, v32)->ptr;
    }
    else
    {
      file_0 = guess_save_name(t_buf, pu.file);
    }
    if ( doFileSave(f, file_0) )
    {
      if ( !ISclose(f.stream) )
        f.stream = 0;
    }
    else
    {
      UFhalfclose(&f);
    }
    return (Buffer *)1;
  }
  if ( f.content_encoding && AutoUncompress && (w3m_dump & 8) == 0 )
  {
    uncompress_stream(&f, &pu.real_file);
  }
  else if ( f.compression )
  {
    if ( (w3m_dump & 4) == 0 && ((w3m_dump & 0xFFFFFFDF) != 0 || is_text_type(t) || searchExtViewer(t)) )
    {
      if ( !t_buf )
      {
        if ( showLineNum )
          v36 = 6;
        else
          v36 = 1;
        v37 = COLS - v36;
        if ( v37 < 0 )
          v37 = 0;
        t_buf = newBuffer(v37);
      }
      uncompress_stream(&f, &t_buf->sourcefile);
      uncompressed_file_type(pu.file, &f.ext);
    }
    else
    {
      t = compress_application_type(f.compression);
      f.compression = 0;
    }
  }
  if ( image_source )
  {
    b_0 = 0;
    if ( f.stream->base.type != 4 )
      f.stream = newEncodedStream(f.stream, f.encoding);
    if ( !save2tmp(f, image_source) )
    {
      if ( showLineNum )
        v38 = 6;
      else
        v38 = 1;
      v39 = COLS - v38;
      if ( v39 < 0 )
        v39 = 0;
      b_0 = newBuffer(v39);
      b_0->sourcefile = image_source;
      b_0->real_type = t;
    }
    if ( !ISclose(f.stream) )
      f.stream = 0;
    if ( TrapSignal )
    {
      if ( fmInitialized )
        term_raw();
      if ( prevtrap )
        mySignal(2, prevtrap);
    }
    return b_0;
  }
  if ( is_html_type(t) )
  {
    proc = (Buffer *(*)(...))loadHTMLBuffer;
LABEL_330:
    if ( (flag & 2) != 0 )
    {
      if ( !t_buf )
      {
        if ( showLineNum )
          v47 = 6;
        else
          v47 = 1;
        v48 = COLS - v47;
        if ( v48 < 0 )
          v48 = 0;
        t_buf = newBuffer(v48);
      }
      t_buf->bufferprop |= 2u;
    }
    frame_source = flag & 4;
    if ( pu.real_file )
      v49 = pu.real_file;
    else
      v49 = pu.file;
    b = loadSomething(&f, v49, (Buffer *(*)(URLFile *, Buffer *))proc, t_buf);
    if ( !ISclose(f.stream) )
      f.stream = 0;
    frame_source = 0;
    if ( b )
    {
      b->real_scheme = f.scheme;
      b->real_type = real_type;
      if ( !b->currentURL.host && !b->currentURL.file )
        copyParsedURL(&b->currentURL, &pu);
      if ( is_html_type(t) )
      {
        b->type = "text/html";
      }
      else if ( w3m_backend )
      {
        s_0 = Strnew_charp(t);
        b->type = s_0->ptr;
      }
      else if ( (char *)proc == (char *)loadImageBuffer )
      {
        b->type = "text/html";
      }
      else
      {
        b->type = "text/plain";
      }
      if ( pu.label )
      {
        if ( (char *)proc == (char *)loadHTMLBuffer )
        {
          a = searchURLLabel(b, pu.label);
          if ( a )
          {
            gotoLine(b, a->start.line);
            if ( label_topline )
            {
              v50 = b;
              v50->topLine = lineSkip(b, b->topLine, b->currentLine->linenumber - b->topLine->linenumber, 0);
            }
            b->pos = a->start.pos;
            arrangeCursor(b);
          }
        }
        else
        {
          l = atoi(pu.label);
          gotoRealLine(b, l);
          b->pos = 0;
          arrangeCursor(b);
        }
      }
    }
    if ( header_string )
      header_string = 0;
    if ( f.scheme == 7 || f.scheme == 9 )
      reAnchorNewsheader(b);
    preFormUpdateBuffer(b);
    if ( TrapSignal )
    {
      if ( fmInitialized )
        term_raw();
      if ( prevtrap )
        mySignal(2, prevtrap);
    }
    return b;
  }
  if ( is_plain_text_type(t) )
  {
    proc = (Buffer *(*)(...))loadBuffer;
    goto LABEL_330;
  }
  if ( activeImage
    && displayImage
    && !useExtImageViewer
    && (w3m_dump & 0xFFFFFFDF) == 0
    && !strncasecmp(t, "image/", 6u) )
  {
    proc = (Buffer *(*)(...))loadImageBuffer;
    goto LABEL_330;
  }
  if ( w3m_backend )
    goto LABEL_330;
  if ( (w3m_dump & 0xFFFFFFDF) != 0 && !is_dump_text_type(t) )
  {
    if ( (w3m_dump & 0x20) != 0 )
      return 0;
    goto LABEL_330;
  }
  if ( do_download || (!pu.real_file ? (v40 = pu.file) : (v40 = pu.real_file), !doExternal(f, v40, t, &b, t_buf)) )
  {
    if ( TrapSignal )
    {
      if ( fmInitialized )
        term_raw();
      if ( prevtrap )
        mySignal(2, prevtrap);
    }
    if ( pu.scheme == 4 )
    {
      if ( !ISclose(f.stream) )
        f.stream = 0;
      v41 = InnerCharset;
      v42 = SystemCharset;
      v43 = guess_save_name(0, pu.real_file);
      v44 = Strnew_charp(v43);
      v45 = wc_Str_conv(v44, v42, v41);
      doFileCopy(pu.real_file, v45->ptr, 1);
    }
    else
    {
      if ( DecodeCTE && f.stream->base.type != 4 )
        f.stream = newEncodedStream(f.stream, f.encoding);
      v46 = guess_save_name(t_buf, pu.file);
      if ( doFileSave(f, v46) )
      {
        if ( !ISclose(f.stream) )
          f.stream = 0;
      }
      else
      {
        UFhalfclose(&f);
      }
    }
    result = (Buffer *)1;
  }
  else
  {
    if ( b )
    {
      if ( b != (Buffer *)1 )
      {
        b->real_scheme = f.scheme;
        b->real_type = real_type;
        if ( !b->currentURL.host && !b->currentURL.file )
          copyParsedURL(&b->currentURL, &pu);
      }
    }
    if ( !ISclose(f.stream) )
      f.stream = 0;
    if ( TrapSignal )
    {
      if ( fmInitialized )
        term_raw();
      if ( prevtrap )
        mySignal(2, prevtrap);
    }
    result = b;
  }
  return result;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (0805FA4E) --------------------------------------------------------
char *__cdecl has_hidden_link(readbuffer *obuf, int cmd)
{
  link_stack *p; // [esp+8h] [ebp-8h]
  Str line; // [esp+Ch] [ebp-4h]

  line = obuf->line;
  if ( obuf->line->length <= 0 || line->ptr[line->length - 1] != 62 )
    return 0;
  for ( p = link_stack_0; p && p->cmd != cmd; p = p->next )
    ;
  if ( !p )
    return 0;
  if ( obuf->pos == p->pos )
    return &line->ptr[p->offset];
  return 0;
}

//----- (0805FAE4) --------------------------------------------------------
void __cdecl push_link(int cmd, int offset, int pos)
{
  link_stack *p; // [esp+1Ch] [ebp-Ch]

  p = (link_stack *)GC_malloc(12);
  p->cmd = cmd;
  p->offset = offset;
  p->pos = pos;
  p->next = link_stack_0;
  link_stack_0 = p;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (0805FB2F) --------------------------------------------------------
int __cdecl is_period_char(unsigned __int8 *ch_0)
{
  int result; // eax

  switch ( *ch_0 )
  {
    case '!':
    case ')':
    case ',':
    case '.':
    case ':':
    case ';':
    case '>':
    case '?':
    case ']':
    case '}':
      result = 1;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

//----- (0805FB5A) --------------------------------------------------------
int __cdecl is_beginning_char(unsigned __int8 *ch_0)
{
  int v1; // eax

  v1 = *ch_0;
  if ( v1 == 91 )
    return 1;
  if ( *ch_0 > 0x5Bu )
    return v1 == 96 || v1 == 123;
  return v1 == 40 || v1 == 60;
}

//----- (0805FB94) --------------------------------------------------------
int __cdecl is_word_char(unsigned __int8 *ch_0)
{
  int result; // eax
  Lineprop ctype; // [esp+Eh] [ebp-2h]

  ctype = WTF_TYPE_MAP[*ch_0] << 8;
  if ( (ctype & 0x1900) != 0 )
    return 0;
  if ( (ctype & 0x600) != 0 )
    return 1;
  if ( (MYCTYPE_MAP[*ch_0] & 0xC) != 0 )
    return 1;
  switch ( *ch_0 )
  {
    case '"':
    case '$':
    case '%':
    case '\'':
    case '*':
    case '+':
    case ',':
    case '-':
    case '.':
    case ':':
    case '@':
    case '_':
    case '~':
      result = 1;
      break;
    default:
      result = *ch_0 == 0xA0;
      break;
  }
  return result;
}

//----- (0805FC36) --------------------------------------------------------
int __cdecl is_combining_char(unsigned __int8 *ch_0)
{
  return ((WTF_TYPE_MAP[*ch_0] << 8) & 0x400) != 0;
}

//----- (0805FC71) --------------------------------------------------------
int __cdecl is_boundary(unsigned __int8 *ch1, unsigned __int8 *ch2)
{
  if ( !*ch1 || !*ch2 )
    return 1;
  if ( *ch1 == 32 && *ch2 == 32 )
    return 0;
  if ( *ch1 != 32 && is_period_char(ch2) )
    return 0;
  if ( *ch2 != 32 && is_beginning_char(ch1) )
    return 0;
  if ( is_combining_char(ch2) )
    return 0;
  return !is_word_char(ch1) || !is_word_char(ch2);
}

//----- (0805FD35) --------------------------------------------------------
void __cdecl set_breakpoint(readbuffer *obuf, int tag_length)
{
  obuf->bp.len = obuf->line->length;
  obuf->bp.pos = obuf->pos;
  obuf->bp.tlen = tag_length;
  obuf->bp.flag = obuf->flag;
  obuf->bp.top_margin = obuf->top_margin;
  obuf->bp.bottom_margin = obuf->bottom_margin;
  if ( obuf->bp.init_flag )
  {
    bcopy(&obuf->anchor, &obuf->bp.anchor, 0x3Cu);
    obuf->bp.img_alt = obuf->img_alt;
    obuf->bp.fontstat[0] = obuf->fontstat[0];
    obuf->bp.fontstat[2] = obuf->fontstat[2];
    obuf->bp.fontstat[1] = obuf->fontstat[1];
    obuf->bp.fontstat[3] = obuf->fontstat[3];
    obuf->bp.fontstat[4] = obuf->fontstat[4];
    obuf->bp.nobr_level = obuf->nobr_level;
    obuf->bp.prev_ctype = obuf->prev_ctype;
    obuf->bp.init_flag = 0;
  }
}

//----- (0805FE7C) --------------------------------------------------------
void __cdecl back_to_breakpoint(readbuffer *obuf)
{
  obuf->flag = obuf->bp.flag;
  bcopy(&obuf->bp.anchor, &obuf->anchor, 0x3Cu);
  obuf->img_alt = obuf->bp.img_alt;
  obuf->fontstat[0] = obuf->bp.fontstat[0];
  obuf->fontstat[2] = obuf->bp.fontstat[2];
  obuf->fontstat[1] = obuf->bp.fontstat[1];
  obuf->fontstat[3] = obuf->bp.fontstat[3];
  obuf->fontstat[4] = obuf->bp.fontstat[4];
  obuf->prev_ctype = obuf->bp.prev_ctype;
  obuf->pos = obuf->bp.pos;
  obuf->top_margin = obuf->bp.top_margin;
  obuf->bottom_margin = obuf->bp.bottom_margin;
  if ( (obuf->flag & 0x80) != 0 )
    obuf->nobr_level = obuf->bp.nobr_level;
}

//----- (0805FF94) --------------------------------------------------------
void __cdecl append_tags(readbuffer *obuf)
{
  int v1; // eax
  int v2; // eax
  int set_bp; // [esp+14h] [ebp-14h]
  int len; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]

  len = obuf->line->length;
  set_bp = 0;
  for ( i = 0; obuf->tag_sp > i; ++i )
  {
    v1 = obuf->tag_stack[i]->cmd;
    if ( v1 == 65 )
      goto LABEL_10;
    if ( v1 > 65 )
    {
      if ( v1 == 109 || v1 == 136 || v1 == 105 )
      {
LABEL_10:
        push_link(obuf->tag_stack[i]->cmd, obuf->line->length, obuf->pos);
        goto LABEL_11;
      }
    }
    else if ( v1 == 1 || v1 == 7 )
    {
      goto LABEL_10;
    }
LABEL_11:
    Strcat_charp(obuf->line, obuf->tag_stack[i]->cmdname);
    v2 = obuf->tag_stack[i]->cmd;
    if ( v2 == 50 )
    {
      if ( obuf->nobr_level > 1 )
        continue;
LABEL_15:
      set_bp = 1;
      continue;
    }
    if ( v2 == 69 )
      goto LABEL_15;
  }
  obuf->tag_sp = 0;
  if ( set_bp )
    set_breakpoint(obuf, obuf->line->length - len);
}

//----- (080600BA) --------------------------------------------------------
void __cdecl push_tag(readbuffer *obuf, char *cmdname, int cmd)
{
  int v3; // ebx
  cmdtable *v4; // ebx

  v3 = obuf->tag_sp;
  obuf->tag_stack[v3] = (cmdtable *)GC_malloc(8);
  v4 = obuf->tag_stack[obuf->tag_sp];
  v4->cmdname = allocStr(cmdname, -1);
  obuf->tag_stack[obuf->tag_sp]->cmd = cmd;
  if ( ++obuf->tag_sp > 9 || (obuf->flag & 0x20F) != 0 )
    append_tags(obuf);
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (08060163) --------------------------------------------------------
void __cdecl push_nchars(readbuffer *obuf, int width, char *str, int len, Lineprop mode)
{
  int v5; // edx

  append_tags(obuf);
  Strcat_charp_n(obuf->line, str, len);
  obuf->pos += width;
  if ( width > 0 )
  {
    Strcopy_charp_n(obuf->prevchar, str, len);
    obuf->prev_ctype = mode;
  }
  v5 = obuf->flag;
  BYTE1(v5) |= 0x80u;
  obuf->flag = v5;
}

//----- (080601F1) --------------------------------------------------------
void __cdecl check_breakpoint(readbuffer *obuf, int pre_mode, char *ch_0)
{
  int len; // [esp+18h] [ebp-10h]
  int tlen; // [esp+1Ch] [ebp-Ch]

  len = obuf->line->length;
  append_tags(obuf);
  if ( !pre_mode )
  {
    tlen = obuf->line->length - len;
    if ( tlen > 0 || is_boundary((unsigned __int8 *)obuf->prevchar->ptr, (unsigned __int8 *)ch_0) )
      set_breakpoint(obuf, tlen);
  }
}

//----- (08060259) --------------------------------------------------------
void __cdecl push_char(readbuffer *obuf, int pre_mode, char ch_0)
{
  Str v3; // eax
  int v4; // edx
  int v5; // edx
  char ch_0a[12]; // [esp+1Ch] [ebp-Ch] BYREF

  ch_0a[0] = ch_0;
  check_breakpoint(obuf, pre_mode, ch_0a);
  if ( obuf->line->length + 1 >= obuf->line->area_size )
    Strgrow(obuf->line);
  v3 = obuf->line;
  v4 = obuf->line->length;
  obuf->line->ptr[v4] = ch_0a[0];
  v3->length = v4 + 1;
  obuf->line->ptr[obuf->line->length] = 0;
  ++obuf->pos;
  Strcopy_charp_n(obuf->prevchar, ch_0a, 1);
  if ( ch_0a[0] != 32 )
    obuf->prev_ctype = 0;
  v5 = obuf->flag;
  BYTE1(v5) |= 0x80u;
  obuf->flag = v5;
}

//----- (08060330) --------------------------------------------------------
void __cdecl push_spaces(readbuffer *obuf, int pre_mode, int width)
{
  Str v3; // eax
  int v4; // edx
  int v5; // edx
  int i; // [esp+1Ch] [ebp-Ch]

  if ( width > 0 )
  {
    check_breakpoint(obuf, pre_mode, " ");
    for ( i = 0; i < width; ++i )
    {
      if ( obuf->line->length + 1 >= obuf->line->area_size )
        Strgrow(obuf->line);
      v3 = obuf->line;
      v4 = obuf->line->length;
      obuf->line->ptr[v4] = 32;
      v3->length = v4 + 1;
      obuf->line->ptr[obuf->line->length] = 0;
    }
    obuf->pos += width;
    Strcopy_charp_n(obuf->prevchar, " ", 1);
    v5 = obuf->flag;
    BYTE1(v5) |= 0x80u;
    obuf->flag = v5;
  }
}

//----- (08060416) --------------------------------------------------------
void __cdecl proc_mchar(readbuffer *obuf, int pre_mode, int width, char **str, Lineprop mode)
{
  int v5; // edx

  check_breakpoint(obuf, pre_mode, *str);
  obuf->pos += width;
  Strcat_charp_n(obuf->line, *str, WTF_LEN_MAP[(unsigned __int8)**str]);
  if ( width > 0 )
  {
    Strcopy_charp_n(obuf->prevchar, *str, 1);
    if ( **str != 32 )
      obuf->prev_ctype = mode;
  }
  *str += WTF_LEN_MAP[(unsigned __int8)**str];
  v5 = obuf->flag;
  BYTE1(v5) |= 0x80u;
  obuf->flag = v5;
}

//----- (080604F8) --------------------------------------------------------
void __cdecl push_render_image(Str str, int width, int limit, html_feed_environ *h_env)
{
  int indent; // [esp+28h] [ebp-10h]
  readbuffer *obuf; // [esp+2Ch] [ebp-Ch]

  obuf = h_env->obuf;
  indent = h_env->envs[h_env->envc].indent;
  push_spaces(h_env->obuf, 1, (limit - width) / 2);
  push_nchars(obuf, width, str->ptr, str->length, 0);
  push_spaces(obuf, 1, (limit - width + 1) / 2);
  if ( width > 0 )
    flushline(h_env, obuf, indent, 0, h_env->limit);
}

//----- (080605DF) --------------------------------------------------------
int __cdecl sloppy_parse_line(char **str)
{
  int result; // eax

  if ( **str == 60 )
  {
    while ( **str && **str != 62 )
      ++*str;
    if ( **str == 62 )
      ++*str;
    result = 1;
  }
  else
  {
    while ( **str && **str != 60 )
      ++*str;
    result = 0;
  }
  return result;
}

//----- (08060664) --------------------------------------------------------
void __cdecl passthrough(readbuffer *obuf, char *str, int back)
{
  link_stack *p; // [esp+28h] [ebp-20h]
  char *q; // [esp+2Ch] [ebp-1Ch] BYREF
  Str str_save; // [esp+30h] [ebp-18h]
  char *str_bak; // [esp+34h] [ebp-14h]
  Str tok; // [esp+38h] [ebp-10h]
  int cmd; // [esp+3Ch] [ebp-Ch]

  tok = Strnew();
  if ( back )
  {
    str_save = Strnew_charp(str);
    Strshrink(obuf->line, &obuf->line->ptr[obuf->line->length] - str);
    str = str_save->ptr;
  }
  while ( *str )
  {
    str_bak = str;
    if ( sloppy_parse_line(&str) )
    {
      q = str_bak;
      cmd = gethtmlcmd(&q);
      if ( back )
      {
        for ( p = link_stack_0; p; p = p->next )
        {
          if ( p->cmd == cmd )
          {
            link_stack_0 = p->next;
            break;
          }
        }
        back = 0;
      }
      else
      {
        Strcat_charp_n(tok, str_bak, str - str_bak);
        push_tag(obuf, tok->ptr, cmd);
        Strclear(tok);
      }
    }
    else
    {
      push_nchars(obuf, 0, str_bak, str - str_bak, obuf->prev_ctype);
    }
  }
}

//----- (080607D1) --------------------------------------------------------
void __cdecl fillline(readbuffer *obuf, int indent)
{
  int v2; // edx

  push_spaces(obuf, 1, indent - obuf->pos);
  v2 = obuf->flag;
  BYTE1(v2) &= 0x7Fu;
  obuf->flag = v2;
}

//----- (08060812) --------------------------------------------------------
void __cdecl flushline(html_feed_environ *h_env, readbuffer *obuf, int indent, int force, int width)
{
  Str v5; // eax
  int v6; // edx
  Str v7; // eax
  size_t v8; // ebx
  Str v9; // eax
  Str v10; // eax
  int v11; // edx
  int v12; // edx
  char *v13; // eax
  char *v14; // eax
  char *v15; // eax
  char *v16; // eax
  int v17; // eax
  char *v18; // eax
  readbuffer o; // [esp+20h] [ebp-1F8h] BYREF
  html_feed_environ h; // [esp+170h] [ebp-A8h] BYREF
  environment e[1]; // [esp+1A0h] [ebp-78h] BYREF
  Str tmp_1; // [esp+1B0h] [ebp-68h]
  char *c; // [esp+1B4h] [ebp-64h]
  Str tmp_0; // [esp+1B8h] [ebp-60h]
  int i_0; // [esp+1BCh] [ebp-5Ch]
  Str tmp2; // [esp+1C0h] [ebp-58h]
  Str tmp; // [esp+1C4h] [ebp-54h]
  char *q; // [esp+1C8h] [ebp-50h]
  char *p; // [esp+1CCh] [ebp-4Ch] BYREF
  TextLine *lbuf; // [esp+1D0h] [ebp-48h]
  int i; // [esp+1D4h] [ebp-44h]
  char *ep; // [esp+1D8h] [ebp-40h]
  char *tp; // [esp+1DCh] [ebp-3Ch]
  char *hidden; // [esp+1E0h] [ebp-38h]
  char *hidden_ins; // [esp+1E4h] [ebp-34h]
  char *hidden_strike; // [esp+1E8h] [ebp-30h]
  char *hidden_italic; // [esp+1ECh] [ebp-2Ch]
  char *hidden_under; // [esp+1F0h] [ebp-28h]
  char *hidden_bold; // [esp+1F4h] [ebp-24h]
  char *hidden_img; // [esp+1F8h] [ebp-20h]
  char *hidden_anchor; // [esp+1FCh] [ebp-1Ch]
  Str pass; // [esp+200h] [ebp-18h]
  Str line; // [esp+204h] [ebp-14h]
  FILE *f; // [esp+208h] [ebp-10h]
  TextLineList *buf; // [esp+20Ch] [ebp-Ch]

  buf = h_env->buf;
  f = h_env->f;
  line = obuf->line;
  pass = 0;
  hidden_anchor = 0;
  hidden_img = 0;
  hidden_bold = 0;
  hidden_under = 0;
  hidden_italic = 0;
  hidden_strike = 0;
  hidden_ins = 0;
  hidden = 0;
  if ( (obuf->flag & 0x20F) == 0 && line->length > 0 && line->ptr[line->length - 1] == 32 )
  {
    Strshrink(line, 1);
    --obuf->pos;
  }
  append_tags(obuf);
  if ( obuf->anchor.url )
  {
    hidden_anchor = has_hidden_link(obuf, 1);
    hidden = hidden_anchor;
  }
  if ( obuf->img_alt )
  {
    hidden_img = has_hidden_link(obuf, 136);
    if ( hidden_img )
    {
      if ( !hidden || hidden_img < hidden )
        hidden = hidden_img;
    }
  }
  if ( obuf->fontstat[0] )
  {
    hidden_bold = has_hidden_link(obuf, 7);
    if ( hidden_bold )
    {
      if ( !hidden || hidden_bold < hidden )
        hidden = hidden_bold;
    }
  }
  if ( obuf->fontstat[2] )
  {
    hidden_italic = has_hidden_link(obuf, 109);
    if ( hidden_italic )
    {
      if ( !hidden || hidden_italic < hidden )
        hidden = hidden_italic;
    }
  }
  if ( obuf->fontstat[1] )
  {
    hidden_under = has_hidden_link(obuf, 65);
    if ( hidden_under )
    {
      if ( !hidden || hidden_under < hidden )
        hidden = hidden_under;
    }
  }
  if ( obuf->fontstat[3] )
  {
    hidden_strike = has_hidden_link(obuf, 105);
    if ( hidden_strike )
    {
      if ( !hidden || hidden_strike < hidden )
        hidden = hidden_strike;
    }
  }
  if ( obuf->fontstat[4] )
  {
    hidden_ins = has_hidden_link(obuf, 63);
    if ( hidden_ins )
    {
      if ( !hidden || hidden_ins < hidden )
        hidden = hidden_ins;
    }
  }
  if ( hidden )
  {
    pass = Strnew_charp(hidden);
    Strshrink(line, &line->ptr[line->length] - hidden);
  }
  if ( (obuf->flag & 0x20F) == 0 && obuf->pos > width )
  {
    tp = &line->ptr[obuf->bp.len - obuf->bp.tlen];
    ep = &line->ptr[line->length];
    if ( obuf->bp.pos == obuf->pos && tp <= ep && line->ptr < tp && *(tp - 1) == 32 )
    {
      bcopy(tp, tp - 1, ep - tp + 1);
      --line->length;
      --obuf->pos;
    }
  }
  if ( obuf->anchor.url && !hidden_anchor )
    Strcat_charp(line, "</a>");
  if ( obuf->img_alt && !hidden_img )
    Strcat_charp(line, "</img_alt>");
  if ( obuf->fontstat[0] && !hidden_bold )
    Strcat_charp(line, "</b>");
  if ( obuf->fontstat[2] && !hidden_italic )
    Strcat_charp(line, "</i>");
  if ( obuf->fontstat[1] && !hidden_under )
    Strcat_charp(line, "</u>");
  if ( obuf->fontstat[3] && !hidden_strike )
    Strcat_charp(line, "</s>");
  if ( obuf->fontstat[4] && !hidden_ins )
    Strcat_charp(line, "</ins>");
  if ( obuf->top_margin > 0 )
  {
    init_henv(&h, &o, e, 1, 0, width, indent);
    o.line = Strnew_size(width + 20);
    o.pos = obuf->pos;
    o.flag = obuf->flag;
    o.top_margin = -1;
    o.bottom_margin = -1;
    Strcat_charp(o.line, "<pre_int>");
    for ( i = 0; o.pos > i; ++i )
    {
      if ( o.line->length + 1 >= o.line->area_size )
        Strgrow(o.line);
      v5 = o.line;
      v6 = o.line->length;
      o.line->ptr[v6] = 32;
      v5->length = v6 + 1;
      o.line->ptr[o.line->length] = 0;
    }
    Strcat_charp(o.line, "</pre_int>");
    for ( i = 0; obuf->top_margin > i; ++i )
      flushline(h_env, &o, indent, force, width);
  }
  if ( force == 1 || (obuf->flag & 0x8000) != 0 )
  {
    lbuf = newTextLine(line, obuf->pos);
    if ( (obuf->flag & 0x70) == 32 )
    {
      align(lbuf, width, 0);
    }
    else if ( (obuf->flag & 0x70) == 64 )
    {
      align(lbuf, width, 2);
    }
    else if ( (obuf->flag & 0x70) == 16 && (obuf->flag & 0x20000) != 0 )
    {
      align(lbuf, width, 1);
    }
    if ( lbuf->pos > h_env->maxlimit )
      h_env->maxlimit = lbuf->pos;
    if ( buf )
    {
      pushValue((GeneralList *)buf, lbuf);
    }
    else if ( f )
    {
      if ( ExtHalfdump )
        v7 = wc_Str_conv(lbuf->line, InnerCharset, DisplayCharset);
      else
        v7 = lbuf->line;
      v8 = v7->length;
      if ( ExtHalfdump )
        v9 = wc_Str_conv(lbuf->line, InnerCharset, DisplayCharset);
      else
        v9 = lbuf->line;
      fwrite(v9->ptr, 1u, v8, f);
      fputc(10, f);
    }
    if ( (obuf->flag & 0x28F) != 0 || (obuf->flag & 0x8000) != 0 )
      h_env->blank_lines = 0;
    else
      ++h_env->blank_lines;
  }
  else
  {
    p = line->ptr;
    tmp = Strnew();
    tmp2 = Strnew();
    while ( *p )
    {
      q = p;
      if ( sloppy_parse_line(&p) )
      {
        Strcat_charp_n(tmp, q, p - q);
        if ( force == 2 )
        {
          if ( buf )
          {
            appendTextLine(buf, tmp, 0);
          }
          else if ( f )
          {
            fwrite(tmp->ptr, 1u, tmp->length, f);
          }
        }
        else
        {
          savexmlstr_0(tmp2, tmp);
        }
        Strclear(tmp);
      }
    }
    if ( force == 2 )
    {
      if ( pass )
      {
        if ( buf )
        {
          appendTextLine(buf, pass, 0);
        }
        else if ( f )
        {
          fwrite(pass->ptr, 1u, pass->length, f);
        }
      }
      pass = 0;
    }
    else
    {
      if ( pass )
        savexmlstr_0(tmp2, pass);
      pass = tmp2;
    }
  }
  if ( obuf->bottom_margin > 0 )
  {
    init_henv(&h, &o, e, 1, 0, width, indent);
    o.line = Strnew_size(width + 20);
    o.pos = obuf->pos;
    o.flag = obuf->flag;
    o.top_margin = -1;
    o.bottom_margin = -1;
    Strcat_charp(o.line, "<pre_int>");
    for ( i_0 = 0; o.pos > i_0; ++i_0 )
    {
      if ( o.line->length + 1 >= o.line->area_size )
        Strgrow(o.line);
      v10 = o.line;
      v11 = o.line->length;
      o.line->ptr[v11] = 32;
      v10->length = v11 + 1;
      o.line->ptr[o.line->length] = 0;
    }
    Strcat_charp(o.line, "</pre_int>");
    for ( i_0 = 0; obuf->bottom_margin > i_0; ++i_0 )
      flushline(h_env, &o, indent, force, width);
  }
  if ( obuf->top_margin >= 0 && obuf->bottom_margin >= 0 )
  {
    obuf->line = Strnew_size(256);
    obuf->pos = 0;
    obuf->top_margin = 0;
    obuf->bottom_margin = 0;
    Strcopy_charp_n(obuf->prevchar, " ", 1);
    obuf->bp.init_flag = 1;
    v12 = obuf->flag;
    BYTE1(v12) &= 0x7Fu;
    obuf->flag = v12;
    set_breakpoint(obuf, 0);
    obuf->prev_ctype = 0;
    link_stack_0 = 0;
    fillline(obuf, indent);
    if ( pass )
      passthrough(obuf, pass->ptr, 0);
    if ( !hidden_anchor && obuf->anchor.url )
    {
      if ( obuf->anchor.hseq > 0 )
        obuf->anchor.hseq = -obuf->anchor.hseq;
      tmp_0 = Sprintf("<A HSEQ=\"%d\" HREF=\"", obuf->anchor.hseq);
      v13 = html_quote(obuf->anchor.url);
      Strcat_charp(tmp_0, v13);
      if ( obuf->anchor.target )
      {
        Strcat_charp(tmp_0, "\" TARGET=\"");
        v14 = html_quote(obuf->anchor.target);
        Strcat_charp(tmp_0, v14);
      }
      if ( obuf->anchor.referer )
      {
        Strcat_charp(tmp_0, "\" REFERER=\"");
        v15 = html_quote(obuf->anchor.referer);
        Strcat_charp(tmp_0, v15);
      }
      if ( obuf->anchor.title )
      {
        Strcat_charp(tmp_0, "\" TITLE=\"");
        v16 = html_quote(obuf->anchor.title);
        Strcat_charp(tmp_0, v16);
      }
      if ( obuf->anchor.accesskey )
      {
        c = HTML_QUOTE_MAP[QUOTE_MAP[obuf->anchor.accesskey] & 7];
        Strcat_charp(tmp_0, "\" ACCESSKEY=\"");
        if ( c )
        {
          Strcat_charp(tmp_0, c);
        }
        else
        {
          if ( tmp_0->length + 1 >= tmp_0->area_size )
            Strgrow(tmp_0);
          v17 = tmp_0->length;
          tmp_0->ptr[v17] = obuf->anchor.accesskey;
          tmp_0->length = v17 + 1;
          tmp_0->ptr[tmp_0->length] = 0;
        }
      }
      Strcat_charp(tmp_0, "\">");
      push_tag(obuf, tmp_0->ptr, 1);
    }
    if ( !hidden_img && obuf->img_alt )
    {
      tmp_1 = Strnew_charp("<IMG_ALT SRC=\"");
      v18 = html_quote(obuf->img_alt->ptr);
      Strcat_charp(tmp_1, v18);
      Strcat_charp(tmp_1, "\">");
      push_tag(obuf, tmp_1->ptr, 136);
    }
    if ( !hidden_bold && obuf->fontstat[0] )
      push_tag(obuf, "<B>", 7);
    if ( !hidden_italic && obuf->fontstat[2] )
      push_tag(obuf, "<I>", 109);
    if ( !hidden_under && obuf->fontstat[1] )
      push_tag(obuf, "<U>", 65);
    if ( !hidden_strike && obuf->fontstat[3] )
      push_tag(obuf, "<S>", 105);
    if ( !hidden_ins )
    {
      if ( obuf->fontstat[4] )
        push_tag(obuf, "<INS>", 63);
    }
  }
}

//----- (08061711) --------------------------------------------------------
void __cdecl do_blankline(html_feed_environ *h_env, readbuffer *obuf, int indent, int indent_incr, int width)
{
  if ( !h_env->blank_lines )
    flushline(h_env, obuf, indent, 1, width);
}

//----- (0806174B) --------------------------------------------------------
void __cdecl purgeline(html_feed_environ *h_env)
{
  _Str *tmp; // [esp+14h] [ebp-14h]
  char *q; // [esp+18h] [ebp-10h]
  char *p; // [esp+1Ch] [ebp-Ch] BYREF

  if ( h_env->buf && h_env->blank_lines )
  {
    p = **(char ***)rpopValue((GeneralList *)h_env->buf);
    tmp = Strnew();
    while ( *p )
    {
      q = p;
      if ( sloppy_parse_line(&p) )
        Strcat_charp_n(tmp, q, p - q);
    }
    appendTextLine(h_env->buf, tmp, 0);
    --h_env->blank_lines;
  }
}

//----- (08061803) --------------------------------------------------------
int __cdecl close_effect0(readbuffer *obuf, int cmd)
{
  int result; // eax
  char *p; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]

  for ( i = obuf->tag_sp - 1; i >= 0 && obuf->tag_stack[i]->cmd != cmd; --i )
    ;
  if ( i < 0 )
  {
    p = has_hidden_link(obuf, cmd);
    if ( p )
    {
      passthrough(obuf, p, 1);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    bcopy(&obuf->tag_stack[i + 1], &obuf->tag_stack[i], 4 * (--obuf->tag_sp - i));
    result = 1;
  }
  return result;
}

//----- (080618EE) --------------------------------------------------------
void __cdecl close_anchor(html_feed_environ *h_env, readbuffer *obuf)
{
  Str v2; // eax
  int v3; // edx
  int is_erased; // [esp+14h] [ebp-14h]
  char *p; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]

  if ( obuf->anchor.url )
  {
    p = 0;
    is_erased = 0;
    for ( i = obuf->tag_sp - 1; i >= 0 && obuf->tag_stack[i]->cmd != 1; --i )
      ;
    if ( i < 0 && obuf->anchor.hseq > 0 && obuf->line->length > 0 && obuf->line->ptr[obuf->line->length - 1] == 32 )
    {
      Strshrink(obuf->line, 1);
      --obuf->pos;
      is_erased = 1;
    }
    if ( i >= 0 || (p = has_hidden_link(obuf, 1)) != 0 )
    {
      if ( obuf->anchor.hseq <= 0 )
      {
        if ( i < 0 )
          passthrough(obuf, p, 1);
        else
          bcopy(&obuf->tag_stack[i + 1], &obuf->tag_stack[i], 4 * (--obuf->tag_sp - i));
        goto LABEL_23;
      }
      HTMLlineproc0((char *)&byte_80C9BE3, h_env, 1);
      Strcopy_charp_n(obuf->prevchar, " ", 1);
      is_erased = 0;
    }
    if ( is_erased )
    {
      if ( obuf->line->length + 1 >= obuf->line->area_size )
        Strgrow(obuf->line);
      v2 = obuf->line;
      v3 = obuf->line->length;
      obuf->line->ptr[v3] = 32;
      v2->length = v3 + 1;
      obuf->line->ptr[obuf->line->length] = 0;
      ++obuf->pos;
    }
    push_tag(obuf, "</a>", 2);
  }
LABEL_23:
  bzero(&obuf->anchor, 0x3Cu);
}

//----- (08061B5C) --------------------------------------------------------
void __cdecl save_fonteffect(html_feed_environ *h_env, readbuffer *obuf)
{
  if ( obuf->fontstat_sp <= 4 )
    bcopy(obuf->fontstat, obuf->fontstat_stack[obuf->fontstat_sp], 7u);
  ++obuf->fontstat_sp;
  if ( obuf->fontstat[0] )
    push_tag(obuf, "</b>", 8);
  if ( obuf->fontstat[2] )
    push_tag(obuf, "</i>", 110);
  if ( obuf->fontstat[1] )
    push_tag(obuf, "</u>", 66);
  if ( obuf->fontstat[3] )
    push_tag(obuf, "</s>", 106);
  if ( obuf->fontstat[4] )
    push_tag(obuf, "</ins>", 64);
  bzero(obuf->fontstat, 7u);
}

//----- (08061CA6) --------------------------------------------------------
void __cdecl restore_fonteffect(html_feed_environ *h_env, readbuffer *obuf)
{
  if ( obuf->fontstat_sp > 0 )
    --obuf->fontstat_sp;
  if ( obuf->fontstat_sp <= 4 )
    bcopy(obuf->fontstat_stack[obuf->fontstat_sp], obuf->fontstat, 7u);
  if ( obuf->fontstat[0] )
    push_tag(obuf, "<b>", 7);
  if ( obuf->fontstat[2] )
    push_tag(obuf, "<i>", 109);
  if ( obuf->fontstat[1] )
    push_tag(obuf, "<u>", 65);
  if ( obuf->fontstat[3] )
    push_tag(obuf, "<s>", 105);
  if ( obuf->fontstat[4] )
    push_tag(obuf, "<ins>", 63);
}

//----- (08061DEB) --------------------------------------------------------
Str __cdecl process_title(parsed_tag *tag)
{
  cur_title = Strnew();
  return 0;
}

//----- (08061E02) --------------------------------------------------------
Str __cdecl process_n_title(parsed_tag *tag)
{
  Str result; // eax
  char *v2; // eax

  if ( !cur_title )
    return 0;
  Strremovefirstspaces(cur_title);
  Strremovetrailingspaces(cur_title);
  v2 = html_quote(cur_title->ptr);
  result = Strnew_m_charp("<title_alt title=\"", v2, "\">", 0);
  cur_title = 0;
  return result;
}

//----- (08061E73) --------------------------------------------------------
void __cdecl feed_title(char *str)
{
  char *v1; // eax
  Str v2; // eax
  int v3; // edx
  Str v4; // eax
  int v5; // ecx
  char *v6; // edx

  if ( cur_title )
  {
    while ( *str )
    {
      if ( *str == 38 )
      {
        v1 = getescapecmd(&str);
        Strcat_charp(cur_title, v1);
      }
      else if ( *str == 10 || *str == 13 )
      {
        if ( cur_title->length + 1 >= cur_title->area_size )
          Strgrow(cur_title);
        v2 = cur_title;
        v3 = cur_title->length;
        cur_title->ptr[v3] = 32;
        v2->length = v3 + 1;
        cur_title->ptr[cur_title->length] = 0;
        ++str;
      }
      else
      {
        if ( cur_title->length + 1 >= cur_title->area_size )
          Strgrow(cur_title);
        v4 = cur_title;
        v5 = cur_title->length;
        v6 = str;
        cur_title->ptr[v5] = *str;
        v4->length = v5 + 1;
        str = v6 + 1;
        cur_title->ptr[cur_title->length] = 0;
      }
    }
  }
}

//----- (08061FA7) --------------------------------------------------------
Str __cdecl process_img(parsed_tag *tag, int width)
{
  int v2; // eax
  parsed_tag *v4; // eax
  int v5; // eax
  _Str *v6; // eax
  char *v7; // eax
  char *v8; // eax
  int v9; // eax
  int v10; // ecx
  _Str *v11; // eax
  ParsedURL *v12; // ebx
  wc_ces v13; // edi
  wc_ces v14; // esi
  _Str *v15; // eax
  Str v16; // eax
  int v17; // eax
  int v18; // eax
  int v19; // edx
  _Str *v20; // eax
  int v21; // eax
  char *v22; // eax
  char *v23; // eax
  _Str *v24; // eax
  _Str *v25; // eax
  long double v26; // fst7
  _Str *v27; // eax
  _Str *v28; // eax
  _Str *v29; // eax
  _Str *v30; // eax
  char *v31; // eax
  char *v32; // eax
  int v33; // eax
  int v34; // eax
  Str v35; // eax
  char *v36; // eax
  char *v37; // eax
  int v38; // eax
  int v39; // eax
  int v40; // eax
  int v41; // eax
  ParsedURL u; // [esp+20h] [ebp-C8h] BYREF
  Image image; // [esp+48h] [ebp-A0h] BYREF
  char *r_0; // [esp+6Ch] [ebp-7Ch]
  Str tmp2; // [esp+70h] [ebp-78h]
  Str tmp; // [esp+74h] [ebp-74h]
  int ext_pre_int; // [esp+78h] [ebp-70h]
  int pre_int; // [esp+7Ch] [ebp-6Ch]
  int use_image; // [esp+80h] [ebp-68h]
  int ismap; // [esp+84h] [ebp-64h]
  int bottom; // [esp+88h] [ebp-60h]
  int top; // [esp+8Ch] [ebp-5Ch]
  int yoffset; // [esp+90h] [ebp-58h]
  int xoffset; // [esp+94h] [ebp-54h]
  int align; // [esp+98h] [ebp-50h] BYREF
  int i0; // [esp+9Ch] [ebp-4Ch]
  int w0; // [esp+A0h] [ebp-48h]
  int n; // [esp+A4h] [ebp-44h]
  int ni; // [esp+A8h] [ebp-40h]
  int nw; // [esp+ACh] [ebp-3Ch]
  int i; // [esp+B0h] [ebp-38h] BYREF
  int w; // [esp+B4h] [ebp-34h] BYREF
  char *t; // [esp+B8h] [ebp-30h] BYREF
  char *s; // [esp+BCh] [ebp-2Ch] BYREF
  char *r2; // [esp+C0h] [ebp-28h]
  char *r; // [esp+C4h] [ebp-24h] BYREF
  char *q; // [esp+C8h] [ebp-20h] BYREF
  char *p; // [esp+CCh] [ebp-1Ch] BYREF

  r2 = 0;
  ni = 1;
  w0 = -1;
  i0 = -1;
  ismap = 0;
  v2 = activeImage && displayImage;
  use_image = v2;
  pre_int = 0;
  ext_pre_int = 0;
  tmp = Strnew();
  if ( !parsedtag_get_value(tag, 31, &p) )
    return tmp;
  p = remove_space(p);
  q = 0;
  parsedtag_get_value(tag, 5, &q);
  t = q;
  parsedtag_get_value(tag, 49, &t);
  w = -1;
  if ( parsedtag_get_value(tag, 38, &w) )
  {
    if ( w < 0 )
    {
      if ( width <= 0 )
        w = -1;
      else
        w = (int)((long double)-width * pixel_per_char * (long double)w / 100.0 + 0.5);
    }
    if ( use_image && w > 0 )
    {
      w = (int)((long double)w * image_scale / 100.0 + 0.5);
      if ( w )
      {
        if ( w > 2048 )
          w = 2048;
      }
      else
      {
        w = 1;
      }
    }
  }
  if ( use_image )
  {
    i = -1;
    if ( parsedtag_get_value(tag, 17, &i) )
    {
      if ( i <= 0 )
      {
        i = -1;
      }
      else
      {
        i = (int)((long double)i * image_scale / 100.0 + 0.5);
        if ( i )
        {
          if ( i > 2048 )
            i = 2048;
        }
        else
        {
          i = 1;
        }
      }
    }
    align = -1;
    parsedtag_get_value(tag, 4, &align);
    ismap = 0;
    if ( tag->map && tag->map[46] != 75 && tag->attrid[tag->map[46]] )
      ismap = 1;
  }
  else
  {
    parsedtag_get_value(tag, 17, &i);
  }
  r = 0;
  parsedtag_get_value(tag, 34, &r);
  if ( tag->map && tag->map[74] != 75 && tag->attrid[tag->map[74]] )
    ext_pre_int = 1;
  tmp = Strnew_size(128);
  if ( use_image )
  {
    switch ( align )
    {
      case 1:
        Strcat_charp(tmp, "<div_int align=left>");
        break;
      case 2:
        Strcat_charp(tmp, "<div_int align=right>");
        break;
      case 0:
        Strcat_charp(tmp, "<div_int align=center>");
        break;
    }
  }
  if ( r )
  {
    r2 = strchr(r, 35);
    s = "<form_int method=internal action=map>";
    v4 = parse_tag(&s, 1);
    tmp2 = process_form(v4);
    if ( tmp2 )
      savexmlstr_0(tmp, tmp2);
    if ( form_sp < 0 )
      v5 = -1;
    else
      v5 = form_stack[form_sp];
    v6 = Sprintf("<input_alt fid=\"%d\" type=hidden name=link value=\"", v5);
    savexmlstr_0(tmp, v6);
    if ( r2 )
      v7 = r2 + 1;
    else
      v7 = r;
    v8 = html_quote(v7);
    Strcat_charp(tmp, v8);
    if ( form_sp < 0 )
      v9 = -1;
    else
      v9 = form_stack[form_sp];
    v10 = cur_hseq++;
    v11 = Sprintf("\"><input_alt hseq=\"%d\" fid=\"%d\" type=submit no_effect=true>", v10, v9);
    savexmlstr_0(tmp, v11);
  }
  if ( use_image )
  {
    w0 = w;
    i0 = i;
    if ( w < 0 || i < 0 )
    {
      v12 = cur_baseURL;
      v13 = cur_document_charset[0];
      v14 = InnerCharset;
      v15 = Strnew_charp(p);
      v16 = wc_Str_conv(v15, v14, v13);
      parseURL2(v16->ptr, &u, v12);
      image.url = parsedURL2Str(&u)->ptr;
      if ( !uncompressed_file_type(u.file, &image.ext) )
        image.ext = filename_extension(u.file, 1);
      image.cache = 0;
      image.width = w;
      image.height = i;
      image.cache = getImage(&image, cur_baseURL, 1);
      if ( image.cache && image.cache->width > 0 && image.cache->height > 0 )
      {
        w0 = image.cache->width;
        w = w0;
        i0 = image.cache->height;
        i = i0;
      }
      if ( w < 0 )
        w = (int)(pixel_per_char * 8.0);
      if ( i < 0 )
        i = (int)pixel_per_line;
    }
    if ( w <= 3 )
      v17 = 1;
    else
      v17 = (int)((long double)(w - 3) / pixel_per_char + 1.0);
    nw = v17;
    if ( i <= 3 )
      v18 = 1;
    else
      v18 = (int)((long double)(i - 3) / pixel_per_line + 1.0);
    ni = v18;
    v19 = cur_iseq++;
    v20 = Sprintf("<pre_int><img_alt hseq=\"%d\" src=\"", v19);
    savexmlstr_0(tmp, v20);
    pre_int = 1;
  }
  else
  {
    if ( w < 0 )
      w = (int)(pixel_per_char * 12.0);
    if ( w )
      v21 = (int)((long double)(w - 1) / pixel_per_char + 1.0);
    else
      v21 = 1;
    nw = v21;
    if ( r )
    {
      Strcat_charp(tmp, "<pre_int>");
      pre_int = 1;
    }
    Strcat_charp(tmp, "<img_alt src=\"");
  }
  v22 = html_quote(p);
  Strcat_charp(tmp, v22);
  Strcat_charp(tmp, "\"");
  if ( t )
  {
    Strcat_charp(tmp, " title=\"");
    v23 = html_quote(t);
    Strcat_charp(tmp, v23);
    Strcat_charp(tmp, "\"");
  }
  if ( use_image )
  {
    if ( w0 >= 0 )
    {
      v24 = Sprintf(" width=%d", w0);
      savexmlstr_0(tmp, v24);
    }
    if ( i0 >= 0 )
    {
      v25 = Sprintf(" height=%d", i0);
      savexmlstr_0(tmp, v25);
    }
    switch ( align )
    {
      case 5:
        top = 0;
        bottom = ni - 1;
        yoffset = 0;
        break;
      case 6:
        top = ni - 1;
        bottom = 0;
        yoffset = (int)((long double)ni * pixel_per_line - (long double)i);
        break;
      case 4:
        top = ni / 2;
        bottom = ni / 2;
        if ( 2 * (ni / 2) == ni )
          v26 = ((long double)(ni + 1) * pixel_per_line - (long double)i) / 2.0;
        else
          v26 = ((long double)ni * pixel_per_line - (long double)i) / 2.0;
        yoffset = (int)v26;
        break;
      default:
        top = ni - 1;
        bottom = 0;
        if ( ni == 1 && (long double)1 * pixel_per_line > (long double)i )
        {
          yoffset = 0;
        }
        else
        {
          yoffset = (int)((long double)ni * pixel_per_line - (long double)i);
          if ( yoffset < -1 )
            ++yoffset;
        }
        break;
    }
    xoffset = (int)(((long double)nw * pixel_per_char - (long double)w) / 2.0);
    if ( xoffset )
    {
      v27 = Sprintf(" xoffset=%d", xoffset);
      savexmlstr_0(tmp, v27);
    }
    if ( yoffset )
    {
      v28 = Sprintf(" yoffset=%d", yoffset);
      savexmlstr_0(tmp, v28);
    }
    if ( top )
    {
      v29 = Sprintf(" top_margin=%d", top);
      savexmlstr_0(tmp, v29);
    }
    if ( bottom )
    {
      v30 = Sprintf(" bottom_margin=%d", bottom);
      savexmlstr_0(tmp, v30);
    }
    if ( r )
    {
      Strcat_charp(tmp, " usemap=\"");
      if ( r2 )
        v31 = r2 + 1;
      else
        v31 = r;
      v32 = html_quote(v31);
      Strcat_charp(tmp, v32);
      Strcat_charp(tmp, "\"");
    }
    if ( ismap )
      Strcat_charp(tmp, " ismap");
  }
  Strcat_charp(tmp, ">");
  if ( q && !*q && ignore_null_img_alt )
    q = 0;
  if ( !q )
  {
    if ( w > 0 && i > 0 )
    {
      if ( w <= 31 && i <= 47 )
      {
        n = 1;
        if ( strcasestr(p, "space") || strcasestr(p, "blank") )
        {
          Strcat_charp(tmp, "_");
        }
        else if ( w * i > 127 )
        {
          if ( !pre_int )
          {
            Strcat_charp(tmp, "<pre_int>");
            pre_int = 1;
          }
          push_symbol(tmp, 44, symbol_width, 1);
          n = symbol_width;
        }
        else
        {
          Strcat_charp(tmp, "*");
        }
        goto img_end;
      }
      if ( w > 200 && i <= 12 )
      {
        if ( !pre_int )
        {
          Strcat_charp(tmp, "<pre_int>");
          pre_int = 1;
        }
        w = (int)((long double)w / pixel_per_char / (long double)symbol_width);
        if ( w <= 0 )
          w = 1;
        push_symbol(tmp, 26, symbol_width, w);
        n = w * symbol_width;
        goto img_end;
      }
    }
    for ( q = p; *q; ++q )
      ;
    while ( q > p && *q != 47 )
      --q;
    if ( *q == 47 )
      ++q;
    if ( tmp->length + 1 >= tmp->area_size )
      Strgrow(tmp);
    v38 = tmp->length;
    tmp->ptr[v38] = 91;
    tmp->length = v38 + 1;
    tmp->ptr[tmp->length] = 0;
    n = 1;
    p = q;
    while ( *q && ((MYCTYPE_MAP[(unsigned __int8)*q] & 0xC) != 0 || *q == 95 || *q == 45) )
    {
      if ( tmp->length + 1 >= tmp->area_size )
        Strgrow(tmp);
      v39 = tmp->length;
      tmp->ptr[v39] = *q;
      tmp->length = v39 + 1;
      tmp->ptr[tmp->length] = 0;
      if ( ++n + 1 >= nw )
        break;
      ++q;
    }
    if ( tmp->length + 1 >= tmp->area_size )
      Strgrow(tmp);
    v40 = tmp->length;
    tmp->ptr[v40] = 93;
    tmp->length = v40 + 1;
    tmp->ptr[tmp->length] = 0;
    ++n;
    goto img_end;
  }
  n = wtf_strwidth((wc_uchar *)q);
  if ( use_image && n > nw )
  {
    r_0 = q;
    for ( n = 0; r_0; n += v34 )
    {
      v33 = WcOption.use_wide ? WTF_WIDTH_MAP[(unsigned __int8)*r_0] : WTF_WIDTH_MAP[(unsigned __int8)*r_0] != 0;
      if ( n + v33 > nw )
        break;
      r_0 += WTF_LEN_MAP[(unsigned __int8)*r_0];
      if ( WcOption.use_wide )
        v34 = WTF_WIDTH_MAP[(unsigned __int8)*r_0];
      else
        v34 = WTF_WIDTH_MAP[(unsigned __int8)*r_0] != 0;
    }
    v35 = Strnew_charp_n(q, r_0 - q);
    v36 = html_quote(v35->ptr);
    Strcat_charp(tmp, v36);
  }
  else
  {
    v37 = html_quote(q);
    Strcat_charp(tmp, v37);
  }
img_end:
  if ( use_image )
  {
    while ( n < nw )
    {
      if ( tmp->length + 1 >= tmp->area_size )
        Strgrow(tmp);
      v41 = tmp->length;
      tmp->ptr[v41] = 32;
      tmp->length = v41 + 1;
      tmp->ptr[tmp->length] = 0;
      ++n;
    }
  }
  Strcat_charp(tmp, "</img_alt>");
  if ( pre_int && !ext_pre_int )
    Strcat_charp(tmp, "</pre_int>");
  if ( r )
  {
    Strcat_charp(tmp, "</input_alt>");
    process_n_form();
  }
  if ( use_image )
  {
    if ( (unsigned int)align <= 2 )
      Strcat_charp(tmp, "</div_int>");
  }
  return tmp;
}
// 804A36C: using guessed type int __cdecl strcasestr(_DWORD, _DWORD);

//----- (08063264) --------------------------------------------------------
Str __cdecl process_anchor(parsed_tag *tag, char *tagbuf)
{
  int v2; // edx
  Str result; // eax
  char *v4; // [esp+8h] [ebp-20h]
  _Str *tmp; // [esp+1Ch] [ebp-Ch]

  v2 = cur_hseq;
  if ( tag->need_reconstruct )
  {
    ++cur_hseq;
    v4 = Sprintf("%d", v2)->ptr;
    parsedtag_set_value(tag, 69, v4);
    result = parsedtag2str(tag);
  }
  else
  {
    ++cur_hseq;
    tmp = Sprintf("<a hseq=\"%d\"", v2);
    Strcat_charp(tmp, tagbuf + 2);
    result = tmp;
  }
  return result;
}

//----- (080632F6) --------------------------------------------------------
Str __cdecl process_input(parsed_tag *tag)
{
  parsed_tag *v1; // eax
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v6; // eax
  int v7; // eax
  int v8; // edi
  char *v9; // ecx
  int v10; // edx
  int v11; // ebx
  _Str *v12; // eax
  int v13; // eax
  int v14; // eax
  char *v15; // eax
  _Str *v16; // eax
  char *v17; // eax
  _Str *v18; // eax
  _Str *v19; // eax
  _Str *v20; // eax
  int v21; // eax
  int v22; // eax
  int v23; // ebx
  _Str *v24; // eax
  _Str *v25; // eax
  int v26; // eax
  char *v27; // eax
  int v28; // eax
  int v29; // eax
  int v30; // eax
  int v31; // eax
  int v32; // [esp+2Ch] [ebp-6Ch]
  char *s_0; // [esp+3Ch] [ebp-5Ch] BYREF
  int qlen; // [esp+40h] [ebp-58h]
  char *qq; // [esp+44h] [ebp-54h]
  Str tmp; // [esp+48h] [ebp-50h]
  char *s; // [esp+4Ch] [ebp-4Ch] BYREF
  char *p2; // [esp+50h] [ebp-48h] BYREF
  char *r; // [esp+54h] [ebp-44h] BYREF
  char *p; // [esp+58h] [ebp-40h] BYREF
  char *q; // [esp+5Ch] [ebp-3Ch] BYREF
  int ih; // [esp+60h] [ebp-38h] BYREF
  int iw; // [esp+64h] [ebp-34h] BYREF
  int z; // [esp+68h] [ebp-30h]
  int y; // [esp+6Ch] [ebp-2Ch]
  int x; // [esp+70h] [ebp-28h]
  int v; // [esp+74h] [ebp-24h]
  int w; // [esp+78h] [ebp-20h] BYREF
  int i[7]; // [esp+7Ch] [ebp-1Ch] BYREF

  tmp = 0;
  qq = (char *)&line;
  qlen = 0;
  if ( form_sp < 0 || form_stack[form_sp] < 0 )
  {
    s_0 = "<form_int method=internal action=none>";
    v1 = parse_tag(&s_0, 1);
    tmp = process_form(v1);
  }
  if ( !tmp )
    tmp = Strnew();
  p = "text";
  parsedtag_get_value(tag, 33, &p);
  q = 0;
  parsedtag_get_value(tag, 36, &q);
  r = (char *)&line;
  parsedtag_get_value(tag, 25, &r);
  w = 20;
  parsedtag_get_value(tag, 30, &w);
  i[0] = 20;
  parsedtag_get_value(tag, 22, i);
  p2 = 0;
  parsedtag_get_value(tag, 5, &p2);
  v2 = tag->map && tag->map[12] != 75 && tag->attrid[tag->map[12]];
  x = v2;
  v3 = tag->map && tag->map[1] != 75 && tag->attrid[tag->map[1]];
  y = v3;
  v4 = tag->map && tag->map[43] != 75 && tag->attrid[tag->map[43]];
  z = v4;
  v = formtype(p);
  if ( v == -1 )
    return 0;
  if ( !q )
  {
    switch ( v )
    {
      case 2:
        q = "on";
        break;
      case 4:
      case 7:
      case 10:
        q = "SUBMIT";
        break;
      case 5:
        q = "RESET";
        break;
      default:
        break;
    }
  }
  if ( v == 11 )
    q = 0;
  if ( q )
  {
    qq = html_quote(q);
    qlen = wtf_strwidth((wc_uchar *)q);
  }
  Strcat_charp(tmp, "<pre_int>");
  if ( v == 3 )
  {
    if ( tmp->length + 1 >= tmp->area_size )
      Strgrow(tmp);
    v7 = tmp->length;
    tmp->ptr[v7] = 40;
    tmp->length = v7 + 1;
    tmp->ptr[tmp->length] = 0;
    goto LABEL_43;
  }
  if ( v > 3 )
  {
    if ( v == 11 )
    {
LABEL_37:
      if ( tmp->length + 1 >= tmp->area_size )
        Strgrow(tmp);
      v6 = tmp->length;
      tmp->ptr[v6] = 91;
      tmp->length = v6 + 1;
      tmp->ptr[tmp->length] = 0;
      goto LABEL_43;
    }
  }
  else if ( v >= 0 )
  {
    goto LABEL_37;
  }
LABEL_43:
  v32 = i[0];
  v8 = w;
  v9 = html_quote(r);
  if ( form_sp < 0 )
    v10 = -1;
  else
    v10 = form_stack[form_sp];
  v11 = cur_hseq++;
  v12 = Sprintf(
          "<input_alt hseq=\"%d\" fid=\"%d\" type=%s name=\"%s\" width=%d maxlength=%d value=\"%s\"",
          v11,
          v10,
          p,
          v9,
          v8,
          v32,
          qq);
  savexmlstr_0(tmp, v12);
  if ( x )
    Strcat_charp(tmp, " checked");
  if ( y )
    Strcat_charp(tmp, " accept");
  if ( z )
    Strcat_charp(tmp, " readonly");
  if ( tmp->length + 1 >= tmp->area_size )
    Strgrow(tmp);
  v13 = tmp->length;
  tmp->ptr[v13] = 62;
  tmp->length = v13 + 1;
  tmp->ptr[tmp->length] = 0;
  if ( v == 6 )
  {
    Strcat_charp(tmp, "</input_alt></pre_int>");
    return tmp;
  }
  if ( (unsigned int)v > 0xB )
    goto LABEL_71;
  v14 = 1 << v;
  if ( ((1 << v) & 0x430) != 0 )
    goto LABEL_70;
  if ( (v14 & 0x803) != 0 )
  {
    Strcat_charp(tmp, "<u>");
    goto LABEL_71;
  }
  if ( (v14 & 0x80) == 0 )
  {
LABEL_71:
    switch ( v )
    {
      case 0:
      case 11:
        if ( q )
        {
          v23 = w;
          v24 = Strnew_charp(q);
          v25 = textfieldrep(v24, v23);
          savexmlstr_0(tmp, v25);
        }
        else
        {
          for ( i[0] = 0; i[0] < w; ++i[0] )
          {
            if ( tmp->length + 1 >= tmp->area_size )
              Strgrow(tmp);
            v26 = tmp->length;
            tmp->ptr[v26] = 32;
            tmp->length = v26 + 1;
            tmp->ptr[tmp->length] = 0;
          }
        }
        break;
      case 1:
        i[0] = 0;
        if ( q )
        {
          while ( i[0] < qlen && i[0] < w )
          {
            if ( tmp->length + 1 >= tmp->area_size )
              Strgrow(tmp);
            v21 = tmp->length;
            tmp->ptr[v21] = 42;
            tmp->length = v21 + 1;
            tmp->ptr[tmp->length] = 0;
            ++i[0];
          }
        }
        while ( i[0] < w )
        {
          if ( tmp->length + 1 >= tmp->area_size )
            Strgrow(tmp);
          v22 = tmp->length;
          tmp->ptr[v22] = 32;
          tmp->length = v22 + 1;
          tmp->ptr[tmp->length] = 0;
          ++i[0];
        }
        break;
      case 2:
      case 3:
        if ( x )
        {
          if ( tmp->length + 1 >= tmp->area_size )
            Strgrow(tmp);
          v28 = tmp->length;
          tmp->ptr[v28] = 42;
          tmp->length = v28 + 1;
          tmp->ptr[tmp->length] = 0;
        }
        else
        {
          if ( tmp->length + 1 >= tmp->area_size )
            Strgrow(tmp);
          v29 = tmp->length;
          tmp->ptr[v29] = 32;
          tmp->length = v29 + 1;
          tmp->ptr[tmp->length] = 0;
        }
        break;
      case 4:
      case 10:
        if ( !p2 )
          goto LABEL_95;
        v27 = html_quote(p2);
        Strcat_charp(tmp, v27);
        break;
      case 5:
LABEL_95:
        Strcat_charp(tmp, qq);
        break;
      default:
        break;
    }
    if ( (unsigned int)v <= 0xB )
    {
      if ( ((1 << v) & 0x4B0) != 0 )
      {
        Strcat_charp(tmp, "]");
      }
      else if ( ((1 << v) & 0x803) != 0 )
      {
        Strcat_charp(tmp, "</u>");
      }
    }
    Strcat_charp(tmp, "</input_alt>");
    if ( v == 3 )
    {
      if ( tmp->length + 1 >= tmp->area_size )
        Strgrow(tmp);
      v31 = tmp->length;
      tmp->ptr[v31] = 41;
      tmp->length = v31 + 1;
      tmp->ptr[tmp->length] = 0;
      goto LABEL_119;
    }
    if ( v > 3 )
    {
      if ( v == 11 )
      {
LABEL_113:
        if ( tmp->length + 1 >= tmp->area_size )
          Strgrow(tmp);
        v30 = tmp->length;
        tmp->ptr[v30] = 93;
        tmp->length = v30 + 1;
        tmp->ptr[tmp->length] = 0;
        goto LABEL_119;
      }
    }
    else if ( v >= 0 )
    {
      goto LABEL_113;
    }
LABEL_119:
    Strcat_charp(tmp, "</pre_int>");
    return tmp;
  }
  s = 0;
  parsedtag_get_value(tag, 31, &s);
  if ( !s )
  {
LABEL_70:
    Strcat_charp(tmp, "[");
    goto LABEL_71;
  }
  v15 = html_quote(s);
  v16 = Sprintf("<img src=\"%s\"", v15);
  savexmlstr_0(tmp, v16);
  if ( p2 )
  {
    v17 = html_quote(p2);
    v18 = Sprintf(" alt=\"%s\"", v17);
    savexmlstr_0(tmp, v18);
  }
  if ( parsedtag_get_value(tag, 38, &iw) )
  {
    v19 = Sprintf(" width=\"%d\"", iw);
    savexmlstr_0(tmp, v19);
  }
  if ( parsedtag_get_value(tag, 17, &ih) )
  {
    v20 = Sprintf(" height=\"%d\"", ih);
    savexmlstr_0(tmp, v20);
  }
  Strcat_charp(tmp, " pre_int>");
  Strcat_charp(tmp, "</input_alt></pre_int>");
  return tmp;
}

//----- (08063D02) --------------------------------------------------------
Str __cdecl process_select(parsed_tag *tag)
{
  parsed_tag *v1; // eax
  _BOOL4 v2; // eax
  int v3; // esi
  char *v4; // ecx
  int v5; // eax
  int v6; // ebx
  char *s; // [esp+24h] [ebp-14h] BYREF
  char *p; // [esp+28h] [ebp-10h] BYREF
  Str tmp; // [esp+2Ch] [ebp-Ch]

  tmp = 0;
  if ( form_sp < 0 || form_stack[form_sp] < 0 )
  {
    s = "<form_int method=internal action=none>";
    v1 = parse_tag(&s, 1);
    tmp = process_form(v1);
  }
  p = (char *)&line;
  parsedtag_get_value(tag, 25, &p);
  cur_select = Strnew_charp(p);
  v2 = tag->map && tag->map[24] != 75 && tag->attrid[tag->map[24]];
  select_is_multiple = v2;
  if ( v2 )
  {
    select_str = Strnew();
  }
  else
  {
    v3 = n_select;
    v4 = html_quote(p);
    if ( form_sp < 0 )
      v5 = -1;
    else
      v5 = form_stack[form_sp];
    v6 = cur_hseq++;
    select_str = Sprintf(
                   "<pre_int>[<input_alt hseq=\"%d\" fid=\"%d\" type=select name=\"%s\" selectnumber=%d",
                   v6,
                   v5,
                   v4,
                   v3);
    Strcat_charp(select_str, ">");
    if ( n_select == max_select )
    {
      max_select *= 2;
      select_option = (FormSelectOption *)GC_realloc(select_option, 8 * max_select);
    }
    select_option[n_select].first = 0;
    select_option[n_select].last = 0;
    cur_option_maxwidth = 0;
  }
  cur_option = 0;
  cur_status = 0;
  n_selectitem = 0;
  return tmp;
}
// 8049E6C: using guessed type int __cdecl GC_realloc(_DWORD, _DWORD);

//----- (08063F01) --------------------------------------------------------
Str process_n_select()
{
  _Str *v1; // eax
  FormItemList sitem; // [esp+18h] [ebp-50h] BYREF

  if ( !cur_select )
    return 0;
  process_option();
  if ( select_is_multiple )
  {
    Strcat_charp(select_str, "<br>");
  }
  else
  {
    if ( select_option[n_select].first )
    {
      chooseSelectOption(&sitem, select_option[n_select].first);
      v1 = textfieldrep(sitem.label, cur_option_maxwidth);
      savexmlstr_0(select_str, v1);
    }
    Strcat_charp(select_str, "</input_alt>]</pre_int>");
    ++n_select;
  }
  cur_select = 0;
  n_selectitem = 0;
  return select_str;
}

//----- (08063FDE) --------------------------------------------------------
void __cdecl feed_select(char *str)
{
  _BOOL4 v1; // eax
  char *v2; // eax
  Str v3; // eax
  int v4; // ecx
  char *v5; // edx
  char *q; // [esp+2Ch] [ebp-1Ch] BYREF
  parsed_tag *tag; // [esp+30h] [ebp-18h]
  char *p; // [esp+34h] [ebp-14h] BYREF
  int prev_status; // [esp+38h] [ebp-10h]
  Str tmp; // [esp+3Ch] [ebp-Ch]

  tmp = Strnew();
  prev_status = cur_status;
  if ( cur_select )
  {
    while ( read_token(tmp, &str, &cur_status, 0, 0) )
    {
      if ( !cur_status && !prev_status )
      {
        p = tmp->ptr;
        if ( *tmp->ptr == 60 && tmp->length > 0 && tmp->ptr[tmp->length - 1] == 62 )
        {
          tag = parse_tag(&p, 0);
          if ( tag && tag->tagid == 49 )
          {
            process_option();
            cur_option = Strnew();
            if ( parsedtag_get_value(tag, 36, &q) )
              cur_option_value = Strnew_charp(q);
            else
              cur_option_value = 0;
            if ( parsedtag_get_value(tag, 42, &q) )
              cur_option_label = Strnew_charp(q);
            else
              cur_option_label = 0;
            v1 = tag->map && tag->map[41] != 75 && tag->attrid[tag->map[41]];
            cur_option_selected = v1;
            prev_spaces_14599 = -1;
          }
        }
        else if ( cur_option )
        {
          while ( *p )
          {
            if ( (MYCTYPE_MAP[(unsigned __int8)*p] & 2) != 0 && prev_spaces_14599 )
            {
              ++p;
              if ( prev_spaces_14599 > 0 )
                ++prev_spaces_14599;
            }
            else
            {
              prev_spaces_14599 = (MYCTYPE_MAP[(unsigned __int8)*p] & 2) != 0;
              if ( *p == 38 )
              {
                v2 = getescapecmd(&p);
                Strcat_charp(cur_option, v2);
              }
              else
              {
                if ( cur_option->length + 1 >= cur_option->area_size )
                  Strgrow(cur_option);
                v3 = cur_option;
                v4 = cur_option->length;
                v5 = p;
                cur_option->ptr[v4] = *p;
                v3->length = v4 + 1;
                p = v5 + 1;
                cur_option->ptr[cur_option->length] = 0;
              }
            }
          }
        }
      }
    }
  }
}

//----- (080642DF) --------------------------------------------------------
void process_option()
{
  char *v0; // esi
  char *v1; // ebx
  const char *v2; // edx
  int v3; // eax
  int v4; // edi
  _Str *v5; // eax
  Str v6; // eax
  int v7; // edx
  char *v8; // eax
  int len; // [esp+28h] [ebp-20h]

  if ( cur_select && cur_option )
  {
    while ( cur_option->length > 0 && (MYCTYPE_MAP[(unsigned __int8)cur_option->ptr[cur_option->length - 1]] & 2) != 0 )
      Strshrink(cur_option, 1);
    if ( !cur_option_value )
      cur_option_value = cur_option;
    if ( !cur_option_label )
      cur_option_label = cur_option;
    if ( select_is_multiple )
    {
      v0 = html_quote(cur_option_value->ptr);
      v1 = html_quote(cur_select->ptr);
      if ( select_is_multiple )
        v2 = "checkbox";
      else
        v2 = "radio";
      if ( form_sp < 0 )
        v3 = -1;
      else
        v3 = form_stack[form_sp];
      v4 = cur_hseq++;
      v5 = Sprintf(
             "<br><pre_int>%c<input_alt hseq=\"%d\" fid=\"%d\" type=%s name=\"%s\" value=\"%s\"",
             91,
             v4,
             v3,
             v2,
             v1,
             v0);
      savexmlstr_0(select_str, v5);
      if ( cur_option_selected )
        Strcat_charp(select_str, " checked>*</input_alt>");
      else
        Strcat_charp(select_str, "> </input_alt>");
      if ( select_str->length + 1 >= select_str->area_size )
        Strgrow(select_str);
      v6 = select_str;
      v7 = select_str->length;
      select_str->ptr[v7] = 93;
      v6->length = v7 + 1;
      select_str->ptr[select_str->length] = 0;
      v8 = html_quote(cur_option_label->ptr);
      Strcat_charp(select_str, v8);
      Strcat_charp(select_str, "</pre_int>");
      ++n_selectitem;
    }
    else
    {
      len = wtf_strwidth((wc_uchar *)cur_option_label->ptr);
      if ( len > cur_option_maxwidth )
        cur_option_maxwidth = len;
      addSelectOption(&select_option[n_select], cur_option_value, cur_option_label, cur_option_selected);
    }
  }
}

//----- (0806458C) --------------------------------------------------------
Str __cdecl process_textarea(parsed_tag *tag, int width)
{
  parsed_tag *v2; // eax
  char *v3; // ebx
  _BOOL4 v4; // eax
  Str *v5; // ebx
  char *s; // [esp+14h] [ebp-14h] BYREF
  char *p; // [esp+18h] [ebp-10h] BYREF
  Str tmp; // [esp+1Ch] [ebp-Ch]

  tmp = 0;
  if ( form_sp < 0 || form_stack[form_sp] < 0 )
  {
    s = "<form_int method=internal action=none>";
    v2 = parse_tag(&s, 1);
    tmp = process_form(v2);
  }
  p = (char *)&line;
  parsedtag_get_value(tag, 25, &p);
  cur_textarea = Strnew_charp(p);
  cur_textarea_size = 20;
  if ( parsedtag_get_value(tag, 13, &p) )
  {
    cur_textarea_size = atoi(p);
    v3 = p;
    if ( v3[strlen(p) - 1] == 37 )
      cur_textarea_size = width * cur_textarea_size / 100 - 2;
    if ( cur_textarea_size <= 0 )
      cur_textarea_size = 20;
  }
  cur_textarea_rows = 1;
  if ( parsedtag_get_value(tag, 28, &p) )
  {
    cur_textarea_rows = atoi(p);
    if ( cur_textarea_rows <= 0 )
      cur_textarea_rows = 1;
  }
  v4 = tag->map && tag->map[43] != 75 && tag->attrid[tag->map[43]];
  cur_textarea_readonly = v4;
  if ( n_textarea >= max_textarea )
  {
    max_textarea *= 2;
    textarea_str = (Str *)GC_realloc(textarea_str, 4 * max_textarea);
  }
  v5 = &textarea_str[n_textarea];
  *v5 = Strnew();
  ignore_nl_textarea = 1;
  return tmp;
}
// 8049E6C: using guessed type int __cdecl GC_realloc(_DWORD, _DWORD);

//----- (0806479C) --------------------------------------------------------
Str process_n_textarea()
{
  int v1; // edi
  int v2; // esi
  int v3; // ebx
  char *v4; // ecx
  int v5; // eax
  _Str *v6; // eax
  int v7; // eax
  int v8; // [esp+2Ch] [ebp-2Ch]
  int i; // [esp+38h] [ebp-20h]
  Str tmp; // [esp+3Ch] [ebp-1Ch]

  if ( !cur_textarea )
    return 0;
  tmp = Strnew();
  v1 = n_textarea;
  v8 = cur_textarea_rows - 1;
  v2 = cur_textarea_rows;
  v3 = cur_textarea_size;
  v4 = html_quote(cur_textarea->ptr);
  if ( form_sp < 0 )
    v5 = -1;
  else
    v5 = form_stack[form_sp];
  v6 = Sprintf(
         "<pre_int>[<input_alt hseq=\"%d\" fid=\"%d\" type=textarea name=\"%s\" size=%d rows=%d top_margin=%d textareanumber=%d",
         cur_hseq,
         v5,
         v4,
         v3,
         v2,
         v8,
         v1);
  savexmlstr_0(tmp, v6);
  if ( cur_textarea_readonly )
    Strcat_charp(tmp, " readonly");
  Strcat_charp(tmp, "><u>");
  for ( i = 0; i < cur_textarea_size; ++i )
  {
    if ( tmp->length + 1 >= tmp->area_size )
      Strgrow(tmp);
    v7 = tmp->length;
    tmp->ptr[v7] = 32;
    tmp->length = v7 + 1;
    tmp->ptr[tmp->length] = 0;
  }
  Strcat_charp(tmp, "</u></input_alt>]</pre_int>\n");
  ++cur_hseq;
  ++n_textarea;
  cur_textarea = 0;
  return tmp;
}

//----- (08064924) --------------------------------------------------------
void __cdecl feed_textarea(char *str)
{
  char *v1; // eax
  Str v2; // eax
  int v3; // ecx
  char *v4; // edx

  if ( cur_textarea )
  {
    if ( ignore_nl_textarea )
    {
      if ( *str == 13 )
        ++str;
      if ( *str == 10 )
        ++str;
    }
    ignore_nl_textarea = 0;
    while ( *str )
    {
      if ( *str == 38 )
      {
        v1 = getescapecmd(&str);
        Strcat_charp(textarea_str[n_textarea], v1);
      }
      else if ( *str == 10 )
      {
        Strcat_charp(textarea_str[n_textarea], "\r\n");
        ++str;
      }
      else if ( *str != 13 )
      {
        if ( textarea_str[n_textarea]->length + 1 >= textarea_str[n_textarea]->area_size )
          Strgrow(textarea_str[n_textarea]);
        v2 = textarea_str[n_textarea];
        v3 = v2->length;
        v4 = str;
        v2->ptr[v3] = *str;
        v2->length = v3 + 1;
        str = v4 + 1;
        textarea_str[n_textarea]->ptr[textarea_str[n_textarea]->length] = 0;
      }
    }
  }
}

//----- (08064ACC) --------------------------------------------------------
Str __cdecl process_hr(parsed_tag *tag, int width, int indent_width)
{
  int v3; // eax
  int x; // [esp+34h] [ebp-14h] BYREF
  int w; // [esp+38h] [ebp-10h] BYREF
  Str tmp; // [esp+3Ch] [ebp-Ch]

  tmp = Strnew_charp("<nobr>");
  w = 0;
  x = 0;
  if ( width > indent_width )
    width -= indent_width;
  if ( parsedtag_get_value(tag, 38, &w) )
  {
    if ( w < 0 )
      v3 = width * -w / 100;
    else
      v3 = (int)((long double)w / pixel_per_char);
    w = v3;
  }
  else
  {
    w = width;
  }
  parsedtag_get_value(tag, 4, &x);
  switch ( x )
  {
    case 1:
      Strcat_charp(tmp, "<div_int align=left>");
      break;
    case 2:
      Strcat_charp(tmp, "<div_int align=right>");
      break;
    case 0:
      Strcat_charp(tmp, "<div_int align=center>");
      break;
  }
  w /= symbol_width;
  if ( w <= 0 )
    w = 1;
  push_symbol(tmp, 26, symbol_width, w);
  Strcat_charp(tmp, "</div_int></nobr>");
  return tmp;
}

//----- (08064C43) --------------------------------------------------------
char *__cdecl check_charset(char *p)
{
  char *result; // eax

  if ( wc_guess_charset(p, 0) )
    result = p;
  else
    result = 0;
  return result;
}

//----- (08064C6C) --------------------------------------------------------
char *__cdecl check_accept_charset(char *ac)
{
  Str v1; // eax
  char *e; // [esp+18h] [ebp-10h]
  char *s; // [esp+1Ch] [ebp-Ch]

  for ( s = ac; *s; s = e )
  {
    while ( *s && ((MYCTYPE_MAP[(unsigned __int8)*s] & 2) != 0 || *s == 44) )
      ++s;
    if ( !*s )
      break;
    for ( e = s; *e && (MYCTYPE_MAP[(unsigned __int8)*e] & 2) == 0 && *e != 44; ++e )
      ;
    v1 = Strnew_charp_n(s, e - s);
    if ( wc_guess_charset(v1->ptr, 0) )
      return ac;
  }
  return 0;
}

//----- (08064D4E) --------------------------------------------------------
Str __cdecl process_form_int(parsed_tag *tag, int fid)
{
  char *v2; // ebx
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  Str result; // eax
  _Str *v8; // [esp+4h] [ebp-64h]
  _Str *v9; // [esp+4h] [ebp-64h]
  _Str *v10; // [esp+4h] [ebp-64h]
  _Str *v11; // [esp+4h] [ebp-64h]
  char *v12; // [esp+8h] [ebp-60h]
  FormList **v13; // [esp+2Ch] [ebp-3Ch]
  _Str *tmp; // [esp+34h] [ebp-34h]
  char *n; // [esp+38h] [ebp-30h] BYREF
  char *tg; // [esp+3Ch] [ebp-2Ch] BYREF
  char *s; // [esp+40h] [ebp-28h] BYREF
  char *r; // [esp+44h] [ebp-24h] BYREF
  char *q; // [esp+48h] [ebp-20h] BYREF
  char *p; // [esp+4Ch] [ebp-1Ch] BYREF

  p = "get";
  parsedtag_get_value(tag, 23, &p);
  q = "!CURRENT_URL!";
  parsedtag_get_value(tag, 3, &q);
  r = 0;
  if ( parsedtag_get_value(tag, 2, &r) )
    r = check_accept_charset(r);
  if ( !r && parsedtag_get_value(tag, 11, &r) )
    r = check_charset(r);
  s = 0;
  parsedtag_get_value(tag, 16, &s);
  tg = 0;
  parsedtag_get_value(tag, 32, &tg);
  n = 0;
  parsedtag_get_value(tag, 25, &n);
  if ( fid >= 0 )
  {
    if ( form_max < fid )
      form_max = fid;
    form_sp = fid;
  }
  else
  {
    ++form_max;
    ++form_sp;
    fid = form_max;
  }
  if ( forms_size )
  {
    if ( forms_size <= form_max )
    {
      forms_size += form_max;
      forms = (FormList **)GC_realloc(forms, 4 * forms_size);
      form_stack = (int *)GC_realloc(form_stack, 4 * forms_size);
    }
  }
  else
  {
    forms_size = 10;
    forms = (FormList **)GC_malloc(40);
    form_stack = (int *)GC_malloc_atomic(4 * forms_size);
  }
  form_stack[form_sp] = fid;
  if ( (w3m_dump & 0x10) != 0 )
  {
    v2 = html_quote(p);
    v12 = html_quote(q);
    tmp = Sprintf("<form_int fid=\"%d\" action=\"%s\" method=\"%s\"", fid, v12, v2);
    if ( s )
    {
      v3 = html_quote(s);
      v8 = Sprintf(" enctype=\"%s\"", v3);
      savexmlstr_0(tmp, v8);
    }
    if ( tg )
    {
      v4 = html_quote(tg);
      v9 = Sprintf(" target=\"%s\"", v4);
      savexmlstr_0(tmp, v9);
    }
    if ( n )
    {
      v5 = html_quote(n);
      v10 = Sprintf(" name=\"%s\"", v5);
      savexmlstr_0(tmp, v10);
    }
    if ( r )
    {
      v6 = html_quote(r);
      v11 = Sprintf(" accept-charset=\"%s\"", v6);
      savexmlstr_0(tmp, v11);
    }
    Strcat_charp(tmp, ">");
    result = tmp;
  }
  else
  {
    v13 = &forms[fid];
    *v13 = newFormList(q, p, r, s, tg, n, 0);
    result = 0;
  }
  return result;
}
// 8049E6C: using guessed type int __cdecl GC_realloc(_DWORD, _DWORD);
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);
// 804A51C: using guessed type int __cdecl GC_malloc_atomic(_DWORD);

//----- (080650DB) --------------------------------------------------------
Str __cdecl process_form(parsed_tag *tag)
{
  return process_form_int(tag, -1);
}

//----- (080650F6) --------------------------------------------------------
Str process_n_form()
{
  if ( form_sp >= 0 )
    --form_sp;
  return 0;
}

//----- (08065116) --------------------------------------------------------
void __cdecl clear_ignore_p_flag(int cmd, readbuffer *obuf)
{
  int v2; // edx
  int i; // [esp+Ch] [ebp-4h]

  for ( i = 0; clear_flag_cmd_15359[i]; ++i )
  {
    if ( clear_flag_cmd_15359[i] == cmd )
    {
      v2 = obuf->flag;
      BYTE1(v2) &= 0xDFu;
      obuf->flag = v2;
      return;
    }
  }
}

//----- (0806515B) --------------------------------------------------------
void __cdecl set_alignment(readbuffer *obuf, parsed_tag *tag)
{
  int v2; // eax
  int align; // [esp+18h] [ebp-10h] BYREF
  int flag; // [esp+1Ch] [ebp-Ch]

  flag = -1;
  if ( parsedtag_get_value(tag, 4, &align) )
  {
    switch ( align )
    {
      case 1:
        flag = 16;
        break;
      case 2:
        flag = 64;
        break;
      case 0:
        flag = 32;
        break;
    }
  }
  if ( obuf->flag_sp <= 9 )
  {
    v2 = obuf->flag_sp;
    obuf->flag_stack[v2] = obuf->flag & 0x70;
    obuf->flag_sp = v2 + 1;
  }
  if ( flag != -1 )
  {
    obuf->flag &= 0xFFFFFF8F;
    obuf->flag |= flag;
  }
}

//----- (0806520D) --------------------------------------------------------
void __cdecl process_idattr(readbuffer *obuf, int cmd, parsed_tag *tag)
{
  char *v3; // ebx
  char *v4; // eax
  char *v5; // eax
  Str idtag; // [esp+14h] [ebp-14h]
  char *framename; // [esp+18h] [ebp-10h] BYREF
  char *id; // [esp+1Ch] [ebp-Ch] BYREF

  id = 0;
  framename = 0;
  if ( cmd != 31 )
  {
    parsedtag_get_value(tag, 20, &id);
    parsedtag_get_value(tag, 67, &framename);
    if ( id )
    {
      if ( framename )
      {
        v3 = html_quote(framename);
        v4 = html_quote(id);
        idtag = Sprintf("<_id id=\"%s\" framename=\"%s\">", v4, v3);
      }
      else
      {
        v5 = html_quote(id);
        idtag = Sprintf("<_id id=\"%s\">", v5);
      }
      push_tag(obuf, idtag->ptr, 138);
    }
  }
}

//----- (080652EC) --------------------------------------------------------
int __cdecl ul_type(parsed_tag *tag, int default_type)
{
  int result; // eax
  char *p; // [esp+1Ch] [ebp-Ch] BYREF

  if ( !parsedtag_get_value(tag, 33, &p) )
    goto LABEL_8;
  if ( !strcasecmp(p, "disc") )
    return 100;
  if ( !strcasecmp(p, "circle") )
    return 99;
  if ( !strcasecmp(p, "square") )
    result = 115;
  else
LABEL_8:
    result = default_type;
  return result;
}

//----- (0806536F) --------------------------------------------------------
int __cdecl getMetaRefreshParam(char *q, Str *refresh_uri)
{
  Str s_tmp; // [esp+14h] [ebp-14h]
  char *r; // [esp+18h] [ebp-10h]
  int refresh_interval; // [esp+1Ch] [ebp-Ch]
  char *qa; // [esp+30h] [ebp+8h]

  s_tmp = 0;
  if ( !q || !refresh_uri )
    return 0;
  refresh_interval = atoi(q);
  if ( refresh_interval < 0 )
    return 0;
  while ( *q )
  {
    if ( !strncasecmp(q, "url=", 4u) )
    {
      qa = q + 4;
      if ( *qa == 34 )
        ++qa;
      for ( r = qa; *r && (MYCTYPE_MAP[(unsigned __int8)*r] & 2) == 0 && *r != 59; ++r )
        ;
      s_tmp = Strnew_charp_n(qa, r - qa);
      if ( s_tmp->ptr[s_tmp->length - 1] == 34 )
        s_tmp->ptr[--s_tmp->length] = 0;
      q = r;
    }
    while ( *q && *q != 59 )
      ++q;
    if ( *q == 59 )
      ++q;
    while ( *q && *q == 32 )
      ++q;
  }
  *refresh_uri = s_tmp;
  return refresh_interval;
}

//----- (080654E5) --------------------------------------------------------
int __cdecl HTMLtagproc1(parsed_tag *tag, html_feed_environ *h_env)
{
  int result; // eax
  int v3; // edx
  int v4; // edx
  int v5; // edx
  int v6; // edx
  int v7; // edx
  int v8; // edx
  int v9; // edx
  int v10; // edx
  environment *v11; // ebx
  int v12; // edx
  int v13; // edx
  int v14; // edx
  int v15; // eax
  bool v16; // dl
  int v17; // edx
  int v18; // edx
  int v19; // edx
  int v20; // edx
  int v21; // edx
  int v22; // edx
  int v23; // edx
  int v24; // eax
  environment *v25; // ebx
  int v26; // eax
  int v27; // eax
  int v28; // eax
  int v29; // edx
  int v30; // edx
  int v31; // edx
  int v32; // edx
  int v33; // edx
  int v34; // edx
  int v35; // edx
  int v36; // edx
  int v37; // edx
  int v38; // edx
  int v39; // eax
  bool v40; // dl
  int v41; // edx
  int v42; // edx
  int v43; // edx
  int v44; // edx
  int v45; // edx
  Str v46; // eax
  int v47; // esi
  char *v48; // ebx
  int v49; // eax
  int v50; // eax
  int v51; // edx
  int v52; // edx
  int v53; // edx
  int v54; // edx
  int v55; // edx
  int v56; // edx
  int v57; // edx
  int v58; // edx
  int v59; // edx
  int v60; // edx
  int v61; // edx
  int v62; // edx
  int v63; // edx
  int v64; // edx
  int v65; // edx
  int v66; // edx
  int v67; // edx
  int v68; // eax
  int v69; // eax
  int v70; // ebx
  table *v71; // ebx
  int v72; // edx
  int v73; // edx
  int v74; // eax
  int v75; // edx
  int v76; // edx
  int v77; // edx
  int v78; // edx
  int v79; // edx
  int v80; // edx
  int v81; // edx
  int v82; // edx
  int v83; // edx
  int v84; // edx
  int v85; // edx
  int v86; // edx
  int v87; // edx
  int v88; // edx
  int v89; // edx
  int v90; // edx
  int v91; // edx
  int v92; // edx
  int v93; // edx
  int v94; // edx
  int v95; // edx
  int v96; // edx
  char *v97; // ebx
  char *v98; // eax
  Str s_2; // [esp+38h] [ebp-60h]
  Str s_1; // [esp+3Ch] [ebp-5Ch]
  Str s_0; // [esp+40h] [ebp-58h]
  Str s; // [esp+44h] [ebp-54h]
  int refresh_interval; // [esp+48h] [ebp-50h]
  Str num; // [esp+4Ch] [ebp-4Ch]
  char *id; // [esp+50h] [ebp-48h] BYREF
  int cmd; // [esp+54h] [ebp-44h]
  int hseq; // [esp+58h] [ebp-40h] BYREF
  Str tmp; // [esp+5Ch] [ebp-3Ch] BYREF
  environment *envs; // [esp+60h] [ebp-38h]
  readbuffer *obuf; // [esp+64h] [ebp-34h]
  int width; // [esp+68h] [ebp-30h]
  int count; // [esp+6Ch] [ebp-2Ch] BYREF
  int z; // [esp+70h] [ebp-28h] BYREF
  int y; // [esp+74h] [ebp-24h] BYREF
  int x; // [esp+78h] [ebp-20h] BYREF
  int w; // [esp+7Ch] [ebp-1Ch] BYREF
  int i; // [esp+80h] [ebp-18h] BYREF
  char *r; // [esp+84h] [ebp-14h] BYREF
  char *q; // [esp+88h] [ebp-10h] BYREF
  char *p[3]; // [esp+8Ch] [ebp-Ch] BYREF

  obuf = h_env->obuf;
  envs = h_env->envs;
  id = 0;
  cmd = tag->tagid;
  if ( (obuf->flag & 1) != 0 && cmd >= 50 && (cmd <= 51 || (unsigned int)(cmd - 128) <= 1) )
    return 1;
  switch ( cmd )
  {
    case 1:
      if ( obuf->anchor.url )
        close_anchor(h_env, obuf);
      hseq = 0;
      if ( parsedtag_get_value(tag, 18, p) )
        obuf->anchor.url = Strnew_charp(p[0])->ptr;
      if ( parsedtag_get_value(tag, 32, p) )
        obuf->anchor.target = Strnew_charp(p[0])->ptr;
      if ( parsedtag_get_value(tag, 71, p) )
        obuf->anchor.referer = Strnew_charp(p[0])->ptr;
      if ( parsedtag_get_value(tag, 49, p) )
        obuf->anchor.title = Strnew_charp(p[0])->ptr;
      if ( parsedtag_get_value(tag, 50, p) )
        obuf->anchor.accesskey = *p[0];
      if ( parsedtag_get_value(tag, 69, &hseq) )
        obuf->anchor.hseq = hseq;
      if ( hseq || !obuf->anchor.url )
        return 0;
      obuf->anchor.hseq = cur_hseq;
      tmp = process_anchor(tag, h_env->tagbuf->ptr);
      push_tag(obuf, tmp->ptr, 1);
      return 1;
    case 2:
      goto LABEL_92;
    case 3:
      if ( (obuf->flag & 0x2A0F) == 0 )
      {
        flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);
        do_blankline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);
      }
      HTMLlineproc0("<b>", h_env, 1);
      set_alignment(obuf, tag);
      return 1;
    case 4:
      HTMLlineproc0("</b>", h_env, 1);
      if ( (obuf->flag & 0xA0F) == 0 )
        flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);
      do_blankline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);
      if ( obuf->flag_sp > 0 )
      {
        obuf->flag &= 0xFFFFFF8F;
        v7 = obuf->flag;
        obuf->flag = obuf->flag_stack[--obuf->flag_sp] | v7;
      }
      close_anchor(h_env, obuf);
      v8 = obuf->flag;
      BYTE1(v8) |= 0x20u;
      obuf->flag = v8;
      return 1;
    case 5:
    case 34:
      if ( (obuf->flag & 0x100) != 0 )
      {
        flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);
        if ( obuf->flag_sp > 0 )
        {
          obuf->flag &= 0xFFFFFF8F;
          v3 = obuf->flag;
          obuf->flag = obuf->flag_stack[--obuf->flag_sp] | v3;
        }
        v4 = obuf->flag;
        BYTE1(v4) &= 0xFEu;
        obuf->flag = v4;
      }
      close_anchor(h_env, obuf);
      if ( (obuf->flag & 0x2000) == 0 )
      {
        flushline(h_env, obuf, envs[h_env->envc].indent, 1, h_env->limit);
        do_blankline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);
      }
      v5 = obuf->flag;
      BYTE1(v5) |= 0x20u;
      obuf->flag = v5;
      if ( cmd == 5 )
      {
        set_alignment(obuf, tag);
        v6 = obuf->flag;
        BYTE1(v6) |= 1u;
        obuf->flag = v6;
      }
      return 1;
    case 6:
      flushline(h_env, obuf, envs[h_env->envc].indent, 1, h_env->limit);
      h_env->blank_lines = 0;
      return 1;
    case 7:
      return ++obuf->fontstat[0] > 1;
    case 8:
      if ( obuf->fontstat[0] == 1 && close_effect0(obuf, 7) )
        obuf->fontstat[0] = 0;
      result = 1;
      if ( obuf->fontstat[0] > 0 && !--obuf->fontstat[0] )
        result = 0;
      return result;
    case 9:
    case 12:
    case 23:
      if ( (obuf->flag & 0x100) != 0 )
      {
        flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);
        if ( obuf->flag_sp > 0 )
        {
          obuf->flag &= 0xFFFFFF8F;
          v9 = obuf->flag;
          obuf->flag = obuf->flag_stack[--obuf->flag_sp] | v9;
        }
        v10 = obuf->flag;
        BYTE1(v10) &= 0xFEu;
        obuf->flag = v10;
      }
      close_anchor(h_env, obuf);
      if ( (obuf->flag & 0x2000) == 0 )
      {
        flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);
        if ( (obuf->flag & 0xA0F) == 0 && (!h_env->envc || cmd == 23) )
          do_blankline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);
      }
      if ( ++h_env->envc_real < h_env->nenv )
      {
        envs[++h_env->envc].env = cmd;
        envs[h_env->envc].count = 0;
        if ( h_env->envc > 10 )
          envs[h_env->envc].indent = envs[h_env->envc - 1].indent;
        else
          envs[h_env->envc].indent = envs[h_env->envc - 1].indent + IndentIncr;
      }
      if ( (cmd == 9 || cmd == 12) && parsedtag_get_value(tag, 40, &count) )
        envs[h_env->envc].count = count - 1;
      if ( cmd == 12 )
      {
        envs[h_env->envc].type = 49;
        if ( parsedtag_get_value(tag, 33, p) )
          envs[h_env->envc].type = *p[0];
      }
      if ( cmd == 9 )
      {
        v11 = &envs[h_env->envc];
        v11->type = ul_type(tag, 0);
      }
      flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);
      return 1;
    case 10:
    case 13:
    case 18:
    case 24:
      if ( (obuf->flag & 0x400) != 0 )
      {
        v12 = obuf->flag;
        BYTE1(v12) &= 0xFBu;
        obuf->flag = v12;
        HTMLlineproc0("</b>", h_env, 1);
      }
      if ( (obuf->flag & 0x100) != 0 )
      {
        flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);
        if ( obuf->flag_sp > 0 )
        {
          obuf->flag &= 0xFFFFFF8F;
          v13 = obuf->flag;
          obuf->flag = obuf->flag_stack[--obuf->flag_sp] | v13;
        }
        v14 = obuf->flag;
        BYTE1(v14) &= 0xFEu;
        obuf->flag = v14;
      }
      close_anchor(h_env, obuf);
      if ( h_env->envc > 0 )
      {
        flushline(h_env, obuf, envs[h_env->envc - 1].indent, 0, h_env->limit);
        v15 = h_env->envc_real;
        v16 = v15 < h_env->nenv;
        h_env->envc_real = v15 - 1;
        if ( v16 )
          --h_env->envc;
        if ( (obuf->flag & 0xA0F) == 0 && (!h_env->envc || cmd == 18 || cmd == 24) )
        {
          do_blankline(h_env, obuf, envs[h_env->envc].indent, IndentIncr, h_env->limit);
          v17 = obuf->flag;
          BYTE1(v17) |= 0x20u;
          obuf->flag = v17;
        }
      }
LABEL_92:
      close_anchor(h_env, obuf);
      return 1;
    case 11:
      if ( (obuf->flag & 0x100) != 0 )
      {
        flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);
        if ( obuf->flag_sp > 0 )
        {
          obuf->flag &= 0xFFFFFF8F;
          v21 = obuf->flag;
          obuf->flag = obuf->flag_stack[--obuf->flag_sp] | v21;
        }
        v22 = obuf->flag;
        BYTE1(v22) &= 0xFEu;
        obuf->flag = v22;
      }
      close_anchor(h_env, obuf);
      if ( (obuf->flag & 0x400) != 0 )
      {
        v23 = obuf->flag;
        BYTE1(v23) &= 0xFBu;
        obuf->flag = v23;
        HTMLlineproc0("</b>", h_env, 1);
      }
      if ( h_env->envc <= 0 )
      {
        flushline(h_env, obuf, 0, 0, h_env->limit);
        goto LABEL_160;
      }
      flushline(h_env, obuf, envs[h_env->envc - 1].indent, 0, h_env->limit);
      ++envs[h_env->envc].count;
      if ( parsedtag_get_value(tag, 36, p) )
      {
        count = atoi(p[0]);
        if ( count <= 0 )
          envs[h_env->envc].count = 0;
        else
          envs[h_env->envc].count = count;
      }
      v24 = envs[h_env->envc].env;
      if ( v24 != 9 )
      {
        if ( v24 != 12 )
        {
          push_spaces(obuf, 1, IndentIncr);
          goto LABEL_160;
        }
        if ( parsedtag_get_value(tag, 33, p) )
          envs[h_env->envc].type = *p[0];
        if ( envs[h_env->envc].count <= 0 )
          v27 = 49;
        else
          v27 = envs[h_env->envc].type;
        if ( v27 == 73 )
        {
          num = romanNumeral(envs[h_env->envc].count);
          Strupper(num);
        }
        else if ( v27 > 73 )
        {
          if ( v27 == 97 )
          {
            num = romanAlphabet(envs[h_env->envc].count);
          }
          else
          {
            if ( v27 != 105 )
            {
LABEL_151:
              num = Sprintf("%d", envs[h_env->envc].count);
              goto LABEL_152;
            }
            num = romanNumeral(envs[h_env->envc].count);
          }
        }
        else
        {
          if ( v27 != 65 )
            goto LABEL_151;
          num = romanAlphabet(envs[h_env->envc].count);
          Strupper(num);
        }
LABEL_152:
        if ( IndentIncr <= 3 )
        {
          if ( num->length + 1 >= num->area_size )
            Strgrow(num);
          v28 = num->length;
          num->ptr[v28] = 46;
          num->length = v28 + 1;
          num->ptr[num->length] = 0;
        }
        else
        {
          Strcat_charp(num, ". ");
        }
        push_spaces(obuf, 1, IndentIncr - num->length);
        push_nchars(obuf, num->length, num->ptr, num->length, 0);
        if ( IndentIncr > 3 )
          Strcopy_charp_n(obuf->prevchar, " ", 1);
        goto LABEL_160;
      }
      v25 = &envs[h_env->envc];
      v25->type = ul_type(tag, v25->type);
      for ( i = 0; IndentIncr - 3 > i; ++i )
        push_nchars(obuf, 1, (char *)&str, 1, 0);
      tmp = Strnew();
      v26 = envs[h_env->envc].type;
      switch ( v26 )
      {
        case 'd':
          push_symbol(tmp, 41, symbol_width, 1);
          break;
        case 's':
          push_symbol(tmp, 43, symbol_width, 1);
          break;
        case 'c':
          push_symbol(tmp, 42, symbol_width, 1);
          break;
        default:
          push_symbol(tmp, (h_env->envc_real - 1) % 9 + 32, symbol_width, 1);
          break;
      }
      if ( symbol_width == 1 )
        push_nchars(obuf, 1, (char *)&str, 1, 0);
      push_nchars(obuf, symbol_width, tmp->ptr, tmp->length, 0);
      push_nchars(obuf, 1, (char *)&str, 1, 0);
      Strcopy_charp_n(obuf->prevchar, " ", 1);
LABEL_160:
      v29 = obuf->flag;
      BYTE1(v29) |= 0x20u;
      obuf->flag = v29;
      return 1;
    case 14:
      close_anchor(h_env, obuf);
      process_title(tag);
      v37 = obuf->flag;
      BYTE1(v37) |= 0x40u;
      obuf->flag = v37;
      obuf->end_tag = 15;
      return 1;
    case 15:
      if ( (obuf->flag & 0x4000) == 0 )
        return 1;
      v38 = obuf->flag;
      BYTE1(v38) &= 0xBFu;
      obuf->flag = v38;
      obuf->end_tag = 0;
      tmp = process_n_title(tag);
      if ( tmp )
        HTMLlineproc0(tmp->ptr, h_env, 1);
      return 1;
    case 16:
      close_anchor(h_env, obuf);
      tmp = process_hr(tag, h_env->limit, envs[h_env->envc].indent);
      HTMLlineproc0(tmp->ptr, h_env, 1);
      Strcopy_charp_n(obuf->prevchar, " ", 1);
      return 1;
    case 17:
      if ( (obuf->flag & 0x100) != 0 )
      {
        flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);
        if ( obuf->flag_sp > 0 )
        {
          obuf->flag &= 0xFFFFFF8F;
          v18 = obuf->flag;
          obuf->flag = obuf->flag_stack[--obuf->flag_sp] | v18;
        }
        v19 = obuf->flag;
        BYTE1(v19) &= 0xFEu;
        obuf->flag = v19;
      }
      close_anchor(h_env, obuf);
      if ( (obuf->flag & 0x2000) == 0 )
      {
        flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);
        if ( (obuf->flag & 0xA0F) == 0 )
          do_blankline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);
      }
      if ( ++h_env->envc_real < h_env->nenv )
      {
        envs[++h_env->envc].env = cmd;
        envs[h_env->envc].count = 0;
        if ( h_env->envc > 10 )
          envs[h_env->envc].indent = envs[h_env->envc - 1].indent;
        else
          envs[h_env->envc].indent = envs[h_env->envc - 1].indent + IndentIncr;
      }
      if ( tag->map && tag->map[39] != 75 && tag->attrid[tag->map[39]] )
        envs[h_env->envc].env = -123;
      v20 = obuf->flag;
      BYTE1(v20) |= 0x20u;
      obuf->flag = v20;
      return 1;
    case 19:
      if ( (obuf->flag & 0x100) != 0 )
      {
        flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);
        if ( obuf->flag_sp > 0 )
        {
          obuf->flag &= 0xFFFFFF8F;
          v30 = obuf->flag;
          obuf->flag = obuf->flag_stack[--obuf->flag_sp] | v30;
        }
        v31 = obuf->flag;
        BYTE1(v31) &= 0xFEu;
        obuf->flag = v31;
      }
      close_anchor(h_env, obuf);
      if ( (!h_env->envc
         || h_env->envc_real < h_env->nenv && envs[h_env->envc].env != 17 && envs[h_env->envc].env != 0x85)
        && ++h_env->envc_real < h_env->nenv )
      {
        envs[++h_env->envc].env = 17;
        envs[h_env->envc].count = 0;
        if ( h_env->envc > 10 )
          envs[h_env->envc].indent = envs[h_env->envc - 1].indent;
        else
          envs[h_env->envc].indent = envs[h_env->envc - 1].indent + IndentIncr;
      }
      if ( h_env->envc > 0 )
        flushline(h_env, obuf, envs[h_env->envc - 1].indent, 0, h_env->limit);
      if ( (obuf->flag & 0x400) == 0 )
      {
        HTMLlineproc0("<b>", h_env, 1);
        v32 = obuf->flag;
        BYTE1(v32) |= 4u;
        obuf->flag = v32;
      }
      v33 = obuf->flag;
      BYTE1(v33) |= 0x20u;
      obuf->flag = v33;
      return 1;
    case 20:
      if ( (obuf->flag & 0x100) != 0 )
      {
        flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);
        if ( obuf->flag_sp > 0 )
        {
          obuf->flag &= 0xFFFFFF8F;
          v34 = obuf->flag;
          obuf->flag = obuf->flag_stack[--obuf->flag_sp] | v34;
        }
        v35 = obuf->flag;
        BYTE1(v35) &= 0xFEu;
        obuf->flag = v35;
      }
      close_anchor(h_env, obuf);
      if ( (obuf->flag & 0x400) != 0 )
      {
        v36 = obuf->flag;
        BYTE1(v36) &= 0xFBu;
        obuf->flag = v36;
        HTMLlineproc0("</b>", h_env, 1);
      }
      if ( envs[h_env->envc].env == 0x85 && obuf->pos <= envs[h_env->envc].indent )
        push_spaces(obuf, 1, envs[h_env->envc].indent - obuf->pos);
      else
        flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);
      return 1;
    case 21:
      v50 = tag->map && tag->map[66] != 75 && tag->attrid[tag->map[66]];
      x = v50;
      if ( (obuf->flag & 0x100) != 0 )
      {
        flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);
        if ( obuf->flag_sp > 0 )
        {
          obuf->flag &= 0xFFFFFF8F;
          v51 = obuf->flag;
          obuf->flag = obuf->flag_stack[--obuf->flag_sp] | v51;
        }
        v52 = obuf->flag;
        BYTE1(v52) &= 0xFEu;
        obuf->flag = v52;
      }
      close_anchor(h_env, obuf);
      if ( (obuf->flag & 0x2000) != 0 )
      {
        fillline(obuf, envs[h_env->envc].indent);
      }
      else
      {
        flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);
        if ( !x )
          do_blankline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);
      }
      obuf->flag |= 0x2001u;
      return 1;
    case 22:
      flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);
      if ( (obuf->flag & 0x2000) == 0 )
      {
        do_blankline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);
        v53 = obuf->flag;
        BYTE1(v53) |= 0x20u;
        obuf->flag = v53;
        ++h_env->blank_lines;
      }
      obuf->flag &= 0xFFFFFFFE;
      close_anchor(h_env, obuf);
      return 1;
    case 25:
      tmp = process_img(tag, h_env->limit);
      HTMLlineproc0(tmp->ptr, h_env, 1);
      return 1;
    case 26:
    case 28:
    case 30:
      if ( (obuf->flag & 0x100) != 0 )
      {
        flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);
        if ( obuf->flag_sp > 0 )
        {
          obuf->flag &= 0xFFFFFF8F;
          v63 = obuf->flag;
          obuf->flag = obuf->flag_stack[--obuf->flag_sp] | v63;
        }
        v64 = obuf->flag;
        BYTE1(v64) &= 0xFEu;
        obuf->flag = v64;
      }
      close_anchor(h_env, obuf);
      if ( (obuf->flag & 0x2000) == 0 )
      {
        flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);
        do_blankline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);
      }
      obuf->flag |= 0x2008u;
      switch ( cmd )
      {
        case 28:
          obuf->end_tag = 29;
          break;
        case 30:
          obuf->end_tag = -111;
          break;
        case 26:
          obuf->end_tag = 27;
          break;
      }
      return 1;
    case 27:
    case 29:
      if ( (obuf->flag & 0x100) != 0 )
      {
        flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);
        if ( obuf->flag_sp > 0 )
        {
          obuf->flag &= 0xFFFFFF8F;
          v65 = obuf->flag;
          obuf->flag = obuf->flag_stack[--obuf->flag_sp] | v65;
        }
        v66 = obuf->flag;
        BYTE1(v66) &= 0xFEu;
        obuf->flag = v66;
      }
      close_anchor(h_env, obuf);
      if ( (obuf->flag & 0x2000) == 0 )
      {
        flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);
        do_blankline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);
        v67 = obuf->flag;
        BYTE1(v67) |= 0x20u;
        obuf->flag = v67;
      }
      obuf->flag &= 0xFFFFFFF7;
      obuf->end_tag = 0;
      return 1;
    case 31:
      close_anchor(h_env, obuf);
      if ( ++obuf->table_level > 19 )
        return 0;
      w = 0;
      x = 2;
      y = 1;
      z = 0;
      width = 0;
      if ( tag->map && tag->map[8] != 75 && tag->attrid[tag->map[8]] )
      {
        if ( parsedtag_get_value(tag, 8, &w) )
        {
          if ( w <= 2 )
          {
            if ( w < 0 )
              w = 1;
          }
          else
          {
            w = 2;
          }
        }
        else
        {
          w = 1;
        }
      }
      if ( parsedtag_get_value(tag, 38, &i) )
      {
        if ( obuf->table_level )
        {
          if ( i < 0 )
            v69 = i;
          else
            v69 = (int)((long double)i / pixel_per_char);
          width = v69;
        }
        else
        {
          if ( i < 0 )
            v68 = i * (envs[h_env->envc].indent - h_env->limit) / 100;
          else
            v68 = (int)((long double)i / pixel_per_char);
          width = v68;
        }
      }
      if ( tag->map && tag->map[68] != 75 && tag->attrid[tag->map[68]] )
        w = 3;
      parsedtag_get_value(tag, 10, &x);
      parsedtag_get_value(tag, 9, &y);
      parsedtag_get_value(tag, 37, &z);
      parsedtag_get_value(tag, 20, &id);
      v70 = obuf->table_level;
      tables[v70] = begin_table(w, x, y, z);
      if ( id )
      {
        v71 = tables[obuf->table_level];
        v71->id = Strnew_charp(id);
      }
      table_mode_0[obuf->table_level].pre_mode = 0;
      table_mode_0[obuf->table_level].indent_level = 0;
      table_mode_0[obuf->table_level].nobr_level = 0;
      table_mode_0[obuf->table_level].caption = 0;
      table_mode_0[obuf->table_level].end_tag = 0;
      tables[obuf->table_level]->total_width = width;
      return 1;
    case 32:
      return 1;
    case 33:
      q = 0;
      p[0] = 0;
      parsedtag_get_value(tag, 19, p);
      parsedtag_get_value(tag, 15, &q);
      if ( p[0] && q && !strcasecmp(p[0], "Content-Type") && (q = (char *)strcasestr(q, "charset")) != 0 )
      {
        for ( q += 7; *q && (MYCTYPE_MAP[(unsigned __int8)*q] & 2) != 0; ++q )
          ;
        if ( *q == 61 )
        {
          ++q;
          while ( *q && (MYCTYPE_MAP[(unsigned __int8)*q] & 2) != 0 )
            ++q;
          meta_charset = wc_guess_charset(q, 0);
        }
      }
      else if ( p[0] && q && !strcasecmp(p[0], "refresh") )
      {
        tmp = 0;
        refresh_interval = getMetaRefreshParam(q, &tmp);
        if ( tmp )
        {
          q = html_quote(tmp->ptr);
          tmp = Sprintf("Refresh (%d sec) <a href=\"%s\">%s</a>", refresh_interval, q, q);
        }
        else if ( refresh_interval > 0 )
        {
          tmp = Sprintf("Refresh (%d sec)", refresh_interval);
        }
        if ( tmp )
        {
          HTMLlineproc0(tmp->ptr, h_env, 1);
          do_blankline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);
          if ( !is_redisplay && ((obuf->flag & 0x10000) == 0 || !RenderFrame) )
          {
            tag->need_reconstruct = 1;
            return 0;
          }
        }
      }
      return 1;
    case 35:
      r = 0;
      q = 0;
      parsedtag_get_value(tag, 31, &q);
      parsedtag_get_value(tag, 25, &r);
      if ( q )
      {
        q = html_quote(q);
        v45 = cur_hseq++;
        v46 = Sprintf("<a hseq=\"%d\" href=\"%s\">", v45, q);
        push_tag(obuf, v46->ptr, 1);
        if ( r )
          q = html_quote(r);
        v47 = strlen(q);
        v48 = q;
        v49 = wtf_strwidth((wc_uchar *)q);
        push_nchars(obuf, v49, v48, v47, 0);
        push_tag(obuf, "</a>", 2);
      }
      flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);
      return 0;
    case 36:
      if ( ++h_env->envc_real < h_env->nenv )
      {
        envs[++h_env->envc].env = cmd;
        envs[h_env->envc].count = 0;
        if ( h_env->envc > 10 )
          envs[h_env->envc].indent = envs[h_env->envc - 1].indent;
        else
          envs[h_env->envc].indent = envs[h_env->envc - 1].indent + IndentIncr;
      }
      push_nchars(obuf, 9, "--FRAME--", 9, 0);
      flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);
      return 0;
    case 37:
      if ( h_env->envc > 0 )
      {
        v39 = h_env->envc_real;
        v40 = v39 < h_env->nenv;
        h_env->envc_real = v39 - 1;
        if ( v40 )
          --h_env->envc;
        flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);
      }
      return 0;
    case 38:
      if ( (obuf->flag & 0x100) != 0 )
      {
        flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);
        if ( obuf->flag_sp > 0 )
        {
          obuf->flag &= 0xFFFFFF8F;
          v72 = obuf->flag;
          obuf->flag = obuf->flag_stack[--obuf->flag_sp] | v72;
        }
        v73 = obuf->flag;
        BYTE1(v73) &= 0xFEu;
        obuf->flag = v73;
      }
      close_anchor(h_env, obuf);
      if ( (obuf->flag & 0x2A0F) == 0 )
        flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);
      if ( obuf->flag_sp <= 9 )
      {
        v74 = obuf->flag_sp;
        obuf->flag_stack[v74] = obuf->flag & 0x70;
        obuf->flag_sp = v74 + 1;
      }
      obuf->flag &= 0xFFFFFF8F;
      obuf->flag |= 0x20u;
      return 1;
    case 39:
      if ( (obuf->flag & 0x100) != 0 )
      {
        flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);
        if ( obuf->flag_sp > 0 )
        {
          obuf->flag &= 0xFFFFFF8F;
          v75 = obuf->flag;
          obuf->flag = obuf->flag_stack[--obuf->flag_sp] | v75;
        }
        v76 = obuf->flag;
        BYTE1(v76) &= 0xFEu;
        obuf->flag = v76;
      }
      close_anchor(h_env, obuf);
      if ( (obuf->flag & 0xA0F) == 0 )
        flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);
      if ( obuf->flag_sp > 0 )
      {
        obuf->flag &= 0xFFFFFF8F;
        v77 = obuf->flag;
        obuf->flag = obuf->flag_stack[--obuf->flag_sp] | v77;
      }
      return 1;
    case 40:
    case 41:
    case 138:
      return 1;
    case 42:
      if ( (obuf->flag & 0x100) != 0 )
      {
        flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);
        if ( obuf->flag_sp > 0 )
        {
          obuf->flag &= 0xFFFFFF8F;
          v88 = obuf->flag;
          obuf->flag = obuf->flag_stack[--obuf->flag_sp] | v88;
        }
        v89 = obuf->flag;
        BYTE1(v89) &= 0xFEu;
        obuf->flag = v89;
      }
      close_anchor(h_env, obuf);
      if ( (obuf->flag & 0x2000) == 0 )
        flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);
      tmp = process_form(tag);
      if ( tmp )
        HTMLlineproc0(tmp->ptr, h_env, 1);
      return 1;
    case 43:
      if ( (obuf->flag & 0x100) != 0 )
      {
        flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);
        if ( obuf->flag_sp > 0 )
        {
          obuf->flag &= 0xFFFFFF8F;
          v90 = obuf->flag;
          obuf->flag = obuf->flag_stack[--obuf->flag_sp] | v90;
        }
        v91 = obuf->flag;
        BYTE1(v91) &= 0xFEu;
        obuf->flag = v91;
      }
      close_anchor(h_env, obuf);
      flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);
      v92 = obuf->flag;
      BYTE1(v92) |= 0x20u;
      obuf->flag = v92;
      process_n_form();
      return 1;
    case 44:
      close_anchor(h_env, obuf);
      tmp = process_input(tag);
      if ( tmp )
        HTMLlineproc0(tmp->ptr, h_env, 1);
      return 1;
    case 45:
      close_anchor(h_env, obuf);
      tmp = process_textarea(tag, h_env->limit);
      if ( tmp )
        HTMLlineproc0(tmp->ptr, h_env, 1);
      v95 = obuf->flag;
      BYTE1(v95) |= 8u;
      obuf->flag = v95;
      obuf->end_tag = 46;
      return 1;
    case 46:
      v96 = obuf->flag;
      BYTE1(v96) &= 0xF7u;
      obuf->flag = v96;
      obuf->end_tag = 0;
      tmp = process_n_textarea();
      if ( tmp )
        HTMLlineproc0(tmp->ptr, h_env, 1);
      return 1;
    case 47:
      close_anchor(h_env, obuf);
      tmp = process_select(tag);
      if ( tmp )
        HTMLlineproc0(tmp->ptr, h_env, 1);
      v93 = obuf->flag;
      BYTE1(v93) |= 0x10u;
      obuf->flag = v93;
      obuf->end_tag = 48;
      return 1;
    case 48:
      v94 = obuf->flag;
      BYTE1(v94) &= 0xEFu;
      obuf->flag = v94;
      obuf->end_tag = 0;
      tmp = process_n_select();
      if ( tmp )
        HTMLlineproc0(tmp->ptr, h_env, 1);
      return 1;
    case 49:
      return 1;
    case 50:
      v56 = obuf->flag;
      LOBYTE(v56) = v56 | 0x80;
      obuf->flag = v56;
      ++obuf->nobr_level;
      return 0;
    case 51:
      if ( obuf->nobr_level > 0 )
        --obuf->nobr_level;
      if ( !obuf->nobr_level )
      {
        v57 = obuf->flag;
        LOBYTE(v57) = v57 & 0x7F;
        obuf->flag = v57;
      }
      return 0;
    case 52:
      if ( (obuf->flag & 0x100) != 0 )
      {
        flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);
        if ( obuf->flag_sp > 0 )
        {
          obuf->flag &= 0xFFFFFF8F;
          v78 = obuf->flag;
          obuf->flag = obuf->flag_stack[--obuf->flag_sp] | v78;
        }
        v79 = obuf->flag;
        BYTE1(v79) &= 0xFEu;
        obuf->flag = v79;
      }
      close_anchor(h_env, obuf);
      if ( (obuf->flag & 0x2000) == 0 )
        flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);
      goto LABEL_385;
    case 53:
      if ( (obuf->flag & 0x100) != 0 )
      {
        flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);
        if ( obuf->flag_sp > 0 )
        {
          obuf->flag &= 0xFFFFFF8F;
          v80 = obuf->flag;
          obuf->flag = obuf->flag_stack[--obuf->flag_sp] | v80;
        }
        v81 = obuf->flag;
        BYTE1(v81) &= 0xFEu;
        obuf->flag = v81;
      }
      close_anchor(h_env, obuf);
      flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);
      if ( obuf->flag_sp > 0 )
      {
        obuf->flag &= 0xFFFFFF8F;
        v82 = obuf->flag;
        obuf->flag = obuf->flag_stack[--obuf->flag_sp] | v82;
      }
      return 1;
    case 54:
      p[0] = (char *)&line;
      q = "!CURRENT_URL!";
      parsedtag_get_value(tag, 27, p);
      parsedtag_get_value(tag, 3, &q);
      v97 = html_quote(p[0]);
      v98 = html_quote(q);
      tmp = Strnew_m_charp(
              "<form method=get action=\"",
              v98,
              "\">",
              v97,
              "<input type=text name=\"\" accept></form>",
              0);
      HTMLlineproc0(tmp->ptr, h_env, 1);
      return 1;
    case 55:
    case 56:
    case 57:
      return 0;
    case 58:
      obuf->flag |= 2u;
      obuf->end_tag = 59;
      return 1;
    case 59:
      obuf->flag &= 0xFFFFFFFD;
      obuf->end_tag = 0;
      return 1;
    case 60:
      p[0] = 0;
      if ( parsedtag_get_value(tag, 18, p) )
      {
        if ( !cur_baseURL )
          cur_baseURL = (ParsedURL *)GC_malloc(40);
        parseURL(p[0], cur_baseURL, 0);
      }
      return 0;
    case 61:
      switch ( displayInsDel )
      {
        case 1:
          HTMLlineproc0("<U>[DEL:</U>", h_env, 1);
          break;
        case 2:
          if ( ++obuf->fontstat[3] == 1 )
            push_tag(obuf, "<s>", 105);
          break;
        case 0:
          obuf->flag |= 0x100000u;
          break;
      }
      return 1;
    case 62:
      if ( displayInsDel == 1 )
      {
        HTMLlineproc0("<U>:DEL]</U>", h_env, 1);
      }
      else if ( displayInsDel != 2 )
      {
        if ( !displayInsDel )
          obuf->flag &= 0xFFEFFFFF;
        return 1;
      }
      if ( !obuf->fontstat[3] )
        return 1;
      if ( obuf->fontstat[3] == 1 && close_effect0(obuf, 105) )
        obuf->fontstat[3] = 0;
      if ( obuf->fontstat[3] > 0 && !--obuf->fontstat[3] )
        push_tag(obuf, "</s>", 106);
      return 1;
    case 63:
      if ( displayInsDel == 1 )
      {
        HTMLlineproc0("<U>[INS:</U>", h_env, 1);
      }
      else if ( displayInsDel == 2 && ++obuf->fontstat[4] == 1 )
      {
        push_tag(obuf, "<ins>", 63);
      }
      return 1;
    case 64:
      if ( displayInsDel == 1 )
      {
        HTMLlineproc0("<U>:INS]</U>", h_env, 1);
      }
      else if ( displayInsDel == 2 )
      {
        if ( !obuf->fontstat[4] )
          return 1;
        if ( obuf->fontstat[4] == 1 && close_effect0(obuf, 63) )
          obuf->fontstat[4] = 0;
        if ( obuf->fontstat[4] > 0 && !--obuf->fontstat[4] )
          push_tag(obuf, "</ins>", 64);
      }
      return 1;
    case 65:
      return ++obuf->fontstat[1] > 1;
    case 66:
      if ( obuf->fontstat[1] == 1 && close_effect0(obuf, 65) )
        obuf->fontstat[1] = 0;
      result = 1;
      if ( obuf->fontstat[1] > 0 && !--obuf->fontstat[1] )
        result = 0;
      return result;
    case 67:
      obuf->flag |= 4u;
      obuf->end_tag = 68;
      return 1;
    case 68:
      obuf->flag &= 0xFFFFFFFB;
      obuf->end_tag = 0;
      return 1;
    case 70:
      HTMLlineproc0("<i>", h_env, 1);
      return 1;
    case 71:
      HTMLlineproc0("</i>", h_env, 1);
      return 1;
    case 72:
      if ( view_unseenobject && parsedtag_get_value(tag, 7, p) )
      {
        q = html_quote(p[0]);
        s_2 = Sprintf("<IMG SRC=\"%s\" ALT=\"bg image(%s)\"><BR>", q, q);
        HTMLlineproc0(s_2->ptr, h_env, 1);
      }
      goto LABEL_560;
    case 73:
    case 95:
      return 1;
    case 91:
      if ( view_unseenobject && parsedtag_get_value(tag, 31, p) )
      {
        q = html_quote(p[0]);
        s = Sprintf("<A HREF=\"%s\">bgsound(%s)</A>", q, q);
        HTMLlineproc0(s->ptr, h_env, 1);
      }
      return 1;
    case 92:
      if ( view_unseenobject && parsedtag_get_value(tag, 6, p) )
      {
        q = html_quote(p[0]);
        s_1 = Sprintf("<A HREF=\"%s\">applet archive(%s)</A>", q, q);
        HTMLlineproc0(s_1->ptr, h_env, 1);
      }
      return 1;
    case 93:
      if ( view_unseenobject && parsedtag_get_value(tag, 31, p) )
      {
        q = html_quote(p[0]);
        s_0 = Sprintf("<A HREF=\"%s\">embed(%s)</A>", q, q);
        HTMLlineproc0(s_0->ptr, h_env, 1);
      }
      return 1;
    case 96:
LABEL_560:
      if ( (obuf->flag & 0x4000) != 0 )
        HTMLlineproc0("</title>", h_env, 1);
      return 1;
    case 98:
      if ( (obuf->flag & 0x100) != 0 )
      {
        flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);
        if ( obuf->flag_sp > 0 )
        {
          obuf->flag &= 0xFFFFFF8F;
          v41 = obuf->flag;
          obuf->flag = obuf->flag_stack[--obuf->flag_sp] | v41;
        }
        v42 = obuf->flag;
        BYTE1(v42) &= 0xFEu;
        obuf->flag = v42;
      }
      close_anchor(h_env, obuf);
      flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);
      obuf->flag |= 0x12000u;
      return 1;
    case 99:
      if ( (obuf->flag & 0x100) != 0 )
      {
        flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);
        if ( obuf->flag_sp > 0 )
        {
          obuf->flag &= 0xFFFFFF8F;
          v43 = obuf->flag;
          obuf->flag = obuf->flag_stack[--obuf->flag_sp] | v43;
        }
        v44 = obuf->flag;
        BYTE1(v44) &= 0xFEu;
        obuf->flag = v44;
      }
      close_anchor(h_env, obuf);
      flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);
      obuf->flag &= 0xFFFEFFFF;
      return 1;
    case 100:
      if ( (obuf->flag & 0x300000) == 0 )
        HTMLlineproc0("^", h_env, 1);
      return 1;
    case 101:
      return 1;
    case 102:
      if ( (obuf->flag & 0x300000) == 0 )
        HTMLlineproc0("[", h_env, 1);
      return 1;
    case 103:
      if ( (obuf->flag & 0x300000) == 0 )
        HTMLlineproc0("]", h_env, 1);
      return 1;
    case 105:
      switch ( displayInsDel )
      {
        case 1:
          HTMLlineproc0("<U>[S:</U>", h_env, 1);
          break;
        case 2:
          if ( ++obuf->fontstat[3] == 1 )
            push_tag(obuf, "<s>", 105);
          break;
        case 0:
          obuf->flag |= 0x200000u;
          break;
      }
      return 1;
    case 106:
      switch ( displayInsDel )
      {
        case 1:
          HTMLlineproc0("<U>:S]</U>", h_env, 1);
          break;
        case 2:
          if ( !obuf->fontstat[3] )
            return 1;
          if ( obuf->fontstat[3] == 1 && close_effect0(obuf, 105) )
            obuf->fontstat[3] = 0;
          if ( obuf->fontstat[3] > 0 && !--obuf->fontstat[3] )
            push_tag(obuf, "</s>", 106);
          break;
        case 0:
          obuf->flag &= 0xFFDFFFFF;
          break;
      }
      return 1;
    case 107:
      HTMLlineproc0("`", h_env, 1);
      return 1;
    case 108:
      HTMLlineproc0("'", h_env, 1);
      return 1;
    case 109:
      return ++obuf->fontstat[2] > 1;
    case 110:
      if ( obuf->fontstat[2] == 1 && close_effect0(obuf, 109) )
        obuf->fontstat[2] = 0;
      result = 1;
      if ( obuf->fontstat[2] > 0 && !--obuf->fontstat[2] )
        result = 0;
      return result;
    case 111:
      HTMLlineproc0("<b>", h_env, 1);
      return 1;
    case 112:
      HTMLlineproc0("</b>", h_env, 1);
      return 1;
    case 128:
      i = obuf->line->length;
      append_tags(obuf);
      if ( (obuf->flag & 0x28F) == 0 )
        set_breakpoint(obuf, obuf->line->length - i);
      v54 = obuf->flag;
      BYTE1(v54) |= 2u;
      obuf->flag = v54;
      return 0;
    case 129:
      push_tag(obuf, "</pre_int>", 129);
      v55 = obuf->flag;
      BYTE1(v55) &= 0xFDu;
      obuf->flag = v55;
      if ( (obuf->flag & 0x28F) == 0 && obuf->pos > obuf->bp.pos )
      {
        Strcopy_charp_n(obuf->prevchar, (char *)&line, 0);
        obuf->prev_ctype = 256;
      }
      return 1;
    case 130:
      if ( parsedtag_get_value(tag, 49, p) )
        h_env->title = html_unquote(p[0]);
      return 0;
    case 134:
      i = 0;
      if ( parsedtag_get_value(tag, 62, &i) && obuf->top_margin < i )
        obuf->top_margin = i;
      i = 0;
      if ( parsedtag_get_value(tag, 63, &i) && obuf->bottom_margin < i )
        obuf->bottom_margin = i;
      return 0;
    case 136:
      if ( parsedtag_get_value(tag, 31, p) )
        obuf->img_alt = Strnew_charp(p[0]);
      i = 0;
      if ( parsedtag_get_value(tag, 62, &i) && obuf->top_margin < i )
        obuf->top_margin = i;
      i = 0;
      if ( parsedtag_get_value(tag, 63, &i) && obuf->bottom_margin < i )
        obuf->bottom_margin = i;
      return 0;
    case 137:
      if ( obuf->img_alt )
      {
        if ( !close_effect0(obuf, 136) )
          push_tag(obuf, "</img_alt>", 137);
        obuf->img_alt = 0;
      }
      return 1;
    case 139:
      if ( (obuf->flag & 0x100) != 0 )
      {
        flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);
        if ( obuf->flag_sp > 0 )
        {
          obuf->flag &= 0xFFFFFF8F;
          v58 = obuf->flag;
          obuf->flag = obuf->flag_stack[--obuf->flag_sp] | v58;
        }
        v59 = obuf->flag;
        BYTE1(v59) &= 0xFEu;
        obuf->flag = v59;
      }
      close_anchor(h_env, obuf);
      if ( (obuf->flag & 0x2000) == 0 )
      {
        flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);
        do_blankline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);
      }
      obuf->flag |= 0x2001u;
      return 1;
    case 140:
      if ( (obuf->flag & 0x100) != 0 )
      {
        flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);
        if ( obuf->flag_sp > 0 )
        {
          obuf->flag &= 0xFFFFFF8F;
          v60 = obuf->flag;
          obuf->flag = obuf->flag_stack[--obuf->flag_sp] | v60;
        }
        v61 = obuf->flag;
        BYTE1(v61) &= 0xFEu;
        obuf->flag = v61;
      }
      close_anchor(h_env, obuf);
      if ( (obuf->flag & 0x2000) == 0 )
      {
        flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);
        do_blankline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);
        v62 = obuf->flag;
        BYTE1(v62) |= 0x20u;
        obuf->flag = v62;
      }
      obuf->flag &= 0xFFFFFFFE;
      return 1;
    case 143:
      if ( (obuf->flag & 0x100) != 0 )
      {
        flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);
        if ( obuf->flag_sp > 0 )
        {
          obuf->flag &= 0xFFFFFF8F;
          v83 = obuf->flag;
          obuf->flag = obuf->flag_stack[--obuf->flag_sp] | v83;
        }
        v84 = obuf->flag;
        BYTE1(v84) &= 0xFEu;
        obuf->flag = v84;
      }
      if ( (obuf->flag & 0x2000) == 0 )
        flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);
LABEL_385:
      set_alignment(obuf, tag);
      return 1;
    case 144:
      if ( (obuf->flag & 0x100) != 0 )
      {
        flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);
        if ( obuf->flag_sp > 0 )
        {
          obuf->flag &= 0xFFFFFF8F;
          v85 = obuf->flag;
          obuf->flag = obuf->flag_stack[--obuf->flag_sp] | v85;
        }
        v86 = obuf->flag;
        BYTE1(v86) &= 0xFEu;
        obuf->flag = v86;
      }
      flushline(h_env, obuf, envs[h_env->envc].indent, 0, h_env->limit);
      if ( obuf->flag_sp > 0 )
      {
        obuf->flag &= 0xFFFFFF8F;
        v87 = obuf->flag;
        obuf->flag = obuf->flag_stack[--obuf->flag_sp] | v87;
      }
      return 1;
    default:
      return 0;
  }
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);
// 804A36C: using guessed type int __cdecl strcasestr(_DWORD, _DWORD);

//----- (08069B8B) --------------------------------------------------------
Str textlist_feed()
{
  TextLine *p; // [esp+Ch] [ebp-4h]

  if ( !tl_lp2 )
    return 0;
  p = tl_lp2->ptr;
  tl_lp2 = tl_lp2->next;
  return p->line;
}

//----- (08069BBF) --------------------------------------------------------
int __cdecl ex_efct(int ex)
{
  int effect; // [esp+Ch] [ebp-4h]

  effect = 0;
  if ( !ex )
    return 0;
  if ( (ex & 1) != 0 )
    effect = 2;
  if ( (ex & 2) != 0 )
    effect |= 2u;
  if ( (ex & 4) != 0 )
    effect |= 4u;
  return effect;
}

//----- (08069C08) --------------------------------------------------------
void __cdecl HTMLlineproc2body(Buffer *buf, Str (*feed)(...), int llimit)
{
  Lineprop v3; // bx
  Lineprop *v4; // ebx
  __int16 v5; // si
  char *v6; // eax
  Lineprop v7; // ax
  Lineprop *v8; // ebx
  __int16 v9; // si
  char *v10; // eax
  Lineprop *v12; // ebx
  Lineprop *v13; // ebx
  Lineprop *v14; // ebx
  __int16 v15; // si
  char *v16; // eax
  Lineprop v17; // ax
  Lineprop *v18; // ebx
  __int16 v19; // si
  char *v20; // eax
  Lineprop *v22; // ebx
  Lineprop *v23; // ebx
  Lineprop *v24; // ebx
  __int16 v25; // si
  char *v26; // eax
  Lineprop v27; // ax
  Lineprop *v28; // ebx
  __int16 v29; // si
  char *v30; // eax
  wc_ces v32; // esi
  wc_ces v33; // ebx
  _Str *v34; // eax
  Str v35; // eax
  wc_ces v36; // esi
  wc_ces v37; // ebx
  _Str *v38; // eax
  Str v39; // eax
  wc_ces v40; // esi
  wc_ces v41; // ebx
  char *v42; // eax
  _Str *v43; // eax
  Str v44; // eax
  wc_ces v45; // esi
  wc_ces v46; // ebx
  _Str *v47; // eax
  Str v48; // eax
  wc_ces v49; // esi
  wc_ces v50; // ebx
  _Str *v51; // eax
  Str v52; // eax
  int v53; // ebx
  int v54; // eax
  BufferPoint *v55; // ebx
  frame_element *v56; // ebx
  int v57; // eax
  int v58; // eax
  int v59; // eax
  int v60; // ebx
  int v61; // eax
  wc_ces v62; // esi
  wc_ces v63; // ebx
  char *v64; // eax
  _Str *v65; // eax
  Str v66; // eax
  int v67; // eax
  Str v68; // eax
  char *v69; // eax
  __int16 v70; // ax
  __int16 v71; // ax
  __int16 v72; // ax
  ImageCache *v73; // eax
  int v74; // eax
  int v75; // ebx
  int v76; // eax
  __int16 v77; // ax
  int v78; // eax
  _Str *v79; // eax
  wc_ces v80; // esi
  wc_ces v81; // ebx
  char *v82; // eax
  _Str *v83; // eax
  Str v84; // eax
  int v85; // ebx
  wc_ces v86; // esi
  wc_ces v87; // ebx
  char *v88; // eax
  _Str *v89; // eax
  Str v90; // eax
  wc_ces v91; // esi
  wc_ces v92; // ebx
  _Str *v93; // eax
  Str v94; // eax
  wc_ces v95; // esi
  wc_ces v96; // ebx
  char *v97; // eax
  _Str *v98; // eax
  Str v99; // eax
  Str *v100; // ebx
  int v101; // eax
  _Str *v102; // ebx
  _Str *v103; // eax
  wc_ces v104; // esi
  wc_ces v105; // ebx
  _Str *v106; // eax
  Str v107; // eax
  wc_ces v108; // esi
  wc_ces v109; // ebx
  _Str *v110; // eax
  Str v111; // eax
  frame_element *v112; // ebx
  int v113; // eax
  FormList *v114; // eax
  int v115; // [esp+8h] [ebp-180h]
  int v116; // [esp+8h] [ebp-180h]
  int v117; // [esp+Ch] [ebp-17Ch]
  ParsedURL u; // [esp+5Ch] [ebp-12Ch] BYREF
  frameset *frameset_s[10]; // [esp+84h] [ebp-104h]
  int selected; // [esp+ACh] [ebp-DCh]
  FormItemList *item; // [esp+B0h] [ebp-D8h]
  FormItemList *item_0; // [esp+B4h] [ebp-D4h]
  int refresh_interval; // [esp+B8h] [ebp-D0h]
  int xoffset; // [esp+BCh] [ebp-CCh] BYREF
  frameset_element element; // [esp+C0h] [ebp-C8h]
  MapArea *a; // [esp+C4h] [ebp-C4h]
  MapList *m; // [esp+C8h] [ebp-C0h]
  int hpos; // [esp+CCh] [ebp-BCh]
  int yoffset; // [esp+D0h] [ebp-B8h] BYREF
  int top_0; // [esp+D4h] [ebp-B4h] BYREF
  int bottom; // [esp+D8h] [ebp-B0h] BYREF
  FormList *form; // [esp+DCh] [ebp-ACh]
  Anchor *a_0; // [esp+E0h] [ebp-A8h]
  BufferPoint *po; // [esp+E4h] [ebp-A4h]
  Image *image; // [esp+E8h] [ebp-A0h]
  int ismap; // [esp+ECh] [ebp-9Ch]
  int iseq; // [esp+F0h] [ebp-98h] BYREF
  int h; // [esp+F4h] [ebp-94h] BYREF
  int w; // [esp+F8h] [ebp-90h] BYREF
  int h_0; // [esp+FCh] [ebp-8Ch]
  parsed_tag *tag; // [esp+100h] [ebp-88h]
  int len_1; // [esp+104h] [ebp-84h]
  int len_0; // [esp+108h] [ebp-80h]
  int len; // [esp+10Ch] [ebp-7Ch]
  char **buf_0; // [esp+110h] [ebp-78h]
  Anchor **a_select; // [esp+114h] [ebp-74h]
  Anchor **a_textarea; // [esp+118h] [ebp-70h]
  int internal; // [esp+11Ch] [ebp-6Ch]
  char *endp; // [esp+120h] [ebp-68h]
  Str line; // [esp+124h] [ebp-64h]
  int form_id; // [esp+128h] [ebp-60h] BYREF
  int hseq; // [esp+12Ch] [ebp-5Ch] BYREF
  char *id; // [esp+130h] [ebp-58h] BYREF
  frameset_element *idFrame; // [esp+134h] [ebp-54h]
  int frameset_sp; // [esp+138h] [ebp-50h]
  int nlines; // [esp+13Ch] [ebp-4Ch]
  int pos; // [esp+140h] [ebp-48h]
  char *str; // [esp+144h] [ebp-44h] BYREF
  char *t; // [esp+148h] [ebp-40h] BYREF
  char *s; // [esp+14Ch] [ebp-3Ch] BYREF
  char *r; // [esp+150h] [ebp-38h] BYREF
  char *q; // [esp+154h] [ebp-34h] BYREF
  char *p; // [esp+158h] [ebp-30h] BYREF
  Anchor *a_form; // [esp+15Ch] [ebp-2Ch]
  Anchor *a_img; // [esp+160h] [ebp-28h]
  Anchor *a_href; // [esp+164h] [ebp-24h]
  Lineprop ex_effect; // [esp+168h] [ebp-20h]
  Lineprop effect; // [esp+16Ah] [ebp-1Eh]
  Lineprop mode; // [esp+16Ch] [ebp-1Ch]
  char symbol; // [esp+16Fh] [ebp-19h]

  a_href = 0;
  a_img = 0;
  a_form = 0;
  frameset_sp = -1;
  idFrame = 0;
  id = 0;
  symbol = 0;
  internal = 0;
  a_textarea = 0;
  a_select = 0;
  if ( !out_size_17965 )
  {
    out_size_17965 = 256;
    outc_17963 = (char *)GC_malloc_atomic(256);
    outp_17964 = (Lineprop *)GC_malloc_atomic(2 * out_size_17965);
  }
  n_textarea = -1;
  if ( !max_textarea )
  {
    max_textarea = 10;
    textarea_str = (Str *)GC_malloc(40);
    a_textarea = (Anchor **)GC_malloc(4 * max_textarea);
  }
  n_select = -1;
  if ( !max_select )
  {
    max_select = 10;
    select_option = (FormSelectOption *)GC_malloc(80);
    a_select = (Anchor **)GC_malloc(4 * max_select);
  }
  effect = 0;
  ex_effect = 0;
  nlines = 0;
LABEL_242:
  while ( 1 )
  {
    line = feed();
    if ( !line )
      break;
    if ( n_textarea < 0 || *line->ptr == 60 )
    {
      while ( ++nlines != llimit )
      {
        pos = 0;
        Strremovetrailingspaces(line);
        str = line->ptr;
        endp = &str[line->length];
        while ( str < endp )
        {
          if ( pos + 1 >= out_size_17965 )
          {
            out_size_17965 = 3 * pos / 2;
            outc_17963 = (char *)GC_realloc(outc_17963, 3 * pos / 2);
            outp_17964 = (Lineprop *)GC_realloc(outp_17964, 2 * out_size_17965);
          }
          mode = WTF_TYPE_MAP[(unsigned __int8)*str] << 8;
          v3 = effect;
          if ( ((v3 | (unsigned __int16)ex_efct(ex_effect)) & 0x8000) == 0 || *str == 60 )
          {
            if ( mode == 256 || mode == 0x2000 )
            {
              v12 = &outp_17964[pos];
              *v12 = ex_efct(ex_effect) | effect;
              outc_17963[pos++] = 32;
              ++str;
            }
            else if ( (mode & 0x1000) != 0 )
            {
              v13 = &outp_17964[pos];
              *v13 = ex_efct(ex_effect) | effect;
              outc_17963[pos++] = 32;
              str += WTF_LEN_MAP[(unsigned __int8)*str];
            }
            else if ( *str == 60 || *str == 38 )
            {
              if ( *str == 38 )
              {
                p = getescapecmd(&str);
                while ( *p )
                {
                  if ( pos + 1 >= out_size_17965 )
                  {
                    out_size_17965 = 3 * pos / 2;
                    outc_17963 = (char *)GC_realloc(outc_17963, 3 * pos / 2);
                    outp_17964 = (Lineprop *)GC_realloc(outp_17964, 2 * out_size_17965);
                  }
                  mode = WTF_TYPE_MAP[(unsigned __int8)*p] << 8;
                  if ( mode == 256 || mode == 0x2000 )
                  {
                    v22 = &outp_17964[pos];
                    *v22 = ex_efct(ex_effect) | effect;
                    outc_17963[pos++] = 32;
                    ++p;
                  }
                  else if ( (mode & 0x1000) != 0 )
                  {
                    v23 = &outp_17964[pos];
                    *v23 = ex_efct(ex_effect) | effect;
                    outc_17963[pos++] = 32;
                    p += WTF_LEN_MAP[(unsigned __int8)*p];
                  }
                  else
                  {
                    len_1 = WTF_LEN_MAP[(unsigned __int8)*p];
                    v24 = &outp_17964[pos];
                    v25 = mode | effect;
                    *v24 = v25 | ex_efct(ex_effect);
                    v26 = p;
                    outc_17963[pos] = *p;
                    p = v26 + 1;
                    ++pos;
                    if ( --len_1 )
                    {
                      LOBYTE(v27) = mode;
                      HIBYTE(v27) = HIBYTE(mode) & 0xF9 | 4;
                      mode = v27;
                      while ( len_1-- != 0 )
                      {
                        if ( pos + 1 >= out_size_17965 )
                        {
                          out_size_17965 = 3 * pos / 2;
                          outc_17963 = (char *)GC_realloc(outc_17963, 3 * pos / 2);
                          outp_17964 = (Lineprop *)GC_realloc(outp_17964, 2 * out_size_17965);
                        }
                        v28 = &outp_17964[pos];
                        v29 = mode | effect;
                        *v28 = v29 | ex_efct(ex_effect);
                        v30 = p;
                        outc_17963[pos] = *p;
                        p = v30 + 1;
                        ++pos;
                      }
                    }
                  }
                }
              }
              else
              {
                tag = parse_tag(&str, 1);
                if ( tag )
                {
                  switch ( tag->tagid )
                  {
                    case 1u:
                      if ( renderFrameSet )
                      {
                        if ( parsedtag_get_value(tag, 67, &p) )
                        {
                          v32 = buf->document_charset;
                          v33 = InnerCharset;
                          v34 = Strnew_charp(p);
                          v35 = wc_Str_conv_strict(v34, v33, v32);
                          p = url_quote(v35->ptr);
                          if ( !idFrame || strcmp(idFrame->element->name, p) )
                          {
                            idFrame = search_frame(renderFrameSet, p);
                            if ( idFrame )
                            {
                              if ( idFrame->element->attr != 1 )
                                idFrame = 0;
                            }
                          }
                        }
                      }
                      s = 0;
                      r = 0;
                      p = 0;
                      q = buf->baseTarget;
                      t = (char *)&::line;
                      hseq = 0;
                      id = 0;
                      if ( parsedtag_get_value(tag, 25, &id) )
                      {
                        v36 = buf->document_charset;
                        v37 = InnerCharset;
                        v38 = Strnew_charp(id);
                        v39 = wc_Str_conv_strict(v38, v37, v36);
                        id = url_quote(v39->ptr);
                        v115 = currentLn(buf);
                        registerName(buf, id, v115, pos);
                      }
                      if ( parsedtag_get_value(tag, 18, &p) )
                      {
                        v40 = buf->document_charset;
                        v41 = InnerCharset;
                        v42 = remove_space(p);
                        v43 = Strnew_charp(v42);
                        v44 = wc_Str_conv_strict(v43, v41, v40);
                        p = url_quote(v44->ptr);
                      }
                      if ( parsedtag_get_value(tag, 32, &q) )
                      {
                        v45 = buf->document_charset;
                        v46 = InnerCharset;
                        v47 = Strnew_charp(q);
                        v48 = wc_Str_conv_strict(v47, v46, v45);
                        q = url_quote(v48->ptr);
                      }
                      if ( parsedtag_get_value(tag, 71, &r) )
                      {
                        v49 = buf->document_charset;
                        v50 = InnerCharset;
                        v51 = Strnew_charp(r);
                        v52 = wc_Str_conv_strict(v51, v50, v49);
                        r = url_quote(v52->ptr);
                      }
                      parsedtag_get_value(tag, 49, &s);
                      parsedtag_get_value(tag, 50, &t);
                      parsedtag_get_value(tag, 69, &hseq);
                      if ( hseq <= 0 )
                      {
                        if ( hseq < 0 )
                        {
                          h_0 = ~hseq;
                          if ( buf->hmarklist )
                          {
                            if ( buf->hmarklist->nmark > h_0 && buf->hmarklist->marks[h_0].invalid )
                            {
                              buf->hmarklist->marks[h_0].pos = pos;
                              v55 = &buf->hmarklist->marks[h_0];
                              v55->line = currentLn(buf);
                              buf->hmarklist->marks[h_0].invalid = 0;
                              hseq = -hseq;
                            }
                          }
                        }
                      }
                      else
                      {
                        v53 = hseq - 1;
                        v54 = currentLn(buf);
                        buf->hmarklist = putHmarker(buf->hmarklist, v54, pos, v53);
                      }
                      if ( id && idFrame )
                      {
                        v56 = idFrame->element;
                        v57 = currentLn(buf);
                        v56[3].name = (char *)putAnchor(
                                                (AnchorList *)idFrame->element[3].name,
                                                id,
                                                0,
                                                0,
                                                0,
                                                0,
                                                0,
                                                v57,
                                                pos);
                      }
                      if ( p )
                      {
                        effect |= 0x10u;
                        v58 = currentLn(buf);
                        a_href = registerHref(buf, p, q, r, s, *t, v58, pos);
                        a_href->hseq = abs32(hseq) - 1;
                        a_href->slave = hseq <= 0;
                      }
                      break;
                    case 2u:
                      effect &= 0xFFEFu;
                      if ( a_href )
                      {
                        v59 = currentLn(buf);
                        a_href->end.line = v59;
                        a_href->end.pos = pos;
                        if ( a_href->start.line == a_href->end.line && a_href->start.pos == a_href->end.pos )
                        {
                          if ( buf->hmarklist && a_href->hseq < buf->hmarklist->nmark )
                            buf->hmarklist->marks[a_href->hseq].invalid = 1;
                          a_href->hseq = -1;
                        }
                        a_href = 0;
                      }
                      break;
                    case 7u:
                      effect |= 8u;
                      break;
                    case 8u:
                      effect &= 0xFFF7u;
                      break;
                    case 0x21u:
                      q = 0;
                      p = 0;
                      parsedtag_get_value(tag, 19, &p);
                      parsedtag_get_value(tag, 15, &q);
                      if ( p && q && !strcasecmp(p, "refresh") && MetaRefresh )
                      {
                        xoffset = 0;
                        refresh_interval = getMetaRefreshParam(q, (Str *)&xoffset);
                        if ( xoffset )
                        {
                          v95 = buf->document_charset;
                          v96 = InnerCharset;
                          v97 = remove_space(*(char **)xoffset);
                          v98 = Strnew_charp(v97);
                          v99 = wc_Str_conv_strict(v98, v96, v95);
                          p = url_quote(v99->ptr);
                          buf->event = setAlarmEvent(buf->event, refresh_interval, 3, 37, p);
                        }
                        else if ( refresh_interval > 0 )
                        {
                          buf->event = setAlarmEvent(buf->event, refresh_interval, 2, 112, 0);
                        }
                      }
                      break;
                    case 0x23u:
                      if ( frameset_sp >= 0 && frameset_sp <= 9 )
                      {
                        element.element = (frame_element *)newFrame(tag, buf);
                        addFrameSetElement(frameset_s[frameset_sp], element);
                      }
                      break;
                    case 0x24u:
                      if ( ++frameset_sp <= 9 )
                      {
                        v85 = frameset_sp;
                        frameset_s[v85] = newFrameSet(tag);
                        if ( frameset_s[frameset_sp] )
                        {
                          if ( frameset_sp )
                          {
                            addFrameSetElement(frameset_s[frameset_sp - 1], (frameset_element)frameset_s[frameset_sp]);
                          }
                          else if ( buf->frameset )
                          {
                            pushFrameTree(&buf->frameQ, frameset_s[frameset_sp], 0);
                          }
                          else
                          {
                            buf->frameset = frameset_s[frameset_sp];
                          }
                        }
                      }
                      break;
                    case 0x25u:
                      if ( frameset_sp >= 0 )
                        --frameset_sp;
                      break;
                    case 0x37u:
                      if ( parsedtag_get_value(tag, 25, &p) )
                      {
                        m = (MapList *)GC_malloc(12);
                        v79 = Strnew_charp(p);
                        m->name = v79;
                        m->area = newGeneralList();
                        m->next = buf->maplist;
                        buf->maplist = m;
                      }
                      break;
                    case 0x39u:
                      if ( buf->maplist && parsedtag_get_value(tag, 18, &p) )
                      {
                        v80 = buf->document_charset;
                        v81 = InnerCharset;
                        v82 = remove_space(p);
                        v83 = Strnew_charp(v82);
                        v84 = wc_Str_conv_strict(v83, v81, v80);
                        p = url_quote(v84->ptr);
                        t = 0;
                        parsedtag_get_value(tag, 32, &t);
                        q = (char *)&::line;
                        parsedtag_get_value(tag, 5, &q);
                        r = 0;
                        s = 0;
                        parsedtag_get_value(tag, 44, &r);
                        parsedtag_get_value(tag, 45, &s);
                        a = newMapArea(p, t, q, r, s);
                        pushValue(buf->maplist->area, a);
                      }
                      break;
                    case 0x3Cu:
                      if ( parsedtag_get_value(tag, 18, &p) )
                      {
                        v86 = buf->document_charset;
                        v87 = InnerCharset;
                        v88 = remove_space(p);
                        v89 = Strnew_charp(v88);
                        v90 = wc_Str_conv_strict(v89, v87, v86);
                        p = url_quote(v90->ptr);
                        if ( !buf->baseURL )
                          buf->baseURL = (ParsedURL *)GC_malloc(40);
                        parseURL(p, buf->baseURL, 0);
                      }
                      if ( parsedtag_get_value(tag, 32, &p) )
                      {
                        v91 = buf->document_charset;
                        v92 = InnerCharset;
                        v93 = Strnew_charp(p);
                        v94 = wc_Str_conv_strict(v93, v92, v91);
                        buf->baseTarget = url_quote(v94->ptr);
                      }
                      break;
                    case 0x3Fu:
                      ex_effect |= 2u;
                      break;
                    case 0x40u:
                      ex_effect &= 0xFFFDu;
                      break;
                    case 0x41u:
                      effect |= 2u;
                      break;
                    case 0x42u:
                      effect &= 0xFFFDu;
                      break;
                    case 0x68u:
                      addLink(buf, tag);
                      break;
                    case 0x69u:
                      ex_effect |= 4u;
                      break;
                    case 0x6Au:
                      ex_effect &= 0xFFFBu;
                      break;
                    case 0x6Du:
                      ex_effect |= 1u;
                      break;
                    case 0x6Eu:
                      ex_effect &= 0xFFFEu;
                      break;
                    case 0x78u:
                      if ( parsedtag_get_value(tag, 72, &n_select) && n_select < max_select )
                      {
                        select_option[n_select].first = 0;
                        select_option[n_select].last = 0;
                      }
                      else
                      {
                        n_select = -1;
                      }
                      break;
                    case 0x79u:
                      if ( n_select >= 0 )
                      {
                        item = (FormItemList *)a_select[n_select]->url;
                        item->select_option = select_option[n_select].first;
                        chooseSelectOption(item, item->select_option);
                        item->init_selected = item->selected;
                        item->init_value = item->value;
                        item->init_label = item->label;
                      }
                      break;
                    case 0x7Au:
                      if ( n_select >= 0 )
                      {
                        q = (char *)&::line;
                        parsedtag_get_value(tag, 42, &q);
                        p = q;
                        parsedtag_get_value(tag, 36, &p);
                        v101 = tag->map && tag->map[41] != 75 && tag->attrid[tag->map[41]];
                        selected = v101;
                        v102 = Strnew_charp(q);
                        v103 = Strnew_charp(p);
                        addSelectOption(&select_option[n_select], v103, v102, selected);
                      }
                      break;
                    case 0x7Bu:
                      if ( parsedtag_get_value(tag, 73, &n_textarea) && n_textarea < max_textarea )
                      {
                        v100 = &textarea_str[n_textarea];
                        *v100 = Strnew();
                      }
                      else
                      {
                        n_textarea = -1;
                      }
                      break;
                    case 0x7Cu:
                      if ( n_textarea >= 0 )
                      {
                        item_0 = (FormItemList *)a_textarea[n_textarea]->url;
                        item_0->value = textarea_str[n_textarea];
                        item_0->init_value = item_0->value;
                      }
                      break;
                    case 0x7Eu:
                      effect |= 0x8000u;
                      if ( parsedtag_get_value(tag, 33, &p) )
                        symbol = atoi(p);
                      break;
                    case 0x7Fu:
                      effect &= 0x7FFFu;
                      break;
                    case 0x82u:
                      if ( parsedtag_get_value(tag, 49, &p) )
                        buf->buffername = html_unquote(p);
                      break;
                    case 0x83u:
                      if ( parsedtag_get_value(tag, 65, &form_id) )
                        process_form_int(tag, form_id);
                      break;
                    case 0x86u:
                      bottom = 0;
                      top_0 = 0;
                      yoffset = -1;
                      xoffset = -1;
                      hseq = 0;
                      form_id = -1;
                      parsedtag_get_value(tag, 69, &hseq);
                      parsedtag_get_value(tag, 65, &form_id);
                      parsedtag_get_value(tag, 62, &bottom);
                      parsedtag_get_value(tag, 63, &top_0);
                      if ( form_id >= 0 && form_id <= form_max && forms )
                      {
                        form = forms[form_id];
                        if ( hseq > 0 )
                        {
                          hpos = pos;
                          if ( *str == 91 )
                            ++hpos;
                          v75 = hseq - 1;
                          v76 = currentLn(buf);
                          buf->hmarklist = putHmarker(buf->hmarklist, v76, hpos, v75);
                        }
                        if ( !form->target )
                          form->target = buf->baseTarget;
                        if ( a_textarea && parsedtag_get_value(tag, 73, &yoffset) && yoffset >= max_textarea )
                        {
                          max_textarea = 2 * yoffset;
                          textarea_str = (Str *)GC_realloc(textarea_str, 8 * yoffset);
                          a_textarea = (Anchor **)GC_realloc(a_textarea, 4 * max_textarea);
                        }
                        if ( a_select && parsedtag_get_value(tag, 72, &xoffset) && xoffset >= max_select )
                        {
                          max_select = 2 * xoffset;
                          select_option = (FormSelectOption *)GC_realloc(select_option, 16 * xoffset);
                          a_select = (Anchor **)GC_realloc(a_select, 4 * max_select);
                        }
                        v117 = currentLn(buf);
                        a_form = registerForm(buf, form, tag, v117, pos);
                        if ( a_textarea && yoffset >= 0 )
                          a_textarea[yoffset] = a_form;
                        if ( a_select && xoffset >= 0 )
                          a_select[xoffset] = a_form;
                        if ( !a_form )
                          goto LABEL_159;
                        a_form->hseq = hseq - 1;
                        v77 = currentLn(buf);
                        a_form->y = v77 - bottom;
                        a_form->rows = bottom + top_0 + 1;
                        if ( !tag->map || tag->map[70] == 75 || !tag->attrid[tag->map[70]] )
                          effect |= 0x40u;
                      }
                      break;
                    case 0x87u:
LABEL_159:
                      effect &= 0xFFBFu;
                      if ( a_form )
                      {
                        v78 = currentLn(buf);
                        a_form->end.line = v78;
                        a_form->end.pos = pos;
                        if ( a_form->start.line == a_form->end.line && a_form->start.pos == a_form->end.pos )
                          a_form->hseq = -1;
                      }
                      a_form = 0;
                      break;
                    case 0x88u:
                      if ( parsedtag_get_value(tag, 31, &p) )
                      {
                        w = -1;
                        h = -1;
                        iseq = 0;
                        ismap = 0;
                        xoffset = 0;
                        yoffset = 0;
                        top_0 = 0;
                        bottom = 0;
                        parsedtag_get_value(tag, 69, &iseq);
                        parsedtag_get_value(tag, 38, &w);
                        parsedtag_get_value(tag, 17, &h);
                        parsedtag_get_value(tag, 60, &xoffset);
                        parsedtag_get_value(tag, 61, &yoffset);
                        parsedtag_get_value(tag, 62, &top_0);
                        parsedtag_get_value(tag, 63, &bottom);
                        if ( tag->map && tag->map[46] != 75 && tag->attrid[tag->map[46]] )
                          ismap = 1;
                        q = 0;
                        parsedtag_get_value(tag, 34, &q);
                        if ( iseq > 0 )
                        {
                          v60 = iseq - 1;
                          v61 = currentLn(buf);
                          buf->imarklist = putHmarker(buf->imarklist, v61, pos, v60);
                        }
                        s = 0;
                        parsedtag_get_value(tag, 49, &s);
                        v62 = buf->document_charset;
                        v63 = InnerCharset;
                        v64 = remove_space(p);
                        v65 = Strnew_charp(v64);
                        v66 = wc_Str_conv_strict(v65, v63, v62);
                        p = url_quote(v66->ptr);
                        v67 = currentLn(buf);
                        a_img = registerImg(buf, p, s, v67, pos);
                        a_img->hseq = iseq;
                        a_img->image = 0;
                        if ( iseq <= 0 )
                        {
                          if ( iseq < 0 )
                          {
                            po = (BufferPoint *)((char *)buf->imarklist->marks - 12 - 12 * iseq);
                            a_0 = retrieveAnchor(buf->img, po->line, po->pos);
                            if ( a_0 )
                            {
                              a_img->url = a_0->url;
                              a_img->image = a_0->image;
                            }
                          }
                        }
                        else
                        {
                          parseURL2(a_img->url, &u, cur_baseURL);
                          image = (Image *)GC_malloc(36);
                          a_img->image = image;
                          v68 = parsedURL2Str(&u);
                          image->url = v68->ptr;
                          if ( !uncompressed_file_type(u.file, &image->ext) )
                          {
                            v69 = filename_extension(u.file, 1);
                            image->ext = v69;
                          }
                          image->cache = 0;
                          v70 = w;
                          if ( w > 2048 )
                            v70 = 2048;
                          image->width = v70;
                          v71 = h;
                          if ( h > 2048 )
                            v71 = 2048;
                          image->height = v71;
                          image->xoffset = xoffset;
                          image->yoffset = yoffset;
                          v72 = currentLn(buf);
                          image->y = v72 - top_0;
                          if ( image->xoffset < 0 && !pos )
                            image->xoffset = 0;
                          if ( image->yoffset < 0 && image->y == 1 )
                            image->yoffset = 0;
                          image->rows = top_0 + bottom + 1;
                          image->map = q;
                          image->ismap = ismap;
                          image->touch = 0;
                          v73 = getImage(image, cur_baseURL, 1);
                          image->cache = v73;
                        }
                      }
                      effect |= 0x20u;
                      break;
                    case 0x89u:
                      effect &= 0xFFDFu;
                      if ( a_img )
                      {
                        v74 = currentLn(buf);
                        a_img->end.line = v74;
                        a_img->end.pos = pos;
                      }
                      a_img = 0;
                      break;
                    case 0x8Du:
                      internal = 141;
                      break;
                    case 0x8Eu:
                      internal = 142;
                      break;
                    default:
                      break;
                  }
                  id = 0;
                  if ( parsedtag_get_value(tag, 20, &id) )
                  {
                    v104 = buf->document_charset;
                    v105 = InnerCharset;
                    v106 = Strnew_charp(id);
                    v107 = wc_Str_conv_strict(v106, v105, v104);
                    id = url_quote(v107->ptr);
                    v116 = currentLn(buf);
                    registerName(buf, id, v116, pos);
                  }
                  if ( renderFrameSet )
                  {
                    if ( parsedtag_get_value(tag, 67, &p) )
                    {
                      v108 = buf->document_charset;
                      v109 = InnerCharset;
                      v110 = Strnew_charp(p);
                      v111 = wc_Str_conv_strict(v110, v109, v108);
                      p = url_quote(v111->ptr);
                      if ( !idFrame || strcmp(idFrame->element->name, p) )
                      {
                        idFrame = search_frame(renderFrameSet, p);
                        if ( idFrame )
                        {
                          if ( idFrame->element->attr != 1 )
                            idFrame = 0;
                        }
                      }
                    }
                  }
                  if ( id && idFrame )
                  {
                    v112 = idFrame->element;
                    v113 = currentLn(buf);
                    v112[3].name = (char *)putAnchor(
                                             (AnchorList *)idFrame->element[3].name,
                                             id,
                                             0,
                                             0,
                                             0,
                                             0,
                                             0,
                                             v113,
                                             pos);
                  }
                }
              }
            }
            else
            {
              len_0 = WTF_LEN_MAP[(unsigned __int8)*str];
              v14 = &outp_17964[pos];
              v15 = mode | effect;
              *v14 = v15 | ex_efct(ex_effect);
              v16 = str;
              outc_17963[pos] = *str;
              str = v16 + 1;
              ++pos;
              if ( --len_0 )
              {
                LOBYTE(v17) = mode;
                HIBYTE(v17) = HIBYTE(mode) & 0xF9 | 4;
                mode = v17;
                while ( len_0-- != 0 )
                {
                  if ( pos + 1 >= out_size_17965 )
                  {
                    out_size_17965 = 3 * pos / 2;
                    outc_17963 = (char *)GC_realloc(outc_17963, 3 * pos / 2);
                    outp_17964 = (Lineprop *)GC_realloc(outp_17964, 2 * out_size_17965);
                  }
                  v18 = &outp_17964[pos];
                  v19 = mode | effect;
                  *v18 = v19 | ex_efct(ex_effect);
                  v20 = str;
                  outc_17963[pos] = *str;
                  str = v20 + 1;
                  ++pos;
                }
              }
            }
          }
          else
          {
            buf_0 = set_symbol(symbol_width0);
            p = buf_0[symbol];
            len = WTF_LEN_MAP[(unsigned __int8)*p];
            mode = WTF_TYPE_MAP[(unsigned __int8)*p] << 8;
            v4 = &outp_17964[pos];
            v5 = mode | effect;
            *v4 = v5 | ex_efct(ex_effect);
            v6 = p;
            outc_17963[pos] = *p;
            p = v6 + 1;
            ++pos;
            if ( --len )
            {
              LOBYTE(v7) = mode;
              HIBYTE(v7) = HIBYTE(mode) & 0xF9 | 4;
              mode = v7;
              while ( len-- != 0 )
              {
                if ( pos + 1 >= out_size_17965 )
                {
                  out_size_17965 = 3 * pos / 2;
                  outc_17963 = (char *)GC_realloc(outc_17963, 3 * pos / 2);
                  outp_17964 = (Lineprop *)GC_realloc(outp_17964, 2 * out_size_17965);
                }
                v8 = &outp_17964[pos];
                v9 = mode | effect;
                *v8 = v9 | ex_efct(ex_effect);
                v10 = p;
                outc_17963[pos] = *p;
                p = v10 + 1;
                ++pos;
              }
            }
            str += symbol_width;
          }
        }
        if ( !internal )
          addnewline(buf, outc_17963, outp_17964, 0, pos, -1, nlines);
        if ( internal == 142 )
          internal = 0;
        if ( str == endp )
          goto LABEL_242;
        line = Strsubstr(line, str - line->ptr, endp - str);
      }
      break;
    }
    savexmlstr_0(textarea_str[n_textarea], line);
  }
  for ( form_id = 1; form_id <= form_max; ++form_id )
    forms[form_id]->next = forms[form_id - 1];
  if ( form_max < 0 )
    v114 = 0;
  else
    v114 = forms[form_max];
  buf->formlist = v114;
  if ( n_textarea )
    addMultirowsForm(buf, buf->formitem);
  addMultirowsImg(buf, buf->img);
}
// 8049E6C: using guessed type int __cdecl GC_realloc(_DWORD, _DWORD);
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);
// 804A51C: using guessed type int __cdecl GC_malloc_atomic(_DWORD);

//----- (0806C0A4) --------------------------------------------------------
void __cdecl addLink(Buffer *buf, parsed_tag *tag)
{
  wc_ces v2; // esi
  wc_ces v3; // ebx
  char *v4; // eax
  _Str *v5; // eax
  Str v6; // eax
  LinkList *i; // [esp+10h] [ebp-28h]
  LinkList *l; // [esp+14h] [ebp-24h]
  char *rev; // [esp+18h] [ebp-20h] BYREF
  char *rel; // [esp+1Ch] [ebp-1Ch] BYREF
  char *ctype; // [esp+20h] [ebp-18h] BYREF
  char *title; // [esp+24h] [ebp-14h] BYREF
  char *href; // [esp+28h] [ebp-10h] BYREF
  char type; // [esp+2Fh] [ebp-9h]

  href = 0;
  title = 0;
  ctype = 0;
  rel = 0;
  rev = 0;
  type = 0;
  parsedtag_get_value(tag, 18, &href);
  if ( href )
  {
    v2 = buf->document_charset;
    v3 = InnerCharset;
    v4 = remove_space(href);
    v5 = Strnew_charp(v4);
    v6 = wc_Str_conv_strict(v5, v3, v2);
    href = url_quote(v6->ptr);
  }
  parsedtag_get_value(tag, 49, &title);
  parsedtag_get_value(tag, 33, &ctype);
  parsedtag_get_value(tag, 47, &rel);
  if ( rel )
  {
    type = 1;
    if ( !title )
      title = rel;
  }
  parsedtag_get_value(tag, 48, &rev);
  if ( rev )
  {
    type = 2;
    if ( !title )
      title = rev;
  }
  l = (LinkList *)GC_malloc(20);
  l->url = href;
  l->title = title;
  l->ctype = ctype;
  l->type = type;
  l->next = 0;
  if ( buf->linklist )
  {
    for ( i = buf->linklist; i->next; i = i->next )
      ;
    i->next = l;
  }
  else
  {
    buf->linklist = l;
  }
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (0806C24B) --------------------------------------------------------
void __cdecl HTMLlineproc2(Buffer *buf, TextLineList *tl)
{
  tl_lp2 = tl->first;
  HTMLlineproc2body(buf, (Str (*)(...))textlist_feed, -1);
}

//----- (0806C278) --------------------------------------------------------
Str file_feed()
{
  Str s; // [esp+1Ch] [ebp-Ch]

  s = StrISgets(file_lp2);
  if ( s->length )
    return s;
  ISclose(file_lp2);
  return 0;
}

//----- (0806C2B1) --------------------------------------------------------
void __cdecl HTMLlineproc3(Buffer *buf, InputStream stream)
{
  file_lp2 = stream;
  HTMLlineproc2body(buf, (Str (*)(...))file_feed, -1);
}

//----- (0806C2DC) --------------------------------------------------------
void __cdecl proc_escape(readbuffer *obuf, char **str_return)
{
  __int16 v2; // ax
  int v3; // eax
  int v4; // [esp+Ch] [ebp-3Ch]
  char *n_add; // [esp+28h] [ebp-20h]
  int width; // [esp+2Ch] [ebp-1Ch]
  signed int ech; // [esp+30h] [ebp-18h]
  char *estr; // [esp+34h] [ebp-14h]
  char *str; // [esp+38h] [ebp-10h]
  Lineprop mode; // [esp+3Eh] [ebp-Ah]

  str = *str_return;
  ech = getescapechar(str_return);
  n_add = (char *)(*str_return - str);
  if ( ech >= 0 )
  {
    if ( (MYCTYPE_MAP[(unsigned __int8)ech] & 1) != 0 )
      v2 = 256;
    else
      v2 = 0;
    mode = v2;
    estr = conv_entity(ech);
    check_breakpoint(obuf, obuf->flag & 0x28F, estr);
    width = wtf_strwidth((wc_uchar *)estr);
    if ( width != 1 || (unsigned __int8)*estr != ech || ech == 38 || ech == 60 || ech == 62 )
    {
      push_nchars(obuf, width, str, (int)n_add, mode);
    }
    else
    {
      if ( (MYCTYPE_MAP[(unsigned __int8)ech] & 1) != 0 )
        mode = 256;
      v4 = strlen(estr);
      push_nchars(obuf, 1, estr, v4, mode);
    }
    v3 = strlen(estr);
    Strcopy_charp_n(obuf->prevchar, estr, v3);
    obuf->prev_ctype = mode;
  }
  else
  {
    *str_return = str;
    proc_mchar(obuf, obuf->flag & 0x28F, 1, str_return, 0);
  }
}

//----- (0806C497) --------------------------------------------------------
int __cdecl need_flushline(html_feed_environ *h_env, readbuffer *obuf, Lineprop mode)
{
  int result; // eax
  char v4; // al

  if ( (obuf->flag & 0x200) != 0 )
    return obuf->pos > h_env->limit;
  if ( obuf->line->length <= 0 )
    v4 = 0;
  else
    v4 = obuf->line->ptr[obuf->line->length - 1];
  if ( v4 == 32 )
    result = 0;
  else
    result = obuf->pos > h_env->limit;
  return result;
}

//----- (0806C532) --------------------------------------------------------
int __cdecl table_width(html_feed_environ *h_env, int table_level)
{
  if ( table_level < 0 )
    return 0;
  if ( table_level <= 0 && tables[table_level]->total_width <= 0 )
    return h_env->limit - h_env->envs[h_env->envc].indent;
  return tables[table_level]->total_width;
}

//----- (0806C58D) --------------------------------------------------------
void __cdecl HTMLlineproc0(char *line, html_feed_environ *h_env, int internal)
{
  __int16 v3; // ax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // edx
  int v8; // edx
  _Str *v9; // eax
  int v10; // eax
  int v11; // edx
  int v12; // edx
  int v13; // eax
  int v14; // edx
  int i_0; // [esp+38h] [ebp-80h]
  char *tp_0; // [esp+3Ch] [ebp-7Ch]
  Str line_0; // [esp+40h] [ebp-78h]
  int i; // [esp+44h] [ebp-74h]
  char *tp; // [esp+48h] [ebp-70h]
  char *bp_0; // [esp+4Ch] [ebp-6Ch]
  char *p_1; // [esp+50h] [ebp-68h]
  int ech; // [esp+54h] [ebp-64h]
  char *p_0; // [esp+58h] [ebp-60h] BYREF
  int indent_1; // [esp+5Ch] [ebp-5Ch]
  int indent_0; // [esp+60h] [ebp-58h]
  table *tbl0; // [esp+64h] [ebp-54h]
  int end_tag; // [esp+68h] [ebp-50h]
  int pre_mode; // [esp+6Ch] [ebp-4Ch]
  int is_tag; // [esp+70h] [ebp-48h]
  char *p; // [esp+74h] [ebp-44h] BYREF
  char *str; // [esp+78h] [ebp-40h] BYREF
  int level; // [esp+7Ch] [ebp-3Ch]
  int prev_is_hangul; // [esp+80h] [ebp-38h]
  int is_hangul; // [esp+84h] [ebp-34h]
  int tbl_width; // [esp+88h] [ebp-30h]
  table_mode *tbl_mode; // [esp+8Ch] [ebp-2Ch]
  table *tbl; // [esp+90h] [ebp-28h]
  Str tokbuf; // [esp+94h] [ebp-24h]
  parsed_tag *tag; // [esp+98h] [ebp-20h]
  int delta; // [esp+9Ch] [ebp-1Ch]
  int indent; // [esp+A0h] [ebp-18h]
  readbuffer *obuf; // [esp+A4h] [ebp-14h]
  int cmd; // [esp+A8h] [ebp-10h]
  Lineprop mode; // [esp+ACh] [ebp-Ch]
  char ch_0; // [esp+AFh] [ebp-9h]

  obuf = h_env->obuf;
  tbl = 0;
  tbl_mode = 0;
  tbl_width = 0;
  prev_is_hangul = 0;
  tokbuf = Strnew();
table_start:
  if ( obuf->table_level >= 0 )
  {
    v3 = obuf->table_level;
    if ( v3 > 19 )
      v3 = 19;
    level = v3;
    tbl = tables[v3];
    tbl_mode = (table_mode *)(16 * v3 + 135776000);
    tbl_width = table_width(h_env, v3);
  }
LABEL_151:
  while ( *line )
  {
    is_tag = 0;
    if ( obuf->table_level < 0 )
      v4 = obuf->flag;
    else
      v4 = tbl_mode->pre_mode;
    pre_mode = v4;
    if ( obuf->table_level < 0 )
      v5 = obuf->end_tag;
    else
      v5 = tbl_mode->end_tag;
    end_tag = v5;
    if ( *line != 60 && !obuf->status )
    {
      read_token(tokbuf, &line, &obuf->status, pre_mode & 0xA0F, 0);
      if ( obuf->status )
        obuf->status = 0;
      str = tokbuf->ptr;
      goto LABEL_32;
    }
    if ( obuf->status == 7 )
    {
      obuf->status = 0;
    }
    else
    {
      read_token(h_env->tagbuf, &line, &obuf->status, pre_mode & 0xA0F, obuf->status != 0);
      if ( obuf->status )
        return;
    }
    if ( h_env->tagbuf->length )
    {
      str = h_env->tagbuf->ptr;
      if ( *str == 60 )
      {
        if ( str[1]
          && ((MYCTYPE_MAP[(unsigned __int8)str[1]] & 4) != 0
           || str[1] == 47
           || str[1] == 33
           || str[1] == 63
           || !str[1]
           || str[1] == 95) )
        {
          is_tag = 1;
        }
        else if ( (pre_mode & 0x580E) == 0 )
        {
          line = Strnew_m_charp(str + 1, line, 0)->ptr;
          str = "&lt;";
        }
      }
LABEL_32:
      if ( (pre_mode & 0x580E) == 0 )
        goto proc_normal;
      if ( is_tag )
      {
        p = str;
        tag = parse_tag(&p, internal);
        if ( tag )
        {
          if ( tag->tagid == end_tag
            || (pre_mode & 0x1000) != 0 && tag->tagid == 43
            || (pre_mode & 0x4000) != 0 && (tag->tagid == 96 || tag->tagid == 72) )
          {
            goto proc_normal;
          }
        }
      }
      if ( (pre_mode & 0x4000) != 0 )
      {
        feed_title(str);
      }
      else if ( (pre_mode & 0x1000) != 0 )
      {
        if ( obuf->table_level >= 0 )
        {
proc_normal:
          if ( obuf->table_level < 0 )
          {
LABEL_70:
            if ( is_tag )
            {
              tag = parse_tag(&str, internal);
              if ( tag )
              {
                cmd = tag->tagid;
                if ( HTMLtagproc1(tag, h_env) )
                {
                  process_idattr(obuf, cmd, tag);
                }
                else
                {
                  if ( tag->need_reconstruct )
                  {
                    v9 = parsedtag2str(tag);
                    h_env->tagbuf = v9;
                  }
                  push_tag(obuf, h_env->tagbuf->ptr, cmd);
                }
                obuf->bp.init_flag = 1;
                clear_ignore_p_flag(cmd, obuf);
                if ( cmd == 31 )
                  goto table_start;
              }
            }
            else if ( (obuf->flag & 0x300000) == 0 )
            {
              while ( 1 )
              {
                while ( 1 )
                {
                  while ( 1 )
                  {
                    if ( !*str )
                      goto LABEL_151;
                    mode = WTF_TYPE_MAP[(unsigned __int8)*str] << 8;
                    v10 = WcOption.use_wide ? WTF_WIDTH_MAP[(unsigned __int8)*str] : WTF_WIDTH_MAP[(unsigned __int8)*str] != 0;
                    delta = v10;
                    if ( (obuf->flag & 0x20F) != 0 )
                      break;
                    if ( (MYCTYPE_MAP[(unsigned __int8)*str] & 2) == 0 )
                    {
                      v14 = obuf->flag;
                      BYTE1(v14) &= 0xDFu;
                      obuf->flag = v14;
                    }
                    if ( (!mode || mode == 256) && (MYCTYPE_MAP[(unsigned __int8)*str] & 2) != 0 )
                    {
                      if ( *obuf->prevchar->ptr != 32 )
                        push_char(obuf, obuf->flag & 0x28F, 32);
                      ++str;
                    }
                    else
                    {
                      if ( mode == 2560 )
                        is_hangul = wtf_is_hangul((wc_uchar *)str);
                      else
                        is_hangul = 0;
                      if ( !SimplePreserveSpace
                        && mode == 2560
                        && !is_hangul
                        && !prev_is_hangul
                        && obuf->pos > h_env->envs[h_env->envc].indent
                        && obuf->line->length > 0
                        && obuf->line->ptr[obuf->line->length - 1] == 32 )
                      {
                        while ( obuf->line->length > 1
                             && !strncmp(&obuf->line->ptr[obuf->line->length - 2], "  ", 2u)
                             && obuf->pos >= h_env->envs[h_env->envc].indent )
                        {
                          Strshrink(obuf->line, 1);
                          --obuf->pos;
                        }
                        if ( obuf->line->length > 2
                          && obuf->prev_ctype == 2560
                          && obuf->line->length > 0
                          && obuf->line->ptr[obuf->line->length - 1] == 32
                          && obuf->pos >= h_env->envs[h_env->envc].indent )
                        {
                          Strshrink(obuf->line, 1);
                          --obuf->pos;
                        }
                      }
                      prev_is_hangul = is_hangul;
                      if ( *str == 38 )
                        proc_escape(obuf, &str);
                      else
                        proc_mchar(obuf, obuf->flag & 0x28F, delta, &str, mode);
                    }
LABEL_144:
                    if ( need_flushline(h_env, obuf, mode) )
                    {
                      bp_0 = &obuf->line->ptr[obuf->bp.len];
                      tp = &bp_0[-obuf->bp.tlen];
                      i = 0;
                      if ( obuf->line->ptr < tp && *(tp - 1) == 32 )
                        i = 1;
                      indent = h_env->envs[h_env->envc].indent;
                      if ( obuf->bp.pos - i > indent )
                      {
                        append_tags(obuf);
                        line_0 = Strnew_charp(bp_0);
                        Strshrink(obuf->line, obuf->line->length - obuf->bp.len);
                        back_to_breakpoint(obuf);
                        flushline(h_env, obuf, indent, 0, h_env->limit);
                        HTMLlineproc0(line_0->ptr, h_env, 1);
                      }
                    }
                  }
                  ch_0 = *str;
                  if ( (obuf->flag & 8) == 0 && *str == 38 )
                  {
                    p_0 = str;
                    ech = getescapechar(&p_0);
                    if ( ech == 10 || ech == 13 )
                    {
                      ch_0 = 10;
                      str = p_0 - 1;
                    }
                    else if ( ech == 9 )
                    {
                      ch_0 = 9;
                      str = p_0 - 1;
                    }
                  }
                  if ( ch_0 != 10 )
                  {
                    v11 = obuf->flag;
                    BYTE1(v11) &= 0xDFu;
                    obuf->flag = v11;
                  }
                  if ( ch_0 != 10 )
                    break;
                  ++str;
                  if ( (obuf->flag & 0x2000) == 0 )
                  {
                    if ( (obuf->flag & 0x200) != 0 )
                      push_char(obuf, obuf->flag & 0x28F, 32);
                    else
                      flushline(h_env, obuf, h_env->envs[h_env->envc].indent, 1, h_env->limit);
                    goto LABEL_110;
                  }
                  v12 = obuf->flag;
                  BYTE1(v12) &= 0xDFu;
                  obuf->flag = v12;
                }
                if ( ch_0 == 9 )
                {
                  do
                    push_char(obuf, obuf->flag & 0x28F, 32);
                  while ( (obuf->pos + h_env->envs[h_env->envc].indent) % Tabstop );
                  ++str;
                  goto LABEL_110;
                }
                if ( (obuf->flag & 8) != 0 )
                {
                  p_1 = HTML_QUOTE_MAP[QUOTE_MAP[(unsigned __int8)*str] & 7];
                  if ( !p_1 )
                    goto LABEL_109;
                  v13 = strlen(p_1);
                  push_nchars(obuf, 1, p_1, v13, 0);
                  ++str;
                }
                else
                {
                  if ( *str != 38 )
                  {
LABEL_109:
                    proc_mchar(obuf, 1, delta, &str, mode);
                    goto LABEL_110;
                  }
                  proc_escape(obuf, &str);
                }
LABEL_110:
                if ( (obuf->flag & 0x8F) == 0 )
                  goto LABEL_144;
              }
            }
          }
          else
          {
            v6 = feed_table(tbl, str, tbl_mode, tbl_width, internal);
            if ( v6 )
            {
              if ( v6 == 1 )
                goto LABEL_70;
            }
            else if ( --obuf->table_level <= 18 )
            {
              end_table(tbl);
              if ( obuf->table_level < 0 )
              {
                if ( (obuf->flag & 0x100000) == 0 )
                {
                  if ( tbl->vspace > 0 && (obuf->flag & 0x2000) == 0 )
                  {
                    indent_0 = h_env->envs[h_env->envc].indent;
                    flushline(h_env, obuf, indent_0, 0, h_env->limit);
                    do_blankline(h_env, obuf, indent_0, 0, h_env->limit);
                  }
                  save_fonteffect(h_env, obuf);
                  renderTable(tbl, tbl_width, h_env);
                  restore_fonteffect(h_env, obuf);
                  v7 = obuf->flag;
                  BYTE1(v7) &= 0xDFu;
                  obuf->flag = v7;
                  if ( tbl->vspace > 0 )
                  {
                    indent_1 = h_env->envs[h_env->envc].indent;
                    do_blankline(h_env, obuf, indent_1, 0, h_env->limit);
                    v8 = obuf->flag;
                    BYTE1(v8) |= 0x20u;
                    obuf->flag = v8;
                  }
                  Strcopy_charp_n(obuf->prevchar, " ", 1);
                }
              }
              else
              {
                tbl0 = tables[obuf->table_level];
                str = Sprintf("<table_alt tid=%d>", tbl0->ntable)->ptr;
                pushTable(tbl0, tbl);
                tbl = tbl0;
                tbl_mode = (table_mode *)(16 * obuf->table_level + 135776000);
                tbl_width = table_width(h_env, obuf->table_level);
                feed_table(tbl, str, tbl_mode, tbl_width, 1);
              }
            }
          }
        }
        else
        {
          feed_select(str);
        }
      }
      else
      {
        if ( is_tag )
        {
          if ( strncmp(str, "<!--", 4u) )
          {
            p = strchr(str + 1, 60);
            if ( p )
            {
              str = Strnew_charp_n(str, p - str)->ptr;
              line = Strnew_m_charp(p, line, 0)->ptr;
            }
          }
          is_tag = 0;
        }
        if ( obuf->table_level >= 0 )
          goto proc_normal;
        if ( (pre_mode & 0x800) != 0 )
        {
          feed_textarea(str);
        }
        else if ( (pre_mode & 2) == 0 && (pre_mode & 4) == 0 )
        {
          goto proc_normal;
        }
      }
    }
  }
  if ( (obuf->flag & 0x1A8F) == 0 )
  {
    i_0 = 0;
    if ( obuf->bp.pos == obuf->pos )
      tp_0 = &obuf->line->ptr[obuf->bp.len - obuf->bp.tlen];
    else
      tp_0 = &obuf->line->ptr[obuf->line->length];
    if ( obuf->line->ptr < tp_0 && *(tp_0 - 1) == 32 )
      i_0 = 1;
    indent = h_env->envs[h_env->envc].indent;
    if ( obuf->pos - i_0 > h_env->limit )
      flushline(h_env, obuf, indent, 0, h_env->limit);
  }
}

//----- (0806D554) --------------------------------------------------------
void __cdecl addnewline2(Buffer *buf, char *line, Lineprop *prop, Linecolor *color, int pos, int nlines)
{
  Line *l; // [esp+1Ch] [ebp-Ch]

  l = (Line *)GC_malloc(52);
  l->next = 0;
  l->lineBuf = line;
  l->propBuf = prop;
  l->colorBuf = color;
  l->len = pos;
  l->width = -1;
  l->size = pos;
  l->bpos = 0;
  l->bwidth = 0;
  l->prev = buf->currentLine;
  if ( buf->currentLine )
  {
    l->next = buf->currentLine->next;
    buf->currentLine->next = l;
  }
  else
  {
    l->next = 0;
  }
  if ( !buf->lastLine || buf->lastLine == buf->currentLine )
    buf->lastLine = l;
  buf->currentLine = l;
  if ( !buf->firstLine )
    buf->firstLine = l;
  l->linenumber = ++buf->allLine;
  if ( nlines >= 0 )
    l->real_linenumber = nlines;
  else
    l->real_linenumber = 0;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (0806D678) --------------------------------------------------------
void __cdecl addnewline(Buffer *buf, char *line, Lineprop *prop, Linecolor *color, int pos, int width, int nlines)
{
  int bwidth; // [esp+24h] [ebp-24h]
  int bpos; // [esp+28h] [ebp-20h]
  int i; // [esp+2Ch] [ebp-1Ch]
  Line *l; // [esp+30h] [ebp-18h]
  Linecolor *c; // [esp+34h] [ebp-14h]
  Lineprop *p; // [esp+38h] [ebp-10h]
  char *s; // [esp+3Ch] [ebp-Ch]

  if ( pos <= 0 )
  {
    s = NullLine;
    p = NullProp;
  }
  else
  {
    s = allocStr(line, pos);
    p = (Lineprop *)GC_malloc_atomic(2 * pos);
    bcopy(prop, p, 2 * pos);
  }
  if ( pos > 0 && color )
  {
    c = (Linecolor *)GC_malloc_atomic(pos);
    bcopy(color, c, pos);
  }
  else
  {
    c = 0;
  }
  addnewline2(buf, s, p, c, pos, nlines);
  if ( pos > 0 && width > 0 )
  {
    bpos = 0;
    bwidth = 0;
    while ( 1 )
    {
      l = buf->currentLine;
      l->bpos = bpos;
      l->bwidth = bwidth;
      i = columnLen(l, width);
      if ( !i )
      {
        for ( i = 1; l->len > i && (p[i] & 0x400) != 0; ++i )
          ;
      }
      l->len = i;
      l->width = calcPosition(l->lineBuf, l->propBuf, l->len, l->len, 0, 0);
      if ( pos <= i )
        break;
      bpos += l->len;
      bwidth += l->width;
      s += i;
      p += i;
      if ( c )
        c += i;
      pos -= i;
      addnewline2(buf, s, p, c, pos, nlines);
    }
  }
}
// 804A51C: using guessed type int __cdecl GC_malloc_atomic(_DWORD);

//----- (0806D888) --------------------------------------------------------
Buffer *__cdecl loadHTMLBuffer(URLFile *f, Buffer *newBuf)
{
  int v2; // eax
  int v3; // eax
  Str tmp; // [esp+18h] [ebp-10h]
  FILE *src; // [esp+1Ch] [ebp-Ch]

  src = 0;
  if ( !newBuf )
  {
    if ( showLineNum )
      v2 = 6;
    else
      v2 = 1;
    v3 = COLS - v2;
    if ( v3 < 0 )
      v3 = 0;
    newBuf = newBuffer(v3);
  }
  if ( !newBuf->sourcefile && (f->scheme != 4 || newBuf->mailcap) )
  {
    tmp = tmpfname(1, ".html");
    src = fopen(tmp->ptr, "w");
    if ( src )
      newBuf->sourcefile = tmp->ptr;
  }
  loadHTMLstream(f, newBuf, src, newBuf->bufferprop & 2);
  newBuf->topLine = newBuf->firstLine;
  newBuf->lastLine = newBuf->currentLine;
  newBuf->currentLine = newBuf->firstLine;
  if ( n_textarea )
    formResetBuffer(newBuf, newBuf->formitem);
  if ( src )
    fclose(src);
  return newBuf;
}

//----- (0806D9B9) --------------------------------------------------------
char *__cdecl convert_size(clen_t size, int usefloat)
{
  char *v2; // ebx
  long double v3; // fst7
  Str v4; // eax
  int sizepos; // [esp+28h] [ebp-10h]
  float csize; // [esp+2Ch] [ebp-Ch]

  sizepos = 0;
  csize = (float)size;
  while ( csize >= 999.495 && size_unit[sizepos + 1] )
  {
    csize = csize / 1024.0;
    ++sizepos;
  }
  v2 = size_unit[sizepos];
  v3 = floor(csize * 100.0 + 0.5) / 100.0;
  if ( usefloat )
    v4 = Sprintf("%.3g%s", (double)v3, v2);
  else
    v4 = Sprintf("%.0f%s", (double)v3, v2);
  return v4->ptr;
}

//----- (0806DA74) --------------------------------------------------------
char *__cdecl convert_size2(clen_t size1, clen_t size2, int usefloat)
{
  clen_t v3; // rax
  char *v4; // ebx
  long double v5; // fst7
  char *v6; // eax
  double v8; // [esp+20h] [ebp-38h]
  int sizepos; // [esp+40h] [ebp-18h]
  float factor; // [esp+44h] [ebp-14h]
  float csize; // [esp+48h] [ebp-10h]

  factor = 1.0;
  sizepos = 0;
  v3 = size2;
  if ( size2 < size1 )
    v3 = size1;
  while ( 1 )
  {
    csize = (float)v3;
    if ( csize / factor < 999.495 || !size_unit[sizepos + 1] )
      break;
    factor = factor * 1024.0;
    ++sizepos;
  }
  v4 = size_unit[sizepos];
  v8 = floor((long double)size2 / factor * 100.0 + 0.5) / 100.0;
  v5 = floor((long double)size1 / factor * 100.0 + 0.5) / 100.0;
  if ( usefloat )
    v6 = "%.3g/%.3g%s";
  else
    v6 = "%.0f/%.0f%s";
  return Sprintf(v6, (double)v5, v8, v4)->ptr;
}

//----- (0806DB9B) --------------------------------------------------------
void __cdecl showProgress(clen_t *linelen, clen_t *trbyte)
{
  clen_t v2; // rax
  char *v3; // [esp+8h] [ebp-70h]
  double ratio; // [esp+30h] [ebp-48h]
  const char *fmrate; // [esp+38h] [ebp-40h]
  const char *fmtrbyte; // [esp+3Ch] [ebp-3Ch]
  const char *fmtrbytea; // [esp+3Ch] [ebp-3Ch]
  Str messages; // [esp+40h] [ebp-38h]
  Str messagesa; // [esp+40h] [ebp-38h]
  time_t cur_time; // [esp+44h] [ebp-34h]
  time_t cur_timea; // [esp+44h] [ebp-34h]
  int rate; // [esp+54h] [ebp-24h]
  int j; // [esp+58h] [ebp-20h]
  int i; // [esp+5Ch] [ebp-1Ch]

  if ( fmInitialized && *linelen > 1023 )
  {
    if ( current_content_length <= 0 )
    {
      cur_timea = time(0);
      if ( !*trbyte )
      {
        move(LINES - 1, 0);
        clrtoeolx();
        start_time_20349 = cur_timea;
      }
      *trbyte += *linelen;
      *linelen = 0LL;
      if ( cur_timea != last_time_20348 )
      {
        last_time_20348 = cur_timea;
        move(LINES - 1, 0);
        fmtrbytea = convert_size(*trbyte, 1);
        if ( cur_timea == start_time_20349 )
        {
          messagesa = Sprintf("%7s loaded", fmtrbytea);
        }
        else
        {
          v3 = convert_size(*trbyte / (cur_timea - start_time_20349), 1);
          messagesa = Sprintf("%7s loaded %7s/s", fmtrbytea, v3);
        }
        message(messagesa->ptr, 0, 0);
        refresh();
      }
    }
    else
    {
      cur_time = time(0);
      if ( !*trbyte )
      {
        move(LINES - 1, 0);
        clrtoeolx();
        start_time_20349 = cur_time;
      }
      *trbyte += *linelen;
      *linelen = 0LL;
      if ( cur_time != last_time_20348 )
      {
        last_time_20348 = cur_time;
        move(LINES - 1, 0);
        ratio = (long double)*trbyte * 100.0 / (long double)current_content_length;
        fmtrbyte = convert_size2(*trbyte, current_content_length, 1);
        if ( cur_time == start_time_20349 )
        {
          messages = Sprintf("%11s %3.0f%%                          ", fmtrbyte, ratio);
        }
        else
        {
          rate = *trbyte / (cur_time - start_time_20349);
          fmrate = convert_size(rate, 1);
          if ( rate )
            v2 = (current_content_length - *trbyte) / rate;
          else
            LODWORD(v2) = -1;
          messages = Sprintf(
                       "%11s %3.0f%% %7s/s eta %02d:%02d:%02d     ",
                       fmtrbyte,
                       ratio,
                       fmrate,
                       (int)v2 / 3600,
                       (int)v2 / 60 % 60,
                       (int)v2 % 60);
        }
        addstr(messages->ptr);
        i = *trbyte * (COLS - 43) / current_content_length + 42;
        move(LINES - 1, 42);
        standout();
        addch(32);
        for ( j = 43; j <= i; ++j )
          addch(124);
        standend();
        refresh();
      }
    }
  }
}

//----- (0806E0B9) --------------------------------------------------------
void __cdecl init_henv(html_feed_environ *h_env, readbuffer *obuf, environment *envs, int nenv, TextLineList *buf, int limit, int indent)
{
  envs->indent = indent;
  obuf->line = Strnew();
  obuf->cprop = 0;
  obuf->pos = 0;
  obuf->prevchar = Strnew_size(8);
  Strcopy_charp_n(obuf->prevchar, " ", 1);
  obuf->flag = 0x2000;
  obuf->flag_sp = 0;
  obuf->status = 0;
  obuf->table_level = -1;
  obuf->nobr_level = 0;
  bzero(&obuf->anchor, 0x3Cu);
  obuf->img_alt = 0;
  obuf->fontstat[0] = 0;
  obuf->fontstat[2] = 0;
  obuf->fontstat[1] = 0;
  obuf->fontstat[3] = 0;
  obuf->fontstat[4] = 0;
  obuf->prev_ctype = 0;
  obuf->tag_sp = 0;
  obuf->fontstat_sp = 0;
  obuf->top_margin = 0;
  obuf->bottom_margin = 0;
  obuf->bp.init_flag = 1;
  set_breakpoint(obuf, 0);
  h_env->buf = buf;
  h_env->f = 0;
  h_env->obuf = obuf;
  h_env->tagbuf = Strnew();
  h_env->limit = limit;
  h_env->maxlimit = 0;
  h_env->envs = envs;
  h_env->nenv = nenv;
  h_env->envc = 0;
  h_env->envc_real = 0;
  h_env->title = 0;
  h_env->blank_lines = 0;
}

//----- (0806E26B) --------------------------------------------------------
void __cdecl completeHTMLstream(html_feed_environ *h_env, readbuffer *obuf)
{
  close_anchor(h_env, obuf);
  if ( obuf->img_alt )
  {
    push_tag(obuf, "</img_alt>", 137);
    obuf->img_alt = 0;
  }
  if ( obuf->fontstat[0] )
  {
    push_tag(obuf, "</b>", 8);
    obuf->fontstat[0] = 0;
  }
  if ( obuf->fontstat[2] )
  {
    push_tag(obuf, "</i>", 110);
    obuf->fontstat[2] = 0;
  }
  if ( obuf->fontstat[1] )
  {
    push_tag(obuf, "</u>", 66);
    obuf->fontstat[1] = 0;
  }
  if ( obuf->fontstat[3] )
  {
    push_tag(obuf, "</s>", 106);
    obuf->fontstat[3] = 0;
  }
  if ( obuf->fontstat[4] )
  {
    push_tag(obuf, "</ins>", 64);
    obuf->fontstat[4] = 0;
  }
  if ( (obuf->flag & 0x800) != 0 )
    HTMLlineproc0("</textarea>", h_env, 1);
  if ( (obuf->flag & 0x1000) != 0 )
    HTMLlineproc0("</select>", h_env, 1);
  if ( (obuf->flag & 0x4000) != 0 )
    HTMLlineproc0("</title>", h_env, 1);
  if ( obuf->table_level > 19 )
    obuf->table_level = 19;
  while ( obuf->table_level >= 0 )
  {
    table_mode_0[obuf->table_level].pre_mode &= 0xFFFFFFF1;
    HTMLlineproc0("</table>", h_env, 1);
  }
}

//----- (0806E4A4) --------------------------------------------------------
void __cdecl print_internal_information(html_feed_environ *henv)
{
  TextLine *v1; // eax
  char *v2; // eax
  TextLine *v3; // eax
  TextLine *v4; // eax
  const char *v5; // ebx
  char *v6; // esi
  char *v7; // eax
  char *v8; // eax
  TextLine *v9; // eax
  TextLine *v10; // eax
  _Str *v11; // eax
  TextLine *v12; // eax
  char *v13; // eax
  TextLine *v14; // eax
  TextLine *v15; // eax
  Str v16; // eax
  TextLineListItem *p; // [esp+1Ch] [ebp-1Ch]
  FormSelectOptionItem *ip_0; // [esp+20h] [ebp-18h]
  GeneralList *tl; // [esp+24h] [ebp-14h]
  _Str *s; // [esp+28h] [ebp-10h]
  _Str *sa; // [esp+28h] [ebp-10h]
  _Str *sb; // [esp+28h] [ebp-10h]
  _Str *sc; // [esp+28h] [ebp-10h]
  _Str *sd; // [esp+28h] [ebp-10h]
  _Str *se; // [esp+28h] [ebp-10h]
  _Str *sf; // [esp+28h] [ebp-10h]
  int i; // [esp+2Ch] [ebp-Ch]
  int ia; // [esp+2Ch] [ebp-Ch]

  tl = newGeneralList();
  s = Strnew_charp("<internal>");
  v1 = newTextLine(s, 0);
  pushValue(tl, v1);
  if ( henv->title )
  {
    v2 = html_quote(henv->title);
    sa = Strnew_m_charp("<title_alt title=\"", v2, "\">", 0);
    v3 = newTextLine(sa, 0);
    pushValue(tl, v3);
  }
  if ( n_select > 0 )
  {
    for ( i = 0; i < n_select; ++i )
    {
      sb = Sprintf("<select_int selectnumber=%d>", i);
      v4 = newTextLine(sb, 0);
      pushValue(tl, v4);
      for ( ip_0 = select_option[i].first; ip_0; ip_0 = ip_0->next )
      {
        if ( ip_0->checked )
          v5 = " selected";
        else
          v5 = &line;
        v6 = html_quote(ip_0->label->ptr);
        if ( ip_0->value )
          v7 = ip_0->value->ptr;
        else
          v7 = ip_0->label->ptr;
        v8 = html_quote(v7);
        sc = Sprintf("<option_int value=\"%s\" label=\"%s\"%s>", v8, v6, v5);
        v9 = newTextLine(sc, 0);
        pushValue(tl, v9);
      }
      sd = Strnew_charp("</select_int>");
      v10 = newTextLine(sd, 0);
      pushValue(tl, v10);
    }
  }
  if ( n_textarea > 0 )
  {
    for ( ia = 0; ia < n_textarea; ++ia )
    {
      v11 = Sprintf("<textarea_int textareanumber=%d>", ia);
      v12 = newTextLine(v11, 0);
      pushValue(tl, v12);
      v13 = html_quote(textarea_str[ia]->ptr);
      se = Strnew_charp(v13);
      Strcat_charp(se, "</textarea_int>");
      v14 = newTextLine(se, 0);
      pushValue(tl, v14);
    }
  }
  sf = Strnew_charp("</internal>");
  v15 = newTextLine(sf, 0);
  pushValue(tl, v15);
  if ( henv->buf )
  {
    appendGeneralList((GeneralList *)henv->buf, tl);
  }
  else if ( henv->f )
  {
    for ( p = (TextLineListItem *)tl->first; p; p = p->next )
    {
      if ( ExtHalfdump )
        v16 = wc_Str_conv(p->ptr->line, InnerCharset, DisplayCharset);
      else
        v16 = p->ptr->line;
      fprintf(henv->f, "%s\n", v16->ptr);
    }
  }
}

//----- (0806E813) --------------------------------------------------------
void __cdecl loadHTMLstream(URLFile *f, Buffer *newBuf, FILE *src, int internal)
{
  int v4; // eax
  char *v5; // eax
  readbuffer obuf; // [esp+28h] [ebp-2F0h] BYREF
  environment envs[20]; // [esp+178h] [ebp-1A0h] BYREF
  html_feed_environ htmlenv1; // [esp+2B8h] [ebp-60h] BYREF
  clen_t trbyte; // [esp+2E8h] [ebp-30h] BYREF
  clen_t linelen; // [esp+2F0h] [ebp-28h] BYREF
  void (*prevtrap)(int); // [esp+2FCh] [ebp-1Ch]
  int image_flag; // [esp+300h] [ebp-18h]
  wc_ces doc_charset; // [esp+304h] [ebp-14h]
  wc_ces charset; // [esp+308h] [ebp-10h] BYREF
  Str lineBuf2; // [esp+30Ch] [ebp-Ch]

  linelen = 0LL;
  trbyte = 0LL;
  lineBuf2 = Strnew();
  charset = 256;
  doc_charset = DocumentCharset;
  prevtrap = 0;
  if ( fmInitialized && graph_ok() )
  {
    symbol_width0 = 1;
    symbol_width = 1;
  }
  else
  {
    symbol_width0 = 0;
    get_symbol(DisplayCharset, &symbol_width0);
    if ( WcOption.use_wide )
      v4 = symbol_width0;
    else
      v4 = 1;
    symbol_width = v4;
  }
  cur_title = 0;
  n_textarea = 0;
  cur_textarea = 0;
  max_textarea = 10;
  textarea_str = (Str *)GC_malloc(40);
  n_select = 0;
  max_select = 10;
  select_option = (FormSelectOption *)GC_malloc(80);
  cur_select = 0;
  form_sp = -1;
  form_max = -1;
  forms_size = 0;
  forms = 0;
  cur_hseq = 1;
  cur_iseq = 1;
  if ( newBuf->image_flag )
  {
    image_flag = newBuf->image_flag;
  }
  else if ( activeImage && displayImage && autoImage )
  {
    image_flag = 2;
  }
  else
  {
    image_flag = 1;
  }
  if ( newBuf->currentURL.file )
    cur_baseURL = baseURL(newBuf);
  if ( w3m_halfload )
  {
    newBuf->buffername = "---";
    newBuf->document_charset = InnerCharset;
    max_textarea = 0;
    max_select = 0;
    HTMLlineproc3(newBuf, f->stream);
    w3m_halfload = 0;
    return;
  }
  init_henv(&htmlenv1, &obuf, envs, 20, 0, newBuf->width, 0);
  if ( (w3m_dump & 0x10) != 0 )
    htmlenv1.f = stdout;
  else
    htmlenv1.buf = (TextLineList *)newGeneralList();
  if ( __sigsetjmp(AbortLoading, 1) )
  {
    HTMLlineproc0("<br>Transfer Interrupted!<br>", &htmlenv1, 1);
phase2:
    newBuf->trbyte = trbyte + linelen;
    if ( TrapSignal )
    {
      if ( fmInitialized )
        term_raw();
      if ( prevtrap )
        mySignal(2, prevtrap);
    }
    if ( (newBuf->bufferprop & 2) == 0 )
      newBuf->document_charset = charset;
    newBuf->image_flag = image_flag;
    HTMLlineproc2(newBuf, htmlenv1.buf);
    return;
  }
  if ( TrapSignal )
  {
    prevtrap = mySignal(2, KeyAbort);
    if ( fmInitialized )
      term_cbreak();
  }
  if ( newBuf )
  {
    if ( (newBuf->bufferprop & 2) != 0 )
    {
      charset = InnerCharset;
    }
    else if ( newBuf->document_charset )
    {
      doc_charset = newBuf->document_charset;
      charset = doc_charset;
    }
  }
  if ( content_charset && UseContentCharset )
  {
    doc_charset = content_charset;
  }
  else if ( f->guess_type && !strcasecmp(f->guess_type, "application/xhtml+xml") )
  {
    doc_charset = 3178565;
  }
  meta_charset = 0;
  if ( f->stream->base.type != 4 )
    f->stream = newEncodedStream(f->stream, f->encoding);
  while ( 1 )
  {
    lineBuf2 = StrmyISgets(f->stream);
    if ( !lineBuf2->length )
      break;
    if ( f->scheme == 9 && *lineBuf2->ptr == 46 )
    {
      Strdelete(lineBuf2, 0, 1);
      if ( *lineBuf2->ptr == 10 || *lineBuf2->ptr == 13 || !*lineBuf2->ptr )
        break;
    }
    if ( src )
      fwrite(lineBuf2->ptr, 1u, lineBuf2->length, src);
    linelen += lineBuf2->length;
    if ( (w3m_dump & 8) != 0 )
    {
      v5 = convert_size2(linelen, current_content_length, 1);
      printf("W3m-in-progress: %s\n", v5);
    }
    if ( (w3m_dump & 4) == 0 )
    {
      showProgress(&linelen, &trbyte);
      if ( meta_charset )
      {
        if ( !content_charset && UseContentCharset )
        {
          doc_charset = meta_charset;
          charset = 256;
        }
        meta_charset = 0;
      }
      lineBuf2 = convertLine(f, lineBuf2, 2, &charset, doc_charset);
      cur_document_charset[0] = charset;
      HTMLlineproc0(lineBuf2->ptr, &htmlenv1, internal);
    }
  }
  if ( obuf.status )
  {
    obuf.status = 7;
    HTMLlineproc0("\n", &htmlenv1, internal);
  }
  obuf.status = 0;
  completeHTMLstream(&htmlenv1, &obuf);
  flushline(&htmlenv1, &obuf, 0, 2, htmlenv1.limit);
  if ( htmlenv1.title )
    newBuf->buffername = htmlenv1.title;
  if ( (w3m_dump & 0x10) != 0 )
  {
    if ( TrapSignal )
    {
      if ( fmInitialized )
        term_raw();
      if ( prevtrap )
        mySignal(2, prevtrap);
    }
    print_internal_information(&htmlenv1);
  }
  else
  {
    if ( !w3m_backend )
      goto phase2;
    if ( TrapSignal )
    {
      if ( fmInitialized )
        term_raw();
      if ( prevtrap )
        mySignal(2, prevtrap);
    }
    print_internal_information(&htmlenv1);
    backend_halfdump_buf = htmlenv1.buf;
  }
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (0806EF44) --------------------------------------------------------
Buffer *__cdecl loadHTMLString(Str page)
{
  int v1; // eax
  int v2; // eax
  Buffer *result; // eax
  input_stream *v4; // eax
  URLFile f; // [esp+18h] [ebp-30h] BYREF
  Buffer *newBuf; // [esp+38h] [ebp-10h]
  void (*prevtrap)(int); // [esp+3Ch] [ebp-Ch]

  prevtrap = 0;
  if ( showLineNum )
    v1 = 6;
  else
    v1 = 1;
  v2 = COLS - v1;
  if ( v2 < 0 )
    v2 = 0;
  newBuf = newBuffer(v2);
  if ( __sigsetjmp(AbortLoading, 1) )
  {
    if ( TrapSignal )
    {
      if ( fmInitialized )
        term_raw();
    }
    discardBuffer(newBuf);
    result = 0;
  }
  else
  {
    if ( TrapSignal )
    {
      prevtrap = mySignal(2, KeyAbort);
      if ( fmInitialized )
        term_cbreak();
    }
    v4 = newStrStream(page);
    init_stream(&f, 4, v4);
    newBuf->document_charset = InnerCharset;
    loadHTMLstream(&f, newBuf, 0, 1);
    newBuf->document_charset = 256;
    if ( TrapSignal )
    {
      if ( fmInitialized )
        term_raw();
      if ( prevtrap )
        mySignal(2, prevtrap);
    }
    newBuf->topLine = newBuf->firstLine;
    newBuf->lastLine = newBuf->currentLine;
    newBuf->currentLine = newBuf->firstLine;
    newBuf->type = "text/html";
    newBuf->real_type = newBuf->type;
    if ( n_textarea )
      formResetBuffer(newBuf, newBuf->formitem);
    result = newBuf;
  }
  return result;
}
// 806EFBF: conditional instruction was optimized away because of '%prevtrap.4==0'

//----- (0806F10D) --------------------------------------------------------
Str __cdecl loadGopherDir(URLFile *uf, ParsedURL *pu, wc_ces *charset)
{
  char *v3; // eax
  _Str *v4; // eax
  Str v5; // eax
  char *v6; // edx
  int v7; // eax
  char *v8; // ebx
  wc_ces v9; // edi
  _Str *v10; // eax
  Str v11; // eax
  char *v12; // eax
  char *v13; // eax
  wc_ces t_ces; // [esp+2Ch] [ebp-4Ch]
  wc_ces doc_charset; // [esp+38h] [ebp-40h]
  void (*prevtrap)(int); // [esp+3Ch] [ebp-3Ch]
  char *volatile q; // [esp+40h] [ebp-38h]
  char *volatile qa; // [esp+40h] [ebp-38h]
  char *volatile qb; // [esp+40h] [ebp-38h]
  char *volatile qc; // [esp+40h] [ebp-38h]
  char *volatile qd; // [esp+40h] [ebp-38h]
  char *pe; // [esp+44h] [ebp-34h]
  char *volatile p; // [esp+44h] [ebp-34h]
  char *pa; // [esp+44h] [ebp-34h]
  char *pb; // [esp+44h] [ebp-34h]
  char *pc; // [esp+44h] [ebp-34h]
  char *volatile pd; // [esp+44h] [ebp-34h]
  Str port; // [esp+48h] [ebp-30h]
  Str host; // [esp+4Ch] [ebp-2Ch]
  Str file; // [esp+50h] [ebp-28h]
  Str name; // [esp+54h] [ebp-24h]
  _Str *lbuf; // [esp+58h] [ebp-20h]
  Str tmpa; // [esp+5Ch] [ebp-1Ch]
  _Str *tmp; // [esp+5Ch] [ebp-1Ch]

  prevtrap = 0;
  doc_charset = DocumentCharset;
  tmpa = parsedURL2Str(pu);
  pe = html_quote(tmpa->ptr);
  v3 = file_unquote(tmpa->ptr);
  v4 = Strnew_charp(v3);
  v5 = convertLine(0, v4, 0, charset, doc_charset);
  v6 = html_quote(v5->ptr);
  tmp = Strnew_m_charp(
          "<html>\n<head>\n<base href=\"",
          pe,
          "\">\n<title>",
          v6,
          "</title>\n</head>\n<body>\n<h1>Index of ",
          v6,
          "</h1>\n<table>\n",
          0);
  if ( !__sigsetjmp(AbortLoading, 1) )
  {
    if ( TrapSignal )
    {
      prevtrap = mySignal(2, KeyAbort);
      if ( fmInitialized )
        term_cbreak();
    }
    while ( 1 )
    {
      while ( 1 )
      {
        lbuf = StrISgets(uf->stream);
        if ( !lbuf->length || *lbuf->ptr == 46 && (lbuf->ptr[1] == 10 || lbuf->ptr[1] == 13) )
          goto gopher_end;
        p = convertLine(uf, lbuf, 2, charset, doc_charset)->ptr;
        for ( q = p; *q && *q != 9; ++q )
          ;
        name = Strnew_charp_n(p, q - p);
        if ( *q )
        {
          pa = q + 1;
          for ( qa = q + 1; *qa && *qa != 9; ++qa )
            ;
          file = Strnew_charp_n(pa, qa - pa);
          if ( *qa )
          {
            pb = qa + 1;
            for ( qb = qa + 1; *qb && *qb != 9; ++qb )
              ;
            host = Strnew_charp_n(pb, qb - pb);
            if ( *qb )
              break;
          }
        }
      }
      pc = qb + 1;
      for ( qc = qb + 1; *qc && *qc != 9 && *qc != 13 && *qc != 10; ++qc )
        ;
      port = Strnew_charp_n(pc, qc - pc);
      v7 = *name->ptr;
      if ( v7 == 103 )
      {
        pd = "[gif]";
        goto LABEL_46;
      }
      if ( v7 > 103 )
      {
        switch ( v7 )
        {
          case 'm':
            pd = "[message]";
            goto LABEL_46;
          case 's':
            pd = "[sound]";
            goto LABEL_46;
          case 'h':
            pd = "[HTML]";
            goto LABEL_46;
        }
      }
      else
      {
        if ( v7 == 48 )
        {
          pd = "[text file]";
          goto LABEL_46;
        }
        if ( v7 == 49 )
        {
          pd = "[directory]";
          goto LABEL_46;
        }
      }
      pd = "[unsupported]";
LABEL_46:
      qd = Strnew_m_charp("gopher://", host->ptr, ":", port->ptr, "/", file->ptr, 0)->ptr;
      v8 = html_quote(name->ptr + 1);
      t_ces = *charset;
      v9 = InnerCharset;
      v10 = Strnew_charp(qd);
      v11 = wc_Str_conv_strict(v10, v9, t_ces);
      v12 = url_quote(v11->ptr);
      v13 = html_quote(v12);
      Strcat_m_charp(tmp, "<a href=\"", v13, "\">", pd, v8, "</a>\n", 0);
    }
  }
gopher_end:
  if ( TrapSignal )
  {
    if ( fmInitialized )
      term_raw();
    if ( prevtrap )
      mySignal(2, prevtrap);
  }
  Strcat_charp(tmp, "</table>\n</body>\n</html>\n");
  return tmp;
}

//----- (0806F5A5) --------------------------------------------------------
Buffer *__cdecl loadBuffer(URLFile *uf, Buffer *volatile newBuf)
{
  int v2; // eax
  int v3; // eax
  char *v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  clen_t trbyte; // [esp+28h] [ebp-50h] BYREF
  clen_t linelen; // [esp+30h] [ebp-48h] BYREF
  void (*prevtrap)(int); // [esp+38h] [ebp-40h]
  Linecolor *colorBuffer; // [esp+3Ch] [ebp-3Ch]
  Lineprop *propBuffer; // [esp+40h] [ebp-38h] BYREF
  Str tmpf; // [esp+44h] [ebp-34h]
  int nlines; // [esp+48h] [ebp-30h]
  Str lineBuf2; // [esp+4Ch] [ebp-2Ch]
  wc_ces doc_charset; // [esp+50h] [ebp-28h]
  wc_ces charset; // [esp+54h] [ebp-24h] BYREF
  FILE *src; // [esp+58h] [ebp-20h]
  char pre_lbuf; // [esp+5Fh] [ebp-19h]

  src = 0;
  charset = 256;
  doc_charset = DocumentCharset;
  pre_lbuf = 0;
  linelen = 0LL;
  trbyte = 0LL;
  propBuffer = 0;
  colorBuffer = 0;
  prevtrap = 0;
  if ( !newBuf )
  {
    if ( showLineNum )
      v2 = 6;
    else
      v2 = 1;
    v3 = COLS - v2;
    if ( v3 < 0 )
      v3 = 0;
    newBuf = newBuffer(v3);
  }
  lineBuf2 = Strnew();
  if ( !__sigsetjmp(AbortLoading, 1) )
  {
    if ( TrapSignal )
    {
      prevtrap = mySignal(2, KeyAbort);
      if ( fmInitialized )
        term_cbreak();
    }
    if ( !newBuf->sourcefile && (uf->scheme != 4 || newBuf->mailcap) )
    {
      tmpf = tmpfname(1, 0);
      src = fopen(tmpf->ptr, "w");
      if ( src )
        newBuf->sourcefile = tmpf->ptr;
    }
    if ( newBuf->document_charset )
    {
      doc_charset = newBuf->document_charset;
      charset = doc_charset;
    }
    if ( content_charset && UseContentCharset )
      doc_charset = content_charset;
    nlines = 0;
    if ( uf->stream->base.type != 4 )
      uf->stream = newEncodedStream(uf->stream, uf->encoding);
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          lineBuf2 = StrmyISgets(uf->stream);
          if ( !lineBuf2->length )
            goto _end;
          if ( uf->scheme == 9 && *lineBuf2->ptr == 46 )
          {
            Strdelete(lineBuf2, 0, 1);
            if ( *lineBuf2->ptr == 10 || *lineBuf2->ptr == 13 || !*lineBuf2->ptr )
              goto _end;
          }
          if ( src )
            fwrite(lineBuf2->ptr, 1u, lineBuf2->length, src);
          linelen += lineBuf2->length;
          if ( (w3m_dump & 8) != 0 )
          {
            v4 = convert_size2(linelen, current_content_length, 1);
            printf("W3m-in-progress: %s\n", v4);
          }
          if ( (w3m_dump & 4) == 0 )
          {
            showProgress(&linelen, &trbyte);
            if ( !frame_source )
              break;
          }
        }
        lineBuf2 = convertLine(uf, lineBuf2, 1, &charset, doc_charset);
        if ( squeezeBlankLine )
          break;
LABEL_40:
        ++nlines;
        Strchop(lineBuf2);
        lineBuf2 = checkType(lineBuf2, &propBuffer, 0);
        if ( FoldLine )
        {
          if ( showLineNum )
            v5 = 6;
          else
            v5 = 1;
          v6 = COLS - v5;
          if ( v6 < 0 )
            v6 = 0;
          v7 = v6 + 1;
        }
        else
        {
          v7 = -1;
        }
        addnewline(newBuf, lineBuf2->ptr, propBuffer, colorBuffer, lineBuf2->length, v7, nlines);
      }
      if ( *lineBuf2->ptr != 10 || pre_lbuf != 10 )
      {
        pre_lbuf = *lineBuf2->ptr;
        goto LABEL_40;
      }
      ++nlines;
    }
  }
_end:
  if ( TrapSignal )
  {
    if ( fmInitialized )
      term_raw();
    if ( prevtrap )
      mySignal(2, prevtrap);
  }
  newBuf->topLine = newBuf->firstLine;
  newBuf->lastLine = newBuf->currentLine;
  newBuf->currentLine = newBuf->firstLine;
  newBuf->trbyte = trbyte + linelen;
  newBuf->document_charset = charset;
  if ( src )
    fclose(src);
  return newBuf;
}

//----- (0806FA5B) --------------------------------------------------------
Buffer *__cdecl loadImageBuffer(URLFile *uf, Buffer *newBuf)
{
  int v3; // eax
  int v4; // eax
  char *v5; // eax
  input_stream *v6; // eax
  stat st; // [esp+30h] [ebp-B8h] BYREF
  Image image; // [esp+88h] [ebp-60h] BYREF
  URLFile f; // [esp+ACh] [ebp-3Ch] BYREF
  void (*prevtrap)(int); // [esp+CCh] [ebp-1Ch]
  FILE *src; // [esp+D0h] [ebp-18h]
  Str tmpf; // [esp+D4h] [ebp-14h]
  Str tmp; // [esp+D8h] [ebp-10h]
  ImageCache *cache; // [esp+DCh] [ebp-Ch]

  src = 0;
  prevtrap = 0;
  loadImage(newBuf, 1);
  image.url = uf->url;
  image.ext = uf->ext;
  image.width = -1;
  image.height = -1;
  image.cache = 0;
  cache = getImage(&image, cur_baseURL, 2);
  if ( cur_baseURL->is_nocache || (cache->loaded & 1) == 0 || stat_0(cache->file, (int)&st) )
  {
    if ( TrapSignal )
    {
      prevtrap = mySignal(2, KeyAbort);
      if ( fmInitialized )
        term_cbreak();
    }
    if ( uf->stream->base.type != 4 )
      uf->stream = newEncodedStream(uf->stream, uf->encoding);
    if ( save2tmp(*uf, cache->file) < 0 )
    {
      if ( !ISclose(uf->stream) )
        uf->stream = 0;
      if ( TrapSignal )
      {
        if ( fmInitialized )
          term_raw();
        if ( prevtrap )
          mySignal(2, prevtrap);
      }
      return 0;
    }
    if ( !ISclose(uf->stream) )
      uf->stream = 0;
    if ( TrapSignal )
    {
      if ( fmInitialized )
        term_raw();
      if ( prevtrap )
        mySignal(2, prevtrap);
    }
    cache->loaded = 1;
    cache->index = 0;
  }
  if ( !newBuf )
  {
    if ( showLineNum )
      v3 = 6;
    else
      v3 = 1;
    v4 = COLS - v3;
    if ( v4 < 0 )
      v4 = 0;
    newBuf = newBuffer(v4);
  }
  cache->loaded |= 4u;
  if ( !newBuf->sourcefile && uf->scheme != 4 )
    newBuf->sourcefile = cache->file;
  v5 = html_quote(image.url);
  tmp = Sprintf("<img src=\"%s\"><br><br>", v5);
  tmpf = tmpfname(1, ".html");
  src = fopen(tmpf->ptr, "w");
  newBuf->mailcap_source = tmpf->ptr;
  v6 = newStrStream(tmp);
  init_stream(&f, 4, v6);
  loadHTMLstream(&f, newBuf, src, 1);
  if ( src )
    fclose(src);
  newBuf->topLine = newBuf->firstLine;
  newBuf->lastLine = newBuf->currentLine;
  newBuf->currentLine = newBuf->firstLine;
  newBuf->image_flag = 2;
  return newBuf;
}

//----- (0806FDDB) --------------------------------------------------------
Str __cdecl conv_symbol(Line *l)
{
  int v1; // eax
  int v2; // eax
  Str result; // eax
  int len; // [esp+10h] [ebp-28h]
  char **symbol; // [esp+14h] [ebp-24h]
  int w; // [esp+18h] [ebp-20h] BYREF
  Lineprop *pr; // [esp+1Ch] [ebp-1Ch]
  char *ep; // [esp+20h] [ebp-18h]
  char *p; // [esp+24h] [ebp-14h]
  Str tmp; // [esp+28h] [ebp-10h]
  char c; // [esp+2Fh] [ebp-9h]

  tmp = 0;
  p = l->lineBuf;
  ep = &p[l->len];
  pr = l->propBuf;
  symbol = 0;
  while ( p < ep )
  {
    if ( (*pr & 0x8000u) == 0 )
    {
      if ( tmp )
      {
        if ( tmp->length + 1 >= tmp->area_size )
          Strgrow(tmp);
        v2 = tmp->length;
        tmp->ptr[v2] = *p;
        tmp->length = v2 + 1;
        tmp->ptr[tmp->length] = 0;
      }
    }
    else
    {
      c = (wtf_get_code((wc_uchar *)p) & 0x7F) - 32;
      len = WTF_LEN_MAP[(unsigned __int8)*p];
      if ( !tmp )
      {
        tmp = Strnew_size(l->len);
        Strcopy_charp_n(tmp, l->lineBuf, p - l->lineBuf);
        if ( (*pr & 0x800) != 0 )
          v1 = 2;
        else
          v1 = 1;
        w = v1;
        symbol = get_symbol(DisplayCharset, &w);
      }
      Strcat_charp(tmp, symbol[c]);
      p += len - 1;
      pr += len - 1;
    }
    ++p;
    ++pr;
  }
  if ( tmp )
    result = tmp;
  else
    result = Strnew_charp_n(l->lineBuf, l->len);
  return result;
}

//----- (0806FF79) --------------------------------------------------------
void __cdecl saveBuffer(Buffer *buf, Line *l, FILE *f, int cont)
{
  wc_ces v4; // eax
  wc_ces charset; // [esp+10h] [ebp-18h]
  int set_charset; // [esp+14h] [ebp-14h]
  int is_html; // [esp+18h] [ebp-10h]
  _Str *tmp; // [esp+1Ch] [ebp-Ch]
  Str tmpa; // [esp+1Ch] [ebp-Ch]

  set_charset = DisplayCharset == 0;
  if ( DisplayCharset )
    v4 = DisplayCharset;
  else
    v4 = 256;
  charset = v4;
  is_html = is_html_type(buf->type);
  while ( 1 )
  {
    while ( l )
    {
      if ( is_html )
        tmp = conv_symbol(l);
      else
        tmp = Strnew_charp_n(l->lineBuf, l->len);
      tmpa = wc_Str_conv(tmp, InnerCharset, charset);
      fwrite(tmpa->ptr, 1u, tmpa->length, f);
      if ( (tmpa->length <= 0 || tmpa->ptr[tmpa->length - 1] != 10) && (!cont || !l->next || !l->next->bpos) )
        _IO_putc(10, f);
      l = l->next;
    }
    if ( !buf->pagerSource || (buf->bufferprop & 0x40) != 0 )
      break;
    l = getNextPage(buf, PagerMax);
    if ( set_charset )
      charset = buf->document_charset;
  }
}

//----- (080700E6) --------------------------------------------------------
void __cdecl saveBuffer(Buffer *buf, FILE *f, int cont)
{
  saveBuffer(buf, buf->firstLine, f, cont);
}

//----- (08070111) --------------------------------------------------------
void __cdecl saveBufferBody(Buffer *buf, FILE *f, int cont)
{
  Line *l; // [esp+1Ch] [ebp-Ch]

  for ( l = buf->firstLine; l && !l->real_linenumber; l = l->next )
    ;
  saveBuffer(buf, l, f, cont);
}

//----- (0807015D) --------------------------------------------------------
Buffer *__cdecl loadcmdout(char *cmd, Buffer *(*loadproc)(URLFile *, Buffer *), Buffer *defaultbuf)
{
  input_stream *v4; // eax
  URLFile uf; // [esp+18h] [ebp-30h] BYREF
  Buffer *buf; // [esp+38h] [ebp-10h]
  FILE *f; // [esp+3Ch] [ebp-Ch]

  if ( !cmd || !*cmd )
    return 0;
  f = popen(cmd, "r");
  if ( !f )
    return 0;
  v4 = newFileStream(f, (void (*)(...))pclose);
  init_stream(&uf, 255, v4);
  buf = loadproc(&uf, defaultbuf);
  if ( !ISclose(uf.stream) )
    uf.stream = 0;
  return buf;
}

//----- (08070200) --------------------------------------------------------
Buffer *__cdecl getshell(char *cmd)
{
  wc_ces v2; // esi
  wc_ces v3; // ebx
  _Str *v4; // eax
  Str v5; // eax
  Buffer *buf; // [esp+1Ch] [ebp-Ch]

  buf = loadcmdout(cmd, (Buffer *(*)(URLFile *, Buffer *))loadBuffer, 0);
  if ( !buf )
    return 0;
  buf->filename = cmd;
  v2 = InnerCharset;
  v3 = SystemCharset;
  v4 = Strnew_charp(cmd);
  v5 = wc_Str_conv(v4, v3, v2);
  buf->buffername = Sprintf("%s %s", "*Shellout*", v5->ptr)->ptr;
  return buf;
}

//----- (0807028F) --------------------------------------------------------
Buffer *__cdecl getpipe(char *cmd)
{
  int v2; // eax
  int v3; // eax
  wc_ces v4; // esi
  wc_ces v5; // ebx
  _Str *v6; // eax
  Str v7; // eax
  Buffer *buf; // [esp+18h] [ebp-10h]
  FILE *f; // [esp+1Ch] [ebp-Ch]

  if ( !cmd || !*cmd )
    return 0;
  f = popen(cmd, "r");
  if ( !f )
    return 0;
  if ( showLineNum )
    v2 = 6;
  else
    v2 = 1;
  v3 = COLS - v2;
  if ( v3 < 0 )
    v3 = 0;
  buf = newBuffer(v3);
  buf->pagerSource = newFileStream(f, (void (*)(...))pclose);
  buf->filename = cmd;
  v4 = InnerCharset;
  v5 = SystemCharset;
  v6 = Strnew_charp(cmd);
  v7 = wc_Str_conv(v6, v5, v4);
  buf->buffername = Sprintf("%s %s", "*stream*", v7->ptr)->ptr;
  buf->bufferprop |= 1u;
  buf->document_charset = 256;
  return buf;
}

//----- (080703A2) --------------------------------------------------------
Buffer *__cdecl openPagerBuffer(InputStream stream, Buffer *buf)
{
  int v2; // eax
  int v3; // eax
  wc_ces v4; // esi
  wc_ces v5; // ebx
  _Str *v6; // eax

  if ( !buf )
  {
    if ( showLineNum )
      v2 = 6;
    else
      v2 = 1;
    v3 = COLS - v2;
    if ( v3 < 0 )
      v3 = 0;
    buf = newBuffer(v3);
  }
  buf->pagerSource = stream;
  buf->buffername = getenv("MAN_PN");
  if ( buf->buffername )
  {
    v4 = InnerCharset;
    v5 = SystemCharset;
    v6 = Strnew_charp(buf->buffername);
    buf->buffername = wc_Str_conv(v6, v5, v4)->ptr;
  }
  else
  {
    buf->buffername = "*stream*";
  }
  buf->bufferprop |= 1u;
  if ( content_charset && UseContentCharset )
    buf->document_charset = content_charset;
  else
    buf->document_charset = 256;
  buf->currentLine = buf->firstLine;
  return buf;
}

//----- (080704A4) --------------------------------------------------------
Buffer *__cdecl openGeneralPagerBuffer(InputStream stream)
{
  int v1; // eax
  int v2; // eax
  URLFile uf; // [esp+34h] [ebp-34h] BYREF
  Buffer *t_buf; // [esp+54h] [ebp-14h]
  char *t; // [esp+58h] [ebp-10h]
  Buffer *buf; // [esp+5Ch] [ebp-Ch] BYREF

  t = "text/plain";
  t_buf = 0;
  init_stream(&uf, 255, stream);
  content_charset = 0;
  if ( SearchHeader[0] )
  {
    if ( showLineNum )
      v1 = 6;
    else
      v1 = 1;
    v2 = COLS - v1;
    if ( v2 < 0 )
      v2 = 0;
    t_buf = newBuffer(v2);
    readHeader(&uf, t_buf, 1, 0);
    t = checkContentType(t_buf);
    if ( !t )
      t = "text/plain";
    if ( t_buf )
    {
      t_buf->topLine = t_buf->firstLine;
      t_buf->currentLine = t_buf->lastLine;
    }
    SearchHeader[0] = 0;
  }
  else if ( DefaultType )
  {
    t = DefaultType;
    DefaultType = 0;
  }
  if ( is_html_type(t) )
  {
    buf = loadHTMLBuffer(&uf, t_buf);
    buf->type = "text/html";
    goto LABEL_35;
  }
  if ( is_plain_text_type(t) )
  {
    if ( stream->base.type != 4 )
      stream = newEncodedStream(stream, uf.encoding);
LABEL_34:
    buf = openPagerBuffer(stream, t_buf);
    buf->type = "text/plain";
    goto LABEL_35;
  }
  if ( activeImage
    && displayImage
    && !useExtImageViewer
    && (w3m_dump & 0xFFFFFFDF) == 0
    && !strncasecmp(t, "image/", 6u) )
  {
    cur_baseURL = (ParsedURL *)GC_malloc(40);
    parseURL("-", cur_baseURL, 0);
    buf = loadImageBuffer(&uf, t_buf);
    buf->type = "text/html";
    goto LABEL_35;
  }
  if ( !doExternal(uf, "-", t, &buf, t_buf) )
  {
    if ( stream->base.type != 4 )
      stream = newEncodedStream(stream, uf.encoding);
    goto LABEL_34;
  }
  if ( !ISclose(uf.stream) )
    uf.stream = 0;
  if ( !buf || buf == (Buffer *)1 )
    return buf;
LABEL_35:
  buf->real_type = t;
  buf->currentURL.scheme = 4;
  buf->currentURL.file = "-";
  return buf;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (080707C1) --------------------------------------------------------
Line *__cdecl getNextPage(Buffer *buf, int plen)
{
  wc_ces v3; // esi
  wc_ces v4; // ebx
  _Str *v5; // eax
  Str v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  URLFile uf; // [esp+28h] [ebp-80h] BYREF
  clen_t trbyte; // [esp+48h] [ebp-60h] BYREF
  clen_t linelen; // [esp+50h] [ebp-58h] BYREF
  Line *l; // [esp+58h] [ebp-50h]
  void (*prevtrap)(int); // [esp+5Ch] [ebp-4Ch]
  Linecolor *colorBuffer; // [esp+60h] [ebp-48h] BYREF
  Lineprop *propBuffer; // [esp+64h] [ebp-44h] BYREF
  int squeeze_flag; // [esp+68h] [ebp-40h]
  wc_ces doc_charset; // [esp+6Ch] [ebp-3Ch]
  wc_ces charset; // [esp+70h] [ebp-38h] BYREF
  Str lineBuf2; // [esp+74h] [ebp-34h]
  int nlines; // [esp+78h] [ebp-30h]
  int i; // [esp+7Ch] [ebp-2Ch]
  Line *cur; // [esp+80h] [ebp-28h]
  Line *last; // [esp+84h] [ebp-24h]
  Line *top; // [esp+88h] [ebp-20h]
  wc_uint8 old_auto_detect; // [esp+8Eh] [ebp-1Ah]
  char pre_lbuf; // [esp+8Fh] [ebp-19h]

  top = buf->topLine;
  last = buf->lastLine;
  cur = buf->currentLine;
  nlines = 0;
  linelen = 0LL;
  trbyte = buf->trbyte;
  pre_lbuf = 0;
  doc_charset = DocumentCharset;
  old_auto_detect = WcOption.auto_detect;
  squeeze_flag = 0;
  propBuffer = 0;
  colorBuffer = 0;
  prevtrap = 0;
  if ( !buf->pagerSource )
    return 0;
  if ( last )
  {
    nlines = last->real_linenumber;
    pre_lbuf = *last->lineBuf;
    if ( !pre_lbuf )
      pre_lbuf = 10;
    buf->currentLine = last;
  }
  charset = buf->document_charset;
  if ( buf->document_charset == 256 )
  {
    if ( UseContentCharset )
    {
      content_charset = 0;
      checkContentType(buf);
      if ( content_charset )
        doc_charset = content_charset;
    }
  }
  else
  {
    doc_charset = buf->document_charset;
  }
  WcOption.auto_detect = buf->auto_detect;
  if ( !__sigsetjmp(AbortLoading, 1) )
  {
    if ( TrapSignal )
    {
      prevtrap = mySignal(2, KeyAbort);
      if ( fmInitialized )
        term_cbreak();
    }
    init_stream(&uf, 255, 0);
    for ( i = 0; i < plen; ++i )
    {
      lineBuf2 = StrmyISgets(buf->pagerSource);
      if ( !lineBuf2->length )
      {
        if ( buf->filename )
        {
          v3 = InnerCharset;
          v4 = SystemCharset;
          v5 = Strnew_charp(buf->filename);
          v6 = wc_Str_conv(v5, v4, v3);
          buf->buffername = Sprintf("%s %s", "*stream(closed)*", v6->ptr)->ptr;
        }
        else if ( !getenv("MAN_PN") )
        {
          buf->buffername = "*stream(closed)*";
        }
        buf->bufferprop |= 0x40u;
        break;
      }
      linelen += lineBuf2->length;
      showProgress(&linelen, &trbyte);
      lineBuf2 = convertLine(&uf, lineBuf2, 1, &charset, doc_charset);
      if ( squeezeBlankLine )
      {
        squeeze_flag = 0;
        if ( *lineBuf2->ptr == 10 && pre_lbuf == 10 )
        {
          ++nlines;
          --i;
          squeeze_flag = 1;
          continue;
        }
        pre_lbuf = *lineBuf2->ptr;
      }
      ++nlines;
      Strchop(lineBuf2);
      lineBuf2 = checkType(lineBuf2, &propBuffer, &colorBuffer);
      if ( FoldLine )
      {
        if ( showLineNum )
          v7 = 6;
        else
          v7 = 1;
        v8 = COLS - v7;
        if ( v8 < 0 )
          v8 = 0;
        v9 = v8 + 1;
      }
      else
      {
        v9 = -1;
      }
      addnewline(buf, lineBuf2->ptr, propBuffer, colorBuffer, lineBuf2->length, v9, nlines);
      if ( !top )
      {
        top = buf->firstLine;
        cur = top;
      }
      if ( buf->lastLine->real_linenumber - buf->firstLine->real_linenumber >= PagerMax )
      {
        l = buf->firstLine;
        do
        {
          if ( top == l )
            top = l->next;
          if ( cur == l )
            cur = l->next;
          if ( last == l )
            last = 0;
          l = l->next;
        }
        while ( l && l->bpos );
        buf->firstLine = l;
        buf->firstLine->prev = 0;
      }
    }
  }
  if ( TrapSignal )
  {
    if ( fmInitialized )
      term_raw();
    if ( prevtrap )
      mySignal(2, prevtrap);
  }
  buf->trbyte = trbyte + linelen;
  buf->document_charset = charset;
  WcOption.auto_detect = old_auto_detect;
  buf->topLine = top;
  buf->currentLine = cur;
  if ( !last )
    return buf->firstLine;
  if ( last->next || !squeeze_flag )
    last = last->next;
  return last;
}
// 8070C90: conditional instruction was optimized away because of '%last.4!=0'

//----- (08070CBA) --------------------------------------------------------
int __cdecl save2tmp(URLFile uf, char *tmpf)
{
  clen_t trbyte; // [esp+18h] [ebp-30h] BYREF
  clen_t linelen; // [esp+20h] [ebp-28h] BYREF
  Str buf; // [esp+2Ch] [ebp-1Ch]
  void (*prevtrap)(int); // [esp+30h] [ebp-18h]
  int check; // [esp+34h] [ebp-14h]
  FILE *ff; // [esp+38h] [ebp-10h]
  char c; // [esp+3Fh] [ebp-9h]

  linelen = 0LL;
  trbyte = 0LL;
  prevtrap = 0;
  ff = fopen(tmpf, "wb");
  if ( !ff )
    return -1;
  bcopy(AbortLoading, env_bak_22032, 0x9Cu);
  if ( !__sigsetjmp(AbortLoading, 1) )
  {
    if ( TrapSignal )
    {
      prevtrap = mySignal(2, KeyAbort);
      if ( fmInitialized )
        term_cbreak();
    }
    check = 0;
    if ( uf.scheme == 9 )
    {
      while ( 1 )
      {
        c = ISgetc(uf.stream);
        if ( uf.stream->base.iseos )
          break;
        if ( c == 10 )
        {
          if ( check )
          {
            if ( check == 3 )
              break;
          }
          else
          {
            check = 1;
          }
        }
        else if ( c == 46 && check == 1 )
        {
          check = 2;
        }
        else if ( c == 13 && check == 2 )
        {
          check = 3;
        }
        else
        {
          check = 0;
        }
        _IO_putc(c, ff);
        ++linelen;
        showProgress(&linelen, &trbyte);
      }
    }
    else
    {
      buf = Strnew_size(1536);
      while ( ISread(uf.stream, buf, 1536) )
      {
        fwrite(buf->ptr, 1u, buf->length, ff);
        linelen += buf->length;
        showProgress(&linelen, &trbyte);
      }
    }
  }
  bcopy(env_bak_22032, AbortLoading, 0x9Cu);
  if ( TrapSignal )
  {
    if ( fmInitialized )
      term_raw();
    if ( prevtrap )
      mySignal(2, prevtrap);
  }
  fclose(ff);
  current_content_length = 0LL;
  return 0;
}

//----- (08070F2F) --------------------------------------------------------
int __cdecl doExternal(URLFile uf, char *path, char *type, Buffer **bufp, Buffer *defaultbuf)
{
  int result; // eax
  char *v6; // eax
  wc_ces v7; // esi
  wc_ces v8; // ebx
  _Str *v9; // eax
  char *v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  wc_ces v14; // esi
  wc_ces v15; // ebx
  char *v16; // eax
  _Str *v17; // eax
  char *ext; // [esp+40h] [ebp-28h]
  char *src; // [esp+44h] [ebp-24h]
  char *header; // [esp+48h] [ebp-20h]
  Buffer *buf; // [esp+4Ch] [ebp-1Ch]
  int mc_stat; // [esp+50h] [ebp-18h] BYREF
  mailcap *mcap; // [esp+54h] [ebp-14h]
  Str command; // [esp+58h] [ebp-10h]
  Str tmpf; // [esp+5Ch] [ebp-Ch]

  src = 0;
  ext = uf.ext;
  mcap = searchExtViewer(type);
  if ( !mcap )
    return 0;
  if ( mcap->nametemplate )
  {
    tmpf = cptifil(mcap->nametemplate, 0, (char *)&line, 0, 0);
    if ( *tmpf->ptr == 46 )
      ext = tmpf->ptr;
  }
  if ( ext && *ext )
    v6 = ext;
  else
    v6 = 0;
  tmpf = tmpfname(0, v6);
  if ( uf.stream->base.type != 4 )
    uf.stream = newEncodedStream(uf.stream, uf.encoding);
  header = checkHeader(defaultbuf, "Content-Type:");
  if ( header )
  {
    v7 = SystemCharset;
    v8 = InnerCharset;
    v9 = Strnew_charp(header);
    header = wc_Str_conv_strict(v9, v8, v7)->ptr;
  }
  command = cptifil(mcap->viewer, type, tmpf->ptr, header, &mc_stat);
  if ( (mc_stat & 1) == 0 )
  {
    v10 = shell_quote(tmpf->ptr);
    command = Sprintf("(%s) < %s", command->ptr, v10);
  }
  if ( (mcap->flags & 6) != 0 || (mcap->flags & 1) != 0 || !BackgroundExtViewer )
  {
    if ( save2tmp(uf, tmpf->ptr) >= 0 )
    {
      if ( (mcap->flags & 6) != 0 )
      {
        if ( !defaultbuf )
        {
          if ( showLineNum )
            v12 = 6;
          else
            v12 = 1;
          v13 = COLS - v12;
          if ( v13 < 0 )
            v13 = 0;
          defaultbuf = newBuffer(v13);
        }
        if ( defaultbuf->sourcefile )
          src = defaultbuf->sourcefile;
        else
          src = tmpf->ptr;
        defaultbuf->sourcefile = 0;
        defaultbuf->mailcap = mcap;
      }
      if ( (mcap->flags & 4) != 0 )
      {
        buf = loadcmdout(command->ptr, loadHTMLBuffer, defaultbuf);
        if ( buf && buf != (Buffer *)1 )
        {
          buf->type = "text/html";
          buf->mailcap_source = buf->sourcefile;
          buf->sourcefile = src;
        }
      }
      else if ( (mcap->flags & 2) != 0 )
      {
        buf = loadcmdout(command->ptr, (Buffer *(*)(URLFile *, Buffer *))loadBuffer, defaultbuf);
        if ( buf && buf != (Buffer *)1 )
        {
          buf->type = "text/plain";
          buf->mailcap_source = buf->sourcefile;
          buf->sourcefile = src;
        }
      }
      else
      {
        if ( (mcap->flags & 1) == 0 && BackgroundExtViewer )
        {
          mySystem(command->ptr, 1);
        }
        else
        {
          fmTerm();
          mySystem(command->ptr, 0);
          fmInit();
          if ( CurrentTab && CurrentTab->currentBuffer )
            displayBuffer(CurrentTab->currentBuffer, 1);
        }
        buf = (Buffer *)1;
      }
      if ( buf && buf != (Buffer *)1 )
      {
        buf->filename = path;
        if ( !buf->buffername || !*buf->buffername )
        {
          v14 = InnerCharset;
          v15 = SystemCharset;
          v16 = lastFileName(path);
          v17 = Strnew_charp(v16);
          buf->buffername = wc_Str_conv(v17, v15, v14)->ptr;
        }
        buf->edit = mcap->edit;
        buf->mailcap = mcap;
      }
      *bufp = buf;
      result = 1;
    }
    else
    {
      *bufp = 0;
      result = 1;
    }
  }
  else
  {
    flush_tty();
    if ( !fork() )
    {
      v11 = ISfileno(uf.stream);
      setup_child(0, 0, v11);
      if ( save2tmp(uf, tmpf->ptr) < 0 )
        exit(1);
      ISclose(uf.stream);
      myExec(command->ptr);
    }
    *bufp = (Buffer *)1;
    result = 1;
  }
  return result;
}

//----- (08071480) --------------------------------------------------------
int __cdecl MoveFile(char *path1, char *path2)
{
  int v2; // eax
  int result; // eax
  clen_t trbyte; // [esp+10h] [ebp-28h] BYREF
  clen_t linelen; // [esp+18h] [ebp-20h] BYREF
  Str buf; // [esp+20h] [ebp-18h]
  int is_pipe; // [esp+24h] [ebp-14h]
  FILE *f2; // [esp+28h] [ebp-10h]
  InputStream f1; // [esp+2Ch] [ebp-Ch]

  linelen = 0LL;
  trbyte = 0LL;
  v2 = open(path1, 0);
  f1 = newInputStream(v2);
  if ( !f1 )
    return -1;
  if ( *path2 == 124 && PermitSaveToPipe )
  {
    is_pipe = 1;
    f2 = popen(path2 + 1, "w");
  }
  else
  {
    is_pipe = 0;
    f2 = fopen(path2, "wb");
  }
  if ( f2 )
  {
    current_content_length = 0LL;
    buf = Strnew_size(1536);
    while ( ISread(f1, buf, 1536) )
    {
      fwrite(buf->ptr, 1u, buf->length, f2);
      linelen += buf->length;
      showProgress(&linelen, &trbyte);
    }
    ISclose(f1);
    if ( is_pipe )
      pclose(f2);
    else
      fclose(f2);
    result = 0;
  }
  else
  {
    ISclose(f1);
    result = -1;
  }
  return result;
}

//----- (0807160F) --------------------------------------------------------
int __cdecl doFileCopy(char *tmpf, char *defstr, int download)
{
  wc_ces v4; // esi
  wc_ces v5; // ebx
  _Str *v6; // eax
  _Str *v7; // eax
  wc_ces v8; // esi
  wc_ces v9; // ebx
  _Str *v10; // eax
  wc_ces v11; // esi
  wc_ces v12; // ebx
  _Str *v13; // eax
  char *v14; // ebx
  wc_ces v15; // edi
  wc_ces v16; // esi
  _Str *v17; // eax
  Str v18; // eax
  wc_ces v19; // esi
  wc_ces v20; // ebx
  _Str *v21; // eax
  Str v22; // eax
  wc_ces v23; // esi
  wc_ces v24; // ebx
  _Str *v25; // eax
  Str v26; // eax
  stat st; // [esp+20h] [ebp-98h] BYREF
  clen_t size; // [esp+78h] [ebp-40h]
  int is_pipe; // [esp+84h] [ebp-34h]
  char *lock; // [esp+88h] [ebp-30h]
  pid_t pid; // [esp+8Ch] [ebp-2Ch]
  char *q; // [esp+90h] [ebp-28h]
  char *p; // [esp+94h] [ebp-24h]
  Str filen; // [esp+98h] [ebp-20h]
  Str msg; // [esp+9Ch] [ebp-1Ch]

  q = 0;
  size = 0LL;
  is_pipe = 0;
  if ( !fmInitialized )
  {
    q = searchKeyData();
    if ( !q || !*q )
    {
      printf("(Download)Save file to: ");
      fflush(stdout);
      filen = Strfgets(stdin);
      if ( !filen->length )
        return -1;
      q = filen->ptr;
    }
    for ( p = &q[strlen(q) - 1]; (MYCTYPE_MAP[(unsigned __int8)*p] & 2) != 0; --p )
      ;
    p[1] = 0;
    if ( !*q )
      return -1;
    p = q;
    if ( *q == 124 && PermitSaveToPipe )
    {
      is_pipe = 1;
    }
    else
    {
      p = expandPath(p);
      if ( checkOverWrite(p) < 0 )
        return -1;
    }
    if ( checkCopyFile(tmpf, p) < 0 )
    {
      printf("Can't copy. %s and %s are identical.", tmpf, p);
      return -1;
    }
    if ( MoveFile(tmpf, p) < 0 )
    {
      printf("Can't save to %s\n", p);
      return -1;
    }
    if ( PreserveTimestamp && !is_pipe && !stat_0(tmpf, (int)&st) )
      setModtime(p, st.st_mtim.tv_sec);
    return 0;
  }
  p = searchKeyData();
  if ( !p || !*p )
  {
    q = inputLineHistSearch("(Download)Save file to: ", defstr, 128, SaveHist, 0);
    if ( !q || !*q )
      return 0;
    v4 = SystemCharset;
    v5 = InnerCharset;
    v6 = Strnew_charp(q);
    p = wc_Str_conv_strict(v6, v5, v4)->ptr;
  }
  if ( *p == 124 && PermitSaveToPipe )
  {
    is_pipe = 1;
  }
  else
  {
    if ( q )
    {
      v7 = Strnew_charp(q);
      p = unescape_spaces(v7)->ptr;
      v8 = SystemCharset;
      v9 = InnerCharset;
      v10 = Strnew_charp(q);
      p = wc_Str_conv_strict(v10, v9, v8)->ptr;
    }
    p = expandPath(p);
    if ( checkOverWrite(p) < 0 )
      return -1;
  }
  if ( checkCopyFile(tmpf, p) < 0 )
  {
    v11 = InnerCharset;
    v12 = SystemCharset;
    v13 = Strnew_charp(p);
    v14 = wc_Str_conv(v13, v12, v11)->ptr;
    v15 = InnerCharset;
    v16 = SystemCharset;
    v17 = Strnew_charp(tmpf);
    v18 = wc_Str_conv(v17, v16, v15);
    msg = Sprintf("Can't copy. %s and %s are identical.", v18->ptr, v14);
    _ZN10bdInetAddrC2Ej(msg->ptr, 0);
    return -1;
  }
  if ( download )
  {
    lock = tmpfname(0, ".lock")->ptr;
    symlink(p, lock);
    flush_tty();
    pid = fork();
    if ( !pid )
    {
      setup_child(0, 0, -1);
      if ( !MoveFile(tmpf, p) && PreserveTimestamp && !is_pipe && !stat_0(tmpf, (int)&st) )
        setModtime(p, st.st_mtim.tv_sec);
      unlink(lock);
      exit(0);
    }
    if ( !stat_0(tmpf, (int)&st) )
      size = st.st_size;
    v23 = InnerCharset;
    v24 = SystemCharset;
    v25 = Strnew_charp(tmpf);
    v26 = wc_Str_conv(v25, v24, v23);
    addDownloadList(pid, v26->ptr, p, lock, size);
    return 0;
  }
  if ( MoveFile(tmpf, p) < 0 )
  {
    v19 = InnerCharset;
    v20 = SystemCharset;
    v21 = Strnew_charp(p);
    v22 = wc_Str_conv(v21, v20, v19);
    msg = Sprintf("Can't save to %s", v22->ptr);
    _ZN10bdInetAddrC2Ej(msg->ptr, 0);
  }
  return -1;
}

//----- (08071B71) --------------------------------------------------------
int __cdecl doFileMove(char *tmpf, char *defstr)
{
  int ret; // [esp+1Ch] [ebp-Ch]

  ret = doFileCopy(tmpf, defstr, 0);
  unlink(tmpf);
  return ret;
}

//----- (08071BA4) --------------------------------------------------------
int __cdecl doFileSave(URLFile uf, char *defstr)
{
  wc_ces v3; // esi
  wc_ces v4; // ebx
  _Str *v5; // eax
  wc_ces v6; // esi
  wc_ces v7; // ebx
  _Str *v8; // eax
  Str v9; // eax
  int v10; // eax
  char *tmpf; // [esp+34h] [ebp-24h] BYREF
  char *lock; // [esp+38h] [ebp-20h]
  pid_t pid; // [esp+3Ch] [ebp-1Ch]
  char *q; // [esp+40h] [ebp-18h]
  char *p; // [esp+44h] [ebp-14h]
  Str filen; // [esp+48h] [ebp-10h]
  Str msg; // [esp+4Ch] [ebp-Ch]

  tmpf = 0;
  if ( fmInitialized )
  {
    p = searchKeyData();
    if ( !p || !*p )
    {
      p = inputLineHistSearch("(Download)Save file to: ", defstr, 32, SaveHist, 0);
      if ( !p || !*p )
        return -1;
      v3 = SystemCharset;
      v4 = InnerCharset;
      v5 = Strnew_charp(p);
      p = wc_Str_conv_strict(v5, v4, v3)->ptr;
    }
    if ( checkOverWrite(p) < 0 )
      return -1;
    if ( checkSaveFile(uf.stream, p) < 0 )
    {
      v6 = InnerCharset;
      v7 = SystemCharset;
      v8 = Strnew_charp(p);
      v9 = wc_Str_conv(v8, v7, v6);
      msg = Sprintf("Can't save. Load file and %s are identical.", v9->ptr);
      _ZN10bdInetAddrC2Ej(msg->ptr, 0);
      return -1;
    }
    lock = tmpfname(0, ".lock")->ptr;
    symlink(p, lock);
    flush_tty();
    pid = fork();
    if ( !pid )
    {
      if ( uf.content_encoding )
      {
        if ( AutoUncompress )
        {
          uncompress_stream(&uf, &tmpf);
          if ( tmpf )
            unlink(tmpf);
        }
      }
      v10 = ISfileno(uf.stream);
      setup_child(0, 0, v10);
      if ( !save2tmp(uf, p) && PreserveTimestamp && uf.modtime != -1 )
        setModtime(p, uf.modtime);
      if ( !ISclose(uf.stream) )
        uf.stream = 0;
      unlink(lock);
      exit(0);
    }
    addDownloadList(pid, uf.url, p, lock, current_content_length);
  }
  else
  {
    q = searchKeyData();
    if ( !q || !*q )
    {
      printf("(Download)Save file to: ");
      fflush(stdout);
      filen = Strfgets(stdin);
      if ( !filen->length )
        return -1;
      q = filen->ptr;
    }
    for ( p = &q[strlen(q) - 1]; (MYCTYPE_MAP[(unsigned __int8)*p] & 2) != 0; --p )
      ;
    p[1] = 0;
    if ( !*q )
      return -1;
    p = expandPath(q);
    if ( checkOverWrite(p) < 0 )
      return -1;
    if ( checkSaveFile(uf.stream, p) < 0 )
    {
      printf("Can't save. Load file and %s are identical.", p);
      return -1;
    }
    if ( uf.content_encoding )
    {
      if ( AutoUncompress )
      {
        uncompress_stream(&uf, &tmpf);
        if ( tmpf )
          unlink(tmpf);
      }
    }
    if ( save2tmp(uf, p) < 0 )
    {
      printf("Can't save to %s\n", p);
      return -1;
    }
    if ( PreserveTimestamp && uf.modtime != -1 )
      setModtime(p, uf.modtime);
  }
  return 0;
}

//----- (0807201D) --------------------------------------------------------
int __cdecl checkCopyFile(char *path1, char *path2)
{
  stat st2_0; // [esp+10h] [ebp-B8h] BYREF
  stat st1_0; // [esp+68h] [ebp-60h] BYREF

  if ( *path2 == 124 && PermitSaveToPipe )
    return 0;
  if ( stat_0(path1, (int)&st1_0) || stat_0(path2, (int)&st2_0) || st1_0.st_ino != st2_0.st_ino )
    return 0;
  return -1;
}

//----- (0807208C) --------------------------------------------------------
int __cdecl checkSaveFile(InputStream stream, char *path2)
{
  stat st2_0; // [esp+1Ch] [ebp-BCh] BYREF
  stat st1_0; // [esp+74h] [ebp-64h] BYREF
  int des; // [esp+CCh] [ebp-Ch]

  des = ISfileno(stream);
  if ( des < 0 )
    return 0;
  if ( *path2 == 124 && PermitSaveToPipe )
    return 0;
  if ( fstat(des, (int)&st1_0) || stat_0(path2, (int)&st2_0) || st1_0.st_ino != st2_0.st_ino )
    return 0;
  return -1;
}

//----- (08072116) --------------------------------------------------------
int __cdecl checkOverWrite(char *path)
{
  stat st; // [esp+14h] [ebp-64h] BYREF
  char *ans; // [esp+6Ch] [ebp-Ch]

  if ( stat_0(path, (int)&st) < 0 )
    return 0;
  ans = inputAnswer("File exists. Overwrite? (y/n)");
  if ( !ans )
    return -1;
  if ( (MYCTYPE_MAP[(unsigned __int8)*ans] & 4) != 0 )
  {
    if ( ((unsigned __int8)*ans | 0x20) != 121 )
      return -1;
    return 0;
  }
  if ( *ans == 121 )
    return 0;
  return -1;
}

//----- (0807218F) --------------------------------------------------------
char *__cdecl inputAnswer(char *prompt)
{
  char *ans; // [esp+2Ch] [ebp-Ch]

  if ( QuietMessage[0] )
    return "n";
  if ( fmInitialized )
  {
    term_raw();
    ans = inputLineHistSearch(prompt, (char *)&line, 512, 0, 0);
  }
  else
  {
    printf("%s", prompt);
    fflush(stdout);
    ans = Strfgets(stdin)->ptr;
  }
  return ans;
}

//----- (0807221F) --------------------------------------------------------
void __cdecl uncompress_stream(URLFile *uf, char **src)
{
  int v2; // eax
  FILE *f; // [esp+14h] [ebp-34h]
  Str buf; // [esp+18h] [ebp-30h]
  FILE *f2; // [esp+1Ch] [ebp-2Ch] BYREF
  pid_t pid2; // [esp+20h] [ebp-28h]
  compression_decoder *d; // [esp+24h] [ebp-24h]
  char *ext; // [esp+28h] [ebp-20h]
  char *tmpf; // [esp+2Ch] [ebp-1Ch]
  char *expand_name; // [esp+30h] [ebp-18h]
  char *expand_cmd; // [esp+34h] [ebp-14h]
  FILE *f1; // [esp+38h] [ebp-10h] BYREF
  pid_t pid1; // [esp+3Ch] [ebp-Ch]

  expand_cmd = "gunzip";
  expand_name = "gunzip";
  tmpf = 0;
  ext = 0;
  if ( uf->stream->base.type != 4 )
  {
    uf->stream = newEncodedStream(uf->stream, uf->encoding);
    uf->encoding = 0;
  }
  for ( d = compression_decoders; d->type; ++d )
  {
    if ( uf->compression == d->type )
    {
      if ( d->auxbin_p )
        expand_cmd = auxbinFile(d->cmd);
      else
        expand_cmd = d->cmd;
      expand_name = d->name;
      ext = d->ext;
      break;
    }
  }
  uf->compression = 0;
  if ( uf->scheme != 4 && !image_source )
    tmpf = tmpfname(0, ext)->ptr;
  pid1 = open_pipe_rw(&f1, 0);
  if ( pid1 >= 0 )
  {
    if ( !pid1 )
    {
      f2 = stdin;
      pid2 = open_pipe_rw(&f2, 0);
      if ( pid2 < 0 )
      {
        if ( !ISclose(uf->stream) )
          uf->stream = 0;
        exit(1);
      }
      if ( !pid2 )
      {
        buf = Strnew_size(1536);
        f = 0;
        v2 = ISfileno(uf->stream);
        setup_child(1, 2, v2);
        if ( tmpf )
          f = fopen(tmpf, "wb");
        while ( ISread(uf->stream, buf, 1536) )
        {
          fwrite(buf->ptr, 1u, buf->length, stdout);
          if ( f )
            fwrite(buf->ptr, 1u, buf->length, f);
        }
        if ( !ISclose(uf->stream) )
          uf->stream = 0;
        if ( f )
          fclose(f);
        exit(0);
      }
      dup2(1, 2);
      setup_child(1, -1, -1);
      execlp(expand_cmd, expand_name, 0);
      exit(1);
    }
    if ( tmpf )
    {
      if ( src )
        *src = tmpf;
      else
        uf->scheme = 4;
    }
    UFhalfclose(uf);
    uf->stream = newFileStream(f1, (void (*)(...))fclose);
  }
  else if ( !ISclose(uf->stream) )
  {
    uf->stream = 0;
  }
}

//----- (08072573) --------------------------------------------------------
FILE *__cdecl lessopen_stream(char *path)
{
  char *v2; // [esp+4h] [ebp-24h]
  int c; // [esp+10h] [ebp-18h]
  Str tmpf; // [esp+14h] [ebp-14h]
  FILE *fp; // [esp+18h] [ebp-10h]
  char *lessopen; // [esp+1Ch] [ebp-Ch]

  lessopen = getenv("LESSOPEN");
  if ( !lessopen )
    return 0;
  if ( !*lessopen )
    return 0;
  if ( *lessopen != 124 )
    return 0;
  v2 = shell_quote(path);
  tmpf = Sprintf(lessopen + 1, v2);
  fp = popen(tmpf->ptr, "r");
  if ( !fp )
    return 0;
  c = _IO_getc(fp);
  if ( c == -1 )
  {
    fclose(fp);
    return 0;
  }
  ungetc(c, fp);
  return fp;
}

//----- (08072646) --------------------------------------------------------
char *__cdecl guess_filename(char *file)
{
  char *s; // [esp+18h] [ebp-10h]
  char *p; // [esp+1Ch] [ebp-Ch]

  p = 0;
  if ( file )
    p = mybasename(file);
  if ( !p || !*p )
    return "index.html";
  s = p;
  if ( *p == 35 )
    ++p;
  while ( *p )
  {
    if ( *p == 35 && p[1] || *p == 63 )
    {
      *p = 0;
      return s;
    }
    ++p;
  }
  return s;
}

//----- (080726D3) --------------------------------------------------------
char *__cdecl guess_save_name(Buffer *buf, char *path)
{
  char *q; // [esp+14h] [ebp-14h]
  char *qa; // [esp+14h] [ebp-14h]
  char *p; // [esp+18h] [ebp-10h]
  char *pa; // [esp+18h] [ebp-10h]
  Str name[3]; // [esp+1Ch] [ebp-Ch] BYREF

  if ( buf && buf->document_header )
  {
    name[0] = 0;
    p = checkHeader(buf, "Content-Disposition:");
    if ( p
      && (q = (char *)strcasestr(p, "filename")) != 0
      && (q == p || (MYCTYPE_MAP[(unsigned __int8)*(q - 1)] & 2) != 0 || *(q - 1) == 59)
      && matchattr(q, "filename", 8, name) )
    {
      path = name[0]->ptr;
    }
    else
    {
      pa = checkHeader(buf, "Content-Type:");
      if ( pa )
      {
        qa = (char *)strcasestr(pa, "name");
        if ( qa )
        {
          if ( qa == pa || (MYCTYPE_MAP[(unsigned __int8)*(qa - 1)] & 2) != 0 || *(qa - 1) == 59 )
          {
            if ( matchattr(qa, "name", 4, name) )
              path = name[0]->ptr;
          }
        }
      }
    }
  }
  return guess_filename(path);
}
// 804A36C: using guessed type int __cdecl strcasestr(_DWORD, _DWORD);

//----- (08072844) --------------------------------------------------------
Buffer *__cdecl newBuffer(int width)
{
  Buffer *n; // [esp+1Ch] [ebp-Ch]

  n = (Buffer *)GC_malloc(260);
  if ( !n )
    return 0;
  bzero(n, 0x104u);
  n->width = width;
  n->COLS = COLS;
  n->LINES = LINES - 1;
  n->currentURL.scheme = 255;
  n->baseURL = 0;
  n->baseTarget = 0;
  n->buffername = (char *)&unk_80CABB0;
  n->bufferprop = 0;
  n->clone = (int *)GC_malloc(4);
  *n->clone = 1;
  n->trbyte = 0;
  n->auto_detect = WcOption.auto_detect;
  return n;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (08072929) --------------------------------------------------------
Buffer *nullBuffer()
{
  Buffer *result; // eax

  result = newBuffer(COLS);
  result->buffername = "*Null*";
  return result;
}

//----- (0807294E) --------------------------------------------------------
void __cdecl clearBuffer(Buffer *buf)
{
  buf->lastLine = 0;
  buf->currentLine = buf->lastLine;
  buf->topLine = buf->currentLine;
  buf->firstLine = buf->topLine;
  buf->allLine = 0;
}

//----- (0807298B) --------------------------------------------------------
void __cdecl discardBuffer(Buffer *buf)
{
  int *v1; // eax
  Buffer *b; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]

  deleteImage(buf);
  clearBuffer(buf);
  for ( i = 0; i <= 4; ++i )
  {
    b = buf->linkBuffer[i];
    if ( b )
      b->linkBuffer[REV_LB[i]] = 0;
  }
  if ( buf->savecache )
    unlink(buf->savecache);
  v1 = buf->clone;
  if ( !--*v1 )
  {
    if ( buf->pagerSource )
      ISclose(buf->pagerSource);
    if ( buf->sourcefile
      && (!buf->real_type || strncasecmp(buf->real_type, "image/", 6u))
      && (buf->real_scheme != 4 || (buf->bufferprop & 2) != 0) )
    {
      unlink(buf->sourcefile);
    }
    if ( buf->header_source )
      unlink(buf->header_source);
    if ( buf->mailcap_source )
      unlink(buf->mailcap_source);
    while ( buf->frameset )
    {
      deleteFrameSet(buf->frameset);
      buf->frameset = popFrameTree(&buf->frameQ);
    }
  }
}

//----- (08072B1F) --------------------------------------------------------
Buffer *__cdecl namedBuffer(Buffer *first, char *name)
{
  Buffer *buf; // [esp+1Ch] [ebp-Ch]

  if ( !strcmp(first->buffername, name) )
    return first;
  for ( buf = first; buf->nextBuffer; buf = buf->nextBuffer )
  {
    if ( !strcmp(buf->nextBuffer->buffername, name) )
      return buf->nextBuffer;
  }
  return 0;
}

//----- (08072B89) --------------------------------------------------------
Buffer *__cdecl deleteBuffer(Buffer *first, Buffer *delbuf)
{
  Buffer *result; // eax
  Buffer *b; // [esp+18h] [ebp-10h]
  _Buffer *bufa; // [esp+1Ch] [ebp-Ch]
  Buffer *buf; // [esp+1Ch] [ebp-Ch]

  if ( first == delbuf && first->nextBuffer )
  {
    bufa = first->nextBuffer;
    discardBuffer(first);
    result = bufa;
  }
  else
  {
    buf = prevBuffer(first, delbuf);
    if ( buf )
    {
      b = buf->nextBuffer;
      buf->nextBuffer = b->nextBuffer;
      discardBuffer(b);
    }
    result = first;
  }
  return result;
}

//----- (08072BFA) --------------------------------------------------------
Buffer *__cdecl replaceBuffer(Buffer *first, Buffer *delbuf, Buffer *newbuf)
{
  Buffer *result; // eax
  Buffer *buf; // [esp+1Ch] [ebp-Ch]

  if ( delbuf )
  {
    if ( first == delbuf )
    {
      newbuf->nextBuffer = delbuf->nextBuffer;
      discardBuffer(delbuf);
      result = newbuf;
    }
    else
    {
      buf = prevBuffer(first, delbuf);
      if ( buf )
      {
        buf->nextBuffer = newbuf;
        newbuf->nextBuffer = delbuf->nextBuffer;
        discardBuffer(delbuf);
        result = first;
      }
      else
      {
        newbuf->nextBuffer = first;
        result = newbuf;
      }
    }
  }
  else
  {
    newbuf->nextBuffer = first;
    result = newbuf;
  }
  return result;
}
// 8072C3C: conditional instruction was optimized away because of '%delbuf.4!=0'

//----- (08072C8C) --------------------------------------------------------
Buffer *__cdecl nthBuffer(Buffer *firstbuf, int n)
{
  Buffer *buf; // [esp+8h] [ebp-8h]
  int i; // [esp+Ch] [ebp-4h]

  buf = firstbuf;
  if ( n < 0 )
    return firstbuf;
  for ( i = 0; i < n; ++i )
  {
    if ( !buf )
      return 0;
    buf = buf->nextBuffer;
  }
  return buf;
}

//----- (08072CD3) --------------------------------------------------------
void __cdecl writeBufferName(Buffer *buf, int n)
{
  int v2; // eax
  int v3; // eax
  wc_ces v4; // esi
  wc_ces v5; // ebx
  _Str *v6; // eax
  int v7; // eax
  char *v8; // [esp+4h] [ebp-24h]
  _Str *v9; // [esp+4h] [ebp-24h]
  int all; // [esp+18h] [ebp-10h]
  Str msg; // [esp+1Ch] [ebp-Ch]

  all = buf->allLine;
  if ( !all && buf->lastLine )
    all = buf->lastLine->linenumber;
  move(n, 0);
  msg = Sprintf("<%s> [%d lines]", buf->buffername, all);
  if ( buf->filename )
  {
    v2 = buf->currentURL.scheme;
    if ( v2 < 4 )
    {
LABEL_13:
      if ( msg->length + 1 >= msg->area_size )
        Strgrow(msg);
      v7 = msg->length;
      msg->ptr[v7] = 32;
      msg->length = v7 + 1;
      msg->ptr[msg->length] = 0;
      v9 = parsedURL2Str(&buf->currentURL);
      savexmlstr_0(msg, v9);
      goto LABEL_16;
    }
    if ( v2 > 5 )
    {
      if ( (unsigned int)(v2 - 254) <= 1 )
        goto LABEL_16;
      goto LABEL_13;
    }
    if ( strcmp(buf->currentURL.file, "-") )
    {
      if ( msg->length + 1 >= msg->area_size )
        Strgrow(msg);
      v3 = msg->length;
      msg->ptr[v3] = 32;
      msg->length = v3 + 1;
      msg->ptr[msg->length] = 0;
      v4 = InnerCharset;
      v5 = SystemCharset;
      v6 = Strnew_charp(buf->currentURL.real_file);
      v8 = wc_Str_conv(v6, v5, v4)->ptr;
      Strcat_charp(msg, v8);
    }
  }
LABEL_16:
  addnstr_sup(msg->ptr, COLS - 1);
}

//----- (08072EA3) --------------------------------------------------------
void __cdecl gotoLine(Buffer *buf, int n)
{
  Line *l; // [esp+28h] [ebp-30h]
  Line *la; // [esp+28h] [ebp-30h]
  char msg[32]; // [esp+2Ch] [ebp-2Ch] BYREF
  unsigned int v5; // [esp+4Ch] [ebp-Ch]

  v5 = __readgsdword(0x14u);
  l = buf->firstLine;
  if ( l )
  {
    if ( buf->pagerSource && (buf->bufferprop & 0x40) == 0 )
    {
      if ( buf->lastLine->linenumber < n )
        getNextPage(buf, n - buf->lastLine->linenumber);
      while ( buf->lastLine->linenumber < n && getNextPage(buf, 1) )
        ;
    }
    if ( l->linenumber <= n )
    {
      if ( buf->lastLine->linenumber >= n )
      {
        while ( l )
        {
          if ( l->linenumber >= n )
          {
            buf->currentLine = l;
            if ( buf->topLine->linenumber > n || buf->topLine->linenumber + buf->LINES <= n )
              buf->topLine = lineSkip(buf, l, ((buf->LINES >= 0) + ~buf->LINES) >> 1, 0);
            return;
          }
          l = l->next;
        }
      }
      else
      {
        la = buf->lastLine;
        sprintf(msg, "Last line is #%ld", la->linenumber);
        set_delayed_message(msg);
        buf->currentLine = la;
        buf->topLine = lineSkip(buf, buf->currentLine, 1 - buf->LINES, 0);
      }
    }
    else
    {
      sprintf(msg, "First line is #%ld", l->linenumber);
      set_delayed_message(msg);
      buf->currentLine = l;
      buf->topLine = buf->currentLine;
    }
  }
}

//----- (080730B4) --------------------------------------------------------
void __cdecl gotoRealLine(Buffer *buf, int n)
{
  Line *l; // [esp+28h] [ebp-30h]
  Line *la; // [esp+28h] [ebp-30h]
  char msg[32]; // [esp+2Ch] [ebp-2Ch] BYREF
  unsigned int v5; // [esp+4Ch] [ebp-Ch]

  v5 = __readgsdword(0x14u);
  l = buf->firstLine;
  if ( l )
  {
    if ( buf->pagerSource && (buf->bufferprop & 0x40) == 0 )
    {
      if ( buf->lastLine->real_linenumber < n )
        getNextPage(buf, n - buf->lastLine->real_linenumber);
      while ( buf->lastLine->real_linenumber < n && getNextPage(buf, 1) )
        ;
    }
    if ( l->real_linenumber <= n )
    {
      if ( buf->lastLine->real_linenumber >= n )
      {
        while ( l )
        {
          if ( l->real_linenumber >= n )
          {
            buf->currentLine = l;
            if ( buf->topLine->real_linenumber > n || buf->topLine->real_linenumber + buf->LINES <= n )
              buf->topLine = lineSkip(buf, l, ((buf->LINES >= 0) + ~buf->LINES) >> 1, 0);
            return;
          }
          l = l->next;
        }
      }
      else
      {
        la = buf->lastLine;
        sprintf(msg, "Last line is #%ld", la->real_linenumber);
        set_delayed_message(msg);
        buf->currentLine = la;
        buf->topLine = lineSkip(buf, buf->currentLine, 1 - buf->LINES, 0);
      }
    }
    else
    {
      sprintf(msg, "First line is #%ld", l->real_linenumber);
      set_delayed_message(msg);
      buf->currentLine = l;
      buf->topLine = buf->currentLine;
    }
  }
}

//----- (080732C5) --------------------------------------------------------
Buffer *__cdecl listBuffer(Buffer *top, Buffer *current)
{
  int c; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]

  c = 0;
  move(0, 0);
  if ( useColor )
  {
    setfcolor(basic_color);
    setbcolor(bg_color);
  }
  clrtobotx();
  for ( i = 0; LINES - 1 > i; ++i )
  {
    if ( top == current )
    {
      c = i;
      standout();
    }
    writeBufferName(top, i);
    if ( top == current )
    {
      standend();
      clrtoeolx();
      move(i, 0);
      toggle_stand();
    }
    else
    {
      clrtoeolx();
    }
    if ( !top->nextBuffer )
    {
      move(i + 1, 0);
      clrtobotx();
      break;
    }
    top = top->nextBuffer;
  }
  standout();
  message("Buffer selection mode: SPC for select / D for delete buffer", 0, 0);
  standend();
  move(c, 0);
  refresh();
  return top->nextBuffer;
}

//----- (08073401) --------------------------------------------------------
Buffer *__cdecl selectBuffer(Buffer *firstbuf, Buffer *currentbuf, char *selectchar)
{
  char v3; // al
  Buffer *topbuf; // [esp+10h] [ebp-28h]
  Buffer *buf; // [esp+14h] [ebp-24h]
  int sclimit; // [esp+18h] [ebp-20h]
  int maxbuf; // [esp+1Ch] [ebp-1Ch]
  int spoint; // [esp+20h] [ebp-18h]
  int cpoint; // [esp+24h] [ebp-14h]
  int i; // [esp+28h] [ebp-10h]
  int ia; // [esp+28h] [ebp-10h]
  char c; // [esp+2Fh] [ebp-9h]

  sclimit = LINES - 1;
  cpoint = 0;
  i = 0;
  for ( buf = firstbuf; buf; buf = buf->nextBuffer )
  {
    if ( buf == currentbuf )
      cpoint = i;
    ++i;
  }
  maxbuf = i;
  if ( cpoint < sclimit )
  {
    topbuf = firstbuf;
    spoint = cpoint;
  }
  else
  {
    spoint = sclimit / 2;
    topbuf = nthBuffer(firstbuf, cpoint - sclimit / 2);
  }
  listBuffer(topbuf, currentbuf);
  while ( 1 )
  {
    while ( 1 )
    {
      c = do_getch();
      if ( c == 27 )
      {
        c = do_getch();
        if ( c == 91 || c == 79 )
        {
          v3 = do_getch();
          c = v3;
          if ( v3 == 66 )
          {
            c = 106;
          }
          else if ( v3 > 66 )
          {
            if ( v3 == 67 )
            {
              c = 32;
            }
            else if ( v3 == 68 )
            {
              c = 66;
            }
          }
          else if ( v3 == 65 )
          {
            c = 107;
          }
        }
      }
      if ( c == 16 )
        goto LABEL_36;
      if ( c > 16 )
        break;
      if ( c != 14 )
        goto LABEL_42;
LABEL_31:
      if ( sclimit - 1 <= spoint )
      {
        if ( maxbuf - 1 > cpoint )
        {
          topbuf = currentbuf;
          currentbuf = currentbuf->nextBuffer;
          ++cpoint;
          spoint = 1;
          listBuffer(topbuf, currentbuf);
        }
        goto LABEL_43;
      }
      if ( currentbuf->nextBuffer )
      {
        writeBufferName(currentbuf, spoint);
        currentbuf = currentbuf->nextBuffer;
        ++cpoint;
        ++spoint;
        standout();
        writeBufferName(currentbuf, spoint);
        standend();
        move(spoint, 0);
        toggle_stand();
        goto LABEL_43;
      }
    }
    if ( c == 106 )
      goto LABEL_31;
    if ( c != 107 )
      break;
LABEL_36:
    if ( spoint <= 0 )
    {
      if ( cpoint > 0 )
      {
        ia = cpoint - sclimit;
        if ( cpoint - sclimit < 0 )
          ia = 0;
        spoint = --cpoint - ia;
        currentbuf = nthBuffer(firstbuf, cpoint);
        topbuf = nthBuffer(firstbuf, ia);
        listBuffer(topbuf, currentbuf);
      }
    }
    else
    {
      writeBufferName(currentbuf, spoint--);
      currentbuf = nthBuffer(topbuf, spoint);
      --cpoint;
      standout();
      writeBufferName(currentbuf, spoint);
      standend();
      move(spoint, 0);
      toggle_stand();
    }
LABEL_43:
    move(spoint, 0);
    refresh();
  }
LABEL_42:
  *selectchar = c;
  return currentbuf;
}

//----- (080736FB) --------------------------------------------------------
void __cdecl reshapeBuffer(Buffer *buf)
{
  int v1; // eax
  int v2; // eax
  char *v3; // eax
  Buffer sbuf; // [esp+10h] [ebp-158h] BYREF
  URLFile h; // [esp+114h] [ebp-54h] BYREF
  URLFile f; // [esp+134h] [ebp-34h] BYREF
  int n; // [esp+154h] [ebp-14h]
  Line *cur; // [esp+158h] [ebp-10h]
  wc_uint8 old_auto_detect; // [esp+15Fh] [ebp-9h]

  old_auto_detect = WcOption.auto_detect;
  if ( buf->need_reshape )
  {
    buf->need_reshape = 0;
    if ( showLineNum )
      v1 = 6;
    else
      v1 = 1;
    v2 = COLS - v1;
    if ( v2 < 0 )
      LOWORD(v2) = 0;
    buf->width = v2;
    if ( buf->sourcefile )
    {
      init_stream(&f, 4, 0);
      v3 = buf->mailcap_source ? buf->mailcap_source : buf->sourcefile;
      examineFile(v3, &f);
      if ( f.stream )
      {
        copyBuffer(&sbuf, buf);
        clearBuffer(buf);
        while ( buf->frameset )
        {
          deleteFrameSet(buf->frameset);
          buf->frameset = popFrameTree(&buf->frameQ);
        }
        buf->href = 0;
        buf->name = 0;
        buf->img = 0;
        buf->formitem = 0;
        buf->formlist = 0;
        buf->linklist = 0;
        buf->maplist = 0;
        if ( buf->hmarklist )
          buf->hmarklist->nmark = 0;
        if ( buf->imarklist )
          buf->imarklist->nmark = 0;
        if ( buf->header_source )
        {
          if ( buf->currentURL.scheme != 4 || buf->mailcap_source || !strcmp(buf->currentURL.file, "-") )
          {
            init_stream(&h, 4, 0);
            examineFile(buf->header_source, &h);
            if ( h.stream )
            {
              readHeader(&h, buf, 1, 0);
              if ( !ISclose(h.stream) )
                h.stream = 0;
            }
          }
          else if ( buf->search_header )
          {
            readHeader(&f, buf, 1, 0);
          }
        }
        WcOption.auto_detect = 0;
        UseContentCharset = 0;
        if ( is_html_type(buf->type) )
          loadHTMLBuffer(&f, buf);
        else
          loadBuffer(&f, buf);
        if ( !ISclose(f.stream) )
          f.stream = 0;
        WcOption.auto_detect = old_auto_detect;
        UseContentCharset = 1;
        buf->height = LINES;
        if ( buf->firstLine && sbuf.firstLine )
        {
          cur = sbuf.currentLine;
          buf->pos = sbuf.currentLine->bpos + sbuf.pos;
          while ( cur->bpos && cur->prev )
            cur = cur->prev;
          if ( cur->real_linenumber <= 0 )
            gotoLine(buf, cur->linenumber);
          else
            gotoRealLine(buf, cur->real_linenumber);
          n = buf->currentLine->linenumber - buf->topLine->linenumber + sbuf.topLine->linenumber - cur->linenumber;
          if ( n )
          {
            buf->topLine = lineSkip(buf, buf->topLine, n, 0);
            if ( cur->real_linenumber <= 0 )
              gotoLine(buf, cur->linenumber);
            else
              gotoRealLine(buf, cur->real_linenumber);
          }
          buf->pos -= buf->currentLine->bpos;
          if ( !FoldLine || is_html_type(buf->type) )
            buf->currentColumn = sbuf.currentColumn;
          else
            buf->currentColumn = 0;
          arrangeCursor(buf);
        }
        if ( (buf->check_url & 1) != 0 )
          chkURLBuffer(buf);
        if ( (buf->check_url & 2) != 0 )
          chkNMIDBuffer(buf);
        if ( buf->real_scheme == 7 || buf->real_scheme == 9 )
          reAnchorNewsheader(buf);
        formResetBuffer(buf, sbuf.formitem);
      }
    }
  }
}

//----- (08073C16) --------------------------------------------------------
void __cdecl copyBuffer(Buffer *a, Buffer *b)
{
  readBufferCache(b);
  bcopy(b, a, 0x104u);
}

//----- (08073C43) --------------------------------------------------------
Buffer *__cdecl prevBuffer(Buffer *first, Buffer *buf)
{
  while ( first && first->nextBuffer != buf )
    first = first->nextBuffer;
  return first;
}

//----- (08073C70) --------------------------------------------------------
int __cdecl writeBufferCache(Buffer *buf)
{
  unsigned int v2; // eax
  unsigned int v3; // eax
  unsigned int v4; // eax
  int colorflag; // [esp+10h] [ebp-18h] BYREF
  Line *l; // [esp+14h] [ebp-14h]
  FILE *cache; // [esp+18h] [ebp-10h]
  Str tmp; // [esp+1Ch] [ebp-Ch]

  cache = 0;
  if ( buf->savecache )
    return -1;
  if ( !buf->firstLine )
    goto _error1;
  tmp = tmpfname(3, 0);
  buf->savecache = tmp->ptr;
  cache = fopen(buf->savecache, aWr);
  if ( !cache )
    goto _error1;
  if ( !fwrite(&buf->currentLine->linenumber, 4u, 1u, cache) || !fwrite(&buf->topLine->linenumber, 4u, 1u, cache) )
  {
_error:
    fclose(cache);
    unlink(buf->savecache);
_error1:
    buf->savecache = 0;
    return -1;
  }
  for ( l = buf->firstLine; l; l = l->next )
  {
    if ( !fwrite(&l->real_linenumber, 4u, 1u, cache) )
      goto _error;
    if ( !fwrite(&l->usrflags, 2u, 1u, cache) )
      goto _error;
    if ( !fwrite(&l->width, 4u, 1u, cache) )
      goto _error;
    if ( !fwrite(&l->len, 4u, 1u, cache) )
      goto _error;
    if ( !fwrite(&l->size, 4u, 1u, cache) )
      goto _error;
    if ( !fwrite(&l->bpos, 4u, 1u, cache) )
      goto _error;
    if ( !fwrite(&l->bwidth, 4u, 1u, cache) )
      goto _error;
    if ( !l->bpos )
    {
      v2 = fwrite(l->lineBuf, 1u, l->size, cache);
      if ( v2 < l->size )
        goto _error;
      v3 = fwrite(l->propBuf, 2u, l->size, cache);
      if ( v3 < l->size )
        goto _error;
    }
    colorflag = l->colorBuf != 0;
    if ( !fwrite(&colorflag, 4u, 1u, cache) )
      goto _error;
    if ( colorflag )
    {
      if ( !l->bpos )
      {
        v4 = fwrite(l->colorBuf, 1u, l->size, cache);
        if ( v4 < l->size )
          goto _error;
      }
    }
  }
  fclose(cache);
  return 0;
}

//----- (08073FE8) --------------------------------------------------------
int __cdecl readBufferCache(Buffer *buf)
{
  int result; // eax
  char *v2; // eax
  Linecolor *v3; // eax
  int colorflag; // [esp+10h] [ebp-28h] BYREF
  int tlnum; // [esp+14h] [ebp-24h] BYREF
  int clnum; // [esp+18h] [ebp-20h] BYREF
  int lnum; // [esp+1Ch] [ebp-1Ch]
  Line *basel; // [esp+20h] [ebp-18h]
  Line *prevl; // [esp+24h] [ebp-14h]
  Line *l; // [esp+28h] [ebp-10h]
  FILE *cache; // [esp+2Ch] [ebp-Ch]

  l = 0;
  prevl = 0;
  basel = 0;
  lnum = 0;
  if ( !buf->savecache )
    return -1;
  cache = fopen(buf->savecache, &aWr[2]);
  if ( cache && fread(&clnum, 4u, 1u, cache) && fread(&tlnum, 4u, 1u, cache) )
  {
    while ( !feof(cache) )
    {
      ++lnum;
      prevl = l;
      l = (Line *)GC_malloc(52);
      l->prev = prevl;
      if ( prevl )
        prevl->next = l;
      else
        buf->firstLine = l;
      l->linenumber = lnum;
      if ( lnum == clnum )
        buf->currentLine = l;
      if ( lnum == tlnum )
        buf->topLine = l;
      if ( !fread(&l->real_linenumber, 4u, 1u, cache)
        || !fread(&l->usrflags, 2u, 1u, cache)
        || !fread(&l->width, 4u, 1u, cache)
        || !fread(&l->len, 4u, 1u, cache)
        || !fread(&l->size, 4u, 1u, cache)
        || !fread(&l->bpos, 4u, 1u, cache)
        || !fread(&l->bwidth, 4u, 1u, cache) )
      {
        break;
      }
      if ( l->bpos )
      {
        if ( !basel )
          break;
        l->lineBuf = &basel->lineBuf[l->bpos];
        l->propBuf = &basel->propBuf[l->bpos];
      }
      else
      {
        basel = l;
        v2 = (char *)GC_malloc_atomic(l->size + 1);
        l->lineBuf = v2;
        fread(l->lineBuf, 1u, l->size, cache);
        l->lineBuf[l->size] = 0;
        l->propBuf = (Lineprop *)GC_malloc_atomic(2 * l->size);
        fread(l->propBuf, 2u, l->size, cache);
      }
      if ( !fread(&colorflag, 4u, 1u, cache) )
        break;
      if ( colorflag )
      {
        if ( l->bpos )
        {
          l->colorBuf = &basel->colorBuf[l->bpos];
        }
        else
        {
          v3 = (Linecolor *)GC_malloc_atomic(l->size);
          l->colorBuf = v3;
          fread(l->colorBuf, 1u, l->size, cache);
        }
      }
      else
      {
        l->colorBuf = 0;
      }
    }
    buf->lastLine = prevl;
    buf->lastLine->next = 0;
    fclose(cache);
    unlink(buf->savecache);
    buf->savecache = 0;
    result = 0;
  }
  else
  {
    buf->savecache = 0;
    result = -1;
  }
  return result;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);
// 804A51C: using guessed type int __cdecl GC_malloc_atomic(_DWORD);

//----- (08074428) --------------------------------------------------------
void effect_anchor_start()
{
  if ( useColor )
    setfcolor(anchor_color);
  else
    underline();
}

//----- (0807444D) --------------------------------------------------------
void effect_anchor_end()
{
  if ( useColor )
    setfcolor(basic_color);
  else
    underlineend();
}

//----- (08074472) --------------------------------------------------------
void effect_image_start()
{
  if ( useColor )
    setfcolor(image_color);
  else
    standout();
}

//----- (08074497) --------------------------------------------------------
void effect_image_end()
{
  if ( useColor )
    setfcolor(basic_color);
  else
    standend();
}

//----- (080744BC) --------------------------------------------------------
void effect_form_start()
{
  if ( useColor )
    setfcolor(form_color);
  else
    standout();
}

//----- (080744E1) --------------------------------------------------------
void effect_form_end()
{
  if ( useColor )
    setfcolor(basic_color);
  else
    standend();
}

//----- (08074506) --------------------------------------------------------
void effect_mark_start()
{
  if ( useColor )
    setbcolor(mark_color);
  else
    standout();
}

//----- (0807452B) --------------------------------------------------------
void effect_mark_end()
{
  if ( useColor )
    setbcolor(bg_color);
  else
    standend();
}

//----- (08074550) --------------------------------------------------------
void effect_active_start()
{
  if ( useColor )
  {
    if ( useActiveColor )
      setfcolor(active_color);
    underline();
  }
  else
  {
    bold();
  }
}

//----- (0807458A) --------------------------------------------------------
void effect_active_end()
{
  if ( useColor )
  {
    if ( useActiveColor )
      setfcolor(basic_color);
    underlineend();
  }
  else
  {
    boldend();
  }
}

//----- (080745C4) --------------------------------------------------------
void effect_visited_start()
{
  if ( useVisitedColor )
  {
    if ( useColor )
      setfcolor(visited_color);
  }
}

//----- (080745EB) --------------------------------------------------------
void effect_visited_end()
{
  if ( useVisitedColor )
  {
    if ( useColor )
      setfcolor(basic_color);
  }
}

//----- (08074612) --------------------------------------------------------
void fmTerm()
{
  if ( fmInitialized )
  {
    move(LINES - 1, 0);
    clrtoeolx();
    refresh();
    if ( activeImage )
      loadImage(0, 1);
    if ( use_mouse )
      mouse_end();
    reset_tty();
    fmInitialized = 0;
  }
}

//----- (0807467E) --------------------------------------------------------
void fmInit()
{
  if ( !fmInitialized )
  {
    initscr();
    term_raw();
    term_noecho();
    if ( displayImage )
      initImage();
  }
  fmInitialized = 1;
}

//----- (080746B5) --------------------------------------------------------
Str __cdecl make_lastline_link(Buffer *buf, char *title, char *url)
{
  Str result; // eax
  char *v4; // eax
  int v5; // eax
  int v6; // ebx
  ParsedURL *v7; // [esp+8h] [ebp-50h]
  ParsedURL pu; // [esp+10h] [ebp-48h] BYREF
  int i; // [esp+38h] [ebp-20h]
  int l; // [esp+3Ch] [ebp-1Ch]
  char *p; // [esp+40h] [ebp-18h]
  Lineprop *pr; // [esp+44h] [ebp-14h] BYREF
  Str u; // [esp+48h] [ebp-10h]
  Str s; // [esp+4Ch] [ebp-Ch]

  s = 0;
  l = COLS - 1;
  if ( title && *title )
  {
    s = Strnew_m_charp((char *)&aWr[6], title, 135048248, 0);
    for ( p = s->ptr; *p; ++p )
    {
      if ( (MYCTYPE_MAP[(unsigned __int8)*p] & 1) != 0 || (MYCTYPE_MAP[(unsigned __int8)*p] & 2) != 0 )
        *p = 32;
    }
    if ( url )
      Strcat_charp(s, (char *)&aWr[8]);
    l -= wtf_strwidth((wc_uchar *)s->ptr);
    if ( l <= 0 )
      return s;
  }
  if ( !url )
    return s;
  v7 = baseURL(buf);
  parseURL2(url, &pu, v7);
  u = parsedURL2Str(&pu);
  if ( DecodeURL )
  {
    v4 = url_unquote_conv(u->ptr, buf->document_charset);
    u = Strnew_charp(v4);
  }
  u = checkType(u, &pr, 0);
  if ( l > 4 && (v5 = wtf_strwidth((wc_uchar *)u->ptr), v5 > l) )
  {
    if ( !s )
      s = Strnew_size(COLS);
    for ( i = (l - 2) / 2; i && (pr[i] & 0x400) != 0; --i )
      ;
    Strcat_charp_n(s, u->ptr, i);
    Strcat_charp(s, "..");
    v6 = wtf_strwidth((wc_uchar *)u->ptr);
    for ( i = v6 + 1 - COLS + wtf_strwidth((wc_uchar *)s->ptr); u->length > i && (pr[i] & 0x400) != 0; ++i )
      ;
    Strcat_charp(s, &u->ptr[i]);
    result = s;
  }
  else if ( s )
  {
    savexmlstr_0(s, u);
    result = s;
  }
  else
  {
    result = u;
  }
  return result;
}

//----- (0807495D) --------------------------------------------------------
Str __cdecl make_lastline_message(Buffer *buf)
{
  char *v1; // eax
  long double v3; // fst6
  int v4; // eax
  _Str *v5; // [esp+4h] [ebp-54h]
  char *p_0; // [esp+20h] [ebp-38h]
  int l; // [esp+24h] [ebp-34h]
  int ll; // [esp+2Ch] [ebp-2Ch]
  Anchor *a_img; // [esp+34h] [ebp-24h]
  char *p; // [esp+38h] [ebp-20h]
  Anchor *a_0; // [esp+3Ch] [ebp-1Ch]
  MapArea *a; // [esp+40h] [ebp-18h]
  int sl; // [esp+44h] [ebp-14h]
  _Str *s; // [esp+48h] [ebp-10h]
  _Str *msg; // [esp+4Ch] [ebp-Ch]

  s = 0;
  sl = 0;
  if ( displayLink )
  {
    a = retrieveCurrentMapArea(buf);
    if ( a )
    {
      s = make_lastline_link(buf, a->alt, a->url);
    }
    else
    {
      a_0 = retrieveCurrentAnchor(buf);
      p = 0;
      if ( a_0 && a_0->title && *a_0->title )
      {
        p = a_0->title;
      }
      else
      {
        a_img = retrieveCurrentImg(buf);
        if ( a_img && a_img->title && *a_img->title )
          p = a_img->title;
      }
      if ( p || a_0 )
      {
        if ( a_0 )
          v1 = a_0->url;
        else
          v1 = 0;
        s = make_lastline_link(buf, p, v1);
      }
    }
    if ( s )
    {
      sl = wtf_strwidth((wc_uchar *)s->ptr);
      if ( COLS - 3 <= sl )
        return s;
    }
  }
  if ( use_mouse && mouse_action.lastline_str )
    msg = Strnew_charp(mouse_action.lastline_str);
  else
    msg = Strnew();
  if ( displayLineInfo && buf->currentLine && buf->lastLine )
  {
    ll = buf->lastLine->real_linenumber;
    if ( ll )
      v3 = (long double)ll;
    else
      v3 = 1.0;
    v5 = Sprintf(
           "%d/%d (%d%%)",
           buf->currentLine->real_linenumber,
           ll,
           (int)((long double)buf->currentLine->real_linenumber * 100.0 / v3 + 0.5));
    savexmlstr_0(msg, v5);
  }
  else
  {
    Strcat_charp(msg, "Viewing");
  }
  Strcat_charp(msg, " <");
  Strcat_charp(msg, buf->buffername);
  if ( s )
  {
    l = COLS - 3 - sl;
    if ( wtf_strwidth((wc_uchar *)msg->ptr) > l )
    {
      for ( p_0 = msg->ptr; *p_0; p_0 += WTF_LEN_MAP[(unsigned __int8)*p_0] )
      {
        v4 = WcOption.use_wide ? WTF_WIDTH_MAP[(unsigned __int8)*p_0] : WTF_WIDTH_MAP[(unsigned __int8)*p_0] != 0;
        l -= v4;
        if ( l < 0 )
          break;
      }
      Strtruncate(msg, p_0 - msg->ptr);
    }
    Strcat_charp(msg, "> ");
    savexmlstr_0(msg, s);
  }
  else
  {
    Strcat_charp(msg, ">");
  }
  return msg;
}

//----- (08074C9B) --------------------------------------------------------
void __cdecl displayBuffer(Buffer *buf, int mode)
{
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v5; // eax
  wc_ces v6; // esi
  wc_ces v7; // ebx
  _Str *v8; // eax
  Str v9; // eax
  int ny; // [esp+28h] [ebp-10h]
  _Str *msg; // [esp+2Ch] [ebp-Ch]

  ny = 0;
  if ( buf )
  {
    if ( !buf->topLine && !readBufferCache(buf) )
      mode = 1;
    if ( !buf->width )
    {
      if ( showLineNum )
        v2 = 6;
      else
        v2 = 1;
      v3 = COLS - v2;
      if ( v3 < 0 )
        LOWORD(v3) = 0;
      buf->width = v3;
    }
    if ( !buf->height )
      buf->height = LINES;
    if ( showLineNum )
      v4 = 6;
    else
      v4 = 1;
    v5 = COLS - v4;
    if ( v5 < 0 )
      v5 = 0;
    if ( buf->width != v5 && (is_html_type(buf->type) || FoldLine) || buf->need_reshape )
    {
      buf->need_reshape = 1;
      reshapeBuffer(buf);
    }
    if ( showLineNum )
    {
      if ( buf->lastLine && buf->lastLine->real_linenumber > 0 )
        buf->rootX = (int)(log((long double)buf->lastLine->real_linenumber + 0.1) / 2.302585092994046) + 2;
      if ( buf->rootX <= 4 )
        buf->rootX = 5;
      if ( buf->rootX > COLS )
        buf->rootX = COLS;
    }
    else
    {
      buf->rootX = 0;
    }
    buf->COLS = COLS - buf->rootX;
    if ( nTab > 1 || mouse_action.menu_str )
    {
      if ( mode == 1 || mode == 4 )
        calcTabPos();
      ny = LastTab->y + 2;
      if ( LINES - 1 < ny )
        ny = LINES - 1;
    }
    if ( buf->rootY != ny || buf->LINES != LINES - 1 - ny )
    {
      buf->rootY = ny;
      buf->LINES = LINES - ny - 1;
      arrangeCursor(buf);
      mode = 4;
    }
    if ( mode == 1 || mode == 3 || mode == 4 || buf->topLine != cline || buf->currentColumn != ccolumn )
    {
      if ( activeImage && (mode == 4 || buf->topLine != cline || buf->currentColumn != ccolumn) )
      {
        if ( draw_image_flag )
          clear();
        clearImage();
        loadImage(buf, 1);
        ++image_touch;
        draw_image_flag = 0;
      }
      redrawNLine(buf, LINES - 1);
      cline = buf->topLine;
      ccolumn = buf->currentColumn;
    }
    if ( !buf->topLine )
      buf->topLine = buf->firstLine;
    if ( buf->need_reshape )
    {
      displayBuffer(buf, 1);
    }
    else
    {
      drawAnchorCursor(buf);
      msg = make_lastline_message(buf);
      if ( !buf->firstLine )
        Strcat_charp(msg, "\tNo Line");
      if ( delayed_msg )
      {
        disp_message(delayed_msg, 0);
        delayed_msg = 0;
        refresh();
      }
      standout();
      message(msg->ptr, buf->rootX + buf->cursorX, buf->cursorY + buf->rootY);
      standend();
      v6 = SystemCharset;
      v7 = InnerCharset;
      v8 = Strnew_charp(buf->buffername);
      v9 = wc_Str_conv_strict(v8, v7, v6);
      term_title(v9->ptr);
      refresh();
      if ( activeImage && displayImage )
      {
        if ( buf->img )
          drawImage();
      }
    }
  }
}

//----- (08075138) --------------------------------------------------------
void __cdecl drawAnchorCursor0(Buffer *buf, AnchorList *al_0, int hseq, int prevhseq, int tline, int eline, int active)
{
  Lineprop v7; // ax
  Anchor *an; // [esp+20h] [ebp-18h]
  Line *l; // [esp+24h] [ebp-14h]
  int j; // [esp+28h] [ebp-10h]
  int i; // [esp+2Ch] [ebp-Ch]

  l = buf->topLine;
  for ( j = 0; al_0->nanchor > j; ++j )
  {
    an = &al_0->anchors[j];
    if ( an->start.line >= tline )
    {
      if ( an->start.line >= eline )
        return;
      while ( 1 )
      {
        if ( !l )
          return;
        if ( l->linenumber == an->start.line )
          break;
        l = l->next;
      }
      if ( hseq >= 0 && an->hseq == hseq )
      {
        for ( i = an->start.pos; an->end.pos > i; ++i )
        {
          if ( (l->propBuf[i] & 0x70) != 0 )
          {
            v7 = l->propBuf[i];
            if ( active )
              LOBYTE(v7) = v7 | 0x80;
            else
              LOBYTE(v7) = v7 & 0x7F;
            l->propBuf[i] = v7;
          }
        }
        if ( active )
        {
LABEL_19:
          redrawLineRegion(buf, l, l->linenumber - tline + buf->rootY, an->start.pos, an->end.pos);
          continue;
        }
      }
      else if ( prevhseq >= 0 && an->hseq == prevhseq && active )
      {
        goto LABEL_19;
      }
    }
  }
}

//----- (0807531B) --------------------------------------------------------
void __cdecl drawAnchorCursor(Buffer *buf)
{
  int eline; // [esp+2Ch] [ebp-1Ch]
  int tline; // [esp+30h] [ebp-18h]
  int prevhseq; // [esp+34h] [ebp-14h]
  int hseq; // [esp+38h] [ebp-10h]
  Anchor *an; // [esp+3Ch] [ebp-Ch]

  if ( buf->firstLine && buf->hmarklist && (buf->href || buf->formitem) )
  {
    an = retrieveCurrentAnchor(buf);
    if ( !an )
      an = retrieveCurrentMap(buf);
    if ( an )
      hseq = an->hseq;
    else
      hseq = -1;
    tline = buf->topLine->linenumber;
    eline = tline + buf->LINES;
    prevhseq = buf->hmarklist->prevhseq;
    if ( buf->href )
    {
      drawAnchorCursor0(buf, buf->href, hseq, prevhseq, tline, eline, 1);
      drawAnchorCursor0(buf, buf->href, hseq, -1, tline, eline, 0);
    }
    if ( buf->formitem )
    {
      drawAnchorCursor0(buf, buf->formitem, hseq, prevhseq, tline, eline, 1);
      drawAnchorCursor0(buf, buf->formitem, hseq, -1, tline, eline, 0);
    }
    buf->hmarklist->prevhseq = hseq;
  }
}

//----- (080754C6) --------------------------------------------------------
void __cdecl redrawNLine(Buffer *buf, int n)
{
  int v2; // ebx
  int l_0; // [esp+10h] [ebp-18h]
  TabBuffer *t; // [esp+14h] [ebp-14h]
  int i; // [esp+18h] [ebp-10h]
  int ia; // [esp+18h] [ebp-10h]
  int ib; // [esp+18h] [ebp-10h]
  Line *l; // [esp+1Ch] [ebp-Ch]
  Line *la; // [esp+1Ch] [ebp-Ch]

  if ( useColor )
  {
    setfcolor(basic_color);
    setbcolor(bg_color);
  }
  if ( nTab > 1 || mouse_action.menu_str )
  {
    move(0, 0);
    if ( mouse_action.menu_str )
      addstr(mouse_action.menu_str);
    clrtoeolx();
    for ( t = FirstTab; t; t = t->nextTab )
    {
      move(t->y, t->x1);
      if ( t == CurrentTab )
        bold();
      addch(91);
      v2 = t->x2 - t->x1 - 1;
      l_0 = v2 - wtf_strwidth((wc_uchar *)t->currentBuffer->buffername);
      if ( l_0 < 0 )
        l_0 = 0;
      if ( l_0 > 1 )
        addnstr_sup((char *)&aWr[8], l_0 / 2);
      if ( t == CurrentTab )
        effect_active_start();
      addnstr(t->currentBuffer->buffername, t->x2 - t->x1 - l_0);
      if ( t == CurrentTab )
        effect_active_end();
      if ( l_0 + 1 > 1 )
        addnstr_sup((char *)&aWr[8], (l_0 + 1) / 2);
      move(t->y, t->x2);
      addch(93);
      if ( t == CurrentTab )
        boldend();
    }
    move(LastTab->y + 1, 0);
    for ( i = 0; i < COLS; ++i )
      addch(126);
  }
  ia = 0;
  for ( l = buf->topLine; buf->LINES > ia; l = l->next )
  {
    if ( buf->LINES - n <= ia || -n > ia )
      l = redrawLine(buf, l, ia + buf->rootY);
    if ( !l )
      break;
    ++ia;
  }
  if ( n > 0 )
  {
    move(ia + buf->rootY, 0);
    clrtobotx();
  }
  if ( activeImage && displayImage && buf->img )
  {
    move(buf->cursorY + buf->rootY, buf->rootX + buf->cursorX);
    ib = 0;
    for ( la = buf->topLine; buf->LINES > ib && la; la = la->next )
    {
      if ( buf->LINES - n <= ib || -n > ib )
        redrawLineImage(buf, la, ib + buf->rootY);
      ++ib;
    }
    getAllImage(buf);
  }
}

//----- (08075864) --------------------------------------------------------
Line *__cdecl redrawLine(Buffer *buf, Line *l, int i)
{
  Line *result; // eax
  ParsedURL *v4; // eax
  Str v5; // eax
  Lineprop v6; // dx
  Line *la; // [esp+28h] [ebp-80h]
  ParsedURL url; // [esp+34h] [ebp-74h] BYREF
  int vpos; // [esp+5Ch] [ebp-4Ch]
  int k; // [esp+60h] [ebp-48h]
  Anchor *a; // [esp+64h] [ebp-44h]
  Linecolor *pc; // [esp+68h] [ebp-40h]
  Lineprop *pr; // [esp+6Ch] [ebp-3Ch]
  char *p; // [esp+70h] [ebp-38h]
  int column; // [esp+74h] [ebp-34h]
  int delta; // [esp+78h] [ebp-30h]
  int ncol; // [esp+7Ch] [ebp-2Ch]
  int rcol; // [esp+80h] [ebp-28h]
  int pos; // [esp+84h] [ebp-24h]
  int j; // [esp+88h] [ebp-20h]
  char tmp[16]; // [esp+8Ch] [ebp-1Ch] BYREF
  unsigned int v22; // [esp+9Ch] [ebp-Ch]

  la = l;
  v22 = __readgsdword(0x14u);
  delta = 1;
  column = buf->currentColumn;
  vpos = -1;
  if ( !l )
  {
    if ( !buf->pagerSource )
      return 0;
    la = getNextPage(buf, buf->LINES + buf->rootY - i);
    if ( !la )
      return 0;
  }
  move(i, 0);
  if ( showLineNum )
  {
    if ( !buf->rootX )
    {
      if ( buf->lastLine->real_linenumber > 0 )
        buf->rootX = (int)(log((long double)buf->lastLine->real_linenumber + 0.1) / 2.302585092994046) + 2;
      if ( buf->rootX <= 4 )
        buf->rootX = 5;
      if ( buf->rootX > COLS )
        buf->rootX = COLS;
      buf->COLS = COLS - buf->rootX;
    }
    if ( !la->real_linenumber || la->bpos )
      sprintf(tmp, "%*s ", buf->rootX - 1, (const char *)&unk_80CAC72);
    else
      sprintf(tmp, "%*ld:", buf->rootX - 1, la->real_linenumber);
    addstr(tmp);
  }
  move(i, buf->rootX);
  if ( la->width < 0 )
    la->width = calcPosition(la->lineBuf, la->propBuf, la->len, la->len, 0, 0);
  if ( la->len && la->width - 1 >= column )
  {
    pos = columnPos(la, column);
    p = &la->lineBuf[pos];
    pr = &la->propBuf[pos];
    if ( useColor && la->colorBuf )
      pc = &la->colorBuf[pos];
    else
      pc = 0;
    rcol = calcPosition(la->lineBuf, la->propBuf, la->len, pos, 0, 0);
    for ( j = 0; rcol - column < buf->COLS && j + pos < la->len; j += delta )
    {
      if ( useVisitedColor )
      {
        if ( pos + j >= vpos && (pr[j] & 0x4000) == 0 )
        {
          a = retrieveAnchor(buf->href, la->linenumber, pos + j);
          if ( a )
          {
            v4 = baseURL(buf);
            parseURL2(a->url, &url, v4);
            v5 = parsedURL2Str(&url);
            if ( getHashHist(URLHist, v5->ptr) )
            {
              for ( k = a->start.pos; a->end.pos > k; ++k )
              {
                v6 = pr[k - pos];
                HIBYTE(v6) |= 0x40u;
                pr[k - pos] = v6;
              }
            }
            vpos = a->end.pos;
          }
        }
      }
      delta = wtf_len((wc_uchar *)&p[j]);
      ncol = calcPosition(la->lineBuf, la->propBuf, la->len, delta + pos + j, 0, 0);
      if ( ncol - column > buf->COLS )
        break;
      if ( pc )
        do_color(pc[j]);
      if ( rcol >= column )
      {
        if ( p[j] == 9 )
        {
          while ( rcol < ncol )
          {
            addChar(32, 0);
            ++rcol;
          }
        }
        else
        {
          addMChar(&p[j], pr[j], delta);
        }
        rcol = ncol;
      }
      else
      {
        for ( rcol = column; rcol < ncol; ++rcol )
          addChar(32, 0);
      }
    }
    if ( somode )
    {
      somode = 0;
      standend();
    }
    if ( ulmode )
    {
      ulmode = 0;
      underlineend();
    }
    if ( bomode )
    {
      bomode = 0;
      boldend();
    }
    if ( emph_mode )
    {
      emph_mode = 0;
      boldend();
    }
    if ( anch_mode )
    {
      anch_mode = 0;
      effect_anchor_end();
    }
    if ( imag_mode )
    {
      imag_mode = 0;
      effect_image_end();
    }
    if ( form_mode )
    {
      form_mode = 0;
      effect_form_end();
    }
    if ( visited_mode )
    {
      visited_mode = 0;
      effect_visited_end();
    }
    if ( active_mode )
    {
      active_mode = 0;
      effect_active_end();
    }
    if ( mark_mode )
    {
      mark_mode = 0;
      effect_mark_end();
    }
    if ( graph_mode )
    {
      graph_mode = 0;
      graphend();
    }
    if ( color_mode )
      do_color(0);
    if ( rcol - column < buf->COLS )
      clrtoeolx();
    result = la;
  }
  else
  {
    clrtoeolx();
    result = la;
  }
  return result;
}

//----- (08075F31) --------------------------------------------------------
Line *__cdecl redrawLineImage(Buffer *buf, Line *l, int i)
{
  int v4; // ebx
  ParsedURL *v5; // [esp+4h] [ebp-74h]
  ImageCache *cache; // [esp+3Ch] [ebp-3Ch]
  Image *image; // [esp+40h] [ebp-38h]
  int h; // [esp+44h] [ebp-34h]
  int w; // [esp+48h] [ebp-30h]
  int sy; // [esp+4Ch] [ebp-2Ch]
  int sx; // [esp+50h] [ebp-28h]
  int y; // [esp+54h] [ebp-24h]
  int x; // [esp+58h] [ebp-20h]
  Anchor *a; // [esp+5Ch] [ebp-1Ch]
  int column; // [esp+60h] [ebp-18h]
  int rcol; // [esp+64h] [ebp-14h]
  int pos; // [esp+68h] [ebp-10h]
  int j; // [esp+6Ch] [ebp-Ch]

  column = buf->currentColumn;
  if ( !l )
    return 0;
  if ( l->width < 0 )
    l->width = calcPosition(l->lineBuf, l->propBuf, l->len, l->len, 0, 0);
  if ( !l->len || l->width - 1 < column )
    return l;
  pos = columnPos(l, column);
  rcol = calcPosition(l->lineBuf, l->propBuf, l->len, pos, 0, 0);
  for ( j = 0; rcol - column < buf->COLS && j + pos < l->len; ++j )
  {
    if ( rcol - column >= 0 )
    {
      a = retrieveAnchor(buf->img, l->linenumber, pos + j);
      if ( a )
      {
        if ( a->image )
        {
          if ( a->image->touch < image_touch )
          {
            image = a->image;
            v4 = buf->image_flag;
            v5 = baseURL(buf);
            image->cache = getImage(image, v5, v4);
            cache = image->cache;
            if ( cache )
            {
              if ( image->width < 0 && cache->width > 0 || image->height < 0 && cache->height > 0 )
              {
                image->width = cache->width;
                image->height = cache->height;
                buf->need_reshape = 1;
              }
              x = (int)((long double)(rcol - column + buf->rootX) * pixel_per_char);
              y = (int)((long double)i * pixel_per_line);
              sx = (int)((long double)(rcol - calcPosition(l->lineBuf, l->propBuf, l->len, a->start.pos, 0, 0))
                       * pixel_per_char);
              sy = (int)((long double)(l->linenumber - image->y) * pixel_per_line);
              if ( sx || x + image->xoffset < 0 )
                sx -= image->xoffset;
              else
                x += image->xoffset;
              if ( sy || y + image->yoffset < 0 )
                sy -= image->yoffset;
              else
                y += image->yoffset;
              if ( image->width <= 0 )
                w = (int)(pixel_per_char * 8.0 - (long double)sx);
              else
                w = image->width - sx;
              if ( image->height <= 0 )
                h = (int)(pixel_per_line - (long double)sy);
              else
                h = image->height - sy;
              if ( (int)((long double)(buf->rootX + buf->COLS) * pixel_per_char - (long double)x) < w )
                w = (int)((long double)(buf->rootX + buf->COLS) * pixel_per_char - (long double)x);
              if ( (int)((long double)(LINES - 1) * pixel_per_line - (long double)y) < h )
                h = (int)((long double)(LINES - 1) * pixel_per_line - (long double)y);
              addImage(cache, x, y, sx, sy, w, h);
              image->touch = image_touch;
              draw_image_flag = 1;
            }
          }
        }
      }
    }
    rcol = calcPosition(l->lineBuf, l->propBuf, l->len, pos + j + 1, 0, 0);
  }
  return l;
}

//----- (0807648A) --------------------------------------------------------
int __cdecl redrawLineRegion(Buffer *buf, Line *l, int i, int bpos, int epos)
{
  ParsedURL *v6; // eax
  Str v7; // eax
  Lineprop v8; // dx
  ParsedURL url; // [esp+20h] [ebp-68h] BYREF
  int vpos; // [esp+48h] [ebp-40h]
  int k; // [esp+4Ch] [ebp-3Ch]
  Anchor *a; // [esp+50h] [ebp-38h]
  int ecol; // [esp+54h] [ebp-34h]
  int bcol; // [esp+58h] [ebp-30h]
  Linecolor *pc; // [esp+5Ch] [ebp-2Ch]
  Lineprop *pr; // [esp+60h] [ebp-28h]
  char *p; // [esp+64h] [ebp-24h]
  int column; // [esp+68h] [ebp-20h]
  int delta; // [esp+6Ch] [ebp-1Ch]
  int ncol; // [esp+70h] [ebp-18h]
  int rcol; // [esp+74h] [ebp-14h]
  int pos; // [esp+78h] [ebp-10h]
  int j; // [esp+7Ch] [ebp-Ch]

  delta = 1;
  column = buf->currentColumn;
  vpos = -1;
  if ( !l )
    return 0;
  pos = columnPos(l, column);
  p = &l->lineBuf[pos];
  pr = &l->propBuf[pos];
  if ( useColor && l->colorBuf )
    pc = &l->colorBuf[pos];
  else
    pc = 0;
  rcol = calcPosition(l->lineBuf, l->propBuf, l->len, pos, 0, 0);
  bcol = bpos - pos;
  ecol = epos - pos;
  for ( j = 0; rcol - column < buf->COLS && j + pos < l->len; j += delta )
  {
    if ( useVisitedColor )
    {
      if ( pos + j >= vpos && (pr[j] & 0x4000) == 0 )
      {
        a = retrieveAnchor(buf->href, l->linenumber, pos + j);
        if ( a )
        {
          v6 = baseURL(buf);
          parseURL2(a->url, &url, v6);
          v7 = parsedURL2Str(&url);
          if ( getHashHist(URLHist, v7->ptr) )
          {
            for ( k = a->start.pos; a->end.pos > k; ++k )
            {
              v8 = pr[k - pos];
              HIBYTE(v8) |= 0x40u;
              pr[k - pos] = v8;
            }
          }
          vpos = a->end.pos;
        }
      }
    }
    delta = wtf_len((wc_uchar *)&p[j]);
    ncol = calcPosition(l->lineBuf, l->propBuf, l->len, delta + pos + j, 0, 0);
    if ( ncol - column > buf->COLS )
      break;
    if ( pc )
      do_color(pc[j]);
    if ( j < bcol || j >= ecol )
      goto LABEL_33;
    if ( rcol >= column )
    {
      move(i, rcol - column + buf->rootX);
      if ( p[j] == 9 )
      {
        while ( rcol < ncol )
        {
          addChar(32, 0);
          ++rcol;
        }
      }
      else
      {
        addMChar(&p[j], pr[j], delta);
      }
LABEL_33:
      rcol = ncol;
      continue;
    }
    move(i, buf->rootX);
    for ( rcol = column; rcol < ncol; ++rcol )
      addChar(32, 0);
  }
  if ( somode )
  {
    somode = 0;
    standend();
  }
  if ( ulmode )
  {
    ulmode = 0;
    underlineend();
  }
  if ( bomode )
  {
    bomode = 0;
    boldend();
  }
  if ( emph_mode )
  {
    emph_mode = 0;
    boldend();
  }
  if ( anch_mode )
  {
    anch_mode = 0;
    effect_anchor_end();
  }
  if ( imag_mode )
  {
    imag_mode = 0;
    effect_image_end();
  }
  if ( form_mode )
  {
    form_mode = 0;
    effect_form_end();
  }
  if ( visited_mode )
  {
    visited_mode = 0;
    effect_visited_end();
  }
  if ( active_mode )
  {
    active_mode = 0;
    effect_active_end();
  }
  if ( mark_mode )
  {
    mark_mode = 0;
    effect_mark_end();
  }
  if ( graph_mode )
  {
    graph_mode = 0;
    graphend();
  }
  if ( color_mode )
    do_color(0);
  return rcol - column;
}

//----- (08076954) --------------------------------------------------------
void __cdecl do_effects(Lineprop m)
{
  if ( ulmode )
  {
    underlineend();
    ulmode = 0;
  }
  if ( somode )
  {
    standend();
    somode = 0;
  }
  if ( bomode )
  {
    boldend();
    bomode = 0;
  }
  if ( emph_mode )
  {
    boldend();
    emph_mode = 0;
  }
  if ( anch_mode )
  {
    effect_anchor_end();
    anch_mode = 0;
  }
  if ( imag_mode )
  {
    effect_image_end();
    imag_mode = 0;
  }
  if ( form_mode )
  {
    effect_form_end();
    form_mode = 0;
  }
  if ( visited_mode )
  {
    effect_visited_end();
    visited_mode = 0;
  }
  if ( active_mode )
  {
    effect_active_end();
    active_mode = 0;
  }
  if ( mark_mode )
  {
    effect_mark_end();
    mark_mode = 0;
  }
  if ( graph_mode )
  {
    graphend();
    graph_mode = 0;
  }
  if ( (m & 2) != 0 && !ulmode )
  {
    underline();
    ulmode = 1;
  }
  if ( (m & 4) != 0 && !somode )
  {
    standout();
    somode = 1;
  }
  if ( (m & 8) != 0 && !bomode )
  {
    bold();
    bomode = 1;
  }
  if ( (m & 8) != 0 && !emph_mode )
  {
    bold();
    emph_mode = 1;
  }
  if ( (m & 0x10) != 0 && !anch_mode )
  {
    effect_anchor_start();
    anch_mode = 1;
  }
  if ( (m & 0x20) != 0 && !imag_mode )
  {
    effect_image_start();
    imag_mode = 1;
  }
  if ( (m & 0x40) != 0 && !form_mode )
  {
    effect_form_start();
    form_mode = 1;
  }
  if ( (m & 0x4000) != 0 && !visited_mode )
  {
    effect_visited_start();
    visited_mode = 1;
  }
  if ( (m & 0x80) != 0 && !active_mode )
  {
    effect_active_start();
    active_mode = 1;
  }
  if ( (m & 1) != 0 && !mark_mode )
  {
    effect_mark_start();
    mark_mode = 1;
  }
}

//----- (08076BCD) --------------------------------------------------------
void __cdecl do_color(Linecolor c)
{
  if ( (c & 8) != 0 )
  {
    setfcolor(c & 7);
  }
  else if ( (color_mode & 8) != 0 )
  {
    setfcolor(basic_color);
  }
  if ( (c & 0x80u) == 0 )
  {
    if ( (color_mode & 0x80u) != 0 )
      setbcolor(bg_color);
  }
  else
  {
    setbcolor((c >> 4) & 7);
  }
  color_mode = c;
}

//----- (08076C55) --------------------------------------------------------
void __cdecl addChar(char c, Lineprop mode)
{
  char ca[12]; // [esp+1Ch] [ebp-Ch] BYREF

  ca[0] = c;
  addMChar(ca, mode, 1u);
}

//----- (08076C85) --------------------------------------------------------
void __cdecl addMChar(char *p, Lineprop mode, size_t len)
{
  Lineprop v3; // ax
  int v4; // eax
  unsigned __int8 v5; // al
  char buf[5]; // [esp+2Fh] [ebp-19h] BYREF
  int w; // [esp+34h] [ebp-14h] BYREF
  char **symbol; // [esp+38h] [ebp-10h]
  Lineprop m; // [esp+3Ch] [ebp-Ch]
  char c; // [esp+3Fh] [ebp-9h]

  LOBYTE(v3) = mode;
  HIBYTE(v3) = HIBYTE(mode) & 0xC0;
  m = v3;
  c = *p;
  if ( (mode & 0x400) == 0 )
  {
    do_effects(m);
    if ( (mode & 0x8000u) == 0 )
    {
      if ( (mode & 0x100) != 0 )
      {
        if ( c == 10 )
        {
          addch(32);
          return;
        }
        if ( c > 10 )
        {
          if ( c == 13 )
            return;
          if ( c == 127 )
          {
            addstr("^?");
            return;
          }
        }
        else if ( c == 9 )
        {
          addch(c);
          return;
        }
        addch(94);
        addch(c + 64);
      }
      else if ( (mode & 0x1000) != 0 )
      {
        v5 = wtf_get_code((wc_uchar *)p);
        sprintf(buf, "[%.2X]", v5 | 0x80);
        addstr(buf);
      }
      else
      {
        addmch(p, len);
      }
    }
    else
    {
      if ( (mode & 0x800) != 0 )
        v4 = 2;
      else
        v4 = 1;
      w = v4;
      c = (wtf_get_code((wc_uchar *)p) & 0x7F) - 32;
      if ( graph_ok() && c <= 31 )
      {
        if ( !graph_mode )
        {
          graphstart();
          graph_mode = 1;
        }
        if ( w == 2 && WcOption.use_wide )
          addstr(graph2_symbol[c]);
        else
          addch(*graph_symbol[c]);
      }
      else
      {
        symbol = get_symbol(DisplayCharset, &w);
        addstr(symbol[c]);
      }
    }
  }
}

//----- (08076E82) --------------------------------------------------------
void __cdecl record_err_message(char *s)
{
  char *v1; // eax

  if ( fmInitialized )
  {
    if ( !message_list )
      message_list = newGeneralList();
    if ( message_list->nitem >= LINES )
      popValue(message_list);
    v1 = allocStr(s, -1);
    pushValue(message_list, v1);
  }
}

//----- (08076EEF) --------------------------------------------------------
Buffer *message_list_panel()
{
  char *v0; // eax
  ListItem *p; // [esp+28h] [ebp-10h]
  _Str *tmp; // [esp+2Ch] [ebp-Ch]

  tmp = Strnew_size(LINES * COLS);
  Strcat_charp(
    tmp,
    "<html><head><title>List of error messages</title></head><body><h1>List of error messages</h1><table cellpadding=0>\n");
  if ( message_list )
  {
    for ( p = message_list->last; p; p = p->prev )
    {
      v0 = html_quote((char *)p->ptr);
      Strcat_m_charp(tmp, "<tr><td><pre>", v0, "</pre></td></tr>\n", 0);
    }
  }
  else
  {
    Strcat_charp(tmp, "<tr><td>(no message recorded)</td></tr>\n");
  }
  Strcat_charp(tmp, "</table></body></html>");
  return loadHTMLString(tmp);
}

//----- (08076FAF) --------------------------------------------------------
void __cdecl message(char *s, int return_x, int return_y)
{
  if ( fmInitialized )
  {
    move(LINES - 1, 0);
    addnstr(s, COLS - 1);
    clrtoeolx();
    move(return_y, return_x);
  }
}

//----- (0807700B) --------------------------------------------------------
void __cdecl _ZN10bdInetAddrC2Ej(char *s, int redraw_current)
{
  record_err_message(s);
  disp_message(s, redraw_current);
}

//----- (08077030) --------------------------------------------------------
void __cdecl disp_message_nsec(char *s, int redraw_current, int sec, int purge, int mouse)
{
  wc_ces v5; // esi
  wc_ces v6; // ebx
  _Str *v7; // eax
  Str v8; // eax

  if ( !QuietMessage[0] )
  {
    if ( fmInitialized )
    {
      if ( CurrentTab && CurrentTab->currentBuffer )
        message(
          s,
          CurrentTab->currentBuffer->cursorX + CurrentTab->currentBuffer->rootX,
          CurrentTab->currentBuffer->rootY + CurrentTab->currentBuffer->cursorY);
      else
        message(s, LINES - 1, 0);
      refresh();
      if ( mouse && use_mouse )
        mouse_active();
      sleep_till_anykey(sec, purge);
      if ( mouse && use_mouse )
        mouse_inactive();
      if ( CurrentTab && CurrentTab->currentBuffer )
      {
        if ( redraw_current )
          displayBuffer(CurrentTab->currentBuffer, 0);
      }
    }
    else
    {
      v5 = SystemCharset;
      v6 = InnerCharset;
      v7 = Strnew_charp(s);
      v8 = wc_Str_conv_strict(v7, v6, v5);
      fprintf(stderr, "%s\n", v8->ptr);
    }
  }
}

//----- (0807719C) --------------------------------------------------------
void __cdecl disp_message(char *s, int redraw_current)
{
  disp_message_nsec(s, redraw_current, 10, 0, 1);
}

//----- (080771CE) --------------------------------------------------------
void __cdecl disp_message_nomouse(char *s, int redraw_current)
{
  disp_message_nsec(s, redraw_current, 10, 0, 0);
}

//----- (08077200) --------------------------------------------------------
void __cdecl set_delayed_message(char *s)
{
  delayed_msg = allocStr(s, -1);
}

//----- (08077220) --------------------------------------------------------
void __cdecl cursorUp0(Buffer *buf, int n)
{
  if ( buf->cursorY <= 0 )
  {
    buf->topLine = lineSkip(buf, buf->topLine, -n, 0);
    if ( buf->currentLine->prev )
      buf->currentLine = buf->currentLine->prev;
    arrangeLine(buf);
  }
  else
  {
    cursorUpDown(buf, -1);
  }
}

//----- (0807729E) --------------------------------------------------------
void __cdecl cursorUp(Buffer *buf, int n)
{
  Line *l; // [esp+1Ch] [ebp-Ch]

  l = buf->currentLine;
  if ( buf->firstLine )
  {
    while ( buf->currentLine->prev && buf->currentLine->bpos )
      cursorUp0(buf, n);
    if ( buf->currentLine == buf->firstLine )
    {
      gotoLine(buf, l->linenumber);
      arrangeLine(buf);
    }
    else
    {
      do
        cursorUp0(buf, n);
      while ( buf->currentLine->prev
           && buf->currentLine->bpos
           && buf->currentLine->bwidth >= buf->currentColumn + buf->visualpos );
    }
  }
}

//----- (0807737B) --------------------------------------------------------
void __cdecl cursorDown0(Buffer *buf, int n)
{
  if ( buf->cursorY >= buf->LINES - 1 )
  {
    buf->topLine = lineSkip(buf, buf->topLine, n, 0);
    if ( buf->currentLine->next )
      buf->currentLine = buf->currentLine->next;
    arrangeLine(buf);
  }
  else
  {
    cursorUpDown(buf, 1);
  }
}

//----- (08077402) --------------------------------------------------------
void __cdecl cursorDown(Buffer *buf, int n)
{
  Line *l; // [esp+1Ch] [ebp-Ch]

  l = buf->currentLine;
  if ( buf->firstLine )
  {
    while ( buf->currentLine->next && buf->currentLine->next->bpos )
      cursorDown0(buf, n);
    if ( buf->currentLine == buf->lastLine )
    {
      gotoLine(buf, l->linenumber);
      arrangeLine(buf);
    }
    else
    {
      do
        cursorDown0(buf, n);
      while ( buf->currentLine->next
           && buf->currentLine->next->bpos
           && buf->currentLine->bwidth + buf->currentLine->width < buf->currentColumn + buf->visualpos );
    }
  }
}

//----- (080774F1) --------------------------------------------------------
void __cdecl cursorUpDown(Buffer *buf, int n)
{
  Line *cl_0; // [esp+1Ch] [ebp-Ch]

  cl_0 = buf->currentLine;
  if ( buf->firstLine )
  {
    buf->currentLine = currentLineSkip(buf, cl_0, n, 0);
    if ( buf->currentLine != cl_0 )
      arrangeLine(buf);
  }
}

//----- (0807754F) --------------------------------------------------------
void __cdecl cursorRight(Buffer *buf, int n)
{
  Lineprop *p; // [esp+28h] [ebp-20h]
  Line *l; // [esp+2Ch] [ebp-1Ch]
  int vpos2; // [esp+30h] [ebp-18h]
  int cpos; // [esp+34h] [ebp-14h]
  int delta; // [esp+38h] [ebp-10h]
  int deltaa; // [esp+38h] [ebp-10h]
  int i; // [esp+3Ch] [ebp-Ch]

  delta = 1;
  l = buf->currentLine;
  if ( buf->firstLine && (buf->pos != l->len || l->next && l->next->bpos) )
  {
    i = buf->pos;
    p = l->propBuf;
    while ( delta + i < l->len && (p[i + delta] & 0x400) != 0 )
      ++delta;
    if ( delta + i >= l->len )
    {
      if ( l->len )
      {
        if ( l->next && l->next->bpos )
        {
          cursorDown0(buf, 1);
          buf->pos = 0;
          arrangeCursor(buf);
          return;
        }
        for ( buf->pos = l->len - 1; buf->pos && (p[buf->pos] & 0x400) != 0; --buf->pos )
          ;
      }
      else
      {
        buf->pos = 0;
      }
    }
    else
    {
      buf->pos = delta + i;
    }
    cpos = calcPosition(l->lineBuf, l->propBuf, l->len, buf->pos, 0, 0);
    buf->visualpos = cpos + l->bwidth - buf->currentColumn;
    for ( deltaa = 1; deltaa + buf->pos < l->len && (p[deltaa + buf->pos] & 0x400) != 0; ++deltaa )
      ;
    vpos2 = calcPosition(l->lineBuf, l->propBuf, l->len, deltaa + buf->pos, 0, 0) - buf->currentColumn - 1;
    if ( buf->COLS <= vpos2 )
    {
      if ( n )
      {
        columnSkip(buf, n + vpos2 - buf->COLS - (vpos2 - buf->COLS) % n);
        buf->visualpos = cpos + l->bwidth - buf->currentColumn;
      }
    }
    buf->cursorX = buf->visualpos - l->bwidth;
  }
}

//----- (08077833) --------------------------------------------------------
void __cdecl cursorLeft(Buffer *buf, int n)
{
  Line *l; // [esp+30h] [ebp-18h]
  int cpos; // [esp+34h] [ebp-14h]
  int delta; // [esp+38h] [ebp-10h]
  int i; // [esp+3Ch] [ebp-Ch]

  delta = 1;
  l = buf->currentLine;
  if ( buf->firstLine )
  {
    i = buf->pos;
    while ( i - delta > 0 && (l->propBuf[i - delta] & 0x400) != 0 )
      ++delta;
    if ( i < delta )
    {
      if ( l->prev && l->bpos )
      {
        cursorUp0(buf, -1);
        buf->pos = buf->currentLine->len - 1;
        arrangeCursor(buf);
        return;
      }
      buf->pos = 0;
    }
    else
    {
      buf->pos = i - delta;
    }
    cpos = calcPosition(l->lineBuf, l->propBuf, l->len, buf->pos, 0, 0);
    buf->visualpos = cpos + l->bwidth - buf->currentColumn;
    if ( buf->visualpos - l->bwidth < 0 )
    {
      if ( n )
      {
        columnSkip(buf, buf->visualpos - n - l->bwidth - (buf->visualpos - l->bwidth) % n);
        buf->visualpos = cpos + l->bwidth - buf->currentColumn;
      }
    }
    buf->cursorX = buf->visualpos - l->bwidth;
  }
}

//----- (08077A04) --------------------------------------------------------
void __cdecl cursorHome(Buffer *buf)
{
  buf->visualpos = 0;
  buf->cursorY = 0;
  buf->cursorX = buf->cursorY;
}

//----- (08077A2A) --------------------------------------------------------
void __cdecl arrangeCursor(Buffer *buf)
{
  int v1; // esi
  int delta; // [esp+20h] [ebp-18h]
  int pos; // [esp+24h] [ebp-14h]
  int posa; // [esp+24h] [ebp-14h]
  int col2; // [esp+28h] [ebp-10h]
  int col; // [esp+2Ch] [ebp-Ch]

  delta = 1;
  if ( buf && buf->currentLine )
  {
    if ( buf->currentLine->linenumber - buf->topLine->linenumber >= buf->LINES
      || buf->currentLine->linenumber < buf->topLine->linenumber )
    {
      buf->topLine = lineSkip(buf, buf->currentLine, 0, 0);
    }
    while ( buf->pos < 0 && buf->currentLine->prev && buf->currentLine->bpos )
    {
      pos = buf->pos + buf->currentLine->prev->len;
      cursorUp0(buf, 1);
      buf->pos = pos;
    }
    while ( buf->pos >= buf->currentLine->len && buf->currentLine->next && buf->currentLine->next->bpos )
    {
      posa = buf->pos - buf->currentLine->len;
      cursorDown0(buf, 1);
      buf->pos = posa;
    }
    if ( buf->currentLine->len && buf->pos >= 0 )
    {
      if ( buf->pos >= buf->currentLine->len )
        buf->pos = buf->currentLine->len - 1;
    }
    else
    {
      buf->pos = 0;
    }
    while ( buf->pos > 0 && (buf->currentLine->propBuf[buf->pos] & 0x400) != 0 )
      --buf->pos;
    col = calcPosition(buf->currentLine->lineBuf, buf->currentLine->propBuf, buf->currentLine->len, buf->pos, 0, 0);
    while ( delta + buf->pos < buf->currentLine->len && (buf->currentLine->propBuf[delta + buf->pos] & 0x400) != 0 )
      ++delta;
    col2 = calcPosition(
             buf->currentLine->lineBuf,
             buf->currentLine->propBuf,
             buf->currentLine->len,
             delta + buf->pos,
             0,
             0);
    if ( buf->currentColumn > col || buf->COLS + buf->currentColumn < col2 )
    {
      buf->currentColumn = 0;
      if ( buf->COLS < col2 )
        columnSkip(buf, col);
    }
    buf->cursorY = buf->currentLine->linenumber - buf->topLine->linenumber;
    v1 = buf->currentLine->bwidth;
    buf->visualpos = v1
                   + calcPosition(
                       buf->currentLine->lineBuf,
                       buf->currentLine->propBuf,
                       buf->currentLine->len,
                       buf->pos,
                       0,
                       0)
                   - buf->currentColumn;
    buf->cursorX = buf->visualpos - buf->currentLine->bwidth;
  }
}

//----- (08077DD8) --------------------------------------------------------
void __cdecl arrangeLine(Buffer *buf)
{
  int cpos; // [esp+28h] [ebp-10h]
  int i; // [esp+2Ch] [ebp-Ch]

  if ( buf->firstLine )
  {
    buf->cursorY = buf->currentLine->linenumber - buf->topLine->linenumber;
    i = columnPos(buf->currentLine, buf->visualpos + buf->currentColumn - buf->currentLine->bwidth);
    cpos = calcPosition(buf->currentLine->lineBuf, buf->currentLine->propBuf, buf->currentLine->len, i, 0, 0)
         - buf->currentColumn;
    if ( cpos < 0 )
    {
      if ( buf->currentLine->len <= i )
      {
        buf->cursorX = 0;
        buf->pos = 0;
      }
      else
      {
        buf->cursorX = 0;
        buf->pos = i + 1;
      }
    }
    else
    {
      buf->cursorX = cpos;
      buf->pos = i;
    }
  }
}

//----- (08077EE9) --------------------------------------------------------
void __cdecl cursorXY(Buffer *buf, int x, int y)
{
  int oldX; // [esp+1Ch] [ebp-Ch]

  cursorUpDown(buf, y - buf->cursorY);
  if ( buf->cursorX <= x )
  {
    if ( buf->cursorX < x )
    {
      do
      {
        if ( buf->cursorX >= x )
          break;
        oldX = buf->cursorX;
        cursorRight(buf, buf->COLS / 2);
      }
      while ( buf->cursorX != oldX );
      if ( buf->cursorX > x )
        cursorLeft(buf, buf->COLS / 2);
    }
  }
  else
  {
    while ( buf->cursorX > x )
      cursorLeft(buf, buf->COLS / 2);
  }
}

//----- (08077FDF) --------------------------------------------------------
void __cdecl restorePosition(Buffer *buf, Buffer *orig)
{
  int v2; // eax
  int v3; // eax

  if ( orig->topLine )
    v2 = orig->topLine->linenumber - 1;
  else
    v2 = 0;
  buf->topLine = lineSkip(buf, buf->firstLine, v2, 0);
  if ( orig->currentLine )
    v3 = orig->currentLine->linenumber;
  else
    v3 = 1;
  gotoLine(buf, v3);
  buf->pos = orig->pos;
  if ( buf->currentLine && orig->currentLine )
    buf->pos += orig->currentLine->bpos - buf->currentLine->bpos;
  buf->currentColumn = orig->currentColumn;
  arrangeCursor(buf);
}

//----- (080780B8) --------------------------------------------------------
int __cdecl columnSkip(Buffer *buf, int offset)
{
  Line *l; // [esp+2Ch] [ebp-1Ch]
  int nlines; // [esp+30h] [ebp-18h]
  int column; // [esp+34h] [ebp-14h]
  int maxColumn; // [esp+38h] [ebp-10h]
  int maxColumna; // [esp+38h] [ebp-10h]
  int i; // [esp+3Ch] [ebp-Ch]

  column = offset + buf->currentColumn;
  nlines = buf->LINES + 1;
  maxColumn = 0;
  i = 0;
  for ( l = buf->topLine; i < nlines && l; l = l->next )
  {
    if ( l->width < 0 )
      l->width = calcPosition(l->lineBuf, l->propBuf, l->len, l->len, 0, 0);
    if ( l->width - 1 > maxColumn )
      maxColumn = l->width - 1;
    ++i;
  }
  maxColumna = 1 - buf->COLS + maxColumn;
  if ( column < maxColumna )
    maxColumna = column;
  if ( maxColumna < 0 )
    maxColumna = 0;
  if ( buf->currentColumn == maxColumna )
    return 0;
  buf->currentColumn = maxColumna;
  return 1;
}

//----- (080781C9) --------------------------------------------------------
int __cdecl columnPos(Line *line, int column)
{
  int i; // [esp+2Ch] [ebp-Ch]
  int ia; // [esp+2Ch] [ebp-Ch]

  for ( i = 1; line->len > i && calcPosition(line->lineBuf, line->propBuf, line->len, i, 0, 0) <= column; ++i )
    ;
  for ( ia = i - 1; ia > 0 && (line->propBuf[ia] & 0x400) != 0; --ia )
    ;
  return ia;
}

//----- (0807825D) --------------------------------------------------------
Line *__cdecl lineSkip(Buffer *buf, Line *line, int offset, int last)
{
  Line *l; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]

  l = currentLineSkip(buf, line, offset, last);
  if ( !nextpage_topline )
  {
    for ( i = buf->LINES - 1 + l->linenumber - buf->lastLine->linenumber; i > 0 && l->prev; --i )
      l = l->prev;
  }
  return l;
}

//----- (080782DE) --------------------------------------------------------
Line *__cdecl currentLineSkip(Buffer *buf, Line *line, int offset, int last)
{
  Line *l; // [esp+14h] [ebp-14h]
  int n; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]
  int ia; // [esp+1Ch] [ebp-Ch]

  l = line;
  if ( buf->pagerSource && (buf->bufferprop & 0x40) == 0 )
  {
    n = offset + line->linenumber + buf->LINES;
    if ( buf->lastLine->linenumber < n )
      getNextPage(buf, n - buf->lastLine->linenumber);
    while ( (last || buf->lastLine->linenumber < n) && getNextPage(buf, 1) )
      ;
    if ( last )
      l = buf->lastLine;
  }
  if ( !offset )
    return l;
  if ( offset <= 0 )
  {
    for ( ia = 0; -offset > ia && l->prev; ++ia )
      l = l->prev;
  }
  else
  {
    for ( i = 0; i < offset && l->next; ++i )
      l = l->next;
  }
  return l;
}

//----- (080783F7) --------------------------------------------------------
int __cdecl gethtmlcmd(char **s)
{
  char v1; // al
  int result; // eax
  char v3; // al
  int cmd; // [esp+20h] [ebp-98h]
  char *save; // [esp+24h] [ebp-94h]
  char *p; // [esp+28h] [ebp-90h]
  char cmdstr[128]; // [esp+2Ch] [ebp-8Ch] BYREF
  unsigned int v8; // [esp+ACh] [ebp-Ch]

  v8 = __readgsdword(0x14u);
  save = (*s)++;
  if ( (MYCTYPE_MAP[(unsigned __int8)**s] & 0xC) == 0 && **s != 95 && **s != 47 )
    return 0;
  if ( (MYCTYPE_MAP[(unsigned __int8)**s] & 4) != 0 )
    v1 = **s | 0x20;
  else
    v1 = **s;
  cmdstr[0] = v1;
  p = &cmdstr[1];
  ++*s;
  if ( cmdstr[0] == 47 )
  {
    while ( **s && (MYCTYPE_MAP[(unsigned __int8)**s] & 2) != 0 )
      ++*s;
  }
  while ( ((MYCTYPE_MAP[(unsigned __int8)**s] & 0xC) != 0 || **s == 95) && p - cmdstr <= 127 )
  {
    if ( (MYCTYPE_MAP[(unsigned __int8)**s] & 4) != 0 )
      v3 = **s | 0x20;
    else
      v3 = **s;
    *p++ = v3;
    ++*s;
  }
  if ( p - cmdstr == 128 )
  {
    *s = save + 1;
    result = 0;
  }
  else
  {
    *p = 0;
    cmd = getHash_si(&tagtable, cmdstr, 0);
    while ( **s && **s != 62 )
      ++*s;
    if ( **s == 62 )
      ++*s;
    result = cmd;
  }
  return result;
}

//----- (080786B3) --------------------------------------------------------
int __cdecl parse_ansi_color(char **str, Lineprop *effect, Linecolor *color)
{
  char *v4; // eax
  int v5; // eax
  char *q; // [esp+14h] [ebp-14h]
  char *qa; // [esp+14h] [ebp-14h]
  char *p; // [esp+18h] [ebp-10h]
  char *pa; // [esp+18h] [ebp-10h]
  char *pb; // [esp+18h] [ebp-10h]
  Lineprop e; // [esp+1Ch] [ebp-Ch]
  Linecolor c; // [esp+1Fh] [ebp-9h]

  p = *str;
  e = *effect;
  c = *color;
  if ( **str != 27 || p[1] != 91 )
    return 0;
  pa = p + 2;
  for ( q = pa; (MYCTYPE_MAP[(unsigned __int8)*q] & 8) != 0 || *q == 59; ++q )
    ;
  if ( *q != 109 )
    return 0;
  *str = q + 1;
  while ( 1 )
  {
    if ( *pa == 109 )
    {
      e = 0;
      c = 0;
      goto LABEL_47;
    }
    if ( (MYCTYPE_MAP[(unsigned __int8)*pa] & 8) == 0 )
      break;
    qa = pa;
    for ( pb = pa + 1; (MYCTYPE_MAP[(unsigned __int8)*pb] & 8) != 0; ++pb )
      ;
    v4 = allocStr(qa, pb - qa);
    v5 = atoi(v4);
    if ( v5 == 5 )
    {
LABEL_31:
      e = 8;
      goto LABEL_43;
    }
    if ( v5 > 5 )
    {
      if ( v5 == 39 )
      {
        c &= 0xF0u;
        goto LABEL_43;
      }
      if ( v5 > 39 )
      {
        if ( v5 == 49 )
        {
          c &= 0xFu;
          goto LABEL_43;
        }
        if ( v5 == 100 )
        {
          c = 0;
          goto LABEL_43;
        }
      }
      else if ( v5 == 7 )
      {
        e = 4;
        goto LABEL_43;
      }
    }
    else
    {
      switch ( v5 )
      {
        case 1:
          goto LABEL_31;
        case 4:
          e = 2;
          goto LABEL_43;
        case 0:
          e = 0;
          c = 0;
          goto LABEL_43;
      }
    }
    if ( v5 <= 29 || v5 > 37 )
    {
      if ( v5 > 39 && v5 <= 47 )
        c = c & 0xF | (16 * (v5 - 40)) | 0x80;
    }
    else
    {
      c = c & 0xF0 | (v5 - 30) | 8;
    }
LABEL_43:
    if ( *pb == 109 )
      goto LABEL_47;
    pa = pb + 1;
  }
  e = 0;
  c = 0;
LABEL_47:
  *effect = e;
  *color = c;
  return 1;
}

//----- (080788C5) --------------------------------------------------------
Str __cdecl checkType(Str s, Lineprop **oprop, Linecolor **ocolor)
{
  int v3; // eax
  int v4; // eax
  unsigned int v5; // eax
  Lineprop v6; // ax
  Lineprop v7; // ax
  int v8; // eax
  Lineprop v9; // ax
  int v10; // eax
  Linecolor *v11; // eax
  int ok; // [esp+10h] [ebp-48h]
  char *ep; // [esp+14h] [ebp-44h]
  char *sp_0; // [esp+18h] [ebp-40h]
  int clen; // [esp+1Ch] [ebp-3Ch]
  int clena; // [esp+1Ch] [ebp-3Ch]
  int plen; // [esp+20h] [ebp-38h]
  int i; // [esp+24h] [ebp-34h]
  int ia; // [esp+24h] [ebp-34h]
  int ib; // [esp+24h] [ebp-34h]
  int ic; // [esp+24h] [ebp-34h]
  int id; // [esp+24h] [ebp-34h]
  int do_copy; // [esp+28h] [ebp-30h]
  char *es_0; // [esp+2Ch] [ebp-2Ch]
  Linecolor *color; // [esp+30h] [ebp-28h]
  int check_color; // [esp+34h] [ebp-24h]
  char *bs; // [esp+38h] [ebp-20h]
  char *endp; // [esp+3Ch] [ebp-1Ch]
  char *str; // [esp+40h] [ebp-18h] BYREF
  Lineprop *prop; // [esp+44h] [ebp-14h]
  Lineprop ceffect; // [esp+48h] [ebp-10h] BYREF
  Lineprop effect; // [esp+4Ah] [ebp-Eh]
  Lineprop mode; // [esp+4Ch] [ebp-Ch]
  Linecolor cmode[9]; // [esp+4Fh] [ebp-9h] BYREF

  effect = 0;
  str = s->ptr;
  endp = &s->ptr[s->length];
  bs = 0;
  ceffect = 0;
  cmode[0] = 0;
  check_color = 0;
  color = 0;
  es_0 = 0;
  do_copy = 0;
  plen = 0;
  if ( s->length > prop_size_9084 )
  {
    v3 = s->length;
    if ( v3 < 256 )
      v3 = 256;
    prop_size_9084 = v3;
    prop_buffer_9083 = (Lineprop *)GC_realloc(prop_buffer_9083, 2 * v3);
  }
  prop = prop_buffer_9083;
  if ( ShowEffect )
  {
    bs = (char *)memchr(str, 8, s->length);
    if ( ocolor )
    {
      es_0 = (char *)memchr(str, 27, s->length);
      if ( es_0 )
      {
        if ( s->length > color_size_9093 )
        {
          v4 = s->length;
          if ( v4 < 256 )
            v4 = 256;
          color_size_9093 = v4;
          color_buffer_9092 = (Linecolor *)GC_realloc(color_buffer_9092, v4);
        }
        color = color_buffer_9092;
      }
    }
    if ( bs || es_0 )
    {
      sp_0 = str;
      s = Strnew_size(s->length);
      do_copy = 1;
      if ( bs )
        v5 = (unsigned int)(bs - 2);
      else
        v5 = (unsigned int)endp;
      ep = (char *)v5;
      if ( es_0 && (unsigned int)(es_0 - 2) < v5 )
        ep = es_0 - 2;
      while ( str < ep && (MYCTYPE_MAP[(unsigned __int8)*str] & 0x11) != 0 )
      {
        if ( (MYCTYPE_MAP[(unsigned __int8)*str] & 1) != 0 )
          v6 = 256;
        else
          v6 = 0;
        *prop++ = v6;
        if ( color )
          *color++ = 0;
        ++str;
      }
      Strcat_charp_n(s, sp_0, str - sp_0);
    }
  }
  if ( !do_copy )
  {
    while ( str < endp && (MYCTYPE_MAP[(unsigned __int8)*str] & 0x11) != 0 )
    {
      if ( (MYCTYPE_MAP[(unsigned __int8)*str] & 1) != 0 )
        v7 = 256;
      else
        v7 = 0;
      *prop++ = v7;
      ++str;
    }
  }
  while ( str < endp && prop - prop_buffer_9083 < prop_size_9084 )
  {
    if ( bs )
    {
      if ( bs - 2 == str && !strncmp(str, "__\b\b", 4u) )
      {
        str += 4;
        effect = 2;
        if ( str < endp )
          goto LABEL_87;
      }
      else if ( bs - 1 == str && *str == 95 )
      {
        str += 2;
        effect = 2;
        if ( str < endp )
          goto LABEL_87;
      }
      else
      {
        if ( str != bs )
        {
          if ( str > bs )
            bs = (char *)memchr(str, 8, endp - str);
          goto LABEL_90;
        }
        if ( str[1] == 95 )
        {
          if ( s->length )
          {
            str += 2;
            for ( i = 1; i <= plen; ++i )
              prop[-i] |= 2u;
          }
          else
          {
            ++str;
          }
        }
        else if ( !strncmp(str + 1, "\b__", 3u) )
        {
          if ( s->length )
          {
            if ( plen == 1 )
              v8 = 3;
            else
              v8 = 4;
            str += v8;
            for ( ia = 1; ia <= plen; ++ia )
              prop[-ia] |= 2u;
          }
          else
          {
            str += 2;
          }
        }
        else if ( str[1] == 8 )
        {
          if ( s->length )
          {
            clen = WTF_LEN_MAP[(unsigned __int8)str[2]];
            if ( plen == clen && !strncmp(&str[-plen], str + 2, plen) )
            {
              for ( ib = 1; ib <= plen; ++ib )
                prop[-ib] |= 8u;
              str += clen + 2;
            }
            else
            {
              Strshrink(s, plen);
              prop -= plen;
              str += 2;
            }
          }
          else
          {
            str += 2;
          }
        }
        else if ( s->length )
        {
          clena = WTF_LEN_MAP[(unsigned __int8)str[1]];
          if ( plen == clena && !strncmp(&str[-plen], str + 1, plen) )
          {
            for ( ic = 1; ic <= plen; ++ic )
              prop[-ic] |= 8u;
            str += clena + 1;
          }
          else
          {
            Strshrink(s, plen);
            prop -= plen;
            ++str;
          }
        }
        else
        {
          ++str;
        }
        if ( str < endp )
LABEL_87:
          bs = (char *)memchr(str, 8, endp - str);
      }
    }
    else
    {
LABEL_90:
      if ( !es_0 )
        goto LABEL_99;
      if ( str == es_0 )
      {
        ok = parse_ansi_color(&str, &ceffect, cmode);
        if ( str < endp )
          es_0 = (char *)memchr(str, 27, endp - str);
        if ( !ok )
          goto LABEL_99;
        if ( cmode[0] )
          check_color = 1;
      }
      else
      {
        if ( str > es_0 )
          es_0 = (char *)memchr(str, 27, endp - str);
LABEL_99:
        plen = WTF_LEN_MAP[(unsigned __int8)*str];
        mode = (WTF_TYPE_MAP[(unsigned __int8)*str] << 8) | effect;
        if ( color )
        {
          *color++ = cmode[0];
          mode |= ceffect;
        }
        *prop++ = mode;
        if ( plen <= 1 )
        {
          if ( do_copy )
          {
            if ( s->length + 1 >= s->area_size )
              Strgrow(s);
            v10 = s->length;
            s->ptr[v10] = *str;
            s->length = v10 + 1;
            s->ptr[s->length] = 0;
          }
          ++str;
        }
        else
        {
          LOBYTE(v9) = mode;
          HIBYTE(v9) = HIBYTE(mode) & 0xF9 | 4;
          mode = v9;
          for ( id = 1; id < plen; ++id )
          {
            *prop++ = mode;
            if ( color )
              *color++ = cmode[0];
          }
          if ( do_copy )
            Strcat_charp_n(s, str, plen);
          str += plen;
        }
        effect = 0;
      }
    }
  }
  *oprop = prop_buffer_9083;
  if ( ocolor )
  {
    if ( check_color )
      v11 = color_buffer_9092;
    else
      v11 = 0;
    *ocolor = v11;
  }
  return s;
}
// 8049E6C: using guessed type int __cdecl GC_realloc(_DWORD, _DWORD);

//----- (080791C2) --------------------------------------------------------
int __cdecl nextColumn(int n, char *p, Lineprop *pr)
{
  int result; // eax
  int v4; // eax

  if ( (*pr & 0x100) != 0 )
  {
    switch ( *p )
    {
      case 9:
        result = (n + Tabstop) / Tabstop * Tabstop;
        break;
      case 10:
        result = n + 1;
        break;
      case 13:
        result = n;
        break;
      default:
        result = n + 2;
        break;
    }
  }
  else if ( (*pr & 0x1000) != 0 )
  {
    result = n + 4;
  }
  else
  {
    if ( WcOption.use_wide )
      v4 = WTF_WIDTH_MAP[(unsigned __int8)*p];
    else
      v4 = WTF_WIDTH_MAP[(unsigned __int8)*p] != 0;
    result = n + v4;
  }
  return result;
}

//----- (08079289) --------------------------------------------------------
int __cdecl calcPosition(char *l, Lineprop *pr, int len, int pos, int bpos, int mode)
{
  int result; // eax
  int v7; // eax
  int j; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]

  if ( !l || !len )
    return bpos;
  if ( l == prevl_9601 && !mode && pos <= len )
    return realColumn_9599[pos];
  if ( len + 1 > size_9600 )
  {
    v7 = len + 1;
    if ( len + 1 < 256 )
      v7 = 256;
    size_9600 = v7;
    realColumn_9599 = (int *)GC_malloc(4 * v7);
  }
  prevl_9601 = l;
  i = 0;
  j = bpos;
  if ( (*pr & 0x400) != 0 )
  {
    while ( i < len && (pr[i] & 0x400) != 0 )
      realColumn_9599[i++] = bpos;
    if ( i > 0 && (pr[i - 1] & 0x800) != 0 && WcOption.use_wide )
      j = bpos + 1;
  }
  while ( 1 )
  {
    realColumn_9599[i] = j;
    if ( i == len )
      break;
    j = nextColumn(j, &l[i], &pr[i]);
    ++i;
    while ( i < len && (pr[i] & 0x400) != 0 )
    {
      realColumn_9599[i] = realColumn_9599[i - 1];
      ++i;
    }
  }
  if ( pos >= i )
    result = j;
  else
    result = realColumn_9599[pos];
  return result;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (08079452) --------------------------------------------------------
int __cdecl columnLen(Line *line, int column)
{
  int j; // [esp+14h] [ebp-8h]
  int i; // [esp+18h] [ebp-4h]

  i = 0;
  j = 0;
  while ( line->len > i )
  {
    j = nextColumn(j, &line->lineBuf[i], &line->propBuf[i]);
    if ( j > column )
      return i;
    ++i;
    while ( line->len > i && (line->propBuf[i] & 0x400) != 0 )
      ++i;
  }
  return line->len;
}

//----- (080794E8) --------------------------------------------------------
char *__cdecl lastFileName(char *path)
{
  const char *q; // [esp+18h] [ebp-10h]
  char *p; // [esp+1Ch] [ebp-Ch]

  q = path;
  for ( p = path; *p; ++p )
  {
    if ( *p == 47 )
      q = p + 1;
  }
  return allocStr(q, -1);
}

//----- (08079532) --------------------------------------------------------
char *__cdecl mybasename(char *s)
{
  char *p; // [esp+1Ch] [ebp-Ch]
  const char *pa; // [esp+1Ch] [ebp-Ch]

  for ( p = s; *p; ++p )
    ;
  while ( s <= p && *p != 47 )
    --p;
  if ( *p == 47 )
    pa = p + 1;
  else
    pa = s;
  return allocStr(pa, -1);
}

//----- (08079591) --------------------------------------------------------
char *__cdecl mydirname(char *s)
{
  size_t v2; // ebx
  int v3; // [esp+4h] [ebp-24h]
  char *p; // [esp+1Ch] [ebp-Ch]

  for ( p = s; *p; ++p )
    ;
  if ( s != p )
    --p;
  while ( s != p && *p == 47 )
    --p;
  while ( s != p && *p != 47 )
    --p;
  if ( *p != 47 )
    return ".";
  while ( s != p && *p == 47 )
    --p;
  v2 = strlen(s);
  v3 = v2 - strlen(p) + 1;
  return allocStr(s, v3);
}

//----- (08079647) --------------------------------------------------------
int __cdecl next_status(char c, int *status)
{
  int result; // eax

  switch ( *status )
  {
    case 0:
      if ( c == 60 )
      {
        *status = 1;
        result = 0;
      }
      else
      {
        if ( c == 38 )
          *status = 6;
        result = 1;
      }
      break;
    case 1:
      if ( c != 33 )
      {
        *status = 2;
        goto LABEL_11;
      }
      *status = 8;
      result = 0;
      break;
    case 2:
LABEL_11:
      if ( c == 62 )
      {
        *status = 0;
      }
      else if ( c == 61 )
      {
        *status = 5;
      }
      result = 0;
      break;
    case 3:
      if ( c == 39 )
        *status = 2;
      result = 0;
      break;
    case 4:
      if ( c == 34 )
        *status = 2;
      result = 0;
      break;
    case 5:
      if ( c == 34 )
      {
        *status = 4;
      }
      else if ( c == 39 )
      {
        *status = 3;
      }
      else if ( (MYCTYPE_MAP[(unsigned __int8)c] & 2) != 0 )
      {
        *status = 5;
      }
      else if ( c == 62 )
      {
        *status = 0;
      }
      else
      {
        *status = 15;
      }
      result = 0;
      break;
    case 6:
      if ( c == 59 )
      {
        *status = 0;
        result = 0;
      }
      else if ( c == 35 || (MYCTYPE_MAP[(unsigned __int8)c] & 0xC) != 0 || c == 95 )
      {
        result = 0;
      }
      else
      {
        *status = 0;
        result = 0;
      }
      break;
    case 8:
      if ( c == 45 )
      {
        *status = 9;
      }
      else if ( c == 62 )
      {
        *status = 0;
      }
      else
      {
        *status = 14;
      }
      result = 0;
      break;
    case 9:
      if ( c == 45 )
      {
        *status = 10;
      }
      else if ( c == 62 )
      {
        *status = 0;
      }
      else
      {
        *status = 14;
      }
      result = 0;
      break;
    case 10:
      if ( c == 45 )
        *status = 11;
      result = 0;
      break;
    case 11:
      if ( c == 45 )
        *status = 12;
      else
        *status = 10;
      result = 0;
      break;
    case 12:
      if ( c == 45 )
      {
        *status = 12;
      }
      else if ( c == 62 )
      {
        *status = 0;
      }
      else if ( (MYCTYPE_MAP[(unsigned __int8)c] & 2) != 0 )
      {
        *status = 13;
      }
      else
      {
        *status = 10;
      }
      goto LABEL_81;
    case 13:
      if ( c == 45 )
      {
        *status = 11;
      }
      else if ( c == 62 )
      {
        *status = 0;
      }
      else if ( (MYCTYPE_MAP[(unsigned __int8)c] & 2) != 0 )
      {
        *status = 13;
      }
      else
      {
        *status = 10;
      }
      result = 0;
      break;
    case 14:
      if ( c == 62 )
        *status = 0;
      result = 0;
      break;
    case 15:
      if ( c == 62 )
      {
        *status = 0;
      }
      else if ( (MYCTYPE_MAP[(unsigned __int8)c] & 2) != 0 )
      {
        *status = 2;
      }
      result = 0;
      break;
    default:
LABEL_81:
      result = 0;
      break;
  }
  return result;
}

//----- (0807999A) --------------------------------------------------------
int __cdecl read_token(Str buf, char **instr, int *status, int pre, int append)
{
  int v6; // eax
  int v7; // edx
  char v8; // al
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int prev_status; // [esp+18h] [ebp-10h]
  char *p; // [esp+1Ch] [ebp-Ch]

  if ( !append )
    Strclear(buf);
  if ( !**instr )
    return 0;
  p = *instr;
  while ( *p )
  {
    prev_status = *status;
    next_status(*p, status);
    switch ( *status )
    {
      case 0:
        if ( prev_status == 6 && *p != 59 )
        {
          --p;
          goto LABEL_67;
        }
        if ( prev_status == 12 || prev_status == 13 || prev_status == 14 || prev_status == 8 )
        {
          if ( prev_status == 8 && !append && !pre )
            Strclear(buf);
          if ( pre )
          {
            if ( buf->length + 1 >= buf->area_size )
              Strgrow(buf);
            v6 = buf->length;
            buf->ptr[v6] = *p;
            buf->length = v6 + 1;
            buf->ptr[buf->length] = 0;
          }
          ++p;
          goto proc_end;
        }
        if ( buf->length + 1 >= buf->area_size )
          Strgrow(buf);
        v7 = buf->length;
        if ( !pre && (MYCTYPE_MAP[(unsigned __int8)*p] & 2) != 0 )
          v8 = 32;
        else
          v8 = *p;
        buf->ptr[buf->length] = v8;
        buf->length = v7 + 1;
        buf->ptr[buf->length] = 0;
        if ( prev_status != 2 && prev_status != 1 && prev_status != 5 && prev_status != 15 )
          goto LABEL_67;
        *instr = p + 1;
        if ( buf->length > 1 && buf->ptr[buf->length - 2] == 60 && buf->ptr[buf->length - 1] == 62 )
        {
          Strshrink(buf, 2);
          goto LABEL_67;
        }
        return 1;
      case 1:
      case 2:
        if ( prev_status || *instr == p )
        {
          if ( *status != 1
            || (MYCTYPE_MAP[(unsigned __int8)p[1]] & 4) != 0
            || p[1] == 47
            || p[1] == 33
            || p[1] == 63
            || !p[1]
            || p[1] == 95 )
          {
            if ( buf->length + 1 >= buf->area_size )
              Strgrow(buf);
            v10 = buf->length;
            buf->ptr[v10] = *p;
            buf->length = v10 + 1;
            buf->ptr[buf->length] = 0;
          }
          else
          {
            if ( buf->length + 1 >= buf->area_size )
              Strgrow(buf);
            v9 = buf->length;
            buf->ptr[v9] = 60;
            buf->length = v9 + 1;
            buf->ptr[buf->length] = 0;
            *status = 0;
          }
          goto LABEL_67;
        }
        *instr = p;
        *status = 0;
        return 1;
      case 3:
      case 4:
      case 5:
      case 6:
      case 15:
        if ( buf->length + 1 >= buf->area_size )
          Strgrow(buf);
        v11 = buf->length;
        buf->ptr[v11] = *p;
        buf->length = v11 + 1;
        buf->ptr[buf->length] = 0;
        goto LABEL_67;
      case 8:
      case 9:
      case 11:
      case 12:
      case 13:
        if ( pre )
        {
          if ( buf->length + 1 >= buf->area_size )
            Strgrow(buf);
          v13 = buf->length;
          buf->ptr[v13] = *p;
          buf->length = v13 + 1;
          buf->ptr[buf->length] = 0;
        }
        goto LABEL_67;
      case 10:
      case 14:
        if ( pre )
        {
          if ( buf->length + 1 >= buf->area_size )
            Strgrow(buf);
          v12 = buf->length;
          buf->ptr[v12] = *p;
          buf->length = v12 + 1;
          buf->ptr[buf->length] = 0;
        }
        else if ( !append )
        {
          Strclear(buf);
        }
        goto LABEL_67;
      default:
LABEL_67:
        ++p;
        break;
    }
  }
proc_end:
  *instr = p;
  return 1;
}

//----- (08079E3B) --------------------------------------------------------
Str __cdecl correct_irrtag(int status)
{
  int v2; // eax
  Str tmp; // [esp+18h] [ebp-10h]
  char c; // [esp+1Fh] [ebp-9h]

  tmp = Strnew();
  while ( 2 )
  {
    if ( status )
    {
      switch ( status )
      {
        case 1:
        case 2:
        case 5:
        case 8:
        case 9:
        case 12:
        case 13:
        case 14:
        case 15:
          c = 62;
          next_status(62, &status);
          goto LABEL_9;
        case 3:
          c = 39;
          next_status(39, &status);
          goto LABEL_9;
        case 4:
          c = 34;
          next_status(34, &status);
          goto LABEL_9;
        case 6:
          c = 59;
          next_status(59, &status);
          goto LABEL_9;
        case 10:
        case 11:
          c = 45;
          next_status(45, &status);
LABEL_9:
          if ( tmp->length + 1 >= tmp->area_size )
            Strgrow(tmp);
          v2 = tmp->length;
          tmp->ptr[v2] = c;
          tmp->length = v2 + 1;
          tmp->ptr[tmp->length] = 0;
          continue;
        default:
          return tmp;
      }
    }
    return tmp;
  }
}

//----- (08079EF2) --------------------------------------------------------
void __cdecl add_auth_pass_entry(const auth_pass *ent, int netrc, int override)
{
  auth_pass *ep; // [esp+18h] [ebp-10h]
  auth_pass *newent; // [esp+1Ch] [ebp-Ch]

  if ( (ent->host || netrc) && (ent->is_proxy || ent->realm || netrc) && ent->uname && ent->pwd )
  {
    newent = (auth_pass *)GC_malloc(32);
    memcpy(newent, ent, sizeof(auth_pass));
    if ( override )
    {
      newent->next = passwords;
      passwords = newent;
    }
    else if ( passwords )
    {
      if ( passwords->next )
      {
        for ( ep = passwords; ep->next; ep = ep->next )
          ;
        ep->next = newent;
      }
      else
      {
        passwords->next = newent;
      }
    }
    else
    {
      passwords = newent;
    }
  }
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (08079FDF) --------------------------------------------------------
auth_pass *__cdecl find_auth_pass_entry(char *host, int port, char *realm, char *uname, int is_proxy)
{
  auth_pass *ent; // [esp+1Ch] [ebp-Ch]

  for ( ent = passwords; ent; ent = ent->next )
  {
    if ( ent->is_proxy == is_proxy
      && ent->bad != 1
      && (!ent->host || !strcasecmp(ent->host->ptr, host))
      && (!ent->port || ent->port == port)
      && (!ent->uname || !uname || !strcmp(ent->uname->ptr, uname))
      && (!ent->realm || !realm || !strcmp(ent->realm->ptr, realm)) )
    {
      return ent;
    }
  }
  return 0;
}

//----- (0807A0BE) --------------------------------------------------------
int __cdecl find_auth_user_passwd(ParsedURL *pu, char *realm, Str *uname, Str *pwd, int is_proxy)
{
  int result; // eax
  auth_pass *ent; // [esp+2Ch] [ebp-Ch]

  if ( pu->user && pu->pass )
  {
    *uname = Strnew_charp(pu->user);
    *pwd = Strnew_charp(pu->pass);
    result = 1;
  }
  else
  {
    ent = find_auth_pass_entry(pu->host, pu->port, realm, pu->user, is_proxy);
    if ( ent )
    {
      *uname = ent->uname;
      *pwd = ent->pwd;
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  return result;
}

//----- (0807A167) --------------------------------------------------------
void __cdecl add_auth_user_passwd(ParsedURL *pu, char *realm, Str uname, Str pwd, int is_proxy)
{
  auth_pass ent; // [esp+10h] [ebp-28h] BYREF

  memset(&ent, 0, sizeof(ent));
  ent.is_proxy = is_proxy;
  ent.host = Strnew_charp(pu->host);
  ent.port = pu->port;
  ent.realm = Strnew_charp(realm);
  ent.uname = uname;
  ent.pwd = pwd;
  add_auth_pass_entry(&ent, 0, 1);
}

//----- (0807A1DF) --------------------------------------------------------
void __cdecl invalidate_auth_user_passwd(ParsedURL *pu, char *realm, Str uname, Str pwd, int is_proxy)
{
  auth_pass *ent; // [esp+2Ch] [ebp-Ch]

  ent = find_auth_pass_entry(pu->host, pu->port, realm, 0, is_proxy);
  if ( ent )
    ent->bad = 1;
}

//----- (0807A227) --------------------------------------------------------
Str __cdecl next_token(Str arg)
{
  char *q; // [esp+14h] [ebp-14h]
  char *qa; // [esp+14h] [ebp-14h]
  _Str *narg; // [esp+1Ch] [ebp-Ch]

  narg = 0;
  if ( !arg || !arg->length )
    return 0;
  for ( q = arg->ptr; *q && (MYCTYPE_MAP[(unsigned __int8)*q] & 2) == 0; ++q )
    ;
  if ( *q )
  {
    *q = 0;
    for ( qa = q + 1; *qa && (MYCTYPE_MAP[(unsigned __int8)*qa] & 2) != 0; ++qa )
      ;
    if ( *qa )
      narg = Strnew_charp(qa);
  }
  return narg;
}

//----- (0807A2E1) --------------------------------------------------------
void __cdecl parsePasswd(FILE *fp, int netrc)
{
  auth_pass ent; // [esp+14h] [ebp-34h] BYREF
  char *p; // [esp+34h] [ebp-14h]
  Str arg; // [esp+38h] [ebp-10h]
  Str line; // [esp+3Ch] [ebp-Ch]

  line = 0;
  bzero(&ent, 0x20u);
  while ( 1 )
  {
    arg = 0;
    if ( !line || !line->length )
      line = Strfgets(fp);
    if ( !line->length )
      break;
    Strchop(line);
    Strremovefirstspaces(line);
    p = line->ptr;
    if ( *p != 35 && *p )
    {
      arg = next_token(line);
      if ( !strcmp(p, "machine") || !strcmp(p, "host") || netrc && !strcmp(p, "default") )
      {
        add_auth_pass_entry(&ent, netrc, 0);
        bzero(&ent, 0x20u);
        if ( netrc )
          ent.port = 21;
        if ( !strcmp(p, "default") )
        {
          line = arg;
        }
        else
        {
          line = next_token(arg);
          ent.host = arg;
        }
      }
      else if ( !netrc && !strcmp(p, "port") && arg )
      {
        line = next_token(arg);
        ent.port = atoi(arg->ptr);
      }
      else if ( netrc || strcmp(p, "proxy") )
      {
        if ( netrc || strcmp(p, "path") )
        {
          if ( netrc || strcmp(p, "realm") )
          {
            if ( !strcmp(p, "login") )
            {
              line = next_token(arg);
              ent.uname = arg;
            }
            else if ( !strcmp(p, "password") || !strcmp(p, "passwd") )
            {
              line = next_token(arg);
              ent.pwd = arg;
            }
            else if ( netrc && !strcmp(p, "machdef") )
            {
              do
                line = Strfgets(fp);
              while ( line->length && *line->ptr != 10 );
              line = 0;
            }
            else
            {
              if ( netrc && !strcmp(p, "account") )
                goto LABEL_28;
              line = 0;
            }
          }
          else
          {
            line = 0;
            ent.realm = arg;
          }
        }
        else
        {
LABEL_28:
          line = next_token(arg);
        }
      }
      else
      {
        ent.is_proxy = 1;
        line = arg;
      }
    }
    else
    {
      line = 0;
    }
  }
  add_auth_pass_entry(&ent, netrc, 0);
}

//----- (0807A631) --------------------------------------------------------
FILE *__cdecl openSecretFile(char *fname)
{
  Str v2; // eax
  FILE *v3; // ebx
  Str v4; // eax
  stat st; // [esp+14h] [ebp-64h] BYREF
  char *efname; // [esp+6Ch] [ebp-Ch]

  if ( !fname )
    return 0;
  efname = expandPath(fname);
  if ( stat_0(efname, (int)&st) < 0 )
    return 0;
  if ( disable_secret_security_check || (st.st_mode & 0x3F) == 0 )
    return fopen(efname, "r");
  if ( fmInitialized )
  {
    v2 = Sprintf("SECURITY NOTE: file %s must not be accessible by others", fname);
    message(v2->ptr, 0, 0);
    refresh();
  }
  else
  {
    v3 = stderr;
    v4 = Sprintf("SECURITY NOTE: file %s must not be accessible by others", fname);
    fputs(v4->ptr, v3);
    fputc(10, stderr);
  }
  sleep(2u);
  return 0;
}

//----- (0807A73A) --------------------------------------------------------
void loadPasswd()
{
  FILE *fp; // [esp+1Ch] [ebp-Ch]
  FILE *fpa; // [esp+1Ch] [ebp-Ch]

  passwords = 0;
  fp = openSecretFile(passwd_file);
  if ( fp )
  {
    parsePasswd(fp, 0);
    fclose(fp);
  }
  fpa = openSecretFile("~/.netrc");
  if ( fpa )
  {
    parsePasswd(fpa, 1);
    fclose(fpa);
  }
}

//----- (0807A7B3) --------------------------------------------------------
char *__cdecl last_modified(Buffer *buf)
{
  char *result; // eax
  stat st; // [esp+14h] [ebp-64h] BYREF
  TextListItem *ti; // [esp+6Ch] [ebp-Ch]

  if ( buf->document_header )
  {
    for ( ti = buf->document_header->first; ti; ti = ti->next )
    {
      if ( !strncasecmp(ti->ptr, "Last-modified: ", 0xFu) )
        return ti->ptr + 15;
    }
    result = "unknown";
  }
  else if ( buf->currentURL.scheme == 4 )
  {
    if ( stat_0(buf->currentURL.file, (int)&st) >= 0 )
      result = ctime(&st.st_mtim.tv_sec);
    else
      result = "unknown";
  }
  else
  {
    result = "unknown";
  }
  return result;
}

//----- (0807A85F) --------------------------------------------------------
Str __cdecl romanNum2(int l, int n)
{
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  Str s; // [esp+1Ch] [ebp-Ch]
  int na; // [esp+34h] [ebp+Ch]

  s = Strnew();
  switch ( n )
  {
    case 1:
    case 2:
    case 3:
      while ( n > 0 )
      {
        if ( s->length + 1 >= s->area_size )
          Strgrow(s);
        v2 = s->length;
        s->ptr[v2] = roman_num1[l];
        s->length = v2 + 1;
        s->ptr[s->length] = 0;
        --n;
      }
      break;
    case 4:
      if ( s->length + 1 >= s->area_size )
        Strgrow(s);
      v3 = s->length;
      s->ptr[v3] = roman_num1[l];
      s->length = v3 + 1;
      s->ptr[s->length] = 0;
      if ( s->length + 1 >= s->area_size )
        Strgrow(s);
      v4 = s->length;
      s->ptr[v4] = roman_num5[l];
      s->length = v4 + 1;
      s->ptr[s->length] = 0;
      break;
    case 5:
    case 6:
    case 7:
    case 8:
      if ( s->length + 1 >= s->area_size )
        Strgrow(s);
      v5 = s->length;
      s->ptr[v5] = roman_num5[l];
      s->length = v5 + 1;
      s->ptr[s->length] = 0;
      for ( na = n - 5; na > 0; --na )
      {
        if ( s->length + 1 >= s->area_size )
          Strgrow(s);
        v6 = s->length;
        s->ptr[v6] = roman_num1[l];
        s->length = v6 + 1;
        s->ptr[s->length] = 0;
      }
      break;
    case 9:
      if ( s->length + 1 >= s->area_size )
        Strgrow(s);
      v7 = s->length;
      s->ptr[v7] = roman_num1[l];
      s->length = v7 + 1;
      s->ptr[s->length] = 0;
      if ( s->length + 1 >= s->area_size )
        Strgrow(s);
      v8 = s->length;
      s->ptr[v8] = roman_num1[l + 1];
      s->length = v8 + 1;
      s->ptr[s->length] = 0;
      break;
    default:
      return s;
  }
  return s;
}

//----- (0807AAFB) --------------------------------------------------------
Str __cdecl romanNumeral(int n)
{
  _Str *v2; // [esp+4h] [ebp-24h]
  _Str *v3; // [esp+4h] [ebp-24h]
  _Str *v4; // [esp+4h] [ebp-24h]
  _Str *v5; // [esp+4h] [ebp-24h]
  _Str *r; // [esp+1Ch] [ebp-Ch]

  r = Strnew();
  if ( n <= 0 )
    return r;
  if ( n <= 3999 )
  {
    v2 = romanNum2(3, n / 1000);
    savexmlstr_0(r, v2);
    v3 = romanNum2(2, n % 1000 / 100);
    savexmlstr_0(r, v3);
    v4 = romanNum2(1, n % 100 / 10);
    savexmlstr_0(r, v4);
    v5 = romanNum2(0, n % 10);
    savexmlstr_0(r, v5);
  }
  else
  {
    Strcat_charp(r, "**");
  }
  return r;
}

//----- (0807AC6D) --------------------------------------------------------
Str __cdecl romanAlphabet(int n)
{
  int v2; // eax
  int l; // [esp+14h] [ebp-24h]
  int la; // [esp+14h] [ebp-24h]
  Str r; // [esp+18h] [ebp-20h]
  char buf[14]; // [esp+1Eh] [ebp-1Ah]
  unsigned int v7; // [esp+2Ch] [ebp-Ch]

  v7 = __readgsdword(0x14u);
  r = Strnew();
  if ( n <= 0 )
    return r;
  l = 0;
  while ( n )
  {
    buf[l++] = (n - 1) % 26 + 97;
    n = (n - 1) / 26;
  }
  for ( la = l - 1; la >= 0; --la )
  {
    if ( r->length + 1 >= r->area_size )
      Strgrow(r);
    v2 = r->length;
    r->ptr[v2] = buf[la];
    r->length = v2 + 1;
    r->ptr[r->length] = 0;
  }
  return r;
}

//----- (0807AD75) --------------------------------------------------------
void reset_signals()
{
  mySignal(1, 0);
  mySignal(2, 0);
  mySignal(3, 0);
  mySignal(15, 0);
  mySignal(4, 0);
  mySignal(6, 0);
  mySignal(8, 0);
  mySignal(7, 0);
  mySignal(17, (void (*)(int))1);
  mySignal(13, (void (*)(int))1);
}

//----- (0807AE45) --------------------------------------------------------
void __cdecl close_all_fds_except(int i, int f)
{
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int ia; // [esp+20h] [ebp+8h]

  switch ( i )
  {
    case 1:
      goto LABEL_5;
    case 2:
LABEL_6:
      v4 = open("/dev/null", 1);
      dup2(v4, 2);
      break;
    case 0:
      v2 = open("/dev/null", 0);
      dup2(v2, 0);
LABEL_5:
      v3 = open("/dev/null", 1);
      dup2(v3, 1);
      goto LABEL_6;
  }
  for ( ia = 3; ia <= 15; ++ia )
  {
    if ( ia != f )
      close(ia);
  }
}

//----- (0807AEF0) --------------------------------------------------------
void __cdecl setup_child(int child, int i, int f)
{
  reset_signals();
  mySignal(2, (void (*)(int))1);
  if ( !child )
    setpgrp();
  close_tty();
  close_all_fds_except(i, f);
  QuietMessage[0] = 1;
  fmInitialized = 0;
  TrapSignal = 0;
}

//----- (0807AF48) --------------------------------------------------------
pid_t __cdecl open_pipe_rw(FILE **fr, FILE **fw)
{
  int fdw[2]; // [esp+1Ch] [ebp-1Ch] BYREF
  int fdr[2]; // [esp+24h] [ebp-14h] BYREF
  pid_t pid; // [esp+2Ch] [ebp-Ch]

  if ( fr && pipe(fdr) < 0 )
    return -1;
  if ( fw && pipe(fdw) < 0 )
  {
err1:
    if ( fr )
    {
      close(fdr[0]);
      close(fdr[1]);
    }
    return -1;
  }
  flush_tty();
  pid = fork();
  if ( pid < 0 )
  {
    if ( fw )
    {
      close(fdw[0]);
      close(fdw[1]);
    }
    goto err1;
  }
  if ( pid )
  {
    if ( fr )
    {
      close(fdr[1]);
      if ( *fr == stdin )
        dup2(fdr[0], 0);
      else
        *fr = fdopen(fdr[0], "r");
    }
    if ( fw )
    {
      close(fdw[0]);
      if ( *fw == stdout )
        dup2(fdw[1], 1);
      else
        *fw = fdopen(fdw[1], "w");
    }
  }
  else
  {
    if ( fr )
    {
      close(fdr[0]);
      dup2(fdr[1], 1);
    }
    if ( fw )
    {
      close(fdw[1]);
      dup2(fdw[0], 0);
    }
  }
  return pid;
}

//----- (0807B0D1) --------------------------------------------------------
void __cdecl __noreturn myExec(char *command)
{
  mySignal(2, 0);
  execl("/bin/sh", "sh", "-c", command, 0);
  exit(127);
}

//----- (0807B122) --------------------------------------------------------
void __cdecl mySystem(char *command, int background)
{
  if ( background )
  {
    flush_tty();
    if ( !fork() )
    {
      setup_child(0, 0, -1);
      myExec(command);
    }
  }
  else
  {
    system(command);
  }
}

//----- (0807B172) --------------------------------------------------------
Str __cdecl myExtCommand(char *cmd, char *arg, int redirect)
{
  int v3; // eax
  int set_arg; // [esp+24h] [ebp-14h]
  char *p; // [esp+28h] [ebp-10h]
  Str tmp; // [esp+2Ch] [ebp-Ch]

  tmp = 0;
  set_arg = 0;
  for ( p = cmd; *p; ++p )
  {
    if ( *p == 37 && p[1] == 115 && !set_arg )
    {
      if ( !tmp )
        tmp = Strnew_charp_n(cmd, p - cmd);
      Strcat_charp(tmp, arg);
      set_arg = 1;
      ++p;
    }
    else if ( tmp )
    {
      if ( tmp->length + 1 >= tmp->area_size )
        Strgrow(tmp);
      v3 = tmp->length;
      tmp->ptr[v3] = *p;
      tmp->length = v3 + 1;
      tmp->ptr[tmp->length] = 0;
    }
  }
  if ( !set_arg )
  {
    if ( redirect )
      tmp = Strnew_m_charp("(", cmd, ") < ", arg, 0);
    else
      tmp = Strnew_m_charp(cmd, " ", arg, 0);
  }
  return tmp;
}

//----- (0807B2BD) --------------------------------------------------------
Str __cdecl myEditor(char *cmd, char *file, int line)
{
  int v3; // eax
  _Str *v5; // [esp+4h] [ebp-24h]
  _Str *v6; // [esp+4h] [ebp-24h]
  int set_line; // [esp+10h] [ebp-18h]
  int set_file; // [esp+14h] [ebp-14h]
  char *p; // [esp+18h] [ebp-10h]
  Str tmp; // [esp+1Ch] [ebp-Ch]

  tmp = 0;
  set_file = 0;
  set_line = 0;
  for ( p = cmd; *p; ++p )
  {
    if ( *p == 37 && p[1] == 115 && !set_file )
    {
      if ( !tmp )
        tmp = Strnew_charp_n(cmd, p - cmd);
      Strcat_charp(tmp, file);
      set_file = 1;
      ++p;
    }
    else if ( *p == 37 && p[1] == 100 && !set_line && line > 0 )
    {
      if ( !tmp )
        tmp = Strnew_charp_n(cmd, p - cmd);
      v5 = Sprintf("%d", line);
      savexmlstr_0(tmp, v5);
      set_line = 1;
      ++p;
    }
    else if ( tmp )
    {
      if ( tmp->length + 1 >= tmp->area_size )
        Strgrow(tmp);
      v3 = tmp->length;
      tmp->ptr[v3] = *p;
      tmp->length = v3 + 1;
      tmp->ptr[tmp->length] = 0;
    }
  }
  if ( !set_file )
  {
    if ( !tmp )
      tmp = Strnew_charp(cmd);
    if ( !set_line && line > 1 && strcasestr(cmd, "vi") )
    {
      v6 = Sprintf(" +%d", line);
      savexmlstr_0(tmp, v6);
    }
    Strcat_m_charp(tmp, " ", file, 0);
  }
  return tmp;
}
// 804A36C: using guessed type int __cdecl strcasestr(_DWORD, _DWORD);

//----- (0807B4A9) --------------------------------------------------------
char *__cdecl expandName(char *name)
{
  char *v2; // eax
  char *q; // [esp+10h] [ebp-18h]
  _Str *extpath; // [esp+14h] [ebp-14h]
  passwd *passent; // [esp+18h] [ebp-10h]
  char *p; // [esp+1Ch] [ebp-Ch]
  char *pa; // [esp+1Ch] [ebp-Ch]

  if ( !name )
    return 0;
  if ( *name != 47 )
    return expandPath(name);
  if ( name[1] != 126 || (MYCTYPE_MAP[(unsigned __int8)name[2]] & 4) == 0 || !personal_document_root )
    return name;
  p = name + 2;
  q = strchr(name + 2, 47);
  if ( q )
  {
    v2 = allocStr(p, q - p);
    passent = getpwnam(v2);
    pa = q;
  }
  else
  {
    passent = getpwnam(p);
    pa = (char *)&unk_80CAF55;
  }
  if ( !passent )
    return name;
  extpath = Strnew_m_charp(passent->pw_dir, "/", personal_document_root, 0);
  if ( !*personal_document_root && *pa == 47 )
    ++pa;
  if ( !strcmp(extpath->ptr, "/") && *pa == 47 )
    ++pa;
  Strcat_charp(extpath, pa);
  return extpath->ptr;
}

//----- (0807B61E) --------------------------------------------------------
char *__cdecl file_to_url(char *file)
{
  int v1; // eax
  char *v2; // eax
  char *v4; // [esp+4h] [ebp-24h]
  Str tmp; // [esp+1Ch] [ebp-Ch]
  _Str *tmpa; // [esp+1Ch] [ebp-Ch]
  char *filea; // [esp+30h] [ebp+8h]

  filea = expandPath(file);
  if ( *filea != 47 )
  {
    tmp = Strnew_charp(CurrentDir);
    if ( tmp->length <= 0 || tmp->ptr[tmp->length - 1] != 47 )
    {
      if ( tmp->length + 1 >= tmp->area_size )
        Strgrow(tmp);
      v1 = tmp->length;
      tmp->ptr[v1] = 47;
      tmp->length = v1 + 1;
      tmp->ptr[tmp->length] = 0;
    }
    Strcat_charp(tmp, filea);
    filea = tmp->ptr;
  }
  tmpa = Strnew_charp("file://");
  v2 = cleanupName(filea);
  v4 = file_quote(v2);
  Strcat_charp(tmpa, v4);
  return tmpa->ptr;
}

//----- (0807B70F) --------------------------------------------------------
char *__cdecl url_unquote_conv(char *url, wc_ces charset)
{
  _Str *v2; // eax
  _Str *tmp; // [esp+28h] [ebp-10h]
  Str tmpa; // [esp+28h] [ebp-10h]
  wc_uint8 old_auto_detect; // [esp+2Fh] [ebp-9h]

  old_auto_detect = WcOption.auto_detect;
  v2 = Strnew_charp(url);
  tmp = Str_url_unquote(v2, 0, 1);
  if ( !charset || charset == 256 )
    charset = SystemCharset;
  WcOption.auto_detect = 2;
  tmpa = convertLine(0, tmp, 0, &charset, charset);
  WcOption.auto_detect = old_auto_detect;
  return tmpa->ptr;
}

//----- (0807B7A1) --------------------------------------------------------
Str __cdecl tmpfname(int type, char *ext)
{
  char *v2; // eax
  unsigned int v3; // esi
  char *v4; // eax
  _Str *tmpf; // [esp+2Ch] [ebp-Ch]

  if ( ext )
    v2 = ext;
  else
    v2 = (char *)&unk_80CAF55;
  v3 = tmpf_seq[type];
  tmpf_seq[type] = v3 + 1;
  tmpf = Sprintf("%s/w3m%s%d-%d%s", tmp_dir, tmpf_base[type], CurrentPid, v3, v2);
  v4 = allocStr(tmpf->ptr, -1);
  pushValue((GeneralList *)fileToDelete, v4);
  return tmpf;
}

//----- (0807B839) --------------------------------------------------------
int __cdecl get_day(char **s)
{
  int v2; // edx
  char *v3; // eax
  char *ss_0; // [esp+14h] [ebp-14h]
  int day; // [esp+18h] [ebp-10h]
  Str tmp; // [esp+1Ch] [ebp-Ch]

  tmp = Strnew();
  ss_0 = *s;
  if ( !**s )
    return -1;
  while ( **s && (MYCTYPE_MAP[(unsigned __int8)**s] & 8) != 0 )
  {
    if ( tmp->length + 1 >= tmp->area_size )
      Strgrow(tmp);
    v2 = tmp->length;
    v3 = *s;
    tmp->ptr[v2] = **s;
    tmp->length = v2 + 1;
    *s = v3 + 1;
    tmp->ptr[tmp->length] = 0;
  }
  day = atoi(tmp->ptr);
  if ( day > 0 && day <= 31 )
    return day;
  *s = ss_0;
  return -1;
}

//----- (0807B923) --------------------------------------------------------
int __cdecl get_month(char **s)
{
  int v2; // edx
  char *v3; // eax
  int v4; // edx
  char *v5; // eax
  char *ss_0; // [esp+14h] [ebp-14h]
  int mon; // [esp+18h] [ebp-10h]
  Str tmp; // [esp+1Ch] [ebp-Ch]

  tmp = Strnew();
  ss_0 = *s;
  if ( !**s )
    return -1;
  while ( **s && (MYCTYPE_MAP[(unsigned __int8)**s] & 8) != 0 )
  {
    if ( tmp->length + 1 >= tmp->area_size )
      Strgrow(tmp);
    v2 = tmp->length;
    v3 = *s;
    tmp->ptr[v2] = **s;
    tmp->length = v2 + 1;
    *s = v3 + 1;
    tmp->ptr[tmp->length] = 0;
  }
  if ( tmp->length <= 0 )
  {
    while ( **s && (MYCTYPE_MAP[(unsigned __int8)**s] & 4) != 0 )
    {
      if ( tmp->length + 1 >= tmp->area_size )
        Strgrow(tmp);
      v4 = tmp->length;
      v5 = *s;
      tmp->ptr[v4] = **s;
      tmp->length = v4 + 1;
      *s = v5 + 1;
      tmp->ptr[tmp->length] = 0;
    }
    for ( mon = 1; mon <= 12 && strncmp(tmp->ptr, monthtbl[mon - 1], 3u); ++mon )
      ;
  }
  else
  {
    mon = atoi(tmp->ptr);
  }
  if ( mon > 0 && mon <= 12 )
    return mon;
  *s = ss_0;
  return -1;
}

//----- (0807BAE5) --------------------------------------------------------
int __cdecl get_year(char **s)
{
  int result; // eax
  int v2; // edx
  char *v3; // eax
  char *ss_0; // [esp+14h] [ebp-14h]
  int year; // [esp+18h] [ebp-10h]
  Str tmp; // [esp+1Ch] [ebp-Ch]

  tmp = Strnew();
  ss_0 = *s;
  if ( !**s )
    return -1;
  while ( **s && (MYCTYPE_MAP[(unsigned __int8)**s] & 8) != 0 )
  {
    if ( tmp->length + 1 >= tmp->area_size )
      Strgrow(tmp);
    v2 = tmp->length;
    v3 = *s;
    tmp->ptr[v2] = **s;
    tmp->length = v2 + 1;
    *s = v3 + 1;
    tmp->ptr[tmp->length] = 0;
  }
  if ( tmp->length == 2 || tmp->length == 4 )
  {
    year = atoi(tmp->ptr);
    if ( tmp->length == 2 )
    {
      if ( year <= 69 )
        year += 2000;
      else
        year += 1900;
    }
    result = year;
  }
  else
  {
    *s = ss_0;
    result = -1;
  }
  return result;
}

//----- (0807BBFA) --------------------------------------------------------
int __cdecl get_time(char **s, int *hour, int *min, int *sec)
{
  int result; // eax
  int v5; // edx
  char *v6; // eax
  int v7; // edx
  char *v8; // eax
  int v9; // edx
  char *v10; // eax
  char *ss_0; // [esp+18h] [ebp-10h]
  Str tmp; // [esp+1Ch] [ebp-Ch]

  tmp = Strnew();
  ss_0 = *s;
  if ( !**s )
    return -1;
  while ( **s && (MYCTYPE_MAP[(unsigned __int8)**s] & 8) != 0 )
  {
    if ( tmp->length + 1 >= tmp->area_size )
      Strgrow(tmp);
    v5 = tmp->length;
    v6 = *s;
    tmp->ptr[v5] = **s;
    tmp->length = v5 + 1;
    *s = v6 + 1;
    tmp->ptr[tmp->length] = 0;
  }
  if ( **s == 58 )
  {
    *hour = atoi(tmp->ptr);
    ++*s;
    Strclear(tmp);
    while ( **s && (MYCTYPE_MAP[(unsigned __int8)**s] & 8) != 0 )
    {
      if ( tmp->length + 1 >= tmp->area_size )
        Strgrow(tmp);
      v7 = tmp->length;
      v8 = *s;
      tmp->ptr[v7] = **s;
      tmp->length = v7 + 1;
      *s = v8 + 1;
      tmp->ptr[tmp->length] = 0;
    }
    if ( **s == 58 )
    {
      *min = atoi(tmp->ptr);
      ++*s;
      Strclear(tmp);
      while ( **s && (MYCTYPE_MAP[(unsigned __int8)**s] & 8) != 0 )
      {
        if ( tmp->length + 1 >= tmp->area_size )
          Strgrow(tmp);
        v9 = tmp->length;
        v10 = *s;
        tmp->ptr[v9] = **s;
        tmp->length = v9 + 1;
        *s = v10 + 1;
        tmp->ptr[tmp->length] = 0;
      }
      *sec = atoi(tmp->ptr);
      if ( *hour >= 0 && *hour <= 23 && *min >= 0 && *min <= 59 && *sec >= 0 && *sec <= 59 )
      {
        result = 0;
      }
      else
      {
        *s = ss_0;
        result = -1;
      }
    }
    else
    {
      *s = ss_0;
      result = -1;
    }
  }
  else
  {
    *s = ss_0;
    result = -1;
  }
  return result;
}

//----- (0807BEB5) --------------------------------------------------------
int __cdecl get_zone(char **s, int *z_hour, int *z_min)
{
  int result; // eax
  int v4; // edx
  char *v5; // eax
  int v6; // eax
  char *ss_0; // [esp+14h] [ebp-14h]
  Str tmp; // [esp+1Ch] [ebp-Ch]

  tmp = Strnew();
  ss_0 = *s;
  if ( !**s )
    return -1;
  if ( **s != 43 && **s != 45 )
    goto LABEL_11;
  if ( tmp->length + 1 >= tmp->area_size )
    Strgrow(tmp);
  while ( 1 )
  {
    v4 = tmp->length;
    v5 = *s;
    tmp->ptr[v4] = **s;
    tmp->length = v4 + 1;
    *s = v5 + 1;
    tmp->ptr[tmp->length] = 0;
LABEL_11:
    if ( !**s || (MYCTYPE_MAP[(unsigned __int8)**s] & 8) == 0 )
      break;
    if ( tmp->length + 1 >= tmp->area_size )
      Strgrow(tmp);
  }
  if ( tmp->length == 4 && (MYCTYPE_MAP[(unsigned __int8)*ss_0] & 8) != 0
    || tmp->length == 5 && (*ss_0 == 43 || *ss_0 == 45) )
  {
    v6 = atoi(tmp->ptr);
    *z_hour = v6 / 100;
    *z_min = v6 % 100;
    result = 0;
  }
  else
  {
    *s = ss_0;
    result = -1;
  }
  return result;
}

//----- (0807C094) --------------------------------------------------------
time_t __cdecl mymktime(char *timestr)
{
  int z_min; // [esp+1Ch] [ebp-2Ch] BYREF
  int z_hour; // [esp+20h] [ebp-28h] BYREF
  int sec; // [esp+24h] [ebp-24h] BYREF
  int min; // [esp+28h] [ebp-20h] BYREF
  int hour; // [esp+2Ch] [ebp-1Ch] BYREF
  int year; // [esp+30h] [ebp-18h]
  int mon; // [esp+34h] [ebp-14h]
  int day; // [esp+38h] [ebp-10h]
  char *s[3]; // [esp+3Ch] [ebp-Ch] BYREF

  z_hour = 0;
  z_min = 0;
  if ( !timestr || !*timestr )
    return -1;
  for ( s[0] = timestr; *s[0] && (MYCTYPE_MAP[(unsigned __int8)*s[0]] & 4) != 0; ++s[0] )
    ;
  while ( *s[0] && (MYCTYPE_MAP[(unsigned __int8)*s[0]] & 0xC) == 0 )
    ++s[0];
  if ( (MYCTYPE_MAP[(unsigned __int8)*s[0]] & 8) != 0 )
  {
    day = get_day(s);
    if ( day == -1 )
      return -1;
    while ( *s[0] && (MYCTYPE_MAP[(unsigned __int8)*s[0]] & 0xC) == 0 )
      ++s[0];
    mon = get_month(s);
    if ( mon == -1 )
      return -1;
    while ( *s[0] && (MYCTYPE_MAP[(unsigned __int8)*s[0]] & 8) == 0 )
      ++s[0];
    year = get_year(s);
    if ( year == -1 )
      return -1;
    while ( *s[0] && (MYCTYPE_MAP[(unsigned __int8)*s[0]] & 8) == 0 )
      ++s[0];
    if ( *s[0] )
    {
      if ( get_time(s, &hour, &min, &sec) == -1 )
        return -1;
      while ( *s[0] && (MYCTYPE_MAP[(unsigned __int8)*s[0]] & 8) == 0 && *s[0] != 43 && *s[0] != 45 )
        ++s[0];
      get_zone(s, &z_hour, &z_min);
    }
    else
    {
      hour = 0;
      min = 0;
      sec = 0;
    }
  }
  else
  {
    while ( *s[0] && (MYCTYPE_MAP[(unsigned __int8)*s[0]] & 0xC) == 0 )
      ++s[0];
    mon = get_month(s);
    if ( mon == -1 )
      return -1;
    while ( *s[0] && (MYCTYPE_MAP[(unsigned __int8)*s[0]] & 8) == 0 )
      ++s[0];
    day = get_day(s);
    if ( day == -1 )
      return -1;
    while ( *s[0] && (MYCTYPE_MAP[(unsigned __int8)*s[0]] & 8) == 0 )
      ++s[0];
    if ( get_time(s, &hour, &min, &sec) == -1 )
      return -1;
    while ( *s[0] && (MYCTYPE_MAP[(unsigned __int8)*s[0]] & 8) == 0 )
      ++s[0];
    year = get_year(s);
    if ( year == -1 )
      return -1;
  }
  mon -= 3;
  if ( mon < 0 )
  {
    mon += 12;
    --year;
  }
  return 60 * (min - z_min)
       + 3600 * (hour - z_hour)
       + 86400 * ((153 * mon + 2) / 5 - 672 + (1461 * year - 2875248) / 4 + day)
       + sec;
}

//----- (0807C4D9) --------------------------------------------------------
char *__cdecl FQDN(char *host)
{
  addrinfo hints; // [esp+18h] [ebp-40h] BYREF
  char *namebuf; // [esp+38h] [ebp-20h]
  addrinfo *res0; // [esp+3Ch] [ebp-1Ch] BYREF
  addrinfo *res; // [esp+40h] [ebp-18h]
  int *af_0; // [esp+48h] [ebp-10h]
  char *p; // [esp+4Ch] [ebp-Ch]

  if ( !host )
    return 0;
  if ( !strcasecmp(host, "localhost") )
    return host;
  for ( p = host; *p && *p != 46; ++p )
    ;
  if ( *p == 46 )
    return host;
  for ( af_0 = ai_family_order_table[DNS_order]; ; ++af_0 )
  {
    memset(&hints, 0, sizeof(hints));
    hints.ai_flags = 2;
    hints.ai_family = *af_0;
    hints.ai_socktype = 1;
    if ( !getaddrinfo(host, 0, &hints, &res0) )
      break;
    if ( !*af_0 )
      return 0;
LABEL_21:
    ;
  }
  for ( res = res0; res; res = res->ai_next )
  {
    if ( res->ai_canonname )
    {
      namebuf = strdup(res->ai_canonname);
      freeaddrinfo(res0);
      return namebuf;
    }
  }
  freeaddrinfo(res0);
  if ( *af_0 )
    goto LABEL_21;
  return 0;
}

//----- (0807C62B) --------------------------------------------------------
void (*__cdecl mySignal(int signal_number, void (*action)(int)))(int)
{
  sigaction old_action; // [esp+18h] [ebp-120h] BYREF
  sigaction new_action; // [esp+A4h] [ebp-94h] BYREF

  sigemptyset(&new_action.sa_mask);
  new_action.sa_handler = action;
  if ( signal_number == 14 )
    new_action.sa_flags = 0x20000000;
  else
    new_action.sa_flags = 0x10000000;
  sigaction(signal_number, &new_action, &old_action);
  return old_action.sa_handler;
}

//----- (0807C68C) --------------------------------------------------------
void __cdecl set_mark(Line *l, int pos, int epos)
{
  while ( pos < epos && l->size > pos )
    l->propBuf[pos++] |= 1;
}

//----- (0807C6CE) --------------------------------------------------------
void init_migemo()
{
  migemo_running = use_migemo;
  migemo_active = use_migemo;
  if ( migemor )
    fclose(migemor);
  if ( migemow )
    fclose(migemow);
  migemow = 0;
  migemor = 0;
  if ( migemo_pid )
    kill(migemo_pid, 9);
  migemo_pid = 0;
}

//----- (0807C752) --------------------------------------------------------
int __cdecl open_migemo(char *migemo_command)
{
  int result; // eax

  migemo_pid = open_pipe_rw(&migemor, &migemow);
  if ( migemo_pid < 0 )
  {
    migemo_pid = 0;
    migemo_running = 0;
    migemo_active = 0;
    result = 0;
  }
  else
  {
    if ( !migemo_pid )
    {
      setup_child(0, 2, -1);
      myExec(migemo_command);
    }
    result = 1;
  }
  return result;
}

//----- (0807C7D7) --------------------------------------------------------
char *__cdecl migemostr(char *str)
{
  wc_ces v2; // esi
  wc_ces v3; // ebx
  _Str *v4; // eax
  Str v5; // eax
  wc_ces v6; // esi
  wc_ces v7; // ebx
  _Str *v8; // eax
  Str tmp; // [esp+1Ch] [ebp-Ch]

  if ( (!migemor || !migemow) && !open_migemo(migemo_command) )
    return str;
  v2 = SystemCharset;
  v3 = InnerCharset;
  v4 = Strnew_charp(str);
  v5 = wc_Str_conv_strict(v4, v3, v2);
  fprintf(migemow, "%s\n", v5->ptr);
  while ( fflush(migemow) )
  {
    if ( *__errno_location() != 4 )
      goto err;
  }
  v6 = InnerCharset;
  v7 = SystemCharset;
  v8 = Strfgets(migemor);
  tmp = wc_Str_conv(v8, v7, v6);
  Strchop(tmp);
  if ( tmp->length )
    return conv_search_string(tmp->ptr, SystemCharset);
err:
  init_migemo();
  migemo_running = 0;
  migemo_active = 0;
  return str;
}

//----- (0807C8F4) --------------------------------------------------------
char *__cdecl conv_search_string(char *str, wc_ces f_ces)
{
  if ( SearchConv && !WcOption.pre_conv && CurrentTab->currentBuffer->document_charset != f_ces )
    str = wtf_conv_fit(str, CurrentTab->currentBuffer->document_charset);
  return str;
}

//----- (0807C948) --------------------------------------------------------
int __cdecl forwardSearch(Buffer *buf, char *str)
{
  int v2; // ebx
  char *v3; // eax
  int result; // eax
  int pos; // [esp+14h] [ebp-24h]
  int posa; // [esp+14h] [ebp-24h]
  int posb; // [esp+14h] [ebp-24h]
  int wrapped; // [esp+18h] [ebp-20h]
  Line *begin; // [esp+1Ch] [ebp-1Ch]
  Line *l; // [esp+20h] [ebp-18h]
  Line *la; // [esp+20h] [ebp-18h]
  char *last; // [esp+24h] [ebp-14h] BYREF
  char *first; // [esp+28h] [ebp-10h] BYREF
  char *p; // [esp+2Ch] [ebp-Ch]

  wrapped = 0;
  if ( migemo_active <= 0 )
  {
    p = regexCompile(str, IgnoreCase);
    if ( p )
    {
LABEL_4:
      message(p, 0, 0);
      return 2;
    }
  }
  else
  {
    v2 = IgnoreCase;
    v3 = migemostr(str);
    p = regexCompile(v3, v2);
    if ( p )
    {
      p = regexCompile(str, IgnoreCase);
      if ( p )
        goto LABEL_4;
    }
  }
  l = buf->currentLine;
  if ( !l )
    return 2;
  pos = buf->pos;
  if ( l->bpos )
  {
    pos += l->bpos;
    while ( l->bpos && l->prev )
      l = l->prev;
  }
  begin = l;
  while ( l->size > pos && (l->propBuf[pos] & 0x400) != 0 )
    ++pos;
  if ( l->size > pos && __gmp_vfprintf(&l->lineBuf[pos], l->size - pos, 0) == 1 )
  {
    matchedPosition(&first, &last);
    posa = first - l->lineBuf;
    while ( l->len <= posa && l->next && l->next->bpos )
    {
      posa -= l->len;
      l = l->next;
    }
    buf->pos = posa;
    if ( buf->currentLine != l )
      gotoLine(buf, l->linenumber);
    arrangeCursor(buf);
    set_mark(l, posa, &last[posa] - first);
    return 1;
  }
  for ( la = l->next; ; la = la->next )
  {
    if ( !la )
    {
      if ( buf->pagerSource )
      {
        la = getNextPage(buf, 1);
        if ( !la )
        {
          if ( !WrapSearch || wrapped )
            return 2;
          la = buf->firstLine;
          wrapped = 1;
        }
      }
      else
      {
        if ( !WrapSearch )
          return 2;
        la = buf->firstLine;
        wrapped = 1;
      }
    }
    if ( !la->bpos )
      break;
LABEL_48:
    ;
  }
  if ( __gmp_vfprintf(la->lineBuf, la->size, 1) != 1 )
  {
    if ( wrapped && la == begin )
      return 2;
    goto LABEL_48;
  }
  matchedPosition(&first, &last);
  posb = first - la->lineBuf;
  while ( la->len <= posb && la->next && la->next->bpos )
  {
    posb -= la->len;
    la = la->next;
  }
  buf->pos = posb;
  buf->currentLine = la;
  gotoLine(buf, la->linenumber);
  arrangeCursor(buf);
  set_mark(la, posb, &last[posb] - first);
  if ( wrapped )
    result = 5;
  else
    result = 1;
  return result;
}

//----- (0807CD41) --------------------------------------------------------
int __cdecl backwardSearch(Buffer *buf, char *str)
{
  int v2; // ebx
  char *v3; // eax
  int result; // eax
  int pos; // [esp+18h] [ebp-30h]
  int posa; // [esp+18h] [ebp-30h]
  int posb; // [esp+18h] [ebp-30h]
  int posc; // [esp+18h] [ebp-30h]
  int wrapped; // [esp+1Ch] [ebp-2Ch]
  Line *begin; // [esp+20h] [ebp-28h]
  Line *l; // [esp+24h] [ebp-24h]
  Line *la; // [esp+24h] [ebp-24h]
  char *last; // [esp+28h] [ebp-20h] BYREF
  char *first; // [esp+2Ch] [ebp-1Ch] BYREF
  char *found_last; // [esp+30h] [ebp-18h]
  char *found; // [esp+34h] [ebp-14h]
  char *q; // [esp+38h] [ebp-10h]
  char *p; // [esp+3Ch] [ebp-Ch]

  wrapped = 0;
  if ( migemo_active <= 0 )
  {
    p = regexCompile(str, IgnoreCase);
    if ( p )
    {
LABEL_4:
      message(p, 0, 0);
      return 2;
    }
  }
  else
  {
    v2 = IgnoreCase;
    v3 = migemostr(str);
    p = regexCompile(v3, v2);
    if ( p )
    {
      p = regexCompile(str, IgnoreCase);
      if ( p )
        goto LABEL_4;
    }
  }
  l = buf->currentLine;
  if ( !l )
    return 2;
  pos = buf->pos;
  if ( l->bpos )
  {
    pos += l->bpos;
    while ( l->bpos && l->prev )
      l = l->prev;
  }
  begin = l;
  if ( pos <= 0 )
    goto LABEL_37;
  for ( posa = pos - 1; posa > 0 && (l->propBuf[posa] & 0x400) != 0; --posa )
    ;
  p = &l->lineBuf[posa];
  found = 0;
  found_last = 0;
  q = l->lineBuf;
  do
  {
    if ( __gmp_vfprintf(q, &l->lineBuf[l->size] - q, l->lineBuf == q) != 1 )
      break;
    matchedPosition(&first, &last);
    if ( first <= p )
    {
      found = first;
      found_last = last;
    }
    if ( q - l->lineBuf >= l->size )
      break;
    ++q;
    while ( q - l->lineBuf < l->size && (l->propBuf[q - l->lineBuf] & 0x400) != 0 )
      ++q;
  }
  while ( q <= p );
  if ( found )
  {
    posb = found - l->lineBuf;
    while ( l->len <= posb && l->next && l->next->bpos )
    {
      posb -= l->len;
      l = l->next;
    }
    buf->pos = posb;
    if ( buf->currentLine != l )
      gotoLine(buf, l->linenumber);
    arrangeCursor(buf);
    set_mark(l, posb, &found_last[posb] - found);
    result = 1;
  }
  else
  {
LABEL_37:
    for ( la = l->prev; ; la = la->prev )
    {
      if ( !la )
      {
        if ( !WrapSearch )
          return 2;
        la = buf->lastLine;
        wrapped = 1;
      }
      found = 0;
      found_last = 0;
      q = la->lineBuf;
      while ( __gmp_vfprintf(q, &la->lineBuf[la->size] - q, la->lineBuf == q) == 1 )
      {
        matchedPosition(&first, &last);
        found = first;
        found_last = last;
        if ( q - la->lineBuf >= la->size )
          break;
        ++q;
        while ( q - la->lineBuf < la->size && (la->propBuf[q - la->lineBuf] & 0x400) != 0 )
          ++q;
      }
      if ( found )
        break;
      if ( wrapped && la == begin )
        return 2;
    }
    posc = found - la->lineBuf;
    while ( la->len <= posc && la->next && la->next->bpos )
    {
      posc -= la->len;
      la = la->next;
    }
    buf->pos = posc;
    gotoLine(buf, la->linenumber);
    arrangeCursor(buf);
    set_mark(la, posc, &found_last[posc] - found);
    if ( wrapped )
      result = 5;
    else
      result = 1;
  }
  return result;
}

//----- (0807D230) --------------------------------------------------------
char *__cdecl inputLineHistSearch(char *prompt, char *def_str, int flag, Hist *hist, int (*incrfunc)(int, Str, Lineprop *))
{
  wc_ces v5; // ebx
  wc_ces v6; // eax
  char *result; // eax
  const char *q; // [esp+28h] [ebp-30h]
  Str tmp; // [esp+2Ch] [ebp-2Ch]
  char *p; // [esp+30h] [ebp-28h]
  int epos; // [esp+34h] [ebp-24h]
  int rpos; // [esp+38h] [ebp-20h]
  int lpos; // [esp+3Ch] [ebp-1Ch]
  int y; // [esp+40h] [ebp-18h]
  int x; // [esp+44h] [ebp-14h]
  int opos; // [esp+48h] [ebp-10h]
  unsigned __int8 c; // [esp+4Fh] [ebp-9h]

  is_passwd = 0;
  move_word = 1;
  CurrentHist = hist;
  if ( hist )
  {
    use_hist = 1;
    strCurrentBuf = 0;
  }
  else
  {
    use_hist = 0;
  }
  if ( (flag & 0x100) != 0 )
  {
    cm_mode = 12;
  }
  else if ( (flag & 0x20) != 0 )
  {
    cm_mode = 4;
  }
  else if ( (flag & 0x40) != 0 )
  {
    cm_mode = 0;
    is_passwd = 1;
    move_word = 0;
  }
  else if ( (flag & 0x80) != 0 )
  {
    cm_mode = 2;
  }
  else
  {
    cm_mode = 1;
  }
  opos = wtf_strwidth((wc_uchar *)prompt);
  epos = COLS - 2 - opos;
  if ( epos < 0 )
    epos = 0;
  lpos = epos / 3;
  rpos = 2 * epos / 3;
  offset = 0;
  if ( def_str )
  {
    strBuf = Strnew_charp(def_str);
    CPos = setStrType(strBuf, strProp);
    CLen = CPos;
  }
  else
  {
    strBuf = Strnew();
    CPos = 0;
    CLen = 0;
  }
  i_cont = 1;
  i_broken = 0;
  i_quote = 0;
  cm_next = 0;
  cm_disp_next = -1;
  need_redraw = 0;
  v5 = InnerCharset;
  v6 = wc_guess_8bit_charset(DisplayCharset);
  wc_char_conv_init(v6, v5);
  do
  {
    x = calcPosition(strBuf->ptr, strProp, CLen, CPos, 0, 1);
    if ( x - rpos <= offset )
    {
      if ( x - lpos < offset )
      {
        if ( x - lpos <= 0 )
          offset = 0;
        else
          offset = x - lpos;
      }
    }
    else
    {
      y = calcPosition(strBuf->ptr, strProp, CLen, CLen, 0, 0);
      if ( y - epos <= x - rpos )
      {
        if ( y - epos > 0 )
          offset = y - epos;
      }
      else
      {
        offset = x - rpos;
      }
    }
    move(LINES - 1, 0);
    addstr(prompt);
    if ( is_passwd )
      addPasswd(strBuf->ptr, strProp, CLen, offset, COLS - opos);
    else
      addStr(strBuf->ptr, strProp, CLen, offset, COLS - opos);
    clrtoeolx();
    move(LINES - 1, x + opos - offset);
    refresh();
    while ( 1 )
    {
      c = do_getch();
      cm_clear = 1;
      cm_disp_clear = 1;
      if ( !i_quote && ((cm_mode & 4) != 0 && (c == 9 || c == 32) || (cm_mode & 2) != 0 && c == 9) )
      {
        if ( emacs_like_lineedit && cm_next )
          goto LABEL_40;
        compl();
        cm_disp_next = -1;
        goto LABEL_71;
      }
      if ( !i_quote && CLen == CPos && ((cm_mode & 4) != 0 || (cm_mode & 2) != 0) && c == 4 )
        break;
      if ( !i_quote && c == 127 )
      {
        bs();
        cm_next = 0;
        cm_disp_next = -1;
        goto LABEL_71;
      }
      if ( !i_quote && c <= 0x1Fu )
      {
        if ( !incrfunc || (c = incrfunc(c, strBuf, strProp), c <= 0x1Fu) )
          InputKeymap[c]();
        if ( incrfunc && c != 0xFF && c != 10 )
          incrfunc(-1, strBuf, strProp);
        if ( cm_clear )
          cm_next = 0;
        if ( cm_disp_clear )
          cm_disp_next = -1;
        goto LABEL_71;
      }
      tmp = wc_char_conv(c);
      if ( tmp )
      {
        i_quote = 0;
        cm_next = 0;
        cm_disp_next = -1;
        if ( tmp->length + CLen <= 1024 && tmp->length )
        {
          ins_char(tmp);
          if ( incrfunc )
            incrfunc(-1, strBuf, strProp);
          goto LABEL_71;
        }
      }
      else
      {
        i_quote = 1;
      }
    }
    if ( !emacs_like_lineedit )
    {
LABEL_40:
      dcompl();
      need_redraw = 1;
    }
LABEL_71:
    ;
  }
  while ( (!CLen || (flag & 0x200) == 0) && i_cont );
  if ( CurrentTab && need_redraw )
    displayBuffer(CurrentTab->currentBuffer, 1);
  if ( i_broken )
    return 0;
  move(LINES - 1, 0);
  refresh();
  p = strBuf->ptr;
  if ( (flag & 0xA0) != 0 )
  {
    while ( *p && (MYCTYPE_MAP[(unsigned __int8)*p] & 2) != 0 )
      ++p;
  }
  if ( use_hist )
  {
    if ( (flag & 0x100) == 0 )
    {
      if ( *p )
      {
        q = lastHist(hist);
        if ( !q || strcmp(q, p) )
          pushHist(hist, p);
      }
    }
  }
  if ( (flag & 0x20) != 0 )
    result = expandPath(p);
  else
    result = allocStr(p, -1);
  return result;
}

//----- (0807D9AC) --------------------------------------------------------
void __cdecl addPasswd(char *p, Lineprop *pr, int len, int offset, int limit)
{
  int ncol; // [esp+28h] [ebp-10h]
  int rcol; // [esp+2Ch] [ebp-Ch]

  rcol = 0;
  ncol = calcPosition(p, pr, len, len, 0, 0);
  if ( offset + limit < ncol )
    ncol = offset + limit;
  if ( offset )
  {
    addChar(123, 0);
    rcol = offset + 1;
  }
  while ( rcol < ncol )
  {
    addChar(42, 0);
    ++rcol;
  }
}

//----- (0807DA4D) --------------------------------------------------------
void __cdecl addStr(char *p, Lineprop *pr, int len, int offset, int limit)
{
  int delta; // [esp+20h] [ebp-18h]
  int ncol; // [esp+24h] [ebp-14h]
  int ncola; // [esp+24h] [ebp-14h]
  int rcol; // [esp+28h] [ebp-10h]
  int i; // [esp+2Ch] [ebp-Ch]

  i = 0;
  rcol = 0;
  if ( !offset )
  {
LABEL_22:
    while ( i < len )
    {
      delta = wtf_len((wc_uchar *)&p[i]);
      ncola = calcPosition(p, pr, len, i + delta, 0, 0);
      if ( ncola - offset > limit )
        break;
      if ( p[i] == 9 )
      {
        while ( rcol < ncola )
        {
          addChar(32, 0);
          ++rcol;
        }
      }
      else
      {
        addMChar(&p[i], pr[i], delta);
        rcol = ncola;
      }
      i += delta;
    }
    return;
  }
  for ( i = 0; i < len && calcPosition(p, pr, len, i, 0, 0) <= offset; ++i )
    ;
  if ( i < len )
  {
    while ( (pr[i] & 0x400) != 0 )
      ++i;
    addChar(123, 0);
    rcol = offset + 1;
    ncol = calcPosition(p, pr, len, i, 0, 0);
    while ( rcol < ncol )
    {
      addChar(32, 0);
      ++rcol;
    }
    goto LABEL_22;
  }
}

//----- (0807DC34) --------------------------------------------------------
void __cdecl ins_char(Str str)
{
  Lineprop v1; // ax
  int len; // [esp+0h] [ebp-18h]
  int lena; // [esp+0h] [ebp-18h]
  char *ep; // [esp+4h] [ebp-14h]
  char *p; // [esp+8h] [ebp-10h]
  Lineprop ctype; // [esp+Eh] [ebp-Ah]
  Lineprop ctypea; // [esp+Eh] [ebp-Ah]

  p = str->ptr;
  ep = &str->ptr[str->length];
  if ( str->length + CLen <= 1023 )
  {
    while ( p < ep )
    {
      len = WTF_LEN_MAP[(unsigned __int8)*p];
      ctype = WTF_TYPE_MAP[(unsigned __int8)*p] << 8;
      if ( is_passwd )
      {
        if ( (ctype & 0x100) != 0 )
          ctype = 0;
        if ( (ctype & 0x1000) != 0 )
          ctype = 512;
      }
      insC();
      strBuf->ptr[CPos] = *p++;
      strProp[CPos++] = ctype;
      lena = len - 1;
      if ( lena )
      {
        LOBYTE(v1) = ctype;
        HIBYTE(v1) = HIBYTE(ctype) & 0xF9 | 4;
        for ( ctypea = v1; lena-- != 0; strProp[CPos++] = ctypea )
        {
          insC();
          strBuf->ptr[CPos] = *p++;
        }
      }
    }
  }
}

//----- (0807DD7C) --------------------------------------------------------
void esc()
{
  char v0; // al
  char v1; // al
  char c; // [esp+1Fh] [ebp-9h]

  v0 = do_getch();
  c = v0;
  if ( v0 == 32 )
    goto LABEL_25;
  if ( v0 > 32 )
  {
    if ( v0 != 91 )
    {
      if ( v0 > 91 )
      {
        if ( v0 == 98 )
        {
          if ( emacs_like_lineedit )
            mvLw();
          return;
        }
        if ( v0 == 102 )
        {
          if ( emacs_like_lineedit )
            mvRw();
          return;
        }
LABEL_37:
        if ( !wc_char_conv(27) && !wc_char_conv(c) )
          i_quote = 1;
        return;
      }
      if ( v0 != 79 )
        goto LABEL_37;
    }
    v1 = do_getch();
    if ( v1 == 66 )
    {
      next();
    }
    else if ( v1 > 66 )
    {
      if ( v1 == 67 )
      {
        mvR();
      }
      else if ( v1 == 68 )
      {
        mvL();
      }
    }
    else if ( v1 == 65 )
    {
      prev();
    }
    return;
  }
  if ( v0 == 8 )
  {
    if ( emacs_like_lineedit )
      bsw();
    return;
  }
  if ( v0 == 9 )
  {
LABEL_25:
    if ( emacs_like_lineedit )
    {
      rdcompl();
      cm_clear = 0;
      need_redraw = 1;
    }
    else
    {
      rcompl();
    }
    return;
  }
  if ( v0 != 4 )
    goto LABEL_37;
  if ( !emacs_like_lineedit )
    rdcompl();
  need_redraw = 1;
}

//----- (0807DEE7) --------------------------------------------------------
void insC()
{
  int i; // [esp+1Ch] [ebp-Ch]

  Strinsert_char(strBuf, CPos, 32);
  CLen = strBuf->length;
  for ( i = CLen; i > CPos; --i )
    strProp[i] = strProp[i - 1];
}

//----- (0807DF4C) --------------------------------------------------------
void delC()
{
  int delta; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]

  delta = 1;
  if ( CLen != CPos )
  {
    while ( delta + CPos < CLen && (strProp[CPos + delta] & 0x400) != 0 )
      ++delta;
    for ( i = CPos; i < CLen; ++i )
      strProp[i] = strProp[i + delta];
    Strdelete(strBuf, CPos, delta);
    CLen -= delta;
  }
}

//----- (0807E00B) --------------------------------------------------------
void mvL()
{
  if ( CPos > 0 )
    --CPos;
  while ( CPos > 0 && (strProp[CPos] & 0x400) != 0 )
    --CPos;
}

//----- (0807E05A) --------------------------------------------------------
void mvLw()
{
  int first; // [esp+1Ch] [ebp-Ch]

  first = 1;
  do
  {
    if ( CPos <= 0 || !first && terminated(strBuf->ptr[CPos - 1]) )
      break;
    --CPos;
    first = 0;
    if ( CPos > 0 && (strProp[CPos] & 0x400) != 0 )
      --CPos;
  }
  while ( move_word );
}

//----- (0807E0ED) --------------------------------------------------------
void mvRw()
{
  int first; // [esp+1Ch] [ebp-Ch]

  first = 1;
  do
  {
    if ( CPos >= CLen || !first && terminated(strBuf->ptr[CPos - 1]) )
      break;
    ++CPos;
    first = 0;
    if ( CPos < CLen && (strProp[CPos] & 0x400) != 0 )
      ++CPos;
  }
  while ( move_word );
}

//----- (0807E190) --------------------------------------------------------
void mvR()
{
  if ( CPos < CLen )
    ++CPos;
  while ( CPos < CLen && (strProp[CPos] & 0x400) != 0 )
    ++CPos;
}

//----- (0807E1EB) --------------------------------------------------------
void bs()
{
  if ( CPos > 0 )
  {
    mvL();
    delC();
  }
}

//----- (0807E206) --------------------------------------------------------
void bsw()
{
  _BOOL4 v0; // eax
  int t; // [esp+1Ch] [ebp-Ch]

  t = 0;
  while ( CPos > 0 && !t )
  {
    mvL();
    v0 = move_word && terminated(strBuf->ptr[CPos - 1]);
    t = v0;
    delC();
  }
}

//----- (0807E26C) --------------------------------------------------------
void enter()
{
  i_cont = 0;
}

//----- (0807E27B) --------------------------------------------------------
void __cdecl insertself(char c)
{
  Lineprop v1; // ax

  if ( CLen <= 1023 )
  {
    insC();
    strBuf->ptr[CPos] = c;
    if ( is_passwd )
      v1 = 0;
    else
      v1 = 256;
    strProp[CPos++] = v1;
  }
}

//----- (0807E2E1) --------------------------------------------------------
void quo()
{
  i_quote = 1;
}

//----- (0807E2F0) --------------------------------------------------------
void mvB()
{
  CPos = 0;
}

//----- (0807E2FF) --------------------------------------------------------
void mvE()
{
  CPos = CLen;
}

//----- (0807E30E) --------------------------------------------------------
void killn()
{
  CLen = CPos;
  Strtruncate(strBuf, CPos);
}

//----- (0807E337) --------------------------------------------------------
void killb()
{
  while ( CPos > 0 )
    bs();
}

//----- (0807E34F) --------------------------------------------------------
void inbrk()
{
  i_cont = 0;
  i_broken = 1;
}

//----- (0807E368) --------------------------------------------------------
void compl()
{
  next_compl(1);
}

//----- (0807E37C) --------------------------------------------------------
void rcompl()
{
  next_compl(-1);
}

//----- (0807E390) --------------------------------------------------------
void tcompl()
{
  if ( (cm_mode & 1) != 0 )
  {
    cm_mode = 2;
  }
  else if ( (cm_mode & 2) != 0 )
  {
    cm_mode = 1;
  }
}

//----- (0807E3C3) --------------------------------------------------------
void __cdecl next_compl(int next)
{
  Str s; // [esp+1Ch] [ebp-1Ch]
  _Str *buf; // [esp+20h] [ebp-18h]
  int a; // [esp+24h] [ebp-14h]
  int b; // [esp+28h] [ebp-10h]
  int ba; // [esp+28h] [ebp-10h]
  int status[3]; // [esp+2Ch] [ebp-Ch] BYREF

  if ( cm_mode && (cm_mode & 1) == 0 )
  {
    cm_clear = 0;
    if ( cm_next )
    {
      s = doComplete(strBuf, status, next);
    }
    else
    {
      if ( (cm_mode & 4) != 0 )
      {
        b = 0;
      }
      else
      {
        for ( ba = CPos - 1;
              ba >= 0 && (strBuf->ptr[ba] != 32 && strBuf->ptr[ba] != 9 || ba > 0 && strBuf->ptr[ba - 1] == 92);
              --ba )
        {
          ;
        }
        b = ba + 1;
      }
      a = CPos;
      CBeforeBuf = Strsubstr(strBuf, 0, b);
      buf = Strsubstr(strBuf, b, a - b);
      CAfterBuf = Strsubstr(strBuf, a, strBuf->length - a);
      s = doComplete(buf, status, next);
    }
    if ( next )
    {
      if ( status[0] && status[0] != 3 )
        bell();
      if ( status[0] != 2 )
      {
        strBuf = Strnew_m_charp(CBeforeBuf->ptr, s->ptr, CAfterBuf->ptr, 0);
        CLen = setStrType(strBuf, strProp);
        CPos = CBeforeBuf->length + s->length;
        if ( CPos > CLen )
          CPos = CLen;
      }
    }
  }
}

//----- (0807E5D4) --------------------------------------------------------
void dcompl()
{
  next_dcompl(1);
}

//----- (0807E5E8) --------------------------------------------------------
void rdcompl()
{
  next_dcompl(-1);
}

//----- (0807E5FC) --------------------------------------------------------
void __cdecl next_dcompl(int next)
{
  wc_ces v1; // esi
  wc_ces v2; // ebx
  _Str *v3; // eax
  Str v4; // eax
  int v5; // edx
  wc_ces v6; // esi
  wc_ces v7; // ebx
  _Str *v8; // eax
  Str v9; // eax
  char *v10; // eax
  stat st; // [esp+28h] [ebp-80h] BYREF
  int nline; // [esp+80h] [ebp-28h]
  int comment; // [esp+84h] [ebp-24h]
  char *p; // [esp+88h] [ebp-20h]
  Str f; // [esp+8Ch] [ebp-1Ch]
  int y; // [esp+90h] [ebp-18h]
  int n; // [esp+94h] [ebp-14h]
  int j; // [esp+98h] [ebp-10h]
  int i; // [esp+9Ch] [ebp-Ch]

  if ( cm_mode && (cm_mode & 1) == 0 )
  {
    cm_disp_clear = 0;
    if ( CurrentTab )
      displayBuffer(CurrentTab->currentBuffer, 1);
    if ( LINES - 1 <= 2 )
    {
      if ( LINES == 1 )
        return;
      comment = 0;
      nline = LINES - 1;
    }
    else
    {
      comment = 1;
      nline = LINES - 3;
    }
    if ( cm_disp_next < 0 )
    {
      cm_next = 0;
      next_compl(0);
      if ( !NCFileBuf )
        return;
      cm_disp_next = 0;
      v1 = SystemCharset;
      v2 = InnerCharset;
      v3 = Strdup(CDirBuf);
      d_9104 = wc_Str_conv_strict(v3, v2, v1);
      if ( d_9104->length > 0 && d_9104->ptr[d_9104->length - 1] != 47 )
      {
        if ( d_9104->length + 1 >= d_9104->area_size )
          Strgrow(d_9104);
        v4 = d_9104;
        v5 = d_9104->length;
        d_9104->ptr[v5] = 47;
        v4->length = v5 + 1;
        d_9104->ptr[d_9104->length] = 0;
      }
      if ( (cm_mode & 8) != 0 && *d_9104->ptr == 102 )
      {
        p = d_9104->ptr;
        if ( !strncmp(p, "file://localhost/", 0x11u) )
        {
          p += 16;
        }
        else if ( !strncmp(p, "file:///", 8u) )
        {
          p += 7;
        }
        else if ( !strncmp(p, "file:/", 6u) && p[6] != 47 )
        {
          p += 5;
        }
        d_9104 = Strnew_charp(p);
      }
      len_9103 = 0;
      for ( i = 0; i < (int)NCFileBuf; ++i )
      {
        n = strlen(CFileBuf[i]) + 3;
        if ( len_9103 < n )
          len_9103 = n;
      }
      col_9101 = COLS / len_9103;
      if ( !(COLS / len_9103) )
        col_9101 = 1;
      row_9102 = (int)(NCFileBuf + col_9101 - 1) / col_9101;
    }
    else
    {
      if ( next == 1 )
      {
        cm_disp_next += nline * col_9101;
        if ( cm_disp_next >= (int)NCFileBuf )
          cm_disp_next = 0;
      }
      else if ( next == -1 )
      {
        cm_disp_next -= nline * col_9101;
        if ( cm_disp_next < 0 )
          cm_disp_next = 0;
      }
      row_9102 = (int)(NCFileBuf - cm_disp_next + col_9101 - 1) / col_9101;
    }
    if ( comment )
    {
      if ( row_9102 <= nline )
      {
        y = nline - row_9102 + 1;
      }
      else
      {
        row_9102 = nline;
        y = 0;
      }
    }
    else if ( row_9102 < nline )
    {
      y = nline - row_9102 - 1;
    }
    else
    {
      row_9102 = nline;
      y = 0;
    }
    if ( y )
    {
      move(y - 1, 0);
      clrtoeolx();
    }
    if ( comment )
    {
      move(y, 0);
      clrtoeolx();
      bold();
      addstr("----- Completion list -----");
      boldend();
      ++y;
    }
    for ( i = 0; i < row_9102; ++i )
    {
      for ( j = 0; j < col_9101; ++j )
      {
        n = i + j * row_9102 + cm_disp_next;
        if ( n >= (int)NCFileBuf )
          break;
        move(y, j * len_9103);
        clrtoeolx();
        f = Strdup(d_9104);
        Strcat_charp(f, CFileBuf[n]);
        v6 = InnerCharset;
        v7 = SystemCharset;
        v8 = Strnew_charp(CFileBuf[n]);
        v9 = wc_Str_conv(v8, v7, v6);
        addstr(v9->ptr);
        v10 = expandPath(f->ptr);
        if ( stat_0(v10, (int)&st) != -1 && (st.st_mode & 0xF000) == 0x4000 )
          addstr("/");
      }
      ++y;
    }
    if ( comment && LINES - 2 == y )
    {
      move(y, 0);
      clrtoeolx();
      bold();
      if ( emacs_like_lineedit )
        addstr("----- Press TAB to continue -----");
      else
        addstr("----- Press CTRL-D to continue -----");
      boldend();
    }
  }
}

//----- (0807EBE9) --------------------------------------------------------
Str __cdecl escape_spaces(Str s)
{
  Str result; // eax
  int v2; // eax
  int v3; // eax
  char *p; // [esp+18h] [ebp-10h]
  Str tmp; // [esp+1Ch] [ebp-Ch]

  tmp = 0;
  if ( !s )
    return 0;
  for ( p = s->ptr; *p; ++p )
  {
    if ( *p == 32 || *p == 9 )
    {
      if ( !tmp )
        tmp = Strnew_charp_n(s->ptr, p - s->ptr);
      if ( tmp->length + 1 >= tmp->area_size )
        Strgrow(tmp);
      v2 = tmp->length;
      tmp->ptr[v2] = 92;
      tmp->length = v2 + 1;
      tmp->ptr[tmp->length] = 0;
    }
    if ( tmp )
    {
      if ( tmp->length + 1 >= tmp->area_size )
        Strgrow(tmp);
      v3 = tmp->length;
      tmp->ptr[v3] = *p;
      tmp->length = v3 + 1;
      tmp->ptr[tmp->length] = 0;
    }
  }
  if ( tmp )
    result = tmp;
  else
    result = s;
  return result;
}

//----- (0807ED0B) --------------------------------------------------------
Str __cdecl unescape_spaces(Str s)
{
  Str result; // eax
  int v2; // eax
  char *p; // [esp+18h] [ebp-10h]
  Str tmp; // [esp+1Ch] [ebp-Ch]

  tmp = 0;
  if ( !s )
    return 0;
  for ( p = s->ptr; *p; ++p )
  {
    if ( *p == 92 && (p[1] == 32 || p[1] == 9) )
    {
      if ( !tmp )
        tmp = Strnew_charp_n(s->ptr, p - s->ptr);
    }
    else if ( tmp )
    {
      if ( tmp->length + 1 >= tmp->area_size )
        Strgrow(tmp);
      v2 = tmp->length;
      tmp->ptr[v2] = *p;
      tmp->length = v2 + 1;
      tmp->ptr[tmp->length] = 0;
    }
  }
  if ( tmp )
    result = tmp;
  else
    result = s;
  return result;
}

//----- (0807EDF7) --------------------------------------------------------
Str __cdecl doComplete(Str ifn, int *status, int next)
{
  Str v4; // eax
  int v5; // edx
  char *v6; // eax
  char **v7; // ebx
  size_t v8; // eax
  Str v9; // eax
  int v10; // edx
  char *v11; // eax
  Str v12; // eax
  int v13; // edx
  stat st; // [esp+20h] [ebp-78h] BYREF
  Directory *dir; // [esp+78h] [ebp-20h]
  DIR *d; // [esp+7Ch] [ebp-1Ch]
  char *p; // [esp+80h] [ebp-18h]
  char *fn; // [esp+84h] [ebp-14h]
  int i; // [esp+88h] [ebp-10h]
  int fl; // [esp+8Ch] [ebp-Ch]
  _Str *ifna; // [esp+A0h] [ebp+8h]

  if ( cm_next )
  {
    CFileName = Strnew_charp(CFileBuf[NCFileOffset]);
    NCFileOffset = (int)(NCFileBuf + next + NCFileOffset) % (int)NCFileBuf;
    *status = 3;
LABEL_52:
    CompleteBuf = Strdup(CDirBuf);
    if ( CompleteBuf->length && (CompleteBuf->length <= 0 || CompleteBuf->ptr[CompleteBuf->length - 1] != 47) )
    {
      if ( CompleteBuf->length + 1 >= CompleteBuf->area_size )
        Strgrow(CompleteBuf);
      v9 = CompleteBuf;
      v10 = CompleteBuf->length;
      CompleteBuf->ptr[v10] = 47;
      v9->length = v10 + 1;
      CompleteBuf->ptr[CompleteBuf->length] = 0;
    }
    savexmlstr_0(CompleteBuf, CFileName);
    if ( *status != 1 )
    {
      p = CompleteBuf->ptr;
      if ( (cm_mode & 8) != 0 )
      {
        if ( !strncmp(p, "file://localhost/", 0x11u) )
        {
          p += 16;
        }
        else if ( !strncmp(p, "file:///", 8u) )
        {
          p += 7;
        }
        else if ( !strncmp(p, "file:/", 6u) && p[6] != 47 )
        {
          p += 5;
        }
      }
      v11 = expandPath(p);
      if ( stat_0(v11, (int)&st) != -1 && (st.st_mode & 0xF000) == 0x4000 )
      {
        if ( CompleteBuf->length + 1 >= CompleteBuf->area_size )
          Strgrow(CompleteBuf);
        v12 = CompleteBuf;
        v13 = CompleteBuf->length;
        CompleteBuf->ptr[v13] = 47;
        v12->length = v13 + 1;
        CompleteBuf->ptr[CompleteBuf->length] = 0;
      }
    }
    if ( (cm_mode & 2) != 0 )
      CompleteBuf = escape_spaces(CompleteBuf);
    return wc_Str_conv(CompleteBuf, SystemCharset, InnerCharset);
  }
  NCFileBuf = 0;
  ifna = wc_Str_conv_strict(ifn, InnerCharset, SystemCharset);
  if ( (cm_mode & 2) != 0 )
    ifna = unescape_spaces(ifna);
  for ( CompleteBuf = Strdup(ifna);
        (CompleteBuf->length <= 0 || CompleteBuf->ptr[CompleteBuf->length - 1] != 47) && CompleteBuf->length > 0;
        Strshrink(CompleteBuf, 1) )
  {
    ;
  }
  CDirBuf = Strdup(CompleteBuf);
  if ( (cm_mode & 8) != 0 )
  {
    if ( !strncmp(CompleteBuf->ptr, "file://localhost/", 0x11u) )
    {
      Strdelete(CompleteBuf, 0, 16);
    }
    else if ( !strncmp(CompleteBuf->ptr, "file:///", 8u) )
    {
      Strdelete(CompleteBuf, 0, 7);
    }
    else
    {
      if ( strncmp(CompleteBuf->ptr, "file:/", 6u) || CompleteBuf->ptr[6] == 47 )
      {
        CompleteBuf = Strdup(ifna);
        *status = 2;
        return wc_Str_conv_strict(CompleteBuf, InnerCharset, SystemCharset);
      }
      Strdelete(CompleteBuf, 0, 5);
    }
  }
  if ( !CompleteBuf->length )
  {
    if ( CompleteBuf->length + 1 >= CompleteBuf->area_size )
      Strgrow(CompleteBuf);
    v4 = CompleteBuf;
    v5 = CompleteBuf->length;
    CompleteBuf->ptr[v5] = 46;
    v4->length = v5 + 1;
    CompleteBuf->ptr[CompleteBuf->length] = 0;
  }
  if ( CompleteBuf->length > 0 && CompleteBuf->ptr[CompleteBuf->length - 1] == 47 && CompleteBuf->length > 1 )
    Strshrink(CompleteBuf, 1);
  v6 = expandPath(CompleteBuf->ptr);
  d = opendir(v6);
  if ( !d )
  {
    CompleteBuf = Strdup(ifna);
    *status = 2;
    if ( (cm_mode & 2) != 0 )
      CompleteBuf = escape_spaces(CompleteBuf);
    return CompleteBuf;
  }
  fn = lastFileName(ifna->ptr);
  fl = strlen(fn);
  CFileName = Strnew();
  while ( 1 )
  {
    dir = readdir(d);
    if ( !dir )
      break;
    if ( (fl || strcmp(dir->d_name, ".") && strcmp(dir->d_name, "..")) && !strncmp(dir->d_name, fn, fl) )
    {
      ++NCFileBuf;
      CFileBuf = (char **)GC_realloc(CFileBuf, 4 * NCFileBuf);
      v7 = &CFileBuf[NCFileBuf - 1];
      v8 = strlen(dir->d_name);
      *v7 = (char *)GC_malloc_atomic(v8 + 1);
      strcpy(CFileBuf[NCFileBuf - 1], dir->d_name);
      if ( NCFileBuf == 1 )
      {
        CFileName = Strnew_charp(dir->d_name);
      }
      else
      {
        for ( i = 0; CFileName->ptr[i] == dir->d_name[i]; ++i )
          ;
        Strtruncate(CFileName, i);
      }
    }
  }
  closedir(d);
  if ( NCFileBuf )
  {
    qsort(CFileBuf, NCFileBuf, 4u, strCmp);
    NCFileOffset = 0;
    if ( (int)NCFileBuf <= 1 )
    {
      *status = 0;
    }
    else
    {
      cm_next = 1;
      *status = 1;
    }
    goto LABEL_52;
  }
  CompleteBuf = Strdup(ifna);
  *status = 2;
  if ( (cm_mode & 2) != 0 )
    CompleteBuf = escape_spaces(CompleteBuf);
  return CompleteBuf;
}
// 8049E6C: using guessed type int __cdecl GC_realloc(_DWORD, _DWORD);
// 804A51C: using guessed type int __cdecl GC_malloc_atomic(_DWORD);

//----- (0807F5AE) --------------------------------------------------------
void prev()
{
  char *p; // [esp+18h] [ebp-10h]

  if ( use_hist )
  {
    if ( strCurrentBuf )
    {
      p = prevHist(CurrentHist);
      if ( !p )
        return;
    }
    else
    {
      p = lastHist(CurrentHist);
      if ( !p )
        return;
      strCurrentBuf = strBuf;
    }
    if ( DecodeURL )
    {
      if ( (cm_mode & 8) != 0 )
        p = url_unquote_conv(p, 0);
    }
    strBuf = Strnew_charp(p);
    CPos = setStrType(strBuf, strProp);
    CLen = CPos;
    offset = 0;
  }
}

//----- (0807F67A) --------------------------------------------------------
void next()
{
  char *p; // [esp+18h] [ebp-10h]

  if ( use_hist && strCurrentBuf )
  {
    p = nextHist(CurrentHist);
    if ( p )
    {
      if ( DecodeURL )
      {
        if ( (cm_mode & 8) != 0 )
          p = url_unquote_conv(p, 0);
      }
      strBuf = Strnew_charp(p);
    }
    else
    {
      strBuf = strCurrentBuf;
      strCurrentBuf = 0;
    }
    CPos = setStrType(strBuf, strProp);
    CLen = CPos;
    offset = 0;
  }
}

//----- (0807F73D) --------------------------------------------------------
int __cdecl setStrType(Str str, Lineprop *prop)
{
  Lineprop v2; // ax
  int len; // [esp+Ch] [ebp-14h]
  int lena; // [esp+Ch] [ebp-14h]
  int i; // [esp+10h] [ebp-10h]
  char *ep; // [esp+14h] [ebp-Ch]
  char *p; // [esp+18h] [ebp-8h]
  Lineprop ctype; // [esp+1Eh] [ebp-2h]
  Lineprop ctypea; // [esp+1Eh] [ebp-2h]

  p = str->ptr;
  ep = &str->ptr[str->length];
  i = 0;
  while ( p < ep )
  {
    len = WTF_LEN_MAP[(unsigned __int8)*p];
    if ( i + len > 1024 )
      break;
    ctype = WTF_TYPE_MAP[(unsigned __int8)*p] << 8;
    if ( is_passwd )
    {
      if ( (ctype & 0x100) != 0 )
        ctype = 0;
      if ( (ctype & 0x1000) != 0 )
        ctype = 512;
    }
    prop[i++] = ctype;
    p += len;
    lena = len - 1;
    if ( lena )
    {
      LOBYTE(v2) = ctype;
      HIBYTE(v2) = HIBYTE(ctype) & 0xF9 | 4;
      for ( ctypea = v2; lena-- != 0; prop[i++] = ctypea )
        ;
    }
  }
  return i;
}

//----- (0807F846) --------------------------------------------------------
int __cdecl terminated(unsigned __int8 c)
{
  int termchar[5]; // [esp+Ch] [ebp-18h] BYREF
  int *tp; // [esp+20h] [ebp-4h]

  termchar[0] = 47;
  termchar[1] = 38;
  termchar[2] = 63;
  termchar[3] = 32;
  termchar[4] = -1;
  for ( tp = termchar; *tp > 0; ++tp )
  {
    if ( c == *tp )
      return 1;
  }
  return 0;
}

//----- (0807F8A5) --------------------------------------------------------
void editor()
{
  Str v0; // eax
  int v1; // edx
  Str v2; // eax
  int v3; // edx
  FormItemList fi; // [esp+14h] [ebp-54h] BYREF
  char *p; // [esp+5Ch] [ebp-Ch]

  if ( !is_passwd )
  {
    fi.readonly = 0;
    fi.value = Strdup(strBuf);
    if ( fi.value->length + 1 >= fi.value->area_size )
      Strgrow(fi.value);
    v0 = fi.value;
    v1 = fi.value->length;
    fi.value->ptr[v1] = 10;
    v0->length = v1 + 1;
    fi.value->ptr[fi.value->length] = 0;
    input_textarea(&fi);
    strBuf = Strnew();
    for ( p = fi.value->ptr; *p; ++p )
    {
      if ( *p != 13 && *p != 10 )
      {
        if ( strBuf->length + 1 >= strBuf->area_size )
          Strgrow(strBuf);
        v2 = strBuf;
        v3 = strBuf->length;
        strBuf->ptr[v3] = *p;
        v2->length = v3 + 1;
        strBuf->ptr[strBuf->length] = 0;
      }
    }
    CPos = setStrType(strBuf, strProp);
    CLen = CPos;
    if ( CurrentTab )
      displayBuffer(CurrentTab->currentBuffer, 1);
  }
}

//----- (0807FA0C) --------------------------------------------------------
int __cdecl LUfactor(Matrix A, int *indexarray)
{
  double *v2; // eax
  double tmp_1; // [esp+18h] [ebp-40h]
  double tmp; // [esp+20h] [ebp-38h]
  double tmpa; // [esp+20h] [ebp-38h]
  double tmpb; // [esp+20h] [ebp-38h]
  double mx; // [esp+28h] [ebp-30h]
  double mxa; // [esp+28h] [ebp-30h]
  int tmp_0; // [esp+30h] [ebp-28h]
  Vector scale; // [esp+34h] [ebp-24h]
  int i_max; // [esp+3Ch] [ebp-1Ch]
  int k; // [esp+40h] [ebp-18h]
  int j; // [esp+44h] [ebp-14h]
  int ja; // [esp+44h] [ebp-14h]
  int jb; // [esp+44h] [ebp-14h]
  int i; // [esp+48h] [ebp-10h]
  int ia; // [esp+48h] [ebp-10h]
  int ib; // [esp+48h] [ebp-10h]
  int ic; // [esp+48h] [ebp-10h]
  int dim; // [esp+4Ch] [ebp-Ch]

  dim = A->dim;
  scale = new_vector(dim);
  for ( i = 0; i < dim; ++i )
    indexarray[i] = i;
  for ( ia = 0; ia < dim; ++ia )
  {
    mx = 0.0;
    for ( j = 0; j < dim; ++j )
    {
      tmp = fabs(A->me[j + ia * A->dim]);
      if ( tmp > (long double)mx )
        mx = tmp;
    }
    scale->ve[ia] = mx;
  }
  for ( k = 0; k < dim - 1; ++k )
  {
    mxa = 0.0;
    i_max = -1;
    for ( ib = k; ib < dim; ++ib )
    {
      if ( fabs(scale->ve[ib]) >= fabs(A->me[k + ib * A->dim]) * Tiny )
      {
        tmpa = fabs(A->me[k + ib * A->dim]) / scale->ve[ib];
        if ( tmpa > (long double)mxa )
        {
          mxa = tmpa;
          i_max = ib;
        }
      }
    }
    if ( i_max == -1 )
    {
      *(double *)((char *)A->me + k * 8 * (A->dim + 1)) = 0.0;
    }
    else
    {
      if ( i_max != k )
      {
        tmp_0 = indexarray[i_max];
        indexarray[i_max] = indexarray[k];
        indexarray[k] = tmp_0;
        for ( ja = 0; ja < dim; ++ja )
        {
          tmp_1 = A->me[ja + i_max * A->dim];
          A->me[ja + i_max * A->dim] = A->me[ja + k * A->dim];
          A->me[ja + k * A->dim] = tmp_1;
        }
      }
      for ( ic = k + 1; ic < dim; ++ic )
      {
        v2 = &A->me[k + ic * A->dim];
        *v2 = *v2 / *(double *)((char *)A->me + k * 8 * (A->dim + 1));
        tmpb = *v2;
        for ( jb = k + 1; jb < dim; ++jb )
          A->me[jb + ic * A->dim] = A->me[jb + ic * A->dim] - A->me[jb + k * A->dim] * tmpb;
      }
    }
  }
  return 0;
}

//----- (0807FD68) --------------------------------------------------------
int __cdecl LUsolve(Matrix A, int *indexarray, Vector b, Vector x)
{
  int result; // eax
  int dim; // [esp+28h] [ebp-10h]
  int i; // [esp+2Ch] [ebp-Ch]

  dim = A->dim;
  for ( i = 0; i < dim; ++i )
    x->ve[i] = b->ve[indexarray[i]];
  if ( Lsolve(A, x, x, 1.0) == -1 || Usolve(A, x, x, 0.0) == -1 )
    result = -1;
  else
    result = 0;
  return result;
}

//----- (0807FE0A) --------------------------------------------------------
Matrix __cdecl LUinverse(Matrix A, int *indexarray, Matrix out)
{
  vector *tmp2; // [esp+1Ch] [ebp-1Ch]
  vector *tmp; // [esp+20h] [ebp-18h]
  int dim; // [esp+24h] [ebp-14h]
  int j; // [esp+28h] [ebp-10h]
  int ja; // [esp+28h] [ebp-10h]
  int i; // [esp+2Ch] [ebp-Ch]

  dim = A->dim;
  if ( !out )
    out = new_matrix(dim);
  tmp = new_vector(dim);
  tmp2 = new_vector(dim);
  for ( i = 0; i < dim; ++i )
  {
    for ( j = 0; j < dim; ++j )
      tmp->ve[j] = 0.0;
    tmp->ve[i] = 1.0;
    if ( LUsolve(A, indexarray, tmp, tmp2) == -1 )
      return 0;
    for ( ja = 0; ja < dim; ++ja )
      out->me[i + ja * out->dim] = tmp2->ve[ja];
  }
  return out;
}

//----- (0807FF0A) --------------------------------------------------------
int __cdecl Usolve(Matrix mat, Vector b, Vector out, double diag)
{
  double sum; // [esp+10h] [ebp-18h]
  int i_lim; // [esp+1Ch] [ebp-Ch]
  int j; // [esp+20h] [ebp-8h]
  int i; // [esp+24h] [ebp-4h]

  for ( i = mat->dim - 1; i >= 0 && b->ve[i] == 0.0; --i )
    out->ve[i] = 0.0;
  i_lim = i;
  while ( i >= 0 )
  {
    sum = b->ve[i];
    for ( j = i + 1; j <= i_lim; ++j )
      sum = sum - mat->me[j + i * mat->dim] * out->ve[j];
    if ( diag == 0.0 )
    {
      if ( fabs(sum) * Tiny >= fabs(*(double *)((char *)mat->me + i * 8 * (mat->dim + 1))) )
        return -1;
      out->ve[i] = sum / *(double *)((char *)mat->me + i * 8 * (mat->dim + 1));
    }
    else
    {
      out->ve[i] = sum / diag;
    }
    --i;
  }
  return 0;
}

//----- (08080075) --------------------------------------------------------
int __cdecl Lsolve(Matrix mat, Vector b, Vector out, double diag)
{
  double sum; // [esp+10h] [ebp-18h]
  int dim; // [esp+18h] [ebp-10h]
  int i_lim; // [esp+1Ch] [ebp-Ch]
  int j; // [esp+20h] [ebp-8h]
  int i; // [esp+24h] [ebp-4h]

  dim = mat->dim;
  for ( i = 0; i < dim && b->ve[i] == 0.0; ++i )
    out->ve[i] = 0.0;
  i_lim = i;
  while ( i < dim )
  {
    sum = b->ve[i];
    for ( j = i_lim; j < i; ++j )
      sum = sum - mat->me[j + i * mat->dim] * out->ve[j];
    if ( diag == 0.0 )
    {
      if ( fabs(sum) * Tiny >= fabs(*(double *)((char *)mat->me + i * 8 * (mat->dim + 1))) )
        return -1;
      out->ve[i] = sum / *(double *)((char *)mat->me + i * 8 * (mat->dim + 1));
    }
    else
    {
      out->ve[i] = sum / diag;
    }
    ++i;
  }
  return 0;
}

//----- (080801DF) --------------------------------------------------------
Matrix __cdecl new_matrix(int n)
{
  Matrix mat; // [esp+1Ch] [ebp-Ch]

  mat = (Matrix)GC_malloc(8);
  mat->dim = n;
  mat->me = (double *)GC_malloc_atomic(8 * n * n);
  return mat;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);
// 804A51C: using guessed type int __cdecl GC_malloc_atomic(_DWORD);

//----- (0808021B) --------------------------------------------------------
Vector __cdecl new_vector(int n)
{
  Vector vec; // [esp+1Ch] [ebp-Ch]

  vec = (Vector)GC_malloc(8);
  vec->dim = n;
  vec->ve = (double *)GC_malloc_atomic(8 * n);
  return vec;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);
// 804A51C: using guessed type int __cdecl GC_malloc_atomic(_DWORD);

//----- (08080253) --------------------------------------------------------
double __cdecl weight(int x)
{
  double v2; // [esp+10h] [ebp-18h]

  if ( x < COLS )
    return (long double)x;
  v2 = (double)COLS;
  return (log((long double)x / (long double)COLS) + 1.0) * v2;
}

//----- (08080297) --------------------------------------------------------
double __cdecl weight2(int a)
{
  return (long double)a / (long double)COLS * 4.0 + 1.0;
}

//----- (080802BB) --------------------------------------------------------
int __cdecl bsearch_2short(__int16 e1, __int16 *ent1, __int16 e2, __int16 *ent2, int base, __int16 *indexarray, int nent)
{
  int ne; // [esp+10h] [ebp-18h]
  int idx; // [esp+14h] [ebp-14h]
  int nn; // [esp+18h] [ebp-10h]
  int e; // [esp+1Ch] [ebp-Ch]
  int k; // [esp+20h] [ebp-8h]

  k = 0;
  e = base * e1 + e2;
  while ( nent > 0 )
  {
    nn = nent / 2;
    idx = indexarray[k + nent / 2];
    ne = base * ent1[idx] + ent2[idx];
    if ( ne == e )
    {
      k += nn;
      return k;
    }
    if ( ne >= e )
    {
      nent /= 2;
    }
    else
    {
      nent += ~nn;
      k += nn + 1;
    }
  }
  return k;
}

//----- (08080377) --------------------------------------------------------
int __cdecl bsearch_double(double e, double *ent, __int16 *indexarray, int nent)
{
  double ne; // [esp+10h] [ebp-18h]
  int nn; // [esp+1Ch] [ebp-Ch]
  int k; // [esp+20h] [ebp-8h]

  k = 0;
  while ( nent > 0 )
  {
    nn = nent / 2;
    ne = ent[indexarray[k + nent / 2]];
    if ( ne == e )
    {
      k += nn;
      return k;
    }
    if ( ne <= (long double)e )
    {
      nent /= 2;
    }
    else
    {
      nent += ~nn;
      k += nn + 1;
    }
  }
  return k;
}

//----- (0808041A) --------------------------------------------------------
int __cdecl ceil_at_intervals(int x, int step)
{
  int mo; // [esp+Ch] [ebp-4h]

  mo = x % step;
  if ( x % step <= 0 )
  {
    if ( mo < 0 )
      x -= mo;
  }
  else
  {
    x += step - mo;
  }
  return x;
}

//----- (08080456) --------------------------------------------------------
int __cdecl floor_at_intervals(int x, int step)
{
  int mo; // [esp+Ch] [ebp-4h]

  mo = x % step;
  if ( x % step <= 0 )
  {
    if ( mo < 0 )
      x += step - mo;
  }
  else
  {
    x -= mo;
  }
  return x;
}

//----- (08080492) --------------------------------------------------------
int __cdecl table_colspan(table *t, int row, int col)
{
  int i; // [esp+Ch] [ebp-4h]

  for ( i = col + 1; t->maxcol >= i && (t->tabattr[row][i] & 1) != 0; ++i )
    ;
  return i - col;
}

//----- (080804E4) --------------------------------------------------------
int __cdecl table_rowspan(table *t, int row, int col)
{
  int i; // [esp+Ch] [ebp-4h]

  if ( !t->tabattr[row] )
    return 0;
  for ( i = row + 1; t->maxrow >= i && t->tabattr[i] && (t->tabattr[i][col] & 2) != 0; ++i )
    ;
  return i - row;
}

//----- (08080565) --------------------------------------------------------
int __cdecl minimum_cellspacing(int border_mode)
{
  if ( !border_mode )
    return 1;
  if ( border_mode < 0 || border_mode > 3 )
    return 0;
  return symbol_width;
}

//----- (0808058D) --------------------------------------------------------
int __cdecl table_border_width(table *t)
{
  int v1; // eax

  v1 = t->border_mode;
  if ( v1 <= 2 )
  {
    if ( v1 >= 1 )
      return t->cellspacing * t->maxcol + 2 * (t->cellpadding + symbol_width);
    if ( v1 )
      return 0;
    return t->maxcol * t->cellspacing;
  }
  if ( v1 == 3 )
    return t->maxcol * t->cellspacing;
  return 0;
}

//----- (080805E9) --------------------------------------------------------
table *newTable()
{
  int j; // [esp+14h] [ebp-14h]
  int i; // [esp+18h] [ebp-10h]
  table *t; // [esp+1Ch] [ebp-Ch]

  t = (table *)GC_malloc(716);
  t->max_rowsize = 50;
  t->tabdata = (GeneralList ***)GC_malloc(200);
  t->tabattr = (table_attr **)GC_malloc(200);
  t->tabheight = (__int16 *)GC_malloc_atomic(100);
  t->tabidvalue = (Str **)GC_malloc(200);
  t->tridvalue = (Str *)GC_malloc(200);
  for ( i = 0; i <= 49; ++i )
  {
    t->tabdata[i] = 0;
    t->tabattr[i] = 0;
    t->tabheight[i] = 0;
    t->tabidvalue[i] = 0;
    t->tridvalue[i] = 0;
  }
  for ( j = 0; j <= 49; ++j )
  {
    t->tabwidth[j] = 0;
    t->minimum_width[j] = 0;
    t->fixed_width[j] = 0;
  }
  t->cell.maxcell = -1;
  t->cell.icell = -1;
  t->ntable = 0;
  t->tables_size = 0;
  t->tables = 0;
  t->matrix = 0;
  t->vector = 0;
  t->linfo.prevchar = Strnew_size(8);
  Strcopy_charp_n(t->linfo.prevchar, (char *)&byte_80CB060, 0);
  t->trattr = 0;
  t->caption = Strnew();
  t->suspended_data = 0;
  t->id = 0;
  return t;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);
// 804A51C: using guessed type int __cdecl GC_malloc_atomic(_DWORD);

//----- (080807E9) --------------------------------------------------------
void __cdecl check_row(table *t, int row)
{
  int v2; // eax
  GeneralList ***v3; // ebx
  table_attr **v4; // ebx
  Str **v5; // ebx
  Str *tridvalue; // [esp+14h] [ebp-24h]
  Str **tabidvalue; // [esp+18h] [ebp-20h]
  __int16 *tabheight; // [esp+1Ch] [ebp-1Ch]
  table_attr **tabattr; // [esp+20h] [ebp-18h]
  GeneralList ***tabdata; // [esp+24h] [ebp-14h]
  int r; // [esp+28h] [ebp-10h]
  int i; // [esp+2Ch] [ebp-Ch]
  int ia; // [esp+2Ch] [ebp-Ch]

  if ( t->max_rowsize <= row )
  {
    v2 = 2 * t->max_rowsize;
    if ( row + 1 >= v2 )
      v2 = row + 1;
    r = v2;
    tabdata = (GeneralList ***)GC_malloc(4 * v2);
    tabattr = (table_attr **)GC_malloc(4 * r);
    tabheight = (__int16 *)GC_malloc_atomic(2 * r);
    tabidvalue = (Str **)GC_malloc(4 * r);
    tridvalue = (Str *)GC_malloc(4 * r);
    for ( i = 0; t->max_rowsize > i; ++i )
    {
      tabdata[i] = t->tabdata[i];
      tabattr[i] = t->tabattr[i];
      tabheight[i] = t->tabheight[i];
      tabidvalue[i] = t->tabidvalue[i];
      tridvalue[i] = t->tridvalue[i];
    }
    while ( i < r )
    {
      tabdata[i] = 0;
      tabattr[i] = 0;
      tabheight[i] = 0;
      tabidvalue[i] = 0;
      tridvalue[i++] = 0;
    }
    t->tabdata = tabdata;
    t->tabattr = tabattr;
    t->tabheight = tabheight;
    t->tabidvalue = tabidvalue;
    t->tridvalue = tridvalue;
    t->max_rowsize = r;
  }
  if ( !t->tabdata[row] )
  {
    v3 = &t->tabdata[row];
    *v3 = (GeneralList **)GC_malloc(200);
    v4 = &t->tabattr[row];
    *v4 = (table_attr *)GC_malloc_atomic(100);
    v5 = &t->tabidvalue[row];
    *v5 = (Str *)GC_malloc(200);
    for ( ia = 0; ia <= 49; ++ia )
    {
      t->tabdata[row][ia] = 0;
      t->tabattr[row][ia] = 0;
      t->tabidvalue[row][ia] = 0;
    }
  }
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);
// 804A51C: using guessed type int __cdecl GC_malloc_atomic(_DWORD);

//----- (08080A82) --------------------------------------------------------
void __cdecl pushdata(table *t, int row, int col, char *data)
{
  GeneralList **v4; // ebx
  char *v5; // eax
  char *v6; // eax

  check_row(t, row);
  if ( !t->tabdata[row][col] )
  {
    v4 = &t->tabdata[row][col];
    *v4 = newGeneralList();
  }
  if ( data )
    v5 = data;
  else
    v5 = (char *)&byte_80CB060;
  v6 = allocStr(v5, -1);
  pushValue(t->tabdata[row][col], v6);
}

//----- (08080B25) --------------------------------------------------------
void __cdecl suspend_or_pushdata(table *tbl, char *line)
{
  char *v2; // eax
  char *v3; // eax

  if ( (tbl->flag & 4) != 0 )
  {
    pushdata(tbl, tbl->row, tbl->col, line);
  }
  else
  {
    if ( !tbl->suspended_data )
      tbl->suspended_data = (TextList *)newGeneralList();
    if ( line )
      v2 = line;
    else
      v2 = (char *)&byte_80CB060;
    v3 = allocStr(v2, -1);
    pushValue((GeneralList *)tbl->suspended_data, v3);
  }
}

//----- (08080BB3) --------------------------------------------------------
int __cdecl visible_length(char *str)
{
  int v1; // eax
  int v2; // ebx
  int v3; // eax
  int v4; // ebx
  int v5; // eax
  int result; // eax
  int amp_len; // [esp+1Ch] [ebp-2Ch]
  char *r2; // [esp+20h] [ebp-28h] BYREF
  char *t; // [esp+24h] [ebp-24h]
  Str tagbuf; // [esp+28h] [ebp-20h]
  int prev_status; // [esp+2Ch] [ebp-1Ch]
  int status; // [esp+30h] [ebp-18h] BYREF
  int max_len; // [esp+34h] [ebp-14h]
  int n; // [esp+38h] [ebp-10h]
  int len; // [esp+3Ch] [ebp-Ch]

  len = 0;
  max_len = 0;
  status = 0;
  prev_status = 0;
  tagbuf = Strnew();
  amp_len = 0;
  t = str;
  while ( *str )
  {
    prev_status = status;
    if ( next_status(*str, &status) )
    {
      if ( WcOption.use_wide )
        v1 = WTF_WIDTH_MAP[(unsigned __int8)*str];
      else
        v1 = WTF_WIDTH_MAP[(unsigned __int8)*str] != 0;
      len += v1;
      n = WTF_LEN_MAP[(unsigned __int8)*str];
    }
    else
    {
      n = 1;
    }
    switch ( status )
    {
      case 1:
        Strclear(tagbuf);
        Strcat_charp_n(tagbuf, str, n);
        break;
      case 2:
      case 4:
      case 3:
      case 5:
      case 15:
        Strcat_charp_n(tagbuf, str, n);
        break;
      case 6:
        if ( prev_status )
        {
          Strcat_charp_n(tagbuf, str, n);
          ++amp_len;
        }
        else
        {
          Strclear(tagbuf);
          --len;
          amp_len = 0;
        }
        break;
      default:
        if ( status || prev_status != 6 )
        {
          if ( status || prev_status != 2 && prev_status != 1 && prev_status != 5 && prev_status != 15 )
          {
            if ( *str == 9 )
            {
              --len;
              do
                ++len;
              while ( (len + visible_length_offset) % Tabstop );
            }
            else if ( *str == 13 || *str == 10 )
            {
              if ( --len > max_len )
                max_len = len;
              len = 0;
            }
          }
        }
        else
        {
          Strcat_charp_n(tagbuf, str, n);
          r2 = tagbuf->ptr;
          t = getescapecmd(&r2);
          if ( !*r2 && (*t == 13 || *t == 10) )
          {
            if ( len > max_len )
              max_len = len;
            len = 0;
          }
          else
          {
            v2 = wtf_strwidth((wc_uchar *)t);
            v3 = wtf_strwidth((wc_uchar *)r2);
            len += v2 + v3;
          }
        }
        break;
    }
    str += n;
  }
  if ( status == 6 )
  {
    r2 = tagbuf->ptr;
    t = getescapecmd(&r2);
    if ( *t != 13 && *t != 10 )
    {
      v4 = wtf_strwidth((wc_uchar *)t);
      v5 = wtf_strwidth((wc_uchar *)r2);
      len += v4 + v5;
    }
  }
  result = len;
  if ( max_len >= len )
    result = max_len;
  return result;
}

//----- (08080EB9) --------------------------------------------------------
int __cdecl visible_length_plain(char *str)
{
  int v1; // eax
  int result; // eax
  int max_len; // [esp+8h] [ebp-8h]
  int len; // [esp+Ch] [ebp-4h]

  len = 0;
  max_len = 0;
  while ( *str )
  {
    if ( *str == 9 )
    {
      do
        ++len;
      while ( (len + visible_length_offset) % Tabstop );
      ++str;
    }
    else if ( *str == 13 || *str == 10 )
    {
      if ( len > max_len )
        max_len = len;
      len = 0;
      ++str;
    }
    else
    {
      if ( WcOption.use_wide )
        v1 = WTF_WIDTH_MAP[(unsigned __int8)*str];
      else
        v1 = WTF_WIDTH_MAP[(unsigned __int8)*str] != 0;
      len += v1;
      str += WTF_LEN_MAP[(unsigned __int8)*str];
    }
  }
  result = len;
  if ( max_len >= len )
    result = max_len;
  return result;
}

//----- (08080F9E) --------------------------------------------------------
int __cdecl maximum_visible_length(char *str, int offset)
{
  visible_length_offset = offset;
  return visible_length(str);
}

//----- (08080FB9) --------------------------------------------------------
int __cdecl maximum_visible_length_plain(char *str, int offset)
{
  visible_length_offset = offset;
  return visible_length_plain(str);
}

//----- (08080FD4) --------------------------------------------------------
void __cdecl align(TextLine *lbuf, int width, int mode)
{
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  Str line; // [esp+18h] [ebp-20h]
  Str buf; // [esp+1Ch] [ebp-1Ch]
  int l; // [esp+28h] [ebp-10h]
  int i; // [esp+2Ch] [ebp-Ch]
  int ia; // [esp+2Ch] [ebp-Ch]
  int ib; // [esp+2Ch] [ebp-Ch]
  int ic; // [esp+2Ch] [ebp-Ch]
  int id; // [esp+2Ch] [ebp-Ch]

  line = lbuf->line;
  if ( lbuf->line->length )
  {
    buf = Strnew();
    l = width - lbuf->pos;
    if ( mode == 1 )
    {
      savexmlstr_0(buf, line);
      for ( ic = 0; ic < l; ++ic )
      {
        if ( buf->length + 1 >= buf->area_size )
          Strgrow(buf);
        v6 = buf->length;
        buf->ptr[v6] = 32;
        buf->length = v6 + 1;
        buf->ptr[buf->length] = 0;
      }
    }
    else if ( mode == 2 )
    {
      for ( id = 0; id < l; ++id )
      {
        if ( buf->length + 1 >= buf->area_size )
          Strgrow(buf);
        v7 = buf->length;
        buf->ptr[v7] = 32;
        buf->length = v7 + 1;
        buf->ptr[buf->length] = 0;
      }
      savexmlstr_0(buf, line);
    }
    else
    {
      if ( mode )
        return;
      for ( ia = 0; ia < l / 2; ++ia )
      {
        if ( buf->length + 1 >= buf->area_size )
          Strgrow(buf);
        v4 = buf->length;
        buf->ptr[v4] = 32;
        buf->length = v4 + 1;
        buf->ptr[buf->length] = 0;
      }
      savexmlstr_0(buf, line);
      for ( ib = 0; ib < l - l / 2; ++ib )
      {
        if ( buf->length + 1 >= buf->area_size )
          Strgrow(buf);
        v5 = buf->length;
        buf->ptr[v5] = 32;
        buf->length = v5 + 1;
        buf->ptr[buf->length] = 0;
      }
    }
    lbuf->line = buf;
    if ( lbuf->pos < width )
      lbuf->pos = width;
  }
  else
  {
    for ( i = 0; i < width; ++i )
    {
      if ( line->length + 1 >= line->area_size )
        Strgrow(line);
      v3 = line->length;
      line->ptr[v3] = 32;
      line->length = v3 + 1;
      line->ptr[line->length] = 0;
    }
    lbuf->pos = width;
  }
}

//----- (08081299) --------------------------------------------------------
void __cdecl print_item(table *t, int row, int col, int width, Str buf)
{
  TextLine *lbuf; // [esp+18h] [ebp-10h]
  TextLine *lbufa; // [esp+18h] [ebp-10h]
  int alignment; // [esp+1Ch] [ebp-Ch]

  if ( t->tabdata[row] )
    lbuf = (TextLine *)popValue(t->tabdata[row][col]);
  else
    lbuf = 0;
  if ( lbuf )
  {
    check_row(t, row);
    alignment = 0;
    if ( (t->tabattr[row][col] & 0x30) != 0 )
    {
      if ( (t->tabattr[row][col] & 0x30) == 32 )
      {
        alignment = 2;
      }
      else if ( (t->tabattr[row][col] & 0x30) == 16 )
      {
        alignment = 0;
      }
    }
    else
    {
      alignment = 1;
    }
    align(lbuf, width, alignment);
    savexmlstr_0(buf, lbuf->line);
  }
  else
  {
    lbufa = newTextLine(0, 0);
    align(lbufa, width, 0);
    savexmlstr_0(buf, lbufa->line);
  }
}

//----- (08081401) --------------------------------------------------------
void __cdecl print_sep(table *t, int row, int type, int maxcol, Str buf)
{
  char v5; // al
  char v6; // al
  char v7; // al
  char v8; // al
  int w; // [esp+34h] [ebp-24h]
  int m; // [esp+38h] [ebp-20h]
  int l; // [esp+3Ch] [ebp-1Ch]
  int k; // [esp+40h] [ebp-18h]
  int i; // [esp+44h] [ebp-14h]
  int rule_mode; // [esp+48h] [ebp-10h]
  char forbid; // [esp+4Ch] [ebp-Ch]
  int forbida; // [esp+4Ch] [ebp-Ch]
  char forbidb; // [esp+4Ch] [ebp-Ch]

  if ( row >= 0 )
    check_row(t, row);
  check_row(t, row + 1);
  if ( (!type || type == 2) && t->border_mode == 2 )
    rule_mode = 2;
  else
    rule_mode = 1;
  forbid = 1;
  if ( type )
  {
    if ( type == 2 )
    {
      forbid = 9;
    }
    else if ( (*t->tabattr[row + 1] & 2) != 0 )
    {
      forbid = 5;
    }
  }
  else
  {
    forbid = 3;
  }
  if ( t->border_mode != 3 )
  {
    if ( t->border_mode == 2 )
      v5 = forbid + 16;
    else
      v5 = forbid;
    push_symbol(buf, v5, symbol_width, 1);
  }
  for ( i = 0; i <= maxcol; ++i )
  {
    if ( type == 2 || (t->tabattr[row + 1][i] & 2) == 0 )
    {
      w = t->tabwidth[i] + 2 * t->cellpadding;
      if ( symbol_width == 2 )
        w = (w + 1) / symbol_width;
      if ( rule_mode == 2 )
        v6 = 26;
      else
        v6 = 10;
      push_symbol(buf, v6, symbol_width, w);
    }
    else if ( (t->tabattr[row + 1][i] & 1) == 0 )
    {
      for ( k = row; k >= 0 && t->tabattr[k] && (t->tabattr[k][i] & 2) != 0; --k )
        ;
      m = t->tabwidth[i] + 2 * t->cellpadding;
      for ( l = i + 1; t->maxcol >= l && (t->tabattr[row][l] & 1) != 0; ++l )
        m += t->tabwidth[l] + t->cellspacing;
      print_item(t, k, i, m, buf);
    }
    if ( i < maxcol )
    {
      forbida = 0;
      if ( type )
      {
        if ( (t->tabattr[row][i + 1] & 1) != 0 )
          forbida = 2;
      }
      else
      {
        forbida = 2;
      }
      if ( type == 2 )
      {
        forbida |= 8u;
      }
      else
      {
        if ( (t->tabattr[row + 1][i + 1] & 1) != 0 )
          forbida |= 8u;
        if ( (t->tabattr[row + 1][i + 1] & 2) != 0 )
          forbida |= 4u;
        if ( (t->tabattr[row + 1][i] & 2) != 0 )
          forbida |= 1u;
      }
      if ( forbida != 15 )
      {
        if ( rule_mode == 2 )
          v7 = forbida + 16;
        else
          v7 = forbida;
        push_symbol(buf, v7, symbol_width, 1);
      }
    }
  }
  forbidb = 4;
  if ( !type )
    forbidb = 6;
  if ( type == 2 )
    forbidb |= 8u;
  if ( (t->tabattr[row + 1][maxcol] & 2) != 0 )
    forbidb |= 1u;
  if ( t->border_mode != 3 )
  {
    if ( t->border_mode == 2 )
      v8 = forbidb + 16;
    else
      v8 = forbidb;
    push_symbol(buf, v8, symbol_width, 1);
  }
}

//----- (08081881) --------------------------------------------------------
int __cdecl get_spec_cell_width(table *tbl, int row, int col)
{
  int w; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]

  w = tbl->tabwidth[col];
  for ( i = col + 1; tbl->maxcol >= i; ++i )
  {
    check_row(tbl, row);
    if ( (tbl->tabattr[row][i] & 1) == 0 )
      break;
    w += tbl->tabwidth[i] + tbl->cellspacing;
  }
  return w;
}

//----- (0808190E) --------------------------------------------------------
void __cdecl do_refill(table *tbl, int row, int col, int maxlimit)
{
  GeneralList **v4; // ebx
  int v5; // eax
  int v6; // eax
  int v7; // eax
  readbuffer obuf; // [esp+28h] [ebp-310h] BYREF
  environment envs[20]; // [esp+178h] [ebp-1C0h] BYREF
  html_feed_environ h_env; // [esp+2B8h] [ebp-80h] BYREF
  int k; // [esp+2E8h] [ebp-50h]
  table_cell *cell; // [esp+2ECh] [ebp-4Ch]
  int rowspan; // [esp+2F0h] [ebp-48h]
  int limit; // [esp+2F4h] [ebp-44h]
  table *t; // [esp+2F8h] [ebp-40h]
  TextLineListItem *ti; // [esp+2FCh] [ebp-3Ch]
  int alignment; // [esp+300h] [ebp-38h]
  parsed_tag *tag; // [esp+304h] [ebp-34h]
  char *p; // [esp+308h] [ebp-30h] BYREF
  int id; // [esp+30Ch] [ebp-2Ch] BYREF
  int icell; // [esp+310h] [ebp-28h]
  int colspan; // [esp+314h] [ebp-24h]
  TextListItem *l; // [esp+318h] [ebp-20h]
  TextList *orgdata; // [esp+31Ch] [ebp-1Ch]

  if ( !tbl->tabdata[row] || !tbl->tabdata[row][col] )
    return;
  orgdata = (TextList *)tbl->tabdata[row][col];
  v4 = &tbl->tabdata[row][col];
  *v4 = newGeneralList();
  v5 = get_spec_cell_width(tbl, row, col);
  init_henv(&h_env, &obuf, envs, 20, (TextLineList *)tbl->tabdata[row][col], v5, 0);
  obuf.flag |= 0x20000u;
  if ( h_env.limit > maxlimit )
    h_env.limit = maxlimit;
  if ( tbl->border_mode && tbl->vcellpadding > 0 )
    do_blankline(&h_env, &obuf, 0, 0, h_env.limit);
  for ( l = orgdata->first; l; l = l->next )
  {
    if ( !strncasecmp(l->ptr, "<table_alt", 0xAu)
      && (l->ptr[10] == 62 || (MYCTYPE_MAP[*((unsigned __int8 *)l->ptr + 10)] & 2) != 0) )
    {
      id = -1;
      p = l->ptr;
      tag = parse_tag(&p, 1);
      if ( tag )
        parsedtag_get_value(tag, 64, &id);
      if ( id >= 0 && tbl->ntable > id )
      {
        t = tbl->tables[id].ptr;
        limit = tbl->tables[id].indent + t->total_width;
        tbl->tables[id].ptr = 0;
        save_fonteffect(&h_env, h_env.obuf);
        flushline(&h_env, &obuf, 0, 2, h_env.limit);
        if ( t->vspace > 0 && (obuf.flag & 0x2000) == 0 )
          do_blankline(&h_env, &obuf, 0, 0, h_env.limit);
        if ( (h_env.obuf->flag & 0x70) == 32 )
        {
          alignment = 0;
        }
        else if ( (h_env.obuf->flag & 0x70) == 64 )
        {
          alignment = 2;
        }
        else
        {
          alignment = 1;
        }
        if ( alignment != 1 )
        {
          for ( ti = tbl->tables[id].buf->first; ti; ti = ti->next )
            align(ti->ptr, h_env.limit, alignment);
        }
        appendGeneralList((GeneralList *)h_env.buf, (GeneralList *)tbl->tables[id].buf);
        if ( h_env.maxlimit < limit )
          h_env.maxlimit = limit;
        restore_fonteffect(&h_env, h_env.obuf);
        v6 = obuf.flag;
        BYTE1(v6) = BYTE1(obuf.flag) & 0xDF;
        obuf.flag = v6;
        h_env.blank_lines = 0;
        if ( t->vspace > 0 )
        {
          do_blankline(&h_env, &obuf, 0, 0, h_env.limit);
          v7 = obuf.flag;
          BYTE1(v7) = BYTE1(obuf.flag) | 0x20;
          obuf.flag = v7;
        }
      }
    }
    else
    {
      HTMLlineproc0(l->ptr, &h_env, 1);
    }
  }
  if ( obuf.status )
  {
    obuf.status = 7;
    HTMLlineproc0("\n", &h_env, 1);
  }
  completeHTMLstream(&h_env, &obuf);
  flushline(&h_env, &obuf, 0, 2, h_env.limit);
  if ( !tbl->border_mode )
  {
    rowspan = table_rowspan(tbl, row, col);
    if ( rowspan + row <= tbl->maxrow )
    {
      if ( tbl->vcellpadding > 0 && (obuf.flag & 0x2000) == 0 )
        goto LABEL_41;
      goto LABEL_48;
    }
    if ( tbl->vspace <= 0 )
      goto LABEL_48;
LABEL_47:
    purgeline(&h_env);
    goto LABEL_48;
  }
  if ( tbl->vcellpadding <= 0 )
    goto LABEL_47;
  if ( (obuf.flag & 0x2000) == 0 )
LABEL_41:
    do_blankline(&h_env, &obuf, 0, 0, h_env.limit);
LABEL_48:
  colspan = table_colspan(tbl, row, col);
  if ( colspan <= 1 )
  {
    if ( tbl->minimum_width[col] < h_env.maxlimit )
      tbl->minimum_width[col] = h_env.maxlimit;
  }
  else
  {
    cell = &tbl->cell;
    k = bsearch_2short(colspan, tbl->cell.colspan, col, tbl->cell.col, 50, tbl->cell.index, tbl->cell.maxcell + 1);
    icell = cell->index[k];
    if ( cell->minimum_width[icell] < h_env.maxlimit )
      cell->minimum_width[icell] = h_env.maxlimit;
  }
}

//----- (08081FAE) --------------------------------------------------------
int __cdecl table_rule_width(table *t)
{
  int result; // eax

  if ( t->border_mode )
    result = symbol_width;
  else
    result = 1;
  return result;
}

//----- (08081FC9) --------------------------------------------------------
void __cdecl check_cell_width(__int16 *tabwidth, __int16 *cellwidth, __int16 *col, __int16 *colspan, __int16 maxcell, __int16 *indexarray, int space, int dir)
{
  int r; // [esp+18h] [ebp-28h]
  int w; // [esp+1Ch] [ebp-24h]
  int width; // [esp+20h] [ebp-20h]
  int swidth; // [esp+24h] [ebp-1Ch]
  int ecol; // [esp+28h] [ebp-18h]
  int k; // [esp+30h] [ebp-10h]
  int j; // [esp+34h] [ebp-Ch]
  int i; // [esp+38h] [ebp-8h]
  int ia; // [esp+38h] [ebp-8h]
  int ib; // [esp+38h] [ebp-8h]

  for ( k = 0; maxcell >= k; ++k )
  {
    j = indexarray[k];
    if ( cellwidth[j] > 0 )
    {
      ecol = col[j] + colspan[j];
      swidth = 0;
      for ( i = col[j]; i < ecol; ++i )
        swidth += tabwidth[i];
      width = cellwidth[j] + space * (1 - colspan[j]);
      if ( width > swidth )
      {
        w = (width - swidth) / colspan[j];
        r = (width - swidth) % colspan[j];
        for ( ia = col[j]; ia < ecol; ++ia )
          tabwidth[ia] += w;
        if ( dir == 1 && r > 0 )
          r = colspan[j];
        for ( ib = 1; ib <= r; ++ib )
          ++tabwidth[ecol - ib];
      }
    }
  }
}

//----- (0808216A) --------------------------------------------------------
void __cdecl check_minimum_width(table *t, __int16 *tabwidth)
{
  int i; // [esp+2Ch] [ebp-10h]

  for ( i = 0; t->maxcol >= i; ++i )
  {
    if ( tabwidth[i] < t->minimum_width[i] )
      tabwidth[i] = t->minimum_width[i];
  }
  check_cell_width(
    tabwidth,
    t->cell.minimum_width,
    t->cell.col,
    t->cell.colspan,
    t->cell.maxcell,
    t->cell.index,
    t->cellspacing,
    0);
}

//----- (08082228) --------------------------------------------------------
void __cdecl check_maximum_width(table *t)
{
  int swidth; // [esp+8h] [ebp-18h]
  int j; // [esp+14h] [ebp-Ch]
  int i; // [esp+18h] [ebp-8h]
  table_cell *cell; // [esp+1Ch] [ebp-4h]

  cell = &t->cell;
  t->cell.necell = 0;
  for ( j = 0; t->cell.maxcell >= j; ++j )
  {
    swidth = 0;
    for ( i = cell->col[j]; i < cell->col[j] + cell->colspan[j]; ++i )
      swidth += t->tabwidth[i];
    if ( cell->width[j] + (1 - cell->colspan[j]) * t->cellspacing > swidth )
      t->cell.eindex[t->cell.necell++] = j;
  }
}

//----- (0808232A) --------------------------------------------------------
void __cdecl set_integered_width(table *t, double *dwidth, __int16 *iwidth)
{
  long double v3; // fst7
  double nsum; // [esp+38h] [ebp-80h]
  double x; // [esp+40h] [ebp-78h]
  double sum; // [esp+48h] [ebp-70h]
  int ii_0; // [esp+50h] [ebp-68h]
  int ii_2; // [esp+58h] [ebp-60h]
  int m; // [esp+5Ch] [ebp-5Ch]
  int width; // [esp+60h] [ebp-58h]
  int w; // [esp+64h] [ebp-54h]
  int wa; // [esp+64h] [ebp-54h]
  int kk; // [esp+68h] [ebp-50h]
  int kka; // [esp+68h] [ebp-50h]
  int kkb; // [esp+68h] [ebp-50h]
  int kkc; // [esp+68h] [ebp-50h]
  int kkd; // [esp+68h] [ebp-50h]
  int kke; // [esp+68h] [ebp-50h]
  int ii_3; // [esp+6Ch] [ebp-4Ch]
  int ii_4; // [esp+70h] [ebp-48h]
  char *idx; // [esp+74h] [ebp-44h]
  int nn; // [esp+78h] [ebp-40h]
  int ii; // [esp+7Ch] [ebp-3Ch]
  int rulewidth; // [esp+80h] [ebp-38h]
  table_cell *cell; // [esp+84h] [ebp-34h]
  double *mod; // [esp+88h] [ebp-30h]
  char *fixed; // [esp+8Ch] [ebp-2Ch]
  __int16 *indexarray; // [esp+90h] [ebp-28h]
  int step; // [esp+94h] [ebp-24h]
  int ecol; // [esp+98h] [ebp-20h]
  int bcol; // [esp+9Ch] [ebp-1Ch]
  int n; // [esp+A0h] [ebp-18h]
  int k; // [esp+A4h] [ebp-14h]
  int ka; // [esp+A4h] [ebp-14h]
  int kb; // [esp+A4h] [ebp-14h]
  int kc; // [esp+A4h] [ebp-14h]
  int kd; // [esp+A4h] [ebp-14h]
  int j; // [esp+A8h] [ebp-10h]
  int i; // [esp+ACh] [ebp-Ch]
  int ia; // [esp+ACh] [ebp-Ch]
  int ib; // [esp+ACh] [ebp-Ch]

  x = 0.0;
  cell = &t->cell;
  rulewidth = table_rule_width(t);
  indexarray = (__int16 *)GC_malloc_atomic(2 * (t->maxcol + 1));
  mod = (double *)GC_malloc_atomic(8 * (t->maxcol + 1));
  for ( i = 0; t->maxcol >= i; ++i )
  {
    v3 = ceil(dwidth[i]);
    iwidth[i] = ceil_at_intervals((int)v3, rulewidth);
    mod[i] = (long double)iwidth[i] - dwidth[i];
  }
  sum = 0.0;
  for ( k = 0; t->maxcol >= k; ++k )
  {
    x = mod[k];
    sum = sum + x;
    ia = bsearch_double(x, mod, indexarray, k);
    if ( k > ia )
    {
      for ( ii = k; ii > ia; --ii )
        indexarray[ii] = indexarray[ii - 1];
    }
    indexarray[ia] = k;
  }
  fixed = (char *)GC_malloc_atomic(t->maxcol + 1);
  bzero(fixed, t->maxcol + 1);
  for ( step = 0; step <= 1; ++step )
  {
    for ( ib = 0; t->maxcol >= ib; ib += n )
    {
      if ( sum < 0.5 )
        return;
      for ( n = 0; n + ib <= t->maxcol; ++n )
      {
        ii_4 = indexarray[ib + n];
        if ( n )
        {
          if ( fabs(mod[ii_4] - x) > 0.000001 )
            break;
        }
        else
        {
          x = mod[ii_4];
        }
      }
      for ( ka = 0; ka < n; ++ka )
      {
        ii_3 = indexarray[ib + ka];
        if ( fixed[ii_3] <= 1 && iwidth[ii_3] - rulewidth < t->minimum_width[ii_3] )
          fixed[ii_3] = 2;
        if ( fixed[ii_3] <= 0
          && iwidth[ii_3] - rulewidth < t->tabwidth[ii_3]
          && (long double)rulewidth - mod[ii_3] > 0.5 )
        {
          fixed[ii_3] = 1;
        }
      }
      idx = (char *)GC_malloc_atomic(n);
      for ( kb = 0; t->cell.maxcell > kb; ++kb )
      {
        j = cell->index[kb];
        bcol = cell->col[j];
        ecol = bcol + cell->colspan[j];
        m = 0;
        for ( kk = 0; kk < n; ++kk )
        {
          ii_2 = indexarray[ib + kk];
          if ( ii_2 >= bcol && ii_2 < ecol )
            idx[m++] = ii_2;
        }
        if ( m )
        {
          width = (cell->colspan[j] - 1) * t->cellspacing;
          for ( kka = bcol; kka < ecol; ++kka )
            width += iwidth[kka];
          w = 0;
          for ( kkb = 0; kkb < m; ++kkb )
          {
            if ( fixed[idx[kkb]] <= 1 )
              w += rulewidth;
          }
          if ( width - w < cell->minimum_width[j] )
          {
            for ( kkc = 0; kkc < m; ++kkc )
            {
              if ( fixed[idx[kkc]] <= 1 )
                fixed[idx[kkc]] = 2;
            }
          }
          wa = 0;
          for ( kkd = 0; kkd < m; ++kkd )
          {
            if ( fixed[idx[kkd]] <= 0 && (long double)rulewidth - mod[idx[kkd]] > 0.5 )
              wa += rulewidth;
          }
          if ( width - wa < cell->width[j] )
          {
            for ( kke = 0; kke < m; ++kke )
            {
              if ( fixed[idx[kke]] <= 0 && (long double)rulewidth - mod[idx[kke]] > 0.5 )
                fixed[idx[kke]] = 1;
            }
          }
        }
      }
      nn = 0;
      for ( kc = 0; kc < n; ++kc )
      {
        if ( fixed[indexarray[ib + kc]] <= step )
          ++nn;
      }
      nsum = sum - (long double)(rulewidth * nn);
      if ( nsum < 0.0 && fabs(nsum) >= fabs(sum) )
        return;
      for ( kd = 0; kd < n; ++kd )
      {
        ii_0 = indexarray[ib + kd];
        if ( fixed[ii_0] <= step )
        {
          iwidth[ii_0] -= rulewidth;
          fixed[ii_0] = 3;
        }
      }
      sum = sum - (long double)(rulewidth * nn);
    }
  }
}
// 804A51C: using guessed type int __cdecl GC_malloc_atomic(_DWORD);

//----- (08082A0A) --------------------------------------------------------
double __cdecl correlation_coefficient(double sxx, double syy, double sxy)
{
  double tmp; // [esp+30h] [ebp-18h]
  double coe; // [esp+38h] [ebp-10h]

  tmp = sxx * syy;
  if ( Tiny > (long double)tmp )
    tmp = Tiny;
  coe = sxy / sqrt(tmp);
  if ( coe > 1.0 )
    return 1.0;
  if ( -1.0 <= coe )
    return coe;
  return -1.0;
}

//----- (08082AB3) --------------------------------------------------------
double __cdecl correlation_coefficient2(double sxx, double syy, double sxy)
{
  double tmp; // [esp+30h] [ebp-18h]
  double coe; // [esp+38h] [ebp-10h]

  tmp = (syy + sxx + sxy * -2.0) * sxx;
  if ( Tiny > (long double)tmp )
    tmp = Tiny;
  coe = (sxx - sxy) / sqrt(tmp);
  if ( coe > 1.0 )
    return 1.0;
  if ( -1.0 <= coe )
    return coe;
  return -1.0;
}

//----- (08082B62) --------------------------------------------------------
double __cdecl recalc_width(double old, double swidth, int cwidth, double sxx, double syy, double sxy, int is_inclusive)
{
  long double result; // fst7
  double olda; // [esp+48h] [ebp-50h]
  double wmin_0; // [esp+50h] [ebp-48h]
  double coe1; // [esp+58h] [ebp-40h]
  double wmin; // [esp+60h] [ebp-38h]
  double ww; // [esp+68h] [ebp-30h]
  double wwa; // [esp+68h] [ebp-30h]
  double w; // [esp+70h] [ebp-28h]
  double coe; // [esp+78h] [ebp-20h]
  double rat; // [esp+80h] [ebp-18h]
  double delta; // [esp+88h] [ebp-10h]

  olda = old;
  rat = sxy / sxx;
  coe = correlation_coefficient(sxx, syy, sxy);
  if ( old < 0.0 )
    olda = 0.0;
  if ( fabs(coe) < 0.00001 )
    return olda;
  w = rat * olda;
  delta = swidth - (long double)cwidth;
  ww = delta;
  if ( w <= 0.0 )
  {
    wmin_0 = sqrt(syy) * 0.005 * fabs(coe);
    if ( rat > -0.001 )
      return olda;
    if ( wmin_0 > 0.01 )
      wmin_0 = 0.01;
    if ( delta > 0.0 )
      ww = 0.0;
    wwa = ww - wmin_0;
  }
  else
  {
    wmin = sqrt((1.0 - coe * coe) * syy) * 0.005;
    if ( swidth < 0.2 && cwidth > 0 )
    {
      if ( is_inclusive )
      {
        coe1 = correlation_coefficient2(sxx, syy, sxy);
        if ( coe > 0.9 || coe1 > 0.9 )
          return 0.0;
      }
    }
    if ( wmin > 0.05 )
      wmin = 0.05;
    if ( delta < 0.0 )
      ww = 0.0;
    wwa = ww + wmin;
  }
  if ( w <= (long double)wwa )
    result = olda;
  else
    result = wwa / rat;
  return result;
}

//----- (08082D94) --------------------------------------------------------
int __cdecl check_compressible_cell(table *t, MAT *minv, double *newwidth, double *swidth, __int16 *cwidth, double totalwidth, double *Sxx, int icol, int icell, double sxx, int corr)
{
  int v12; // eax
  long double v13; // fst7
  int v14; // [esp+Ch] [ebp-ACh]
  double sxy; // [esp+50h] [ebp-68h]
  double sxya; // [esp+50h] [ebp-68h]
  double dmin; // [esp+58h] [ebp-60h]
  double dmax; // [esp+60h] [ebp-58h]
  double owidth; // [esp+68h] [ebp-50h]
  double delta; // [esp+70h] [ebp-48h]
  int is_inclusive_0; // [esp+7Ch] [ebp-3Ch]
  int is_inclusive; // [esp+80h] [ebp-38h]
  int ecol1; // [esp+84h] [ebp-34h]
  int bcol1; // [esp+88h] [ebp-30h]
  int rulewidth; // [esp+8Ch] [ebp-2Ch]
  int ecol; // [esp+94h] [ebp-24h]
  int bcol; // [esp+98h] [ebp-20h]
  int m; // [esp+9Ch] [ebp-1Ch]
  int ma; // [esp+9Ch] [ebp-1Ch]
  int k; // [esp+A0h] [ebp-18h]
  int j; // [esp+A4h] [ebp-14h]
  int i; // [esp+A8h] [ebp-10h]
  int ia; // [esp+A8h] [ebp-10h]
  table_cell *cell; // [esp+ACh] [ebp-Ch]

  cell = &t->cell;
  rulewidth = table_rule_width(t);
  if ( sxx < 10.0 )
    return corr;
  if ( icol < 0 )
  {
    if ( icell < 0 )
    {
      owidth = totalwidth;
      delta = totalwidth;
      bcol = 0;
      v12 = t->maxcol + 1;
    }
    else
    {
      owidth = swidth[icell];
      delta = owidth - (long double)cwidth[icell];
      bcol = cell->col[icell];
      v12 = bcol + cell->colspan[icell];
    }
    ecol = v12;
  }
  else
  {
    owidth = newwidth[icol];
    delta = owidth - (long double)t->tabwidth[icol];
    bcol = icol;
    ecol = icol + 1;
  }
  dmin = delta;
  dmax = -1.0;
  for ( k = 0; t->cell.maxcell >= k; ++k )
  {
    is_inclusive = 0;
    if ( dmin <= 0.0 )
      goto _end;
    j = cell->index[k];
    if ( j != icell )
    {
      bcol1 = cell->col[j];
      ecol1 = bcol1 + cell->colspan[j];
      sxy = 0.0;
      for ( m = bcol1; m < ecol1; ++m )
      {
        for ( i = bcol; i < ecol; ++i )
          sxy = minv->me[m + i * minv->dim] + sxy;
      }
      if ( bcol1 >= bcol && ecol1 <= ecol )
        is_inclusive = 1;
      if ( sxy <= 0.0 )
        dmax = recalc_width(dmax, swidth[j], cwidth[j], sxx, Sxx[j], sxy, is_inclusive);
      else
        dmin = recalc_width(dmin, swidth[j], cwidth[j], sxx, Sxx[j], sxy, is_inclusive);
    }
  }
  for ( ma = 0; t->maxcol >= ma; ++ma )
  {
    is_inclusive_0 = 0;
    if ( dmin <= 0.0 )
      break;
    if ( ma != icol )
    {
      sxya = 0.0;
      for ( ia = bcol; ia < ecol; ++ia )
        sxya = minv->me[ma + ia * minv->dim] + sxya;
      if ( ma >= bcol && ma < ecol )
        is_inclusive_0 = 1;
      if ( sxya <= 0.0 )
        dmax = recalc_width(
                 dmax,
                 newwidth[ma],
                 t->tabwidth[ma],
                 sxx,
                 *(double *)((char *)minv->me + ma * 8 * (minv->dim + 1)),
                 sxya,
                 is_inclusive_0);
      else
        dmin = recalc_width(
                 dmin,
                 newwidth[ma],
                 t->tabwidth[ma],
                 sxx,
                 *(double *)((char *)minv->me + ma * 8 * (minv->dim + 1)),
                 sxya,
                 is_inclusive_0);
    }
  }
_end:
  if ( dmax > 0.0 && dmin > (long double)dmax )
    dmin = dmax;
  if ( t->maxcol + 1 == ecol - bcol && dmin >= 0.0
    || t->maxcol + 1 != ecol - bcol && dmin > (long double)rulewidth * 0.5 )
  {
    v13 = floor(owidth - dmin + 0.5);
    v14 = ceil_at_intervals((int)v13, rulewidth);
    correct_table_matrix(t, bcol, ecol - bcol, v14, 1.0);
    ++corr;
  }
  return corr;
}

//----- (080832E2) --------------------------------------------------------
int __cdecl check_table_width(table *t, double *newwidth, MAT *minv, int itr)
{
  int v4; // ecx
  void *v5; // esp
  int v6; // ecx
  void *v7; // esp
  int v8; // ecx
  void *v9; // esp
  int v10; // ecx
  void *v11; // esp
  double *v12; // eax
  int v13; // edx
  int result; // eax
  int v15; // esi
  int v16; // ebx
  long double v17; // fst7
  __int16 v18; // ax
  long double v19; // fst7
  long double v20; // fst7
  int v21[5]; // [esp+40h] [ebp-138h] BYREF
  int v22; // [esp+54h] [ebp-124h]
  int v23; // [esp+58h] [ebp-120h]
  int v24; // [esp+5Ch] [ebp-11Ch]
  int v25; // [esp+60h] [ebp-118h]
  int v26; // [esp+64h] [ebp-114h]
  int v27; // [esp+68h] [ebp-110h]
  int v28; // [esp+6Ch] [ebp-10Ch]
  int v29; // [esp+70h] [ebp-108h]
  int v30; // [esp+74h] [ebp-104h]
  int v31; // [esp+78h] [ebp-100h]
  int v32; // [esp+7Ch] [ebp-FCh]
  int v33; // [esp+80h] [ebp-F8h]
  int v34; // [esp+84h] [ebp-F4h]
  int v35; // [esp+88h] [ebp-F0h]
  int v36; // [esp+8Ch] [ebp-ECh]
  int v37; // [esp+90h] [ebp-E8h]
  int v38; // [esp+94h] [ebp-E4h]
  int v39; // [esp+98h] [ebp-E0h]
  int v40; // [esp+9Ch] [ebp-DCh]
  int v41; // [esp+A0h] [ebp-D8h]
  int v42; // [esp+A4h] [ebp-D4h]
  int v43; // [esp+A8h] [ebp-D0h]
  int v44; // [esp+ACh] [ebp-CCh]
  int v45; // [esp+B0h] [ebp-C8h]
  int v46; // [esp+B4h] [ebp-C4h]
  int v47; // [esp+BCh] [ebp-BCh]
  __int16 v48; // [esp+C0h] [ebp-B8h]
  __int16 v49; // [esp+C2h] [ebp-B6h]
  MAT *minva; // [esp+C4h] [ebp-B4h]
  double *newwidtha; // [esp+C8h] [ebp-B0h]
  table *ta; // [esp+CCh] [ebp-ACh]
  double w_0; // [esp+D8h] [ebp-A0h]
  double sx_0; // [esp+E0h] [ebp-98h]
  double w; // [esp+E8h] [ebp-90h]
  double sx; // [esp+F0h] [ebp-88h]
  double stotal; // [esp+F8h] [ebp-80h]
  double sxy; // [esp+100h] [ebp-78h]
  double twidth; // [esp+108h] [ebp-70h]
  double (*p_swidth)[]; // [esp+110h] [ebp-68h]
  int v61; // [esp+114h] [ebp-64h]
  __int16 (*p_cwidth)[]; // [esp+118h] [ebp-60h]
  int v63; // [esp+11Ch] [ebp-5Ch]
  __int16 (*p_corwidth)[]; // [esp+120h] [ebp-58h]
  int v65; // [esp+124h] [ebp-54h]
  __int16 (*p_orgwidth)[]; // [esp+128h] [ebp-50h]
  int v67; // [esp+12Ch] [ebp-4Ch]
  int mwidth; // [esp+130h] [ebp-48h]
  int nwidth; // [esp+134h] [ebp-44h]
  double *Sxx; // [esp+138h] [ebp-40h]
  table_cell *cell; // [esp+13Ch] [ebp-3Ch]
  int corr; // [esp+140h] [ebp-38h]
  int ecol; // [esp+144h] [ebp-34h]
  int bcol; // [esp+148h] [ebp-30h]
  int m; // [esp+14Ch] [ebp-2Ch]
  int k; // [esp+150h] [ebp-28h]
  int j; // [esp+154h] [ebp-24h]
  int i; // [esp+158h] [ebp-20h]
  unsigned int v79; // [esp+15Ch] [ebp-1Ch]

  ta = t;
  newwidtha = newwidth;
  minva = minv;
  v79 = __readgsdword(0x14u);
  corr = 0;
  cell = &t->cell;
  v4 = t->maxcol + 1;
  v67 = t->maxcol;
  v45 = 16 * v4;
  v46 = ((unsigned __int64)(unsigned int)v4 >> 28) & 0xF;
  v43 = v4;
  v44 = 0;
  v41 = 16 * v4;
  v42 = v46;
  v5 = alloca(16 * ((unsigned int)(2 * v4 + 30) >> 4));
  p_orgwidth = (__int16 (*)[])(16 * (((unsigned int)v21 + 3) >> 4));
  v6 = t->maxcol + 1;
  v65 = t->maxcol;
  v39 = v6;
  v40 = 0;
  v37 = 16 * v6;
  v38 = ((unsigned __int64)(unsigned int)v6 >> 28) & 0xF;
  v35 = v6;
  v36 = 0;
  v33 = 16 * v6;
  v34 = v38;
  v7 = alloca(16 * ((unsigned int)(2 * v6 + 30) >> 4));
  p_corwidth = p_orgwidth;
  v8 = t->cell.maxcell + 1;
  v63 = t->cell.maxcell;
  v31 = v8;
  v32 = 0;
  v29 = 16 * v8;
  v30 = ((unsigned __int64)(unsigned int)v8 >> 28) & 0xF;
  v27 = v8;
  v28 = 0;
  v25 = 16 * v8;
  v26 = v30;
  v9 = alloca(16 * ((unsigned int)(2 * v8 + 30) >> 4));
  p_cwidth = p_orgwidth;
  v10 = t->cell.maxcell + 1;
  v61 = t->cell.maxcell;
  v23 = v10;
  v24 = 0;
  v21[4] = v10 << 6;
  v22 = ((unsigned __int64)(unsigned int)v10 >> 26) & 0xF;
  v21[2] = v10;
  v21[3] = 0;
  v21[0] = v10 << 6;
  v21[1] = v22;
  v11 = alloca(16 * ((unsigned int)(8 * v10 + 30) >> 4));
  p_swidth = (double (*)[])p_orgwidth;
  twidth = 0.0;
  stotal = 0.0;
  for ( i = 0; ta->maxcol >= i; ++i )
  {
    twidth = newwidtha[i] + twidth;
    stotal = *(double *)((char *)minva->me + i * 8 * (minva->dim + 1)) + stotal;
    for ( m = 0; m < i; ++m )
    {
      v12 = &minva->me[m + i * minva->dim];
      stotal = *v12 + *v12 + stotal;
    }
  }
  Sxx = (double *)GC_malloc_atomic(8 * (cell->maxcell + 1));
  for ( k = 0; cell->maxcell >= k; ++k )
  {
    j = cell->index[k];
    bcol = cell->col[j];
    ecol = bcol + cell->colspan[j];
    *((double *)p_swidth + j) = 0.0;
    for ( i = bcol; i < ecol; ++i )
      *((double *)p_swidth + j) = *((double *)p_swidth + j) + newwidtha[i];
    *((_WORD *)p_cwidth + j) = cell->width[j] + (1 - cell->colspan[j]) * LOWORD(ta->cellspacing);
    Sxx[j] = 0.0;
    for ( i = bcol; i < ecol; ++i )
    {
      Sxx[j] = Sxx[j] + *(double *)((char *)minva->me + i * 8 * (minva->dim + 1));
      for ( m = bcol; m <= ecol; ++m )
      {
        if ( m < i )
        {
          v13 = m + i * minva->dim;
          Sxx[j] = Sxx[j] + minva->me[v13] + minva->me[v13];
        }
      }
    }
  }
  corr = check_compressible_cell(
           ta,
           minva,
           newwidtha,
           (double *)p_swidth,
           (__int16 *)p_cwidth,
           twidth,
           Sxx,
           -1,
           -1,
           stotal,
           corr);
  if ( itr <= 9 && corr > 0 )
    return corr;
  for ( k = cell->maxcell; k >= 0; --k )
  {
    j = cell->index[k];
    corr = check_compressible_cell(
             ta,
             minva,
             newwidtha,
             (double *)p_swidth,
             (__int16 *)p_cwidth,
             twidth,
             Sxx,
             -1,
             j,
             Sxx[j],
             corr);
    if ( itr <= 9 && corr > 0 )
      return corr;
  }
  for ( i = 0; ta->maxcol >= i; ++i )
  {
    corr = check_compressible_cell(
             ta,
             minva,
             newwidtha,
             (double *)p_swidth,
             (__int16 *)p_cwidth,
             twidth,
             Sxx,
             i,
             -1,
             *(double *)((char *)minva->me + i * 8 * (minva->dim + 1)),
             corr);
    if ( itr <= 9 && corr > 0 )
      return corr;
  }
  for ( i = 0; ta->maxcol >= i; ++i )
  {
    v15 = i;
    v16 = i;
    v17 = floor(newwidtha[i] + 0.5);
    LOBYTE(v18) = v49;
    HIBYTE(v18) = 12;
    v48 = v18;
    v47 = (int)v17;
    *((_WORD *)p_orgwidth + v16) = (int)v17;
    *((_WORD *)p_corwidth + v15) = *((_WORD *)p_orgwidth + v16);
  }
  check_minimum_width(ta, (__int16 *)p_corwidth);
  for ( i = 0; ta->maxcol >= i; ++i )
  {
    sx = sqrt(*(double *)((char *)minva->me + i * 8 * (minva->dim + 1)));
    if ( sx >= 0.1
      && *((_WORD *)p_orgwidth + i) < ta->minimum_width[i]
      && *((_WORD *)p_corwidth + i) == ta->minimum_width[i] )
    {
      if ( sx <= 0.5 )
        v19 = sx * 0.2;
      else
        v19 = 0.5;
      w = v19;
      sxy = 0.0;
      for ( m = 0; ta->maxcol >= m; ++m )
      {
        if ( m != i )
          sxy = minva->me[m + i * minva->dim] + sxy;
      }
      if ( sxy <= 0.0 )
      {
        correct_table_matrix(ta, i, 1, ta->minimum_width[i], w);
        ++corr;
      }
    }
  }
  for ( k = 0; cell->maxcell >= k; ++k )
  {
    nwidth = 0;
    j = cell->index[k];
    sx_0 = sqrt(Sxx[j]);
    if ( sx_0 >= 0.1 )
    {
      bcol = cell->col[j];
      ecol = bcol + cell->colspan[j];
      for ( i = bcol; i < ecol; ++i )
        nwidth += *((__int16 *)p_corwidth + i);
      mwidth = cell->minimum_width[j] + (1 - cell->colspan[j]) * ta->cellspacing;
      if ( (long double)mwidth > *((double *)p_swidth + j) && mwidth == nwidth )
      {
        if ( sx_0 <= 0.5 )
          v20 = sx_0 * 0.2;
        else
          v20 = 0.5;
        w_0 = v20;
        sxy = 0.0;
        for ( i = bcol; i < ecol; ++i )
        {
          for ( m = 0; ta->maxcol >= m; ++m )
          {
            if ( m < bcol || m >= ecol )
              sxy = minva->me[m + i * minva->dim] + sxy;
          }
        }
        if ( sxy <= 0.0 )
        {
          correct_table_matrix(ta, bcol, cell->colspan[j], mwidth, w_0);
          ++corr;
        }
      }
    }
  }
  if ( itr <= 9 )
    result = corr;
  else
    result = 0;
  return result;
}
// 804A51C: using guessed type int __cdecl GC_malloc_atomic(_DWORD);

//----- (08083EF8) --------------------------------------------------------
void __cdecl check_table_height(table *t)
{
  __int16 v1; // ax
  int v2; // eax
  int v3; // eax
  __int16 *cell; // [esp+48h] [ebp-50h]
  __int16 *cell_4; // [esp+4Ch] [ebp-4Ch]
  __int16 *cell_8; // [esp+50h] [ebp-48h]
  __int16 cell_12; // [esp+54h] [ebp-44h]
  __int16 cell_14; // [esp+56h] [ebp-42h]
  __int16 *cell_16; // [esp+58h] [ebp-40h]
  int ii; // [esp+5Ch] [ebp-3Ch]
  int idx; // [esp+60h] [ebp-38h]
  int c; // [esp+64h] [ebp-34h]
  int rowspan; // [esp+68h] [ebp-30h]
  int t_dep; // [esp+6Ch] [ebp-2Ch]
  int space; // [esp+70h] [ebp-28h]
  int k; // [esp+74h] [ebp-24h]
  int j; // [esp+78h] [ebp-20h]
  int i; // [esp+7Ch] [ebp-1Ch]

  space = 0;
  cell_14 = 0;
  cell_12 = -1;
  for ( j = 0; t->maxrow >= j; ++j )
  {
    if ( t->tabattr[j] )
    {
      for ( i = 0; t->maxcol >= i; ++i )
      {
        if ( (t->tabattr[j][i] & 3) == 0 )
        {
          if ( t->tabdata[j][i] )
            t_dep = t->tabdata[j][i]->nitem;
          else
            t_dep = 0;
          rowspan = table_rowspan(t, j, i);
          if ( rowspan <= 1 )
          {
            if ( t->tabheight[j] < t_dep )
              t->tabheight[j] = t_dep;
          }
          else
          {
            c = cell_12 + 1;
            k = bsearch_2short(rowspan, cell_4, j, cell, t->maxrow + 1, cell_8, c);
            if ( cell_12 >= k )
            {
              idx = cell_8[k];
              if ( cell[idx] == j && cell_4[idx] == rowspan )
                c = cell_8[k];
            }
            if ( c <= 999 )
            {
              if ( cell_14 <= c )
              {
                if ( cell_14 )
                {
                  v2 = cell_14 + 20;
                  if ( c + 1 >= v2 )
                    LOWORD(v2) = c + 1;
                  cell_14 = v2;
                  cell = (__int16 *)GC_realloc(cell, 2 * (__int16)v2);
                  cell_4 = (__int16 *)GC_realloc(cell_4, 2 * cell_14);
                  cell_8 = (__int16 *)GC_realloc(cell_8, 2 * cell_14);
                  cell_16 = (__int16 *)GC_realloc(cell_16, 2 * cell_14);
                }
                else
                {
                  v1 = c + 1;
                  if ( c + 1 < 20 )
                    v1 = 20;
                  cell_14 = v1;
                  cell = (__int16 *)GC_malloc_atomic(2 * v1);
                  cell_4 = (__int16 *)GC_malloc_atomic(2 * cell_14);
                  cell_8 = (__int16 *)GC_malloc_atomic(2 * cell_14);
                  cell_16 = (__int16 *)GC_malloc_atomic(2 * cell_14);
                }
              }
              if ( cell_12 < c )
              {
                cell[++cell_12] = j;
                cell_4[cell_12] = rowspan;
                cell_16[cell_12] = 0;
                if ( cell_12 > k )
                {
                  for ( ii = cell_12; ii > k; --ii )
                    cell_8[ii] = cell_8[ii - 1];
                }
                cell_8[k] = cell_12;
              }
              if ( cell_16[c] < t_dep )
                cell_16[c] = t_dep;
            }
          }
        }
      }
    }
  }
  v3 = t->border_mode;
  if ( v3 )
  {
    if ( v3 >= 0 && v3 <= 3 )
      space = 1;
  }
  else
  {
    space = 0;
  }
  check_cell_width(t->tabheight, cell_16, cell, cell_4, cell_12, cell_8, space, 1);
}
// 8084029: variable 'cell_4' is possibly undefined
// 8084029: variable 'cell' is possibly undefined
// 8084029: variable 'cell_8' is possibly undefined
// 8084172: variable 'cell_16' is possibly undefined
// 8049E6C: using guessed type int __cdecl GC_realloc(_DWORD, _DWORD);
// 804A51C: using guessed type int __cdecl GC_malloc_atomic(_DWORD);

//----- (08084329) --------------------------------------------------------
int __cdecl get_table_width(table *t, __int16 *orgwidth, __int16 *cellwidth, int flag)
{
  int v4; // esi
  void *v5; // esp
  __int16 v6; // dx
  int v7; // ecx
  void *v8; // esp
  int v9; // edx
  __int16 v10; // di
  int v11; // eax
  int v12; // eax
  _DWORD v14[11]; // [esp+0h] [ebp-B8h] BYREF
  int v15[2]; // [esp+2Ch] [ebp-8Ch] BYREF
  int v16; // [esp+34h] [ebp-84h]
  int v17; // [esp+38h] [ebp-80h]
  int v18; // [esp+3Ch] [ebp-7Ch]
  int v19; // [esp+40h] [ebp-78h]
  int v20; // [esp+44h] [ebp-74h]
  int v21; // [esp+48h] [ebp-70h]
  int v22; // [esp+4Ch] [ebp-6Ch]
  int v23; // [esp+50h] [ebp-68h]
  int v24; // [esp+54h] [ebp-64h]
  __int16 *colspan; // [esp+58h] [ebp-60h]
  _DWORD *v26; // [esp+5Ch] [ebp-5Ch]
  _DWORD *v27; // [esp+60h] [ebp-58h]
  __int16 *cellwidtha; // [esp+64h] [ebp-54h]
  __int16 *orgwidtha; // [esp+68h] [ebp-50h]
  table *ta; // [esp+6Ch] [ebp-4Ch]
  __int16 (*p_ccellwidth)[]; // [esp+7Ch] [ebp-3Ch]
  int v32; // [esp+80h] [ebp-38h]
  __int16 (*p_newwidth)[]; // [esp+84h] [ebp-34h]
  int v34; // [esp+88h] [ebp-30h]
  int rulewidth; // [esp+8Ch] [ebp-2Ch]
  table_cell *cell; // [esp+90h] [ebp-28h]
  int swidth; // [esp+94h] [ebp-24h]
  int i; // [esp+98h] [ebp-20h]
  unsigned int v39; // [esp+9Ch] [ebp-1Ch]

  ta = t;
  orgwidtha = orgwidth;
  cellwidtha = cellwidth;
  v39 = __readgsdword(0x14u);
  v27 = v14;
  v4 = t->maxcol + 1;
  v34 = t->maxcol;
  v23 = 16 * v4;
  v24 = ((unsigned __int64)(unsigned int)v4 >> 28) & 0xF;
  v21 = v4;
  v22 = 0;
  v19 = 16 * v4;
  v20 = v24;
  v5 = alloca(16 * ((unsigned int)(2 * v4 + 30) >> 4));
  p_newwidth = (__int16 (*)[])(16 * (((unsigned int)v15 + 3) >> 4));
  cell = &t->cell;
  rulewidth = table_rule_width(t);
  for ( i = 0; ta->maxcol >= i; ++i )
  {
    v6 = 0;
    if ( orgwidtha[i] >= 0 )
      v6 = orgwidtha[i];
    *((_WORD *)p_newwidth + i) = v6;
  }
  if ( (flag & 2) != 0 )
  {
    v26 = v14;
    v7 = cell->maxcell + 1;
    v32 = cell->maxcell;
    v17 = v7;
    v18 = 0;
    v15[1] = 16 * v7;
    v16 = ((unsigned __int64)(unsigned int)v7 >> 28) & 0xF;
    v14[10] = v7;
    v15[0] = 0;
    v14[8] = 16 * v7;
    v14[9] = v16;
    v8 = alloca(16 * ((unsigned int)(2 * v7 + 30) >> 4));
    p_ccellwidth = (__int16 (*)[])(16 * (((unsigned int)v15 + 3) >> 4));
    for ( i = 0; ta->maxcol >= i; ++i )
    {
      if ( *((_WORD *)p_newwidth + i) < ta->fixed_width[i] )
        *((_WORD *)p_newwidth + i) = ta->fixed_width[i];
    }
    for ( i = 0; cell->maxcell >= i; ++i )
    {
      *((_WORD *)p_ccellwidth + i) = cellwidtha[i];
      if ( *((_WORD *)p_ccellwidth + i) < cell->fixed_width[i] )
        *((_WORD *)p_ccellwidth + i) = cell->fixed_width[i];
    }
    v9 = ta->cellspacing;
    v10 = cell->maxcell;
    colspan = cell->colspan;
    check_cell_width((__int16 *)p_newwidth, (__int16 *)p_ccellwidth, cell->col, cell->colspan, v10, cell->index, v9, 0);
  }
  else
  {
    check_cell_width(
      (__int16 *)p_newwidth,
      cellwidtha,
      cell->col,
      cell->colspan,
      cell->maxcell,
      cell->index,
      ta->cellspacing,
      0);
  }
  if ( (flag & 1) != 0 )
    check_minimum_width(ta, (__int16 *)p_newwidth);
  swidth = 0;
  for ( i = 0; ta->maxcol >= i; ++i )
  {
    v11 = ceil_at_intervals(*((__int16 *)p_newwidth + i), rulewidth);
    swidth += v11;
  }
  v12 = table_border_width(ta);
  return v12 + swidth;
}

//----- (08084705) --------------------------------------------------------
void __cdecl renderCoTable(table *tbl, int maxlimit)
{
  int v2; // eax
  readbuffer obuf; // [esp+28h] [ebp-2E0h] BYREF
  environment envs[20]; // [esp+178h] [ebp-190h] BYREF
  html_feed_environ h_env; // [esp+2B8h] [ebp-50h] BYREF
  int maxwidth; // [esp+2E8h] [ebp-20h]
  int indent; // [esp+2ECh] [ebp-1Ch]
  int row; // [esp+2F0h] [ebp-18h]
  int col; // [esp+2F4h] [ebp-14h]
  int i; // [esp+2F8h] [ebp-10h]
  table *t; // [esp+2FCh] [ebp-Ch]

  for ( i = 0; tbl->ntable > i; ++i )
  {
    t = tbl->tables[i].ptr;
    col = tbl->tables[i].col;
    row = tbl->tables[i].row;
    indent = tbl->tables[i].indent;
    v2 = get_spec_cell_width(tbl, row, col);
    init_henv(&h_env, &obuf, envs, 20, tbl->tables[i].buf, v2, indent);
    check_row(tbl, row);
    if ( h_env.limit > maxlimit )
      h_env.limit = maxlimit;
    if ( t->total_width )
    {
      if ( t->total_width <= 0 )
        t->total_width = h_env.limit * -t->total_width / 100;
      maxwidth = t->total_width;
    }
    else
    {
      maxwidth = h_env.limit - indent;
    }
    renderTable(t, maxwidth, &h_env);
  }
}

//----- (0808488F) --------------------------------------------------------
void __cdecl make_caption(table *t, html_feed_environ *h_env)
{
  int v2; // ebx
  TextLineList *v3; // eax
  readbuffer obuf; // [esp+2Ch] [ebp-2CCh] BYREF
  environment envs[20]; // [esp+17Ch] [ebp-17Ch] BYREF
  html_feed_environ henv; // [esp+2BCh] [ebp-3Ch] BYREF
  int limit; // [esp+2ECh] [ebp-Ch]

  if ( t->caption->length > 0 )
  {
    if ( t->total_width <= 0 )
      limit = h_env->limit;
    else
      limit = t->total_width;
    v2 = h_env->envs[h_env->envc].indent;
    v3 = (TextLineList *)newGeneralList();
    init_henv(&henv, &obuf, envs, 20, v3, limit, v2);
    HTMLlineproc0("<center>", &henv, 1);
    HTMLlineproc0(t->caption->ptr, &henv, 0);
    HTMLlineproc0("</center>", &henv, 1);
    if ( t->total_width < henv.maxlimit )
      t->total_width = henv.maxlimit;
    limit = h_env->limit;
    h_env->limit = t->total_width;
    HTMLlineproc0("<center>", h_env, 1);
    HTMLlineproc0(t->caption->ptr, h_env, 0);
    HTMLlineproc0("</center>", h_env, 1);
    h_env->limit = limit;
  }
}

//----- (08084A06) --------------------------------------------------------
void __cdecl renderTable(table *t, int max_width, html_feed_environ *h_env)
{
  int v3; // ebx
  int v4; // ebx
  int v5; // ebx
  TextLine *v6; // eax
  GeneralList **v7; // ebx
  char *v8; // eax
  int v9; // eax
  char v10; // al
  int v11; // eax
  int v12; // eax
  int v13; // eax
  char v14; // al
  int v15; // eax
  int v16; // eax
  char *v17; // eax
  char *v18; // eax
  __int16 new_tabwidth[50]; // [esp+20h] [ebp-B8h] BYREF
  int k; // [esp+84h] [ebp-54h]
  TextLineList *l; // [esp+88h] [ebp-50h]
  Str idtag; // [esp+8Ch] [ebp-4Ch]
  Str vrulec; // [esp+90h] [ebp-48h]
  Str vruleb; // [esp+94h] [ebp-44h]
  Str vrulea; // [esp+98h] [ebp-40h]
  int rulewidth; // [esp+9Ch] [ebp-3Ch]
  int width; // [esp+A0h] [ebp-38h]
  PERM *pivot; // [esp+A4h] [ebp-34h]
  MAT *minv; // [esp+A8h] [ebp-30h]
  MAT *mat; // [esp+ACh] [ebp-2Ch]
  VEC *newwidth; // [esp+B0h] [ebp-28h]
  int itr; // [esp+B4h] [ebp-24h]
  Str renderbuf; // [esp+B8h] [ebp-20h]
  int h; // [esp+BCh] [ebp-1Ch]
  int r; // [esp+C0h] [ebp-18h]
  int w; // [esp+C4h] [ebp-14h]
  int j; // [esp+C8h] [ebp-10h]
  int i; // [esp+CCh] [ebp-Ch]
  int max_widtha; // [esp+E4h] [ebp+Ch]

  vrulea = 0;
  vruleb = 0;
  vrulec = 0;
  t->total_height = 0;
  if ( t->maxcol < 0 )
  {
    make_caption(t, h_env);
    return;
  }
  if ( t->sloppy_width > max_width )
    max_width = t->sloppy_width;
  rulewidth = table_rule_width(t);
  max_widtha = max_width - table_border_width(t);
  if ( rulewidth > 1 )
    max_widtha = floor_at_intervals(max_widtha, rulewidth);
  if ( max_widtha < rulewidth )
    max_widtha = rulewidth;
  check_maximum_width(t);
  if ( t->maxcol )
  {
    set_table_matrix(t, max_widtha);
    itr = 0;
    mat = new_matrix(t->maxcol + 1);
    pivot = (PERM *)GC_malloc(4 * (t->maxcol + 1));
    newwidth = new_vector(t->maxcol + 1);
    minv = new_matrix(t->maxcol + 1);
    do
    {
      bcopy(t->matrix->me, mat->me, 8 * t->matrix->dim * t->matrix->dim);
      LUfactor(mat, pivot);
      LUsolve(mat, pivot, t->vector, newwidth);
      LUinverse(mat, pivot, minv);
      ++itr;
    }
    while ( check_table_width(t, newwidth->ve, minv, itr) );
    set_integered_width(t, newwidth->ve, new_tabwidth);
    check_minimum_width(t, new_tabwidth);
    newwidth = 0;
    pivot = 0;
    mat = 0;
    minv = 0;
    t->matrix = 0;
    t->vector = 0;
    for ( i = 0; t->maxcol >= i; ++i )
      t->tabwidth[i] = new_tabwidth[i];
  }
  else
  {
    if ( t->tabwidth[0] > max_widtha )
      t->tabwidth[0] = max_widtha;
    if ( t->total_width <= 0 )
    {
      if ( t->fixed_width[0] > 0 )
        t->tabwidth[0] = t->fixed_width[0];
    }
    else
    {
      t->tabwidth[0] = max_widtha;
    }
    if ( t->tabwidth[0] < t->minimum_width[0] )
      t->tabwidth[0] = t->minimum_width[0];
  }
  check_minimum_width(t, t->tabwidth);
  for ( i = 0; t->maxcol >= i; ++i )
  {
    v3 = i;
    t->tabwidth[v3] = ceil_at_intervals(t->tabwidth[i], rulewidth);
  }
  renderCoTable(t, h_env->limit);
  for ( i = 0; t->maxcol >= i; ++i )
  {
    for ( j = 0; t->maxrow >= j; ++j )
    {
      check_row(t, j);
      if ( (t->tabattr[j][i] & 2) == 0 )
        do_refill(t, j, i, h_env->limit);
    }
  }
  check_minimum_width(t, t->tabwidth);
  t->total_width = 0;
  for ( i = 0; t->maxcol >= i; ++i )
  {
    v4 = i;
    t->tabwidth[v4] = ceil_at_intervals(t->tabwidth[i], rulewidth);
    t->total_width += t->tabwidth[i];
  }
  v5 = t->total_width;
  t->total_width = v5 + table_border_width(t);
  check_table_height(t);
  for ( i = 0; t->maxcol >= i; ++i )
  {
    for ( j = 0; t->maxrow >= j; ++j )
    {
      if ( (t->tabattr[j][i] & 2) == 0 && (t->tabattr[j][i] & 0x100) == 0 && t->tabdata[j][i] )
      {
        h = t->tabheight[j];
        for ( k = j + 1; t->maxrow >= k && (t->tabattr[k][i] & 2) != 0; ++k )
        {
          h += t->tabheight[k];
          if ( (unsigned int)(t->border_mode - 1) <= 2 )
            ++h;
        }
        h -= t->tabdata[j][i]->nitem;
        if ( (t->tabattr[j][i] & 0x200) != 0 )
          h /= 2;
        if ( h > 0 )
        {
          l = (TextLineList *)newGeneralList();
          for ( k = 0; k < h; ++k )
          {
            v6 = newTextLine(0, 0);
            pushValue((GeneralList *)l, v6);
          }
          v7 = &t->tabdata[j][i];
          *v7 = appendGeneralList((GeneralList *)l, *v7);
        }
      }
    }
  }
  width = t->total_width;
  make_caption(t, h_env);
  HTMLlineproc0("<pre for_table>", h_env, 1);
  if ( t->id )
  {
    v8 = html_quote(t->id->ptr);
    idtag = Sprintf("<_id id=\"%s\">", v8);
    HTMLlineproc0(idtag->ptr, h_env, 1);
  }
  if ( (unsigned int)(t->border_mode - 1) <= 1 )
  {
    renderbuf = Strnew();
    print_sep(t, -1, 0, t->maxcol, renderbuf);
    push_render_image(renderbuf, width, t->total_width, h_env);
    ++t->total_height;
  }
  vruleb = Strnew();
  v9 = t->border_mode;
  if ( v9 <= 2 )
  {
    if ( v9 < 1 )
    {
      if ( !v9 )
      {
        for ( i = 0; t->cellspacing > i; ++i )
        {
          if ( vruleb->length + 1 >= vruleb->area_size )
            Strgrow(vruleb);
          v16 = vruleb->length;
          vruleb->ptr[v16] = 32;
          vruleb->length = v16 + 1;
          vruleb->ptr[vruleb->length] = 0;
        }
      }
      goto LABEL_96;
    }
    vrulea = Strnew();
    vrulec = Strnew();
    if ( t->border_mode == 2 )
      v10 = 21;
    else
      v10 = 5;
    push_symbol(vrulea, v10, symbol_width, 1);
    for ( i = 0; t->cellpadding > i; ++i )
    {
      if ( vrulea->length + 1 >= vrulea->area_size )
        Strgrow(vrulea);
      v11 = vrulea->length;
      vrulea->ptr[v11] = 32;
      vrulea->length = v11 + 1;
      vrulea->ptr[vrulea->length] = 0;
      if ( vruleb->length + 1 >= vruleb->area_size )
        Strgrow(vruleb);
      v12 = vruleb->length;
      vruleb->ptr[v12] = 32;
      vruleb->length = v12 + 1;
      vruleb->ptr[vruleb->length] = 0;
      if ( vrulec->length + 1 >= vrulec->area_size )
        Strgrow(vrulec);
      v13 = vrulec->length;
      vrulec->ptr[v13] = 32;
      vrulec->length = v13 + 1;
      vrulec->ptr[vrulec->length] = 0;
    }
    if ( t->border_mode == 2 )
      v14 = 21;
    else
      v14 = 5;
    push_symbol(vrulec, v14, symbol_width, 1);
LABEL_85:
    push_symbol(vruleb, 5, symbol_width, 1);
    for ( i = 0; t->cellpadding > i; ++i )
    {
      if ( vruleb->length + 1 >= vruleb->area_size )
        Strgrow(vruleb);
      v15 = vruleb->length;
      vruleb->ptr[v15] = 32;
      vruleb->length = v15 + 1;
      vruleb->ptr[vruleb->length] = 0;
    }
    goto LABEL_96;
  }
  if ( v9 == 3 )
    goto LABEL_85;
LABEL_96:
  for ( r = 0; t->maxrow >= r; ++r )
  {
    for ( h = 0; t->tabheight[r] > h; ++h )
    {
      renderbuf = Strnew();
      if ( t->border_mode == 1 || t->border_mode == 2 )
        savexmlstr_0(renderbuf, vrulea);
      if ( t->tridvalue[r] && !h )
      {
        v17 = html_quote(t->tridvalue[r]->ptr);
        idtag = Sprintf("<_id id=\"%s\">", v17);
        savexmlstr_0(renderbuf, idtag);
      }
      for ( i = 0; t->maxcol >= i; ++i )
      {
        check_row(t, r);
        if ( t->tabidvalue[r][i] && !h )
        {
          v18 = html_quote(t->tabidvalue[r][i]->ptr);
          idtag = Sprintf("<_id id=\"%s\">", v18);
          savexmlstr_0(renderbuf, idtag);
        }
        if ( (t->tabattr[r][i] & 1) == 0 )
        {
          w = t->tabwidth[i];
          for ( j = i + 1; t->maxcol >= j && (t->tabattr[r][j] & 1) != 0; ++j )
            w += t->tabwidth[j] + t->cellspacing;
          if ( (t->tabattr[r][i] & 2) != 0 )
          {
            for ( j = r - 1; j >= 0 && t->tabattr[j] && (t->tabattr[j][i] & 2) != 0; --j )
              ;
            print_item(t, j, i, w, renderbuf);
          }
          else
          {
            print_item(t, r, i, w, renderbuf);
          }
        }
        if ( t->maxcol > i && (t->tabattr[r][i + 1] & 1) == 0 )
          savexmlstr_0(renderbuf, vruleb);
      }
      if ( (unsigned int)(t->border_mode - 1) <= 1 )
      {
        savexmlstr_0(renderbuf, vrulec);
        ++t->total_height;
      }
      push_render_image(renderbuf, width, t->total_width, h_env);
    }
    if ( t->maxrow > r && t->border_mode )
    {
      renderbuf = Strnew();
      print_sep(t, r, 1, t->maxcol, renderbuf);
      push_render_image(renderbuf, width, t->total_width, h_env);
    }
    t->total_height += t->tabheight[r];
  }
  if ( (unsigned int)(t->border_mode - 1) <= 1 )
  {
    renderbuf = Strnew();
    print_sep(t, t->maxrow, 2, t->maxcol, renderbuf);
    push_render_image(renderbuf, width, t->total_width, h_env);
    ++t->total_height;
  }
  if ( !t->total_height )
  {
    renderbuf = Strnew_charp(" ");
    ++t->total_height;
    t->total_width = 1;
    push_render_image(renderbuf, 1, t->total_width, h_env);
  }
  HTMLlineproc0("</pre>", h_env, 1);
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (0808594A) --------------------------------------------------------
table *__cdecl begin_table(int border, int spacing, int padding, int vspace)
{
  int ppc; // [esp+2Ch] [ebp-1Ch]
  int mincell_pixels; // [esp+30h] [ebp-18h]
  int rcellspacing; // [esp+34h] [ebp-14h]
  int mincell; // [esp+38h] [ebp-10h]
  table *t; // [esp+3Ch] [ebp-Ch]

  mincell = minimum_cellspacing(border);
  mincell_pixels = (int)floor((long double)mincell * pixel_per_char + 0.5);
  ppc = (int)floor(pixel_per_char + 0.5);
  t = newTable();
  t->col = -1;
  t->row = t->col;
  t->maxcol = -1;
  t->maxrow = -1;
  t->border_mode = border;
  t->flag = 0;
  if ( border == 3 )
    t->flag |= 2u;
  rcellspacing = spacing + 2 * padding;
  if ( border )
  {
    if ( border >= 0 && border <= 3 )
      t->cellpadding = padding - (mincell_pixels - 4) / 2;
  }
  else
  {
    t->cellpadding = rcellspacing - mincell_pixels;
  }
  if ( t->cellpadding < ppc )
    t->cellpadding = t->cellpadding > 0;
  else
    t->cellpadding /= ppc;
  if ( border )
  {
    if ( border >= 0 && border <= 3 )
      t->cellspacing = mincell + 2 * t->cellpadding;
  }
  else
  {
    t->cellspacing = mincell + t->cellpadding;
  }
  if ( border )
    t->vspace = vspace >= ppc;
  else
    t->vspace = vspace + rcellspacing / 2 > 1;
  if ( border )
    t->vcellpadding = 2 * (ppc - 1) <= padding;
  else
    t->vcellpadding = rcellspacing > 4;
  return t;
}

//----- (08085B72) --------------------------------------------------------
void __cdecl end_table(table *tbl)
{
  int rulewidth; // [esp+14h] [ebp-14h]
  int i; // [esp+18h] [ebp-10h]
  int ia; // [esp+18h] [ebp-10h]
  table_cell *cell; // [esp+1Ch] [ebp-Ch]

  cell = &tbl->cell;
  rulewidth = table_rule_width(tbl);
  if ( rulewidth > 1 )
  {
    if ( tbl->total_width > 0 )
      tbl->total_width = ceil_at_intervals(tbl->total_width, rulewidth);
    for ( i = 0; tbl->maxcol >= i; ++i )
    {
      tbl->minimum_width[i] = ceil_at_intervals(tbl->minimum_width[i], rulewidth);
      tbl->tabwidth[i] = ceil_at_intervals(tbl->tabwidth[i], rulewidth);
      if ( tbl->fixed_width[i] > 0 )
        tbl->fixed_width[i] = ceil_at_intervals(tbl->fixed_width[i], rulewidth);
    }
    for ( ia = 0; tbl->cell.maxcell >= ia; ++ia )
    {
      cell->minimum_width[ia] = ceil_at_intervals(cell->minimum_width[ia], rulewidth);
      cell->width[ia] = ceil_at_intervals(cell->width[ia], rulewidth);
      if ( cell->fixed_width[ia] > 0 )
        cell->fixed_width[ia] = ceil_at_intervals(cell->fixed_width[ia], rulewidth);
    }
  }
  tbl->sloppy_width = get_table_width(tbl, tbl->fixed_width, tbl->cell.fixed_width, 1);
  if ( tbl->total_width > tbl->sloppy_width )
    tbl->sloppy_width = tbl->total_width;
}

//----- (08085D9E) --------------------------------------------------------
void __cdecl check_minimum0(table *t, int min)
{
  int v2; // eax
  int ww; // [esp+14h] [ebp-14h]
  int i; // [esp+1Ch] [ebp-Ch]
  int mina; // [esp+34h] [ebp+Ch]

  if ( t->col >= 0 && t->tabwidth[t->col] >= 0 )
  {
    check_row(t, t->row);
    v2 = table_colspan(t, t->row, t->col);
    mina = t->indent + min;
    if ( v2 == 1 )
    {
      ww = mina;
    }
    else
    {
      ww = 0;
      if ( t->cell.icell >= 0 && t->cell.minimum_width[t->cell.icell] < mina )
        t->cell.minimum_width[t->cell.icell] = mina;
    }
    for ( i = t->col; t->maxcol >= i && (t->col == i || (t->tabattr[t->row][i] & 1) != 0); ++i )
    {
      if ( t->minimum_width[i] < ww )
        t->minimum_width[i] = ww;
    }
  }
}

//----- (08085EE6) --------------------------------------------------------
int __cdecl setwidth0(table *t, table_mode *mode)
{
  int width; // [esp+18h] [ebp-10h]

  width = t->tabcontentssize;
  if ( t->col < 0 )
    return -1;
  if ( t->tabwidth[t->col] < 0 )
    return -1;
  check_row(t, t->row);
  if ( t->linfo.prev_spaces > 0 )
    width -= t->linfo.prev_spaces;
  if ( table_colspan(t, t->row, t->col) == 1 )
  {
    if ( t->tabwidth[t->col] < width )
      t->tabwidth[t->col] = width;
  }
  else if ( t->cell.icell >= 0 && t->cell.width[t->cell.icell] < width )
  {
    t->cell.width[t->cell.icell] = width;
  }
  return width;
}

//----- (08086002) --------------------------------------------------------
void __cdecl setwidth(table *t, table_mode *mode)
{
  int width; // [esp+1Ch] [ebp-Ch]

  width = setwidth0(t, mode);
  if ( width >= 0 )
  {
    if ( (t->tabattr[t->row][t->col] & 4) != 0 )
      check_minimum0(t, width);
    if ( (mode->pre_mode & 0x281) != 0 && mode->nobr_offset >= 0 )
      check_minimum0(t, width - mode->nobr_offset);
  }
}

//----- (0808609F) --------------------------------------------------------
void __cdecl addcontentssize(table *t, int width)
{
  if ( t->col >= 0 && t->tabwidth[t->col] >= 0 )
  {
    check_row(t, t->row);
    t->tabcontentssize += width;
  }
}

//----- (080860F2) --------------------------------------------------------
void __cdecl clearcontentssize(table *t, table_mode *mode)
{
  table_close_anchor0(t, mode);
  mode->nobr_offset = 0;
  t->linfo.prev_spaces = -1;
  Strcopy_charp_n(t->linfo.prevchar, " ", 1);
  t->linfo.prev_ctype = 0;
  t->linfo.length = 0;
  t->tabcontentssize = 0;
}

//----- (08086162) --------------------------------------------------------
void __cdecl begin_cell(table *t, table_mode *mode)
{
  GeneralList **v2; // ebx

  clearcontentssize(t, mode);
  mode->indent_level = 0;
  mode->nobr_level = 0;
  mode->pre_mode = 0;
  t->indent = 0;
  t->flag |= 4u;
  if ( t->suspended_data )
  {
    check_row(t, t->row);
    if ( !t->tabdata[t->row][t->col] )
    {
      v2 = &t->tabdata[t->row][t->col];
      *v2 = newGeneralList();
    }
    appendGeneralList(t->tabdata[t->row][t->col], (GeneralList *)t->suspended_data);
    t->suspended_data = 0;
  }
}

//----- (08086268) --------------------------------------------------------
void __cdecl check_rowcol(table *tbl, table_mode *mode)
{
  int col; // [esp+18h] [ebp-10h]
  int row; // [esp+1Ch] [ebp-Ch]

  row = tbl->row;
  col = tbl->col;
  if ( (tbl->flag & 1) == 0 )
  {
    tbl->flag |= 1u;
    if ( ++tbl->row > tbl->maxrow )
      tbl->maxrow = tbl->row;
    tbl->col = -1;
  }
  if ( tbl->row == -1 )
    tbl->row = 0;
  if ( tbl->col == -1 )
    tbl->col = 0;
  while ( 1 )
  {
    check_row(tbl, tbl->row);
    while ( tbl->col <= 49 && (tbl->tabattr[tbl->row][tbl->col] & 3) != 0 )
      ++tbl->col;
    if ( tbl->col <= 49 )
      break;
    tbl->col = 0;
    ++tbl->row;
  }
  if ( tbl->row > tbl->maxrow )
    tbl->maxrow = tbl->row;
  if ( tbl->col > tbl->maxcol )
    tbl->maxcol = tbl->col;
  if ( tbl->row != row || tbl->col != col )
    begin_cell(tbl, mode);
  tbl->flag |= 4u;
}

//----- (080863EA) --------------------------------------------------------
int __cdecl skip_space(table *t, char *line, table_linfo *linfo, int checkminimum)
{
  char *v4; // ebx
  int result; // eax
  int v6; // eax
  int v7; // [esp+4h] [ebp-44h]
  int plen; // [esp+10h] [ebp-38h]
  char *wlen; // [esp+14h] [ebp-34h]
  int len; // [esp+18h] [ebp-30h]
  signed int ec; // [esp+1Ch] [ebp-2Ch]
  char *c; // [esp+20h] [ebp-28h]
  char *save; // [esp+24h] [ebp-24h]
  int min; // [esp+28h] [ebp-20h]
  int w; // [esp+2Ch] [ebp-1Ch]
  Str prevchar; // [esp+30h] [ebp-18h]
  int s; // [esp+34h] [ebp-14h]
  int skip; // [esp+38h] [ebp-10h]
  Lineprop prev_ctype; // [esp+3Ch] [ebp-Ch]
  Lineprop ctype; // [esp+3Eh] [ebp-Ah]

  skip = 0;
  s = linfo->prev_spaces;
  prev_ctype = linfo->prev_ctype;
  prevchar = linfo->prevchar;
  w = linfo->length;
  min = 1;
  if ( *line == 60 && (v4 = line, v4[strlen(line) - 1] == 62) )
  {
    if ( checkminimum )
    {
      v7 = visible_length(line);
      check_minimum0(t, v7);
    }
    result = 0;
  }
  else
  {
    while ( *line )
    {
      save = line;
      c = line;
      ctype = WTF_TYPE_MAP[(unsigned __int8)*line] << 8;
      if ( WcOption.use_wide )
        v6 = WTF_WIDTH_MAP[(unsigned __int8)*line];
      else
        v6 = WTF_WIDTH_MAP[(unsigned __int8)*line] != 0;
      len = v6;
      plen = WTF_LEN_MAP[(unsigned __int8)*line];
      wlen = (char *)plen;
      if ( min < w )
        min = w;
      if ( ctype || (MYCTYPE_MAP[(unsigned __int8)*line] & 2) == 0 )
      {
        if ( *line == 38 )
        {
          ec = getescapechar(&line);
          if ( ec >= 0 )
          {
            c = conv_entity(ec);
            ctype = WTF_TYPE_MAP[(unsigned __int8)*c] << 8;
            len = wtf_strwidth((wc_uchar *)c);
            wlen = (char *)(line - save);
            plen = WTF_LEN_MAP[(unsigned __int8)*c];
          }
        }
        if ( prevchar->length && is_boundary((unsigned __int8 *)prevchar->ptr, (unsigned __int8 *)c) )
          w = len;
        else
          w += len;
        if ( s > 0 )
        {
          if ( ctype == 2560 && prev_ctype == 2560 )
            skip += s;
          else
            skip += s - 1;
        }
        s = 0;
        prev_ctype = ctype;
      }
      else
      {
        w = 0;
        ++s;
      }
      Strcopy_charp_n(prevchar, c, plen);
      line = &wlen[(_DWORD)save];
    }
    if ( s <= 1 )
    {
      linfo->prev_spaces = s;
    }
    else
    {
      skip += s - 1;
      linfo->prev_spaces = 1;
    }
    linfo->prev_ctype = prev_ctype;
    linfo->prevchar = prevchar;
    if ( checkminimum )
    {
      if ( min < w )
        min = w;
      linfo->length = w;
      check_minimum0(t, min);
    }
    result = skip;
  }
  return result;
}

//----- (080866C5) --------------------------------------------------------
void __cdecl feed_table_inline_tag(table *tbl, char *line, table_mode *mode, int width)
{
  check_rowcol(tbl, mode);
  pushdata(tbl, tbl->row, tbl->col, line);
  if ( width >= 0 )
  {
    check_minimum0(tbl, width);
    addcontentssize(tbl, width);
    setwidth(tbl, mode);
  }
}

//----- (08086740) --------------------------------------------------------
void __cdecl feed_table_block_tag(table *tbl, char *line, table_mode *mode, int indent, int cmd)
{
  int offset; // [esp+1Ch] [ebp-Ch]

  if ( mode->indent_level > 0 || indent != -1 )
  {
    setwidth(tbl, mode);
    feed_table_inline_tag(tbl, line, mode, -1);
    clearcontentssize(tbl, mode);
    if ( indent == 1 )
    {
      if ( ++mode->indent_level <= 10 )
        tbl->indent += IndentIncr;
    }
    else if ( indent == -1 && --mode->indent_level <= 9 )
    {
      tbl->indent -= IndentIncr;
    }
    offset = tbl->indent;
    if ( cmd == 19 && mode->indent_level > 0 && mode->indent_level <= 10 )
      offset -= IndentIncr;
    if ( tbl->indent > 0 )
    {
      check_minimum0(tbl, 0);
      addcontentssize(tbl, offset);
    }
  }
}

//----- (0808686B) --------------------------------------------------------
void __cdecl table_close_select(table *tbl, table_mode *mode, int width)
{
  unsigned int v3; // edx
  _Str *tmp; // [esp+1Ch] [ebp-Ch]

  tmp = process_n_select();
  v3 = mode->pre_mode;
  BYTE1(v3) = BYTE1(mode->pre_mode) & 0xEF;
  mode->pre_mode = v3;
  mode->end_tag = 0;
  feed_table1(tbl, tmp, mode, width);
}

//----- (080868B1) --------------------------------------------------------
void __cdecl table_close_textarea(table *tbl, table_mode *mode, int width)
{
  unsigned int v3; // edx
  _Str *tmp; // [esp+1Ch] [ebp-Ch]

  tmp = process_n_textarea();
  v3 = mode->pre_mode;
  BYTE1(v3) = BYTE1(mode->pre_mode) & 0xF7;
  mode->pre_mode = v3;
  mode->end_tag = 0;
  feed_table1(tbl, tmp, mode, width);
}

//----- (080868F7) --------------------------------------------------------
void __cdecl table_close_anchor0(table *tbl, table_mode *mode)
{
  if ( (mode->pre_mode & 0x1000000) != 0 )
  {
    mode->pre_mode &= 0xFEFFFFFF;
    if ( tbl->tabcontentssize == mode->anchor_offset )
    {
      check_minimum0(tbl, 1);
      addcontentssize(tbl, 1);
      setwidth(tbl, mode);
    }
    else if ( tbl->linfo.prev_spaces > 0
           && tbl->tabcontentssize - 1 == mode->anchor_offset
           && tbl->linfo.prev_spaces > 0 )
    {
      tbl->linfo.prev_spaces = -1;
    }
  }
}

//----- (080869AD) --------------------------------------------------------
int __cdecl feed_table_tag(table *tbl, char *line, table_mode *mode, int width, parsed_tag *tag)
{
  int result; // eax
  Str *v6; // ebx
  int v7; // eax
  Str *v8; // ebx
  __int16 v9; // ax
  unsigned int v10; // edx
  unsigned int v11; // edx
  unsigned int v12; // edx
  unsigned int v13; // edx
  unsigned int v14; // edx
  unsigned int v15; // edx
  char *v16; // ecx
  _Str *v17; // [esp+4h] [ebp-A4h]
  _Str *v18; // [esp+4h] [ebp-A4h]
  int v19; // [esp+4h] [ebp-A4h]
  table *tbl1; // [esp+3Ch] [ebp-6Ch]
  int ii; // [esp+44h] [ebp-64h]
  Str anchor; // [esp+48h] [ebp-60h] BYREF
  Str tmp; // [esp+4Ch] [ebp-5Ch]
  int id; // [esp+54h] [ebp-54h] BYREF
  int w; // [esp+58h] [ebp-50h]
  int v0; // [esp+5Ch] [ebp-4Ch]
  int v; // [esp+60h] [ebp-48h] BYREF
  int k; // [esp+64h] [ebp-44h]
  int j; // [esp+68h] [ebp-40h]
  int i; // [esp+6Ch] [ebp-3Ch] BYREF
  int prev_col; // [esp+70h] [ebp-38h]
  int col; // [esp+74h] [ebp-34h]
  int rowspan; // [esp+78h] [ebp-30h] BYREF
  int colspan; // [esp+7Ch] [ebp-2Ch] BYREF
  table_cell *cell; // [esp+80h] [ebp-28h]
  char *p; // [esp+84h] [ebp-24h] BYREF
  int cmd; // [esp+88h] [ebp-20h]
  table_attr valign; // [esp+8Ch] [ebp-1Ch]
  table_attr align; // [esp+8Eh] [ebp-1Ah]

  cell = &tbl->cell;
  cmd = tag->tagid;
  if ( (mode->pre_mode & 8) != 0 )
  {
    if ( mode->end_tag != cmd )
      return 4;
    mode->pre_mode &= 0xFFFFFFF7;
    mode->end_tag = 0;
    feed_table_block_tag(tbl, line, mode, 0, cmd);
    return 0;
  }
  if ( (mode->pre_mode & 0x800) == 0 )
  {
LABEL_10:
    if ( (mode->pre_mode & 2) != 0 )
    {
      if ( mode->end_tag != cmd )
        return 4;
      mode->pre_mode &= 0xFFFFFFFD;
      mode->end_tag = 0;
      return 0;
    }
    if ( (mode->pre_mode & 4) != 0 )
    {
      if ( mode->end_tag != cmd )
        return 4;
      mode->pre_mode &= 0xFFFFFFFB;
      mode->end_tag = 0;
      return 0;
    }
    if ( (mode->pre_mode & 0x1000) != 0 )
    {
      switch ( cmd )
      {
        case 31:
        case 32:
        case 43:
        case 48:
        case 74:
        case 75:
        case 76:
        case 77:
        case 80:
        case 81:
        case 82:
        case 83:
        case 84:
        case 85:
        case 86:
        case 87:
        case 88:
        case 89:
        case 90:
          table_close_select(tbl, mode, width);
          if ( cmd != 48 )
            goto LABEL_23;
          result = 0;
          break;
        default:
          return 1;
      }
      return result;
    }
LABEL_23:
    if ( mode->caption )
    {
      switch ( cmd )
      {
        case 31:
        case 32:
        case 74:
        case 75:
        case 76:
        case 77:
        case 79:
        case 80:
        case 81:
        case 82:
        case 83:
        case 84:
        case 85:
        case 86:
        case 87:
        case 88:
        case 89:
        case 90:
          mode->caption = 0;
          if ( cmd != 79 )
            goto LABEL_28;
          result = 0;
          break;
        default:
          return 1;
      }
      return result;
    }
LABEL_28:
    if ( (mode->pre_mode & 1) != 0 && cmd >= 50 && (cmd <= 51 || (unsigned int)(cmd - 128) <= 1) )
      return 0;
    switch ( cmd )
    {
      case 1:
        table_close_anchor0(tbl, mode);
        anchor = 0;
        i = 0;
        parsedtag_get_value(tag, 18, &anchor);
        parsedtag_get_value(tag, 69, &i);
        if ( anchor )
        {
          check_rowcol(tbl, mode);
          if ( i )
          {
            pushdata(tbl, tbl->row, tbl->col, line);
          }
          else
          {
            v16 = process_anchor(tag, line)->ptr;
            pushdata(tbl, tbl->row, tbl->col, v16);
          }
          if ( i >= 0 )
          {
            mode->pre_mode |= 0x1000000u;
            mode->anchor_offset = tbl->tabcontentssize;
          }
        }
        else
        {
          suspend_or_pushdata(tbl, line);
        }
        return 0;
      case 2:
        table_close_anchor0(tbl, mode);
        goto LABEL_277;
      case 3:
      case 4:
      case 11:
      case 16:
      case 19:
      case 20:
      case 21:
      case 22:
      case 26:
      case 28:
      case 30:
      case 139:
      case 140:
        goto LABEL_168;
      case 5:
      case 6:
      case 38:
      case 39:
      case 52:
      case 53:
        if ( (tbl->flag & 1) == 0 )
          return 0;
LABEL_168:
        feed_table_block_tag(tbl, line, mode, 0, cmd);
        if ( cmd == 28 )
        {
          mode->pre_mode |= 8u;
          mode->end_tag = 29;
          return 0;
        }
        if ( cmd > 28 )
        {
          if ( cmd == 139 )
          {
LABEL_178:
            mode->pre_mode |= 1u;
            return 0;
          }
          if ( cmd != 140 )
          {
            if ( cmd == 30 )
            {
              mode->pre_mode |= 8u;
              mode->end_tag = -111;
            }
            return 0;
          }
        }
        else if ( cmd != 22 )
        {
          if ( cmd != 26 )
          {
            if ( cmd != 21 )
              return 0;
            goto LABEL_178;
          }
          mode->pre_mode |= 8u;
          mode->end_tag = 27;
          return 0;
        }
        mode->pre_mode &= 0xFFFFFFFE;
        return 0;
      case 9:
      case 12:
      case 17:
      case 23:
        feed_table_block_tag(tbl, line, mode, 1, cmd);
        return 0;
      case 10:
      case 13:
      case 18:
      case 24:
        feed_table_block_tag(tbl, line, mode, -1, cmd);
        return 0;
      case 25:
        check_rowcol(tbl, mode);
        w = tbl->fixed_width[tbl->col];
        if ( w >= 0 )
        {
          if ( !w )
          {
            if ( tbl->total_width <= 0 )
            {
              if ( width > 0 )
                w = width;
            }
            else
            {
              w = tbl->total_width;
            }
          }
        }
        else if ( tbl->total_width <= 0 )
        {
          if ( width <= 0 )
            w = 0;
          else
            w = w * -width / 100;
        }
        else
        {
          w = w * -tbl->total_width / 100;
        }
        v17 = process_img(tag, w);
        feed_table1(tbl, v17, mode, width);
        return 0;
      case 31:
        check_rowcol(tbl, mode);
        return 2;
      case 32:
        if ( tbl->suspended_data )
          check_rowcol(tbl, mode);
        return 3;
      case 40:
      case 41:
      case 138:
LABEL_277:
        suspend_or_pushdata(tbl, line);
        return 0;
      case 42:
        feed_table_block_tag(tbl, (char *)&byte_80CB060, mode, 0, cmd);
        tmp = process_form(tag);
        if ( tmp )
          feed_table1(tbl, tmp, mode, width);
        return 0;
      case 43:
        feed_table_block_tag(tbl, (char *)&byte_80CB060, mode, 0, cmd);
        process_n_form();
        return 0;
      case 44:
        v18 = process_input(tag);
        feed_table1(tbl, v18, mode, width);
        return 0;
      case 45:
        w = 0;
        check_rowcol(tbl, mode);
        if ( tbl->col + 1 <= tbl->maxcol && (tbl->tabattr[tbl->row][tbl->col + 1] & 1) != 0 )
        {
          if ( cell->icell >= 0 && cell->fixed_width[cell->icell] > 0 )
            w = cell->fixed_width[cell->icell];
        }
        else if ( tbl->fixed_width[tbl->col] > 0 )
        {
          w = tbl->fixed_width[tbl->col];
        }
        tmp = process_textarea(tag, w);
        if ( tmp )
          feed_table1(tbl, tmp, mode, width);
        v15 = mode->pre_mode;
        BYTE1(v15) = BYTE1(mode->pre_mode) | 8;
        mode->pre_mode = v15;
        mode->end_tag = 46;
        return 0;
      case 47:
        tmp = process_select(tag);
        if ( tmp )
          feed_table1(tbl, tmp, mode, width);
        v14 = mode->pre_mode;
        BYTE1(v14) = BYTE1(mode->pre_mode) | 0x10;
        mode->pre_mode = v14;
        mode->end_tag = 48;
        return 0;
      case 48:
      case 49:
      case 79:
      case 82:
      case 83:
      case 84:
      case 85:
      case 86:
      case 87:
      case 88:
      case 89:
      case 90:
      case 101:
        return 0;
      case 50:
      case 69:
        if ( (tbl->flag & 1) != 0 )
          goto LABEL_186;
        return 0;
      case 51:
        if ( (tbl->flag & 1) != 0 )
        {
          feed_table_inline_tag(tbl, line, mode, -1);
          if ( mode->nobr_level > 0 )
            --mode->nobr_level;
          if ( !mode->nobr_level )
          {
            v12 = mode->pre_mode;
            LOBYTE(v12) = mode->pre_mode & 0x7F;
            mode->pre_mode = v12;
          }
        }
        return 0;
      case 58:
        mode->pre_mode |= 2u;
        mode->end_tag = 59;
        return 0;
      case 61:
        switch ( displayInsDel )
        {
          case 1:
            goto LABEL_266;
          case 2:
            goto LABEL_267;
          case 0:
            mode->pre_mode |= 0x100000u;
            break;
        }
        return 0;
      case 62:
        switch ( displayInsDel )
        {
          case 1:
            goto LABEL_266;
          case 2:
            goto LABEL_267;
          case 0:
            mode->pre_mode &= 0xFFEFFFFF;
            break;
        }
        return 0;
      case 63:
      case 64:
        if ( displayInsDel == 1 )
        {
LABEL_266:
          feed_table_inline_tag(tbl, line, mode, 5);
        }
        else if ( displayInsDel == 2 )
        {
          goto LABEL_267;
        }
        return 0;
      case 67:
        mode->pre_mode |= 4u;
        mode->end_tag = 68;
        return 0;
      case 74:
        if ( tbl->col >= 0 && tbl->tabcontentssize > 0 )
          setwidth(tbl, mode);
        tbl->col = -1;
        ++tbl->row;
        tbl->flag |= 1u;
        tbl->flag &= 0xFFFFFFFB;
        align = 0;
        valign = 0;
        if ( parsedtag_get_value(tag, 4, &i) )
        {
          switch ( i )
          {
            case 1:
              align = 64;
              break;
            case 2:
              align = 96;
              break;
            case 0:
              align = 80;
              break;
          }
        }
        if ( parsedtag_get_value(tag, 35, &i) )
        {
          switch ( i )
          {
            case 1:
              valign = 2304;
              break;
            case 2:
              valign = 3072;
              break;
            case 0:
              valign = 2560;
              break;
          }
        }
        if ( parsedtag_get_value(tag, 20, &p) )
        {
          v6 = &tbl->tridvalue[tbl->row];
          *v6 = Strnew_charp(p);
        }
        tbl->trattr = valign | align;
        return 0;
      case 75:
        setwidth(tbl, mode);
        tbl->col = -1;
        tbl->flag &= 0xFFFFFFFA;
        return 0;
      case 76:
      case 80:
        prev_col = tbl->col;
        if ( tbl->col >= 0 && tbl->tabcontentssize > 0 )
          setwidth(tbl, mode);
        if ( tbl->row == -1 )
        {
          tbl->row = -1;
          tbl->col = -1;
          tbl->maxrow = tbl->row;
        }
        if ( tbl->col == -1 )
        {
          if ( (tbl->flag & 1) == 0 )
          {
            ++tbl->row;
            tbl->flag |= 1u;
          }
          if ( tbl->row > tbl->maxrow )
            tbl->maxrow = tbl->row;
        }
        ++tbl->col;
        check_row(tbl, tbl->row);
        while ( tbl->tabattr[tbl->row][tbl->col] )
          ++tbl->col;
        if ( tbl->col > 49 )
        {
          tbl->col = prev_col;
          return 0;
        }
        if ( tbl->col > tbl->maxcol )
          tbl->maxcol = tbl->col;
        rowspan = 1;
        colspan = 1;
        if ( (tbl->trattr & 0x40) != 0 )
        {
          align = tbl->trattr & 0x30;
        }
        else if ( cmd == 80 )
        {
          align = 16;
        }
        else
        {
          align = 0;
        }
        if ( (tbl->trattr & 0x800) != 0 )
          valign = tbl->trattr & 0x700;
        else
          valign = 512;
        if ( parsedtag_get_value(tag, 29, &rowspan) && rowspan + tbl->row >= tbl->max_rowsize )
          check_row(tbl, tbl->row + rowspan);
        if ( parsedtag_get_value(tag, 14, &colspan) && tbl->col + colspan > 49 )
          colspan = 50 - tbl->col;
        if ( parsedtag_get_value(tag, 4, &i) )
        {
          switch ( i )
          {
            case 1:
              align = 0;
              break;
            case 2:
              align = 32;
              break;
            case 0:
              align = 16;
              break;
          }
        }
        if ( parsedtag_get_value(tag, 35, &i) )
        {
          switch ( i )
          {
            case 1:
              valign = 256;
              break;
            case 2:
              valign = 1024;
              break;
            case 0:
              valign = 512;
              break;
          }
        }
        if ( tag->map && tag->map[26] != 75 && tag->attrid[tag->map[26]] )
          tbl->tabattr[tbl->row][tbl->col] |= 4;
        v = 0;
        if ( parsedtag_get_value(tag, 38, &v) )
        {
          if ( v < 0 )
            v7 = v;
          else
            v7 = (int)((long double)v / pixel_per_char);
          v = v7;
        }
        if ( parsedtag_get_value(tag, 20, &p) )
        {
          v8 = &tbl->tabidvalue[tbl->row][tbl->col];
          *v8 = Strnew_charp(p);
        }
        if ( v )
          tbl->tabattr[tbl->row][tbl->col] &= 0xFFFB;
        tbl->tabattr[tbl->row][tbl->col] &= 0xF8CF;
        tbl->tabattr[tbl->row][tbl->col] |= align | valign;
        if ( colspan > 1 )
        {
          col = tbl->col;
          cell->icell = cell->maxcell + 1;
          k = bsearch_2short(colspan, cell->colspan, col, cell->col, 50, cell->index, cell->icell);
          if ( cell->maxcell >= k )
          {
            i = cell->index[k];
            if ( cell->col[i] == col && cell->colspan[i] == colspan )
              cell->icell = i;
          }
          if ( cell->icell > cell->maxcell && cell->icell <= 19 )
          {
            cell->col[++cell->maxcell] = col;
            cell->colspan[cell->maxcell] = colspan;
            cell->width[cell->maxcell] = 0;
            cell->minimum_width[cell->maxcell] = 0;
            cell->fixed_width[cell->maxcell] = 0;
            if ( cell->maxcell > k )
            {
              for ( ii = cell->maxcell; ii > k; --ii )
                cell->index[ii] = cell->colspan[ii + 19];
            }
            cell->index[k] = cell->maxcell;
          }
          if ( cell->icell > cell->maxcell )
            cell->icell = -1;
        }
        if ( v )
        {
          if ( colspan == 1 )
          {
            v0 = tbl->fixed_width[tbl->col];
            if ( !v0 || v0 > 0 && v > v0 || v0 < 0 && v < v0 )
              tbl->fixed_width[tbl->col] = v;
          }
          else if ( cell->icell >= 0
                 && ((v0 = cell->fixed_width[cell->icell]) == 0 || v0 > 0 && v > v0 || v0 < 0 && v < v0) )
          {
            cell->fixed_width[cell->icell] = v;
          }
        }
        for ( i = 0; i < rowspan; ++i )
        {
          check_row(tbl, tbl->row + i);
          for ( j = 0; j < colspan; ++j )
          {
            if ( ((&tbl->tabattr[tbl->row])[i][j + tbl->col] & 3) == 0 )
            {
              if ( i <= 0 )
                v9 = 0;
              else
                v9 = 2;
              (&tbl->tabattr[tbl->row])[i][j + tbl->col] |= (j > 0) | v9;
            }
            if ( j + tbl->col > tbl->maxcol )
              tbl->maxcol = j + tbl->col;
          }
          if ( i + tbl->row > tbl->maxrow )
            tbl->maxrow = i + tbl->row;
        }
        begin_cell(tbl, mode);
        return 0;
      case 77:
      case 81:
        setwidth(tbl, mode);
        tbl->flag &= 0xFFFFFFFB;
        return 0;
      case 78:
        mode->caption = 1;
        return 0;
      case 100:
      case 102:
      case 103:
        if ( (mode->pre_mode & 0x300000) == 0 )
          feed_table_inline_tag(tbl, line, mode, 1);
        return 0;
      case 105:
        switch ( displayInsDel )
        {
          case 1:
            goto LABEL_255;
          case 2:
            goto LABEL_267;
          case 0:
            mode->pre_mode |= 0x200000u;
            break;
        }
        return 0;
      case 106:
        switch ( displayInsDel )
        {
          case 1:
LABEL_255:
            feed_table_inline_tag(tbl, line, mode, 3);
            break;
          case 2:
LABEL_267:
            feed_table_inline_tag(tbl, line, mode, -1);
            break;
          case 0:
            mode->pre_mode &= 0xFFDFFFFF;
            break;
        }
        return 0;
      case 125:
        id = -1;
        w = 0;
        parsedtag_get_value(tag, 64, &id);
        if ( id >= 0 && tbl->ntable > id )
        {
          tbl1 = tbl->tables[id].ptr;
          feed_table_block_tag(tbl, line, mode, 0, cmd);
          v19 = get_table_width(tbl1, tbl1->tabwidth, tbl1->cell.width, 2);
          addcontentssize(tbl, v19);
          check_minimum0(tbl, tbl1->sloppy_width);
          setwidth0(tbl, mode);
          clearcontentssize(tbl, mode);
        }
        return 0;
      case 128:
LABEL_186:
        feed_table_inline_tag(tbl, line, mode, -1);
        if ( cmd == 50 )
        {
          ++mode->nobr_level;
          if ( (mode->pre_mode & 0x80) != 0 )
            return 0;
          v10 = mode->pre_mode;
          LOBYTE(v10) = mode->pre_mode | 0x80;
          mode->pre_mode = v10;
        }
        else if ( cmd == 128 )
        {
          if ( (mode->pre_mode & 0x200) != 0 )
            return 0;
          v11 = mode->pre_mode;
          BYTE1(v11) = BYTE1(mode->pre_mode) | 2;
          mode->pre_mode = v11;
          tbl->linfo.prev_spaces = 0;
        }
        mode->nobr_offset = -1;
        if ( tbl->linfo.length > 0 )
        {
          check_minimum0(tbl, tbl->linfo.length);
          tbl->linfo.length = 0;
        }
        return 0;
      case 129:
        feed_table_inline_tag(tbl, line, mode, -1);
        v13 = mode->pre_mode;
        BYTE1(v13) = BYTE1(mode->pre_mode) & 0xFD;
        mode->pre_mode = v13;
        return 0;
      default:
        return 1;
    }
  }
  switch ( cmd )
  {
    case 31:
    case 32:
    case 46:
    case 74:
    case 75:
    case 76:
    case 77:
    case 80:
    case 81:
    case 82:
    case 83:
    case 84:
    case 85:
    case 86:
    case 87:
    case 88:
    case 89:
    case 90:
      table_close_textarea(tbl, mode, width);
      if ( cmd != 46 )
        goto LABEL_10;
      result = 0;
      break;
    default:
      return 1;
  }
  return result;
}

//----- (0808822A) --------------------------------------------------------
int __cdecl feed_table(table *tbl, char *line, table_mode *mode, int width, int internal)
{
  int v5; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // [esp+4h] [ebp-54h]
  int nl; // [esp+2Ch] [ebp-2Ch]
  int ec; // [esp+30h] [ebp-28h]
  char *r; // [esp+34h] [ebp-24h]
  char *q; // [esp+38h] [ebp-20h]
  parsed_tag *tag; // [esp+3Ch] [ebp-1Ch]
  Str tmp; // [esp+44h] [ebp-14h]
  Str tmpa; // [esp+44h] [ebp-14h]
  char *p; // [esp+48h] [ebp-10h] BYREF
  int i; // [esp+4Ch] [ebp-Ch]

  if ( *line == 60
    && line[1]
    && ((MYCTYPE_MAP[(unsigned __int8)line[1]] & 4) != 0
     || line[1] == 47
     || line[1] == 33
     || line[1] == 63
     || !line[1]
     || line[1] == 95) )
  {
    p = line;
    tag = parse_tag(&p, internal);
    if ( tag )
    {
      v5 = feed_table_tag(tbl, line, mode, width, tag);
      if ( v5 == 2 )
        return 1;
      if ( v5 <= 2 )
      {
        if ( !v5 )
          return -1;
LABEL_21:
        if ( tag->need_reconstruct )
          line = parsedtag2str(tag)->ptr;
        goto LABEL_27;
      }
      if ( v5 == 3 )
        return 0;
      if ( v5 != 4 )
        goto LABEL_21;
    }
    else if ( (mode->pre_mode & 0x180E) == 0 )
    {
      return -1;
    }
  }
  else if ( (mode->pre_mode & 0x300000) != 0 )
  {
    return -1;
  }
LABEL_27:
  if ( mode->caption )
  {
    Strcat_charp(tbl->caption, line);
    return -1;
  }
  if ( (mode->pre_mode & 2) != 0 )
    return -1;
  if ( (mode->pre_mode & 4) != 0 )
    return -1;
  if ( (mode->pre_mode & 0x800) != 0 )
  {
    feed_textarea(line);
    return -1;
  }
  if ( (mode->pre_mode & 0x1000) != 0 )
  {
    feed_select(line);
    return -1;
  }
  if ( (mode->pre_mode & 8) == 0 && (*line != 60 || line[strlen(line) - 1] != 62) && strchr(line, 38) )
  {
    tmp = Strnew();
    p = line;
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            if ( !*p )
            {
              line = tmp->ptr;
              goto LABEL_77;
            }
            if ( *p == 38 )
              break;
            if ( tmp->length + 1 >= tmp->area_size )
              Strgrow(tmp);
            v12 = tmp->length;
            tmp->ptr[v12] = *p;
            tmp->length = v12 + 1;
            tmp->ptr[tmp->length] = 0;
            ++p;
          }
          if ( strncasecmp(p, "&amp;", 5u) && strncasecmp(p, "&gt;", 4u) && strncasecmp(p, "&lt;", 4u) )
            break;
          if ( tmp->length + 1 >= tmp->area_size )
            Strgrow(tmp);
          v7 = tmp->length;
          tmp->ptr[v7] = *p;
          tmp->length = v7 + 1;
          tmp->ptr[tmp->length] = 0;
          ++p;
        }
        q = p;
        v8 = getescapechar(&p);
        ec = v8;
        if ( v8 != 38 )
          break;
        Strcat_charp(tmp, "&amp;");
      }
      if ( v8 > 38 )
      {
        if ( v8 == 60 )
        {
          Strcat_charp(tmp, "&lt;");
        }
        else
        {
          if ( v8 != 62 )
            goto LABEL_63;
          Strcat_charp(tmp, "&gt;");
        }
      }
      else
      {
        if ( v8 == -1 )
          goto LABEL_69;
        if ( v8 == 13 )
        {
          if ( tmp->length + 1 >= tmp->area_size )
            Strgrow(tmp);
          v9 = tmp->length;
          tmp->ptr[v9] = 10;
          tmp->length = v9 + 1;
          tmp->ptr[tmp->length] = 0;
        }
        else
        {
LABEL_63:
          r = conv_entity(v8);
          if ( r && strlen(r) == 1 && (unsigned __int8)*r == ec )
          {
            if ( tmp->length + 1 >= tmp->area_size )
              Strgrow(tmp);
            v10 = tmp->length;
            tmp->ptr[v10] = *r;
            tmp->length = v10 + 1;
            tmp->ptr[tmp->length] = 0;
          }
          else
          {
LABEL_69:
            if ( tmp->length + 1 >= tmp->area_size )
              Strgrow(tmp);
            v11 = tmp->length;
            tmp->ptr[v11] = *q;
            tmp->length = v11 + 1;
            tmp->ptr[tmp->length] = 0;
            p = q + 1;
          }
        }
      }
    }
  }
LABEL_77:
  if ( (mode->pre_mode & 0x20F) != 0 )
  {
    if ( (mode->pre_mode & 0x200) != 0 )
    {
      check_rowcol(tbl, mode);
      if ( mode->nobr_offset < 0 )
        mode->nobr_offset = tbl->tabcontentssize;
      v14 = maximum_visible_length(line, tbl->tabcontentssize);
      addcontentssize(tbl, v14);
      setwidth(tbl, mode);
      pushdata(tbl, tbl->row, tbl->col, line);
    }
    else
    {
      check_rowcol(tbl, mode);
      while ( *line )
      {
        nl = 0;
        p = strchr(line, 13);
        if ( p || (p = strchr(line, 10)) != 0 )
        {
          if ( *p == 13 && p[1] == 10 )
            ++p;
          if ( p[1] )
          {
            tmpa = Strnew_charp_n(line, ++p - line);
            line = p;
            p = tmpa->ptr;
          }
          else
          {
            p = line;
            line = (char *)&byte_80CB060;
          }
          nl = 1;
        }
        else
        {
          p = line;
          line = (char *)&byte_80CB060;
        }
        if ( (mode->pre_mode & 8) != 0 )
          i = maximum_visible_length_plain(p, tbl->tabcontentssize);
        else
          i = maximum_visible_length(p, tbl->tabcontentssize);
        addcontentssize(tbl, i);
        setwidth(tbl, mode);
        if ( nl )
          clearcontentssize(tbl, mode);
        pushdata(tbl, tbl->row, tbl->col, p);
      }
    }
  }
  else
  {
    if ( (tbl->flag & 4) == 0 || tbl->linfo.prev_spaces )
    {
      while ( (MYCTYPE_MAP[(unsigned __int8)*line] & 2) != 0 )
        ++line;
    }
    if ( !*line )
      return -1;
    check_rowcol(tbl, mode);
    if ( (mode->pre_mode & 0x80) != 0 && mode->nobr_offset < 0 )
      mode->nobr_offset = tbl->tabcontentssize;
    i = skip_space(tbl, line, &tbl->linfo, (mode->pre_mode & 0x80) == 0);
    v13 = visible_length(line);
    addcontentssize(tbl, v13 - i);
    setwidth(tbl, mode);
    pushdata(tbl, tbl->row, tbl->col, line);
  }
  return -1;
}

//----- (08088AE3) --------------------------------------------------------
void __cdecl feed_table1(table *tbl, Str tok, table_mode *mode, int width)
{
  char *line; // [esp+24h] [ebp-14h] BYREF
  int status; // [esp+28h] [ebp-10h] BYREF
  Str tokbuf; // [esp+2Ch] [ebp-Ch]

  if ( tok )
  {
    tokbuf = Strnew();
    status = 0;
    line = tok->ptr;
    while ( read_token(tokbuf, &line, &status, mode->pre_mode & 0xA0F, 0) )
      feed_table(tbl, tokbuf->ptr, mode, width, 1);
  }
}

//----- (08088B6A) --------------------------------------------------------
void __cdecl pushTable(table *tbl, table *tbl1)
{
  table_in *v2; // ebx
  table_in *tmp; // [esp+14h] [ebp-14h]
  int row; // [esp+18h] [ebp-10h]
  int col; // [esp+1Ch] [ebp-Ch]

  col = tbl->col;
  row = tbl->row;
  if ( tbl->ntable >= tbl->tables_size )
  {
    tbl->tables_size += 20;
    tmp = (table_in *)GC_malloc(16 * tbl->tables_size);
    if ( tbl->tables )
      bcopy(tbl->tables, tmp, 16 * tbl->ntable);
    tbl->tables = tmp;
  }
  tbl->tables[tbl->ntable].ptr = tbl1;
  tbl->tables[tbl->ntable].col = col;
  tbl->tables[tbl->ntable].row = row;
  tbl->tables[tbl->ntable].indent = tbl->indent;
  v2 = &tbl->tables[tbl->ntable];
  v2->buf = (TextLineList *)newGeneralList();
  check_row(tbl, row);
  if ( col + 1 <= tbl->maxcol && (tbl->tabattr[row][col + 1] & 1) != 0 )
    tbl->tables[tbl->ntable].cell = tbl->cell.icell;
  else
    tbl->tables[tbl->ntable].cell = -1;
  ++tbl->ntable;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (08088D64) --------------------------------------------------------
int __cdecl correct_table_matrix(table *t, int col, int cspan, int a, double b)
{
  double w; // [esp+10h] [ebp-18h]
  int ecol; // [esp+1Ch] [ebp-Ch]
  int j; // [esp+20h] [ebp-8h]
  int i; // [esp+24h] [ebp-4h]

  ecol = col + cspan;
  w = 1.0 / (b * b);
  for ( i = col; i < ecol; ++i )
  {
    t->vector->ve[i] = t->vector->ve[i] + (long double)a * w;
    for ( j = i; j < ecol; ++j )
    {
      t->matrix->me[j + i * t->matrix->dim] = t->matrix->me[j + i * t->matrix->dim] + w;
      t->matrix->me[i + j * t->matrix->dim] = t->matrix->me[j + i * t->matrix->dim];
    }
  }
  return i;
}

//----- (08088E96) --------------------------------------------------------
void __cdecl correct_table_matrix2(table *t, int col, int cspan, double s, double b)
{
  double ss_0; // [esp+10h] [ebp-20h]
  int size; // [esp+20h] [ebp-10h]
  int ecol; // [esp+24h] [ebp-Ch]
  int j; // [esp+28h] [ebp-8h]
  int i; // [esp+2Ch] [ebp-4h]

  ecol = col + cspan;
  size = t->maxcol + 1;
  for ( i = 0; i < size; ++i )
  {
    for ( j = i; j < size; ++j )
    {
      if ( i < col || i >= ecol || j < col || j >= ecol )
      {
        if ( (i < col || i >= ecol) && (j < col || j >= ecol) )
          ss_0 = s * s;
        else
          ss_0 = -(1.0 - s) * s;
      }
      else
      {
        ss_0 = (1.0 - s) * (1.0 - s);
      }
      t->matrix->me[j + i * t->matrix->dim] = t->matrix->me[j + i * t->matrix->dim] + (double)(1.0 / (b * b)) * ss_0;
    }
  }
}

//----- (08088FCE) --------------------------------------------------------
void __cdecl correct_table_matrix3(table *t, int col, char *flags, double s, double b)
{
  double ss_0; // [esp+18h] [ebp-18h]
  int flg; // [esp+20h] [ebp-10h]
  int size; // [esp+24h] [ebp-Ch]
  int j; // [esp+28h] [ebp-8h]
  int i; // [esp+2Ch] [ebp-4h]

  size = t->maxcol + 1;
  flg = flags[col] == 0;
  for ( i = 0; i < size; ++i )
  {
    if ( flg && !flags[i] || !flg && flags[i] )
    {
      for ( j = i; j < size; ++j )
      {
        if ( flg && !flags[j] || !flg && flags[j] )
        {
          if ( i == col && j == col )
          {
            ss_0 = (1.0 - s) * (1.0 - s);
          }
          else if ( i == col || j == col )
          {
            ss_0 = -(1.0 - s) * s;
          }
          else
          {
            ss_0 = s * s;
          }
          t->matrix->me[j + i * t->matrix->dim] = t->matrix->me[j + i * t->matrix->dim] + (double)(1.0 / (b * b)) * ss_0;
        }
      }
    }
  }
}

//----- (08089156) --------------------------------------------------------
void __cdecl correct_table_matrix4(table *t, int col, int cspan, char *flags, double s, double b)
{
  double ss_0; // [esp+18h] [ebp-18h]
  int size; // [esp+20h] [ebp-10h]
  int ecol; // [esp+24h] [ebp-Ch]
  int j; // [esp+28h] [ebp-8h]
  int i; // [esp+2Ch] [ebp-4h]

  ecol = col + cspan;
  size = t->maxcol + 1;
  for ( i = 0; i < size; ++i )
  {
    if ( !flags[i] || i >= col && i < ecol )
    {
      for ( j = i; j < size; ++j )
      {
        if ( !flags[j] || j >= col && j < ecol )
        {
          if ( i < col || i >= ecol || j < col || j >= ecol )
          {
            if ( (i < col || i >= ecol) && (j < col || j >= ecol) )
              ss_0 = s * s;
            else
              ss_0 = -(1.0 - s) * s;
          }
          else
          {
            ss_0 = (1.0 - s) * (1.0 - s);
          }
          t->matrix->me[j + i * t->matrix->dim] = t->matrix->me[j + i * t->matrix->dim] + (double)(1.0 / (b * b)) * ss_0;
        }
      }
    }
  }
}

//----- (080892E4) --------------------------------------------------------
void __cdecl set_table_matrix0(table *t, int maxwidth)
{
  void *v2; // esp
  void *v3; // esp
  int v4; // ebx
  __int16 v5; // ax
  __int16 v6; // ax
  __int16 v7; // ax
  long double v8; // fst6
  __int16 v9; // ax
  long double v10; // fst6
  _DWORD v11[11]; // [esp+0h] [ebp-E8h] BYREF
  int v12[4]; // [esp+2Ch] [ebp-BCh] BYREF
  int v13; // [esp+3Ch] [ebp-ACh]
  int v14; // [esp+40h] [ebp-A8h]
  int v15; // [esp+44h] [ebp-A4h]
  int v16; // [esp+48h] [ebp-A0h]
  int v17; // [esp+4Ch] [ebp-9Ch]
  int v18; // [esp+50h] [ebp-98h]
  int v19; // [esp+54h] [ebp-94h]
  int v20; // [esp+58h] [ebp-90h]
  _DWORD *v21; // [esp+5Ch] [ebp-8Ch]
  __int16 v22; // [esp+62h] [ebp-86h]
  int a; // [esp+64h] [ebp-84h]
  __int16 v24; // [esp+68h] [ebp-80h]
  __int16 v25; // [esp+6Ah] [ebp-7Eh]
  table *ta; // [esp+6Ch] [ebp-7Ch]
  double b; // [esp+70h] [ebp-78h]
  double s; // [esp+78h] [ebp-70h]
  double w; // [esp+80h] [ebp-68h]
  double w1; // [esp+88h] [ebp-60h]
  double w0; // [esp+90h] [ebp-58h]
  char (*p_expand)[]; // [esp+9Ch] [ebp-4Ch]
  int v33; // [esp+A0h] [ebp-48h]
  double (*p_we)[]; // [esp+A4h] [ebp-44h]
  int v35; // [esp+A8h] [ebp-40h]
  table_cell *cell; // [esp+ACh] [ebp-3Ch]
  int width; // [esp+B0h] [ebp-38h]
  int ecol; // [esp+B4h] [ebp-34h]
  int bcol; // [esp+B8h] [ebp-30h]
  int k; // [esp+BCh] [ebp-2Ch]
  int j; // [esp+C0h] [ebp-28h]
  int i; // [esp+C4h] [ebp-24h]
  int size; // [esp+C8h] [ebp-20h]
  unsigned int v44; // [esp+CCh] [ebp-1Ch]

  ta = t;
  v44 = __readgsdword(0x14u);
  v21 = v11;
  size = t->maxcol + 1;
  v20 = size;
  v35 = size - 1;
  v18 = size;
  v19 = 0;
  v16 = size << 6;
  v17 = ((unsigned __int64)(unsigned int)size >> 26) & 0xF;
  v2 = alloca(16 * ((unsigned int)(8 * size + 30) >> 4));
  p_we = (double (*)[])(16 * (((unsigned int)v12 + 3) >> 4));
  v33 = size - 1;
  v14 = size;
  v15 = 0;
  v12[3] = 8 * size;
  v13 = ((unsigned __int64)(unsigned int)size >> 29) & 0xF;
  v12[1] = size;
  v12[2] = 0;
  v11[10] = 8 * size;
  v12[0] = v13;
  v3 = alloca(16 * ((unsigned int)(size + 30) >> 4));
  p_expand = (char (*)[])p_we;
  cell = &t->cell;
  w0 = 0.0;
  for ( i = 0; i < size; ++i )
  {
    v4 = i;
    *((double *)p_we + v4) = weight(ta->tabwidth[i]);
    w0 = *((double *)p_we + i) + w0;
  }
  if ( w0 <= 0.0 )
    w0 = 1.0;
  if ( cell->necell )
  {
    bzero(p_expand, size);
    for ( k = 0; cell->necell > k; ++k )
    {
      j = cell->eindex[k];
      bcol = cell->col[j];
      ecol = bcol + cell->colspan[j];
      width = cell->width[j] + (1 - cell->colspan[j]) * ta->cellspacing;
      w1 = 0.0;
      for ( i = bcol; i < ecol; ++i )
      {
        v22 = ta->tabwidth[i];
        w1 = (long double)v22 + 0.1 + w1;
        ++*((_BYTE *)p_expand + i);
      }
      for ( i = bcol; i < ecol; ++i )
      {
        v22 = ta->tabwidth[i];
        LOBYTE(v6) = v25;
        HIBYTE(v6) = 12;
        v24 = v6;
        a = (int)((long double)width * ((long double)v22 + 0.1) / w1);
        w = weight(a);
        if ( w > (long double)*((double *)p_we + i) )
          *((double *)p_we + i) = w;
      }
    }
    w0 = 0.0;
    w1 = 0.0;
    for ( i = 0; i < size; ++i )
    {
      w0 = *((double *)p_we + i) + w0;
      if ( !*((_BYTE *)p_expand + i) )
        w1 = *((double *)p_we + i) + w1;
    }
    if ( w0 <= 0.0 )
      w0 = 1.0;
    for ( k = 0; cell->necell > k; ++k )
    {
      j = cell->eindex[k];
      bcol = cell->col[j];
      width = cell->width[j] + (1 - cell->colspan[j]) * ta->cellspacing;
      w = weight(width);
      s = w / (w1 + w);
      LOBYTE(v7) = v25;
      HIBYTE(v7) = 12;
      v24 = v7;
      a = (int)((long double)maxwidth * s);
      b = weight2(a) * 32.0;
      correct_table_matrix4(ta, bcol, cell->colspan[j], (char *)p_expand, s, b);
    }
    for ( i = 0; i < size; ++i )
    {
      if ( *((_BYTE *)p_expand + i) )
      {
        if ( w0 - w1 <= 1.0 )
          v10 = 1.0;
        else
          v10 = w0 - w1;
        s = *((double *)p_we + i) / v10;
        b = weight2(maxwidth) * 32.0;
      }
      else
      {
        if ( w1 <= 1.0 )
          v8 = 1.0;
        else
          v8 = w1;
        s = *((double *)p_we + i) / v8;
        LOBYTE(v9) = v25;
        HIBYTE(v9) = 12;
        v24 = v9;
        a = (int)((long double)maxwidth * s);
        b = weight2(a) * 32.0;
      }
      correct_table_matrix3(ta, i, (char *)p_expand, s, b);
    }
  }
  else
  {
    for ( i = 0; i < size; ++i )
    {
      s = *((double *)p_we + i) / w0;
      LOBYTE(v5) = v25;
      HIBYTE(v5) = 12;
      v24 = v5;
      a = (int)((long double)maxwidth * s);
      b = weight2(a) * 32.0;
      correct_table_matrix2(ta, i, 1, s, b);
    }
  }
}

//----- (080899B4) --------------------------------------------------------
void __cdecl check_relative_width(table *t, int maxwidth)
{
  double r_0; // [esp+28h] [ebp-50h]
  double r; // [esp+30h] [ebp-48h]
  double w; // [esp+38h] [ebp-40h]
  double rel_total; // [esp+40h] [ebp-38h]
  int j_0; // [esp+4Ch] [ebp-2Ch]
  int n_leftcell; // [esp+50h] [ebp-28h]
  int k; // [esp+54h] [ebp-24h]
  int j; // [esp+58h] [ebp-20h]
  int ja; // [esp+58h] [ebp-20h]
  int n_leftcol; // [esp+5Ch] [ebp-1Ch]
  table_cell *cell; // [esp+60h] [ebp-18h]
  double *rcolwidth; // [esp+64h] [ebp-14h]
  int size; // [esp+68h] [ebp-10h]
  int i; // [esp+6Ch] [ebp-Ch]
  int ia; // [esp+6Ch] [ebp-Ch]
  int ib; // [esp+6Ch] [ebp-Ch]
  int ic; // [esp+6Ch] [ebp-Ch]
  int id; // [esp+6Ch] [ebp-Ch]
  int ie; // [esp+6Ch] [ebp-Ch]
  int ig; // [esp+6Ch] [ebp-Ch]

  rel_total = 0.0;
  size = t->maxcol + 1;
  rcolwidth = (double *)GC_malloc(8 * size);
  cell = &t->cell;
  n_leftcol = 0;
  for ( i = 0; i < size; ++i )
    rcolwidth[i] = 0.0;
  for ( ia = 0; ia < size; ++ia )
  {
    if ( t->fixed_width[ia] >= 0 )
    {
      if ( t->fixed_width[ia] <= 0 )
        ++n_leftcol;
      else
        rcolwidth[ia] = (long double)t->fixed_width[ia] / (long double)maxwidth;
    }
    else
    {
      rcolwidth[ia] = (long double)t->fixed_width[ia] / -100.0;
    }
  }
  for ( ib = 0; t->cell.maxcell >= ib; ++ib )
  {
    if ( cell->fixed_width[ib] < 0 )
    {
      w = (long double)cell->fixed_width[ib] / -100.0;
      n_leftcell = 0;
      k = cell->col[ib];
      r = 0.0;
      for ( j = 0; cell->colspan[ib] > j; ++j )
      {
        if ( rcolwidth[j + k] <= 0.0 )
          ++n_leftcell;
        else
          r = rcolwidth[j + k] + r;
      }
      if ( n_leftcell )
      {
        if ( r >= (long double)w )
        {
          w = (long double)cell->colspan[ib] * r / (long double)(cell->colspan[ib] - n_leftcell);
          cell->fixed_width[ib] = (__int16)(w * -100.0);
        }
        for ( ja = 0; cell->colspan[ib] > ja; ++ja )
        {
          if ( rcolwidth[ja + k] == 0.0 )
            rcolwidth[ja + k] = (w - r) / (long double)n_leftcell;
        }
      }
      else if ( w != r )
      {
        cell->fixed_width[ib] = (__int16)(r * -100.0);
      }
    }
  }
  for ( ic = 0; ic < size; ++ic )
    rel_total = rcolwidth[ic] + rel_total;
  if ( !n_leftcol && rel_total < 0.9 || rel_total > 1.1 )
  {
    for ( id = 0; id < size; ++id )
      rcolwidth[id] = rcolwidth[id] / rel_total;
    for ( ie = 0; ie < size; ++ie )
    {
      if ( t->fixed_width[ie] < 0 )
        t->fixed_width[ie] = (__int16)(rcolwidth[ie] * -100.0);
    }
    for ( ig = 0; t->cell.maxcell >= ig; ++ig )
    {
      if ( cell->fixed_width[ig] < 0 )
      {
        r_0 = 0.0;
        for ( j_0 = 0; cell->colspan[ig] > j_0; ++j_0 )
          r_0 = rcolwidth[j_0 + cell->col[ig]] + r_0;
        cell->fixed_width[ig] = (__int16)(r_0 * -100.0);
      }
    }
  }
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (08089E51) --------------------------------------------------------
void __cdecl set_table_matrix(table *t, int width)
{
  __int16 v2; // ax
  long double v3; // fst7
  __int16 v4; // ax
  long double v5; // fst7
  long double v6; // fst7
  double s; // [esp+38h] [ebp-30h]
  double sa; // [esp+38h] [ebp-30h]
  double ba; // [esp+40h] [ebp-28h]
  double bb; // [esp+40h] [ebp-28h]
  double b; // [esp+40h] [ebp-28h]
  table_cell *cell; // [esp+4Ch] [ebp-1Ch]
  int a; // [esp+50h] [ebp-18h]
  int aa; // [esp+50h] [ebp-18h]
  int j; // [esp+54h] [ebp-14h]
  int ja; // [esp+54h] [ebp-14h]
  int i; // [esp+58h] [ebp-10h]
  int ia; // [esp+58h] [ebp-10h]
  int size; // [esp+5Ch] [ebp-Ch]

  size = t->maxcol + 1;
  cell = &t->cell;
  if ( size > 0 )
  {
    t->matrix = new_matrix(size);
    t->vector = new_vector(size);
    for ( i = 0; i < size; ++i )
    {
      for ( j = i; j < size; ++j )
        t->matrix->me[j + i * t->matrix->dim] = 0.0;
      t->vector->ve[i] = 0.0;
    }
    check_relative_width(t, width);
    for ( ia = 0; ia < size; ++ia )
    {
      if ( t->fixed_width[ia] <= 0 )
      {
        if ( t->fixed_width[ia] < 0 )
        {
          s = (long double)t->fixed_width[ia] / -100.0;
          ba = weight2((int)((long double)width * s)) * 0.5;
          correct_table_matrix2(t, ia, 1, s, ba);
        }
      }
      else
      {
        v2 = t->fixed_width[ia];
        if ( t->minimum_width[ia] >= v2 )
          v2 = t->minimum_width[ia];
        a = v2;
        v3 = weight2(v2);
        correct_table_matrix(t, ia, 1, a, v3 * 0.5);
      }
    }
    for ( ja = 0; t->cell.maxcell >= ja; ++ja )
    {
      if ( cell->fixed_width[ja] <= 0 )
      {
        if ( cell->fixed_width[ja] < 0 )
        {
          sa = (long double)cell->fixed_width[ja] / -100.0;
          bb = weight2((int)((long double)width * sa)) * 0.5;
          correct_table_matrix2(t, cell->col[ja], cell->colspan[ja], sa, bb);
        }
      }
      else
      {
        v4 = cell->fixed_width[ja];
        if ( cell->minimum_width[ja] >= v4 )
          v4 = cell->minimum_width[ja];
        aa = v4;
        v5 = weight2(v4);
        correct_table_matrix(t, cell->col[ja], cell->colspan[ja], aa, v5 * 0.5);
      }
    }
    set_table_matrix0(t, width);
    if ( t->total_width <= 0 )
    {
      v6 = weight2(width);
      b = v6 + v6;
    }
    else
    {
      b = weight2(width) * 0.25;
    }
    correct_table_matrix(t, 0, size, width, b);
  }
}

//----- (0808A210) --------------------------------------------------------
void writeLocalCookie()
{
  FILE *f; // [esp+1Ch] [ebp-Ch]

  if ( !no_rc_dir && !Local_cookie_file )
  {
    Local_cookie_file = tmpfname(4, 0)->ptr;
    set_environ("LOCAL_COOKIE_FILE", Local_cookie_file);
    f = fopen(Local_cookie_file, "wb");
    if ( f )
    {
      localCookie();
      fwrite(Local_cookie->ptr, 1u, Local_cookie->length, f);
      fclose(f);
      chmod(Local_cookie_file, 0x180u);
    }
  }
}

//----- (0808A2DB) --------------------------------------------------------
Str localCookie()
{
  int v1; // ebx
  time_t v2; // eax
  int v3; // eax
  char hostname[256]; // [esp+1Ch] [ebp-10Ch] BYREF
  unsigned int v5; // [esp+11Ch] [ebp-Ch]

  v5 = __readgsdword(0x14u);
  if ( !Local_cookie )
  {
    gethostname(hostname, 0x100u);
    v1 = GC_malloc(1);
    v2 = time(0);
    srand48(v1 + v2);
    v3 = lrand48();
    Local_cookie = Sprintf("%ld@%s", v3, hostname);
  }
  return Local_cookie;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (0808A37E) --------------------------------------------------------
Str __cdecl loadLocalDir(char *dname)
{
  int v2; // eax
  Str v3; // eax
  char *v4; // eax
  char *v5; // eax
  int v6; // eax
  char *v7; // eax
  char *v8; // eax
  int v9; // eax
  wc_ces v10; // esi
  wc_ces v11; // ebx
  _Str *v12; // eax
  Str v13; // eax
  char *v14; // eax
  int v15; // eax
  wc_ces v17; // esi
  wc_ces v18; // ebx
  _Str *v19; // eax
  Str v20; // eax
  char *v21; // eax
  int v22; // eax
  stat lst; // [esp+40h] [ebp-4F8h] BYREF
  stat st; // [esp+98h] [ebp-4A0h] BYREF
  Str dirname; // [esp+F0h] [ebp-448h]
  int nfile_max; // [esp+F4h] [ebp-444h]
  int nfile; // [esp+F8h] [ebp-440h]
  int maxlen; // [esp+FCh] [ebp-43Ch]
  int n; // [esp+100h] [ebp-438h]
  int nrow; // [esp+104h] [ebp-434h]
  int l; // [esp+108h] [ebp-430h]
  int i; // [esp+10Ch] [ebp-42Ch]
  Str fbuf; // [esp+110h] [ebp-428h]
  char *qdir; // [esp+114h] [ebp-424h]
  char *p; // [esp+118h] [ebp-420h]
  char **flist; // [esp+11Ch] [ebp-41Ch]
  Directory *dir; // [esp+120h] [ebp-418h]
  DIR *d; // [esp+124h] [ebp-414h]
  Str tmp; // [esp+128h] [ebp-410h]
  char lbuf[1024]; // [esp+12Ch] [ebp-40Ch] BYREF
  unsigned int v41; // [esp+52Ch] [ebp-Ch]

  v41 = __readgsdword(0x14u);
  fbuf = Strnew();
  nrow = 0;
  n = 0;
  maxlen = 0;
  nfile_max = 100;
  d = opendir(dname);
  if ( !d )
    return 0;
  dirname = Strnew_charp(dname);
  if ( dirname->length <= 0 || dirname->ptr[dirname->length - 1] != 47 )
  {
    if ( dirname->length + 1 >= dirname->area_size )
      Strgrow(dirname);
    v2 = dirname->length;
    dirname->ptr[v2] = 47;
    dirname->length = v2 + 1;
    dirname->ptr[dirname->length] = 0;
  }
  v3 = wc_Str_conv(dirname, SystemCharset, InnerCharset);
  qdir = html_quote(v3->ptr);
  v4 = file_quote(dirname->ptr);
  v5 = html_quote(v4);
  tmp = Strnew_m_charp(
          "<HTML>\n<HEAD>\n<BASE HREF=\"file://",
          v5,
          "\">\n<TITLE>Directory list of ",
          qdir,
          "</TITLE>\n</HEAD>\n<BODY>\n<H1>Directory list of ",
          qdir,
          "</H1>\n",
          0);
  flist = (char **)GC_malloc(4 * nfile_max);
  nfile = 0;
  while ( 1 )
  {
    dir = readdir(d);
    if ( !dir )
      break;
    flist[nfile++] = allocStr(dir->d_name, -1);
    if ( nfile == nfile_max )
    {
      nfile_max *= 2;
      flist = (char **)GC_realloc(flist, 4 * nfile_max);
    }
    if ( multicolList )
    {
      l = strlen(dir->d_name);
      if ( l > maxlen )
        maxlen = l;
      ++n;
    }
  }
  if ( multicolList )
  {
    l = COLS / (maxlen + 2);
    if ( !l )
      l = 1;
    nrow = (n + l - 1) / l;
    n = 1;
    Strcat_charp(tmp, "<TABLE CELLPADDING=0>\n<TR VALIGN=TOP>\n");
  }
  qsort(flist, nfile, 4u, strCmp);
  for ( i = 0; i < nfile; ++i )
  {
    p = flist[i];
    if ( strcmp(p, ".") )
    {
      Strcopy(fbuf, dirname);
      if ( fbuf->length <= 0 || fbuf->ptr[fbuf->length - 1] != 47 )
      {
        if ( fbuf->length + 1 >= fbuf->area_size )
          Strgrow(fbuf);
        v6 = fbuf->length;
        fbuf->ptr[v6] = 47;
        fbuf->length = v6 + 1;
        fbuf->ptr[fbuf->length] = 0;
      }
      Strcat_charp(fbuf, p);
      if ( lstat(fbuf->ptr, (int)&lst) >= 0 && stat_0(fbuf->ptr, (int)&st) >= 0 )
      {
        if ( multicolList )
        {
          if ( n == 1 )
            Strcat_charp(tmp, "<TD><NOBR>");
        }
        else if ( (lst.st_mode & 0xF000) == 40960 )
        {
          Strcat_charp(tmp, "[LINK] ");
        }
        else if ( (st.st_mode & 0xF000) == 0x4000 )
        {
          Strcat_charp(tmp, "[DIR]&nbsp; ");
        }
        else
        {
          Strcat_charp(tmp, "[FILE] ");
        }
        v7 = file_quote(p);
        v8 = html_quote(v7);
        Strcat_m_charp(tmp, "<A HREF=\"", v8, 0);
        if ( (st.st_mode & 0xF000) == 0x4000 )
        {
          if ( tmp->length + 1 >= tmp->area_size )
            Strgrow(tmp);
          v9 = tmp->length;
          tmp->ptr[v9] = 47;
          tmp->length = v9 + 1;
          tmp->ptr[tmp->length] = 0;
        }
        v10 = InnerCharset;
        v11 = SystemCharset;
        v12 = Strnew_charp(p);
        v13 = wc_Str_conv(v12, v11, v10);
        v14 = html_quote(v13->ptr);
        Strcat_m_charp(tmp, "\">", v14, 0);
        if ( (st.st_mode & 0xF000) == 0x4000 )
        {
          if ( tmp->length + 1 >= tmp->area_size )
            Strgrow(tmp);
          v15 = tmp->length;
          tmp->ptr[v15] = 47;
          tmp->length = v15 + 1;
          tmp->ptr[tmp->length] = 0;
        }
        Strcat_charp(tmp, "</A>");
        if ( multicolList )
        {
          if ( n++ == nrow )
          {
            Strcat_charp(tmp, "</NOBR></TD>\n");
            n = 1;
          }
          else
          {
            Strcat_charp(tmp, "<BR>\n");
          }
        }
        else
        {
          if ( (lst.st_mode & 0xF000) == 40960 )
          {
            l = readlink(fbuf->ptr, lbuf, 0x400u);
            if ( l > 0 )
            {
              lbuf[l] = 0;
              v17 = InnerCharset;
              v18 = SystemCharset;
              v19 = Strnew_charp(lbuf);
              v20 = wc_Str_conv(v19, v18, v17);
              v21 = html_quote(v20->ptr);
              Strcat_m_charp(tmp, " -> ", v21, 0);
              if ( (st.st_mode & 0xF000) == 0x4000 )
              {
                if ( tmp->length + 1 >= tmp->area_size )
                  Strgrow(tmp);
                v22 = tmp->length;
                tmp->ptr[v22] = 47;
                tmp->length = v22 + 1;
                tmp->ptr[tmp->length] = 0;
              }
            }
          }
          Strcat_charp(tmp, "<br>\n");
        }
      }
    }
  }
  if ( multicolList )
    Strcat_charp(tmp, "</TR>\n</TABLE>\n");
  Strcat_charp(tmp, "</BODY>\n</HTML>\n");
  return tmp;
}
// 8049E6C: using guessed type int __cdecl GC_realloc(_DWORD, _DWORD);
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (0808AC49) --------------------------------------------------------
int __cdecl check_local_cgi(char *file, int status)
{
  int result; // eax
  __uid_t v3; // ebx
  __gid_t v4; // ebx
  stat st; // [esp+18h] [ebp-60h] BYREF

  if ( status != 1 && status != 2 )
    return -1;
  if ( stat_0(file, (int)&st) < 0 )
    return -1;
  if ( (st.st_mode & 0xF000) == 0x4000 )
    return -1;
  v3 = st.st_uid;
  if ( v3 == geteuid() && (st.st_mode & 0x40) != 0
    || (v4 = st.st_gid, v4 == getegid()) && (st.st_mode & 8) != 0
    || (st.st_mode & 1) != 0 )
  {
    result = 0;
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (0808ACDE) --------------------------------------------------------
void __cdecl set_environ(char *var, char *value)
{
  if ( var )
  {
    if ( value )
      setenv(var, value, 1);
  }
}

//----- (0808AD0C) --------------------------------------------------------
void __cdecl set_cgi_environ(char *name, char *fn, char *req_uri)
{
  set_environ("SERVER_SOFTWARE", w3m_version);
  set_environ("SERVER_PROTOCOL", "HTTP/1.0");
  set_environ("SERVER_NAME", "localhost");
  set_environ("SERVER_PORT", "80");
  set_environ("REMOTE_HOST", "localhost");
  set_environ("REMOTE_ADDR", "127.0.0.1");
  set_environ("GATEWAY_INTERFACE", "CGI/1.1");
  set_environ("SCRIPT_NAME", name);
  set_environ("SCRIPT_FILENAME", fn);
  set_environ("REQUEST_URI", req_uri);
}

//----- (0808ADDA) --------------------------------------------------------
Str __cdecl checkPath(char *fn, char *path)
{
  char *v2; // eax
  char *v3; // eax
  int v4; // eax
  stat st; // [esp+10h] [ebp-68h] BYREF
  Str tmp; // [esp+68h] [ebp-10h]
  char *p; // [esp+6Ch] [ebp-Ch]

  while ( *path )
  {
    p = strchr(path, 58);
    if ( p )
      v2 = allocStr(path, p - path);
    else
      v2 = path;
    v3 = expandPath(v2);
    tmp = Strnew_charp(v3);
    if ( tmp->length <= 0 || tmp->ptr[tmp->length - 1] != 47 )
    {
      if ( tmp->length + 1 >= tmp->area_size )
        Strgrow(tmp);
      v4 = tmp->length;
      tmp->ptr[v4] = 47;
      tmp->length = v4 + 1;
      tmp->ptr[tmp->length] = 0;
    }
    Strcat_charp(tmp, fn);
    if ( !stat_0(tmp->ptr, (int)&st) )
      return tmp;
    if ( !p )
      break;
    for ( path = p + 1; *path == 58; ++path )
      ;
  }
  return 0;
}

//----- (0808AF07) --------------------------------------------------------
int __cdecl cgi_filename(char *uri, char **fn, char **name, char **path_info)
{
  int result; // eax
  char *v5; // eax
  int v6; // eax
  int v7; // eax
  Str tmp2; // [esp+14h] [ebp-14h]
  int offset; // [esp+18h] [ebp-10h]
  Str tmp; // [esp+1Ch] [ebp-Ch]
  Str tmpa; // [esp+1Ch] [ebp-Ch]

  *fn = uri;
  *name = uri;
  *path_info = 0;
  if ( cgi_bin && !strncmp(uri, "/cgi-bin/", 9u) )
  {
    *path_info = strchr(uri + 9, 47);
    if ( *path_info )
      *name = allocStr(uri, *path_info - uri);
    tmp = checkPath(*name + 9, cgi_bin);
    if ( tmp )
    {
      *fn = tmp->ptr;
      result = 2;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    v5 = w3m_lib_dir();
    tmpa = Strnew_charp(v5);
    if ( tmpa->length <= 0 || tmpa->ptr[tmpa->length - 1] != 47 )
    {
      if ( tmpa->length + 1 >= tmpa->area_size )
        Strgrow(tmpa);
      v6 = tmpa->length;
      tmpa->ptr[v6] = 47;
      tmpa->length = v6 + 1;
      tmpa->ptr[tmpa->length] = 0;
    }
    if ( !strncmp(uri, "/$LIB/", 6u) )
    {
      offset = 6;
    }
    else if ( !strncmp(uri, tmpa->ptr, tmpa->length) )
    {
      offset = tmpa->length;
    }
    else
    {
      if ( *uri != 47 || !document_root )
        return 0;
      tmp2 = Strnew_charp(document_root);
      if ( tmp2->length <= 0 || tmp2->ptr[tmp2->length - 1] != 47 )
      {
        if ( tmp2->length + 1 >= tmp2->area_size )
          Strgrow(tmp2);
        v7 = tmp2->length;
        tmp2->ptr[v7] = 47;
        tmp2->length = v7 + 1;
        tmp2->ptr[tmp2->length] = 0;
      }
      Strcat_charp(tmp2, uri + 1);
      if ( strncmp(tmp2->ptr, tmpa->ptr, tmpa->length) )
        return 0;
      uri = tmp2->ptr;
      *name = tmp2->ptr;
      offset = tmpa->length;
    }
    *path_info = strchr(&uri[offset], 47);
    if ( *path_info )
      *name = allocStr(uri, *path_info - uri);
    Strcat_charp(tmpa, &(*name)[offset]);
    *fn = tmpa->ptr;
    result = 1;
  }
  return result;
}

//----- (0808B234) --------------------------------------------------------
FILE *__cdecl localcgi_post(char *uri, char *qstr, FormList *request, char *referer)
{
  int v5; // eax
  Str v6; // eax
  Str v7; // eax
  char *v8; // eax
  char *v9; // eax
  char *v10; // eax
  int *v11; // eax
  char *v12; // ebx
  char *v13; // eax
  const char *tmpf; // [esp+20h] [ebp-28h]
  char *path_info; // [esp+24h] [ebp-24h] BYREF
  char *name; // [esp+28h] [ebp-20h] BYREF
  char *file; // [esp+2Ch] [ebp-1Ch] BYREF
  pid_t pid; // [esp+30h] [ebp-18h]
  int status; // [esp+34h] [ebp-14h]
  FILE *fw; // [esp+38h] [ebp-10h]
  FILE *fr; // [esp+3Ch] [ebp-Ch] BYREF

  fr = 0;
  fw = 0;
  file = uri;
  name = uri;
  path_info = 0;
  tmpf = 0;
  status = cgi_filename(uri, &file, &name, &path_info);
  if ( check_local_cgi(file, status) < 0 )
    return 0;
  writeLocalCookie();
  if ( request )
  {
    if ( request->enctype != 1 )
    {
      tmpf = tmpfname(0, 0)->ptr;
      fw = fopen(tmpf, "w");
      if ( !fw )
        return 0;
    }
  }
  pid = open_pipe_rw(&fr, 0);
  if ( pid < 0 )
    return 0;
  if ( !pid )
  {
    if ( fw )
      v5 = fileno(fw);
    else
      v5 = -1;
    setup_child(1, 2, v5);
    if ( qstr )
      uri = Strnew_m_charp(uri, "?", qstr, 0)->ptr;
    set_cgi_environ(name, file, uri);
    if ( path_info )
      set_environ("PATH_INFO", path_info);
    if ( referer && referer != (char *)-1 )
      set_environ("HTTP_REFERER", referer);
    if ( request )
    {
      set_environ("REQUEST_METHOD", "POST");
      if ( qstr )
        set_environ("QUERY_STRING", qstr);
      v6 = Sprintf("%d", request->length);
      set_environ("CONTENT_LENGTH", v6->ptr);
      if ( request->enctype == 1 )
      {
        v7 = Sprintf("multipart/form-data; boundary=%s", request->boundary);
        set_environ("CONTENT_TYPE", v7->ptr);
        freopen(request->body, "r", stdin);
      }
      else
      {
        set_environ("CONTENT_TYPE", "application/x-www-form-urlencoded");
        fwrite(request->body, 1u, request->length, fw);
        fclose(fw);
        freopen(tmpf, "r", stdin);
      }
    }
    else
    {
      set_environ("REQUEST_METHOD", "GET");
      if ( qstr )
        v8 = qstr;
      else
        v8 = (char *)&unk_80CB8E6;
      set_environ("QUERY_STRING", v8);
      freopen("/dev/null", "r", stdin);
    }
    v9 = mydirname(file);
    chdir(v9);
    v10 = mybasename(file);
    execl(file, v10, 0);
    v11 = __errno_location();
    v12 = strerror(*v11);
    v13 = mybasename(file);
    fprintf(stderr, "execl(\"%s\", \"%s\", NULL): %s\n", file, v13, v12);
    exit(1);
  }
  if ( fw )
    fclose(fw);
  return fr;
}

//----- (0808B5F0) --------------------------------------------------------
form_list *__cdecl newFormList(char *action, char *method, char *charset, char *enctype, char *target, char *name, form_list *_next)
{
  form_list *result; // eax
  wc_ces c; // [esp+1Ch] [ebp-1Ch]
  int e; // [esp+20h] [ebp-18h]
  int m; // [esp+24h] [ebp-14h]
  _Str *a; // [esp+28h] [ebp-10h]

  a = Strnew_charp(action);
  m = 0;
  e = 0;
  c = 0;
  if ( method && strcasecmp(method, "get") )
  {
    if ( !strcasecmp(method, "post") )
    {
      m = 1;
    }
    else if ( !strcasecmp(method, "internal") )
    {
      m = 2;
    }
  }
  else
  {
    m = 0;
  }
  if ( enctype )
  {
    if ( !strcasecmp(enctype, "multipart/form-data") )
    {
      e = 1;
      if ( !m )
        m = 1;
    }
  }
  if ( charset )
    c = wc_guess_charset(charset, 0);
  result = (form_list *)GC_malloc(52);
  result->lastitem = 0;
  result->item = result->lastitem;
  result->action = a;
  result->method = m;
  result->charset = c;
  result->enctype = e;
  result->target = target;
  result->name = name;
  result->next = _next;
  result->nitems = 0;
  result->body = 0;
  result->length = 0;
  return result;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (0808B750) --------------------------------------------------------
form_item_list *__cdecl formList_addInput(form_list *fl, parsed_tag *tag)
{
  int v3; // eax
  _Str *v4; // eax
  _Str *v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int i; // [esp+14h] [ebp-14h] BYREF
  char *p; // [esp+18h] [ebp-10h] BYREF
  form_item_list *item; // [esp+1Ch] [ebp-Ch]

  if ( !fl )
    return 0;
  item = (form_item_list *)GC_malloc(72);
  item->type = -1;
  item->size = -1;
  item->rows = 0;
  item->init_checked = 0;
  item->checked = item->init_checked;
  item->accept = 0;
  item->name = 0;
  item->init_value = 0;
  item->value = item->init_value;
  item->readonly = 0;
  if ( parsedtag_get_value(tag, 33, &p) )
  {
    v3 = formtype(p);
    item->type = v3;
    if ( item->size < 0 && (!item->type || item->type == 11 || item->type == 1) )
      item->size = 40;
  }
  if ( parsedtag_get_value(tag, 25, &p) )
  {
    v4 = Strnew_charp(p);
    item->name = v4;
  }
  if ( parsedtag_get_value(tag, 36, &p) )
  {
    v5 = Strnew_charp(p);
    item->init_value = v5;
    item->value = item->init_value;
  }
  v6 = tag->map && tag->map[12] != 75 && tag->attrid[tag->map[12]];
  item->init_checked = v6;
  item->checked = item->init_checked;
  v7 = tag->map && tag->map[1] != 75 && tag->attrid[tag->map[1]];
  item->accept = v7;
  parsedtag_get_value(tag, 30, &item->size);
  parsedtag_get_value(tag, 22, &item->maxlength);
  v8 = tag->map && tag->map[43] != 75 && tag->attrid[tag->map[43]];
  item->readonly = v8;
  if ( parsedtag_get_value(tag, 73, &i) )
  {
    item->init_value = textarea_str[i];
    item->value = item->init_value;
  }
  if ( parsedtag_get_value(tag, 72, &i) )
    item->select_option = select_option[i].first;
  if ( parsedtag_get_value(tag, 28, &p) )
  {
    v9 = atoi(p);
    item->rows = v9;
  }
  if ( item->type == -1 )
    return 0;
  if ( item->type == 8 )
  {
    chooseSelectOption(item, item->select_option);
    item->init_selected = item->selected;
    item->init_value = item->value;
    item->init_label = item->label;
  }
  if ( item->type == 11 && item->value && item->value->length )
    return 0;
  item->parent = fl;
  item->next = 0;
  if ( fl->item )
  {
    fl->lastitem->next = item;
    fl->lastitem = item;
  }
  else
  {
    fl->lastitem = item;
    fl->item = fl->lastitem;
  }
  if ( item->type == 6 )
    return 0;
  ++fl->nitems;
  return item;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (0808BB58) --------------------------------------------------------
char *__cdecl form2str(FormItemList *fi)
{
  _Str *tmp; // [esp+2Ch] [ebp-Ch]

  tmp = Strnew();
  if ( fi->type != 8 && fi->type != 9 )
    Strcat_charp(tmp, "input type=");
  Strcat_charp(tmp, formtypetbl[fi->type]);
  if ( fi->name && fi->name->length )
    Strcat_m_charp(tmp, " name=\"", fi->name->ptr, "\"", 0);
  if ( fi->type == 3 || fi->type == 2 || fi->type == 8 )
  {
    if ( fi->value )
      Strcat_m_charp(tmp, " value=\"", fi->value->ptr, "\"", 0);
  }
  Strcat_m_charp(tmp, " (", formmethodtbl[fi->parent->method], " ", fi->parent->action->ptr, ")", 0);
  return tmp->ptr;
}

//----- (0808BC9A) --------------------------------------------------------
int __cdecl formtype(char *typestr)
{
  int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; formtypetbl[i]; ++i )
  {
    if ( !strcasecmp(typestr, formtypetbl[i]) )
      return i;
  }
  return -1;
}

//----- (0808BCE4) --------------------------------------------------------
void __cdecl formRecheckRadio(Anchor *a, Buffer *buf, FormItemList *fi)
{
  FormItemList *f2; // [esp+14h] [ebp-14h]
  Anchor *a2; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; buf->formitem->nanchor > i; ++i )
  {
    a2 = &buf->formitem->anchors[i];
    f2 = (FormItemList *)a2->url;
    if ( (form_list *)*((_DWORD *)a2->url + 16) == fi->parent
      && f2 != fi
      && f2->type == 3
      && !strcmp(f2->name->ptr, fi->name->ptr) )
    {
      f2->checked = 0;
      formUpdateBuffer(a2, buf, f2);
    }
  }
  fi->checked = 1;
  formUpdateBuffer(a, buf, fi);
}

//----- (0808BDC2) --------------------------------------------------------
void __cdecl formResetBuffer(Buffer *buf, AnchorList *formitem)
{
  const char *v2; // edx
  const char *v3; // eax
  int v4; // eax
  char *f2; // [esp+10h] [ebp-18h]
  FormItemList *f1; // [esp+14h] [ebp-14h]
  Anchor *a; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]

  if ( buf && buf->formitem && formitem )
  {
    for ( i = 0; ; ++i )
    {
      if ( buf->formitem->nanchor <= i || formitem->nanchor <= i )
        return;
      a = &buf->formitem->anchors[i];
      if ( a->y == a->start.line )
      {
        f1 = (FormItemList *)a->url;
        f2 = formitem->anchors[i].url;
        if ( *(_DWORD *)a->url != *(_DWORD *)f2 )
          return;
        v2 = *((_DWORD *)f2 + 1) ? **((_DWORD **)f2 + 1) : &byte_80CB9EE;
        v3 = f1->name ? f1->name->ptr : &byte_80CB9EE;
        if ( strcmp(v3, v2) )
          return;
        if ( f1->type <= 0xBu )
        {
          v4 = 1 << f1->type;
          if ( (v4 & 0xA03) != 0 )
          {
            f1->value = (Str)*((_DWORD *)f2 + 2);
            f1->init_value = (Str)*((_DWORD *)f2 + 3);
LABEL_22:
            formUpdateBuffer(a, buf, f1);
            continue;
          }
          if ( (v4 & 0x100) != 0 )
          {
            f1->select_option = (FormSelectOptionItem *)*((_DWORD *)f2 + 11);
            f1->value = (Str)*((_DWORD *)f2 + 2);
            f1->label = (Str)*((_DWORD *)f2 + 12);
            f1->selected = *((_DWORD *)f2 + 14);
            f1->init_value = (Str)*((_DWORD *)f2 + 3);
            f1->init_label = (Str)*((_DWORD *)f2 + 13);
            f1->init_selected = *((_DWORD *)f2 + 15);
            goto LABEL_22;
          }
          if ( (v4 & 0xC) != 0 )
          {
            f1->checked = *((_DWORD *)f2 + 4);
            f1->init_checked = *((_DWORD *)f2 + 5);
            goto LABEL_22;
          }
        }
      }
    }
  }
}

//----- (0808BFC3) --------------------------------------------------------
int __cdecl form_update_line(Line *line, char **str, int spos, int epos, int width, int newline, int password)
{
  int v7; // eax
  Lineprop v8; // ax
  int v9; // eax
  char v10; // al
  __int16 v11; // ax
  Lineprop *prop; // [esp+18h] [ebp-30h]
  char *buf; // [esp+1Ch] [ebp-2Ch]
  char *p; // [esp+20h] [ebp-28h]
  char *pa; // [esp+20h] [ebp-28h]
  int pos; // [esp+24h] [ebp-24h]
  int posa; // [esp+24h] [ebp-24h]
  int len; // [esp+28h] [ebp-20h]
  int i; // [esp+2Ch] [ebp-1Ch]
  int ia; // [esp+2Ch] [ebp-1Ch]
  int w; // [esp+30h] [ebp-18h]
  int wa; // [esp+30h] [ebp-18h]
  int c_width; // [esp+34h] [ebp-14h]
  int c_len; // [esp+38h] [ebp-10h]
  int c_lena; // [esp+38h] [ebp-10h]
  Lineprop effect; // [esp+3Ch] [ebp-Ch]
  Lineprop c_type; // [esp+3Eh] [ebp-Ah]
  Lineprop c_typea; // [esp+3Eh] [ebp-Ah]

  p = *str;
  w = 0;
  pos = 0;
  while ( *p && w < width )
  {
    c_type = WTF_TYPE_MAP[(unsigned __int8)*p] << 8;
    c_len = WTF_LEN_MAP[(unsigned __int8)*p];
    if ( WcOption.use_wide )
      v7 = WTF_WIDTH_MAP[(unsigned __int8)*p];
    else
      v7 = WTF_WIDTH_MAP[(unsigned __int8)*p] != 0;
    if ( c_type == 256 )
    {
      if ( newline && *p == 10 )
        break;
      if ( *p != 13 )
      {
        ++w;
        ++pos;
      }
    }
    else if ( password )
    {
      if ( w + v7 > width )
        break;
      w += v7;
      pos += v7;
    }
    else if ( (c_type & 0x1000) != 0 )
    {
      ++w;
      ++pos;
    }
    else
    {
      if ( w + v7 > width )
        break;
      w += v7;
      pos += c_len;
    }
    p += c_len;
  }
  len = spos + width - w + pos + line->len - epos;
  buf = (char *)GC_malloc(len);
  prop = (Lineprop *)GC_malloc(2 * len);
  bcopy(line->lineBuf, buf, spos);
  bcopy(line->propBuf, prop, 2 * spos);
  v8 = line->propBuf[spos];
  HIBYTE(v8) &= 0xC0u;
  effect = v8;
  pa = *str;
  wa = 0;
  posa = spos;
  while ( *pa && wa < width )
  {
    c_typea = WTF_TYPE_MAP[(unsigned __int8)*pa] << 8;
    c_lena = WTF_LEN_MAP[(unsigned __int8)*pa];
    if ( WcOption.use_wide )
      v9 = WTF_WIDTH_MAP[(unsigned __int8)*pa];
    else
      v9 = WTF_WIDTH_MAP[(unsigned __int8)*pa] != 0;
    c_width = v9;
    if ( c_typea == 256 )
    {
      if ( newline && *pa == 10 )
        break;
      if ( *pa != 13 )
      {
        if ( password )
          v10 = 42;
        else
          v10 = 32;
        buf[posa] = v10;
        prop[posa++] = effect;
        ++wa;
      }
    }
    else if ( password )
    {
      if ( wa + v9 > width )
        break;
      for ( i = 0; i < v9; ++i )
      {
        buf[posa] = 42;
        prop[posa++] = effect;
        ++wa;
      }
    }
    else if ( (c_typea & 0x1000) != 0 )
    {
      buf[posa] = 32;
      prop[posa++] = effect;
      ++wa;
    }
    else
    {
      if ( wa + v9 > width )
        break;
      buf[posa] = *pa;
      prop[posa++] = effect | c_typea;
      LOBYTE(v11) = c_typea;
      for ( ia = 1; ia < c_lena; ++ia )
      {
        buf[posa] = pa[ia];
        HIBYTE(v11) = HIBYTE(c_typea) & 0xF9 | 4;
        prop[posa++] = effect | v11;
      }
      wa += c_width;
    }
    pa += c_lena;
  }
  while ( wa < width )
  {
    buf[posa] = 32;
    prop[posa++] = effect;
    ++wa;
  }
  if ( newline )
  {
    if ( !FoldTextarea )
    {
      while ( *pa && *pa != 13 && *pa != 10 )
        ++pa;
    }
    if ( *pa == 13 )
      ++pa;
    if ( *pa == 10 )
      ++pa;
  }
  *str = pa;
  bcopy(&line->lineBuf[epos], &buf[posa], line->len - epos);
  bcopy(&line->propBuf[epos], &prop[posa], 2 * (line->len - epos));
  line->lineBuf = buf;
  line->propBuf = prop;
  line->len = len;
  line->size = len;
  return posa;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (0808C4B8) --------------------------------------------------------
void __cdecl formUpdateBuffer(Anchor *a, Buffer *buf, FormItemList *form)
{
  int v3; // eax
  int v4; // eax
  int v5; // esi
  int v6; // ebx
  int v7; // eax
  Buffer save; // [esp+28h] [ebp-140h] BYREF
  int n; // [esp+12Ch] [ebp-3Ch]
  Line *l; // [esp+130h] [ebp-38h]
  int col; // [esp+134h] [ebp-34h]
  int pos; // [esp+138h] [ebp-30h]
  int c_rows; // [esp+13Ch] [ebp-2Ch]
  int rows; // [esp+140h] [ebp-28h]
  int epos; // [esp+144h] [ebp-24h]
  int spos; // [esp+148h] [ebp-20h]
  char *p; // [esp+14Ch] [ebp-1Ch] BYREF

  col = 0;
  copyBuffer(&save, buf);
  gotoLine(buf, a->start.line);
  if ( form->type <= 0xBu && ((1 << form->type) & 0xB0F) != 0 )
  {
    spos = a->start.pos;
    epos = a->end.pos;
  }
  else
  {
    spos = a->start.pos + 1;
    epos = a->end.pos - 1;
  }
  if ( form->type <= 0xBu )
  {
    v3 = 1 << form->type;
    if ( (v3 & 0xB03) != 0 )
    {
      if ( form->type == 8 )
      {
        p = form->label->ptr;
        updateSelectOption(form, form->select_option);
      }
      else
      {
        p = form->value->ptr;
      }
      l = buf->currentLine;
      if ( form->type != 9 )
        goto LABEL_41;
      n = a->y - buf->currentLine->linenumber;
      if ( n <= 0 )
      {
        if ( n < 0 )
        {
          while ( l && n )
          {
            l = l->prev;
            ++n;
          }
        }
      }
      else
      {
        while ( l && n )
        {
          l = l->prev;
          --n;
        }
      }
      if ( l )
      {
LABEL_41:
        if ( form->rows )
          v4 = form->rows;
        else
          v4 = 1;
        rows = v4;
        col = calcPosition(l->lineBuf, l->propBuf, l->len, a->start.pos, 0, 0);
        c_rows = 0;
        while ( c_rows < rows )
        {
          if ( rows > 1 )
          {
            pos = columnPos(l, col);
            a = retrieveAnchor(buf->formitem, l->linenumber, pos);
            if ( !a )
              break;
            spos = a->start.pos;
            epos = a->end.pos;
          }
          v5 = form->type == 1;
          v6 = rows > 1;
          v7 = calcPosition(l->lineBuf, l->propBuf, l->len, epos, 0, 0);
          pos = form_update_line(l, &p, spos, epos, v7 - col, v6, v5);
          if ( pos != epos )
          {
            shiftAnchorPosition(buf->href, buf->hmarklist, a->start.line, spos, pos - epos);
            shiftAnchorPosition(buf->name, buf->hmarklist, a->start.line, spos, pos - epos);
            shiftAnchorPosition(buf->img, buf->hmarklist, a->start.line, spos, pos - epos);
            shiftAnchorPosition(buf->formitem, buf->hmarklist, a->start.line, spos, pos - epos);
          }
          ++c_rows;
          l = l->next;
        }
      }
    }
    else if ( (v3 & 0xC) != 0 )
    {
      if ( form->checked )
        buf->currentLine->lineBuf[spos] = 42;
      else
        buf->currentLine->lineBuf[spos] = 32;
    }
  }
  copyBuffer(buf, &save);
  arrangeLine(buf);
}

//----- (0808C8CE) --------------------------------------------------------
Str __cdecl textfieldrep(Str s, int width)
{
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int c_len; // [esp+18h] [ebp-20h]
  int k; // [esp+1Ch] [ebp-1Ch]
  int j; // [esp+20h] [ebp-18h]
  int i; // [esp+24h] [ebp-14h]
  Str n; // [esp+28h] [ebp-10h]
  Lineprop c_type; // [esp+2Eh] [ebp-Ah]

  n = Strnew_size(width + 2);
  j = 0;
  for ( i = 0; s->length > i; i += c_len )
  {
    c_type = WTF_TYPE_MAP[(unsigned __int8)s->ptr[i]] << 8;
    c_len = WTF_LEN_MAP[(unsigned __int8)s->ptr[i]];
    if ( s->ptr[i] != 13 )
    {
      if ( WcOption.use_wide )
        v2 = WTF_WIDTH_MAP[(unsigned __int8)s->ptr[i]];
      else
        v2 = WTF_WIDTH_MAP[(unsigned __int8)s->ptr[i]] != 0;
      k = j + v2;
      if ( j + v2 > width )
        break;
      if ( c_type == 256 )
      {
        if ( n->length + 1 >= n->area_size )
          Strgrow(n);
        v3 = n->length;
        n->ptr[v3] = 32;
        n->length = v3 + 1;
        n->ptr[n->length] = 0;
      }
      else if ( (c_type & 0x1000) != 0 )
      {
        if ( n->length + 1 >= n->area_size )
          Strgrow(n);
        v4 = n->length;
        n->ptr[v4] = 32;
        n->length = v4 + 1;
        n->ptr[n->length] = 0;
      }
      else
      {
        switch ( s->ptr[i] )
        {
          case '&':
            Strcat_charp(n, "&amp;");
            break;
          case '<':
            Strcat_charp(n, "&lt;");
            break;
          case '>':
            Strcat_charp(n, "&gt;");
            break;
          default:
            Strcat_charp_n(n, &s->ptr[i], c_len);
            break;
        }
      }
      j = k;
    }
  }
  while ( j < width )
  {
    if ( n->length + 1 >= n->area_size )
      Strgrow(n);
    v5 = n->length;
    n->ptr[v5] = 32;
    n->length = v5 + 1;
    n->ptr[n->length] = 0;
    ++j;
  }
  return n;
}

//----- (0808CB78) --------------------------------------------------------
void __cdecl form_fputs_decode(Str s, FILE *f)
{
  int v2; // eax
  Str z; // [esp+18h] [ebp-10h]
  Str za; // [esp+18h] [ebp-10h]
  char *p; // [esp+1Ch] [ebp-Ch]

  z = Strnew();
  for ( p = s->ptr; *p; ++p )
  {
    if ( *p == 13 && p[1] == 10 )
      ++p;
    if ( z->length + 1 >= z->area_size )
      Strgrow(z);
    v2 = z->length;
    z->ptr[v2] = *p;
    z->length = v2 + 1;
    z->ptr[z->length] = 0;
  }
  za = wc_Str_conv_strict(z, InnerCharset, DisplayCharset);
  fwrite(za->ptr, 1u, za->length, f);
}

//----- (0808CC57) --------------------------------------------------------
void __cdecl input_textarea(FormItemList *fi)
{
  Str v1; // eax
  wc_ces charset; // [esp+2Ch] [ebp-1Ch] BYREF
  FILE *f; // [esp+30h] [ebp-18h]
  Str tmp; // [esp+34h] [ebp-14h]
  char *tmpf; // [esp+38h] [ebp-10h]
  wc_uint8 auto_detect; // [esp+3Fh] [ebp-9h]

  tmpf = tmpfname(0, 0)->ptr;
  charset = DisplayCharset;
  f = fopen(tmpf, "w");
  if ( f )
  {
    if ( fi->value )
      form_fputs_decode(fi->value, f);
    fclose(f);
    fmTerm();
    v1 = myEditor(Editor, tmpf, 1);
    system(v1->ptr);
    fmInit();
    if ( !fi->readonly )
    {
      f = fopen(tmpf, "r");
      if ( f )
      {
        fi->value = Strnew();
        auto_detect = WcOption.auto_detect;
        WcOption.auto_detect = 2;
        while ( 1 )
        {
          tmp = Strfgets(f);
          if ( tmp->length <= 0 )
            break;
          if ( tmp->length == 1 && tmp->ptr[tmp->length - 1] == 10 )
          {
            tmp = Strnew_charp("\r\n");
          }
          else if ( tmp->length > 1 && tmp->ptr[tmp->length - 1] == 10 && tmp->ptr[tmp->length - 2] != 13 )
          {
            Strshrink(tmp, 1);
            Strcat_charp(tmp, "\r\n");
          }
          tmp = convertLine(0, tmp, 0, &charset, DisplayCharset);
          savexmlstr_0(fi->value, tmp);
        }
        WcOption.auto_detect = auto_detect;
        fclose(f);
      }
      else
      {
        _ZN10bdInetAddrC2Ej("Can't open temporary file", 0);
      }
    }
    unlink(tmpf);
  }
  else
  {
    _ZN10bdInetAddrC2Ej("Can't open temporary file", 0);
  }
}

//----- (0808CE8B) --------------------------------------------------------
void __cdecl do_internal(char *action, char *data)
{
  void (*v2)(parsed_tagarg *); // ebx
  parsed_tagarg *v3; // eax
  int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; internal_action[i].action; ++i )
  {
    if ( !strcasecmp(internal_action[i].action, action) )
    {
      if ( internal_action[i].rout )
      {
        v2 = internal_action[i].rout;
        v3 = cgistr2tagarg(data);
        v2(v3);
      }
      return;
    }
  }
}

//----- (0808CEFD) --------------------------------------------------------
void __cdecl addSelectOption(FormSelectOption *fso, Str value, Str label, int chk)
{
  FormSelectOptionItem *o; // [esp+1Ch] [ebp-Ch]

  o = (FormSelectOptionItem *)GC_malloc(16);
  if ( !value )
    value = label;
  o->value = value;
  Strremovefirstspaces(label);
  Strremovetrailingspaces(label);
  o->label = label;
  o->checked = chk;
  o->next = 0;
  if ( fso->first )
  {
    fso->last->next = o;
    fso->last = o;
  }
  else
  {
    fso->last = o;
    fso->first = fso->last;
  }
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (0808CF8E) --------------------------------------------------------
void __cdecl chooseSelectOption(FormItemList *fi, FormSelectOptionItem *item)
{
  int i; // [esp+18h] [ebp-10h]
  FormSelectOptionItem *opt; // [esp+1Ch] [ebp-Ch]

  fi->selected = 0;
  if ( item )
  {
    fi->value = item->value;
    fi->label = item->label;
    i = 0;
    for ( opt = item; opt; opt = opt->next )
    {
      if ( opt->checked )
      {
        fi->value = opt->value;
        fi->label = opt->label;
        fi->selected = i;
        break;
      }
      ++i;
    }
    updateSelectOption(fi, item);
  }
  else
  {
    fi->value = Strnew_size(0);
    fi->label = Strnew_size(0);
  }
}

//----- (0808D043) --------------------------------------------------------
void __cdecl updateSelectOption(FormItemList *fi, FormSelectOptionItem *item)
{
  int i; // [esp+Ch] [ebp-4h]

  if ( fi && item )
  {
    i = 0;
    while ( item )
    {
      item->checked = fi->selected == i++;
      item = item->next;
    }
  }
}

//----- (0808D09A) --------------------------------------------------------
int __cdecl formChooseOptionByMenu(form_item_list *fi, int x, int y)
{
  char **label; // [esp+28h] [ebp-20h]
  FormSelectOptionItem *opt; // [esp+2Ch] [ebp-1Ch]
  FormSelectOptionItem *opta; // [esp+2Ch] [ebp-1Ch]
  FormSelectOptionItem *optb; // [esp+2Ch] [ebp-1Ch]
  int init_select; // [esp+30h] [ebp-18h]
  int selected; // [esp+34h] [ebp-14h] BYREF
  int n; // [esp+38h] [ebp-10h]
  int i; // [esp+3Ch] [ebp-Ch]

  selected = -1;
  init_select = fi->selected;
  n = 0;
  for ( opt = fi->select_option; opt; opt = opt->next )
    ++n;
  label = (char **)GC_malloc(4 * (n + 1));
  i = 0;
  for ( opta = fi->select_option; opta; opta = opta->next )
    label[i++] = opta->label->ptr;
  label[n] = 0;
  optionMenu(x, y, label, &selected, init_select, 0);
  if ( selected < 0 )
    return 0;
  i = 0;
  for ( optb = fi->select_option; optb; optb = optb->next )
  {
    if ( i == selected )
    {
      fi->selected = selected;
      fi->value = optb->value;
      fi->label = optb->label;
      break;
    }
    ++i;
  }
  updateSelectOption(fi, fi->select_option);
  return 1;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (0808D1D8) --------------------------------------------------------
void __cdecl form_write_data(FILE *f, char *boundary, char *name, char *value)
{
  fprintf(f, "--%s\r\n", boundary);
  fprintf(f, "Content-Disposition: form-data; name=\"%s\"\r\n\r\n", name);
  fprintf(f, "%s\r\n", value);
}

//----- (0808D231) --------------------------------------------------------
void __cdecl form_write_from_file(FILE *f, char *boundary, char *name, char *filename, char *file)
{
  char *v5; // eax
  char *v6; // [esp+Ch] [ebp-7Ch]
  stat st; // [esp+1Ch] [ebp-6Ch] BYREF
  char *type; // [esp+74h] [ebp-14h]
  int c; // [esp+78h] [ebp-10h]
  FILE *fd; // [esp+7Ch] [ebp-Ch]

  fprintf(f, "--%s\r\n", boundary);
  v6 = mybasename(filename);
  fprintf(f, "Content-Disposition: form-data; name=\"%s\"; filename=\"%s\"\r\n", name, v6);
  type = guessContentType(file);
  if ( type )
    v5 = type;
  else
    v5 = "application/octet-stream";
  fprintf(f, "Content-Type: %s\r\n\r\n", v5);
  if ( lstat(file, (int)&st) >= 0 && (st.st_mode & 0xF000) != 0x4000 )
  {
    fd = fopen(file, "r");
    if ( fd )
    {
      while ( 1 )
      {
        c = fgetc(fd);
        if ( c == -1 )
          break;
        fputc(c, f);
      }
      fclose(fd);
    }
  }
  fwrite("\r\n", 1u, 2u, f);
}

//----- (0808D356) --------------------------------------------------------
pre_form *__cdecl add_pre_form(pre_form *prev, char *url, char *name, char *action)
{
  Str v4; // eax
  char *v5; // eax
  char *v6; // eax
  ParsedURL pu; // [esp+10h] [ebp-38h] BYREF
  int l; // [esp+38h] [ebp-10h]
  pre_form *newa; // [esp+3Ch] [ebp-Ch]

  if ( prev )
  {
    prev->next = (pre_form *)GC_malloc(24);
    newa = prev->next;
  }
  else
  {
    PreForm = (pre_form *)GC_malloc(24);
    newa = PreForm;
  }
  if ( url && *url == 47 )
  {
    l = strlen(url);
    if ( l > 1 && url[l - 1] == 47 )
      newa->url = allocStr(url + 1, l - 2);
    else
      newa->url = url + 1;
    newa->re_url = newRegex(newa->url, 0, 0, 0);
    if ( !newa->re_url )
      newa->url = 0;
  }
  else if ( url )
  {
    parseURL2(url, &pu, 0);
    v4 = parsedURL2Str(&pu);
    newa->url = v4->ptr;
    newa->re_url = 0;
  }
  if ( name && *name )
    v5 = name;
  else
    v5 = 0;
  newa->name = v5;
  if ( action && *action )
    v6 = action;
  else
    v6 = 0;
  newa->action = v6;
  newa->item = 0;
  newa->next = 0;
  return newa;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (0808D4D8) --------------------------------------------------------
pre_form_item *__cdecl add_pre_form_item(pre_form *pf_0, pre_form_item *prev, int type, char *name, char *value, char *checked)
{
  pre_form_item *newa; // [esp+1Ch] [ebp-Ch]

  if ( !pf_0 )
    return 0;
  if ( prev )
  {
    prev->next = (pre_form_item *)GC_malloc(20);
    newa = prev->next;
  }
  else
  {
    pf_0->item = (pre_form_item *)GC_malloc(20);
    newa = pf_0->item;
  }
  newa->type = type;
  newa->name = name;
  newa->value = value;
  newa->checked = !checked
               || !*checked
               || strcmp(checked, "0") && !strcasecmp(checked, "off") && strcasecmp(checked, "no");
  newa->next = 0;
  return newa;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (0808D5C4) --------------------------------------------------------
void loadPreForm()
{
  char *v0; // eax
  char *v1; // eax
  pre_form *prev; // [esp+24h] [ebp-34h]
  char *arg; // [esp+28h] [ebp-30h]
  const char *s; // [esp+2Ch] [ebp-2Ch]
  char *sa; // [esp+2Ch] [ebp-2Ch]
  char *sb; // [esp+2Ch] [ebp-2Ch]
  char *p; // [esp+30h] [ebp-28h] BYREF
  char *name; // [esp+34h] [ebp-24h]
  int type; // [esp+38h] [ebp-20h]
  pre_form_item *pi; // [esp+3Ch] [ebp-1Ch]
  pre_form *pf_0; // [esp+40h] [ebp-18h]
  Str textarea; // [esp+44h] [ebp-14h]
  Str line; // [esp+48h] [ebp-10h]
  FILE *fp; // [esp+4Ch] [ebp-Ch]

  line = 0;
  textarea = 0;
  pf_0 = 0;
  pi = 0;
  type = -1;
  name = 0;
  PreForm = 0;
  fp = openSecretFile(pre_form_file);
  if ( fp )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        do
        {
          while ( 1 )
          {
            do
            {
              while ( 1 )
              {
                line = Strfgets(fp);
                if ( !line->length )
                {
                  fclose(fp);
                  return;
                }
                if ( !textarea
                  || !strncmp(line->ptr, "/textarea", 9u) && (MYCTYPE_MAP[*((unsigned __int8 *)line->ptr + 9)] & 2) != 0 )
                {
                  break;
                }
                savexmlstr_0(textarea, line);
              }
              Strchop(line);
              Strremovefirstspaces(line);
              p = line->ptr;
            }
            while ( *p == 35 || !*p );
            s = getWord(&p);
            arg = getWord(&p);
            if ( strcmp(s, "url") )
              break;
            if ( arg )
            {
              if ( *arg )
              {
                p = getQWord(&p);
                pf_0 = add_pre_form(pf_0, arg, 0, p);
                pi = pf_0->item;
              }
            }
          }
        }
        while ( !pf_0 );
        if ( strcmp(s, "form") )
          break;
        if ( arg && *arg )
        {
          sa = getQWord(&p);
          p = getQWord(&p);
          if ( !p || !*p )
          {
            p = sa;
            sa = 0;
          }
          if ( pf_0->item )
          {
            prev = pf_0;
            pf_0 = add_pre_form(pf_0, (char *)&byte_80CB9EE, sa, p);
            pf_0->url = prev->url;
            pf_0->re_url = prev->re_url;
          }
          else
          {
            pf_0->name = sa;
            if ( p && *p )
              v0 = p;
            else
              v0 = 0;
            pf_0->action = v0;
          }
          pi = pf_0->item;
        }
      }
      if ( !strcmp(s, "text") )
      {
        type = 0;
        goto LABEL_56;
      }
      if ( !strcmp(s, "file") )
      {
        type = 11;
        goto LABEL_56;
      }
      if ( !strcmp(s, "passwd") || !strcmp(s, "password") )
      {
        type = 1;
        goto LABEL_56;
      }
      if ( !strcmp(s, "checkbox") )
      {
        type = 2;
        goto LABEL_56;
      }
      if ( !strcmp(s, "radio") )
      {
        type = 3;
        goto LABEL_56;
      }
      if ( !strcmp(s, "submit") )
      {
        type = 4;
        goto LABEL_56;
      }
      if ( !strcmp(s, "image") )
        break;
      if ( !strcmp(s, "select") )
      {
        type = 8;
LABEL_56:
        sb = getQWord(&p);
        v1 = getQWord(&p);
        pi = add_pre_form_item(pf_0, pi, type, arg, sb, v1);
      }
      else if ( !strcmp(s, "textarea") )
      {
        type = 9;
        name = Strnew_charp(arg)->ptr;
        textarea = Strnew();
      }
      else if ( textarea && name && !strcmp(s, "/textarea") )
      {
        pi = add_pre_form_item(pf_0, pi, type, name, textarea->ptr, 0);
        textarea = 0;
        name = 0;
      }
    }
    type = 7;
    goto LABEL_56;
  }
}

//----- (0808DA7C) --------------------------------------------------------
void __cdecl preFormUpdateBuffer(Buffer *buf)
{
  const char *v1; // ebx
  Str v2; // eax
  Str url; // [esp+1Ch] [ebp-2Ch]
  int j; // [esp+20h] [ebp-28h]
  FormSelectOptionItem *opt; // [esp+24h] [ebp-24h]
  FormItemList *fi; // [esp+28h] [ebp-20h]
  FormList *fl; // [esp+2Ch] [ebp-1Ch]
  Anchor *a; // [esp+30h] [ebp-18h]
  int i; // [esp+34h] [ebp-14h]
  pre_form_item *pi; // [esp+38h] [ebp-10h]
  pre_form *pf_0; // [esp+3Ch] [ebp-Ch]

  if ( buf && buf->formitem && PreForm )
  {
    for ( pf_0 = PreForm; ; pf_0 = pf_0->next )
    {
      if ( !pf_0 )
        return;
      if ( pf_0->re_url )
      {
        url = parsedURL2Str(&buf->currentURL);
        if ( !RegexMatch(pf_0->re_url, url->ptr, url->length, 1) )
          continue;
      }
      else
      {
        if ( !pf_0->url )
          continue;
        v1 = pf_0->url;
        v2 = parsedURL2Str(&buf->currentURL);
        if ( strcmp(v2->ptr, v1) )
          continue;
      }
      for ( i = 0; buf->formitem->nanchor > i; ++i )
      {
        a = &buf->formitem->anchors[i];
        fi = (FormItemList *)a->url;
        fl = (FormList *)*((_DWORD *)a->url + 16);
        if ( (!pf_0->name || fl->name && !strcmp(fl->name, pf_0->name))
          && (!pf_0->action || fl->action && !strcmp(fl->action->ptr, pf_0->action)) )
        {
          for ( pi = pf_0->item; pi; pi = pi->next )
          {
            if ( pi->type == fi->type )
            {
              if ( pi->type == 4 || pi->type == 7 )
              {
                if ( (!pi->name || !*pi->name || fi->name && !strcmp(fi->name->ptr, pi->name))
                  && (!pi->value || !*pi->value || fi->value && !strcmp(fi->value->ptr, pi->value)) )
                {
                  buf->submit = a;
                }
              }
              else if ( pi->name && fi->name && !strcmp(fi->name->ptr, pi->name) )
              {
                switch ( pi->type )
                {
                  case 0:
                  case 1:
                  case 9:
                  case 0xB:
                    fi->value = Strnew_charp(pi->value);
                    formUpdateBuffer(a, buf, fi);
                    break;
                  case 2:
                    if ( pi->value && fi->value && !strcmp(fi->value->ptr, pi->value) )
                    {
                      fi->checked = pi->checked;
                      formUpdateBuffer(a, buf, fi);
                    }
                    break;
                  case 3:
                    if ( pi->value && fi->value && !strcmp(fi->value->ptr, pi->value) )
                      formRecheckRadio(a, buf, fi);
                    break;
                  case 8:
                    j = 0;
                    for ( opt = fi->select_option; opt; opt = opt->next )
                    {
                      if ( pi->value && opt->value && !strcmp(opt->value->ptr, pi->value) )
                      {
                        fi->selected = j;
                        fi->value = opt->value;
                        fi->label = opt->label;
                        updateSelectOption(fi, fi->select_option);
                        formUpdateBuffer(a, buf, fi);
                        goto LABEL_50;
                      }
                      ++j;
                    }
                    break;
                  default:
                    continue;
                }
              }
            }
LABEL_50:
            ;
          }
        }
      }
    }
  }
}

//----- (0808DF40) --------------------------------------------------------
MapList *__cdecl searchMapList(Buffer *buf, char *name)
{
  MapList *ml; // [esp+1Ch] [ebp-Ch]

  if ( !name )
    return 0;
  for ( ml = buf->maplist; ml && strcmp(ml->name->ptr, name); ml = ml->next )
    ;
  return ml;
}

//----- (0808DF8F) --------------------------------------------------------
int __cdecl inMapArea(MapArea *a, int x, int y)
{
  int v4; // eax
  double t; // [esp+20h] [ebp-38h]
  double r2; // [esp+38h] [ebp-20h]
  double r1; // [esp+40h] [ebp-18h]
  int i; // [esp+4Ch] [ebp-Ch]

  if ( !a )
    return 0;
  v4 = a->shape;
  if ( v4 == 2 )
  {
    if ( *a->coords <= x && a->coords[1] <= y && a->coords[2] >= x && a->coords[3] >= y )
      return 1;
  }
  else if ( v4 > 2 )
  {
    if ( v4 == 3 )
    {
      if ( (x - *a->coords) * (x - *a->coords) + (y - a->coords[1]) * (y - a->coords[1]) <= a->coords[2] * a->coords[2] )
        return 1;
    }
    else if ( v4 == 4 )
    {
      t = 0.0;
      for ( i = 0; a->ncoords > i; i += 2 )
      {
        r1 = sqrt(
               (long double)(x - a->coords[i]) * (long double)(x - a->coords[i])
             + (long double)(y - a->coords[i + 1]) * (long double)(y - a->coords[i + 1]));
        r2 = sqrt(
               (long double)(x - a->coords[i + 2]) * (long double)(x - a->coords[i + 2])
             + (long double)(y - a->coords[i + 3]) * (long double)(y - a->coords[i + 3]));
        if ( r1 == 0.0 || r2 == 0.0 )
          return 1;
        t = atan2(
              ((long double)(x - a->coords[i]) * (long double)(y - a->coords[i + 3])
             - (long double)(x - a->coords[i + 2]) * (long double)(y - a->coords[i + 1]))
            / r1
            / r2,
              ((long double)(x - a->coords[i]) * (long double)(x - a->coords[i + 2])
             + (long double)(y - a->coords[i + 1]) * (long double)(y - a->coords[i + 3]))
            / r1
            / r2)
          + t;
      }
      if ( fabs(t) > 6.28 )
        return 1;
    }
  }
  else if ( v4 == 1 )
  {
    return 1;
  }
  return 0;
}

//----- (0808E3E5) --------------------------------------------------------
int __cdecl nearestMapArea(MapList *ml, int x, int y)
{
  int min; // [esp+Ch] [ebp-18h]
  int n; // [esp+10h] [ebp-14h]
  int l; // [esp+14h] [ebp-10h]
  int i; // [esp+18h] [ebp-Ch]
  MapArea *a; // [esp+1Ch] [ebp-8h]
  ListItem *al_0; // [esp+20h] [ebp-4h]

  n = -1;
  min = -1;
  if ( !ml || !ml->area )
    return -1;
  i = 0;
  for ( al_0 = ml->area->first; al_0; al_0 = al_0->next )
  {
    a = (MapArea *)al_0->ptr;
    if ( al_0->ptr )
    {
      l = (a->center_x - x) * (a->center_x - x) + (a->center_y - y) * (a->center_y - y);
      if ( (min < 0 || l < min) && l < (int)(pixel_per_char * pixel_per_char + pixel_per_line * pixel_per_line) )
      {
        n = i;
        min = (a->center_x - x) * (a->center_x - x) + (a->center_y - y) * (a->center_y - y);
      }
    }
    ++i;
  }
  return n;
}

//----- (0808E4DD) --------------------------------------------------------
int __cdecl searchMapArea(Buffer *buf, MapList *ml, Anchor *a_img)
{
  int py; // [esp+18h] [ebp-20h] BYREF
  int px; // [esp+1Ch] [ebp-1Ch] BYREF
  int n; // [esp+20h] [ebp-18h]
  int i; // [esp+24h] [ebp-14h]
  MapArea *a; // [esp+28h] [ebp-10h]
  ListItem *al_0; // [esp+2Ch] [ebp-Ch]

  if ( !ml || !ml->area || !ml->area->nitem )
    return -1;
  if ( !getMapXY(buf, a_img, &px, &py) )
    return -1;
  n = -ml->area->nitem;
  i = 0;
  for ( al_0 = ml->area->first; al_0; al_0 = al_0->next )
  {
    a = (MapArea *)al_0->ptr;
    if ( a && n < 0 && inMapArea(a, px, py) )
    {
      if ( a->shape == 1 )
      {
        if ( -ml->area->nitem == n )
          n = -i;
      }
      else
      {
        n = i;
      }
    }
    ++i;
  }
  if ( -ml->area->nitem == n )
    return nearestMapArea(ml, px, py);
  if ( n >= 0 )
    return n;
  return -n;
}

//----- (0808E611) --------------------------------------------------------
MapArea *__cdecl retrieveCurrentMapArea(Buffer *buf)
{
  char *v2; // eax
  int n; // [esp+10h] [ebp-28h]
  int i; // [esp+14h] [ebp-24h]
  ListItem *al_0; // [esp+1Ch] [ebp-1Ch]
  MapList *ml; // [esp+20h] [ebp-18h]
  FormItemList *fi; // [esp+24h] [ebp-14h]
  FormItemList *fia; // [esp+24h] [ebp-14h]
  Anchor *a_form; // [esp+28h] [ebp-10h]
  Anchor *a_img; // [esp+2Ch] [ebp-Ch]

  a_img = retrieveCurrentImg(buf);
  if ( !a_img || !a_img->image || !a_img->image->map )
    return 0;
  a_form = retrieveCurrentForm(buf);
  if ( !a_form || !a_form->url )
    return 0;
  fi = (FormItemList *)a_form->url;
  if ( !a_form->url || !fi->parent || !fi->parent->item )
    return 0;
  fia = fi->parent->item;
  if ( fia->value )
    v2 = fia->value->ptr;
  else
    v2 = 0;
  ml = searchMapList(buf, v2);
  if ( !ml )
    return 0;
  n = searchMapArea(buf, ml, a_img);
  if ( n < 0 )
    return 0;
  i = 0;
  for ( al_0 = ml->area->first; al_0; al_0 = al_0->next )
  {
    if ( al_0->ptr && i == n )
      return (MapArea *)al_0->ptr;
    ++i;
  }
  return 0;
}

//----- (0808E756) --------------------------------------------------------
int __cdecl getMapXY(Buffer *buf, Anchor *a, int *x, int *y)
{
  int v5; // esi

  if ( !buf || !a || !a->image || !x || !y )
    return 0;
  v5 = buf->currentColumn + buf->cursorX;
  *x = (int)(((long double)(v5
                          - calcPosition(
                              buf->currentLine->lineBuf,
                              buf->currentLine->propBuf,
                              buf->currentLine->len,
                              a->start.pos,
                              0,
                              0))
            + 0.5)
           * pixel_per_char)
     - a->image->xoffset;
  *y = (int)(((long double)(buf->currentLine->linenumber - a->image->y) + 0.5) * pixel_per_line) - a->image->yoffset;
  if ( *x <= 0 )
    *x = 1;
  if ( *y <= 0 )
    *y = 1;
  return 1;
}

//----- (0808E8A4) --------------------------------------------------------
Anchor *__cdecl retrieveCurrentMap(Buffer *buf)
{
  Anchor *a; // [esp+1Ch] [ebp-Ch]

  a = retrieveCurrentForm(buf);
  if ( !a || !a->url )
    return 0;
  if ( *(_DWORD *)(*((_DWORD *)a->url + 16) + 8) == 2
    && !strcmp(**(const char ***)(*((_DWORD *)a->url + 16) + 12), "map") )
  {
    return a;
  }
  return 0;
}

//----- (0808E90F) --------------------------------------------------------
MapArea *__cdecl follow_map_menu(Buffer *buf, char *name, Anchor *a_img, int x, int y)
{
  char *v6; // eax
  char **label; // [esp+24h] [ebp-24h]
  MapArea *a; // [esp+28h] [ebp-20h]
  int initial; // [esp+2Ch] [ebp-1Ch]
  int selected; // [esp+30h] [ebp-18h] BYREF
  int i; // [esp+34h] [ebp-14h]
  ListItem *al_0; // [esp+38h] [ebp-10h]
  MapList *ml; // [esp+3Ch] [ebp-Ch]

  selected = -1;
  ml = searchMapList(buf, name);
  if ( !ml || !ml->area || !ml->area->nitem )
    return 0;
  initial = searchMapArea(buf, ml, a_img);
  if ( initial < 0 )
  {
    initial = 0;
    goto LABEL_9;
  }
  if ( image_map_list )
  {
LABEL_9:
    label = (char **)GC_malloc(4 * (ml->area->nitem + 1));
    i = 0;
    for ( al_0 = ml->area->first; al_0; al_0 = al_0->next )
    {
      a = (MapArea *)al_0->ptr;
      if ( al_0->ptr )
      {
        if ( *a->alt )
          v6 = a->alt;
        else
          v6 = a->url;
        label[i] = v6;
      }
      else
      {
        label[i] = (char *)&unk_80CBB1C;
      }
      ++i;
    }
    label[ml->area->nitem] = 0;
    optionMenu(x, y, label, &selected, initial, 0);
    goto map_end;
  }
  selected = initial;
map_end:
  if ( selected >= 0 )
  {
    i = 0;
    for ( al_0 = ml->area->first; al_0; al_0 = al_0->next )
    {
      if ( al_0->ptr && i == selected )
        return (MapArea *)al_0->ptr;
      ++i;
    }
  }
  return 0;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (0808EABC) --------------------------------------------------------
MapArea *__cdecl newMapArea(char *url, char *target, char *alt, char *shape, char *coords)
{
  char *v5; // eax
  MapArea *result; // eax
  int v7; // eax
  __int16 *v8; // ebx
  int max; // [esp+10h] [ebp-18h]
  int i; // [esp+14h] [ebp-14h]
  int ia; // [esp+14h] [ebp-14h]
  char *p; // [esp+18h] [ebp-10h]
  MapArea *a; // [esp+1Ch] [ebp-Ch]

  a = (MapArea *)GC_malloc(28);
  a->url = url;
  a->target = target;
  if ( alt )
    v5 = alt;
  else
    v5 = (char *)&unk_80CBB1C;
  a->alt = v5;
  a->shape = 2;
  if ( shape )
  {
    if ( !strcasecmp(shape, "default") )
    {
      a->shape = 1;
    }
    else if ( !strncasecmp(shape, "rect", 4u) )
    {
      a->shape = 2;
    }
    else if ( !strncasecmp(shape, "circ", 4u) )
    {
      a->shape = 3;
    }
    else if ( !strncasecmp(shape, "poly", 4u) )
    {
      a->shape = 4;
    }
    else
    {
      a->shape = 0;
    }
  }
  a->coords = 0;
  a->ncoords = 0;
  a->center_x = 0;
  a->center_y = 0;
  if ( !a->shape || a->shape == 1 )
    return a;
  if ( coords )
  {
    if ( a->shape == 2 )
    {
      a->coords = (__int16 *)GC_malloc(8);
      a->ncoords = 4;
    }
    else if ( a->shape == 3 )
    {
      a->coords = (__int16 *)GC_malloc(6);
      a->ncoords = 3;
    }
    max = a->ncoords;
    i = 0;
    p = coords;
    while ( a->shape == 4 || a->ncoords > i )
    {
      if ( !*p )
        break;
      while ( (MYCTYPE_MAP[(unsigned __int8)*p] & 2) != 0 )
        ++p;
      if ( (MYCTYPE_MAP[(unsigned __int8)*p] & 8) == 0 && *p != 45 && *p != 43 )
        break;
      if ( a->shape == 4 )
      {
        if ( max <= i )
        {
          if ( i )
            v7 = 2 * i;
          else
            v7 = 6;
          max = v7;
          a->coords = (__int16 *)GC_realloc(a->coords, 2 * (v7 + 2));
        }
        ++a->ncoords;
      }
      v8 = &a->coords[i];
      *v8 = atoi(p);
      ++i;
      if ( *p == 45 || *p == 43 )
        ++p;
      while ( (MYCTYPE_MAP[(unsigned __int8)*p] & 8) != 0 )
        ++p;
      if ( *p != 44 && (MYCTYPE_MAP[(unsigned __int8)*p] & 2) == 0 )
        break;
      while ( (MYCTYPE_MAP[(unsigned __int8)*p] & 2) != 0 )
        ++p;
      if ( *p == 44 )
        ++p;
    }
    if ( a->ncoords == i && (a->shape != 4 || a->ncoords > 5) )
    {
      if ( a->shape == 4 )
      {
        a->ncoords = 2 * (a->ncoords / 2);
        a->coords[a->ncoords] = *a->coords;
        a->coords[a->ncoords + 1] = a->coords[1];
      }
      if ( a->shape == 3 )
      {
        a->center_x = *a->coords;
        a->center_y = a->coords[1];
      }
      else
      {
        for ( ia = 0; a->ncoords / 2 > ia; ++ia )
        {
          a->center_x += a->coords[2 * ia];
          a->center_y += a->coords[2 * ia + 1];
        }
        a->center_x /= a->ncoords / 2;
        a->center_y /= a->ncoords / 2;
      }
      result = a;
    }
    else
    {
      a->shape = 0;
      a->coords = 0;
      a->ncoords = 0;
      result = a;
    }
  }
  else
  {
    a->shape = 0;
    result = a;
  }
  return result;
}
// 8049E6C: using guessed type int __cdecl GC_realloc(_DWORD, _DWORD);
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (0808EFA6) --------------------------------------------------------
void __cdecl append_map_info(Buffer *buf, Str tmp, FormItemList *fi)
{
  char *v3; // eax
  ParsedURL *v4; // eax
  Str v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // [esp+10h] [ebp-68h]
  ParsedURL pu; // [esp+34h] [ebp-44h] BYREF
  char *q; // [esp+5Ch] [ebp-1Ch]
  char *p; // [esp+60h] [ebp-18h]
  MapArea *a; // [esp+64h] [ebp-14h]
  ListItem *al_0; // [esp+68h] [ebp-10h]
  MapList *ml; // [esp+6Ch] [ebp-Ch]

  if ( fi->value )
    v3 = fi->value->ptr;
  else
    v3 = 0;
  ml = searchMapList(buf, v3);
  if ( ml )
  {
    Strcat_m_charp(
      tmp,
      "<tr valign=top><td colspan=2>Links of current image map",
      "<tr valign=top><td colspan=2><table>",
      0);
    for ( al_0 = ml->area->first; al_0; al_0 = al_0->next )
    {
      a = (MapArea *)al_0->ptr;
      if ( a )
      {
        v4 = baseURL(buf);
        parseURL2(a->url, &pu, v4);
        v5 = parsedURL2Str(&pu);
        q = html_quote(v5->ptr);
        if ( DecodeURL )
        {
          v6 = url_unquote_conv(a->url, buf->document_charset);
          p = html_quote(v6);
        }
        else
        {
          p = html_quote(a->url);
        }
        if ( *a->alt )
          v7 = a->alt;
        else
          v7 = mybasename(a->url);
        v8 = html_quote(v7);
        Strcat_m_charp(tmp, "<tr valign=top><td>&nbsp;&nbsp;<td><a href=\"", q, "\">", v8, "</a><td>", p, "\n", 0);
      }
    }
    Strcat_charp(tmp, "</table>");
  }
}

//----- (0808F13E) --------------------------------------------------------
void __cdecl append_link_info(Buffer *buf, Str html, LinkList *link)
{
  ParsedURL *v3; // eax
  Str v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // [esp+8h] [ebp-50h]
  ParsedURL pu; // [esp+20h] [ebp-38h] BYREF
  char *url; // [esp+48h] [ebp-10h]
  LinkList *l; // [esp+4Ch] [ebp-Ch]

  if ( link )
  {
    Strcat_charp(html, "<hr width=50%><h1>Link information</h1><table>\n");
    for ( l = link; l; l = l->next )
    {
      if ( l->url )
      {
        v3 = baseURL(buf);
        parseURL2(l->url, &pu, v3);
        v4 = parsedURL2Str(&pu);
        url = html_quote(v4->ptr);
      }
      else
      {
        url = "(empty)";
      }
      if ( l->title )
        v5 = html_quote(l->title);
      else
        v5 = "(empty)";
      Strcat_m_charp(html, "<tr valign=top><td><a href=\"", url, "\">", v5, "</a><td>", 0);
      if ( l->type == 1 )
      {
        Strcat_charp(html, "[Rel]");
      }
      else if ( l->type == 2 )
      {
        Strcat_charp(html, "[Rev]");
      }
      if ( l->url )
      {
        if ( DecodeURL )
        {
          v6 = url_unquote_conv(l->url, buf->document_charset);
          url = html_quote(v6);
        }
        else
        {
          url = html_quote(l->url);
        }
      }
      else
      {
        url = "(empty)";
      }
      Strcat_m_charp(html, "<td>", url, 0);
      if ( l->ctype )
      {
        v7 = html_quote(l->ctype);
        Strcat_m_charp(html, " (", v7, ")", 0);
      }
      Strcat_charp(html, "\n");
    }
    Strcat_charp(html, "</table>\n");
  }
}

//----- (0808F33D) --------------------------------------------------------
void __cdecl append_frame_info(Buffer *buf, Str html, frameset *set, int level)
{
  int v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // [esp+4h] [ebp-44h]
  frame_element *frame; // [esp+2Ch] [ebp-1Ch]
  int j; // [esp+30h] [ebp-18h]
  int i; // [esp+34h] [ebp-14h]
  char *q; // [esp+38h] [ebp-10h]
  char *p; // [esp+3Ch] [ebp-Ch]

  if ( set )
  {
    for ( i = 0; set->col * set->row > i; ++i )
    {
      frame = set->frame[i].element;
      if ( frame )
      {
        v4 = frame->attr;
        if ( v4 >= 0 )
        {
          if ( v4 <= 1 )
          {
            if ( *(_DWORD *)&frame[1].attr )
            {
              Strcat_charp(html, "<pre_int>");
              for ( j = 0; j < level; ++j )
                Strcat_charp(html, "   ");
              q = html_quote(*(char **)&frame[1].attr);
              Strcat_m_charp(html, "<a href=\"", q, "\">", 0);
              if ( frame->name )
              {
                v5 = url_unquote_conv(frame->name, buf->document_charset);
                v7 = html_quote(v5);
                Strcat_charp(html, v7);
              }
              if ( DecodeURL )
              {
                v6 = url_unquote_conv(*(char **)&frame[1].attr, buf->document_charset);
                p = html_quote(v6);
              }
              else
              {
                p = q;
              }
              Strcat_m_charp(html, " ", p, "</a></pre_int><br>\n", 0);
            }
          }
          else if ( v4 == 2 )
          {
            append_frame_info(buf, html, (frameset *)frame, level + 1);
          }
        }
      }
    }
  }
}

//----- (0808F50B) --------------------------------------------------------
Buffer *__cdecl page_info_panel(Buffer *buf)
{
  char *v1; // eax
  char *v2; // edi
  char *v3; // ebx
  char *v4; // esi
  char *v5; // eax
  const char *v6; // eax
  char *v7; // ebx
  Str v8; // eax
  ParsedURL *v9; // eax
  char *v10; // eax
  ParsedURL *v11; // eax
  char *v12; // eax
  char *v13; // eax
  char *v14; // eax
  ParsedURL pu; // [esp+4Ch] [ebp-7Ch] BYREF
  FormItemList *fi; // [esp+74h] [ebp-54h]
  Buffer *newbuf; // [esp+78h] [ebp-50h]
  wc_ces_list *list; // [esp+7Ch] [ebp-4Ch]
  char *q; // [esp+80h] [ebp-48h]
  char *p; // [esp+84h] [ebp-44h]
  int all; // [esp+88h] [ebp-40h]
  frameset *f_set; // [esp+8Ch] [ebp-3Ch]
  TextListItem *ti; // [esp+90h] [ebp-38h]
  Anchor *a; // [esp+94h] [ebp-34h]
  Str tmp; // [esp+98h] [ebp-30h]
  char charset[16]; // [esp+9Ch] [ebp-2Ch] BYREF
  unsigned int v28; // [esp+ACh] [ebp-1Ch]

  v28 = __readgsdword(0x14u);
  tmp = Strnew_size(1024);
  f_set = 0;
  Strcat_charp(
    tmp,
    "<html><head><title>Information about current page</title></head><body><h1>Information about current page</h1>\n");
  if ( buf )
  {
    all = buf->allLine;
    if ( !all && buf->lastLine )
      all = buf->lastLine->linenumber;
    Strcat_charp(tmp, "<form method=internal action=charset>");
    p = parsedURL2Str(&buf->currentURL)->ptr;
    if ( DecodeURL )
      p = url_unquote_conv(p, 0);
    v1 = last_modified(buf);
    v2 = html_quote(v1);
    if ( buf->real_type )
      v3 = html_quote(buf->real_type);
    else
      v3 = "unknown";
    v4 = html_quote(p);
    v5 = html_quote(buf->buffername);
    Strcat_m_charp(
      tmp,
      "<table cellpadding=0>",
      "<tr valign=top><td nowrap>Title<td>",
      v5,
      "<tr valign=top><td nowrap>Current URL<td>",
      v4,
      "<tr valign=top><td nowrap>Document Type<td>",
      v3,
      "<tr valign=top><td nowrap>Last Modified<td>",
      v2,
      0);
    if ( buf->document_charset != InnerCharset )
    {
      list = wc_get_ces_list();
      Strcat_charp(tmp, "<tr><td nowrap>Document Charset<td><select name=charset>");
      while ( list->name )
      {
        sprintf(charset, "%d", list->id);
        if ( buf->document_charset == list->id )
          v6 = " selected>";
        else
          v6 = ">";
        Strcat_m_charp(tmp, "<option value=", charset, v6, list->desc, 0);
        ++list;
      }
      Strcat_charp(tmp, "</select>");
      Strcat_charp(tmp, "<tr><td><td><input type=submit value=Change>");
    }
    v7 = Sprintf("%d", buf->trbyte)->ptr;
    v8 = Sprintf("%d", all);
    Strcat_m_charp(
      tmp,
      "<tr valign=top><td nowrap>Number of lines<td>",
      v8->ptr,
      "<tr valign=top><td nowrap>Transferred bytes<td>",
      v7,
      0);
    a = retrieveCurrentAnchor(buf);
    if ( a )
    {
      v9 = baseURL(buf);
      parseURL2(a->url, &pu, v9);
      p = parsedURL2Str(&pu)->ptr;
      q = html_quote(p);
      if ( DecodeURL )
      {
        v10 = url_unquote_conv(p, buf->document_charset);
        p = html_quote(v10);
      }
      else
      {
        p = q;
      }
      Strcat_m_charp(tmp, "<tr valign=top><td nowrap>URL of current anchor<td><a href=\"", q, "\">", p, "</a>", 0);
    }
    a = retrieveCurrentImg(buf);
    if ( a )
    {
      v11 = baseURL(buf);
      parseURL2(a->url, &pu, v11);
      p = parsedURL2Str(&pu)->ptr;
      q = html_quote(p);
      if ( DecodeURL )
      {
        v12 = url_unquote_conv(p, buf->document_charset);
        p = html_quote(v12);
      }
      else
      {
        p = q;
      }
      Strcat_m_charp(tmp, "<tr valign=top><td nowrap>URL of current image<td><a href=\"", q, "\">", p, "</a>", 0);
    }
    a = retrieveCurrentForm(buf);
    if ( a )
    {
      fi = (FormItemList *)a->url;
      p = form2str(fi);
      if ( DecodeURL )
      {
        v13 = url_unquote_conv(p, buf->document_charset);
        p = html_quote(v13);
      }
      else
      {
        p = html_quote(p);
      }
      Strcat_m_charp(tmp, "<tr valign=top><td nowrap>Method/type of current form&nbsp;<td>", p, 0);
      if ( fi->parent->method == 2 && !strcmp(fi->parent->action->ptr, "map") )
        append_map_info(buf, tmp, fi->parent->item);
    }
    Strcat_charp(tmp, "</table>\n");
    Strcat_charp(tmp, "</form>");
    append_link_info(buf, tmp, buf->linklist);
    if ( buf->document_header )
    {
      Strcat_charp(tmp, "<hr width=50%><h1>Header information</h1><pre>\n");
      for ( ti = buf->document_header->first; ti; ti = ti->next )
      {
        v14 = html_quote(ti->ptr);
        Strcat_m_charp(tmp, "<pre_int>", v14, "</pre_int>\n", 0);
      }
      Strcat_charp(tmp, "</pre>\n");
    }
    if ( buf->frameset )
    {
      f_set = buf->frameset;
    }
    else if ( (buf->bufferprop & 2) != 0 && buf->nextBuffer && buf->nextBuffer->frameset )
    {
      f_set = buf->nextBuffer->frameset;
    }
    if ( f_set )
    {
      Strcat_charp(tmp, "<hr width=50%><h1>Frame information</h1>\n");
      append_frame_info(buf, tmp, f_set, 0);
    }
  }
  Strcat_charp(tmp, "</body></html>");
  newbuf = loadHTMLString(tmp);
  if ( newbuf )
    newbuf->document_charset = buf->document_charset;
  return newbuf;
}

//----- (0808FC0C) --------------------------------------------------------
void __cdecl __noreturn KeyAbort_0(int _dummy)
{
  siglongjmp(AbortLoading_0, 1);
}

//----- (0808FC26) --------------------------------------------------------
int __cdecl parseFrameSetLength(char *s, char ***ret)
{
  int v2; // eax
  char **v3; // ebx
  char **v4; // ebx
  char **lv; // [esp+1Ch] [ebp-1Ch]
  char *q; // [esp+20h] [ebp-18h] BYREF
  char *p; // [esp+24h] [ebp-14h]
  int len; // [esp+28h] [ebp-10h]
  int i; // [esp+2Ch] [ebp-Ch]

  i = 1;
  if ( s )
  {
    for ( p = s; ; ++p )
    {
      p = strchr(p, 44);
      if ( !p )
        break;
      ++i;
    }
  }
  else
  {
    s = (char *)&unk_80CC030;
  }
  lv = (char **)GC_malloc(4 * i);
  i = 0;
  for ( p = s; ; ++p )
  {
    while ( *p && (MYCTYPE_MAP[(unsigned __int8)*p] & 2) != 0 )
      ++p;
    len = strtol(p, &q, 10);
    v2 = *q;
    if ( v2 == 37 )
    {
      v3 = &lv[i];
      *v3 = Sprintf("%d%%", len)->ptr;
      ++i;
    }
    else
    {
      if ( v2 == 42 )
      {
        lv[i] = (char *)&unk_80CC030;
      }
      else
      {
        v4 = &lv[i];
        *v4 = Sprintf("%d", len)->ptr;
      }
      ++i;
    }
    p = strchr(q, 44);
    if ( !p )
      break;
  }
  *ret = lv;
  return i;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (0808FD83) --------------------------------------------------------
frameset *__cdecl newFrameSet(parsed_tag *tag)
{
  int v1; // eax
  int v2; // eax
  frameset_element *v3; // eax
  char *rows; // [esp+10h] [ebp-18h] BYREF
  char *cols; // [esp+14h] [ebp-14h] BYREF
  int i; // [esp+18h] [ebp-10h]
  frameset *f; // [esp+1Ch] [ebp-Ch]

  cols = 0;
  rows = 0;
  f = (frameset *)GC_malloc(36);
  f->attr = 2;
  f->name = 0;
  f->currentURL = 0;
  parsedtag_get_value(tag, 13, &cols);
  parsedtag_get_value(tag, 28, &rows);
  v1 = parseFrameSetLength(cols, &f->width);
  f->col = v1;
  v2 = parseFrameSetLength(rows, &f->height);
  f->row = v2;
  f->i = 0;
  i = f->row * f->col;
  f->frame = (frameset_element *)GC_malloc(4 * i);
  do
  {
    v3 = f->frame;
    v3[--i].element = 0;
  }
  while ( i );
  return f;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (0808FE7F) --------------------------------------------------------
frame_body *__cdecl newFrame(parsed_tag *tag, Buffer *buf)
{
  wc_ces v2; // esi
  wc_ces v3; // ebx
  char *v4; // eax
  _Str *v5; // eax
  Str v6; // eax
  char *v7; // eax
  wc_ces v8; // esi
  wc_ces v9; // ebx
  _Str *v10; // eax
  Str v11; // eax
  char *v12; // eax
  char *p; // [esp+18h] [ebp-10h] BYREF
  frame_body *body; // [esp+1Ch] [ebp-Ch]

  body = (frame_body *)GC_malloc(36);
  bzero(body, 0x24u);
  body->attr = 0;
  body->flags = 0;
  body->baseURL = baseURL(buf);
  if ( tag )
  {
    if ( parsedtag_get_value(tag, 31, &p) )
    {
      v2 = buf->document_charset;
      v3 = InnerCharset;
      v4 = remove_space(p);
      v5 = Strnew_charp(v4);
      v6 = wc_Str_conv_strict(v5, v3, v2);
      v7 = url_quote(v6->ptr);
      body->url = v7;
    }
    if ( parsedtag_get_value(tag, 25, &p) && *p != 95 )
    {
      v8 = buf->document_charset;
      v9 = InnerCharset;
      v10 = Strnew_charp(p);
      v11 = wc_Str_conv_strict(v10, v9, v8);
      v12 = url_quote(v11->ptr);
      body->name = v12;
    }
  }
  return body;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (0808FF9D) --------------------------------------------------------
void __cdecl unloadFrame(frame_body *b)
{
  b->attr = 0;
}

//----- (0808FFA8) --------------------------------------------------------
void __cdecl deleteFrame(frame_body *b)
{
  if ( b )
  {
    unloadFrame(b);
    bzero(b, 0x24u);
  }
}

//----- (0808FFD7) --------------------------------------------------------
void __cdecl addFrameSetElement(frameset *f, frameset_element element)
{
  int i; // [esp+Ch] [ebp-4h]

  if ( f )
  {
    i = f->i;
    if ( f->col * f->row > i )
    {
      f->frame[i] = element;
      ++f->i;
    }
  }
}

//----- (0809002B) --------------------------------------------------------
void __cdecl deleteFrameSet(frameset *f)
{
  int i; // [esp+1Ch] [ebp-Ch]

  if ( f )
  {
    for ( i = 0; f->col * f->row > i; ++i )
      deleteFrameSetElement(f->frame[i]);
    f->name = 0;
    f->currentURL = 0;
  }
}

//----- (0809008A) --------------------------------------------------------
void __cdecl deleteFrameSetElement(frameset_element e)
{
  int v1; // eax

  if ( e.element )
  {
    v1 = e.element->attr;
    if ( v1 == 1 )
    {
      deleteFrame(e.body);
    }
    else if ( v1 == 2 )
    {
      deleteFrameSet(e.set);
    }
  }
}

//----- (080900D1) --------------------------------------------------------
frame_body *__cdecl copyFrame(frame_body *ob)
{
  frame_body *rb; // [esp+1Ch] [ebp-Ch]

  rb = (frame_body *)GC_malloc(36);
  bcopy(ob, rb, 0x24u);
  return rb;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (08090105) --------------------------------------------------------
frameset *__cdecl copyFrameSet(frameset *of_0)
{
  int v1; // eax
  frameset_element *v2; // ebx
  frameset_element *v3; // ebx
  int n; // [esp+18h] [ebp-10h]
  frameset *rf; // [esp+1Ch] [ebp-Ch]

  rf = (frameset *)GC_malloc(36);
  n = of_0->col * of_0->row;
  bcopy(of_0, rf, 0x24u);
  rf->width = (char **)GC_malloc(4 * rf->col);
  bcopy(of_0->width, rf->width, 4 * rf->col);
  rf->height = (char **)GC_malloc(4 * rf->row);
  bcopy(of_0->height, rf->height, 4 * rf->row);
  rf->frame = (frameset_element *)GC_malloc(4 * n);
  while ( n )
  {
    if ( of_0->frame[--n].element && (v1 = of_0->frame[n].element->attr, v1 >= 0) )
    {
      if ( v1 <= 1 )
      {
        v2 = &rf->frame[n];
        v2->element = (frame_element *)copyFrame(of_0->frame[n].body);
      }
      else
      {
        if ( v1 != 2 )
          goto attr_default;
        v3 = &rf->frame[n];
        v3->element = (frame_element *)copyFrameSet(of_0->frame[n].set);
      }
    }
    else
    {
attr_default:
      rf->frame[n].element = 0;
    }
  }
  return rf;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (080902A2) --------------------------------------------------------
void __cdecl flushFrameSet(frameset *fs_0)
{
  int v1; // eax
  int n; // [esp+1Ch] [ebp-Ch]

  n = fs_0->i;
  while ( n )
  {
    if ( fs_0->frame[--n].element )
    {
      v1 = fs_0->frame[n].element->attr;
      if ( v1 >= 0 )
      {
        if ( v1 <= 1 )
        {
          fs_0->frame[n].element[3].name = 0;
        }
        else if ( v1 == 2 )
        {
          flushFrameSet(fs_0->frame[n].set);
        }
      }
    }
  }
}

//----- (0809032D) --------------------------------------------------------
void __cdecl pushFrameTree(frameset_queue **fqpp, frameset *fs_0, Buffer *buf)
{
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  AnchorList *v7; // eax
  frameset_queue *cfq; // [esp+18h] [ebp-10h]
  frameset_queue *rfq; // [esp+1Ch] [ebp-Ch]

  cfq = *fqpp;
  if ( fs_0 )
  {
    rfq = (frameset_queue *)GC_malloc(32);
    if ( buf && buf->currentLine )
      v3 = buf->currentLine->linenumber;
    else
      v3 = 1;
    rfq->linenumber = v3;
    if ( buf && buf->topLine )
      v4 = buf->topLine->linenumber;
    else
      v4 = 1;
    rfq->top_linenumber = v4;
    if ( buf )
      v5 = buf->pos;
    else
      v5 = 0;
    rfq->pos = v5;
    if ( buf )
      v6 = buf->currentColumn;
    else
      v6 = 0;
    rfq->currentColumn = v6;
    if ( buf )
      v7 = buf->formitem;
    else
      v7 = 0;
    rfq->formitem = v7;
    rfq->back = cfq;
    if ( cfq )
    {
      rfq->next = cfq->next;
      if ( cfq->next )
        cfq->next->back = rfq;
      cfq->next = rfq;
    }
    else
    {
      rfq->next = 0;
    }
    rfq->frameset = fs_0;
    *fqpp = rfq;
  }
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (08090441) --------------------------------------------------------
frameset *__cdecl popFrameTree(frameset_queue **fqpp)
{
  frameset *rfs; // [esp+14h] [ebp-14h]
  frameset_queue *cfq; // [esp+18h] [ebp-10h]
  frameset_queue *rfq; // [esp+1Ch] [ebp-Ch]

  rfq = 0;
  cfq = *fqpp;
  if ( !*fqpp )
    return 0;
  rfs = cfq->frameset;
  if ( cfq->next )
  {
    rfq = cfq->next;
    cfq->next->back = cfq->back;
  }
  if ( cfq->back )
  {
    rfq = cfq->back;
    rfq->next = cfq->next;
  }
  *fqpp = rfq;
  bzero(cfq, 0x20u);
  return rfs;
}

//----- (080904CB) --------------------------------------------------------
void __cdecl resetFrameElement(frameset_element *f_element, Buffer *buf, char *referer, FormList *request)
{
  frame_element *v4; // ebx
  frame_body *f_body; // [esp+18h] [ebp-10h]
  char *f_name; // [esp+1Ch] [ebp-Ch]

  f_name = f_element->element->name;
  if ( buf->frameset )
  {
    deleteFrameSetElement((frameset_element)f_element->element);
    f_element->element = (frame_element *)buf->frameset;
    v4 = f_element->element;
    *(_DWORD *)&v4[1].attr = GC_malloc(40);
    copyParsedURL(*(ParsedURL **)&f_element->element[1].attr, &buf->currentURL);
    buf->frameset = popFrameTree(&buf->frameQ);
    f_element->element->name = f_name;
  }
  else
  {
    f_body = newFrame(0, buf);
    f_body->attr = 1;
    f_body->name = f_name;
    f_body->url = parsedURL2Str(&buf->currentURL)->ptr;
    f_body->source = buf->sourcefile;
    buf->sourcefile = 0;
    if ( buf->mailcap_source )
    {
      f_body->source = buf->mailcap_source;
      buf->mailcap_source = 0;
    }
    f_body->type = buf->type;
    f_body->referer = referer;
    f_body->request = request;
    deleteFrameSetElement((frameset_element)f_element->element);
    f_element->element = (frame_element *)f_body;
  }
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (0809061A) --------------------------------------------------------
frameset *__cdecl frame_download_source(frame_body *b, ParsedURL *currentURL, ParsedURL *baseURL, int flag)
{
  frameset *result; // eax
  ParsedURL *v5; // eax
  frameset *v6; // eax
  ParsedURL url; // [esp+20h] [ebp-38h] BYREF
  frameset *ret_frameset; // [esp+48h] [ebp-10h]
  Buffer *buf; // [esp+4Ch] [ebp-Ch]

  ret_frameset = 0;
  if ( !b || !b->url || !*b->url )
    return 0;
  if ( b->baseURL )
    baseURL = b->baseURL;
  parseURL2(b->url, &url, currentURL);
  if ( url.scheme == 4 )
    b->flags = 0;
  is_redisplay = 1;
  w3m_dump |= 0x20u;
  if ( baseURL )
    v5 = baseURL;
  else
    v5 = currentURL;
  buf = loadGeneralFile(b->url, v5, b->referer, flag | 4, b->request);
  w3m_dump &= 0xFFFFFFDF;
  is_redisplay = 0;
  if ( buf && buf != (Buffer *)1 )
  {
    b->url = parsedURL2Str(&buf->currentURL)->ptr;
    b->type = buf->type;
    b->source = buf->sourcefile;
    buf->sourcefile = 0;
    if ( buf->mailcap_source )
    {
      b->source = buf->mailcap_source;
      buf->mailcap_source = 0;
    }
    b->attr = 1;
    if ( buf->frameset )
    {
      ret_frameset = buf->frameset;
      ret_frameset->name = b->name;
      ret_frameset->currentURL = (ParsedURL *)GC_malloc(40);
      copyParsedURL(ret_frameset->currentURL, &buf->currentURL);
      v6 = popFrameTree(&buf->frameQ);
      buf->frameset = v6;
    }
    discardBuffer(buf);
    result = ret_frameset;
  }
  else
  {
    b->source = 0;
    b->flags = buf == (Buffer *)1;
    result = 0;
  }
  return result;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (0809081D) --------------------------------------------------------
int __cdecl createFrameFile(frameset *f, FILE *f1, Buffer *current, int level, int force_reload)
{
  ParsedURL *v6; // eax
  int v7; // eax
  int v8; // ebx
  frameset_element v9; // ebx
  frameset_element *v10; // edx
  char *v11; // eax
  char *v12; // eax
  char *v13; // eax
  wc_ces v14; // esi
  wc_ces v15; // ebx
  char *v16; // eax
  _Str *v17; // eax
  Str v18; // eax
  wc_ces v19; // esi
  wc_ces v20; // ebx
  _Str *v21; // eax
  Str v22; // eax
  unsigned int v23; // eax
  int v24; // eax
  char **v25; // edi
  wc_ces v26; // esi
  wc_ces v27; // ebx
  char *v28; // eax
  _Str *v29; // eax
  Str v30; // eax
  char **v31; // ebx
  Str v32; // eax
  char *v33; // eax
  char *v34; // eax
  char *v35; // eax
  char *v36; // eax
  Str v37; // eax
  frameset_element v39; // ebx
  char *v40; // [esp+8h] [ebp-120h]
  char *v41; // [esp+8h] [ebp-120h]
  char *v42; // [esp+8h] [ebp-120h]
  char *v43; // [esp+8h] [ebp-120h]
  char *v44; // [esp+8h] [ebp-120h]
  char *v45; // [esp+8h] [ebp-120h]
  char *v46; // [esp+8h] [ebp-120h]
  ParsedURL url; // [esp+24h] [ebp-104h] BYREF
  ParsedURL base; // [esp+4Ch] [ebp-DCh] BYREF
  URLFile f2; // [esp+74h] [ebp-B4h] BYREF
  wc_ces c_0; // [esp+94h] [ebp-94h]
  int refresh_interval; // [esp+98h] [ebp-90h]
  Str s_tmp; // [esp+9Ch] [ebp-8Ch] BYREF
  int a_target; // [esp+A0h] [ebp-88h]
  int j; // [esp+A4h] [ebp-84h]
  char *q_0; // [esp+A8h] [ebp-80h] BYREF
  Str tmp_0; // [esp+ACh] [ebp-7Ch]
  parsed_tag *tag; // [esp+B0h] [ebp-78h]
  char *q; // [esp+B4h] [ebp-74h] BYREF
  int is_tag; // [esp+B8h] [ebp-70h]
  Str tmp; // [esp+BCh] [ebp-6Ch]
  int end_tag; // [esp+C0h] [ebp-68h]
  int pre_mode; // [esp+C4h] [ebp-64h]
  Str tok; // [esp+C8h] [ebp-60h]
  int status; // [esp+CCh] [ebp-5Ch] BYREF
  char *p; // [esp+D0h] [ebp-58h] BYREF
  int i; // [esp+D4h] [ebp-54h]
  frameset *f_frameset; // [esp+D8h] [ebp-50h]
  frameset_element frame; // [esp+DCh] [ebp-4Ch]
  int flag; // [esp+E0h] [ebp-48h]
  void (*prevtrap)(int); // [esp+E4h] [ebp-44h]
  ParsedURL *currentURL; // [esp+E8h] [ebp-40h]
  char *t_target; // [esp+ECh] [ebp-3Ch]
  char *s_target; // [esp+F0h] [ebp-38h]
  char *p_target; // [esp+F4h] [ebp-34h]
  char *d_target; // [esp+F8h] [ebp-30h]
  wc_ces doc_charset; // [esp+FCh] [ebp-2Ch]
  wc_ces charset; // [esp+100h] [ebp-28h] BYREF
  int t_stack; // [esp+104h] [ebp-24h]
  int c; // [esp+108h] [ebp-20h]
  int r; // [esp+10Ch] [ebp-1Ch]

  prevtrap = 0;
  if ( !f )
    return -1;
  if ( !level )
  {
    if ( __sigsetjmp(AbortLoading_0, 1) )
    {
      if ( TrapSignal )
      {
        if ( fmInitialized )
          term_raw();
      }
      return -1;
    }
    if ( TrapSignal )
    {
      prevtrap = mySignal(2, KeyAbort_0);
      if ( fmInitialized )
        term_cbreak();
    }
    f->name = "_top";
  }
  if ( level > 7 )
  {
    fwrite("Too many frameset tasked.\n", 1u, 0x1Au, f1);
    return -1;
  }
  if ( level )
  {
    fwrite("<table hborder>\n", 1u, 0x10u, f1);
  }
  else
  {
    v40 = html_quote(current->buffername);
    fprintf(f1, "<html><head><title>%s</title></head><body>\n", v40);
    fwrite("<table hborder width=\"100%\">\n", 1u, 0x1Du, f1);
  }
  if ( f->currentURL )
    v6 = f->currentURL;
  else
    v6 = &current->currentURL;
  currentURL = v6;
  r = 0;
LABEL_210:
  if ( f->row > r )
  {
    fwrite("<tr valign=top>\n", 1u, 0x10u, f1);
    for ( c = 0; ; ++c )
    {
      if ( f->col <= c )
      {
        fwrite("</tr>\n", 1u, 6u, f1);
        ++r;
        goto LABEL_210;
      }
      i = c + r * f->col;
      p = (char *)&unk_80CC0C8;
      status = 0;
      tok = Strnew();
      pre_mode = 0;
      end_tag = 0;
      frame.element = (frame_element *)f->frame[i];
      if ( !frame.element )
      {
        fwrite("<td>\n</td>\n", 1u, 0xBu, f1);
        continue;
      }
      fwrite("<td", 1u, 3u, f1);
      if ( frame.element->name )
      {
        v41 = html_quote(frame.element->name);
        fprintf(f1, " id=\"_%s\"", v41);
      }
      if ( !r )
        fprintf(f1, " width=\"%s\"", f->width[c]);
      fwrite(">\n", 1u, 2u, f1);
      flag = 0;
      if ( force_reload )
      {
        flag |= 1u;
        if ( frame.element->attr == 1 )
          unloadFrame(frame.body);
      }
      v7 = frame.element->attr;
      if ( v7 != 1 )
      {
        if ( v7 == 2 )
          goto render_frameset;
        if ( frame.element->attr )
        {
          v8 = i + 1;
          v42 = html_quote(f->name);
          fprintf(f1, "Frameset \"%s\" frame %d: type unrecognized", v42, v8);
          goto LABEL_206;
        }
        if ( !frame.element->name && f->name )
        {
          v9.element = frame.element;
          v9.element->name = Sprintf("%s_%d", f->name, i)->ptr;
        }
        fflush(f1);
        f_frameset = frame_download_source(frame.body, currentURL, current->baseURL, flag);
        if ( f_frameset )
        {
          deleteFrame(frame.body);
          v10 = &f->frame[i];
          frame.element = (frame_element *)f_frameset;
          v10->element = (frame_element *)f_frameset;
render_frameset:
          if ( !frame.element->name && f->name )
          {
            v39.element = frame.element;
            v39.element->name = Sprintf("%s_%d", f->name, i)->ptr;
          }
          createFrameFile(frame.set, f1, current, level + 1, force_reload);
          goto LABEL_206;
        }
      }
      init_stream(&f2, 4, 0);
      if ( *(_DWORD *)&frame.element[2].attr )
      {
        fflush(f1);
        examineFile(*(char **)&frame.element[2].attr, &f2);
      }
      if ( !f2.stream )
      {
        frame.element->attr = 0;
        if ( (frame.element->dummy & 1) != 0 )
        {
          v43 = html_quote(*(char **)&frame.element[1].attr);
          fprintf(f1, "Open %s with other method", v43);
        }
        else if ( *(_DWORD *)&frame.element[1].attr )
        {
          v44 = html_quote(*(char **)&frame.element[1].attr);
          fprintf(f1, "Can't open %s", v44);
        }
        else
        {
          if ( frame.element->name )
            v11 = html_quote(frame.element->name);
          else
            v11 = "(no name)";
          fprintf(f1, "This frame (%s) contains no src attribute", v11);
        }
        goto LABEL_206;
      }
      parseURL2(*(char **)&frame.element[1].attr, &base, currentURL);
      p_target = f->name;
      s_target = frame.element->name;
      t_target = "_blank";
      if ( TargetSelf )
        v12 = s_target;
      else
        v12 = t_target;
      d_target = v12;
      charset = 256;
      if ( current->document_charset == 256 )
        doc_charset = DocumentCharset;
      else
        doc_charset = current->document_charset;
      t_stack = 0;
      if ( frame.element[2].name && !strcasecmp(frame.element[2].name, "text/plain") )
      {
        fwrite("<pre>\n", 1u, 6u, f1);
        while ( 1 )
        {
          tmp = StrmyISgets(f2.stream);
          if ( !tmp->length )
            break;
          tmp = convertLine(0, tmp, 2, &charset, doc_charset);
          v13 = html_quote(tmp->ptr);
          fputs(v13, f1);
        }
        fwrite("</pre>\n", 1u, 7u, f1);
        if ( !ISclose(f2.stream) )
          f2.stream = 0;
        goto LABEL_206;
      }
      do
      {
        is_tag = 0;
        do
        {
          if ( !*p )
          {
            tmp_0 = StrmyISgets(f2.stream);
            if ( !tmp_0->length )
              break;
            tmp_0 = convertLine(0, tmp_0, 2, &charset, doc_charset);
            p = tmp_0->ptr;
          }
          read_token(tok, &p, &status, 1, status != 0);
        }
        while ( status );
        if ( tok->length )
        {
          if ( *tok->ptr == 60 )
          {
            if ( tok->ptr[1]
              && ((MYCTYPE_MAP[*((unsigned __int8 *)tok->ptr + 1)] & 4) != 0
               || tok->ptr[1] == 47
               || tok->ptr[1] == 33
               || tok->ptr[1] == 63
               || !tok->ptr[1]
               || tok->ptr[1] == 95) )
            {
              is_tag = 1;
            }
            else if ( (pre_mode & 0x80E) == 0 )
            {
              p = Strnew_m_charp(tok->ptr + 1, p, 0)->ptr;
              tok = Strnew_charp("&lt;");
            }
          }
          if ( is_tag )
          {
            if ( (pre_mode & 0x80E) != 0 )
            {
              q = tok->ptr;
              tag = parse_tag(&q, 0);
              if ( tag && tag->tagid == end_tag )
              {
                if ( (pre_mode & 8) != 0 )
                {
                  fwrite("</PRE_PLAIN>", 1u, 0xCu, f1);
                  pre_mode = 0;
                  end_tag = 0;
token_end:
                  Strclear(tok);
                  continue;
                }
                pre_mode = 0;
                end_tag = 0;
              }
              else
              {
                if ( strncmp(tok->ptr, "<!--", 4u) )
                {
                  q = strchr((const char *)tok->ptr + 1, 60);
                  if ( q )
                  {
                    tok = Strnew_charp_n(tok->ptr, q - tok->ptr);
                    p = Strnew_m_charp(q, p, 0)->ptr;
                    status = 0;
                  }
                }
                is_tag = 0;
              }
            }
            else if ( (pre_mode & 0x1000) != 0 )
            {
              q = tok->ptr;
              tag = parse_tag(&q, 0);
              if ( tag )
              {
                if ( tag->tagid == end_tag || tag->tagid == 43 )
                {
                  if ( tag->tagid == 43 )
                    fwrite("</SELECT>", 1u, 9u, f1);
                  pre_mode = 0;
                  end_tag = 0;
                }
                else if ( t_stack )
                {
                  switch ( tag->tagid )
                  {
                    case 0x1Fu:
                    case 0x20u:
                    case 0x4Au:
                    case 0x4Bu:
                    case 0x4Cu:
                    case 0x4Du:
                    case 0x50u:
                    case 0x51u:
                    case 0x52u:
                    case 0x53u:
                    case 0x54u:
                    case 0x55u:
                    case 0x56u:
                    case 0x57u:
                    case 0x58u:
                    case 0x59u:
                    case 0x5Au:
                      fwrite("</SELECT>", 1u, 9u, f1);
                      pre_mode = 0;
                      end_tag = 0;
                      break;
                    default:
                      break;
                  }
                }
              }
            }
          }
          if ( is_tag )
          {
            q_0 = tok->ptr;
            a_target = 0;
            tag = parse_tag(&q_0, 0);
            if ( tag )
            {
              switch ( tag->tagid )
              {
                case 0xEu:
                  fwrite("<!-- title:", 1u, 0xBu, f1);
                  goto token_end;
                case 0xFu:
                  fwrite("-->", 1u, 3u, f1);
                  goto token_end;
                case 0x1Au:
                  pre_mode = 8;
                  end_tag = 27;
                  fwrite("<PRE_PLAIN>", 1u, 0xBu, f1);
                  goto token_end;
                case 0x1Cu:
                  pre_mode = 8;
                  end_tag = 29;
                  fwrite("<PRE_PLAIN>", 1u, 0xBu, f1);
                  goto token_end;
                case 0x1Eu:
                  pre_mode = 8;
                  end_tag = 145;
                  fwrite("<PRE_PLAIN>", 1u, 0xBu, f1);
                  goto token_end;
                case 0x1Fu:
                  ++t_stack;
                  goto LABEL_151;
                case 0x20u:
                  if ( --t_stack >= 0 )
                    goto LABEL_151;
                  t_stack = 0;
                  Strdelete(tok, 0, 1);
                  Strshrink(tok, 1);
                  v45 = html_quote(tok->ptr);
                  fprintf(f1, "<!-- table stack underflow: %s -->", v45);
                  goto token_end;
                case 0x21u:
                  if ( parsedtag_get_value(tag, 19, &q_0) )
                  {
                    if ( !strcasecmp(q_0, "refresh") )
                    {
                      if ( parsedtag_get_value(tag, 15, &q_0) )
                      {
                        s_tmp = 0;
                        refresh_interval = getMetaRefreshParam(q_0, &s_tmp);
                        if ( s_tmp )
                        {
                          q_0 = html_quote(s_tmp->ptr);
                          fprintf(f1, "Refresh (%d sec) <a href=\"%s\">%s</a>\n", refresh_interval, q_0, q_0);
                        }
                      }
                    }
                  }
                  if ( UseContentCharset )
                  {
                    if ( parsedtag_get_value(tag, 19, &q_0) )
                    {
                      if ( !strcasecmp(q_0, "Content-Type") )
                      {
                        if ( parsedtag_get_value(tag, 15, &q_0) )
                        {
                          q_0 = (char *)strcasestr(q_0, "charset");
                          if ( q_0 )
                          {
                            for ( q_0 += 7; *q_0 && (MYCTYPE_MAP[(unsigned __int8)*q_0] & 2) != 0; ++q_0 )
                              ;
                            if ( *q_0 == 61 )
                            {
                              ++q_0;
                              while ( *q_0 && (MYCTYPE_MAP[(unsigned __int8)*q_0] & 2) != 0 )
                                ++q_0;
                              c_0 = wc_guess_charset(q_0, 0);
                              if ( c_0 )
                              {
                                doc_charset = c_0;
                                charset = 256;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                  goto LABEL_143;
                case 0x2Du:
                  pre_mode = 2048;
                  end_tag = 46;
                  goto LABEL_151;
                case 0x2Fu:
                  pre_mode = 4096;
                  end_tag = 48;
                  goto LABEL_151;
                case 0x3Au:
                  pre_mode = 2;
                  end_tag = 59;
                  goto LABEL_151;
                case 0x3Cu:
                  if ( parsedtag_get_value(tag, 18, &q_0) )
                  {
                    v14 = charset;
                    v15 = InnerCharset;
                    v16 = remove_space(q_0);
                    v17 = Strnew_charp(v16);
                    v18 = wc_Str_conv_strict(v17, v15, v14);
                    q_0 = url_quote(v18->ptr);
                    parseURL(q_0, &base, 0);
                  }
                  if ( parsedtag_get_value(tag, 32, &q_0) )
                  {
                    if ( !strcasecmp(q_0, "_self") )
                    {
                      d_target = s_target;
                    }
                    else if ( !strcasecmp(q_0, "_parent") )
                    {
                      d_target = p_target;
                    }
                    else
                    {
                      v19 = charset;
                      v20 = InnerCharset;
                      v21 = Strnew_charp(q_0);
                      v22 = wc_Str_conv_strict(v21, v20, v19);
                      d_target = url_quote(v22->ptr);
                    }
                  }
                  goto LABEL_143;
                case 0x43u:
                  pre_mode = 4;
                  end_tag = 68;
                  goto LABEL_151;
                case 0x48u:
                case 0x49u:
                case 0x5Fu:
                case 0x60u:
                case 0x61u:
                  goto LABEL_143;
                case 0x4Au:
                case 0x4Bu:
                case 0x4Cu:
                case 0x4Du:
                case 0x50u:
                case 0x51u:
                case 0x52u:
                case 0x53u:
                case 0x54u:
                case 0x55u:
                case 0x56u:
                case 0x57u:
                case 0x58u:
                case 0x59u:
                case 0x5Au:
                  if ( t_stack )
                    goto LABEL_151;
LABEL_143:
                  Strdelete(tok, 0, 1);
                  Strshrink(tok, 1);
                  v46 = html_quote(tok->ptr);
                  fprintf(f1, "<!-- %s -->", v46);
                  goto token_end;
                default:
LABEL_151:
                  for ( j = 0; TagMAP[tag->tagid].max_attribute > j; ++j )
                  {
                    v23 = tag->attrid[j] - 3;
                    if ( v23 <= 0x1D )
                    {
                      v24 = 1 << v23;
                      if ( (v24 & 0x10008001) != 0 )
                      {
                        if ( tag->value[j] )
                        {
                          v25 = &tag->value[j];
                          v26 = charset;
                          v27 = InnerCharset;
                          v28 = remove_space(*v25);
                          v29 = Strnew_charp(v28);
                          v30 = wc_Str_conv_strict(v29, v27, v26);
                          *v25 = url_quote(v30->ptr);
                          tag->need_reconstruct = 1;
                          parseURL2(tag->value[j], &url, &base);
                          if ( url.scheme != 255 && url.scheme != 254 )
                          {
                            a_target |= 1u;
                            v31 = &tag->value[j];
                            *v31 = parsedURL2Str(&url)->ptr;
                            v32 = parsedURL2Str(&base);
                            parsedtag_set_value(tag, 71, v32->ptr);
                            if ( tag->attrid[j] == 3 && charset != 256 )
                            {
                              v33 = wc_ces_to_charset(charset);
                              parsedtag_set_value(tag, 11, v33);
                            }
                          }
                        }
                      }
                      else if ( (v24 & 0x420000) != 0 )
                      {
                        if ( tag->value[j] )
                          parsedtag_set_value(tag, 67, s_target);
                      }
                      else if ( (v24 & 0x20000000) != 0 && tag->value[j] )
                      {
                        a_target |= 2u;
                        if ( !strcasecmp(tag->value[j], "_self") )
                        {
                          parsedtag_set_value(tag, 32, s_target);
                        }
                        else if ( !strcasecmp(tag->value[j], "_parent") )
                        {
                          parsedtag_set_value(tag, 32, p_target);
                        }
                      }
                    }
                  }
                  if ( a_target == 1 )
                    parsedtag_set_value(tag, 32, d_target);
                  if ( tag->need_reconstruct )
                    tok = parsedtag2str(tag);
                  goto LABEL_176;
              }
            }
          }
          else if ( (pre_mode & 8) != 0 )
          {
            v34 = html_quote(tok->ptr);
            fputs(v34, f1);
          }
          else if ( (pre_mode & 0x800) != 0 )
          {
            v35 = html_unquote(tok->ptr);
            v36 = html_quote(v35);
            fputs(v36, f1);
          }
          else
          {
LABEL_176:
            fwrite(tok->ptr, 1u, tok->length, f1);
          }
          goto token_end;
        }
      }
      while ( *p || !f2.stream->base.iseos );
      if ( (pre_mode & 8) != 0 )
      {
        fwrite("</PRE_PLAIN>\n", 1u, 0xDu, f1);
      }
      else if ( (pre_mode & 0x800) != 0 )
      {
        fwrite("</TEXTAREA></FORM>\n", 1u, 0x13u, f1);
      }
      else if ( (pre_mode & 0x1000) != 0 )
      {
        fwrite("</SELECT></FORM>\n", 1u, 0x11u, f1);
      }
      else if ( (pre_mode & 6) != 0 )
      {
        if ( status )
        {
          v37 = correct_irrtag(status);
          fputs(v37->ptr, f1);
        }
        if ( (pre_mode & 2) != 0 )
        {
          fwrite("</SCRIPT>\n", 1u, 0xAu, f1);
        }
        else if ( (pre_mode & 4) != 0 )
        {
          fwrite("</STYLE>\n", 1u, 9u, f1);
        }
      }
      while ( t_stack-- != 0 )
        fwrite("</TABLE>\n", 1u, 9u, f1);
      if ( !ISclose(f2.stream) )
        f2.stream = 0;
LABEL_206:
      fwrite("</td>\n", 1u, 6u, f1);
    }
  }
  fwrite("</table>\n", 1u, 9u, f1);
  if ( !level )
  {
    fwrite("</body></html>\n", 1u, 0xFu, f1);
    if ( TrapSignal )
    {
      if ( fmInitialized )
        term_raw();
      if ( prevtrap )
        mySignal(2, prevtrap);
    }
  }
  return 0;
}
// 8090882: conditional instruction was optimized away because of '%prevtrap.4==0'
// 804A36C: using guessed type int __cdecl strcasestr(_DWORD, _DWORD);

//----- (08091F71) --------------------------------------------------------
Buffer *__cdecl renderFrame(Buffer *Cbuf, int force_reload)
{
  wc_ces doc_charset; // [esp+28h] [ebp-20h]
  frameset *fset; // [esp+2Ch] [ebp-1Ch]
  int flag; // [esp+30h] [ebp-18h]
  Buffer *buf; // [esp+34h] [ebp-14h]
  FILE *f; // [esp+38h] [ebp-10h]
  Str tmp; // [esp+3Ch] [ebp-Ch]

  doc_charset = DocumentCharset;
  tmp = tmpfname(2, ".html");
  f = fopen(tmp->ptr, "w");
  if ( !f )
    return 0;
  fset = Cbuf->frameset;
  if ( !fset || createFrameFile(fset, f, Cbuf, 0, force_reload) < 0 )
    return 0;
  fclose(f);
  flag = 2;
  if ( Cbuf->currentURL.is_nocache )
    flag = 3;
  renderFrameSet = Cbuf->frameset;
  flushFrameSet(renderFrameSet);
  DocumentCharset = InnerCharset;
  buf = loadGeneralFile(tmp->ptr, 0, 0, flag, 0);
  DocumentCharset = doc_charset;
  renderFrameSet = 0;
  if ( !buf || buf == (Buffer *)1 )
    return 0;
  buf->sourcefile = tmp->ptr;
  buf->document_charset = Cbuf->document_charset;
  copyParsedURL(&buf->currentURL, &Cbuf->currentURL);
  preFormUpdateBuffer(buf);
  return buf;
}

//----- (080920F0) --------------------------------------------------------
frameset_element *__cdecl search_frame(frameset *fset, char *name)
{
  frameset_element *e; // [esp+18h] [ebp-10h]
  frameset_element *ea; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; fset->col * fset->row > i; ++i )
  {
    e = &fset->frame[i];
    if ( e->element )
    {
      if ( e->element->name && !strcmp(e->element->name, name) )
        return e;
      if ( e->element->attr == 2 )
      {
        ea = search_frame(e->set, name);
        if ( ea )
          return ea;
      }
    }
  }
  return 0;
}

//----- (080921A0) --------------------------------------------------------
int __cdecl compare_table(rc_search_table *a, rc_search_table *b)
{
  return strcmp(a->param->name, b->param->name);
}

//----- (080921C2) --------------------------------------------------------
void create_option_search_table()
{
  char *q; // [esp+14h] [ebp-24h]
  char *p; // [esp+18h] [ebp-20h]
  int diff2; // [esp+1Ch] [ebp-1Ch]
  int k; // [esp+24h] [ebp-14h]
  int j; // [esp+28h] [ebp-10h]
  int ja; // [esp+28h] [ebp-10h]
  int jb; // [esp+28h] [ebp-10h]
  int i; // [esp+2Ch] [ebp-Ch]
  int ia; // [esp+2Ch] [ebp-Ch]
  int ib; // [esp+2Ch] [ebp-Ch]

  RC_table_size = 0;
  for ( j = 0; sections[j].name; ++j )
  {
    for ( i = 0; sections[j].params[i].name; ++i )
      ++RC_table_size;
  }
  RC_search_table = (rc_search_table *)GC_malloc(8 * RC_table_size);
  k = 0;
  for ( ja = 0; sections[ja].name; ++ja )
  {
    for ( ia = 0; sections[ja].params[ia].name; ++ia )
      RC_search_table[k++].param = &sections[ja].params[ia];
  }
  qsort(RC_search_table, RC_table_size, 8u, (__compar_fn_t)compare_table);
  diff2 = 0;
  for ( ib = 0; (int)(RC_table_size - 1) > ib; ++ib )
  {
    p = RC_search_table[ib].param->name;
    q = RC_search_table[ib + 1].param->name;
    for ( jb = 0; p[jb] && q[jb] && p[jb] == q[jb]; ++jb )
      ;
    if ( jb <= diff2 )
      RC_search_table[ib].uniq_pos = diff2 + 1;
    else
      RC_search_table[ib].uniq_pos = jb + 1;
    diff2 = jb;
  }
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (080923C2) --------------------------------------------------------
param_ptr *__cdecl search_param(char *name)
{
  int len; // [esp+1Ch] [ebp-1Ch]
  int cmp; // [esp+20h] [ebp-18h]
  int cmpa; // [esp+20h] [ebp-18h]
  unsigned int i; // [esp+24h] [ebp-14h]
  size_t e; // [esp+28h] [ebp-10h]
  size_t b; // [esp+2Ch] [ebp-Ch]

  len = strlen(name);
  b = 0;
  e = RC_table_size - 1;
  while ( 1 )
  {
    if ( b > e )
      return 0;
    i = (b + e) >> 1;
    cmp = strncmp(name, RC_search_table[i].param->name, len);
    if ( !cmp )
      break;
    if ( cmp >= 0 )
    {
      b = i + 1;
    }
    else
    {
      if ( !i )
        return 0;
      e = i - 1;
    }
  }
  if ( RC_search_table[i].uniq_pos <= len )
    return RC_search_table[i].param;
  while ( 1 )
  {
    cmpa = strcmp(name, RC_search_table[i].param->name);
    if ( cmpa > 0 )
      break;
    if ( !cmpa )
      return RC_search_table[i].param;
    if ( !i )
      return 0;
    --i;
  }
  return 0;
}

//----- (080924EF) --------------------------------------------------------
void __cdecl show_params(FILE *fp)
{
  wc_ces v1; // esi
  wc_ces v2; // ebx
  char *v3; // eax
  _Str *v4; // eax
  wc_ces v5; // esi
  wc_ces v6; // ebx
  _Str *v7; // eax
  const char *v8; // eax
  wc_ces v9; // esi
  wc_ces v10; // ebx
  char *v11; // eax
  _Str *v12; // eax
  size_t v13; // ebx
  wc_ces v14; // esi
  wc_ces v15; // ebx
  _Str *v16; // eax
  char *v17; // [esp+Ch] [ebp-3Ch]
  char *v18; // [esp+18h] [ebp-30h]
  char *cmt; // [esp+2Ch] [ebp-1Ch]
  char *cmta; // [esp+2Ch] [ebp-1Ch]
  char *t; // [esp+30h] [ebp-18h]
  int l; // [esp+34h] [ebp-14h]
  int j; // [esp+38h] [ebp-10h]
  int i; // [esp+3Ch] [ebp-Ch]

  t = 0;
  OptionCharset = SystemCharset;
  fwrite("\nconfiguration parameters\n", 1u, 0x1Au, fp);
  for ( j = 0; sections[j].name; ++j )
  {
    if ( OptionEncode )
    {
      cmt = sections[j].name;
    }
    else
    {
      v1 = InnerCharset;
      v2 = OptionCharset;
      v3 = gettext(sections[j].name);
      v4 = Strnew_charp(v3);
      cmt = wc_Str_conv(v4, v2, v1)->ptr;
    }
    v5 = SystemCharset;
    v6 = InnerCharset;
    v7 = Strnew_charp(cmt);
    v17 = wc_Str_conv_strict(v7, v6, v5)->ptr;
    fprintf(fp, "  section[%d]: %s\n", j, v17);
    for ( i = 0; sections[j].params[i].name; ++i )
    {
      switch ( sections[j].params[i].type )
      {
        case 0:
        case 1:
        case 2:
        case 9:
          if ( sections[j].params[i].inputtype == 1 )
            v8 = "bool";
          else
            v8 = "number";
          t = (char *)v8;
          break;
        case 3:
          t = "char";
          break;
        case 4:
          t = "string";
          break;
        case 6:
          t = "color";
          break;
        case 7:
          t = "charset";
          break;
        case 8:
          t = "number";
          break;
        case 0xA:
          t = "percent";
          break;
        default:
          break;
      }
      if ( OptionEncode )
      {
        cmta = sections[j].params[i].comment;
      }
      else
      {
        v9 = InnerCharset;
        v10 = OptionCharset;
        v11 = gettext(sections[j].params[i].comment);
        v12 = Strnew_charp(v11);
        cmta = wc_Str_conv(v12, v10, v9)->ptr;
      }
      v13 = strlen(sections[j].params[i].name);
      l = 30 - (v13 + strlen(t));
      if ( l < 0 )
        l = 1;
      v14 = SystemCharset;
      v15 = InnerCharset;
      v16 = Strnew_charp(cmta);
      v18 = wc_Str_conv_strict(v16, v15, v14)->ptr;
      fprintf(fp, "    -o %s=<%s>%*s%s\n", sections[j].params[i].name, t, l, " ", v18);
    }
  }
}

//----- (080927EA) --------------------------------------------------------
int __cdecl str_to_bool(char *value, int old)
{
  int result; // eax
  int v3; // eax
  char v4; // al
  char v5; // al

  if ( !value )
    return 1;
  if ( (MYCTYPE_MAP[(unsigned __int8)*value] & 4) != 0 )
    v3 = *value | 0x20;
  else
    v3 = *value;
  switch ( v3 )
  {
    case '!':
    case 'r':
    case 'x':
      result = old == 0;
      break;
    case '0':
    case 'f':
    case 'n':
    case 'u':
      result = 0;
      break;
    case 'o':
      if ( (MYCTYPE_MAP[(unsigned __int8)value[1]] & 4) != 0 )
        v4 = value[1] | 0x20;
      else
        v4 = value[1];
      result = v4 != 102;
      break;
    case 't':
      if ( (MYCTYPE_MAP[(unsigned __int8)value[1]] & 4) != 0 )
        v5 = value[1] | 0x20;
      else
        v5 = value[1];
      if ( v5 == 111 )
        result = old == 0;
      else
        result = 1;
      break;
    default:
      result = 1;
      break;
  }
  return result;
}

//----- (08092905) --------------------------------------------------------
int __cdecl str_to_color(char *value)
{
  int result; // eax
  int v2; // eax

  if ( !value )
    return 8;
  if ( (MYCTYPE_MAP[(unsigned __int8)*value] & 4) != 0 )
    v2 = *value | 0x20;
  else
    v2 = *value;
  switch ( v2 )
  {
    case '0':
      result = 0;
      break;
    case '1':
    case 'r':
      result = 1;
      break;
    case '2':
    case 'g':
      result = 2;
      break;
    case '3':
    case 'y':
      result = 3;
      break;
    case '4':
      result = 4;
      break;
    case '5':
    case 'm':
      result = 5;
      break;
    case '6':
    case 'c':
      result = 6;
      break;
    case '7':
    case 'w':
      result = 7;
      break;
    case '8':
    case 't':
      result = 8;
      break;
    case 'b':
      if ( !strncasecmp(value, "blu", 3u) )
        result = 4;
      else
        result = 0;
      break;
    default:
      result = 8;
      break;
  }
  return result;
}

//----- (080929D0) --------------------------------------------------------
int __cdecl set_param(char *name, char *value)
{
  _DWORD *v3; // ebx
  int v4; // eax
  _DWORD *v5; // ebx
  _WORD *v6; // ebx
  __int16 v7; // ax
  _BYTE *v8; // ebx
  char v9; // al
  _DWORD *v10; // ebx
  wc_ces *v11; // ebx
  double ppc; // [esp+10h] [ebp-18h]
  double ppca; // [esp+10h] [ebp-18h]
  param_ptr *p; // [esp+1Ch] [ebp-Ch]

  if ( !value )
    return 0;
  p = search_param(name);
  if ( !p )
    return 0;
  switch ( p->type )
  {
    case 0:
      if ( atoi(value) >= 0 )
      {
        v3 = p->varptr;
        if ( p->inputtype == 1 )
          v4 = str_to_bool(value, *(_DWORD *)p->varptr);
        else
          v4 = atoi(value);
        *v3 = v4;
      }
      break;
    case 1:
      v6 = p->varptr;
      if ( p->inputtype == 1 )
        v7 = str_to_bool(value, *(__int16 *)p->varptr);
      else
        v7 = atoi(value);
      *v6 = v7;
      break;
    case 2:
      v8 = p->varptr;
      if ( p->inputtype == 1 )
        v9 = str_to_bool(value, *(char *)p->varptr);
      else
        v9 = atoi(value);
      *v8 = v9;
      break;
    case 3:
      *(_BYTE *)p->varptr = *value;
      break;
    case 4:
      *(_DWORD *)p->varptr = value;
      break;
    case 6:
      v10 = p->varptr;
      *v10 = str_to_color(value);
      break;
    case 7:
      v11 = (wc_ces *)p->varptr;
      *v11 = wc_guess_charset_short(value, *v11);
      break;
    case 8:
      ppc = atof(value);
      if ( ppc >= 4.0 && ppc <= 64.0 )
        *(double *)p->varptr = ppc;
      break;
    case 9:
      if ( atoi(value) > 0 )
      {
        v5 = p->varptr;
        *v5 = atoi(value);
      }
      break;
    case 0xA:
      ppca = atof(value);
      if ( ppca >= 10.0 && ppca <= 1000.0 )
        *(double *)p->varptr = ppca;
      break;
    default:
      return 1;
  }
  return 1;
}

//----- (08092C20) --------------------------------------------------------
int __cdecl set_param_option(char *option)
{
  int v1; // eax
  int result; // eax
  char *q; // [esp+14h] [ebp-14h]
  char *qa; // [esp+14h] [ebp-14h]
  Str tmp; // [esp+1Ch] [ebp-Ch]

  tmp = Strnew();
  while ( *option && (MYCTYPE_MAP[(unsigned __int8)*option] & 2) == 0 && *option != 61 )
  {
    if ( tmp->length + 1 >= tmp->area_size )
      Strgrow(tmp);
    v1 = tmp->length;
    tmp->ptr[v1] = *option;
    tmp->length = v1 + 1;
    ++option;
    tmp->ptr[tmp->length] = 0;
  }
  while ( *option && (MYCTYPE_MAP[(unsigned __int8)*option] & 2) != 0 )
    ++option;
  if ( *option == 61 )
  {
    ++option;
    while ( *option && (MYCTYPE_MAP[(unsigned __int8)*option] & 2) != 0 )
      ++option;
  }
  Strlower(tmp);
  if ( set_param(tmp->ptr, option) )
    goto option_assigned;
  q = tmp->ptr;
  if ( !strncmp(tmp->ptr, "no", 2u) )
  {
    qa = q + 2;
    if ( *qa == 45 || *qa == 95 )
      ++qa;
  }
  else
  {
    if ( *tmp->ptr != 45 )
      return 0;
    qa = q + 1;
  }
  if ( set_param(qa, "0") )
option_assigned:
    result = 1;
  else
    result = 0;
  return result;
}

//----- (08092DCD) --------------------------------------------------------
char *__cdecl get_param_option(char *name)
{
  char *result; // eax
  param_ptr *p; // [esp+1Ch] [ebp-Ch]

  p = search_param(name);
  if ( p )
    result = to_str(p)->ptr;
  else
    result = 0;
  return result;
}

//----- (08092DFD) --------------------------------------------------------
void __cdecl interpret_rc(FILE *f)
{
  int v1; // eax
  char *p; // [esp+14h] [ebp-14h]
  Str tmp; // [esp+18h] [ebp-10h]
  Str line; // [esp+1Ch] [ebp-Ch]

  while ( 1 )
  {
    line = Strfgets(f);
    Strchop(line);
    if ( !line->length )
      break;
    Strremovefirstspaces(line);
    if ( *line->ptr != 35 )
    {
      tmp = Strnew();
      for ( p = line->ptr; *p && (MYCTYPE_MAP[(unsigned __int8)*p] & 2) == 0; ++p )
      {
        if ( tmp->length + 1 >= tmp->area_size )
          Strgrow(tmp);
        v1 = tmp->length;
        tmp->ptr[v1] = *p;
        tmp->length = v1 + 1;
        tmp->ptr[tmp->length] = 0;
      }
      while ( *p && (MYCTYPE_MAP[(unsigned __int8)*p] & 2) != 0 )
        ++p;
      Strlower(tmp);
      set_param(tmp->ptr, p);
    }
  }
}

//----- (08092F21) --------------------------------------------------------
void parse_proxy()
{
  if ( non_null(HTTP_proxy) )
    parseURL(HTTP_proxy, &HTTP_proxy_parsed, 0);
  if ( non_null(GOPHER_proxy) )
    parseURL(GOPHER_proxy, &GOPHER_proxy_parsed, 0);
  if ( non_null(FTP_proxy) )
    parseURL(FTP_proxy, &FTP_proxy_parsed, 0);
  if ( non_null(NO_proxy) )
    NO_proxy_domains = make_domain_list(NO_proxy);
}

//----- (08092FD6) --------------------------------------------------------
void parse_cookie()
{
  if ( non_null(cookie_reject_domains) )
    Cookie_reject_domains = make_domain_list(cookie_reject_domains);
  if ( non_null(cookie_accept_domains) )
    Cookie_accept_domains = make_domain_list(cookie_accept_domains);
}

//----- (08093024) --------------------------------------------------------
void sync_with_option()
{
  if ( PagerMax < LINES )
    PagerMax = LINES;
  WrapSearch = WrapDefault;
  parse_proxy();
  parse_cookie();
  initMailcap();
  initMimeTypes();
  initURIMethods();
  init_migemo();
  if ( fmInitialized && displayImage )
    initImage();
  loadPasswd();
  loadPreForm();
  if ( !AcceptLang || !*AcceptLang )
    AcceptLang = gettext("en;q=1.0");
  if ( !AcceptEncoding || !*AcceptEncoding )
    AcceptEncoding = acceptableEncoding();
  if ( !AcceptMedia || !*AcceptMedia )
    AcceptMedia = acceptableMimeTypes();
  if ( fmInitialized )
  {
    initKeymap(0);
    initMouseAction();
    initMenu();
  }
}

//----- (08093115) --------------------------------------------------------
void init_rc()
{
  char *v0; // eax
  char *v1; // eax
  stat st; // [esp+10h] [ebp-68h] BYREF
  FILE *f; // [esp+68h] [ebp-10h]
  int i; // [esp+6Ch] [ebp-Ch]

  if ( !rc_dir )
  {
    rc_dir = expandPath("~/.w3m");
    i = strlen(rc_dir);
    if ( i > 1 && rc_dir[i - 1] == 47 )
      rc_dir[i - 1] = 0;
    display_charset_str = wc_get_ces_list();
    document_charset_str = display_charset_str;
    system_charset_str = display_charset_str;
    if ( stat_0(rc_dir, (int)&st) < 0 )
    {
      if ( *__errno_location() != 2 )
      {
        fprintf(stderr, "Can't open config directory (%s)!", rc_dir);
        goto rc_dir_err;
      }
      if ( mkdir(rc_dir, 0x1C0u) < 0 )
      {
        fprintf(stderr, "Can't create config directory (%s)!", rc_dir);
        goto rc_dir_err;
      }
      stat_0(rc_dir, (int)&st);
    }
    if ( (st.st_mode & 0xF000) != 0x4000 )
    {
      fprintf(stderr, "%s is not a directory!", rc_dir);
      goto rc_dir_err;
    }
    if ( (st.st_mode & 0x80) == 0 )
    {
      fprintf(stderr, "%s is not writable!", rc_dir);
rc_dir_err:
      no_rc_dir = 1;
      tmp_dir = getenv("TMPDIR");
      if ( !tmp_dir || !*tmp_dir )
      {
        tmp_dir = getenv("TMP");
        if ( !tmp_dir || !*tmp_dir )
        {
          tmp_dir = getenv("TEMP");
          if ( !tmp_dir || !*tmp_dir )
            tmp_dir = "/tmp";
        }
      }
      return;
    }
    no_rc_dir = 0;
    tmp_dir = rc_dir;
    if ( !config_file )
      config_file = rcFile("config");
    create_option_search_table();
  }
  v0 = etcFile("w3mconfig");
  f = fopen(v0, "rt");
  if ( f )
  {
    interpret_rc(f);
    fclose(f);
  }
  v1 = confFile("config");
  f = fopen(v1, "rt");
  if ( f )
  {
    interpret_rc(f);
    fclose(f);
  }
  f = fopen(config_file, "rt");
  if ( f )
  {
    interpret_rc(f);
    fclose(f);
  }
}

//----- (08093413) --------------------------------------------------------
Str __cdecl to_str(param_ptr *p)
{
  Str result; // eax
  wc_ces v2; // esi
  wc_ces v3; // ebx
  _Str *v4; // eax
  Str v5; // eax

  switch ( p->type )
  {
    case 0:
    case 6:
    case 7:
    case 9:
      result = Sprintf("%d", *(_DWORD *)p->varptr);
      break;
    case 1:
      result = Sprintf("%d", *(__int16 *)p->varptr);
      break;
    case 2:
      result = Sprintf("%d", *(char *)p->varptr);
      break;
    case 3:
      result = Sprintf("%c", *(char *)p->varptr);
      break;
    case 4:
      v2 = InnerCharset;
      v3 = SystemCharset;
      v4 = Strnew_charp(*(char **)p->varptr);
      v5 = wc_Str_conv(v4, v3, v2);
      result = Strnew_charp(v5->ptr);
      break;
    case 8:
    case 0xA:
      result = Sprintf("%g", *(double *)p->varptr);
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

//----- (08093526) --------------------------------------------------------
Buffer *load_option_panel()
{
  char *v0; // ebx
  Str v1; // eax
  char *v2; // eax
  wc_ces v3; // edi
  wc_ces v4; // esi
  char *v5; // eax
  _Str *v6; // eax
  wc_ces v7; // esi
  wc_ces v8; // ebx
  char *v9; // eax
  _Str *v10; // eax
  wc_ces v11; // esi
  wc_ces v12; // ebx
  char *v13; // eax
  _Str *v14; // eax
  wc_ces v15; // esi
  wc_ces v16; // ebx
  char *v17; // eax
  _Str *v18; // eax
  _Str *v19; // eax
  int v20; // eax
  Str v21; // eax
  char *v22; // eax
  Str v23; // eax
  const char *v24; // edx
  const char *v25; // eax
  _Str *v26; // eax
  int v27; // ebx
  int v28; // eax
  _Str *v29; // eax
  wc_ces v30; // ebx
  int v31; // eax
  Buffer *buf; // [esp+40h] [ebp-38h]
  Str tmp; // [esp+44h] [ebp-34h]
  Str tmpa; // [esp+44h] [ebp-34h]
  int i; // [esp+48h] [ebp-30h]
  int ia; // [esp+48h] [ebp-30h]
  int x; // [esp+4Ch] [ebp-2Ch]
  wc_ces_list *c; // [esp+50h] [ebp-28h]
  sel_c *s; // [esp+54h] [ebp-24h]
  sel_c *sa; // [esp+54h] [ebp-24h]
  sel_c *sb; // [esp+54h] [ebp-24h]
  param_ptr *p; // [esp+58h] [ebp-20h]
  param_ptr *pa; // [esp+58h] [ebp-20h]
  Str src; // [esp+5Ch] [ebp-1Ch]

  if ( !optionpanel_str )
  {
    v0 = gettext("External Viewer Setup");
    v1 = localCookie();
    v2 = html_quote(v1->ptr);
    optionpanel_str = Sprintf(
                        "<html><head><title>Option Setting Panel</title></head><body><h1 align=center>Option Setting Pane"
                        "l<br>(w3m version %s)</b></h1><form method=post action=\"file:///$LIB/w3mhelperpanel\"><input ty"
                        "pe=hidden name=mode value=panel><input type=hidden name=cookie value=\"%s\"><input type=submit v"
                        "alue=\"%s\"></form><br><form method=internal action=option>",
                        w3m_version,
                        v2,
                        v0);
  }
  OptionCharset = SystemCharset;
  if ( !OptionEncode )
  {
    optionpanel_str = wc_Str_conv(optionpanel_str, OptionCharset, InnerCharset);
    for ( i = 0; sections[i].name; ++i )
    {
      v3 = InnerCharset;
      v4 = OptionCharset;
      v5 = gettext(sections[i].name);
      v6 = Strnew_charp(v5);
      sections[i].name = wc_Str_conv(v6, v4, v3)->ptr;
      for ( p = sections[i].params; p->name; ++p )
      {
        v7 = InnerCharset;
        v8 = OptionCharset;
        v9 = gettext(p->comment);
        v10 = Strnew_charp(v9);
        p->comment = wc_Str_conv(v10, v8, v7)->ptr;
        if ( p->inputtype == 2 && p->select != colorstr )
        {
          for ( s = (sel_c *)p->select; s->text; ++s )
          {
            v11 = InnerCharset;
            v12 = OptionCharset;
            v13 = gettext(s->text);
            v14 = Strnew_charp(v13);
            s->text = wc_Str_conv(v14, v12, v11)->ptr;
          }
        }
      }
    }
    for ( sa = colorstr; sa->text; ++sa )
    {
      v15 = InnerCharset;
      v16 = OptionCharset;
      v17 = gettext(sa->text);
      v18 = Strnew_charp(v17);
      sa->text = wc_Str_conv(v18, v16, v15)->ptr;
    }
    OptionEncode = 1;
  }
  src = Strdup(optionpanel_str);
  Strcat_charp(src, "<table><tr><td>");
  ia = 0;
LABEL_58:
  if ( sections[ia].name )
  {
    Strcat_m_charp(src, "<h1>", sections[ia].name, "</h1>", 0);
    pa = sections[ia].params;
    Strcat_charp(src, "<table width=100% cellpadding=0>");
    while ( 1 )
    {
      if ( !pa->name )
      {
        Strcat_charp(src, "<tr><td></td><td><p><input type=submit value=\"OK\"></td></tr>");
        Strcat_charp(src, "</table><hr width=50%>");
        ++ia;
        goto LABEL_58;
      }
      Strcat_m_charp(src, "<tr><td>", pa->comment, 0);
      v19 = Sprintf("</td><td width=%d>", (int)(pixel_per_char * 28.0));
      savexmlstr_0(src, v19);
      v20 = pa->inputtype;
      if ( v20 == 1 )
      {
        v23 = to_str(pa);
        x = atoi(v23->ptr);
        if ( x )
          v24 = (const char *)&unk_80CE2D8;
        else
          v24 = " checked";
        if ( x )
          v25 = " checked";
        else
          v25 = (const char *)&unk_80CE2D8;
        Strcat_m_charp(
          src,
          "<input type=radio name=",
          pa->name,
          " value=1",
          v25,
          ">YES&nbsp;&nbsp;<input type=radio name=",
          pa->name,
          " value=0",
          v24,
          ">NO",
          0);
      }
      else if ( v20 > 1 )
      {
        if ( v20 == 2 )
        {
          tmp = to_str(pa);
          Strcat_m_charp(src, "<select name=", pa->name, ">", 0);
          for ( sb = (sel_c *)pa->select; sb->text; ++sb )
          {
            Strcat_charp(src, "<option value=");
            v26 = Sprintf("%s\n", sb->cvalue);
            savexmlstr_0(src, v26);
            if ( pa->type != 3 && (v27 = sb->value, v27 == atoi(tmp->ptr))
              || pa->type == 3 && (unsigned __int8)sb->value == *tmp->ptr )
            {
              Strcat_charp(src, " selected");
            }
            if ( src->length + 1 >= src->area_size )
              Strgrow(src);
            v28 = src->length;
            src->ptr[v28] = 62;
            src->length = v28 + 1;
            src->ptr[src->length] = 0;
            Strcat_charp(src, sb->text);
          }
          goto LABEL_54;
        }
        if ( v20 == 3 )
        {
          tmpa = to_str(pa);
          Strcat_m_charp(src, "<select name=", pa->name, ">", 0);
          for ( c = *(wc_ces_list **)pa->select; c->desc; ++c )
          {
            Strcat_charp(src, "<option value=");
            v29 = Sprintf("%s\n", c->name);
            savexmlstr_0(src, v29);
            v30 = c->id;
            if ( v30 == atoi(tmpa->ptr) )
              Strcat_charp(src, " selected");
            if ( src->length + 1 >= src->area_size )
              Strgrow(src);
            v31 = src->length;
            src->ptr[v31] = 62;
            src->length = v31 + 1;
            src->ptr[src->length] = 0;
            Strcat_charp(src, c->desc);
          }
LABEL_54:
          Strcat_charp(src, "</select>");
          goto LABEL_55;
        }
      }
      else if ( !v20 )
      {
        v21 = to_str(pa);
        v22 = html_quote(v21->ptr);
        Strcat_m_charp(src, "<input type=text name=", pa->name, " value=\"", v22, "\">", 0);
      }
LABEL_55:
      Strcat_charp(src, "</td></tr>\n");
      ++pa;
    }
  }
  Strcat_charp(src, "</table></form></body></html>");
  buf = loadHTMLString(src);
  if ( buf )
    buf->document_charset = OptionCharset;
  return buf;
}

//----- (08093C71) --------------------------------------------------------
void __cdecl panel_set_option(parsed_tagarg *arg)
{
  wc_ces v1; // esi
  wc_ces v2; // ebx
  _Str *v3; // eax
  Str v4; // eax
  const char *p; // [esp+18h] [ebp-10h]
  FILE *f; // [esp+1Ch] [ebp-Ch]

  f = 0;
  if ( no_rc_dir )
  {
    disp_message("There's no ~/.w3m directory... config not saved", 0);
  }
  else
  {
    f = fopen(config_file, "wt");
    if ( !f )
      disp_message("Can't write option!", 0);
  }
  while ( arg )
  {
    if ( arg->value )
    {
      v1 = SystemCharset;
      v2 = InnerCharset;
      v3 = Strnew_charp(arg->value);
      v4 = wc_Str_conv_strict(v3, v2, v1);
      p = v4->ptr;
      if ( set_param(arg->arg, v4->ptr) )
      {
        if ( f )
          fprintf(f, "%s %s\n", arg->arg, p);
      }
    }
    arg = arg->next;
  }
  if ( f )
    fclose(f);
  sync_with_option();
  backBf();
}

//----- (08093D8E) --------------------------------------------------------
char *__cdecl rcFile(char *base)
{
  Str v2; // eax

  if ( base
    && (*base == 47 || *base == 46 && (base[1] == 47 || base[1] == 46 && base[2] == 47) || *base == 126 && base[1] == 47) )
  {
    return expandPath(base);
  }
  v2 = Strnew_m_charp(rc_dir, "/", base, 0);
  return expandPath(v2->ptr);
}

//----- (08093E29) --------------------------------------------------------
char *__cdecl auxbinFile(char *base)
{
  char *v1; // eax
  Str v2; // eax

  v1 = w3m_auxbin_dir();
  v2 = Strnew_m_charp(v1, "/", base, 0);
  return expandPath(v2->ptr);
}

//----- (08093E5F) --------------------------------------------------------
char *__cdecl etcFile(char *base)
{
  char *v1; // eax
  Str v2; // eax

  v1 = w3m_etc_dir();
  v2 = Strnew_m_charp(v1, "/", base, 0);
  return expandPath(v2->ptr);
}

//----- (08093E95) --------------------------------------------------------
char *__cdecl confFile(char *base)
{
  char *v1; // eax
  Str v2; // eax

  v1 = w3m_conf_dir();
  v2 = Strnew_m_charp(v1, "/", base, 0);
  return expandPath(v2->ptr);
}

//----- (08093ECC) --------------------------------------------------------
void __cdecl new_menu(Menu *menu, MenuItem *item)
{
  char *p; // [esp+14h] [ebp-14h]
  int l; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]
  int ia; // [esp+1Ch] [ebp-Ch]
  int ib; // [esp+1Ch] [ebp-Ch]

  menu->cursorX = 0;
  menu->cursorY = 0;
  menu->x = 0;
  menu->y = 0;
  menu->nitem = 0;
  menu->item = item;
  menu->initial = 0;
  menu->select = 0;
  menu->offset = 0;
  menu->active = 0;
  if ( item )
  {
    for ( i = 0; item[i].type; ++i )
      ;
    menu->nitem = i;
    menu->height = menu->nitem;
    for ( ia = 0; ia <= 127; ++ia )
      menu->keymap[ia] = MenuKeymap[ia];
    menu->width = 0;
    for ( ib = 0; menu->nitem > ib; ++ib )
    {
      p = item[ib].keys;
      if ( p )
      {
        while ( *p )
        {
          if ( (MYCTYPE_MAP[(unsigned __int8)*p] & 0x11) != 0 )
          {
            menu->keymap[*p] = mSelect;
            menu->keyselect[*p] = ib;
          }
          ++p;
        }
      }
      l = wtf_strwidth((wc_uchar *)item[ib].label);
      if ( menu->width < l )
        menu->width = l;
    }
  }
}

//----- (08094062) --------------------------------------------------------
void __cdecl geom_menu(Menu *menu, int x, int y, int mselect)
{
  int win_h; // [esp+4h] [ebp-14h]
  int win_w; // [esp+8h] [ebp-10h]
  int win_y; // [esp+Ch] [ebp-Ch]
  int win_x; // [esp+10h] [ebp-8h]

  menu->select = mselect;
  if ( menu->width % FRAME_WIDTH )
    menu->width = FRAME_WIDTH * (menu->width / FRAME_WIDTH + 1);
  win_x = menu->x - FRAME_WIDTH;
  win_w = 2 * FRAME_WIDTH + menu->width;
  if ( win_w + win_x > COLS )
    win_x = COLS - win_w;
  if ( win_x < 0 )
  {
    win_x = 0;
    if ( win_w > COLS )
    {
      menu->width = COLS - 2 * FRAME_WIDTH;
      menu->width -= menu->width % FRAME_WIDTH;
    }
  }
  menu->x = win_x + FRAME_WIDTH;
  win_y = menu->y - mselect - 1;
  win_h = menu->height + 2;
  if ( win_h + win_y > LINES - 1 )
    win_y = LINES - 1 - win_h;
  if ( win_y < 0 )
  {
    win_y = 0;
    if ( win_h > LINES - 1 )
    {
      menu->height = LINES - 3;
      if ( menu->height <= mselect )
        menu->offset = mselect - menu->height + 1;
    }
  }
  menu->y = win_y + 1;
}

//----- (08094220) --------------------------------------------------------
void __cdecl draw_all_menu(Menu *menu)
{
  if ( menu->parent )
    draw_all_menu(menu->parent);
  draw_menu(menu);
}

//----- (08094249) --------------------------------------------------------
void __cdecl draw_menu(Menu *menu)
{
  int j; // [esp+2Ch] [ebp-1Ch]
  int i; // [esp+30h] [ebp-18h]
  int ia; // [esp+30h] [ebp-18h]
  int ib; // [esp+30h] [ebp-18h]
  int ic; // [esp+30h] [ebp-18h]
  int w; // [esp+34h] [ebp-14h]
  int y; // [esp+38h] [ebp-10h]
  int ya; // [esp+38h] [ebp-10h]
  int x; // [esp+3Ch] [ebp-Ch]

  x = menu->x - FRAME_WIDTH;
  w = 2 * FRAME_WIDTH + menu->width;
  y = menu->y - 1;
  if ( menu->offset )
  {
    if ( graph_mode_0 )
      graphstart();
    move(y, x);
    addstr(FRAME[5]);
    if ( graph_mode_0 )
      graphend();
    for ( ia = FRAME_WIDTH; w - FRAME_WIDTH > ia; ++ia )
    {
      move(y, x + ia);
      addstr(" ");
    }
    if ( graph_mode_0 )
      graphstart();
    move(y, x + ia);
    addstr(FRAME[5]);
    if ( graph_mode_0 )
      graphend();
    move(y, x + (w / 2 - 1) / FRAME_WIDTH * FRAME_WIDTH);
    addstr(":");
  }
  else
  {
    if ( graph_mode_0 )
      graphstart();
    move(y, x);
    addstr(FRAME[3]);
    for ( i = FRAME_WIDTH; w - FRAME_WIDTH > i; i += FRAME_WIDTH )
    {
      move(y, x + i);
      addstr(FRAME[10]);
    }
    move(y, x + i);
    addstr(FRAME[6]);
    if ( graph_mode_0 )
      graphend();
  }
  for ( j = 0; menu->height > j; ++j )
  {
    ++y;
    if ( graph_mode_0 )
      graphstart();
    move(y, x);
    addstr(FRAME[5]);
    if ( graph_mode_0 )
      graphend();
    draw_menu_item(menu, j + menu->offset);
    if ( graph_mode_0 )
      graphstart();
    move(y, w + x - FRAME_WIDTH);
    addstr(FRAME[5]);
    if ( graph_mode_0 )
      graphend();
  }
  ya = y + 1;
  if ( menu->height + menu->offset == menu->nitem )
  {
    if ( graph_mode_0 )
      graphstart();
    move(ya, x);
    addstr(FRAME[9]);
    for ( ib = FRAME_WIDTH; w - FRAME_WIDTH > ib; ib += FRAME_WIDTH )
    {
      move(ya, x + ib);
      addstr(FRAME[10]);
    }
    move(ya, x + ib);
    addstr(FRAME[12]);
    if ( graph_mode_0 )
      graphend();
  }
  else
  {
    if ( graph_mode_0 )
      graphstart();
    move(ya, x);
    addstr(FRAME[5]);
    if ( graph_mode_0 )
      graphend();
    for ( ic = FRAME_WIDTH; w - FRAME_WIDTH > ic; ++ic )
    {
      move(ya, x + ic);
      addstr(" ");
    }
    if ( graph_mode_0 )
      graphstart();
    move(ya, x + ic);
    addstr(FRAME[5]);
    if ( graph_mode_0 )
      graphend();
    move(ya, x + (w / 2 - 1) / FRAME_WIDTH * FRAME_WIDTH);
    addstr(":");
  }
}

//----- (0809473B) --------------------------------------------------------
void __cdecl draw_menu_item(Menu *menu, int mselect)
{
  move(mselect + menu->y - menu->offset, menu->x);
  addnstr_sup(menu->item[mselect].label, menu->width);
}

//----- (08094794) --------------------------------------------------------
int __cdecl select_menu(Menu *menu, int mselect)
{
  if ( mselect < 0 || menu->nitem <= mselect )
    return -1;
  if ( menu->offset <= mselect )
  {
    if ( menu->offset + menu->height <= mselect )
      down_menu(menu, mselect - menu->offset - menu->height + 1);
  }
  else
  {
    up_menu(menu, menu->offset - mselect);
  }
  if ( menu->select >= menu->offset && menu->select < menu->offset + menu->height )
    draw_menu_item(menu, menu->select);
  menu->select = mselect;
  standout();
  draw_menu_item(menu, menu->select);
  standend();
  move(mselect + menu->y - menu->offset, menu->x);
  toggle_stand();
  refresh();
  return menu->select;
}

//----- (080948BD) --------------------------------------------------------
void __cdecl goto_menu(Menu *menu, int mselect, int down)
{
  int select_in; // [esp+1Ch] [ebp-Ch]

  if ( menu->nitem > mselect )
  {
    if ( mselect < 0 )
      mselect = 0;
  }
  else
  {
    mselect = menu->nitem - 1;
  }
  select_in = mselect;
  while ( menu->item[mselect].type == 1 )
  {
    if ( down <= 0 )
    {
      if ( down >= 0 )
        return;
      if ( --mselect < 0 )
      {
        up_menu(menu, menu->select - select_in);
        mselect = menu->select;
        break;
      }
    }
    else if ( ++mselect >= menu->nitem )
    {
      down_menu(menu, select_in - menu->select);
      mselect = menu->select;
      break;
    }
  }
  select_menu(menu, mselect);
}

//----- (08094992) --------------------------------------------------------
void __cdecl up_menu(Menu *menu, int n)
{
  if ( n >= 0 && menu->offset )
  {
    menu->offset -= n;
    if ( menu->offset < 0 )
      menu->offset = 0;
    draw_menu(menu);
  }
}

//----- (080949E0) --------------------------------------------------------
void __cdecl down_menu(Menu *menu, int n)
{
  if ( n >= 0 && menu->height + menu->offset != menu->nitem )
  {
    menu->offset += n;
    if ( menu->height + menu->offset > menu->nitem )
      menu->offset = menu->nitem - menu->height;
    draw_menu(menu);
  }
}

//----- (08094A54) --------------------------------------------------------
int __cdecl action_menu(Menu *menu)
{
  int result; // eax
  MenuItem *v2; // eax
  int item; // [esp+18h] [ebp-30h]
  int *item_8; // [esp+20h] [ebp-28h]
  int item_12; // [esp+24h] [ebp-24h]
  void (*item_16)(void); // [esp+28h] [ebp-20h]
  char *item_28; // [esp+34h] [ebp-14h]
  int mselect; // [esp+38h] [ebp-10h]
  char c; // [esp+3Fh] [ebp-9h]

  if ( menu->active )
  {
    draw_all_menu(menu);
    select_menu(menu, menu->select);
    while ( 1 )
    {
      if ( use_mouse )
        mouse_active();
      c = do_getch();
      if ( use_mouse )
        mouse_inactive();
      if ( c == -1 )
      {
        mselect = X_Mouse_Selection;
        if ( X_Mouse_Selection != -1 )
          break;
      }
      if ( (MYCTYPE_MAP[(unsigned __int8)c] & 0x11) != 0 )
      {
        mselect = menu->keymap[c](c);
        if ( mselect != -1 )
          break;
      }
    }
    if ( mselect < 0 || menu->nitem <= mselect )
    {
      if ( mselect == -3 && menu->parent )
        menu->parent->active = 0;
    }
    else
    {
      v2 = &menu->item[mselect];
      item = v2->type;
      item_8 = v2->variable;
      item_12 = v2->value;
      item_16 = (void (*)(void))v2->func;
      item_28 = v2->data;
      if ( (v2->type & 8) != 0 )
      {
        popup_menu(menu, v2->popup);
        return 1;
      }
      if ( menu->parent )
        menu->parent->active = 0;
      if ( (item & 2) != 0 )
        *item_8 = item_12;
      if ( (item & 4) != 0 )
      {
        CurrentKey = -1;
        CurrentKeyData = 0;
        CurrentCmdData = item_28;
        item_16();
        CurrentCmdData = 0;
      }
    }
    result = 0;
  }
  else
  {
    if ( menu->parent )
      menu->parent->active = 0;
    result = 0;
  }
  return result;
}

//----- (08094C1B) --------------------------------------------------------
void __cdecl popup_menu(Menu *parent, Menu *menu)
{
  int active; // [esp+1Ch] [ebp-Ch]

  active = 1;
  if ( menu->item && menu->nitem && !menu->active )
  {
    gpm_handler = (int)gpm_process_menu_mouse;
    menu->parent = parent;
    menu->select = menu->initial;
    menu->offset = 0;
    menu->active = 1;
    if ( parent )
    {
      menu->cursorX = parent->cursorX;
      menu->cursorY = parent->cursorY;
      guess_menu_xy(parent, menu->width, &menu->x, &menu->y);
    }
    geom_menu(menu, menu->x, menu->y, menu->select);
    CurrentMenu = menu;
    while ( active )
    {
      active = action_menu(CurrentMenu);
      displayBuffer(CurrentTab->currentBuffer, 1);
    }
    menu->active = 0;
    CurrentMenu = parent;
    if ( !parent )
      gpm_handler = (int)gpm_process_mouse;
  }
}
// 817C1E0: using guessed type int gpm_handler;

//----- (08094D5C) --------------------------------------------------------
void __cdecl guess_menu_xy(Menu *parent, int width, int *x, int *y)
{
  *x = parent->width + parent->x + FRAME_WIDTH - 1;
  if ( FRAME_WIDTH + width + *x > COLS )
  {
    *x = COLS - width - FRAME_WIDTH;
    if ( parent->width / 2 + parent->x > *x && parent->width / 2 + parent->x > COLS / 2 )
      *x = parent->x - width - FRAME_WIDTH + 1;
  }
  *y = parent->select + parent->y - parent->offset;
}

//----- (08094E38) --------------------------------------------------------
void __cdecl new_option_menu(Menu *menu, char **label, int *variable, void (*func)(...))
{
  MenuItem *item; // [esp+10h] [ebp-18h]
  char **p; // [esp+14h] [ebp-14h]
  char **pa; // [esp+14h] [ebp-14h]
  int nitem; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]
  int ia; // [esp+1Ch] [ebp-Ch]

  if ( label && *label )
  {
    i = 0;
    for ( p = label; *p; ++p )
      ++i;
    nitem = i;
    item = (MenuItem *)GC_malloc(32 * (i + 1));
    ia = 0;
    pa = label;
    while ( ia < nitem )
    {
      if ( func )
        item[ia].type = 6;
      else
        item[ia].type = 2;
      item[ia].label = *pa;
      item[ia].variable = variable;
      item[ia].value = ia;
      item[ia].func = func;
      item[ia].popup = 0;
      item[ia++].keys = (char *)&unk_80CE512;
      ++pa;
    }
    item[nitem].type = 0;
    new_menu(menu, item);
  }
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (08094F62) --------------------------------------------------------
void set_menu_frame()
{
  if ( graph_ok() )
  {
    graph_mode_0 = 1;
    FRAME_WIDTH = 1;
    FRAME = graph_symbol;
  }
  else
  {
    graph_mode_0 = 0;
    FRAME_WIDTH = 0;
    FRAME = get_symbol(DisplayCharset, &FRAME_WIDTH);
    if ( !WcOption.use_wide )
      FRAME_WIDTH = 1;
  }
}

//----- (08094FD6) --------------------------------------------------------
int __cdecl mEsc(char c)
{
  char ca; // [esp+1Ch] [ebp-Ch]

  ca = do_getch();
  return MenuEscKeymap[ca](ca);
}

//----- (08095000) --------------------------------------------------------
int __cdecl mEscB(char c)
{
  int result; // eax
  char ca; // [esp+1Ch] [ebp-Ch]

  ca = do_getch();
  if ( (MYCTYPE_MAP[(unsigned __int8)ca] & 8) != 0 )
    result = mEscD(ca);
  else
    result = MenuEscBKeymap[ca](ca);
  return result;
}

//----- (08095050) --------------------------------------------------------
int __cdecl mEscD(char c)
{
  int result; // eax
  char ca; // [esp+1Ch] [ebp-1Ch]
  int d; // [esp+2Ch] [ebp-Ch]

  d = c - 48;
  ca = do_getch();
  if ( (MYCTYPE_MAP[(unsigned __int8)ca] & 8) != 0 )
  {
    d = 10 * d + ca - 48;
    ca = do_getch();
  }
  if ( ca == 126 )
    result = MenuEscDKeymap[d](126);
  else
    result = -1;
  return result;
}

//----- (080950CB) --------------------------------------------------------
int __cdecl mNull(char c)
{
  return -1;
}

//----- (080950DE) --------------------------------------------------------
int __cdecl mSelect(char c)
{
  int result; // eax

  if ( (MYCTYPE_MAP[(unsigned __int8)c] & 0x11) != 0 )
    result = select_menu(CurrentMenu, CurrentMenu->keyselect[c]);
  else
    result = -1;
  return result;
}

//----- (0809512F) --------------------------------------------------------
int __cdecl mDown(char c)
{
  if ( CurrentMenu->select < CurrentMenu->nitem - 1 )
    goto_menu(CurrentMenu, CurrentMenu->select + 1, 1);
  return -1;
}

//----- (08095184) --------------------------------------------------------
int __cdecl mUp(char c)
{
  if ( CurrentMenu->select > 0 )
    goto_menu(CurrentMenu, CurrentMenu->select - 1, -1);
  return -1;
}

//----- (080951CE) --------------------------------------------------------
int __cdecl mLast(char c)
{
  goto_menu(CurrentMenu, CurrentMenu->nitem - 1, -1);
  return -1;
}

//----- (08095205) --------------------------------------------------------
int __cdecl mTop(char c)
{
  goto_menu(CurrentMenu, 0, 1);
  return -1;
}

//----- (08095235) --------------------------------------------------------
int __cdecl mNext(char c)
{
  int mselect; // [esp+2Ch] [ebp-Ch]

  mselect = CurrentMenu->select + CurrentMenu->height;
  if ( CurrentMenu->nitem <= mselect )
    return mLast(c);
  down_menu(CurrentMenu, CurrentMenu->height);
  goto_menu(CurrentMenu, mselect, -1);
  return -1;
}

//----- (080952AE) --------------------------------------------------------
int __cdecl mPrev(char c)
{
  int mselect; // [esp+2Ch] [ebp-Ch]

  mselect = CurrentMenu->select - CurrentMenu->height;
  if ( mselect < 0 )
    return mTop(c);
  up_menu(CurrentMenu, CurrentMenu->height);
  goto_menu(CurrentMenu, mselect, 1);
  return -1;
}

//----- (08095323) --------------------------------------------------------
int __cdecl mFore(char c)
{
  if ( CurrentMenu->select < CurrentMenu->nitem - 1 )
    goto_menu(CurrentMenu, CurrentMenu->select + CurrentMenu->height - 1, CurrentMenu->height + 1);
  return -1;
}

//----- (0809538A) --------------------------------------------------------
int __cdecl mBack(char c)
{
  if ( CurrentMenu->select > 0 )
    goto_menu(CurrentMenu, CurrentMenu->select - CurrentMenu->height + 1, ~CurrentMenu->height);
  return -1;
}

//----- (080953EF) --------------------------------------------------------
int __cdecl mLineU(char c)
{
  int mselect; // [esp+2Ch] [ebp-Ch]

  mselect = CurrentMenu->select;
  if ( CurrentMenu->nitem <= mselect )
    return mLast(c);
  if ( CurrentMenu->height + CurrentMenu->offset < CurrentMenu->nitem )
  {
    down_menu(CurrentMenu, 1);
    if ( CurrentMenu->offset > mselect )
      ++mselect;
  }
  else
  {
    ++mselect;
  }
  goto_menu(CurrentMenu, mselect, 1);
  return -1;
}

//----- (0809548E) --------------------------------------------------------
int __cdecl mLineD(char c)
{
  int mselect; // [esp+2Ch] [ebp-Ch]

  mselect = CurrentMenu->select;
  if ( mselect <= 0 )
    return mTop(c);
  if ( CurrentMenu->offset > 0 )
  {
    up_menu(CurrentMenu, 1);
    if ( CurrentMenu->offset + CurrentMenu->height <= mselect )
      --mselect;
  }
  else
  {
    --mselect;
  }
  goto_menu(CurrentMenu, mselect, -1);
  return -1;
}

//----- (0809551F) --------------------------------------------------------
int __cdecl mOk(char c)
{
  int result; // eax

  if ( CurrentMenu->item[CurrentMenu->select].type == 1 )
    result = -1;
  else
    result = CurrentMenu->select;
  return result;
}

//----- (08095559) --------------------------------------------------------
int __cdecl mCancel(char c)
{
  return -2;
}

//----- (0809556C) --------------------------------------------------------
int __cdecl mClose(char c)
{
  return -3;
}

//----- (0809557F) --------------------------------------------------------
int __cdecl mSusp(char c)
{
  susp();
  draw_all_menu(CurrentMenu);
  select_menu(CurrentMenu, CurrentMenu->select);
  return -1;
}

//----- (080955BD) --------------------------------------------------------
int __cdecl menuForwardSearch(Menu *menu, char *str, int from)
{
  int result; // eax
  char *p; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]

  p = regexCompile(str, IgnoreCase);
  if ( p )
  {
    message(p, 0, 0);
    result = -1;
  }
  else
  {
    if ( from < 0 )
      from = 0;
    for ( i = from; menu->nitem > i; ++i )
    {
      if ( menu->item[i].type != 1 && __gmp_vfprintf(menu->item[i].label, -1, 1) == 1 )
        return i;
    }
    result = -1;
  }
  return result;
}

//----- (08095675) --------------------------------------------------------
int __cdecl menu_search_forward(Menu *menu, int from)
{
  int found; // [esp+28h] [ebp-10h]
  char *str; // [esp+2Ch] [ebp-Ch]
  char *stra; // [esp+2Ch] [ebp-Ch]

  str = inputLineHistSearch("Forward: ", 0, 16, TextHist, 0);
  if ( str && !*str )
    str = SearchString_0;
  if ( !str || !*str )
    return -1;
  SearchString_0 = str;
  stra = conv_search_string(str, DisplayCharset);
  menuSearchRoutine = menuForwardSearch;
  found = menuForwardSearch(menu, stra, from + 1);
  if ( WrapSearch && found == -1 )
    found = menuForwardSearch(menu, stra, 0);
  if ( found >= 0 )
    return found;
  disp_message("Not found", 1);
  return -1;
}

//----- (08095777) --------------------------------------------------------
int __cdecl mSrchF(char c)
{
  int mselect; // [esp+2Ch] [ebp-Ch]

  mselect = menu_search_forward(CurrentMenu, CurrentMenu->select);
  if ( mselect >= 0 )
    goto_menu(CurrentMenu, mselect, 1);
  return -1;
}

//----- (080957C8) --------------------------------------------------------
int __cdecl menuBackwardSearch(Menu *menu, char *str, int from)
{
  int result; // eax
  char *p; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]

  p = regexCompile(str, IgnoreCase);
  if ( p )
  {
    message(p, 0, 0);
    result = -1;
  }
  else
  {
    if ( menu->nitem <= from )
      from = menu->nitem - 1;
    for ( i = from; i >= 0; --i )
    {
      if ( menu->item[i].type != 1 && __gmp_vfprintf(menu->item[i].label, -1, 1) == 1 )
        return i;
    }
    result = -1;
  }
  return result;
}

//----- (08095885) --------------------------------------------------------
int __cdecl menu_search_backward(Menu *menu, int from)
{
  int found; // [esp+28h] [ebp-10h]
  char *str; // [esp+2Ch] [ebp-Ch]
  char *stra; // [esp+2Ch] [ebp-Ch]

  str = inputLineHistSearch("Backward: ", 0, 16, TextHist, 0);
  if ( str && !*str )
    str = SearchString_0;
  if ( !str || !*str )
    return -1;
  SearchString_0 = str;
  stra = conv_search_string(str, DisplayCharset);
  menuSearchRoutine = menuBackwardSearch;
  found = menuBackwardSearch(menu, stra, from - 1);
  if ( WrapSearch && found == -1 )
    found = menuBackwardSearch(menu, stra, menu->nitem);
  if ( found >= 0 )
    return found;
  disp_message("Not found", 1);
  return -1;
}

//----- (08095989) --------------------------------------------------------
int __cdecl mSrchB(char c)
{
  int mselect; // [esp+2Ch] [ebp-Ch]

  mselect = menu_search_backward(CurrentMenu, CurrentMenu->select);
  if ( mselect >= 0 )
    goto_menu(CurrentMenu, mselect, -1);
  return -1;
}

//----- (080959DA) --------------------------------------------------------
int __cdecl menu_search_next_previous(Menu *menu, int from, int reverse)
{
  int result; // eax
  int v4; // eax
  char *str; // [esp+18h] [ebp-10h]
  int found; // [esp+1Ch] [ebp-Ch]
  int reversea; // [esp+38h] [ebp+10h]

  if ( menuSearchRoutine )
  {
    str = conv_search_string(SearchString_0, DisplayCharset);
    reversea = reverse != 0;
    if ( menuSearchRoutine == menuBackwardSearch )
      reversea ^= 1u;
    if ( reversea )
      v4 = -1;
    else
      v4 = 1;
    found = routine_8886[reversea](menu, str, v4 + from);
    if ( WrapSearch && found == -1 )
      found = routine_8886[reversea](menu, str, reversea * menu->nitem);
    if ( found < 0 )
    {
      disp_message("Not found", 1);
      result = -1;
    }
    else
    {
      result = found;
    }
  }
  else
  {
    disp_message("No previous regular expression", 1);
    result = -1;
  }
  return result;
}

//----- (08095AD5) --------------------------------------------------------
int __cdecl mSrchN(char c)
{
  int mselect; // [esp+2Ch] [ebp-Ch]

  mselect = menu_search_next_previous(CurrentMenu, CurrentMenu->select, 0);
  if ( mselect >= 0 )
    goto_menu(CurrentMenu, mselect, 1);
  return -1;
}

//----- (08095B2E) --------------------------------------------------------
int __cdecl mSrchP(char c)
{
  int mselect; // [esp+2Ch] [ebp-Ch]

  mselect = menu_search_next_previous(CurrentMenu, CurrentMenu->select, 1);
  if ( mselect >= 0 )
    goto_menu(CurrentMenu, mselect, -1);
  return -1;
}

//----- (08095B87) --------------------------------------------------------
int mMouse_scroll_line()
{
  int result; // eax
  int i; // [esp+Ch] [ebp-4h]

  if ( relative_wheel_scroll )
    i = (CurrentMenu->height * relative_wheel_scroll_ratio + 99) / 100;
  else
    i = fixed_wheel_scroll_count;
  if ( i )
    result = i;
  else
    result = 1;
  return result;
}

//----- (08095BE6) --------------------------------------------------------
int __cdecl process_mMouse(int btn, int x, int y)
{
  int result; // eax
  int i; // [esp+10h] [ebp-18h]
  int ia; // [esp+10h] [ebp-18h]
  int ib; // [esp+10h] [ebp-18h]
  int ic; // [esp+10h] [ebp-18h]
  int id; // [esp+10h] [ebp-18h]
  int ie; // [esp+10h] [ebp-18h]
  int mselect; // [esp+14h] [ebp-14h]

  if ( x < 0 || x >= COLS || y < 0 || LINES - 1 < y )
    return -1;
  if ( btn != 3 )
  {
    if ( btn == 64 )
    {
      for ( id = 0; mMouse_scroll_line() > id; ++id )
        mLineD(32);
    }
    else if ( btn == 65 )
    {
      for ( ie = 0; mMouse_scroll_line() > ie; ++ie )
        mLineU(32);
    }
    goto LABEL_58;
  }
  if ( press_btn_8969 != 2 )
  {
    if ( press_btn_8969 > 2 )
    {
      if ( press_btn_8969 == 3 )
      {
        for ( ib = 0; mMouse_scroll_line() > ib; ++ib )
          mLineD(32);
      }
      else if ( press_btn_8969 == 4 )
      {
        for ( ic = 0; mMouse_scroll_line() > ic; ++ic )
          mLineU(32);
      }
      goto LABEL_58;
    }
    if ( press_btn_8969 )
    {
LABEL_58:
      if ( btn == 3 && press_btn_8969 != -1 )
      {
        press_btn_8969 = -1;
      }
      else
      {
        press_btn_8969 = btn;
        press_x_8970 = x;
        press_y_8971 = y;
      }
      return -1;
    }
  }
  if ( CurrentMenu->x - FRAME_WIDTH > x
    || CurrentMenu->width + CurrentMenu->x + FRAME_WIDTH <= x
    || CurrentMenu->y - 1 > y
    || CurrentMenu->y + CurrentMenu->height + 1 <= y )
  {
    return -2;
  }
  if ( CurrentMenu->x - FRAME_WIDTH <= x && CurrentMenu->x > x
    || CurrentMenu->x + CurrentMenu->width <= x && CurrentMenu->width + CurrentMenu->x + FRAME_WIDTH > x )
  {
    return -1;
  }
  if ( press_y_8971 <= y )
  {
    if ( press_y_8971 >= y )
    {
      if ( CurrentMenu->y - 1 == y )
      {
        mPrev(32);
        result = -1;
      }
      else if ( CurrentMenu->y + CurrentMenu->height == y )
      {
        mNext(32);
        result = -1;
      }
      else
      {
        mselect = y - CurrentMenu->y + CurrentMenu->offset;
        if ( CurrentMenu->item[mselect].type == 1 )
          result = -1;
        else
          result = select_menu(CurrentMenu, mselect);
      }
    }
    else
    {
      for ( ia = 0; y - press_y_8971 > ia; ++ia )
        mLineD(32);
      result = -1;
    }
  }
  else
  {
    for ( i = 0; press_y_8971 - y > i; ++i )
      mLineU(32);
    result = -1;
  }
  return result;
}

//----- (08095F06) --------------------------------------------------------
int __cdecl mMouse(char c)
{
  int y; // [esp+24h] [ebp-14h]
  int x; // [esp+28h] [ebp-10h]
  int btn; // [esp+2Ch] [ebp-Ch]

  btn = (unsigned __int8)do_getch() - 32;
  x = (unsigned __int8)do_getch() - 33;
  y = (unsigned __int8)do_getch() - 33;
  return process_mMouse(btn, x + (x < 0 ? 0x100 : 0), y + (y < 0 ? 0x100 : 0));
}

//----- (08095F71) --------------------------------------------------------
int __cdecl gpm_process_menu_mouse(Gpm_Event_0 *event, void *data)
{
  int v2; // eax
  _WORD *v3; // edx
  _WORD *v4; // eax
  _WORD *v5; // ecx
  _WORD *v6; // eax
  int btn; // [esp+1Ch] [ebp-Ch]

  btn = -1;
  if ( (event->type & 8) != 0 )
  {
    btn = 3;
  }
  else
  {
    if ( (event->type & 4) == 0 )
    {
      byte_817C201 = 2;
      v3 = (_WORD *)gpm_arg;
      v4 = (_WORD *)(gpm_arg + 4);
      *(_WORD *)(gpm_arg + 4) = event->x + gpm_zerobased;
      *v3 = *v4;
      v5 = (_WORD *)(gpm_arg + 2);
      v6 = (_WORD *)(gpm_arg + 6);
      *(_WORD *)(gpm_arg + 6) = event->y + gpm_zerobased;
      *v5 = *v6;
      *(_WORD *)(gpm_arg + 8) = 3;
      ioctl(gpm_consolefd, 0x541Cu, &byte_817C201);
      return 0;
    }
    v2 = event->buttons;
    switch ( v2 )
    {
      case 2:
        btn = 1;
        break;
      case 4:
        btn = 0;
        break;
      case 1:
        btn = 2;
        break;
    }
  }
  X_Mouse_Selection = process_mMouse(btn, event->x - 1, event->y - 1);
  return -1;
}
// 817C1E8: using guessed type int gpm_zerobased;
// 817C201: using guessed type char byte_817C201;
// 817C20C: using guessed type int gpm_arg;

//----- (080960B8) --------------------------------------------------------
void __cdecl popupMenu(int x, int y, Menu *menu)
{
  set_menu_frame();
  initSelectMenu();
  initSelTabMenu();
  menu->cursorX = CurrentTab->currentBuffer->rootX + CurrentTab->currentBuffer->cursorX;
  menu->cursorY = CurrentTab->currentBuffer->rootY + CurrentTab->currentBuffer->cursorY;
  menu->x = x + FRAME_WIDTH + 1;
  menu->y = y + 2;
  popup_menu(0, menu);
}

//----- (08096147) --------------------------------------------------------
void __cdecl find_nvp_node(int x, int y)
{
  popupMenu(x, y, &MainMenu);
}

//----- (08096169) --------------------------------------------------------
void mainMn()
{
  int y; // [esp+1Ch] [ebp-1Ch]
  int x; // [esp+20h] [ebp-18h]
  int n; // [esp+24h] [ebp-14h]
  char *data; // [esp+28h] [ebp-10h]
  Menu *menu; // [esp+2Ch] [ebp-Ch]

  menu = &MainMenu;
  x = CurrentTab->currentBuffer->cursorX + CurrentTab->currentBuffer->rootX;
  y = CurrentTab->currentBuffer->cursorY + CurrentTab->currentBuffer->rootY;
  data = searchKeyData();
  if ( data )
  {
    n = getMenuN(w3mMenuList, data);
    if ( n < 0 )
      return;
    menu = w3mMenuList[n].menu;
  }
  if ( mouse_action.in_action )
  {
    x = mouse_action.cursorX;
    y = mouse_action.cursorY;
  }
  popupMenu(x, y, menu);
}

//----- (08096237) --------------------------------------------------------
void selMn()
{
  int y; // [esp+18h] [ebp-10h]
  int x; // [esp+1Ch] [ebp-Ch]

  x = CurrentTab->currentBuffer->cursorX + CurrentTab->currentBuffer->rootX;
  y = CurrentTab->currentBuffer->cursorY + CurrentTab->currentBuffer->rootY;
  if ( mouse_action.in_action )
  {
    x = mouse_action.cursorX;
    y = mouse_action.cursorY;
  }
  popupMenu(x, y, &SelectMenu);
}

//----- (080962B6) --------------------------------------------------------
void initSelectMenu()
{
  int v0; // eax
  int v1; // eax
  wc_ces v2; // esi
  wc_ces v3; // ebx
  _Str *v4; // eax
  Str v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  char *p; // [esp+10h] [ebp-28h]
  char **label; // [esp+14h] [ebp-24h]
  Str str; // [esp+18h] [ebp-20h]
  Str stra; // [esp+18h] [ebp-20h]
  Buffer *buf; // [esp+1Ch] [ebp-1Ch]
  Buffer *bufa; // [esp+1Ch] [ebp-1Ch]
  int l; // [esp+20h] [ebp-18h]
  int len; // [esp+24h] [ebp-14h]
  int lena; // [esp+24h] [ebp-14h]
  int nitem; // [esp+28h] [ebp-10h]
  int i; // [esp+2Ch] [ebp-Ch]
  int ia; // [esp+2Ch] [ebp-Ch]
  int ib; // [esp+2Ch] [ebp-Ch]
  int ic; // [esp+2Ch] [ebp-Ch]

  len = 0;
  SelectV = -1;
  i = 0;
  for ( buf = CurrentTab->firstBuffer; buf; buf = buf->nextBuffer )
  {
    if ( CurrentTab->currentBuffer == buf )
      SelectV = i;
    ++i;
  }
  nitem = i;
  label = (char **)GC_malloc(4 * (i + 2));
  ia = 0;
  bufa = CurrentTab->firstBuffer;
  while ( ia < nitem )
  {
    str = Sprintf("<%s>", bufa->buffername);
    if ( bufa->filename )
    {
      v0 = bufa->currentURL.scheme;
      if ( v0 == 4 )
      {
        if ( strcmp(bufa->currentURL.file, "-") )
        {
          if ( str->length + 1 >= str->area_size )
            Strgrow(str);
          v1 = str->length;
          str->ptr[v1] = 32;
          str->length = v1 + 1;
          str->ptr[str->length] = 0;
          v2 = InnerCharset;
          v3 = SystemCharset;
          v4 = Strnew_charp(bufa->currentURL.real_file);
          v5 = wc_Str_conv(v4, v3, v2);
          Strcat_charp(str, v5->ptr);
        }
      }
      else if ( v0 != 254 )
      {
        if ( str->length + 1 >= str->area_size )
          Strgrow(str);
        v6 = str->length;
        str->ptr[v6] = 32;
        str->length = v6 + 1;
        str->ptr[str->length] = 0;
        p = parsedURL2Str(&bufa->currentURL)->ptr;
        if ( DecodeURL )
          p = url_unquote_conv(p, 0);
        Strcat_charp(str, p);
      }
    }
    label[ia] = str->ptr;
    if ( str->length > len )
      len = str->length;
    ++ia;
    bufa = bufa->nextBuffer;
  }
  l = wtf_strwidth(comment_9275);
  if ( l + 4 > len )
    len = l + 4;
  if ( -2 * FRAME_WIDTH + COLS < len )
    len = -2 * FRAME_WIDTH + COLS;
  if ( len <= 1 )
    v7 = 0;
  else
    v7 = (len - l + 1) / 2;
  lena = v7;
  stra = Strnew();
  for ( ib = 0; ib < lena; ++ib )
  {
    if ( stra->length + 1 >= stra->area_size )
      Strgrow(stra);
    v8 = stra->length;
    stra->ptr[v8] = 45;
    stra->length = v8 + 1;
    stra->ptr[stra->length] = 0;
  }
  Strcat_charp(stra, (char *)comment_9275);
  for ( ic = 0; ic < lena; ++ic )
  {
    if ( stra->length + 1 >= stra->area_size )
      Strgrow(stra);
    v9 = stra->length;
    stra->ptr[v9] = 45;
    stra->length = v9 + 1;
    stra->ptr[stra->length] = 0;
  }
  label[nitem] = stra->ptr;
  label[nitem + 1] = 0;
  new_option_menu(&SelectMenu, label, &SelectV, (void (*)(...))smChBuf);
  SelectMenu.initial = SelectV;
  SelectMenu.cursorX = CurrentTab->currentBuffer->cursorX + CurrentTab->currentBuffer->rootX;
  SelectMenu.cursorY = CurrentTab->currentBuffer->cursorY + CurrentTab->currentBuffer->rootY;
  SelectMenu.keymap[68] = smDelBuf;
  SelectMenu.item[nitem].type = 1;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (08096722) --------------------------------------------------------
void smChBuf()
{
  Buffer *buf; // [esp+18h] [ebp-10h]
  Buffer *bufa; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]

  if ( SelectV >= 0 && SelectMenu.nitem > SelectV )
  {
    i = 0;
    buf = CurrentTab->firstBuffer;
    while ( i < SelectV )
    {
      ++i;
      buf = buf->nextBuffer;
    }
    CurrentTab->currentBuffer = buf;
    for ( bufa = CurrentTab->firstBuffer; bufa; bufa = bufa->nextBuffer )
    {
      if ( CurrentTab->currentBuffer != bufa )
      {
        deleteImage(bufa);
        if ( clear_buffer )
          tmpClearBuffer(bufa);
      }
    }
  }
}

//----- (080967D1) --------------------------------------------------------
int __cdecl smDelBuf(char c)
{
  TabBuffer *v2; // ebx
  TabBuffer *v3; // ebx
  TabBuffer *v4; // ebx
  int v5; // eax
  Buffer *buf; // [esp+2Ch] [ebp-1Ch]
  int mselect; // [esp+30h] [ebp-18h]
  int y; // [esp+34h] [ebp-14h]
  int x; // [esp+38h] [ebp-10h]
  int i; // [esp+3Ch] [ebp-Ch]

  if ( CurrentMenu->select < 0 || CurrentMenu->select >= SelectMenu.nitem )
    return -1;
  i = 0;
  buf = CurrentTab->firstBuffer;
  while ( CurrentMenu->select > i )
  {
    ++i;
    buf = buf->nextBuffer;
  }
  if ( CurrentTab->currentBuffer == buf )
    CurrentTab->currentBuffer = buf->nextBuffer;
  v2 = CurrentTab;
  v2->firstBuffer = deleteBuffer(CurrentTab->firstBuffer, buf);
  if ( !CurrentTab->currentBuffer )
  {
    v3 = CurrentTab;
    v3->currentBuffer = nthBuffer(CurrentTab->firstBuffer, i - 1);
  }
  if ( !CurrentTab->firstBuffer )
  {
    v4 = CurrentTab;
    v4->firstBuffer = nullBuffer();
    CurrentTab->currentBuffer = CurrentTab->firstBuffer;
  }
  x = CurrentMenu->x;
  y = CurrentMenu->y;
  mselect = CurrentMenu->select;
  initSelectMenu();
  CurrentMenu->x = x;
  CurrentMenu->y = y;
  geom_menu(CurrentMenu, x, y, 0);
  v5 = mselect;
  if ( CurrentMenu->nitem - 2 <= mselect )
    v5 = CurrentMenu->nitem - 2;
  CurrentMenu->select = v5;
  displayBuffer(CurrentTab->currentBuffer, 1);
  draw_all_menu(CurrentMenu);
  select_menu(CurrentMenu, CurrentMenu->select);
  return -1;
}

//----- (0809698C) --------------------------------------------------------
void tabMn()
{
  int y; // [esp+18h] [ebp-10h]
  int x; // [esp+1Ch] [ebp-Ch]

  x = CurrentTab->currentBuffer->cursorX + CurrentTab->currentBuffer->rootX;
  y = CurrentTab->currentBuffer->cursorY + CurrentTab->currentBuffer->rootY;
  if ( mouse_action.in_action )
  {
    x = mouse_action.cursorX;
    y = mouse_action.cursorY;
  }
  popupMenu(x, y, &SelTabMenu);
}

//----- (08096A0B) --------------------------------------------------------
void initSelTabMenu()
{
  int v0; // eax
  int v1; // eax
  wc_ces v2; // esi
  wc_ces v3; // ebx
  _Str *v4; // eax
  Str v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  char *p; // [esp+1Ch] [ebp-2Ch]
  char **label; // [esp+20h] [ebp-28h]
  Str str; // [esp+24h] [ebp-24h]
  Str stra; // [esp+24h] [ebp-24h]
  Buffer *buf; // [esp+28h] [ebp-20h]
  TabBuffer *tab; // [esp+2Ch] [ebp-1Ch]
  TabBuffer *taba; // [esp+2Ch] [ebp-1Ch]
  int l; // [esp+30h] [ebp-18h]
  int len; // [esp+34h] [ebp-14h]
  int lena; // [esp+34h] [ebp-14h]
  int nitem; // [esp+38h] [ebp-10h]
  int i; // [esp+3Ch] [ebp-Ch]
  int ia; // [esp+3Ch] [ebp-Ch]
  int ib; // [esp+3Ch] [ebp-Ch]
  int ic; // [esp+3Ch] [ebp-Ch]

  len = 0;
  SelTabV = -1;
  i = 0;
  for ( tab = LastTab; tab; tab = tab->prevTab )
  {
    if ( tab == CurrentTab )
      SelTabV = i;
    ++i;
  }
  nitem = i;
  label = (char **)GC_malloc(4 * (i + 2));
  ia = 0;
  taba = LastTab;
  while ( ia < nitem )
  {
    buf = taba->currentBuffer;
    str = Sprintf("<%s>", buf->buffername);
    if ( buf->filename )
    {
      v0 = buf->currentURL.scheme;
      if ( v0 == 4 )
      {
        if ( strcmp(buf->currentURL.file, "-") )
        {
          if ( str->length + 1 >= str->area_size )
            Strgrow(str);
          v1 = str->length;
          str->ptr[v1] = 32;
          str->length = v1 + 1;
          str->ptr[str->length] = 0;
          v2 = InnerCharset;
          v3 = SystemCharset;
          v4 = Strnew_charp(buf->currentURL.real_file);
          v5 = wc_Str_conv(v4, v3, v2);
          Strcat_charp(str, v5->ptr);
        }
      }
      else if ( v0 != 254 )
      {
        p = parsedURL2Str(&buf->currentURL)->ptr;
        if ( DecodeURL )
          p = url_unquote_conv(p, 0);
        Strcat_charp(str, p);
      }
    }
    label[ia] = str->ptr;
    if ( str->length > len )
      len = str->length;
    ++ia;
    taba = taba->prevTab;
  }
  l = strlen(comment_9583);
  if ( l + 4 > len )
    len = l + 4;
  if ( -2 * FRAME_WIDTH + COLS < len )
    len = -2 * FRAME_WIDTH + COLS;
  if ( len <= 1 )
    v6 = 0;
  else
    v6 = (len - l + 1) / 2;
  lena = v6;
  stra = Strnew();
  for ( ib = 0; ib < lena; ++ib )
  {
    if ( stra->length + 1 >= stra->area_size )
      Strgrow(stra);
    v7 = stra->length;
    stra->ptr[v7] = 45;
    stra->length = v7 + 1;
    stra->ptr[stra->length] = 0;
  }
  Strcat_charp(stra, comment_9583);
  for ( ic = 0; ic < lena; ++ic )
  {
    if ( stra->length + 1 >= stra->area_size )
      Strgrow(stra);
    v8 = stra->length;
    stra->ptr[v8] = 45;
    stra->length = v8 + 1;
    stra->ptr[stra->length] = 0;
  }
  label[nitem] = stra->ptr;
  label[nitem + 1] = 0;
  new_option_menu(&SelTabMenu, label, &SelTabV, (void (*)(...))smChTab);
  SelTabMenu.initial = SelTabV;
  SelTabMenu.cursorX = CurrentTab->currentBuffer->cursorX + CurrentTab->currentBuffer->rootX;
  SelTabMenu.cursorY = CurrentTab->currentBuffer->cursorY + CurrentTab->currentBuffer->rootY;
  SelTabMenu.keymap[68] = smDelTab;
  SelTabMenu.item[nitem].type = 1;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (08096E29) --------------------------------------------------------
void smChTab()
{
  Buffer *buf; // [esp+14h] [ebp-14h]
  TabBuffer *tab; // [esp+18h] [ebp-10h]
  TabBuffer *taba; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]

  if ( SelTabV >= 0 && SelTabMenu.nitem > SelTabV )
  {
    i = 0;
    for ( tab = LastTab; i < SelTabV && tab; tab = tab->prevTab )
      ++i;
    CurrentTab = tab;
    for ( taba = LastTab; taba; taba = taba->prevTab )
    {
      if ( taba != CurrentTab )
      {
        buf = taba->currentBuffer;
        deleteImage(buf);
        if ( clear_buffer )
          tmpClearBuffer(buf);
      }
    }
  }
}

//----- (08096EDB) --------------------------------------------------------
int __cdecl smDelTab(char c)
{
  int v2; // eax
  TabBuffer *tab; // [esp+2Ch] [ebp-1Ch]
  int mselect; // [esp+30h] [ebp-18h]
  int y; // [esp+34h] [ebp-14h]
  int x; // [esp+38h] [ebp-10h]
  int i; // [esp+3Ch] [ebp-Ch]

  if ( CurrentMenu->select < 0 || CurrentMenu->select >= SelTabMenu.nitem )
    return -1;
  i = 0;
  for ( tab = LastTab; CurrentMenu->select > i && tab; tab = tab->prevTab )
    ++i;
  deleteTab(tab);
  x = CurrentMenu->x;
  y = CurrentMenu->y;
  mselect = CurrentMenu->select;
  initSelTabMenu();
  CurrentMenu->x = x;
  CurrentMenu->y = y;
  geom_menu(CurrentMenu, x, y, 0);
  v2 = mselect;
  if ( CurrentMenu->nitem - 2 <= mselect )
    v2 = CurrentMenu->nitem - 2;
  CurrentMenu->select = v2;
  displayBuffer(CurrentTab->currentBuffer, 1);
  draw_all_menu(CurrentMenu);
  select_menu(CurrentMenu, CurrentMenu->select);
  return -1;
}

//----- (0809700A) --------------------------------------------------------
void __cdecl optionMenu(int x, int y, char **label, int *variable, int initial, void (*func)(...))
{
  Menu menu; // [esp+1Ch] [ebp-43Ch] BYREF

  set_menu_frame();
  new_option_menu(&menu, label, variable, func);
  menu.cursorX = COLS - 1;
  menu.cursorY = LINES - 1;
  menu.x = x;
  menu.y = y;
  menu.initial = initial;
  popup_menu(0, &menu);
}

//----- (0809708A) --------------------------------------------------------
void __cdecl interpret_menu(FILE *mf)
{
  MenuList *v1; // ebx
  wc_ces charset; // [esp+1Ch] [ebp-2Ch]
  MenuItem *item; // [esp+20h] [ebp-28h]
  int type; // [esp+24h] [ebp-24h]
  int nitem; // [esp+28h] [ebp-20h]
  int nmenu; // [esp+2Ch] [ebp-1Ch]
  int in_menu; // [esp+30h] [ebp-18h]
  char *s; // [esp+34h] [ebp-14h]
  char *sa; // [esp+34h] [ebp-14h]
  char *sb; // [esp+34h] [ebp-14h]
  char *p; // [esp+38h] [ebp-10h] BYREF
  Str line; // [esp+3Ch] [ebp-Ch]

  in_menu = 0;
  nmenu = 0;
  nitem = 0;
  item = 0;
  charset = SystemCharset;
  while ( !feof(mf) )
  {
    line = Strfgets(mf);
    Strchop(line);
    Strremovefirstspaces(line);
    if ( line->length )
    {
      line = wc_Str_conv(line, charset, InnerCharset);
      p = line->ptr;
      s = getWord(&p);
      if ( *s != 35 )
      {
        if ( in_menu )
        {
          type = setMenuItem(&item[nitem], s, p);
          if ( type != -1 )
          {
            if ( type )
            {
              item = (MenuItem *)GC_realloc(item, 32 * (++nitem + 1));
              w3mMenuList[nmenu].item = item;
              item[nitem].type = 0;
            }
            else
            {
              in_menu = 0;
            }
          }
        }
        else if ( !strcmp(s, "menu") )
        {
          sa = getQWord(&p);
          if ( *sa )
          {
            in_menu = 1;
            nmenu = getMenuN(w3mMenuList, sa);
            if ( nmenu == -1 )
            {
              nmenu = addMenuList(&w3mMenuList, sa);
            }
            else
            {
              v1 = &w3mMenuList[nmenu];
              v1->item = (MenuItem *)GC_malloc(32);
            }
            item = w3mMenuList[nmenu].item;
            nitem = 0;
            item->type = 0;
          }
        }
        else if ( !strcmp(s, "charset") || !strcmp(s, "encoding") )
        {
          sb = getQWord(&p);
          if ( *sb )
            charset = wc_guess_charset(sb, charset);
        }
      }
    }
  }
}
// 8049E6C: using guessed type int __cdecl GC_realloc(_DWORD, _DWORD);
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (08097311) --------------------------------------------------------
void initMenu()
{
  wc_ces v0; // esi
  wc_ces v1; // ebx
  char *v2; // eax
  _Str *v3; // eax
  char *v4; // eax
  char *v5; // eax
  MenuItem *item; // [esp+14h] [ebp-14h]
  MenuList *list; // [esp+18h] [ebp-10h]
  FILE *mf; // [esp+1Ch] [ebp-Ch]
  FILE *mfa; // [esp+1Ch] [ebp-Ch]

  w3mMenuList = (MenuList *)GC_malloc(36);
  w3mMenuList->id = "Main";
  w3mMenuList->menu = &MainMenu;
  w3mMenuList->item = MainMenuItem;
  w3mMenuList[1].id = "Select";
  w3mMenuList[1].menu = &SelectMenu;
  w3mMenuList[1].item = 0;
  w3mMenuList[2].id = "SelectTab";
  w3mMenuList[2].menu = &SelTabMenu;
  w3mMenuList[2].item = 0;
  w3mMenuList[3].id = 0;
  if ( !MainMenuEncode )
  {
    MainMenuCharset = SystemCharset;
    for ( item = MainMenuItem; item->type; ++item )
    {
      v0 = InnerCharset;
      v1 = MainMenuCharset;
      v2 = gettext(item->label);
      v3 = Strnew_charp(v2);
      item->label = wc_Str_conv(v3, v1, v0)->ptr;
    }
    MainMenuEncode = 1;
  }
  v4 = confFile("menu");
  mf = fopen(v4, "rt");
  if ( mf )
  {
    interpret_menu(mf);
    fclose(mf);
  }
  v5 = rcFile("menu");
  mfa = fopen(v5, "rt");
  if ( mfa )
  {
    interpret_menu(mfa);
    fclose(mfa);
  }
  for ( list = w3mMenuList; list->id; ++list )
  {
    if ( list->item )
      new_menu(list->menu, list->item);
  }
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (080974DB) --------------------------------------------------------
int __cdecl setMenuItem(MenuItem *item, char *type, char *line)
{
  int result; // eax
  int v4; // eax
  int n; // [esp+14h] [ebp-24h]
  int f; // [esp+18h] [ebp-20h]
  char *data; // [esp+1Ch] [ebp-1Ch]
  char *keys; // [esp+20h] [ebp-18h]
  char *keysa; // [esp+20h] [ebp-18h]
  char *popup; // [esp+24h] [ebp-14h]
  char *func; // [esp+28h] [ebp-10h]
  char *label; // [esp+2Ch] [ebp-Ch]
  char *labela; // [esp+2Ch] [ebp-Ch]

  if ( !type || !*type )
    return -1;
  if ( !strcmp(type, "end") )
  {
    item->type = 0;
    result = 0;
  }
  else if ( !strcmp(type, "nop") )
  {
    item->type = 1;
    item->label = getQWord(&line);
    result = 1;
  }
  else if ( !strcmp(type, "func") )
  {
    label = getQWord(&line);
    func = getWord(&line);
    keys = getQWord(&line);
    data = getQWord(&line);
    if ( *func )
    {
      item->type = 4;
      item->label = label;
      f = getFuncList(func);
      v4 = 0;
      if ( f >= 0 )
        v4 = f;
      item->func = w3mFuncList[v4].func;
      item->keys = keys;
      item->data = data;
      result = 4;
    }
    else
    {
      result = -1;
    }
  }
  else if ( !strcmp(type, "popup") )
  {
    labela = getQWord(&line);
    popup = getQWord(&line);
    keysa = getQWord(&line);
    if ( *popup )
    {
      item->type = 8;
      item->label = labela;
      n = getMenuN(w3mMenuList, popup);
      if ( n == -1 )
        n = addMenuList(&w3mMenuList, popup);
      item->popup = w3mMenuList[n].menu;
      item->keys = keysa;
      result = 8;
    }
    else
    {
      result = -1;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (080976ED) --------------------------------------------------------
int __cdecl addMenuList(MenuList **mlist, char *id)
{
  MenuList *list; // [esp+18h] [ebp-10h]
  MenuList *lista; // [esp+18h] [ebp-10h]
  int n; // [esp+1Ch] [ebp-Ch]

  list = *mlist;
  n = 0;
  while ( list->id )
  {
    ++list;
    ++n;
  }
  *mlist = (MenuList *)GC_realloc(*mlist, 12 * n + 24);
  lista = &(*mlist)[n];
  lista->id = id;
  lista->menu = (Menu *)GC_malloc(1076);
  lista->item = (MenuItem *)GC_malloc(32);
  lista[1].id = 0;
  return n;
}
// 8049E6C: using guessed type int __cdecl GC_realloc(_DWORD, _DWORD);
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (08097796) --------------------------------------------------------
int __cdecl getMenuN(MenuList *list, char *id)
{
  int n; // [esp+1Ch] [ebp-Ch]

  n = 0;
  while ( list->id )
  {
    if ( !strcmp(id, list->id) )
      return n;
    ++list;
    ++n;
  }
  return -1;
}

//----- (080977DA) --------------------------------------------------------
LinkList *__cdecl link_menu(Buffer *buf)
{
  char *v2; // eax
  Menu menu; // [esp+1Ch] [ebp-45Ch] BYREF
  char *p; // [esp+450h] [ebp-28h]
  Str str; // [esp+454h] [ebp-24h]
  char **label; // [esp+458h] [ebp-20h]
  int linkV; // [esp+45Ch] [ebp-1Ch] BYREF
  int len; // [esp+460h] [ebp-18h]
  int nitem; // [esp+464h] [ebp-14h]
  int i; // [esp+468h] [ebp-10h]
  LinkList *l; // [esp+46Ch] [ebp-Ch]

  len = 0;
  linkV = -1;
  if ( !buf->linklist )
    return 0;
  i = 0;
  for ( l = buf->linklist; l; l = l->next )
    ++i;
  nitem = i;
  label = (char **)GC_malloc(4 * (i + 1));
  i = 0;
  for ( l = buf->linklist; l; l = l->next )
  {
    if ( l->title )
      v2 = l->title;
    else
      v2 = "(empty)";
    str = Strnew_charp(v2);
    if ( l->type == 1 )
    {
      Strcat_charp(str, " [Rel] ");
    }
    else if ( l->type == 2 )
    {
      Strcat_charp(str, " [Rev] ");
    }
    else
    {
      Strcat_charp(str, " ");
    }
    if ( l->url )
    {
      if ( DecodeURL )
        p = url_unquote_conv(l->url, buf->document_charset);
      else
        p = l->url;
    }
    else
    {
      p = (char *)&unk_80CE512;
    }
    Strcat_charp(str, p);
    label[i] = str->ptr;
    if ( str->length > len )
      len = str->length;
    ++i;
  }
  label[nitem] = 0;
  set_menu_frame();
  new_option_menu(&menu, label, &linkV, 0);
  menu.initial = 0;
  menu.cursorX = buf->cursorX + buf->rootX;
  menu.cursorY = buf->cursorY + buf->rootY;
  menu.x = menu.cursorX + FRAME_WIDTH + 1;
  menu.y = menu.cursorY + 2;
  popup_menu(0, &menu);
  if ( linkV < 0 )
    return 0;
  i = 0;
  for ( l = buf->linklist; l; l = l->next )
  {
    if ( i == linkV )
      return l;
    ++i;
  }
  return 0;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (08097A58) --------------------------------------------------------
Anchor *__cdecl accesskey_menu(Buffer *buf)
{
  Anchor *result; // eax
  char *v2; // eax
  unsigned __int8 v3; // al
  unsigned __int8 v4; // al
  Menu menu; // [esp+14h] [ebp-464h] BYREF
  char *t; // [esp+448h] [ebp-30h]
  char **label; // [esp+44Ch] [ebp-2Ch]
  int key; // [esp+450h] [ebp-28h] BYREF
  int nitem; // [esp+454h] [ebp-24h]
  int n; // [esp+458h] [ebp-20h]
  int i; // [esp+45Ch] [ebp-1Ch]
  Anchor **ap; // [esp+460h] [ebp-18h]
  Anchor *a; // [esp+464h] [ebp-14h]
  AnchorList *al_0; // [esp+468h] [ebp-10h]
  unsigned __int8 c; // [esp+46Fh] [ebp-9h]

  al_0 = buf->href;
  nitem = 0;
  key = -1;
  if ( !al_0 )
    return 0;
  for ( i = 0; al_0->nanchor > i; ++i )
  {
    a = &al_0->anchors[i];
    if ( !a->slave && a->accesskey && (MYCTYPE_MAP[a->accesskey] & 0x11) != 0 )
      ++nitem;
  }
  if ( !nitem )
    return 0;
  label = (char **)GC_malloc(4 * (nitem + 1));
  ap = (Anchor **)GC_malloc(4 * nitem);
  i = 0;
  n = 0;
  while ( al_0->nanchor > i )
  {
    a = &al_0->anchors[i];
    if ( !a->slave && a->accesskey && (MYCTYPE_MAP[a->accesskey] & 0x11) != 0 )
    {
      t = getAnchorText(buf, al_0, a);
      if ( t )
        v2 = t;
      else
        v2 = (char *)&unk_80CE512;
      label[n] = Sprintf("%c: %s", a->accesskey, v2)->ptr;
      ap[n++] = a;
    }
    ++i;
  }
  label[nitem] = 0;
  new_option_menu(&menu, label, &key, 0);
  menu.initial = 0;
  menu.cursorX = buf->cursorX + buf->rootX;
  menu.cursorY = buf->cursorY + buf->rootY;
  menu.x = menu.cursorX + FRAME_WIDTH + 1;
  menu.y = menu.cursorY + 2;
  for ( i = 0; i <= 127; ++i )
    menu.keyselect[i] = -1;
  for ( i = 0; i < nitem; ++i )
  {
    c = ap[i]->accesskey;
    menu.keymap[c] = mSelect;
    menu.keyselect[c] = i;
  }
  for ( i = 0; i < nitem; ++i )
  {
    c = ap[i]->accesskey;
    if ( (MYCTYPE_MAP[c] & 4) != 0 && menu.keyselect[n] < 0 )
    {
      if ( (MYCTYPE_MAP[c] & 4) != 0 )
        v3 = c | 0x20;
      else
        v3 = c;
      c = v3;
      menu.keymap[v3] = mSelect;
      menu.keyselect[c] = i;
      if ( (MYCTYPE_MAP[c] & 4) != 0 )
        v4 = c & 0xDF;
      else
        v4 = c;
      c = v4;
      menu.keymap[v4] = mSelect;
      menu.keyselect[c] = i;
    }
  }
  a = retrieveCurrentAnchor(buf);
  if ( a && a->accesskey && (MYCTYPE_MAP[a->accesskey] & 0x11) != 0 )
  {
    for ( i = 0; i < nitem; ++i )
    {
      if ( a->hseq == ap[i]->hseq )
      {
        menu.initial = i;
        break;
      }
    }
  }
  popup_menu(0, &menu);
  if ( key < 0 )
    result = 0;
  else
    result = ap[key];
  return result;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (08097EBD) --------------------------------------------------------
int __cdecl lmGoto(char c)
{
  if ( (MYCTYPE_MAP[(unsigned __int8)c] & 0x11) != 0 && CurrentMenu->keyselect[c] >= 0 )
  {
    goto_menu(CurrentMenu, CurrentMenu->nitem - 1, -1);
    goto_menu(CurrentMenu, 21 * CurrentMenu->keyselect[c], 1);
  }
  return -1;
}

//----- (08097F5F) --------------------------------------------------------
int __cdecl lmSelect(char c)
{
  int result; // eax

  if ( (MYCTYPE_MAP[(unsigned __int8)c] & 0x11) != 0 )
    result = select_menu(CurrentMenu, 21 * (CurrentMenu->select / 0x15u) + CurrentMenu->keyselect[c]);
  else
    result = -1;
  return result;
}

//----- (08097FE3) --------------------------------------------------------
Anchor *__cdecl list_menu(Buffer *buf)
{
  Anchor *result; // eax
  Menu menu; // [esp+10h] [ebp-468h] BYREF
  char *t; // [esp+444h] [ebp-34h]
  char **label; // [esp+448h] [ebp-30h]
  int two; // [esp+44Ch] [ebp-2Ch]
  int key; // [esp+450h] [ebp-28h] BYREF
  int nitem; // [esp+454h] [ebp-24h]
  int n; // [esp+458h] [ebp-20h]
  int i; // [esp+45Ch] [ebp-1Ch]
  Anchor **ap; // [esp+460h] [ebp-18h]
  Anchor *a; // [esp+464h] [ebp-14h]
  AnchorList *al_0; // [esp+468h] [ebp-10h]
  unsigned __int8 c; // [esp+46Fh] [ebp-9h]

  al_0 = buf->href;
  nitem = 0;
  key = -1;
  two = 0;
  if ( !al_0 )
    return 0;
  for ( i = 0; al_0->nanchor > i; ++i )
  {
    a = &al_0->anchors[i];
    if ( !a->slave )
      ++nitem;
  }
  if ( !nitem )
    return 0;
  if ( (unsigned int)nitem > 0x14 )
    two = 1;
  label = (char **)GC_malloc(4 * (nitem + 1));
  ap = (Anchor **)GC_malloc(4 * nitem);
  i = 0;
  n = 0;
  while ( al_0->nanchor > i )
  {
    a = &al_0->anchors[i];
    if ( !a->slave )
    {
      t = getAnchorText(buf, al_0, a);
      if ( !t )
        t = (char *)&unk_80CE512;
      if ( two && (unsigned int)n > 0x2B4 )
      {
        label[n] = Sprintf("  : %s", t)->ptr;
      }
      else if ( two )
      {
        label[n] = Sprintf("%c%c: %s", lmKeys2[n / 0x15u], lmKeys[n % 0x15u], t)->ptr;
      }
      else
      {
        label[n] = Sprintf("%c: %s", lmKeys[n], t)->ptr;
      }
      ap[n++] = a;
    }
    ++i;
  }
  label[nitem] = 0;
  set_menu_frame();
  set_menu_frame();
  new_option_menu(&menu, label, &key, 0);
  menu.initial = 0;
  menu.cursorX = buf->cursorX + buf->rootX;
  menu.cursorY = buf->cursorY + buf->rootY;
  menu.x = menu.cursorX + FRAME_WIDTH + 1;
  menu.y = menu.cursorY + 2;
  for ( i = 0; i <= 127; ++i )
    menu.keyselect[i] = -1;
  if ( two )
  {
    for ( i = 0; (unsigned int)i <= 0x20; ++i )
    {
      c = lmKeys2[i];
      menu.keymap[c] = lmGoto;
      menu.keyselect[c] = i;
    }
    for ( i = 0; (unsigned int)i <= 0x14; ++i )
    {
      c = lmKeys[i];
      menu.keymap[c] = lmSelect;
      menu.keyselect[c] = i;
    }
  }
  else
  {
    for ( i = 0; i < nitem; ++i )
    {
      c = lmKeys[i];
      menu.keymap[c] = mSelect;
      menu.keyselect[c] = i;
    }
  }
  a = retrieveCurrentAnchor(buf);
  if ( a )
  {
    for ( i = 0; i < nitem; ++i )
    {
      if ( a->hseq == ap[i]->hseq )
      {
        menu.initial = i;
        break;
      }
    }
  }
  popup_menu(0, &menu);
  if ( key < 0 )
    result = 0;
  else
    result = ap[key];
  return result;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (08098458) --------------------------------------------------------
int __cdecl mailcapMatch(mailcap *mcap, char *type)
{
  char v2; // al
  int v3; // edx
  int v4; // eax
  int result; // eax
  char v6; // al
  int v7; // edx
  int v8; // eax
  int level; // [esp+4h] [ebp-Ch]
  char *p; // [esp+8h] [ebp-8h]
  char *pa; // [esp+8h] [ebp-8h]
  char *typea; // [esp+1Ch] [ebp+Ch]

  for ( p = mcap->type; *p != 47; ++p )
  {
    if ( (MYCTYPE_MAP[(unsigned __int8)*p] & 4) != 0 )
      v2 = *p | 0x20;
    else
      v2 = *p;
    v3 = v2;
    if ( (MYCTYPE_MAP[(unsigned __int8)*type] & 4) != 0 )
      v4 = *type | 0x20;
    else
      v4 = *type;
    if ( v3 != v4 )
      return 0;
    ++type;
  }
  if ( *type != 47 )
    return 0;
  pa = p + 1;
  typea = type + 1;
  level = (mcap->flags & 4) != 0;
  if ( *pa == 42 )
    return level + 10;
  while ( *pa )
  {
    if ( (MYCTYPE_MAP[(unsigned __int8)*pa] & 4) != 0 )
      v6 = *pa | 0x20;
    else
      v6 = *pa;
    v7 = v6;
    if ( (MYCTYPE_MAP[(unsigned __int8)*typea] & 4) != 0 )
      v8 = *typea | 0x20;
    else
      v8 = *typea;
    if ( v7 != v8 )
      return 0;
    ++pa;
    ++typea;
  }
  if ( *typea )
    result = 0;
  else
    result = level + 20;
  return result;
}

//----- (080985E5) --------------------------------------------------------
mailcap *__cdecl searchMailcap(mailcap *table, char *type)
{
  Str command; // [esp+20h] [ebp-18h]
  int i; // [esp+24h] [ebp-14h]
  mailcap *mcap; // [esp+28h] [ebp-10h]
  int level; // [esp+2Ch] [ebp-Ch]

  level = 0;
  mcap = 0;
  if ( !table )
    return 0;
  while ( table->type )
  {
    i = mailcapMatch(table, type);
    if ( i > level )
    {
      if ( !table->test || (command = cptifil(table->test, type, 0, 0, 0), !system(command->ptr)) )
      {
        level = i;
        mcap = table;
      }
    }
    ++table;
  }
  return mcap;
}

//----- (0809869D) --------------------------------------------------------
int __cdecl matchMailcapAttr(char *p, char *attr, int len, Str *value)
{
  Str v4; // eax
  int v5; // edx
  char *q; // [esp+18h] [ebp-10h]
  int quoted; // [esp+1Ch] [ebp-Ch]
  char *pa; // [esp+30h] [ebp+8h]
  char *pb; // [esp+30h] [ebp+8h]

  q = 0;
  if ( strncasecmp(p, attr, len) )
    return 0;
  for ( pa = &p[len]; *pa && (MYCTYPE_MAP[(unsigned __int8)*pa] & 2) != 0; ++pa )
    ;
  if ( !value )
    return !*pa || *pa == 59;
  *value = Strnew();
  if ( *pa == 61 )
  {
    for ( pb = pa + 1; *pb && (MYCTYPE_MAP[(unsigned __int8)*pb] & 2) != 0; ++pb )
      ;
    quoted = 0;
    while ( *pb && (quoted || *pb != 59) )
    {
      if ( quoted || (MYCTYPE_MAP[(unsigned __int8)*pb] & 2) == 0 )
        q = pb;
      if ( quoted )
        quoted = 0;
      else
        quoted = *pb == 92;
      if ( (*value)->length + 1 >= (*value)->area_size )
        Strgrow(*value);
      v4 = *value;
      v5 = (*value)->length;
      (*value)->ptr[v5] = *pb;
      v4->length = v5 + 1;
      (*value)->ptr[(*value)->length] = 0;
      ++pb;
    }
    if ( q )
      Strshrink(*value, pb - q - 1);
  }
  return 1;
}

//----- (08098871) --------------------------------------------------------
int __cdecl extractMailcapEntry(char *mcap_entry, mailcap *mcap)
{
  int v2; // eax
  int v4; // eax
  Str tmp; // [esp+1Ch] [ebp-1Ch] BYREF
  int quoted; // [esp+20h] [ebp-18h]
  char *p; // [esp+24h] [ebp-14h]
  int k; // [esp+28h] [ebp-10h]
  int j; // [esp+2Ch] [ebp-Ch]

  bzero(mcap, 0x18u);
  for ( p = mcap_entry; *p && (MYCTYPE_MAP[(unsigned __int8)*p] & 2) != 0; ++p )
    ;
  k = -1;
  for ( j = 0; p[j] && p[j] != 59; ++j )
  {
    if ( (MYCTYPE_MAP[(unsigned __int8)p[j]] & 2) == 0 )
      k = j;
  }
  if ( k < 0 )
    v2 = j;
  else
    v2 = k + 1;
  mcap->type = allocStr(p, v2);
  if ( !p[j] )
    return 0;
  for ( p += j + 1; *p && (MYCTYPE_MAP[(unsigned __int8)*p] & 2) != 0; ++p )
    ;
  k = -1;
  quoted = 0;
  for ( j = 0; p[j] && (quoted || p[j] != 59); ++j )
  {
    if ( quoted || (MYCTYPE_MAP[(unsigned __int8)p[j]] & 2) == 0 )
      k = j;
    if ( quoted )
      quoted = 0;
    else
      quoted = p[j] == 92;
  }
  if ( k < 0 )
    v4 = j;
  else
    v4 = k + 1;
  mcap->viewer = allocStr(p, v4);
  p += j;
  while ( *p == 59 )
  {
    ++p;
    while ( *p && (MYCTYPE_MAP[(unsigned __int8)*p] & 2) != 0 )
      ++p;
    if ( matchMailcapAttr(p, "needsterminal", 13, 0) )
    {
      mcap->flags |= 1u;
    }
    else if ( matchMailcapAttr(p, "copiousoutput", 13, 0) )
    {
      mcap->flags |= 2u;
    }
    else if ( matchMailcapAttr(p, "x-htmloutput", 12, 0) || matchMailcapAttr(p, "htmloutput", 10, 0) )
    {
      mcap->flags |= 4u;
    }
    else if ( matchMailcapAttr(p, "test", 4, &tmp) )
    {
      mcap->test = allocStr(tmp->ptr, tmp->length);
    }
    else if ( matchMailcapAttr(p, "nametemplate", 12, &tmp) )
    {
      mcap->nametemplate = allocStr(tmp->ptr, tmp->length);
    }
    else if ( matchMailcapAttr(p, "edit", 4, &tmp) )
    {
      mcap->edit = allocStr(tmp->ptr, tmp->length);
    }
    quoted = 0;
    while ( *p && (quoted || *p != 59) )
    {
      if ( quoted )
        quoted = 0;
      else
        quoted = *p == 92;
      ++p;
    }
  }
  return 1;
}

//----- (08098C6A) --------------------------------------------------------
mailcap *__cdecl loadMailcap(char *filename)
{
  char *v1; // eax
  int v3; // eax
  _Str *v4; // [esp+4h] [ebp-34h]
  mailcap *mcap; // [esp+1Ch] [ebp-1Ch]
  Str tmp; // [esp+20h] [ebp-18h]
  Str tmpa; // [esp+20h] [ebp-18h]
  int i; // [esp+28h] [ebp-10h]
  int ia; // [esp+28h] [ebp-10h]
  FILE *f; // [esp+2Ch] [ebp-Ch]

  v1 = expandPath(filename);
  f = fopen(v1, "r");
  if ( !f )
    return 0;
  i = 0;
  while ( 1 )
  {
    tmp = Strfgets(f);
    if ( tmp->length <= 0 )
      break;
    if ( *tmp->ptr != 35 )
      ++i;
  }
  fseek(f, 0, 0);
  mcap = (mailcap *)GC_malloc(24 * (i + 1));
  ia = 0;
  while ( 1 )
  {
    tmpa = Strfgets(f);
    if ( tmpa->length <= 0 )
      break;
    if ( *tmpa->ptr != 35 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          v3 = tmpa->length <= 0 ? 0 : (unsigned __int8)tmpa->ptr[tmpa->length - 1];
          if ( (MYCTYPE_MAP[v3] & 2) == 0 )
            break;
          Strshrink(tmpa, 1);
        }
        if ( tmpa->length <= 0 || tmpa->ptr[tmpa->length - 1] != 92 )
          break;
        Strshrink(tmpa, 1);
        v4 = Strfgets(f);
        savexmlstr_0(tmpa, v4);
      }
      if ( extractMailcapEntry(tmpa->ptr, &mcap[ia]) )
        ++ia;
    }
  }
  bzero(&mcap[ia], 0x18u);
  fclose(f);
  return mcap;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (08098E46) --------------------------------------------------------
void initMailcap()
{
  mailcap **v0; // ebx
  int i; // [esp+18h] [ebp-10h]
  TextListItem *tl; // [esp+1Ch] [ebp-Ch]

  if ( non_null(mailcap_files) )
    mailcap_list = make_domain_list(mailcap_files);
  else
    mailcap_list = 0;
  if ( mailcap_list )
  {
    UserMailcap = (mailcap **)GC_malloc(4 * mailcap_list->nitem);
    i = 0;
    for ( tl = mailcap_list->first; tl; tl = tl->next )
    {
      v0 = &UserMailcap[i];
      *v0 = loadMailcap(tl->ptr);
      ++i;
    }
  }
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (08098EEB) --------------------------------------------------------
char *acceptableMimeTypes()
{
  char *v1; // eax
  char *v2; // eax
  char *mt; // [esp+18h] [ebp-20h]
  mailcap *mp; // [esp+1Ch] [ebp-1Ch]
  int i; // [esp+20h] [ebp-18h]
  char *p; // [esp+24h] [ebp-14h]
  char *pa; // [esp+24h] [ebp-14h]
  Hash_si_0 *mhash; // [esp+28h] [ebp-10h]
  GeneralList *l; // [esp+2Ch] [ebp-Ch]

  if ( types_8551 )
    return types_8551->ptr;
  l = newGeneralList();
  mhash = newHash_si(16);
  putHash_si(mhash, "text", 1);
  v1 = allocStr("image", -1);
  pushValue(l, v1);
  putHash_si(mhash, "image", 1);
  for ( i = 0; mailcap_list->nitem > i; ++i )
  {
    mp = UserMailcap[i];
    if ( mp )
    {
      while ( mp->type )
      {
        p = strchr(mp->type, 47);
        if ( p )
        {
          mt = allocStr(mp->type, p - mp->type);
          if ( !getHash_si(mhash, mt, 0) )
          {
            v2 = allocStr(mt, -1);
            pushValue(l, v2);
            putHash_si(mhash, mt, 1);
          }
        }
        ++mp;
      }
    }
  }
  types_8551 = Strnew();
  Strcat_charp(types_8551, "text/html, text/*;q=0.5");
  while ( 1 )
  {
    pa = (char *)popValue(l);
    if ( !pa )
      break;
    Strcat_charp(types_8551, ", ");
    Strcat_charp(types_8551, pa);
    Strcat_charp(types_8551, "/*");
  }
  return types_8551->ptr;
}

//----- (080990E3) --------------------------------------------------------
mailcap *__cdecl searchExtViewer(char *type)
{
  int i; // [esp+18h] [ebp-10h]
  mailcap *p; // [esp+1Ch] [ebp-Ch]

  if ( mailcap_list )
  {
    for ( i = 0; mailcap_list->nitem > i; ++i )
    {
      p = searchMailcap(UserMailcap[i], type);
      if ( p )
        return p;
    }
  }
  return searchMailcap(DefaultMailcap, type);
}

//----- (08099152) --------------------------------------------------------
Str __cdecl quote_mailcap(char *s, int flag)
{
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v5; // eax
  Str d; // [esp+1Ch] [ebp-Ch]

  d = Strnew();
  while ( 1 )
  {
    switch ( *s )
    {
      case 0:
        return d;
      case 34:
      case 36:
      case 92:
      case 96:
        if ( (flag & 1) == 0 )
        {
          if ( d->length + 1 >= d->area_size )
            Strgrow(d);
          v2 = d->length;
          d->ptr[v2] = 92;
          d->length = v2 + 1;
          d->ptr[d->length] = 0;
        }
        if ( d->length + 1 >= d->area_size )
          Strgrow(d);
        v3 = d->length;
        d->ptr[v3] = *s;
        d->length = v3 + 1;
        d->ptr[d->length] = 0;
        break;
      case 39:
        if ( (flag & 1) == 0 )
          goto LABEL_12;
        Strcat_charp(d, "'\\''");
        break;
      case 46:
      case 47:
      case 58:
      case 95:
        goto LABEL_17;
      default:
LABEL_12:
        if ( !flag && (MYCTYPE_MAP[(unsigned __int8)*s] & 0xC) == 0 )
        {
          if ( d->length + 1 >= d->area_size )
            Strgrow(d);
          v4 = d->length;
          d->ptr[v4] = 92;
          d->length = v4 + 1;
          d->ptr[d->length] = 0;
        }
LABEL_17:
        if ( d->length + 1 >= d->area_size )
          Strgrow(d);
        v5 = d->length;
        d->ptr[v5] = *s;
        d->length = v5 + 1;
        d->ptr[d->length] = 0;
        break;
    }
    ++s;
  }
}

//----- (0809930F) --------------------------------------------------------
Str __cdecl unquote_mailcap_loop(char *qstr, char *type, char *name, char *attr, int *mc_stat, int flag0)
{
  Str v7; // eax
  int v8; // edx
  int v9; // eax
  int v10; // eax
  int v11; // eax
  Str v12; // eax
  Str v13; // eax
  int v14; // eax
  Str v15; // eax
  int v16; // edx
  int v17; // eax
  Str v18; // eax
  Str v19; // eax
  int v20; // edx
  char *q; // [esp+18h] [ebp-30h]
  int flag; // [esp+1Ch] [ebp-2Ch]
  int sp_0; // [esp+20h] [ebp-28h]
  int prev_status; // [esp+24h] [ebp-24h]
  int status; // [esp+28h] [ebp-20h]
  char *p; // [esp+2Ch] [ebp-1Ch]
  Str tmp; // [esp+38h] [ebp-10h] BYREF
  Str str; // [esp+3Ch] [ebp-Ch]

  status = 0;
  prev_status = 0;
  sp_0 = 0;
  if ( mc_stat )
    *mc_stat = 0;
  if ( !qstr )
    return 0;
  str = Strnew();
  tmp = 0;
  flag = flag0;
  for ( p = qstr; *p; ++p )
  {
    if ( status == 3 )
    {
      if ( prev_status == 2 )
      {
        if ( tmp->length + 1 >= tmp->area_size )
          Strgrow(tmp);
        v7 = tmp;
        v8 = tmp->length;
        tmp->ptr[v8] = *p;
        v7->length = v8 + 1;
        tmp->ptr[tmp->length] = 0;
      }
      else
      {
        if ( str->length + 1 >= str->area_size )
          Strgrow(str);
        v9 = str->length;
        str->ptr[v9] = *p;
        str->length = v9 + 1;
        str->ptr[str->length] = 0;
      }
      status = prev_status;
    }
    else if ( *p == 92 )
    {
      prev_status = status;
      status = 3;
    }
    else if ( status == 1 )
    {
      if ( (MYCTYPE_MAP[(unsigned __int8)*p] & 4) != 0 )
      {
        v11 = *p;
        if ( v11 == 115 )
        {
          if ( name )
          {
            v12 = quote_mailcap(name, flag);
            Strcat_charp(str, v12->ptr);
            if ( mc_stat )
              *mc_stat |= 1u;
          }
        }
        else if ( v11 == 116 )
        {
          if ( type )
          {
            v13 = quote_mailcap(type, flag);
            Strcat_charp(str, v13->ptr);
            if ( mc_stat )
              *mc_stat |= 2u;
          }
        }
        status = 0;
      }
      else if ( *p == 123 )
      {
        status = 2;
        tmp = Strnew();
      }
      else if ( *p == 37 )
      {
        if ( str->length + 1 >= str->area_size )
          Strgrow(str);
        v14 = str->length;
        str->ptr[v14] = *p;
        str->length = v14 + 1;
        str->ptr[str->length] = 0;
      }
    }
    else if ( status == 2 )
    {
      if ( sp_0 > 0 || *p == 123 )
      {
        if ( tmp->length + 1 >= tmp->area_size )
          Strgrow(tmp);
        v15 = tmp;
        v16 = tmp->length;
        tmp->ptr[v16] = *p;
        v15->length = v16 + 1;
        tmp->ptr[tmp->length] = 0;
        v17 = *p;
        if ( v17 == 123 )
        {
          ++sp_0;
        }
        else if ( v17 == 125 )
        {
          --sp_0;
        }
      }
      else if ( *p == 125 )
      {
        if ( attr )
        {
          q = (char *)strcasestr(attr, tmp->ptr);
          if ( q )
          {
            if ( q == attr || (MYCTYPE_MAP[(unsigned __int8)*(q - 1)] & 2) != 0 || *(q - 1) == 59 )
            {
              if ( matchattr(q, tmp->ptr, tmp->length, &tmp) )
              {
                v18 = quote_mailcap(tmp->ptr, flag);
                Strcat_charp(str, v18->ptr);
                if ( mc_stat )
                  *mc_stat |= 4u;
              }
            }
          }
        }
        status = 0;
      }
      else
      {
        if ( tmp->length + 1 >= tmp->area_size )
          Strgrow(tmp);
        v19 = tmp;
        v20 = tmp->length;
        tmp->ptr[v20] = *p;
        v19->length = v20 + 1;
        tmp->ptr[tmp->length] = 0;
      }
    }
    else if ( *p == 37 )
    {
      status = 1;
    }
    else
    {
      if ( *p == 39 )
      {
        if ( flag0 || (flag & 1) == 0 )
        {
          if ( !flag )
            flag = 1;
        }
        else
        {
          flag &= 0xFFFFFFFE;
        }
      }
      else if ( *p == 34 )
      {
        if ( flag0 || (flag & 2) == 0 )
        {
          if ( !flag )
            flag = 2;
        }
        else
        {
          flag &= 0xFFFFFFFD;
        }
      }
      if ( str->length + 1 >= str->area_size )
        Strgrow(str);
      v10 = str->length;
      str->ptr[v10] = *p;
      str->length = v10 + 1;
      str->ptr[str->length] = 0;
    }
  }
  return str;
}
// 8099461: conditional instruction was optimized away because of '%status.4==0'
// 804A36C: using guessed type int __cdecl strcasestr(_DWORD, _DWORD);

//----- (08099846) --------------------------------------------------------
Str __cdecl cptifil(char *qstr, char *type, char *name, char *attr, int *mc_stat)
{
  return unquote_mailcap_loop(qstr, type, name, attr, mc_stat, 0);
}

//----- (08099880) --------------------------------------------------------
void initImage()
{
  if ( !activeImage )
  {
    if ( getCharSize() )
      activeImage = 1;
  }
}

//----- (080998A7) --------------------------------------------------------
int getCharSize()
{
  char *v0; // eax
  char *v1; // eax
  int h; // [esp+20h] [ebp-18h] BYREF
  int w; // [esp+24h] [ebp-14h] BYREF
  Str tmp; // [esp+28h] [ebp-10h]
  FILE *f; // [esp+2Ch] [ebp-Ch]

  w = 0;
  h = 0;
  v0 = ttyname_tty();
  set_environ("W3M_TTY", v0);
  tmp = Strnew();
  if ( !strchr(Imgdisplay, 47) )
  {
    v1 = w3m_auxbin_dir();
    Strcat_m_charp(tmp, v1, "/", 0);
  }
  Strcat_m_charp(tmp, Imgdisplay, " -test 2>/dev/null", 0);
  f = popen(tmp->ptr, "r");
  if ( !f )
    return 0;
  while ( fscanf(f, "%d %d", &w, &h) < 0 && !feof(f) )
    ;
  pclose(f);
  if ( w <= 0 || h <= 0 )
    return 0;
  if ( !set_pixel_per_char )
    pixel_per_char = (double)(int)((long double)w / (long double)COLS + 0.5);
  if ( !set_pixel_per_line )
    pixel_per_line = (double)(int)((long double)h / (long double)LINES + 0.5);
  return 1;
}

//----- (08099A5E) --------------------------------------------------------
void termImage()
{
  if ( activeImage )
  {
    clearImage();
    if ( Imgdisplay_wf )
    {
      fwrite("2;\n", 1u, 3u, Imgdisplay_wf);
      fflush(Imgdisplay_wf);
    }
    closeImgdisplay();
  }
}

//----- (08099AB9) --------------------------------------------------------
int openImgdisplay()
{
  char *v0; // ebx
  char *v1; // eax
  int result; // eax
  char *cmd; // [esp+1Ch] [ebp-Ch]

  Imgdisplay_pid = open_pipe_rw(&Imgdisplay_rf, &Imgdisplay_wf);
  if ( Imgdisplay_pid < 0 )
  {
    Imgdisplay_pid = 0;
    activeImage = 0;
    result = 0;
  }
  else
  {
    if ( !Imgdisplay_pid )
    {
      setup_child(0, 2, -1);
      if ( !strchr(Imgdisplay, 47) )
      {
        v0 = Imgdisplay;
        v1 = w3m_auxbin_dir();
        cmd = Strnew_m_charp(v1, "/", v0, 0)->ptr;
        myExec(cmd);
      }
      myExec(Imgdisplay);
    }
    activeImage = 1;
    result = 1;
  }
  return result;
}

//----- (08099B96) --------------------------------------------------------
void closeImgdisplay()
{
  if ( Imgdisplay_rf )
    fclose(Imgdisplay_rf);
  if ( Imgdisplay_wf )
    fclose(Imgdisplay_wf);
  if ( Imgdisplay_pid )
    kill(Imgdisplay_pid, 9);
  Imgdisplay_rf = 0;
  Imgdisplay_wf = 0;
  Imgdisplay_pid = 0;
}

//----- (08099C06) --------------------------------------------------------
void __cdecl addImage(ImageCache *cache, int x, int y, int sx, int sy, int w, int h)
{
  int v7; // eax
  TerminalImage *i; // [esp+1Ch] [ebp-Ch]

  if ( activeImage )
  {
    if ( n_terminal_image >= max_terminal_image )
    {
      if ( max_terminal_image )
        v7 = 2 * max_terminal_image;
      else
        v7 = 8;
      max_terminal_image = v7;
      terminal_image = (TerminalImage *)GC_realloc(terminal_image, 16 * v7);
    }
    i = &terminal_image[n_terminal_image];
    i->cache = cache;
    i->x = x;
    i->y = y;
    i->sx = sx;
    i->sy = sy;
    i->width = w;
    i->height = h;
    ++n_terminal_image;
  }
}
// 8049E6C: using guessed type int __cdecl GC_realloc(_DWORD, _DWORD);

//----- (08099CD9) --------------------------------------------------------
void syncImage()
{
  fwrite("3;\n", 1u, 3u, Imgdisplay_wf);
  fwrite("4;\n", 1u, 3u, Imgdisplay_wf);
  while ( fflush(Imgdisplay_wf) )
  {
    if ( ferror(Imgdisplay_wf) )
      goto err;
  }
  if ( fgetc(Imgdisplay_rf) )
    return;
err:
  closeImgdisplay();
  image_index += 1000;
  n_terminal_image = 0;
}

//----- (08099D88) --------------------------------------------------------
void drawImage()
{
  __int16 v0; // ax
  __int16 v1; // ax
  int v2; // [esp+58h] [ebp-30h]
  TerminalImage *i; // [esp+64h] [ebp-24h]
  int draw; // [esp+68h] [ebp-20h]
  int j; // [esp+6Ch] [ebp-1Ch]

  draw = 0;
  if ( activeImage && n_terminal_image )
  {
    for ( j = 0; j < n_terminal_image; ++j )
    {
      i = &terminal_image[j];
      if ( (i->cache->loaded & 1) != 0 && i->width > 0 && i->height > 0 )
      {
        if ( (!Imgdisplay_rf || !Imgdisplay_wf) && !openImgdisplay() )
          return;
        if ( i->cache->index <= 0 )
        {
          fwrite("1;", 1u, 2u, Imgdisplay_wf);
        }
        else
        {
          i->cache->index = -i->cache->index;
          fwrite("0;", 1u, 2u, Imgdisplay_wf);
        }
        v0 = i->cache->height;
        if ( v0 < 0 )
          v0 = 0;
        v2 = v0;
        v1 = i->cache->width;
        if ( v1 < 0 )
          v1 = 0;
        sprintf(
          buf_8642,
          "%d;%d;%d;%d;%d;%d;%d;%d;%d;",
          ~i->cache->index % 1000 + 1,
          i->x,
          i->y,
          v1,
          v2,
          i->sx,
          i->sy,
          i->width,
          i->height);
        fputs(buf_8642, Imgdisplay_wf);
        fputs(i->cache->file, Imgdisplay_wf);
        fputc(10, Imgdisplay_wf);
        draw = 1;
      }
    }
    if ( draw )
    {
      syncImage();
      touch_cursor();
      refresh();
    }
  }
}

//----- (0809A012) --------------------------------------------------------
void clearImage()
{
  TerminalImage *i; // [esp+28h] [ebp-10h]
  int j; // [esp+2Ch] [ebp-Ch]

  if ( activeImage && n_terminal_image )
  {
    if ( Imgdisplay_wf )
    {
      for ( j = 0; j < n_terminal_image; ++j )
      {
        i = &terminal_image[j];
        if ( (i->cache->loaded & 1) != 0 && i->width > 0 && i->height > 0 )
        {
          sprintf(buf_8728, "6;%d;%d;%d;%d\n", i->x, i->y, i->width, i->height);
          fputs(buf_8728, Imgdisplay_wf);
        }
      }
      syncImage();
      n_terminal_image = 0;
    }
    else
    {
      n_terminal_image = 0;
    }
  }
}

//----- (0809A12E) --------------------------------------------------------
void __cdecl deleteImage(Buffer *buf)
{
  int i; // [esp+14h] [ebp-14h]
  Anchor *a; // [esp+18h] [ebp-10h]
  AnchorList *al_0; // [esp+1Ch] [ebp-Ch]

  if ( buf )
  {
    al_0 = buf->img;
    if ( al_0 )
    {
      i = 0;
      a = al_0->anchors;
      while ( al_0->nanchor > i )
      {
        if ( a->image
          && a->image->cache
          && a->image->cache->loaded
          && (a->image->cache->loaded & 4) == 0
          && a->image->cache->index < 0 )
        {
          unlink(a->image->cache->file);
        }
        ++i;
        ++a;
      }
      loadImage(0, 1);
    }
  }
}

//----- (0809A1F4) --------------------------------------------------------
void __cdecl getAllImage(Buffer *buf)
{
  Image *v1; // ebx
  int i; // [esp+10h] [ebp-18h]
  ParsedURL *current; // [esp+14h] [ebp-14h]
  Anchor *a; // [esp+18h] [ebp-10h]
  AnchorList *al_0; // [esp+1Ch] [ebp-Ch]

  image_buffer = buf;
  if ( buf )
  {
    buf->image_loaded = 1;
    al_0 = buf->img;
    if ( al_0 )
    {
      current = baseURL(buf);
      i = 0;
      a = al_0->anchors;
      while ( al_0->nanchor > i )
      {
        if ( a->image )
        {
          v1 = a->image;
          v1->cache = getImage(v1, current, buf->image_flag);
          if ( a->image->cache )
          {
            if ( !a->image->cache->loaded )
              buf->image_loaded = 0;
          }
        }
        ++i;
        ++a;
      }
    }
  }
}

//----- (0809A2C9) --------------------------------------------------------
void __cdecl showImageProgress(Buffer *buf)
{
  int v1; // esi
  int v2; // ebx
  Str v3; // eax
  int n; // [esp+1Ch] [ebp-1Ch]
  int l; // [esp+20h] [ebp-18h]
  int i; // [esp+24h] [ebp-14h]
  Anchor *a; // [esp+28h] [ebp-10h]
  AnchorList *al_0; // [esp+2Ch] [ebp-Ch]

  if ( buf )
  {
    al_0 = buf->img;
    if ( al_0 )
    {
      i = 0;
      l = 0;
      n = 0;
      a = al_0->anchors;
      while ( al_0->nanchor > i )
      {
        if ( a->image )
        {
          if ( a->hseq >= 0 )
          {
            ++n;
            if ( a->image->cache )
            {
              if ( (a->image->cache->loaded & 1) != 0 )
                ++l;
            }
          }
        }
        ++i;
        ++a;
      }
      if ( n )
      {
        v1 = buf->cursorY + buf->rootY;
        v2 = buf->cursorX + buf->rootX;
        v3 = Sprintf("%d/%d images loaded", l, n);
        message(v3->ptr, v2, v1);
        refresh();
      }
    }
  }
}

//----- (0809A3CE) --------------------------------------------------------
void __cdecl loadImage(Buffer *buf, int flag)
{
  int v2; // eax
  stat st; // [esp+28h] [ebp-70h] BYREF
  Buffer *b; // [esp+80h] [ebp-18h]
  int draw; // [esp+84h] [ebp-14h]
  int i; // [esp+88h] [ebp-10h]
  ImageCache *cache; // [esp+8Ch] [ebp-Ch]

  draw = 0;
  if ( maxLoadImage <= 8 )
  {
    if ( maxLoadImage <= 0 )
      maxLoadImage = 1;
  }
  else
  {
    maxLoadImage = 8;
  }
  if ( !n_load_image )
    n_load_image = maxLoadImage;
  if ( !image_cache )
  {
    image_cache = (ImageCache **)GC_malloc(32);
    bzero(image_cache, 0x20u);
  }
  for ( i = 0; i < n_load_image; ++i )
  {
    cache = image_cache[i];
    if ( cache && !lstat(cache->touch, (int)&st) )
    {
      if ( cache->pid )
      {
        kill(cache->pid, 9);
        cache->pid = 0;
      }
      if ( stat_0(cache->file, (int)&st) )
      {
        cache->loaded = 2;
      }
      else
      {
        cache->loaded = 1;
        if ( getImageSize(cache) && image_buffer )
          image_buffer->need_reshape = 1;
        draw = 1;
      }
      unlink(cache->touch);
      image_cache[i] = 0;
    }
  }
  if ( buf == image_buffer )
    v2 = maxLoadImage;
  else
    v2 = 0;
  for ( i = v2; i < n_load_image; ++i )
  {
    cache = image_cache[i];
    if ( cache )
    {
      if ( cache->pid )
      {
        kill(cache->pid, 9);
        cache->pid = 0;
      }
      unlink(cache->touch);
      image_cache[i] = 0;
    }
  }
  if ( flag == 1 )
  {
    image_list = 0;
    image_file = 0;
    n_load_image = maxLoadImage;
    image_buffer = 0;
  }
  else
  {
    if ( draw && image_buffer )
    {
      drawImage();
      showImageProgress(image_buffer);
    }
    image_buffer = buf;
    if ( image_list )
    {
      for ( i = 0; i < n_load_image; ++i )
      {
        if ( !image_cache[i] )
        {
          do
          {
            cache = (ImageCache *)popValue(image_list);
            if ( !cache )
            {
              for ( i = 0; i < n_load_image; ++i )
              {
                if ( image_cache[i] )
                  return;
              }
              image_list = 0;
              image_file = 0;
              if ( image_buffer )
                displayBuffer(image_buffer, 0);
              return;
            }
          }
          while ( cache->loaded );
          image_cache[i] = cache;
          flush_tty();
          cache->pid = fork();
          if ( !cache->pid )
          {
            setup_child(0, 0, -1);
            image_source = cache->file;
            b = loadGeneralFile(cache->url, cache->current, 0, 0, 0);
            if ( !b || !b->real_type || strncasecmp(b->real_type, "image/", 6u) )
              unlink(cache->file);
            symlink(cache->file, cache->touch);
            exit(0);
          }
          if ( cache->pid < 0 )
          {
            cache->pid = 0;
            return;
          }
        }
      }
    }
  }
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (0809A815) --------------------------------------------------------
ImageCache *__cdecl getImage(Image *image, ParsedURL *current, int flag)
{
  Str v4; // eax
  stat st; // [esp+10h] [ebp-68h] BYREF
  ImageCache *cache; // [esp+68h] [ebp-10h]
  Str key; // [esp+6Ch] [ebp-Ch]

  key = 0;
  if ( !activeImage )
    return 0;
  if ( !image_hash )
    image_hash = newHash_sv(100);
  if ( image->cache )
  {
    cache = image->cache;
  }
  else
  {
    key = Sprintf("%d;%d;%s", image->width, image->height, image->url);
    cache = (ImageCache *)getHash_sv(image_hash, key->ptr, 0);
  }
  if ( cache && cache->index && (int)abs32(cache->index) <= image_index - 1000 )
  {
    if ( stat_0(cache->file, (int)&st) )
      cache->loaded = 0;
    cache->index = 0;
  }
  if ( !cache )
  {
    if ( flag == 1 )
      return 0;
    cache = (ImageCache *)GC_malloc(32);
    cache->url = image->url;
    cache->current = current;
    v4 = tmpfname(0, image->ext);
    cache->file = v4->ptr;
    cache->touch = tmpfname(0, 0)->ptr;
    cache->pid = 0;
    cache->index = 0;
    cache->loaded = 0;
    cache->width = image->width;
    cache->height = image->height;
    putHash_sv(image_hash, key->ptr, cache);
  }
  if ( flag != 1 )
  {
    if ( !cache->loaded )
    {
      if ( !image_file )
        image_file = newHash_sv(100);
      if ( !getHash_sv(image_file, cache->file, 0) )
      {
        putHash_sv(image_file, cache->file, cache);
        if ( !image_list )
          image_list = newGeneralList();
        pushValue(image_list, cache);
      }
    }
    if ( !cache->index )
      cache->index = ++image_index;
  }
  if ( (cache->loaded & 1) != 0 )
    getImageSize(cache);
  return cache;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (0809AAB9) --------------------------------------------------------
int __cdecl getImageSize(ImageCache *cache)
{
  char *v2; // eax
  char *v3; // eax
  __int16 v4; // ax
  __int16 v5; // ax
  int v6; // eax
  int v7; // eax
  int h; // [esp+40h] [ebp-18h] BYREF
  int w; // [esp+44h] [ebp-14h] BYREF
  FILE *f; // [esp+48h] [ebp-10h]
  Str tmp; // [esp+4Ch] [ebp-Ch]

  w = 0;
  h = 0;
  if ( !activeImage )
    return 0;
  if ( !cache || (cache->loaded & 1) == 0 || cache->width > 0 && cache->height > 0 )
    return 0;
  tmp = Strnew();
  if ( !strchr(Imgdisplay, 47) )
  {
    v2 = w3m_auxbin_dir();
    Strcat_m_charp(tmp, v2, "/", 0);
  }
  v3 = shell_quote(cache->file);
  Strcat_m_charp(tmp, Imgdisplay, " -size ", v3, 0);
  f = popen(tmp->ptr, "r");
  if ( !f )
    return 0;
  while ( fscanf(f, "%d %d", &w, &h) < 0 && !feof(f) )
    ;
  pclose(f);
  if ( w <= 0 || h <= 0 )
    return 0;
  w = (int)((long double)w * image_scale / 100.0 + 0.5);
  if ( !w )
    w = 1;
  h = (int)((long double)h * image_scale / 100.0 + 0.5);
  if ( !h )
    h = 1;
  if ( cache->width >= 0 || cache->height >= 0 )
  {
    if ( cache->width >= 0 )
    {
      if ( cache->height < 0 )
      {
        LOWORD(v7) = 2048;
        if ( (int)((long double)cache->width * (long double)h / (long double)w + 0.5) <= 2048 )
          v7 = (int)((long double)cache->width * (long double)h / (long double)w + 0.5);
        cache->height = v7;
      }
    }
    else
    {
      LOWORD(v6) = 2048;
      if ( (int)((long double)cache->height * (long double)w / (long double)h + 0.5) <= 2048 )
        v6 = (int)((long double)cache->height * (long double)w / (long double)h + 0.5);
      cache->width = v6;
    }
  }
  else
  {
    v4 = w;
    if ( w > 2048 )
      v4 = 2048;
    cache->width = v4;
    v5 = h;
    if ( h > 2048 )
      v5 = 2048;
    cache->height = v5;
  }
  if ( !cache->width )
    cache->width = 1;
  if ( !cache->height )
    cache->height = 1;
  tmp = Sprintf("%d;%d;%s", cache->width, cache->height, cache->url);
  putHash_sv(image_hash, tmp->ptr, cache);
  return 1;
}

//----- (0809AE2C) --------------------------------------------------------
void __cdecl encode_symbol(symbol_set *s)
{
  char **v1; // edi
  wc_ces v2; // esi
  wc_ces v3; // ebx
  _Str *v4; // eax
  int i; // [esp+1Ch] [ebp-1Ch]

  for ( i = 0; s->item[i]; ++i )
  {
    if ( *s->item[i] )
    {
      v1 = &s->item[i];
      v2 = InnerCharset;
      v3 = s->ces;
      v4 = Strnew_charp(*v1);
      *v1 = wc_Str_conv(v4, v3, v2)->ptr;
    }
  }
  s->encode = 1;
}

//----- (0809AEC2) --------------------------------------------------------
char **__cdecl get_symbol(wc_ces charset, int *width)
{
  char **result; // eax
  symbol_set *v3; // eax
  symbol_set *s; // [esp+18h] [ebp-10h]
  charset_symbol_set *p; // [esp+1Ch] [ebp-Ch]

  s = 0;
  if ( charset == save_charset && save_symbol && *width == save_symbol->width )
  {
    *width = save_symbol->width;
    result = save_symbol->item;
  }
  else
  {
    save_charset = charset;
    for ( p = charset_symbol_list; p->charset; ++p )
    {
      if ( p->charset == charset && (!*width || *width == p->symbol->width) )
      {
        s = p->symbol;
        break;
      }
    }
    if ( !s )
    {
      if ( *width == 2 )
        v3 = &alt2_symbol_set;
      else
        v3 = &alt_symbol_set;
      s = v3;
    }
    if ( s != save_symbol )
    {
      if ( !s->encode )
        encode_symbol(s);
      save_symbol = s;
    }
    *width = s->width;
    result = s->item;
  }
  return result;
}

//----- (0809AFC5) --------------------------------------------------------
char **__cdecl set_symbol(int width)
{
  _Str *tmp; // [esp+14h] [ebp-14h]
  int i; // [esp+18h] [ebp-10h]
  int ia; // [esp+18h] [ebp-10h]

  if ( width == save_width_8078 )
    return symbol_buf_8077;
  if ( !symbol_buf_8077 )
  {
    for ( i = 0; alt_symbol_set.item[i]; ++i )
      ;
    symbol_buf_8077 = (char **)GC_malloc(4 * i);
  }
  for ( ia = 0; alt_symbol_set.item[ia]; ++ia )
  {
    tmp = Strnew_size(4);
    if ( width == 2 )
      wtf_push(tmp, 0x8800u, ia + 32);
    else
      wtf_push(tmp, 0x800u, ia + 32);
    symbol_buf_8077[ia] = tmp->ptr;
  }
  save_width_8078 = width;
  return symbol_buf_8077;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (0809B0B9) --------------------------------------------------------
void __cdecl push_symbol(Str str, char symbol, int width, int n)
{
  char v4; // al
  _Str *v5; // [esp+4h] [ebp-34h]
  int i; // [esp+24h] [ebp-14h]
  char *p; // [esp+28h] [ebp-10h]
  char buf[2]; // [esp+2Eh] [ebp-Ah] BYREF

  if ( width == 2 )
    p = alt2_symbol[symbol];
  else
    p = alt_symbol[symbol];
  for ( i = 0; i <= 1 && *p; ++i )
  {
    if ( *p == 32 )
      v4 = -96;
    else
      v4 = *p;
    buf[i] = v4;
    ++p;
  }
  v5 = Sprintf("<_SYMBOL TYPE=%d>", symbol);
  savexmlstr_0(str, v5);
  while ( n > 0 )
  {
    Strcat_charp_n(str, buf, i);
    --n;
  }
  Strcat_charp(str, "</_SYMBOL>");
}

//----- (0809B188) --------------------------------------------------------
char *__cdecl conv_entity(unsigned int c)
{
  char *result; // eax
  wc_ces v2; // ebx
  _Str *v3; // eax
  wc_ces v4; // ebx
  _Str *v5; // eax
  wc_uchar utf8[7]; // [esp+18h] [ebp-10h] BYREF
  char b[9]; // [esp+1Fh] [ebp-9h] BYREF

  b[0] = c;
  if ( c <= 0x1F )
    return (char *)&unk_80CEDBD;
  if ( c <= 0x7E )
    return Strnew_charp_n(b, 1)->ptr;
  if ( c <= 0x9F )
    return (char *)&unk_80CEDBD;
  if ( c == 160 )
    return (char *)&unk_80CECA0;
  if ( c > 0xFF )
  {
    if ( (c & 0x80000000) != 0 )
    {
      result = (char *)&unk_80CECFC;
    }
    else
    {
      wc_ucs_to_utf8(c, utf8);
      v4 = InnerCharset;
      v5 = Strnew_charp((char *)utf8);
      result = wc_Str_conv(v5, 0x308045u, v4)->ptr;
    }
  }
  else if ( UseAltEntity )
  {
    result = alt_latin1[c - 160];
  }
  else
  {
    v2 = InnerCharset;
    v3 = Strnew_charp_n(b, 1);
    result = wc_Str_conv(v3, 0x100201u, v2)->ptr;
  }
  return result;
}

//----- (0809B290) --------------------------------------------------------
void __cdecl writestr(char *s)
{
  tputs(s, 1, (int (*)(int))write1);
}

//----- (0809B2B3) --------------------------------------------------------
int set_tty()
{
  int v0; // eax
  size_t v1; // eax
  size_t v2; // eax
  w3m_term_info *p_0; // [esp+10h] [ebp-18h]
  const char *term; // [esp+14h] [ebp-14h]
  w3m_term_info *p; // [esp+18h] [ebp-10h]
  const char *ttyn; // [esp+1Ch] [ebp-Ch]

  if ( isatty(0) )
  {
    ttyn = ttyname(0);
    v0 = open(ttyn, 2);
  }
  else
  {
    v0 = open("/dev/tty", 2);
  }
  tty = v0;
  if ( v0 < 0 )
    tty = 2;
  ttyf = fdopen(tty, "w");
  tcgetattr(tty, &d_ioval);
  if ( displayTitleTerm )
  {
    for ( p = w3m_term_info_list; p->term; ++p )
    {
      v1 = strlen(p->term);
      if ( !strncmp(displayTitleTerm, p->term, v1) )
      {
        title_str = p->title_str;
        break;
      }
    }
  }
  term = getenv("TERM");
  if ( term )
  {
    for ( p_0 = w3m_term_info_list; p_0->term; ++p_0 )
    {
      v2 = strlen(p_0->term);
      if ( !strncmp(term, p_0->term, v2) )
      {
        is_xterm = p_0->mouse_flag;
        return 0;
      }
    }
  }
  return 0;
}

//----- (0809B3FC) --------------------------------------------------------
void __cdecl ttymode_set(int mode, int imode)
{
  int *v2; // eax
  TerminalMode ioval; // [esp+10h] [ebp-48h] BYREF
  unsigned int v4; // [esp+4Ch] [ebp-Ch]

  v4 = __readgsdword(0x14u);
  tcgetattr(tty, &ioval);
  ioval.c_lflag |= mode;
  ioval.c_iflag |= imode;
  while ( tcsetattr(tty, 0, &ioval) == -1 )
  {
    if ( *__errno_location() != 4 && *__errno_location() != 11 )
    {
      v2 = __errno_location();
      printf("Error occured while set %x: errno=%d\n", mode, *v2);
      reset_exit(0);
    }
  }
}

//----- (0809B4B6) --------------------------------------------------------
void __cdecl ttymode_reset(int mode, int imode)
{
  int *v2; // eax
  TerminalMode ioval; // [esp+10h] [ebp-48h] BYREF
  unsigned int v4; // [esp+4Ch] [ebp-Ch]

  v4 = __readgsdword(0x14u);
  tcgetattr(tty, &ioval);
  ioval.c_lflag &= ~mode;
  ioval.c_iflag &= ~imode;
  while ( tcsetattr(tty, 0, &ioval) == -1 )
  {
    if ( *__errno_location() != 4 && *__errno_location() != 11 )
    {
      v2 = __errno_location();
      printf("Error occured while reset %x: errno=%d\n", mode, *v2);
      reset_exit(0);
    }
  }
}

//----- (0809B574) --------------------------------------------------------
void __cdecl set_cc(int spec, int val)
{
  int *v2; // eax
  TerminalMode ioval; // [esp+10h] [ebp-48h] BYREF
  unsigned int v4; // [esp+4Ch] [ebp-Ch]

  v4 = __readgsdword(0x14u);
  tcgetattr(tty, &ioval);
  ioval.c_cc[spec] = val;
  while ( tcsetattr(tty, 0, &ioval) == -1 )
  {
    if ( *__errno_location() != 4 && *__errno_location() != 11 )
    {
      v2 = __errno_location();
      printf("Error occured: errno=%d\n", *v2);
      reset_exit(0);
    }
  }
}

//----- (0809B61B) --------------------------------------------------------
void close_tty()
{
  if ( tty > 2 )
    close(tty);
}

//----- (0809B63A) --------------------------------------------------------
char *ttyname_tty()
{
  return ttyname(tty);
}

//----- (0809B64F) --------------------------------------------------------
void reset_tty()
{
  writestr(T_op);
  writestr(T_me);
  if ( !Do_not_use_ti_te )
  {
    if ( T_te && *T_te )
      writestr(T_te);
    else
      writestr(T_cl);
  }
  writestr(T_se);
  flush_tty();
  tcsetattr(tty, 0, &d_ioval);
  close_tty();
}

//----- (0809B6DF) --------------------------------------------------------
void __cdecl __noreturn reset_exit(int _dummy)
{
  if ( mouseActive )
    mouse_end();
  reset_tty();
  w3m_exit(0);
}

//----- (0809B706) --------------------------------------------------------
void __cdecl __noreturn error_dump(int _dummy)
{
  mySignal(6, 0);
  reset_tty();
  abort();
}

//----- (0809B72A) --------------------------------------------------------
void set_int()
{
  mySignal(1, reset_exit);
  mySignal(2, reset_exit);
  mySignal(3, reset_exit);
  mySignal(15, reset_exit);
  mySignal(4, error_dump);
  mySignal(6, error_dump);
  mySignal(8, error_dump);
  mySignal(7, error_dump);
}

//----- (0809B7D2) --------------------------------------------------------
void setgraphchar()
{
  int n; // [esp+14h] [ebp-14h]
  int i; // [esp+18h] [ebp-10h]
  int c; // [esp+1Ch] [ebp-Ch]
  int ca; // [esp+1Ch] [ebp-Ch]

  for ( c = 0; c <= 95; ++c )
    gcmap[c] = c + 32;
  if ( T_ac )
  {
    n = strlen(T_ac);
    for ( i = 0; n - 1 > i; i += 2 )
    {
      ca = T_ac[i] - 32;
      if ( ca >= 0 && ca <= 95 )
        gcmap[ca] = T_ac[i + 1];
    }
  }
}

//----- (0809B86E) --------------------------------------------------------
void getTCstr()
{
  char *v0; // eax
  char *pt; // [esp+14h] [ebp-14h] BYREF
  char *suc; // [esp+18h] [ebp-10h]
  char *ent; // [esp+1Ch] [ebp-Ch]

  pt = funcstr;
  if ( getenv("TERM") )
    v0 = getenv("TERM");
  else
    v0 = 0;
  ent = v0;
  if ( !v0 )
  {
    fwrite("TERM is not set\n", 1u, 0x10u, stderr);
    reset_exit(0);
  }
  if ( tgetent(byte_817E220, ent) != 1 )
  {
    fprintf(stderr, "Can't find termcap entry %s\n", ent);
    reset_exit(0);
  }
  T_ce = pt;
  suc = tgetstr("ce", &pt);
  if ( suc )
    T_ce = allocStr(suc, -1);
  else
    T_ce = (char *)&unk_80CEE92;
  T_cd = pt;
  suc = tgetstr("cd", &pt);
  if ( suc )
    T_cd = allocStr(suc, -1);
  else
    T_cd = (char *)&unk_80CEE92;
  T_kr = pt;
  suc = tgetstr("nd", &pt);
  if ( suc )
    T_kr = allocStr(suc, -1);
  else
    T_kr = (char *)&unk_80CEE92;
  if ( !suc )
  {
    T_kr = pt;
    suc = tgetstr("kr", &pt);
    if ( suc )
      T_kr = allocStr(suc, -1);
    else
      T_kr = (char *)&unk_80CEE92;
  }
  if ( tgetflag("bs") )
  {
    T_kl = "\b";
  }
  else
  {
    T_kl = pt;
    suc = tgetstr("le", &pt);
    if ( suc )
      T_kl = allocStr(suc, -1);
    else
      T_kl = (char *)&unk_80CEE92;
    if ( !suc )
    {
      T_kl = pt;
      suc = tgetstr("kb", &pt);
      if ( suc )
        T_kl = allocStr(suc, -1);
      else
        T_kl = (char *)&unk_80CEE92;
    }
    if ( !suc )
    {
      T_kl = pt;
      suc = tgetstr("kl", &pt);
      if ( suc )
        T_kl = allocStr(suc, -1);
      else
        T_kl = (char *)&unk_80CEE92;
    }
  }
  T_cr = pt;
  suc = tgetstr("cr", &pt);
  if ( suc )
    T_cr = allocStr(suc, -1);
  else
    T_cr = (char *)&unk_80CEE92;
  T_ta = pt;
  suc = tgetstr("ta", &pt);
  if ( suc )
    T_ta = allocStr(suc, -1);
  else
    T_ta = (char *)&unk_80CEE92;
  T_sc = pt;
  suc = tgetstr("sc", &pt);
  if ( suc )
    T_sc = allocStr(suc, -1);
  else
    T_sc = (char *)&unk_80CEE92;
  T_rc = pt;
  suc = tgetstr("rc", &pt);
  if ( suc )
    T_rc = allocStr(suc, -1);
  else
    T_rc = (char *)&unk_80CEE92;
  T_so = pt;
  suc = tgetstr("so", &pt);
  if ( suc )
    T_so = allocStr(suc, -1);
  else
    T_so = (char *)&unk_80CEE92;
  T_se = pt;
  suc = tgetstr("se", &pt);
  if ( suc )
    T_se = allocStr(suc, -1);
  else
    T_se = (char *)&unk_80CEE92;
  T_us = pt;
  suc = tgetstr("us", &pt);
  if ( suc )
    T_us = allocStr(suc, -1);
  else
    T_us = (char *)&unk_80CEE92;
  T_ue = pt;
  suc = tgetstr("ue", &pt);
  if ( suc )
    T_ue = allocStr(suc, -1);
  else
    T_ue = (char *)&unk_80CEE92;
  T_md = pt;
  suc = tgetstr("md", &pt);
  if ( suc )
    T_md = allocStr(suc, -1);
  else
    T_md = (char *)&unk_80CEE92;
  T_me = pt;
  suc = tgetstr("me", &pt);
  if ( suc )
    T_me = allocStr(suc, -1);
  else
    T_me = (char *)&unk_80CEE92;
  T_cl = pt;
  suc = tgetstr("cl", &pt);
  if ( suc )
    T_cl = allocStr(suc, -1);
  else
    T_cl = (char *)&unk_80CEE92;
  T_cm = pt;
  suc = tgetstr("cm", &pt);
  if ( suc )
    T_cm = allocStr(suc, -1);
  else
    T_cm = (char *)&unk_80CEE92;
  T_al = pt;
  suc = tgetstr("al", &pt);
  if ( suc )
    T_al = allocStr(suc, -1);
  else
    T_al = (char *)&unk_80CEE92;
  T_sr = pt;
  suc = tgetstr("sr", &pt);
  if ( suc )
    T_sr = allocStr(suc, -1);
  else
    T_sr = (char *)&unk_80CEE92;
  T_ti = pt;
  suc = tgetstr("ti", &pt);
  if ( suc )
    T_ti = allocStr(suc, -1);
  else
    T_ti = (char *)&unk_80CEE92;
  T_te = pt;
  suc = tgetstr("te", &pt);
  if ( suc )
    T_te = allocStr(suc, -1);
  else
    T_te = (char *)&unk_80CEE92;
  T_nd = pt;
  suc = tgetstr("nd", &pt);
  if ( suc )
    T_nd = allocStr(suc, -1);
  else
    T_nd = (char *)&unk_80CEE92;
  T_eA = pt;
  suc = tgetstr("eA", &pt);
  if ( suc )
    T_eA = allocStr(suc, -1);
  else
    T_eA = (char *)&unk_80CEE92;
  T_as = pt;
  suc = tgetstr("as", &pt);
  if ( suc )
    T_as = allocStr(suc, -1);
  else
    T_as = (char *)&unk_80CEE92;
  T_ae = pt;
  suc = tgetstr("ae", &pt);
  if ( suc )
    T_ae = allocStr(suc, -1);
  else
    T_ae = (char *)&unk_80CEE92;
  T_ac = pt;
  suc = tgetstr("ac", &pt);
  if ( suc )
    T_ac = allocStr(suc, -1);
  else
    T_ac = (char *)&unk_80CEE92;
  T_op = pt;
  suc = tgetstr("op", &pt);
  if ( suc )
    T_op = allocStr(suc, -1);
  else
    T_op = (char *)&unk_80CEE92;
  COLS = 0;
  LINES = 0;
  setlinescols();
  setgraphchar();
}

//----- (0809C199) --------------------------------------------------------
void setlinescols()
{
  winsize wins; // [esp+10h] [ebp-18h] BYREF
  int i; // [esp+18h] [ebp-10h]
  char *p; // [esp+1Ch] [ebp-Ch]

  i = ioctl(tty, 0x5413u, &wins);
  if ( i >= 0 && wins.ws_row && wins.ws_col )
  {
    LINES = wins.ws_row;
    COLS = wins.ws_col;
  }
  if ( LINES <= 0 )
  {
    p = getenv("LINES");
    if ( p )
    {
      i = atoi(p);
      if ( i >= 0 )
        LINES = i;
    }
  }
  if ( COLS <= 0 )
  {
    p = getenv("COLUMNS");
    if ( p )
    {
      i = atoi(p);
      if ( i >= 0 )
        COLS = i;
    }
  }
  if ( LINES <= 0 )
    LINES = tgetnum("li");
  if ( COLS <= 0 )
    COLS = tgetnum("co");
  if ( COLS > 400 )
    COLS = 400;
  if ( LINES > 200 )
    LINES = 200;
}

//----- (0809C2C4) --------------------------------------------------------
void setupscreen()
{
  Screen *v0; // ebx
  Screen *v1; // ebx
  int i; // [esp+1Ch] [ebp-Ch]
  int ia; // [esp+1Ch] [ebp-Ch]

  if ( LINES + 1 > max_LINES )
  {
    max_LINES = LINES + 1;
    max_COLS = 0;
    ScreenElem = (Screen *)GC_malloc(12 * (LINES + 1));
    ScreenImage = (Screen **)GC_malloc(4 * max_LINES);
  }
  if ( COLS + 1 > max_COLS )
  {
    max_COLS = COLS + 1;
    for ( i = 0; i < max_LINES; ++i )
    {
      v0 = &ScreenElem[i];
      v0->lineimage = (char **)GC_malloc(4 * max_COLS);
      bzero(ScreenElem[i].lineimage, 4 * max_COLS);
      v1 = &ScreenElem[i];
      v1->lineprop = (l_prop *)GC_malloc(2 * max_COLS);
    }
  }
  for ( ia = 0; ia < LINES; ++ia )
  {
    ScreenImage[ia] = &ScreenElem[ia];
    *ScreenImage[ia]->lineprop = 8;
    ScreenImage[ia]->isdirty = 0;
  }
  while ( ia < max_LINES )
    ScreenElem[ia++].isdirty = 2;
  clear();
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (0809C480) --------------------------------------------------------
int initscr()
{
  if ( set_tty() < 0 )
    return -1;
  set_int();
  getTCstr();
  if ( T_ti )
  {
    if ( !Do_not_use_ti_te )
      writestr(T_ti);
  }
  setupscreen();
  return 0;
}

//----- (0809C4CB) --------------------------------------------------------
int __cdecl write1(char c)
{
  _IO_putc(c, ttyf);
  return 0;
}

//----- (0809C4F4) --------------------------------------------------------
void __cdecl move(int line, int column)
{
  if ( line >= 0 && line < LINES )
    CurLine = line;
  if ( column >= 0 && column < COLS )
    CurColumn = column;
}

//----- (0809C529) --------------------------------------------------------
int __cdecl need_redraw_0(char *c1, l_prop pr1, char *c2, l_prop pr2)
{
  if ( !c1 || !c2 || strcmp(c1, c2) )
    return 1;
  if ( *c1 == 32 )
    return (pr1 ^ pr2) & 0xFF1F;
  return ((pr1 ^ pr2) & 0xFFDF) != 0;
}

//----- (0809C5A6) --------------------------------------------------------
void __cdecl addch(char c)
{
  char ca[12]; // [esp+1Ch] [ebp-Ch] BYREF

  ca[0] = c;
  addmch(ca, 1u);
}

//----- (0809C5C7) --------------------------------------------------------
void __cdecl addmch(char *pc, size_t len)
{
  int v2; // eax
  l_prop v3; // ax
  __int16 v4; // ax
  l_prop v5; // ax
  l_prop v6; // dx
  l_prop v7; // dx
  char **v8; // ebx
  l_prop v9; // ax
  l_prop v10; // dx
  l_prop v11; // dx
  l_prop v12; // dx
  int width; // [esp+24h] [ebp-24h]
  char **p; // [esp+28h] [ebp-20h]
  int i; // [esp+30h] [ebp-18h]
  int ia; // [esp+30h] [ebp-18h]
  int ib; // [esp+30h] [ebp-18h]
  int ic; // [esp+30h] [ebp-18h]
  int id; // [esp+30h] [ebp-18h]
  int ie; // [esp+30h] [ebp-18h]
  int ig; // [esp+30h] [ebp-18h]
  int ih; // [esp+30h] [ebp-18h]
  int dest; // [esp+34h] [ebp-14h]
  l_prop *pr; // [esp+38h] [ebp-10h]
  l_prop l; // [esp+3Ch] [ebp-Ch]
  unsigned __int8 c; // [esp+3Fh] [ebp-9h]
  char *pca; // [esp+50h] [ebp+8h]

  c = *pc;
  if ( WcOption.use_wide )
    v2 = WTF_WIDTH_MAP[(unsigned __int8)*pc];
  else
    v2 = WTF_WIDTH_MAP[(unsigned __int8)*pc] != 0;
  width = v2;
  if ( !tmp_8815 )
    tmp_8815 = Strnew();
  Strcopy_charp_n(tmp_8815, pc, len);
  pca = tmp_8815->ptr;
  if ( CurColumn == COLS )
    wrap();
  if ( CurColumn < COLS )
  {
    p = ScreenImage[CurLine]->lineimage;
    pr = ScreenImage[CurLine]->lineprop;
    if ( (pr[CurColumn] & 8) != 0 )
    {
      if ( c == 32 && (CurrentMode & 0xFF1F) == 0 )
      {
        ++CurColumn;
        return;
      }
      for ( i = CurColumn; i >= 0 && (pr[i] & 8) != 0; --i )
      {
        p[i] = (char *)GC_realloc(p[i], 2);
        memcpy(p[i], " ", sizeof(char));
        p[i][1] = 0;
        pr[i] &= 0x20u;
      }
    }
    if ( c == 9 || c == 10 || c == 13 || c == 8 )
    {
      HIBYTE(v3) = HIBYTE(CurrentMode);
      LOBYTE(v3) = CurrentMode | 0xC0;
      CurrentMode = v3;
    }
    else if ( len <= 1 )
    {
      if ( (MYCTYPE_MAP[c] & 1) != 0 )
        return;
      HIBYTE(v5) = HIBYTE(CurrentMode);
      LOBYTE(v5) = CurrentMode & 0x3F;
      CurrentMode = v5;
    }
    else
    {
      HIBYTE(v4) = HIBYTE(CurrentMode);
      LOBYTE(v4) = CurrentMode & 0x3F;
      CurrentMode = v4 | 0x40;
    }
    ia = width + CurColumn - 1;
    if ( ia < COLS
      && ((pr[ia] & 4) != 0 && need_redraw_0(p[ia], pr[ia], pca, CurrentMode)
       || (pr[ia] & 2) != 0 && (CurrentMode & 2) == 0) )
    {
      touch_line();
      ib = ia + 1;
      if ( ib < COLS )
      {
        touch_column(ib);
        if ( (pr[ib] & 8) != 0 )
        {
          p[ib] = (char *)GC_realloc(p[ib], 2);
          memcpy(p[ib], " ", sizeof(char));
          p[ib][1] = 0;
          pr[ib] &= 0x20u;
        }
        else
        {
          for ( ic = ib + 1; ic < COLS && (pr[ic] & 0xC0) == 128; ++ic )
            touch_column(ic);
        }
      }
    }
    if ( width + CurColumn > COLS )
    {
      touch_line();
      for ( id = CurColumn; id < COLS; ++id )
      {
        p[id] = (char *)GC_realloc(p[id], 2);
        memcpy(p[id], " ", sizeof(char));
        p[id][1] = 0;
        v6 = pr[id];
        LOBYTE(v6) = v6 & 0x3F;
        pr[id] = v6;
        touch_column(id);
      }
      wrap();
      if ( width + CurColumn > COLS )
        return;
      p = ScreenImage[CurLine]->lineimage;
      pr = ScreenImage[CurLine]->lineprop;
    }
    if ( (pr[CurColumn] & 0xC0) == 128 )
    {
      touch_line();
      for ( ie = CurColumn - 1; ie >= 0; --ie )
      {
        l = pr[ie] & 0xC0;
        p[ie] = (char *)GC_realloc(p[ie], 2);
        memcpy(p[ie], " ", sizeof(char));
        p[ie][1] = 0;
        v7 = pr[ie];
        LOBYTE(v7) = v7 & 0x3F;
        pr[ie] = v7;
        touch_column(ie);
        if ( l != 128 )
          break;
      }
    }
    if ( (CurrentMode & 0xC0) == 192 )
    {
      switch ( c )
      {
        case 9u:
          dest = (CurColumn + tab_step) / tab_step * tab_step;
          if ( dest >= COLS )
          {
            wrap();
            touch_line();
            dest = tab_step;
            p = ScreenImage[CurLine]->lineimage;
            pr = ScreenImage[CurLine]->lineprop;
          }
          for ( ih = CurColumn; ih < dest; ++ih )
          {
            if ( need_redraw_0(p[ih], pr[ih], " ", CurrentMode) )
            {
              p[ih] = (char *)GC_realloc(p[ih], 2);
              memcpy(p[ih], " ", sizeof(char));
              p[ih][1] = 0;
              pr[ih] = pr[ih] & 0x20 | CurrentMode;
              touch_line();
              touch_column(ih);
            }
          }
          CurColumn = ih;
          break;
        case 0xAu:
          wrap();
          break;
        case 0xDu:
          CurColumn = 0;
          break;
        default:
          if ( c == 8 && CurColumn > 0 )
          {
            --CurColumn;
            while ( CurColumn > 0 && (pr[CurColumn] & 0xC0) == 128 )
              --CurColumn;
          }
          break;
      }
    }
    else
    {
      if ( need_redraw_0(p[CurColumn], pr[CurColumn], pca, CurrentMode) )
      {
        v8 = &p[CurColumn];
        *v8 = (char *)GC_realloc(*v8, len + 1);
        strncpy(p[CurColumn], pca, len);
        p[CurColumn][len] = 0;
        pr[CurColumn] = pr[CurColumn] & 0x20 | CurrentMode;
        touch_line();
        touch_column(CurColumn);
        HIBYTE(v9) = HIBYTE(CurrentMode);
        LOBYTE(v9) = CurrentMode & 0x3F | 0x80;
        CurrentMode = v9;
        for ( ig = CurColumn + 1; width + CurColumn > ig; ++ig )
        {
          p[ig] = (char *)GC_realloc(p[ig], 2);
          memcpy(p[ig], " ", sizeof(char));
          p[ig][1] = 0;
          v10 = pr[CurColumn];
          LOBYTE(v10) = v10 & 0x3F;
          v11 = pr[ig] & 0x20 | v10;
          LOBYTE(v11) = v11 | 0x80;
          pr[ig] = v11;
          touch_column(ig);
        }
        while ( ig < COLS && (pr[ig] & 0xC0) == 128 )
        {
          p[ig] = (char *)GC_realloc(p[ig], 2);
          memcpy(p[ig], " ", sizeof(char));
          p[ig][1] = 0;
          v12 = pr[ig];
          LOBYTE(v12) = v12 & 0x3F;
          pr[ig] = v12;
          touch_column(ig++);
        }
      }
      CurColumn += width;
    }
  }
}
// 8049E6C: using guessed type int __cdecl GC_realloc(_DWORD, _DWORD);

//----- (0809D009) --------------------------------------------------------
void wrap()
{
  if ( LINES - 1 != CurLine )
  {
    ++CurLine;
    CurColumn = 0;
  }
}

//----- (0809D039) --------------------------------------------------------
void __cdecl touch_column(int col)
{
  if ( col >= 0 && col < COLS )
    ScreenImage[CurLine]->lineprop[col] |= 0x20;
}

//----- (0809D090) --------------------------------------------------------
void touch_line()
{
  int i; // [esp+Ch] [ebp-4h]

  if ( (ScreenImage[CurLine]->isdirty & 1) == 0 )
  {
    for ( i = 0; i < COLS; ++i )
      ScreenImage[CurLine]->lineprop[i] &= 0xFFDF;
    ScreenImage[CurLine]->isdirty |= 1u;
  }
}

//----- (0809D143) --------------------------------------------------------
void standout()
{
  CurrentMode |= 1u;
}

//----- (0809D158) --------------------------------------------------------
void standend()
{
  CurrentMode &= 0xFFFEu;
}

//----- (0809D16D) --------------------------------------------------------
void toggle_stand()
{
  l_prop *pr; // [esp+8h] [ebp-8h]
  int i; // [esp+Ch] [ebp-4h]

  pr = ScreenImage[CurLine]->lineprop;
  pr[CurColumn] ^= 1u;
  if ( (pr[CurColumn] & 0xC0) != 128 )
  {
    for ( i = CurColumn + 1; (pr[i] & 0xC0) == 128; ++i )
      pr[i] ^= 1u;
  }
}

//----- (0809D20B) --------------------------------------------------------
void bold()
{
  CurrentMode |= 4u;
}

//----- (0809D220) --------------------------------------------------------
void boldend()
{
  CurrentMode &= 0xFFFBu;
}

//----- (0809D235) --------------------------------------------------------
void underline()
{
  CurrentMode |= 2u;
}

//----- (0809D24A) --------------------------------------------------------
void underlineend()
{
  CurrentMode &= 0xFFFDu;
}

//----- (0809D25F) --------------------------------------------------------
void graphstart()
{
  CurrentMode |= 0x10u;
}

//----- (0809D274) --------------------------------------------------------
void graphend()
{
  CurrentMode &= 0xFFEFu;
}

//----- (0809D289) --------------------------------------------------------
_BOOL4 graph_ok()
{
  if ( !UseGraphicChar[0] )
    return 0;
  return *T_as && *T_ae && *T_ac;
}

//----- (0809D2D0) --------------------------------------------------------
void __cdecl setfcolor(int color)
{
  l_prop v1; // ax

  LOBYTE(v1) = CurrentMode;
  HIBYTE(v1) = HIBYTE(CurrentMode) & 0xF0;
  CurrentMode = v1;
  if ( (color & 0xFu) <= 7 )
    CurrentMode |= (color & 7 | 8) << 8;
}

//----- (0809D30D) --------------------------------------------------------
char *__cdecl color_seq(int colmode)
{
  sprintf(seqbuf_9607, "\x1B[%dm", ((colmode >> 8) & 7) + 30);
  return seqbuf_9607;
}

//----- (0809D33F) --------------------------------------------------------
void __cdecl setbcolor(int color)
{
  CurrentMode &= 0xFFFu;
  if ( (color & 0xFu) <= 7 )
    CurrentMode |= (color & 7 | 8) << 12;
}

//----- (0809D37D) --------------------------------------------------------
char *__cdecl bcolor_seq(int colmode)
{
  sprintf(seqbuf_9632, "\x1B[%dm", ((colmode >> 12) & 7) + 40);
  return seqbuf_9632;
}

//----- (0809D3AF) --------------------------------------------------------
void refresh()
{
  char *v0; // eax
  char *v1; // eax
  char *v2; // eax
  bool v3; // al
  char *v4; // eax
  __int16 v5; // dx
  char *v6; // eax
  char *v7; // eax
  char v8; // al
  char *v9; // eax
  __int16 *dirty; // [esp+18h] [ebp-30h]
  l_prop *pr; // [esp+1Ch] [ebp-2Ch]
  char **pc; // [esp+20h] [ebp-28h]
  int moved; // [esp+24h] [ebp-24h]
  int pline; // [esp+28h] [ebp-20h]
  int pcol; // [esp+2Ch] [ebp-1Ch]
  int pcola; // [esp+2Ch] [ebp-1Ch]
  int col; // [esp+30h] [ebp-18h]
  int line; // [esp+34h] [ebp-14h]
  l_prop bcolor; // [esp+3Ah] [ebp-Eh]
  l_prop color; // [esp+3Ch] [ebp-Ch]
  l_prop mode; // [esp+3Eh] [ebp-Ah]

  pline = CurLine;
  moved = 0;
  mode = 0;
  wc_putc_init(InnerCharset, DisplayCharset);
  for ( line = 0; LINES - 1 >= line; ++line )
  {
    dirty = &ScreenImage[line]->isdirty;
    if ( (*(_BYTE *)dirty & 1) != 0 )
    {
      *dirty &= 0xFFFEu;
      pc = ScreenImage[line]->lineimage;
      pr = ScreenImage[line]->lineprop;
      for ( col = 0; col < COLS && (pr[col] & 8) == 0; ++col )
      {
        if ( (*dirty & 4) != 0 && ScreenImage[line]->eol <= col )
        {
          if ( need_redraw_0(pc[col], pr[col], " ", 0) )
            break;
        }
        else if ( (pr[col] & 0x20) != 0 )
        {
          break;
        }
      }
      if ( (*dirty & 0xC) != 0 )
      {
        pcol = ScreenImage[line]->eol;
        if ( pcol >= COLS )
        {
          *dirty &= 0xFFF3u;
          pcol = col;
        }
      }
      else
      {
        pcol = col;
      }
      if ( LINES - 2 <= line || line - 1 != pline || pcol )
      {
        v1 = tgoto(T_cm, pcol, line);
        writestr(v1);
        moved = 1;
      }
      else if ( moved == 1 )
      {
        write1(10);
        write1(13);
      }
      else
      {
        v0 = tgoto(T_cm, 0, line);
        writestr(v0);
        moved = 1;
      }
      if ( (*dirty & 0xC) != 0 )
      {
        writestr(T_ce);
        if ( col != pcol )
        {
          v2 = tgoto(T_cm, col, line);
          writestr(v2);
        }
      }
      pline = line;
      pcola = col;
      while ( col < COLS && (pr[col] & 8) == 0 )
      {
        if ( (pr[col] & 1) == 0 && (mode & 1) != 0
          || (pr[col] & 2) == 0 && (mode & 2) != 0
          || (pr[col] & 4) == 0 && (mode & 4) != 0
          || (pr[col] & 0xF00) == 0 && (mode & 0xF00) != 0
          || (pr[col] & 0xF000) == 0 && (mode & 0xF000) != 0
          || (pr[col] & 0x10) == 0 && (mode & 0x10) != 0 )
        {
          if ( (mode & 0xF00) != 0 || (mode & 0xF000) != 0 )
            writestr(T_op);
          if ( (mode & 0x10) != 0 )
            writestr(T_ae);
          writestr(T_me);
          mode &= 0xE8u;
        }
        if ( (*dirty & 4) != 0 && ScreenImage[line]->eol <= col )
          v3 = need_redraw_0(pc[col], pr[col], " ", 0) != 0;
        else
          v3 = (pr[col] & 0x20) != 0;
        if ( v3 )
        {
          if ( col - 1 == pcola )
          {
            writestr(T_nd);
          }
          else if ( pcola != col )
          {
            v4 = tgoto(T_cm, col, line);
            writestr(v4);
          }
          if ( (pr[col] & 1) != 0 && (mode & 1) == 0 )
          {
            writestr(T_so);
            mode |= 1u;
          }
          if ( (pr[col] & 2) != 0 && (mode & 2) == 0 )
          {
            writestr(T_us);
            mode |= 2u;
          }
          if ( (pr[col] & 4) != 0 && (mode & 4) == 0 )
          {
            writestr(T_md);
            mode |= 4u;
          }
          if ( (pr[col] & 0xF00) != 0 && ((mode ^ pr[col]) & 0xF00) != 0 )
          {
            color = pr[col] & 0xF00;
            LOBYTE(v5) = mode;
            HIBYTE(v5) = HIBYTE(mode) & 0xF0;
            mode = v5 | color;
            v6 = color_seq(color);
            writestr(v6);
          }
          if ( (pr[col] & 0xF000) != 0 && ((mode ^ pr[col]) & 0xF000) != 0 )
          {
            bcolor = pr[col] & 0xF000;
            mode = mode & 0xFFF | bcolor;
            v7 = bcolor_seq(bcolor);
            writestr(v7);
          }
          if ( (pr[col] & 0x10) != 0 && (mode & 0x10) == 0 )
          {
            wc_putc_end(ttyf);
            if ( !graph_enabled )
            {
              graph_enabled = 1;
              writestr(T_eA);
            }
            writestr(T_as);
            mode |= 0x10u;
          }
          if ( (pr[col] & 0x10) != 0 )
          {
            if ( (unsigned __int8)*pc[col] <= 0x1Fu || *pc[col] < 0 )
              v8 = *pc[col];
            else
              v8 = gcmap[*pc[col] - 32];
            write1(v8);
          }
          else if ( (pr[col] & 0xC0) != 128 )
          {
            wc_putc(pc[col], ttyf);
          }
          pcola = col + 1;
        }
        ++col;
      }
      if ( col == COLS )
        moved = 0;
      while ( col < COLS && (pr[col] & 8) == 0 )
        pr[col++] |= 8u;
    }
    *dirty &= 0xFFF3u;
    if ( (mode & 0xFF17) != 0 )
    {
      if ( (mode & 0xFF00) != 0 )
        writestr(T_op);
      if ( (mode & 0x10) != 0 )
      {
        writestr(T_ae);
        wc_putc_clear_status();
      }
      writestr(T_me);
      mode &= 0xE8u;
    }
  }
  wc_putc_end(ttyf);
  v9 = tgoto(T_cm, CurColumn, CurLine);
  writestr(v9);
  flush_tty();
}
// 809D57E: conditional instruction was optimized away because of '%moved.4==0'
// 809D582: conditional instruction was optimized away because of '%moved.4==0'

//----- (0809DBFF) --------------------------------------------------------
void clear()
{
  l_prop *p; // [esp+14h] [ebp-14h]
  int j; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]

  writestr(T_cl);
  move(0, 0);
  for ( i = 0; i < LINES; ++i )
  {
    ScreenImage[i]->isdirty = 0;
    p = ScreenImage[i]->lineprop;
    for ( j = 0; j < COLS; ++j )
      p[j] = 8;
  }
  CurrentMode = 0;
}

//----- (0809DC96) --------------------------------------------------------
void clrtoeol()
{
  l_prop *lprop; // [esp+8h] [ebp-8h]
  int i; // [esp+Ch] [ebp-4h]

  lprop = ScreenImage[CurLine]->lineprop;
  if ( (lprop[CurColumn] & 8) == 0 )
  {
    if ( (ScreenImage[CurLine]->isdirty & 0xC) == 0 || ScreenImage[CurLine]->eol > CurColumn )
      ScreenImage[CurLine]->eol = CurColumn;
    ScreenImage[CurLine]->isdirty |= 8u;
    touch_line();
    for ( i = CurColumn; i < COLS && (lprop[i] & 8) == 0; ++i )
      lprop[i] = 40;
  }
}

//----- (0809DD9F) --------------------------------------------------------
void clrtoeol_with_bcolor()
{
  int cco; // [esp+10h] [ebp-18h]
  int cli; // [esp+14h] [ebp-14h]
  int i; // [esp+18h] [ebp-10h]
  l_prop pr; // [esp+1Eh] [ebp-Ah]

  if ( (CurrentMode & 0xF000) != 0 )
  {
    cli = CurLine;
    cco = CurColumn;
    pr = CurrentMode;
    CurrentMode &= 0xF020u;
    for ( i = CurColumn; i < COLS; ++i )
      addch(32);
    move(cli, cco);
    CurrentMode = pr;
  }
  else
  {
    clrtoeol();
  }
}

//----- (0809DE2D) --------------------------------------------------------
void clrtoeolx()
{
  clrtoeol_with_bcolor();
}

//----- (0809DE3A) --------------------------------------------------------
void __cdecl clrtobot_eol(void (*clrtoeol)(...))
{
  int c; // [esp+8h] [ebp-10h]
  int l; // [esp+Ch] [ebp-Ch]

  l = CurLine;
  c = CurColumn;
  clrtoeol();
  CurColumn = 0;
  ++CurLine;
  while ( CurLine < LINES )
  {
    clrtoeol();
    ++CurLine;
  }
  CurLine = l;
  CurColumn = c;
}

//----- (0809DEA1) --------------------------------------------------------
void clrtobot()
{
  clrtobot_eol((void (*)(...))clrtoeol);
}

//----- (0809DEB6) --------------------------------------------------------
void clrtobotx()
{
  clrtobot_eol((void (*)(...))clrtoeolx);
}

//----- (0809DECB) --------------------------------------------------------
void __cdecl addstr(char *s)
{
  int len; // [esp+1Ch] [ebp-Ch]

  while ( *s )
  {
    len = wtf_len((wc_uchar *)s);
    addmch(s, len);
    s += len;
  }
}

//----- (0809DF05) --------------------------------------------------------
void __cdecl addnstr(char *s, int n)
{
  int v2; // eax
  int width; // [esp+14h] [ebp-14h]
  int len; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; *s; i += width )
  {
    v2 = WcOption.use_wide ? WTF_WIDTH_MAP[(unsigned __int8)*s] : WTF_WIDTH_MAP[(unsigned __int8)*s] != 0;
    width = v2;
    if ( i + v2 > n )
      break;
    len = wtf_len((wc_uchar *)s);
    addmch(s, len);
    s += len;
  }
}

//----- (0809DF98) --------------------------------------------------------
void __cdecl addnstr_sup(char *s, int n)
{
  int v2; // eax
  int width; // [esp+14h] [ebp-14h]
  int len; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; *s; i += width )
  {
    v2 = WcOption.use_wide ? WTF_WIDTH_MAP[(unsigned __int8)*s] : WTF_WIDTH_MAP[(unsigned __int8)*s] != 0;
    width = v2;
    if ( i + v2 > n )
      break;
    len = wtf_len((wc_uchar *)s);
    addmch(s, len);
    s += len;
  }
  while ( i < n )
  {
    addch(32);
    ++i;
  }
}

//----- (0809E049) --------------------------------------------------------
void crmode()
{
  ttymode_reset(2, 1024);
  ttymode_set(1, 0);
  set_cc(6, 1);
}

//----- (0809E08D) --------------------------------------------------------
void nocrmode()
{
  ttymode_set(2, 0);
  set_cc(6, 4);
}

//----- (0809E0BD) --------------------------------------------------------
void term_echo()
{
  ttymode_set(8, 0);
}

//----- (0809E0D9) --------------------------------------------------------
void term_noecho()
{
  ttymode_reset(8, 0);
}

//----- (0809E0F5) --------------------------------------------------------
void term_raw()
{
  ttymode_reset(32779, 5120);
  set_cc(6, 1);
}

//----- (0809E125) --------------------------------------------------------
void term_cooked()
{
  ttymode_set(32779, 0);
  set_cc(6, 4);
}

//----- (0809E155) --------------------------------------------------------
void term_cbreak()
{
  term_cooked();
  term_noecho();
}

//----- (0809E167) --------------------------------------------------------
void __cdecl term_title(char *s)
{
  if ( fmInitialized )
  {
    if ( title_str )
      fprintf(ttyf, title_str, s);
  }
}

//----- (0809E1A5) --------------------------------------------------------
int getch()
{
  char c[9]; // [esp+1Fh] [ebp-9h] BYREF

  while ( read(tty, c, 1u) <= 0 )
  {
    if ( *__errno_location() != 4 && *__errno_location() != 11 )
    {
      quitfm();
      return (unsigned __int8)c[0];
    }
  }
  return (unsigned __int8)c[0];
}

//----- (0809E1F6) --------------------------------------------------------
char __cdecl wgetch(void *p)
{
  char c[9]; // [esp+1Fh] [ebp-9h] BYREF

  while ( read(tty, c, 1u) <= 0 )
  {
    if ( *__errno_location() != 4 && *__errno_location() != 11 )
    {
      quitfm();
      return c[0];
    }
  }
  return c[0];
}

//----- (0809E247) --------------------------------------------------------
int do_getch()
{
  int result; // eax

  if ( is_xterm )
    result = (char)getch();
  else
    result = Gpm_Wgetch();
  return result;
}

//----- (0809E26E) --------------------------------------------------------
void bell()
{
  write1(7);
}

//----- (0809E282) --------------------------------------------------------
void skip_escseq()
{
  int c; // [esp+Ch] [ebp-Ch]
  int ca; // [esp+Ch] [ebp-Ch]

  c = (char)getch();
  if ( c == 91 || c == 79 )
  {
    ca = (char)getch();
    if ( is_xterm && ca == 77 )
    {
      getch();
      getch();
      getch();
    }
    else
    {
      while ( (MYCTYPE_MAP[(unsigned __int8)ca] & 8) != 0 )
        LOBYTE(ca) = getch();
    }
  }
}

//----- (0809E2F4) --------------------------------------------------------
int __cdecl sleep_till_anykey(int sec, int purge)
{
  int *v2; // eax
  fd_set rfd; // [esp+24h] [ebp-F4h] BYREF
  timeval tim; // [esp+A4h] [ebp-74h] BYREF
  int __d1; // [esp+ACh] [ebp-6Ch]
  int __d0; // [esp+B0h] [ebp-68h]
  int ret; // [esp+B4h] [ebp-64h]
  int c; // [esp+B8h] [ebp-60h]
  int er; // [esp+BCh] [ebp-5Ch]
  TerminalMode ioval; // [esp+C0h] [ebp-58h] BYREF
  unsigned int v12; // [esp+FCh] [ebp-1Ch]

  v12 = __readgsdword(0x14u);
  tcgetattr(tty, &ioval);
  term_raw();
  tim.tv_sec = sec;
  tim.tv_usec = 0;
  memset(&rfd, 0, sizeof(rfd));
  __d0 = 0;
  __d1 = (int)&tim;
  rfd.__fds_bits[tty / 32] |= 1 << (tty % 32);
  ret = select(tty + 1, &rfd, 0, 0, &tim);
  if ( ret > 0 )
  {
    if ( purge )
    {
      c = (char)getch();
      if ( c == 27 )
        skip_escseq();
    }
  }
  er = tcsetattr(tty, 0, &ioval);
  if ( er == -1 )
  {
    v2 = __errno_location();
    printf("Error occured: errno=%d\n", *v2);
    reset_exit(0);
  }
  return ret;
}

//----- (0809E44F) --------------------------------------------------------
void mouse_init()
{
  Gpm_Connect_0 conn; // [esp+1Ch] [ebp-1Ch] BYREF
  int r; // [esp+2Ch] [ebp-Ch]

  if ( !mouseActive )
  {
    conn.eventMask = -1;
    conn.defaultMask = 0;
    conn.maxMod = 0;
    conn.minMod = 0;
    r = Gpm_Open(&conn, 0);
    if ( r == -2 )
    {
      Gpm_Close();
      is_xterm = 3;
    }
    else if ( r >= 0 )
    {
      gpm_handler = (int)gpm_process_mouse;
      is_xterm = 0;
    }
    if ( is_xterm )
    {
      fwrite("\x1B[?1001s\x1B[?1000h", 1u, 0x10u, ttyf);
      flush_tty();
    }
    mouseActive = 1;
  }
}
// 817C1E0: using guessed type int gpm_handler;

//----- (0809E505) --------------------------------------------------------
void mouse_end()
{
  if ( mouseActive )
  {
    if ( is_xterm )
    {
      fwrite("\x1B[?1000l\x1B[?1001r", 1u, 0x10u, ttyf);
      flush_tty();
    }
    else
    {
      Gpm_Close();
    }
    mouseActive = 0;
  }
}

//----- (0809E55F) --------------------------------------------------------
void mouse_active()
{
  if ( !mouseActive )
    mouse_init();
}

//----- (0809E575) --------------------------------------------------------
void mouse_inactive()
{
  if ( mouseActive )
  {
    if ( is_xterm )
      mouse_end();
  }
}

//----- (0809E594) --------------------------------------------------------
void flush_tty()
{
  if ( ttyf )
    fflush(ttyf);
}

//----- (0809E5B2) --------------------------------------------------------
void touch_cursor()
{
  int i; // [esp+10h] [ebp-4h]
  int ia; // [esp+10h] [ebp-4h]

  touch_line();
  for ( i = CurColumn; i >= 0; --i )
  {
    touch_column(i);
    if ( (ScreenImage[CurLine]->lineprop[i] & 0xC0) != 128 )
      break;
  }
  for ( ia = CurColumn + 1; ia < COLS && (ScreenImage[CurLine]->lineprop[ia] & 0xC0) == 128; ++ia )
    touch_column(ia);
}

//----- (0809E668) --------------------------------------------------------
table2 *__cdecl loadMimeTypes(char *filename)
{
  char *v1; // eax
  table2 *mtypes; // [esp+14h] [ebp-24h]
  Str tmp; // [esp+18h] [ebp-20h]
  Str tmpa; // [esp+18h] [ebp-20h]
  int n; // [esp+1Ch] [ebp-1Ch]
  int i; // [esp+20h] [ebp-18h]
  int ia; // [esp+20h] [ebp-18h]
  char *type; // [esp+24h] [ebp-14h]
  char *d; // [esp+28h] [ebp-10h]
  char *da; // [esp+28h] [ebp-10h]
  FILE *f; // [esp+2Ch] [ebp-Ch]

  v1 = expandPath(filename);
  f = fopen(v1, "r");
  if ( !f )
    return 0;
  n = 0;
  while ( 1 )
  {
    tmp = Strfgets(f);
    if ( tmp->length <= 0 )
      break;
    if ( *tmp->ptr != 35 && strtok(tmp->ptr, " \t\n\r") )
    {
      d = strtok(0, " \t\n\r");
      i = 0;
      while ( d )
      {
        d = strtok(0, " \t\n\r");
        ++i;
      }
      n += i;
    }
  }
  fseek(f, 0, 0);
  mtypes = (table2 *)GC_malloc(8 * (n + 1));
  ia = 0;
  while ( 1 )
  {
    tmpa = Strfgets(f);
    if ( tmpa->length <= 0 )
      break;
    if ( *tmpa->ptr != 35 )
    {
      type = strtok(tmpa->ptr, " \t\n\r");
      if ( type )
      {
        while ( 1 )
        {
          da = strtok(0, " \t\n\r");
          if ( !da )
            break;
          mtypes[ia].item1 = Strnew_charp(da)->ptr;
          mtypes[ia++].item2 = Strnew_charp(type)->ptr;
        }
      }
    }
  }
  mtypes[ia].item1 = 0;
  mtypes[ia].item2 = 0;
  fclose(f);
  return mtypes;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (0809E854) --------------------------------------------------------
void initMimeTypes()
{
  table2 **v0; // ebx
  TextListItem *tl; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]

  if ( non_null(mimetypes_files) )
    mimetypes_list = make_domain_list(mimetypes_files);
  else
    mimetypes_list = 0;
  if ( mimetypes_list )
  {
    UserMimeTypes = (table2 **)GC_malloc(4 * mimetypes_list->nitem);
    i = 0;
    for ( tl = mimetypes_list->first; tl; tl = tl->next )
    {
      v0 = &UserMimeTypes[i];
      *v0 = loadMimeTypes(tl->ptr);
      ++i;
    }
  }
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (0809E8F9) --------------------------------------------------------
char *__cdecl DefaultFile(int scheme)
{
  if ( scheme == 1 )
    return allocStr("1", -1);
  if ( scheme <= 1 )
  {
    if ( scheme )
      return 0;
    return allocStr("/", -1);
  }
  if ( scheme <= 5 )
    return allocStr("/", -1);
  return 0;
}

//----- (0809E962) --------------------------------------------------------
void __cdecl __noreturn KeyAbort_1(int _dummy)
{
  siglongjmp(AbortLoading_1, 1);
}

//----- (0809E97C) --------------------------------------------------------
void __cdecl write_from_file(int sock, char *file)
{
  int c; // [esp+14h] [ebp-14h]
  FILE *fd; // [esp+18h] [ebp-10h]
  char buf[1]; // [esp+1Fh] [ebp-9h] BYREF

  fd = fopen(file, "r");
  if ( fd )
  {
    while ( 1 )
    {
      c = fgetc(fd);
      if ( c == -1 )
        break;
      buf[0] = c;
      write(sock, buf, 1u);
    }
    fclose(fd);
  }
}

//----- (0809E9E2) --------------------------------------------------------
ParsedURL *__cdecl baseURL(Buffer *buf)
{
  if ( (buf->bufferprop & 0x10) != 0 )
    return 0;
  if ( buf->baseURL )
    return buf->baseURL;
  return &buf->currentURL;
}

//----- (0809EA1D) --------------------------------------------------------
int __cdecl openSocket(char *const hostname, char *remoteport_name, unsigned __int16 remoteport_num)
{
  Str v3; // eax
  size_t v4; // ebx
  addrinfo hints; // [esp+20h] [ebp-48h] BYREF
  Str portbuf; // [esp+40h] [ebp-28h]
  void (*prevtrap)(int); // [esp+44h] [ebp-24h]
  char *hname; // [esp+48h] [ebp-20h]
  int error; // [esp+4Ch] [ebp-1Ch]
  addrinfo *res; // [esp+50h] [ebp-18h]
  addrinfo *res0; // [esp+54h] [ebp-14h] BYREF
  int *af_0; // [esp+58h] [ebp-10h]
  int sock; // [esp+5Ch] [ebp-Ch]

  sock = -1;
  prevtrap = 0;
  if ( fmInitialized )
  {
    v3 = Sprintf("Opening socket...");
    message(v3->ptr, 0, 0);
    refresh();
  }
  if ( __sigsetjmp(AbortLoading_1, 1) )
    goto LABEL_39;
  if ( TrapSignal )
  {
    prevtrap = mySignal(2, KeyAbort_1);
    if ( fmInitialized )
      term_cbreak();
  }
  if ( !hostname
    || (hname = hostname, *hostname == 91)
    && hname[strlen(hname) - 1] == 93
    && (hname = allocStr(hostname + 1, -1),
        hname[strlen(hname) - 1] = 0,
        v4 = strspn(hname, "0123456789abcdefABCDEF:."),
        v4 != strlen(hname)) )
  {
LABEL_39:
    if ( TrapSignal )
    {
      if ( fmInitialized )
        term_raw();
      if ( prevtrap )
        mySignal(2, prevtrap);
    }
    return -1;
  }
  for ( af_0 = ai_family_order_table[DNS_order]; ; ++af_0 )
  {
    memset(&hints, 0, sizeof(hints));
    hints.ai_family = *af_0;
    hints.ai_socktype = 1;
    if ( remoteport_num )
    {
      portbuf = Sprintf("%d", remoteport_num);
      error = getaddrinfo(hname, portbuf->ptr, &hints, &res0);
    }
    else
    {
      error = -1;
    }
    if ( error && remoteport_name && *remoteport_name )
      error = getaddrinfo(hname, remoteport_name, &hints, &res0);
    if ( error )
    {
      if ( !*af_0 )
        goto LABEL_39;
      continue;
    }
    sock = -1;
    for ( res = res0; res; res = res->ai_next )
    {
      sock = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
      if ( sock >= 0 )
      {
        if ( connect(sock, res->ai_addr, res->ai_addrlen) >= 0 )
          break;
        close(sock);
        sock = -1;
      }
    }
    if ( sock >= 0 )
      break;
    freeaddrinfo(res0);
    if ( !*af_0 )
      goto LABEL_39;
  }
  freeaddrinfo(res0);
  if ( TrapSignal )
  {
    if ( fmInitialized )
      term_raw();
    if ( prevtrap )
      mySignal(2, prevtrap);
  }
  return sock;
}
// 809EA8C: conditional instruction was optimized away because of '%sock.4==FFFFFFFF'
// 809EAE8: conditional instruction was optimized away because of '%hostname.4!=0'

//----- (0809ED8B) --------------------------------------------------------
char *__cdecl copyPath(char *orgpath, int length, int option)
{
  int v3; // eax
  int v4; // eax
  Str tmp; // [esp+1Ch] [ebp-Ch]

  tmp = Strnew();
  while ( *orgpath && length )
  {
    if ( (MYCTYPE_MAP[(unsigned __int8)*orgpath] & 2) != 0 )
    {
      if ( option != 1 )
      {
        if ( option == 2 )
        {
          Strcat_charp(tmp, "%20");
        }
        else if ( !option )
        {
          if ( tmp->length + 1 >= tmp->area_size )
            Strgrow(tmp);
          v3 = tmp->length;
          tmp->ptr[v3] = *orgpath;
          tmp->length = v3 + 1;
          tmp->ptr[tmp->length] = 0;
        }
      }
    }
    else
    {
      if ( tmp->length + 1 >= tmp->area_size )
        Strgrow(tmp);
      v4 = tmp->length;
      tmp->ptr[v4] = *orgpath;
      tmp->length = v4 + 1;
      tmp->ptr[tmp->length] = 0;
    }
    ++orgpath;
    --length;
  }
  return tmp->ptr;
}

//----- (0809EEAF) --------------------------------------------------------
void __cdecl parseURL(char *url, ParsedURL *p_url, ParsedURL *current)
{
  int v3; // eax
  int v4; // edx
  char *v5; // eax
  char *cgi; // [esp+10h] [ebp-18h]
  Str tmpa; // [esp+14h] [ebp-14h]
  Str tmp; // [esp+14h] [ebp-14h]
  char *q; // [esp+18h] [ebp-10h]
  char *qa; // [esp+18h] [ebp-10h]
  char *qb; // [esp+18h] [ebp-10h]
  char *qc; // [esp+18h] [ebp-10h]
  char *p; // [esp+1Ch] [ebp-Ch] BYREF
  char *urla; // [esp+30h] [ebp+8h]

  urla = url_quote(url);
  p = urla;
  p_url->scheme = 254;
  p_url->port = 0;
  p_url->user = 0;
  p_url->pass = 0;
  p_url->host = 0;
  p_url->is_nocache = 0;
  p_url->file = 0;
  p_url->real_file = 0;
  p_url->query = 0;
  p_url->label = 0;
  if ( *urla && *urla != 35 )
  {
    p_url->scheme = getURLScheme(&p);
    if ( p_url->scheme == 254 )
    {
      if ( current )
      {
        switch ( current->scheme )
        {
          case 2:
          case 3:
            p_url->scheme = 2;
            break;
          case 4:
          case 5:
            p_url->scheme = 4;
            break;
          case 7:
          case 8:
            p_url->scheme = 7;
            break;
          case 9:
          case 0xA:
            p_url->scheme = 9;
            break;
          default:
            p_url->scheme = current->scheme;
            break;
        }
      }
      else
      {
        p_url->scheme = 4;
      }
      p = urla;
      if ( !strncmp(urla, "//", 2u) )
      {
        for ( p += 2; ; ++p )
        {
          while ( 1 )
          {
analyze_url:
            q = p;
            if ( *p == 91 )
            {
              ++p;
              while ( (MYCTYPE_MAP[(unsigned __int8)*p] & 0x28) != 0 || *p == 58 || *p == 46 )
                ++p;
              if ( *p != 93 || p[1] && !strchr(":/?#", p[1]) )
                p = q;
            }
            while ( *p && !strchr(":/@?#", *p) )
              ++p;
            v3 = *p;
            if ( v3 != 58 )
              break;
            p_url->host = copyPath(q, p - q, 1);
            qa = ++p;
            while ( *p && !strchr("@/?#", *p) )
              ++p;
            if ( *p != 64 )
            {
              tmpa = Strnew_charp_n(qa, p - qa);
              p_url->port = atoi(tmpa->ptr);
              goto analyze_file;
            }
            p_url->pass = copyPath(qa, p - qa, 0);
            ++p;
            p_url->user = p_url->host;
            p_url->host = 0;
          }
          if ( v3 <= 58 )
            break;
          if ( v3 == 63 )
            goto LABEL_58;
          if ( v3 != 64 )
            goto analyze_file;
          p_url->user = copyPath(q, p - q, 1);
        }
        if ( v3 == 35 || v3 == 47 || !*p )
        {
LABEL_58:
          p_url->host = copyPath(q, p - q, 1);
          p_url->port = DefaultPort[p_url->scheme];
          goto analyze_file;
        }
      }
    }
    else
    {
      if ( p_url->scheme == 255 )
      {
        p_url->file = allocStr(urla, -1);
        return;
      }
      if ( *p == 47 && p[1] == 47 )
      {
        if ( p_url->scheme != 4 || p[2] != 47 && p[2] != 126 )
        {
          p += 2;
          goto analyze_url;
        }
        p += 2;
      }
      else
      {
        p_url->host = 0;
        if ( p_url->scheme == 255 )
          p_url->port = 0;
        else
          p_url->port = DefaultPort[p_url->scheme];
      }
    }
analyze_file:
    if ( p_url->scheme == 4 && !p_url->user )
    {
      if ( p_url->host )
      {
        if ( *p_url->host )
        {
          if ( strcmp(p_url->host, "localhost") )
          {
            p_url->scheme = 2;
            if ( !p_url->port )
              p_url->port = DefaultPort[2];
          }
        }
      }
    }
    if ( *p && *p != 35 && *p != 63 || p_url->host )
    {
      qb = p;
      if ( p_url->scheme == 1 )
      {
        if ( *p == 47 )
          qb = p + 1;
        if ( *qb && *qb != 47 && qb[1] != 47 && qb[2] == 47 )
          ++qb;
      }
      if ( *p == 47 )
        ++p;
      if ( !*p || *p == 35 || *p == 63 )
      {
        p_url->file = DefaultFile(p_url->scheme);
      }
      else if ( p_url->scheme == 1 && *p == 82 )
      {
        ++p;
        tmp = Strnew();
        if ( tmp->length + 1 >= tmp->area_size )
          Strgrow(tmp);
        v4 = tmp->length;
        v5 = p;
        tmp->ptr[v4] = *p;
        tmp->length = v4 + 1;
        p = v5 + 1;
        tmp->ptr[tmp->length] = 0;
        while ( *p && *p != 47 )
          ++p;
        Strcat_charp(tmp, p);
        while ( *p )
          ++p;
        p_url->file = copyPath(tmp->ptr, -1, 1);
      }
      else
      {
        cgi = strchr(p, 63);
        while ( 1 )
        {
          while ( *p && *p != 35 && p != cgi )
            ++p;
          if ( *p != 35 || p_url->scheme != 4 )
            break;
          if ( p <= qb || *(p - 1) != 47 || cgi && p >= cgi )
          {
            if ( !p[1] )
              ++p;
            break;
          }
          ++p;
        }
        if ( p_url->scheme == 4 || p_url->scheme == 254 )
          p_url->file = copyPath(qb, p - qb, 0);
        else
          p_url->file = copyPath(qb, p - qb, 1);
      }
    }
    else
    {
      p_url->file = (char *)&unk_80CF0E8;
    }
    if ( *p == 63 )
    {
      qc = ++p;
      while ( *p && *p != 35 )
        ++p;
      p_url->query = copyPath(qc, p - qc, 0);
    }
  }
  else if ( current )
  {
    copyParsedURL(p_url, current);
  }
  if ( p_url->scheme == 254 )
  {
    p_url->scheme = 4;
    p_url->file = allocStr(p, -1);
    p_url->label = 0;
  }
  else if ( *p == 35 )
  {
    p_url->label = allocStr(p + 1, -1);
  }
  else
  {
    p_url->label = 0;
  }
}

//----- (0809F763) --------------------------------------------------------
void __cdecl copyParsedURL(ParsedURL *p, ParsedURL *q)
{
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax

  p->scheme = q->scheme;
  p->port = q->port;
  p->is_nocache = q->is_nocache;
  if ( q->user )
    v2 = allocStr(q->user, -1);
  else
    v2 = 0;
  p->user = v2;
  if ( q->pass )
    v3 = allocStr(q->pass, -1);
  else
    v3 = 0;
  p->pass = v3;
  if ( q->host )
    v4 = allocStr(q->host, -1);
  else
    v4 = 0;
  p->host = v4;
  if ( q->file )
    v5 = allocStr(q->file, -1);
  else
    v5 = 0;
  p->file = v5;
  if ( q->real_file )
    v6 = allocStr(q->real_file, -1);
  else
    v6 = 0;
  p->real_file = v6;
  if ( q->label )
    v7 = allocStr(q->label, -1);
  else
    v7 = 0;
  p->label = v7;
  if ( q->query )
    v8 = allocStr(q->query, -1);
  else
    v8 = 0;
  p->query = v8;
}

//----- (0809F8C8) --------------------------------------------------------
void __cdecl parseURL2(char *url, ParsedURL *pu, ParsedURL *current)
{
  char *v3; // eax
  char *v4; // ebx
  char *v5; // eax
  int v6; // eax
  char *v7; // eax
  char *v8; // eax
  char *v9; // [esp+4h] [ebp-24h]
  char *q; // [esp+10h] [ebp-18h]
  int relative_uri; // [esp+14h] [ebp-14h]
  Str tmp; // [esp+18h] [ebp-10h]
  Str tmpa; // [esp+18h] [ebp-10h]
  char *p; // [esp+1Ch] [ebp-Ch]
  char *pa; // [esp+1Ch] [ebp-Ch]
  char *pb; // [esp+1Ch] [ebp-Ch]
  char *pc; // [esp+1Ch] [ebp-Ch]

  relative_uri = 0;
  parseURL(url, pu, current);
  switch ( pu->scheme )
  {
    case 0xB:
      return;
    case 9:
    case 0xA:
      if ( !pu->file || strchr(pu->file, 64) || (p = strchr(pu->file, 47)) != 0 && !strchr(p + 1, 45) && p[1] )
        pu->scheme = 9;
      else
        pu->scheme = 10;
      return;
    case 7:
    case 8:
      if ( pu->file && *pu->file == 47 )
        pu->file = allocStr((const char *)pu->file + 1, -1);
      if ( !pu->file || strchr(pu->file, 64) || (pa = strchr(pu->file, 47)) != 0 && !strchr(pa + 1, 45) && pa[1] )
        pu->scheme = 7;
      else
        pu->scheme = 8;
      if ( current && (current->scheme == 7 || current->scheme == 8) && !pu->host )
      {
        pu->host = current->host;
        pu->port = current->port;
      }
      return;
    case 4:
      v3 = file_unquote(pu->file);
      q = expandName(v3);
      pu->file = file_quote(q);
      break;
  }
  if ( current
    && (pu->scheme == current->scheme
     || pu->scheme == 2 && current->scheme == 3
     || pu->scheme == 4 && current->scheme == 5)
    && !pu->host )
  {
    pu->user = current->user;
    pu->pass = current->pass;
    pu->host = current->host;
    pu->port = current->port;
    if ( pu->file && *pu->file )
    {
      if ( pu->scheme == 255 && !strchr(pu->file, 58) && (pb = strchr(current->file, 58)) != 0 )
      {
        v4 = pu->file;
        v5 = allocStr(current->file, pb - current->file);
        pu->file = Sprintf("%s:%s", v5, v4)->ptr;
      }
      else if ( pu->scheme == 1 || *pu->file == 47 )
      {
        if ( pu->scheme == 1 && *pu->file == 47 )
          pu->file = allocStr((const char *)pu->file + 1, -1);
      }
      else
      {
        pc = pu->file;
        if ( current->file )
        {
          for ( tmp = Strnew_charp(current->file); tmp->length > 0 && tmp->ptr[tmp->length - 1] != 47; Strshrink(tmp, 1) )
            ;
          Strcat_charp(tmp, pc);
          pu->file = tmp->ptr;
          relative_uri = 1;
        }
      }
    }
    else
    {
      pu->file = current->file;
      if ( !pu->query )
        pu->query = current->query;
    }
  }
  if ( pu->file )
  {
    if ( pu->scheme == 4 && *pu->file != 47 && strcmp(pu->file, "-") )
    {
      tmpa = Strnew_charp(CurrentDir);
      if ( tmpa->length <= 0 || tmpa->ptr[tmpa->length - 1] != 47 )
      {
        if ( tmpa->length + 1 >= tmpa->area_size )
          Strgrow(tmpa);
        v6 = tmpa->length;
        tmpa->ptr[v6] = 47;
        tmpa->length = v6 + 1;
        tmpa->ptr[tmpa->length] = 0;
      }
      v9 = file_unquote(pu->file);
      Strcat_charp(tmpa, v9);
      v7 = cleanupName(tmpa->ptr);
      pu->file = file_quote(v7);
      goto LABEL_73;
    }
    if ( pu->scheme )
    {
      if ( pu->scheme == 1 || *pu->file != 47 )
      {
LABEL_73:
        if ( pu->scheme == 4 )
        {
          v8 = file_unquote(pu->file);
          pu->real_file = cleanupName(v8);
        }
        return;
      }
    }
    else if ( !relative_uri )
    {
      goto LABEL_73;
    }
    pu->file = cleanupName(pu->file);
    goto LABEL_73;
  }
}
// 809FBBC: conditional instruction was optimized away because of '%current.4!=0'

//----- (0809FEC0) --------------------------------------------------------
Str __cdecl parsedURL2Str(ParsedURL *pu, int pass)
{
  Str result; // eax
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  _Str *v12; // [esp+4h] [ebp-24h]
  Str tmp; // [esp+1Ch] [ebp-Ch]
  Str tmpa; // [esp+1Ch] [ebp-Ch]

  if ( pu->scheme == 254 )
    return Strnew_charp("???");
  if ( pu->scheme == 255 )
    return Strnew_charp(pu->file);
  if ( !pu->host && !pu->file && pu->label )
    return Sprintf("#%s", pu->label);
  if ( pu->scheme == 4 && !strcmp(pu->file, "-") )
  {
    tmp = Strnew_charp("-");
    if ( pu->label )
    {
      if ( tmp->length + 1 >= tmp->area_size )
        Strgrow(tmp);
      v3 = tmp->length;
      tmp->ptr[v3] = 35;
      tmp->length = v3 + 1;
      tmp->ptr[tmp->length] = 0;
      Strcat_charp(tmp, pu->label);
    }
    result = tmp;
  }
  else
  {
    tmpa = Strnew_charp(scheme_str_10358[pu->scheme]);
    if ( tmpa->length + 1 >= tmpa->area_size )
      Strgrow(tmpa);
    v4 = tmpa->length;
    tmpa->ptr[v4] = 58;
    tmpa->length = v4 + 1;
    tmpa->ptr[tmpa->length] = 0;
    if ( pu->scheme == 11 )
    {
      Strcat_charp(tmpa, pu->file);
      result = tmpa;
    }
    else
    {
      if ( pu->scheme != 9 && pu->scheme != 10 )
        Strcat_charp(tmpa, "//");
      if ( pu->user )
      {
        Strcat_charp(tmpa, pu->user);
        if ( pass && pu->pass )
        {
          if ( tmpa->length + 1 >= tmpa->area_size )
            Strgrow(tmpa);
          v5 = tmpa->length;
          tmpa->ptr[v5] = 58;
          tmpa->length = v5 + 1;
          tmpa->ptr[tmpa->length] = 0;
          Strcat_charp(tmpa, pu->pass);
        }
        if ( tmpa->length + 1 >= tmpa->area_size )
          Strgrow(tmpa);
        v6 = tmpa->length;
        tmpa->ptr[v6] = 64;
        tmpa->length = v6 + 1;
        tmpa->ptr[tmpa->length] = 0;
      }
      if ( pu->host )
      {
        Strcat_charp(tmpa, pu->host);
        if ( pu->port != DefaultPort[pu->scheme] )
        {
          if ( tmpa->length + 1 >= tmpa->area_size )
            Strgrow(tmpa);
          v7 = tmpa->length;
          tmpa->ptr[v7] = 58;
          tmpa->length = v7 + 1;
          tmpa->ptr[tmpa->length] = 0;
          v12 = Sprintf("%d", pu->port);
          savexmlstr_0(tmpa, v12);
        }
      }
      if ( pu->scheme != 9 && pu->scheme != 10 && (!pu->file || *pu->file != 47) )
      {
        if ( tmpa->length + 1 >= tmpa->area_size )
          Strgrow(tmpa);
        v8 = tmpa->length;
        tmpa->ptr[v8] = 47;
        tmpa->length = v8 + 1;
        tmpa->ptr[tmpa->length] = 0;
      }
      Strcat_charp(tmpa, pu->file);
      if ( pu->scheme == 3 && (tmpa->length <= 0 || tmpa->ptr[tmpa->length - 1] != 47) )
      {
        if ( tmpa->length + 1 >= tmpa->area_size )
          Strgrow(tmpa);
        v9 = tmpa->length;
        tmpa->ptr[v9] = 47;
        tmpa->length = v9 + 1;
        tmpa->ptr[tmpa->length] = 0;
      }
      if ( pu->query )
      {
        if ( tmpa->length + 1 >= tmpa->area_size )
          Strgrow(tmpa);
        v10 = tmpa->length;
        tmpa->ptr[v10] = 63;
        tmpa->length = v10 + 1;
        tmpa->ptr[tmpa->length] = 0;
        Strcat_charp(tmpa, pu->query);
      }
      if ( pu->label )
      {
        if ( tmpa->length + 1 >= tmpa->area_size )
          Strgrow(tmpa);
        v11 = tmpa->length;
        tmpa->ptr[v11] = 35;
        tmpa->length = v11 + 1;
        tmpa->ptr[tmpa->length] = 0;
        Strcat_charp(tmpa, pu->label);
      }
      result = tmpa;
    }
  }
  return result;
}

//----- (080A03FA) --------------------------------------------------------
Str __cdecl parsedURL2Str(ParsedURL *pu)
{
  return parsedURL2Str(pu, 0);
}

//----- (080A0415) --------------------------------------------------------
int __cdecl getURLScheme(char **url)
{
  int len; // [esp+1Ch] [ebp-1Ch]
  int scheme; // [esp+20h] [ebp-18h]
  int i; // [esp+24h] [ebp-14h]
  const char *q; // [esp+28h] [ebp-10h]
  char *p; // [esp+2Ch] [ebp-Ch]

  p = *url;
  scheme = 254;
  while ( *p && ((MYCTYPE_MAP[(unsigned __int8)*p] & 0xC) != 0 || *p == 46 || *p == 43 || *p == 45) )
    ++p;
  if ( *p == 58 )
  {
    scheme = 255;
    for ( i = 0; ; ++i )
    {
      q = schemetable[i].cmdname;
      if ( !q )
        break;
      len = strlen(q);
      if ( !strncasecmp(q, *url, len) && (*url)[len] == 58 )
      {
        scheme = schemetable[i].cmd;
        *url = p + 1;
        return scheme;
      }
    }
  }
  return scheme;
}

//----- (080A0505) --------------------------------------------------------
char *__cdecl otherinfo(ParsedURL *target, ParsedURL *current, char *referer)
{
  _Str *v4; // [esp+4h] [ebp-34h]
  _Str *v5; // [esp+4h] [ebp-34h]
  char *p_0; // [esp+24h] [ebp-14h]
  char *p; // [esp+28h] [ebp-10h]
  _Str *s; // [esp+2Ch] [ebp-Ch]

  s = Strnew();
  Strcat_charp(s, "User-Agent: ");
  if ( UserAgent && *UserAgent )
    Strcat_charp(s, UserAgent);
  else
    Strcat_charp(s, w3m_version);
  Strcat_charp(s, "\r\n");
  Strcat_m_charp(s, "Accept: ", AcceptMedia, "\r\n", 0);
  Strcat_m_charp(s, "Accept-Encoding: ", AcceptEncoding, "\r\n", 0);
  Strcat_m_charp(s, "Accept-Language: ", AcceptLang, "\r\n", 0);
  if ( target->host )
  {
    Strcat_charp(s, "Host: ");
    Strcat_charp(s, target->host);
    if ( target->port != DefaultPort[target->scheme] )
    {
      v4 = Sprintf(":%d", target->port);
      savexmlstr_0(s, v4);
    }
    Strcat_charp(s, "\r\n");
  }
  if ( target->is_nocache || NoCache[0] )
  {
    Strcat_charp(s, "Pragma: no-cache\r\n");
    Strcat_charp(s, "Cache-control: no-cache\r\n");
  }
  if ( !NoSendReferer )
  {
    if ( referer || !current || current->scheme == 4 || current->scheme == 2 && (current->user || current->pass) )
    {
      if ( referer && referer != (char *)-1 )
      {
        p_0 = strchr(referer, 35);
        Strcat_charp(s, "Referer: ");
        if ( p_0 )
          Strcat_charp_n(s, referer, p_0 - referer);
        else
          Strcat_charp(s, referer);
        Strcat_charp(s, "\r\n");
      }
    }
    else
    {
      p = current->label;
      Strcat_charp(s, "Referer: ");
      current->label = 0;
      v5 = parsedURL2Str(current);
      savexmlstr_0(s, v5);
      current->label = p;
      Strcat_charp(s, "\r\n");
    }
  }
  return s->ptr;
}

//----- (080A07EC) --------------------------------------------------------
Str __cdecl HTTPrequestMethod(HRequest *hr)
{
  int v1; // eax

  v1 = hr->command;
  switch ( v1 )
  {
    case 2:
      return Strnew_charp("CONNECT");
    case 3:
      return Strnew_charp("HEAD");
    case 1:
      return Strnew_charp("POST");
  }
  return Strnew_charp("GET");
}

//----- (080A0844) --------------------------------------------------------
Str __cdecl HTTPrequestURI(ParsedURL *pu, HRequest *hr)
{
  int v2; // eax
  _Str *v4; // [esp+4h] [ebp-24h]
  _Str *v5; // [esp+4h] [ebp-24h]
  char *save_label; // [esp+18h] [ebp-10h]
  Str tmp; // [esp+1Ch] [ebp-Ch]

  tmp = Strnew();
  if ( hr->command == 2 )
  {
    Strcat_charp(tmp, pu->host);
    v4 = Sprintf(":%d", pu->port);
    savexmlstr_0(tmp, v4);
  }
  else if ( (hr->flag & 1) != 0 )
  {
    Strcat_charp(tmp, pu->file);
    if ( pu->query )
    {
      if ( tmp->length + 1 >= tmp->area_size )
        Strgrow(tmp);
      v2 = tmp->length;
      tmp->ptr[v2] = 63;
      tmp->length = v2 + 1;
      tmp->ptr[tmp->length] = 0;
      Strcat_charp(tmp, pu->query);
    }
  }
  else
  {
    save_label = pu->label;
    pu->label = 0;
    v5 = parsedURL2Str(pu, 1);
    savexmlstr_0(tmp, v5);
    pu->label = save_label;
  }
  return tmp;
}

//----- (080A0978) --------------------------------------------------------
Str __cdecl HTTPrequest(ParsedURL *pu, ParsedURL *current, HRequest *hr, TextList *extra)
{
  char *v5; // [esp+4h] [ebp-34h]
  char *v6; // [esp+4h] [ebp-34h]
  _Str *v7; // [esp+4h] [ebp-34h]
  _Str *v8; // [esp+4h] [ebp-34h]
  _Str *cookie; // [esp+1Ch] [ebp-1Ch]
  TextListItem *i; // [esp+28h] [ebp-10h]
  _Str *tmp; // [esp+2Ch] [ebp-Ch]

  tmp = HTTPrequestMethod(hr);
  Strcat_charp(tmp, " ");
  v5 = HTTPrequestURI(pu, hr)->ptr;
  Strcat_charp(tmp, v5);
  Strcat_charp(tmp, " HTTP/1.0\r\n");
  if ( hr->referer == (char *)-1 )
    v6 = otherinfo(pu, 0, 0);
  else
    v6 = otherinfo(pu, current, hr->referer);
  Strcat_charp(tmp, v6);
  if ( extra )
  {
    for ( i = extra->first; i; i = i->next )
    {
      strncasecmp(i->ptr, "Authorization:", 0xEu);
      strncasecmp(i->ptr, "Proxy-Authorization:", 0x14u);
      Strcat_charp(tmp, i->ptr);
    }
  }
  if ( hr->command != 2 )
  {
    if ( use_cookie )
    {
      cookie = find_cookie(pu);
      if ( cookie )
      {
        Strcat_charp(tmp, "Cookie: ");
        savexmlstr_0(tmp, cookie);
        Strcat_charp(tmp, "\r\n");
        if ( *cookie->ptr != 36 )
          Strcat_charp(tmp, "Cookie2: $Version=\"1\"\r\n");
      }
    }
  }
  if ( hr->command == 1 )
  {
    if ( hr->request->enctype == 1 )
    {
      Strcat_charp(tmp, "Content-type: multipart/form-data; boundary=");
      Strcat_charp(tmp, hr->request->boundary);
      Strcat_charp(tmp, "\r\n");
      v7 = Sprintf("Content-length: %ld\r\n", hr->request->length);
      savexmlstr_0(tmp, v7);
      Strcat_charp(tmp, "\r\n");
    }
    else
    {
      if ( !override_content_type )
        Strcat_charp(tmp, "Content-type: application/x-www-form-urlencoded\r\n");
      v8 = Sprintf("Content-length: %ld\r\n", hr->request->length);
      savexmlstr_0(tmp, v8);
      if ( header_string )
        savexmlstr_0(tmp, header_string);
      Strcat_charp(tmp, "\r\n");
      Strcat_charp_n(tmp, hr->request->body, hr->request->length);
      Strcat_charp(tmp, "\r\n");
    }
  }
  else
  {
    if ( header_string )
      savexmlstr_0(tmp, header_string);
    Strcat_charp(tmp, "\r\n");
  }
  return tmp;
}

//----- (080A0CC5) --------------------------------------------------------
void __cdecl init_stream(URLFile *uf, int scheme, InputStream stream)
{
  memset(uf, 0, sizeof(URLFile));
  uf->stream = stream;
  uf->scheme = scheme;
  uf->encoding = 0;
  uf->is_cgi = 0;
  uf->compression = 0;
  uf->content_encoding = 0;
  uf->guess_type = 0;
  uf->ext = 0;
  uf->modtime = -1;
}

//----- (080A0D3B) --------------------------------------------------------
URLFile *__userpurge openURL@<eax>(URLFile *retstr, char *url, ParsedURL *pu, ParsedURL *current, URLOption *option, FormList *request, TextList *extra_header, URLFile *ouf, HRequest *hr, unsigned __int8 *status)
{
  char *v10; // eax
  FILE *v11; // eax
  FILE *v12; // eax
  int v13; // eax
  char *v14; // eax
  char *v15; // eax
  int v16; // eax
  char *v17; // eax
  URLFile uf; // [esp+14h] [ebp-54h] BYREF
  HRequest hr0; // [esp+34h] [ebp-34h] BYREF
  FILE *ff; // [esp+40h] [ebp-28h]
  Str tmp2; // [esp+44h] [ebp-24h]
  char *u; // [esp+48h] [ebp-20h] BYREF
  char *q; // [esp+4Ch] [ebp-1Ch]
  char *p; // [esp+50h] [ebp-18h]
  int scheme; // [esp+54h] [ebp-14h]
  int sock; // [esp+58h] [ebp-10h]
  Str tmp; // [esp+5Ch] [ebp-Ch]

  if ( !hr )
    hr = &hr0;
  if ( ouf )
    uf = *ouf;
  else
    init_stream(&uf, 254, 0);
  u = url;
  scheme = getURLScheme(&u);
  if ( current || scheme != 254 || ArgvIsURL )
    u = url;
  else
    u = file_to_url(url);
  while ( 2 )
  {
    parseURL2(u, pu, current);
    if ( pu->scheme == 4 && !pu->file )
    {
      if ( !pu->label )
        goto LABEL_98;
      tmp2 = Strnew_charp("#");
      Strcat_charp(tmp2, pu->label);
      pu->file = tmp2->ptr;
      v10 = file_unquote(pu->file);
      pu->real_file = cleanupName(v10);
      pu->label = 0;
    }
    uf.scheme = pu->scheme;
    uf.url = parsedURL2Str(pu)->ptr;
    pu->is_nocache = option->flag & 1;
    uf.ext = filename_extension(pu->file, 1);
    hr->command = 0;
    hr->flag = 0;
    hr->referer = option->referer;
    hr->request = request;
    switch ( pu->scheme )
    {
      case 0:
        if ( !pu->file )
          pu->file = allocStr("/", -1);
        if ( request && request->method == 1 && request->body )
          hr->command = 1;
        if ( request && request->method == 3 )
          hr->command = 3;
        if ( non_null(HTTP_proxy) && use_proxy && pu->host && !check_no_proxy(pu->host) )
        {
          hr->flag |= 2u;
          sock = openSocket(
                   HTTP_proxy_parsed.host,
                   schemetable[HTTP_proxy_parsed.scheme].cmdname,
                   HTTP_proxy_parsed.port);
          if ( sock < 0 )
            goto LABEL_98;
          tmp = HTTPrequest(pu, current, hr, extra_header);
          *status = 0;
        }
        else
        {
          sock = openSocket(pu->host, schemetable[pu->scheme].cmdname, pu->port);
          if ( sock < 0 )
          {
            *status = -2;
            *retstr = uf;
            return retstr;
          }
          hr->flag |= 1u;
          tmp = HTTPrequest(pu, current, hr, extra_header);
          *status = 0;
        }
        write(sock, tmp->ptr, tmp->length);
        if ( w3m_reqlog )
        {
          ff = fopen(w3m_reqlog, "a");
          fwrite(tmp->ptr, 1u, tmp->length, ff);
          fclose(ff);
        }
        if ( hr->command == 1 && request->enctype == 1 )
          write_from_file(sock, request->body);
        goto LABEL_109;
      case 1:
        if ( non_null(GOPHER_proxy) && use_proxy && pu->host && !check_no_proxy(pu->host) )
        {
          hr->flag |= 2u;
          sock = openSocket(
                   GOPHER_proxy_parsed.host,
                   schemetable[GOPHER_proxy_parsed.scheme].cmdname,
                   GOPHER_proxy_parsed.port);
          if ( sock < 0 )
            goto LABEL_98;
          uf.scheme = 0;
          tmp = HTTPrequest(pu, current, hr, extra_header);
        }
        else
        {
          sock = openSocket(pu->host, schemetable[pu->scheme].cmdname, pu->port);
          if ( sock < 0 )
            goto LABEL_98;
          if ( !pu->file )
            pu->file = "1";
          v15 = file_unquote(pu->file);
          tmp = Strnew_charp(v15);
          if ( tmp->length + 1 >= tmp->area_size )
            Strgrow(tmp);
          v16 = tmp->length;
          tmp->ptr[v16] = 10;
          tmp->length = v16 + 1;
          tmp->ptr[tmp->length] = 0;
        }
        write(sock, tmp->ptr, tmp->length);
        goto LABEL_109;
      case 2:
      case 3:
        if ( !pu->file )
          pu->file = allocStr("/", -1);
        if ( non_null(FTP_proxy) && use_proxy && pu->host && !check_no_proxy(pu->host) )
        {
          hr->flag |= 2u;
          sock = openSocket(FTP_proxy_parsed.host, schemetable[FTP_proxy_parsed.scheme].cmdname, FTP_proxy_parsed.port);
          if ( sock < 0 )
            goto LABEL_98;
          uf.scheme = 0;
          tmp = HTTPrequest(pu, current, hr, extra_header);
          write(sock, tmp->ptr, tmp->length);
LABEL_109:
          uf.stream = newInputStream(sock);
          *retstr = uf;
        }
        else
        {
          uf.stream = openFTPStream(pu, &uf);
          uf.scheme = pu->scheme;
          *retstr = uf;
        }
        return retstr;
      case 4:
      case 5:
        if ( request && request->body )
        {
          v11 = localcgi_post(pu->real_file, pu->query, request, option->referer);
          uf.stream = newFileStream(v11, (void (*)(...))fclose);
        }
        else
        {
          v12 = localcgi_post(pu->real_file, pu->query, 0, option->referer);
          uf.stream = newFileStream(v12, (void (*)(...))fclose);
        }
        if ( !uf.stream )
        {
          examineFile(pu->real_file, &uf);
          if ( !uf.stream )
          {
            if ( dir_exist(pu->real_file) )
            {
              add_index_file(pu, &uf);
              if ( !uf.stream )
                goto LABEL_98;
            }
            else if ( document_root )
            {
              tmp = Strnew_charp(document_root);
              if ( (tmp->length <= 0 || tmp->ptr[tmp->length - 1] != 47) && *pu->file != 47 )
              {
                if ( tmp->length + 1 >= tmp->area_size )
                  Strgrow(tmp);
                v13 = tmp->length;
                tmp->ptr[v13] = 47;
                tmp->length = v13 + 1;
                tmp->ptr[tmp->length] = 0;
              }
              Strcat_charp(tmp, pu->file);
              p = cleanupName(tmp->ptr);
              v14 = file_unquote(p);
              q = cleanupName(v14);
              if ( dir_exist(q) )
              {
                pu->file = p;
                pu->real_file = q;
                add_index_file(pu, &uf);
                if ( !uf.stream )
                  goto LABEL_98;
              }
              else
              {
                examineFile(q, &uf);
                if ( uf.stream )
                {
                  pu->file = p;
                  pu->real_file = q;
                }
              }
            }
          }
          if ( uf.stream || !retryAsHttp || *url == 47 || scheme != 254 && scheme != 255 )
          {
LABEL_98:
            *retstr = uf;
            return retstr;
          }
          u = Strnew_m_charp("http://", url, 0)->ptr;
          continue;
        }
        uf.is_cgi = 1;
        pu->scheme = 5;
        uf.scheme = 5;
        *retstr = uf;
        return retstr;
      case 7:
      case 8:
      case 9:
      case 0xA:
        if ( pu->scheme == 7 || pu->scheme == 9 )
          uf.scheme = 9;
        else
          uf.scheme = 10;
        uf.stream = openNewsStream(pu);
        *retstr = uf;
        return retstr;
      case 0xB:
        if ( !pu->file )
          goto LABEL_98;
        p = Strnew_charp(pu->file)->ptr;
        q = strchr(p, 44);
        if ( q )
        {
          *q++ = 0;
          tmp = Strnew_charp(q);
          q = strrchr(p, 59);
          if ( q && !strcmp(q, ";base64") )
          {
            *q = 0;
            uf.encoding = 1;
          }
          else
          {
            tmp = Str_url_unquote(tmp, 0, 0);
          }
          uf.stream = newStrStream(tmp);
          if ( *p )
            v17 = p;
          else
            v17 = "text/plain";
          uf.guess_type = v17;
          *retstr = uf;
        }
        else
        {
          *retstr = uf;
        }
        return retstr;
      default:
        goto LABEL_98;
    }
  }
}

//----- (080A1AD3) --------------------------------------------------------
void __cdecl add_index_file(ParsedURL *pu, URLFile *uf)
{
  char *v2; // eax
  Str v3; // eax
  char *v4; // eax
  char *q; // [esp+18h] [ebp-10h]
  char *p; // [esp+1Ch] [ebp-Ch]

  if ( index_file && *index_file )
  {
    v2 = file_quote(index_file);
    v3 = Strnew_m_charp(pu->file, "/", v2, 0);
    p = cleanupName(v3->ptr);
    v4 = file_unquote(p);
    q = cleanupName(v4);
    examineFile(q, uf);
    if ( uf->stream )
    {
      pu->file = p;
      pu->real_file = q;
    }
  }
  else
  {
    uf->stream = 0;
  }
}

//----- (080A1B89) --------------------------------------------------------
char *__cdecl guessContentTypeFromTable(table2 *table, char *filename)
{
  char *p; // [esp+18h] [ebp-10h]
  char *pa; // [esp+18h] [ebp-10h]
  table2 *t; // [esp+1Ch] [ebp-Ch]
  table2 *ta; // [esp+1Ch] [ebp-Ch]

  if ( !table )
    return 0;
  for ( p = &filename[strlen(filename) - 1]; filename < p && *p != 46; --p )
    ;
  if ( p == filename )
    return 0;
  pa = p + 1;
  for ( t = table; t->item1; ++t )
  {
    if ( !strcmp(pa, t->item1) )
      return t->item2;
  }
  for ( ta = table; ta->item1; ++ta )
  {
    if ( !strcasecmp(pa, ta->item1) )
      return ta->item2;
  }
  return 0;
}

//----- (080A1C4F) --------------------------------------------------------
char *__cdecl guessContentType(char *filename)
{
  int i; // [esp+18h] [ebp-10h]
  char *ret; // [esp+1Ch] [ebp-Ch]

  if ( !filename )
    return 0;
  if ( mimetypes_list )
  {
    for ( i = 0; mimetypes_list->nitem > i; ++i )
    {
      ret = guessContentTypeFromTable(UserMimeTypes[i], filename);
      if ( ret )
        return ret;
    }
  }
  return guessContentTypeFromTable(DefaultGuess, filename);
}

//----- (080A1CCB) --------------------------------------------------------
TextList *__cdecl make_domain_list(char *domain_list)
{
  int v1; // eax
  char *v2; // eax
  GeneralList *domains; // [esp+14h] [ebp-14h]
  Str tmp; // [esp+18h] [ebp-10h]

  domains = 0;
  tmp = Strnew_size(64);
  while ( *domain_list )
  {
    while ( *domain_list && (MYCTYPE_MAP[(unsigned __int8)*domain_list] & 2) != 0 )
      ++domain_list;
    Strclear(tmp);
    while ( *domain_list && (MYCTYPE_MAP[(unsigned __int8)*domain_list] & 2) == 0 && *domain_list != 44 )
    {
      if ( tmp->length + 1 >= tmp->area_size )
        Strgrow(tmp);
      v1 = tmp->length;
      tmp->ptr[v1] = *domain_list;
      tmp->length = v1 + 1;
      ++domain_list;
      tmp->ptr[tmp->length] = 0;
    }
    if ( tmp->length > 0 )
    {
      if ( !domains )
        domains = newGeneralList();
      v2 = allocStr(tmp->ptr, -1);
      pushValue(domains, v2);
    }
    while ( *domain_list && (MYCTYPE_MAP[(unsigned __int8)*domain_list] & 2) != 0 )
      ++domain_list;
    if ( *domain_list == 44 )
      ++domain_list;
  }
  return (TextList *)domains;
}

//----- (080A1E39) --------------------------------------------------------
int __cdecl domain_match(char *pat, char *domain)
{
  char *domaina; // [esp+24h] [ebp+Ch]

  if ( !domain )
    return 0;
  if ( *pat == 46 )
    ++pat;
  while ( 1 )
  {
    if ( !strcasecmp(pat, domain) )
      return 1;
    domaina = strchr(domain, 46);
    if ( !domaina )
      break;
    domain = domaina + 1;
  }
  return 0;
}

//----- (080A1EA2) --------------------------------------------------------
int __cdecl check_no_proxy(char *domain)
{
  int v2; // eax
  size_t v3; // eax
  addrinfo hints; // [esp+20h] [ebp-88h] BYREF
  int *af_0; // [esp+40h] [ebp-68h]
  addrinfo *res0; // [esp+44h] [ebp-64h] BYREF
  addrinfo *res; // [esp+48h] [ebp-60h]
  void (*prevtrap)(int); // [esp+50h] [ebp-58h]
  int ret; // [esp+54h] [ebp-54h]
  TextListItem *tl; // [esp+58h] [ebp-50h]
  char addr[64]; // [esp+5Ch] [ebp-4Ch] BYREF
  unsigned int v13; // [esp+9Ch] [ebp-Ch]

  v13 = __readgsdword(0x14u);
  ret = 0;
  prevtrap = 0;
  if ( !NO_proxy_domains || !NO_proxy_domains->nitem || !domain )
    return 0;
  for ( tl = NO_proxy_domains->first; tl; tl = tl->next )
  {
    if ( domain_match(tl->ptr, domain) )
      return 1;
  }
  if ( !NOproxy_netaddr )
    return 0;
  if ( __sigsetjmp(AbortLoading_1, 1) )
  {
    ret = 0;
    goto end;
  }
  if ( TrapSignal )
  {
    prevtrap = mySignal(2, KeyAbort_1);
    if ( fmInitialized )
      term_cbreak();
  }
  af_0 = ai_family_order_table[DNS_order];
  while ( 2 )
  {
    memset(&hints, 0, sizeof(hints));
    hints.ai_family = *af_0;
    if ( getaddrinfo(domain, 0, &hints, &res0) )
    {
      if ( *af_0 )
        goto LABEL_35;
      break;
    }
    for ( res = res0; res; res = res->ai_next )
    {
      v2 = res->ai_family;
      if ( v2 == 2 )
      {
        inet_ntop(2, &res->ai_addr->sa_data[2], addr, 0x40u);
      }
      else
      {
        if ( v2 != 10 )
          continue;
        inet_ntop(10, &res->ai_addr->sa_data[6], addr, 0x40u);
      }
      for ( tl = NO_proxy_domains->first; tl; tl = tl->next )
      {
        v3 = strlen(tl->ptr);
        if ( !strncmp(tl->ptr, addr, v3) )
        {
          freeaddrinfo(res0);
          ret = 1;
          goto end;
        }
      }
    }
    freeaddrinfo(res0);
    if ( *af_0 )
    {
LABEL_35:
      ++af_0;
      continue;
    }
    break;
  }
end:
  if ( TrapSignal )
  {
    if ( fmInitialized )
      term_raw();
    if ( prevtrap )
      mySignal(2, prevtrap);
  }
  return ret;
}

//----- (080A2170) --------------------------------------------------------
char *__cdecl filename_extension(char *path, int is_url)
{
  int i; // [esp+14h] [ebp-14h]
  char *p; // [esp+18h] [ebp-10h]
  char *last_dot; // [esp+1Ch] [ebp-Ch]

  last_dot = (char *)&unk_80CF0E8;
  p = path;
  if ( !path )
    return (char *)&unk_80CF0E8;
  if ( *path == 46 )
    p = path + 1;
  while ( *p )
  {
    if ( *p == 46 )
    {
      last_dot = p;
    }
    else if ( is_url && *p == 63 )
    {
      break;
    }
    ++p;
  }
  if ( *last_dot != 46 )
    return last_dot;
  for ( i = 1; last_dot[i] && i <= 7 && (!is_url || (MYCTYPE_MAP[(unsigned __int8)last_dot[i]] & 0xC) != 0); ++i )
    ;
  return allocStr(last_dot, i);
}

//----- (080A2240) --------------------------------------------------------
table2 *__cdecl loadURIMethods(char *filename)
{
  char *v1; // eax
  int v3; // eax
  char *p; // [esp+14h] [ebp-24h]
  table2 *um; // [esp+1Ch] [ebp-1Ch]
  Str tmp; // [esp+20h] [ebp-18h]
  Str tmpa; // [esp+20h] [ebp-18h]
  int i; // [esp+28h] [ebp-10h]
  int ia; // [esp+28h] [ebp-10h]
  FILE *f; // [esp+2Ch] [ebp-Ch]

  v1 = expandPath(filename);
  f = fopen(v1, "r");
  if ( !f )
    return 0;
  i = 0;
  while ( 1 )
  {
    tmp = Strfgets(f);
    if ( tmp->length <= 0 )
      break;
    if ( *tmp->ptr != 35 )
      ++i;
  }
  fseek(f, 0, 0);
  um = (table2 *)GC_malloc(8 * (i + 1));
  ia = 0;
  while ( 1 )
  {
    tmpa = Strfgets(f);
    if ( tmpa->length <= 0 )
      break;
    if ( *tmpa->ptr != 35 )
    {
      while ( 1 )
      {
        v3 = tmpa->length <= 0 ? 0 : (unsigned __int8)tmpa->ptr[tmpa->length - 1];
        if ( (MYCTYPE_MAP[v3] & 2) == 0 )
          break;
        Strshrink(tmpa, 1);
      }
      for ( p = tmpa->ptr; *p; ++p )
      {
        if ( *p == 58 )
        {
          um[ia].item1 = Strnew_charp_n(tmpa->ptr, p - tmpa->ptr)->ptr;
          ++p;
          break;
        }
      }
      if ( *p )
      {
        while ( *p && (MYCTYPE_MAP[(unsigned __int8)*p] & 2) != 0 )
          ++p;
        um[ia++].item2 = Strnew_charp(p)->ptr;
      }
    }
  }
  um[ia].item1 = 0;
  um[ia].item2 = 0;
  fclose(f);
  return um;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (080A2445) --------------------------------------------------------
void initURIMethods()
{
  table2 **v0; // ebx
  int i; // [esp+14h] [ebp-14h]
  TextListItem *tl; // [esp+18h] [ebp-10h]
  TextList *methodmap_list; // [esp+1Ch] [ebp-Ch]

  methodmap_list = 0;
  if ( non_null(urimethodmap_files) )
    methodmap_list = make_domain_list(urimethodmap_files);
  if ( methodmap_list )
  {
    urimethods = (table2 **)GC_malloc(4 * (methodmap_list->nitem + 1));
    i = 0;
    for ( tl = methodmap_list->first; tl; tl = tl->next )
    {
      v0 = &urimethods[i];
      *v0 = loadURIMethods(tl->ptr);
      if ( urimethods[i] )
        ++i;
    }
    urimethods[i] = 0;
  }
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (080A2509) --------------------------------------------------------
Str __cdecl searchURIMethods(ParsedURL *pu)
{
  char *v2; // eax
  char *p; // [esp+1Ch] [ebp-1Ch]
  Str url; // [esp+20h] [ebp-18h]
  Str scheme; // [esp+24h] [ebp-14h]
  int i; // [esp+28h] [ebp-10h]
  table2 *ump; // [esp+2Ch] [ebp-Ch]

  scheme = 0;
  if ( pu->scheme != 255 )
    return 0;
  if ( !urimethods )
    return 0;
  url = parsedURL2Str(pu);
  for ( p = url->ptr; *p; ++p )
  {
    if ( *p == 58 )
    {
      scheme = Strnew_charp_n(url->ptr, p - url->ptr);
      break;
    }
  }
  if ( !scheme )
    return 0;
  for ( i = 0; ; ++i )
  {
    ump = urimethods[i];
    if ( !ump )
      break;
    while ( ump->item1 )
    {
      if ( !strcasecmp(ump->item1, scheme->ptr) )
      {
LABEL_14:
        v2 = url_quote(url->ptr);
        return Sprintf(ump->item2, v2);
      }
      ++ump;
    }
  }
  for ( ump = default_urimethods; ump->item1; ++ump )
  {
    if ( !strcasecmp(ump->item1, scheme->ptr) )
      goto LABEL_14;
  }
  return 0;
}

//----- (080A266A) --------------------------------------------------------
void __cdecl chkExternalURIBuffer(Buffer *buf)
{
  char *v1; // [esp+4h] [ebp-24h]
  char *v2; // [esp+4h] [ebp-24h]
  table2 *ump; // [esp+18h] [ebp-10h]
  table2 *umpa; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; ; ++i )
  {
    ump = urimethods[i];
    if ( !ump )
      break;
    while ( ump->item1 )
    {
      v1 = Sprintf("%s:%s", ump->item1, "([-;/?:@&=+$,a-zA-Z0-9_.!~*'()]|%[0-9A-Fa-f][0-9A-Fa-f])*")->ptr;
      find_nvp_node_0(buf, v1);
      ++ump;
    }
  }
  for ( umpa = default_urimethods; umpa->item1; ++umpa )
  {
    v2 = Sprintf("%s:%s", umpa->item1, "([-;/?:@&=+$,a-zA-Z0-9_.!~*'()]|%[0-9A-Fa-f][0-9A-Fa-f])*")->ptr;
    find_nvp_node_0(buf, v2);
  }
}

//----- (080A2719) --------------------------------------------------------
ParsedURL *__cdecl schemeToProxy(int scheme)
{
  ParsedURL *pu; // [esp+Ch] [ebp-4h]

  pu = 0;
  switch ( scheme )
  {
    case 1:
      return &GOPHER_proxy_parsed;
    case 2:
      return &FTP_proxy_parsed;
    case 0:
      pu = &HTTP_proxy_parsed;
      break;
  }
  return pu;
}

//----- (080A2758) --------------------------------------------------------
void __cdecl __noreturn KeyAbort_2(int _dummy)
{
  siglongjmp(AbortLoading_2, 1);
}

//----- (080A2772) --------------------------------------------------------
Str __cdecl ftp_command(FTP ftp, char *cmd, char *arg, int *status)
{
  Str tmp; // [esp+1Ch] [ebp-Ch]
  _Str *tmpa; // [esp+1Ch] [ebp-Ch]
  _Str *tmpb; // [esp+1Ch] [ebp-Ch]

  if ( !ftp->host )
    return 0;
  if ( cmd )
  {
    if ( arg )
      tmp = Sprintf("%s %s\r\n", cmd, arg);
    else
      tmp = Sprintf("%s\r\n", cmd);
    fwrite(tmp->ptr, 1u, tmp->length, ftp->wf);
    fflush(ftp->wf);
  }
  if ( !status )
    return 0;
  *status = -1;
  tmpa = StrISgets(ftp->rf);
  if ( (MYCTYPE_MAP[*(unsigned __int8 *)tmpa->ptr] & 8) != 0
    && (MYCTYPE_MAP[*((unsigned __int8 *)tmpa->ptr + 1)] & 8) != 0
    && (MYCTYPE_MAP[*((unsigned __int8 *)tmpa->ptr + 2)] & 8) != 0
    && tmpa->ptr[3] == 32 )
  {
    __isoc99_sscanf(tmpa->ptr, "%d", status);
  }
  if ( tmpa->ptr[3] != 45 )
    return tmpa;
  do
  {
    do
      tmpb = StrISgets(ftp->rf);
    while ( (MYCTYPE_MAP[*(unsigned __int8 *)tmpb->ptr] & 8) == 0 );
  }
  while ( (MYCTYPE_MAP[*((unsigned __int8 *)tmpb->ptr + 1)] & 8) == 0
       || (MYCTYPE_MAP[*((unsigned __int8 *)tmpb->ptr + 2)] & 8) == 0
       || tmpb->ptr[3] != 32 );
  __isoc99_sscanf(tmpb->ptr, "%d", status);
  return tmpb;
}
// 8049DBC: using guessed type int __isoc99_sscanf(_DWORD, const char *, ...);

//----- (080A2972) --------------------------------------------------------
void __cdecl ftp_close(FTP ftp)
{
  if ( ftp->host )
  {
    if ( ftp->rf )
    {
      ftp->rf->base.type &= 0xEFu;
      ISclose(ftp->rf);
      ftp->rf = 0;
    }
    if ( ftp->wf )
    {
      fclose(ftp->wf);
      ftp->wf = 0;
    }
    if ( ftp->data )
    {
      fclose(ftp->data);
      ftp->data = 0;
    }
    ftp->host = 0;
  }
}

//----- (080A2A10) --------------------------------------------------------
int __cdecl ftp_login(FTP ftp)
{
  int v1; // eax
  Str v2; // eax
  char *v4; // [esp+8h] [ebp-60h]
  _Str *tmp; // [esp+34h] [ebp-34h]
  hostent *sockent; // [esp+38h] [ebp-30h]
  int socknamelen; // [esp+3Ch] [ebp-2Ch] BYREF
  size_t n; // [esp+40h] [ebp-28h]
  int status; // [esp+44h] [ebp-24h] BYREF
  int sock; // [esp+48h] [ebp-20h]
  sockaddr_in sockname; // [esp+4Ch] [ebp-1Ch] BYREF
  unsigned int v12; // [esp+5Ch] [ebp-Ch]

  v12 = __readgsdword(0x14u);
  sock = openSocket(ftp->host, "ftp", 0x15u);
  if ( sock >= 0 )
  {
    if ( ftppass_hostnamegen )
    {
      if ( !strcmp(ftp->user, "anonymous") )
      {
        n = strlen(ftp->pass);
        if ( n )
        {
          if ( ftp->pass[n - 1] == 64 )
          {
            socknamelen = 16;
            if ( !getsockname(sock, (struct sockaddr *)&sockname, (socklen_t *)&socknamelen) )
            {
              tmp = Strnew_charp(ftp->pass);
              sockent = gethostbyaddr(&sockname.sin_addr, 4u, sockname.sin_family);
              if ( sockent )
              {
                Strcat_charp(tmp, sockent->h_name);
              }
              else
              {
                v4 = inet_ntoa(sockname.sin_addr);
                Strcat_m_charp(tmp, "[", v4, "]", 0);
              }
              ftp->pass = tmp->ptr;
            }
          }
        }
      }
    }
    ftp->rf = newInputStream(sock);
    v1 = dup(sock);
    ftp->wf = fdopen(v1, "wb");
    if ( ftp->rf )
    {
      if ( ftp->wf )
      {
        ftp->rf->base.type |= 0x10u;
        ftp_command(ftp, 0, 0, &status);
        if ( status == 220 )
        {
          if ( fmInitialized )
          {
            v2 = Sprintf("Sending FTP username (%s) to remote server.", ftp->user);
            message(v2->ptr, 0, 0);
            refresh();
          }
          ftp_command(ftp, "USER", ftp->user, &status);
          if ( status == 230 )
            return 1;
          if ( status == 331 )
          {
            if ( fmInitialized )
            {
              message("Sending FTP password to remote server.", 0, 0);
              refresh();
            }
            ftp_command(ftp, "PASS", ftp->pass, &status);
            if ( status == 230 )
              return 1;
          }
        }
      }
    }
  }
  ftp_close(ftp);
  return 0;
}

//----- (080A2D03) --------------------------------------------------------
int __cdecl ftp_pasv(FTP ftp)
{
  int v1; // eax
  int port; // [esp+34h] [ebp-F4h] BYREF
  int sockaddrlen; // [esp+38h] [ebp-F0h] BYREF
  int family; // [esp+3Ch] [ebp-ECh]
  Str tmp; // [esp+40h] [ebp-E8h]
  char *p; // [esp+44h] [ebp-E4h]
  int data; // [esp+48h] [ebp-E0h]
  int p2; // [esp+4Ch] [ebp-DCh] BYREF
  int p1; // [esp+50h] [ebp-D8h] BYREF
  int n4; // [esp+54h] [ebp-D4h] BYREF
  int n3; // [esp+58h] [ebp-D0h] BYREF
  int n2; // [esp+5Ch] [ebp-CCh] BYREF
  int n1; // [esp+60h] [ebp-C8h] BYREF
  int status; // [esp+64h] [ebp-C4h] BYREF
  unsigned __int8 d4; // [esp+68h] [ebp-C0h] BYREF
  unsigned __int8 d3; // [esp+69h] [ebp-BFh] BYREF
  unsigned __int8 d2; // [esp+6Ah] [ebp-BEh] BYREF
  unsigned __int8 d1; // [esp+6Bh] [ebp-BDh] BYREF
  sockaddr_storage sockaddr; // [esp+6Ch] [ebp-BCh] BYREF
  char abuf[46]; // [esp+EEh] [ebp-3Ah] BYREF
  unsigned int v22; // [esp+11Ch] [ebp-Ch]

  v22 = __readgsdword(0x14u);
  sockaddrlen = 128;
  v1 = fileno(ftp->wf);
  if ( getpeername(v1, (struct sockaddr *)&sockaddr, (socklen_t *)&sockaddrlen) < 0 )
    return -1;
  family = sockaddr.ss_family;
  if ( sockaddr.ss_family == 2 )
  {
    tmp = ftp_command(ftp, "PASV", 0, &status);
    if ( status != 227 )
      return -1;
    for ( p = tmp->ptr + 4; *p && (MYCTYPE_MAP[(unsigned __int8)*p] & 8) == 0; ++p )
      ;
    if ( !*p )
      return -1;
    __isoc99_sscanf(p, "%d,%d,%d,%d,%d,%d", &n1, &n2, &n3, &n4, &p1, &p2);
    tmp = Sprintf("%d.%d.%d.%d", n1, n2, n3, n4);
    data = openSocket(tmp->ptr, (char *)&byte_80CF3D8, ((_WORD)p1 << 8) + p2);
  }
  else
  {
    if ( sockaddr.ss_family != 10 )
      return -1;
    tmp = ftp_command(ftp, "EPSV", 0, &status);
    if ( status != 229 )
      return -1;
    for ( p = tmp->ptr + 4; *p && *p != 40; ++p )
      ;
    if ( !*p )
      return -1;
    if ( __isoc99_sscanf(++p, "%c%c%c%d%c", &d1, &d2, &d3, &port, &d4) != 5 || d1 != d2 || d1 != d3 || d1 != d4 )
      return -1;
    if ( getnameinfo((const struct sockaddr *)&sockaddr, sockaddrlen, abuf, 0x2Eu, 0, 0, 1u) )
      return -1;
    data = openSocket(abuf, (char *)&byte_80CF3D8, port);
  }
  if ( data < 0 )
    return -1;
  ftp->data = fdopen(data, "rb");
  return 0;
}
// 8049DBC: using guessed type int __isoc99_sscanf(_DWORD, const char *, ...);

//----- (080A30EC) --------------------------------------------------------
time_t __cdecl ftp_modtime(FTP ftp, char *path)
{
  struct tm *v3; // eax
  struct tm *v4; // eax
  tm tm; // [esp+2Ch] [ebp-4Ch] BYREF
  time_t gt; // [esp+58h] [ebp-20h]
  time_t lt; // [esp+5Ch] [ebp-1Ch]
  time_t t; // [esp+60h] [ebp-18h] BYREF
  char *p; // [esp+64h] [ebp-14h]
  Str tmp; // [esp+68h] [ebp-10h]
  int status[3]; // [esp+6Ch] [ebp-Ch] BYREF

  tmp = ftp_command(ftp, "MDTM", path, status);
  if ( status[0] != 213 )
    return -1;
  for ( p = tmp->ptr + 4; *p && *p == 32; ++p )
    ;
  memset(&tm, 0, sizeof(tm));
  if ( __isoc99_sscanf(
         p,
         "%04d%02d%02d%02d%02d%02d",
         &tm.tm_year,
         &tm.tm_mon,
         &tm.tm_mday,
         &tm.tm_hour,
         &tm.tm_min,
         &tm) <= 5 )
    return -1;
  tm.tm_year -= 1900;
  --tm.tm_mon;
  t = mktime(&tm);
  v3 = localtime(&t);
  lt = mktime(v3);
  v4 = gmtime(&t);
  gt = mktime(v4);
  return lt - gt + t;
}
// 8049DBC: using guessed type int __isoc99_sscanf(_DWORD, const char *, ...);

//----- (080A3221) --------------------------------------------------------
int __cdecl ftp_quit(FTP ftp)
{
  ftp_command(ftp, "QUIT", 0, 0);
  ftp_close(ftp);
  return 0;
}

//----- (080A325C) --------------------------------------------------------
void __cdecl closeFTPdata(FILE *f)
{
  int status[3]; // [esp+1Ch] [ebp-Ch] BYREF

  if ( f )
  {
    fclose(f);
    if ( current_ftp.data == f )
      current_ftp.data = 0;
  }
  ftp_command(&current_ftp, 0, 0, status);
}

//----- (080A32AC) --------------------------------------------------------
void closeFTP()
{
  ftp_close(&current_ftp);
}

//----- (080A32C0) --------------------------------------------------------
InputStream __cdecl openFTPStream(ParsedURL *pu, URLFile *uf)
{
  InputStream result; // eax
  char *v3; // eax
  char *v4; // eax
  __uid_t v5; // eax
  char *v6; // eax
  int v7; // eax
  char *v8; // ebx
  passwd *mypw; // [esp+2Ch] [ebp-2Ch]
  char *realpathname; // [esp+30h] [ebp-28h]
  int add_auth_cookie_flag; // [esp+34h] [ebp-24h]
  Str pwd; // [esp+38h] [ebp-20h] BYREF
  Str uname; // [esp+3Ch] [ebp-1Ch] BYREF
  char *pass; // [esp+40h] [ebp-18h]
  char *user; // [esp+44h] [ebp-14h]
  int status; // [esp+48h] [ebp-10h] BYREF
  Str tmp; // [esp+4Ch] [ebp-Ch]

  user = 0;
  pass = 0;
  uname = 0;
  pwd = 0;
  add_auth_cookie_flag = 0;
  if ( !pu->host )
    return 0;
  if ( !pu->user && !pu->pass && find_auth_user_passwd(pu, 0, &uname, &pwd, 0) )
  {
    if ( uname )
      user = uname->ptr;
    if ( pwd )
      pass = pwd->ptr;
  }
  if ( !user )
  {
    if ( pu->user )
      user = pu->user;
    else
      user = "anonymous";
  }
  if ( current_ftp.host )
  {
    if ( !strcmp(current_ftp.host, pu->host) && current_ftp.port == pu->port && !strcmp(current_ftp.user, user) )
    {
      ftp_command(&current_ftp, "NOOP", 0, &status);
      if ( status == 200 )
        goto ftp_read;
      ftp_close(&current_ftp);
    }
    else
    {
      ftp_quit(&current_ftp);
    }
  }
  if ( !pass )
  {
    if ( pu->pass )
    {
      pass = pu->pass;
    }
    else if ( pu->user )
    {
      pwd = 0;
      find_auth_user_passwd(pu, 0, &uname, &pwd, 0);
      if ( !pwd )
      {
        if ( fmInitialized )
        {
          term_raw();
          v3 = inputLineHistSearch("Password: ", 0, 64, 0, 0);
          pwd = Strnew_charp(v3);
          pwd = wc_Str_conv_strict(pwd, InnerCharset, SystemCharset);
          term_cbreak();
        }
        else
        {
          v4 = getpass("Password: ");
          pwd = Strnew_charp(v4);
        }
        add_auth_cookie_flag = 1;
      }
      pass = pwd->ptr;
    }
    else if ( ftppasswd && *ftppasswd )
    {
      pass = ftppasswd;
    }
    else
    {
      v5 = getuid();
      mypw = getpwuid(v5);
      if ( mypw )
        v6 = mypw->pw_name;
      else
        v6 = "anonymous";
      tmp = Strnew_charp(v6);
      if ( tmp->length + 1 >= tmp->area_size )
        Strgrow(tmp);
      v7 = tmp->length;
      tmp->ptr[v7] = 64;
      tmp->length = v7 + 1;
      tmp->ptr[tmp->length] = 0;
      pass = tmp->ptr;
    }
  }
  if ( !current_ftp.host )
  {
    current_ftp.host = allocStr(pu->host, -1);
    current_ftp.port = pu->port;
    current_ftp.user = allocStr(user, -1);
    current_ftp.pass = allocStr(pass, -1);
    if ( !ftp_login(&current_ftp) )
      return 0;
  }
  if ( add_auth_cookie_flag )
    add_auth_user_passwd(pu, 0, uname, pwd, 0);
ftp_read:
  ftp_command(&current_ftp, "TYPE", "I", &status);
  if ( ftp_pasv(&current_ftp) >= 0 )
  {
    if ( !pu->file )
      goto ftp_dir;
    if ( !*pu->file )
      goto ftp_dir;
    v8 = pu->file;
    if ( v8[strlen(v8) - 1] == 47 )
      goto ftp_dir;
    realpathname = file_unquote(pu->file);
    if ( *realpathname == 47 && realpathname[1] == 126 )
      ++realpathname;
    uf->modtime = ftp_modtime(&current_ftp, realpathname);
    ftp_command(&current_ftp, "RETR", realpathname, &status);
    if ( status == 125 || status == 150 )
    {
      result = newFileStream(current_ftp.data, (void (*)(...))closeFTPdata);
    }
    else
    {
ftp_dir:
      pu->scheme = 3;
      result = 0;
    }
  }
  else
  {
    ftp_quit(&current_ftp);
    result = 0;
  }
  return result;
}

//----- (080A37A6) --------------------------------------------------------
Str __cdecl loadFTPDir(ParsedURL *pu, wc_ces *charset)
{
  Str result; // eax
  int v3; // eax
  char *v4; // eax
  _Str *v5; // eax
  char **v6; // ebx
  _Str *v7; // eax
  int v8; // eax
  char *v9; // ebx
  char *v10; // eax
  char *v11; // eax
  int v12; // eax
  int v13; // eax
  _Str *v14; // eax
  char *v15; // eax
  _Str *v16; // eax
  char *v17; // ebx
  char *v18; // eax
  char *v19; // eax
  int j; // [esp+28h] [ebp-60h]
  int len; // [esp+2Ch] [ebp-5Ch]
  int max_len; // [esp+30h] [ebp-58h]
  int ftype; // [esp+34h] [ebp-54h]
  int ftypea; // [esp+34h] [ebp-54h]
  char *type_str; // [esp+38h] [ebp-50h]
  char *size; // [esp+3Ch] [ebp-4Ch] BYREF
  char *date; // [esp+40h] [ebp-48h] BYREF
  char *link; // [esp+44h] [ebp-44h] BYREF
  char *name; // [esp+48h] [ebp-40h] BYREF
  wc_ces doc_charset; // [esp+4Ch] [ebp-3Ch]
  void (*prevtrap)(int); // [esp+50h] [ebp-38h]
  int nfile_max; // [esp+54h] [ebp-34h]
  int nfile; // [esp+58h] [ebp-30h]
  int i; // [esp+5Ch] [ebp-2Ch]
  char **flist; // [esp+60h] [ebp-28h]
  char *q; // [esp+64h] [ebp-24h]
  char *fn; // [esp+68h] [ebp-20h]
  char *realpathname; // [esp+6Ch] [ebp-1Ch]
  int sv_type; // [esp+70h] [ebp-18h]
  int status; // [esp+74h] [ebp-14h] BYREF
  Str tmp; // [esp+78h] [ebp-10h]
  Str FTPDIRtmp; // [esp+7Ch] [ebp-Ch]

  prevtrap = 0;
  doc_charset = DocumentCharset;
  *charset = 256;
  if ( !current_ftp.data )
    return 0;
  tmp = ftp_command(&current_ftp, "SYST", 0, &status);
  sv_type = strstr(tmp->ptr, "UNIX") || !strncmp((const char *)tmp->ptr + 4, "Windows_NT", 0xAu);
  if ( pu->file && *pu->file )
  {
    realpathname = file_unquote(pu->file);
    if ( *realpathname == 47 && realpathname[1] == 126 )
      ++realpathname;
    if ( sv_type == 1 )
    {
      ftp_command(&current_ftp, "CWD", realpathname, &status);
      if ( status == 250 )
        ftp_command(&current_ftp, "LIST", 0, &status);
    }
    else
    {
      ftp_command(&current_ftp, "NLST", realpathname, &status);
    }
  }
  else
  {
    if ( sv_type == 1 )
      ftp_command(&current_ftp, "LIST", 0, &status);
    else
      ftp_command(&current_ftp, "NLST", 0, &status);
    pu->file = "/";
  }
  if ( status == 125 || status == 150 )
  {
    tmp = parsedURL2Str(pu);
    if ( tmp->length <= 0 || tmp->ptr[tmp->length - 1] != 47 )
    {
      if ( tmp->length + 1 >= tmp->area_size )
        Strgrow(tmp);
      v3 = tmp->length;
      tmp->ptr[v3] = 47;
      tmp->length = v3 + 1;
      tmp->ptr[tmp->length] = 0;
    }
    fn = html_quote(tmp->ptr);
    v4 = file_unquote(tmp->ptr);
    v5 = Strnew_charp(v4);
    tmp = convertLine(0, v5, 0, charset, doc_charset);
    q = html_quote(tmp->ptr);
    FTPDIRtmp = Strnew_m_charp(
                  "<html>\n<head>\n<base href=\"",
                  fn,
                  "\">\n<title>",
                  q,
                  "</title>\n</head>\n<body>\n<h1>Index of ",
                  q,
                  "</h1>\n",
                  0);
    if ( __sigsetjmp(AbortLoading_2, 1) )
    {
      if ( sv_type == 1 )
        Strcat_charp(FTPDIRtmp, "</a></pre>\n");
      else
        Strcat_charp(FTPDIRtmp, "</a></ul>\n");
      Strcat_charp(FTPDIRtmp, "<p>Transfer Interrupted!\n");
    }
    else
    {
      if ( TrapSignal )
      {
        prevtrap = mySignal(2, KeyAbort_2);
        if ( fmInitialized )
          term_cbreak();
      }
      if ( sv_type == 1 )
        Strcat_charp(FTPDIRtmp, "<pre>\n");
      else
        Strcat_charp(FTPDIRtmp, "<ul>\n<li>");
      Strcat_charp(FTPDIRtmp, "<a href=\"..\">[Upper Directory]</a>\n");
      nfile_max = 100;
      flist = (char **)GC_malloc(400);
      nfile = 0;
      if ( sv_type == 1 )
      {
        max_len = 20;
        while ( 1 )
        {
          tmp = Strfgets(current_ftp.data);
          if ( tmp->length <= 0 )
            break;
          Strchop(tmp);
          ftype = ex_ftpdir_name_size_date(tmp->ptr, &name, &link, &date, &size);
          if ( ftype )
          {
            if ( strcmp(".", name) )
            {
              if ( strcmp("..", name) )
              {
                len = strlen(name);
                if ( len )
                {
                  if ( ftype == 1 )
                  {
                    ++len;
                    type_str = "/";
                  }
                  else if ( ftype == 2 )
                  {
                    ++len;
                    type_str = "@";
                  }
                  else
                  {
                    type_str = " ";
                  }
                  if ( max_len < len )
                    max_len = len;
                  v6 = &flist[nfile];
                  *v6 = Sprintf("%s%s\n%s  %5s%s", name, type_str, date, size, link)->ptr;
                  if ( ++nfile == nfile_max )
                  {
                    nfile_max *= 2;
                    flist = (char **)GC_realloc(flist, 4 * nfile_max);
                  }
                }
              }
            }
          }
        }
        qsort(flist, nfile, 4u, strCmp);
        for ( j = 0; j < nfile; ++j )
        {
          fn = flist[j];
          date = strchr(fn, 10);
          if ( *(date - 1) == 47 )
          {
            ftypea = 1;
            *date = 0;
          }
          else
          {
            if ( *(date - 1) == 64 )
              ftypea = 2;
            else
              ftypea = 3;
            *(date - 1) = 0;
          }
          ++date;
          v7 = Strnew_charp(fn);
          tmp = convertLine(0, v7, 0, charset, doc_charset);
          if ( ftypea == 2 )
          {
            if ( tmp->length + 1 >= tmp->area_size )
              Strgrow(tmp);
            v8 = tmp->length;
            tmp->ptr[v8] = 64;
            tmp->length = v8 + 1;
            tmp->ptr[tmp->length] = 0;
          }
          v9 = html_quote(tmp->ptr);
          v10 = file_quote(fn);
          v11 = html_quote(v10);
          Strcat_m_charp(FTPDIRtmp, "<a href=\"", v11, "\">", v9, "</a>", 0);
          for ( i = wtf_strwidth((wc_uchar *)tmp->ptr); i <= max_len; ++i )
          {
            if ( (((_BYTE)i + (unsigned __int8)(max_len % 2)) & 1) != 0 )
            {
              if ( FTPDIRtmp->length + 1 >= FTPDIRtmp->area_size )
                Strgrow(FTPDIRtmp);
              v12 = FTPDIRtmp->length;
              FTPDIRtmp->ptr[v12] = 46;
              FTPDIRtmp->length = v12 + 1;
              FTPDIRtmp->ptr[FTPDIRtmp->length] = 0;
            }
            else
            {
              if ( FTPDIRtmp->length + 1 >= FTPDIRtmp->area_size )
                Strgrow(FTPDIRtmp);
              v13 = FTPDIRtmp->length;
              FTPDIRtmp->ptr[v13] = 32;
              FTPDIRtmp->length = v13 + 1;
              FTPDIRtmp->ptr[FTPDIRtmp->length] = 0;
            }
          }
          v14 = Strnew_charp(date);
          tmp = convertLine(0, v14, 0, charset, doc_charset);
          v15 = html_quote(tmp->ptr);
          Strcat_m_charp(FTPDIRtmp, v15, "\n", 0);
        }
        Strcat_charp(FTPDIRtmp, "</pre>\n");
      }
      else
      {
        while ( 1 )
        {
          tmp = Strfgets(current_ftp.data);
          if ( tmp->length <= 0 )
            break;
          Strchop(tmp);
          flist[nfile++] = mybasename(tmp->ptr);
          if ( nfile == nfile_max )
          {
            nfile_max *= 2;
            flist = (char **)GC_realloc(flist, 4 * nfile_max);
          }
        }
        qsort(flist, nfile, 4u, strCmp);
        for ( i = 0; i < nfile; ++i )
        {
          fn = flist[i];
          v16 = Strnew_charp(fn);
          tmp = convertLine(0, v16, 0, charset, doc_charset);
          v17 = html_quote(tmp->ptr);
          v18 = file_quote(fn);
          v19 = html_quote(v18);
          Strcat_m_charp(FTPDIRtmp, "<li><a href=\"", v19, "\">", v17, "</a>\n", 0);
        }
        Strcat_charp(FTPDIRtmp, "</ul>\n");
      }
    }
    Strcat_charp(FTPDIRtmp, "</body>\n</html>\n");
    if ( TrapSignal )
    {
      if ( fmInitialized )
        term_raw();
      if ( prevtrap )
        mySignal(2, prevtrap);
    }
    closeFTPdata(current_ftp.data);
    result = FTPDIRtmp;
  }
  else
  {
    fclose(current_ftp.data);
    current_ftp.data = 0;
    result = 0;
  }
  return result;
}
// 8049E6C: using guessed type int __cdecl GC_realloc(_DWORD, _DWORD);
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (080A41AF) --------------------------------------------------------
void disconnectFTP()
{
  ftp_quit(&current_ftp);
}

//----- (080A41C3) --------------------------------------------------------
int __cdecl ex_ftpdir_name_size_date(char *line, char **name, char **link, char **date, char **sizep)
{
  int v5; // eax
  clen_t size; // [esp+18h] [ebp-20h]
  __int64 sizea; // [esp+18h] [ebp-20h]
  char *p; // [esp+24h] [ebp-14h]
  char *pa; // [esp+24h] [ebp-14h]
  const char *pb; // [esp+24h] [ebp-14h]
  char *cp; // [esp+28h] [ebp-10h]
  char *cpa; // [esp+28h] [ebp-10h]
  char *cpb; // [esp+28h] [ebp-10h]
  char *cpc; // [esp+28h] [ebp-10h]
  char *cpd; // [esp+28h] [ebp-10h]
  char *cpe; // [esp+28h] [ebp-10h]
  int ftype; // [esp+2Ch] [ebp-Ch]

  ftype = 0;
  if ( strlen(line) > 0xA && (MYCTYPE_MAP[(unsigned __int8)line[10]] & 2) != 0 )
  {
    for ( cp = line + 11; (MYCTYPE_MAP[(unsigned __int8)*cp] & 2) != 0 && *cp; ++cp )
      ;
    if ( *cp )
    {
      size = 0LL;
      while ( *cp && (MYCTYPE_MAP[(unsigned __int8)*cp] & 8) != 0 )
        size = *cp++ + 10 * size - 48;
      if ( *cp )
      {
        for ( cpa = cp + 1; (MYCTYPE_MAP[(unsigned __int8)*cpa] & 2) != 0 && *cpa; ++cpa )
          ;
        if ( *cpa )
        {
          while ( (MYCTYPE_MAP[(unsigned __int8)*cpa] & 2) == 0 && *cpa )
            ++cpa;
          if ( *cpa )
          {
            for ( cpb = cpa + 1; (MYCTYPE_MAP[(unsigned __int8)*cpb] & 2) != 0 && *cpb; ++cpb )
              ;
            if ( *cpb )
            {
              while ( (MYCTYPE_MAP[(unsigned __int8)*cpb] & 2) == 0 && *cpb )
                ++cpb;
              if ( *cpb )
              {
                for ( cpc = cpb + 1; (MYCTYPE_MAP[(unsigned __int8)*cpc] & 2) != 0 && *cpc; ++cpc )
                  ;
                if ( *cpc )
                {
                  p = cpc;
                  sizea = 0LL;
                  while ( *cpc && (MYCTYPE_MAP[(unsigned __int8)*cpc] & 8) != 0 )
                    sizea = *cpc++ + 10 * sizea - 48;
                  if ( *cpc )
                  {
                    if ( *cpc == 44 )
                    {
                      ++cpc;
                      while ( (MYCTYPE_MAP[(unsigned __int8)*cpc] & 2) != 0 && *cpc )
                        ++cpc;
                      if ( !*cpc )
                        return ftype;
                      while ( (MYCTYPE_MAP[(unsigned __int8)*cpc] & 2) == 0 && *cpc )
                        ++cpc;
                      if ( !*cpc )
                        return ftype;
                      *sizep = allocStr(p, cpc - p);
                    }
                    else
                    {
                      *sizep = size_int2str(sizea)->ptr;
                    }
                    cpd = cpc + 1;
                    pa = cpd;
                    while ( (MYCTYPE_MAP[(unsigned __int8)*cpd] & 2) != 0 && *cpd )
                      ++cpd;
                    if ( *cpd )
                    {
                      while ( (MYCTYPE_MAP[(unsigned __int8)*cpd] & 2) == 0 && *cpd )
                        ++cpd;
                      if ( *cpd )
                      {
                        while ( (MYCTYPE_MAP[(unsigned __int8)*cpd] & 2) != 0 && *cpd )
                          ++cpd;
                        if ( *cpd )
                        {
                          while ( (MYCTYPE_MAP[(unsigned __int8)*cpd] & 2) == 0 && *cpd )
                            ++cpd;
                          if ( *cpd )
                          {
                            while ( (MYCTYPE_MAP[(unsigned __int8)*cpd] & 2) != 0 && *cpd )
                              ++cpd;
                            if ( *cpd )
                            {
                              while ( (MYCTYPE_MAP[(unsigned __int8)*cpd] & 2) == 0 && *cpd )
                                ++cpd;
                              if ( *cpd )
                              {
                                *date = allocStr(pa, cpd - pa);
                                for ( cpe = cpd + 1; (MYCTYPE_MAP[(unsigned __int8)*cpe] & 2) != 0 && *cpe; ++cpe )
                                  ;
                                if ( *cpe )
                                {
                                  v5 = *line;
                                  if ( v5 == 100 )
                                  {
                                    ftype = 1;
                                    *name = allocStr(cpe, -1);
                                    *link = (char *)&byte_80CF3D8;
                                    *sizep = (char *)&byte_80CF3D8;
                                  }
                                  else if ( v5 == 108 )
                                  {
                                    ftype = 2;
                                    pb = strstr(cpe, " -> ");
                                    if ( pb )
                                    {
                                      *name = allocStr(cpe, pb - cpe);
                                      *link = allocStr(pb, -1);
                                      *sizep = (char *)&byte_80CF3D8;
                                    }
                                  }
                                  else
                                  {
                                    ftype = 3;
                                    *name = allocStr(cpe, -1);
                                    *link = (char *)&byte_80CF3D8;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return ftype;
}

//----- (080A47D6) --------------------------------------------------------
Str __cdecl size_int2str(clen_t size)
{
  double dtmp; // [esp+28h] [ebp-20h]
  char *unit_str; // [esp+30h] [ebp-18h]
  char *size_format; // [esp+34h] [ebp-14h]
  int unit; // [esp+38h] [ebp-10h]

  dtmp = (double)size;
  for ( unit = 0; unit <= 2 && dtmp >= 1024.0; ++unit )
    dtmp = dtmp / 1024.0;
  if ( unit && dtmp <= 100.0 )
  {
    if ( dtmp <= 10.0 )
      size_format = "%.2f%s";
    else
      size_format = "%.1f%s";
  }
  else
  {
    size_format = "%.0f%s";
  }
  switch ( unit )
  {
    case 2:
      unit_str = "M";
      break;
    case 3:
      unit_str = "G";
      break;
    case 1:
      unit_str = "K";
      break;
    default:
      unit_str = (char *)&byte_80CF3D8;
      break;
  }
  return Sprintf(size_format, dtmp, unit_str);
}

//----- (080A48C8) --------------------------------------------------------
unsigned __int8 __cdecl c2e(char x)
{
  if ( x > 64 && x <= 90 )
    return x - 65;
  if ( x > 96 && x <= 122 )
    return x - 71;
  if ( x > 47 && x <= 57 )
    return x + 4;
  if ( x == 43 )
    return 62;
  if ( x == 47 )
    return 63;
  return -1;
}

//----- (080A4934) --------------------------------------------------------
int __cdecl ha2d(char x, char y)
{
  int r; // [esp+14h] [ebp-4h]
  int ra; // [esp+14h] [ebp-4h]

  r = 0;
  if ( x <= 47 || x > 57 )
  {
    if ( x <= 64 || x > 70 )
    {
      if ( x > 96 && x <= 102 )
        r = x - 87;
    }
    else
    {
      r = x - 55;
    }
  }
  else
  {
    r = x - 48;
  }
  ra = 16 * r;
  if ( y <= 47 || y > 57 )
  {
    if ( y <= 64 || y > 70 )
    {
      if ( y > 96 && y <= 102 )
        ra += y - 87;
    }
    else
    {
      ra += y - 55;
    }
  }
  else
  {
    ra += y - 48;
  }
  return ra;
}

//----- (080A49E2) --------------------------------------------------------
Str __cdecl decodeB(char **ww)
{
  int v1; // eax
  int v3; // eax
  Str ap; // [esp+18h] [ebp-20h]
  int n_pad; // [esp+1Ch] [ebp-1Ch]
  int i; // [esp+20h] [ebp-18h]
  int ia; // [esp+20h] [ebp-18h]
  int ib; // [esp+20h] [ebp-18h]
  int ic; // [esp+20h] [ebp-18h]
  char *wp; // [esp+24h] [ebp-14h]
  unsigned __int8 c[4]; // [esp+29h] [ebp-Fh]
  char d[3]; // [esp+2Dh] [ebp-Bh]

  wp = *ww;
  v1 = strlen(*ww);
  ap = Strnew_size(v1);
  n_pad = 0;
  do
  {
    for ( i = 0; i <= 3; ++i )
    {
      c[i] = *wp++;
      if ( !*wp || *wp == 63 )
      {
        for ( ia = i + 1; ia <= 3; ++ia )
          c[ia] = 61;
        break;
      }
    }
    if ( c[3] == 61 )
    {
      n_pad = 1;
      c[3] = 65;
      if ( c[2] == 61 )
      {
        n_pad = 2;
        c[2] = 65;
      }
    }
    for ( ib = 0; ib <= 3; ++ib )
    {
      c[ib] = c2e(c[ib]);
      if ( c[ib] == 0xFF )
      {
        *ww = wp;
        return ap;
      }
    }
    d[0] = (4 * c[0]) | (c[1] >> 4);
    d[1] = (16 * c[1]) | (c[2] >> 2);
    d[2] = (c[2] << 6) | c[3];
    for ( ic = 0; 3 - n_pad > ic; ++ic )
    {
      if ( ap->length + 1 >= ap->area_size )
        Strgrow(ap);
      v3 = ap->length;
      ap->ptr[v3] = d[ic];
      ap->length = v3 + 1;
      ap->ptr[ap->length] = 0;
    }
  }
  while ( !n_pad && *wp && *wp != 63 );
  *ww = wp;
  return ap;
}

//----- (080A4BAB) --------------------------------------------------------
Str __cdecl decodeU(char **ww)
{
  int v2; // eax
  Str a; // [esp+2Ch] [ebp-2Ch]
  int i; // [esp+30h] [ebp-28h]
  int n; // [esp+34h] [ebp-24h]
  char *w; // [esp+38h] [ebp-20h]
  char *wa; // [esp+38h] [ebp-20h]
  unsigned __int8 c2; // [esp+3Eh] [ebp-1Ah]
  unsigned __int8 c1; // [esp+3Fh] [ebp-19h]

  w = *ww;
  if ( **ww <= 32 || *w > 95 )
    return Strnew_size(0);
  n = *w - 32;
  a = Strnew_size(n);
  wa = w + 1;
  i = 2;
  while ( *wa && n )
  {
    c1 = (*wa - 32) % 64;
    c2 = (wa[1] - 32) % 64;
    if ( a->length + 1 >= a->area_size )
      Strgrow(a);
    v2 = a->length;
    a->ptr[v2] = (c1 << i) | ((int)c2 >> (6 - i));
    a->length = v2 + 1;
    a->ptr[a->length] = 0;
    if ( i == 6 )
    {
      wa += 2;
      i = 2;
    }
    else
    {
      ++wa;
      i += 2;
    }
    --n;
  }
  return a;
}

//----- (080A4D08) --------------------------------------------------------
Str __cdecl decodeQ(char **ww)
{
  int v1; // eax
  int v2; // ebx
  char *v3; // esi
  int v4; // eax
  int v5; // eax
  Str a; // [esp+18h] [ebp-10h]
  char *w; // [esp+1Ch] [ebp-Ch]
  char *wa; // [esp+1Ch] [ebp-Ch]

  w = *ww;
  v1 = strlen(*ww);
  a = Strnew_size(v1);
  while ( *w && *w != 63 )
  {
    if ( *w == 61 )
    {
      wa = w + 1;
      if ( a->length + 1 >= a->area_size )
        Strgrow(a);
      v2 = a->length;
      v3 = &a->ptr[v2];
      *v3 = ha2d(*wa, wa[1]);
      a->length = v2 + 1;
      a->ptr[a->length] = 0;
      w = wa + 1;
    }
    else if ( *w == 95 )
    {
      if ( a->length + 1 >= a->area_size )
        Strgrow(a);
      v4 = a->length;
      a->ptr[v4] = 32;
      a->length = v4 + 1;
      a->ptr[a->length] = 0;
    }
    else
    {
      if ( a->length + 1 >= a->area_size )
        Strgrow(a);
      v5 = a->length;
      a->ptr[v5] = *w;
      a->length = v5 + 1;
      a->ptr[a->length] = 0;
    }
    ++w;
  }
  *ww = w;
  return a;
}

//----- (080A4E89) --------------------------------------------------------
Str __cdecl decodeQP(char **ww)
{
  int v1; // eax
  int v2; // ebx
  char *v3; // esi
  int v4; // eax
  Str a; // [esp+18h] [ebp-10h]
  char *w; // [esp+1Ch] [ebp-Ch]

  w = *ww;
  v1 = strlen(*ww);
  a = Strnew_size(v1);
  while ( *w )
  {
    if ( *w == 61 )
    {
      if ( *++w == 10 || *w == 13 || *w == 32 || *w == 9 )
      {
        while ( *w != 10 && *w )
          ++w;
        if ( !*w )
          break;
      }
      else
      {
        if ( !*w || !w[1] )
          break;
        if ( a->length + 1 >= a->area_size )
          Strgrow(a);
        v2 = a->length;
        v3 = &a->ptr[v2];
        *v3 = ha2d(*w, w[1]);
        a->length = v2 + 1;
        a->ptr[a->length] = 0;
        ++w;
      }
    }
    else
    {
      if ( a->length + 1 >= a->area_size )
        Strgrow(a);
      v4 = a->length;
      a->ptr[v4] = *w;
      a->length = v4 + 1;
      a->ptr[a->length] = 0;
    }
    ++w;
  }
  *ww = w;
  return a;
}

//----- (080A502A) --------------------------------------------------------
Str __cdecl decodeWord(char **ow, wc_ces *charset)
{
  int v2; // eax
  int v3; // eax
  Str tmp; // [esp+18h] [ebp-20h]
  _Str *a; // [esp+1Ch] [ebp-1Ch]
  char *w; // [esp+20h] [ebp-18h] BYREF
  char *p; // [esp+24h] [ebp-14h]
  wc_ces c; // [esp+28h] [ebp-10h]
  char method; // [esp+2Fh] [ebp-9h]

  w = *ow;
  Strnew();
  tmp = Strnew();
  if ( *w != 61 || w[1] != 63 )
    return Strnew();
  for ( w += 2; *w != 63; ++w )
  {
    if ( !*w )
      return Strnew();
    if ( tmp->length + 1 >= tmp->area_size )
      Strgrow(tmp);
    v2 = tmp->length;
    tmp->ptr[v2] = *w;
    tmp->length = v2 + 1;
    tmp->ptr[tmp->length] = 0;
  }
  c = wc_guess_charset(tmp->ptr, 0);
  if ( !c )
    return Strnew();
  method = *++w;
  if ( *++w != 63 )
    return Strnew();
  p = ++w;
  if ( (MYCTYPE_MAP[(unsigned __int8)method] & 4) != 0 )
    v3 = (char)(method & 0xDF);
  else
    v3 = method;
  if ( v3 == 66 )
  {
    a = decodeB(&w);
  }
  else
  {
    if ( v3 != 81 )
      return Strnew();
    a = decodeQ(&w);
  }
  if ( p == w )
    return Strnew();
  if ( *w == 63 && *++w == 61 )
    ++w;
  *ow = w;
  *charset = c;
  return a;
}

//----- (080A51E0) --------------------------------------------------------
Str __cdecl decodeMIME(Str orgstr, wc_ces *charset)
{
  Str result; // eax
  int v3; // eax
  int v4; // eax
  _Str *v5; // [esp+4h] [ebp-34h]
  Str cnv; // [esp+1Ch] [ebp-1Ch]
  char *p; // [esp+20h] [ebp-18h]
  char *org0; // [esp+24h] [ebp-14h]
  char *endp; // [esp+28h] [ebp-10h]
  char *org; // [esp+2Ch] [ebp-Ch] BYREF

  org = orgstr->ptr;
  endp = &org[orgstr->length];
  cnv = 0;
  *charset = 0;
LABEL_24:
  while ( org < endp )
  {
    if ( *org == 61 && org[1] == 63 )
    {
      if ( !cnv )
      {
        cnv = Strnew_size(orgstr->length);
        Strcat_charp_n(cnv, orgstr->ptr, org - orgstr->ptr);
      }
      while ( 2 )
      {
        p = org;
        v5 = decodeWord(&org, charset);
        savexmlstr_0(cnv, v5);
        if ( org == p )
        {
          Strcat_charp(cnv, org);
          return cnv;
        }
        for ( org0 = org; ; ++org0 )
        {
          v3 = *org0;
          if ( v3 == 13 )
            continue;
          if ( v3 > 13 )
            break;
          if ( (unsigned int)(v3 - 9) > 1 )
            goto LABEL_24;
LABEL_16:
          ;
        }
        if ( v3 == 32 )
          goto LABEL_16;
        if ( v3 == 61 && org0[1] == 63 )
        {
          org = org0;
          continue;
        }
        break;
      }
    }
    else
    {
      if ( cnv )
      {
        if ( cnv->length + 1 >= cnv->area_size )
          Strgrow(cnv);
        v4 = cnv->length;
        cnv->ptr[v4] = *org;
        cnv->length = v4 + 1;
        cnv->ptr[cnv->length] = 0;
      }
      ++org;
    }
  }
  if ( cnv )
    result = cnv;
  else
    result = orgstr;
  return result;
}

//----- (080A5389) --------------------------------------------------------
Str __cdecl encodeB(char *a)
{
  int v1; // eax
  int v2; // eax
  int v3; // eax
  int v4; // eax
  Str w; // [esp+1Ch] [ebp-1Ch]
  int n_pad; // [esp+20h] [ebp-18h]
  int i; // [esp+24h] [ebp-14h]
  unsigned __int8 d[3]; // [esp+29h] [ebp-Fh]
  unsigned __int8 c4; // [esp+2Ch] [ebp-Ch]
  unsigned __int8 c3; // [esp+2Dh] [ebp-Bh]
  unsigned __int8 c2; // [esp+2Eh] [ebp-Ah]
  unsigned __int8 c1; // [esp+2Fh] [ebp-9h]

  w = Strnew();
  while ( *a )
  {
    n_pad = 0;
    d[2] = 0;
    d[1] = 0;
    for ( i = 0; i <= 2; ++i )
    {
      d[i] = a[i];
      if ( !a[i] )
      {
        n_pad = 3 - i;
        break;
      }
    }
    c1 = d[0] >> 2;
    c2 = ((16 * d[0]) | (d[1] >> 4)) & 0x3F;
    if ( n_pad == 2 )
    {
      c4 = 64;
      c3 = 64;
    }
    else if ( n_pad == 1 )
    {
      c3 = (4 * d[1]) & 0x3F;
      c4 = 64;
    }
    else
    {
      c3 = ((4 * d[1]) | (d[2] >> 6)) & 0x3F;
      c4 = d[2] & 0x3F;
    }
    if ( w->length + 1 >= w->area_size )
      Strgrow(w);
    v1 = w->length;
    w->ptr[v1] = Base64Table[c1];
    w->length = v1 + 1;
    w->ptr[w->length] = 0;
    if ( w->length + 1 >= w->area_size )
      Strgrow(w);
    v2 = w->length;
    w->ptr[v2] = Base64Table[c2];
    w->length = v2 + 1;
    w->ptr[w->length] = 0;
    if ( w->length + 1 >= w->area_size )
      Strgrow(w);
    v3 = w->length;
    w->ptr[v3] = Base64Table[c3];
    w->length = v3 + 1;
    w->ptr[w->length] = 0;
    if ( w->length + 1 >= w->area_size )
      Strgrow(w);
    v4 = w->length;
    w->ptr[v4] = Base64Table[c4];
    w->length = v4 + 1;
    w->ptr[w->length] = 0;
    if ( n_pad )
      break;
    a += 3;
  }
  return w;
}

//----- (080A55D8) --------------------------------------------------------
longchar *set_longchar(longchar *retstr, char *str)
{
  wc_wchar_t v3; // [esp+18h] [ebp-30h] BYREF
  longchar r; // [esp+2Ch] [ebp-1Ch]
  unsigned __int8 *p; // [esp+3Ch] [ebp-Ch] BYREF

  p = (unsigned __int8 *)str;
  if ( *str >= 0 )
  {
    r.ch = *p;
    r.type = 1;
    *retstr = r;
  }
  else
  {
    wtf_parse1(&v3, &p);
    r.wch = v3;
    if ( v3.ccs == 2048 || r.wch.ccs == 34816 )
    {
      r.type = 4;
      *retstr = r;
    }
    else
    {
      if ( LOWORD(r.wch.ccs) == 4096 || LOWORD(r.wch.ccs) == 0x2000 || LOWORD(r.wch.ccs) == 8193 )
      {
        if ( LOWORD(r.wch.ccs) == 8193 )
          r.wch.code &= 0x1FFFFFu;
        r.wch.ccs = 0x2000;
      }
      else
      {
        r.wch.ccs = LOWORD(r.wch.ccs);
      }
      r.type = 2;
      *retstr = r;
    }
  }
  return retstr;
}
// 80A55D8: inconsistent function type and number of purged bytes

//----- (080A56F0) --------------------------------------------------------
char *__cdecl regexCompile(char *ex, int igncase)
{
  char *msg; // [esp+1Ch] [ebp-Ch] BYREF

  newRegex(ex, igncase, &DefaultRegex, &msg);
  return msg;
}

//----- (080A571C) --------------------------------------------------------
Regex *__cdecl newRegex0(char **ex, int igncase, Regex *regex, char **msg, int level)
{
  Regex *result; // eax
  regexchar_0 *v6; // ecx
  int v7; // edx
  longchar *v8; // ebx
  longchar *v9; // ebx
  longchar *v10; // ebx
  longchar *v11; // eax
  longchar *v12; // ebx
  longchar v13; // [esp+20h] [ebp-38h] BYREF
  longchar *st_ptr; // [esp+3Ch] [ebp-1Ch]
  int m; // [esp+40h] [ebp-18h]
  regexchar_0 *re; // [esp+44h] [ebp-14h]
  longchar *r; // [esp+48h] [ebp-10h]
  char *p[2]; // [esp+4Ch] [ebp-Ch] BYREF

  if ( !regex )
    regex = (Regex *)GC_malloc(4620);
  regex->alt_regex = 0;
  re = (regexchar_0 *)regex;
  st_ptr = regex->storage;
  p[0] = *ex;
LABEL_74:
  if ( !*p[0] )
  {
    re->mode |= 7u;
    if ( msg )
      *msg = 0;
    *ex = p[0];
    return regex;
  }
  re->mode = 0;
  switch ( *p[0] )
  {
    case '$':
      re->p.pattern = 0;
      re->mode = re->mode & 0xF8 | 6;
      ++re;
      goto LABEL_68;
    case '(':
      re->mode = re->mode & 0xF8 | 4;
      ++p[0];
      v11 = (longchar *)newRegex0(p, igncase, 0, msg, level + 1);
      re->p.pattern = v11;
      if ( !re->p.pattern )
        return 0;
      ++re;
      goto LABEL_68;
    case ')':
      if ( level )
      {
        re->mode |= 7u;
        ++re;
        *ex = p[0];
        result = regex;
      }
      else
      {
        if ( msg )
          *msg = "Too many ')'";
        result = 0;
      }
      return result;
    case '*':
      if ( regex == (Regex *)re || (re[-1].mode & 7) != 1 && !re[-1].p.pattern )
      {
        if ( msg )
          *msg = "Invalid regular expression";
        return 0;
      }
      re[-1].mode |= 0x10u;
      goto LABEL_68;
    case '+':
      if ( regex == (Regex *)re || (re[-1].mode & 7) != 1 && !re[-1].p.pattern )
      {
        if ( msg )
          *msg = "Invalid regular expression";
        return 0;
      }
      v6 = re;
      v7 = *(_DWORD *)&re[-1].mode;
      re->p.pattern = re[-1].p.pattern;
      *(_DWORD *)&v6->mode = v7;
      re->mode |= 0x10u;
      ++re;
      goto LABEL_68;
    case '.':
      re->p.pattern = 0;
      re->mode = re->mode & 0xF8 | 1;
      ++re;
      goto LABEL_68;
    case '?':
      if ( regex == (Regex *)re || (re[-1].mode & 7) != 1 && !re[-1].p.pattern )
      {
        if ( msg )
          *msg = "Invalid regular expression";
        return 0;
      }
      re[-1].mode |= 8u;
      goto LABEL_68;
    case '[':
      r = st_ptr;
      if ( *++p[0] == 94 )
      {
        ++p[0];
        m = 3;
      }
      else
      {
        m = 2;
      }
      if ( *p[0] == 45 || *p[0] == 93 )
      {
        v8 = st_ptr;
        set_longchar(&v13, p[0]);
        *v8 = v13;
        ++st_ptr;
      }
      break;
    case '\\':
      ++p[0];
      goto LABEL_65;
    case '^':
      re->p.pattern = 0;
      re->mode = re->mode & 0xF8 | 5;
      ++re;
      goto LABEL_68;
    case '|':
      re->mode |= 7u;
      ++re;
      ++p[0];
      regex->alt_regex = newRegex0(p, igncase, 0, msg, level);
      if ( !regex->alt_regex )
        return 0;
      *ex = p[0];
      return regex;
    default:
LABEL_65:
      v12 = st_ptr;
      set_longchar(&v13, p[0]);
      *v12 = v13;
      p[0] += WTF_LEN_MAP[(unsigned __int8)*p[0]] - 1;
      re->p.pattern = st_ptr++;
      re->mode &= 0xF8u;
      if ( igncase )
        re->mode |= 0x40u;
      ++re;
      goto LABEL_68;
  }
  while ( 1 )
  {
    if ( *p[0] == 93 )
    {
      st_ptr->type = 0;
      ++st_ptr;
      re->p.pattern = r;
      re->mode = re->mode & 0xF8 | m & 7;
      if ( igncase )
        re->mode |= 0x40u;
      ++re;
LABEL_68:
      if ( &regex->position <= (char **)st_ptr || regex->storage <= (longchar *)re )
      {
        if ( msg )
          *msg = "Regular expression too long";
        return 0;
      }
      ++p[0];
      goto LABEL_74;
    }
    if ( *p[0] != 92 )
      break;
    ++p[0];
    v9 = st_ptr;
    set_longchar(&v13, p[0]);
    *v9 = v13;
    ++st_ptr;
    p[0] += WTF_LEN_MAP[(unsigned __int8)*p[0]];
LABEL_45:
    if ( &regex->position <= (char **)st_ptr )
    {
      if ( msg )
        *msg = "Regular expression too long";
      return 0;
    }
  }
  if ( *p[0] == 45 && p[0][1] != 93 )
  {
    st_ptr->type = 3;
    ++st_ptr;
    ++p[0];
    goto LABEL_45;
  }
  if ( *p[0] )
  {
    v10 = st_ptr;
    set_longchar(&v13, p[0]);
    *v10 = v13;
    ++st_ptr;
    p[0] += WTF_LEN_MAP[(unsigned __int8)*p[0]];
    goto LABEL_45;
  }
  if ( msg )
    *msg = "Missing ]";
  return 0;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (080A5D6B) --------------------------------------------------------
Regex *__cdecl newRegex(char *ex, int igncase, Regex *regex, char **msg)
{
  return newRegex0(&ex, igncase, regex, msg, 0);
}

//----- (080A5D9B) --------------------------------------------------------
int __cdecl __gmp_vfprintf(char *str, int len, int firstp)
{
  return RegexMatch(&DefaultRegex, str, len, firstp);
}

//----- (080A5DC4) --------------------------------------------------------
int __cdecl RegexMatch(Regex *re, char *str, int len, int firstp)
{
  int v5; // eax
  int v6; // eax
  Regex *r; // [esp+20h] [ebp-18h]
  char *lpos; // [esp+24h] [ebp-14h] BYREF
  char *ep; // [esp+28h] [ebp-10h]
  char *p; // [esp+2Ch] [ebp-Ch]

  if ( !str )
    return 0;
  if ( len < 0 )
    len = strlen(str);
  re->position = 0;
  ep = &str[len];
  for ( p = str; p <= ep; ++p )
  {
    lpos = 0;
    re->lposition = 0;
    for ( r = re; r; r = r->alt_regex )
    {
      v5 = firstp && p == str;
      v6 = regmatch(r->re, p, ep, v5, &lpos);
      if ( v6 == -1 )
      {
        re->position = 0;
        return -1;
      }
      if ( v6 == 1 )
      {
        re->position = p;
        if ( !re->lposition || re->lposition < lpos )
          re->lposition = lpos;
      }
    }
    if ( re->lposition )
      return 1;
    p += WTF_LEN_MAP[(unsigned __int8)*p] - 1;
  }
  return 0;
}

//----- (080A5F1C) --------------------------------------------------------
void __cdecl MatchedPosition(Regex *re, char **first, char **last)
{
  *first = re->position;
  *last = re->lposition;
}

//----- (080A5F3D) --------------------------------------------------------
void __cdecl matchedPosition(char **first, char **last)
{
  *first = DefaultRegex.position;
  *last = DefaultRegex.lposition;
}

//----- (080A5F58) --------------------------------------------------------
int __cdecl regmatch_sub_anytime(MatchingContext2 *c, Regex *regex, regexchar_0 *pat2, char *str, char *end_p, int iter_limit, int firstp)
{
  int v7; // eax

  v7 = c->label;
  if ( c->label == 2 )
    goto label2;
  if ( v7 == 3 )
    goto label3;
  if ( v7 == 1 )
    goto label2;
  c->ctx = (MatchingContext1 *)GC_malloc(44);
  c->ctx2 = (MatchingContext2 *)GC_malloc(32);
  c->ctx->label = 0;
  c->regex = regex;
  c->n_any = 0;
  c->str = str;
  c->firstp = firstp;
  while ( 1 )
  {
    c->ctx->label = 0;
    while ( regmatch_iter(c->ctx, c->regex->re, c->str, end_p, c->firstp) )
    {
      c->n_any = c->ctx->lastpos - c->str;
      if ( c->n_any > 0 )
      {
        c->firstp = 0;
        if ( (pat2->mode & 7) == 7 )
        {
          c->lastpos = &c->str[c->n_any];
          c->label = 1;
          return 1;
        }
        if ( regmatch(pat2, &c->str[c->n_any], end_p, c->firstp, &c->lastpos) == 1 )
        {
          c->label = 2;
          return 1;
        }
label2:
        if ( iter_limit != 1 )
        {
          c->ctx2->label = 0;
label3:
          if ( regmatch_sub_anytime(c->ctx2, regex, pat2, &c->str[c->n_any], end_p, iter_limit - 1, c->firstp) )
          {
            c->lastpos = c->ctx2->lastpos;
            c->label = 3;
            return 1;
          }
        }
      }
    }
    if ( !c->regex->alt_regex )
      break;
    c->regex = c->regex->alt_regex;
  }
  return 0;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (080A61A6) --------------------------------------------------------
int __cdecl regmatch_iter(MatchingContext1 *c, regexchar_0 *re, char *str, char *end_p, int firstp)
{
  int result; // eax
  int v6; // eax
  longchar v7; // [esp+30h] [ebp-38h] BYREF
  longchar k; // [esp+40h] [ebp-28h] BYREF

  switch ( c->label )
  {
    case 1:
      goto label1;
    case 2:
    case 3:
      goto label3;
    case 4:
      goto LABEL_55;
    case 5:
    case 6:
      goto label6;
    case 7:
      return 0;
    default:
      if ( (re->mode & 7) == 7 )
        return 0;
      c->re = re;
      c->firstp = firstp;
      c->str = str;
      c->end_p = end_p;
      c->sub_ctx = 0;
      c->lastpos = 0;
      break;
  }
  while ( 1 )
  {
    if ( (c->re->mode & 7) == 7 )
    {
      c->lastpos = c->str;
      c->label = 7;
      return 1;
    }
    if ( (c->re->mode & 0x18) != 0 )
    {
      if ( (c->re->mode & 0x10) != 0 )
        c->iter_limit = 0xFFFF;
      else
        c->iter_limit = 1;
      c->n_any = -1;
      while ( 1 )
      {
label3:
        if ( c->n_any >= c->iter_limit )
          return 0;
        if ( &c->str[c->n_any] >= c->end_p )
          return 0;
        if ( c->n_any < 0 )
        {
          ++c->n_any;
        }
        else
        {
          if ( (c->re->mode & 7) == 4 )
          {
            c->ctx2 = (MatchingContext2 *)GC_malloc(32);
            c->ctx2->label = 0;
label1:
            if ( !regmatch_sub_anytime(
                    c->ctx2,
                    c->re->p.sub,
                    c->re + 1,
                    &c->str[c->n_any],
                    c->end_p,
                    c->iter_limit,
                    c->firstp) )
              return 0;
            c->n_any = c->ctx2->lastpos - c->str;
            c->lastpos = c->ctx2->lastpos;
            c->label = 1;
            return 1;
          }
          set_longchar(&v7, &c->str[c->n_any]);
          k = v7;
          if ( !regmatch1(c->re, &k) )
            return 0;
          c->n_any += WTF_LEN_MAP[(unsigned __int8)c->str[c->n_any]];
          c->firstp = 0;
        }
        if ( (c->re[1].mode & 7) == 7 )
        {
          c->lastpos = &c->str[c->n_any];
          c->label = 2;
          return 1;
        }
        if ( regmatch(c->re + 1, &c->str[c->n_any], c->end_p, c->firstp, &c->lastpos) == 1 )
        {
          c->label = 3;
          return 1;
        }
      }
    }
    v6 = c->re->mode & 7;
    if ( v6 != 5 )
      break;
    if ( !c->firstp )
      return 0;
    ++c->re;
LABEL_55:
    if ( c->str > c->end_p )
      return 0;
  }
  if ( v6 == 6 )
  {
    if ( c->str < c->end_p )
    {
      c->lastpos = 0;
      result = 0;
    }
    else
    {
      c->lastpos = c->str;
      ++c->re;
      c->label = 4;
      result = 1;
    }
    return result;
  }
  if ( v6 != 4 )
  {
    set_longchar(&v7, c->str);
    k = v7;
    c->str += WTF_LEN_MAP[*(unsigned __int8 *)c->str];
    if ( !regmatch1(c->re, &k) )
      return 0;
    ++c->re;
    c->firstp = 0;
    goto LABEL_55;
  }
  if ( !c->sub_ctx )
    c->sub_ctx = (MatchingContext1 *)GC_malloc(44);
  for ( c->sub_regex = c->re->p.sub; ; c->sub_regex = c->sub_regex->alt_regex )
  {
    c->sub_ctx->label = 0;
label6:
    while ( regmatch_iter(c->sub_ctx, c->sub_regex->re, c->str, c->end_p, c->firstp) )
    {
      if ( c->sub_ctx->lastpos != c->str )
        c->firstp = 0;
      if ( (c->re[1].mode & 7) == 7 )
      {
        c->lastpos = c->sub_ctx->lastpos;
        c->label = 5;
        return 1;
      }
      if ( regmatch(c->re + 1, c->sub_ctx->lastpos, c->end_p, c->firstp, &c->lastpos) == 1 )
      {
        c->label = 6;
        return 1;
      }
    }
    if ( !c->sub_regex->alt_regex )
      break;
  }
  return 0;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (080A67D2) --------------------------------------------------------
int __cdecl regmatch(regexchar_0 *re, char *str, char *end_p, int firstp, char **lastpos)
{
  MatchingContext1 contx; // [esp+24h] [ebp-34h] BYREF

  *lastpos = 0;
  contx.label = 0;
  while ( regmatch_iter(&contx, re, str, end_p, firstp) )
  {
    if ( !*lastpos || *lastpos < contx.lastpos )
      *lastpos = contx.lastpos;
  }
  return *lastpos != 0;
}

//----- (080A6849) --------------------------------------------------------
int __cdecl regmatch1(regexchar_0 *re, longchar *c)
{
  int v3; // eax

  if ( c->type == 4 )
    return 0;
  v3 = re->mode & 7;
  if ( v3 == 1 )
    return 1;
  if ( (re->mode & 7u) > 1 )
  {
    if ( v3 == 2 )
      return matchWhich(re->p.pattern, c, re->mode & 0x40);
    if ( v3 == 3 )
      return matchWhich(re->p.pattern, c, re->mode & 0x40) == 0;
  }
  else if ( (re->mode & 7) == 0 )
  {
    return match_longchar(re->p.pattern, c, re->mode & 0x40);
  }
  return 0;
}

//----- (080A692C) --------------------------------------------------------
int __cdecl matchWhich(longchar *pattern, longchar *c, int igncase)
{
  int ans; // [esp+18h] [ebp-10h]

  ans = 0;
  while ( pattern->type )
  {
    if ( pattern[1].type == 3 && pattern[2].type )
    {
      if ( match_range_longchar(pattern, pattern + 2, c, igncase) )
        return 1;
      pattern += 3;
    }
    else
    {
      if ( match_longchar(pattern, c, igncase) )
        return 1;
      ++pattern;
    }
  }
  return ans;
}

//----- (080A69CE) --------------------------------------------------------
int __cdecl match_longchar(longchar *a, longchar *b, int ignore)
{
  int v4; // eax

  if ( a->type != b->type )
    return 0;
  if ( a->type == 2 )
    return a->wch.ccs == b->wch.ccs && a->wch.code == b->wch.code;
  if ( ignore && (MYCTYPE_MAP[b->ch] & 4) != 0 )
    return a->ch == (b->ch | 0x20) || ((MYCTYPE_MAP[b->ch] & 4) == 0 ? (v4 = b->ch) : (v4 = b->ch & 0xDF), a->ch == v4);
  return a->ch == b->ch;
}

//----- (080A6AF9) --------------------------------------------------------
int __cdecl match_range_longchar(longchar *a, longchar *b, longchar *c, int ignore)
{
  int v5; // eax
  int v6; // eax
  int v7; // eax

  if ( a->type != b->type || a->type != c->type )
    return 0;
  if ( a->type == 2 )
    return a->wch.ccs == c->wch.ccs
        && c->wch.ccs == b->wch.ccs
        && a->wch.code <= c->wch.code
        && c->wch.code <= b->wch.code;
  if ( ignore && (MYCTYPE_MAP[c->ch] & 4) != 0 )
    return a->ch <= (c->ch | 0x20) && ((MYCTYPE_MAP[c->ch] & 4) == 0 ? (v5 = c->ch) : (v5 = c->ch | 0x20), v5 <= b->ch)
        || ((MYCTYPE_MAP[c->ch] & 4) == 0 ? (v6 = c->ch) : (v6 = c->ch & 0xDF),
            a->ch <= v6 && ((MYCTYPE_MAP[c->ch] & 4) == 0 ? (v7 = c->ch) : (v7 = c->ch & 0xDF), v7 <= b->ch));
  return a->ch <= c->ch && c->ch <= b->ch;
}

//----- (080A6CF8) --------------------------------------------------------
void __cdecl __noreturn KeyAbort_3(int _dummy)
{
  siglongjmp(AbortLoading_3, 1);
}

//----- (080A6D12) --------------------------------------------------------
Str __cdecl news_command(News *news, char *cmd, char *arg, int *status)
{
  Str tmp; // [esp+1Ch] [ebp-Ch]
  Str tmpa; // [esp+1Ch] [ebp-Ch]

  if ( !news->host )
    return 0;
  if ( cmd )
  {
    if ( arg )
      tmp = Sprintf("%s %s\r\n", cmd, arg);
    else
      tmp = Sprintf("%s\r\n", cmd);
    fwrite(tmp->ptr, 1u, tmp->length, news->wf);
    fflush(news->wf);
  }
  if ( !status )
    return 0;
  *status = -1;
  tmpa = StrISgets(news->rf);
  if ( tmpa->length )
    sscanf(tmpa->ptr, "%d", status);
  return tmpa;
}

//----- (080A6DF8) --------------------------------------------------------
void __cdecl news_close(News *news)
{
  if ( news->host )
  {
    if ( news->rf )
    {
      news->rf->base.type &= 0xEFu;
      ISclose(news->rf);
      news->rf = 0;
    }
    if ( news->wf )
    {
      fclose(news->wf);
      news->wf = 0;
    }
    news->host = 0;
  }
}

//----- (080A6E6F) --------------------------------------------------------
int __cdecl news_open(News *news)
{
  int v1; // eax
  int status; // [esp+18h] [ebp-10h] BYREF
  int sock; // [esp+1Ch] [ebp-Ch]

  sock = openSocket(news->host, "nntp", news->port);
  if ( sock >= 0 )
  {
    news->rf = newInputStream(sock);
    v1 = dup(sock);
    news->wf = fdopen(v1, "wb");
    if ( news->rf )
    {
      if ( news->wf )
      {
        news->rf->base.type |= 0x10u;
        news_command(news, 0, 0, &status);
        if ( status == 200 || status == 201 )
        {
          if ( !news->mode )
            return 1;
          news_command(news, "MODE", news->mode, &status);
          if ( status == 200 || status == 201 )
            return 1;
        }
      }
    }
  }
  news_close(news);
  return 0;
}

//----- (080A6FA0) --------------------------------------------------------
void __cdecl news_quit(News *news)
{
  news_command(news, "QUIT", 0, 0);
  news_close(news);
}

//----- (080A6FD6) --------------------------------------------------------
char *__cdecl name_from_address(char *str, int n)
{
  int v2; // eax
  int space; // [esp+10h] [ebp-18h]
  int l; // [esp+14h] [ebp-14h]
  char *p; // [esp+18h] [ebp-10h]
  char *pa; // [esp+18h] [ebp-10h]
  char *pb; // [esp+18h] [ebp-10h]
  char *pc; // [esp+18h] [ebp-10h]
  char *pd; // [esp+18h] [ebp-10h]
  char *pe; // [esp+18h] [ebp-10h]
  char *pf; // [esp+18h] [ebp-10h]
  char *s; // [esp+1Ch] [ebp-Ch]

  space = 1;
  for ( s = allocStr(str, -1); *s && (MYCTYPE_MAP[(unsigned __int8)*s] & 2) != 0; ++s )
    ;
  if ( *s == 60 && (p = strchr(s, 62)) != 0 )
  {
    *p = 0;
    for ( pa = p + 1; *pa && (MYCTYPE_MAP[(unsigned __int8)*pa] & 2) != 0; ++pa )
      ;
    if ( *pa )
      s = pa;
    else
      ++s;
  }
  else
  {
    pb = strchr(s, 60);
    if ( pb )
    {
      *pb = 0;
    }
    else
    {
      pc = strchr(s, 40);
      if ( pc )
        s = pc;
    }
  }
  if ( *s == 34 && (pd = strchr(s + 1, 34)) != 0 )
  {
    *pd = 0;
    ++s;
  }
  else if ( *s == 40 )
  {
    pe = strchr(s + 1, 41);
    if ( pe )
    {
      *pe = 0;
      ++s;
    }
  }
  pf = s;
  l = 0;
  while ( *pf )
  {
    if ( (MYCTYPE_MAP[(unsigned __int8)*pf] & 2) != 0 )
    {
      if ( space )
        goto LABEL_33;
      space = 1;
    }
    else
    {
      space = 0;
    }
    if ( WcOption.use_wide )
      v2 = WTF_WIDTH_MAP[(unsigned __int8)*pf];
    else
      v2 = WTF_WIDTH_MAP[(unsigned __int8)*pf] != 0;
    l += v2;
    if ( l > n )
      break;
LABEL_33:
    pf += WTF_LEN_MAP[(unsigned __int8)*pf];
  }
  *pf = 0;
  return s;
}

//----- (080A71FD) --------------------------------------------------------
char *__cdecl html_quote_s(char *str)
{
  int v1; // eax
  char *result; // eax
  int space; // [esp+10h] [ebp-18h]
  char *q; // [esp+14h] [ebp-14h]
  char *p; // [esp+18h] [ebp-10h]
  Str tmp; // [esp+1Ch] [ebp-Ch]

  tmp = 0;
  space = 1;
  for ( p = str; *p; ++p )
  {
    if ( (MYCTYPE_MAP[(unsigned __int8)*p] & 2) != 0 )
    {
      if ( space )
        continue;
      q = "&nbsp;";
      space = 1;
    }
    else
    {
      q = HTML_QUOTE_MAP[QUOTE_MAP[(unsigned __int8)*p] & 7];
      space = 0;
    }
    if ( q )
    {
      if ( !tmp )
        tmp = Strnew_charp_n(str, p - str);
      Strcat_charp(tmp, q);
    }
    else if ( tmp )
    {
      if ( tmp->length + 1 >= tmp->area_size )
        Strgrow(tmp);
      v1 = tmp->length;
      tmp->ptr[v1] = *p;
      tmp->length = v1 + 1;
      tmp->ptr[tmp->length] = 0;
    }
  }
  if ( tmp )
    result = tmp->ptr;
  else
    result = str;
  return result;
}

//----- (080A7331) --------------------------------------------------------
void __cdecl add_news_message(Str str, int index, char *date, char *name, char *subject, char *mid, char *scheme, char *group)
{
  char *v8; // ebx
  char *v9; // eax
  _Str *v10; // [esp+4h] [ebp-34h]
  _Str *v11; // [esp+4h] [ebp-34h]
  char *v12; // [esp+8h] [ebp-30h]
  char *v13; // [esp+10h] [ebp-28h]
  char *v14; // [esp+10h] [ebp-28h]
  tm *tm; // [esp+28h] [ebp-10h]
  time_t t; // [esp+2Ch] [ebp-Ch] BYREF
  char *namea; // [esp+4Ch] [ebp+14h]

  namea = name_from_address(name, 16);
  t = mymktime(date);
  tm = localtime(&t);
  v13 = html_quote_s(namea);
  v10 = Sprintf("<tr valign=top><td>%d<td nowrap>(%02d/%02d)<td nowrap>%s", index, tm->tm_mon + 1, tm->tm_mday, v13);
  savexmlstr_0(str, v10);
  if ( group )
  {
    v14 = html_quote(subject);
    v11 = Sprintf("<td><a href=\"%s%s/%d\">%s</a>\n", scheme, group, index, v14);
  }
  else
  {
    v8 = html_quote(subject);
    v9 = file_quote(mid);
    v12 = html_quote(v9);
    v11 = Sprintf("<td><a href=\"%s%s\">%s</a>\n", scheme, v12, v8);
  }
  savexmlstr_0(str, v11);
}

//----- (080A7449) --------------------------------------------------------
InputStream __cdecl openNewsStream(ParsedURL *pu)
{
  InputStream result; // eax
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  Str v5; // eax
  int status; // [esp+14h] [ebp-24h] BYREF
  int port; // [esp+18h] [ebp-20h]
  Str tmp; // [esp+1Ch] [ebp-1Ch]
  char *p; // [esp+20h] [ebp-18h]
  char *group; // [esp+24h] [ebp-14h]
  char *mode; // [esp+28h] [ebp-10h]
  char *host; // [esp+2Ch] [ebp-Ch]

  if ( !pu->file || !*pu->file )
    return 0;
  if ( pu->scheme == 7 || pu->scheme == 8 )
    host = pu->host;
  else
    host = NNTP_server;
  if ( host && *host )
  {
    if ( pu->scheme == 7 || pu->scheme == 8 || (p = strchr(host, 58)) == 0 )
    {
      port = pu->port;
    }
    else
    {
      host = allocStr(host, p - host);
      port = atoi(p + 1);
    }
    if ( NNTP_mode && *NNTP_mode )
      mode = NNTP_mode;
    else
      mode = 0;
    if ( current_news.host )
    {
      if ( !strcmp(current_news.host, host) && current_news.port == port )
      {
        if ( mode )
          v2 = mode;
        else
          v2 = "READER";
        tmp = news_command(&current_news, "MODE", v2, &status);
        if ( status != 200 && status != 201 )
          news_close(&current_news);
      }
      else
      {
        news_quit(&current_news);
      }
    }
    if ( !current_news.host )
    {
      current_news.host = allocStr(host, -1);
      current_news.port = port;
      v3 = mode ? allocStr(mode, -1) : 0;
      current_news.mode = v3;
      if ( !news_open(&current_news) )
        return 0;
    }
    if ( pu->scheme == 7 || pu->scheme == 9 )
    {
      v4 = allocStr(pu->file, -1);
      group = file_unquote(v4);
      p = strchr(group, 47);
      if ( p )
      {
        *p++ = 0;
        news_command(&current_news, "GROUP", group, &status);
        if ( status != 211 )
          return 0;
      }
      else
      {
        if ( !strchr(group, 64) )
          return 0;
        p = group;
      }
      if ( strchr(p, 64) )
      {
        v5 = Sprintf("<%s>", p);
        news_command(&current_news, "ARTICLE", v5->ptr, &status);
      }
      else
      {
        news_command(&current_news, "ARTICLE", p, &status);
      }
      if ( status == 220 )
        result = current_news.rf;
      else
        result = 0;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    if ( current_news.host )
      news_quit(&current_news);
    result = 0;
  }
  return result;
}

//----- (080A779F) --------------------------------------------------------
Str __cdecl loadNewsgroup(ParsedURL *pu, wc_ces *charset)
{
  char *v3; // eax
  Str v4; // eax
  Str v5; // eax
  Str v6; // eax
  _Str *v7; // eax
  Str v8; // eax
  _Str *v9; // eax
  wc_ces v10; // edx
  wc_ces *v11; // eax
  _Str *v12; // eax
  wc_ces v13; // edx
  wc_ces *v14; // eax
  char *v15; // eax
  int v16; // eax
  int v17; // eax
  Str v18; // eax
  char *v19; // eax
  _Str *v20; // eax
  char *v21; // ebx
  char *v22; // eax
  char *v23; // eax
  _Str *v24; // eax
  URLFile f; // [esp+38h] [ebp-90h] BYREF
  wc_ces mime_charset; // [esp+58h] [ebp-70h] BYREF
  wc_ces doc_charset; // [esp+5Ch] [ebp-6Ch]
  void (*prevtrap)(int); // [esp+60h] [ebp-68h]
  int end; // [esp+64h] [ebp-64h]
  int start; // [esp+68h] [ebp-60h]
  int flag; // [esp+6Ch] [ebp-5Ch]
  int last; // [esp+70h] [ebp-58h] BYREF
  int first; // [esp+74h] [ebp-54h] BYREF
  int i; // [esp+78h] [ebp-50h] BYREF
  int status; // [esp+7Ch] [ebp-4Ch] BYREF
  char *list; // [esp+80h] [ebp-48h]
  char *group; // [esp+84h] [ebp-44h]
  char *scheme; // [esp+88h] [ebp-40h]
  char *n; // [esp+8Ch] [ebp-3Ch]
  char *t; // [esp+90h] [ebp-38h]
  char *s; // [esp+94h] [ebp-34h]
  char *q; // [esp+98h] [ebp-30h]
  char *p; // [esp+9Ch] [ebp-2Ch]
  char *qgroup; // [esp+A0h] [ebp-28h]
  Buffer *buf; // [esp+A4h] [ebp-24h]
  Str tmp; // [esp+A8h] [ebp-20h]
  Str page; // [esp+ACh] [ebp-1Ch]

  flag = 0;
  start = 0;
  end = 0;
  prevtrap = 0;
  doc_charset = DocumentCharset;
  *charset = 256;
  if ( !current_news.host || !pu->file || !*pu->file )
    return 0;
  group = allocStr(pu->file, -1);
  if ( pu->scheme == 8 )
    scheme = "/";
  else
    scheme = "news:";
  list = strchr(group, 47);
  if ( list )
  {
    v3 = list;
    *list = 0;
    list = v3 + 1;
  }
  if ( fmInitialized )
  {
    v4 = Sprintf("Reading newsgroup %s...", group);
    message(v4->ptr, 0, 0);
    refresh();
  }
  qgroup = html_quote(group);
  group = file_unquote(group);
  v5 = parsedURL2Str(pu);
  page = Strnew_m_charp(
           "<html>\n<head>\n<base href=\"",
           v5->ptr,
           "\">\n<title>Newsgroup: ",
           qgroup,
           "</title>\n</head>\n<body>\n<h1>Newsgroup: ",
           qgroup,
           "</h1>\n<hr>\n",
           0);
  if ( __sigsetjmp(AbortLoading_3, 1) )
  {
    news_close(&current_news);
    Strcat_charp(page, "</table>\n<p>Transfer Interrupted!\n");
  }
  else
  {
    if ( TrapSignal )
    {
      prevtrap = mySignal(2, KeyAbort_3);
      if ( fmInitialized )
        term_cbreak();
    }
    tmp = news_command(&current_news, "GROUP", group, &status);
    if ( status == 211 && sscanf(tmp->ptr, "%d %d %d %d", &status, &i, &first, &last) == 4 )
    {
      if ( list && *list )
      {
        p = strchr(list, 45);
        if ( p )
        {
          *p++ = 0;
          end = atoi(p);
        }
        start = atoi(list);
        if ( start > 0 )
        {
          if ( start < first )
            start = first;
          if ( end <= 0 )
            end = start + MaxNewsMessage - 1;
        }
      }
      if ( start <= 0 )
      {
        start = first;
        end = last;
        if ( last - first > MaxNewsMessage - 1 )
          start = end - MaxNewsMessage + 1;
      }
      v6 = parsedURL2Str(pu);
      page = Sprintf(
               "<html>\n"
               "<head>\n"
               "<base href=\"%s\">\n"
               "<title>Newsgroup: %s %d-%d</title>\n"
               "</head>\n"
               "<body>\n"
               "<h1>Newsgroup: %s %d-%d</h1>\n"
               "<hr>\n",
               v6->ptr,
               qgroup,
               start,
               end,
               qgroup,
               start,
               end);
      if ( start > first )
      {
        i = start - MaxNewsMessage;
        if ( start - MaxNewsMessage < first )
          i = first;
        v7 = Sprintf("<a href=\"%s%s/%d-%d\">[%d-%d]</a>\n", scheme, qgroup, i, start - 1, i, start - 1);
        savexmlstr_0(page, v7);
      }
      Strcat_charp(page, "<table>\n");
      v8 = Sprintf("%d-%d", start, end);
      news_command(&current_news, "XOVER", v8->ptr, &status);
      if ( status == 224 )
      {
        f.scheme = 9;
        while ( 1 )
        {
          tmp = StrISgets(current_news.rf);
          if ( *tmp->ptr == 46 && (tmp->ptr[1] == 10 || tmp->ptr[1] == 13 || !tmp->ptr[1]) )
            break;
          if ( *tmp->ptr == 10 || *tmp->ptr == 13 || !*tmp->ptr )
            break;
          if ( sscanf(tmp->ptr, "%d", &i) == 1 )
          {
            s = strchr(tmp->ptr, 9);
            if ( s )
            {
              n = strchr(++s, 9);
              if ( n )
              {
                *n++ = 0;
                t = strchr(n, 9);
                if ( t )
                {
                  *t++ = 0;
                  p = strchr(t, 9);
                  if ( p )
                  {
                    *p++ = 0;
                    if ( *p == 60 )
                      ++p;
                    q = strchr(p, 62);
                    if ( q || (q = strchr(p, 9)) != 0 )
                    {
                      *q = 0;
                      v9 = Strnew_charp(s);
                      tmp = decodeMIME(v9, &mime_charset);
                      if ( mime_charset )
                        v10 = mime_charset;
                      else
                        v10 = doc_charset;
                      if ( mime_charset )
                        v11 = &mime_charset;
                      else
                        v11 = charset;
                      s = convertLine(&f, tmp, 3, v11, v10)->ptr;
                      v12 = Strnew_charp(n);
                      tmp = decodeMIME(v12, &mime_charset);
                      if ( mime_charset )
                        v13 = mime_charset;
                      else
                        v13 = doc_charset;
                      if ( mime_charset )
                        v14 = &mime_charset;
                      else
                        v14 = charset;
                      n = convertLine(&f, tmp, 3, v14, v13)->ptr;
                      if ( pu->scheme == 8 )
                        v15 = qgroup;
                      else
                        v15 = 0;
                      add_news_message(page, i, t, n, s, p, scheme, v15);
                    }
                  }
                }
              }
            }
          }
        }
      }
      else
      {
        init_stream(&f, 9, current_news.rf);
        if ( showLineNum )
          v16 = 6;
        else
          v16 = 1;
        v17 = COLS - v16;
        if ( v17 < 0 )
          v17 = 0;
        buf = newBuffer(v17);
        for ( i = start; i <= end && i <= last; ++i )
        {
          v18 = Sprintf("%d", i);
          news_command(&current_news, "HEAD", v18->ptr, &status);
          if ( status == 221 )
          {
            readHeader(&f, buf, 0, 0);
            p = checkHeader(buf, "Message-ID:");
            if ( p )
            {
              if ( *p == 60 )
                ++p;
              q = strchr(p, 62);
              if ( !q )
              {
                q = strchr(p, 9);
                if ( !q )
                  MEMORY[0] = 0;
              }
              s = checkHeader(buf, "Subject:");
              if ( s )
              {
                n = checkHeader(buf, "From:");
                if ( n )
                {
                  t = checkHeader(buf, "Date:");
                  if ( t )
                  {
                    if ( pu->scheme == 8 )
                      v19 = qgroup;
                    else
                      v19 = 0;
                    add_news_message(page, i, t, n, s, p, scheme, v19);
                  }
                }
              }
            }
          }
        }
      }
      Strcat_charp(page, "</table>\n");
      if ( end < last )
      {
        i = end + MaxNewsMessage;
        if ( end + MaxNewsMessage > last )
          i = last;
        v20 = Sprintf("<a href=\"%s%s/%d-%d\">[%d-%d]</a>\n", scheme, qgroup, end + 1, i, end + 1, i);
        savexmlstr_0(page, v20);
      }
      flag = 1;
    }
    tmp = Sprintf("ACTIVE %s", group);
    if ( !strchr(group, 42) )
      Strcat_charp(tmp, ".*");
    news_command(&current_news, "LIST", tmp->ptr, &status);
    if ( status == 215 )
    {
      while ( 1 )
      {
        tmp = StrISgets(current_news.rf);
        if ( *tmp->ptr == 46 && (tmp->ptr[1] == 10 || tmp->ptr[1] == 13 || !tmp->ptr[1]) )
          break;
        if ( *tmp->ptr == 10 || *tmp->ptr == 13 || !*tmp->ptr )
          break;
        if ( flag <= 1 )
        {
          if ( flag == 1 )
            Strcat_charp(page, "<hr>\n");
          Strcat_charp(page, "<table>\n");
          flag = 2;
        }
        p = tmp->ptr;
        for ( q = p; *q && (MYCTYPE_MAP[(unsigned __int8)*q] & 2) == 0; ++q )
          ;
        *q++ = 0;
        if ( sscanf(q, "%d %d", &last, &first) == 2 && last >= first )
          i = last - first + 1;
        else
          i = 0;
        v21 = html_quote(p);
        v22 = file_quote(p);
        v23 = html_quote(v22);
        v24 = Sprintf("<tr><td align=right>%d<td><a href=\"%s%s\">%s</a>\n", i, scheme, v23, v21);
        savexmlstr_0(page, v24);
      }
      if ( flag == 2 )
        Strcat_charp(page, "</table>\n");
    }
  }
  Strcat_charp(page, "</body>\n</html>\n");
  if ( TrapSignal )
  {
    if ( fmInitialized )
      term_raw();
    if ( prevtrap )
      mySignal(2, prevtrap);
  }
  return page;
}

//----- (080A83BA) --------------------------------------------------------
void closeNews()
{
  news_close(&current_news);
}

//----- (080A83CE) --------------------------------------------------------
void disconnectNews()
{
  news_quit(&current_news);
}

//----- (080A83E4) --------------------------------------------------------
void __cdecl setKeymap(char *p, int lineno, int verbose)
{
  int m; // [esp+2Ch] [ebp-2Ch]
  int j; // [esp+30h] [ebp-28h]
  int i; // [esp+34h] [ebp-24h]
  char *mmap; // [esp+38h] [ebp-20h]
  int f; // [esp+3Ch] [ebp-1Ch]
  int c; // [esp+40h] [ebp-18h]
  char *emsg; // [esp+44h] [ebp-14h]
  char *s; // [esp+48h] [ebp-10h]
  char *sa; // [esp+48h] [ebp-10h]
  char *sb; // [esp+48h] [ebp-10h]
  unsigned __int8 *map; // [esp+4Ch] [ebp-Ch]
  unsigned __int8 *mapa; // [esp+4Ch] [ebp-Ch]

  s = getQWord(&p);
  c = getKey(s);
  if ( c >= 0 )
  {
    sa = getWord(&p);
    f = getFuncList(sa);
    if ( f >= 0 )
    {
      if ( (c & 0x10000000) != 0 )
      {
        mmap = 0;
        m = (c >> 16) & 0x77F;
        if ( (c & 0x4000000) != 0 )
        {
          map = EscDKeymap;
        }
        else if ( (c & 0x2000000) != 0 )
        {
          map = EscBKeymap;
        }
        else if ( (c & 0x1000000) != 0 )
        {
          map = EscKeymap;
        }
        else
        {
          map = GlobalKeymap;
        }
        if ( map[BYTE2(c) & 0x7F] == 74 )
          mmap = getKeyData(m);
        else
          map[BYTE2(c) & 0x7F] = 74;
        if ( !mmap )
        {
          mmap = (char *)GC_malloc(16);
          for ( i = 0; i <= 3; ++i )
          {
            *(_DWORD *)&mmap[4 * i] = GC_malloc(128);
            for ( j = 0; j <= 127; ++j )
              *(_BYTE *)(*(_DWORD *)&mmap[4 * i] + j) = 0;
          }
          *(_BYTE *)(*(_DWORD *)mmap + 27) = 28;
          *(_BYTE *)(*((_DWORD *)mmap + 1) + 91) = 27;
          *(_BYTE *)(*((_DWORD *)mmap + 1) + 79) = 27;
        }
        if ( !keyData )
          keyData = newHash_iv(16);
        putHash_iv(keyData, m, mmap);
        if ( (c & 0x400) != 0 )
        {
          mapa = (unsigned __int8 *)*((_DWORD *)mmap + 3);
        }
        else if ( (c & 0x200) != 0 )
        {
          mapa = (unsigned __int8 *)*((_DWORD *)mmap + 2);
        }
        else if ( (c & 0x100) != 0 )
        {
          mapa = (unsigned __int8 *)*((_DWORD *)mmap + 1);
        }
        else
        {
          mapa = *(unsigned __int8 **)mmap;
        }
      }
      else if ( (c & 0x400) != 0 )
      {
        mapa = EscDKeymap;
      }
      else if ( (c & 0x200) != 0 )
      {
        mapa = EscBKeymap;
      }
      else if ( (c & 0x100) != 0 )
      {
        mapa = EscKeymap;
      }
      else
      {
        mapa = GlobalKeymap;
      }
      mapa[c & 0x7F] = f;
      sb = getQWord(&p);
      if ( *sb )
      {
        if ( !keyData )
          keyData = newHash_iv(16);
        putHash_iv(keyData, c, sb);
      }
      else if ( getKeyData(c) )
      {
        putHash_iv(keyData, c, 0);
      }
    }
    else
    {
      if ( lineno <= 0 )
        emsg = Sprintf("defkey: invalid command '%s'", sa)->ptr;
      else
        emsg = Sprintf("line %d: invalid command '%s'", lineno, sa)->ptr;
      record_err_message(emsg);
      if ( verbose )
        goto LABEL_6;
    }
  }
  else
  {
    if ( lineno <= 0 )
      emsg = Sprintf("defkey: unknown key '%s'", s)->ptr;
    else
      emsg = Sprintf("line %d: unknown key '%s'", lineno, s)->ptr;
    record_err_message(emsg);
    if ( verbose )
    {
LABEL_6:
      disp_message_nsec(emsg, 0, 1, 1, 0);
      return;
    }
  }
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (080A87D7) --------------------------------------------------------
void __cdecl interpret_keymap(FILE *kf, stat *current, int force)
{
  stat kstat; // [esp+28h] [ebp-90h] BYREF
  int verbose; // [esp+80h] [ebp-38h]
  wc_ces charset; // [esp+84h] [ebp-34h]
  int lineno; // [esp+88h] [ebp-30h]
  char *emsg; // [esp+8Ch] [ebp-2Ch]
  char *s; // [esp+90h] [ebp-28h]
  char *p; // [esp+94h] [ebp-24h] BYREF
  Str line; // [esp+98h] [ebp-20h]
  int fd; // [esp+9Ch] [ebp-1Ch]

  charset = SystemCharset;
  verbose = 1;
  fd = fileno(kf);
  if ( fd >= 0
    && !fstat(fd, (int)&kstat)
    && (force
     || kstat.st_mtim.tv_sec != current->st_mtim.tv_sec
     || kstat.st_dev != current->st_dev
     || kstat.st_ino != current->st_ino
     || kstat.st_size != current->st_size) )
  {
    qmemcpy(current, &kstat, sizeof(stat));
    lineno = 0;
    while ( !feof(kf) )
    {
      line = Strfgets(kf);
      ++lineno;
      Strchop(line);
      Strremovefirstspaces(line);
      if ( line->length )
      {
        line = wc_Str_conv(line, charset, InnerCharset);
        p = line->ptr;
        s = getWord(&p);
        if ( *s != 35 )
        {
          if ( !strcmp(s, "keymap") )
          {
            setKeymap(p, lineno, verbose);
          }
          else if ( !strcmp(s, "charset") || !strcmp(s, "encoding") )
          {
            s = getQWord(&p);
            if ( *s )
              charset = wc_guess_charset(s, charset);
          }
          else if ( !strcmp(s, "verbose") )
          {
            s = getWord(&p);
            if ( *s )
              verbose = str_to_bool(s, verbose);
          }
          else
          {
            emsg = Sprintf("line %d: syntax error '%s'", lineno, s)->ptr;
            record_err_message(emsg);
            if ( verbose )
              disp_message_nsec(emsg, 0, 1, 1, 0);
          }
        }
      }
    }
  }
}

//----- (080A8A8F) --------------------------------------------------------
void __cdecl initKeymap(int force)
{
  char *v1; // eax
  int v2; // eax
  char *v3; // eax
  int v4; // eax
  FILE *kf; // [esp+1Ch] [ebp-Ch]
  FILE *kfa; // [esp+1Ch] [ebp-Ch]

  v1 = confFile("keymap");
  kf = fopen(v1, "rt");
  if ( kf )
  {
    v2 = force || !keymap_initialized[0];
    interpret_keymap(kf, &sys_current_keymap_file, v2);
    fclose(kf);
  }
  v3 = rcFile(keymap_file);
  kfa = fopen(v3, "rt");
  if ( kfa )
  {
    v4 = force || !keymap_initialized[0];
    interpret_keymap(kfa, &current_keymap_file, v4);
    fclose(kfa);
  }
  keymap_initialized[0] = 1;
}

//----- (080A8B6E) --------------------------------------------------------
int __cdecl getFuncList(char *id)
{
  return getHash_si(&functable, id, -1);
}

//----- (080A8B91) --------------------------------------------------------
char *__cdecl getKeyData(int key)
{
  char *result; // eax

  if ( keyData )
    result = (char *)getHash_iv(keyData, key, 0);
  else
    result = 0;
  return result;
}

//----- (080A8BC5) --------------------------------------------------------
int __cdecl getKey2(char **str)
{
  int result; // eax
  int ctrl; // [esp+10h] [ebp-18h]
  int esc; // [esp+14h] [ebp-14h]
  int c; // [esp+18h] [ebp-10h]
  char *s; // [esp+1Ch] [ebp-Ch]
  char *sa; // [esp+1Ch] [ebp-Ch]
  char *sb; // [esp+1Ch] [ebp-Ch]

  s = *str;
  esc = 0;
  ctrl = 0;
  if ( !*str || !*s )
    return -1;
  if ( !strcasecmp(s, "UP") )
  {
    *str = s + 2;
    result = 577;
  }
  else if ( !strcasecmp(s, "DOWN") )
  {
    *str = s + 4;
    result = 578;
  }
  else if ( !strcasecmp(s, "RIGHT") )
  {
    *str = s + 5;
    result = 579;
  }
  else if ( !strcasecmp(s, "LEFT") )
  {
    *str = s + 4;
    result = 580;
  }
  else
  {
    if ( !strncasecmp(s, "ESC-", 4u) || !strncasecmp(s, "ESC ", 4u) )
    {
      s += 4;
      esc = 256;
    }
    else if ( !strncasecmp(s, "M-", 2u) || !strncasecmp(s, "\\E", 2u) )
    {
      s += 2;
      esc = 256;
    }
    else if ( *s == 27 )
    {
      ++s;
      esc = 256;
    }
    if ( !strncasecmp(s, "C-", 2u) )
    {
      s += 2;
      ctrl = 1;
    }
    else if ( *s == 94 && s[1] )
    {
      ++s;
      ctrl = 1;
    }
    if ( !esc && ctrl && *s == 91 )
    {
      ++s;
      ctrl = 0;
      esc = 256;
    }
    if ( esc && !ctrl )
    {
      if ( *s == 91 || *s == 79 )
      {
        ++s;
        esc = 512;
      }
      if ( !strncasecmp(s, "C-", 2u) )
      {
        s += 2;
        ctrl = 1;
      }
      else if ( *s == 94 && s[1] )
      {
        ++s;
        ctrl = 1;
      }
    }
    if ( ctrl )
    {
      *str = s + 1;
      if ( *s <= 63 || *s > 95 )
      {
        if ( *s <= 96 || *s > 122 )
        {
          if ( *s == 63 )
            result = esc | 0x7F;
          else
            result = -1;
        }
        else
        {
          result = esc | (*s - 96);
        }
      }
      else
      {
        result = esc | (*s - 64);
      }
    }
    else if ( esc == 512 && (MYCTYPE_MAP[(unsigned __int8)*s] & 8) != 0 )
    {
      c = *s - 48;
      sa = s + 1;
      if ( (MYCTYPE_MAP[(unsigned __int8)*sa] & 8) != 0 )
        c = 10 * c + *sa++ - 48;
      *str = sa + 1;
      if ( *sa == 126 )
      {
        result = c;
        BYTE1(result) = BYTE1(c) | 4;
      }
      else
      {
        result = -1;
      }
    }
    else if ( !strncasecmp(s, "SPC", 3u) )
    {
      *str = s + 3;
      result = esc | 0x20;
    }
    else if ( !strncasecmp(s, "TAB", 3u) )
    {
      *str = s + 3;
      result = esc | 9;
    }
    else if ( !strncasecmp(s, "DEL", 3u) )
    {
      *str = s + 3;
      result = esc | 0x7F;
    }
    else if ( *s == 92 && s[1] )
    {
      sb = s + 1;
      *str = sb + 1;
      switch ( *sb )
      {
        case '\\':
          result = esc | 0x5C;
          break;
        case '^':
          result = esc | 0x5E;
          break;
        case 'a':
          result = esc | 7;
          break;
        case 'b':
          result = esc | 8;
          break;
        case 'e':
          result = esc | 0x1B;
          break;
        case 'n':
          result = esc | 0xA;
          break;
        case 'r':
          result = esc | 0xD;
          break;
        case 't':
          result = esc | 9;
          break;
        default:
          result = -1;
          break;
      }
    }
    else
    {
      *str = s + 1;
      if ( (MYCTYPE_MAP[(unsigned __int8)*s] & 0x11) != 0 )
        result = esc | *s;
      else
        result = -1;
    }
  }
  return result;
}

//----- (080A90C7) --------------------------------------------------------
int __cdecl getKey(char *s)
{
  int c2; // [esp+18h] [ebp-10h]
  int c; // [esp+1Ch] [ebp-Ch]

  c = getKey2(&s);
  if ( c < 0 )
    return -1;
  if ( *s == 32 || *s == 45 )
    ++s;
  if ( *s )
  {
    c2 = getKey2(&s);
    if ( c2 < 0 )
      return -1;
    c = c2 | (c << 16) | 0x10000000;
  }
  return c;
}

//----- (080A9140) --------------------------------------------------------
char *__cdecl getWord(char **str)
{
  char *s; // [esp+18h] [ebp-10h]
  char *p; // [esp+1Ch] [ebp-Ch]

  for ( p = *str; *p && (MYCTYPE_MAP[(unsigned __int8)*p] & 2) != 0; ++p )
    ;
  s = p;
  while ( *p && (MYCTYPE_MAP[(unsigned __int8)*p] & 2) == 0 && *p != 59 )
    ++p;
  *str = p;
  return Strnew_charp_n(s, p - s)->ptr;
}

//----- (080A91D9) --------------------------------------------------------
char *__cdecl getQWord(char **str)
{
  int v1; // eax
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int esc; // [esp+1Ch] [ebp-1Ch]
  int in_dq; // [esp+20h] [ebp-18h]
  int in_q; // [esp+24h] [ebp-14h]
  char *p; // [esp+28h] [ebp-10h]
  Str tmp; // [esp+2Ch] [ebp-Ch]

  tmp = Strnew();
  in_q = 0;
  in_dq = 0;
  esc = 0;
  for ( p = *str; *p && (MYCTYPE_MAP[(unsigned __int8)*p] & 2) != 0; ++p )
    ;
  while ( *p )
  {
    if ( esc )
    {
      if ( in_q )
      {
        if ( *p != 92 && *p != 39 )
        {
          if ( tmp->length + 1 >= tmp->area_size )
            Strgrow(tmp);
          v1 = tmp->length;
          tmp->ptr[v1] = 92;
          tmp->length = v1 + 1;
          tmp->ptr[tmp->length] = 0;
        }
      }
      else if ( in_dq )
      {
        if ( *p != 92 && *p != 34 )
        {
          if ( tmp->length + 1 >= tmp->area_size )
            Strgrow(tmp);
          v2 = tmp->length;
          tmp->ptr[v2] = 92;
          tmp->length = v2 + 1;
          tmp->ptr[tmp->length] = 0;
        }
      }
      else if ( *p != 92 && *p != 39 && *p != 34 && (MYCTYPE_MAP[(unsigned __int8)*p] & 2) == 0 )
      {
        if ( tmp->length + 1 >= tmp->area_size )
          Strgrow(tmp);
        v3 = tmp->length;
        tmp->ptr[v3] = 92;
        tmp->length = v3 + 1;
        tmp->ptr[tmp->length] = 0;
      }
      if ( tmp->length + 1 >= tmp->area_size )
        Strgrow(tmp);
      v4 = tmp->length;
      tmp->ptr[v4] = *p;
      tmp->length = v4 + 1;
      tmp->ptr[tmp->length] = 0;
      esc = 0;
    }
    else if ( *p == 92 )
    {
      esc = 1;
    }
    else if ( in_q )
    {
      if ( *p == 39 )
      {
        in_q = 0;
      }
      else
      {
        if ( tmp->length + 1 >= tmp->area_size )
          Strgrow(tmp);
        v5 = tmp->length;
        tmp->ptr[v5] = *p;
        tmp->length = v5 + 1;
        tmp->ptr[tmp->length] = 0;
      }
    }
    else if ( in_dq )
    {
      if ( *p == 34 )
      {
        in_dq = 0;
      }
      else
      {
        if ( tmp->length + 1 >= tmp->area_size )
          Strgrow(tmp);
        v6 = tmp->length;
        tmp->ptr[v6] = *p;
        tmp->length = v6 + 1;
        tmp->ptr[tmp->length] = 0;
      }
    }
    else if ( *p == 39 )
    {
      in_q = 1;
    }
    else if ( *p == 34 )
    {
      in_dq = 1;
    }
    else
    {
      if ( (MYCTYPE_MAP[(unsigned __int8)*p] & 2) != 0 || *p == 59 )
        break;
      if ( tmp->length + 1 >= tmp->area_size )
        Strgrow(tmp);
      v7 = tmp->length;
      tmp->ptr[v7] = *p;
      tmp->length = v7 + 1;
      tmp->ptr[tmp->length] = 0;
    }
    ++p;
  }
  *str = p;
  return tmp->ptr;
}

//----- (080A95B9) --------------------------------------------------------
void __cdecl setMouseAction0(char **str, int *width, MouseActionMap **map, char *p)
{
  int x; // [esp+10h] [ebp-18h]
  int w; // [esp+14h] [ebp-14h]
  int b; // [esp+18h] [ebp-10h]
  int ba; // [esp+18h] [ebp-10h]
  char *s; // [esp+1Ch] [ebp-Ch]

  s = getQWord(&p);
  if ( *s )
  {
    w = *width;
    *str = s;
    *width = wtf_strwidth((wc_uchar *)s);
    if ( *width > 99 )
      *width = 100;
    if ( *width > w )
    {
      for ( ba = 0; ba <= 2; ++ba )
      {
        if ( map[ba] )
        {
          map[ba] = (MouseActionMap *)GC_realloc(map[ba], 8 * *width);
          for ( x = w + 1; *width > x; ++x )
          {
            map[ba][x].func = 0;
            map[ba][x].data = 0;
          }
        }
      }
    }
  }
  else
  {
    *str = 0;
    for ( b = 0; b <= 2; ++b )
      map[b] = 0;
  }
}
// 8049E6C: using guessed type int __cdecl GC_realloc(_DWORD, _DWORD);

//----- (080A9701) --------------------------------------------------------
void __cdecl setMouseAction1(MouseActionMap **map, int width, char *p)
{
  char *v3; // eax
  void (*v4)(...); // eax
  int f; // [esp+10h] [ebp-18h]
  int x2; // [esp+14h] [ebp-14h]
  int x; // [esp+18h] [ebp-10h]
  int xa; // [esp+18h] [ebp-10h]
  const char *sa; // [esp+1Ch] [ebp-Ch]
  const char *sb; // [esp+1Ch] [ebp-Ch]
  char *s; // [esp+1Ch] [ebp-Ch]

  if ( !*map )
  {
    *map = (MouseActionMap *)GC_malloc(8 * width);
    for ( x = 0; x < width; ++x )
    {
      (*map)[x].func = 0;
      (*map)[x].data = 0;
    }
  }
  sa = getWord(&p);
  xa = atoi(sa);
  if ( (MYCTYPE_MAP[*(unsigned __int8 *)sa] & 8) != 0 && xa >= 0 && xa < width )
  {
    sb = getWord(&p);
    x2 = atoi(sb);
    if ( (MYCTYPE_MAP[*(unsigned __int8 *)sb] & 8) != 0 && x2 >= 0 && x2 < width )
    {
      v3 = getWord(&p);
      f = getFuncList(v3);
      s = getQWord(&p);
      if ( !*s )
        s = 0;
      while ( xa <= x2 )
      {
        if ( f < 0 )
          v4 = 0;
        else
          v4 = w3mFuncList[f].func;
        (*map)[xa].func = v4;
        (*map)[xa++].data = s;
      }
    }
  }
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (080A9899) --------------------------------------------------------
void __cdecl setMouseAction2(MouseActionMap *map, char *p)
{
  char *v2; // eax
  void (*v3)(...); // eax
  int f; // [esp+18h] [ebp-10h]
  char *s; // [esp+1Ch] [ebp-Ch]

  v2 = getWord(&p);
  f = getFuncList(v2);
  s = getQWord(&p);
  if ( !*s )
    s = 0;
  if ( f < 0 )
    v3 = 0;
  else
    v3 = w3mFuncList[f].func;
  map->func = v3;
  map->data = s;
}

//----- (080A9901) --------------------------------------------------------
void __cdecl interpret_mouse_action(FILE *mf)
{
  wc_ces v1; // esi
  wc_ces v2; // ebx
  _Str *v3; // eax
  int b; // [esp+10h] [ebp-18h]
  const char *s; // [esp+14h] [ebp-14h]
  const char *sb; // [esp+14h] [ebp-14h]
  const char *sa; // [esp+14h] [ebp-14h]
  char *p; // [esp+18h] [ebp-10h] BYREF
  Str line; // [esp+1Ch] [ebp-Ch]

  while ( !feof(mf) )
  {
    line = Strfgets(mf);
    Strchop(line);
    Strremovefirstspaces(line);
    if ( line->length )
    {
      v1 = InnerCharset;
      v2 = SystemCharset;
      v3 = Strnew_charp(line->ptr);
      p = wc_Str_conv(v3, v2, v1)->ptr;
      s = getWord(&p);
      if ( *s != 35 )
      {
        if ( !strcmp(s, "menu") )
        {
          setMouseAction0(&mouse_action.menu_str, &mouse_action.menu_width, mouse_action.menu_map, p);
        }
        else if ( !strcmp(s, "lastline") )
        {
          setMouseAction0(&mouse_action.lastline_str, &mouse_action.lastline_width, mouse_action.lastline_map, p);
        }
        else if ( !strcmp(s, "button") )
        {
          sb = getWord(&p);
          b = atoi(sb) - 1;
          if ( b >= 0 && b <= 2 )
          {
            while ( *p && (MYCTYPE_MAP[(unsigned __int8)*p] & 2) != 0 )
              ++p;
            if ( (MYCTYPE_MAP[(unsigned __int8)*p] & 8) != 0 )
              sa = "menu";
            else
              sa = getWord(&p);
            if ( !strcasecmp(sa, "menu") )
            {
              if ( mouse_action.menu_str )
                setMouseAction1((MouseActionMap **)(4 * b + 135792380), mouse_action.menu_width, p);
            }
            else if ( !strcasecmp(sa, "lastline") )
            {
              if ( mouse_action.lastline_str )
                setMouseAction1((MouseActionMap **)(4 * b + 135792392), mouse_action.lastline_width, p);
            }
            else if ( !strcasecmp(sa, "default") )
            {
              setMouseAction2((MouseActionMap *)(8 * b + 135792284), p);
            }
            else if ( !strcasecmp(sa, "anchor") )
            {
              setMouseAction2((MouseActionMap *)(8 * b + 135792308), p);
            }
            else if ( !strcasecmp(sa, "active") )
            {
              setMouseAction2((MouseActionMap *)(8 * b + 135792332), p);
            }
            else if ( !strcasecmp(sa, "tab") )
            {
              setMouseAction2((MouseActionMap *)(8 * b + 135792356), p);
            }
          }
        }
      }
    }
  }
}

//----- (080A9C4C) --------------------------------------------------------
void initMouseAction()
{
  char *v0; // eax
  char *v1; // eax
  char **symbol; // [esp+14h] [ebp-14h]
  int w; // [esp+18h] [ebp-10h] BYREF
  FILE *mf; // [esp+1Ch] [ebp-Ch]

  bcopy(&default_mouse_action, &mouse_action, 0x94u);
  mouse_action.lastline_map[0] = (MouseActionMap *)GC_malloc(48);
  bcopy(default_lastline_action, mouse_action.lastline_map[0], 0x30u);
  w = 0;
  symbol = get_symbol(DisplayCharset, &w);
  mouse_action.lastline_str = Strnew_charp(symbol[45])->ptr;
  v0 = confFile("mouse");
  mf = fopen(v0, "rt");
  if ( mf )
  {
    interpret_mouse_action(mf);
    fclose(mf);
  }
  v1 = rcFile("mouse");
  mf = fopen(v1, "rt");
  if ( mf )
  {
    interpret_mouse_action(mf);
    fclose(mf);
  }
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (080A9D54) --------------------------------------------------------
int __cdecl total_dot_number(char *p, char *ep, int max_count)
{
  int count; // [esp+1Ch] [ebp-Ch]

  count = 0;
  if ( !ep )
    ep = &p[strlen(p)];
  while ( p < ep && count < max_count )
  {
    if ( *p == 46 )
      ++count;
    ++p;
  }
  return count;
}

//----- (080A9DA1) --------------------------------------------------------
char *__cdecl domain_match_0(char *host, char *domain)
{
  size_t v3; // ebx
  int v4; // eax
  char *domain_p; // [esp+10h] [ebp-18h]
  char *domain_pa; // [esp+10h] [ebp-18h]
  int m1; // [esp+18h] [ebp-10h]
  int m0; // [esp+1Ch] [ebp-Ch]

  regexCompile("[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+", 0);
  m0 = __gmp_vfprintf(host, -1, 1);
  m1 = __gmp_vfprintf(domain, -1, 1);
  if ( m0 && m1 )
  {
    if ( !strcasecmp(host, domain) )
      return host;
  }
  else if ( !m0 && !m1 )
  {
    if ( !strcasecmp(domain, ".") || !strcasecmp(domain, ".local") )
    {
      domain_p = &host[strlen(host)];
      if ( !domain[1] || !total_dot_number(host, domain_p, 1) )
        return domain_p;
    }
    else
    {
      if ( *domain == 46 && !strcasecmp(host, domain + 1) )
        return host;
      if ( *domain == 46 )
      {
        v3 = strlen(host);
        v4 = v3 - strlen(domain);
      }
      else
      {
        v4 = 0;
      }
      domain_pa = &host[v4];
      if ( v4 >= 0 && !strcasecmp(domain_pa, domain) )
        return domain_pa;
    }
  }
  return 0;
}

//----- (080A9F49) --------------------------------------------------------
portlist *__cdecl make_portlist(Str port)
{
  int v1; // eax
  Str tmp; // [esp+10h] [ebp-18h]
  char *p; // [esp+14h] [ebp-14h]
  portlist *pl; // [esp+18h] [ebp-10h]
  portlist *first; // [esp+1Ch] [ebp-Ch]

  first = 0;
  tmp = Strnew();
  p = port->ptr;
  while ( *p )
  {
    while ( *p && (MYCTYPE_MAP[(unsigned __int8)*p] & 8) == 0 )
      ++p;
    Strclear(tmp);
    while ( *p && (MYCTYPE_MAP[(unsigned __int8)*p] & 8) != 0 )
    {
      if ( tmp->length + 1 >= tmp->area_size )
        Strgrow(tmp);
      v1 = tmp->length;
      tmp->ptr[v1] = *p;
      tmp->length = v1 + 1;
      ++p;
      tmp->ptr[tmp->length] = 0;
    }
    if ( !tmp->length )
      break;
    pl = (portlist *)GC_malloc(8);
    pl->port = atoi(tmp->ptr);
    pl->next = first;
    first = pl;
  }
  return first;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (080AA06D) --------------------------------------------------------
Str __cdecl portlist2str(portlist *first)
{
  _Str *v2; // [esp+4h] [ebp-24h]
  _Str *tmp; // [esp+18h] [ebp-10h]
  portlist *pl; // [esp+1Ch] [ebp-Ch]

  tmp = Sprintf("%d", first->port);
  for ( pl = first->next; pl; pl = pl->next )
  {
    v2 = Sprintf(", %d", pl->port);
    savexmlstr_0(tmp, v2);
  }
  return tmp;
}

//----- (080AA0D6) --------------------------------------------------------
int __cdecl port_match(portlist *first, int port)
{
  while ( first )
  {
    if ( first->port == port )
      return 1;
    first = first->next;
  }
  return 0;
}

//----- (080AA10F) --------------------------------------------------------
void check_expired_cookies()
{
  time_t now; // [esp+14h] [ebp-14h]
  cookie *p1; // [esp+18h] [ebp-10h]
  cookie *p; // [esp+1Ch] [ebp-Ch]

  now = time(0);
  if ( First_cookie )
  {
    if ( First_cookie->expires != -1 && First_cookie->expires < now )
    {
      if ( (First_cookie->flag & 0x10) == 0 )
        is_saved = 0;
      First_cookie = First_cookie->next;
    }
    for ( p = First_cookie; p && p->next; p = p1 )
    {
      p1 = p->next;
      if ( p1->expires != -1 && p1->expires < now )
      {
        if ( (p1->flag & 0x10) == 0 )
          is_saved = 0;
        p->next = p1->next;
        p1 = p;
      }
    }
  }
}

//----- (080AA1E6) --------------------------------------------------------
Str __cdecl make_cookie(cookie *cookie)
{
  int v1; // eax
  Str tmp; // [esp+1Ch] [ebp-Ch]

  tmp = Strdup(cookie->name);
  if ( tmp->length + 1 >= tmp->area_size )
    Strgrow(tmp);
  v1 = tmp->length;
  tmp->ptr[v1] = 61;
  tmp->length = v1 + 1;
  tmp->ptr[tmp->length] = 0;
  savexmlstr_0(tmp, cookie->value);
  return tmp;
}

//----- (080AA262) --------------------------------------------------------
int __cdecl match_cookie(ParsedURL *pu, cookie *cookie, char *domainname)
{
  if ( !domainname )
    return 0;
  if ( !domain_match_0(domainname, cookie->domain->ptr) )
    return 0;
  if ( strncmp(cookie->path->ptr, pu->file, cookie->path->length) )
    return 0;
  if ( (cookie->flag & 2) != 0 )
    return 0;
  return !cookie->portl || port_match(cookie->portl, pu->port);
}

//----- (080AA31A) --------------------------------------------------------
cookie *__cdecl get_cookie_info(Str domain, Str path, Str name)
{
  cookie *p; // [esp+1Ch] [ebp-Ch]

  for ( p = First_cookie; p; p = p->next )
  {
    if ( !strcasecmp(p->domain->ptr, domain->ptr)
      && !strcmp(p->path->ptr, path->ptr)
      && !strcasecmp(p->name->ptr, name->ptr) )
    {
      return p;
    }
  }
  return 0;
}

//----- (080AA39C) --------------------------------------------------------
Str __cdecl find_cookie(ParsedURL *pu)
{
  char *v1; // eax
  const char *v3; // eax
  _Str *v4; // [esp+4h] [ebp-34h]
  _Str *v5; // [esp+4h] [ebp-34h]
  _Str *v6; // [esp+4h] [ebp-34h]
  _Str *v7; // [esp+4h] [ebp-34h]
  _Str *v8; // [esp+4h] [ebp-34h]
  _Str *v9; // [esp+4h] [ebp-34h]
  char *fq_domainname; // [esp+18h] [ebp-20h]
  int version; // [esp+1Ch] [ebp-1Ch]
  cookie *fco; // [esp+20h] [ebp-18h]
  cookie *p1; // [esp+24h] [ebp-14h]
  cookie *p1a; // [esp+24h] [ebp-14h]
  cookie *p1b; // [esp+24h] [ebp-14h]
  cookie *p; // [esp+28h] [ebp-10h]
  _Str *tmp; // [esp+2Ch] [ebp-Ch]

  fco = 0;
  version = 0;
  fq_domainname = FQDN(pu->host);
  check_expired_cookies();
  for ( p = First_cookie; p; p = p->next )
  {
    if ( p->version )
      v1 = pu->host;
    else
      v1 = fq_domainname;
    if ( (p->flag & 1) != 0 && match_cookie(pu, p, v1) )
    {
      for ( p1 = fco; p1 && strcasecmp(p1->name->ptr, p->name->ptr); p1 = p1->next )
        ;
      if ( !p1 )
      {
        p1a = (cookie *)GC_malloc(80);
        bcopy(p, p1a, 0x50u);
        p1a->next = fco;
        fco = p1a;
        if ( p1a->version > version )
          version = p1a->version;
      }
    }
  }
  if ( !fco )
    return 0;
  tmp = Strnew();
  if ( version > 0 )
  {
    v4 = Sprintf("$Version=\"%d\"; ", version);
    savexmlstr_0(tmp, v4);
  }
  v5 = make_cookie(fco);
  savexmlstr_0(tmp, v5);
  for ( p1b = fco->next; p1b; p1b = p1b->next )
  {
    Strcat_charp(tmp, "; ");
    v6 = make_cookie(p1b);
    savexmlstr_0(tmp, v6);
    if ( version > 0 )
    {
      if ( (p1b->flag & 8) != 0 )
      {
        v7 = Sprintf("; $Path=\"%s\"", p1b->path->ptr);
        savexmlstr_0(tmp, v7);
      }
      if ( (p1b->flag & 4) != 0 )
      {
        v8 = Sprintf("; $Domain=\"%s\"", p1b->domain->ptr);
        savexmlstr_0(tmp, v8);
      }
      if ( p1b->portl )
      {
        v3 = (const char *)portlist2str(p1b->portl);
        v9 = Sprintf("; $Port=\"%s\"", v3);
        savexmlstr_0(tmp, v9);
      }
    }
  }
  return tmp;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (080AA627) --------------------------------------------------------
int __cdecl add_cookie(ParsedURL *pu, Str name, Str value, time_t expires, Str domain, Str path, int flag, Str comment, int version, Str port, Str commentURL)
{
  char *v11; // eax
  int v13; // ebx
  int offset; // [esp+14h] [ebp-34h]
  int ok; // [esp+18h] [ebp-30h]
  char **sdomain; // [esp+1Ch] [ebp-2Ch]
  int n; // [esp+20h] [ebp-28h]
  char *dp; // [esp+24h] [ebp-24h]
  portlist *portlist; // [esp+2Ch] [ebp-1Ch]
  Str opath; // [esp+30h] [ebp-18h]
  Str odomain; // [esp+34h] [ebp-14h]
  char *domainname; // [esp+38h] [ebp-10h]
  cookie *p; // [esp+3Ch] [ebp-Ch]

  if ( version )
    v11 = pu->host;
  else
    v11 = FQDN(pu->host);
  domainname = v11;
  odomain = domain;
  opath = path;
  portlist = 0;
  if ( !v11 )
    return 37;
  if ( !domain )
    goto LABEL_73;
  if ( *domain->ptr != 46 && (version > 0 || strcasecmp(v11, domain->ptr)) )
    domain = Sprintf(".%s", domain->ptr);
  if ( version )
  {
    if ( strcasecmp(domain->ptr, ".local")
      && !total_dot_number(domain->ptr + 1, &domain->ptr[domain->length], 1)
      && (flag & 0x20) == 0 )
    {
      return 37;
    }
  }
  else
  {
    n = total_dot_number(domain->ptr, &domain->ptr[domain->length], 3);
    if ( n <= 1 )
      return 3;
    if ( n == 2 )
    {
      ok = 0;
      for ( sdomain = special_domain; !ok && *sdomain; ++sdomain )
      {
        v13 = domain->length;
        offset = v13 - strlen(*sdomain);
        if ( offset >= 0 && !strcasecmp(*sdomain, &domain->ptr[offset]) )
          ok = 1;
      }
      if ( !ok )
        return 3;
    }
  }
  dp = domain_match_0(domainname, domain->ptr);
  if ( !dp && (flag & 0x20) == 0 )
    return 39;
  if ( version > 0 && total_dot_number(domainname, dp, 1) && (flag & 0x20) == 0 )
    return 40;
LABEL_73:
  if ( path && version > 0 && strncmp(path->ptr, pu->file, path->length) )
    return 4;
  if ( port )
  {
    portlist = make_portlist(port);
    if ( portlist )
    {
      if ( !port_match(portlist, pu->port) )
        return 9;
    }
  }
  if ( !domain )
    domain = Strnew_charp(domainname);
  if ( !path )
  {
    for ( path = Strnew_charp(pu->file); path->length > 0 && path->ptr[path->length - 1] != 47; Strshrink(path, 1) )
      ;
    if ( path->length > 0 && path->ptr[path->length - 1] == 47 )
      Strshrink(path, 1);
  }
  p = get_cookie_info(domain, path, name);
  if ( !p )
  {
    p = (cookie *)GC_malloc(80);
    p->flag = 0;
    if ( default_use_cookie )
      p->flag |= 1u;
    p->next = First_cookie;
    First_cookie = p;
  }
  copyParsedURL(&p->url, pu);
  p->name = name;
  p->value = value;
  p->expires = expires;
  p->domain = domain;
  p->path = path;
  p->comment = comment;
  p->version = version;
  p->portl = portlist;
  p->commentURL = commentURL;
  if ( (flag & 2) != 0 )
    p->flag |= 2u;
  else
    p->flag &= 0xFDu;
  if ( odomain )
    p->flag |= 4u;
  else
    p->flag &= 0xFBu;
  if ( opath )
    p->flag |= 8u;
  else
    p->flag &= 0xF7u;
  if ( (flag & 0x10) != 0 || p->expires == -1 )
  {
    p->flag |= 0x10u;
  }
  else
  {
    p->flag &= 0xEFu;
    is_saved = 0;
  }
  check_expired_cookies();
  return 0;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (080AAB16) --------------------------------------------------------
cookie *__cdecl nth_cookie(int n)
{
  int i; // [esp+8h] [ebp-8h]
  cookie *p; // [esp+Ch] [ebp-4h]

  p = First_cookie;
  i = 0;
  while ( p )
  {
    if ( i == n )
      return p;
    p = p->next;
    ++i;
  }
  return 0;
}

//----- (080AAB54) --------------------------------------------------------
void save_cookies()
{
  const char *v0; // ebx
  char *v1; // edi
  const char *v2; // esi
  Str v3; // eax
  const char *v4; // [esp+44h] [ebp-44h]
  int v5; // [esp+48h] [ebp-40h]
  int v6; // [esp+4Ch] [ebp-3Ch]
  const char *v7; // [esp+50h] [ebp-38h]
  const char *v8; // [esp+54h] [ebp-34h]
  time_t v9; // [esp+58h] [ebp-30h]
  const char *v10; // [esp+5Ch] [ebp-2Ch]
  FILE *fp; // [esp+64h] [ebp-24h]
  const char *cookie_file; // [esp+68h] [ebp-20h]
  cookie *p; // [esp+6Ch] [ebp-1Ch]

  check_expired_cookies();
  if ( First_cookie )
  {
    if ( !is_saved && !no_rc_dir )
    {
      cookie_file = rcFile("cookie");
      fp = fopen(cookie_file, "w");
      if ( fp )
      {
        for ( p = First_cookie; p; p = p->next )
        {
          if ( (p->flag & 1) != 0 && (p->flag & 0x10) == 0 )
          {
            if ( p->commentURL )
              v0 = p->commentURL->ptr;
            else
              v0 = (const char *)&unk_80D019C;
            if ( p->portl )
              v1 = portlist2str(p->portl)->ptr;
            else
              v1 = (char *)&unk_80D019C;
            if ( p->comment )
              v4 = p->comment->ptr;
            else
              v4 = (const char *)&unk_80D019C;
            v5 = p->version;
            v6 = p->flag;
            v7 = p->path->ptr;
            v8 = p->domain->ptr;
            v9 = p->expires;
            v10 = p->value->ptr;
            v2 = p->name->ptr;
            v3 = parsedURL2Str(&p->url);
            fprintf(
              fp,
              "%s\t%s\t%s\t%ld\t%s\t%s\t%d\t%d\t%s\t%s\t%s\n",
              v3->ptr,
              v2,
              v10,
              v9,
              v8,
              v7,
              v6,
              v5,
              v4,
              v1,
              v0);
          }
        }
        fclose(fp);
        chmod(cookie_file, 0x180u);
      }
    }
  }
}

//----- (080AAD41) --------------------------------------------------------
Str __cdecl readcol(char **p)
{
  int v1; // edx
  char *v2; // eax
  Str tmp; // [esp+1Ch] [ebp-Ch]

  tmp = Strnew();
  while ( **p && **p != 10 && **p != 13 && **p != 9 )
  {
    if ( tmp->length + 1 >= tmp->area_size )
      Strgrow(tmp);
    v1 = tmp->length;
    v2 = *p;
    tmp->ptr[v1] = **p;
    tmp->length = v1 + 1;
    *p = v2 + 1;
    tmp->ptr[tmp->length] = 0;
  }
  if ( **p == 9 )
    ++*p;
  return tmp;
}

//----- (080AAE02) --------------------------------------------------------
void load_cookies()
{
  char *v0; // eax
  cookie *v1; // ebx
  Str v2; // eax
  _Str *v3; // eax
  _Str *v4; // eax
  Str v5; // eax
  int v6; // eax
  _Str *v7; // eax
  _Str *v8; // eax
  Str v9; // eax
  char v10; // dl
  Str v11; // eax
  char v12; // dl
  _Str *v13; // eax
  _Str *v14; // eax
  portlist *v15; // eax
  _Str *v16; // eax
  char *str; // [esp+1Ch] [ebp-1Ch] BYREF
  Str line; // [esp+20h] [ebp-18h]
  FILE *fp; // [esp+24h] [ebp-14h]
  cookie *p; // [esp+28h] [ebp-10h]
  cookie *cookie; // [esp+2Ch] [ebp-Ch]

  v0 = rcFile("cookie");
  fp = fopen(v0, "r");
  if ( fp )
  {
    if ( First_cookie )
    {
      for ( p = First_cookie; p->next; p = p->next )
        ;
    }
    else
    {
      p = 0;
    }
    while ( 1 )
    {
      line = Strfgets(fp);
      if ( !line->length )
        break;
      str = line->ptr;
      cookie = (cookie *)GC_malloc(80);
      cookie->next = 0;
      cookie->flag = 0;
      cookie->version = 0;
      cookie->expires = -1;
      cookie->comment = 0;
      cookie->portl = 0;
      cookie->commentURL = 0;
      v1 = cookie;
      v2 = readcol(&str);
      parseURL(v2->ptr, &v1->url, 0);
      if ( !*str )
        return;
      v3 = readcol(&str);
      cookie->name = v3;
      if ( !*str )
        return;
      v4 = readcol(&str);
      cookie->value = v4;
      if ( !*str )
        return;
      v5 = readcol(&str);
      v6 = atol(v5->ptr);
      cookie->expires = v6;
      if ( !*str )
        return;
      v7 = readcol(&str);
      cookie->domain = v7;
      if ( !*str )
        return;
      v8 = readcol(&str);
      cookie->path = v8;
      if ( !*str )
        return;
      v9 = readcol(&str);
      v10 = atoi(v9->ptr);
      cookie->flag = v10;
      if ( !*str )
        return;
      v11 = readcol(&str);
      v12 = atoi(v11->ptr);
      cookie->version = v12;
      if ( !*str )
        return;
      v13 = readcol(&str);
      cookie->comment = v13;
      if ( !cookie->comment->length )
        cookie->comment = 0;
      if ( !*str )
        return;
      v14 = readcol(&str);
      v15 = make_portlist(v14);
      cookie->portl = v15;
      if ( !*str )
        return;
      v16 = readcol(&str);
      cookie->commentURL = v16;
      if ( !cookie->commentURL->length )
        cookie->commentURL = 0;
      if ( p )
        p->next = cookie;
      else
        First_cookie = cookie;
      p = cookie;
    }
    fclose(fp);
  }
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (080AB0D8) --------------------------------------------------------
void initCookie()
{
  load_cookies();
  check_expired_cookies();
}

//----- (080AB0EA) --------------------------------------------------------
Buffer *cookie_list_panel()
{
  Str v1; // eax
  struct tm *v2; // eax
  Str v3; // eax
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  Str v8; // eax
  char *v9; // eax
  char *v10; // eax
  Str v11; // eax
  char *v12; // eax
  char *v13; // eax
  const char *v14; // edx
  const char *v15; // eax
  _Str *v16; // eax
  char *tmp; // [esp+2Ch] [ebp-6Ch]
  int i; // [esp+30h] [ebp-68h]
  cookie *p; // [esp+34h] [ebp-64h]
  _Str *src; // [esp+38h] [ebp-60h]
  char tmp2[80]; // [esp+3Ch] [ebp-5Ch] BYREF
  unsigned int v22; // [esp+8Ch] [ebp-Ch]

  v22 = __readgsdword(0x14u);
  src = Strnew_charp("<html><head><title>Cookies</title></head><body><center><b>Cookies</b></center><p><form method=inter"
                     "nal action=cookie>");
  if ( !use_cookie || !First_cookie )
    return 0;
  Strcat_charp(src, "<ol>");
  p = First_cookie;
  i = 0;
  while ( p )
  {
    v1 = parsedURL2Str(&p->url);
    tmp = html_quote(v1->ptr);
    if ( p->expires == -1 )
    {
      tmp2[0] = 0;
    }
    else
    {
      v2 = gmtime(&p->expires);
      strftime(tmp2, 0x50u, "%a, %d %b %Y %H:%M:%S GMT", v2);
    }
    Strcat_charp(src, "<li>");
    Strcat_charp(src, "<h1><a href=\"");
    Strcat_charp(src, tmp);
    Strcat_charp(src, "\">");
    Strcat_charp(src, tmp);
    Strcat_charp(src, "</a></h1>");
    Strcat_charp(src, "<table cellpadding=0>");
    if ( (p->flag & 2) == 0 )
    {
      Strcat_charp(src, "<tr><td width=\"80\"><b>Cookie:</b></td><td>");
      v3 = make_cookie(p);
      v4 = html_quote(v3->ptr);
      Strcat_charp(src, v4);
      Strcat_charp(src, "</td></tr>");
    }
    if ( p->comment )
    {
      Strcat_charp(src, "<tr><td width=\"80\"><b>Comment:</b></td><td>");
      v5 = html_quote(p->comment->ptr);
      Strcat_charp(src, v5);
      Strcat_charp(src, "</td></tr>");
    }
    if ( p->commentURL )
    {
      Strcat_charp(src, "<tr><td width=\"80\"><b>CommentURL:</b></td><td>");
      Strcat_charp(src, "<a href=\"");
      v6 = html_quote(p->commentURL->ptr);
      Strcat_charp(src, v6);
      Strcat_charp(src, "\">");
      v7 = html_quote(p->commentURL->ptr);
      Strcat_charp(src, v7);
      Strcat_charp(src, "</a>");
      Strcat_charp(src, "</td></tr>");
    }
    if ( tmp2[0] )
    {
      Strcat_charp(src, "<tr><td width=\"80\"><b>Expires:</b></td><td>");
      Strcat_charp(src, tmp2);
      if ( (p->flag & 0x10) != 0 )
        Strcat_charp(src, " (Discard)");
      Strcat_charp(src, "</td></tr>");
    }
    Strcat_charp(src, "<tr><td width=\"80\"><b>Version:</b></td><td>");
    v8 = Sprintf("%d", p->version);
    Strcat_charp(src, v8->ptr);
    Strcat_charp(src, "</td></tr><tr><td>");
    if ( p->domain )
    {
      Strcat_charp(src, "<tr><td width=\"80\"><b>Domain:</b></td><td>");
      v9 = html_quote(p->domain->ptr);
      Strcat_charp(src, v9);
      Strcat_charp(src, "</td></tr>");
    }
    if ( p->path )
    {
      Strcat_charp(src, "<tr><td width=\"80\"><b>Path:</b></td><td>");
      v10 = html_quote(p->path->ptr);
      Strcat_charp(src, v10);
      Strcat_charp(src, "</td></tr>");
    }
    if ( p->portl )
    {
      Strcat_charp(src, "<tr><td width=\"80\"><b>Port:</b></td><td>");
      v11 = portlist2str(p->portl);
      v12 = html_quote(v11->ptr);
      Strcat_charp(src, v12);
      Strcat_charp(src, "</td></tr>");
    }
    Strcat_charp(src, "<tr><td width=\"80\"><b>Secure:</b></td><td>");
    if ( (p->flag & 2) != 0 )
      v13 = "Yes";
    else
      v13 = "No";
    Strcat_charp(src, v13);
    Strcat_charp(src, "</td></tr><tr><td>");
    if ( (p->flag & 1) != 0 )
      v14 = (const char *)&unk_80D019C;
    else
      v14 = " checked";
    if ( (p->flag & 1) != 0 )
      v15 = " checked";
    else
      v15 = (const char *)&unk_80D019C;
    v16 = Sprintf(
            "<tr><td width=\"80\"><b>Use:</b></td><td><input type=radio name=\"%d\" value=1%s>Yes&nbsp;&nbsp;<input type="
            "radio name=\"%d\" value=0%s>No",
            i,
            v15,
            i,
            v14);
    savexmlstr_0(src, v16);
    Strcat_charp(src, "</td></tr><tr><td><input type=submit value=\"OK\"></table><p>");
    p = p->next;
    ++i;
  }
  Strcat_charp(src, "</ol></form></body></html>");
  return loadHTMLString(src);
}

//----- (080AB643) --------------------------------------------------------
void __cdecl set_cookie_flag(parsed_tagarg *arg)
{
  cookie *p; // [esp+14h] [ebp-14h]
  int v; // [esp+18h] [ebp-10h]
  int n; // [esp+1Ch] [ebp-Ch]

  while ( arg )
  {
    if ( arg->arg )
    {
      if ( *arg->arg )
      {
        if ( arg->value )
        {
          if ( *arg->value )
          {
            n = atoi(arg->arg);
            v = atoi(arg->value);
            p = nth_cookie(n);
            if ( p )
            {
              if ( !v || (p->flag & 1) != 0 )
              {
                if ( !v && (p->flag & 1) != 0 )
                  p->flag &= 0xFEu;
              }
              else
              {
                p->flag |= 1u;
              }
              if ( (p->flag & 0x10) == 0 )
                is_saved = 0;
            }
          }
        }
      }
    }
    arg = arg->next;
  }
  backBf();
}

//----- (080AB748) --------------------------------------------------------
int __cdecl check_cookie_accept_domain(char *domain)
{
  TextListItem *tl; // [esp+1Ch] [ebp-Ch]
  TextListItem *tla; // [esp+1Ch] [ebp-Ch]

  if ( !domain )
    return 0;
  if ( Cookie_accept_domains && Cookie_accept_domains->nitem > 0 )
  {
    for ( tl = Cookie_accept_domains->first; tl; tl = tl->next )
    {
      if ( domain_match_0(domain, tl->ptr) )
        return 1;
    }
  }
  if ( Cookie_reject_domains && Cookie_reject_domains->nitem > 0 )
  {
    for ( tla = Cookie_reject_domains->first; tla; tla = tla->next )
    {
      if ( domain_match_0(domain, tla->ptr) )
        return 0;
    }
  }
  return 1;
}

//----- (080AB808) --------------------------------------------------------
Buffer *__cdecl historyBuffer(Hist *hist)
{
  char *v1; // eax
  char *q; // [esp+10h] [ebp-18h]
  char *p; // [esp+14h] [ebp-14h]
  ListItem *item; // [esp+18h] [ebp-10h]
  _Str *src; // [esp+1Ch] [ebp-Ch]

  src = Strnew();
  Strcat_charp(src, "<html>\n<head><title>History Page</title></head>\n");
  Strcat_charp(src, "<body>\n<h1>History Page</h1>\n<hr>\n");
  Strcat_charp(src, "<ol>\n");
  if ( hist && hist->list )
  {
    for ( item = hist->list->last; item; item = item->prev )
    {
      q = html_quote((char *)item->ptr);
      if ( DecodeURL )
      {
        v1 = url_unquote_conv((char *)item->ptr, 0);
        p = html_quote(v1);
      }
      else
      {
        p = q;
      }
      Strcat_charp(src, "<li><a href=\"");
      Strcat_charp(src, q);
      Strcat_charp(src, "\">");
      Strcat_charp(src, p);
      Strcat_charp(src, "</a>\n");
    }
  }
  Strcat_charp(src, "</ol>\n</body>\n</html>");
  return loadHTMLString(src);
}

//----- (080AB947) --------------------------------------------------------
void __cdecl loadHistory(Hist *hist)
{
  char *v1; // eax
  char *v2; // [esp+4h] [ebp-24h]
  Str line; // [esp+18h] [ebp-10h]
  FILE *f; // [esp+1Ch] [ebp-Ch]

  if ( hist )
  {
    v1 = rcFile("history");
    f = fopen(v1, "rt");
    if ( f )
    {
      while ( !feof(f) )
      {
        line = Strfgets(f);
        Strchop(line);
        Strremovefirstspaces(line);
        Strremovetrailingspaces(line);
        if ( line->length )
        {
          v2 = url_quote(line->ptr);
          pushHist(hist, v2);
        }
      }
      fclose(f);
    }
  }
}

//----- (080AB9FE) --------------------------------------------------------
void __cdecl saveHistory(Hist *hist, size_t size)
{
  char *v2; // [esp+4h] [ebp-24h]
  const char *tmpf; // [esp+14h] [ebp-14h]
  ListItem *item; // [esp+18h] [ebp-10h]
  FILE *f; // [esp+1Ch] [ebp-Ch]

  if ( hist && hist->list )
  {
    tmpf = tmpfname(0, 0)->ptr;
    f = fopen(tmpf, "w");
    if ( f )
    {
      for ( item = hist->list->first; item && hist->list->nitem > size; item = item->next )
        ++size;
      while ( item )
      {
        fprintf(f, "%s\n", (const char *)item->ptr);
        item = item->next;
      }
      if ( fclose(f) == -1 )
      {
        _ZN10bdInetAddrC2Ej("Can't save history", 0);
      }
      else
      {
        v2 = rcFile("history");
        rename(tmpf, v2);
      }
    }
    else
    {
      _ZN10bdInetAddrC2Ej("Can't open history", 0);
    }
  }
}

//----- (080ABB11) --------------------------------------------------------
Hist *newHist()
{
  Hist *hist; // [esp+1Ch] [ebp-Ch]

  hist = (Hist *)GC_malloc(12);
  hist->list = newGeneralList();
  hist->current = 0;
  hist->hash = 0;
  return hist;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (080ABB49) --------------------------------------------------------
Hist *__cdecl copyHist(Hist *hist)
{
  ListItem *item; // [esp+18h] [ebp-10h]
  Hist *newa; // [esp+1Ch] [ebp-Ch]

  if ( !hist )
    return 0;
  newa = newHist();
  for ( item = hist->list->first; item; item = item->next )
    pushHist(newa, (char *)item->ptr);
  return newa;
}

//----- (080ABB98) --------------------------------------------------------
HistItem *__cdecl unshiftHist(Hist *hist, char *ptr)
{
  ListItem *v3; // ebx
  char *v4; // eax
  ListItem *item; // [esp+1Ch] [ebp-Ch]

  if ( !hist || !hist->list )
    return 0;
  v3 = hist->list->first;
  v4 = allocStr(ptr, -1);
  item = newListItem(v4, v3, 0);
  if ( hist->list->first )
    hist->list->first->prev = item;
  else
    hist->list->last = item;
  hist->list->first = item;
  ++hist->list->nitem;
  return item;
}

//----- (080ABC2E) --------------------------------------------------------
HistItem *__cdecl pushHist(Hist *hist, char *ptr)
{
  ListItem *v3; // ebx
  char *v4; // eax
  ListItem *item; // [esp+1Ch] [ebp-Ch]

  if ( !hist || !hist->list )
    return 0;
  v3 = hist->list->last;
  v4 = allocStr(ptr, -1);
  item = newListItem(v4, 0, v3);
  if ( hist->list->last )
    hist->list->last->next = item;
  else
    hist->list->first = item;
  hist->list->last = item;
  ++hist->list->nitem;
  return item;
}

//----- (080ABCC7) --------------------------------------------------------
HistItem *__cdecl pushHashHist(Hist *hist, char *ptr)
{
  HistItem *item; // [esp+1Ch] [ebp-Ch]
  HistItem *itema; // [esp+1Ch] [ebp-Ch]

  if ( !hist || !hist->list )
    return 0;
  item = getHashHist(hist, ptr);
  if ( item )
  {
    if ( item->next )
      item->next->prev = item->prev;
    else
      hist->list->last = item->prev;
    if ( item->prev )
      item->prev->next = item->next;
    else
      hist->list->first = item->next;
    --hist->list->nitem;
  }
  itema = pushHist(hist, ptr);
  putHash_sv(hist->hash, ptr, itema);
  return itema;
}

//----- (080ABD98) --------------------------------------------------------
HistItem *__cdecl getHashHist(Hist *hist, char *ptr)
{
  ListItem *item; // [esp+1Ch] [ebp-Ch]

  if ( !hist || !hist->list )
    return 0;
  if ( !hist->hash )
  {
    hist->hash = newHash_sv(127);
    for ( item = hist->list->first; item; item = item->next )
      putHash_sv(hist->hash, (char *)item->ptr, item);
  }
  return (HistItem *)getHash_sv(hist->hash, ptr, 0);
}

//----- (080ABE2A) --------------------------------------------------------
char *__cdecl lastHist(Hist *hist)
{
  if ( !hist || !hist->list )
    return 0;
  if ( !hist->list->last )
    return 0;
  hist->current = hist->list->last;
  return (char *)hist->current->ptr;
}

//----- (080ABE6E) --------------------------------------------------------
char *__cdecl nextHist(Hist *hist)
{
  if ( !hist || !hist->list )
    return 0;
  if ( !hist->current || !hist->current->next )
    return 0;
  hist->current = hist->current->next;
  return (char *)hist->current->ptr;
}

//----- (080ABEBE) --------------------------------------------------------
char *__cdecl prevHist(Hist *hist)
{
  if ( !hist || !hist->list )
    return 0;
  if ( !hist->current || !hist->current->prev )
    return 0;
  hist->current = hist->current->prev;
  return (char *)hist->current->ptr;
}

//----- (080ABF10) --------------------------------------------------------
void __cdecl print_headers(Buffer *buf, int len)
{
  Str v2; // eax
  Str v3; // eax
  char *v4; // eax
  TextListItem *tp; // [esp+1Ch] [ebp-Ch]

  if ( buf->document_header )
  {
    for ( tp = buf->document_header->first; tp; tp = tp->next )
      puts(tp->ptr);
  }
  v2 = parsedURL2Str(&buf->currentURL);
  printf("w3m-current-url: %s\n", v2->ptr);
  if ( buf->baseURL )
  {
    v3 = parsedURL2Str(buf->baseURL);
    printf("w3m-base-url: %s\n", v3->ptr);
  }
  printf("w3m-content-type: %s\n", buf->type);
  if ( buf->document_charset )
  {
    v4 = wc_ces_to_charset(buf->document_charset);
    printf("w3m-content-charset: %s\n", v4);
  }
  if ( len > 0 )
    printf("w3m-content-length: %d\n", len);
}

//----- (080AC005) --------------------------------------------------------
void __cdecl internal_get(char *url, int flag, FormList *request)
{
  Str *v3; // ebx
  Str v4; // eax
  char *v5; // eax
  int len_0; // [esp+24h] [ebp-24h]
  Line *lp; // [esp+28h] [ebp-20h]
  int len; // [esp+2Ch] [ebp-1Ch]
  Str last; // [esp+30h] [ebp-18h]
  Str first; // [esp+34h] [ebp-14h]
  TextLineListItem *p; // [esp+38h] [ebp-10h]
  TextLineListItem *pa; // [esp+38h] [ebp-10h]
  Buffer *buf; // [esp+3Ch] [ebp-Ch]

  backend_halfdump_buf = 0;
  do_download = flag;
  buf = loadGeneralFile(url, 0, (char *)0xFFFFFFFF, 0, request);
  do_download = 0;
  if ( buf && buf != (Buffer *)1 )
  {
    if ( is_html_type(buf->type) && backend_halfdump_buf )
    {
      len = 0;
      for ( p = backend_halfdump_buf->first; p; p = p->next )
      {
        v3 = &p->ptr->line;
        if ( ExtHalfdump )
          v4 = wc_Str_conv(p->ptr->line, InnerCharset, DisplayCharset);
        else
          v4 = p->ptr->line;
        *v3 = v4;
        len += p->ptr->line->length + 1;
      }
      first = Strnew_charp("<pre>\n");
      v5 = html_quote(buf->buffername);
      last = Strnew_m_charp("</pre><title>", v5, "</title>\n", 0);
      print_headers(buf, len + first->length + last->length);
      putchar(10);
      printf("%s", first->ptr);
      for ( pa = backend_halfdump_buf->first; pa; pa = pa->next )
        puts(pa->ptr->line->ptr);
      printf("%s", last->ptr);
    }
    else if ( !strcasecmp(buf->type, "text/plain") )
    {
      len_0 = 0;
      for ( lp = buf->firstLine; lp; lp = lp->next )
      {
        len_0 += lp->len;
        if ( lp->lineBuf[lp->len - 1] != 10 )
          ++len_0;
      }
      print_headers(buf, len_0);
      putchar(10);
      saveBuffer(buf, stdout, 1);
    }
    else
    {
      print_headers(buf, 0);
    }
  }
}

//----- (080AC281) --------------------------------------------------------
void __cdecl get(TextList *argv)
{
  int flag; // [esp+14h] [ebp-14h]
  char *url; // [esp+18h] [ebp-10h]
  char *p; // [esp+1Ch] [ebp-Ch]

  url = 0;
  flag = 0;
  while ( 1 )
  {
    p = (char *)popValue((GeneralList *)argv);
    if ( !p )
      break;
    if ( !strcasecmp(p, "-download_only") )
      flag = 1;
    else
      url = p;
  }
  if ( url )
    internal_get(url, flag, 0);
}

//----- (080AC2F3) --------------------------------------------------------
void __cdecl post(TextList *argv)
{
  const char *v1; // eax
  size_t v2; // eax
  int length; // [esp+28h] [ebp-30h]
  int flag; // [esp+2Ch] [ebp-2Ch]
  char *url; // [esp+30h] [ebp-28h]
  char *boundary; // [esp+34h] [ebp-24h]
  char *body; // [esp+38h] [ebp-20h]
  char *enctype; // [esp+3Ch] [ebp-1Ch]
  char *charset; // [esp+40h] [ebp-18h]
  char *target; // [esp+44h] [ebp-14h]
  char *p; // [esp+48h] [ebp-10h]
  form_list *request; // [esp+4Ch] [ebp-Ch]

  target = 0;
  charset = 0;
  enctype = 0;
  body = 0;
  boundary = 0;
  url = 0;
  flag = 0;
  length = 0;
  while ( 1 )
  {
    p = (char *)popValue((GeneralList *)argv);
    if ( !p )
      break;
    if ( !strcasecmp(p, "-download_only") )
    {
      flag = 1;
    }
    else if ( !strcasecmp(p, "-target") )
    {
      target = (char *)popValue((GeneralList *)argv);
    }
    else if ( !strcasecmp(p, "-charset") )
    {
      charset = (char *)popValue((GeneralList *)argv);
    }
    else if ( !strcasecmp(p, "-enctype") )
    {
      enctype = (char *)popValue((GeneralList *)argv);
    }
    else if ( !strcasecmp(p, "-body") )
    {
      body = (char *)popValue((GeneralList *)argv);
    }
    else if ( !strcasecmp(p, "-boundary") )
    {
      boundary = (char *)popValue((GeneralList *)argv);
    }
    else if ( !strcasecmp(p, "-length") )
    {
      v1 = (const char *)popValue((GeneralList *)argv);
      length = atol(v1);
    }
    else
    {
      url = p;
    }
  }
  if ( url )
  {
    request = newFormList(0, "post", charset, enctype, target, 0, 0);
    request->body = body;
    request->boundary = boundary;
    if ( length <= 0 )
    {
      if ( body )
        v2 = strlen(body);
      else
        v2 = 0;
    }
    else
    {
      v2 = length;
    }
    request->length = v2;
    internal_get(url, flag, request);
  }
}

//----- (080AC50E) --------------------------------------------------------
void __cdecl set(TextList *argv)
{
  int i; // [esp+1Ch] [ebp-Ch]

  if ( argv->nitem > 1 )
  {
    for ( i = 0; variable_table[i].name; ++i )
    {
      if ( !strcasecmp(variable_table[i].name, argv->first->ptr) )
      {
        popValue((GeneralList *)argv);
        if ( variable_table[i].set_func )
          variable_table[i].set_func(argv);
        return;
      }
    }
  }
}

//----- (080AC5B3) --------------------------------------------------------
void __cdecl show(TextList *argv)
{
  int i; // [esp+1Ch] [ebp-Ch]

  if ( argv->nitem > 0 )
  {
    for ( i = 0; variable_table[i].name; ++i )
    {
      if ( !strcasecmp(variable_table[i].name, argv->first->ptr) )
      {
        popValue((GeneralList *)argv);
        if ( variable_table[i].show_func )
          variable_table[i].show_func(argv);
        return;
      }
    }
  }
}

//----- (080AC657) --------------------------------------------------------
void __cdecl __noreturn quit(TextList *argv)
{
  save_cookies();
  w3m_exit(0);
}

//----- (080AC670) --------------------------------------------------------
void __cdecl help(TextList *argv)
{
  int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; command_table[i].name; ++i )
    printf("%s %s\n    %s\n", command_table[i].name, command_table[i].option_string, command_table[i].help);
}

//----- (080AC6D7) --------------------------------------------------------
void __cdecl set_column(TextList *argv)
{
  if ( argv->nitem == 1 )
    COLS = atol(argv->first->ptr);
}

//----- (080AC700) --------------------------------------------------------
void __cdecl show_column(TextList *argv)
{
  fprintf(stdout, "column=%d\n", COLS);
}

//----- (080AC728) --------------------------------------------------------
void __cdecl call_command_function(char *str)
{
  TextList *argv; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]

  argv = split(str);
  if ( argv->nitem > 0 )
  {
    for ( i = 0; command_table[i].name; ++i )
    {
      if ( !strcasecmp(command_table[i].name, argv->first->ptr) )
      {
        popValue((GeneralList *)argv);
        if ( command_table[i].func )
          command_table[i].func(argv);
        return;
      }
    }
  }
}

//----- (080AC7BE) --------------------------------------------------------
void __noreturn backend()
{
  char *str; // [esp+1Ch] [ebp-Ch]
  char *stra; // [esp+1Ch] [ebp-Ch]

  w3m_dump = 0;
  if ( !COLS )
    COLS = 80;
  use_mouse = 0;
  if ( backend_batch_commands )
  {
    while ( 1 )
    {
      str = (char *)popValue((GeneralList *)backend_batch_commands);
      if ( !str )
        break;
      call_command_function(str);
    }
  }
  else
  {
    while ( 1 )
    {
      stra = readline("w3m> ");
      if ( !stra )
        break;
      call_command_function(stra);
    }
  }
  quit(0);
}

//----- (080AC84F) --------------------------------------------------------
char *__cdecl readline(char *prompt)
{
  char *result; // eax
  Str s; // [esp+1Ch] [ebp-Ch]

  fputs(prompt, stdout);
  fflush(stdout);
  s = Strfgets(stdin);
  if ( !feof(stdin) || *s->ptr )
    result = s->ptr;
  else
    result = 0;
  return result;
}

//----- (080AC8B3) --------------------------------------------------------
TextList *__cdecl split(char *p)
{
  int v1; // eax
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  char *v12; // eax
  int v13; // eax
  char *v14; // eax
  GeneralList *tp; // [esp+10h] [ebp-18h]
  Str s; // [esp+14h] [ebp-14h]
  int in_single_quote; // [esp+18h] [ebp-10h]
  int in_double_quote; // [esp+1Ch] [ebp-Ch]

  in_double_quote = 0;
  in_single_quote = 0;
  s = Strnew();
  tp = newGeneralList();
  while ( *p )
  {
    v1 = *p;
    if ( v1 <= 13 )
    {
      if ( v1 >= 12 || (unsigned int)(v1 - 9) <= 1 )
      {
LABEL_49:
        if ( in_double_quote || in_single_quote )
        {
          if ( s->length + 1 >= s->area_size )
            Strgrow(s);
          v11 = s->length;
          s->ptr[v11] = *p;
          s->length = v11 + 1;
          s->ptr[s->length] = 0;
        }
        else if ( s->length > 0 )
        {
          v12 = allocStr(s->ptr, -1);
          pushValue(tp, v12);
          s = Strnew();
        }
        goto LABEL_59;
      }
      goto LABEL_56;
    }
    if ( v1 == 34 )
    {
      if ( in_single_quote )
      {
        if ( s->length + 1 >= s->area_size )
          Strgrow(s);
        v2 = s->length;
        s->ptr[v2] = 34;
        s->length = v2 + 1;
        s->ptr[s->length] = 0;
      }
      else
      {
        in_double_quote = in_double_quote == 0;
      }
    }
    else
    {
      if ( v1 <= 34 )
      {
        if ( v1 == 32 )
          goto LABEL_49;
LABEL_56:
        if ( s->length + 1 >= s->area_size )
          Strgrow(s);
        v13 = s->length;
        s->ptr[v13] = *p;
        s->length = v13 + 1;
        s->ptr[s->length] = 0;
        goto LABEL_59;
      }
      if ( v1 == 39 )
      {
        if ( in_double_quote )
        {
          if ( s->length + 1 >= s->area_size )
            Strgrow(s);
          v3 = s->length;
          s->ptr[v3] = 39;
          s->length = v3 + 1;
          s->ptr[s->length] = 0;
        }
        else
        {
          in_single_quote = in_single_quote == 0;
        }
      }
      else
      {
        if ( v1 != 92 )
          goto LABEL_56;
        if ( in_single_quote )
        {
          if ( s->length + 1 >= s->area_size )
            Strgrow(s);
          v10 = s->length;
          s->ptr[v10] = *p;
          s->length = v10 + 1;
          s->ptr[s->length] = 0;
        }
        else
        {
          v4 = *++p;
          if ( v4 == 110 )
          {
            if ( s->length + 1 >= s->area_size )
              Strgrow(s);
            v8 = s->length;
            s->ptr[v8] = 10;
            s->length = v8 + 1;
            s->ptr[s->length] = 0;
          }
          else if ( v4 > 110 )
          {
            if ( v4 == 114 )
            {
              if ( s->length + 1 >= s->area_size )
                Strgrow(s);
              v6 = s->length;
              s->ptr[v6] = 13;
              s->length = v6 + 1;
              s->ptr[s->length] = 0;
            }
            else
            {
              if ( v4 != 116 )
                goto LABEL_43;
              if ( s->length + 1 >= s->area_size )
                Strgrow(s);
              v5 = s->length;
              s->ptr[v5] = 9;
              s->length = v5 + 1;
              s->ptr[s->length] = 0;
            }
          }
          else
          {
            if ( !*p )
              break;
            if ( v4 != 102 )
            {
LABEL_43:
              if ( s->length + 1 >= s->area_size )
                Strgrow(s);
              v9 = s->length;
              s->ptr[v9] = *p;
              s->length = v9 + 1;
              s->ptr[s->length] = 0;
              goto LABEL_59;
            }
            if ( s->length + 1 >= s->area_size )
              Strgrow(s);
            v7 = s->length;
            s->ptr[v7] = 12;
            s->length = v7 + 1;
            s->ptr[s->length] = 0;
          }
        }
      }
    }
LABEL_59:
    ++p;
  }
  if ( s->length > 0 )
  {
    v14 = allocStr(s->ptr, -1);
    pushValue(tp, v14);
  }
  return (TextList *)tp;
}

//----- (080ACD68) --------------------------------------------------------
AnchorList *__cdecl putAnchor(AnchorList *al_0, char *url, char *target, Anchor **anchor_return, char *referer, char *title, unsigned __int8 key, int line, int pos)
{
  bool v9; // al
  Anchor *v10; // eax
  Anchor *v11; // edx
  int bp_0_8; // [esp+2Ch] [ebp-1Ch]
  Anchor *a; // [esp+30h] [ebp-18h]
  int j; // [esp+34h] [ebp-14h]
  int i; // [esp+38h] [ebp-10h]
  int n; // [esp+3Ch] [ebp-Ch]

  if ( !al_0 )
  {
    al_0 = (AnchorList *)GC_malloc(16);
    al_0->anchors = 0;
    al_0->anchormax = 0;
    al_0->nanchor = al_0->anchormax;
    al_0->acache = -1;
  }
  if ( !al_0->anchormax )
  {
    al_0->anchors = (Anchor *)GC_malloc(1800);
    al_0->anchormax = 30;
  }
  if ( al_0->nanchor == al_0->anchormax )
  {
    al_0->anchormax *= 2;
    al_0->anchors = (Anchor *)GC_realloc(al_0->anchors, 60 * al_0->anchormax);
  }
  n = al_0->nanchor;
  if ( !n )
    goto LABEL_12;
  if ( al_0->anchors[n - 1].start.line == line )
  {
    if ( al_0->anchors[n - 1].start.pos - pos >= 0 )
      goto LABEL_13;
LABEL_12:
    i = al_0->nanchor;
    goto LABEL_24;
  }
  if ( al_0->anchors[n - 1].start.line - line < 0 )
    goto LABEL_12;
LABEL_13:
  for ( i = 0; i < n; ++i )
  {
    if ( al_0->anchors[i].start.line == line )
      v9 = al_0->anchors[i].start.pos - pos >= 0;
    else
      v9 = al_0->anchors[i].start.line - line >= 0;
    if ( v9 )
    {
      for ( j = al_0->nanchor; j > i; --j )
      {
        v10 = &al_0->anchors[j];
        v11 = &al_0->anchors[j - 1];
        v10->url = v11->url;
        v10->target = v11->target;
        v10->referer = v11->referer;
        v10->title = v11->title;
        *(_DWORD *)&v10->accesskey = *(_DWORD *)&v11->accesskey;
        v10->start.line = v11->start.line;
        v10->start.pos = v11->start.pos;
        v10->start.invalid = v11->start.invalid;
        v10->end.line = v11->end.line;
        v10->end.pos = v11->end.pos;
        v10->end.invalid = v11->end.invalid;
        v10->hseq = v11->hseq;
        *(_DWORD *)&v10->slave = *(_DWORD *)&v11->slave;
        *(_DWORD *)&v10->rows = *(_DWORD *)&v11->rows;
        v10->image = v11->image;
      }
      break;
    }
  }
LABEL_24:
  a = &al_0->anchors[i];
  a->url = url;
  a->target = target;
  a->referer = referer;
  a->title = title;
  a->accesskey = key;
  a->slave = 0;
  a->start.line = line;
  a->start.pos = pos;
  a->start.invalid = bp_0_8;
  a->end.line = line;
  a->end.pos = pos;
  a->end.invalid = bp_0_8;
  ++al_0->nanchor;
  if ( anchor_return )
    *anchor_return = a;
  return al_0;
}
// 80AD075: variable 'bp_0_8' is possibly undefined
// 8049E6C: using guessed type int __cdecl GC_realloc(_DWORD, _DWORD);
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (080AD0B4) --------------------------------------------------------
Anchor *__cdecl registerHref(Buffer *buf, char *url, char *target, char *referer, char *title, unsigned __int8 key, int line, int pos)
{
  Anchor *a; // [esp+4Ch] [ebp-Ch] BYREF

  buf->href = putAnchor(buf->href, url, target, &a, referer, title, key, line, pos);
  return a;
}

//----- (080AD112) --------------------------------------------------------
Anchor *__cdecl registerName(Buffer *buf, char *url, int line, int pos)
{
  Anchor *a; // [esp+3Ch] [ebp-Ch] BYREF

  buf->name = putAnchor(buf->name, url, 0, &a, 0, 0, 0, line, pos);
  return a;
}

//----- (080AD16D) --------------------------------------------------------
Anchor *__cdecl registerImg(Buffer *buf, char *url, char *title, int line, int pos)
{
  Anchor *a; // [esp+3Ch] [ebp-Ch] BYREF

  buf->img = putAnchor(buf->img, url, 0, &a, 0, title, 0, line, pos);
  return a;
}

//----- (080AD1C7) --------------------------------------------------------
Anchor *__cdecl registerForm(Buffer *buf, FormList *flist, parsed_tag *tag, int line, int pos)
{
  form_item_list *fi; // [esp+38h] [ebp-10h]
  Anchor *a; // [esp+3Ch] [ebp-Ch] BYREF

  fi = formList_addInput(flist, tag);
  if ( !fi )
    return 0;
  buf->formitem = putAnchor(buf->formitem, (char *)fi, flist->target, &a, 0, 0, 0, line, pos);
  return a;
}

//----- (080AD24B) --------------------------------------------------------
int __cdecl onAnchor(Anchor *a, int line, int pos)
{
  int v3; // eax
  bool v5; // al

  if ( line == a->start.line )
    v3 = pos - a->start.pos;
  else
    v3 = line - a->start.line;
  if ( v3 < 0 )
    return -1;
  if ( a->end.line == line )
    v5 = a->end.pos - pos <= 0;
  else
    v5 = a->end.line - line <= 0;
  return v5;
}

//----- (080AD2E4) --------------------------------------------------------
Anchor *__cdecl retrieveAnchor(AnchorList *al_0, int line, int pos)
{
  int cmp; // [esp+Ch] [ebp-14h]
  size_t e; // [esp+10h] [ebp-10h]
  size_t b; // [esp+14h] [ebp-Ch]
  Anchor *a; // [esp+18h] [ebp-8h]

  if ( !al_0 || !al_0->nanchor )
    return 0;
  if ( al_0->acache < 0 || al_0->acache >= al_0->nanchor )
    al_0->acache = 0;
  b = 0;
  for ( e = al_0->nanchor - 1; b <= e; al_0->acache = (b + e) >> 1 )
  {
    a = &al_0->anchors[al_0->acache];
    cmp = onAnchor(a, line, pos);
    if ( !cmp )
      return a;
    if ( cmp <= 0 )
    {
      if ( !al_0->acache )
        return 0;
      e = al_0->acache - 1;
    }
    else
    {
      b = al_0->acache + 1;
    }
  }
  return 0;
}

//----- (080AD3E2) --------------------------------------------------------
Anchor *__cdecl retrieveCurrentAnchor(Buffer *buf)
{
  Anchor *result; // eax

  if ( buf->currentLine )
    result = retrieveAnchor(buf->href, buf->currentLine->linenumber, buf->pos);
  else
    result = 0;
  return result;
}

//----- (080AD420) --------------------------------------------------------
Anchor *__cdecl retrieveCurrentImg(Buffer *buf)
{
  Anchor *result; // eax

  if ( buf->currentLine )
    result = retrieveAnchor(buf->img, buf->currentLine->linenumber, buf->pos);
  else
    result = 0;
  return result;
}

//----- (080AD45E) --------------------------------------------------------
Anchor *__cdecl retrieveCurrentForm(Buffer *buf)
{
  Anchor *result; // eax

  if ( buf->currentLine )
    result = retrieveAnchor(buf->formitem, buf->currentLine->linenumber, buf->pos);
  else
    result = 0;
  return result;
}

//----- (080AD49C) --------------------------------------------------------
Anchor *__cdecl searchAnchor(AnchorList *al_0, char *str)
{
  Anchor *a; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]

  if ( !al_0 )
    return 0;
  for ( i = 0; al_0->nanchor > i; ++i )
  {
    a = &al_0->anchors[i];
    if ( a->hseq >= 0 && !strcmp(a->url, str) )
      return a;
  }
  return 0;
}

//----- (080AD517) --------------------------------------------------------
Anchor *__cdecl searchURLLabel(Buffer *buf, char *url)
{
  return searchAnchor(buf->name, url);
}

//----- (080AD534) --------------------------------------------------------
Anchor *__cdecl put_anchor_news(Buffer *buf, char *p1, char *p2, int line, int pos)
{
  wc_ces v5; // esi
  wc_ces v6; // ebx
  _Str *v7; // eax
  Str v8; // eax
  char *v9; // eax
  char *v11; // [esp+4h] [ebp-34h]

  if ( *p1 == 60 )
  {
    ++p1;
    if ( *(p2 - 1) == 62 )
      --p2;
  }
  v5 = buf->document_charset;
  v6 = InnerCharset;
  v7 = Strnew_charp_n(p1, p2 - p1);
  v8 = wc_Str_conv_strict(v7, v6, v5);
  v9 = file_quote(v8->ptr);
  v11 = Sprintf("news:%s", v9)->ptr;
  return registerHref(buf, v11, 0, (char *)0xFFFFFFFF, 0, 0, line, pos);
}

//----- (080AD601) --------------------------------------------------------
Anchor *__cdecl put_anchor_all(Buffer *buf, char *p1, char *p2, int line, int pos)
{
  wc_ces v5; // esi
  wc_ces v6; // ebx
  _Str *v7; // eax
  char *v9; // [esp+4h] [ebp-34h]
  Str tmp; // [esp+2Ch] [ebp-Ch]

  v5 = buf->document_charset;
  v6 = InnerCharset;
  v7 = Strnew_charp_n(p1, p2 - p1);
  tmp = wc_Str_conv_strict(v7, v6, v5);
  v9 = url_quote(tmp->ptr);
  return registerHref(buf, v9, 0, (char *)0xFFFFFFFF, 0, 0, line, pos);
}

//----- (080AD697) --------------------------------------------------------
void __cdecl reseq_anchor0(AnchorList *al_0, __int16 *seqmap)
{
  Anchor *a; // [esp+8h] [ebp-Ch]
  int i; // [esp+Ch] [ebp-8h]

  if ( al_0 )
  {
    for ( i = 0; al_0->nanchor > i; ++i )
    {
      a = &al_0->anchors[i];
      if ( a->hseq >= 0 )
        a->hseq = seqmap[a->hseq];
    }
  }
}

//----- (080AD702) --------------------------------------------------------
void __cdecl reseq_anchor(Buffer *buf)
{
  int v1; // eax
  Anchor *v2; // eax
  HmarkerList *ml; // [esp+10h] [ebp-28h]
  Anchor *a1; // [esp+14h] [ebp-24h]
  Anchor *a; // [esp+18h] [ebp-20h]
  __int16 *seqmap; // [esp+1Ch] [ebp-1Ch]
  int nmark; // [esp+20h] [ebp-18h]
  int n; // [esp+24h] [ebp-14h]
  int na; // [esp+24h] [ebp-14h]
  int j; // [esp+28h] [ebp-10h]
  int i; // [esp+2Ch] [ebp-Ch]
  int ia; // [esp+2Ch] [ebp-Ch]
  int ib; // [esp+2Ch] [ebp-Ch]
  int ic; // [esp+2Ch] [ebp-Ch]

  if ( buf->hmarklist )
    v1 = buf->hmarklist->nmark;
  else
    v1 = 0;
  nmark = v1;
  ml = 0;
  if ( buf->href )
  {
    n = v1;
    for ( i = 0; buf->href->nanchor > i; ++i )
    {
      if ( buf->href->anchors[i].hseq == -2 )
        ++n;
    }
    if ( n != v1 )
    {
      seqmap = (__int16 *)GC_malloc_atomic(2 * n);
      for ( ia = 0; ia < n; ++ia )
        seqmap[ia] = ia;
      na = nmark;
      for ( ib = 0; buf->href->nanchor > ib; ++ib )
      {
        a = &buf->href->anchors[ib];
        if ( a->hseq == -2 )
        {
          a->hseq = na;
          v2 = closest_next_anchor(buf->href, 0, a->start.pos, a->start.line);
          a1 = closest_next_anchor(buf->formitem, v2, a->start.pos, a->start.line);
          if ( a1 && a1->hseq >= 0 )
          {
            seqmap[na] = seqmap[a1->hseq];
            for ( j = a1->hseq; j < nmark; ++j )
              ++seqmap[j];
          }
          ml = putHmarker(ml, a->start.line, a->start.pos, seqmap[na++]);
        }
      }
      for ( ic = 0; ic < nmark; ++ic )
        ml = putHmarker(ml, buf->hmarklist->marks[ic].line, buf->hmarklist->marks[ic].pos, seqmap[ic]);
      buf->hmarklist = ml;
      reseq_anchor0(buf->href, seqmap);
      reseq_anchor0(buf->formitem, seqmap);
    }
  }
}
// 804A51C: using guessed type int __cdecl GC_malloc_atomic(_DWORD);

//----- (080AD9BB) --------------------------------------------------------
char *__cdecl reAnchorPos(Buffer *buf, Line *l, char *p1, char *p2, Anchor *(*anchorproc)(Buffer *, char *, char *, int, int))
{
  int hseq; // [esp+2Ch] [ebp-1Ch]
  int i; // [esp+30h] [ebp-18h]
  int ia; // [esp+30h] [ebp-18h]
  int epos; // [esp+34h] [ebp-14h]
  int spos; // [esp+38h] [ebp-10h]
  Anchor *a; // [esp+3Ch] [ebp-Ch]

  hseq = -2;
  spos = p1 - l->lineBuf;
  epos = p2 - l->lineBuf;
  for ( i = spos; i < epos; ++i )
  {
    if ( (l->propBuf[i] & 0x50) != 0 )
      return p2;
  }
  for ( ia = p1 - l->lineBuf; ia < epos; ++ia )
    l->propBuf[ia] |= 0x10;
  while ( l->len < spos && l->next && l->next->bpos )
  {
    spos -= l->len;
    epos -= l->len;
    l = l->next;
  }
  while ( 1 )
  {
    a = anchorproc(buf, p1, p2, l->linenumber, spos);
    a->hseq = hseq;
    if ( hseq == -2 )
    {
      reseq_anchor(buf);
      hseq = a->hseq;
    }
    a->end.line = l->linenumber;
    if ( l->len >= epos || !l->next || !l->next->bpos )
      break;
    a->end.pos = l->len;
    spos = 0;
    epos -= l->len;
    l = l->next;
  }
  a->end.pos = epos;
  return p2;
}

//----- (080ADB4D) --------------------------------------------------------
void __cdecl reAnchorWord(Buffer *buf, Line *l, int spos, int epos)
{
  reAnchorPos(buf, l, &l->lineBuf[spos], &l->lineBuf[epos], put_anchor_all);
}

//----- (080ADB8C) --------------------------------------------------------
char *__cdecl reAnchorAny(Buffer *buf, char *re, Anchor *(*anchorproc)(Buffer *, char *, char *, int, int))
{
  Line *v4; // eax
  char *p2; // [esp+20h] [ebp-18h] BYREF
  char *p1; // [esp+24h] [ebp-14h] BYREF
  char *p; // [esp+28h] [ebp-10h]
  Line *l; // [esp+2Ch] [ebp-Ch]
  char *rea; // [esp+44h] [ebp+Ch]

  p = 0;
  if ( !re || !*re )
    return 0;
  rea = regexCompile(re, 1);
  if ( rea )
    return rea;
  if ( MarkAllPages )
    v4 = buf->firstLine;
  else
    v4 = buf->topLine;
  for ( l = v4; l && (MarkAllPages || l->linenumber < LINES - 1 + buf->topLine->linenumber); l = l->next )
  {
    if ( !p || !l->bpos )
    {
      for ( p = l->lineBuf;
            __gmp_vfprintf(p, &l->lineBuf[l->size] - p, l->lineBuf == p) == 1;
            p = reAnchorPos(buf, l, p1, p2, anchorproc) )
      {
        matchedPosition(&p1, &p2);
      }
    }
    if ( MarkAllPages && !l->next && buf->pagerSource && (buf->bufferprop & 0x40) == 0 )
      getNextPage(buf, PagerMax);
  }
  return 0;
}

//----- (080ADD1D) --------------------------------------------------------
char *__cdecl find_nvp_node_0(Buffer *buf, char *re)
{
  return reAnchorAny(buf, re, put_anchor_all);
}

//----- (080ADD3F) --------------------------------------------------------
char *__cdecl find_nvp_node_1(Buffer *buf, char *re)
{
  return reAnchorAny(buf, re, put_anchor_news);
}

//----- (080ADD61) --------------------------------------------------------
char *__cdecl reAnchorNewsheader(Buffer *buf)
{
  size_t v2; // eax
  int search; // [esp+20h] [ebp-28h]
  int i; // [esp+24h] [ebp-24h]
  char **q; // [esp+28h] [ebp-20h]
  char **header; // [esp+2Ch] [ebp-1Ch]
  char *p2; // [esp+30h] [ebp-18h] BYREF
  char *p1; // [esp+34h] [ebp-14h] BYREF
  char *p; // [esp+38h] [ebp-10h]
  Line *l; // [esp+3Ch] [ebp-Ch]

  search = 0;
  if ( !buf || !buf->firstLine )
    return 0;
  for ( i = 0; i <= 1; ++i )
  {
    if ( i )
    {
      regexCompile("[a-zA-Z0-9\\.\\-_]+", 1);
      header = header_group_8686;
    }
    else
    {
      regexCompile("<[!-;=?-~]+@[a-zA-Z0-9\\.\\-_]+>", 1);
      header = header_mid_8685;
    }
    for ( l = buf->firstLine; l && !l->real_linenumber; l = l->next )
    {
      if ( !l->bpos )
      {
        p = l->lineBuf;
        if ( (MYCTYPE_MAP[(unsigned __int8)*p] & 2) == 0 )
        {
          search = 0;
          for ( q = header; *q; ++q )
          {
            v2 = strlen(*q);
            if ( !strncasecmp(p, *q, v2) )
            {
              search = 1;
              p = strchr(p, 58) + 1;
              break;
            }
          }
        }
        if ( search )
        {
          while ( __gmp_vfprintf(p, &l->lineBuf[l->size] - p, l->lineBuf == p) == 1 )
          {
            matchedPosition(&p1, &p2);
            p = reAnchorPos(buf, l, p1, p2, put_anchor_news);
          }
        }
      }
    }
  }
  reseq_anchor(buf);
  return 0;
}

//----- (080ADF4A) --------------------------------------------------------
HmarkerList *__cdecl putHmarker(HmarkerList *ml, int line, int pos, int seq)
{
  if ( !ml )
  {
    ml = (HmarkerList *)GC_malloc(16);
    ml->marks = 0;
    ml->nmark = 0;
    ml->markmax = 0;
    ml->prevhseq = -1;
  }
  if ( !ml->markmax )
  {
    ml->markmax = 30;
    ml->marks = (BufferPoint *)GC_malloc_atomic(12 * ml->markmax);
    bzero(ml->marks, 12 * ml->markmax);
  }
  if ( seq + 1 > ml->nmark )
    ml->nmark = seq + 1;
  if ( ml->nmark >= ml->markmax )
  {
    ml->markmax = 2 * ml->nmark;
    ml->marks = (BufferPoint *)GC_realloc(ml->marks, 12 * ml->markmax);
  }
  ml->marks[seq].line = line;
  ml->marks[seq].pos = pos;
  ml->marks[seq].invalid = 0;
  return ml;
}
// 8049E6C: using guessed type int __cdecl GC_realloc(_DWORD, _DWORD);
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);
// 804A51C: using guessed type int __cdecl GC_malloc_atomic(_DWORD);

//----- (080AE09D) --------------------------------------------------------
Anchor *__cdecl closest_next_anchor(AnchorList *a, Anchor *an, int x, int y)
{
  int i; // [esp+Ch] [ebp-Ch]

  if ( !a || !a->nanchor )
    return an;
  for ( i = 0; a->nanchor > i; ++i )
  {
    if ( a->anchors[i].hseq >= 0
      && (a->anchors[i].start.line > y || a->anchors[i].start.line == y && a->anchors[i].start.pos > x)
      && (!an
       || an->start.line > a->anchors[i].start.line
       || an->start.line == a->anchors[i].start.line && an->start.pos > a->anchors[i].start.pos) )
    {
      an = &a->anchors[i];
    }
  }
  return an;
}

//----- (080AE20C) --------------------------------------------------------
Anchor *__cdecl closest_prev_anchor(AnchorList *a, Anchor *an, int x, int y)
{
  int i; // [esp+Ch] [ebp-Ch]

  if ( !a || !a->nanchor )
    return an;
  for ( i = 0; a->nanchor > i; ++i )
  {
    if ( a->anchors[i].hseq >= 0
      && (a->anchors[i].end.line < y || a->anchors[i].end.line == y && a->anchors[i].end.pos <= x)
      && (!an
       || an->end.line < a->anchors[i].end.line
       || an->end.line == a->anchors[i].end.line && an->end.pos < a->anchors[i].end.pos) )
    {
      an = &a->anchors[i];
    }
  }
  return an;
}

//----- (080AE37B) --------------------------------------------------------
void __cdecl shiftAnchorPosition(AnchorList *al_0, HmarkerList *hl, int line, int pos, int shift)
{
  int cmp; // [esp+18h] [ebp-18h]
  unsigned int s; // [esp+1Ch] [ebp-14h]
  size_t e; // [esp+20h] [ebp-10h]
  size_t b; // [esp+24h] [ebp-Ch]
  Anchor *a; // [esp+28h] [ebp-8h]

  if ( al_0 && al_0->nanchor )
  {
    s = al_0->nanchor / 2;
    b = 0;
    for ( e = al_0->nanchor - 1; b <= e; s = (b + e + 1) >> 1 )
    {
      cmp = onAnchor(&al_0->anchors[s], line, pos);
      if ( !cmp )
        break;
      if ( cmp <= 0 )
      {
        if ( !s )
          break;
        e = s - 1;
      }
      else
      {
        b = s + 1;
      }
    }
    while ( al_0->nanchor > s )
    {
      a = &al_0->anchors[s];
      if ( a->start.line > line )
        break;
      if ( a->start.pos > pos )
      {
        a->start.pos += shift;
        if ( hl->marks[a->hseq].line == line )
          hl->marks[a->hseq].pos = a->start.pos;
      }
      if ( a->end.pos >= pos )
        a->end.pos += shift;
      ++s;
    }
  }
}

//----- (080AE515) --------------------------------------------------------
void __cdecl addMultirowsImg(Buffer *buf, AnchorList *al_0)
{
  Anchor *v2; // eax
  _Line *v3; // eax
  char *a_form; // [esp+54h] [ebp-F4h]
  char *a_form_4; // [esp+58h] [ebp-F0h]
  int a_form_44; // [esp+80h] [ebp-C8h]
  char *a_href; // [esp+90h] [ebp-B8h]
  char *a_href_4; // [esp+94h] [ebp-B4h]
  char *a_href_8; // [esp+98h] [ebp-B0h]
  char *a_href_12; // [esp+9Ch] [ebp-ACh]
  int a_href_16; // [esp+A0h] [ebp-A8h]
  int a_href_44; // [esp+BCh] [ebp-8Ch]
  char *a_img; // [esp+CCh] [ebp-7Ch]
  char *a_img_12; // [esp+D8h] [ebp-70h]
  int a_img_20; // [esp+E0h] [ebp-68h]
  int a_img_24; // [esp+E4h] [ebp-64h]
  int a_img_36; // [esp+F0h] [ebp-58h]
  int a_img_44; // [esp+F8h] [ebp-50h]
  int a_img_48; // [esp+FCh] [ebp-4Ch]
  Line *ls; // [esp+108h] [ebp-40h]
  Line *l; // [esp+10Ch] [ebp-3Ch]
  Anchor *a; // [esp+110h] [ebp-38h] BYREF
  Image *img; // [esp+114h] [ebp-34h]
  int pos; // [esp+118h] [ebp-30h]
  int ecol; // [esp+11Ch] [ebp-2Ch]
  int col; // [esp+120h] [ebp-28h]
  int k; // [esp+124h] [ebp-24h]
  int j; // [esp+128h] [ebp-20h]
  int i; // [esp+12Ch] [ebp-1Ch]

  if ( al_0 && al_0->nanchor )
  {
    for ( i = 0; ; ++i )
    {
      if ( al_0->nanchor <= i )
        return;
      v2 = &al_0->anchors[i];
      a_img = v2->url;
      a_img_12 = v2->title;
      a_img_20 = v2->start.line;
      a_img_24 = v2->start.pos;
      a_img_36 = v2->end.pos;
      a_img_44 = v2->hseq;
      a_img_48 = *(_DWORD *)&v2->slave;
      img = v2->image;
      if ( a_img_44 >= 0 && img && img->rows > 1 )
      {
        for ( l = buf->firstLine; l && l->linenumber != img->y; l = l->next )
          ;
        if ( l )
        {
          if ( SHIWORD(a_img_48) == a_img_20 )
          {
            ls = l;
          }
          else
          {
            for ( ls = l; ls && ls->linenumber != a_img_20; ls = v3 )
            {
              if ( SHIWORD(a_img_48) >= a_img_20 )
                v3 = ls->prev;
              else
                v3 = ls->next;
            }
            if ( !ls )
              continue;
          }
          a = retrieveAnchor(buf->href, a_img_20, a_img_24);
          if ( a )
          {
            a_href = a->url;
            a_href_4 = a->target;
            a_href_8 = a->referer;
            a_href_12 = a->title;
            a_href_16 = *(_DWORD *)&a->accesskey;
            a_href_44 = a->hseq;
          }
          else
          {
            a_href = 0;
          }
          a = retrieveAnchor(buf->formitem, a_img_20, a_img_24);
          if ( a )
          {
            a_form = a->url;
            a_form_4 = a->target;
            a_form_44 = a->hseq;
          }
          else
          {
            a_form = 0;
          }
          col = calcPosition(ls->lineBuf, ls->propBuf, ls->len, a_img_24, 0, 0);
          ecol = calcPosition(ls->lineBuf, ls->propBuf, ls->len, a_img_36, 0, 0);
          for ( j = 0; l && img->rows > j; ++j )
          {
            if ( a_img_20 != l->linenumber )
            {
              pos = columnPos(l, col);
              a = registerImg(buf, a_img, a_img_12, l->linenumber, pos);
              a->hseq = -a_img_44;
              a->slave = 1;
              a->image = img;
              a->end.pos = pos + ecol - col;
              for ( k = pos; a->end.pos > k; ++k )
                l->propBuf[k] |= 0x20;
              if ( a_href )
              {
                a = registerHref(buf, a_href, a_href_4, a_href_8, a_href_12, a_href_16, l->linenumber, pos);
                a->hseq = a_href_44;
                a->slave = 1;
                a->end.pos = pos + ecol - col;
                for ( k = pos; a->end.pos > k; ++k )
                  l->propBuf[k] |= 0x10;
              }
              if ( a_form )
              {
                buf->formitem = putAnchor(buf->formitem, a_form, a_form_4, &a, 0, 0, 0, l->linenumber, pos);
                a->hseq = a_form_44;
                a->end.pos = pos + ecol - col;
              }
            }
            l = l->next;
          }
          img->rows = 0;
        }
      }
    }
  }
}
// 80AE9A4: variable 'a_href_4' is possibly undefined
// 80AE9A4: variable 'a_href_8' is possibly undefined
// 80AE9A4: variable 'a_href_12' is possibly undefined
// 80AE9A4: variable 'a_href_16' is possibly undefined
// 80AE9B5: variable 'a_href_44' is possibly undefined
// 80AEA63: variable 'a_form_4' is possibly undefined
// 80AEA77: variable 'a_form_44' is possibly undefined

//----- (080AEAEF) --------------------------------------------------------
void __cdecl addMultirowsForm(Buffer *buf, AnchorList *al_0)
{
  Anchor *v2; // eax
  _Line *v3; // eax
  char *a_form; // [esp+3Ch] [ebp-6Ch]
  char *a_form_4; // [esp+40h] [ebp-68h]
  int a_form_20; // [esp+50h] [ebp-58h]
  int a_form_24; // [esp+54h] [ebp-54h]
  int a_form_36; // [esp+60h] [ebp-48h]
  int a_form_44; // [esp+68h] [ebp-40h]
  int a_form_48; // [esp+6Ch] [ebp-3Ch]
  int a_form_52; // [esp+70h] [ebp-38h]
  Line *ls; // [esp+78h] [ebp-30h]
  Line *l; // [esp+7Ch] [ebp-2Ch]
  Anchor *a; // [esp+84h] [ebp-24h] BYREF
  int pos; // [esp+88h] [ebp-20h]
  int ecol; // [esp+8Ch] [ebp-1Ch]
  int col; // [esp+90h] [ebp-18h]
  int k; // [esp+94h] [ebp-14h]
  int j; // [esp+98h] [ebp-10h]
  int i; // [esp+9Ch] [ebp-Ch]

  if ( al_0 && al_0->nanchor )
  {
    for ( i = 0; ; ++i )
    {
      if ( al_0->nanchor <= i )
        return;
      v2 = &al_0->anchors[i];
      a_form = v2->url;
      a_form_4 = v2->target;
      a_form_20 = v2->start.line;
      a_form_24 = v2->start.pos;
      a_form_36 = v2->end.pos;
      a_form_44 = v2->hseq;
      a_form_48 = *(_DWORD *)&v2->slave;
      a_form_52 = *(_DWORD *)&v2->rows;
      v2->rows = 1;
      if ( a_form_44 >= 0 && (__int16)a_form_52 > 1 )
      {
        for ( l = buf->firstLine; l && l->linenumber != SHIWORD(a_form_48); l = l->next )
          ;
        if ( l )
        {
          if ( SHIWORD(a_form_48) == a_form_20 )
          {
            ls = l;
          }
          else
          {
            for ( ls = l; ls && ls->linenumber != a_form_20; ls = v3 )
            {
              if ( SHIWORD(a_form_48) >= a_form_20 )
                v3 = ls->prev;
              else
                v3 = ls->next;
            }
            if ( !ls )
              continue;
          }
          col = calcPosition(ls->lineBuf, ls->propBuf, ls->len, a_form_24, 0, 0);
          ecol = calcPosition(ls->lineBuf, ls->propBuf, ls->len, a_form_36, 0, 0);
          for ( j = 0; l && (__int16)a_form_52 > j; ++j )
          {
            pos = columnPos(l, col);
            if ( !j )
            {
              buf->hmarklist->marks[a_form_44].line = l->linenumber;
              buf->hmarklist->marks[a_form_44].pos = pos;
            }
            if ( a_form_20 != l->linenumber )
            {
              buf->formitem = putAnchor(buf->formitem, a_form, a_form_4, &a, 0, 0, 0, l->linenumber, pos);
              a->hseq = a_form_44;
              a->y = HIWORD(a_form_48);
              a->end.pos = pos + ecol - col;
              l->lineBuf[pos - 1] = 91;
              l->lineBuf[a->end.pos] = 93;
              for ( k = pos; a->end.pos > k; ++k )
                l->propBuf[k] |= 0x40;
            }
            l = l->next;
          }
        }
      }
    }
  }
}

//----- (080AEE76) --------------------------------------------------------
char *__cdecl getAnchorText(Buffer *buf, AnchorList *al_0, Anchor *a)
{
  char *result; // eax
  int v4; // eax
  char *ep; // [esp+18h] [ebp-20h]
  char *p; // [esp+1Ch] [ebp-1Ch]
  Str tmp; // [esp+20h] [ebp-18h]
  Line *l; // [esp+24h] [ebp-14h]
  int i; // [esp+28h] [ebp-10h]
  int hseq; // [esp+2Ch] [ebp-Ch]
  Anchor *aa; // [esp+48h] [ebp+10h]

  tmp = 0;
  if ( !a || a->hseq < 0 )
    return 0;
  hseq = a->hseq;
  l = buf->firstLine;
  for ( i = 0; al_0->nanchor > i; ++i )
  {
    aa = &al_0->anchors[i];
    if ( aa->hseq == hseq )
    {
      while ( l && l->linenumber != aa->start.line )
        l = l->next;
      if ( !l )
        break;
      p = &l->lineBuf[aa->start.pos];
      ep = &l->lineBuf[aa->end.pos];
      while ( p < ep && (MYCTYPE_MAP[(unsigned __int8)*p] & 2) != 0 )
        ++p;
      if ( p != ep )
      {
        if ( tmp )
        {
          if ( tmp->length + 1 >= tmp->area_size )
            Strgrow(tmp);
          v4 = tmp->length;
          tmp->ptr[v4] = 32;
          tmp->length = v4 + 1;
          tmp->ptr[tmp->length] = 0;
        }
        else
        {
          tmp = Strnew_size(ep - p);
        }
        Strcat_charp_n(tmp, p, ep - p);
      }
    }
  }
  if ( tmp )
    result = tmp->ptr;
  else
    result = 0;
  return result;
}

//----- (080AF027) --------------------------------------------------------
Buffer *__cdecl link_list_panel(Buffer *buf)
{
  ParsedURL *v2; // eax
  char *v3; // eax
  char *v4; // eax
  ParsedURL *v5; // eax
  char *v6; // eax
  char *v7; // eax
  ParsedURL *v8; // eax
  char *v9; // eax
  char *v10; // eax
  ParsedURL *v11; // eax
  char *v12; // eax
  char *v13; // eax
  ParsedURL pu; // [esp+38h] [ebp-60h] BYREF
  MapArea *m; // [esp+60h] [ebp-38h]
  ListItem *mi; // [esp+64h] [ebp-34h]
  MapList *ml; // [esp+68h] [ebp-30h]
  Str tmp; // [esp+6Ch] [ebp-2Ch]
  char *p; // [esp+70h] [ebp-28h]
  char *u; // [esp+74h] [ebp-24h]
  char *t; // [esp+78h] [ebp-20h]
  int i; // [esp+7Ch] [ebp-1Ch]
  FormItemList *fi; // [esp+80h] [ebp-18h]
  Anchor *a; // [esp+84h] [ebp-14h]
  AnchorList *al_0; // [esp+88h] [ebp-10h]
  LinkList *l; // [esp+8Ch] [ebp-Ch]

  tmp = Strnew_charp("<title>Link List</title><h1 align=center>Link List</h1>\n");
  if ( (buf->bufferprop & 8) != 0 || !buf->linklist && !buf->href && !buf->img )
    return 0;
  if ( buf->linklist )
  {
    Strcat_charp(tmp, "<hr><h2>Links</h2>\n<ol>\n");
    for ( l = buf->linklist; l; l = l->next )
    {
      if ( l->url )
      {
        v2 = baseURL(buf);
        parseURL2(l->url, &pu, v2);
        p = parsedURL2Str(&pu)->ptr;
        u = html_quote(p);
        if ( DecodeURL )
        {
          v3 = url_unquote_conv(p, buf->document_charset);
          p = html_quote(v3);
        }
        else
        {
          p = u;
        }
      }
      else
      {
        p = (char *)&unk_80D08CE;
        u = (char *)&unk_80D08CE;
      }
      if ( l->type == 1 )
      {
        t = " [Rel]";
      }
      else if ( l->type == 2 )
      {
        t = " [Rev]";
      }
      else
      {
        t = (char *)&unk_80D08CE;
      }
      if ( l->title )
        v4 = l->title;
      else
        v4 = (char *)&unk_80D08CE;
      t = Sprintf("%s%s\n", v4, t)->ptr;
      t = html_quote(t);
      Strcat_m_charp(tmp, "<li><a href=\"", u, "\">", t, "</a><br>", p, "\n", 0);
    }
    Strcat_charp(tmp, "</ol>\n");
  }
  if ( buf->href )
  {
    Strcat_charp(tmp, "<hr><h2>Anchors</h2>\n<ol>\n");
    al_0 = buf->href;
    for ( i = 0; al_0->nanchor > i; ++i )
    {
      a = &al_0->anchors[i];
      if ( a->hseq >= 0 && !a->slave )
      {
        v5 = baseURL(buf);
        parseURL2(a->url, &pu, v5);
        p = parsedURL2Str(&pu)->ptr;
        u = html_quote(p);
        if ( DecodeURL )
        {
          v6 = url_unquote_conv(p, buf->document_charset);
          p = html_quote(v6);
        }
        else
        {
          p = u;
        }
        t = getAnchorText(buf, al_0, a);
        if ( t )
          v7 = html_quote(t);
        else
          v7 = (char *)&unk_80D08CE;
        t = v7;
        Strcat_m_charp(tmp, "<li><a href=\"", u, "\">", v7, "</a><br>", p, "\n", 0);
      }
    }
    Strcat_charp(tmp, "</ol>\n");
  }
  if ( buf->img )
  {
    Strcat_charp(tmp, "<hr><h2>Images</h2>\n<ol>\n");
    al_0 = buf->img;
    for ( i = 0; al_0->nanchor > i; ++i )
    {
      a = &al_0->anchors[i];
      if ( !a->slave )
      {
        v8 = baseURL(buf);
        parseURL2(a->url, &pu, v8);
        p = parsedURL2Str(&pu)->ptr;
        u = html_quote(p);
        if ( DecodeURL )
        {
          v9 = url_unquote_conv(p, buf->document_charset);
          p = html_quote(v9);
        }
        else
        {
          p = u;
        }
        if ( a->title && *a->title )
        {
          t = html_quote(a->title);
        }
        else if ( DecodeURL )
        {
          v10 = url_unquote_conv(a->url, buf->document_charset);
          t = html_quote(v10);
        }
        else
        {
          t = html_quote(a->url);
        }
        Strcat_m_charp(tmp, "<li><a href=\"", u, "\">", t, "</a><br>", p, "\n", 0);
        a = retrieveAnchor(buf->formitem, a->start.line, a->start.pos);
        if ( a )
        {
          fi = (FormItemList *)a->url;
          fi = fi->parent->item;
          if ( fi->parent->method == 2 && !strcmp(fi->parent->action->ptr, "map") )
          {
            if ( fi->value )
            {
              ml = searchMapList(buf, fi->value->ptr);
              if ( ml )
              {
                Strcat_charp(tmp, "<br>\n<b>Image map</b>\n<ol>\n");
                for ( mi = ml->area->first; mi; mi = mi->next )
                {
                  m = (MapArea *)mi->ptr;
                  if ( m )
                  {
                    v11 = baseURL(buf);
                    parseURL2(m->url, &pu, v11);
                    p = parsedURL2Str(&pu)->ptr;
                    u = html_quote(p);
                    if ( DecodeURL )
                    {
                      v12 = url_unquote_conv(p, buf->document_charset);
                      p = html_quote(v12);
                    }
                    else
                    {
                      p = u;
                    }
                    if ( m->alt && *m->alt )
                    {
                      t = html_quote(m->alt);
                    }
                    else if ( DecodeURL )
                    {
                      v13 = url_unquote_conv(m->url, buf->document_charset);
                      t = html_quote(v13);
                    }
                    else
                    {
                      t = html_quote(m->url);
                    }
                    Strcat_m_charp(tmp, "<li><a href=\"", u, "\">", t, "</a><br>", p, "\n", 0);
                  }
                }
                Strcat_charp(tmp, "</ol>\n");
              }
            }
          }
        }
      }
    }
    Strcat_charp(tmp, "</ol>\n");
  }
  return loadHTMLString(tmp);
}

//----- (080AF79C) --------------------------------------------------------
int __cdecl noConv(char *oval, char **str)
{
  *str = oval;
  return 1;
}

//----- (080AF7AE) --------------------------------------------------------
int __cdecl toNumber(char *oval, int *num)
{
  int x; // [esp+18h] [ebp-10h]
  char *ep; // [esp+1Ch] [ebp-Ch] BYREF

  x = strtol(oval, &ep, 10);
  if ( ep <= oval )
    return 0;
  *num = x;
  return 1;
}

//----- (080AF7EF) --------------------------------------------------------
int __cdecl toLength(char *oval, int *len)
{
  int w; // [esp+1Ch] [ebp-Ch]

  if ( (MYCTYPE_MAP[(unsigned __int8)*oval] & 8) == 0 )
    return 0;
  w = atoi(oval);
  if ( w < 0 )
    return 0;
  if ( !w )
    w = 1;
  if ( oval[strlen(oval) - 1] == 37 )
    *len = -w;
  else
    *len = w;
  return 1;
}

//----- (080AF873) --------------------------------------------------------
int __cdecl toAlign(char *oval, int *align)
{
  if ( !strcasecmp(oval, "left") )
  {
    *align = 1;
  }
  else if ( !strcasecmp(oval, "right") )
  {
    *align = 2;
  }
  else if ( !strcasecmp(oval, "center") )
  {
    *align = 0;
  }
  else if ( !strcasecmp(oval, "top") )
  {
    *align = 5;
  }
  else if ( !strcasecmp(oval, "bottom") )
  {
    *align = 6;
  }
  else
  {
    if ( strcasecmp(oval, "middle") )
      return 0;
    *align = 4;
  }
  return 1;
}

//----- (080AF959) --------------------------------------------------------
int __cdecl toVAlign(char *oval, int *valign)
{
  if ( !strcasecmp(oval, "top") || !strcasecmp(oval, "baseline") )
  {
    *valign = 1;
  }
  else if ( !strcasecmp(oval, "bottom") )
  {
    *valign = 2;
  }
  else
  {
    if ( strcasecmp(oval, "middle") )
      return 0;
    *valign = 0;
  }
  return 1;
}

//----- (080AF9EA) --------------------------------------------------------
parsed_tag *__cdecl parse_tag(char **s, int internal)
{
  char v2; // al
  char v3; // al
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  char **v8; // ebx
  char *x; // [esp+2Ch] [ebp-BCh]
  int hidden; // [esp+30h] [ebp-B8h]
  int j; // [esp+34h] [ebp-B4h]
  Str value_tmp; // [esp+38h] [ebp-B0h]
  Str value; // [esp+3Ch] [ebp-ACh]
  int nattr; // [esp+40h] [ebp-A8h]
  int attr_id; // [esp+44h] [ebp-A4h]
  int i; // [esp+48h] [ebp-A0h]
  int ia; // [esp+48h] [ebp-A0h]
  char *q; // [esp+4Ch] [ebp-9Ch]
  char *p; // [esp+50h] [ebp-98h]
  char *pa; // [esp+50h] [ebp-98h]
  int tag_id; // [esp+54h] [ebp-94h]
  parsed_tag *tag; // [esp+58h] [ebp-90h]
  char attrname[64]; // [esp+5Ch] [ebp-8Ch] BYREF
  char tagname[64]; // [esp+9Ch] [ebp-4Ch] BYREF
  unsigned int v26; // [esp+DCh] [ebp-Ch]

  v26 = __readgsdword(0x14u);
  tag = 0;
  attr_id = 0;
  q = *s + 1;
  p = tagname;
  if ( *q == 47 )
  {
    tagname[0] = *q;
    p = &tagname[1];
    ++q;
    while ( *q && (MYCTYPE_MAP[(unsigned __int8)*q] & 2) != 0 )
      ++q;
  }
  while ( *q
       && (MYCTYPE_MAP[(unsigned __int8)*q] & 2) == 0
       && (tagname[0] == 47 || *q != 47)
       && *q != 62
       && p - tagname <= 62 )
  {
    if ( (MYCTYPE_MAP[(unsigned __int8)*q] & 4) != 0 )
      v2 = *q | 0x20;
    else
      v2 = *q;
    *p++ = v2;
    ++q;
  }
  *p = 0;
  while ( *q && (MYCTYPE_MAP[(unsigned __int8)*q] & 2) == 0 && (tagname[0] == 47 || *q != 47) && *q != 62 )
    ++q;
  tag_id = getHash_si(&tagtable, tagname, 0);
  if ( tag_id && (internal || (TagMAP[tag_id].flag & 2) == 0) )
  {
    tag = (parsed_tag *)GC_malloc(20);
    bzero(tag, 0x14u);
    tag->tagid = tag_id;
    nattr = TagMAP[tag_id].max_attribute;
    if ( TagMAP[tag_id].max_attribute )
    {
      tag->attrid = (unsigned __int8 *)GC_malloc_atomic(nattr);
      tag->value = (char **)GC_malloc(4 * nattr);
      tag->map = (unsigned __int8 *)GC_malloc_atomic(75);
      memset(tag->map, 75, 0x4Bu);
      memset(tag->attrid, 0, nattr);
      for ( i = 0; i < nattr; ++i )
        tag->map[TagMAP[tag_id].accept_attribute[i]] = i;
    }
    while ( *q && (MYCTYPE_MAP[(unsigned __int8)*q] & 2) != 0 )
      ++q;
    while ( 1 )
    {
      value = 0;
      value_tmp = 0;
      if ( *q == 62 || !*q )
        break;
      for ( pa = attrname;
            *q && *q != 61 && (MYCTYPE_MAP[(unsigned __int8)*q] & 2) == 0 && *q != 62 && pa - attrname <= 62;
            ++pa )
      {
        if ( (MYCTYPE_MAP[(unsigned __int8)*q] & 4) != 0 )
          v3 = *q | 0x20;
        else
          v3 = *q;
        *pa = v3;
        ++q;
      }
      *pa = 0;
      while ( *q && *q != 61 && (MYCTYPE_MAP[(unsigned __int8)*q] & 2) == 0 && *q != 62 )
        ++q;
      while ( *q && (MYCTYPE_MAP[(unsigned __int8)*q] & 2) != 0 )
        ++q;
      if ( *q == 61 )
      {
        value_tmp = Strnew();
        ++q;
        while ( *q && (MYCTYPE_MAP[(unsigned __int8)*q] & 2) != 0 )
          ++q;
        if ( *q == 34 )
        {
          ++q;
          while ( *q && *q != 34 )
          {
            if ( value_tmp->length + 1 >= value_tmp->area_size )
              Strgrow(value_tmp);
            v4 = value_tmp->length;
            value_tmp->ptr[v4] = *q;
            value_tmp->length = v4 + 1;
            value_tmp->ptr[value_tmp->length] = 0;
            if ( !tag->need_reconstruct && (QUOTE_MAP[(unsigned __int8)*q] & 7) != 0 )
              tag->need_reconstruct = 1;
            ++q;
          }
          if ( *q == 34 )
            ++q;
        }
        else if ( *q == 39 )
        {
          ++q;
          while ( *q && *q != 39 )
          {
            if ( value_tmp->length + 1 >= value_tmp->area_size )
              Strgrow(value_tmp);
            v5 = value_tmp->length;
            value_tmp->ptr[v5] = *q;
            value_tmp->length = v5 + 1;
            value_tmp->ptr[value_tmp->length] = 0;
            if ( !tag->need_reconstruct && (QUOTE_MAP[(unsigned __int8)*q] & 7) != 0 )
              tag->need_reconstruct = 1;
            ++q;
          }
          if ( *q == 39 )
            ++q;
        }
        else if ( *q )
        {
          while ( *q && (MYCTYPE_MAP[(unsigned __int8)*q] & 2) == 0 && *q != 62 )
          {
            if ( value_tmp->length + 1 >= value_tmp->area_size )
              Strgrow(value_tmp);
            v6 = value_tmp->length;
            value_tmp->ptr[v6] = *q;
            value_tmp->length = v6 + 1;
            value_tmp->ptr[value_tmp->length] = 0;
            if ( !tag->need_reconstruct && (QUOTE_MAP[(unsigned __int8)*q] & 7) != 0 )
              tag->need_reconstruct = 1;
            ++q;
          }
        }
      }
      for ( ia = 0; ia < nattr; ++ia )
      {
        if ( !tag->attrid[ia] && !strcmp(AttrMAP[TagMAP[tag_id].accept_attribute[ia]].name, attrname) )
        {
          attr_id = TagMAP[tag_id].accept_attribute[ia];
          break;
        }
      }
      if ( value_tmp )
      {
        hidden = 0;
        for ( j = 0; j < ia; ++j )
        {
          if ( tag->attrid[j] == 33 && !strcmp("hidden", tag->value[j]) )
          {
            hidden = 1;
            break;
          }
        }
        if ( (tag_id == 44 || tag_id == 134) && attr_id == 36 && hidden )
        {
          value = value_tmp;
        }
        else
        {
          value = Strnew();
          for ( x = value_tmp->ptr; *x; ++x )
          {
            if ( *x != 10 )
            {
              if ( value->length + 1 >= value->area_size )
                Strgrow(value);
              v7 = value->length;
              value->ptr[v7] = *x;
              value->length = v7 + 1;
              value->ptr[value->length] = 0;
            }
          }
        }
      }
      if ( ia == nattr )
      {
        tag->need_reconstruct = 1;
      }
      else if ( !internal
             && ((AttrMAP[attr_id].flag & 1) != 0
              || value && AttrMAP[attr_id].vtype == 8 && !strcasecmp(value->ptr, "internal")) )
      {
        tag->need_reconstruct = 1;
      }
      else
      {
        tag->attrid[ia] = attr_id;
        if ( value )
        {
          v8 = &tag->value[ia];
          *v8 = html_unquote(value->ptr);
        }
        else
        {
          tag->value[ia] = 0;
        }
      }
    }
  }
  else
  {
    while ( *q != 62 && *q )
      ++q;
  }
  if ( *q == 62 )
    ++q;
  *s = q;
  return tag;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);
// 804A51C: using guessed type int __cdecl GC_malloc_atomic(_DWORD);

//----- (080B05B7) --------------------------------------------------------
int __cdecl parsedtag_set_value(parsed_tag *tag, int id, char *value)
{
  char **v4; // ebx
  int i; // [esp+1Ch] [ebp-Ch]

  if ( !tag->map || tag->map[id] == 75 )
    return 0;
  i = tag->map[id];
  tag->attrid[i] = id;
  if ( value )
  {
    v4 = &tag->value[i];
    *v4 = allocStr(value, -1);
  }
  else
  {
    tag->value[i] = 0;
  }
  tag->need_reconstruct = 1;
  return 1;
}

//----- (080B0659) --------------------------------------------------------
int __cdecl parsedtag_get_value(parsed_tag *tag, int id, void *value)
{
  int result; // eax
  int i; // [esp+1Ch] [ebp-Ch]

  if ( tag->map && tag->map[id] != 75 && tag->attrid[tag->map[id]] && (i = tag->map[id], tag->value[i]) )
    result = toValFunc[AttrMAP[id].vtype](tag->value[i], (char **)value);
  else
    result = 0;
  return result;
}

//----- (080B0702) --------------------------------------------------------
Str __cdecl parsedtag2str(parsed_tag *tag)
{
  int v1; // eax
  int v2; // eax
  char *v3; // eax
  int v4; // eax
  _Str *v6; // [esp+4h] [ebp-24h]
  Str tagstr; // [esp+10h] [ebp-18h]
  int nattr; // [esp+14h] [ebp-14h]
  int tag_id; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]

  tag_id = tag->tagid;
  nattr = TagMAP[tag_id].max_attribute;
  tagstr = Strnew();
  if ( tagstr->length + 1 >= tagstr->area_size )
    Strgrow(tagstr);
  v1 = tagstr->length;
  tagstr->ptr[v1] = 60;
  tagstr->length = v1 + 1;
  tagstr->ptr[tagstr->length] = 0;
  Strcat_charp(tagstr, TagMAP[tag_id].name);
  for ( i = 0; i < nattr; ++i )
  {
    if ( tag->attrid[i] )
    {
      if ( tagstr->length + 1 >= tagstr->area_size )
        Strgrow(tagstr);
      v2 = tagstr->length;
      tagstr->ptr[v2] = 32;
      tagstr->length = v2 + 1;
      tagstr->ptr[tagstr->length] = 0;
      Strcat_charp(tagstr, AttrMAP[tag->attrid[i]].name);
      if ( tag->value[i] )
      {
        v3 = html_quote(tag->value[i]);
        v6 = Sprintf("=\"%s\"", v3);
        savexmlstr_0(tagstr, v6);
      }
    }
  }
  if ( tagstr->length + 1 >= tagstr->area_size )
    Strgrow(tagstr);
  v4 = tagstr->length;
  tagstr->ptr[v4] = 62;
  tagstr->length = v4 + 1;
  tagstr->ptr[tagstr->length] = 0;
  return tagstr;
}

//----- (080B08E4) --------------------------------------------------------
void __cdecl do_update(BaseStream base)
{
  int len; // [esp+1Ch] [ebp-Ch]

  base->stream.next = 0;
  base->stream.cur = base->stream.next;
  len = base->read(base->handle, base->stream.buf, base->stream.size);
  if ( len > 0 )
    base->stream.next += len;
  else
    base->iseos = 1;
}

//----- (080B094E) --------------------------------------------------------
int __cdecl buffer_read(StreamBuffer sb, char *obuf, int count)
{
  int len; // [esp+1Ch] [ebp-Ch]

  len = sb->next - sb->cur;
  if ( len > 0 )
  {
    if ( len > count )
      len = count;
    bcopy(&sb->buf[sb->cur], obuf, len);
    sb->cur += len;
  }
  return len;
}

//----- (080B09B7) --------------------------------------------------------
void __cdecl init_buffer(BaseStream base, char *buf, int bufsize)
{
  base->stream.size = bufsize;
  base->stream.cur = 0;
  if ( buf )
  {
    base->stream.buf = (unsigned __int8 *)buf;
    base->stream.next = bufsize;
  }
  else
  {
    base->stream.buf = (unsigned __int8 *)GC_malloc_atomic(bufsize);
    base->stream.next = 0;
  }
  base->iseos = 0;
}
// 804A51C: using guessed type int __cdecl GC_malloc_atomic(_DWORD);

//----- (080B0A14) --------------------------------------------------------
void __cdecl jzero_far(BaseStream base, int bufsize)
{
  init_buffer(base, 0, bufsize);
}

//----- (080B0A36) --------------------------------------------------------
void __cdecl savexmlstr(BaseStream base, Str s)
{
  init_buffer(base, s->ptr, s->length);
}

//----- (080B0A5C) --------------------------------------------------------
InputStream __cdecl newInputStream(int des)
{
  InputStream stream; // [esp+1Ch] [ebp-Ch]

  if ( des < 0 )
    return 0;
  stream = (InputStream)GC_malloc(32);
  jzero_far(&stream->base, 0x2000);
  stream->base.type = 0;
  stream->base.handle = (void *)GC_malloc(4);
  *(_DWORD *)stream->base.handle = des;
  stream->base.read = (int (*)(...))basic_read;
  stream->base.close = (void (*)(...))basic_close;
  return stream;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (080B0AD0) --------------------------------------------------------
InputStream __cdecl newFileStream(FILE *f, void (*closep)(...))
{
  InputStream stream; // [esp+1Ch] [ebp-Ch]

  if ( !f )
    return 0;
  stream = (InputStream)GC_malloc(32);
  jzero_far(&stream->base, 0x2000);
  stream->base.type = 1;
  stream->base.handle = (void *)GC_malloc(8);
  *(_DWORD *)stream->base.handle = f;
  if ( closep )
    *((_DWORD *)stream->base.handle + 1) = closep;
  else
    *((_DWORD *)stream->base.handle + 1) = fclose;
  stream->base.read = (int (*)(...))file_read;
  stream->base.close = (void (*)(...))file_close;
  return stream;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (080B0B6B) --------------------------------------------------------
InputStream __cdecl newStrStream(Str s)
{
  InputStream stream; // [esp+1Ch] [ebp-Ch]

  if ( !s )
    return 0;
  stream = (InputStream)GC_malloc(32);
  savexmlstr(&stream->base, s);
  stream->base.type = 2;
  stream->base.handle = s;
  stream->base.read = (int (*)(...))str_read;
  stream->base.close = 0;
  return stream;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (080B0BC9) --------------------------------------------------------
InputStream __cdecl newEncodedStream(InputStream is, char encoding)
{
  InputStream stream; // [esp+2Ch] [ebp-Ch]

  if ( !is || encoding != 2 && encoding != 1 && encoding != 3 )
    return is;
  stream = (InputStream)GC_malloc(32);
  jzero_far(&stream->base, 0x2000);
  stream->base.type = 4;
  stream->base.handle = (void *)GC_malloc(16);
  *(_DWORD *)stream->base.handle = is;
  *((_DWORD *)stream->base.handle + 2) = 0;
  *((_BYTE *)stream->base.handle + 12) = encoding;
  *((_DWORD *)stream->base.handle + 1) = 0;
  stream->base.read = (int (*)(...))ens_read;
  stream->base.close = (void (*)(...))ens_close;
  return stream;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (080B0C7F) --------------------------------------------------------
int __cdecl ISclose(InputStream stream)
{
  void (*prevtrap)(int); // [esp+1Ch] [ebp-Ch]

  if ( !stream || !stream->base.close || (stream->base.type & 0x10) != 0 )
    return -1;
  prevtrap = mySignal(2, (void (*)(int))1);
  stream->base.close(stream->base.handle);
  mySignal(2, prevtrap);
  return 0;
}

//----- (080B0CEF) --------------------------------------------------------
int __cdecl ISgetc(InputStream stream)
{
  if ( !stream )
    return 0;
  if ( !stream->base.iseos && stream->base.stream.cur == stream->base.stream.next )
    do_update(&stream->base);
  if ( stream->base.iseos )
    return 0;
  return stream->base.stream.buf[stream->base.stream.cur++];
}

//----- (080B0D61) --------------------------------------------------------
int __cdecl ISundogetc(InputStream stream)
{
  if ( !stream )
    return -1;
  if ( stream->base.stream.cur <= 0 )
    return -1;
  --stream->base.stream.cur;
  return 0;
}

//----- (080B0DA1) --------------------------------------------------------
Str __cdecl StrISgets(InputStream stream)
{
  Str result; // eax
  unsigned int len; // [esp+1Ch] [ebp-1Ch]
  unsigned __int8 *p; // [esp+20h] [ebp-18h]
  _Str *s; // [esp+24h] [ebp-14h]

  s = 0;
  if ( !stream )
    return 0;
  while ( 1 )
  {
    while ( 1 )
    {
      if ( stream->base.iseos )
      {
        if ( s )
          result = s;
        else
          result = Strnew();
        return result;
      }
      if ( stream->base.stream.cur != stream->base.stream.next )
        break;
      do_update(&stream->base);
    }
    p = (unsigned __int8 *)memchr(
                             &stream->base.stream.buf[stream->base.stream.cur],
                             10,
                             stream->base.stream.next - stream->base.stream.cur);
    if ( p )
      break;
    if ( !s )
      s = Strnew_size(stream->base.stream.next - stream->base.stream.cur + 10);
    Strcat_charp_n(
      s,
      (char *)&stream->base.stream.buf[stream->base.stream.cur],
      stream->base.stream.next - stream->base.stream.cur);
    stream->base.stream.cur = stream->base.stream.next;
  }
  len = p - &stream->base.stream.buf[stream->base.stream.cur] + 1;
  if ( !s )
    s = Strnew_size(len);
  Strcat_charp_n(s, (char *)&stream->base.stream.buf[stream->base.stream.cur], len);
  stream->base.stream.cur += len;
  return s;
}

//----- (080B0F1F) --------------------------------------------------------
Str __cdecl StrmyISgets(InputStream stream)
{
  Str result; // eax
  int v2; // edx
  int v3; // eax
  int len; // [esp+1Ch] [ebp-1Ch]
  int i; // [esp+20h] [ebp-18h]
  Str s; // [esp+24h] [ebp-14h]

  s = 0;
  if ( !stream )
    return 0;
  while ( 1 )
  {
    while ( 1 )
    {
      if ( stream->base.iseos )
      {
        if ( s )
          result = s;
        else
          result = Strnew();
        return result;
      }
      if ( stream->base.stream.cur != stream->base.stream.next )
        break;
      do_update(&stream->base);
    }
    if ( s && s->length > 0 && s->ptr[s->length - 1] == 13 )
      break;
    for ( i = stream->base.stream.cur;
          stream->base.stream.next > i && stream->base.stream.buf[i] != 10 && stream->base.stream.buf[i] != 13;
          ++i )
    {
      ;
    }
    if ( stream->base.stream.next <= i )
    {
      if ( !s )
        s = Strnew_size(stream->base.stream.next - stream->base.stream.cur + 10);
      Strcat_charp_n(
        s,
        (char *)&stream->base.stream.buf[stream->base.stream.cur],
        stream->base.stream.next - stream->base.stream.cur);
      stream->base.stream.cur = stream->base.stream.next;
    }
    else
    {
      len = i - stream->base.stream.cur + 1;
      if ( !s )
        s = Strnew_size(i - stream->base.stream.cur + 11);
      Strcat_charp_n(s, (char *)&stream->base.stream.buf[stream->base.stream.cur], len);
      stream->base.stream.cur = i + 1;
      if ( stream->base.stream.buf[i] == 10 )
        return s;
    }
  }
  if ( stream->base.stream.buf[stream->base.stream.cur] == 10 )
  {
    if ( s->length + 1 >= s->area_size )
      Strgrow(s);
    v2 = s->length;
    v3 = stream->base.stream.cur;
    s->ptr[v2] = stream->base.stream.buf[v3];
    s->length = v2 + 1;
    stream->base.stream.cur = v3 + 1;
    s->ptr[s->length] = 0;
  }
  return s;
}

//----- (080B116F) --------------------------------------------------------
int __cdecl ISread(InputStream stream, Str buf, int count)
{
  int len; // [esp+18h] [ebp-10h]
  int lena; // [esp+18h] [ebp-10h]
  int rest; // [esp+1Ch] [ebp-Ch]

  if ( !stream || stream->base.iseos )
    return 0;
  len = buffer_read(&stream->base.stream, buf->ptr, count);
  rest = count - len;
  if ( stream->base.stream.cur == stream->base.stream.next )
  {
    lena = stream->base.read(stream->base.handle, &buf->ptr[len], rest);
    if ( lena <= 0 )
    {
      stream->base.iseos = 1;
      lena = 0;
    }
    rest -= lena;
  }
  Strtruncate(buf, count - rest);
  return buf->length > 0;
}

//----- (080B124F) --------------------------------------------------------
int __cdecl ISfileno(InputStream stream)
{
  int v2; // eax

  if ( !stream )
    return -1;
  v2 = (char)(stream->base.type & 0xEF);
  if ( v2 == 1 )
    return fileno(*(FILE **)stream->base.handle);
  if ( v2 == 4 )
    return ISfileno(*(InputStream *)stream->base.handle);
  if ( (stream->base.type & 0xEF) != 0 )
    return -1;
  return *(_DWORD *)stream->base.handle;
}

//----- (080B12B2) --------------------------------------------------------
int __cdecl ISeos(InputStream stream)
{
  if ( !stream->base.iseos && stream->base.stream.cur == stream->base.stream.next )
    do_update(&stream->base);
  return stream->base.iseos;
}

//----- (080B12F0) --------------------------------------------------------
void __cdecl basic_close(int *handle)
{
  close(*handle);
}

//----- (080B1305) --------------------------------------------------------
int __cdecl basic_read(int *handle, char *buf, int len)
{
  return read(*handle, buf, len);
}

//----- (080B1328) --------------------------------------------------------
void __cdecl file_close(file_handle *handle)
{
  handle->close(handle->f);
}

//----- (080B1340) --------------------------------------------------------
int __cdecl file_read(file_handle *handle, char *buf, int len)
{
  return fread(buf, 1u, len, handle->f);
}

//----- (080B136B) --------------------------------------------------------
int __cdecl str_read(Str handle, char *buf, int len)
{
  return 0;
}

//----- (080B1375) --------------------------------------------------------
void __cdecl ens_close(ens_handle *handle)
{
  ISclose(handle->is);
}

//----- (080B138A) --------------------------------------------------------
int __cdecl ens_read(ens_handle *handle, char *buf, int len)
{
  char *p[3]; // [esp+1Ch] [ebp-Ch] BYREF

  if ( !handle->s || handle->pos == handle->s->length )
  {
    handle->s = StrmyISgets(handle->is);
    if ( !handle->s->length )
      return 0;
    cleanup_line(handle->s, 1);
    if ( handle->encoding != 1 )
    {
      if ( handle->encoding != 3 )
      {
LABEL_10:
        p[0] = handle->s->ptr;
        switch ( handle->encoding )
        {
          case 2:
            handle->s = decodeQP(p);
            break;
          case 1:
            handle->s = decodeB(p);
            break;
          case 3:
            handle->s = decodeU(p);
            break;
        }
        handle->pos = 0;
        goto LABEL_17;
      }
      if ( !strncmp(handle->s->ptr, "begin", 5u) )
        handle->s = StrmyISgets(handle->is);
    }
    Strchop(handle->s);
    goto LABEL_10;
  }
LABEL_17:
  if ( handle->s->length - handle->pos < len )
    len = handle->s->length - handle->pos;
  bcopy(&handle->s->ptr[handle->pos], buf, len);
  handle->pos += len;
  return len;
}

//----- (080B1538) --------------------------------------------------------
Str Strnew()
{
  Str x; // [esp+1Ch] [ebp-Ch]

  x = (Str)GC_malloc(12);
  x->ptr = (char *)GC_malloc_atomic(32);
  *x->ptr = 0;
  x->area_size = 32;
  x->length = 0;
  return x;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);
// 804A51C: using guessed type int __cdecl GC_malloc_atomic(_DWORD);

//----- (080B1581) --------------------------------------------------------
Str __cdecl Strnew_size(int n)
{
  Str x; // [esp+1Ch] [ebp-Ch]

  x = (Str)GC_malloc(12);
  x->ptr = (char *)GC_malloc_atomic(n + 1);
  *x->ptr = 0;
  x->area_size = n + 1;
  x->length = 0;
  return x;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);
// 804A51C: using guessed type int __cdecl GC_malloc_atomic(_DWORD);

//----- (080B15CE) --------------------------------------------------------
Str __cdecl Strnew_charp(char *p)
{
  int n; // [esp+18h] [ebp-10h]
  Str x; // [esp+1Ch] [ebp-Ch]

  if ( !p )
    return Strnew();
  x = (Str)GC_malloc(12);
  n = strlen(p) + 1;
  x->ptr = (char *)GC_malloc_atomic(n);
  x->area_size = n;
  x->length = n - 1;
  bcopy(p, x->ptr, n);
  return x;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);
// 804A51C: using guessed type int __cdecl GC_malloc_atomic(_DWORD);

//----- (080B1648) --------------------------------------------------------
Str Strnew_m_charp(char *p, ...)
{
  char **v1; // eax
  _Str *r; // [esp+18h] [ebp-10h]
  va_list ap; // [esp+1Ch] [ebp-Ch]
  va_list va; // [esp+34h] [ebp+Ch] BYREF

  va_start(va, p);
  r = Strnew();
  va_copy(ap, va);
  while ( p )
  {
    Strcat_charp(r, p);
    v1 = (char **)ap;
    ap += 4;
    p = *v1;
  }
  return r;
}

//----- (080B1689) --------------------------------------------------------
Str __cdecl Strnew_charp_n(char *p, int n)
{
  Str x; // [esp+1Ch] [ebp-Ch]

  if ( !p )
    return Strnew_size(n);
  x = (Str)GC_malloc(12);
  x->ptr = (char *)GC_malloc_atomic(n + 1);
  x->area_size = n + 1;
  x->length = n;
  bcopy(p, x->ptr, n);
  x->ptr[n] = 0;
  return x;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);
// 804A51C: using guessed type int __cdecl GC_malloc_atomic(_DWORD);

//----- (080B1709) --------------------------------------------------------
Str __cdecl Strdup(Str s)
{
  _Str *n; // [esp+1Ch] [ebp-Ch]

  n = Strnew_size(s->length);
  Strcopy(n, s);
  return n;
}

//----- (080B1737) --------------------------------------------------------
void __cdecl Strclear(Str s)
{
  s->length = 0;
  *s->ptr = 0;
}

//----- (080B174E) --------------------------------------------------------
void __cdecl Strfree(Str x)
{
  GC_free(x->ptr);
  GC_free(x);
}
// 804A25C: using guessed type int __cdecl GC_free(_DWORD);

//----- (080B176E) --------------------------------------------------------
void __cdecl Strcopy(Str x, Str y)
{
  if ( x->area_size < y->length + 1 )
  {
    GC_free(x->ptr);
    x->ptr = (char *)GC_malloc_atomic(y->length + 1);
    x->area_size = y->length + 1;
  }
  bcopy(y->ptr, x->ptr, y->length + 1);
  x->length = y->length;
}
// 804A25C: using guessed type int __cdecl GC_free(_DWORD);
// 804A51C: using guessed type int __cdecl GC_malloc_atomic(_DWORD);

//----- (080B17EE) --------------------------------------------------------
void __cdecl Strcopy_charp(Str x, char *y)
{
  size_t len; // [esp+1Ch] [ebp-Ch]

  if ( y )
  {
    len = strlen(y);
    if ( x->area_size < (signed int)(len + 1) )
    {
      GC_free(x->ptr);
      x->ptr = (char *)GC_malloc_atomic(len + 1);
      x->area_size = len + 1;
    }
    bcopy(y, x->ptr, len + 1);
    x->length = len;
  }
  else
  {
    x->length = 0;
  }
}
// 804A25C: using guessed type int __cdecl GC_free(_DWORD);
// 804A51C: using guessed type int __cdecl GC_malloc_atomic(_DWORD);

//----- (080B187D) --------------------------------------------------------
void __cdecl Strcopy_charp_n(Str x, char *y, int n)
{
  if ( y )
  {
    if ( x->area_size < n + 1 )
    {
      GC_free(x->ptr);
      x->ptr = (char *)GC_malloc_atomic(n + 1);
      x->area_size = n + 1;
    }
    bcopy(y, x->ptr, n);
    x->ptr[n] = 0;
    x->length = n;
  }
  else
  {
    x->length = 0;
  }
}
// 804A25C: using guessed type int __cdecl GC_free(_DWORD);
// 804A51C: using guessed type int __cdecl GC_malloc_atomic(_DWORD);

//----- (080B190D) --------------------------------------------------------
void __cdecl Strcat_charp_n(Str x, char *y, int n)
{
  char *old; // [esp+18h] [ebp-10h]
  int newlen; // [esp+1Ch] [ebp-Ch]
  int newlena; // [esp+1Ch] [ebp-Ch]

  if ( y )
  {
    newlen = n + x->length + 1;
    if ( x->area_size < newlen )
    {
      old = x->ptr;
      newlena = 3 * newlen / 2;
      x->ptr = (char *)GC_malloc_atomic(newlena);
      x->area_size = newlena;
      bcopy(old, x->ptr, x->length);
      GC_free(old);
    }
    bcopy(y, &x->ptr[x->length], n);
    x->length += n;
    x->ptr[x->length] = 0;
  }
}
// 804A25C: using guessed type int __cdecl GC_free(_DWORD);
// 804A51C: using guessed type int __cdecl GC_malloc_atomic(_DWORD);

//----- (080B19E6) --------------------------------------------------------
void __cdecl savexmlstr_0(Str x, Str y)
{
  Strcat_charp_n(x, y->ptr, y->length);
}

//----- (080B1A0C) --------------------------------------------------------
void __cdecl Strcat_charp(Str x, char *y)
{
  int v2; // [esp+8h] [ebp-10h]

  if ( y )
  {
    v2 = strlen(y);
    Strcat_charp_n(x, y, v2);
  }
}

//----- (080B1A3E) --------------------------------------------------------
void Strcat_m_charp(Str x, ...)
{
  char **v1; // eax
  int v2; // [esp+8h] [ebp-20h]
  char *p; // [esp+18h] [ebp-10h]
  va_list ap; // [esp+1Ch] [ebp-Ch]
  va_list va; // [esp+34h] [ebp+Ch] BYREF

  va_start(va, x);
  va_copy(ap, va);
  while ( 1 )
  {
    v1 = (char **)ap;
    ap += 4;
    p = *v1;
    if ( !*v1 )
      break;
    v2 = strlen(p);
    Strcat_charp_n(x, p, v2);
  }
}

//----- (080B1A83) --------------------------------------------------------
void __cdecl Strgrow(Str x)
{
  int newlen; // [esp+18h] [ebp-10h]
  char *old; // [esp+1Ch] [ebp-Ch]

  old = x->ptr;
  newlen = 6 * x->length / 5;
  if ( x->length == newlen )
    newlen += 2;
  x->ptr = (char *)GC_malloc_atomic(newlen);
  x->area_size = newlen;
  bcopy(old, x->ptr, x->length);
  GC_free(old);
}
// 804A25C: using guessed type int __cdecl GC_free(_DWORD);
// 804A51C: using guessed type int __cdecl GC_malloc_atomic(_DWORD);

//----- (080B1B11) --------------------------------------------------------
Str __cdecl Strsubstr(Str s, int beg, int len)
{
  int v4; // eax
  int i; // [esp+18h] [ebp-10h]
  Str new_s; // [esp+1Ch] [ebp-Ch]

  new_s = Strnew();
  if ( s->length <= beg )
    return new_s;
  for ( i = 0; i < len && i + beg < s->length; ++i )
  {
    if ( new_s->length + 1 >= new_s->area_size )
      Strgrow(new_s);
    v4 = new_s->length;
    new_s->ptr[v4] = s->ptr[beg + i];
    new_s->length = v4 + 1;
    new_s->ptr[new_s->length] = 0;
  }
  return new_s;
}

//----- (080B1BC2) --------------------------------------------------------
void __cdecl Strlower(Str s)
{
  char v1; // al
  int i; // [esp+Ch] [ebp-4h]

  for ( i = 0; s->length > i; ++i )
  {
    if ( (MYCTYPE_MAP[(unsigned __int8)s->ptr[i]] & 4) != 0 )
      v1 = s->ptr[i] | 0x20;
    else
      v1 = s->ptr[i];
    s->ptr[i] = v1;
  }
}

//----- (080B1C31) --------------------------------------------------------
void __cdecl Strupper(Str s)
{
  char v1; // al
  int i; // [esp+Ch] [ebp-4h]

  for ( i = 0; s->length > i; ++i )
  {
    if ( (MYCTYPE_MAP[(unsigned __int8)s->ptr[i]] & 4) != 0 )
      v1 = s->ptr[i] & 0xDF;
    else
      v1 = s->ptr[i];
    s->ptr[i] = v1;
  }
}

//----- (080B1CA0) --------------------------------------------------------
void __cdecl Strchop(Str s)
{
  while ( (s->ptr[s->length - 1] == 10 || s->ptr[s->length - 1] == 13) && s->length > 0 )
    --s->length;
  s->ptr[s->length] = 0;
}

//----- (080B1D01) --------------------------------------------------------
void __cdecl Strinsert_char(Str s, int pos, char c)
{
  char *v3; // edx
  int i; // [esp+2Ch] [ebp-Ch]

  if ( pos >= 0 && s->length >= pos )
  {
    if ( s->length + 2 > s->area_size )
      Strgrow(s);
    for ( i = s->length; i > pos; --i )
      s->ptr[i] = s->ptr[i - 1];
    v3 = s->ptr;
    v3[++s->length] = 0;
    s->ptr[pos] = c;
  }
}

//----- (080B1DAF) --------------------------------------------------------
void __cdecl Strinsert_charp(Str s, int pos, char *p)
{
  char v3; // dl
  int v4; // eax

  while ( *p )
  {
    v3 = *p++;
    v4 = pos++;
    Strinsert_char(s, v4, v3);
  }
}

//----- (080B1DEA) --------------------------------------------------------
void __cdecl Strdelete(Str s, int pos, int n)
{
  int i; // [esp+Ch] [ebp-8h]

  if ( s->length > pos + n )
  {
    for ( i = pos; s->length - n > i; ++i )
      s->ptr[i] = s->ptr[i + n];
    s->ptr[i] = 0;
    s->length = i;
  }
  else
  {
    s->ptr[pos] = 0;
    s->length = pos;
  }
}

//----- (080B1E74) --------------------------------------------------------
void __cdecl Strtruncate(Str s, int pos)
{
  s->ptr[pos] = 0;
  s->length = pos;
}

//----- (080B1E90) --------------------------------------------------------
void __cdecl Strshrink(Str s, int n)
{
  if ( s->length > n )
  {
    s->length -= n;
    s->ptr[s->length] = 0;
  }
  else
  {
    s->length = 0;
    *s->ptr = 0;
  }
}

//----- (080B1ED6) --------------------------------------------------------
void __cdecl Strremovefirstspaces(Str s)
{
  int i; // [esp+18h] [ebp-4h]

  for ( i = 0; s->length > i && (MYCTYPE_MAP[(unsigned __int8)s->ptr[i]] & 2) != 0; ++i )
    ;
  if ( i )
    Strdelete(s, 0, i);
}

//----- (080B1F3B) --------------------------------------------------------
void __cdecl Strremovetrailingspaces(Str s)
{
  int i; // [esp+Ch] [ebp-4h]

  for ( i = s->length - 1; i >= 0 && (MYCTYPE_MAP[(unsigned __int8)s->ptr[i]] & 2) != 0; --i )
    ;
  s->length = i + 1;
  s->ptr[i + 1] = 0;
}

//----- (080B1F99) --------------------------------------------------------
Str __cdecl Stralign_left(Str s, int width)
{
  int v3; // eax
  int i; // [esp+18h] [ebp-10h]
  Str n; // [esp+1Ch] [ebp-Ch]

  if ( s->length >= width )
    return Strdup(s);
  n = Strnew_size(width);
  Strcopy(n, s);
  for ( i = s->length; i < width; ++i )
  {
    if ( n->length + 1 >= n->area_size )
      Strgrow(n);
    v3 = n->length;
    n->ptr[v3] = 32;
    n->length = v3 + 1;
    n->ptr[n->length] = 0;
  }
  return n;
}

//----- (080B2041) --------------------------------------------------------
Str __cdecl Stralign_right(Str s, int width)
{
  int v3; // eax
  int i; // [esp+18h] [ebp-10h]
  Str n; // [esp+1Ch] [ebp-Ch]

  if ( s->length >= width )
    return Strdup(s);
  n = Strnew_size(width);
  for ( i = s->length; i < width; ++i )
  {
    if ( n->length + 1 >= n->area_size )
      Strgrow(n);
    v3 = n->length;
    n->ptr[v3] = 32;
    n->length = v3 + 1;
    n->ptr[n->length] = 0;
  }
  savexmlstr_0(n, s);
  return n;
}

//----- (080B20E9) --------------------------------------------------------
Str __cdecl Stralign_center(Str s, int width)
{
  int v3; // eax
  int v4; // eax
  int w; // [esp+14h] [ebp-14h]
  int i; // [esp+18h] [ebp-10h]
  int ia; // [esp+18h] [ebp-10h]
  Str n; // [esp+1Ch] [ebp-Ch]

  if ( s->length >= width )
    return Strdup(s);
  n = Strnew_size(width);
  w = (width - s->length) / 2;
  for ( i = 0; i < w; ++i )
  {
    if ( n->length + 1 >= n->area_size )
      Strgrow(n);
    v3 = n->length;
    n->ptr[v3] = 32;
    n->length = v3 + 1;
    n->ptr[n->length] = 0;
  }
  savexmlstr_0(n, s);
  for ( ia = w + s->length; ia < width; ++ia )
  {
    if ( n->length + 1 >= n->area_size )
      Strgrow(n);
    v4 = n->length;
    n->ptr[v4] = 32;
    n->length = v4 + 1;
    n->ptr[n->length] = 0;
  }
  return n;
}

//----- (080B2210) --------------------------------------------------------
Str Sprintf(char *fmt, ...)
{
  int v1; // eax
  int v2; // eax
  const char **v3; // eax
  int v4; // eax
  int vi; // [esp+24h] [ebp-24h]
  va_list ap; // [esp+28h] [ebp-20h]
  Str s; // [esp+2Ch] [ebp-1Ch]
  char *f; // [esp+30h] [ebp-18h]
  int p; // [esp+34h] [ebp-14h]
  int status; // [esp+38h] [ebp-10h]
  int len; // [esp+3Ch] [ebp-Ch]
  va_list va; // [esp+54h] [ebp+Ch] BYREF

  va_start(va, fmt);
  len = 0;
  status = 0;
  p = 0;
  va_copy(ap, va);
  for ( f = fmt; *f; ++f )
  {
    while ( status != 1 )
    {
      if ( status != 2 )
      {
        if ( *f == 37 )
        {
          status = 1;
          p = 0;
        }
        else
        {
          ++len;
        }
        goto LABEL_32;
      }
      if ( (MYCTYPE_MAP[(unsigned __int8)*f] & 4) == 0 )
        goto LABEL_32;
      status = 1;
    }
    if ( (MYCTYPE_MAP[(unsigned __int8)*f] & 4) != 0 )
    {
      switch ( *f )
      {
        case 'E':
        case 'G':
        case 'e':
        case 'f':
        case 'g':
          ap += 8;
          if ( p <= 0 )
            v2 = 15;
          else
            v2 = p;
          len += v2;
          goto LABEL_23;
        case 'L':
        case 'h':
        case 'l':
        case 'w':
          continue;
        case 'X':
        case 'd':
        case 'i':
        case 'o':
        case 'u':
        case 'x':
          ap += 4;
          if ( p <= 0 )
            v1 = 10;
          else
            v1 = p;
          len += v1;
          goto LABEL_23;
        case 'c':
          ++len;
          ap += 4;
          goto LABEL_23;
        case 'n':
          ap += 4;
          goto LABEL_23;
        case 'p':
          ap += 4;
          len += 10;
          goto LABEL_23;
        case 's':
          v3 = (const char **)ap;
          ap += 4;
          vi = strlen(*v3);
          v4 = p;
          if ( vi >= p )
            v4 = vi;
          len += v4;
          goto LABEL_23;
        default:
LABEL_23:
          status = 0;
          break;
      }
    }
    else if ( (MYCTYPE_MAP[(unsigned __int8)*f] & 8) != 0 )
    {
      p = 10 * p + *f - 48;
    }
    else if ( *f == 46 )
    {
      status = 2;
    }
    else if ( *f == 37 )
    {
      status = 0;
      ++len;
    }
LABEL_32:
    ;
  }
  s = Strnew_size(2 * len);
  vsprintf(s->ptr, fmt, va);
  s->length = strlen(s->ptr);
  if ( s->length > 2 * len )
  {
    fwrite("Sprintf: string too long\n", 1u, 0x19u, stderr);
    exit(1);
  }
  return s;
}
// 80B224F: conditional instruction was optimized away because of '%status.4==0'

//----- (080B249D) --------------------------------------------------------
Str __cdecl Strfgets(FILE *f)
{
  int v1; // eax
  Str s; // [esp+18h] [ebp-10h]
  char c; // [esp+1Fh] [ebp-9h]

  s = Strnew();
  do
  {
    c = fgetc(f);
    if ( feof(f) || ferror(f) )
      break;
    if ( s->length + 1 >= s->area_size )
      Strgrow(s);
    v1 = s->length;
    s->ptr[v1] = c;
    s->length = v1 + 1;
    s->ptr[s->length] = 0;
  }
  while ( c != 10 );
  return s;
}

//----- (080B2533) --------------------------------------------------------
Str __cdecl Strfgetall(FILE *f)
{
  int v1; // eax
  Str s; // [esp+18h] [ebp-10h]
  char c; // [esp+1Fh] [ebp-9h]

  for ( s = Strnew(); ; s->ptr[s->length] = 0 )
  {
    c = fgetc(f);
    if ( feof(f) || ferror(f) )
      break;
    if ( s->length + 1 >= s->area_size )
      Strgrow(s);
    v1 = s->length;
    s->ptr[v1] = c;
    s->length = v1 + 1;
  }
  return s;
}

//----- (080B25C4) --------------------------------------------------------
clen_t __cdecl strtoclen(const char *s)
{
  return strtoll(s, 0, 10);
}

//----- (080B25E7) --------------------------------------------------------
char *__cdecl allocStr(const char *s, int len)
{
  char *ptr; // [esp+1Ch] [ebp-Ch]

  if ( !s )
    return 0;
  if ( len < 0 )
    len = strlen(s);
  ptr = (char *)GC_malloc_atomic(len + 1);
  if ( !ptr )
  {
    fwrite("fm: Can't allocate string. Give me more memory!\n", 1u, 0x30u, stderr);
    exit(-1);
  }
  bcopy(s, ptr, len);
  ptr[len] = 0;
  return ptr;
}
// 804A51C: using guessed type int __cdecl GC_malloc_atomic(_DWORD);

//----- (080B2683) --------------------------------------------------------
int __cdecl strCmp(const void *s1, const void *s2)
{
  return strcmp(*(const char **)s1, *(const char **)s2);
}

//----- (080B26A1) --------------------------------------------------------
char *currentdir()
{
  char *path; // [esp+1Ch] [ebp-Ch]

  path = (char *)GC_malloc_atomic(4096);
  getcwd(path, 0x1000u);
  return path;
}
// 804A51C: using guessed type int __cdecl GC_malloc_atomic(_DWORD);

//----- (080B26CE) --------------------------------------------------------
char *__cdecl cleanupName(char *name)
{
  const char *q; // [esp+14h] [ebp-14h]
  char *p; // [esp+18h] [ebp-10h]
  char *buf; // [esp+1Ch] [ebp-Ch]

  buf = allocStr(name, -1);
  p = buf;
  q = name;
  while ( *q )
  {
    if ( !strncmp(p, "/../", 4u) )
    {
      if ( p - 2 == buf && !strncmp(p - 2, "..", 2u) )
      {
        p += 3;
        q += 3;
      }
      else if ( p - 3 >= buf && !strncmp(p - 3, "/..", 3u) )
      {
        p += 3;
        q += 3;
      }
      else
      {
        do
        {
          if ( p == buf )
            break;
          --p;
        }
        while ( *p != 47 );
        *p = 0;
        q += 3;
        strcat(buf, q);
      }
    }
    else
    {
      if ( !strcmp(p, "/..") )
      {
        if ( (p - 2 != buf || strncmp(p - 2, "..", 2u)) && (p - 3 < buf || strncmp(p - 3, "/..", 3u)) )
        {
          do
          {
            if ( p == buf )
              break;
            --p;
          }
          while ( *p != 47 );
          p[1] = 0;
        }
        return buf;
      }
      if ( !strncmp(p, "/./", 3u) )
      {
        *p = 0;
        q += 2;
        strcat(buf, q);
      }
      else
      {
        if ( !strcmp(p, "/.") )
        {
          p[1] = 0;
          return buf;
        }
        if ( !strncmp(p, "//", 2u) )
        {
          *p = 0;
          strcat(buf, ++q);
        }
        else
        {
          ++p;
          ++q;
        }
      }
    }
  }
  return buf;
}

//----- (080B2925) --------------------------------------------------------
char *__cdecl expandPath(char *name)
{
  char *v2; // eax
  char *v3; // eax
  char *q; // [esp+10h] [ebp-18h]
  _Str *extpath; // [esp+14h] [ebp-14h]
  passwd *passent; // [esp+18h] [ebp-10h]
  char *p; // [esp+1Ch] [ebp-Ch]

  if ( !name )
    return 0;
  if ( *name != 126 )
    return name;
  p = name + 1;
  if ( (MYCTYPE_MAP[(unsigned __int8)name[1]] & 4) == 0 )
  {
    if ( *p == 47 || !*p )
    {
      v3 = getenv("HOME");
      extpath = Strnew_charp(v3);
      goto LABEL_13;
    }
    return name;
  }
  q = strchr(p, 47);
  if ( q )
  {
    v2 = allocStr(p, q - p);
    passent = getpwnam(v2);
    p = q;
  }
  else
  {
    passent = getpwnam(p);
    p = (char *)&unk_80D19D7;
  }
  if ( !passent )
    return name;
  extpath = Strnew_charp(passent->pw_dir);
LABEL_13:
  if ( !strcmp(extpath->ptr, "/") && *p == 47 )
    ++p;
  Strcat_charp(extpath, p);
  return extpath->ptr;
}

//----- (080B2A5D) --------------------------------------------------------
int __cdecl strcasematch(char *s1, char *s2)
{
  char v3; // al
  int v4; // edx
  int v5; // eax

  while ( *s1 )
  {
    if ( !*s2 )
      return 1;
    v3 = (MYCTYPE_MAP[(unsigned __int8)*s1] & 4) != 0 ? *s1 | 0x20 : *s1;
    v4 = v3;
    v5 = (MYCTYPE_MAP[(unsigned __int8)*s2] & 4) != 0 ? *s2 | 0x20 : *s2;
    if ( v4 != v5 )
      break;
    ++s1;
    ++s2;
  }
  return *s2 == 0;
}

//----- (080B2B16) --------------------------------------------------------
int __cdecl strcasemstr(char *str, char **srch, char **ret_ptr)
{
  int i; // [esp+14h] [ebp-4h]

LABEL_10:
  if ( !*str )
    return -1;
  for ( i = 0; ; ++i )
  {
    if ( !srch[i] )
    {
      ++str;
      goto LABEL_10;
    }
    if ( strcasematch(str, srch[i]) )
      break;
  }
  if ( ret_ptr )
    *ret_ptr = str;
  return i;
}

//----- (080B2B80) --------------------------------------------------------
char *__cdecl remove_space(char *str)
{
  char *result; // eax
  char *q; // [esp+18h] [ebp-10h]

  while ( *str && (MYCTYPE_MAP[(unsigned __int8)*str] & 2) != 0 )
    ++str;
  for ( q = str; *q; ++q )
    ;
  while ( q > str && (MYCTYPE_MAP[(unsigned __int8)*(q - 1)] & 2) != 0 )
    --q;
  if ( *q )
    result = Strnew_charp_n(str, q - str)->ptr;
  else
    result = str;
  return result;
}

//----- (080B2C25) --------------------------------------------------------
int __cdecl non_null(char *s)
{
  if ( !s )
    return 0;
  while ( *s )
  {
    if ( (MYCTYPE_MAP[(unsigned __int8)*s] & 2) == 0 )
      return 1;
    ++s;
  }
  return 0;
}

//----- (080B2C6E) --------------------------------------------------------
void __cdecl cleanup_line(Str s, int mode)
{
  int v2; // eax
  int v3; // eax
  int i; // [esp+1Ch] [ebp-Ch]

  if ( s->length > 1 && s->ptr[s->length - 2] == 13 && s->ptr[s->length - 1] == 10 )
  {
    Strshrink(s, 2);
    if ( s->length + 1 >= s->area_size )
      Strgrow(s);
    v2 = s->length;
    s->ptr[v2] = 10;
    s->length = v2 + 1;
    s->ptr[s->length] = 0;
  }
  else if ( s->length > 0 && s->ptr[s->length - 1] == 13 )
  {
    s->ptr[s->length - 1] = 10;
  }
  else if ( s->length <= 0 || s->ptr[s->length - 1] != 10 )
  {
    if ( s->length + 1 >= s->area_size )
      Strgrow(s);
    v3 = s->length;
    s->ptr[v3] = 10;
    s->length = v3 + 1;
    s->ptr[s->length] = 0;
  }
  if ( mode != 1 )
  {
    for ( i = 0; s->length > i; ++i )
    {
      if ( !s->ptr[i] )
        s->ptr[i] = 32;
    }
  }
}

//----- (080B2DFB) --------------------------------------------------------
int __cdecl getescapechar(char **str)
{
  int result; // eax
  int strict_entity; // [esp+10h] [ebp-18h]
  char *q; // [esp+14h] [ebp-14h]
  char *qa; // [esp+14h] [ebp-14h]
  char *p; // [esp+18h] [ebp-10h]
  char *pa; // [esp+18h] [ebp-10h]
  char *pb; // [esp+18h] [ebp-10h]
  char *pc; // [esp+18h] [ebp-10h]
  char *pd; // [esp+18h] [ebp-10h]
  char *pe; // [esp+18h] [ebp-10h]
  int dummy; // [esp+1Ch] [ebp-Ch]
  int dummya; // [esp+1Ch] [ebp-Ch]

  p = *str;
  strict_entity = 1;
  if ( **str == 38 )
    ++p;
  if ( *p == 35 )
  {
    pa = p + 1;
    if ( *pa == 120 || *pa == 88 )
    {
      pb = pa + 1;
      if ( (MYCTYPE_MAP[(unsigned __int8)*pb] & 0x28) != 0 )
      {
        dummy = MYCTYPE_DIGITMAP[(unsigned __int8)*pb];
        for ( pc = pb + 1; (MYCTYPE_MAP[(unsigned __int8)*pc] & 0x28) != 0; ++pc )
          dummy = 16 * dummy + MYCTYPE_DIGITMAP[(unsigned __int8)*pc];
        if ( *pc == 59 )
          ++pc;
        *str = pc;
        result = dummy;
      }
      else
      {
        *str = pb;
        result = -1;
      }
    }
    else if ( (MYCTYPE_MAP[(unsigned __int8)*pa] & 8) != 0 )
    {
      dummya = MYCTYPE_DIGITMAP[(unsigned __int8)*pa];
      for ( pd = pa + 1; (MYCTYPE_MAP[(unsigned __int8)*pd] & 8) != 0; ++pd )
        dummya = 10 * dummya + MYCTYPE_DIGITMAP[(unsigned __int8)*pd];
      if ( *pd == 59 )
        ++pd;
      *str = pd;
      result = dummya;
    }
    else
    {
      *str = pa;
      result = -1;
    }
  }
  else
  {
    if ( (MYCTYPE_MAP[(unsigned __int8)*p] & 4) == 0 )
    {
      *str = p;
      return -1;
    }
    q = p;
    for ( pe = p + 1; (MYCTYPE_MAP[(unsigned __int8)*pe] & 0xC) != 0; ++pe )
      ;
    qa = allocStr(q, pe - q);
    if ( strcasestr("lt gt amp quot nbsp", qa) && *pe != 61 )
      strict_entity = 0;
    if ( *pe == 59 )
    {
      ++pe;
    }
    else if ( strict_entity )
    {
      *str = pe;
      return -1;
    }
    *str = pe;
    result = getHash_si(&entity, qa, -1);
  }
  return result;
}
// 804A36C: using guessed type int __cdecl strcasestr(_DWORD, _DWORD);

//----- (080B3089) --------------------------------------------------------
char *__cdecl getescapecmd(char **s)
{
  signed int ch_0; // [esp+14h] [ebp-14h]
  _Str *tmp; // [esp+18h] [ebp-10h]
  char *save; // [esp+1Ch] [ebp-Ch]

  save = *s;
  ch_0 = getescapechar(s);
  if ( ch_0 >= 0 )
    return conv_entity(ch_0);
  if ( *save == 38 )
    tmp = Strnew();
  else
    tmp = Strnew_charp("&");
  Strcat_charp_n(tmp, save, *s - save);
  return tmp->ptr;
}

//----- (080B3108) --------------------------------------------------------
char *__cdecl html_quote(char *str)
{
  int v1; // eax
  char *result; // eax
  char *q; // [esp+14h] [ebp-14h]
  char *p; // [esp+18h] [ebp-10h]
  Str tmp; // [esp+1Ch] [ebp-Ch]

  tmp = 0;
  for ( p = str; *p; ++p )
  {
    q = HTML_QUOTE_MAP[QUOTE_MAP[(unsigned __int8)*p] & 7];
    if ( q )
    {
      if ( !tmp )
        tmp = Strnew_charp_n(str, p - str);
      Strcat_charp(tmp, q);
    }
    else if ( tmp )
    {
      if ( tmp->length + 1 >= tmp->area_size )
        Strgrow(tmp);
      v1 = tmp->length;
      tmp->ptr[v1] = *p;
      tmp->length = v1 + 1;
      tmp->ptr[tmp->length] = 0;
    }
  }
  if ( tmp )
    result = tmp->ptr;
  else
    result = str;
  return result;
}

//----- (080B31F7) --------------------------------------------------------
char *__cdecl html_unquote(char *str)
{
  int v1; // eax
  char *result; // eax
  char *q; // [esp+14h] [ebp-14h]
  char *p; // [esp+18h] [ebp-10h] BYREF
  Str tmp; // [esp+1Ch] [ebp-Ch]

  tmp = 0;
  p = str;
  while ( *p )
  {
    if ( *p == 38 )
    {
      if ( !tmp )
        tmp = Strnew_charp_n(str, p - str);
      q = getescapecmd(&p);
      Strcat_charp(tmp, q);
    }
    else
    {
      if ( tmp )
      {
        if ( tmp->length + 1 >= tmp->area_size )
          Strgrow(tmp);
        v1 = tmp->length;
        tmp->ptr[v1] = *p;
        tmp->length = v1 + 1;
        tmp->ptr[tmp->length] = 0;
      }
      ++p;
    }
  }
  if ( tmp )
    result = tmp->ptr;
  else
    result = str;
  return result;
}

//----- (080B32DF) --------------------------------------------------------
char *__cdecl url_quote(char *str)
{
  int v1; // eax
  int v2; // eax
  int v3; // eax
  int v4; // eax
  char *result; // eax
  char *p; // [esp+18h] [ebp-10h]
  Str tmp; // [esp+1Ch] [ebp-Ch]

  tmp = 0;
  for ( p = str; *p; ++p )
  {
    if ( (QUOTE_MAP[(unsigned __int8)*p] & 0x10) != 0 )
    {
      if ( !tmp )
        tmp = Strnew_charp_n(str, p - str);
      if ( tmp->length + 1 >= tmp->area_size )
        Strgrow(tmp);
      v1 = tmp->length;
      tmp->ptr[v1] = 37;
      tmp->length = v1 + 1;
      tmp->ptr[tmp->length] = 0;
      if ( tmp->length + 1 >= tmp->area_size )
        Strgrow(tmp);
      v2 = tmp->length;
      tmp->ptr[v2] = xdigit[(unsigned __int8)*p >> 4];
      tmp->length = v2 + 1;
      tmp->ptr[tmp->length] = 0;
      if ( tmp->length + 1 >= tmp->area_size )
        Strgrow(tmp);
      v3 = tmp->length;
      tmp->ptr[v3] = xdigit[*p & 0xF];
      tmp->length = v3 + 1;
      tmp->ptr[tmp->length] = 0;
    }
    else if ( tmp )
    {
      if ( tmp->length + 1 >= tmp->area_size )
        Strgrow(tmp);
      v4 = tmp->length;
      tmp->ptr[v4] = *p;
      tmp->length = v4 + 1;
      tmp->ptr[tmp->length] = 0;
    }
  }
  if ( tmp )
    result = tmp->ptr;
  else
    result = str;
  return result;
}

//----- (080B34B7) --------------------------------------------------------
char *__cdecl file_quote(char *str)
{
  int v1; // eax
  char *result; // eax
  char buf[4]; // [esp+14h] [ebp-14h] BYREF
  char *p; // [esp+18h] [ebp-10h]
  Str tmp; // [esp+1Ch] [ebp-Ch]

  tmp = 0;
  for ( p = str; *p; ++p )
  {
    if ( (QUOTE_MAP[(unsigned __int8)*p] & 0x30) != 0 )
    {
      if ( !tmp )
        tmp = Strnew_charp_n(str, p - str);
      sprintf(buf, "%%%02X", (unsigned __int8)*p);
      Strcat_charp(tmp, buf);
    }
    else if ( tmp )
    {
      if ( tmp->length + 1 >= tmp->area_size )
        Strgrow(tmp);
      v1 = tmp->length;
      tmp->ptr[v1] = *p;
      tmp->length = v1 + 1;
      tmp->ptr[tmp->length] = 0;
    }
  }
  if ( tmp )
    result = tmp->ptr;
  else
    result = str;
  return result;
}

//----- (080B35BB) --------------------------------------------------------
char *__cdecl file_unquote(char *str)
{
  int v1; // eax
  int v2; // eax
  int v3; // eax
  char *result; // eax
  int c; // [esp+10h] [ebp-18h]
  char *q; // [esp+14h] [ebp-14h]
  char *p; // [esp+18h] [ebp-10h]
  Str tmp; // [esp+1Ch] [ebp-Ch]

  tmp = 0;
  p = str;
  while ( *p )
  {
    if ( *p == 37
      && ((q = p, (MYCTYPE_MAP[(unsigned __int8)p[1]] & 0x28) == 0) || (MYCTYPE_MAP[(unsigned __int8)p[2]] & 0x28) == 0 ? (v1 = -1) : (q = p + 3, v1 = (16 * MYCTYPE_DIGITMAP[(unsigned __int8)p[1]]) | MYCTYPE_DIGITMAP[(unsigned __int8)p[2]]),
          c = v1,
          v1 >= 0) )
    {
      if ( !tmp )
        tmp = Strnew_charp_n(str, p - str);
      if ( c && c != 10 && c != 13 )
      {
        if ( tmp->length + 1 >= tmp->area_size )
          Strgrow(tmp);
        v2 = tmp->length;
        tmp->ptr[v2] = c;
        tmp->length = v2 + 1;
        tmp->ptr[tmp->length] = 0;
      }
      p = q;
    }
    else
    {
      if ( tmp )
      {
        if ( tmp->length + 1 >= tmp->area_size )
          Strgrow(tmp);
        v3 = tmp->length;
        tmp->ptr[v3] = *p;
        tmp->length = v3 + 1;
        tmp->ptr[tmp->length] = 0;
      }
      ++p;
    }
  }
  if ( tmp )
    result = tmp->ptr;
  else
    result = str;
  return result;
}

//----- (080B3774) --------------------------------------------------------
Str __cdecl Str_form_quote(Str x)
{
  int v1; // eax
  int v2; // eax
  Str result; // eax
  char buf[4]; // [esp+10h] [ebp-18h] BYREF
  char *ep; // [esp+14h] [ebp-14h]
  char *p; // [esp+18h] [ebp-10h]
  Str tmp; // [esp+1Ch] [ebp-Ch]

  tmp = 0;
  p = x->ptr;
  ep = &x->ptr[x->length];
  while ( p < ep )
  {
    if ( *p == 32 )
    {
      if ( !tmp )
        tmp = Strnew_charp_n(x->ptr, p - x->ptr);
      if ( tmp->length + 1 >= tmp->area_size )
        Strgrow(tmp);
      v1 = tmp->length;
      tmp->ptr[v1] = 43;
      tmp->length = v1 + 1;
      tmp->ptr[tmp->length] = 0;
    }
    else if ( (QUOTE_MAP[(unsigned __int8)*p] & 0x70) != 0 )
    {
      if ( !tmp )
        tmp = Strnew_charp_n(x->ptr, p - x->ptr);
      sprintf(buf, "%%%02X", (unsigned __int8)*p);
      Strcat_charp(tmp, buf);
    }
    else if ( tmp )
    {
      if ( tmp->length + 1 >= tmp->area_size )
        Strgrow(tmp);
      v2 = tmp->length;
      tmp->ptr[v2] = *p;
      tmp->length = v2 + 1;
      tmp->ptr[tmp->length] = 0;
    }
    ++p;
  }
  if ( tmp )
    result = tmp;
  else
    result = x;
  return result;
}

//----- (080B3905) --------------------------------------------------------
Str __cdecl Str_url_unquote(Str x, int is_form, int safe)
{
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  Str result; // eax
  char c; // [esp+1Ch] [ebp-1Ch]
  char *q; // [esp+20h] [ebp-18h]
  char *ep; // [esp+24h] [ebp-14h]
  char *p; // [esp+28h] [ebp-10h]
  Str tmp; // [esp+2Ch] [ebp-Ch]

  tmp = 0;
  p = x->ptr;
  ep = &x->ptr[x->length];
  while ( p < ep )
  {
    if ( is_form && *p == 43 )
    {
      if ( !tmp )
        tmp = Strnew_charp_n(x->ptr, p - x->ptr);
      if ( tmp->length + 1 >= tmp->area_size )
        Strgrow(tmp);
      v3 = tmp->length;
      tmp->ptr[v3] = 32;
      tmp->length = v3 + 1;
      tmp->ptr[tmp->length] = 0;
      ++p;
    }
    else if ( *p != 37
           || ((q = p, (MYCTYPE_MAP[(unsigned __int8)p[1]] & 0x28) == 0)
            || (MYCTYPE_MAP[(unsigned __int8)p[2]] & 0x28) == 0 ? (v4 = -1) : (q = p + 3,
                                                                               v4 = (16
                                                                                   * MYCTYPE_DIGITMAP[(unsigned __int8)p[1]]) | MYCTYPE_DIGITMAP[(unsigned __int8)p[2]]),
               (c = v4, v4 < 0)
            || safe && (MYCTYPE_MAP[(unsigned __int8)v4] & 0x11) != 0 && (QUOTE_MAP[(unsigned __int8)v4] & 0x30) != 0) )
    {
      if ( tmp )
      {
        if ( tmp->length + 1 >= tmp->area_size )
          Strgrow(tmp);
        v6 = tmp->length;
        tmp->ptr[v6] = *p;
        tmp->length = v6 + 1;
        tmp->ptr[tmp->length] = 0;
      }
      ++p;
    }
    else
    {
      if ( !tmp )
        tmp = Strnew_charp_n(x->ptr, p - x->ptr);
      if ( tmp->length + 1 >= tmp->area_size )
        Strgrow(tmp);
      v5 = tmp->length;
      tmp->ptr[v5] = c;
      tmp->length = v5 + 1;
      tmp->ptr[tmp->length] = 0;
      p = q;
    }
  }
  if ( tmp )
    result = tmp;
  else
    result = x;
  return result;
}

//----- (080B3B7B) --------------------------------------------------------
char *__cdecl shell_quote(char *str)
{
  int v1; // eax
  int v2; // eax
  int v3; // eax
  char *result; // eax
  char *p; // [esp+18h] [ebp-10h]
  Str tmp; // [esp+1Ch] [ebp-Ch]

  tmp = 0;
  for ( p = str; *p; ++p )
  {
    if ( (QUOTE_MAP[(unsigned __int8)*p] & 8) != 0 )
    {
      if ( !tmp )
        tmp = Strnew_charp_n(str, p - str);
      if ( tmp->length + 1 >= tmp->area_size )
        Strgrow(tmp);
      v1 = tmp->length;
      tmp->ptr[v1] = 92;
      tmp->length = v1 + 1;
      tmp->ptr[tmp->length] = 0;
      if ( tmp->length + 1 >= tmp->area_size )
        Strgrow(tmp);
      v2 = tmp->length;
      tmp->ptr[v2] = *p;
      tmp->length = v2 + 1;
      tmp->ptr[tmp->length] = 0;
    }
    else if ( tmp )
    {
      if ( tmp->length + 1 >= tmp->area_size )
        Strgrow(tmp);
      v3 = tmp->length;
      tmp->ptr[v3] = *p;
      tmp->length = v3 + 1;
      tmp->ptr[tmp->length] = 0;
    }
  }
  if ( tmp )
    result = tmp->ptr;
  else
    result = str;
  return result;
}

//----- (080B3CEA) --------------------------------------------------------
char *__cdecl w3m_dir(const char *name, char *dft)
{
  return dft;
}

//----- (080B3CF2) --------------------------------------------------------
char *w3m_auxbin_dir()
{
  return w3m_dir("W3M_AUXBIN_DIR", "/usr/lib/w3m");
}

//----- (080B3D0E) --------------------------------------------------------
char *w3m_lib_dir()
{
  return w3m_dir("W3M_LIB_DIR", "/usr/lib/w3m/cgi-bin");
}

//----- (080B3D2A) --------------------------------------------------------
char *w3m_etc_dir()
{
  return w3m_dir("W3M_ETC_DIR", "/etc");
}

//----- (080B3D46) --------------------------------------------------------
char *w3m_conf_dir()
{
  return w3m_dir("W3M_CONF_DIR", "/etc/w3m");
}

//----- (080B3D62) --------------------------------------------------------
char *w3m_help_dir()
{
  return w3m_dir("W3M_HELP_DIR", "/usr/share/w3m");
}

//----- (080B3D80) --------------------------------------------------------
ListItem *__cdecl newListItem(void *s, ListItem *n, ListItem *p)
{
  ListItem *result; // eax

  result = (ListItem *)GC_malloc(12);
  result->ptr = s;
  result->next = n;
  result->prev = p;
  return result;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (080B3DB4) --------------------------------------------------------
GeneralList *newGeneralList()
{
  GeneralList *result; // eax

  result = (GeneralList *)GC_malloc(12);
  result->last = 0;
  result->first = result->last;
  result->nitem = 0;
  return result;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (080B3DEC) --------------------------------------------------------
void __cdecl pushValue(GeneralList *tl, void *s)
{
  ListItem *it; // [esp+1Ch] [ebp-Ch]

  if ( s )
  {
    it = newListItem(s, 0, tl->last);
    if ( tl->first )
    {
      tl->last->next = it;
      tl->last = it;
      ++tl->nitem;
    }
    else
    {
      tl->first = it;
      tl->last = it;
      tl->nitem = 1;
    }
  }
}

//----- (080B3E68) --------------------------------------------------------
void *__cdecl popValue(GeneralList *tl)
{
  ListItem *f; // [esp+Ch] [ebp-4h]

  if ( !tl || !tl->first )
    return 0;
  f = tl->first;
  tl->first = tl->first->next;
  if ( tl->first )
    tl->first->prev = 0;
  else
    tl->last = 0;
  --tl->nitem;
  return f->ptr;
}

//----- (080B3ED0) --------------------------------------------------------
void *__cdecl rpopValue(GeneralList *tl)
{
  ListItem *f; // [esp+Ch] [ebp-4h]

  if ( !tl || !tl->last )
    return 0;
  f = tl->last;
  tl->last = f->prev;
  if ( tl->last )
    tl->last->next = 0;
  else
    tl->first = 0;
  --tl->nitem;
  return f->ptr;
}

//----- (080B3F3C) --------------------------------------------------------
void __cdecl delValue(GeneralList *tl, ListItem *it)
{
  if ( it->prev )
    it->prev->next = it->next;
  else
    tl->first = it->next;
  if ( it->next )
    it->next->prev = it->prev;
  else
    tl->last = it->prev;
  --tl->nitem;
}

//----- (080B3F9F) --------------------------------------------------------
GeneralList *__cdecl appendGeneralList(GeneralList *tl, GeneralList *tl2)
{
  __int16 v2; // dx

  if ( tl && tl2 )
  {
    if ( tl2->first )
    {
      if ( tl->last )
      {
        tl->last->next = tl2->first;
        tl2->first->prev = tl->last;
        tl->last = tl2->last;
        v2 = tl->nitem + tl2->nitem;
      }
      else
      {
        tl->first = tl2->first;
        tl->last = tl2->last;
        v2 = tl2->nitem;
      }
      tl->nitem = v2;
    }
    tl2->last = 0;
    tl2->first = tl2->last;
    tl2->nitem = 0;
  }
  return tl;
}

//----- (080B4056) --------------------------------------------------------
TextLine *__cdecl newTextLine(Str line, int pos)
{
  TextLine *lbuf; // [esp+1Ch] [ebp-Ch]

  lbuf = (TextLine *)GC_malloc(8);
  if ( line )
    lbuf->line = line;
  else
    lbuf->line = Strnew();
  lbuf->pos = pos;
  return lbuf;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (080B4096) --------------------------------------------------------
void __cdecl appendTextLine(TextLineList *tl, Str line, int pos)
{
  _Str *v3; // eax
  TextLine *v4; // eax
  TextLine *lbuf; // [esp+1Ch] [ebp-Ch]

  if ( tl->last )
  {
    lbuf = tl->last->ptr;
    if ( lbuf->line )
      savexmlstr_0(lbuf->line, line);
    else
      lbuf->line = line;
    lbuf->pos += pos;
  }
  else
  {
    v3 = Strdup(line);
    v4 = newTextLine(v3, pos);
    pushValue((GeneralList *)tl, v4);
  }
}

//----- (080B4120) --------------------------------------------------------
char *__cdecl tag_get_value(parsed_tagarg *t, char *arg)
{
  while ( t )
  {
    if ( !strcasecmp(t->arg, arg) )
      return t->value;
    t = t->next;
  }
  return 0;
}

//----- (080B415E) --------------------------------------------------------
int __cdecl tag_exists(parsed_tagarg *t, char *arg)
{
  while ( t )
  {
    if ( !strcasecmp(t->arg, arg) )
      return 1;
    t = t->next;
  }
  return 0;
}

//----- (080B419B) --------------------------------------------------------
parsed_tagarg *__cdecl cgistr2tagarg(char *cgistr)
{
  int v1; // eax
  int v3; // eax
  parsed_tagarg *t; // [esp+10h] [ebp-18h]
  parsed_tagarg *t0; // [esp+14h] [ebp-14h]
  Str value; // [esp+18h] [ebp-10h]
  Str tag; // [esp+1Ch] [ebp-Ch]

  t0 = 0;
  do
  {
    t = (parsed_tagarg *)GC_malloc(12);
    t->next = t0;
    t0 = t;
    tag = Strnew();
    while ( *cgistr && *cgistr != 61 && *cgistr != 38 )
    {
      if ( tag->length + 1 >= tag->area_size )
        Strgrow(tag);
      v1 = tag->length;
      tag->ptr[v1] = *cgistr;
      tag->length = v1 + 1;
      ++cgistr;
      tag->ptr[tag->length] = 0;
    }
    t->arg = Str_url_unquote(tag, 1, 0)->ptr;
    t->value = 0;
    switch ( *cgistr )
    {
      case 0:
        return t;
      case 61:
        ++cgistr;
        value = Strnew();
        while ( *cgistr && *cgistr != 38 )
        {
          if ( value->length + 1 >= value->area_size )
            Strgrow(value);
          v3 = value->length;
          value->ptr[v3] = *cgistr;
          value->length = v3 + 1;
          ++cgistr;
          value->ptr[value->length] = 0;
        }
        t->value = Str_url_unquote(value, 1, 0)->ptr;
        break;
      case 38:
        ++cgistr;
        break;
    }
  }
  while ( *cgistr );
  return t;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (080B4350) --------------------------------------------------------
unsigned int __cdecl hashfunc(char *s)
{
  int h; // [esp+Ch] [ebp-4h]
  int ha; // [esp+Ch] [ebp-4h]

  h = 0;
  while ( *s )
  {
    if ( h >= 0 )
      ha = 2 * h;
    else
      ha = (2 * h) | 1;
    h = *s++ + ha;
  }
  return h;
}

//----- (080B4391) --------------------------------------------------------
Hash_si_0 *__cdecl newHash_si(int size)
{
  int i; // [esp+18h] [ebp-10h]
  Hash_si *hash; // [esp+1Ch] [ebp-Ch]

  hash = (Hash_si *)GC_malloc(8);
  hash->size = size;
  hash->tab = (HashItem_si **)GC_malloc(4 * size);
  for ( i = 0; i < size; ++i )
    hash->tab[i] = 0;
  return hash;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (080B43F2) --------------------------------------------------------
HashItem_si_0 *__cdecl lookupHash_si(Hash_si_0 *t, char *key, int *hashval_return)
{
  HashItem_si_0 *hi; // [esp+1Ch] [ebp-Ch]

  *hashval_return = hashfunc(key) % t->size;
  for ( hi = t->tab[*hashval_return]; hi; hi = hi->next )
  {
    if ( !strcmp(hi->key, key) )
      return hi;
  }
  return 0;
}

//----- (080B4465) --------------------------------------------------------
void __cdecl putHash_si(Hash_si_0 *t, char *key, int value)
{
  HashItem_si_0 *hi; // [esp+18h] [ebp-10h]
  HashItem_si_0 *hia; // [esp+18h] [ebp-10h]
  int h[3]; // [esp+1Ch] [ebp-Ch] BYREF

  hi = lookupHash_si(t, key, h);
  if ( hi )
  {
    hi->value = value;
  }
  else
  {
    hia = (HashItem_si_0 *)GC_malloc(12);
    hia->key = key;
    hia->value = value;
    hia->next = t->tab[h[0]];
    t->tab[h[0]] = hia;
  }
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (080B44E4) --------------------------------------------------------
int __cdecl getHash_si(Hash_si_0 *t, char *key, int failval)
{
  int result; // eax
  HashItem_si_0 *hi; // [esp+18h] [ebp-10h]
  int h[3]; // [esp+1Ch] [ebp-Ch] BYREF

  hi = lookupHash_si(t, key, h);
  if ( hi )
    result = hi->value;
  else
    result = failval;
  return result;
}

//----- (080B4519) --------------------------------------------------------
Hash_ss_0 *__cdecl newHash_ss(int size)
{
  int i; // [esp+18h] [ebp-10h]
  Hash_ss *hash; // [esp+1Ch] [ebp-Ch]

  hash = (Hash_ss *)GC_malloc(8);
  hash->size = size;
  hash->tab = (HashItem_ss **)GC_malloc(4 * size);
  for ( i = 0; i < size; ++i )
    hash->tab[i] = 0;
  return hash;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (080B457A) --------------------------------------------------------
HashItem_ss_0 *__cdecl lookupHash_ss(Hash_ss_0 *t, char *key, int *hashval_return)
{
  HashItem_ss_0 *hi; // [esp+1Ch] [ebp-Ch]

  *hashval_return = hashfunc(key) % t->size;
  for ( hi = t->tab[*hashval_return]; hi; hi = hi->next )
  {
    if ( !strcmp(hi->key, key) )
      return hi;
  }
  return 0;
}

//----- (080B45ED) --------------------------------------------------------
void __cdecl putHash_ss(Hash_ss_0 *t, char *key, char *value)
{
  HashItem_ss_0 *hi; // [esp+18h] [ebp-10h]
  HashItem_ss_0 *hia; // [esp+18h] [ebp-10h]
  int h[3]; // [esp+1Ch] [ebp-Ch] BYREF

  hi = lookupHash_ss(t, key, h);
  if ( hi )
  {
    hi->value = value;
  }
  else
  {
    hia = (HashItem_ss_0 *)GC_malloc(12);
    hia->key = key;
    hia->value = value;
    hia->next = t->tab[h[0]];
    t->tab[h[0]] = hia;
  }
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (080B466C) --------------------------------------------------------
char *__cdecl getHash_ss(Hash_ss_0 *t, char *key, char *failval)
{
  char *result; // eax
  HashItem_ss_0 *hi; // [esp+18h] [ebp-10h]
  int h[3]; // [esp+1Ch] [ebp-Ch] BYREF

  hi = lookupHash_ss(t, key, h);
  if ( hi )
    result = hi->value;
  else
    result = failval;
  return result;
}

//----- (080B46A1) --------------------------------------------------------
Hash_sv_0 *__cdecl newHash_sv(int size)
{
  int i; // [esp+18h] [ebp-10h]
  Hash_sv *hash; // [esp+1Ch] [ebp-Ch]

  hash = (Hash_sv *)GC_malloc(8);
  hash->size = size;
  hash->tab = (HashItem_sv **)GC_malloc(4 * size);
  for ( i = 0; i < size; ++i )
    hash->tab[i] = 0;
  return hash;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (080B4702) --------------------------------------------------------
HashItem_sv_0 *__cdecl lookupHash_sv(Hash_sv_0 *t, char *key, int *hashval_return)
{
  HashItem_sv_0 *hi; // [esp+1Ch] [ebp-Ch]

  *hashval_return = hashfunc(key) % t->size;
  for ( hi = t->tab[*hashval_return]; hi; hi = hi->next )
  {
    if ( !strcmp(hi->key, key) )
      return hi;
  }
  return 0;
}

//----- (080B4775) --------------------------------------------------------
void __cdecl putHash_sv(Hash_sv_0 *t, char *key, void *value)
{
  HashItem_sv_0 *hi; // [esp+18h] [ebp-10h]
  HashItem_sv_0 *hia; // [esp+18h] [ebp-10h]
  int h[3]; // [esp+1Ch] [ebp-Ch] BYREF

  hi = lookupHash_sv(t, key, h);
  if ( hi )
  {
    hi->value = value;
  }
  else
  {
    hia = (HashItem_sv_0 *)GC_malloc(12);
    hia->key = key;
    hia->value = value;
    hia->next = t->tab[h[0]];
    t->tab[h[0]] = hia;
  }
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (080B47F4) --------------------------------------------------------
void *__cdecl getHash_sv(Hash_sv_0 *t, char *key, void *failval)
{
  void *result; // eax
  HashItem_sv_0 *hi; // [esp+18h] [ebp-10h]
  int h[3]; // [esp+1Ch] [ebp-Ch] BYREF

  hi = lookupHash_sv(t, key, h);
  if ( hi )
    result = hi->value;
  else
    result = failval;
  return result;
}

//----- (080B4829) --------------------------------------------------------
Hash_iv_0 *__cdecl newHash_iv(int size)
{
  int i; // [esp+18h] [ebp-10h]
  Hash_iv *hash; // [esp+1Ch] [ebp-Ch]

  hash = (Hash_iv *)GC_malloc(8);
  hash->size = size;
  hash->tab = (HashItem_iv **)GC_malloc(4 * size);
  for ( i = 0; i < size; ++i )
    hash->tab[i] = 0;
  return hash;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (080B488A) --------------------------------------------------------
HashItem_iv_0 *__cdecl lookupHash_iv(Hash_iv_0 *t, int key, int *hashval_return)
{
  HashItem_iv_0 *hi; // [esp+Ch] [ebp-4h]

  *hashval_return = key % t->size;
  for ( hi = t->tab[*hashval_return]; hi; hi = hi->next )
  {
    if ( hi->key == key )
      return hi;
  }
  return 0;
}

//----- (080B48E1) --------------------------------------------------------
void __cdecl putHash_iv(Hash_iv_0 *t, int key, void *value)
{
  HashItem_iv_0 *hi; // [esp+18h] [ebp-10h]
  HashItem_iv_0 *hia; // [esp+18h] [ebp-10h]
  int h[3]; // [esp+1Ch] [ebp-Ch] BYREF

  hi = lookupHash_iv(t, key, h);
  if ( hi )
  {
    hi->value = value;
  }
  else
  {
    hia = (HashItem_iv_0 *)GC_malloc(12);
    hia->key = key;
    hia->value = value;
    hia->next = t->tab[h[0]];
    t->tab[h[0]] = hia;
  }
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (080B4960) --------------------------------------------------------
void *__cdecl getHash_iv(Hash_iv_0 *t, int key, void *failval)
{
  void *result; // eax
  HashItem_iv_0 *hi; // [esp+14h] [ebp-8h]
  int h; // [esp+18h] [ebp-4h] BYREF

  hi = lookupHash_iv(t, key, &h);
  if ( hi )
    result = hi->value;
  else
    result = failval;
  return result;
}

//----- (080B4998) --------------------------------------------------------
void __cdecl wc_char_conv_init(wc_ces f_ces, wc_ces t_ces)
{
  wc_input_init(f_ces, &char_conv_st);
  char_conv_st.state = -1;
  char_conv_f_ces = f_ces;
  char_conv_t_ces = t_ces;
}

//----- (080B49CD) --------------------------------------------------------
Str __cdecl wc_char_conv(char c)
{
  wc_ces v1; // ebx
  _Str *v2; // eax

  v1 = char_conv_t_ces;
  v2 = char_conv_st.ces_info->char_conv((unsigned __int8)c, &char_conv_st);
  return wc_Str_conv(v2, 0x310000u, v1);
}

//----- (080B4A18) --------------------------------------------------------
wc_ces __cdecl wc_guess_charset(char *charset, wc_ces orig)
{
  wc_ces result; // eax
  wc_ces guess; // [esp+1Ch] [ebp-Ch]

  if ( !charset || !*charset )
    return orig;
  guess = wc_charset_to_ces(charset);
  if ( guess )
    result = guess;
  else
    result = orig;
  return result;
}

//----- (080B4A51) --------------------------------------------------------
wc_ces __cdecl wc_guess_charset_short(char *charset, wc_ces orig)
{
  wc_ces result; // eax
  wc_ces guess; // [esp+1Ch] [ebp-Ch]

  if ( !charset || !*charset )
    return orig;
  guess = wc_charset_short_to_ces(charset);
  if ( guess )
    result = guess;
  else
    result = orig;
  return result;
}

//----- (080B4A8A) --------------------------------------------------------
wc_ces __cdecl wc_guess_locale_charset(char *locale, wc_ces orig)
{
  wc_ces result; // eax
  wc_ces guess; // [esp+1Ch] [ebp-Ch]

  if ( !locale || !*locale )
    return orig;
  guess = wc_locale_to_ces(locale);
  if ( guess )
    result = guess;
  else
    result = orig;
  return result;
}

//----- (080B4AC3) --------------------------------------------------------
wc_ces __cdecl wc_charset_to_ces(char *charset)
{
  wc_ces result; // eax
  int v2; // eax
  int n; // [esp+24h] [ebp-24h]
  int na; // [esp+24h] [ebp-24h]
  char *p; // [esp+28h] [ebp-20h]
  const char *pa; // [esp+28h] [ebp-20h]
  char buf[16]; // [esp+2Ch] [ebp-1Ch] BYREF
  unsigned int v8; // [esp+3Ch] [ebp-Ch]

  v8 = __readgsdword(0x14u);
  p = charset;
  if ( tolower(*charset) == 120 && charset[1] == 45 )
    p = charset + 2;
  n = 0;
  while ( *p && n <= 14 )
  {
    if ( (unsigned __int8)*p > 0x20u && *p != 95 && *p != 45 )
      buf[n++] = tolower(*p);
    ++p;
  }
  buf[n] = 0;
  pa = buf;
  switch ( buf[0] )
  {
    case 'a':
      if ( strncmp(buf, "ascii", 5u) )
        goto LABEL_199;
      result = 256;
      break;
    case 'b':
      if ( !strncmp(buf, "big5hkscs", 9u) )
      {
        result = 3153982;
      }
      else
      {
        if ( strncmp(buf, "big5", 4u) )
          goto LABEL_199;
        result = 3153981;
      }
      break;
    case 'c':
      if ( !strncmp(buf, "cngb", 4u) )
      {
        result = 3149847;
      }
      else
      {
        if ( buf[1] != 112 )
          goto LABEL_199;
        v2 = atoi(&buf[2]);
        if ( v2 == 869 )
        {
          result = 1049641;
        }
        else if ( v2 > 869 )
        {
          if ( v2 == 1251 )
          {
            result = 1049645;
          }
          else if ( v2 > 1251 )
          {
            if ( v2 == 1255 )
            {
              result = 1049649;
            }
            else if ( v2 > 1255 )
            {
              if ( v2 == 1257 )
              {
                result = 1049651;
              }
              else if ( v2 < 1257 )
              {
                result = 1049650;
              }
              else
              {
                if ( v2 != 1258 )
                  goto LABEL_199;
                result = 1049665;
              }
            }
            else if ( v2 == 1253 )
            {
              result = 1049647;
            }
            else if ( v2 > 1253 )
            {
              result = 1049648;
            }
            else
            {
              result = 1049646;
            }
          }
          else if ( v2 == 949 )
          {
            result = 3153983;
          }
          else if ( v2 > 949 )
          {
            switch ( v2 )
            {
              case 1006:
                result = 1049643;
                break;
              case 1250:
                result = 1049644;
                break;
              case 950:
                result = 3153981;
                break;
              default:
                goto LABEL_199;
            }
          }
          else
          {
            switch ( v2 )
            {
              case 932:
                result = 3153976;
                break;
              case 936:
                result = 3153978;
                break;
              case 874:
                result = 1049642;
                break;
              default:
                goto LABEL_199;
            }
          }
        }
        else if ( v2 == 857 )
        {
          result = 1049633;
        }
        else if ( v2 > 857 )
        {
          if ( v2 == 863 )
          {
            result = 1049637;
          }
          else if ( v2 > 863 )
          {
            if ( v2 == 865 )
            {
              result = 1049639;
            }
            else if ( v2 < 865 )
            {
              result = 1049638;
            }
            else
            {
              if ( v2 != 866 )
                goto LABEL_199;
              result = 1049640;
            }
          }
          else if ( v2 == 861 )
          {
            result = 1049635;
          }
          else if ( v2 > 861 )
          {
            result = 1049636;
          }
          else
          {
            if ( v2 != 860 )
              goto LABEL_199;
            result = 1049634;
          }
        }
        else if ( v2 == 850 )
        {
          result = 1049629;
        }
        else if ( v2 > 850 )
        {
          if ( v2 == 855 )
          {
            result = 1049631;
          }
          else if ( v2 > 855 )
          {
            result = 1049632;
          }
          else
          {
            if ( v2 != 852 )
              goto LABEL_199;
            result = 1049630;
          }
        }
        else
        {
          switch ( v2 )
          {
            case 737:
              result = 1049627;
              break;
            case 775:
              result = 1049628;
              break;
            case 437:
              result = 1049626;
              break;
            default:
              goto LABEL_199;
          }
        }
      }
      break;
    case 'e':
      if ( strncmp(buf, "euc", 3u) )
        goto LABEL_199;
      if ( buf[3] == 106 )
        return 3149846;
      if ( buf[3] > 106 )
      {
        if ( buf[3] == 107 )
          return 3149849;
        if ( buf[3] == 116 )
          return 3149848;
      }
      else if ( buf[3] == 99 )
      {
        return 3149847;
      }
      switch ( WcLocale )
      {
        case 1u:
          result = 3149846;
          break;
        case 2u:
          result = 3149847;
          break;
        case 3u:
          result = 3149848;
          break;
        case 4u:
          result = 3149847;
          break;
        case 5u:
          result = 3149849;
          break;
        default:
          result = 3149846;
          break;
      }
      break;
    case 'g':
      if ( !strncmp(buf, "gb18030", 7u) || !strncmp(buf, "gbk2k", 5u) )
      {
        result = 3153979;
      }
      else if ( !strncmp(buf, "gbk", 3u) )
      {
        result = 3153978;
      }
      else
      {
        if ( strncmp(buf, "gb2312", 6u) )
          goto LABEL_199;
        result = 3149847;
      }
      break;
    case 'h':
      if ( !strncmp(buf, "hz", 2u) )
      {
        result = 2105404;
      }
      else
      {
        if ( strncmp(buf, "hkscs", 5u) )
          goto LABEL_199;
        result = 3153982;
      }
      break;
    case 'i':
      if ( !strncmp(buf, "iso2022", 7u) )
      {
        switch ( buf[7] )
        {
          case 'j':
            if ( !strncmp(&buf[7], "jp2", 3u) )
            {
              result = 2099218;
            }
            else if ( !strncmp(&buf[7], "jp3", 3u) )
            {
              result = 2099219;
            }
            else
            {
              result = 2099217;
            }
            break;
          case 'k':
            result = 2099221;
            break;
          case 'c':
            result = 2099220;
            break;
          default:
            result = 2099217;
            break;
        }
      }
      else
      {
        if ( strncmp(buf, "iso8859", 7u) )
          goto LABEL_199;
        na = atoi(&buf[7]);
        if ( na <= 0 || na > 16 || na == 12 )
          result = 1049089;
        else
          result = na | 0x100200;
      }
      break;
    case 'j':
      if ( !strncmp(buf, "johab", 5u) )
      {
        result = 3153984;
      }
      else
      {
        if ( strncmp(buf, "jis", 3u) )
          goto LABEL_199;
        result = 2099217;
      }
      break;
    case 'k':
      if ( !strncmp(buf, "koi8r", 5u) )
      {
        result = 1049652;
      }
      else if ( !strncmp(buf, "koi8u", 5u) )
      {
        result = 1049653;
      }
      else if ( !strncmp(buf, "ksx1001", 7u) )
      {
        result = 3149849;
      }
      else
      {
        if ( strncmp(buf, "ksc5601", 7u) )
          goto LABEL_199;
        result = 3149849;
      }
      break;
    case 'n':
      if ( strncmp(buf, "next", 4u) )
        goto LABEL_199;
      result = 1049654;
      break;
    case 's':
      if ( !strncmp(buf, "shiftjisx0213", 0xDu) || !strncmp(buf, "sjisx0213", 9u) )
      {
        result = 3153977;
      }
      else
      {
        if ( strncmp(buf, "shiftjis", 8u) && strncmp(buf, "sjis", 4u) )
          goto LABEL_199;
        result = 3153976;
      }
      break;
    case 't':
      if ( !strncmp(buf, "tis620", 6u) )
      {
        result = 1049099;
      }
      else
      {
        if ( strncmp(buf, "tcvn", 4u) )
          goto LABEL_199;
        result = 1066050;
      }
      break;
    case 'u':
      if ( !strncmp(buf, "utf8", 4u) )
      {
        result = 3178565;
      }
      else if ( !strncmp(buf, "utf7", 4u) )
      {
        result = 2129990;
      }
      else if ( !strncmp(buf, "uhc", 3u) )
      {
        result = 3153983;
      }
      else if ( !strncmp(buf, "ujis", 4u) )
      {
        result = 3149846;
      }
      else
      {
        if ( strncmp(buf, "usascii", 7u) )
          goto LABEL_199;
        result = 256;
      }
      break;
    case 'v':
      if ( !strncmp(buf, "viet", 4u) && (pa = &buf[4], !strncmp(&buf[4], "tcvn", 4u)) )
      {
        result = 1066050;
      }
      else if ( !strncmp(pa, "viscii", 6u) )
      {
        result = 1066051;
      }
      else
      {
        if ( strncmp(pa, "vps", 3u) )
          goto LABEL_199;
        result = 1066052;
      }
      break;
    case 'w':
      if ( strncmp(buf, "windows", 7u) )
        goto LABEL_199;
      if ( !strncmp(buf, "31j", 3u) )
      {
        result = 3153976;
      }
      else
      {
        switch ( atoi(&buf[7]) )
        {
          case 1250:
            result = 1049644;
            break;
          case 1251:
            result = 1049645;
            break;
          case 1252:
            result = 1049646;
            break;
          case 1253:
            result = 1049647;
            break;
          case 1254:
            result = 1049648;
            break;
          case 1255:
            result = 1049649;
            break;
          case 1256:
            result = 1049650;
            break;
          case 1257:
            result = 1049651;
            break;
          case 1258:
            result = 1049665;
            break;
          default:
            goto LABEL_199;
        }
      }
      break;
    default:
LABEL_199:
      result = 0;
      break;
  }
  return result;
}

//----- (080B568A) --------------------------------------------------------
wc_ces __cdecl wc_charset_short_to_ces(char *charset)
{
  wc_ces result; // eax
  int n; // [esp+20h] [ebp-28h]
  int na; // [esp+20h] [ebp-28h]
  wc_ces ces; // [esp+24h] [ebp-24h]
  char *p; // [esp+28h] [ebp-20h]
  char *pa; // [esp+28h] [ebp-20h]
  char buf[16]; // [esp+2Ch] [ebp-1Ch] BYREF
  unsigned int v8; // [esp+3Ch] [ebp-Ch]

  v8 = __readgsdword(0x14u);
  p = charset;
  ces = wc_charset_to_ces(charset);
  if ( ces )
    return ces;
  n = 0;
  while ( *p && n <= 14 )
  {
    if ( (unsigned __int8)*p > 0x20u && *p != 95 && *p != 45 )
      buf[n++] = tolower(*p);
    ++p;
  }
  buf[n] = 0;
  switch ( buf[0] )
  {
    case 'a':
      result = 256;
      break;
    case 'b':
      result = 3153981;
      break;
    case 'c':
      result = 2099220;
      break;
    case 'e':
      if ( buf[1] == 106 )
        return 3149846;
      if ( buf[1] > 106 )
      {
        if ( buf[1] == 107 )
          return 3149849;
        if ( buf[1] == 116 )
          return 3149848;
      }
      else if ( buf[1] == 99 )
      {
        return 3149847;
      }
      result = 3149846;
      break;
    case 'g':
      result = 3149847;
      break;
    case 'h':
      if ( buf[1] == 107 )
        result = 3153982;
      else
        result = 2105404;
      break;
    case 'j':
      pa = &buf[1];
      if ( buf[1] == 111 )
      {
        result = 3153984;
      }
      else
      {
        if ( buf[1] == 112 )
          pa = &buf[2];
        if ( *pa == 50 )
        {
          result = 2099218;
        }
        else if ( *pa == 51 )
        {
          result = 2099219;
        }
        else
        {
          result = 2099217;
        }
      }
      break;
    case 'k':
      if ( buf[1] == 111 )
        result = 1049652;
      else
        result = 2099221;
      break;
    case 'l':
      na = atoi(&buf[1]);
      if ( na <= 0 || na > 16 || na == 12 )
        result = 1049089;
      else
        result = na | 0x100200;
      break;
    case 'n':
      result = 1049654;
      break;
    case 'r':
      result = 1049655;
      break;
    case 's':
      result = 3153976;
      break;
    case 't':
      if ( buf[1] == 99 )
        result = 1066050;
      else
        result = 1049099;
      break;
    case 'u':
      if ( buf[1] == 55 )
        result = 2129990;
      else
        result = 3178565;
      break;
    case 'v':
      if ( buf[1] == 112 )
        result = 1066052;
      else
        result = 1066051;
      break;
    case 'w':
      switch ( atoi(&buf[1]) )
      {
        case 1250:
          result = 1049644;
          break;
        case 1251:
          result = 1049645;
          break;
        case 1252:
          result = 1049646;
          break;
        case 1253:
          result = 1049647;
          break;
        case 1254:
          result = 1049648;
          break;
        case 1255:
          result = 1049649;
          break;
        case 1256:
          result = 1049650;
          break;
        case 1257:
          result = 1049651;
          break;
        case 1258:
          result = 1049665;
          break;
        default:
          goto LABEL_70;
      }
      break;
    default:
LABEL_70:
      result = 0;
      break;
  }
  return result;
}

//----- (080B5999) --------------------------------------------------------
wc_ces __cdecl wc_locale_to_ces(char *locale)
{
  wc_ces result; // eax
  int v2; // ebx
  char buf[6]; // [esp+1Eh] [ebp-1Ah] BYREF
  char *cs_0; // [esp+24h] [ebp-14h]
  int n; // [esp+28h] [ebp-10h]
  char *p; // [esp+2Ch] [ebp-Ch]

  p = locale;
  if ( *locale == 67 && !p[1] )
    return 256;
  cs_0 = nl_langinfo(14);
  if ( cs_0 && strcmp(cs_0, "US-ASCII") )
    return wc_charset_to_ces(cs_0);
  n = 0;
  while ( *p && *p != 46 && n <= 4 )
  {
    if ( (unsigned __int8)*p > 0x20u )
    {
      v2 = n;
      buf[v2] = tolower(*p);
      ++n;
    }
    ++p;
  }
  buf[n] = 0;
  if ( *p == 46 )
  {
    if ( !strcasecmp(++p, "euc") )
    {
      if ( buf[0] == 107 )
      {
        WcLocale = 5;
      }
      else if ( buf[0] == 122 )
      {
        if ( !strcmp(buf, "zh_tw") )
        {
          WcLocale = 3;
        }
        else if ( !strcmp(buf, "zh_hk") )
        {
          WcLocale = 4;
        }
        else
        {
          WcLocale = 2;
        }
      }
      else
      {
        WcLocale = buf[0] == 106;
      }
    }
    result = wc_charset_to_ces(p);
  }
  else if ( !strcmp(buf, "japanese") )
  {
    result = 3153976;
  }
  else if ( !strcmp(buf, "zh_tw") || !strcmp(buf, "zh_hk") )
  {
    result = 3153981;
  }
  else
  {
    for ( n = 0; lang_ces_table[n].lang; ++n )
    {
      if ( !strncmp(buf, lang_ces_table[n].lang, 2u) )
        return lang_ces_table[n].ces;
    }
    result = 1049089;
  }
  return result;
}

//----- (080B5BCC) --------------------------------------------------------
char *__cdecl wc_ces_to_charset(wc_ces ces)
{
  char *result; // eax

  if ( ces == 3211264 )
    result = "WTF";
  else
    result = WcCesInfo[(unsigned __int8)ces].name;
  return result;
}

//----- (080B5BF2) --------------------------------------------------------
char *__cdecl wc_ces_to_charset_desc(wc_ces ces)
{
  char *result; // eax

  if ( ces == 3211264 )
    result = "W3M Transfer Format";
  else
    result = WcCesInfo[(unsigned __int8)ces].desc;
  return result;
}

//----- (080B5C18) --------------------------------------------------------
wc_ces __cdecl wc_guess_8bit_charset(wc_ces orig)
{
  if ( orig > 0x200813 )
  {
    if ( orig == 2099221 )
      return 3149849;
    if ( orig < 0x200815 || orig == 2105404 )
      return 3149847;
  }
  else
  {
    if ( orig >= 0x200811 )
      return 3149846;
    if ( orig == 256 )
      return 1049089;
  }
  return orig;
}

//----- (080B5C6D) --------------------------------------------------------
wc_bool __cdecl wc_check_ces(wc_ces ces)
{
  return (unsigned __int8)ces <= 0x46u && WcCesInfo[(unsigned __int8)ces].id == ces;
}

//----- (080B5CA3) --------------------------------------------------------
int __cdecl wc_ces_list_cmp(const void *a, const void *b)
{
  return strcasecmp(*((const char **)a + 2), *((const char **)b + 2));
}

//----- (080B5CC3) --------------------------------------------------------
wc_ces_list *wc_get_ces_list()
{
  size_t n; // [esp+18h] [ebp-10h]
  size_t na; // [esp+18h] [ebp-10h]
  wc_ces_info *info; // [esp+1Ch] [ebp-Ch]
  wc_ces_info *infoa; // [esp+1Ch] [ebp-Ch]

  if ( list )
    return list;
  info = WcCesInfo;
  n = 0;
  while ( info->id )
  {
    if ( info->name )
      ++n;
    ++info;
  }
  list = (wc_ces_list *)GC_malloc(12 * (n + 1));
  infoa = WcCesInfo;
  na = 0;
  while ( infoa->id )
  {
    if ( infoa->name )
    {
      list[na].id = infoa->id;
      list[na].name = infoa->name;
      list[na++].desc = infoa->desc;
    }
    ++infoa;
  }
  list[na].id = 0;
  list[na].name = 0;
  list[na].desc = 0;
  qsort(list, na, 0xCu, wc_ces_list_cmp);
  return list;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (080B5E24) --------------------------------------------------------
Str __cdecl wc_Str_conv(Str is, wc_ces f_ces, wc_ces t_ces)
{
  Str result; // eax

  if ( f_ces != 3211264 )
    is = WcCesInfo[(unsigned __int8)f_ces].conv_from(is, f_ces);
  if ( t_ces == 3211264 )
    result = is;
  else
    result = wc_conv_to_ces(is, t_ces);
  return result;
}

//----- (080B5E7D) --------------------------------------------------------
Str __cdecl wc_Str_conv_strict(Str is, wc_ces f_ces, wc_ces t_ces)
{
  Str result; // eax
  wc_option opt; // [esp+1Ch] [ebp-1Ch]

  opt = WcOption;
  WcOption.strict_iso2022 = 1;
  WcOption.no_replace = 1;
  WcOption.fix_width_conv = 0;
  result = wc_Str_conv(is, f_ces, t_ces);
  WcOption = opt;
  return result;
}

//----- (080B5EF9) --------------------------------------------------------
Str __cdecl wc_conv_to_ces(Str is, wc_ces ces)
{
  void (*v3)(...); // ebx
  int v4; // eax
  void (*v5)(...); // ebx
  wc_status st; // [esp+14h] [ebp-64h] BYREF
  wc_wchar_t v7; // [esp+50h] [ebp-28h] BYREF
  wc_wchar_t v8; // [esp+58h] [ebp-20h] BYREF
  wc_uchar *p; // [esp+60h] [ebp-18h] BYREF
  wc_uchar *ep; // [esp+64h] [ebp-14h]
  wc_uchar *sp_0; // [esp+68h] [ebp-10h]
  Str os; // [esp+6Ch] [ebp-Ch]

  sp_0 = (wc_uchar *)is->ptr;
  ep = &sp_0[is->length];
  if ( ces < 0x104442 )
  {
LABEL_16:
    for ( p = sp_0; p < ep && (*p & 0x80u) == 0; ++p )
      ;
    goto LABEL_20;
  }
  if ( ces > 0x104444 )
  {
    if ( ces == 2105404 )
    {
      for ( p = sp_0; p < ep && *p != 126 && (*p & 0x80u) == 0; ++p )
        ;
      goto LABEL_20;
    }
    goto LABEL_16;
  }
  for ( p = sp_0; p < ep && *p > 0x1Fu && (*p & 0x80u) == 0; ++p )
    ;
LABEL_20:
  if ( p == ep )
    return is;
  os = Strnew_size(is->length);
  if ( p > sp_0 )
    --p;
  if ( p > sp_0 )
    Strcat_charp_n(os, is->ptr, p - sp_0);
  wc_output_init(ces, &st);
  if ( ces > 0x200815 )
  {
    if ( ces == 2129990 || ces == 3178565 || ces == 2105404 )
      goto LABEL_35;
LABEL_43:
    while ( p < ep )
    {
      if ( (*p & 0x80u) == 0 && WTF_WIDTH_MAP[p[1]] )
      {
        if ( os->length + 1 >= os->area_size )
          Strgrow(os);
        v4 = os->length;
        os->ptr[v4] = *p;
        os->length = v4 + 1;
        os->ptr[os->length] = 0;
        ++p;
      }
      else
      {
        v5 = st.ces_info->push_to;
        wtf_parse(&v7, &p);
        v5(os, v7.ccs, v7.code, &st);
      }
    }
    goto LABEL_44;
  }
  if ( ces < 0x200811 && ces - 1066050 > 2 )
    goto LABEL_43;
LABEL_35:
  while ( p < ep )
  {
    v3 = st.ces_info->push_to;
    wtf_parse(&v8, &p);
    v3(os, v8.ccs, v8.code, &st);
  }
LABEL_44:
  wc_push_end(os, &st);
  return os;
}

//----- (080B618F) --------------------------------------------------------
Str __cdecl wc_Str_conv_with_detect(Str is, wc_ces *f_ces, wc_ces hint, wc_ces t_ces)
{
  wc_ces detect; // [esp+1Ch] [ebp-Ch]

  if ( *f_ces == 3211264 || hint == 3211264 )
  {
    *f_ces = 3211264;
    detect = 3211264;
  }
  else if ( WcOption.auto_detect )
  {
    if ( (*f_ces & 0x100000) != 0 )
      hint = *f_ces;
    detect = wc_auto_detect(is->ptr, is->length, hint);
    if ( WcOption.auto_detect == 2 )
    {
      if ( (detect & 0x100000) != 0 || (detect & 0x1FE00) != 0 && (*f_ces & 0x100000) == 0 )
        *f_ces = detect;
    }
    else if ( (detect & 0x800) != 0 && (*f_ces & 0x100000) == 0 )
    {
      *f_ces = detect;
    }
  }
  else
  {
    *f_ces = hint;
    detect = hint;
  }
  return wc_Str_conv(is, detect, t_ces);
}

//----- (080B628E) --------------------------------------------------------
void __cdecl wc_push_end(Str os, wc_status *st)
{
  if ( (st->ces_info->id & 0x800) != 0 )
  {
    wc_push_to_iso2022_end(os, st);
  }
  else
  {
    switch ( st->ces_info->id )
    {
      case 0x20203Cu:
        wc_push_to_hz_end(os, st);
        break;
      case 0x308045u:
        wc_push_to_utf8_end(os, st);
        break;
      case 0x208046u:
        wc_push_to_utf7_end(os, st);
        break;
    }
  }
}

//----- (080B6320) --------------------------------------------------------
void __cdecl wc_create_detect_map(wc_ces ces, wc_bool esc)
{
  bool v2; // al
  wc_uint8 *map; // [esp+Ch] [ebp-8h]
  int i; // [esp+10h] [ebp-4h]
  int ia; // [esp+10h] [ebp-4h]

  if ( ces != detect_ces_2403 )
  {
    if ( (ces & 0x4000) != 0 )
    {
      map = 0;
      switch ( ces )
      {
        case 0x104443u:
          map = wc_c0_viscii112_map;
          break;
        case 0x104444u:
          map = wc_c0_vps2_map;
          break;
        case 0x104442u:
          map = wc_c0_tcvn57122_map;
          break;
      }
      for ( i = 0; i <= 31; ++i )
        WC_DETECT_MAP[i] = map[i] != 0;
    }
    else
    {
      for ( ia = 0; ia <= 31; ++ia )
        WC_DETECT_MAP[ia] = 0;
      WC_DETECT_MAP[126] = ces == 2105404;
      WC_DETECT_MAP[43] = ces == 2129990;
    }
    detect_ces_2403 = ces;
  }
  v2 = esc || (ces & 0x800) != 0;
  WC_DETECT_MAP[27] = v2;
}

//----- (080B6412) --------------------------------------------------------
wc_ces __cdecl wc_auto_detect(char *is, size_t len, wc_ces hint)
{
  wc_ces result; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  wc_status st; // [esp+1Ch] [ebp-9Ch] BYREF
  int utf8_next; // [esp+58h] [ebp-60h]
  int utf8_detect; // [esp+5Ch] [ebp-5Ch]
  int utf8_state; // [esp+60h] [ebp-58h]
  int possible; // [esp+64h] [ebp-54h]
  int priv_detect; // [esp+68h] [ebp-50h]
  int latin_detect; // [esp+6Ch] [ebp-4Ch]
  int hz_detect; // [esp+70h] [ebp-48h]
  int big5_detect; // [esp+74h] [ebp-44h]
  int sjis_detect; // [esp+78h] [ebp-40h]
  int euc_detect; // [esp+7Ch] [ebp-3Ch]
  int iso_detect; // [esp+80h] [ebp-38h]
  int hz_state; // [esp+84h] [ebp-34h]
  int big5_state; // [esp+88h] [ebp-30h]
  int sjis_state; // [esp+8Ch] [ebp-2Ch]
  int euc_state; // [esp+90h] [ebp-28h]
  wc_ces priv; // [esp+94h] [ebp-24h]
  wc_ces euc; // [esp+98h] [ebp-20h]
  wc_uchar *q; // [esp+9Ch] [ebp-1Ch] BYREF
  wc_uchar *ep; // [esp+A0h] [ebp-18h]
  wc_uchar *p; // [esp+A4h] [ebp-14h]
  wc_bool ok; // [esp+ABh] [ebp-Dh]
  wc_bool iso2022kr; // [esp+ACh] [ebp-Ch]
  wc_bool iso2022cn; // [esp+ADh] [ebp-Bh]
  wc_bool iso2022jp3; // [esp+AEh] [ebp-Ah]
  wc_bool iso2022jp2; // [esp+AFh] [ebp-9h]

  p = (wc_uchar *)is;
  ep = (wc_uchar *)&is[len];
  euc = 0;
  priv = 0;
  euc_state = 0;
  sjis_state = 0;
  big5_state = 0;
  hz_state = 0;
  iso_detect = 8;
  euc_detect = 8;
  sjis_detect = 8;
  big5_detect = 8;
  hz_detect = 8;
  latin_detect = 8;
  priv_detect = 8;
  possible = 0;
  iso2022jp2 = 0;
  iso2022jp3 = 0;
  iso2022cn = 0;
  iso2022kr = 0;
  ok = 0;
  utf8_state = 0;
  utf8_detect = 8;
  utf8_next = 0;
  wc_create_detect_map(hint, 1u);
  while ( p < ep && !WC_DETECT_MAP[*p] )
    ++p;
  if ( p == ep )
    return hint;
  if ( hint == 3149846 )
    goto LABEL_26;
  if ( hint > 0x301016 )
  {
    if ( hint > 0x302039 )
    {
      if ( hint != 3153981 )
      {
        if ( hint != 3178565 )
          goto LABEL_33;
        iso_detect = 0;
        possible = 1;
        goto LABEL_37;
      }
    }
    else
    {
      if ( hint >= 0x302038 )
        goto LABEL_26;
      if ( hint != 3149848 )
      {
        if ( hint < 0x301018 )
          goto LABEL_27;
        if ( hint != 3149849 )
          goto LABEL_33;
        goto LABEL_30;
      }
    }
    euc = 3149848;
    euc_state = 0;
    big5_state = 0;
    big5_detect = 0;
    euc_detect = 0;
    iso_detect = 0;
    possible = 3;
    goto LABEL_37;
  }
  if ( hint > 0x200813 )
  {
    if ( hint != 2099221 )
    {
      if ( hint >= 0x200815 )
      {
        if ( hint != 2105404 )
          goto LABEL_33;
        euc = 3149847;
        euc_state = 0;
        hz_state = 0;
        hz_detect = 0;
        big5_detect = 0;
        euc_detect = 0;
        iso_detect = 0;
        possible = 4;
        goto LABEL_37;
      }
LABEL_27:
      euc = 3149847;
      euc_state = 0;
      big5_state = 0;
      big5_detect = 0;
      euc_detect = 0;
      iso_detect = 0;
      possible = 3;
      goto LABEL_37;
    }
LABEL_30:
    euc = 3149849;
    euc_state = 0;
    euc_detect = 0;
    iso_detect = 0;
    possible = 3;
    goto LABEL_37;
  }
  if ( hint >= 0x200811 )
  {
LABEL_26:
    euc = 3149846;
    euc_state = 0;
    sjis_state = 0;
    sjis_detect = 0;
    euc_detect = 0;
    iso_detect = 0;
    possible = 3;
    goto LABEL_37;
  }
  if ( hint != 256 )
  {
LABEL_33:
    if ( (hint & 0x200) != 0 )
    {
      latin_detect = 0;
      iso_detect = 0;
    }
    else
    {
      priv_detect = 0;
      iso_detect = 0;
      priv = hint;
    }
    possible = 2;
    goto LABEL_37;
  }
  latin_detect = 0;
  iso_detect = 0;
  possible = 2;
LABEL_37:
  if ( priv_detect == 8 )
  {
    utf8_detect = 0;
    ++possible;
  }
  wc_input_init(0x100u, &st);
  while ( p < ep && possible && (possible != 1 || !ok) )
  {
    if ( iso_detect != 8 )
    {
      if ( *p < 0xEu )
        goto LABEL_74;
      if ( *p <= 0xFu )
      {
        iso_detect = 2;
        ok = 1;
        iso2022cn = 1;
        iso2022kr = 1;
        goto LABEL_76;
      }
      if ( *p != 27 )
      {
LABEL_74:
        if ( (*p & 0x80u) != 0 )
        {
          iso_detect = 8;
          --possible;
        }
        goto LABEL_76;
      }
      switch ( p[1] )
      {
        case '$':
          q = p;
          if ( wc_parse_iso2022_esc(&q, &st) )
          {
            if ( st.design[0] != 33088 && st.design[0] != 33090 )
            {
              if ( st.design[0] == 33103 || st.design[0] == 33104 )
              {
                iso2022jp3 = 1;
              }
              else if ( (st.design[0] & 0xFF00) == 33024 )
              {
                iso2022jp2 = 1;
              }
            }
            if ( st.design[1] == 33091 )
            {
              iso2022kr = 1;
            }
            else if ( st.design[1] == 33089 || st.design[1] == 33093 || st.design[1] == 33095 )
            {
              iso2022cn = 1;
            }
            if ( (st.design[2] & 0xFF00) == 33024 || (st.design[3] & 0xFF00) == 33024 )
              iso2022cn = 1;
LABEL_72:
            iso_detect = 2;
            ok = 1;
            break;
          }
          break;
        case '.':
          q = p;
          if ( wc_parse_iso2022_esc(&q, &st) )
          {
            if ( (st.design[2] & 0xFF00) == 512 )
              iso2022jp2 = 1;
            goto LABEL_72;
          }
          break;
        case '%':
          q = p;
          if ( wc_parse_iso2022_esc(&q, &st) )
          {
            possible = 0;
            iso_detect = 4;
            goto LABEL_192;
          }
          break;
        default:
          goto LABEL_72;
      }
    }
LABEL_76:
    if ( euc_detect != 8 )
    {
      switch ( euc_state )
      {
        case 2:
          if ( WC_ISO_MAP[*p] == 64 )
          {
            euc_detect |= 2u;
            ok = 1;
          }
          else
          {
            if ( (euc_detect & 4) != 0 )
              v4 = 8;
            else
              v4 = euc_detect | 4;
            euc_detect = v4;
          }
          euc_state = 0;
          break;
        case 3:
          if ( *p <= 0x9Fu || *p > 0xB0u || WC_ISO_MAP[p[1]] != 64 )
            euc_detect = 8;
          euc_state = 0;
          break;
        case 0:
          switch ( WC_ISO_MAP[*p] )
          {
            case '@':
              euc_state = 2;
              break;
            case 'P':
            case '`':
              euc_detect = 8;
              break;
            case 'T':
              if ( euc == 3149846 )
              {
                euc_state = 2;
              }
              else if ( euc == 3149848 )
              {
                euc_state = 3;
              }
              else
              {
                euc_detect = 8;
              }
              break;
            case 'U':
              if ( euc != 3149846 || WC_ISO_MAP[p[1]] != 64 )
                euc_detect = 8;
              break;
            default:
              goto LABEL_104;
          }
          break;
      }
LABEL_104:
      if ( euc_detect == 8 )
        --possible;
    }
    if ( sjis_detect != 8 )
    {
      switch ( sjis_state )
      {
        case 1:
          if ( (WC_SJIS_MAP[*p] & 0x10) != 0 )
          {
            sjis_detect |= 2u;
            ok = 1;
          }
          else
          {
            if ( (sjis_detect & 4) != 0 )
              v5 = 8;
            else
              v5 = sjis_detect | 4;
            sjis_detect = v5;
          }
          sjis_state = 0;
          break;
        case 3:
          if ( (WC_SJIS_MAP[*p] & 0x10) != 0 )
            sjis_detect |= 1u;
          else
            sjis_detect = 8;
          sjis_state = 0;
          break;
        case 0:
          switch ( WC_SJIS_MAP[*p] )
          {
            case 0x12u:
            case 0x17u:
            case 0x40u:
              goto LABEL_115;
            case 0x13u:
              sjis_detect |= 1u;
              break;
            case 0x34u:
            case 0x35u:
              sjis_state = 1;
              break;
            case 0x36u:
              if ( WcOption.use_jisx0213 )
                sjis_state = 3;
              else
LABEL_115:
                sjis_detect = 8;
              break;
            default:
              goto LABEL_128;
          }
          break;
      }
LABEL_128:
      if ( sjis_detect == 8 )
        --possible;
    }
    if ( big5_detect != 8 )
    {
      if ( big5_state )
      {
        if ( big5_state == 1 )
        {
          if ( (WC_BIG5_MAP[*p] & 4) != 0 )
          {
            big5_detect |= 2u;
            ok = 1;
          }
          else
          {
            if ( (big5_detect & 4) != 0 )
              v7 = 8;
            else
              v7 = big5_detect | 4;
            big5_detect = v7;
          }
          big5_state = 0;
        }
      }
      else
      {
        v6 = WC_BIG5_MAP[*p];
        if ( v6 == 2 )
        {
          big5_detect = 8;
        }
        else if ( v6 == 7 )
        {
          big5_state = 1;
        }
      }
      if ( big5_detect == 8 )
        --possible;
    }
    if ( hz_detect != 8 )
    {
      if ( (*p & 0x80u) == 0 )
      {
        switch ( hz_state )
        {
          case 0:
            if ( *p == 126 )
              hz_state = 1;
            break;
          case 1:
            if ( *p == 123 )
              hz_state = 3;
            else
              hz_state = 0;
            break;
          case 2:
            if ( *p == 125 )
              hz_state = 0;
            else
              hz_state = 3;
            break;
          case 3:
            if ( *p == 126 )
              hz_state = 2;
            else
              hz_state = 4;
            break;
          case 4:
            hz_detect = 2;
            ok = 1;
            hz_state = 0;
            break;
          default:
            break;
        }
      }
      else
      {
        hz_detect = 8;
        --possible;
      }
    }
    if ( latin_detect != 8 )
    {
      v8 = WC_ISO_MAP[*p] & 0xF0;
      if ( v8 == 80 )
      {
        latin_detect = 8;
      }
      else if ( v8 == 96 || v8 == 64 )
      {
        latin_detect |= 2u;
        ok = 1;
      }
      if ( latin_detect == 8 )
        --possible;
    }
    if ( priv_detect != 8 && *p != 27 && WC_DETECT_MAP[*p] )
    {
      priv_detect |= 2u;
      ok = 1;
    }
    if ( utf8_detect != 8 )
    {
      if ( utf8_state )
      {
        if ( utf8_state == 1 )
        {
          if ( WC_UTF8_MAP[*p] )
          {
            utf8_detect = 8;
            utf8_state = 0;
          }
          else if ( !--utf8_next )
          {
            utf8_detect |= 2u;
            ok = 1;
            utf8_state = 0;
          }
        }
      }
      else
      {
        utf8_next = WC_UTF8_MAP[*p];
        if ( utf8_next != 1 )
        {
          if ( utf8_next <= 1 || utf8_next == 7 )
          {
            utf8_detect = 8;
          }
          else if ( utf8_next != 8 )
          {
            --utf8_next;
            utf8_state = 1;
          }
        }
      }
      if ( utf8_detect == 8 )
        --possible;
    }
LABEL_192:
    ++p;
  }
  if ( iso_detect == 8 )
  {
    if ( hint > 0x301019 )
    {
      if ( hint == 3153981 )
      {
        if ( big5_detect != 8 )
          return 3153981;
        goto LABEL_249;
      }
      if ( hint > 0x30203D )
      {
        if ( hint == 3178565 )
          return 3178565;
      }
      else if ( hint - 3153976 <= 1 )
      {
        if ( sjis_detect != 8 )
          return hint;
        goto LABEL_249;
      }
    }
    else
    {
      if ( hint >= 0x301016 )
      {
        if ( euc_detect != 8 )
          return hint;
        goto LABEL_249;
      }
      if ( hint == 256 )
      {
        if ( utf8_detect != 8 )
          return 256;
        if ( latin_detect == 8 )
          return 256;
        return 1049089;
      }
      if ( hint >= 0x100 && hint - 2099217 <= 4 )
      {
LABEL_249:
        if ( euc_detect == 2 )
          return euc;
        if ( sjis_detect == 2 )
          return 3153976;
        if ( big5_detect == 2 )
          return 3153981;
        if ( utf8_detect == 2 )
          return 3178565;
        if ( (sjis_detect & 1) != 0 )
          return 3153976;
        if ( euc_detect != 8 )
          return euc;
        if ( sjis_detect != 8 )
          return 3153976;
        if ( big5_detect != 8 )
          return 3153981;
        if ( utf8_detect == 8 )
          return hint;
        return 3178565;
      }
    }
    if ( latin_detect != 8 )
      return hint;
    if ( priv_detect != 8 )
      return hint;
    if ( utf8_detect == 8 )
      return hint;
    return 3178565;
  }
  if ( iso_detect )
  {
    if ( euc >= 0x301017 )
    {
      if ( euc <= 0x301018 )
      {
        if ( iso2022cn )
          return 2099220;
      }
      else if ( euc == 3149849 && iso2022kr )
      {
        return 2099221;
      }
    }
    if ( iso2022jp3 )
    {
      result = 2099219;
    }
    else if ( iso2022jp2 )
    {
      result = 2099218;
    }
    else if ( iso2022cn )
    {
      result = 2099220;
    }
    else if ( iso2022kr )
    {
      result = 2099221;
    }
    else
    {
      result = 2099217;
    }
  }
  else if ( hz_detect == 2 )
  {
    result = 2105404;
  }
  else if ( priv_detect == 2 )
  {
    result = priv;
  }
  else
  {
    result = 256;
  }
  return result;
}
// 80B6D73: conditional instruction was optimized away because of '%utf8_next.4==0'

//----- (080B7018) --------------------------------------------------------
Str __cdecl wc_conv_from_hz(Str is, wc_ces ces)
{
  int v3; // eax
  int v4; // eax
  int state; // [esp+1Ch] [ebp-1Ch]
  wc_uchar *p; // [esp+20h] [ebp-18h]
  wc_uchar *ep; // [esp+24h] [ebp-14h]
  char *sp_0; // [esp+28h] [ebp-10h]
  Str os; // [esp+2Ch] [ebp-Ch]

  sp_0 = is->ptr;
  ep = (wc_uchar *)&is->ptr[is->length];
  state = 0;
  for ( p = (wc_uchar *)is->ptr; p < ep && (*p & 0x80u) == 0 && *p != 126; ++p )
    ;
  if ( p == ep )
    return is;
  os = Strnew_size(is->length);
  if ( p > (wc_uchar *)sp_0 )
    Strcat_charp_n(os, is->ptr, p - (wc_uchar *)sp_0);
  while ( p < ep )
  {
    switch ( state )
    {
      case 0:
        if ( *p == 126 )
        {
          state = 1;
        }
        else if ( WC_ISO_MAP[*p] == 64 )
        {
          state = 5;
        }
        else
        {
          if ( (*p & 0x80u) != 0 )
            goto LABEL_16;
          if ( os->length + 1 >= os->area_size )
            Strgrow(os);
          v3 = os->length;
          os->ptr[v3] = *p;
          os->length = v3 + 1;
          os->ptr[os->length] = 0;
        }
        break;
      case 1:
        switch ( *p )
        {
          case 0x7Bu:
            state = 3;
            goto LABEL_49;
          case 0x7Eu:
            if ( os->length + 1 >= os->area_size )
              Strgrow(os);
            v4 = os->length;
            os->ptr[v4] = *p;
            os->length = v4 + 1;
            os->ptr[os->length] = 0;
            break;
          case 0xAu:
            goto LABEL_49;
          default:
            wtf_push_unknown(os, p - 1, 2u);
            break;
        }
        state = 0;
        break;
      case 2:
        if ( *p == 125 || *p == 10 )
        {
          state = 0;
        }
        else
        {
          if ( WC_ISO_MAP[*p & 0x7F] )
            wtf_push_unknown(os, p - 1, 2u);
          else
            wtf_push(os, 0x8141u, (*(p - 1) << 8) | *p);
          state = 3;
        }
        break;
      case 3:
        if ( *p == 126 )
        {
          state = 2;
        }
        else if ( WC_ISO_MAP[*p & 0x7F] )
        {
LABEL_16:
          wtf_push_unknown(os, p, 1u);
        }
        else
        {
          state = 4;
        }
        break;
      case 4:
        if ( WC_ISO_MAP[*p & 0x7F] )
          wtf_push_unknown(os, p - 1, 2u);
        else
          wtf_push(os, 0x8141u, (*(p - 1) << 8) | *p);
        state = 3;
        break;
      case 5:
        if ( WC_ISO_MAP[*p] == 64 )
          wtf_push(os, 0x8141u, (*(p - 1) << 8) | *p);
        else
          wtf_push_unknown(os, p - 1, 2u);
        state = 0;
        break;
      default:
        break;
    }
LABEL_49:
    ++p;
  }
  if ( ((1 << state) & 0x36) != 0 )
    wtf_push_unknown(os, p - 1, 1u);
  return os;
}
// 80B740A: conditional instruction was optimized away because of '%state.4<6u'

//----- (080B7449) --------------------------------------------------------
void __cdecl wc_push_to_hz(Str os, wc_wchar_t cc, wc_status *st)
{
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  wc_ccs v15; // eax

  while ( cc.ccs != 0x4000 )
  {
    if ( cc.ccs > 0x4000 )
    {
      if ( cc.ccs == 33089 )
      {
        if ( !st->gl )
        {
          if ( os->length + 1 >= os->area_size )
            Strgrow(os);
          v7 = os->length;
          os->ptr[v7] = 126;
          os->length = v7 + 1;
          os->ptr[os->length] = 0;
          if ( os->length + 1 >= os->area_size )
            Strgrow(os);
          v8 = os->length;
          os->ptr[v8] = 123;
          os->length = v8 + 1;
          os->ptr[os->length] = 0;
          st->gl = 1;
        }
        if ( os->length + 1 >= os->area_size )
          Strgrow(os);
        v9 = os->length;
        os->ptr[v9] = BYTE1(cc.code) & 0x7F;
        os->length = v9 + 1;
        os->ptr[os->length] = 0;
        if ( os->length + 1 >= os->area_size )
          Strgrow(os);
        v10 = os->length;
        os->ptr[v10] = cc.code & 0x7F;
        os->length = v10 + 1;
        os->ptr[os->length] = 0;
        return;
      }
      if ( cc.ccs == 49152 )
      {
        if ( !WcOption.no_replace )
        {
          if ( st->gl )
          {
            if ( os->length + 1 >= os->area_size )
              Strgrow(os);
            v11 = os->length;
            os->ptr[v11] = 126;
            os->length = v11 + 1;
            os->ptr[os->length] = 0;
            if ( os->length + 1 >= os->area_size )
              Strgrow(os);
            v12 = os->length;
            os->ptr[v12] = 125;
            os->length = v12 + 1;
            os->ptr[os->length] = 0;
            st->gl = 0;
          }
          Strcat_charp(os, WcReplaceW);
        }
        return;
      }
    }
    else if ( cc.ccs == 322 )
    {
      if ( st->gl )
      {
        if ( os->length + 1 >= os->area_size )
          Strgrow(os);
        v3 = os->length;
        os->ptr[v3] = 126;
        os->length = v3 + 1;
        os->ptr[os->length] = 0;
        if ( os->length + 1 >= os->area_size )
          Strgrow(os);
        v4 = os->length;
        os->ptr[v4] = 125;
        os->length = v4 + 1;
        os->ptr[os->length] = 0;
        st->gl = 0;
      }
      if ( LOBYTE(cc.code) == 126 )
      {
        if ( os->length + 1 >= os->area_size )
          Strgrow(os);
        v5 = os->length;
        os->ptr[v5] = 126;
        os->length = v5 + 1;
        os->ptr[os->length] = 0;
      }
      if ( os->length + 1 >= os->area_size )
        Strgrow(os);
      v6 = os->length;
      os->ptr[v6] = cc.code;
      os->length = v6 + 1;
      os->ptr[os->length] = 0;
      return;
    }
    if ( WcOption.ucs_conv )
    {
      wc_any_to_any_ces(&cc, cc, st);
    }
    else
    {
      if ( (cc.ccs & 0x18000) != 0 )
        v15 = 49152;
      else
        v15 = 0x4000;
      cc.ccs = v15;
    }
  }
  if ( !WcOption.no_replace )
  {
    if ( st->gl )
    {
      if ( os->length + 1 >= os->area_size )
        Strgrow(os);
      v13 = os->length;
      os->ptr[v13] = 126;
      os->length = v13 + 1;
      os->ptr[os->length] = 0;
      if ( os->length + 1 >= os->area_size )
        Strgrow(os);
      v14 = os->length;
      os->ptr[v14] = 125;
      os->length = v14 + 1;
      os->ptr[os->length] = 0;
      st->gl = 0;
    }
    Strcat_charp(os, WcReplace);
  }
}

//----- (080B792D) --------------------------------------------------------
void __cdecl wc_push_to_hz_end(Str os, wc_status *st)
{
  int v2; // eax
  int v3; // eax

  if ( st->gl )
  {
    if ( os->length + 1 >= os->area_size )
      Strgrow(os);
    v2 = os->length;
    os->ptr[v2] = 126;
    os->length = v2 + 1;
    os->ptr[os->length] = 0;
    if ( os->length + 1 >= os->area_size )
      Strgrow(os);
    v3 = os->length;
    os->ptr[v3] = 125;
    os->length = v3 + 1;
    os->ptr[os->length] = 0;
    st->gl = 0;
  }
}

//----- (080B79E4) --------------------------------------------------------
void __cdecl wtf_push_iso2022(Str os, wc_ccs ccs, wc_uint32 code)
{
  if ( ccs == 33090 )
    goto LABEL_11;
  if ( ccs <= 0x8142 )
  {
    if ( ccs == 340 )
    {
LABEL_13:
      ccs = 322;
      goto LABEL_14;
    }
    if ( ccs != 33088 )
    {
      if ( ccs != 330 )
        goto LABEL_14;
      goto LABEL_13;
    }
    goto LABEL_11;
  }
  if ( ccs == 33103 )
  {
LABEL_11:
    ccs = wc_jisx0208_or_jisx02131(code);
    goto LABEL_14;
  }
  if ( ccs == 33104 || ccs == 33092 )
    ccs = wc_jisx0212_or_jisx02132(code);
LABEL_14:
  wtf_push(os, ccs, code);
}

//----- (080B7A71) --------------------------------------------------------
Str __cdecl wc_conv_from_iso2022(Str is, wc_ces ces)
{
  unsigned int v3; // eax
  wc_ccs v4; // eax
  int v5; // eax
  wc_ccs v6; // eax
  int v7; // eax
  wc_ccs v8; // eax
  wc_ccs v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  wc_status st; // [esp+14h] [ebp-64h] BYREF
  wc_ccs gr_ccs; // [esp+50h] [ebp-28h]
  wc_ccs gl_ccs; // [esp+54h] [ebp-24h]
  int state; // [esp+58h] [ebp-20h]
  wc_uchar *q; // [esp+5Ch] [ebp-1Ch]
  wc_uchar *p; // [esp+60h] [ebp-18h] BYREF
  wc_uchar *ep; // [esp+64h] [ebp-14h]
  wc_uchar *sp_0; // [esp+68h] [ebp-10h]
  Str os; // [esp+6Ch] [ebp-Ch]

  sp_0 = (wc_uchar *)is->ptr;
  ep = &sp_0[is->length];
  q = 0;
  state = 0;
  for ( p = sp_0; p < ep && (WC_ISO_MAP[*p] & 0x4F) == 0; ++p )
    ;
  if ( p == ep )
    return is;
  os = Strnew_size(is->length);
  if ( p > sp_0 )
    Strcat_charp_n(os, is->ptr, p - sp_0);
  wc_input_init(ces, &st);
  gl_ccs = st.design[st.gl];
  gr_ccs = st.design[st.gr];
  while ( p < ep )
  {
    switch ( state )
    {
      case 0:
        v3 = *p;
        if ( v3 <= 0x60 )
        {
          switch ( (char)v3 )
          {
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 16:
            case 17:
            case 18:
            case 19:
            case 20:
            case 21:
            case 22:
            case 23:
            case 24:
            case 25:
            case 26:
            case 28:
            case 29:
            case 30:
            case 31:
              if ( os->length + 1 >= os->area_size )
                Strgrow(os);
              v10 = os->length;
              os->ptr[v10] = *p;
              os->length = v10 + 1;
              os->ptr[os->length] = 0;
              goto LABEL_94;
            case 14:
              st.gl = 1;
              goto LABEL_94;
            case 15:
              st.gl = 0;
              goto LABEL_94;
            case 27:
              st.ss = 0;
              if ( wc_parse_iso2022_esc(&p, &st) )
              {
                state = st.state;
              }
              else
              {
                if ( os->length + 1 >= os->area_size )
                  Strgrow(os);
                v11 = os->length;
                os->ptr[v11] = *p;
                os->length = v11 + 1;
                os->ptr[os->length] = 0;
              }
              goto LABEL_95;
            case 32:
            case 127:
              if ( st.ss )
                v4 = st.design[st.ss];
              else
                v4 = st.design[st.gl];
              gl_ccs = v4;
              if ( (v4 & 0x200) != 0 )
                goto LABEL_20;
              if ( os->length + 1 >= os->area_size )
                Strgrow(os);
              v5 = os->length;
              os->ptr[v5] = *p;
              os->length = v5 + 1;
              os->ptr[os->length] = 0;
              goto LABEL_94;
            case 33:
            case 34:
            case 35:
            case 36:
            case 37:
            case 38:
            case 39:
            case 40:
            case 41:
            case 42:
            case 43:
            case 44:
            case 45:
            case 46:
            case 47:
            case 48:
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
            case 58:
            case 59:
            case 60:
            case 61:
            case 62:
            case 63:
            case 64:
            case 65:
            case 66:
            case 67:
            case 68:
            case 69:
            case 70:
            case 71:
            case 72:
            case 73:
            case 74:
            case 75:
            case 76:
            case 77:
            case 78:
            case 79:
            case 80:
            case 81:
            case 82:
            case 83:
            case 84:
            case 85:
            case 86:
            case 87:
            case 88:
            case 89:
            case 90:
            case 91:
            case 92:
            case 93:
            case 94:
            case 95:
            case 96:
            case 97:
            case 98:
            case 99:
            case 100:
            case 101:
            case 102:
            case 103:
            case 104:
            case 105:
            case 106:
            case 107:
            case 108:
            case 109:
            case 110:
            case 111:
            case 112:
            case 113:
            case 114:
            case 115:
            case 116:
            case 117:
            case 118:
            case 119:
            case 120:
            case 121:
            case 122:
            case 123:
            case 124:
            case 125:
            case 126:
LABEL_20:
              if ( st.ss )
                v6 = st.design[st.ss];
              else
                v6 = st.design[st.gl];
              gl_ccs = v6;
              if ( (v6 & 0x18000) != 0 )
              {
                q = p;
                state = 1;
                goto LABEL_95;
              }
              if ( gl_ccs == 256 )
              {
                if ( os->length + 1 >= os->area_size )
                  Strgrow(os);
                v7 = os->length;
                os->ptr[v7] = *p;
                os->length = v7 + 1;
                os->ptr[os->length] = 0;
              }
              else
              {
                wtf_push_iso2022(os, gl_ccs, *p);
              }
              goto LABEL_94;
            case -128:
            case -127:
            case -126:
            case -125:
            case -124:
            case -123:
            case -122:
            case -121:
            case -120:
            case -119:
            case -118:
            case -117:
            case -116:
            case -115:
            case -112:
            case -111:
            case -110:
            case -109:
            case -108:
            case -107:
            case -106:
            case -105:
            case -104:
            case -103:
            case -102:
            case -101:
            case -100:
            case -99:
            case -98:
            case -97:
              wtf_push(os, 0x4001u, *p);
              goto LABEL_94;
            case -114:
              if ( !st.design[2] )
                goto LABEL_57;
              st.ss = 2;
              goto LABEL_95;
            case -113:
              if ( !st.design[3] )
                goto LABEL_57;
              st.ss = 3;
              goto LABEL_95;
            case -96:
              if ( st.ss )
                v8 = st.design[st.ss];
              else
                v8 = st.design[st.gr];
              gr_ccs = v8;
              if ( (v8 & 0x200) != 0 )
                goto LABEL_34;
              goto LABEL_57;
            case -95:
            case -94:
            case -93:
            case -92:
            case -91:
            case -90:
            case -89:
LABEL_34:
              if ( st.ss )
                v9 = st.design[st.ss];
              else
                v9 = st.design[st.gr];
              gr_ccs = v9;
              if ( (v9 & 0x18000) != 0 )
              {
                q = p;
                state = 2;
                goto LABEL_95;
              }
              if ( gr_ccs )
                wtf_push_iso2022(os, gr_ccs, *p);
              else
LABEL_57:
                wtf_push_unknown(os, p, 1u);
              break;
            default:
              goto LABEL_81;
          }
        }
        goto LABEL_94;
      case 1:
        if ( !WC_ISO_MAP[*p] )
          goto LABEL_68;
        if ( WC_ISO_MAP[*p] == 32 )
        {
          if ( (gl_ccs & 0x200) != 0 )
          {
LABEL_68:
            wtf_push_iso2022(os, gl_ccs, (*q << 8) | *p);
          }
          else
          {
            if ( os->length + 1 >= os->area_size )
              Strgrow(os);
            v12 = os->length;
            os->ptr[v12] = *q;
            os->length = v12 + 1;
            os->ptr[os->length] = 0;
            if ( os->length + 1 >= os->area_size )
              Strgrow(os);
            v13 = os->length;
            os->ptr[v13] = *p;
            os->length = v13 + 1;
            os->ptr[os->length] = 0;
          }
        }
        else
        {
LABEL_73:
          wtf_push_unknown(os, q, 2u);
        }
        goto LABEL_94;
      case 2:
        v14 = WC_ISO_MAP[*p];
        if ( v14 != 64 && (v14 != 96 || (gr_ccs & 0x200) == 0) )
          goto LABEL_73;
        if ( gr_ccs == 34829 )
        {
          state = 5;
        }
        else
        {
          wtf_push_iso2022(os, gr_ccs, (*q << 8) | *p);
LABEL_94:
          st.ss = 0;
          state = 0;
        }
LABEL_95:
        ++p;
        break;
      case 5:
        if ( WC_ISO_MAP[*p] != 64 )
          goto LABEL_84;
        if ( *q <= 0xA0u )
        {
LABEL_81:
          if ( *q <= 0xA7u || *q > 0xB0u )
LABEL_84:
            wtf_push_unknown(os, q, 3u);
          else
            wtf_push_iso2022(os, *q + 34652, *p | (q[1] << 8));
        }
        else
        {
          wtf_push_iso2022(os, *q + 32934, *p | (q[1] << 8));
        }
        goto LABEL_94;
      case 16:
        if ( *p != 27 || p[1] != 37 )
          goto LABEL_92;
        if ( p[2] == 64 )
        {
          st.state = 0;
          state = 0;
          p += 2;
        }
        else if ( p[2] <= 0x40u || p[2] > 0x7Eu )
        {
LABEL_92:
          wtf_push_unknown(os, p, 1u);
        }
        else
        {
          p += 2;
        }
        goto LABEL_95;
      case 32:
        wtf_push_unknown(os, p, ep - p);
        return os;
      default:
        goto LABEL_94;
    }
  }
  if ( state >= 1 )
  {
    if ( state <= 2 )
    {
      wtf_push_unknown(os, p - 1, 1u);
    }
    else if ( state == 4 )
    {
      wtf_push_unknown(os, p - 2, 2u);
    }
  }
  return os;
}

//----- (080B82F1) --------------------------------------------------------
int __cdecl wc_parse_iso2022_esc(wc_uchar **ptr, wc_status *st)
{
  int result; // eax
  unsigned int v3; // eax
  int v4; // eax
  wc_ccs v5; // eax
  wc_ccs v6; // eax
  wc_ccs v7; // eax
  wc_ccs v8; // eax
  wc_ccs v9; // eax
  wc_uchar *p; // [esp+8h] [ebp-Ch]
  wc_uchar *pa; // [esp+8h] [ebp-Ch]
  wc_uchar cs_0; // [esp+Ch] [ebp-8h]
  wc_uchar g; // [esp+Dh] [ebp-7h]
  wc_uchar f; // [esp+Eh] [ebp-6h]
  wc_uchar state; // [esp+Fh] [ebp-5h]

  p = *ptr;
  f = 0;
  g = 0;
  cs_0 = 0;
  if ( **ptr != 27 )
    return 0;
  state = *p;
  for ( pa = p + 1; ; ++pa )
  {
    if ( !*pa || !state )
    {
      if ( f <= 0x3Fu || f > 0x7Eu )
        return 0;
      if ( cs_0 == 47 )
      {
        st->state = 32;
      }
      else if ( cs_0 > 0x2Fu )
      {
        switch ( cs_0 )
        {
          case 0xA8u:
            v6 = f;
            BYTE1(v6) = -127;
            st->design[g] = v6;
            break;
          case 0xACu:
            v8 = f;
            BYTE1(v8) = -126;
            st->design[g] = v8;
            break;
          case 0xA1u:
            v9 = f;
            BYTE1(v9) = 4;
            st->design[g] = v9;
            break;
        }
      }
      else
      {
        switch ( cs_0 )
        {
          case '(':
            v5 = f;
            BYTE1(v5) = 1;
            st->design[g] = v5;
            break;
          case ',':
            v7 = f;
            BYTE1(v7) = 2;
            st->design[g] = v7;
            break;
          case '%':
            if ( f == 64 )
              st->state = 0;
            else
              st->state = 16;
            break;
        }
      }
      *ptr = pa - 1;
      return 1;
    }
    if ( state == 40 )
    {
      if ( *pa == 33 )
      {
        cs_0 = -95;
        state = -95;
        g = *pa & 3;
        continue;
      }
      goto LABEL_46;
    }
    if ( state > 0x28u )
    {
      if ( state != 165 )
      {
        if ( state > 0xA5u )
        {
          if ( state != 168 && state != 172 )
            return 0;
        }
        else if ( state != 44 && state != 161 )
        {
          return 0;
        }
      }
LABEL_46:
      state = 0;
      f = *pa;
      continue;
    }
    if ( state == 33 )
      goto LABEL_46;
    if ( state <= 0x21u )
      break;
    if ( state == 36 )
    {
      v3 = *pa - 40;
      if ( v3 > 0x1A )
        return 0;
      v4 = 1 << v3;
      if ( (v4 & 0x7000000) != 0 )
      {
        state = 0;
        cs_0 = -88;
        g = 0;
        f = *pa;
      }
      else if ( (v4 & 0xF0) != 0 )
      {
        cs_0 = -84;
        state = -84;
        g = *pa & 3;
      }
      else
      {
        if ( (v4 & 0xF) == 0 )
          return 0;
        cs_0 = -88;
        state = -88;
        g = *pa & 3;
      }
    }
    else
    {
      if ( state != 37 )
        return 0;
      if ( *pa == 47 )
      {
        cs_0 = -91;
        state = -91;
      }
      else
      {
        state = 0;
        f = *pa;
      }
    }
LABEL_51:
    ;
  }
  if ( state != 27 )
    return 0;
  switch ( *pa )
  {
    case '!':
    case '"':
    case '&':
      cs_0 = 33;
      state = 33;
      goto LABEL_51;
    case '$':
      state = *pa;
      goto LABEL_51;
    case '%':
      cs_0 = 37;
      state = 37;
      goto LABEL_51;
    case '(':
    case ')':
    case '*':
    case '+':
      cs_0 = 40;
      state = 40;
      g = *pa & 3;
      goto LABEL_51;
    case ',':
    case '-':
    case '.':
    case '/':
      cs_0 = 44;
      state = 44;
      g = *pa & 3;
      goto LABEL_51;
    case 'N':
      st->ss = 2;
      *ptr = pa;
      result = 1;
      break;
    case 'O':
      st->ss = 3;
      *ptr = pa;
      result = 1;
      break;
    case 'n':
      st->gl = 2;
      *ptr = pa;
      result = 1;
      break;
    case 'o':
      st->gl = 3;
      *ptr = pa;
      result = 1;
      break;
    case '|':
      st->gr = 3;
      *ptr = pa;
      result = 1;
      break;
    case '}':
      st->gr = 2;
      *ptr = pa;
      result = 1;
      break;
    case '~':
      st->gr = 1;
      *ptr = pa;
      result = 1;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

//----- (080B871B) --------------------------------------------------------
void __cdecl wc_push_to_iso2022(Str os, wc_wchar_t cc, wc_status *st)
{
  unsigned int v3; // eax
  wc_ccs v4; // eax
  wc_ccs v5; // eax
  int v6; // eax
  int v7; // eax
  wc_wchar_t v8; // [esp+28h] [ebp-30h] BYREF
  wc_wchar_t cc2_0; // [esp+3Ch] [ebp-1Ch] BYREF
  wc_wchar_t cc2; // [esp+44h] [ebp-14h] BYREF
  wc_bool retry; // [esp+4Dh] [ebp-Bh]
  wc_bool is_wide; // [esp+4Eh] [ebp-Ah]
  wc_uchar g; // [esp+4Fh] [ebp-9h]

  g = 0;
  is_wide = 0;
  for ( retry = 0; ; retry = 1 )
  {
    while ( 1 )
    {
      v3 = cc.ccs & 0xFF00;
      if ( v3 == 0x4000 )
      {
        if ( WcOption.no_replace )
          return;
        cc.ccs = 322;
        g = cs94_gmap[2];
        cc.code = *WcReplace;
        goto LABEL_47;
      }
      if ( v3 <= 0x4000 )
        break;
      switch ( v3 )
      {
        case 0x8200u:
          is_wide = 1;
          g = cs96w_gmap[LOBYTE(cc.ccs) - 64];
          goto LABEL_47;
        case 0xC000u:
          if ( WcOption.no_replace )
            return;
          is_wide = 1;
          cc.ccs = 322;
          g = cs94_gmap[2];
          cc.code = (*WcReplaceW << 8) | WcReplaceW[1];
          goto LABEL_47;
        case 0x8100u:
          is_wide = 1;
          if ( cc.ccs == 33092 )
          {
            if ( WcOption.use_jisx0212
              || !WcOption.use_jisx0213
              || !WcOption.ucs_conv
              || (wc_jisx0212_to_jisx0213(&cc2, cc), cc2.ccs != 33103) && cc2.ccs != 33104 )
            {
LABEL_30:
              g = cs94w_gmap[LOBYTE(cc.ccs) - 64];
              goto LABEL_47;
            }
            cc = cc2;
          }
          else
          {
            if ( cc.ccs < 0x8144 )
              goto LABEL_30;
            if ( cc.ccs - 33103 > 1 )
              goto LABEL_30;
            if ( WcOption.use_jisx0213 )
              goto LABEL_30;
            if ( !WcOption.use_jisx0212 )
              goto LABEL_30;
            if ( !WcOption.ucs_conv )
              goto LABEL_30;
            wc_jisx0213_to_jisx0212(&v8, cc);
            cc2 = v8;
            if ( v8.ccs != 33092 )
              goto LABEL_30;
            cc.ccs = 33092;
            cc.code = cc2.code;
          }
          break;
        default:
LABEL_38:
          if ( cs94w_gmap[3] && (wc_johab_to_ksx1001(&cc2_0, cc), cc2_0.ccs == 33091) )
          {
            cc.ccs = 33091;
            cc.code = cc2_0.code;
          }
          else if ( WcOption.ucs_conv )
          {
            wc_any_to_iso2022(&cc, cc, st);
          }
          else
          {
            if ( (cc.ccs & 0x18000) != 0 )
              v4 = 49152;
            else
              v4 = 0x4000;
            cc.ccs = v4;
          }
          break;
      }
    }
    switch ( v3 )
    {
      case 0x200u:
        g = cs96_gmap[LOBYTE(cc.ccs) - 64];
        break;
      case 0x400u:
        g = cs942_gmap[LOBYTE(cc.ccs) - 64];
        break;
      case 0x100u:
        if ( cc.ccs == 322 )
          cc.ccs = st->g0_ccs;
        g = cs94_gmap[LOBYTE(cc.ccs) - 64];
        break;
      default:
        goto LABEL_38;
    }
LABEL_47:
    if ( g )
      break;
    if ( !WcOption.ucs_conv || retry )
    {
      if ( (cc.ccs & 0x18000) != 0 )
        v5 = 49152;
      else
        v5 = 0x4000;
      cc.ccs = v5;
    }
    else
    {
      wc_any_to_any_ces(&v8, cc, st);
      cc = v8;
    }
  }
  wc_push_iso2022_esc(os, cc.ccs, g, 1u, st);
  if ( is_wide )
  {
    if ( os->length + 1 >= os->area_size )
      Strgrow(os);
    v6 = os->length;
    os->ptr[v6] = BYTE1(cc.code) & 0x7F;
    os->length = v6 + 1;
    os->ptr[os->length] = 0;
  }
  if ( os->length + 1 >= os->area_size )
    Strgrow(os);
  v7 = os->length;
  os->ptr[v7] = cc.code & 0x7F;
  os->length = v7 + 1;
  os->ptr[os->length] = 0;
}

//----- (080B8B9C) --------------------------------------------------------
void __cdecl wc_push_to_iso2022_end(Str os, wc_status *st)
{
  if ( st->design[1] && st->design[1] != st->g1_ccs )
    wc_push_iso2022_esc(os, st->g1_ccs, 0x29u, 0, st);
  wc_push_iso2022_esc(os, st->g0_ccs, 0x28u, 1u, st);
}

//----- (080B8C16) --------------------------------------------------------
void __cdecl wc_push_iso2022_esc(Str os, wc_ccs ccs, wc_uchar g, wc_uint8 invoke, wc_status *st)
{
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  int v15; // eax
  int v16; // eax
  wc_uint8 g_invoke; // [esp+2Fh] [ebp-9h]

  g_invoke = g & 3;
  if ( st->design[g & 3] != ccs )
  {
    if ( os->length + 1 >= os->area_size )
      Strgrow(os);
    v5 = os->length;
    os->ptr[v5] = 27;
    os->length = v5 + 1;
    os->ptr[os->length] = 0;
    if ( (ccs & 0x18000) != 0 )
    {
      if ( os->length + 1 >= os->area_size )
        Strgrow(os);
      v6 = os->length;
      os->ptr[v6] = 36;
      os->length = v6 + 1;
      os->ptr[os->length] = 0;
      if ( g_invoke || ccs != 33088 && ccs != 33090 && ccs != 33089 )
      {
        if ( os->length + 1 >= os->area_size )
          Strgrow(os);
        v7 = os->length;
        os->ptr[v7] = g;
        os->length = v7 + 1;
        os->ptr[os->length] = 0;
      }
    }
    else
    {
      if ( os->length + 1 >= os->area_size )
        Strgrow(os);
      v8 = os->length;
      os->ptr[v8] = g;
      os->length = v8 + 1;
      os->ptr[os->length] = 0;
      if ( (ccs & 0x700) == 1024 )
      {
        if ( os->length + 1 >= os->area_size )
          Strgrow(os);
        v9 = os->length;
        os->ptr[v9] = 33;
        os->length = v9 + 1;
        os->ptr[os->length] = 0;
      }
    }
    if ( os->length + 1 >= os->area_size )
      Strgrow(os);
    v10 = os->length;
    os->ptr[v10] = ccs;
    os->length = v10 + 1;
    os->ptr[os->length] = 0;
    st->design[g_invoke] = ccs;
  }
  if ( invoke )
  {
    if ( g_invoke == 1 )
    {
      if ( st->gl != 1 )
      {
        if ( os->length + 1 >= os->area_size )
          Strgrow(os);
        v12 = os->length;
        os->ptr[v12] = 14;
        os->length = v12 + 1;
        os->ptr[os->length] = 0;
        st->gl = 1;
      }
    }
    else if ( g_invoke > 1u )
    {
      if ( g_invoke == 2 )
      {
        if ( os->length + 1 >= os->area_size )
          Strgrow(os);
        v13 = os->length;
        os->ptr[v13] = 27;
        os->length = v13 + 1;
        os->ptr[os->length] = 0;
        if ( os->length + 1 >= os->area_size )
          Strgrow(os);
        v14 = os->length;
        os->ptr[v14] = 78;
        os->length = v14 + 1;
        os->ptr[os->length] = 0;
      }
      else if ( g_invoke == 3 )
      {
        if ( os->length + 1 >= os->area_size )
          Strgrow(os);
        v15 = os->length;
        os->ptr[v15] = 27;
        os->length = v15 + 1;
        os->ptr[os->length] = 0;
        if ( os->length + 1 >= os->area_size )
          Strgrow(os);
        v16 = os->length;
        os->ptr[v16] = 79;
        os->length = v16 + 1;
        os->ptr[os->length] = 0;
      }
    }
    else if ( !g_invoke && st->gl )
    {
      if ( os->length + 1 >= os->area_size )
        Strgrow(os);
      v11 = os->length;
      os->ptr[v11] = 15;
      os->length = v11 + 1;
      os->ptr[os->length] = 0;
      st->gl = 0;
    }
  }
}

//----- (080B90B4) --------------------------------------------------------
void __cdecl wc_push_to_euc(Str os, wc_wchar_t cc, wc_status *st)
{
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  wc_ccs v7; // eax
  wc_wchar_t v8; // [esp+18h] [ebp-20h] BYREF
  wc_ccs g1_ccs; // [esp+2Ch] [ebp-Ch]

  g1_ccs = st->ces_info->gset[1].ccs;
  while ( 1 )
  {
    if ( cc.ccs == g1_ccs )
    {
      if ( os->length + 1 >= os->area_size )
        Strgrow(os);
      v3 = os->length;
      os->ptr[v3] = BYTE1(cc.code) | 0x80;
      os->length = v3 + 1;
      os->ptr[os->length] = 0;
      if ( os->length + 1 >= os->area_size )
        Strgrow(os);
      v4 = os->length;
      os->ptr[v4] = LOBYTE(cc.code) | 0x80;
      os->length = v4 + 1;
      os->ptr[os->length] = 0;
      return;
    }
    if ( cc.ccs == 16385 )
      break;
    if ( cc.ccs <= 0x4001 )
    {
      if ( cc.ccs == 322 )
      {
        if ( os->length + 1 >= os->area_size )
          Strgrow(os);
        v5 = os->length;
        os->ptr[v5] = cc.code;
        os->length = v5 + 1;
        os->ptr[os->length] = 0;
        return;
      }
      if ( cc.ccs == 0x4000 )
      {
        if ( !WcOption.no_replace )
          Strcat_charp(os, WcReplace);
        return;
      }
      goto LABEL_29;
    }
    if ( cc.ccs < 0x880F )
      goto LABEL_29;
    if ( cc.ccs <= 0x8812 )
    {
      if ( st->ces_info->id != 3149849 )
        goto LABEL_29;
      wc_johab_to_ksx1001(&cc, cc);
    }
    else
    {
      if ( cc.ccs == 49152 )
      {
        if ( !WcOption.no_replace )
          Strcat_charp(os, WcReplaceW);
        return;
      }
LABEL_29:
      if ( WcOption.ucs_conv )
      {
        wc_any_to_any_ces(&v8, cc, st);
        cc = v8;
      }
      else
      {
        if ( (cc.ccs & 0x18000) != 0 )
          v7 = 49152;
        else
          v7 = 0x4000;
        cc.ccs = v7;
      }
    }
  }
  if ( os->length + 1 >= os->area_size )
    Strgrow(os);
  v6 = os->length;
  os->ptr[v6] = LOBYTE(cc.code) | 0x80;
  os->length = v6 + 1;
  os->ptr[os->length] = 0;
}

//----- (080B9358) --------------------------------------------------------
void __cdecl wc_push_to_eucjp(Str os, wc_wchar_t cc, wc_status *st)
{
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  wc_ccs v9; // eax
  int v10; // eax
  int v11; // eax
  wc_wchar_t v12; // [esp+18h] [ebp-10h] BYREF

  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          if ( cc.ccs == 33090 )
            goto LABEL_62;
          if ( cc.ccs > 0x8142 )
            break;
          if ( cc.ccs == 329 )
          {
            if ( WcOption.use_jisx0201k )
            {
              if ( os->length + 1 >= os->area_size )
                Strgrow(os);
              v4 = os->length;
              os->ptr[v4] = -114;
              os->length = v4 + 1;
              os->ptr[os->length] = 0;
              if ( os->length + 1 >= os->area_size )
                Strgrow(os);
              v5 = os->length;
              os->ptr[v5] = LOBYTE(cc.code) | 0x80;
              os->length = v5 + 1;
              os->ptr[os->length] = 0;
              return;
            }
            if ( WcOption.fix_width_conv )
              cc.ccs = 0x4000;
            else
              wc_jisx0201k_to_jisx0208(&cc, cc);
          }
          else
          {
            if ( cc.ccs > 0x149 )
            {
              if ( cc.ccs == 0x4000 )
              {
                if ( !WcOption.no_replace )
                  Strcat_charp(os, WcReplace);
                return;
              }
              if ( cc.ccs == 16385 )
              {
                if ( os->length + 1 >= os->area_size )
                  Strgrow(os);
                v8 = os->length;
                os->ptr[v8] = LOBYTE(cc.code) | 0x80;
                os->length = v8 + 1;
                os->ptr[os->length] = 0;
                return;
              }
            }
            else if ( cc.ccs == 322 )
            {
              if ( os->length + 1 >= os->area_size )
                Strgrow(os);
              v3 = os->length;
              os->ptr[v3] = cc.code;
              os->length = v3 + 1;
              os->ptr[os->length] = 0;
              return;
            }
LABEL_56:
            if ( WcOption.ucs_conv )
            {
              wc_any_to_any_ces(&v12, cc, st);
              cc = v12;
            }
            else
            {
              if ( (cc.ccs & 0x18000) != 0 )
                v9 = 49152;
              else
                v9 = 0x4000;
              cc.ccs = v9;
            }
          }
        }
        if ( cc.ccs != 33103 )
          break;
        if ( WcOption.use_jisx0213 )
          goto LABEL_62;
        if ( WcOption.ucs_conv && WcOption.use_jisx0212 )
          goto LABEL_32;
        cc.ccs = 49152;
      }
      if ( cc.ccs > 0x814F )
        break;
      if ( cc.ccs != 33092 )
        goto LABEL_56;
      if ( WcOption.use_jisx0212 )
      {
        if ( os->length + 1 >= os->area_size )
          Strgrow(os);
        v6 = os->length;
        os->ptr[v6] = -113;
        os->length = v6 + 1;
        os->ptr[os->length] = 0;
LABEL_62:
        if ( os->length + 1 >= os->area_size )
          Strgrow(os);
        v10 = os->length;
        os->ptr[v10] = BYTE1(cc.code) | 0x80;
        os->length = v10 + 1;
        os->ptr[os->length] = 0;
        if ( os->length + 1 >= os->area_size )
          Strgrow(os);
        v11 = os->length;
        os->ptr[v11] = LOBYTE(cc.code) | 0x80;
        os->length = v11 + 1;
        os->ptr[os->length] = 0;
        return;
      }
      if ( WcOption.ucs_conv && WcOption.use_jisx0213 )
      {
        wc_jisx0212_to_jisx0213(&v12, cc);
        cc = v12;
      }
      else
      {
        cc.ccs = 49152;
      }
    }
    if ( cc.ccs != 33104 )
      break;
    if ( WcOption.use_jisx0213 )
    {
      if ( os->length + 1 >= os->area_size )
        Strgrow(os);
      v7 = os->length;
      os->ptr[v7] = -113;
      os->length = v7 + 1;
      os->ptr[os->length] = 0;
      goto LABEL_62;
    }
    if ( WcOption.ucs_conv && WcOption.use_jisx0212 )
    {
LABEL_32:
      wc_jisx0213_to_jisx0212(&v12, cc);
      cc = v12;
    }
    else
    {
      cc.ccs = 49152;
    }
  }
  if ( cc.ccs != 49152 )
    goto LABEL_56;
  if ( !WcOption.no_replace )
    Strcat_charp(os, WcReplaceW);
}

//----- (080B9879) --------------------------------------------------------
void __cdecl wc_push_to_euctw(Str os, wc_wchar_t cc, wc_status *st)
{
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  wc_ccs v9; // eax
  int v10; // eax
  int v11; // eax

  while ( cc.ccs <= 0x814D )
  {
    if ( cc.ccs >= 0x8148 )
    {
      if ( os->length + 1 >= os->area_size )
        Strgrow(os);
      v4 = os->length;
      os->ptr[v4] = -114;
      os->length = v4 + 1;
      os->ptr[os->length] = 0;
      if ( os->length + 1 >= os->area_size )
        Strgrow(os);
      v5 = os->length;
      os->ptr[v5] = LOBYTE(cc.ccs) + 90;
      os->length = v5 + 1;
      os->ptr[os->length] = 0;
LABEL_40:
      if ( os->length + 1 >= os->area_size )
        Strgrow(os);
      v10 = os->length;
      os->ptr[v10] = BYTE1(cc.code) | 0x80;
      os->length = v10 + 1;
      os->ptr[os->length] = 0;
      if ( os->length + 1 >= os->area_size )
        Strgrow(os);
      v11 = os->length;
      os->ptr[v11] = LOBYTE(cc.code) | 0x80;
      os->length = v11 + 1;
      os->ptr[os->length] = 0;
      return;
    }
    if ( cc.ccs == 0x4000 )
    {
      if ( !WcOption.no_replace )
        Strcat_charp(os, WcReplace);
      return;
    }
    if ( cc.ccs > 0x4000 )
    {
      if ( cc.ccs == 16385 )
      {
        if ( os->length + 1 >= os->area_size )
          Strgrow(os);
        v8 = os->length;
        os->ptr[v8] = LOBYTE(cc.code) | 0x80;
        os->length = v8 + 1;
        os->ptr[os->length] = 0;
        return;
      }
      if ( cc.ccs == 33095 )
        goto LABEL_40;
    }
    else if ( cc.ccs == 322 )
    {
      if ( os->length + 1 >= os->area_size )
        Strgrow(os);
      v3 = os->length;
      os->ptr[v3] = cc.code;
      os->length = v3 + 1;
      os->ptr[os->length] = 0;
      return;
    }
LABEL_34:
    if ( WcOption.ucs_conv )
    {
      wc_any_to_any_ces(&cc, cc, st);
    }
    else
    {
      if ( (cc.ccs & 0x18000) != 0 )
        v9 = 49152;
      else
        v9 = 0x4000;
      cc.ccs = v9;
    }
  }
  if ( cc.ccs < 0x8804 )
    goto LABEL_34;
  if ( cc.ccs <= 0x880C )
  {
    if ( os->length + 1 >= os->area_size )
      Strgrow(os);
    v6 = os->length;
    os->ptr[v6] = -114;
    os->length = v6 + 1;
    os->ptr[os->length] = 0;
    if ( os->length + 1 >= os->area_size )
      Strgrow(os);
    v7 = os->length;
    os->ptr[v7] = LOBYTE(cc.ccs) - 92;
    os->length = v7 + 1;
    os->ptr[os->length] = 0;
    goto LABEL_40;
  }
  if ( cc.ccs != 49152 )
    goto LABEL_34;
  if ( !WcOption.no_replace )
    Strcat_charp(os, WcReplaceW);
}

//----- (080B9C24) --------------------------------------------------------
void __cdecl wc_push_to_iso8859(Str os, wc_wchar_t cc, wc_status *st)
{
  int v3; // eax
  int v4; // eax
  int v5; // eax
  wc_ccs v6; // eax
  wc_ccs g1_ccs; // [esp+1Ch] [ebp-Ch]

  g1_ccs = st->ces_info->gset[1].ccs;
  while ( 1 )
  {
    if ( cc.ccs == g1_ccs )
    {
      if ( os->length + 1 >= os->area_size )
        Strgrow(os);
      v3 = os->length;
      os->ptr[v3] = LOBYTE(cc.code) | 0x80;
      os->length = v3 + 1;
      os->ptr[os->length] = 0;
      return;
    }
    if ( cc.ccs == 0x4000 )
      break;
    if ( cc.ccs > 0x4000 )
    {
      if ( cc.ccs == 16385 )
      {
        if ( os->length + 1 >= os->area_size )
          Strgrow(os);
        v5 = os->length;
        os->ptr[v5] = LOBYTE(cc.code) | 0x80;
        os->length = v5 + 1;
        os->ptr[os->length] = 0;
        return;
      }
      if ( cc.ccs == 49152 )
      {
        if ( !WcOption.no_replace )
          Strcat_charp(os, WcReplaceW);
        return;
      }
    }
    else if ( cc.ccs == 322 )
    {
      if ( os->length + 1 >= os->area_size )
        Strgrow(os);
      v4 = os->length;
      os->ptr[v4] = cc.code;
      os->length = v4 + 1;
      os->ptr[os->length] = 0;
      return;
    }
    if ( WcOption.ucs_conv )
    {
      wc_any_to_any_ces(&cc, cc, st);
    }
    else
    {
      if ( (cc.ccs & 0x18000) != 0 )
        v6 = 49152;
      else
        v6 = 0x4000;
      cc.ccs = v6;
    }
  }
  if ( !WcOption.no_replace )
    Strcat_charp(os, WcReplace);
}

//----- (080B9E12) --------------------------------------------------------
void __cdecl wc_create_gmap(wc_status *st)
{
  unsigned int v1; // eax
  unsigned int v2; // eax
  int f; // [esp+0h] [ebp-10h]
  int i; // [esp+4h] [ebp-Ch]
  int ia; // [esp+4h] [ebp-Ch]
  int ib; // [esp+4h] [ebp-Ch]
  wc_uchar *gset_ext; // [esp+8h] [ebp-8h]
  wc_gset *gset; // [esp+Ch] [ebp-4h]

  gset = st->ces_info->gset;
  gset_ext = st->ces_info->gset_ext;
  if ( WcOption.strict_iso2022 )
  {
    for ( i = 0; i <= 63; ++i )
    {
      cs94_gmap[i] = 0;
      cs96_gmap[i] = 0;
      cs94w_gmap[i] = 0;
      cs96w_gmap[i] = 0;
      cs942_gmap[i] = 0;
    }
  }
  else
  {
    for ( ia = 0; ia <= 63; ++ia )
    {
      cs94_gmap[ia] = *gset_ext;
      cs96_gmap[ia] = gset_ext[1];
      cs94w_gmap[ia] = gset_ext[2];
      cs96w_gmap[ia] = gset_ext[3];
      cs942_gmap[ia] = *gset_ext;
    }
  }
  for ( ib = 0; gset[ib].ccs; ++ib )
  {
    f = (unsigned __int8)gset[ib].ccs - 64;
    v1 = gset[ib].ccs & 0xFF00;
    if ( v1 == 1024 )
    {
      cs942_gmap[f] = gset[ib].g;
    }
    else if ( v1 > 0x400 )
    {
      if ( v1 == 33024 )
      {
        v2 = gset[ib].ccs;
        if ( v2 == 33092 )
        {
          if ( WcOption.use_jisx0212 )
            goto LABEL_28;
        }
        else if ( v2 < 0x8144 || v2 - 33103 > 1 || WcOption.use_jisx0213 )
        {
LABEL_28:
          cs94w_gmap[f] = gset[ib].g;
          continue;
        }
      }
      else if ( v1 == 33280 )
      {
        cs96w_gmap[f] = gset[ib].g;
      }
    }
    else if ( v1 == 256 )
    {
      if ( gset[ib].ccs != 329 || WcOption.use_jisx0201k )
        cs94_gmap[f] = gset[ib].g;
    }
    else if ( v1 == 512 )
    {
      cs96_gmap[f] = gset[ib].g;
    }
  }
}

//----- (080BA052) --------------------------------------------------------
Str __cdecl wc_char_conv_from_iso2022(wc_uchar c, wc_status *st)
{
  int v2; // edx
  int v3; // edx
  Str v4; // eax
  int v5; // edx
  size_t v6; // eax
  Str result; // eax
  Str v8; // eax
  int v9; // edx
  size_t v10; // eax
  Str v11; // eax
  int v12; // edx
  size_t v13; // eax
  size_t v14; // eax
  int v15; // eax
  size_t v16; // eax
  size_t v17; // eax
  size_t v18; // eax
  size_t v19; // eax
  size_t v20; // eax
  size_t v21; // eax
  size_t v22; // eax
  size_t v23; // eax
  size_t v24; // eax
  size_t v25; // eax
  wc_ccs gr_ccs; // [esp+24h] [ebp-14h]
  wc_ccs gl_ccs; // [esp+28h] [ebp-10h]
  wc_uchar *p; // [esp+2Ch] [ebp-Ch] BYREF

  if ( st->state == -1 )
  {
    st->state = 0;
    os_4122 = Strnew_size(8);
    nbuf_4124 = 0;
  }
  if ( st->ss )
    v2 = st->ss;
  else
    v2 = st->gl;
  gl_ccs = st->design[v2];
  if ( st->ss )
    v3 = st->ss;
  else
    v3 = st->gr;
  gr_ccs = st->design[v3];
  switch ( st->state )
  {
    case 0:
      switch ( WC_ISO_MAP[c] )
      {
        case 0u:
          goto LABEL_15;
        case 0x10u:
          if ( os_4122->length + 1 >= os_4122->area_size )
            Strgrow(os_4122);
          v11 = os_4122;
          v12 = os_4122->length;
          os_4122->ptr[v12] = c;
          v11->length = v12 + 1;
          os_4122->ptr[os_4122->length] = 0;
          goto LABEL_83;
        case 0x11u:
          st->gl = 1;
          goto LABEL_83;
        case 0x12u:
          st->gl = 0;
          goto LABEL_83;
        case 0x13u:
          v13 = nbuf_4124;
          buf_4123[nbuf_4124] = c;
          nbuf_4124 = v13 + 1;
          st->state = 27;
          return 0;
        case 0x20u:
          if ( (gl_ccs & 0x200) != 0 )
          {
LABEL_15:
            if ( (gl_ccs & 0x18000) != 0 )
            {
              v6 = nbuf_4124;
              buf_4123[nbuf_4124] = c;
              nbuf_4124 = v6 + 1;
              st->state = 1;
              return 0;
            }
            if ( gl_ccs == 256 )
            {
              if ( os_4122->length + 1 >= os_4122->area_size )
                Strgrow(os_4122);
              v8 = os_4122;
              v9 = os_4122->length;
              os_4122->ptr[v9] = c;
              v8->length = v9 + 1;
              os_4122->ptr[os_4122->length] = 0;
            }
            else
            {
              wtf_push_iso2022(os_4122, gl_ccs, c);
            }
          }
          else
          {
            if ( os_4122->length + 1 >= os_4122->area_size )
              Strgrow(os_4122);
            v4 = os_4122;
            v5 = os_4122->length;
            os_4122->ptr[v5] = c;
            v4->length = v5 + 1;
            os_4122->ptr[os_4122->length] = 0;
          }
          goto LABEL_83;
        case 0x40u:
          goto LABEL_23;
        case 0x54u:
          if ( !st->design[2] )
            return os_4122;
          st->ss = 2;
          return 0;
        case 0x55u:
          if ( !st->design[3] )
            return os_4122;
          st->ss = 3;
          return 0;
        case 0x60u:
          if ( (gr_ccs & 0x200) == 0 )
            goto LABEL_83;
LABEL_23:
          if ( (gr_ccs & 0x18000) != 0 )
          {
            v10 = nbuf_4124;
            buf_4123[nbuf_4124] = c;
            nbuf_4124 = v10 + 1;
            st->state = 2;
            return 0;
          }
          if ( gr_ccs )
            wtf_push_iso2022(os_4122, gr_ccs, c);
          break;
        default:
          goto LABEL_83;
      }
      goto LABEL_83;
    case 1:
      if ( !WC_ISO_MAP[c] || WC_ISO_MAP[c] == 32 && (gl_ccs & 0x200) != 0 )
      {
        v14 = nbuf_4124;
        buf_4123[nbuf_4124] = c;
        nbuf_4124 = v14 + 1;
        wtf_push_iso2022(os_4122, gl_ccs, (unsigned __int8)byte_817FF09 | (buf_4123[0] << 8));
      }
      st->state = 0;
      goto LABEL_83;
    case 2:
      v15 = WC_ISO_MAP[c];
      if ( v15 != 64 && (v15 != 96 || (gr_ccs & 0x200) == 0) )
        goto LABEL_52;
      if ( gr_ccs == 34829 )
      {
        v16 = nbuf_4124;
        buf_4123[nbuf_4124] = c;
        nbuf_4124 = v16 + 1;
        st->state = 5;
        return 0;
      }
      v17 = nbuf_4124;
      buf_4123[nbuf_4124] = c;
      nbuf_4124 = v17 + 1;
      wtf_push_iso2022(os_4122, gr_ccs, (unsigned __int8)byte_817FF09 | (buf_4123[0] << 8));
LABEL_52:
      st->state = 0;
      goto LABEL_83;
    case 5:
      if ( WC_ISO_MAP[c] != 64 )
        goto LABEL_60;
      v18 = nbuf_4124;
      buf_4123[nbuf_4124] = c;
      nbuf_4124 = v18 + 1;
      if ( buf_4123[0] <= 0xA0u || buf_4123[0] > 0xA7u )
      {
        if ( buf_4123[0] <= 0xA7u || buf_4123[0] > 0xB0u )
LABEL_60:
          st->state = 0;
        else
          wtf_push_iso2022(
            os_4122,
            buf_4123[0] + 34652,
            (unsigned __int8)byte_817FF0A | ((unsigned __int8)byte_817FF09 << 8));
      }
      else
      {
        wtf_push_iso2022(
          os_4122,
          buf_4123[0] + 32934,
          (unsigned __int8)byte_817FF0A | ((unsigned __int8)byte_817FF09 << 8));
      }
      goto LABEL_83;
    case 0x1B:
      switch ( c )
      {
        case '!':
        case '"':
        case '&':
        case ',':
        case '-':
        case '.':
        case '/':
          v20 = nbuf_4124;
          buf_4123[nbuf_4124] = c;
          nbuf_4124 = v20 + 1;
          st->state = 44;
          result = 0;
          break;
        case '$':
        case '%':
          v21 = nbuf_4124;
          buf_4123[nbuf_4124] = c;
          nbuf_4124 = v21 + 1;
          st->state = c;
          result = 0;
          break;
        case '(':
        case ')':
        case '*':
        case '+':
          v19 = nbuf_4124;
          buf_4123[nbuf_4124] = c;
          nbuf_4124 = v19 + 1;
          st->state = 40;
          result = 0;
          break;
        case 'N':
          st->ss = 2;
          st->state = 0;
          result = 0;
          break;
        case 'O':
          st->ss = 3;
          st->state = 0;
          result = 0;
          break;
        case 'n':
          st->gl = 2;
          goto LABEL_83;
        case 'o':
          st->gl = 3;
          goto LABEL_83;
        case '|':
          st->gr = 3;
          goto LABEL_83;
        case '}':
          st->gr = 2;
          goto LABEL_83;
        default:
          goto LABEL_83;
      }
      return result;
    case 0x24:
      if ( c < 0x28u )
        goto LABEL_83;
      if ( c <= 0x2Fu )
      {
        v22 = nbuf_4124;
        buf_4123[nbuf_4124] = c;
        nbuf_4124 = v22 + 1;
        st->state = 44;
        result = 0;
      }
      else
      {
        if ( (unsigned int)c - 64 <= 2 )
        {
LABEL_82:
          v25 = nbuf_4124;
          buf_4123[nbuf_4124] = c;
          nbuf_4124 = v25 + 1;
          p = buf_4123;
          wc_parse_iso2022_esc(&p, st);
        }
LABEL_83:
        st->ss = 0;
        st->state = -1;
        result = os_4122;
      }
      return result;
    case 0x25:
      if ( c != 47 )
        goto LABEL_82;
      v23 = nbuf_4124;
      buf_4123[nbuf_4124] = c;
      nbuf_4124 = v23 + 1;
      st->state = 41;
      return 0;
    case 0x28:
      if ( c != 33 )
        goto LABEL_82;
      v24 = nbuf_4124;
      buf_4123[nbuf_4124] = c;
      nbuf_4124 = v24 + 1;
      st->state = 44;
      return 0;
    case 0x2C:
      goto LABEL_82;
    default:
      goto LABEL_83;
  }
}
// 817FF09: using guessed type char byte_817FF09;
// 817FF0A: using guessed type char byte_817FF0A;

//----- (080BA840) --------------------------------------------------------
wc_wchar_t *__userpurge wc_jisx0201k_to_jisx0208@<eax>(wc_wchar_t *retstr, wc_wchar_t cc)
{
  wc_ccs v2; // eax
  wc_uint32 cc_4; // [esp+10h] [ebp+10h]

  cc_4 = jisx0201k_jisx0208_map[cc.code & 0x7F];
  if ( cc_4 )
    v2 = 33090;
  else
    v2 = 49152;
  retstr->ccs = v2;
  retstr->code = cc_4;
  return retstr;
}

//----- (080BA881) --------------------------------------------------------
wc_wchar_t *__userpurge wc_jisx0212_to_jisx0213@<eax>(wc_wchar_t *retstr, wc_wchar_t cc)
{
  wc_uint32 v2; // edx
  wc_wchar_t cc2; // [esp+18h] [ebp-10h] BYREF

  if ( !t1_2377 )
  {
    t1_2377 = wc_get_ucs_table(0x814Fu);
    t2_2378 = wc_get_ucs_table(0x8150u);
  }
  wc_any_to_any(&cc2, cc, t2_2378);
  if ( cc2.ccs == 33092 )
  {
    v2 = cc2.code;
    retstr->ccs = 33092;
    retstr->code = v2;
  }
  else
  {
    wc_any_to_any(retstr, cc, t1_2377);
  }
  return retstr;
}

//----- (080BA91D) --------------------------------------------------------
wc_wchar_t *__userpurge wc_jisx0213_to_jisx0212@<eax>(wc_wchar_t *retstr, wc_wchar_t cc)
{
  if ( !t_2393 )
    t_2393 = wc_get_ucs_table(0x8144u);
  wc_any_to_any(retstr, cc, t_2393);
  return retstr;
}

//----- (080BA96C) --------------------------------------------------------
wc_ccs __cdecl wc_jisx0208_or_jisx02131(wc_uint16 code)
{
  wc_ccs result; // eax

  if ( wc_map_range_search(code & 0x7F7F, jisx0208_jisx02131_map, 18) )
    result = 33103;
  else
    result = 33090;
  return result;
}

//----- (080BA9AC) --------------------------------------------------------
wc_ccs __cdecl wc_jisx0212_or_jisx02132(wc_uint16 code)
{
  wc_ccs result; // eax

  if ( wc_jisx0212_jisx02132_map[HIBYTE(code) & 0x7F] )
    result = 33104;
  else
    result = 33092;
  return result;
}

//----- (080BA9E4) --------------------------------------------------------
wc_wchar_t *__userpurge wc_johab_to_ksx1001@<eax>(wc_wchar_t *retstr, wc_wchar_t cc)
{
  wc_uint32 v2; // edx
  wc_wchar_t v4; // [esp+18h] [ebp-10h] BYREF

  if ( cc.ccs > 0x8811 )
  {
    if ( cc.ccs == 34834 )
    {
      if ( cc.code <= 0x2120 )
        cc.ccs = 49152;
      else
        cc.ccs = 33091;
    }
    goto LABEL_16;
  }
  if ( cc.ccs >= 0x8810 )
  {
    if ( WcOption.ucs_conv )
    {
      if ( !t_2389 )
        t_2389 = wc_get_ucs_table(0x8143u);
      wc_any_to_any(&cc, cc, t_2389);
    }
    else
    {
      cc.ccs = 49152;
    }
    goto LABEL_16;
  }
  if ( cc.ccs != 34831 )
  {
LABEL_16:
    v2 = cc.code;
    retstr->ccs = cc.ccs;
    retstr->code = v2;
    return retstr;
  }
  wc_johab_to_cs128w(&v4, (wc_wchar_t)__PAIR64__(cc.code, 34831));
  wc_johab_to_ksx1001(retstr, v4);
  return retstr;
}

//----- (080BAAD5) --------------------------------------------------------
wc_wchar_t *__userpurge wc_ksx1001_to_johab@<eax>(wc_wchar_t *retstr, wc_wchar_t cc)
{
  wc_uint32 v2; // edx
  wc_uint32 v3; // eax
  wc_uint32 v4; // edx

  cc.code = cc.code & 0x7F7F;
  if ( (cc.code <= 0x2120 || cc.code > 0x2420)
    && (cc.code <= 0x2453 || cc.code > 0x2C7E)
    && (cc.code <= 0x4A20 || cc.code > 0x7D7E) )
  {
    if ( WcOption.ucs_conv )
    {
      v3 = wc_any_to_ucs(cc);
      wc_ucs_to_johab(&cc, v3);
    }
    else
    {
      cc.ccs = 49152;
    }
    v4 = cc.code;
    retstr->ccs = cc.ccs;
    retstr->code = v4;
  }
  else
  {
    cc.ccs = 34834;
    v2 = cc.code;
    retstr->ccs = 34834;
    retstr->code = v2;
  }
  return retstr;
}

//----- (080BAB86) --------------------------------------------------------
wc_wchar_t *wc_ucs_to_johab(wc_wchar_t *retstr, wc_uint32 ucs)
{
  wc_uint32 v2; // edx
  wc_wchar_t v4; // [esp+18h] [ebp-20h] BYREF
  wc_wchar_t cc; // [esp+24h] [ebp-14h] BYREF
  wc_table *t; // [esp+2Ch] [ebp-Ch]

  if ( ucs <= 0xABFF || ucs > 0xD7A3 )
  {
    if ( ucs <= 0x3130 || ucs > 0x3163 )
    {
      t = wc_get_ucs_table(0x8812u);
      wc_ucs_to_any(&v4, ucs, t);
      cc = v4;
    }
    else
    {
      t = wc_get_ucs_table(0x8811u);
      wc_ucs_to_any(&cc, ucs, t);
    }
  }
  else
  {
    cc.code = wc_N_to_johab1(ucs - 44032);
    cc.ccs = 34831;
  }
  v2 = cc.code;
  retstr->ccs = cc.ccs;
  retstr->code = v2;
  return retstr;
}
// 80BAB86: inconsistent function type and number of purged bytes

//----- (080BAC4A) --------------------------------------------------------
wc_uint32 __cdecl wc_johab1_to_N(wc_uint32 code)
{
  wc_uint32 result; // eax

  if ( johab1_N_map[0][(code >> 10) & 0x1F] && johab1_N_map[1][(code >> 5) & 0x1F] && johab1_N_map[2][code & 0x1F] )
    result = johab1_N_map[2][code & 0x1F]
           + 28 * (johab1_N_map[1][(code >> 5) & 0x1F] + 21 * johab1_N_map[0][(code >> 10) & 0x1F])
           - 617;
  else
    result = -1;
  return result;
}

//----- (080BACD4) --------------------------------------------------------
wc_uint32 __cdecl wc_N_to_johab1(wc_uint32 code)
{
  wc_uint32 result; // eax

  result = N_johab1_map[2][code % 0x1C] | (N_johab1_map[0][code / 0x24C] << 10) | (32
                                                                                 * N_johab1_map[1][code / 0x1C % 0x15]);
  BYTE1(result) |= 0x80u;
  return result;
}

//----- (080BAD93) --------------------------------------------------------
wc_wchar_t *__userpurge wc_johab_to_cs128w@<eax>(wc_wchar_t *retstr, wc_wchar_t cc)
{
  int v2; // eax
  char v3; // al
  char v4; // al
  wc_uint32 n; // [esp+Ch] [ebp-Ch]
  unsigned __int16 lb; // [esp+12h] [ebp-6h]
  wc_ccs cca; // [esp+24h] [ebp+Ch]
  wc_uint32 cc_4; // [esp+28h] [ebp+10h]

  if ( cc.code > 0xD7FF )
  {
    if ( BYTE1(cc.code) > 0xDFu )
      v3 = 2 * (BYTE1(cc.code) + 32) + 74;
    else
      v3 = 2 * (BYTE1(cc.code) + 40) + 31;
    HIBYTE(lb) = v3;
    if ( LOBYTE(cc.code) > 0xA0u )
    {
      HIBYTE(lb) = v3 + 1;
      LOBYTE(lb) = LOBYTE(cc.code) + 0x80;
    }
    else
    {
      if ( LOBYTE(cc.code) > 0x90u )
        v4 = 34;
      else
        v4 = 16;
      LOBYTE(lb) = LOBYTE(cc.code) - v4;
    }
    cc_4 = lb;
    cca = 34834;
  }
  else
  {
    n = wc_johab1_to_N(cc.code);
    if ( n == -1 )
    {
      if ( LOBYTE(cc.code) > 0x80u )
        v2 = 67;
      else
        v2 = 65;
      cc_4 = ((188 * BYTE1(cc.code) + (unsigned int)LOBYTE(cc.code) - v2 - 24816) >> 7 << 8)
           + ((-68 * BYTE1(cc.code) + LOBYTE(cc.code) - (_BYTE)v2 + 16) & 0x7F);
      cca = 34833;
    }
    else
    {
      cc_4 = (((n >> 7) + 33) << 8) + (n & 0x7F);
      cca = 34832;
    }
  }
  retstr->ccs = cca;
  retstr->code = cc_4;
  return retstr;
}

//----- (080BAED3) --------------------------------------------------------
wc_wchar_t *__userpurge wc_cs128w_to_johab@<eax>(wc_wchar_t *retstr, wc_wchar_t cc)
{
  int v2; // eax
  char v3; // al
  char v4; // al
  wc_uchar lb; // [esp+16h] [ebp-Eh]
  unsigned __int16 lba; // [esp+16h] [ebp-Eh]
  wc_uchar ub; // [esp+17h] [ebp-Dh]
  wc_uchar uba; // [esp+17h] [ebp-Dh]
  wc_uchar ubb; // [esp+17h] [ebp-Dh]

  switch ( cc.ccs )
  {
    case 0x8811u:
      if ( ((((cc.code >> 8) & 0x7F) << 7) + (cc.code & 0x7F)) % 0xBC > 0x3D )
        v2 = 67;
      else
        v2 = 65;
      cc.code = ((((((cc.code >> 8) & 0x7F) << 7) + (cc.code & 0x7F)) / 0xBC + 132) << 8)
              + ((((cc.code >> 8) & 0x7F) << 7) + (cc.code & 0x7F)) % 0xBC
              + v2;
      break;
    case 0x8812u:
      ub = BYTE1(cc.code) & 0x7F;
      lb = cc.code & 0x7F;
      if ( (BYTE1(cc.code) & 0x7Fu) > 0x49 )
      {
        ubb = ub - 74;
        if ( (ubb & 1) != 0 )
        {
          v4 = 0x80;
        }
        else if ( lb > 0x6Eu )
        {
          v4 = 34;
        }
        else
        {
          v4 = 16;
        }
        LOBYTE(lba) = v4 + lb;
        HIBYTE(lba) = (ubb >> 1) - 32;
      }
      else
      {
        uba = ub - 31;
        if ( (uba & 1) != 0 )
        {
          v3 = 0x80;
        }
        else if ( lb > 0x6Eu )
        {
          v3 = 34;
        }
        else
        {
          v3 = 16;
        }
        LOBYTE(lba) = v3 + lb;
        HIBYTE(lba) = (uba >> 1) - 40;
      }
      cc.code = lba;
      break;
    case 0x8810u:
      cc.code = wc_N_to_johab1(((((cc.code >> 8) & 0x7F) + 33554399) << 7) + (cc.code & 0x7F));
      break;
  }
  retstr->ccs = 34831;
  retstr->code = cc.code;
  return retstr;
}

//----- (080BB07C) --------------------------------------------------------
Str __cdecl wc_conv_from_johab(Str is, wc_ces ces)
{
  int v3; // eax
  int v4; // eax
  int state; // [esp+1Ch] [ebp-1Ch]
  wc_uchar *p; // [esp+20h] [ebp-18h]
  wc_uchar *ep; // [esp+24h] [ebp-14h]
  char *sp_0; // [esp+28h] [ebp-10h]
  Str os; // [esp+2Ch] [ebp-Ch]

  sp_0 = is->ptr;
  ep = (wc_uchar *)&is->ptr[is->length];
  state = 0;
  for ( p = (wc_uchar *)is->ptr; p < ep && (*p & 0x80u) == 0; ++p )
    ;
  if ( p == ep )
    return is;
  os = Strnew_size(is->length);
  if ( p > (wc_uchar *)sp_0 )
    Strcat_charp_n(os, is->ptr, p - (wc_uchar *)sp_0);
  while ( p < ep )
  {
    if ( state == 1 )
    {
      if ( (WC_JOHAB_MAP[*p] & 0x10) != 0 )
        wtf_push(os, 0x880Fu, (*(p - 1) << 8) | *p);
      else
        wtf_push_unknown(os, p - 1, 2u);
      state = 0;
    }
    else if ( state == 2 )
    {
      if ( (WC_JOHAB_MAP[*p] & 0x20) != 0 )
        wtf_push(os, 0x880Fu, (*(p - 1) << 8) | *p);
      else
        wtf_push_unknown(os, p - 1, 2u);
      state = 0;
    }
    else
    {
      v3 = WC_JOHAB_MAP[*p] & 0xF;
      switch ( v3 )
      {
        case 4:
          state = 2;
          break;
        case 8:
          wtf_push_unknown(os, p, 1u);
          break;
        case 2:
          state = 1;
          break;
        default:
          if ( os->length + 1 >= os->area_size )
            Strgrow(os);
          v4 = os->length;
          os->ptr[v4] = *p;
          os->length = v4 + 1;
          os->ptr[os->length] = 0;
          break;
      }
    }
    ++p;
  }
  if ( (unsigned int)(state - 1) <= 1 )
    wtf_push_unknown(os, p - 1, 1u);
  return os;
}
// 80BB124: conditional instruction was optimized away because of '%state.4==0'

//----- (080BB2FB) --------------------------------------------------------
void __cdecl wc_push_to_johab(Str os, wc_wchar_t cc, wc_status *st)
{
  int v3; // eax
  int v4; // eax
  int v5; // eax
  wc_ccs v6; // eax
  wc_wchar_t v7; // [esp+18h] [ebp-10h] BYREF

  while ( cc.ccs != 34831 )
  {
    if ( cc.ccs > 0x880F )
    {
      if ( cc.ccs <= 0x8812 )
      {
        wc_cs128w_to_johab(&cc, cc);
        break;
      }
      if ( cc.ccs == 49152 )
      {
        if ( !WcOption.no_replace )
          Strcat_charp(os, WcReplaceW);
        return;
      }
LABEL_24:
      if ( WcOption.ucs_conv )
      {
        wc_any_to_any_ces(&v7, cc, st);
        cc = v7;
      }
      else
      {
        if ( (cc.ccs & 0x18000) != 0 )
          v6 = 49152;
        else
          v6 = 0x4000;
        cc.ccs = v6;
      }
    }
    else
    {
      if ( cc.ccs == 0x4000 )
      {
        if ( !WcOption.no_replace )
          Strcat_charp(os, WcReplace);
        return;
      }
      if ( cc.ccs != 33091 )
      {
        if ( cc.ccs == 322 )
        {
          if ( os->length + 1 >= os->area_size )
            Strgrow(os);
          v3 = os->length;
          os->ptr[v3] = cc.code;
          os->length = v3 + 1;
          os->ptr[os->length] = 0;
          return;
        }
        goto LABEL_24;
      }
      wc_ksx1001_to_johab(&v7, (wc_wchar_t)__PAIR64__(cc.code, 33091));
      cc = v7;
    }
  }
  if ( os->length + 1 >= os->area_size )
    Strgrow(os);
  v4 = os->length;
  os->ptr[v4] = BYTE1(cc.code);
  os->length = v4 + 1;
  os->ptr[os->length] = 0;
  if ( os->length + 1 >= os->area_size )
    Strgrow(os);
  v5 = os->length;
  os->ptr[v5] = cc.code;
  os->length = v5 + 1;
  os->ptr[os->length] = 0;
}

//----- (080BB538) --------------------------------------------------------
Str __cdecl wc_char_conv_from_johab(wc_uchar c, wc_status *st)
{
  int v2; // eax
  int v3; // eax
  Str v5; // eax
  int v6; // edx

  if ( st->state == -1 )
  {
    st->state = 0;
    os_2826 = Strnew_size(8);
  }
  v2 = st->state;
  switch ( v2 )
  {
    case 1:
      if ( (WC_JOHAB_MAP[c] & 0x10) == 0 )
        break;
LABEL_18:
      wtf_push(os_2826, 0x880Fu, c | (johabu_2827 << 8));
      break;
    case 2:
      if ( (WC_JOHAB_MAP[c] & 0x20) == 0 )
        break;
      goto LABEL_18;
    case 0:
      v3 = WC_JOHAB_MAP[c] & 0xF;
      if ( v3 == 4 )
      {
        johabu_2827 = c;
        st->state = 2;
        return 0;
      }
      if ( v3 != 8 )
      {
        if ( v3 == 2 )
        {
          johabu_2827 = c;
          st->state = 1;
          return 0;
        }
        if ( os_2826->length + 1 >= os_2826->area_size )
          Strgrow(os_2826);
        v5 = os_2826;
        v6 = os_2826->length;
        os_2826->ptr[v6] = c;
        v5->length = v6 + 1;
        os_2826->ptr[os_2826->length] = 0;
      }
      break;
  }
  st->state = -1;
  return os_2826;
}

//----- (080BB6E8) --------------------------------------------------------
void __cdecl wc_putc_init(wc_ces f_ces, wc_ces t_ces)
{
  wc_output_init(t_ces, &putc_st);
  putc_str = Strnew_size(8);
  putc_f_ces = f_ces;
  putc_t_ces = t_ces;
}

//----- (080BB724) --------------------------------------------------------
void __cdecl wc_putc(char *c, FILE *f)
{
  wc_ces v2; // ebx
  _Str *v3; // eax
  void (*v4)(...); // ebx
  wc_wchar_t v5; // [esp+14h] [ebp-14h] BYREF
  wc_uchar *p; // [esp+1Ch] [ebp-Ch] BYREF

  if ( putc_f_ces == 3211264 )
  {
    p = (wc_uchar *)c;
  }
  else
  {
    v2 = putc_f_ces;
    v3 = Strnew_charp(c);
    p = (wc_uchar *)wc_Str_conv(v3, v2, 0x310000u)->ptr;
  }
  Strclear(putc_str);
  while ( *p )
  {
    v4 = putc_st.ces_info->push_to;
    wtf_parse(&v5, &p);
    v4(putc_str, v5.ccs, v5.code, &putc_st);
  }
  fwrite(putc_str->ptr, 1u, putc_str->length, f);
}

//----- (080BB7F1) --------------------------------------------------------
void __cdecl wc_putc_end(FILE *f)
{
  Strclear(putc_str);
  wc_push_end(putc_str, &putc_st);
  if ( putc_str->length )
    fwrite(putc_str->ptr, 1u, putc_str->length, f);
}

//----- (080BB853) --------------------------------------------------------
void wc_putc_clear_status()
{
  if ( (putc_st.ces_info->id & 0x800) != 0 )
  {
    putc_st.gl = 0;
    putc_st.gr = 0;
    putc_st.ss = 0;
    putc_st.design[0] = 0;
    putc_st.design[1] = 0;
    putc_st.design[2] = 0;
    putc_st.design[3] = 0;
  }
}

//----- (080BB8A8) --------------------------------------------------------
int __cdecl map_cmp(const void *a, const void *b)
{
  return *(unsigned __int16 *)a - *(unsigned __int16 *)b;
}

//----- (080BB8C5) --------------------------------------------------------
int __cdecl map3_cmp(const void *a, const void *b)
{
  return *(_DWORD *)a - ((*(unsigned __int16 *)b << 16) | *((unsigned __int16 *)b + 1));
}

//----- (080BB8EF) --------------------------------------------------------
int __cdecl map_range_cmp(const void *a, const void *b)
{
  int result; // eax

  if ( *(_WORD *)a < *(_WORD *)b )
    result = -1;
  else
    result = *(_WORD *)a > *((_WORD *)b + 1);
  return result;
}

//----- (080BB922) --------------------------------------------------------
int __cdecl map2_range_cmp(const void *a, const void *b)
{
  int result; // eax

  if ( *(_WORD *)a < *(_WORD *)b )
    result = -1;
  else
    result = *(_WORD *)a >= *((_WORD *)b + 2);
  return result;
}

//----- (080BB957) --------------------------------------------------------
int __cdecl map3_range_cmp(const void *a, const void *b)
{
  int result; // eax

  if ( *(_WORD *)a < *(_WORD *)b )
    result = -1;
  else
    result = *(_WORD *)a > *((_WORD *)b + 1);
  return result;
}

//----- (080BB98A) --------------------------------------------------------
wc_map *__cdecl wc_map_search(wc_uint16 code, wc_map *map, size_t n)
{
  wc_uint16 codea[6]; // [esp+2Ch] [ebp-Ch] BYREF

  codea[0] = code;
  return (wc_map *)bsearch(codea, map, n, 4u, map_cmp);
}

//----- (080BB9C2) --------------------------------------------------------
wc_map3 *__cdecl wc_map3_search(wc_uint16 c1, wc_uint16 c2, wc_map3 *map, size_t n)
{
  wc_uint32 code[3]; // [esp+3Ch] [ebp-Ch] BYREF

  code[0] = (c1 << 16) | c2;
  return (wc_map3 *)bsearch(code, map, n, 6u, map3_cmp);
}

//----- (080BBA13) --------------------------------------------------------
wc_map *__cdecl wc_map_range_search(wc_uint16 code, wc_map *map, int n)
{
  wc_uint16 codea[6]; // [esp+2Ch] [ebp-Ch] BYREF

  codea[0] = code;
  return (wc_map *)bsearch(codea, map, n, 4u, map_range_cmp);
}

//----- (080BBA4B) --------------------------------------------------------
wc_map *__cdecl wc_map2_range_search(wc_uint16 code, wc_map *map, size_t n)
{
  wc_uint16 codea[6]; // [esp+2Ch] [ebp-Ch] BYREF

  codea[0] = code;
  return (wc_map *)bsearch(codea, map, n, 4u, map2_range_cmp);
}

//----- (080BBA83) --------------------------------------------------------
wc_map3 *__cdecl wc_map3_range_search(wc_uint16 code, wc_map3 *map, size_t n)
{
  wc_uint16 codea[6]; // [esp+2Ch] [ebp-Ch] BYREF

  codea[0] = code;
  return (wc_map3 *)bsearch(codea, map, n, 6u, map3_range_cmp);
}

//----- (080BBABC) --------------------------------------------------------
wc_wchar_t *__userpurge wc_sjis_to_jis@<eax>(wc_wchar_t *retstr, wc_wchar_t cc)
{
  char v2; // al
  char v3; // al
  char v4; // al
  unsigned __int16 lb; // [esp+Eh] [ebp-2h]
  wc_ccs cca; // [esp+1Ch] [ebp+Ch]

  if ( BYTE1(cc.code) > 0xEFu )
  {
    if ( LOBYTE(cc.code) > 0x9Eu )
    {
      HIBYTE(lb) = sjis2_jisx02132_map[BYTE1(cc.code) - 240];
      LOBYTE(lb) = LOBYTE(cc.code) - 126;
    }
    else
    {
      HIBYTE(lb) = sjis1_jisx02132_map[BYTE1(cc.code) - 240];
      if ( LOBYTE(cc.code) <= 0x7Eu )
        v4 = 31;
      else
        v4 = 32;
      LOBYTE(lb) = LOBYTE(cc.code) - v4;
    }
    cca = 33104;
  }
  else
  {
    if ( BYTE1(cc.code) > 0x9Fu )
      v2 = -63;
    else
      v2 = -127;
    HIBYTE(lb) = 2 * (BYTE1(cc.code) - v2) + 33;
    if ( LOBYTE(cc.code) > 0x9Eu )
    {
      HIBYTE(lb) = 2 * (BYTE1(cc.code) - v2) + 34;
      LOBYTE(lb) = LOBYTE(cc.code) - 126;
    }
    else
    {
      if ( LOBYTE(cc.code) <= 0x7Eu )
        v3 = 31;
      else
        v3 = 32;
      LOBYTE(lb) = LOBYTE(cc.code) - v3;
    }
    cca = 33090;
  }
  retstr->ccs = cca;
  retstr->code = lb;
  return retstr;
}

//----- (080BBB9A) --------------------------------------------------------
wc_wchar_t *__userpurge wc_jis_to_sjis@<eax>(wc_wchar_t *retstr, wc_wchar_t cc)
{
  char v2; // al
  char v3; // al
  char v4; // al
  unsigned __int16 lb; // [esp+Eh] [ebp-2h]
  wc_uchar ub; // [esp+Fh] [ebp-1h]

  lb = cc.code & 0x7F7F;
  if ( cc.ccs != 33104 )
  {
    if ( (cc.code & 0x100) != 0 )
      v3 = 31;
    else
      v3 = 125;
    LOBYTE(lb) = v3 + lb;
    if ( (unsigned __int8)lb > 0x7Eu )
      LOBYTE(lb) = lb + 1;
    ub = (HIBYTE(lb) - 33) >> 1;
    if ( ub > 0x1Eu )
      v4 = -63;
    else
      v4 = -127;
    HIBYTE(lb) = v4 + ub;
    goto LABEL_18;
  }
  if ( (cc.code & 0x100) != 0 )
    v2 = 31;
  else
    v2 = 125;
  LOBYTE(lb) = v2 + lb;
  if ( (unsigned __int8)lb > 0x7Eu )
    LOBYTE(lb) = lb + 1;
  HIBYTE(lb) = jisx02132_sjis_map[HIBYTE(lb)];
  if ( HIBYTE(lb) )
  {
LABEL_18:
    retstr->ccs = cc.ccs;
    retstr->code = lb;
    return retstr;
  }
  retstr->ccs = 49152;
  retstr->code = cc.code;
  return retstr;
}

//----- (080BBC76) --------------------------------------------------------
wc_wchar_t *__userpurge wc_sjis_ext_to_cs94w@<eax>(wc_wchar_t *retstr, wc_wchar_t cc)
{
  char v2; // al
  char v3; // al
  unsigned __int16 lb; // [esp+Eh] [ebp-2h]
  wc_ccs cca; // [esp+1Ch] [ebp+Ch]

  if ( BYTE1(cc.code) > 0x9Fu )
    v2 = -63;
  else
    v2 = -127;
  HIBYTE(lb) = 2 * (BYTE1(cc.code) - v2) + 33;
  if ( LOBYTE(cc.code) > 0x9Eu )
  {
    HIBYTE(lb) = 2 * (BYTE1(cc.code) - v2) + 34;
    LOBYTE(lb) = LOBYTE(cc.code) - 126;
  }
  else
  {
    if ( LOBYTE(cc.code) <= 0x7Eu )
      v3 = 31;
    else
      v3 = 32;
    LOBYTE(lb) = LOBYTE(cc.code) - v3;
  }
  if ( HIBYTE(lb) > 0x7Eu )
  {
    HIBYTE(lb) -= 94;
    cca = 34837;
  }
  else
  {
    cca = 34836;
  }
  retstr->ccs = cca;
  retstr->code = lb;
  return retstr;
}

//----- (080BBD11) --------------------------------------------------------
wc_wchar_t *__userpurge wc_cs94w_to_sjis_ext@<eax>(wc_wchar_t *retstr, wc_wchar_t cc)
{
  char v2; // al
  char v3; // al
  unsigned __int16 lb; // [esp+Eh] [ebp-2h]
  wc_uchar ub; // [esp+Fh] [ebp-1h]

  ub = BYTE1(cc.code) & 0x7F;
  if ( cc.ccs == 34837 )
    ub += 94;
  if ( (ub & 1) != 0 )
    v2 = 31;
  else
    v2 = 125;
  LOBYTE(lb) = v2 + (cc.code & 0x7F);
  if ( (unsigned __int8)lb > 0x7Eu )
    LOBYTE(lb) = lb + 1;
  HIBYTE(lb) = (ub - 33) >> 1;
  if ( HIBYTE(lb) > 0x1Eu )
    v3 = -63;
  else
    v3 = -127;
  HIBYTE(lb) += v3;
  retstr->ccs = 34835;
  retstr->code = lb;
  return retstr;
}

//----- (080BBDAC) --------------------------------------------------------
wc_uint32 __cdecl wc_sjis_ext1_to_N(wc_uint32 c)
{
  int v1; // eax
  wc_uchar ub; // [esp+Fh] [ebp-1h]

  v1 = BYTE1(c) & 0x7F;
  if ( v1 == 45 )
  {
    ub = 0;
  }
  else
  {
    if ( (BYTE1(c) & 0x7Fu) < 0x2D || (unsigned int)(v1 - 121) > 3 )
      return -1;
    ub = (BYTE1(c) & 0x7F) - 120;
  }
  return (c & 0x7F) + 94 * ub - 33;
}

//----- (080BBDFD) --------------------------------------------------------
wc_uint32 __cdecl wc_sjis_ext2_to_N(wc_uint32 c)
{
  wc_uint32 result; // eax

  if ( (BYTE1(c) & 0x7Fu) - 53 > 4 )
    result = -1;
  else
    result = (c & 0x7F) + 94 * (unsigned __int8)((BYTE1(c) & 0x7F) - 48) - 33;
  return result;
}

//----- (080BBE3A) --------------------------------------------------------
Str __cdecl wc_conv_from_sjis(Str is, wc_ces ces)
{
  int v3; // eax
  char v4; // al
  char v5; // al
  int state; // [esp+18h] [ebp-20h]
  wc_uchar *p; // [esp+1Ch] [ebp-1Ch]
  wc_uchar *ep; // [esp+20h] [ebp-18h]
  char *sp_0; // [esp+24h] [ebp-14h]
  Str os; // [esp+28h] [ebp-10h]
  unsigned __int16 jis; // [esp+2Eh] [ebp-Ah]

  sp_0 = is->ptr;
  ep = (wc_uchar *)&is->ptr[is->length];
  state = 0;
  for ( p = (wc_uchar *)is->ptr; p < ep && (*p & 0x80u) == 0; ++p )
    ;
  if ( p == ep )
    return is;
  os = Strnew_size(is->length);
  if ( p > (wc_uchar *)sp_0 )
    Strcat_charp_n(os, is->ptr, p - (wc_uchar *)sp_0);
  while ( p < ep )
  {
    if ( state > 2 )
    {
      if ( (WC_SJIS_MAP[*p] & 0x10) != 0 )
        wtf_push(os, 0x8813u, (*(p - 1) << 8) | *p);
      else
        wtf_push_unknown(os, p - 1, 2u);
      state = 0;
    }
    else if ( state >= 1 )
    {
      if ( (WC_SJIS_MAP[*p] & 0x10) != 0 )
      {
        jis = *(_WORD *)(p - 1);
        if ( (unsigned __int8)jis > 0x9Fu )
          v4 = -63;
        else
          v4 = -127;
        LOBYTE(jis) = 2 * (jis - v4) + 33;
        if ( HIBYTE(jis) > 0x9Eu )
        {
          LOBYTE(jis) = jis + 1;
          HIBYTE(jis) -= 126;
        }
        else
        {
          if ( HIBYTE(jis) <= 0x7Eu )
            v5 = 31;
          else
            v5 = 32;
          HIBYTE(jis) -= v5;
        }
        if ( wc_jisx0208_or_jisx02131(_byteswap_ushort(jis)) == 33090 )
          wtf_push(os, 0x8142u, ((unsigned __int8)jis << 8) | HIBYTE(jis));
        else
          wtf_push(os, 0x8813u, (*(p - 1) << 8) | *p);
      }
      else
      {
        wtf_push_unknown(os, p - 1, 2u);
      }
      state = 0;
    }
    else
    {
      switch ( WC_SJIS_MAP[*p] )
      {
        case 0x12u:
        case 0x17u:
        case 0x40u:
          wtf_push_unknown(os, p, 1u);
          break;
        case 0x13u:
          wtf_push(os, 0x149u, *p);
          break;
        case 0x34u:
          state = 1;
          break;
        case 0x35u:
          state = 2;
          break;
        case 0x36u:
          state = 3;
          break;
        default:
          if ( os->length + 1 >= os->area_size )
            Strgrow(os);
          v3 = os->length;
          os->ptr[v3] = *p;
          os->length = v3 + 1;
          os->ptr[os->length] = 0;
          break;
      }
    }
    ++p;
  }
  if ( (unsigned int)(state - 1) <= 2 )
    wtf_push_unknown(os, p - 1, 1u);
  return os;
}
// 80BBEDE: conditional instruction was optimized away because of '%state.4==0'
// 80BBEE8: conditional instruction was optimized away because of '%state.4==3'

//----- (080BC1CA) --------------------------------------------------------
Str __cdecl wc_conv_from_sjisx0213(Str is, wc_ces ces)
{
  int v3; // eax
  char v4; // al
  char v5; // al
  char v6; // al
  wc_ccs v7; // [esp+4h] [ebp-34h]
  int state; // [esp+18h] [ebp-20h]
  wc_uchar *p; // [esp+1Ch] [ebp-1Ch]
  wc_uchar *ep; // [esp+20h] [ebp-18h]
  char *sp_0; // [esp+24h] [ebp-14h]
  Str os; // [esp+28h] [ebp-10h]
  unsigned __int16 jis; // [esp+2Eh] [ebp-Ah]
  unsigned __int8 jisa; // [esp+2Eh] [ebp-Ah]
  wc_uchar jisb; // [esp+2Eh] [ebp-Ah]
  char jis_1; // [esp+2Fh] [ebp-9h]
  unsigned __int8 jis_1a; // [esp+2Fh] [ebp-9h]

  sp_0 = is->ptr;
  ep = (wc_uchar *)&is->ptr[is->length];
  state = 0;
  for ( p = (wc_uchar *)is->ptr; p < ep && (*p & 0x80u) == 0; ++p )
    ;
  if ( p == ep )
    return is;
  os = Strnew_size(is->length);
  if ( p > (wc_uchar *)sp_0 )
    Strcat_charp_n(os, is->ptr, p - (wc_uchar *)sp_0);
  while ( p < ep )
  {
    if ( state > 2 )
    {
      if ( (WC_SJIS_MAP[*p] & 0x10) != 0 )
      {
        jisa = *(p - 1);
        jis_1 = *p;
        if ( *p > 0x9Eu )
        {
          jisb = sjis2_jisx02132_map[jisa - 240];
          jis_1a = jis_1 - 126;
        }
        else
        {
          jisb = sjis1_jisx02132_map[jisa - 240];
          if ( (unsigned __int8)jis_1 <= 0x7Eu )
            v6 = 31;
          else
            v6 = 32;
          jis_1a = jis_1 - v6;
        }
        wtf_push(os, 0x8150u, (jisb << 8) | jis_1a);
      }
      else
      {
        wtf_push_unknown(os, p - 1, 2u);
      }
      state = 0;
    }
    else if ( state >= 1 )
    {
      if ( (WC_SJIS_MAP[*p] & 0x10) != 0 )
      {
        jis = *(_WORD *)(p - 1);
        if ( (unsigned __int8)jis > 0x9Fu )
          v4 = -63;
        else
          v4 = -127;
        LOBYTE(jis) = 2 * (jis - v4) + 33;
        if ( HIBYTE(jis) > 0x9Eu )
        {
          LOBYTE(jis) = jis + 1;
          HIBYTE(jis) -= 126;
        }
        else
        {
          if ( HIBYTE(jis) <= 0x7Eu )
            v5 = 31;
          else
            v5 = 32;
          HIBYTE(jis) -= v5;
        }
        v7 = wc_jisx0208_or_jisx02131(_byteswap_ushort(jis));
        wtf_push(os, v7, ((unsigned __int8)jis << 8) | HIBYTE(jis));
      }
      else
      {
        wtf_push_unknown(os, p - 1, 2u);
      }
      state = 0;
    }
    else
    {
      switch ( WC_SJIS_MAP[*p] )
      {
        case 0x12u:
        case 0x17u:
        case 0x40u:
          wtf_push_unknown(os, p, 1u);
          break;
        case 0x13u:
          wtf_push(os, 0x149u, *p);
          break;
        case 0x34u:
          state = 1;
          break;
        case 0x35u:
          state = 2;
          break;
        case 0x36u:
          state = 3;
          break;
        default:
          if ( os->length + 1 >= os->area_size )
            Strgrow(os);
          v3 = os->length;
          os->ptr[v3] = *p;
          os->length = v3 + 1;
          os->ptr[os->length] = 0;
          break;
      }
    }
    ++p;
  }
  if ( (unsigned int)(state - 1) <= 2 )
    wtf_push_unknown(os, p - 1, 1u);
  return os;
}
// 80BC26E: conditional instruction was optimized away because of '%state.4==0'
// 80BC278: conditional instruction was optimized away because of '%state.4==3'

//----- (080BC591) --------------------------------------------------------
void __cdecl wc_push_to_sjis(Str os, wc_wchar_t cc, wc_status *st)
{
  int v3; // eax
  int v4; // eax
  char v5; // al
  char v6; // al
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  wc_ccs v11; // eax
  wc_wchar_t v12; // [esp+18h] [ebp-20h] BYREF
  wc_uchar lb; // [esp+2Eh] [ebp-Ah]
  wc_uchar ub; // [esp+2Fh] [ebp-9h]

  while ( cc.ccs != 33090 )
  {
    if ( cc.ccs > 0x8142 )
    {
      if ( cc.ccs > 0x8815 )
      {
        if ( cc.ccs == 49152 )
        {
          if ( !WcOption.no_replace )
            Strcat_charp(os, WcReplaceW);
          return;
        }
      }
      else
      {
        if ( cc.ccs >= 0x8814 )
        {
          wc_cs94w_to_sjis_ext(&v12, cc);
          cc = v12;
LABEL_37:
          if ( os->length + 1 >= os->area_size )
            Strgrow(os);
          v9 = os->length;
          os->ptr[v9] = BYTE1(cc.code);
          os->length = v9 + 1;
          os->ptr[os->length] = 0;
          if ( os->length + 1 >= os->area_size )
            Strgrow(os);
          v10 = os->length;
          os->ptr[v10] = cc.code;
          os->length = v10 + 1;
          os->ptr[os->length] = 0;
          return;
        }
        if ( cc.ccs == 34835 )
          goto LABEL_37;
      }
LABEL_46:
      if ( WcOption.ucs_conv )
      {
        wc_any_to_any_ces(&v12, cc, st);
        cc = v12;
      }
      else
      {
        if ( (cc.ccs & 0x18000) != 0 )
          v11 = 49152;
        else
          v11 = 0x4000;
        cc.ccs = v11;
      }
    }
    else
    {
      if ( cc.ccs != 329 )
      {
        if ( cc.ccs == 0x4000 )
        {
          if ( !WcOption.no_replace )
            Strcat_charp(os, WcReplace);
          return;
        }
        if ( cc.ccs == 322 )
        {
          if ( os->length + 1 >= os->area_size )
            Strgrow(os);
          v3 = os->length;
          os->ptr[v3] = cc.code;
          os->length = v3 + 1;
          os->ptr[os->length] = 0;
          return;
        }
        goto LABEL_46;
      }
      if ( WcOption.use_jisx0201k )
      {
        if ( os->length + 1 >= os->area_size )
          Strgrow(os);
        v4 = os->length;
        os->ptr[v4] = LOBYTE(cc.code) | 0x80;
        os->length = v4 + 1;
        os->ptr[os->length] = 0;
        return;
      }
      if ( WcOption.fix_width_conv )
        cc.ccs = 0x4000;
      else
        wc_jisx0201k_to_jisx0208(&cc, cc);
    }
  }
  ub = BYTE1(cc.code) & 0x7F;
  lb = cc.code & 0x7F;
  if ( (cc.code & 0x100) != 0 )
    v5 = 31;
  else
    v5 = 125;
  lb += v5;
  if ( lb > 0x7Eu )
    ++lb;
  ub = (ub - 33) >> 1;
  if ( ub > 0x1Eu )
    v6 = -63;
  else
    v6 = -127;
  ub += v6;
  if ( os->length + 1 >= os->area_size )
    Strgrow(os);
  v7 = os->length;
  os->ptr[v7] = ub;
  os->length = v7 + 1;
  os->ptr[os->length] = 0;
  if ( os->length + 1 >= os->area_size )
    Strgrow(os);
  v8 = os->length;
  os->ptr[v8] = lb;
  os->length = v8 + 1;
  os->ptr[os->length] = 0;
}

//----- (080BC955) --------------------------------------------------------
void __cdecl wc_push_to_sjisx0213(Str os, wc_wchar_t cc, wc_status *st)
{
  int v3; // eax
  int v4; // eax
  char v5; // al
  char v6; // al
  int v7; // eax
  int v8; // eax
  char v9; // al
  int v10; // eax
  int v11; // eax
  wc_ccs v12; // eax
  wc_wchar_t v13; // [esp+18h] [ebp-20h] BYREF
  wc_uchar lb; // [esp+2Eh] [ebp-Ah]
  wc_uchar ub; // [esp+2Fh] [ebp-9h]

  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        if ( cc.ccs == 33090 )
        {
LABEL_23:
          ub = BYTE1(cc.code) & 0x7F;
          lb = cc.code & 0x7F;
          if ( (cc.code & 0x100) != 0 )
            v5 = 31;
          else
            v5 = 125;
          lb += v5;
          if ( lb > 0x7Eu )
            ++lb;
          ub = (ub - 33) >> 1;
          if ( ub > 0x1Eu )
            v6 = -63;
          else
            v6 = -127;
          ub += v6;
          if ( os->length + 1 >= os->area_size )
            Strgrow(os);
          v7 = os->length;
          os->ptr[v7] = ub;
          os->length = v7 + 1;
          os->ptr[os->length] = 0;
          if ( os->length + 1 >= os->area_size )
            Strgrow(os);
          v8 = os->length;
          os->ptr[v8] = lb;
          os->length = v8 + 1;
          os->ptr[os->length] = 0;
          return;
        }
        if ( cc.ccs > 0x8142 )
          break;
        if ( cc.ccs != 329 )
        {
          if ( cc.ccs == 0x4000 )
          {
            if ( !WcOption.no_replace )
              Strcat_charp(os, WcReplace);
            return;
          }
          if ( cc.ccs == 322 )
          {
            if ( os->length + 1 >= os->area_size )
              Strgrow(os);
            v3 = os->length;
            os->ptr[v3] = cc.code;
            os->length = v3 + 1;
            os->ptr[os->length] = 0;
            return;
          }
          goto LABEL_53;
        }
        if ( WcOption.use_jisx0201k )
        {
          if ( os->length + 1 >= os->area_size )
            Strgrow(os);
          v4 = os->length;
          os->ptr[v4] = LOBYTE(cc.code) | 0x80;
          os->length = v4 + 1;
          os->ptr[os->length] = 0;
          return;
        }
        if ( WcOption.fix_width_conv )
          cc.ccs = 0x4000;
        else
          wc_jisx0201k_to_jisx0208(&cc, cc);
      }
      if ( cc.ccs == 33104 )
        break;
      if ( cc.ccs == 49152 )
        goto LABEL_49;
      if ( cc.ccs == 33103 )
      {
        if ( WcOption.use_jisx0213 )
          goto LABEL_23;
        cc.ccs = 49152;
      }
      else
      {
LABEL_53:
        if ( WcOption.ucs_conv )
        {
          wc_any_to_any_ces(&v13, cc, st);
          cc = v13;
        }
        else
        {
          if ( (cc.ccs & 0x18000) != 0 )
            v12 = 49152;
          else
            v12 = 0x4000;
          cc.ccs = v12;
        }
      }
    }
    if ( WcOption.use_jisx0213 )
      break;
    cc.ccs = 49152;
  }
  ub = BYTE1(cc.code) & 0x7F;
  lb = cc.code & 0x7F;
  if ( (cc.code & 0x100) != 0 )
    v9 = 31;
  else
    v9 = 125;
  lb += v9;
  if ( lb > 0x7Eu )
    ++lb;
  ub = jisx02132_sjis_map[ub];
  if ( ub )
  {
    if ( os->length + 1 >= os->area_size )
      Strgrow(os);
    v10 = os->length;
    os->ptr[v10] = ub;
    os->length = v10 + 1;
    os->ptr[os->length] = 0;
    if ( os->length + 1 >= os->area_size )
      Strgrow(os);
    v11 = os->length;
    os->ptr[v11] = lb;
    os->length = v11 + 1;
    os->ptr[os->length] = 0;
  }
  else
  {
LABEL_49:
    if ( !WcOption.no_replace )
      Strcat_charp(os, WcReplaceW);
  }
}

//----- (080BCD67) --------------------------------------------------------
Str __cdecl wc_char_conv_from_sjis(wc_uchar c, wc_status *st)
{
  int v2; // eax
  Str result; // eax
  Str v4; // eax
  int v5; // edx
  char v6; // al
  char v7; // al
  int cc_4; // [esp+2Ch] [ebp-Ch]

  if ( st->state == -1 )
  {
    st->state = 0;
    os_3288 = Strnew_size(8);
  }
  v2 = st->state;
  if ( v2 > 2 )
  {
    if ( v2 == 3 )
    {
      if ( (WC_SJIS_MAP[c] & 0x10) != 0 )
      {
        jis_3289[1] = c;
        wtf_push(os_3288, 0x8813u, c | (jis_3289[0] << 8));
      }
      st->state = 0;
    }
    goto LABEL_34;
  }
  if ( v2 >= 1 )
  {
    if ( (WC_SJIS_MAP[c] & 0x10) != 0 )
    {
      jis_3289[1] = c;
      if ( jis_3289[0] > 0x9Fu )
        v6 = -63;
      else
        v6 = -127;
      jis_3289[0] = 2 * (jis_3289[0] - v6) + 33;
      if ( jis_3289[1] > 0x9Eu )
      {
        ++jis_3289[0];
        jis_3289[1] -= 126;
      }
      else
      {
        if ( jis_3289[1] <= 0x7Eu )
          v7 = 31;
        else
          v7 = 32;
        jis_3289[1] -= v7;
      }
      cc_4 = (jis_3289[0] << 8) | jis_3289[1];
      if ( wc_jisx0208_or_jisx02131(_byteswap_ushort(*(unsigned __int16 *)jis_3289)) == 33090 )
        wtf_push(os_3288, 0x8142u, cc_4);
      else
        wtf_push(os_3288, 0x8813u, jis_3289[1] | (jis_3289[0] << 8));
    }
    st->state = 0;
    goto LABEL_34;
  }
  if ( v2 )
  {
LABEL_34:
    st->state = -1;
    return os_3288;
  }
  switch ( WC_SJIS_MAP[c] )
  {
    case 0x12u:
    case 0x17u:
    case 0x40u:
      goto LABEL_34;
    case 0x13u:
      wtf_push(os_3288, 0x149u, c);
      goto LABEL_34;
    case 0x34u:
      jis_3289[0] = c;
      st->state = 1;
      result = 0;
      break;
    case 0x35u:
      jis_3289[0] = c;
      st->state = 2;
      result = 0;
      break;
    case 0x36u:
      jis_3289[0] = c;
      st->state = 3;
      result = 0;
      break;
    default:
      if ( os_3288->length + 1 >= os_3288->area_size )
        Strgrow(os_3288);
      v4 = os_3288;
      v5 = os_3288->length;
      os_3288->ptr[v5] = c;
      v4->length = v5 + 1;
      os_3288->ptr[os_3288->length] = 0;
      goto LABEL_34;
  }
  return result;
}

//----- (080BD079) --------------------------------------------------------
Str __cdecl wc_char_conv_from_sjisx0213(wc_uchar c, wc_status *st)
{
  int v2; // eax
  Str result; // eax
  Str v4; // eax
  int v5; // edx
  char v6; // al
  char v7; // al
  char v8; // al
  wc_ccs cc; // [esp+28h] [ebp-10h]
  int cc_4; // [esp+2Ch] [ebp-Ch]

  if ( st->state == -1 )
  {
    st->state = 0;
    os_3413 = Strnew_size(8);
  }
  v2 = st->state;
  if ( v2 > 2 )
  {
    if ( v2 == 3 )
    {
      if ( (WC_SJIS_MAP[c] & 0x10) != 0 )
      {
        jis_3414[1] = c;
        if ( c > 0x9Eu )
        {
          jis_3414[0] = sjis2_jisx02132_map[jis_3414[0] - 240];
          jis_3414[1] -= 126;
        }
        else
        {
          jis_3414[0] = sjis1_jisx02132_map[jis_3414[0] - 240];
          if ( jis_3414[1] <= 0x7Eu )
            v8 = 31;
          else
            v8 = 32;
          jis_3414[1] -= v8;
        }
        wtf_push(os_3413, 0x8150u, jis_3414[1] | (jis_3414[0] << 8));
      }
      st->state = 0;
    }
    goto LABEL_38;
  }
  if ( v2 >= 1 )
  {
    if ( (WC_SJIS_MAP[c] & 0x10) != 0 )
    {
      jis_3414[1] = c;
      if ( jis_3414[0] > 0x9Fu )
        v6 = -63;
      else
        v6 = -127;
      jis_3414[0] = 2 * (jis_3414[0] - v6) + 33;
      if ( jis_3414[1] > 0x9Eu )
      {
        ++jis_3414[0];
        jis_3414[1] -= 126;
      }
      else
      {
        if ( jis_3414[1] <= 0x7Eu )
          v7 = 31;
        else
          v7 = 32;
        jis_3414[1] -= v7;
      }
      cc_4 = (jis_3414[0] << 8) | jis_3414[1];
      cc = wc_jisx0208_or_jisx02131(_byteswap_ushort(*(unsigned __int16 *)jis_3414));
      wtf_push(os_3413, cc, cc_4);
    }
    st->state = 0;
    goto LABEL_38;
  }
  if ( v2 )
  {
LABEL_38:
    st->state = -1;
    return os_3413;
  }
  switch ( WC_SJIS_MAP[c] )
  {
    case 0x12u:
    case 0x17u:
    case 0x40u:
      goto LABEL_38;
    case 0x13u:
      wtf_push(os_3413, 0x149u, c);
      goto LABEL_38;
    case 0x34u:
      jis_3414[0] = c;
      st->state = 1;
      result = 0;
      break;
    case 0x35u:
      jis_3414[0] = c;
      st->state = 2;
      result = 0;
      break;
    case 0x36u:
      jis_3414[0] = c;
      st->state = 3;
      result = 0;
      break;
    default:
      if ( os_3413->length + 1 >= os_3413->area_size )
        Strgrow(os_3413);
      v4 = os_3413;
      v5 = os_3413->length;
      os_3413->ptr[v5] = c;
      v4->length = v5 + 1;
      os_3413->ptr[os_3413->length] = 0;
      goto LABEL_38;
  }
  return result;
}

//----- (080BD3D0) --------------------------------------------------------
void __cdecl wc_input_init(wc_ces ces, wc_status *st)
{
  int g; // [esp+4h] [ebp-Ch]
  int i; // [esp+8h] [ebp-8h]
  wc_gset *gset; // [esp+Ch] [ebp-4h]

  st->ces_info = &WcCesInfo[(unsigned __int8)ces];
  gset = st->ces_info->gset;
  st->state = 0;
  st->g0_ccs = 0;
  st->g1_ccs = 0;
  st->design[0] = gset->ccs;
  st->design[1] = gset[1].ccs;
  st->design[2] = 0;
  st->design[3] = 0;
  st->gl = 0;
  st->gr = 1;
  st->ss = 0;
  for ( i = 0; gset[i].ccs; ++i )
  {
    if ( gset[i].init )
    {
      g = gset[i].g & 3;
      if ( !st->design[g] )
        st->design[g] = gset[i].ccs;
    }
  }
  st->tag = 0;
  st->ntag = 0;
}

//----- (080BD4D7) --------------------------------------------------------
void __cdecl wc_output_init(wc_ces ces, wc_status *st)
{
  wc_ccs v2; // eax
  wc_ccs v3; // eax
  unsigned int v4; // eax
  wc_table **v5; // ebx
  wc_table **v6; // ebx
  wc_table **v7; // ebx
  size_t nw; // [esp+10h] [ebp-18h]
  size_t nwa; // [esp+10h] [ebp-18h]
  size_t n; // [esp+14h] [ebp-14h]
  size_t na; // [esp+14h] [ebp-14h]
  size_t i; // [esp+18h] [ebp-10h]
  size_t ia; // [esp+18h] [ebp-10h]
  wc_gset *gset; // [esp+1Ch] [ebp-Ch]

  if ( output_set && output_st.ces_info->id == ces && !memcmp(&WcOption, &output_option, 0x10u) )
  {
    *st = output_st;
    return;
  }
  st->state = 0;
  st->ces_info = &WcCesInfo[(unsigned __int8)ces];
  gset = st->ces_info->gset;
  if ( (ces == 2099217 || ces == 2099218 || ces == 2099219) && WcOption.use_jisx0201 )
    v2 = 330;
  else
    v2 = gset->ccs;
  st->g0_ccs = v2;
  if ( (ces == 2099217 || ces == 2099218 || ces == 2099219) && WcOption.use_jisc6226 )
    v3 = 33088;
  else
    v3 = gset[1].ccs;
  st->g1_ccs = v3;
  st->design[0] = st->g0_ccs;
  st->design[1] = 0;
  st->design[2] = 0;
  st->design[3] = 0;
  st->gl = 0;
  st->gr = 0;
  st->ss = 0;
  if ( (ces & 0x800) != 0 )
    wc_create_gmap(st);
  st->tag = 0;
  st->ntag = 0;
  if ( !WcOption.ucs_conv )
  {
    st->tlist = 0;
    st->tlistw = 0;
    goto LABEL_50;
  }
  nw = 0;
  n = 0;
  for ( i = 0; gset[i].ccs; ++i )
  {
    if ( (gset[i].ccs & 0x18000) != 0 )
      ++nw;
    else
      ++n;
  }
  st->tlist = (wc_table **)GC_malloc(4 * (n + 1));
  st->tlistw = (wc_table **)GC_malloc(4 * (nw + 1));
  nwa = 0;
  na = 0;
  for ( ia = 0; gset[ia].ccs; ++ia )
  {
    if ( (gset[ia].ccs & 0x18000) != 0 )
    {
      v4 = gset[ia].ccs;
      if ( v4 == 33092 )
      {
        if ( WcOption.use_jisx0212 )
          goto LABEL_43;
      }
      else
      {
        if ( v4 <= 0x8144 )
        {
          if ( v4 == 33089 && WcOption.use_gb12345_map && ces != 3153978 && ces != 3153979 )
          {
            v5 = &st->tlistw[nwa];
            *v5 = wc_get_ucs_table(0x880Eu);
            ++nwa;
            continue;
          }
LABEL_43:
          v6 = &st->tlistw[nwa];
          *v6 = wc_get_ucs_table(gset[ia].ccs);
          ++nwa;
          continue;
        }
        if ( v4 - 33103 > 1 || WcOption.use_jisx0213 )
          goto LABEL_43;
      }
    }
    else if ( gset[ia].ccs != 329 || WcOption.use_jisx0201k )
    {
      v7 = &st->tlist[na];
      *v7 = wc_get_ucs_table(gset[ia].ccs);
      ++na;
    }
  }
  st->tlist[na] = 0;
  st->tlistw[nwa] = 0;
LABEL_50:
  output_st = *st;
  output_set = 1;
  output_option = WcOption;
}
// 8049F2C: using guessed type int __cdecl GC_malloc(_DWORD);

//----- (080BD983) --------------------------------------------------------
wc_bool __cdecl wc_ces_has_ccs(wc_ccs ccs, wc_status *st)
{
  int i; // [esp+8h] [ebp-8h]
  wc_gset *gset; // [esp+Ch] [ebp-4h]

  gset = st->ces_info->gset;
  for ( i = 0; gset[i].ccs; ++i )
  {
    if ( gset[i].ccs == ccs )
      return 1;
  }
  return 0;
}

//----- (080BD9D0) --------------------------------------------------------
wc_wchar_t *__userpurge ucs_cs94_conv@<eax>(wc_wchar_t *retstr, wc_ccs ccs, wc_uint16 c)
{
  retstr->ccs = ccs;
  retstr->code = c;
  return retstr;
}

//----- (080BD9FE) --------------------------------------------------------
wc_wchar_t *__userpurge ucs_viet_conv@<eax>(wc_wchar_t *retstr, wc_ccs ccs, wc_uint16 c)
{
  wc_ccs cc; // [esp+Ch] [ebp-8h]

  if ( (c & 0x80) != 0 )
  {
    cc = ccs;
    switch ( ccs )
    {
      case 0x821u:
        cc = 2080;
        break;
      case 0x823u:
        cc = 2082;
        break;
      case 0x81Eu:
        cc = 2077;
        break;
    }
  }
  else
  {
    cc = ccs;
    switch ( ccs )
    {
      case 0x820u:
        cc = 2081;
        break;
      case 0x822u:
        cc = 2083;
        break;
      case 0x81Du:
        cc = 2078;
        break;
    }
  }
  retstr->ccs = cc;
  retstr->code = (unsigned __int8)c;
  return retstr;
}

//----- (080BDAAC) --------------------------------------------------------
wc_wchar_t *__userpurge ucs_cp1258_conv@<eax>(wc_wchar_t *retstr, wc_ccs ccs, wc_uint16 c)
{
  wc_ccs v3; // eax

  if ( c > 0xFFu )
    v3 = 2076;
  else
    v3 = 2075;
  retstr->ccs = v3;
  retstr->code = c;
  return retstr;
}

//----- (080BDAEB) --------------------------------------------------------
wc_wchar_t *__userpurge ucs_cns11643_conv@<eax>(wc_wchar_t *retstr, wc_ccs cs_0, wc_uint16 c)
{
  wc_ccs v3; // eax

  if ( (c & 0x8000u) == 0 )
    v3 = 33095;
  else
    v3 = 33096;
  retstr->ccs = v3;
  retstr->code = c & 0x7F7F;
  return retstr;
}

//----- (080BDB30) --------------------------------------------------------
wc_wchar_t *__userpurge ucs_big5_conv@<eax>(wc_wchar_t *retstr, wc_ccs cs_0, wc_uint16 c)
{
  wc_wchar_t v4; // [esp+4h] [ebp-34h]

  v4.ccs = cs_0;
  v4.code = c;
  wc_big5_to_cs94w(retstr, v4);
  return retstr;
}

//----- (080BDB70) --------------------------------------------------------
wc_wchar_t *__userpurge ucs_johab2_conv@<eax>(wc_wchar_t *retstr, wc_ccs cs_0, wc_uint16 c)
{
  wc_wchar_t v4; // [esp+4h] [ebp-34h]

  v4.ccs = cs_0;
  v4.code = c;
  wc_johab_to_cs128w(retstr, v4);
  return retstr;
}

//----- (080BDBB0) --------------------------------------------------------
wc_wchar_t *__userpurge ucs_johab3_conv@<eax>(wc_wchar_t *retstr, wc_ccs cs_0, wc_uint16 c)
{
  if ( (c <= 0x2120u || c > 0x2420u) && (c <= 0x2453u || c > 0x2C7Eu) && (c <= 0x4A20u || c > 0x7D7Eu) )
    cs_0 = 49152;
  retstr->ccs = cs_0;
  retstr->code = c;
  return retstr;
}

//----- (080BDC17) --------------------------------------------------------
wc_wchar_t *__userpurge ucs_sjis_ext_conv@<eax>(wc_wchar_t *retstr, wc_ccs cs_0, wc_uint16 c)
{
  wc_wchar_t v4; // [esp+4h] [ebp-34h]

  v4.ccs = cs_0;
  v4.code = c;
  wc_sjis_ext_to_cs94w(retstr, v4);
  return retstr;
}

//----- (080BDC57) --------------------------------------------------------
wc_wchar_t *__userpurge ucs_gbk_conv@<eax>(wc_wchar_t *retstr, wc_ccs cs_0, wc_uint16 c)
{
  wc_wchar_t v4; // [esp+4h] [ebp-34h]

  v4.ccs = cs_0;
  v4.code = c;
  wc_gbk_to_cs128w(retstr, v4);
  return retstr;
}

//----- (080BDC97) --------------------------------------------------------
wc_wchar_t *__userpurge ucs_uhc_conv@<eax>(wc_wchar_t *retstr, wc_ccs cs_0, wc_uint16 c)
{
  wc_wchar_t v4; // [esp+4h] [ebp-34h]

  v4.ccs = cs_0;
  v4.code = c;
  wc_uhc_to_cs128w(retstr, v4);
  return retstr;
}

//----- (080BDCD7) --------------------------------------------------------
wc_wchar_t *__userpurge ucs_hkscs_conv@<eax>(wc_wchar_t *retstr, wc_ccs cs_0, wc_uint16 c)
{
  wc_wchar_t v4; // [esp+4h] [ebp-34h]

  v4.ccs = cs_0;
  v4.code = c;
  wc_hkscs_to_cs128w(retstr, v4);
  return retstr;
}

//----- (080BDD17) --------------------------------------------------------
wc_table *__cdecl wc_get_ucs_table(wc_ccs ccs)
{
  wc_ccs v1; // eax
  wc_table *result; // eax

  v1 = ccs & 0xFF00;
  if ( v1 == 2048 )
  {
    if ( (_BYTE)ccs && (unsigned __int8)ccs <= 0x28u )
      result = (wc_table *)(16 * ((unsigned __int8)ccs - 1) + 135754432);
    else
      result = 0;
  }
  else if ( v1 > 0x800 )
  {
    switch ( v1 )
    {
      case 0x8200u:
        return 0;
      case 0x8800u:
        if ( (_BYTE)ccs && (unsigned __int8)ccs <= 0x21u )
          result = (wc_table *)(16 * ((unsigned __int8)ccs - 1) + 135755360);
        else
          result = 0;
        break;
      case 0x8100u:
        if ( (unsigned __int8)ccs > 0x3Fu && (unsigned __int8)ccs <= 0x50u )
          result = (wc_table *)(16 * ((unsigned __int8)ccs - 64) + 135755072);
        else
          result = 0;
        break;
      default:
        return 0;
    }
  }
  else
  {
    switch ( v1 )
    {
      case 0x200u:
        if ( (unsigned __int8)ccs > 0x3Fu && (unsigned __int8)ccs <= 0x66u )
          result = (wc_table *)(16 * ((unsigned __int8)ccs - 64) + 135753792);
        else
          result = 0;
        break;
      case 0x400u:
        return 0;
      case 0x100u:
        if ( (unsigned __int8)ccs > 0x3Fu && (unsigned __int8)ccs <= 0x54u )
          result = (wc_table *)(16 * ((unsigned __int8)ccs - 64) + 135753440);
        else
          result = 0;
        break;
      default:
        return 0;
    }
  }
  return result;
}
// 80BDE0B: conditional instruction was optimized away because of '%f.4 in (40..FF)'
// 80BDE33: conditional instruction was optimized away because of '%f.4 in (40..FF)'

//----- (080BDE9B) --------------------------------------------------------
wc_wchar_t *__userpurge wc_ucs_to_any@<eax>(wc_wchar_t *retstr, wc_uint32 ucs, wc_table *t)
{
  int v3; // eax
  wc_uint32 cc_4; // [esp+18h] [ebp-10h]
  wc_map *map; // [esp+1Ch] [ebp-Ch]

  if ( t && t->map && ucs && ucs <= 0xFFFF && wc_map_search(ucs, t->map, t->n)
    || t
    && (HIWORD(v3) = HIWORD(ucs), LOWORD(v3) = 0, v3 == 0x20000)
    && (t->ccs != 33103 ? (t->ccs != 33104 ? (t->ccs != 34847 && t->ccs != 34848 && t->ccs != 34849 ? (map = 0) : (map = wc_map_search(ucs, ucs_p2_hkscs_map, 0x439u))) : (map = wc_map_search(ucs, ucs_p2_jisx02132_map, 0x115u))) : (map = wc_map_search(ucs, ucs_p2_jisx02131_map, 0x19u)),
        map) )
  {
    t->conv(retstr);
  }
  else
  {
    retstr->ccs = 0x4000;
    retstr->code = cc_4;
  }
  return retstr;
}
// 80BE01D: variable 'cc_4' is possibly undefined

//----- (080BE029) --------------------------------------------------------
wc_uint32 __cdecl wc_any_to_ucs(wc_wchar_t cc)
{
  unsigned int v1; // eax
  wc_uint32 result; // eax
  int v3; // eax
  unsigned int v4; // esi
  unsigned int v5; // ecx
  int v6; // eax
  wc_uint32 v7; // [esp+1Ch] [ebp-4Ch]
  wc_wchar_t v8; // [esp+28h] [ebp-40h] BYREF
  wc_wchar_t v9; // [esp+3Ch] [ebp-2Ch] BYREF
  wc_wchar_t v10; // [esp+44h] [ebp-24h] BYREF
  wc_wchar_t v11; // [esp+4Ch] [ebp-1Ch] BYREF
  wc_map *map2; // [esp+54h] [ebp-14h]
  wc_uint16 *map; // [esp+58h] [ebp-10h]
  int f; // [esp+5Ch] [ebp-Ch]

  map = 0;
  f = LOBYTE(cc.ccs);
  v1 = cc.ccs & 0xFF00;
  if ( v1 == 4096 )
  {
    if ( LOWORD(cc.ccs) == 4096 )
      result = cc.code;
    else
      result = -1;
  }
  else
  {
    if ( v1 <= 0x1000 )
    {
      if ( v1 == 512 )
      {
        if ( f <= 63 || f > 102 )
          return -1;
        map = cs96_ucs_map[f - 64];
        cc.code = cc.code & 0x7F;
      }
      else
      {
        if ( v1 <= 0x200 )
        {
          if ( v1 != 256 )
            return -1;
          if ( f <= 63 || f > 84 )
            return -1;
          map = cs94_ucs_map[f - 64];
          cc.code = cc.code & 0x7F;
          goto LABEL_104;
        }
        if ( v1 == 1024 )
          return -1;
        if ( v1 != 2048 )
          return -1;
        if ( f <= 0 || f > 40 )
          return -1;
        switch ( cc.ccs )
        {
          case 0x81Fu:
            wc_tcvn57123_to_tcvn5712(&v11, (wc_wchar_t)__PAIR64__(cc.code, 2079));
            return wc_any_to_ucs(v11);
          case 0x827u:
            return 8364;
          case 0x81Cu:
            map2 = wc_map_search(cc.code, cp12582_ucs_map, 0x78u);
            if ( map2 )
              result = map2->code2;
            else
              result = -1;
            return result;
        }
        map = pcs_ucs_map[f - 1];
        cc.code = cc.code & 0x7F;
      }
LABEL_104:
      if ( !map )
        return -1;
      cc.code = map[cc.code];
      if ( cc.code )
        result = cc.code;
      else
        result = -1;
      return result;
    }
    if ( v1 == 33024 )
    {
      if ( cc.ccs == 33089 && WcOption.use_gb12345_map )
      {
        cc.ccs = 34830;
        return wc_any_to_ucs((wc_wchar_t)__PAIR64__(cc.code, 34830));
      }
      if ( cc.ccs == 33103 )
      {
        map2 = wc_map_search(cc.code & 0x7F7F, jisx02131_ucs_p2_map, 0x19u);
        if ( map2 )
          return map2->code2 | 0x20000;
      }
      else if ( cc.ccs == 33104 )
      {
        map2 = wc_map_search(cc.code & 0x7F7F, jisx02132_ucs_p2_map, 0x115u);
        if ( map2 )
          return map2->code2 | 0x20000;
      }
      if ( f <= 63 || f > 80 )
        return 0;
      map = cs94w_ucs_map[f - 64];
      cc.code = (cc.code & 0x7F) + 94 * ((cc.code >> 8) & 0x7F) - 3135;
      goto LABEL_104;
    }
    if ( v1 > 0x8100 )
    {
      if ( v1 == 33280 )
        return -1;
      if ( v1 != 34816 )
        return -1;
      if ( f <= 0 || f > 33 )
        return -1;
      map = pcsw_ucs_map[f - 1];
      switch ( cc.ccs )
      {
        case 0x8801u:
          if ( LOBYTE(cc.code) > 0xA0u )
            v3 = 98;
          else
            v3 = 64;
          cc.code = 157 * BYTE1(cc.code) + LOBYTE(cc.code) - v3 - 25277;
          goto LABEL_104;
        case 0x8803u:
          cc.code = (cc.code & 0x7F) + 94 * ((cc.code >> 8) & 0x7F) + 3145;
          goto LABEL_104;
        case 0x880Fu:
          wc_johab_to_cs128w(&v10, cc);
          return wc_any_to_ucs(v10);
        case 0x8810u:
          return ((((cc.code >> 8) & 0x7F) + 33554399) << 7) + (cc.code & 0x7F) + 44032;
        case 0x8811u:
          v7 = (((cc.code >> 8) & 0x7F) << 7) + (cc.code & 0x7F);
          v4 = (v7 / 0xBC + 132) << 8;
          v5 = v7 % 0xBC;
          if ( v7 % 0xBC > 0x3D )
            v6 = 67;
          else
            v6 = 65;
          cc.code = v4 + v5 + v6;
          map2 = wc_map_search(v4 + v5 + v6, johab2_ucs_map, 0x33u);
          if ( map2 )
            result = map2->code2;
          else
            result = -1;
          return result;
        case 0x8812u:
          if ( (cc.code & 0x7F7F) > 0x2120 )
            goto LABEL_76;
          return -1;
        case 0x8813u:
LABEL_76:
          wc_sjis_ext_to_cs94w(&v9, cc);
          return wc_any_to_ucs(v9);
        case 0x8814u:
          cc.code = wc_sjis_ext1_to_N(cc.code);
          if ( cc.code != -1 )
            goto LABEL_104;
          return -1;
        case 0x8815u:
          cc.code = wc_sjis_ext2_to_N(cc.code);
          if ( cc.code != -1 )
            goto LABEL_104;
          return -1;
        case 0x8816u:
          goto LABEL_84;
        case 0x8817u:
        case 0x8818u:
          wc_cs128w_to_gbk(&v8, cc);
          cc = v8;
LABEL_84:
          cc.code = wc_gbk_to_N(cc.code);
          goto LABEL_104;
        case 0x8819u:
        case 0x881Au:
        case 0x881Bu:
          goto LABEL_85;
        case 0x881Cu:
          goto LABEL_87;
        case 0x881Du:
        case 0x881Eu:
          wc_cs128w_to_uhc(&v8, cc);
          cc = v8;
LABEL_87:
          if ( cc.code > 0xC6FE )
            return -1;
          cc.code = wc_uhc_to_N(cc.code);
          goto LABEL_104;
        case 0x881Fu:
          goto LABEL_63;
        case 0x8820u:
        case 0x8821u:
          wc_cs128w_to_hkscs(&cc, cc);
LABEL_63:
          map2 = wc_map_search(cc.code, hkscs_ucs_p2_map, 0x439u);
          if ( map2 )
            return map2->code2 | 0x20000;
          cc.code = wc_hkscs_to_N(cc.code);
          break;
        default:
          cc.code = (cc.code & 0x7F) + 94 * ((cc.code >> 8) & 0x7F) - 3135;
          goto LABEL_104;
      }
      goto LABEL_104;
    }
    if ( v1 != 0x2000 )
    {
      if ( v1 == 0x4000 && cc.ccs == 16385 )
      {
        result = cc.code;
        LOBYTE(result) = LOBYTE(cc.code) | 0x80;
        return result;
      }
      return -1;
    }
    switch ( LOWORD(cc.ccs) )
    {
      case 0x2001u:
        result = cc.code & 0x1FFFFF;
        break;
      case 0x2002u:
LABEL_85:
        result = wc_gb18030_to_ucs(cc);
        break;
      case 0x2000u:
        result = cc.code;
        break;
      default:
        result = -1;
        break;
    }
  }
  return result;
}
// 80BE25A: conditional instruction was optimized away because of '%f.4 in (40..FF)'
// 80BE2AE: conditional instruction was optimized away because of '%f.4 in (40..FF)'

//----- (080BE7F3) --------------------------------------------------------
wc_wchar_t *__userpurge wc_any_to_any@<eax>(wc_wchar_t *retstr, wc_wchar_t cc, wc_table *t)
{
  wc_uint32 v3; // edx
  wc_uint32 v4; // edx
  wc_ccs v5; // eax
  wc_uint32 v6; // edx
  wc_wchar_t v8; // [esp+18h] [ebp-20h] BYREF
  wc_uint32 ucs; // [esp+28h] [ebp-10h]
  wc_ccs is_wide; // [esp+2Ch] [ebp-Ch]

  is_wide = cc.ccs & 0x18000;
  ucs = wc_any_to_ucs(cc);
  if ( ucs != -1 )
  {
    wc_ucs_to_any(&cc, ucs, t);
    if ( (cc.ccs & 0x4000) == 0 )
    {
      v3 = cc.code;
      retstr->ccs = cc.ccs;
      retstr->code = v3;
      return retstr;
    }
    ucs = wc_ucs_to_fullwidth(ucs);
    if ( ucs != -1 )
    {
      wc_ucs_to_any(&v8, ucs, t);
      cc = v8;
      if ( (v8.ccs & 0x4000) == 0 )
      {
        v4 = cc.code;
        retstr->ccs = cc.ccs;
        retstr->code = v4;
        return retstr;
      }
    }
  }
  if ( is_wide )
    v5 = 49152;
  else
    v5 = 0x4000;
  cc.ccs = v5;
  v6 = cc.code;
  retstr->ccs = v5;
  retstr->code = v6;
  return retstr;
}

//----- (080BE8DA) --------------------------------------------------------
wc_wchar_t *__userpurge wc_ucs_to_any_list@<eax>(wc_wchar_t *retstr, wc_uint32 ucs, wc_table **tlist)
{
  wc_uint32 v3; // edx
  wc_uint32 v4; // edx
  wc_wchar_t cc; // [esp+14h] [ebp-14h] BYREF
  wc_table **t; // [esp+1Ch] [ebp-Ch]

  if ( tlist )
  {
    for ( t = tlist; *t; ++t )
    {
      if ( (*t)->map )
      {
        wc_ucs_to_any(&cc, ucs, *t);
        if ( (cc.ccs & 0x4000) == 0 )
        {
          v3 = cc.code;
          retstr->ccs = cc.ccs;
          retstr->code = v3;
          return retstr;
        }
      }
    }
  }
  cc.ccs = 0x4000;
  v4 = cc.code;
  retstr->ccs = 0x4000;
  retstr->code = v4;
  return retstr;
}

//----- (080BE95E) --------------------------------------------------------
wc_wchar_t *__userpurge wc_any_to_any_ces@<eax>(wc_wchar_t *retstr, wc_wchar_t cc, wc_status *st)
{
  wc_uint32 v3; // edx
  wc_uint32 v4; // edx
  wc_ccs v5; // eax
  wc_uint32 v6; // edx
  wc_table **v7; // eax
  wc_uint32 v8; // edx
  wc_table **v9; // eax
  wc_uint32 v10; // edx
  wc_ccs v11; // eax
  wc_uint32 v12; // edx
  wc_uint32 v13; // edx
  wc_table **v14; // eax
  wc_uint32 v15; // edx
  wc_table **v16; // eax
  wc_uint32 v17; // edx
  wc_ccs v18; // eax
  wc_uint32 v19; // edx
  wc_wchar_t v21; // [esp+18h] [ebp-20h] BYREF
  wc_ccs is_wide; // [esp+28h] [ebp-10h]
  wc_uint32 ucs; // [esp+2Ch] [ebp-Ch]

  ucs = wc_any_to_ucs(cc);
  is_wide = cc.ccs & 0x18000;
  if ( ucs <= 0x7F )
  {
    cc.ccs = 322;
    cc.code = ucs;
    v3 = ucs;
    retstr->ccs = 322;
    retstr->code = v3;
    return retstr;
  }
  if ( ucs == -1 )
    goto LABEL_49;
  if ( (st->ces_info->id & 0x8000) != 0 )
  {
    cc.ccs = wc_ucs_to_ccs(ucs);
    cc.code = ucs;
    v4 = ucs;
    retstr->ccs = cc.ccs;
    retstr->code = v4;
    return retstr;
  }
  if ( st->ces_info->id == 3153984 )
  {
    wc_ucs_to_johab(&cc, ucs);
    if ( (cc.ccs & 0x4000) != 0 )
    {
      if ( is_wide )
        v5 = 49152;
      else
        v5 = 0x4000;
      cc.ccs = v5;
    }
    v6 = cc.code;
    retstr->ccs = cc.ccs;
    retstr->code = v6;
    return retstr;
  }
  if ( is_wide )
    v7 = st->tlistw;
  else
    v7 = st->tlist;
  wc_ucs_to_any_list(&v21, ucs, v7);
  cc = v21;
  if ( (v21.ccs & 0x4000) == 0 )
  {
    v8 = cc.code;
    retstr->ccs = cc.ccs;
    retstr->code = v8;
    return retstr;
  }
  if ( !WcOption.fix_width_conv )
  {
    v9 = is_wide ? st->tlist : st->tlistw;
    wc_ucs_to_any_list(&v21, ucs, v9);
    cc = v21;
    if ( (v21.ccs & 0x4000) == 0 )
    {
      v10 = cc.code;
      retstr->ccs = cc.ccs;
      retstr->code = v10;
      return retstr;
    }
  }
  if ( st->ces_info->id != 3153979 )
  {
    if ( ucs == 160 )
    {
      cc.ccs = 322;
      cc.code = 32;
      retstr->ccs = 322;
      retstr->code = 32;
      return retstr;
    }
    if ( (st->ces_info->id & 0x1200) != 0 && ucs > 0x7F && ucs <= 0x9F )
    {
      cc.ccs = 16385;
      cc.code = ucs;
      v13 = ucs;
      retstr->ccs = 16385;
      retstr->code = v13;
      return retstr;
    }
    ucs = wc_ucs_to_fullwidth(ucs);
    if ( ucs != -1 )
    {
      if ( is_wide )
        v14 = st->tlistw;
      else
        v14 = st->tlist;
      wc_ucs_to_any_list(&v21, ucs, v14);
      cc = v21;
      if ( (v21.ccs & 0x4000) == 0 )
      {
        v15 = cc.code;
        retstr->ccs = cc.ccs;
        retstr->code = v15;
        return retstr;
      }
      if ( !WcOption.fix_width_conv )
      {
        v16 = is_wide ? st->tlist : st->tlistw;
        wc_ucs_to_any_list(&v21, ucs, v16);
        cc = v21;
        if ( (v21.ccs & 0x4000) == 0 )
        {
          v17 = cc.code;
          retstr->ccs = cc.ccs;
          retstr->code = v17;
          return retstr;
        }
      }
    }
LABEL_49:
    if ( is_wide )
      v18 = 49152;
    else
      v18 = 0x4000;
    cc.ccs = v18;
    v19 = cc.code;
    retstr->ccs = v18;
    retstr->code = v19;
    return retstr;
  }
  wc_ucs_to_gb18030(&v21, ucs);
  cc = v21;
  if ( (v21.ccs & 0x4000) != 0 )
  {
    if ( is_wide )
      v11 = 49152;
    else
      v11 = 0x4000;
    cc.ccs = v11;
  }
  v12 = cc.code;
  retstr->ccs = cc.ccs;
  retstr->code = v12;
  return retstr;
}

//----- (080BECA5) --------------------------------------------------------
wc_wchar_t *__userpurge wc_any_to_iso2022@<eax>(wc_wchar_t *retstr, wc_wchar_t cc, wc_status *st)
{
  wc_uint32 v3; // edx
  wc_table **v4; // eax
  wc_uint32 v5; // edx
  wc_uint32 v6; // edx
  wc_table **v7; // eax
  wc_uint32 v8; // edx
  wc_uint32 v9; // edx
  wc_table **v10; // eax
  wc_uint32 v11; // edx
  wc_uint32 v12; // edx
  wc_table **v13; // eax
  wc_uint32 v14; // edx
  wc_uint32 v15; // edx
  wc_ccs v16; // eax
  wc_uint32 v17; // edx
  wc_wchar_t v19; // [esp+18h] [ebp-20h] BYREF
  wc_ccs is_wide; // [esp+28h] [ebp-10h]
  wc_uint32 ucs; // [esp+2Ch] [ebp-Ch]

  ucs = wc_any_to_ucs(cc);
  is_wide = cc.ccs & 0x18000;
  if ( ucs > 0x7F )
  {
    if ( ucs != -1 )
    {
      if ( is_wide )
        v4 = st->tlistw;
      else
        v4 = st->tlist;
      wc_ucs_to_any_list(&cc, ucs, v4);
      if ( (cc.ccs & 0x4000) == 0 )
      {
        v5 = cc.code;
        retstr->ccs = cc.ccs;
        retstr->code = v5;
        return retstr;
      }
      if ( !WcOption.strict_iso2022 )
      {
        if ( is_wide )
          wc_ucs_to_iso2022w(&v19, ucs);
        else
          wc_ucs_to_iso2022(&v19, ucs);
        cc = v19;
        if ( (v19.ccs & 0x4000) == 0 )
        {
          v6 = cc.code;
          retstr->ccs = cc.ccs;
          retstr->code = v6;
          return retstr;
        }
      }
      if ( !WcOption.fix_width_conv )
      {
        if ( is_wide )
          v7 = st->tlist;
        else
          v7 = st->tlistw;
        wc_ucs_to_any_list(&v19, ucs, v7);
        cc = v19;
        if ( (v19.ccs & 0x4000) == 0 )
        {
          v8 = cc.code;
          retstr->ccs = cc.ccs;
          retstr->code = v8;
          return retstr;
        }
        if ( !WcOption.strict_iso2022 )
        {
          if ( is_wide )
            wc_ucs_to_iso2022(&v19, ucs);
          else
            wc_ucs_to_iso2022w(&v19, ucs);
          cc = v19;
          if ( (v19.ccs & 0x4000) == 0 )
          {
            v9 = cc.code;
            retstr->ccs = cc.ccs;
            retstr->code = v9;
            return retstr;
          }
        }
      }
      if ( ucs == 160 )
      {
        cc.ccs = 322;
        cc.code = 32;
        retstr->ccs = 322;
        retstr->code = 32;
        return retstr;
      }
      ucs = wc_ucs_to_fullwidth(ucs);
      if ( ucs != -1 )
      {
        if ( is_wide )
          v10 = st->tlistw;
        else
          v10 = st->tlist;
        wc_ucs_to_any_list(&v19, ucs, v10);
        cc = v19;
        if ( (v19.ccs & 0x4000) == 0 )
        {
          v11 = cc.code;
          retstr->ccs = cc.ccs;
          retstr->code = v11;
          return retstr;
        }
        if ( !WcOption.strict_iso2022 )
        {
          if ( is_wide )
            wc_ucs_to_iso2022w(&v19, ucs);
          else
            wc_ucs_to_iso2022(&v19, ucs);
          cc = v19;
          if ( (v19.ccs & 0x4000) == 0 )
          {
            v12 = cc.code;
            retstr->ccs = cc.ccs;
            retstr->code = v12;
            return retstr;
          }
        }
        if ( !WcOption.fix_width_conv )
        {
          if ( is_wide )
            v13 = st->tlist;
          else
            v13 = st->tlistw;
          wc_ucs_to_any_list(&v19, ucs, v13);
          cc = v19;
          if ( (v19.ccs & 0x4000) == 0 )
          {
            v14 = cc.code;
            retstr->ccs = cc.ccs;
            retstr->code = v14;
            return retstr;
          }
          if ( !WcOption.strict_iso2022 )
          {
            if ( is_wide )
              wc_ucs_to_iso2022(&v19, ucs);
            else
              wc_ucs_to_iso2022w(&v19, ucs);
            cc = v19;
            if ( (v19.ccs & 0x4000) == 0 )
            {
              v15 = cc.code;
              retstr->ccs = cc.ccs;
              retstr->code = v15;
              return retstr;
            }
          }
        }
      }
      if ( ucs == 160 )
      {
        cc.ccs = 322;
        cc.code = 32;
        retstr->ccs = 322;
        retstr->code = 32;
        return retstr;
      }
    }
    if ( is_wide )
      v16 = 49152;
    else
      v16 = 0x4000;
    cc.ccs = v16;
    v17 = cc.code;
    retstr->ccs = v16;
    retstr->code = v17;
  }
  else
  {
    cc.ccs = 322;
    cc.code = ucs;
    v3 = ucs;
    retstr->ccs = 322;
    retstr->code = v3;
  }
  return retstr;
}

//----- (080BF0AF) --------------------------------------------------------
wc_wchar_t *wc_ucs_to_iso2022(wc_wchar_t *retstr, wc_uint32 ucs)
{
  wc_uint32 v2; // edx
  wc_uint32 v3; // edx
  wc_uint32 v4; // edx
  wc_wchar_t v6; // [esp+18h] [ebp-20h] BYREF
  wc_wchar_t cc; // [esp+20h] [ebp-18h] BYREF
  int f; // [esp+28h] [ebp-10h]
  wc_table *t; // [esp+2Ch] [ebp-Ch]

  if ( ucs <= 0xFFFF )
  {
    for ( f = 0; f <= 38; ++f )
    {
      t = (wc_table *)(16 * f + 135753792);
      if ( ucs_cs96_table[f].map )
      {
        wc_ucs_to_any(&cc, (unsigned __int16)ucs, t);
        if ( (cc.ccs & 0x4000) == 0 )
        {
          v2 = cc.code;
          retstr->ccs = cc.ccs;
          retstr->code = v2;
          return retstr;
        }
      }
    }
    for ( f = 0; f <= 20; ++f )
    {
      t = (wc_table *)(16 * f + 135753440);
      if ( ucs_cs94_table[f].map )
      {
        wc_ucs_to_any(&v6, (unsigned __int16)ucs, t);
        cc = v6;
        if ( (v6.ccs & 0x4000) == 0 )
        {
          v3 = cc.code;
          retstr->ccs = cc.ccs;
          retstr->code = v3;
          return retstr;
        }
      }
    }
    f = 0;
  }
  cc.ccs = 0x4000;
  v4 = cc.code;
  retstr->ccs = 0x4000;
  retstr->code = v4;
  return retstr;
}
// 80BF210: conditional instruction was optimized away because of '%f.4==0'
// 80BF0AF: inconsistent function type and number of purged bytes

//----- (080BF22D) --------------------------------------------------------
wc_wchar_t *wc_ucs_to_iso2022w(wc_wchar_t *retstr, wc_uint32 ucs)
{
  wc_uint32 v2; // edx
  wc_uint32 v3; // edx
  wc_wchar_t cc; // [esp+20h] [ebp-18h] BYREF
  int f; // [esp+28h] [ebp-10h]
  wc_table *t; // [esp+2Ch] [ebp-Ch]

  if ( ucs <= 0xFFFF )
  {
    for ( f = 0; f <= 16; ++f )
    {
      t = (wc_table *)(16 * f + 135755072);
      if ( ucs_cs94w_table[f].map )
      {
        wc_ucs_to_any(&cc, (unsigned __int16)ucs, t);
        if ( (cc.ccs & 0x4000) == 0 )
        {
          v2 = cc.code;
          retstr->ccs = cc.ccs;
          retstr->code = v2;
          return retstr;
        }
      }
    }
    f = 0;
  }
  cc.ccs = 49152;
  v3 = cc.code;
  retstr->ccs = 49152;
  retstr->code = v3;
  return retstr;
}
// 80BF31B: conditional instruction was optimized away because of '%f.4==0'
// 80BF22D: inconsistent function type and number of purged bytes

//----- (080BF338) --------------------------------------------------------
wc_ccs __cdecl wc_ucs_to_ccs(wc_uint32 ucs)
{
  int v2; // ebx
  int v3; // eax
  int v4; // ebx
  int v5; // eax

  if ( ucs > 0x7F && ucs <= 0x9F )
    return 16385;
  if ( ucs > 0xFFFF )
    v2 = 0x2000;
  else
    v2 = 4096;
  if ( wc_is_ucs_wide(ucs) )
    v3 = 0x10000;
  else
    v3 = 0;
  v4 = v3 | v2;
  if ( wc_is_ucs_combining(ucs) )
    v5 = 0x20000;
  else
    v5 = 0;
  return v4 | v5;
}

//----- (080BF3AA) --------------------------------------------------------
wc_bool __cdecl wc_is_ucs_wide(wc_uint32 ucs)
{
  wc_bool result; // al
  int v2; // eax
  int v3; // eax

  if ( ucs <= 0xFFFF )
    return wc_map_range_search(ucs, ucs_wide_map, 11) != 0;
  HIWORD(v2) = HIWORD(ucs);
  LOWORD(v2) = 0;
  result = 1;
  if ( v2 != 0x20000 )
  {
    HIWORD(v3) = HIWORD(ucs);
    LOWORD(v3) = 0;
    if ( v3 != 196608 )
      result = 0;
  }
  return result;
}

//----- (080BF408) --------------------------------------------------------
wc_bool __cdecl wc_is_ucs_combining(wc_uint32 ucs)
{
  return WcOption.use_combining && ucs <= 0xFFFF && wc_map_range_search(ucs, ucs_combining_map, 99);
}

//----- (080BF452) --------------------------------------------------------
wc_bool __cdecl wc_is_ucs_hangul(wc_uint32 ucs)
{
  return ucs <= 0xFFFF && wc_map_range_search(ucs, ucs_hangul_map, 6);
}

//----- (080BF491) --------------------------------------------------------
wc_uint32 __cdecl wc_ucs_precompose(wc_uint32 ucs1, wc_uint32 ucs2)
{
  wc_uint32 result; // eax
  wc_map3 *map; // [esp+1Ch] [ebp-Ch]

  if ( WcOption.use_combining
    && ucs1 <= 0xFFFF
    && ucs2 <= 0xFFFF
    && (map = wc_map3_search(ucs1, ucs2, ucs_precompose_map, 0x3DCu)) != 0 )
  {
    result = map->code3;
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (080BF4F8) --------------------------------------------------------
wc_uint32 __cdecl wc_ucs_to_fullwidth(wc_uint32 ucs)
{
  wc_uint32 result; // eax
  wc_map *map; // [esp+1Ch] [ebp-Ch]

  if ( ucs <= 0xFFFF && (map = wc_map_search(ucs, ucs_fullwidth_map, 0xEu)) != 0 )
    result = map->code2;
  else
    result = -1;
  return result;
}

//----- (080BF541) --------------------------------------------------------
int __cdecl wc_ucs_put_tag(char *p)
{
  int i; // [esp+1Ch] [ebp-Ch]

  if ( !p || !*p )
    return 0;
  for ( i = 1; i <= n_tag_map; ++i )
  {
    if ( !strcasecmp(p, tag_map[i]) )
      return i;
  }
  if ( ++n_tag_map == 256 )
    return 0;
  tag_map[n_tag_map] = p;
  return n_tag_map;
}

//----- (080BF5CD) --------------------------------------------------------
char *__cdecl wc_ucs_get_tag(int ntag)
{
  char *result; // eax

  if ( ntag && ntag <= n_tag_map )
    result = tag_map[ntag];
  else
    result = 0;
  return result;
}

//----- (080BF5F3) --------------------------------------------------------
void __cdecl wtf_push_ucs(Str os, wc_uint32 ucs, wc_status *st)
{
  Str v3; // eax
  int v4; // edx
  int v5; // eax
  int v6; // eax
  wc_ccs ccs; // [esp+1Ch] [ebp-Ch]

  if ( ucs <= 0xDFFFF || ucs > 0xE007F )
  {
    if ( st->tag )
    {
      st->ntag = wc_ucs_put_tag(st->tag->ptr);
      st->tag = 0;
    }
    if ( ucs > 0x7F )
    {
      ccs = wc_ucs_to_ccs(ucs);
      if ( st->ntag && ucs <= 0x10FFFF )
      {
        HIWORD(v6) = HIWORD(ccs);
        LOWORD(v6) = 0;
        ccs = v6 | 0x2001;
        ucs |= st->ntag << 24;
      }
      wtf_push(os, ccs, ucs);
    }
    else if ( st->ntag )
    {
      wtf_push(os, 0x2001u, ucs | (st->ntag << 24));
    }
    else
    {
      if ( os->length + 1 >= os->area_size )
        Strgrow(os);
      v5 = os->length;
      os->ptr[v5] = ucs;
      os->length = v5 + 1;
      os->ptr[os->length] = 0;
    }
  }
  else if ( WcOption.use_language_tag )
  {
    if ( ucs == 917505 )
    {
      st->tag = Strnew_size(4);
    }
    else if ( ucs == 917631 )
    {
      st->tag = 0;
      st->ntag = 0;
    }
    else if ( st->tag && ucs > 0xE001F )
    {
      if ( st->tag->length + 1 >= st->tag->area_size )
        Strgrow(st->tag);
      v3 = st->tag;
      v4 = v3->length;
      v3->ptr[v4] = ucs & 0x7F;
      v3->length = v4 + 1;
      st->tag->ptr[st->tag->length] = 0;
    }
  }
}

//----- (080BF800) --------------------------------------------------------
wc_wchar_t *__userpurge wc_uhc_to_cs128w@<eax>(wc_wchar_t *retstr, wc_wchar_t cc)
{
  int v2; // eax

  if ( LOBYTE(cc.code) <= 0x60u )
  {
    v2 = 65;
  }
  else if ( LOBYTE(cc.code) > 0x80u )
  {
    v2 = 77;
  }
  else
  {
    v2 = 71;
  }
  cc.code = 178 * BYTE1(cc.code) + LOBYTE(cc.code) - v2 - 22962;
  if ( cc.code > 0x3FFF )
  {
    cc.ccs = 34846;
    cc.code -= 0x4000;
  }
  else
  {
    cc.ccs = 34845;
  }
  retstr->ccs = cc.ccs;
  retstr->code = (cc.code >> 7 << 8) + (cc.code & 0x7F);
  return retstr;
}

//----- (080BF8AF) --------------------------------------------------------
wc_wchar_t *__userpurge wc_cs128w_to_uhc@<eax>(wc_wchar_t *retstr, wc_wchar_t cc)
{
  int v2; // eax
  unsigned int cc_4; // [esp+20h] [ebp+10h]

  cc.code = (((cc.code >> 8) & 0x7F) << 7) + (cc.code & 0x7F);
  if ( cc.ccs == 34846 )
    cc_4 += 0x4000;
  if ( cc_4 % 0xB2 <= 0x19 )
  {
    v2 = 65;
  }
  else if ( cc_4 % 0xB2 > 0x33 )
  {
    v2 = 77;
  }
  else
  {
    v2 = 71;
  }
  retstr->ccs = 34844;
  retstr->code = ((cc_4 / 0xB2 + 129) << 8) + cc_4 % 0xB2 + v2;
  return retstr;
}

//----- (080BF9A2) --------------------------------------------------------
wc_uint32 __cdecl wc_uhc_to_N(wc_uint32 c)
{
  int v1; // eax
  wc_uint32 result; // eax
  int v3; // eax
  int v4; // eax

  if ( c > 0xA1A0 )
  {
    if ( c > 0xA2A0 )
    {
      if ( c > 0xA2E7 )
      {
        if ( (unsigned __int8)c <= 0x60u )
        {
          v4 = 65;
        }
        else if ( (unsigned __int8)c > 0x80u )
        {
          v4 = 77;
        }
        else
        {
          v4 = 71;
        }
        result = 178 * BYTE1(c) + (unsigned __int8)c - v4 - 94 * (c >> 8) - 7826;
      }
      else
      {
        result = c - 35838;
      }
    }
    else
    {
      if ( (unsigned __int8)c <= 0x60u )
      {
        v3 = 65;
      }
      else if ( (unsigned __int8)c > 0x80u )
      {
        v3 = 77;
      }
      else
      {
        v3 = 71;
      }
      result = 178 * BYTE1(c) + (unsigned __int8)c - v3 - 23056;
    }
  }
  else
  {
    if ( (unsigned __int8)c <= 0x60u )
    {
      v1 = 65;
    }
    else if ( (unsigned __int8)c > 0x80u )
    {
      v1 = 77;
    }
    else
    {
      v1 = 71;
    }
    result = 178 * BYTE1(c) + (unsigned __int8)c - v1 - 22962;
  }
  return result;
}

//----- (080BFAE3) --------------------------------------------------------
Str __cdecl wc_conv_from_uhc(Str is, wc_ces ces)
{
  int v3; // eax
  int v4; // eax
  int uhc; // [esp+18h] [ebp-20h]
  int state; // [esp+1Ch] [ebp-1Ch]
  wc_uchar *p; // [esp+20h] [ebp-18h]
  wc_uchar *ep; // [esp+24h] [ebp-14h]
  char *sp_0; // [esp+28h] [ebp-10h]
  Str os; // [esp+2Ch] [ebp-Ch]

  sp_0 = is->ptr;
  ep = (wc_uchar *)&is->ptr[is->length];
  state = 0;
  for ( p = (wc_uchar *)is->ptr; p < ep && (*p & 0x80u) == 0; ++p )
    ;
  if ( p == ep )
    return is;
  os = Strnew_size(is->length);
  if ( p > (wc_uchar *)sp_0 )
    Strcat_charp_n(os, is->ptr, p - (wc_uchar *)sp_0);
  while ( p < ep )
  {
    if ( state )
    {
      if ( (WC_UHC_MAP[*p] & 4) != 0 )
      {
        uhc = (*(p - 1) << 8) | *p;
        if ( *(p - 1) <= 0xA0u || *p <= 0xA0u || uhc == 41702 || uhc == 41703 )
          wtf_push(os, 0x881Cu, uhc);
        else
          wtf_push(os, 0x8143u, uhc);
      }
      else
      {
        wtf_push_unknown(os, p - 1, 2u);
      }
      state = 0;
    }
    else
    {
      v3 = WC_UHC_MAP[*p];
      if ( v3 == 2 )
      {
        wtf_push_unknown(os, p, 1u);
      }
      else if ( v3 == 12 )
      {
        state = 1;
      }
      else
      {
        if ( os->length + 1 >= os->area_size )
          Strgrow(os);
        v4 = os->length;
        os->ptr[v4] = *p;
        os->length = v4 + 1;
        os->ptr[os->length] = 0;
      }
    }
    ++p;
  }
  if ( state == 1 )
    wtf_push_unknown(os, p - 1, 1u);
  return os;
}
// 80BFB7E: conditional instruction was optimized away because of '%state.4==1'

//----- (080BFD21) --------------------------------------------------------
void __cdecl wc_push_to_uhc(Str os, wc_wchar_t cc, wc_status *st)
{
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  wc_ccs v8; // eax
  wc_wchar_t v9; // [esp+18h] [ebp-10h] BYREF

  while ( cc.ccs != 34844 )
  {
    if ( cc.ccs > 0x881C )
    {
      if ( cc.ccs <= 0x881E )
      {
        wc_cs128w_to_uhc(&cc, cc);
        break;
      }
      if ( cc.ccs == 49152 )
      {
        if ( !WcOption.no_replace )
          Strcat_charp(os, WcReplaceW);
        return;
      }
    }
    else
    {
      switch ( cc.ccs )
      {
        case 0x4000u:
          if ( !WcOption.no_replace )
            Strcat_charp(os, WcReplace);
          return;
        case 0x8143u:
          if ( os->length + 1 >= os->area_size )
            Strgrow(os);
          v4 = os->length;
          os->ptr[v4] = BYTE1(cc.code) | 0x80;
          os->length = v4 + 1;
          os->ptr[os->length] = 0;
          if ( os->length + 1 >= os->area_size )
            Strgrow(os);
          v5 = os->length;
          os->ptr[v5] = LOBYTE(cc.code) | 0x80;
          os->length = v5 + 1;
          os->ptr[os->length] = 0;
          return;
        case 0x142u:
          if ( os->length + 1 >= os->area_size )
            Strgrow(os);
          v3 = os->length;
          os->ptr[v3] = cc.code;
          os->length = v3 + 1;
          os->ptr[os->length] = 0;
          return;
      }
    }
    if ( WcOption.ucs_conv )
    {
      wc_any_to_any_ces(&v9, cc, st);
      cc = v9;
    }
    else
    {
      if ( (cc.ccs & 0x18000) != 0 )
        v8 = 49152;
      else
        v8 = 0x4000;
      cc.ccs = v8;
    }
  }
  if ( os->length + 1 >= os->area_size )
    Strgrow(os);
  v6 = os->length;
  os->ptr[v6] = BYTE1(cc.code);
  os->length = v6 + 1;
  os->ptr[os->length] = 0;
  if ( os->length + 1 >= os->area_size )
    Strgrow(os);
  v7 = os->length;
  os->ptr[v7] = cc.code;
  os->length = v7 + 1;
  os->ptr[os->length] = 0;
}

//----- (080BFFD6) --------------------------------------------------------
Str __cdecl wc_char_conv_from_uhc(wc_uchar c, wc_status *st)
{
  int v2; // eax
  int v3; // eax
  Str v5; // eax
  int v6; // edx
  int uhc; // [esp+2Ch] [ebp-Ch]

  if ( st->state == -1 )
  {
    st->state = 0;
    os_2735 = Strnew_size(8);
  }
  v2 = st->state;
  if ( v2 )
  {
    if ( v2 == 1 && (WC_UHC_MAP[c] & 4) != 0 )
    {
      uhc = (uhcu_2736 << 8) | c;
      if ( uhcu_2736 <= 0xA0u || c <= 0xA0u || uhc == 41702 || uhc == 41703 )
        wtf_push(os_2735, 0x881Cu, uhc);
      else
        wtf_push(os_2735, 0x8143u, uhc);
    }
  }
  else
  {
    v3 = WC_UHC_MAP[c];
    if ( v3 != 2 )
    {
      if ( v3 == 12 )
      {
        uhcu_2736 = c;
        st->state = 1;
        return 0;
      }
      if ( os_2735->length + 1 >= os_2735->area_size )
        Strgrow(os_2735);
      v5 = os_2735;
      v6 = os_2735->length;
      os_2735->ptr[v6] = c;
      v5->length = v6 + 1;
      os_2735->ptr[os_2735->length] = 0;
    }
  }
  st->state = -1;
  return os_2735;
}

//----- (080C0158) --------------------------------------------------------
Str __cdecl wc_conv_from_utf7(Str is, wc_ces ces)
{
  int v3; // eax
  int v4; // eax
  int v5; // eax
  wc_status st; // [esp+18h] [ebp-60h] BYREF
  wc_uint32 high; // [esp+54h] [ebp-24h]
  wc_uint32 b; // [esp+58h] [ebp-20h]
  int state; // [esp+5Ch] [ebp-1Ch]
  wc_uchar *p; // [esp+60h] [ebp-18h]
  wc_uchar *ep; // [esp+64h] [ebp-14h]
  wc_uchar *sp_0; // [esp+68h] [ebp-10h]
  Str os; // [esp+6Ch] [ebp-Ch]

  sp_0 = (wc_uchar *)is->ptr;
  ep = &sp_0[is->length];
  state = 0;
  high = 0;
  for ( p = sp_0; p < ep && (*p & 0x80u) == 0 && *p != 43; ++p )
    ;
  if ( p == ep )
    return is;
  os = Strnew_size(4 * is->length / 3);
  if ( p > sp_0 )
    Strcat_charp_n(os, is->ptr, p - sp_0);
  st.tag = 0;
  st.ntag = 0;
  while ( p < ep )
  {
    if ( state == 1 )
    {
      if ( *p == 45 )
        wtf_push_ucs(os, 0x2Bu, &st);
    }
    else if ( state != 2 )
    {
      if ( !state && *p == 43 )
      {
        state = 1;
        st.shift = 16;
        st.base = 0;
        high = 0;
        goto LABEL_45;
      }
      goto LABEL_37;
    }
    v3 = WC_UTF7_MAP[*p];
    switch ( v3 )
    {
      case 32:
        goto LABEL_21;
      case 64:
        state = 0;
        goto LABEL_45;
      case 16:
LABEL_21:
        b = c_base64_map[*p - 32];
        st.shift -= 6;
        if ( st.shift <= 0 )
        {
          st.base |= b >> -LOBYTE(st.shift);
          if ( st.base <= 0xD7FF || st.base > 0xDBFF )
          {
            if ( st.base <= 0xDBFF || st.base > 0xDFFF )
            {
              if ( st.base != 65279 )
                wtf_push_ucs(os, st.base, &st);
            }
            else
            {
              if ( high )
                wtf_push_ucs(os, (((high & 0x3FF) << 10) | st.base & 0x3FF) + 0x10000, &st);
              high = 0;
            }
          }
          else if ( high )
          {
            high = 0;
          }
          else
          {
            high = st.base;
          }
          st.shift += 16;
          st.base = 0;
        }
        st.base |= (unsigned __int16)(b << SLOBYTE(st.shift));
        state = 2;
        goto LABEL_45;
    }
LABEL_37:
    v4 = WC_UTF7_MAP[*p];
    switch ( v4 )
    {
      case 6:
        goto LABEL_40;
      case 8:
        wtf_push_unknown(os, p, 1u);
        break;
      case 4:
LABEL_40:
        if ( os->length + 1 >= os->area_size )
          Strgrow(os);
        v5 = os->length;
        os->ptr[v5] = *p;
        os->length = v5 + 1;
        os->ptr[os->length] = 0;
        break;
      default:
        wtf_push_ucs(os, *p, &st);
        break;
    }
LABEL_45:
    ++p;
  }
  return os;
}

//----- (080C04AB) --------------------------------------------------------
void __cdecl wc_push_ucs_to_utf7(Str os, wc_uint32 ucs, wc_status *st)
{
  wc_uint32 v3; // eax
  wc_uint32 v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  int v15; // eax
  int v16; // eax
  unsigned __int16 ucsa; // [esp+34h] [ebp+Ch]

  if ( ucs > 0x10FFFF )
    return;
  if ( ucs > 0xFFFF )
  {
    v3 = (ucs - 0x10000) >> 10;
    BYTE1(v3) |= 0xD8u;
    v4 = (v3 << 16) | ucs & 0x3FF;
    BYTE1(v4) |= 0xDCu;
    ucsa = v4;
    wc_push_ucs_to_utf7(os, HIWORD(v4), st);
    wc_push_ucs_to_utf7(os, ucsa, st);
    return;
  }
  if ( ucs > 0x7F )
    goto LABEL_32;
  v5 = WC_UTF7_MAP[ucs];
  if ( v5 == 16 )
  {
LABEL_12:
    if ( st->state == 2 )
    {
      if ( os->length + 1 >= os->area_size )
        Strgrow(os);
      v6 = os->length;
      os->ptr[v6] = base64_c_map[st->base];
      os->length = v6 + 1;
      os->ptr[os->length] = 0;
      if ( os->length + 1 >= os->area_size )
        Strgrow(os);
      v7 = os->length;
      os->ptr[v7] = 45;
      os->length = v7 + 1;
      os->ptr[os->length] = 0;
      st->state = 0;
    }
    if ( os->length + 1 >= os->area_size )
      Strgrow(os);
    v8 = os->length;
    os->ptr[v8] = ucs;
    os->length = v8 + 1;
    os->ptr[os->length] = 0;
    return;
  }
  if ( WC_UTF7_MAP[ucs] <= 0x10u )
  {
    if ( WC_UTF7_MAP[ucs] && v5 != 4 )
      goto LABEL_32;
    goto LABEL_12;
  }
  if ( v5 != 32 )
  {
    if ( v5 != 64 )
    {
LABEL_32:
      if ( st->state == 2 && st->shift )
      {
        st->shift += 16;
        st->base |= ucs >> st->shift;
        if ( os->length + 1 >= os->area_size )
          Strgrow(os);
        v13 = os->length;
        os->ptr[v13] = base64_c_map[st->base];
        os->length = v13 + 1;
        os->ptr[os->length] = 0;
      }
      else
      {
        if ( st->state != 2 )
        {
          if ( os->length + 1 >= os->area_size )
            Strgrow(os);
          v14 = os->length;
          os->ptr[v14] = 43;
          os->length = v14 + 1;
          os->ptr[os->length] = 0;
          st->state = 2;
        }
        st->shift = 16;
        st->base = 0;
      }
      st->shift -= 6;
      if ( os->length + 1 >= os->area_size )
        Strgrow(os);
      v15 = os->length;
      os->ptr[v15] = base64_c_map[(ucs >> st->shift) & 0x3F];
      os->length = v15 + 1;
      os->ptr[os->length] = 0;
      st->shift -= 6;
      if ( os->length + 1 >= os->area_size )
        Strgrow(os);
      v16 = os->length;
      os->ptr[v16] = base64_c_map[(ucs >> st->shift) & 0x3F];
      os->length = v16 + 1;
      os->ptr[os->length] = 0;
      if ( st->shift )
      {
        st->shift -= 6;
        st->base = (ucs << -LOBYTE(st->shift)) & 0x3F;
      }
      return;
    }
    goto LABEL_12;
  }
  if ( st->state == 2 )
  {
    if ( os->length + 1 >= os->area_size )
      Strgrow(os);
    v9 = os->length;
    os->ptr[v9] = base64_c_map[st->base];
    os->length = v9 + 1;
    os->ptr[os->length] = 0;
    if ( os->length + 1 >= os->area_size )
      Strgrow(os);
    v10 = os->length;
    os->ptr[v10] = 45;
    os->length = v10 + 1;
    os->ptr[os->length] = 0;
    st->state = 0;
  }
  if ( os->length + 1 >= os->area_size )
    Strgrow(os);
  v11 = os->length;
  os->ptr[v11] = 43;
  os->length = v11 + 1;
  os->ptr[os->length] = 0;
  if ( os->length + 1 >= os->area_size )
    Strgrow(os);
  v12 = os->length;
  os->ptr[v12] = 45;
  os->length = v12 + 1;
  os->ptr[os->length] = 0;
}

//----- (080C0A16) --------------------------------------------------------
int __cdecl wc_push_tag_to_utf7(Str os, int ntag, wc_status *st)
{
  char *p; // [esp+1Ch] [ebp-Ch]

  if ( ntag )
  {
    p = wc_ucs_get_tag(ntag);
    if ( !p )
      ntag = 0;
  }
  if ( ntag )
  {
    wc_push_ucs_to_utf7(os, 0xE0001u, st);
    while ( *p )
      wc_push_ucs_to_utf7(os, *p++ | 0xE0000, st);
  }
  else
  {
    wc_push_ucs_to_utf7(os, 0xE007Fu, st);
  }
  return ntag;
}
// 80C0A62: variable 'p' is possibly undefined

//----- (080C0AB2) --------------------------------------------------------
void __cdecl wc_push_to_utf7(Str os, wc_wchar_t cc, wc_status *st)
{
  wc_ccs v3; // eax
  wc_uint32 v4; // edx
  wc_ccs v5; // eax
  char *p; // [esp+1Ch] [ebp-Ch]
  char *pa; // [esp+1Ch] [ebp-Ch]

  while ( 1 )
  {
    while ( LOWORD(cc.ccs) == 0x2000 )
    {
      if ( cc.code <= 0x10FFFF )
        goto LABEL_16;
      if ( (cc.ccs & 0x18000) != 0 )
        v3 = 49152;
      else
        v3 = 0x4000;
      cc.ccs = v3;
    }
    if ( LOWORD(cc.ccs) <= 0x2000u )
    {
      if ( LOWORD(cc.ccs) == 577 )
      {
        if ( st->ntag )
          st->ntag = wc_push_tag_to_utf7(os, 0, st);
        v4 = cc.code;
        LOBYTE(v4) = LOBYTE(cc.code) | 0x80;
        wc_push_ucs_to_utf7(os, v4, st);
        return;
      }
      if ( LOWORD(cc.ccs) == 4096 || LOWORD(cc.ccs) == 322 )
      {
LABEL_16:
        if ( st->ntag )
          st->ntag = wc_push_tag_to_utf7(os, 0, st);
        wc_push_ucs_to_utf7(os, cc.code, st);
        return;
      }
      goto LABEL_40;
    }
    if ( LOWORD(cc.ccs) == 0x4000 )
      break;
    if ( LOWORD(cc.ccs) == 49152 )
    {
      if ( !WcOption.no_replace )
      {
        if ( st->ntag )
          st->ntag = wc_push_tag_to_utf7(os, 0, st);
        for ( p = WcReplaceW; *p; ++p )
          wc_push_ucs_to_utf7(os, *p, st);
      }
      return;
    }
    if ( LOWORD(cc.ccs) == 8193 )
    {
      if ( WcOption.use_language_tag && HIBYTE(cc.code) != st->ntag )
        st->ntag = wc_push_tag_to_utf7(os, HIBYTE(cc.code), st);
      wc_push_ucs_to_utf7(os, cc.code & 0x1FFFFF, st);
      return;
    }
LABEL_40:
    if ( !WcOption.ucs_conv || (cc.code = wc_any_to_ucs(cc), cc.code == -1) )
    {
      if ( (cc.ccs & 0x18000) != 0 )
        v5 = 49152;
      else
        v5 = 0x4000;
      cc.ccs = v5;
    }
    else
    {
      cc.ccs = 4096;
    }
  }
  if ( !WcOption.no_replace )
  {
    if ( st->ntag )
      st->ntag = wc_push_tag_to_utf7(os, 0, st);
    for ( pa = WcReplace; *pa; ++pa )
      wc_push_ucs_to_utf7(os, *pa, st);
  }
}

//----- (080C0D72) --------------------------------------------------------
void __cdecl wc_push_to_utf7_end(Str os, wc_status *st)
{
  int v2; // eax
  int v3; // eax

  if ( st->ntag )
    st->ntag = wc_push_tag_to_utf7(os, 0, st);
  if ( st->state == 2 )
  {
    if ( st->shift )
    {
      if ( os->length + 1 >= os->area_size )
        Strgrow(os);
      v2 = os->length;
      os->ptr[v2] = base64_c_map[st->base];
      os->length = v2 + 1;
      os->ptr[os->length] = 0;
    }
    if ( os->length + 1 >= os->area_size )
      Strgrow(os);
    v3 = os->length;
    os->ptr[v3] = 45;
    os->length = v3 + 1;
    os->ptr[os->length] = 0;
  }
}

//----- (080C0E5E) --------------------------------------------------------
Str __cdecl wc_char_conv_from_utf7(wc_uchar c, wc_status *st)
{
  int v2; // eax
  int v4; // eax
  int v5; // eax
  Str v6; // eax
  int v7; // edx
  wc_uint32 b; // [esp+2Ch] [ebp-Ch]

  if ( st->state == -1 )
  {
    st->state = 0;
    os_2932 = Strnew_size(8);
  }
  v2 = st->state;
  if ( v2 == 1 )
  {
    if ( c == 45 )
    {
      wtf_push_ucs(os_2932, 0x2Bu, st);
      st->state = -1;
      return os_2932;
    }
  }
  else if ( v2 != 2 )
  {
    if ( !v2 && c == 43 )
    {
      st->state = 1;
      st->shift = 16;
      st->base = 0;
      high_2933 = 0;
      return 0;
    }
    goto LABEL_29;
  }
  v4 = WC_UTF7_MAP[c];
  if ( v4 != 32 )
  {
    if ( v4 == 64 )
    {
      st->state = -1;
      return 0;
    }
    if ( v4 != 16 )
    {
LABEL_29:
      v5 = WC_UTF7_MAP[c];
      if ( v5 != 6 )
      {
        if ( v5 != 8 )
        {
          if ( v5 == 4 )
            goto LABEL_32;
          wtf_push_ucs(os_2932, c, st);
        }
LABEL_36:
        st->state = -1;
        return os_2932;
      }
LABEL_32:
      if ( os_2932->length + 1 >= os_2932->area_size )
        Strgrow(os_2932);
      v6 = os_2932;
      v7 = os_2932->length;
      os_2932->ptr[v7] = c;
      v6->length = v7 + 1;
      os_2932->ptr[os_2932->length] = 0;
      goto LABEL_36;
    }
  }
  b = c_base64_map[c - 32];
  st->shift -= 6;
  if ( st->shift <= 0 )
  {
    st->base |= b >> -LOBYTE(st->shift);
    if ( st->base <= 0xD7FF || st->base > 0xDBFF )
    {
      if ( st->base <= 0xDBFF || st->base > 0xDFFF )
      {
        if ( st->base != 65279 )
          wtf_push_ucs(os_2932, st->base, st);
      }
      else
      {
        if ( high_2933 )
          wtf_push_ucs(os_2932, (((high_2933 & 0x3FF) << 10) | st->base & 0x3FF) + 0x10000, st);
        high_2933 = 0;
      }
    }
    else if ( high_2933 )
    {
      high_2933 = 0;
    }
    else
    {
      high_2933 = st->base;
    }
    st->shift += 16;
    st->base = 0;
  }
  st->base |= (unsigned __int16)(b << st->shift);
  st->state = 2;
  return os_2932;
}

//----- (080C117C) --------------------------------------------------------
size_t __cdecl wc_ucs_to_utf8(wc_uint32 ucs, wc_uchar *utf8)
{
  size_t result; // eax

  if ( ucs > 0x7F )
  {
    if ( ucs > 0x7FF )
    {
      if ( ucs > 0xFFFF )
      {
        if ( ucs > 0x1FFFFF )
        {
          if ( ucs > 0x3FFFFFF )
          {
            if ( (ucs & 0x80000000) != 0 )
            {
              *utf8 = 0;
              result = 0;
            }
            else
            {
              *utf8 = (ucs >> 30) | 0xFC;
              utf8[1] = HIBYTE(ucs) & 0x3F | 0x80;
              utf8[2] = (ucs >> 18) & 0x3F | 0x80;
              utf8[3] = (ucs >> 12) & 0x3F | 0x80;
              utf8[4] = (ucs >> 6) & 0x3F | 0x80;
              utf8[5] = ucs & 0x3F | 0x80;
              utf8[6] = 0;
              result = 6;
            }
          }
          else
          {
            *utf8 = HIBYTE(ucs) | 0xF8;
            utf8[1] = (ucs >> 18) & 0x3F | 0x80;
            utf8[2] = (ucs >> 12) & 0x3F | 0x80;
            utf8[3] = (ucs >> 6) & 0x3F | 0x80;
            utf8[4] = ucs & 0x3F | 0x80;
            utf8[5] = 0;
            result = 5;
          }
        }
        else
        {
          *utf8 = (ucs >> 18) | 0xF0;
          utf8[1] = (ucs >> 12) & 0x3F | 0x80;
          utf8[2] = (ucs >> 6) & 0x3F | 0x80;
          utf8[3] = ucs & 0x3F | 0x80;
          utf8[4] = 0;
          result = 4;
        }
      }
      else
      {
        *utf8 = (ucs >> 12) | 0xE0;
        utf8[1] = (ucs >> 6) & 0x3F | 0x80;
        utf8[2] = ucs & 0x3F | 0x80;
        utf8[3] = 0;
        result = 3;
      }
    }
    else
    {
      *utf8 = (ucs >> 6) | 0xC0;
      utf8[1] = ucs & 0x3F | 0x80;
      utf8[2] = 0;
      result = 2;
    }
  }
  else
  {
    *utf8 = ucs;
    utf8[1] = 0;
    result = 1;
  }
  return result;
}

//----- (080C13A7) --------------------------------------------------------
wc_uint32 __cdecl wc_utf8_to_ucs(wc_uchar *utf8)
{
  wc_uint32 result; // eax

  switch ( WC_UTF8_MAP[*utf8] )
  {
    case 1u:
      if ( *utf8 > 0x7Fu )
        goto LABEL_14;
      result = *utf8;
      break;
    case 2u:
      if ( (((*utf8 & 0x1F) << 6) | utf8[1] & 0x3Fu) <= 0x7F )
        goto LABEL_14;
      result = ((*utf8 & 0x1F) << 6) | utf8[1] & 0x3F;
      break;
    case 3u:
      if ( (((utf8[1] & 0x3F) << 6) | (unsigned __int16)(*utf8 << 12) | utf8[2] & 0x3Fu) <= 0x7FF )
        goto LABEL_14;
      result = ((utf8[1] & 0x3F) << 6) | (unsigned __int16)(*utf8 << 12) | utf8[2] & 0x3F;
      break;
    case 4u:
      if ( (((utf8[2] & 0x3F) << 6) | ((utf8[1] & 0x3F) << 12) | ((*utf8 & 7) << 18) | utf8[3] & 0x3Fu) <= 0xFFFF )
        goto LABEL_14;
      result = ((utf8[2] & 0x3F) << 6) | ((utf8[1] & 0x3F) << 12) | ((*utf8 & 7) << 18) | utf8[3] & 0x3F;
      break;
    case 5u:
      if ( (((utf8[3] & 0x3F) << 6) | ((utf8[2] & 0x3F) << 12) | ((utf8[1] & 0x3F) << 18) | ((*utf8 & 3) << 24) | utf8[4] & 0x3Fu) <= 0x1FFFFF )
        goto LABEL_14;
      result = ((utf8[3] & 0x3F) << 6) | ((utf8[2] & 0x3F) << 12) | ((utf8[1] & 0x3F) << 18) | ((*utf8 & 3) << 24) | utf8[4] & 0x3F;
      break;
    case 6u:
      if ( (((utf8[4] & 0x3F) << 6) | ((utf8[3] & 0x3F) << 12) | ((utf8[2] & 0x3F) << 18) | ((utf8[1] & 0x3F) << 24) | ((*utf8 & 1) << 30) | utf8[5] & 0x3Fu) <= 0x3FFFFFF )
        goto LABEL_14;
      result = ((utf8[4] & 0x3F) << 6) | ((utf8[3] & 0x3F) << 12) | ((utf8[2] & 0x3F) << 18) | ((utf8[1] & 0x3F) << 24) | ((*utf8 & 1) << 30) | utf8[5] & 0x3F;
      break;
    default:
LABEL_14:
      result = -1;
      break;
  }
  return result;
}

//----- (080C15E5) --------------------------------------------------------
Str __cdecl wc_conv_from_utf8(Str is, wc_ces ces)
{
  int v3; // eax
  wc_status st; // [esp+14h] [ebp-64h] BYREF
  wc_uint32 ucs; // [esp+50h] [ebp-28h]
  size_t next; // [esp+54h] [ebp-24h]
  int state; // [esp+58h] [ebp-20h]
  wc_uchar *q; // [esp+5Ch] [ebp-1Ch]
  wc_uchar *p; // [esp+60h] [ebp-18h]
  wc_uchar *ep; // [esp+64h] [ebp-14h]
  wc_uchar *sp_0; // [esp+68h] [ebp-10h]
  Str os; // [esp+6Ch] [ebp-Ch]

  sp_0 = (wc_uchar *)is->ptr;
  ep = &sp_0[is->length];
  q = 0;
  state = 0;
  next = 0;
  for ( p = sp_0; p < ep && (*p & 0x80u) == 0; ++p )
    ;
  if ( p == ep )
    return is;
  os = Strnew_size(4 * is->length / 3);
  if ( p > sp_0 )
    Strcat_charp_n(os, is->ptr, p - sp_0);
  st.tag = 0;
  st.ntag = 0;
  while ( p < ep )
  {
    if ( state )
    {
      if ( state == 1 )
      {
        if ( WC_UTF8_MAP[*p] )
        {
          wtf_push_unknown(os, q, p - q + 1);
          state = 0;
        }
        else if ( !--next )
        {
          state = 0;
          ucs = wc_utf8_to_ucs(q);
          if ( ucs == -1 || ucs > 0xD7FF && ucs <= 0xDFFF )
          {
            wtf_push_unknown(os, q, p - q + 1);
          }
          else if ( ucs != 65279 )
          {
            wtf_push_ucs(os, ucs, &st);
          }
        }
      }
    }
    else
    {
      next = WC_UTF8_MAP[*p];
      switch ( next )
      {
        case 1u:
          wtf_push_ucs(os, *p, &st);
          break;
        case 0u:
        case 7u:
          wtf_push_unknown(os, p, 1u);
          break;
        case 8u:
          if ( os->length + 1 >= os->area_size )
            Strgrow(os);
          v3 = os->length;
          os->ptr[v3] = *p;
          os->length = v3 + 1;
          os->ptr[os->length] = 0;
          break;
        default:
          q = p;
          --next;
          state = 1;
          break;
      }
    }
    ++p;
  }
  if ( state == 1 )
    wtf_push_unknown(os, q, p - q);
  return os;
}

//----- (080C18A7) --------------------------------------------------------
int __cdecl wc_push_tag_to_utf8(Str os, int ntag)
{
  char *p; // [esp+1Ch] [ebp-Ch]

  if ( ntag )
  {
    p = wc_ucs_get_tag(ntag);
    if ( !p )
      ntag = 0;
  }
  if ( ntag )
  {
    wc_ucs_to_utf8(0xE0001u, utf8_buf);
    Strcat_charp(os, (char *)utf8_buf);
    while ( *p )
    {
      wc_ucs_to_utf8(*p | 0xE0000, utf8_buf);
      Strcat_charp(os, (char *)utf8_buf);
      ++p;
    }
  }
  else
  {
    wc_ucs_to_utf8(0xE007Fu, utf8_buf);
    Strcat_charp(os, (char *)utf8_buf);
  }
  return ntag;
}
// 80C1901: variable 'p' is possibly undefined

//----- (080C196D) --------------------------------------------------------
void __cdecl wc_push_to_utf8(Str os, wc_wchar_t cc, wc_status *st)
{
  int v3; // eax
  wc_uint32 v4; // eax
  wc_ccs v5; // eax

  while ( 1 )
  {
    if ( LOWORD(cc.ccs) == 0x2000 )
    {
LABEL_16:
      if ( st->ntag )
        st->ntag = wc_push_tag_to_utf8(os, 0);
      wc_ucs_to_utf8(cc.code, utf8_buf);
      Strcat_charp(os, (char *)utf8_buf);
      return;
    }
    if ( LOWORD(cc.ccs) <= 0x2000u )
    {
      switch ( LOWORD(cc.ccs) )
      {
        case 0x241u:
          if ( st->ntag )
            st->ntag = wc_push_tag_to_utf8(os, 0);
          v4 = cc.code;
          LOBYTE(v4) = LOBYTE(cc.code) | 0x80;
          wc_ucs_to_utf8(v4, utf8_buf);
          Strcat_charp(os, (char *)utf8_buf);
          return;
        case 0x1000u:
          goto LABEL_16;
        case 0x142u:
          if ( st->ntag )
            st->ntag = wc_push_tag_to_utf8(os, 0);
          if ( os->length + 1 >= os->area_size )
            Strgrow(os);
          v3 = os->length;
          os->ptr[v3] = cc.code & 0x7F;
          os->length = v3 + 1;
          os->ptr[os->length] = 0;
          return;
      }
      goto LABEL_34;
    }
    if ( LOWORD(cc.ccs) == 0x4000 )
      break;
    if ( LOWORD(cc.ccs) == 49152 )
    {
      if ( !WcOption.no_replace )
      {
        if ( st->ntag )
          st->ntag = wc_push_tag_to_utf8(os, 0);
        Strcat_charp(os, WcReplaceW);
      }
      return;
    }
    if ( LOWORD(cc.ccs) == 8193 )
    {
      if ( WcOption.use_language_tag && HIBYTE(cc.code) != st->ntag )
        st->ntag = wc_push_tag_to_utf8(os, HIBYTE(cc.code));
      wc_ucs_to_utf8(cc.code & 0x1FFFFF, utf8_buf);
      Strcat_charp(os, (char *)utf8_buf);
      return;
    }
LABEL_34:
    if ( !WcOption.ucs_conv || (cc.code = wc_any_to_ucs(cc), cc.code == -1) )
    {
      if ( (cc.ccs & 0x18000) != 0 )
        v5 = 49152;
      else
        v5 = 0x4000;
      cc.ccs = v5;
    }
    else
    {
      cc.ccs = 4096;
    }
  }
  if ( !WcOption.no_replace )
  {
    if ( st->ntag )
      st->ntag = wc_push_tag_to_utf8(os, 0);
    Strcat_charp(os, WcReplace);
  }
}

//----- (080C1C44) --------------------------------------------------------
void __cdecl wc_push_to_utf8_end(Str os, wc_status *st)
{
  if ( st->ntag )
    st->ntag = wc_push_tag_to_utf8(os, 0);
}

//----- (080C1C6F) --------------------------------------------------------
Str __cdecl wc_char_conv_from_utf8(wc_uchar c, wc_status *st)
{
  int v2; // eax
  Str v3; // eax
  int v4; // edx
  size_t v5; // eax
  size_t v7; // eax
  wc_uint32 ucs; // [esp+2Ch] [ebp-Ch]

  if ( st->state == -1 )
  {
    st->state = 0;
    os_2857 = Strnew_size(8);
    st->tag = 0;
    st->ntag = 0;
    nbuf_2859 = 0;
  }
  v2 = st->state;
  if ( v2 )
  {
    if ( v2 == 1 && !WC_UTF8_MAP[c] )
    {
      v7 = nbuf_2859;
      buf_2858[nbuf_2859] = c;
      nbuf_2859 = v7 + 1;
      if ( --next_2860 )
        return 0;
      ucs = wc_utf8_to_ucs(buf_2858);
      if ( ucs != -1 && (ucs <= 0xD7FF || ucs > 0xDFFF) && ucs != 65279 )
        wtf_push_ucs(os_2857, ucs, st);
    }
  }
  else
  {
    next_2860 = WC_UTF8_MAP[c];
    if ( next_2860 == 1 )
    {
      wtf_push_ucs(os_2857, c, st);
    }
    else if ( next_2860 && next_2860 != 7 )
    {
      if ( next_2860 != 8 )
      {
        v5 = nbuf_2859;
        buf_2858[nbuf_2859] = c;
        nbuf_2859 = v5 + 1;
        --next_2860;
        st->state = 1;
        return 0;
      }
      if ( os_2857->length + 1 >= os_2857->area_size )
        Strgrow(os_2857);
      v3 = os_2857;
      v4 = os_2857->length;
      os_2857->ptr[v4] = c;
      v3->length = v4 + 1;
      os_2857->ptr[os_2857->length] = 0;
    }
  }
  st->state = -1;
  return os_2857;
}

//----- (080C1E74) --------------------------------------------------------
wc_uint32 __cdecl wc_tcvn5712_precompose(wc_uchar c1, wc_uchar c2)
{
  wc_uint32 result; // eax

  if ( tcvn5712_precompose_map[c1] == 1 && tcvn5712_precompose_map[c2] == 2 )
    result = (c1 << 8) | c2;
  else
    result = 0;
  return result;
}

//----- (080C1EBC) --------------------------------------------------------
wc_wchar_t *__userpurge wc_tcvn57123_to_tcvn5712@<eax>(wc_wchar_t *retstr, wc_wchar_t cc)
{
  wc_ccs v2; // eax
  wc_uint16 v3; // ax
  wc_map *map; // [esp+1Ch] [ebp-Ch]

  map = wc_map_search(cc.code & 0x7F7F, tcvn57123_tcvn5712_map, 0x78u);
  if ( map )
  {
    if ( map->code2 > 0x1Fu )
      v2 = 2077;
    else
      v2 = 2078;
    cc.ccs = v2;
    v3 = map->code2;
    LOBYTE(v3) = v3 | 0x80;
    cc.code = v3;
  }
  else
  {
    cc.ccs = 0x4000;
  }
  *retstr = cc;
  return retstr;
}

//----- (080C1F3B) --------------------------------------------------------
wc_uint32 __cdecl wc_cp1258_precompose(wc_uchar c1, wc_uchar c2)
{
  wc_uint32 result; // eax

  if ( cp1258_precompose_map[c1] == 1 && cp1258_precompose_map[c2] == 2 )
    result = (c1 << 8) | c2;
  else
    result = 0;
  return result;
}

//----- (080C1F83) --------------------------------------------------------
Str __cdecl wc_conv_from_viet(Str is, wc_ces ces)
{
  int v3; // eax
  wc_uint8 *map; // [esp+14h] [ebp-24h]
  wc_ccs ccs2; // [esp+18h] [ebp-20h]
  wc_ccs ccs1; // [esp+1Ch] [ebp-1Ch]
  wc_uchar *p; // [esp+20h] [ebp-18h]
  wc_uchar *ep; // [esp+24h] [ebp-14h]
  char *sp_0; // [esp+28h] [ebp-10h]
  Str os; // [esp+2Ch] [ebp-Ch]

  sp_0 = is->ptr;
  ep = (wc_uchar *)&is->ptr[is->length];
  ccs1 = WcCesInfo[(unsigned __int8)ces].gset[1].ccs;
  ccs2 = WcCesInfo[(unsigned __int8)ces].gset[2].ccs;
  map = 0;
  switch ( ces )
  {
    case 0x104443u:
      map = wc_c0_viscii112_map;
      break;
    case 0x104444u:
      map = wc_c0_vps2_map;
      break;
    case 0x104442u:
      map = wc_c0_tcvn57122_map;
      break;
  }
  wc_create_detect_map(ces, 0);
  for ( p = (wc_uchar *)sp_0; p < ep && !WC_DETECT_MAP[*p]; ++p )
    ;
  if ( p == ep )
    return is;
  os = Strnew_size(is->length);
  if ( p > (wc_uchar *)sp_0 )
    Strcat_charp_n(os, is->ptr, p - (wc_uchar *)sp_0);
  while ( p < ep )
  {
    if ( (*p & 0x80u) == 0 )
    {
      if ( *p <= 0x1Fu && map[*p] )
      {
        wtf_push(os, ccs2, *p);
      }
      else
      {
        if ( os->length + 1 >= os->area_size )
          Strgrow(os);
        v3 = os->length;
        os->ptr[v3] = *p;
        os->length = v3 + 1;
        os->ptr[os->length] = 0;
      }
    }
    else
    {
      wtf_push(os, ccs1, *p);
    }
    ++p;
  }
  return os;
}

//----- (080C2164) --------------------------------------------------------
void __cdecl wc_push_to_viet(Str os, wc_wchar_t cc, wc_status *st)
{
  wc_ces v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  wc_ccs v10; // eax
  wc_uint8 *map; // [esp+10h] [ebp-18h]
  wc_ccs ccs3; // [esp+14h] [ebp-14h]
  wc_ccs ccs2; // [esp+18h] [ebp-10h]
  wc_ccs ccs1; // [esp+1Ch] [ebp-Ch]

  ccs1 = st->ces_info->gset[1].ccs;
  ccs2 = 0;
  ccs3 = 0;
  map = 0;
  v3 = st->ces_info->id;
  if ( v3 == 1066050 )
  {
    map = wc_c0_tcvn57122_map;
    ccs2 = st->ces_info->gset[2].ccs;
    ccs3 = st->ces_info->gset[3].ccs;
  }
  else if ( v3 > 0x104442 )
  {
    if ( v3 == 1066051 )
    {
      map = wc_c0_viscii112_map;
      ccs2 = st->ces_info->gset[2].ccs;
    }
    else if ( v3 == 1066052 )
    {
      map = wc_c0_vps2_map;
      ccs2 = st->ces_info->gset[2].ccs;
    }
  }
  else if ( v3 == 1049665 )
  {
    ccs3 = st->ces_info->gset[2].ccs;
  }
  while ( 1 )
  {
    if ( cc.ccs == ccs1 )
    {
      if ( os->length + 1 >= os->area_size )
        Strgrow(os);
      v4 = os->length;
      os->ptr[v4] = LOBYTE(cc.code) | 0x80;
      os->length = v4 + 1;
      os->ptr[os->length] = 0;
      return;
    }
    if ( cc.ccs == ccs2 )
    {
      if ( os->length + 1 >= os->area_size )
        Strgrow(os);
      v5 = os->length;
      os->ptr[v5] = cc.code & 0x7F;
      os->length = v5 + 1;
      os->ptr[os->length] = 0;
      return;
    }
    if ( cc.ccs == ccs3 )
    {
      if ( os->length + 1 >= os->area_size )
        Strgrow(os);
      v6 = os->length;
      os->ptr[v6] = BYTE1(cc.code);
      os->length = v6 + 1;
      os->ptr[os->length] = 0;
      if ( os->length + 1 >= os->area_size )
        Strgrow(os);
      v7 = os->length;
      os->ptr[v7] = cc.code;
      os->length = v7 + 1;
      os->ptr[os->length] = 0;
      return;
    }
    if ( cc.ccs == 0x4000 )
      break;
    if ( cc.ccs == 49152 )
    {
      if ( !WcOption.no_replace )
        Strcat_charp(os, WcReplaceW);
      return;
    }
    if ( cc.ccs == 322 )
    {
      if ( cc.code <= 0x1F && map && map[cc.code] )
      {
        if ( os->length + 1 >= os->area_size )
          Strgrow(os);
        v8 = os->length;
        os->ptr[v8] = 32;
        os->length = v8 + 1;
        os->ptr[os->length] = 0;
      }
      else
      {
        if ( os->length + 1 >= os->area_size )
          Strgrow(os);
        v9 = os->length;
        os->ptr[v9] = cc.code;
        os->length = v9 + 1;
        os->ptr[os->length] = 0;
      }
      return;
    }
    if ( WcOption.ucs_conv )
    {
      wc_any_to_any_ces(&cc, cc, st);
    }
    else
    {
      if ( (cc.ccs & 0x18000) != 0 )
        v10 = 49152;
      else
        v10 = 0x4000;
      cc.ccs = v10;
    }
  }
  if ( !WcOption.no_replace )
    Strcat_charp(os, WcReplace);
}

//----- (080C250D) --------------------------------------------------------
Str __cdecl wc_char_conv_from_viet(wc_uchar c, wc_status *st)
{
  wc_ces v2; // eax
  int v3; // eax
  wc_uint8 *map; // [esp+28h] [ebp-10h]
  Str os; // [esp+2Ch] [ebp-Ch]

  os = Strnew_size(1);
  map = 0;
  v2 = st->ces_info->id;
  switch ( v2 )
  {
    case 0x104443u:
      map = wc_c0_viscii112_map;
      break;
    case 0x104444u:
      map = wc_c0_vps2_map;
      break;
    case 0x104442u:
      map = wc_c0_tcvn57122_map;
      break;
  }
  if ( (c & 0x80u) == 0 )
  {
    if ( c <= 0x1Fu && map[c] )
    {
      wtf_push(os, st->ces_info->gset[2].ccs, c);
    }
    else
    {
      if ( os->length + 1 >= os->area_size )
        Strgrow(os);
      v3 = os->length;
      os->ptr[v3] = c;
      os->length = v3 + 1;
      os->ptr[os->length] = 0;
    }
  }
  else
  {
    wtf_push(os, st->ces_info->gset[1].ccs, c);
  }
  return os;
}

//----- (080C2624) --------------------------------------------------------
void __cdecl wtf_init(wc_ces ces1, wc_ces ces2)
{
  wc_gset *gset; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]
  int ia; // [esp+1Ch] [ebp-Ch]

  if ( wc_check_ces(ces2) )
    wtf_major_ces = ces2;
  if ( wc_check_ces(ces1) )
  {
    gset = WcCesInfo[(unsigned __int8)ces1].gset;
    if ( gset )
    {
      if ( gset[1].ccs && (gset[1].ccs & 0x3000) == 0 )
      {
        wtf_gr_ccs = gset[1].ccs;
        if ( (wtf_gr_ccs & 0x18000) != 0 )
        {
          for ( i = 161; i <= 255; ++i )
          {
            WTF_WIDTH_MAP[i] = 2;
            WTF_LEN_MAP[i] = 2;
            WTF_TYPE_MAP[i] = 10;
          }
        }
        else
        {
          for ( ia = 161; ia <= 255; ++ia )
          {
            WTF_WIDTH_MAP[ia] = 1;
            WTF_LEN_MAP[ia] = 1;
            WTF_TYPE_MAP[ia] = 2;
          }
        }
      }
    }
  }
}

//----- (080C272A) --------------------------------------------------------
int __cdecl wtf_strwidth(wc_uchar *p)
{
  int v1; // eax
  int w; // [esp+Ch] [ebp-4h]

  w = 0;
  while ( *p )
  {
    if ( WcOption.use_wide )
      v1 = WTF_WIDTH_MAP[*p];
    else
      v1 = WTF_WIDTH_MAP[*p] != 0;
    w += v1;
    p += WTF_LEN_MAP[*p];
  }
  return w;
}

//----- (080C2799) --------------------------------------------------------
size_t __cdecl wtf_len(wc_uchar *p)
{
  wc_uchar *q; // [esp+Ch] [ebp-4h]

  for ( q = &p[WTF_LEN_MAP[*p]]; *q && !WTF_WIDTH_MAP[*q]; q += WTF_LEN_MAP[*q] )
    ;
  return q - p;
}

//----- (080C27FF) --------------------------------------------------------
void __cdecl wtf_push(Str os, wc_ccs ccs, wc_uint32 code)
{
  int v3; // eax
  int v4; // eax
  unsigned int v5; // eax
  char v6; // dl
  char v7; // al
  char v8; // dl
  char v9; // al
  wc_wchar_t v10; // [esp+10h] [ebp-48h] BYREF
  Str osa; // [esp+1Ch] [ebp-3Ch]
  wc_wchar_t cc2; // [esp+2Ch] [ebp-2Ch] BYREF
  wc_wchar_t cc; // [esp+34h] [ebp-24h] BYREF
  size_t n; // [esp+3Ch] [ebp-1Ch]
  wc_bool fix_width_conv; // [esp+43h] [ebp-15h]
  wc_uchar s[8]; // [esp+44h] [ebp-14h] BYREF
  unsigned int v17; // [esp+4Ch] [ebp-Ch]

  osa = os;
  v17 = __readgsdword(0x14u);
  if ( ccs == 322 )
  {
    if ( osa->length + 1 >= osa->area_size )
      Strgrow(osa);
    v3 = osa->length;
    osa->ptr[v3] = code & 0x7F;
    osa->length = v3 + 1;
    osa->ptr[osa->length] = 0;
    return;
  }
  cc.ccs = ccs;
  cc.code = code;
  if ( !WcOption.pre_conv || (cc.ccs & 0x4000) != 0 )
  {
LABEL_30:
    v5 = cc.ccs & 0xFF00;
    if ( v5 == 4096 )
    {
      if ( (cc.ccs & 0x18000) != 0 )
        v6 = -119;
      else
        v6 = -120;
      if ( (cc.ccs & 0x20000) != 0 )
        v7 = 16;
      else
        v7 = 0;
      s[0] = v6 | v7;
      s[1] = (cc.code >> 14) & 3 | 0x80;
      s[2] = (cc.code >> 7) | 0x80;
      s[3] = LOBYTE(cc.code) | 0x80;
      s[1] |= 4 * LOBYTE(cc.ccs);
      n = 4;
      goto LABEL_106;
    }
    if ( v5 > 0x1000 )
    {
      if ( v5 == 33024 )
      {
        if ( cc.ccs == wtf_gr_ccs )
        {
          s[0] = BYTE1(cc.code) | 0x80;
          s[1] = LOBYTE(cc.code) | 0x80;
          n = 2;
        }
        else
        {
          s[0] = -127;
          s[1] = LOBYTE(cc.ccs) | 0x80;
          s[2] = BYTE1(cc.code) | 0x80;
          s[3] = LOBYTE(cc.code) | 0x80;
          n = 4;
        }
        goto LABEL_106;
      }
      if ( v5 > 0x8100 )
      {
        if ( v5 == 33280 )
        {
          if ( cc.ccs == wtf_gr_ccs && ((cc.code >> 8) & 0x7F) > 0x20 )
          {
            s[0] = BYTE1(cc.code) | 0x80;
            s[1] = LOBYTE(cc.code) | 0x80;
            n = 2;
          }
          else
          {
            s[0] = -125;
            s[1] = LOBYTE(cc.ccs) | 0x80;
            s[2] = BYTE1(cc.code) | 0x80;
            s[3] = LOBYTE(cc.code) | 0x80;
            n = 4;
          }
          goto LABEL_106;
        }
        if ( v5 == 34816 )
        {
          switch ( cc.ccs )
          {
            case 0x8801u:
              wc_big5_to_cs94w(&v10, cc);
              cc = v10;
              break;
            case 0x880Fu:
              wc_johab_to_cs128w(&v10, cc);
              cc = v10;
              break;
            case 0x8813u:
              wc_sjis_ext_to_cs94w(&cc, cc);
              break;
            case 0x8816u:
              wc_gbk_to_cs128w(&v10, cc);
              cc = v10;
              break;
            case 0x8819u:
              wc_gbk_ext_to_cs128w(&v10, cc);
              cc = v10;
              break;
            case 0x881Cu:
              wc_uhc_to_cs128w(&v10, cc);
              cc = v10;
              break;
            case 0x881Fu:
              wc_hkscs_to_cs128w(&v10, cc);
              cc = v10;
              break;
            default:
              break;
          }
          if ( cc.ccs == wtf_gr_ccs && ((cc.code >> 8) & 0x7F) > 0x20 )
          {
            s[0] = BYTE1(cc.code) | 0x80;
            s[1] = LOBYTE(cc.code) | 0x80;
            n = 2;
          }
          else
          {
            s[0] = -121;
            s[1] = LOBYTE(cc.ccs) | 0x80;
            s[2] = BYTE1(cc.code) | 0x80;
            s[3] = LOBYTE(cc.code) | 0x80;
            n = 4;
          }
          goto LABEL_106;
        }
      }
      else if ( v5 == 0x2000 )
      {
        if ( (cc.ccs & 0x18000) != 0 )
          v8 = -117;
        else
          v8 = -118;
        if ( (cc.ccs & 0x20000) != 0 )
          v9 = 16;
        else
          v9 = 0;
        s[0] = v8 | v9;
        s[1] = (cc.code >> 28) | 0x80;
        s[2] = (cc.code >> 21) | 0x80;
        s[3] = (cc.code >> 14) | 0x80;
        s[4] = (cc.code >> 7) | 0x80;
        s[5] = LOBYTE(cc.code) | 0x80;
        s[1] |= 16 * LOBYTE(cc.ccs);
        n = 6;
        goto LABEL_106;
      }
      goto LABEL_105;
    }
    if ( v5 != 512 )
    {
      if ( v5 <= 0x200 )
      {
        if ( v5 == 256 )
        {
          if ( cc.ccs == wtf_gr_ccs )
          {
            s[0] = LOBYTE(cc.code) | 0x80;
            n = 1;
          }
          else
          {
            if ( cc.ccs == 329 && !WcOption.use_jisx0201k )
            {
              wc_jisx0201k_to_jisx0208(&v10, cc);
              cc2 = v10;
              if ( (v10.ccs & 0x4000) == 0 )
              {
                wtf_push(osa, cc2.ccs, cc2.code);
                return;
              }
            }
            s[0] = 0x80;
            s[1] = LOBYTE(cc.ccs) | 0x80;
            s[2] = LOBYTE(cc.code) | 0x80;
            n = 3;
          }
          goto LABEL_106;
        }
LABEL_105:
        s[0] = -123;
        s[1] = LOBYTE(cc.ccs) | 0x80;
        s[2] = LOBYTE(cc.code) | 0x80;
        n = 3;
        goto LABEL_106;
      }
      if ( v5 == 1024 )
      {
        if ( cc.ccs == wtf_gr_ccs )
        {
          s[0] = LOBYTE(cc.code) | 0x80;
          n = 1;
        }
        else
        {
          s[0] = -124;
          s[1] = LOBYTE(cc.ccs) | 0x80;
          s[2] = LOBYTE(cc.code) | 0x80;
          n = 3;
        }
        goto LABEL_106;
      }
      if ( v5 != 2048 )
        goto LABEL_105;
      if ( WcOption.use_combining && wc_is_combining(cc) )
      {
        s[0] = -106;
LABEL_78:
        s[1] = LOBYTE(cc.ccs) | 0x80;
        s[2] = LOBYTE(cc.code) | 0x80;
        n = 3;
        goto LABEL_106;
      }
      if ( cc.ccs != wtf_gr_ccs || (cc.code & 0x7F) <= 0x20 )
      {
        s[0] = -122;
        goto LABEL_78;
      }
      s[0] = LOBYTE(cc.code) | 0x80;
      n = 1;
LABEL_106:
      Strcat_charp_n(osa, (char *)s, n);
      return;
    }
    if ( WcOption.use_combining && wc_is_combining(cc) )
    {
      s[0] = -110;
    }
    else
    {
      if ( cc.ccs == wtf_gr_ccs && (cc.code & 0x7F) > 0x20 )
      {
        s[0] = LOBYTE(cc.code) | 0x80;
        n = 1;
        goto LABEL_106;
      }
      s[0] = -126;
    }
    s[1] = LOBYTE(cc.ccs) | 0x80;
    s[2] = LOBYTE(cc.code) | 0x80;
    n = 3;
    goto LABEL_106;
  }
  if ( (ccs == 34831 || ccs == 34832 || ccs == 34833 || ccs == 34834)
    && (wtf_major_ces == 3149849 || wtf_major_ces == 2099221) )
  {
    wc_johab_to_ksx1001(&cc2, cc);
    if ( (cc2.ccs & 0x4000) == 0 )
      cc = cc2;
    goto LABEL_30;
  }
  if ( ccs == 33091 && wtf_major_ces == 3153984 )
  {
    wc_ksx1001_to_johab(&v10, cc);
    cc2 = v10;
    if ( (v10.ccs & 0x4000) == 0 )
      cc = cc2;
    goto LABEL_30;
  }
  if ( !WcOption.ucs_conv )
    goto LABEL_30;
  fix_width_conv = WcOption.fix_width_conv;
  WcOption.fix_width_conv = 0;
  wc_output_init(wtf_major_ces, &wtf_major_st);
  if ( wc_ces_has_ccs((unsigned __int16)ccs, &wtf_major_st) )
  {
LABEL_29:
    WcOption.fix_width_conv = fix_width_conv;
    goto LABEL_30;
  }
  wc_any_to_any_ces(&v10, cc, &wtf_major_st);
  cc2 = v10;
  if ( v10.ccs != 322 )
  {
    if ( (cc2.ccs & 0x4000) == 0 && cc2.ccs != 2076 && cc2.ccs != 2079 )
      cc = cc2;
    goto LABEL_29;
  }
  if ( osa->length + 1 >= osa->area_size )
    Strgrow(osa);
  v4 = osa->length;
  osa->ptr[v4] = cc2.code & 0x7F;
  osa->length = v4 + 1;
  osa->ptr[osa->length] = 0;
}

//----- (080C30CF) --------------------------------------------------------
void __cdecl wtf_push_unknown(Str os, wc_uchar *p, size_t len)
{
  int v3; // eax

  while ( len-- != 0 )
  {
    if ( (*p & 0x80u) == 0 )
    {
      if ( os->length + 1 >= os->area_size )
        Strgrow(os);
      v3 = os->length;
      os->ptr[v3] = *p;
      os->length = v3 + 1;
      os->ptr[os->length] = 0;
    }
    else
    {
      wtf_push(os, 0x4000u, *p);
    }
    ++p;
  }
}

//----- (080C316B) --------------------------------------------------------
wc_wchar_t *wtf_parse1(wc_wchar_t *retstr, wc_uchar **p)
{
  unsigned int v2; // eax
  wc_wchar_t cc; // [esp+14h] [ebp-14h]
  int cca; // [esp+14h] [ebp-14h]
  wc_uchar *q; // [esp+1Ch] [ebp-Ch]
  wc_uchar *qa; // [esp+1Ch] [ebp-Ch]
  wc_uchar *qb; // [esp+1Ch] [ebp-Ch]
  wc_uchar *qc; // [esp+1Ch] [ebp-Ch]

  q = *p;
  if ( (**p & 0x80u) == 0 )
  {
    cc.ccs = 322;
    cc.code = *q;
    qa = q + 1;
    goto LABEL_29;
  }
  if ( *q <= 0xA0u )
  {
    cca = CCS_MAP[*q - 128] << 8;
    qa = q + 1;
    v2 = cca & 0xFF00;
    if ( v2 == 0x2000 )
    {
      cc.ccs = cca | ((*qa & 0x70) >> 4);
      cc.code = ((qa[3] & 0x7F) << 7) | ((qa[2] & 0x7F) << 14) | ((qa[1] & 0x7F) << 21) | (*qa << 28) | qa[4] & 0x7F;
      qa += 5;
      goto LABEL_29;
    }
    if ( v2 <= 0x2000 )
    {
      if ( v2 != 1024 )
      {
        if ( v2 > 0x400 )
        {
          if ( v2 != 2048 )
          {
            if ( v2 == 4096 )
            {
              cc.ccs = cca | ((*qa & 0x7C) >> 2);
              cc.code = ((qa[1] & 0x7F) << 7) | (unsigned __int16)(*qa << 14) | qa[2] & 0x7F;
              qa += 3;
              goto LABEL_29;
            }
            goto LABEL_28;
          }
        }
        else if ( v2 != 256 && v2 != 512 )
        {
          goto LABEL_28;
        }
      }
LABEL_24:
      cc.ccs = cca | *qa & 0x7F;
      qb = qa + 1;
      cc.code = *qb;
      qa = qb + 1;
      goto LABEL_29;
    }
    if ( v2 != 33280 )
    {
      if ( v2 > 0x8200 )
      {
        if ( v2 != 34816 )
          goto LABEL_28;
      }
      else
      {
        if ( v2 == 0x4000 )
          goto LABEL_24;
        if ( v2 != 33024 )
        {
LABEL_28:
          cc = (wc_wchar_t)0x2000000142LL;
          goto LABEL_29;
        }
      }
    }
    cc.ccs = cca | *qa & 0x7F;
    qc = qa + 1;
    cc.code = (*qc << 8) | qc[1];
    qa = qc + 2;
    goto LABEL_29;
  }
  cc.ccs = wtf_gr_ccs;
  if ( (wtf_gr_ccs & 0x18000) != 0 )
  {
    cc.code = (*q << 8) | q[1];
    qa = q + 2;
  }
  else
  {
    cc.code = *q;
    qa = q + 1;
  }
LABEL_29:
  *p = qa;
  switch ( cc.ccs )
  {
    case 0x8802u:
    case 0x8803u:
      wc_cs94w_to_big5(retstr, cc);
      break;
    case 0x8810u:
    case 0x8811u:
    case 0x8812u:
      wc_cs128w_to_johab(retstr, cc);
      break;
    case 0x8814u:
    case 0x8815u:
      wc_cs94w_to_sjis_ext(retstr, cc);
      break;
    case 0x8817u:
    case 0x8818u:
      wc_cs128w_to_gbk(retstr, cc);
      break;
    case 0x881Au:
    case 0x881Bu:
      wc_cs128w_to_gbk_ext(retstr, cc);
      break;
    case 0x881Du:
    case 0x881Eu:
      wc_cs128w_to_uhc(retstr, cc);
      break;
    case 0x8820u:
    case 0x8821u:
      wc_cs128w_to_hkscs(retstr, cc);
      break;
    default:
      *retstr = cc;
      break;
  }
  return retstr;
}
// 80C3297: conditional instruction was optimized away because of 'eax.4 in (8201..FFFF)'
// 80C32A2: conditional instruction was optimized away because of 'eax.4 in (8201..FFFF)'
// 80C316B: inconsistent function type and number of purged bytes

//----- (080C34FA) --------------------------------------------------------
wc_wchar_t *wtf_parse(wc_wchar_t *retstr, wc_uchar **p)
{
  wc_uchar *v2; // eax
  wc_uint32 v3; // edx
  wc_uint32 v4; // edx
  wc_uint32 v5; // edx
  wc_uint32 v6; // eax
  wc_uint32 v7; // eax
  wc_uint32 v8; // edx
  wc_wchar_t v10; // [esp+18h] [ebp-30h] BYREF
  wc_wchar_t cc2; // [esp+24h] [ebp-24h] BYREF
  wc_wchar_t cc; // [esp+2Ch] [ebp-1Ch] BYREF
  wc_uint32 ucs2; // [esp+34h] [ebp-14h]
  wc_uint32 ucs; // [esp+38h] [ebp-10h]
  wc_uchar *q[2]; // [esp+3Ch] [ebp-Ch] BYREF

  if ( (**p & 0x80u) != 0 )
  {
    wtf_parse1(&cc, p);
  }
  else
  {
    cc.ccs = 322;
    v2 = *p;
    cc.code = **p;
    *p = v2 + 1;
  }
  if ( WcOption.use_combining && !WTF_WIDTH_MAP[**p] )
  {
    q[0] = *p;
    wtf_parse1(&cc2, q);
    if ( (cc.ccs == 322 || cc.ccs == 2075) && LOWORD(cc2.ccs) == 2075 )
    {
      cc2.code = wc_cp1258_precompose(cc.code, cc2.code);
      if ( cc2.code )
      {
        cc2.ccs = 2076;
        *p = q[0];
        v4 = cc2.code;
        retstr->ccs = cc2.ccs;
        retstr->code = v4;
        return retstr;
      }
    }
    else if ( (cc.ccs == 322 || cc.ccs == 2077) && LOWORD(cc2.ccs) == 2077 )
    {
      cc2.code = wc_tcvn5712_precompose(cc.code, cc2.code);
      if ( cc2.code )
      {
        cc2.ccs = 2079;
        *p = q[0];
        v5 = cc2.code;
        retstr->ccs = cc2.ccs;
        retstr->code = v5;
        return retstr;
      }
    }
    else if ( (cc.ccs == 322
            || cc.ccs == 577
            || LOWORD(cc.ccs) == 4096
            || LOWORD(cc.ccs) == 0x2000
            || LOWORD(cc.ccs) == 8193)
           && (LOWORD(cc2.ccs) == 4096 || LOWORD(cc2.ccs) == 0x2000 || LOWORD(cc2.ccs) == 8193) )
    {
      do
      {
        if ( LOWORD(cc.ccs) == 8193 )
          v6 = cc.code & 0x1FFFFF;
        else
          v6 = cc.code;
        ucs = v6;
        if ( LOWORD(cc2.ccs) == 8193 )
          v7 = cc2.code & 0x1FFFFF;
        else
          v7 = cc2.code;
        ucs2 = v7;
        ucs = wc_ucs_precompose(ucs, v7);
        if ( ucs == -1 )
          break;
        if ( LOWORD(cc.ccs) == 8193 )
        {
          cc.code = ucs | cc.code & 0xFF000000;
        }
        else
        {
          cc.ccs = wc_ucs_to_ccs(ucs);
          cc.code = ucs;
        }
        *p = q[0];
        if ( !WTF_WIDTH_MAP[*q[0]] )
          break;
        wtf_parse1(&v10, q);
        cc2 = v10;
      }
      while ( LOWORD(v10.ccs) == 4096 || LOWORD(cc2.ccs) == 0x2000 || LOWORD(cc2.ccs) == 8193 );
    }
    v8 = cc.code;
    retstr->ccs = cc.ccs;
    retstr->code = v8;
    return retstr;
  }
  v3 = cc.code;
  retstr->ccs = cc.ccs;
  retstr->code = v3;
  return retstr;
}
// 80C34FA: inconsistent function type and number of purged bytes

//----- (080C3807) --------------------------------------------------------
wc_ccs __cdecl wtf_get_ccs(wc_uchar *p)
{
  wc_wchar_t v2; // [esp+18h] [ebp-10h] BYREF

  wtf_parse1(&v2, &p);
  return v2.ccs;
}

//----- (080C3827) --------------------------------------------------------
wc_uint32 __cdecl wtf_get_code(wc_uchar *p)
{
  wc_wchar_t v2; // [esp+18h] [ebp-10h] BYREF

  wtf_parse1(&v2, &p);
  return v2.code;
}

//----- (080C3847) --------------------------------------------------------
wc_bool __cdecl wtf_is_hangul(wc_uchar *p)
{
  wc_bool result; // al
  wc_uchar f; // [esp+1Fh] [ebp-9h]
  wc_uchar *pa; // [esp+30h] [ebp+8h]
  wc_uchar *pb; // [esp+30h] [ebp+8h]

  if ( *p > 0xA0u )
    return wtf_gr_ccs == 33091 || wtf_gr_ccs == 34832;
  if ( *p == 0x81 )
    return (p[1] & 0x7F) == 67;
  if ( *p == 0x87 )
  {
    f = p[1] & 0x7F;
    result = f == 16 || f == 17 || f == 18 || f == 29 || f == 30;
  }
  else
  {
    if ( *p == 0x89 )
    {
      pa = p + 1;
      if ( !((*pa & 0x7F) >> 2) )
        return wc_is_ucs_hangul(((pa[1] & 0x7F) << 7) | (unsigned __int16)(*pa << 14) | pa[2] & 0x7F);
    }
    else if ( *p == 0x8B )
    {
      pb = p + 1;
      if ( (*pb & 0x7F) >> 4 == 1 )
        return wc_is_ucs_hangul((((pb[3] & 0x7F) << 7) | ((pb[2] & 0x7F) << 14) | ((pb[1] & 0x7F) << 21) | (*pb << 28) | pb[4] & 0x7F) & 0x1FFFFF);
    }
    result = 0;
  }
  return result;
}

//----- (080C39F2) --------------------------------------------------------
char *__cdecl wtf_conv_fit(char *s, wc_ces ces)
{
  int v3; // eax
  wc_wchar_t cc; // [esp+18h] [ebp-20h] BYREF
  wc_ces major_ces; // [esp+20h] [ebp-18h]
  Str os; // [esp+24h] [ebp-14h]
  wc_uchar *p; // [esp+28h] [ebp-10h] BYREF
  wc_bool ucs_conv; // [esp+2Eh] [ebp-Ah]
  wc_bool pre_conv; // [esp+2Fh] [ebp-9h]

  if ( ces == 3211264 || ces == 256 )
    return s;
  for ( p = (wc_uchar *)s; *p && (*p & 0x80u) == 0; ++p )
    ;
  if ( !*p )
    return s;
  v3 = strlen(s);
  os = Strnew_size(v3);
  if ( p > (wc_uchar *)s )
    Strcopy_charp_n(os, s, p - (wc_uchar *)s);
  major_ces = wtf_major_ces;
  pre_conv = WcOption.pre_conv;
  ucs_conv = WcOption.ucs_conv;
  wtf_major_ces = ces;
  WcOption.pre_conv = 1;
  WcOption.ucs_conv = 1;
  while ( *p )
  {
    wtf_parse1(&cc, &p);
    wtf_push(os, cc.ccs, cc.code);
  }
  wtf_major_ces = major_ces;
  WcOption.pre_conv = pre_conv;
  WcOption.ucs_conv = ucs_conv;
  return os->ptr;
}

//----- (080C3B1C) --------------------------------------------------------
wc_wchar_t *__userpurge wc_big5_to_cs94w@<eax>(wc_wchar_t *retstr, wc_wchar_t cc)
{
  int v2; // eax

  if ( LOBYTE(cc.code) > 0xA0u )
    v2 = 98;
  else
    v2 = 64;
  cc.code = 157 * BYTE1(cc.code) + LOBYTE(cc.code) - v2 - 25277;
  if ( cc.code > 0x1887 )
  {
    cc.ccs = 34819;
    cc.code -= 6280;
  }
  else
  {
    cc.ccs = 34818;
  }
  retstr->ccs = cc.ccs;
  retstr->code = ((cc.code / 0x5E + 33) << 8) + cc.code % 0x5E + 33;
  return retstr;
}

//----- (080C3BE8) --------------------------------------------------------
wc_wchar_t *__userpurge wc_cs94w_to_big5@<eax>(wc_wchar_t *retstr, wc_wchar_t cc)
{
  int v2; // eax
  unsigned int cc_4; // [esp+20h] [ebp+10h]

  cc.code = (cc.code & 0x7F) + 94 * ((cc.code >> 8) & 0x7F) - 3135;
  if ( cc.ccs == 34819 )
    cc_4 += 6280;
  if ( cc_4 % 0x9D > 0x3E )
    v2 = 98;
  else
    v2 = 64;
  retstr->ccs = 34817;
  retstr->code = ((cc_4 / 0x9D + 161) << 8) + cc_4 % 0x9D + v2;
  return retstr;
}

//----- (080C3CB4) --------------------------------------------------------
Str __cdecl wc_conv_from_big5(Str is, wc_ces ces)
{
  int v3; // eax
  int v4; // eax
  int state; // [esp+1Ch] [ebp-1Ch]
  wc_uchar *p; // [esp+20h] [ebp-18h]
  wc_uchar *ep; // [esp+24h] [ebp-14h]
  char *sp_0; // [esp+28h] [ebp-10h]
  Str os; // [esp+2Ch] [ebp-Ch]

  sp_0 = is->ptr;
  ep = (wc_uchar *)&is->ptr[is->length];
  state = 0;
  for ( p = (wc_uchar *)is->ptr; p < ep && (*p & 0x80u) == 0; ++p )
    ;
  if ( p == ep )
    return is;
  os = Strnew_size(is->length);
  if ( p > (wc_uchar *)sp_0 )
    Strcat_charp_n(os, is->ptr, p - (wc_uchar *)sp_0);
  while ( p < ep )
  {
    if ( state )
    {
      if ( (WC_BIG5_MAP[*p] & 4) != 0 )
        wtf_push(os, 0x8801u, (*(p - 1) << 8) | *p);
      else
        wtf_push_unknown(os, p - 1, 2u);
      state = 0;
    }
    else
    {
      v3 = WC_BIG5_MAP[*p];
      if ( v3 == 2 )
      {
        wtf_push_unknown(os, p, 1u);
      }
      else if ( v3 == 7 )
      {
        state = 1;
      }
      else
      {
        if ( os->length + 1 >= os->area_size )
          Strgrow(os);
        v4 = os->length;
        os->ptr[v4] = *p;
        os->length = v4 + 1;
        os->ptr[os->length] = 0;
      }
    }
    ++p;
  }
  if ( state == 1 )
    wtf_push_unknown(os, p - 1, 1u);
  return os;
}
// 80C3D4F: conditional instruction was optimized away because of '%state.4==1'

//----- (080C3E9C) --------------------------------------------------------
void __cdecl wc_push_to_big5(Str os, wc_wchar_t cc, wc_status *st)
{
  int v3; // eax
  int v4; // eax
  int v5; // eax
  wc_ccs v6; // eax
  wc_wchar_t v7; // [esp+18h] [ebp-10h] BYREF

  while ( cc.ccs != 34817 )
  {
    if ( cc.ccs > 0x8801 )
    {
      if ( cc.ccs <= 0x8803 )
      {
        wc_cs94w_to_big5(&cc, cc);
        break;
      }
      if ( cc.ccs == 49152 )
      {
        if ( !WcOption.no_replace )
          Strcat_charp(os, WcReplaceW);
        return;
      }
    }
    else
    {
      if ( cc.ccs == 322 )
      {
        if ( os->length + 1 >= os->area_size )
          Strgrow(os);
        v3 = os->length;
        os->ptr[v3] = cc.code;
        os->length = v3 + 1;
        os->ptr[os->length] = 0;
        return;
      }
      if ( cc.ccs == 0x4000 )
      {
        if ( !WcOption.no_replace )
          Strcat_charp(os, WcReplace);
        return;
      }
    }
    if ( WcOption.ucs_conv )
    {
      wc_any_to_any_ces(&v7, cc, st);
      cc = v7;
    }
    else
    {
      if ( (cc.ccs & 0x18000) != 0 )
        v6 = 49152;
      else
        v6 = 0x4000;
      cc.ccs = v6;
    }
  }
  if ( os->length + 1 >= os->area_size )
    Strgrow(os);
  v4 = os->length;
  os->ptr[v4] = BYTE1(cc.code);
  os->length = v4 + 1;
  os->ptr[os->length] = 0;
  if ( os->length + 1 >= os->area_size )
    Strgrow(os);
  v5 = os->length;
  os->ptr[v5] = cc.code;
  os->length = v5 + 1;
  os->ptr[os->length] = 0;
}

//----- (080C40A0) --------------------------------------------------------
Str __cdecl wc_char_conv_from_big5(wc_uchar c, wc_status *st)
{
  int v2; // eax
  int v3; // eax
  Str v5; // eax
  int v6; // edx

  if ( st->state == -1 )
  {
    st->state = 0;
    os_2633 = Strnew_size(8);
  }
  v2 = st->state;
  if ( v2 )
  {
    if ( v2 == 1 && (WC_BIG5_MAP[c] & 4) != 0 )
      wtf_push(os_2633, 0x8801u, c | (big5u_2634 << 8));
  }
  else
  {
    v3 = WC_BIG5_MAP[c];
    if ( v3 != 2 )
    {
      if ( v3 == 7 )
      {
        big5u_2634 = c;
        st->state = 1;
        return 0;
      }
      if ( os_2633->length + 1 >= os_2633->area_size )
        Strgrow(os_2633);
      v5 = os_2633;
      v6 = os_2633->length;
      os_2633->ptr[v6] = c;
      v5->length = v6 + 1;
      os_2633->ptr[os_2633->length] = 0;
    }
  }
  st->state = -1;
  return os_2633;
}

//----- (080C41D8) --------------------------------------------------------
wc_bool __cdecl wc_is_combining(wc_wchar_t cc)
{
  if ( LOWORD(cc.ccs) == 2073 )
    return cp1256_combining_map[cc.code & 0x7F];
  if ( LOWORD(cc.ccs) > 0x819u )
  {
    if ( LOWORD(cc.ccs) == 4096 )
      return wc_is_ucs_combining(cc.code);
    if ( LOWORD(cc.ccs) <= 0x1000u )
    {
      if ( LOWORD(cc.ccs) == 2075 )
        return cp1258_combining_map[cc.code & 0x7F];
      if ( LOWORD(cc.ccs) == 2077 )
        return tcvn5712_combining_map[cc.code & 0x7F];
      return 0;
    }
    if ( (unsigned int)LOWORD(cc.ccs) - 0x2000 <= 1 )
      return wc_is_ucs_combining(cc.code);
  }
  else
  {
    if ( LOWORD(cc.ccs) == 2061 )
      return cp864_combining_map[cc.code & 0x7F];
    if ( LOWORD(cc.ccs) > 0x80Du )
    {
      if ( LOWORD(cc.ccs) == 2065 )
        return cp874_combining_map[cc.code & 0x7F];
      if ( LOWORD(cc.ccs) == 2072 )
        return cp1255_combining_map[cc.code & 0x7F];
    }
    else
    {
      if ( LOWORD(cc.ccs) == 583 )
        return iso88596_combining_map[cc.code & 0x7F];
      if ( LOWORD(cc.ccs) == 596 )
        return iso885911_combining_map[cc.code & 0x7F];
    }
  }
  return 0;
}

//----- (080C42F4) --------------------------------------------------------
wc_wchar_t *__userpurge wc_gbk_ext_to_cs128w@<eax>(wc_wchar_t *retstr, wc_wchar_t cc)
{
  int v2; // eax

  if ( LOBYTE(cc.code) > 0x7Fu )
    v2 = 65;
  else
    v2 = 64;
  cc.code = 190 * BYTE1(cc.code) + LOBYTE(cc.code) - v2 - 24510;
  if ( cc.code > 0x3FFF )
  {
    cc.ccs = 34843;
    cc.code -= 0x4000;
  }
  else
  {
    cc.ccs = 34842;
  }
  retstr->ccs = cc.ccs;
  retstr->code = (cc.code >> 7 << 8) + (cc.code & 0x7F);
  return retstr;
}

//----- (080C438D) --------------------------------------------------------
wc_wchar_t *__userpurge wc_cs128w_to_gbk_ext@<eax>(wc_wchar_t *retstr, wc_wchar_t cc)
{
  int v2; // eax
  unsigned int cc_4; // [esp+20h] [ebp+10h]

  cc.code = (((cc.code >> 8) & 0x7F) << 7) + (cc.code & 0x7F);
  if ( cc.ccs == 34843 )
    cc_4 += 0x4000;
  if ( cc_4 % 0xBE > 0x3E )
    v2 = 65;
  else
    v2 = 64;
  retstr->ccs = 34841;
  retstr->code = ((cc_4 / 0xBE + 129) << 8) + cc_4 % 0xBE + v2;
  return retstr;
}

//----- (080C446B) --------------------------------------------------------
wc_ccs __cdecl wc_gbk_or_gbk_ext(wc_uint16 code)
{
  wc_ccs result; // eax

  if ( wc_map3_range_search(code, gbk_ext_ucs_map, 0x6Eu) )
    result = 34841;
  else
    result = 34838;
  return result;
}

//----- (080C44A6) --------------------------------------------------------
wc_uint32 __cdecl wc_gb18030_to_ucs(wc_wchar_t cc)
{
  int v1; // eax
  int v2; // ecx
  int v3; // eax
  wc_uint32 result; // eax
  int max; // [esp+10h] [ebp-18h]
  int min; // [esp+14h] [ebp-14h]
  int i; // [esp+18h] [ebp-10h]
  wc_map3 *map; // [esp+1Ch] [ebp-Ch]

  if ( LOWORD(cc.ccs) == 34841 )
  {
LABEL_7:
    map = wc_map3_range_search(cc.code, gbk_ext_ucs_map, 0x6Eu);
    if ( !map )
      return -1;
    if ( LOBYTE(cc.code) > 0x7Fu )
      v1 = 65;
    else
      v1 = 64;
    v2 = map->code3 + 190 * BYTE1(cc.code) + LOBYTE(cc.code) - v1;
    if ( (unsigned __int8)map->code2 > 0x7Fu )
      v3 = 65;
    else
      v3 = 64;
    return v2 + -190 * HIBYTE(map->code2) - (unsigned __int8)map->code2 + v3;
  }
  if ( LOWORD(cc.ccs) > 0x8819u )
  {
    if ( LOWORD(cc.ccs) > 0x881Bu )
      return wc_any_to_ucs(cc);
    wc_cs128w_to_gbk_ext(&cc, cc);
    goto LABEL_7;
  }
  if ( LOWORD(cc.ccs) != 8194 )
    return wc_any_to_ucs(cc);
  if ( cc.code <= 0x8130812F || cc.code > 0x8431A439 )
  {
    if ( cc.code <= 0x9030812F || cc.code > 0xE3329A35 )
      result = -1;
    else
      result = LOBYTE(cc.code) + 10 * (BYTE1(cc.code) + 126 * (BYTE2(cc.code) + 10 * HIBYTE(cc.code))) - 1810682;
  }
  else
  {
    min = 0;
    max = 205;
    cc.code = LOBYTE(cc.code) + 10 * (BYTE1(cc.code) + 126 * (BYTE2(cc.code) + 10 * HIBYTE(cc.code))) - 1687218;
    if ( cc.code < ucs_gb18030_map[205].code3 )
    {
      while ( 1 )
      {
        i = (min + max) / 2;
        if ( min == max )
          break;
        if ( cc.code >= ucs_gb18030_map[i].code3 )
        {
          if ( cc.code < ucs_gb18030_map[i + 1].code3 )
            break;
          min = i + 1;
        }
        else
        {
          max = i - 1;
        }
      }
    }
    else
    {
      i = 205;
    }
    result = ucs_gb18030_map[i].code + cc.code - ucs_gb18030_map[i].code3;
  }
  return result;
}

//----- (080C47AD) --------------------------------------------------------
wc_wchar_t *wc_ucs_to_gb18030(wc_wchar_t *retstr, wc_uint32 ucs)
{
  int v2; // eax
  int v3; // eax
  wc_ccs v4; // eax
  wc_ccs v5; // eax
  wc_wchar_t cc; // [esp+24h] [ebp-24h]
  int cca; // [esp+24h] [ebp-24h]
  wc_uint32 cc_4; // [esp+28h] [ebp-20h]
  wc_uint32 cc_4a; // [esp+28h] [ebp-20h]
  wc_uint32 cc_4b; // [esp+28h] [ebp-20h]
  wc_map3 *map; // [esp+2Ch] [ebp-1Ch]
  wc_map3 *mapa; // [esp+2Ch] [ebp-1Ch]

  if ( ucs <= 0xFFFF )
  {
    map = wc_map3_range_search(ucs, ucs_gbk_ext_map, 0x6Eu);
    if ( map )
    {
      if ( (unsigned __int8)map->code3 > 0x7Fu )
        v2 = 65;
      else
        v2 = 64;
      cc_4a = ucs + (unsigned __int8)map->code3 + 190 * HIBYTE(map->code3) - 24510 - v2 - map->code;
      if ( cc_4a % 0xBE > 0x3E )
        v3 = 65;
      else
        v3 = 64;
      retstr->ccs = 34841;
      retstr->code = ((cc_4a / 0xBE + 129) << 8) + cc_4a % 0xBE + v3;
      return retstr;
    }
    mapa = wc_map3_range_search(ucs, ucs_gb18030_map, 0xCEu);
    if ( mapa )
    {
      cc_4b = ucs + mapa->code3 - mapa->code;
      cc.code = ((cc_4b / 0xA - 126 * ((unsigned int)((2181570691u * (unsigned __int64)(cc_4b / 0x14)) >> 32) >> 5) + 129) << 8)
              + ((cc_4b / 0x4EC % 0xA + 48) << 16)
              + ((cc_4b / 0x3138 + 129) << 24)
              + cc_4b % 0xA
              + 48;
      if ( WcOption.gb18030_as_ucs )
      {
        v4 = wc_ucs_to_ccs(ucs);
        LOWORD(v4) = 0;
        cc.ccs = v4 | 0x2002;
      }
      else
      {
        cc.ccs = 73730;
      }
      *retstr = cc;
      return retstr;
    }
LABEL_20:
    retstr->ccs = 0x4000;
    retstr->code = cc_4;
    return retstr;
  }
  if ( ucs > 0x10FFFF )
    goto LABEL_20;
  if ( WcOption.gb18030_as_ucs )
  {
    v5 = wc_ucs_to_ccs(ucs);
    LOWORD(v5) = 0;
    cca = v5 | 0x2002;
  }
  else
  {
    cca = 73730;
  }
  retstr->ccs = cca;
  retstr->code = (((ucs + 123464) / 0xA
                 - 126 * ((unsigned int)((2181570691u * (unsigned __int64)((ucs + 123464) / 0x14)) >> 32) >> 5)
                 + 129) << 8)
               + (((ucs + 123464) / 0x4EC % 0xA + 48) << 16)
               + (((ucs + 123464) / 0x3138 + 129) << 24)
               + (ucs + 123464) % 0xA
               + 48;
  return retstr;
}
// 80C4B67: variable 'cc_4' is possibly undefined
// 80C47AD: inconsistent function type and number of purged bytes

//----- (080C4B76) --------------------------------------------------------
Str __cdecl wc_conv_from_gb18030(Str is, wc_ces ces)
{
  int v3; // eax
  int v4; // eax
  wc_ccs v5; // eax
  wc_ccs v6; // [esp+4h] [ebp-44h]
  wc_wchar_t cc; // [esp+1Ch] [ebp-2Ch]
  wc_uint32 ucs; // [esp+24h] [ebp-24h]
  int gbk; // [esp+28h] [ebp-20h]
  int state; // [esp+2Ch] [ebp-1Ch]
  wc_uchar *p; // [esp+30h] [ebp-18h]
  wc_uchar *ep; // [esp+34h] [ebp-14h]
  char *sp_0; // [esp+38h] [ebp-10h]
  Str os; // [esp+3Ch] [ebp-Ch]

  sp_0 = is->ptr;
  ep = (wc_uchar *)&is->ptr[is->length];
  state = 0;
  for ( p = (wc_uchar *)is->ptr; p < ep && (*p & 0x80u) == 0; ++p )
    ;
  if ( p == ep )
    return is;
  os = Strnew_size(is->length);
  if ( p > (wc_uchar *)sp_0 )
    Strcat_charp_n(os, is->ptr, p - (wc_uchar *)sp_0);
  while ( p < ep )
  {
    if ( state == 1 )
    {
      if ( (WC_GB18030_MAP[*p] & 4) != 0 )
      {
        gbk = (*(p - 1) << 8) | *p;
        if ( wc_gbk_or_gbk_ext(_byteswap_ushort(*(_WORD *)(p - 1))) == 34841 )
        {
          wtf_push(os, 0x8819u, gbk);
        }
        else if ( *(p - 1) <= 0xA0u || *p <= 0xA0u )
        {
          wtf_push(os, 0x8816u, gbk);
        }
        else
        {
          v6 = wc_gb2312_or_gbk(gbk);
          wtf_push(os, v6, gbk);
        }
      }
      else
      {
        if ( WC_GB18030_MAP[*p] == 16 )
        {
          state = 2;
          goto LABEL_41;
        }
        wtf_push_unknown(os, p - 1, 2u);
      }
      state = 0;
    }
    else if ( state <= 1 )
    {
      v3 = WC_GB18030_MAP[*p];
      if ( v3 == 2 )
      {
        wtf_push_unknown(os, p, 1u);
      }
      else if ( v3 == 12 )
      {
        state = 1;
      }
      else
      {
        if ( os->length + 1 >= os->area_size )
          Strgrow(os);
        v4 = os->length;
        os->ptr[v4] = *p;
        os->length = v4 + 1;
        os->ptr[os->length] = 0;
      }
    }
    else if ( state == 2 )
    {
      if ( WC_GB18030_MAP[*p] == 12 )
      {
        state = 3;
      }
      else
      {
        wtf_push_unknown(os, p - 2, 3u);
        state = 0;
      }
    }
    else
    {
      if ( WC_GB18030_MAP[*p] == 16 )
      {
        cc.ccs = 73730;
        cc.code = _byteswap_ulong(*(_DWORD *)(p - 3));
        if ( !WcOption.gb18030_as_ucs || (ucs = wc_gb18030_to_ucs(cc), ucs == -1) )
        {
          wtf_push(os, 0x12002u, cc.code);
        }
        else
        {
          v5 = wc_ucs_to_ccs(ucs);
          LOWORD(v5) = 0;
          wtf_push(os, v5 | 0x2002, cc.code);
        }
      }
      else
      {
        wtf_push_unknown(os, p - 3, 4u);
      }
      state = 0;
    }
LABEL_41:
    ++p;
  }
  switch ( state )
  {
    case 2:
      wtf_push_unknown(os, p - 2, 2u);
      break;
    case 3:
      wtf_push_unknown(os, p - 3, 3u);
      break;
    case 1:
      wtf_push_unknown(os, p - 1, 1u);
      break;
  }
  return os;
}
// 80C4C1B: conditional instruction was optimized away because of '%state.4==0'
// 80C4C2E: conditional instruction was optimized away because of '%state.4==3'

//----- (080C4FA9) --------------------------------------------------------
void __cdecl wc_push_to_gb18030(Str os, wc_wchar_t cc, wc_status *st)
{
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  wc_ccs v14; // eax
  wc_wchar_t v15; // [esp+18h] [ebp-10h] BYREF

  while ( 1 )
  {
    if ( LOWORD(cc.ccs) <= 0x8818u )
    {
      if ( LOWORD(cc.ccs) >= 0x8817u )
      {
        wc_cs128w_to_gbk(&cc, cc);
LABEL_25:
        if ( os->length + 1 >= os->area_size )
          Strgrow(os);
        v6 = os->length;
        os->ptr[v6] = BYTE1(cc.code);
        os->length = v6 + 1;
        os->ptr[os->length] = 0;
        if ( os->length + 1 >= os->area_size )
          Strgrow(os);
        v7 = os->length;
        os->ptr[v7] = cc.code;
        os->length = v7 + 1;
        os->ptr[os->length] = 0;
        return;
      }
      if ( LOWORD(cc.ccs) == 0x4000 )
      {
        if ( !WcOption.no_replace )
          Strcat_charp(os, WcReplace);
        return;
      }
      if ( LOWORD(cc.ccs) > 0x4000u )
      {
        if ( LOWORD(cc.ccs) == 33089 )
        {
          if ( os->length + 1 >= os->area_size )
            Strgrow(os);
          v4 = os->length;
          os->ptr[v4] = BYTE1(cc.code) | 0x80;
          os->length = v4 + 1;
          os->ptr[os->length] = 0;
          if ( os->length + 1 >= os->area_size )
            Strgrow(os);
          v5 = os->length;
          os->ptr[v5] = LOBYTE(cc.code) | 0x80;
          os->length = v5 + 1;
          os->ptr[os->length] = 0;
          return;
        }
        if ( LOWORD(cc.ccs) == 34838 )
          goto LABEL_25;
      }
      else
      {
        if ( LOWORD(cc.ccs) == 322 )
        {
          if ( os->length + 1 >= os->area_size )
            Strgrow(os);
          v3 = os->length;
          os->ptr[v3] = cc.code;
          os->length = v3 + 1;
          os->ptr[os->length] = 0;
          return;
        }
        if ( LOWORD(cc.ccs) == 8194 )
        {
          if ( os->length + 1 >= os->area_size )
            Strgrow(os);
          v10 = os->length;
          os->ptr[v10] = HIBYTE(cc.code);
          os->length = v10 + 1;
          os->ptr[os->length] = 0;
          if ( os->length + 1 >= os->area_size )
            Strgrow(os);
          v11 = os->length;
          os->ptr[v11] = BYTE2(cc.code);
          os->length = v11 + 1;
          os->ptr[os->length] = 0;
          if ( os->length + 1 >= os->area_size )
            Strgrow(os);
          v12 = os->length;
          os->ptr[v12] = BYTE1(cc.code);
          os->length = v12 + 1;
          os->ptr[os->length] = 0;
          if ( os->length + 1 >= os->area_size )
            Strgrow(os);
          v13 = os->length;
          os->ptr[v13] = cc.code;
          os->length = v13 + 1;
          os->ptr[os->length] = 0;
          return;
        }
      }
      goto LABEL_49;
    }
    if ( LOWORD(cc.ccs) <= 0x881Bu )
    {
      if ( LOWORD(cc.ccs) >= 0x881Au )
      {
        wc_cs128w_to_gbk(&v15, cc);
        cc = v15;
      }
      if ( os->length + 1 >= os->area_size )
        Strgrow(os);
      v8 = os->length;
      os->ptr[v8] = BYTE1(cc.code);
      os->length = v8 + 1;
      os->ptr[os->length] = 0;
      if ( os->length + 1 >= os->area_size )
        Strgrow(os);
      v9 = os->length;
      os->ptr[v9] = cc.code;
      os->length = v9 + 1;
      os->ptr[os->length] = 0;
      return;
    }
    if ( LOWORD(cc.ccs) == 49152 )
      break;
LABEL_49:
    if ( WcOption.ucs_conv )
    {
      wc_any_to_any_ces(&v15, cc, st);
      cc = v15;
    }
    else
    {
      if ( (cc.ccs & 0x18000) != 0 )
        v14 = 49152;
      else
        v14 = 0x4000;
      cc.ccs = v14;
    }
  }
  if ( !WcOption.no_replace )
    Strcat_charp(os, WcReplaceW);
}

//----- (080C549B) --------------------------------------------------------
Str __cdecl wc_char_conv_from_gb18030(wc_uchar c, wc_status *st)
{
  int v2; // eax
  int v3; // eax
  Str v5; // eax
  int v6; // edx
  int v7; // edx
  wc_ccs v8; // eax
  wc_ccs v9; // eax
  wc_wchar_t cc; // [esp+20h] [ebp-18h]
  wc_uint32 ucs; // [esp+28h] [ebp-10h]
  int gbk; // [esp+2Ch] [ebp-Ch]

  if ( st->state == -1 )
  {
    st->state = 0;
    os_3152 = Strnew_size(8);
  }
  v2 = st->state;
  if ( v2 == 1 )
  {
    if ( (WC_GB18030_MAP[c] & 4) != 0 )
    {
      v7 = gb_3153[0] << 8;
      gbk = v7 | c;
      if ( wc_gbk_or_gbk_ext(v7 | c) == 34841 )
      {
        wtf_push(os_3152, 0x8819u, gbk);
      }
      else if ( gb_3153[0] <= 0xA0u || c <= 0xA0u )
      {
        wtf_push(os_3152, 0x8816u, gbk);
      }
      else
      {
        v8 = wc_gb2312_or_gbk(gbk);
        wtf_push(os_3152, v8, gbk);
      }
    }
    else if ( WC_GB18030_MAP[c] == 16 )
    {
      byte_81804C9 = c;
      st->state = 2;
      return 0;
    }
  }
  else if ( v2 > 1 )
  {
    if ( v2 == 2 )
    {
      if ( WC_GB18030_MAP[c] == 12 )
      {
        byte_81804CA = c;
        st->state = 3;
        return 0;
      }
    }
    else if ( v2 == 3 && WC_GB18030_MAP[c] == 16 )
    {
      cc.ccs = 73730;
      cc.code = ((unsigned __int8)byte_81804CA << 8) | ((unsigned __int8)byte_81804C9 << 16) | (gb_3153[0] << 24) | c;
      if ( !WcOption.gb18030_as_ucs || (ucs = wc_gb18030_to_ucs(cc), ucs == -1) )
      {
        wtf_push(os_3152, 0x12002u, cc.code);
      }
      else
      {
        v9 = wc_ucs_to_ccs(ucs);
        LOWORD(v9) = 0;
        wtf_push(os_3152, v9 | 0x2002, cc.code);
      }
    }
  }
  else if ( !v2 )
  {
    v3 = WC_GB18030_MAP[c];
    if ( v3 != 2 )
    {
      if ( v3 == 12 )
      {
        gb_3153[0] = c;
        st->state = 1;
        return 0;
      }
      if ( os_3152->length + 1 >= os_3152->area_size )
        Strgrow(os_3152);
      v5 = os_3152;
      v6 = os_3152->length;
      os_3152->ptr[v6] = c;
      v5->length = v6 + 1;
      os_3152->ptr[os_3152->length] = 0;
    }
  }
  st->state = -1;
  return os_3152;
}
// 81804C9: using guessed type char byte_81804C9;
// 81804CA: using guessed type char byte_81804CA;

//----- (080C57A0) --------------------------------------------------------
wc_ccs __cdecl wc_gb2312_or_gbk(wc_uint16 code)
{
  wc_ccs result; // eax

  if ( wc_map_range_search(code, gb2312_gbk_map, 7) )
    result = 34838;
  else
    result = 33089;
  return result;
}

//----- (080C57DB) --------------------------------------------------------
wc_wchar_t *__userpurge wc_gbk_to_cs128w@<eax>(wc_wchar_t *retstr, wc_wchar_t cc)
{
  int v2; // eax

  if ( LOBYTE(cc.code) > 0x7Fu )
    v2 = 65;
  else
    v2 = 64;
  cc.code = 190 * BYTE1(cc.code) + LOBYTE(cc.code) - v2 - 24510;
  if ( cc.code > 0x3FFF )
  {
    cc.ccs = 34840;
    cc.code -= 0x4000;
  }
  else
  {
    cc.ccs = 34839;
  }
  retstr->ccs = cc.ccs;
  retstr->code = (cc.code >> 7 << 8) + (cc.code & 0x7F);
  return retstr;
}

//----- (080C5874) --------------------------------------------------------
wc_wchar_t *__userpurge wc_cs128w_to_gbk@<eax>(wc_wchar_t *retstr, wc_wchar_t cc)
{
  int v2; // eax
  unsigned int cc_4; // [esp+20h] [ebp+10h]

  cc.code = (((cc.code >> 8) & 0x7F) << 7) + (cc.code & 0x7F);
  if ( cc.ccs == 34840 )
    cc_4 += 0x4000;
  if ( cc_4 % 0xBE > 0x3E )
    v2 = 65;
  else
    v2 = 64;
  retstr->ccs = 34838;
  retstr->code = ((cc_4 / 0xBE + 129) << 8) + cc_4 % 0xBE + v2;
  return retstr;
}

//----- (080C5952) --------------------------------------------------------
wc_uint32 __cdecl wc_gbk_to_N(wc_uint32 c)
{
  int v1; // eax
  wc_uint32 result; // eax
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax

  if ( c > 0xA1A0 )
  {
    if ( c > 0xA2AA )
    {
      if ( c > 0xA6A0 )
      {
        if ( c > 0xA6F5 )
        {
          if ( c > 0xA8A0 )
          {
            if ( c > 0xA8C0 )
            {
              if ( (unsigned __int8)c > 0x7Fu )
                v8 = 65;
              else
                v8 = 64;
              result = 190 * BYTE1(c) + (unsigned __int8)c - v8 - 94 * (c >> 8) - 9338;
            }
            else
            {
              if ( (unsigned __int8)c > 0x7Fu )
                v7 = 65;
              else
                v7 = 64;
              result = 190 * BYTE1(c) + (unsigned __int8)c - v7 - 94 * (c >> 8) - 9370;
            }
          }
          else
          {
            if ( (unsigned __int8)c > 0x7Fu )
              v6 = 65;
            else
              v6 = 64;
            result = 190 * BYTE1(c) + (unsigned __int8)c - v6 - 94 * (c >> 8) - 9344;
          }
        }
        else
        {
          if ( (unsigned __int8)c > 0x7Fu )
            v5 = 65;
          else
            v5 = 64;
          result = 190 * BYTE1(c) + (unsigned __int8)c - v5 - 94 * (c >> 8) - 9429;
        }
      }
      else
      {
        if ( (unsigned __int8)c > 0x7Fu )
          v4 = 65;
        else
          v4 = 64;
        result = 190 * BYTE1(c) + (unsigned __int8)c - v4 - 94 * (c >> 8) - 9366;
      }
    }
    else
    {
      if ( (unsigned __int8)c > 0x7Fu )
        v3 = 65;
      else
        v3 = 64;
      result = 190 * BYTE1(c) + (unsigned __int8)c - v3 - 94 * (c >> 8) - 9376;
    }
  }
  else
  {
    if ( (unsigned __int8)c > 0x7Fu )
      v1 = 65;
    else
      v1 = 64;
    result = 190 * BYTE1(c) + (unsigned __int8)c - v1 - 24510;
  }
  return result;
}

//----- (080C5BB1) --------------------------------------------------------
Str __cdecl wc_conv_from_gbk(Str is, wc_ces ces)
{
  int v3; // eax
  int v4; // eax
  wc_ccs v5; // [esp+4h] [ebp-34h]
  int gbk; // [esp+18h] [ebp-20h]
  int state; // [esp+1Ch] [ebp-1Ch]
  wc_uchar *p; // [esp+20h] [ebp-18h]
  wc_uchar *ep; // [esp+24h] [ebp-14h]
  char *sp_0; // [esp+28h] [ebp-10h]
  Str os; // [esp+2Ch] [ebp-Ch]

  sp_0 = is->ptr;
  ep = (wc_uchar *)&is->ptr[is->length];
  state = 0;
  for ( p = (wc_uchar *)is->ptr; p < ep && (*p & 0x80u) == 0; ++p )
    ;
  if ( p == ep )
    return is;
  os = Strnew_size(is->length);
  if ( p > (wc_uchar *)sp_0 )
    Strcat_charp_n(os, is->ptr, p - (wc_uchar *)sp_0);
  while ( p < ep )
  {
    if ( state )
    {
      if ( (WC_GBK_MAP[*p] & 4) != 0 )
      {
        gbk = (*(p - 1) << 8) | *p;
        if ( *(p - 1) <= 0xA0u || *p <= 0xA0u )
        {
          wtf_push(os, 0x8816u, gbk);
        }
        else
        {
          v5 = wc_gb2312_or_gbk(_byteswap_ushort(*(_WORD *)(p - 1)));
          wtf_push(os, v5, gbk);
        }
      }
      else
      {
        wtf_push_unknown(os, p - 1, 2u);
      }
      state = 0;
    }
    else
    {
      v3 = WC_GBK_MAP[*p];
      switch ( v3 )
      {
        case 12:
          state = 1;
          break;
        case 20:
          wtf_push(os, 0x827u, *p);
          break;
        case 2:
          wtf_push_unknown(os, p, 1u);
          break;
        default:
          if ( os->length + 1 >= os->area_size )
            Strgrow(os);
          v4 = os->length;
          os->ptr[v4] = *p;
          os->length = v4 + 1;
          os->ptr[os->length] = 0;
          break;
      }
    }
    ++p;
  }
  if ( state == 1 )
    wtf_push_unknown(os, p - 1, 1u);
  return os;
}
// 80C5C4C: conditional instruction was optimized away because of '%state.4==1'

//----- (080C5E0F) --------------------------------------------------------
void __cdecl wc_push_to_gbk(Str os, wc_wchar_t cc, wc_status *st)
{
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  wc_ccs v9; // eax
  wc_wchar_t v10; // [esp+18h] [ebp-10h] BYREF

  while ( cc.ccs != 33089 )
  {
    if ( cc.ccs > 0x8141 )
    {
      if ( cc.ccs > 0x8818 )
      {
        if ( cc.ccs == 49152 )
        {
          if ( !WcOption.no_replace )
            Strcat_charp(os, WcReplaceW);
          return;
        }
      }
      else
      {
        if ( cc.ccs >= 0x8817 )
        {
          wc_cs128w_to_gbk(&cc, cc);
LABEL_25:
          if ( os->length + 1 >= os->area_size )
            Strgrow(os);
          v7 = os->length;
          os->ptr[v7] = BYTE1(cc.code);
          os->length = v7 + 1;
          os->ptr[os->length] = 0;
          if ( os->length + 1 >= os->area_size )
            Strgrow(os);
          v8 = os->length;
          os->ptr[v8] = cc.code;
          os->length = v8 + 1;
          os->ptr[os->length] = 0;
          return;
        }
        if ( cc.ccs == 34838 )
          goto LABEL_25;
      }
    }
    else
    {
      switch ( cc.ccs )
      {
        case 0x827u:
          if ( os->length + 1 >= os->area_size )
            Strgrow(os);
          v6 = os->length;
          os->ptr[v6] = LOBYTE(cc.code) | 0x80;
          os->length = v6 + 1;
          os->ptr[os->length] = 0;
          return;
        case 0x4000u:
          if ( !WcOption.no_replace )
            Strcat_charp(os, WcReplace);
          return;
        case 0x142u:
          if ( os->length + 1 >= os->area_size )
            Strgrow(os);
          v3 = os->length;
          os->ptr[v3] = cc.code;
          os->length = v3 + 1;
          os->ptr[os->length] = 0;
          return;
      }
    }
    if ( WcOption.ucs_conv )
    {
      wc_any_to_any_ces(&v10, cc, st);
      cc = v10;
    }
    else
    {
      if ( (cc.ccs & 0x18000) != 0 )
        v9 = 49152;
      else
        v9 = 0x4000;
      cc.ccs = v9;
    }
  }
  if ( os->length + 1 >= os->area_size )
    Strgrow(os);
  v4 = os->length;
  os->ptr[v4] = BYTE1(cc.code) | 0x80;
  os->length = v4 + 1;
  os->ptr[os->length] = 0;
  if ( os->length + 1 >= os->area_size )
    Strgrow(os);
  v5 = os->length;
  os->ptr[v5] = LOBYTE(cc.code) | 0x80;
  os->length = v5 + 1;
  os->ptr[os->length] = 0;
}

//----- (080C6133) --------------------------------------------------------
Str __cdecl wc_char_conv_from_gbk(wc_uchar c, wc_status *st)
{
  int v2; // eax
  int v3; // eax
  Str v5; // eax
  int v6; // edx
  wc_ccs v7; // eax
  int gbk; // [esp+2Ch] [ebp-Ch]

  if ( st->state == -1 )
  {
    st->state = 0;
    os_2832 = Strnew_size(8);
  }
  v2 = st->state;
  if ( v2 )
  {
    if ( v2 == 1 && (WC_GBK_MAP[c] & 4) != 0 )
    {
      gbk = (gbku_2833 << 8) | c;
      if ( gbku_2833 <= 0xA0u || c <= 0xA0u )
      {
        wtf_push(os_2832, 0x8816u, gbk);
      }
      else
      {
        v7 = wc_gb2312_or_gbk(gbk);
        wtf_push(os_2832, v7, gbk);
      }
    }
  }
  else
  {
    v3 = WC_GBK_MAP[c];
    if ( v3 == 12 )
    {
      gbku_2833 = c;
      st->state = 1;
      return 0;
    }
    if ( v3 == 20 )
    {
      wtf_push(os_2832, 0x827u, c);
    }
    else if ( v3 != 2 )
    {
      if ( os_2832->length + 1 >= os_2832->area_size )
        Strgrow(os_2832);
      v5 = os_2832;
      v6 = os_2832->length;
      os_2832->ptr[v6] = c;
      v5->length = v6 + 1;
      os_2832->ptr[os_2832->length] = 0;
    }
  }
  st->state = -1;
  return os_2832;
}

//----- (080C62D8) --------------------------------------------------------
wc_wchar_t *__userpurge wc_hkscs_to_cs128w@<eax>(wc_wchar_t *retstr, wc_wchar_t cc)
{
  int v2; // eax

  if ( LOBYTE(cc.code) > 0xA0u )
    v2 = 98;
  else
    v2 = 64;
  cc.code = 157 * BYTE1(cc.code) + LOBYTE(cc.code) - v2 - 21352;
  if ( cc.code > 0x3FFF )
  {
    cc.ccs = 34849;
    cc.code -= 0x4000;
  }
  else
  {
    cc.ccs = 34848;
  }
  retstr->ccs = cc.ccs;
  retstr->code = (cc.code >> 7 << 8) + (cc.code & 0x7F);
  return retstr;
}

//----- (080C6373) --------------------------------------------------------
wc_wchar_t *__userpurge wc_cs128w_to_hkscs@<eax>(wc_wchar_t *retstr, wc_wchar_t cc)
{
  int v2; // eax
  unsigned int cc_4; // [esp+20h] [ebp+10h]

  cc.code = (((cc.code >> 8) & 0x7F) << 7) + (cc.code & 0x7F);
  if ( cc.ccs == 34849 )
    cc_4 += 0x4000;
  if ( cc_4 % 0x9D > 0x3E )
    v2 = 98;
  else
    v2 = 64;
  retstr->ccs = 34847;
  retstr->code = ((cc_4 / 0x9D + 136) << 8) + cc_4 % 0x9D + v2;
  return retstr;
}

//----- (080C643D) --------------------------------------------------------
wc_uint32 __cdecl wc_hkscs_to_N(wc_uint32 c)
{
  int v1; // eax
  wc_uint32 result; // eax
  int v3; // eax

  if ( c > 0xA13F )
  {
    if ( (unsigned __int8)c > 0xA0u )
      v3 = 98;
    else
      v3 = 64;
    result = 157 * BYTE1(c) + (unsigned __int8)c - v3 - 35325;
  }
  else
  {
    if ( (unsigned __int8)c > 0xA0u )
      v1 = 98;
    else
      v1 = 64;
    result = 157 * BYTE1(c) + (unsigned __int8)c - v1 - 21352;
  }
  return result;
}

//----- (080C64D3) --------------------------------------------------------
Str __cdecl wc_conv_from_hkscs(Str is, wc_ces ces)
{
  int v3; // eax
  int v4; // eax
  int hkscs; // [esp+18h] [ebp-20h]
  int state; // [esp+1Ch] [ebp-1Ch]
  wc_uchar *p; // [esp+20h] [ebp-18h]
  wc_uchar *ep; // [esp+24h] [ebp-14h]
  char *sp_0; // [esp+28h] [ebp-10h]
  Str os; // [esp+2Ch] [ebp-Ch]

  sp_0 = is->ptr;
  ep = (wc_uchar *)&is->ptr[is->length];
  state = 0;
  for ( p = (wc_uchar *)is->ptr; p < ep && (*p & 0x80u) == 0; ++p )
    ;
  if ( p == ep )
    return is;
  os = Strnew_size(is->length);
  if ( p > (wc_uchar *)sp_0 )
    Strcat_charp_n(os, is->ptr, p - (wc_uchar *)sp_0);
  while ( p < ep )
  {
    if ( state )
    {
      if ( (WC_HKSCS_MAP[*p] & 4) != 0 )
      {
        hkscs = (*(p - 1) << 8) | *p;
        if ( *(p - 1) <= 0xA0u || *(p - 1) > 0xF9u )
          wtf_push(os, 0x881Fu, hkscs);
        else
          wtf_push(os, 0x8801u, hkscs);
      }
      else
      {
        wtf_push_unknown(os, p - 1, 2u);
      }
      state = 0;
    }
    else
    {
      v3 = WC_HKSCS_MAP[*p];
      if ( v3 == 12 || v3 == 16 )
      {
        state = 1;
      }
      else if ( v3 == 2 )
      {
        wtf_push_unknown(os, p, 1u);
      }
      else
      {
        if ( os->length + 1 >= os->area_size )
          Strgrow(os);
        v4 = os->length;
        os->ptr[v4] = *p;
        os->length = v4 + 1;
        os->ptr[os->length] = 0;
      }
    }
    ++p;
  }
  if ( state == 1 )
    wtf_push_unknown(os, p - 1, 1u);
  return os;
}
// 80C656E: conditional instruction was optimized away because of '%state.4==1'

//----- (080C6705) --------------------------------------------------------
void __cdecl wc_push_to_hkscs(Str os, wc_wchar_t cc, wc_status *st)
{
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  wc_ccs v8; // eax
  wc_wchar_t v9; // [esp+18h] [ebp-10h] BYREF

  while ( 1 )
  {
    if ( cc.ccs <= 0x8803 )
    {
      if ( cc.ccs >= 0x8802 )
      {
        wc_cs94w_to_big5(&cc, cc);
LABEL_17:
        if ( os->length + 1 >= os->area_size )
          Strgrow(os);
        v4 = os->length;
        os->ptr[v4] = BYTE1(cc.code);
        os->length = v4 + 1;
        os->ptr[os->length] = 0;
        if ( os->length + 1 >= os->area_size )
          Strgrow(os);
        v5 = os->length;
        os->ptr[v5] = cc.code;
        os->length = v5 + 1;
        os->ptr[os->length] = 0;
        return;
      }
      switch ( cc.ccs )
      {
        case 0x4000u:
          if ( !WcOption.no_replace )
            Strcat_charp(os, WcReplace);
          return;
        case 0x8801u:
          goto LABEL_17;
        case 0x142u:
          if ( os->length + 1 >= os->area_size )
            Strgrow(os);
          v3 = os->length;
          os->ptr[v3] = cc.code;
          os->length = v3 + 1;
          os->ptr[os->length] = 0;
          return;
      }
      goto LABEL_32;
    }
    if ( cc.ccs > 0x8821 )
      break;
    if ( cc.ccs >= 0x8820 )
    {
      wc_cs128w_to_hkscs(&v9, cc);
      cc = v9;
LABEL_23:
      if ( os->length + 1 >= os->area_size )
        Strgrow(os);
      v6 = os->length;
      os->ptr[v6] = BYTE1(cc.code);
      os->length = v6 + 1;
      os->ptr[os->length] = 0;
      if ( os->length + 1 >= os->area_size )
        Strgrow(os);
      v7 = os->length;
      os->ptr[v7] = cc.code;
      os->length = v7 + 1;
      os->ptr[os->length] = 0;
      return;
    }
    if ( cc.ccs == 34847 )
      goto LABEL_23;
LABEL_32:
    if ( WcOption.ucs_conv )
    {
      wc_any_to_any_ces(&v9, cc, st);
      cc = v9;
    }
    else
    {
      if ( (cc.ccs & 0x18000) != 0 )
        v8 = 49152;
      else
        v8 = 0x4000;
      cc.ccs = v8;
    }
  }
  if ( cc.ccs != 49152 )
    goto LABEL_32;
  if ( !WcOption.no_replace )
    Strcat_charp(os, WcReplaceW);
}

//----- (080C69F7) --------------------------------------------------------
Str __cdecl wc_char_conv_from_hkscs(wc_uchar c, wc_status *st)
{
  int v2; // eax
  int v3; // eax
  Str v5; // eax
  int v6; // edx
  int hkscs; // [esp+2Ch] [ebp-Ch]

  if ( st->state == -1 )
  {
    st->state = 0;
    os_2724 = Strnew_size(8);
  }
  v2 = st->state;
  if ( v2 )
  {
    if ( v2 == 1 && (WC_HKSCS_MAP[c] & 4) != 0 )
    {
      hkscs = (hkscsu_2725 << 8) | c;
      if ( hkscsu_2725 <= 0xA0u || hkscsu_2725 > 0xF9u || c <= 0xA0u )
        wtf_push(os_2724, 0x881Fu, hkscs);
      else
        wtf_push(os_2724, 0x8801u, hkscs);
    }
  }
  else
  {
    v3 = WC_HKSCS_MAP[c];
    if ( v3 == 12 || v3 == 16 )
    {
      hkscsu_2725 = c;
      st->state = 1;
      return 0;
    }
    if ( v3 != 2 )
    {
      if ( os_2724->length + 1 >= os_2724->area_size )
        Strgrow(os_2724);
      v5 = os_2724;
      v6 = os_2724->length;
      os_2724->ptr[v6] = c;
      v5->length = v6 + 1;
      os_2724->ptr[os_2724->length] = 0;
    }
  }
  st->state = -1;
  return os_2724;
}

//----- (080C6B7C) --------------------------------------------------------
Str __cdecl wc_conv_from_priv1(Str is, wc_ces ces)
{
  int v3; // eax
  wc_ccs ccs; // [esp+1Ch] [ebp-1Ch]
  char *p; // [esp+20h] [ebp-18h]
  wc_uchar *ep; // [esp+24h] [ebp-14h]
  char *sp_0; // [esp+28h] [ebp-10h]
  Str os; // [esp+2Ch] [ebp-Ch]

  sp_0 = is->ptr;
  ep = (wc_uchar *)&is->ptr[is->length];
  ccs = WcCesInfo[(unsigned __int8)ces].gset[1].ccs;
  for ( p = is->ptr; p < (char *)ep && *p >= 0; ++p )
    ;
  if ( p == (char *)ep )
    return is;
  os = Strnew_size(is->length);
  if ( p > sp_0 )
    Strcat_charp_n(os, is->ptr, p - sp_0);
  while ( p < (char *)ep )
  {
    if ( *p >= 0 )
    {
      if ( os->length + 1 >= os->area_size )
        Strgrow(os);
      v3 = os->length;
      os->ptr[v3] = *p;
      os->length = v3 + 1;
      os->ptr[os->length] = 0;
    }
    else
    {
      wtf_push(os, ccs, (unsigned __int8)*p);
    }
    ++p;
  }
  return os;
}

//----- (080C6CAB) --------------------------------------------------------
Str __cdecl wc_char_conv_from_priv1(wc_uchar c, wc_status *st)
{
  int v2; // eax
  Str os; // [esp+2Ch] [ebp-Ch]

  os = Strnew_size(1);
  if ( (c & 0x80u) == 0 )
  {
    if ( os->length + 1 >= os->area_size )
      Strgrow(os);
    v2 = os->length;
    os->ptr[v2] = c;
    os->length = v2 + 1;
    os->ptr[os->length] = 0;
  }
  else
  {
    wtf_push(os, st->ces_info->gset[1].ccs, c);
  }
  return os;
}

//----- (080C6D46) --------------------------------------------------------
Str __cdecl wc_conv_from_ascii(Str is, wc_ces ces)
{
  int v3; // eax
  wc_uchar *p; // [esp+10h] [ebp-18h]
  wc_uchar *ep; // [esp+14h] [ebp-14h]
  char *sp_0; // [esp+18h] [ebp-10h]
  Str os; // [esp+1Ch] [ebp-Ch]

  sp_0 = is->ptr;
  ep = (wc_uchar *)&is->ptr[is->length];
  for ( p = (wc_uchar *)is->ptr; p < ep && (*p & 0x80u) == 0; ++p )
    ;
  if ( p == ep )
    return is;
  os = Strnew_size(is->length);
  if ( p > (wc_uchar *)sp_0 )
    Strcat_charp_n(os, is->ptr, p - (wc_uchar *)sp_0);
  while ( p < ep )
  {
    if ( (*p & 0x80u) == 0 )
    {
      if ( os->length + 1 >= os->area_size )
        Strgrow(os);
      v3 = os->length;
      os->ptr[v3] = *p;
      os->length = v3 + 1;
      os->ptr[os->length] = 0;
    }
    else
    {
      wtf_push_unknown(os, p, 1u);
    }
    ++p;
  }
  return os;
}

//----- (080C6E57) --------------------------------------------------------
void __cdecl wc_push_to_raw(Str os, wc_wchar_t cc, wc_status *st)
{
  int v3; // eax

  if ( cc.ccs == 322 || cc.ccs == 2088 )
  {
    if ( os->length + 1 >= os->area_size )
      Strgrow(os);
    v3 = os->length;
    os->ptr[v3] = cc.code;
    os->length = v3 + 1;
    os->ptr[os->length] = 0;
  }
}

//----- (080C7210) --------------------------------------------------------
void _libc_csu_fini(void)
{
  ;
}

//----- (080C7220) --------------------------------------------------------
void _libc_csu_init(void)
{
  init_proc();
}

//----- (080C7280) --------------------------------------------------------
int __cdecl stat_0(char *filename, int a2)
{
  return __xstat(3, filename, (struct stat *)a2);
}

//----- (080C72C0) --------------------------------------------------------
int __cdecl fstat(int fildes, int a2)
{
  return __fxstat(3, fildes, (struct stat *)a2);
}

//----- (080C7300) --------------------------------------------------------
int __cdecl lstat(char *filename, int a2)
{
  return __lxstat(3, filename, (struct stat *)a2);
}

//----- (080C7340) --------------------------------------------------------
void (*_do_global_ctors_aux())(void)
{
  void (*result)(void); // eax
  void (**v1)(void); // ebx

  result = (void (*)(void))_CTOR_LIST__;
  if ( _CTOR_LIST__ != -1 )
  {
    v1 = (void (**)(void))&_CTOR_LIST__;
    do
    {
      --v1;
      result();
      result = *v1;
    }
    while ( *v1 != (void (*)(void))-1 );
  }
  return result;
}
// 80D4EE4: using guessed type int _CTOR_LIST__;

//----- (080C736C) --------------------------------------------------------
void term_proc()
{
  _do_global_dtors_aux();
}

// nfuncs=1649 queued=1330 decompiled=1330 lumina nreq=0 worse=0 better=0
// ALL OK, 1330 function(s) have been successfully decompiled
