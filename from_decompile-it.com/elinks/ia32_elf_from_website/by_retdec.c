//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <ctype.h>
#include <errno.h>
#include <iconv.h>
#include <langinfo.h>
#include <locale.h>
#include <search.h>
#include <signal.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/select.h>
#include <sys/time.h>
#include <termios.h>
#include <time.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct _TYPEDEF_fd_set {
    int32_t e0[1];
};

struct _TYPEDEF_sigset_t {
    int32_t e0[1];
};

struct sigaction {
    void (*e0)(int32_t);
    int32_t e1;
    void (*e2)();
    struct _TYPEDEF_sigset_t e3;
};

struct sockaddr {
    int32_t e0;
    char e1[14];
};

struct stat64 {
    int64_t e0;
    int64_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int64_t e6;
    int64_t e7;
    int64_t e8;
    int32_t e9;
    int32_t e10;
    int64_t e11;
    int32_t e12;
    int32_t e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int32_t e17;
    int32_t e18;
    int32_t e19;
};

struct termios {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    char e4;
    char e5[1];
};

struct timeval {
    int32_t e0;
    int32_t e1;
};

struct tm {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    char * e10;
};

// ------------------------- Classes --------------------------

// Sorry, but auth entry "%s" is being used by something else.

// ------------------- Function Prototypes --------------------

int32_t __divdi3(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t __udivdi3(uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4);
char * _nl_expand_alias(char * name);
int32_t _nl_explode_name(char * name, char ** language, char ** modifier, char ** territory, char ** codeset, char ** normalized_codeset, char ** special, char ** sponsor, char ** revision);
int32_t * _nl_find_domain(char * dirname, char * locale, char * domainname, int32_t * domainbinding);
char * _nl_find_msg(int32_t * domain_file, int32_t * domainbinding, char * msgid, int32_t * lengthp);
void _nl_free_domain_conv(int32_t * domain);
char * _nl_init_domain_conv(int32_t * domain_file, int32_t * domain, int32_t * domainbinding);
void _nl_load_domain(int32_t * domain_file, int32_t * domainbinding);
int32_t * _nl_make_l10nflist(int32_t ** l10nfile_list, char * dirlist, int32_t dirlist_len, uint32_t mask, char * language, char * territory, char * codeset, char * normalized_codeset, char * modifier, char * special, char * sponsor, char * revision, char * filename, int32_t do_allocate);
char * _nl_normalize_codeset(char * codeset, uint32_t name_len);
void abort_all_connections(void);
void abort_all_downloads(void);
void abort_connection(int32_t * conn, int32_t state);
void abort_download(int32_t * file_download);
int32_t * add_bookmark(int32_t * root2, int32_t place, char * title, char * url);
int32_t * add_bookmark_cp(int32_t * root2, int32_t place, int32_t codepage, char * title, char * url);
int32_t * add_bytes_to_string__(int32_t * string, char * bytes, int32_t length);
int32_t add_bytes_to_string__2(void);
int32_t add_bytes_to_string__3(void);
int32_t add_bytes_to_string__4(void);
int32_t * add_char_to_string(int32_t * string, char character);
int32_t * add_format_to_string(int32_t * string, char * format, ...);
int32_t * add_hash_item(int32_t * hash, char * key, int32_t keylen, char * value);
int32_t add_host_connection(int32_t * conn);
int32_t * add_listbox_item(int32_t * browser, int32_t * root2, int32_t type, char * data, int32_t add_position);
int32_t * add_long_to_string(int32_t * string, int32_t number);
void add_opt_rec(int32_t * tree, char * path, int32_t * option_elinks);
int32_t add_to_string(int32_t * a1, int32_t a2);
int32_t * add_uri_to_string(int32_t * string, int32_t * uri, uint32_t components);
void bookmark_auto_save_tabs(int32_t * term);
void bookmark_terminal(int32_t * term, int32_t * folder);
void bookmark_terminal_tabs(int32_t * term, char * foldername);
int32_t c_isupper(int32_t c);
int32_t c_strcasecmp(char * s1, char * s2);
char * c_strcasestr(char * haystack, char * needle);
int32_t c_strncasecmp(char * s1, char * s2, int32_t n);
int32_t c_tolower(int32_t c);
int32_t c_toupper(int32_t c);
int32_t can_read(int32_t fd);
int32_t can_read_or_write(int32_t fd, int32_t write2);
int32_t cancel_dialog(int32_t a1, int32_t a2);
void cancel_download(int32_t * download, int32_t interrupt);
void check_bottom_halves(void);
void check_keepalive_connections(void);
void check_questions_queue(int32_t * ses);
int32_t check_signals(void);
void check_timers(int32_t * last_time);
void clear_signal_mask_and_handlers(void);
void clear_terminal(int32_t * term);
void close_encoded(int32_t * stream);
void close_socket(int32_t * socket);
int32_t compare_component(char * a, int32_t alen, char * b, int32_t blen);
int32_t compare_uri(int32_t * a, int32_t * b, uint32_t components);
int32_t connection_state(void);
char * convert_string_elinks(int32_t * convert_table, char * chars, uint32_t charslen, int32_t cp, int32_t mode, int32_t * length, void (*callback)(char *, char *, int32_t), char * callback_data);
int32_t * copy_option(int32_t * template);
int32_t cp2u(int32_t from, unsigned char c);
char * cp2utf8(int32_t from, int32_t c);
int32_t cp_to_unicode(int32_t codepage, char ** string, char * end);
int32_t * current_frame(int32_t * ses);
char * dcgettext__(char * domainname, char * msgid, int32_t category);
char * dcigettext__(char * domainname, char * msgid1, char * msgid2, int32_t plural, int32_t n, int32_t category);
void del_dns_cache_entry(int32_t * dnsentry);
void del_hash_item(int32_t * hash, int32_t * item);
void delete_bookmark(int32_t * bm);
void delete_cache_entry(int32_t * cached);
void delete_entry_content(int32_t * cached);
void delete_option_do(int32_t * option_elinks, int32_t recursive);
void delete_window(int32_t * win);
void destroy_all_terminals(void);
void destroy_terminal(int32_t * term);
void detach_downloads_from_terminal(int32_t * term);
void disable_mouse(void);
int32_t do_keepalive_connection_callback(int32_t * keep_conn);
void done_bfu_colors(void);
void done_connection(int32_t * conn);
void done_connection_info(int32_t * socket);
void done_dns_lookup(int32_t * query, int32_t result);
void done_document(int32_t * document);
void done_document_options(int32_t * options);
void done_document_refresh(int32_t * refresh);
void done_download_display(int32_t * file_download);
void done_draw(void);
void done_event(void);
void done_form(int32_t * form);
void done_form_control(int32_t * fc);
void done_home(void);
void done_interlink(void);
void done_link_members(int32_t * link);
void done_listbox_item(int32_t * browser, int32_t * item);
void done_module(int32_t * module);
void done_modules(int32_t * modules);
void done_options(void);
void done_progress(int32_t * progress);
void done_saved_session_info(void);
void done_screen(int32_t * screen);
void done_session_info(int32_t * info);
void done_socket(int32_t * socket);
void done_ssl_connection(int32_t * socket);
void done_state_message(void);
int32_t done_string(int32_t * a1);
void done_uri(int32_t * uri);
void draw_box(int32_t * term, int32_t * box, unsigned char data, int32_t attr, int32_t * color);
void elinks_error(char * fmt, ...);
void elinks_internal(char * fmt, ...);
char * elinks_locale_charset(void);
int32_t elinks_ulongcat(int32_t * a1, int32_t a2, uint32_t a3, uint32_t a4, int32_t a5, uint32_t a6, int32_t a7);
int32_t encode_utf8(uint32_t a1);
void er(int32_t bell, int32_t shall_sleep, char * fmt, char * params);
void erase_screen(int32_t * term);
void fastfind_done(int32_t * index);
char * fastfind_search(int32_t * index, char * key, int32_t key_len);
void free_all_itrms(void);
void free_charsets_lookup(void);
void free_colors_lookup(void);
void free_connection_data(int32_t * conn);
void free_conv_table(void);
void free_frameset_desc(int32_t * frameset_desc);
void free_hash(int32_t ** hashp);
void free_history_lists(void);
void free_itrm(int32_t * itrm);
void free_menu(int32_t * m);
void free_translation_table(int32_t * p);
void free_uri_list(int32_t * list);
int32_t function_8058c48(int32_t a1);
int32_t function_8058d38(int32_t a1);
int32_t function_8058df8(int32_t a1);
int32_t function_8058e58(int32_t a1);
int32_t function_80590c8(int32_t a1, int32_t * a2, int32_t a3);
int32_t function_8059148(int32_t a1);
int32_t function_80593d8(int32_t a1);
int32_t function_80593e8(int32_t a1);
int32_t function_8059508(int32_t a1);
int32_t function_8059598(int32_t a1);
int32_t function_8059678(void);
int32_t function_8059778(int32_t a1);
int32_t function_80597f8(int32_t a1);
int32_t function_8059808(int32_t a1);
int32_t function_8059a68(int32_t a1);
int32_t function_8059ab8(int32_t a1, int32_t a2);
int32_t function_80cd909(void);
int32_t function_80cd977(void);
int32_t function_80cd995(void);
int32_t function_80cd9d6(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_80cda2f(void);
int32_t function_80cdd8d(void);
int32_t function_80cdde2(void);
int32_t function_80cde19(void);
int32_t function_80cde45(void);
int32_t function_80cdf00(void);
void garbage_collection(int32_t whole);
char * get_auto_save_bookmark_foldername_utf8(void);
int32_t * get_composed_uri(int32_t * uri, int32_t components);
int32_t get_cp_index(char * name);
char * get_current_title(int32_t * ses, char * str, int32_t str_size);
char * get_current_url(int32_t * ses, char * str, int32_t str_size);
char * get_entity_string(char * str, int32_t strlen2, int32_t encoding);
int32_t get_event_id(char * name);
int32_t * get_hash_item(int32_t * hash, char * key, int32_t keylen);
int32_t * get_host_connection(int32_t * conn);
int32_t get_next_timer_time(int32_t * t);
int32_t get_opt_(int32_t a1, char * a2);
int32_t * get_opt_rec(int32_t * tree, char * name_);
int32_t * get_opt_rec_real(int32_t * tree, char * name);
int32_t get_output_handle(void);
int32_t get_priority(int32_t * conn);
int32_t get_protocol(char * name, int32_t namelen);
int32_t get_protocol_free_syntax(uint32_t protocol);
int32_t get_protocol_need_slash_after_host(uint32_t protocol);
int32_t get_protocol_need_slashes(uint32_t protocol);
int32_t get_protocol_port(uint32_t protocol);
char * get_protocol_proxy(char * opt, char * env1, char * env2, char * strip1, char * strip2);
int32_t * get_proxied_uri(int32_t * uri);
int32_t * get_proxy_uri(int32_t * uri, int32_t * error_state);
char * get_ssl_connection_cipher(int32_t * socket);
char * get_system_str(int32_t xwin);
int32_t * get_tab_by_number(int32_t * term, int32_t num);
int32_t get_terminal_codepage(int32_t * term);
void get_terminal_name(char * name);
int32_t * get_translation_table(int32_t from, int32_t to);
int32_t * get_uri(char * string, int32_t components);
char * get_uri_string(int32_t * uri, int32_t components);
char * get_user_program(int32_t * term, char * progid, int32_t progidlen);
char * gettext(char * msgid);
char * gettext__(char * msgid);
int32_t gettext__parse(char * arg);
void gettext_free_exp__(int32_t * exp);
int32_t hard_write(int32_t fd, char * data, int32_t datalen);
int32_t has_keepalive_connection(int32_t * conn);
int32_t * init_connection(int32_t * uri, int32_t * proxied_uri, int32_t * referrer, int64_t start, int32_t cache_mode, int32_t priority);
int32_t * init_hash8(void);
int32_t * init_progress(int64_t start);
int32_t * init_socket(char * conn, int32_t * ops);
int32_t init_string(int32_t * a1);
void install_signal_handler(uint32_t sig, void (*fn)(char *), char * data, int32_t critical);
void install_timer(int32_t ** id, int32_t delay, void (*func)(char *), char * data);
int32_t is_blocked(void);
int32_t is_cp_utf8(int32_t a1);
int32_t is_entry_used(int32_t * cached);
int32_t is_gnuscreen(void);
int32_t is_xterm(void);
void kill_dns_request(char ** queryref);
void kill_timer(int32_t ** id);
int32_t mem_align_alloc__(int32_t a1, int32_t a2);
char * mem_alloc(int32_t size);
char * mem_calloc(int32_t count, int32_t eltsize);
void mem_free(char * p);
char * mem_mmap_alloc(int32_t size);
void mem_mmap_free(char * p, int32_t size);
char * mem_mmap_realloc(char * p, int32_t old_size, int32_t new_size);
char * mem_realloc(char * p, int32_t size);
char * memacpy(char * src, int32_t len);
int32_t mult_ms(int32_t a, uint32_t lb);
int32_t * new_exp(int32_t nargs, int32_t op, int32_t ** args);
void new_translation_table(int32_t * p);
void normalize_cache_entry(int32_t * cached, int64_t truncate_length);
void notify_connection_callbacks(int32_t * conn);
int32_t parse_day(char ** date_p, char * end);
int32_t parse_time(char ** time2, struct tm * tm, char * end);
int32_t parse_uri(int32_t * uri, char * uristring);
int32_t patience(char * of);
int32_t plural_eval(int32_t * pexp, int32_t n);
char * plural_lookup(int32_t * domain, int32_t n, char * translation, int32_t translation_len);
int32_t * proxy_uri(int32_t * uri, char * proxy, int32_t * error_state);
int32_t read_alias_file(char * fname, int32_t fname_len);
void redraw_all_terminals(void);
void redraw_from_window(int32_t * win);
void redraw_screen(int32_t * term);
void redraw_terminal(int32_t * term);
int32_t register_bottom_half_do(void (*fn)(char *), char * data);
int32_t register_check_queue(void);
void resize_screen(int32_t * term, int32_t width, int32_t height);
int32_t round_size(int32_t size);
char * safe_strncpy(char * dst, char * src, int32_t dst_size);
void sanitize_title(char * title);
int32_t sanitize_url(char * url);
void select_loop(void (*init)());
void send_done_sequence(int32_t h, int32_t altscreen);
void send_mouse_done_sequence(int32_t h);
void set_connection_state(int32_t * conn, int32_t state);
void set_cursor(int32_t * term, int32_t x, int32_t y, int32_t blockable);
void set_handlers(uint32_t fd, void (*read_func)(char *), void (*write_func)(char *), void (*error_func)(char *), char * data);
void set_screen_driver_opt(int32_t * driver, int32_t * term_spec);
void set_term_color(int32_t * schar, int32_t * pair, uint32_t flags, uint32_t color_mode);
void set_window_title(char * title, int32_t codepage);
void shrink_dns_cache(int32_t whole);
void shrink_format_cache(int32_t whole);
void shrink_memory(int32_t whole);
void shutdown_connection_stream(int32_t * conn);
void sort_queue(void);
int32_t ssl_close(int32_t * socket);
void start_update_progress(int32_t * progress, void (*timer_func)(char *), char * timer_func_data);
char * stracpy(char * src);
int32_t * string_concat(int32_t * string, ...);
char * strip_proxy_protocol(char * proxy, char * strip1, char * strip2);
int32_t T_146(void);
int32_t T_163(void);
void term_send_event(int32_t * term, int32_t * ev);
void terminate_osdep(void);
int32_t * timeval_add_interval(int32_t * t, int32_t * interval);
int32_t timeval_cmp(int32_t * t1, int32_t * t2);
int32_t timeval_div_off_t(int64_t n, int32_t * t);
int32_t * timeval_from_milliseconds(int32_t * t, int32_t milliseconds);
int32_t * timeval_from_seconds(int32_t * t, int32_t seconds);
int32_t timeval_is_positive(int32_t * t);
void timeval_limit_to_zero_or_one(int32_t * t);
int32_t * timeval_now(int32_t * t);
int32_t * timeval_sub(int32_t * res, int32_t * older, int32_t * newer);
int32_t * timeval_sub_interval(int32_t * t, int32_t * interval);
int32_t * traverse_listbox_items_list(int32_t * item, int32_t * box, int32_t offset, int32_t follow_visible, int32_t (*fn)(int32_t *, char *, int32_t *), char * d);
void trigger_event(int32_t id, ...);
void trigger_event_name(char * name, ...);
void trigger_event_va(int32_t id, char * ap_init);
void truncate_entry(int32_t * cached, int64_t offset, int32_t final);
char * u2cp_(int32_t u, int32_t to, int32_t nbsp_mode);
void unhandle_mouse(char * h);
void unhandle_terminal_resize(int32_t fd);
void unhandle_terminal_signals(int32_t * term);
void uninstall_alarm(void);
void unlink_unix(struct sockaddr * addr);
void unregister_event_hook(uint32_t id, int32_t (*callback)(char *, char *));
void unregister_event_hooks(int32_t * hooks);
void unregister_module_options(int32_t * module);
void unregister_modules_options(int32_t * modules);
void unregister_options(int32_t * info, int32_t * tree);
void update_hierbox_browser(int32_t * browser);
void update_progress(int32_t * progress, int64_t loaded, int64_t size, int64_t pos);
int32_t utf8_to_unicode(int32_t * a1, uint32_t a2);
void want_draw(void);

// --------------------- Global Variables ---------------------

int32_t LANGUAGE = 0; // 0x814a980
char * _nl_current_default_domain__ = "\xa8\xc1\x10\b"; // 0x8145260
int32_t * _nl_domain_bindings__ = NULL; // 0x815c504
int32_t * _nl_loaded_domains = NULL; // 0x814a994
int32_t _nl_msg_cat_cntr = 0; // 0x815d148
int32_t ac = 0; // 0x814aa34
int32_t active_connections = 0; // 0x814ed4c
int32_t active_screen_drivers = 0x81486cc; // 0x81486cc
char * aliases_utf8[2] = {
    "utf-8",
    "utf8"
}; // 0x8104e48
int32_t alloc_try = 0; // 0x815b340
int32_t assert_failed = 0; // 0x815b2ac
char ** av = NULL; // 0x814aa38
int32_t * bfu_colors = NULL; // 0x8148cd4
int32_t bookmark_browser = 0x8127a2d; // 0x81377c0
int32_t * bookmark_cache = NULL; // 0x8148cdc
int32_t bookmarks = 0x81375e0; // 0x81375e0
int32_t bookmarks_dirty = 0; // 0x8148ce0
int32_t bottom_halves = 0x8145418; // 0x8145418
int32_t * builtin_modules[14] = {
    (int32_t *)0x813fa38,
    (int32_t *)0x8148b5c,
    (int32_t *)0x8140b60,
    (int32_t *)0x8145fc0,
    (int32_t *)0x8145e20,
    (int32_t *)0x8145480,
    (int32_t *)0x8137400,
    (int32_t *)0x8137650,
    (int32_t *)0x813fac0,
    (int32_t *)0x8144ec8,
    (int32_t *)0x8145080,
    (int32_t *)0x81485c0,
    (int32_t *)0x813fa70,
    NULL
}; // 0x81453e0
int32_t cache_browser = 0x8127c4a; // 0x81378c0
int32_t cache_entries = 0x81378a0; // 0x81378a0
int64_t cache_size = 0; // 0x8148d00
int32_t charset_aliases = 0; // 0x814a9dc
int32_t * cmdline_options = NULL; // 0x815d144
int32_t cmdline_options_info = 0; // 0x8137980
int32_t codepages = 0x812eb69; // 0x8104f80
int32_t * color_modes[5] = {
    (int32_t *)0x810cea0,
    (int32_t *)0x810cea0,
    (int32_t *)0x810ceb4,
    (int32_t *)0x810cec8,
    (int32_t *)0x810cea0
}; // 0x810cdfc
int32_t * config_options = NULL; // 0x815d140
int32_t config_options_info = 0; // 0x81398e0
int32_t connection_id = 0; // 0x814ed50
int32_t connection_queue = 0x8145de0; // 0x8145de0
int32_t critical_section = 0; // 0x814ed80
int32_t * ditrm = NULL; // 0x815b060
int32_t dns_cache = 0x8145e08; // 0x8145e08
int32_t download_browser = 0x812b492; // 0x813fd80
int32_t elinks_home = 0; // 0x8149360
int32_t enable_secure = 0; // 0x814a990
int32_t entities = 0x812eced; // 0x81051c0
int32_t errfile = 0; // 0x815c500
int32_t errline = 0; // 0x815d14c
int32_t * event_hash = NULL; // 0x814aa08
int32_t * events = NULL; // 0x814aa00
int32_t eventssize = 0; // 0x814aa04
int32_t ff_charsets_index = 0x812ecdd; // 0x8145224
int32_t ff_colors_index = 0x8134edf; // 0x8148700
char fg_color[16][8] = {"\a\x00\x00\x00\a\x00\x00", "\x01\t\x01\t\t\t\x01\x01", "\x02\x02\n\x02\x02\x02\n\n", "\x03\v\x03\v\x03\v\x03\x03", "\f\f\x06\x04\f\x06\x04\x04", "\x05\r\x05\r\r\r\x05\x05", "\x06\x06\x0e\x06\x06\x06\x0e\x0e", "\a\a\x00\a\a\a\x00", "\x0f\x0f\b\x0f\x0f\x0f\b\b", "\t\t\x01\t\t\t\x01\t", "\n\n\n\n\n\n\n\n", "\v\v\v\v\v\v\v\v", "\f\f\x06\x04\x06\x06\x04\f", "\r\r\x05\r\r\r\x05\x05", "\x0e\x0e\x0e\x0e\x0e\x0e\x0e\x0e", "\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f"}; // 0x810ce20
int32_t file_history = 0x813fe80; // 0x813fe80
int32_t first = 1; // 0x8145238
int32_t format_cache = 0x81409fc; // 0x81409fc
int32_t germanic_plural = 0; // 0x814a9c8
int32_t g1 = 0; // 0x81016d0
int32_t g2; // 0x8104f84
int32_t g4; // 0x8104f8c
bool g5 = false; // 0x81051b0
int32_t g6 = 0x810080; // 0x8107220
char (*g7)[4] = "NUL"; // 0x8107324
int32_t g8 = 0xfee6; // 0x810bee0
int32_t g9 = 0; // 0x810c924
char * g10 = "\x14"; // 0x810c92c
char * g12 = "\x1b[1mINTERNAL ERROR\x1b[0m at %s:%d: %s"; // 0x8125598
int32_t g13 = 0x73610001; // 0x812e3d7
int32_t g14 = 0x73736100; // 0x812e3d8
char * g15 = "\x1b]0;%s\a"; // 0x8131e7e
char * g16 = "/"; // 0x8132419
char * g17 = "\x1b[2J"; // 0x81338f1
char * g18 = "\x1b[?47l"; // 0x81338f6
char * g19 = "\x1b\x38\r \b"; // 0x81338fd
char * g20 = "\x1b[?9l"; // 0x8133910
char * g21 = "\x1b[?1000l"; // 0x8133916
char * g22 = "\x1b[2J\x1b[1;1H"; // 0x813394c
char g23 = 27; // 0x81339b0
int32_t g24 = 0x38345b1b; // 0x81339bd
int32_t ** g25 = (int32_t **)0x2d250020; // 0x8134f9c
int32_t g27 = -1; // 0x8137670
int32_t g31 = 0; // 0x8140a04
int32_t g32 = 1; // 0x8145234
int32_t g33 = -1; // 0x814523c
int32_t g34 = -1; // 0x8145240
int32_t g35 = -1; // 0x8145244
char (*g36)[18] = "/usr/share/locale"; // 0x81453b0
int32_t g37 = 0; // 0x8145428
int32_t g38 = 0; // 0x814542c
int32_t g39 = 0x80b9a00; // 0x8145df0
int32_t g40 = -1; // 0x8145f98
int32_t g41 = -1; // 0x8145f9c
int32_t g42 = -1; // 0x81460c4
struct _IO_FILE * g43 = NULL; // 0x8148c58
struct _IO_FILE * g44 = NULL; // 0x8148ca0
int32_t g45 = 0; // 0x8148d04
char * g46; // 0x8149480
int32_t g47 = 0; // 0x81494c0
int32_t g48 = 0; // 0x81494c8
int32_t g49 = 0; // 0x81494cc
char * g50; // 0x81494d0
int32_t g51 = 0; // 0x814a169
int32_t g52 = 0; // 0x814a16a
int32_t g53 = 0; // 0x814a16b
int32_t g54 = 0; // 0x814a16c
int32_t g55 = 0; // 0x814a16d
int32_t g56 = 0; // 0x814a16e
int32_t g57 = 0; // 0x814a184
int32_t g58 = 0; // 0x814a984
int32_t g59 = 0; // 0x814a988
int32_t g60 = 0; // 0x814a9a4
int32_t g61 = 0; // 0x814a9b8
int32_t g62 = 0; // 0x814a9bc
int32_t g63 = 0; // 0x814a9cc
int32_t g64 = 0; // 0x814a9d0
int32_t g65 = 0; // 0x814a9d4
char * g66; // 0x814aa14
char * g67; // 0x814aa20
int32_t g68 = 0; // 0x814aa2c
int32_t g69 = 0; // 0x814aa44
int32_t g70 = 0; // 0x814aa48
int32_t g71 = 0; // 0x814aa4c
int32_t g72 = 0; // 0x814eda4
int32_t g73 = 0; // 0x814eda8
int32_t g74 = 0; // 0x814edac
int32_t g75 = 0; // 0x814efa4
int32_t g76 = 0; // 0x814f060
char * g77; // 0x815b0c4
char g78 = 0; // 0x815b0d4
int32_t g79 = 0; // 0x815c524
int32_t g80 = 0; // 0x815c924
int32_t g81 = 0; // 0x815d128
char * g82; // 0x815d12c
int16_t highhalf_NULL[128] = {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}; // 0x8104e60
int32_t host_connections = 0x8145e00; // 0x8145e00
int32_t id_counter = 1; // 0x81378a8
int32_t init_b = 0; // 0x814aa30
int32_t * keepalive_timeout = NULL; // 0x814ed54
int32_t m11_hack_frame_seqs = 0x81339a4; // 0x810df90
int32_t * main_modules[4] = {
    (int32_t *)0x81409e0,
    (int32_t *)0x81382c0,
    (int32_t *)0x81486dc,
    NULL
}; // 0x81453c0
int32_t * map = NULL; // 0x814a9ec
int32_t mouse_enabled = 0; // 0x815b064
int32_t nmap = 0; // 0x814a9f0
int32_t no_autocreate = 0; // 0x8149380
int32_t option_browser = 0x81283ee; // 0x81381c0
int32_t page_size = 0; // 0x815b344
int32_t pending_alarm = 0; // 0x814ed84
int32_t plone = 0; // 0x814a9b4
int32_t plvar = 0; // 0x814a9a0
int32_t program = 0; // 0x815d124
int32_t protocol_backends = 0x8131fd3; // 0x810c920
int32_t root = 0; // 0x814a98c
int32_t s_info_accept = 0; // 0x814aa0c
int32_t s_info_connect = 0; // 0x814aa24
int32_t s_info_listen = 0; // 0x814aa18
int32_t * screen_driver_opts[5] = {
    (int32_t *)0x810dfe0,
    (int32_t *)0x810dffc,
    (int32_t *)0x810e018,
    (int32_t *)0x810e034,
    (int32_t *)0x810e050
}; // 0x810deb0
int32_t signal_info = 0; // 0x814eda0
int32_t strerror_buf = 0x8145e18; // 0x8145e18
char strings[256][2] = {{0}, "\x01", "\x02", "\x03", "\x04", "\x05", "\x06", "\a", "\b", "\t", "\n", "\v", "\f", "\r", "\x0e", "\x0f", "\x10", "\x11", "\x12", "\x13", "\x14", "\x15", "\x16", "\x1b", "\x18", "\x19", "\x1a", "\x1b", "\x1c", "\x1d", "\x1e", "\x1b", " ", "!", "\"", "#", "$", "%", "&", "'", "(", ")", "*", "+", ",", "-", ".", "/", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ":", ";", "<", "=", ">", "?", "@", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "[", "\\", "]", "^", "_", "`", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "{", "|", "}", "~", "\x7f", "\x80", "\x81", "\x82", "\x83", "\x84", "\x85", "\x86", "\x87", "\x88", "\x89", "\x8a", "\x8b", "\x8c", "\x8d", "\x8e", "\x8f", "\x90", "\x91", "\x92", "\x93", "\x94", "\x95", "\x96", "\x97", "\x98", "\x99", "\x9a", "\x9b", "\x9c", "\x9d", "\x9e", "\x9f", "\xa0", "\xa1", "\xa2", "\xa3", "\xa4", "\xa5", "\xa6", "\xa7", "\xa8", "\xa9", "\xaa", "\xab", "\xac", "\xad", "\xae", "\xaf", "\xb0", "\xb1", "\xb2", "\xb3", "\xb4", "\xb5", "\xb6", "\xb7", "\xb8", "\xb9", "\xba", "\xbb", "\xbc", "\xbd", "\xbe", "\xbf", "\xc0", "\xc1", "\xc2", "\xc3", "\xc4", "\xc5", "\xc6", "\xc7", "\xc8", "\xc9", "\xca", "\xcb", "\xcc", "\xcd", "\xce", "\xcf", "\xd0", "\xd1", "\xd2", "\xd3", "\xd4", "\xd5", "\xd6", "\xd7", "\xd8", "\xd9", "\xda", "\xdb", "\xdc", "\xdd", "\xde", "\xdf", "\xe0", "\xe1", "\xe2", "\xe3", "\xe4", "\xe5", "\xe6", "\xe7", "\xe8", "\xe9", "\xea", "\xeb", "\xec", "\xed", "\xee", "\xef", "\xf0", "\xf1", "\xf2", "\xf3", "\xf4", "\xf5", "\xf6", "\xf7", "\xf8", "\xf9", "\xfa", "\xfb", "\xfc", "\xfd", "\xfe", "\xff"}; // 0x8107120
int32_t table_elinks = 0; // 0x814a180
int32_t terminals = 0x81486d4; // 0x81486d4
int32_t threads = 0; // 0x814aa40
int32_t timers = 0x8145420; // 0x8145420
int32_t underline_seqs = 0x8133999; // 0x810dec4
int32_t unicode_7b = 0; // 0x8107320
int32_t uri_cache = 0; // 0x814efa0
char utf_buffer[7]; // 0x814a168
int32_t utf_table = 0; // 0x815c520
int32_t utf_table_init = 1; // 0x8145220
int32_t g83;
char g84;
int32_t g85;
int32_t g86;
int32_t g87;
int32_t g88;
int32_t g89;
int32_t g90;
int32_t g91;
int32_t w_error = 0; // 0x814eb40
int32_t w_max = 0; // 0x814ed40
int32_t w_read = 0; // 0x814ea40
int32_t w_write = 0; // 0x814eac0
int32_t x_error = 0; // 0x814ecc0
int32_t x_read = 0; // 0x814ebc0
int32_t x_write = 0; // 0x814ec40
int16_t (*g3)[128] = &highhalf_NULL; // 0x8104f88
int32_t * g11 = &g24; // 0x810dfd8
int32_t * g26 = &bookmarks; // 0x81375e4
int32_t * g28 = &cache_entries; // 0x81378a4
int32_t * g29 = &file_history; // 0x813fe84
int32_t * g30 = &format_cache; // 0x8140a00

// ------------------------ Functions -------------------------

// Address range: 0x8058c48 - 0x8058c4e
int32_t function_8058c48(int32_t a1) {
    // 0x8058c48
    return gnutls_mac_get();
}

// Address range: 0x8058d38 - 0x8058d3e
int32_t function_8058d38(int32_t a1) {
    // 0x8058d38
    return gnutls_certificate_type_get_name();
}

// Address range: 0x8058df8 - 0x8058dfe
int32_t function_8058df8(int32_t a1) {
    // 0x8058df8
    return gnutls_protocol_get_name();
}

// Address range: 0x8058e58 - 0x8058e5e
int32_t function_8058e58(int32_t a1) {
    // 0x8058e58
    return gnutls_compression_get();
}

// Address range: 0x80590c8 - 0x80590ce
int32_t function_80590c8(int32_t a1, int32_t * a2, int32_t a3) {
    // 0x80590c8
    return idna_to_ascii_lz();
}

// Address range: 0x8059148 - 0x805914e
int32_t function_8059148(int32_t a1) {
    // 0x8059148
    return gnutls_cipher_get_name();
}

// Address range: 0x80593d8 - 0x80593de
int32_t function_80593d8(int32_t a1) {
    // 0x80593d8
    return gnutls_protocol_get_version();
}

// Address range: 0x80593e8 - 0x80593ee
int32_t function_80593e8(int32_t a1) {
    // 0x80593e8
    return gnutls_deinit();
}

// Address range: 0x8059508 - 0x805950e
int32_t function_8059508(int32_t a1) {
    // 0x8059508
    return gnutls_mac_get_name();
}

// Address range: 0x8059598 - 0x805959e
int32_t function_8059598(int32_t a1) {
    // 0x8059598
    return gnutls_compression_get_name();
}

// Address range: 0x8059678 - 0x805967e
int32_t function_8059678(void) {
    // 0x8059678
    return Gpm_Close();
}

// Address range: 0x8059778 - 0x805977e
int32_t function_8059778(int32_t a1) {
    // 0x8059778
    return gnutls_certificate_type_get();
}

// Address range: 0x80597f8 - 0x80597fe
int32_t function_80597f8(int32_t a1) {
    // 0x80597f8
    return gnutls_kx_get();
}

// Address range: 0x8059808 - 0x805980e
int32_t function_8059808(int32_t a1) {
    // 0x8059808
    return gnutls_kx_get_name();
}

// Address range: 0x8059a68 - 0x8059a6e
int32_t function_8059a68(int32_t a1) {
    // 0x8059a68
    return gnutls_cipher_get();
}

// Address range: 0x8059ab8 - 0x8059abe
int32_t function_8059ab8(int32_t a1, int32_t a2) {
    // 0x8059ab8
    return gnutls_bye();
}

// Address range: 0x805b2f0 - 0x805b307
int32_t cancel_dialog(int32_t a1, int32_t a2) {
    // 0x805b2f0
    delete_window((int32_t *)*(int32_t *)a1);
    return 0;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/bfu/hierbox.c
// Address range: 0x805dba0 - 0x805dbd4
// Line range:    28 - 35
void update_hierbox_browser(int32_t * browser) {
    int32_t v1 = (int32_t)browser + 24; // 0x805dbab
    int32_t v2 = *(int32_t *)v1; // 0x805dbab
    if (v2 == v1) {
        // 0x805dbcd
        return;
    }
    int32_t v3 = v2; // 0x805dbb3
    int32_t v4 = *(int32_t *)*(int32_t *)(v3 + 8); // 0x805dbbb
    redraw_from_window((int32_t *)*(int32_t *)v4);
    v3 = *(int32_t *)v3;
    while (v3 != v1) {
        // 0x805dbb8
        v4 = *(int32_t *)*(int32_t *)(v3 + 8);
        redraw_from_window((int32_t *)*(int32_t *)v4);
        v3 = *(int32_t *)v3;
    }
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/bfu/hierbox.c
// Address range: 0x805dbe0 - 0x805dcd2
// Line range:    40 - 46
int32_t * add_listbox_item(int32_t * browser, int32_t * root2, int32_t type, char * data, int32_t add_position) {
    int32_t v1 = (int32_t)root2; // 0x805dbf0
    if (root2 == NULL) {
        // 0x805dc88
        if (assert_failed == 0) {
            // 0x805dc92
            assert_failed = browser == NULL;
            if (browser == NULL) {
                // 0x805dcb0
                errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/bfu/hierbox.c";
                errline = 46;
                elinks_internal("assertion browser != NULL failed: Nowhere to add new list box item");
            }
        }
        // 0x805dca2
        v1 = (int32_t)browser + 32;
    }
    char * v2 = mem_calloc(1, 32); // 0x805dc05
    if (v2 == NULL) {
        // 0x805dc5c
        return (int32_t *)v2;
    }
    int32_t v3 = (int32_t)v2; // 0x805dc05
    char * v4 = (char *)(v3 + 24); // 0x805dc0e
    *v4 = *v4 | 2;
    int32_t v5 = v3 + 8; // 0x805dc12
    *(int32_t *)(v3 + 12) = v5;
    *(int32_t *)v5 = v5;
    *(int32_t *)(v3 + 28) = (int32_t)data;
    *(int32_t *)(v3 + 16) = type;
    *(int32_t *)(v3 + 20) = *(int32_t *)(v1 + 20) + 1;
    if (add_position < 0) {
        int32_t * v6 = (int32_t *)(v1 + 12); // 0x805dc68
        *(int32_t *)v2 = *(int32_t *)*v6;
        *(int32_t *)(v3 + 4) = *v6;
        *(int32_t *)*v6 = v3;
        *(int32_t *)(*(int32_t *)v2 + 4) = v3;
    } else {
        int32_t v7 = v1 + 8; // 0x805dc37
        int32_t * v8 = (int32_t *)v7; // 0x805dc37
        *(int32_t *)(v3 + 4) = v7;
        *(int32_t *)v2 = *v8;
        *v8 = v3;
        *(int32_t *)(*(int32_t *)v2 + 4) = v3;
    }
    if (browser != NULL) {
        // 0x805dc4e
        update_hierbox_browser(browser);
    }
    // 0x805dc5c
    return (int32_t *)v2;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/bfu/hierbox.c
// Address range: 0x805dce0 - 0x805deb8
// Line range:    88 - 84
void done_listbox_item(int32_t * browser, int32_t * item) {
    // 0x805dce0
    if (assert_failed != 0) {
        // 0x805dd98
        assert_failed = 0;
        return;
    }
    int32_t v1 = (int32_t)item;
    if (item == NULL) {
        goto lab_0x805dd0d;
    } else {
        int32_t v2 = v1 + 8; // 0x805dd01
        if (*(int32_t *)v2 == v2) {
            // 0x805de36
            assert_failed = 0;
            goto lab_0x805dd47;
        } else {
            goto lab_0x805dd0d;
        }
    }
  lab_0x805dd0d:
    // 0x805dd0d
    assert_failed = 1;
    errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/bfu/hierbox.c";
    errline = 92;
    elinks_internal("assertion item && list_empty(item->child) failed!");
    if (assert_failed != 0) {
        // 0x805dd98
        assert_failed = 0;
        return;
    }
    goto lab_0x805dd47;
  lab_0x805dd47:;
    int32_t v3 = *item; // 0x805dd47
    if (v3 == 0) {
        // 0x805dd83
        mem_free((char *)item);
        return;
    }
    int32_t v4 = (int32_t)browser + 16; // 0x805dd4d
    int32_t v5 = *(int32_t *)v4; // 0x805dd4d
    int32_t v6 = v3; // 0x805dd55
    if (v5 != v4) {
        int32_t * v7 = (int32_t *)(v5 + 12); // 0x805dd58
        int32_t * v8 = (int32_t *)v5;
        int32_t * v9; // 0x805de22
        int32_t * v10; // 0x805de6c
        int32_t v11; // 0x805de78
        if (*v7 == v1) {
            // 0x805ddf8
            v9 = traverse_listbox_items_list(item, v8, 1, 1, NULL, NULL);
            v11 = (int32_t)v9;
            if (v9 == item) {
                // 0x805de45
                v10 = traverse_listbox_items_list(item, v8, -1, 1, NULL, NULL);
                v11 = v10 == item ? 0 : (int32_t)v10;
            }
            // 0x805de2e
            *v7 = v11;
        }
        int32_t * v12 = (int32_t *)(v5 + 16); // 0x805dd61
        int32_t * v13; // 0x805ddda
        int32_t * v14; // 0x805dea4
        int32_t v15; // 0x805deb0
        if (*v12 == v1) {
            // 0x805ddb0
            v13 = traverse_listbox_items_list(item, v8, 1, 1, NULL, NULL);
            v15 = (int32_t)v13;
            if (v13 == item) {
                // 0x805de7d
                v14 = traverse_listbox_items_list(item, v8, -1, 1, NULL, NULL);
                v15 = v14 == item ? 0 : (int32_t)v14;
            }
            // 0x805ddea
            *v12 = v15;
        }
        int32_t v16 = *v8; // 0x805dd66
        int32_t v17 = v16; // 0x805dd6a
        while (v16 != v4) {
            // 0x805dd58
            v7 = (int32_t *)(v17 + 12);
            v8 = (int32_t *)v17;
            if (*v7 == v1) {
                // 0x805ddf8
                v9 = traverse_listbox_items_list(item, v8, 1, 1, NULL, NULL);
                v11 = (int32_t)v9;
                if (v9 == item) {
                    // 0x805de45
                    v10 = traverse_listbox_items_list(item, v8, -1, 1, NULL, NULL);
                    v11 = v10 == item ? 0 : (int32_t)v10;
                }
                // 0x805de2e
                *v7 = v11;
            }
            // 0x805dd61
            v12 = (int32_t *)(v17 + 16);
            if (*v12 == v1) {
                // 0x805ddb0
                v13 = traverse_listbox_items_list(item, v8, 1, 1, NULL, NULL);
                v15 = (int32_t)v13;
                if (v13 == item) {
                    // 0x805de7d
                    v14 = traverse_listbox_items_list(item, v8, -1, 1, NULL, NULL);
                    v15 = v14 == item ? 0 : (int32_t)v14;
                }
                // 0x805ddea
                *v12 = v15;
            }
            // 0x805dd66
            v16 = *v8;
            v17 = v16;
        }
        // 0x805dd6c
        v6 = *item;
    }
    int32_t * v18 = (int32_t *)(v1 + 4); // 0x805dd6e
    *(int32_t *)(v6 + 4) = *v18;
    *(int32_t *)*v18 = *item;
    update_hierbox_browser(browser);
    // 0x805dd83
    mem_free((char *)item);
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/bfu/listbox.c
// Address range: 0x80611d0 - 0x80614b3
// Line range:    119 - 223
int32_t * traverse_listbox_items_list(int32_t * item, int32_t * box, int32_t offset, int32_t follow_visible, int32_t (*fn)(int32_t *, char *, int32_t *), char * d) {
    int32_t * result = NULL; // 0x80611e8
    if (item == NULL) {
      lab_0x80612c0_4:
        // 0x80612c0
        return result;
    }
    int32_t v1 = (int32_t)box;
    bool v2 = offset != 0; // 0x8061202
    int32_t * v3 = item; // 0x8061202
    int32_t v4 = offset == 0 ? 1 : offset; // 0x8061202
    int32_t v5 = (int32_t)item; // 0x8061202
    int32_t v6; // 0x80611d0
    int32_t v7; // 0x80611d0
    int32_t v8; // 0x80611d0
    int32_t v9; // 0x80611d0
    int32_t v10; // 0x80611d0
    int32_t v11; // 0x80611d0
    int32_t v12; // 0x80611d0
    int32_t v13; // 0x80611d0
    int32_t v14; // 0x80611d0
    int32_t v15; // 0x80611d0
    int32_t v16; // 0x80611d0
    int32_t v17; // 0x80611d0
    int32_t v18; // 0x80611d0
    int32_t v19; // 0x80611d0
    int32_t v20; // 0x80611d0
    int32_t v21; // 0x80611d0
    int32_t v22; // 0x80611d0
    int32_t v23; // 0x806121b
    int32_t v24; // 0x806122a
    int32_t v25; // 0x8061227
    int32_t * v26; // 0x80611d0
    while (true) {
      lab_0x8061208:
        // 0x8061208
        v22 = v2;
        int32_t v27 = v5;
        int32_t v28 = v4;
        int32_t * v29 = v3;
        while (true) {
            // 0x8061210
            v26 = v29;
            v10 = v27;
            v6 = v28;
            v18 = v28;
            while (true) {
              lab_0x8061210_2:
                // 0x8061210
                v19 = v18;
                v7 = v6;
                v11 = v10;
                while (true) {
                  lab_0x8061210:
                    // 0x8061210
                    result = v26;
                    if (v7 == 0) {
                        return result;
                    }
                    // 0x8061218
                    v12 = v11;
                    v20 = v19;
                    v23 = *(int32_t *)(v1 + 8);
                    v24 = *(int32_t *)v12;
                    v13 = v12;
                    if (fn == NULL) {
                        goto lab_0x806124a;
                    } else {
                        if (follow_visible == 0) {
                            goto lab_0x80612d0;
                        } else {
                            // 0x806123d
                            v13 = v12;
                            if ((*(char *)(v12 + 24) & 2) != 0) {
                                goto lab_0x80612d0;
                            } else {
                                goto lab_0x806124a;
                            }
                        }
                    }
                }
              lab_0x8061390:
                // 0x8061390
                v25 = *(int32_t *)(v12 + 4);
                int32_t v30; // 0x80611d0
                v17 = v20 + v30;
                if (v23 == 0) {
                    // 0x806143c
                    int32_t * v31; // 0x80611d0
                    int32_t v32 = *v31; // 0x8061444
                    v9 = 1;
                    v16 = v14;
                    if (v32 == v25) {
                        goto lab_0x8061453;
                    } else {
                        goto lab_0x80613b2;
                    }
                } else {
                    // 0x80613a7
                    if (v23 + 8 == v25) {
                        goto lab_0x8061457_2;
                    } else {
                        goto lab_0x80613b2;
                    }
                }
            }
          lab_0x8061310_4:
            // 0x8061310
            v27 = v15;
            v28 = v21;
            v29 = (int32_t *)v27;
            result = v29;
            if (v8 != 0) {
                return result;
            }
        }
    }
  lab_0x80612c0_4:;
    int32_t v33 = v17 - 1; // 0x806146c
    int32_t v34; // 0x80611d0
    v10 = v34;
    v6 = v33;
    v18 = v33;
    result = v26;
    if (v9 != 0) {
        return result;
    }
    goto lab_0x8061210_2;
  lab_0x8061457_2:
    // 0x8061457
    v21 = v17;
    v8 = v9;
    v15 = v16;
    if (follow_visible == 0) {
        // break -> 0x8061310
        goto lab_0x8061310_4;
    }
    // 0x8061462
    v21 = v17;
    v8 = v9;
    v15 = v16;
    v34 = v16;
    if ((*(char *)(v16 + 24) & 2) != 0) {
        // break -> 0x8061310
        goto lab_0x8061310_4;
    }
    goto lab_0x80612c0_4;
  lab_0x806124a:
    // 0x806124a
    v14 = v13;
    if (v20 < 1) {
        // break -> 0x8061390
        goto lab_0x8061390;
    }
    int32_t v35 = v20 + v22;
    int32_t v36; // 0x80611d0
    int32_t v37; // 0x80611d0
    if (v14 == 0) {
        goto lab_0x8061320;
    } else {
        int32_t v38 = v14 + 8; // 0x8061267
        int32_t v39 = *(int32_t *)v38; // 0x8061267
        if (v39 == v38) {
            goto lab_0x8061320;
        } else {
            unsigned char v40 = *(char *)(v14 + 24); // 0x8061275
            if (v40 % 2 == 0) {
                goto lab_0x8061320;
            } else {
                // 0x8061281
                v36 = 0;
                v37 = v39;
                if (follow_visible != 0 == (v40 & 2) == 0) {
                    goto lab_0x8061320;
                } else {
                    goto lab_0x80612a0;
                }
            }
        }
    }
  lab_0x8061320:;
    int32_t v41; // 0x80611d0
    int32_t v42; // 0x80611d0
    if (v23 == 0) {
        // 0x8061357
        v36 = 1;
        v37 = v14;
        if (v24 == 0) {
            goto lab_0x80612a0;
        } else {
            // 0x806135f
            v36 = 1;
            v37 = v14;
            v42 = v24;
            v41 = 0;
            if (*(int32_t *)(v1 + 24) == v24) {
                goto lab_0x80612a0;
            } else {
                goto lab_0x80612a4;
            }
        }
    } else {
        int32_t v43 = v23 + 8;
        v36 = 0;
        v37 = v24;
        if (v24 == v43) {
            int32_t v44 = *(int32_t *)v23; // 0x806134f
            v36 = 0;
            v37 = v44;
            while (v43 == v44) {
                // 0x8061338
                v36 = 0;
                v37 = v44;
            }
        }
        goto lab_0x80612a0;
    }
  lab_0x80612d0:;
    int32_t v45 = d != NULL ? 0 : v12; // 0x80612f1
    v2 = true;
    v3 = v26;
    v4 = v20;
    v5 = v45;
    v13 = v45;
    if (v20 != 0) {
        goto lab_0x806124a;
    } else {
        goto lab_0x8061208;
    }
  lab_0x80612a0:
    // 0x80612a0
    v42 = v37;
    v41 = v36;
    int32_t v46 = 0; // 0x80612a2
    int32_t v47 = v36; // 0x80612a2
    if (v37 == 0) {
        goto lab_0x80612b1;
    } else {
        goto lab_0x80612a4;
    }
  lab_0x80612b1:;
    int32_t v48 = v35 + 1; // 0x80612b1
    v19 = v48;
    v7 = v48;
    v11 = v46;
    result = v26;
    if (v47 != 0) {
        // break (via goto) -> 0x80612c0
        goto lab_0x80612c0_4;
    }
    goto lab_0x8061210;
  lab_0x80612a4:;
    int32_t v49 = v41;
    int32_t v50 = v42;
    v21 = v35;
    v8 = v49;
    v15 = v50;
    if (follow_visible == 0) {
        // break (via goto) -> 0x8061310
        goto lab_0x8061310_4;
    }
    // 0x80612ab
    v46 = v50;
    v47 = v49;
    v21 = v35;
    v8 = v49;
    v15 = v50;
    if ((*(char *)(v50 + 24) & 2) != 0) {
        // break (via goto) -> 0x8061310
        goto lab_0x8061310_4;
    }
    goto lab_0x80612b1;
  lab_0x8061453:
    // 0x8061453
    v34 = 0;
    if (v16 == 0) {
        goto lab_0x80612c0_4;
    } else {
        goto lab_0x8061457_2;
    }
  lab_0x80613b2:
    // 0x80613b2
    v34 = 0;
    if (v25 == 0) {
        goto lab_0x80612c0_4;
    } else {
        int32_t v51 = v25 + 8; // 0x80613c2
        int32_t v52 = *(int32_t *)v51; // 0x80613c5
        if (v52 == v51) {
            goto lab_0x8061457_2;
        } else {
            unsigned char v53 = *(char *)(v25 + 24); // 0x80613ce
            char v54 = v53; // 0x80613d6
            int32_t v55 = v25; // 0x80613d6
            if (v53 % 2 == 0) {
                goto lab_0x8061457_2;
            } else {
                int32_t v56 = v55;
                char v57 = v54;
                v9 = 0;
                v16 = v56;
                while (follow_visible != 0 != ((v57 & 2) == 0)) {
                    int32_t v58 = *(int32_t *)(v56 + 12); // 0x8061404
                    v34 = 0;
                    if (v58 == 0) {
                        goto lab_0x80612c0_4;
                    }
                    int32_t v59 = v58 + 8; // 0x80613e8
                    int32_t v60 = *(int32_t *)v59; // 0x80613eb
                    if (v60 == v59) {
                        goto lab_0x8061457_2;
                    }
                    unsigned char v61 = *(char *)(v58 + 24); // 0x80613f4
                    v54 = v61;
                    v55 = v58;
                    if (v61 % 2 == 0) {
                        goto lab_0x8061457_2;
                    }
                    v56 = v55;
                    v57 = v54;
                    v9 = 0;
                    v16 = v56;
                }
                goto lab_0x8061453;
            }
        }
    }
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/bfu/listmenu.c
// Address range: 0x8062440 - 0x8062497
// Line range:    137 - 149
void free_menu(int32_t * m) {
    if (m == NULL) {
        // 0x8062490
        return;
    }
    int32_t v1 = *m; // 0x806244f
    if (v1 == 0) {
        // 0x8062472
        mem_free((char *)m);
        return;
    }
    int32_t v2 = (int32_t)m;
    mem_free((char *)v1);
    if (*(int32_t *)(v2 + 12) == 0x8062810) {
        // 0x8062480
        free_menu((int32_t *)*(int32_t *)(v2 + 16));
    }
    int32_t v3 = v2 + 32; // 0x8062469
    int32_t v4 = *(int32_t *)v3; // 0x806246c
    while (v4 != 0) {
        // 0x8062458
        v2 = v3;
        mem_free((char *)v4);
        if (*(int32_t *)(v2 + 12) == 0x8062810) {
            // 0x8062480
            free_menu((int32_t *)*(int32_t *)(v2 + 16));
        }
        // 0x8062469
        v3 = v2 + 32;
        v4 = *(int32_t *)v3;
    }
    // 0x8062472
    mem_free((char *)m);
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/bfu/style.c
// Address range: 0x8065bb0 - 0x8065c40
// Line range:    101 - 114
void done_bfu_colors(void) {
    // 0x8065bb0
    if (bfu_colors == NULL) {
        // 0x8065c38
        return;
    }
    int32_t v1 = (int32_t)bfu_colors; // 0x8065bb9
    int32_t v2 = v1; // 0x8065bcd
    int32_t v3 = 0; // 0x8065bcd
    if (v1 % 32 == 31) {
        // 0x8065c2c
        free_hash(&bfu_colors);
        // 0x8065c38
        return;
    }
    int32_t v4 = 8 * v3 + 8;
    int32_t v5 = v4 + v1;
    int32_t v6 = *(int32_t *)v5; // 0x8065bdf
    int32_t v7 = v2; // 0x8065bef
    int32_t v8 = v6; // 0x8065bef
    int32_t v9 = v1; // 0x8065bef
    int32_t v10; // 0x8065bb0
    int32_t v11; // 0x8065bf8
    int32_t v12; // 0x8065c0c
    if (v6 != v5) {
        v11 = *(int32_t *)(v8 + 16);
        v10 = v7;
        if (v11 != 0) {
            // 0x8065bff
            mem_free((char *)v11);
            v10 = (int32_t)bfu_colors;
        }
        // 0x8065c0c
        v12 = *(int32_t *)v8;
        v7 = v10;
        v8 = v12;
        v2 = v10;
        v9 = v10;
        while (v10 + v4 != v12) {
            // 0x8065bf8
            v11 = *(int32_t *)(v8 + 16);
            v10 = v7;
            if (v11 != 0) {
                // 0x8065bff
                mem_free((char *)v11);
                v10 = (int32_t)bfu_colors;
            }
            // 0x8065c0c
            v12 = *(int32_t *)v8;
            v7 = v10;
            v8 = v12;
            v2 = v10;
            v9 = v10;
        }
    }
    // 0x8065c18
    v3++;
    while (1 << *(int32_t *)v9 % 32 > v3) {
        // 0x8065bd8
        v4 = 8 * v3 + 8;
        v5 = v4 + v9;
        v6 = *(int32_t *)v5;
        v7 = v2;
        v8 = v6;
        if (v6 != v5) {
            v11 = *(int32_t *)(v8 + 16);
            v10 = v7;
            if (v11 != 0) {
                // 0x8065bff
                mem_free((char *)v11);
                v10 = (int32_t)bfu_colors;
            }
            // 0x8065c0c
            v12 = *(int32_t *)v8;
            v7 = v10;
            v8 = v12;
            v2 = v10;
            v9 = v10;
            while (v10 + v4 != v12) {
                // 0x8065bf8
                v11 = *(int32_t *)(v8 + 16);
                v10 = v7;
                if (v11 != 0) {
                    // 0x8065bff
                    mem_free((char *)v11);
                    v10 = (int32_t)bfu_colors;
                }
                // 0x8065c0c
                v12 = *(int32_t *)v8;
                v7 = v10;
                v8 = v12;
                v2 = v10;
                v9 = v10;
            }
        }
        // 0x8065c18
        v3++;
    }
    // 0x8065c2c
    free_hash(&bfu_colors);
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/bookmarks/bookmarks.c
// Address range: 0x8067080 - 0x806712c
// Line range:    647 - 664
char * get_auto_save_bookmark_foldername_utf8(void) {
    int32_t v1 = get_opt_((int32_t)config_options, "ui.sessions.auto_save_foldername"); // 0x806709f
    char * str = (char *)*(int32_t *)v1; // 0x80670a6
    if (*str == 0) {
        // 0x80670ad
        return NULL;
    }
    int32_t v2 = get_cp_index("System"); // 0x80670c7
    int32_t v3 = get_cp_index("UTF-8"); // 0x80670d5
    int32_t * v4 = get_translation_table(v2, v3); // 0x80670e3
    char * result = NULL; // 0x80670ec
    if (v4 != NULL) {
        // 0x80670ee
        result = convert_string_elinks(v4, str, strlen(str), v3, 3, NULL, NULL, NULL);
    }
    // 0x80670ad
    return result;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/bookmarks/bookmarks.c
// Address range: 0x80673d0 - 0x806760f
// Line range:    382 - 409
int32_t * add_bookmark(int32_t * root2, int32_t place, char * title, char * url) {
    char * v1 = mem_calloc(1, 36); // 0x80673ee
    int32_t v2 = (int32_t)v1; // 0x80673ee
    if (v1 == NULL) {
        // 0x8067501
        return (int32_t *)v2;
    }
    char * v3 = stracpy(title); // 0x8067403
    int32_t * v4 = (int32_t *)(v2 + 20); // 0x806740a
    *v4 = (int32_t)v3;
    if (v3 == NULL) {
        // 0x80675db
        mem_free(v1);
        // 0x8067501
        return (int32_t *)0;
    }
    // 0x8067413
    sanitize_title(v3);
    char * v5 = stracpy(url != NULL ? url : (char *)&g14); // 0x8067428
    int32_t * v6 = (int32_t *)(v2 + 24); // 0x806742f
    *v6 = (int32_t)v5;
    if (v5 == NULL) {
        // 0x80675d0
        mem_free((char *)*v4);
        // 0x80675db
        mem_free(v1);
        // 0x8067501
        return (int32_t *)0;
    }
    int32_t v7 = (int32_t)root2;
    sanitize_url(v5);
    int32_t v8 = v2 + 28; // 0x8067440
    *(int32_t *)(v2 + 12) = v7;
    *(int32_t *)(v2 + 32) = v8;
    *(int32_t *)v8 = v8;
    int32_t v9; // 0x80673d0
    if (url == NULL) {
        goto lab_0x8067510;
    } else {
        // 0x8067454
        v9 = 0;
        if (*url == 0) {
            goto lab_0x8067510;
        } else {
            goto lab_0x806745f;
        }
    }
  lab_0x8067510:
    if (title == NULL) {
        // 0x806751f
        v9 = 1;
        goto lab_0x806745f;
    } else {
        // 0x8067517
        if (*title == 45) {
            // 0x8067550
            v9 = 2;
            if (*(char *)((int32_t)title + 1) == 0) {
                goto lab_0x806745f;
            } else {
                // 0x806751f
                v9 = 1;
                goto lab_0x806745f;
            }
        } else {
            // 0x806751f
            v9 = 1;
            goto lab_0x806745f;
        }
    }
  lab_0x806745f:;
    int32_t * v10 = NULL; // 0x806746f
    if (root2 != NULL) {
        // 0x8067471
        v10 = (int32_t *)*(int32_t *)(v7 + 16);
    }
    int32_t * v11 = add_listbox_item(&bookmark_browser, v10, v9, v1, place == 0 ? 1 : -1); // 0x806748b
    *(int32_t *)(v2 + 16) = (int32_t)v11;
    if (v11 == NULL) {
        // 0x80675ea
        mem_free((char *)*v6);
        mem_free((char *)*v4);
        mem_free(v1);
        // 0x8067501
        return (int32_t *)0;
    }
    if (place != 0) {
        if (root2 == NULL) {
            // 0x8067568
            *(int32_t *)v1 = (int32_t)g26;
            *(int32_t *)(v2 + 4) = (int32_t)g26;
            *g26 = v2;
            *(int32_t *)(*(int32_t *)v1 + 4) = v2;
        } else {
            int32_t * v12 = (int32_t *)(v7 + 32); // 0x8067534
            *(int32_t *)v1 = *(int32_t *)*v12;
            *(int32_t *)(v2 + 4) = *v12;
            *(int32_t *)*v12 = v2;
            *(int32_t *)(*(int32_t *)v1 + 4) = v2;
        }
    } else {
        if (root2 == NULL) {
            // 0x8067590
            *(int32_t *)(v2 + 4) = (int32_t)&bookmarks;
            *(int32_t *)v1 = (int32_t)&bookmarks;
            bookmarks = v2;
            *(int32_t *)(*(int32_t *)v1 + 4) = v2;
        } else {
            int32_t v13 = v7 + 28; // 0x80674ae
            int32_t * v14 = (int32_t *)v13; // 0x80674ae
            *(int32_t *)(v2 + 4) = v13;
            *(int32_t *)v1 = *v14;
            *v14 = v2;
            *(int32_t *)(*(int32_t *)v1 + 4) = v2;
        }
    }
    // 0x80674c1
    bookmarks_dirty = 1;
    int32_t v15 = (int32_t)bookmark_cache; // 0x80674d3
    if (bookmark_cache == NULL) {
        int32_t * v16 = init_hash8(); // 0x80675b0
        int32_t v17 = (int32_t)v16; // 0x80675b0
        *(int32_t *)&bookmark_cache = v17;
        v15 = v17;
        if (v16 == NULL) {
            // 0x8067501
            return (int32_t *)v2;
        }
    }
    int32_t v18 = *v6; // 0x80674d9
    if (v18 == 0) {
        // 0x8067501
        return (int32_t *)v2;
    }
    char * str = (char *)v18; // 0x80674e0
    if (*str != 0) {
        // 0x80674e5
        add_hash_item((int32_t *)v15, str, strlen(str), v1);
    }
    // 0x8067501
    return (int32_t *)v2;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/bookmarks/bookmarks.c
// Address range: 0x8067610 - 0x806773f
// Line range:    437 - 460
int32_t * add_bookmark_cp(int32_t * root2, int32_t place, int32_t codepage, char * title, char * url) {
    int32_t v1 = get_cp_index("UTF-8"); // 0x8067623
    int32_t * v2 = get_translation_table(codepage, v1); // 0x806763e
    if (v2 == NULL) {
        // 0x806770b
        return (int32_t *)0;
    }
    char * v3 = convert_string_elinks(v2, title, strlen(title), v1, 3, NULL, NULL, NULL); // 0x806768c
    char * str = url == NULL ? (char *)&g14 : url; // 0x8067697
    char * v4 = convert_string_elinks(v2, str, strlen(str), v1, 3, NULL, NULL, NULL); // 0x80676cb
    if (v4 == NULL) {
        // 0x80676e3
        if (v3 != NULL) {
            // 0x80676f7
            mem_free(v3);
        }
        // 0x806770b
        return (int32_t *)0;
    }
    int32_t v5 = 0; // 0x806771a
    if (v3 != NULL) {
        int32_t * v6 = add_bookmark(root2, place, v3, v4); // 0x8067735
        mem_free(v3);
        v5 = (int32_t)v6;
    }
    // 0x80676fd
    mem_free(v4);
    // 0x806770b
    return (int32_t *)v5;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/bookmarks/bookmarks.c
// Address range: 0x8067740 - 0x8067830
// Line range:    575 - 592
void bookmark_terminal(int32_t * term, int32_t * folder) {
    int32_t v1 = __readgsdword(20); // 0x8067751
    int32_t v2; // 0x8067740
    int32_t * v3 = (int32_t *)v2; // 0x8067762
    int32_t v4 = get_terminal_codepage(v3); // 0x8067762
    int32_t v5 = *(int32_t *)(v2 + 12); // 0x806776d
    int32_t v6 = v2 + 8; // 0x8067770
    int32_t v7; // 0x8067740
    int32_t v8; // 0x8067740
    if (v5 != v6) {
        // 0x806778b
        v7 = v5;
        while (true) {
          lab_0x806778b_2:
            // 0x806778b
            v8 = v7;
            if (*(int32_t *)(v8 + 8) != 1) {
                goto lab_0x8067780;
            } else {
                int32_t * v9 = (int32_t *)*(int32_t *)(v8 + 16); // 0x80677aa
                int32_t v10; // bp-2080, 0x8067740
                if (get_current_url(v9, (char *)&v10, 1024) == NULL) {
                    goto lab_0x8067780;
                } else {
                    // 0x80677b3
                    int32_t v11; // bp-1056, 0x8067740
                    if (get_current_title(v9, (char *)&v11, 1024) == NULL) {
                        goto lab_0x8067780;
                    } else {
                        // 0x80677d1
                        add_bookmark_cp(v3, 1, v4, (char *)&v11, (char *)&v10);
                        int32_t v12 = *(int32_t *)(v8 + 4); // 0x8067805
                        if (v12 == v6) {
                            // break -> 0x8067810
                            break;
                        }
                        // 0x806778b
                        v7 = v12;
                        goto lab_0x806778b_2;
                    }
                }
            }
        }
    }
  lab_0x8067810:
    // 0x8067810
    if (v1 != __readgsdword(20)) {
        // 0x8067827
        __stack_chk_fail();
        return;
    }
  lab_0x8067780:;
    int32_t v13 = *(int32_t *)(v8 + 4); // 0x8067780
    if (v13 == v6) {
        // break -> 0x8067810
        goto lab_0x8067810;
    }
    // 0x806778b
    v7 = v13;
    goto lab_0x806778b_2;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/bookmarks/bookmarks.c
// Address range: 0x8067830 - 0x8067876
// Line range:    603 - 610
void bookmark_terminal_tabs(int32_t * term, char * foldername) {
    // 0x8067830
    if (add_bookmark(NULL, 1, foldername, NULL) == NULL) {
        // 0x8067870
        return;
    }
    // 0x8067861
    bookmark_terminal(&g83, &g83);
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/bookmarks/bookmarks.c
// Address range: 0x8067880 - 0x806797e
// Line range:    249 - 264
void delete_bookmark(int32_t * bm) {
    int32_t v1 = (int32_t)bm;
    int32_t v2 = v1 + 28; // 0x806788c
    int32_t * v3 = (int32_t *)v2; // 0x806788c
    int32_t v4 = *v3; // 0x806788c
    if (v4 != v2) {
        delete_bookmark((int32_t *)v4);
        int32_t v5 = *v3; // 0x80678a0
        while (v5 != v2) {
            // 0x8067898
            delete_bookmark((int32_t *)v5);
            v5 = *v3;
        }
    }
    // 0x80678a7
    int32_t v6; // 0x8067880
    if (bookmark_cache == NULL) {
        goto lab_0x80678bd;
    } else {
        int32_t v7 = *(int32_t *)(v1 + 24); // 0x80678b1
        if (v7 == 0) {
            goto lab_0x80678bd;
        } else {
            char * str = (char *)v7; // 0x80678b8
            if (*str != 0) {
                int32_t * v8 = get_hash_item(bookmark_cache, str, strlen(str)); // 0x806793b
                if (v8 == NULL) {
                    goto lab_0x80678bd;
                } else {
                    // 0x8067948
                    del_hash_item(bookmark_cache, v8);
                    v6 = g27;
                    if (g27 != -1) {
                        goto lab_0x80678cb;
                    } else {
                        goto lab_0x8067968;
                    }
                }
            } else {
                goto lab_0x80678bd;
            }
        }
    }
  lab_0x80678bd:
    // 0x80678bd
    v6 = g27;
    if (g27 == -1) {
        goto lab_0x8067968;
    } else {
        goto lab_0x80678cb;
    }
  lab_0x8067968:;
    int32_t v9 = get_event_id("bookmark-delete"); // 0x806796f
    g27 = v9;
    v6 = v9;
    goto lab_0x80678cb;
  lab_0x80678cb:
    // 0x80678cb
    trigger_event(v6);
    int32_t * v10 = (int32_t *)(v1 + 4); // 0x80678d9
    *(int32_t *)(*bm + 4) = *v10;
    *(int32_t *)*v10 = *bm;
    bookmarks_dirty = 1;
    done_listbox_item(&bookmark_browser, (int32_t *)*(int32_t *)(v1 + 16));
    mem_free((char *)*(int32_t *)(v1 + 20));
    mem_free((char *)*(int32_t *)(v1 + 24));
    mem_free((char *)bm);
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/bookmarks/bookmarks.c
// Address range: 0x8067980 - 0x8067a69
// Line range:    671 - 687
void bookmark_auto_save_tabs(int32_t * term) {
    // 0x8067980
    if (*(int32_t *)get_opt_((int32_t)cmdline_options, "anonymous") != 0 || *(int32_t *)get_opt_((int32_t)config_options, "ui.sessions.auto_save") == 0) {
        // 0x80679b0
        return;
    }
    char * v1 = get_auto_save_bookmark_foldername_utf8(); // 0x80679db
    if (v1 == NULL) {
        // 0x80679b0
        return;
    }
    // 0x8067a40
    bookmark_terminal_tabs(term, v1);
    mem_free(v1);
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/cache/cache.c
// Address range: 0x806b540 - 0x806b66d
// Line range:    635 - 266
void delete_entry_content(int32_t * cached) {
    int32_t v1 = (int32_t)cached;
    int32_t * v2 = (int32_t *)(v1 + 72); // 0x806b54b
    int32_t v3 = *v2; // 0x806b54b
    int32_t * v4 = (int32_t *)(v1 + 76); // 0x806b54e
    *v2 = 0;
    *v4 = 0;
    int32_t v5 = *v4 + (int32_t)(v3 != 0); // 0x806b567
    if (assert_failed != 0) {
        // 0x806b618
        assert_failed = 0;
        *v2 = 0;
        *v4 = 0;
        uint32_t v6 = *(int32_t *)&cache_size; // 0x806b636
        uint32_t v7 = v6 - v3; // 0x806b636
        *(int32_t *)&cache_size = v7;
        g45 = g45 - v5 + (int32_t)(v7 < v6);
        if (assert_failed == 0) {
            // 0x806b580
            assert_failed = 0;
            goto lab_0x806b58a;
        } else {
            // 0x806b64a
            assert_failed = 0;
            *(int32_t *)&cache_size = 0;
            g45 = 0;
            goto lab_0x806b58a;
        }
    } else {
        uint32_t v8 = *(int32_t *)&cache_size; // 0x806b574
        uint32_t v9 = v8 - v3; // 0x806b574
        *(int32_t *)&cache_size = v9;
        g45 = g45 - v5 + (int32_t)(v9 < v8);
        // 0x806b580
        assert_failed = 0;
        goto lab_0x806b58a;
    }
  lab_0x806b58a:;
    int32_t v10 = v1 + 12; // 0x806b58a
    int32_t * v11 = (int32_t *)v10; // 0x806b58a
    int32_t v12 = *v11; // 0x806b58a
    if (v12 != v10) {
        int32_t v13 = v12;
        int32_t * v14 = (int32_t *)v13; // 0x806b598
        int32_t * v15 = (int32_t *)(v13 + 4); // 0x806b59a
        *(int32_t *)(*v14 + 4) = *v15;
        *(int32_t *)*v15 = *v14;
        mem_mmap_free((char *)v13, *(int32_t *)(v13 + 24) + 35);
        int32_t v16 = *v11; // 0x806b5b9
        while (v16 != v10) {
            // 0x806b598
            v13 = v16;
            v14 = (int32_t *)v13;
            v15 = (int32_t *)(v13 + 4);
            *(int32_t *)(*v14 + 4) = *v15;
            *(int32_t *)*v15 = *v14;
            mem_mmap_free((char *)v13, *(int32_t *)(v13 + 24) + 35);
            v16 = *v11;
        }
    }
    // 0x806b5c0
    *(int32_t *)(v1 + 56) = id_counter;
    id_counter++;
    int32_t * v17 = (int32_t *)(v1 + 40); // 0x806b5d0
    int32_t v18 = *v17; // 0x806b5d0
    char * v19 = (char *)(v1 + 92); // 0x806b5d3
    *v19 = *v19 | 8;
    *(int32_t *)(v1 + 64) = 0;
    *(int32_t *)(v1 + 68) = 0;
    if (v18 != 0) {
        // 0x806b5e9
        mem_free((char *)v18);
    }
    int32_t * v20 = (int32_t *)(v1 + 44); // 0x806b5f1
    int32_t v21 = *v20; // 0x806b5f1
    *v17 = 0;
    if (v21 == 0) {
        // 0x806b607
        *v20 = 0;
        return;
    }
    // 0x806b5ff
    mem_free((char *)v21);
    // 0x806b607
    *v20 = 0;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/cache/cache.c
// Address range: 0x806b670 - 0x806b7dd
// Line range:    681 - 657
void delete_cache_entry(int32_t * cached) {
    int32_t v1 = (int32_t)cached;
    int32_t * v2 = (int32_t *)(v1 + 4); // 0x806b67c
    *(int32_t *)(*cached + 4) = *v2;
    *(int32_t *)*v2 = *cached;
    if (assert_failed != 0) {
        goto lab_0x806b6c7;
    } else {
        int32_t v3 = *(int32_t *)(v1 + 8); // 0x806b695
        assert_failed = v3 != 0;
        if (v3 != 0) {
            // 0x806b780
            errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/cache/cache.c";
            errline = 656;
            elinks_internal("assertion !is_object_used(cached) failed: deleting locked cache entry");
            if (assert_failed != 0) {
                goto lab_0x806b6c7;
            } else {
                goto lab_0x806b6aa;
            }
        } else {
            goto lab_0x806b6aa;
        }
    }
  lab_0x806b6c7:
    // 0x806b6c7
    delete_entry_content(cached);
    int32_t v4 = *(int32_t *)(v1 + 80); // 0x806b6cf
    if (v4 != 0) {
        // 0x806b6d6
        done_listbox_item(&cache_browser, (int32_t *)v4);
    }
    int32_t v5 = *(int32_t *)(v1 + 20); // 0x806b6e6
    if (v5 != 0) {
        // 0x806b6ed
        done_uri((int32_t *)v5);
    }
    int32_t v6 = *(int32_t *)(v1 + 24); // 0x806b6f5
    if (v6 != 0) {
        // 0x806b6fc
        done_uri((int32_t *)v6);
    }
    int32_t v7 = *(int32_t *)(v1 + 28); // 0x806b704
    if (v7 != 0) {
        // 0x806b70b
        done_uri((int32_t *)v7);
    }
    int32_t v8 = *(int32_t *)(v1 + 32); // 0x806b713
    if (v8 != 0) {
        // 0x806b71a
        mem_free((char *)v8);
    }
    int32_t v9 = *(int32_t *)(v1 + 36); // 0x806b722
    if (v9 != 0) {
        // 0x806b729
        mem_free((char *)v9);
    }
    int32_t v10 = *(int32_t *)(v1 + 40); // 0x806b731
    if (v10 != 0) {
        // 0x806b738
        mem_free((char *)v10);
    }
    int32_t v11 = *(int32_t *)(v1 + 48); // 0x806b740
    if (v11 != 0) {
        // 0x806b747
        mem_free((char *)v11);
    }
    int32_t v12 = *(int32_t *)(v1 + 52); // 0x806b74f
    if (v12 != 0) {
        // 0x806b756
        mem_free((char *)v12);
    }
    int32_t v13 = *(int32_t *)(v1 + 44); // 0x806b75e
    if (v13 != 0) {
        // 0x806b765
        mem_free((char *)v13);
    }
    // 0x806b76d
    mem_free((char *)cached);
  lab_0x806b6aa:;
    int32_t v14 = is_entry_used(cached); // 0x806b6ad
    assert_failed = v14 != 0;
    if (v14 != 0) {
        // 0x806b7b8
        errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/cache/cache.c";
        errline = 657;
        elinks_internal("assertion !is_entry_used(cached) failed: deleting loading cache entry");
    }
    goto lab_0x806b6c7;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/cache/cache.c
// Address range: 0x806b7e0 - 0x806bce8
// Line range:    755 - 853
void garbage_collection(int32_t whole) {
    int32_t v1 = get_opt_((int32_t)config_options, "document.cache.memory.size"); // 0x806b7f9
    int32_t v2 = *(int32_t *)&cache_size; // 0x806b801
    uint32_t v3 = g45; // 0x806b807
    uint32_t v4 = *(int32_t *)v1; // 0x806b80d
    uint32_t v5 = v4 / 0x80000000; // 0x806b811
    if (whole == 0) {
        if (v3 < v5) {
            // 0x806b823
            return;
        }
        if (v3 <= v5 == v2 <= v4) {
            // 0x806b823
            return;
        }
    }
    // 0x806b838
    if (assert_failed == 0) {
        // 0x806bac8
        assert_failed = (v3 | v2) != 0;
        if ((v3 || v2) == 0) {
            goto lab_0x806b8f4;
        } else {
            // 0x806baf8
            errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/cache/cache.c";
            errline = 810;
            elinks_internal("assertion old_cache_size == cache_size failed: cache_size out of sync: %ld != (actual) %ld", v2, v3);
            if (assert_failed == 0) {
                goto lab_0x806b8f4;
            } else {
                goto lab_0x806b8de;
            }
        }
    } else {
        goto lab_0x806b8de;
    }
  lab_0x806b992:;
    // 0x806b992
    int32_t v6; // 0x806b7e0
    int32_t v7 = v6; // 0x806b998
    int32_t v8; // 0x806b7e0
    int32_t v9 = v8; // 0x806b998
    int32_t v10; // 0x806b7e0
    int32_t v11 = v10; // 0x806b998
    int32_t v12 = v6; // 0x806b998
    int32_t v13 = v8; // 0x806b998
    int32_t v14 = v10; // 0x806b998
    if (whole != 0) {
        goto lab_0x806b968_2;
    } else {
        goto lab_0x806b99a;
    }
  lab_0x806b976:;
    // 0x806b976
    int32_t v15; // 0x806b7e0
    char * v16 = (char *)(v15 + 92); // 0x806b976
    *v16 = *v16 & -33;
    uint32_t v17; // 0x806b7e0
    int32_t v18 = v17; // 0x806b976
    uint32_t v19; // 0x806b7e0
    int32_t v20 = v19; // 0x806b976
    goto lab_0x806b97a;
  lab_0x806b97a:;
    int32_t v21 = *(int32_t *)(v15 + 4); // 0x806b97a
    int32_t v22 = v18; // 0x806b980
    int32_t v23 = v20; // 0x806b980
    int32_t v24 = v21; // 0x806b980
    int32_t v25 = v18; // 0x806b980
    int32_t v26 = v20; // 0x806b980
    if (v21 == (int32_t)&cache_entries) {
        // break -> 0x806bbc8
        goto lab_0x806bbc8_3;
    }
    goto lab_0x806b986;
  lab_0x806bb9e:;
    char * v40 = (char *)(v15 + 92); // 0x806bb9e
    *v40 = *v40 | 32;
    if (assert_failed != 0) {
        // 0x806bbf8
        assert_failed = 0;
        v18 = 0;
        v20 = 0;
        goto lab_0x806b97a;
    } else {
        uint32_t v41 = *(int32_t *)(v15 + 72); // 0x806bba9
        int32_t v42 = v17 - v41; // 0x806bbb1
        int32_t v43 = *(int32_t *)(v15 + 4); // 0x806bbb3
        int32_t v44 = v19 + (int32_t)(v17 < v41) - *(int32_t *)(v15 + 76); // 0x806bbb6
        v22 = v42;
        v23 = v44;
        v24 = v43;
        v25 = v42;
        v26 = v44;
        if (v43 == (int32_t)&cache_entries) {
            // break -> 0x806bbc8
            goto lab_0x806bbc8_3;
        }
        goto lab_0x806b986;
    }
  lab_0x806b986:;
    int32_t v27 = v24;
    int32_t v28 = v23;
    int32_t v29 = v22;
    uint32_t v30; // 0x806b93e
    uint32_t v31; // 0x806b934
    if (v28 <= v31) {
        // 0x806b98a
        v6 = v29;
        v8 = v28;
        v10 = v27;
        if (v29 > v30 != v28 >= v31) {
            goto lab_0x806b992;
        }
    }
    int32_t v32 = v29; // 0x806b7e0
    int32_t v33 = v28; // 0x806b7e0
    int32_t v34 = v27; // 0x806b7e0
    goto lab_0x806b968;
  lab_0x806bb91:
    // 0x806bb91
    assert_failed = 1;
    errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/cache/cache.c";
    errline = 840;
    int32_t * v36; // 0x806b7e0
    int32_t v38 = *v36; // 0x806bc46
    int32_t v39 = *(int32_t *)&cache_size; // 0x806bc57
    elinks_internal("assertion new_cache_size >= cached->data_size failed: cache_size (%ld) underflow: subtracting %ld from %ld", v39, g45, v38);
    goto lab_0x806bb9e;
  lab_0x806b8de:
    // 0x806b8de
    assert_failed = 0;
    *(int32_t *)&cache_size = 0;
    g45 = 0;
    goto lab_0x806b8f4;
  lab_0x806b8f4:
    if (v3 <= v5) {
        if (whole == 0 && v2 > v4 != v3 >= v5) {
            // 0x806b823
            return;
        }
    }
    // 0x806b918
    v31 = 90 * v5 + v4 / 0x2d82d83;
    v30 = __udivdi3(0, v31, 100, 0);
    v25 = v2;
    v26 = v3;
    if (g28 == &cache_entries) {
        goto lab_0x806bbc8_3;
    } else {
        int32_t v45 = (int32_t)g28; // 0x806b943
        v7 = v2;
        v9 = v3;
        v11 = v45;
        if (v31 < v3) {
            goto lab_0x806b968_2;
        } else {
            // 0x806b95b
            v7 = v2;
            v9 = v3;
            v11 = v45;
            v6 = v2;
            v8 = v3;
            v10 = v45;
            if (v31 > v3 || v30 >= v2) {
                goto lab_0x806b992;
            } else {
                goto lab_0x806b968_2;
            }
        }
    }
  lab_0x806bbc8_3:
    // 0x806bbc8
    if (assert_failed != 0) {
        goto lab_0x806bcd0;
    } else {
        // 0x806bbd5
        assert_failed = (v26 | v25) != 0;
        v12 = v25;
        v13 = v26;
        v14 = &cache_entries;
        if ((v26 || v25) != 0) {
            int32_t v46 = *(int32_t *)&cache_size; // 0x806bc7e
            errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/cache/cache.c";
            errline = 852;
            elinks_internal("assertion new_cache_size == 0 failed: cache_size (%ld) overflow: %ld", v46, g45);
            v12 = v25;
            v13 = v26;
            v14 = &cache_entries;
            if (assert_failed == 0) {
                goto lab_0x806b99a;
            } else {
                goto lab_0x806bcd0;
            }
        } else {
            goto lab_0x806b99a;
        }
    }
  lab_0x806bcd0:
    // 0x806bcd0
    assert_failed = 0;
    v12 = 0;
    v13 = 0;
    v14 = &cache_entries;
    goto lab_0x806b99a;
  lab_0x806b968_2:
    // 0x806b968
    v32 = v7;
    v33 = v9;
    v34 = v11;
    while (true) {
      lab_0x806b968:
        // 0x806b968
        v15 = v34;
        v19 = v33;
        v17 = v32;
        if (*(int32_t *)(v15 + 8) == 0) {
            // 0x806bb68
            if (is_entry_used((int32_t *)v15) != 0) {
                goto lab_0x806b976;
            } else {
                // 0x806bb7e
                if (assert_failed != 0) {
                    goto lab_0x806bb9e;
                } else {
                    uint32_t v35 = *(int32_t *)(v15 + 76); // 0x806bb87
                    if (v35 > v19) {
                        // 0x806bb87
                        v36 = (int32_t *)(v15 + 72);
                        goto lab_0x806bb91;
                    } else {
                        if (v35 < v19) {
                            // 0x806bc1b
                            assert_failed = 0;
                            goto lab_0x806bb9e;
                        } else {
                            int32_t * v37 = (int32_t *)(v15 + 72);
                            v36 = v37;
                            if (*v37 > v17) {
                                goto lab_0x806bb91;
                            } else {
                                // 0x806bc1b
                                assert_failed = 0;
                                goto lab_0x806bb9e;
                            }
                        }
                    }
                }
            }
        } else {
            goto lab_0x806b976;
        }
    }
    goto lab_0x806bbc8_3;
  lab_0x806b99a:;
    int32_t v47 = *(int32_t *)v14; // 0x806b99a
    if (v47 == (int32_t)&cache_entries) {
        // 0x806b823
        return;
    }
    int32_t v48 = v47; // 0x806b9ac
    int32_t v49; // 0x806b7e0
    int32_t v50; // 0x806b7e0
    int32_t v51; // 0x806b7e0
    if (whole != 0) {
        goto lab_0x806b9fc;
    } else {
        uint32_t v52 = *(int32_t *)(v47 + 72) + v12; // 0x806b9bc
        uint32_t v53 = *(int32_t *)(v47 + 76) + v13 + (int32_t)(v52 < v12); // 0x806b9bf
        int32_t v54 = v12; // 0x806b9c4
        int32_t v55 = v13; // 0x806b9c4
        char * v56; // 0x806b9cd
        if (v31 >= v53) {
            // 0x806b9c6
            v54 = v12;
            v55 = v13;
            if (v52 > v30 != v31 <= v53) {
                // 0x806b9cd
                v56 = (char *)(v47 + 92);
                *v56 = *v56 & -33;
                v54 = v52;
                v55 = v53;
            }
        }
        int32_t v57 = *(int32_t *)v47; // 0x806b9d5
        while (v57 != (int32_t)&cache_entries) {
            int32_t v58 = v55;
            int32_t v59 = v54;
            int32_t v60 = v57;
            v52 = *(int32_t *)(v60 + 72) + v59;
            v53 = *(int32_t *)(v60 + 76) + v58 + (int32_t)(v52 < v59);
            v54 = v59;
            v55 = v58;
            if (v31 >= v53) {
                // 0x806b9c6
                v54 = v59;
                v55 = v58;
                if (v52 > v30 != v31 <= v53) {
                    // 0x806b9cd
                    v56 = (char *)(v60 + 92);
                    *v56 = *v56 & -33;
                    v54 = v52;
                    v55 = v53;
                }
            }
            // 0x806b9d5
            v57 = *(int32_t *)v60;
        }
        int32_t v61 = *(int32_t *)v47; // 0x806b9e1
        int32_t v62 = *(int32_t *)(v61 + 4); // 0x806b9e3
        v50 = v61;
        v49 = v62;
        v51 = v61;
        if ((*(char *)(v62 + 92) & 32) != 0) {
            goto lab_0x806ba07;
        } else {
            goto lab_0x806b9f0;
        }
    }
  lab_0x806b9fc:;
    int32_t v63 = *(int32_t *)v48; // 0x806b9fc
    int32_t v64 = *(int32_t *)(v63 + 4); // 0x806b9fe
    v50 = v63;
    v49 = v64;
    v51 = v63;
    if ((*(char *)(v64 + 92) & 32) == 0) {
        goto lab_0x806b9f0;
    } else {
        goto lab_0x806ba07;
    }
  lab_0x806b9f0:
    // 0x806b9f0
    v48 = v50;
    if (v50 == (int32_t)&cache_entries) {
        // 0x806b823
        return;
    }
    goto lab_0x806b9fc;
  lab_0x806ba07:
    // 0x806ba07
    delete_cache_entry((int32_t *)v49);
    v50 = v51;
    goto lab_0x806b9f0;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/cache/cache.c
// Address range: 0x806be30 - 0x806c1ed
// Line range:    567 - 584
void truncate_entry(int32_t * cached, int64_t offset, int32_t final) {
    // 0x806be30
    int32_t v1; // 0x806be30
    uint32_t v2 = v1;
    int32_t v3 = *(int32_t *)(v1 + 68); // 0x806be41
    if (v3 < v1) {
        goto lab_0x806be5c;
    } else {
        // 0x806be46
        if (v3 > v1) {
            goto lab_0x806bea8;
        } else {
            // 0x806c0d0
            if (*(int32_t *)(v1 + 64) > v2) {
                goto lab_0x806bea8;
            } else {
                goto lab_0x806be5c;
            }
        }
    }
  lab_0x806c023:
    // 0x806c023
    assert_failed = 0;
    int32_t * v4; // 0x806c003
    *v4 = 0;
    int32_t * v5; // 0x806c006
    *v5 = 0;
    uint32_t v6 = *(int32_t *)&cache_size; // 0x806c044
    int32_t v7; // 0x806bff2
    uint32_t v8 = v6 - v7; // 0x806c044
    *(int32_t *)&cache_size = v8;
    int32_t v9; // 0x806bffa
    g45 = g45 - v9 + (int32_t)(v8 < v6);
    if (assert_failed == 0) {
        // 0x806bfb0
        assert_failed = 0;
        goto lab_0x806bfba;
    } else {
        // 0x806c058
        assert_failed = 0;
        *(int32_t *)&cache_size = 0;
        g45 = 0;
        goto lab_0x806bfba;
    }
  lab_0x806bfa4:;
    uint32_t v10 = *(int32_t *)&cache_size; // 0x806bfa4
    uint32_t v11 = v10 - v7; // 0x806bfa4
    *(int32_t *)&cache_size = v11;
    g45 = g45 - v9 + (int32_t)(v11 < v10);
    // 0x806bfb0
    assert_failed = 0;
    goto lab_0x806bfba;
  lab_0x806bfba:;
    // 0x806bfba
    int32_t v12; // 0x806be30
    int32_t * v13 = (int32_t *)(v12 + 4); // 0x806bfbc
    int32_t * v14; // 0x806bfea
    *(int32_t *)(*v14 + 4) = *v13;
    *(int32_t *)*v13 = *v14;
    mem_mmap_free((char *)v12, *(int32_t *)(v12 + 24) + 35);
    int32_t v15; // 0x806bfea
    int32_t v16 = v15; // 0x806bfe1
    int32_t v17; // 0x806be5c
    if (v15 == v17) {
        // break -> 0x806bea8
        goto lab_0x806bea8;
    }
    goto lab_0x806bfea;
  lab_0x806be5c:
    // 0x806be5c
    v17 = v1 + 12;
    int32_t v20 = *(int32_t *)v17; // 0x806be5c
    if (v20 == v17) {
        // 0x806bea8
        return;
    }
    int32_t v21 = v20;
    uint32_t v22 = *(int32_t *)(v21 + 8); // 0x806be76
    int32_t * v23 = (int32_t *)(v21 + 20);
    int32_t v24; // 0x806be80
    if (assert_failed == 0) {
        // 0x806be80
        v24 = *v23;
        assert_failed = v24 < 0;
        if (v24 < 0) {
            // 0x806c120
            errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/cache/cache.c";
            errline = 580;
            elinks_internal("assertion f->length >= 0 failed!");
        }
    }
    uint32_t v25 = v2 - v22; // 0x806be76
    int32_t v26 = v1 - *(int32_t *)(v21 + 12) + (int32_t)(v2 < v22); // 0x806be79
    int32_t v27 = *v23; // 0x806be94
    int32_t * v28 = (int32_t *)(v21 + 16);
    uint32_t v29 = *v28; // 0x806be97
    while (v26 >= v27) {
        if (v26 <= v27 && v25 < v29) {
            // break -> 0x806bebc
            break;
        }
        int32_t v30 = *(int32_t *)v21; // 0x806bea0
        if (v30 == v17) {
            // 0x806bea8
            return;
        }
        v21 = v30;
        v22 = *(int32_t *)(v21 + 8);
        v23 = (int32_t *)(v21 + 20);
        if (assert_failed == 0) {
            // 0x806be80
            v24 = *v23;
            assert_failed = v24 < 0;
            if (v24 < 0) {
                // 0x806c120
                errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/cache/cache.c";
                errline = 580;
                elinks_internal("assertion f->length >= 0 failed!");
            }
        }
        // 0x806be94
        v25 = v2 - v22;
        v26 = v1 - *(int32_t *)(v21 + 12) + (int32_t)(v2 < v22);
        v27 = *v23;
        v28 = (int32_t *)(v21 + 16);
        v29 = *v28;
    }
    int32_t v31 = v21; // 0x806bece
    uint32_t v32; // 0x806bee0
    int32_t v33; // 0x806bee3
    int32_t * v34; // 0x806beec
    int32_t * v35; // 0x806beef
    if (v26 < 0 || (v26 || v25) == 0) {
        goto lab_0x806bf7b;
    } else {
        // 0x806beda
        v32 = v25 - v29;
        v33 = v26 - v27 + (int32_t)(v25 < v29);
        v34 = (int32_t *)(v1 + 72);
        uint32_t v36 = *v34 + v32; // 0x806beec
        v35 = (int32_t *)(v1 + 76);
        int32_t v37 = *v35 + v33 + (int32_t)(v36 < v32); // 0x806beef
        *v34 = v36;
        *v35 = v37;
        if (assert_failed == 0) {
            // 0x806c0e8
            assert_failed = v37 < 0;
            if (v37 < 0) {
                // 0x806c193
                errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/cache/cache.c";
                errline = 261;
                elinks_internal("assertion cached->data_size >= 0 failed: cache entry data_size underflow: %ld", *v34);
                if (assert_failed == 0) {
                    goto lab_0x806c0fc;
                } else {
                    goto lab_0x806bf0c;
                }
            } else {
                goto lab_0x806c0fc;
            }
        } else {
            goto lab_0x806bf0c;
        }
    }
  lab_0x806bf7b:
    // 0x806bf7b
    if (v31 == v17) {
        // 0x806bea8
        return;
    }
    // 0x806bfea
    v4 = (int32_t *)(v1 + 72);
    v5 = (int32_t *)(v1 + 76);
    v16 = v31;
    while (true) {
      lab_0x806bfea:
        // 0x806bfea
        v12 = v16;
        v14 = (int32_t *)v12;
        v15 = *v14;
        v7 = *(int32_t *)(v12 + 16);
        v9 = *(int32_t *)(v12 + 20) + (int32_t)(v7 != 0);
        uint32_t v18 = *v4 - v7; // 0x806c003
        int32_t v19 = *v5 - v9 + (int32_t)(v18 < -v7); // 0x806c006
        *v4 = v18;
        *v5 = v19;
        if (assert_failed == 0) {
            // 0x806bf90
            assert_failed = v19 < 0;
            if (v19 < 0) {
                // 0x806c080
                errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/cache/cache.c";
                errline = 261;
                elinks_internal("assertion cached->data_size >= 0 failed: cache entry data_size underflow: %ld", *v4);
                if (assert_failed == 0) {
                    goto lab_0x806bfa4;
                } else {
                    goto lab_0x806c023;
                }
            } else {
                goto lab_0x806bfa4;
            }
        } else {
            goto lab_0x806c023;
        }
    }
  lab_0x806bea8:;
    char * v38 = (char *)(v1 + 92); // 0x806be52
    *v38 = *v38 | 8;
    goto lab_0x806be5c;
  lab_0x806bf0c:
    // 0x806bf0c
    assert_failed = 0;
    *v34 = 0;
    *v35 = 0;
    uint32_t v39 = *(int32_t *)&cache_size; // 0x806bf2a
    uint32_t v40 = v39 + v32; // 0x806bf2a
    *(int32_t *)&cache_size = v40;
    g45 = g45 + v33 + (int32_t)(v40 < v39);
    if (assert_failed == 0) {
        // 0x806c10e
        assert_failed = 0;
        goto lab_0x806bf62;
    } else {
        // 0x806bf44
        assert_failed = 0;
        *(int32_t *)&cache_size = 0;
        g45 = 0;
        goto lab_0x806bf62;
    }
  lab_0x806c0fc:;
    uint32_t v41 = *(int32_t *)&cache_size; // 0x806c102
    uint32_t v42 = v41 + v32; // 0x806c102
    *(int32_t *)&cache_size = v42;
    g45 = g45 + v33 + (int32_t)(v42 < v41);
    // 0x806c10e
    assert_failed = 0;
    goto lab_0x806bf62;
  lab_0x806bf62:
    // 0x806bf62
    *v28 = v25;
    *v23 = v26;
    if (cached != NULL) {
        int32_t v43 = *(int32_t *)(v21 + 24); // 0x806c15a
        char * v44 = mem_mmap_realloc((char *)v21, v43 + 35, v25 + 35); // 0x806c167
        if (v44 == NULL) {
            // 0x806bf79
            v31 = *(int32_t *)v21;
            goto lab_0x806bf7b;
        } else {
            int32_t v45 = (int32_t)v44; // 0x806c167
            *(int32_t *)(*(int32_t *)v44 + 4) = v45;
            *(int32_t *)*(int32_t *)(v45 + 4) = v45;
            *(int32_t *)(v45 + 24) = *(int32_t *)(v45 + 16);
            *(int32_t *)(v45 + 28) = *(int32_t *)(v45 + 20);
            v31 = *(int32_t *)v44;
            goto lab_0x806bf7b;
        }
    } else {
        // 0x806bf79
        v31 = *(int32_t *)v21;
        goto lab_0x806bf7b;
    }
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/cache/cache.c
// Address range: 0x806c1f0 - 0x806c22b
// Line range:    690 - 699
void normalize_cache_entry(int32_t * cached, int64_t truncate_length) {
    // 0x806c1f0
    int32_t v1; // 0x806c1f0
    if ((uint32_t)v1 >= 0) {
        int32_t v2 = (int32_t)cached;
        truncate_entry((int32_t *)1, (int64_t)&g83, (int32_t)&g83);
        char * v3 = (char *)(v2 + 92); // 0x806c212
        *v3 = *v3 & -11;
        *(int32_t *)(v2 + 60) = time(NULL);
    }
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/config/home.c
// Address range: 0x8072350 - 0x8072369
// Line range:    166 - 169
void done_home(void) {
    // 0x8072350
    if (elinks_home != 0) {
        // 0x807235f
        mem_free((char *)elinks_home);
    }
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/config/options.c
// Address range: 0x8073950 - 0x8073ade
// Line range:    588 - 733
void delete_option_do(int32_t * option_elinks, int32_t recursive) {
    // 0x8073950
    int32_t v1; // 0x8073950
    if (v1 != 0) {
        int32_t * v2 = (int32_t *)(v1 + 4); // 0x8073963
        int32_t v3 = *v2; // 0x8073963
        *(int32_t *)v3 = v3;
        *(int32_t *)v1 = 0;
        *v2 = 0;
    }
    if (v1 == -1) {
        // 0x8073a70
        errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/config/options.c";
        errline = 596;
        elinks_error("Orphaned option %s", (char *)*(int32_t *)(v1 + 12));
    }
    int32_t * v4 = (int32_t *)(v1 + 20); // 0x8073986
    int32_t v5 = *v4; // 0x8073986
    int32_t v6 = v5; // 0x8073a25
    int32_t * v7; // 0x8073950
    int32_t * v8; // 0x8073950
    int32_t v9; // 0x8073950
    int32_t * v10; // 0x8073950
    switch (v5) {
        case 9: {
            // 0x80739f8
            v10 = (int32_t *)(v1 + 32);
            int32_t v11 = *v10; // 0x80739f8
            if (v11 == 0) {
                goto lab_0x80739a0;
            } else {
                int32_t * v12 = (int32_t *)v11;
                if (v11 == *v12) {
                    // 0x8073a5b
                    mem_free((char *)v11);
                    goto lab_0x80739a0;
                } else {
                    // 0x8073a05
                    v8 = v12;
                    v9 = v11;
                    if (v1 != 0) {
                        goto lab_0x8073a18;
                    } else {
                        // 0x8073a09
                        v8 = v12;
                        v9 = v11;
                        if ((*(char *)(v1 + 16) & 2) == 0) {
                            // 0x8073aa0
                            errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/config/options.c";
                            errline = 605;
                            int32_t v13 = *(int32_t *)(v1 + 12); // 0x8073ab9
                            elinks_error("Orphaned unregistered option in subtree %s!", (char *)v13);
                            int32_t v14 = *v10; // 0x8073acc
                            int32_t * v15 = (int32_t *)v14;
                            v8 = v15;
                            v9 = v14;
                            if (v14 == *v15) {
                                goto lab_0x8073a25;
                            } else {
                                goto lab_0x8073a18;
                            }
                        } else {
                            goto lab_0x8073a18;
                        }
                    }
                }
            }
        }
        case 3: {
            // 0x8073986
            v7 = (int32_t *)(v1 + 32);
            goto lab_0x8073a31;
        }
        default: {
            goto lab_0x8073997;
        }
    }
  lab_0x8073997:
    // 0x8073997
    if (v6 == 9) {
        int32_t v16 = *(int32_t *)(v1 + 32); // 0x8073a50
        if (v16 == 0) {
            goto lab_0x80739a0;
        } else {
            // 0x8073a5b
            mem_free((char *)v16);
            goto lab_0x80739a0;
        }
    } else {
        goto lab_0x80739a0;
    }
  lab_0x80739a0:;
    int32_t v17 = *(int32_t *)(v1 + 52); // 0x80739a0
    if (v17 != 0) {
        // 0x80739a7
        done_listbox_item(&option_browser, (int32_t *)v17);
    }
    // 0x80739b7
    if ((*(int32_t *)(v1 + 16) & 32) == 0) {
        // 0x80739e0
        if (*(int32_t *)(v1 + 40) == 0) {
            // 0x80739e7
            __asm_rep_stosd_memset((char *)v1, 0, 14);
        }
        // 0x80739d6
        return;
    }
    int32_t v18 = *(int32_t *)(v1 + 12); // 0x80739bf
    if (v18 != 0) {
        // 0x80739c6
        mem_free((char *)v18);
    }
    // 0x80739ce
    mem_free((char *)v1);
  lab_0x8073a31:;
    int32_t v19 = *v7; // 0x8073a31
    if (v19 != 0) {
        // 0x8073a3c
        mem_free((char *)v19);
    }
    goto lab_0x80739a0;
  lab_0x8073a18:
    // 0x8073a18
    while (true) {
        // 0x8073a18
        delete_option_do(&g83, (int32_t)&g83);
        if (*v8 == v9) {
            // break -> 0x8073a25
            break;
        }
    }
    goto lab_0x8073a25;
  lab_0x8073a25:
    // 0x8073a25
    v6 = *v4;
    v7 = v10;
    if (v6 != 3) {
        goto lab_0x8073997;
    } else {
        goto lab_0x8073a31;
    }
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/config/options.c
// Address range: 0x8073ae0 - 0x8073b30
// Line range:    1175 - 1186
void unregister_options(int32_t * info, int32_t * tree) {
    int32_t v1 = (int32_t)info;
    if (*(int32_t *)(v1 + 56) == 0) {
        // 0x8073b2c
        return;
    }
    int32_t v2 = v1; // 0x8073b05
    int32_t v3 = 0; // 0x8073b05
    if (*(int32_t *)(v1 + 116) != 0) {
        v3++;
        while (*(int32_t *)(v2 + 176) != 0) {
            // 0x8073af8
            v2 += 60;
            v3++;
        }
        // 0x8073b07
        if (v3 == -1) {
            // 0x8073b2c
            return;
        }
    }
    int32_t v4 = v3;
    delete_option_do(&g83, (int32_t)&g83);
    while (v4 != 0) {
        // 0x8073b18
        v4--;
        delete_option_do(&g83, (int32_t)&g83);
    }
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/config/options.c
// Address range: 0x8073b30 - 0x8073b8d
// Line range:    738 - 744
void done_options(void) {
    // 0x8073b30
    unregister_options(&config_options_info, config_options);
    unregister_options(&cmdline_options_info, cmdline_options);
    *(int32_t *)((int32_t)config_options + 52) = 0;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/config/options.c
// Address range: 0x8074170 - 0x8074269
// Line range:    641 - 656
int32_t * copy_option(int32_t * template) {
    char * v1 = mem_calloc(1, 56); // 0x807418a
    if (v1 == NULL) {
        // 0x8074243
        return (int32_t *)v1;
    }
    int32_t v2 = (int32_t)template;
    int32_t v3 = *(int32_t *)(v2 + 12); // 0x8074199
    int32_t v4 = 0; // 0x80741a0
    if (v3 != 0) {
        // 0x80741a2
        v4 = (int32_t)stracpy((char *)v3);
    }
    int32_t v5 = (int32_t)v1; // 0x807418a
    *(int32_t *)(v5 + 12) = v4;
    *(int32_t *)(v5 + 16) = *(int32_t *)(v2 + 16) | 32;
    int32_t * v6 = (int32_t *)(v2 + 20); // 0x80741b6
    int32_t * v7 = (int32_t *)(v5 + 20); // 0x80741b9
    *v7 = *v6;
    *(int32_t *)(v5 + 24) = *(int32_t *)(v2 + 24);
    *(int32_t *)(v5 + 28) = *(int32_t *)(v2 + 28);
    *(int32_t *)(v5 + 40) = *(int32_t *)(v2 + 40);
    *(int32_t *)(v5 + 36) = *(int32_t *)(v2 + 36);
    *(int32_t *)(v5 + 48) = *(int32_t *)(v2 + 48);
    char * v8 = mem_calloc(1, 32); // 0x80741e9
    if (v8 == NULL) {
        // 0x8074260
        *(int32_t *)(v5 + 52) = 0;
    } else {
        int32_t v9 = (int32_t)v8; // 0x80741e9
        int32_t v10 = v9 + 8; // 0x80741f2
        char * v11 = (char *)(v9 + 24); // 0x80741f5
        *v11 = *v11 | 2;
        *(int32_t *)(v9 + 12) = v10;
        *(int32_t *)v10 = v10;
        *(int32_t *)(v9 + 28) = v5;
        int32_t * v12 = (int32_t *)(v9 + 16); // 0x807420b
        *v12 = (int32_t)(*v7 == 9);
        int32_t * v13 = (int32_t *)(v5 + 52); // 0x807420e
        *v13 = v9;
        int32_t * v14 = (int32_t *)(v2 + 52); // 0x8074211
        int32_t v15 = *v14; // 0x8074211
        if (v15 != 0) {
            // 0x8074218
            *v12 = *(int32_t *)(v15 + 16);
            *(int32_t *)(*v13 + 20) = *(int32_t *)(*v14 + 20);
        }
    }
    // 0x807422a
    if (*(int32_t *)(32 * *v6 + (int32_t)&g1) != 0) {
        // 0x8074243
        return (int32_t *)v1;
    }
    // 0x8074250
    *(int32_t *)(v5 + 32) = *(int32_t *)(v2 + 32);
    return (int32_t *)v1;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/config/options.c
// Address range: 0x8074270 - 0x8074457
// Line range:    169 - 235
int32_t * get_opt_rec(int32_t * tree, char * name_) {
    char * str = stracpy(name_); // 0x8074281
    if (str == NULL) {
        // 0x80743b3
        return NULL;
    }
    char * found_char_pos = strrchr(str, 46); // 0x807429b
    int32_t v1 = (int32_t)str; // 0x80742a8
    char * str3 = str; // 0x80742a8
    int32_t v2 = (int32_t)tree; // 0x80742a8
    if (found_char_pos != NULL) {
        // 0x80742aa
        *found_char_pos = 0;
        int32_t * v3 = get_opt_rec(tree, str); // 0x80742b7
        if (v3 == NULL) {
            // 0x80743c0
            mem_free(str);
            return NULL;
        }
        // 0x80742c7
        v2 = (int32_t)v3;
        if (*(int32_t *)(v2 + 20) != 9 || *(char *)(v2 + 16) % 2 != 0) {
            // 0x80743c0
            mem_free(str);
            return NULL;
        }
        // 0x80742db
        *found_char_pos = 46;
        v1 = (int32_t)found_char_pos + 1;
        str3 = (char *)v1;
    }
    int32_t v4 = *(int32_t *)(v2 + 32); // 0x80742ea
    int32_t v5 = *(int32_t *)v4; // 0x80742ed
    if (v5 != v4) {
        int32_t str2 = *(int32_t *)(v5 + 12); // 0x8074300
        if (str2 != 0) {
            // 0x8074307
            if (strcmp((char *)str2, str3) == 0) {
                // 0x80743d8
                mem_free(str);
                return (int32_t *)v5;
            }
        }
        int32_t v6 = *(int32_t *)v5; // 0x807431b
        while (v6 != v4) {
            int32_t v7 = v6;
            str2 = *(int32_t *)(v7 + 12);
            if (str2 != 0) {
                // 0x8074307
                if (strcmp((char *)str2, str3) == 0) {
                    // 0x80743d8
                    mem_free(str);
                    return (int32_t *)v7;
                }
            }
            // 0x807431b
            v6 = *(int32_t *)v7;
        }
    }
    // 0x8074324
    if ((*(char *)(v2 + 16) & 2) == 0 || no_autocreate != 0) {
        // 0x80743c0
        mem_free(str);
        return NULL;
    }
    int32_t * v8 = get_opt_rec((int32_t *)v2, "_template_"); // 0x8074349
    if (assert_failed != 0) {
        // 0x8074439
        assert_failed = 0;
        mem_free(str);
        return NULL;
    }
    // 0x807435c
    assert_failed = v8 == NULL;
    if (v8 == NULL) {
        // 0x80743ed
        errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/config/options.c";
        errline = 209;
        elinks_internal("assertion template != NULL failed: Requested %s should be autocreated but %.*s._template_ is missing!", name_, (int32_t)found_char_pos - (int32_t)name_, name_);
        if (assert_failed != 0) {
            // 0x8074439
            assert_failed = 0;
            mem_free(str);
            return NULL;
        }
    }
    int32_t * result = copy_option(v8); // 0x8074374
    if (result == NULL) {
        // 0x80743ab
        mem_free(str);
        // 0x80743b3
        return result;
    }
    int32_t * v9 = (int32_t *)((int32_t)result + 12); // 0x807437f
    int32_t v10 = *v9; // 0x807437f
    if (v10 != 0) {
        // 0x8074386
        mem_free((char *)v10);
    }
    // 0x807438e
    *v9 = (int32_t)stracpy((char *)v1);
    add_opt_rec(&g83, (char *)&g83, &g83);
    // 0x80743ab
    mem_free(str);
    // 0x80743b3
    return result;
}

// Address range: 0x8074670 - 0x807468d
int32_t get_opt_(int32_t a1, char * a2) {
    // 0x8074670
    return (int32_t)get_opt_rec((int32_t *)a1, a2) + 32;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/config/options.c
// Address range: 0x8074690 - 0x8074c74
// Line range:    415 - 382
void add_opt_rec(int32_t * tree, char * path, int32_t * option_elinks) {
    // 0x8074690
    int32_t v1; // 0x8074690
    char v2 = v1;
    int32_t v3; // 0x8074690
    int32_t * v4; // 0x8074868
    if (assert_failed != 0) {
        goto lab_0x80746e0;
    } else {
        if (v1 == 0 || v1 == 0 || v1 == 0) {
            // 0x80746b0
            assert_failed = 1;
            errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/config/options.c";
            errline = 419;
            elinks_internal("assertion path && option && tree failed!");
            goto lab_0x80746e0;
        } else {
            // 0x8074848
            assert_failed = 0;
            if (v2 == 0) {
                goto lab_0x80746e9;
            } else {
                // 0x807485b
                v4 = get_opt_rec((int32_t *)v1, (char *)v1);
                v3 = (int32_t)v4;
                goto lab_0x80746e9;
            }
        }
    }
  lab_0x80749bc:
    // 0x80749bc
    if (assert_failed != 0) {
        // 0x80747d5
        update_hierbox_browser(&option_browser);
        // 0x80747e1
        return;
    }
    // 0x80749ca
    int32_t v5; // 0x8074690
    int32_t v6; // 0x8074887
    assert_failed = v5 == v6;
    if (v5 == v6) {
        // 0x8074b98
        errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/config/options.c";
        errline = 408;
        elinks_internal("assertion pos != (struct option *) cat failed!");
        if (assert_failed != 0) {
            // 0x80747d5
            update_hierbox_browser(&option_browser);
            // 0x80747e1
            return;
        }
    }
    // 0x80749e3
    int32_t v7; // 0x8074690
    int32_t v8; // 0x8074890
    assert_failed = v8 == v7;
    if (v8 == v7) {
        // 0x80749fb
        errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/config/options.c";
        errline = 409;
        elinks_internal("assertion bpos != (struct listbox_item *) bcat failed!");
    }
    // 0x80747d5
    update_hierbox_browser(&option_browser);
  lab_0x80746e0:
    if (v2 != 0) {
        // 0x807485b
        v4 = get_opt_rec((int32_t *)v1, (char *)v1);
        v3 = (int32_t)v4;
        goto lab_0x80746e9;
    } else {
        goto lab_0x80746e9;
    }
  lab_0x80746e9:
    // 0x80746e9
    if (assert_failed == 0) {
        // 0x80746f3
        assert_failed = v3 == 0;
        if (v3 == 0) {
            // 0x8074a68
            errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/config/options.c";
            errline = 422;
            elinks_internal("assertion tree != NULL failed: Missing option tree for '%s'", (char *)v1);
        }
    }
    int32_t * v9 = (int32_t *)(v3 + 32); // 0x807470d
    if (*v9 == 0) {
        // 0x80747e1
        return;
    }
    int32_t * v10 = (int32_t *)(v1 + 52); // 0x8074718
    int32_t v11 = *v10; // 0x8074718
    bool v12; // 0x8074690
    if (v11 != 0) {
        int32_t v13 = *(int32_t *)(v1 + 12); // 0x807471f
        if (v13 != 0) {
            int32_t v14 = v12 ? -1 : 1; // 0x8074730
            int32_t v15 = (int32_t)"_template_"; // 0x8074690
            int32_t v16 = v13; // 0x8074690
            int32_t v17 = 11; // 0x8074730
            while (*(char *)v16 == *(char *)v15) {
                // 0x8074726
                v17--;
                v15 += v14;
                v16 += v14;
                if (v17 == 0) {
                    int32_t v18 = *(int32_t *)((int32_t)get_opt_rec(config_options, "config.show_template") + 32); // 0x8074a3b
                    char * v19 = (char *)(v11 + 24); // 0x8074a3e
                    *v19 = 2 * (char)v18 & 2 | *v19 & -3;
                    if ((*(char *)(v3 + 16) & 2) == 0) {
                        goto lab_0x8074745;
                    } else {
                        goto lab_0x80747f0;
                    }
                }
            }
        }
    }
    // 0x8074738
    if ((*(char *)(v3 + 16) & 2) != 0) {
        goto lab_0x80747f0;
    } else {
        goto lab_0x8074745;
    }
  lab_0x80747f0:;
    int32_t * v20 = (int32_t *)(v1 + 36); // 0x80747f0
    if (*v20 == 0) {
        int32_t * v21 = get_opt_rec((int32_t *)v3, "_template_"); // 0x8074806
        if (assert_failed == 0) {
            // 0x8074815
            assert_failed = v21 == NULL;
            if (v21 == NULL) {
                // 0x8074c39
                errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/config/options.c";
                errline = 433;
                elinks_internal("assertion template failed!");
            }
        }
        // 0x807482a
        *v20 = *(int32_t *)((int32_t)v21 + 36);
    }
    goto lab_0x8074745;
  lab_0x8074745:
    // 0x8074745
    *(int32_t *)(v1 + 44) = v3;
    int32_t * v22 = (int32_t *)(v3 + 52); // 0x807474b
    int32_t v23 = *v22; // 0x807474b
    bool v24; // 0x8074690
    int32_t v25; // 0x8074690
    if (v23 == 0) {
        goto lab_0x8074878;
    } else {
        int32_t v26 = *v10; // 0x8074756
        if (v26 == 0) {
            goto lab_0x8074878;
        } else {
            // 0x8074761
            v25 = 1;
            if (*(int32_t *)v23 != 0) {
                // 0x807476c
                *(int32_t *)(v26 + 20) = *(int32_t *)(v23 + 20) + 1;
            }
            // 0x8074775
            if ((*(char *)(v3 + 16) & 64) != 0) {
                goto lab_0x8074887;
            } else {
                // 0x8074775
                v24 = v25 == 0;
                goto lab_0x8074782;
            }
        }
    }
  lab_0x8074878:
    // 0x8074878
    v25 = 0;
    v24 = true;
    if ((*(char *)(v3 + 16) & 64) == 0) {
        goto lab_0x8074782;
    } else {
        goto lab_0x8074887;
    }
  lab_0x8074782:
    // 0x8074782
    *(int32_t *)v1 = *(int32_t *)*(int32_t *)(*v9 + 4);
    *(int32_t *)(v1 + 4) = *(int32_t *)(*v9 + 4);
    if (v24) {
        // 0x80747d5
        update_hierbox_browser(&option_browser);
        // 0x80747e1
        return;
    }
    // 0x80747a9
    *(int32_t *)*v10 = *(int32_t *)*(int32_t *)(*v22 + 12);
    *(int32_t *)(*v10 + 4) = *(int32_t *)(*v22 + 12);
    int32_t * v27 = (int32_t *)(*v22 + 12); // 0x80747c5
    goto lab_0x80747c8;
  lab_0x8074887:
    // 0x8074887
    v6 = *v9;
    int32_t v34 = *v22; // 0x807488d
    v8 = v34 + 8;
    int32_t v37 = *(int32_t *)v6; // 0x8074896
    if (v6 == v37) {
        // 0x8074bd0
        *(int32_t *)v1 = v6;
        *(int32_t *)(v1 + 4) = v6;
        if (v25 != 0) {
            int32_t * v59 = (int32_t *)v8; // 0x8074be7
            *(int32_t *)*v10 = *v59;
            *(int32_t *)(*v10 + 4) = v8;
            *v59 = *v10;
            int32_t v60 = *v10; // 0x8074bf8
            *(int32_t *)(*(int32_t *)v60 + 4) = v60;
        }
        // 0x80747d5
        update_hierbox_browser(&option_browser);
        // 0x80747e1
        return;
    }
    int32_t * v49 = (int32_t *)(v1 + 20); // 0x80748a3
    int32_t v31 = *v49; // 0x80748a3
    int32_t * v32 = (int32_t *)(v6 + 4);
    int32_t v29 = *v32;
    int32_t * v30; // 0x8074690
    if (v31 == 9) {
        // 0x8074a98
        if (*(int32_t *)(v29 + 20) != 9) {
            // 0x8074a98
            v30 = (int32_t *)(v1 + 12);
            goto lab_0x80748ea;
        } else {
            goto lab_0x80748b5;
        }
    } else {
        goto lab_0x80748b5;
    }
  lab_0x80747c8:
    // 0x80747c8
    *(int32_t *)*v27 = *v10;
    int32_t v28 = *v10; // 0x80747cd
    *(int32_t *)(*(int32_t *)v28 + 4) = v28;
    // 0x80747d5
    update_hierbox_browser(&option_browser);
    // 0x80747e1
    return;
  lab_0x80748b5:;
    int32_t * str = (int32_t *)(v1 + 12);
    if (strcmp((char *)*(int32_t *)(v29 + 12), (char *)*str) < 1) {
        goto lab_0x8074ac8;
    } else {
        // 0x80748db
        v30 = str;
        if (v31 == 9) {
            goto lab_0x80748ea;
        } else {
            // 0x80748e0
            v30 = str;
            if (*(int32_t *)(v29 + 20) == 9) {
                goto lab_0x8074ac8;
            } else {
                goto lab_0x80748ea;
            }
        }
    }
  lab_0x8074ac8:
    // 0x8074ac8
    *(int32_t *)v1 = *(int32_t *)v29;
    *(int32_t *)(v1 + 4) = *v32;
    if (v25 == 0) {
        // 0x80747d5
        update_hierbox_browser(&option_browser);
        // 0x80747e1
        return;
    }
    int32_t * v33 = (int32_t *)(v34 + 12);
    *(int32_t *)*v10 = *(int32_t *)*v33;
    *(int32_t *)(*v10 + 4) = *v33;
    v27 = v33;
    goto lab_0x80747c8;
  lab_0x80748ea:;
    int32_t v35 = v8; // 0x8074690
    int32_t v36 = v37; // 0x8074690
    int32_t v38 = v31; // 0x8074690
    int32_t v39; // 0x8074690
    int32_t v40; // 0x8074690
    int32_t v41; // 0x8074690
    int32_t v42; // 0x8074690
    int32_t v43; // 0x8074b56
    while (true) {
        int32_t v44 = v38;
        v39 = v36;
        int32_t v45 = v35;
        int32_t v46 = v45; // 0x8074905
        int32_t v47 = v44; // 0x8074905
        if (*(char *)(v39 + 16) >= 0) {
            // 0x8074907
            v46 = v45;
            v47 = v44;
            if (*(int32_t *)(v39 + 52) != 0) {
                int32_t v48 = *(int32_t *)v45; // 0x8074917
                v46 = v48;
                v47 = v44;
                if (assert_failed == 0) {
                    // 0x8074b20
                    assert_failed = v8 == v48;
                    if (v8 == v48) {
                        // 0x8074c05
                        errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/config/options.c";
                        errline = 373;
                        elinks_internal("assertion bpos != (struct listbox_item *) bcat failed!");
                        v46 = v48;
                        v47 = *v49;
                    } else {
                        // 0x8074b36
                        v46 = v48;
                        v47 = *v49;
                    }
                }
            }
        }
        int32_t v50 = v47;
        v7 = v46;
        if (v50 == 9) {
            // 0x8074b08
            if (*(int32_t *)(v39 + 20) != 9) {
                // break -> 0x8074978
                break;
            }
        }
        int32_t str2 = *(int32_t *)(v39 + 12); // 0x807492d
        char * str3 = (char *)*v30;
        if (strcmp((char *)str2, str3) >= 1) {
            int32_t v51 = *(int32_t *)(v39 + 20);
            if (v50 != 9 != (v51 == 9)) {
                // 0x8074970
                if (v50 == v51) {
                    // 0x8074b40
                    if (*str3 < 96) {
                        // 0x8074b49
                        v43 = v12 ? -1 : 1;
                        v41 = (int32_t)"_template_";
                        v42 = str2;
                        v40 = 11;
                        goto lab_dec_label_pc_unknown;
                    } else {
                        goto lab_0x8074978;
                    }
                } else {
                    goto lab_0x8074978;
                }
            }
        }
        int32_t v52 = *(int32_t *)v39; // 0x8074ab0
        v35 = v7;
        v36 = v52;
        v38 = v50;
        v5 = v52;
        if (v52 == v6) {
            goto lab_0x80749bc;
        }
    }
    // 0x8074978
    goto lab_0x8074978;
  lab_0x8074978:
    // 0x8074978
    if (v25 == 0) {
        // branch -> 0x80749a2
    } else {
        int32_t * v53 = (int32_t *)(v7 + 4);
        *(int32_t *)*v10 = *(int32_t *)*v53;
        *(int32_t *)(*v10 + 4) = *v53;
        *(int32_t *)*v53 = *v10;
        int32_t v54 = *v10; // 0x807499a
        *(int32_t *)(*(int32_t *)v54 + 4) = v54;
    }
    int32_t * v55 = (int32_t *)(v39 + 4); // 0x80749a5
    *(int32_t *)v1 = *(int32_t *)*v55;
    *(int32_t *)(v1 + 4) = *v55;
    v5 = v39;
    goto lab_0x80749bc;
  lab_dec_label_pc_unknown:;
    int32_t v56 = v40 - 1; // 0x8074b56
    if (*(char *)v42 == *(char *)v41) {
        v41 += v43;
        v42 += v43;
        v40 = v56;
        if (v56 == 0) {
            // 0x8074b5e
            if (v25 == 0) {
                goto lab_0x8074b7f;
            } else {
                int32_t * v57 = (int32_t *)v7; // 0x8074b68
                *(int32_t *)*v10 = *v57;
                *(int32_t *)(*v10 + 4) = v7;
                *v57 = *v10;
                int32_t v58 = *v10; // 0x8074b77
                *(int32_t *)(*(int32_t *)v58 + 4) = v58;
                goto lab_0x8074b7f;
            }
        } else {
            goto lab_dec_label_pc_unknown;
        }
    } else {
        goto lab_0x8074978;
    }
  lab_0x8074b7f:
    // 0x8074b7f
    *(int32_t *)(v1 + 4) = v39;
    *(int32_t *)v1 = *(int32_t *)v39;
    v5 = v39;
    goto lab_0x80749bc;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/config/options.c
// Address range: 0x8075370 - 0x807539e
// Line range:    241 - 249
int32_t * get_opt_rec_real(int32_t * tree, char * name) {
    // 0x8075370
    no_autocreate = 1;
    int32_t * result = get_opt_rec(tree, name); // 0x807538d
    no_autocreate = 0;
    return result;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/dialogs/download.c
// Address range: 0x8079c30 - 0x8079c5e
// Line range:    525 - 531
void done_download_display(int32_t * file_download) {
    int32_t * v1 = (int32_t *)((int32_t)file_download + 112); // 0x8079c3a
    int32_t v2 = *v1; // 0x8079c3a
    if (v2 != 0) {
        // 0x8079c41
        done_listbox_item(&download_browser, (int32_t *)v2);
        *v1 = 0;
    }
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/dialogs/menu.c
// Address range: 0x807c7a0 - 0x807c813
// Line range:    614 - 620
void free_history_lists(void) {
    // 0x807c7a0
    if (g29 == &file_history) {
        // 0x807c7ff
        trigger_event_name("free-history");
        return;
    }
    int32_t v1 = (int32_t)g29; // 0x807c7d0
    v1 += 4;
    while (v1 != (int32_t)&file_history) {
        // 0x807c7d0
        v1 += 4;
    }
    // 0x807c7ff
    trigger_event_name("free-history");
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/document/document.c
// Address range: 0x8081720 - 0x808177c
// Line range:    70 - 85
void free_frameset_desc(int32_t * frameset_desc) {
    int32_t v1 = 0; // 0x808172f
    int32_t v2; // 0x8081720
    if (v2 < 1) {
        // 0x808176c
        mem_free((char *)v2);
        return;
    }
    int32_t v3; // 0x8081720
    int32_t v4 = v3 + 20; // 0x8081738
    if (*(int32_t *)v4 != 0) {
        // 0x808173f
        free_frameset_desc(&g83);
    }
    int32_t v5 = *(int32_t *)(v3 + 24); // 0x8081744
    if (v5 != 0) {
        // 0x808174b
        mem_free((char *)v5);
    }
    int32_t v6 = *(int32_t *)(v3 + 28); // 0x8081753
    int32_t v7 = 0; // 0x8081758
    if (v6 != 0) {
        // 0x808175a
        done_uri((int32_t *)v6);
        v7 = &g83;
    }
    // 0x8081762
    v1++;
    v3 = v4;
    while (v7 > v1) {
        // 0x8081738
        v4 = v3 + 20;
        if (*(int32_t *)v4 != 0) {
            // 0x808173f
            free_frameset_desc(&g83);
        }
        // 0x8081744
        v5 = *(int32_t *)(v3 + 24);
        if (v5 != 0) {
            // 0x808174b
            mem_free((char *)v5);
        }
        // 0x8081753
        v6 = *(int32_t *)(v3 + 28);
        v7 = 0;
        if (v6 != 0) {
            // 0x808175a
            done_uri((int32_t *)v6);
            v7 = &g83;
        }
        // 0x8081762
        v1++;
        v3 = v4;
    }
    // 0x808176c
    mem_free((char *)v2);
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/document/document.c
// Address range: 0x8081780 - 0x8081848
// Line range:    88 - 105
void done_link_members(int32_t * link) {
    int32_t v1 = (int32_t)link;
    int32_t * v2 = (int32_t *)(v1 + 44); // 0x808178c
    int32_t v3 = *v2; // 0x808178c
    if (v3 != 0) {
        int32_t v4 = *(int32_t *)v3; // 0x8081793
        int32_t v5 = v3; // 0x8081799
        if (v4 != v3) {
            int32_t v6 = *(int32_t *)v4;
            int32_t v7 = *(int32_t *)(v4 + 12); // 0x80817a2
            if (v7 != 0) {
                // 0x80817a9
                mem_free((char *)v7);
            }
            // 0x80817b1
            mem_free((char *)v4);
            int32_t v8 = *v2; // 0x80817bb
            int32_t v9 = v6; // 0x80817c2
            v5 = v8;
            while (v8 != v6) {
                // 0x80817a2
                v6 = *(int32_t *)v9;
                v7 = *(int32_t *)(v9 + 12);
                if (v7 != 0) {
                    // 0x80817a9
                    mem_free((char *)v7);
                }
                // 0x80817b1
                mem_free((char *)v9);
                v8 = *v2;
                v9 = v6;
                v5 = v8;
            }
        }
        // 0x80817c4
        mem_free((char *)v5);
    }
    // 0x80817cc
    if (*(int32_t *)(v1 + 4) < 2) {
        int32_t v10 = *(int32_t *)(v1 + 48); // 0x8081828
        if (v10 != 0) {
            // 0x808182f
            mem_free((char *)v10);
        }
    }
    int32_t v11 = *(int32_t *)(v1 + 8); // 0x80817d2
    if (v11 != 0) {
        // 0x80817d9
        mem_free((char *)v11);
    }
    int32_t v12 = *(int32_t *)(v1 + 12); // 0x80817e1
    if (v12 != 0) {
        // 0x80817e8
        mem_free((char *)v12);
    }
    int32_t v13 = *(int32_t *)(v1 + 20); // 0x80817f0
    if (v13 != 0) {
        // 0x80817f7
        mem_free((char *)v13);
    }
    int32_t v14 = *(int32_t *)(v1 + 16); // 0x80817ff
    if (v14 != 0) {
        // 0x8081806
        mem_free((char *)v14);
    }
    int32_t v15 = *(int32_t *)(v1 + 24); // 0x808180e
    if (v15 == 0) {
        // 0x8081840
        return;
    }
    // 0x8081815
    mem_free((char *)v15);
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/document/document.c
// Address range: 0x8081850 - 0x8081b90
// Line range:    108 - 111
void done_document(int32_t * document) {
    // 0x8081850
    if (assert_failed != 0) {
        // 0x8081b20
        assert_failed = 0;
        return;
    }
    // 0x808186a
    assert_failed = document == NULL;
    if (document == NULL) {
        // 0x8081b60
        errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/document/document.c";
        errline = 110;
        elinks_internal("assertion document failed!");
        if (assert_failed != 0) {
            // 0x8081b20
            assert_failed = 0;
            return;
        }
    }
    int32_t v1 = (int32_t)document;
    int32_t v2 = *(int32_t *)(v1 + 8); // 0x8081880
    assert_failed = v2 != 0;
    if (v2 != 0) {
        // 0x8081af0
        errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/document/document.c";
        errline = 113;
        elinks_internal("assertion !is_object_used(document) failed: Attempt to free locked formatted data.");
        if (assert_failed != 0) {
            // 0x8081b20
            assert_failed = 0;
            return;
        }
    }
    int32_t * v3 = (int32_t *)(v1 + 192); // 0x8081897
    int32_t v4 = *v3; // 0x8081897
    assert_failed = v4 == 0;
    if (v4 == 0) {
        // 0x8081b38
        errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/document/document.c";
        errline = 116;
        elinks_internal("assertion document->cached failed!");
    }
    int32_t * v5 = (int32_t *)(*v3 + 8); // 0x80818b5
    *v5 = *v5 - 1;
    int32_t v6 = *(int32_t *)(v1 + 184); // 0x80818b9
    if (v6 != 0) {
        // 0x80818c3
        done_uri((int32_t *)v6);
    }
    int32_t v7 = *(int32_t *)(v1 + 188); // 0x80818cb
    if (v7 != 0) {
        // 0x80818d5
        mem_free((char *)v7);
    }
    // 0x80818dd
    if (*(int32_t *)(v1 + 200) != 0) {
        // 0x80818e7
        free_frameset_desc(&g83);
    }
    int32_t v8 = *(int32_t *)(v1 + 204); // 0x80818ec
    if (v8 != 0) {
        // 0x80818f6
        done_document_refresh((int32_t *)v8);
    }
    int32_t * v9 = (int32_t *)(v1 + 212); // 0x80818fe
    int32_t v10 = *v9; // 0x80818fe
    if (v10 != 0) {
        int32_t * v11 = (int32_t *)(v1 + 260); // 0x8081908
        int32_t v12 = 0; // 0x8081910
        int32_t v13 = v10; // 0x8081910
        if (*v11 >= 1) {
            int32_t v14 = 1; // 0x8081920
            done_link_members((int32_t *)(v12 + v10));
            int32_t v15 = *v9;
            int32_t v16 = v15; // 0x8081934
            int32_t v17 = v14; // 0x8081934
            v12 += 52;
            v13 = v15;
            while (*v11 > v14) {
                // 0x808191e
                v14 = v17 + 1;
                done_link_members((int32_t *)(v12 + v16));
                v15 = *v9;
                v16 = v15;
                v17 = v14;
                v12 += 52;
                v13 = v15;
            }
        }
        // 0x808193c
        mem_free((char *)v13);
    }
    int32_t * v18 = (int32_t *)(v1 + 208); // 0x8081944
    int32_t v19 = *v18; // 0x8081944
    if (v19 != 0) {
        int32_t * v20 = (int32_t *)(v1 + 256); // 0x808194e
        uint32_t v21 = *v20; // 0x808194e
        int32_t v22 = 0; // 0x8081956
        int32_t v23 = v19; // 0x8081956
        if (v21 >= 1) {
            int32_t v24 = *(int32_t *)(8 * v22 + v19); // 0x8081960
            int32_t v25 = v21; // 0x8081965
            int32_t v26 = v19; // 0x8081965
            if (v24 != 0) {
                // 0x8081967
                mem_free((char *)v24);
                v26 = *v18;
                v25 = *v20;
            }
            int32_t v27 = v22 + 1; // 0x8081975
            int32_t v28 = v25; // 0x808197e
            int32_t v29 = v26; // 0x808197e
            v22 = v27;
            v23 = v26;
            while (v25 > v27) {
                // 0x8081960
                v24 = *(int32_t *)(8 * v22 + v29);
                v25 = v28;
                v26 = v29;
                if (v24 != 0) {
                    // 0x8081967
                    mem_free((char *)v24);
                    v26 = *v18;
                    v25 = *v20;
                }
                // 0x8081975
                v27 = v22 + 1;
                v28 = v25;
                v29 = v26;
                v22 = v27;
                v23 = v26;
            }
        }
        // 0x8081980
        mem_free((char *)v23);
    }
    int32_t v30 = *(int32_t *)(v1 + 216); // 0x8081988
    if (v30 != 0) {
        // 0x8081992
        mem_free((char *)v30);
    }
    int32_t v31 = *(int32_t *)(v1 + 220); // 0x808199a
    if (v31 != 0) {
        // 0x80819a4
        mem_free((char *)v31);
    }
    int32_t v32 = v1 + 148; // 0x80819b2
    done_document_options((int32_t *)(v1 + 12));
    int32_t * v33 = (int32_t *)v32; // 0x80819bd
    int32_t v34 = *v33; // 0x80819bd
    if (v34 != v32) {
        done_form((int32_t *)v34);
        int32_t v35 = *v33; // 0x80819d0
        while (v35 != v32) {
            // 0x80819c8
            done_form((int32_t *)v35);
            v35 = *v33;
        }
    }
    // 0x80819da
    free_uri_list((int32_t *)(v1 + 172));
    int32_t v36 = v1 + 156; // 0x80819e8
    int32_t v37 = *(int32_t *)v36; // 0x80819e8
    int32_t v38 = v37; // 0x80819f8
    int32_t v39 = v36; // 0x80819f8
    if (v37 != v36) {
        v38 = *(int32_t *)v38;
        v39 = v38;
        while (v38 != v36) {
            // 0x8081a00
            v38 = *(int32_t *)v38;
            v39 = v38;
        }
    }
    int32_t v40 = *(int32_t *)(v1 + 160); // 0x8081a06
    int32_t v41 = v40; // 0x8081a0e
    if (v40 != v39) {
        v41 += 4;
        while (v41 != v39) {
            // 0x8081a10
            v41 += 4;
        }
    }
    // 0x8081a17
    if (v37 != v39) {
        int32_t * v42 = (int32_t *)v37;
        int32_t v43 = *v42;
        int32_t * v44 = (int32_t *)(v37 + 4); // 0x8081a20
        *(int32_t *)(v43 + 4) = *v44;
        *(int32_t *)*v44 = *v42;
        mem_free((char *)v37);
        while (v43 != v39) {
            int32_t v45 = v43;
            v42 = (int32_t *)v45;
            v43 = *v42;
            v44 = (int32_t *)(v45 + 4);
            *(int32_t *)(v43 + 4) = *v44;
            *(int32_t *)*v44 = *v42;
            mem_free((char *)v45);
        }
    }
    int32_t v46 = v1 + 164; // 0x8081a42
    int32_t v47 = *(int32_t *)v46; // 0x8081a42
    int32_t v48 = v47; // 0x8081a50
    if (v46 != v47) {
        v48 = *(int32_t *)v48;
        while (v46 != v48) {
            // 0x8081a58
            v48 = *(int32_t *)v48;
        }
    }
    int32_t v49 = *(int32_t *)(v1 + 168); // 0x8081a5e
    int32_t v50 = v49; // 0x8081a66
    if (v49 != v46) {
        v50 += 4;
        while (v50 != v46) {
            // 0x8081a68
            v50 += 4;
        }
    }
    // 0x8081a6f
    if (v46 != v47) {
        int32_t * v51 = (int32_t *)v47;
        int32_t v52 = *v51;
        int32_t * v53 = (int32_t *)(v47 + 4); // 0x8081a78
        *(int32_t *)(v52 + 4) = *v53;
        *(int32_t *)*v53 = *v51;
        mem_free((char *)v47);
        while (v46 != v52) {
            int32_t v54 = v52;
            v51 = (int32_t *)v54;
            v52 = *v51;
            v53 = (int32_t *)(v54 + 4);
            *(int32_t *)(v52 + 4) = *v53;
            *(int32_t *)*v53 = *v51;
            mem_free((char *)v54);
        }
    }
    int32_t v55 = *(int32_t *)(v1 + 224); // 0x8081a9a
    if (v55 != 0) {
        // 0x8081aa4
        mem_free((char *)v55);
    }
    int32_t v56 = *(int32_t *)(v1 + 228); // 0x8081aac
    if (v56 != 0) {
        // 0x8081ab6
        mem_free((char *)v56);
    }
    int32_t v57 = *(int32_t *)(v1 + 232); // 0x8081abe
    if (v57 != 0) {
        // 0x8081ac8
        mem_free((char *)v57);
    }
    int32_t * v58 = (int32_t *)(v1 + 4); // 0x8081ad2
    *(int32_t *)(*document + 4) = *v58;
    *(int32_t *)*v58 = *document;
    mem_free((char *)document);
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/document/document.c
// Address range: 0x8081b90 - 0x8081d20
// Line range:    274 - 302
void shrink_format_cache(int32_t whole) {
    int32_t v1 = get_opt_((int32_t)config_options, "document.cache.format.size"); // 0x8081bb0
    assert_failed = 0;
    if (g30 == &format_cache) {
        // 0x8081c6b
        assert_failed = 0;
        // 0x8081c78
        return;
    }
    int32_t v2 = 0;
    int32_t v3 = (int32_t)g30;
    int32_t v4 = *&g31;
    int32_t v5 = v2; // 0x8081c3f
    if (*(int32_t *)(v3 + 8) == 0) {
        // 0x8081c41
        if (!((whole != 0 | v2 > *(int32_t *)v1))) {
            // break -> 0x8081c61
            break;
        }
        // 0x8081c49
        done_document((int32_t *)v3);
        v5 = v2 - 1;
    }
    int32_t v6 = v5;
    int32_t v7 = v6; // 0x8081c5f
    while (v4 != (int32_t)&format_cache) {
        // 0x8081c38
        v2 = v6;
        v3 = v4;
        v4 += 4;
        v5 = v2;
        if (*(int32_t *)(v3 + 8) == 0) {
            // 0x8081c41
            v7 = v2;
            if (!((whole != 0 | v2 > *(int32_t *)v1))) {
                // break -> 0x8081c61
                break;
            }
            // 0x8081c49
            done_document((int32_t *)v3);
            v5 = v2 - 1;
        }
        // 0x8081c54
        v6 = v5;
        v7 = v6;
    }
    // 0x8081c61
    if (assert_failed != 0) {
        // 0x8081cb0
        assert_failed = 0;
        return;
    }
    // 0x8081c6b
    assert_failed = v7 < 0;
    if (v7 >= 0) {
        // 0x8081c78
        return;
    }
    // 0x8081c80
    errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/document/document.c";
    errline = 309;
    elinks_internal("assertion format_cache_entries >= 0 failed: format_cache_entries underflow");
    if (assert_failed == 0) {
        // 0x8081c78
        return;
    }
    // 0x8081cb0
    assert_failed = 0;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/document/forms.c
// Address range: 0x80821a0 - 0x80822c2
// Line range:    148 - 168
void done_form_control(int32_t * fc) {
    // 0x80821a0
    if (assert_failed != 0) {
        // 0x80822b0
        assert_failed = 0;
        // 0x80822ba
        return;
    }
    // 0x80821ba
    assert_failed = fc == NULL;
    if (fc == NULL) {
        // 0x8082280
        errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/document/forms.c";
        errline = 152;
        elinks_internal("assertion fc failed!");
        if (assert_failed != 0) {
            // 0x80822b0
            assert_failed = 0;
            // 0x80822ba
            return;
        }
    }
    int32_t v1 = (int32_t)fc;
    int32_t v2 = *(int32_t *)(v1 + 28); // 0x80821ce
    if (v2 != 0) {
        // 0x80821d5
        mem_free((char *)v2);
    }
    int32_t v3 = *(int32_t *)(v1 + 32); // 0x80821dd
    if (v3 != 0) {
        // 0x80821e4
        mem_free((char *)v3);
    }
    int32_t v4 = *(int32_t *)(v1 + 36); // 0x80821ec
    if (v4 != 0) {
        // 0x80821f3
        mem_free((char *)v4);
    }
    int32_t v5 = *(int32_t *)(v1 + 40); // 0x80821fb
    if (v5 != 0) {
        // 0x8082202
        mem_free((char *)v5);
    }
    int32_t * v6 = (int32_t *)(v1 + 68); // 0x808220a
    int32_t * v7 = (int32_t *)(v1 + 72);
    if (*v6 >= 1) {
        for (int32_t i = 0; i < *v6; i++) {
            int32_t v8 = 4 * i; // 0x808221b
            int32_t v9 = *(int32_t *)(*v7 + v8); // 0x8082222
            if (v9 != 0) {
                // 0x8082229
                mem_free((char *)v9);
            }
            int32_t v10 = *(int32_t *)(*(int32_t *)(v1 + 76) + v8); // 0x8082234
            if (v10 != 0) {
                // 0x808223b
                mem_free((char *)v10);
            }
        }
    }
    int32_t v11 = *v7; // 0x808224b
    if (v11 != 0) {
        // 0x8082252
        mem_free((char *)v11);
    }
    int32_t v12 = *(int32_t *)(v1 + 76); // 0x808225a
    if (v12 != 0) {
        // 0x8082261
        mem_free((char *)v12);
    }
    int32_t v13 = *(int32_t *)(v1 + 80); // 0x8082269
    if (v13 == 0) {
        // 0x80822ba
        return;
    }
    // 0x8082270
    free_menu((int32_t *)v13);
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/document/forms.c
// Address range: 0x80822d0 - 0x80823c1
// Line range:    87 - 104
void done_form(int32_t * form) {
    int32_t v1 = (int32_t)form;
    int32_t v2 = *form; // 0x80822e1
    if (v2 != 0) {
        int32_t * v3 = (int32_t *)(v1 + 4); // 0x80822e9
        *(int32_t *)(v2 + 4) = *v3;
        *(int32_t *)*v3 = *form;
    }
    int32_t v4 = *(int32_t *)(v1 + 16); // 0x80822f9
    if (v4 != 0) {
        // 0x8082300
        mem_free((char *)v4);
    }
    int32_t v5 = *(int32_t *)(v1 + 20); // 0x808230b
    if (v5 != 0) {
        // 0x8082312
        mem_free((char *)v5);
    }
    int32_t v6 = *(int32_t *)(v1 + 24); // 0x808231d
    if (v6 != 0) {
        // 0x8082324
        mem_free((char *)v6);
    }
    int32_t v7 = *(int32_t *)(v1 + 28); // 0x808232f
    if (v7 != 0) {
        // 0x8082336
        mem_free((char *)v7);
    }
    int32_t v8 = v1 + 36; // 0x8082341
    int32_t * v9 = (int32_t *)v8; // 0x8082341
    int32_t v10 = *v9; // 0x8082341
    bool v11 = true; // 0x808234d
    int32_t v12 = v8; // 0x808234d
    if (v10 != v8) {
        int32_t * v13 = (int32_t *)v10;
        done_form_control(v13);
        int32_t v14 = *v13; // 0x8082358
        while (v14 != v8) {
            // 0x8082350
            v13 = (int32_t *)v14;
            done_form_control(v13);
            v14 = *v13;
        }
        int32_t v15 = *v9; // 0x8082361
        v11 = true;
        v12 = v8;
        if (v15 != v8) {
            int32_t v16 = *(int32_t *)v15; // 0x8082370
            int32_t v17 = v16; // 0x8082374
            v11 = false;
            v12 = v15;
            while (v8 != v16) {
                // 0x8082370
                v16 = *(int32_t *)v17;
                v17 = v16;
                v11 = false;
                v12 = v15;
            }
        }
    }
    int32_t v18 = *(int32_t *)(v1 + 40); // 0x8082379
    int32_t v19 = v18; // 0x808237e
    if (v18 != v8) {
        v19 += 4;
        while (v8 != v19) {
            // 0x8082380
            v19 += 4;
        }
    }
    // 0x8082387
    if (v11) {
        // 0x80823af
        mem_free((char *)form);
        return;
    }
    int32_t * v20 = (int32_t *)v12;
    int32_t v21 = *v20;
    int32_t * v22 = (int32_t *)(v12 + 4); // 0x8082390
    *(int32_t *)(v21 + 4) = *v22;
    *(int32_t *)*v22 = *v20;
    mem_free((char *)v12);
    while (v8 != v21) {
        int32_t v23 = v21;
        v20 = (int32_t *)v23;
        v21 = *v20;
        v22 = (int32_t *)(v23 + 4);
        *(int32_t *)(v21 + 4) = *v22;
        *(int32_t *)*v22 = *v20;
        mem_free((char *)v23);
    }
    // 0x80823af
    mem_free((char *)form);
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/document/options.c
// Address range: 0x8082610 - 0x8082644
// Line range:    117 - 121
void done_document_options(int32_t * options) {
    int32_t v1 = (int32_t)options;
    int32_t v2 = *(int32_t *)(v1 + 72); // 0x808261a
    if (v2 != 0) {
        // 0x8082621
        mem_free((char *)v2);
    }
    // 0x8082629
    mem_free((char *)*(int32_t *)(v1 + 108));
    mem_free((char *)*(int32_t *)(v1 + 112));
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/document/refresh.c
// Address range: 0x8082f60 - 0x8082f8a
// Line range:    56 - 60
void done_document_refresh(int32_t * refresh) {
    // 0x8082f60
    kill_timer((int32_t **)refresh);
    done_uri((int32_t *)*(int32_t *)((int32_t)refresh + 8));
    mem_free((char *)refresh);
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/encoding/encoding.c
// Address range: 0x80aab80 - 0x80aaba6
// Line range:    143 - 146
void close_encoded(int32_t * stream) {
    // 0x80aab80
    mem_free((char *)stream);
}

// Address range: 0x80ad050 - 0x80ad06d
int32_t is_cp_utf8(int32_t a1) {
    int32_t v1 = *(int32_t *)((16 * a1 & -2064) + (int32_t)&g2); // 0x80ad05c
    return v1 == (int32_t)&aliases_utf8;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/intl/charsets.c
// Address range: 0x80ad070 - 0x80ad084
// Line range:    1435 - 1440
void free_charsets_lookup(void) {
    // 0x80ad070
    fastfind_done(&ff_charsets_index);
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/intl/charsets.c
// Address range: 0x80ad0b0 - 0x80ad198
// Line range:    1397 - 1417
int32_t get_cp_index(char * name) {
    int32_t v1 = c_strcasecmp(name, "System"); // 0x80ad0c8
    char * str = name; // 0x80ad0cf
    int32_t v2 = 0; // 0x80ad0cf
    if (v1 == 0) {
        // 0x80ad168
        str = nl_langinfo(14);
        v2 = 128;
    }
    int32_t len = strlen(str); // 0x80ad0d8
    char * v3 = fastfind_search(&ff_charsets_index, str, len); // 0x80ad0ec
    if (v3 == NULL) {
        int32_t result = -1; // 0x80ad186
        if (v2 != 0) {
            // 0x80ad188
            result = get_cp_index("us-ascii") | v2;
        }
        // 0x80ad144
        return result;
    }
    // 0x80ad0f9
    if (assert_failed == 0) {
        if (v3 < (char *)&codepages || v3 >= (char *)&g5) {
            // 0x80ad10a
            assert_failed = 1;
            errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/intl/charsets.c";
            errline = 1413;
            elinks_internal("assertion codepages <= codepage && codepage < codepages + N_CODEPAGES failed!");
        } else {
            // 0x80ad157
            assert_failed = 0;
        }
    }
    // 0x80ad144
    return (int32_t)v3 - (int32_t)&codepages >> 4 | v2;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/intl/charsets.c
// Address range: 0x80ad1a0 - 0x80ad25d
// Line range:    738 - 749
int32_t cp2u(int32_t from, unsigned char c) {
    // 0x80ad1a0
    if (assert_failed != 0) {
        // 0x80ad219
        assert_failed = 0;
        return 0xfffd;
    }
    int32_t v1 = 16 * from & -2064; // 0x80ad1c1
    int32_t v2 = *(int32_t *)(v1 + (int32_t)&codepages + 4); // 0x80ad1ca
    assert_failed = v2 == (int32_t)&aliases_utf8;
    if (v2 == (int32_t)&aliases_utf8) {
        // 0x80ad1f0
        errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/intl/charsets.c";
        errline = 744;
        elinks_internal("assertion !is_cp_ptr_utf8(&codepages[from]) failed!");
        if (assert_failed != 0) {
            // 0x80ad219
            assert_failed = 0;
            return 0xfffd;
        }
    }
    int32_t result = c; // 0x80ad1a9
    if (c >= 0) {
        // 0x80ad1e5
        return result;
    }
    int32_t v3 = *(int32_t *)(v1 + (int32_t)&codepages + 8); // 0x80ad238
    int16_t v4 = *(int16_t *)(2 * result - 256 + v3); // 0x80ad241
    return v4 == -1 ? -3 : v4;
}

// Address range: 0x80ad260 - 0x80ad56b
int32_t utf8_to_unicode(int32_t * a1, uint32_t a2) {
    int32_t v1 = *a1; // 0x80ad272
    unsigned char v2 = *(char *)v1; // 0x80ad279
    g84 = v2;
    int32_t v3 = v2; // 0x80ad279
    char v4 = *(char *)(v3 + (int32_t)"\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x04\x04\x04\x04\x04\x04\x04\x04\x05\x05\x05\x05\x06\x06\x01\x01"); // 0x80ad27f
    uint32_t v5 = v1 + (int32_t)v4; // 0x80ad289
    if (v5 > a2) {
        // 0x80ad2ca
        return -3;
    }
    int32_t result; // 0x80ad260
    if (v2 < 7) {
        // 0x80ad390
        *a1 = v5;
        result = v3;
    } else {
        // 0x80ad2c0
        errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/intl/charsets.c";
        errline = 719;
        elinks_internal("utf8char_len_tab out of range");
        *a1 = *a1 + 1;
        result = 0xfffd;
    }
    // 0x80ad2ca
    return result;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/intl/charsets.c
// Address range: 0x80ad570 - 0x80ad5d4
// Line range:    764 - 769
int32_t cp_to_unicode(int32_t codepage, char ** string, char * end) {
    int32_t v1 = *(int32_t *)((16 * codepage & -2064) + (int32_t)&g2); // 0x80ad58c
    if (v1 == (int32_t)&aliases_utf8) {
        // 0x80ad5c0
        int32_t v2; // 0x80ad570
        return utf8_to_unicode((int32_t *)v2, v2);
    }
    char * v3 = *string;
    int32_t result = -3; // 0x80ad5a1
    if (v3 < end) {
        // 0x80ad5a3
        result = cp2u(codepage, *v3);
        *(int32_t *)string = (int32_t)*string + 1;
    }
    // 0x80ad5b5
    return result;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/intl/charsets.c
// Address range: 0x80ad5e0 - 0x80ad625
// Line range:    122 - 131
void free_translation_table(int32_t * p) {
    int32_t v1 = 0; // 0x80ad5ec
    int32_t v2; // 0x80ad5e0
    while (true) {
        int32_t v3 = v1;
        if (*(int32_t *)(8 * v3 + v2) == 0) {
            if (v3 == 255) {
                // break -> 0x80ad616
                break;
            }
        } else {
            // 0x80ad602
            free_translation_table(&g83);
            if (v3 == 255) {
                // break -> 0x80ad616
                break;
            }
        }
        // 0x80ad5fb
        v1 = v3 + 1;
    }
    // 0x80ad616
    mem_free((char *)v2);
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/intl/charsets.c
// Address range: 0x80ad630 - 0x80ad6a5
// Line range:    141 - 156
void new_translation_table(int32_t * p) {
    int32_t v1 = 0; // 0x80ad639
    int32_t v2; // 0x80ad630
    while (true) {
        int32_t v3 = v1;
        if (*(int32_t *)(8 * v3 + v2) == 0) {
            if (v3 == 255) {
                // break -> 0x80ad666
                break;
            }
        } else {
            // 0x80ad652
            free_translation_table(&g83);
            if (v3 == 255) {
                // break -> 0x80ad666
                break;
            }
        }
        // 0x80ad64b
        v1 = v3 + 1;
    }
    int32_t v4 = v2 + 4; // 0x80ad675
    int32_t v5 = 0;
    int32_t v6 = 4 * v5; // 0x80ad66e
    *(int32_t *)(v6 + v2) = 0;
    *(int32_t *)(v6 + v4) = v5 + (int32_t)&strings;
    int32_t v7 = v5 + 2; // 0x80ad679
    while (v5 != 254) {
        // 0x80ad668
        v5 = v7;
        v6 = 4 * v5;
        *(int32_t *)(v6 + v2) = 0;
        *(int32_t *)(v6 + v4) = v5 + (int32_t)&strings;
        v7 = v5 + 2;
    }
    int32_t v8 = v7 & -0x10000 | 128; // 0x80ad687
    int32_t v9 = 8 * v8; // 0x80ad688
    *(int32_t *)(v9 + v2) = 0;
    *(int32_t *)(v9 + v4) = (int32_t)"*";
    while (v8 != 255) {
        // 0x80ad688
        v8++;
        v9 = 8 * v8;
        *(int32_t *)(v9 + v2) = 0;
        *(int32_t *)(v9 + v4) = (int32_t)"*";
    }
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/intl/charsets.c
// Address range: 0x80ad780 - 0x80ad7e5
// Line range:    881 - 888
void free_conv_table(void) {
    int32_t v1 = 128; // 0x80ad78f
    if (utf_table_init == 0) {
        int32_t v2 = *(int32_t *)(8 * v1 + (int32_t)&g79); // 0x80ad798
        mem_free((char *)v2);
        while (v1 != 255) {
            // 0x80ad798
            v1++;
            v2 = *(int32_t *)(8 * v1 + (int32_t)&g79);
            mem_free((char *)v2);
        }
    }
    // 0x80ad7b2
    if (first != 0) {
        // 0x80ad7bc
        __asm_rep_stosd_memset((char *)&table_elinks, 0, 512);
        first = 0;
    }
    // 0x80ad7d6
    new_translation_table(&g83);
}

// Address range: 0x80ad7f0 - 0x80ad9a9
int32_t encode_utf8(uint32_t a1) {
    // 0x80ad7f0
    *(int32_t *)&utf_buffer = 0;
    *(int16_t *)&g54 = 0;
    *(char *)&g56 = 0;
    if (a1 < 128) {
        // 0x80ad8d0
        utf_buffer[0] = a1;
        return (int32_t)&utf_buffer;
    }
    if (a1 < 2048) {
        // 0x80ad8a8
        utf_buffer[0] = (char)(a1 / 64) % 32 | -64;
        *(char *)&g51 = (char)a1 % 64 | -128;
        // 0x80ad8c4
        return (int32_t)&utf_buffer;
    }
    if (a1 < 0x10000) {
        // 0x80ad920
        utf_buffer[0] = (char)(a1 / 0x1000) % 16 | -32;
        *(char *)&g52 = (char)a1 % 64 | -128;
        *(char *)&g51 = (char)(a1 / 64) % 64 | -128;
        return (int32_t)&utf_buffer;
    }
    if (a1 < 0x200000) {
        // 0x80ad8e0
        utf_buffer[0] = (char)(a1 / 0x40000) | -16;
        *(char *)&g51 = (char)(a1 / 0x1000) % 64 | -128;
        *(char *)&g52 = (char)(a1 / 64) % 64 | -128;
        *(char *)&g53 = (char)a1 % 64 | -128;
        // 0x80ad8c4
        return (int32_t)&utf_buffer;
    }
    if (a1 < 0x4000000) {
        // 0x80ad958
        utf_buffer[0] = (char)(a1 / 0x1000000) | -8;
        *(char *)&g51 = (char)(a1 / 0x40000) % 64 | -128;
        *(char *)&g52 = (char)(a1 / 0x1000) % 64 | -128;
        *(char *)&g53 = (char)(a1 / 64) % 64 | -128;
        *(char *)&g54 = (char)a1 % 64 | -128;
    } else {
        // 0x80ad846
        utf_buffer[0] = (char)(a1 / 0x40000000) % 2 | -4;
        *(char *)&g51 = (char)(a1 / 0x1000000) % 64 | -128;
        *(char *)&g52 = (char)(a1 / 0x40000) % 64 | -128;
        *(char *)&g53 = (char)(a1 / 0x1000) % 64 | -128;
        *(char *)&g54 = (char)(a1 / 64) % 64 | -128;
        *(char *)&g55 = (char)a1 % 64 | -128;
    }
    // 0x80ad8c4
    return (int32_t)&utf_buffer;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/intl/charsets.c
// Address range: 0x80ad9b0 - 0x80adb0e
// Line range:    185 - 221
char * u2cp_(int32_t u, int32_t to, int32_t nbsp_mode) {
    int32_t v1 = u; // 0x80ad9c2
    if (u < 128) {
        // 0x80ada12
        return (char *)(2 * u + (int32_t)&strings);
    }
    int32_t v2 = to; // 0x80ad9c2
    uint32_t v3; // 0x80ad9b0
    int32_t v4; // 0x80ad9b0
    int32_t v5; // 0x80ad9b0
    int32_t v6; // 0x80ad9c9
    int32_t v7; // 0x80adac3
    while (true) {
      lab_0x80ad9c4:
        // 0x80ad9c4
        v3 = v1;
        v2 &= -129;
        v6 = 16 * v2;
        int32_t v8 = *(int32_t *)(v6 + (int32_t)&g2); // 0x80ad9cc
        if (v8 == (int32_t)&aliases_utf8) {
            // break -> 0x80ada18
            break;
        }
        // 0x80ad9d8
        v4 = &g14;
        switch (v3) {
            case 160: {
                int32_t v9 = nbsp_mode != 0 ? (int32_t)&g25 : (int32_t)&g13; // 0x80ada34
                // 0x80ada12
                return (char *)v9;
            }
            case 173: {
                return (char *)v4;
            }
            default: {
                if (v3 >= 160) {
                    if (v3 < 0xffff) {
                        // 0x80adabe
                        v7 = *(int32_t *)(v6 + (int32_t)&g3);
                        v5 = 0;
                        goto lab_0x80adadf;
                    } else {
                        goto lab_0x80ada4f;
                    }
                }
                // 0x80ad9f2
                v1 = *(int32_t *)(4 * v3 + (int32_t)&g8);
                v4 = 0;
                if (v1 == 0) {
                  lab_0x80ada12:
                    // 0x80ada12
                    return (char *)v4;
                }
                int32_t v10 = v1; // 0x80ada00
                if (v1 < 128) {
                    // 0x80ada12
                    return (char *)(2 * v10 + (int32_t)&strings);
                }
                goto lab_0x80ad9c4;
            }
        }
    }
    // 0x80ada18
    return (char *)encode_utf8(v3);
  lab_0x80ada4f:;
    int32_t v11 = *(int32_t *)(v6 + (int32_t)&g4); // 0x80ada52
    char v12 = *(char *)v11; // 0x80ada58
    int32_t v13; // 0x80ad9b0
    int32_t v14; // 0x80ad9b0
    int32_t v15; // 0x80ad9b0
    if (v12 == 0) {
        // 0x80ada83
        v14 = 0;
        v13 = 2451;
        goto lab_0x80ada90;
    } else {
        // 0x80ada5f
        v15 = v11;
        if (v3 != (int32_t)*(int16_t *)(v11 + 2)) {
            goto lab_0x80ada7b;
        } else {
            // 0x80adaf3
            v4 = 2 * (int32_t)v12 + (int32_t)&strings;
            return (char *)v4;
        }
    }
  lab_0x80adadf:;
    int32_t v16 = v5;
    int32_t v17 = 2 * v16;
    if (v3 != (int32_t)*(int16_t *)(v17 + v7)) {
        // 0x80adad0
        v5 = v16 + 1;
        if (v16 == 127) {
            goto lab_0x80ada4f;
        } else {
            goto lab_0x80adadf;
        }
    } else {
        // 0x80adae7
        v4 = v17 + (int32_t)&g6;
        return (char *)v4;
    }
  lab_0x80ada90:;
    int32_t v18 = v13 + v14 >> 1; // 0x80ada93
    int32_t v19 = 8 * v18; // 0x80ada95
    uint32_t v20 = *(int32_t *)(v19 + (int32_t)&unicode_7b); // 0x80ada95
    if (v20 == v3) {
        // 0x80adb02
        v4 = *(int32_t *)(v19 + (int32_t)&g7);
        return (char *)v4;
    } else {
        int32_t v21 = v3 < v20 ? v18 - 1 : v13; // 0x80adaa5
        int32_t v22 = v3 > v20 ? v18 + 1 : v14; // 0x80adaad
        v4 = (int32_t)"*";
        v14 = v22;
        v13 = v21;
        if (v21 < v22) {
            return (char *)v4;
        } else {
            goto lab_0x80ada90;
        }
    }
  lab_0x80ada7b:;
    int32_t v23 = v15;
    int32_t v24 = v23 + 4; // 0x80ada7b
    char v25 = *(char *)v24; // 0x80ada7b
    if (v25 != 0) {
        // 0x80ada70
        v15 = v24;
        char v26 = v25; // 0x80ada79
        if (v3 == (int32_t)*(int16_t *)(v23 + 6)) {
            // 0x80adaf3
            v4 = 2 * (int32_t)v26 + (int32_t)&strings;
            return (char *)v4;
        } else {
            goto lab_0x80ada7b;
        }
    } else {
        // 0x80ada83
        v14 = 0;
        v13 = 2451;
        goto lab_0x80ada90;
    }
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/intl/charsets.c
// Address range: 0x80adb10 - 0x80ade8a
// Line range:    1005 - 1133
char * get_entity_string(char * str, int32_t strlen2, int32_t encoding) {
    // 0x80adb10
    if (strlen2 < 1) {
        // 0x80adcd5
        return (char *)0;
    }
    int32_t v1 = (int32_t)str;
    int32_t v2 = encoding & -129; // 0x80adb29
    int32_t * v3 = (int32_t *)(16 * v2 + (int32_t)&codepages + 4); // 0x80adb39
    int32_t v4 = 0; // 0x80adb40
    int32_t v5; // 0x80adb10
    if (*v3 == (int32_t)&aliases_utf8) {
        goto lab_0x80adb6f;
    } else {
        // 0x80adb42
        if (g32 != 0) {
            // 0x80addc8
            __asm_rep_stosd_memset((char *)&g46, 0, 9);
            g32 = 0;
            v5 = strlen2;
            if (strlen2 < 9) {
                goto lab_0x80adce8;
            } else {
                goto lab_0x80adb5f;
            }
        } else {
            // 0x80adb50
            v5 = strlen2;
            if (strlen2 < 9) {
                goto lab_0x80adce8;
            } else {
                goto lab_0x80adb5f;
            }
        }
    }
  lab_0x80adbec_2:;
    // 0x80adbec
    int32_t v6; // 0x80adb10
    int32_t v7 = (int32_t)u2cp_(v6, v2, 0); // 0x80adc05
    goto lab_0x80adc5e;
  lab_0x80adb6f:;
    // 0x80adb6f
    int32_t v8; // 0x80adb10
    int32_t v9; // 0x80adb10
    if (*str != 35) {
        // 0x80adc08
        char * key; // bp-36, 0x80adb10
        *(int32_t *)&key = v1;
        int32_t * found_elem = bsearch((int32_t *)&key, &entities, 1001, 8, (int32_t (*)(int32_t *, int32_t *))0x80aceb0); // 0x80adc39
        v7 = 0;
        if (found_elem != NULL) {
            // 0x80adc42
            v7 = (int32_t)u2cp_(*(int32_t *)((int32_t)found_elem + 4), v2, 0);
        }
        goto lab_0x80adc5e;
    } else {
        // 0x80adb7b
        v9 = 0;
        if (strlen2 == 1) {
            goto lab_0x80adc71;
        } else {
            int32_t v31 = v1 + 1; // 0x80adb95
            int32_t v32 = strlen2 - 1; // 0x80adb98
            char v33 = *(char *)v31; // 0x80adb9b
            if ((v33 || 32) == 120) {
                // 0x80addf8
                v8 = 0;
                if (v32 <= 9 && v32 != 1) {
                    int32_t v34 = strlen2 - 2; // 0x80ade12
                    int32_t v35 = 0; // 0x80ade12
                    int32_t v36 = v1 + 2; // 0x80ade12
                    while (true) {
                        int32_t v37 = v35;
                        unsigned char v38 = *(char *)v36 | 32;
                        int32_t v39 = v38; // 0x80ade2e
                        int32_t v40; // 0x80adb10
                        if (v38 < 58) {
                            // 0x80ade18
                            v40 = v39 - 48 | 16 * v37;
                        } else {
                            int16_t * v41 = *__ctype_b_loc(); // 0x80ade46
                            v8 = 0;
                            if ((*(char *)((2 * v39 | 1) + (int32_t)v41) & 16) == 0) {
                                // break -> 0x80adc6a
                                break;
                            }
                            // 0x80ade4f
                            v40 = v39 - 87 | 16 * v37;
                        }
                        // 0x80ade23
                        v35 = v40;
                        v34--;
                        v6 = v35;
                        v36++;
                        if (v34 == 0) {
                            goto lab_0x80adbec_2;
                        }
                    }
                }
            } else {
                int32_t v42 = v31; // 0x80adbaf
                int32_t v43 = v32; // 0x80adbaf
                v8 = 0;
                if (v32 < 11 == v33 < 58) {
                    int32_t v44 = (int32_t)v33 - 48; // 0x80adbd8
                    v8 = 0;
                    while (v44 != -1) {
                        int32_t v45 = v43 - 1; // 0x80adbe5
                        v6 = v44;
                        if (v45 == 0) {
                            goto lab_0x80adbec_2;
                        }
                        int32_t v46 = v42 + 1; // 0x80adbc0
                        char v47 = *(char *)v46; // 0x80adbc3
                        v42 = v46;
                        v43 = v45;
                        v8 = 0;
                        if (v47 >= 58) {
                            // break -> 0x80adc6a
                            break;
                        }
                        v44 = 10 * v44 - 48 + (int32_t)v47;
                        v8 = 0;
                    }
                }
            }
            goto lab_0x80adc6a;
        }
    }
  lab_0x80adc5e:
    // 0x80adc5e
    v8 = v7;
    if (*v3 == (int32_t)&aliases_utf8) {
        // 0x80adcd5
        return (char *)v7;
    }
    goto lab_0x80adc6a;
  lab_0x80adc71:;
    int32_t * v10 = (int32_t *)(4 * v4 + (int32_t)&g46); // 0x80adc74
    uint32_t nmemb = *v10; // 0x80adc74
    int32_t v11 = 360 * v4;
    int32_t v12 = nmemb; // 0x80adc7e
    int32_t v13; // 0x80adb10
    if (nmemb < 2) {
        goto lab_0x80adc8a;
    } else {
        // 0x80add80
        qsort((int32_t *)(v11 + (int32_t)&g47), nmemb, 36, (int32_t (*)(int32_t *, int32_t *))0x80ace80);
        int32_t v14 = *v10; // 0x80addb2
        v12 = v14;
        v13 = v14;
        if (v14 < 10) {
            goto lab_0x80adc8a;
        } else {
            goto lab_0x80adc97;
        }
    }
  lab_0x80adce8:;
    uint32_t v15 = *(int32_t *)(4 * v5 + (int32_t)&g46); // 0x80adceb
    v4 = v5;
    int32_t v16; // 0x80adb10
    if (v15 != 0) {
        int32_t v17 = 360 * v5; // 0x80adcfd
        bool v18; // 0x80adb10
        int32_t v19 = v18 ? -1 : 1;
        int32_t v20 = v17 + (int32_t)&g48; // 0x80add12
        int32_t v21 = 0;
        int32_t v22; // 0x80adb10
        int32_t v23; // 0x80adb10
        int32_t v24; // 0x80adb10
        int32_t v25; // 0x80adb10
        int32_t v26; // 0x80adb10
        int32_t * v27; // 0x80add54
        int32_t v28; // 0x80add54
        char v29; // 0x80add4d
        if (*(int32_t *)v20 == v2) {
            // 0x80add2e
            v26 = 36 * v21 + v17;
            v22 = strlen2;
            v23 = v26 + (int32_t)&g50;
            if (v22 == 0) {
                // 0x80add51
                v27 = (int32_t *)(v26 + (int32_t)&g47);
                v28 = *v27;
                if (v28 == -1) {
                    // 0x80add68
                    v16 = *(int32_t *)(v26 + (int32_t)&g49);
                    goto lab_0x80adcd5;
                } else {
                    // 0x80add5f
                    *v27 = v28 + 1;
                    // 0x80add68
                    v16 = *(int32_t *)(v26 + (int32_t)&g49);
                    goto lab_0x80adcd5;
                }
            }
            v25 = v1;
            v29 = *(char *)v23;
            v22--;
            v24 = v25 + v19;
            v23 += v19;
            while (*(char *)v25 == v29) {
                if (v22 == 0) {
                    // 0x80add51
                    v27 = (int32_t *)(v26 + (int32_t)&g47);
                    v28 = *v27;
                    if (v28 == -1) {
                        // 0x80add68
                        v16 = *(int32_t *)(v26 + (int32_t)&g49);
                        goto lab_0x80adcd5;
                    } else {
                        // 0x80add5f
                        *v27 = v28 + 1;
                        // 0x80add68
                        v16 = *(int32_t *)(v26 + (int32_t)&g49);
                        goto lab_0x80adcd5;
                    }
                }
                v25 = v24;
                v29 = *(char *)v23;
                v22--;
                v24 = v25 + v19;
                v23 += v19;
            }
        }
        int32_t v30 = v21 + 1; // 0x80add18
        v4 = v5;
        v20 += 36;
        while (v15 > v30) {
            // 0x80add27
            v21 = v30;
            if (*(int32_t *)v20 == v2) {
                // 0x80add2e
                v26 = 36 * v21 + v17;
                v22 = strlen2;
                v23 = v26 + (int32_t)&g50;
                if (v22 == 0) {
                    // 0x80add51
                    v27 = (int32_t *)(v26 + (int32_t)&g47);
                    v28 = *v27;
                    if (v28 == -1) {
                        // 0x80add68
                        v16 = *(int32_t *)(v26 + (int32_t)&g49);
                        goto lab_0x80adcd5;
                    } else {
                        // 0x80add5f
                        *v27 = v28 + 1;
                        // 0x80add68
                        v16 = *(int32_t *)(v26 + (int32_t)&g49);
                        goto lab_0x80adcd5;
                    }
                }
                v25 = v1;
                v29 = *(char *)v23;
                v22--;
                v24 = v25 + v19;
                v23 += v19;
                while (*(char *)v25 == v29) {
                    if (v22 == 0) {
                        // 0x80add51
                        v27 = (int32_t *)(v26 + (int32_t)&g47);
                        v28 = *v27;
                        if (v28 == -1) {
                            // 0x80add68
                            v16 = *(int32_t *)(v26 + (int32_t)&g49);
                            goto lab_0x80adcd5;
                        } else {
                            // 0x80add5f
                            *v27 = v28 + 1;
                            // 0x80add68
                            v16 = *(int32_t *)(v26 + (int32_t)&g49);
                            goto lab_0x80adcd5;
                        }
                    }
                    v25 = v24;
                    v29 = *(char *)v23;
                    v22--;
                    v24 = v25 + v19;
                    v23 += v19;
                }
            }
            // 0x80add18
            v30 = v21 + 1;
            v4 = v5;
            v20 += 36;
        }
    }
    goto lab_0x80adb6f;
  lab_0x80adb5f:
    // 0x80adb5f
    v4 = 0;
    v5 = 0;
    if (strlen2 < 9) {
        goto lab_0x80adce8;
    } else {
        goto lab_0x80adb6f;
    }
  lab_0x80adc6a:
    // 0x80adc6a
    v9 = v8;
    if (strlen2 >= 20) {
        // 0x80adcd5
        return (char *)v8;
    }
    goto lab_0x80adc71;
  lab_0x80adc8a:;
    int32_t v48 = v12 + 1; // 0x80adc8d
    *v10 = v48;
    v13 = v48;
    goto lab_0x80adc97;
  lab_0x80adc97:;
    int32_t v49 = v11 - 36 + 36 * v13; // 0x80adc9a
    *(int32_t *)(v49 + (int32_t)&g47) = 1;
    *(int32_t *)(v49 + (int32_t)&g47 + 4) = strlen2;
    *(int32_t *)(v49 + (int32_t)&g47 + 12) = v9;
    *(int32_t *)(v49 + (int32_t)&g47 + 8) = v2;
    int32_t v50 = v49 + (int32_t)&g47 + 16; // 0x80adcba
    memcpy((int32_t *)v50, (int32_t *)str, strlen2);
    *(char *)(v50 + strlen2) = 0;
    v16 = v9;
  lab_0x80adcd5:
    // 0x80adcd5
    return (char *)v16;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/intl/charsets.c
// Address range: 0x80ade90 - 0x80ae23a
// Line range:    1181 - 1263
char * convert_string_elinks(int32_t * convert_table, char * chars, uint32_t charslen, int32_t cp, int32_t mode, int32_t * length, void (*callback)(char *, char *, int32_t), char * callback_data) {
    char * buffer; // bp-36, 0x80ade90
    if (convert_table == NULL) {
        // 0x80adecd
        if (memchr((int32_t *)chars, 38, charslen) == NULL) {
            if (callback == NULL) {
                // 0x80ae0e0
                return memacpy(chars, charslen);
            }
            // 0x80adef0
            buffer = NULL;
            // 0x80adeff
            return NULL;
        }
    }
    char * v1 = mem_alloc(257); // 0x80adf17
    buffer = v1;
    if (v1 == NULL) {
        // 0x80adeff
        return NULL;
    }
    // 0x80adf23
    buffer = v1;
    int32_t v2 = 0; // 0x80adf30
    int32_t v3; // 0x80ade90
    char v4; // 0x80ade90
    int32_t v5; // 0x80ade90
    int32_t v6; // 0x80ade90
    int32_t v7; // 0x80ade90
    int32_t v8; // 0x80ade90
    int32_t v9; // 0x80ade90
    int32_t v10; // 0x80ade90
    int32_t v11; // 0x80ae05e
    int32_t v12; // 0x80ae031
    int32_t v13; // 0x80ade90
    char * v14; // 0x80adf45
    unsigned char v15; // 0x80adf48
    if (charslen >= 1) {
        // 0x80adf3f
        v13 = (int32_t)chars;
        v5 = 0;
        v8 = 0;
        while (true) {
          lab_0x80adf3f:
            // 0x80adf3f
            v9 = v8;
            v6 = v5;
            int32_t v16 = v6 + v13; // 0x80adf42
            v14 = (char *)v16;
            v15 = *v14;
            if (v15 == 38) {
                if ((mode & -2) == 2) {
                    // 0x80ae0c8
                    *(char *)(v9 + (int32_t)buffer) = 38;
                    v7 = v6 + 1;
                    goto lab_0x80adf7c;
                } else {
                    // 0x80ae056
                    v11 = v6 + 1;
                    int32_t v17 = v16; // 0x80ae068
                    int32_t v18 = v11; // 0x80ae068
                    int32_t v19 = v11; // 0x80ae068
                    if (v11 < charslen) {
                        int32_t v20 = v18;
                        int32_t v21 = v17 + 1; // 0x80ae070
                        char v22 = *(char *)v21; // 0x80ae070
                        v19 = v20;
                        while (v22 != 35 != (v22 > 57 == (v22 & -33) > 90)) {
                            int32_t v23 = v20 + 1; // 0x80ae090
                            v17 = v21;
                            v18 = v23;
                            v19 = v23;
                            if (v23 >= charslen) {
                                // break -> 0x80ae09c
                                break;
                            }
                            v20 = v18;
                            v21 = v17 + 1;
                            v22 = *(char *)v21;
                            v19 = v20;
                        }
                    }
                    // 0x80ae09c
                    v10 = v19;
                    if (mode == 0) {
                        if (v10 > v11) {
                            int32_t v24 = v10 + v13; // 0x80ae104
                            v4 = *(char *)v24;
                            v3 = v24;
                            goto lab_0x80ae101;
                        } else {
                            goto lab_0x80ae0ae;
                        }
                    } else {
                        if (v10 > v11) {
                            int32_t v25 = v10 + v13;
                            char v26 = *(char *)v25; // 0x80ae0a6
                            v4 = v26;
                            v3 = v25;
                            switch (v26) {
                                case 61: {
                                    goto lab_0x80ae0ae;
                                }
                                case 38: {
                                    goto lab_0x80ae0ae;
                                }
                                default: {
                                    goto lab_0x80ae101;
                                }
                            }
                        } else {
                            goto lab_0x80ae0ae;
                        }
                    }
                }
            } else {
                if (convert_table != NULL == v15 < 0) {
                    // 0x80ae02b
                    v12 = 8 * (int32_t)v15 + (int32_t)convert_table;
                    if (*(int32_t *)v12 == 0) {
                        goto lab_0x80ae170;
                    } else {
                        int32_t v27; // 0x80ade90
                        while (v27 < charslen) {
                            // 0x80ae028
                            int32_t v28; // 0x80ade90
                            int32_t v29 = v28;
                            int32_t v30; // 0x80ade90
                            int32_t v31 = v30;
                            int32_t v32 = v29 + 1; // 0x80ae041
                            int32_t v33 = *(int32_t *)(v31 + 4); // 0x80ae044
                            unsigned char v34 = *(char *)v32; // 0x80ae028
                            int32_t v35 = 8 * (int32_t)v34 + v33; // 0x80ae031
                            int32_t v36 = *(int32_t *)v35; // 0x80ae034
                            uint32_t v37; // 0x80ade90
                            int32_t v38 = v37 + 1;
                            v27 = v38;
                            v30 = v35;
                            v28 = v32;
                            if (v36 == 0) {
                                goto lab_0x80ae170;
                            }
                            v37 = v27;
                        }
                        goto lab_0x80adf66;
                    }
                } else {
                    // 0x80adf57
                    goto lab_0x80adf66;
                }
            }
        }
      lab_0x80adfd4:;
    }
    // 0x80adfd4
    *(char *)(v2 + (int32_t)buffer) = 0;
    if (length != NULL) {
        // 0x80adfe2
        *length = v2;
    }
    char * result; // 0x80ade90
    if (callback == NULL) {
        // 0x80adfe7
        result = buffer;
    } else {
        // 0x80adffa
        mem_free(buffer);
        buffer = NULL;
        result = NULL;
    }
  lab_0x80adeff:
    // 0x80adeff
    return result;
  lab_0x80ae170:;
    int32_t v39 = *(int32_t *)(v12 + 4); // 0x80ae176
    int32_t v40 = v6 + 1; // 0x80ae176
    goto lab_0x80ae179;
  lab_0x80adf7c:;
    int32_t v66 = v9 + 1;
    int32_t v58 = v7; // 0x80adf80
    int32_t v59 = v66; // 0x80adf80
    int32_t v60 = &g14; // 0x80adf80
    int32_t v67 = v7; // 0x80adf80
    int32_t v68 = v66; // 0x80adf80
    int32_t v69 = &g14; // 0x80adf80
    if ((char)v66 != 0) {
        goto lab_0x80adfa9;
    } else {
        goto lab_0x80adf82;
    }
  lab_0x80adf66:
    // 0x80adf66
    *(char *)(v9 + (int32_t)buffer) = v15;
    v7 = v6 + 1;
    goto lab_0x80adf7c;
  lab_0x80adfa9:;
    char v70 = *(char *)v69; // 0x80adfa9
    int32_t v52 = v67; // 0x80adfae
    char v53 = v70; // 0x80adfae
    int32_t v54 = v68; // 0x80adfae
    int32_t v51 = v69; // 0x80adfae
    int32_t v44 = v67; // 0x80adfae
    int32_t v45 = v68; // 0x80adfae
    if (v70 == 0) {
        goto lab_0x80adfc9;
    } else {
        goto lab_0x80adfb0;
    }
  lab_0x80adf82:;
    int32_t v71 = v60;
    int32_t v72 = v59;
    int32_t v73 = v58;
    if (callback == NULL) {
        char * v74 = mem_realloc(buffer, v72 + 256); // 0x80ae1bb
        if (v74 == NULL) {
            // 0x80ae20a
            char * v75; // 0x80ade90
            mem_free(v75);
            buffer = NULL;
            result = NULL;
            goto lab_0x80adeff;
        }
        // 0x80ae1c7
        buffer = v74;
        v67 = v73;
        v68 = v72;
        v69 = v71;
    } else {
        // 0x80adf8d
        *(char *)(v72 + (int32_t)buffer) = 0;
        v67 = v73;
        v68 = 0;
        v69 = v71;
    }
    goto lab_0x80adfa9;
  lab_0x80ae0ae:
    // 0x80ae0ae
    *(char *)(v9 + (int32_t)buffer) = 38;
    v7 = v11;
    goto lab_0x80adf7c;
  lab_0x80ae179:;
    int32_t v41 = v40;
    int32_t v42 = v39;
    char v43 = *(char *)v42; // 0x80ae179
    v44 = v41;
    v45 = v9;
    int32_t v46; // 0x80ade90
    char v47; // 0x80ade90
    int32_t v48; // 0x80ade90
    int32_t v49; // 0x80ade90
    if (v43 == 0) {
        goto lab_0x80adfc9;
    } else {
        int32_t v50 = v42 + 1;
        v49 = v50;
        v46 = v41;
        v47 = v43;
        v48 = v9;
        if (*(char *)v50 != 0) {
            goto lab_0x80adfb3;
        } else {
            // 0x80ae193
            *(char *)(v9 + (int32_t)buffer) = v43;
            v7 = v41;
            goto lab_0x80adf7c;
        }
    }
  lab_0x80adfc9:
    // 0x80adfc9
    v2 = v45;
    v5 = v44;
    v8 = v2;
    if (v44 >= charslen) {
        // break -> 0x80adfd4
        goto lab_0x80adfd4;
    }
    goto lab_0x80adf3f;
  lab_0x80adfb0:
    // 0x80adfb0
    v49 = v51 + 1;
    v46 = v52;
    v47 = v53;
    v48 = v54;
    goto lab_0x80adfb3;
  lab_0x80ae101:;
    char v62 = v4; // 0x80ae109
    if (v62 < 58 || (v62 & -33) < 91) {
        goto lab_0x80ae0ae;
    } else {
        char * v63 = get_entity_string((char *)(v11 + v13), v10 - v11, cp); // 0x80ae13f
        if (v63 == NULL) {
            // 0x80ae221
            *(char *)(v9 + (int32_t)buffer) = *v14;
            v7 = v11;
            goto lab_0x80adf7c;
        } else {
            int32_t v64 = v10 - (int32_t)(*(char *)(0x1000000 * v3 >> 24) != 59); // 0x80ae154
            int32_t v65 = v64 - charslen; // 0x80ae160
            v39 = (int32_t)v63;
            v40 = v64 + (int32_t)(v65 < 0 != ((v65 ^ v64) & (v64 ^ charslen)) < 0);
            goto lab_0x80ae179;
        }
    }
  lab_0x80adfb3:;
    int32_t v55 = v46;
    int32_t v56 = v49;
    int32_t v57 = v48 + 1; // 0x80adfb6
    *(char *)(v48 + (int32_t)buffer) = v47;
    v58 = v55;
    v59 = v57;
    v60 = v56;
    if ((char)v57 == 0) {
        goto lab_0x80adf82;
    } else {
        char v61 = *(char *)v56; // 0x80adfc2
        v52 = v55;
        v53 = v61;
        v54 = v57;
        v51 = v56;
        v44 = v55;
        v45 = v57;
        if (v61 != 0) {
            goto lab_0x80adfb0;
        } else {
            goto lab_0x80adfc9;
        }
    }
}

// Address range: 0x80ae240 - 0x80ae523
int32_t T_163(void) {
    // 0x80ae240
    int32_t v1; // 0x80ae240
    uint32_t v2 = v1;
    *(int32_t *)&utf_buffer = 0;
    *(int16_t *)&g54 = 0;
    *(char *)&g56 = 0;
    if (v2 < 128) {
        // 0x80ae418
        utf_buffer[0] = v2;
    } else {
        if (v2 < 2048) {
            // 0x80ae300
            utf_buffer[0] = (char)(v2 / 64) % 32 | -64;
            *(char *)&g51 = (char)v2 % 64 | -128;
        } else {
            if (v2 < 0x10000) {
                // 0x80ae4a0
                utf_buffer[0] = (char)(v2 / 0x1000) % 16 | -32;
                *(char *)&g51 = (char)(v2 / 64) % 64 | -128;
                *(char *)&g52 = (char)v2 % 64 | -128;
            } else {
                if (v2 < 0x200000) {
                    // 0x80ae422
                    utf_buffer[0] = (char)(v2 / 0x40000) | -16;
                    *(char *)&g51 = (char)(v2 / 0x1000) % 64 | -128;
                    *(char *)&g52 = (char)(v2 / 64) % 64 | -128;
                    *(char *)&g53 = (char)v2 % 64 | -128;
                } else {
                    if (v2 < 0x4000000) {
                        // 0x80ae4d2
                        utf_buffer[0] = (char)(v2 / 0x1000000) | -8;
                        *(char *)&g51 = (char)(v2 / 0x40000) % 64 | -128;
                        *(char *)&g52 = (char)(v2 / 0x1000) % 64 | -128;
                        *(char *)&g53 = (char)(v2 / 64) % 64 | -128;
                        *(char *)&g54 = (char)v2 % 64 | -128;
                    } else {
                        // 0x80ae29b
                        utf_buffer[0] = (char)(v2 / 0x40000000) % 2 | -4;
                        *(char *)&g51 = (char)(v2 / 0x1000000) % 64 | -128;
                        *(char *)&g52 = (char)(v2 / 0x40000) % 64 | -128;
                        *(char *)&g53 = (char)(v2 / 0x1000) % 64 | -128;
                        *(char *)&g54 = (char)(v2 / 64) % 64 | -128;
                        *(char *)&g55 = (char)v2 % 64 | -128;
                    }
                }
            }
        }
    }
    int32_t v3 = (int32_t)&utf_buffer + 1; // 0x80ae336
    int32_t v4 = &table_elinks; // 0x80ae336
    int32_t v5 = (int32_t)&utf_buffer; // 0x80ae336
    int32_t result = (int32_t)&utf_buffer; // 0x80ae336
    int32_t v6 = &table_elinks; // 0x80ae336
    if (*(char *)((int32_t)&utf_buffer + 1) == 0) {
      lab_0x80ae3e0:
        // 0x80ae3e0
        if (assert_failed != 0) {
            // 0x80ae3c9
            assert_failed = 0;
            // 0x80ae3d3
            return result;
        }
        char * v7 = (char *)result; // 0x80ae3ea
        int32_t v8 = *(int32_t *)(8 * (int32_t)*v7 + v6); // 0x80ae3ed
        assert_failed = v8 != 0;
        if (v8 != 0) {
            // 0x80ae462
            errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/intl/charsets.c";
            errline = 803;
            elinks_internal("assertion !ct[*p].t failed: bad utf encoding #2");
            if (assert_failed != 0) {
                // 0x80ae3c9
                assert_failed = 0;
                // 0x80ae3d3
                return result;
            }
        }
        int32_t result2 = 8 * (int32_t)*v7 + v6; // 0x80ae404
        if (*(int32_t *)(result2 + 4) == (int32_t)"*") {
            // branch -> 0x80ae3d3
        }
        // 0x80ae3d3
        return result2;
    }
    int32_t result3; // 0x80ae240
    while (true) {
        int32_t v9 = v5;
        int32_t v10 = v4;
        v5 = v3;
        char * v11 = (char *)v9; // 0x80ae33c
        int32_t v12 = 8 * (int32_t)*v11 + v10; // 0x80ae340
        int32_t v13; // 0x80ae240
        if (*(int32_t *)v12 != 0) {
            // 0x80ae328
            v13 = *(int32_t *)(v12 + 4);
        } else {
            // 0x80ae349
            result3 = v12;
            if (assert_failed != 0) {
                // break -> 0x80ae3c9
                break;
            }
            int32_t v14 = *(int32_t *)(v12 + 4); // 0x80ae353
            assert_failed = v14 != (int32_t)"*";
            if (v14 != (int32_t)"*") {
                // 0x80ae3a0
                errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/intl/charsets.c";
                errline = 790;
                elinks_internal("assertion ct[*p].u.str == no_str failed: bad utf encoding #1");
                result3 = assert_failed;
                if (assert_failed != 0) {
                    // break -> 0x80ae3c9
                    break;
                }
            }
            char * v15 = mem_calloc(256, 8); // 0x80ae378
            if (v15 == NULL) {
                // 0x80ae3d3
                return 0;
            }
            int32_t v16 = (int32_t)v15; // 0x80ae378
            new_translation_table(&g83);
            *(int32_t *)(8 * (int32_t)*v11 + v10) = 1;
            *(int32_t *)(v10 + 4 + 8 * (int32_t)*v11) = v16;
            v13 = v16;
        }
        // 0x80ae32b
        v4 = v13;
        v3 = v5 + 1;
        result = v5;
        v6 = v4;
        if (*(char *)v3 == 0) {
            goto lab_0x80ae3e0;
        }
    }
    // 0x80ae3c9
    assert_failed = 0;
    // 0x80ae3d3
    return result3;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/intl/charsets.c
// Address range: 0x80ae530 - 0x80ae63b
// Line range:    753 - 237
char * cp2utf8(int32_t from, int32_t c) {
    if (c < 128) {
        // 0x80ae598
        return (char *)(2 * c + (int32_t)&strings);
    }
    int32_t v1 = 16 * from & -2064; // 0x80ae53b
    int32_t v2 = *(int32_t *)(v1 + (int32_t)&codepages + 4); // 0x80ae548
    if (v2 == (int32_t)&aliases_utf8) {
        // 0x80ae598
        return (char *)(2 * c + (int32_t)&strings);
    }
    int32_t v3 = *(int32_t *)(v1 + (int32_t)&codepages + 8); // 0x80ae551
    uint16_t v4 = *(int16_t *)((2 * c & 510) - 256 + v3); // 0x80ae557
    *(int32_t *)&utf_buffer = 0;
    *(int16_t *)&g54 = 0;
    *(char *)&g56 = 0;
    char v5 = -67; // 0x80ae564
    char v6 = -17; // 0x80ae564
    char v7 = -65; // 0x80ae564
    if (v4 != -1) {
        if (v4 < 128) {
            // 0x80ae585
            utf_buffer[0] = v4;
            return &utf_buffer[0];
        }
        uint16_t v8 = v4 / 64;
        v5 = (char)v4 % 64 | -128;
        if (v4 < 2048) {
            // 0x80ae5af
            *(char *)&g51 = v5;
            utf_buffer[0] = (char)v8 % 32 | -64;
            return &utf_buffer[0];
        }
        // 0x80ae620
        v6 = (char)(v4 / 0x1000) | -32;
        v7 = (char)v8 % 64 | -128;
    }
    // 0x80ae601
    *(char *)&g52 = v5;
    utf_buffer[0] = v6;
    *(char *)&g51 = v7;
    return &utf_buffer[0];
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/intl/charsets.c
// Address range: 0x80af2f0 - 0x80af71c
// Line range:    893 - 237
int32_t * get_translation_table(int32_t from, int32_t to) {
    // 0x80af2f0
    if (first != 0) {
        // 0x80af3c3
        __asm_rep_stosd_memset((char *)&table_elinks, 0, 512);
        first = 0;
    }
    int32_t v1 = from & -129; // 0x80af304
    int32_t v2 = to & -129; // 0x80af30a
    int32_t v3 = 16 * v2; // 0x80af317
    int32_t v4 = *(int32_t *)(v3 + (int32_t)&g2); // 0x80af31a
    if (v4 != (int32_t)&aliases_utf8) {
        // 0x80af32a
        if (v1 == g34) {
            // 0x80af3b0
            if (v2 == g33) {
                // 0x80af3a8
                return (int32_t *)(int32_t)&table_elinks;
            }
        }
        // 0x80af332
        g34 = v1;
        int32_t v5 = 16 * v1; // 0x80af33d
        g33 = v2;
        new_translation_table(&g83);
        int32_t v6 = *(int32_t *)(v5 + (int32_t)&g2); // 0x80af34b
        if (v6 != (int32_t)&aliases_utf8) {
            int32_t v7 = *(int32_t *)(v5 + (int32_t)&g3) - 256; // 0x80af368
            for (int32_t i = 128; i < 256; i++) {
                uint16_t v8 = *(int16_t *)(v7 + 2 * i); // 0x80af368
                if (v8 != -1) {
                    char * v9 = u2cp_((int32_t)v8, v2, 0); // 0x80af388
                    if (v9 != NULL) {
                        // 0x80af391
                        *(int32_t *)(8 * i + (int32_t)&g57) = (int32_t)v9;
                    }
                }
            }
            // 0x80af3a8
            return (int32_t *)(int32_t)&table_elinks;
        }
        // 0x80af3e2
        T_163();
        T_163();
        int32_t v10 = *(int32_t *)(v3 + (int32_t)&g3); // 0x80af407
        int32_t v11 = 0;
        if (*(int16_t *)(v11 + v10) != -1) {
            // 0x80af41a
            T_163();
        }
        int32_t v12 = v11 + 2; // 0x80af431
        while (v11 != 254) {
            // 0x80af410
            v11 = v12;
            if (*(int16_t *)(v11 + v10) != -1) {
                // 0x80af41a
                T_163();
            }
            // 0x80af428
            v12 = v11 + 2;
        }
        int32_t v13 = *(int32_t *)(v3 + (int32_t)&g4); // 0x80af436
        if (*(char *)v13 != 0) {
            int32_t v14 = v13 + 4;
            T_163();
            int32_t v15 = v14; // 0x80af463
            while (*(char *)v14 != 0) {
                // 0x80af446
                v14 = v15 + 4;
                T_163();
                v15 = v14;
            }
        }
        int32_t v16 = *(int32_t *)((int32_t)&unicode_7b + 8); // 0x80af46b
        if (v16 == -1) {
            // 0x80af3a8
            return (int32_t *)(int32_t)&table_elinks;
        }
        int32_t v17 = 1; // 0x80af475
        if (v16 >= 128) {
            // 0x80af480
            T_163();
        }
        // 0x80af468
        v17++;
        int32_t v18 = *(int32_t *)(8 * v17 + (int32_t)&unicode_7b); // 0x80af46b
        while (v18 != -1) {
            // 0x80af47b
            if (v18 >= 128) {
                // 0x80af480
                T_163();
            }
            // 0x80af468
            v17++;
            v18 = *(int32_t *)(8 * v17 + (int32_t)&unicode_7b);
        }
        // 0x80af3a8
        return (int32_t *)(int32_t)&table_elinks;
    }
    // 0x80af48e
    if (v1 == g35) {
        // 0x80af3a8
        return (int32_t *)(int32_t)&utf_table;
    }
    // 0x80af4a0
    g35 = v1;
    if (utf_table_init != 0) {
        // 0x80af6d2
        __asm_rep_stosd_memset((char *)&utf_table, 0, 512);
        utf_table_init = 0;
    } else {
        int32_t v19 = 128;
        int32_t v20 = *(int32_t *)(8 * v19 + (int32_t)&g79); // 0x80af4b8
        mem_free((char *)v20);
        int32_t v21 = v19 + 1; // 0x80af4d0
        while (v19 != 255) {
            // 0x80af4b8
            v19 = v21;
            v20 = *(int32_t *)(8 * v19 + (int32_t)&g79);
            mem_free((char *)v20);
            v21 = v19 + 1;
        }
    }
    int32_t v22 = 0;
    *(int32_t *)(4 * v22 + (int32_t)&g79) = v22 + (int32_t)&strings;
    int32_t v23 = v22 + 2; // 0x80af4f5
    while (v22 != 254) {
        // 0x80af4e0
        v22 = v23;
        *(int32_t *)(4 * v22 + (int32_t)&g79) = v22 + (int32_t)&strings;
        v23 = v22 + 2;
    }
    int32_t v24 = 16 * v1; // 0x80af4f9
    int32_t v25 = *(int32_t *)(v24 + (int32_t)&g2); // 0x80af4fc
    if (v25 == (int32_t)&aliases_utf8) {
        int32_t v26 = 0;
        char * v27 = stracpy((char *)(v26 + (int32_t)&g6)); // 0x80af5e8
        *(int32_t *)(4 * v26 + (int32_t)&g80) = (int32_t)v27;
        int32_t v28 = v26 + 2; // 0x80af5fd
        while (v26 != 254) {
            // 0x80af5df
            v26 = v28;
            v27 = stracpy((char *)(v26 + (int32_t)&g6));
            *(int32_t *)(4 * v26 + (int32_t)&g80) = (int32_t)v27;
            v28 = v26 + 2;
        }
        // 0x80af3a8
        return (int32_t *)(int32_t)&utf_table;
    }
    int32_t v29 = *(int32_t *)(v24 + (int32_t)&g3) - 256; // 0x80af542
    int32_t v30 = 128;
    uint16_t v31 = *(int16_t *)(v29 + 2 * v30); // 0x80af542
    char * v32; // 0x80af5a7
    if (v31 == -1) {
        // 0x80af528
        *(int32_t *)(8 * v30 + (int32_t)&g79) = 0;
    } else {
        // 0x80af551
        *(int32_t *)&utf_buffer = 0;
        *(int16_t *)&g54 = 0;
        *(char *)&g56 = 0;
        if (v31 < 128) {
            // 0x80af5b8
            utf_buffer[0] = v31;
        } else {
            if (v31 < 2048) {
                // 0x80af5bf
                utf_buffer[0] = (char)(v31 / 64) % 32 | -64;
                *(char *)&g51 = (char)v31 % 64 | -128;
            } else {
                // 0x80af571
                utf_buffer[0] = (char)(v31 / 0x1000) | -32;
                *(char *)&g51 = (char)(v31 / 64) % 64 | -128;
                *(char *)&g52 = (char)v31 % 64 | -128;
            }
        }
        // 0x80af5a0
        v32 = stracpy(utf_buffer);
        *(int32_t *)(8 * v30 + (int32_t)&g79) = (int32_t)v32;
    }
    int32_t v33 = v30 + 1; // 0x80af53c
    while (v30 != 255) {
        // 0x80af542
        v30 = v33;
        v31 = *(int16_t *)(v29 + 2 * v30);
        if (v31 == -1) {
            // 0x80af528
            *(int32_t *)(8 * v30 + (int32_t)&g79) = 0;
        } else {
            // 0x80af551
            *(int32_t *)&utf_buffer = 0;
            *(int16_t *)&g54 = 0;
            *(char *)&g56 = 0;
            if (v31 < 128) {
                // 0x80af5b8
                utf_buffer[0] = v31;
            } else {
                if (v31 < 2048) {
                    // 0x80af5bf
                    utf_buffer[0] = (char)(v31 / 64) % 32 | -64;
                    *(char *)&g51 = (char)v31 % 64 | -128;
                } else {
                    // 0x80af571
                    utf_buffer[0] = (char)(v31 / 0x1000) | -32;
                    *(char *)&g51 = (char)(v31 / 64) % 64 | -128;
                    *(char *)&g52 = (char)v31 % 64 | -128;
                }
            }
            // 0x80af5a0
            v32 = stracpy(utf_buffer);
            *(int32_t *)(8 * v30 + (int32_t)&g79) = (int32_t)v32;
        }
        // 0x80af533
        v33 = v30 + 1;
    }
    int32_t v34 = *(int32_t *)(v24 + (int32_t)&g4); // 0x80af60f
    char v35 = *(char *)v34; // 0x80af615
    if (v35 != 0) {
        int32_t v36 = 8 * (int32_t)v35; // 0x80af626
        uint16_t v37; // 0x80af622
        char * v38; // 0x80af6c1
        if (*(int32_t *)(v36 + (int32_t)&g79) == 0) {
            // 0x80af673
            v37 = *(int16_t *)(v34 + 2);
            __asm_rep_stosb_memset(utf_buffer, 0, 7);
            if (v37 < 128) {
                // 0x80af6f6
                utf_buffer[0] = v37;
            } else {
                if (v37 < 2048) {
                    // 0x80af6fe
                    utf_buffer[0] = (char)(v37 / 64) % 32 | -64;
                    *(char *)&g51 = (char)v37 % 64 | -128;
                } else {
                    // 0x80af691
                    utf_buffer[0] = (char)(v37 / 0x1000) | -32;
                    *(char *)&g51 = (char)(v37 / 64) % 64 | -128;
                    *(char *)&g52 = (char)v37 % 64 | -128;
                }
            }
            // 0x80af6ba
            v38 = stracpy(utf_buffer);
            *(int32_t *)(v36 + (int32_t)&utf_table + 4) = (int32_t)v38;
        }
        int32_t v39 = v34 + 4;
        char v40 = *(char *)v39; // 0x80af631
        while (v40 != 0) {
            int32_t v41 = v39;
            v36 = 8 * (int32_t)v40;
            if (*(int32_t *)(v36 + (int32_t)&g79) == 0) {
                // 0x80af673
                v37 = *(int16_t *)(v41 + 2);
                __asm_rep_stosb_memset(utf_buffer, 0, 7);
                if (v37 < 128) {
                    // 0x80af6f6
                    utf_buffer[0] = v37;
                } else {
                    if (v37 < 2048) {
                        // 0x80af6fe
                        utf_buffer[0] = (char)(v37 / 64) % 32 | -64;
                        *(char *)&g51 = (char)v37 % 64 | -128;
                    } else {
                        // 0x80af691
                        utf_buffer[0] = (char)(v37 / 0x1000) | -32;
                        *(char *)&g51 = (char)(v37 / 64) % 64 | -128;
                        *(char *)&g52 = (char)v37 % 64 | -128;
                    }
                }
                // 0x80af6ba
                v38 = stracpy(utf_buffer);
                *(int32_t *)(v36 + (int32_t)&utf_table + 4) = (int32_t)v38;
            }
            // 0x80af631
            v39 = v41 + 4;
            v40 = *(char *)v39;
        }
    }
    int32_t v42 = 128;
    int32_t * v43 = (int32_t *)(8 * v42 + (int32_t)&g79); // 0x80af653
    if (*v43 == 0) {
        // 0x80af65e
        *v43 = (int32_t)stracpy("*");
    }
    int32_t v44 = v42 + 1; // 0x80af651
    while (v42 != 255) {
        // 0x80af653
        v42 = v44;
        v43 = (int32_t *)(8 * v42 + (int32_t)&g79);
        if (*v43 == 0) {
            // 0x80af65e
            *v43 = (int32_t)stracpy("*");
        }
        // 0x80af648
        v44 = v42 + 1;
    }
    // 0x80af3a8
    return (int32_t *)(int32_t)&utf_table;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/intl/gettext/dcgettext.c
// Address range: 0x80b0030 - 0x80b0069
// Line range:    30 - 33
char * dcgettext__(char * domainname, char * msgid, int32_t category) {
    // 0x80b0030
    return dcigettext__(domainname, msgid, NULL, 0, 0, category);
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/intl/gettext/dcigettext.c
// Address range: 0x80b0070 - 0x80b01f5
// Line range:    800 - 870
int32_t plural_eval(int32_t * pexp, int32_t n) {
    // 0x80b0070
    int32_t v1; // 0x80b0070
    if (v1 == 1) {
        // 0x80b009c
        return plural_eval(&g83, (int32_t)&g83) == 0;
    }
    int32_t v2; // 0x80b0070
    int32_t v3; // 0x80b0070
    int32_t result; // 0x80b0070
    while (true) {
      lab_0x80b008a:;
        // 0x80b008a
        int32_t v4; // 0x80b0070
        v3 = v4;
        int32_t v5; // 0x80b0070
        v2 = v5;
        int32_t v6; // 0x80b0070
        int32_t v7; // 0x80b0070
        if (v7 <= v6) {
            // break -> 0x80b0128
            break;
        }
        // 0x80b0090
        result = 0;
        switch (v2) {
            case 2: {
                uint32_t v8 = plural_eval(&g83, (int32_t)&g83); // 0x80b00b5
                int32_t * v9 = (int32_t *)(v3 + 4); // 0x80b00bc
                int32_t v10 = *v9; // 0x80b00bc
                if (v10 == 15) {
                    // 0x80b0118
                    if (v8 != 0) {
                        // 0x80b009c
                        return 1;
                    }
                    // 0x80b009c
                    return plural_eval(&g83, (int32_t)&g83) != 0;
                }
                if (v10 == 14) {
                    // 0x80b00cd
                    if (v8 == 0) {
                        // 0x80b009c
                        return 0;
                    }
                    // 0x80b009c
                    return plural_eval(&g83, (int32_t)&g83) != 0;
                }
                uint32_t v11 = plural_eval(&g83, (int32_t)&g83); // 0x80b0155
                int32_t v12 = *v9; // 0x80b015c
                g87 = v12 - 3;
                result = 0;
                switch (v12) {
                    case 3: {
                        // 0x80b01de
                        result = v11 * v8;
                        // break -> 0x80b009c
                        break;
                    }
                    case 4: {
                        // 0x80b01d1
                        result = v8 / v11;
                        // break -> 0x80b009c
                        break;
                    }
                    case 5: {
                        // 0x80b01c4
                        result = v8 % v11;
                        // break -> 0x80b009c
                        break;
                    }
                    case 6: {
                        // 0x80b01bc
                        result = v11 + v8;
                        // break -> 0x80b009c
                        break;
                    }
                    case 7: {
                        // 0x80b01b3
                        result = v8 - v11;
                        // break -> 0x80b009c
                        break;
                    }
                    case 8: {
                        // 0x80b01a6
                        result = v8 < v11;
                        // break -> 0x80b009c
                        break;
                    }
                    case 9: {
                        // 0x80b0199
                        result = v8 > v11;
                        // break -> 0x80b009c
                        break;
                    }
                    case 10: {
                        // 0x80b018c
                        result = v8 <= v11;
                        // break -> 0x80b009c
                        break;
                    }
                    case 11: {
                        // 0x80b017f
                        result = v8 >= v11;
                        // break -> 0x80b009c
                        break;
                    }
                    case 12: {
                        // 0x80b0172
                        result = v8 == v11;
                        // break -> 0x80b009c
                        break;
                    }
                    case 13: {
                        // 0x80b01e8
                        result = v8 != v11;
                        // break -> 0x80b009c
                        break;
                    }
                }
                // 0x80b009c
                return result;
            }
            case 3: {
                int32_t v13 = plural_eval(&g83, (int32_t)&g83); // 0x80b00ed
                int32_t v14 = *(int32_t *)(v3 + 16 + 4 * (int32_t)(v13 != 0)); // 0x80b00f9
                int32_t v15 = *(int32_t *)v14; // 0x80b00fd
                v6 = 1;
                v5 = v15;
                v7 = v15;
                v4 = v14;
                if (v15 == 1) {
                    // 0x80b009c
                    return plural_eval(&g83, (int32_t)&g83) == 0;
                }
                goto lab_0x80b008a;
            }
            default: {
                return result;
            }
        }
    }
    // 0x80b0128
    result = 0;
    if (v2 != 0) {
        // 0x80b009c
        return result;
    }
    int32_t v16 = *(int32_t *)(v3 + 4); // 0x80b0130
    if (v16 == 0) {
        // 0x80b009c
        return result;
    }
    int32_t result2 = 0; // 0x80b0140
    if (v16 == 1) {
        // 0x80b0146
        result2 = *(int32_t *)(v3 + 8);
    }
    // 0x80b009c
    return result2;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/intl/gettext/dcigettext.c
// Address range: 0x80b0250 - 0x80b075d
// Line range:    552 - 746
char * _nl_find_msg(int32_t * domain_file, int32_t * domainbinding, char * msgid, int32_t * lengthp) {
    int32_t v1 = (int32_t)domain_file;
    if (*(int32_t *)(v1 + 12) == 0) {
        // 0x80b04c0
        _nl_load_domain(domain_file, domainbinding);
    }
    int32_t v2 = *(int32_t *)(v1 + 16); // 0x80b026d
    if (v2 == 0) {
        // 0x80b03f1
        return NULL;
    }
    uint32_t v3 = *(int32_t *)(v2 + 28); // 0x80b0278
    int32_t v4; // 0x80b0250
    int32_t v5; // 0x80b0250
    int32_t v6; // 0x80b0250
    int32_t v7; // 0x80b0250
    if (v3 >= 3) {
        int32_t v8 = *(int32_t *)(v2 + 32); // 0x80b0287
        if (v8 != 0) {
            uint32_t len = strlen(msgid); // 0x80b029b
            char v9 = *msgid; // 0x80b02c3
            int32_t v10 = 0; // 0x80b02c8
            if (v9 != 0) {
                int32_t v11 = v9; // 0x80b02ae
                uint32_t v12 = v11 & -0x10000000; // 0x80b02b2
                int32_t v13 = v11; // 0x80b02b7
                if (v12 != 0) {
                    // 0x80b02b9
                    v13 = v12 / 0x1000000 ^ v11 % 0x10000000;
                }
                int32_t v14 = (int32_t)msgid + 1; // 0x80b02c0
                char v15 = *(char *)v14; // 0x80b02c3
                int32_t v16 = v14; // 0x80b02c8
                v10 = v13;
                while (v15 != 0) {
                    // 0x80b02a8
                    v11 = 16 * v13 + (int32_t)v15;
                    v12 = v11 & -0x10000000;
                    v13 = v11;
                    if (v12 != 0) {
                        // 0x80b02b9
                        v13 = v12 / 0x1000000 ^ v11 % 0x10000000;
                    }
                    // 0x80b02c0
                    v14 = v16 + 1;
                    v15 = *(char *)v14;
                    v16 = v14;
                    v10 = v13;
                }
            }
            int32_t v17 = v10 % (v3 - 2) + 1; // 0x80b02e8
            int32_t v18 = *(int32_t *)(v2 + 12); // 0x80b02f7
            int32_t v19 = v10 % v3; // 0x80b0303
            while (true) {
                uint32_t v20 = v19;
                int32_t v21 = *(int32_t *)(4 * v20 + v8);
                int32_t v22; // 0x80b0250
                if (v18 != 0) {
                    // 0x80b0308
                    v22 = llvm_bswap_i32(v21);
                    if (v21 == 0) {
                        // break -> 0x80b03f1
                        break;
                    }
                } else {
                    // 0x80b03e3
                    v22 = v21;
                    if (v21 == 0) {
                        // break -> 0x80b03f1
                        break;
                    }
                }
                int32_t v23 = v22 - 1;
                int32_t v24 = 8 * v23;
                int32_t v25 = v24 + *(int32_t *)(v2 + 20);
                int32_t v26 = *(int32_t *)v25;
                if ((v18 == 0 ? v26 : llvm_bswap_i32(v26)) >= len) {
                    int32_t v27 = *(int32_t *)v2; // 0x80b037e
                    int32_t v28 = *(int32_t *)(v25 + 4);
                    int32_t strcmp_rc = strcmp(msgid, (char *)((v18 == 0 ? v28 : llvm_bswap_i32(v28)) + v27)); // 0x80b03be
                    v4 = v24;
                    v7 = v27;
                    v6 = v23;
                    v5 = v18;
                    if (strcmp_rc == 0) {
                        goto lab_0x80b0425;
                    }
                }
                // 0x80b03c7
                v19 = v20 + v17 + (v20 < v3 - v17 ? 0 : -v3);
            }
            // 0x80b03f1
            return NULL;
        }
    }
    int32_t v29 = *(int32_t *)(v2 + 16); // 0x80b04d8
    if (v29 == 0) {
        // 0x80b03f1
        return NULL;
    }
    int32_t v30 = v29;
    uint32_t v31 = 0;
    int32_t v32 = *(int32_t *)(v2 + 12); // 0x80b04ee
    int32_t v33 = *(int32_t *)v2; // 0x80b04f4
    int32_t v34 = (v30 + v31) / 2; // 0x80b055c
    int32_t v35 = 8 * v34;
    int32_t v36 = *(int32_t *)(*(int32_t *)(v2 + 20) + 4 + v35);
    int32_t strcmp_rc2 = strcmp(msgid, (char *)((v32 != 0 ? llvm_bswap_i32(v36) : v36) + v33)); // 0x80b053b
    while (strcmp_rc2 < 0) {
        // 0x80b0548
        if (v34 <= v31) {
            // 0x80b03f1
            return NULL;
        }
        v30 = v34;
        v34 = (v30 + v31) / 2;
        v35 = 8 * v34;
        v36 = *(int32_t *)(*(int32_t *)(v2 + 20) + 4 + v35);
        strcmp_rc2 = strcmp(msgid, (char *)((v32 != 0 ? llvm_bswap_i32(v36) : v36) + v33));
    }
    // 0x80b0570
    v4 = v35;
    v7 = v33;
    v6 = v34;
    v5 = v32;
    while (strcmp_rc2 != 0) {
        int32_t v37 = v34 + 1; // 0x80b0576
        if (v37 >= v30) {
            // 0x80b03f1
            return NULL;
        }
        v31 = v37;
        v32 = *(int32_t *)(v2 + 12);
        v33 = *(int32_t *)v2;
        v34 = (v30 + v31) / 2;
        v35 = 8 * v34;
        v36 = *(int32_t *)(*(int32_t *)(v2 + 20) + 4 + v35);
        strcmp_rc2 = strcmp(msgid, (char *)((v32 != 0 ? llvm_bswap_i32(v36) : v36) + v33));
        while (strcmp_rc2 < 0) {
            // 0x80b0548
            if (v34 <= v31) {
                // 0x80b03f1
                return NULL;
            }
            v30 = v34;
            v34 = (v30 + v31) / 2;
            v35 = 8 * v34;
            v36 = *(int32_t *)(*(int32_t *)(v2 + 20) + 4 + v35);
            strcmp_rc2 = strcmp(msgid, (char *)((v32 != 0 ? llvm_bswap_i32(v36) : v36) + v33));
        }
        // 0x80b0570
        v4 = v35;
        v7 = v33;
        v6 = v34;
        v5 = v32;
    }
  lab_0x80b0425:;
    int32_t v38 = *(int32_t *)(v2 + 24) + v4;
    int32_t v39; // 0x80b0250
    int32_t v40; // 0x80b0250
    if (v5 != 0) {
        // 0x80b0580
        v39 = llvm_bswap_i32(*(int32_t *)(v38 + 4));
        v40 = llvm_bswap_i32(*(int32_t *)v38);
    } else {
        // 0x80b042d
        v39 = *(int32_t *)(v38 + 4);
        v40 = *(int32_t *)v38;
    }
    int32_t v41 = 0; // 0x80b044f
    if (domainbinding != NULL) {
        // 0x80b0451
        v41 = *(int32_t *)((int32_t)domainbinding + 8);
    }
    // 0x80b0457
    if (v41 != *(int32_t *)(v2 + 36)) {
        int32_t * v42 = (int32_t *)v2; // 0x80b0462
        _nl_free_domain_conv(v42);
        _nl_init_domain_conv(domain_file, v42, domainbinding);
    }
    int32_t v43 = v39 + v7;
    int32_t v44 = v40 + 1;
    int32_t * v45 = (int32_t *)(v2 + 40); // 0x80b0480
    if (*v45 == -1) {
        // 0x80b04b0
        *lengthp = v44;
        return (char *)v43;
    }
    int32_t * v46 = (int32_t *)(v2 + 44); // 0x80b0486
    int32_t v47 = *v46; // 0x80b0486
    int32_t v48 = v47; // 0x80b048b
    if (v47 == 0) {
        int32_t * mem = calloc(*(int32_t *)(v2 + 16), 4); // 0x80b06f9
        int32_t v49 = (int32_t)mem; // 0x80b06f9
        *v46 = v49;
        v48 = v49;
        if (mem == NULL) {
            // 0x80b070c
            *v46 = -1;
            // 0x80b04b0
            *lengthp = v44;
            return (char *)v43;
        }
    }
    // 0x80b0491
    if (v48 == -1) {
        // 0x80b04b0
        *lengthp = v44;
        return (char *)v43;
    }
    int32_t v50 = 4 * v6; // 0x80b0496
    int32_t v51 = *(int32_t *)(v48 + v50); // 0x80b04a0
    int32_t v52 = v51; // 0x80b04a5
    if (v51 == 0) {
        int32_t v53 = 0; // 0x80b05f9
        int32_t v54 = 0; // 0x80b05f9
        int32_t outbuf; // bp-40, 0x80b0250
        while (true) {
            int32_t v55 = v54;
            int32_t v56 = v53;
            int32_t inbytesleft = v44; // bp-36, 0x80b0637
            outbuf = v53 + 4;
            int32_t inbuf = v43; // bp-32, 0x80b063d
            uint32_t v57 = g58; // 0x80b0640
            if (v57 >= 4) {
                int32_t outbytesleft = v57 - 4; // bp-44, 0x80b0650
                int32_t cd = *v45; // 0x80b066f
                int32_t v58 = iconv((int32_t *)cd, (char **)&inbuf, &inbytesleft, (char **)&outbuf, &outbytesleft); // 0x80b0675
                if (v58 != -1) {
                    // break -> 0x80b0718
                    break;
                }
                // 0x80b0683
                if (*__errno_location() != 7) {
                  lab_0x80b04b0:
                    // 0x80b04b0
                    *lengthp = v44;
                    return (char *)v43;
                }
            }
            int32_t v59; // 0x80b0250
            int32_t * mem2; // 0x80b0250
            if (v55 == 0) {
                // 0x80b06a0
                g58 = 4080;
                v59 = 1;
                mem2 = malloc(4080);
            } else {
                int32_t v60 = v55 + 1; // 0x80b0608
                int32_t v61 = 4080 * v60; // 0x80b060b
                g58 = v61;
                v59 = v60;
                mem2 = realloc((int32_t *)v56, v61);
            }
            // 0x80b0622
            if (mem2 == NULL) {
                // 0x80b06cc
                g59 = 0;
                g58 = 0;
                goto lab_0x80b04b0;
            }
            // 0x80b062a
            v53 = (int32_t)mem2;
            g59 = v53;
            v54 = v59;
        }
        int32_t v62 = g59; // 0x80b071b
        *(int32_t *)v62 = outbuf - 4 - v62;
        *(int32_t *)(*v46 + v50) = v62;
        uint32_t v63 = g58 + v62 - outbuf; // 0x80b0737
        g59 = v63 % 4 + outbuf;
        g58 = v63 & -4;
        v52 = *(int32_t *)(*v46 + v50);
    }
    // 0x80b04b0
    *lengthp = *(int32_t *)v52;
    return (char *)(v52 + 4);
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/intl/gettext/dcigettext.c
// Address range: 0x80b0760 - 0x80b07c4
// Line range:    767 - 796
char * plural_lookup(int32_t * domain, int32_t n, char * translation, int32_t translation_len) {
    // 0x80b0760
    int32_t v1; // 0x80b0760
    uint32_t v2 = plural_eval((int32_t *)v1, v1); // 0x80b0771
    int32_t v3 = v2 >= *(int32_t *)(*(int32_t *)(v1 + 16) + 52) ? 0 : v2; // 0x80b0760
    int32_t v4; // 0x80b0760
    int32_t v5 = v4;
    while (v3 != 0) {
        int32_t v6 = (int32_t)__rawmemchr((int32_t *)v5, 0) + 1; // 0x80b07a7
        v3--;
        if (v6 >= v1 + (int32_t)domain) {
            // 0x80b07ae
            return (char *)v1;
        }
        v5 = v6;
    }
    // 0x80b07b8
    return (char *)v5;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/intl/gettext/dcigettext.c
// Address range: 0x80b07d0 - 0x80b0e0d
// Line range:    288 - 399
char * dcigettext__(char * domainname, char * msgid1, char * msgid2, int32_t plural, int32_t n, int32_t category) {
    // 0x80b07d0
    char * v1; // bp-124, 0x80b07d0
    int32_t v2 = (int32_t)&v1; // 0x80b07d8
    int32_t v3 = __readgsdword(20); // 0x80b07e7
    int32_t v4 = (int32_t)msgid1;
    char * v5 = domainname; // 0x80b07fa
    int32_t v6 = v2; // 0x80b07fa
    int32_t v7 = 0; // 0x80b07fa
    char * v8; // 0x80b07d0
    int32_t v9; // 0x80b07d0
    int32_t v10; // 0x80b07d0
    int32_t v11; // 0x80b0820
    int32_t v12; // 0x80b0829
    int32_t * v13; // 0x80b083c
    int32_t * v14; // 0x80b0840
    int32_t v15; // 0x80b0866
    int32_t v16; // 0x80b080b
    if (msgid1 == NULL) {
        goto lab_0x80b09c8;
    } else {
        // 0x80b0800
        v8 = domainname == NULL ? _nl_current_default_domain__ : domainname;
        v16 = (int32_t)v8;
        *(int32_t *)&v1 = v4;
        int32_t len = strlen(msgid1); // 0x80b0818
        v11 = len + 1;
        v12 = v2 - (len + 55 & -16);
        int32_t v17 = v12 + 31 & -16; // 0x80b082f
        int32_t * v18 = (int32_t *)(v12 + 8); // 0x80b0838
        *v18 = v11;
        v13 = (int32_t *)(v12 + 4);
        *v13 = v4;
        v14 = (int32_t *)v12;
        *v14 = v17 + 24;
        memcpy((int32_t *)v11, &g83, (int32_t)&g83);
        *(int32_t *)v17 = v16;
        *(int32_t *)(v17 | 4) = category;
        *v18 = 0x80b0200;
        *v13 = (int32_t)&root;
        *v14 = v17;
        int32_t * v19 = tfind(&g83, (int32_t **)&g83, (int32_t (*)(int32_t *, int32_t *))&g83); // 0x80b0866
        v15 = (int32_t)v19;
        if (v19 == NULL) {
            goto lab_0x80b0883;
        } else {
            int32_t v20 = *v19; // 0x80b0872
            if (*(int32_t *)(v20 + 8) == _nl_msg_cat_cntr) {
                if (plural != 0) {
                    // 0x80b0d82
                    *v14 = *(int32_t *)(v20 + 20);
                    char * v21 = plural_lookup(v19, (int32_t)&g83, (char *)&g83, (int32_t)&g83); // 0x80b0d91
                    v9 = v11;
                    v10 = v15;
                    v5 = v8;
                    v6 = v12;
                    v7 = (int32_t)v21;
                } else {
                    // 0x80b0d60
                    v9 = v11;
                    v10 = v15;
                    v5 = v8;
                    v6 = v12;
                    v7 = *(int32_t *)(v20 + 16);
                }
                goto lab_0x80b09c8;
            } else {
                goto lab_0x80b0883;
            }
        }
    }
  lab_0x80b098d_2:;
    // 0x80b098d
    int32_t v22; // 0x80b07d0
    int32_t v23 = v22;
    char * v24; // 0x80b07d0
    char * v25 = v24;
    char * v26; // 0x80b07d0
    char * name = v26;
    int32_t v27; // 0x80b07d0
    int32_t v28 = v27;
    int32_t v29; // 0x80b07d0
    int32_t v30 = v29;
    int32_t v31; // 0x80b07d0
    int32_t v32 = v31;
    int32_t v33; // 0x80b07d0
    int32_t v34 = v33;
    int32_t v35; // 0x80b07d0
    int32_t v36 = v35;
    g86 = category;
    int32_t v37 = (int32_t)"LC_XXX"; // 0x80b099b
    switch (category) {
        case 0: {
            // 0x80b0dbb
            v37 = (int32_t)"LC_CTYPE";
            // break -> 0x80b0a10
            break;
        }
        case 1: {
            // 0x80b0db1
            v37 = (int32_t)"LC_NUMERIC";
            // break -> 0x80b0a10
            break;
        }
        case 2: {
            // 0x80b0da7
            v37 = (int32_t)"LC_TIME";
            // break -> 0x80b0a10
            break;
        }
        case 3: {
            // 0x80b0a05
            v37 = (int32_t)"LC_COLLATE";
            // break -> 0x80b0a10
            break;
        }
        case 4: {
            // 0x80b0dcf
            v37 = (int32_t)"LC_MONETARY";
            // break -> 0x80b0a10
            break;
        }
        case 5: {
            // 0x80b0d9d
            v37 = (int32_t)"LC_MESSAGES";
            // break -> 0x80b0a10
            break;
        }
        case 6: {
            // 0x80b0dc5
            v37 = (int32_t)"LC_ALL";
            // break -> 0x80b0a10
            break;
        }
    }
    // 0x80b0a10
    int32_t * v38; // 0x80b07d0
    int32_t v39; // 0x80b07d0
    if (LANGUAGE == 0) {
        goto lab_0x80b0a1f;
    } else {
        // 0x80b0a1a
        if (*(char *)LANGUAGE != 0) {
            // 0x80b0a1a
            v38 = (int32_t *)v23;
            v39 = LANGUAGE;
            goto lab_0x80b0a3e;
        } else {
            goto lab_0x80b0a1f;
        }
    }
  lab_0x80b0952:;
    // 0x80b0952
    int32_t * v40; // 0x80b07d0
    *v40 = 0;
    int32_t * v41; // 0x80b07d0
    int32_t v42; // 0x80b07d0
    *v41 = v42;
    int32_t * v43 = __rawmemchr(&g83, (int32_t)&g83); // 0x80b0969
    *v40 = (int32_t)&g16;
    *v41 = (int32_t)v43;
    char * v44 = stpcpy((char *)&g83, (char *)&g83); // 0x80b0979
    int32_t * v45; // 0x80b08e7
    *v40 = *v45;
    *v41 = (int32_t)v44;
    strcpy((char *)&g83, (char *)&g83);
    v35 = v11;
    v33 = v15;
    int32_t v46; // 0x80b0883
    v31 = v46;
    int32_t v47; // 0x80b0893
    v29 = v47;
    int32_t v48; // 0x80b07d0
    v27 = v48;
    v26 = (char *)v42;
    v24 = v8;
    int32_t v49; // 0x80b07d0
    v22 = v49;
    goto lab_0x80b098d_2;
  lab_0x80b09c8:
    // 0x80b09c8
    if (v3 == __readgsdword(20)) {
        // 0x80b09da
        return (char *)v7;
    }
    // 0x80b0dfc
    __stack_chk_fail();
    v35 = v9;
    v33 = v10;
    int32_t v50; // 0x80b07d0
    v31 = v50;
    int32_t v51; // 0x80b07d0
    v29 = v51;
    int32_t v52; // 0x80b07d0
    v27 = v52;
    v26 = "/usr/share/locale";
    v24 = v5;
    v22 = v6;
    goto lab_0x80b098d_2;
  lab_0x80b0883:;
    int32_t * v53 = __errno_location(); // 0x80b0883
    v47 = *v53;
    if (enable_secure == 0) {
        // 0x80b09e2
        if (getuid() == geteuid()) {
            // 0x80b0dd9
            if (getgid() != getegid()) {
                // 0x80b09f6
                enable_secure = 1;
                goto lab_0x80b089e;
            } else {
                // 0x80b0ded
                enable_secure = -1;
                goto lab_0x80b089e;
            }
        } else {
            // 0x80b09f6
            enable_secure = 1;
            goto lab_0x80b089e;
        }
    } else {
        goto lab_0x80b089e;
    }
  lab_0x80b0a1f:;
    int32_t * v54 = (int32_t *)v23;
    *v54 = (int32_t)"LANGUAGE";
    char * env_val = getenv(name); // 0x80b0a26
    if (env_val == NULL) {
        goto lab_0x80b0d68;
    } else {
        // 0x80b0a35
        v38 = v54;
        v39 = (int32_t)env_val;
        if (*env_val == 0) {
            goto lab_0x80b0d68;
        } else {
            goto lab_0x80b0a3e;
        }
    }
  lab_0x80b089e:
    // 0x80b089e
    v46 = (int32_t)v53;
    v35 = v11;
    v33 = v15;
    v31 = v46;
    v29 = v47;
    v27 = 0;
    v26 = "/usr/share/locale";
    v24 = v8;
    v22 = v12;
    int32_t v55; // 0x80b07d0
    int32_t v56; // 0x80b07d0
    int32_t v57; // 0x80b07d0
    int32_t v58; // 0x80b07d0
    int32_t v59; // 0x80b07d0
    int32_t v60; // 0x80b07d0
    int32_t v61; // 0x80b07d0
    int32_t v62; // 0x80b07d0
    int32_t v63; // 0x80b07d0
    int32_t v64; // 0x80b07d0
    int32_t v65; // 0x80b07d0
    int32_t v66; // 0x80b07d0
    char * v67; // 0x80b07d0
    char * v68; // 0x80b07d0
    if (_nl_domain_bindings__ == NULL) {
        goto lab_0x80b098d_2;
    } else {
        // 0x80b08ac
        v48 = (int32_t)_nl_domain_bindings__;
        *v13 = v48 + 16;
        *v14 = v16;
        int32_t strcmp_rc = strcmp((char *)&g83, (char *)&g83); // 0x80b08d2
        while (strcmp_rc != 0) {
            // 0x80b08b8
            v35 = v11;
            v33 = v15;
            v31 = v46;
            v29 = v47;
            v27 = 0;
            v26 = "/usr/share/locale";
            v24 = v8;
            v22 = v12;
            if (strcmp_rc < 0) {
                goto lab_0x80b098d_2;
            }
            int32_t v69 = *(int32_t *)v48; // 0x80b08be
            v35 = v11;
            v33 = v15;
            v31 = v46;
            v29 = v47;
            v27 = 0;
            v26 = "/usr/share/locale";
            v24 = v8;
            v22 = v12;
            if (v69 == 0) {
                goto lab_0x80b098d_2;
            }
            v48 = v69;
            *v13 = v48 + 16;
            *v14 = v16;
            strcmp_rc = strcmp((char *)&g83, (char *)&g83);
        }
        // 0x80b08dc
        v35 = v11;
        v33 = v15;
        v31 = v46;
        v29 = v47;
        v27 = 0;
        v26 = "/usr/share/locale";
        v24 = v8;
        v22 = v12;
        if (v48 == 0) {
            goto lab_0x80b098d_2;
        } else {
            // 0x80b08e7
            v45 = (int32_t *)(v48 + 4);
            int32_t v70 = *v45; // 0x80b08e7
            char * str = (char *)v70; // 0x80b08ea
            v35 = v11;
            v33 = v15;
            v31 = v46;
            v29 = v47;
            v27 = v48;
            v26 = str;
            v24 = v8;
            v22 = v12;
            if (*str == 47) {
                goto lab_0x80b098d_2;
            } else {
                // 0x80b08f6
                *v14 = v70;
                int32_t len2 = strlen(str); // 0x80b08fe
                int32_t v71 = len2 + 1; // 0x80b0906
                *v53 = 0;
                int32_t v72 = v12 - (len2 + 0x1021 & -16); // 0x80b0939
                int32_t v73 = v72 + 31 & -16; // 0x80b093f
                int32_t * v74 = (int32_t *)(v72 + 4); // 0x80b0942
                *v74 = 0x1002;
                int32_t * v75 = (int32_t *)v72; // 0x80b0946
                *v75 = v73;
                char * v76 = getcwd((char *)&g83, (int32_t)&g83); // 0x80b0949
                int32_t v77 = 0x1002; // 0x80b0950
                v49 = v72;
                v42 = v73;
                v40 = v74;
                v41 = v75;
                if (v76 == NULL) {
                    int32_t v78 = v72;
                    while (*v53 == 34) {
                        uint32_t v79 = v77;
                        int32_t v80 = v79 + 32 + v79 / 2; // 0x80b0925
                        *v53 = 0;
                        int32_t v81 = v78 - (len2 + 31 + v80 & -16); // 0x80b0939
                        int32_t v82 = v81 + 31 & -16; // 0x80b093f
                        int32_t * v83 = (int32_t *)(v81 + 4);
                        *v83 = v80;
                        int32_t * v84 = (int32_t *)v81;
                        *v84 = v82;
                        char * v85 = getcwd((char *)&g83, (int32_t)&g83); // 0x80b0949
                        v77 = v80;
                        v49 = v81;
                        v42 = v82;
                        v40 = v83;
                        v41 = v84;
                        if (v85 != NULL) {
                            goto lab_0x80b0952;
                        }
                        v78 = v81;
                    }
                    // 0x80b0d3e
                    *v53 = v47;
                    v57 = v11;
                    v65 = v15;
                    v59 = v46;
                    v61 = v47;
                    v63 = v71;
                    v67 = v8;
                    v55 = v78;
                    v58 = v11;
                    v66 = v15;
                    v60 = v46;
                    v62 = v47;
                    v64 = v71;
                    v68 = v8;
                    v56 = v78;
                    if (plural != 0) {
                        goto lab_0x80b09bb;
                    } else {
                        goto lab_0x80b0d51;
                    }
                } else {
                    goto lab_0x80b0952;
                }
            }
        }
    }
  lab_0x80b0d68:
    // 0x80b0d68
    *(int32_t *)(v23 + 4) = 0;
    *v54 = category;
    char * locale = setlocale((int32_t)&g83, (char *)&g83); // 0x80b0d76
    v38 = v54;
    v39 = (int32_t)locale;
    goto lab_0x80b0a3e;
  lab_0x80b0a3e:;
    int32_t v86 = (int32_t)v25; // 0x80b0a3e
    *v38 = v86;
    int32_t len3 = strlen((char *)&g83); // 0x80b0a44
    *v38 = v37;
    int32_t v87 = v23 - (len3 + 35 + strlen((char *)len3) & -16); // 0x80b0a5e
    int32_t str2 = v87 + 31 & -16; // 0x80b0a64
    int32_t * v88 = (int32_t *)v87; // 0x80b0a67
    *v88 = str2;
    int32_t * v89 = (int32_t *)(v87 + 4); // 0x80b0a6d
    *v89 = v37;
    char * v90 = stpcpy((char *)str2, (char *)&g83); // 0x80b0a71
    *v89 = (int32_t)&g16;
    *v88 = (int32_t)v90;
    char * v91 = stpcpy((char *)&g83, (char *)&g83); // 0x80b0a81
    *(int32_t *)(v87 + 8) = len3;
    *v89 = v86;
    *v88 = (int32_t)v91;
    *mempcpy(&g83, &g83, (int32_t)&g83) = 0x6f6d2e;
    *v88 = v39;
    int32_t v92 = v87 - (strlen((char *)&g83) + 31 & -16); // 0x80b0ab0
    int32_t v93 = v92 + 31 & -16; // 0x80b0ab6
    int32_t * v94 = (int32_t *)v92;
    int32_t * v95 = (int32_t *)(v92 + 4);
    char * str3 = (char *)v93;
    char * v96 = (char *)(v93 | 1);
    bool v97; // 0x80b07d0
    int32_t v98 = v97 ? -1 : 1;
    int32_t * v99 = (int32_t *)(v92 + 12);
    int32_t v100 = (int32_t)name;
    int32_t * v101 = (int32_t *)(v92 + 8);
    int32_t v102; // bp-36, 0x80b07d0
    int32_t v103 = &v102;
    int32_t v104 = v39; // 0x80b0ab9
    int32_t v105; // 0x80b07d0
    int32_t v106; // 0x80b07d0
    int32_t v107; // 0x80b07d0
    int32_t v108; // 0x80b07d0
    while (true) {
        char v109 = *(char *)v104; // 0x80b0ac0
        char v110 = v109; // 0x80b0ac5
        int32_t v111 = v104; // 0x80b0ac5
        int32_t v112 = v104; // 0x80b0ac5
        int32_t v113; // 0x80b07d0
        if (v109 == 58) {
          lab_0x80b0c08:
            // 0x80b0c08
            v113 = v112 + 1;
        } else {
            int32_t v114; // 0x80b07d0
            int32_t v115; // 0x80b07d0
            while (true) {
                // 0x80b0acb
                v114 = v111;
                char v116 = v110; // 0x80b0acf
                int32_t v117 = v93; // 0x80b0acf
                int32_t v118 = v114; // 0x80b0acf
                if (v110 == 0) {
                    // break -> 0x80b0ad5
                    break;
                }
                int32_t v119; // 0x80b0bbc
                char * v120; // 0x80b07d0
                int32_t v121; // 0x80b0bc4
                while (true) {
                  lab_0x80b0bbc:
                    // 0x80b0bbc
                    v119 = v118 + 1;
                    *(char *)v117 = v116;
                    v120 = (char *)v119;
                    v116 = *v120;
                    v121 = v117 + 1;
                    v117 = v121;
                    v118 = v119;
                    switch (v116) {
                        case 58: {
                            goto lab_0x80b0bcb;
                        }
                        case 0: {
                            goto lab_0x80b0bcb;
                        }
                        default: {
                            goto lab_0x80b0bbc;
                        }
                    }
                }
              lab_0x80b0bcb:
                // 0x80b0bcb
                *(char *)v121 = 0;
                v115 = v119;
                if (enable_secure != 1) {
                    goto lab_0x80b0adc_2;
                }
                // 0x80b0bdb
                *v94 = v93;
                *v95 = 47;
                char * found_char_pos = strchr(str3, (int32_t)&g83); // 0x80b0be9
                v115 = v119;
                if (found_char_pos == NULL) {
                    goto lab_0x80b0adc_2;
                }
                char v122 = *v120; // 0x80b0bf9
                v110 = v122;
                v111 = v119;
                v112 = v119;
                if (v122 == 58) {
                    goto lab_0x80b0c08;
                }
            }
            // 0x80b0ad5
            *str3 = 67;
            *v96 = 0;
            v115 = v114;
          lab_0x80b0adc_2:;
            int32_t v123 = v115;
            char v124 = *str3; // 0x80b0adc
            if (v124 == 67) {
                // 0x80b0ae7
                if (*v96 == 0) {
                    // break -> 0x80b09a8
                    break;
                }
            }
            int32_t v125 = v93; // 0x80b0b03
            if (v124 == 80) {
                int32_t v126 = 5;
                if (v126 == 0) {
                    // break (via goto) -> 0x80b09a8
                    goto lab_0x80b09a8;
                }
                int32_t v127 = v125 + v98; // 0x80b0b03
                int32_t v128 = (int32_t)"POSIX" + v98; // 0x80b0b03
                int32_t v129 = v126 - 1; // 0x80b0b03
                v125 = v127;
                int32_t v130 = v128; // 0x80b0b03
                while (*(char *)v127 == *(char *)v128) {
                    // .lr.ph
                    v126 = v129;
                    if (v126 == 0) {
                        // break (via goto) -> 0x80b09a8
                        goto lab_0x80b09a8;
                    }
                    // ._crit_edge
                    v127 = v125 + v98;
                    v128 = v130 + v98;
                    v129 = v126 - 1;
                    v125 = v127;
                    v130 = v128;
                }
            }
            // 0x80b0b0b
            *v95 = v93;
            *v99 = v28;
            *v101 = str2;
            *v94 = v100;
            int32_t * v131 = _nl_find_domain(str3, (char *)&g83, (char *)&g83, &g83); // 0x80b0b26
            v113 = v123;
            if (v131 != NULL) {
                int32_t v132 = (int32_t)v131;
                *v99 = v103;
                *v94 = v132;
                *v101 = v4;
                *v95 = v28;
                char * v133 = _nl_find_msg(&g83, &g83, (char *)&g83, &g83); // 0x80b0b4c
                if (v133 != NULL) {
                    int32_t v134 = (int32_t)v133; // 0x80b0b4c
                    *(int32_t *)v32 = v30;
                    v107 = v132;
                    v105 = v134;
                    v108 = v132;
                    v106 = v134;
                    if (v34 == 0) {
                        goto lab_0x80b0c7b;
                    } else {
                        goto lab_0x80b0b71;
                    }
                }
                int32_t v135 = v132 + 24; // 0x80b0c10
                int32_t v136 = *(int32_t *)v135; // 0x80b0c10
                v113 = v123;
                int32_t v137 = v136; // 0x80b0c15
                if (v136 != 0) {
                    int32_t v138 = 0;
                    *v99 = v103;
                    *v101 = v4;
                    *v95 = v28;
                    *v94 = v137;
                    char * v139 = _nl_find_msg(&g83, &g83, (char *)&g83, &g83); // 0x80b0c54
                    int32_t v140; // 0x80b0c54
                    int32_t v141; // 0x80b0c6a
                    if (v139 != NULL) {
                        // 0x80b0c5d
                        v140 = (int32_t)v139;
                        v141 = *(int32_t *)(4 * v138 + v135);
                        *(int32_t *)v32 = v30;
                        v107 = v141;
                        v105 = v140;
                        v108 = v141;
                        v106 = v140;
                        if (v34 != 0) {
                            goto lab_0x80b0b71;
                        } else {
                            goto lab_0x80b0c7b;
                        }
                    }
                    int32_t v142 = v138 + 1; // 0x80b0c33
                    int32_t v143 = *(int32_t *)(4 * v142 + v135); // 0x80b0c36
                    v113 = v123;
                    while (v143 != 0) {
                        // 0x80b0c42
                        v138 = v142;
                        *v99 = v103;
                        *v101 = v4;
                        *v95 = v28;
                        *v94 = v143;
                        v139 = _nl_find_msg(&g83, &g83, (char *)&g83, &g83);
                        if (v139 != NULL) {
                            // 0x80b0c5d
                            v140 = (int32_t)v139;
                            v141 = *(int32_t *)(4 * v138 + v135);
                            *(int32_t *)v32 = v30;
                            v107 = v141;
                            v105 = v140;
                            v108 = v141;
                            v106 = v140;
                            if (v34 != 0) {
                                goto lab_0x80b0b71;
                            } else {
                                goto lab_0x80b0c7b;
                            }
                        }
                        // 0x80b0c30
                        v142 = v138 + 1;
                        v143 = *(int32_t *)(4 * v142 + v135);
                        v113 = v123;
                    }
                }
            }
        }
        // 0x80b0ac0
        v104 = v113;
    }
  lab_0x80b09a8:
    // 0x80b09a8
    *(int32_t *)v32 = v30;
    v57 = v36;
    v65 = v34;
    v59 = v32;
    v61 = v30;
    v63 = v28;
    v67 = v25;
    v55 = v92;
    v58 = v36;
    v66 = v34;
    v60 = v32;
    v62 = v30;
    v64 = v28;
    v68 = v25;
    v56 = v92;
    if (plural == 0) {
        goto lab_0x80b0d51;
    } else {
        goto lab_0x80b09bb;
    }
  lab_0x80b0d51:
    // 0x80b0d51
    v9 = v58;
    v10 = v66;
    v50 = v60;
    v51 = v62;
    v52 = v64;
    v5 = v68;
    v6 = v56;
    v7 = v4;
    goto lab_0x80b09c8;
  lab_0x80b09bb:;
    int32_t v144 = v55;
    char * v145 = v67;
    int32_t v146 = v63;
    int32_t v147 = v61;
    int32_t v148 = v59;
    int32_t v149 = v65;
    int32_t v150 = v57;
    v58 = v150;
    v66 = v149;
    v60 = v148;
    v62 = v147;
    v64 = v146;
    v68 = v145;
    v56 = v144;
    if (n == 1) {
        goto lab_0x80b0d51;
    } else {
        // 0x80b09c5
        v9 = v150;
        v10 = v149;
        v50 = v148;
        v51 = v147;
        v52 = v146;
        v5 = v145;
        v6 = v144;
        v7 = (int32_t)msgid2;
        goto lab_0x80b09c8;
    }
  lab_0x80b0c7b:;
    int32_t v151 = v106;
    int32_t v152 = v108;
    *v94 = v36 + 25 + len3;
    int32_t * mem = malloc((int32_t)&g83); // 0x80b0c88
    int32_t v153 = v151; // 0x80b0c91
    int32_t v154; // 0x80b0c88
    if (mem == NULL) {
        goto lab_0x80b0b94;
    } else {
        // 0x80b0c97
        v154 = (int32_t)mem;
        *v95 = v4;
        *v101 = v36;
        *v94 = v154 + 24;
        int32_t v155 = (int32_t)mempcpy(&g83, &g83, (int32_t)&g83); // 0x80b0cab
        *mem = v155;
        *v94 = v155;
        *v101 = len3 + 1;
        *v95 = v86;
        memcpy(&g83, &g83, (int32_t)&g83);
        *(int32_t *)(v154 + 4) = category;
        *(int32_t *)(v154 + 12) = v152;
        *(int32_t *)(v154 + 16) = v151;
        *(int32_t *)(v154 + 8) = _nl_msg_cat_cntr;
        *(int32_t *)(v154 + 20) = v102;
        *v101 = 0x80b0200;
        *v95 = (int32_t)&root;
        *v94 = v154;
        int32_t * v156 = tsearch(&g83, (int32_t **)&g83, (int32_t (*)(int32_t *, int32_t *))&g83); // 0x80b0cf8
        if (v156 == NULL) {
            goto lab_0x80b0d09;
        } else {
            // 0x80b0d01
            v153 = v151;
            if (*v156 == v154) {
                goto lab_0x80b0b94;
            } else {
                goto lab_0x80b0d09;
            }
        }
    }
  lab_0x80b0b71:;
    int32_t * v157 = (int32_t *)v34; // 0x80b0b74
    *(int32_t *)(*v157 + 8) = _nl_msg_cat_cntr;
    *(int32_t *)(*v157 + 12) = v107;
    *(int32_t *)(*v157 + 16) = v105;
    *(int32_t *)(*v157 + 20) = v102;
    v153 = v105;
    goto lab_0x80b0b94;
  lab_0x80b0b94:
    // 0x80b0b94
    v9 = v36;
    v10 = v34;
    v50 = v32;
    v51 = v30;
    v52 = v28;
    v5 = v25;
    v6 = v92;
    v7 = v153;
    if (plural == 0) {
        goto lab_0x80b09c8;
    } else {
        // 0x80b0b9f
        *v94 = v102;
        char * v158 = plural_lookup(&g83, (int32_t)&g83, (char *)&g83, (int32_t)&g83); // 0x80b0bac
        v9 = v36;
        v10 = v34;
        v50 = v32;
        v51 = v30;
        v52 = v28;
        v5 = v25;
        v6 = v92;
        v7 = (int32_t)v158;
        goto lab_0x80b09c8;
    }
  lab_0x80b0d09:
    // 0x80b0d09
    *v94 = v154;
    free(&g83);
    v153 = v151;
    goto lab_0x80b0b94;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/intl/gettext/explodename.c
// Address range: 0x80b0f00 - 0x80b1300
// Line range:    52 - 172
int32_t _nl_explode_name(char * name, char ** language, char ** modifier, char ** territory, char ** codeset, char ** normalized_codeset, char ** special, char ** sponsor, char ** revision) {
    int32_t v1 = (int32_t)name;
    *(int32_t *)modifier = 0;
    *(int32_t *)territory = 0;
    *(int32_t *)codeset = 0;
    *(int32_t *)normalized_codeset = 0;
    *(int32_t *)special = 0;
    *(int32_t *)sponsor = 0;
    *(int32_t *)revision = 0;
    *(int32_t *)language = v1;
    int32_t v2 = v1; // 0x80b0f9c
    char * v3; // 0x80b0f00
    int32_t v4; // 0x80b0f00
    int32_t v5; // 0x80b0f00
    int32_t v6; // 0x80b0f00
    int32_t v7; // 0x80b0f00
    char v8; // 0x80b0f00
    switch (*name) {
        case 95: {
            goto lab_0x80b12a8;
        }
        case 0: {
            goto lab_0x80b12a8;
        }
        case 64: {
            goto lab_0x80b12a8;
        }
        case 43: {
            goto lab_0x80b12a8;
        }
        case 44: {
            goto lab_0x80b12a8;
        }
        default: {
            int32_t v9; // 0x80b0f00
            char * v10; // 0x80b0f00
            char v11; // 0x80b0f9f
            while (true) {
              lab_0x80b0f9c:
                // 0x80b0f9c
                v9 = v2;
                v2 = v9 + 1;
                v10 = (char *)v2;
                v11 = *v10;
                switch (v11) {
                    case 95: {
                        goto lab_0x80b0fa7;
                    }
                    case 64: {
                        goto lab_0x80b0fa7;
                    }
                    case 44: {
                        goto lab_0x80b0fa7;
                    }
                    case 43: {
                        goto lab_0x80b0fa7;
                    }
                    case 0: {
                        goto lab_0x80b0fa7;
                    }
                    default: {
                        goto lab_0x80b0f9c;
                    }
                }
            }
          lab_0x80b0fa7:
            if (v2 == v1) {
                goto lab_0x80b12a8;
            } else {
                // 0x80b0fb2
                v8 = v11;
                v4 = 0;
                v6 = v2;
                v5 = 0;
                if (v11 == 95) {
                    // 0x80b1078
                    *v10 = 0;
                    int32_t v12 = v9 + 2; // 0x80b107b
                    *(int32_t *)territory = v12;
                    char * v13 = (char *)v12;
                    char v14 = *v13; // 0x80b1080
                    char v15 = v14; // 0x80b1086
                    int32_t v16 = v12; // 0x80b1086
                    v3 = v13;
                    v7 = v12;
                    if (v14 != 46) {
                        char v17; // 0x80b0f00
                        int32_t v18; // 0x80b0f00
                        while (true) {
                          lab_0x80b10c3:
                            // 0x80b10c3
                            v18 = v16;
                            v17 = v15;
                            if (v17 == 0) {
                                // break -> 0x80b10c7
                                break;
                            }
                            // 0x80b1090
                            v8 = v17;
                            v4 = 32;
                            v6 = v18;
                            v5 = 0;
                            switch (v17) {
                                case 64: {
                                    goto lab_0x80b0fc0;
                                }
                                case 43: {
                                    goto lab_0x80b0fc0;
                                }
                                case 44: {
                                    goto lab_0x80b0fc0;
                                }
                                case 95: {
                                    goto lab_0x80b0fc0;
                                }
                                default: {
                                    int32_t v19 = v18 + 1; // 0x80b10b8
                                    char v20 = *(char *)v19; // 0x80b10bb
                                    v15 = v20;
                                    v16 = v19;
                                    if (v20 == 46) {
                                        goto lab_0x80b10d0;
                                    }
                                    goto lab_0x80b10c3;
                                }
                            }
                        }
                        // 0x80b10c7
                        v8 = v17;
                        v4 = 32;
                        v6 = v18;
                        v5 = 0;
                        if (v17 != 46) {
                            goto lab_0x80b0fc0;
                        } else {
                            // 0x80b10c7
                            v3 = (char *)v18;
                            v7 = v18;
                            goto lab_0x80b10d0;
                        }
                    } else {
                        goto lab_0x80b10d0;
                    }
                } else {
                    goto lab_0x80b0fc0;
                }
            }
        }
    }
  lab_0x80b10d0:
    // 0x80b10d0
    *v3 = 0;
    int32_t v21 = v7 + 1; // 0x80b10d6
    *(int32_t *)codeset = v21;
    char * v22 = (char *)v21; // 0x80b10db
    char v23 = *v22; // 0x80b10db
    v8 = v23;
    v4 = 48;
    v6 = v21;
    v5 = 1;
    int32_t v24 = v21; // 0x80b10e3
    int32_t v25; // 0x80b0f00
    if (v23 != 0 == (v23 != 64)) {
        int32_t v26; // 0x80b10fc
        char * v27; // 0x80b0f00
        while (true) {
          lab_0x80b10fc:
            // 0x80b10fc
            v26 = v24 + 1;
            v27 = (char *)v26;
            v24 = v26;
            switch (*v27) {
                case 64: {
                    goto lab_0x80b1106;
                }
                case 0: {
                    goto lab_0x80b1106;
                }
                default: {
                    goto lab_0x80b10fc;
                }
            }
        }
      lab_0x80b1106:
        // 0x80b1106
        v25 = 48;
        if (v26 == v21) {
            goto lab_0x80b1028;
        } else {
            char * str = _nl_normalize_codeset(v22, v26 - v21); // 0x80b1119
            *(int32_t *)normalized_codeset = (int32_t)str;
            if (strcmp(*codeset, str) == 0) {
                // 0x80b12c9
                free((int32_t *)str);
                v8 = *v27;
                v4 = 48;
                v6 = v26;
                v5 = 1;
            } else {
                // 0x80b1144
                v8 = *v27;
                v4 = 56;
                v6 = v26;
                v5 = 1;
            }
            goto lab_0x80b0fc0;
        }
    } else {
        goto lab_0x80b0fc0;
    }
  lab_0x80b11d9:;
    int32_t result = v4 | 192; // 0x80b0f00
    int32_t v28; // 0x80b0f00
    int32_t v29 = v28; // 0x80b0f00
    int32_t v30; // 0x80b0f00
    int32_t v31 = v30; // 0x80b0f00
    goto lab_0x80b1018;
  lab_0x80b0fc0:;
    // 0x80b0fc0
    int32_t v57; // 0x80b0f00
    int32_t v44; // 0x80b0f00
    int32_t v48; // 0x80b0f00
    char v58; // 0x80b0f00
    int32_t v49; // 0x80b0f00
    int32_t v59; // 0x80b0f00
    int32_t v32; // 0x80b0f00
    int32_t v60; // 0x80b1173
    char v61; // 0x80b1178
    if (v8 == 64) {
        // 0x80b1068
        *(char *)v6 = 0;
        *(int32_t *)modifier = v6 + 1;
        v25 = v4 | 192;
        goto lab_0x80b1028;
    } else {
        // 0x80b0fca
        v25 = v4;
        if (v5 == 1) {
            goto lab_0x80b1028;
        } else {
            // 0x80b0fcf
            v57 = v4;
            v59 = v6;
            v58 = v8;
            if (v8 == 43) {
                // 0x80b1170
                *(char *)v6 = 0;
                v60 = v6 + 1;
                *(int32_t *)modifier = v60;
                v61 = *(char *)v60;
                switch (v61) {
                    case 0: {
                        goto lab_0x80b12e8;
                    }
                    case 43: {
                        goto lab_0x80b12e8;
                    }
                    case 44: {
                        goto lab_0x80b12e8;
                    }
                    case 95: {
                        goto lab_0x80b12e8;
                    }
                    default: {
                        int32_t v62 = v6 + 2; // 0x80b11a2
                        char v63 = *(char *)v62; // 0x80b11ce
                        char v64 = v63; // 0x80b11d3
                        int32_t v65 = v62; // 0x80b11d3
                        v28 = v62;
                        v30 = 0;
                        if (v63 != 0) {
                            int32_t v66; // 0x80b0f00
                            while (true) {
                              lab_0x80b11b0:
                                // 0x80b11b0
                                v66 = v65;
                                v28 = v66;
                                v30 = 95;
                                switch (v64) {
                                    case 43: {
                                        goto lab_0x80b0fec;
                                    }
                                    case 44: {
                                        // 0x80b0fec
                                        v48 = v4 | 192;
                                        v49 = v66;
                                        goto lab_0x80b1237;
                                    }
                                    case 95: {
                                        goto lab_0x80b11d9;
                                    }
                                    default: {
                                        int32_t v67 = v66 + 1; // 0x80b11cb
                                        char v68 = *(char *)v67; // 0x80b11ce
                                        v64 = v68;
                                        v65 = v67;
                                        v28 = v67;
                                        v30 = 0;
                                        if (v68 == 0) {
                                            goto lab_0x80b11d9;
                                        }
                                        goto lab_0x80b11b0;
                                    }
                                }
                            }
                          lab_0x80b0fec:
                            // 0x80b0fec
                            v32 = v66;
                            v44 = v4 | 192;
                            goto lab_0x80b11f7;
                        } else {
                            goto lab_0x80b11d9;
                        }
                    }
                }
            } else {
                goto lab_0x80b0fe4;
            }
        }
    }
  lab_0x80b12a8:;
    int32_t * v69 = __rawmemchr((int32_t *)name, 0); // 0x80b12b5
    v8 = *(char *)v69;
    v4 = 0;
    v6 = (int32_t)v69;
    v5 = 0;
    goto lab_0x80b0fc0;
  lab_0x80b1028:;
    int32_t v70 = v25;
    char * v71 = *territory;
    int32_t v72 = v70; // 0x80b102c
    if (v71 != NULL) {
        // 0x80b102e
        v72 = *v71 == 0 ? v70 & -33 : v70;
    }
    int32_t v73 = v72;
    char * v74 = *codeset;
    int32_t v75 = v73; // 0x80b1040
    if (v74 != NULL) {
        // 0x80b1042
        v75 = *v74 == 0 ? v73 & -17 : v73;
    }
    int32_t result4 = v75;
    char * v76 = *modifier;
    if (v76 != NULL) {
        // 0x80b1053
        return *v76 == 0 ? result4 & -129 : result4;
    }
    // 0x80b100d
    return result4;
  lab_0x80b0fe4:
    // 0x80b0fe4
    result = v57;
    v29 = v59;
    v31 = v58;
    char v46; // 0x80b0f00
    int32_t result3; // 0x80b0f00
    int32_t v47; // 0x80b0f00
    if (v58 < 45) {
        // 0x80b0fec
        v46 = v58;
        result3 = v57;
        v47 = v59;
        v32 = v59;
        v44 = v57;
        v48 = v57;
        v49 = v59;
        switch (v58) {
            case 43: {
                goto lab_0x80b11f7;
            }
            case 44: {
                goto lab_0x80b1237;
            }
            default: {
                goto lab_0x80b1002;
            }
        }
    } else {
        goto lab_0x80b1018;
    }
  lab_0x80b12e8:
    // 0x80b12e8
    v57 = v4 | 192;
    v59 = v60;
    v58 = v61;
    goto lab_0x80b0fe4;
  lab_0x80b1018:
    // 0x80b1018
    if (v31 == 95) {
        // 0x80b1275
        *(char *)v29 = 0;
        *(int32_t *)revision = v29 + 1;
        return result | 1;
    }
    // 0x80b100d
    return result;
  lab_0x80b11f7:
    // 0x80b11f7
    *(char *)v32 = 0;
    int32_t v33 = v32 + 1; // 0x80b11fd
    *(int32_t *)special = v33;
    unsigned char v34 = *(char *)v33; // 0x80b1202
    int32_t v35 = v34; // 0x80b1202
    int32_t v36 = v35; // 0x80b1207
    int32_t v37 = v33; // 0x80b1207
    int32_t v38 = v35; // 0x80b1207
    int32_t v39 = v33; // 0x80b1207
    if (v34 != 0 == (v34 != 44)) {
        while (true) {
          lab_0x80b1222:
            // 0x80b1222
            v38 = v36;
            v39 = v37;
            if (v36 == 95) {
                // break -> 0x80b1227
                break;
            }
            int32_t v40 = v37 + 1; // 0x80b1210
            unsigned char v41 = *(char *)v40; // 0x80b1213
            int32_t v42 = v41; // 0x80b1213
            v36 = v42;
            v37 = v40;
            v38 = v42;
            v39 = v40;
            switch (v41) {
                case 44: {
                    goto lab_0x80b1227;
                }
                case 0: {
                    goto lab_0x80b1227;
                }
                default: {
                    goto lab_0x80b1222;
                }
            }
        }
    }
  lab_0x80b1227:;
    int32_t v43 = v44 | 4; // 0x80b1229
    char v45 = v38;
    v46 = v45;
    result3 = v43;
    v47 = v39;
    v48 = v43;
    v49 = v39;
    if (v45 != 44) {
        goto lab_0x80b1002;
    } else {
        goto lab_0x80b1237;
    }
  lab_0x80b1237:
    // 0x80b1237
    *(char *)v49 = 0;
    int32_t v50 = v49 + 1; // 0x80b123d
    *(int32_t *)sponsor = v50;
    char v51 = *(char *)v50; // 0x80b1242
    int32_t v52 = v50; // 0x80b1247
    char v53 = v51; // 0x80b1247
    int32_t v54 = v50; // 0x80b1247
    if (v51 != 0 == (v51 != 95)) {
        while (true) {
          lab_0x80b125a:;
            int32_t v55 = v52 + 1; // 0x80b125a
            char v56 = *(char *)v55; // 0x80b125d
            v52 = v55;
            v53 = v56;
            v54 = v55;
            switch (v56) {
                case 95: {
                    goto lab_0x80b1265;
                }
                case 0: {
                    goto lab_0x80b1265;
                }
                default: {
                    goto lab_0x80b125a;
                }
            }
        }
    }
  lab_0x80b1265:;
    int32_t result2 = v48 | 2; // 0x80b1267
    if (v53 == 95) {
        // 0x80b1275
        *(char *)v54 = 0;
        *(int32_t *)revision = v54 + 1;
        return result2 | 1;
    }
    // 0x80b100d
    return result2;
  lab_0x80b1002:
    // 0x80b1002
    if (v46 != 95) {
        // 0x80b100d
        return result3;
    }
    // 0x80b1275
    *(char *)v47 = 0;
    *(int32_t *)revision = v47 + 1;
    return result3 | 1;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/intl/gettext/finddomain.c
// Address range: 0x80b1300 - 0x80b1596
// Line range:    45 - 144
int32_t * _nl_find_domain(char * dirname, char * locale, char * domainname, int32_t * domainbinding) {
    int32_t len = strlen(dirname); // 0x80b1312
    int32_t * v1 = _nl_make_l10nflist(&_nl_loaded_domains, dirname, len + 1, 0, locale, NULL, NULL, NULL, NULL, NULL, NULL, NULL, domainname, 0); // 0x80b137c
    int32_t v2 = (int32_t)v1; // 0x80b137c
    if (v1 != NULL) {
        // 0x80b138b
        if (*(int32_t *)(v2 + 12) == 0) {
            // 0x80b13a8
            _nl_load_domain(v1, domainbinding);
            if (*(int32_t *)(v2 + 16) != 0) {
                // 0x80b1399
                return (int32_t *)v2;
            }
        } else {
            // 0x80b1392
            if (*(int32_t *)(v2 + 16) != 0) {
                // 0x80b1399
                return (int32_t *)v2;
            }
        }
        int32_t v3 = v2 + 24; // 0x80b13be
        int32_t v4 = *(int32_t *)v3; // 0x80b13be
        if (v4 == 0) {
            // 0x80b1399
            return (int32_t *)v2;
        }
        int32_t v5 = 0; // 0x80b13c3
        if (*(int32_t *)(v4 + 12) == 0) {
            // 0x80b13ed
            _nl_load_domain((int32_t *)v4, domainbinding);
        }
        while (*(int32_t *)(*(int32_t *)(4 * v5 + v3) + 16) == 0) {
            // 0x80b13db
            v5++;
            int32_t v6 = *(int32_t *)(4 * v5 + v3); // 0x80b13de
            if (v6 == 0) {
                // break -> 0x80b1400
                break;
            }
            int32_t v7 = v6;
            if (*(int32_t *)(v7 + 12) == 0) {
                // 0x80b13ed
                _nl_load_domain((int32_t *)v7, domainbinding);
            }
        }
        // 0x80b1400
        return (int32_t *)(v5 < 0 ? 0 : v2);
    }
    char * v8 = _nl_expand_alias(locale); // 0x80b141b
    char * v9 = locale; // 0x80b1424
    if (v8 != NULL) {
        // 0x80b1426
        v9 = __strdup(v8);
        if (v9 == NULL) {
            // 0x80b1399
            return (int32_t *)v2;
        }
    }
    // 0x80b143e
    char * v10; // bp-32, 0x80b1300
    char * v11; // bp-36, 0x80b1300
    char * v12; // bp-40, 0x80b1300
    char * v13; // bp-44, 0x80b1300
    char * v14; // bp-48, 0x80b1300
    char * v15; // bp-52, 0x80b1300
    char * v16; // bp-56, 0x80b1300
    char * v17; // bp-60, 0x80b1300
    int32_t v18 = _nl_explode_name(v9, &v10, &v11, &v12, &v13, &v14, &v15, &v16, &v17); // 0x80b147c
    int32_t len2 = strlen(dirname); // 0x80b1487
    int32_t * v19 = _nl_make_l10nflist(&_nl_loaded_domains, dirname, len2 + 1, v18, v10, v12, v13, v14, v11, v15, v16, v17, domainname, 1); // 0x80b14ec
    int32_t v20 = (int32_t)v19; // 0x80b14ec
    if (v19 == NULL) {
        // 0x80b1399
        return (int32_t *)v20;
    }
    // 0x80b14fe
    if (*(int32_t *)(v20 + 12) == 0) {
        // 0x80b1532
        _nl_load_domain(v19, domainbinding);
    }
    // 0x80b1505
    if (*(int32_t *)(v20 + 16) == 0) {
        int32_t v21 = *(int32_t *)(v20 + 24); // 0x80b1546
        int32_t v22 = v20; // 0x80b154b
        if (v21 != 0) {
            if (*(int32_t *)(v21 + 12) == 0) {
                // 0x80b157b
                _nl_load_domain((int32_t *)v21, domainbinding);
            }
            while (*(int32_t *)(*(int32_t *)(v22 + 24) + 16) == 0) {
                int32_t v23 = *(int32_t *)(v22 + 28); // 0x80b156a
                v22 += 4;
                if (v23 == 0) {
                    // break -> 0x80b150c
                    break;
                }
                int32_t v24 = v23;
                if (*(int32_t *)(v24 + 12) == 0) {
                    // 0x80b157b
                    _nl_load_domain((int32_t *)v24, domainbinding);
                }
            }
        }
    }
    if (v8 != NULL) {
        // 0x80b1510
        free((int32_t *)v9);
    }
    // 0x80b1518
    if ((v18 & 8) == 0) {
        // 0x80b1399
        return (int32_t *)v20;
    }
    // 0x80b1522
    free((int32_t *)v14);
    // 0x80b1399
    return (int32_t *)v20;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/intl/gettext/gettext.c
// Address range: 0x80b15a0 - 0x80b15c3
// Line range:    34 - 37
char * gettext__(char * msgid) {
    // 0x80b15a0
    return dcgettext__(NULL, msgid, 5);
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/intl/gettext/intl-compat.c
// Address range: 0x80b1650 - 0x80b165c
// Line range:    81 - 83
char * gettext(char * msgid) {
    // 0x80b1650
    return gettext__((char *)&g83);
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/intl/gettext/l10nflist.c
// Address range: 0x80b1660 - 0x80b1766
// Line range:    327 - 347
char * _nl_normalize_codeset(char * codeset, uint32_t name_len) {
    int32_t v1 = (int32_t)codeset;
    int32_t size = 4; // 0x80b1676
    int32_t v2 = 1; // 0x80b1676
    if (name_len != 0) {
        int16_t * v3 = *__ctype_b_loc(); // 0x80b1688
        int32_t v4 = 0; // 0x80b168c
        int32_t v5 = 1;
        int32_t v6 = 0;
        unsigned char v7 = *(char *)(v4 + v1); // 0x80b1690
        int16_t v8 = *(int16_t *)(2 * (int32_t)v7 + (int32_t)v3); // 0x80b1694
        int32_t v9 = v6; // 0x80b169b
        int32_t v10 = v5; // 0x80b169b
        if ((v8 & 8) != 0) {
            // 0x80b169d
            v10 = (v8 & 1024) != 0 ? 0 : v5;
            v9 = v6 + 1;
        }
        int32_t v11 = v10;
        int32_t v12 = v9;
        v4++;
        while (v4 != name_len) {
            // 0x80b1690
            v5 = v11;
            v6 = v12;
            v7 = *(char *)(v4 + v1);
            v8 = *(int16_t *)(2 * (int32_t)v7 + (int32_t)v3);
            v9 = v6;
            v10 = v5;
            if ((v8 & 8) != 0) {
                // 0x80b169d
                v10 = (v8 & 1024) != 0 ? 0 : v5;
                v9 = v6 + 1;
            }
            // 0x80b16ab
            v11 = v10;
            v12 = v9;
            v4++;
        }
        if (v11 != 0) {
            // 0x80b1748
            size = v12 + 4;
            v2 = 1;
        } else {
            // 0x80b16bb
            size = v12 + 1;
            v2 = v11;
        }
    }
    int32_t * mem = malloc(size); // 0x80b16c1
    if (mem == NULL) {
        // 0x80b173a
        return (char *)mem;
    }
    int32_t v13 = (int32_t)mem; // 0x80b16c1
    int32_t v14 = v13; // 0x80b16d1
    if (v2 != 0) {
        // 0x80b1758
        *mem = 0x6f7369;
        v14 = v13 + 3;
    }
    int32_t v15 = v14; // 0x80b16dc
    if (name_len != 0) {
        int16_t ** v16 = __ctype_b_loc(); // 0x80b16e3
        int32_t v17 = 0; // 0x80b16f2
        int32_t v18 = v14; // 0x80b16f2
        while (true) {
            int32_t v19 = v18;
            int32_t v20 = v17;
            unsigned char v21 = *(char *)(v20 + v1); // 0x80b1712
            int32_t v22 = v21; // 0x80b1712
            int32_t v23; // 0x80b1660
            int32_t v24; // 0x80b1660
            if ((*(char *)((int32_t)*v16 + 1 + 2 * v22) & 4) == 0) {
                int32_t v25 = v19; // 0x80b16fe
                if (v21 < 58) {
                    // 0x80b1700
                    *(char *)v19 = v21;
                    v25 = v19 + 1;
                }
                int32_t v26 = v20 + 1; // 0x80b1705
                v23 = v26;
                v24 = v25;
                v15 = v25;
                if (v26 >= name_len) {
                    // break -> 0x80b1737
                    break;
                }
            } else {
                int32_t v27 = v20 + 1; // 0x80b1723
                *(char *)v19 = (char)c_tolower(v22);
                int32_t v28 = v19 + 1; // 0x80b172d
                v23 = v27;
                v24 = v28;
                v15 = v28;
                if (v27 >= name_len) {
                    // break -> 0x80b1737
                    break;
                }
            }
            // 0x80b170d
            v17 = v23;
            v18 = v24;
        }
    }
    // 0x80b1737
    *(char *)v15 = 0;
    // 0x80b173a
    return (char *)mem;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/intl/gettext/l10nflist.c
// Address range: 0x80b1770 - 0x80b1db9
// Line range:    149 - 285
int32_t * _nl_make_l10nflist(int32_t ** l10nfile_list, char * dirlist, int32_t dirlist_len, uint32_t mask, char * language, char * territory, char * codeset, char * normalized_codeset, char * modifier, char * special, char * sponsor, char * revision, char * filename, int32_t do_allocate) {
    int32_t len = strlen(language); // 0x80b1782
    int32_t v1 = 0; // 0x80b1792
    if ((mask & 32) != 0) {
        // 0x80b19c8
        v1 = strlen(territory) + 1;
    }
    int32_t v2 = 0; // 0x80b17a7
    if ((mask & 16) != 0) {
        // 0x80b19b0
        v2 = strlen(codeset) + 1;
    }
    int32_t v3 = 0; // 0x80b17bc
    if ((mask & 8) != 0) {
        // 0x80b1998
        v3 = strlen(normalized_codeset) + 1;
    }
    int32_t v4 = 0; // 0x80b17d1
    if ((mask & 192) != 0) {
        // 0x80b17d3
        v4 = strlen(modifier) + 1;
    }
    int32_t v5 = 0; // 0x80b17e9
    if ((mask & 4) != 0) {
        // 0x80b1980
        v5 = strlen(special) + 1;
    }
    int32_t v6 = 0; // 0x80b17fe
    int32_t v7; // 0x80b1770
    int32_t v8; // 0x80b1770
    int32_t v9; // 0x80b1770
    if (mask % 4 == 0) {
        goto lab_0x80b1821;
    } else {
        if ((mask & 2) != 0) {
            int32_t v10 = strlen(sponsor) + 2; // 0x80b1abb
            v8 = v10;
            v7 = 0;
            v9 = v10;
            if (mask % 2 == 0) {
                goto lab_0x80b181f;
            } else {
                goto lab_0x80b1a88;
            }
        } else {
            // 0x80b1811
            v8 = 1;
            v7 = 0;
            v9 = 1;
            if (mask % 2 != 0) {
                goto lab_0x80b1a88;
            } else {
                goto lab_0x80b181f;
            }
        }
    }
  lab_0x80b1c6d:;
    // 0x80b1c6d
    int32_t v11; // 0x80b1770
    int32_t v12 = v11; // 0x80b1c70
    int32_t v13; // 0x80b1770
    int32_t v14 = v13 - 1; // 0x80b1c70
    int32_t v15; // 0x80b1770
    int32_t v16 = v15; // 0x80b1c70
    int32_t v17 = v11; // 0x80b1c70
    if (v13 < 1) {
        // break -> 0x80b1d7a
        goto lab_0x80b1d7a;
    }
    goto lab_0x80b1c76;
  lab_0x80b1c8b:;
    // 0x80b1c8b
    int32_t v18; // 0x80b1770
    v11 = v18;
    int32_t v19; // 0x80b1c56
    uint32_t v20; // 0x80b1c59
    if (dirlist_len != 0 && (v13 & 24) != 24) {
        int32_t v21 = 4 * v18 + v15; // 0x80b1770
        int32_t v22 = v18;
        int32_t v23 = v19; // 0x80b1cc5
        v11 = v22;
        while (v23 != 0) {
            int32_t v24 = v21;
            int32_t v25 = v22 + 1; // 0x80b1cd4
            char * str = (char *)v23;
            int32_t * v26 = _nl_make_l10nflist(l10nfile_list, str, strlen(str) + 1, v13, language, territory, codeset, normalized_codeset, modifier, special, sponsor, revision, filename, 1); // 0x80b1d3b
            *(int32_t *)v24 = (int32_t)v26;
            v11 = v25;
            if (v23 >= v20) {
                // break -> 0x80b1c6d
                break;
            }
            // 0x80b1cb5
            v23 = (int32_t)__rawmemchr((int32_t *)v23, 0) + 1;
            v11 = v25;
            v21 = v24 + 4;
            if (v20 <= v23) {
                // break -> 0x80b1c6d
                break;
            }
            v22 = v25;
            v11 = v22;
        }
    }
    goto lab_0x80b1c6d;
  lab_0x80b1821:;
    int32_t * mem = malloc(dirlist_len + 2 + len + v1 + v2 + v3 + v4 + v5 + v6 + strlen(filename)); // 0x80b184e
    if (mem == NULL) {
        // 0x80b1972
        return (int32_t *)0;
    }
    int32_t v27 = (int32_t)mem; // 0x80b184e
    memcpy(mem, (int32_t *)dirlist, dirlist_len);
    __argz_stringify((char *)mem, dirlist_len, 58);
    int32_t str2 = v27 + dirlist_len;
    *(char *)(str2 - 1) = 47;
    char * v28 = stpcpy((char *)str2, language); // 0x80b18a9
    char * v29 = v28; // 0x80b18b6
    if ((mask & 32) != 0) {
        // 0x80b1b40
        *v28 = 95;
        v29 = stpcpy((char *)((int32_t)v28 + 1), territory);
    }
    char * v30 = v29;
    char * v31; // 0x80b1770
    char * v32; // 0x80b1770
    if ((mask & 16) != 0) {
        // 0x80b1af0
        *v30 = 46;
        char * v33 = stpcpy((char *)((int32_t)v30 + 1), codeset); // 0x80b1b06
        v31 = v33;
        v32 = v33;
        if ((mask & 8) == 0) {
            goto lab_0x80b18d2;
        } else {
            goto lab_0x80b1b19;
        }
    } else {
        // 0x80b18c7
        v31 = v30;
        v32 = v30;
        if ((mask & 8) != 0) {
            goto lab_0x80b1b19;
        } else {
            goto lab_0x80b18d2;
        }
    }
  lab_0x80b18d2:;
    char * v34 = v31;
    char * v35; // 0x80b1770
    char * v36; // 0x80b1770
    if ((mask & 192) != 0) {
        // 0x80b1a28
        *v34 = (mask & 64) == 0 ? 64 : 43;
        char * v37 = stpcpy((char *)((int32_t)v34 + 1), modifier); // 0x80b1a4c
        v35 = v37;
        v36 = v37;
        if ((mask & 4) == 0) {
            goto lab_0x80b18e9;
        } else {
            goto lab_0x80b1a5f;
        }
    } else {
        // 0x80b18de
        v35 = v34;
        v36 = v34;
        if ((mask & 4) != 0) {
            goto lab_0x80b1a5f;
        } else {
            goto lab_0x80b18e9;
        }
    }
  lab_0x80b1b19:
    // 0x80b1b19
    *v32 = 46;
    v31 = stpcpy((char *)((int32_t)v32 + 1), normalized_codeset);
    goto lab_0x80b18d2;
  lab_0x80b181f:
    // 0x80b181f
    v6 = v7 + v8;
    goto lab_0x80b1821;
  lab_0x80b1a88:
    // 0x80b1a88
    v8 = v9;
    v7 = strlen(revision) + 1;
    goto lab_0x80b181f;
  lab_0x80b18e9:;
    char * v38 = v35;
    char * v39 = v38; // 0x80b18f0
    if (mask % 4 != 0) {
        // 0x80b19e0
        *v38 = 44;
        char * str3 = (char *)((int32_t)v38 + 1); // 0x80b19ef
        char * v40 = str3; // 0x80b19f2
        if ((mask & 2) != 0) {
            // 0x80b1d60
            v40 = stpcpy(str3, sponsor);
        }
        char * v41 = v40;
        v39 = v41;
        if (mask % 2 != 0) {
            // 0x80b1a04
            *v41 = 95;
            v39 = stpcpy((char *)((int32_t)v41 + 1), revision);
        }
    }
    // 0x80b18f6
    *v39 = 47;
    int32_t v42 = (int32_t)v39; // 0x80b18fe
    strcpy((char *)(v42 + 1), filename);
    int32_t * v43 = *l10nfile_list;
    int32_t v44 = (int32_t)v43;
    int32_t v45 = v44; // 0x80b191a
    int32_t v46 = v44; // 0x80b191a
    int32_t v47 = v44; // 0x80b191a
    int32_t v48; // 0x80b1770
    if (v43 != NULL) {
        int32_t v49 = v45;
        int32_t str4 = *(int32_t *)v49; // 0x80b1928
        int32_t v50 = 0; // 0x80b192c
        int32_t strcmp_rc; // 0x80b1935
        if (str4 != 0) {
            // 0x80b192e
            strcmp_rc = strcmp((char *)str4, (char *)mem);
            if (strcmp_rc == 0) {
                // 0x80b1ac8
                free(mem);
                v48 = v49;
                goto lab_0x80b1972;
            }
            // 0x80b1943
            v50 = v49;
            if (strcmp_rc < 0) {
                // break -> 0x80b1959
                break;
            }
        }
        int32_t v51 = *(int32_t *)(v49 + 20); // 0x80b194b
        v46 = v51;
        v47 = v50;
        while (v51 != 0) {
            int32_t v52 = v50;
            v49 = v51;
            str4 = *(int32_t *)v49;
            v50 = v52;
            if (str4 != 0) {
                // 0x80b192e
                strcmp_rc = strcmp((char *)str4, (char *)mem);
                if (strcmp_rc == 0) {
                    // 0x80b1ac8
                    free(mem);
                    v48 = v49;
                    goto lab_0x80b1972;
                }
                // 0x80b1943
                v50 = v49;
                v46 = 0;
                v47 = v52;
                if (strcmp_rc < 0) {
                    // break -> 0x80b1959
                    break;
                }
            }
            // 0x80b194b
            v51 = *(int32_t *)(v49 + 20);
            v46 = v51;
            v47 = v50;
        }
    }
    if (do_allocate == 0) {
        // 0x80b1964
        free(mem);
        // 0x80b1972
        return (int32_t *)v46;
    }
    int32_t v53 = (mask / 2 & -0x2aab) + (mask & 0x5555); // 0x80b1b84
    uint32_t v54 = (v53 >> 2 & -3277) + (v53 & 0x3333); // 0x80b1b98
    uint32_t v55 = v54 / 16 + v54 & 3855; // 0x80b1ba1
    int32_t * mem2 = malloc(4 * (__argz_count(dirlist, dirlist_len) << (v55 / 256 + v55) % 32) + 28); // 0x80b1bbb
    int32_t v56 = (int32_t)mem2; // 0x80b1bbb
    v48 = v56;
    if (mem2 == NULL) {
        // 0x80b1972
        return (int32_t *)v48;
    }
    int32_t v57 = v47;
    *mem2 = v27;
    *(int32_t *)(v56 + 4) = str2;
    *(int32_t *)(v56 + 8) = v42 - str2;
    int32_t v58 = __argz_count(dirlist, dirlist_len); // 0x80b1bed
    *(int32_t *)(v56 + 12) = (int32_t)((mask & 24) == 24 | v58 != 1);
    *(int32_t *)(v56 + 16) = 0;
    if (v57 == 0) {
        // 0x80b1da4
        *(int32_t *)(v56 + 20) = (int32_t)*l10nfile_list;
        *(int32_t *)l10nfile_list = v56;
    } else {
        int32_t * v59 = (int32_t *)(v57 + 20); // 0x80b1c1a
        *(int32_t *)(v56 + 20) = *v59;
        *v59 = v56;
    }
    int32_t v60 = (int32_t)(__argz_count(dirlist, dirlist_len) == 1) + mask; // 0x80b1c44
    if (v60 < 0) {
        // 0x80b1c26
        v16 = v56 + 24;
        v17 = 0;
    } else {
        // 0x80b1c56
        v19 = (int32_t)dirlist;
        v20 = v19 + dirlist_len;
        v15 = v56 + 24;
        v12 = 0;
        v14 = v60;
        while (true) {
          lab_0x80b1c76:
            // 0x80b1c76
            v13 = v14;
            v18 = v12;
            v11 = v18;
            if ((v13 & -1 - mask) != 0) {
                goto lab_0x80b1c6d;
            } else {
                if ((v13 & 71) == 0) {
                    goto lab_0x80b1c8b;
                } else {
                    // 0x80b1c83
                    if ((v13 & 152) != 0) {
                        goto lab_0x80b1c6d;
                    } else {
                        goto lab_0x80b1c8b;
                    }
                }
            }
        }
    }
  lab_0x80b1d7a:
    // 0x80b1d7a
    *(int32_t *)(4 * v17 + v16) = 0;
    v48 = v56;
  lab_0x80b1972:
    // 0x80b1972
    return (int32_t *)v48;
  lab_0x80b1a5f:
    // 0x80b1a5f
    *v36 = 43;
    v35 = stpcpy((char *)((int32_t)v36 + 1), special);
    goto lab_0x80b18e9;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/util/string.h
// Address range: 0x80b2100 - 0x80b224a
// Line range:    246 - 270
int32_t * add_bytes_to_string__(int32_t * string, char * bytes, int32_t length) {
    // 0x80b2100
    if (assert_failed != 0) {
        // 0x80b211b
        assert_failed = 0;
        // 0x80b2128
        return (int32_t *)0;
    }
    int32_t v1; // 0x80b2100
    if (v1 < 0 || v1 == 0 || v1 == 0) {
        // 0x80b2140
        assert_failed = 1;
        errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
        errline = 255;
        elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
        if (assert_failed != 0) {
            // 0x80b211b
            assert_failed = 0;
            // 0x80b2128
            return (int32_t *)0;
        }
    } else {
        // 0x80b21e8
        assert_failed = 0;
    }
    if (v1 == 0) {
        // 0x80b2128
        int32_t v2; // 0x80b2100
        return (int32_t *)v2;
    }
    int32_t * v3 = (int32_t *)(v1 + 4); // 0x80b2183
    int32_t v4 = *v3; // 0x80b2183
    int32_t v5 = v4 + v1; // 0x80b2186
    int32_t v6 = v4 + 255; // 0x80b2189
    uint32_t v7 = v6 & -256; // 0x80b2197
    uint32_t v8 = v5 + 256 & -256; // 0x80b219e
    int32_t set_mem = v6; // 0x80b21a7
    if (v8 > v7) {
        char * v9 = mem_realloc((char *)v6, v8); // 0x80b2207
        if (v9 == NULL) {
            // 0x80b2128
            return (int32_t *)0;
        }
        int32_t v10 = (int32_t)v9; // 0x80b2207
        *(int32_t *)v1 = v10;
        set_mem = (int32_t)memset(&((struct _IO_FILE *)(v7 + v10))->e0, 0, v8 - v7);
    }
    // 0x80b21a9
    if (set_mem != 0) {
        int32_t * dest_mem = memcpy(&((struct _IO_FILE *)(*v3 + set_mem))->e0, (int32_t *)v1, v1); // 0x80b21c1
        *(char *)(v5 + (int32_t)dest_mem) = 0;
        *v3 = v5;
    }
    // 0x80b2128
    return (int32_t *)0;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/intl/gettext/loadmsgcat.c
// Address range: 0x80b2250 - 0x80b2296
// Line range:    201 - 209
void _nl_free_domain_conv(int32_t * domain) {
    int32_t v1 = (int32_t)domain;
    int32_t v2 = *(int32_t *)(v1 + 44); // 0x80b225a
    if (v2 < 0xffffffff) {
        // 0x80b2280
        free((int32_t *)v2);
        int32_t cd = *(int32_t *)(v1 + 40); // 0x80b2288
        if (cd != -1) {
            // 0x80b226d
            iconv_close((int32_t *)cd);
            return;
        }
    } else {
        int32_t cd2 = *(int32_t *)(v1 + 40); // 0x80b2265
        if (cd2 != -1) {
            // 0x80b226d
            iconv_close((int32_t *)cd2);
            return;
        }
    }
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/intl/gettext/loadmsgcat.c
// Address range: 0x80b22a0 - 0x80b23e5
// Line range:    119 - 998
char * _nl_init_domain_conv(int32_t * domain_file, int32_t * domain, int32_t * domainbinding) {
    int32_t v1 = (int32_t)domainbinding;
    int32_t v2 = 0; // 0x80b22b3
    if (domainbinding != NULL) {
        // 0x80b22b5
        v2 = *(int32_t *)(v1 + 8);
    }
    int32_t v3 = (int32_t)domain;
    *(int32_t *)(v3 + 36) = v2;
    int32_t * v4 = (int32_t *)(v3 + 40); // 0x80b22be
    *v4 = -1;
    *(int32_t *)(v3 + 44) = 0;
    int32_t v5; // bp-32, 0x80b22a0
    char * str = _nl_find_msg(domain_file, domainbinding, (char *)&g14, &v5); // 0x80b22e2
    if (str == NULL) {
        // 0x80b23ad
        return str;
    }
    char * substr_pos = strstr(str, "charset="); // 0x80b22fd
    if (substr_pos == NULL) {
        // 0x80b23ad
        return str;
    }
    int32_t v6 = (int32_t)substr_pos + 8; // 0x80b230a
    int32_t v7 = 1; // 0x80b22a0
    int32_t v8 = 0; // 0x80b2352
    switch (*(char *)v6) {
        case 0: {
            goto lab_0x80b2361;
        }
        case 32: {
            goto lab_0x80b2361;
        }
        case 9: {
            goto lab_0x80b2361;
        }
        case 10: {
            goto lab_0x80b2361;
        }
        default: {
            int32_t v9; // 0x80b22a0
            while (true) {
              lab_0x80b2352:
                // 0x80b2352
                v9 = v8;
                v8 = v9 + 1;
                switch (*(char *)(v8 + v6)) {
                    case 32: {
                        goto lab_0x80b235e;
                    }
                    case 10: {
                        goto lab_0x80b235e;
                    }
                    case 9: {
                        goto lab_0x80b235e;
                    }
                    case 0: {
                        goto lab_0x80b235e;
                    }
                    default: {
                        goto lab_0x80b2352;
                    }
                }
            }
          lab_0x80b235e:
            // 0x80b235e
            v7 = v9 + 2;
            goto lab_0x80b2361;
        }
    }
  lab_0x80b2361:;
    char * fromcode = mem_alloc(v7); // 0x80b2367
    *(char *)mempcpy((int32_t *)fromcode, (int32_t *)v6, v8) = 0;
    int32_t tocode; // 0x80b22a0
    if (domainbinding == NULL) {
        goto lab_0x80b23b8;
    } else {
        int32_t v10 = *(int32_t *)(v1 + 12); // 0x80b2389
        tocode = v10;
        if (v10 == 0) {
            goto lab_0x80b23b8;
        } else {
            goto lab_0x80b2390;
        }
    }
  lab_0x80b23b8:;
    char * env_val = getenv("OUTPUT_CHARSET"); // 0x80b23bf
    if (env_val == NULL) {
        // 0x80b23cd
        tocode = (int32_t)elinks_locale_charset();
        goto lab_0x80b2390;
    } else {
        // 0x80b23c8
        tocode = (int32_t)env_val;
        if (*env_val != 0) {
            goto lab_0x80b2390;
        } else {
            // 0x80b23cd
            tocode = (int32_t)elinks_locale_charset();
            goto lab_0x80b2390;
        }
    }
  lab_0x80b2390:
    // 0x80b2390
    *v4 = (int32_t)iconv_open((char *)tocode, fromcode);
    mem_free(fromcode);
    // 0x80b23ad
    return str;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/intl/gettext/loadmsgcat.c
// Address range: 0x80b23f0 - 0x80b2a10
// Line range:    241 - 413
void _nl_load_domain(int32_t * domain_file, int32_t * domainbinding) {
    int32_t v1 = (int32_t)domain_file;
    *(int32_t *)(v1 + 12) = 1;
    int32_t * v2 = (int32_t *)(v1 + 16); // 0x80b240f
    *v2 = 0;
    int32_t fd; // 0x80b23f0
    int32_t v3; // bp-36, 0x80b23f0
    if (init_string(&v3) != 0) {
        char * found_char_pos = strrchr(g82, 47); // 0x80b2439
        if (found_char_pos != NULL) {
            int32_t v4 = (int32_t)g82; // 0x80b2422
            uint32_t v5 = (int32_t)found_char_pos - v4 + 1; // 0x80b244a
            if (v5 >= 4) {
                // 0x80b2550
                bool v6; // 0x80b23f0
                int32_t v7 = v6 ? -1 : 1; // 0x80b255e
                int32_t v8 = (int32_t)"src"; // 0x80b23f0
                int32_t v9 = v4 - 4 + v5; // 0x80b23f0
                int32_t v10 = 3; // 0x80b255e
                while (*(char *)v9 == *(char *)v8) {
                    v10--;
                    v8 += v7;
                    v9 += v7;
                    if (v10 == 0) {
                        // 0x80b2566
                        if (add_bytes_to_string__(&g83, (char *)&g83, (int32_t)&g83) == NULL) {
                            // 0x80b245c
                            done_string(&v3);
                            goto lab_0x80b2464;
                        } else {
                            // 0x80b257b
                            if (add_to_string(&v3, (int32_t)"../po/") == 0) {
                                // 0x80b245c
                                done_string(&v3);
                                goto lab_0x80b2464;
                            } else {
                                // 0x80b2593
                                if (add_bytes_to_string__(&g83, (char *)&g83, (int32_t)&g83) == NULL) {
                                    // 0x80b245c
                                    done_string(&v3);
                                    goto lab_0x80b2464;
                                } else {
                                    // 0x80b25ab
                                    if (add_to_string(&v3, (int32_t)".gmo") == 0) {
                                        // 0x80b245c
                                        done_string(&v3);
                                        goto lab_0x80b2464;
                                    } else {
                                        int32_t v11 = open64((char *)v3, 0); // 0x80b25d1
                                        done_string(&v3);
                                        fd = v11;
                                        if (v11 != -1) {
                                            goto lab_0x80b2484;
                                        } else {
                                            goto lab_0x80b2464;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    // 0x80b245c
    done_string(&v3);
    goto lab_0x80b2464;
  lab_0x80b2464:;
    int32_t v12 = *domain_file; // 0x80b2467
    if (v12 == 0) {
        // 0x80b24b1
        return;
    }
    int32_t v13 = open64((char *)v12, 0); // 0x80b2478
    fd = v13;
    if (v13 == -1) {
        // 0x80b24b1
        return;
    }
    goto lab_0x80b2484;
  lab_0x80b2484:;
    // 0x80b2484
    int32_t v14; // bp-132, 0x80b23f0
    if (__fxstat64(3, fd, (struct stat64 *)&v14) != 0) {
      lab_0x80b24a9:
        // 0x80b24a9
        close(fd);
        // 0x80b24b1
        return;
    }
    int32_t size; // 0x80b23f0
    if (size < 28 || size != 0) {
        // 0x80b24a9
        close(fd);
        // 0x80b24b1
        return;
    }
    int32_t * v15 = mmap64(NULL, size, 1, 2, fd, 0); // 0x80b24f4
    int32_t v16; // 0x80b23f0
    int32_t v17; // 0x80b23f0
    if (v15 == (int32_t *)-1) {
        int32_t * mem = malloc(size); // 0x80b2903
        int32_t v18 = (int32_t)mem; // 0x80b2903
        if (mem == NULL) {
            // 0x80b24b1
            return;
        }
        int32_t buf = v18; // 0x80b290a
        int32_t nbyte; // 0x80b23f0
        int32_t v19 = read(fd, (int32_t *)buf, nbyte); // 0x80b2959
        // 0x80b2942
        while (v19 == -1) {
            // 0x80b2963
            if (*__errno_location() != 4) {
                // break (via goto) -> 0x80b24a9
                goto lab_0x80b24a9;
            }
            v19 = read(fd, (int32_t *)buf, nbyte);
        }
        while (v19 >= 1) {
            int32_t v20 = nbyte - v19; // 0x80b2930
            nbyte = v20;
            buf += v19;
            if (v20 == 0) {
                // 0x80b29d6
                close(fd);
                v16 = 0;
                v17 = v18;
                goto lab_0x80b251b;
            }
            v19 = read(fd, (int32_t *)buf, nbyte);
            // 0x80b2942
            while (v19 == -1) {
                // 0x80b2963
                if (*__errno_location() != 4) {
                    // break (via goto) -> 0x80b24a9
                    goto lab_0x80b24a9;
                }
                v19 = read(fd, (int32_t *)buf, nbyte);
            }
        }
        // 0x80b24a9
        close(fd);
        // 0x80b24b1
        return;
    }
    // 0x80b2502
    close(fd);
    v16 = 1;
    v17 = (int32_t)v15;
    goto lab_0x80b251b;
  lab_0x80b251b:;
    int32_t v21 = v17;
    int32_t * v22 = (int32_t *)v21; // 0x80b251b
    int32_t * mem2; // 0x80b261b
    int32_t v23; // 0x80b261b
    int32_t v24; // 0x80b2646
    switch (*v22) {
        case -0x21edfb6b: {
        }
        case -0x6afbed22: {
            // 0x80b2608
            mem2 = malloc(56);
            if (mem2 == NULL) {
                // 0x80b24b1
                return;
            }
            // 0x80b2636
            v23 = (int32_t)mem2;
            *v2 = v23;
            *mem2 = v21;
            *(int32_t *)(v23 + 4) = v16;
            v24 = *v22;
            *(int32_t *)(v23 + 12) = (int32_t)(v24 != -0x6afbed22);
            int32_t v25 = *(int32_t *)(v21 + 4);
            if ((v24 == -0x6afbed22 ? v25 : llvm_bswap_i32(v25)) != 0) {
                if (v16 == 0) {
                    // 0x80b29cc
                    free(v22);
                } else {
                    // 0x80b2985
                    munmap(v22, size);
                }
                // 0x80b2991
                free(mem2);
                *v2 = 0;
                // 0x80b24b1
                return;
            }
            // break -> 0x80b26a8
            break;
        }
        default: {
            if (v16 == 0) {
                // 0x80b25f0
                free(v22);
            } else {
                // 0x80b253b
                munmap(v22, size);
            }
            // 0x80b24b1
            return;
        }
    }
    int32_t v26 = *(int32_t *)(v21 + 8);
    int32_t v27; // 0x80b23f0
    if (v24 == -0x6afbed22) {
        // 0x80b29a8
        *(int32_t *)(v23 + 16) = v26;
        *(int32_t *)(v23 + 20) = *(int32_t *)(v21 + 12) + v21;
        *(int32_t *)(v23 + 24) = *(int32_t *)(v21 + 16) + v21;
        *(int32_t *)(v23 + 28) = *(int32_t *)(v21 + 20);
        v27 = *(int32_t *)(v21 + 24);
    } else {
        // 0x80b26b6
        *(int32_t *)(v23 + 16) = llvm_bswap_i32(v26);
        *(int32_t *)(v23 + 20) = llvm_bswap_i32(*(int32_t *)(v21 + 12)) + v21;
        *(int32_t *)(v23 + 24) = llvm_bswap_i32(*(int32_t *)(v21 + 16)) + v21;
        *(int32_t *)(v23 + 28) = llvm_bswap_i32(*(int32_t *)(v21 + 20));
        v27 = llvm_bswap_i32(*(int32_t *)(v21 + 24));
    }
    // 0x80b278b
    *(int32_t *)(v23 + 32) = v27 + v21;
    char * str = _nl_init_domain_conv(domain_file, mem2, domainbinding); // 0x80b27a2
    if (str != NULL) {
        char * substr_pos = strstr(str, "plural="); // 0x80b27bc
        char * substr_pos2 = strstr(str, "nplurals="); // 0x80b27d2
        if (substr_pos != NULL && substr_pos2 != NULL) {
            int16_t * v28 = *__ctype_b_loc(); // 0x80b27f5
            int32_t v29 = (int32_t)substr_pos2 + 9;
            unsigned char v30 = *(char *)v29; // 0x80b2803
            int32_t v31 = v30; // 0x80b2803
            int32_t v32 = v29 + 1; // 0x80b280e
            while ((*(char *)((int32_t)v28 + 1 + 2 * v31) & 32) != 0) {
                // 0x80b2803
                v29 = v32;
                v30 = *(char *)v29;
                v31 = v30;
                v32 = v29 + 1;
            }
            // 0x80b2810
            if (v30 < 58) {
                int32_t v33 = v29 + 1; // 0x80b2830
                int32_t v34 = v31 - 48; // 0x80b2843
                unsigned char v35 = *(char *)v33; // 0x80b2847
                int32_t v36 = v33; // 0x80b2852
                int32_t v37 = v34; // 0x80b2852
                while (v35 < 58) {
                    // 0x80b2830
                    v33 = v36 + 1;
                    v34 = (int32_t)v35 - 48 + 10 * v37;
                    v35 = *(char *)v33;
                    v36 = v33;
                    v37 = v34;
                }
                // 0x80b2854
                *(int32_t *)(v23 + 52) = v34;
                if (v29 != v33) {
                    // 0x80b2867
                    v3 = (int32_t)substr_pos + 7;
                    if (gettext__parse((char *)&v3) == 0) {
                        // 0x80b24b1
                        return;
                    }
                }
            } else {
                // 0x80b2a04
                *(int32_t *)(v23 + 52) = 0;
            }
        }
    }
    // 0x80b2883
    if (g62 == 0) {
        // 0x80b288d
        plvar = 0;
        g60 = 0;
        plone = 0;
        g61 = 1;
        g62 = 1;
        germanic_plural = 2;
        g63 = 13;
        g64 = &plvar;
        g65 = &plone;
    }
    // 0x80b28e7
    *(int32_t *)(v23 + 48) = (int32_t)&germanic_plural;
    *(int32_t *)(v23 + 52) = 2;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/intl/gettext/localcharset.c
// Address range: 0x80b2a10 - 0x80b2d30
// Line range:    202 - 267
char * elinks_locale_charset(void) {
    int32_t item = __readgsdword(20); // 0x80b2a23
    char * v1 = nl_langinfo(item); // 0x80b2a2e
    int32_t v2 = charset_aliases; // 0x80b2a47
    int32_t v3; // 0x80b2a10
    int32_t v4; // 0x80b2a10
    int32_t v5; // 0x80b2a10
    int32_t v6; // 0x80b2a10
    int32_t v7; // 0x80b2a10
    int32_t v8; // 0x80b2a10
    int32_t v9; // 0x80b2a10
    int32_t v10; // 0x80b2a10
    int32_t v11; // 0x80b2a10
    int32_t * mem; // 0x80b2adc
    struct _IO_FILE * file; // 0x80b2b43
    if (charset_aliases == 0) {
        // 0x80b2ac0
        mem = malloc(23);
        v8 = &g14;
        if (mem == NULL) {
            goto lab_0x80b2ca6;
        } else {
            int32_t v12 = (int32_t)mem; // 0x80b2adc
            *mem = 0x7273752f;
            *(int32_t *)(v12 + 4) = 0x62696c2f;
            *(char *)(v12 + 8) = 47;
            *(int32_t *)(v12 + 9) = 0x72616863;
            *(int32_t *)(v12 + 13) = 0x2e746573;
            *(int32_t *)(v12 + 17) = 0x61696c61;
            *(int16_t *)(v12 + 21) = 115;
            file = fopen64((char *)mem, "rb");
            v7 = &g14;
            if (file != NULL) {
                int32_t v13 = _IO_getc(file); // 0x80b2b63
                if (v13 == -1) {
                    // 0x80b2c78
                    fclose(file);
                    v7 = &g14;
                } else {
                    // 0x80b2b71
                    v3 = v13;
                    v4 = 0;
                    v9 = 0;
                    while (true) {
                      lab_0x80b2b71_2:;
                        int32_t v14 = v9; // 0x80b2a10
                        int32_t v15 = v3; // 0x80b2a10
                        int32_t v16 = v4; // 0x80b2a10
                        while (true) {
                          lab_0x80b2b71:
                            // 0x80b2b71
                            v5 = v16;
                            int32_t c = v15;
                            v10 = v14;
                            switch (c) {
                                case 32: {
                                    goto lab_0x80b2b60;
                                }
                                case 10: {
                                    goto lab_0x80b2b60;
                                }
                                case 9: {
                                    goto lab_0x80b2b60;
                                }
                                case 35: {
                                    int32_t v17 = _IO_getc(file); // 0x80b2cbb
                                    while (v17 != 10) {
                                        // 0x80b2cc9
                                        v11 = v10;
                                        v6 = v5;
                                        if (v17 == -1) {
                                            // break (via goto) -> 0x80b2c78
                                            goto lab_0x80b2c78_4;
                                        }
                                        v17 = _IO_getc(file);
                                    }
                                    goto lab_0x80b2b60;
                                }
                                default: {
                                    // 0x80b2b8b
                                    ungetc(c, file);
                                    int32_t str2; // bp-134, 0x80b2a10
                                    int32_t str; // bp-83, 0x80b2a10
                                    int32_t items_assigned = fscanf(file, "%50s %50s", &str, &str2); // 0x80b2bb3
                                    v11 = v10;
                                    v6 = v5;
                                    if (items_assigned < 2) {
                                        // break (via goto) -> 0x80b2c78
                                        goto lab_0x80b2c78_4;
                                    }
                                    int32_t len = strlen((char *)&str); // 0x80b2bc7
                                    int32_t len2 = strlen((char *)&str2); // 0x80b2bdb
                                    int32_t v18 = len2 + len;
                                    int32_t v19 = v18 + 2;
                                    int32_t v20; // 0x80b2a10
                                    int32_t * mem3; // 0x80b2a10
                                    if (v10 != 0) {
                                        int32_t v21 = v19 + v10; // 0x80b2cf2
                                        int32_t * mem2 = realloc((int32_t *)v5, v21 + 1); // 0x80b2d01
                                        v20 = v21;
                                        mem3 = mem2;
                                    } else {
                                        // 0x80b2bf0
                                        v20 = v19;
                                        mem3 = malloc(v18 + 3);
                                    }
                                    // 0x80b2c1a
                                    if (mem3 == NULL) {
                                        // 0x80b2d13
                                        fclose(file);
                                        v7 = &g14;
                                        goto lab_0x80b2c98;
                                    }
                                    int32_t v22 = (int32_t)mem3;
                                    int32_t v23 = v20 - len2 + v22;
                                    strcpy((char *)(v23 - 2 - len), (char *)&str);
                                    strcpy((char *)(v23 - 1), (char *)&str2);
                                    int32_t v24 = _IO_getc(file); // 0x80b2c6a
                                    v14 = v20;
                                    v15 = v24;
                                    v16 = v22;
                                    v11 = v20;
                                    v6 = v22;
                                    if (v24 == -1) {
                                        // break (via goto) -> 0x80b2c78
                                        goto lab_0x80b2c78_4;
                                    }
                                    goto lab_0x80b2b71;
                                }
                            }
                        }
                        goto lab_0x80b2b60;
                    }
                  lab_0x80b2c78_4:
                    // 0x80b2c78
                    fclose(file);
                    v7 = &g14;
                    if (v11 != 0) {
                        // 0x80b2c8e
                        *(char *)(v6 + v11) = 0;
                        v7 = v6;
                    }
                }
            }
            goto lab_0x80b2c98;
        }
    } else {
        goto lab_0x80b2a49;
    }
  lab_0x80b2b60:;
    int32_t v25 = _IO_getc(file); // 0x80b2b63
    v3 = v25;
    v4 = v5;
    v9 = v10;
    v11 = v10;
    v6 = v5;
    if (v25 == -1) {
        // break -> 0x80b2c78
        goto lab_0x80b2c78_4;
    }
    goto lab_0x80b2b71_2;
  lab_0x80b2a49:;
    int32_t str3 = v1 == NULL ? (int32_t)&g14 : (int32_t)v1; // 0x80b2a42
    char v26 = *(char *)v2; // 0x80b2a49
    int32_t v27 = str3; // 0x80b2a50
    if (v26 != 0) {
        char v28 = v26; // 0x80b2a70
        int32_t v29 = v2;
        char * str4 = (char *)v29;
        int32_t v30; // 0x80b2a10
        while (strcmp((char *)str3, str4) != 0) {
            int32_t v31 = v29 + 1;
            if (v28 == 42) {
                // 0x80b2a8f
                v30 = v31;
                if (*(char *)v31 == 0) {
                    goto lab_0x80b2a95;
                }
            }
            int32_t str5 = strlen(str4) + v31; // 0x80b2a60
            int32_t v32 = str5 + 1 + strlen((char *)str5); // 0x80b2a6c
            v28 = *(char *)v32;
            v27 = str3;
            if (v28 == 0) {
                goto lab_0x80b2aa1;
            }
            v29 = v32;
            str4 = (char *)v29;
        }
        // 0x80b2a79
        v30 = v29 + 1;
      lab_0x80b2a95:
        // 0x80b2a95
        v27 = strlen(str4) + v30;
    }
  lab_0x80b2aa1:
    // 0x80b2aa1
    if (item != __readgsdword(20)) {
        // 0x80b2d25
        __stack_chk_fail();
        return (char *)&g83;
    }
    // 0x80b2ab3
    return (char *)v27;
  lab_0x80b2ca6:
    // 0x80b2ca6
    v2 = v8;
    charset_aliases = v2;
    goto lab_0x80b2a49;
  lab_0x80b2c98:
    // 0x80b2c98
    free(mem);
    v8 = v7;
    goto lab_0x80b2ca6;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/intl/gettext/localealias.c
// Address range: 0x80b2d30 - 0x80b31d0
// Line range:    123 - 264
int32_t read_alias_file(char * fname, int32_t fname_len) {
    int32_t v1 = __readgsdword(20); // 0x80b2d40
    int32_t v2; // 0x80b2d30
    char * v3 = mem_alloc(v2 + 14); // 0x80b2d51
    int32_t * v4 = mempcpy((int32_t *)v3, (int32_t *)v2, v2); // 0x80b2d63
    int32_t v5 = (int32_t)v4; // 0x80b2d63
    *v4 = 0x636f6c2f;
    *(int32_t *)(v5 + 4) = 0x2e656c61;
    *(int32_t *)(v5 + 8) = 0x61696c61;
    *(int16_t *)(v5 + 12) = 115;
    struct _IO_FILE * file = fopen64(v3, "rb"); // 0x80b2d8d
    mem_free(v3);
    int32_t result = 0; // 0x80b2da8
    if (file != NULL) {
        // 0x80b2db0
        if ((*(char *)file & 16) != 0) {
            // 0x80b305d
            fclose(file);
            result = 0;
        } else {
            // 0x80b2db9
            int32_t v6; // 0x80b2d30
            while (true) {
                // 0x80b2db9
                v6 = 0;
                while (true) {
                  lab_0x80b2db9:;
                    // 0x80b2db9
                    int32_t str; // bp-8224, 0x80b2d30
                    if (fgets_unlocked((char *)&str, 0x2000, file) == NULL) {
                        // break (via goto) -> 0x80b305d
                        goto lab_0x80b305d_2;
                    }
                    // 0x80b2ddb
                    if (strchr((char *)&str, 10) == NULL) {
                        int32_t str2; // bp-16416, 0x80b2d30
                        while (fgets_unlocked((char *)&str2, 0x2000, file) != NULL) {
                            // 0x80b3032
                            if (strchr((char *)&str2, 10) != NULL) {
                                // break -> 0x80b2df9
                                break;
                            }
                        }
                    }
                    int16_t ** v7 = __ctype_b_loc(); // 0x80b2df9
                    int32_t v8 = (int32_t)*v7 + 1;
                    int32_t v9 = &str; // 0x80b2e06
                    unsigned char v10 = *(char *)v9; // 0x80b2e0b
                    int32_t v11 = v9 + 1;
                    v9 = v11;
                    while ((*(char *)(2 * (int32_t)v10 + v8) & 32) != 0) {
                        // 0x80b2e0b
                        v10 = *(char *)v9;
                        v11 = v9 + 1;
                        v9 = v11;
                    }
                    switch (v10) {
                        case 35: {
                            goto lab_0x80b2db0;
                        }
                        case 0: {
                            goto lab_0x80b2db0;
                        }
                        default: {
                            char v12 = *(char *)v11; // 0x80b2e21
                            char v13 = v12; // 0x80b2e2a
                            int32_t v14 = v11; // 0x80b2e2a
                            int32_t v15 = v8; // 0x80b2e2a
                            char v16 = 0; // 0x80b2e2a
                            int32_t v17 = v11; // 0x80b2e2a
                            if (v12 != 0) {
                                int32_t v18 = v14;
                                while ((*(char *)(2 * (int32_t)v13 + v8) & 32) == 0) {
                                    int32_t v19 = v18 + 1; // 0x80b2e38
                                    char v20 = *(char *)v19; // 0x80b2e3b
                                    v13 = v20;
                                    v14 = v19;
                                    v15 = v8;
                                    v16 = 0;
                                    v17 = v19;
                                    if (v20 == 0) {
                                        goto lab_0x80b2e66;
                                    }
                                    v18 = v14;
                                }
                                // 0x80b2e50
                                *(char *)v18 = 0;
                                int32_t v21 = v18 + 1; // 0x80b2e53
                                v15 = (int32_t)*v7 + 1;
                                v16 = *(char *)v21;
                                v17 = v21;
                            }
                          lab_0x80b2e66:;
                            int32_t v22 = v15;
                            int32_t v23 = v17; // 0x80b2e6e
                            char v24 = v16; // 0x80b2e6e
                            if ((*(char *)(2 * (int32_t)v16 + v22) & 32) != 0) {
                                int32_t v25 = v23 + 1; // 0x80b2e60
                                unsigned char v26 = *(char *)v25; // 0x80b2e63
                                v23 = v25;
                                v24 = v26;
                                while ((*(char *)(2 * (int32_t)v26 + v22) & 32) != 0) {
                                    // 0x80b2e60
                                    v25 = v23 + 1;
                                    v26 = *(char *)v25;
                                    v23 = v25;
                                    v24 = v26;
                                }
                            }
                            // 0x80b2e70
                            if (v24 != 0) {
                                // break -> 0x80b2e78
                                break;
                            }
                            goto lab_0x80b2db0;
                        }
                    }
                }
            }
          lab_0x80b305d_2:
            // 0x80b305d
            fclose(file);
            result = 0;
            if (v6 != 0) {
                // 0x80b306f
                qsort(map, nmap, 8, (int32_t (*)(int32_t *, int32_t *))0x80b32b0);
                result = v6;
            }
        }
    }
    // 0x80b3095
    if (v1 != __readgsdword(20)) {
        // 0x80b31c2
        __stack_chk_fail();
        return &g83;
    }
    // 0x80b30ab
    return result;
  lab_0x80b2db0:
    // 0x80b2db0
    if ((*(char *)file & 16) != 0) {
        // break (via goto) -> 0x80b305d
        goto lab_0x80b305d_2;
    }
    goto lab_0x80b2db9;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/intl/gettext/localealias.c
// Address range: 0x80b31d0 - 0x80b32aa
// Line range:    69 - 95
char * _nl_expand_alias(char * name) {
    char * key = name; // bp-36, 0x80b31e4
    if (nmap != 0) {
        // 0x80b3278
        if (bsearch((int32_t *)&key, map, nmap, 8, (int32_t (*)(int32_t *, int32_t *))0x80b32b0) != NULL) {
            // break -> 0x80b32a5
            break;
        }
    }
    char v1 = *(char *)&g36; // 0x80b31f5
    while (v1 != 0) {
        char v2 = v1; // 0x80b31fa
        char v3 = v2; // 0x80b31fe
        int32_t v4 = (int32_t)g36; // 0x80b31fe
        int32_t v5; // 0x80b31d0
        char v6; // 0x80b31d0
        int32_t v7; // 0x80b31d0
        int32_t v8; // 0x80b31d0
        int32_t v9; // 0x80b31d0
        int32_t v10; // 0x80b31d0
        int32_t v11; // 0x80b3208
        char v12; // 0x80b320b
        int32_t v13; // 0x80b3224
        while (true) {
            // 0x80b3200
            v7 = v4;
            v5 = v4;
            v6 = v3;
            if (v3 == 58) {
                v11 = v7 + 1;
                v12 = *(char *)v11;
                v7 = v11;
                v5 = v11;
                v6 = v12;
                while (v12 == 58) {
                    // 0x80b3208
                    v11 = v7 + 1;
                    v12 = *(char *)v11;
                    v7 = v11;
                    v5 = v11;
                    v6 = v12;
                }
            }
            // 0x80b3217
            v8 = v5;
            v9 = v5;
            if (v6 != 0) {
                while (true) {
                    // 0x80b3224
                    v13 = v8 + 1;
                    v8 = v13;
                    v9 = v13;
                    switch (*(char *)v13) {
                        case 58: {
                            goto lab_0x80b3234;
                        }
                        case 0: {
                            goto lab_0x80b3234;
                        }
                        default: {
                            goto lab_0x80b3224;
                        }
                    }
                }
            }
            // 0x80b3234
            v10 = v9;
            if (v5 < v10) {
                // break -> 0x80b3248
                break;
            }
            // 0x80b3238
            v3 = *(char *)v10;
            v4 = v10;
            if (v3 == 0) {
                // 0x80b3270
                *(int32_t *)&g36 = v10;
                return NULL;
            }
        }
        // 0x80b3248
        *(int32_t *)&g36 = v10;
        while (read_alias_file((char *)&g83, (int32_t)&g83) == 0) {
            // 0x80b3259
            v2 = *(char *)&g36;
            if (v2 == 0) {
                // 0x80b3268
                return NULL;
            }
            v3 = v2;
            v4 = (int32_t)g36;
            while (true) {
                // 0x80b3200
                v7 = v4;
                v5 = v4;
                v6 = v3;
                if (v3 == 58) {
                    v11 = v7 + 1;
                    v12 = *(char *)v11;
                    v7 = v11;
                    v5 = v11;
                    v6 = v12;
                    while (v12 == 58) {
                        // 0x80b3208
                        v11 = v7 + 1;
                        v12 = *(char *)v11;
                        v7 = v11;
                        v5 = v11;
                        v6 = v12;
                    }
                }
                // 0x80b3217
                v8 = v5;
                v9 = v5;
                if (v6 != 0) {
                    while (true) {
                        // 0x80b3224
                        v13 = v8 + 1;
                        v8 = v13;
                        v9 = v13;
                        switch (*(char *)v13) {
                            case 58: {
                                goto lab_0x80b3234;
                            }
                            case 0: {
                                goto lab_0x80b3234;
                            }
                            default: {
                                goto lab_0x80b3224;
                            }
                        }
                    }
                }
                // 0x80b3234
                v10 = v9;
                if (v5 < v10) {
                    // break -> 0x80b3248
                    break;
                }
                // 0x80b3238
                v3 = *(char *)v10;
                v4 = v10;
                if (v3 == 0) {
                    // 0x80b3270
                    *(int32_t *)&g36 = v10;
                    return NULL;
                }
            }
            // 0x80b3248
            *(int32_t *)&g36 = v10;
        }
        key = name;
        if (nmap != 0) {
            // 0x80b3278
            if (bsearch((int32_t *)&key, map, nmap, 8, (int32_t (*)(int32_t *, int32_t *))0x80b32b0) != NULL) {
                // break -> 0x80b32a5
                break;
            }
        }
        // 0x80b31ef
        v1 = *(char *)&g36;
    }
    // 0x80b3268
    return NULL;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/build-main/src/intl/gettext/plural.y
// Address range: 0x80b3310 - 0x80b3376
// Line range:    212 - 234
void gettext_free_exp__(int32_t * exp) {
    // 0x80b3310
    if (exp == NULL) {
        // 0x80b3370
        return;
    }
    int32_t v1 = (int32_t)exp;
    switch (*exp) {
        case 3: {
            // 0x80b3340
            gettext_free_exp__((int32_t *)*(int32_t *)(v1 + 16));
        }
        case 2: {
            // 0x80b334b
            gettext_free_exp__((int32_t *)*(int32_t *)(v1 + 12));
        }
        case 1: {
            // 0x80b3356
            gettext_free_exp__((int32_t *)*(int32_t *)(v1 + 8));
            free(exp);
            return;
        }
        default: {
            // 0x80b3332
            int32_t v2; // 0x80b3310
            free((int32_t *)v2);
            return;
        }
    }
}

// From module:   /home/naftali/source/elinks-0.12~pre5/build-main/src/intl/gettext/plural.y
// Address range: 0x80b3380 - 0x80b3444
// Line range:    67 - 93
int32_t * new_exp(int32_t nargs, int32_t op, int32_t ** args) {
    // 0x80b3380
    int32_t v1; // 0x80b3380
    int32_t v2 = v1 - 1; // 0x80b338d
    int32_t v3; // 0x80b3380
    int32_t v4; // 0x80b3380
    if (v2 < 0) {
        goto lab_0x80b33be;
    } else {
        int32_t v5 = *(int32_t *)(4 * v2 + v1); // 0x80b3398
        int32_t v6 = v1 - 2;
        v3 = v6;
        v4 = 0;
        if (v5 == 0) {
            goto lab_0x80b3418;
        } else {
            int32_t v7 = v2; // 0x80b33aa
            int32_t v8 = 4 * v6 + v1; // 0x80b33aa
            v7--;
            while (v7 >= 0) {
                int32_t v9 = v8;
                v8 = v9 - 4;
                v3 = v6;
                v4 = v5;
                if (*(int32_t *)v9 == 0) {
                    goto lab_0x80b3418;
                }
                v7--;
            }
            goto lab_0x80b33be;
        }
    }
  lab_0x80b3418:
    // 0x80b3418
    gettext_free_exp__((int32_t *)v4);
    if (v3 < 0) {
        // 0x80b33f9
        return NULL;
    }
    int32_t v10 = 4 * v3 + v1; // 0x80b3380
    gettext_free_exp__((int32_t *)*(int32_t *)v10);
    int32_t v11 = v3 - 1; // 0x80b3435
    int32_t v12 = v11; // 0x80b3438
    v10 -= 4;
    while (v11 >= 0) {
        // 0x80b3428
        gettext_free_exp__((int32_t *)*(int32_t *)v10);
        v11 = v12 - 1;
        v12 = v11;
        v10 -= 4;
    }
    // 0x80b33f9
    return NULL;
  lab_0x80b33be:;
    int32_t * mem = malloc(20); // 0x80b33c5
    if (mem != NULL) {
        // 0x80b33ce
        if (v2 < 0) {
            // 0x80b33f9
            return mem;
        }
        int32_t v13 = 4 * v2; // 0x80b33dd
        int32_t v14 = v13 + 8 + (int32_t)mem; // 0x80b33e6
        int32_t v15 = 0; // 0x80b33e6
        int32_t v16 = v13 + v1; // 0x80b33e6
        v15++;
        *(int32_t *)v14 = *(int32_t *)v16;
        v14 -= 4;
        v16 -= 4;
        while (v15 != v1) {
            // 0x80b33e8
            v15++;
            *(int32_t *)v14 = *(int32_t *)v16;
            v14 -= 4;
            v16 -= 4;
        }
        // 0x80b33f9
        return mem;
    }
    // 0x80b3401
    if (v2 < 0) {
        // 0x80b33f9
        return NULL;
    }
    // 0x80b3405
    v3 = v1 - 2;
    v4 = *(int32_t *)(4 * v2 + v1);
    goto lab_0x80b3418;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/build-main/src/intl/gettext/plural.c
// Address range: 0x80b3450 - 0x80b3bf0
// Line range:    856 - 1423
int32_t gettext__parse(char * arg) {
    int32_t v1[200]; // 0x80b360e
    int32_t v2[200]; // 0x80b3555
    int32_t v3[200]; // 0x80b3685
    int32_t v4[200]; // 0x80b36bd
    int32_t v5[200]; // 0x80b34c3
    int32_t v6[200]; // 0x80b386d
    int32_t v7[200]; // 0x80b3749
    int32_t v8[200]; // 0x80b384d
    int32_t yyvsa2[200]; // bp-1248, 0x80b3450
    int32_t yyvsa[200]; // bp-1252, 0x80b3450
    int32_t v9 = __readgsdword(20); // 0x80b345f
    int32_t v10; // bp-444, 0x80b3450
    int32_t v11 = &v10; // 0x80b346b
    int32_t v12; // bp-1244, 0x80b3450
    int32_t v13 = &v12; // 0x80b3471
    yyvsa2 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    int32_t v14 = 0; // 0x80b34a9
    int32_t v15 = -2; // 0x80b34a9
    int32_t v16 = 200; // 0x80b34a9
    int32_t v17 = 199; // 0x80b34a9
    int32_t v18 = v11; // 0x80b34a9
    int32_t v19 = v13; // 0x80b34a9
    int32_t v20 = v11; // 0x80b34a9
    int32_t v21; // bp-1324, 0x80b3450
    int32_t v22 = &v21; // 0x80b34a9
    int32_t v23 = v13; // 0x80b34a9
    int32_t result; // 0x80b3450
    int32_t v24; // 0x80b3450
    int32_t v25; // 0x80b3450
    int32_t v26; // 0x80b3450
    int32_t v27; // 0x80b3450
    int32_t v28; // 0x80b3450
    int32_t v29; // 0x80b3450
    int32_t v30; // 0x80b3450
    int32_t v31; // 0x80b3450
    int32_t v32; // 0x80b3450
    int32_t v33; // 0x80b3450
    char v34; // 0x80b3450
    int32_t v35; // 0x80b37a6
    int32_t v36; // 0x80b3594
    int32_t v37; // 0x80b359a
    int32_t v38; // 0x80b3450
    while (true) {
      lab_0x80b34b3:;
        int32_t v39 = v22;
        int32_t v40 = v20;
        int32_t v41 = v19;
        int32_t v42 = v18;
        v31 = v30;
        int32_t v43 = v17;
        int32_t v44 = v16;
        int32_t v45 = v15;
        v38 = v14;
        *(int16_t *)v40 = *(int16_t *)&yyvsa2;
        v5[0] = v41;
        yyvsa = v5;
        v16 = v44;
        v17 = v43;
        int32_t v46 = v40; // 0x80b34d0
        v22 = v39;
        int32_t v47 = v23; // 0x80b34d0
        int32_t v48 = v42; // 0x80b34d0
        if (v40 >= v42 + 2 * v43) {
            // 0x80b34d6
            result = 2;
            if (v44 >= 0x2710) {
                // break -> 0x80b3765
                break;
            }
            int32_t v49 = v40 - v42; // 0x80b34f3
            int32_t v50 = v49 >> 1; // 0x80b34f5
            int32_t v51 = v50 + 1; // 0x80b34f7
            uint32_t v52 = 2 * v44; // 0x80b34fa
            v16 = v52 < 0x2710 ? v52 : 0x2710;
            v22 = v39 - (6 * v16 + 33 & 0x3fff0);
            v48 = v22 + 27 & -16;
            int32_t * v53 = (int32_t *)(v22 + 8); // 0x80b3530
            *v53 = 2 * v51;
            int32_t v54 = v48 + 2 * v16; // 0x80b3534
            int32_t * v55 = (int32_t *)(v22 + 4); // 0x80b353d
            *v55 = v42;
            int32_t * v56 = (int32_t *)v22; // 0x80b3541
            *v56 = v48;
            memcpy((int32_t *)v41, &g83, (int32_t)&g83);
            v2[0] = v54;
            yyvsa = v2;
            *v56 = v54;
            v46 = v48 + (v49 & -2);
            *v53 = 4 * v51;
            *v55 = v41;
            int32_t * v57 = *(int32_t **)&yyvsa; // 0x80b356c
            memcpy(v57, &g83, (int32_t)&g83);
            v17 = v16 - 1;
            result = 1;
            if (v46 >= v48 + 2 * v17) {
                // break -> 0x80b3765
                break;
            }
            // 0x80b358b
            v47 = 4 * v50 + (int32_t)v57;
        }
        // 0x80b3594
        v18 = v48;
        v27 = v47;
        v24 = v46;
        v36 = yyvsa2[0];
        char v58 = *(char *)(v36 + (int32_t)"\xf7\xf7\xf6\xf6\xf7\b$\xf6\r\xf6\xf7\xf7\xf7\xf7\xf7\xf7\xf7\xf6\x1a)-\x12\xfe\x0e\xf6\xf7$"); // 0x80b359a
        v37 = v58;
        v29 = v45;
        v33 = v31;
        if (v58 == -10) {
            goto lab_0x80b35fc;
        } else {
            // 0x80b35a6
            v28 = v45;
            v32 = v31;
            if (v45 == -2) {
                // 0x80b37a0
                v35 = *(int32_t *)arg;
                char v59 = *(char *)v35; // 0x80b37a8
                v25 = v35;
                v34 = v59;
                v26 = v35;
                switch (v59) {
                    case 0: {
                        goto lab_0x80b37d8;
                    }
                    case 9: {
                        goto lab_0x80b37ce_2;
                    }
                    case 32: {
                        goto lab_0x80b37ce_2;
                    }
                    default: {
                        goto lab_0x80b3947;
                    }
                }
            } else {
                goto lab_0x80b35b3;
            }
        }
    }
  lab_0x80b3765_3:
    // 0x80b3765
    if (v9 != __readgsdword(20)) {
        // 0x80b3be7
        __stack_chk_fail();
        return &g83;
    }
    // 0x80b3775
    return result;
  lab_0x80b3700:
    // 0x80b3700
    result = 1;
    int32_t v60; // 0x80b3450
    if (v60 == v18) {
        // break (via goto) -> 0x80b3765
        goto lab_0x80b3765_3;
    }
    int32_t v61 = v60 - 2; // 0x80b3704
    int16_t v62 = *(int16_t *)v61; // 0x80b370a
    char v63 = *(char *)((int32_t)v62 + (int32_t)"\xf7\xf7\xf6\xf6\xf7\b$\xf6\r\xf6\xf7\xf7\xf7\xf7\xf7\xf7\xf7\xf6\x1a)-\x12\xfe\x0e\xf6\xf7$"); // 0x80b370d
    int32_t v64 = v63; // 0x80b370d
    int32_t v65 = v61; // 0x80b370d
    int32_t v66; // 0x80b3450
    int32_t v67 = v66 - 4; // 0x80b370d
    goto lab_0x80b3714;
  lab_0x80b37d8:
    // 0x80b37d8
    *(int32_t *)arg = v25;
    int32_t v70 = 0; // 0x80b37ec
    int32_t v71 = v31; // 0x80b37ec
    int32_t v72 = 0; // 0x80b37ec
    goto lab_0x80b35df;
  lab_0x80b37ce:;
    // 0x80b37ce
    int32_t v101; // 0x80b3450
    int32_t v102 = v101 + 1; // 0x80b37ce
    char v103 = *(char *)v102; // 0x80b37d1
    char v104 = v103; // 0x80b37d6
    int32_t v105 = v102; // 0x80b37d6
    v25 = v102;
    if (v103 == 0) {
        goto lab_0x80b37d8;
    }
    goto lab_0x80b37c0;
  lab_0x80b3947:;
    int32_t v88 = v26;
    unsigned char v91 = v34;
    int32_t v92 = v91;
    int32_t v90 = v88 + 1; // 0x80b395b
    g89 = v92;
    int32_t v85 = 256; // 0x80b398b
    int32_t v86 = v31; // 0x80b398b
    int32_t v87 = v90; // 0x80b398b
    switch (v91) {
        case 0: {
            goto lab_0x80b39f4;
        }
        case 10: {
            goto lab_0x80b39f4;
        }
        case 33: {
            // 0x80b39ce
            if (*(char *)v90 != 61) {
                goto lab_0x80b3992;
            } else {
                // 0x80b39d9
                v85 = 258;
                v86 = 13;
                v87 = v88 + 2;
                goto lab_0x80b3978;
            }
        }
        case 37: {
            // 0x80b39b2
            v85 = 261;
            v86 = 5;
            v87 = v90;
            goto lab_0x80b3978;
        }
        case 38: {
            goto lab_0x80b399a;
        }
        case 40: {
            goto lab_0x80b3992;
        }
        case 41: {
            goto lab_0x80b3992;
        }
        case 42: {
            // 0x80b3b68
            v85 = 261;
            v86 = 3;
            v87 = v90;
            goto lab_0x80b3978;
        }
        case 43: {
            // 0x80b3b49
            v85 = 260;
            v86 = 6;
            v87 = v90;
            goto lab_0x80b3978;
        }
        case 45: {
            // 0x80b3b2a
            v85 = 260;
            v86 = 7;
            v87 = v90;
            goto lab_0x80b3978;
        }
        case 47: {
            // 0x80b3b0b
            v85 = 261;
            v86 = 4;
            v87 = v90;
            goto lab_0x80b3978;
        }
        case 48: {
            goto lab_0x80b3a8a;
        }
        case 49: {
            goto lab_0x80b3a8a;
        }
        case 50: {
            goto lab_0x80b3a8a;
        }
        case 51: {
            goto lab_0x80b3a8a;
        }
        case 52: {
            goto lab_0x80b3a8a;
        }
        case 53: {
            goto lab_0x80b3a8a;
        }
        case 54: {
            goto lab_0x80b3a8a;
        }
        case 55: {
            goto lab_0x80b3a8a;
        }
        case 56: {
            goto lab_0x80b3a8a;
        }
        case 57: {
            goto lab_0x80b3a8a;
        }
        case 58: {
            goto lab_0x80b3992;
        }
        case 59: {
            goto lab_0x80b39f4;
        }
        case 60: {
            char v107 = *(char *)v90; // 0x80b3a62
            v85 = 259;
            v86 = v107 == 61 ? 10 : 8;
            v87 = v107 == 61 ? v88 + 2 : v90;
            goto lab_0x80b3978;
        }
        case 61: {
            char v108 = *(char *)v90; // 0x80b3a37
            v85 = v108 != 61 ? 256 : 258;
            v86 = v108 != 61 ? v31 : 12;
            v87 = v108 != 61 ? v90 : v88 + 2;
            goto lab_0x80b3978;
        }
        case 62: {
            char v109 = *(char *)v90; // 0x80b3a09
            v85 = 259;
            v86 = v109 == 61 ? 11 : 9;
            v87 = v109 == 61 ? v88 + 2 : v90;
            goto lab_0x80b3978;
        }
        case 63: {
            goto lab_0x80b3992;
        }
        case 110: {
            goto lab_0x80b3992;
        }
        case 124: {
            goto lab_0x80b399a;
        }
        default: {
            goto lab_0x80b3978;
        }
    }
  lab_0x80b35fc:;
    int32_t v110 = v33;
    int32_t v111 = v29;
    g88 = v36;
    unsigned char v112 = *(char *)(v36 + (int32_t)"\x00\x00\f\v\x00\x00\x02\n\x00\x01\x00\x00\x00\x00\x00\x00\x00\r\x00\x04\x05\x06\a\b\t\x00\x03"); // 0x80b3602
    int32_t v113 = v112; // 0x80b3602
    v1[0] = v113;
    yyvsa2 = v1;
    int32_t v79 = v111; // 0x80b3614
    int32_t v80 = v110; // 0x80b3614
    int32_t v84; // 0x80b3450
    int32_t v83; // 0x80b3450
    int32_t v114; // 0x80b366d
    int32_t v115; // 0x80b366f
    int32_t v116; // 0x80b367e
    if (v112 == 0) {
        goto lab_0x80b36f0;
    } else {
        unsigned char v117 = *(char *)(v113 + (int32_t)"\x00\x02\x01\x05\x03\x03\x03\x03\x03\x03\x02\x01\x01\x03"); // 0x80b361a
        int32_t v118 = v117; // 0x80b361a
        int32_t v119 = 4 * v118; // 0x80b362c
        int32_t v120 = *(int32_t *)(v27 + 4 - v119); // 0x80b3635
        int32_t v121 = v120; // 0x80b363a
        switch (v36) {
            case 2: {
                int32_t * v122 = new_exp(v118, (int32_t)&g83, (int32_t **)&g83); // 0x80b38f5
                int32_t v123 = (int32_t)v122; // 0x80b38f5
                v121 = v123;
                if (v122 != NULL) {
                    int32_t v124 = *(int32_t *)v27; // 0x80b3902
                    *(int32_t *)(v123 + 8) = v124;
                    v121 = v123;
                }
                // break -> 0x80b3658
                break;
            }
            case 3: {
                // 0x80b390c
                v121 = (int32_t)new_exp(v118, (int32_t)&g83, (int32_t **)&g83);
                // break -> 0x80b3658
                break;
            }
            case 6: {
                int32_t v125 = *(int32_t *)v27; // 0x80b3641
                if (v125 == 0) {
                    // break -> 0x80b3765
                    break;
                }
                // 0x80b364b
                *(int32_t *)((int32_t)arg + 4) = v125;
                v121 = v120;
                // break -> 0x80b3658
                break;
            }
            case 7: {
                // 0x80b391c
                v121 = (int32_t)new_exp(v118, (int32_t)&g83, (int32_t **)&g83);
                // break -> 0x80b3658
                break;
            }
        }
        // 0x80b3658
        v114 = v24 - 2 * v118;
        v115 = v27 - v119 + 4;
        *(int32_t *)v115 = v121;
        int32_t v126 = yyvsa2[0]; // 0x80b3672
        unsigned char v127 = *(char *)(v126 + (int32_t)"\x00\x10\x11\x12\x12\x12\x12\x12\x12\x12\x12\x12\x12\x12"); // 0x80b367e
        v116 = v127;
        int32_t v128 = (int32_t)*(int16_t *)v114; // 0x80b3685
        v3[0] = v128;
        yyvsa2 = v3;
        uint32_t v129 = (int32_t)*(char *)(v116 + (int32_t)"\xf6\xf6\xff" - 16) + v128; // 0x80b3699
        if (v129 < 55) {
            char v130 = *(char *)(v129 + (int32_t)"\x01\n\v\x04\r\x0e\b\t\x00\n\v\f\r\x0e\x0f\x10\x03\x04\x05\x06\a\b\t\t\x19\a\b\t\x0f\x03\x04\x05\x06\a\b\t\xff\xff\f\x03\x04\x05\x06\a\b\t\x05\x06\a\b\t\x06\a\b\t"); // 0x80b36a1
            if (*(int16_t *)&yyvsa2 == (int16_t)v130) {
                unsigned char v131 = *(char *)(v129 + (int32_t)"\a\x01\x02\b\x03\x04\x0f\x10\t\x12\x13\x14\x15\x16\x17\x18\n\v\f\r\x0e\x0f\x10\x10\x1a\x0e\x0f\x10\x11\n\v\f\r\x0e\x0f\x10\x00\x00\x19\n\v\f\r\x0e\x0f\x10\f\r\x0e\x0f\x10\r\x0e\x0f\x10"); // 0x80b3866
                v6[0] = v131;
                yyvsa2 = v6;
                v14 = v38;
                v15 = v111;
                v83 = v110;
                v84 = v114;
                v23 = v115;
                goto lab_0x80b36c3;
            } else {
                goto lab_0x80b36b6;
            }
        } else {
            goto lab_0x80b36b6;
        }
    }
  lab_0x80b36f0:;
    int32_t v132 = v80;
    int32_t v133 = v79;
    int32_t v134 = v133; // 0x80b36f7
    if (v38 == 3) {
        // 0x80b37f1
        v134 = -2;
        result = 1;
        if (v133 == 0) {
            // break -> 0x80b3765
            goto lab_0x80b3765_3;
        }
    }
    int32_t v135 = v134;
    v64 = v37;
    v65 = v24;
    v67 = v27;
    unsigned char v69; // 0x80b372a
    while (true) {
      lab_0x80b3714:
        // 0x80b3714
        v66 = v67;
        v60 = v65;
        int32_t v68 = v64;
        if (v68 != -10 == v68 < 54) {
            // 0x80b3721
            if (*(char *)(v68 + 0x810c561) != 1) {
                goto lab_0x80b3700;
            } else {
                // 0x80b372a
                v69 = *(char *)(v68 + 0x810c5a1);
                result = 0;
                switch (v69) {
                    case 0: {
                        goto lab_0x80b3700;
                    }
                    case 9: {
                        goto lab_0x80b3765_3;
                    }
                    default: {
                        goto lab_0x80b373e;
                    }
                }
            }
        } else {
            goto lab_0x80b3700;
        }
    }
  lab_0x80b373e:;
    int32_t v136 = v66 + 4; // 0x80b3744
    *(int32_t *)v136 = v132;
    v7[0] = v69;
    yyvsa2 = v7;
    v14 = 3;
    v15 = v135;
    v83 = v132;
    v84 = v60;
    v23 = v136;
    goto lab_0x80b36c3;
  lab_0x80b35b3:;
    int32_t v138 = v32;
    int32_t v139 = v28;
    v70 = 0;
    v71 = v138;
    v72 = 0;
    if (v139 >= 1) {
        // 0x80b35c1
        v70 = v139;
        v71 = v138;
        v72 = 2;
        if (v139 < 263) {
            unsigned char v140 = *(char *)(v139 + (int32_t)"\x00\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\n\x02\x02\x02\x02\x05\x02\x0e\x0f\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\f\x02\x02\x02\x02\x03\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\r\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x04\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x01\x02\x06\a\b\t\v"); // 0x80b35d8
            v70 = v139;
            v71 = v138;
            v72 = v140;
        }
    }
    goto lab_0x80b35df;
  lab_0x80b36c3:
    // 0x80b36c3
    v19 = yyvsa[0];
    v30 = v83;
    v20 = v84 + 2;
    goto lab_0x80b34b3;
  lab_0x80b36b6:
    // 0x80b36b6
    v4[0] = (int32_t)*(char *)(v116 + (int32_t)"\xff\x05\x06" - 16);
    yyvsa2 = v4;
    v14 = v38;
    v15 = v111;
    v83 = v110;
    v84 = v114;
    v23 = v115;
    goto lab_0x80b36c3;
  lab_0x80b37ce_2:;
    int32_t v137 = v35 + 1; // 0x80b37ce
    v25 = v137;
    if (*(char *)v137 != 0) {
        while (true) {
          lab_0x80b37c0:
            // 0x80b37c0
            v101 = v105;
            char v106 = v104;
            v34 = v106;
            v26 = v101;
            switch (v106) {
                case 32: {
                    goto lab_0x80b37ce;
                }
                case 9: {
                    goto lab_0x80b37ce;
                }
                default: {
                    goto lab_0x80b3947;
                }
            }
        }
        goto lab_0x80b3947;
    } else {
        goto lab_0x80b37d8;
    }
  lab_0x80b35df:;
    int32_t v73 = v72;
    int32_t v74 = v71;
    int32_t v75 = v70;
    uint32_t v76 = v73 + v37; // 0x80b35df
    v29 = v75;
    v33 = v74;
    if (v76 < 55) {
        char v77 = *(char *)(v76 + (int32_t)"\x01\n\v\x04\r\x0e\b\t\x00\n\v\f\r\x0e\x0f\x10\x03\x04\x05\x06\a\b\t\t\x19\a\b\t\x0f\x03\x04\x05\x06\a\b\t\xff\xff\f\x03\x04\x05\x06\a\b\t\x05\x06\a\b\t\x06\a\b\t"); // 0x80b35ed
        v29 = v75;
        v33 = v74;
        if (v73 == (int32_t)v77) {
            unsigned char v78 = *(char *)(v76 + (int32_t)"\a\x01\x02\b\x03\x04\x0f\x10\t\x12\x13\x14\x15\x16\x17\x18\n\v\f\r\x0e\x0f\x10\x10\x1a\x0e\x0f\x10\x11\n\v\f\r\x0e\x0f\x10\x00\x00\x19\n\v\f\r\x0e\x0f\x10\f\r\x0e\x0f\x10\r\x0e\x0f\x10"); // 0x80b36de
            v79 = v75;
            v80 = v74;
            if (v78 != 0) {
                // 0x80b381f
                result = 0;
                if (v78 == 9) {
                    // break -> 0x80b3765
                    goto lab_0x80b3765_3;
                }
                int32_t v81 = v75 == 0 ? 0 : -2; // 0x80b3835
                int32_t v82 = v27 + 4; // 0x80b383c
                *(int32_t *)v82 = v74;
                v8[0] = v78;
                yyvsa2 = v8;
                v14 = v38 - 1 + (int32_t)(v38 == 0);
                v15 = v81;
                v83 = v74;
                v84 = v24;
                v23 = v82;
                goto lab_0x80b36c3;
            } else {
                goto lab_0x80b36f0;
            }
        } else {
            goto lab_0x80b35fc;
        }
    } else {
        goto lab_0x80b35fc;
    }
  lab_0x80b39f4:
    // 0x80b39f4
    v85 = 0;
    v86 = v31;
    v87 = v88;
    goto lab_0x80b3978;
  lab_0x80b399a:;
    char v89 = *(char *)v90; // 0x80b39a0
    v85 = v89 != v91 ? 256 : v92;
    v86 = v31;
    v87 = v89 != v91 ? v90 : v88 + 2;
    goto lab_0x80b3978;
  lab_0x80b3992:
    // 0x80b3992
    v85 = v92;
    v86 = v31;
    v87 = v90;
    goto lab_0x80b3978;
  lab_0x80b3a8a:;
    char v93 = *(char *)v90; // 0x80b3a96
    int32_t v94 = v92 - 48; // 0x80b3a99
    v85 = 262;
    v86 = v94;
    v87 = v90;
    char v95 = v93; // 0x80b3aa8
    int32_t v96 = v94; // 0x80b3aa8
    int32_t v97 = v90; // 0x80b3aa8
    if (v93 < 58) {
        int32_t v98 = v97 + 1; // 0x80b3acb
        int32_t v99 = (int32_t)v95 - 48 + 10 * v96; // 0x80b3ace
        char v100 = *(char *)v98; // 0x80b3ad2
        v85 = 262;
        v86 = v99;
        v87 = v98;
        v96 = v99;
        v97 = v98;
        while (v100 < 58) {
            // 0x80b3ac5
            v98 = v97 + 1;
            v99 = (int32_t)v100 - 48 + 10 * v96;
            v100 = *(char *)v98;
            v85 = 262;
            v86 = v99;
            v87 = v98;
            v96 = v99;
            v97 = v98;
        }
    }
    goto lab_0x80b3978;
  lab_0x80b3978:
    // 0x80b3978
    *(int32_t *)arg = v87;
    v28 = v85;
    v32 = v86;
    goto lab_0x80b35b3;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/main/event.c
// Address range: 0x80b3ce0 - 0x80b3d70
// Line range:    317 - 330
void done_event(void) {
    int32_t v1 = 0; // 0x80b3cf0
    if (eventssize != 0) {
        int32_t v2 = 16 * v1; // 0x80b3cfd
        int32_t v3 = v2 + (int32_t)events; // 0x80b3d00
        int32_t v4 = *(int32_t *)(v3 + 4); // 0x80b3d02
        int32_t v5 = v3; // 0x80b3d07
        if (v4 != 0) {
            // 0x80b3d09
            mem_free((char *)v4);
            v5 = v2 + (int32_t)events;
        }
        // 0x80b3d18
        v1++;
        mem_free((char *)*(int32_t *)v5);
        while (eventssize > v1) {
            // 0x80b3cf8
            v2 = 16 * v1;
            v3 = v2 + (int32_t)events;
            v4 = *(int32_t *)(v3 + 4);
            v5 = v3;
            if (v4 != 0) {
                // 0x80b3d09
                mem_free((char *)v4);
                v5 = v2 + (int32_t)events;
            }
            // 0x80b3d18
            v1++;
            mem_free((char *)*(int32_t *)v5);
        }
    }
    // 0x80b3d2f
    if (events != NULL) {
        // 0x80b3d38
        mem_free((char *)events);
    }
    // 0x80b3d40
    *(int32_t *)&events = 0;
    if (event_hash == NULL) {
        // 0x80b3d5f
        eventssize = 0;
        return;
    }
    // 0x80b3d53
    free_hash(&event_hash);
    // 0x80b3d5f
    eventssize = 0;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/main/event.c
// Address range: 0x80b3d90 - 0x80b3ef3
// Line range:    246 - 260
void unregister_event_hook(uint32_t id, int32_t (*callback)(char *, char *)) {
    // 0x80b3d90
    if (assert_failed != 0) {
        // 0x80b3eb0
        assert_failed = 0;
        return;
    }
    // 0x80b3dad
    assert_failed = callback == NULL;
    if (callback == NULL) {
        // 0x80b3e80
        errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/main/event.c";
        errline = 250;
        elinks_internal("assertion callback failed!");
        if (assert_failed != 0) {
            // 0x80b3eb0
            assert_failed = 0;
            return;
        }
    }
    if (id < 0 || eventssize <= id) {
        // 0x80b3e78
        return;
    }
    int32_t v1 = 16 * id + (int32_t)events; // 0x80b3dd8
    int32_t * v2 = (int32_t *)(v1 + 4); // 0x80b3dde
    int32_t v3 = *v2; // 0x80b3dde
    if (v3 == 0) {
        // 0x80b3e78
        return;
    }
    int32_t * v4 = (int32_t *)(v1 + 8); // 0x80b3dec
    uint32_t v5 = *v4; // 0x80b3dec
    if (v5 == 0) {
        // 0x80b3e78
        return;
    }
    int32_t v6 = (int32_t)callback;
    int32_t * v7 = (int32_t *)v3;
    int32_t v8 = v3; // 0x80b3dfc
    int32_t * v9 = v7; // 0x80b3dfc
    int32_t v10 = 1; // 0x80b3dfc
    int32_t v11 = 12; // 0x80b3dfc
    if (*v7 == v6) {
        goto lab_0x80b3e33;
      lab_0x80b3e33:
        // 0x80b3e33
        memmove(v9, (int32_t *)(v11 + v3), 12 * (v5 - v10));
        int32_t v12 = *v4 - 1; // 0x80b3e51
        *v4 = v12;
        if (v12 == 0) {
            // 0x80b3ec8
            mem_free((char *)*v2);
            *v2 = 0;
            return;
        }
        char * v13 = mem_realloc((char *)*v2, 12 * v12); // 0x80b3e6b
        if (v13 != NULL) {
            // 0x80b3e74
            *v2 = (int32_t)v13;
        }
        // 0x80b3e78
        return;
    }
    int32_t v14 = 0;
    int32_t v15 = v14 + 1; // 0x80b3e10
    while (v15 < v5) {
        // 0x80b3e17
        v8 += 12;
        v9 = (int32_t *)v8;
        if (*v9 == v6) {
            int32_t v16 = v14 + 2; // 0x80b3e22
            v10 = (v16 & v14 - 0x7fffffff) >= 0 ? v16 : v15;
            v11 = 12 * v16;
            goto lab_0x80b3e33;
        }
        v14 = v15;
        v15 = v14 + 1;
    }
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/main/event.c
// Address range: 0x80b3f00 - 0x80b3f65
// Line range:    153 - 171
void trigger_event_va(int32_t id, char * ap_init) {
    // 0x80b3f00
    return;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/main/event.c
// Address range: 0x80b3f70 - 0x80b3f83
// Line range:    174 - 181
void trigger_event(int32_t id, ...) {
    // 0x80b3f70
    int32_t v1; // 0x80b3f70
    trigger_event_va(v1, (char *)&g83);
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/main/event.c
// Address range: 0x80b3f90 - 0x80b40a6
// Line range:    120 - 138
int32_t get_event_id(char * name) {
    // 0x80b3f90
    if (assert_failed != 0) {
        // 0x80b4030
        assert_failed = 0;
        // 0x80b3ff7
        return -1;
    }
    if (name == NULL) {
        goto lab_0x80b3fb9;
    } else {
        // 0x80b3fb0
        if (*name != 0) {
            // 0x80b4050
            assert_failed = 0;
            goto lab_0x80b3fed;
        } else {
            goto lab_0x80b3fb9;
        }
    }
  lab_0x80b3fb9:
    // 0x80b3fb9
    assert_failed = 1;
    errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/main/event.c";
    errline = 125;
    elinks_internal("assertion name && name[0] failed: Empty or missing event name");
    if (assert_failed != 0) {
        // 0x80b4030
        assert_failed = 0;
        // 0x80b3ff7
        return -1;
    }
    goto lab_0x80b3fed;
  lab_0x80b3fed:
    // 0x80b3fed
    if (event_hash == NULL) {
        // 0x80b3ff7
        return -1;
    }
    int32_t * v1 = get_hash_item(event_hash, name, strlen(name)); // 0x80b4073
    if (v1 == NULL) {
        // 0x80b3ff7
        return -1;
    }
    // 0x80b4080
    if (assert_failed != 0) {
        // 0x80b4030
        assert_failed = 0;
        // 0x80b3ff7
        return -1;
    }
    int32_t v2 = *(int32_t *)((int32_t)v1 + 16); // 0x80b4086
    assert_failed = v2 == 0;
    if (v2 != 0) {
        // 0x80b3ff7
        return *(int32_t *)(v2 + 12);
    }
    // 0x80b4006
    errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/main/event.c";
    errline = 135;
    elinks_internal("assertion event != NULL failed: Hash item with no value");
    if (assert_failed == 0) {
        // 0x80b3ff7
        return *(int32_t *)(v2 + 12);
    }
    // 0x80b4030
    assert_failed = 0;
    // 0x80b3ff7
    return -1;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/main/event.c
// Address range: 0x80b40b0 - 0x80b40f6
// Line range:    297 - 308
void unregister_event_hooks(int32_t * hooks) {
    int32_t v1 = *hooks; // 0x80b40bb
    if (v1 == 0) {
        // 0x80b40ef
        return;
    }
    int32_t v2 = (int32_t)hooks;
    int32_t v3 = get_event_id((char *)v1); // 0x80b40cb
    if (v3 != -1) {
        // 0x80b40d5
        unregister_event_hook(v3, (int32_t (*)(char *, char *))*(int32_t *)(v2 + 8));
    }
    int32_t v4 = v2 + 16;
    int32_t v5 = *(int32_t *)v4; // 0x80b40e4
    while (v5 != 0) {
        // 0x80b40c8
        v2 = v4;
        v3 = get_event_id((char *)v5);
        if (v3 != -1) {
            // 0x80b40d5
            unregister_event_hook(v3, (int32_t (*)(char *, char *))*(int32_t *)(v2 + 8));
        }
        // 0x80b40e4
        v4 = v2 + 16;
        v5 = *(int32_t *)v4;
    }
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/main/event.c
// Address range: 0x80b4100 - 0x80b411b
// Line range:    184 - 192
void trigger_event_name(char * name, ...) {
    // 0x80b4100
    get_event_id(name);
    trigger_event_va((int32_t)&g83, (char *)&g83);
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/main/interlink.c
// Address range: 0x80b47d0 - 0x80b483b
// Line range:    223 - 229
void unlink_unix(struct sockaddr * addr) {
    // 0x80b47d0
    if (assert_failed != 0) {
        // 0x80b482f
        assert_failed = 0;
        return;
    }
    // 0x80b47e0
    int32_t v1; // 0x80b47d0
    assert_failed = v1 == 0;
    if (v1 != 0) {
        // 0x80b47f1
        unlink((char *)(v1 + 2));
        return;
    }
    // 0x80b4800
    errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/main/interlink.c";
    errline = 225;
    elinks_internal("assertion addr failed!");
    if (assert_failed == 0) {
        // 0x80b47f1
        unlink((char *)(v1 + 2));
        return;
    }
    // 0x80b482f
    assert_failed = 0;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/main/interlink.c
// Address range: 0x80b4840 - 0x80b4909
// Line range:    481 - 505
void done_interlink(void) {
    // 0x80b4840
    if (s_info_listen != 0) {
        // 0x80b484f
        if (g67 != (char *)-1) {
            // 0x80b485a
            close((int32_t)g67);
            g67 = (char *)-1;
        }
        // 0x80b4871
        unlink_unix((struct sockaddr *)&g83);
        mem_free((char *)s_info_listen);
        s_info_listen = 0;
    }
    // 0x80b488d
    if (s_info_connect != 0) {
        int32_t v1 = s_info_connect; // 0x80b489f
        if (g68 != -1) {
            // 0x80b48a1
            close(g68);
            v1 = s_info_connect;
            g68 = -1;
        }
        // 0x80b48b8
        mem_free((char *)v1);
        s_info_connect = 0;
    }
    // 0x80b48ca
    if (s_info_accept == 0) {
        // 0x80b4907
        return;
    }
    int32_t v2 = s_info_accept; // 0x80b48dc
    if (g66 != (char *)-1) {
        // 0x80b48de
        close((int32_t)g66);
        v2 = s_info_accept;
        g66 = (char *)-1;
    }
    // 0x80b48f5
    mem_free((char *)v2);
    s_info_accept = 0;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/main/main.c
// Address range: 0x80b53a0 - 0x80b53c7
// Line range:    307 - 311
void shrink_memory(int32_t whole) {
    // 0x80b53a0
    shrink_dns_cache(whole);
    shrink_format_cache(whole);
    garbage_collection(whole);
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/main/main.c
// Address range: 0x80b53d0 - 0x80b54e3
// Line range:    339 - 360
int main(int argc, char ** argv) {
    // 0x80b53d0
    program = 0;
    g81 = 0;
    *(int32_t *)&av = (int32_t)argv;
    *(int32_t *)&g82 = (int32_t)*argv;
    ac = argc;
    select_loop((void (*)())0x80b4e40);
    done_interlink();
    check_bottom_halves();
    abort_all_downloads();
    check_bottom_halves();
    destroy_all_terminals();
    check_bottom_halves();
    free_all_itrms();
    abort_all_connections();
    check_bottom_halves();
    abort_all_connections();
    if (init_b != 0) {
        // 0x80b5453
        trigger_event_name("quit");
        free_history_lists();
        done_modules((int32_t *)&builtin_modules);
        done_saved_session_info();
    }
    // 0x80b5475
    shrink_memory(1);
    free_charsets_lookup();
    free_colors_lookup();
    done_modules((int32_t *)&main_modules);
    free_conv_table();
    check_bottom_halves();
    done_home();
    done_state_message();
    done_bfu_colors();
    unregister_modules_options((int32_t *)&builtin_modules);
    unregister_modules_options((int32_t *)&main_modules);
    done_options();
    done_event();
    terminate_osdep();
    return g81;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/main/module.c
// Address range: 0x80b54f0 - 0x80b5580
// Line range:    125 - 136
void done_module(int32_t * module) {
    int32_t v1 = (int32_t)module;
    int32_t * v2 = (int32_t *)(v1 + 12); // 0x80b54fc
    int32_t v3 = *v2; // 0x80b54fc
    if (v3 != 0) {
        // 0x80b5503
        if (*(int32_t *)v3 != 0) {
            int32_t v4 = 0;
            int32_t v5 = v4 + 1; // 0x80b5512
            while (*(int32_t *)(4 * v5 + v3) != 0) {
                // 0x80b5512
                v4 = v5;
                v5 = v4 + 1;
            }
            if (v4 != -1) {
                int32_t v6 = *(int32_t *)(4 * v4 + v3); // 0x80b5521
                if (v6 != 0) {
                    // 0x80b5528
                    done_module((int32_t *)v6);
                    if (v4 != 0) {
                        int32_t v7 = v4 - 1; // 0x80b5528
                        int32_t v8 = 4 * v7; // 0x80b54f0
                        int32_t v9 = v7; // 0x80b54f0
                        int32_t v10 = *(int32_t *)(*v2 + v8); // 0x80b553b
                        while (v10 != 0) {
                            int32_t v11 = v9;
                            done_module((int32_t *)v10);
                            v8 -= 4;
                            v9 = v11 - 1;
                            if (v11 == 0) {
                                // break -> 0x80b5555
                                break;
                            }
                            v10 = *(int32_t *)(*v2 + v8);
                        }
                    }
                }
            }
        }
    }
    int32_t v12 = *(int32_t *)(v1 + 8); // 0x80b5555
    if (v12 != 0) {
        // 0x80b555c
        unregister_event_hooks((int32_t *)v12);
    }
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/main/module.c
// Address range: 0x80b5580 - 0x80b55e0
// Line range:    178 - 186
void done_modules(int32_t * modules) {
    if (modules == NULL) {
        // 0x80b55d9
        return;
    }
    int32_t v1 = (int32_t)modules;
    if (*modules == 0) {
        // 0x80b55d9
        return;
    }
    int32_t v2 = 0;
    int32_t v3 = v2 + 1; // 0x80b55a2
    while (*(int32_t *)(4 * v3 + v1) != 0) {
        // 0x80b55a2
        v2 = v3;
        v3 = v2 + 1;
    }
    if (v2 == -1) {
        // 0x80b55d9
        return;
    }
    int32_t v4 = *(int32_t *)(4 * v2 + v1); // 0x80b55b1
    if (v4 == 0) {
        // 0x80b55d9
        return;
    }
    // 0x80b55b8
    done_module((int32_t *)v4);
    if (v2 == 0) {
        // 0x80b55d9
        return;
    }
    int32_t v5 = v2 - 1; // 0x80b55b8
    int32_t v6 = 4 * v5 + v1; // 0x80b5580
    int32_t v7 = v5;
    int32_t v8 = *(int32_t *)v6; // 0x80b55c0
    while (v8 != 0) {
        // 0x80b55c9
        done_module((int32_t *)v8);
        v6 -= 4;
        if (v7 == 0) {
            // break -> 0x80b55d9
            break;
        }
        v7--;
        v8 = *(int32_t *)v6;
    }
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/main/module.c
// Address range: 0x80b5670 - 0x80b56f6
// Line range:    98 - 108
void unregister_module_options(int32_t * module) {
    int32_t v1 = (int32_t)module;
    int32_t * v2 = (int32_t *)(v1 + 12); // 0x80b567c
    int32_t v3 = *v2; // 0x80b567c
    if (v3 != 0) {
        // 0x80b5683
        if (*(int32_t *)v3 != 0) {
            int32_t v4 = 0;
            int32_t v5 = v4 + 1; // 0x80b5692
            while (*(int32_t *)(4 * v5 + v3) != 0) {
                // 0x80b5692
                v4 = v5;
                v5 = v4 + 1;
            }
            if (v4 != -1) {
                int32_t v6 = *(int32_t *)(4 * v4 + v3); // 0x80b56a1
                if (v6 != 0) {
                    // 0x80b56a8
                    unregister_module_options((int32_t *)v6);
                    if (v4 != 0) {
                        int32_t v7 = v4 - 1; // 0x80b56a8
                        int32_t v8 = 4 * v7; // 0x80b5670
                        int32_t v9 = v7; // 0x80b5670
                        int32_t v10 = *(int32_t *)(*v2 + v8); // 0x80b56bb
                        while (v10 != 0) {
                            int32_t v11 = v9;
                            unregister_module_options((int32_t *)v10);
                            v8 -= 4;
                            v9 = v11 - 1;
                            if (v11 == 0) {
                                // break -> 0x80b56d5
                                break;
                            }
                            v10 = *(int32_t *)(*v2 + v8);
                        }
                    }
                }
            }
        }
    }
    int32_t v12 = *(int32_t *)(v1 + 4); // 0x80b56d5
    if (v12 != 0) {
        // 0x80b56dc
        unregister_options((int32_t *)v12, config_options);
    }
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/main/module.c
// Address range: 0x80b5700 - 0x80b5760
// Line range:    152 - 160
void unregister_modules_options(int32_t * modules) {
    if (modules == NULL) {
        // 0x80b5759
        return;
    }
    int32_t v1 = (int32_t)modules;
    if (*modules == 0) {
        // 0x80b5759
        return;
    }
    int32_t v2 = 0;
    int32_t v3 = v2 + 1; // 0x80b5722
    while (*(int32_t *)(4 * v3 + v1) != 0) {
        // 0x80b5722
        v2 = v3;
        v3 = v2 + 1;
    }
    if (v2 == -1) {
        // 0x80b5759
        return;
    }
    int32_t v4 = *(int32_t *)(4 * v2 + v1); // 0x80b5731
    if (v4 == 0) {
        // 0x80b5759
        return;
    }
    // 0x80b5738
    unregister_module_options((int32_t *)v4);
    if (v2 == 0) {
        // 0x80b5759
        return;
    }
    int32_t v5 = v2 - 1; // 0x80b5738
    int32_t v6 = 4 * v5 + v1; // 0x80b5700
    int32_t v7 = v5;
    int32_t v8 = *(int32_t *)v6; // 0x80b5740
    while (v8 != 0) {
        // 0x80b5749
        unregister_module_options((int32_t *)v8);
        v6 -= 4;
        if (v7 == 0) {
            // break -> 0x80b5759
            break;
        }
        v7--;
        v8 = *(int32_t *)v6;
    }
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/main/select.c
// Address range: 0x80b5840 - 0x80b58d6
// Line range:    335 - 351
int32_t can_read_or_write(int32_t fd, int32_t write2) {
    // 0x80b5840
    int32_t v1; // 0x80b5840
    int32_t v2 = v1;
    int32_t timeout = 0; // bp-36, 0x80b5863
    int32_t v3; // bp-164, 0x80b5840
    __asm_rep_stosd_memset((char *)&v3, 0, 32);
    int32_t v4 = v2 >= 0 ? v2 : v2 + 31; // 0x80b587b
    int32_t readfds = v1 == 0 ? (int32_t)&v3 : 0; // 0x80b5888
    int32_t v5; // bp-4, 0x80b5840
    int32_t * v6 = (int32_t *)(4 * (v4 >> 5) - 160 + (int32_t)&v5); // 0x80b58a7
    *v6 = *v6 | 1 << v2 % 32;
    struct _TYPEDEF_fd_set * writefds = v1 != 0 ? (struct _TYPEDEF_fd_set *)&v3 : NULL; // 0x80b58c4
    return select(v2 + 1, (struct _TYPEDEF_fd_set *)readfds, writefds, NULL, (struct timeval *)&timeout);
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/main/select.c
// Address range: 0x80b5900 - 0x80b5911
// Line range:    354 - 356
int32_t can_read(int32_t fd) {
    // 0x80b5900
    return can_read_or_write((int32_t)&g83, (int32_t)&g83);
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/main/select.c
// Address range: 0x80b5920 - 0x80b5b25
// Line range:    143 - 190
void set_handlers(uint32_t fd, void (*read_func)(char *), void (*write_func)(char *), void (*error_func)(char *), char * data) {
    // 0x80b5920
    if (assert_failed != 0) {
        // 0x80b5a38
        assert_failed = 0;
        return;
    }
    // 0x80b5940
    assert_failed = fd >= 1024;
    if (fd >= 1024) {
        // 0x80b59f8
        errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/main/select.c";
        errline = 149;
        elinks_internal("assertion fd >= 0 && fd < FD_SETSIZE failed: set_handlers: handle %d >= FD_SETSIZE %d", fd, 1024);
        if (assert_failed != 0) {
            // 0x80b5a38
            assert_failed = 0;
            return;
        }
    }
    int32_t v1 = 16 * fd; // 0x80b595a
    *(int32_t *)(v1 + (int32_t)&threads) = (int32_t)read_func;
    *(int32_t *)(v1 + (int32_t)&g69) = (int32_t)write_func;
    *(int32_t *)(v1 + (int32_t)&g70) = (int32_t)error_func;
    *(int32_t *)(v1 + (int32_t)&g71) = (int32_t)data;
    int32_t v2 = fd >= 0 ? fd : fd + 31;
    int32_t v3; // 0x80b5920
    int32_t v4; // 0x80b5920
    int32_t v5; // 0x80b5920
    int32_t v6; // 0x80b5920
    int32_t v7; // 0x80b5920
    if (read_func == NULL) {
        int32_t v8 = 1 << fd % 32;
        int32_t v9 = -1 - v8;
        int32_t v10 = 4 * (v2 >> 5);
        int32_t * v11 = (int32_t *)(v10 + (int32_t)&w_read); // 0x80b5ad6
        *v11 = *v11 & v9;
        int32_t * v12 = (int32_t *)(v10 + (int32_t)&x_read); // 0x80b5add
        *v12 = *v12 & v9;
        v5 = v10;
        v6 = v8;
        v3 = v9;
        v4 = v10;
        v7 = v8;
        if (write_func != NULL) {
            goto lab_0x80b59b4;
        } else {
            goto lab_0x80b5af0;
        }
    } else {
        int32_t v13 = 1 << fd % 32;
        int32_t v14 = 4 * (v2 >> 5);
        int32_t * v15 = (int32_t *)(v14 + (int32_t)&w_read); // 0x80b59a5
        *v15 = *v15 | v13;
        v5 = v14;
        v6 = v13;
        if (write_func == NULL) {
            // 0x80b5983
            v3 = -1 - v13;
            v4 = v14;
            v7 = v13;
            goto lab_0x80b5af0;
        } else {
            goto lab_0x80b59b4;
        }
    }
  lab_0x80b59b4:;
    int32_t * v16 = (int32_t *)(v5 + (int32_t)&w_write); // 0x80b59b7
    *v16 = *v16 | v6;
    int32_t v17 = v5; // 0x80b59c0
    int32_t v18 = v6; // 0x80b59c0
    int32_t v19; // 0x80b5920
    int32_t v20; // 0x80b5920
    if (error_func == NULL) {
        // 0x80b59b4
        v20 = -1 - v6;
        v19 = v5;
        goto lab_0x80b5b10;
    } else {
        goto lab_0x80b59c6;
    }
  lab_0x80b5af0:;
    int32_t * v21 = (int32_t *)(v4 + (int32_t)&w_write); // 0x80b5af4
    *v21 = *v21 & v3;
    int32_t * v22 = (int32_t *)(v4 + (int32_t)&x_write); // 0x80b5afb
    *v22 = *v22 & v3;
    v17 = v4;
    v18 = v7;
    v20 = v3;
    v19 = v4;
    if (error_func != NULL) {
        goto lab_0x80b59c6;
    } else {
        goto lab_0x80b5b10;
    }
  lab_0x80b59c6:;
    int32_t * v23 = (int32_t *)(v17 + (int32_t)&w_error); // 0x80b59c6
    *v23 = *v23 | v18;
    goto lab_0x80b59cd;
  lab_0x80b5b10:;
    int32_t * v30 = (int32_t *)(v19 + (int32_t)&w_error); // 0x80b5b12
    *v30 = *v30 & v20;
    int32_t * v31 = (int32_t *)(v19 + (int32_t)&x_error); // 0x80b5b19
    *v31 = *v31 & v20;
    goto lab_0x80b59cd;
  lab_0x80b59cd:
    // 0x80b59cd
    if (write_func == NULL != (read_func == NULL == error_func == NULL)) {
        uint32_t v24; // 0x80b5920
        if (v24 <= fd) {
            // 0x80b59e4
            w_max = fd + 1;
        }
        // 0x80b59ed
        return;
    }
    if (w_max != fd + 1) {
        // 0x80b59ed
        return;
    }
    int32_t v25 = w_max - 2; // 0x80b5a5c
    if (v25 < 0) {
        // 0x80b5a9e
        w_max = v25 + 1;
        // 0x80b59ed
        return;
    }
    int32_t v26 = v25;
    int32_t v27 = 4 * (v26 >> 5); // 0x80b5a92
    int32_t v28 = 1 << v26 % 32; // 0x80b5a99
    int32_t v29 = v26; // 0x80b5a9c
    while ((v28 & *(int32_t *)(v27 + (int32_t)&w_read)) == 0) {
        // 0x80b5a68
        v29 = v26;
        if ((*(int32_t *)(v27 + (int32_t)&w_write) & v28) != 0) {
            // break -> 0x80b5a9e
            break;
        }
        // 0x80b5a74
        v29 = v26;
        if ((*(int32_t *)(v27 + (int32_t)&w_error) & v28) != 0) {
            // break -> 0x80b5a9e
            break;
        }
        // 0x80b5a80
        v29 = -1;
        if (v26 == 0) {
            // break -> 0x80b5a9e
            break;
        }
        v26--;
        v27 = 4 * (v26 >> 5);
        v28 = 1 << v26 % 32;
        v29 = v26;
    }
    // 0x80b5a9e
    w_max = v29 + 1;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/main/select.c
// Address range: 0x80b5c80 - 0x80b5cd2
// Line range:    109 - 120
void check_bottom_halves(void) {
    // 0x80b5c80
    if (bottom_halves == 0x8145418) {
        // 0x80b5ccb
        return;
    }
    int32_t v1 = *(int32_t *)0x814541c; // 0x80b5c98
    int32_t * v2 = (int32_t *)v1; // 0x80b5c9d
    int32_t * v3 = (int32_t *)(v1 + 4); // 0x80b5c9f
    *(int32_t *)(*v2 + 4) = *v3;
    *(int32_t *)*v3 = *v2;
    mem_free((char *)v1);
    while (bottom_halves != 0x8145418) {
        // 0x80b5c98
        v1 = *(int32_t *)0x814541c;
        v2 = (int32_t *)v1;
        v3 = (int32_t *)(v1 + 4);
        *(int32_t *)(*v2 + 4) = *v3;
        *(int32_t *)*v3 = *v2;
        mem_free((char *)v1);
    }
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/main/select.c
// Address range: 0x80b5ce0 - 0x80b6016
// Line range:    208 - 241
void select_loop(void (*init)()) {
    // 0x80b5ce0
    clear_signal_mask_and_handlers();
    __asm_rep_stosd_memset((char *)&w_read, 0, 32);
    __asm_rep_stosd_memset((char *)&w_write, 0, 32);
    __asm_rep_stosd_memset((char *)&w_error, 0, 32);
    w_max = 0;
    int32_t v1; // bp-36, 0x80b5ce0
    timeval_now(&v1);
    signal(SIGPIPE, SIG_IGN);
    check_bottom_halves();
    while (true) {
      lab_0x80b5d50_2:
        // 0x80b5d50
        while (program == 0) {
            // 0x80b5d50
            check_signals();
            check_timers(&v1);
            redraw_all_terminals();
            __asm_rep_movsd_memcpy((char *)&x_read, (char *)&w_read, 32);
            __asm_rep_movsd_memcpy((char *)&x_write, (char *)&w_write, 32);
            __asm_rep_movsd_memcpy((char *)&x_error, (char *)&w_error, 32);
            while (program == 0) {
                // 0x80b5dae
                int32_t last_time; // bp-44, 0x80b5ce0
                if (get_next_timer_time(&last_time) == 0) {
                    // 0x80b6003
                    if (w_max == 0) {
                        return;
                    }
                }
                // 0x80b5dc3
                critical_section = 1;
                if (check_signals() == 0) {
                    // break -> 0x80b5df8
                    break;
                }
                // 0x80b5dd6
                critical_section = 0;
                if (program != 0) {
                    return;
                }
                check_signals();
                check_timers(&v1);
                redraw_all_terminals();
                __asm_rep_movsd_memcpy((char *)&x_read, (char *)&w_read, 32);
                __asm_rep_movsd_memcpy((char *)&x_write, (char *)&w_write, 32);
                __asm_rep_movsd_memcpy((char *)&x_error, (char *)&w_error, 32);
            }
            return;
        }
        return;
    }
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/main/select.c
// Address range: 0x80b6020 - 0x80b6093
// Line range:    91 - 103
int32_t register_bottom_half_do(void (*fn)(char *), char * data) {
    char * v1 = mem_alloc(16); // 0x80b606f
    int32_t result = -1; // 0x80b607b
    if (v1 != NULL) {
        int32_t v2 = (int32_t)v1; // 0x80b606f
        *(int32_t *)(v2 + 8) = (int32_t)fn;
        *(int32_t *)(v2 + 12) = (int32_t)data;
        *(int32_t *)(v2 + 4) = (int32_t)&bottom_halves;
        *(int32_t *)v1 = bottom_halves;
        bottom_halves = v2;
        *(int32_t *)(*(int32_t *)v1 + 4) = v2;
        result = 0;
    }
    // 0x80b605a
    return result;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/main/timer.c
// Address range: 0x80b60d0 - 0x80b60fb
// Line range:    118 - 126
int32_t get_next_timer_time(int32_t * t) {
    int32_t result = 0; // 0x80b60df
    if (timers != 0x8145420) {
        // 0x80b60e1
        *t = g37;
        *(int32_t *)((int32_t)t + 4) = g38;
        result = 1;
    }
    // 0x80b60f9
    return result;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/main/timer.c
// Address range: 0x80b6100 - 0x80b6172
// Line range:    103 - 107
void kill_timer(int32_t ** id) {
    // 0x80b6100
    if (assert_failed == 0) {
        // 0x80b6113
        assert_failed = id == NULL;
        if (id == NULL) {
            // 0x80b6150
            errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/main/timer.c";
            errline = 107;
            elinks_internal("assertion id != NULL failed!");
        }
    }
    int32_t * v1 = *id;
    if (v1 != NULL) {
        int32_t * v2 = (int32_t *)((int32_t)v1 + 4); // 0x80b612b
        *(int32_t *)(*v1 + 4) = *v2;
        *(int32_t *)*v2 = *v1;
        mem_free((char *)v1);
        *(int32_t *)id = 0;
    }
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/main/timer.c
// Address range: 0x80b6180 - 0x80b625d
// Line range:    80 - 84
void install_timer(int32_t ** id, int32_t delay, void (*func)(char *), char * data) {
    // 0x80b6180
    if (assert_failed == 0) {
        bool v1 = id == NULL | delay < 1;
        assert_failed = v1;
        if (v1) {
            // 0x80b6238
            errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/main/timer.c";
            errline = 84;
            elinks_internal("assertion id && delay > 0 failed!");
        }
    }
    char * v2 = mem_alloc(24); // 0x80b61bc
    int32_t v3 = (int32_t)v2; // 0x80b61bc
    *(int32_t *)id = v3;
    if (v2 != NULL) {
        // 0x80b61c9
        timeval_from_milliseconds((int32_t *)(v3 + 8), delay);
        *(int32_t *)(v3 + 16) = (int32_t)func;
        *(int32_t *)(v3 + 20) = (int32_t)data;
        *(int32_t *)v2 = *(int32_t *)*(int32_t *)((int32_t)&timers + 4);
        *(int32_t *)(v3 + 4) = *(int32_t *)((int32_t)&timers + 4);
        *(int32_t *)*(int32_t *)((int32_t)&timers + 4) = v3;
        *(int32_t *)(*(int32_t *)v2 + 4) = v3;
    }
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/main/timer.c
// Address range: 0x80b6260 - 0x80b631c
// Line range:    37 - 53
void check_timers(int32_t * last_time) {
    // 0x80b6260
    int32_t v1; // bp-36, 0x80b6260
    timeval_now(&v1);
    int32_t now; // bp-44, 0x80b6260
    timeval_sub(&now, last_time, &v1);
    *last_time = v1;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/network/connection.c
// Address range: 0x80b8e30 - 0x80b8eb0
// Line range:    428 - 442
void notify_connection_callbacks(int32_t * conn) {
    // 0x80b8e30
    int32_t v1; // 0x80b8e30
    int32_t v2 = v1 + 8; // 0x80b8e3e
    int32_t v3 = *(int32_t *)v2; // 0x80b8e47
    if (v3 == v2) {
        // 0x80b8ea8
        return;
    }
    int32_t v4 = *(int32_t *)v3;
    *(int32_t *)(v3 + 12) = *(int32_t *)(v1 + 36);
    while (*(int32_t *)(v1 + 80) <= -1 && v4 != v2) {
        int32_t v5 = v4;
        v4 = *(int32_t *)v5;
        *(int32_t *)(v5 + 12) = *(int32_t *)(v1 + 36);
    }
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/network/connection.c
// Address range: 0x80b8eb0 - 0x80b8ee4
// Line range:    1198 - 1207
int32_t is_entry_used(int32_t * cached) {
    // 0x80b8eb0
    return 0;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/network/connection.c
// Address range: 0x80b8ef0 - 0x80b8f60
// Line range:    71 - 83
int32_t get_priority(int32_t * conn) {
    int32_t v1 = 0;
    int32_t result = v1; // 0x80b8f06
    int32_t v2; // 0x80b8ef0
    while (*(int32_t *)(v2 + 124 + 4 * v1) == 0) {
        int32_t v3 = v1 + 1; // 0x80b8f08
        result = v3;
        if (v1 == 6) {
            // break -> 0x80b8f13
            break;
        }
        v1 = v3;
        result = v1;
    }
    // 0x80b8f13
    if (assert_failed != 0) {
        // 0x80b8f2e
        return result;
    }
    // 0x80b8f1d
    assert_failed = result == 7;
    if (result != 7) {
        // 0x80b8f2e
        return result;
    }
    // 0x80b8f38
    errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/network/connection.c";
    errline = 79;
    elinks_internal("assertion priority != PRIORITIES failed: Connection has no owner");
    return result;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/network/connection.c
// Address range: 0x80b8fc0 - 0x80b9043
// Line range:    677 - 697
void sort_queue(void) {
    // 0x80b8fc0
    return;
}

// Address range: 0x80b9050 - 0x80b90d2
int32_t connection_state(void) {
    // 0x80b9050
    int32_t result; // 0x80b9050
    if (assert_failed != 0) {
        // 0x80b90b8
        assert_failed = 0;
        *(int32_t *)(result + 4) = 0;
        *(int32_t *)result = -0x186a3;
        return result;
    }
    // 0x80b9060
    assert_failed = result == -1;
    if (result != -1) {
        // 0x80b9072
        *(int32_t *)(result + 4) = 0;
        return result;
    }
    // 0x80b9080
    errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/network/state.h";
    errline = 132;
    elinks_internal("assertion basic != S_ERRNO failed!");
    if (assert_failed == 0) {
        // 0x80b9072
        *(int32_t *)(result + 4) = 0;
        return result;
    }
    // 0x80b90b8
    assert_failed = 0;
    *(int32_t *)(result + 4) = 0;
    *(int32_t *)result = -0x186a3;
    return result;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/network/connection.c
// Address range: 0x80b90e0 - 0x80b9284
// Line range:    265 - 299
int32_t * init_connection(int32_t * uri, int32_t * proxied_uri, int32_t * referrer, int64_t start, int32_t cache_mode, int32_t priority) {
    char * v1 = mem_calloc(1, 156); // 0x80b910b
    int32_t v2 = (int32_t)v1; // 0x80b910b
    if (v1 == NULL) {
        // 0x80b91e8
        return (int32_t *)v2;
    }
    // 0x80b911a
    int32_t v3; // 0x80b90e0
    if (assert_failed == 0) {
        int32_t v4 = *(int32_t *)(v3 + 4); // 0x80b91fa
        assert_failed = v4 == 15;
        if (v4 == 15) {
            // 0x80b920e
            errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/network/connection.c";
            errline = 279;
            elinks_internal("assertion proxied_uri->protocol != PROTOCOL_PROXY failed!");
        }
    }
    int32_t * v5 = init_socket(v1, &g39); // 0x80b9132
    int32_t * v6 = (int32_t *)(v2 + 96); // 0x80b9139
    *v6 = (int32_t)v5;
    if (v5 == NULL) {
        // 0x80b9253
        mem_free(v1);
        // 0x80b91e8
        return (int32_t *)0;
    }
    int32_t * v7 = init_socket(v1, &g39); // 0x80b914d
    int32_t * v8 = (int32_t *)(v2 + 100); // 0x80b9154
    *v8 = (int32_t)v7;
    if (v7 == NULL) {
        // 0x80b9248
        mem_free((char *)*v6);
        // 0x80b9253
        mem_free(v1);
        // 0x80b91e8
        return (int32_t *)0;
    }
    int32_t * v9 = init_progress((int64_t)(int32_t)uri); // 0x80b916a
    *(int32_t *)(v2 + 16) = (int32_t)v9;
    if (v9 == NULL) {
        // 0x80b925f
        mem_free((char *)*v8);
        mem_free((char *)*v6);
        mem_free(v1);
        // 0x80b91e8
        return (int32_t *)0;
    }
    // 0x80b917a
    *(int32_t *)(v2 + 76) = connection_id;
    connection_id++;
    *(int32_t *)(4 * (int32_t)start + 124 + v2) = 1;
    *(int32_t *)(v2 + 64) = 0;
    *(int32_t *)(v2 + 116) = -1;
    *(int32_t *)(v2 + 112) = -1;
    *(int32_t *)(v2 + 32) = (int32_t)referrer;
    int32_t v10 = v2 + 8; // 0x80b91bb
    *(int32_t *)(v2 + 12) = v10;
    *(int32_t *)v10 = v10;
    *(int32_t *)(v2 + 56) = -1;
    *(int32_t *)(v2 + 60) = -1;
    *(int32_t *)(v2 + 108) = 0;
    if (v3 == 0) {
        // 0x80b91e8
        return (int32_t *)v2;
    }
    // 0x80b91db
    if (*(int32_t *)(v3 + 4) == 4) {
        // 0x80b9238
        if (*(int32_t *)(v3 + 4) != 4) {
            // 0x80b923e
            return (int32_t *)v1;
        }
    }
    int32_t * v11 = (int32_t *)(v3 + 56); // 0x80b91e1
    *v11 = *v11 + 1;
    // 0x80b91e8
    return (int32_t *)v2;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/network/connection.c
// Address range: 0x80b9290 - 0x80b92ea
// Line range:    156 - 162
int32_t * get_host_connection(int32_t * conn) {
    // 0x80b9290
    return NULL;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/network/connection.c
// Address range: 0x80b92f0 - 0x80b9366
// Line range:    172 - 182
int32_t add_host_connection(int32_t * conn) {
    // 0x80b92f0
    int32_t v1; // 0x80b92f0
    int32_t * v2 = get_host_connection((int32_t *)v1); // 0x80b92f9
    int32_t v3 = (int32_t)v2; // 0x80b9300
    if (v2 == NULL) {
        int32_t * v4 = (int32_t *)(v1 + 20); // 0x80b9318
        if (*(int32_t *)(*v4 + 20) == 0) {
            // 0x80b930b
            return 1;
        }
        char * v5 = mem_calloc(1, 16); // 0x80b9336
        if (v5 == NULL) {
            // 0x80b930b
            return 0;
        }
        // 0x80b9341
        v3 = (int32_t)v5;
        int32_t v6 = *v4; // 0x80b9341
        int32_t * v7 = (int32_t *)(v6 + 56); // 0x80b9344
        *v7 = *v7 + 1;
        *(int32_t *)(v3 + 12) = v6;
        *(int32_t *)(v3 + 4) = (int32_t)&host_connections;
        *(int32_t *)v5 = (int32_t)&host_connections;
        host_connections = v3;
        *(int32_t *)(*(int32_t *)v5 + 4) = v3;
    }
    int32_t * v8 = (int32_t *)(v3 + 8); // 0x80b9302
    *v8 = *v8 + 1;
    // 0x80b930b
    return 1;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/network/connection.c
// Address range: 0x80b9690 - 0x80b96ac
// Line range:    856 - 859
int32_t register_check_queue(void) {
    // 0x80b9690
    return register_bottom_half_do((void (*)(char *))0x80baf50, NULL);
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/network/connection.c
// Address range: 0x80b96b0 - 0x80b9709
// Line range:    379 - 387
void shutdown_connection_stream(int32_t * conn) {
    int32_t v1 = (int32_t)conn;
    int32_t * v2 = (int32_t *)(v1 + 68); // 0x80b96ba
    int32_t v3 = *v2; // 0x80b96ba
    if (v3 == 0) {
        uint32_t fd = *(int32_t *)(v1 + 112); // 0x80b96f8
        if (fd >= 0) {
            // 0x80b96ff
            close(fd);
        }
    } else {
        // 0x80b96c1
        close_encoded((int32_t *)v3);
        *v2 = 0;
    }
    int32_t * v4 = (int32_t *)(v1 + 116); // 0x80b96d0
    uint32_t fd2 = *v4; // 0x80b96d0
    if (fd2 >= 0) {
        // 0x80b96d7
        close(fd2);
    }
    // 0x80b96df
    *v4 = -1;
    *(int32_t *)(v1 + 112) = -1;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/network/connection.c
// Address range: 0x80b9710 - 0x80b98bd
// Line range:    395 - 397
void free_connection_data(int32_t * conn) {
    // 0x80b9710
    int32_t v1; // 0x80b9710
    char * v2 = (char *)(v1 + 120);
    if (assert_failed == 0) {
        unsigned char v3 = *v2 % 2 ^ 1;
        assert_failed = v3;
        if (v3 != 0) {
            // 0x80b9898
            errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/network/connection.c";
            errline = 397;
            elinks_internal("assertion conn->running failed: connection already suspended");
        }
    }
    // 0x80b973a
    *v2 = *v2 & -2;
    int32_t v4 = active_connections - 1; // 0x80b9749
    active_connections = v4;
    if (assert_failed != 0) {
        // 0x80b9830
        assert_failed = 0;
        active_connections = 0;
        goto lab_0x80b9769;
    } else {
        // 0x80b9759
        assert_failed = v4 < 0;
        if (v4 < 0) {
            // 0x80b9800
            errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/network/connection.c";
            errline = 403;
            elinks_internal("assertion active_connections >= 0 failed: active connections underflow");
            if (assert_failed == 0) {
                goto lab_0x80b9769;
            } else {
                // 0x80b9830
                assert_failed = 0;
                active_connections = 0;
                goto lab_0x80b9769;
            }
        } else {
            goto lab_0x80b9769;
        }
    }
  lab_0x80b9769:;
    int32_t * v5 = (int32_t *)(v1 + 96); // 0x80b9769
    int32_t v6 = *v5; // 0x80b9769
    int32_t v7 = v6; // 0x80b9771
    if (*(int32_t *)(v6 + 32) != 0) {
        int32_t * v8 = (int32_t *)(v1 + 36); // 0x80b9773
        int32_t v9 = *v8; // 0x80b9773
        v7 = v6;
        if (v9 != 0) {
            int32_t * v10 = (int32_t *)(v9 + 48);
            int32_t v11 = *v10; // 0x80b977a
            int32_t * v12 = v10; // 0x80b977f
            int32_t v13 = v6; // 0x80b977f
            if (v11 != 0) {
                // 0x80b9781
                mem_free((char *)v11);
                v13 = *v5;
                v12 = (int32_t *)(*v8 + 48);
            }
            // 0x80b978f
            *v12 = (int32_t)get_ssl_connection_cipher((int32_t *)v13);
            v7 = *v5;
        }
    }
    // 0x80b979a
    done_socket((int32_t *)v7);
    done_socket((int32_t *)*(int32_t *)(v1 + 100));
    shutdown_connection_stream((int32_t *)v1);
    int32_t * v14 = (int32_t *)(v1 + 152); // 0x80b97c4
    int32_t v15 = *v14; // 0x80b97c4
    if (v15 != 0) {
        // 0x80b97ce
        mem_free((char *)v15);
    }
    // 0x80b97d6
    *v14 = 0;
    kill_timer((int32_t **)(v1 + 108));
    if (*(int32_t *)(v1 + 80) == 0) {
        // 0x80b97f2
        return;
    }
    int32_t * v16 = get_host_connection(&g83); // 0x80b9852
    if (v16 == NULL) {
        // 0x80b97f2
        return;
    }
    int32_t v17 = (int32_t)v16; // 0x80b9852
    int32_t * v18 = (int32_t *)(v17 + 8); // 0x80b985b
    int32_t v19 = *v18 - 1; // 0x80b985e
    *v18 = v19;
    if (v19 != 0) {
        // 0x80b97f2
        return;
    }
    int32_t * v20 = (int32_t *)(v17 + 4); // 0x80b986a
    *(int32_t *)(*v16 + 4) = *v20;
    *(int32_t *)*v20 = *v16;
    done_uri((int32_t *)*(int32_t *)(v17 + 12));
    mem_free((char *)v16);
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/network/connection.c
// Address range: 0x80b98c0 - 0x80b99f9
// Line range:    347 - 353
void set_connection_state(int32_t * conn, int32_t state) {
    int32_t v1 = (int32_t)conn;
    int32_t * v2 = (int32_t *)(v1 + 80); // 0x80b98d2
    int32_t v3 = *v2; // 0x80b98d2
    int32_t * v4 = (int32_t *)(v1 + 16); // 0x80b98d5
    int32_t v5 = *v4; // 0x80b98d5
    if (v3 < 0) {
        // 0x80b9980
        if (state >= 0) {
            // 0x80b99e8
            *(int32_t *)(v1 + 88) = v3;
            *(int32_t *)(v1 + 92) = *(int32_t *)(v1 + 84);
            goto lab_0x80b98e0;
        } else {
            // 0x80b998a
            *v2 = state;
            // 0x80b9990
            kill_timer((int32_t **)(v5 + 100));
            goto lab_0x80b99a1;
        }
    } else {
        // 0x80b98c0
        goto lab_0x80b98e0;
    }
  lab_0x80b98e0:
    // 0x80b98e0
    *v2 = state;
    if (state != 8) {
        // 0x80b9990
        kill_timer((int32_t **)(v5 + 100));
        goto lab_0x80b99a1;
    } else {
        // 0x80b98ef
        if (*(int32_t *)(v5 + 100) == 0) {
            // 0x80b98fa
            start_update_progress((int32_t *)v5, (void (*)(char *))0x80b9a80, (char *)conn);
            int32_t v6 = *(int32_t *)(v1 + 56); // 0x80b9922
            int32_t v7 = *(int32_t *)(v1 + 48); // 0x80b9930
            int32_t v8 = *(int32_t *)(v1 + 52); // 0x80b9933
            int32_t v9 = *v4; // 0x80b993e
            update_progress((int32_t *)v9, (int64_t)v7, (int64_t)v8, (int64_t)v6);
            // 0x80b99e0
            return;
        }
        goto lab_0x80b99a1;
    }
  lab_0x80b99a1:;
    int32_t v10 = v1 + 8; // 0x80b99a1
    int32_t v11 = *(int32_t *)v10; // 0x80b99a1
    if (v11 != v10) {
        int32_t v12 = v11; // 0x80b99c2
        *(int32_t *)(v12 + 28) = state;
        *(int32_t *)(v12 + 36) = *(int32_t *)(v1 + 88);
        *(int32_t *)(v12 + 40) = *(int32_t *)(v1 + 92);
        v12 = *(int32_t *)v12;
        while (v12 != v10) {
            // 0x80b99b0
            *(int32_t *)(v12 + 28) = state;
            *(int32_t *)(v12 + 36) = *(int32_t *)(v1 + 88);
            *(int32_t *)(v12 + 40) = *(int32_t *)(v1 + 92);
            v12 = *(int32_t *)v12;
        }
    }
    if (state < 0) {
        // 0x80b99e0
        return;
    }
    // 0x80b99cd
    notify_connection_callbacks(&g83);
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/network/connection.c
// Address range: 0x80b9fe0 - 0x80ba07c
// Line range:    445 - 464
void done_connection(int32_t * conn) {
    // 0x80b9fe0
    int32_t v1; // 0x80b9fe0
    uint32_t v2 = *(int32_t *)(v1 + 80); // 0x80b9fe9
    int32_t v3 = v2; // 0x80b9fee
    if (v2 >= 0) {
        // 0x80b9ff0
        assert_failed = 0;
        set_connection_state((int32_t *)v1, -0x186a3);
        v3 = &g83;
    }
    int32_t * v4 = (int32_t *)(v1 + 4); // 0x80ba014
    *(int32_t *)(v3 + 4) = *v4;
    int32_t v5 = *v4; // 0x80ba01a
    *(int32_t *)v5 = v5;
    notify_connection_callbacks(&g83);
    int32_t v6 = *(int32_t *)(v1 + 28); // 0x80ba028
    if (v6 != 0) {
        // 0x80ba02f
        done_uri((int32_t *)v6);
    }
    // 0x80ba037
    done_uri((int32_t *)*(int32_t *)(v1 + 20));
    done_uri((int32_t *)*(int32_t *)(v1 + 24));
    mem_free((char *)*(int32_t *)(v1 + 96));
    mem_free((char *)*(int32_t *)(v1 + 100));
    done_progress((int32_t *)*(int32_t *)(v1 + 16));
    mem_free((char *)v1);
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/network/connection.c
// Address range: 0x80ba080 - 0x80ba1b5
// Line range:    483 - 510
int32_t do_keepalive_connection_callback(int32_t * keep_conn) {
    // 0x80ba080
    int32_t v1; // 0x80ba080
    int32_t * v2 = (int32_t *)(v1 + 8); // 0x80ba08b
    int32_t * v3 = get_proxied_uri((int32_t *)*v2); // 0x80ba091
    int32_t * v4 = get_proxy_uri((int32_t *)*v2, NULL); // 0x80ba0a6
    if (v4 == NULL) {
        // 0x80ba0ba
        if (v3 != NULL) {
            // 0x80ba0c6
            done_uri(v3);
        }
        // 0x80ba0d6
        return 0;
    }
    if (v3 == NULL) {
        // 0x80ba0cc
        done_uri(v4);
        // 0x80ba0d6
        return 0;
    }
    int32_t * v5 = init_connection(NULL, NULL, (int32_t *)4, 6, (int32_t)&g83, (int32_t)&g83); // 0x80ba109
    if (v5 == NULL) {
        // 0x80ba0c6
        done_uri(v3);
        // 0x80ba0cc
        done_uri(v4);
        // 0x80ba0d6
        return 0;
    }
    int32_t v6 = (int32_t)v5; // 0x80ba109
    get_priority(v5);
    *v5 = *(int32_t *)*(int32_t *)((int32_t)&connection_queue + 4);
    *(int32_t *)(v6 + 4) = *(int32_t *)((int32_t)&connection_queue + 4);
    *(int32_t *)*(int32_t *)((int32_t)&connection_queue + 4) = v6;
    *(int32_t *)(*v5 + 4) = v6;
    if (has_keepalive_connection(v5) == 0 || add_host_connection(&g83) == 0) {
        // 0x80ba162
        free_connection_data(&g83);
        done_connection(&g83);
        return 0;
    }
    // 0x80ba198
    active_connections++;
    char * v7 = (char *)(v6 + 120); // 0x80ba1a2
    *v7 = *v7 | 1;
    // 0x80ba0d6
    return 1;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/network/connection.c
// Address range: 0x80ba1c0 - 0x80ba291
// Line range:    570 - 586
int32_t has_keepalive_connection(int32_t * conn) {
    // 0x80ba1c0
    return 0;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/network/connection.c
// Address range: 0x80ba2a0 - 0x80ba468
// Line range:    628 - 664
void check_keepalive_connections(void) {
    // 0x80ba2a0
    int32_t v1; // bp-36, 0x80ba2a0
    timeval_now(&v1);
    kill_timer(&keepalive_timeout);
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/network/connection.c
// Address range: 0x80ba670 - 0x80ba72d
// Line range:    736 - 738
void abort_connection(int32_t * conn, int32_t state) {
    // 0x80ba670
    if (assert_failed == 0) {
        // 0x80ba691
        assert_failed = state > -1;
        if (state > -1) {
            // 0x80ba700
            errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/network/connection.c";
            errline = 739;
            elinks_internal("assertion is_in_result_state(state) failed: connection didn't end in result state (%d)", state);
        }
    }
    int32_t v1 = (int32_t)conn;
    if (state == -0x186a0) {
        int32_t v2 = *(int32_t *)(v1 + 36); // 0x80ba6e0
        if (v2 != 0) {
            // 0x80ba6e7
            normalize_cache_entry((int32_t *)v2, (int64_t)*(int32_t *)(v1 + 40));
        }
    }
    // 0x80ba6a9
    set_connection_state(conn, state);
    if (*(char *)(v1 + 120) % 2 != 0) {
        // 0x80ba6bf
        free_connection_data(&g83);
    }
    // 0x80ba6c6
    done_connection(&g83);
    register_check_queue();
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/network/connection.c
// Address range: 0x80ba7c0 - 0x80ba892
// Line range:    1176 - 672
void abort_all_connections(void) {
    // 0x80ba7c0
    check_keepalive_connections();
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/network/connection.c
// Address range: 0x80ba920 - 0x80bab15
// Line range:    1002 - 1031
void cancel_download(int32_t * download, int32_t interrupt) {
    // 0x80ba920
    if (assert_failed != 0) {
        // 0x80baa20
        assert_failed = 0;
        // 0x80baa2a
        return;
    }
    // 0x80ba943
    assert_failed = download == NULL;
    if (download == NULL) {
        // 0x80ba9f0
        errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/network/connection.c";
        errline = 1006;
        elinks_internal("assertion download failed!");
        if (assert_failed != 0) {
            // 0x80baa20
            assert_failed = 0;
            // 0x80baa2a
            return;
        }
    }
    int32_t v1 = (int32_t)download;
    int32_t * v2 = (int32_t *)(v1 + 28); // 0x80ba957
    if (*v2 < 0) {
        // 0x80baa2a
        return;
    }
    int32_t * v3 = (int32_t *)(v1 + 8); // 0x80ba964
    int32_t v4 = *v3; // 0x80ba964
    assert_failed = v4 == 0;
    int32_t v5 = -0x186a1; // 0x80ba973
    if (v4 == 0) {
        // 0x80baa88
        errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/network/connection.c";
        errline = 1013;
        elinks_internal("assertion download->conn != NULL failed: last state is %d", *v2);
        v5 = assert_failed == 0 ? -0x186a1 : -0x186a3;
    }
    // 0x80ba988
    assert_failed = 0;
    *v2 = v5;
    int32_t * v6 = (int32_t *)(v1 + 4); // 0x80ba98b
    *(int32_t *)(v1 + 32) = 0;
    *(int32_t *)(*download + 4) = *v6;
    *(int32_t *)*v6 = *download;
    int32_t v7 = *v3; // 0x80ba9a1
    int32_t * v8 = (int32_t *)(v1 + 44); // 0x80ba9a4
    int32_t v9 = v7 + 124; // 0x80ba9a7
    int32_t * v10 = (int32_t *)(4 * *v8 + v9); // 0x80ba9a7
    *v10 = *v10 - 1;
    if (assert_failed != 0) {
        goto lab_0x80baa68;
    } else {
        int32_t v11 = *(int32_t *)(4 * *v8 + v9); // 0x80ba9bd
        assert_failed = v11 < 0;
        if (v11 < 0) {
            // 0x80baa38
            errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/network/connection.c";
            errline = 1023;
            elinks_internal("assertion conn->pri[download->pri] >= 0 failed: priority counter underflow");
            if (assert_failed == 0) {
                goto lab_0x80ba9cd;
            } else {
                goto lab_0x80baa68;
            }
        } else {
            goto lab_0x80ba9cd;
        }
    }
  lab_0x80baa68:
    // 0x80baa68
    assert_failed = 0;
    *(int32_t *)(4 * *v8 + v9) = 0;
    goto lab_0x80ba9cd;
  lab_0x80ba9cd:;
    int32_t v12 = v7 + 8; // 0x80ba9cd
    if (*(int32_t *)v12 != v12) {
        // 0x80ba9d9
        sort_queue();
        register_check_queue();
        return;
    }
    int32_t * v13 = (int32_t *)(v7 + 148); // 0x80baad8
    *v13 = *v13 + 1;
    int32_t v14; // 0x80ba920
    if (interrupt != 0) {
        // 0x80baaed
        connection_state();
        abort_connection((int32_t *)v7, v14);
        // 0x80ba9d9
        sort_queue();
        register_check_queue();
        return;
    }
    // 0x80baae3
    if ((*(char *)(v7 + 120) & 4) == 0) {
        // 0x80ba9d9
        sort_queue();
        register_check_queue();
        return;
    }
    // 0x80baaed
    connection_state();
    abort_connection((int32_t *)v7, v14);
    // 0x80ba9d9
    sort_queue();
    register_check_queue();
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/network/dns.c
// Address range: 0x80bb1f0 - 0x80bb225
// Line range:    130 - 135
void del_dns_cache_entry(int32_t * dnsentry) {
    // 0x80bb1f0
    int32_t v1; // 0x80bb1f0
    int32_t v2 = *(int32_t *)(v1 + 4); // 0x80bb1fb
    *(int32_t *)v2 = v2;
    int32_t v3 = *(int32_t *)(v1 + 8); // 0x80bb208
    if (v3 != 0) {
        // 0x80bb20f
        mem_free((char *)v3);
    }
    // 0x80bb217
    mem_free((char *)v1);
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/network/dns.c
// Address range: 0x80bb230 - 0x80bb2ef
// Line range:    541 - 564
void shrink_dns_cache(int32_t whole) {
    if (whole == 0) {
        // 0x80bb270
        int32_t v1; // bp-44, 0x80bb230
        timeval_from_seconds(&v1, 3600);
        int32_t v2; // bp-36, 0x80bb230
        timeval_now(&v2);
    }
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/network/dns.c
// Address range: 0x80bb2f0 - 0x80bb536
// Line range:    422 - 115
void done_dns_lookup(int32_t * query, int32_t result) {
    // 0x80bb2f0
    int32_t v1; // 0x80bb2f0
    int32_t * fd = (int32_t *)(v1 + 20); // 0x80bb2fe
    int32_t v2 = *fd; // 0x80bb2fe
    if (v2 != -1) {
        // 0x80bb306
        set_handlers(v2, NULL, NULL, NULL, NULL);
        close(*fd);
        *fd = -1;
    }
    int32_t v3 = *(int32_t *)(v1 + 16); // 0x80bb340
    *(int32_t *)v3 = 0;
    if (v3 != 0) {
        if (v1 == 0) {
            int32_t str = v1 + 24; // 0x80bb359
            int32_t v4 = *(int32_t *)(v1 + 12); // 0x80bb428
            int32_t len = strlen((char *)str); // 0x80bb437
            if (assert_failed == 0) {
                // 0x80bb449
                assert_failed = v4 < 1;
                if (v4 < 1) {
                    // 0x80bb504
                    errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/network/dns.c";
                    errline = 107;
                    elinks_internal("assertion addrno > 0 failed!");
                }
            }
            char * v5 = mem_calloc(1, len + 28); // 0x80bb471
            if (v5 != NULL) {
                int32_t v6 = (int32_t)v5; // 0x80bb471
                int32_t v7 = 128 * v4; // 0x80bb486
                char * v8 = mem_alloc(v7); // 0x80bb48f
                int32_t * v9 = (int32_t *)(v6 + 8); // 0x80bb499
                *v9 = (int32_t)v8;
                if (v8 == NULL) {
                    // 0x80bb529
                    mem_free(v5);
                } else {
                    // 0x80bb4a2
                    memcpy((int32_t *)(v6 + 24), (int32_t *)str, len);
                    memcpy((int32_t *)*v9, (int32_t *)*(int32_t *)(v1 + 8), v7);
                    *(int32_t *)(v6 + 12) = v4;
                    timeval_now((int32_t *)(v6 + 16));
                    *(int32_t *)v5 = dns_cache;
                    *(int32_t *)(v6 + 4) = (int32_t)&dns_cache;
                    dns_cache = v6;
                    *(int32_t *)(*(int32_t *)v5 + 4) = v6;
                }
            }
        }
    }
    int32_t * v10 = (int32_t *)(v1 + 8); // 0x80bb3e8
    int32_t v11 = *v10; // 0x80bb3e8
    if (v11 != 0) {
        // 0x80bb3ef
        mem_free((char *)v11);
    }
    // 0x80bb3f7
    *v10 = 0;
    mem_free((char *)v1);
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/network/dns.c
// Address range: 0x80bb540 - 0x80bb5a0
// Line range:    530 - 534
void kill_dns_request(char ** queryref) {
    char * v1 = *queryref; // 0x80bb551
    if (assert_failed != 0) {
        // 0x80bb566
        *(int32_t *)v1 = 0;
        done_dns_lookup(&g83, (int32_t)&g83);
        return;
    }
    // 0x80bb555
    assert_failed = v1 == NULL;
    if (v1 == NULL) {
        // 0x80bb578
        errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/network/dns.c";
        errline = 534;
        elinks_internal("assertion query failed!");
    }
    // 0x80bb566
    *(int32_t *)v1 = 0;
    done_dns_lookup(&g83, (int32_t)&g83);
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/network/progress.c
// Address range: 0x80bbd50 - 0x80bbf8b
// Line range:    51 - 84
void update_progress(int32_t * progress, int64_t loaded, int64_t size, int64_t pos) {
    int32_t v1 = size;
    uint32_t v2 = (int32_t)loaded;
    int32_t v3 = (int32_t)progress;
    int32_t v4; // bp-36, 0x80bbd50
    timeval_now(&v4);
    int32_t * v5 = (int32_t *)(v3 + 8); // 0x80bbd9c
    int32_t now; // bp-44, 0x80bbd50
    timeval_sub(&now, v5, &v4);
    *v5 = v4;
    int32_t * v6 = (int32_t *)(v3 + 60); // 0x80bbdb7
    uint32_t v7 = *v6; // 0x80bbdb7
    int32_t * v8 = (int32_t *)(v3 + 64); // 0x80bbdba
    int32_t * v9 = (int32_t *)(v3 + 52); // 0x80bbdbd
    *v9 = v2;
    int32_t * v10 = (int32_t *)(v3 + 56); // 0x80bbdc0
    *v10 = v1;
    *v6 = v2;
    *v8 = v1;
    timeval_add_interval(progress, &now);
    int32_t * v11 = (int32_t *)(v3 + 16); // 0x80bbdeb
    timeval_add_interval(v11, &now);
    int32_t v12 = mult_ms(100, 50); // 0x80bbdff
    int32_t elapsed; // bp-52, 0x80bbd50
    timeval_from_milliseconds(&elapsed, v12);
    int32_t dis_b_max; // bp-60, 0x80bbd50
    timeval_from_milliseconds(&dis_b_max, 100);
    int32_t * v13; // 0x80bbd50
    int32_t * v14; // 0x80bbd50
    int32_t * v15; // 0x80bbd50
    if (timeval_cmp(v11, &elapsed) >= 0) {
        int32_t * v16 = (int32_t *)(v3 + 112); // 0x80bbe38
        int32_t * v17 = (int32_t *)(v3 + 68);
        int32_t * v18 = (int32_t *)(v3 + 72);
        int32_t * v19 = (int32_t *)(v3 + 308);
        uint32_t v20 = *v16; // 0x80bbe38
        uint32_t v21 = *v17; // 0x80bbe40
        *v17 = v21 - v20;
        *v18 = (int32_t)(v20 < 0) + (int32_t)(v21 < v20) + *v18;
        memmove(v16, (int32_t *)(v3 + 116), 196);
        *v19 = 0;
        timeval_sub_interval(v11, &dis_b_max);
        int32_t v22 = timeval_cmp(v11, &elapsed); // 0x80bbe80
        v15 = v18;
        v14 = v17;
        v13 = v19;
        while (v22 >= 0) {
            // 0x80bbe38
            v20 = *v16;
            v21 = *v17;
            *v17 = v21 - v20;
            *v18 = (int32_t)(v20 < 0) + (int32_t)(v21 < v20) + *v18;
            memmove(v16, (int32_t *)(v3 + 116), 196);
            *v19 = 0;
            timeval_sub_interval(v11, &dis_b_max);
            v22 = timeval_cmp(v11, &elapsed);
            v15 = v18;
            v14 = v17;
            v13 = v19;
        }
    } else {
        // 0x80bbd50
        v15 = (int32_t *)(v3 + 72);
        v14 = (int32_t *)(v3 + 68);
        v13 = (int32_t *)(v3 + 308);
    }
    uint32_t v23 = v2 - v7; // 0x80bbdb7
    int32_t * v24 = v13;
    *v24 = *v24 + v23;
    uint32_t v25 = *v14 + v23; // 0x80bbe98
    int32_t v26 = *v15; // 0x80bbe9b
    int32_t v27 = v1 - *v8 + (int32_t)(v7 > v2) + v26 + (int32_t)(v25 < v23); // 0x80bbe9b
    *v14 = v25;
    *v15 = v27;
    *(int32_t *)(v3 + 36) = __divdi3(v25, v27, 5, 0);
    int32_t * v28 = (int32_t *)(v3 + 44); // 0x80bbed2
    *v28 = (int32_t)pos;
    int32_t v29 = timeval_div_off_t((int64_t)*v9, (int32_t *)*v10); // 0x80bbefa
    *(int32_t *)(v3 + 32) = v29;
    if (v29 != 0) {
        uint32_t v30 = *v28; // 0x80bbf06
        int32_t v31 = *(int32_t *)(v3 + 48); // 0x80bbf0b
        uint32_t v32 = *(int32_t *)(v3 + 84); // 0x80bbf0e
        int32_t v33 = *(int32_t *)(v3 + 88); // 0x80bbf11
        timeval_from_seconds((int32_t *)(v3 + 24), __divdi3(v30 - v32, v31 - v33 + (int32_t)(v30 < v32), v29, v29 >> 31));
    }
    int32_t v34 = *(int32_t *)(v3 + 108); // 0x80bbf3a
    int32_t v35 = *(int32_t *)(v3 + 104); // 0x80bbf41
    install_timer((int32_t **)(v3 + 100), 100, (void (*)(char *))v35, (char *)v34);
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/network/progress.c
// Address range: 0x80bbf90 - 0x80bbff5
// Line range:    42 - 45
void done_progress(int32_t * progress) {
    // 0x80bbf90
    int32_t v1; // 0x80bbf90
    if (assert_failed != 0) {
        // 0x80bbfb6
        mem_free((char *)v1);
        return;
    }
    int32_t v2 = *(int32_t *)((int32_t)progress + 100); // 0x80bbfa5
    assert_failed = v2 != 0;
    if (v2 == 0) {
        // 0x80bbfb6
        mem_free((char *)v1);
        return;
    }
    // 0x80bbfc8
    errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/network/progress.c";
    errline = 44;
    elinks_internal("assertion progress->timer == TIMER_ID_UNDEF failed!");
    mem_free((char *)progress);
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/network/progress.c
// Address range: 0x80bc000 - 0x80bc041
// Line range:    29 - 39
int32_t * init_progress(int64_t start) {
    char * v1 = mem_calloc(1, 312); // 0x80bc021
    if (v1 != NULL) {
        int32_t v2 = (int32_t)v1; // 0x80bc021
        *(int32_t *)(v2 + 76) = (int32_t)start;
        *(int32_t *)(v2 + 100) = 0;
    }
    // 0x80bc037
    return (int32_t *)v1;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/network/progress.c
// Address range: 0x80bc050 - 0x80bc0dd
// Line range:    100 - 118
void start_update_progress(int32_t * progress, void (*timer_func)(char *), char * timer_func_data) {
    int32_t v1 = (int32_t)progress;
    if (*(char *)(v1 + 40) % 2 == 0) {
        // 0x80bc06b
        int32_t v2; // bp-340, 0x80bc050
        __asm_rep_stosd_memset((char *)&v2, 0, 78);
        __asm_rep_movsd_memcpy((char *)progress, (char *)&v2, 78);
    }
    // 0x80bc0ad
    timeval_now((int32_t *)(v1 + 8));
    *(int32_t *)(v1 + 60) = *(int32_t *)(v1 + 52);
    *(int32_t *)(v1 + 64) = *(int32_t *)(v1 + 56);
    *(int32_t *)(v1 + 104) = (int32_t)timer_func;
    *(int32_t *)(v1 + 108) = (int32_t)timer_func_data;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/network/socket.c
// Address range: 0x80bc2a0 - 0x80bc2d2
// Line range:    139 - 151
int32_t * init_socket(char * conn, int32_t * ops) {
    char * v1 = mem_calloc(1, 40); // 0x80bc2b5
    int32_t * result = NULL; // 0x80bc2bc
    if (v1 != NULL) {
        int32_t v2 = (int32_t)v1; // 0x80bc2b5
        *(int32_t *)v1 = -1;
        *(int32_t *)(v2 + 8) = (int32_t)conn;
        *(int32_t *)(v2 + 24) = (int32_t)ops;
        result = (int32_t *)v1;
    }
    // 0x80bc2d0
    return result;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/network/socket.c
// Address range: 0x80bc350 - 0x80bc3e2
// Line range:    125 - 129
void done_connection_info(int32_t * socket) {
    // 0x80bc350
    int32_t v1; // 0x80bc350
    int32_t * v2 = (int32_t *)(v1 + 12); // 0x80bc35a
    int32_t v3 = *v2; // 0x80bc35a
    if (assert_failed == 0) {
        // 0x80bc366
        assert_failed = v3 == 0;
        if (v3 == 0) {
            // 0x80bc3c0
            errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/network/socket.c";
            errline = 129;
            elinks_internal("assertion socket->connect_info failed!");
        }
    }
    int32_t v4 = v3 + 16; // 0x80bc376
    if (*(int32_t *)v4 != 0) {
        // 0x80bc37d
        kill_dns_request((char **)v4);
    }
    int32_t v5 = *(int32_t *)v3; // 0x80bc388
    if (v5 != 0) {
        // 0x80bc38e
        mem_free((char *)v5);
    }
    // 0x80bc396
    done_uri((int32_t *)*(int32_t *)(v3 + 28));
    int32_t v6 = *v2; // 0x80bc3a1
    if (v6 != 0) {
        // 0x80bc3a8
        mem_free((char *)v6);
    }
    // 0x80bc3b0
    *v2 = 0;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/network/socket.c
// Address range: 0x80bc700 - 0x80bc760
// Line range:    173 - 182
void close_socket(int32_t * socket) {
    int32_t v1 = *socket; // 0x80bc70a
    if (v1 == -1) {
        // 0x80bc75a
        return;
    }
    int32_t fd = v1; // 0x80bc716
    if (*(int32_t *)((int32_t)socket + 32) != 0) {
        // 0x80bc718
        ssl_close(socket);
        fd = *socket;
    }
    // 0x80bc722
    close(fd);
    set_handlers(*socket, NULL, NULL, NULL, NULL);
    *socket = -1;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/network/socket.c
// Address range: 0x80bc760 - 0x80bc7e6
// Line range:    154 - 170
void done_socket(int32_t * socket) {
    int32_t v1 = (int32_t)socket;
    close_socket(socket);
    if (*(int32_t *)(v1 + 12) != 0) {
        // 0x80bc779
        done_connection_info(&g83);
    }
    int32_t * v2 = (int32_t *)(v1 + 16); // 0x80bc780
    int32_t v3 = *v2; // 0x80bc780
    if (v3 != 0) {
        // 0x80bc787
        mem_free((char *)v3);
    }
    int32_t * v4 = (int32_t *)(v1 + 20); // 0x80bc78f
    int32_t v5 = *v4; // 0x80bc78f
    *v2 = 0;
    if (v5 != 0) {
        // 0x80bc79d
        mem_free((char *)v5);
    }
    // 0x80bc7a5
    *v4 = 0;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/network/state.c
// Address range: 0x80bdf60 - 0x80bdfc7
// Line range:    189 - 192
void done_state_message(void) {
    int32_t v1 = *(int32_t *)0x8145e1c; // 0x80bdf82
    if (v1 == (int32_t)&strerror_buf) {
        // 0x80bdfbf
        return;
    }
    int32_t v2 = v1; // 0x80bdf8a
    v2 += 4;
    while (v2 != (int32_t)&strerror_buf) {
        // 0x80bdf90
        v2 += 4;
    }
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/network/ssl/socket.c
// Address range: 0x80be1a0 - 0x80be1cf
// Line range:    267 - 273
int32_t ssl_close(int32_t * socket) {
    // 0x80be1a0
    function_8059ab8(*(int32_t *)*(int32_t *)((int32_t)socket + 32), 0);
    done_ssl_connection(socket);
    return 0;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/network/ssl/ssl.c
// Address range: 0x80be7f0 - 0x80be8d3
// Line range:    296 - 320
char * get_ssl_connection_cipher(int32_t * socket) {
    // 0x80be7f0
    char * result; // bp-36, 0x80be7f0
    int32_t v1 = init_string((int32_t *)&result); // 0x80be805
    result = NULL;
    if (v1 != 0) {
        int32_t * v2 = (int32_t *)*(int32_t *)((int32_t)socket + 32); // 0x80be816
        int32_t v3 = function_8059598(function_8058e58(*v2)); // 0x80be823
        int32_t v4 = function_8058d38(function_8059778(*v2)); // 0x80be83a
        int32_t v5 = function_8059508(function_8058c48(*v2)); // 0x80be84e
        int32_t v6 = function_8059148(function_8059a68(*v2)); // 0x80be865
        int32_t v7 = function_8059808(function_80597f8(*v2)); // 0x80be87a
        int32_t v8 = function_8058df8(function_80593d8(*v2)); // 0x80be88f
        add_format_to_string((int32_t *)&result, "%s - %s - %s - %s - %s (compr: %s)", (char *)v8, (char *)v7, (char *)v6, (char *)v5, (char *)v4, (char *)v3);
    }
    // 0x80be8cb
    return result;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/network/ssl/ssl.c
// Address range: 0x80be8e0 - 0x80be919
// Line range:    281 - 293
void done_ssl_connection(int32_t * socket) {
    int32_t * v1 = (int32_t *)((int32_t)socket + 32); // 0x80be8ef
    int32_t v2 = *v1; // 0x80be8ef
    if (v2 != 0) {
        // 0x80be8f6
        function_80593e8(*(int32_t *)v2);
        mem_free((char *)v2);
        *v1 = 0;
    }
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/osdep/osdep.c
// Address range: 0x80bec10 - 0x80bec15
// Line range:    733 - 735
void want_draw(void) {
    // 0x80bec10
    return;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/osdep/osdep.c
// Address range: 0x80bec20 - 0x80bec25
// Line range:    738 - 740
void done_draw(void) {
    // 0x80bec20
    return;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/osdep/osdep.c
// Address range: 0x80bec30 - 0x80bec3a
// Line range:    746 - 749
int32_t get_output_handle(void) {
    // 0x80bec30
    return 1;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/osdep/osdep.c
// Address range: 0x80bec40 - 0x80bec45
// Line range:    789 - 791
void terminate_osdep(void) {
    // 0x80bec40
    return;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/osdep/osdep.c
// Address range: 0x80becd0 - 0x80bece7
// Line range:    915 - 918
char * get_system_str(int32_t xwin) {
    // 0x80becd0
    return (char *)(xwin == 0 ? (int32_t)"unix" : (int32_t)"unix-xwin");
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/osdep/osdep.c
// Address range: 0x80bedc0 - 0x80bee33
// Line range:    297 - 325
int32_t is_xterm(void) {
    int32_t result = g40; // 0x80bedc7
    if (result != -1) {
        // 0x80bedd1
        return result;
    }
    char * env_val = getenv("DISPLAY"); // 0x80beddf
    char * env_val2 = getenv("WINDOWID"); // 0x80beded
    char * env_val3; // 0x80bedc0
    if (env_val2 == NULL) {
        // 0x80bedfb
        env_val3 = getenv("KONSOLE_DCOP_SESSION");
        goto lab_0x80bee07;
    } else {
        // 0x80bedf6
        env_val3 = env_val2;
        if (*env_val2 != 0) {
            goto lab_0x80bee07;
        } else {
            // 0x80bedfb
            env_val3 = getenv("KONSOLE_DCOP_SESSION");
            goto lab_0x80bee07;
        }
    }
  lab_0x80bee07:
    // 0x80bee07
    if (env_val == NULL || env_val3 == NULL) {
        int32_t result2 = 0;
        g40 = result2;
        return result2;
    }
    int32_t result3 = 0; // 0x80bee12
    if (*env_val != 0) {
        // 0x80bee28
        result3 = *env_val3 != 0;
    }
    // 0x80bee16
    g40 = result3;
    return result3;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/osdep/osdep.c
// Address range: 0x80bee40 - 0x80bee73
// Line range:    284 - 291
int32_t is_gnuscreen(void) {
    int32_t result = g41; // 0x80bee46
    if (result != -1) {
        // 0x80bee50
        return result;
    }
    int32_t result2 = getenv("STY") != NULL; // 0x80bee66
    g41 = result2;
    return result2;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/osdep/osdep.c
// Address range: 0x80bee80 - 0x80bf09b
// Line range:    410 - 86
void set_window_title(char * title, int32_t codepage) {
    // 0x80bee80
    if (is_xterm() == 0) {
        // 0x80bee95
        if (is_gnuscreen() == 0) {
            // 0x80befee
            return;
        }
    }
    // 0x80beea6
    int32_t v1; // bp-40, 0x80bee80
    if (init_string(&v1) == 0) {
        // 0x80befee
        return;
    }
    int32_t v2; // 0x80bee80
    int32_t v3; // 0x80bee80
    int32_t v4; // 0x80bee80
    int32_t v5; // 0x80bee80
    char * v6; // bp-32, 0x80bee80
    int32_t v7; // 0x80bee80
    int32_t v8; // 0x80bee80
    int32_t v9; // 0x80bee80
    int32_t v10; // 0x80beeff
    int32_t v11; // 0x80bef16
    char * v12; // 0x80beee9
    if (title != NULL) {
        int32_t v13 = (int32_t)title;
        v6 = title;
        v12 = (char *)(strlen(title) + v13);
        int32_t v14 = cp_to_unicode(codepage, &v6, v12); // 0x80beee9
        v2 = v14;
        v4 = v13;
        if (v14 == -3) {
            // 0x80befbb
            __printf_chk(1, (char *)&g15);
            fflush(g44);
            done_string(&v1);
            // 0x80befee
            return;
        }
        while (true) {
          lab_0x80beefa:
            // 0x80beefa
            v8 = v7;
            int32_t v15 = v4;
            int32_t v16 = v2; // 0x80beee9
            int32_t v17 = (int32_t)v6;
            v5 = v17;
            v9 = v8;
            while (v16 >= 32 && v16 >= 160) {
                // 0x80bef13
                v3 = v15;
                v10 = v17 - v3;
                v11 = v10 + v8;
                if (v11 > 596) {
                    // 0x80befa8
                    add_to_string(&v1, (int32_t)"...");
                    goto lab_0x80befbb_2;
                }
                int32_t v18 = v17; // 0x80bef2a
                if (assert_failed == 0) {
                    if (v3 != 0 && v10 >= 0) {
                        // 0x80bef40
                        assert_failed = 0;
                        goto lab_0x80bef4a;
                    }
                    // 0x80beff8
                    assert_failed = 1;
                    errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
                    errline = 255;
                    elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
                    if (assert_failed == 0) {
                        goto lab_0x80bef4a;
                    }
                    // 0x80bf030
                    v18 = (int32_t)v6;
                }
                // 0x80bf038
                v15 = v18;
                assert_failed = 0;
                v16 = cp_to_unicode(codepage, &v6, v12);
                if (v16 == -3) {
                    // break (via goto) -> 0x80befbb
                    goto lab_0x80befbb_2;
                }
                v17 = (int32_t)v6;
                v5 = v17;
                v9 = v8;
            }
            goto lab_0x80bef9b;
        }
    }
  lab_0x80befbb_2:
    // 0x80befbb
    __printf_chk(1, (char *)&g15);
    fflush(g44);
    done_string(&v1);
  lab_0x80bef4a:;
    int32_t v19 = v8; // 0x80bef4c
    if (v10 == 0) {
        goto lab_0x80bef98;
    } else {
        uint32_t v20 = v8 + 255 & -256; // 0x80bef5f
        uint32_t v21 = v11 + 256 & -256; // 0x80bef61
        if (v21 > v20) {
            char * v22 = mem_realloc((char *)v1, v21); // 0x80bf060
            v19 = v8;
            if (v22 == NULL) {
                goto lab_0x80bef98;
            } else {
                int32_t v23 = (int32_t)v22; // 0x80bf060
                v1 = v23;
                memset(&((struct _IO_FILE *)(v20 + v23))->e0, 0, v21 - v20);
                goto lab_0x80bef6e;
            }
        } else {
            goto lab_0x80bef6e;
        }
    }
  lab_0x80bef9b:;
    int32_t v24 = cp_to_unicode(codepage, &v6, v12); // 0x80beee9
    v2 = v24;
    v4 = v5;
    v7 = v9;
    if (v24 == -3) {
        // break -> 0x80befbb
        goto lab_0x80befbb_2;
    }
    goto lab_0x80beefa;
  lab_0x80bef98:
    // 0x80bef98
    v5 = (int32_t)v6;
    v9 = v19;
    goto lab_0x80bef9b;
  lab_0x80bef6e:;
    int32_t v25 = v1; // 0x80bef6e
    v19 = v8;
    if (v25 == 0) {
        goto lab_0x80bef98;
    } else {
        // 0x80bef75
        memcpy(&((struct _IO_FILE *)(v25 + v8))->e0, (int32_t *)v3, v10);
        *(char *)(v1 + v11) = 0;
        v19 = v11;
        goto lab_0x80bef98;
    }
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/osdep/osdep.c
// Address range: 0x80bf200 - 0x80bf22c
// Line range:    203 - 206
void unhandle_terminal_resize(int32_t fd) {
    // 0x80bf200
    install_signal_handler(28, NULL, NULL, 0);
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/osdep/signals.c
// Address range: 0x80bf5d0 - 0x80bf624
// Line range:    350 - 367
int32_t check_signals(void) {
    int32_t result = 0; // 0x80bf5dc
    for (int32_t i = 0; i < 497; i += 16) {
        int32_t * v1 = (int32_t *)(i + (int32_t)&g74); // 0x80bf5e0
        int32_t v2 = result; // 0x80bf5e8
        if (*v1 != 0) {
            // 0x80bf5ea
            *v1 = 0;
            check_bottom_halves();
            v2 = 1;
        }
        // 0x80bf613
        result = v2;
    }
    // 0x80bf61e
    return result;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/osdep/signals.c
// Address range: 0x80bf660 - 0x80bf67e
// Line range:    314 - 320
void uninstall_alarm(void) {
    // 0x80bf660
    pending_alarm = 0;
    alarm(0);
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/osdep/signals.c
// Address range: 0x80bf820 - 0x80bf837
// Line range:    344 - 347
void clear_signal_mask_and_handlers(void) {
    // 0x80bf820
    __asm_rep_stosd_memset((char *)&signal_info, 0, 128);
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/osdep/signals.c
// Address range: 0x80bf840 - 0x80bf980
// Line range:    251 - 279
void install_signal_handler(uint32_t sig, void (*fn)(char *), char * data, int32_t critical) {
    // 0x80bf840
    if (assert_failed != 0) {
        // 0x80bf922
        assert_failed = 0;
        // 0x80bf8dc
        return;
    }
    // 0x80bf863
    assert_failed = sig >= 32;
    if (sig >= 32) {
        // 0x80bf8f0
        errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/osdep/signals.c";
        errline = 261;
        elinks_internal("assertion sig >= 0 && sig < NUM_SIGNALS failed: bad signal number: %d", sig);
        if (assert_failed != 0) {
            // 0x80bf922
            assert_failed = 0;
            // 0x80bf8dc
            return;
        }
    }
    // 0x80bf874
    int32_t act; // bp-168, 0x80bf840
    __asm_rep_stosd_memset((char *)&act, 0, 35);
    int32_t set; // bp-164, 0x80bf840
    if (fn == NULL) {
        // 0x80bf930
        act = 1;
        sigfillset((struct _TYPEDEF_sigset_t *)&set);
        int32_t v1 = 16 * sig; // 0x80bf94b
        sigaction(sig, (struct sigaction *)&act, NULL);
        *(int32_t *)(v1 + (int32_t)&signal_info) = 0;
        *(int32_t *)(v1 + (int32_t)&g72) = (int32_t)data;
        *(int32_t *)(v1 + (int32_t)&g73) = critical;
    } else {
        // 0x80bf890
        act = 0x80bfa30;
        sigfillset((struct _TYPEDEF_sigset_t *)&set);
        int32_t v2 = 16 * sig; // 0x80bf8ad
        *(int32_t *)(v2 + (int32_t)&signal_info) = (int32_t)fn;
        *(int32_t *)(v2 + (int32_t)&g72) = (int32_t)data;
        *(int32_t *)(v2 + (int32_t)&g73) = critical;
        sigaction(sig, (struct sigaction *)&act, NULL);
    }
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/osdep/signals.c
// Address range: 0x80bfaa0 - 0x80bfba4
// Line range:    158 - 179
void unhandle_terminal_signals(int32_t * term) {
    // 0x80bfaa0
    install_signal_handler(1, NULL, NULL, 0);
    install_signal_handler(2, NULL, NULL, 0);
    install_signal_handler(20, NULL, NULL, 0);
    install_signal_handler(21, NULL, NULL, 0);
    install_signal_handler(22, NULL, NULL, 0);
    install_signal_handler(18, NULL, NULL, 0);
    install_signal_handler(11, NULL, NULL, 0);
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/osdep/unix/unix.c
// Address range: 0x80c00a0 - 0x80c00f6
// Line range:    122 - 131
void unhandle_mouse(char * h) {
    if (h == NULL) {
        // 0x80c00f0
        return;
    }
    // 0x80c00ae
    set_handlers(*(int32_t *)h, NULL, NULL, NULL, NULL);
    mem_free(h);
    function_8059678();
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/protocol/date.c
// Address range: 0x80c0ea0 - 0x80c0f15
// Line range:    91 - 104
int32_t parse_day(char ** date_p, char * end) {
    char * v1 = *date_p; // 0x80c0eb7
    if (end != NULL && v1 >= end) {
        // 0x80c0ee9
        return 32;
    }
    unsigned char v2 = *v1; // 0x80c0ebd
    if (v2 >= 58) {
        // 0x80c0ee9
        return 32;
    }
    int32_t v3 = (int32_t)v1; // 0x80c0eb7
    uint32_t v4 = v3 + 1; // 0x80c0ecd
    int32_t result = (int32_t)v2 - 48; // 0x80c0ed0
    if (end != NULL && v4 >= (int32_t)end) {
        // 0x80c0edb
        *(int32_t *)date_p = v4;
        // 0x80c0ee9
        return result;
    }
    unsigned char v5 = *(char *)v4; // 0x80c0ef8
    if (v5 < 58) {
        // 0x80c0f04
        *(int32_t *)date_p = v3 + 2;
        // 0x80c0ee9
        return 10 * result - 48 + (int32_t)v5;
    }
    // 0x80c0edb
    *(int32_t *)date_p = v4;
    // 0x80c0ee9
    return result;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/protocol/date.c
// Address range: 0x80c0f20 - 0x80c10ef
// Line range:    109 - 156
int32_t parse_time(char ** time2, struct tm * tm, char * end) {
    uint32_t v1 = (int32_t)end;
    char * v2 = *time2; // 0x80c0f37
    int32_t v3 = (int32_t)v2; // 0x80c0f37
    int32_t v4 = v3 + 5; // 0x80c0f3b
    if (end != NULL == v4 > v1) {
        // 0x80c0f6a
        return false;
    }
    unsigned char v5 = *v2; // 0x80c0f42
    if (v5 >= 58) {
        // 0x80c0f6a
        return false;
    }
    unsigned char v6 = *(char *)(v3 + 1); // 0x80c0f4f
    if (v6 >= 58 || *(char *)(v3 + 2) != 58) {
        // 0x80c0f6a
        return false;
    }
    unsigned char v7 = *(char *)(v3 + 3); // 0x80c0f78
    if (v7 >= 58) {
        // 0x80c0f6a
        return false;
    }
    unsigned char v8 = *(char *)(v3 + 4); // 0x80c0f84
    if (v8 >= 58) {
        // 0x80c0f6a
        return false;
    }
    int32_t v9 = 10 * (int32_t)v5 - 528 + (int32_t)v6; // 0x80c0fa5
    int32_t v10 = (int32_t)tm; // 0x80c0fac
    int32_t * v11 = (int32_t *)(v10 + 8); // 0x80c0fba
    *v11 = v9;
    int32_t * v12 = (int32_t *)(v10 + 4); // 0x80c0fce
    *v12 = 10 * (int32_t)v7 - 528 + (int32_t)v8;
    tm->e0 = 0;
    int32_t v13 = v3 + 7; // 0x80c0fd9
    bool result; // 0x80c0f20
    if (end != NULL && v13 >= v1) {
        // 0x80c0fe0
        *(int32_t *)time2 = v4;
        if (*v11 > 23) {
            // 0x80c0f6a
            return false;
        }
        // 0x80c0ff2
        result = false;
        if (*v12 <= 59) {
            int32_t v14 = tm->e0; // 0x80c0ffe
            int32_t v15 = v14 - 59; // 0x80c0ffe
            result = v15 == 0 | v15 < 0 != (58 - v14 & v14) < 0;
        }
        // 0x80c0f6a
        return result;
    }
    char * v16 = (char *)v4; // 0x80c1010
    char v17 = *v16; // 0x80c1010
    int32_t v18; // 0x80c0f20
    switch (v17) {
        case 58: {
            int32_t v19 = v3 + 8; // 0x80c1084
            if (end != NULL && v19 >= v1) {
                // 0x80c0f6a
                return false;
            }
            unsigned char v20 = *(char *)(v3 + 6); // 0x80c108f
            if (v20 >= 58) {
                // 0x80c0f6a
                return false;
            }
            unsigned char v21 = *(char *)v13; // 0x80c109e
            if (v21 >= 58) {
                // 0x80c0f6a
                return false;
            }
            // 0x80c10b0
            tm->e0 = 10 * (int32_t)v20 - 528 + (int32_t)v21;
            v18 = v19;
            goto lab_0x80c104b;
        }
        case 80: {
            goto lab_0x80c1023;
        }
        default: {
            // 0x80c101e
            v18 = v4;
            if (v17 != 65) {
                goto lab_0x80c104b;
            } else {
                goto lab_0x80c1023;
            }
        }
    }
  lab_0x80c1023:;
    char v22 = v17; // 0x80c1027
    if (v9 == 12) {
        // 0x80c10dc
        *v11 = 0;
        v22 = *v16;
    }
    // 0x80c102d
    if (v22 == 80) {
        // 0x80c10d0
        *v11 = *v11 + 12;
    }
    // 0x80c103c
    v18 = v13;
    if (*(char *)(v3 + 6) != 77) {
        // 0x80c0f6a
        return false;
    }
    goto lab_0x80c104b;
  lab_0x80c104b:
    // 0x80c104b
    *(int32_t *)time2 = v18;
    if (*v11 > 23) {
        // 0x80c0f6a
        return false;
    }
    // 0x80c1060
    result = false;
    if (*v12 <= 59) {
        int32_t v23 = tm->e0; // 0x80c106c
        int32_t v24 = v23 - 59; // 0x80c106c
        result = v24 == 0 | v24 < 0 != (58 - v23 & v23) < 0;
    }
    // 0x80c0f6a
    return result;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/protocol/protocol.c
// Address range: 0x80c1d10 - 0x80c1d92
// Line range:    188 - 193
int32_t get_protocol_free_syntax(uint32_t protocol) {
    // 0x80c1d10
    if (assert_failed != 0) {
        // 0x80c1d80
        assert_failed = 0;
        return 0;
    }
    // 0x80c1d24
    assert_failed = protocol >= 21;
    unsigned char v1; // 0x80c1d38
    if (protocol < 21) {
        // 0x80c1d35
        v1 = *(char *)(16 * protocol + (int32_t)&g10);
        return v1 / 4 % 2;
    }
    // 0x80c1d50
    errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/protocol/protocol.c";
    errline = 190;
    elinks_internal("assertion VALID_PROTOCOL(protocol) failed!");
    if (assert_failed == 0) {
        // 0x80c1d35
        v1 = *(char *)(16 * protocol + (int32_t)&g10);
        return v1 / 4 % 2;
    }
    // 0x80c1d80
    assert_failed = 0;
    return 0;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/protocol/protocol.c
// Address range: 0x80c1e30 - 0x80c1eb2
// Line range:    172 - 177
int32_t get_protocol_need_slash_after_host(uint32_t protocol) {
    // 0x80c1e30
    if (assert_failed != 0) {
        // 0x80c1ea0
        assert_failed = 0;
        return 0;
    }
    // 0x80c1e43
    assert_failed = protocol >= 21;
    unsigned char v1; // 0x80c1e57
    if (protocol < 21) {
        // 0x80c1e54
        v1 = *(char *)(16 * protocol + (int32_t)&g10);
        return v1 / 2 % 2;
    }
    // 0x80c1e70
    errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/protocol/protocol.c";
    errline = 174;
    elinks_internal("assertion VALID_PROTOCOL(protocol) failed!");
    if (assert_failed == 0) {
        // 0x80c1e54
        v1 = *(char *)(16 * protocol + (int32_t)&g10);
        return v1 / 2 % 2;
    }
    // 0x80c1ea0
    assert_failed = 0;
    return 0;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/protocol/protocol.c
// Address range: 0x80c1ec0 - 0x80c1f3a
// Line range:    164 - 169
int32_t get_protocol_need_slashes(uint32_t protocol) {
    // 0x80c1ec0
    if (assert_failed != 0) {
        // 0x80c1f28
        assert_failed = 0;
        return 0;
    }
    // 0x80c1ed4
    assert_failed = protocol >= 21;
    unsigned char v1; // 0x80c1ee8
    if (protocol < 21) {
        // 0x80c1ee5
        v1 = *(char *)(16 * protocol + (int32_t)&g10);
        return v1 % 2;
    }
    // 0x80c1ef8
    errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/protocol/protocol.c";
    errline = 166;
    elinks_internal("assertion VALID_PROTOCOL(protocol) failed!");
    if (assert_failed == 0) {
        // 0x80c1ee5
        v1 = *(char *)(16 * protocol + (int32_t)&g10);
        return v1 % 2;
    }
    // 0x80c1f28
    assert_failed = 0;
    return 0;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/protocol/protocol.c
// Address range: 0x80c1f40 - 0x80c1fff
// Line range:    152 - 155
int32_t get_protocol_port(uint32_t protocol) {
    // 0x80c1f40
    if (assert_failed != 0) {
        // 0x80c1fb8
        assert_failed = 0;
        return 0;
    }
    // 0x80c1f54
    assert_failed = protocol >= 21;
    if (protocol >= 21) {
        // 0x80c1fd0
        errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/protocol/protocol.c";
        errline = 154;
        elinks_internal("assertion VALID_PROTOCOL(protocol) failed!");
        if (assert_failed != 0) {
            // 0x80c1fb8
            assert_failed = 0;
            return 0;
        }
    }
    uint32_t result = *(int32_t *)(16 * protocol + (int32_t)&g9); // 0x80c1f6a
    assert_failed = result >= 0x10000;
    if (result < 0x10000) {
        // 0x80c1f82
        return result;
    }
    // 0x80c1f88
    errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/protocol/protocol.c";
    errline = 157;
    elinks_internal("assertion uri_port_is_valid(protocol_backends[protocol].port) failed!");
    if (assert_failed == 0) {
        // 0x80c1f82
        return result;
    }
    // 0x80c1fb8
    assert_failed = 0;
    return 0;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/protocol/protocol.c
// Address range: 0x80c20c0 - 0x80c2188
// Line range:    95 - 132
int32_t get_protocol(char * name, int32_t namelen) {
    // 0x80c20c0
    if (assert_failed == 0) {
        // 0x80c20d3
        assert_failed = 0;
    }
    int32_t v1 = 0; // 0x80c20ee
    int32_t v2 = 17; // 0x80c20ee
    int32_t v3 = 9; // 0x80c20ee
    int32_t v4 = *(int32_t *)(16 * v3 + (int32_t)&protocol_backends); // 0x80c20f5
    char * str = (char *)v4; // 0x80c20fe
    int32_t len = strlen(str); // 0x80c2101
    int32_t v5 = len - namelen; // 0x80c2109
    int32_t v6 = v5 == 0 | v5 < 0 != ((v5 ^ len) & (len ^ namelen)) < 0 ? len : namelen; // 0x80c2111
    int32_t v7 = c_strncasecmp(str, name, v6); // 0x80c211f
    int32_t result = v3; // 0x80c212a
    while ((v7 || v5) != 0) {
        int32_t v8 = v7 != 0 ? v7 : v5;
        v1 = v8 < 0 != (((v5 ^ len) & (len ^ namelen)) < 0 == v7 == 0) ? v3 + 1 : v1;
        v2 = v8 < 0 != (((v5 ^ len) & (len ^ namelen)) < 0 == v7 == 0) ? v2 : v3 - 1;
        if (v1 > v2) {
            // 0x80c2150
            result = (int32_t)(get_user_program(NULL, name, namelen) == NULL) + 19;
            return result;
        }
        int32_t v9 = v2 + v1; // 0x80c213e
        v3 = v9 + (int32_t)(v9 < 0) >> 1;
        v4 = *(int32_t *)(16 * v3 + (int32_t)&protocol_backends);
        str = (char *)v4;
        len = strlen(str);
        v5 = len - namelen;
        v6 = v5 == 0 | v5 < 0 != ((v5 ^ len) & (len ^ namelen)) < 0 ? len : namelen;
        v7 = c_strncasecmp(str, name, v6);
        result = v3;
    }
  lab_0x80c2172:
    // 0x80c2172
    return result;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/protocol/proxy.c
// Address range: 0x80c22b0 - 0x80c22ed
// Line range:    209 - 215
int32_t * get_proxied_uri(int32_t * uri) {
    int32_t v1 = (int32_t)uri;
    if (*(int32_t *)(v1 + 4) == 15) {
        // 0x80c22d8
        return get_uri((char *)*(int32_t *)(v1 + 28), -0x7d41);
    }
    // 0x80c22bf
    return get_composed_uri(uri, -0x7d41);
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/protocol/proxy.c
// Address range: 0x80c22f0 - 0x80c23bc
// Line range:    84 - 87
char * strip_proxy_protocol(char * proxy, char * strip1, char * strip2) {
    // 0x80c22f0
    int32_t v1; // 0x80c22f0
    int32_t v2 = v1;
    if (assert_failed == 0) {
        if (v2 != 0 == ((char)v2 != 0)) {
            // 0x80c23b0
            assert_failed = 0;
        } else {
            // 0x80c231b
            assert_failed = 1;
            errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/protocol/proxy.c";
            errline = 87;
            elinks_internal("assertion proxy && *proxy failed!");
        }
    }
    char * str = (char *)v1; // 0x80c2345
    int32_t len = strlen(str); // 0x80c2348
    char * v3 = (char *)v2; // 0x80c2351
    if (c_strncasecmp(v3, str, len) == 0) {
        // 0x80c238b
        return (char *)(strlen(str) + v2);
    }
    int32_t v4; // 0x80c22f0
    if (v1 == 0) {
        // 0x80c238b
        return (char *)v4;
    }
    char * str2 = (char *)v1; // 0x80c2365
    int32_t len2 = strlen(str2); // 0x80c2368
    if (c_strncasecmp(v3, str2, len2) == 0) {
        // 0x80c2381
        v4 = strlen(str2) + v2;
    }
    // 0x80c238b
    return (char *)v4;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/protocol/proxy.c
// Address range: 0x80c23c0 - 0x80c2442
// Line range:    102 - 109
char * get_protocol_proxy(char * opt, char * env1, char * env2, char * strip1, char * strip2) {
    // 0x80c23c0
    int32_t name; // 0x80c23c0
    int32_t v1 = *(int32_t *)get_opt_((int32_t)config_options, (char *)name); // 0x80c23ed
    int32_t env_val = v1; // 0x80c23f2
    if (*(char *)v1 == 0) {
        // 0x80c2438
        env_val = (int32_t)getenv((char *)name);
    }
    // 0x80c23f4
    if (env_val != 0) {
        // 0x80c23f8
        if (*(char *)env_val != 0) {
            // 0x80c2420
            return strip_proxy_protocol((char *)&g83, (char *)&g83, (char *)&g83);
        }
    }
    char * env_val2 = getenv((char *)name); // 0x80c2400
    if (env_val2 == NULL) {
        // 0x80c240e
        return env_val2;
    }
    // 0x80c2409
    if (*env_val2 != 0) {
        // 0x80c2420
        return strip_proxy_protocol((char *)&g83, (char *)&g83, (char *)&g83);
    }
    // 0x80c240e
    return env_val2;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/protocol/proxy.c
// Address range: 0x80c2450 - 0x80c2569
// Line range:    57 - 132
int32_t * proxy_uri(int32_t * uri, char * proxy, int32_t * error_state) {
    // 0x80c2450
    char * v1; // bp-36, 0x80c2450
    int32_t v2; // 0x80c2450
    if (init_string((int32_t *)&v1) != 0) {
        // 0x80c2475
        if (string_concat((int32_t *)&v1) != NULL) {
            // 0x80c249d
            if (add_uri_to_string((int32_t *)&v1, (int32_t *)v2, -0x7d41) != NULL) {
                int32_t * v3 = get_uri(v1, 0); // 0x80c24c3
                if (v3 == NULL) {
                    int32_t v4 = assert_failed; // 0x80c2518
                    assert_failed = 0;
                    *(int32_t *)v2 = v4 == 0 ? -0x1895c : -0x186a3;
                    *(int32_t *)(v2 + 4) = 0;
                }
                // 0x80c24ce
                done_string((int32_t *)&v1);
                return (int32_t *)(int32_t)v3;
            }
        }
    }
    int32_t v5 = assert_failed; // 0x80c24e8
    assert_failed = 0;
    *(int32_t *)v2 = v5 != 0 ? -0x186a3 : -0x186a4;
    *(int32_t *)(v2 + 4) = 0;
    // 0x80c24ce
    done_string((int32_t *)&v1);
    return (int32_t *)0;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/protocol/proxy.c
// Address range: 0x80c2570 - 0x80c2841
// Line range:    187 - 176
int32_t * get_proxy_uri(int32_t * uri, int32_t * error_state) {
    int32_t v1 = (int32_t)uri;
    int32_t * v2 = (int32_t *)(v1 + 4); // 0x80c257c
    if (*v2 == 15) {
        // 0x80c25e1
        return get_composed_uri(uri, -0x7d41);
    }
    int32_t v3 = g42; // 0x80c2595
    if (g42 == -1) {
        // 0x80c2770
        v3 = get_event_id("get-proxy");
        g42 = v3;
    }
    // 0x80c259b
    trigger_event(v3);
    int32_t v4 = *v2; // 0x80c2610
    char * str; // 0x80c2570
    switch (v4) {
        case 9: {
            char * v5 = get_protocol_proxy("http://", NULL, (char *)&g83, (char *)&g83, (char *)&g83); // 0x80c2801
            str = v5;
            // break -> 0x80c2651
            break;
        }
        case 10: {
            char * v6 = get_protocol_proxy("http://", NULL, (char *)&g83, (char *)&g83, (char *)&g83); // 0x80c27d6
            str = v6;
            // break -> 0x80c2651
            break;
        }
        default: {
            if (v4 != 7) {
                // 0x80c25e1
                return get_composed_uri(uri, -0x7d41);
            }
            char * v7 = get_protocol_proxy("ftp://", "http://", (char *)&g83, (char *)&g83, (char *)&g83); // 0x80c2649
            str = v7;
            // break -> 0x80c2651
            break;
        }
    }
    // 0x80c2651
    if (str == NULL || *str == 0) {
        // 0x80c25e1
        return get_composed_uri(uri, -0x7d41);
    }
    char * found_char_pos = strchr(str, 47); // 0x80c2673
    if (found_char_pos != NULL) {
        // 0x80c267c
        *found_char_pos = 0;
    }
    int32_t v8 = *(int32_t *)get_opt_((int32_t)config_options, "protocol.no_proxy"); // 0x80c2694
    int32_t env_val = v8; // 0x80c2699
    if (*(char *)v8 == 0) {
        // 0x80c282e
        env_val = (int32_t)getenv("NO_PROXY");
    }
    // 0x80c269f
    int32_t env_val2; // 0x80c2570
    if (env_val == 0) {
        // 0x80c26a8
        env_val2 = (int32_t)getenv("no_proxy");
        goto lab_0x80c26b6;
    } else {
        // 0x80c26a3
        env_val2 = env_val;
        if (*(char *)env_val != 0) {
            goto lab_0x80c26b6;
        } else {
            // 0x80c26a8
            env_val2 = (int32_t)getenv("no_proxy");
            goto lab_0x80c26b6;
        }
    }
  lab_0x80c26b6:;
    char * str2 = (char *)*(int32_t *)(v1 + 20); // 0x80c26c7
    char * found_char_pos2 = strchr(str2, 47); // 0x80c26c7
    if (found_char_pos2 != NULL) {
        // 0x80c26d3
        *found_char_pos2 = 0;
    }
    if (env_val2 != 0) {
        char v9 = *(char *)env_val2; // 0x80c26da
        if (v9 != 0) {
            int16_t ** v10 = __ctype_b_loc(); // 0x80c26e4
            char * found_char_pos3 = strchr((char *)env_val2, 44); // 0x80c2703
            int32_t v11 = (int32_t)*v10 + 1; // 0x80c2721
            int32_t v12 = env_val2; // 0x80c2726
            int32_t v13; // 0x80c2570
            int32_t v14; // 0x80c2718
            if ((*(char *)(v11 + 2 * (int32_t)v9) & 32) != 0) {
                v14 = env_val2 + 1;
                v13 = v14;
                v12 = v14;
                while ((*(char *)(2 * (int32_t)*(char *)v14 + v11) & 32) != 0) {
                    // 0x80c2718
                    v14 = v13 + 1;
                    v13 = v14;
                    v12 = v14;
                }
            }
            // 0x80c2728
            if (found_char_pos3 != NULL) {
                // 0x80c272c
                *found_char_pos3 = 0;
            }
            while (c_strcasestr(str2, (char *)v12) == NULL) {
                if (found_char_pos3 == NULL) {
                    goto lab_0x80c274d_3;
                }
                int32_t str3 = (int32_t)found_char_pos3 + 1; // 0x80c27a2
                *found_char_pos3 = 44;
                if (str3 == 0) {
                    goto lab_0x80c274d_3;
                }
                char v15 = *(char *)str3; // 0x80c27aa
                if (v15 == 0) {
                    goto lab_0x80c274d_3;
                }
                found_char_pos3 = strchr((char *)str3, 44);
                v11 = (int32_t)*v10 + 1;
                v13 = str3;
                v12 = str3;
                if ((*(char *)(v11 + 2 * (int32_t)v15) & 32) != 0) {
                    v14 = v13 + 1;
                    v13 = v14;
                    v12 = v14;
                    while ((*(char *)(2 * (int32_t)*(char *)v14 + v11) & 32) != 0) {
                        // 0x80c2718
                        v14 = v13 + 1;
                        v13 = v14;
                        v12 = v14;
                    }
                }
                // 0x80c2728
                if (found_char_pos3 != NULL) {
                    // 0x80c272c
                    *found_char_pos3 = 0;
                }
            }
            if (found_char_pos3 != NULL) {
                // 0x80c2815
                *found_char_pos3 = 44;
            }
            if (found_char_pos2 != NULL) {
                // 0x80c2823
                *found_char_pos2 = 47;
            }
            // 0x80c25e1
            return get_composed_uri(uri, -0x7d41);
        }
    }
  lab_0x80c274d_3:
    if (found_char_pos2 != NULL) {
        // 0x80c2754
        *found_char_pos2 = 47;
    }
    // 0x80c25e1
    return proxy_uri(&g83, (char *)&g83, &g83);
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c
// Address range: 0x80c2990 - 0x80c2ab3
// Line range:    1606 - 1613
void done_uri(int32_t * uri) {
    char * str = (char *)*uri; // 0x80c29a0
    int32_t len = strlen(str); // 0x80c29a0
    if (assert_failed == 0) {
        // 0x80c29af
        assert_failed = g75 == 0;
        if (g75 == 0) {
            // 0x80c2a88
            errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
            errline = 1613;
            elinks_internal("assertion is_object_used(&uri_cache) failed!");
        }
    }
    int32_t * v1 = (int32_t *)((int32_t)uri + 56); // 0x80c29ca
    int32_t v2 = *v1 - 1; // 0x80c29cd
    *v1 = v2;
    if (v2 != 0) {
        // 0x80c29d7
        return;
    }
    int32_t * v3 = get_hash_item((int32_t *)uri_cache, str, len); // 0x80c29f2
    int32_t v4 = 0; // 0x80c29f9
    if (v3 != NULL) {
        // 0x80c29fb
        v4 = *(int32_t *)((int32_t)v3 + 16);
    }
    // 0x80c29fe
    if (assert_failed == 0) {
        // 0x80c2a08
        assert_failed = v4 == 0;
        if (v4 == 0) {
            // 0x80c2a19
            errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
            errline = 1621;
            elinks_internal("assertion entry != NULL failed: Releasing unknown URI [%s]", str);
        }
    }
    // 0x80c2a48
    del_hash_item((int32_t *)uri_cache, v3);
    mem_free((char *)v4);
    int32_t v5 = g75 - 1; // 0x80c2a66
    g75 = v5;
    if (v5 != 0) {
        // 0x80c29d7
        return;
    }
    // 0x80c2a76
    free_hash((int32_t **)&uri_cache);
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c
// Address range: 0x80c2ac0 - 0x80c2b19
// Line range:    1488 - 1501
void free_uri_list(int32_t * list) {
    int32_t * v1 = (int32_t *)((int32_t)list + 4); // 0x80c2acb
    int32_t v2 = *v1; // 0x80c2acb
    if (v2 == 0) {
        // 0x80c2b12
        return;
    }
    int32_t v3 = *list; // 0x80c2ad2
    int32_t v4 = 0; // 0x80c2ad6
    if (v3 < 1) {
        // 0x80c2afd
        mem_free((char *)v2);
        // 0x80c2b05
        *v1 = 0;
        *list = 0;
        // 0x80c2b12
        return;
    }
    int32_t v5 = *(int32_t *)(4 * v4 + v2); // 0x80c2ae0
    int32_t v6 = v3; // 0x80c2ae5
    int32_t v7 = v2; // 0x80c2ae5
    if (v5 != 0) {
        // 0x80c2ae7
        done_uri((int32_t *)v5);
        v7 = *v1;
        v6 = *list;
    }
    int32_t v8 = v7;
    v4++;
    while (v6 > v4) {
        // 0x80c2ae0
        v5 = *(int32_t *)(4 * v4 + v8);
        v7 = v8;
        if (v5 != 0) {
            // 0x80c2ae7
            done_uri((int32_t *)v5);
            v7 = *v1;
            v6 = *list;
        }
        // 0x80c2af2
        v8 = v7;
        v4++;
    }
    // 0x80c2af9
    if (v8 == 0) {
        // 0x80c2b05
        *v1 = 0;
        *list = 0;
        // 0x80c2b12
        return;
    }
    // 0x80c2afd
    mem_free((char *)v8);
    // 0x80c2b05
    *v1 = 0;
    *list = 0;
}

// Address range: 0x80c2b20 - 0x80c2b97
int32_t mem_align_alloc__(int32_t a1, int32_t a2) {
    int32_t result = -1 - a2;
    int32_t v1; // 0x80c2b20
    uint32_t v2 = v1 + a2 & result; // 0x80c2b40
    uint32_t v3 = v1 + a2 & result; // 0x80c2b42
    if (v2 <= v3) {
        // 0x80c2b4a
        return result;
    }
    int32_t v4 = v2 * a1; // 0x80c2b58
    char * v5 = mem_realloc((char *)result, v4); // 0x80c2b67
    int32_t set_mem = 0; // 0x80c2b75
    if (v5 != NULL) {
        int32_t v6 = (int32_t)v5; // 0x80c2b67
        int32_t v7 = v3 * a1; // 0x80c2b77
        *(int32_t *)v1 = v6;
        set_mem = (int32_t)memset((int32_t *)(v7 + v6), 0, v4 - v7);
    }
    // 0x80c2b4a
    return set_mem;
}

// Address range: 0x80c2ba0 - 0x80c2c95
int32_t add_bytes_to_string__2(void) {
    // 0x80c2ba0
    if (assert_failed != 0) {
        // 0x80c2bbf
        assert_failed = 0;
        // 0x80c2bd0
        return 0;
    }
    int32_t v1; // 0x80c2ba0
    if (v1 < 0 || v1 == 0 || v1 == 0) {
        // 0x80c2be8
        assert_failed = 1;
        errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
        errline = 255;
        elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
        if (assert_failed != 0) {
            // 0x80c2bbf
            assert_failed = 0;
            // 0x80c2bd0
            return 0;
        }
    } else {
        // 0x80c2c80
        assert_failed = 0;
    }
    if (v1 == 0) {
        // 0x80c2bd0
        int32_t result; // 0x80c2ba0
        return result;
    }
    int32_t * v2 = (int32_t *)(v1 + 4); // 0x80c2c1f
    int32_t v3 = mem_align_alloc__(1, 255); // 0x80c2c3e
    if (v3 != 0) {
        int32_t v4 = *v2 + v1; // 0x80c2c31
        int32_t * dest_mem = memcpy(&((struct _IO_FILE *)(*v2 + v3))->e0, (int32_t *)v1, v1); // 0x80c2c57
        *(char *)(v4 + (int32_t)dest_mem) = 0;
        *v2 = v4;
    }
    // 0x80c2bd0
    return 0;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c
// Address range: 0x80c3140 - 0x80c319f
// Line range:    445 - 452
int32_t compare_component(char * a, int32_t alen, char * b, int32_t blen) {
    // 0x80c3140
    int32_t v1; // 0x80c3140
    if (v1 != (int32_t)a || v1 != 0 != v1 != 0) {
        // 0x80c315a
        return 0;
    }
    // 0x80c317e
    if (v1 == 0 || v1 == 0) {
        // 0x80c315a
        return 1;
    }
    // 0x80c3186
    bool v2; // 0x80c3140
    int32_t v3 = v2 ? -1 : 1;
    int32_t result = 1; // 0x80c318c
    int32_t v4; // 0x80c3140
    while (v4 != 0) {
        // 0x80c3186
        int32_t v5; // 0x80c3140
        int32_t v6 = v5;
        int32_t v7; // 0x80c3140
        char v8 = *(char *)v7; // 0x80c318c
        result = 0;
        v4--;
        v5 = v6 + v3;
        v7 += v3;
        if (*(char *)v6 != v8) {
            // break -> 0x80c315a
            break;
        }
        result = 1;
    }
    // 0x80c315a
    return result;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c
// Address range: 0x80c31a0 - 0x80c33d3
// Line range:    461 - 470
int32_t compare_uri(int32_t * a, int32_t * b, uint32_t components) {
    // 0x80c31a0
    if (a == b) {
        // 0x80c329a
        return 1;
    }
    // 0x80c31c0
    if (components == 0) {
        // 0x80c329a
        return 0;
    }
    // 0x80c31c8
    if (assert_failed == 0) {
        // 0x80c31d1
        assert_failed = (components & 0x7840) != 0;
        if ((components & 0x7840) != 0) {
            // 0x80c32b8
            errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
            errline = 468;
            elinks_internal("assertion can_compare_uri_components(components) failed: compare_uri() is a work in progress. Component unsupported");
        }
    }
    int32_t v1 = (int32_t)b;
    int32_t v2 = (int32_t)a;
    if (components % 2 != 0) {
        // 0x80c32a8
        if (*(int32_t *)(v2 + 4) != *(int32_t *)(v1 + 4)) {
            // 0x80c329a
            return 0;
        }
    }
    if ((components & 2) != 0) {
        // 0x80c3288
        if (*(int32_t *)(v2 + 8) != *(int32_t *)(v1 + 8)) {
            // 0x80c329a
            return 0;
        }
    }
    if ((components & 4) != 0) {
        uint16_t v3 = *(int16_t *)(v1 + 42); // 0x80c32e0
        int32_t v4 = compare_component((char *)(int32_t)v3, (int32_t)&g83, (char *)&g83, (int32_t)&g83); // 0x80c32f1
        if (v4 == 0) {
            // 0x80c329a
            return 0;
        }
    }
    if ((components & 8) != 0) {
        uint16_t v5 = *(int16_t *)(v1 + 44); // 0x80c3310
        int32_t v6 = compare_component((char *)(int32_t)v5, (int32_t)&g83, (char *)&g83, (int32_t)&g83); // 0x80c3321
        if (v6 == 0) {
            // 0x80c329a
            return 0;
        }
    }
    if ((components & 16) != 0) {
        uint16_t v7 = *(int16_t *)(v1 + 46); // 0x80c3338
        int32_t v8 = compare_component((char *)(int32_t)v7, (int32_t)&g83, (char *)&g83, (int32_t)&g83); // 0x80c3349
        if (v8 == 0) {
            // 0x80c329a
            return 0;
        }
    }
    if ((components & 32) != 0) {
        unsigned char v9 = *(char *)(v1 + 48); // 0x80c3360
        int32_t v10 = compare_component((char *)(int32_t)v9, (int32_t)&g83, (char *)&g83, (int32_t)&g83); // 0x80c3371
        if (v10 == 0) {
            // 0x80c329a
            return 0;
        }
    }
    if ((char)components < 0) {
        uint16_t v11 = *(int16_t *)(v1 + 49); // 0x80c3388
        int32_t v12 = compare_component((char *)(int32_t)v11, (int32_t)&g83, (char *)&g83, (int32_t)&g83); // 0x80c3399
        if (v12 == 0) {
            // 0x80c329a
            return 0;
        }
    }
    if ((components & 256) != 0) {
        uint16_t v13 = *(int16_t *)(v1 + 52); // 0x80c33b0
        int32_t v14 = compare_component((char *)(int32_t)v13, (int32_t)&g83, (char *)&g83, (int32_t)&g83); // 0x80c33c1
        if (v14 == 0) {
            // 0x80c329a
            return 0;
        }
    }
    // 0x80c3237
    if ((components & 512) == 0) {
        // 0x80c329a
        return 1;
    }
    int32_t str = *(int32_t *)(v1 + 36); // 0x80c3240
    char * len = NULL; // 0x80c3247
    if (str != 0) {
        // 0x80c3249
        len = (char *)strlen((char *)str);
    }
    int32_t str2 = *(int32_t *)(v2 + 36); // 0x80c3253
    if (str2 != 0) {
        // 0x80c325c
        strlen((char *)str2);
    }
    int32_t v15 = compare_component(len, (int32_t)&g83, (char *)&g83, (int32_t)&g83); // 0x80c3273
    // 0x80c329a
    return v15 != 0;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c
// Address range: 0x80c3470 - 0x80c3d24
// Line range:    205 - 259
int32_t parse_uri(int32_t * uri, char * uristring) {
    // 0x80c3470
    if (assert_failed == 0) {
        // 0x80c3489
        assert_failed = uristring == NULL;
        if (uristring == NULL) {
            // 0x80c3577
            errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
            errline = 212;
            elinks_internal("assertion uristring != NULL failed: No uri to parse.");
        }
    }
    // 0x80c349d
    __asm_rep_stosd_memset((char *)uri, 0, 15);
    if (assert_failed != 0) {
        // 0x80c34b2
        assert_failed = 0;
        // 0x80c34bc
        return 0;
    }
    // 0x80c34c8
    if (*uristring == 0) {
        // 0x80c34bc
        return 1;
    }
    int32_t v1 = (int32_t)uristring;
    int32_t v2 = (int32_t)uri;
    *uri = v1;
    int16_t * v3 = *__ctype_b_loc(); // 0x80c34db
    int32_t v4 = v1; // 0x80c34dd
    int32_t v5; // 0x80c3470
    unsigned char v6; // 0x80c34e3
    while (true) {
      lab_0x80c34e3:
        // 0x80c34e3
        v5 = v4;
        v6 = *(char *)v5;
        if ((*(char *)(2 * (int32_t)v6 + (int32_t)v3) & 8) != 0) {
            // 0x80c34e0
            v4 = v5 + 1;
            goto lab_0x80c34e3;
        } else {
            switch (v6) {
                case 46: {
                    // 0x80c34e0
                    v4 = v5 + 1;
                    goto lab_0x80c34e3;
                }
                case 45: {
                    // 0x80c34e0
                    v4 = v5 + 1;
                    goto lab_0x80c34e3;
                }
                case 43: {
                    // 0x80c34e0
                    v4 = v5 + 1;
                    goto lab_0x80c34e3;
                }
                default: {
                    goto lab_0x80c34fb;
                }
            }
        }
    }
  lab_0x80c34fb:;
    int32_t v7; // 0x80c3470
    if (v5 == v1) {
        goto lab_0x80c3568;
    } else {
        int32_t v8 = v5 - 1; // 0x80c3502
        v7 = v8;
        if (*(char *)v8 < 58) {
            goto lab_0x80c3513;
        } else {
            goto lab_0x80c3568;
        }
    }
  lab_0x80c371a:;
    int32_t v9 = 0; // 0x80c3720
    int32_t v10; // 0x80c3470
    int32_t v11; // 0x80c3732
    while (true) {
      lab_0x80c3732:
        // 0x80c3732
        v11 = v9 + 1;
        v9 = v11;
        switch (*(char *)(v11 + v10)) {
            case 63: {
                goto lab_0x80c373e;
            }
            case 47: {
                goto lab_0x80c373e;
            }
            case 0: {
                goto lab_0x80c373e;
            }
            default: {
                goto lab_0x80c3732;
            }
        }
    }
  lab_0x80c373e:;
    // 0x80c373e
    int32_t v12; // 0x80c3470
    int32_t v13 = v12; // 0x80c3740
    char * v14; // 0x80c3470
    char * v15 = v14; // 0x80c3740
    int32_t v16; // 0x80c3470
    if (v11 <= v16) {
        // break -> 0x80c37ac
        goto lab_0x80c37ac_3;
    }
    int32_t v17 = 0; // 0x80c374c
    int32_t v18 = 1; // 0x80c374c
    char v19; // 0x80c3470
    if (v19 != 64) {
        int32_t v20; // 0x80c3470
        while (true) {
          lab_0x80c375d:
            // 0x80c375d
            v20 = v17;
            int32_t v21 = v20 + 1; // 0x80c375d
            v17 = v21;
            switch (*(char *)(v21 + v10)) {
                case 64: {
                    goto lab_0x80c3769;
                }
                case 0: {
                    goto lab_0x80c3769;
                }
                default: {
                    goto lab_0x80c375d;
                }
            }
        }
      lab_0x80c3769:
        // 0x80c3769
        v18 = v20 + 2;
    }
    int32_t v22 = v18 + v12; // 0x80c376c
    int32_t v23 = v22 + 1; // 0x80c36df
    char * v24 = (char *)v23;
    char v25 = *v24; // 0x80c36df
    char v26 = v25; // 0x80c36e5
    char * v27 = v24; // 0x80c36e5
    int32_t v28 = v23; // 0x80c36e5
    int32_t v29 = v22; // 0x80c36e5
    v13 = v22;
    v15 = v24;
    if (v25 == 0) {
        // break -> 0x80c37ac
        goto lab_0x80c37ac_3;
    }
    goto lab_0x80c36eb;
  lab_0x80c36c8:;
    // 0x80c36c8
    int32_t v32; // 0x80c3470
    int32_t v33 = v32;
    char * v34; // 0x80c36c8
    char * v35 = v34; // 0x80c36cd
    char * v36; // 0x80c3470
    int32_t str; // 0x80c3470
    char * v37; // bp-32, 0x80c3470
    int32_t v38; // 0x80c3470
    if (v38 > v33) {
        // 0x80c36d3
        v35 = v34;
        if (*(char *)v33 != 0) {
            int32_t v39 = v33 + 1; // 0x80c36df
            char * v40 = (char *)v39; // 0x80c36df
            char v41 = *v40; // 0x80c36df
            v26 = v41;
            v27 = v40;
            v28 = v39;
            v29 = v33;
            v13 = v33;
            v15 = v40;
            if (v41 != 0) {
                while (true) {
                  lab_0x80c36eb:
                    // 0x80c36eb
                    v12 = v29;
                    v10 = v28;
                    v14 = v27;
                    v19 = v26;
                    int32_t v30 = 0; // 0x80c36f0
                    v16 = 0;
                    if (v19 != 64) {
                        int32_t v31; // 0x80c36fc
                        while (true) {
                          lab_0x80c36fc:
                            // 0x80c36fc
                            v31 = v30 + 1;
                            v30 = v31;
                            switch (*(char *)(v31 + v10)) {
                                case 64: {
                                    goto lab_0x80c3708;
                                }
                                case 0: {
                                    goto lab_0x80c3708;
                                }
                                default: {
                                    goto lab_0x80c36fc;
                                }
                            }
                        }
                      lab_0x80c3708:
                        // 0x80c3708
                        v16 = v31;
                        v13 = v12;
                        v15 = v14;
                        switch (v19) {
                            case 47: {
                                goto lab_0x80c37ac_3;
                            }
                            case 63: {
                                goto lab_0x80c37ac_3;
                            }
                            default: {
                                goto lab_0x80c371a;
                            }
                        }
                    } else {
                        goto lab_0x80c371a;
                    }
                }
            }
          lab_0x80c37ac_3:;
            uint32_t v42 = v13;
            char * found_char_pos = strchr((char *)str, 58); // 0x80c37bd
            uint32_t v43 = (int32_t)found_char_pos; // 0x80c37bd
            int32_t v44 = (int32_t)v36;
            if (found_char_pos == NULL || v42 < v43) {
                // 0x80c37ca
                *(int32_t *)(v2 + 12) = v44;
                *(int16_t *)(v2 + 42) = (int16_t)(v42 - v44);
            } else {
                // 0x80c3b37
                *(int32_t *)(v2 + 12) = v44;
                *(int32_t *)(v2 + 16) = v43 + 1;
                *(int16_t *)(v2 + 42) = (int16_t)(v43 - (int32_t)v37);
                *(int16_t *)(v2 + 44) = (int16_t)((v43 ^ 0xffff) + v42);
            }
            // 0x80c37d9
            v37 = v15;
            v35 = v15;
        }
    }
    goto lab_0x80c37df;
  lab_0x80c3568:
    // 0x80c3568
    v7 = v5;
    if (v6 >= 59) {
        // 0x80c356f
        *(int16_t *)(v2 + 40) = 0;
        // 0x80c34bc
        return 2;
    }
    goto lab_0x80c3513;
  lab_0x80c3513:;
    uint32_t v99 = v7 - v1; // 0x80c3513
    int16_t v100 = v99; // 0x80c3515
    int16_t * v101 = (int16_t *)(v2 + 40); // 0x80c3518
    *v101 = v100;
    if (v100 == 0) {
        // 0x80c34bc
        return 2;
    }
    int32_t v102 = get_protocol(uristring, v99 % 0x10000); // 0x80c3528
    int32_t * v75 = (int32_t *)(v2 + 4); // 0x80c352d
    *v75 = v102;
    int32_t v103 = (int32_t)*v101 + v1; // 0x80c3534
    unsigned char v104 = *(char *)v103; // 0x80c3537
    int32_t v105 = v103; // 0x80c3540
    char v106 = v104; // 0x80c3540
    if (v104 < 58) {
        int32_t v107 = v103 + 1; // 0x80c3545
        *(int32_t *)(v2 + 8) = (int32_t)v104 - 48;
        v105 = v107;
        v106 = *(char *)v107;
    }
    // 0x80c3551
    if (v106 != 58) {
        // 0x80c34bc
        return 2;
    }
    int32_t v108 = v105;
    int32_t v109 = v108 + 1; // 0x80c359c
    char * v110 = (char *)v109; // 0x80c359f
    v37 = v110;
    int32_t v111; // 0x80c3470
    char * v112; // 0x80c3470
    if (*v110 == 47) {
        // 0x80c3773
        if (*(char *)(v108 + 2) != 47) {
            goto lab_0x80c35ac;
        } else {
            int32_t v113 = v108 + 3; // 0x80c377d
            char * v114 = (char *)v113; // 0x80c3780
            v37 = v114;
            v111 = v113;
            v112 = v114;
            if (*v114 == 47) {
                // 0x80c378d
                v111 = v113;
                v112 = v114;
                if (get_protocol_need_slash_after_host(*v75) != 0) {
                    // 0x80c34bc
                    return 4;
                }
            }
            goto lab_0x80c35c6;
        }
    } else {
        goto lab_0x80c35ac;
    }
  lab_0x80c35ac:
    // 0x80c35ac
    v111 = v109;
    v112 = v110;
    if (get_protocol_need_slashes(*v75) != 0) {
        // 0x80c34bc
        return 3;
    }
    goto lab_0x80c35c6;
  lab_0x80c35c6:;
    char * str3 = v112; // 0x80c38f9
    if (get_protocol_free_syntax(*v75) != 0) {
        // 0x80c38f9
        *(int32_t *)(v2 + 28) = (int32_t)str3;
        int32_t len = strlen(str3); // 0x80c3902
        int32_t * v115 = (int32_t *)(v2 + 48); // 0x80c390a
        *v115 = *v115 & -0xffff01 | 256 * len & 0xffff00;
        // 0x80c34bc
        return 0;
    }
    // 0x80c35d9
    char v116; // 0x80c3470
    int32_t v117; // 0x80c3470
    int32_t v118; // 0x80c3470
    int32_t v92; // 0x80c3470
    int32_t v60; // 0x80c3470
    char * v55; // 0x80c3470
    unsigned char v46; // 0x80c3470
    if (*v75 == 4) {
        int32_t v119 = (int32_t)str3;
        char v120 = *str3; // 0x80c3a81
        int32_t v121 = 0; // 0x80c3470
        v116 = v120;
        v117 = v119;
        v118 = 0;
        switch (v120) {
            case 0: {
                goto lab_0x80c3aca;
            }
            case 35: {
                goto lab_0x80c3aca;
            }
            case 1: {
                goto lab_0x80c3aca;
            }
            default: {
                int32_t v122; // 0x80c3ab2
                int32_t v123; // 0x80c3470
                char v124; // 0x80c3ab5
                while (true) {
                  lab_0x80c3ab2:
                    // 0x80c3ab2
                    v122 = v121 + 1;
                    v123 = v122 + v119;
                    v124 = *(char *)v123;
                    v121 = v122;
                    switch (v124) {
                        case 35: {
                            goto lab_0x80c3abd;
                        }
                        case 1: {
                            goto lab_0x80c3abd;
                        }
                        case 0: {
                            goto lab_0x80c3abd;
                        }
                        default: {
                            goto lab_0x80c3ab2;
                        }
                    }
                }
              lab_0x80c3abd:
                // 0x80c3abd
                v116 = v124;
                v117 = v123;
                v118 = v122;
                if (v122 < 0) {
                    int32_t v125 = -1; // 0x80c3bed
                    int32_t v126 = v119; // 0x80c3470
                    int32_t v127 = 0; // 0x80c3bed
                    while (v125 != 0) {
                        int32_t v128 = v126;
                        v125--;
                        bool v129; // 0x80c3470
                        v126 = v128 + (v129 ? -1 : 1);
                        v127 = v125;
                        if (*(char *)v128 == 0) {
                            // break -> 
                            break;
                        }
                        v127 = 0;
                    }
                    v92 = -2 - v127;
                    goto lab_0x80c3ae1;
                } else {
                    goto lab_0x80c3aca;
                }
            }
        }
    } else {
        int32_t v130 = v111;
        char * str4 = (char *)v130;
        char * found_char_pos2 = strchr(str4, 91); // 0x80c35f1
        char * v131; // 0x80c3470
        int32_t v132; // 0x80c3470
        char * v133; // 0x80c3470
        int32_t v134; // 0x80c3470
        int32_t v135; // 0x80c3470
        char * v136; // 0x80c3470
        char v137; // 0x80c3470
        if (found_char_pos2 == NULL) {
            // 0x80c3b70
            v131 = str3;
            v135 = 0;
            v132 = v130;
            v133 = str4;
            v137 = *(char *)(v2 + 54);
            v136 = NULL;
            v134 = (int32_t)*str4;
        } else {
            char * found_char_pos3 = strchr(found_char_pos2, 93); // 0x80c360f
            unsigned char v138 = *str4;
            int32_t v139 = v138;
            if (found_char_pos3 == NULL) {
                // 0x80c3c46
                v131 = str3;
                v135 = 0;
                v132 = v130;
                v133 = str4;
                v137 = *(char *)(v2 + 54);
                v136 = NULL;
                v134 = v139;
            } else {
                int32_t v140 = 0; // 0x80c3470
                int32_t v141 = 0; // 0x80c3470
                switch (v138) {
                    default: {
                        while (true) {
                          lab_0x80c3644:;
                            int32_t v142 = v140 + 1; // 0x80c3647
                            v140 = v142;
                            v141 = v142;
                            switch (*(char *)(v142 + v130)) {
                                case 47: {
                                    goto lab_0x80c3655;
                                }
                                case 0: {
                                    goto lab_0x80c3655;
                                }
                                default: {
                                    goto lab_0x80c3644;
                                }
                            }
                        }
                    }
                    case 0: {
                    }
                    case 47: {
                      lab_0x80c3655:;
                        char * v143 = (char *)(v2 + 54);
                        char v144 = *v143;
                        v131 = str3;
                        v135 = 0;
                        v132 = v130;
                        v133 = str4;
                        v137 = v144;
                        v136 = NULL;
                        v134 = v139;
                        if (v141 + v130 > (int32_t)found_char_pos3) {
                            char v145 = v144 | 1; // 0x80c3a68
                            *v143 = v145;
                            v131 = v37;
                            v135 = (int32_t)found_char_pos2;
                            v132 = (int32_t)v37;
                            v133 = v37;
                            v137 = v145;
                            v136 = found_char_pos3;
                            v134 = (int32_t)*v37;
                        }
                        // break -> 0x80c3675
                        break;
                    }
                }
            }
        }
        // 0x80c3675
        v55 = v136;
        v46 = v137;
        v34 = v133;
        v60 = v135;
        v35 = v34;
        if (v134 == 0) {
            goto lab_0x80c37df;
        } else {
            // 0x80c367d
            str = v132;
            v36 = v131;
            v38 = (int32_t)v34;
            int32_t v146 = 0; // 0x80c3685
            if (v134 != 64) {
                while (true) {
                  lab_0x80c3695:;
                    int32_t v147 = v146 + 1; // 0x80c3695
                    v32 = v147 + v38;
                    v146 = v147;
                    switch (*(char *)v32) {
                        case 64: {
                            goto lab_0x80c36a2;
                        }
                        case 0: {
                            goto lab_0x80c36a2;
                        }
                        default: {
                            goto lab_0x80c3695;
                        }
                    }
                }
              lab_0x80c36a2:
                // 0x80c36a2
                if (v134 == 47) {
                    goto lab_0x80c36c8;
                } else {
                    goto lab_0x80c36ae;
                }
            } else {
                goto lab_0x80c36ae;
            }
        }
    }
  lab_0x80c3aca:;
    int32_t v148 = v117; // 0x80c3ad0
    char v149 = v116; // 0x80c3ad0
    if (v116 == 35) {
        int32_t v150 = v117 + 1; // 0x80c3bb8
        *(int32_t *)(v2 + 32) = v150;
        int32_t v151 = 0; // 0x80c3470
        int16_t v152 = 0; // 0x80c3470
        if (*(char *)v150 >= 2) {
            int32_t v153 = 1; // 0x80c3bd4
            int32_t v154 = v153; // 0x80c3470
            while (*(char *)(v153 + v150) >= 2) {
                // 0x80c3bd4
                v153 = v154 + 1;
                v154 = v153;
            }
            // 0x80c3be0
            v151 = v153 % 0x10000;
            v152 = v153;
        }
        int32_t v155 = v151 + v150; // 0x80c3bfd
        *(int16_t *)(v2 + 52) = v152;
        v148 = v155;
        v149 = *(char *)v155;
    }
    // 0x80c3ad6
    v92 = v118;
    if (v149 == 1) {
        // 0x80c3adb
        *(int32_t *)(v2 + 36) = v148 + 1;
        v92 = v118;
    }
    goto lab_0x80c3ae1;
  lab_0x80c37df:;
    int32_t v45; // 0x80c3470
    if (v46 % 2 == 0) {
        int32_t v47 = (int32_t)v35;
        int32_t v48 = 0; // 0x80c3470
        int32_t v49 = 0; // 0x80c3470
        char * v50; // 0x80c3921
        switch (*v50) {
            default: {
                while (true) {
                  lab_0x80c395c:;
                    int32_t v51 = v48 + 1; // 0x80c395c
                    v48 = v51;
                    v49 = v51;
                    switch (*(char *)(v51 + v47)) {
                        case 63: {
                            goto lab_0x80c3967;
                        }
                        case 58: {
                            goto lab_0x80c3967;
                        }
                        case 47: {
                            goto lab_0x80c3967;
                        }
                        case 0: {
                            goto lab_0x80c3967;
                        }
                        default: {
                            goto lab_0x80c395c;
                        }
                    }
                }
            }
            case 0: {
            }
            case 58: {
            }
            case 47: {
            }
            case 63: {
              lab_0x80c3967:;
                int32_t v52 = v49 + v47; // 0x80c3967
                int16_t v53 = v49; // 0x80c3972
                *(int32_t *)(v2 + 20) = v47;
                *(int16_t *)(v2 + 46) = v53;
                v45 = v52;
                if (v53 != 0) {
                    // 0x80c3982
                    v45 = v52;
                    if (*(char *)(v49 % 0x10000 - 1 + (int32_t)v37) == 46) {
                        // 0x80c34bc
                        return 5;
                    }
                }
                // break -> 0x80c3871
                break;
            }
        }
    } else {
        int32_t v54 = 0; // 0x80c3470
        switch (*v55) {
            default: {
                int32_t v56 = 0; // 0x80c3814
                while (true) {
                  lab_0x80c3826:
                    // 0x80c3826
                    v56++;
                    char v57 = *(char *)(v56 + (int32_t)v55); // 0x80c3829
                    v54 = v56;
                    switch (v57) {
                        case 63: {
                            goto lab_0x80c3831;
                        }
                        case 58: {
                            goto lab_0x80c3831;
                        }
                        case 47: {
                            goto lab_0x80c3831;
                        }
                        case 0: {
                            goto lab_0x80c3831;
                        }
                        default: {
                            goto lab_0x80c3826;
                        }
                    }
                }
            }
            case 0: {
            }
            case 58: {
            }
            case 47: {
            }
            case 63: {
              lab_0x80c3831:
                // 0x80c3831
                if (assert_failed != 0) {
                    // 0x80c3a4d
                    assert_failed = 0;
                    // 0x80c34bc
                    return 9;
                }
                int32_t v58 = (int32_t)v55; // 0x80c383e
                uint32_t v59 = v58 + -1 - v60; // 0x80c3846
                assert_failed = v59 >= 1025;
                if (v59 >= 1025) {
                    // 0x80c3a12
                    errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
                    errline = 347;
                    elinks_internal("assertion addrlen >= 0 && addrlen < NI_MAXHOST failed: parse_uri(): addrlen value is bad (%d) for URL '%s'. Problems are likely to be encountered. Please report this, it is a security bug!", v59, uristring);
                    if (assert_failed != 0) {
                        // 0x80c3a4d
                        assert_failed = 0;
                        // 0x80c34bc
                        return 9;
                    }
                }
                // 0x80c385f
                *(int16_t *)(v2 + 46) = (int16_t)v59;
                *(int32_t *)(v2 + 20) = v60 + 1;
                v45 = v54 + v58;
                // break -> 0x80c3871
                break;
            }
        }
    }
    char v61 = *(char *)v45; // 0x80c3871
    char v62 = v61; // 0x80c3876
    int32_t v63 = v45; // 0x80c3876
    if (v61 == 58) {
        int32_t v64 = v45 + 1; // 0x80c399d
        char * v65 = (char *)v64;
        char v66 = *v65; // 0x80c399d
        int32_t v67 = 0; // 0x80c39a3
        if (v66 != 0 != v66 != 47) {
            // 0x80c3cff
            *(int32_t *)(v2 + 24) = v64;
            *(char *)(v2 + 48) = 0;
            // 0x80c34bc
            return 7;
        }
        int32_t v68; // 0x80c39c6
        uint32_t v69; // 0x80c39c9
        while (true) {
          lab_0x80c39c6:
            // 0x80c39c6
            v68 = v67 + 1;
            v69 = v68 + v64;
            v67 = v68;
            switch (*(char *)v69) {
                case 47: {
                    goto lab_0x80c39df;
                }
                case 0: {
                    goto lab_0x80c39df;
                }
                default: {
                    goto lab_0x80c39c6;
                }
            }
        }
      lab_0x80c39df:;
        char v70 = v68; // 0x80c39e3
        *(char *)(v2 + 48) = v70;
        int32_t * str2 = (int32_t *)(v2 + 24); // 0x80c39ed
        *str2 = v64;
        if (v70 == 0) {
            // 0x80c34bc
            return 7;
        }
        // 0x80c39f6
        if (v68 > 255) {
            // 0x80c34bc
            return 10;
        }
        int32_t v71 = v64; // 0x80c3c71
        if (v69 > v64) {
            // 0x80c3c73
            if (*v65 >= 58) {
                // 0x80c34bc
                return 10;
            }
            int32_t v72 = v64; // 0x80c3c7d
            v72++;
            v71 = v72;
            while (v72 < v69) {
                // 0x80c3c88
                if (*(char *)v72 >= 58) {
                    // 0x80c34bc
                    return 10;
                }
                v72++;
                v71 = v72;
            }
        }
        // 0x80c3c9d
        if (v64 != 0) {
            int32_t * v73 = __errno_location(); // 0x80c3ca1
            *v73 = 0;
            if (strtol((char *)*str2, NULL, 10) >= 0x10000 || *v73 != 0) {
                // 0x80c34bc
                return 10;
            }
        }
        // 0x80c3cdd
        v62 = *(char *)v71;
        v63 = v71;
    }
    // 0x80c387c
    int32_t v74; // 0x80c3470
    if (v62 != 47) {
        // 0x80c3b0a
        v74 = v63;
        if (get_protocol_need_slash_after_host(*v75) != 0) {
            // 0x80c34bc
            return *(int16_t *)(v2 + 46) == 0 ? 6 : 8;
        }
    } else {
        // 0x80c3884
        v74 = v63 + 1;
    }
    int32_t v76 = 0; // 0x80c3470
    int32_t v77 = 0; // 0x80c3470
    int32_t v78; // 0x80c3470
    switch (*(char *)v78) {
        default: {
            while (true) {
              lab_0x80c38b2:;
                int32_t v79 = v76 + 1; // 0x80c38b2
                v76 = v79;
                v77 = v79;
                switch (*(char *)(v79 + v78)) {
                    case 35: {
                        goto lab_0x80c38bd;
                    }
                    case 1: {
                        goto lab_0x80c38bd;
                    }
                    case 0: {
                        goto lab_0x80c38bd;
                    }
                    default: {
                        goto lab_0x80c38b2;
                    }
                }
            }
        }
        case 0: {
        }
        case 35: {
        }
        case 1: {
          lab_0x80c38bd:;
            int32_t * v80 = (int32_t *)(v2 + 48); // 0x80c38bd
            int32_t v81 = v77 + v74; // 0x80c38c0
            *(int32_t *)(v2 + 28) = v74;
            *v80 = *v80 & -0xffff01 | 256 * v77 & 0xffff00;
            char v82 = *(char *)v81; // 0x80c38d7
            char v83 = v82; // 0x80c38dd
            int32_t v84 = v81; // 0x80c38dd
            if (v82 == 35) {
                int32_t v85 = v81 + 1; // 0x80c3c0c
                *(int32_t *)(v2 + 32) = v85;
                int16_t v86 = 0; // 0x80c3470
                int32_t v87 = 0; // 0x80c3470
                if (*(char *)v85 >= 2) {
                    int32_t v88 = 1; // 0x80c3c32
                    int32_t v89 = v88; // 0x80c3470
                    while (*(char *)(v88 + v85) >= 2) {
                        // 0x80c3c32
                        v88 = v89 + 1;
                        v89 = v88;
                    }
                    // 0x80c3c3e
                    v86 = v88;
                    v87 = v88 % 0x10000;
                }
                // 0x80c3cf0
                v84 = v87 + v85;
                *(int16_t *)(v2 + 52) = v86;
                v83 = *(char *)v84;
            }
            // 0x80c38e3
            if (v83 == 1) {
                // 0x80c38ee
                *(int32_t *)(v2 + 36) = v84 + 1;
            }
            // 0x80c34bc
            return 0;
        }
    }
  lab_0x80c3ae1:;
    // 0x80c3ae1
    char * v90; // 0x80c3470
    int32_t v91; // 0x80c3470
    if (v92 > 9) {
        int32_t v93 = c_strncasecmp(v37, "localhost/", 10); // 0x80c3b9f
        v90 = v37;
        v91 = v92;
        if (v93 == 0) {
            // 0x80c3bac
            v90 = (char *)((int32_t)v37 + 9);
            v91 = v92 - 9;
        }
    } else {
        // 0x80c3ae1
        v90 = v37;
        v91 = v92;
    }
    int32_t * v94 = (int32_t *)(v2 + 48); // 0x80c3aea
    *v94 = *v94 & -0xffff01 | 256 * v91 & 0xffff00;
    *(int32_t *)(v2 + 28) = (int32_t)v90;
    // 0x80c34bc
    return 0;
  lab_0x80c36ae:
    // 0x80c36ae
    while (true) {
      lab_0x80c36bd:;
        // 0x80c36bd
        int32_t v95; // 0x80c3470
        int32_t v96 = v95;
        int32_t v97 = v96 + 1; // 0x80c36bd
        char v98 = *(char *)(v97 + v38); // 0x80c36c0
        v95 = v97;
        switch (v98) {
            case 47: {
                goto lab_0x80c36c8;
            }
            case 0: {
                goto lab_0x80c36c8;
            }
            default: {
                goto lab_0x80c36bd;
            }
        }
    }
    goto lab_0x80c36c8;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c
// Address range: 0x80c5130 - 0x80c5d99
// Line range:    491 - 985
int32_t * add_uri_to_string(int32_t * string, int32_t * uri, uint32_t components) {
    int32_t v1 = (int32_t)uri;
    int32_t * v2 = (int32_t *)(v1 + 4); // 0x80c513f
    if (*v2 == 18) {
        // 0x80c52f0
        return (int32_t *)add_to_string(string, *uri);
    }
    int32_t v3 = (int32_t)string;
    int32_t v4; // 0x80c5485
    uint16_t v5; // 0x80c5487
    if (components % 2 != 0) {
        // 0x80c5480
        if (assert_failed != 0) {
            // 0x80c5aa8
            assert_failed = 0;
            goto lab_0x80c54e7;
        } else {
            // 0x80c5496
            v4 = *uri;
            v5 = *(int16_t *)(v1 + 40);
            if (string != NULL == (v4 != 0)) {
                // 0x80c5ae0
                assert_failed = 0;
                goto lab_0x80c54dc;
            } else {
                // 0x80c54a5
                assert_failed = 1;
                errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
                errline = 255;
                elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
                if (assert_failed != 0) {
                    // 0x80c5aa8
                    assert_failed = 0;
                    goto lab_0x80c54e7;
                } else {
                    goto lab_0x80c54dc;
                }
            }
        }
    } else {
        goto lab_0x80c5155;
    }
  lab_0x80c5155:;
    uint16_t v6; // 0x80c515d
    int32_t v7; // 0x80c553e
    if ((components & 4) == 0) {
        goto lab_0x80c516a;
    } else {
        // 0x80c515d
        v6 = *(int16_t *)(v1 + 42);
        if (v6 != 0) {
            // 0x80c5538
            if (assert_failed == 0) {
                // 0x80c5810
                v7 = *(int32_t *)(v1 + 12);
                if (string == NULL || v7 == 0) {
                    // 0x80c5ba8
                    assert_failed = 1;
                    errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
                    errline = 255;
                    elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
                    if (assert_failed == 0) {
                        goto lab_0x80c5830;
                    } else {
                        // 0x80c554c
                        assert_failed = 0;
                        goto lab_0x80c5556;
                    }
                } else {
                    // 0x80c5826
                    assert_failed = 0;
                    goto lab_0x80c5830;
                }
            } else {
                // 0x80c554c
                assert_failed = 0;
                goto lab_0x80c5556;
            }
        } else {
            goto lab_0x80c516a;
        }
    }
  lab_0x80c516a:;
    uint16_t v8; // 0x80c5172
    int32_t v9; // 0x80c5596
    if ((components & 8) == 0) {
        goto lab_0x80c517f;
    } else {
        // 0x80c5172
        v8 = *(int16_t *)(v1 + 44);
        if (v8 != 0) {
            // 0x80c5590
            if (assert_failed == 0) {
                // 0x80c59b0
                v9 = *(int32_t *)(v1 + 16);
                if (string == NULL || v9 == 0) {
                    // 0x80c5be8
                    assert_failed = 1;
                    errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
                    errline = 255;
                    elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
                    if (assert_failed == 0) {
                        goto lab_0x80c59cd;
                    } else {
                        // 0x80c55a4
                        assert_failed = 0;
                        goto lab_0x80c517f;
                    }
                } else {
                    // 0x80c59c3
                    assert_failed = 0;
                    goto lab_0x80c59cd;
                }
            } else {
                // 0x80c55a4
                assert_failed = 0;
                goto lab_0x80c517f;
            }
        } else {
            goto lab_0x80c517f;
        }
    }
  lab_0x80c54e7:
    if ((components & 2) != 0) {
        int32_t v10 = *(int32_t *)(v1 + 8); // 0x80c54ef
        if (v10 != 0) {
            // 0x80c5cd8
            add_long_to_string(string, v10);
        }
    }
    // 0x80c54fa
    add_char_to_string(string, 58);
    if (get_protocol_need_slashes(*v2) != 0) {
        // 0x80c5520
        add_to_string(string, (int32_t)"//");
    }
    goto lab_0x80c5155;
  lab_0x80c517f:
    if ((components & 16) == 0) {
        goto lab_0x80c51d0;
    } else {
        goto lab_0x80c5187;
    }
  lab_0x80c54dc:
    if (v5 != 0) {
        int32_t * v11 = (int32_t *)(v3 + 4); // 0x80c5d31
        if (mem_align_alloc__(1, 255) != 0) {
            int32_t v12 = v5; // 0x80c5487
            int32_t v13 = *v11 + v12; // 0x80c5d34
            memcpy(&((struct _IO_FILE *)(*v11 + *string))->e0, (int32_t *)v4, v12);
            *(char *)(*string + v13) = 0;
            *v11 = v13;
        }
    }
    goto lab_0x80c54e7;
  lab_0x80c51d0:;
    int32_t v14; // 0x80c5771
    unsigned char v15; // 0x80c5774
    if ((components & 96) == 0) {
        goto lab_0x80c5228;
    } else {
        char * v16 = (char *)(v1 + 48); // 0x80c51d8
        if (*v16 != 0) {
            // 0x80c5758
            add_char_to_string(string, 58);
            if (assert_failed == 0) {
                // 0x80c5890
                v14 = *(int32_t *)(v1 + 24);
                v15 = *v16;
                if (string == NULL || v14 == 0) {
                    // 0x80c5b68
                    assert_failed = 1;
                    errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
                    errline = 255;
                    elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
                    if (assert_failed == 0) {
                        goto lab_0x80c58ad;
                    } else {
                        // 0x80c5783
                        assert_failed = 0;
                        goto lab_0x80c5228;
                    }
                } else {
                    // 0x80c58a3
                    assert_failed = 0;
                    goto lab_0x80c58ad;
                }
            } else {
                // 0x80c5783
                assert_failed = 0;
                goto lab_0x80c5228;
            }
        } else {
            if ((components & 64) != 0) {
                int32_t v17 = *v2; // 0x80c51f2
                if (v17 != 19) {
                    int32_t v18 = get_protocol_port(v17); // 0x80c51fd
                    add_char_to_string(string, 58);
                    add_long_to_string(string, v18);
                }
            }
            goto lab_0x80c5228;
        }
    }
  lab_0x80c5187:;
    int16_t * v19 = (int16_t *)(v1 + 46); // 0x80c5187
    uint16_t v20 = *v19; // 0x80c5187
    char * v21; // 0x80c5190
    if (v20 == 0) {
        goto lab_0x80c51d0;
    } else {
        int32_t v22 = v20; // 0x80c5187
        v21 = (char *)(v1 + 54);
        int32_t v23 = v22; // 0x80c5194
        if (*v21 % 2 != 0) {
            // 0x80c5196
            v23 = v22;
            if ((components & 32) != 0) {
                // 0x80c5af0
                add_char_to_string(string, 91);
                v23 = (int32_t)*v19;
            }
        }
        if ((components & 2048) != 0) {
            char * v24 = memacpy((char *)*(int32_t *)(v1 + 20), v23); // 0x80c560d
            if (v24 == NULL) {
                // 0x80c51ae
                add_bytes_to_string__2();
                goto lab_0x80c51bc;
            } else {
                // 0x80c5618
                int32_t v25; // bp-32, 0x80c5130
                if (function_80590c8((int32_t)v24, &v25, 0) == 0) {
                    // 0x80c5d04
                    add_to_string(string, v25);
                    free(&((struct _IO_FILE *)v25)->e0);
                    mem_free(v24);
                    goto lab_0x80c51bc;
                } else {
                    // 0x80c5637
                    mem_free(v24);
                    // 0x80c51ae
                    add_bytes_to_string__2();
                    goto lab_0x80c51bc;
                }
            }
        } else {
            // 0x80c51ae
            add_bytes_to_string__2();
            goto lab_0x80c51bc;
        }
    }
  lab_0x80c5228:
    if ((components & 640) == 0 != components != 49) {
        if ((components & -161) != 0) {
            // 0x80c57c0
            if (get_protocol_need_slash_after_host(*v2) != 0) {
                // 0x80c57d3
                add_char_to_string(string, 47);
            }
        }
    }
    int32_t v26; // 0x80c579d
    uint16_t v27; // 0x80c57a0
    if ((char)components >= 0) {
        goto lab_0x80c5259;
    } else {
        // 0x80c524c
        if ((*(int32_t *)(v1 + 48) & 0xffff00) != 0) {
            // 0x80c5798
            if (assert_failed == 0) {
                // 0x80c5920
                v26 = *(int32_t *)(v1 + 28);
                v27 = *(int16_t *)(v1 + 49);
                if (string == NULL || v26 == 0) {
                    // 0x80c5b28
                    assert_failed = 1;
                    errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
                    errline = 255;
                    elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
                    if (assert_failed == 0) {
                        goto lab_0x80c593d;
                    } else {
                        // 0x80c57af
                        assert_failed = 0;
                        goto lab_0x80c5259;
                    }
                } else {
                    // 0x80c5933
                    assert_failed = 0;
                    goto lab_0x80c593d;
                }
            } else {
                // 0x80c57af
                assert_failed = 0;
                goto lab_0x80c5259;
            }
        } else {
            goto lab_0x80c5259;
        }
    }
  lab_0x80c5556:
    if ((components & 8) != 0) {
        // 0x80c555e
        if (*(int16_t *)(v1 + 44) != 0) {
            // 0x80c5c68
            add_char_to_string(string, 58);
            add_bytes_to_string__2();
        }
    }
    // 0x80c5569
    add_char_to_string(string, 64);
    if ((components & 16) == 0) {
        goto lab_0x80c51d0;
    } else {
        goto lab_0x80c5187;
    }
  lab_0x80c5259:;
    int32_t v28; // 0x80c5130
    if ((components & 0x3000) == 0) {
        if ((components & 0x4000) != 0) {
            // 0x80c530c
            if ((*(int32_t *)(v1 + 48) & 0xffff00) != 0) {
                int32_t v29 = *(int32_t *)(v1 + 28); // 0x80c5329
                int32_t * found_byte_pos = memchr(&((struct _IO_FILE *)v29)->e0, 63, (int32_t)*(int16_t *)(v1 + 49)); // 0x80c532f
                if (assert_failed == 0) {
                    // 0x80c533e
                    assert_failed = components != 0x4000;
                    if (components != 0x4000) {
                        // 0x80c5c8f
                        errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
                        errline = 625;
                        elinks_internal("assertion URI_QUERY == components failed: URI_QUERY should be used alone %d", components);
                    }
                }
                // 0x80c5357
                if (found_byte_pos == NULL) {
                    // 0x80c52f0
                    return (int32_t *)v3;
                }
                int32_t v30 = (int32_t)found_byte_pos + 1; // 0x80c535b
                int32_t v31 = 0; // 0x80c5130
                int32_t v32 = 0; // 0x80c5130
                switch (*(char *)v30) {
                    default: {
                        while (true) {
                          lab_0x80c5397:;
                            int32_t v33 = v31 + 1; // 0x80c5397
                            v31 = v33;
                            v32 = v33;
                            switch (*(char *)(v33 + v30)) {
                                case 35: {
                                    goto lab_0x80c53a5;
                                }
                                case 1: {
                                    goto lab_0x80c53a5;
                                }
                                case 0: {
                                    goto lab_0x80c53a5;
                                }
                                default: {
                                    goto lab_0x80c5397;
                                }
                            }
                        }
                    }
                    case 0: {
                    }
                    case 35: {
                    }
                    case 1: {
                      lab_0x80c53a5:
                        // 0x80c53a5
                        if (assert_failed != 0) {
                            // 0x80c53b3
                            assert_failed = 0;
                            // 0x80c52f0
                            return (int32_t *)0;
                        }
                        // 0x80c5a30
                        if (string == NULL || v32 < 0) {
                            // 0x80c5c28
                            assert_failed = 1;
                            errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
                            errline = 255;
                            elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
                            if (assert_failed != 0) {
                                // 0x80c53b3
                                assert_failed = 0;
                                // 0x80c52f0
                                return (int32_t *)0;
                            }
                        } else {
                            // 0x80c5a43
                            assert_failed = 0;
                        }
                        // 0x80c5a4d
                        if (v32 == 0) {
                            // 0x80c52f0
                            return (int32_t *)v3;
                        }
                        int32_t * v34 = (int32_t *)(v3 + 4); // 0x80c5a58
                        v28 = 0;
                        if (mem_align_alloc__(1, 255) != 0) {
                            int32_t v35 = *v34 + v32; // 0x80c5a6a
                            memcpy(&((struct _IO_FILE *)(*v34 + *string))->e0, (int32_t *)v30, v32);
                            *(char *)(*string + v35) = 0;
                            *v34 = v35;
                            v28 = v3;
                        }
                        // 0x80c52f0
                        return (int32_t *)v28;
                    }
                }
            }
        }
        if ((components & 256) != 0) {
            // 0x80c53d8
            if (*(int16_t *)(v1 + 52) != 0) {
                // 0x80c5ab8
                add_char_to_string(string, 35);
                add_bytes_to_string__2();
            }
        }
        if ((components & 512) != 0) {
            int32_t * v36 = (int32_t *)(v1 + 36); // 0x80c53eb
            if (*v36 != 0) {
                // 0x80c53f2
                add_char_to_string(string, 1);
                add_to_string(string, *v36);
                return string;
            }
        }
        // 0x80c5428
        if ((components & 1024) == 0) {
            // 0x80c52f0
            return (int32_t *)v3;
        }
        int32_t v37 = *(int32_t *)(v1 + 36); // 0x80c5434
        if (v37 == 0) {
            // 0x80c52f0
            return (int32_t *)v3;
        }
        // 0x80c543f
        bool v38; // 0x80c5130
        int32_t v39 = v38 ? -1 : 1;
        int32_t v40 = (int32_t)"text/plain"; // 0x80c5130
        int32_t v41 = v37; // 0x80c5130
        int32_t v42 = 10; // 0x80c544b
        int32_t v43 = (int32_t)"multipart/form-data;"; // 0x80c544b
        int32_t v44 = v37; // 0x80c544b
        int32_t v45 = 20; // 0x80c544b
        while (*(char *)v41 == *(char *)v40) {
            // 0x80c543f
            v42--;
            v40 += v39;
            v41 += v39;
            if (v42 == 0) {
                // 0x80c5cec
                add_to_string(string, (int32_t)" (PLAIN TEXT DATA)");
                goto lab_0x80c52f0;
            }
            v43 = (int32_t)"multipart/form-data;";
            v44 = v37;
            v45 = 20;
        }
        while (*(char *)v44 == *(char *)v43) {
            int32_t v46 = v45 - 1; // 0x80c545f
            v43 += v39;
            v44 += v39;
            v45 = v46;
            if (v46 == 0) {
                // 0x80c5cc0
                add_to_string(string, (int32_t)" (MULTIPART FORM DATA)");
                goto lab_0x80c52f0;
            }
        }
        // 0x80c5467
        add_to_string(string, (int32_t)" (POST DATA)");
      lab_0x80c52f0:
        // 0x80c52f0
        return (int32_t *)v3;
    }
    int32_t v47 = *(int32_t *)(v1 + 28); // 0x80c526c
    if (assert_failed == 0) {
        int32_t v48 = components / 0x2000 & (int32_t)(components != 0x2000); // 0x80c5283
        assert_failed = v48;
        if (v48 != 0) {
            // 0x80c55d0
            errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
            errline = 602;
            elinks_internal("assertion !wants(URI_FILENAME) || components == URI_FILENAME failed: URI_FILENAME should be used alone %d", components);
        }
    }
    if ((components & 0x1000) != 0) {
        // 0x80c529a
        if (*(char *)v47 != 47) {
            // 0x80c55b8
            add_char_to_string(string, 47);
        }
    }
    // 0x80c52ad
    if ((*(int32_t *)(v1 + 48) & 0xffff00) == 0) {
        // 0x80c52f0
        return (int32_t *)v3;
    }
    char v49 = *(char *)v47; // 0x80c52b6
    int32_t v50 = 0; // 0x80c5130
    int32_t v51 = v47; // 0x80c5130
    switch (v49) {
        case 0: {
            goto lab_0x80c52d0;
        }
        case 35: {
            goto lab_0x80c52d0;
        }
        case 63: {
            goto lab_0x80c52d0;
        }
        case 1: {
            goto lab_0x80c52d0;
        }
        default: {
            char v52 = v49; // 0x80c5711
            int32_t v53 = v47; // 0x80c5711
            int32_t v54 = v47; // 0x80c5711
            int32_t v55; // 0x80c5130
            int32_t v56; // 0x80c5130
            while (true) {
              lab_0x80c5718:;
                int32_t v57 = v54;
                v56 = v53 + 1;
                int32_t v58 = v57; // 0x80c571c
                if ((components & 0x2000) != 0) {
                    // 0x80c571e
                    v58 = v52 == 47 ? v56 : v57;
                }
                // 0x80c572d
                v55 = v58;
                char v59 = *(char *)v56; // 0x80c572d
                switch (v59) {
                    case 0: {
                        goto lab_0x80c573c;
                    }
                    case 35: {
                        goto lab_0x80c573c;
                    }
                    default: {
                        if (v59 == 1) {
                            // break -> 0x80c573c
                            break;
                        }
                        // 0x80c5748
                        v52 = v59;
                        v53 = v56;
                        v54 = v55;
                        if (v59 == 63) {
                            // 0x80c574f
                            v50 = v56 - v55;
                            v51 = v55;
                            goto lab_0x80c52d0;
                        }
                        goto lab_0x80c5718;
                    }
                }
            }
          lab_0x80c573c:
            // 0x80c573c
            v50 = v56 - v55;
            v51 = v55;
            goto lab_0x80c52d0;
        }
    }
  lab_0x80c5830:;
    int32_t * v60 = (int32_t *)(v3 + 4); // 0x80c5839
    if (mem_align_alloc__(1, 255) != 0) {
        int32_t v61 = v6; // 0x80c515d
        int32_t v62 = *v60 + v61; // 0x80c584b
        memcpy(&((struct _IO_FILE *)(*v60 + *string))->e0, (int32_t *)v7, v61);
        *(char *)(*string + v62) = 0;
        *v60 = v62;
    }
    goto lab_0x80c5556;
  lab_0x80c52d0:
    // 0x80c52d0
    if (assert_failed != 0) {
        // 0x80c52de
        assert_failed = 0;
        // 0x80c52f0
        return (int32_t *)0;
    }
    // 0x80c5648
    if (v50 < 0 || string == NULL || v51 == 0) {
        // 0x80c56c0
        assert_failed = 1;
        errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
        errline = 255;
        elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
        if (assert_failed != 0) {
            // 0x80c52de
            assert_failed = 0;
            // 0x80c52f0
            return (int32_t *)0;
        }
    } else {
        // 0x80c5657
        assert_failed = 0;
    }
    // 0x80c5661
    if (v50 == 0) {
        // 0x80c52f0
        return (int32_t *)v3;
    }
    int32_t * v63 = (int32_t *)(v3 + 4); // 0x80c566c
    v28 = 0;
    if (mem_align_alloc__(1, 255) != 0) {
        int32_t v64 = *v63 + v50; // 0x80c567e
        memcpy(&((struct _IO_FILE *)(*v63 + *string))->e0, (int32_t *)v51, v50);
        *(char *)(*string + v64) = 0;
        *v63 = v64;
        v28 = v3;
    }
    // 0x80c52f0
    return (int32_t *)v28;
  lab_0x80c51bc:
    // 0x80c51bc
    if (*v21 % 2 != 0) {
        if ((components & 32) != 0) {
            // 0x80c5b10
            add_char_to_string(string, 93);
        }
    }
    goto lab_0x80c51d0;
  lab_0x80c59cd:;
    int32_t * v65 = (int32_t *)(v3 + 4); // 0x80c59d6
    int32_t v66 = *v65; // 0x80c59d6
    if (mem_align_alloc__(1, 255) != 0) {
        int32_t v67 = v8; // 0x80c5172
        int32_t v68 = v66 + v67; // 0x80c59e8
        memcpy(&((struct _IO_FILE *)(*v65 + *string))->e0, (int32_t *)v9, v67);
        *(char *)(*string + v68) = 0;
        *v65 = v68;
    }
    goto lab_0x80c517f;
  lab_0x80c58ad:
    if (v15 != 0) {
        int32_t * v69 = (int32_t *)(v3 + 4); // 0x80c58be
        if (mem_align_alloc__(1, 255) != 0) {
            int32_t v70 = v15; // 0x80c5774
            int32_t v71 = *v69 + v70; // 0x80c58c1
            memcpy(&((struct _IO_FILE *)(*v69 + *string))->e0, (int32_t *)v14, v70);
            *(char *)(*string + v71) = 0;
            *v69 = v71;
        }
    }
    goto lab_0x80c5228;
  lab_0x80c593d:
    if (v27 != 0) {
        int32_t * v72 = (int32_t *)(v3 + 4); // 0x80c594b
        if (mem_align_alloc__(1, 255) != 0) {
            int32_t v73 = v27; // 0x80c57a0
            int32_t v74 = *v72 + v73; // 0x80c594e
            memcpy(&((struct _IO_FILE *)(*v72 + *string))->e0, (int32_t *)v26, v73);
            *(char *)(*string + v74) = 0;
            *v72 = v74;
        }
    }
    goto lab_0x80c5259;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c
// Address range: 0x80c5da0 - 0x80c5dec
// Line range:    662 - 671
char * get_uri_string(int32_t * uri, int32_t components) {
    // 0x80c5da0
    char * result; // bp-20, 0x80c5da0
    if (init_string((int32_t *)&result) == 0) {
        // 0x80c5de0
        done_string((int32_t *)&result);
        // 0x80c5dd3
        return NULL;
    }
    // 0x80c5db6
    if (add_uri_to_string((int32_t *)&result, uri, components) != NULL) {
        // 0x80c5dd3
        return result;
    }
    // 0x80c5de0
    done_string((int32_t *)&result);
    // 0x80c5dd3
    return NULL;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c
// Address range: 0x80c5df0 - 0x80c5e8c
// Line range:    1284 - 1298
int32_t * get_composed_uri(int32_t * uri, int32_t components) {
    // 0x80c5df0
    if (assert_failed != 0) {
        // 0x80c5e7a
        assert_failed = 0;
        // 0x80c5e86
        return NULL;
    }
    // 0x80c5e04
    assert_failed = uri == NULL;
    if (uri == NULL) {
        // 0x80c5e50
        errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
        errline = 1288;
        elinks_internal("assertion uri failed!");
        if (assert_failed != 0) {
            // 0x80c5e7a
            assert_failed = 0;
            // 0x80c5e86
            return NULL;
        }
    }
    char * v1 = get_uri_string(uri, components); // 0x80c5e1e
    if (v1 == NULL) {
        // 0x80c5e86
        return NULL;
    }
    int32_t * result = get_uri(v1, 0); // 0x80c5e36
    mem_free(v1);
    return result;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c
// Address range: 0x80c5e90 - 0x80c608d
// Line range:    1570 - 1560
int32_t * get_uri(char * string, int32_t components) {
    // 0x80c5e90
    if (assert_failed == 0) {
        // 0x80c5eaf
        assert_failed = string == NULL;
        if (string == NULL) {
            // 0x80c5f88
            errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
            errline = 1574;
            elinks_internal("assertion string failed!");
        }
    }
    if (components != 0) {
        // 0x80c5fc0
        int32_t v1; // bp-88, 0x80c5e90
        int32_t v2 = parse_uri(&v1, string); // 0x80c5fca
        int32_t v3 = 0; // 0x80c5fd1
        if (v2 == 0) {
            // 0x80c5fd3
            v3 = (int32_t)get_composed_uri(&v1, components);
        }
        // 0x80c5f2f
        return (int32_t *)v3;
    }
    // 0x80c5ecb
    if (g75 == 0) {
        int32_t * v4 = init_hash8(); // 0x80c5fe8
        uri_cache = (int32_t)v4;
        if (v4 == NULL) {
            // 0x80c5f2f
            return (int32_t *)0;
        }
    }
    int32_t len = strlen(string); // 0x80c5edc
    if (assert_failed != 0) {
        // 0x80c5f69
        assert_failed = 0;
        goto lab_0x80c5f73;
    } else {
        bool v5 = string == NULL | len < 1;
        assert_failed = v5;
        if (v5) {
            // 0x80c5f40
            errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
            errline = 1543;
            elinks_internal("assertion string && length > 0 failed!");
            if (assert_failed == 0) {
                goto lab_0x80c5f05;
            } else {
                // 0x80c5f69
                assert_failed = 0;
                goto lab_0x80c5f73;
            }
        } else {
            goto lab_0x80c5f05;
        }
    }
  lab_0x80c5f73:
    // 0x80c5f73
    if (g75 == 0) {
        // 0x80c5fad
        free_hash((int32_t **)&uri_cache);
    }
    // 0x80c5f2f
    return (int32_t *)0;
  lab_0x80c5f05:;
    int32_t * v6 = get_hash_item((int32_t *)uri_cache, string, len); // 0x80c5f15
    int32_t v7; // 0x80c5e90
    if (v6 == NULL) {
        char * v8 = mem_calloc(1, len + 64); // 0x80c6016
        if (v8 == NULL) {
            goto lab_0x80c5f73;
        } else {
            int32_t v9 = (int32_t)v8; // 0x80c6016
            int32_t v10 = v9 + 60; // 0x80c6025
            char * v11 = (char *)v10; // 0x80c6028
            memcpy((int32_t *)v10, (int32_t *)string, len);
            if (parse_uri((int32_t *)v8, v11) != 0) {
                // 0x80c6080
                mem_free(v8);
                goto lab_0x80c5f73;
            } else {
                // 0x80c604e
                if (add_hash_item((int32_t *)uri_cache, v11, len, v8) == NULL) {
                    // 0x80c6080
                    mem_free(v8);
                    goto lab_0x80c5f73;
                } else {
                    // 0x80c606e
                    g75++;
                    v7 = v9;
                    goto lab_0x80c5f29;
                }
            }
        }
    } else {
        int32_t v12 = *(int32_t *)((int32_t)v6 + 16); // 0x80c5f22
        v7 = v12;
        if (v12 == 0) {
            goto lab_0x80c5f73;
        } else {
            goto lab_0x80c5f29;
        }
    }
  lab_0x80c5f29:;
    int32_t * v13 = (int32_t *)(v7 + 56); // 0x80c5f29
    *v13 = *v13 + 1;
    // 0x80c5f2f
    return (int32_t *)v7;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/protocol/user.c
// Address range: 0x80c6120 - 0x80c631f
// Line range:    96 - 86
char * get_user_program(int32_t * term, char * progid, int32_t progidlen) {
    int32_t v1 = 0; // 0x80c6133
    if (term != NULL) {
        // 0x80c6135
        v1 = *(int32_t *)((int32_t)term + 68) & 2;
    }
    // 0x80c613b
    char * v2; // bp-36, 0x80c6120
    if (init_string((int32_t *)&v2) == 0) {
        // 0x80c6230
        return NULL;
    }
    // 0x80c614e
    add_to_string((int32_t *)&v2, (int32_t)"protocol.user.");
    if (assert_failed == 0) {
        if (progid == NULL || progidlen < 0) {
            // 0x80c6240
            assert_failed = 1;
            errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
            errline = 255;
            elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
            if (assert_failed == 0) {
                goto lab_0x80c61d5;
            } else {
                goto lab_0x80c6168;
            }
        } else {
            // 0x80c61cb
            assert_failed = 0;
            goto lab_0x80c61d5;
        }
    } else {
        goto lab_0x80c6168;
    }
  lab_0x80c6168:
    // 0x80c6168
    assert_failed = 0;
    int32_t v3 = (int32_t)v2; // 0x80c616b
    goto lab_0x80c6175;
  lab_0x80c6175:;
    int32_t v4 = progidlen - 1; // 0x80c6177
    if (v4 >= 0) {
        int32_t v5 = v4; // 0x80c6184
        int32_t v6 = v3 + progidlen; // 0x80c6184
        while (true) {
            int32_t v7 = v5;
            char * v8 = (char *)(v6 + 13); // 0x80c6190
            int32_t v9; // 0x80c6120
            if (c_isupper((int32_t)*v8) == 0) {
                int32_t v10 = v7 - 1; // 0x80c618b
                v9 = v10;
                if (v10 < 0) {
                    // break -> 0x80c61dd
                    break;
                }
            } else {
                // 0x80c61a0
                *v8 = (char)c_tolower((int32_t)*v8);
                int32_t v11 = v7 - 1; // 0x80c61b2
                v9 = v11;
                if (v11 < 0) {
                    // break -> 0x80c61dd
                    break;
                }
            }
            // 0x80c6190
            v5 = v9;
            v6--;
        }
    }
    goto lab_0x80c61dd;
  lab_0x80c61d5:;
    int32_t v16; // 0x80c6283
    int32_t v15; // 0x80c6120
    if (progidlen != 0) {
        // 0x80c6280
        v16 = v15 + progidlen;
        uint32_t v17 = v15 + 255 & -256; // 0x80c6294
        uint32_t v18 = v16 + 256 & -256; // 0x80c629b
        if (v18 > v17) {
            char * v19 = mem_realloc(v2, v18); // 0x80c62eb
            if (v19 == NULL) {
                // 0x80c62d3
                v3 = (int32_t)v2;
                goto lab_0x80c6175;
            } else {
                // 0x80c62fa
                v2 = v19;
                memset((int32_t *)(v17 + (int32_t)v19), 0, v18 - v17);
                goto lab_0x80c62a2;
            }
        } else {
            goto lab_0x80c62a2;
        }
    } else {
        goto lab_0x80c61dd;
    }
  lab_0x80c61dd:
    // 0x80c61dd
    add_char_to_string((int32_t *)&v2, 46);
    char * v12 = get_system_str(v1); // 0x80c61f0
    add_to_string((int32_t *)&v2, (int32_t)v12);
    int32_t * v13 = get_opt_rec_real(config_options, v2); // 0x80c6210
    done_string((int32_t *)&v2);
    if (v13 == NULL) {
        // 0x80c6230
        return NULL;
    }
    // 0x80c6223
    return (char *)*(int32_t *)((int32_t)v13 + 32);
  lab_0x80c62a2:;
    int32_t v14 = (int32_t)v2; // 0x80c62a2
    v3 = v14;
    if (v2 == NULL) {
        goto lab_0x80c6175;
    } else {
        // 0x80c62ad
        memcpy((int32_t *)(v15 + v14), (int32_t *)progid, progidlen);
        *(char *)(v16 + (int32_t)v2) = 0;
        // 0x80c62d3
        v3 = (int32_t)v2;
        goto lab_0x80c6175;
    }
}

// Address range: 0x80cd909 - 0x80cd977
// From class:    Sorry, but auth entry "%s" is being used by something else.
// Type:          virtual member function
int32_t function_80cd909(void) {
    // 0x80cd909
    int32_t v1; // 0x80cd909
    int32_t str = v1;
    memchr((int32_t *)str, 58, v1 - str);
    int32_t v2 = v1 - 76; // 0x80cd938
    int32_t result = parse_time((char **)(v1 - 28), (struct tm *)v2, (char *)v1); // 0x80cd949
    *(int32_t *)v2 = 0;
    *(int32_t *)(v1 - 72) = 0;
    *(int32_t *)(v1 - 68) = 0;
    *(int32_t *)(v1 - 100) = 4;
    return result;
}

// Address range: 0x80cd977 - 0x80cd995
// From class:    Sorry, but auth entry "%s" is being used by something else.
// Type:          virtual member function
int32_t function_80cd977(void) {
    // 0x80cd977
    int32_t v1; // 0x80cd977
    int32_t result = parse_day((char **)(v1 - 28), (char *)v1); // 0x80cd981
    *(int32_t *)(v1 - 100) = 3;
    *(int32_t *)(v1 - 64) = result;
    return result;
}

// Address range: 0x80cd995 - 0x80cd9d6
// From class:    Sorry, but auth entry "%s" is being used by something else.
// Type:          virtual member function
int32_t function_80cd995(void) {
    // 0x80cd995
    int32_t result; // 0x80cd995
    int32_t * v1 = (int32_t *)(result - 100); // 0x80cd99c
    *v1 = 1;
    *(int32_t *)(*(int32_t *)(result + 8) + 36) = 0;
    *v1 = 1;
    return result;
}

// Address range: 0x80cd9d6 - 0x80cda2f
// From class:    Sorry, but auth entry "%s" is being used by something else.
// Type:          virtual member function
int32_t function_80cd9d6(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x80cd9d6
    int32_t v1; // 0x80cd9d6
    int32_t * v2 = (int32_t *)(v1 + 8); // 0x80cd9d6
    int32_t v3 = *v2; // 0x80cd9d6
    *(int32_t *)(v3 + 8) = v1 - *(int32_t *)(v1 - 28);
    switch (*(int32_t *)v3) {
        case 100: {
            // 0x80cd9ef
            function_80cdf00();
            // break -> 0x80cda01
            break;
        }
        case 108: {
            // 0x80cd9f8
            function_80cde45();
            // break -> 0x80cda01
            break;
        }
        case 45: {
            function_80cde19();
            // break -> 0x80cda01
            break;
        }
    }
    // 0x80cda01
    if (*(int32_t *)(v1 - 56) == 0) {
        function_80cdde2();
    }
    int32_t time_info = mktime((struct tm *)(v1 - 76)); // 0x80cda12
    int32_t v4 = *v2; // 0x80cda17
    char * v5 = (char *)(v4 + 32); // 0x80cda1a
    *v5 = *v5 | 1;
    *(int32_t *)(v4 + 28) = time_info;
    return *v2;
}

// Address range: 0x80cda2f - 0x80cdb01
// From class:    Sorry, but auth entry "%s" is being used by something else.
// Type:          virtual member function
int32_t function_80cda2f(void) {
    // 0x80cda2f
    int32_t v1; // 0x80cda2f
    int32_t * v2 = (int32_t *)(v1 - 28); // 0x80cda4a
    int32_t v3 = *v2; // 0x80cda4a
    char v4 = *(char *)v3; // 0x80cda4d
    if (v4 >= 58) {
        function_80cdd8d();
    }
    int32_t * v5 = (int32_t *)(v1 - 136); // 0x80cda6e
    *v5 = 0;
    int32_t * v6 = (int32_t *)(v1 - 132); // 0x80cda76
    *v6 = 0;
    int32_t * v7 = (int32_t *)(v1 - 92); // 0x80cdaaa
    int32_t v8 = v3; // 0x80cda7c
    int32_t v9 = (int32_t)v4 - 48; // 0x80cdaa5
    *v7 = *v5 / 0x1999999a;
    int32_t v10 = v9 >> 31; // 0x80cdaaf
    *v5 = v9;
    uint32_t v11 = *(int32_t *)(v1 - 96) + v9; // 0x80cdabb
    *v5 = v11;
    *v6 = v10;
    int32_t v12 = *v7 + v10 + (int32_t)(v11 < v9); // 0x80cdaca
    *v6 = v12;
    v8++;
    while (v8 < v1) {
        char v13 = *(char *)v8; // 0x80cda80
        if (v13 >= 58) {
            // break -> 0x80cdad7
            break;
        }
        v9 = (int32_t)v13 - 48;
        *v7 = 10 * v12 + *v5 / 0x1999999a;
        v10 = v9 >> 31;
        *v5 = v9;
        v11 = *(int32_t *)(v1 - 96) + v9;
        *v5 = v11;
        *v6 = v10;
        v12 = *v7 + v10 + (int32_t)(v11 < v9);
        *v6 = v12;
        v8++;
    }
    int32_t result = *v5; // 0x80cdae2
    *v2 = v8;
    int32_t v14 = *(int32_t *)(v1 + 8); // 0x80cdaf3
    *(int32_t *)(v14 + 20) = result;
    *(int32_t *)(v14 + 24) = v12;
    return result;
}

// Address range: 0x80cdd8d - 0x80cdda3
int32_t function_80cdd8d(void) {
    // 0x80cdd8d
    int32_t result; // 0x80cdd8d
    int32_t v1 = *(int32_t *)(result + 8); // 0x80cdd8d
    *(int32_t *)(v1 + 20) = -1;
    *(int32_t *)(v1 + 24) = -1;
    return result;
}

// Address range: 0x80cdde2 - 0x80cde19
int32_t function_80cdde2(void) {
    int32_t time_val = time(NULL); // 0x80cdde9
    int32_t v1; // 0x80cdde2
    int32_t * timep = (int32_t *)(v1 - 32); // 0x80cddee
    *timep = time_val;
    int32_t time_info = (int32_t)localtime(timep); // 0x80cddf7
    *(int32_t *)(v1 - 56) = *(int32_t *)(time_info + 20) - 1;
    return time_info;
}

// Address range: 0x80cde19 - 0x80cde45
int32_t function_80cde19(void) {
    // 0x80cde19
    int32_t result; // 0x80cde19
    *(int32_t *)(*(int32_t *)(result + 8) + 8) = result - 1;
    return result;
}

// Address range: 0x80cde45 - 0x80cdf00
int32_t function_80cde45(void) {
    // 0x80cde45
    bool v1; // 0x80cde45
    int32_t v2 = v1 ? -1 : 1; // 0x80cde9a
    int32_t v3; // 0x80cde45
    int32_t v4; // 0x80cde45
    while (true) {
        // 0x80cde8e
        int32_t found_byte_pos; // 0x80cde45
        v3 = found_byte_pos;
        int32_t v5 = 4; // 0x80cde9a
        int32_t v6 = v3;
        int32_t v7 = (int32_t)" -> ";
        while (*(char *)v6 == *(char *)v7) {
            v5--;
            if (v5 == 0) {
                // break (via goto) -> 0x80cde9e
                goto lab_0x80cde9e;
            }
            v6 += v2;
            v7 += v2;
        }
        // 0x80cde60
        found_byte_pos = (int32_t)memchr((int32_t *)(v3 + 1), 32, v4 - v3);
    }
  lab_0x80cde9e:;
    int32_t * v8 = (int32_t *)(v4 + 8); // 0x80cde9e
    int32_t v9 = *v8; // 0x80cde9e
    *(int32_t *)(v9 + 12) = v3 + 4;
    *(int32_t *)(v9 + 16) = v4 - 4 - v3;
    *(int32_t *)(v9 + 8) = v3 - *(int32_t *)(v4 - 28);
    int32_t * v10 = (int32_t *)(*v8 + 16); // 0x80cdedc
    int32_t result = *v10 - 1; // 0x80cdef5
    *v10 = result;
    return result;
}

// Address range: 0x80cdf00 - 0x80cdf21
int32_t function_80cdf00(void) {
    // 0x80cdf00
    int32_t result; // 0x80cdf00
    *(int32_t *)(*(int32_t *)(result + 8) + 8) = result - 1;
    return result;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/session/download.c
// Address range: 0x80d49f0 - 0x80d4aad
// Line range:    127 - 154
void abort_download(int32_t * file_download) {
    int32_t v1 = (int32_t)file_download;
    done_download_display(file_download);
    int32_t v2 = *(int32_t *)(v1 + 24); // 0x80d4a02
    if (v2 != 0) {
        // 0x80d4a09
        check_questions_queue((int32_t *)v2);
    }
    int32_t v3 = *(int32_t *)(v1 + 108); // 0x80d4a11
    if (v3 != 0) {
        // 0x80d4a18
        cancel_dialog(v3, 0);
    }
    char * v4 = (char *)(v1 + 104); // 0x80d4a28
    cancel_download((int32_t *)(v1 + 56), (int32_t)(*v4 / 2 % 2));
    int32_t v5 = *(int32_t *)(v1 + 12); // 0x80d4a40
    if (v5 != 0) {
        // 0x80d4a47
        done_uri((int32_t *)v5);
    }
    int32_t fd = *(int32_t *)(v1 + 44); // 0x80d4a4f
    if (fd != -1) {
        // 0x80d4a57
        close(fd);
    }
    int32_t v6 = *(int32_t *)(v1 + 20); // 0x80d4a5f
    if (v6 != 0) {
        // 0x80d4a66
        mem_free((char *)v6);
    }
    int32_t * v7 = (int32_t *)(v1 + 16); // 0x80d4a6e
    int32_t path = *v7; // 0x80d4a6e
    if (path != 0) {
        int32_t v8 = path; // 0x80d4a79
        if (*v4 % 2 != 0) {
            // 0x80d4aa0
            unlink((char *)path);
            v8 = *v7;
        }
        // 0x80d4a7b
        mem_free((char *)v8);
    }
    int32_t * v9 = (int32_t *)(v1 + 4); // 0x80d4a85
    *(int32_t *)(*file_download + 4) = *v9;
    *(int32_t *)*v9 = *file_download;
    mem_free((char *)file_download);
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/session/download.c
// Address range: 0x80d4b10 - 0x80d4bf2
// Line range:    223 - 238
void detach_downloads_from_terminal(int32_t * term) {
    // 0x80d4b10
    if (assert_failed != 0) {
        // 0x80d4bb0
        assert_failed = 0;
        return;
    }
    // 0x80d4b2a
    assert_failed = term == NULL;
    if (term != NULL) {
        // 0x80d4b78
        return;
    }
    // 0x80d4b80
    errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/session/download.c";
    errline = 227;
    elinks_internal("assertion term != NULL failed!");
    if (assert_failed == 0) {
        // 0x80d4b78
        return;
    }
    // 0x80d4bb0
    assert_failed = 0;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/session/download.c
// Address range: 0x80d4cd0 - 0x80d4cfe
// Line range:    178 - 182
void abort_all_downloads(void) {
    // 0x80d4cd0
    return;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/session/session.c
// Address range: 0x80d7010 - 0x80d70b0
// Line range:    1346 - 1350
char * get_current_title(int32_t * ses, char * str, int32_t str_size) {
    int32_t * v1 = current_frame(ses); // 0x80d7028
    if (assert_failed == 0) {
        bool v2 = str == NULL | str_size == 0;
        assert_failed = v2;
        if (v2) {
            // 0x80d7088
            errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/session/session.c";
            errline = 1350;
            elinks_internal("assertion str && str_size > 0 failed!");
        }
    }
    if (v1 == NULL) {
        // 0x80d7054
        return NULL;
    }
    int32_t v3 = *(int32_t *)(*(int32_t *)((int32_t)v1 + 20) + 188); // 0x80d7063
    if (v3 == 0) {
        // 0x80d7054
        return NULL;
    }
    // 0x80d706d
    return safe_strncpy(str, (char *)v3, str_size);
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/session/session.c
// Address range: 0x80d70b0 - 0x80d717c
// Line range:    1320 - 316
char * get_current_url(int32_t * ses, char * str, int32_t str_size) {
    int32_t v1 = (int32_t)ses;
    int32_t v2; // 0x80d70b0
    if (assert_failed != 0) {
        goto lab_0x80d70ea;
    } else {
        bool v3 = str == NULL | str_size == 0;
        assert_failed = v3;
        if (v3) {
            // 0x80d7130
            errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/session/session.c";
            errline = 1325;
            elinks_internal("assertion str && str_size > 0 failed!");
            int32_t v4 = *(int32_t *)(v1 + 20); // 0x80d7150
            v2 = v4;
            if (v4 != 0) {
                goto lab_0x80d70f1;
            } else {
                goto lab_0x80d7158;
            }
        } else {
            goto lab_0x80d70ea;
        }
    }
  lab_0x80d70ea:;
    int32_t v5 = *(int32_t *)(v1 + 20); // 0x80d70ea
    v2 = v5;
    if (v5 == 0) {
        goto lab_0x80d7158;
    } else {
        goto lab_0x80d70f1;
    }
  lab_0x80d7158:;
    int32_t v6 = *(int32_t *)(v1 + 80); // 0x80d7158
    int32_t v7 = v6; // 0x80d715d
    if (v6 == 0) {
        // 0x80d7160
        return NULL;
    }
    goto lab_0x80d70f8;
  lab_0x80d70f1:;
    int32_t v14 = *(int32_t *)(v2 + 68); // 0x80d70f1
    v7 = v14;
    if (v14 == 0) {
        // 0x80d7160
        return NULL;
    }
    goto lab_0x80d70f8;
  lab_0x80d70f8:;
    int32_t v8 = *(int32_t *)(v7 + 36); // 0x80d70f8
    int32_t v9 = *(int32_t *)v7;
    if (v8 == 0) {
        char * str2 = (char *)v9;
        int32_t len = strlen(str2); // 0x80d7175
    }
    int32_t v10 = v8 + -1 - v9;
    int32_t v11 = str_size - 1; // 0x80d7106
    int32_t v12 = v10 - v11; // 0x80d7109
    int32_t v13 = v12 == 0 | v12 < 0 != ((v12 ^ v10) & (v10 ^ v11)) < 0 ? v10 : v11; // 0x80d710b
    return safe_strncpy(str, (char *)v9, v13 + 1);
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/session/session.c
// Address range: 0x80d74d0 - 0x80d7529
// Line range:    484 - 493
void check_questions_queue(int32_t * ses) {
    // 0x80d74d0
    return;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/session/session.c
// Address range: 0x80d7610 - 0x80d765f
// Line range:    127 - 135
void done_session_info(int32_t * info) {
    // 0x80d7610
    int32_t v1; // 0x80d7610
    int32_t v2 = *(int32_t *)(v1 + 4); // 0x80d761b
    *(int32_t *)v2 = v2;
    kill_timer((int32_t **)(v1 + 12));
    int32_t v3 = *(int32_t *)(v1 + 20); // 0x80d7633
    if (v3 != 0) {
        // 0x80d763a
        done_uri((int32_t *)v3);
    }
    int32_t v4 = *(int32_t *)(v1 + 24); // 0x80d7642
    if (v4 != 0) {
        // 0x80d7649
        done_uri((int32_t *)v4);
    }
    // 0x80d7651
    mem_free((char *)v1);
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/session/session.c
// Address range: 0x80d76d0 - 0x80d76fb
// Line range:    138 - 142
void done_saved_session_info(void) {
    // 0x80d76d0
    return;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/terminal/color.c
// Address range: 0x80daba0 - 0x80db18c
// Line range:    292 - 396
void set_term_color(int32_t * schar, int32_t * pair, uint32_t flags, uint32_t color_mode) {
    uint32_t v1 = color_mode + 1; // 0x80dabc4
    if (assert_failed == 0) {
        // 0x80dabd1
        assert_failed = v1 >= 6;
        if (v1 >= 6) {
            // 0x80db0b0
            errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/terminal/color.c";
            errline = 299;
            elinks_internal("assertion color_mode >= COLOR_MODE_DUMP && color_mode < COLOR_MODES failed!");
        }
    }
    int32_t v2 = (int32_t)schar;
    g85 = v1;
    int32_t v3; // 0x80daba0
    int32_t v4; // 0x80daba0
    int32_t v5; // 0x80daba0
    switch (color_mode) {
        case -1: {
            return;
        }
        case 0: {
            if (flags % 2 == 0) {
                // 0x80dabfc
                v5 = 0;
                goto lab_0x80dac03;
            } else {
                char * v6 = (char *)(v2 + 4); // 0x80db04d
                *v6 = *v6 | 64;
                v3 = 1;
                v4 = 1;
                if (assert_failed != 0) {
                    goto lab_0x80dac23;
                } else {
                    goto lab_0x80dac0c;
                }
            }
        }
        case 2: {
            // 0x80dabfc
            v5 = 0;
            goto lab_0x80dac03;
        }
        case 3: {
            // 0x80dabfc
            v5 = 0;
            goto lab_0x80dac03;
        }
        case 5: {
            return;
        }
        default: {
            // 0x80dabef
            v5 = 1;
            if (flags % 2 != 0) {
                goto lab_0x80dac03;
            } else {
                // 0x80dabfc
                v5 = 0;
                goto lab_0x80dac03;
            }
        }
    }
  lab_0x80dac03:
    // 0x80dac03
    v3 = v5;
    v4 = v5;
    if (assert_failed != 0) {
        goto lab_0x80dac23;
    } else {
        goto lab_0x80dac0c;
    }
  lab_0x80dac23:;
    int32_t v7 = *(int32_t *)(4 * color_mode + (int32_t)&color_modes); // 0x80dac2c
    int32_t * v8 = (int32_t *)v7; // 0x80dac33
    int32_t v9 = 8 * v4 + v7;
    uint32_t v10 = *(int32_t *)(v9 + 8); // 0x80dac36
    uint32_t v11 = *(int32_t *)((int32_t)pair + 4); // 0x80dac3d
    int32_t v12 = *v8; // 0x80dac40
    uint32_t v13 = v11 / 0x10000 % 256; // 0x80dac4e
    uint32_t v14 = v11 / 256 % 256; // 0x80dac51
    uint32_t v15 = v11 % 256; // 0x80dac54
    int32_t v16 = 12 * ((v15 + v10 + 8 * v13 + 4 * v14) % 0x1000); // 0x80dac6c
    int32_t * v17 = (int32_t *)(v16 + (int32_t)&g76 + 4); // 0x80dac7d
    int32_t v18 = *v17; // 0x80dac7d
    int32_t v19; // 0x80daba0
    char v20; // 0x80daba0
    if (v18 == 0 || v10 != v18) {
        goto lab_0x80dac88;
    } else {
        // 0x80db021
        if (*(int32_t *)(v16 + (int32_t)&g76 + 8) != v11) {
            goto lab_0x80dac88;
        } else {
            // 0x80db02d
            v20 = *(char *)(v16 + (int32_t)&g76);
            v19 = v12;
            goto lab_0x80dad77;
        }
    }
  lab_0x80dac0c:
    // 0x80dac0c
    assert_failed = schar == NULL;
    v4 = v3;
    if (schar == NULL) {
        // 0x80db0f0
        errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/terminal/color.c";
        errline = 366;
        elinks_internal("assertion schar failed!");
        v4 = v3;
    }
    goto lab_0x80dac23;
  lab_0x80dac88:;
    char v21 = 0; // 0x80daca0
    int32_t v22 = 0; // 0x80daca0
    if (v10 >= 2) {
        int32_t v23 = v12 + 2; // 0x80dac98
        int32_t v24 = v12 + 1; // 0x80dac90
        int32_t v25 = v15 - (int32_t)*(char *)v23; // 0x80dacc1
        int32_t v26 = v14 - (int32_t)*(char *)v24; // 0x80dacd1
        int32_t v27 = v13 - (int32_t)*(char *)v12; // 0x80dacd8
        char v28 = 0; // 0x80dacf7
        int32_t v29 = 1; // 0x80dacf7
        int32_t v30 = 4 * v26 * v26 + 2 * v25 * v25 + 3 * v27 * v27; // 0x80dacf7
        char v31; // 0x80daba0
        while (true) {
            int32_t v32 = v30;
            int32_t v33 = v29;
            int32_t v34 = 4 * v33; // 0x80dad0e
            int32_t v35 = v13 - (int32_t)*(char *)(v34 + v12); // 0x80dad1d
            int32_t v36 = v14 - (int32_t)*(char *)(v34 + v24); // 0x80dad1f
            int32_t v37 = v15 - (int32_t)*(char *)(v34 + v23); // 0x80dad33
            int32_t v38 = 4 * v36 * v36 + 3 * v35 * v35 + 2 * v37 * v37; // 0x80dad40
            int32_t v39; // 0x80daba0
            int32_t v40; // 0x80daba0
            char v41; // 0x80daba0
            if (v38 < v32) {
                char v42 = v33;
                int32_t v43 = v33 + 1; // 0x80dad4b
                v41 = v42;
                v39 = v38;
                v40 = v43;
                v31 = v42;
                if (v43 == v10) {
                    // break -> 0x80dad53
                    break;
                }
            } else {
                int32_t v44 = v33 + 1; // 0x80dad00
                v41 = v28;
                v39 = v32;
                v40 = v44;
                v31 = v28;
                if (v44 == v10) {
                    // break -> 0x80dad53
                    break;
                }
            }
            // 0x80dad0b
            v28 = v41;
            v29 = v40;
            v30 = v39;
        }
        // 0x80dad53
        v21 = v31;
        v22 = v31;
    }
    // 0x80dad5a
    *(int32_t *)(v16 + (int32_t)&g76) = v22;
    *v17 = v10;
    *(int32_t *)(v16 + (int32_t)&g76 + 8) = v11;
    v20 = v21;
    v19 = *v8;
    goto lab_0x80dad77;
  lab_0x80dad77:;
    uint32_t v45 = *(int32_t *)(v9 + 4); // 0x80dad7d
    uint32_t v46 = *pair; // 0x80dad87
    uint32_t v47 = v46 / 0x10000 % 256; // 0x80dad95
    uint32_t v48 = v46 / 256 % 256; // 0x80dad98
    uint32_t v49 = v46 % 256; // 0x80dad9b
    int32_t v50 = 12 * ((v49 + v45 + 8 * v47 + 4 * v48) % 0x1000); // 0x80dadb2
    int32_t * v51 = (int32_t *)(v50 + (int32_t)&g76 + 4); // 0x80dadc3
    int32_t v52 = *v51; // 0x80dadc3
    int32_t v53; // 0x80daba0
    if (v52 == 0 || v45 != v52) {
        goto lab_0x80dadce;
    } else {
        // 0x80daff8
        if (*(int32_t *)(v50 + (int32_t)&g76 + 8) != v46) {
            goto lab_0x80dadce;
        } else {
            // 0x80db004
            v53 = (int32_t)*(char *)(v50 + (int32_t)&g76);
            goto lab_0x80daeb9;
        }
    }
  lab_0x80dadce:;
    int32_t v54 = 0; // 0x80dade7
    if (v45 >= 2) {
        int32_t v55 = v19 + 2; // 0x80daddf
        int32_t v56 = v19 + 1; // 0x80dadd6
        int32_t v57 = v49 - (int32_t)*(char *)v55; // 0x80dae12
        int32_t v58 = v47 - (int32_t)*(char *)v19; // 0x80dae1a
        int32_t v59 = v48 - (int32_t)*(char *)v56; // 0x80dae24
        char v60 = 0; // 0x80dae40
        int32_t v61 = 1; // 0x80dae40
        int32_t v62 = 4 * v59 * v59 + 2 * v57 * v57 + 3 * v58 * v58; // 0x80dae40
        char v63; // 0x80daba0
        while (true) {
            int32_t v64 = v62;
            int32_t v65 = v61;
            int32_t v66 = 4 * v65; // 0x80dae56
            int32_t v67 = v47 - (int32_t)*(char *)(v66 + v19); // 0x80dae65
            int32_t v68 = v48 - (int32_t)*(char *)(v66 + v56); // 0x80dae67
            int32_t v69 = v49 - (int32_t)*(char *)(v66 + v55); // 0x80dae7b
            int32_t v70 = 4 * v68 * v68 + 3 * v67 * v67 + 2 * v69 * v69; // 0x80dae88
            int32_t v71; // 0x80daba0
            int32_t v72; // 0x80daba0
            char v73; // 0x80daba0
            if (v70 < v64) {
                char v74 = v65;
                int32_t v75 = v65 + 1; // 0x80dae93
                v73 = v74;
                v71 = v70;
                v72 = v75;
                v63 = v74;
                if (v75 == v45) {
                    // break -> 0x80dae9b
                    break;
                }
            } else {
                int32_t v76 = v65 + 1; // 0x80dae48
                v73 = v60;
                v71 = v64;
                v72 = v76;
                v63 = v60;
                if (v76 == v45) {
                    // break -> 0x80dae9b
                    break;
                }
            }
            // 0x80dae53
            v60 = v73;
            v61 = v72;
            v62 = v71;
        }
        // 0x80dae9b
        v54 = v63;
    }
    // 0x80daea1
    *(int32_t *)(v50 + (int32_t)&g76) = v54;
    *v51 = v45;
    *(int32_t *)(v50 + (int32_t)&g76 + 8) = v46;
    v53 = v54;
    goto lab_0x80daeb9;
  lab_0x80daeb9:
    // 0x80daeb9
    if (color_mode < 4) {
        if (color_mode >= 2) {
            // 0x80dafca
            if (v20 != (char)v53) {
                // 0x80dafd6
                *(char *)(v2 + 5) = v20;
                *(char *)(v2 + 6) = (char)v53;
                return;
            }
            int32_t v77 = v20; // 0x80db11c
            if ((flags & 8) == 0) {
                // 0x80dafd6
                *(char *)(v2 + 5) = v20;
                *(char *)(v2 + 6) = (char)v77;
                return;
            }
            int32_t v78; // 0x80daba0
            char v79; // 0x80daba0
            if ((flags & 16) != 0) {
                // 0x80db15a
                v79 = v20;
                v78 = v20 == 0 ? 15 : 0;
            } else {
                // 0x80db12c
                v79 = v20 == 0 ? 15 : 0;
                v78 = v77;
            }
            // 0x80dafd6
            *(char *)(v2 + 5) = v79;
            *(char *)(v2 + 6) = (char)v78;
            return;
        }
        if (color_mode == -1) {
            // 0x80db080
            errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/terminal/color.c";
            errline = 375;
            elinks_internal("Bad color mode, it should _never_ occur here.");
            return;
        }
    } else {
        if (color_mode == 5) {
            // 0x80db080
            errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/terminal/color.c";
            errline = 375;
            elinks_internal("Bad color mode, it should _never_ occur here.");
            return;
        }
    }
    char v80 = v20; // 0x80daed8
    if ((flags & 4) != 0) {
        char v81 = *(char *)(v53 + (int32_t)&fg_color + 8 * (int32_t)v20); // 0x80daede
        v80 = v81;
    }
    char * v82 = (char *)(v2 + 4); // 0x80daeec
    unsigned char v83 = *v82; // 0x80daeec
    char v84 = v80; // 0x80daef2
    if (v83 != 0) {
        int32_t v85 = v83; // 0x80daeec
        char v86 = v80 ^ (char)((v85 & 16) != 0);
        char v87 = v86 | 8; // 0x80daf11
        char v88 = (v85 & 8) != 0 ? v87 : v86; // 0x80daf1e
        v84 = (flags & 2) == 0 | (v85 & 32) == 0 ? v88 : v87 ^ 4;
    }
    char v89 = v53;
    int32_t v90; // 0x80daba0
    int32_t v91; // 0x80daba0
    int32_t v92; // 0x80daba0
    char v93; // 0x80daba0
    if ((flags & 4) == 0) {
        if (v84 == v89) {
            // 0x80db168
            v93 = v89;
            v90 = v53;
            v91 = v53;
            v92 = v53;
            if ((flags & 8) != 0) {
                goto lab_0x80daf40;
            } else {
                goto lab_0x80daf62;
            }
        } else {
            // 0x80db0e3
            v93 = v84;
            v90 = v53;
            v91 = v84;
            v92 = v53;
            goto lab_0x80daf62;
        }
    } else {
        goto lab_0x80daf40;
    }
  lab_0x80daf40:;
    unsigned char v94 = *(char *)(v53 + (int32_t)&fg_color + 8 * (int32_t)v84);
    int32_t v95 = v94;
    v93 = (flags & 16) == 0 ? v94 : v89;
    v90 = (flags & 16) == 0 ? v53 : v95;
    v91 = (flags & 16) == 0 ? v95 : v53;
    v92 = (flags & 16) == 0 ? v53 : v95;
    goto lab_0x80daf62;
  lab_0x80daf62:;
    uint32_t v96 = v91;
    int32_t v97 = v96 & 8;
    if (v97 != 0 || (v96 / 4 % 2 || 2 * v96 & 6) < (v92 / 4 | 2 * v90) % 8) {
        char v98 = v83 | (char)v97;
        char v99 = (v96 / 4 % 2 | 2 * v96 & 6) < (v92 / 4 | 2 * v90) % 8 ? v98 | 64 : v98;
        *v82 = v99;
    }
    *(char *)(v2 + 5) = 16 * (char)v90 | v93;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/terminal/draw.c
// Address range: 0x80db260 - 0x80db3a5
// Line range:    562 - 572
void set_cursor(int32_t * term, int32_t x, int32_t y, int32_t blockable) {
    // 0x80db260
    if (assert_failed != 0) {
        // 0x80db348
        assert_failed = 0;
        // 0x80db352
        return;
    }
    int32_t v1 = (int32_t)term;
    if (term == NULL) {
        goto lab_0x80db310;
    } else {
        // 0x80db28e
        if (*(int32_t *)(v1 + 24) == 0) {
            goto lab_0x80db310;
        } else {
            // 0x80db295
            assert_failed = 0;
            goto lab_0x80db29f;
        }
    }
  lab_0x80db310:
    // 0x80db310
    assert_failed = 1;
    errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/terminal/draw.c";
    errline = 564;
    elinks_internal("assertion term && term->screen failed!");
    if (assert_failed != 0) {
        // 0x80db348
        assert_failed = 0;
        // 0x80db352
        return;
    }
    goto lab_0x80db29f;
  lab_0x80db29f:;
    int32_t v2; // 0x80db260
    int32_t v3; // 0x80db260
    int32_t v4; // 0x80db260
    int32_t v5; // 0x80db260
    int32_t v6; // 0x80db260
    int32_t v7; // 0x80db260
    if (blockable != 0) {
        // 0x80db360
        if (*(int32_t *)get_opt_(*(int32_t *)(v1 + 16), "block_cursor") == 0) {
            goto lab_0x80db2aa;
        } else {
            int32_t v8 = *(int32_t *)(v1 + 24); // 0x80db383
            int32_t v9 = *(int32_t *)(v1 + 44) - 1; // 0x80db386
            int32_t v10 = *(int32_t *)(v1 + 48) - 1; // 0x80db389
            v2 = v8;
            v6 = v9;
            v4 = v10;
            v3 = v8;
            v7 = v9;
            v5 = v10;
            if (*(int32_t *)(v8 + 8) != v9) {
                goto lab_0x80db2b6;
            } else {
                goto lab_0x80db398;
            }
        }
    } else {
        goto lab_0x80db2aa;
    }
  lab_0x80db2aa:;
    int32_t v11 = *(int32_t *)(v1 + 24); // 0x80db2aa
    v2 = v11;
    v6 = x;
    v4 = y;
    v3 = v11;
    v7 = x;
    v5 = y;
    if (*(int32_t *)(v11 + 8) == x) {
        goto lab_0x80db398;
    } else {
        goto lab_0x80db2b6;
    }
  lab_0x80db398:;
    int32_t v12 = *(int32_t *)(v3 + 12); // 0x80db398
    int32_t v13 = v3; // 0x80db39d
    int32_t v14 = v12; // 0x80db39d
    int32_t v15 = v7; // 0x80db39d
    int32_t v16 = v5; // 0x80db39d
    if (v12 == v5) {
        // 0x80db352
        return;
    }
    goto lab_0x80db2b9;
  lab_0x80db2b6:
    // 0x80db2b6
    v13 = v2;
    v14 = *(int32_t *)(v2 + 12);
    v15 = v6;
    v16 = v4;
    goto lab_0x80db2b9;
  lab_0x80db2b9:;
    uint32_t v17 = v16;
    int32_t v18 = v14;
    if (v15 >= 0) {
        // branch -> 0x80db2d0
    }
    int32_t v19 = 0; // 0x80db2da
    if (v17 >= 0) {
        int32_t v20 = *(int32_t *)(v1 + 48) - 1; // 0x80db2df
        int32_t v21 = v17 - v20; // 0x80db2e2
        int32_t v22 = v21 == 0 | v21 < 0 != ((v21 ^ v17) & (v20 ^ v17)) < 0 ? v17 : v20; // 0x80db2e4
        v19 = v22;
    }
    int32_t v23 = v19;
    int32_t v24 = v23 - v18; // 0x80db2e7
    int32_t v25 = v24 == 0 | v24 < 0 != ((v24 ^ v23) & (v23 ^ v18)) < 0 ? v23 : v18; // 0x80db2ee
    int32_t * v26 = (int32_t *)(v13 + 24); // 0x80db2f1
    if (v25 < *v26) {
        // 0x80db2f6
        *v26 = v25;
    }
    int32_t v27 = v24 < 0 == ((v24 ^ v23) & (v23 ^ v18)) < 0 ? v23 : v18; // 0x80db2eb
    int32_t * v28 = (int32_t *)(v13 + 28); // 0x80db2f9
    if (v27 > *v28) {
        // 0x80db2fe
        *v28 = v27;
    }
    int32_t * v29 = (int32_t *)(v1 + 24); // 0x80db301
    *(int32_t *)(*v29 + 8) = 0;
    *(int32_t *)(*v29 + 12) = v23;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/terminal/draw.c
// Address range: 0x80db3b0 - 0x80db595
// Line range:    360 - 86
void draw_box(int32_t * term, int32_t * box, unsigned char data, int32_t attr, int32_t * color) {
    // 0x80db3b0
    if (assert_failed != 0) {
        // 0x80db3d4
        assert_failed = 0;
        // 0x80db3e0
        return;
    }
    int32_t v1 = (int32_t)box;
    int32_t v2 = (int32_t)term;
    int32_t * v3 = (int32_t *)(v1 + 4); // 0x80db3cb
    uint32_t v4 = *v3; // 0x80db3cb
    uint32_t v5 = *box; // 0x80db3ce
    if (term == NULL) {
        goto lab_0x80db548;
    } else {
        int32_t v6 = *(int32_t *)(v2 + 24); // 0x80db3f0
        if (v6 == 0) {
            goto lab_0x80db548;
        } else {
            // 0x80db3fb
            if (*(int32_t *)v6 == 0) {
                goto lab_0x80db548;
            } else {
                // 0x80db405
                assert_failed = 0;
                goto lab_0x80db40f;
            }
        }
    }
  lab_0x80db548:
    // 0x80db548
    assert_failed = 1;
    errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/terminal/draw.c";
    errline = 39;
    elinks_internal("assertion term && term->screen && term->screen->image failed!");
    if (assert_failed != 0) {
        // 0x80db3d4
        assert_failed = 0;
        // 0x80db3e0
        return;
    }
    goto lab_0x80db40f;
  lab_0x80db40f:;
    int32_t * v7 = (int32_t *)(v2 + 44); // 0x80db413
    int32_t v8 = *v7; // 0x80db413
    int32_t v9 = 0; // 0x80db416
    if (v5 >= 0) {
        int32_t v10 = v8 - 1; // 0x80db418
        int32_t v11 = v10 - v5; // 0x80db41b
        v9 = v11 < 0 == ((v11 ^ v10) & (v10 ^ v5)) < 0 == (v11 != 0) ? v5 : v10;
    }
    int32_t v12 = *(int32_t *)(v2 + 48); // 0x80db424
    int32_t v13 = 0; // 0x80db427
    if (v4 >= 0) {
        int32_t v14 = v12 - 1; // 0x80db429
        int32_t v15 = v14 - v4; // 0x80db42c
        v13 = v15 < 0 == ((v15 ^ v14) & (v14 ^ v4)) < 0 == (v15 != 0) ? v4 : v14;
    }
    int32_t * v16 = (int32_t *)(v2 + 24); // 0x80db434
    int32_t v17 = 8 * (v13 * v8 + v9) + *(int32_t *)*v16; // 0x80db43c
    if (v17 == 0) {
        // 0x80db3e0
        return;
    }
    int32_t * v18 = (int32_t *)(v1 + 12); // 0x80db449
    int32_t v19 = *v18; // 0x80db449
    int32_t v20 = v12 - *v3; // 0x80db44c
    int32_t v21 = v20 - v19; // 0x80db451
    int32_t v22 = *(int32_t *)(v1 + 8); // 0x80db453
    int32_t v23 = v21 == 0 | v21 < 0 != ((v21 ^ v20) & (v20 ^ v19)) < 0 ? v20 : v19; // 0x80db456
    int32_t v24 = v8 - *box; // 0x80db459
    int32_t v25 = v24 - v22; // 0x80db45d
    int32_t v26 = v25 == 0 | v25 < 0 != ((v25 ^ v24) & (v24 ^ v22)) < 0 ? v24 : v22; // 0x80db45f
    if (v23 < 1 || v26 < 1) {
        // 0x80db3e0
        return;
    }
    int32_t v27 = 8 * v26; // 0x80db475
    uint32_t v28 = v17 - 8 + v27; // 0x80db475
    int32_t v29 = v28 + 4; // 0x80db47c
    *(char *)v29 = (char)attr;
    int32_t * v30 = (int32_t *)v28; // 0x80db483
    *v30 = (int32_t)data;
    if (color == NULL) {
        // 0x80db588
        *(int16_t *)(v28 + 5) = 0;
    } else {
        int32_t v31 = get_opt_(*(int32_t *)(v2 + 16), "colors"); // 0x80db4a1
        set_term_color(v30, color, 0, *(int32_t *)v31);
    }
    if (v28 > v17) {
        for (int32_t i = v17; i < v28; i += 8) {
            // 0x80db4d0
            *(int32_t *)i = *v30;
            *(int32_t *)(i + 4) = *(int32_t *)v29;
        }
    }
    int32_t v32 = v23 - 1; // 0x80db4e3
    if (v32 != 0) {
        int32_t v33 = v32; // 0x80db514
        int32_t v34 = v17; // 0x80db502
        v34 += 8 * *v7;
        memcpy((int32_t *)v34, (int32_t *)v17, v27);
        v33--;
        while (v33 != 0) {
            // 0x80db4f8
            v34 += 8 * *v7;
            memcpy((int32_t *)v34, (int32_t *)v17, v27);
            v33--;
        }
    }
    int32_t v35 = *v16; // 0x80db521
    int32_t v36 = *v3; // 0x80db524
    int32_t * v37 = (int32_t *)(v35 + 24); // 0x80db52c
    if (v36 < *v37) {
        // 0x80db531
        *v37 = v36;
    }
    int32_t v38 = *v18 + v36; // 0x80db52a
    int32_t * v39 = (int32_t *)(v35 + 28); // 0x80db534
    if (v38 <= *v39) {
        // 0x80db3e0
        return;
    }
    // 0x80db53d
    *v39 = v38;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/terminal/draw.c
// Address range: 0x80db5a0 - 0x80db61d
// Line range:    583 - 590
void clear_terminal(int32_t * term) {
    int32_t v1 = 0; // bp-28, 0x80db5b5
    draw_box(term, &v1, 32, 0, NULL);
    set_cursor(term, 0, 0, 1);
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/terminal/event.c
// Address range: 0x80dcc50 - 0x80dcef2
// Line range:    64 - 130
void term_send_event(int32_t * term, int32_t * ev) {
    // 0x80dcc50
    if (assert_failed != 0) {
        // 0x80dcd98
        assert_failed = 0;
        return;
    }
    bool v1 = term == NULL | ev == NULL;
    assert_failed = v1;
    int32_t v2; // 0x80dcc50
    if (v1) {
        // 0x80dcdb0
        errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/terminal/event.c";
        errline = 68;
        elinks_internal("assertion ev && term failed!");
        if (assert_failed != 0) {
            // 0x80dcd98
            assert_failed = 0;
            return;
        }
        uint32_t v3 = *ev; // 0x80dcdda
        v2 = v3;
        if (v3 >= 6) {
            // 0x80dcd4e
            return;
        }
    } else {
        uint32_t v4 = *ev; // 0x80dcc89
        v2 = v4;
        if (v4 >= 6) {
            // 0x80dcd4e
            return;
        }
    }
    int32_t v5 = (int32_t)term;
    uint32_t v6 = v2 % 32; // 0x80dcc99
    int32_t v7 = 1 << v6;
    if ((v7 & 38) != 0) {
        int32_t v8 = v5 + 8; // 0x80dcd58
        int32_t * v9 = (int32_t *)v8; // 0x80dcd5b
        int32_t v10 = *v9; // 0x80dcd5b
        assert_failed = v10 == v8;
        if (v10 == v8) {
            // 0x80dcd6d
            errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/terminal/event.c";
            errline = 121;
            elinks_internal("assertion !list_empty(term->windows) failed!");
            if (assert_failed != 0) {
                // 0x80dcd98
                assert_failed = 0;
                return;
            }
        }
        // 0x80dcde8
        if (*(int32_t *)(*v9 + 8) != 1) {
            // 0x80dcd4e
            return;
        }
        int32_t * v11 = get_tab_by_number(term, *(int32_t *)(v5 + 60)); // 0x80dce92
        if (assert_failed != 0) {
            // 0x80dcd98
            assert_failed = 0;
            return;
        }
        // 0x80dcea5
        assert_failed = v11 == NULL;
        if (v11 != NULL) {
            // 0x80dcd4e
            return;
        }
        // 0x80dceba
        errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/terminal/event.c";
        errline = 129;
        elinks_internal("assertion win != NULL failed: No tab to send the event to!");
        if (assert_failed == 0) {
            // 0x80dcd4e
            return;
        }
        // 0x80dcd98
        assert_failed = 0;
        return;
    }
    if ((v7 & 17) == 0) {
        if (v6 != 3) {
            // 0x80dcd4e
            return;
        }
    } else {
        int32_t v12 = (int32_t)ev;
        int32_t v13 = *(int32_t *)(v12 + 8); // 0x80dccab
        int32_t v14 = *(int32_t *)(v12 + 4); // 0x80dccae
        if (v13 < 0 || v14 < 0) {
            // 0x80dce18
            errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/terminal/event.c";
            errline = 79;
            elinks_error(gettext("Bad terminal size: %d, %d"));
            // 0x80dcd4e
            return;
        }
        // 0x80dccc1
        resize_screen(term, v14, v13);
        erase_screen(term);
    }
    // 0x80dccd9
    if (*(int32_t *)*(int32_t *)(v5 + 24) == 0) {
        // 0x80dcd4e
        return;
    }
    // 0x80dcce2
    clear_terminal(term);
    int32_t * v15 = (int32_t *)(v5 + 52); // 0x80dccea
    *v15 = 2;
    int32_t v16 = *(int32_t *)(v5 + 12);
    int32_t v17 = v5 + 8;
    int32_t v18; // 0x80dcc50
    int32_t v19; // 0x80dcc50
    if (*ev == 4) {
        // 0x80dce58
        if (v17 != v16) {
            int32_t v20 = *(int32_t *)(v16 + 4); // 0x80dce7a
            int32_t v21 = v20; // 0x80dce80
            while (v17 != v20) {
                // 0x80dce70
                v20 = *(int32_t *)(v21 + 4);
                v21 = v20;
            }
        }
    } else {
        // 0x80dccfa
        v18 = v16;
        if (v16 != v17) {
            while (true) {
              lab_0x80dcd2e_2:
                // 0x80dcd2e
                v19 = v18;
                if (*(int32_t *)(v19 + 8) != 0) {
                    int32_t v22 = *(int32_t *)(v19 + 20); // 0x80dcd10
                    int32_t v23 = *(int32_t *)(v22 + 60); // 0x80dcd13
                    if (v19 == (int32_t)get_tab_by_number((int32_t *)v22, v23)) {
                        goto lab_0x80dcd35;
                    } else {
                        int32_t v24 = *(int32_t *)(v19 + 4); // 0x80dcd26
                        if (v24 == v17) {
                            // break -> 0x80dcd47
                            break;
                        }
                        // 0x80dcd2e
                        v18 = v24;
                        goto lab_0x80dcd2e_2;
                    }
                } else {
                    goto lab_0x80dcd35;
                }
            }
        }
    }
  lab_0x80dcd47:
    // 0x80dcd47
    *v15 = 0;
  lab_0x80dcd35:;
    int32_t v25 = *(int32_t *)(v19 + 4); // 0x80dcd3f
    if (v25 == v17) {
        // break -> 0x80dcd47
        goto lab_0x80dcd47;
    }
    // 0x80dcd2e
    v18 = v25;
    goto lab_0x80dcd2e_2;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/terminal/hardio.c
// Address range: 0x80dd8e0 - 0x80dd9b2
// Line range:    98 - 111
int32_t hard_write(int32_t fd, char * data, int32_t datalen) {
    // 0x80dd8e0
    if (assert_failed != 0) {
        // 0x80dd8f9
        assert_failed = 0;
        return -1;
    }
    // 0x80dd910
    assert_failed = data == NULL;
    if (data == NULL) {
        // 0x80dd975
        errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/terminal/hardio.c";
        errline = 102;
        elinks_internal("assertion data && datalen >= 0 failed!");
        if (assert_failed != 0) {
            // 0x80dd8f9
            assert_failed = 0;
            return -1;
        }
    }
    // 0x80dd920
    if (datalen == 0) {
        // 0x80dd968
        return datalen;
    }
    int32_t buf = (int32_t)data; // 0x80dd925
    int32_t nbyte = datalen;
    int32_t v1 = write(fd, (int32_t *)buf, nbyte); // 0x80dd933
    while (v1 == -1) {
        // 0x80dd93d
        if (*__errno_location() != 4) {
            // 0x80dd947
            return -1;
        }
        v1 = write(fd, (int32_t *)buf, nbyte);
    }
    while (v1 >= 1) {
        int32_t v2 = nbyte - v1; // 0x80dd95d
        if (v2 == 0) {
            // 0x80dd968
            return datalen;
        }
        // 0x80dd961
        buf += v1;
        nbyte = v2;
        v1 = write(fd, (int32_t *)buf, nbyte);
        while (v1 == -1) {
            // 0x80dd93d
            if (*__errno_location() != 4) {
                // 0x80dd947
                return -1;
            }
            v1 = write(fd, (int32_t *)buf, nbyte);
        }
    }
    // 0x80dd9a4
    if (v1 == 0) {
        // 0x80dd968
        return datalen - nbyte;
    }
    // 0x80dd947
    return -1;
}

// Address range: 0x80dd9c0 - 0x80dd9d8
int32_t is_blocked(void) {
    int32_t result = 0; // 0x80dd9cd
    if (ditrm != NULL) {
        // 0x80dd9cf
        result = g78 % 2;
    }
    // 0x80dd9d6
    return result;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/terminal/kbd.c
// Address range: 0x80dd9e0 - 0x80dda4e
// Line range:    181 - 195
void send_done_sequence(int32_t h, int32_t altscreen) {
    // 0x80dd9e0
    int32_t v1; // 0x80dd9e0
    hard_write(v1, (char *)&g17, 4);
    send_mouse_done_sequence(v1);
    if (v1 != 0) {
        // 0x80dda14
        hard_write(v1, (char *)&g18, 6);
    }
    // 0x80dda2c
    hard_write(v1, (char *)&g19, 5);
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/terminal/kbd.c
// Address range: 0x80ddca0 - 0x80ddd78
// Line range:    212 - 86
void get_terminal_name(char * name) {
    int32_t v1 = (int32_t)name;
    char * env_val = getenv("TERM"); // 0x80ddcb3
    int32_t v2; // 0x80ddca0
    int32_t v3; // 0x80ddca0
    int32_t v4; // 0x80ddca0
    int32_t v5; // 0x80ddca0
    if (v1 % 2 != 0) {
        int32_t v6 = v1 + 1; // 0x80ddd50
        *name = 0;
        v2 = 31;
        v4 = v6;
        v3 = 29;
        v5 = v6;
        if ((v6 & 2) == 0) {
            goto lab_0x80ddcd3;
        } else {
            goto lab_0x80ddd68;
        }
    } else {
        // 0x80ddcca
        v2 = 32;
        v4 = v1;
        v3 = 30;
        v5 = v1;
        if ((v1 & 2) != 0) {
            goto lab_0x80ddd68;
        } else {
            goto lab_0x80ddcd3;
        }
    }
  lab_0x80ddcd3:;
    int32_t v7 = 0; // 0x80ddcd7
    *(int32_t *)(v7 + v4) = 0;
    int32_t v8 = v7 + 4; // 0x80ddce1
    v7 = v8;
    while (v8 < (v2 & -4)) {
        // 0x80ddcda
        *(int32_t *)(v7 + v4) = 0;
        v8 = v7 + 4;
        v7 = v8;
    }
    int32_t v9 = v8 + v4; // 0x80ddce8
    int32_t v10 = v9; // 0x80ddced
    if ((v2 & 2) != 0) {
        // 0x80ddcef
        *(int16_t *)v9 = 0;
        v10 = v9 + 2;
    }
    if (v2 % 2 != 0) {
        // 0x80ddcfc
        *(char *)v10 = 0;
    }
    if (env_val == NULL) {
        // 0x80ddd45
        return;
    }
    char v11 = *env_val; // 0x80ddd03
    if (v11 == 0) {
        // 0x80ddd45
        return;
    }
    char v12 = v11;
    uint32_t v13 = 0;
    char v14 = v12; // 0x80ddd19
    if (v12 >= 58 && (v12 & -33) >= 91) {
        // 0x80ddd29
        v14 = v12 != 95 ? 45 : v12;
    }
    int32_t v15 = v13 + 1; // 0x80ddd34
    *(char *)(v13 + v1) = v14;
    char v16 = *(char *)(v15 + (int32_t)env_val); // 0x80ddd3f
    while (v13 <= 29 && v16 != 0) {
        // 0x80ddd14
        v12 = v16;
        v13 = v15;
        v14 = v12;
        if (v12 >= 58 && (v12 & -33) >= 91) {
            // 0x80ddd29
            v14 = v12 != 95 ? 45 : v12;
        }
        // 0x80ddd34
        v15 = v13 + 1;
        *(char *)(v13 + v1) = v14;
        v16 = *(char *)(v15 + (int32_t)env_val);
    }
  lab_0x80ddd68:
    // 0x80ddd68
    *(int16_t *)v5 = 0;
    v2 = v3;
    v4 = v5 + 2;
    goto lab_0x80ddcd3;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/terminal/kbd.c
// Address range: 0x80ddd80 - 0x80ddf80
// Line range:    417 - 460
void free_itrm(int32_t * itrm) {
    int32_t v1 = __readgsdword(20); // 0x80ddd8b
    int32_t * v2; // 0x80ddd80
    int32_t v3; // 0x80ddd80
    char * v4; // 0x80ddd9e
    char v5; // 0x80ddd9e
    if (itrm == NULL) {
        goto lab_0x80ddf01;
    } else {
        // 0x80ddd9e
        v3 = (int32_t)itrm;
        v4 = (char *)(v3 + 116);
        v5 = *v4;
        v2 = (int32_t *)(v3 + 104);
        if ((v5 & 8) != 0) {
            goto lab_0x80dddf9;
        } else {
            int32_t v6 = *v2; // 0x80ddda6
            if (v6 == 0) {
                goto lab_0x80dddb6;
            } else {
                char * v7 = (char *)v6; // 0x80dddad
                if (*v7 != 0) {
                    // 0x80ddf30
                    set_window_title(v7, *(int32_t *)(v3 + 112));
                    goto lab_0x80dddbe;
                } else {
                    goto lab_0x80dddb6;
                }
            }
        }
    }
  lab_0x80ddf01:
    // 0x80ddf01
    if (v1 != __readgsdword(20)) {
        // 0x80ddf7a
        __stack_chk_fail();
        return;
    }
  lab_0x80dddf9:;
    int32_t v8 = *v2; // 0x80dddf9
    if (v8 != 0) {
        // 0x80dde00
        mem_free((char *)v8);
    }
    // 0x80dde08
    *v2 = 0;
    int32_t v9 = *itrm;
    if ((*v4 & 8) != 0 != v9 < 0) {
        // 0x80dde1f
        set_handlers(v9, NULL, NULL, NULL, NULL);
    }
    // 0x80dde47
    set_handlers(*(int32_t *)(v3 + 4), NULL, NULL, NULL, NULL);
    set_handlers(*(int32_t *)(v3 + 20), NULL, NULL, NULL, NULL);
    set_handlers(*(int32_t *)(v3 + 24), NULL, NULL, NULL, NULL);
    kill_timer((int32_t **)(v3 + 36));
    if (ditrm == itrm) {
        // 0x80ddf20
        *(int32_t *)&ditrm = 0;
    }
    int32_t v10 = *(int32_t *)(v3 + 28); // 0x80ddedb
    if (v10 != 0) {
        // 0x80ddee2
        mem_free((char *)v10);
    }
    int32_t v11 = *(int32_t *)(v3 + 12); // 0x80ddeea
    if (v11 != 0) {
        // 0x80ddef1
        mem_free((char *)v11);
    }
    // 0x80ddef9
    mem_free((char *)itrm);
    goto lab_0x80ddf01;
  lab_0x80dddb6:
    if ((v5 & 4) != 0) {
        // 0x80ddf48
        char v12; // bp-48, 0x80ddd80
        get_terminal_name(&v12);
        if (v12 != 0) {
            int32_t v13 = get_cp_index("US-ASCII"); // 0x80ddf64
            set_window_title(&v12, v13);
        }
    }
    goto lab_0x80dddbe;
  lab_0x80dddbe:;
    int32_t * fd = (int32_t *)(v3 + 8); // 0x80dddbe
    unhandle_terminal_resize(*fd);
    disable_mouse();
    send_done_sequence((int32_t)&g83, (int32_t)&g83);
    tcsetattr(*fd, TCSANOW, (struct termios *)(v3 + 40));
    goto lab_0x80dddf9;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/terminal/kbd.c
// Address range: 0x80ddf80 - 0x80ddf99
// Line range:    69 - 72
void free_all_itrms(void) {
    // 0x80ddf80
    if (ditrm != NULL) {
        // 0x80ddf8f
        free_itrm(ditrm);
    }
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/terminal/mouse.c
// Address range: 0x80dfd90 - 0x80dfdd0
// Line range:    63 - 70
void send_mouse_done_sequence(int32_t h) {
    // 0x80dfd90
    hard_write(h, (char *)&g20, 5);
    hard_write(h, (char *)&g21, 8);
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/terminal/mouse.c
// Address range: 0x80dfdd0 - 0x80dfe2a
// Line range:    75 - 82
void disable_mouse(void) {
    int32_t v1 = get_output_handle(); // 0x80dfdd7
    if (mouse_enabled == 0) {
        // 0x80dfde7
        return;
    }
    // 0x80dfdf0
    unhandle_mouse(g77);
    if (is_xterm() != 0) {
        // 0x80dfe20
        send_mouse_done_sequence(v1);
    }
    // 0x80dfe09
    mouse_enabled = 0;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/terminal/screen.c
// Address range: 0x80dff00 - 0x80dff25
// Line range:    1205 - 1208
void done_screen(int32_t * screen) {
    int32_t v1 = *screen; // 0x80dff0a
    if (v1 != 0) {
        // 0x80dff10
        mem_free((char *)v1);
    }
    // 0x80dff18
    mem_free((char *)screen);
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/terminal/screen.c
// Address range: 0x80dffa0 - 0x80e014b
// Line range:    1172 - 1183
void resize_screen(int32_t * term, int32_t width, int32_t height) {
    int32_t v1 = (int32_t)term;
    int32_t * v2; // 0x80dffa0
    int32_t v3; // 0x80dffa0
    int32_t v4; // 0x80dffa0
    if (assert_failed != 0) {
        // 0x80e00b8
        v4 = *(int32_t *)(v1 + 24);
        goto lab_0x80e00bb;
    } else {
        // 0x80dffc2
        v2 = (int32_t *)(v1 + 24);
        if (term == NULL) {
            goto lab_0x80e00d8;
        } else {
            // 0x80dffca
            if (*v2 == 0) {
                goto lab_0x80e00d8;
            } else {
                // 0x80dffd5
                assert_failed = 0;
                v3 = *v2;
                goto lab_0x80dffe2;
            }
        }
    }
  lab_0x80e00bb:;
    int32_t v5 = height * width; // 0x80e00be
    int32_t v6 = v5; // 0x80e00c3
    int32_t v7 = v4; // 0x80e00c3
    if (v5 == 0) {
        // 0x80e00c9
        return;
    }
    goto lab_0x80e0038;
  lab_0x80e00d8:
    // 0x80e00d8
    assert_failed = 1;
    errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/terminal/screen.c";
    errline = 1178;
    elinks_internal("assertion term && term->screen failed!");
    int32_t v16 = *v2; // 0x80e0108
    v3 = v16;
    v4 = v16;
    if (assert_failed == 0) {
        goto lab_0x80dffe2;
    } else {
        goto lab_0x80e00bb;
    }
  lab_0x80e0038:;
    int32_t * v8 = (int32_t *)v7; // 0x80e0049
    char * v9 = mem_realloc((char *)*v8, 16 * v6); // 0x80e004e
    if (v9 == NULL) {
        // 0x80e00c9
        return;
    }
    int32_t v10 = 8 * v6; // 0x80e0038
    int32_t v11 = (int32_t)v9; // 0x80e004e
    *v8 = v11;
    int32_t * v12 = (int32_t *)(v7 + 4); // 0x80e005f
    *v12 = v10 + v11;
    memset((int32_t *)v9, 0, v10);
    memset((int32_t *)*v12, 255, v10);
    *(int32_t *)(v1 + 48) = height;
    *(int32_t *)(v1 + 44) = width;
    int32_t * v13 = (int32_t *)(v7 + 24); // 0x80e009c
    if (*v13 >= 1) {
        // 0x80e00a3
        *v13 = 0;
    }
    int32_t * v14 = (int32_t *)(v7 + 28); // 0x80e00aa
    if (*v14 < height) {
        // 0x80e00af
        *v14 = height;
    }
  lab_0x80dffe2:
    // 0x80dffe2
    assert_failed = width < 0;
    if (width < 0) {
        // 0x80e0118
        errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/terminal/screen.c";
        errline = 1182;
        elinks_internal("assertion width >= 0 failed!");
        v4 = v3;
        if (assert_failed == 0) {
            goto lab_0x80dfff5;
        } else {
            goto lab_0x80e00bb;
        }
    } else {
        goto lab_0x80dfff5;
    }
  lab_0x80dfff5:
    // 0x80dfff5
    assert_failed = height < 0;
    v4 = v3;
    if (height >= 0) {
        goto lab_0x80e00bb;
    } else {
        // 0x80e0007
        errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/terminal/screen.c";
        errline = 1183;
        elinks_internal("assertion height >= 0 failed!");
        int32_t v15 = height * width; // 0x80e002a
        v6 = v15;
        v7 = v3;
        if (v15 == 0) {
            // 0x80e00c9
            return;
        }
        goto lab_0x80e0038;
    }
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/terminal/screen.c
// Address range: 0x80e01b0 - 0x80e0208
// Line range:    1133 - 1141
void erase_screen(int32_t * term) {
    int32_t v1 = (int32_t)term;
    char * v2 = (char *)(v1 + 56); // 0x80e01ba
    if (*v2 % 2 != 0) {
        // 0x80e01c0
        if (is_blocked() != 0) {
            // 0x80e01c9
            return;
        }
        // 0x80e01d8
        want_draw();
    }
    // 0x80e01dd
    hard_write(*(int32_t *)(v1 + 36), (char *)&g22, 10);
    if (*v2 % 2 == 0) {
        // 0x80e01c9
        return;
    }
    // 0x80e01fe
    done_draw();
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/terminal/screen.c
// Address range: 0x80e0210 - 0x80e0454
// Line range:    318 - 370
void set_screen_driver_opt(int32_t * driver, int32_t * term_spec) {
    // 0x80e0210
    int32_t v1; // 0x80e0210
    int32_t v2 = *(int32_t *)get_opt_(v1, "charset"); // 0x80e022d
    int32_t v3 = *(int32_t *)get_opt_(v1, "utf_8_io"); // 0x80e023f
    int32_t * v4 = (int32_t *)(v1 + 8); // 0x80e0244
    int32_t v5 = *(int32_t *)(4 * *v4 + (int32_t)&screen_driver_opts); // 0x80e0247
    int32_t * v6 = (int32_t *)(v1 + 12); // 0x80e0250
    *v6 = *(int32_t *)v5;
    int32_t * v7 = (int32_t *)(v1 + 16); // 0x80e0256
    *v7 = *(int32_t *)(v5 + 4);
    int32_t * v8 = (int32_t *)(v1 + 20); // 0x80e025c
    *v8 = *(int32_t *)(v5 + 8);
    int32_t * v9 = (int32_t *)(v1 + 24); // 0x80e0262
    *v9 = *(int32_t *)(v5 + 12);
    int32_t * v10 = (int32_t *)(v1 + 28); // 0x80e0268
    *v10 = *(int32_t *)(v5 + 16);
    int32_t * v11 = (int32_t *)(v1 + 32); // 0x80e026e
    *v11 = *(int32_t *)(v5 + 20);
    int32_t v12 = v1 + 36; // 0x80e0274
    *(int32_t *)v12 = *(int32_t *)(v5 + 24);
    int32_t v13 = is_cp_utf8(v2); // 0x80e027a
    char * v14 = (char *)v12;
    char v15 = *v14;
    *v14 = v13 == 0 ? v15 & -3 : v15 | 2;
    *v11 = *(int32_t *)get_opt_(v1, "colors");
    *v14 = *v14 & -2 | (char)*(int32_t *)get_opt_(v1, "transparency") % 2;
    int32_t v16 = *(int32_t *)get_opt_(v1, "underline"); // 0x80e02da
    *v10 = v16 != 0 ? (int32_t)&underline_seqs : 0;
    int32_t v17 = *v4;
    if ((v13 || v3) == 0) {
        // 0x80e0350
        *v6 = -1;
        switch (v17) {
            case 2: {
                // 0x80e0378
                if (*(int32_t *)get_opt_(v1, "restrict_852") != 0) {
                    // 0x80e0400
                    *v8 = (int32_t)"\xb0\xb1\xb2\xb3\xb4\xb3\xba\xba\xcd\xb9\xba\xbb\xbc\xba\xcd\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xb3\xba\xc8\xc9\xca\xcb\xcc\xcd\xce\xcd\xc4\xcd\xc4\xba\xcd\xcd\xba\xba\xb3\xd9\xda\xdb\xdc\xdd\xde\xdf";
                }
            }
            case 4: {
                // 0x80e038e
                if (*(int32_t *)get_opt_(v1, "m11_hack") != 0) {
                    // 0x80e03a4
                    *v9 = (int32_t)&m11_hack_frame_seqs;
                }
                // break -> 0x80e0333
                break;
            }
            default: {
                if (v17 == 1) {
                    // 0x80e0369
                    *v8 = (int32_t)"aaaxuuukkuxkjjjkmvwtqnttmlvwtqnvvwwmmllnnjla    ";
                    return;
                }
                // break -> 0x80e0333
                break;
            }
        }
        // 0x80e0333
        return;
    }
    // 0x80e02f0
    *v6 = v2;
    *v9 = 0;
    switch (v17) {
        case 2: {
            // 0x80e03b0
            if (*(int32_t *)get_opt_(v1, "restrict_852") != 0) {
                // 0x80e03c6
                *v8 = (int32_t)"\xb0\xb1\xb2\xb3\xb4\xb3\xba\xba\xcd\xb9\xba\xbb\xbc\xba\xcd\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xb3\xba\xc8\xc9\xca\xcb\xcc\xcd\xce\xcd\xc4\xcd\xc4\xba\xcd\xcd\xba\xba\xb3\xd9\xda\xdb\xdc\xdd\xde\xdf";
            }
            // 0x80e03cd
            *v7 = get_cp_index("cp437");
            return;
        }
        case 4: {
            // 0x80e0410
            *v8 = (int32_t)"\xb1\xb1\xdb\xb3\xb4\xb4\xb4\xbf\xbf\xb4\xb3\xbf\xd9\xd9\xd9\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc3\xc3\xc0\xda\xc1\xc2\xc3\xc4\xc5\xc1\xc1\xc2\xc2\xc0\xc0\xda\xda\xc5\xc5\xd9\xda\xdb\xdb\xdb\xdb\xdb";
            // 0x80e03cd
            *v7 = get_cp_index("cp437");
            return;
        }
        case 1: {
            // 0x80e0420
            *v8 = (int32_t)"\xb1\xb1\xb1\xb3\xb4\xb4\xb4\xbf\xbf\xb4\xb3\xbf\xd9\xd9\xd9\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc3\xc3\xc0\xda\xc1\xc2\xc3\xc4\xc5\xc1\xc1\xc2\xc2\xc0\xc0\xda\xda\xc5\xc5\xd9\xda\xb1    ";
            *v7 = get_cp_index("cp437");
            // 0x80e0333
            return;
        }
        case 3: {
            // 0x80e0440
            *v7 = get_cp_index("koi8-r");
            // 0x80e0333
            return;
        }
    }
    // 0x80e0326
    if ((*v14 & 2) != 0) {
        // 0x80e03e8
        *v7 = get_cp_index("US-ASCII");
    } else {
        // 0x80e0330
        *v7 = v2;
    }
}

// Address range: 0x80e04d0 - 0x80e061a
int32_t add_bytes_to_string__3(void) {
    // 0x80e04d0
    if (assert_failed != 0) {
        // 0x80e04eb
        assert_failed = 0;
        // 0x80e04f8
        return 0;
    }
    int32_t v1; // 0x80e04d0
    if (v1 < 0 || v1 == 0 || v1 == 0) {
        // 0x80e0510
        assert_failed = 1;
        errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
        errline = 255;
        elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
        if (assert_failed != 0) {
            // 0x80e04eb
            assert_failed = 0;
            // 0x80e04f8
            return 0;
        }
    } else {
        // 0x80e05b8
        assert_failed = 0;
    }
    if (v1 == 0) {
        // 0x80e04f8
        int32_t result; // 0x80e04d0
        return result;
    }
    int32_t * v2 = (int32_t *)(v1 + 4); // 0x80e0554
    int32_t v3 = *v2; // 0x80e0554
    int32_t v4 = v3 + v1; // 0x80e0557
    int32_t v5 = v3 + 255; // 0x80e055a
    uint32_t v6 = v5 & -256; // 0x80e0568
    uint32_t v7 = v4 + 256 & -256; // 0x80e056f
    int32_t set_mem = v5; // 0x80e0578
    if (v7 > v6) {
        char * v8 = mem_realloc((char *)v5, v7); // 0x80e05d7
        if (v8 == NULL) {
            // 0x80e04f8
            return 0;
        }
        int32_t v9 = (int32_t)v8; // 0x80e05d7
        *(int32_t *)v1 = v9;
        set_mem = (int32_t)memset(&((struct _IO_FILE *)(v6 + v9))->e0, 0, v7 - v6);
    }
    // 0x80e057a
    if (set_mem != 0) {
        int32_t * dest_mem = memcpy(&((struct _IO_FILE *)(*v2 + set_mem))->e0, (int32_t *)v1, v1); // 0x80e0592
        *(char *)(v4 + (int32_t)dest_mem) = 0;
        *v2 = v4;
    }
    // 0x80e04f8
    return 0;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/terminal/screen.c
// Address range: 0x80e0620 - 0x80e2740
// Line range:    1051 - 1130
void redraw_screen(int32_t * term) {
    int32_t v1; // 0x80e0620
    int32_t v2; // 0x80e0620
    int32_t v3; // 0x80e0620
    int32_t v4; // 0x80e0620
    int32_t v5; // 0x80e0620
    int16_t v6; // 0x80e0620
    char v7; // 0x80e0620
    char v8; // 0x80e0620
    int32_t * v9; // 0x80e0620
    char v10; // 0x80e0620
    char * v11; // 0x80e0620
    int32_t v12; // 0x80e0620
    int32_t v13; // 0x80e267d
    char v14; // 0x80e2687
    char v15; // 0x80e2697
    int32_t v16 = (int32_t)term;
    int32_t v17 = __readgsdword(20); // 0x80e062f
    int32_t * v18 = (int32_t *)(v16 + 24); // 0x80e0641
    int32_t v19 = *v18; // 0x80e0641
    char * v20; // 0x80e0664
    int32_t * v21; // 0x80e0652
    int32_t * v22; // 0x80e0655
    if (v19 == 0) {
        goto lab_0x80e0cb5;
    } else {
        // 0x80e0652
        v21 = (int32_t *)(v19 + 24);
        v22 = (int32_t *)(v19 + 28);
        if (*v21 > *v22) {
            goto lab_0x80e0cb5;
        } else {
            // 0x80e065e
            v20 = (char *)(v16 + 56);
            if (*v20 % 2 != 0) {
                // 0x80e0cd0
                if (is_blocked() == 0) {
                    goto lab_0x80e066e;
                } else {
                    goto lab_0x80e0cb5;
                }
            } else {
                goto lab_0x80e066e;
            }
        }
    }
  lab_0x80e1f73:;
    // 0x80e1f73
    char v23; // 0x80e0620
    char v24; // 0x80e1f5c
    char v25 = v24 ^ v23;
    char * v26 = (char *)(int32_t)v25; // 0x80e1f7c
    char * v27 = v26; // bp-96, 0x80e1f7c
    char v28 = v23; // 0x80e1f7f
    int32_t v29; // 0x80e1f62
    int32_t v30 = v29; // 0x80e1f7f
    char v31; // 0x80e0620
    char v32 = v31; // 0x80e1f7f
    int16_t v33; // 0x80e0620
    int16_t v34 = v33; // 0x80e1f7f
    int32_t v35; // 0x80e1f58
    int32_t v36 = v35; // 0x80e1f7f
    int32_t v37; // 0x80e0620
    char * v38; // 0x80e1f5c
    int32_t v39; // 0x80e152a
    char * v40; // 0x80e1583
    int32_t * v41; // 0x80e0620
    if (v25 != 0) {
        char * v42 = v26; // 0x80e1f81
        char v43 = v31; // 0x80e1f81
        char v44 = v24; // 0x80e1f81
        if (v25 < 0) {
            // 0x80e2430
            v42 = v26;
            v43 = v31;
            v44 = v24;
            if (*(int32_t *)(v39 + 24) != 0) {
                // 0x80e243b
                add_bytes_to_string__3();
                v42 = v27;
                v43 = v24 >> 7;
                v44 = *v38;
            }
        }
        char v45 = v44;
        uint32_t v46 = (int32_t)v42; // 0x80e1f8a
        char * v47 = (char *)(v46 % 256); // 0x80e1f8e
        v27 = v47;
        char * v48 = v47; // 0x80e1f94
        char v49 = v45; // 0x80e1f94
        if ((v46 & 32) != 0) {
            // 0x80e1f96
            v48 = v47;
            v49 = v45;
            if (*v41 != 0) {
                // 0x80e1f9d
                add_bytes_to_string__3();
                v48 = v27;
                v49 = *v38;
            }
        }
        char v50 = v49;
        char v51 = v50; // 0x80e1fc0
        int16_t v52 = v33; // 0x80e1fc0
        if (((int32_t)v48 & 8) != 0) {
            if ((v50 & 8) != 0) {
                // 0x80e2378
                add_bytes_to_string__3();
                v51 = *v38;
                v52 = v33;
            } else {
                // 0x80e1fd0
                v51 = v50;
                v52 = (int16_t)(*(char *)(v37 + 5) + 1);
            }
        }
        unsigned char v53 = *v40; // 0x80e1fda
        v28 = v51;
        v30 = v53 & 2;
        v32 = v43;
        v34 = v52;
        v36 = v53;
    }
    int32_t v54 = v36;
    int16_t v55 = v34;
    char v56 = v32;
    char v57 = v28;
    char v58; // 0x80e0620
    int32_t v59; // 0x80e0620
    int16_t v60; // 0x80e0620
    char v61; // 0x80e0620
    char v62; // 0x80e0620
    if (v30 != 0) {
        // 0x80e2350
        if (*(int32_t *)v37 != -3) {
            goto lab_0x80e1ff0;
        } else {
            // 0x80e2350
            v58 = *v38;
            v61 = v57;
            v62 = v56;
            v60 = v55;
            v59 = v54;
            goto lab_0x80e2360;
        }
    } else {
        goto lab_0x80e1ff0;
    }
  lab_0x80e1ff0:;
    char v63 = *(char *)(v37 + 5); // 0x80e1ff0
    v27 = (char *)(int32_t)v63;
    char * v64 = (char *)(v37 + 6);
    char v65 = *v64;
    int32_t v66 = v65;
    int32_t v67 = 0; // 0x80e1ffd
    int32_t v68; // 0x80e0620
    int32_t v69; // 0x80e0620
    int16_t v70; // 0x80e0620
    char v71; // 0x80e0620
    int32_t v72; // 0x80e0620
    char v73; // 0x80e0620
    int32_t v74; // 0x80e0620
    int32_t v75; // 0x80e0620
    char v76; // 0x80e0620
    if (v63 != (char)v55 || v65 != v71) {
        while (*(char *)(v67 + (int32_t)&g23 + 1) != 37) {
            // 0x80e2020
            v67++;
        }
        // 0x80e2029
        add_bytes_to_string__3();
        add_bytes_to_string__3();
        add_bytes_to_string__3();
        if (*v40 % 2 != 0 != (*v64 == 0)) {
            int32_t v77 = 0; // 0x80e20fb
            if (*(char *)&g11 != 37) {
                while (*(char *)(v77 + (int32_t)&g24 + 1) != 37) {
                    // 0x80e2100
                    v77++;
                }
            }
            // 0x80e211e
            add_bytes_to_string__3();
            add_bytes_to_string__3();
            add_bytes_to_string__3();
        }
        int32_t v78 = (int32_t)*v38; // 0x80e21c4
        int32_t v79 = v78; // 0x80e21ce
        if ((v78 & 8) != 0) {
            // 0x80e2498
            add_bytes_to_string__3();
            v79 = (int32_t)*v38;
        }
        int32_t v80 = v79;
        v74 = v80;
        if ((v80 & 32) == 0) {
            goto lab_0x80e21fa;
        } else {
            // 0x80e21da
            if (*v41 == 0) {
                // 0x80e25d0
                v73 = v57;
                v72 = v66;
                v76 = v56;
                v70 = 256 * (int16_t)(int32_t)v27 >> 8;
                v75 = v80;
                v68 = *(int32_t *)v37;
                v69 = (int32_t)*v40;
                goto lab_0x80e2207;
            } else {
                // 0x80e21e5
                add_bytes_to_string__3();
                v74 = (int32_t)*v38;
                goto lab_0x80e21fa;
            }
        }
    } else {
        // 0x80e23ab
        v73 = v57;
        v72 = v66;
        v76 = v56;
        v70 = v55;
        v75 = (int32_t)*v38;
        v68 = *(int32_t *)v37;
        v69 = v54;
        goto lab_0x80e2207;
    }
  lab_0x80e2360:
    // 0x80e2360
    v73 = v61;
    v72 = v71;
    v76 = v62;
    v70 = v60;
    v75 = v58;
    v68 = -3;
    v69 = v59;
    goto lab_0x80e2207;
  lab_0x80e2207:;
    int32_t v81 = v68;
    int32_t v82 = v75 & 128; // 0x80e220b
    int32_t v83 = 0x1000000 * v82 >> 24; // 0x80e2211
    v27 = (char *)v83;
    int32_t v84 = v81; // 0x80e2214
    if (v82 != 0) {
        int32_t v85 = *(int32_t *)(v39 + 20); // 0x80e221b
        uint32_t v86 = v81 - 176;
        v84 = v81;
        if (v86 < 48 == (v85 != 0)) {
            // 0x80e222b
            v84 = (int32_t)*(char *)(v85 + v86);
        }
    }
    uint32_t v87 = v84;
    char * v88; // bp-80, 0x80e0620
    int32_t * v89; // 0x80e1596
    if ((v69 & 2) == 0) {
        // 0x80e2290
        if (*v89 == -1) {
            if ((char)v83 != 0) {
                // 0x80e23f7
                add_char_to_string((int32_t *)&v88, (char)v87);
                goto lab_0x80e2278;
            } else {
                if (v87 == 127 || v87 < 32) {
                    // 0x80e25e8
                    add_char_to_string((int32_t *)&v88, 32);
                    goto lab_0x80e2278;
                } else {
                    // 0x80e23f7
                    add_char_to_string((int32_t *)&v88, (char)v87);
                    goto lab_0x80e2278;
                }
            }
        } else {
            // 0x80e229a
            if ((char)v83 != 0) {
                goto lab_0x80e22c1;
            } else {
                if (v87 == 127 || v87 < 32) {
                    // 0x80e24d8
                    add_char_to_string((int32_t *)&v88, 32);
                    goto lab_0x80e2278;
                } else {
                    goto lab_0x80e22c1;
                }
            }
        }
    } else {
        int32_t v90 = v87; // 0x80e2241
        if ((char)v83 != 0) {
            // 0x80e23c0
            v90 = cp2u(*(int32_t *)(v39 + 16), (char)v87);
        }
        uint32_t v91 = v90;
        if (v91 != -3) {
            int32_t v92 = encode_utf8(v91 < 127 ? v91 : v91 < 160 ? 32 : v91); // 0x80e2264
            add_to_string((int32_t *)&v88, v92);
        }
        goto lab_0x80e2278;
    }
  lab_0x80e21fa:
    // 0x80e21fa
    v73 = v57;
    v72 = v66;
    v76 = v56;
    v70 = 256 * (int16_t)(int32_t)v27 >> 8;
    v75 = v74;
    v68 = *(int32_t *)v37;
    v69 = (int32_t)*v40;
    goto lab_0x80e2207;
  lab_0x80e2278:;
    int32_t v93 = v37 + 8; // 0x80e2278
    int32_t v94 = v93; // 0x80e227e
    uint32_t v95; // 0x80e1f18
    if (v93 > v95) {
        // break -> 0x80e22e4
        goto lab_0x80e22e4_2;
    }
    goto lab_0x80e2280;
  lab_0x80e22c1:;
    int32_t v610 = v37 + 8; // 0x80e22c4
    int32_t v317; // 0x80e1596
    char * v611 = cp2utf8(*(int32_t *)(((char)v83 == 0 ? 0 : 4) + v317), v87); // 0x80e22cb
    add_to_string((int32_t *)&v88, (int32_t)v611);
    v94 = v610;
    if (v610 > v95) {
        // break -> 0x80e22e4
        goto lab_0x80e22e4_2;
    }
    goto lab_0x80e2280;
  lab_0x80e2280:;
    char v96 = v73; // 0x80e2287
    char v97 = v76; // 0x80e2287
    int16_t v98 = v70; // 0x80e2287
    char v99 = v72; // 0x80e2287
    int32_t v100 = v94; // 0x80e2287
    goto lab_0x80e1f58;
  lab_0x80e1f2e:;
    char * v101; // 0x80e0620
    char * v102; // 0x80e0620
    char * v103; // 0x80e0620
    char * v104; // 0x80e0620
    int32_t v105; // 0x80e0620
    int32_t v106; // 0x80e0620
    int32_t v107; // 0x80e0620
    int32_t v108; // 0x80e0620
    char * v109; // 0x80e0620
    char * v110; // bp-148, 0x80e0620
    int32_t v111; // 0x80e0620
    int32_t v112; // 0x80e0620
    int32_t v113; // bp-57, 0x80e0620
    int32_t v114; // bp-64, 0x80e0620
    int32_t v115; // 0x80e0620
    int32_t v116; // 0x80e0620
    if (v112 == v106 == v107 + 80 > v95) {
        // 0x80e1f46
        *(int32_t *)&v110 = v105;
        v108 = v107;
        v101 = v103;
        v102 = v104;
        if (v95 < v107) {
            goto lab_0x80e22f1;
        } else {
            goto lab_0x80e1f58_2;
        }
    } else {
        // 0x80e24f0
        v114 = 2;
        v113 = 27;
        *(int32_t *)&v110 = v105;
        uint32_t v117 = elinks_ulongcat(&v113, v115, v111, 10, 0, 10, 0); // 0x80e253f
        v108 = v95;
        if (v117 >= 0) {
            // 0x80e2548
            *(char *)(v114 + v116) = 59;
            v114++;
            uint32_t v118 = elinks_ulongcat(&v113, v115, (int32_t)v109, 10, 0, 10, 0); // 0x80e2587
            v108 = v95;
            if (v118 >= 0) {
                // 0x80e2590
                *(char *)(v114 + v116) = 72;
                v114++;
                add_bytes_to_string__3();
                v108 = v95;
            }
        }
        goto lab_0x80e1f58_2;
    }
  lab_0x80e2632:;
    int32_t v119; // 0x80e0620
    char * v120; // 0x80e0620
    if (v120 > (char *)32) {
        goto lab_0x80e1f2e;
    } else {
        // 0x80e263c
        if (*(int32_t *)v119 < 33) {
            // 0x80e264b
            *(int32_t *)&v110 = v105;
            v101 = v103;
            v102 = v104;
            if (*(char *)(v95 + 4) != *(char *)(v119 + 4)) {
                goto lab_0x80e1f2e;
            } else {
                goto lab_0x80e22f1;
            }
        } else {
            goto lab_0x80e1f2e;
        }
    }
  lab_0x80e22f1:
    // 0x80e22f1
    if (v102 < v109) {
        // break -> 0x80e232a
        goto lab_0x80e232a_2;
    }
    // 0x80e2307
    int32_t v121; // 0x80e1e56
    if (v121 == v112 == v101 == v110) {
        // break -> 0x80e232a
        goto lab_0x80e232a_2;
    }
    goto lab_0x80e1f18;
  lab_0x80e1f58_2:;
    // 0x80e1f58
    char v131; // 0x80e0620
    v96 = v131;
    char v129; // 0x80e0620
    v97 = v129;
    int16_t v127; // 0x80e0620
    v98 = v127;
    char v124; // 0x80e0620
    v99 = v124;
    v100 = v108;
    while (true) {
      lab_0x80e1f58:
        // 0x80e1f58
        v37 = v100;
        v71 = v99;
        v33 = v98;
        v31 = v97;
        v23 = v96;
        v35 = (int32_t)*v40;
        v38 = (char *)(v37 + 4);
        v24 = *v38;
        v29 = v35 & 2;
        if (v29 == 0) {
            goto lab_0x80e1f73;
        } else {
            // 0x80e1f6a
            v58 = v24;
            v61 = v23;
            v62 = v31;
            v60 = v33;
            v59 = v35;
            if (*(int32_t *)v37 == -3) {
                goto lab_0x80e2360;
            } else {
                goto lab_0x80e1f73;
            }
        }
    }
  lab_0x80e22e4_2:;
    // 0x80e22e4
    char * v136; // bp-144, 0x80e0620
    v101 = v136;
    v102 = v136;
    goto lab_0x80e22f1;
  lab_0x80e16fb:;
    // 0x80e16fb
    char v137; // 0x80e0620
    char v138; // 0x80e16e4
    char v139 = v138 ^ v137;
    char * v140 = (char *)(int32_t)v139; // 0x80e1704
    v27 = v140;
    char v141 = v137; // 0x80e1707
    int32_t v142; // 0x80e16ea
    int32_t v143 = v142; // 0x80e1707
    char v144; // 0x80e0620
    char v145 = v144; // 0x80e1707
    int16_t v146; // 0x80e0620
    int16_t v147 = v146; // 0x80e1707
    int32_t v148; // 0x80e16e0
    int32_t v149 = v148; // 0x80e1707
    int32_t v150; // 0x80e0620
    char * v151; // 0x80e16e4
    int32_t * v152; // 0x80e0620
    if (v139 != 0) {
        char * v153 = v140; // 0x80e1709
        char v154 = v144; // 0x80e1709
        char v155 = v138; // 0x80e1709
        if (v139 < 0) {
            // 0x80e1bb8
            v153 = v140;
            v154 = v144;
            v155 = v138;
            if (*(int32_t *)(v39 + 24) != 0) {
                // 0x80e1bc3
                add_bytes_to_string__3();
                v153 = v27;
                v154 = v138 >> 7;
                v155 = *v151;
            }
        }
        char v156 = v155;
        uint32_t v157 = (int32_t)v153; // 0x80e1712
        char * v158 = (char *)(v157 % 256); // 0x80e1716
        v27 = v158;
        char * v159 = v158; // 0x80e171c
        char v160 = v156; // 0x80e171c
        if ((v157 & 32) != 0) {
            // 0x80e171e
            v159 = v158;
            v160 = v156;
            if (*v152 != 0) {
                // 0x80e1725
                add_bytes_to_string__3();
                v159 = v27;
                v160 = *v151;
            }
        }
        char v161 = v160;
        char v162 = v161; // 0x80e1748
        int16_t v163 = v146; // 0x80e1748
        if (((int32_t)v159 & 8) != 0) {
            if ((v161 & 8) != 0) {
                // 0x80e1b00
                add_bytes_to_string__3();
                v162 = *v151;
                v163 = v146;
            } else {
                // 0x80e1758
                v162 = v161;
                v163 = (int16_t)(*(char *)(v150 + 5) + 1);
            }
        }
        unsigned char v164 = *v40; // 0x80e1762
        v141 = v162;
        v143 = v164 & 2;
        v145 = v154;
        v147 = v163;
        v149 = v164;
    }
    int32_t v165 = v149;
    int16_t v166 = v147;
    char v167 = v145;
    char v168 = v141;
    char v169; // 0x80e0620
    int32_t v170; // 0x80e0620
    int16_t v171; // 0x80e0620
    char v172; // 0x80e0620
    char v173; // 0x80e0620
    if (v143 != 0) {
        // 0x80e1ad8
        if (*(int32_t *)v150 != -3) {
            goto lab_0x80e1778;
        } else {
            // 0x80e1ad8
            v169 = *v151;
            v172 = v168;
            v173 = v167;
            v171 = v166;
            v170 = v165;
            goto lab_0x80e1ae8;
        }
    } else {
        goto lab_0x80e1778;
    }
  lab_0x80e1778:;
    char v174 = *(char *)(v150 + 5); // 0x80e1778
    v27 = (char *)(int32_t)v174;
    char * v175 = (char *)(v150 + 6);
    char v176 = *v175;
    int32_t v177 = v176;
    int32_t v178 = 0; // 0x80e1785
    int32_t v179; // 0x80e0620
    int32_t v180; // 0x80e0620
    int16_t v181; // 0x80e0620
    char v182; // 0x80e0620
    int32_t v183; // 0x80e0620
    char v184; // 0x80e0620
    int32_t v185; // 0x80e0620
    int32_t v186; // 0x80e0620
    char v187; // 0x80e0620
    if (v174 != (char)v166 || v176 != v182) {
        while (*(char *)(v178 + (int32_t)&g23 + 1) != 37) {
            // 0x80e17a8
            v178++;
        }
        // 0x80e17b1
        add_bytes_to_string__3();
        add_bytes_to_string__3();
        add_bytes_to_string__3();
        if (*v40 % 2 != 0 != (*v175 == 0)) {
            int32_t v188 = 0; // 0x80e1883
            if (*(char *)&g11 != 37) {
                while (*(char *)(v188 + (int32_t)&g24 + 1) != 37) {
                    // 0x80e1888
                    v188++;
                }
            }
            // 0x80e18a6
            add_bytes_to_string__3();
            add_bytes_to_string__3();
            add_bytes_to_string__3();
        }
        int32_t v189 = (int32_t)*v151; // 0x80e194c
        int32_t v190 = v189; // 0x80e1956
        if ((v189 & 8) != 0) {
            // 0x80e1c20
            add_bytes_to_string__3();
            v190 = (int32_t)*v151;
        }
        int32_t v191 = v190;
        v185 = v191;
        if ((v191 & 32) == 0) {
            goto lab_0x80e1982;
        } else {
            // 0x80e1962
            if (*v152 == 0) {
                // 0x80e1d58
                v184 = v168;
                v183 = v177;
                v187 = v167;
                v181 = 256 * (int16_t)(int32_t)v27 >> 8;
                v186 = v191;
                v179 = *(int32_t *)v150;
                v180 = (int32_t)*v40;
                goto lab_0x80e198f;
            } else {
                // 0x80e196d
                add_bytes_to_string__3();
                v185 = (int32_t)*v151;
                goto lab_0x80e1982;
            }
        }
    } else {
        // 0x80e1b33
        v184 = v168;
        v183 = v177;
        v187 = v167;
        v181 = v166;
        v186 = (int32_t)*v151;
        v179 = *(int32_t *)v150;
        v180 = v165;
        goto lab_0x80e198f;
    }
  lab_0x80e1ae8:
    // 0x80e1ae8
    v184 = v172;
    v183 = v182;
    v187 = v173;
    v181 = v171;
    v186 = v169;
    v179 = -3;
    v180 = v170;
    goto lab_0x80e198f;
  lab_0x80e198f:;
    int32_t v192 = v179;
    int16_t v193 = v181;
    char v194 = v187;
    int32_t v195 = v183;
    char v196 = v184;
    int32_t v197 = v186 & 128; // 0x80e1993
    int32_t v198 = 0x1000000 * v197 >> 24; // 0x80e1999
    v27 = (char *)v198;
    int32_t v199 = v192; // 0x80e199c
    if (v197 != 0) {
        int32_t v200 = *(int32_t *)(v39 + 20); // 0x80e19a3
        uint32_t v201 = v192 - 176;
        v199 = v192;
        if (v201 < 48 == (v200 != 0)) {
            // 0x80e19b3
            v199 = (int32_t)*(char *)(v200 + v201);
        }
    }
    uint32_t v202 = v199;
    if ((v180 & 2) == 0) {
        // 0x80e1a18
        if (*v89 == -1) {
            if ((char)v198 != 0) {
                // 0x80e1b7f
                add_char_to_string((int32_t *)&v88, (char)v202);
                goto lab_0x80e1a00;
            } else {
                if (v202 == 127 || v202 < 32) {
                    // 0x80e1d70
                    add_char_to_string((int32_t *)&v88, 32);
                    goto lab_0x80e1a00;
                } else {
                    // 0x80e1b7f
                    add_char_to_string((int32_t *)&v88, (char)v202);
                    goto lab_0x80e1a00;
                }
            }
        } else {
            // 0x80e1a22
            if ((char)v198 != 0) {
                goto lab_0x80e1a49;
            } else {
                if (v202 == 127 || v202 < 32) {
                    // 0x80e1c60
                    add_char_to_string((int32_t *)&v88, 32);
                    goto lab_0x80e1a00;
                } else {
                    goto lab_0x80e1a49;
                }
            }
        }
    } else {
        int32_t v203 = v202; // 0x80e19c9
        if ((char)v198 != 0) {
            // 0x80e1b48
            v203 = cp2u(*(int32_t *)(v39 + 16), (char)v202);
        }
        uint32_t v204 = v203;
        if (v204 != -3) {
            int32_t v205 = encode_utf8(v204 < 127 ? v204 : v204 < 160 ? 32 : v204); // 0x80e19ec
            add_to_string((int32_t *)&v88, v205);
        }
        goto lab_0x80e1a00;
    }
  lab_0x80e1982:
    // 0x80e1982
    v184 = v168;
    v183 = v177;
    v187 = v167;
    v181 = 256 * (int16_t)(int32_t)v27 >> 8;
    v186 = v185;
    v179 = *(int32_t *)v150;
    v180 = (int32_t)*v40;
    goto lab_0x80e198f;
  lab_0x80e1a00:;
    int32_t v206 = v150 + 8; // 0x80e1a00
    int32_t v207 = v206; // 0x80e1a06
    int32_t v208 = v206; // 0x80e1a06
    uint32_t v209; // 0x80e16a0
    if (v206 > v209) {
        // break -> 0x80e1a6c
        goto lab_0x80e1a6c_2;
    }
    goto lab_0x80e1a08;
  lab_0x80e1a49:;
    int32_t v608 = v150 + 8; // 0x80e1a4c
    char * v609 = cp2utf8(*(int32_t *)(((char)v198 == 0 ? 0 : 4) + v317), v202); // 0x80e1a53
    add_to_string((int32_t *)&v88, (int32_t)v609);
    v207 = v608;
    v208 = v608;
    if (v608 > v209) {
        // break -> 0x80e1a6c
        goto lab_0x80e1a6c_2;
    }
    goto lab_0x80e1a08;
  lab_0x80e1a08:;
    char v210 = v196; // 0x80e1a0f
    char v211 = v194; // 0x80e1a0f
    int16_t v212 = v193; // 0x80e1a0f
    char v213 = v195; // 0x80e1a0f
    int32_t v214 = v207; // 0x80e1a0f
    goto lab_0x80e16e0;
  lab_0x80e16b6:;
    char * v215; // 0x80e0620
    int32_t v216; // 0x80e0620
    char * v217; // 0x80e16b6
    int32_t v218; // 0x80e0620
    int32_t v219; // 0x80e0620
    int32_t v220; // 0x80e0620
    int32_t v221; // 0x80e0620
    int32_t v222; // 0x80e0620
    int16_t v223; // 0x80e0620
    int16_t v224; // 0x80e0620
    char v225; // 0x80e0620
    char v226; // 0x80e0620
    char v227; // 0x80e0620
    char v228; // 0x80e0620
    char v229; // 0x80e0620
    char v230; // 0x80e0620
    char * v231; // 0x80e0620
    int32_t v232; // 0x80e0620
    int32_t v233; // 0x80e0620
    int32_t v234; // 0x80e0620
    if (v218 == (int32_t)v217 == v221 + 80 > v209) {
        // 0x80e16ce
        *(int32_t *)&v136 = v216;
        v222 = v221;
        v215 = v217;
        v228 = v227;
        v230 = v229;
        v224 = v223;
        v226 = v225;
        v219 = v218;
        v220 = v221;
        if (v209 < v221) {
            goto lab_0x80e1a79;
        } else {
            goto lab_0x80e16e0_2;
        }
    } else {
        // 0x80e1c78
        v114 = 2;
        v113 = 27;
        *(int32_t *)&v136 = v216;
        uint32_t v235 = elinks_ulongcat(&v113, v233, v232, 10, 0, 10, 0); // 0x80e1cc7
        v222 = v209;
        if (v235 >= 0) {
            // 0x80e1cd0
            *(char *)(v114 + v234) = 59;
            v114++;
            uint32_t v236 = elinks_ulongcat(&v113, v233, (int32_t)v231, 10, 0, 10, 0); // 0x80e1d0f
            v222 = v209;
            if (v236 >= 0) {
                // 0x80e1d18
                *(char *)(v114 + v234) = 72;
                v114++;
                add_bytes_to_string__3();
                v222 = v209;
            }
        }
        goto lab_0x80e16e0_2;
    }
  lab_0x80e1dba:;
    int32_t v237; // 0x80e0620
    char * v238; // 0x80e0620
    if (v238 > (char *)32) {
        goto lab_0x80e16b6;
    } else {
        // 0x80e1dc4
        if (*(int32_t *)v237 < 33) {
            // 0x80e1dd3
            *(int32_t *)&v136 = v216;
            v215 = v217;
            v228 = v227;
            v230 = v229;
            v224 = v223;
            v226 = v225;
            v219 = v218;
            v220 = v221;
            if (*(char *)(v209 + 4) != *(char *)(v237 + 4)) {
                goto lab_0x80e16b6;
            } else {
                goto lab_0x80e1a79;
            }
        } else {
            goto lab_0x80e16b6;
        }
    }
  lab_0x80e1a79:;
    int32_t v239 = v220;
    int32_t v240 = v219;
    char v241 = v226;
    int16_t v242 = v224;
    char v243 = v230;
    char v244 = v228;
    int32_t v245 = (int32_t)v231; // 0x80e1a79
    int32_t v246 = v237 + 8; // 0x80e1a7c
    int32_t v247; // 0x80e0620
    int32_t * v248 = (int32_t *)((v247 + 8) % 256);
    char v249 = v244; // 0x80e1a8d
    char v250 = v243; // 0x80e1a8d
    int16_t v251 = v242; // 0x80e1a8d
    int32_t v252 = v246; // 0x80e1a8d
    char v253 = v241; // 0x80e1a8d
    int32_t * v254 = v248; // 0x80e1a8d
    int32_t v255 = v240; // 0x80e1a8d
    int32_t v256 = v239; // 0x80e1a8d
    int32_t v257; // 0x80e15c8
    if (v257 < v245) {
        // break -> 0x80e1ab2
        goto lab_0x80e1ab2_2;
    }
    int32_t v258 = v245 + 1; // 0x80e1a95
    char * v259 = (char *)v258; // 0x80e1a9f
    int32_t v260 = v258; // 0x80e1a9f
    char * v261 = v215; // 0x80e1a9f
    char v262 = v244; // 0x80e1a9f
    char v263 = v243; // 0x80e1a9f
    int16_t v264 = v242; // 0x80e1a9f
    int32_t v265 = v246; // 0x80e1a9f
    char v266 = v241; // 0x80e1a9f
    int32_t * v267 = v248; // 0x80e1a9f
    int32_t v268 = v240; // 0x80e1a9f
    int32_t v269 = v239; // 0x80e1a9f
    v249 = v244;
    v250 = v243;
    v251 = v242;
    v252 = v246;
    v253 = v241;
    v254 = v248;
    v255 = v240;
    v256 = v239;
    int32_t v270; // 0x80e0620
    int32_t v271; // 0x80e15d4
    if (v271 == v270 == v257 == (int32_t)v136) {
        // break -> 0x80e1ab2
        goto lab_0x80e1ab2_2;
    }
    goto lab_0x80e16a0;
  lab_0x80e16e0_2:
    // 0x80e16e0
    v210 = v227;
    v211 = v229;
    v212 = v223;
    v213 = v225;
    v214 = v222;
    while (true) {
      lab_0x80e16e0:
        // 0x80e16e0
        v150 = v214;
        v182 = v213;
        v146 = v212;
        v144 = v211;
        v137 = v210;
        v148 = (int32_t)*v40;
        v151 = (char *)(v150 + 4);
        v138 = *v151;
        v142 = v148 & 2;
        if (v142 == 0) {
            goto lab_0x80e16fb;
        } else {
            // 0x80e16f2
            v169 = v138;
            v172 = v137;
            v173 = v144;
            v171 = v146;
            v170 = v148;
            if (*(int32_t *)v150 == -3) {
                goto lab_0x80e1ae8;
            } else {
                goto lab_0x80e16fb;
            }
        }
    }
  lab_0x80e1a6c_2:
    // 0x80e1a6c
    v215 = v110;
    v228 = v196;
    v230 = v194;
    v224 = v193;
    v226 = v195;
    v219 = (int32_t)v110;
    v220 = v208;
    goto lab_0x80e1a79;
  lab_0x80e0967:;
    // 0x80e0967
    int32_t v274; // 0x80e0620
    int32_t v275 = v274; // 0x80e096c
    int32_t v276; // 0x80e0959
    int32_t v277 = v276; // 0x80e096c
    int32_t v278; // 0x80e0953
    int32_t v279 = v278; // 0x80e096c
    int32_t v280; // 0x80e0620
    int32_t v281; // 0x80e0620
    char v282; // 0x80e0620
    char v283; // 0x80e0620
    int32_t v284; // 0x80e0620
    char v285; // 0x80e0620
    int32_t v286; // 0x80e0982
    int32_t v287; // 0x80e0985
    if (v282 == v285) {
        goto lab_0x80e0d5b;
    } else {
        int32_t v288 = *(int32_t *)(v39 + 24); // 0x80e0972
        v283 = v282;
        v280 = v276;
        v281 = v278;
        if (v288 == 0) {
            goto lab_0x80e09ac;
        } else {
            // 0x80e0979
            if (assert_failed == 0) {
                int32_t v289 = v285 == 0 ? v288 : v288 + 8;
                v286 = *(int32_t *)(v289 + 4);
                v287 = *(int32_t *)v289;
                if (v286 < 0 || v287 == 0) {
                    // 0x80e1008
                    assert_failed = 1;
                    errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
                    errline = 255;
                    elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
                    if (assert_failed != 0) {
                        goto lab_0x80e0994;
                    } else {
                        // 0x80e1058
                        v284 = v274;
                        if (v286 == 0) {
                            goto lab_0x80e0d50;
                        } else {
                            goto lab_0x80e1060;
                        }
                    }
                } else {
                    // 0x80e0d3e
                    assert_failed = 0;
                    v284 = v274;
                    if (v286 != 0) {
                        goto lab_0x80e1060;
                    } else {
                        goto lab_0x80e0d50;
                    }
                }
            } else {
                goto lab_0x80e0994;
            }
        }
    }
  lab_0x80e0d5b:;
    char v290 = v285; // 0x80e0d60
    int32_t v291 = v275; // 0x80e0d60
    int32_t v292 = v279; // 0x80e0d60
    char v293 = v285; // 0x80e0d60
    int32_t v294 = v275; // 0x80e0d60
    int32_t v295 = v279; // 0x80e0d60
    if (v277 == 0) {
        goto lab_0x80e09b8;
    } else {
        goto lab_0x80e0d66;
    }
  lab_0x80e0a42:;
    // 0x80e0a42
    int32_t v296; // 0x80e0620
    int32_t v297 = v296;
    int32_t v298; // 0x80e0620
    int32_t v299 = v298;
    int32_t * v300; // 0x80e0620
    int32_t * v301 = v300;
    char v302; // 0x80e0620
    char v303 = v302;
    int16_t v304; // 0x80e0620
    int16_t v305 = v304;
    char v306; // 0x80e0620
    char v307 = v306;
    int32_t v308 = v297; // 0x80e0a46
    if (v285 != 0) {
        int32_t v309 = *(int32_t *)(v39 + 20); // 0x80e0a4d
        uint32_t v310 = v297 - 176;
        v308 = v297;
        if (v310 < 48 == (v309 != 0)) {
            // 0x80e0a5d
            v308 = (int32_t)*(char *)(v309 + v310);
        }
    }
    uint32_t v311 = v308;
    int32_t v312; // 0x80e0620
    int32_t v313; // 0x80e0a8b
    if ((v312 & 2) != 0) {
        int32_t v314 = v311; // 0x80e08f4
        if (v285 != 0) {
            // 0x80e0fc0
            v314 = cp2u(*(int32_t *)(v39 + 16), (char)v311);
        }
        uint32_t v315 = v314;
        if (v315 != -3) {
            int32_t v316 = encode_utf8(v315 < 127 ? v315 : v315 < 160 ? 32 : v315); // 0x80e091a
            add_to_string((int32_t *)&v88, v316);
        }
        goto lab_0x80e092e;
    } else {
        // 0x80e0a71
        if (*v89 == -1) {
            if (v285 != 0) {
                // 0x80e0ff0
                add_char_to_string((int32_t *)&v88, (char)v311);
                goto lab_0x80e092e;
            } else {
                if (v311 == 127 || v311 < 32) {
                    // 0x80e1368
                    add_char_to_string((int32_t *)&v88, 32);
                    goto lab_0x80e092e;
                } else {
                    // 0x80e0ff0
                    add_char_to_string((int32_t *)&v88, (char)v311);
                    goto lab_0x80e092e;
                }
            }
        } else {
            // 0x80e0a7b
            v313 = *(int32_t *)(v317 + (int32_t)(v285 / 32));
            if (v285 != 0) {
                goto lab_0x80e0aa3;
            } else {
                if (v311 == 127 || v311 < 32) {
                    // 0x80e1220
                    add_char_to_string((int32_t *)&v88, 32);
                    goto lab_0x80e092e;
                } else {
                    goto lab_0x80e0aa3;
                }
            }
        }
    }
  lab_0x80e09b8:;
    int32_t v318 = v292;
    int32_t v319 = v291;
    char v320 = v290;
    int32_t v321 = (int32_t)v27;
    char v322 = v321; // 0x80e09bc
    int32_t v323 = v321; // 0x80e09bf
    int32_t v324 = v318; // 0x80e09bf
    int32_t v325; // 0x80e0620
    int32_t v326; // 0x80e0620
    int16_t v327; // 0x80e0620
    int16_t v328; // 0x80e0620
    int32_t v329; // 0x80e0620
    int32_t * v330; // 0x80e0620
    int32_t v331; // 0x80e09d5
    int32_t v332; // 0x80e09d8
    if (v322 == (char)v327) {
        goto lab_0x80e0da6;
    } else {
        int32_t v333 = *v330; // 0x80e09c5
        v328 = v327;
        v329 = v319;
        v326 = v318;
        if (v333 == 0) {
            goto lab_0x80e09fc;
        } else {
            int32_t v334 = v322 == 0 ? v333 : v333 + 8;
            v331 = *(int32_t *)(v334 + 4);
            v332 = *(int32_t *)v334;
            v325 = v321;
            if (assert_failed == 0) {
                if (v331 < 0 || v332 == 0) {
                    // 0x80e10b8
                    assert_failed = 1;
                    errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
                    errline = 255;
                    elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
                    if (assert_failed != 0) {
                        // 0x80e10b8
                        v325 = (int32_t)v27;
                        goto lab_0x80e09e7;
                    } else {
                        if (v331 == 0) {
                            goto lab_0x80e0da2;
                        } else {
                            goto lab_0x80e1110;
                        }
                    }
                } else {
                    // 0x80e0d90
                    assert_failed = 0;
                    if (v331 != 0) {
                        goto lab_0x80e1110;
                    } else {
                        goto lab_0x80e0da2;
                    }
                }
            } else {
                goto lab_0x80e09e7;
            }
        }
    }
  lab_0x80e0d66:
    // 0x80e0d66
    v290 = v293;
    v291 = v294;
    v292 = v295;
    v306 = v293;
    v304 = v327;
    char v335; // 0x80e0620
    v302 = v335;
    int32_t * v336; // 0x80e0620
    v300 = v336;
    v298 = v294;
    v296 = -3;
    v312 = v295;
    int32_t v337; // 0x80e0620
    if (*(int32_t *)v337 != -3) {
        goto lab_0x80e09b8;
    } else {
        goto lab_0x80e0a42;
    }
  lab_0x80e09ac:
    // 0x80e09ac
    v290 = v283;
    v291 = v274;
    v292 = v281;
    v293 = v283;
    v294 = v274;
    v295 = v281;
    if (v280 != 0) {
        goto lab_0x80e0d66;
    } else {
        goto lab_0x80e09b8;
    }
  lab_0x80e0da6:;
    int16_t v338 = 256 * (int16_t)v323 >> 8; // 0x80e0dad
    int16_t v339 = v338; // 0x80e0db0
    int32_t v340 = v319; // 0x80e0db0
    int32_t v341 = v324; // 0x80e0db0
    int16_t v342 = v338; // 0x80e0db0
    int32_t v343 = v319; // 0x80e0db0
    int32_t v344 = v324; // 0x80e0db0
    if ((v324 & 2) == 0) {
        goto lab_0x80e0a08;
    } else {
        goto lab_0x80e0db6;
    }
  lab_0x80e0994:
    // 0x80e0994
    assert_failed = 0;
    int32_t v345 = (int32_t)*v40; // 0x80e099e
    v283 = v285;
    v280 = v345 & 2;
    v281 = v345;
    goto lab_0x80e09ac;
  lab_0x80e092e:;
    int32_t v346 = v337 + 8; // 0x80e092e
    int32_t v347 = v346; // 0x80e0934
    char v348 = v307; // 0x80e0934
    int16_t v349 = v305; // 0x80e0934
    char v350 = v303; // 0x80e0934
    int32_t * v351 = v301; // 0x80e0934
    int32_t v352 = v299; // 0x80e0934
    int32_t v353 = v346; // 0x80e0934
    uint32_t v354; // 0x80e0620
    if (v346 > v354) {
        // break -> 0x80e0aca
        goto lab_0x80e0aca_3;
    }
    goto lab_0x80e093a;
  lab_0x80e0a08:;
    // 0x80e0a08
    char v362; // 0x80e093a
    char v400 = v362 & 8; // 0x80e094a
    int32_t v601 = v341;
    int32_t v599 = v340;
    int16_t v373 = v339;
    char v372 = v335; // 0x80e0a0f
    int32_t * v370 = v336; // 0x80e0a0f
    int32_t v368 = v599; // 0x80e0a0f
    int32_t v366 = v601; // 0x80e0a0f
    char * v600; // 0x80e0620
    if (v335 == v400) {
        goto lab_0x80e0a27;
    } else {
        if (v400 != 0) {
            int32_t v602 = assert_failed; // 0x80e0f50
            assert_failed = 0;
            if (v602 != 0) {
                // 0x80e1200
                v372 = v400;
                v370 = v336;
                v368 = v599;
                v366 = (int32_t)*v40;
                goto lab_0x80e0a27;
            } else {
                // 0x80e0f5e
                if ((v599 + 260 & -256) > (v599 + 255 & -256)) {
                    // 0x80e1305
                    uint32_t v603; // 0x80e0f7d
                    char * v604; // 0x80e0620
                    char * v605 = mem_realloc(v604, v603); // 0x80e131b
                    if (v605 == NULL) {
                        goto lab_0x80e1358;
                    } else {
                        // 0x80e132a
                        v88 = v605;
                        memset((int32_t *)v605, 0, v603);
                        char * v606 = v88; // 0x80e1347
                        v600 = v606;
                        if (v606 != NULL) {
                            goto lab_0x80e0f97;
                        } else {
                            goto lab_0x80e1358;
                        }
                    }
                } else {
                    // 0x80e0f8c
                    v600 = v88;
                    if (v88 == NULL) {
                        goto lab_0x80e1358;
                    } else {
                        goto lab_0x80e0f97;
                    }
                }
            }
        } else {
            char v607 = *(char *)(v337 + 5); // 0x80e0a19
            v372 = 0;
            v370 = (int32_t *)(int32_t)(v607 + 1);
            v368 = v599;
            v366 = v601;
            goto lab_0x80e0a27;
        }
    }
  lab_0x80e0db6:
    // 0x80e0db6
    v339 = v342;
    v340 = v343;
    v341 = v344;
    v306 = v320;
    v304 = v342;
    v302 = v335;
    v300 = v336;
    v298 = v343;
    v296 = -3;
    v312 = v344;
    if (*(int32_t *)v337 != -3) {
        goto lab_0x80e0a08;
    } else {
        goto lab_0x80e0a42;
    }
  lab_0x80e09fc:
    // 0x80e09fc
    v339 = v328;
    v340 = v329;
    v341 = v326;
    v342 = v328;
    v343 = v329;
    v344 = v326;
    if ((v326 & 2) != 0) {
        goto lab_0x80e0db6;
    } else {
        goto lab_0x80e0a08;
    }
  lab_0x80e093a:;
    char v355 = v307; // 0x80e0620
    int16_t v356 = v305; // 0x80e0620
    char v357 = v303; // 0x80e0620
    int32_t * v358 = v301; // 0x80e0620
    int32_t v359 = v299; // 0x80e0620
    int32_t v360 = v347; // 0x80e0620
    goto lab_0x80e093a_2;
  lab_0x80e0aa3:;
    int32_t v363 = v337 + 8; // 0x80e0aa9
    char * v364 = cp2utf8(v313, v311); // 0x80e0ab0
    add_to_string((int32_t *)&v88, (int32_t)v364);
    v347 = v363;
    v348 = v307;
    v349 = v305;
    v350 = v303;
    v351 = v301;
    v352 = v299;
    v353 = v363;
    if (v363 > v354) {
        // break -> 0x80e0aca
        goto lab_0x80e0aca_3;
    }
    goto lab_0x80e093a;
  lab_0x80e0a27:;
    int32_t v365 = v366;
    int32_t v367 = v368;
    int32_t * v369 = v370;
    char v371 = v372;
    if ((v365 & 2) != 0) {
        // 0x80e0f08
        v306 = v320;
        v304 = v373;
        v302 = v371;
        v300 = v369;
        v298 = v367;
        v296 = -3;
        v312 = v365;
        if (*(int32_t *)v337 != -3) {
            goto lab_0x80e0a30;
        } else {
            goto lab_0x80e0a42;
        }
    } else {
        goto lab_0x80e0a30;
    }
  lab_0x80e09e7:
    // 0x80e09e7
    assert_failed = 0;
    v328 = 256 * (int16_t)v325 >> 8;
    v329 = v319;
    v326 = (int32_t)*v40;
    goto lab_0x80e09fc;
  lab_0x80e1060:;
    int32_t v374 = v286 + v274; // 0x80e1063
    if ((v374 + 256 & -256) > (v274 + 255 & -256)) {
        char * v375 = mem_realloc(v88, 0); // 0x80e141e
        v284 = v274;
        if (v375 == NULL) {
            goto lab_0x80e0d50;
        } else {
            // 0x80e143d
            *(int32_t *)&v88 = (int32_t)v375;
            memset((int32_t *)v375, 0, 0);
            goto lab_0x80e1088;
        }
    } else {
        goto lab_0x80e1088;
    }
  lab_0x80e0d50:;
    int32_t v376 = (int32_t)*v40; // 0x80e0d50
    v275 = v284;
    v277 = v376 & 2;
    v279 = v376;
    goto lab_0x80e0d5b;
  lab_0x80e0a30:;
    char * v377 = (char *)(v337 + 5); // 0x80e0a30
    unsigned char v378 = *v377; // 0x80e0a30
    int32_t v379; // 0x80e0620
    int32_t v380; // 0x80e0620
    int32_t v381; // 0x80e0620
    int32_t * v382; // 0x80e074e
    if (v378 != (char)(int32_t)v369) {
        int32_t v383 = assert_failed; // 0x80e0dc8
        assert_failed = 0;
        if (v383 != 0) {
            // 0x80e0f18
            v380 = v367;
            v381 = v367;
            if (*v382 != 0) {
                goto lab_0x80e0e30;
            } else {
                goto lab_0x80e0f2d;
            }
        } else {
            uint32_t v384 = v367 + 259 & -256; // 0x80e0df5
            if (v384 > (v367 + 255 & -256)) {
                char * v385 = mem_realloc(v88, v384); // 0x80e11a6
                v379 = v367;
                if (v385 == NULL) {
                    goto lab_0x80e0e25;
                } else {
                    // 0x80e11b9
                    v88 = v385;
                    memset((int32_t *)v385, 0, v384);
                    goto lab_0x80e0e04;
                }
            } else {
                goto lab_0x80e0e04;
            }
        }
    } else {
        // 0x80e0a40
        v306 = v320;
        v304 = v373;
        v302 = v371;
        v300 = v369;
        v298 = v367;
        v296 = *(int32_t *)v337;
        v312 = v365;
        goto lab_0x80e0a42;
    }
  lab_0x80e1088:;
    char * v386 = v88; // 0x80e1088
    v284 = v274;
    if (v386 != NULL) {
        // 0x80e1093
        memcpy(&((struct _IO_FILE *)(v274 + (int32_t)v386))->e0, (int32_t *)v287, v286);
        *(char *)(v374 + (int32_t)v88) = 0;
        v284 = v374;
    }
    goto lab_0x80e0d50;
  lab_0x80e1110:;
    int32_t v387 = v331 + v319; // 0x80e1113
    if ((v387 + 256 & -256) > (v319 + 255 & -256)) {
        char * v388 = mem_realloc(v88, 0); // 0x80e149f
        if (v388 == NULL) {
            goto lab_0x80e0da2;
        } else {
            // 0x80e14be
            *(int32_t *)&v88 = (int32_t)v388;
            memset((int32_t *)v388, 0, 0);
            goto lab_0x80e1138;
        }
    } else {
        goto lab_0x80e1138;
    }
  lab_0x80e0da2:
    // 0x80e0da2
    v323 = (int32_t)v27;
    v324 = (int32_t)*v40;
    goto lab_0x80e0da6;
  lab_0x80e1138:;
    char * v389 = v88; // 0x80e1138
    if (v389 == NULL) {
        goto lab_0x80e0da2;
    } else {
        // 0x80e1143
        memcpy(&((struct _IO_FILE *)(v319 + (int32_t)v389))->e0, (int32_t *)v332, v331);
        *(char *)(v387 + (int32_t)v88) = 0;
        v328 = 256 * (int16_t)(int32_t)v27 >> 8;
        v329 = v387;
        v326 = (int32_t)*v40;
        goto lab_0x80e09fc;
    }
  lab_0x80e0e30:;
    int32_t v390 = v380;
    int32_t v391; // 0x80e0620
    if ((*v377 & 112) != 0) {
        // 0x80e0e5d
        add_bytes_to_string__3();
        v391 = v390;
        goto lab_0x80e0e70;
    } else {
        // 0x80e0e53
        if (*v40 % 2 != 0) {
            // 0x80e11e8
            add_bytes_to_string__3();
            v391 = v390;
            goto lab_0x80e0e70;
        } else {
            // 0x80e0e5d
            add_bytes_to_string__3();
            v391 = v390;
            goto lab_0x80e0e70;
        }
    }
  lab_0x80e0f2d:;
    int32_t v392 = v381;
    v391 = v392;
    char * v361; // 0x80e093a
    if ((*v361 & 64) != 0) {
        // 0x80e0f37
        add_bytes_to_string__3();
        v391 = v392;
    }
    goto lab_0x80e0e70;
  lab_0x80e0e04:;
    char * v596 = v88; // 0x80e0e04
    v379 = v367;
    if (v596 != NULL) {
        int32_t v597 = v367 + 3; // 0x80e0de3
        int32_t v598 = v367 + (int32_t)v596; // 0x80e0e0b
        *(int16_t *)v598 = 0x5b1b;
        *(char *)(v598 + 2) = 48;
        *(char *)(v597 + (int32_t)v88) = 0;
        v379 = v597;
    }
    goto lab_0x80e0e25;
  lab_0x80e1358:
    // 0x80e1358
    v372 = v400;
    v370 = v336;
    v368 = v599;
    v366 = (int32_t)*v40;
    goto lab_0x80e0a27;
  lab_0x80e0f97:
    // 0x80e0f97
    *(int32_t *)(v599 + (int32_t)v600) = 0x6d315b1b;
    *(char *)(v599 + 4 + (int32_t)v88) = 0;
    v372 = v400;
    v370 = v336;
    v368 = 0x1000000 * v599 + 0x4000000 >> 24;
    v366 = (int32_t)*v40;
    goto lab_0x80e0a27;
  lab_0x80e0e70:;
    int32_t v393 = v391;
    int32_t v394 = v393; // 0x80e0e74
    if ((char)(int32_t)v27 == 0) {
        goto lab_0x80e0ed5;
    } else {
        // 0x80e0e76
        if (*v330 == 0) {
            goto lab_0x80e0ed5;
        } else {
            int32_t v395 = assert_failed; // 0x80e0e7d
            assert_failed = 0;
            v394 = v393;
            if (v395 != 0) {
                goto lab_0x80e0ed5;
            } else {
                uint32_t v396 = v393 + 258 & -256; // 0x80e0ea9
                uint32_t v397 = v393 + 255 & -256; // 0x80e0eab
                v27 = (char *)v397;
                if (v396 > v397) {
                    char * v398 = mem_realloc(v88, v396); // 0x80e1396
                    v394 = v393;
                    if (v398 == NULL) {
                        goto lab_0x80e0ed5;
                    } else {
                        // 0x80e13a9
                        v88 = v398;
                        int32_t v399 = (int32_t)v27; // 0x80e13ac
                        memset(&((struct _IO_FILE *)(v399 + (int32_t)v398))->e0, 0, v396 - v399);
                        goto lab_0x80e0eb8;
                    }
                } else {
                    goto lab_0x80e0eb8;
                }
            }
        }
    }
  lab_0x80e0e25:
    // 0x80e0e25
    v380 = v379;
    v381 = v379;
    if (*v382 == 0) {
        goto lab_0x80e0f2d;
    } else {
        goto lab_0x80e0e30;
    }
  lab_0x80e0ed5:
    // 0x80e0ed5
    if (v400 != 0) {
        // 0x80e1178
        add_bytes_to_string__3();
    }
    // 0x80e0edf
    add_bytes_to_string__3();
    v306 = v320;
    v304 = v373;
    v302 = v371;
    v300 = (int32_t *)(int32_t)v378;
    v298 = v394;
    v296 = *(int32_t *)v337;
    v312 = (int32_t)*v40;
    goto lab_0x80e0a42;
  lab_0x80e0eb8:;
    char * v401 = v88; // 0x80e0eb8
    v394 = v393;
    if (v401 != NULL) {
        // 0x80e0ebf
        *(int16_t *)(v393 + (int32_t)v401) = 0x343b;
        *(char *)(v393 + 2 + (int32_t)v88) = 0;
        v394 = 0x1000000 * v393 + 0x2000000 >> 24;
    }
    goto lab_0x80e0ed5;
  lab_0x80e08c0:;
    char * v402; // 0x80e08c3
    char * v403; // 0x80e08c0
    int32_t v404; // 0x80e0620
    int32_t v405; // 0x80e0620
    int16_t v406; // 0x80e0620
    char v407; // 0x80e0620
    int32_t * v408; // 0x80e0620
    char v409; // 0x80e0620
    char * v410; // 0x80e0620
    int32_t v411; // 0x80e0620
    int32_t v412; // 0x80e0620
    int32_t v413; // 0x80e0620
    int32_t v414; // 0x80e0620
    if (v402 == v403 == v404 + 80 > v354) {
        // 0x80e08db
        v405 = v404;
        v348 = v409;
        v349 = v406;
        v350 = v407;
        v351 = v408;
        v352 = v412;
        v353 = v404;
        if (v404 > v354) {
            goto lab_0x80e0aca_3;
        } else {
            goto lab_0x80e093a_3;
        }
    } else {
        // 0x80e1248
        v114 = 2;
        v113 = 27;
        uint32_t v415 = elinks_ulongcat(&v113, v413, v411, 10, 0, 10, 0); // 0x80e1297
        v405 = v354;
        if (v415 >= 0) {
            // 0x80e12a0
            *(char *)(v114 + v414) = 59;
            v114++;
            uint32_t v416 = elinks_ulongcat(&v113, v413, (int32_t)v410, 10, 0, 10, 0); // 0x80e12dc
            v405 = v354;
            if (v416 >= 0) {
                // 0x80e12e5
                *(char *)(v114 + v414) = 72;
                v114++;
                add_bytes_to_string__3();
                v405 = v354;
            }
        }
        goto lab_0x80e093a_3;
    }
  lab_0x80e088b:;
    char * v417; // 0x80e0620
    char * v418; // 0x80e0620
    int32_t v419; // 0x80e0620
    int16_t v420; // 0x80e0620
    char v421; // 0x80e0620
    int32_t * v422; // 0x80e0620
    char v423; // 0x80e0620
    int32_t v424; // 0x80e0620
    int32_t v425; // 0x80e0620
    uint32_t v426; // 0x80e0620
    if (v426 < 33) {
        // 0x80e0890
        if (*(int32_t *)v424 < 33) {
            char v427 = *(char *)(v354 + 4); // 0x80e08a7
            char v428 = *(char *)(v424 + 4); // 0x80e08b1
            v417 = v402;
            v418 = v403;
            v423 = v409;
            v420 = v406;
            v421 = v407;
            v422 = v408;
            v425 = v412;
            v419 = v404;
            if (v427 == v428) {
                goto lab_0x80e0ad3;
            } else {
                goto lab_0x80e08c0;
            }
        } else {
            goto lab_0x80e08c0;
        }
    } else {
        goto lab_0x80e08c0;
    }
  lab_0x80e0aca_3:
    // 0x80e0aca
    *(int32_t *)&v27 = (int32_t)v110;
    v417 = v110;
    v418 = v110;
    v423 = v348;
    v420 = v349;
    v421 = v350;
    v422 = v351;
    v425 = v352;
    v419 = v353;
    goto lab_0x80e0ad3;
  lab_0x80e093a_3:
    // 0x80e093a
    v355 = v409;
    v356 = v406;
    v357 = v407;
    v358 = v408;
    v359 = v412;
    v360 = v405;
    while (true) {
      lab_0x80e093a_2:
        // 0x80e093a
        v337 = v360;
        v274 = v359;
        v336 = v358;
        v335 = v357;
        v327 = v356;
        v282 = v355;
        v361 = (char *)(v337 + 4);
        v362 = *v361;
        v285 = v362 & -128;
        v27 = (char *)(int32_t)(v362 & 32);
        v278 = (int32_t)*v40;
        v276 = v278 & 2;
        if (v276 == 0) {
            goto lab_0x80e0967;
        } else {
            // 0x80e095e
            v306 = v282;
            v304 = v327;
            v302 = v335;
            v300 = v336;
            v298 = v274;
            v296 = -3;
            v312 = v278;
            if (*(int32_t *)v337 == -3) {
                goto lab_0x80e0a42;
            } else {
                goto lab_0x80e0967;
            }
        }
    }
    goto lab_0x80e0aca_3;
  lab_0x80e0ad3:;
    int32_t v429 = v419;
    int32_t v430 = v425;
    int32_t * v431 = v422;
    char v432 = v421;
    int16_t v433 = v420;
    char v434 = v423;
    char * v435 = v418;
    int32_t v436 = v424 + 8; // 0x80e0ad6
    int32_t v437 = v354 + 8; // 0x80e0add
    char * v438 = v435; // 0x80e0ae7
    char * v439 = v136; // 0x80e0ae7
    char * v440 = v136; // 0x80e0ae7
    char v441 = v434; // 0x80e0ae7
    int16_t v442 = v433; // 0x80e0ae7
    int32_t v443 = v436; // 0x80e0ae7
    int32_t v444 = v437; // 0x80e0ae7
    char v445 = v432; // 0x80e0ae7
    int32_t * v446 = v431; // 0x80e0ae7
    int32_t v447 = v430; // 0x80e0ae7
    int32_t v448 = v429; // 0x80e0ae7
    if (v136 < v410) {
        // break -> 0x80e0b0c
        goto lab_0x80e0b0c_2;
    }
    char * v449 = (char *)((int32_t)v410 + 1); // 0x80e0af9
    char * v450 = v417; // 0x80e0af9
    char * v451 = v435; // 0x80e0af9
    char v452 = v434; // 0x80e0af9
    int16_t v453 = v433; // 0x80e0af9
    int32_t v454 = v436; // 0x80e0af9
    int32_t v455 = v437; // 0x80e0af9
    char v456 = v432; // 0x80e0af9
    int32_t * v457 = v431; // 0x80e0af9
    int32_t v458 = v430; // 0x80e0af9
    int32_t v459 = v429; // 0x80e0af9
    v438 = v435;
    v439 = v410;
    v440 = v410;
    v441 = v434;
    v442 = v433;
    v443 = v436;
    v444 = v437;
    v445 = v432;
    v446 = v431;
    v447 = v430;
    v448 = v429;
    int32_t v460; // 0x80e0620
    int32_t v461; // 0x80e0796
    if (v460 == v461 == v410 == v136) {
        // break -> 0x80e0b0c
        goto lab_0x80e0b0c_2;
    }
    goto lab_0x80e0858;
  lab_0x80e0cb5:
    // 0x80e0cb5
    if (v17 != __readgsdword(20)) {
        // 0x80e272e
        __stack_chk_fail();
        return;
    }
  lab_0x80e066e:;
    int32_t * v465 = (int32_t *)(v16 + 16); // 0x80e067c
    int32_t v466 = get_opt_(*v465, "type"); // 0x80e0682
    char * str = (char *)*(int32_t *)(*v465 + 12); // 0x80e0692
    v27 = str;
    int32_t v467 = 0x1000000 * strlen(str) >> 24; // 0x80e1521
    char * v468 = mem_alloc(v467 + 44); // 0x80e152a
    char v469; // 0x80e0620
    int32_t v470; // 0x80e0621
    if (v468 == NULL) {
        goto lab_0x80e0cb5;
    } else {
        // 0x80e1539
        v39 = (int32_t)v468;
        *(int32_t *)(v39 + 4) = (int32_t)&active_screen_drivers;
        *(int32_t *)v468 = active_screen_drivers;
        active_screen_drivers = v39;
        *(int32_t *)(*(int32_t *)v468 + 4) = v39;
        *(int32_t *)(v39 + 8) = *(int32_t *)v466;
        set_screen_driver_opt(&g83, &g83);
        int32_t v471 = *(int32_t *)(*v465 + 12); // 0x80e1563
        memcpy(&((struct _IO_FILE *)(v39 + 40))->e0, (int32_t *)v471, v467 + 1);
        *(int32_t *)(*v465 + 48) = 0x80e0460;
        v40 = (char *)(v39 + 36);
        char v472 = *v20 & -3 | *v40 & 2;
        *v20 = v472;
        v317 = v39 + 12;
        v89 = (int32_t *)v317;
        *v20 = 4 * (char)(*v89 != -1) | v472 & -5;
        if (init_string((int32_t *)&v88) == 0) {
            goto lab_0x80e0cb5;
        } else {
            // 0x80e074e
            int32_t v473; // bp-4, 0x80e0620
            v470 = &v473;
            v382 = (int32_t *)(v39 + 32);
            int32_t v474 = *v382; // 0x80e074e
            if (v474 == 2) {
                int32_t v475 = *v18; // 0x80e1e35
                uint32_t v476 = *(int32_t *)(v475 + 24); // 0x80e1e3e
                int32_t v477 = *(int32_t *)(v16 + 44); // 0x80e1e41
                v136 = (char *)(v477 - 1);
                v121 = *(int32_t *)(v16 + 48) - 1;
                v27 = (char *)*(int32_t *)(v475 + 4);
                int32_t * v478 = (int32_t *)(v475 + 28); // 0x80e1e71
                int32_t v479 = *v478; // 0x80e1e71
                int32_t v480 = v479; // 0x80e1e76
                if (v121 < v479) {
                    // 0x80e1e78
                    *v478 = v121;
                    v480 = v121;
                }
                // 0x80e1e7b
                v469 = -1;
                if (v476 <= v480) {
                    int32_t v481 = 8 * v476 * v477; // 0x80e1ea6
                    v115 = &v114;
                    v116 = v470 - 53;
                    v41 = (int32_t *)(v39 + 28);
                    int32_t v482 = 0;
                    v106 = -1;
                    int32_t * v483 = (int32_t *)((*(int32_t *)v475 + v481) % 256);
                    char v484 = -1;
                    int32_t v485 = v481 + (int32_t)v27;
                    int16_t v486 = -1;
                    char v487 = -1;
                    v112 = v476;
                    char v488 = 0;
                    char * v489 = v136; // 0x80e1ed7
                    char * v490 = v136;
                    char * v491 = v136;
                    v111 = v112 + 1;
                    int32_t * v492; // 0x80e0620
                    char * v134; // 0x80e0620
                    char * v133; // 0x80e0620
                    char * v493; // 0x80e0620
                    int32_t v494; // 0x80e0620
                    char * v495; // 0x80e0620
                    char * v496; // 0x80e0620
                    char * v497; // 0x80e0620
                    char * v498; // 0x80e2311
                    int32_t v499; // 0x80e0620
                    int32_t v500; // 0x80e0620
                    int32_t v122; // 0x80e0620
                    int32_t v501; // 0x80e0620
                    int32_t v502; // 0x80e0620
                    int16_t v128; // 0x80e0620
                    int16_t v503; // 0x80e0620
                    int16_t v504; // 0x80e0620
                    char v125; // 0x80e0620
                    char v505; // 0x80e0620
                    char v506; // 0x80e0620
                    char v132; // 0x80e0620
                    char v507; // 0x80e0620
                    char v508; // 0x80e0620
                    int32_t * v123; // 0x80e0620
                    int32_t * v509; // 0x80e0620
                    char v130; // 0x80e0620
                    char v510; // 0x80e0620
                    char v511; // 0x80e0620
                    int32_t v126; // 0x80e0620
                    int32_t v512; // 0x80e0620
                    int32_t v135; // 0x80e0620
                    int32_t v513; // 0x80e22f4
                    if (v489 >= NULL) {
                        // 0x80e1eee
                        v134 = v491;
                        v133 = v490;
                        v132 = v488;
                        v130 = v487;
                        v128 = v486;
                        v126 = v485;
                        v125 = v484;
                        v123 = v483;
                        v122 = v482;
                        if (v489 == NULL != (v121 == v112)) {
                            while (true) {
                                // 0x80e1f18
                                v107 = v122;
                                v124 = v125;
                                v119 = v126;
                                v127 = v128;
                                v129 = v130;
                                v131 = v132;
                                v105 = 1;
                                v104 = v133;
                                v103 = v134;
                                v109 = (char *)1;
                                v95 = 0x1000000 * (int32_t)v123 >> 24;
                                if (*(char *)(v95 + 6) == *(char *)(v119 + 6)) {
                                    // 0x80e2618
                                    v120 = (char *)*v123;
                                    v27 = v120;
                                    if (*(char *)(v95 + 5) == *(char *)(v119 + 5)) {
                                        // 0x80e266f
                                        if (v135 != *(int32_t *)v119) {
                                            goto lab_0x80e2632;
                                        } else {
                                            // 0x80e2681
                                            *(int32_t *)&v110 = v105;
                                            v101 = v103;
                                            v102 = v104;
                                            if (*(char *)(v95 + 4) != *(char *)(v119 + 4)) {
                                                goto lab_0x80e2632;
                                            } else {
                                                goto lab_0x80e22f1;
                                            }
                                        }
                                    } else {
                                        goto lab_0x80e2632;
                                    }
                                } else {
                                    goto lab_0x80e1f2e;
                                }
                            }
                            // 0x80e232a
                            v494 = *v478;
                            v495 = v498;
                            v496 = v493;
                            v497 = v493;
                            v508 = v507;
                            v511 = v510;
                            v504 = v503;
                            v512 = v513;
                            v506 = v505;
                            v509 = v492;
                            v500 = v499;
                            v502 = v501;
                        }
                    }
                    int32_t v514 = v482;
                    int32_t v515 = v106;
                    int32_t * v516 = v483;
                    char v517 = v484;
                    int32_t v518 = v485;
                    int16_t v519 = v486;
                    char v520 = v487;
                    char v521 = v488;
                    char * v522 = v489;
                    char * v523 = v490;
                    char * v524 = v491;
                    int32_t v525 = v480; // 0x80e233d
                    v469 = v520;
                    while (v525 >= v111) {
                        // 0x80e1ec5
                        v482 = v514;
                        v106 = v515;
                        v483 = v516;
                        v484 = v517;
                        v485 = v518;
                        v486 = v519;
                        v487 = v520;
                        v112 = v111;
                        v488 = v521;
                        v489 = v522;
                        v490 = v523;
                        v491 = v524;
                        v111 = v112 + 1;
                        if (v489 >= NULL) {
                            // 0x80e1eee
                            v134 = v491;
                            v133 = v490;
                            v132 = v488;
                            v130 = v487;
                            v128 = v486;
                            v126 = v485;
                            v125 = v484;
                            v123 = v483;
                            v122 = v482;
                            if (v489 == NULL != (v121 == v112)) {
                                while (true) {
                                    // 0x80e1f18
                                    v107 = v122;
                                    v124 = v125;
                                    v119 = v126;
                                    v127 = v128;
                                    v129 = v130;
                                    v131 = v132;
                                    v105 = 1;
                                    v104 = v133;
                                    v103 = v134;
                                    v109 = (char *)1;
                                    v95 = 0x1000000 * (int32_t)v123 >> 24;
                                    if (*(char *)(v95 + 6) == *(char *)(v119 + 6)) {
                                        // 0x80e2618
                                        v120 = (char *)*v123;
                                        v27 = v120;
                                        if (*(char *)(v95 + 5) == *(char *)(v119 + 5)) {
                                            // 0x80e266f
                                            if (v135 != *(int32_t *)v119) {
                                                goto lab_0x80e2632;
                                            } else {
                                                // 0x80e2681
                                                *(int32_t *)&v110 = v105;
                                                v101 = v103;
                                                v102 = v104;
                                                if (*(char *)(v95 + 4) != *(char *)(v119 + 4)) {
                                                    goto lab_0x80e2632;
                                                } else {
                                                    goto lab_0x80e22f1;
                                                }
                                            }
                                        } else {
                                            goto lab_0x80e2632;
                                        }
                                    } else {
                                        goto lab_0x80e1f2e;
                                    }
                                }
                                // 0x80e232a
                                v494 = *v478;
                                v495 = v498;
                                v496 = v493;
                                v497 = v493;
                                v508 = v507;
                                v511 = v510;
                                v504 = v503;
                                v512 = v513;
                                v506 = v505;
                                v509 = v492;
                                v500 = v499;
                                v502 = v501;
                            }
                        }
                        // 0x80e232a
                        v514 = v482;
                        v515 = v106;
                        v516 = v483;
                        v517 = v484;
                        v518 = v485;
                        v519 = v486;
                        v520 = v487;
                        v521 = v488;
                        v522 = v489;
                        v523 = v490;
                        v524 = v491;
                        v469 = v520;
                    }
                }
                goto lab_0x80e0b28;
            } else {
                if (v474 > 2) {
                    if (v474 == 3) {
                        int32_t v526 = *v18; // 0x80e15b9
                        int32_t v527 = *(int32_t *)(v16 + 44); // 0x80e15c2
                        uint32_t v528 = *(int32_t *)(v526 + 24); // 0x80e15c5
                        v271 = *(int32_t *)(v16 + 48) - 1;
                        v27 = (char *)*(int32_t *)(v526 + 4);
                        int32_t * v529 = (int32_t *)(v526 + 28); // 0x80e15ed
                        int32_t v530 = *v529; // 0x80e15ed
                        int32_t v531 = v530; // 0x80e15f6
                        if (v271 < v530) {
                            // 0x80e15f8
                            *v529 = v271;
                            v531 = v271;
                        }
                        // 0x80e1607
                        v469 = -1;
                        if (v528 <= v531) {
                            // 0x80e160f
                            v257 = v527 - 1;
                            int32_t v532 = 8 * v527 * v528; // 0x80e1629
                            v233 = &v114;
                            v234 = v470 - 53;
                            v152 = (int32_t *)(v39 + 28);
                            char v533 = 0; // 0x80e1646
                            int32_t v534 = v528; // 0x80e1646
                            char v535 = -1; // 0x80e1646
                            int16_t v536 = -1; // 0x80e1646
                            int32_t v537 = v532 + (int32_t)v27; // 0x80e1646
                            char v538 = -1; // 0x80e1646
                            int32_t * v539 = (int32_t *)((*(int32_t *)v526 + v532) % 256); // 0x80e1646
                            int32_t v540 = -1; // 0x80e1646
                            int32_t v541 = 0; // 0x80e1646
                            while (true) {
                                int32_t v542 = v541;
                                int32_t v543 = v540;
                                int32_t * v544 = v539;
                                char v545 = v538;
                                int32_t v546 = v537;
                                int16_t v547 = v536;
                                char v548 = v535;
                                v270 = v534;
                                char v549 = v533;
                                v232 = v270 + 1;
                                char * v550 = (char *)v270; // 0x80e1665
                                v110 = v550;
                                v249 = v549;
                                v250 = v548;
                                v251 = v547;
                                v252 = v546;
                                v253 = v545;
                                v254 = v544;
                                v255 = v543;
                                v256 = v542;
                                if (v257 >= 0) {
                                    // 0x80e1673
                                    v259 = (char *)1;
                                    v260 = 1;
                                    v261 = v550;
                                    v262 = v549;
                                    v263 = v548;
                                    v264 = v547;
                                    v265 = v546;
                                    v266 = v545;
                                    v267 = v544;
                                    v268 = v543;
                                    v269 = v542;
                                    v249 = v549;
                                    v250 = v548;
                                    v251 = v547;
                                    v252 = v546;
                                    v253 = v545;
                                    v254 = v544;
                                    v255 = v543;
                                    v256 = v542;
                                    if (v257 == 0 != (v271 == v270)) {
                                        while (true) {
                                          lab_0x80e16a0:
                                            // 0x80e16a0
                                            v221 = v269;
                                            v218 = v268;
                                            int32_t * v272 = v267;
                                            v225 = v266;
                                            v237 = v265;
                                            v223 = v264;
                                            v229 = v263;
                                            v227 = v262;
                                            v217 = v261;
                                            v216 = v260;
                                            v231 = v259;
                                            v247 = (int32_t)v272;
                                            v209 = 0x1000000 * v247 >> 24;
                                            if (*(char *)(v209 + 6) == *(char *)(v237 + 6)) {
                                                int32_t v273 = *v272;
                                                v238 = (char *)v273;
                                                v27 = v238;
                                                if (*(char *)(v209 + 5) == *(char *)(v237 + 5)) {
                                                    // 0x80e1df7
                                                    if (v273 != *(int32_t *)v237) {
                                                        goto lab_0x80e1dba;
                                                    } else {
                                                        // 0x80e1e09
                                                        *(int32_t *)&v136 = v216;
                                                        v215 = v217;
                                                        v228 = v227;
                                                        v230 = v229;
                                                        v224 = v223;
                                                        v226 = v225;
                                                        v219 = v218;
                                                        v220 = v221;
                                                        if (*(char *)(v209 + 4) != *(char *)(v237 + 4)) {
                                                            goto lab_0x80e1dba;
                                                        } else {
                                                            goto lab_0x80e1a79;
                                                        }
                                                    }
                                                } else {
                                                    goto lab_0x80e1dba;
                                                }
                                            } else {
                                                goto lab_0x80e16b6;
                                            }
                                        }
                                    }
                                }
                              lab_0x80e1ab2_2:
                                // 0x80e1ab2
                                v540 = v255;
                                v537 = v252;
                                v536 = v251;
                                v535 = v250;
                                v533 = v249;
                                v469 = v535;
                                v534 = v232;
                                v538 = v253;
                                v539 = v254;
                                v541 = v256;
                                if (*v529 < v232) {
                                    // break -> 0x80e0b28
                                    break;
                                }
                            }
                        }
                        goto lab_0x80e0b28;
                    } else {
                        if (v474 != 5) {
                            goto lab_0x80e0769;
                        } else {
                            goto lab_0x80e0cfe;
                        }
                    }
                } else {
                    if (v474 == -1) {
                        goto lab_0x80e0cfe;
                    } else {
                        goto lab_0x80e0769;
                    }
                }
            }
        }
    }
  lab_0x80e0b28:;
    // 0x80e0b28
    int32_t v551; // 0x80e0620
    int32_t v552 = v551;
    int32_t * v553; // 0x80e0620
    int32_t v554; // 0x80e0620
    int32_t v555; // 0x80e0620
    if (v552 == 0) {
        int32_t v556 = *(int32_t *)(v19 + 8); // 0x80e150d
        int32_t * v557 = (int32_t *)(v19 + 16);
        int32_t v558 = *(int32_t *)(v19 + 12);
        v553 = v557;
        v554 = v558;
        v555 = v556;
        if (v556 == *v557) {
            // 0x80e26d0
            v553 = v557;
            v554 = v558;
            v555 = v556;
            if (v558 != *(int32_t *)(v19 + 20)) {
                goto lab_0x80e0b7e;
            } else {
                goto lab_0x80e0c70;
            }
        } else {
            goto lab_0x80e0b7e;
        }
    } else {
        // 0x80e0b32
        if (*v382 != 0) {
            // 0x80e2705
            add_bytes_to_string__3();
        }
        // 0x80e0b3c
        add_bytes_to_string__3();
        if (v469 != 0) {
            // 0x80e0b54
            if (*(int32_t *)(v39 + 24) != 0) {
                // 0x80e0b5b
                add_bytes_to_string__3();
            }
        }
        // 0x80e0b72
        v553 = (int32_t *)(v19 + 16);
        v554 = *(int32_t *)(v19 + 12);
        v555 = *(int32_t *)(v19 + 8);
        goto lab_0x80e0b7e;
    }
  lab_0x80e0cfe:
    // 0x80e0cfe
    errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/terminal/screen.c";
    errline = 1091;
    elinks_internal("Invalid color mode (%d).", *v382);
    goto lab_0x80e0cb5;
  lab_0x80e0769:;
    int32_t v559 = *v18; // 0x80e0775
    int32_t v560 = *(int32_t *)(v16 + 44); // 0x80e077e
    uint32_t v561 = *(int32_t *)(v559 + 24); // 0x80e0781
    v136 = (char *)(v560 - 1);
    v461 = *(int32_t *)(v16 + 48) - 1;
    v27 = (char *)*(int32_t *)(v559 + 4);
    int32_t * v562 = (int32_t *)(v559 + 28); // 0x80e07b1
    int32_t v563 = *v562; // 0x80e07b1
    int32_t v564 = v563; // 0x80e07b6
    if (v461 < v563) {
        // 0x80e07b8
        *v562 = v461;
        v564 = v461;
    }
    // 0x80e07bb
    v469 = -1;
    if (v561 <= v564) {
        char * v565 = v27; // 0x80e07cd
        int32_t v566 = 8 * v560 * v561; // 0x80e07e1
        v27 = (char *)-1;
        v413 = &v114;
        v414 = v470 - 53;
        v330 = (int32_t *)(v39 + 28);
        char * v567 = (char *)-1; // 0x80e07fc
        char * v568 = v136; // 0x80e07fc
        char * v569 = v136; // 0x80e07fc
        int32_t v570 = v561; // 0x80e07fc
        char v571 = -1; // 0x80e07fc
        int16_t v572 = -1; // 0x80e07fc
        int32_t v573 = v566 + (int32_t)v565; // 0x80e07fc
        int32_t v574 = *(int32_t *)v559 + v566; // 0x80e07fc
        char v575 = -1; // 0x80e07fc
        int32_t * v576 = (int32_t *)-1; // 0x80e07fc
        int32_t v577 = 0; // 0x80e07fc
        while (true) {
            int32_t v578 = v577;
            int32_t v579; // 0x80e0620
            int32_t v580 = v579;
            int32_t * v581 = v576;
            char v582 = v575;
            int32_t v583 = v574;
            int32_t v584 = v573;
            int16_t v585 = v572;
            char v586 = v571;
            v460 = v570;
            char * v587 = v568; // 0x80e271c
            char * v588 = v567;
            v411 = v460 + 1;
            char * v589 = (char *)v460; // 0x80e081a
            v110 = v589;
            v438 = v588;
            v439 = v587;
            v440 = v569;
            v441 = v586;
            v442 = v585;
            v443 = v584;
            v444 = v583;
            v445 = v582;
            v446 = v581;
            v447 = v580;
            v448 = v578;
            if (v569 >= NULL) {
                // 0x80e082c
                v449 = (char *)1;
                v450 = v589;
                v451 = v588;
                v452 = v586;
                v453 = v585;
                v454 = v584;
                v455 = v583;
                v456 = v582;
                v457 = v581;
                v458 = v580;
                v459 = v578;
                v438 = v588;
                v439 = v587;
                v440 = v587;
                v441 = v586;
                v442 = v585;
                v443 = v584;
                v444 = v583;
                v445 = v582;
                v446 = v581;
                v447 = v580;
                v448 = v578;
                if (v587 == NULL != (v460 == v461)) {
                    while (true) {
                      lab_0x80e0858:
                        // 0x80e0858
                        v404 = v459;
                        v412 = v458;
                        v408 = v457;
                        v407 = v456;
                        v354 = v455;
                        v424 = v454;
                        v406 = v453;
                        v409 = v452;
                        v403 = v451;
                        v402 = v450;
                        v410 = v449;
                        char v462 = *(char *)(v424 + 5); // 0x80e0865
                        unsigned char v463 = v462 ^ *(char *)(v354 + 5);
                        if ((v463 & 112) != 0) {
                            goto lab_0x80e08c0;
                        } else {
                            // 0x80e087c
                            v426 = *(int32_t *)v354;
                            if (v463 % 8 == 0) {
                                // 0x80e13d1
                                if (v426 != *(int32_t *)v424) {
                                    goto lab_0x80e088b;
                                } else {
                                    char v464 = *(char *)(v424 + 4); // 0x80e13f7
                                    v417 = v402;
                                    v418 = v403;
                                    v423 = v409;
                                    v420 = v406;
                                    v421 = v407;
                                    v422 = v408;
                                    v425 = v412;
                                    v419 = v404;
                                    if (*(char *)(v354 + 4) != v464) {
                                        goto lab_0x80e088b;
                                    } else {
                                        goto lab_0x80e0ad3;
                                    }
                                }
                            } else {
                                goto lab_0x80e088b;
                            }
                        }
                    }
                }
            }
          lab_0x80e0b0c_2:
            // 0x80e0b0c
            v577 = v448;
            v576 = v446;
            v575 = v445;
            v574 = v444;
            v573 = v443;
            v572 = v442;
            v571 = v441;
            v569 = v440;
            v568 = v439;
            v567 = v438;
            v570 = v411;
            v579 = v447;
            v469 = v571;
            v551 = v447;
            if (*v562 < v411) {
                // break -> 0x80e0b28
                break;
            }
        }
    }
    goto lab_0x80e0b28;
  lab_0x80e0b7e:
    // 0x80e0b7e
    *(int32_t *)(v19 + 20) = v554;
    *v553 = v555;
    v114 = 2;
    v113 = 27;
    int32_t v590 = &v114; // 0x80e0bc6
    if (elinks_ulongcat(&v113, v590, v554 + 1, 10, 0, 10, 0) >= 0) {
        int32_t v591 = v470 - 53; // 0x80e0bf4
        *(char *)(v114 + v591) = 59;
        v114++;
        if (elinks_ulongcat(&v113, v590, v555 + 1, 10, 0, 10, 0) >= 0) {
            // 0x80e0c1b
            *(char *)(v114 + v591) = 72;
            v114++;
            add_bytes_to_string__3();
        }
    }
    if (v552 != 0) {
        // 0x80e0c3a
        if (*v20 % 2 != 0) {
            // 0x80e26f5
            want_draw();
        }
        // 0x80e0c4a
        hard_write(*(int32_t *)(v16 + 36), v88, v552);
        if (*v20 % 2 != 0) {
            // 0x80e26e7
            done_draw();
        }
    }
    goto lab_0x80e0c70;
  lab_0x80e0c70:
    // 0x80e0c70
    done_string((int32_t *)&v88);
    int32_t * v592 = (int32_t *)(v16 + 48); // 0x80e0c87
    int32_t v593 = *(int32_t *)(v16 + 44); // 0x80e0c8a
    int32_t v594 = *(int32_t *)(v19 + 4); // 0x80e0c90
    int32_t v595 = *(int32_t *)v19; // 0x80e0c93
    memcpy(&((struct _IO_FILE *)v594)->e0, (int32_t *)v595, 8 * *v592 * v593);
    *v22 = 0;
    *v21 = *v592;
    goto lab_0x80e0cb5;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/terminal/tab.c
// Address range: 0x80e27f0 - 0x80e289b
// Line range:    99 - 115
int32_t * get_tab_by_number(int32_t * term, int32_t num) {
    int32_t v1 = (int32_t)term;
    int32_t v2 = *(int32_t *)(v1 + 12); // 0x80e27fd
    int32_t v3 = v1 + 8; // 0x80e2800
    int32_t v4 = num; // 0x80e2805
    int32_t v5 = v2; // 0x80e2805
    if (v2 != v3) {
        int32_t v6 = v2;
        int32_t v7; // 0x80e2810
        while (*(int32_t *)(v6 + 8) != 1) {
            // 0x80e2810
            v7 = *(int32_t *)(v6 + 4);
            v5 = v3;
            if (v7 == v3) {
                // break (via goto) -> 0x80e2830
                goto lab_0x80e2830;
            }
            v6 = v7;
        }
        // 0x80e2822
        v5 = v6;
        while (v4 != 0) {
            int32_t v8 = *(int32_t *)(v6 + 4); // 0x80e2826
            v4--;
            v5 = v8;
            if (v8 == v3) {
                // break -> 0x80e2830
                break;
            }
            v6 = v8;
            while (*(int32_t *)(v6 + 8) != 1) {
                // 0x80e2810
                v7 = *(int32_t *)(v6 + 4);
                v5 = v3;
                if (v7 == v3) {
                    // break (via goto) -> 0x80e2830
                    goto lab_0x80e2830;
                }
                v6 = v7;
            }
            // 0x80e2822
            v5 = v6;
        }
    }
  lab_0x80e2830:
    // 0x80e2830
    if (assert_failed != 0) {
        // 0x80e2888
        assert_failed = 0;
        return (int32_t *)*(int32_t *)v3;
    }
    // 0x80e283a
    assert_failed = v5 == v3;
    if (v5 != v3) {
        // 0x80e284c
        return (int32_t *)v5;
    }
    // 0x80e2852
    errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/terminal/tab.c";
    errline = 111;
    elinks_internal("assertion (LIST_OF(struct window) *) win != &term->windows failed: tab number out of range");
    if (assert_failed == 0) {
        // 0x80e284c
        return (int32_t *)v5;
    }
    // 0x80e2888
    assert_failed = 0;
    return (int32_t *)*(int32_t *)v3;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/terminal/terminal.c
// Address range: 0x80e3240 - 0x80e3260
// Line range:    119 - 122
int32_t get_terminal_codepage(int32_t * term) {
    // 0x80e3240
    return *(int32_t *)get_opt_(*(int32_t *)((int32_t)term + 16), "charset");
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/terminal/terminal.c
// Address range: 0x80e3900 - 0x80e3a7e
// Line range:    134 - 172
void destroy_terminal(int32_t * term) {
    int32_t v1 = (int32_t)term;
    int32_t v2 = v1 + 8; // 0x80e390e
    bookmark_auto_save_tabs(term);
    detach_downloads_from_terminal(term);
    int32_t * v3 = (int32_t *)v2; // 0x80e391e
    int32_t v4 = *v3; // 0x80e391e
    *(int32_t *)(v1 + 60) = 0;
    if (v4 != v2) {
        delete_window((int32_t *)v4);
        int32_t v5 = *v3; // 0x80e3938
        while (v5 != v2) {
            // 0x80e3930
            delete_window((int32_t *)v5);
            v5 = *v3;
        }
    }
    int32_t v6 = *(int32_t *)(v1 + 20); // 0x80e393f
    if (v6 != 0) {
        // 0x80e3946
        mem_free((char *)v6);
    }
    int32_t v7 = *(int32_t *)(v1 + 24); // 0x80e394e
    if (v7 != 0) {
        // 0x80e3955
        done_screen((int32_t *)v7);
    }
    int32_t * fd2 = (int32_t *)(v1 + 32); // 0x80e397d
    set_handlers(*fd2, NULL, NULL, NULL, NULL);
    int32_t v8 = *(int32_t *)(v1 + 328); // 0x80e3988
    if (v8 != 0) {
        // 0x80e3992
        mem_free((char *)v8);
    }
    int32_t * v9 = (int32_t *)(v1 + 40); // 0x80e399a
    int32_t fd = *v9; // 0x80e399a
    if (fd != -1) {
        // 0x80e39a2
        close(fd);
        set_handlers(*v9, NULL, NULL, NULL, NULL);
    }
    int32_t * v10 = (int32_t *)(v1 + 4); // 0x80e39d7
    *(int32_t *)(*term + 4) = *v10;
    *(int32_t *)*v10 = *term;
    close(*fd2);
    int32_t fd3 = *(int32_t *)(v1 + 36); // 0x80e39ef
    if (fd3 == 1) {
        // 0x80e3a50
        unhandle_terminal_signals(term);
        free_all_itrms();
        if (terminals != 0x81486d4) {
            // 0x80e3a69
            if (fork() != 0) {
                // 0x80e3a72
                exit(0);
                // UNREACHABLE
            }
        }
    } else {
        // 0x80e39f7
        if (fd3 != *fd2) {
            // 0x80e39fc
            close(fd3);
        }
    }
    int32_t * v11 = (int32_t *)(*(int32_t *)(v1 + 16) + 8); // 0x80e3a07
    *v11 = *v11 - 1;
    mem_free((char *)term);
    if (terminals == 0x81486d4) {
        int32_t v12 = get_opt_((int32_t)config_options, "ui.sessions.keep_session_active"); // 0x80e3a3e
        if (*(int32_t *)v12 == 0) {
            // 0x80e3a21
            program = 1;
            return;
        }
    }
    // 0x80e3a21
    program = 0;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/terminal/terminal.c
// Address range: 0x80e3a80 - 0x80e3aae
// Line range:    183 - 187
void destroy_all_terminals(void) {
    // 0x80e3a80
    return;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/terminal/terminal.c
// Address range: 0x80e3ab0 - 0x80e3ae0
// Line range:    125 - 131
void redraw_all_terminals(void) {
    // 0x80e3ab0
    return;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/terminal/terminal.c
// Address range: 0x80e3d30 - 0x80e3d69
// Line range:    45 - 51
void redraw_terminal(int32_t * term) {
    int32_t v1 = 3; // bp-28, 0x80e3d4a
    term_send_event(term, &v1);
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/terminal/window.c
// Address range: 0x80e3ee0 - 0x80e3f77
// Line range:    20 - 35
void redraw_from_window(int32_t * win) {
    int32_t v1 = (int32_t)win;
    int32_t v2 = *(int32_t *)(v1 + 20); // 0x80e3eec
    int32_t * v3 = (int32_t *)(v2 + 52); // 0x80e3eef
    if (*v3 != 0) {
        // 0x80e3ef6
        return;
    }
    int32_t v4 = v2 + 8; // 0x80e3f03
    *v3 = 1;
    int32_t v5 = *(int32_t *)(v1 + 4); // 0x80e3f24
    int32_t v6 = v5; // 0x80e3f29
    if (v4 == v5) {
        // 0x80e3f68
        *v3 = 0;
        return;
    }
    int32_t v7; // 0x80e3ee0
    while (true) {
      lab_0x80e3f4d_2:
        // 0x80e3f4d
        v7 = v6;
        if (*(int32_t *)(v7 + 8) != 0) {
            int32_t v8 = *(int32_t *)(v7 + 20); // 0x80e3f30
            int32_t v9 = *(int32_t *)(v8 + 60); // 0x80e3f33
            if (v7 == (int32_t)get_tab_by_number((int32_t *)v8, v9)) {
                goto lab_0x80e3f54;
            } else {
                int32_t v10 = *(int32_t *)(v7 + 4); // 0x80e3f46
                if (v4 == v10) {
                    // break -> 0x80e3f68
                    break;
                }
                // 0x80e3f4d
                v6 = v10;
                goto lab_0x80e3f4d_2;
            }
        } else {
            goto lab_0x80e3f54;
        }
    }
  lab_0x80e3f68:
    // 0x80e3f68
    *v3 = 0;
  lab_0x80e3f54:;
    int32_t v11 = *(int32_t *)(v7 + 4); // 0x80e3f61
    if (v4 == v11) {
        // break -> 0x80e3f68
        goto lab_0x80e3f68;
    }
    // 0x80e3f4d
    v6 = v11;
    goto lab_0x80e3f4d_2;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/terminal/window.c
// Address range: 0x80e3f80 - 0x80e3fea
// Line range:    77 - 89
void delete_window(int32_t * win) {
    int32_t v1 = (int32_t)win;
    int32_t * v2 = (int32_t *)(v1 + 4); // 0x80e3f8c
    *(int32_t *)(*win + 4) = *v2;
    *(int32_t *)*v2 = *win;
    int32_t v3 = *(int32_t *)(v1 + 16); // 0x80e3fc2
    if (v3 != 0) {
        // 0x80e3fc9
        mem_free((char *)v3);
    }
    // 0x80e3fd1
    redraw_terminal((int32_t *)*(int32_t *)(v1 + 20));
    mem_free((char *)win);
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/util/color.c
// Address range: 0x80e49e0 - 0x80e49f4
// Line range:    77 - 82
void free_colors_lookup(void) {
    // 0x80e49e0
    fastfind_done(&ff_colors_index);
}

// Address range: 0x80e4a20 - 0x80e4b5c
int32_t elinks_ulongcat(int32_t * a1, int32_t a2, uint32_t a3, uint32_t a4, int32_t a5, uint32_t a6, int32_t a7) {
    int32_t v1 = 0; // 0x80e4a4f
    if (a2 != 0) {
        // 0x80e4a51
        v1 = *(int32_t *)a2;
    }
    // 0x80e4a53
    if (a6 < 2 || a1 != NULL == (a4 != 0) != a6 < 17) {
        // 0x80e4a5f
        return -1;
    }
    uint32_t v2 = a6 - 1; // 0x80e4a90
    uint32_t v3 = a3; // 0x80e4a95
    int32_t v4 = 1; // 0x80e4a95
    int32_t v5 = 1; // 0x80e4a95
    if (v2 < a3) {
        v4++;
        v3 /= a6;
        v5 = v4;
        while (v3 > v2) {
            // 0x80e4aa8
            v4++;
            v3 /= a6;
            v5 = v4;
        }
    }
    uint32_t v6 = v5;
    int32_t v7 = v6 <= a4 ? v6 : a4;
    if (a2 != 0) {
        int32_t * v8 = (int32_t *)a2; // 0x80e4ad7
        *v8 = *v8 + v7;
    }
    int32_t v9 = (int32_t)a1;
    char v10 = a5; // 0x80e4a3e
    int32_t v11 = v1; // 0x80e4add
    if (v10 != 0) {
        int32_t v12 = a4 - v7; // 0x80e4ae2
        v11 = v1;
        if (v12 != 0) {
            if (a2 != 0) {
                int32_t * v13 = (int32_t *)a2; // 0x80e4aee
                *v13 = *v13 + v12;
            }
            int32_t v14 = v12 + v1;
            int32_t v15 = v9 - 1 + v14; // 0x80e4afd
            int32_t v16 = v12; // 0x80e4afd
            *(char *)v15 = v10;
            v16--;
            v15--;
            v11 = v14;
            while (v16 != 0) {
                // 0x80e4b00
                *(char *)v15 = v10;
                v16--;
                v15--;
                v11 = v14;
            }
        }
    }
    int32_t result = v6 <= a4 ? 0 : v6;
    int32_t v17 = v11 + v9;
    *(char *)(v17 + v7) = 0;
    if (v7 == 0) {
        // 0x80e4a5f
        return result;
    }
    int32_t v18 = a7 != 0 ? (int32_t)"0123456789ABCDEF" : (int32_t)"0123456789abcdef"; // 0x80e4a48
    int32_t v19 = v7 - 1; // 0x80e4b33
    int32_t v20 = v17 + v19; // 0x80e4b39
    *(char *)v20 = *(char *)(a3 % a6 + v18);
    int32_t v21 = v20; // 0x80e4b52
    int32_t v22 = v19; // 0x80e4b52
    if (v19 == 0) {
        // 0x80e4a5f
        return result;
    }
    uint32_t v23 = a3; // 0x80e4b52
    v21--;
    v23 /= a6;
    v22--;
    *(char *)v21 = *(char *)(v23 % a6 + v18);
    while (v22 != 0) {
        // 0x80e4b40
        v21--;
        v23 /= a6;
        v22--;
        *(char *)v21 = *(char *)(v23 % a6 + v18);
    }
    // 0x80e4a5f
    return result;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/util/conv.c
// Address range: 0x80e4cc0 - 0x80e4e71
// Line range:    531 - 562
int32_t c_tolower(int32_t c) {
    // 0x80e4cc0
    g90 = c - 65;
    int32_t result = c; // 0x80e4cce
    int32_t v1 = 121; // 0x80e4cce
    switch (c) {
        case 65: {
            // 0x80e4e58
            v1 = 97;
        }
        case 89: {
          lab_0x80e4ce8:
            // 0x80e4ce8
            result = v1;
            // break -> 0x80e4ce0
            break;
        }
        case 66: {
            // 0x80e4cd8
            result = 98;
            // break -> 0x80e4ce0
            break;
        }
        case 67: {
            // 0x80e4e48
            v1 = 99;
            // branch (via goto) -> 0x80e4ce8
            goto lab_0x80e4ce8;
        }
        case 68: {
            // 0x80e4e38
            v1 = 100;
            // branch (via goto) -> 0x80e4ce8
            goto lab_0x80e4ce8;
        }
        case 69: {
            // 0x80e4e28
            v1 = 101;
            // branch (via goto) -> 0x80e4ce8
            goto lab_0x80e4ce8;
        }
        case 70: {
            // 0x80e4e18
            v1 = 102;
            // branch (via goto) -> 0x80e4ce8
            goto lab_0x80e4ce8;
        }
        case 71: {
            // 0x80e4e08
            v1 = 103;
            // branch (via goto) -> 0x80e4ce8
            goto lab_0x80e4ce8;
        }
        case 72: {
            // 0x80e4df8
            v1 = 104;
            // branch (via goto) -> 0x80e4ce8
            goto lab_0x80e4ce8;
        }
        case 73: {
            // 0x80e4de8
            v1 = 105;
            // branch (via goto) -> 0x80e4ce8
            goto lab_0x80e4ce8;
        }
        case 74: {
            // 0x80e4dd8
            v1 = 106;
            // branch (via goto) -> 0x80e4ce8
            goto lab_0x80e4ce8;
        }
        case 75: {
            // 0x80e4dc8
            v1 = 107;
            // branch (via goto) -> 0x80e4ce8
            goto lab_0x80e4ce8;
        }
        case 76: {
            // 0x80e4db8
            v1 = 108;
            // branch (via goto) -> 0x80e4ce8
            goto lab_0x80e4ce8;
        }
        case 77: {
            // 0x80e4da8
            v1 = 109;
            // branch (via goto) -> 0x80e4ce8
            goto lab_0x80e4ce8;
        }
        case 78: {
            // 0x80e4d98
            v1 = 110;
            // branch (via goto) -> 0x80e4ce8
            goto lab_0x80e4ce8;
        }
        case 79: {
            // 0x80e4d88
            v1 = 111;
            // branch (via goto) -> 0x80e4ce8
            goto lab_0x80e4ce8;
        }
        case 80: {
            // 0x80e4d78
            v1 = 112;
            // branch (via goto) -> 0x80e4ce8
            goto lab_0x80e4ce8;
        }
        case 81: {
            // 0x80e4d68
            v1 = 113;
            // branch (via goto) -> 0x80e4ce8
            goto lab_0x80e4ce8;
        }
        case 82: {
            // 0x80e4d58
            v1 = 114;
            // branch (via goto) -> 0x80e4ce8
            goto lab_0x80e4ce8;
        }
        case 83: {
            // 0x80e4d48
            v1 = 115;
            // branch (via goto) -> 0x80e4ce8
            goto lab_0x80e4ce8;
        }
        case 84: {
            // 0x80e4d38
            v1 = 116;
            // branch (via goto) -> 0x80e4ce8
            goto lab_0x80e4ce8;
        }
        case 85: {
            // 0x80e4d28
            v1 = 117;
            // branch (via goto) -> 0x80e4ce8
            goto lab_0x80e4ce8;
        }
        case 86: {
            // 0x80e4d18
            v1 = 118;
            // branch (via goto) -> 0x80e4ce8
            goto lab_0x80e4ce8;
        }
        case 87: {
            // 0x80e4d08
            v1 = 119;
            // branch (via goto) -> 0x80e4ce8
            goto lab_0x80e4ce8;
        }
        case 88: {
            // 0x80e4cf8
            v1 = 120;
            // branch (via goto) -> 0x80e4ce8
            goto lab_0x80e4ce8;
        }
        case 90: {
            // 0x80e4e68
            v1 = 122;
            // branch (via goto) -> 0x80e4ce8
            goto lab_0x80e4ce8;
        }
    }
    // 0x80e4ce0
    return result;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/util/conv.c
// Address range: 0x80e4e80 - 0x80e5031
// Line range:    564 - 594
int32_t c_toupper(int32_t c) {
    // 0x80e4e80
    g91 = c - 97;
    int32_t result = c; // 0x80e4e8e
    int32_t v1 = 89; // 0x80e4e8e
    switch (c) {
        case 97: {
            // 0x80e5018
            v1 = 65;
        }
        case 121: {
          lab_0x80e4ea8:
            // 0x80e4ea8
            result = v1;
            // break -> 0x80e4ea0
            break;
        }
        case 98: {
            // 0x80e4e98
            result = 66;
            // break -> 0x80e4ea0
            break;
        }
        case 99: {
            // 0x80e5008
            v1 = 67;
            // branch (via goto) -> 0x80e4ea8
            goto lab_0x80e4ea8;
        }
        case 100: {
            // 0x80e4ff8
            v1 = 68;
            // branch (via goto) -> 0x80e4ea8
            goto lab_0x80e4ea8;
        }
        case 101: {
            // 0x80e4fe8
            v1 = 69;
            // branch (via goto) -> 0x80e4ea8
            goto lab_0x80e4ea8;
        }
        case 102: {
            // 0x80e4fd8
            v1 = 70;
            // branch (via goto) -> 0x80e4ea8
            goto lab_0x80e4ea8;
        }
        case 103: {
            // 0x80e4fc8
            v1 = 71;
            // branch (via goto) -> 0x80e4ea8
            goto lab_0x80e4ea8;
        }
        case 104: {
            // 0x80e4fb8
            v1 = 72;
            // branch (via goto) -> 0x80e4ea8
            goto lab_0x80e4ea8;
        }
        case 105: {
            // 0x80e4fa8
            v1 = 73;
            // branch (via goto) -> 0x80e4ea8
            goto lab_0x80e4ea8;
        }
        case 106: {
            // 0x80e4f98
            v1 = 74;
            // branch (via goto) -> 0x80e4ea8
            goto lab_0x80e4ea8;
        }
        case 107: {
            // 0x80e4f88
            v1 = 75;
            // branch (via goto) -> 0x80e4ea8
            goto lab_0x80e4ea8;
        }
        case 108: {
            // 0x80e4f78
            v1 = 76;
            // branch (via goto) -> 0x80e4ea8
            goto lab_0x80e4ea8;
        }
        case 109: {
            // 0x80e4f68
            v1 = 77;
            // branch (via goto) -> 0x80e4ea8
            goto lab_0x80e4ea8;
        }
        case 110: {
            // 0x80e4f58
            v1 = 78;
            // branch (via goto) -> 0x80e4ea8
            goto lab_0x80e4ea8;
        }
        case 111: {
            // 0x80e4f48
            v1 = 79;
            // branch (via goto) -> 0x80e4ea8
            goto lab_0x80e4ea8;
        }
        case 112: {
            // 0x80e4f38
            v1 = 80;
            // branch (via goto) -> 0x80e4ea8
            goto lab_0x80e4ea8;
        }
        case 113: {
            // 0x80e4f28
            v1 = 81;
            // branch (via goto) -> 0x80e4ea8
            goto lab_0x80e4ea8;
        }
        case 114: {
            // 0x80e4f18
            v1 = 82;
            // branch (via goto) -> 0x80e4ea8
            goto lab_0x80e4ea8;
        }
        case 115: {
            // 0x80e4f08
            v1 = 83;
            // branch (via goto) -> 0x80e4ea8
            goto lab_0x80e4ea8;
        }
        case 116: {
            // 0x80e4ef8
            v1 = 84;
            // branch (via goto) -> 0x80e4ea8
            goto lab_0x80e4ea8;
        }
        case 117: {
            // 0x80e4ee8
            v1 = 85;
            // branch (via goto) -> 0x80e4ea8
            goto lab_0x80e4ea8;
        }
        case 118: {
            // 0x80e4ed8
            v1 = 86;
            // branch (via goto) -> 0x80e4ea8
            goto lab_0x80e4ea8;
        }
        case 119: {
            // 0x80e4ec8
            v1 = 87;
            // branch (via goto) -> 0x80e4ea8
            goto lab_0x80e4ea8;
        }
        case 120: {
            // 0x80e4eb8
            v1 = 88;
            // branch (via goto) -> 0x80e4ea8
            goto lab_0x80e4ea8;
        }
        case 122: {
            // 0x80e5028
            v1 = 90;
            // branch (via goto) -> 0x80e4ea8
            goto lab_0x80e4ea8;
        }
    }
    // 0x80e4ea0
    return result;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/util/conv.c
// Address range: 0x80e5040 - 0x80e5054
// Line range:    596 - 609
int32_t c_isupper(int32_t c) {
    // 0x80e5040
    return (bool)((uint32_t)(c - 65) < 26);
}

// Address range: 0x80e5400 - 0x80e554a
int32_t add_bytes_to_string__4(void) {
    // 0x80e5400
    if (assert_failed != 0) {
        // 0x80e541b
        assert_failed = 0;
        // 0x80e5428
        return 0;
    }
    int32_t v1; // 0x80e5400
    if (v1 < 0 || v1 == 0 || v1 == 0) {
        // 0x80e5440
        assert_failed = 1;
        errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
        errline = 255;
        elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
        if (assert_failed != 0) {
            // 0x80e541b
            assert_failed = 0;
            // 0x80e5428
            return 0;
        }
    } else {
        // 0x80e54e8
        assert_failed = 0;
    }
    if (v1 == 0) {
        // 0x80e5428
        int32_t result; // 0x80e5400
        return result;
    }
    int32_t * v2 = (int32_t *)(v1 + 4); // 0x80e5484
    int32_t v3 = *v2; // 0x80e5484
    int32_t v4 = v3 + v1; // 0x80e5487
    int32_t v5 = v3 + 255; // 0x80e548a
    uint32_t v6 = v5 & -256; // 0x80e5498
    uint32_t v7 = v4 + 256 & -256; // 0x80e549f
    int32_t set_mem = v5; // 0x80e54a8
    if (v7 > v6) {
        char * v8 = mem_realloc((char *)v5, v7); // 0x80e5507
        if (v8 == NULL) {
            // 0x80e5428
            return 0;
        }
        int32_t v9 = (int32_t)v8; // 0x80e5507
        *(int32_t *)v1 = v9;
        set_mem = (int32_t)memset(&((struct _IO_FILE *)(v6 + v9))->e0, 0, v7 - v6);
    }
    // 0x80e54aa
    if (set_mem != 0) {
        int32_t * dest_mem = memcpy(&((struct _IO_FILE *)(*v2 + set_mem))->e0, (int32_t *)v1, v1); // 0x80e54c2
        *(char *)(v4 + (int32_t)dest_mem) = 0;
        *v2 = v4;
    }
    // 0x80e5428
    return 0;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/util/conv.c
// Address range: 0x80e55f0 - 0x80e56a5
// Line range:    516 - 177
int32_t sanitize_url(char * url) {
    int32_t len = strlen(url); // 0x80e55ff
    if (len == 0) {
        // 0x80e562a
        return 1;
    }
    int32_t v1 = (int32_t)url;
    int32_t v2 = len + v1;
    int32_t v3 = len; // 0x80e5613
    int32_t v4 = v2; // 0x80e5613
    int32_t v5; // 0x80e55f0
    int32_t v6; // 0x80e55f0
    int32_t v7; // 0x80e55f0
    int32_t v8; // 0x80e55f0
    int32_t v9; // 0x80e55f0
    while (*(char *)(v4 - 1) >= 32) {
        // 0x80e5622
        v4--;
        // 0x80e5618
        v3--;
        if (v3 == 0) {
            // 0x80e5638
            v6 = len;
            v8 = v1;
            v5 = v2;
            v7 = len;
            v9 = v1;
            if (*url != 32) {
                goto lab_0x80e564f;
            } else {
                goto lab_0x80e5640;
            }
        }
    }
    // 0x80e562a
    return 0;
  lab_0x80e564f:;
    int32_t v10 = v7; // 0x80e5657
    int32_t v11 = v5; // 0x80e5657
    int32_t v12 = v7; // 0x80e5657
    if (*(char *)(v5 - 1) == 32) {
        goto lab_0x80e566e;
    } else {
        goto lab_0x80e56a0;
    }
  lab_0x80e5640:;
    int32_t v13 = v8;
    int32_t v14 = v6;
    int32_t v15 = v13 + 1; // 0x80e5640
    int32_t v16 = v14 - 1; // 0x80e5643
    v6 = v16;
    v8 = v15;
    int32_t v17; // 0x80e55f0
    int32_t v18; // 0x80e55f0
    if (*(char *)v15 == 32) {
        goto lab_0x80e5640;
    } else {
        // 0x80e564b
        v17 = v15;
        v18 = 1;
        if (v16 == 0) {
            goto lab_0x80e567c;
        } else {
            // 0x80e564b
            v5 = v13 + v14;
            v7 = v16;
            v9 = v15;
            goto lab_0x80e564f;
        }
    }
  lab_0x80e566e:;
    int32_t v19 = v11;
    int32_t v20 = v10 - 1; // 0x80e566e
    int32_t v21 = v19 - 1; // 0x80e5671
    *(char *)v21 = 0;
    v17 = v9;
    v18 = 1;
    if (v20 != 0) {
        // 0x80e5660
        v10 = v20;
        v11 = v21;
        v12 = v20;
        if (*(char *)(v19 - 2) != 32) {
            goto lab_0x80e56a0;
        } else {
            goto lab_0x80e566e;
        }
    } else {
        goto lab_0x80e567c;
    }
  lab_0x80e56a0:
    // 0x80e56a0
    v17 = v9;
    v18 = v12 + 1;
    goto lab_0x80e567c;
  lab_0x80e567c:
    // 0x80e567c
    memmove((int32_t *)url, (int32_t *)v17, v18);
    return 1;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/util/conv.c
// Address range: 0x80e56b0 - 0x80e5755
// Line range:    500 - 177
void sanitize_title(char * title) {
    int32_t len = strlen(title); // 0x80e56bf
    if (len == 0) {
        // 0x80e5744
        return;
    }
    int32_t v1 = (int32_t)title;
    int32_t v2 = len + v1; // 0x80e56ce
    int32_t v3 = len; // 0x80e56ce
    v2--;
    char * v4 = (char *)v2; // 0x80e56d3
    if (*v4 < 32) {
        // 0x80e56d9
        *v4 = 32;
    }
    while (v3 != 1) {
        // 0x80e56dd
        v3--;
        v2--;
        v4 = (char *)v2;
        if (*v4 < 32) {
            // 0x80e56d9
            *v4 = 32;
        }
    }
    int32_t len2 = strlen(title); // 0x80e56e7
    int32_t v5 = len2; // 0x80e56f1
    int32_t v6 = v1; // 0x80e56f1
    int32_t v7 = len2; // 0x80e56f1
    int32_t v8 = v1; // 0x80e56f1
    if (*title == 32) {
        v6++;
        v5--;
        v7 = v5;
        v8 = v6;
        while (*(char *)v6 == 32) {
            // 0x80e56f8
            v6++;
            v5--;
            v7 = v5;
            v8 = v6;
        }
    }
    // 0x80e5703
    if (v7 == 0) {
        // 0x80e5734
        memmove((int32_t *)title, (int32_t *)v8, 1);
        // 0x80e5744
        return;
    }
    int32_t v9 = v8 + v7;
    int32_t v10 = v7; // 0x80e570f
    int32_t v11 = v7; // 0x80e570f
    if (*(char *)(v9 - 1) != 32) {
      lab_0x80e5750:
        // 0x80e5734
        memmove((int32_t *)title, (int32_t *)v8, v11 + 1);
        // 0x80e5744
        return;
    }
    int32_t v12 = v9;
    v10--;
    int32_t v13 = v12 - 1; // 0x80e5729
    *(char *)v13 = 0;
    while (v10 != 0) {
        // 0x80e5718
        v11 = v10;
        if (*(char *)(v12 - 2) != 32) {
            goto lab_0x80e5750;
        }
        v12 = v13;
        v10--;
        v13 = v12 - 1;
        *(char *)v13 = 0;
    }
    // 0x80e5734
    memmove((int32_t *)title, (int32_t *)v8, 1);
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/util/conv.c
// Address range: 0x80e6210 - 0x80e63a0
// Line range:    132 - 139
int32_t * add_long_to_string(int32_t * string, int32_t number) {
    // 0x80e6210
    int32_t v1; // bp-4, 0x80e6210
    int32_t v2 = &v1; // 0x80e6211
    int32_t v3 = __readgsdword(20); // 0x80e6216
    int32_t v4; // 0x80e6210
    int32_t v5; // 0x80e6210
    if (assert_failed != 0) {
        goto lab_0x80e6322;
    } else {
        // 0x80e623d
        assert_failed = string == NULL;
        if (string == NULL) {
            // 0x80e62f8
            errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/util/conv.c";
            errline = 138;
            elinks_internal("assertion string failed!");
            v4 = 0;
            v5 = assert_failed;
            if (assert_failed == 0) {
                goto lab_0x80e625a;
            } else {
                goto lab_0x80e6322;
            }
        } else {
            goto lab_0x80e625a;
        }
    }
  lab_0x80e6322:
    // 0x80e6322
    assert_failed = 0;
    int32_t * result = NULL; // 0x80e632c
    int32_t v6 = v4; // 0x80e632c
    int32_t v7 = number; // 0x80e632c
    int32_t v8 = v5; // 0x80e632c
    goto lab_0x80e632e;
  lab_0x80e632e:
    // 0x80e632e
    if (v3 == __readgsdword(20)) {
        // 0x80e633a
        return result;
    }
    // 0x80e6374
    __stack_chk_fail();
    int32_t v9 = v6; // 0x80e6374
    int32_t v10 = v7; // 0x80e6374
    int32_t v11 = v8; // 0x80e6374
    goto lab_0x80e6379;
  lab_0x80e625a:;
    int32_t v33 = 31; // 0x80e6263
    int32_t v34 = 0; // 0x80e6263
    int32_t v35 = number; // 0x80e6263
    if (number < 0) {
        // 0x80e6265
        *(char *)(v2 - 60) = 45;
        v33 = 30;
        v34 = 1;
        v35 = -number;
    }
    // 0x80e6276
    int32_t v15; // 0x80e6210
    int32_t v17; // 0x80e6210
    int32_t v16; // 0x80e6210
    int32_t v13; // 0x80e6210
    int32_t v14; // 0x80e6210
    if (v35 < 10) {
        // 0x80e6358
        *(char *)(v2 - 59 + v34) = 0;
        v13 = v34 + 1;
        v14 = 0;
        v15 = v34;
        v16 = v35;
        v17 = 1;
        goto lab_0x80e62b8;
    } else {
        uint32_t v36 = v35;
        int32_t v37 = 2; // 0x80e628b
        int32_t v38 = v36 / 10; // 0x80e6296
        int32_t v39 = v37; // 0x80e6296
        while (v36 >= 100) {
            // 0x80e6286
            v36 = v38;
            v37 = v39 + 1;
            v38 = v36 / 10;
            v39 = v37;
        }
        // 0x80e6298
        v9 = v34;
        v10 = v35;
        v11 = v37;
        if (v37 > v33) {
            int32_t v40 = v34 + v33; // 0x80e62a7
            *(char *)(v2 - 60 + v40) = 0;
            v13 = v40;
            v14 = v37;
            v15 = v34;
            v16 = v35;
            v17 = v33;
            goto lab_0x80e62b8;
        } else {
            goto lab_0x80e6379;
        }
    }
  lab_0x80e6379:;
    int32_t v12 = v11 + v9; // 0x80e6379
    *(char *)(v2 - 60 + v12) = 0;
    v13 = v12;
    v14 = 0;
    v15 = v9;
    v16 = v10;
    v17 = v11;
    int32_t v18 = v12; // 0x80e6386
    int32_t v19 = v10; // 0x80e6386
    int32_t v20 = 0; // 0x80e6386
    if (v11 == 0) {
        goto lab_0x80e62eb;
    } else {
        goto lab_0x80e62b8;
    }
  lab_0x80e62eb:;
    int32_t v21 = v20;
    int32_t v22 = v19;
    int32_t v23 = v18;
    int32_t v24 = v23; // 0x80e62f0
    int32_t v25 = v22; // 0x80e62f0
    int32_t v26 = v21; // 0x80e62f0
    if (v23 != 0) {
        // 0x80e6348
        result = (int32_t *)add_bytes_to_string__4();
        v6 = v23;
        v7 = v22;
        v8 = v21;
        goto lab_0x80e632e;
    } else {
        goto lab_0x80e62f2;
    }
  lab_0x80e62b8:;
    int32_t v27 = v2 - 61 + v15 + v17; // 0x80e62bc
    int32_t v28 = v16 / 10;
    char v29 = *(char *)(v16 + (int32_t)"0123456789abcdef" - 2 * v28); // 0x80e62d1
    *(char *)v27 = v29;
    int32_t v30 = v17 - 1; // 0x80e62df
    v27--;
    int32_t v31 = v28; // 0x80e62e2
    int32_t v32 = v30; // 0x80e62e2
    while (v30 != 0) {
        // 0x80e62c0
        v28 = v31 / 10;
        v29 = *(char *)(v31 + (int32_t)"0123456789abcdef" - 2 * v28);
        *(char *)v27 = v29;
        v30 = v32 - 1;
        v27--;
        v31 = v28;
        v32 = v30;
    }
    // 0x80e62e4
    v18 = v13;
    v19 = v28;
    v20 = v30;
    v24 = v14;
    v25 = v28;
    v26 = v30;
    if (v14 < 0) {
        goto lab_0x80e62f2;
    } else {
        goto lab_0x80e62eb;
    }
  lab_0x80e62f2:
    // 0x80e62f2
    result = NULL;
    v6 = v24;
    v7 = v25;
    v8 = v26;
    goto lab_0x80e632e;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/util/error.c
// Address range: 0x80e6b20 - 0x80e6bb8
// Line range:    41 - 47
void er(int32_t bell, int32_t shall_sleep, char * fmt, char * params) {
    // 0x80e6b20
    int32_t v1; // 0x80e6b20
    if (v1 != 0) {
        // 0x80e6b98
        fputc(7, g43);
    }
    // 0x80e6b31
    __vfprintf_chk(g43, 1, (char *)v1, bell);
    fputc(10, g43);
    fflush(g43);
    if (v1 == 0) {
        // 0x80e6b74
        return;
    }
    // 0x80e6b80
    sleep(1);
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/util/error.c
// Address range: 0x80e6bc0 - 0x80e6c50
// Line range:    107 - 124
void elinks_internal(char * fmt, ...) {
    int32_t v1 = __readgsdword(20); // 0x80e6bcb
    int32_t v2; // bp-4112, 0x80e6bc0
    __snprintf_chk((char *)&v2, 0x1000, 1, 0x1000, (char *)&g12);
    int32_t v3; // 0x80e6bc0
    er((int32_t)&v3, (int32_t)&g83, (char *)&g83, (char *)&g83);
    if (v1 == __readgsdword(20)) {
        // 0x80e6c40
        return;
    }
    // 0x80e6c4a
    __stack_chk_fail();
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/util/error.c
// Address range: 0x80e6cd0 - 0x80e6d60
// Line range:    91 - 104
void elinks_error(char * fmt, ...) {
    int32_t v1 = __readgsdword(20); // 0x80e6cdb
    int32_t v2; // bp-4112, 0x80e6cd0
    __snprintf_chk((char *)&v2, 0x1000, 1, 0x1000, "ERROR at %s:%d: %s", (char *)errfile, errline, fmt);
    int32_t v3; // 0x80e6cd0
    er((int32_t)&v3, (int32_t)&g83, (char *)&g83, (char *)&g83);
    if (v1 == __readgsdword(20)) {
        // 0x80e6d50
        return;
    }
    // 0x80e6d5a
    __stack_chk_fail();
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/util/fastfind.c
// Address range: 0x80e6e80 - 0x80e6f5e
// Line range:    639 - 660
void fastfind_done(int32_t * index) {
    // 0x80e6e80
    if (assert_failed != 0) {
        // 0x80e6f48
        assert_failed = 0;
        return;
    }
    // 0x80e6e99
    assert_failed = index == NULL;
    if (index == NULL) {
        // 0x80e6f18
        errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/util/fastfind.c";
        errline = 643;
        elinks_internal("assertion index failed!");
        if (assert_failed != 0) {
            // 0x80e6f48
            assert_failed = 0;
            return;
        }
    }
    int32_t * v1 = (int32_t *)((int32_t)index + 12); // 0x80e6ea9
    int32_t v2 = *v1; // 0x80e6ea9
    if (v2 == 0) {
        // 0x80e6f0c
        return;
    }
    int32_t v3 = *(int32_t *)v2; // 0x80e6eb0
    if (v3 != 0) {
        // 0x80e6eb6
        mem_free((char *)v3);
    }
    int32_t * v4 = (int32_t *)(v2 + 32); // 0x80e6ebe
    int32_t v5 = *v4; // 0x80e6ebe
    int32_t * v6 = (int32_t *)(v2 + 4);
    int32_t v7 = *v6;
    int32_t v8 = v7; // 0x80e6ec5
    if (v5 != 0) {
        int32_t v9 = *(int32_t *)(v7 + 4 * v5); // 0x80e6ed0
        int32_t v10 = v5; // 0x80e6ed5
        int32_t v11 = v7; // 0x80e6ed5
        if (v9 != 0) {
            // 0x80e6ed7
            mem_free((char *)v9);
            v10 = *v4;
            v11 = *v6;
        }
        int32_t v12 = v11;
        int32_t v13 = v10 - 1; // 0x80e6ee5
        *v4 = v13;
        v8 = v12;
        while (v13 != 0) {
            // 0x80e6ed0
            v9 = *(int32_t *)(v12 + 4 * v13);
            v10 = v13;
            v11 = v12;
            if (v9 != 0) {
                // 0x80e6ed7
                mem_free((char *)v9);
                v10 = *v4;
                v11 = *v6;
            }
            // 0x80e6ee5
            v12 = v11;
            v13 = v10 - 1;
            *v4 = v13;
            v8 = v12;
        }
    }
    // 0x80e6ef1
    if (v8 != 0) {
        // 0x80e6ef5
        mem_free((char *)v8);
    }
    // 0x80e6efd
    mem_free((char *)v2);
    *v1 = 0;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/util/fastfind.c
// Address range: 0x80e6f60 - 0x80e729c
// Line range:    596 - 631
char * fastfind_search(int32_t * index, char * key, int32_t key_len) {
    // 0x80e6f60
    if (assert_failed != 0) {
        // 0x80e6fe0
        assert_failed = 0;
        // 0x80e6fec
        return NULL;
    }
    // 0x80e6f81
    assert_failed = index == NULL;
    if (index == NULL) {
        // 0x80e70e8
        errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/util/fastfind.c";
        errline = 602;
        elinks_internal("assertion index failed!");
        if (assert_failed != 0) {
            // 0x80e6fe0
            assert_failed = 0;
            // 0x80e6fec
            return NULL;
        }
    }
    int32_t v1 = *(int32_t *)((int32_t)index + 12); // 0x80e6f95
    assert_failed = v1 == 0;
    if (v1 == 0) {
        // 0x80e6fb0
        errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/util/fastfind.c";
        errline = 607;
        elinks_internal("assertion info != NULL failed: FastFind index %s not initialized", (char *)*index);
        if (assert_failed != 0) {
            // 0x80e6fe0
            assert_failed = 0;
            // 0x80e6fec
            return NULL;
        }
    }
    // 0x80e6fa8
    if (key == NULL || *(int32_t *)(v1 + 16) < key_len || *(int32_t *)(v1 + 12) > key_len) {
        // 0x80e6fec
        return NULL;
    }
    unsigned char v2 = *(char *)(v1 + 36); // 0x80e700a
    int32_t v3 = *(int32_t *)(v1 + 8); // 0x80e700e
    int32_t v4; // 0x80e6f60
    if (v2 % 2 != 0) {
        // 0x80e71cf
        if (key_len < 1) {
            // 0x80e6fec
            return NULL;
        }
        unsigned char v5 = *key; // 0x80e71d7
        if (v5 < 0) {
            // 0x80e6fec
            return NULL;
        }
        int32_t v6 = v1 + 40; // 0x80e71e6
        int32_t v7 = *(int32_t *)(4 * (int32_t)v5 + v6); // 0x80e71e6
        if (v7 < 0) {
            // 0x80e6fec
            return NULL;
        }
        int32_t v8 = 0; // 0x80e7241
        char v9 = *(char *)v3; // 0x80e7276
        char v10; // 0x80e6f60
        int32_t v11; // 0x80e6f60
        int32_t v12; // 0x80e7208
        if ((v9 & 2) == 0) {
            // 0x80e7208
            v12 = 4 * v7 + v3;
            v10 = *(char *)v12;
            v11 = v12;
        } else {
            // 0x80e727d
            v10 = v9;
            v11 = v3;
            if (v7 != (int32_t)(*(char *)(v3 + 3) / 2)) {
                // break -> 0x80e6fec
                break;
            }
        }
        int32_t v13 = v11;
        int32_t v14; // 0x80e7227
        if (v10 % 2 != 0) {
            // 0x80e7212
            v14 = *(int32_t *)v1 + (int32_t)(2 * *(int16_t *)v13 & 0x1ff8);
            v4 = v14;
            if (*(int32_t *)(v14 + 4) == key_len) {
                goto lab_0x80e71c8_3;
            }
        }
        uint32_t v15 = *(int32_t *)v13; // 0x80e722e
        while ((v15 & 0x1fff000) != 0) {
            // 0x80e723b
            v8++;
            if (v8 >= key_len) {
                // break -> 0x80e6fec
                break;
            }
            unsigned char v16 = *(char *)(v8 + (int32_t)key); // 0x80e725a
            if (v16 < 0) {
                // break -> 0x80e6fec
                break;
            }
            int32_t v17 = *(int32_t *)(4 * (int32_t)v16 + v6); // 0x80e726a
            if (v17 < 0) {
                // break -> 0x80e6fec
                break;
            }
            int32_t v18 = v17;
            int32_t v19 = *(int32_t *)(*(int32_t *)(v1 + 4) + (v15 / 1024 & 0x7ffc));
            v9 = *(char *)v19;
            if ((v9 & 2) == 0) {
                // 0x80e7208
                v12 = 4 * v18 + v19;
                v10 = *(char *)v12;
                v11 = v12;
            } else {
                // 0x80e727d
                v10 = v9;
                v11 = v19;
                if (v18 != (int32_t)(*(char *)(v19 + 3) / 2)) {
                    // break -> 0x80e6fec
                    break;
                }
            }
            // 0x80e720e
            v13 = v11;
            if (v10 % 2 != 0) {
                // 0x80e7212
                v14 = *(int32_t *)v1 + (int32_t)(2 * *(int16_t *)v13 & 0x1ff8);
                v4 = v14;
                if (*(int32_t *)(v14 + 4) == key_len) {
                    goto lab_0x80e71c8_3;
                }
            }
            // 0x80e722e
            v15 = *(int32_t *)v13;
        }
        // 0x80e6fec
        return NULL;
    }
    if ((v2 & 2) != 0) {
        // 0x80e7128
        if (key_len < 1) {
            // 0x80e6fec
            return NULL;
        }
        int32_t v20 = v3; // 0x80e7181
        int32_t v21 = 0; // 0x80e7173
        int32_t v22 = c_toupper((int32_t)*(char *)(v21 + (int32_t)key)); // 0x80e7193
        while (v22 <= 127) {
            int32_t v23 = *(int32_t *)(v1 + 40 + 4 * v22); // 0x80e71a1
            if (v23 < 0) {
                // break -> 0x80e6fec
                break;
            }
            int32_t v24 = v20;
            char v25 = *(char *)v24; // 0x80e71ad
            char v26; // 0x80e6f60
            int32_t v27; // 0x80e6f60
            if ((v25 & 2) == 0) {
                int32_t v28 = 4 * v23 + v24; // 0x80e7140
                v26 = *(char *)v28;
                v27 = v28;
            } else {
                // 0x80e71b4
                v26 = v25;
                v27 = v24;
                if (v23 != (int32_t)(*(char *)(v24 + 3) / 2)) {
                    // break -> 0x80e6fec
                    break;
                }
            }
            int32_t v29 = v27;
            if (v26 % 2 != 0) {
                int32_t v30 = *(int32_t *)v1 + (int32_t)(2 * *(int16_t *)v29 & 0x1ff8); // 0x80e715c
                v4 = v30;
                if (*(int32_t *)(v30 + 4) == key_len) {
                    goto lab_0x80e71c8_3;
                }
            }
            uint32_t v31 = *(int32_t *)v29; // 0x80e7163
            if ((v31 & 0x1fff000) == 0) {
                // break -> 0x80e6fec
                break;
            }
            // 0x80e7170
            v21++;
            v20 = *(int32_t *)(*(int32_t *)(v1 + 4) + (v31 / 1024 & 0x7ffc));
            if (v21 >= key_len) {
                // break -> 0x80e6fec
                break;
            }
            v22 = c_toupper((int32_t)*(char *)(v21 + (int32_t)key));
        }
        // 0x80e6fec
        return NULL;
    }
    // 0x80e7021
    if (key_len < 1) {
        // 0x80e6fec
        return NULL;
    }
    int32_t * v32 = *__ctype_toupper_loc(); // 0x80e7032
    int32_t v33 = 0; // 0x80e7040
    int32_t v34 = v3; // 0x80e7040
    unsigned char v35 = *(char *)(v33 + (int32_t)key); // 0x80e70a1
    int32_t v36 = *(int32_t *)(4 * (int32_t)v35 + (int32_t)v32); // 0x80e70a5
    char * result = NULL; // 0x80e70ab
    while (v36 <= 127) {
        int32_t v37 = *(int32_t *)(v1 + 40 + 4 * v36); // 0x80e70b4
        result = NULL;
        if (v37 < 0) {
            // break -> 0x80e6fec
            break;
        }
        int32_t v38 = v34;
        char v39 = *(char *)v38; // 0x80e70c0
        char v40; // 0x80e6f60
        int32_t v41; // 0x80e6f60
        if ((v39 & 2) == 0) {
            int32_t v42 = 4 * v37 + v38; // 0x80e7048
            v40 = *(char *)v42;
            v41 = v42;
        } else {
            // 0x80e70c7
            result = NULL;
            v40 = v39;
            v41 = v38;
            if (v37 != (int32_t)(*(char *)(v38 + 3) / 2)) {
                // break -> 0x80e6fec
                break;
            }
        }
        int32_t v43 = v41;
        if (v40 % 2 != 0) {
            int32_t v44 = *(int32_t *)v1 + (int32_t)(2 * *(int16_t *)v43 & 0x1ff8); // 0x80e7067
            v4 = v44;
            if (*(int32_t *)(v44 + 4) == key_len) {
                goto lab_0x80e71c8_3;
            }
        }
        uint32_t v45 = *(int32_t *)v43; // 0x80e7072
        result = NULL;
        if ((v45 & 0x1fff000) == 0) {
            // break -> 0x80e6fec
            break;
        }
        // 0x80e707f
        v33++;
        v34 = *(int32_t *)(*(int32_t *)(v1 + 4) + (v45 / 1024 & 0x7ffc));
        result = NULL;
        if (v33 >= key_len) {
            // break -> 0x80e6fec
            break;
        }
        v35 = *(char *)(v33 + (int32_t)key);
        v36 = *(int32_t *)(4 * (int32_t)v35 + (int32_t)v32);
        result = NULL;
    }
    // 0x80e6fec
    return result;
  lab_0x80e71c8_3:
    // 0x80e71c8
    result = (char *)*(int32_t *)v4;
    return result;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/util/hash.c
// Address range: 0x80e8980 - 0x80e89fa
// Line range:    137 - 144
void del_hash_item(int32_t * hash, int32_t * item) {
    // 0x80e8980
    if (assert_failed != 0) {
        // 0x80e89ea
        assert_failed = 0;
        return;
    }
    // 0x80e8993
    assert_failed = hash == NULL;
    if (hash == NULL) {
        // 0x80e89c0
        errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/util/hash.c";
        errline = 139;
        elinks_internal("assertion item failed!");
        if (assert_failed != 0) {
            // 0x80e89ea
            assert_failed = 0;
            return;
        }
    }
    int32_t * v1 = (int32_t *)((int32_t)hash + 4); // 0x80e89a5
    *(int32_t *)(*hash + 4) = *v1;
    *(int32_t *)*v1 = *hash;
    mem_free((char *)hash);
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/util/hash.c
// Address range: 0x80e8a00 - 0x80e8b49
// Line range:    63 - 74
void free_hash(int32_t ** hashp) {
    // 0x80e8a00
    if (assert_failed != 0) {
        // 0x80e8b37
        assert_failed = 0;
        return;
    }
    if (hashp == NULL) {
        goto lab_0x80e8b00;
    } else {
        // 0x80e8a22
        if (*hashp == NULL) {
            goto lab_0x80e8b00;
        } else {
            // 0x80e8a2f
            assert_failed = 0;
            goto lab_0x80e8a39;
        }
    }
  lab_0x80e8b00:
    // 0x80e8b00
    assert_failed = 1;
    errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/util/hash.c";
    errline = 67;
    elinks_internal("assertion hashp && *hashp failed!");
    if (assert_failed != 0) {
        // 0x80e8b37
        assert_failed = 0;
        return;
    }
    goto lab_0x80e8a39;
  lab_0x80e8a39:;
    int32_t * v1 = *hashp;
    int32_t v2 = (int32_t)v1;
    int32_t v3 = 0; // 0x80e8a00
    int32_t v4 = v2 + 8; // 0x80e8a00
    int32_t v5 = 8 * v3; // 0x80e8a63
    int32_t v6 = v2 + v5;
    int32_t v7 = *(int32_t *)(v6 + 8); // 0x80e8a63
    int32_t v8 = v4 + v5; // 0x80e8a6c
    int32_t v9 = v7; // 0x80e8a71
    int32_t v10; // 0x80e8a78
    if (v7 != v8) {
        v10 = *(int32_t *)v9;
        v9 = v10;
        while (v10 != v8) {
            // 0x80e8a78
            v10 = *(int32_t *)v9;
            v9 = v10;
        }
    }
    int32_t v11 = *(int32_t *)(v6 + 12); // 0x80e8a81
    int32_t v12 = v11; // 0x80e8a8a
    int32_t v13; // 0x80e8a90
    if (v11 != v8) {
        v13 = *(int32_t *)(v12 + 4);
        v12 = v13;
        while (v13 != v8) {
            // 0x80e8a90
            v13 = *(int32_t *)(v12 + 4);
            v12 = v13;
        }
    }
    int32_t v14 = v7; // 0x80e8a9e
    int32_t v15 = *v1; // 0x80e8a9e
    int32_t v16 = v2; // 0x80e8a9e
    int32_t v17 = v4; // 0x80e8a9e
    int32_t v18; // 0x80e8a00
    int32_t * v19; // 0x80e8a00
    int32_t * v20; // 0x80e8aa0
    int32_t * v21; // 0x80e8a00
    int32_t v22; // 0x80e8a00
    int32_t v23; // 0x80e8ac0
    if (v7 != v8) {
        v19 = (int32_t *)v14;
        v18 = *v19;
        v20 = (int32_t *)(v14 + 4);
        *(int32_t *)(v18 + 4) = *v20;
        *(int32_t *)*v20 = *v19;
        mem_free((char *)v14);
        v21 = *hashp;
        v22 = (int32_t)v21;
        v23 = v22 + 8;
        v14 = v18;
        while (v23 + v5 != v18) {
            // 0x80e8aa0
            v19 = (int32_t *)v14;
            v18 = *v19;
            v20 = (int32_t *)(v14 + 4);
            *(int32_t *)(v18 + 4) = *v20;
            *(int32_t *)*v20 = *v19;
            mem_free((char *)v14);
            v21 = *hashp;
            v22 = (int32_t)v21;
            v23 = v22 + 8;
            v14 = v18;
        }
        // 0x80e8aca
        v15 = *v21;
        v16 = v22;
        v17 = v23;
    }
    int32_t v24 = v16;
    int32_t v25 = v3 + 1; // 0x80e8ad8
    v3 = v25;
    int32_t v26 = v15; // 0x80e8ae1
    int32_t v27 = v24; // 0x80e8ae1
    v4 = v17;
    while (v25 >> v15 % 32 == 0) {
        // 0x80e8a60
        v5 = 8 * v3;
        v6 = v27 + v5;
        v7 = *(int32_t *)(v6 + 8);
        v8 = v4 + v5;
        v9 = v7;
        if (v7 != v8) {
            v10 = *(int32_t *)v9;
            v9 = v10;
            while (v10 != v8) {
                // 0x80e8a78
                v10 = *(int32_t *)v9;
                v9 = v10;
            }
        }
        // 0x80e8a7e
        v11 = *(int32_t *)(v6 + 12);
        v12 = v11;
        if (v11 != v8) {
            v13 = *(int32_t *)(v12 + 4);
            v12 = v13;
            while (v13 != v8) {
                // 0x80e8a90
                v13 = *(int32_t *)(v12 + 4);
                v12 = v13;
            }
        }
        // 0x80e8a97
        v14 = v7;
        v15 = v26;
        v16 = v27;
        v17 = v4;
        if (v7 != v8) {
            v19 = (int32_t *)v14;
            v18 = *v19;
            v20 = (int32_t *)(v14 + 4);
            *(int32_t *)(v18 + 4) = *v20;
            *(int32_t *)*v20 = *v19;
            mem_free((char *)v14);
            v21 = *hashp;
            v22 = (int32_t)v21;
            v23 = v22 + 8;
            v14 = v18;
            while (v23 + v5 != v18) {
                // 0x80e8aa0
                v19 = (int32_t *)v14;
                v18 = *v19;
                v20 = (int32_t *)(v14 + 4);
                *(int32_t *)(v18 + 4) = *v20;
                *(int32_t *)*v20 = *v19;
                mem_free((char *)v14);
                v21 = *hashp;
                v22 = (int32_t)v21;
                v23 = v22 + 8;
                v14 = v18;
            }
            // 0x80e8aca
            v15 = *v21;
            v16 = v22;
            v17 = v23;
        }
        // 0x80e8acf
        v24 = v16;
        v25 = v3 + 1;
        v3 = v25;
        v26 = v15;
        v27 = v24;
        v4 = v17;
    }
    // 0x80e8ae7
    mem_free((char *)v24);
    *(int32_t *)hashp = 0;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/util/hash.c
// Address range: 0x80e8b50 - 0x80e8bf3
// Line range:    106 - 115
int32_t * get_hash_item(int32_t * hash, char * key, int32_t keylen) {
    int32_t v1 = (int32_t)key;
    int32_t v2 = (int32_t)hash + 8 + 8 * ((-1 << *hash % 32 ^ 0x1fffffff) & v1);
    int32_t * v3 = (int32_t *)v2;
    int32_t v4 = *v3; // 0x80e8b84
    if (v4 == v2) {
        // 0x80e8bda
        return (int32_t *)0;
    }
    // 0x80e8b9d
    bool v5; // 0x80e8b50
    int32_t v6 = v5 ? -1 : 1;
    int32_t v7; // 0x80e8b50
    int32_t v8; // 0x80e8b50
    int32_t v9; // 0x80e8b50
    int32_t v10; // 0x80e8b50
    int32_t v11; // 0x80e8b50
    char v12; // 0x80e8bac
    int32_t * v13; // 0x80e8bb8
    int32_t * v14; // 0x80e8bba
    if (*(int32_t *)(v4 + 12) == keylen) {
        // 0x80e8ba2
        v8 = keylen;
        v9 = *(int32_t *)(v4 + 8);
        if (v8 == 0) {
            // 0x80e8bb0
            v7 = v4;
            return (int32_t *)v7;
        }
        v11 = v1;
        v12 = *(char *)v9;
        v8--;
        v10 = v11 + v6;
        v9 += v6;
        while (*(char *)v11 == v12) {
            if (v8 == 0) {
                // 0x80e8bb0
                v7 = v4;
                return (int32_t *)v7;
            }
            v11 = v10;
            v12 = *(char *)v9;
            v8--;
            v10 = v11 + v6;
            v9 += v6;
        }
    }
    int32_t v15 = *(int32_t *)v4; // 0x80e8be8
    v7 = 0;
    while (v15 != v2) {
        int32_t v16 = v15;
        if (*(int32_t *)(v16 + 12) == keylen) {
            // 0x80e8ba2
            v8 = keylen;
            v9 = *(int32_t *)(v16 + 8);
            if (v8 == 0) {
                // 0x80e8bb0
                v7 = v4;
                if (v16 == v4) {
                    return (int32_t *)v7;
                } else {
                    // 0x80e8bb8
                    v13 = (int32_t *)v16;
                    v14 = (int32_t *)(v16 + 4);
                    *(int32_t *)(*v13 + 4) = *v14;
                    *(int32_t *)*v14 = *v13;
                    *v13 = *v3;
                    *v14 = v2;
                    *v3 = v16;
                    *(int32_t *)(*v13 + 4) = v16;
                    v7 = v16;
                    return (int32_t *)v7;
                }
            }
            v11 = v1;
            v12 = *(char *)v9;
            v8--;
            v10 = v11 + v6;
            v9 += v6;
            while (*(char *)v11 == v12) {
                if (v8 == 0) {
                    // 0x80e8bb0
                    v7 = v4;
                    if (v16 == v4) {
                        return (int32_t *)v7;
                    } else {
                        // 0x80e8bb8
                        v13 = (int32_t *)v16;
                        v14 = (int32_t *)(v16 + 4);
                        *(int32_t *)(*v13 + 4) = *v14;
                        *(int32_t *)*v14 = *v13;
                        *v13 = *v3;
                        *v14 = v2;
                        *v3 = v16;
                        *(int32_t *)(*v13 + 4) = v16;
                        v7 = v16;
                        return (int32_t *)v7;
                    }
                }
                v11 = v10;
                v12 = *(char *)v9;
                v8--;
                v10 = v11 + v6;
                v9 += v6;
            }
        }
        // 0x80e8be8
        v15 = *(int32_t *)v16;
        v7 = 0;
    }
  lab_0x80e8bda:
    // 0x80e8bda
    return (int32_t *)v7;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/util/hash.c
// Address range: 0x80e8c00 - 0x80e8c7a
// Line range:    85 - 102
int32_t * add_hash_item(int32_t * hash, char * key, int32_t keylen, char * value) {
    char * v1 = mem_alloc(20); // 0x80e8c1c
    int32_t * result = NULL; // 0x80e8c25
    if (v1 != NULL) {
        int32_t v2 = (int32_t)v1; // 0x80e8c1c
        *(int32_t *)(v2 + 8) = (int32_t)key;
        uint32_t v3 = *hash % 32; // 0x80e8c46
        int32_t v4 = (int32_t)hash + 8 + 8 * ((v3 == 0 ? 0 : (1 << v3) + 0x1fffffff) & keylen); // 0x80e8c50
        *(int32_t *)(v2 + 12) = keylen;
        *(int32_t *)(v2 + 16) = (int32_t)value;
        int32_t * v5 = (int32_t *)v4; // 0x80e8c5d
        *(int32_t *)(v2 + 4) = v4;
        *(int32_t *)v1 = *v5;
        *v5 = v2;
        *(int32_t *)(*(int32_t *)v1 + 4) = v2;
        result = (int32_t *)v1;
    }
    // 0x80e8c6b
    return result;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/util/hash.c
// Address range: 0x80e8c80 - 0x80e8cf2
// Line range:    56 - 59
int32_t * init_hash8(void) {
    int32_t v1 = assert_failed; // 0x80e8c87
    assert_failed = 0;
    if (v1 != 0) {
        // 0x80e8cd6
        return NULL;
    }
    char * v2 = mem_alloc(2056); // 0x80e8ca1
    if (v2 == NULL) {
        // 0x80e8cd6
        return (int32_t *)v2;
    }
    int32_t v3 = (int32_t)v2; // 0x80e8ca1
    *(int32_t *)v2 = 8;
    *(int32_t *)(v3 + 4) = 0x80e8830;
    for (int32_t i = 0; i < 2041; i += 8) {
        int32_t v4 = i + v3;
        int32_t v5 = v4 + 8; // 0x80e8cc0
        *(int32_t *)(v4 + 12) = v5;
        *(int32_t *)v5 = v5;
    }
    // 0x80e8cd6
    return (int32_t *)v2;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/util/memory.c
// Address range: 0x80e9a00 - 0x80e9a4d
// Line range:    136 - 139
int32_t round_size(int32_t size) {
    int32_t v1 = page_size; // 0x80e9a11
    if (page_size == 0) {
        // 0x80e9a38
        v1 = sysconf(_SC_PAGESIZE);
        page_size = v1;
    }
    int32_t v2 = v1;
    int32_t v3 = v2; // 0x80e9a15
    if (v2 >= 0 != v2 != 0) {
        // 0x80e9a17
        page_size = 1;
        v3 = 1;
    }
    uint32_t v4 = v3;
    int32_t v5; // 0x80e9a00
    return ((uint32_t)v5 / v4 + 1) * v4;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/util/memory.c
// Address range: 0x80e9a50 - 0x80e9a9d
// Line range:    164 - 167
void mem_mmap_free(char * p, int32_t size) {
    // 0x80e9a50
    int32_t v1; // 0x80e9a50
    if (p != NULL) {
        // 0x80e9a61
        munmap((int32_t *)p, round_size(v1));
        return;
    }
    // 0x80e9a78
    errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/util/memory.c";
    errline = 167;
    elinks_internal((char *)v1);
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/util/memory.c
// Address range: 0x80e9aa0 - 0x80e9afc
// Line range:    151 - 161
char * mem_mmap_alloc(int32_t size) {
    // 0x80e9aa0
    if (size == 0) {
        // 0x80e9aad
        return NULL;
    }
    // 0x80e9ab8
    int32_t v1; // 0x80e9aa0
    int32_t * v2 = mmap64(NULL, round_size(v1), 3, 33, -1, 0); // 0x80e9af0
    if (v2 == (int32_t *)-1) {
        // 0x80e9aad
        return NULL;
    }
    // 0x80e9afa
    return (char *)v2;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/util/memory.c
// Address range: 0x80e9b00 - 0x80e9b9c
// Line range:    175 - 177
char * mem_mmap_realloc(char * p, int32_t old_size, int32_t new_size) {
    // 0x80e9b00
    int32_t v1; // 0x80e9b00
    if (p == NULL) {
        // 0x80e9b88
        return mem_mmap_alloc(v1);
    }
    int32_t v2 = round_size(v1); // 0x80e9b1e
    if (v2 == round_size(v2)) {
        // 0x80e9b66
        return (char *)(int32_t)p;
    }
    int32_t v3; // 0x80e9b00
    if (new_size == 0) {
        // 0x80e9b78
        mem_mmap_free(p, old_size);
        v3 = 0;
    } else {
        int32_t v4 = round_size((int32_t)&g83); // 0x80e9b38
        int32_t * v5 = mremap((int32_t *)p, round_size((int32_t)&g83), v4, 1); // 0x80e9b5b
        v3 = v5 != (int32_t *)-1 ? (int32_t)v5 : 0;
    }
    // 0x80e9b66
    return (char *)v3;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/util/memory.c
// Address range: 0x80e9ba0 - 0x80e9c33
// Line range:    30 - 52
int32_t patience(char * of) {
    int32_t v1 = alloc_try + 1; // 0x80e9bac
    alloc_try = v1;
    errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/util/memory.c";
    int32_t v2; // 0x80e9ba0
    if (v1 < 3) {
        // 0x80e9bf0
        errline = 34;
        elinks_error("Out of memory (%s returned NULL): retry #%d/%d, I still exercise my patience and retry tirelessly.", (char *)v2, v1, 3);
        sleep(3);
        return alloc_try;
    }
    // 0x80e9bba
    errline = 46;
    elinks_error("Out of memory (%s returned NULL) after %d tries, I give up and try to continue. Pray for me, please.", (char *)v2, v1);
    alloc_try = 0;
    return 0;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/util/memory.c
// Address range: 0x80e9c40 - 0x80e9c79
// Line range:    87 - 90
void mem_free(char * p) {
    // 0x80e9c40
    int32_t v1; // 0x80e9c40
    if (p != NULL) {
        // 0x80e9c4d
        free((int32_t *)v1);
        return;
    }
    // 0x80e9c58
    errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/util/memory.c";
    errline = 90;
    elinks_internal((char *)v1);
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/util/memory.c
// Address range: 0x80e9c80 - 0x80e9cd4
// Line range:    71 - 84
char * mem_calloc(int32_t count, int32_t eltsize) {
    if (count == 0 || eltsize == 0) {
        // 0x80e9cc8
        return NULL;
    }
    int32_t * mem = calloc(count, eltsize); // 0x80e9c9f
    while (mem == NULL) {
        // 0x80e9caa
        if (patience((char *)&g83) == 0) {
            // break -> 0x80e9cb8
            break;
        }
        mem = calloc(count, eltsize);
    }
    // 0x80e9cb8
    return (char *)mem;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/util/memory.c
// Address range: 0x80e9ce0 - 0x80e9d1d
// Line range:    55 - 68
char * mem_alloc(int32_t size) {
    // 0x80e9ce0
    if (size == 0) {
        // 0x80e9d14
        return NULL;
    }
    int32_t * mem = malloc(size); // 0x80e9cfb
    while (mem == NULL) {
        // 0x80e9d06
        if (patience((char *)&g83) == 0) {
            // break -> 0x80e9d14
            break;
        }
        mem = malloc(size);
    }
    // 0x80e9d14
    return (char *)mem;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/util/memory.c
// Address range: 0x80e9d20 - 0x80e9d7d
// Line range:    101 - 115
char * mem_realloc(char * p, int32_t size) {
    // 0x80e9d20
    if (p == NULL) {
        // 0x80e9d62
        int32_t v1; // 0x80e9d20
        return mem_alloc(v1);
    }
    if (size == 0) {
        // 0x80e9d71
        mem_free(p);
        // 0x80e9d58
        return NULL;
    }
    int32_t * mem = realloc((int32_t *)p, size); // 0x80e9d3f
    while (mem == NULL) {
        // 0x80e9d4a
        if (patience((char *)&g83) == 0) {
            // break -> 0x80e9d58
            break;
        }
        mem = realloc((int32_t *)p, size);
    }
    // 0x80e9d58
    return (char *)mem;
}

// Address range: 0x80eaaa0 - 0x80eab2c
int32_t init_string(int32_t * a1) {
    // 0x80eaaa0
    if (assert_failed != 0) {
        // 0x80eab11
        assert_failed = 0;
        // 0x80eab1d
        return 0;
    }
    // 0x80eaab4
    assert_failed = a1 == NULL;
    if (a1 == NULL) {
        // 0x80eaae8
        errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/util/string.c";
        errline = 307;
        elinks_internal("assertion string != NULL failed: [init_string]");
        if (assert_failed != 0) {
            // 0x80eab11
            assert_failed = 0;
            // 0x80eab1d
            return 0;
        }
    }
    int32_t result = (int32_t)a1;
    *(int32_t *)(result + 4) = 0;
    char * v1 = mem_alloc(256); // 0x80eaad2
    *a1 = (int32_t)v1;
    if (v1 == NULL) {
        // 0x80eab1d
        return 0;
    }
    // 0x80eaadd
    *v1 = 0;
    return result;
}

// Address range: 0x80eac10 - 0x80eac98
int32_t done_string(int32_t * a1) {
    int32_t result = assert_failed; // 0x80eac17
    if (result != 0) {
        // 0x80eac88
        assert_failed = 0;
        return result;
    }
    // 0x80eac23
    assert_failed = a1 == NULL;
    if (a1 == NULL) {
        // 0x80eac58
        errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/util/string.c";
        errline = 328;
        elinks_internal("assertion string != NULL failed: [done_string]");
        if (assert_failed != 0) {
            // 0x80eac88
            assert_failed = 0;
            return &g83;
        }
    }
    int32_t v1 = *a1; // 0x80eac33
    int32_t result2 = 0; // 0x80eac37
    if (v1 != 0) {
        // 0x80eac39
        mem_free((char *)v1);
        result2 = &g83;
    }
    // 0x80eac41
    *a1 = 0;
    *(int32_t *)((int32_t)a1 + 4) = 0;
    return result2;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/util/string.c
// Address range: 0x80ead80 - 0x80eae36
// Line range:    73 - 52
char * memacpy(char * src, int32_t len) {
    // 0x80ead80
    int32_t v1; // 0x80ead80
    int32_t v2; // 0x80ead80
    if (assert_failed != 0) {
        goto lab_0x80eae08;
    } else {
        // 0x80ead9f
        assert_failed = len < 0;
        if (len < 0) {
            // 0x80eadd8
            errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/util/string.c";
            errline = 77;
            elinks_internal("assertion len >= 0 failed: [memacpy]");
            if (assert_failed == 0) {
                // 0x80eadad
                v1 = len + 1;
                v2 = len;
                goto lab_0x80eadb0;
            } else {
                goto lab_0x80eae08;
            }
        } else {
            // 0x80eadad
            v1 = len + 1;
            v2 = len;
            goto lab_0x80eadb0;
        }
    }
  lab_0x80eae08:
    // 0x80eae08
    assert_failed = 0;
    v1 = 1;
    v2 = 0;
    goto lab_0x80eadb0;
  lab_0x80eadb0:;
    char * result = mem_alloc(v1); // 0x80eadb3
    if (result == NULL) {
        // 0x80eadc6
        return result;
    }
    // 0x80eadbe
    if (src != NULL && v2 != 0) {
        // 0x80eae24
        memcpy((int32_t *)result, (int32_t *)src, v2);
    }
    // 0x80eadc2
    *(char *)(v2 + (int32_t)result) = 0;
    // 0x80eadc6
    return result;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/util/string.c
// Address range: 0x80eae40 - 0x80eaec4
// Line range:    90 - 93
char * stracpy(char * src) {
    // 0x80eae40
    if (assert_failed != 0) {
        // 0x80eae53
        assert_failed = 0;
        return NULL;
    }
    // 0x80eae68
    assert_failed = src == NULL;
    int32_t len; // 0x80eae7b
    if (src != NULL) {
        // 0x80eae78
        len = strlen(src);
        return memacpy(src, len);
    }
    // 0x80eae98
    errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/util/string.c";
    errline = 92;
    elinks_internal("assertion src failed: [stracpy]");
    if (assert_failed == 0) {
        // 0x80eae78
        len = strlen(src);
        return memacpy(src, len);
    }
    // 0x80eae53
    assert_failed = 0;
    return NULL;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/util/string.c
// Address range: 0x80eb040 - 0x80eb0a2
// Line range:    262 - 274
int32_t c_strncasecmp(char * s1, char * s2, int32_t n) {
    if (n == 0) {
        // 0x80eb098
        return 0;
    }
    int32_t v1 = 0; // 0x80eb05e
    int32_t v2 = c_tolower((int32_t)*(char *)(v1 + (int32_t)s1)); // 0x80eb06d
    unsigned char v3 = *(char *)(v1 + (int32_t)s2); // 0x80eb077
    unsigned char v4 = (char)v2;
    unsigned char v5 = (char)c_tolower((int32_t)v3);
    while (v4 == v5) {
        if (v4 == 0) {
            // 0x80eb098
            return 0;
        }
        // 0x80eb05e
        v1++;
        if (v1 == n) {
            // 0x80eb098
            return 0;
        }
        v2 = c_tolower((int32_t)*(char *)(v1 + (int32_t)s1));
        v3 = *(char *)(v1 + (int32_t)s2);
        v4 = (char)v2;
        v5 = (char)c_tolower((int32_t)v3);
    }
    // 0x80eb089
    return v4 < v5 ? -1 : 1;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/util/string.c
// Address range: 0x80eb0b0 - 0x80eb122
// Line range:    277 - 286
char * c_strcasestr(char * haystack, char * needle) {
    uint32_t len = strlen(haystack); // 0x80eb0c5
    uint32_t len2 = strlen(needle); // 0x80eb0d2
    if (len < len2) {
        // 0x80eb0df
        return (char *)0;
    }
    int32_t v1 = len + 1 - len2; // 0x80eb0f3
    if (v1 == 0) {
        // 0x80eb0df
        return (char *)0;
    }
    int32_t v2 = (int32_t)haystack;
    int32_t v3 = v1; // 0x80eb118
    if (c_strncasecmp(haystack, needle, len2) == 0) {
        // 0x80eb0df
        return (char *)v2;
    }
    int32_t v4 = v2; // 0x80eb118
    v3--;
    int32_t v5 = 0; // 0x80eb11d
    while (v3 != 0) {
        // 0x80eb100
        v4++;
        int32_t v6 = c_strncasecmp((char *)v4, needle, len2); // 0x80eb111
        v5 = v4;
        if (v6 == 0) {
            // break -> 0x80eb0df
            break;
        }
        v3--;
        v5 = 0;
    }
    // 0x80eb0df
    return (char *)v5;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/util/string.c
// Address range: 0x80eb130 - 0x80eb18a
// Line range:    249 - 260
int32_t c_strcasecmp(char * s1, char * s2) {
    int32_t v1 = 0; // 0x80eb13e
    int32_t v2 = c_tolower((int32_t)*(char *)(v1 + (int32_t)s1)); // 0x80eb153
    unsigned char v3 = *(char *)(v1 + (int32_t)s2); // 0x80eb15a
    unsigned char v4 = (char)v2;
    unsigned char v5 = (char)c_tolower((int32_t)v3);
    while (v4 == v5) {
        // 0x80eb140
        v1++;
        if (v4 == 0) {
            // 0x80eb180
            return 0;
        }
        v2 = c_tolower((int32_t)*(char *)(v1 + (int32_t)s1));
        v3 = *(char *)(v1 + (int32_t)s2);
        v4 = (char)v2;
        v5 = (char)c_tolower((int32_t)v3);
    }
    // 0x80eb16c
    return v4 < v5 ? -1 : 1;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/util/string.c
// Address range: 0x80eb350 - 0x80eb3f4
// Line range:    186 - 188
char * safe_strncpy(char * dst, char * src, int32_t dst_size) {
    // 0x80eb350
    if (assert_failed != 0) {
        // 0x80eb372
        assert_failed = 0;
        // 0x80eb380
        return NULL;
    }
    if (dst == NULL || src == NULL || dst_size == 0) {
        // 0x80eb394
        assert_failed = 1;
        errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/util/string.c";
        errline = 188;
        elinks_internal("assertion dst && src && dst_size > 0 failed: [safe_strncpy]");
        if (assert_failed != 0) {
            // 0x80eb372
            assert_failed = 0;
            // 0x80eb380
            return NULL;
        }
    } else {
        // 0x80eb3e8
        assert_failed = 0;
    }
    // 0x80eb3c8
    strncpy(dst, src, dst_size);
    *(char *)((int32_t)dst - 1 + dst_size) = 0;
    // 0x80eb380
    return dst;
}

// Address range: 0x80eb4d0 - 0x80eb542
int32_t T_146(void) {
    // 0x80eb4d0
    int32_t v1; // 0x80eb4d0
    uint32_t v2 = v1 + 255 & -256; // 0x80eb4e8
    uint32_t v3 = v1 + 255 & -256; // 0x80eb4ee
    int32_t set_mem; // 0x80eb4d0
    if (v2 <= v3) {
        // 0x80eb4ff
        return set_mem;
    }
    char * v4 = mem_realloc((char *)v1, v2); // 0x80eb519
    set_mem = 0;
    if (v4 != NULL) {
        int32_t v5 = (int32_t)v4; // 0x80eb519
        *(int32_t *)v1 = v5;
        set_mem = (int32_t)memset((int32_t *)(v3 + v5), 0, v2 - v3);
    }
    // 0x80eb4ff
    return set_mem;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/util/string.c
// Address range: 0x80eb550 - 0x80eb660
// Line range:    496 - 523
int32_t * add_format_to_string(int32_t * string, char * format, ...) {
    // 0x80eb550
    if (assert_failed != 0) {
        // 0x80eb5ea
        assert_failed = 0;
        // 0x80eb5f6
        return NULL;
    }
    bool v1 = string == NULL | format == NULL;
    assert_failed = v1;
    if (v1) {
        // 0x80eb5c0
        errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/util/string.c";
        errline = 502;
        elinks_internal("assertion string && format failed: [add_format_to_string]");
        if (assert_failed != 0) {
            // 0x80eb5ea
            assert_failed = 0;
            // 0x80eb5f6
            return NULL;
        }
    }
    // 0x80eb586
    int32_t v2; // bp+12, 0x80eb550
    int32_t v3 = &v2; // 0x80eb589
    int32_t v4 = __vsnprintf_chk(NULL, 0, 1, -1, format, v3); // 0x80eb5b0
    if (v4 >= 0 != v4 != 0) {
        // 0x80eb5f6
        return NULL;
    }
    int32_t * v5 = (int32_t *)((int32_t)string + 4); // 0x80eb608
    int32_t * result = NULL; // 0x80eb61e
    if (T_146() != 0) {
        int32_t v6 = *v5 + v4; // 0x80eb60b
        __vsnprintf_chk((char *)(*v5 + *string), v4 + 1, 1, -1, format, v3);
        *v5 = v6;
        *(char *)(*string + v6) = 0;
        result = string;
    }
    // 0x80eb5f6
    return result;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/util/string.c
// Address range: 0x80eba30 - 0x80ebbf3
// Line range:    433 - 439
int32_t * string_concat(int32_t * string, ...) {
    // 0x80eba30
    if (assert_failed != 0) {
        // 0x80eba43
        assert_failed = 0;
        // 0x80eba58
        return NULL;
    }
    int32_t v1 = string == NULL; // 0x80eba6d
    assert_failed = v1;
    int32_t v2; // 0x80eba30
    int32_t v3; // 0x80eba30
    if (string == NULL) {
        // 0x80ebbc0
        errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/util/string.c";
        errline = 438;
        elinks_internal("assertion string != NULL failed: [string_concat]");
        if (assert_failed != 0) {
            // 0x80eba43
            assert_failed = 0;
            // 0x80eba58
            return NULL;
        }
        // 0x80ebbc0
        v2 = v3;
    }
    // 0x80eba81
    if (v2 == 0) {
        // 0x80eba58
        return string;
    }
    int32_t * v4 = (int32_t *)((int32_t)string + 4);
    int32_t v5 = v2; // 0x80eba88
    int32_t v6 = &v3; // 0x80eba8e
    int32_t v7; // 0x80eba30
    char * str; // 0x80eba91
    while (true) {
      lab_0x80eba8e:
        // 0x80eba8e
        v7 = v5;
        str = (char *)v7;
        if (*str == 0) {
            goto lab_0x80eba88;
        } else {
            // 0x80eba96
            if (assert_failed == 0) {
                // 0x80ebab0
                assert_failed = v1;
                if (string == NULL) {
                    // 0x80ebb88
                    errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/util/string.c";
                    errline = 347;
                    elinks_internal("assertion string && source failed: [add_to_string]");
                    if (assert_failed == 0) {
                        goto lab_0x80ebabe;
                    } else {
                        // 0x80ebaa0
                        assert_failed = 0;
                        goto lab_0x80eba88;
                    }
                } else {
                    goto lab_0x80ebabe;
                }
            } else {
                // 0x80ebaa0
                assert_failed = 0;
                goto lab_0x80eba88;
            }
        }
    }
    // 0x80eba58
    return string;
  lab_0x80eba88:
    // 0x80eba88
    v6 += 4;
    v5 = *(int32_t *)v6;
    if (v5 == 0) {
        return string;
    }
    goto lab_0x80eba8e;
  lab_0x80ebabe:;
    // 0x80ebabe
    int32_t len; // 0x80ebac6
    if (*str == 0) {
        goto lab_0x80eba88;
    } else {
        // 0x80ebac3
        len = strlen(str);
        if (string == NULL || len < 0) {
            // 0x80ebb40
            assert_failed = 1;
            errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
            errline = 255;
            elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
            if (assert_failed != 0) {
                // 0x80ebaa0
                assert_failed = 0;
                goto lab_0x80eba88;
            } else {
                if (len == 0) {
                    goto lab_0x80eba88;
                } else {
                    goto lab_0x80ebaea;
                }
            }
        } else {
            // 0x80ebad9
            assert_failed = 0;
            if (len == 0) {
                goto lab_0x80eba88;
            } else {
                goto lab_0x80ebaea;
            }
        }
    }
  lab_0x80ebaea:
    // 0x80ebaea
    if (T_146() != 0) {
        int32_t v8 = *v4 + len; // 0x80ebaf3
        memcpy(&((struct _IO_FILE *)(*v4 + *string))->e0, (int32_t *)v7, len);
        *(char *)(*string + v8) = 0;
        *v4 = v8;
    }
    goto lab_0x80eba88;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/util/string.c
// Address range: 0x80ebd00 - 0x80ebe13
// Line range:    455 - 468
int32_t * add_char_to_string(int32_t * string, char character) {
    // 0x80ebd00
    if (assert_failed != 0) {
        // 0x80ebdb1
        assert_failed = 0;
        // 0x80ebdbd
        return NULL;
    }
    bool v1 = string == NULL | character == 0;
    assert_failed = v1;
    if (v1) {
        // 0x80ebd80
        errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/util/string.c";
        errline = 457;
        elinks_internal("assertion string && character failed: [add_char_to_string]");
        if (assert_failed != 0) {
            // 0x80ebdb1
            assert_failed = 0;
            // 0x80ebdbd
            return NULL;
        }
    }
    int32_t * v2 = (int32_t *)((int32_t)string + 4); // 0x80ebd3c
    int32_t v3 = *v2; // 0x80ebd3c
    uint32_t v4 = v3 + 257 & -256; // 0x80ebd4b
    uint32_t v5 = v3 + 255 & -256; // 0x80ebd51
    if (v4 > v5) {
        char * v6 = mem_realloc((char *)*string, v4); // 0x80ebddc
        if (v6 == NULL) {
            // 0x80ebdbd
            return NULL;
        }
        int32_t v7 = (int32_t)v6; // 0x80ebddc
        *string = v7;
        memset((int32_t *)(v5 + v7), 0, v4 - v5);
    }
    int32_t v8 = *string; // 0x80ebd5b
    int32_t * result = NULL; // 0x80ebd5f
    if (v8 != 0) {
        int32_t v9 = *v2; // 0x80ebd65
        *(char *)(v9 + v8) = character;
        int32_t v10 = v9 + 1; // 0x80ebd6b
        *v2 = v10;
        *(char *)(*string + v10) = 0;
        result = string;
    }
    // 0x80ebdbd
    return result;
}

// Address range: 0x80ebe20 - 0x80ebf75
int32_t add_to_string(int32_t * a1, int32_t a2) {
    // 0x80ebe20
    if (assert_failed != 0) {
        // 0x80ebe3f
        assert_failed = 0;
        // 0x80ebe50
        return 0;
    }
    int32_t result = (int32_t)a1;
    bool v1 = a1 == NULL | a2 == 0;
    assert_failed = v1;
    char * str; // 0x80ebe20
    if (v1) {
        // 0x80ebf30
        errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/util/string.c";
        errline = 347;
        elinks_internal("assertion string && source failed: [add_to_string]");
        if (assert_failed != 0) {
            // 0x80ebe3f
            assert_failed = 0;
            // 0x80ebe50
            return 0;
        }
        char * v2 = (char *)a2;
        str = v2;
        if (*v2 == 0) {
            // 0x80ebe50
            return result;
        }
    } else {
        char * v3 = (char *)a2;
        str = v3;
        if (*v3 == 0) {
            // 0x80ebe50
            return result;
        }
    }
    int32_t len = strlen(str); // 0x80ebe84
    if (a1 == NULL || len < 0) {
        // 0x80ebe93
        assert_failed = 1;
        errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
        errline = 255;
        elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
        if (assert_failed != 0) {
            // 0x80ebe3f
            assert_failed = 0;
            // 0x80ebe50
            return 0;
        }
    } else {
        // 0x80ebf20
        assert_failed = 0;
    }
    // 0x80ebeca
    if (len == 0) {
        // 0x80ebe50
        return result;
    }
    int32_t * v4 = (int32_t *)(result + 4); // 0x80ebece
    if (T_146() != 0) {
        int32_t v5 = *v4 + len; // 0x80ebed1
        memcpy(&((struct _IO_FILE *)(*v4 + *a1))->e0, (int32_t *)a2, len);
        *(char *)(*a1 + v5) = 0;
        *v4 = v5;
    }
    // 0x80ebe50
    return 0;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/util/time.c
// Address range: 0x80ec290 - 0x80ec2e8
// Line range:    54 - 76
int32_t * timeval_sub_interval(int32_t * t, int32_t * interval) {
    int32_t v1 = (int32_t)t;
    int32_t v2 = *t; // 0x80ec29a
    int32_t v3 = *interval; // 0x80ec29c
    int32_t v4 = v2 - v3; // 0x80ec29c
    *t = v4;
    if (v4 < 0) {
        // 0x80ec2d8
        *t = 0;
        *(int32_t *)(v1 + 4) = 0;
        return t;
    }
    int32_t * v5 = (int32_t *)(v1 + 4);
    int32_t v6 = *v5; // 0x80ec2a4
    int32_t v7 = *(int32_t *)((int32_t)interval + 4); // 0x80ec2a7
    int32_t v8 = v6 - v7; // 0x80ec2a7
    *v5 = v8;
    if (v8 >= 0) {
        // 0x80ec2ce
        return t;
    }
    int32_t v9 = v6 + 0xf4240;
    int32_t v10 = v9 - v7;
    uint32_t v11 = ((v10 > 0 ? v9 : v7) + -1 - v6) / 0xf4240;
    int32_t v12 = v2 + -1 - v3 - v11;
    *v5 = v10 + 0xf4240 * v11;
    *t = v12;
    if (v12 >= 0) {
        // 0x80ec2ce
        return t;
    }
    // 0x80ec2d8
    *t = 0;
    *v5 = 0;
    return t;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/util/time.c
// Address range: 0x80ec2f0 - 0x80ec323
// Line range:    80 - 91
int32_t * timeval_sub(int32_t * res, int32_t * older, int32_t * newer) {
    int32_t v1 = *newer; // 0x80ec2fd
    int32_t v2 = *older; // 0x80ec2ff
    *res = v1 - v2;
    int32_t v3 = *(int32_t *)((int32_t)newer + 4); // 0x80ec303
    int32_t v4 = *(int32_t *)((int32_t)older + 4); // 0x80ec306
    int32_t v5 = v3 - v4; // 0x80ec306
    int32_t * v6 = (int32_t *)((int32_t)res + 4); // 0x80ec30b
    *v6 = v5;
    if (v5 < 0) {
        int32_t v7 = v3 + 0xf4240;
        int32_t v8 = v7 - v4;
        uint32_t v9 = ((v8 > 0 ? v7 : v4) + -1 - v3) / 0xf4240;
        *v6 = v8 + 0xf4240 * v9;
        *res = v1 + -1 - v2 - v9;
    }
    // 0x80ec320
    return res;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/util/time.c
// Address range: 0x80ec380 - 0x80ec3b8
// Line range:    110 - 121
int32_t * timeval_add_interval(int32_t * t, int32_t * interval) {
    // 0x80ec380
    *t = *t + *interval;
    int32_t * v1 = (int32_t *)((int32_t)t + 4); // 0x80ec38d
    uint32_t v2 = *(int32_t *)((int32_t)interval + 4) + *v1;
    *v1 = v2;
    if (v2 >= 0xf4240) {
        uint32_t v3 = v2 - 0xf4240;
        uint32_t v4 = v3 / 0xf4240;
        *v1 = -0xf4240 * v4 + v3;
        *t = v4 + 1 + *t;
    }
    // 0x80ec3b6
    return t;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/util/time.c
// Address range: 0x80ec400 - 0x80ec435
// Line range:    135 - 143
int32_t * timeval_from_milliseconds(int32_t * t, int32_t milliseconds) {
    int32_t v1 = milliseconds / 1000; // 0x80ec41b
    *t = v1;
    *(int32_t *)((int32_t)t + 4) = 1000 * (-1000 * v1 + milliseconds);
    return t;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/util/time.c
// Address range: 0x80ec440 - 0x80ec454
// Line range:    149 - 155
int32_t * timeval_from_seconds(int32_t * t, int32_t seconds) {
    // 0x80ec440
    *(int32_t *)((int32_t)t + 4) = 0;
    *t = seconds;
    return t;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/util/time.c
// Address range: 0x80ec490 - 0x80ec4bc
// Line range:    210 - 213
int32_t timeval_is_positive(int32_t * t) {
    uint32_t v1 = *t; // 0x80ec49b
    if (v1 >= 1) {
        // 0x80ec4a0
        return 1;
    }
    // 0x80ec4a8
    if (v1 != 0) {
        // 0x80ec4a0
        return 0;
    }
    int32_t v2 = *(int32_t *)((int32_t)t + 4); // 0x80ec4ac
    return v2 >= 0 == (v2 != 0);
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/util/time.c
// Address range: 0x80ec4c0 - 0x80ec4f2
// Line range:    218 - 220
void timeval_limit_to_zero_or_one(int32_t * t) {
    // 0x80ec4c0
    if (*t < 0) {
        // 0x80ec4e8
        *t = 0;
    }
    int32_t * v1 = (int32_t *)((int32_t)t + 4); // 0x80ec4cc
    if (*v1 >= 0) {
        // 0x80ec4d3
        return;
    }
    // 0x80ec4d8
    *v1 = 0;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/util/time.c
// Address range: 0x80ec500 - 0x80ec532
// Line range:    234 - 237
int32_t timeval_cmp(int32_t * t1, int32_t * t2) {
    uint32_t v1 = *t2; // 0x80ec50f
    uint32_t v2 = *t1; // 0x80ec511
    if (v2 > v1) {
        // 0x80ec515
        return 1;
    }
    int32_t result = -1; // 0x80ec518
    if (v2 >= v1) {
        int32_t v3 = *(int32_t *)((int32_t)t2 + 4); // 0x80ec51d
        result = *(int32_t *)((int32_t)t1 + 4) - v3;
    }
    // 0x80ec515
    return result;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/util/time.c
// Address range: 0x80ec540 - 0x80ec5d6
// Line range:    244 - 254
int32_t timeval_div_off_t(int64_t n, int32_t * t) {
    // 0x80ec540
    int32_t v1; // 0x80ec540
    int32_t v2 = *(int32_t *)(v1 + 4) / 1000; // 0x80ec56a
    uint64_t v3 = 1000 * (int64_t)*(int32_t *)v1; // 0x80ec583
    uint32_t v4 = v2 + (int32_t)v3; // 0x80ec585
    int32_t v5 = (v2 >> 31) + (int32_t)(v3 / 0x100000000) + (int32_t)(v4 < v2); // 0x80ec588
    int32_t result = 0x7fffffff; // 0x80ec591
    if ((v5 || v4) != 0) {
        uint64_t v6 = 1000 * (n & 0xffffffff); // 0x80ec595
        result = __divdi3((int32_t)v6, 1000 * (int32_t)t + (int32_t)(v6 / 0x100000000), v4, v5);
    }
    // 0x80ec5c7
    return result;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/util/time.c
// Address range: 0x80ec5e0 - 0x80ec688
// Line range:    179 - 183
int32_t mult_ms(int32_t a, uint32_t lb) {
    // 0x80ec5e0
    if (assert_failed != 0) {
        // 0x80ec648
        assert_failed = 0;
        return 0x20c49b;
    }
    if (a >= 0 && lb >= 0) {
        if (0x7fffffff / lb > a) {
            // 0x80ec67c
            assert_failed = 0;
            // 0x80ec633
            return lb * a;
        }
    }
    // 0x80ec5ff
    assert_failed = 1;
    errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/util/time.c";
    errline = 183;
    elinks_internal("assertion la >= 0 && lb >= 0 && la < LONG_MAX / lb failed!");
    if (assert_failed == 0) {
        // 0x80ec633
        return lb * a;
    }
    // 0x80ec648
    assert_failed = 0;
    return 0x20c49b;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/util/time.c
// Address range: 0x80ec810 - 0x80ec840
// Line range:    26 - 48
int32_t * timeval_now(int32_t * t) {
    // 0x80ec810
    int32_t tp; // bp-20, 0x80ec810
    gettimeofday((struct timeval *)&tp, NULL);
    *t = tp;
    return t;
}

// From module:   /home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c
// Address range: 0x80fcfe0 - 0x80fd112
// Line range:    1248 - 1256
int32_t * current_frame(int32_t * ses) {
    // 0x80fcfe0
    if (assert_failed != 0) {
        // 0x80fd0c0
        assert_failed = 0;
        // 0x80fd0cc
        return (int32_t *)0;
    }
    int32_t v1 = (int32_t)ses;
    assert_failed = ses == NULL;
    int32_t v2; // 0x80fcfe0
    if (ses == NULL) {
        // 0x80fd0d8
        errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
        errline = 1253;
        elinks_internal("assertion ses failed!");
        if (assert_failed != 0) {
            // 0x80fd0c0
            assert_failed = 0;
            // 0x80fd0cc
            return (int32_t *)0;
        }
        int32_t v3 = *(int32_t *)(v1 + 20); // 0x80fd102
        v2 = v3;
        if (v3 == 0) {
            // 0x80fd0cc
            return (int32_t *)0;
        }
    } else {
        int32_t v4 = *(int32_t *)(v1 + 20); // 0x80fd00d
        v2 = v4;
        if (v4 == 0) {
            // 0x80fd0cc
            return (int32_t *)0;
        }
    }
    int32_t v5 = v1 + 96; // 0x80fd019
    int32_t v6 = *(int32_t *)v5; // 0x80fd022
    if (v6 == v5) {
      lab_0x80fd058_2:;
        int32_t v7 = *(int32_t *)(v1 + 92); // 0x80fd058
        int32_t * v8; // 0x80fcfe0
        if (v7 == 0) {
            goto lab_0x80fd085;
        } else {
            int32_t * v9 = (int32_t *)(v7 + 20);
            if (*v9 == 0) {
                goto lab_0x80fd085;
            } else {
                // 0x80fd066
                assert_failed = 0;
                v8 = v9;
                goto lab_0x80fd070;
            }
        }
      lab_0x80fd085:
        // 0x80fd085
        assert_failed = 1;
        errfile = (int32_t)"/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
        errline = 1268;
        elinks_internal("assertion doc_view && doc_view->document failed!");
        if (assert_failed != 0) {
            // 0x80fd0c0
            assert_failed = 0;
            // 0x80fd0cc
            return (int32_t *)0;
        }
        // 0x80fd085
        v8 = (int32_t *)(v7 + 20);
        goto lab_0x80fd070;
      lab_0x80fd070:;
        int32_t v10 = *v8; // 0x80fd070
        if (v10 == 0 || *(int32_t *)(v10 + 200) == 0) {
            // 0x80fd0cc
            return (int32_t *)v7;
        }
        // 0x80fd0cc
        return (int32_t *)0;
    }
    int32_t v11 = *(int32_t *)(v2 + 96); // 0x80fd014
    int32_t v12 = v11 == -1 ? 0 : v11; // 0x80fcfe0
    int32_t v13 = v6;
    int32_t v14 = *(int32_t *)(v13 + 20); // 0x80fd040
    int32_t v15; // 0x80fd03a
    while (v14 != 0) {
        // 0x80fd030
        if (*(int32_t *)(v14 + 200) == 0) {
            // break -> 0x80fd047
            break;
        }
        // 0x80fd03a
        v15 = *(int32_t *)v13;
        if (v5 == v15) {
            goto lab_0x80fd058_2;
        }
        v13 = v15;
        v14 = *(int32_t *)(v13 + 20);
    }
    // 0x80fd047
    while (v12 != 0) {
        int32_t v16 = *(int32_t *)v13; // 0x80fd04f
        v12--;
        if (v5 == v16) {
            goto lab_0x80fd058_2;
        }
        v13 = v16;
        v14 = *(int32_t *)(v13 + 20);
        while (v14 != 0) {
            // 0x80fd030
            if (*(int32_t *)(v14 + 200) == 0) {
                // break -> 0x80fd047
                break;
            }
            // 0x80fd03a
            v15 = *(int32_t *)v13;
            if (v5 == v15) {
                goto lab_0x80fd058_2;
            }
            v13 = v15;
            v14 = *(int32_t *)(v13 + 20);
        }
    }
    // 0x80fd0cc
    return (int32_t *)v13;
}

// Address range: 0x8100800 - 0x8100972
int32_t __divdi3(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1; // 0x8100800
    int32_t v2; // 0x8100800
    int32_t v3; // 0x8100800
    int32_t v4; // 0x8100800
    int32_t v5; // 0x8100800
    int32_t v6; // 0x8100800
    int32_t v7; // 0x8100800
    int32_t v8; // 0x8100800
    if (a2 < 0) {
        int32_t v9 = -a1; // 0x81008cb
        int32_t v10 = -(((int32_t)(a1 != 0) + a2)); // 0x81008d0
        v6 = a3;
        v5 = a4;
        v7 = -1;
        v1 = v10;
        v3 = v9;
        v8 = 0;
        v2 = v10;
        v4 = v9;
        if (a4 >= 0) {
            goto lab_0x8100834;
        } else {
            goto lab_0x81008e1;
        }
    } else {
        // 0x8100829
        v6 = a3;
        v5 = a4;
        v7 = 0;
        v1 = a2;
        v3 = a1;
        v8 = -1;
        v2 = a2;
        v4 = a1;
        if (a4 < 0) {
            goto lab_0x81008e1;
        } else {
            goto lab_0x8100834;
        }
    }
  lab_0x8100834:;
    uint32_t v11 = v3;
    uint32_t v12 = v1;
    uint32_t v13 = v6;
    int32_t v14; // 0x8100800
    int32_t v15; // 0x8100800
    if (v5 == 0) {
        if (v13 > v12) {
            // 0x8100847
            v14 = (0x100000000 * (int64_t)v12 | (int64_t)v11) / (int64_t)v13;
        } else {
            uint32_t v16 = v13 != 0 ? v13 : (int32_t)(v13 == 1);
            v14 = (0x100000000 * (int64_t)(v12 % v16) | (int64_t)v11) / (int64_t)v16;
        }
        // 0x8100860
        v15 = v14;
        return v7 == 0 ? v15 : -v15;
    }
    // 0x8100858
    if (v5 > v12) {
        // 0x8100860
        v15 = 0;
        return v7 == 0 ? v15 : -v15;
    }
    uint32_t v17 = llvm_ctlz_i32(v5, true); // 0x81008a8
    if (v17 == 0) {
        // 0x81008b3
        v14 = v5 < v12 | v13 <= v11;
        // 0x8100860
        v15 = v14;
        return v7 == 0 ? v15 : -v15;
    }
    uint32_t v18 = -v17 % 32; // 0x810090d
    uint64_t v19 = 0x100000000 * (int64_t)(v12 >> v18) | (int64_t)(v11 >> v18 | v12 << v17); // 0x8100937
    uint64_t v20 = (int64_t)(v13 >> v18 | v5 << v17); // 0x8100937
    uint64_t v21 = v19 / v20; // 0x8100937
    int32_t v22 = v21; // 0x8100937
    uint32_t v23 = (int32_t)(v19 % v20); // 0x8100937
    uint64_t v24 = (v21 & 0xffffffff) * (int64_t)(v13 << v17); // 0x810093e
    uint32_t v25 = (int32_t)(v24 / 0x100000000); // 0x810093e
    if (v23 < v25 || v11 << v17 < (int32_t)v24 == v23 == v25) {
        // 0x8100860
        v15 = v22 - 1;
        return v7 == 0 ? v15 : -v15;
    }
    // 0x8100860
    v15 = v22;
    return v7 == 0 ? v15 : -v15;
  lab_0x81008e1:
    // 0x81008e1
    v6 = -a3;
    v5 = -(((int32_t)(a3 != 0) + a4));
    v7 = v8;
    v1 = v2;
    v3 = v4;
    goto lab_0x8100834;
}

// Address range: 0x8100b50 - 0x8100c78
int32_t __udivdi3(uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4) {
    if (a4 == 0) {
        if (a3 > a2) {
            // 0x8100bd0
            return (uint64_t)(0x100000000 * (int64_t)a2 | (int64_t)a1) / (uint64_t)(int64_t)a3;
        }
        uint32_t v1 = a3 != 0 ? a3 : (int32_t)(bool)(a3 == 1);
        return (0x100000000 * (int64_t)(a2 % v1) | (int64_t)a1) / (int64_t)v1;
    }
    // 0x8100ba0
    if (a4 > a2) {
        // 0x8100bc4
        return 0;
    }
    uint32_t v2 = llvm_ctlz_i32(a4, true); // 0x8100ba4
    if (v2 == 0) {
        // 0x8100bc4
        return a3 <= a1 | a4 < a2;
    }
    uint32_t v3 = -v2 % 32; // 0x8100bfd
    uint64_t v4 = 0x100000000 * (int64_t)(a2 >> v3) | (int64_t)(a1 >> v3 | a2 << v2); // 0x8100c27
    uint64_t v5 = (int64_t)(a3 >> v3 | a4 << v2); // 0x8100c27
    uint64_t v6 = v4 / v5; // 0x8100c27
    int32_t result = v6; // 0x8100c27
    uint32_t v7 = (int32_t)(v4 % v5); // 0x8100c27
    uint64_t v8 = (v6 & 0xffffffff) * (int64_t)(a3 << v2); // 0x8100c2e
    uint32_t v9 = (int32_t)(v8 / 0x100000000); // 0x8100c2e
    if (v7 < v9 || a1 << v2 < (int32_t)v8 == v7 == v9) {
        // 0x8100c68
        return result - 1;
    }
    // 0x8100bc4
    return result;
}

// --------------- Dynamically Linked Functions ---------------

// size_t __argz_count(const char * argz, size_t len);
// void __argz_stringify(char * argz, size_t len, int sep);
// const unsigned short int ** __ctype_b_loc(void);
// const __int32_t ** __ctype_toupper_loc(void);
// int * __errno_location(void);
// int __fxstat64(int ver, int fildes, struct stat64 * stat_buf);
// int __printf_chk(int flag, const char * restrict format, ...);
// void * __rawmemchr(const void * s, int c);
// int __snprintf_chk(char * restrict s, size_t n, int flag, size_t slen, const char * restrict format, ...);
// void __stack_chk_fail(void);
// char * __strdup(const char * string);
// int __vfprintf_chk(FILE * restrict stream, int flag, const char * restrict format, _G_va_list ap);
// int __vsnprintf_chk(char * restrict s, size_t n, int flag, size_t slen, const char * restrict format, _G_va_list ap);
// int _IO_getc(_IO_FILE * fp);
// unsigned int alarm(unsigned int seconds);
// void * bsearch(const void * key, const void * base, size_t nmemb, size_t size, __compar_fn_t compar);
// void * calloc(size_t nmemb, size_t size);
// int close(int fd);
// void exit(int status);
// int fclose(FILE * stream);
// int fflush(FILE * stream);
// char * fgets_unlocked(char * restrict s, int n, FILE * restrict stream);
// FILE * fopen64(const char * restrict filename, const char * restrict modes);
// __pid_t fork(void);
// int fputc(int c, FILE * stream);
// void free(void * ptr);
// int fscanf(FILE * restrict stream, const char * restrict format, ...);
// char * getcwd(char * buf, size_t size);
// __gid_t getegid(void);
// char * getenv(const char * name);
// __uid_t geteuid(void);
// __gid_t getgid(void);
// int gettimeofday(struct timeval * restrict tv, __timezone_ptr_t tz);
// __uid_t getuid(void);
// int32_t gnutls_bye(void);
// int32_t gnutls_certificate_type_get(void);
// int32_t gnutls_certificate_type_get_name(void);
// int32_t gnutls_cipher_get(void);
// int32_t gnutls_cipher_get_name(void);
// int32_t gnutls_compression_get(void);
// int32_t gnutls_compression_get_name(void);
// int32_t gnutls_deinit(void);
// int32_t gnutls_kx_get(void);
// int32_t gnutls_kx_get_name(void);
// int32_t gnutls_mac_get(void);
// int32_t gnutls_mac_get_name(void);
// int32_t gnutls_protocol_get_name(void);
// int32_t gnutls_protocol_get_version(void);
// int32_t Gpm_Close(void);
// size_t iconv(iconv_t cd, char ** restrict inbuf, size_t * restrict inbytesleft, char ** restrict outbuf, size_t * restrict outbytesleft);
// int iconv_close(iconv_t cd);
// iconv_t iconv_open(const char * tocode, const char * fromcode);
// int32_t idna_to_ascii_lz(void);
// struct tm * localtime(const time_t * timer);
// void * malloc(size_t size);
// void * memchr(void * s, int c, size_t n);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// void * memmove(void * dest, const void * src, size_t n);
// void * mempcpy(void * restrict dest, const void * restrict src, size_t n);
// void * memset(void * s, int c, size_t n);
// time_t mktime(struct tm * tp);
// void * mmap64(void * addr, size_t len, int prot, int flags, int fd, __off64_t offset);
// void * mremap(void * addr, size_t old_len, size_t new_len, int flags, ...);
// int munmap(void * addr, size_t len);
// char * nl_langinfo(nlitem __item);
// int open64(const char * file, int oflag, ...);
// void qsort(void * base, size_t nmemb, size_t size, __compar_fn_t compar);
// ssize_t read(int fd, void * buf, size_t nbytes);
// void * realloc(void * ptr, size_t size);
// int select(int nfds, fd_set * restrict readfds, fd_set * restrict writefds, fd_set * restrict exceptfds, struct timeval * restrict timeout);
// char * setlocale(int category, const char * locale);
// int sigaction(int sig, const struct sigaction * restrict act, struct sigaction * restrict oact);
// int sigfillset(sigset_t * set);
// __sighandler_t signal(int sig, __sighandler_t handler);
// unsigned int sleep(unsigned int seconds);
// char * stpcpy(char * restrict dest, const char * restrict src);
// char * strchr(char * s, int c);
// int strcmp(const char * s1, const char * s2);
// char * strcpy(char * restrict dest, const char * restrict src);
// char * strerror(int errnum);
// size_t strlen(const char * s);
// char * strncpy(char * restrict dest, const char * restrict src, size_t n);
// char * strrchr(char * s, int c);
// char * strstr(char * haystack, const char * needle);
// long int strtol(const char * restrict nptr, char ** restrict endptr, int base);
// long int sysconf(int name);
// int tcsetattr(int fd, int optional_actions, const struct termios * termios_p);
// void * tfind(const void * key, void * const * rootp, __compar_fn_t compar);
// time_t time(time_t * timer);
// void * tsearch(const void * key, void ** rootp, __compar_fn_t compar);
// int ungetc(int c, FILE * stream);
// int unlink(const char * name);
// ssize_t write(int fd, const void * buf, size_t n);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (4.4.5)
// Detected functions: 291

